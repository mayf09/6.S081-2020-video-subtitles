1
00:00:00,810 --> 00:00:02,640
好的。
Yep.

2
00:00:05,770 --> 00:00:07,960
嘿，大家能听到我说话吗？
Hey buddy, people hear what I'm saying.

3
00:00:07,960 --> 00:00:10,210
很好，能听到。
You're good, good.

4
00:00:11,020 --> 00:00:15,070
好的，我想像上周一样开始，
Awesome, I just want to get started with similar to last week

5
00:00:15,070 --> 00:00:18,400
上周，我们问了一些 util 实验的问题，
where we asked you about, the util lab,

6
00:00:18,400 --> 00:00:20,920
我想先问一下 syscall 实验的情况，
I just want to get started by asking a little bit about syscall lab,

7
00:00:20,920 --> 00:00:23,890
因为那是周四到期的。
since that was due on Thursday.

8
00:00:24,520 --> 00:00:29,200
所以如果有人在实验中发现什么特别有趣的东西
So if anybody just has like something particularly interesting, they found about the lab

9
00:00:29,200 --> 00:00:31,030
或者发现一个难缠的 bug ，
or a nasty bug that they found

10
00:00:31,030 --> 00:00:32,920
或者只是犯了一个愚蠢的错误，
or just a silly mistake they made,

11
00:00:32,920 --> 00:00:36,410
关于 syscall 实验，任何你想分享的都可以。
anything you want to share about the syscall lab to be， [that'd be great.]

12
00:00:38,450 --> 00:00:45,470
不知道什么原因，我删除了 fork 中需要通过 mask 复制的部分，
I somehow managed to delete the part from where from fork where you have to copy over the mask,

13
00:00:45,470 --> 00:00:49,490
我让它工作，然后我修改了其他东西，然后我测试它，
so I had that working and then I change something else and then I tested it for.

14
00:00:50,200 --> 00:00:51,880
你好像掉线了。
Your audio is like cutting out.

15
00:00:51,880 --> 00:00:54,660
哦，抱歉，你能听到我说话吗？
Oh, it is sorry, you hear me.

16
00:00:58,060 --> 00:00:58,750
我听到了。
I hear you.

17
00:00:59,380 --> 00:01:00,280
好的。
Oh, okay.

18
00:01:00,820 --> 00:01:03,250
我想是的。
Yeah I guess.

19
00:01:03,680 --> 00:01:07,490
基本上我以某种方式删除了 mask 的复制，
So basically I deleted somehow the copy of the mask

20
00:01:07,490 --> 00:01:10,910
然后我的 fork 就不能用了，
and then my my fork didn't work anymore,

21
00:01:11,120 --> 00:01:14,000
所以我想，之前还是好的，现在怎么不能用了，
so then I was just like I did that, how does it not work,

22
00:01:14,240 --> 00:01:17,580
我花了很多时间去找问题。
so spend a lot of time figuring out. What I did wrong.

23
00:01:17,610 --> 00:01:20,400
我意识到我把那行删除了。
And I realized I just deleted that line from the.

24
00:01:22,820 --> 00:01:25,640
有没有人听不到 Luca ，还是只有我这边。
Is anybody having trouble hearing Luca, is that on my end.

25
00:01:26,290 --> 00:01:27,370
我想只是你那边。
I think its on your end.

26
00:01:28,000 --> 00:01:28,900
是的，我这边是好的。
Yeah I'm fine.

27
00:01:32,290 --> 00:01:33,610
那一定是我这边的问题。
This must be on my end.

28
00:01:56,320 --> 00:01:57,970
抱歉，现在应该好了。
Sorry, maybe that'll work better now.

29
00:02:02,760 --> 00:02:06,330
现在能听到我说话吗？好的。
Can you hear me now, okay great.

30
00:02:06,330 --> 00:02:08,550
我还担心我这边。
I was worried that I was just talking.

31
00:02:08,550 --> 00:02:11,130
不，好像是我这边的问题。
No, no, seems to be on my end.

32
00:02:11,400 --> 00:02:12,000
好的。
Alright.

33
00:02:16,870 --> 00:02:21,850
好的，还有人想分享关于 syscall 的任何事情吗？
Awesome, will anybody else have anything they'd like to share about you of syscall.

34
00:02:24,190 --> 00:02:25,990
有什么特别有趣的，
Anything particularly interesting,

35
00:02:25,990 --> 00:02:28,690
或者实验太难了，
or was the lab absolutely horrendous

36
00:02:28,690 --> 00:02:32,110
你觉得我们应该把它从课程中删掉，再也不做了。
and you think we should cut it out of the class, never do it again.

37
00:02:33,430 --> 00:02:40,480
我有一些东西，概括来说，事情的顺序很重要，
I have something, apparently the order of things matters which is a general statement,

38
00:02:40,780 --> 00:02:48,460
我试着理解 syscall 函数内的代码，
so I tried to determine the mass computation inside the syscall function.

39
00:02:48,980 --> 00:02:52,400
在理解之前，我需要先做 tracing 。
Before determining whether I actually needed to do the tracing.

40
00:02:53,100 --> 00:02:59,220
所有系统调用都能正确跟踪，除了 trace call 。
And so all the syscall we're getting correctly traced except that trace call.

41
00:02:59,560 --> 00:03:02,500
这件事让我心烦意乱，
And I was really getting disturbed by that,

42
00:03:02,500 --> 00:03:04,480
直到 David 指出，
until I think it was David who pointed out,

43
00:03:04,480 --> 00:03:10,040
你知道，应该在 trace 之后进行计算。
you know you should do the computation after [you should trace] just like that's fun.

44
00:03:10,790 --> 00:03:14,770
好的，很高兴你能找到这一点。
Alright. I'm glad you were able to catch that.

45
00:03:15,220 --> 00:03:17,050
是的，顺序确实很重要，
Yeah order does matter,

46
00:03:17,080 --> 00:03:22,120
特别是对页表来说，你们会发现，顺序在那里也很重要，
especially for page tables, you'll find I think that order matters there as well

47
00:03:22,120 --> 00:03:26,220
而且贯穿整个课程，注意事物的顺序很重要。
and generally throughout the class, paying attention to the order of things will be important.

48
00:03:28,140 --> 00:03:30,360
最好不要覆盖页表中的内容。
It's good to not overwrite things in page table.

49
00:03:31,630 --> 00:03:35,970
我也有一些东西，事实上我现在仍然对此感到困惑。
I also had something which I'm actually still confused about.

50
00:03:36,120 --> 00:03:42,000
我在调试内核代码时用了很多 print 语句。
Well I had a lot of debugging print statements in the kernel code.

51
00:03:42,870 --> 00:03:47,520
然后我把所有的位都设置好，运行 trace ，
I then ran that trace thing with all of the bits set,

52
00:03:47,610 --> 00:03:50,850
基本上跟踪了所有的系统调用。
so basically tracing all the system calls.

53
00:03:51,520 --> 00:03:59,860
我看到了内核中很多 print 语句的跟踪，然后。
And, I think I saw a lot of tracing for the print statements in the kernel, and then.

54
00:04:00,410 --> 00:04:09,110
然后我假设我的 print 程序读取和写入控制台，
Because and then I assumed that my print my print apps were trying to read and write to the console,

55
00:04:09,140 --> 00:04:11,030
确实会写入控制台，
but that do write to the console,

56
00:04:11,030 --> 00:04:14,840
但我想知道是为什么。
but then I was wondering why are we.

57
00:04:15,110 --> 00:04:19,190
我想，我困惑的是，为什么可以在内核中使用 printf 。
I guess, I'm just confused why we're able to use printf in the kernel.

58
00:04:22,670 --> 00:04:26,840
我最近没有看过 printf 的代码，
Yeah I'm not I haven't looked at the printf code recently,

59
00:04:26,840 --> 00:04:29,860
但是我想有一个 printf.c 文件，
but I think there's a file printf.c

60
00:04:29,860 --> 00:04:31,630
你可以自己看一下。
you might be a look at if you want to.

61
00:04:32,160 --> 00:04:35,990
嗯，这里发生了什么，
Um, here what was going on there,

62
00:04:35,990 --> 00:04:38,270
我认为 printf 函数是在那里实现的。
so I think the printf function should be [implemented in there].

63
00:04:41,120 --> 00:04:42,320
至少我们的版本是这样的，
At least our version of it,

64
00:04:42,530 --> 00:04:48,120
我不知道，或许其他工作人员可能知道是怎么回事。
I don't know perhaps one of the what are some of the other core staff might know what's going on.

65
00:04:49,270 --> 00:04:53,530
在跟踪的时候，内核中的 printf 不应该出现，
And the printf in the kernel shouldn't show up as your traces,

66
00:04:53,530 --> 00:04:56,530
因为内核中的 printf 不做任何系统调用。
because printf in the kernel doesn't call any system calls.

67
00:04:58,000 --> 00:04:59,890
是的，我也是这么想的，
Yeah that's what I thought,

68
00:04:59,890 --> 00:05:03,700
也许 tracing 不是从那里来的。
maybe that maybe the tracing was not from that.

69
00:05:04,680 --> 00:05:07,080
是的，我不认为它来自内核中的 printf 。
Yeah I don't think it is from your printf in the kernel.

70
00:05:08,240 --> 00:05:08,960
好的。
Okay.

71
00:05:12,370 --> 00:05:18,490
好的，除非还有人对 syscall 有别的评论，
OK, well unless anybody has any other burning comments about syscall,

72
00:05:18,490 --> 00:05:22,810
我想我们可以开始今天的讲座了。
I think we can get started with lecture for today.

73
00:05:23,290 --> 00:05:32,710
我将谈谈 C 语言转换为汇编语言的过程和处理器，
I'll be talking a little bit about the process of converting C to assembly and processors,

74
00:05:32,710 --> 00:05:35,380
今天更多是一个实用的讲座，
and this is more of a practical lecture today

75
00:05:35,380 --> 00:05:36,640
至少这是我们的目标。
or at least that's the aim,

76
00:05:36,640 --> 00:05:43,550
我们的目标是让你们熟悉 RISC-V ，
so the goal here is to get you all familiarized with RISC-V,

77
00:05:43,550 --> 00:05:49,340
熟悉它的处理器、汇编语言和调用约定。
the processor, the assembly language and calling conventions for RISC-V.

78
00:05:49,340 --> 00:05:50,600
这是非常重要的，
And this will be important,

79
00:05:50,600 --> 00:05:53,390
虽然对页表来说不是特别重要，
in not not super important for page table,

80
00:05:53,390 --> 00:05:58,100
但是对于这周布置的的 traps 实验来说是这样的。
but certainly for the traps lab which is will be assigned later this week,

81
00:05:58,100 --> 00:06:01,970
对于调试和实现都是必不可少的，
this will be essential for debugging and implementing things,

82
00:06:01,970 --> 00:06:07,160
因为你将直接使用 trap frame 和堆栈之类的东西，
because you'll be working quite intimately with trap frame and stack and things like that,

83
00:06:07,490 --> 00:06:09,530
所以这就是今天的目标。
so that's the that's kind of the goal for today.

84
00:06:09,530 --> 00:06:12,860
我的第一个目标是，
And, my first aim was to,

85
00:06:12,950 --> 00:06:17,030
这是对 6.004 课程的一点回顾，
this might be a little bit of review from 6.004

86
00:06:17,030 --> 00:06:21,950
或者你学过的任何其他计算机体系结构课程。
or any other computer architecture theme classes that you may have taken in the past,

87
00:06:22,040 --> 00:06:26,240
我只想简单回顾一下，
but I just want to go over briefly kind of see

88
00:06:26,270 --> 00:06:29,570
C 语言是如何转换成汇编语言的，
the C language, how we get to assembly

89
00:06:29,750 --> 00:06:32,420
还有一点处理器相关的知识。
and I'm maybe a little bit about processor.

90
00:06:32,420 --> 00:06:36,070
当然，在这节课的整个过程中，
So, throughout, and then of course throughout this lecture,

91
00:06:36,070 --> 00:06:39,610
如果你有任何问题，可以随时打断我并提问。
feel free to interrupt with any questions that you have.

92
00:06:41,050 --> 00:06:45,340
你知道，在 C 程序中，一般都有 main 函数。
So, you know, we have our normal main functions in C.

93
00:06:45,700 --> 00:06:51,930
它们会做一些事情，也许是打印一些东西，然后退出。
You know they do something, maybe they print something, then they exit.

94
00:06:53,680 --> 00:06:56,050
这些看起来都很好，
And this all looks well and good,

95
00:06:56,050 --> 00:06:59,410
但正如你们从 6.004 知道的，
but as any of you are aware from 6.004,

96
00:06:59,410 --> 00:07:03,280
处理器实际上并不理解 C 语言，
processors don't actually understand the C language,

97
00:07:03,280 --> 00:07:06,520
它们理解的是我们称为汇编的东西，
rather they understand what we call a assembly

98
00:07:06,520 --> 00:07:09,880
或者更具体地说，它们理解的是汇编的二进制编码，
or more specifically they understand the binary encoding of assembly,

99
00:07:10,150 --> 00:07:13,300
这里我在照片中圈出来的
and so this here I've circled a picture of

100
00:07:13,300 --> 00:07:16,420
是 SiFive 板上真正的 RISC-V 处理器。
an actual RISC-V processor from a SiFive board,

101
00:07:16,510 --> 00:07:20,140
而且当我们说处理器是 RISC-V 时，
and when we say a processor is RISC-V,

102
00:07:20,140 --> 00:07:23,980
意思是它可以理解 RISC-V 指令集，
that means that it understands the RISC-V instruction set,

103
00:07:24,220 --> 00:07:30,460
每个处理器都有关联的 ISA 或指令。
so every processor has an associated ISA or instruction.

104
00:07:31,010 --> 00:07:33,800
那就是一套指令集。
And that's kind of the set of instructions,

105
00:07:34,890 --> 00:07:36,870
对处理器来说是可以理解的，
that makes sense to that processor,

106
00:07:36,870 --> 00:07:41,580
每条指令都有相关的二进制编码或操作码。
so every instruction has an associated binary encoding or an op code.

107
00:07:42,480 --> 00:07:44,760
当处理器运行时，
And when a processor is running

108
00:07:44,760 --> 00:07:48,240
会看到一种特殊的编码，然后知道该怎么做。
and it sees a particular encoding, it knows what to do.

109
00:07:48,540 --> 00:07:56,150
所以，你知道这块板上的处理器理解 RISC-V 汇编，
And so, you know this processor on this board happens to understand the RISC-V assembly

110
00:07:56,150 --> 00:07:58,910
汇编从 C 代码编译而来，
which is what C code is compiled to,

111
00:07:58,910 --> 00:08:03,920
所以让 C 代码真正在处理器上运行的一般过程是，
so the general process of getting C code to actually run on your processor is,

112
00:08:03,920 --> 00:08:06,950
编写 C 代码，然后编程成汇编语言，
we start with C, it gets compiled to assembly,

113
00:08:06,950 --> 00:08:09,950
这之间还发生了一些链接之类的事情，
and there's some linking and things like that happened between this step

114
00:08:09,950 --> 00:08:12,650
不过我们不是一门编译器课程，
but that's we are not a compiler class,

115
00:08:12,710 --> 00:08:18,120
然后汇编语言会被翻译成二进制。
so and then the assembly will then be translated into binary,

116
00:08:18,120 --> 00:08:26,110
这就是我们看到的 obj 或 .o 文件。
and so this is the object or .o files that you see.

117
00:08:26,110 --> 00:08:32,980
如果你在运行 make qemu 之后注意过实验目录中的内容，
so if you've ever paid attention to what's inside of your lab directory after you run make qemu,

118
00:08:32,980 --> 00:08:36,160
你会看到很多 .o 文件散落在各处，
you'll see a bunch of .o files lying around

119
00:08:36,250 --> 00:08:40,150
这些就是处理器能够理解的目标文件。
and those are the actual object files that the processor understands.

120
00:08:41,030 --> 00:08:43,070
你们也看到了 asm 文件，
And the asm files, you've also seen,

121
00:08:43,100 --> 00:08:47,210
你还没有写过任何汇编代码，但是如果你回想 syscall ，
you haven't really written any, but if you recall from syscall,

122
00:08:47,210 --> 00:08:51,980
usys.pl 文件被编译成 usys.S ，
usys.pl is compiled to a file called usys.S,

123
00:08:52,040 --> 00:08:56,270
而 .S 文件就是汇编，
and so .S files are assembly language,

124
00:08:56,270 --> 00:08:59,570
所以你肯定已经到了一些 RISC-V 汇编
and so you've seen you've certainly seen some RISC-V assembly

125
00:08:59,570 --> 00:09:00,980
如果你学过 6.004 ，
and if you took 6.004,

126
00:09:01,040 --> 00:09:04,610
我相信你也看到过很多汇编代码。
I believe you've also seen a good amount of assembly language.

127
00:09:05,480 --> 00:09:10,100
一般来说，汇编看起来比 C 语言的结构化程度要低得多，
An assembly looks in general much less structured than C,

128
00:09:10,100 --> 00:09:14,480
你会看到一行接一行的指令，
so you'll just see line after line after line of instructions,

129
00:09:14,480 --> 00:09:22,200
你会看到一些简单的东西，比如 add mult 等。
you'll see simple things like add mult etc, and so on and so forth,

130
00:09:22,200 --> 00:09:27,420
它也没有好的控制流，没有循环语句，
and this doesn't have no nice control flow, there's no loops,

131
00:09:27,450 --> 00:09:31,140
有函数，但不是 C 语言那种函数，
there are functions but not in the sense that you might remember from C,

132
00:09:31,140 --> 00:09:35,100
我们看到的是标签，而不是真正的函数定义。
we see labels as opposed to true function definitions.

133
00:09:36,500 --> 00:09:38,990
汇编语言，是一种低级语言，
And the assembly, so it's a much lower language

134
00:09:38,990 --> 00:09:42,080
还有很多其他语言可以编译成汇编语言，
and there are plenty of other languages that are also compiled to assembly,

135
00:09:42,080 --> 00:09:47,600
比如，同样的过程也适用于 C++ 。
so, the same process holds true for things like C++.

136
00:09:47,780 --> 00:09:51,910
嗯，你知道任何一种编译语言，
Um, you know any any language that's compiled

137
00:09:51,910 --> 00:09:55,120
最终生成相同的汇编语言。
will go to the same assembly language at the base.

138
00:09:56,700 --> 00:10:01,080
这就是运行的基本过程，
And, so that's kind of the basic process of

139
00:10:01,080 --> 00:10:06,210
计算机真正理解我们编写的 C 代码，
getting our computer to actually understand the C code that we're writing,

140
00:10:06,420 --> 00:10:13,380
但要注意，我们指的是 RISC-V 汇编。
but you'll notice that we've been referring to RISC-V assembly.

141
00:10:13,620 --> 00:10:16,110
在整个课程中，处理器都是 RISC-V ，
Throughout the course and the processor is RISC-V

142
00:10:16,110 --> 00:10:20,550
这很重要是因为有许多不同类型的汇编，
and that's because, it it's important because there's many different kinds of assembly,

143
00:10:20,550 --> 00:10:25,360
你可能不会自己使用 RISC-V ，
so it's unlikely that you're using RISC-V yourself,

144
00:10:25,360 --> 00:10:27,670
比如你不会在上面运行 Linux ，
like you're not going to be running Linux on it,

145
00:10:27,760 --> 00:10:36,520
相反，大多数现代计算机在 x86 上运行，或者有时候看到的 x86-64 。
instead most modern computers will run on what's called x86 or you'll sometimes see is x86-64.

146
00:10:37,720 --> 00:10:42,370
这是一个不同的 ISA ，不同的指令集，
And this is this is a different ISA, this is a different instruction set,

147
00:10:42,370 --> 00:10:44,200
它看起来与 RISC-V 很像，
it looks pretty similar to RISC-V,

148
00:10:44,230 --> 00:10:48,340
但这是你经常在个人电脑上看到的。
but this is what you see in kind of your personal computers often.

149
00:10:51,760 --> 00:10:54,820
所以，如果你使用英特尔处理器，
So if you use an Intel

150
00:10:54,820 --> 00:11:01,220
英特尔 CPU 实现了 x86 ，还有 AMD 。
so Intel CPU's implement x86 and I believe AMD also do.

151
00:11:02,090 --> 00:11:07,800
这是两者之间相对重要的区别，
And [this is] relatively important distinction between the two,

152
00:11:07,800 --> 00:11:11,250
它们并不像看起来那么类似，
they're not quite as similar as they may look at first

153
00:11:11,400 --> 00:11:17,130
这归结于一个事实， RISC-V 是我们所说的 RISC ，
and that comes down to the fact that RISC-V is what we call as a RISC,

154
00:11:17,130 --> 00:11:21,990
RISC-V 的 RISC 部分指的是精简指令集。
the RISC part of RISC-V refers to a reduced instruction set.

155
00:11:22,710 --> 00:11:30,660
而 x86-64 是所谓的 CISC 或复杂指令集。
And x86-64 is what's called a CISC or complex instructions.

156
00:11:34,570 --> 00:11:38,260
这里有几个关键的不同之处，
And there's a couple of key differences here,

157
00:11:38,260 --> 00:11:42,640
其中之一就是 x86-64 中存在的指令数量，
one is just the number of instructions that are present in x86-64,

158
00:11:42,640 --> 00:11:50,230
事实上，创建 RISC-V 的动机之一就是
in fact one of the big motivations for writing, for for making RISC-V was

159
00:11:50,230 --> 00:11:54,220
我们实际上有多少指令。
how many instructions we actually have.

160
00:11:54,940 --> 00:12:00,760
在英特尔手册里，有三本完整的书可供参考。
In the Intel kind of handbook, so for reference, there's three full books,

161
00:12:02,150 --> 00:12:06,770
包括 ISA 和一些统计数据，
that encompass the ISA and some statistics,

162
00:12:06,770 --> 00:12:17,560
新的指令仍然以每月三个指令的速度增加。
I think there's new instructions have been added at a rate of three instructions per month.

163
00:12:18,720 --> 00:12:24,030
自从 x86-64 发布，它最早是在七十年代发布的，
Since x86-64 was added, it was first published in the seventies,

164
00:12:24,030 --> 00:12:33,130
大概有 15000 多条指令在 x86-64 中。
so I believe there's like north of 15,000 instructions in x86-64.

165
00:12:34,240 --> 00:12:37,210
而 RISC-V 则相反，
And RISC-V on the other hand,

166
00:12:37,570 --> 00:12:41,170
RISC-V 的程序集可以包含在两个文档中。
the assembly for RISC-V can be nicely contained within two documents.

167
00:12:41,170 --> 00:12:44,320
某种程度上，
And so, a kind of going off of that,

168
00:12:44,410 --> 00:12:50,230
在这门课上，我们不需要你们记住 RISC-V 的每一条指令，
we don't expect you in this course to memorize every single RISC-V instruction,

169
00:12:50,290 --> 00:12:52,330
但是如果你感兴趣，
but if you are interested

170
00:12:52,330 --> 00:12:57,250
或者发现哪条指令自己不清楚，
or you ever find yourself confused by what a specific instruction is or does,

171
00:12:57,550 --> 00:12:59,710
如果你访问课程网站，
if you go to the course website

172
00:12:59,950 --> 00:13:02,710
我们可以在 references 菜单下看到，
and we look under the references tab,

173
00:13:03,460 --> 00:13:10,060
在 RISC-V 下，我们提供了特权指令和非特权指令集的链接，
under RISC-V we give you the links to both the privileged and unprivileged instruction sets,

174
00:13:10,300 --> 00:13:16,710
这个文档给出了很多关于 ISA 的信息，
so this is kind of the document that gives you a whole bunch of information about the ISA,

175
00:13:16,800 --> 00:13:22,800
但是注意，这个有 240 页，这个有 135 页，
but you'll note that like this is 240 pages, and this is 135 pages,

176
00:13:22,800 --> 00:13:28,590
所以它比 x86 指令集小得多，
so it's significantly significantly smaller than the x86 instruction set,

177
00:13:28,620 --> 00:13:33,060
这是 RISC-V 的优点之一，
that's one of the nice things about, about RISC-V,

178
00:13:33,330 --> 00:13:39,960
因此，在 RISC-V 中，我们的指令更少，
so we have in RISC-V we have fewer instructions

179
00:13:39,960 --> 00:13:43,730
而且指令更简单。
and not only that, the instructions are simpler.

180
00:13:44,340 --> 00:13:47,540
所以，我的意思是，
So, what I mean by that is that,

181
00:13:48,800 --> 00:13:52,580
在 x86-64 中有许多指令，
there are many instructions in x86-64 by,

182
00:13:52,580 --> 00:13:56,450
比如，有 add mul sub 等。
for example, that referring to something like add or mul sub.

183
00:13:57,020 --> 00:14:01,190
在 x86-64 中，有很多指令不仅做一件事，
In x86-64 there's plenty of instructions, that do more than one thing,

184
00:14:01,190 --> 00:14:07,430
它们会执行一些复杂的操作，然后给出结果，
so they perform some complicated set of operations and then gets you the result

185
00:14:07,430 --> 00:14:13,490
而 RISC-V 则不同，指令的范围往往较小，
and that's not the case with RISC-V RISC-V instructions tend to be smaller in scope,

186
00:14:13,490 --> 00:14:18,860
比 x86-64 用更小的周期来运行每条指令，
and so they take less cycles to run each instruction then maybe x86-64 is

187
00:14:18,950 --> 00:14:23,000
这只是设计者选择的一种权衡。
and this is just a trade-off that the designers chose to chose to undertake.

188
00:14:23,270 --> 00:14:29,640
没有什么规范的理由，
There's nothing or you know there's no canonical reason

189
00:14:29,640 --> 00:14:36,090
为什么精简指令集比复杂指令集好，
why I reduced instruction set is better than you know a complex induction instruction set,

190
00:14:36,090 --> 00:14:40,110
它们各有其用途，
they each have their own uses, and so on and so forth

191
00:14:40,110 --> 00:14:46,650
与 x86 相比， RISC-V 还有一个很酷的地方，就是它是开源的，
and another cool thing about RISC-V as opposed to x86 is that, this is open source,

192
00:14:47,740 --> 00:14:53,620
是市面上仅有的开源指令集之一，
so one of the only open source instruction sets on the market,

193
00:14:53,620 --> 00:14:56,680
这意味着任何人都可以为 RISC-V 开发电路板，
so that means anybody can develop a board for RISC-V

194
00:14:56,860 --> 00:15:01,570
它来自加州大学伯克利分校的一个研究项目，
and it came out of a research project from UC Berkeley

195
00:15:01,570 --> 00:15:03,850
这就是 RISC-V 开始的地方，
and so that's kind of where was RISC-V started

196
00:15:03,940 --> 00:15:07,810
从那时起，它得到了很多公司的支持，
and since then it's been picked up and supported by a number of companies,

197
00:15:07,960 --> 00:15:09,640
你可以在网上找到这个列表，
you can find the list online,

198
00:15:09,640 --> 00:15:14,290
确实有很多大公司对支持开放指令集感兴趣。
but yeah there's tons of big companies that are interested in supporting an open instruction set.

199
00:15:14,990 --> 00:15:19,460
事实上，最近 SiFive 开了一场发布会，
And actually I think quite recently there was an announcement made by SiFive

200
00:15:19,460 --> 00:15:25,110
他们是 RISC-V 处理器的首屈一指的电路板制造商，
who are sort of the premier board manufacturer for RISC-V processors,

201
00:15:25,260 --> 00:15:30,780
他们将发布一款适用于个人电脑的电路板，
that they will be releasing a board for personal computers

202
00:15:30,780 --> 00:15:35,580
该板将采用 RISC-V 处理器，为了在个人电脑上运行 Linux ，
that should extensively a RISC-V processor designed to run Linux for personal computers

203
00:15:35,850 --> 00:15:40,230
我记得是在过去一两周开的发布会。
and I think that's been released in the last week or two, the announcement about it.

204
00:15:40,530 --> 00:15:43,800
如果你很好奇，如果你发现自己，
So if you're if you're curious if your find yourself

205
00:15:43,800 --> 00:15:48,090
你知道，我在完成 6.S081 之后，很想使用 RISC-V ，
you know absolutely I want to use RISC-V after I finish 6.S081,

206
00:15:48,120 --> 00:15:51,330
希望到那时候有处理器可用，
hopefully by that time there will be a processor available

207
00:15:51,330 --> 00:15:53,520
可以在自己的计算机上运行 Linux 。
that you can run Linux on your own computer.

208
00:15:55,080 --> 00:15:56,820
但是即使在日常生活中，
But even in your day-to-day lives,

209
00:15:56,820 --> 00:16:01,410
你也很可能使用了精简指令集，可能你没有意识到这一点，
you're most likely using reduced instruction set even if you don't realize it,

210
00:16:01,410 --> 00:16:06,710
所以 ARM 指令集， A R M ，
so the ARM assembly, so that's A R M,

211
00:16:07,000 --> 00:16:09,850
也是精简指令集。
this is also a reduced instruction set。

212
00:16:11,030 --> 00:16:18,790
And ARM is implemented by Qualcomm, the the snapdragon series of processors.

213
00:16:19,060 --> 00:16:29,430
所以，如果你有一部安卓手机，很可能运行的是精简指令集。
So if you have an android phone, you are most likely running a reduced instruction set.

214
00:16:30,200 --> 00:16:35,540
即使你用的是 iOS ，我忘了叫什么，
And even if you're using ios, ios I think I forget what the name of it,

215
00:16:35,540 --> 00:16:40,320
但是苹果也有一些版本的 ARM ，
but Apple has some has some version of ARM,

216
00:16:40,320 --> 00:16:42,780
他们也在自己的处理器上实现了，
they also implement in their own processors

217
00:16:42,810 --> 00:16:47,730
这些处理器运行在 iPad iPhone 和多数苹果的移动设备上，
that runs on ipads iphones and most mobile Apple devices,

218
00:16:47,940 --> 00:16:50,880
所以精简指令集随处可见，
so reduced instruction sets are present all over the place,

219
00:16:50,880 --> 00:16:54,180
如果你在现实世界中寻找 RISC-V ，
and if you're looking for a RISC-V in the real world,

220
00:16:54,870 --> 00:16:57,180
你知道，在 QEMU 之外，
you know outside of your QEMU,

221
00:16:58,170 --> 00:17:03,120
你可以在集成设备中找到它。
you'll be able to find that in like integrated devices.

222
00:17:03,890 --> 00:17:10,070
所以它是存在的，虽然不想 x86-64 那样广泛，
So it is present, it's not as certainly not as ubiquitous as something like x86-64

223
00:17:10,130 --> 00:17:11,810
但它是。
but it's um.

224
00:17:12,540 --> 00:17:19,000
Yes I yes I think Apple is as Lucas just said I think Apple is moving Mac to ARM.

225
00:17:19,000 --> 00:17:20,410
我相信情况也是如此，
I believe that's also the case,

226
00:17:20,560 --> 00:17:25,360
去年确实有一股精简指令集的热潮。
there's been in last year's definitely been a push towards reduced instruction sets .

227
00:17:25,960 --> 00:17:29,530
英特尔指令集为什么这么大？
Given given how big the Intel ISA has gotten.

228
00:17:29,530 --> 00:17:31,930
英特尔指令集这么大的原因是，
And the reason why Intel ISA is so big is because

229
00:17:31,930 --> 00:17:35,230
因为他们非常关心向后兼容性。
they're very concerned with backwards compatibility.

230
00:17:35,230 --> 00:17:36,460
所以如果你写了。
So if you write.

231
00:17:36,870 --> 00:17:41,100
一个现代英特尔处理器
A modern Intel processor can run the same instructions

232
00:17:41,130 --> 00:17:45,720
也可以运行三十四年前编写的指令，
that Intel code from you know 30 40 years ago was was written,

233
00:17:45,720 --> 00:17:50,280
他们不弃用任何指令，以保证向后兼容性，
it so they don't really deprecate any instructions so that they maintain backwards compatibility,

234
00:17:50,400 --> 00:17:53,730
RISC-V 更现代，所以不需要考虑这个。
that RISC-V is more modern, so it's not a worry RISC-V is.

235
00:17:53,730 --> 00:17:57,000
如果我们回到那些手册，
Also if we jump back to those manuals,

236
00:17:57,180 --> 00:17:59,820
RISC-V 的独特之处是它的指令是分开的，
RISC-V is unique in that it's divided,

237
00:17:59,820 --> 00:18:06,650
所有的 RISC-V 处理器都有基本整型指令集。
we have what's called the base integer instruction set which all RISC-V processors, um.

238
00:18:07,340 --> 00:18:08,270
如果我们有。
If we have fifteen.

239
00:18:08,270 --> 00:18:09,440
Gabriel 在聊天中问道，
Gabriel asks in the chat,

240
00:18:09,440 --> 00:18:13,400
如果有 15000 条指令，几乎不可能有效地使用它们，
if we have 15,000 instructions, it nearly impossible to efficiently pipeline them,

241
00:18:13,580 --> 00:18:14,660
那么为什么需要这么多。
why do we need so many.

242
00:18:15,110 --> 00:18:18,350
就像我说的，需要这么多指令，是出于向后兼容的原因，
Like I was saying we need so many for backwards compatibility reasons,

243
00:18:18,350 --> 00:18:22,340
这是由你自己决定的，你是否认为这是非常重要的。
it's up to you to decide you know whether you think that's super important.

244
00:18:22,340 --> 00:18:27,750
但是我想很多指令被简单的指令所[]，
But many of those instructions I think a ton of them are also [] by simply instructions

245
00:18:27,750 --> 00:18:30,870
这是它们特有的东西。
which are their own kind of special class of things.

246
00:18:31,850 --> 00:18:34,610
我从没见过
You won't I I I've never seen

247
00:18:34,610 --> 00:18:39,080
英特尔汇编代码能充分利用这 15000 条指令，
Intel assembly code that makes full uses full usage out of the 15,000 instructions,

248
00:18:39,080 --> 00:18:42,950
这主要是出于向后兼容的需要，并且保持简单。
but mostly this comes from a from a need for backwards compatibility and simply.

249
00:18:43,520 --> 00:18:48,530
就像我说的， RISC-V 有一个基本整型指令集，
But like I was saying the RISC-V has a what's called the base integer instruction set,

250
00:18:49,030 --> 00:18:54,340
它包含所有正常的加法、乘法运算，
which contains all of the normal add multiply things,

251
00:18:54,400 --> 00:18:58,630
然后处理器可以选择实现其他模块，
and then processors can choose to implement a number of other modules,

252
00:18:58,630 --> 00:19:00,400
你可以在这边看到，
which you can see along the side here,

253
00:19:00,400 --> 00:19:02,980
可能你在屏幕上看不清楚，
it's probably impossible to read on your screen,

254
00:19:02,980 --> 00:19:05,410
举个例子，如果你希望处理器
but for example if you want a processor,

255
00:19:05,470 --> 00:19:09,280
支持单精度浮点型标准扩展，
you know that supports standard extension for single precision floating point,

256
00:19:09,400 --> 00:19:11,260
你就可以包含 F 模块。
then you can include the F module.

257
00:19:11,960 --> 00:19:16,430
这使得 RISC-V 更容易支持向后兼容，
And this makes it easier for RISC-V to support backwards compatibility,

258
00:19:16,430 --> 00:19:22,010
因为你可以指出包含和支持哪些模块，
because if, you can just say what set of modules do I include and support

259
00:19:22,160 --> 00:19:24,290
而编译器可以选择。
and the compiler can choose.

260
00:19:24,290 --> 00:19:29,770
然后，编译器告诉我它支持这些模块，
Then, compiler can say okay, you know this processor is telling me it supports these modules,

261
00:19:29,770 --> 00:19:32,110
所以我可以用这些模块编译这段代码。
so I can only compile this code with these modules.

262
00:19:33,760 --> 00:19:35,560
好的， Bibik 说，
Okay, Bibik says

263
00:19:35,590 --> 00:19:39,160
似乎使用 x86 而不是 RISC-V 处理器的唯一优势是
it seems that the only advantage of using x86 instead of RISC-V processor

264
00:19:39,160 --> 00:19:40,480
可以获得更好的性能，
is the kind of performance you can get,

265
00:19:40,630 --> 00:19:45,130
然而，这种性能是以巨大的成本、复杂度和潜在的安全性为代价的，
however, that performance comes as a massive cost and complexity and potential security,

266
00:19:45,190 --> 00:19:47,710
我的问题是为什么我们还在使用 x86 ，
my question is why are we still using x86,

267
00:19:47,710 --> 00:19:49,480
而不是转向 RISC-V 。
instead of moving to something like RISC-V.

268
00:19:49,970 --> 00:19:54,560
好的，一个宽泛的答案是，世界运行在 x86 之上，
Well, a big answer that the world is run on x86,

269
00:19:54,590 --> 00:19:58,160
我也没有一个更好的答案。
for I I don't have a great answer for why.

270
00:19:58,370 --> 00:20:00,080
RISC-V 是相当现代的，
RISC-V is pretty modern too.

271
00:20:00,740 --> 00:20:05,210
世界几乎都运行在 x86 上，
So the world as a whole pretty much runs on x86,

272
00:20:05,210 --> 00:20:11,180
如果突然把处理器转换为 RISC-V ，
so if you suddenly start converting your processors to RISC-V,

273
00:20:11,180 --> 00:20:17,320
你会冒着失去对一些重要事情支持的风险。
you run the risk of, you know losing support for a bunch of important things,

274
00:20:17,380 --> 00:20:22,420
另外，英特尔在他们的处理器中也做了一些有趣的事情，
also there are like Intel does do interesting things within their processors,

275
00:20:22,510 --> 00:20:27,310
比如在安全方面，有 enclave ，
like security wise, there are enclaves on Intel processors

276
00:20:27,310 --> 00:20:30,430
而且近年来他们一直在做一些事情，
and there's things that they've been doing in recent years

277
00:20:30,430 --> 00:20:33,940
试图提供额外的安全性，
to try to try and give you extra added security

278
00:20:34,150 --> 00:20:37,240
英特尔确实实现了一些指令，
and some of those instructions that Intel does implement

279
00:20:37,240 --> 00:20:42,940
这些指令对某些特定的计算是非常有效的。
which are hyper specific can be really efficient for certain, computations.

280
00:20:43,250 --> 00:20:45,140
所以他们有这么多指令，
And so they have so many instructions,

281
00:20:45,140 --> 00:20:48,870
你知道，多数情况下，一种情况对应一条指令，
there's often you know, a perfect instruction for a situation

282
00:20:48,870 --> 00:20:53,120
这可能比 RISC-V 更有效。
that may be more efficient than then what exists within RISC-V,

283
00:20:53,210 --> 00:20:55,220
但一个更实际的答案是，
but a more practical answer is

284
00:20:55,220 --> 00:20:56,630
RISC-V 相对较新，
at RISC-V is relatively new

285
00:20:56,630 --> 00:21:00,350
还没有真正为个人电脑制造的处理器，
and we just don't know, nobody's really making processors for personal computers,

286
00:21:00,350 --> 00:21:03,260
SiFive 的发布会是最近举办的，
I think the SiFive announcement is super recent,

287
00:21:03,440 --> 00:21:06,650
他们可以说是第一批这样做的人。
and they're kind of the first people to be doing that.

288
00:21:06,650 --> 00:21:12,420
所以在实践上，不能运行所有为英特尔设计的软件，
so on a practical level, that and the inability to run all the software design for Intel

289
00:21:12,930 --> 00:21:14,970
这是我最好的答案。
is is my best answer.

290
00:21:16,210 --> 00:21:20,710
我们现在讲一下汇编，
So we've been now chatting a little bit about assembly,

291
00:21:20,710 --> 00:21:25,690
我想先看一些实际的汇编代码。
so I just wanted to take a look at some actual assembly code.

292
00:21:26,600 --> 00:21:31,580
这是一段 C 代码，
So here is the C code for what's below,

293
00:21:31,580 --> 00:21:34,100
有一个简单的函数，一个累加器，
so this is a simple function that has an accumulator,

294
00:21:34,190 --> 00:21:36,440
我们从 0 循环到 n ，
we loop from zero to n

295
00:21:36,440 --> 00:21:41,060
然后将 0 到 n 的所有数字加起来，
and we sum up all the numbers from from zero to n,

296
00:21:41,960 --> 00:21:43,550
然后返回这个值。
and then return that value.

297
00:21:43,760 --> 00:21:48,140
这是最简单的级别，最简单的汇编代码，
And at its simplest level, this is the easiest kind of assembly,

298
00:21:48,140 --> 00:21:50,510
你可以编译这段程序，
you can get out of compiling that program,

299
00:21:50,720 --> 00:21:56,930
如果你真的编写了 C 代码，并编译它，
if you actually go into your own computer and you write the C code and you try to compile it,

300
00:21:56,930 --> 00:22:00,470
你可能会得到一些看起来完全不同的东西。
you will end up with something that likely looks quite different.

301
00:22:01,420 --> 00:22:03,280
这是正确的，有不同的原因，
And that's true for a variety of reasons,

302
00:22:03,280 --> 00:22:06,760
我们会看到其中一些原因，还有一些是特定编译器的，
we have a some of which we'll get to and some of which are compiler specific,

303
00:22:07,090 --> 00:22:11,980
现代编译器进行了大量的优化，
so modern compilers make a large number of optimization ,

304
00:22:13,510 --> 00:22:16,000
当使用编译器将 C 编译成汇编时，
With it when they compile your C to assembly,

305
00:22:16,000 --> 00:22:18,160
所以你的汇编指令看起来可能会不同，
and so your assembly instructions may look different,

306
00:22:18,280 --> 00:22:21,280
例如，当你在 gdb 中调试时，
for instance while you're debugging in gdb,

307
00:22:21,280 --> 00:22:25,750
可能会遇到一些东西告诉你某个变量已经被优化，
you may come across something that tells you that it's some variable has been optimized out,

308
00:22:26,050 --> 00:22:30,010
意思是编译器决定不需要该变量，
and that means that the compiler decided it didn't need that variable

309
00:22:30,010 --> 00:22:33,370
因此，这个变量会从程序中消失。
and so that'll be gone effectively from the program,

310
00:22:33,610 --> 00:22:41,230
这是很直接的，我们把 a0 中的值移动到 t0 ，
but yeah and it's at its most straightforward, we're moving value that's in a0 the t0,

311
00:22:41,260 --> 00:22:42,940
我们把 a0 设置为 0 ，
we're setting a0 to zero

312
00:22:42,940 --> 00:22:47,890
然后把 t0 中的内容加到 a0 上，
and then we are just adding what's in t0 to a0,

313
00:22:47,890 --> 00:22:51,340
对循环中的每次迭代，直到 t0 变为 0 。
for every iteration of a loop until t0 reaches zero.

314
00:22:52,500 --> 00:22:54,060
这就是这段代码的意思。
And that's all that's going on in this piece.

315
00:22:54,090 --> 00:22:55,410
Amir, 你举手了。
Amir, your hands raised.

316
00:22:57,460 --> 00:23:01,900
我想知道 .section .text .global 是做什么的。
I was wondering what .section .text .global do.

317
00:23:02,420 --> 00:23:05,810
global 表示你可以从其他文件中包含这个，
A global means that you can include this from other files,

318
00:23:06,050 --> 00:23:12,860
如果我们去看，看一下 defs.h 。
so if we actually hop into, let's see defs.h.

319
00:23:14,220 --> 00:23:19,740
这是你后面会非常熟悉的文件，
This is the file that you're will, if you aren't already, you will become quite familiar with,

320
00:23:19,740 --> 00:23:24,480
包含内核中可能使用的所有函数
this includes basically all of the functions within the kernel that you may want to be using

321
00:23:24,870 --> 00:23:28,470
在这里，我们可以看到，
and within here you know we can see that,

322
00:23:28,470 --> 00:23:33,210
在我的文件中，已经包含了这些函数的定义，
in my my file, I've included the definitions to these functions,

323
00:23:33,360 --> 00:23:40,950
这样， .global 保证这些函数可以从其他地方调用，
and so that .global makes sure that, that these these functions can be called from other places

324
00:23:41,220 --> 00:23:43,530
而 .text 表示这是代码。
and .text just says this is code.

325
00:23:44,220 --> 00:23:48,720
如果你回想一下书中的图 3.4 ，
So if you recall from figure 3.4 in the book,

326
00:23:49,300 --> 00:23:54,510
我们去看那本书，
so that's if we go to the book,

327
00:23:56,380 --> 00:24:00,790
我们进入页表进程地址空间，
and we go into page tables process address space,

328
00:24:00,970 --> 00:24:06,640
在这张图中，这和 text 是一样的，表示代码。
so in here in this diagram, that's the same thing is text, so just means code.

329
00:24:09,440 --> 00:24:10,250
这回答了你的问题吗？
That answer your question?

330
00:24:10,730 --> 00:24:11,630
谢谢。
Thanks.

331
00:24:14,810 --> 00:24:17,180
如果我们想运行，嗯。
And so if we want to run, um.

332
00:24:17,670 --> 00:24:19,530
我们有一些汇编代码，
Let's say we have some assembly,

333
00:24:19,590 --> 00:24:24,900
如果你发现自己对内核代码感兴趣，
also if you ever find yourself interested in what the kernel looks like,

334
00:24:25,140 --> 00:24:31,830
我们可以进入，编译后你可以查看 kernel/kernel.asm 文件。
we can go inside the, after you compile you can look in the file kernel/kernel.asm.

335
00:24:32,800 --> 00:24:40,330
这是 xv6 内核的完整汇编代码，
And this is the full kind of assembly for the kernel of xv6,

336
00:24:40,330 --> 00:24:44,410
左边的每个数字都是一个标签，
and each of these numbers on the left here is a label

337
00:24:44,410 --> 00:24:48,160
告诉你这个指令在内存中的位置，
that tells you where in memory, this in this instruction will be

338
00:24:48,490 --> 00:24:50,290
这是很有用的。
and that will come in quite handy.

339
00:24:50,670 --> 00:24:53,820
所以，这就是实际的，
And so here is the here's the actual,

340
00:24:54,840 --> 00:24:59,910
使用实际的汇编代码，你可以看到函数的标签以及声明，
use the actual assembly code and you can see the labels for the functions and whether declared,

341
00:24:59,910 --> 00:25:04,380
这在我们调试代码时是非常有用的，
so this is this is, can be really really useful as we're debugging code

342
00:25:04,380 --> 00:25:06,900
稍后我将展示这一点。
and hopefully I'll be able to show that in a second.

343
00:25:07,540 --> 00:25:12,370
但是现在我们回到第一个函数 sum_to ，
But for now we'll jump back to this first function, sum_to

344
00:25:12,550 --> 00:25:16,750
我们看看如何在 gdb 中调试，
and we'll just see how we can examine that inside of gdb,

345
00:25:16,780 --> 00:25:21,460
第一步，这里我有两个窗口，
so the first step is I have my two windows here.

346
00:25:21,670 --> 00:25:24,670
.asm 和 .S 文件有什么不同？
What's the difference between .asm .S files?

347
00:25:25,170 --> 00:25:29,310
嗯，我也不是很确定，
Um, not a hundred percent certain,

348
00:25:29,430 --> 00:25:30,780
它们都是汇编，
they're both assembly,

349
00:25:30,780 --> 00:25:36,120
我想 .asm 文件包含了许多 .S 文件没有包含的额外注释，
I think the .asm file includes a bunch of extra annotations that aren't included in .S,

350
00:25:36,390 --> 00:25:40,570
通常情况下，你把 C 代码编译成 .S 时，
so usually when you compile your c code to .S,

351
00:25:40,570 --> 00:25:44,590
你会得到一些不包含行号的汇编代码，
you'll end up with something that doesn't include all those line numbers and things like that.

352
00:25:44,590 --> 00:25:47,700
如果你想知道如何获得 .asm 文件，
So, if you're curious about how we get asm file,

353
00:25:47,700 --> 00:25:52,530
我想 makefile 会告诉你获得它的准确步骤。
I think the makefile will tell you the exact steps used to get that.

354
00:25:55,960 --> 00:26:00,460
我们回到终端，我们有两个窗口，
And so if we're in our terminal, we have our two two windows,

355
00:26:00,580 --> 00:26:05,800
首先要做的当然是启动并运行 QEMU 。
so the first thing to do is of course get QEMU up and running.

356
00:26:06,630 --> 00:26:10,110
在 gdb 模式下启动，
So gdb, started within gdb mode,

357
00:26:10,110 --> 00:26:13,470
现在我们卡在这里，然后我们启动 gdb 。
so now we're frozen here and then we can start gdb,

358
00:26:15,990 --> 00:26:20,220
就像 Frans 教授上周展示的那样。
and what what what what professor Frans showed last week.

359
00:26:20,550 --> 00:26:22,980
我想有些人会很兴奋，
Which I think some people were excited,

360
00:26:22,980 --> 00:26:26,280
输入 tui enable ，会出现一个窗口，
you typed UI, enable you get this nice window

361
00:26:26,280 --> 00:26:30,150
现在是空的，但在你调试时会很有用，
which is empty for now but will come in quite useful as you're debugging,

362
00:26:30,390 --> 00:26:32,010
我们可以设置一个断点，
so we can set a break point

363
00:26:32,010 --> 00:26:37,170
应该注意到这些代码都在内核中，没有一个在用户空间，
and I should note that all this code is living inside the kernel, none of this is in user space,

364
00:26:37,440 --> 00:26:40,170
所以我们设置断点时没有什么烦人的问题，
so we don't have any of those annoying problems setting break points,

365
00:26:40,410 --> 00:26:45,840
我可以在函数 sum_to 设置一个断点，然后继续运行。
so I can set a break point in the function sum_to and then just continue running.

366
00:26:47,300 --> 00:26:55,880
现在运行该函数，你在 tui 中看到的第一个窗口是源码窗口，
Run that function and now, so the first window that you see in tui is the source window.

367
00:26:57,270 --> 00:27:03,540
是的，像 David 说的， kernel.asm 左边的数字是非常有用的，
Yes, as David is saying those those numbers on the left of kernel .asm are really useful

368
00:27:03,540 --> 00:27:08,130
当你调试的时候，你得到一个地址，它会告诉你，
when you're debugging things and you get an address it'll tell you,

369
00:27:08,130 --> 00:27:09,300
所以你可以看到，
so you can see now,

370
00:27:09,330 --> 00:27:14,560
我们可以在 gdb 中看到 PC ，即程序计数器，
even here we can see that the programs of PC here in gdb, is the program counter,

371
00:27:14,560 --> 00:27:18,220
我们可以看这个地址，以 800 开头的，
so we can see this address eight zero zero so on and so forth.

372
00:27:18,540 --> 00:27:24,240
如果我们查看 kernel.asm ，并查找那个地址，
If we go into kernel.asm and we search for that specific address,

373
00:27:24,270 --> 00:27:25,890
我们可以看到它在，
we can see that it's the,

374
00:27:26,860 --> 00:27:29,620
嗯，它出现了两次，因为函数调用，
um, it comes up twice because the function call,

375
00:27:29,740 --> 00:27:33,970
我们看这里，这就是那个地址，它是 sum_to 的开头。
but if we look here, this is that address, it's the top of the sum_to function.

376
00:27:34,760 --> 00:27:37,580
所以如果你在任何时候看到这些东西，
So if you see any time you see one of these,

377
00:27:37,610 --> 00:27:45,180
所有内核地址都是 0x8000 这样的数字。 
um all the kernel addresses will look something like a 0x8000 some numbers.

378
00:27:46,240 --> 00:27:50,290
这些地址你可以直接跳转到 kernel.asm ，
Those addresses you can jump straight into kernel.asm

379
00:27:50,290 --> 00:27:54,190
并找到发生问题的那一行，
and find the exact line of assembly where the problem is occurring,

380
00:27:54,190 --> 00:27:56,050
然后可以在相应地设置断点，
and then you can set your break points accordingly,

381
00:27:56,410 --> 00:28:00,700
现在 tui 的顶部窗口是源码窗口，
but for now, the top window in tui is source,

382
00:28:00,700 --> 00:28:07,390
如果我们想要查看汇编，可以在 gdb 中输入 layout asm ，
and if we want to look at specifically the assembly we can do layout in gdb asm,

383
00:28:07,390 --> 00:28:11,920
这会给我们所有的汇编指令，
and that'll give us all of the assembly instructions and ,

384
00:28:11,920 --> 00:28:14,830
如果我们输入 layout reg 还可以查看寄存器，
we can also look at the registers if we type layout reg,

385
00:28:14,830 --> 00:28:17,380
我们得到汇编和寄存器，
we'll get assembly and registers

386
00:28:17,620 --> 00:28:20,590
如果你要浏览什么东西，
and if you find yourself what to scroll through things,

387
00:28:21,410 --> 00:28:24,350
现在我们有三个窗口，需要指定聚焦在哪个窗口，
now that we have three windows, we need to specify which one is focused,

388
00:28:24,350 --> 00:28:27,260
如果我想查看所有的寄存器，输入 focus reg 。
so if I want to look for all the registers, I'm going to focus reg.

389
00:28:28,000 --> 00:28:30,220
现在我聚焦在了寄存器窗口，
And now my focus is on the register window

390
00:28:30,220 --> 00:28:34,960
这时移动箭头键或者滚动，就可以在那个窗口滚动了。
so I move the arrow keys or scroll you'll start scrolling that window.

391
00:28:35,660 --> 00:28:38,810
现在，我们聚焦在汇编窗口。
Now we can focus on the assembly window.

392
00:28:39,580 --> 00:28:41,800
我们到了这里，就可以看到所有的东西，
And once we're here, we can see all of the things,

393
00:28:42,040 --> 00:28:45,940
让我们看看，我们可以在寄存器窗口中看到，
so let's see, we can see in the registry register window,

394
00:28:45,940 --> 00:28:48,490
我们可以看到 t0 包含这个值，
we can see that t0 contains this value,

395
00:28:48,550 --> 00:28:51,250
可以看到 a0 包含这个值。
we can see that a0 contains this value.

396
00:28:51,840 --> 00:28:55,140
当我们单步执行汇编时，可以看到，
And as we step through the assembly, we can watch,

397
00:28:55,170 --> 00:29:00,150
t0 刚刚得到了 a0 的值，也就是 5 ，
say OK, t0 just got the value of a0 which was five,

398
00:29:00,150 --> 00:29:03,060
它也高亮显示了发生改变的寄存器。
and it's nicely highlighted the register that's changed.

399
00:29:03,280 --> 00:29:09,640
这里我们可以，如果按下 enter 键，会得到最近执行的命令，
Here and we can just, keep remember if we push enter we get the most recently executed instructions,

400
00:29:09,640 --> 00:29:12,880
我们继续，将 a0 设置为 0 ，
so we can go through, we set a0 to zero

401
00:29:13,030 --> 00:29:19,270
现在我们可以看到这个循环和其中一些值，
and now we can just kind of watch ourselves go through this loop and some of the values,

402
00:29:20,020 --> 00:29:22,840
这就像是一个完整的[]函数。
and then this is like a complete you know [] function.

403
00:29:23,630 --> 00:29:27,050
我们继续，
Then continue and live our lives

404
00:29:27,050 --> 00:29:31,700
如果你想知道设置了什么断点，
and if you're ever curious about what kind of break points you've set

405
00:29:31,700 --> 00:29:33,800
或者忘记了你在做什么，
or you lose track of what you were doing,

406
00:29:33,980 --> 00:29:37,940
输入 info break 或 breakpoints ，
if you type info break or breakpoints,

407
00:29:38,060 --> 00:29:41,120
就可以看到代码中设置的所有断点，
you can see all of the break points that you set in your code,

408
00:29:41,390 --> 00:29:45,410
你甚至可以看到，这个断点已经命中了一次，
and you can even see okay, this break point has already been hit one time

409
00:29:45,620 --> 00:29:48,560
这样你就能得到很多有用的信息。
and you get lots of useful information doing that.

410
00:29:49,410 --> 00:29:54,390
如果你不想使用寄存器窗口，但需要查看寄存器，
If you don't want to have the register window, but you do want to look at the registers,

411
00:29:54,510 --> 00:29:58,110
输入 info reg 或 info registers 或 i registers
info reg or info registers or i registers

412
00:29:58,110 --> 00:30:04,130
任何一个都可以调出寄存器窗口。
or any of the numerous gdb shortenings will bring up the register window .

413
00:30:05,900 --> 00:30:10,400
那么，有关于 gdb 的问题吗？
So with that is there any are there any questions about gdb?

414
00:30:10,640 --> 00:30:15,320
简单的问题，我知道已经有很多关于它的[]了，
Simple ones, I know it's been, there's been lots of post some [] about it,

415
00:30:15,320 --> 00:30:18,380
所以现在可以问一些简单的问题。
so now's a good time to just ask some straightforward,

416
00:30:18,380 --> 00:30:21,890
我会展示更多 gdb 的用法。
well I'll be showing more usage as gdb.

417
00:30:22,100 --> 00:30:24,500
你使用什么命令打开多个窗口？
What command did you use to open the multiple windows?

418
00:30:24,500 --> 00:30:25,730
我使用的是 tmux ，
So I use tmux,

419
00:30:25,820 --> 00:30:27,800
我可以从头开始演示，
so I can show just from scratch,

420
00:30:27,920 --> 00:30:32,840
在这里，我打开一个新的终端，只有一个空白的终端。
if we go here, I open a new terminal, so here's just a blank terminal.

421
00:30:33,730 --> 00:30:36,580
如果你输入 tmux ，在 Athena 上也是可用的。
If you type tmux and this is available on Athena.

422
00:30:37,150 --> 00:30:42,000
嗯，我一会再回答下一个问题，
Um, I'll answer the next question in a second,

423
00:30:42,180 --> 00:30:46,470
现在我在 tmux ，你可以从底部的绿色状态栏看出来，
so now I'm in tmux, which you can tell by this green bar at the bottom

424
00:30:46,650 --> 00:30:52,230
在 tmux 中，有几种方式可以创建多个窗口，
and if you want to get so there's a couple ways you can do multiple windows in tmux,

425
00:30:52,230 --> 00:30:55,670
你可以输入 control-b c ，
if you're, so you can type control-b c

426
00:30:55,670 --> 00:31:00,440
如果你习惯使用 emacs ，对此会很熟悉，
and I know that sometimes if you're used to using emacs that will make a lot of sense,

427
00:31:00,440 --> 00:31:03,950
但是对于不使用 emacs 的人，
but normal people who don't use emacs

428
00:31:04,010 --> 00:31:09,260
就是先按下 control 键，然后按下 b ，然后单独按下 c ，
that's hitting control and then b and then hitting c on its own afterwords,

429
00:31:09,320 --> 00:31:11,000
这会打开第二个窗口，
that will get you a second window

430
00:31:11,000 --> 00:31:14,480
然后，你可以使用 control-b p 或
which you can then navigate between with control b and then p,

431
00:31:14,540 --> 00:31:17,750
control-b n 在它们之间切换，
control b and n to go previous and next.

432
00:31:17,810 --> 00:31:20,930
是的， David 刚刚贴出了 tmux 的 cheatsheet ，这很有用，
Yeah and David just posted that tmux cheatsheet which is useful

433
00:31:21,350 --> 00:31:22,850
如果你想拆分窗口，
and if you want to split the windows,

434
00:31:22,850 --> 00:31:28,800
使用 control-b % 会垂直拆分窗口，
I think it's control b and then the percent sign will split them, um, vertically,

435
00:31:28,800 --> 00:31:35,050
使用 control-b " 会水平拆分窗口，
and then sign a double control b and double quote will split them horizontally,

436
00:31:35,800 --> 00:31:36,820
这就是我如何得到它们的。
and so that's how we get them.

437
00:31:36,820 --> 00:31:42,370
如果我们处于这种状态，可以使用 control-b o 在窗口之间切换。
If we're in this state, we can use control b and o to jump between our windows,

438
00:31:42,940 --> 00:31:45,670
这就是我有多个窗口的方法。
so that's that's how I got multiple windows.

439
00:31:45,670 --> 00:31:47,410
是的，[]。
Yeah [].

440
00:31:47,970 --> 00:31:53,610
Ahmed 问，为什么显示汇编地址，而不是 C 行号。
And then Ahmed asked why is displaying assembly addresses again instead of C line numbers.

441
00:31:53,670 --> 00:31:56,790
因为函数。
So because the function.

442
00:31:58,010 --> 00:32:00,920
如果我们回到汇编函数，
So if we go back to the assembly function,

443
00:32:00,980 --> 00:32:04,220
这完全是由汇编语言实现的，而不是用 C ，
this is implemented entirely in assembly and not at all in C

444
00:32:04,340 --> 00:32:07,490
所以没有与此相关的 C 行号。
and so there just aren't any associated C line numbers for this.

445
00:32:07,850 --> 00:32:12,410
如果我们要设置断点，
If we were to set a break point,

446
00:32:12,560 --> 00:32:15,560
如果你输入 delete ，可以删除所有断点，
so if you type delete you will delete all your break points,

447
00:32:15,980 --> 00:32:20,510
我删除旧断点，现在在 demo_1 中设置一个断点，
so I cleared the old one if I now set a break point in demo one,

448
00:32:20,510 --> 00:32:24,680
这是一个 C 断点，然后继续运行，
so that's a C break point and continue and run this,

449
00:32:24,740 --> 00:32:29,300
现在，我输入 layout split ，会得到 C 和汇编窗口。
now if I go here and type layout split I'll get the C and the assembly.

450
00:32:29,970 --> 00:32:33,990
如果我只想要 C 源码窗口，可以使用 layout source ，然后就只有 C 。
Um, or if I just want to C source, I can do layout source and I'll just get to C.

451
00:32:35,440 --> 00:32:37,090
这就是正在发生的事，
So that's that's what's going on,

452
00:32:37,090 --> 00:32:39,040
基于这个事实，
it's just a quirk of the fact

453
00:32:39,040 --> 00:32:42,580
它没有关联的 C 代码，所以看不到 C 行号。
that this doesn't have associated C code and so we don't see C line numbers.

454
00:32:46,270 --> 00:32:52,720
关于 gdb tmux ，还有别的问题吗？
Any other any other questions about gdb tmux, and that sort of thing.

455
00:32:53,080 --> 00:32:55,360
所以 layout split 用来
So layout split is the one that you use to

456
00:32:55,360 --> 00:32:59,200
bring up this extra window of the source and assembling so on right.

457
00:32:59,200 --> 00:33:04,840
是的，如果你使用 layout split ，可以得到源码和汇编窗口，
Yes yes, so layout if you do layout split that'll get you source and assembly,

458
00:33:04,840 --> 00:33:06,730
使用 layout source 只得到源码窗口，
layout source will get you just source,

459
00:33:06,730 --> 00:33:08,410
使用 layout asm 则只有汇编窗口。
asm will get you just assembly.

460
00:33:08,530 --> 00:33:12,160
寄存器是单独的，你可以输入 layout reg ，
And the registers are their own thing where you type layout, reg I think.

461
00:33:12,160 --> 00:33:14,540
是的，这会调出寄存器，
Yeah, that will bring up the registers,

462
00:33:14,540 --> 00:33:17,600
但是，我不知道有什么方法
but unfortunately I don't know of a way

463
00:33:17,600 --> 00:33:21,780
可以同时调出寄存器、汇编和 C 源码。
to get to register the assembly and the C code all at the same time

464
00:33:21,780 --> 00:33:24,180
除了在 layout split 状态下使用 info reg 。
outside of using info reg with layout split.

465
00:33:24,990 --> 00:33:30,150
我有一个问题，当我们在行中设置断点。
I have a question, so when we set the back breakpoint at line right.

466
00:33:30,180 --> 00:33:30,690
嗯，
Um,

467
00:33:31,090 --> 00:33:38,290
这种情况下，断点添加到类似 0x80006354 这样的地址，
it displays the address of the like in this case breakpoint to add to 0x80006354,

468
00:33:39,250 --> 00:33:46,900
指令可能有多个， C 中的代码行可能有多个指令，
what any instruction might have multiple , any line of code in C might have multiple instructions,

469
00:33:46,960 --> 00:33:49,090
那么显示的是哪一个？
so which one does show.

470
00:33:49,210 --> 00:33:50,320
我想显示的是第一个。
I think it shows the first one.

471
00:33:51,510 --> 00:33:56,670
对启动 tui 有问题的人，
And it's tu-, for the person who asked to start tui,

472
00:33:56,670 --> 00:34:00,210
我想命令应该是 tui enable 而不是 enable tui ，不好意思。
it's I think it's tui enable, not enabled tui, sorry.

473
00:34:01,070 --> 00:34:04,580
我想是的。
And I think yeah.

474
00:34:05,570 --> 00:34:05,630
是的。
Yeah.

475
00:34:08,450 --> 00:34:14,450
是的，再提一下，这里有一些 gdb 和 tmux 的 cheatsheet ，
Yeah again there's a hundred cheatsheets out here for gdb and for tmux,

476
00:34:14,450 --> 00:34:16,370
如果你发现自己不会用，可以看一下。
as well so if you ever find yourself lost.

477
00:34:16,430 --> 00:34:23,400
gdb 还有自己的内置手册，叫做 apropos ，
I t-, gdb even has its own inbuilt it's own thing called apropos ,

478
00:34:23,550 --> 00:34:26,490
如果你输入 apropos tui ，
so if you look for apropos tui,

479
00:34:26,520 --> 00:34:31,980
它会显示所有相关的 tui 命令。
it'll actually show you all of the commands that involve tui.

480
00:34:33,310 --> 00:34:39,460
是的，这可能非常有用，但也有点令人不知所措。
So yeah, this can be quite useful, but it can also be a little bit overwhelming .

481
00:34:39,820 --> 00:34:43,780
如果你使用 apropos -v ，它会给你提供更多信息。
If you do apropos -v that it will give you even more information I think.

482
00:34:44,610 --> 00:34:49,160
嗯，我不记得了，我不经常使用它。
Um I don't remember, I I don't use it often myself.

483
00:34:49,160 --> 00:34:53,870
但是如果你要查找或忘记了 gdb 中输入命令的确切方式，
But if you do find or if you forget the exact way to type the command in gdb

484
00:34:53,870 --> 00:34:54,860
而且你不想使用谷歌，
and you don't feel like google

485
00:34:54,860 --> 00:34:59,300
apropos 能够找到你要找的东西，
and apropos's will will often be able to find exactly what you're looking for,

486
00:34:59,300 --> 00:35:01,520
还包括很多关联的东西。
in addition to a whole bunch of stuff you are looking for.

487
00:35:04,260 --> 00:35:08,430
是的，所以这是非常有用的， gdb 也有很好的文档。
Yeah, so this is actually quite useful, gdb is extremely well documented as well,

488
00:35:08,460 --> 00:35:13,980
所以，如果发现自己不会使用，你知道的，谷歌是你的朋友。
so um, yeah, if you ever find yourself lost, you know, google is your friend.

489
00:35:16,800 --> 00:35:22,740
现在我们来看汇编和 RISC-V 以及相关的东西，
So now that we've kind of been over assembly and and RISC-V and these sort of things,

490
00:35:22,800 --> 00:35:25,500
我想深入讲解一下细节，
I want to dive a little bit more into the specifics

491
00:35:25,740 --> 00:35:30,810
你们在随后的实验中会用到，
of what you you really need to know for the lab coming up

492
00:35:30,990 --> 00:35:33,900
另外，这也是对文档的一个回顾，
and also it'll be a little bit of review from the document

493
00:35:33,900 --> 00:35:41,710
当然，我想勤奋的同学已经读过一遍了。
that you've of course, diligent students read through thoroughly in preparation for this lecture.

494
00:35:42,700 --> 00:35:47,860
是的，这张表你们很熟悉，
Um, so yeah, this table will of course be a wildly familiar to you all

495
00:35:47,860 --> 00:35:52,270
从 6.004 或你们自己读的资料中，
and from from both 6.004 and from what you've read,

496
00:35:52,360 --> 00:35:54,670
这是寄存器表，
and this is the table of registers

497
00:35:54,670 --> 00:36:03,630
寄存器是 CPU 上处理器周围预设的很小的位置，
and registers are little locations on the CPU around the processor predefined

498
00:36:03,630 --> 00:36:07,410
它可以存储值，这很重要，
that it can use to store values and this is important,

499
00:36:07,410 --> 00:36:11,340
因为汇编操作，如果你记得汇编代码，
because assembly operations if we remember from the assembly code,

500
00:36:11,490 --> 00:36:15,360
汇编不是在内存上操作，而是在寄存器上操作，
the assembly doesn't operate on memory, it operates on register,

501
00:36:15,360 --> 00:36:20,580
所以我们做加法、减法时，是在寄存器上操作。
so when we do add when we do subtract we're operating on registers .

502
00:36:21,000 --> 00:36:25,320
所以你经常看到一种编写汇编的模式，
And so what you often see as the pattern for writing assembly

503
00:36:25,320 --> 00:36:32,080
有一个 load ，将一些值加载到寄存器中。
is will have some kind of a load, so we'll load some value to a register.

504
00:36:33,030 --> 00:36:37,320
这个值可以来自内存，也可以来自另一个寄存器。
And that value can be from memory, or it can be from another register.

505
00:36:38,340 --> 00:36:43,020
这里泛指加载，而不是 load 指令。
And, and here referring to load in general, not the load instruction .

506
00:36:43,420 --> 00:36:49,410
然后我们会操作，在寄存器上执行一些操作，
And then we'll operate, so we'll perform some operation on the register,

507
00:36:49,410 --> 00:36:53,100
如果我们关心返回地址之外的操作结果，
and then if we care about the result of that operation outside the return address,

508
00:36:53,280 --> 00:37:01,310
我们可以把寄存器的值存储到某个地方，
we will, we'll store that register to somewhere, to some locate,

509
00:37:01,310 --> 00:37:08,000
将寄存器的值存储到内存中某个位置或另一个寄存器。
they will store that register to some location in memory or to another register

510
00:37:08,210 --> 00:37:10,580
这就是通常的操作过程，
and that's generally the way things work

511
00:37:10,580 --> 00:37:17,300
寄存器是执行任何计算或访问任何值的最快方式，
and registers are the absolute fastest way to perform any sort of calculation or to access any value

512
00:37:17,300 --> 00:37:20,540
这就是为什么使用它们很重要，
and that's why it's important to use them

513
00:37:20,540 --> 00:37:24,590
也是我们更应该使用寄存器而不是内存的原因，
and also why we prefer using registers overusing memory,

514
00:37:24,590 --> 00:37:28,340
如果你们记得文档中，我们调用函数时，
so if you remember from the reading when we call functions

515
00:37:28,340 --> 00:37:31,490
可以看到，寄存器从 a0 到 a7 。
so you can see here that registers a0 to seven.

516
00:37:32,450 --> 00:37:40,610
一般来说，当我们谈到寄存器时，会使用它们的 ABI 名称来指代它们，
And in general when we speak about registers we we will be referring to them by their ABI name ,

517
00:37:40,820 --> 00:37:43,760
不仅减少了混淆，也是一个标准，
not only is it less confusing, it's just a standard

518
00:37:43,760 --> 00:37:45,920
也是你编写汇编代码的方式，
and it's also the way that you'll write assembly code,

519
00:37:45,950 --> 00:37:50,920
这个，这些实际的数字并不是特别重要，
this, you know, these these actual numbers are not super important,

520
00:37:50,980 --> 00:37:58,360
唯一有意义的情况是对于 RISC-V 指令的压缩版本，
the only case where it does matter is for the compressed version of RISC-V instructions

521
00:37:58,360 --> 00:38:02,350
如果你想了解更多，可以查看文档，
and if you want to know more about that, feel free to read up about it,

522
00:38:02,350 --> 00:38:07,230
基本思想是 RISC-V ，普通指令是 64 位，
the basic idea is that RISC-V, normal instructions are 64 bits,

523
00:38:07,230 --> 00:38:10,650
但是也有一个压缩版本，指令是 16 位，
but there's also a compressed version, which instructions are sixteen bits

524
00:38:10,830 --> 00:38:17,220
我们使用的寄存器更少，这种情况下，使用的寄存器是 8 到 15 ，
and we use less registers and the registers we use in that case are eight through fifteen,

525
00:38:17,220 --> 00:38:19,050
这些是我们可以使用的寄存器。
those are the registers that are available to us.

526
00:38:19,170 --> 00:38:24,120
有人提问，为什么这个 s1 寄存器 x9 ，
So I think somebody had a question about why is this s1 register x9,

527
00:38:24,120 --> 00:38:27,960
为什么它与其他所有寄存器分开？
why is it, separated from all of the other's registers?

528
00:38:28,050 --> 00:38:30,990
我猜是这样，
And my guess is that that's why ,

529
00:38:31,800 --> 00:38:37,050
我们把它与其他分开，因为它在压缩指令模式下是可用的，
that we separated from all the other ones because it's available in compressed instruction mode,

530
00:38:37,080 --> 00:38:39,120
而 s2 到 s11 不是。
whereas s2 to eleven or not.

531
00:38:40,220 --> 00:38:42,470
这是我的想法，它是一个压缩指令寄存器，
And so that's the idea, that's that's a compress,

532
00:38:42,470 --> 00:38:48,030
但是在寄存器之外，将通过它们的 ABI 名称来引用，
but outside of that register will be referred to by their ABI name

533
00:38:48,060 --> 00:38:51,180
a0 到 a7 用于函数变量，
and so a0 to a7 are used for function arguments,

534
00:38:51,270 --> 00:38:52,650
但是如果有一个函数接受的参数数量，
but if we have a function that takes

535
00:38:52,650 --> 00:38:57,030
超过可以访问的寄存器数 8 个，
more than the eight arguments that those registers give us access to,

536
00:38:57,470 --> 00:38:59,000
我们就需要内存，
we do need to use memory

537
00:38:59,000 --> 00:39:01,370
但这在某种程度上也说明了一个事实，
but that's , this is kind of an illustration of the fact

538
00:39:01,370 --> 00:39:03,920
当我们可以使用寄存器时，就不使用内存。
that we don't want to use memory when we can use registers.

539
00:39:04,100 --> 00:39:07,490
我们只在必须的时候使用内存。
We only we only use a memory, we have to.

540
00:39:08,790 --> 00:39:11,490
这一栏， saver 栏，
And this, this column here, the saver column,

541
00:39:11,670 --> 00:39:14,070
也是非常重要的，
this is also extremely important

542
00:39:14,070 --> 00:39:17,400
在我们讨论调用者（caller）和被调用者（callee）保存寄存器时，
when we're discussing registers caller versus callee saved.

543
00:39:17,760 --> 00:39:23,610
这两个属于我也经常混淆，
And the terms are I confuse them regularly,

544
00:39:23,610 --> 00:39:25,950
caller 和 callee 只有一个字母的区别，
caller and callee, the only differ by one letter,

545
00:39:26,010 --> 00:39:29,700
记住它们最简单的方法是，
the easiest way that I've found to remember them is

546
00:39:29,700 --> 00:39:40,850
调用者保存寄存器在函数调用期间不会保留，
that caller saved registers are not preserved, across a function call,

547
00:39:42,190 --> 00:39:47,850
而被调用者保存寄存器会保留。
so and callee saved registers are preserved.

548
00:39:49,580 --> 00:39:52,900
我的意思是，
What I mean by this, is that,

549
00:39:54,500 --> 00:40:01,460
调用者保存寄存器可以被函数重写，
a caller saved register can be overwritten by the function,

550
00:40:01,460 --> 00:40:04,370
比如我有函数 a 调用函数 b ，
so let's say I have function a which calls function b,

551
00:40:04,700 --> 00:40:08,690
函数 a 使用的任何寄存器都是调用者保存的。
any registers being used by function a that are caller saved.

552
00:40:08,880 --> 00:40:12,240
调用函数 b 可以在其被调用时覆盖，
Call function b can overwrite when it gets called,

553
00:40:12,420 --> 00:40:16,080
我想返回地址（Return address）就是一个很好的例子。
and I think a good illustration of this is the return address.

554
00:40:16,320 --> 00:40:20,100
你可以看到返回地址是调用者保存的。
Because you know you can see that the return addresses caller saved.

555
00:40:21,170 --> 00:40:25,640
这一点很重要，因为每个函数都需要使用返回地址，
And that's important because every function needs to use the return address,

556
00:40:25,730 --> 00:40:32,480
因此，当 a 调用 b 时，能够覆盖返回地址中的值是很重要的，
so when a calls b it's important that be be able to overwrite the value in the return address,

557
00:40:32,510 --> 00:40:34,130
这就是为什么它是调用者保存的。
hence why its caller saved.

558
00:40:34,340 --> 00:40:39,440
而被调用者保存寄存器只是我们使用的约定，
And callee saved registers are just are convention that we use,

559
00:40:39,620 --> 00:40:42,800
所以，帧指针（frame pointer, s0/fp）非常重要。
the frame pointer is important for that reason.

560
00:40:43,030 --> 00:40:46,330
这些寄存器在函数调用之间保留，
And those are preserved across function calls,

561
00:40:46,330 --> 00:40:48,850
所以对于调用者保存寄存器，
so basically any register that is caller saved,

562
00:40:49,000 --> 00:40:52,390
进行调用的函数需要考虑这些寄存器，
the function that is making the call needs to worry about those registers,

563
00:40:52,540 --> 00:40:54,070
如果是被调用者保存的，
and if they're callee saved,

564
00:40:54,070 --> 00:40:58,930
则被调用的函数需要考虑如何保存这些寄存器的值。
the function that is being called needs to worry about preserving the value in those registers.

565
00:40:59,830 --> 00:41:03,280
你知道，我经常混淆这两个，
And again, you know I I regularly confuse the two

566
00:41:03,280 --> 00:41:10,200
可以回到这张表，看看它们是怎么用的。
and find myself returning to this table, to remind myself about what they do.

567
00:41:11,160 --> 00:41:14,860
如果你记得读过的内容，
And so, You know you if you remember from the reading,

568
00:41:14,890 --> 00:41:18,280
所有这些寄存器都是 64 位的，
all of these registers are 64 bits wide,

569
00:41:18,280 --> 00:41:21,100
所以，它们有 64 个位置可以放东西，
so they have 64 places where we can put things

570
00:41:21,250 --> 00:41:28,660
基于调用约定，各种类型数据适用于 64 位，
and the various data types are made to fit into those 64 bits based on the calling convention,

571
00:41:28,660 --> 00:41:30,400
所以如果我们有一个 32 位整数，
so if we have a 32 bit integer,

572
00:41:30,490 --> 00:41:33,550
根据它是不是扩展的，
depending on how it's whether or not it's an extended,

573
00:41:33,610 --> 00:41:36,490
我们可以在它前面添加 0 或 1 ，
you know will either add zeros or ones to the front of that integer,

574
00:41:36,490 --> 00:41:39,760
以便将其设置为 64 位放入这些寄存器。
 in order to make it 64 bits to put in these registers.

575
00:41:40,480 --> 00:41:41,860
在我们继续之前，
So before we move on,

576
00:41:41,950 --> 00:41:48,010
有没有关于寄存器或相关的问题。
does anybody have questions about registers or things of that nature.

577
00:41:57,950 --> 00:41:59,360
我有一个问题，
I have a question,

578
00:41:59,360 --> 00:42:03,770
能把一个返回值放在 a1 中吗？
can you have a-, can you put a return value in a1.

579
00:42:04,790 --> 00:42:06,500
是的，这是个好问题。
Yes, that's a good question.

580
00:42:06,500 --> 00:42:11,090
我想理论上是可以的，
So, I think in theory you can,

581
00:42:11,120 --> 00:42:14,960
原因是，比如 a0 到 a1 是，
the reason why we say a0 to a1 is

582
00:42:14,960 --> 00:42:18,770
如果函数返回 128 位的长整型，
if a function returns a long long which is 128 bits,

583
00:42:18,770 --> 00:42:24,560
如果你记得，如果一个函数参数是 100 ，超过一个指针字（pointer-word）长。
so if you remember from the reading if a function argument is a hundred is more than a pointer-word.

584
00:42:24,880 --> 00:42:28,060
当我们说字（word）时，是 64 位，
We're , when we refer to word sign, we're saying 64 bits,

585
00:42:28,210 --> 00:42:31,390
所以如果我们有两倍于指针字大小的东西，
so if we have something that is twice the size of a pointer-word,

586
00:42:32,350 --> 00:42:35,170
我们可以把它放入寄存器对中，
we can put that in a register pair

587
00:42:35,320 --> 00:42:38,590
因此同样的约定也适用于返回地址，
and so the same convention holds true for return addresses

588
00:42:38,590 --> 00:42:42,490
如果我们有一个指针字两倍大小的东西，
where if we have something that's the size of twice pointer-word,

589
00:42:42,520 --> 00:42:46,240
可以把它放在 a0 和 a1 中，并作为返回地址。
we can stick that in a0 and a1 and use that as the return address,

590
00:42:46,330 --> 00:42:49,270
我想如果你只往 a1 里写入，可能会遇到问题。
I think you'll run into problems if you only try to put something in a1.

591
00:42:49,880 --> 00:42:51,050
理解了，谢谢。
Makes sense, thanks.

592
00:42:55,040 --> 00:42:59,510
为什么寄存器不是连续的，
Why are the registers not like continuous,

593
00:42:59,510 --> 00:43:03,860
为什么 a0 和 a1 是分开的？
so why is like a0 and one separate from?

594
00:43:04,680 --> 00:43:06,480
抱歉，这不是一个好例子，
Sorry no that's a bad example,

595
00:43:06,480 --> 00:43:09,450
为什么 s1 和 s2 是分开的，
that's why is s1 separate from s2,

596
00:43:09,450 --> 00:43:12,540
为什么 a 在它们中间，这有什么意义吗？
why the a in between like is there any point in that.

597
00:43:13,180 --> 00:43:15,910
是的，我之前提到，
Yeah, so, I mentioned this briefly earlier,

598
00:43:15,910 --> 00:43:20,080
这只是一个猜测，我不是很确定，
but there is a compressed, this is a guess I don't I don't know for sure,

599
00:43:20,230 --> 00:43:24,760
有一个压缩版本的 RISC-V 指令，
but there's a compressed version of the RISC-V instructions

600
00:43:25,000 --> 00:43:28,450
它的大小是 16 位，而不是 64 位。
which are 16 bits in size as opposed to 64.

601
00:43:28,920 --> 00:43:34,170
你可以用它来使代码在内存中占用更少的空间，
And you would use that to try to make your code takes less space in memory,

602
00:43:34,410 --> 00:43:41,850
当你使用 16 位指令时，只能访问寄存器 8 到 15 位，
and when you use those 16 bit instructions, you only have accesses to registers 8 through 15,

603
00:43:42,000 --> 00:43:45,750
所以我认为 s1 与 s2 到 s11 分开，
so I think s1 is separate from s2 to eleven,

604
00:43:45,870 --> 00:43:47,790
是因为他们想要明确，
because they want to make it clear,

605
00:43:47,790 --> 00:43:53,630
s1 在压缩指令模式下可用，而 s2 到 s11 则不可用。
that s1 is available to you in the compressed instruction mode, whereas two to eleven aren't.

606
00:43:54,500 --> 00:44:00,120
我不知道他们为什么选择 x ， x8 到 x15 ，
And the reason you know I don't know why they picked x, x8 to 15,

607
00:44:00,240 --> 00:44:03,090
但我相信，只要看一些代码，
but I suspect that just looked at a bunch of code

608
00:44:03,090 --> 00:44:05,400
就会发现这些是最常用的寄存器。
and we're like these are the most commonly used registers.

609
00:44:17,140 --> 00:44:18,310
还有其他问题吗？
Any other questions?

610
00:44:20,840 --> 00:44:22,490
我有一个问题。
I had a question .

611
00:44:23,630 --> 00:44:26,960
除了帧指针、栈指针，
Besides the frame pointer, the stack pointer at all,

612
00:44:27,140 --> 00:44:32,120
我不知道为什么我们需要更多的被调用者保存寄存器。
I don't know why we would need more callee saved registers.

613
00:44:32,460 --> 00:44:34,590
但我们确实有很多这样的寄存器。
But we do have like a bunch of them.

614
00:44:35,420 --> 00:44:40,070
是的， s1 到 s11 只是为了，
Yeah, the s1 to elevens those are just for,

615
00:44:40,070 --> 00:44:44,120
我相信只是为了让编译器或程序员有使用它们的自由，
I believe use their freedom for the compiler or the programmer to use,

616
00:44:44,360 --> 00:44:47,390
在某些情况下，你可能想要，
so there may be there are certain cases where you want,

617
00:44:47,600 --> 00:44:52,790
想要保证在函数之后仍然有一些东西存在
you want to guarantee that something is still around after after your function,

618
00:44:52,790 --> 00:44:58,220
可以调用编译器选择使用 s1 到 s11 来做。
call the compiler can choose to use s1 to eleven to do that.

619
00:44:58,760 --> 00:45:04,450
嗯，我现在没有一个具体的例子来说明，
Um, I don't have like on hand, a specific example of where that's useful,

620
00:45:04,570 --> 00:45:06,640
但是，我肯定它会出现的，
but, I'm sure it shows up,

621
00:45:07,330 --> 00:45:09,940
where having a callee saved value is important.

622
00:45:14,390 --> 00:45:19,220
这些基本上是程序员或编译器选择使用 s1 到 s11 。
But these are basically basically a programmer or compiler's choice to use s1 to eleven.

623
00:45:22,420 --> 00:45:27,040
我要提醒一下，这些浮点寄存器，浮点算数，
I should note that these floating point registers their floating point, arithmetic, 

624
00:45:28,480 --> 00:45:31,090
据我所知，你们在这节课上不会看到它们，
as far as I'm aware, you won't see them in this class,

625
00:45:31,360 --> 00:45:33,790
所以不需要担心它们。
and so you don't really need to worry about them.

626
00:45:38,550 --> 00:45:45,140
好的，我们开始讨论一下函数调用，
Okay, so we started talking a little bit about function calls,

627
00:45:45,440 --> 00:45:53,820
有了这些，我想开始讨论堆栈。
and so with that I want to move us into discussion of the stack .

628
00:45:54,390 --> 00:45:59,420
这就是我们要讨论的堆栈，
So this is This is we're talking about the stack,

629
00:45:59,840 --> 00:46:04,610
堆栈，就像你以前看到的那样，
and the stacked, if you've seen it like before,

630
00:46:04,640 --> 00:46:07,730
它之所以重要是因为，
the reason why the stack is important is

631
00:46:07,850 --> 00:46:13,030
它使函数保持组织和正常运行，
it's what keeps our functions organized and sane,

632
00:46:13,060 --> 00:46:18,490
它允许函数工作，允许函数返回，
and it's what allows what makes functions work, it's what makes return work

633
00:46:18,490 --> 00:46:25,150
这也是我们经常编写保存寄存器之类的代码。
and it's also where often we will find ourselves saving our registers and things like that.

634
00:46:26,330 --> 00:46:27,050
嗯。
Um.

635
00:46:29,440 --> 00:46:39,310
在这里，我给出了堆栈的一个非常简单的布局，
So, here, I've given just a pretty simple layout of what the stack looks like,

636
00:46:39,340 --> 00:46:48,100
而且这里的每个框都是我们所说的栈帧。
and so each of these boxes here is what we refer to as a stack frame.

637
00:46:49,070 --> 00:46:54,860
每次我们得到栈帧，都是由函数调用生成的。
And every time we get , which are generated by function calls.

638
00:46:59,890 --> 00:47:03,190
每次我们调用一个函数，
Every time we call a function

639
00:47:03,220 --> 00:47:07,360
该函数都会为自己创建栈帧，
that function makes for itself its own stack frame

640
00:47:07,510 --> 00:47:14,350
并通过移动栈指针来使用它，
and which it uses itself and does that by moving around the stack pointer,

641
00:47:14,530 --> 00:47:16,330
这个是栈指针，
so here's the stack pointer,

642
00:47:16,360 --> 00:47:19,630
记住这些是很重要的。
and this is it's very important to remember.

643
00:47:19,780 --> 00:47:29,070
对于栈，我们从高地址开始，然后向下扩展到低地址，
With stacks, we start from high addresses and we grow downwards. Too low addresses,

644
00:47:29,070 --> 00:47:31,470
所以栈总是向下扩展。
so the stack grows down always.

645
00:47:31,860 --> 00:47:38,370
所以你会看到栈指针的运算通常是通过减法来完成的，
And so you'll see that the arithmetic for stack pointer is usually done via subtraction,

646
00:47:38,370 --> 00:47:41,020
我们要在汇编中创建一个新的栈帧，
we want to make a new stack frame in assemblies,

647
00:47:41,020 --> 00:47:42,430
栈就向下扩展。
the stack grows downwards.

648
00:47:43,380 --> 00:47:48,780
函数栈帧包含寄存器、局部变量，
And stack frames for function contain I see registers local variables,

649
00:47:48,930 --> 00:47:51,030
就像我说的，
also like I was saying,

650
00:47:51,030 --> 00:47:56,190
如果参数寄存器用完了，额外的参数就会出现在栈上，
if you run out of argument registers additional arguments will show up on the stack,

651
00:47:56,370 --> 00:47:59,460
栈帧不一定是相同大小，
and so not as stack frames are not all the same size ,

652
00:47:59,460 --> 00:48:01,980
尽管在这张图中它们是相同的，但事实并非如此，
even though they are in this diagram, that's not the case,

653
00:48:02,010 --> 00:48:04,920
不同函数具有不同数量的局部变量，
different functions have different numbers of local variables

654
00:48:04,920 --> 00:48:07,980
不同的寄存器等，
different registers so on and so forth,

655
00:48:08,070 --> 00:48:09,900
因此栈帧具有不同的大小，
and so stack frames will be different sizes.

656
00:48:09,900 --> 00:48:12,570
但是有两件事是可以确定的，
But the two things that you can definitely count on,

657
00:48:12,820 --> 00:48:17,650
这很重要，返回地址总是在第一个，
which are important is that the return address will always be on the first thing

658
00:48:17,650 --> 00:48:20,950
并且，帧指针，前一帧帧指针
and the frame pointer, the previous frames frame pointer

659
00:48:20,950 --> 00:48:24,700
也会出现在栈中可预测位置，
is also going to show up on the stack at a predictable location,

660
00:48:24,970 --> 00:48:29,330
两个重要的寄存器，这个是 sp ，
so the two important registers here are sp,

661
00:48:29,330 --> 00:48:33,980
正如我们讨论的，这是栈的底部。
which you know as we discussed is used for, this is the bottom of the stack.

662
00:48:35,780 --> 00:48:38,990
或者说是栈所在的位置，
Or generally you know it's the location of the stack,

663
00:48:39,200 --> 00:48:49,480
fp 也是重要的寄存器，指向当前帧的顶部。
and then fp is are also important register and this points to the top of current frame.

664
00:48:50,790 --> 00:48:51,780
这一点很重要，
And this is important,

665
00:48:51,780 --> 00:48:56,220
因为这意味着返回地址和前一 fp
because that means that the return address and the previous fp

666
00:48:56,250 --> 00:49:01,770
将始终位于当前帧指针的固定位置。
will always be at a fixed location from the current frame pointer.

667
00:49:02,400 --> 00:49:05,790
这意味着如果我想找到返回地址，
So that means that if I want to find my return address

668
00:49:05,790 --> 00:49:07,650
或者想找到上一帧，
or I want to find the previous frame,

669
00:49:07,890 --> 00:49:12,930
我总是可以通过查看当前帧指针来获得这些值，
I can always get to those values by looking at the current frame pointer

670
00:49:13,650 --> 00:49:16,800
我们之所以存储前一个帧指针，
and the reason why we store the previous frame pointer is

671
00:49:16,800 --> 00:49:18,900
是为了可以向后跳转，
to allow us to jump back,

672
00:49:18,900 --> 00:49:22,680
一旦这个函数返回，我们可以把它移动到 fp ，
so once this function returns we can move this into fp

673
00:49:22,710 --> 00:49:23,790
然后，
and all of a sudden

674
00:49:23,790 --> 00:49:30,090
fp 从指向这个栈帧，到指向这个栈帧。
fp again will go from pointing to this, this stack frame, to now pointing to this stack frame.

675
00:49:30,450 --> 00:49:34,050
所以，我们使用帧指针来操作栈帧，
So we use the frame pointer to manipulate our stack frames

676
00:49:34,050 --> 00:49:40,110
并确保始终指向函数对应的栈帧。
and make sure we're always going to one corresponding to the correct function.

677
00:49:41,040 --> 00:49:43,920
这就是栈的工作方式，
And that's that's kind of how things how things are done

678
00:49:44,040 --> 00:49:50,830
栈的这部分是使用汇编语言实现的，
and the these pieces of the stack need to be created by assembly

679
00:49:50,920 --> 00:49:56,230
你读到的调用约定文档中的所有内容，
and so everything's everything in that calling conventions document that you read about

680
00:49:56,260 --> 00:50:00,850
都是由编译器实施的，
that's all enforced by effectively by the compiler,

681
00:50:00,850 --> 00:50:06,970
编译器遵循调用约定，生成栈帧，
so the compiler adheres to the calling convention and it's what generates the stack frame,

682
00:50:06,970 --> 00:50:10,900
生成汇编代码，保证栈帧正确，
it generates the assembly code that makes our stack frames look correct,

683
00:50:11,080 --> 00:50:18,570
所以通常在函数的开头，你会看到所谓的函数序言。
so often at the top of a function, you'll see what's called a function prologue.

684
00:50:21,300 --> 00:50:24,180
然后是函数体，
And then there will be the body of the function

685
00:50:24,450 --> 00:50:29,410
然后是一个函数尾声。
and then there will be an epilogue that shows up after that,

686
00:50:29,470 --> 00:50:37,240
这就是汇编函数通常看起来的样子，
so this is kind of like, when an assembly function will often look like.

687
00:50:37,360 --> 00:50:38,920
我们现在来看一下，
And we'll take a look at,

688
00:50:39,100 --> 00:50:43,660
这里我有另一个函数 sum_then_double ，
now, so here I have another function sum_then_double,

689
00:50:43,660 --> 00:50:49,270
注意， sum_to 没有这些东西，
so you'll note that [] that sum_to not have any of these things

690
00:50:49,270 --> 00:50:51,940
一个真正的函数应该有的，
that it it should if it was a proper function

691
00:50:52,060 --> 00:50:54,220
它也是可用的，因为足够简单，
and this works fine because it's simple enough,

692
00:50:54,220 --> 00:50:57,100
它的所有计算都是在 a0 上进行的，
so it does all of its computations on a0

693
00:50:57,100 --> 00:51:01,380
所以是好的，我们把它称为叶子函数，
and so things are, things are good and we're also not it's a it's a leaf function,

694
00:51:01,590 --> 00:51:04,350
如果你看到叶子函数这个术语，
so, you'll see if you've seen the term leaf function

695
00:51:04,350 --> 00:51:06,510
它是一个不调用另一个函数的函数，
that's a function that doesn't call another function,

696
00:51:06,900 --> 00:51:08,910
这种函数的特殊之处是，
and the functions are special in that

697
00:51:08,910 --> 00:51:15,120
它们不需要考虑保存自己的返回地址，
they don't need to worry about saving their own return address

698
00:51:15,120 --> 00:51:18,360
或者保存任何调用者保存寄存器。
or saving really any of the caller saved registers.

699
00:51:18,650 --> 00:51:23,150
因为它们不会进行另一个函数调用，
Because they're going to they're not going to make another function call,

700
00:51:23,150 --> 00:51:25,160
所以它们不需要那么小心。
so they don't have to be as careful,

701
00:51:25,400 --> 00:51:29,060
另一方面， sum_then_double 不是叶子函数，
sum_then_double on the other hand is not a leaf function,

702
00:51:29,060 --> 00:51:32,720
你可以在这里看到，它调用了 sum_to 。
so you can see here, it calls sum_to.

703
00:51:33,530 --> 00:51:37,340
所以它需要包含函数序言，
And so it does need to include that that prologue,

704
00:51:37,340 --> 00:51:42,440
这里我们可以看到，从栈指针减去 16 ，
and so we see here that we are subtracting 16 from the stack pointer,

705
00:51:42,470 --> 00:51:44,780
我们在栈上腾出空间，
so we're making space on our stack,

706
00:51:44,990 --> 00:51:49,850
我们将 sum_then_double 的返回地址存储在栈中，
we're storing the return address for sum_then_double on the stack,

707
00:51:49,970 --> 00:51:52,100
然后调用 sum_to ，
and then we make our call to sum_to,

708
00:51:52,340 --> 00:51:55,220
在此之后，函数所做的全部工作就是调用 sum_to 。
and after that all this function does is it calls sum_to

709
00:51:55,220 --> 00:52:00,420
然后将 sum_to 返回的结果加倍，
and then doubles the result, doubles the result turn by sum_to,

710
00:52:00,600 --> 00:52:03,060
这里你可以看到函数尾声，
and here you can see the epilogue,

711
00:52:03,060 --> 00:52:07,970
我们将返回地址加载回 ra ，
so we load the return address back in to ra

712
00:52:08,060 --> 00:52:12,410
并删除栈帧，然后跳出函数。
and delete our stack frame and then jump out of the function.

713
00:52:13,850 --> 00:52:17,690
我们可以运行它来确保达到预期的效果。
And so we can run that to make sure it does what we would expect.

714
00:52:20,870 --> 00:52:22,010
在这里。
Go here.

715
00:52:24,160 --> 00:52:27,910
我们可以运行，如果我们运行 demo1 ，
We can run, so if we run demo2 or demo1

716
00:52:27,910 --> 00:52:30,280
我们得到了总和为 15 的结果，
we got the result of fifteen for the sum,

717
00:52:30,280 --> 00:52:33,730
我会演示 demo2 ，调用 sum_then_double ，
and I'll tell you that demo2 just, just call sum_then_double

718
00:52:33,730 --> 00:52:39,580
它就是把 sum_to 返回的结果加倍。
and indeed you know it happily doubles the sum returned by sum_to.

719
00:52:40,600 --> 00:52:44,140
所以我有一个问题，
And so a question I have for anybody

720
00:52:45,010 --> 00:52:51,130
如果我们删除这个函数序言和函数尾声，会发生什么，
what happens if we delete this prologue and epilogue,

721
00:52:51,250 --> 00:52:55,900
如果我们在 sum_then_double 这样操作，会发生什么。
what happens if we just have this as our function, sum_then_double.

722
00:52:55,900 --> 00:52:57,460
有人能预测会发生什么吗？
Can anybody predict what's going to happen.

723
00:53:01,590 --> 00:53:07,720
我的意思是， sum_then_double 不知道它应该返回的返回地址，
I mean one thing is that sum_then_double wouldn't know the return address that it should return to,

724
00:53:07,930 --> 00:53:14,170
因此，在调用 sum_to 时，将覆盖 sum_then_double 的返回地址，
so upon calling sum_to, that's going to override the return address to be sum_then_double's,

725
00:53:14,170 --> 00:53:18,260
在 sum_then_double 的末尾，它不会返回到最初的调用者。
at the end of sum_then_double, it's not going to return to its original caller.

726
00:53:19,330 --> 00:53:23,620
是的，没错。我们可以看看发生了什么。
Yeah exactly and we can see that that's what happens.

727
00:53:23,650 --> 00:53:30,400
我们退出这个，退出这个，
Again, so if we exit out of this and exit out of this

728
00:53:31,180 --> 00:53:34,360
我们现在用损坏的函数重新编译。
and we re-compile with now with our broken function.

729
00:53:35,650 --> 00:53:37,810
我们可以看看到底会发生什么，
We can take a look at exactly what's gonna happen,

730
00:53:37,810 --> 00:53:41,650
我们可以在 sum_then_double 设置中断，
so we can actually set our break point for sum_then_double.

731
00:53:45,290 --> 00:53:49,250
设置 tui 并让它继续运行，
And set up tui and let it continue,

732
00:53:49,250 --> 00:53:50,870
现在我们运行 demo2 ，
so we now run demo2,

733
00:53:50,870 --> 00:53:52,760
好的，我们在 sum_then_double 。
okay we're at sum_then_double.

734
00:53:53,280 --> 00:53:56,370
同样的，这里只有一个汇编函数，
And again, this is an assembly only function,

735
00:53:56,370 --> 00:53:59,490
所以我们在汇编中查看它，
so we're going to want to look at it in assembly,

736
00:53:59,610 --> 00:54:03,060
我们输入 layout asm ， layout reg ，
so we'll do layout asm layout reg,

737
00:54:03,060 --> 00:54:05,670
因为这种情况下，寄存器的内容也很重要。
because it's important what's in the registers in this case.

738
00:54:06,620 --> 00:54:09,680
你将看到 gdb 中有很多信息，
And you'll see that gdb knows a whole bunch of extra information

739
00:54:09,890 --> 00:54:15,420
我们可以看到，
and so we can see that, you can see that,

740
00:54:15,420 --> 00:54:21,000
ra 当前，返回地址指向 demo2 加 18 ，
ra currently, so the return address, currently points to demo2 the plus eighteen,

741
00:54:21,060 --> 00:54:25,010
这表示进入函数 demo2 。
so, it points effectively into the function demo2.

742
00:54:26,180 --> 00:54:28,130
现在我们可以运行，
And now we can run,

743
00:54:28,160 --> 00:54:32,210
我们可以单步检查函数，看看会发生什么。
we can just kind of step through our function and see what happens.

744
00:54:32,900 --> 00:54:35,660
我们调用了 sum_to ，
We've called sum_to

745
00:54:35,690 --> 00:54:40,880
可以看到返回地址被 sum_to 覆盖，
and immediately we can see that the return address was overwritten by sum_to,

746
00:54:40,880 --> 00:54:43,160
现在指向 sum_then_double 加 4 ，
to now point to sum_then_double plus four,

747
00:54:43,310 --> 00:54:45,410
这是对的，就是我们期望的。
which makes sense, you know that's what we expect,

748
00:54:45,500 --> 00:54:47,060
如果返回我们的代码，
if we go back into our code,

749
00:54:47,060 --> 00:54:51,410
调用 sum_to ， sum_to 应该返回到这里。
we call sum_to and so sum_to should return to here.

750
00:54:52,750 --> 00:54:57,820
现在我们可以单步，
And now we can step through you know so on up

751
00:54:57,850 --> 00:55:01,020
然后我们再回到。
and then we get back into.

752
00:55:03,550 --> 00:55:07,390
糟糕，出错了。
Oops, the wrong s.

753
00:55:14,490 --> 00:55:15,720
好的，我们现在在这里，
Okay, so now we're here

754
00:55:15,720 --> 00:55:19,950
当 sum_then_double 返回时，就像 Amir 说的，
and now when sum_then_double returns as exactly as Amir pointed out

755
00:55:20,820 --> 00:55:24,090
它没有恢复自己的返回地址，
its return, it has not restored its own return address

756
00:55:24,210 --> 00:55:30,250
而是它的返回地址仍然是 sum_to 使用的，
and instead its return address is still the one that was used by sum_to,

757
00:55:30,310 --> 00:55:33,640
所以我们会进入一个无限循环，
and so we will get into an infinite loop

758
00:55:33,670 --> 00:55:37,720
一遍又一遍地重复这个过程，
where we just keep doing this over and over and over again

759
00:55:37,930 --> 00:55:39,370
永远不会结束。
and we'll never terminate from it.

760
00:55:39,900 --> 00:55:42,960
我想这很好地说明了，
And so this is I think this is a good illustration of

761
00:55:42,960 --> 00:55:47,520
为什么跟踪调用者保存和被调用者保存寄存器很重要，
why it's important to keep track of our caller versus callee saved registers

762
00:55:47,730 --> 00:55:49,020
这也展示了
and hopefully this also shows

763
00:55:49,020 --> 00:55:55,190
可以使用 gdb 来调试这类问题，
that you can use kind of gdb to debug these sorts of these sorts of problems,

764
00:55:55,190 --> 00:55:57,320
让我们恢复之前的代码。
so let's restore what we had.

765
00:55:58,190 --> 00:56:05,690
我将使用其他一些演示代码来讲解。
I will go into some other demos to talk about to illustrate .

766
00:56:05,780 --> 00:56:08,750
有人问，我们为什么要减去 16 ？
Somebody ask why are we subtracting 16.

767
00:56:08,780 --> 00:56:11,660
这是为了给栈帧腾出空间，
That's to put space to get our stack frame,

768
00:56:11,930 --> 00:56:15,980
所以从栈指针中减去 16 ,
so this is subtracting 16 from the stack pointer,

769
00:56:16,010 --> 00:56:18,080
它在内存中向下移动。
so it's moving it down basically in memory.

770
00:56:18,520 --> 00:56:22,660
将其向下移动，以便我们有空间容纳自己的栈帧，
Moving it down so that we now have space for our own stack frame,

771
00:56:22,660 --> 00:56:23,830
然后我们就可以把东西放在那里。
then we can stick stuff there.

772
00:56:24,360 --> 00:56:29,280
因为这时候，我们不想覆盖栈指针上的东西，
So because at this point, in fact that we don't want to override what's at the stack pointer,

773
00:56:29,730 --> 00:56:35,350
为什么不是 4 ，
why not 4 I is just well 4,

774
00:56:36,890 --> 00:56:40,550
我们需要 16 ，因为指令是 64 位。
we need to do 16 because instructions are 64.

775
00:56:42,560 --> 00:56:48,050
是的，我想实际上不一定需要 16 ，
Yeah I guess I guess we wouldn't don't actually need to do 16,

776
00:56:48,110 --> 00:56:52,740
但通常你会看到，
but that's generally what you'll see generally just see,

777
00:56:52,740 --> 00:56:57,750
我想不能使用 4 ，因为需要 8 ，
I don't think yeah you, you can't you can't do 4 because you need 8.

778
00:56:58,070 --> 00:57:02,930
不能使用 4 ，但我想你可以使用指令大小，
So 4 doesn't work, but I think you could do the instruction size,

779
00:57:03,320 --> 00:57:05,960
而寄存器大小是 64 位，
and the size of the register registers are 64,

780
00:57:06,260 --> 00:57:09,620
那么为什么通常看到 16 是因为，
yeah, and then so the convention why you usually see 16 is because

781
00:57:09,620 --> 00:57:15,140
如果我们回到文档，通常有返回地址和帧指针，
if we jump back to our document, usually we have the return address and the frame pointer ,

782
00:57:15,140 --> 00:57:21,200
我们在这里不这样做，因为不是非常小心地处理我们的汇编。
we're not doing that here because or being [not super careful] with our assembly.

783
00:57:22,240 --> 00:57:24,100
所以通常情况下，如果我们看内部，
So normally, if we if we look in,

784
00:57:24,100 --> 00:57:25,810
我肯定，
I'm sure,

785
00:57:25,810 --> 00:57:28,030
如果我们看内核，就会明白这一点。
if we look in kernel at this and we'll see.

786
00:57:29,010 --> 00:57:33,150
我们查看内核数据，发现它也是 16 ，
Yeah, so we look in kernel data we see it's also 16,

787
00:57:33,150 --> 00:57:35,040
这通常是编译器处理后看到的。
this is generally what you'll see with the compiler.

788
00:57:37,970 --> 00:57:42,230
好的，现在我们可以。
Um, OK, so now we can.

789
00:57:44,000 --> 00:57:44,960
在这之后。
After this.

790
00:57:46,680 --> 00:57:50,490
我们修复函数，现在看一些 C 代码。
We fix our function and now we can look at some C code.

791
00:57:54,650 --> 00:57:57,770
好的，现在我们有 demo4 ，
Alright, so here we have demo4

792
00:57:57,770 --> 00:58:02,220
它基本上就是 main 函数的复制，
which is just basically, a copy of main function,

793
00:58:02,220 --> 00:58:05,220
是对 main 函数的模拟，
like a imitation of the main function,

794
00:58:05,400 --> 00:58:10,620
我们有 args ，它是一个字符串数组，
so we have our args, which is an array of strings

795
00:58:10,740 --> 00:58:12,390
我们有 dummymain ，
and we have dummymain

796
00:58:12,390 --> 00:58:16,800
它接收一些参数和参数字符串，
which takes a number of arguments and the arguments string

797
00:58:16,800 --> 00:58:19,470
然后打印出来。
and just print it out, for us.

798
00:58:20,130 --> 00:58:24,390
这就是所有的，都很简单，
And so that's all that's that's all that's happening here is pretty straightforward,

799
00:58:24,630 --> 00:58:29,010
如果我们在 dummymain 中设置断点，
if we set a break point in dummymain,

800
00:58:31,380 --> 00:58:34,170
然后跳过来。
then hop over, let.

801
00:58:35,620 --> 00:58:40,840
好的，我们继续，运行 demo4 ，
Okay, we'll just continue and we start this run demo4,

802
00:58:40,960 --> 00:58:44,180
现在我们到了 dummymain 。
okay so we now we hit dummymain.

803
00:58:45,080 --> 00:58:50,570
有几件重要的事要记住，
And there's a couple of important things to remember about,

804
00:58:51,560 --> 00:58:54,410
你可以使用 gdb 来显示栈帧，
 that you can use gdb for regarding stack frames,

805
00:58:54,590 --> 00:58:58,340
我们输入 i ，也就是 info ，
so if we type i so again, that's info,

806
00:58:58,340 --> 00:59:04,640
如果我们输入 i frame ，可以看到很多关于当前栈帧的信息，
if we type i frame, we can see a whole bunch of useful information about the current stack frame,

807
00:59:04,790 --> 00:59:06,770
可以看到，我们在栈级别 0 ，
so we can see we're at stack level zero,

808
00:59:06,770 --> 00:59:10,550
级别 0 意味着它[]在调用栈下面，
level zero means it's [] is down in the call stack

809
00:59:10,550 --> 00:59:14,750
我们可以转到，而且帧在这个地址。
that we can go and the frame is at this address.

810
00:59:15,570 --> 00:59:19,140
程序计数器也没问题，一切都很好，
The program counter which is okay, that's all well and good,

811
00:59:19,200 --> 00:59:21,450
我们有一个安全的程序计数器，
we have a safe program counter as well,

812
00:59:21,630 --> 00:59:28,680
如果我们使用这个地址跳转到 kernel.asm 。
and if we again if we take this address and we jump into kernel.asm.

813
00:59:29,850 --> 00:59:31,410
我们搜索那个地址，
We search for that address,

814
00:59:31,470 --> 00:59:40,190
我们可以在 demo4 中找到那个地址，
we can indeed that that addresses inside of inside of demo4,

815
00:59:40,190 --> 00:59:44,420
这正是我们希望程序返回的地址，
which is exactly where we expect the program to return to

816
00:59:44,690 --> 00:59:48,140
它是由这个地址的帧调用的，
and it was called by a frame at this address

817
00:59:48,170 --> 00:59:49,760
源代码 C ，
source language C,

818
00:59:49,790 --> 00:59:51,740
很高兴知道这一点，
that's that's nice to know

819
00:59:51,740 --> 00:59:56,030
然后我们有参数列表，也是从这个地址开始的，
and then we have the argument list also starts this address,

820
00:59:56,030 --> 01:00:01,070
当然，本例中我们的大部分参数都在寄存器中，
of course, in this case, we have most of our arguments in registers

821
01:00:01,190 --> 01:00:04,070
我们甚至可以看到 args 是什么，
and then we can even see what args are,

822
01:00:04,070 --> 01:00:09,490
argc 是 3 ， argv 是这个地址。
we argc is three and argv is this address.

823
01:00:10,440 --> 01:00:13,920
如果我们想要更深入研究一些东西，
And if we want a more in-depth examine things

824
01:00:13,920 --> 01:00:16,830
可以使用 info args 命令，
we can look at things like info args,

825
01:00:17,680 --> 01:00:23,080
它告诉我们有关函数参数的信息，我们可以查看，
which will tell us information about the arguments to the function, we can look at,

826
01:00:23,200 --> 01:00:29,650
但更重要的是，我们可以输入 backtrace 或 bt ，
but more importantly we can type we type backtrace or bt works as well,

827
01:00:29,860 --> 01:00:34,660
我们得到了整个栈帧的 backtrace ，
we get a full backtrace of all of the stacks,

828
01:00:34,690 --> 01:00:38,170
调用栈中的所有栈帧，
 all of the stack frames from the call stack,

829
01:00:38,170 --> 01:00:40,630
你可以在这里看到一些问题，
so you can see something questionable happen here,

830
01:00:40,630 --> 01:00:42,460
当我们调用系统调用时，
that's when we invoke a system call,

831
01:00:42,850 --> 01:00:45,640
然后我们到达 usertrap 函数，
then we get to the usertrap function,

832
01:00:45,670 --> 01:00:47,530
然后是 syscall 函数，
then to the syscall function,

833
01:00:47,590 --> 01:00:50,710
然后是 sys_demo ，然后是 demo4 。
then to sys_demo then to demo4.

834
01:00:51,510 --> 01:00:53,340
然后转到 dummymain ，
And then finally to dummymain

835
01:00:54,210 --> 01:00:58,350
如果我们想更深入研究这些栈中的一个，
and if we want to investigate any of these stack frames more in-depth,

836
01:00:58,350 --> 01:01:03,240
我们可以使用 frame 再加上一个数字，
we can do frame and then whatever number is along the side here,

837
01:01:03,240 --> 01:01:07,350
比如我想看看当 syscall 调用时栈帧是什么，
so let's say I want to look at what was my stack frame when syscall called,

838
01:01:07,350 --> 01:01:08,670
我可以查看第 3 帧，
I can go to frame three,

839
01:01:08,940 --> 01:01:12,180
现在，在 gdb 里面，我正在查看栈帧，
and so now, inside of gdb, I'm looking at that stack frame,

840
01:01:12,180 --> 01:01:14,910
我输入 info frame ，可以得到这个。
so I type info frame I can get this.

841
01:01:15,700 --> 01:01:18,640
这里我们得到了更多信息，
And here we get a lot more a lot more information

842
01:01:18,640 --> 01:01:20,980
有很多保存寄存器。
we have a bunch of saves registers.

843
01:01:21,410 --> 01:01:25,070
我们有一些局部变量，
Um, we have some local variables,

844
01:01:25,070 --> 01:01:27,440
这个函数没有任何参数，
we don't have any arguments to this function,

845
01:01:27,530 --> 01:01:31,040
我们可看到程序计数器应该跳回到哪里，
we can see where the program counter were supposed to jump back to,

846
01:01:31,160 --> 01:01:32,750
诸如此类的东西，
all kinds of things like that,

847
01:01:32,750 --> 01:01:35,780
所以，如果你在调试东西，这是非常有用的。
so this is super super useful for if you're debugging things,

848
01:01:35,780 --> 01:01:37,130
事实上，它非常有用，
and in fact it's so useful,

849
01:01:37,160 --> 01:01:43,580
我们让你自己实现的版本，远不如 gdb 告诉你的那样深入。
we make you implement your own version, nowhere near as in depth as what gdb tells you,

850
01:01:43,730 --> 01:01:46,820
我们在下一个实验中的练习之一，
but we're one of the exercises on the next lab

851
01:01:46,820 --> 01:01:50,480
是实现你自己的 backtrace helper 函数，
will be to implement your own backtrace helper function,

852
01:01:50,480 --> 01:01:53,000
以便在实验内调试时使用。
for use when debugging things inside the lab.

853
01:01:54,110 --> 01:01:56,690
因此 backtrace 非常有用，
And so back backtrace is quite useful,

854
01:01:56,780 --> 01:02:00,980
如果我们输入 frame 0 ，就会返回到刚才的位置。
and then if we type frame zero, we go back to where we were supposed to be.

855
01:02:02,900 --> 01:02:04,670
如果我们想要调查，
And if we want to investigate,

856
01:02:04,670 --> 01:02:06,890
你可能注意到这不是很有帮助，
you probably noticed it's not super helpful,

857
01:02:06,890 --> 01:02:10,460
argv 是字符串数组形式的字符串，
you know argv is a string as an array of strings

858
01:02:10,460 --> 01:02:13,700
而且我们只拿到了地址，
and so we just got a ref, we just get an address,

859
01:02:13,760 --> 01:02:17,570
如果我们想看看地址里面是什么，
for where that's actually stored and if we want to look at what's in there,

860
01:02:17,570 --> 01:02:19,130
有几种方法可以做到，
there's a couple ways of doing this,

861
01:02:19,250 --> 01:02:23,720
最简单的是，输入 print ， p 表示打印，
the easiest is if we type print, p is for print,

862
01:02:24,050 --> 01:02:27,920
然后我们间接引用该地址，
and then if we dereference the address,

863
01:02:27,920 --> 01:02:29,780
我们看看地址那里是什么，
so we go look at what's at address,

864
01:02:29,930 --> 01:02:32,390
我们这样做，
we do that and,

865
01:02:32,390 --> 01:02:36,820
你知道，正如预期的，我们得到了该数组的第一个元素，
you know, as you would expect, we get the first element of that array,

866
01:02:36,820 --> 01:02:39,280
因为当它试图打印字符串时，
because when it tries to print a string,

867
01:02:39,280 --> 01:02:42,850
就像 C 语言里，它会一直运行，直到遇到空字符，
it'll go as C says, it'll go until it hits the null character,

868
01:02:43,030 --> 01:02:45,190
所以我们得到 foo ，它是数组中的第一个元素，
so we get foo which is the first element in that array,

869
01:02:45,190 --> 01:02:49,060
如果我们想要得到更多，可以加上一个长度，
and if we want to get more things we can put in the length,

870
01:02:49,090 --> 01:02:51,150
如果我们输入 @ ，然后一个数字，
so if we do @ then a number,

871
01:02:51,150 --> 01:02:52,740
它会上升到某个索引，
it'll go up to a certain index,

872
01:02:52,920 --> 01:02:55,410
然后我们可以看到这两个字符串，
so then we can see both of the strings here

873
01:02:55,800 --> 01:02:58,890
同样， gdb 非常聪明，
and again gdb is quite smart,

874
01:02:58,890 --> 01:03:04,320
我们甚至可以用 argc 打印整个参数数组。
so we can even use argc to print out the whole argument array.

875
01:03:05,590 --> 01:03:08,890
所有的信息对你来说都是可用的，
And so all of that information is available to you,

876
01:03:09,130 --> 01:03:13,360
不管你想得到什么， gdb 是很有用的工具。
you , however you want to get it, so gdb the superpower tool.

877
01:03:14,290 --> 01:03:16,780
为什么 gdb ，不好意思，
Why does gdb sorry,

878
01:03:16,780 --> 01:03:22,360
为什么编译器有时候会优化 argc 和 argv ，
why does the compiler sometimes optimize out argc and argv,

879
01:03:22,360 --> 01:03:23,830
之前发生过这样的事。
that has happened to be before.

880
01:03:24,340 --> 01:03:27,820
这意味着编译器找到了一种更有效的方法，
Yeah that just means that the compiler found a more efficient way,

881
01:03:27,820 --> 01:03:31,570
很可能只是去掉了变量，并进行所有操作，
likely it just got rid of the variable and it's doing all of its operations,

882
01:03:31,810 --> 01:03:36,490
你知道[]寄存器可能在 a0 上执行所有操作，
directly you know [] register might be doing all of its operations on a0,

883
01:03:36,490 --> 01:03:40,820
比如，它可能只是对返回地址进行所有计算。
for example, it might just be doing all the computations on the return address.

884
01:03:41,120 --> 01:03:42,980
这很常见，
It's pretty common to see something like that,

885
01:03:42,980 --> 01:03:48,550
如果它是一个非必须的变量。
if you if it's a variable that's not you know a hundred percent necessary.

886
01:03:48,790 --> 01:03:52,480
我们不能控制编译器，
If you know we don't let we don't give you control over the compiler,

887
01:03:52,480 --> 01:03:54,310
但是如果你在平时发现这个，
but if you ever find that in your day-to-day,

888
01:03:54,460 --> 01:03:59,290
你可以尝试将编译器的优化标志设置为零，
you can try setting the optimization flag for the compiler to zero,

889
01:03:59,530 --> 01:04:04,660
但即使这样，编译器仍会做一定程度的优化。
but even then you know the compiler will do will do it, we'll do some level of optimization.

890
01:04:05,550 --> 01:04:07,320
Bibic 你举手了。
Bibic, your hand is raised.

891
01:04:08,310 --> 01:04:16,380
是的，在 $1 和 $2 后面的地址是什么，就是在 foo 或 bar 之前的，
Yeah what's the address, besides that $1 or $2 you know like before foo or bar.

892
01:04:16,620 --> 01:04:18,180
美元符号，你说这个吗？
Dollar, this?

893
01:04:18,870 --> 01:04:23,160
是的，那个地址就是 foo 所在的地址。
Yeah, so what's that address is that the address where foo is.

894
01:04:23,640 --> 01:04:24,450
可能是吧。
Probably yes.

895
01:04:25,990 --> 01:04:30,160
但是，然后 argv 指向其他地址，它们不应该是相同的。
But then argv points to some other address shouldn't those be the same.

896
01:04:32,080 --> 01:04:34,810
所以 argv 在这个栈上，
So argv is on this stack,

897
01:04:35,140 --> 01:04:39,910
如果你看这些地址，
and you know, so the reason why, if you look at these addresses,

898
01:04:39,910 --> 01:04:44,350
我们可以看到它们在内核中，就在 8000 。
we can see that they're in the kernel, just by the 8000.

899
01:04:44,760 --> 01:04:48,900
这是有道理的，因为我们静态声明，
Um, which makes sense because we declared statically right,

900
01:04:48,900 --> 01:04:51,540
所以在示例程序中，如果我走到这里，它们会在这里声明。
so in demos, if I go here they're declared here.

901
01:04:52,000 --> 01:04:54,460
所以它们位于内核的某个地方，
And so they're basically they're sitting somewhere in the kernel

902
01:04:54,820 --> 01:05:00,130
and they're all [] stars argc or argv is an array of [] stars

903
01:05:00,130 --> 01:05:06,870
所以我想每个元素都指向自己的字符串，
and so I imagined each element points to points to its own string right,

904
01:05:07,020 --> 01:05:08,880
它是一个指针数组。
so it's an array of pointers.

905
01:05:10,420 --> 01:05:10,810
我明白了。
I see.

906
01:05:17,060 --> 01:05:18,350
[]
[]

907
01:05:24,700 --> 01:05:26,440
我也有一个问题，
I also have a question about this,

908
01:05:26,470 --> 01:05:31,860
$3 版本的数组具有，
the $3 version of the array has

909
01:05:31,860 --> 01:05:33,690
如果看这些地址， 
if I look at these addresses

910
01:05:33,930 --> 01:05:36,890
第一个后缀是 38 ，
the first one is suffixed by 38,

911
01:05:37,160 --> 01:05:39,500
第二个后缀是 40 ，
the second one is suffixed by 40

912
01:05:39,650 --> 01:05:42,080
第三个是 48 。
and the third one is 48.

913
01:05:42,500 --> 01:05:48,710
这不是统一的，虽然三个参数的长度都是三个，
Which is not uniform, even though the length of each of the three arguments is three,

914
01:05:49,220 --> 01:05:50,900
所以为什么它们是不同的。
so why, why are they different.

915
01:05:51,140 --> 01:05:55,070
嗯，我也不是百分百确定，
Um, not in I'm not a hundred percent certain,

916
01:05:55,070 --> 01:05:58,280
我猜是为了对齐数据。
my guess is that this is an attempt to align things.

917
01:05:58,700 --> 01:06:04,100
让它们保持合理的位置，
Um, right, so to get them on a reasonable alignment,

918
01:06:04,610 --> 01:06:07,100
有人指出它们用十六进制表示是对齐的。
it is uniform in hex as, people are pointing out.

919
01:06:08,430 --> 01:06:15,420
好的，理解了，谢谢。
Oh yeah, yeah yeah see it now right, thanks.

920
01:06:15,870 --> 01:06:19,590
所以有时候你看到东西放在那里很奇怪，
So you'll sometimes see where strange things are laid out strangely

921
01:06:19,650 --> 01:06:22,110
可能是两个东西有不同的偏移量，
where there might be two things as strange offsets

922
01:06:22,110 --> 01:06:25,740
因为并不是所有的东西都是相同大小的。
and that's just because not everything is naturally the same sized.

923
01:06:26,300 --> 01:06:29,510
好的，还有其他问题吗？
Okay, any other questions.

924
01:06:37,230 --> 01:06:40,620
好的，我们可以跳过第五个 demo 。
Okay, we can skip the fifth demo.

925
01:06:41,150 --> 01:06:46,250
gdb 的另一个有用的功能是，
And so another useful function that we get from gdb,

926
01:06:46,460 --> 01:06:51,680
不仅有断点，还有观察点，
instead of just break points, they're also watch points

927
01:06:51,680 --> 01:06:55,010
并且我们还可以设置有条件的断点。
and we can also set a conditional break points.

928
01:06:55,250 --> 01:07:00,200
我简单介绍一下。
So, I'll just briefly go over that.

929
01:07:02,160 --> 01:07:06,840
运行 demo6 以便我们可以在函数中设置，
Run demo6 so we can set inside this function,

930
01:07:06,840 --> 01:07:09,330
我们可以设置观察点，
we can watch so we can set a watch point,

931
01:07:09,540 --> 01:07:12,720
我想在这里你可以看到。
I think here you'll see .

932
01:07:15,680 --> 01:07:22,460
向 Luke 所说的，一些东西被优化了，
Yeah, so here you'll see what Luke was talking about where we see that some has been optimized out,

933
01:07:22,670 --> 01:07:25,640
可能是因为它只是零或别的什么。
likely because it's just being a zero or something.

934
01:07:27,060 --> 01:07:29,280
我们可以看一下这个汇编，
We can look even at the assembly for this right,

935
01:07:29,280 --> 01:07:32,220
我们可以使用 layout split 。
so we can layout split.

936
01:07:32,980 --> 01:07:37,830
事实上，可以看到所有都是在栈上完成的，
And indeed, we can see that all just being, It's all just being done on the stack,

937
01:07:37,830 --> 01:07:38,760
在我看来。
it looks like to me.

938
01:07:40,280 --> 01:07:43,190
不，这都是在 s0, s0 1 3 上做的，
Oh, no, it's always been done in s0 s0 one three,

939
01:07:43,400 --> 01:07:49,880
在这里你可以看到，编译器使用的是被调用者保存寄存器，
so here you can see the, compiler decided even to use the callee saved registers

940
01:07:51,410 --> 01:07:57,600
这样我们可以设置，对 i 进行观察。
and so we can set things like we do watch on i.

941
01:07:58,360 --> 01:07:59,980
好的，我们还没有声明 i ，
Alright we haven't declared i,

942
01:07:59,980 --> 01:08:05,040
因为我们不在循环里面，
yet because we're not inside we're not inside the for loop.

943
01:08:05,220 --> 01:08:08,350
所以我们单步执行 C 代码，
So we step through the C instructions,

944
01:08:08,350 --> 01:08:12,400
现在我们对本地变量查看信息，会看到 i ，
now if we do information for the locals, we see we get i,

945
01:08:12,430 --> 01:08:16,780
我们甚至可以在 sum 设置观察点。
we can even watch watch point on sum.

946
01:08:17,640 --> 01:08:23,250
现在任何时候 sum 改变都会收到通知，
So now anytime that sum changes will actually get a notification,

947
01:08:23,250 --> 01:08:27,160
我们继续，然后这里有一个删除，
so we can continue and then we'll get a delete here,

948
01:08:27,160 --> 01:08:31,480
因为有东西被删除了，所以我们不能查看它，
because some has been moved so we can't we can't actually watch it,

949
01:08:31,600 --> 01:08:37,030
我们甚至可以做一些事情，比如在 sum_to 上设置断点，
we can even do things like break point on sum_to,

950
01:08:37,030 --> 01:08:44,190
这是一个条件断点，如果 i 现在是 1 ，
so this is a conditional break point if, well, let's actually see was i currently, so i currently 1,

951
01:08:44,250 --> 01:08:48,720
比如，让循环在 i 是 5 的时候中断，
let's say I think my loop is breaking and whenever i is 5,

952
01:08:48,810 --> 01:08:51,630
如果我想专门调试这种情况，
well if I want to specifically debug that case,

953
01:08:51,660 --> 01:09:01,850
我可以在 sum_to 上设置一个断点，如果 i 等于 5 。
I can set a break point on sum_to if i equal 5.

954
01:09:02,850 --> 01:09:06,540
现在我们有了这个断点，如果我们继续
So now we have this break point, and if we continue along,

955
01:09:06,570 --> 01:09:13,260
我们得到 sum_to ，可以看到它打印了第一组值，
we'll get to sum_to, and we can see that it actually printed out the first couple values

956
01:09:13,320 --> 01:09:20,090
现在我们只在 i 符合条件时在 sum_to 上中断。
and so we only break now on sum_to if if i if we hit that break point condition.

957
01:09:21,280 --> 01:09:26,380
也就是说，如果你要调试代码特定的边界条件，它会很有用，
And so that's, it can be again can be useful if you want to debug specific edge cases of your code

958
01:09:26,470 --> 01:09:28,450
观察点可能会很有用，
and watch points can be useful

959
01:09:28,870 --> 01:09:33,640
如果你认为某些东西不应该改变，但你怀疑它改变了，
if for instance you think that something shouldn't be changing, but you suspect that it is

960
01:09:33,670 --> 01:09:38,530
或者你认为每次你改变某个变量都会出问题。
or you think that something is going wrong every time you change a certain variable.

961
01:09:40,000 --> 01:09:42,790
这是它的一种用法。
And so that's that's a it's one one usage for that.

962
01:09:43,630 --> 01:09:47,590
今天，我最后要说的是结构体（struct），
And the last thing I want to talk about today is struct,

963
01:09:47,860 --> 01:09:54,670
结构体非常重要，它会经常出现在实验里，
struct pretty important, they'll come up in in the labs often

964
01:09:54,910 --> 01:09:56,740
还有。
and also.

965
01:09:57,310 --> 01:10:02,590
所以我会简单介绍一下结构体在内存中的布局。
So, what as, I'll talk a little bit about the way structs are laid out in memory.

966
01:10:03,750 --> 01:10:08,610
基本上，一个结构体就是一个连续的内存区域，
And so a structure is basically it's a continued contiguous area of memory,

967
01:10:08,610 --> 01:10:09,810
所以如果我们有一些结构体。
so if we have some structure.

968
01:10:11,510 --> 01:10:15,800
我们有字段一，字段二，字段三。
And we have like field one field two field three.

969
01:10:17,110 --> 01:10:18,220
当我们创建该结构体时，
When we make that struct

970
01:10:18,220 --> 01:10:22,770
在内存中，这些字段将挨着排在一起。
those fields are going to be align next to each other in memory,

971
01:10:22,770 --> 01:10:25,470
你可以把它想象成一个数组，
you can kind of think of this like an array,

972
01:10:25,470 --> 01:10:28,110
但是 f1 f2 f3 可以是不同的类型。
but f1 f2 f3 can all be different types.

973
01:10:28,380 --> 01:10:32,880
而且，我们可以把它们传递给函数，
And, we can pass them [] functions,

974
01:10:32,880 --> 01:10:37,620
它们作为参数传递给函数，通常是通过引用，
usually they pass them as arguments to functions, usually they pass by reference,

975
01:10:37,710 --> 01:10:42,420
这里有一个结构体 person ，包含两个整型参数，
so here I've made a struct person with two integer arguments,

976
01:10:42,660 --> 01:10:47,990
我传递一个 person 作为参数，
and I'm passing them, passing a person as an argument person

977
01:10:48,320 --> 01:10:51,710
并打印出其中的一些信息，
and printing out some of that information,

978
01:10:52,160 --> 01:10:54,290
如果我们进入 gdb ，
so if we hop into gdb

979
01:10:54,290 --> 01:10:56,780
让我们删除所有的断点和观察点，
and let's delete all our break points and watch points,

980
01:10:56,990 --> 01:11:00,980
现在我们在 printPerson 上设置一个断点，
and now we can set a break point at printPerson,

981
01:11:01,680 --> 01:11:06,360
继续，并运行第七个 demo 。
and it's continue and run seventh demo.

982
01:11:07,640 --> 01:11:10,700
现在可以看到，我们在这里，如果输入 i frame ，
We can see that now we're here and so if we type i frame,

983
01:11:10,940 --> 01:11:14,840
我们可以看到，我们有一个参数 p 。
we can see that we have an argument p.

984
01:11:15,310 --> 01:11:19,630
事实上，如果我们打印 p ，
And indeed, we can see if we do print p,

985
01:11:20,780 --> 01:11:24,710
甚至能辨别出这个地址是 struct person ，
If we can even tell that it's struct person at this address

986
01:11:25,910 --> 01:11:28,850
我们可以间接引用它，
and we can if we dereference it,

987
01:11:30,210 --> 01:11:36,290
gdb 告诉我们 p 的 id 是 1215 ， age 是 22 。
gdb will tell us exactly what p looks like it has id 1215 age 22.

988
01:11:37,660 --> 01:11:41,590
只是展示一下结构提是怎么存放的。
And just to show kind of how things are laid out.

989
01:11:42,060 --> 01:11:47,520
你可以取这个地址，我们可以在这个地址看到，
You can take this address and we see at this address,

990
01:11:48,060 --> 01:11:55,110
如果我们看。我记得很清楚。
if we look. I remember exactly.

991
01:11:57,380 --> 01:11:57,920
应该是的。
Should be.

992
01:12:02,180 --> 01:12:06,860
如果我们再来一次，可以用这个来调试我们的结构体。
So if we again so we can use this to debug our structures.

993
01:12:07,900 --> 01:12:15,310
在代码中，我们可以看一下结构体是怎么回事，
In in the code, we can take a look at what's going on with structures this way,

994
01:12:15,340 --> 01:12:18,100
因此 gdb 是非常强大的工具，
so gdb is a super powerful tool

995
01:12:18,100 --> 01:12:20,590
不仅用于单步执行，
not just for stepping through code,

996
01:12:20,590 --> 01:12:27,430
还用于检查代码中各种类型的潜在问题。
but also for examining all kinds of potentially problematic pieces in your code

997
01:12:27,430 --> 01:12:30,520
而且可以查看参数和栈帧，
and looking at arguments and stack frames and things like that,

998
01:12:30,850 --> 01:12:34,510
这在下一个实验中很有用，
and this will be hopefully will be useful in the next lab,

999
01:12:35,270 --> 01:12:39,680
当你必须使用栈帧和汇编来编程时。
when you have to work with, with stack frames and with assembly code.

1000
01:12:40,080 --> 01:12:43,470
这就是我今天想讲的主要内容。
So that's that's mostly what I wanted to talk about today.

1001
01:12:43,470 --> 01:12:47,910
最后还有 7 分钟，
So, with the last kind of seven minutes of lecture,

1002
01:12:47,910 --> 01:12:51,870
你们可以提任何问题。
I'll open it up to any any other questions you guys have.

1003
01:12:59,510 --> 01:13:01,250
我有一个离题的问题，
I had a bit of a tangential question,

1004
01:13:01,880 --> 01:13:05,870
谁管理从 C 到各种指令集架构
who is who manages the creation of compilers

1005
01:13:05,870 --> 01:13:10,100
的编译器的创建，
from to get from C to various instruction set architectures,

1006
01:13:10,100 --> 01:13:14,000
是指令集架构的创建者，或是类似的但三方机构。
is that the creator of the instruction set architecture, is the third parties like that.

1007
01:13:14,500 --> 01:13:19,960
我想不是指令集的创建者，
Um, I believe that it is not the creative the instruction set,

1008
01:13:19,960 --> 01:13:21,700
通常是第三方，
so it's often a third party,

1009
01:13:22,060 --> 01:13:24,430
你们知道的的两个大的 C 编译器，
so the two big C compilers that you'll see

1010
01:13:24,430 --> 01:13:29,530
GCC 是由 GNU 基金会维护的，
refer to GCC which is maintained by I think the GNU foundation

1011
01:13:29,950 --> 01:13:34,990
Clang llvm 是自己维护的，
and Clang llvm, which is its own thing,

1012
01:13:34,990 --> 01:13:39,520
你可以发现， llvm 甚至是开源的，
so I think you know you can find I believe llvm is even open source,

1013
01:13:39,520 --> 01:13:44,430
这样你就能找到，专门做这件事的代码。
so you can find. you can, you can find the code specifically that does this,

1014
01:13:44,550 --> 01:13:48,630
当一个像 RISC-V 的新指令集发布时，
when a new instruction set is released such as RISC-V,

1015
01:13:48,720 --> 01:13:53,040
调用约定文档以及所有这些指令文档一起发布，
that calling convention document as well as all of those instruction documents,

1016
01:13:53,280 --> 01:13:55,050
我猜，
I think carefully I assume

1017
01:13:55,050 --> 01:14:00,840
可能编译器设计者和指令集设计者之间有高级别的合作。
there's a high level of cooperation between the compiler designer and the instruction set designer .

1018
01:14:01,550 --> 01:14:05,720
但简单来说，我相信是第三方维护的，
But yeah a short answer is I believe it's a third party who does it,

1019
01:14:05,720 --> 01:14:09,710
很可能与指令集制作人员的大量合作。
likely with a lot of cooperation from the people who make the instruction set.

1020
01:14:09,770 --> 01:14:16,320
RISC-V 可能是一个例外，因为它来自一个研究项目，
RISC-V is probably, RISC-V might be an exception where because it came out of a research project,

1021
01:14:16,440 --> 01:14:20,770
他们可能也自己编写了编译器。
they may have written the compiler for it themselves, as well.

1022
01:14:21,410 --> 01:14:27,590
我不认为英特尔在 GCC 或 llvm 上有所投入。
I I don't think Intel has for example has input in in GCC or llvm.

1023
01:14:45,530 --> 01:14:46,490
还有其他问题吗？
Other questions?

1024
01:14:54,650 --> 01:14:58,790
好的，感谢收听，
Okay, well, thanks for listening,

1025
01:14:58,790 --> 01:15:00,890
那样的话，我想我们可以。
in that case I guess we can.

1026
01:15:01,790 --> 01:15:03,740
你可以在这里结束，
You can end the lecture here,

1027
01:15:03,800 --> 01:15:07,520
还有 5 分钟，好好休息一下。
a five minutes to spare, so have a nice rest.

