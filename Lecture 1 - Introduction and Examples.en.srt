1
00:00:01,900 --> 00:00:04,270
All right,

2
00:00:04,270 --> 00:00:08,770
welcome to 6.S081 operating systems,

3
00:00:08,770 --> 00:00:10,720
I'm Robert I'll be co-lecturing

4
00:00:10,720 --> 00:00:14,320
with Frans and David and Nicolaas

5
00:00:14,320 --> 00:00:16,180
of the TAs.

6
00:00:16,450 --> 00:00:16,960
So,

7
00:00:16,960 --> 00:00:18,850
um please during the zoom lectures,

8
00:00:18,850 --> 00:00:19,690
ask questions,

9
00:00:19,690 --> 00:00:21,460
you can either interrupt me by

10
00:00:21,460 --> 00:00:24,280
audio or enter something into

11
00:00:24,280 --> 00:00:25,740
the chat window.

12
00:00:25,840 --> 00:00:26,440
Um,

13
00:00:26,440 --> 00:00:27,730
one of the staff will see and ask

14
00:00:27,730 --> 00:00:28,840
question for you.

15
00:00:29,900 --> 00:00:31,430
By the way we'll be recording these

16
00:00:31,430 --> 00:00:33,680
lectures and then we'll post recordings later

17
00:00:33,680 --> 00:00:36,170
so you can review them or for

18
00:00:36,170 --> 00:00:38,180
people who can't make this time so

19
00:00:38,180 --> 00:00:39,740
they can nevertheless see lectures.

20
00:00:40,710 --> 00:00:43,680
All right, I want to start by

21
00:00:43,680 --> 00:00:44,850
laying out some of the goals

22
00:00:44,850 --> 00:00:46,500
of the course. So,

23
00:00:46,750 --> 00:00:49,330
number one is to um,

24
00:00:49,330 --> 00:00:53,680
understand a design and implementation

25
00:00:53,680 --> 00:00:56,180
of operating systems.

26
00:00:56,310 --> 00:00:57,120
Um,

27
00:00:57,120 --> 00:00:58,120
yeah,

28
00:00:58,840 --> 00:01:01,210
design is sort of high level structure

29
00:01:01,210 --> 00:01:03,550
and implementation is really about what the

30
00:01:03,550 --> 00:01:04,600
code looks like,

31
00:01:04,600 --> 00:01:06,740
and we'll spending a lot of time with both.

32
00:01:07,940 --> 00:01:11,840
And in the interest of getting a

33
00:01:11,840 --> 00:01:13,640
deep understanding of what's going on,

34
00:01:13,640 --> 00:01:18,280
you'll get hands-on experience with a small.

35
00:01:18,420 --> 00:01:19,500
Um,

36
00:01:21,060 --> 00:01:23,130
a small operating system,

37
00:01:23,130 --> 00:01:24,980
the xv6 operating system.

38
00:01:25,320 --> 00:01:26,940
Um,

39
00:01:26,940 --> 00:01:27,420
and,

40
00:01:27,420 --> 00:01:29,010
in addition to actually looking at an

41
00:01:29,010 --> 00:01:30,270
existing operating system,

42
00:01:30,270 --> 00:01:33,270
you'll be a in the labs

43
00:01:33,270 --> 00:01:35,070
get a bunch of experience extending

44
00:01:35,070 --> 00:01:37,410
the operating system modifying improving its

45
00:01:37,410 --> 00:01:41,100
behavior and writing system software that

46
00:01:41,100 --> 00:01:43,740
it uses the operating system interfaces,

47
00:01:43,740 --> 00:01:45,140
if it works an application.

48
00:01:45,320 --> 00:01:45,980
Um,

49
00:01:46,520 --> 00:01:47,420
So,

50
00:01:47,420 --> 00:01:47,780
um,

51
00:01:47,780 --> 00:01:48,560
so this is what you're going to

52
00:01:48,560 --> 00:01:49,730
be doing in the course,

53
00:01:49,730 --> 00:01:50,800
um,

54
00:01:51,560 --> 00:01:52,400
um.

55
00:01:52,980 --> 00:01:55,710
We're also interested in what the purpose

56
00:01:55,710 --> 00:01:57,360
of the operating system itself is as

57
00:01:57,360 --> 00:01:58,800
well as the course.

58
00:02:00,980 --> 00:02:02,090
So for that I have a

59
00:02:02,090 --> 00:02:04,040
sort of list of a couple

60
00:02:04,040 --> 00:02:05,540
of things which,

61
00:02:05,540 --> 00:02:08,630
um you know there's lots of operating system,

62
00:02:08,630 --> 00:02:10,550
different operating systems out there,

63
00:02:10,550 --> 00:02:13,780
they typically have a common set of purposes.

64
00:02:15,150 --> 00:02:20,080
Um, one of them is to abstract the hardware,

65
00:02:21,520 --> 00:02:23,770
um, that is what you're given

66
00:02:23,770 --> 00:02:25,420
typically as a kind of starting point is

67
00:02:25,420 --> 00:02:26,170
you buy a computer,

68
00:02:26,170 --> 00:02:27,760
a computer has a CPU and memory

69
00:02:27,760 --> 00:02:29,880
but that's a very low level.

70
00:02:29,940 --> 00:02:31,770
A set of resources,

71
00:02:31,770 --> 00:02:33,300
it's fantastic to have a much higher

72
00:02:33,300 --> 00:02:36,780
level interfaces and abstractions that applications can

73
00:02:36,780 --> 00:02:40,740
use such as processes or file systems

74
00:02:40,740 --> 00:02:43,740
both for convenience and for portability.

75
00:02:44,360 --> 00:02:47,180
Another very important task of an operating

76
00:02:47,180 --> 00:02:49,960
system is to multiplex the hardware

77
00:02:50,190 --> 00:02:52,000
among many applications.

78
00:02:52,360 --> 00:02:52,690
Um,

79
00:02:52,690 --> 00:02:55,120
you might be running a text editor,

80
00:02:55,120 --> 00:02:56,470
and a compiler,

81
00:02:56,470 --> 00:02:58,180
or maybe

82
00:02:58,280 --> 00:03:01,400
a multiple different database servers or something

83
00:03:01,400 --> 00:03:02,420
on your operating system,

84
00:03:02,420 --> 00:03:03,830
it's fantastic to be able to have

85
00:03:03,830 --> 00:03:05,210
the operating system run,

86
00:03:05,210 --> 00:03:06,020
both of them at the same

87
00:03:06,020 --> 00:03:07,250
time or all the things are

88
00:03:07,250 --> 00:03:08,690
going on at the same time

89
00:03:08,690 --> 00:03:10,360
without having them interfere.

90
00:03:11,420 --> 00:03:15,230
That's often called multiplexing, because

91
00:03:15,230 --> 00:03:15,980
there may be a lot of

92
00:03:15,980 --> 00:03:17,630
things happening in the operating system

93
00:03:17,630 --> 00:03:19,070
at the same time, it's critical

94
00:03:19,070 --> 00:03:21,770
that they not interfere unintentionally,

95
00:03:21,770 --> 00:03:24,500
even if they have bugs and that's

96
00:03:24,500 --> 00:03:26,820
a task is called isolation.

97
00:03:27,120 --> 00:03:28,480
The idea that,

98
00:03:28,970 --> 00:03:32,270
a different activities should not be allowed

99
00:03:32,270 --> 00:03:33,620
to interfere. On the other hand,

100
00:03:33,620 --> 00:03:36,140
there are times when different activities would

101
00:03:36,140 --> 00:03:37,070
like to interfere,

102
00:03:37,070 --> 00:03:38,870
would like to interact or cooperate,

103
00:03:38,870 --> 00:03:40,550
so for example if I create a

104
00:03:40,550 --> 00:03:42,230
file with a text editor,

105
00:03:42,230 --> 00:03:43,790
and I'd like my compiler to read

106
00:03:43,790 --> 00:03:45,830
the file and we definitely want to

107
00:03:45,830 --> 00:03:47,740
allow that kind of sharing.

108
00:03:47,860 --> 00:03:48,160
Um,

109
00:03:48,160 --> 00:03:50,380
so we wanna allow sharing [minutes],

110
00:03:50,380 --> 00:03:51,360
um.

111
00:03:51,410 --> 00:03:55,120
Sort of what the user has in mind.

112
00:03:55,670 --> 00:03:57,230
But in many circumstances,

113
00:03:57,230 --> 00:03:59,360
user doesn't want sharing maybe

114
00:03:59,360 --> 00:04:00,800
you're logged into a time sharing

115
00:04:00,800 --> 00:04:02,300
machine like Athena,

116
00:04:02,300 --> 00:04:03,500
and you don't want other people to

117
00:04:03,500 --> 00:04:04,760
read your files,

118
00:04:04,760 --> 00:04:05,000
um,

119
00:04:05,000 --> 00:04:06,380
so we also need as well sharing

120
00:04:06,380 --> 00:04:07,820
we want to not share when we

121
00:04:07,820 --> 00:04:09,640
don't want to um.

122
00:04:09,760 --> 00:04:11,740
Which we could call security or a

123
00:04:11,740 --> 00:04:15,400
permission system an access control system.

124
00:04:16,650 --> 00:04:18,360
Another thing that people value in operating

125
00:04:18,360 --> 00:04:20,040
systems is if you spend a lot

126
00:04:20,040 --> 00:04:21,180
of money on the hardware on a

127
00:04:21,180 --> 00:04:23,190
computer you'd like your application to be

128
00:04:23,190 --> 00:04:24,750
able to get a sort of full

129
00:04:24,750 --> 00:04:27,600
performance that a hardware ought to be

130
00:04:27,600 --> 00:04:30,440
able to provide. And,

131
00:04:30,650 --> 00:04:33,260
A lot of that is just application programming,

132
00:04:33,260 --> 00:04:33,980
um.

133
00:04:34,010 --> 00:04:34,700
But,

134
00:04:34,700 --> 00:04:35,570
um inevitably,

135
00:04:35,570 --> 00:04:36,020
unfortunately,

136
00:04:36,020 --> 00:04:37,760
some of it is the operating system

137
00:04:37,760 --> 00:04:41,240
has to make sure that whatever services

138
00:04:41,240 --> 00:04:43,790
it provides don't get in the way

139
00:04:43,790 --> 00:04:46,250
of applications getting high performance,

140
00:04:46,250 --> 00:04:47,510
so you want to at least not

141
00:04:47,510 --> 00:04:49,430
get in the way and maybe even

142
00:04:49,430 --> 00:04:51,540
help applications achieve

143
00:04:51,650 --> 00:04:52,860
good performance.

144
00:04:54,150 --> 00:04:54,800
Um,

145
00:04:55,880 --> 00:04:56,570
um,

146
00:04:56,570 --> 00:04:57,860
finally,

147
00:04:57,860 --> 00:04:58,740
um.

148
00:04:58,880 --> 00:05:01,460
With most operating systems have to support

149
00:05:01,460 --> 00:05:03,170
a wide range of different applications,

150
00:05:03,170 --> 00:05:05,990
maybe it's a laptop running a text editor,

151
00:05:05,990 --> 00:05:07,610
maybe it's running games,

152
00:05:07,610 --> 00:05:10,400
maybe your operating system needs to support

153
00:05:10,400 --> 00:05:12,860
database servers or cloud computation,

154
00:05:12,860 --> 00:05:15,950
and usually because operating systems are quite

155
00:05:15,950 --> 00:05:19,280
expensive to design and build, people use

156
00:05:19,280 --> 00:05:21,110
the same operating systems for many different

157
00:05:21,110 --> 00:05:22,250
tasks like Linux,

158
00:05:22,250 --> 00:05:23,720
for example which I'm sure many of

159
00:05:23,720 --> 00:05:25,340
you are running a is used in

160
00:05:25,340 --> 00:05:27,170
all of the situations I mentioned so

161
00:05:27,170 --> 00:05:28,520
the same operating system really has to

162
00:05:28,520 --> 00:05:31,380
be able to support a range of,

163
00:05:31,430 --> 00:05:32,300
um,

164
00:05:32,300 --> 00:05:34,140
often quite different uses.

165
00:05:36,830 --> 00:05:38,180
So we're hoping to be able

166
00:05:38,180 --> 00:05:40,430
to support sort of all these

167
00:05:40,430 --> 00:05:42,740
different goals simultaneously.

168
00:05:44,000 --> 00:05:45,170
And we'll hear more about all of

169
00:05:45,170 --> 00:05:46,880
them during the course.

170
00:05:47,810 --> 00:05:48,260
All right,

171
00:05:48,260 --> 00:05:48,620
um,

172
00:05:48,620 --> 00:05:49,790
operating systems,

173
00:05:49,790 --> 00:05:51,920
so people worked out a

174
00:05:51,920 --> 00:05:56,000
set of design ideas over the decades

175
00:05:56,000 --> 00:05:57,860
have worked pretty well sort of ways

176
00:05:57,860 --> 00:05:59,240
of organizing things.

177
00:05:59,310 --> 00:06:01,320
I'm going to lay out for you,

178
00:06:01,320 --> 00:06:03,460
this sort of classic.

179
00:06:05,890 --> 00:06:10,000
A organization sort of standard deal for um.

180
00:06:10,600 --> 00:06:10,960
Um,

181
00:06:10,960 --> 00:06:12,560
this course and,

182
00:06:13,380 --> 00:06:15,960
um, is actually quite common around

183
00:06:15,960 --> 00:06:17,100
for many operating systems.

184
00:06:17,100 --> 00:06:20,980
So this is sort of OS internal organization or.

185
00:06:21,830 --> 00:06:24,380
The way I think about it

186
00:06:24,380 --> 00:06:27,920
is in terms of a box

187
00:06:27,920 --> 00:06:29,810
for the computer,

188
00:06:29,810 --> 00:06:31,600
the computer sort of.

189
00:06:32,260 --> 00:06:33,850
Comes with a bunch of hardware resources,

190
00:06:33,850 --> 00:06:34,810
which I'll put at the bottom,

191
00:06:34,810 --> 00:06:38,440
maybe their CPU and ram, disk for

192
00:06:38,440 --> 00:06:42,070
storage and maybe a network interface,

193
00:06:42,070 --> 00:06:43,240
this sort of hardware,

194
00:06:43,240 --> 00:06:45,700
that's the lowest layer.

195
00:06:46,180 --> 00:06:47,830
So at the top you want to

196
00:06:47,830 --> 00:06:49,570
run various applications,

197
00:06:49,570 --> 00:06:51,640
maybe a text editor I haven't use

198
00:06:51,640 --> 00:06:53,590
VI as a text editor,

199
00:06:53,590 --> 00:06:56,770
if you're going to run a C compiler CC,

200
00:06:56,770 --> 00:06:58,270
you know if you run lots of

201
00:06:58,270 --> 00:06:59,680
other things we're gonna talk a lot

202
00:06:59,680 --> 00:07:02,040
today about the Shell which is the,

203
00:07:02,030 --> 00:07:02,520
um,

204
00:07:02,940 --> 00:07:04,410
command line interface,

205
00:07:04,410 --> 00:07:05,670
so we have all these different programs

206
00:07:05,670 --> 00:07:07,000
that are running.

207
00:07:07,260 --> 00:07:07,710
Um,

208
00:07:07,710 --> 00:07:09,570
and this is the sort of world

209
00:07:09,570 --> 00:07:11,820
in which a applications run is usually

210
00:07:11,820 --> 00:07:13,420
called user space.

211
00:07:14,260 --> 00:07:14,560
Um,

212
00:07:14,560 --> 00:07:16,330
and as distinct from that there's

213
00:07:16,330 --> 00:07:18,540
a single program.

214
00:07:19,440 --> 00:07:20,910
A special program,

215
00:07:20,910 --> 00:07:23,460
that's always running called the kernel and

216
00:07:23,460 --> 00:07:25,440
the kernel is sort of the guardian

217
00:07:25,440 --> 00:07:27,270
of the resources of the computer,

218
00:07:27,270 --> 00:07:30,270
it's what first boots up you turn on the computer,

219
00:07:30,270 --> 00:07:30,420
um,

220
00:07:30,420 --> 00:07:32,730
there's just one of it maintains data,

221
00:07:32,730 --> 00:07:33,560
um.

222
00:07:33,640 --> 00:07:36,280
To help manage each of these processes

223
00:07:36,280 --> 00:07:37,690
and the kernel also means lots of

224
00:07:37,690 --> 00:07:41,660
data structures to help interface and,

225
00:07:42,120 --> 00:07:44,520
um, all the different kinds of hardware.

226
00:07:45,020 --> 00:07:45,920
Um,

227
00:07:45,920 --> 00:07:49,550
these user programs need to use,

228
00:07:49,550 --> 00:07:50,990
the kernel also has built in

229
00:07:50,990 --> 00:07:53,240
a bunch of services.

230
00:07:53,550 --> 00:07:54,090
Um so,

231
00:07:54,090 --> 00:07:57,480
for example a there's typically a file system.

232
00:07:57,980 --> 00:08:00,890
Implementation inside the kernel that implements things

233
00:08:00,890 --> 00:08:03,980
like file names and file contents and

234
00:08:03,980 --> 00:08:07,190
directories and understands how to store the

235
00:08:07,190 --> 00:08:07,910
files in the disk,

236
00:08:07,910 --> 00:08:09,410
so your programs are going to talk

237
00:08:09,410 --> 00:08:11,420
to the files inside the kernel and

238
00:08:11,420 --> 00:08:13,440
file system implementations is going to

239
00:08:13,540 --> 00:08:14,760
talk to the disk.

240
00:08:15,410 --> 00:08:16,660
In this course.

241
00:08:17,460 --> 00:08:17,820
Um,

242
00:08:17,820 --> 00:08:19,800
where we mostly focus on is all

243
00:08:19,800 --> 00:08:21,330
the things that has to happen inside

244
00:08:21,330 --> 00:08:23,880
the kernel and on the interfaces

245
00:08:23,880 --> 00:08:26,060
between user programs and the kernel.

246
00:08:27,490 --> 00:08:30,370
As well as the structure of the software,

247
00:08:30,370 --> 00:08:32,110
um inside the kernel.

248
00:08:32,110 --> 00:08:33,340
So um,

249
00:08:33,430 --> 00:08:36,040
we care a lot about these services

250
00:08:36,040 --> 00:08:38,560
inside the kernel.

251
00:08:38,610 --> 00:08:40,380
One of them is a file system I mentioned,

252
00:08:40,380 --> 00:08:42,000
there's also a

253
00:08:42,570 --> 00:08:44,400
management of processes,

254
00:08:44,400 --> 00:08:46,620
each of these running programs is called

255
00:08:46,620 --> 00:08:48,300
the process and it has things like

256
00:08:48,300 --> 00:08:49,230
its own memory,

257
00:08:49,230 --> 00:08:54,420
for example as well as a share of the CPU time. So,

258
00:08:54,760 --> 00:08:58,140
a kernel manages processes

259
00:08:58,540 --> 00:09:00,250
as a kernel service.

260
00:09:01,300 --> 00:09:01,600
Uh,

261
00:09:01,600 --> 00:09:02,080
um,

262
00:09:02,080 --> 00:09:05,950
kernel manages the allocation of the memory,

263
00:09:05,950 --> 00:09:07,390
the different processes need different

264
00:09:07,390 --> 00:09:08,080
amounts of memory.

265
00:09:08,080 --> 00:09:09,000
The kernel

266
00:09:10,970 --> 00:09:13,520
multiplexes and divides up the memory

267
00:09:13,520 --> 00:09:14,940
allocates the memory,

268
00:09:15,840 --> 00:09:18,200
um, among all the different processes.

269
00:09:22,240 --> 00:09:24,160
Um,

270
00:09:24,400 --> 00:09:26,080
the kernel as I mentioned a influence

271
00:09:26,080 --> 00:09:27,580
the file system, file system really comes

272
00:09:27,580 --> 00:09:30,190
into a three logical or a bunch

273
00:09:30,190 --> 00:09:31,030
of logical parts,

274
00:09:31,030 --> 00:09:32,410
but for now we can think of

275
00:09:32,410 --> 00:09:34,810
it in terms of managing file content,

276
00:09:34,810 --> 00:09:36,280
that's inside files,

277
00:09:36,280 --> 00:09:38,360
figuring out where on disk.

278
00:09:39,080 --> 00:09:39,650
Each file's content

279
00:09:39,650 --> 00:09:41,750
ought to live, file system also somewhat

280
00:09:41,750 --> 00:09:44,150
separately manages a name space that

281
00:09:44,150 --> 00:09:45,650
each file has a name and

282
00:09:45,650 --> 00:09:47,450
there's a hierarchy of directories,

283
00:09:47,450 --> 00:09:49,940
every directory has a bunch of

284
00:09:49,940 --> 00:09:51,050
files in it all that's managed

285
00:09:51,050 --> 00:09:53,640
by the file system.

286
00:09:54,030 --> 00:09:54,480
Um,

287
00:09:54,480 --> 00:09:57,300
there's typically some sort of security arrangement,

288
00:09:57,300 --> 00:09:59,440
maybe we'll call it access control.

289
00:10:01,750 --> 00:10:03,910
Which the kernel decides that when a

290
00:10:03,910 --> 00:10:06,580
given process wants to read, use

291
00:10:06,580 --> 00:10:08,530
some resource, maybe read something from the disk,

292
00:10:08,530 --> 00:10:09,430
use some memory,

293
00:10:09,430 --> 00:10:11,200
the access control machinery inside the

294
00:10:11,200 --> 00:10:12,490
kernel is what gets to decide

295
00:10:12,490 --> 00:10:13,570
yes it's allowed is that

296
00:10:13,570 --> 00:10:14,950
not allowed, that can get pretty

297
00:10:14,950 --> 00:10:16,570
complicated if we're talking about time

298
00:10:16,570 --> 00:10:18,910
sharing systems like Athena systems where

299
00:10:18,910 --> 00:10:20,290
there's you know each of these

300
00:10:20,290 --> 00:10:21,730
processes may be run by a

301
00:10:21,730 --> 00:10:23,890
different user and have different access

302
00:10:23,890 --> 00:10:25,690
control rules apply to what it's

303
00:10:25,690 --> 00:10:27,180
allowed to get at.

304
00:10:28,830 --> 00:10:31,710
And in a real full-blown operating system

305
00:10:31,710 --> 00:10:32,640
turns out to be many,

306
00:10:32,640 --> 00:10:34,050
many other services,

307
00:10:34,050 --> 00:10:35,730
you know there's typically some way for

308
00:10:35,730 --> 00:10:37,650
different processes to talk to each other

309
00:10:37,650 --> 00:10:40,200
called inter process communication,

310
00:10:40,200 --> 00:10:42,210
there's typically a whole bunch of software

311
00:10:42,210 --> 00:10:44,100
associated with the network things like the

312
00:10:44,100 --> 00:10:48,120
TCP/IP protocols for talking the network,

313
00:10:48,120 --> 00:10:48,940
um.

314
00:10:49,900 --> 00:10:52,480
There's typically support for sound cards there

315
00:10:52,480 --> 00:10:54,400
may be drivers for hundreds of different

316
00:10:54,400 --> 00:10:56,470
disk and hundreds of different network cards,

317
00:10:56,470 --> 00:10:58,690
so in a full-blown operating system is

318
00:10:58,690 --> 00:11:00,310
a huge amount of stuff here and

319
00:11:00,310 --> 00:11:01,900
this may run to millions of lines

320
00:11:01,900 --> 00:11:04,120
of code inside the kernel.

321
00:11:05,300 --> 00:11:07,490
So that's sort of a quick overview

322
00:11:07,490 --> 00:11:09,560
of whats inside the kernel,

323
00:11:09,560 --> 00:11:12,320
we're also interested in how applications

324
00:11:12,320 --> 00:11:13,820
interact with the kernel and what

325
00:11:13,820 --> 00:11:16,320
that interface looks like.

326
00:11:19,060 --> 00:11:20,520
The um,

327
00:11:22,160 --> 00:11:24,140
a usual,

328
00:11:24,140 --> 00:11:24,800
um,

329
00:11:24,800 --> 00:11:27,860
so this is the API for the kernel.

330
00:11:30,610 --> 00:11:32,500
How applications get at the kernel,

331
00:11:32,500 --> 00:11:34,570
a typically that's done with something called

332
00:11:34,570 --> 00:11:36,520
system calls and these are things that

333
00:11:36,520 --> 00:11:39,240
look like function calls that um

334
00:11:39,480 --> 00:11:42,300
programs can make, but actually jump into

335
00:11:42,300 --> 00:11:45,720
the kernel and execute a system call

336
00:11:45,720 --> 00:11:47,430
implementation in the kernel,

337
00:11:47,430 --> 00:11:49,050
I'll talk a bunch about that

338
00:11:49,050 --> 00:11:49,980
in the latter part of this

339
00:11:49,980 --> 00:11:51,900
lecture. For now just to give

340
00:11:51,900 --> 00:11:53,100
you a flavor here,

341
00:11:53,100 --> 00:11:54,960
what a couple of different system calls

342
00:11:54,960 --> 00:11:56,760
might look like in the source code

343
00:11:56,760 --> 00:11:58,180
of an application.

344
00:12:00,310 --> 00:12:02,140
One might be that if you want

345
00:12:02,140 --> 00:12:04,180
an application wants to open a file,

346
00:12:04,180 --> 00:12:07,000
and it calls the open system call.

347
00:12:07,420 --> 00:12:09,400
And tells the open system called the

348
00:12:09,400 --> 00:12:10,720
name of the file,

349
00:12:10,720 --> 00:12:12,280
so maybe it wants to open a

350
00:12:12,280 --> 00:12:14,830
file for writing called "out" and the

351
00:12:14,830 --> 00:12:17,050
next argument here saying 1

352
00:12:17,050 --> 00:12:17,920
in this case. I want to

353
00:12:17,920 --> 00:12:19,000
write that file,

354
00:12:19,000 --> 00:12:21,820
and so this thing that looks like a function call.

355
00:12:22,670 --> 00:12:24,620
It opens the system calls actually special

356
00:12:24,620 --> 00:12:26,570
code that jumps into the kernel and

357
00:12:26,570 --> 00:12:29,180
the kernel can retrieve these arguments executes

358
00:12:29,180 --> 00:12:30,680
some kernel code that implements open,

359
00:12:30,680 --> 00:12:32,150
maybe talks to the disk,

360
00:12:32,150 --> 00:12:33,860
and then returns a value and that's

361
00:12:33,860 --> 00:12:35,620
this file descriptor,

362
00:12:36,240 --> 00:12:38,610
as fd stands for file descriptor.

363
00:12:38,610 --> 00:12:40,200
Um, which is the program can

364
00:12:40,200 --> 00:12:42,150
then use as a handle to

365
00:12:42,150 --> 00:12:44,540
refer to this open file.

366
00:12:44,760 --> 00:12:45,930
Um,

367
00:12:45,930 --> 00:12:47,160
if you want to write to a file,

368
00:12:47,160 --> 00:12:49,340
the system call [did].

369
00:12:49,400 --> 00:12:51,200
To do that is called write,

370
00:12:51,200 --> 00:12:52,190
you have to pass it one

371
00:12:52,190 --> 00:12:53,720
of these file descriptors the same as

372
00:12:53,720 --> 00:12:55,420
was returned by open.

373
00:12:55,700 --> 00:12:56,300
Um,

374
00:12:56,300 --> 00:12:58,460
these are arguments that are passed in

375
00:12:58,460 --> 00:12:59,600
the system call.

376
00:12:59,770 --> 00:13:01,960
From the program into the kernel,

377
00:13:01,960 --> 00:13:03,740
and you give it a pointer,

378
00:13:03,960 --> 00:13:06,300
to a buffer of characters so an

379
00:13:06,300 --> 00:13:07,200
easy way to do that in the

380
00:13:07,200 --> 00:13:08,310
C programming language,

381
00:13:08,310 --> 00:13:10,350
which these examples are written by as

382
00:13:10,350 --> 00:13:12,080
double quotes then,

383
00:13:12,340 --> 00:13:13,480
um, the string,

384
00:13:13,480 --> 00:13:15,670
the bytes of the string '\n'

385
00:13:15,670 --> 00:13:17,830
is a new line and the third

386
00:13:17,830 --> 00:13:19,940
argument is the count of characters.

387
00:13:20,160 --> 00:13:20,940
Um,

388
00:13:20,940 --> 00:13:23,490
if you want to write so this really gets point,

389
00:13:23,490 --> 00:13:25,620
pass this address in memory.

390
00:13:25,860 --> 00:13:26,850
So you're telling the kernel, look,

391
00:13:26,850 --> 00:13:28,650
please write 6 bytes from this

392
00:13:28,650 --> 00:13:30,750
address to the file that this

393
00:13:30,750 --> 00:13:32,840
file descriptor refers to.

394
00:13:33,750 --> 00:13:36,270
A much more exciting system call

395
00:13:36,270 --> 00:13:38,220
the encounter is the fork system,

396
00:13:38,220 --> 00:13:40,590
call fork is the system call

397
00:13:40,590 --> 00:13:42,560
that creates a new process.

398
00:13:42,620 --> 00:13:43,480
Um,

399
00:13:44,160 --> 00:13:46,620
and returns actually creates a process that's

400
00:13:46,620 --> 00:13:49,860
identical to the caller and fork returns

401
00:13:49,860 --> 00:13:53,040
the identifier the process identifier pid,

402
00:13:53,040 --> 00:13:56,370
um, new process is more

403
00:13:56,370 --> 00:13:57,920
complicated than [that].

404
00:13:58,040 --> 00:13:59,440
We'll hear more about this.

405
00:14:00,740 --> 00:14:01,250
So again,

406
00:14:01,250 --> 00:14:04,400
these are all look like function calls,

407
00:14:04,400 --> 00:14:05,870
but the system calls are special because

408
00:14:05,870 --> 00:14:07,240
they jump into the kernel.

409
00:14:08,200 --> 00:14:08,350
Um,

410
00:14:08,350 --> 00:14:09,790
that's taste,

411
00:14:09,790 --> 00:14:10,960
we'll see more later.

412
00:14:15,800 --> 00:14:17,600
That is a sort of quick overview,

413
00:14:17,600 --> 00:14:20,380
I'm a wanna.

414
00:14:20,530 --> 00:14:23,350
Just mention why I find a operating

415
00:14:23,350 --> 00:14:25,220
the study of operating systems,

416
00:14:25,300 --> 00:14:30,460
to be both a challenging and interesting.

417
00:14:32,710 --> 00:14:34,620
Why you know why it's maybe worth.

418
00:14:35,360 --> 00:14:36,320
Um,

419
00:14:36,320 --> 00:14:39,240
intellectually worth taking a course in this area.

420
00:14:39,370 --> 00:14:39,550
So,

421
00:14:39,550 --> 00:14:40,900
one reason why it's hard is that

422
00:14:40,900 --> 00:14:44,980
the environment is unforgiving, programming environment

423
00:14:44,980 --> 00:14:48,180
inside the kernels unforgiving, because you're,

424
00:14:50,570 --> 00:14:52,550
your when you're programming when you're modifying

425
00:14:52,550 --> 00:14:53,870
the kernel or extending the kernel of

426
00:14:53,870 --> 00:14:55,640
writing a new operating system kernel,

427
00:14:55,640 --> 00:14:58,220
you're providing the infrastructure that everybody

428
00:14:58,220 --> 00:15:00,080
else assumes is already present to

429
00:15:00,080 --> 00:15:01,460
run their programs.

430
00:15:01,640 --> 00:15:03,200
And then everybody else gets an operating

431
00:15:03,200 --> 00:15:05,270
system under their program when they write

432
00:15:05,270 --> 00:15:06,500
ordinary application programs,

433
00:15:06,500 --> 00:15:08,990
but when we build operating systems

434
00:15:08,990 --> 00:15:10,430
what we get is the hardware

435
00:15:10,430 --> 00:15:13,820
underneath our operating system which turns

436
00:15:13,820 --> 00:15:15,170
out to be more difficult to

437
00:15:15,170 --> 00:15:16,310
deal with. In this course,

438
00:15:16,310 --> 00:15:17,900
we, um,

439
00:15:18,340 --> 00:15:20,890
we get to use a hardware simulator called QEMU,

440
00:15:20,890 --> 00:15:21,070
um,

441
00:15:21,070 --> 00:15:21,820
you,

442
00:15:21,820 --> 00:15:22,500
um.

443
00:15:22,790 --> 00:15:25,970
That simulates a CPU and a computer

444
00:15:25,970 --> 00:15:27,200
and that makes a little bit better,

445
00:15:27,200 --> 00:15:29,690
but it's still a kind of a difficult,

446
00:15:29,690 --> 00:15:31,260
um environment programming.

447
00:15:32,360 --> 00:15:33,470
Another reason why it's hard and

448
00:15:33,470 --> 00:15:35,720
interesting is because if you're designing

449
00:15:35,720 --> 00:15:36,620
and operating system,

450
00:15:36,620 --> 00:15:39,860
you have to satisfy a bunch of tensions.

451
00:15:39,980 --> 00:15:41,900
Um that require real design thought,

452
00:15:41,900 --> 00:15:44,030
so one is that you'd like your

453
00:15:44,030 --> 00:15:46,480
operating system to be both efficient.

454
00:15:46,720 --> 00:15:47,590
Um,

455
00:15:47,590 --> 00:15:49,660
which often means that it operates at

456
00:15:49,660 --> 00:15:51,640
a low level close to the hardware,

457
00:15:51,640 --> 00:15:53,290
but for ease of use,

458
00:15:53,290 --> 00:15:55,030
and because real live people have to

459
00:15:55,030 --> 00:15:57,820
write programs that use your operating system,

460
00:15:57,820 --> 00:16:00,220
we'd like it also to be a

461
00:16:00,220 --> 00:16:02,360
right abstract high-level.

462
00:16:02,660 --> 00:16:04,460
A portable interfaces and it's a

463
00:16:04,460 --> 00:16:06,590
neat trick to provide a abstract

464
00:16:06,590 --> 00:16:08,240
interfaces that are simple.

465
00:16:08,320 --> 00:16:11,320
A portable but they are also efficient.

466
00:16:11,910 --> 00:16:12,600
Um,

467
00:16:12,600 --> 00:16:14,820
another tension is that we'd like to

468
00:16:14,820 --> 00:16:18,240
provide a very powerful operating system services

469
00:16:18,240 --> 00:16:20,190
so that the operating system can shoulder

470
00:16:20,190 --> 00:16:21,580
a lot of the burden.

471
00:16:21,680 --> 00:16:26,000
I'm a running programs like a powerful

472
00:16:26,070 --> 00:16:27,920
operating system services.

473
00:16:28,630 --> 00:16:29,440
Um,

474
00:16:29,440 --> 00:16:30,460
but,

475
00:16:30,860 --> 00:16:33,120
we also want to have simple interfaces.

476
00:16:34,770 --> 00:16:36,960
Um that we don't want a

477
00:16:36,960 --> 00:16:39,480
tremendously complex hard to understand interfaces

478
00:16:39,480 --> 00:16:41,790
for programmers to use because I'm

479
00:16:41,790 --> 00:16:42,600
not going to understand them,

480
00:16:42,600 --> 00:16:45,080
and they may find it hard to use.

481
00:16:45,790 --> 00:16:46,840
Um,

482
00:16:46,840 --> 00:16:48,400
so this is really simple API,

483
00:16:48,400 --> 00:16:50,440
and so this is possible to do

484
00:16:50,440 --> 00:16:53,440
to provide a simple interfaces that have

485
00:16:53,440 --> 00:16:57,280
powerful a machinery inside them will always

486
00:16:57,280 --> 00:16:58,500
be searching for.

487
00:16:58,700 --> 00:17:02,330
Sort of simple interfaces provide

488
00:17:02,330 --> 00:17:04,760
a powerful services.

489
00:17:04,760 --> 00:17:07,200
Hey, Robbery, we've got a question in the chat.

490
00:17:07,280 --> 00:17:07,640
Um,

491
00:17:07,640 --> 00:17:09,830
what is unique/different about saying

492
00:17:09,830 --> 00:17:12,200
system calls jump into the kernel i.e

493
00:17:12,200 --> 00:17:13,970
as opposed to a standard function call

494
00:17:13,970 --> 00:17:15,540
that jumps to another function.

495
00:17:15,660 --> 00:17:16,340
Um.

496
00:17:18,100 --> 00:17:18,550
Well,

497
00:17:18,550 --> 00:17:20,410
the kernel has the kernels is,

498
00:17:20,410 --> 00:17:21,500
um.

499
00:17:21,950 --> 00:17:23,840
A piece of code that's always resident

500
00:17:23,840 --> 00:17:26,540
that has special privileges that were that

501
00:17:26,540 --> 00:17:29,060
because it booted the machine booted the

502
00:17:29,060 --> 00:17:32,600
kernel a kernel has special privileges,

503
00:17:32,600 --> 00:17:34,700
it can get directly at all kinds

504
00:17:34,700 --> 00:17:37,100
of hardware like the disk device that

505
00:17:37,100 --> 00:17:38,270
ordinary user programs,

506
00:17:38,270 --> 00:17:39,800
can't get at, so if you make

507
00:17:39,800 --> 00:17:42,100
a an ordinary function call.

508
00:17:42,160 --> 00:17:43,060
Um.

509
00:17:43,920 --> 00:17:46,440
The function your calling doesn't get it

510
00:17:46,440 --> 00:17:48,600
doesn't get any special privileges with respect

511
00:17:48,600 --> 00:17:50,070
to the hardware whereas if you make

512
00:17:50,070 --> 00:17:53,040
a system call into the kernel will

513
00:17:53,040 --> 00:17:54,000
talk about how this works,

514
00:17:54,000 --> 00:17:57,000
but that ends up as when it

515
00:17:57,000 --> 00:17:58,590
jumps into when the system call jumps

516
00:17:58,590 --> 00:18:01,500
into the kernel a system call implementation

517
00:18:01,500 --> 00:18:02,670
in the kernel then gets all these

518
00:18:02,670 --> 00:18:06,360
special privileges so that it can modify

519
00:18:06,360 --> 00:18:09,440
all kinds of sensitive and protected.

520
00:18:09,730 --> 00:18:12,340
A hardware resources like for example getting

521
00:18:12,340 --> 00:18:14,320
directly at the hard disk.

522
00:18:15,730 --> 00:18:16,090
Um,

523
00:18:16,090 --> 00:18:19,020
we'll see a lot more detail for all this shortly.

524
00:18:20,330 --> 00:18:20,660
Okay,

525
00:18:20,660 --> 00:18:22,310
so a final tension that we

526
00:18:22,310 --> 00:18:24,290
want that all operating systems need

527
00:18:24,290 --> 00:18:25,910
to satisfy your gonna give programs

528
00:18:25,910 --> 00:18:27,560
as much flexibility as you can

529
00:18:27,560 --> 00:18:28,970
you don't want to constrain them,

530
00:18:28,970 --> 00:18:30,680
so you want to have very flexible.

531
00:18:30,740 --> 00:18:31,760
Um.

532
00:18:33,060 --> 00:18:33,750
Interfaces,

533
00:18:33,750 --> 00:18:35,400
but you do need to constrain program

534
00:18:35,400 --> 00:18:37,200
somewhat because you absolutely have to have

535
00:18:37,200 --> 00:18:38,740
some notion of security.

536
00:18:38,880 --> 00:18:40,520
[can].

537
00:18:41,770 --> 00:18:44,770
We love for programs programs complete freedom

538
00:18:44,770 --> 00:18:45,910
but it can't be complete can't be

539
00:18:45,910 --> 00:18:48,490
really complete because we don't want programs

540
00:18:48,490 --> 00:18:49,960
to get directly at the hardware or

541
00:18:49,960 --> 00:18:53,170
to interfere with other programs or a

542
00:18:53,170 --> 00:18:54,310
sort of be able to interfere with

543
00:18:54,310 --> 00:18:57,140
the operation of the operating system itself.

544
00:18:57,360 --> 00:18:58,140
Um,

545
00:18:58,140 --> 00:18:58,410
so,

546
00:18:58,410 --> 00:19:00,820
these are all you know.

547
00:19:01,490 --> 00:19:02,810
It's possible to do a good job

548
00:19:02,810 --> 00:19:03,860
and we'll talk a lot about it

549
00:19:03,860 --> 00:19:05,120
but it's always a bit of a

550
00:19:05,120 --> 00:19:06,620
puzzle to provide sort of both of

551
00:19:06,620 --> 00:19:10,300
these properties in both of these columns.

552
00:19:11,630 --> 00:19:13,730
Another thing that makes OS design hard

553
00:19:13,730 --> 00:19:16,040
and interesting is that operating systems provide

554
00:19:16,040 --> 00:19:17,030
a lot of features and a lot

555
00:19:17,030 --> 00:19:18,710
of services but they actually tend to

556
00:19:18,710 --> 00:19:21,770
interact and sometimes in odd ways that

557
00:19:21,770 --> 00:19:23,540
require a lot of thought so even

558
00:19:23,540 --> 00:19:25,960
the simple examples I gave um.

559
00:19:26,640 --> 00:19:27,780
With open and fork,

560
00:19:27,780 --> 00:19:30,180
those two interact actually if a program,

561
00:19:30,180 --> 00:19:31,120
um.

562
00:19:31,310 --> 00:19:32,930
Allocates a file descriptor with the

563
00:19:32,930 --> 00:19:34,700
open system call,

564
00:19:34,700 --> 00:19:36,680
and then that same program,

565
00:19:36,780 --> 00:19:38,760
a fork.

566
00:19:39,610 --> 00:19:40,090
Um,

567
00:19:40,090 --> 00:19:41,470
and the semantics of fork just

568
00:19:41,470 --> 00:19:42,760
turned out to be that you

569
00:19:42,760 --> 00:19:44,050
create a new process that's a

570
00:19:44,050 --> 00:19:45,730
copy of the current process,

571
00:19:45,730 --> 00:19:46,990
this file descriptor,

572
00:19:46,990 --> 00:19:48,820
you opened.

573
00:19:49,640 --> 00:19:51,290
If that's truly to be a copy,

574
00:19:51,290 --> 00:19:53,660
this file descriptor still has to be

575
00:19:53,660 --> 00:19:56,920
present and usable in the child and,

576
00:19:57,320 --> 00:19:58,370
and so that has to be thought

577
00:19:58,370 --> 00:19:59,660
through that is the files,

578
00:19:59,660 --> 00:20:01,760
the opened file descriptors interact with fork

579
00:20:01,760 --> 00:20:04,460
in this interesting way and somebody has

580
00:20:04,460 --> 00:20:06,380
to figure out a should the child

581
00:20:06,380 --> 00:20:07,900
be able to get at.

582
00:20:07,960 --> 00:20:10,270
The file descriptors created before fork

583
00:20:10,270 --> 00:20:11,560
is called and the answer has

584
00:20:11,560 --> 00:20:12,580
to be yes,

585
00:20:12,580 --> 00:20:14,500
the operating systems we're going to look at.

586
00:20:14,620 --> 00:20:15,500
Um.

587
00:20:17,070 --> 00:20:18,390
All right, so other things

588
00:20:18,390 --> 00:20:19,320
that are turned out to

589
00:20:19,320 --> 00:20:21,210
be interesting I already mentioned

590
00:20:21,210 --> 00:20:22,860
that operating systems have to

591
00:20:22,860 --> 00:20:24,090
cater to a wide variety

592
00:20:24,090 --> 00:20:26,280
of uses the same OS

593
00:20:26,280 --> 00:20:28,620
used both for database servers

594
00:20:28,620 --> 00:20:29,820
and smartphones,

595
00:20:29,820 --> 00:20:33,280
for example and operating systems.

596
00:20:33,410 --> 00:20:36,350
As time goes on the hardware

597
00:20:36,350 --> 00:20:37,940
that you run, hardware

598
00:20:37,940 --> 00:20:38,360
you get,

599
00:20:38,360 --> 00:20:40,400
but typical computers changes,

600
00:20:40,400 --> 00:20:43,190
maybe get superfast ssd storage instead of

601
00:20:43,190 --> 00:20:44,270
mechanical hard drive.

602
00:20:44,270 --> 00:20:45,280
For example,

603
00:20:45,360 --> 00:20:47,610
about fifteen years ago multi

604
00:20:47,610 --> 00:20:50,370
core computers went from being rare

605
00:20:50,370 --> 00:20:54,750
curiosities to being pervasive and and

606
00:20:54,750 --> 00:20:56,700
recently we've seen order of magnitude

607
00:20:56,700 --> 00:20:59,190
speedups and how fast networks operate

608
00:20:59,190 --> 00:21:01,340
and so all these require rethinks.

609
00:21:01,440 --> 00:21:02,640
Um,

610
00:21:02,640 --> 00:21:02,970
um,

611
00:21:02,970 --> 00:21:05,560
periodically of how operating systems are designed.

612
00:21:06,510 --> 00:21:10,500
Now so so those are those are

613
00:21:10,500 --> 00:21:12,090
sort of intellectually why you might take

614
00:21:12,090 --> 00:21:14,010
the course there's also some more practical

615
00:21:14,010 --> 00:21:16,320
reasons why you might be glad to

616
00:21:16,320 --> 00:21:17,580
have taken this course,

617
00:21:17,580 --> 00:21:19,380
one is if you're interested in what

618
00:21:19,380 --> 00:21:20,730
happens inside computers,

619
00:21:20,730 --> 00:21:22,410
what goes on and saw under the

620
00:21:22,410 --> 00:21:24,390
hood a sort of in secret,

621
00:21:24,390 --> 00:21:25,710
when you turn on your computer,

622
00:21:25,710 --> 00:21:25,920
um,

623
00:21:25,920 --> 00:21:27,510
this is a good course to take,

624
00:21:27,510 --> 00:21:29,430
similarly if you like infrastructure that

625
00:21:29,430 --> 00:21:31,770
is if if you enjoy building

626
00:21:31,770 --> 00:21:33,900
a sort of services that other

627
00:21:33,900 --> 00:21:36,160
programs can then use them.

628
00:21:36,510 --> 00:21:37,860
This is of course essentially all

629
00:21:37,860 --> 00:21:40,020
about infrastructure because that's that's what

630
00:21:40,020 --> 00:21:41,340
operating systems are.

631
00:21:42,350 --> 00:21:43,250
If you ever need to

632
00:21:43,250 --> 00:21:44,000
spend a lot of time

633
00:21:44,000 --> 00:21:46,160
tracking down bugs in application

634
00:21:46,160 --> 00:21:47,870
code or tracking down security

635
00:21:47,870 --> 00:21:51,440
problems often that involves understanding

636
00:21:51,440 --> 00:21:52,490
what was going on inside

637
00:21:52,490 --> 00:21:54,020
the operating system because it's

638
00:21:54,020 --> 00:21:56,180
ultimately the operating system that

639
00:21:56,180 --> 00:21:57,710
enforces a lot of security

640
00:21:57,710 --> 00:22:00,020
and when things go wrong,

641
00:22:00,020 --> 00:22:01,490
it's the operating system has to pick

642
00:22:01,490 --> 00:22:03,830
up the pieces so that's often involved

643
00:22:03,830 --> 00:22:08,210
in tracking down bugs, and finally. Two

644
00:22:08,210 --> 00:22:09,440
more questions from the chat,

645
00:22:09,440 --> 00:22:11,210
so the first is how important

646
00:22:11,210 --> 00:22:12,740
is it for application developers to

647
00:22:12,740 --> 00:22:15,050
truly deeply understand the operating systems

648
00:22:15,050 --> 00:22:17,180
of developing their applications for do

649
00:22:17,180 --> 00:22:19,420
they necessarily need to be experts.

650
00:22:19,810 --> 00:22:21,370
You don't have to be an expert,

651
00:22:21,370 --> 00:22:23,530
but if you spend a lot of

652
00:22:23,530 --> 00:22:26,650
time developing and maintaining and debugging applications,

653
00:22:26,650 --> 00:22:29,080
you'll eventually end up knowing a lot

654
00:22:29,080 --> 00:22:30,160
about the operating system,

655
00:22:30,160 --> 00:22:31,420
whether you,

656
00:22:31,520 --> 00:22:33,240
whether you meant to or not just,

657
00:22:34,140 --> 00:22:36,390
it just comes up and you're often

658
00:22:36,390 --> 00:22:37,840
forced to understand.

659
00:22:38,100 --> 00:22:38,900
Um.

660
00:22:39,640 --> 00:22:41,290
And the second question is do

661
00:22:41,290 --> 00:22:44,230
high-level programming languages like python use

662
00:22:44,230 --> 00:22:46,030
system calls directly are there built

663
00:22:46,030 --> 00:22:48,340
in slash wrappers for convenience.

664
00:22:48,710 --> 00:22:50,750
A lot of high-level languages are sort

665
00:22:50,750 --> 00:22:53,540
of at one of move from system calls

666
00:22:53,540 --> 00:22:54,500
that's absolutely true,

667
00:22:54,500 --> 00:22:56,360
so um.

668
00:22:56,600 --> 00:22:58,640
Partially because a lot of

669
00:22:58,640 --> 00:23:01,760
languages want to provide portable a

670
00:23:01,760 --> 00:23:03,410
portable environment that works on many

671
00:23:03,410 --> 00:23:04,760
different operating systems so they can't

672
00:23:04,760 --> 00:23:07,280
necessarily commit to the specific system

673
00:23:07,280 --> 00:23:09,580
calls of any one operating system.

674
00:23:09,980 --> 00:23:11,360
Um,

675
00:23:11,360 --> 00:23:12,410
so I'm the answer,

676
00:23:12,410 --> 00:23:13,490
the question I think is if you

677
00:23:13,490 --> 00:23:16,460
use python, you're somewhat insulated.

678
00:23:16,570 --> 00:23:18,790
From not the system call interface,

679
00:23:18,790 --> 00:23:20,760
you know internally of course python makes,

680
00:23:20,900 --> 00:23:23,060
has to make system calls get its work done,

681
00:23:23,060 --> 00:23:23,360
um,

682
00:23:23,360 --> 00:23:24,340
and,

683
00:23:24,520 --> 00:23:26,380
certainly in python and many other languages,

684
00:23:26,380 --> 00:23:29,840
there is usually a way to get directly at

685
00:23:29,990 --> 00:23:32,330
the system calls whatever your operating system,

686
00:23:32,330 --> 00:23:34,060
you're running on.

687
00:23:35,480 --> 00:23:37,280
And folks for questions, you can just

688
00:23:37,280 --> 00:23:38,540
feel free to jump in yourself and

689
00:23:38,540 --> 00:23:39,650
ask questions you don't need to go

690
00:23:39,650 --> 00:23:40,880
through the chat.

691
00:23:43,410 --> 00:23:43,980
Okay,

692
00:23:43,980 --> 00:23:45,260
Um,

693
00:23:46,020 --> 00:23:46,740
all right,

694
00:23:46,740 --> 00:23:48,540
sorry.

695
00:23:49,510 --> 00:23:51,700
I'm going to spend a couple of

696
00:23:51,700 --> 00:23:56,230
minutes now talking about class structure

697
00:23:56,230 --> 00:24:00,980
of 6.S081,

698
00:24:01,140 --> 00:24:05,430
before switching back to actual technical content.

699
00:24:05,430 --> 00:24:07,740
So there is a website for the

700
00:24:07,740 --> 00:24:09,210
course which I don't want to write

701
00:24:09,210 --> 00:24:10,890
out just now but it's you

702
00:24:10,890 --> 00:24:11,940
can find it by looking for

703
00:24:11,940 --> 00:24:13,900
6.S081 on Google.

704
00:24:14,280 --> 00:24:16,350
And the website,

705
00:24:16,350 --> 00:24:18,520
um, has

706
00:24:19,890 --> 00:24:23,740
a schedule,

707
00:24:23,980 --> 00:24:26,320
it has the assignments on the schedule

708
00:24:26,320 --> 00:24:28,560
that has the lab assignments.

709
00:24:28,740 --> 00:24:29,070
Um,

710
00:24:29,070 --> 00:24:30,300
and it has the sort of

711
00:24:30,300 --> 00:24:32,370
information about course structure like the

712
00:24:32,370 --> 00:24:33,900
grading policy on it.

713
00:24:34,240 --> 00:24:37,300
Um the other big resource you're gonna

714
00:24:37,300 --> 00:24:39,260
wanna keep track of piazza.

715
00:24:39,960 --> 00:24:40,710
Um I guess,

716
00:24:40,710 --> 00:24:42,090
everybody was here got here by way

717
00:24:42,090 --> 00:24:43,020
piazza,

718
00:24:43,020 --> 00:24:43,260
um,

719
00:24:43,260 --> 00:24:45,960
but as well as um,

720
00:24:45,960 --> 00:24:48,150
so we used periodically for two main things,

721
00:24:48,150 --> 00:24:49,680
one is as a way of people

722
00:24:49,680 --> 00:24:51,270
being able to ask questions about the

723
00:24:51,270 --> 00:24:53,200
lab assignments and,

724
00:24:53,420 --> 00:24:56,180
a course staff will try to answer these questions,

725
00:24:56,180 --> 00:24:57,980
but you should feel absolutely free to

726
00:24:57,980 --> 00:25:00,740
answer each other's questions as well. And

727
00:25:00,740 --> 00:25:01,910
the other big thing that happens on

728
00:25:01,910 --> 00:25:04,400
piazza if there's announcements there's any announcements

729
00:25:04,400 --> 00:25:05,380
about the course.

730
00:25:05,500 --> 00:25:06,010
Um,

731
00:25:06,010 --> 00:25:07,720
we'll put the announcement on piazza so

732
00:25:07,720 --> 00:25:09,100
you should keep an eye on piazza

733
00:25:09,100 --> 00:25:10,840
for announcements even if, um,

734
00:25:11,220 --> 00:25:12,760
you're not using it for lab help.

735
00:25:13,580 --> 00:25:14,220
Yeah.

736
00:25:15,460 --> 00:25:16,340
Um,

737
00:25:16,700 --> 00:25:17,000
The um,

738
00:25:17,000 --> 00:25:18,560
one of the big parts of course

739
00:25:18,560 --> 00:25:20,150
is that these lectures,

740
00:25:20,150 --> 00:25:21,040
um,

741
00:25:22,020 --> 00:25:23,080
um,

742
00:25:24,150 --> 00:25:27,420
lectures will cover basic ideas

743
00:25:27,420 --> 00:25:28,800
and operating systems.

744
00:25:28,860 --> 00:25:30,270
Um,

745
00:25:30,270 --> 00:25:31,200
some of the lectures will

746
00:25:31,200 --> 00:25:33,480
be devoted to detailed a

747
00:25:33,480 --> 00:25:35,580
study of the code in

748
00:25:35,580 --> 00:25:36,660
xv6 which is

749
00:25:36,660 --> 00:25:39,420
our small teaching operating system

750
00:25:39,420 --> 00:25:40,800
and so talk about how

751
00:25:40,800 --> 00:25:41,910
it works we'll look at

752
00:25:41,910 --> 00:25:43,140
the code and show the

753
00:25:43,140 --> 00:25:45,810
code executing during lectures,

754
00:25:45,810 --> 00:25:47,370
and in addition before many of

755
00:25:47,370 --> 00:25:49,200
the lectures will be assignments reading

756
00:25:49,200 --> 00:25:51,810
assignments from a book that sort

757
00:25:51,810 --> 00:25:54,600
of describes how xv6 operates and

758
00:25:54,600 --> 00:25:56,220
why it's designed that way.

759
00:25:56,670 --> 00:25:57,990
So you do the readings before the

760
00:25:57,990 --> 00:26:01,170
class so they don't understand the discussion

761
00:26:01,170 --> 00:26:02,400
in the class,

762
00:26:02,400 --> 00:26:04,080
some of the lectures are devoted to

763
00:26:04,080 --> 00:26:06,540
background to help you do the labs.

764
00:26:06,660 --> 00:26:07,200
Um,

765
00:26:07,200 --> 00:26:09,180
no explanations about C works of how

766
00:26:09,180 --> 00:26:11,940
the RISC-V, which is the microprocessor

767
00:26:11,940 --> 00:26:13,080
that we'll be using.

768
00:26:13,200 --> 00:26:16,620
Um that you'll find helpful in understanding

769
00:26:16,620 --> 00:26:18,210
how to do the labs and towards

770
00:26:18,210 --> 00:26:19,420
the end of the course,

771
00:26:19,890 --> 00:26:22,710
we'll spend some lectures discussing some

772
00:26:22,710 --> 00:26:25,080
operating system papers,

773
00:26:25,080 --> 00:26:27,420
research papers and some classic papers in

774
00:26:27,420 --> 00:26:30,300
the field which you will ask that

775
00:26:30,300 --> 00:26:31,470
you read before the lecture and then

776
00:26:31,470 --> 00:26:33,630
we'll sort of talk about the papers

777
00:26:33,630 --> 00:26:36,090
during the lecture. For all the lectures

778
00:26:36,090 --> 00:26:37,290
are almost all the lectures,

779
00:26:37,290 --> 00:26:39,150
we ask that you submit a question

780
00:26:39,150 --> 00:26:40,320
about the reading,

781
00:26:40,320 --> 00:26:44,190
um for the lecture before the actual

782
00:26:44,190 --> 00:26:45,900
time of the lecture which.

783
00:26:45,950 --> 00:26:47,270
Many or all of you did for

784
00:26:47,270 --> 00:26:49,220
this lecture for which thank you,

785
00:26:49,220 --> 00:26:49,850
um,

786
00:26:49,850 --> 00:26:52,580
and we will read those questions to help us.

787
00:26:52,970 --> 00:26:54,800
Guide us about what to talk about

788
00:26:54,800 --> 00:26:57,020
and we'll try to answer as many

789
00:26:57,020 --> 00:26:58,040
of the questions as we can,

790
00:26:58,040 --> 00:26:59,840
although there's rarely time,

791
00:26:59,840 --> 00:27:02,460
unfortunately for us to answer all of them.

792
00:27:02,800 --> 00:27:05,980
I'm the next big part of the course of the labs.

793
00:27:06,400 --> 00:27:08,350
There's a programming lab do,

794
00:27:08,350 --> 00:27:09,320
um,

795
00:27:09,820 --> 00:27:12,490
almost every week and the point of

796
00:27:12,490 --> 00:27:13,510
the labs is to help you get

797
00:27:13,510 --> 00:27:15,940
hands on experience with,

798
00:27:16,110 --> 00:27:19,840
implementing and using operating systems.

799
00:27:20,690 --> 00:27:24,170
A lab that's due next week is

800
00:27:24,170 --> 00:27:27,440
actually about using about writing applications that

801
00:27:27,440 --> 00:27:29,120
make the call the system calls will

802
00:27:29,120 --> 00:27:30,240
be talking about.

803
00:27:31,520 --> 00:27:33,080
Whereas most of those labs after

804
00:27:33,080 --> 00:27:34,070
that are involved,

805
00:27:34,070 --> 00:27:37,370
you either implementing basic operating system

806
00:27:37,370 --> 00:27:38,860
features or adding

807
00:27:39,020 --> 00:27:42,360
a kernel extensions to the xv6

808
00:27:42,770 --> 00:27:44,780
operating system,

809
00:27:44,780 --> 00:27:46,520
the very last lab and one in

810
00:27:46,520 --> 00:27:48,500
which you actually add a network stack

811
00:27:48,500 --> 00:27:49,820
and a network driver so you'll be

812
00:27:49,820 --> 00:27:51,500
able to connect in over the network

813
00:27:51,500 --> 00:27:53,540
to the operating system that you run.

814
00:27:55,560 --> 00:27:56,310
You should,

815
00:27:56,310 --> 00:27:57,990
if you have problems with the lab's

816
00:27:57,990 --> 00:28:00,740
they'll be office hours that,

817
00:28:00,830 --> 00:28:03,260
TA will hold. In addition

818
00:28:03,260 --> 00:28:06,230
you can post questions to piazza

819
00:28:06,230 --> 00:28:07,610
and very often you'll be able

820
00:28:07,610 --> 00:28:09,890
to get useful answers from piazza

821
00:28:09,890 --> 00:28:11,980
more quickly than from office hours.

822
00:28:13,060 --> 00:28:16,000
We welcome you discussing the labs

823
00:28:16,000 --> 00:28:17,230
talking about the labs talking about

824
00:28:17,230 --> 00:28:20,410
how to design the lab solutions

825
00:28:20,410 --> 00:28:21,610
but we ask you please do

826
00:28:21,610 --> 00:28:23,600
not look at other people's solutions.

827
00:28:23,680 --> 00:28:24,190
Relapse,

828
00:28:24,190 --> 00:28:25,810
please all the code you write should

829
00:28:25,810 --> 00:28:27,850
be your own and you shouldn't share

830
00:28:27,850 --> 00:28:30,620
code or a look at other solutions.

831
00:28:32,740 --> 00:28:34,300
Greeting.

832
00:28:35,800 --> 00:28:36,970
Of course,

833
00:28:36,970 --> 00:28:38,000
um.

834
00:28:38,480 --> 00:28:41,480
We'll be mostly determined from the labs this year,

835
00:28:41,480 --> 00:28:44,120
so 70% of the grade will be,

836
00:28:44,120 --> 00:28:45,120
um.

837
00:28:45,780 --> 00:28:46,140
Yeah.

838
00:28:46,620 --> 00:28:46,770
Um,

839
00:28:46,770 --> 00:28:49,620
based on whether or not your lab,

840
00:28:49,620 --> 00:28:52,020
you submit passes the tests and we for grading,

841
00:28:52,020 --> 00:28:54,210
we run the same tests that we

842
00:28:54,210 --> 00:28:56,520
supply you so if your lab passes

843
00:28:56,520 --> 00:28:57,810
all the tests that we give you

844
00:28:57,810 --> 00:28:58,920
the chance to show you that full

845
00:28:58,920 --> 00:29:00,260
credit for the lab.

846
00:29:00,500 --> 00:29:04,070
A 20% of the grade is

847
00:29:04,070 --> 00:29:08,030
going to be from lab checkoff meetings

848
00:29:08,030 --> 00:29:09,500
for each of you will pick a

849
00:29:09,500 --> 00:29:11,660
couple of randomly selected labs and one

850
00:29:11,660 --> 00:29:13,280
of the teams will talk to you

851
00:29:13,280 --> 00:29:14,990
and ask you questions about your implementation

852
00:29:14,990 --> 00:29:17,180
just to make sure that um,

853
00:29:17,320 --> 00:29:19,620
are you really understand what's going on.

854
00:29:20,180 --> 00:29:22,080
It's a lab check offs.

855
00:29:23,870 --> 00:29:26,600
There's a 10% remaining.

856
00:29:28,040 --> 00:29:29,390
A lot of [cops] kind of

857
00:29:29,390 --> 00:29:31,790
be like a yes or no

858
00:29:31,790 --> 00:29:33,290
one or zero type of thing

859
00:29:33,290 --> 00:29:34,460
or would they be,

860
00:29:35,100 --> 00:29:38,250
like could someone get like if they

861
00:29:38,250 --> 00:29:40,080
answered some of the questions right,

862
00:29:40,080 --> 00:29:41,580
but not all the questions right when

863
00:29:41,580 --> 00:29:43,160
they get in between,

864
00:29:43,570 --> 00:29:44,700
so the grade.

865
00:29:45,060 --> 00:29:46,880
You know I haven't thought this through.

866
00:29:47,380 --> 00:29:48,610
Um,

867
00:29:48,610 --> 00:29:50,320
there's certainly room for partial credit

868
00:29:50,320 --> 00:29:52,480
but it's not a it won't

869
00:29:52,480 --> 00:29:55,090
be binary, it'll definitely be you

870
00:29:55,090 --> 00:29:56,540
can receive partial credit.

871
00:29:56,940 --> 00:29:57,680
Okay.

872
00:29:59,470 --> 00:30:01,390
Um, the last 10% is going to

873
00:30:01,390 --> 00:30:03,700
be a driven by the homework and

874
00:30:03,700 --> 00:30:06,920
participation during lecture and piazza.

875
00:30:07,480 --> 00:30:08,300
Um.

876
00:30:08,900 --> 00:30:11,740
There will be no exams or quizzes,

877
00:30:13,300 --> 00:30:14,520
this year.

878
00:30:15,150 --> 00:30:16,140
Um,

879
00:30:16,140 --> 00:30:16,560
and so what,

880
00:30:16,560 --> 00:30:18,480
that means is that most of the um,

881
00:30:18,480 --> 00:30:21,420
you know 90% of the grade

882
00:30:21,420 --> 00:30:23,160
is being driven by the lab

883
00:30:23,160 --> 00:30:24,780
so you should.

884
00:30:25,050 --> 00:30:26,730
Spend a lot of time in the labs,

885
00:30:26,730 --> 00:30:27,390
um,

886
00:30:27,390 --> 00:30:29,610
make sure that you start early

887
00:30:29,610 --> 00:30:31,710
and have enough time to complete

888
00:30:31,710 --> 00:30:33,930
them and work out bugs in

889
00:30:33,930 --> 00:30:35,400
order to get full credit.

890
00:30:37,270 --> 00:30:38,770
And you know as a result of

891
00:30:38,770 --> 00:30:40,000
that this is going to be a

892
00:30:40,000 --> 00:30:43,660
very kind of hands-on software oriented course.

893
00:30:44,580 --> 00:30:46,520
Any questions about the

894
00:30:47,180 --> 00:30:49,000
machinery of the course.

895
00:30:53,760 --> 00:30:54,150
Um,

896
00:30:54,150 --> 00:30:56,670
we've got a couple questions in chat,

897
00:30:56,670 --> 00:30:58,050
so the first is a logistical

898
00:30:58,050 --> 00:31:00,450
question, currently 6.S081

899
00:31:00,450 --> 00:31:01,650
isn't listed as usual for the

900
00:31:01,650 --> 00:31:03,990
system's concentration in the [?],

901
00:31:03,990 --> 00:31:05,370
are there plans added to the list

902
00:31:05,370 --> 00:31:07,350
of classes later. I think for that

903
00:31:07,350 --> 00:31:09,750
because it's not an AAGS

904
00:31:09,750 --> 00:31:11,880
it's an AUS, it can't be

905
00:31:11,880 --> 00:31:13,590
used to fulfill arrange requirements,

906
00:31:13,590 --> 00:31:15,700
so it's not a graduate level class.

907
00:31:15,970 --> 00:31:16,450
So,

908
00:31:16,450 --> 00:31:17,060
um.

909
00:31:19,270 --> 00:31:21,790
And then we have is the only

910
00:31:21,790 --> 00:31:23,410
homework to submit questions looking at the

911
00:31:23,410 --> 00:31:25,620
calendar that appears to be the case.

912
00:31:28,360 --> 00:31:30,400
Unless I'm forgetting something.

913
00:31:31,270 --> 00:31:32,110
I think that's the case,

914
00:31:32,110 --> 00:31:33,540
yes.

915
00:31:35,140 --> 00:31:37,660
So have, um, are there gonna

916
00:31:37,660 --> 00:31:39,670
be cutoffs for grades like X

917
00:31:39,670 --> 00:31:41,260
percent gets an A, Y percent

918
00:31:41,260 --> 00:31:43,510
gets a B etc.

919
00:31:43,510 --> 00:31:45,040
No no,

920
00:31:45,040 --> 00:31:46,180
um.

921
00:31:47,640 --> 00:31:48,210
Um,

922
00:31:48,210 --> 00:31:49,680
you know we're going to try to

923
00:31:49,680 --> 00:31:53,100
a free student estimate.

924
00:31:53,320 --> 00:31:56,950
I'm impression of how well you've

925
00:31:56,950 --> 00:31:58,090
understood the material,

926
00:31:58,090 --> 00:31:58,900
um.

927
00:31:59,250 --> 00:32:00,480
And assign a grade based on that

928
00:32:00,480 --> 00:32:03,080
so there's no predetermined cutoffs.

929
00:32:07,950 --> 00:32:10,020
All right, anything else.

930
00:32:13,660 --> 00:32:14,740
All right.

931
00:32:14,740 --> 00:32:17,140
Just real quick for folks in the

932
00:32:17,140 --> 00:32:20,980
chat asking about the

933
00:32:21,070 --> 00:32:23,530
concentration requirement, I'm not a hundred

934
00:32:23,530 --> 00:32:24,820
percent certain, um,

935
00:32:24,820 --> 00:32:26,890
but 6.S081 is not,

936
00:32:26,890 --> 00:32:28,570
it's like a temporary number before the

937
00:32:28,570 --> 00:32:30,340
class gets official one, so it

938
00:32:30,340 --> 00:32:33,280
certainly won't be listed anywhere,

939
00:32:33,280 --> 00:32:34,540
if you need it to fulfill a

940
00:32:34,540 --> 00:32:36,010
concentration, I think your best bet is

941
00:32:36,010 --> 00:32:37,720
probably to fill out a petition or

942
00:32:37,720 --> 00:32:40,480
to email somebody like Katrina Kurtz.

943
00:32:40,780 --> 00:32:44,920
To see a what the status is, we don't control,

944
00:32:45,570 --> 00:32:48,180
you know what what classes fill these

945
00:32:48,180 --> 00:32:49,260
kind of requirements,

946
00:32:49,260 --> 00:32:50,400
unfortunately.

947
00:32:51,240 --> 00:32:52,650
And for what language will be using

948
00:32:52,650 --> 00:32:55,180
the class will be in C.

949
00:32:55,490 --> 00:32:57,020
Yes.

950
00:32:58,700 --> 00:32:59,540
All right,

951
00:32:59,540 --> 00:33:00,520
um.

952
00:33:00,960 --> 00:33:01,380
Yeah.

953
00:33:02,400 --> 00:33:03,900
All right, for the rest of the lecture

954
00:33:03,900 --> 00:33:06,660
I want to talk about how, um,

955
00:33:06,660 --> 00:33:09,990
what system calls look like applications,

956
00:33:09,990 --> 00:33:10,800
um,

957
00:33:11,290 --> 00:33:13,660
and you know since the system calls

958
00:33:13,660 --> 00:33:16,480
are the interface to the services that

959
00:33:16,480 --> 00:33:18,880
the operating system provides is actually pretty

960
00:33:18,880 --> 00:33:21,010
important what those systems look like what

961
00:33:21,010 --> 00:33:23,740
applications expect from system calls and how

962
00:33:23,740 --> 00:33:26,170
they behave so it's worth understanding what

963
00:33:26,170 --> 00:33:28,280
the interface looks like.

964
00:33:29,380 --> 00:33:29,740
Um,

965
00:33:29,740 --> 00:33:31,090
you'll be using the system calls we

966
00:33:31,090 --> 00:33:32,840
talk about in the first lab.

967
00:33:32,960 --> 00:33:33,320
Um,

968
00:33:33,320 --> 00:33:37,160
and extending and improving the implementation

969
00:33:37,160 --> 00:33:39,140
internal implementation of these system calls

970
00:33:39,140 --> 00:33:40,460
in subsequent labs.

971
00:33:40,960 --> 00:33:43,120
What we're gonna do is show some

972
00:33:43,120 --> 00:33:47,260
simple examples of little programs.

973
00:33:47,980 --> 00:33:51,760
That call system calls and I'll run

974
00:33:51,760 --> 00:33:53,960
them in xv6 for you.

975
00:33:54,540 --> 00:33:56,370
I'm gonna run them,

976
00:33:56,370 --> 00:33:58,420
the xv6 is a, um,

977
00:33:58,550 --> 00:33:58,910
it's a unix,

978
00:33:58,910 --> 00:34:01,250
a simplified unix-like operating system unix

979
00:34:01,250 --> 00:34:03,740
is a old operating system that's at

980
00:34:03,740 --> 00:34:07,460
least intellectual basis for many present-day operating

981
00:34:07,460 --> 00:34:09,470
systems such as Linux and OS X

982
00:34:09,470 --> 00:34:11,480
it's in very common use.

983
00:34:11,480 --> 00:34:11,480
Um,

984
00:34:14,540 --> 00:34:18,140
xv6 our teaching operating system is

985
00:34:18,140 --> 00:34:20,960
much simpler and sort of inspired by

986
00:34:20,960 --> 00:34:23,390
unix and has the same overall structure,

987
00:34:23,390 --> 00:34:26,540
but is dramatically simpler than any real

988
00:34:26,540 --> 00:34:28,180
unix operating system.

989
00:34:28,610 --> 00:34:29,440
Um,

990
00:34:30,750 --> 00:34:33,120
it's simple enough that hopefully,

991
00:34:33,120 --> 00:34:35,070
um, you know it would

992
00:34:35,070 --> 00:34:36,600
be relatively straightforward

993
00:34:36,600 --> 00:34:38,550
for you to read all the source code,

994
00:34:38,550 --> 00:34:40,080
as well as read the book,

995
00:34:40,080 --> 00:34:41,910
in a couple of weeks certainly

996
00:34:41,910 --> 00:34:43,560
during the semester in order to

997
00:34:43,560 --> 00:34:44,970
kind of understand all of what

998
00:34:44,970 --> 00:34:47,200
happens inside xv6.

999
00:34:47,680 --> 00:34:48,400
Um,

1000
00:34:49,680 --> 00:34:52,110
xv6 runs on the RISC-V

1001
00:34:52,110 --> 00:34:55,320
processor, RISC-V microprocessor and this is

1002
00:34:55,320 --> 00:34:57,690
the same microprocessor that's the focus of

1003
00:34:57,690 --> 00:34:59,700
recent 6.004

1004
00:34:59,800 --> 00:35:00,040
Um,

1005
00:35:00,040 --> 00:35:01,750
so many of you may actually

1006
00:35:01,750 --> 00:35:03,520
know quite a bit about the

1007
00:35:03,520 --> 00:35:05,240
RISC-V instruction set.

1008
00:35:05,780 --> 00:35:08,720
Um, in theory you could run xv6

1009
00:35:08,720 --> 00:35:11,510
on top of a RISC-V computer

1010
00:35:11,510 --> 00:35:13,370
and people done that.

1011
00:35:13,370 --> 00:35:14,160
Um,

1012
00:35:14,560 --> 00:35:16,330
but we're going to run it under the QEMU,

1013
00:35:16,330 --> 00:35:18,910
um, machine emulator,

1014
00:35:18,910 --> 00:35:20,680
just write this down we got.

1015
00:35:20,810 --> 00:35:22,400
Our operating system is

1016
00:35:22,400 --> 00:35:23,570
xv6,

1017
00:35:23,570 --> 00:35:26,300
um, runs on RISC-V.

1018
00:35:26,720 --> 00:35:30,350
Microprocessor and not just RISC-V microprocessor,

1019
00:35:30,350 --> 00:35:31,790
but we assume a certain amount

1020
00:35:31,790 --> 00:35:34,670
of surrounding hardware like memory

1021
00:35:34,670 --> 00:35:36,120
and disk.

1022
00:35:36,280 --> 00:35:39,520
And console interface for us to talk to it.

1023
00:35:39,520 --> 00:35:40,300
Um,

1024
00:35:40,740 --> 00:35:43,300
We actually run under the QEMU

1025
00:35:44,720 --> 00:35:46,980
machine simulator.

1026
00:35:48,440 --> 00:35:50,210
So that which runs under Linux,

1027
00:35:50,210 --> 00:35:52,800
so I'm all you can actually.

1028
00:35:53,400 --> 00:35:56,120
A run xv6 without having that hardware.

1029
00:35:56,860 --> 00:36:01,260
Okay so kind of switch to a show the code.

1030
00:36:15,570 --> 00:36:16,050
All right,

1031
00:36:16,050 --> 00:36:16,800
so,

1032
00:36:16,800 --> 00:36:22,660
um, first thing is I've a setup xv6 on my laptop,

1033
00:36:22,800 --> 00:36:25,440
I'm going to run it type 'make qemu',

1034
00:36:25,440 --> 00:36:25,740
'make qemu',

1035
00:36:25,740 --> 00:36:27,030
you'll find yourself doing quite a

1036
00:36:27,030 --> 00:36:28,320
bit during the labs,

1037
00:36:28,320 --> 00:36:30,960
um, which compiles xv6 it's written in C,

1038
00:36:30,960 --> 00:36:32,440
so it's compiled with

1039
00:36:32,520 --> 00:36:33,990
C compiler,

1040
00:36:33,990 --> 00:36:36,930
maybe I'll 'make clean' for you,

1041
00:36:36,930 --> 00:36:39,000
so you can see the actual compilation

1042
00:36:39,000 --> 00:36:40,620
and I might 'make qemu',

1043
00:36:40,620 --> 00:36:43,170
which has the effect of compiling and

1044
00:36:43,170 --> 00:36:45,180
building xv6 kernel and all the

1045
00:36:45,180 --> 00:36:48,600
user processes and then running them under

1046
00:36:48,600 --> 00:36:50,300
the QEMU emulator.

1047
00:36:51,860 --> 00:36:53,880
Takes a moment around the compiles,

1048
00:36:55,020 --> 00:36:55,560
yeah,

1049
00:36:56,000 --> 00:36:58,220
and now we're up and running

1050
00:36:58,220 --> 00:36:59,990
xv6 and the '$'

1051
00:36:59,990 --> 00:37:02,570
prompt you see as the shell which

1052
00:37:02,570 --> 00:37:04,460
is the command line interface,

1053
00:37:04,460 --> 00:37:08,360
um, to xv6, modeled after the shell on unix,

1054
00:37:08,360 --> 00:37:09,160
which is.

1055
00:37:09,420 --> 00:37:09,750
um,

1056
00:37:09,750 --> 00:37:12,240
if you log into Athena organization and

1057
00:37:12,240 --> 00:37:14,880
it's, um, it's like the shell that

1058
00:37:14,880 --> 00:37:16,080
Athena shows you.

1059
00:37:18,180 --> 00:37:20,580
xv6 itself tiny and it comes with

1060
00:37:20,580 --> 00:37:23,920
a small number of utility programs and

1061
00:37:24,220 --> 00:37:26,110
including for example the 'ls' program which

1062
00:37:26,110 --> 00:37:28,390
I'm about to run run ls and

1063
00:37:28,390 --> 00:37:29,660
it gives me a list of

1064
00:37:30,210 --> 00:37:31,470
all the files and xv6

1065
00:37:31,470 --> 00:37:32,670
of which there are only about

1066
00:37:32,670 --> 00:37:36,320
two dozen including things like grep and

1067
00:37:36,410 --> 00:37:39,830
kill and mkdir, rm which

1068
00:37:39,830 --> 00:37:41,210
may be familiar to us,

1069
00:37:41,210 --> 00:37:41,840
um,

1070
00:37:42,160 --> 00:37:43,640
as unix utilities.

1071
00:37:44,930 --> 00:37:45,290
Okay,

1072
00:37:45,290 --> 00:37:46,010
the first program,

1073
00:37:46,010 --> 00:37:47,540
I'm gonna show you to illustrate system

1074
00:37:47,540 --> 00:37:52,380
calls is a program called copy,

1075
00:37:54,520 --> 00:37:54,960
um,

1076
00:37:59,890 --> 00:38:01,220
um,

1077
00:38:01,900 --> 00:38:04,260
here's the source is just a page,

1078
00:38:07,320 --> 00:38:08,760
um,

1079
00:38:08,760 --> 00:38:09,750
so what you're seeing here is

1080
00:38:09,750 --> 00:38:11,940
a program that starts on line

1081
00:38:11,940 --> 00:38:13,290
8 and main is that sort

1082
00:38:13,290 --> 00:38:15,510
of convention for C programs,

1083
00:38:15,510 --> 00:38:17,740
it sits in a loop at line 12,

1084
00:38:17,940 --> 00:38:21,150
and over and over again, it reads

1085
00:38:21,150 --> 00:38:23,280
some data as input and on line

1086
00:38:23,280 --> 00:38:25,110
13 and then writes the data just

1087
00:38:25,110 --> 00:38:28,180
read his output on line 16,

1088
00:38:28,390 --> 00:38:29,800
by run copy,

1089
00:38:32,130 --> 00:38:35,550
um, in xv6, it's waiting to read input,

1090
00:38:35,550 --> 00:38:37,740
if I type some input,

1091
00:38:37,840 --> 00:38:40,860
I'm reads it and spits it back up to me.

1092
00:38:41,640 --> 00:38:44,380
Very simple program just does IO.

1093
00:38:44,950 --> 00:38:45,250
Um,

1094
00:38:45,250 --> 00:38:47,170
it's really see as I mentioned a

1095
00:38:47,170 --> 00:38:49,090
if you don't already know C, it's

1096
00:38:49,090 --> 00:38:53,290
worthwhile getting the standard C programming language

1097
00:38:53,290 --> 00:38:55,100
book by Kernighan and Ritchie.

1098
00:38:55,180 --> 00:38:56,400
And I think there's a

1099
00:38:56,730 --> 00:38:59,490
more full reference to it on the

1100
00:38:59,490 --> 00:39:02,680
course website which explains to you and,

1101
00:39:02,760 --> 00:39:05,380
um, very straightforward way how to program in C.

1102
00:39:06,140 --> 00:39:06,440
Yeah,

1103
00:39:08,180 --> 00:39:09,200
as I mentioned before,

1104
00:39:09,200 --> 00:39:11,870
we even write this program makes two

1105
00:39:11,870 --> 00:39:13,340
really three system calls read

1106
00:39:13,340 --> 00:39:16,320
write and exit, our system calls.

1107
00:39:16,460 --> 00:39:17,270
Um,

1108
00:39:17,270 --> 00:39:18,140
if you look at the call to

1109
00:39:18,140 --> 00:39:22,020
read on line 13, it takes three arguments,

1110
00:39:22,500 --> 00:39:23,970
the first argument is a file descriptor

1111
00:39:23,970 --> 00:39:25,230
which is really a reference to a

1112
00:39:25,230 --> 00:39:27,060
previously opened file.

1113
00:39:27,340 --> 00:39:27,610
Um,

1114
00:39:27,610 --> 00:39:29,140
and the shell,

1115
00:39:29,140 --> 00:39:33,340
ensures that when a program starts by default,

1116
00:39:33,440 --> 00:39:35,750
it's file descriptor 0 is connected to

1117
00:39:35,750 --> 00:39:38,300
the console input, and its file descriptor

1118
00:39:38,300 --> 00:39:41,090
1 is connected to the console

1119
00:39:41,090 --> 00:39:42,170
output, and that's why I was

1120
00:39:42,170 --> 00:39:43,600
able to type to

1121
00:39:43,920 --> 00:39:46,900
this copy program and see the output.

1122
00:39:48,700 --> 00:39:49,780
Um,

1123
00:39:49,780 --> 00:39:52,660
of course, these file descriptors are expected

1124
00:39:52,660 --> 00:39:54,640
the program expected these file descriptors have

1125
00:39:54,640 --> 00:39:56,350
been previously opened and set up by

1126
00:39:56,350 --> 00:39:57,500
the shell for it.

1127
00:39:57,600 --> 00:40:01,860
And 0 1 file descriptors,

1128
00:40:01,920 --> 00:40:03,780
pervasive units convention many,

1129
00:40:03,780 --> 00:40:06,240
many unix programs expect to read from

1130
00:40:06,240 --> 00:40:09,180
file descriptor 1 and read file descriptor

1131
00:40:09,180 --> 00:40:11,520
0 and write to file descriptor 1.

1132
00:40:12,730 --> 00:40:14,980
A second argument to read is a

1133
00:40:14,980 --> 00:40:17,000
pointer to some memory,

1134
00:40:17,160 --> 00:40:17,400
um,

1135
00:40:17,400 --> 00:40:19,110
where the program is asking the operating

1136
00:40:19,110 --> 00:40:21,020
system to read data

1137
00:40:21,390 --> 00:40:22,710
into that address in memory,

1138
00:40:22,710 --> 00:40:25,800
so that's the buff argument and line 10

1139
00:40:26,000 --> 00:40:30,060
allocate 64 bytes of memory on the stack, um,

1140
00:40:30,350 --> 00:40:31,910
for read to read into, and the

1141
00:40:31,910 --> 00:40:33,800
third argument to read is the maximum

1142
00:40:33,800 --> 00:40:35,540
number of bytes that the program wants

1143
00:40:35,540 --> 00:40:37,490
to read and the size of buffs

1144
00:40:37,490 --> 00:40:40,730
as just sixty maximum 64 bytes,

1145
00:40:40,730 --> 00:40:42,410
so the recall reads up to 64

1146
00:40:42,410 --> 00:40:45,080
bytes from whatever is connected to file

1147
00:40:45,080 --> 00:40:46,860
descriptor 0 and that was

1148
00:40:47,080 --> 00:40:48,820
my terminal in this example.

1149
00:40:48,820 --> 00:40:51,460
The return value from read it either

1150
00:40:51,460 --> 00:40:53,230
it may be sure of the number

1151
00:40:53,230 --> 00:40:54,640
of bytes read,

1152
00:40:54,640 --> 00:40:54,910
um,

1153
00:40:54,910 --> 00:40:58,240
which would be 6 and a piece of, um,

1154
00:40:58,240 --> 00:41:00,740
typing "xyzzy" by

1155
00:41:01,150 --> 00:41:02,830
be might be reading from a file,

1156
00:41:02,830 --> 00:41:04,090
if it gets to the end of the file,

1157
00:41:04,090 --> 00:41:05,110
there's no more bytes,

1158
00:41:05,110 --> 00:41:06,760
read will return 0.

1159
00:41:07,160 --> 00:41:09,470
And then some other error occurred like

1160
00:41:09,470 --> 00:41:11,900
the file descriptor doesn't exist, read may

1161
00:41:11,900 --> 00:41:13,440
return -1.

1162
00:41:13,780 --> 00:41:15,940
And, so in many of these examples

1163
00:41:15,940 --> 00:41:17,860
like on line 16 there.

1164
00:41:17,940 --> 00:41:20,640
Um I don't my example code doesn't

1165
00:41:20,640 --> 00:41:24,240
check system call returns for errors.

1166
00:41:24,540 --> 00:41:26,340
But you should be more careful than me,

1167
00:41:26,340 --> 00:41:27,330
um,

1168
00:41:27,330 --> 00:41:29,220
um the you should figure out how

1169
00:41:29,220 --> 00:41:30,750
system calls reflect errors,

1170
00:41:30,750 --> 00:41:32,220
it's usually a -1 return

1171
00:41:32,220 --> 00:41:35,040
value and check all system called

1172
00:41:35,040 --> 00:41:36,560
returns for errors.

1173
00:41:37,280 --> 00:41:38,630
And if you want to know

1174
00:41:38,630 --> 00:41:40,550
what the system call arguments and

1175
00:41:40,550 --> 00:41:42,080
return values are there's a table

1176
00:41:42,080 --> 00:41:43,760
and I think chapter 2 in

1177
00:41:43,760 --> 00:41:46,250
the book explains all of the

1178
00:41:46,250 --> 00:41:50,500
xv6 system call arguments and

1179
00:41:50,880 --> 00:41:52,770
return values.

1180
00:41:52,770 --> 00:41:55,440
The question regarding the read syscall,

1181
00:41:55,440 --> 00:41:57,120
what if we set the max read

1182
00:41:57,120 --> 00:41:59,520
bytes to size of buff to one

1183
00:41:59,520 --> 00:42:01,500
plus size of buffer or bigger,

1184
00:42:01,500 --> 00:42:03,030
so what if we try to read more than the size.

1185
00:42:03,030 --> 00:42:03,300
Yeah,

1186
00:42:03,300 --> 00:42:06,900
then if there was 65 bytes to read,

1187
00:42:06,900 --> 00:42:10,080
then the operating system would happily will just

1188
00:42:10,130 --> 00:42:12,800
copy those 65 bytes to

1189
00:42:12,800 --> 00:42:14,780
the memory that you provide

1190
00:42:14,780 --> 00:42:16,790
and of course there's something

1191
00:42:16,790 --> 00:42:17,660
else on the stack up

1192
00:42:17,660 --> 00:42:19,700
there maybe the return program

1193
00:42:19,700 --> 00:42:20,870
counter or an argument or

1194
00:42:20,870 --> 00:42:22,460
something and so if you

1195
00:42:22,460 --> 00:42:23,930
pass 65,

1196
00:42:23,930 --> 00:42:26,920
then you're inviting a kernel to write junk.

1197
00:42:27,120 --> 00:42:29,840
Um to an unexpected place in your stack.

1198
00:42:30,280 --> 00:42:32,470
And so that's a bug and it

1199
00:42:32,470 --> 00:42:34,160
may cause your [firm] to crash.

1200
00:42:34,420 --> 00:42:37,390
Or do something else unexpected,

1201
00:42:37,390 --> 00:42:38,650
so as a programmer,

1202
00:42:38,650 --> 00:42:39,580
you have to be careful here,

1203
00:42:39,580 --> 00:42:42,130
there's nobody writing in C with these

1204
00:42:42,130 --> 00:42:43,540
kind of interfaces there's.

1205
00:42:43,830 --> 00:42:44,880
Um,

1206
00:42:44,880 --> 00:42:46,320
it's very very easy to write

1207
00:42:46,320 --> 00:42:48,420
code that the compiler is happy

1208
00:42:48,420 --> 00:42:50,130
with and will run but absolutely

1209
00:42:50,130 --> 00:42:51,340
does the wrong thing.

1210
00:42:51,660 --> 00:42:53,130
Um,

1211
00:42:53,130 --> 00:42:57,320
so that's too bad but it's the way it is.

1212
00:43:00,540 --> 00:43:01,080
Okay,

1213
00:43:01,080 --> 00:43:01,350
um,

1214
00:43:01,350 --> 00:43:03,750
one thing to note is that this

1215
00:43:03,750 --> 00:43:05,700
copy program and indeed the read write

1216
00:43:05,700 --> 00:43:07,740
system calls they don't care about the

1217
00:43:07,740 --> 00:43:08,460
format of data,

1218
00:43:08,460 --> 00:43:10,470
they're reading or writing a they just

1219
00:43:10,470 --> 00:43:12,480
read and write read and write in

1220
00:43:12,480 --> 00:43:13,820
this copy program.

1221
00:43:13,980 --> 00:43:15,780
Just deal with 8 bit bytes with

1222
00:43:15,780 --> 00:43:17,600
screams of 8 bit bytes.

1223
00:43:17,680 --> 00:43:18,610
Um,

1224
00:43:18,610 --> 00:43:20,500
how you interpret them is totally up

1225
00:43:20,500 --> 00:43:21,220
to the application,

1226
00:43:21,220 --> 00:43:23,160
so the application maybe,

1227
00:43:23,300 --> 00:43:26,840
a parse there data records or as C source code,

1228
00:43:26,840 --> 00:43:28,100
or who knows what.

1229
00:43:28,890 --> 00:43:30,390
The operating system,

1230
00:43:30,390 --> 00:43:31,260
um,

1231
00:43:33,030 --> 00:43:34,200
the only things in terms of a

1232
00:43:34,200 --> 00:43:36,120
stream of 8 bit bytes.

1233
00:43:36,220 --> 00:43:36,520
Okay,

1234
00:43:36,520 --> 00:43:37,420
so copy,

1235
00:43:37,420 --> 00:43:38,800
assumed this code,

1236
00:43:38,800 --> 00:43:40,120
my copy I can assume that the

1237
00:43:40,120 --> 00:43:42,850
file descriptors are already set up,

1238
00:43:42,850 --> 00:43:44,380
but we need to need to have

1239
00:43:44,380 --> 00:43:46,220
a way to create file descriptors.

1240
00:43:46,280 --> 00:43:47,870
And the most straightforward way to do

1241
00:43:47,870 --> 00:43:51,140
that is I'm with the open system

1242
00:43:51,140 --> 00:43:52,910
call and so here's the source for

1243
00:43:52,910 --> 00:43:55,520
a program that called open.

1244
00:43:55,720 --> 00:43:57,180
That um,

1245
00:43:58,120 --> 00:44:00,370
I use the open system call. A

1246
00:44:00,370 --> 00:44:01,600
question from the chat,

1247
00:44:01,600 --> 00:44:04,900
what do you mean by a stream of bytes.

1248
00:44:07,190 --> 00:44:07,280
Um,

1249
00:44:07,280 --> 00:44:09,380
I just mean that if a

1250
00:44:09,380 --> 00:44:12,060
file contains a bunch of bytes.

1251
00:44:12,180 --> 00:44:15,000
Then read then successive spilling a pile

1252
00:44:15,000 --> 00:44:16,860
contains a million bytes,

1253
00:44:16,860 --> 00:44:21,040
if you make a sequence of recalls each 400 bytes.

1254
00:44:21,160 --> 00:44:22,330
You know I'll just read the first

1255
00:44:22,330 --> 00:44:23,710
hundred bytes and then the second hundred

1256
00:44:23,710 --> 00:44:24,580
bytes and then third,

1257
00:44:24,580 --> 00:44:27,260
the third hundred bytes.

1258
00:44:27,960 --> 00:44:28,880
And um.

1259
00:44:32,000 --> 00:44:32,330
All right,

1260
00:44:32,330 --> 00:44:33,350
so this program,

1261
00:44:33,350 --> 00:44:36,380
um, called open, I'll run it for you.

1262
00:44:36,720 --> 00:44:36,900
Um,

1263
00:44:36,900 --> 00:44:39,990
what it does is a opens creates

1264
00:44:39,990 --> 00:44:41,940
a new file called "output.txt"

1265
00:44:41,940 --> 00:44:44,520
and then write some bytes to it,

1266
00:44:44,520 --> 00:44:45,990
I'm gonna finish this so we don't

1267
00:44:45,990 --> 00:44:48,180
see anything because it broke data to

1268
00:44:48,180 --> 00:44:49,020
this file.

1269
00:44:49,020 --> 00:44:50,380
But we can look

1270
00:44:50,700 --> 00:44:55,110
this "output.txt" file that created it and see,

1271
00:44:55,110 --> 00:44:55,410
um,

1272
00:44:55,410 --> 00:44:57,390
the "ooo" wrote there,

1273
00:44:57,390 --> 00:45:00,100
so an 11 in the program.

1274
00:45:00,430 --> 00:45:02,380
Makes the open system call,

1275
00:45:02,380 --> 00:45:04,750
give it a filename "output.txt"

1276
00:45:04,750 --> 00:45:07,330
and the "O_" stuff,

1277
00:45:07,330 --> 00:45:08,860
um in the second argument to open

1278
00:45:08,860 --> 00:45:12,070
our flags that tell the open system

1279
00:45:12,070 --> 00:45:14,500
call implementation in the kernel, that we'd

1280
00:45:14,500 --> 00:45:16,030
like to create a file with its

1281
00:45:16,030 --> 00:45:18,020
name and we're going to write it.

1282
00:45:18,860 --> 00:45:22,000
Open returns a newly allocated file descriptor.

1283
00:45:22,570 --> 00:45:23,340
Um,

1284
00:45:23,740 --> 00:45:24,670
and the file descriptor is just

1285
00:45:24,670 --> 00:45:26,410
a small number, probably 2 or

1286
00:45:26,410 --> 00:45:27,760
3 or 4 something.

1287
00:45:28,430 --> 00:45:29,840
And then we pass that same file

1288
00:45:29,840 --> 00:45:32,960
descriptor right along with the buffer and

1289
00:45:33,050 --> 00:45:36,760
a number of ways to write a that writes data,

1290
00:45:37,040 --> 00:45:37,940
um, the file,

1291
00:45:37,940 --> 00:45:40,080
the file descriptor refers to.

1292
00:45:41,430 --> 00:45:43,440
What that file descriptor is actually doing

1293
00:45:43,440 --> 00:45:46,170
is indexing into a little table inside

1294
00:45:46,170 --> 00:45:49,410
the kernel, the kernel maintains state for each process,

1295
00:45:49,410 --> 00:45:51,660
that's running each program that you run

1296
00:45:51,660 --> 00:45:52,620
and among other things,

1297
00:45:52,620 --> 00:45:55,140
the kernel remembers a table for every

1298
00:45:55,140 --> 00:45:58,830
running process of index by file descriptors

1299
00:45:58,830 --> 00:46:01,020
and the table sort of tells the

1300
00:46:01,020 --> 00:46:04,380
kernel what each file descriptor refers to.

1301
00:46:05,040 --> 00:46:05,740
Okay,

1302
00:46:08,020 --> 00:46:10,960
a critical point is that each process

1303
00:46:10,960 --> 00:46:13,300
has its own sort of space of

1304
00:46:13,300 --> 00:46:15,040
file descriptors. So,

1305
00:46:15,200 --> 00:46:17,420
before running two different processes,

1306
00:46:17,420 --> 00:46:19,790
two different programs and different processes and

1307
00:46:19,790 --> 00:46:20,990
they both open a file,

1308
00:46:20,990 --> 00:46:22,640
they may actually get the same number

1309
00:46:22,640 --> 00:46:24,350
back as a file descriptor,

1310
00:46:24,350 --> 00:46:26,450
but because the kernel maintains a separate

1311
00:46:26,450 --> 00:46:29,000
file descriptor for each process,

1312
00:46:29,080 --> 00:46:31,630
the same file descriptor number may refer

1313
00:46:31,630 --> 00:46:34,720
to different files in different processes.

1314
00:46:37,040 --> 00:46:39,640
Any questions that open about this little program.

1315
00:46:40,240 --> 00:46:41,050
Now we had a question in

1316
00:46:41,050 --> 00:46:42,640
chat, question from someone not

1317
00:46:42,640 --> 00:46:43,990
familiar with C,

1318
00:46:43,990 --> 00:46:46,540
how are these files being described different

1319
00:46:46,540 --> 00:46:47,830
from normal C programs,

1320
00:46:47,830 --> 00:46:49,990
is it because we're only using kernel

1321
00:46:49,990 --> 00:46:52,480
calls, i.e couldn't we also open or

1322
00:46:52,480 --> 00:46:54,040
write a file in python.

1323
00:46:58,500 --> 00:46:59,060
Um,

1324
00:46:59,440 --> 00:47:01,260
I don't think I understand that

1325
00:47:02,000 --> 00:47:02,750
it's a C program,

1326
00:47:02,750 --> 00:47:04,520
that's opening and writing a file.

1327
00:47:12,480 --> 00:47:13,180
Um,

1328
00:47:15,620 --> 00:47:18,040
that's going to move on.

1329
00:47:20,640 --> 00:47:24,780
All right so you might ask what

1330
00:47:24,780 --> 00:47:27,480
actually happens when ... Maybe the question

1331
00:47:27,480 --> 00:47:29,430
is when someone is doing it

1332
00:47:29,430 --> 00:47:31,110
in C any different than doing

1333
00:47:31,110 --> 00:47:33,300
it in Python minus the syntax.

1334
00:47:34,240 --> 00:47:38,380
Well it's not really, um,

1335
00:47:38,620 --> 00:47:39,400
and,

1336
00:47:40,680 --> 00:47:44,040
there's certainly ways to, um,

1337
00:47:44,410 --> 00:47:48,280
python provides nice function calls for opening

1338
00:47:48,280 --> 00:47:50,040
and doing all these things too.

1339
00:47:50,830 --> 00:47:51,640
Or opening files,

1340
00:47:51,640 --> 00:47:53,590
for example in reading writing files,

1341
00:47:53,590 --> 00:47:54,310
um,

1342
00:47:54,310 --> 00:47:56,890
there's a layer of a higher

1343
00:47:56,890 --> 00:47:59,920
somewhat higher level functions typically not

1344
00:47:59,920 --> 00:48:00,970
pointers the memory,

1345
00:48:00,970 --> 00:48:01,940
for example.

1346
00:48:02,140 --> 00:48:03,040
Um,

1347
00:48:03,690 --> 00:48:06,680
and python has more error checking for you.

1348
00:48:07,140 --> 00:48:08,160
Um,

1349
00:48:08,160 --> 00:48:09,120
but when you open a file in

1350
00:48:09,120 --> 00:48:11,940
python or write a file on python, the

1351
00:48:11,960 --> 00:48:13,360
python calls you make.

1352
00:48:14,300 --> 00:48:18,160
Boil down to system calls just like these.

1353
00:48:19,840 --> 00:48:21,520
Is that a good answer.

1354
00:48:25,860 --> 00:48:27,030
Think so.

1355
00:48:27,030 --> 00:48:28,940
All right,

1356
00:48:30,980 --> 00:48:32,840
all right, um.

1357
00:48:33,560 --> 00:48:36,680
I've been over here talking to the, um,

1358
00:48:39,120 --> 00:48:43,440
xv6 is unix like shell

1359
00:48:43,440 --> 00:48:44,970
and the shell is what people often

1360
00:48:44,970 --> 00:48:46,890
call the command line interface,

1361
00:48:46,890 --> 00:48:50,980
um, as opposed to a more graphical user interface.

1362
00:48:51,240 --> 00:48:53,370
Um, the shell turns,

1363
00:48:53,370 --> 00:48:54,450
if you haven't used the shell,

1364
00:48:54,450 --> 00:48:56,400
the shell turns out to be a

1365
00:48:56,400 --> 00:48:58,200
pretty useful interface for things like system

1366
00:48:58,200 --> 00:49:01,440
management of unix systems,

1367
00:49:01,440 --> 00:49:02,940
it provides a lot of utilities

1368
00:49:02,940 --> 00:49:05,370
for messing around with files and

1369
00:49:05,370 --> 00:49:07,080
for program development and

1370
00:49:07,140 --> 00:49:09,180
on writing scripts to do all these

1371
00:49:09,180 --> 00:49:12,340
things. So, [some before run],

1372
00:49:12,550 --> 00:49:13,660
I just want to demonstrate a few

1373
00:49:13,660 --> 00:49:16,630
shell features ordinarily when you type things,

1374
00:49:16,630 --> 00:49:17,580
um.

1375
00:49:17,770 --> 00:49:20,080
You're telling the shell to run a program,

1376
00:49:20,080 --> 00:49:21,280
so when I type ls what

1377
00:49:21,280 --> 00:49:23,410
that means is I'm asking the

1378
00:49:23,410 --> 00:49:25,480
shell to run the program

1379
00:49:25,530 --> 00:49:27,480
whose name is ls, and what

1380
00:49:27,480 --> 00:49:28,590
that really means is there's a

1381
00:49:28,590 --> 00:49:30,990
file in the file system called

1382
00:49:30,990 --> 00:49:33,630
ls that contains some instructions,

1383
00:49:33,630 --> 00:49:35,880
some machine instructions and I'm asking the

1384
00:49:35,880 --> 00:49:38,520
shell to run the instructions that are

1385
00:49:38,520 --> 00:49:40,770
in the file called ls,

1386
00:49:40,770 --> 00:49:44,660
one ls now ls what it actually does is, um.

1387
00:49:44,940 --> 00:49:46,290
Get a listing of the files in

1388
00:49:46,290 --> 00:49:47,250
the current directory,

1389
00:49:47,250 --> 00:49:48,150
and you can see up there

1390
00:49:48,150 --> 00:49:50,970
on the 4 line that among

1391
00:49:50,970 --> 00:49:52,900
the other files that

1392
00:49:52,980 --> 00:49:54,420
ls as exists,

1393
00:49:54,420 --> 00:49:56,040
and this list is a file called

1394
00:49:56,040 --> 00:49:58,560
ls which is in fact the file

1395
00:49:58,560 --> 00:50:00,540
containing the instructions I just ran.

1396
00:50:02,370 --> 00:50:03,660
The show does a few other things

1397
00:50:03,660 --> 00:50:06,690
for you other than running programs allows

1398
00:50:06,690 --> 00:50:08,490
you to redirect IO,

1399
00:50:08,490 --> 00:50:10,230
so for example if I say

1400
00:50:10,230 --> 00:50:12,420
'ls > out' what that means is

1401
00:50:12,420 --> 00:50:15,030
asking the shell run the ls command,

1402
00:50:15,030 --> 00:50:16,980
but with its output redirected to the

1403
00:50:16,980 --> 00:50:18,260
file called out.

1404
00:50:18,520 --> 00:50:19,920
I run ls.

1405
00:50:21,080 --> 00:50:22,640
We don't see any output because the

1406
00:50:22,640 --> 00:50:24,080
output all went out.

1407
00:50:24,960 --> 00:50:25,920
Um,

1408
00:50:25,920 --> 00:50:28,530
now I can out contains a bunch of data,

1409
00:50:28,530 --> 00:50:29,370
um,

1410
00:50:29,370 --> 00:50:30,380
we could.

1411
00:50:30,900 --> 00:50:33,300
The cat command reads a file and

1412
00:50:33,300 --> 00:50:35,430
displays the contents of the file,

1413
00:50:35,430 --> 00:50:37,080
so I say 'cat out'.

1414
00:50:37,190 --> 00:50:38,870
Just going to see now the now

1415
00:50:38,870 --> 00:50:41,080
this is the same output of ls.

1416
00:50:41,170 --> 00:50:42,490
You can also run a command like

1417
00:50:42,490 --> 00:50:43,420
'grep' and I can give it an

1418
00:50:43,420 --> 00:50:46,300
argument "x" and what 'grep x'.

1419
00:50:46,520 --> 00:50:48,700
The grep command searches for patterns.

1420
00:50:49,080 --> 00:50:54,360
Again a if I run 'grep x', it's gonna search for

1421
00:50:54,680 --> 00:50:58,250
lines of input to contain "x". I can redirect,

1422
00:50:58,250 --> 00:51:00,170
tell the shell to redirect its input

1423
00:51:00,170 --> 00:51:01,600
from the file "out".

1424
00:51:01,700 --> 00:51:03,170
In order to look for instances of

1425
00:51:03,170 --> 00:51:06,020
acts that saved ls output.

1426
00:51:07,150 --> 00:51:10,210
It turns out there's three files whose

1427
00:51:10,210 --> 00:51:12,080
names contain "x".

1428
00:51:13,000 --> 00:51:13,520
Yeah.

1429
00:51:14,000 --> 00:51:14,960
Um,

1430
00:51:15,560 --> 00:51:16,430
we're going to spend a bunch of

1431
00:51:16,430 --> 00:51:17,450
time with the shell,

1432
00:51:17,450 --> 00:51:18,590
um,

1433
00:51:18,590 --> 00:51:19,040
uh,

1434
00:51:19,040 --> 00:51:21,860
its shell is sort of the most

1435
00:51:21,860 --> 00:51:26,540
traditional and fundamental interface units,

1436
00:51:26,540 --> 00:51:29,180
because when unix was first developed, all

1437
00:51:29,180 --> 00:51:30,860
there was was simple terminal interfaces,

1438
00:51:30,860 --> 00:51:32,930
like the one we're using and

1439
00:51:32,930 --> 00:51:35,450
the main use of units originally was

1440
00:51:35,450 --> 00:51:37,370
time sharing a bunch of people logging

1441
00:51:37,370 --> 00:51:38,540
into the same machine,

1442
00:51:38,540 --> 00:51:41,960
much like Athena and talking to shells.

1443
00:51:43,300 --> 00:51:47,860
A question about system calls and the compiler,

1444
00:51:47,860 --> 00:51:49,300
how does the compiler handles system

1445
00:51:49,300 --> 00:51:51,310
calls does assembly generated make a

1446
00:51:51,310 --> 00:51:53,620
procedure call to some code segment

1447
00:51:53,620 --> 00:51:55,480
defined by the operating system.

1448
00:51:57,020 --> 00:51:57,320
Um,

1449
00:51:57,320 --> 00:51:59,960
there's a special RISC-V instruction that

1450
00:51:59,960 --> 00:52:02,060
a program can call that transfers control

1451
00:52:02,060 --> 00:52:02,840
under the kernel,

1452
00:52:02,840 --> 00:52:05,360
so indeed when you write C code

1453
00:52:05,360 --> 00:52:07,550
that makes the system called open write,

1454
00:52:07,550 --> 00:52:08,360
um.

1455
00:52:08,600 --> 00:52:10,520
And technically what actually happens is

1456
00:52:10,520 --> 00:52:12,950
open is a C function in

1457
00:52:12,950 --> 00:52:14,500
the C library.

1458
00:52:14,620 --> 00:52:15,220
Um,

1459
00:52:15,220 --> 00:52:17,860
but the instructions in that function are

1460
00:52:17,860 --> 00:52:19,630
really machine instructions,

1461
00:52:19,630 --> 00:52:21,360
it's not open.

1462
00:52:21,820 --> 00:52:23,470
The open function that we're calling isn't

1463
00:52:23,470 --> 00:52:26,820
a C function implemented in assembler and,

1464
00:52:26,950 --> 00:52:28,630
the assembly code,

1465
00:52:28,630 --> 00:52:29,540
um,

1466
00:52:30,290 --> 00:52:32,300
consists of this special instructions

1467
00:52:32,300 --> 00:52:34,060
actually called ecall.

1468
00:52:34,140 --> 00:52:35,910
On RISC-V the special instruction

1469
00:52:35,910 --> 00:52:37,440
that transfers control

1470
00:52:37,580 --> 00:52:38,900
into the kernel,

1471
00:52:38,900 --> 00:52:40,520
and then the kernel looks at

1472
00:52:40,520 --> 00:52:42,380
the processes memory and registers to

1473
00:52:42,380 --> 00:52:43,700
figure out what the

1474
00:52:44,260 --> 00:52:45,160
arguments were.

1475
00:52:50,610 --> 00:52:53,610
All right, the next example I want

1476
00:52:53,610 --> 00:52:55,800
to look at is example program

1477
00:52:55,800 --> 00:52:58,180
that calls 'fork'.

1478
00:52:58,420 --> 00:53:00,220
Creating process,

1479
00:53:00,220 --> 00:53:01,450
um,

1480
00:53:01,450 --> 00:53:02,720
so this is the

1481
00:53:03,430 --> 00:53:04,780
very simple use of fork at

1482
00:53:04,780 --> 00:53:07,270
line 12, we're calling fork and

1483
00:53:07,270 --> 00:53:08,420
what fork does is

1484
00:53:08,670 --> 00:53:11,460
creates a copy of the memory of

1485
00:53:11,460 --> 00:53:14,490
instructions and data of the calling process,

1486
00:53:14,490 --> 00:53:17,720
now we have two processes with identical memory.

1487
00:53:18,010 --> 00:53:20,200
Fork, the fork system call returns

1488
00:53:20,200 --> 00:53:22,080
in both processes.

1489
00:53:22,360 --> 00:53:24,430
In the original process,

1490
00:53:24,430 --> 00:53:26,710
the fork system call returns the process

1491
00:53:26,710 --> 00:53:28,800
id which is, um

1492
00:53:29,080 --> 00:53:31,480
an integer greater than 0.

1493
00:53:32,100 --> 00:53:33,900
The original process for returns,

1494
00:53:33,900 --> 00:53:35,610
the process id of the newly created

1495
00:53:35,610 --> 00:53:38,580
process and in the newly created process

1496
00:53:38,580 --> 00:53:40,960
fork returns 0.

1497
00:53:41,630 --> 00:53:42,920
So we sort of break even though

1498
00:53:42,920 --> 00:53:45,230
the processes have identical memory,

1499
00:53:45,230 --> 00:53:47,720
you can break the symmetry of

1500
00:53:47,720 --> 00:53:49,310
old versus new process by the

1501
00:53:49,310 --> 00:53:50,800
return value from fork.

1502
00:53:50,940 --> 00:53:53,790
And in line 16 you can see code,

1503
00:53:53,790 --> 00:53:54,930
the checks and says if the

1504
00:53:54,930 --> 00:53:56,310
process id is equal 0 must

1505
00:53:56,310 --> 00:53:57,180
be the child,

1506
00:53:57,180 --> 00:53:59,100
you must now be running in the child.

1507
00:53:59,420 --> 00:54:00,530
Um,

1508
00:54:00,530 --> 00:54:01,850
of course there's two processes in

1509
00:54:01,850 --> 00:54:03,260
the other process,

1510
00:54:03,260 --> 00:54:04,970
um in the calling process which is

1511
00:54:04,970 --> 00:54:07,220
usually called the parent process id is

1512
00:54:07,220 --> 00:54:08,560
greater than 0.

1513
00:54:08,640 --> 00:54:09,360
Um,

1514
00:54:09,360 --> 00:54:11,520
so the child will print "child" and

1515
00:54:11,520 --> 00:54:13,500
the parent will print "parent".

1516
00:54:14,350 --> 00:54:18,540
And then they'll both exit. So when I run fork,

1517
00:54:19,380 --> 00:54:24,860
now here we get, so it may look like garbage.

1518
00:54:25,230 --> 00:54:27,630
What's actually happening is that after the fork,

1519
00:54:27,630 --> 00:54:29,340
both of these processes are running they're

1520
00:54:29,340 --> 00:54:31,800
both running at the same time and

1521
00:54:31,800 --> 00:54:35,540
QEMU is actually emulating a multi-core,

1522
00:54:35,750 --> 00:54:36,890
microprocessor for me,

1523
00:54:36,890 --> 00:54:39,380
so they really are running at

1524
00:54:39,380 --> 00:54:40,280
the very same time,

1525
00:54:40,280 --> 00:54:41,820
so when they produce output.

1526
00:54:41,850 --> 00:54:43,200
They're producing each byte of their

1527
00:54:43,200 --> 00:54:44,460
output at the same time as

1528
00:54:44,460 --> 00:54:45,840
the other process is producing the

1529
00:54:45,840 --> 00:54:47,670
corresponding bytes of its output,

1530
00:54:47,670 --> 00:54:50,360
so the output of the two processes are

1531
00:54:50,820 --> 00:54:52,260
inter league,

1532
00:54:52,260 --> 00:54:52,470
um,

1533
00:54:52,470 --> 00:54:54,540
you can see that they're both typing "f".

1534
00:54:54,800 --> 00:54:57,380
Um, they're both gonna type fork return.

1535
00:54:57,800 --> 00:54:58,250
Um,

1536
00:54:58,250 --> 00:54:59,030
so you can see the "f"

1537
00:54:59,030 --> 00:54:59,960
from both of them, in the

1538
00:54:59,960 --> 00:55:00,890
"o" both of them and the

1539
00:55:00,890 --> 00:55:02,500
"r" both and so on.

1540
00:55:02,920 --> 00:55:04,080
Um, one of them.

1541
00:55:04,700 --> 00:55:05,120
Um,

1542
00:55:05,120 --> 00:55:06,200
you can see the 0 at the

1543
00:55:06,200 --> 00:55:08,060
end of that 1 line is in

1544
00:55:08,060 --> 00:55:10,040
the child fork return 0.

1545
00:55:10,100 --> 00:55:10,790
Um,

1546
00:55:10,790 --> 00:55:14,760
I'm guessing that the parent fork return 19.

1547
00:55:14,960 --> 00:55:16,850
That is the child's process id is

1548
00:55:16,850 --> 00:55:19,400
19, under xv6 that basically means the

1549
00:55:19,400 --> 00:55:22,500
19 process that was created since boot.

1550
00:55:22,860 --> 00:55:23,100
Um,

1551
00:55:23,100 --> 00:55:25,890
and then one of them prints "child"

1552
00:55:25,890 --> 00:55:26,880
and you can see the "c" "h"

1553
00:55:26,880 --> 00:55:28,800
"i" "l" "d" interleave with that is

1554
00:55:28,800 --> 00:55:30,480
the other one prepare.

1555
00:55:30,670 --> 00:55:31,510
So,

1556
00:55:31,510 --> 00:55:32,580
yeah.

1557
00:55:32,930 --> 00:55:34,550
This is a silly use of fork,

1558
00:55:34,550 --> 00:55:36,650
but we can see vividly in

1559
00:55:36,650 --> 00:55:38,330
this output that has created two

1560
00:55:38,330 --> 00:55:39,640
processes that are,

1561
00:55:39,920 --> 00:55:41,780
and both of them are running for

1562
00:55:41,780 --> 00:55:43,880
returning both processes and they're both running.

1563
00:55:44,710 --> 00:55:46,750
But also note that one printed child

1564
00:55:46,750 --> 00:55:49,540
and the other parent so it's important

1565
00:55:49,540 --> 00:55:51,480
that fork returns differently

1566
00:55:51,770 --> 00:55:52,070
Um,

1567
00:55:52,070 --> 00:55:53,840
and the two processes.

1568
00:55:59,680 --> 00:56:01,390
Question, um,

1569
00:56:01,390 --> 00:56:03,070
is the child process as a result of

1570
00:56:03,070 --> 00:56:05,290
fork always identical to the parent process

1571
00:56:05,290 --> 00:56:06,740
or could they be different.

1572
00:56:08,250 --> 00:56:13,560
Um, in xv6 are identical.

1573
00:56:13,740 --> 00:56:14,490
Um,

1574
00:56:14,490 --> 00:56:17,120
except the return value from fork.

1575
00:56:17,260 --> 00:56:18,880
You know the instructions are the same

1576
00:56:18,880 --> 00:56:19,960
that data is the same,

1577
00:56:19,960 --> 00:56:22,090
the stack is the same,

1578
00:56:22,090 --> 00:56:23,960
um, also both.

1579
00:56:24,140 --> 00:56:25,490
Processes,

1580
00:56:25,490 --> 00:56:28,700
the processor copies and they both have

1581
00:56:28,700 --> 00:56:30,080
their own separate

1582
00:56:30,160 --> 00:56:32,590
address spaces that is they both

1583
00:56:32,590 --> 00:56:34,390
have they both think that their

1584
00:56:34,390 --> 00:56:35,890
memory starts at 0 and goes

1585
00:56:35,890 --> 00:56:37,160
on up from there.

1586
00:56:37,400 --> 00:56:38,150
Um,

1587
00:56:38,150 --> 00:56:42,240
but it's different it's different different memory.

1588
00:56:42,340 --> 00:56:42,820
Um,

1589
00:56:42,820 --> 00:56:43,960
with the two of them.

1590
00:56:45,030 --> 00:56:46,680
In a more sophisticated operating system,

1591
00:56:46,680 --> 00:56:49,260
there are some details which we definitely

1592
00:56:49,260 --> 00:56:51,060
don't care about them,

1593
00:56:51,060 --> 00:56:53,790
they may occasionally cause parent and child

1594
00:56:53,790 --> 00:56:55,020
to differ, but in xv6

1595
00:56:55,020 --> 00:56:57,020
they're the same except the return value.

1596
00:56:57,880 --> 00:56:58,360
Um,

1597
00:56:58,360 --> 00:56:59,410
so the memory is the same,

1598
00:56:59,410 --> 00:57:01,100
in addition the, um,

1599
00:57:02,010 --> 00:57:04,800
file descriptor table is copied.

1600
00:57:05,260 --> 00:57:08,920
So if the parent had some files open.

1601
00:57:09,140 --> 00:57:09,740
Um,

1602
00:57:09,740 --> 00:57:11,870
and the child sees the same set

1603
00:57:11,870 --> 00:57:13,580
of file descriptors.

1604
00:57:13,800 --> 00:57:14,190
Um,

1605
00:57:14,190 --> 00:57:17,060
although the child is seeing them in a copy.

1606
00:57:17,180 --> 00:57:20,780
Of the table of file descriptor information.

1607
00:57:21,550 --> 00:57:22,600
And so we'll see in a moment

1608
00:57:22,600 --> 00:57:25,210
that it's quite important that a fork

1609
00:57:25,210 --> 00:57:28,180
copies the table of open file descriptors

1610
00:57:28,180 --> 00:57:29,420
as well as the memory.

1611
00:57:31,340 --> 00:57:32,420
Okay so.

1612
00:57:33,360 --> 00:57:34,980
A fork creates a new process,

1613
00:57:34,980 --> 00:57:37,680
but when we run stuff in the shell,

1614
00:57:37,680 --> 00:57:38,800
um.

1615
00:57:39,030 --> 00:57:40,950
The shell indeed creates a new process

1616
00:57:40,950 --> 00:57:43,260
to run each command that you type.

1617
00:57:43,320 --> 00:57:43,590
Um,

1618
00:57:43,590 --> 00:57:45,330
but it needs to actually run the command in it,

1619
00:57:45,330 --> 00:57:47,160
so if I type ls,

1620
00:57:47,160 --> 00:57:49,590
we need to shell forks to create

1621
00:57:49,590 --> 00:57:50,790
a process to run ls,

1622
00:57:50,790 --> 00:57:52,860
but there needs to be some way.

1623
00:57:53,740 --> 00:57:55,930
For that new process actually run the

1624
00:57:55,930 --> 00:57:58,200
instructions from the ls program.

1625
00:57:58,510 --> 00:58:00,460
Below those instructions from the file called

1626
00:58:00,460 --> 00:58:03,610
ls and the example program,

1627
00:58:03,610 --> 00:58:05,180
I'm gonna show you in a minute.

1628
00:58:05,320 --> 00:58:06,940
Um, uses echo, echo is a very

1629
00:58:06,940 --> 00:58:10,330
simple command a just takes whatever arguments

1630
00:58:10,330 --> 00:58:11,920
you pass to it and writes them

1631
00:58:11,920 --> 00:58:12,860
to its output.

1632
00:58:13,860 --> 00:58:17,060
And I prepared for you a program called 'exec'.

1633
00:58:17,470 --> 00:58:17,920
Um,

1634
00:58:21,300 --> 00:58:22,320
um.

1635
00:58:22,880 --> 00:58:26,020
Which a run which

1636
00:58:26,830 --> 00:58:29,590
makes the exec system call which replaces

1637
00:58:29,590 --> 00:58:32,650
the calling process with the instructions read

1638
00:58:32,650 --> 00:58:34,390
from a particular file

1639
00:58:34,390 --> 00:58:36,720
you specify.

1640
00:58:37,110 --> 00:58:39,510
Loads the instructions from that file over

1641
00:58:39,510 --> 00:58:42,240
the current process or discarding its current

1642
00:58:42,240 --> 00:58:45,600
memory and then starts executing those instructions,

1643
00:58:45,600 --> 00:58:48,270
so the call to exec system call

1644
00:58:48,270 --> 00:58:50,920
exec on line 12.

1645
00:58:52,620 --> 00:58:53,940
It's going to have the effect of

1646
00:58:53,940 --> 00:58:55,980
the operating system loading the instructions from

1647
00:58:55,980 --> 00:58:57,900
the file called echo.

1648
00:58:57,980 --> 00:59:00,860
In the current process sort of replacing

1649
00:59:00,860 --> 00:59:03,140
the memory of the current process and

1650
00:59:03,140 --> 00:59:04,940
then starting to execute.

1651
00:59:05,260 --> 00:59:05,410
Um,

1652
00:59:05,410 --> 00:59:07,330
those instructions and in addition,

1653
00:59:07,330 --> 00:59:09,550
you can pass arguments command line arguments

1654
00:59:09,550 --> 00:59:12,160
echo exec allows you to pass an

1655
00:59:12,160 --> 00:59:14,220
array of command line arguments.

1656
00:59:14,670 --> 00:59:15,540
It was just an array of

1657
00:59:15,540 --> 00:59:18,360
pointers in C line 10 sets

1658
00:59:18,360 --> 00:59:19,780
up an array of

1659
00:59:19,810 --> 00:59:23,050
character pointers which are essentially strings and

1660
00:59:23,050 --> 00:59:24,900
initialize that array to be,

1661
00:59:25,040 --> 00:59:29,420
to contain the strings echo, this is echo, um.

1662
00:59:29,480 --> 00:59:32,090
And that's equivalent to calling running echo

1663
00:59:32,090 --> 00:59:33,140
with them and with

1664
00:59:33,360 --> 00:59:34,170
the three arguments.

1665
00:59:34,170 --> 00:59:36,960
This is echo and so when I want exec.

1666
00:59:38,200 --> 00:59:38,890
Um,

1667
00:59:38,890 --> 00:59:40,120
indeed,

1668
00:59:40,120 --> 00:59:41,380
um I see this output,

1669
00:59:41,380 --> 00:59:41,980
this is echo,

1670
00:59:41,980 --> 00:59:43,690
but even though I ran the exec

1671
00:59:43,690 --> 00:59:45,920
command exec program.

1672
00:59:45,980 --> 00:59:48,080
What the exec program does is calling

1673
00:59:48,080 --> 00:59:50,270
the exec system call to replace itself

1674
00:59:50,270 --> 00:59:51,680
with echo and so it was really

1675
00:59:51,680 --> 00:59:53,220
the echo program.

1676
00:59:53,320 --> 00:59:55,260
I'm producing this output.

1677
00:59:58,600 --> 01:00:01,360
And something about the exec system call,

1678
01:00:01,360 --> 01:00:03,280
that's important for us is that

1679
01:00:03,280 --> 01:00:06,310
it exec preserves the current

1680
01:00:06,310 --> 01:00:08,380
table of file descriptors,

1681
01:00:08,380 --> 01:00:10,810
so whatever file descriptor 0 1 2

1682
01:00:10,810 --> 01:00:13,240
etc, were referred to before exec,

1683
01:00:13,240 --> 01:00:17,420
they refer to the same thing in this new program

1684
01:00:17,670 --> 01:00:19,280
whose instructions we've loaded.

1685
01:00:20,220 --> 01:00:22,470
Another point is that ordinarily exec does

1686
01:00:22,470 --> 01:00:25,780
not return because exec replaces

1687
01:00:26,040 --> 01:00:28,530
the current processes memory entirely,

1688
01:00:28,530 --> 01:00:29,250
um,

1689
01:00:29,250 --> 01:00:31,170
there's nothing for exec to return to

1690
01:00:31,170 --> 01:00:32,620
exec you know.

1691
01:00:32,990 --> 01:00:34,730
Read the instructions for that file and

1692
01:00:34,730 --> 01:00:36,410
execute them and then that's it,

1693
01:00:36,410 --> 01:00:38,030
um, the only time exec turns

1694
01:00:38,030 --> 01:00:40,730
is if some error occurred that

1695
01:00:40,730 --> 01:00:42,620
prevented the operating system from running

1696
01:00:42,620 --> 01:00:43,940
that program for you,

1697
01:00:43,940 --> 01:00:45,770
so for example if the program doesn't

1698
01:00:45,770 --> 01:00:47,100
exist at all.

1699
01:00:48,080 --> 01:00:50,540
Exec can't find a file called echo,

1700
01:00:50,540 --> 01:00:54,060
for example an exec would return -1.

1701
01:00:54,220 --> 01:00:55,080
Um,

1702
01:00:55,520 --> 01:00:58,670
Signal that something wrong it couldn't

1703
01:00:58,670 --> 01:00:59,960
couldn't find the file so ordinarily

1704
01:00:59,960 --> 01:01:01,460
exec does not return.

1705
01:01:01,520 --> 01:01:05,100
It only returns if the kernel

1706
01:01:05,220 --> 01:01:06,980
couldn't actually run the file for you.

1707
01:01:10,430 --> 01:01:11,740
Questions about exec.

1708
01:01:12,620 --> 01:01:13,640
The question in the chat is

1709
01:01:13,640 --> 01:01:15,320
what is the last 0 for

1710
01:01:15,320 --> 01:01:16,360
in argv.

1711
01:01:18,850 --> 01:01:21,940
It marks the end of the array

1712
01:01:21,940 --> 01:01:24,720
C is so low level that,

1713
01:01:25,000 --> 01:01:25,900
um,

1714
01:01:25,900 --> 01:01:27,280
there's no

1715
01:01:27,670 --> 01:01:30,760
the C array scheme.

1716
01:01:32,340 --> 01:01:33,960
Doesn't have a way for

1717
01:01:34,650 --> 01:01:35,850
code to find out how long

1718
01:01:35,850 --> 01:01:37,830
the array is and so

1719
01:01:37,830 --> 01:01:39,400
tell the kernel that,

1720
01:01:39,570 --> 01:01:40,560
um,

1721
01:01:40,970 --> 01:01:43,490
you know we met at the array contains echo,

1722
01:01:43,490 --> 01:01:46,300
this is echo and nothing more.

1723
01:01:46,560 --> 01:01:49,940
We put zero was the last strip as the last

1724
01:01:50,030 --> 01:01:50,990
pointer.

1725
01:01:50,990 --> 01:01:52,670
Each of those strings in double quotes

1726
01:01:52,670 --> 01:01:54,920
is actually a pointer to some memory

1727
01:01:54,920 --> 01:01:56,440
that contains those bytes.

1728
01:01:56,720 --> 01:01:58,760
That fifth element of the array is

1729
01:01:58,760 --> 01:02:00,500
a pointer's value is 0,

1730
01:02:00,500 --> 01:02:02,270
the convention is that a pointer

1731
01:02:02,270 --> 01:02:04,010
whose value is 0 or what's

1732
01:02:04,010 --> 01:02:05,500
called a null pointer.

1733
01:02:05,590 --> 01:02:06,520
Um,

1734
01:02:07,050 --> 01:02:09,600
sort of signifies nothing,

1735
01:02:09,600 --> 01:02:10,980
Um, with it.

1736
01:02:11,620 --> 01:02:13,600
You were gone,

1737
01:02:13,600 --> 01:02:14,920
so the code in the kernel

1738
01:02:14,920 --> 01:02:16,570
has actually walks through this array

1739
01:02:16,570 --> 01:02:17,680
until it finds it.

1740
01:02:18,090 --> 01:02:20,240
Element whose value is zero.

1741
01:02:24,690 --> 01:02:25,740
Okay,

1742
01:02:25,740 --> 01:02:26,520
um,

1743
01:02:26,520 --> 01:02:27,420
all right,

1744
01:02:27,420 --> 01:02:29,780
so this is how a program can replace itself.

1745
01:02:30,800 --> 01:02:32,090
With another program from a file,

1746
01:02:32,090 --> 01:02:33,350
but actually when we run stuff in

1747
01:02:33,350 --> 01:02:35,510
the shell like 'echo abc',

1748
01:02:35,510 --> 01:02:38,900
um or ls or anything else,

1749
01:02:38,900 --> 01:02:40,400
we don't want to replace the shell,

1750
01:02:40,400 --> 01:02:41,570
we don't have a shell,

1751
01:02:41,570 --> 01:02:43,000
just call exec.

1752
01:02:43,420 --> 01:02:44,500
Um, because,

1753
01:02:44,500 --> 01:02:45,850
that would replace the shell with the

1754
01:02:45,850 --> 01:02:48,240
echo command then echo exited.

1755
01:02:48,320 --> 01:02:50,360
That would be end, you know

1756
01:02:50,360 --> 01:02:51,110
we don't want an echo to

1757
01:02:51,110 --> 01:02:52,040
replace the shell,

1758
01:02:52,040 --> 01:02:54,660
so the shell actually does is fork.

1759
01:02:54,940 --> 01:02:56,740
And then the child calls exec

1760
01:02:56,740 --> 01:02:59,440
and that's an extremely common unix

1761
01:02:59,440 --> 01:03:01,540
idiom program instead.

1762
01:03:01,600 --> 01:03:03,520
Um, want to run a program,

1763
01:03:03,520 --> 01:03:05,020
but regain control what they do

1764
01:03:05,020 --> 01:03:06,460
is call fork and have the

1765
01:03:06,460 --> 01:03:07,880
child called exec.

1766
01:03:08,000 --> 01:03:10,520
So here's a simple example,

1767
01:03:10,520 --> 01:03:12,400
this forkexec program.

1768
01:03:14,310 --> 01:03:17,580
In this program call fork line 12

1769
01:03:17,580 --> 01:03:19,350
in the child sort of line 14

1770
01:03:19,350 --> 01:03:21,330
we call exec much like before.

1771
01:03:21,330 --> 01:03:22,940
The child process,

1772
01:03:23,380 --> 01:03:28,060
um, has to replace itself with the echo command.

1773
01:03:28,220 --> 01:03:29,090
Um, echo,

1774
01:03:29,090 --> 01:03:31,220
does this thing and then exits.

1775
01:03:31,680 --> 01:03:32,760
And then the parent process,

1776
01:03:32,760 --> 01:03:37,360
regains control because um when fork returns.

1777
01:03:38,000 --> 01:03:39,860
Greater than zero value in the parent process,

1778
01:03:39,860 --> 01:03:41,330
so the parent process then continues to

1779
01:03:41,330 --> 01:03:43,760
execute at 19 and unix provides a

1780
01:03:43,760 --> 01:03:47,390
wait system call line 24 process to

1781
01:03:47,390 --> 01:03:50,180
wait for child that created

1782
01:03:50,180 --> 01:03:52,310
with fork, because when I run a

1783
01:03:52,310 --> 01:03:55,600
command on the command line.

1784
01:03:56,330 --> 01:04:00,020
We want shell to wait for the

1785
01:04:00,020 --> 01:04:02,210
command to finish before it prints the

1786
01:04:02,210 --> 01:04:04,310
prompt again, before it prints is $

1787
01:04:04,310 --> 01:04:06,620
prompt asking me for more input.

1788
01:04:06,730 --> 01:04:09,190
So it's the wait system call allows

1789
01:04:09,190 --> 01:04:10,720
a process to wait for any of

1790
01:04:10,720 --> 01:04:13,390
its children to return and this status

1791
01:04:13,390 --> 01:04:15,400
argument is that, um,

1792
01:04:15,590 --> 01:04:17,080
a way for

1793
01:04:17,950 --> 01:04:22,450
exiting child to communicate one integer

1794
01:04:22,450 --> 01:04:25,900
32 bit value from the exiting child

1795
01:04:25,900 --> 01:04:28,330
to the waiting parents on line 17 that

1796
01:04:28,330 --> 01:04:30,700
argument to exit that 1 that's the

1797
01:04:30,700 --> 01:04:32,000
argument to exit.

1798
01:04:32,060 --> 01:04:35,750
The operating system passes that one from

1799
01:04:35,750 --> 01:04:37,340
the exiting child

1800
01:04:37,460 --> 01:04:39,200
to the call to wait line

1801
01:04:39,200 --> 01:04:42,460
20 so wait the & wait,

1802
01:04:42,700 --> 01:04:44,350
is passing the address of the

1803
01:04:44,350 --> 01:04:46,720
status variable to the kernel,

1804
01:04:46,720 --> 01:04:49,400
the kernel fills in that address with,

1805
01:04:49,720 --> 01:04:51,800
um, child's argument to exit.

1806
01:04:52,770 --> 01:04:54,690
And the convention in unix is that

1807
01:04:54,690 --> 01:04:58,560
if a program completes successfully exit exits

1808
01:04:58,560 --> 01:05:00,120
with status 0.

1809
01:05:00,430 --> 01:05:00,610
Um,

1810
01:05:00,610 --> 01:05:04,200
but it has encountered an error at line 17.

1811
01:05:04,280 --> 01:05:06,800
Um, the unix convention is that you

1812
01:05:06,800 --> 01:05:08,810
pass 1 to exit and so if

1813
01:05:08,810 --> 01:05:10,940
you care the calling process can look

1814
01:05:10,940 --> 01:05:13,180
at the status from wait.

1815
01:05:13,240 --> 01:05:14,700
Decide whether the

1816
01:05:15,270 --> 01:05:19,080
child completed successfully. A professor

1817
01:05:19,080 --> 01:05:20,400
Morris quick question.

1818
01:05:20,560 --> 01:05:21,280
Yes,

1819
01:05:21,280 --> 01:05:25,090
about the exec call 19, um,

1820
01:05:25,090 --> 01:05:27,280
we mentioned not a bit ago that

1821
01:05:27,280 --> 01:05:29,890
exec will completely go into the echo

1822
01:05:29,890 --> 01:05:32,660
program and not return to fork exec.

1823
01:05:33,060 --> 01:05:33,390
Um,

1824
01:05:33,390 --> 01:05:33,930
so,

1825
01:05:33,930 --> 01:05:34,380
oh,

1826
01:05:34,380 --> 01:05:37,260
would ever reach line 16 and 17.

1827
01:05:38,170 --> 01:05:38,960
Well,

1828
01:05:39,720 --> 01:05:41,490
not for this exec code because there

1829
01:05:41,490 --> 01:05:44,130
happens to be a program called echo,

1830
01:05:44,130 --> 01:05:46,560
but if I modify that code here,

1831
01:05:46,560 --> 01:05:49,470
let me just modify this code.

1832
01:05:49,470 --> 01:05:50,550
Okay, so first let me just

1833
01:05:50,550 --> 01:05:51,820
run forkexec.

1834
01:05:53,590 --> 01:05:56,290
It actually does execute echo with those

1835
01:05:56,290 --> 01:05:57,580
arguments we see the output,

1836
01:05:57,580 --> 01:05:59,650
"this is echo" and we see

1837
01:05:59,650 --> 01:06:02,280
the child exited to show that

1838
01:06:02,900 --> 01:06:05,840
echo exited successfully and the parent wait

1839
01:06:05,840 --> 01:06:07,180
for. Let me just

1840
01:06:07,370 --> 01:06:09,080
modify the program for you.

1841
01:06:09,630 --> 01:06:09,900
Um,

1842
01:06:09,900 --> 01:06:12,150
instead of echo going to run some

1843
01:06:12,150 --> 01:06:13,580
command that doesn't exist.

1844
01:06:14,180 --> 01:06:14,940
Um,

1845
01:06:15,360 --> 01:06:15,660
um,

1846
01:06:15,660 --> 01:06:18,240
actually the exit out of

1847
01:06:18,240 --> 01:06:19,160
QEMU.

1848
01:06:19,240 --> 01:06:21,520
With 'Ctrl-a x' and then rebuild

1849
01:06:21,520 --> 01:06:23,700
the whole thing in order to re-compile

1850
01:06:23,920 --> 01:06:25,380
I modified.

1851
01:06:25,850 --> 01:06:27,650
Forkexec now run forkexec back again

1852
01:06:27,650 --> 01:06:29,500
after modifying it.

1853
01:06:29,800 --> 01:06:31,060
And this time because the program

1854
01:06:31,060 --> 01:06:32,280
we're asking to,

1855
01:06:32,760 --> 01:06:34,220
um, actually,

1856
01:06:36,600 --> 01:06:37,080
the program,

1857
01:06:37,080 --> 01:06:39,600
we're asking to execute doesn't exist,

1858
01:06:39,600 --> 01:06:43,560
exec does return we see the exec failed output.

1859
01:06:43,840 --> 01:06:44,470
Um,

1860
01:06:44,470 --> 01:06:46,180
and the exit 1 you'll see

1861
01:06:46,180 --> 01:06:47,770
the 1 there is communicated back

1862
01:06:47,770 --> 01:06:48,880
to the parent which says the

1863
01:06:48,880 --> 01:06:50,760
child exited the status 1.

1864
01:06:52,280 --> 01:06:55,610
So exec returns back to the calling

1865
01:06:55,610 --> 01:06:57,680
function when something went wrong.

1866
01:06:57,740 --> 01:06:58,520
Yes.

1867
01:07:01,180 --> 01:07:01,700
Yeah.

1868
01:07:08,700 --> 01:07:11,040
Okay good.

1869
01:07:14,680 --> 01:07:15,220
All right,

1870
01:07:15,220 --> 01:07:17,710
um, something that going to note

1871
01:07:17,710 --> 01:07:19,540
here that actually think many of you

1872
01:07:19,540 --> 01:07:21,240
already noted is that.

1873
01:07:21,300 --> 01:07:23,430
It is a common idiom here,

1874
01:07:23,430 --> 01:07:25,440
this fork followed by exec in the

1875
01:07:25,440 --> 01:07:28,710
child and it's potentially a bit wasteful

1876
01:07:28,710 --> 01:07:32,080
the fork copies the entire parent process.

1877
01:07:32,320 --> 01:07:34,840
But exec throws away all that copied

1878
01:07:34,840 --> 01:07:36,910
memory and replaces it with,

1879
01:07:36,910 --> 01:07:38,860
whatever is in the, um,

1880
01:07:39,670 --> 01:07:40,990
a file that you're running,

1881
01:07:40,990 --> 01:07:43,630
so you know if you're worried about

1882
01:07:43,630 --> 01:07:44,320
this kind of stuff,

1883
01:07:44,320 --> 01:07:47,580
the copy implied by the fork.

1884
01:07:48,160 --> 01:07:50,380
Is in some sense mostly wasted because

1885
01:07:50,380 --> 01:07:52,210
all that copied memory is just thrown

1886
01:07:52,210 --> 01:07:54,320
away and replaced by the exec.

1887
01:07:55,270 --> 01:07:57,220
And this affects actually would be significant

1888
01:07:57,220 --> 01:07:57,940
for big programs,

1889
01:07:57,940 --> 01:07:59,830
if you have a multi gigabyte program

1890
01:07:59,830 --> 01:08:01,000
that calls fork.

1891
01:08:01,050 --> 01:08:01,470
Um,

1892
01:08:01,470 --> 01:08:02,880
and it did indeed copy all

1893
01:08:02,880 --> 01:08:04,380
the memory would actually take a

1894
01:08:04,380 --> 01:08:06,510
fair fraction of a second perhaps

1895
01:08:06,510 --> 01:08:07,620
to do the copy.

1896
01:08:07,740 --> 01:08:08,280
Um,

1897
01:08:08,280 --> 01:08:09,560
which could be a problem.

1898
01:08:10,080 --> 01:08:10,900
Um,

1899
01:08:12,520 --> 01:08:13,180
um,

1900
01:08:13,180 --> 01:08:15,850
but later in the course you'll actually

1901
01:08:15,850 --> 01:08:18,370
implement some optimization in particular something called

1902
01:08:18,370 --> 01:08:21,610
copy-on-write fork which will eliminate

1903
01:08:21,610 --> 01:08:25,360
almost all of the apparent inefficiency

1904
01:08:25,360 --> 01:08:27,820
of fork copying only to have exec

1905
01:08:27,820 --> 01:08:29,120
throw away the copy.

1906
01:08:29,180 --> 01:08:30,080
It turns out with a bunch of

1907
01:08:30,080 --> 01:08:32,760
tricks involving a virtual memory system.

1908
01:08:32,920 --> 01:08:33,880
Um,

1909
01:08:33,880 --> 01:08:35,050
you can build a fork,

1910
01:08:35,050 --> 01:08:37,150
that's lazy about the copy and that

1911
01:08:37,150 --> 01:08:39,520
doesn't do in the common case of

1912
01:08:39,520 --> 01:08:41,320
fork immediately followed by exec.

1913
01:08:41,420 --> 01:08:41,660
Um,

1914
01:08:41,660 --> 01:08:42,800
or you don't actually have to do

1915
01:08:42,800 --> 01:08:44,630
the copy because the child doesn't actually

1916
01:08:44,630 --> 01:08:46,060
use most of the memory.

1917
01:08:46,900 --> 01:08:47,600
Um,

1918
01:08:48,100 --> 01:08:49,510
I think you'll find that's a fun

1919
01:08:49,510 --> 01:08:52,510
and interesting lab. Question from chat,

1920
01:08:52,510 --> 01:08:55,360
why does the parent process parent waiting

1921
01:08:55,360 --> 01:08:58,140
completely before the child calls exec.

1922
01:08:59,240 --> 01:08:59,840
Yeah.

1923
01:09:00,710 --> 01:09:03,000
It's just chance.

1924
01:09:03,820 --> 01:09:05,980
Um,

1925
01:09:06,940 --> 01:09:09,970
why is it that you know the observation is that,

1926
01:09:09,970 --> 01:09:11,110
um,

1927
01:09:11,110 --> 01:09:12,060
you know.

1928
01:09:13,130 --> 01:09:13,520
Um,

1929
01:09:13,520 --> 01:09:15,290
it could be that the parents output

1930
01:09:15,290 --> 01:09:17,540
could be interleaved with the child's output

1931
01:09:17,540 --> 01:09:18,530
in the same area that we saw

1932
01:09:18,530 --> 01:09:21,410
before with similar fork example,

1933
01:09:21,410 --> 01:09:22,100
um,

1934
01:09:22,100 --> 01:09:23,780
it just happens not to be there's

1935
01:09:23,780 --> 01:09:25,700
no guarantee that this is the output,

1936
01:09:25,700 --> 01:09:27,800
we would see in fact we,

1937
01:09:28,070 --> 01:09:29,690
we shouldn't be surprised if we saw

1938
01:09:29,690 --> 01:09:30,770
the lines of the output in the

1939
01:09:30,770 --> 01:09:33,240
other order or interleaved.

1940
01:09:33,620 --> 01:09:35,960
I suspect what's going on, is

1941
01:09:35,960 --> 01:09:37,940
that it takes a bit of

1942
01:09:37,940 --> 01:09:39,240
time and effort.

1943
01:09:39,770 --> 01:09:41,240
The exec system caused a little bit

1944
01:09:41,240 --> 01:09:43,370
expensive, because it has to load all

1945
01:09:43,370 --> 01:09:45,560
those you have to access the file

1946
01:09:45,560 --> 01:09:47,240
system and access the disk and read

1947
01:09:47,240 --> 01:09:49,010
the contents of a file called echo

1948
01:09:49,010 --> 01:09:51,050
off the disk into memory,

1949
01:09:51,050 --> 01:09:53,330
after allocating some memory and

1950
01:09:53,330 --> 01:09:55,040
that even after freeing some memory

1951
01:09:55,040 --> 01:09:56,870
from the old process so there's

1952
01:09:56,870 --> 01:09:58,220
quite a bit of machinery involved

1953
01:09:58,220 --> 01:09:59,840
in the exec system call,

1954
01:09:59,840 --> 01:10:00,560
um.

1955
01:10:00,860 --> 01:10:03,500
And apparently that takes long enough that

1956
01:10:03,500 --> 01:10:06,500
the parent can complete producing the output.

1957
01:10:06,580 --> 01:10:08,440
Before the exec is finished and

1958
01:10:08,440 --> 01:10:09,680
started running echo.

1959
01:10:10,400 --> 01:10:11,960
Does that make sense.

1960
01:10:15,360 --> 01:10:17,370
Another question is a convention that the

1961
01:10:17,370 --> 01:10:19,560
child can't wait for the parent.

1962
01:10:21,520 --> 01:10:25,420
There's not a way unix doesn't have

1963
01:10:25,420 --> 01:10:27,160
a way for the child.

1964
01:10:28,220 --> 01:10:30,290
There's no straightforward way for a child to wait

1965
01:10:30,290 --> 01:10:31,140
from a parent.

1966
01:10:31,930 --> 01:10:33,860
The wait system call.

1967
01:10:34,680 --> 01:10:37,080
Because it's the only mechanism available

1968
01:10:37,080 --> 01:10:40,170
well the wait system call waits

1969
01:10:40,170 --> 01:10:41,420
for your children.

1970
01:10:41,880 --> 01:10:42,700
And that's it.

1971
01:10:43,620 --> 01:10:46,350
And so what wait what wait does is,

1972
01:10:46,350 --> 01:10:47,160
um,

1973
01:10:47,160 --> 01:10:48,980
if you have any children.

1974
01:10:49,080 --> 01:10:52,440
And one of them has already exited what does exit.

1975
01:10:52,740 --> 01:10:54,720
Then we will return but you know

1976
01:10:54,720 --> 01:10:56,070
if you don't have any children say,

1977
01:10:56,070 --> 01:10:57,300
because you are.

1978
01:10:57,360 --> 01:11:00,720
Because in this simple case,

1979
01:11:00,720 --> 01:11:01,660
um.

1980
01:11:02,120 --> 01:11:03,950
It was just a parent and child

1981
01:11:03,950 --> 01:11:05,660
if the child called wait.

1982
01:11:06,890 --> 01:11:08,780
The child doesn't have any children and

1983
01:11:08,780 --> 01:11:09,200
in that case,

1984
01:11:09,200 --> 01:11:11,090
wait just returns immediately with a -1

1985
01:11:11,090 --> 01:11:13,910
error return saying this process doesn't

1986
01:11:13,910 --> 01:11:14,740
have any children.

1987
01:11:15,440 --> 01:11:15,770
Anyway,

1988
01:11:15,770 --> 01:11:17,450
the short answer is there's no way

1989
01:11:17,450 --> 01:11:19,280
for a child to wait for its

1990
01:11:19,280 --> 01:11:20,400
parent to exit.

1991
01:11:21,930 --> 01:11:23,310
And another question when we say

1992
01:11:23,310 --> 01:11:25,770
the child copies all the memory

1993
01:11:25,770 --> 01:11:26,820
from the parent process,

1994
01:11:26,820 --> 01:11:28,980
what exactly do we refer to by

1995
01:11:28,980 --> 01:11:30,870
that I thought the child is going

1996
01:11:30,870 --> 01:11:33,260
to define the variables again.

1997
01:11:37,570 --> 01:11:38,640
Um,

1998
01:11:39,050 --> 01:11:40,250
or when you compile this,

1999
01:11:40,250 --> 01:11:40,880
you know,

2000
01:11:40,880 --> 01:11:41,840
um.

2001
01:11:45,260 --> 01:11:47,060
After compilation,

2002
01:11:47,060 --> 01:11:49,020
your C program.

2003
01:11:49,220 --> 01:11:50,450
It's just a bunch of instructions in

2004
01:11:50,450 --> 01:11:52,720
memory that live in ram.

2005
01:11:53,430 --> 01:11:54,400
Um,

2006
01:11:55,070 --> 01:11:57,000
and so those can be copied.

2007
01:11:57,360 --> 01:11:58,920
Because they're just bytes living in ram,

2008
01:11:58,920 --> 01:12:01,170
those can be copied somewhere else,

2009
01:12:01,170 --> 01:12:02,020
um.

2010
01:12:02,370 --> 01:12:04,380
And with appropriate trick having to do

2011
01:12:04,380 --> 01:12:05,620
with setting up.

2012
01:12:06,500 --> 01:12:08,930
A sort of virtual memory mapping's and

2013
01:12:08,930 --> 01:12:10,970
make map things look the same in

2014
01:12:10,970 --> 01:12:12,110
the child and the parent you can

2015
01:12:12,110 --> 01:12:14,270
just copy the parent's memory image to

2016
01:12:14,270 --> 01:12:15,780
the child and

2017
01:12:16,360 --> 01:12:17,760
executing the child.

2018
01:12:20,660 --> 01:12:22,310
And even though we're looking at C programs,

2019
01:12:22,310 --> 01:12:23,360
you should think of them as just

2020
01:12:23,360 --> 01:12:25,820
a bunch of machine instructions.

2021
01:12:26,920 --> 01:12:27,430
Um,

2022
01:12:27,430 --> 01:12:29,480
which is bytes in memory that can be copied.

2023
01:12:31,280 --> 01:12:32,660
If a parent has multiple

2024
01:12:32,660 --> 01:12:34,460
children would wait just return

2025
01:12:34,460 --> 01:12:35,270
as soon as the first

2026
01:12:35,270 --> 01:12:36,860
child finishes meaning that there

2027
01:12:36,860 --> 01:12:38,300
could be some more interleaving

2028
01:12:38,300 --> 01:12:39,470
with the parent and unfinished

2029
01:12:39,470 --> 01:12:40,850
children with their need to

2030
01:12:40,850 --> 01:12:42,290
be multiple separate ways to

2031
01:12:42,290 --> 01:12:44,100
ensure all children finished.

2032
01:12:44,340 --> 01:12:45,180
Yes,

2033
01:12:45,180 --> 01:12:45,480
yeah,

2034
01:12:45,480 --> 01:12:47,250
if you call fork more than one

2035
01:12:47,250 --> 01:12:50,820
if a given process calls for twice.

2036
01:12:51,360 --> 01:12:52,470
Um,

2037
01:12:52,470 --> 01:12:54,450
then it wants to wait for both

2038
01:12:54,450 --> 01:12:56,850
children and has to call wait twice

2039
01:12:56,850 --> 01:12:58,140
each call to wait.

2040
01:12:58,280 --> 01:13:00,500
Will return as soon as one of

2041
01:13:00,500 --> 01:13:02,450
the children exits you don't when wait

2042
01:13:02,450 --> 01:13:05,210
returns you don't necessarily know which child

2043
01:13:05,210 --> 01:13:08,060
is exited the weight returns the child's

2044
01:13:08,060 --> 01:13:09,920
process id as its return value so

2045
01:13:09,920 --> 01:13:11,060
you can tell.

2046
01:13:11,420 --> 01:13:13,670
After we returns you know which one

2047
01:13:13,670 --> 01:13:14,740
it was at exit.

2048
01:13:19,030 --> 01:13:19,620
Um,

2049
01:13:22,660 --> 01:13:23,980
as a final example,

2050
01:13:23,980 --> 01:13:24,920
um.

2051
01:13:25,640 --> 01:13:27,520
I'd like to show,

2052
01:13:28,080 --> 01:13:28,560
um,

2053
01:13:28,560 --> 01:13:32,520
how all these facilities combine,

2054
01:13:32,520 --> 01:13:33,640
um.

2055
01:13:33,740 --> 01:13:37,460
To implement IO direction,

2056
01:13:37,460 --> 01:13:38,960
so if you remember,

2057
01:13:38,960 --> 01:13:39,320
um,

2058
01:13:39,320 --> 01:13:40,670
the shell provides us with this

2059
01:13:40,670 --> 01:13:43,010
handy syntax I can say

2060
01:13:43,010 --> 01:13:44,500
'echo hello >  out'.

2061
01:13:44,830 --> 01:13:47,080
Um, that runs the echo command that

2062
01:13:47,080 --> 01:13:48,800
argument sending it.

2063
01:13:48,800 --> 01:13:49,850
First,

2064
01:13:49,850 --> 01:13:51,200
um, that sends its output to the

2065
01:13:51,200 --> 01:13:52,980
file out and looked out.

2066
01:13:53,120 --> 01:13:54,480
Or yet.

2067
01:13:55,340 --> 01:13:57,260
Um, on the cat and with its

2068
01:13:57,260 --> 01:14:01,250
input connected from the out file,

2069
01:14:01,250 --> 01:14:02,960
we can see that saved output from

2070
01:14:02,960 --> 01:14:04,080
the echo command.

2071
01:14:04,980 --> 01:14:08,060
Um, the way the shell sets this up.

2072
01:14:08,840 --> 01:14:10,070
Um is,

2073
01:14:10,070 --> 01:14:10,730
um,

2074
01:14:10,730 --> 01:14:11,860
as follows.

2075
01:14:13,390 --> 01:14:14,360
Um.

2076
01:14:15,320 --> 01:14:19,160
It a shell first forks like on

2077
01:14:19,160 --> 01:14:22,160
line 13 and then in the child,

2078
01:14:22,160 --> 01:14:24,260
the shell changes the way the file

2079
01:14:24,260 --> 01:14:25,940
descriptors are set up so that the

2080
01:14:25,940 --> 01:14:27,950
child's file descriptor

2081
01:14:27,950 --> 01:14:28,980
1 which

2082
01:14:29,200 --> 01:14:32,350
by convention most programs used for the output,

2083
01:14:32,350 --> 01:14:33,140
um.

2084
01:14:33,470 --> 01:14:36,260
This shell a changes the child's

2085
01:14:36,260 --> 01:14:38,300
file descriptor to 1 to refer

2086
01:14:38,300 --> 01:14:40,430
to this output file,

2087
01:14:40,430 --> 01:14:42,590
and then run whatever commands you wanted

2088
01:14:42,590 --> 01:14:45,470
and that leaves the parent shells file

2089
01:14:45,470 --> 01:14:48,950
descriptor 1 unchanged so this idiom of

2090
01:14:48,950 --> 01:14:51,590
forking and in a child, changing

2091
01:14:51,590 --> 01:14:53,260
around the file descriptors.

2092
01:14:53,360 --> 01:14:57,360
Um, is the usual way unix actually redirect

2093
01:14:57,460 --> 01:14:59,320
input an output for a command

2094
01:14:59,320 --> 01:15:01,090
that you run but not affect

2095
01:15:01,090 --> 01:15:03,370
the input and output for a

2096
01:15:03,370 --> 01:15:04,900
calling program because we don't want

2097
01:15:04,900 --> 01:15:06,720
to redirect the shell's output.

2098
01:15:07,150 --> 01:15:07,930
Um,

2099
01:15:07,930 --> 01:15:10,120
we only want to redirect the

2100
01:15:10,120 --> 01:15:11,760
child programs output.

2101
01:15:12,670 --> 01:15:12,970
Anyway,

2102
01:15:12,970 --> 01:15:15,730
the way this works we call fork unusual way,

2103
01:15:15,730 --> 01:15:18,720
a line 15 only executes in the child.

2104
01:15:18,860 --> 01:15:20,480
The reason for the close 1 on

2105
01:15:20,480 --> 01:15:23,200
line 15 is that in this program.

2106
01:15:23,590 --> 01:15:25,810
We're redirecting a just the output of

2107
01:15:25,810 --> 01:15:26,530
the echo command,

2108
01:15:26,530 --> 01:15:28,360
so when I run this redirect.

2109
01:15:28,640 --> 01:15:31,520
A program produces no output itself,

2110
01:15:31,520 --> 01:15:33,410
it ran echo with its output directly

2111
01:15:33,410 --> 01:15:35,380
to "output.txt".

2112
01:15:35,540 --> 01:15:38,900
So when I look at "output.txt",

2113
01:15:38,900 --> 01:15:39,720
um.

2114
01:15:39,770 --> 01:15:41,750
I see this expected output,

2115
01:15:41,750 --> 01:15:44,540
the reason for the close 1 on line 15.

2116
01:15:44,900 --> 01:15:47,960
Is that we want 1 as

2117
01:15:47,960 --> 01:15:50,180
a sort of conventional output file script

2118
01:15:50,180 --> 01:15:52,010
to refer to something else,

2119
01:15:52,010 --> 01:15:54,650
it happens so we don't have a child,

2120
01:15:54,650 --> 01:15:56,360
we don't want to use the father descriptor

2121
01:15:56,360 --> 01:15:58,070
1 that the shell had that's connected

2122
01:15:58,070 --> 01:15:59,300
to the console.

2123
01:15:59,660 --> 01:16:01,160
Um the call to open on line

2124
01:16:01,160 --> 01:16:04,400
16 is guaranteed to return 1 because,

2125
01:16:04,400 --> 01:16:06,380
um the semantics of open are that

2126
01:16:06,380 --> 01:16:08,140
open returns the lowest

2127
01:16:08,410 --> 01:16:09,490
file descriptor number,

2128
01:16:09,490 --> 01:16:12,430
that's not currently in use in the

2129
01:16:12,430 --> 01:16:15,260
calling process since we just closed 1.

2130
01:16:15,420 --> 01:16:18,990
And file descriptor 0 is still connected

2131
01:16:18,990 --> 01:16:19,590
to the console,

2132
01:16:19,590 --> 01:16:20,400
I mean.

2133
01:16:20,460 --> 01:16:23,440
I'm open is guaranteed to return 1.

2134
01:16:24,290 --> 01:16:27,560
So after the line 16 file descriptor

2135
01:16:27,560 --> 01:16:29,880
1 is connected to this file.

2136
01:16:30,220 --> 01:16:32,890
When we exec echo, echo just writes its output,

2137
01:16:32,890 --> 01:16:35,020
the file descriptor 1 and now go

2138
01:16:35,020 --> 01:16:36,340
to this file and the cool thing

2139
01:16:36,340 --> 01:16:37,720
about this is echo had no idea

2140
01:16:37,720 --> 01:16:39,580
what's going on, echo doesn't need to

2141
01:16:39,580 --> 01:16:41,650
know about IO direction at all,

2142
01:16:41,650 --> 01:16:43,000
it just writes its output,

2143
01:16:43,000 --> 01:16:44,400
the file descriptor 1.

2144
01:16:45,160 --> 01:16:47,590
I'm only the shell

2145
01:16:47,590 --> 01:16:49,140
knows about

2146
01:16:49,330 --> 01:16:50,600
IO redirection.

2147
01:16:52,380 --> 01:16:55,540
This example also illustrates the sort of

2148
01:16:56,090 --> 01:16:59,330
kind of neatness of the separation between

2149
01:16:59,330 --> 01:17:00,950
fork and exec, the fact that fork

2150
01:17:00,950 --> 01:17:05,100
and exec our separate system calls separate.

2151
01:17:05,560 --> 01:17:07,720
Um functions.

2152
01:17:08,130 --> 01:17:09,840
Means that there's a period of time

2153
01:17:09,840 --> 01:17:11,720
in the child between the fork.

2154
01:17:11,980 --> 01:17:13,630
Between them for returns in the child

2155
01:17:13,630 --> 01:17:16,060
and exactly which were still running the

2156
01:17:16,060 --> 01:17:17,860
calling processes instructions,

2157
01:17:17,860 --> 01:17:20,080
so the calling process.

2158
01:17:20,160 --> 01:17:22,320
Even though it's running in those instructions

2159
01:17:22,320 --> 01:17:23,610
are running in the child,

2160
01:17:23,610 --> 01:17:25,890
it's still the calling processes instructions that

2161
01:17:25,890 --> 01:17:28,050
are executed and so the calling process

2162
01:17:28,050 --> 01:17:31,620
is still able to change things and

2163
01:17:31,620 --> 01:17:33,940
still in control up until line 19.

2164
01:17:34,380 --> 01:17:35,790
And this sort of interval between fork

2165
01:17:35,790 --> 01:17:38,010
and exec gives the show a chance

2166
01:17:38,010 --> 01:17:40,380
to change what the file descriptors,

2167
01:17:40,380 --> 01:17:41,820
refer to for example.

2168
01:17:43,180 --> 01:17:46,220
Any questions about this redirect example.

2169
01:17:46,560 --> 01:17:46,940
Yeah.

2170
01:17:55,220 --> 01:18:00,080
All right, I'm about out of time.

2171
01:18:00,410 --> 01:18:02,690
Just wrap up, we look at unix is,

2172
01:18:02,690 --> 01:18:03,520
um.

2173
01:18:03,800 --> 01:18:05,690
A bunch of the interfaces to

2174
01:18:05,690 --> 01:18:09,620
unix's IO and process abstractions, um,

2175
01:18:09,620 --> 01:18:10,820
thing to take away from this is

2176
01:18:10,820 --> 01:18:12,920
if the interfaces are relatively simple and

2177
01:18:12,920 --> 01:18:15,590
just pass integer like file descriptors

2178
01:18:15,590 --> 01:18:18,050
and process ids back and forth across

2179
01:18:18,050 --> 01:18:20,030
its arguments system calls,

2180
01:18:20,030 --> 01:18:20,780
um.

2181
01:18:20,820 --> 01:18:21,900
But,

2182
01:18:22,360 --> 01:18:22,510
Well,

2183
01:18:22,510 --> 01:18:24,790
the functionality inside the interface is

2184
01:18:24,790 --> 01:18:27,020
relatively sophisticated like

2185
01:18:27,180 --> 01:18:29,700
creating new processes and copying the current

2186
01:18:29,700 --> 01:18:32,820
process, and furthermore I show some examples

2187
01:18:32,820 --> 01:18:34,770
of ways in which the abstractions

2188
01:18:34,770 --> 01:18:38,550
individually simple combine in useful ways,

2189
01:18:38,550 --> 01:18:40,800
for example to produce

2190
01:18:40,890 --> 01:18:42,120
IO redirection.

2191
01:18:44,030 --> 01:18:45,260
There's a lab due at the end

2192
01:18:45,260 --> 01:18:48,200
of next week and that lab involves

2193
01:18:48,200 --> 01:18:50,600
writing more simple utilities like the ones

2194
01:18:50,600 --> 01:18:52,160
I showed that use the system calls

2195
01:18:52,160 --> 01:18:54,000
that we discuss.

2196
01:18:54,140 --> 01:18:54,350
So,

2197
01:18:54,350 --> 01:18:56,570
have fun with that lab and I'll

2198
01:18:56,570 --> 01:18:57,880
see you in class next week.

2199
01:18:58,640 --> 01:18:59,420
Um,

2200
01:19:01,520 --> 01:19:02,580
and that's it.

2201
01:19:08,480 --> 01:19:08,940
Thank you.

2202
01:19:15,170 --> 01:19:16,670
Since I'm the one recording,

2203
01:19:16,670 --> 01:19:18,980
how do I end this, first

2204
01:19:18,980 --> 01:19:20,900
time recording in lecture. They

2205
01:19:20,900 --> 01:19:22,320
will be exit.

2206
01:19:22,520 --> 01:19:23,030
Okay,

2207
01:19:23,030 --> 01:19:24,470
nothing special I can just exit it

2208
01:19:24,470 --> 01:19:25,580
will be saved somewhere.

2209
01:19:26,220 --> 01:19:27,300
Yes,

2210
01:19:27,300 --> 01:19:28,020
awesome.

2211
01:19:32,010 --> 01:19:34,520
I assume we'll create some directory and

2212
01:19:35,120 --> 01:19:36,840
sticking a file in that directory.

2213
01:19:38,600 --> 01:19:41,140
There's also office hours right after this right.

2214
01:19:41,930 --> 01:19:42,860
Yes,

2215
01:19:42,860 --> 01:19:46,380
perfect cool.

2216
01:19:48,050 --> 01:19:48,480
Happy.

2217
01:19:50,340 --> 01:19:51,220
All right.

2218
01:19:51,580 --> 01:19:52,450
All right,

2219
01:19:52,450 --> 01:19:54,640
thank you and I'll see you next week,

2220
01:19:54,640 --> 01:19:55,320
thanks.

