1
00:00:01,900 --> 00:00:02,590
Alright,

2
00:00:04,270 --> 00:00:08,140
welcome to 6.S081 operating systems,

3
00:00:08,770 --> 00:00:11,980
I'm Robert I'll be Co lecturing with Frans

4
00:00:12,280 --> 00:00:15,250
and David and Nicolass of the TAs.

5
00:00:16,450 --> 00:00:18,850
So, please during the zoom lecturers,

6
00:00:18,850 --> 00:00:19,690
ask questions,

7
00:00:19,690 --> 00:00:21,970
you can either interrupt me by audio

8
00:00:21,970 --> 00:00:25,390
or enter something into the chat window,

9
00:00:25,840 --> 00:00:28,450
one of the staff will see and ask questions for you.

10
00:00:29,900 --> 00:00:32,120
By the way, we'll be recording these lectures

11
00:00:32,120 --> 00:00:33,680
and then we'll post recordings later,

12
00:00:33,680 --> 00:00:35,180
so you can review them

13
00:00:35,180 --> 00:00:37,580
or for people who can't make this time

14
00:00:38,000 --> 00:00:39,620
so they can nevertheless see lectures.

15
00:00:40,710 --> 00:00:45,690
Alright, I want to start by laying out some of the goals of the course,

16
00:00:45,720 --> 00:00:48,910
So, number one is to ,

17
00:00:49,330 --> 00:00:55,270
understand the design and implementation of operating systems.

18
00:00:56,310 --> 00:01:01,210
Yeah, design is sort of high level structure

19
00:01:01,210 --> 00:01:04,510
and implementation is really about what the code looks like,

20
00:01:04,600 --> 00:01:06,490
and we'll be spending a lot of time with both.

21
00:01:07,940 --> 00:01:13,400
And in the interest of getting deep understanding of what's going on,

22
00:01:13,640 --> 00:01:23,130
you'll get hands-on experience with a small, a small operating system,

23
00:01:23,130 --> 00:01:24,720
the xv6 operating system.

24
00:01:25,320 --> 00:01:30,270
And in addition to actually looking at an existing operating system,

25
00:01:30,270 --> 00:01:34,590
you'll be in the labs get a bunch of experience,

26
00:01:34,590 --> 00:01:38,010
extending the operating system modifying improving its behavior

27
00:01:38,100 --> 00:01:43,740
and writing system software that it uses the operating system interfaces,

28
00:01:43,740 --> 00:01:44,790
[if it works an application].

29
00:01:46,520 --> 00:01:50,420
So,  this is what you're going to be doing in the course .

30
00:01:52,980 --> 00:01:56,580
We're also interested in what the purpose of the operating system

31
00:01:56,580 --> 00:01:58,500
itself is as well as the course.

32
00:02:00,980 --> 00:02:04,790
So for that, I have a sort of list of a couple of things

33
00:02:04,790 --> 00:02:08,630
which you know there's lots of operating system,

34
00:02:08,630 --> 00:02:10,310
different operating systems out there,

35
00:02:10,550 --> 00:02:13,550
they typically have a common set of purposes.

36
00:02:15,150 --> 00:02:19,800
One of them is to abstract the hardware,

37
00:02:21,520 --> 00:02:26,170
that is what you're given typically as a starting point is you buy a computer,

38
00:02:26,170 --> 00:02:27,700
a computer has a CPU and memory,

39
00:02:27,760 --> 00:02:29,590
but that's a very low level.

40
00:02:29,940 --> 00:02:31,740
A set of resources,

41
00:02:31,770 --> 00:02:35,910
it's fantastic to have a much higher level interfaces and abstractions

42
00:02:35,910 --> 00:02:37,350
that applications can use,

43
00:02:37,980 --> 00:02:43,470
such as processes or file systems both for convenience and for portability.

44
00:02:44,360 --> 00:02:48,050
Another very important task of an operating system is

45
00:02:48,050 --> 00:02:51,870
to multiplex the hardware among many applications.

46
00:02:52,360 --> 00:02:56,470
You might be running a text editor, and a compiler,

47
00:02:56,470 --> 00:03:01,010
or maybe a multiple different database servers

48
00:03:01,010 --> 00:03:02,360
or something on your operating system,

49
00:03:02,420 --> 00:03:04,940
it's fantastic to be able to have the operating system

50
00:03:04,940 --> 00:03:06,530
run both of them at the same time

51
00:03:06,530 --> 00:03:10,040
or all the things are going on at the same time without having them interfere.

52
00:03:11,420 --> 00:03:13,010
That's often called multiplexing,

53
00:03:13,970 --> 00:03:16,280
because there may be a lot of things

54
00:03:16,280 --> 00:03:18,260
happening in the operating system at the same time,

55
00:03:18,260 --> 00:03:21,620
it's critical that they not interfere unintentionally,

56
00:03:21,770 --> 00:03:23,330
even if they have bugs

57
00:03:23,360 --> 00:03:26,510
and that's a task is called isolation.

58
00:03:27,120 --> 00:03:32,900
The idea that, different activities should not be allowed to interfere,

59
00:03:33,050 --> 00:03:33,620
on the other hand,

60
00:03:33,620 --> 00:03:37,070
there are times when different activities would like to interfere,

61
00:03:37,070 --> 00:03:38,840
would like to interact or cooperate,

62
00:03:38,870 --> 00:03:42,110
so for example if I create a file with a text editor,

63
00:03:42,230 --> 00:03:44,480
and I'd like my compiler to read the file

64
00:03:44,990 --> 00:03:47,390
and we definitely want to allow that kind of sharing.

65
00:03:47,860 --> 00:03:53,390
So we wanna allow sharing [], sort of what the user has in mind.

66
00:03:55,670 --> 00:03:59,180
But in many circumstances, the user doesn't want sharing,

67
00:03:59,180 --> 00:04:02,210
maybe you're logged into a time sharing machine like Athena,

68
00:04:02,300 --> 00:04:05,000
and you don't want other people to read your files ,

69
00:04:05,000 --> 00:04:06,890
so we also need as well sharing we want to,

70
00:04:06,920 --> 00:04:09,380
not share when we don't want to .

71
00:04:09,760 --> 00:04:12,850
Which we could call security or a permission system,

72
00:04:13,210 --> 00:04:14,500
an access control system.

73
00:04:16,650 --> 00:04:19,230
Another thing that people value in operating systems is

74
00:04:19,320 --> 00:04:21,840
if you spend a lot of money on the hardware on a computer,

75
00:04:21,870 --> 00:04:23,820
you'd like your application to be able to get

76
00:04:23,880 --> 00:04:28,680
a sort of full performance that a hardware ought to be able to provide.

77
00:04:28,800 --> 00:04:33,740
And, a lot of that is just application programming .

78
00:04:34,010 --> 00:04:36,830
But, inevitably, unfortunately, some of it is

79
00:04:36,830 --> 00:04:38,840
the operating system has to make sure that

80
00:04:38,900 --> 00:04:42,410
whatever services it provides

81
00:04:42,470 --> 00:04:46,010
don't get in the way of applications getting high performance,

82
00:04:46,250 --> 00:04:48,290
so you want to at least not get in the way

83
00:04:48,290 --> 00:04:52,700
and maybe even help applications achieve good performance.

84
00:04:55,880 --> 00:05:00,320
Finally , with most operating systems

85
00:05:00,890 --> 00:05:03,170
have to support a wide range of different applications,

86
00:05:03,170 --> 00:05:05,990
maybe it's a laptop running a text editor,

87
00:05:05,990 --> 00:05:07,550
maybe it's running games,

88
00:05:07,610 --> 00:05:09,410
maybe your operating system needs to

89
00:05:09,410 --> 00:05:12,740
support database servers or cloud computation,

90
00:05:12,860 --> 00:05:17,960
and usually because operating systems are quite expensive to design and build,

91
00:05:18,620 --> 00:05:21,710
people use the same operating systems for many different tasks,

92
00:05:21,710 --> 00:05:22,250
like Linux,

93
00:05:22,250 --> 00:05:24,950
for example which I'm sure many of you are running a,

94
00:05:24,950 --> 00:05:27,050
is used in all of the situations I mentioned,

95
00:05:27,050 --> 00:05:29,480
so the same operating system really has to be able to support

96
00:05:29,630 --> 00:05:33,950
a range of often quite different uses.

97
00:05:36,830 --> 00:05:38,840
So we're hoping to be able to support

98
00:05:39,590 --> 00:05:42,470
sort of all these different goals simultaneously.

99
00:05:44,000 --> 00:05:46,520
And we'll hear more about all of them during the course.

100
00:05:47,810 --> 00:05:49,760
Alright, operating systems,

101
00:05:49,790 --> 00:05:55,730
a lot of people worked out a set of design ideas over the decades

102
00:05:56,000 --> 00:05:59,060
have worked pretty well sort of ways of organizing things,

103
00:05:59,310 --> 00:06:03,240
I'm going to lay out for you this sort of classic.

104
00:06:05,890 --> 00:06:11,770
A organization sort of standard deal for  for this course,

105
00:06:11,770 --> 00:06:17,100
and is actually quite common around for many operate systems,

106
00:06:17,100 --> 00:06:20,340
so this is sort of OS internal organization,

107
00:06:20,400 --> 00:06:29,000
or the way I think about it is in terms of a box for the computer,

108
00:06:29,810 --> 00:06:33,850
the computer sort of comes with a bunch of hardware resources,

109
00:06:33,850 --> 00:06:34,810
which I'll put at the bottom,

110
00:06:34,810 --> 00:06:42,040
maybe their CPU and ram, disk for storage and maybe a network interface,

111
00:06:42,070 --> 00:06:44,800
this sort of hardware that's the lowest layer.

112
00:06:46,180 --> 00:06:49,540
So at the top you want to run various applications,

113
00:06:49,570 --> 00:06:53,200
maybe a text editor I have use VI as a text editor,

114
00:06:53,590 --> 00:06:56,500
if you're going to run a C compiler CC,

115
00:06:56,770 --> 00:06:59,920
you know if you run lots of other things we're gonna talk a lot today,

116
00:06:59,920 --> 00:07:04,260
about the shell which is the command line interface,

117
00:07:04,410 --> 00:07:06,330
so we have all these different programs that are running.

118
00:07:07,260 --> 00:07:11,430
And this is the sort of world in which applications run

119
00:07:11,430 --> 00:07:13,260
is usually called user space.

120
00:07:14,260 --> 00:07:18,280
And as distinct from that, there's a single program,

121
00:07:19,440 --> 00:07:23,220
a special program, that's always running called the kernel

122
00:07:23,250 --> 00:07:27,150
and the kernel is sort of the guardian of the resources of the computer,

123
00:07:27,270 --> 00:07:29,970
it's what first boots up you turn on the computer,

124
00:07:30,270 --> 00:07:33,270
there's just one of it maintains data ,

125
00:07:33,640 --> 00:07:36,280
to help manage each of these processes

126
00:07:36,280 --> 00:07:40,810
and the kernel also means lots of data structures to help interface,

127
00:07:40,810 --> 00:07:44,130
and all the different kinds of hardware,

128
00:07:45,020 --> 00:07:48,890
these user programs need to use.

129
00:07:49,550 --> 00:07:52,340
the kernel also has built in a bunch of services,

130
00:07:53,550 --> 00:07:55,260
and so, for example

131
00:07:55,260 --> 00:07:59,720
there's typically a file system implementation inside the kernel,

132
00:07:59,720 --> 00:08:04,790
that implements things like file names and file contents and directories

133
00:08:04,790 --> 00:08:07,910
and understands how to store the files in the disk,

134
00:08:07,910 --> 00:08:10,850
so your programs are going to talk to the files inside the kernel

135
00:08:10,850 --> 00:08:14,530
and file implementations is going to talk to the disk.

136
00:08:15,410 --> 00:08:16,520
In this course,

137
00:08:17,460 --> 00:08:21,840
where we mostly focus on is all the things that has to happen inside the kernel,

138
00:08:22,140 --> 00:08:25,770
and on the interfaces between user programs and the kernel,

139
00:08:27,490 --> 00:08:31,390
As well as the structure of the software inside the kernel.

140
00:08:32,110 --> 00:08:37,030
So we care a lot about these services inside the kernel.

141
00:08:38,610 --> 00:08:40,350
One of them is a file system I mentioned,

142
00:08:40,380 --> 00:08:44,400
there's also management of processes,

143
00:08:44,400 --> 00:08:47,250
each of these running programs is called the process,

144
00:08:47,250 --> 00:08:49,230
and it has things like its own memory,

145
00:08:49,230 --> 00:08:53,310
for example as well as a share of the CPU time.

146
00:08:53,640 --> 00:09:00,730
So, kernel manages processes. as a kernel service ,

147
00:09:01,300 --> 00:09:05,740
 kernel manages the allocation of the memory,

148
00:09:05,950 --> 00:09:08,080
the different processes need different amounts of memory,

149
00:09:08,080 --> 00:09:13,310
the kernel multiplexes and divides up the memory,

150
00:09:13,520 --> 00:09:18,000
allocates the memory among all the different processes.

151
00:09:24,400 --> 00:09:26,650
The kernel as I mentioned influence the file system,

152
00:09:26,650 --> 00:09:31,030
file system really comes into a three logical or a bunch of logical parts,

153
00:09:31,030 --> 00:09:32,530
but for now, we can think of it

154
00:09:32,530 --> 00:09:36,250
in terms of managing file content that's inside files,

155
00:09:36,280 --> 00:09:38,140
figuring out where on disk.

156
00:09:39,080 --> 00:09:40,610
Each file's content ought to live,

157
00:09:40,910 --> 00:09:44,150
file system also somewhat separately manages a name space,

158
00:09:44,150 --> 00:09:45,620
that each file has a name

159
00:09:45,650 --> 00:09:48,560
and there's a hierarchy of directories,

160
00:09:48,830 --> 00:09:50,630
every directory has a bunch of files in it,

161
00:09:50,630 --> 00:09:53,360
all that's managed by the file system.

162
00:09:54,030 --> 00:09:56,700
There's typically some sort of security arrangement,

163
00:09:57,300 --> 00:09:59,130
maybe we'll call it access control.

164
00:10:01,750 --> 00:10:03,130
Which the kernel decides

165
00:10:03,130 --> 00:10:07,210
that when a given process wants to read, use some resource,

166
00:10:07,210 --> 00:10:09,370
maybe read something from disk, use some memory,

167
00:10:09,430 --> 00:10:11,590
the access control machinery inside the kernel

168
00:10:11,590 --> 00:10:14,110
is what gets to decide yes it's allowed is that not allowed,

169
00:10:14,290 --> 00:10:15,610
that can get pretty complicated

170
00:10:15,610 --> 00:10:18,820
if we're talking about time sharing systems like Athena systems,

171
00:10:18,820 --> 00:10:22,480
where there's you know each of these processes may be run by a different user

172
00:10:22,480 --> 00:10:24,910
and have different access control rules,

173
00:10:24,940 --> 00:10:26,890
apply to what it's allowed to get at.

174
00:10:28,830 --> 00:10:31,410
And in a real full-blown operating system

175
00:10:31,710 --> 00:10:33,900
turns out to be many, many other services,

176
00:10:34,050 --> 00:10:35,580
you know there's typically some way

177
00:10:35,580 --> 00:10:37,650
for different processes to talk to each other,

178
00:10:37,650 --> 00:10:39,420
called inter process communication,

179
00:10:40,200 --> 00:10:43,830
there's typically a whole bunch of software associated with the network things,

180
00:10:43,830 --> 00:10:48,690
like the TCP/IP protocols for talking the network ,

181
00:10:49,900 --> 00:10:52,330
there's typically support for sound cards,

182
00:10:52,330 --> 00:10:54,880
there may be drivers for hundreds of different disks

183
00:10:54,880 --> 00:10:56,380
and hundreds of different network cards,

184
00:10:56,470 --> 00:10:58,150
so in a full-blown operating system

185
00:10:58,150 --> 00:11:00,220
is a huge amount of stuff here

186
00:11:00,220 --> 00:11:03,850
and this may run to millions of lines of code inside the kernel.

187
00:11:05,300 --> 00:11:08,660
So that's sort of a quick overview of whats inside the kernel,

188
00:11:09,560 --> 00:11:13,340
we're also interested in how applications interact with the kernel

189
00:11:13,370 --> 00:11:15,920
and what that interface looks like.

190
00:11:19,060 --> 00:11:27,560
The  usual, so this is the API for the kernel.

191
00:11:30,610 --> 00:11:32,230
How applications get at the kernel,

192
00:11:32,500 --> 00:11:35,410
typically that's done with something called system calls

193
00:11:35,410 --> 00:11:40,440
and these are things that look like function calls that programs can make,

194
00:11:41,100 --> 00:11:42,990
but actually jump into the kernel

195
00:11:42,990 --> 00:11:47,130
and execute system call implementation in the kernel,

196
00:11:47,430 --> 00:11:50,520
I'll talk a bunch about that in the latter part of this lecture,

197
00:11:51,090 --> 00:11:53,100
for now just to give you a flavor here,

198
00:11:53,100 --> 00:11:54,960
what a couple of different system calls

199
00:11:54,960 --> 00:11:57,660
might look like in the source code of an application.

200
00:12:00,310 --> 00:12:01,510
One might be that

201
00:12:01,630 --> 00:12:03,910
if you want an application wants to open a file,

202
00:12:04,180 --> 00:12:06,670
and it calls the open system call,

203
00:12:07,420 --> 00:12:10,510
and tells the open system called the name of the file,

204
00:12:10,720 --> 00:12:14,200
so maybe it wants to open a file for writing called out

205
00:12:14,200 --> 00:12:17,500
and   next argument here saying 1 in this case.

206
00:12:17,500 --> 00:12:18,760
Saying I want to write that file,

207
00:12:19,000 --> 00:12:21,550
and so this thing that looks like a function call.

208
00:12:22,670 --> 00:12:26,480
It opens the system calls actually special code that jumps into the kernel

209
00:12:26,480 --> 00:12:28,400
and the kernel can retrieve these arguments,

210
00:12:28,700 --> 00:12:30,680
executes some kernel code that implements open,

211
00:12:30,680 --> 00:12:33,470
maybe talks to the disk, and then returns a value

212
00:12:33,470 --> 00:12:38,220
and that's this file descriptor, as fd stands for file descriptor,

213
00:12:38,610 --> 00:12:44,250
which is the program can then use as a handle to refer to this open file.

214
00:12:44,760 --> 00:12:47,160
If you want to write to a file,

215
00:12:47,160 --> 00:12:50,930
the system call did, to do that is called write,

216
00:12:51,200 --> 00:12:53,360
you have to pass it one of these file descriptors,

217
00:12:53,360 --> 00:12:55,100
the same was returned by open,

218
00:12:55,700 --> 00:12:59,270
these are arguments that are passed in the system call.

219
00:12:59,770 --> 00:13:01,600
From the program into the kernel,

220
00:13:01,960 --> 00:13:05,370
and you give it a pointer to a buffer of characters,

221
00:13:05,370 --> 00:13:08,310
so an easy way to do that in the C programming language,

222
00:13:08,310 --> 00:13:13,480
which these examples are written by as double quotes then the string,

223
00:13:13,480 --> 00:13:16,690
the bytes of the string backslash n is a new line

224
00:13:17,020 --> 00:13:19,810
and the third argument is the count of characters.

225
00:13:20,160 --> 00:13:23,190
If you want to write so this really gets point,

226
00:13:23,490 --> 00:13:25,350
pass this address in memory,

227
00:13:25,860 --> 00:13:29,400
so you're telling the kernel look, please write 6 bytes from this address

228
00:13:29,610 --> 00:13:32,520
to the file that this file descriptor refers to.

229
00:13:33,750 --> 00:13:37,350
A much more exciting system call the encounter

230
00:13:37,350 --> 00:13:40,560
is the fork system call fork is the system call,

231
00:13:40,590 --> 00:13:42,420
that creates a new process,

232
00:13:44,160 --> 00:13:48,000
and returns actually creates a process that's identical to the caller

233
00:13:48,300 --> 00:13:56,100
and fork returns the identifier the process identifier pid of the new process .

234
00:13:56,100 --> 00:13:59,270
More complicated than [], we'll hear more about this.

235
00:14:00,740 --> 00:14:03,470
So again, these are all look like function calls,

236
00:14:04,400 --> 00:14:06,950
but the system calls are special because they jump into the kernel.

237
00:14:08,200 --> 00:14:10,660
That's taste, we'll see more later.

238
00:14:15,800 --> 00:14:17,570
That is a sort of quick overview,

239
00:14:17,600 --> 00:14:25,000
I wanna just mention why I find a operating the study of operating systems,

240
00:14:25,300 --> 00:14:30,160
to be both a challenging and interesting.

241
00:14:32,710 --> 00:14:34,420
Why you know why it's maybe worth,

242
00:14:35,360 --> 00:14:38,450
intellectually worth taking a course in this area.

243
00:14:39,370 --> 00:14:42,760
So, one reason why it's hard is that the environment is unforgiving,

244
00:14:43,090 --> 00:14:46,360
programming environment inside the kernels unforgiving,

245
00:14:46,360 --> 00:14:51,860
because you're, your when you're programming,

246
00:14:51,860 --> 00:14:53,810
when you're modifying the kernel or extending the kernel

247
00:14:53,810 --> 00:14:55,580
or writing a new operating system kernel,

248
00:14:55,640 --> 00:14:59,060
you're providing the infrastructure that everybody else assumes

249
00:14:59,060 --> 00:15:01,280
is already present to run their programs.

250
00:15:01,640 --> 00:15:04,550
And then everybody else gets an operating system under their program

251
00:15:04,610 --> 00:15:06,500
when they write ordinary application programs,

252
00:15:06,500 --> 00:15:08,990
but when we build operating systems

253
00:15:08,990 --> 00:15:12,410
what we get is the hardware underneath our operating system

254
00:15:13,190 --> 00:15:15,620
which turns out to be more difficult to deal with.

255
00:15:15,650 --> 00:15:16,310
In this course,

256
00:15:16,310 --> 00:15:22,210
we we get to use a hardware simulator called QEMU .

257
00:15:22,790 --> 00:15:25,970
That simulates a CPU and a computer

258
00:15:25,970 --> 00:15:27,200
and that makes a little bit better,

259
00:15:27,200 --> 00:15:30,980
but it's still a kind of a difficult, environment programming.

260
00:15:32,360 --> 00:15:34,100
Another reason why it's hard and interesting is

261
00:15:34,100 --> 00:15:36,620
because if you're designing and operating system,

262
00:15:36,620 --> 00:15:39,500
you have to satisfy a bunch of tensions,

263
00:15:39,980 --> 00:15:41,690
that require real design thought.

264
00:15:41,900 --> 00:15:46,220
So one is that you'd like your operating system to be both efficient.

265
00:15:46,720 --> 00:15:51,280
Which often means that it operates at a low level close to the hardware,

266
00:15:51,640 --> 00:15:53,260
but for ease of use,

267
00:15:53,290 --> 00:15:56,110
and because real live people have to write programs

268
00:15:56,380 --> 00:15:57,760
that use your operating system,

269
00:15:57,820 --> 00:16:02,020
we'd like it also to be a right abstract high-level.

270
00:16:02,660 --> 00:16:04,040
A portable interfaces

271
00:16:04,100 --> 00:16:07,910
and it's a neat trick to provide a abstract interfaces that are simple.

272
00:16:08,320 --> 00:16:10,780
A portable but they are also efficient.

273
00:16:11,910 --> 00:16:13,950
Another tension is

274
00:16:13,950 --> 00:16:18,240
that we'd like to provide a very powerful operating system services,

275
00:16:18,240 --> 00:16:21,270
so that the operating system can shoulder a lot of the burden.

276
00:16:21,680 --> 00:16:27,750
 Running programs like a powerful operating system services.

277
00:16:28,630 --> 00:16:32,960
But, we also want to have simple interfaces,

278
00:16:34,770 --> 00:16:38,130
that we don't want a tremendously complex

279
00:16:38,130 --> 00:16:40,560
hard to understand interfaces for programmers to use,

280
00:16:40,560 --> 00:16:42,600
because I'm not going to understand them,

281
00:16:42,600 --> 00:16:44,610
and they may find it hard to use,

282
00:16:45,790 --> 00:16:48,400
so this is really simple API,

283
00:16:48,400 --> 00:16:53,170
and so this is possible to do to provide a simple interfaces,

284
00:16:53,170 --> 00:16:56,710
that have powerful a machinery inside them,

285
00:16:56,830 --> 00:16:58,210
will always be searching for.

286
00:16:58,700 --> 00:17:04,340
Sort of simple interfaces provide a powerful services.

287
00:17:04,760 --> 00:17:06,860
Hey, Robbery, we've got a question in the chat.

288
00:17:07,280 --> 00:17:11,600
What is unique slash different about saying system calls jump into the kernel,

289
00:17:11,600 --> 00:17:15,230
i.e as opposed to a standard function call that jumps to another function.

290
00:17:18,100 --> 00:17:23,840
Well, the kernel has, the kernel is, a piece of code that's always resident,

291
00:17:23,840 --> 00:17:25,730
that has special privileges

292
00:17:25,760 --> 00:17:29,630
that were that because it booted the machine booted the kernel,

293
00:17:30,020 --> 00:17:32,600
kernel has special privileges,

294
00:17:32,600 --> 00:17:35,300
it can get directly at all kinds of hardware,

295
00:17:35,300 --> 00:17:39,020
like the disk device that ordinary user programs can't get at,

296
00:17:39,350 --> 00:17:41,780
so if you make a an ordinary function call,

297
00:17:43,920 --> 00:17:46,440
the function your calling doesn't get it,

298
00:17:46,440 --> 00:17:49,320
doesn't get any special privileges with respect to the hardware,

299
00:17:49,530 --> 00:17:51,510
whereas if you make a system call into the kernel,

300
00:17:52,620 --> 00:17:54,000
we'll talk about how this works,

301
00:17:54,000 --> 00:17:57,510
but that ends up as when it jumps into,

302
00:17:57,510 --> 00:17:59,340
when the system call jumps into the kernel,

303
00:17:59,730 --> 00:18:03,570
system call implementation in the kernel then gets all these special privileges,

304
00:18:03,570 --> 00:18:11,470
so that it can modify all kinds of sensitive and protected hardware resources,

305
00:18:11,470 --> 00:18:14,140
like for example getting directly at the hard disk.

306
00:18:15,730 --> 00:18:18,700
We'll see a lot more detail for all this shortly.

307
00:18:20,330 --> 00:18:22,670
Okay, so a final tension that we want

308
00:18:22,670 --> 00:18:25,910
that all operating systems need to satisfy your gonna give programs,

309
00:18:25,910 --> 00:18:27,560
as much flexibility as you can,

310
00:18:27,560 --> 00:18:28,760
you don't want to constrain them,

311
00:18:28,970 --> 00:18:33,750
so you want to have very flexible interfaces.

312
00:18:33,750 --> 00:18:35,700
But you do need to constrain program somewhat,

313
00:18:35,700 --> 00:18:38,430
because you absolutely have to have some notion of security.

314
00:18:41,770 --> 00:18:44,770
We love for programs programs complete freedom,

315
00:18:44,770 --> 00:18:46,630
but it can't be complete can't be really complete,

316
00:18:46,870 --> 00:18:49,840
because we don't want programs to get directly at the hardware

317
00:18:49,840 --> 00:18:51,490
or to interfere with other programs

318
00:18:51,490 --> 00:18:54,220
or a sort of be able to interfere

319
00:18:54,220 --> 00:18:56,830
with the operation of the operating system itself.

320
00:18:57,360 --> 00:19:00,540
So, these are all you know.

321
00:19:01,490 --> 00:19:02,810
It's possible to do a good job

322
00:19:02,810 --> 00:19:03,860
and we'll talk a lot about it,

323
00:19:03,860 --> 00:19:05,450
but it's always a bit of a puzzle

324
00:19:05,450 --> 00:19:10,100
to provide sort of both of these properties in both of these columns.

325
00:19:11,630 --> 00:19:14,390
Another thing that makes OS design hard and interesting is

326
00:19:14,390 --> 00:19:17,690
that operating systems provide a lot of features and a lot of services,

327
00:19:17,690 --> 00:19:19,520
but they actually tend to interact

328
00:19:19,910 --> 00:19:21,650
and sometimes in odd ways

329
00:19:21,650 --> 00:19:22,760
that require a lot of thought,

330
00:19:22,760 --> 00:19:25,700
so even the simple examples I gave .

331
00:19:26,640 --> 00:19:29,190
With open and fork, those two interact actually

332
00:19:29,190 --> 00:19:34,220
if a program allocates a file descriptor with the open system call,

333
00:19:34,700 --> 00:19:38,640
and then that same program fork.

334
00:19:39,610 --> 00:19:42,040
And the semantics of fork just turned out to be

335
00:19:42,040 --> 00:19:45,580
that you create a new process that's a copy of the current process,

336
00:19:45,730 --> 00:19:47,830
this file descriptor you opened,

337
00:19:49,640 --> 00:19:51,290
if that's truly to be a copy,

338
00:19:51,290 --> 00:19:55,550
this file descriptor still has to be present and usable in the child,

339
00:19:57,320 --> 00:19:58,370
and so that has to be thought,

340
00:19:58,370 --> 00:19:59,660
through that is the files,

341
00:19:59,660 --> 00:20:02,840
the opened file descriptors interact with fork in this interesting way

342
00:20:03,230 --> 00:20:07,580
and somebody has to figure out should the child be able to get at,

343
00:20:07,960 --> 00:20:10,690
the file descriptors created before fork is called

344
00:20:10,930 --> 00:20:12,340
and the answer has to be yes,

345
00:20:12,580 --> 00:20:14,170
the operating systems we're going to look at.

346
00:20:17,070 --> 00:20:18,510
Alright and so other things that

347
00:20:18,510 --> 00:20:21,210
are turned out to be interesting I already mentioned,

348
00:20:21,210 --> 00:20:25,080
that operating systems have to cater to a wide variety of uses,

349
00:20:25,110 --> 00:20:30,540
the same OS used both for database servers and smartphones, for example.

350
00:20:31,500 --> 00:20:35,240
And operating systems, as time goes on,

351
00:20:35,270 --> 00:20:38,360
the hardware that you run hardware, you get,

352
00:20:38,360 --> 00:20:40,130
but typical computers changes,

353
00:20:40,400 --> 00:20:44,930
maybe get superfast ssd storage instead of mechanical hard drive, for example.

354
00:20:45,360 --> 00:20:47,010
And about fifteen years ago,

355
00:20:47,070 --> 00:20:52,650
multi core computers went from being rare curiosities to being pervasive

356
00:20:54,030 --> 00:20:57,360
and and recently we've seen order of magnitude speedups

357
00:20:57,360 --> 00:20:58,890
and how fast networks operate

358
00:20:59,190 --> 00:21:01,110
and so all these require rethinks.

359
00:21:01,440 --> 00:21:05,220
 Periodically of how operating systems are designed.

360
00:21:06,510 --> 00:21:10,500
Now so so those are those are,

361
00:21:10,500 --> 00:21:12,510
sort of intellectually why you might take the course,

362
00:21:12,510 --> 00:21:14,400
there's also some more practical reasons,

363
00:21:14,400 --> 00:21:17,460
why you might be glad to have taken this course,

364
00:21:17,580 --> 00:21:20,730
one is if you're interested in what happens inside computers,

365
00:21:20,730 --> 00:21:24,390
what goes on and saw under the hood a sort of in secret,

366
00:21:24,390 --> 00:21:25,650
when you turn on your computer,

367
00:21:25,710 --> 00:21:27,120
this is a good course to take,

368
00:21:27,510 --> 00:21:29,250
similarly if you like infrastructure

369
00:21:29,250 --> 00:21:33,240
that is if if you enjoy building a sort of services

370
00:21:33,240 --> 00:21:35,910
that other programs can then use them.

371
00:21:36,510 --> 00:21:38,820
This is of course essentially all about infrastructure,

372
00:21:38,820 --> 00:21:41,070
because that's that's what operating systems are.

373
00:21:42,350 --> 00:21:46,670
If you ever need to spend a lot of time tracking down bugs in application code

374
00:21:46,700 --> 00:21:48,500
or tracking down security problems

375
00:21:48,830 --> 00:21:53,360
often that involves understanding what was going on inside the operating system,

376
00:21:53,450 --> 00:21:57,710
because it's ultimately the operating system that enforces a lot of security,

377
00:21:57,710 --> 00:22:00,020
and when things go wrong,

378
00:22:00,020 --> 00:22:02,090
it's the operating system has to pick up the pieces,

379
00:22:02,090 --> 00:22:06,950
so that's often involved in tracking down bugs and finally.

380
00:22:08,000 --> 00:22:09,440
Two more questions from the chat,

381
00:22:09,440 --> 00:22:10,580
so the first is

382
00:22:10,580 --> 00:22:12,620
how important is it for application developers,

383
00:22:12,620 --> 00:22:15,050
to truly deeply understand the operating systems

384
00:22:15,050 --> 00:22:16,730
of developing their applications for,

385
00:22:17,060 --> 00:22:19,100
do they necessarily need to be experts.

386
00:22:19,810 --> 00:22:21,370
You don't have to be an expert,

387
00:22:21,370 --> 00:22:23,830
but if you spend a lot of time

388
00:22:23,830 --> 00:22:26,590
developing and maintaining and debugging applications,

389
00:22:26,650 --> 00:22:30,160
you'll eventually end up knowing a lot about the operating system,

390
00:22:30,160 --> 00:22:32,570
whether you, whether you meant to or not,

391
00:22:32,570 --> 00:22:37,530
just it just comes up and you're often forced to understand.

392
00:22:39,640 --> 00:22:41,080
And the second question is,

393
00:22:41,080 --> 00:22:45,310
do high-level programming languages like python use system calls directly,

394
00:22:45,310 --> 00:22:48,160
are there built in slash wrappers for convenience.

395
00:22:48,710 --> 00:22:53,360
A lot of high-level languages are sort of at one of move from system calls,

396
00:22:53,540 --> 00:22:54,500
that's absolutely true.

397
00:22:54,500 --> 00:22:59,300
So , but partially because a lot of languages

398
00:22:59,330 --> 00:23:02,780
want to provide portable a portable environment,

399
00:23:02,780 --> 00:23:04,430
that works on many different operating systems,

400
00:23:04,430 --> 00:23:06,230
so they can't necessarily commit to

401
00:23:06,230 --> 00:23:09,290
the specific system calls or any one operating system.

402
00:23:09,980 --> 00:23:12,410
So, the answer,

403
00:23:12,410 --> 00:23:13,280
the question I think is

404
00:23:13,280 --> 00:23:14,810
if you use python ,

405
00:23:14,810 --> 00:23:18,790
you're somewhat insulated from the system call interface,

406
00:23:18,790 --> 00:23:20,530
you know internally of course python makes,

407
00:23:20,900 --> 00:23:23,360
has to make system calls get its work done .

408
00:23:23,360 --> 00:23:26,380
And, certainly in python and many other languages,

409
00:23:26,380 --> 00:23:30,740
there is usually a way to get directly at the system calls

410
00:23:30,740 --> 00:23:33,770
whatever your operating system, you're running on.

411
00:23:35,480 --> 00:23:36,740
And folks for questions,

412
00:23:36,740 --> 00:23:39,050
you can just feel free to jump in yourself and ask questions,

413
00:23:39,050 --> 00:23:40,250
you don't need to go through the chat.

414
00:23:43,410 --> 00:23:44,550
Okay .

415
00:23:46,020 --> 00:23:52,300
Alright, sorry, I'm going to spend a couple of minutes now

416
00:23:52,300 --> 00:24:00,130
talking about a class structure of 6.S081,

417
00:24:01,140 --> 00:24:05,160
before switching back to actual technical content.

418
00:24:05,430 --> 00:24:08,370
So there is a website for the course,

419
00:24:08,370 --> 00:24:09,870
which I don't want to write out just now,

420
00:24:09,870 --> 00:24:13,470
but it's you can find it by looking for 6.S081 on Google.

421
00:24:14,280 --> 00:24:23,460
And the website, has a schedule ,

422
00:24:23,980 --> 00:24:28,390
it has the assignments on the schedule that has the lab assignments.

423
00:24:28,740 --> 00:24:31,830
And it has the sort of information about course structure,

424
00:24:31,830 --> 00:24:33,570
like the grading policy on it.

425
00:24:34,240 --> 00:24:38,920
The other big resource you're gonna wanna keep track of piazza.

426
00:24:39,960 --> 00:24:42,720
I guess, everybody was here got here by way piazza,

427
00:24:43,020 --> 00:24:45,600
but as well as ,

428
00:24:45,960 --> 00:24:48,150
so we used periodically for two main things,

429
00:24:48,150 --> 00:24:52,320
one is as a way of people being able to ask questions about the lab assignments,

430
00:24:52,320 --> 00:24:56,180
and a course staff will try to answer these questions,

431
00:24:56,180 --> 00:24:59,690
but you should feel absolutely free to answer each other's questions as well

432
00:25:00,020 --> 00:25:02,270
and the other big thing that happens on piazza,

433
00:25:02,270 --> 00:25:05,180
if there's announcements there's any announcements about the course.

434
00:25:05,500 --> 00:25:07,540
We'll put the announcement on piazza,

435
00:25:07,540 --> 00:25:09,730
so you should keep an eye on piazza for announcements,

436
00:25:09,730 --> 00:25:12,510
even if you're not using it for lab help.

437
00:25:13,580 --> 00:25:13,670
Yeah.

438
00:25:16,700 --> 00:25:20,720
The one of the big parts of course is that these lectures .

439
00:25:24,150 --> 00:25:28,620
Lectures will cover basic ideas of operating systems.

440
00:25:28,860 --> 00:25:36,330
Some of the lectures will be devoted to detailed a study of the code in xv6,

441
00:25:36,330 --> 00:25:38,550
which is our small teaching operating system

442
00:25:39,420 --> 00:25:41,310
and so talk about how it works,

443
00:25:41,310 --> 00:25:44,940
we'll look at the code and show the code executing during lectures,

444
00:25:45,810 --> 00:25:47,880
and in addition, before many of the lectures,

445
00:25:47,880 --> 00:25:50,790
we'll be assignments reading assignments from a book,

446
00:25:51,150 --> 00:25:54,090
that sort of describes how xv6 operates

447
00:25:54,090 --> 00:25:55,950
and why it's designed that way.

448
00:25:56,670 --> 00:25:58,590
So you do the readings before the class,

449
00:25:59,370 --> 00:26:01,950
so they do understand the discussion in the class,

450
00:26:02,400 --> 00:26:04,950
some of the lectures are devoted to background

451
00:26:04,950 --> 00:26:06,420
to help you do the labs.

452
00:26:06,660 --> 00:26:08,910
So, like about C works of,

453
00:26:08,910 --> 00:26:12,750
how the RISC-V which is the microprocessor that we'll be using,

454
00:26:13,200 --> 00:26:17,610
that you'll find helpful in understanding how to do the labs

455
00:26:17,760 --> 00:26:19,290
and towards the end of the course,

456
00:26:19,890 --> 00:26:24,360
we'll spend some lectures discussing some operating system papers,

457
00:26:25,080 --> 00:26:28,020
research papers and some classic papers in the field,

458
00:26:28,320 --> 00:26:31,230
which you will ask that you read before the lecture

459
00:26:31,230 --> 00:26:34,410
and then we'll sort of talk about the papers during the lecture,

460
00:26:34,980 --> 00:26:37,170
for all the lectures are almost all the lectures,

461
00:26:37,290 --> 00:26:40,980
we ask that you submit a question about the reading ,

462
00:26:41,010 --> 00:26:45,090
for the lecture before the actual time of the lecture.

463
00:26:45,300 --> 00:26:49,040
Which many or all of you did for this lecture for which thank you,

464
00:26:49,220 --> 00:26:51,830
and we will read those questions to help us.

465
00:26:52,970 --> 00:26:54,800
Guide us about what to talk about

466
00:26:54,800 --> 00:26:58,040
and we'll try to answer as many of the questions as we can,

467
00:26:58,040 --> 00:27:01,580
although there's rarely time, unfortunately for us to answer all of them.

468
00:27:02,800 --> 00:27:05,830
The next big part of the course of the labs.

469
00:27:06,400 --> 00:27:10,900
There's a programming lab do, almost every week

470
00:27:11,770 --> 00:27:13,000
and the point of the labs is

471
00:27:13,000 --> 00:27:14,650
to help you get hands on experience

472
00:27:14,650 --> 00:27:19,620
with implementing and using operating systems.

473
00:27:20,690 --> 00:27:24,170
A lab that's due next week is

474
00:27:24,170 --> 00:27:27,020
actually about using about writing applications

475
00:27:27,020 --> 00:27:29,030
that make the call the system calls,

476
00:27:29,030 --> 00:27:29,900
we'll be talking about.

477
00:27:31,520 --> 00:27:34,070
Whereas most of those labs after that are involved,

478
00:27:34,070 --> 00:27:37,820
you either implementing basic operating system features

479
00:27:37,820 --> 00:27:43,940
or adding a kernel extensions to the xv6 operating system,

480
00:27:44,780 --> 00:27:46,460
the very last lab and one

481
00:27:46,460 --> 00:27:49,430
in which you actually add a network stack and a network driver,

482
00:27:49,430 --> 00:27:51,500
so you'll be able to connect in over the network

483
00:27:51,500 --> 00:27:53,300
to the operating system that you run.

484
00:27:55,560 --> 00:27:57,990
You should, if you have problems with the lab's,

485
00:27:57,990 --> 00:28:02,810
they'll be office hours that TAs will hold.

486
00:28:02,810 --> 00:28:05,990
In addition you can post questions to piazza

487
00:28:06,230 --> 00:28:09,170
and very often you'll be able to get useful answers from piazza

488
00:28:09,890 --> 00:28:11,810
more quickly than from office hours.

489
00:28:13,060 --> 00:28:16,900
We welcome you discussing the labs talking about the labs,

490
00:28:16,900 --> 00:28:20,410
talking about how to design the lab solutions,

491
00:28:20,410 --> 00:28:23,410
but we ask you please do not look at other people's solutions.

492
00:28:23,680 --> 00:28:26,350
Relapse, please all the code you write should be your own

493
00:28:26,350 --> 00:28:30,490
and you shouldn't share code or a look at other solutions.

494
00:28:32,740 --> 00:28:41,360
Grading, of course , will be mostly determined from the labs this year,

495
00:28:41,480 --> 00:28:49,620
so 70% of the grade will be,  based on whether or not your lab,

496
00:28:49,620 --> 00:28:51,240
you submit passes the tests

497
00:28:51,240 --> 00:28:54,840
and we for grading, we run the same tests that we supply you,

498
00:28:54,840 --> 00:28:57,810
so if your lab passes all the tests that we give you,

499
00:28:57,810 --> 00:28:59,940
the chance to show you that full credit for the lab.

500
00:29:00,500 --> 00:29:06,320
20% of the grade is going to be from lab checkoff meetings

501
00:29:08,030 --> 00:29:11,360
for each of you will pick a couple of randomly selected labs

502
00:29:11,360 --> 00:29:13,040
and one of the teams will talk to you

503
00:29:13,280 --> 00:29:14,990
and ask you questions about your implementation

504
00:29:14,990 --> 00:29:19,330
just to make sure that are you really understand what's going on.

505
00:29:20,180 --> 00:29:21,920
It's a lab check offs.

506
00:29:23,870 --> 00:29:26,240
There's a 10% remaining.

507
00:29:28,040 --> 00:29:33,290
A lot of, kind of be, like a yes or no, one or zero type of thing

508
00:29:33,290 --> 00:29:34,160
or would they be,

509
00:29:35,100 --> 00:29:40,080
like could someone get, like if they answered some of the questions right,

510
00:29:40,080 --> 00:29:41,490
but not all the questions right,

511
00:29:41,490 --> 00:29:44,350
when they get in between, so the grade.

512
00:29:45,060 --> 00:29:46,590
You know I haven't thought this through,

513
00:29:47,380 --> 00:29:50,620
there's certainly room for partial credit, but.

514
00:29:51,310 --> 00:29:53,170
It's not , it won't be binary,

515
00:29:53,440 --> 00:29:56,110
it'll definitely be you can receive partial credit.

516
00:29:56,940 --> 00:29:57,420
Okay.

517
00:29:59,470 --> 00:30:03,070
The last 10% is going to be driven by the homework

518
00:30:03,070 --> 00:30:06,580
and participation during lecture and piazza.

519
00:30:08,900 --> 00:30:14,260
There will be no exams or quizzes this year.

520
00:30:15,150 --> 00:30:17,670
And so what, that means is that most of the ,

521
00:30:18,480 --> 00:30:23,160
you know 90% of the grade is being driven by the lab.

522
00:30:23,160 --> 00:30:26,700
So you should spend a lot of time in the labs,

523
00:30:26,730 --> 00:30:29,610
make sure that you start early

524
00:30:29,610 --> 00:30:33,870
and have enough time to complete them and work out bugs

525
00:30:33,870 --> 00:30:34,980
in order to get full credit.

526
00:30:37,270 --> 00:30:40,000
And you know as a result of that this is going to be a

527
00:30:40,000 --> 00:30:43,510
very kind of hands-on software oriented course.

528
00:30:44,580 --> 00:30:48,530
Any questions about the machinery of the course?

529
00:30:53,760 --> 00:30:56,220
We've got a couple questions in chat.

530
00:30:56,670 --> 00:30:58,800
So the first is a logistical question,

531
00:30:58,950 --> 00:31:03,630
currently 6.S081 isn't listed as usual for the system's concentration in the [],

532
00:31:03,990 --> 00:31:06,180
are there plans added to the list of classes later.

533
00:31:06,180 --> 00:31:09,750
I think for that because it's not an AAGS,

534
00:31:09,750 --> 00:31:10,920
it's an AUS,

535
00:31:10,920 --> 00:31:13,590
it can't be used to fulfill arrange requirements,

536
00:31:13,590 --> 00:31:15,480
so it's not a graduate level class.

537
00:31:15,970 --> 00:31:23,020
But, and then we have is the only homework to submit questions

538
00:31:23,020 --> 00:31:25,450
looking at the calendar that appears to be the case.

539
00:31:28,360 --> 00:31:32,620
Unless I'm forgetting something, I think that's the case, yes.

540
00:31:35,140 --> 00:31:39,250
So have, are there gonna be cutoffs for grades,

541
00:31:39,250 --> 00:31:42,910
like X percent gets in A, Y percent gets a B etc.

542
00:31:43,510 --> 00:31:52,740
No no,  , you know we're going to try to free student estimate.

543
00:31:53,320 --> 00:31:58,630
I'm impression of how well you've understood the material ,

544
00:31:59,250 --> 00:32:00,480
and assign a grade based on that,

545
00:32:00,480 --> 00:32:02,880
so there's no predetermined cut offs.

546
00:32:07,950 --> 00:32:09,840
Alright anything else?

547
00:32:13,660 --> 00:32:18,160
Alright, just real quick for folks in the chat

548
00:32:18,460 --> 00:32:22,600
asking about the concentration requirement,

549
00:32:22,780 --> 00:32:24,820
I'm not a hundred percent certain ,

550
00:32:24,820 --> 00:32:26,770
but 6.S081 is not,

551
00:32:26,890 --> 00:32:30,010
it's a temporary number before the class gets official one,

552
00:32:30,010 --> 00:32:33,100
so it certainly won't be listed anywhere,

553
00:32:33,280 --> 00:32:35,200
if you need it to fulfill a concentration,

554
00:32:35,200 --> 00:32:37,360
I think your best bet is probably to fill out a petition

555
00:32:37,360 --> 00:32:40,270
or to email somebody like Katrina Kurtz,

556
00:32:40,780 --> 00:32:42,730
to see a what the status is,

557
00:32:43,240 --> 00:32:45,840
we don't control, you know,

558
00:32:45,840 --> 00:32:50,010
what what classes fill these kind of requirements, unfortunately.

559
00:32:51,240 --> 00:32:53,700
And for what language will be using the class, will be in C.

560
00:32:58,700 --> 00:33:00,170
Alright, um.

561
00:33:02,400 --> 00:33:03,900
Alright, for the rest of the lecture,

562
00:33:03,900 --> 00:33:07,050
I want to talk about how 

563
00:33:07,050 --> 00:33:10,530
what system calls look like applications .

564
00:33:11,290 --> 00:33:13,660
And you know since the system calls

565
00:33:13,660 --> 00:33:17,860
are the interface to the services that the operating system provides

566
00:33:17,860 --> 00:33:20,890
is actually pretty important what those systems look like,

567
00:33:20,890 --> 00:33:24,280
what applications expect from system calls and how they behave,

568
00:33:24,280 --> 00:33:28,000
so it's worth understanding what the interface looks like.

569
00:33:29,380 --> 00:33:32,590
You'll be using the system calls we talk about in the first lab,

570
00:33:32,960 --> 00:33:37,130
and extending and improving the implementation,

571
00:33:37,160 --> 00:33:40,220
internal implementation of these system calls in subsequent labs.

572
00:33:40,960 --> 00:33:46,390
What we're gonna do is show some simple examples of little programs.

573
00:33:47,980 --> 00:33:53,680
That call system calls and I'll run them in xv6 four you.

574
00:33:54,540 --> 00:33:56,370
I'm gonna run them,

575
00:33:56,370 --> 00:34:01,700
the xv6 is a , it's a unix, a simplified unix like operating system,

576
00:34:01,700 --> 00:34:04,130
unix is a old operating system,

577
00:34:04,130 --> 00:34:09,320
that's at least intellectual basis for many present-day operating systems,

578
00:34:09,320 --> 00:34:12,980
such as Linux and OS X it's in very common use,

579
00:34:14,540 --> 00:34:18,920
xv6 our teaching operating system is much simpler

580
00:34:19,400 --> 00:34:21,650
and sort of inspired by unix

581
00:34:21,650 --> 00:34:23,390
and has the same overall structure,

582
00:34:23,390 --> 00:34:27,860
but is dramatically simpler than any real unix operating system.

583
00:34:30,750 --> 00:34:32,850
It's simple enough that hopefully,

584
00:34:33,120 --> 00:34:36,600
you know it would be relatively straightforward,

585
00:34:36,600 --> 00:34:38,460
for you to read all the source code,

586
00:34:38,550 --> 00:34:39,840
as well as read the book,

587
00:34:40,080 --> 00:34:41,640
in a couple of weeks.

588
00:34:41,640 --> 00:34:42,780
Certainly during the semester

589
00:34:42,780 --> 00:34:47,100
in order to kind of understand all of what happens inside xv6.

590
00:34:49,680 --> 00:34:54,720
xv6 runs on the RISC-V processor, RISC-V microprocessor,

591
00:34:54,870 --> 00:34:59,340
and this is the same microprocessor that's the focus of recent 6.004.

592
00:34:59,800 --> 00:35:04,960
So many of you may actually know quite a bit about the RISC-V instruction set.

593
00:35:05,780 --> 00:35:10,670
In theory you could run xv6 on top of a RISC-V computer

594
00:35:11,510 --> 00:35:13,880
and people done that .

595
00:35:14,560 --> 00:35:18,850
But we're going to run it under the QEMU machine emulator,

596
00:35:18,910 --> 00:35:20,410
just write this down we got.

597
00:35:20,810 --> 00:35:23,180
Our operating system is xv6,

598
00:35:23,570 --> 00:35:27,800
runs on RISC-V microprocessor

599
00:35:28,220 --> 00:35:30,350
and not just RISC-V microprocessor,

600
00:35:30,350 --> 00:35:32,870
but we assume a certain amount of surrounding hardware,

601
00:35:32,870 --> 00:35:35,930
like a memory and a disk,

602
00:35:36,280 --> 00:35:40,030
and console interface for us to talk to it .

603
00:35:40,740 --> 00:35:46,640
We actually run under the QEMU machine simulator.

604
00:35:48,440 --> 00:35:50,210
So that which runs under Linux.

605
00:35:50,210 --> 00:35:55,860
So all you can actually run xv6 without having that hardware.

606
00:35:56,860 --> 00:36:01,000
Okay, so kind of switch to show the code.

607
00:36:15,570 --> 00:36:18,720
Alright, so, first thing is,

608
00:36:18,720 --> 00:36:22,410
I've setup xv6 on my laptop,

609
00:36:22,800 --> 00:36:25,740
I'm going to run it type make qemu,

610
00:36:25,740 --> 00:36:28,140
but you'll find yourself doing quite a bit during the labs,

611
00:36:28,320 --> 00:36:30,960
which compiles xv6 it's written in C,

612
00:36:30,960 --> 00:36:33,480
so it's compiled with C compiler,

613
00:36:33,990 --> 00:36:36,570
maybe I'll make clean for you,

614
00:36:36,930 --> 00:36:38,730
so you can see the actual compilation

615
00:36:39,000 --> 00:36:40,620
and I might make qemu,

616
00:36:40,620 --> 00:36:44,820
which has the effect of compiling and building xv6 kernel

617
00:36:44,820 --> 00:36:46,470
and all the user processes

618
00:36:47,010 --> 00:36:49,920
and then running them under the QEMU emulator.

619
00:36:51,860 --> 00:36:53,720
Takes a moment around the compiles.

620
00:36:55,020 --> 00:36:55,080
Yeah.

621
00:36:56,000 --> 00:36:59,090
And now we're up and running xv6,

622
00:36:59,090 --> 00:37:01,700
and the dollar sign prompt you see as the shell,

623
00:37:02,270 --> 00:37:05,990
which is the command line interface to xv6,

624
00:37:05,990 --> 00:37:08,360
modeled after the shell on unix,

625
00:37:08,360 --> 00:37:12,120
which is if you log into Athena organization

626
00:37:12,120 --> 00:37:15,750
and it's it's like the shell that Athena shows you.

627
00:37:18,180 --> 00:37:23,100
Xv6 itself tiny and it comes with a small number of utility programs,

628
00:37:23,130 --> 00:37:25,960
and including for example the ls program

629
00:37:25,960 --> 00:37:31,080
which about to run run ls and it gives me a list of all the files

630
00:37:31,080 --> 00:37:33,300
and xv6 of which there are only about two dozen

631
00:37:34,020 --> 00:37:39,500
including things like grep and kill and mkdir rm,

632
00:37:39,560 --> 00:37:43,390
which may be familiar to us as unix utilities.

633
00:37:44,930 --> 00:37:46,640
Okay, the first program, I'm gonna show you

634
00:37:46,640 --> 00:37:51,770
to illustrate system calls is a program called copy.

635
00:38:01,900 --> 00:38:03,580
Here's the source is just a page.

636
00:38:07,320 --> 00:38:12,120
So what you're seeing here is a program that starts on line eight

637
00:38:12,120 --> 00:38:15,150
and main is that sort of convention for C programs,

638
00:38:15,510 --> 00:38:17,370
it sits in a loop at line twelve,

639
00:38:17,940 --> 00:38:19,290
and over and over again,

640
00:38:19,710 --> 00:38:23,820
it reads some data as input and on line thirteen,

641
00:38:23,820 --> 00:38:27,900
and then writes the data just read his output on line sixteen.

642
00:38:28,390 --> 00:38:35,550
By run copy, in xv6, it's waitng to read input,

643
00:38:35,550 --> 00:38:37,320
if I type some input,

644
00:38:37,840 --> 00:38:39,970
reads it and spits it back up to me.

645
00:38:41,640 --> 00:38:43,410
Very simple program just does io.

646
00:38:44,950 --> 00:38:48,880
It's really see as I mentioned, if you don't already know C,

647
00:38:48,880 --> 00:38:50,080
it's worthwhile getting

648
00:38:50,080 --> 00:38:54,820
the standard C programming language book by Kernighan and Ritchie.

649
00:38:55,180 --> 00:39:00,330
And I think there's a more full reference to it on the course website

650
00:39:00,840 --> 00:39:05,100
which explains to you and very straightforward way how to program in C.

651
00:39:06,140 --> 00:39:09,200
Yeah, as I mentioned before,

652
00:39:09,200 --> 00:39:10,580
we even write this program

653
00:39:10,580 --> 00:39:13,070
makes two really three system calls

654
00:39:13,070 --> 00:39:15,950
read, write and exit, our system calls.

655
00:39:16,460 --> 00:39:19,790
If you look at the call to read on line thirteen,

656
00:39:20,090 --> 00:39:21,470
it takes three arguments,

657
00:39:22,500 --> 00:39:23,970
the first argument is a file descriptor

658
00:39:23,970 --> 00:39:26,700
which is really a reference to a previously opened file.

659
00:39:27,340 --> 00:39:32,230
And the shell, ensures that when a program starts,

660
00:39:32,230 --> 00:39:36,860
by default it's file descriptor zero is connected to the console input

661
00:39:36,860 --> 00:39:41,480
and its file descriptor one is connected to the console output

662
00:39:41,480 --> 00:39:46,620
and that's why I was able to type to this copy program and see the output.

663
00:39:48,700 --> 00:39:52,660
You know these file descriptors are expected

664
00:39:52,660 --> 00:39:55,630
the program expected these file descriptors have been previously opened

665
00:39:55,630 --> 00:39:57,160
and set up by the shell for it.

666
00:39:57,600 --> 00:40:03,480
And zero one file descriptors, pervasive unix convention,

667
00:40:03,480 --> 00:40:05,220
many, many unix programs expect to

668
00:40:05,220 --> 00:40:07,440
[read from file descriptor one]

669
00:40:07,440 --> 00:40:11,190
and read file descriptor zero and write to file descriptor one.

670
00:40:12,730 --> 00:40:16,540
A second argument to read is a pointer to some memory.

671
00:40:17,160 --> 00:40:19,500
Where the program is asking the operating system

672
00:40:19,500 --> 00:40:22,710
to read data into that address in memory,

673
00:40:22,710 --> 00:40:23,970
so that's the buf argument

674
00:40:24,630 --> 00:40:29,750
and line ten allocate 64 bytes of memory on the stack ,

675
00:40:30,350 --> 00:40:31,520
for read to read into.

676
00:40:31,700 --> 00:40:33,110
And the third argument to read is

677
00:40:33,110 --> 00:40:36,080
the maximum number of bytes that the program wants to read

678
00:40:36,470 --> 00:40:40,370
and the size of buf as just sixty maximum 64 bytes,

679
00:40:40,730 --> 00:40:42,830
so the read call reads up to 64 bytes

680
00:40:42,830 --> 00:40:45,860
from whatever is connected to file descriptor zero

681
00:40:45,860 --> 00:40:48,520
and that was my terminal in this example,

682
00:40:48,820 --> 00:40:54,190
the return value from read it either it may be sure of the number of bytes read,

683
00:40:54,640 --> 00:40:58,240
which would be six and a piece of ,

684
00:40:58,240 --> 00:40:59,740
typing xyzzy by.

685
00:41:01,150 --> 00:41:02,800
Read might be reading from a file,

686
00:41:02,830 --> 00:41:04,090
if it gets to the end of the file,

687
00:41:04,090 --> 00:41:05,110
there's no more bytes,

688
00:41:05,110 --> 00:41:06,370
read will return zero.

689
00:41:07,160 --> 00:41:08,900
And then some other error occurred,

690
00:41:08,900 --> 00:41:11,180
like the file descriptor doesn't exist,

691
00:41:11,420 --> 00:41:13,160
read may return minus one.

692
00:41:13,780 --> 00:41:17,560
And so in many of these examples like on line sixteen there.

693
00:41:17,940 --> 00:41:23,190
I don't, my example code doesn't check system call returns for errors.

694
00:41:24,540 --> 00:41:27,540
But you should be more careful than me  ,

695
00:41:27,540 --> 00:41:30,750
the you should figure out how system calls reflect errors,

696
00:41:30,750 --> 00:41:32,640
it's usually a minus one return value

697
00:41:32,970 --> 00:41:36,360
and check all system called returns for errors.

698
00:41:37,280 --> 00:41:41,360
And if you want to know what the system call arguments and return values are,

699
00:41:41,360 --> 00:41:44,210
there's a table and I think chapter two in the book,

700
00:41:45,140 --> 00:41:51,810
explains all of the xv6 system call arguments and return values.

701
00:41:52,770 --> 00:41:55,230
The question regarding the read syscall.

702
00:41:55,440 --> 00:41:57,870
What if we set the max read bytes to

703
00:41:57,870 --> 00:42:01,200
size of buf to one plus size of buf big,

704
00:42:01,500 --> 00:42:03,030
so what if we try to read more than the size.

705
00:42:03,030 --> 00:42:06,870
Yeah, then if there was 65 bytes to read,

706
00:42:06,900 --> 00:42:09,330
then the operating system would happily

707
00:42:09,330 --> 00:42:14,750
will just copy those sixty-five bytes to the memory that you provide,

708
00:42:14,780 --> 00:42:18,020
and of course there's something else on the stack up there,

709
00:42:18,050 --> 00:42:20,150
maybe the return program counter

710
00:42:20,150 --> 00:42:21,410
or an argument or something

711
00:42:21,560 --> 00:42:23,570
and so if you pass 65,

712
00:42:23,930 --> 00:42:25,460
then you're inviting a kernel

713
00:42:25,460 --> 00:42:29,550
to write junk to an unexpected place in your stack.

714
00:42:30,280 --> 00:42:31,360
And so that's a bug

715
00:42:31,840 --> 00:42:33,940
and it may cause your [] to crash,

716
00:42:34,420 --> 00:42:36,340
or do something else unexpected,

717
00:42:37,390 --> 00:42:39,580
so as a programmer, you have to be careful here,

718
00:42:39,580 --> 00:42:42,940
there's nobody writing in C with these kind of interfaces,

719
00:42:43,830 --> 00:42:46,890
it's very very easy to write code

720
00:42:46,920 --> 00:42:49,200
that the compiler is happy with and will run

721
00:42:49,200 --> 00:42:51,000
but absolutely does the wrong thing.

722
00:42:51,660 --> 00:42:57,120
So that's too bad but it's the way it is.

723
00:43:00,540 --> 00:43:02,490
Okay, one thing to note is

724
00:43:02,490 --> 00:43:06,450
that this copy program and indeed the read write system calls,

725
00:43:06,720 --> 00:43:08,460
they don't care about the format of data,

726
00:43:08,460 --> 00:43:09,480
they're reading or writing

727
00:43:09,660 --> 00:43:13,440
they just read and write read and write in this copy program.

728
00:43:13,980 --> 00:43:17,340
Just deal with eight bit bytes with screams of eight bit bytes.

729
00:43:17,680 --> 00:43:21,220
How you interpret them is totally up to the application,

730
00:43:21,220 --> 00:43:26,840
so the application maybe parse these data records or as C source code,

731
00:43:26,840 --> 00:43:27,680
or who knows what.

732
00:43:28,890 --> 00:43:35,460
The operating system , the only things in terms of a stream of eight bit bytes.

733
00:43:36,220 --> 00:43:39,940
Okay, so copy, assumed this code, my copy I can assume

734
00:43:39,940 --> 00:43:42,670
that the file descriptors are already set up ,

735
00:43:42,850 --> 00:43:46,000
but we need to need to have a way to create file descriptors.

736
00:43:46,280 --> 00:43:51,680
And the most straightforward way to do that is with the open system call,

737
00:43:51,710 --> 00:43:55,160
and so here's the source for a program that called open,

738
00:43:55,720 --> 00:43:56,920
That ,

739
00:43:58,120 --> 00:43:59,770
I use the open system call.

740
00:44:00,250 --> 00:44:01,570
A question from the chat,

741
00:44:01,600 --> 00:44:04,570
what do you mean by a stream of bytes.

742
00:44:07,190 --> 00:44:11,840
I I just mean that if a file contains a bunch of bytes,

743
00:44:12,180 --> 00:44:16,470
then read then successive spilling a pile contains a million bytes,

744
00:44:16,860 --> 00:44:19,200
if you make a sequence of read calls,

745
00:44:19,200 --> 00:44:20,670
each for 100 bytes,

746
00:44:21,160 --> 00:44:22,900
you know I'll just read the first hundred bytes

747
00:44:22,900 --> 00:44:24,100
and then the second hundred bytes and

748
00:44:24,100 --> 00:44:25,810
then third, the third hundred bytes,

749
00:44:27,960 --> 00:44:28,590
That's all.

750
00:44:32,000 --> 00:44:36,020
Alright, so this program, called open, I'll run it for you.

751
00:44:36,720 --> 00:44:41,940
What it does is open creates a new file called output.txt,

752
00:44:41,940 --> 00:44:43,980
and then write some bytes to it,

753
00:44:44,520 --> 00:44:45,690
I'm gonna finish this,

754
00:44:45,690 --> 00:44:46,620
so we don't see anything,

755
00:44:46,620 --> 00:44:48,690
because it broke data, this file,

756
00:44:48,690 --> 00:44:53,100
open, but we can look this output.txt file that created it,

757
00:44:53,490 --> 00:44:57,240
and see the "ooo" wrote there,

758
00:44:57,390 --> 00:45:02,020
so an eleven in the program makes the open system call,

759
00:45:02,380 --> 00:45:04,750
give it a filename output.txt

760
00:45:04,750 --> 00:45:10,240
and the O underscore stuff in the second argument to open or flags

761
00:45:10,240 --> 00:45:13,930
that tell the open system call implementation in the kernel,

762
00:45:13,930 --> 00:45:17,590
that we'd like to create a file with its name and we're going to write it,

763
00:45:18,860 --> 00:45:21,710
open returns a newly allocated file descriptor.

764
00:45:23,740 --> 00:45:25,600
And the file descriptor is just a small number,

765
00:45:25,810 --> 00:45:27,400
probably two or three or four something.

766
00:45:28,430 --> 00:45:32,270
And then we pass that same file descriptor right along with the buffer

767
00:45:32,270 --> 00:45:36,410
and a number of ways to write that writes data,

768
00:45:37,040 --> 00:45:39,770
the file, the file descriptor refers to.

769
00:45:41,430 --> 00:45:43,860
What that file descriptor is actually doing is

770
00:45:43,860 --> 00:45:49,410
indexing into a little table inside the kernel maintains state for each process,

771
00:45:49,410 --> 00:45:52,620
that's running each program that you run and among other things,

772
00:45:52,620 --> 00:45:54,180
the kernel remembers a table

773
00:45:54,180 --> 00:45:58,500
for every running process of index by file descriptors

774
00:45:58,830 --> 00:46:03,420
and the table sort of tells the kernel what each file descriptor refers to.

775
00:46:05,040 --> 00:46:10,960
Okay, a critical point is that each process

776
00:46:10,960 --> 00:46:14,350
has its own sort of space of file descriptors.

777
00:46:14,350 --> 00:46:17,420
So, before running two different processes,

778
00:46:17,420 --> 00:46:19,460
two different programs and different processes

779
00:46:19,640 --> 00:46:20,990
and they both open a file,

780
00:46:20,990 --> 00:46:24,080
they may actually get the same number back as a file descriptor,

781
00:46:24,350 --> 00:46:28,700
but because the kernel maintains a separate file descriptor for each process,

782
00:46:29,080 --> 00:46:31,750
The same file descriptor number may refer to

783
00:46:31,750 --> 00:46:34,570
different files in different processes.

784
00:46:37,040 --> 00:46:39,350
Any questions that open about this little program.

785
00:46:40,240 --> 00:46:41,620
Now we had a question in the chat,

786
00:46:41,620 --> 00:46:43,720
question from someone not familiar with C,

787
00:46:43,990 --> 00:46:47,830
how are these files being described different from normal C programs,

788
00:46:47,830 --> 00:46:50,470
is it because we're only using kernel calls,

789
00:46:50,470 --> 00:46:53,710
i.e couldn't we also open or write a file in python.

790
00:46:59,440 --> 00:47:00,820
I don't think I understand that,

791
00:47:02,000 --> 00:47:04,160
it's a C program, that's opening and writing a file,

792
00:47:15,620 --> 00:47:17,750
that's going to move on.

793
00:47:20,640 --> 00:47:26,310
Alright so you might ask what actually happens when.

794
00:47:26,310 --> 00:47:27,570
Maybe the question is

795
00:47:27,570 --> 00:47:30,120
when someone is doing it in C,

796
00:47:30,120 --> 00:47:33,090
any different than doing it in python minus the syntax.

797
00:47:34,240 --> 00:47:37,810
Well it's not really, um.

798
00:47:38,620 --> 00:47:42,840
And, there's certainly ways to, um.

799
00:47:44,410 --> 00:47:49,480
Python provides nice function calls for opening and doing all these things too.

800
00:47:50,830 --> 00:47:54,040
Or opening files, for example in reading writing files ,

801
00:47:54,310 --> 00:47:58,540
there's a layer of a higher somewhat higher level functions typically,

802
00:47:58,870 --> 00:48:01,660
not pointers the memory, for example.

803
00:48:03,690 --> 00:48:06,420
And python has more error checking for you,

804
00:48:07,140 --> 00:48:09,840
but when you open a file in python

805
00:48:09,840 --> 00:48:11,010
or write a file on python,

806
00:48:11,010 --> 00:48:17,840
the python calls you make boil down to system calls just like these.

807
00:48:19,840 --> 00:48:21,220
Is that a good answer.

808
00:48:25,860 --> 00:48:26,520
Think so.

809
00:48:27,030 --> 00:48:27,420
Alright.

810
00:48:30,980 --> 00:48:32,270
Alright .

811
00:48:33,560 --> 00:48:36,350
I've been over here talking to the ,

812
00:48:39,120 --> 00:48:43,140
xv6 is unix, like shell

813
00:48:43,440 --> 00:48:46,500
and the shell is what people often call the command line interface,

814
00:48:46,890 --> 00:48:50,610
as opposed to more graphical user interface.

815
00:48:51,240 --> 00:48:53,370
The shell turns,

816
00:48:53,370 --> 00:48:54,450
if you haven't used the shell,

817
00:48:54,450 --> 00:48:57,450
the shell turns out to be a pretty useful interface

818
00:48:57,450 --> 00:49:00,270
for things like system management of unix systems,

819
00:49:01,440 --> 00:49:02,940
it provides a lot of utilities

820
00:49:02,940 --> 00:49:06,480
for messing around with files and for program development

821
00:49:06,480 --> 00:49:09,510
and on writing scripts to do all these things.

822
00:49:09,510 --> 00:49:12,030
So, some before run.

823
00:49:12,550 --> 00:49:14,620
I just want to demonstrate a few shell features.

824
00:49:14,650 --> 00:49:17,290
Ordinarily, when you type things ,

825
00:49:17,770 --> 00:49:20,080
you're telling the shell to run a program,

826
00:49:20,080 --> 00:49:21,100
so when I type ls,

827
00:49:21,100 --> 00:49:26,790
what that means is I'm asking the shell to run the program whose name is ls

828
00:49:26,790 --> 00:49:28,290
and what that really means is

829
00:49:28,290 --> 00:49:31,710
there's a file in the file system called ls,

830
00:49:31,710 --> 00:49:34,890
that contains some instructions, some machine instructions

831
00:49:35,250 --> 00:49:40,170
and I'm asking the shell to run the instructions that are in the file called ls,

832
00:49:40,770 --> 00:49:44,430
ls, now ls what it actually does is ,

833
00:49:44,940 --> 00:49:47,220
get a listing of the files in the current directory,

834
00:49:47,250 --> 00:49:49,230
and you can see up there on the fourth line,

835
00:49:49,620 --> 00:49:54,420
that among the other files that ls as exists,

836
00:49:54,420 --> 00:49:55,380
and this list is,

837
00:49:55,380 --> 00:49:57,660
a file called ls which is in fact

838
00:49:58,140 --> 00:50:00,120
the file containing the instructions I just ran.

839
00:50:02,370 --> 00:50:05,340
The shell does a few other things for you other than running programs

840
00:50:06,360 --> 00:50:08,160
allows you to redirect io,

841
00:50:08,490 --> 00:50:11,040
so for example if I say ls greater than out,

842
00:50:11,100 --> 00:50:14,670
what that means is asking the shell run the ls command,

843
00:50:15,030 --> 00:50:17,940
but with its output redirected to the file called out.

844
00:50:18,520 --> 00:50:22,130
I run ls, we don't see any output,

845
00:50:22,340 --> 00:50:23,840
because the output all went out.

846
00:50:24,960 --> 00:50:28,380
Now, I can, out contains a bunch of data,

847
00:50:28,530 --> 00:50:30,090
we could,

848
00:50:30,900 --> 00:50:35,430
the cat command reads a file and displays the contents of the file,

849
00:50:35,430 --> 00:50:36,720
so I say cat out.

850
00:50:37,190 --> 00:50:40,790
Just going to see now the now this is the same output of ls.

851
00:50:41,170 --> 00:50:42,790
You can also run a command like grep

852
00:50:42,790 --> 00:50:46,060
and I can give it an argument x and what grep x.

853
00:50:46,520 --> 00:50:48,440
The grep command searches for patterns.

854
00:50:49,080 --> 00:50:52,830
Again if I run grep x,

855
00:50:52,830 --> 00:50:57,050
it's gonna search for lines of input to contain x,

856
00:50:57,380 --> 00:50:58,250
I can redirect,

857
00:50:58,250 --> 00:51:01,190
tell the shell to redirect its input from the file out.

858
00:51:01,700 --> 00:51:05,720
In order to look for instances of x that saved ls output.

859
00:51:07,150 --> 00:51:11,920
It turns out there's three files whose names contain x.

860
00:51:14,000 --> 00:51:14,630
Um.

861
00:51:15,560 --> 00:51:17,420
We're going to spend a bunch of time with the shell,

862
00:51:17,450 --> 00:51:26,540
 its shell is sort of the most traditional and fundamental interface of unix,

863
00:51:26,540 --> 00:51:28,250
because when unix was first developed,

864
00:51:28,250 --> 00:51:30,860
all there was was simple terminal interfaces,

865
00:51:30,860 --> 00:51:32,540
like the one we're using

866
00:51:32,540 --> 00:51:36,290
and the main use of unix originally was time sharing,

867
00:51:36,290 --> 00:51:38,510
a bunch of people logging into the same machine,

868
00:51:38,540 --> 00:51:41,780
much like Athena and talking to shells.

869
00:51:43,300 --> 00:51:47,650
A question about system calls and the compiler,

870
00:51:47,860 --> 00:51:49,750
how does the compiler handles system calls,

871
00:51:49,750 --> 00:51:52,030
does assembly generated make a procedure call

872
00:51:52,030 --> 00:51:55,210
to some code segment, defined by the operating system.

873
00:51:57,020 --> 00:51:59,780
There's a special RISC-V instruction,

874
00:51:59,780 --> 00:52:02,750
that a program can call that transfers control under the kernel,

875
00:52:02,840 --> 00:52:06,350
so indeed when you write C code that makes the system call,

876
00:52:06,350 --> 00:52:08,060
like open and write

877
00:52:08,600 --> 00:52:14,150
and technically what actually happens is open is a C function in the C library,

878
00:52:14,620 --> 00:52:19,630
but the instructions in that function are really machine instructions,

879
00:52:19,630 --> 00:52:24,280
it's not open, the open function that we calling isn't a C function,

880
00:52:24,490 --> 00:52:25,720
implemented in assembler

881
00:52:25,960 --> 00:52:30,980
and the assembly code consists of

882
00:52:30,980 --> 00:52:35,010
this special instructions actually called ecall, on RISC-V,

883
00:52:35,010 --> 00:52:38,450
the special instruction that transfers control into the kernel,

884
00:52:38,900 --> 00:52:42,290
and then the kernel looks at the processes memory and registers

885
00:52:42,290 --> 00:52:44,890
to figure out what the arguments were.

886
00:52:50,610 --> 00:52:56,850
Alright the next example, I want to look at is example program that calls fork.

887
00:52:58,420 --> 00:53:04,690
Creating process, so this is the very simple use of fork,

888
00:53:04,690 --> 00:53:06,940
at line twelve we're calling fork

889
00:53:06,940 --> 00:53:08,170
and what fork does is

890
00:53:08,670 --> 00:53:14,490
creates a copy of the memory of instructions and data of the calling process,

891
00:53:14,490 --> 00:53:17,430
now we have two processes with identical memory.

892
00:53:18,010 --> 00:53:21,760
Fork the fork system call returns in both processes,

893
00:53:22,360 --> 00:53:23,920
in the original process,

894
00:53:24,430 --> 00:53:27,130
the fork system call returns the process id

895
00:53:27,130 --> 00:53:30,640
which is a an integer greater than zero,

896
00:53:32,100 --> 00:53:36,240
the original process fork returns the process id of the newly created process

897
00:53:36,750 --> 00:53:40,590
and in the newly created process fork returns a zero.

898
00:53:41,630 --> 00:53:44,660
So we sort of break even though the processes have identical memory,

899
00:53:45,230 --> 00:53:47,270
you can break the symmetry of

900
00:53:47,720 --> 00:53:50,570
old versus new process by the return value from fork.

901
00:53:50,940 --> 00:53:54,660
And in line sixteen, you can see code checks and say

902
00:53:54,660 --> 00:53:57,150
if the process id is equal zero must be the child,

903
00:53:57,180 --> 00:53:58,710
you must now be running in the child.

904
00:53:59,420 --> 00:54:01,640
Of course there's two processes,

905
00:54:01,640 --> 00:54:04,670
in the other process, in the calling process,

906
00:54:04,670 --> 00:54:08,240
which is usually called the parent, process id is greater than zero.

907
00:54:08,640 --> 00:54:13,230
So the child will print child and the parent will print parent,

908
00:54:14,350 --> 00:54:16,480
and then they'll both exit.

909
00:54:16,810 --> 00:54:17,890
So when I run fork,

910
00:54:19,380 --> 00:54:24,300
now here we get , so it may look like garbage.

911
00:54:25,230 --> 00:54:26,310
What's actually happening is

912
00:54:26,310 --> 00:54:29,190
that after the fork, both of these processes are running,

913
00:54:29,220 --> 00:54:30,900
they're both running at the same time

914
00:54:31,080 --> 00:54:36,890
and QEMU is actually emulating a multi core microprocessor for me,

915
00:54:36,890 --> 00:54:40,280
so they really are running at the very same time,

916
00:54:40,280 --> 00:54:41,450
so when they produce output,

917
00:54:41,850 --> 00:54:43,620
they're producing each byte of their output

918
00:54:43,620 --> 00:54:45,390
at the same time as the other process is,

919
00:54:45,390 --> 00:54:47,220
producing the corresponding bytes of its output,

920
00:54:47,670 --> 00:54:51,690
so the output of the two processes are interleave.

921
00:54:52,260 --> 00:54:54,330
You can see that they're both typing f,

922
00:54:54,800 --> 00:54:57,050
they're both gonna type for return.

923
00:54:57,800 --> 00:54:59,720
So you can see the f from both of them,

924
00:54:59,720 --> 00:55:02,180
in the o both of them and they r both and so on.

925
00:55:02,920 --> 00:55:03,790
One of them,

926
00:55:04,700 --> 00:55:07,460
you can see the zero at the end of that first line is,

927
00:55:07,880 --> 00:55:09,740
in the child for return zero.

928
00:55:10,100 --> 00:55:14,480
I'm guessing that the parent fork return nineteen,

929
00:55:14,960 --> 00:55:17,510
that is the child's process id nineteen,

930
00:55:17,810 --> 00:55:20,510
under xv6, that basically means the nineteenth process

931
00:55:20,510 --> 00:55:22,250
that was created since boot.

932
00:55:22,860 --> 00:55:25,500
And then one of them prints child

933
00:55:25,890 --> 00:55:27,870
and you can see the c h i l d,

934
00:55:27,870 --> 00:55:30,120
interleave with that is the other one print parent.

935
00:55:30,670 --> 00:55:34,520
So, yeah, this is a silly use of fork,

936
00:55:34,550 --> 00:55:37,310
but we can see vividly in this output

937
00:55:37,310 --> 00:55:39,290
that has created two processes that are.

938
00:55:39,920 --> 00:55:42,110
And both of them are running for returning

939
00:55:42,110 --> 00:55:43,520
both processes and they're both running.

940
00:55:44,710 --> 00:55:47,410
But also note that one printed child and the other parent,

941
00:55:48,490 --> 00:55:53,150
so it's important that fork returns differently and the two processes.

942
00:55:59,680 --> 00:56:01,390
Question ,

943
00:56:01,390 --> 00:56:05,290
the child process as a result of fork always identical to the parent process

944
00:56:05,290 --> 00:56:06,400
or could they be different.

945
00:56:08,250 --> 00:56:13,260
 In xv6 are identical,

946
00:56:13,740 --> 00:56:16,830
except the return value from fork.

947
00:56:17,260 --> 00:56:18,880
You know the instructions are the same,

948
00:56:18,880 --> 00:56:21,850
that data is the same, the stack is the same,

949
00:56:22,090 --> 00:56:27,560
also both processes, the process copies

950
00:56:27,560 --> 00:56:31,210
and they both have their own separate address spaces,

951
00:56:31,210 --> 00:56:35,530
that is they both have they both think that their memory starts at zero

952
00:56:35,530 --> 00:56:36,820
and goes on up from there,

953
00:56:37,400 --> 00:56:43,600
but it's different it's different different memory, with the two of them.

954
00:56:45,030 --> 00:56:46,680
In a more sophisticated operating system,

955
00:56:46,680 --> 00:56:51,030
there are some details which we definitely don't care about them,

956
00:56:51,060 --> 00:56:54,180
they may occasionally cause parent and child to differ,

957
00:56:54,210 --> 00:56:56,580
but in xv6, they're the same except the return value.

958
00:56:57,880 --> 00:56:59,410
So the memory is the same,

959
00:56:59,410 --> 00:57:04,530
in addition the file descriptor table is copied.

960
00:57:05,260 --> 00:57:08,680
So if the parent had some files open,

961
00:57:09,140 --> 00:57:13,220
and the child sees the same set of file descriptors.

962
00:57:13,800 --> 00:57:15,840
Although the child is seeing them

963
00:57:15,840 --> 00:57:19,640
in a copy of the table of file descriptor information.

964
00:57:21,550 --> 00:57:23,710
And so we'll see in a moment, that it's quite important

965
00:57:23,710 --> 00:57:29,140
that a fork copies the table of open file descriptors as well as the memory.

966
00:57:31,340 --> 00:57:34,980
Okay, so fork creates a new process,

967
00:57:34,980 --> 00:57:38,250
but when we run stuff in the shell ,

968
00:57:39,030 --> 00:57:42,960
the shell indeed creates a new process to run each command that you type,

969
00:57:43,320 --> 00:57:45,120
but it needs to actually run the command in it,

970
00:57:45,330 --> 00:57:46,890
so if I type ls,

971
00:57:47,160 --> 00:57:50,790
we need to shell forks to create a process to run ls,

972
00:57:50,790 --> 00:57:55,360
but there needs to be some way for that new process

973
00:57:55,360 --> 00:57:57,910
actually run the instructions from the ls program.

974
00:57:58,510 --> 00:58:00,970
Below those instructions from the file called ls

975
00:58:02,320 --> 00:58:04,690
and the example program, I'm gonna show you in a minute.

976
00:58:05,320 --> 00:58:06,310
Uses echo,

977
00:58:06,310 --> 00:58:08,860
echo is a very simple command ,

978
00:58:09,070 --> 00:58:11,080
just takes whatever arguments you pass to it

979
00:58:11,080 --> 00:58:12,580
and writes them to its output.

980
00:58:13,860 --> 00:58:16,470
And I prepared for you a programme called exec.

981
00:58:22,880 --> 00:58:28,390
Which a run, which makes the exec system call,

982
00:58:28,390 --> 00:58:32,350
which replaces the calling process with the instructions

983
00:58:32,350 --> 00:58:35,440
read from a particular file, you specify.

984
00:58:37,110 --> 00:58:39,210
Loads the instructions from that file

985
00:58:39,240 --> 00:58:42,720
over the current process and discarding its current memory

986
00:58:42,990 --> 00:58:45,600
and then starts executing those instructions,

987
00:58:45,600 --> 00:58:49,500
so the call to exec system call exact on line twelve,

988
00:58:52,620 --> 00:58:53,880
it's going to have the effect of

989
00:58:53,940 --> 00:58:57,600
the operating system loading the instructions from the file called echo.

990
00:58:57,980 --> 00:59:02,360
In the current process sort of replacing the memory of the current process

991
00:59:02,690 --> 00:59:06,340
and then starting to execute those instructions

992
00:59:06,340 --> 00:59:09,550
and in addition, you can pass arguments command line arguments,

993
00:59:09,550 --> 00:59:13,960
echo exec allows you to pass an array of command line arguments.

994
00:59:14,670 --> 00:59:16,620
It was just an array of pointers in C,

995
00:59:17,040 --> 00:59:20,860
line ten sets up an array of character pointers,

996
00:59:20,860 --> 00:59:22,180
which are essentially strings

997
00:59:22,600 --> 00:59:24,580
and initialize that array to be,

998
00:59:25,040 --> 00:59:29,120
to contain the strings echo this is echo .

999
00:59:29,480 --> 00:59:32,360
And that's equivalent to calling running echo command

1000
00:59:32,360 --> 00:59:34,170
and with the three arguments,

1001
00:59:34,170 --> 00:59:34,920
this is echo.

1002
00:59:35,340 --> 00:59:41,980
And so when I run exec, indeed, I see this output, this is echo,

1003
00:59:41,980 --> 00:59:45,670
but even though I ran the exec command exec program,

1004
00:59:45,980 --> 00:59:49,370
what the exec program does is calling the exec system call

1005
00:59:49,490 --> 00:59:50,900
to replace itself with echo

1006
00:59:51,080 --> 00:59:52,880
and so it was really the echo program,

1007
00:59:53,320 --> 00:59:55,000
producing this output.

1008
00:59:58,600 --> 01:00:02,920
And something about the exec system call, that's important for us is that

1009
01:00:03,280 --> 01:00:08,170
it exec preserves the current table of file descriptors,

1010
01:00:08,380 --> 01:00:12,940
so whatever file descriptor zero one two etc were referred to before exec,

1011
01:00:13,240 --> 01:00:17,170
they refer to the same thing in this new program,

1012
01:00:17,670 --> 01:00:18,990
whose instructions we've loaded.

1013
01:00:20,220 --> 01:00:23,370
Another point is that ordinarily exec does not return,

1014
01:00:23,610 --> 01:00:28,440
because exec replaces the current processes memory entirely,

1015
01:00:28,530 --> 01:00:30,540
there's nothing for exec to return,

1016
01:00:30,540 --> 01:00:32,340
to exec you know,

1017
01:00:32,990 --> 01:00:35,240
read the instructions for that file and execute them

1018
01:00:35,240 --> 01:00:36,020
and then that's it,

1019
01:00:36,410 --> 01:00:38,240
the only time exactly returns is

1020
01:00:38,240 --> 01:00:40,160
if some error occurred

1021
01:00:40,400 --> 01:00:43,610
that prevented the operating system from running that program for you,

1022
01:00:43,940 --> 01:00:46,820
so for example if the program doesn't exist at all,

1023
01:00:48,080 --> 01:00:50,450
exec can't find a file called echo,

1024
01:00:50,540 --> 01:00:53,390
for example an exec would return negative one,

1025
01:00:55,520 --> 01:00:58,160
signal that something wrong,

1026
01:00:58,160 --> 01:00:59,390
it couldn't couldn't find the file,

1027
01:00:59,390 --> 01:01:01,220
so ordinarily exec does not return,

1028
01:01:01,520 --> 01:01:06,600
it only returns if the kernel couldn't actually run the file.

1029
01:01:10,430 --> 01:01:11,360
Questions about exec?

1030
01:01:12,620 --> 01:01:13,640
The question in the chat is,

1031
01:01:13,640 --> 01:01:16,070
what is the last zero for in argv?

1032
01:01:18,850 --> 01:01:20,980
It marks the end of the array,

1033
01:01:21,940 --> 01:01:24,010
C is so low level

1034
01:01:24,010 --> 01:01:30,490
that there's no the C array scheme,

1035
01:01:32,340 --> 01:01:37,470
doesn't have a way for code to find out how long the array is

1036
01:01:37,500 --> 01:01:39,030
and so tell the kernel that,

1037
01:01:40,970 --> 01:01:45,140
you know we met at the array contains echo this is echo and nothing more,

1038
01:01:46,560 --> 01:01:50,750
we put zero was the last strip as the last pointer,

1039
01:01:50,990 --> 01:01:53,000
each of those strings in double quotes is actually

1040
01:01:53,000 --> 01:01:56,210
a pointer to some memory that contains those bytes,

1041
01:01:56,720 --> 01:02:00,950
that fifth element of the array is a pointer's value is zero,

1042
01:02:01,310 --> 01:02:03,770
the convention is that a pointer whose value is zero

1043
01:02:03,770 --> 01:02:05,180
or what's called a null pointer,

1044
01:02:07,050 --> 01:02:10,620
sort of signifies nothing with it,

1045
01:02:11,620 --> 01:02:16,570
[], so the code in the kernel has actually walks through this array,

1046
01:02:16,570 --> 01:02:19,920
until it finds it element whose value is zero.

1047
01:02:24,690 --> 01:02:27,420
Okay, all right,

1048
01:02:27,420 --> 01:02:29,490
so this is how a program can replace itself

1049
01:02:30,800 --> 01:02:32,090
with another program from a file,

1050
01:02:32,090 --> 01:02:33,800
but actually when we run stuff in the shell,

1051
01:02:33,800 --> 01:02:37,940
like echo abc, or ls or anything else,

1052
01:02:38,900 --> 01:02:41,180
we don't want to replace the shell, we don't have,

1053
01:02:41,180 --> 01:02:42,710
shell just call exec,

1054
01:02:43,420 --> 01:02:46,630
because, that would replace the shell with the echo command

1055
01:02:46,630 --> 01:02:49,160
then echo exited, that would be end,

1056
01:02:49,700 --> 01:02:52,040
you know we don't want an echo to replace the shell,

1057
01:02:52,040 --> 01:02:54,170
so the shell actually does is fork,

1058
01:02:54,940 --> 01:02:56,620
and then the child calls exec

1059
01:02:56,740 --> 01:03:01,180
and that's an extremely common unix idiom program instead.

1060
01:03:01,600 --> 01:03:04,660
Want to run a program, but regain control

1061
01:03:04,690 --> 01:03:07,570
what they do is call fork and have the child called exec.

1062
01:03:08,000 --> 01:03:12,050
So here's a simple example, this forkexec program.

1063
01:03:14,310 --> 01:03:17,550
In this program call fork line twelve,

1064
01:03:17,580 --> 01:03:20,940
in the child sort of line fourteen, we call exec much like before.

1065
01:03:21,120 --> 01:03:27,700
For the child process, has to replace itself with the echo command,

1066
01:03:28,220 --> 01:03:30,890
echo does this thing and then exits.

1067
01:03:31,680 --> 01:03:33,720
And then the parent process, regains control

1068
01:03:33,720 --> 01:03:39,860
because when fork returns, greater than zero value in the parent process,

1069
01:03:39,860 --> 01:03:42,440
so the parent process then continues to execute at nineteen

1070
01:03:42,650 --> 01:03:45,380
and unix provides a wait system call,

1071
01:03:45,380 --> 01:03:50,720
line 24 process to wait for for a child that created with fork,

1072
01:03:51,080 --> 01:03:55,280
because when I run a command on the command line,

1073
01:03:56,330 --> 01:04:01,190
we want shell to wait for the command to finish

1074
01:04:01,400 --> 01:04:03,170
before it prints the prompt again,

1075
01:04:03,200 --> 01:04:06,050
before it prints the dollar sign prompt asking me for more input.

1076
01:04:06,730 --> 01:04:08,260
So it's the wait system call

1077
01:04:08,890 --> 01:04:11,950
allows a process to wait for any of its children to return

1078
01:04:12,280 --> 01:04:19,330
and this status argument is that a way for exiting child,

1079
01:04:19,390 --> 01:04:24,190
to communicate one integer 32 bit value

1080
01:04:24,400 --> 01:04:27,340
from the exiting child to the waiting parents,

1081
01:04:27,340 --> 01:04:31,450
on line seventeen that argument to exit that one that's the argument to exit.

1082
01:04:32,060 --> 01:04:35,540
The operating system passes that one

1083
01:04:35,570 --> 01:04:39,650
from the exiting child to the call to wait line twenty,

1084
01:04:39,650 --> 01:04:43,570
so wait the ampersand wait is passing

1085
01:04:43,570 --> 01:04:46,720
the address of the status variable to the kernel,

1086
01:04:46,720 --> 01:04:51,520
the kernel fills in that address with child's argument to exit.

1087
01:04:52,770 --> 01:04:54,060
And the convention in unix is

1088
01:04:54,060 --> 01:04:59,850
that if a program completes successfully exit exits with status zero,

1089
01:05:00,430 --> 01:05:03,940
but it has encountered an error at line seventeen,

1090
01:05:04,280 --> 01:05:07,970
the unix convention is that you pass one to exit

1091
01:05:08,420 --> 01:05:10,580
and so if you care the calling process

1092
01:05:10,580 --> 01:05:12,260
can look at the status from wait,

1093
01:05:13,240 --> 01:05:17,280
decide whether the child completed successfully.

1094
01:05:18,420 --> 01:05:20,130
Professor Morris, quick question.

1095
01:05:20,560 --> 01:05:20,950
Yes.

1096
01:05:21,280 --> 01:05:25,090
About the exec call at fifteen ,

1097
01:05:25,090 --> 01:05:26,740
we mentioned not a bit ago,

1098
01:05:26,740 --> 01:05:30,370
that exec will completely go into the echo program

1099
01:05:30,400 --> 01:05:32,440
and not return to forkexec,

1100
01:05:33,060 --> 01:05:36,930
, so,  would ever reach line sixteen and seventeen.

1101
01:05:38,170 --> 01:05:41,190
Well, not for this exec code,

1102
01:05:41,190 --> 01:05:43,650
because there happens to be a program called echo,

1103
01:05:44,130 --> 01:05:46,560
but if I modify that code here,

1104
01:05:46,560 --> 01:05:48,420
let me just modify this code.

1105
01:05:49,470 --> 01:05:51,450
Okay so first let me just run forkexec,

1106
01:05:53,590 --> 01:05:56,740
it actually does execute echo with those arguments,

1107
01:05:56,740 --> 01:05:58,390
we see the output, this is echo,

1108
01:05:58,660 --> 01:06:04,700
and we see the child exited to show that echo exited successfully,

1109
01:06:05,000 --> 01:06:06,110
and the parent wait for.

1110
01:06:06,440 --> 01:06:08,720
Let me just modify the program for you,

1111
01:06:09,630 --> 01:06:13,320
instead of echo going to run some command that doesn't exist,

1112
01:06:15,360 --> 01:06:20,860
actually the exit out of QEMU, with control a x

1113
01:06:20,860 --> 01:06:25,120
and then rebuild the whole thing in order to re-compile. I modified.

1114
01:06:25,850 --> 01:06:29,180
Forkexec now run forkexec back again after modifying it,

1115
01:06:29,800 --> 01:06:31,990
and this time because the program we're asking to.

1116
01:06:32,760 --> 01:06:39,240
Actually, the program, we're asking to execute doesn't exist,

1117
01:06:39,600 --> 01:06:43,230
exec does return we see the exec failed output,

1118
01:06:43,840 --> 01:06:45,760
and the exit one

1119
01:06:45,850 --> 01:06:48,370
you'll see the one there is communicated back to the parent

1120
01:06:48,370 --> 01:06:50,440
which says the child exited the status one.

1121
01:06:52,280 --> 01:06:57,260
So exec returns back to the calling function when something went wrong.

1122
01:06:57,740 --> 01:06:58,190
Yes.

1123
01:07:08,700 --> 01:07:09,570
Okay good.

1124
01:07:14,680 --> 01:07:17,980
Alright, something that's going to note here,

1125
01:07:17,980 --> 01:07:20,500
that actually think many of you already noted is

1126
01:07:20,500 --> 01:07:23,430
that, it is a common idiom here,

1127
01:07:23,430 --> 01:07:26,100
this fork followed by exec in the child

1128
01:07:26,580 --> 01:07:31,890
and it's potentially a bit wasteful the fork copies the entire parent process,

1129
01:07:32,320 --> 01:07:35,470
but exec throws away all that copied memory

1130
01:07:35,770 --> 01:07:40,990
and replaces it with, whatever is in the a file that you're running,

1131
01:07:40,990 --> 01:07:44,320
so you know if you're worried about this kind of stuff,

1132
01:07:44,320 --> 01:07:47,290
the copy implied by the fork,

1133
01:07:48,160 --> 01:07:50,110
is in some sense mostly wasted

1134
01:07:50,110 --> 01:07:54,010
because all that copied memory is just thrown away and replaced by the exec,

1135
01:07:55,270 --> 01:07:57,940
and this affects actually would be significant for big programs,

1136
01:07:57,940 --> 01:08:00,610
if you have a multi gigabyte program that calls fork,

1137
01:08:01,050 --> 01:08:03,240
and it did indeed copy all the memory

1138
01:08:03,240 --> 01:08:07,260
would actually take a fair fraction of a second perhaps to do the copy,

1139
01:08:07,740 --> 01:08:09,240
which could be a problem.

1140
01:08:12,520 --> 01:08:14,710
But later in the course,

1141
01:08:14,710 --> 01:08:17,320
you'll actually implement some optimization

1142
01:08:17,320 --> 01:08:19,810
in particular something called copy on write fork,

1143
01:08:20,080 --> 01:08:26,560
which will eliminate almost all of the apparent inefficiency of fork copying,

1144
01:08:26,560 --> 01:08:28,870
only to have exec throw away the copy.

1145
01:08:29,180 --> 01:08:32,390
It turns out with a bunch of tricks involving a virtual memory system.

1146
01:08:32,920 --> 01:08:36,700
You can build a fork, that's lazy about the copy

1147
01:08:36,730 --> 01:08:40,960
and that doesn't do in the common case of fork immediately followed by exec,

1148
01:08:41,420 --> 01:08:43,310
or you don't actually have to do the copy,

1149
01:08:43,310 --> 01:08:45,770
because the child doesn't actually use most of the memory.

1150
01:08:48,100 --> 01:08:50,410
I think you'll find that's a fun and interesting lab.

1151
01:08:51,040 --> 01:08:52,180
Question from chat,

1152
01:08:52,510 --> 01:08:54,970
why does the parent process parent

1153
01:08:54,970 --> 01:08:57,820
waiting completely before the child calls exec.

1154
01:08:59,240 --> 01:09:02,720
Yeah, it's just chance.

1155
01:09:06,940 --> 01:09:09,880
Why is it that you know the observation is that,

1156
01:09:09,970 --> 01:09:11,680
you know,

1157
01:09:13,130 --> 01:09:17,540
it could be that the parents output could be interleaved with the child's output

1158
01:09:17,540 --> 01:09:20,990
in the same area that we saw before, with similar fork example,

1159
01:09:21,410 --> 01:09:23,420
it just happens not to be

1160
01:09:23,630 --> 01:09:25,700
there's no guarantee that this is the output,

1161
01:09:25,700 --> 01:09:27,260
we would see in fact,

1162
01:09:27,260 --> 01:09:29,390
we we shouldn't be surprised

1163
01:09:29,390 --> 01:09:32,960
if we saw the lines of the output in the other order or interleaved.

1164
01:09:33,620 --> 01:09:38,990
I suspect what's going on is that it takes a bit of time and effort.

1165
01:09:39,770 --> 01:09:41,750
The exec system caused a little bit expensive,

1166
01:09:41,750 --> 01:09:43,730
because it has to load all those,

1167
01:09:43,790 --> 01:09:46,730
you have to access the file system and access the disk

1168
01:09:46,730 --> 01:09:50,780
and read the contents of a file called echo of the disk into memory,

1169
01:09:51,050 --> 01:09:53,180
after allocating some memory

1170
01:09:53,180 --> 01:09:55,850
and that even after freeing some memory from the old process,

1171
01:09:55,850 --> 01:10:00,230
so there's quite a bit of machinery involved in the exec system call ,

1172
01:10:00,860 --> 01:10:03,350
and apparently that takes long enough

1173
01:10:03,350 --> 01:10:06,230
that the parent can complete producing the output,

1174
01:10:06,580 --> 01:10:09,400
before the exec is finished and started running echo.

1175
01:10:10,400 --> 01:10:11,240
Does that make sense.

1176
01:10:15,360 --> 01:10:16,290
Another question,

1177
01:10:16,290 --> 01:10:19,260
is a convention that the child can wait for the parent.

1178
01:10:21,520 --> 01:10:26,770
There's not a way unix doesn't have a way for the child,

1179
01:10:28,220 --> 01:10:30,860
there's no straightforward way for a child to wait from a parent.

1180
01:10:31,930 --> 01:10:33,520
The wait system call,

1181
01:10:34,680 --> 01:10:37,380
because it's the only mechanism available well,

1182
01:10:37,620 --> 01:10:41,130
the wait system call waits for your children.

1183
01:10:41,880 --> 01:10:42,420
And that's it.

1184
01:10:43,620 --> 01:10:45,990
And so what wait what wait does is,

1185
01:10:46,350 --> 01:10:48,720
if you have any children,

1186
01:10:49,080 --> 01:10:53,970
and one of them has already exited what does exit, then we will return,

1187
01:10:54,330 --> 01:10:55,800
but you know if you don't have any children

1188
01:10:55,800 --> 01:10:56,970
because you are.

1189
01:10:57,360 --> 01:11:00,450
Because in this simple case,

1190
01:11:02,120 --> 01:11:02,930
it was just a parent

1191
01:11:02,930 --> 01:11:05,360
and child if the child called wait,

1192
01:11:06,890 --> 01:11:08,330
the child doesn't have any children

1193
01:11:08,600 --> 01:11:09,200
and in that case,

1194
01:11:09,200 --> 01:11:12,500
wait just returns immediately with a minus one error return,

1195
01:11:12,500 --> 01:11:14,450
saying this process doesn't have any children.

1196
01:11:15,440 --> 01:11:16,940
Anyway, the short answer is

1197
01:11:16,940 --> 01:11:20,180
there's no way for a child to wait for its parent to exit.

1198
01:11:21,930 --> 01:11:22,770
And another question,

1199
01:11:22,770 --> 01:11:26,820
when we say the child copies all the memory from the parent process,

1200
01:11:26,820 --> 01:11:28,830
what exactly do we refer to,

1201
01:11:28,830 --> 01:11:32,970
by that I thought the child is going to define the variables again.

1202
01:11:39,050 --> 01:11:40,250
When you compile this,

1203
01:11:40,250 --> 01:11:46,790
you know , after compilation,

1204
01:11:47,060 --> 01:11:51,020
your C program, it's just a bunch of instructions in memory

1205
01:11:51,470 --> 01:11:52,460
that live in RAM.

1206
01:11:55,070 --> 01:11:56,720
And so those can be copied.

1207
01:11:57,360 --> 01:11:58,920
Because they're just bytes living in RAM,

1208
01:11:58,920 --> 01:12:01,740
those can be copied somewhere else .

1209
01:12:02,370 --> 01:12:04,530
And with appropriate trick having to do with

1210
01:12:04,530 --> 01:12:08,840
setting up a sort of virtual memory mappings

1211
01:12:08,930 --> 01:12:12,020
and make map things look the same in the child and the parent,

1212
01:12:12,020 --> 01:12:15,050
you can just copy the parent's memory image to the child

1213
01:12:15,080 --> 01:12:17,440
and executing the child.

1214
01:12:20,660 --> 01:12:22,310
And even though we're looking at C programs,

1215
01:12:22,310 --> 01:12:25,610
you should think of them as just a bunch of machine instructions,

1216
01:12:26,920 --> 01:12:29,200
which is bytes in memory that can be copied.

1217
01:12:31,280 --> 01:12:33,440
If a parent has multiple children

1218
01:12:33,440 --> 01:12:36,230
would wait just return as soon as the first child finishes

1219
01:12:36,230 --> 01:12:38,300
meaning that there could be some more interleaving

1220
01:12:38,300 --> 01:12:40,040
with the parent and unfinished children

1221
01:12:40,310 --> 01:12:43,820
with their need to be multiple separate ways to ensure all children finished.

1222
01:12:44,340 --> 01:12:47,250
Yes, yeah, if you call fork more than one,

1223
01:12:47,250 --> 01:12:50,700
if a given process calls fork twice,

1224
01:12:51,360 --> 01:12:54,810
then it wants to wait for both children

1225
01:12:54,810 --> 01:12:56,760
and has to call wait twice,

1226
01:12:56,850 --> 01:13:01,490
each call to wait will return as soon as one of the children exits,

1227
01:13:01,490 --> 01:13:05,870
you don't, when wait returns you don't necessarily know which child is exited,

1228
01:13:06,170 --> 01:13:09,770
the wait returns the child's process id as its return value,

1229
01:13:09,770 --> 01:13:12,650
so you can tell after wait returns,

1230
01:13:12,860 --> 01:13:14,450
you know which one it was at exit.

1231
01:13:22,660 --> 01:13:24,610
As a final example ,

1232
01:13:25,640 --> 01:13:27,170
I'd like to show,

1233
01:13:28,080 --> 01:13:37,460
how all these facilities combine to implement IO direction,

1234
01:13:37,460 --> 01:13:38,810
so if you remember,

1235
01:13:38,960 --> 01:13:41,900
the shell provides us with this handy syntax,

1236
01:13:42,350 --> 01:13:44,180
I can say echo hello is going out,

1237
01:13:44,830 --> 01:13:48,310
that runs the echo command that argument sending it.

1238
01:13:48,800 --> 01:13:52,670
First, that sends its output to the file out and looked out.

1239
01:13:53,120 --> 01:13:54,170
Or yet,

1240
01:13:55,340 --> 01:14:00,620
on the cat and with its input connected from the out file,

1241
01:14:01,250 --> 01:14:03,620
we can see that saved output from the echo command.

1242
01:14:04,980 --> 01:14:11,630
The way the shell sets this up, is, as follows.

1243
01:14:15,320 --> 01:14:20,060
It, the shell first forks like on line thirteen

1244
01:14:20,150 --> 01:14:23,810
and then in the child, the shell changes the way

1245
01:14:23,810 --> 01:14:25,520
the file descriptors are set up,

1246
01:14:25,520 --> 01:14:28,280
so that the child's file descriptor one,

1247
01:14:28,280 --> 01:14:32,860
which by convention most programs used for the output .

1248
01:14:33,470 --> 01:14:37,430
The shell changes the child's file descriptor to one

1249
01:14:37,430 --> 01:14:40,040
to refer to this output file,

1250
01:14:40,430 --> 01:14:42,530
and then run whatever commands you wanted

1251
01:14:42,590 --> 01:14:47,060
and that leaves the parent shells file scripter one unchanged,

1252
01:14:47,510 --> 01:14:49,520
so this idiom of forking

1253
01:14:49,520 --> 01:14:53,090
and in a child changing around the file descriptors,

1254
01:14:53,360 --> 01:14:55,280
is the usual way in unix,

1255
01:14:55,280 --> 01:14:59,770
actually redirect input and output for a command that you run,

1256
01:14:59,770 --> 01:15:04,300
but not affect the input and output for a calling program,

1257
01:15:04,300 --> 01:15:06,370
because we don't want to redirect the shell's output.

1258
01:15:07,150 --> 01:15:11,500
We only want to redirect the child programs output.

1259
01:15:12,670 --> 01:15:15,490
Anyway, the way this works we call fork usual way,

1260
01:15:15,730 --> 01:15:18,370
line fifteen only executes in the child.

1261
01:15:18,860 --> 01:15:21,410
The reason for the close one on line fifteen is,

1262
01:15:21,410 --> 01:15:26,530
that in this program we're redirecting just the output of the echo command,

1263
01:15:26,530 --> 01:15:28,000
so when I run this redirect,

1264
01:15:28,640 --> 01:15:31,520
program produces no output itself,

1265
01:15:31,520 --> 01:15:35,060
it ran echo with its output directly to output.txt.

1266
01:15:35,540 --> 01:15:39,440
So when I look at output.txt ,

1267
01:15:39,770 --> 01:15:41,330
I see this expected output,

1268
01:15:41,750 --> 01:15:43,880
the reason for the close one on line fifteen,

1269
01:15:44,900 --> 01:15:49,160
is that we want one as a sort of conventional

1270
01:15:49,160 --> 01:15:51,560
output file descriptor to refer to something else,

1271
01:15:52,010 --> 01:15:54,650
it happens so we don't, have a child,

1272
01:15:54,650 --> 01:15:56,690
we don't want to use the father descriptor one

1273
01:15:56,690 --> 01:15:58,790
that the shell had that's connected to the console,

1274
01:15:59,660 --> 01:16:03,320
the call to open on line sixteen is guaranteed to return one,

1275
01:16:03,320 --> 01:16:07,070
because, the semantics of open are that open returns

1276
01:16:07,070 --> 01:16:09,490
the lowest file descriptor number

1277
01:16:09,490 --> 01:16:13,450
that's not currently in use in the calling process

1278
01:16:13,480 --> 01:16:14,950
since we just closed one,

1279
01:16:15,420 --> 01:16:19,590
and file descriptor zero is still connected to the console,

1280
01:16:19,590 --> 01:16:20,010
I mean，

1281
01:16:20,460 --> 01:16:23,160
open is guaranteed to return one.

1282
01:16:24,290 --> 01:16:29,060
So after the line sixteen file descriptor one is connected to this file.

1283
01:16:30,220 --> 01:16:31,300
We only exec echo,

1284
01:16:31,300 --> 01:16:33,970
echo just writes its output the file descriptor one

1285
01:16:34,330 --> 01:16:35,710
and now go to this file

1286
01:16:35,740 --> 01:16:38,380
and the cool thing about this is echo had no idea what's going on,

1287
01:16:38,800 --> 01:16:41,620
echo doesn't need to know about IO direction at all,

1288
01:16:41,650 --> 01:16:44,080
it just writes its output, the file descriptor one.

1289
01:16:45,160 --> 01:16:50,350
Only the shell, knows about IO redirection.

1290
01:16:52,380 --> 01:16:56,720
This example also illustrates the sort of kind of

1291
01:16:57,110 --> 01:17:00,110
neatness of the separation between fork and exec,

1292
01:17:00,110 --> 01:17:03,440
the fact that fork and exec are separate system calls,

1293
01:17:04,220 --> 01:17:06,700
separate functions,

1294
01:17:08,130 --> 01:17:10,440
means that there's a period of time in the child,

1295
01:17:10,440 --> 01:17:13,570
between the fork between them for returns in the child

1296
01:17:13,630 --> 01:17:17,860
and exactly which were still running the calling processes instructions,

1297
01:17:17,860 --> 01:17:19,810
so the calling process,

1298
01:17:20,160 --> 01:17:23,310
even though it's running, those instructions are running in the child,

1299
01:17:23,610 --> 01:17:26,580
it's still the calling processes instructions that are executed

1300
01:17:27,000 --> 01:17:31,260
and so the calling process is still able to change things

1301
01:17:31,320 --> 01:17:33,660
and still in control up until line nineteen.

1302
01:17:34,380 --> 01:17:36,420
And this sort of interval between fork and exec,

1303
01:17:36,780 --> 01:17:38,310
gives the shell chance to

1304
01:17:38,580 --> 01:17:41,520
change what the file descriptor, refer to, for example.

1305
01:17:43,180 --> 01:17:45,880
Any questions about this redirect example.

1306
01:17:55,220 --> 01:17:59,000
Alright, about out of time.

1307
01:18:00,410 --> 01:18:01,430
Just wrap up,

1308
01:18:01,430 --> 01:18:02,300
we look at unix,

1309
01:18:02,300 --> 01:18:08,630
is a bunch of the interfaces, the unix IO, process abstractions.

1310
01:18:09,230 --> 01:18:10,730
Thing to take away from this,

1311
01:18:10,730 --> 01:18:12,770
is if the interfaces are relatively simple

1312
01:18:12,800 --> 01:18:14,630
and just pass an integer

1313
01:18:14,630 --> 01:18:16,490
like file descriptors and process ids,

1314
01:18:16,490 --> 01:18:20,450
back and forth across its arguments system calls .

1315
01:18:20,820 --> 01:18:26,440
But, well, the functionality inside the interface is relatively sophisticated,

1316
01:18:26,440 --> 01:18:30,210
like creating new processes and copying the current process

1317
01:18:30,600 --> 01:18:32,820
and furthermore I show some examples

1318
01:18:32,820 --> 01:18:38,340
of ways in which the abstractions individually simple combine in useful ways,

1319
01:18:38,550 --> 01:18:41,850
for example to produce IO redirection.

1320
01:18:44,030 --> 01:18:46,100
There's a lab due at the end of next week

1321
01:18:46,970 --> 01:18:50,150
and that lab involves writing more simple utilities

1322
01:18:50,150 --> 01:18:52,880
like the ones I showed that use the system calls that we discuss.

1323
01:18:54,140 --> 01:18:55,370
So, have fun with that lab

1324
01:18:55,400 --> 01:18:57,620
and I'll see you in class next week.

1325
01:19:01,520 --> 01:19:02,180
And that's it.

1326
01:19:08,480 --> 01:19:08,780
Thank you.

1327
01:19:15,170 --> 01:19:16,550
Since I'm the one recording,

1328
01:19:16,670 --> 01:19:18,110
how do I end this,

1329
01:19:18,680 --> 01:19:20,210
first time recording in lecture.

1330
01:19:20,600 --> 01:19:21,710
They will be exit.

1331
01:19:22,520 --> 01:19:25,310
Okay, nothing special I can just exit it will be saved somewhere.

1332
01:19:26,220 --> 01:19:27,270
Yes.

1333
01:19:27,300 --> 01:19:27,720
Awesome.

1334
01:19:32,010 --> 01:19:36,470
I assume will create some directory and sticking a file in that directory.

1335
01:19:38,600 --> 01:19:40,640
There's also office hours right after this right.

1336
01:19:41,930 --> 01:19:42,410
Yes.

1337
01:19:42,860 --> 01:19:43,310
Perfect.

1338
01:19:45,200 --> 01:19:45,710
Cool.

1339
01:19:50,340 --> 01:19:50,820
Alright.

1340
01:19:51,580 --> 01:19:51,970
Alright.

1341
01:19:52,450 --> 01:19:54,430
Thank you and I'll see you next week,

1342
01:19:54,640 --> 01:19:55,060
thanks.

