1
00:00:01,900 --> 00:00:04,270
All right,

2
00:00:04,270 --> 00:00:08,770
welcome to 6.S081 operating systems,

3
00:00:08,770 --> 00:00:10,720
I'm Robert I'll be co-lecturing

4
00:00:10,720 --> 00:00:14,320
with Frans and David and Nicolaas

5
00:00:14,320 --> 00:00:16,180
of the TAs.

6
00:00:16,450 --> 00:00:18,850
So, um please during the zoom lectures,

7
00:00:18,850 --> 00:00:19,690
ask questions,

8
00:00:19,690 --> 00:00:21,460
you can either interrupt me by

9
00:00:21,460 --> 00:00:24,280
audio or enter something into

10
00:00:24,280 --> 00:00:25,740
the chat window.

11
00:00:25,840 --> 00:00:27,730
Um, one of the staff will see and ask

12
00:00:27,730 --> 00:00:28,840
question for you.

13
00:00:29,900 --> 00:00:31,430
By the way we'll be recording these

14
00:00:31,430 --> 00:00:33,680
lectures and then we'll post recordings later

15
00:00:33,680 --> 00:00:36,170
so you can review them or for

16
00:00:36,170 --> 00:00:38,180
people who can't make this time so

17
00:00:38,180 --> 00:00:39,740
they can nevertheless see lectures.

18
00:00:40,710 --> 00:00:43,680
All right, I want to start by

19
00:00:43,680 --> 00:00:44,850
laying out some of the goals

20
00:00:44,850 --> 00:00:46,500
of the course. So,

21
00:00:46,750 --> 00:00:49,330
number one is to um,

22
00:00:49,330 --> 00:00:53,680
understand a design and implementation

23
00:00:53,680 --> 00:00:56,180
of operating systems.

24
00:00:56,310 --> 00:00:58,120
Um, yeah,

25
00:00:58,840 --> 00:01:01,210
design is sort of high level structure

26
00:01:01,210 --> 00:01:03,550
and implementation is really about what the

27
00:01:03,550 --> 00:01:04,600
code looks like,

28
00:01:04,600 --> 00:01:06,740
and we'll spending a lot of time with both.

29
00:01:07,940 --> 00:01:11,840
And in the interest of getting a

30
00:01:11,840 --> 00:01:13,640
deep understanding of what's going on,

31
00:01:13,640 --> 00:01:18,280
you'll get hands-on experience with a small.

32
00:01:18,420 --> 00:01:23,130
Um, a small operating system,

33
00:01:23,130 --> 00:01:24,980
the xv6 operating system.

34
00:01:25,320 --> 00:01:27,420
Um, and,

35
00:01:27,420 --> 00:01:29,010
in addition to actually looking at an

36
00:01:29,010 --> 00:01:30,270
existing operating system,

37
00:01:30,270 --> 00:01:33,270
you'll be a in the labs

38
00:01:33,270 --> 00:01:35,070
get a bunch of experience extending

39
00:01:35,070 --> 00:01:37,410
the operating system modifying improving its

40
00:01:37,410 --> 00:01:41,100
behavior and writing system software that

41
00:01:41,100 --> 00:01:43,740
it uses the operating system interfaces,

42
00:01:43,740 --> 00:01:45,140
if it works an application.

43
00:01:45,320 --> 00:01:47,420
Um, So,

44
00:01:47,420 --> 00:01:48,560
um, so this is what you're going to

45
00:01:48,560 --> 00:01:49,730
be doing in the course,

46
00:01:49,730 --> 00:01:52,400
um, um.

47
00:01:52,980 --> 00:01:55,710
We're also interested in what the purpose

48
00:01:55,710 --> 00:01:57,360
of the operating system itself is as

49
00:01:57,360 --> 00:01:58,800
well as the course.

50
00:02:00,980 --> 00:02:02,090
So for that I have a

51
00:02:02,090 --> 00:02:04,040
sort of list of a couple

52
00:02:04,040 --> 00:02:05,540
of things which,

53
00:02:05,540 --> 00:02:08,630
um you know there's lots of operating system,

54
00:02:08,630 --> 00:02:10,550
different operating systems out there,

55
00:02:10,550 --> 00:02:13,780
they typically have a common set of purposes.

56
00:02:15,150 --> 00:02:20,080
Um, one of them is to abstract the hardware,

57
00:02:21,520 --> 00:02:23,770
um, that is what you're given

58
00:02:23,770 --> 00:02:25,420
typically as a kind of starting point is

59
00:02:25,420 --> 00:02:26,170
you buy a computer,

60
00:02:26,170 --> 00:02:27,760
a computer has a CPU and memory

61
00:02:27,760 --> 00:02:29,880
but that's a very low level.

62
00:02:29,940 --> 00:02:31,770
A set of resources,

63
00:02:31,770 --> 00:02:33,300
it's fantastic to have a much higher

64
00:02:33,300 --> 00:02:36,780
level interfaces and abstractions that applications can

65
00:02:36,780 --> 00:02:40,740
use such as processes or file systems

66
00:02:40,740 --> 00:02:43,740
both for convenience and for portability.

67
00:02:44,360 --> 00:02:47,180
Another very important task of an operating

68
00:02:47,180 --> 00:02:49,960
system is to multiplex the hardware

69
00:02:50,190 --> 00:02:52,000
among many applications.

70
00:02:52,360 --> 00:02:55,120
Um, you might be running a text editor,

71
00:02:55,120 --> 00:02:56,470
and a compiler,

72
00:02:56,470 --> 00:02:58,180
or maybe

73
00:02:58,280 --> 00:03:01,400
a multiple different database servers or something

74
00:03:01,400 --> 00:03:02,420
on your operating system,

75
00:03:02,420 --> 00:03:03,830
it's fantastic to be able to have

76
00:03:03,830 --> 00:03:05,210
the operating system run,

77
00:03:05,210 --> 00:03:06,020
both of them at the same

78
00:03:06,020 --> 00:03:07,250
time or all the things are

79
00:03:07,250 --> 00:03:08,690
going on at the same time

80
00:03:08,690 --> 00:03:10,360
without having them interfere.

81
00:03:11,420 --> 00:03:15,230
That's often called multiplexing, because

82
00:03:15,230 --> 00:03:15,980
there may be a lot of

83
00:03:15,980 --> 00:03:17,630
things happening in the operating system

84
00:03:17,630 --> 00:03:19,070
at the same time, it's critical

85
00:03:19,070 --> 00:03:21,770
that they not interfere unintentionally,

86
00:03:21,770 --> 00:03:24,500
even if they have bugs and that's

87
00:03:24,500 --> 00:03:26,820
a task is called isolation.

88
00:03:27,120 --> 00:03:28,480
The idea that,

89
00:03:28,970 --> 00:03:32,270
a different activities should not be allowed

90
00:03:32,270 --> 00:03:33,620
to interfere. On the other hand,

91
00:03:33,620 --> 00:03:36,140
there are times when different activities would

92
00:03:36,140 --> 00:03:37,070
like to interfere,

93
00:03:37,070 --> 00:03:38,870
would like to interact or cooperate,

94
00:03:38,870 --> 00:03:40,550
so for example if I create a

95
00:03:40,550 --> 00:03:42,230
file with a text editor,

96
00:03:42,230 --> 00:03:43,790
and I'd like my compiler to read

97
00:03:43,790 --> 00:03:45,830
the file and we definitely want to

98
00:03:45,830 --> 00:03:47,740
allow that kind of sharing.

99
00:03:47,860 --> 00:03:50,380
Um, so we wanna allow sharing [minutes],

100
00:03:50,380 --> 00:03:55,120
um. Sort of what the user has in mind.

101
00:03:55,670 --> 00:03:57,230
But in many circumstances,

102
00:03:57,230 --> 00:03:59,360
user doesn't want sharing maybe

103
00:03:59,360 --> 00:04:00,800
you're logged into a time sharing

104
00:04:00,800 --> 00:04:02,300
machine like Athena,

105
00:04:02,300 --> 00:04:03,500
and you don't want other people to

106
00:04:03,500 --> 00:04:04,760
read your files,

107
00:04:04,760 --> 00:04:06,380
um, so we also need as well sharing

108
00:04:06,380 --> 00:04:07,820
we want to not share when we

109
00:04:07,820 --> 00:04:09,640
don't want to um.

110
00:04:09,760 --> 00:04:11,740
Which we could call security or a

111
00:04:11,740 --> 00:04:15,400
permission system an access control system.

112
00:04:16,650 --> 00:04:18,360
Another thing that people value in operating

113
00:04:18,360 --> 00:04:20,040
systems is if you spend a lot

114
00:04:20,040 --> 00:04:21,180
of money on the hardware on a

115
00:04:21,180 --> 00:04:23,190
computer you'd like your application to be

116
00:04:23,190 --> 00:04:24,750
able to get a sort of full

117
00:04:24,750 --> 00:04:27,600
performance that a hardware ought to be

118
00:04:27,600 --> 00:04:30,440
able to provide. And,

119
00:04:30,650 --> 00:04:33,260
A lot of that is just application programming,

120
00:04:33,260 --> 00:04:34,700
um. But,

121
00:04:34,700 --> 00:04:35,570
um inevitably,

122
00:04:35,570 --> 00:04:37,760
unfortunately, some of it is the operating system

123
00:04:37,760 --> 00:04:41,240
has to make sure that whatever services

124
00:04:41,240 --> 00:04:43,790
it provides don't get in the way

125
00:04:43,790 --> 00:04:46,250
of applications getting high performance,

126
00:04:46,250 --> 00:04:47,510
so you want to at least not

127
00:04:47,510 --> 00:04:49,430
get in the way and maybe even

128
00:04:49,430 --> 00:04:51,540
help applications achieve

129
00:04:51,650 --> 00:04:52,860
good performance.

130
00:04:54,150 --> 00:04:56,570
Um, um,

131
00:04:56,570 --> 00:04:58,740
finally, um.

132
00:04:58,880 --> 00:05:01,460
With most operating systems have to support

133
00:05:01,460 --> 00:05:03,170
a wide range of different applications,

134
00:05:03,170 --> 00:05:05,990
maybe it's a laptop running a text editor,

135
00:05:05,990 --> 00:05:07,610
maybe it's running games,

136
00:05:07,610 --> 00:05:10,400
maybe your operating system needs to support

137
00:05:10,400 --> 00:05:12,860
database servers or cloud computation,

138
00:05:12,860 --> 00:05:15,950
and usually because operating systems are quite

139
00:05:15,950 --> 00:05:19,280
expensive to design and build, people use

140
00:05:19,280 --> 00:05:21,110
the same operating systems for many different

141
00:05:21,110 --> 00:05:22,250
tasks like Linux,

142
00:05:22,250 --> 00:05:23,720
for example which I'm sure many of

143
00:05:23,720 --> 00:05:25,340
you are running a is used in

144
00:05:25,340 --> 00:05:27,170
all of the situations I mentioned so

145
00:05:27,170 --> 00:05:28,520
the same operating system really has to

146
00:05:28,520 --> 00:05:31,380
be able to support a range of,

147
00:05:31,430 --> 00:05:34,140
um, often quite different uses.

148
00:05:36,830 --> 00:05:38,180
So we're hoping to be able

149
00:05:38,180 --> 00:05:40,430
to support sort of all these

150
00:05:40,430 --> 00:05:42,740
different goals simultaneously.

151
00:05:44,000 --> 00:05:45,170
And we'll hear more about all of

152
00:05:45,170 --> 00:05:46,880
them during the course.

153
00:05:47,810 --> 00:05:48,260
All right,

154
00:05:48,260 --> 00:05:49,790
um, operating systems,

155
00:05:49,790 --> 00:05:51,920
so people worked out a

156
00:05:51,920 --> 00:05:56,000
set of design ideas over the decades

157
00:05:56,000 --> 00:05:57,860
have worked pretty well sort of ways

158
00:05:57,860 --> 00:05:59,240
of organizing things.

159
00:05:59,310 --> 00:06:01,320
I'm going to lay out for you,

160
00:06:01,320 --> 00:06:03,460
this sort of classic.

161
00:06:05,890 --> 00:06:10,000
A organization sort of standard deal for um.

162
00:06:10,600 --> 00:06:12,560
Um, this course and,

163
00:06:13,380 --> 00:06:15,960
um, is actually quite common around

164
00:06:15,960 --> 00:06:17,100
for many operating systems.

165
00:06:17,100 --> 00:06:20,980
So this is sort of OS internal organization or.

166
00:06:21,830 --> 00:06:24,380
The way I think about it

167
00:06:24,380 --> 00:06:27,920
is in terms of a box

168
00:06:27,920 --> 00:06:29,810
for the computer,

169
00:06:29,810 --> 00:06:31,600
the computer sort of.

170
00:06:32,260 --> 00:06:33,850
Comes with a bunch of hardware resources,

171
00:06:33,850 --> 00:06:34,810
which I'll put at the bottom,

172
00:06:34,810 --> 00:06:38,440
maybe their CPU and ram, disk for

173
00:06:38,440 --> 00:06:42,070
storage and maybe a network interface,

174
00:06:42,070 --> 00:06:43,240
this sort of hardware,

175
00:06:43,240 --> 00:06:45,700
that's the lowest layer.

176
00:06:46,180 --> 00:06:47,830
So at the top you want to

177
00:06:47,830 --> 00:06:49,570
run various applications,

178
00:06:49,570 --> 00:06:51,640
maybe a text editor I haven't use

179
00:06:51,640 --> 00:06:53,590
VI as a text editor,

180
00:06:53,590 --> 00:06:56,770
if you're going to run a C compiler CC,

181
00:06:56,770 --> 00:06:58,270
you know if you run lots of

182
00:06:58,270 --> 00:06:59,680
other things we're gonna talk a lot

183
00:06:59,680 --> 00:07:02,040
today about the Shell which is the,

184
00:07:02,030 --> 00:07:04,410
um, command line interface,

185
00:07:04,410 --> 00:07:05,670
so we have all these different programs

186
00:07:05,670 --> 00:07:07,000
that are running.

187
00:07:07,260 --> 00:07:09,570
Um, and this is the sort of world

188
00:07:09,570 --> 00:07:11,820
in which a applications run is usually

189
00:07:11,820 --> 00:07:13,420
called user space.

190
00:07:14,260 --> 00:07:16,330
Um, and as distinct from that there's

191
00:07:16,330 --> 00:07:18,540
a single program.

192
00:07:19,440 --> 00:07:20,910
A special program,

193
00:07:20,910 --> 00:07:23,460
that's always running called the kernel and

194
00:07:23,460 --> 00:07:25,440
the kernel is sort of the guardian

195
00:07:25,440 --> 00:07:27,270
of the resources of the computer,

196
00:07:27,270 --> 00:07:30,270
it's what first boots up you turn on the computer,

197
00:07:30,270 --> 00:07:32,730
um, there's just one of it maintains data,

198
00:07:32,730 --> 00:07:36,280
um. To help manage each of these processes

199
00:07:36,280 --> 00:07:37,690
and the kernel also means lots of

200
00:07:37,690 --> 00:07:41,660
data structures to help interface and,

201
00:07:42,120 --> 00:07:44,520
um, all the different kinds of hardware.

202
00:07:45,020 --> 00:07:49,550
Um, these user programs need to use,

203
00:07:49,550 --> 00:07:50,990
the kernel also has built in

204
00:07:50,990 --> 00:07:53,240
a bunch of services.

205
00:07:53,550 --> 00:07:54,090
Um so,

206
00:07:54,090 --> 00:07:57,480
for example a there's typically a file system.

207
00:07:57,980 --> 00:08:00,890
Implementation inside the kernel that implements things

208
00:08:00,890 --> 00:08:03,980
like file names and file contents and

209
00:08:03,980 --> 00:08:07,190
directories and understands how to store the

210
00:08:07,190 --> 00:08:07,910
files in the disk,

211
00:08:07,910 --> 00:08:09,410
so your programs are going to talk

212
00:08:09,410 --> 00:08:11,420
to the files inside the kernel and

213
00:08:11,420 --> 00:08:13,440
file system implementations is going to

214
00:08:13,540 --> 00:08:14,760
talk to the disk.

215
00:08:15,410 --> 00:08:16,660
In this course.

216
00:08:17,460 --> 00:08:19,800
Um, where we mostly focus on is all

217
00:08:19,800 --> 00:08:21,330
the things that has to happen inside

218
00:08:21,330 --> 00:08:23,880
the kernel and on the interfaces

219
00:08:23,880 --> 00:08:26,060
between user programs and the kernel.

220
00:08:27,490 --> 00:08:30,370
As well as the structure of the software,

221
00:08:30,370 --> 00:08:32,110
um inside the kernel.

222
00:08:32,110 --> 00:08:33,340
So um,

223
00:08:33,430 --> 00:08:36,040
we care a lot about these services

224
00:08:36,040 --> 00:08:38,560
inside the kernel.

225
00:08:38,610 --> 00:08:40,380
One of them is a file system I mentioned,

226
00:08:40,380 --> 00:08:42,000
there's also a

227
00:08:42,570 --> 00:08:44,400
management of processes,

228
00:08:44,400 --> 00:08:46,620
each of these running programs is called

229
00:08:46,620 --> 00:08:48,300
the process and it has things like

230
00:08:48,300 --> 00:08:49,230
its own memory,

231
00:08:49,230 --> 00:08:54,420
for example as well as a share of the CPU time. So,

232
00:08:54,760 --> 00:08:58,140
a kernel manages processes

233
00:08:58,540 --> 00:09:00,250
as a kernel service.

234
00:09:01,300 --> 00:09:02,080
Uh, um,

235
00:09:02,080 --> 00:09:05,950
kernel manages the allocation of the memory,

236
00:09:05,950 --> 00:09:07,390
the different processes need different

237
00:09:07,390 --> 00:09:08,080
amounts of memory.

238
00:09:08,080 --> 00:09:09,000
The kernel

239
00:09:10,970 --> 00:09:13,520
multiplexes and divides up the memory

240
00:09:13,520 --> 00:09:14,940
allocates the memory,

241
00:09:15,840 --> 00:09:18,200
um, among all the different processes.

242
00:09:22,240 --> 00:09:26,080
Um, the kernel as I mentioned a influence

243
00:09:26,080 --> 00:09:27,580
the file system, file system really comes

244
00:09:27,580 --> 00:09:30,190
into a three logical or a bunch

245
00:09:30,190 --> 00:09:31,030
of logical parts,

246
00:09:31,030 --> 00:09:32,410
but for now we can think of

247
00:09:32,410 --> 00:09:34,810
it in terms of managing file content,

248
00:09:34,810 --> 00:09:36,280
that's inside files,

249
00:09:36,280 --> 00:09:38,360
figuring out where on disk.

250
00:09:39,080 --> 00:09:39,650
Each file's content

251
00:09:39,650 --> 00:09:41,750
ought to live, file system also somewhat

252
00:09:41,750 --> 00:09:44,150
separately manages a name space that

253
00:09:44,150 --> 00:09:45,650
each file has a name and

254
00:09:45,650 --> 00:09:47,450
there's a hierarchy of directories,

255
00:09:47,450 --> 00:09:49,940
every directory has a bunch of

256
00:09:49,940 --> 00:09:51,050
files in it all that's managed

257
00:09:51,050 --> 00:09:53,640
by the file system.

258
00:09:54,030 --> 00:09:57,300
Um, there's typically some sort of security arrangement,

259
00:09:57,300 --> 00:09:59,440
maybe we'll call it access control.

260
00:10:01,750 --> 00:10:03,910
Which the kernel decides that when a

261
00:10:03,910 --> 00:10:06,580
given process wants to read, use

262
00:10:06,580 --> 00:10:08,530
some resource, maybe read something from the disk,

263
00:10:08,530 --> 00:10:09,430
use some memory,

264
00:10:09,430 --> 00:10:11,200
the access control machinery inside the

265
00:10:11,200 --> 00:10:12,490
kernel is what gets to decide

266
00:10:12,490 --> 00:10:13,570
yes it's allowed is that

267
00:10:13,570 --> 00:10:14,950
not allowed, that can get pretty

268
00:10:14,950 --> 00:10:16,570
complicated if we're talking about time

269
00:10:16,570 --> 00:10:18,910
sharing systems like Athena systems where

270
00:10:18,910 --> 00:10:20,290
there's you know each of these

271
00:10:20,290 --> 00:10:21,730
processes may be run by a

272
00:10:21,730 --> 00:10:23,890
different user and have different access

273
00:10:23,890 --> 00:10:25,690
control rules apply to what it's

274
00:10:25,690 --> 00:10:27,180
allowed to get at.

275
00:10:28,830 --> 00:10:31,710
And in a real full-blown operating system

276
00:10:31,710 --> 00:10:32,640
turns out to be many,

277
00:10:32,640 --> 00:10:34,050
many other services,

278
00:10:34,050 --> 00:10:35,730
you know there's typically some way for

279
00:10:35,730 --> 00:10:37,650
different processes to talk to each other

280
00:10:37,650 --> 00:10:40,200
called inter process communication,

281
00:10:40,200 --> 00:10:42,210
there's typically a whole bunch of software

282
00:10:42,210 --> 00:10:44,100
associated with the network things like the

283
00:10:44,100 --> 00:10:48,120
TCP/IP protocols for talking the network,

284
00:10:48,120 --> 00:10:52,480
um. There's typically support for sound cards there

285
00:10:52,480 --> 00:10:54,400
may be drivers for hundreds of different

286
00:10:54,400 --> 00:10:56,470
disk and hundreds of different network cards,

287
00:10:56,470 --> 00:10:58,690
so in a full-blown operating system is

288
00:10:58,690 --> 00:11:00,310
a huge amount of stuff here and

289
00:11:00,310 --> 00:11:01,900
this may run to millions of lines

290
00:11:01,900 --> 00:11:04,120
of code inside the kernel.

291
00:11:05,300 --> 00:11:07,490
So that's sort of a quick overview

292
00:11:07,490 --> 00:11:09,560
of whats inside the kernel,

293
00:11:09,560 --> 00:11:12,320
we're also interested in how applications

294
00:11:12,320 --> 00:11:13,820
interact with the kernel and what

295
00:11:13,820 --> 00:11:16,320
that interface looks like.

296
00:11:19,060 --> 00:11:20,520
The um,

297
00:11:22,160 --> 00:11:24,140
a usual,

298
00:11:24,140 --> 00:11:27,860
um, so this is the API for the kernel.

299
00:11:30,610 --> 00:11:32,500
How applications get at the kernel,

300
00:11:32,500 --> 00:11:34,570
a typically that's done with something called

301
00:11:34,570 --> 00:11:36,520
system calls and these are things that

302
00:11:36,520 --> 00:11:39,240
look like function calls that um

303
00:11:39,480 --> 00:11:42,300
programs can make, but actually jump into

304
00:11:42,300 --> 00:11:45,720
the kernel and execute a system call

305
00:11:45,720 --> 00:11:47,430
implementation in the kernel,

306
00:11:47,430 --> 00:11:49,050
I'll talk a bunch about that

307
00:11:49,050 --> 00:11:49,980
in the latter part of this

308
00:11:49,980 --> 00:11:51,900
lecture. For now just to give

309
00:11:51,900 --> 00:11:53,100
you a flavor here,

310
00:11:53,100 --> 00:11:54,960
what a couple of different system calls

311
00:11:54,960 --> 00:11:56,760
might look like in the source code

312
00:11:56,760 --> 00:11:58,180
of an application.

313
00:12:00,310 --> 00:12:02,140
One might be that if you want

314
00:12:02,140 --> 00:12:04,180
an application wants to open a file,

315
00:12:04,180 --> 00:12:07,000
and it calls the open system call.

316
00:12:07,420 --> 00:12:09,400
And tells the open system called the

317
00:12:09,400 --> 00:12:10,720
name of the file,

318
00:12:10,720 --> 00:12:12,280
so maybe it wants to open a

319
00:12:12,280 --> 00:12:14,830
file for writing called "out" and the

320
00:12:14,830 --> 00:12:17,050
next argument here saying 1

321
00:12:17,050 --> 00:12:17,920
in this case. I want to

322
00:12:17,920 --> 00:12:19,000
write that file,

323
00:12:19,000 --> 00:12:21,820
and so this thing that looks like a function call.

324
00:12:22,670 --> 00:12:24,620
It opens the system calls actually special

325
00:12:24,620 --> 00:12:26,570
code that jumps into the kernel and

326
00:12:26,570 --> 00:12:29,180
the kernel can retrieve these arguments executes

327
00:12:29,180 --> 00:12:30,680
some kernel code that implements open,

328
00:12:30,680 --> 00:12:32,150
maybe talks to the disk,

329
00:12:32,150 --> 00:12:33,860
and then returns a value and that's

330
00:12:33,860 --> 00:12:35,620
this file descriptor,

331
00:12:36,240 --> 00:12:38,610
as fd stands for file descriptor.

332
00:12:38,610 --> 00:12:40,200
Um, which is the program can

333
00:12:40,200 --> 00:12:42,150
then use as a handle to

334
00:12:42,150 --> 00:12:44,540
refer to this open file.

335
00:12:44,760 --> 00:12:47,160
Um, if you want to write to a file,

336
00:12:47,160 --> 00:12:49,340
the system call [did].

337
00:12:49,400 --> 00:12:51,200
To do that is called write,

338
00:12:51,200 --> 00:12:52,190
you have to pass it one

339
00:12:52,190 --> 00:12:53,720
of these file descriptors the same as

340
00:12:53,720 --> 00:12:55,420
was returned by open.

341
00:12:55,700 --> 00:12:58,460
Um, these are arguments that are passed in

342
00:12:58,460 --> 00:12:59,600
the system call.

343
00:12:59,770 --> 00:13:01,960
From the program into the kernel,

344
00:13:01,960 --> 00:13:03,740
and you give it a pointer,

345
00:13:03,960 --> 00:13:06,300
to a buffer of characters so an

346
00:13:06,300 --> 00:13:07,200
easy way to do that in the

347
00:13:07,200 --> 00:13:08,310
C programming language,

348
00:13:08,310 --> 00:13:10,350
which these examples are written by as

349
00:13:10,350 --> 00:13:12,080
double quotes then,

350
00:13:12,340 --> 00:13:13,480
um, the string,

351
00:13:13,480 --> 00:13:15,670
the bytes of the string '\n'

352
00:13:15,670 --> 00:13:17,830
is a new line and the third

353
00:13:17,830 --> 00:13:19,940
argument is the count of characters.

354
00:13:20,160 --> 00:13:23,490
Um, if you want to write so this really gets point,

355
00:13:23,490 --> 00:13:25,620
pass this address in memory.

356
00:13:25,860 --> 00:13:26,850
So you're telling the kernel, look,

357
00:13:26,850 --> 00:13:28,650
please write 6 bytes from this

358
00:13:28,650 --> 00:13:30,750
address to the file that this

359
00:13:30,750 --> 00:13:32,840
file descriptor refers to.

360
00:13:33,750 --> 00:13:36,270
A much more exciting system call

361
00:13:36,270 --> 00:13:38,220
the encounter is the fork system,

362
00:13:38,220 --> 00:13:40,590
call fork is the system call

363
00:13:40,590 --> 00:13:42,560
that creates a new process.

364
00:13:42,620 --> 00:13:46,620
Um, and returns actually creates a process that's

365
00:13:46,620 --> 00:13:49,860
identical to the caller and fork returns

366
00:13:49,860 --> 00:13:53,040
the identifier the process identifier pid,

367
00:13:53,040 --> 00:13:56,370
um, new process is more

368
00:13:56,370 --> 00:13:57,920
complicated than [that].

369
00:13:58,040 --> 00:13:59,440
We'll hear more about this.

370
00:14:00,740 --> 00:14:01,250
So again,

371
00:14:01,250 --> 00:14:04,400
these are all look like function calls,

372
00:14:04,400 --> 00:14:05,870
but the system calls are special because

373
00:14:05,870 --> 00:14:07,240
they jump into the kernel.

374
00:14:08,200 --> 00:14:09,790
Um, that's taste,

375
00:14:09,790 --> 00:14:10,960
we'll see more later.

376
00:14:15,800 --> 00:14:17,600
That is a sort of quick overview,

377
00:14:17,600 --> 00:14:20,380
I'm a wanna.

378
00:14:20,530 --> 00:14:23,350
Just mention why I find a operating

379
00:14:23,350 --> 00:14:25,220
the study of operating systems,

380
00:14:25,300 --> 00:14:30,460
to be both a challenging and interesting.

381
00:14:32,710 --> 00:14:34,620
Why you know why it's maybe worth.

382
00:14:35,360 --> 00:14:39,240
Um, intellectually worth taking a course in this area.

383
00:14:39,370 --> 00:14:40,900
So, one reason why it's hard is that

384
00:14:40,900 --> 00:14:44,980
the environment is unforgiving, programming environment

385
00:14:44,980 --> 00:14:48,180
inside the kernels unforgiving, because you're,

386
00:14:50,570 --> 00:14:52,550
your when you're programming when you're modifying

387
00:14:52,550 --> 00:14:53,870
the kernel or extending the kernel of

388
00:14:53,870 --> 00:14:55,640
writing a new operating system kernel,

389
00:14:55,640 --> 00:14:58,220
you're providing the infrastructure that everybody

390
00:14:58,220 --> 00:15:00,080
else assumes is already present to

391
00:15:00,080 --> 00:15:01,460
run their programs.

392
00:15:01,640 --> 00:15:03,200
And then everybody else gets an operating

393
00:15:03,200 --> 00:15:05,270
system under their program when they write

394
00:15:05,270 --> 00:15:06,500
ordinary application programs,

395
00:15:06,500 --> 00:15:08,990
but when we build operating systems

396
00:15:08,990 --> 00:15:10,430
what we get is the hardware

397
00:15:10,430 --> 00:15:13,820
underneath our operating system which turns

398
00:15:13,820 --> 00:15:15,170
out to be more difficult to

399
00:15:15,170 --> 00:15:16,310
deal with. In this course,

400
00:15:16,310 --> 00:15:17,900
we, um,

401
00:15:18,340 --> 00:15:20,890
we get to use a hardware simulator called QEMU,

402
00:15:20,890 --> 00:15:21,820
um, you,

403
00:15:21,820 --> 00:15:25,970
um. That simulates a CPU and a computer

404
00:15:25,970 --> 00:15:27,200
and that makes a little bit better,

405
00:15:27,200 --> 00:15:29,690
but it's still a kind of a difficult,

406
00:15:29,690 --> 00:15:31,260
um environment programming.

407
00:15:32,360 --> 00:15:33,470
Another reason why it's hard and

408
00:15:33,470 --> 00:15:35,720
interesting is because if you're designing

409
00:15:35,720 --> 00:15:36,620
and operating system,

410
00:15:36,620 --> 00:15:39,860
you have to satisfy a bunch of tensions.

411
00:15:39,980 --> 00:15:41,900
Um that require real design thought,

412
00:15:41,900 --> 00:15:44,030
so one is that you'd like your

413
00:15:44,030 --> 00:15:46,480
operating system to be both efficient.

414
00:15:46,720 --> 00:15:49,660
Um, which often means that it operates at

415
00:15:49,660 --> 00:15:51,640
a low level close to the hardware,

416
00:15:51,640 --> 00:15:53,290
but for ease of use,

417
00:15:53,290 --> 00:15:55,030
and because real live people have to

418
00:15:55,030 --> 00:15:57,820
write programs that use your operating system,

419
00:15:57,820 --> 00:16:00,220
we'd like it also to be a

420
00:16:00,220 --> 00:16:02,360
right abstract high-level.

421
00:16:02,660 --> 00:16:04,460
A portable interfaces and it's a

422
00:16:04,460 --> 00:16:06,590
neat trick to provide a abstract

423
00:16:06,590 --> 00:16:08,240
interfaces that are simple.

424
00:16:08,320 --> 00:16:11,320
A portable but they are also efficient.

425
00:16:11,910 --> 00:16:14,820
Um, another tension is that we'd like to

426
00:16:14,820 --> 00:16:18,240
provide a very powerful operating system services

427
00:16:18,240 --> 00:16:20,190
so that the operating system can shoulder

428
00:16:20,190 --> 00:16:21,580
a lot of the burden.

429
00:16:21,680 --> 00:16:26,000
I'm a running programs like a powerful

430
00:16:26,070 --> 00:16:27,920
operating system services.

431
00:16:28,630 --> 00:16:30,460
Um, but,

432
00:16:30,860 --> 00:16:33,120
we also want to have simple interfaces.

433
00:16:34,770 --> 00:16:36,960
Um that we don't want a

434
00:16:36,960 --> 00:16:39,480
tremendously complex hard to understand interfaces

435
00:16:39,480 --> 00:16:41,790
for programmers to use because I'm

436
00:16:41,790 --> 00:16:42,600
not going to understand them,

437
00:16:42,600 --> 00:16:45,080
and they may find it hard to use.

438
00:16:45,790 --> 00:16:48,400
Um, so this is really simple API,

439
00:16:48,400 --> 00:16:50,440
and so this is possible to do

440
00:16:50,440 --> 00:16:53,440
to provide a simple interfaces that have

441
00:16:53,440 --> 00:16:57,280
powerful a machinery inside them will always

442
00:16:57,280 --> 00:16:58,500
be searching for.

443
00:16:58,700 --> 00:17:02,330
Sort of simple interfaces provide

444
00:17:02,330 --> 00:17:04,760
a powerful services.

445
00:17:04,760 --> 00:17:07,200
Hey, Robbery, we've got a question in the chat.

446
00:17:07,280 --> 00:17:09,830
Um, what is unique/different about saying

447
00:17:09,830 --> 00:17:12,200
system calls jump into the kernel i.e

448
00:17:12,200 --> 00:17:13,970
as opposed to a standard function call

449
00:17:13,970 --> 00:17:15,540
that jumps to another function.

450
00:17:15,660 --> 00:17:18,550
Um. Well,

451
00:17:18,550 --> 00:17:20,410
the kernel has the kernels is,

452
00:17:20,410 --> 00:17:23,840
um. A piece of code that's always resident

453
00:17:23,840 --> 00:17:26,540
that has special privileges that were that

454
00:17:26,540 --> 00:17:29,060
because it booted the machine booted the

455
00:17:29,060 --> 00:17:32,600
kernel a kernel has special privileges,

456
00:17:32,600 --> 00:17:34,700
it can get directly at all kinds

457
00:17:34,700 --> 00:17:37,100
of hardware like the disk device that

458
00:17:37,100 --> 00:17:38,270
ordinary user programs,

459
00:17:38,270 --> 00:17:39,800
can't get at, so if you make

460
00:17:39,800 --> 00:17:42,100
a an ordinary function call.

461
00:17:42,160 --> 00:17:46,440
Um. The function your calling doesn't get it

462
00:17:46,440 --> 00:17:48,600
doesn't get any special privileges with respect

463
00:17:48,600 --> 00:17:50,070
to the hardware whereas if you make

464
00:17:50,070 --> 00:17:53,040
a system call into the kernel will

465
00:17:53,040 --> 00:17:54,000
talk about how this works,

466
00:17:54,000 --> 00:17:57,000
but that ends up as when it

467
00:17:57,000 --> 00:17:58,590
jumps into when the system call jumps

468
00:17:58,590 --> 00:18:01,500
into the kernel a system call implementation

469
00:18:01,500 --> 00:18:02,670
in the kernel then gets all these

470
00:18:02,670 --> 00:18:06,360
special privileges so that it can modify

471
00:18:06,360 --> 00:18:09,440
all kinds of sensitive and protected.

472
00:18:09,730 --> 00:18:12,340
A hardware resources like for example getting

473
00:18:12,340 --> 00:18:14,320
directly at the hard disk.

474
00:18:15,730 --> 00:18:19,020
Um, we'll see a lot more detail for all this shortly.

475
00:18:20,330 --> 00:18:22,310
Okay, so a final tension that we

476
00:18:22,310 --> 00:18:24,290
want that all operating systems need

477
00:18:24,290 --> 00:18:25,910
to satisfy your gonna give programs

478
00:18:25,910 --> 00:18:27,560
as much flexibility as you can

479
00:18:27,560 --> 00:18:28,970
you don't want to constrain them,

480
00:18:28,970 --> 00:18:30,680
so you want to have very flexible.

481
00:18:30,740 --> 00:18:33,750
Um. Interfaces,

482
00:18:33,750 --> 00:18:35,400
but you do need to constrain program

483
00:18:35,400 --> 00:18:37,200
somewhat because you absolutely have to have

484
00:18:37,200 --> 00:18:38,740
some notion of security.

485
00:18:38,880 --> 00:18:44,770
[can]. We love for programs programs complete freedom

486
00:18:44,770 --> 00:18:45,910
but it can't be complete can't be

487
00:18:45,910 --> 00:18:48,490
really complete because we don't want programs

488
00:18:48,490 --> 00:18:49,960
to get directly at the hardware or

489
00:18:49,960 --> 00:18:53,170
to interfere with other programs or a

490
00:18:53,170 --> 00:18:54,310
sort of be able to interfere with

491
00:18:54,310 --> 00:18:57,140
the operation of the operating system itself.

492
00:18:57,360 --> 00:18:58,410
Um, so,

493
00:18:58,410 --> 00:19:00,820
these are all you know.

494
00:19:01,490 --> 00:19:02,810
It's possible to do a good job

495
00:19:02,810 --> 00:19:03,860
and we'll talk a lot about it

496
00:19:03,860 --> 00:19:05,120
but it's always a bit of a

497
00:19:05,120 --> 00:19:06,620
puzzle to provide sort of both of

498
00:19:06,620 --> 00:19:10,300
these properties in both of these columns.

499
00:19:11,630 --> 00:19:13,730
Another thing that makes OS design hard

500
00:19:13,730 --> 00:19:16,040
and interesting is that operating systems provide

501
00:19:16,040 --> 00:19:17,030
a lot of features and a lot

502
00:19:17,030 --> 00:19:18,710
of services but they actually tend to

503
00:19:18,710 --> 00:19:21,770
interact and sometimes in odd ways that

504
00:19:21,770 --> 00:19:23,540
require a lot of thought so even

505
00:19:23,540 --> 00:19:25,960
the simple examples I gave um.

506
00:19:26,640 --> 00:19:27,780
With open and fork,

507
00:19:27,780 --> 00:19:30,180
those two interact actually if a program,

508
00:19:30,180 --> 00:19:32,930
um. Allocates a file descriptor with the

509
00:19:32,930 --> 00:19:34,700
open system call,

510
00:19:34,700 --> 00:19:36,680
and then that same program,

511
00:19:36,780 --> 00:19:38,760
a fork.

512
00:19:39,610 --> 00:19:41,470
Um, and the semantics of fork just

513
00:19:41,470 --> 00:19:42,760
turned out to be that you

514
00:19:42,760 --> 00:19:44,050
create a new process that's a

515
00:19:44,050 --> 00:19:45,730
copy of the current process,

516
00:19:45,730 --> 00:19:46,990
this file descriptor,

517
00:19:46,990 --> 00:19:48,820
you opened.

518
00:19:49,640 --> 00:19:51,290
If that's truly to be a copy,

519
00:19:51,290 --> 00:19:53,660
this file descriptor still has to be

520
00:19:53,660 --> 00:19:56,920
present and usable in the child and,

521
00:19:57,320 --> 00:19:58,370
and so that has to be thought

522
00:19:58,370 --> 00:19:59,660
through that is the files,

523
00:19:59,660 --> 00:20:01,760
the opened file descriptors interact with fork

524
00:20:01,760 --> 00:20:04,460
in this interesting way and somebody has

525
00:20:04,460 --> 00:20:06,380
to figure out a should the child

526
00:20:06,380 --> 00:20:07,900
be able to get at.

527
00:20:07,960 --> 00:20:10,270
The file descriptors created before fork

528
00:20:10,270 --> 00:20:11,560
is called and the answer has

529
00:20:11,560 --> 00:20:12,580
to be yes,

530
00:20:12,580 --> 00:20:14,500
the operating systems we're going to look at.

531
00:20:14,620 --> 00:20:18,390
Um. All right, so other things

532
00:20:18,390 --> 00:20:19,320
that are turned out to

533
00:20:19,320 --> 00:20:21,210
be interesting I already mentioned

534
00:20:21,210 --> 00:20:22,860
that operating systems have to

535
00:20:22,860 --> 00:20:24,090
cater to a wide variety

536
00:20:24,090 --> 00:20:26,280
of uses the same OS

537
00:20:26,280 --> 00:20:28,620
used both for database servers

538
00:20:28,620 --> 00:20:29,820
and smartphones,

539
00:20:29,820 --> 00:20:33,280
for example and operating systems.

540
00:20:33,410 --> 00:20:36,350
As time goes on the hardware

541
00:20:36,350 --> 00:20:37,940
that you run, hardware

542
00:20:37,940 --> 00:20:38,360
you get,

543
00:20:38,360 --> 00:20:40,400
but typical computers changes,

544
00:20:40,400 --> 00:20:43,190
maybe get superfast ssd storage instead of

545
00:20:43,190 --> 00:20:44,270
mechanical hard drive.

546
00:20:44,270 --> 00:20:45,280
For example,

547
00:20:45,360 --> 00:20:47,610
about fifteen years ago multi

548
00:20:47,610 --> 00:20:50,370
core computers went from being rare

549
00:20:50,370 --> 00:20:54,750
curiosities to being pervasive and and

550
00:20:54,750 --> 00:20:56,700
recently we've seen order of magnitude

551
00:20:56,700 --> 00:20:59,190
speedups and how fast networks operate

552
00:20:59,190 --> 00:21:01,340
and so all these require rethinks.

553
00:21:01,440 --> 00:21:02,970
Um, um,

554
00:21:02,970 --> 00:21:05,560
periodically of how operating systems are designed.

555
00:21:06,510 --> 00:21:10,500
Now so so those are those are

556
00:21:10,500 --> 00:21:12,090
sort of intellectually why you might take

557
00:21:12,090 --> 00:21:14,010
the course there's also some more practical

558
00:21:14,010 --> 00:21:16,320
reasons why you might be glad to

559
00:21:16,320 --> 00:21:17,580
have taken this course,

560
00:21:17,580 --> 00:21:19,380
one is if you're interested in what

561
00:21:19,380 --> 00:21:20,730
happens inside computers,

562
00:21:20,730 --> 00:21:22,410
what goes on and saw under the

563
00:21:22,410 --> 00:21:24,390
hood a sort of in secret,

564
00:21:24,390 --> 00:21:25,710
when you turn on your computer,

565
00:21:25,710 --> 00:21:27,510
um, this is a good course to take,

566
00:21:27,510 --> 00:21:29,430
similarly if you like infrastructure that

567
00:21:29,430 --> 00:21:31,770
is if if you enjoy building

568
00:21:31,770 --> 00:21:33,900
a sort of services that other

569
00:21:33,900 --> 00:21:36,160
programs can then use them.

570
00:21:36,510 --> 00:21:37,860
This is of course essentially all

571
00:21:37,860 --> 00:21:40,020
about infrastructure because that's that's what

572
00:21:40,020 --> 00:21:41,340
operating systems are.

573
00:21:42,350 --> 00:21:43,250
If you ever need to

574
00:21:43,250 --> 00:21:44,000
spend a lot of time

575
00:21:44,000 --> 00:21:46,160
tracking down bugs in application

576
00:21:46,160 --> 00:21:47,870
code or tracking down security

577
00:21:47,870 --> 00:21:51,440
problems often that involves understanding

578
00:21:51,440 --> 00:21:52,490
what was going on inside

579
00:21:52,490 --> 00:21:54,020
the operating system because it's

580
00:21:54,020 --> 00:21:56,180
ultimately the operating system that

581
00:21:56,180 --> 00:21:57,710
enforces a lot of security

582
00:21:57,710 --> 00:22:00,020
and when things go wrong,

583
00:22:00,020 --> 00:22:01,490
it's the operating system has to pick

584
00:22:01,490 --> 00:22:03,830
up the pieces so that's often involved

585
00:22:03,830 --> 00:22:08,210
in tracking down bugs, and finally. Two

586
00:22:08,210 --> 00:22:09,440
more questions from the chat,

587
00:22:09,440 --> 00:22:11,210
so the first is how important

588
00:22:11,210 --> 00:22:12,740
is it for application developers to

589
00:22:12,740 --> 00:22:15,050
truly deeply understand the operating systems

590
00:22:15,050 --> 00:22:17,180
of developing their applications for do

591
00:22:17,180 --> 00:22:19,420
they necessarily need to be experts.

592
00:22:19,810 --> 00:22:21,370
You don't have to be an expert,

593
00:22:21,370 --> 00:22:23,530
but if you spend a lot of

594
00:22:23,530 --> 00:22:26,650
time developing and maintaining and debugging applications,

595
00:22:26,650 --> 00:22:29,080
you'll eventually end up knowing a lot

596
00:22:29,080 --> 00:22:30,160
about the operating system,

597
00:22:30,160 --> 00:22:31,420
whether you,

598
00:22:31,520 --> 00:22:33,240
whether you meant to or not just,

599
00:22:34,140 --> 00:22:36,390
it just comes up and you're often

600
00:22:36,390 --> 00:22:37,840
forced to understand.

601
00:22:38,100 --> 00:22:41,290
Um. And the second question is do

602
00:22:41,290 --> 00:22:44,230
high-level programming languages like python use

603
00:22:44,230 --> 00:22:46,030
system calls directly are there built

604
00:22:46,030 --> 00:22:48,340
in slash wrappers for convenience.

605
00:22:48,710 --> 00:22:50,750
A lot of high-level languages are sort

606
00:22:50,750 --> 00:22:53,540
of at one of move from system calls

607
00:22:53,540 --> 00:22:54,500
that's absolutely true,

608
00:22:54,500 --> 00:22:56,360
so um.

609
00:22:56,600 --> 00:22:58,640
Partially because a lot of

610
00:22:58,640 --> 00:23:01,760
languages want to provide portable a

611
00:23:01,760 --> 00:23:03,410
portable environment that works on many

612
00:23:03,410 --> 00:23:04,760
different operating systems so they can't

613
00:23:04,760 --> 00:23:07,280
necessarily commit to the specific system

614
00:23:07,280 --> 00:23:09,580
calls of any one operating system.

615
00:23:09,980 --> 00:23:12,410
Um, so I'm the answer,

616
00:23:12,410 --> 00:23:13,490
the question I think is if you

617
00:23:13,490 --> 00:23:16,460
use python, you're somewhat insulated.

618
00:23:16,570 --> 00:23:18,790
From not the system call interface,

619
00:23:18,790 --> 00:23:20,760
you know internally of course python makes,

620
00:23:20,900 --> 00:23:23,060
has to make system calls get its work done,

621
00:23:23,060 --> 00:23:24,340
um, and,

622
00:23:24,520 --> 00:23:26,380
certainly in python and many other languages,

623
00:23:26,380 --> 00:23:29,840
there is usually a way to get directly at

624
00:23:29,990 --> 00:23:32,330
the system calls whatever your operating system,

625
00:23:32,330 --> 00:23:34,060
you're running on.

626
00:23:35,480 --> 00:23:37,280
And folks for questions, you can just

627
00:23:37,280 --> 00:23:38,540
feel free to jump in yourself and

628
00:23:38,540 --> 00:23:39,650
ask questions you don't need to go

629
00:23:39,650 --> 00:23:40,880
through the chat.

630
00:23:43,410 --> 00:23:45,260
Okay, Um,

631
00:23:46,020 --> 00:23:46,740
all right,

632
00:23:46,740 --> 00:23:51,700
sorry. I'm going to spend a couple of

633
00:23:51,700 --> 00:23:56,230
minutes now talking about class structure

634
00:23:56,230 --> 00:24:00,980
of 6.S081,

635
00:24:01,140 --> 00:24:05,430
before switching back to actual technical content.

636
00:24:05,430 --> 00:24:07,740
So there is a website for the

637
00:24:07,740 --> 00:24:09,210
course which I don't want to write

638
00:24:09,210 --> 00:24:10,890
out just now but it's you

639
00:24:10,890 --> 00:24:11,940
can find it by looking for

640
00:24:11,940 --> 00:24:13,900
6.S081 on Google.

641
00:24:14,280 --> 00:24:16,350
And the website,

642
00:24:16,350 --> 00:24:18,520
um, has

643
00:24:19,890 --> 00:24:23,740
a schedule,

644
00:24:23,980 --> 00:24:26,320
it has the assignments on the schedule

645
00:24:26,320 --> 00:24:28,560
that has the lab assignments.

646
00:24:28,740 --> 00:24:30,300
Um, and it has the sort of

647
00:24:30,300 --> 00:24:32,370
information about course structure like the

648
00:24:32,370 --> 00:24:33,900
grading policy on it.

649
00:24:34,240 --> 00:24:37,300
Um the other big resource you're gonna

650
00:24:37,300 --> 00:24:39,260
wanna keep track of piazza.

651
00:24:39,960 --> 00:24:40,710
Um I guess,

652
00:24:40,710 --> 00:24:42,090
everybody was here got here by way

653
00:24:42,090 --> 00:24:43,260
piazza, um,

654
00:24:43,260 --> 00:24:45,960
but as well as um,

655
00:24:45,960 --> 00:24:48,150
so we used periodically for two main things,

656
00:24:48,150 --> 00:24:49,680
one is as a way of people

657
00:24:49,680 --> 00:24:51,270
being able to ask questions about the

658
00:24:51,270 --> 00:24:53,200
lab assignments and,

659
00:24:53,420 --> 00:24:56,180
a course staff will try to answer these questions,

660
00:24:56,180 --> 00:24:57,980
but you should feel absolutely free to

661
00:24:57,980 --> 00:25:00,740
answer each other's questions as well. And

662
00:25:00,740 --> 00:25:01,910
the other big thing that happens on

663
00:25:01,910 --> 00:25:04,400
piazza if there's announcements there's any announcements

664
00:25:04,400 --> 00:25:05,380
about the course.

665
00:25:05,500 --> 00:25:07,720
Um, we'll put the announcement on piazza so

666
00:25:07,720 --> 00:25:09,100
you should keep an eye on piazza

667
00:25:09,100 --> 00:25:10,840
for announcements even if, um,

668
00:25:11,220 --> 00:25:12,760
you're not using it for lab help.

669
00:25:13,580 --> 00:25:16,340
Yeah. Um,

670
00:25:16,700 --> 00:25:17,000
The um,

671
00:25:17,000 --> 00:25:18,560
one of the big parts of course

672
00:25:18,560 --> 00:25:20,150
is that these lectures,

673
00:25:20,150 --> 00:25:23,080
um, um,

674
00:25:24,150 --> 00:25:27,420
lectures will cover basic ideas

675
00:25:27,420 --> 00:25:28,800
and operating systems.

676
00:25:28,860 --> 00:25:31,200
Um, some of the lectures will

677
00:25:31,200 --> 00:25:33,480
be devoted to detailed a

678
00:25:33,480 --> 00:25:35,580
study of the code in

679
00:25:35,580 --> 00:25:36,660
xv6 which is

680
00:25:36,660 --> 00:25:39,420
our small teaching operating system

681
00:25:39,420 --> 00:25:40,800
and so talk about how

682
00:25:40,800 --> 00:25:41,910
it works we'll look at

683
00:25:41,910 --> 00:25:43,140
the code and show the

684
00:25:43,140 --> 00:25:45,810
code executing during lectures,

685
00:25:45,810 --> 00:25:47,370
and in addition before many of

686
00:25:47,370 --> 00:25:49,200
the lectures will be assignments reading

687
00:25:49,200 --> 00:25:51,810
assignments from a book that sort

688
00:25:51,810 --> 00:25:54,600
of describes how xv6 operates and

689
00:25:54,600 --> 00:25:56,220
why it's designed that way.

690
00:25:56,670 --> 00:25:57,990
So you do the readings before the

691
00:25:57,990 --> 00:26:01,170
class so they don't understand the discussion

692
00:26:01,170 --> 00:26:02,400
in the class,

693
00:26:02,400 --> 00:26:04,080
some of the lectures are devoted to

694
00:26:04,080 --> 00:26:06,540
background to help you do the labs.

695
00:26:06,660 --> 00:26:09,180
Um, no explanations about C works of how

696
00:26:09,180 --> 00:26:11,940
the RISC-V, which is the microprocessor

697
00:26:11,940 --> 00:26:13,080
that we'll be using.

698
00:26:13,200 --> 00:26:16,620
Um that you'll find helpful in understanding

699
00:26:16,620 --> 00:26:18,210
how to do the labs and towards

700
00:26:18,210 --> 00:26:19,420
the end of the course,

701
00:26:19,890 --> 00:26:22,710
we'll spend some lectures discussing some

702
00:26:22,710 --> 00:26:25,080
operating system papers,

703
00:26:25,080 --> 00:26:27,420
research papers and some classic papers in

704
00:26:27,420 --> 00:26:30,300
the field which you will ask that

705
00:26:30,300 --> 00:26:31,470
you read before the lecture and then

706
00:26:31,470 --> 00:26:33,630
we'll sort of talk about the papers

707
00:26:33,630 --> 00:26:36,090
during the lecture. For all the lectures

708
00:26:36,090 --> 00:26:37,290
are almost all the lectures,

709
00:26:37,290 --> 00:26:39,150
we ask that you submit a question

710
00:26:39,150 --> 00:26:40,320
about the reading,

711
00:26:40,320 --> 00:26:44,190
um for the lecture before the actual

712
00:26:44,190 --> 00:26:45,900
time of the lecture which.

713
00:26:45,950 --> 00:26:47,270
Many or all of you did for

714
00:26:47,270 --> 00:26:49,220
this lecture for which thank you,

715
00:26:49,220 --> 00:26:52,580
um, and we will read those questions to help us.

716
00:26:52,970 --> 00:26:54,800
Guide us about what to talk about

717
00:26:54,800 --> 00:26:57,020
and we'll try to answer as many

718
00:26:57,020 --> 00:26:58,040
of the questions as we can,

719
00:26:58,040 --> 00:26:59,840
although there's rarely time,

720
00:26:59,840 --> 00:27:02,460
unfortunately for us to answer all of them.

721
00:27:02,800 --> 00:27:05,980
I'm the next big part of the course of the labs.

722
00:27:06,400 --> 00:27:08,350
There's a programming lab do,

723
00:27:08,350 --> 00:27:12,490
um, almost every week and the point of

724
00:27:12,490 --> 00:27:13,510
the labs is to help you get

725
00:27:13,510 --> 00:27:15,940
hands on experience with,

726
00:27:16,110 --> 00:27:19,840
implementing and using operating systems.

727
00:27:20,690 --> 00:27:24,170
A lab that's due next week is

728
00:27:24,170 --> 00:27:27,440
actually about using about writing applications that

729
00:27:27,440 --> 00:27:29,120
make the call the system calls will

730
00:27:29,120 --> 00:27:30,240
be talking about.

731
00:27:31,520 --> 00:27:33,080
Whereas most of those labs after

732
00:27:33,080 --> 00:27:34,070
that are involved,

733
00:27:34,070 --> 00:27:37,370
you either implementing basic operating system

734
00:27:37,370 --> 00:27:38,860
features or adding

735
00:27:39,020 --> 00:27:42,360
a kernel extensions to the xv6

736
00:27:42,770 --> 00:27:44,780
operating system,

737
00:27:44,780 --> 00:27:46,520
the very last lab and one in

738
00:27:46,520 --> 00:27:48,500
which you actually add a network stack

739
00:27:48,500 --> 00:27:49,820
and a network driver so you'll be

740
00:27:49,820 --> 00:27:51,500
able to connect in over the network

741
00:27:51,500 --> 00:27:53,540
to the operating system that you run.

742
00:27:55,560 --> 00:27:56,310
You should,

743
00:27:56,310 --> 00:27:57,990
if you have problems with the lab's

744
00:27:57,990 --> 00:28:00,740
they'll be office hours that,

745
00:28:00,830 --> 00:28:03,260
TA will hold. In addition

746
00:28:03,260 --> 00:28:06,230
you can post questions to piazza

747
00:28:06,230 --> 00:28:07,610
and very often you'll be able

748
00:28:07,610 --> 00:28:09,890
to get useful answers from piazza

749
00:28:09,890 --> 00:28:11,980
more quickly than from office hours.

750
00:28:13,060 --> 00:28:16,000
We welcome you discussing the labs

751
00:28:16,000 --> 00:28:17,230
talking about the labs talking about

752
00:28:17,230 --> 00:28:20,410
how to design the lab solutions

753
00:28:20,410 --> 00:28:21,610
but we ask you please do

754
00:28:21,610 --> 00:28:23,600
not look at other people's solutions.

755
00:28:23,680 --> 00:28:25,810
Relapse, please all the code you write should

756
00:28:25,810 --> 00:28:27,850
be your own and you shouldn't share

757
00:28:27,850 --> 00:28:30,620
code or a look at other solutions.

758
00:28:32,740 --> 00:28:36,970
Greeting. Of course,

759
00:28:36,970 --> 00:28:41,480
um. We'll be mostly determined from the labs this year,

760
00:28:41,480 --> 00:28:44,120
so 70% of the grade will be,

761
00:28:44,120 --> 00:28:46,140
um. Yeah.

762
00:28:46,620 --> 00:28:49,620
Um, based on whether or not your lab,

763
00:28:49,620 --> 00:28:52,020
you submit passes the tests and we for grading,

764
00:28:52,020 --> 00:28:54,210
we run the same tests that we

765
00:28:54,210 --> 00:28:56,520
supply you so if your lab passes

766
00:28:56,520 --> 00:28:57,810
all the tests that we give you

767
00:28:57,810 --> 00:28:58,920
the chance to show you that full

768
00:28:58,920 --> 00:29:00,260
credit for the lab.

769
00:29:00,500 --> 00:29:04,070
A 20% of the grade is

770
00:29:04,070 --> 00:29:08,030
going to be from lab checkoff meetings

771
00:29:08,030 --> 00:29:09,500
for each of you will pick a

772
00:29:09,500 --> 00:29:11,660
couple of randomly selected labs and one

773
00:29:11,660 --> 00:29:13,280
of the teams will talk to you

774
00:29:13,280 --> 00:29:14,990
and ask you questions about your implementation

775
00:29:14,990 --> 00:29:17,180
just to make sure that um,

776
00:29:17,320 --> 00:29:19,620
are you really understand what's going on.

777
00:29:20,180 --> 00:29:22,080
It's a lab check offs.

778
00:29:23,870 --> 00:29:26,600
There's a 10% remaining.

779
00:29:28,040 --> 00:29:29,390
A lot of [cops] kind of

780
00:29:29,390 --> 00:29:31,790
be like a yes or no

781
00:29:31,790 --> 00:29:33,290
one or zero type of thing

782
00:29:33,290 --> 00:29:34,460
or would they be,

783
00:29:35,100 --> 00:29:38,250
like could someone get like if they

784
00:29:38,250 --> 00:29:40,080
answered some of the questions right,

785
00:29:40,080 --> 00:29:41,580
but not all the questions right when

786
00:29:41,580 --> 00:29:43,160
they get in between,

787
00:29:43,570 --> 00:29:44,700
so the grade.

788
00:29:45,060 --> 00:29:46,880
You know I haven't thought this through.

789
00:29:47,380 --> 00:29:50,320
Um, there's certainly room for partial credit

790
00:29:50,320 --> 00:29:52,480
but it's not a it won't

791
00:29:52,480 --> 00:29:55,090
be binary, it'll definitely be you

792
00:29:55,090 --> 00:29:56,540
can receive partial credit.

793
00:29:56,940 --> 00:30:01,390
Okay. Um, the last 10% is going to

794
00:30:01,390 --> 00:30:03,700
be a driven by the homework and

795
00:30:03,700 --> 00:30:06,920
participation during lecture and piazza.

796
00:30:07,480 --> 00:30:11,740
Um. There will be no exams or quizzes,

797
00:30:13,300 --> 00:30:14,520
this year.

798
00:30:15,150 --> 00:30:16,560
Um, and so what,

799
00:30:16,560 --> 00:30:18,480
that means is that most of the um,

800
00:30:18,480 --> 00:30:21,420
you know 90% of the grade

801
00:30:21,420 --> 00:30:23,160
is being driven by the lab

802
00:30:23,160 --> 00:30:24,780
so you should.

803
00:30:25,050 --> 00:30:26,730
Spend a lot of time in the labs,

804
00:30:26,730 --> 00:30:29,610
um, make sure that you start early

805
00:30:29,610 --> 00:30:31,710
and have enough time to complete

806
00:30:31,710 --> 00:30:33,930
them and work out bugs in

807
00:30:33,930 --> 00:30:35,400
order to get full credit.

808
00:30:37,270 --> 00:30:38,770
And you know as a result of

809
00:30:38,770 --> 00:30:40,000
that this is going to be a

810
00:30:40,000 --> 00:30:43,660
very kind of hands-on software oriented course.

811
00:30:44,580 --> 00:30:46,520
Any questions about the

812
00:30:47,180 --> 00:30:49,000
machinery of the course.

813
00:30:53,760 --> 00:30:56,670
Um, we've got a couple questions in chat,

814
00:30:56,670 --> 00:30:58,050
so the first is a logistical

815
00:30:58,050 --> 00:31:00,450
question, currently 6.S081

816
00:31:00,450 --> 00:31:01,650
isn't listed as usual for the

817
00:31:01,650 --> 00:31:03,990
system's concentration in the [?],

818
00:31:03,990 --> 00:31:05,370
are there plans added to the list

819
00:31:05,370 --> 00:31:07,350
of classes later. I think for that

820
00:31:07,350 --> 00:31:09,750
because it's not an AAGS

821
00:31:09,750 --> 00:31:11,880
it's an AUS, it can't be

822
00:31:11,880 --> 00:31:13,590
used to fulfill arrange requirements,

823
00:31:13,590 --> 00:31:15,700
so it's not a graduate level class.

824
00:31:15,970 --> 00:31:17,060
So, um.

825
00:31:19,270 --> 00:31:21,790
And then we have is the only

826
00:31:21,790 --> 00:31:23,410
homework to submit questions looking at the

827
00:31:23,410 --> 00:31:25,620
calendar that appears to be the case.

828
00:31:28,360 --> 00:31:30,400
Unless I'm forgetting something.

829
00:31:31,270 --> 00:31:32,110
I think that's the case,

830
00:31:32,110 --> 00:31:37,660
yes. So have, um, are there gonna

831
00:31:37,660 --> 00:31:39,670
be cutoffs for grades like X

832
00:31:39,670 --> 00:31:41,260
percent gets an A, Y percent

833
00:31:41,260 --> 00:31:43,510
gets a B etc.

834
00:31:43,510 --> 00:31:45,040
No no,

835
00:31:45,040 --> 00:31:48,210
um. Um,

836
00:31:48,210 --> 00:31:49,680
you know we're going to try to

837
00:31:49,680 --> 00:31:53,100
a free student estimate.

838
00:31:53,320 --> 00:31:56,950
I'm impression of how well you've

839
00:31:56,950 --> 00:31:58,090
understood the material,

840
00:31:58,090 --> 00:32:00,480
um. And assign a grade based on that

841
00:32:00,480 --> 00:32:03,080
so there's no predetermined cutoffs.

842
00:32:07,950 --> 00:32:10,020
All right, anything else.

843
00:32:13,660 --> 00:32:14,740
All right.

844
00:32:14,740 --> 00:32:17,140
Just real quick for folks in the

845
00:32:17,140 --> 00:32:20,980
chat asking about the

846
00:32:21,070 --> 00:32:23,530
concentration requirement, I'm not a hundred

847
00:32:23,530 --> 00:32:24,820
percent certain, um,

848
00:32:24,820 --> 00:32:26,890
but 6.S081 is not,

849
00:32:26,890 --> 00:32:28,570
it's like a temporary number before the

850
00:32:28,570 --> 00:32:30,340
class gets official one, so it

851
00:32:30,340 --> 00:32:33,280
certainly won't be listed anywhere,

852
00:32:33,280 --> 00:32:34,540
if you need it to fulfill a

853
00:32:34,540 --> 00:32:36,010
concentration, I think your best bet is

854
00:32:36,010 --> 00:32:37,720
probably to fill out a petition or

855
00:32:37,720 --> 00:32:40,480
to email somebody like Katrina Kurtz.

856
00:32:40,780 --> 00:32:44,920
To see a what the status is, we don't control,

857
00:32:45,570 --> 00:32:48,180
you know what what classes fill these

858
00:32:48,180 --> 00:32:49,260
kind of requirements,

859
00:32:49,260 --> 00:32:52,650
unfortunately. And for what language will be using

860
00:32:52,650 --> 00:32:55,180
the class will be in C.

861
00:32:55,490 --> 00:32:59,540
Yes. All right,

862
00:32:59,540 --> 00:33:01,380
um. Yeah.

863
00:33:02,400 --> 00:33:03,900
All right, for the rest of the lecture

864
00:33:03,900 --> 00:33:06,660
I want to talk about how, um,

865
00:33:06,660 --> 00:33:09,990
what system calls look like applications,

866
00:33:09,990 --> 00:33:13,660
um, and you know since the system calls

867
00:33:13,660 --> 00:33:16,480
are the interface to the services that

868
00:33:16,480 --> 00:33:18,880
the operating system provides is actually pretty

869
00:33:18,880 --> 00:33:21,010
important what those systems look like what

870
00:33:21,010 --> 00:33:23,740
applications expect from system calls and how

871
00:33:23,740 --> 00:33:26,170
they behave so it's worth understanding what

872
00:33:26,170 --> 00:33:28,280
the interface looks like.

873
00:33:29,380 --> 00:33:31,090
Um, you'll be using the system calls we

874
00:33:31,090 --> 00:33:32,840
talk about in the first lab.

875
00:33:32,960 --> 00:33:37,160
Um, and extending and improving the implementation

876
00:33:37,160 --> 00:33:39,140
internal implementation of these system calls

877
00:33:39,140 --> 00:33:40,460
in subsequent labs.

878
00:33:40,960 --> 00:33:43,120
What we're gonna do is show some

879
00:33:43,120 --> 00:33:47,260
simple examples of little programs.

880
00:33:47,980 --> 00:33:51,760
That call system calls and I'll run

881
00:33:51,760 --> 00:33:53,960
them in xv6 for you.

882
00:33:54,540 --> 00:33:56,370
I'm gonna run them,

883
00:33:56,370 --> 00:33:58,420
the xv6 is a, um,

884
00:33:58,550 --> 00:33:58,910
it's a unix,

885
00:33:58,910 --> 00:34:01,250
a simplified unix-like operating system unix

886
00:34:01,250 --> 00:34:03,740
is a old operating system that's at

887
00:34:03,740 --> 00:34:07,460
least intellectual basis for many present-day operating

888
00:34:07,460 --> 00:34:09,470
systems such as Linux and OS X

889
00:34:09,470 --> 00:34:11,480
it's in very common use.

890
00:34:11,480 --> 00:34:18,140
Um, xv6 our teaching operating system is

891
00:34:18,140 --> 00:34:20,960
much simpler and sort of inspired by

892
00:34:20,960 --> 00:34:23,390
unix and has the same overall structure,

893
00:34:23,390 --> 00:34:26,540
but is dramatically simpler than any real

894
00:34:26,540 --> 00:34:28,180
unix operating system.

895
00:34:28,610 --> 00:34:33,120
Um, it's simple enough that hopefully,

896
00:34:33,120 --> 00:34:35,070
um, you know it would

897
00:34:35,070 --> 00:34:36,600
be relatively straightforward

898
00:34:36,600 --> 00:34:38,550
for you to read all the source code,

899
00:34:38,550 --> 00:34:40,080
as well as read the book,

900
00:34:40,080 --> 00:34:41,910
in a couple of weeks certainly

901
00:34:41,910 --> 00:34:43,560
during the semester in order to

902
00:34:43,560 --> 00:34:44,970
kind of understand all of what

903
00:34:44,970 --> 00:34:47,200
happens inside xv6.

904
00:34:47,680 --> 00:34:52,110
Um, xv6 runs on the RISC-V

905
00:34:52,110 --> 00:34:55,320
processor, RISC-V microprocessor and this is

906
00:34:55,320 --> 00:34:57,690
the same microprocessor that's the focus of

907
00:34:57,690 --> 00:34:59,700
recent 6.004

908
00:34:59,800 --> 00:35:01,750
Um, so many of you may actually

909
00:35:01,750 --> 00:35:03,520
know quite a bit about the

910
00:35:03,520 --> 00:35:05,240
RISC-V instruction set.

911
00:35:05,780 --> 00:35:08,720
Um, in theory you could run xv6

912
00:35:08,720 --> 00:35:11,510
on top of a RISC-V computer

913
00:35:11,510 --> 00:35:13,370
and people done that.

914
00:35:13,370 --> 00:35:16,330
Um, but we're going to run it under the QEMU,

915
00:35:16,330 --> 00:35:18,910
um, machine emulator,

916
00:35:18,910 --> 00:35:20,680
just write this down we got.

917
00:35:20,810 --> 00:35:22,400
Our operating system is

918
00:35:22,400 --> 00:35:26,300
xv6, um, runs on RISC-V.

919
00:35:26,720 --> 00:35:30,350
Microprocessor and not just RISC-V microprocessor,

920
00:35:30,350 --> 00:35:31,790
but we assume a certain amount

921
00:35:31,790 --> 00:35:34,670
of surrounding hardware like memory

922
00:35:34,670 --> 00:35:36,120
and disk.

923
00:35:36,280 --> 00:35:39,520
And console interface for us to talk to it.

924
00:35:39,520 --> 00:35:43,300
Um, We actually run under the QEMU

925
00:35:44,720 --> 00:35:46,980
machine simulator.

926
00:35:48,440 --> 00:35:50,210
So that which runs under Linux,

927
00:35:50,210 --> 00:35:52,800
so I'm all you can actually.

928
00:35:53,400 --> 00:35:56,120
A run xv6 without having that hardware.

929
00:35:56,860 --> 00:36:01,260
Okay so kind of switch to a show the code.

930
00:36:15,570 --> 00:36:16,050
All right,

931
00:36:16,050 --> 00:36:22,660
so, um, first thing is I've a setup xv6 on my laptop,

932
00:36:22,800 --> 00:36:25,440
I'm going to run it type 'make qemu',

933
00:36:25,440 --> 00:36:25,740
'make qemu',

934
00:36:25,740 --> 00:36:27,030
you'll find yourself doing quite a

935
00:36:27,030 --> 00:36:28,320
bit during the labs,

936
00:36:28,320 --> 00:36:30,960
um, which compiles xv6 it's written in C,

937
00:36:30,960 --> 00:36:32,440
so it's compiled with

938
00:36:32,520 --> 00:36:33,990
C compiler,

939
00:36:33,990 --> 00:36:36,930
maybe I'll 'make clean' for you,

940
00:36:36,930 --> 00:36:39,000
so you can see the actual compilation

941
00:36:39,000 --> 00:36:40,620
and I might 'make qemu',

942
00:36:40,620 --> 00:36:43,170
which has the effect of compiling and

943
00:36:43,170 --> 00:36:45,180
building xv6 kernel and all the

944
00:36:45,180 --> 00:36:48,600
user processes and then running them under

945
00:36:48,600 --> 00:36:50,300
the QEMU emulator.

946
00:36:51,860 --> 00:36:53,880
Takes a moment around the compiles,

947
00:36:55,020 --> 00:36:58,220
yeah, and now we're up and running

948
00:36:58,220 --> 00:36:59,990
xv6 and the '$'

949
00:36:59,990 --> 00:37:02,570
prompt you see as the shell which

950
00:37:02,570 --> 00:37:04,460
is the command line interface,

951
00:37:04,460 --> 00:37:08,360
um, to xv6, modeled after the shell on unix,

952
00:37:08,360 --> 00:37:09,160
which is.

953
00:37:09,420 --> 00:37:12,240
um, if you log into Athena organization and

954
00:37:12,240 --> 00:37:14,880
it's, um, it's like the shell that

955
00:37:14,880 --> 00:37:16,080
Athena shows you.

956
00:37:18,180 --> 00:37:20,580
xv6 itself tiny and it comes with

957
00:37:20,580 --> 00:37:23,920
a small number of utility programs and

958
00:37:24,220 --> 00:37:26,110
including for example the 'ls' program which

959
00:37:26,110 --> 00:37:28,390
I'm about to run run ls and

960
00:37:28,390 --> 00:37:29,660
it gives me a list of

961
00:37:30,210 --> 00:37:31,470
all the files and xv6

962
00:37:31,470 --> 00:37:32,670
of which there are only about

963
00:37:32,670 --> 00:37:36,320
two dozen including things like grep and

964
00:37:36,410 --> 00:37:39,830
kill and mkdir, rm which

965
00:37:39,830 --> 00:37:41,210
may be familiar to us,

966
00:37:41,210 --> 00:37:43,640
um, as unix utilities.

967
00:37:44,930 --> 00:37:46,010
Okay, the first program,

968
00:37:46,010 --> 00:37:47,540
I'm gonna show you to illustrate system

969
00:37:47,540 --> 00:37:52,380
calls is a program called copy,

970
00:37:54,520 --> 00:38:01,220
um, um,

971
00:38:01,900 --> 00:38:04,260
here's the source is just a page,

972
00:38:07,320 --> 00:38:09,750
um, so what you're seeing here is

973
00:38:09,750 --> 00:38:11,940
a program that starts on line

974
00:38:11,940 --> 00:38:13,290
8 and main is that sort

975
00:38:13,290 --> 00:38:15,510
of convention for C programs,

976
00:38:15,510 --> 00:38:17,740
it sits in a loop at line 12,

977
00:38:17,940 --> 00:38:21,150
and over and over again, it reads

978
00:38:21,150 --> 00:38:23,280
some data as input and on line

979
00:38:23,280 --> 00:38:25,110
13 and then writes the data just

980
00:38:25,110 --> 00:38:28,180
read his output on line 16,

981
00:38:28,390 --> 00:38:29,800
by run copy,

982
00:38:32,130 --> 00:38:35,550
um, in xv6, it's waiting to read input,

983
00:38:35,550 --> 00:38:37,740
if I type some input,

984
00:38:37,840 --> 00:38:40,860
I'm reads it and spits it back up to me.

985
00:38:41,640 --> 00:38:44,380
Very simple program just does IO.

986
00:38:44,950 --> 00:38:47,170
Um, it's really see as I mentioned a

987
00:38:47,170 --> 00:38:49,090
if you don't already know C, it's

988
00:38:49,090 --> 00:38:53,290
worthwhile getting the standard C programming language

989
00:38:53,290 --> 00:38:55,100
book by Kernighan and Ritchie.

990
00:38:55,180 --> 00:38:56,400
And I think there's a

991
00:38:56,730 --> 00:38:59,490
more full reference to it on the

992
00:38:59,490 --> 00:39:02,680
course website which explains to you and,

993
00:39:02,760 --> 00:39:05,380
um, very straightforward way how to program in C.

994
00:39:06,140 --> 00:39:09,200
Yeah, as I mentioned before,

995
00:39:09,200 --> 00:39:11,870
we even write this program makes two

996
00:39:11,870 --> 00:39:13,340
really three system calls read

997
00:39:13,340 --> 00:39:16,320
write and exit, our system calls.

998
00:39:16,460 --> 00:39:18,140
Um, if you look at the call to

999
00:39:18,140 --> 00:39:22,020
read on line 13, it takes three arguments,

1000
00:39:22,500 --> 00:39:23,970
the first argument is a file descriptor

1001
00:39:23,970 --> 00:39:25,230
which is really a reference to a

1002
00:39:25,230 --> 00:39:27,060
previously opened file.

1003
00:39:27,340 --> 00:39:29,140
Um, and the shell,

1004
00:39:29,140 --> 00:39:33,340
ensures that when a program starts by default,

1005
00:39:33,440 --> 00:39:35,750
it's file descriptor 0 is connected to

1006
00:39:35,750 --> 00:39:38,300
the console input, and its file descriptor

1007
00:39:38,300 --> 00:39:41,090
1 is connected to the console

1008
00:39:41,090 --> 00:39:42,170
output, and that's why I was

1009
00:39:42,170 --> 00:39:43,600
able to type to

1010
00:39:43,920 --> 00:39:46,900
this copy program and see the output.

1011
00:39:48,700 --> 00:39:52,660
Um, of course, these file descriptors are expected

1012
00:39:52,660 --> 00:39:54,640
the program expected these file descriptors have

1013
00:39:54,640 --> 00:39:56,350
been previously opened and set up by

1014
00:39:56,350 --> 00:39:57,500
the shell for it.

1015
00:39:57,600 --> 00:40:01,860
And 0 1 file descriptors,

1016
00:40:01,920 --> 00:40:03,780
pervasive units convention many,

1017
00:40:03,780 --> 00:40:06,240
many unix programs expect to read from

1018
00:40:06,240 --> 00:40:09,180
file descriptor 1 and read file descriptor

1019
00:40:09,180 --> 00:40:11,520
0 and write to file descriptor 1.

1020
00:40:12,730 --> 00:40:14,980
A second argument to read is a

1021
00:40:14,980 --> 00:40:17,000
pointer to some memory,

1022
00:40:17,160 --> 00:40:19,110
um, where the program is asking the operating

1023
00:40:19,110 --> 00:40:21,020
system to read data

1024
00:40:21,390 --> 00:40:22,710
into that address in memory,

1025
00:40:22,710 --> 00:40:25,800
so that's the buff argument and line 10

1026
00:40:26,000 --> 00:40:30,060
allocate 64 bytes of memory on the stack, um,

1027
00:40:30,350 --> 00:40:31,910
for read to read into, and the

1028
00:40:31,910 --> 00:40:33,800
third argument to read is the maximum

1029
00:40:33,800 --> 00:40:35,540
number of bytes that the program wants

1030
00:40:35,540 --> 00:40:37,490
to read and the size of buffs

1031
00:40:37,490 --> 00:40:40,730
as just sixty maximum 64 bytes,

1032
00:40:40,730 --> 00:40:42,410
so the recall reads up to 64

1033
00:40:42,410 --> 00:40:45,080
bytes from whatever is connected to file

1034
00:40:45,080 --> 00:40:46,860
descriptor 0 and that was

1035
00:40:47,080 --> 00:40:48,820
my terminal in this example.

1036
00:40:48,820 --> 00:40:51,460
The return value from read it either

1037
00:40:51,460 --> 00:40:53,230
it may be sure of the number

1038
00:40:53,230 --> 00:40:54,640
of bytes read,

1039
00:40:54,640 --> 00:40:58,240
um, which would be 6 and a piece of, um,

1040
00:40:58,240 --> 00:41:00,740
typing "xyzzy" by

1041
00:41:01,150 --> 00:41:02,830
be might be reading from a file,

1042
00:41:02,830 --> 00:41:04,090
if it gets to the end of the file,

1043
00:41:04,090 --> 00:41:05,110
there's no more bytes,

1044
00:41:05,110 --> 00:41:06,760
read will return 0.

1045
00:41:07,160 --> 00:41:09,470
And then some other error occurred like

1046
00:41:09,470 --> 00:41:11,900
the file descriptor doesn't exist, read may

1047
00:41:11,900 --> 00:41:13,440
return -1.

1048
00:41:13,780 --> 00:41:15,940
And, so in many of these examples

1049
00:41:15,940 --> 00:41:17,860
like on line 16 there.

1050
00:41:17,940 --> 00:41:20,640
Um I don't my example code doesn't

1051
00:41:20,640 --> 00:41:24,240
check system call returns for errors.

1052
00:41:24,540 --> 00:41:26,340
But you should be more careful than me,

1053
00:41:26,340 --> 00:41:29,220
um, um the you should figure out how

1054
00:41:29,220 --> 00:41:30,750
system calls reflect errors,

1055
00:41:30,750 --> 00:41:32,220
it's usually a -1 return

1056
00:41:32,220 --> 00:41:35,040
value and check all system called

1057
00:41:35,040 --> 00:41:36,560
returns for errors.

1058
00:41:37,280 --> 00:41:38,630
And if you want to know

1059
00:41:38,630 --> 00:41:40,550
what the system call arguments and

1060
00:41:40,550 --> 00:41:42,080
return values are there's a table

1061
00:41:42,080 --> 00:41:43,760
and I think chapter 2 in

1062
00:41:43,760 --> 00:41:46,250
the book explains all of the

1063
00:41:46,250 --> 00:41:50,500
xv6 system call arguments and

1064
00:41:50,880 --> 00:41:52,770
return values.

1065
00:41:52,770 --> 00:41:55,440
The question regarding the read syscall,

1066
00:41:55,440 --> 00:41:57,120
what if we set the max read

1067
00:41:57,120 --> 00:41:59,520
bytes to size of buff to one

1068
00:41:59,520 --> 00:42:01,500
plus size of buffer or bigger,

1069
00:42:01,500 --> 00:42:03,030
so what if we try to read more than the size.

1070
00:42:03,030 --> 00:42:06,900
Yeah, then if there was 65 bytes to read,

1071
00:42:06,900 --> 00:42:10,080
then the operating system would happily will just

1072
00:42:10,130 --> 00:42:12,800
copy those 65 bytes to

1073
00:42:12,800 --> 00:42:14,780
the memory that you provide

1074
00:42:14,780 --> 00:42:16,790
and of course there's something

1075
00:42:16,790 --> 00:42:17,660
else on the stack up

1076
00:42:17,660 --> 00:42:19,700
there maybe the return program

1077
00:42:19,700 --> 00:42:20,870
counter or an argument or

1078
00:42:20,870 --> 00:42:22,460
something and so if you

1079
00:42:22,460 --> 00:42:23,930
pass 65,

1080
00:42:23,930 --> 00:42:26,920
then you're inviting a kernel to write junk.

1081
00:42:27,120 --> 00:42:29,840
Um to an unexpected place in your stack.

1082
00:42:30,280 --> 00:42:32,470
And so that's a bug and it

1083
00:42:32,470 --> 00:42:34,160
may cause your [firm] to crash.

1084
00:42:34,420 --> 00:42:37,390
Or do something else unexpected,

1085
00:42:37,390 --> 00:42:38,650
so as a programmer,

1086
00:42:38,650 --> 00:42:39,580
you have to be careful here,

1087
00:42:39,580 --> 00:42:42,130
there's nobody writing in C with these

1088
00:42:42,130 --> 00:42:43,540
kind of interfaces there's.

1089
00:42:43,830 --> 00:42:46,320
Um, it's very very easy to write

1090
00:42:46,320 --> 00:42:48,420
code that the compiler is happy

1091
00:42:48,420 --> 00:42:50,130
with and will run but absolutely

1092
00:42:50,130 --> 00:42:51,340
does the wrong thing.

1093
00:42:51,660 --> 00:42:57,320
Um, so that's too bad but it's the way it is.

1094
00:43:00,540 --> 00:43:01,350
Okay, um,

1095
00:43:01,350 --> 00:43:03,750
one thing to note is that this

1096
00:43:03,750 --> 00:43:05,700
copy program and indeed the read write

1097
00:43:05,700 --> 00:43:07,740
system calls they don't care about the

1098
00:43:07,740 --> 00:43:08,460
format of data,

1099
00:43:08,460 --> 00:43:10,470
they're reading or writing a they just

1100
00:43:10,470 --> 00:43:12,480
read and write read and write in

1101
00:43:12,480 --> 00:43:13,820
this copy program.

1102
00:43:13,980 --> 00:43:15,780
Just deal with 8 bit bytes with

1103
00:43:15,780 --> 00:43:17,600
screams of 8 bit bytes.

1104
00:43:17,680 --> 00:43:20,500
Um, how you interpret them is totally up

1105
00:43:20,500 --> 00:43:21,220
to the application,

1106
00:43:21,220 --> 00:43:23,160
so the application maybe,

1107
00:43:23,300 --> 00:43:26,840
a parse there data records or as C source code,

1108
00:43:26,840 --> 00:43:28,100
or who knows what.

1109
00:43:28,890 --> 00:43:30,390
The operating system,

1110
00:43:30,390 --> 00:43:34,200
um, the only things in terms of a

1111
00:43:34,200 --> 00:43:36,120
stream of 8 bit bytes.

1112
00:43:36,220 --> 00:43:37,420
Okay, so copy,

1113
00:43:37,420 --> 00:43:38,800
assumed this code,

1114
00:43:38,800 --> 00:43:40,120
my copy I can assume that the

1115
00:43:40,120 --> 00:43:42,850
file descriptors are already set up,

1116
00:43:42,850 --> 00:43:44,380
but we need to need to have

1117
00:43:44,380 --> 00:43:46,220
a way to create file descriptors.

1118
00:43:46,280 --> 00:43:47,870
And the most straightforward way to do

1119
00:43:47,870 --> 00:43:51,140
that is I'm with the open system

1120
00:43:51,140 --> 00:43:52,910
call and so here's the source for

1121
00:43:52,910 --> 00:43:55,520
a program that called open.

1122
00:43:55,720 --> 00:43:57,180
That um,

1123
00:43:58,120 --> 00:44:00,370
I use the open system call. A

1124
00:44:00,370 --> 00:44:01,600
question from the chat,

1125
00:44:01,600 --> 00:44:04,900
what do you mean by a stream of bytes.

1126
00:44:07,190 --> 00:44:09,380
Um, I just mean that if a

1127
00:44:09,380 --> 00:44:12,060
file contains a bunch of bytes.

1128
00:44:12,180 --> 00:44:15,000
Then read then successive spilling a pile

1129
00:44:15,000 --> 00:44:16,860
contains a million bytes,

1130
00:44:16,860 --> 00:44:21,040
if you make a sequence of recalls each 400 bytes.

1131
00:44:21,160 --> 00:44:22,330
You know I'll just read the first

1132
00:44:22,330 --> 00:44:23,710
hundred bytes and then the second hundred

1133
00:44:23,710 --> 00:44:24,580
bytes and then third,

1134
00:44:24,580 --> 00:44:27,260
the third hundred bytes.

1135
00:44:27,960 --> 00:44:28,880
And um.

1136
00:44:32,000 --> 00:44:32,330
All right,

1137
00:44:32,330 --> 00:44:33,350
so this program,

1138
00:44:33,350 --> 00:44:36,380
um, called open, I'll run it for you.

1139
00:44:36,720 --> 00:44:39,990
Um, what it does is a opens creates

1140
00:44:39,990 --> 00:44:41,940
a new file called "output.txt"

1141
00:44:41,940 --> 00:44:44,520
and then write some bytes to it,

1142
00:44:44,520 --> 00:44:45,990
I'm gonna finish this so we don't

1143
00:44:45,990 --> 00:44:48,180
see anything because it broke data to

1144
00:44:48,180 --> 00:44:49,020
this file.

1145
00:44:49,020 --> 00:44:50,380
But we can look

1146
00:44:50,700 --> 00:44:55,110
this "output.txt" file that created it and see,

1147
00:44:55,110 --> 00:44:57,390
um, the "ooo" wrote there,

1148
00:44:57,390 --> 00:45:00,100
so an 11 in the program.

1149
00:45:00,430 --> 00:45:02,380
Makes the open system call,

1150
00:45:02,380 --> 00:45:04,750
give it a filename "output.txt"

1151
00:45:04,750 --> 00:45:07,330
and the "O_" stuff,

1152
00:45:07,330 --> 00:45:08,860
um in the second argument to open

1153
00:45:08,860 --> 00:45:12,070
our flags that tell the open system

1154
00:45:12,070 --> 00:45:14,500
call implementation in the kernel, that we'd

1155
00:45:14,500 --> 00:45:16,030
like to create a file with its

1156
00:45:16,030 --> 00:45:18,020
name and we're going to write it.

1157
00:45:18,860 --> 00:45:22,000
Open returns a newly allocated file descriptor.

1158
00:45:22,570 --> 00:45:24,670
Um, and the file descriptor is just

1159
00:45:24,670 --> 00:45:26,410
a small number, probably 2 or

1160
00:45:26,410 --> 00:45:27,760
3 or 4 something.

1161
00:45:28,430 --> 00:45:29,840
And then we pass that same file

1162
00:45:29,840 --> 00:45:32,960
descriptor right along with the buffer and

1163
00:45:33,050 --> 00:45:36,760
a number of ways to write a that writes data,

1164
00:45:37,040 --> 00:45:37,940
um, the file,

1165
00:45:37,940 --> 00:45:40,080
the file descriptor refers to.

1166
00:45:41,430 --> 00:45:43,440
What that file descriptor is actually doing

1167
00:45:43,440 --> 00:45:46,170
is indexing into a little table inside

1168
00:45:46,170 --> 00:45:49,410
the kernel, the kernel maintains state for each process,

1169
00:45:49,410 --> 00:45:51,660
that's running each program that you run

1170
00:45:51,660 --> 00:45:52,620
and among other things,

1171
00:45:52,620 --> 00:45:55,140
the kernel remembers a table for every

1172
00:45:55,140 --> 00:45:58,830
running process of index by file descriptors

1173
00:45:58,830 --> 00:46:01,020
and the table sort of tells the

1174
00:46:01,020 --> 00:46:04,380
kernel what each file descriptor refers to.

1175
00:46:05,040 --> 00:46:10,960
Okay, a critical point is that each process

1176
00:46:10,960 --> 00:46:13,300
has its own sort of space of

1177
00:46:13,300 --> 00:46:15,040
file descriptors. So,

1178
00:46:15,200 --> 00:46:17,420
before running two different processes,

1179
00:46:17,420 --> 00:46:19,790
two different programs and different processes and

1180
00:46:19,790 --> 00:46:20,990
they both open a file,

1181
00:46:20,990 --> 00:46:22,640
they may actually get the same number

1182
00:46:22,640 --> 00:46:24,350
back as a file descriptor,

1183
00:46:24,350 --> 00:46:26,450
but because the kernel maintains a separate

1184
00:46:26,450 --> 00:46:29,000
file descriptor for each process,

1185
00:46:29,080 --> 00:46:31,630
the same file descriptor number may refer

1186
00:46:31,630 --> 00:46:34,720
to different files in different processes.

1187
00:46:37,040 --> 00:46:39,640
Any questions that open about this little program.

1188
00:46:40,240 --> 00:46:41,050
Now we had a question in

1189
00:46:41,050 --> 00:46:42,640
chat, question from someone not

1190
00:46:42,640 --> 00:46:43,990
familiar with C,

1191
00:46:43,990 --> 00:46:46,540
how are these files being described different

1192
00:46:46,540 --> 00:46:47,830
from normal C programs,

1193
00:46:47,830 --> 00:46:49,990
is it because we're only using kernel

1194
00:46:49,990 --> 00:46:52,480
calls, i.e couldn't we also open or

1195
00:46:52,480 --> 00:46:54,040
write a file in python.

1196
00:46:58,500 --> 00:47:01,260
Um, I don't think I understand that

1197
00:47:02,000 --> 00:47:02,750
it's a C program,

1198
00:47:02,750 --> 00:47:04,520
that's opening and writing a file.

1199
00:47:12,480 --> 00:47:18,040
Um, that's going to move on.

1200
00:47:20,640 --> 00:47:24,780
All right so you might ask what

1201
00:47:24,780 --> 00:47:27,480
actually happens when ... Maybe the question

1202
00:47:27,480 --> 00:47:29,430
is when someone is doing it

1203
00:47:29,430 --> 00:47:31,110
in C any different than doing

1204
00:47:31,110 --> 00:47:33,300
it in Python minus the syntax.

1205
00:47:34,240 --> 00:47:38,380
Well it's not really, um,

1206
00:47:38,620 --> 00:47:44,040
and, there's certainly ways to, um,

1207
00:47:44,410 --> 00:47:48,280
python provides nice function calls for opening

1208
00:47:48,280 --> 00:47:50,040
and doing all these things too.

1209
00:47:50,830 --> 00:47:51,640
Or opening files,

1210
00:47:51,640 --> 00:47:53,590
for example in reading writing files,

1211
00:47:53,590 --> 00:47:56,890
um, there's a layer of a higher

1212
00:47:56,890 --> 00:47:59,920
somewhat higher level functions typically not

1213
00:47:59,920 --> 00:48:00,970
pointers the memory,

1214
00:48:00,970 --> 00:48:01,940
for example.

1215
00:48:02,140 --> 00:48:06,680
Um, and python has more error checking for you.

1216
00:48:07,140 --> 00:48:09,120
Um, but when you open a file in

1217
00:48:09,120 --> 00:48:11,940
python or write a file on python, the

1218
00:48:11,960 --> 00:48:13,360
python calls you make.

1219
00:48:14,300 --> 00:48:18,160
Boil down to system calls just like these.

1220
00:48:19,840 --> 00:48:21,520
Is that a good answer.

1221
00:48:25,860 --> 00:48:27,030
Think so.

1222
00:48:27,030 --> 00:48:28,940
All right,

1223
00:48:30,980 --> 00:48:32,840
all right, um.

1224
00:48:33,560 --> 00:48:36,680
I've been over here talking to the, um,

1225
00:48:39,120 --> 00:48:43,440
xv6 is unix like shell

1226
00:48:43,440 --> 00:48:44,970
and the shell is what people often

1227
00:48:44,970 --> 00:48:46,890
call the command line interface,

1228
00:48:46,890 --> 00:48:50,980
um, as opposed to a more graphical user interface.

1229
00:48:51,240 --> 00:48:53,370
Um, the shell turns,

1230
00:48:53,370 --> 00:48:54,450
if you haven't used the shell,

1231
00:48:54,450 --> 00:48:56,400
the shell turns out to be a

1232
00:48:56,400 --> 00:48:58,200
pretty useful interface for things like system

1233
00:48:58,200 --> 00:49:01,440
management of unix systems,

1234
00:49:01,440 --> 00:49:02,940
it provides a lot of utilities

1235
00:49:02,940 --> 00:49:05,370
for messing around with files and

1236
00:49:05,370 --> 00:49:07,080
for program development and

1237
00:49:07,140 --> 00:49:09,180
on writing scripts to do all these

1238
00:49:09,180 --> 00:49:12,340
things. So, [some before run],

1239
00:49:12,550 --> 00:49:13,660
I just want to demonstrate a few

1240
00:49:13,660 --> 00:49:16,630
shell features ordinarily when you type things,

1241
00:49:16,630 --> 00:49:20,080
um. You're telling the shell to run a program,

1242
00:49:20,080 --> 00:49:21,280
so when I type ls what

1243
00:49:21,280 --> 00:49:23,410
that means is I'm asking the

1244
00:49:23,410 --> 00:49:25,480
shell to run the program

1245
00:49:25,530 --> 00:49:27,480
whose name is ls, and what

1246
00:49:27,480 --> 00:49:28,590
that really means is there's a

1247
00:49:28,590 --> 00:49:30,990
file in the file system called

1248
00:49:30,990 --> 00:49:33,630
ls that contains some instructions,

1249
00:49:33,630 --> 00:49:35,880
some machine instructions and I'm asking the

1250
00:49:35,880 --> 00:49:38,520
shell to run the instructions that are

1251
00:49:38,520 --> 00:49:40,770
in the file called ls,

1252
00:49:40,770 --> 00:49:44,660
one ls now ls what it actually does is, um.

1253
00:49:44,940 --> 00:49:46,290
Get a listing of the files in

1254
00:49:46,290 --> 00:49:47,250
the current directory,

1255
00:49:47,250 --> 00:49:48,150
and you can see up there

1256
00:49:48,150 --> 00:49:50,970
on the 4 line that among

1257
00:49:50,970 --> 00:49:52,900
the other files that

1258
00:49:52,980 --> 00:49:54,420
ls as exists,

1259
00:49:54,420 --> 00:49:56,040
and this list is a file called

1260
00:49:56,040 --> 00:49:58,560
ls which is in fact the file

1261
00:49:58,560 --> 00:50:00,540
containing the instructions I just ran.

1262
00:50:02,370 --> 00:50:03,660
The show does a few other things

1263
00:50:03,660 --> 00:50:06,690
for you other than running programs allows

1264
00:50:06,690 --> 00:50:08,490
you to redirect IO,

1265
00:50:08,490 --> 00:50:10,230
so for example if I say

1266
00:50:10,230 --> 00:50:12,420
'ls > out' what that means is

1267
00:50:12,420 --> 00:50:15,030
asking the shell run the ls command,

1268
00:50:15,030 --> 00:50:16,980
but with its output redirected to the

1269
00:50:16,980 --> 00:50:18,260
file called out.

1270
00:50:18,520 --> 00:50:19,920
I run ls.

1271
00:50:21,080 --> 00:50:22,640
We don't see any output because the

1272
00:50:22,640 --> 00:50:24,080
output all went out.

1273
00:50:24,960 --> 00:50:28,530
Um, now I can out contains a bunch of data,

1274
00:50:28,530 --> 00:50:30,380
um, we could.

1275
00:50:30,900 --> 00:50:33,300
The cat command reads a file and

1276
00:50:33,300 --> 00:50:35,430
displays the contents of the file,

1277
00:50:35,430 --> 00:50:37,080
so I say 'cat out'.

1278
00:50:37,190 --> 00:50:38,870
Just going to see now the now

1279
00:50:38,870 --> 00:50:41,080
this is the same output of ls.

1280
00:50:41,170 --> 00:50:42,490
You can also run a command like

1281
00:50:42,490 --> 00:50:43,420
'grep' and I can give it an

1282
00:50:43,420 --> 00:50:46,300
argument "x" and what 'grep x'.

1283
00:50:46,520 --> 00:50:48,700
The grep command searches for patterns.

1284
00:50:49,080 --> 00:50:54,360
Again a if I run 'grep x', it's gonna search for

1285
00:50:54,680 --> 00:50:58,250
lines of input to contain "x". I can redirect,

1286
00:50:58,250 --> 00:51:00,170
tell the shell to redirect its input

1287
00:51:00,170 --> 00:51:01,600
from the file "out".

1288
00:51:01,700 --> 00:51:03,170
In order to look for instances of

1289
00:51:03,170 --> 00:51:06,020
acts that saved ls output.

1290
00:51:07,150 --> 00:51:10,210
It turns out there's three files whose

1291
00:51:10,210 --> 00:51:12,080
names contain "x".

1292
00:51:13,000 --> 00:51:14,960
Yeah. Um,

1293
00:51:15,560 --> 00:51:16,430
we're going to spend a bunch of

1294
00:51:16,430 --> 00:51:17,450
time with the shell,

1295
00:51:17,450 --> 00:51:19,040
um, uh,

1296
00:51:19,040 --> 00:51:21,860
its shell is sort of the most

1297
00:51:21,860 --> 00:51:26,540
traditional and fundamental interface units,

1298
00:51:26,540 --> 00:51:29,180
because when unix was first developed, all

1299
00:51:29,180 --> 00:51:30,860
there was was simple terminal interfaces,

1300
00:51:30,860 --> 00:51:32,930
like the one we're using and

1301
00:51:32,930 --> 00:51:35,450
the main use of units originally was

1302
00:51:35,450 --> 00:51:37,370
time sharing a bunch of people logging

1303
00:51:37,370 --> 00:51:38,540
into the same machine,

1304
00:51:38,540 --> 00:51:41,960
much like Athena and talking to shells.

1305
00:51:43,300 --> 00:51:47,860
A question about system calls and the compiler,

1306
00:51:47,860 --> 00:51:49,300
how does the compiler handles system

1307
00:51:49,300 --> 00:51:51,310
calls does assembly generated make a

1308
00:51:51,310 --> 00:51:53,620
procedure call to some code segment

1309
00:51:53,620 --> 00:51:55,480
defined by the operating system.

1310
00:51:57,020 --> 00:51:59,960
Um, there's a special RISC-V instruction that

1311
00:51:59,960 --> 00:52:02,060
a program can call that transfers control

1312
00:52:02,060 --> 00:52:02,840
under the kernel,

1313
00:52:02,840 --> 00:52:05,360
so indeed when you write C code

1314
00:52:05,360 --> 00:52:07,550
that makes the system called open write,

1315
00:52:07,550 --> 00:52:10,520
um. And technically what actually happens is

1316
00:52:10,520 --> 00:52:12,950
open is a C function in

1317
00:52:12,950 --> 00:52:14,500
the C library.

1318
00:52:14,620 --> 00:52:17,860
Um, but the instructions in that function are

1319
00:52:17,860 --> 00:52:19,630
really machine instructions,

1320
00:52:19,630 --> 00:52:21,360
it's not open.

1321
00:52:21,820 --> 00:52:23,470
The open function that we're calling isn't

1322
00:52:23,470 --> 00:52:26,820
a C function implemented in assembler and,

1323
00:52:26,950 --> 00:52:28,630
the assembly code,

1324
00:52:28,630 --> 00:52:32,300
um, consists of this special instructions

1325
00:52:32,300 --> 00:52:34,060
actually called ecall.

1326
00:52:34,140 --> 00:52:35,910
On RISC-V the special instruction

1327
00:52:35,910 --> 00:52:37,440
that transfers control

1328
00:52:37,580 --> 00:52:38,900
into the kernel,

1329
00:52:38,900 --> 00:52:40,520
and then the kernel looks at

1330
00:52:40,520 --> 00:52:42,380
the processes memory and registers to

1331
00:52:42,380 --> 00:52:43,700
figure out what the

1332
00:52:44,260 --> 00:52:45,160
arguments were.

1333
00:52:50,610 --> 00:52:53,610
All right, the next example I want

1334
00:52:53,610 --> 00:52:55,800
to look at is example program

1335
00:52:55,800 --> 00:52:58,180
that calls 'fork'.

1336
00:52:58,420 --> 00:53:00,220
Creating process,

1337
00:53:00,220 --> 00:53:02,720
um, so this is the

1338
00:53:03,430 --> 00:53:04,780
very simple use of fork at

1339
00:53:04,780 --> 00:53:07,270
line 12, we're calling fork and

1340
00:53:07,270 --> 00:53:08,420
what fork does is

1341
00:53:08,670 --> 00:53:11,460
creates a copy of the memory of

1342
00:53:11,460 --> 00:53:14,490
instructions and data of the calling process,

1343
00:53:14,490 --> 00:53:17,720
now we have two processes with identical memory.

1344
00:53:18,010 --> 00:53:20,200
Fork, the fork system call returns

1345
00:53:20,200 --> 00:53:22,080
in both processes.

1346
00:53:22,360 --> 00:53:24,430
In the original process,

1347
00:53:24,430 --> 00:53:26,710
the fork system call returns the process

1348
00:53:26,710 --> 00:53:28,800
id which is, um

1349
00:53:29,080 --> 00:53:31,480
an integer greater than 0.

1350
00:53:32,100 --> 00:53:33,900
The original process for returns,

1351
00:53:33,900 --> 00:53:35,610
the process id of the newly created

1352
00:53:35,610 --> 00:53:38,580
process and in the newly created process

1353
00:53:38,580 --> 00:53:40,960
fork returns 0.

1354
00:53:41,630 --> 00:53:42,920
So we sort of break even though

1355
00:53:42,920 --> 00:53:45,230
the processes have identical memory,

1356
00:53:45,230 --> 00:53:47,720
you can break the symmetry of

1357
00:53:47,720 --> 00:53:49,310
old versus new process by the

1358
00:53:49,310 --> 00:53:50,800
return value from fork.

1359
00:53:50,940 --> 00:53:53,790
And in line 16 you can see code,

1360
00:53:53,790 --> 00:53:54,930
the checks and says if the

1361
00:53:54,930 --> 00:53:56,310
process id is equal 0 must

1362
00:53:56,310 --> 00:53:57,180
be the child,

1363
00:53:57,180 --> 00:53:59,100
you must now be running in the child.

1364
00:53:59,420 --> 00:54:01,850
Um, of course there's two processes in

1365
00:54:01,850 --> 00:54:03,260
the other process,

1366
00:54:03,260 --> 00:54:04,970
um in the calling process which is

1367
00:54:04,970 --> 00:54:07,220
usually called the parent process id is

1368
00:54:07,220 --> 00:54:08,560
greater than 0.

1369
00:54:08,640 --> 00:54:11,520
Um, so the child will print "child" and

1370
00:54:11,520 --> 00:54:13,500
the parent will print "parent".

1371
00:54:14,350 --> 00:54:18,540
And then they'll both exit. So when I run fork,

1372
00:54:19,380 --> 00:54:24,860
now here we get, so it may look like garbage.

1373
00:54:25,230 --> 00:54:27,630
What's actually happening is that after the fork,

1374
00:54:27,630 --> 00:54:29,340
both of these processes are running they're

1375
00:54:29,340 --> 00:54:31,800
both running at the same time and

1376
00:54:31,800 --> 00:54:35,540
QEMU is actually emulating a multi-core,

1377
00:54:35,750 --> 00:54:36,890
microprocessor for me,

1378
00:54:36,890 --> 00:54:39,380
so they really are running at

1379
00:54:39,380 --> 00:54:40,280
the very same time,

1380
00:54:40,280 --> 00:54:41,820
so when they produce output.

1381
00:54:41,850 --> 00:54:43,200
They're producing each byte of their

1382
00:54:43,200 --> 00:54:44,460
output at the same time as

1383
00:54:44,460 --> 00:54:45,840
the other process is producing the

1384
00:54:45,840 --> 00:54:47,670
corresponding bytes of its output,

1385
00:54:47,670 --> 00:54:50,360
so the output of the two processes are

1386
00:54:50,820 --> 00:54:52,260
inter league,

1387
00:54:52,260 --> 00:54:54,540
um, you can see that they're both typing "f".

1388
00:54:54,800 --> 00:54:57,380
Um, they're both gonna type fork return.

1389
00:54:57,800 --> 00:54:59,030
Um, so you can see the "f"

1390
00:54:59,030 --> 00:54:59,960
from both of them, in the

1391
00:54:59,960 --> 00:55:00,890
"o" both of them and the

1392
00:55:00,890 --> 00:55:02,500
"r" both and so on.

1393
00:55:02,920 --> 00:55:04,080
Um, one of them.

1394
00:55:04,700 --> 00:55:06,200
Um, you can see the 0 at the

1395
00:55:06,200 --> 00:55:08,060
end of that 1 line is in

1396
00:55:08,060 --> 00:55:10,040
the child fork return 0.

1397
00:55:10,100 --> 00:55:14,760
Um, I'm guessing that the parent fork return 19.

1398
00:55:14,960 --> 00:55:16,850
That is the child's process id is

1399
00:55:16,850 --> 00:55:19,400
19, under xv6 that basically means the

1400
00:55:19,400 --> 00:55:22,500
19 process that was created since boot.

1401
00:55:22,860 --> 00:55:25,890
Um, and then one of them prints "child"

1402
00:55:25,890 --> 00:55:26,880
and you can see the "c" "h"

1403
00:55:26,880 --> 00:55:28,800
"i" "l" "d" interleave with that is

1404
00:55:28,800 --> 00:55:30,480
the other one prepare.

1405
00:55:30,670 --> 00:55:32,580
So, yeah.

1406
00:55:32,930 --> 00:55:34,550
This is a silly use of fork,

1407
00:55:34,550 --> 00:55:36,650
but we can see vividly in

1408
00:55:36,650 --> 00:55:38,330
this output that has created two

1409
00:55:38,330 --> 00:55:39,640
processes that are,

1410
00:55:39,920 --> 00:55:41,780
and both of them are running for

1411
00:55:41,780 --> 00:55:43,880
returning both processes and they're both running.

1412
00:55:44,710 --> 00:55:46,750
But also note that one printed child

1413
00:55:46,750 --> 00:55:49,540
and the other parent so it's important

1414
00:55:49,540 --> 00:55:51,480
that fork returns differently

1415
00:55:51,770 --> 00:55:53,840
Um, and the two processes.

1416
00:55:59,680 --> 00:56:01,390
Question, um,

1417
00:56:01,390 --> 00:56:03,070
is the child process as a result of

1418
00:56:03,070 --> 00:56:05,290
fork always identical to the parent process

1419
00:56:05,290 --> 00:56:06,740
or could they be different.

1420
00:56:08,250 --> 00:56:13,560
Um, in xv6 are identical.

1421
00:56:13,740 --> 00:56:17,120
Um, except the return value from fork.

1422
00:56:17,260 --> 00:56:18,880
You know the instructions are the same

1423
00:56:18,880 --> 00:56:19,960
that data is the same,

1424
00:56:19,960 --> 00:56:22,090
the stack is the same,

1425
00:56:22,090 --> 00:56:23,960
um, also both.

1426
00:56:24,140 --> 00:56:28,700
Processes, the processor copies and they both have

1427
00:56:28,700 --> 00:56:30,080
their own separate

1428
00:56:30,160 --> 00:56:32,590
address spaces that is they both

1429
00:56:32,590 --> 00:56:34,390
have they both think that their

1430
00:56:34,390 --> 00:56:35,890
memory starts at 0 and goes

1431
00:56:35,890 --> 00:56:37,160
on up from there.

1432
00:56:37,400 --> 00:56:42,240
Um, but it's different it's different different memory.

1433
00:56:42,340 --> 00:56:43,960
Um, with the two of them.

1434
00:56:45,030 --> 00:56:46,680
In a more sophisticated operating system,

1435
00:56:46,680 --> 00:56:49,260
there are some details which we definitely

1436
00:56:49,260 --> 00:56:51,060
don't care about them,

1437
00:56:51,060 --> 00:56:53,790
they may occasionally cause parent and child

1438
00:56:53,790 --> 00:56:55,020
to differ, but in xv6

1439
00:56:55,020 --> 00:56:57,020
they're the same except the return value.

1440
00:56:57,880 --> 00:56:59,410
Um, so the memory is the same,

1441
00:56:59,410 --> 00:57:01,100
in addition the, um,

1442
00:57:02,010 --> 00:57:04,800
file descriptor table is copied.

1443
00:57:05,260 --> 00:57:08,920
So if the parent had some files open.

1444
00:57:09,140 --> 00:57:11,870
Um, and the child sees the same set

1445
00:57:11,870 --> 00:57:13,580
of file descriptors.

1446
00:57:13,800 --> 00:57:17,060
Um, although the child is seeing them in a copy.

1447
00:57:17,180 --> 00:57:20,780
Of the table of file descriptor information.

1448
00:57:21,550 --> 00:57:22,600
And so we'll see in a moment

1449
00:57:22,600 --> 00:57:25,210
that it's quite important that a fork

1450
00:57:25,210 --> 00:57:28,180
copies the table of open file descriptors

1451
00:57:28,180 --> 00:57:29,420
as well as the memory.

1452
00:57:31,340 --> 00:57:32,420
Okay so.

1453
00:57:33,360 --> 00:57:34,980
A fork creates a new process,

1454
00:57:34,980 --> 00:57:37,680
but when we run stuff in the shell,

1455
00:57:37,680 --> 00:57:40,950
um. The shell indeed creates a new process

1456
00:57:40,950 --> 00:57:43,260
to run each command that you type.

1457
00:57:43,320 --> 00:57:45,330
Um, but it needs to actually run the command in it,

1458
00:57:45,330 --> 00:57:47,160
so if I type ls,

1459
00:57:47,160 --> 00:57:49,590
we need to shell forks to create

1460
00:57:49,590 --> 00:57:50,790
a process to run ls,

1461
00:57:50,790 --> 00:57:52,860
but there needs to be some way.

1462
00:57:53,740 --> 00:57:55,930
For that new process actually run the

1463
00:57:55,930 --> 00:57:58,200
instructions from the ls program.

1464
00:57:58,510 --> 00:58:00,460
Below those instructions from the file called

1465
00:58:00,460 --> 00:58:03,610
ls and the example program,

1466
00:58:03,610 --> 00:58:05,180
I'm gonna show you in a minute.

1467
00:58:05,320 --> 00:58:06,940
Um, uses echo, echo is a very

1468
00:58:06,940 --> 00:58:10,330
simple command a just takes whatever arguments

1469
00:58:10,330 --> 00:58:11,920
you pass to it and writes them

1470
00:58:11,920 --> 00:58:12,860
to its output.

1471
00:58:13,860 --> 00:58:17,060
And I prepared for you a program called 'exec'.

1472
00:58:17,470 --> 00:58:22,320
Um, um.

1473
00:58:22,880 --> 00:58:26,020
Which a run which

1474
00:58:26,830 --> 00:58:29,590
makes the exec system call which replaces

1475
00:58:29,590 --> 00:58:32,650
the calling process with the instructions read

1476
00:58:32,650 --> 00:58:34,390
from a particular file

1477
00:58:34,390 --> 00:58:36,720
you specify.

1478
00:58:37,110 --> 00:58:39,510
Loads the instructions from that file over

1479
00:58:39,510 --> 00:58:42,240
the current process or discarding its current

1480
00:58:42,240 --> 00:58:45,600
memory and then starts executing those instructions,

1481
00:58:45,600 --> 00:58:48,270
so the call to exec system call

1482
00:58:48,270 --> 00:58:50,920
exec on line 12.

1483
00:58:52,620 --> 00:58:53,940
It's going to have the effect of

1484
00:58:53,940 --> 00:58:55,980
the operating system loading the instructions from

1485
00:58:55,980 --> 00:58:57,900
the file called echo.

1486
00:58:57,980 --> 00:59:00,860
In the current process sort of replacing

1487
00:59:00,860 --> 00:59:03,140
the memory of the current process and

1488
00:59:03,140 --> 00:59:04,940
then starting to execute.

1489
00:59:05,260 --> 00:59:07,330
Um, those instructions and in addition,

1490
00:59:07,330 --> 00:59:09,550
you can pass arguments command line arguments

1491
00:59:09,550 --> 00:59:12,160
echo exec allows you to pass an

1492
00:59:12,160 --> 00:59:14,220
array of command line arguments.

1493
00:59:14,670 --> 00:59:15,540
It was just an array of

1494
00:59:15,540 --> 00:59:18,360
pointers in C line 10 sets

1495
00:59:18,360 --> 00:59:19,780
up an array of

1496
00:59:19,810 --> 00:59:23,050
character pointers which are essentially strings and

1497
00:59:23,050 --> 00:59:24,900
initialize that array to be,

1498
00:59:25,040 --> 00:59:29,420
to contain the strings echo, this is echo, um.

1499
00:59:29,480 --> 00:59:32,090
And that's equivalent to calling running echo

1500
00:59:32,090 --> 00:59:33,140
with them and with

1501
00:59:33,360 --> 00:59:34,170
the three arguments.

1502
00:59:34,170 --> 00:59:36,960
This is echo and so when I want exec.

1503
00:59:38,200 --> 00:59:40,120
Um, indeed,

1504
00:59:40,120 --> 00:59:41,380
um I see this output,

1505
00:59:41,380 --> 00:59:41,980
this is echo,

1506
00:59:41,980 --> 00:59:43,690
but even though I ran the exec

1507
00:59:43,690 --> 00:59:45,920
command exec program.

1508
00:59:45,980 --> 00:59:48,080
What the exec program does is calling

1509
00:59:48,080 --> 00:59:50,270
the exec system call to replace itself

1510
00:59:50,270 --> 00:59:51,680
with echo and so it was really

1511
00:59:51,680 --> 00:59:53,220
the echo program.

1512
00:59:53,320 --> 00:59:55,260
I'm producing this output.

1513
00:59:58,600 --> 01:00:01,360
And something about the exec system call,

1514
01:00:01,360 --> 01:00:03,280
that's important for us is that

1515
01:00:03,280 --> 01:00:06,310
it exec preserves the current

1516
01:00:06,310 --> 01:00:08,380
table of file descriptors,

1517
01:00:08,380 --> 01:00:10,810
so whatever file descriptor 0 1 2

1518
01:00:10,810 --> 01:00:13,240
etc, were referred to before exec,

1519
01:00:13,240 --> 01:00:17,420
they refer to the same thing in this new program

1520
01:00:17,670 --> 01:00:19,280
whose instructions we've loaded.

1521
01:00:20,220 --> 01:00:22,470
Another point is that ordinarily exec does

1522
01:00:22,470 --> 01:00:25,780
not return because exec replaces

1523
01:00:26,040 --> 01:00:28,530
the current processes memory entirely,

1524
01:00:28,530 --> 01:00:31,170
um, there's nothing for exec to return to

1525
01:00:31,170 --> 01:00:32,620
exec you know.

1526
01:00:32,990 --> 01:00:34,730
Read the instructions for that file and

1527
01:00:34,730 --> 01:00:36,410
execute them and then that's it,

1528
01:00:36,410 --> 01:00:38,030
um, the only time exec turns

1529
01:00:38,030 --> 01:00:40,730
is if some error occurred that

1530
01:00:40,730 --> 01:00:42,620
prevented the operating system from running

1531
01:00:42,620 --> 01:00:43,940
that program for you,

1532
01:00:43,940 --> 01:00:45,770
so for example if the program doesn't

1533
01:00:45,770 --> 01:00:47,100
exist at all.

1534
01:00:48,080 --> 01:00:50,540
Exec can't find a file called echo,

1535
01:00:50,540 --> 01:00:54,060
for example an exec would return -1.

1536
01:00:54,220 --> 01:00:58,670
Um, Signal that something wrong it couldn't

1537
01:00:58,670 --> 01:00:59,960
couldn't find the file so ordinarily

1538
01:00:59,960 --> 01:01:01,460
exec does not return.

1539
01:01:01,520 --> 01:01:05,100
It only returns if the kernel

1540
01:01:05,220 --> 01:01:06,980
couldn't actually run the file for you.

1541
01:01:10,430 --> 01:01:11,740
Questions about exec.

1542
01:01:12,620 --> 01:01:13,640
The question in the chat is

1543
01:01:13,640 --> 01:01:15,320
what is the last 0 for

1544
01:01:15,320 --> 01:01:16,360
in argv.

1545
01:01:18,850 --> 01:01:21,940
It marks the end of the array

1546
01:01:21,940 --> 01:01:24,720
C is so low level that,

1547
01:01:25,000 --> 01:01:27,280
um, there's no

1548
01:01:27,670 --> 01:01:30,760
the C array scheme.

1549
01:01:32,340 --> 01:01:33,960
Doesn't have a way for

1550
01:01:34,650 --> 01:01:35,850
code to find out how long

1551
01:01:35,850 --> 01:01:37,830
the array is and so

1552
01:01:37,830 --> 01:01:39,400
tell the kernel that,

1553
01:01:39,570 --> 01:01:43,490
um, you know we met at the array contains echo,

1554
01:01:43,490 --> 01:01:46,300
this is echo and nothing more.

1555
01:01:46,560 --> 01:01:49,940
We put zero was the last strip as the last

1556
01:01:50,030 --> 01:01:52,670
pointer. Each of those strings in double quotes

1557
01:01:52,670 --> 01:01:54,920
is actually a pointer to some memory

1558
01:01:54,920 --> 01:01:56,440
that contains those bytes.

1559
01:01:56,720 --> 01:01:58,760
That fifth element of the array is

1560
01:01:58,760 --> 01:02:00,500
a pointer's value is 0,

1561
01:02:00,500 --> 01:02:02,270
the convention is that a pointer

1562
01:02:02,270 --> 01:02:04,010
whose value is 0 or what's

1563
01:02:04,010 --> 01:02:05,500
called a null pointer.

1564
01:02:05,590 --> 01:02:09,600
Um, sort of signifies nothing,

1565
01:02:09,600 --> 01:02:10,980
Um, with it.

1566
01:02:11,620 --> 01:02:13,600
You were gone,

1567
01:02:13,600 --> 01:02:14,920
so the code in the kernel

1568
01:02:14,920 --> 01:02:16,570
has actually walks through this array

1569
01:02:16,570 --> 01:02:17,680
until it finds it.

1570
01:02:18,090 --> 01:02:20,240
Element whose value is zero.

1571
01:02:24,690 --> 01:02:26,520
Okay, um,

1572
01:02:26,520 --> 01:02:27,420
all right,

1573
01:02:27,420 --> 01:02:29,780
so this is how a program can replace itself.

1574
01:02:30,800 --> 01:02:32,090
With another program from a file,

1575
01:02:32,090 --> 01:02:33,350
but actually when we run stuff in

1576
01:02:33,350 --> 01:02:35,510
the shell like 'echo abc',

1577
01:02:35,510 --> 01:02:38,900
um or ls or anything else,

1578
01:02:38,900 --> 01:02:40,400
we don't want to replace the shell,

1579
01:02:40,400 --> 01:02:41,570
we don't have a shell,

1580
01:02:41,570 --> 01:02:43,000
just call exec.

1581
01:02:43,420 --> 01:02:44,500
Um, because,

1582
01:02:44,500 --> 01:02:45,850
that would replace the shell with the

1583
01:02:45,850 --> 01:02:48,240
echo command then echo exited.

1584
01:02:48,320 --> 01:02:50,360
That would be end, you know

1585
01:02:50,360 --> 01:02:51,110
we don't want an echo to

1586
01:02:51,110 --> 01:02:52,040
replace the shell,

1587
01:02:52,040 --> 01:02:54,660
so the shell actually does is fork.

1588
01:02:54,940 --> 01:02:56,740
And then the child calls exec

1589
01:02:56,740 --> 01:02:59,440
and that's an extremely common unix

1590
01:02:59,440 --> 01:03:01,540
idiom program instead.

1591
01:03:01,600 --> 01:03:03,520
Um, want to run a program,

1592
01:03:03,520 --> 01:03:05,020
but regain control what they do

1593
01:03:05,020 --> 01:03:06,460
is call fork and have the

1594
01:03:06,460 --> 01:03:07,880
child called exec.

1595
01:03:08,000 --> 01:03:10,520
So here's a simple example,

1596
01:03:10,520 --> 01:03:12,400
this forkexec program.

1597
01:03:14,310 --> 01:03:17,580
In this program call fork line 12

1598
01:03:17,580 --> 01:03:19,350
in the child sort of line 14

1599
01:03:19,350 --> 01:03:21,330
we call exec much like before.

1600
01:03:21,330 --> 01:03:22,940
The child process,

1601
01:03:23,380 --> 01:03:28,060
um, has to replace itself with the echo command.

1602
01:03:28,220 --> 01:03:29,090
Um, echo,

1603
01:03:29,090 --> 01:03:31,220
does this thing and then exits.

1604
01:03:31,680 --> 01:03:32,760
And then the parent process,

1605
01:03:32,760 --> 01:03:37,360
regains control because um when fork returns.

1606
01:03:38,000 --> 01:03:39,860
Greater than zero value in the parent process,

1607
01:03:39,860 --> 01:03:41,330
so the parent process then continues to

1608
01:03:41,330 --> 01:03:43,760
execute at 19 and unix provides a

1609
01:03:43,760 --> 01:03:47,390
wait system call line 24 process to

1610
01:03:47,390 --> 01:03:50,180
wait for child that created

1611
01:03:50,180 --> 01:03:52,310
with fork, because when I run a

1612
01:03:52,310 --> 01:03:55,600
command on the command line.

1613
01:03:56,330 --> 01:04:00,020
We want shell to wait for the

1614
01:04:00,020 --> 01:04:02,210
command to finish before it prints the

1615
01:04:02,210 --> 01:04:04,310
prompt again, before it prints is $

1616
01:04:04,310 --> 01:04:06,620
prompt asking me for more input.

1617
01:04:06,730 --> 01:04:09,190
So it's the wait system call allows

1618
01:04:09,190 --> 01:04:10,720
a process to wait for any of

1619
01:04:10,720 --> 01:04:13,390
its children to return and this status

1620
01:04:13,390 --> 01:04:15,400
argument is that, um,

1621
01:04:15,590 --> 01:04:17,080
a way for

1622
01:04:17,950 --> 01:04:22,450
exiting child to communicate one integer

1623
01:04:22,450 --> 01:04:25,900
32 bit value from the exiting child

1624
01:04:25,900 --> 01:04:28,330
to the waiting parents on line 17 that

1625
01:04:28,330 --> 01:04:30,700
argument to exit that 1 that's the

1626
01:04:30,700 --> 01:04:32,000
argument to exit.

1627
01:04:32,060 --> 01:04:35,750
The operating system passes that one from

1628
01:04:35,750 --> 01:04:37,340
the exiting child

1629
01:04:37,460 --> 01:04:39,200
to the call to wait line

1630
01:04:39,200 --> 01:04:42,460
20 so wait the & wait,

1631
01:04:42,700 --> 01:04:44,350
is passing the address of the

1632
01:04:44,350 --> 01:04:46,720
status variable to the kernel,

1633
01:04:46,720 --> 01:04:49,400
the kernel fills in that address with,

1634
01:04:49,720 --> 01:04:51,800
um, child's argument to exit.

1635
01:04:52,770 --> 01:04:54,690
And the convention in unix is that

1636
01:04:54,690 --> 01:04:58,560
if a program completes successfully exit exits

1637
01:04:58,560 --> 01:05:00,120
with status 0.

1638
01:05:00,430 --> 01:05:04,200
Um, but it has encountered an error at line 17.

1639
01:05:04,280 --> 01:05:06,800
Um, the unix convention is that you

1640
01:05:06,800 --> 01:05:08,810
pass 1 to exit and so if

1641
01:05:08,810 --> 01:05:10,940
you care the calling process can look

1642
01:05:10,940 --> 01:05:13,180
at the status from wait.

1643
01:05:13,240 --> 01:05:14,700
Decide whether the

1644
01:05:15,270 --> 01:05:19,080
child completed successfully. A professor

1645
01:05:19,080 --> 01:05:20,400
Morris quick question.

1646
01:05:20,560 --> 01:05:25,090
Yes, about the exec call 19, um,

1647
01:05:25,090 --> 01:05:27,280
we mentioned not a bit ago that

1648
01:05:27,280 --> 01:05:29,890
exec will completely go into the echo

1649
01:05:29,890 --> 01:05:32,660
program and not return to fork exec.

1650
01:05:33,060 --> 01:05:33,930
Um, so,

1651
01:05:33,930 --> 01:05:37,260
oh, would ever reach line 16 and 17.

1652
01:05:38,170 --> 01:05:41,490
Well, not for this exec code because there

1653
01:05:41,490 --> 01:05:44,130
happens to be a program called echo,

1654
01:05:44,130 --> 01:05:46,560
but if I modify that code here,

1655
01:05:46,560 --> 01:05:49,470
let me just modify this code.

1656
01:05:49,470 --> 01:05:50,550
Okay, so first let me just

1657
01:05:50,550 --> 01:05:51,820
run forkexec.

1658
01:05:53,590 --> 01:05:56,290
It actually does execute echo with those

1659
01:05:56,290 --> 01:05:57,580
arguments we see the output,

1660
01:05:57,580 --> 01:05:59,650
"this is echo" and we see

1661
01:05:59,650 --> 01:06:02,280
the child exited to show that

1662
01:06:02,900 --> 01:06:05,840
echo exited successfully and the parent wait

1663
01:06:05,840 --> 01:06:07,180
for. Let me just

1664
01:06:07,370 --> 01:06:09,080
modify the program for you.

1665
01:06:09,630 --> 01:06:12,150
Um, instead of echo going to run some

1666
01:06:12,150 --> 01:06:13,580
command that doesn't exist.

1667
01:06:14,180 --> 01:06:15,660
Um, um,

1668
01:06:15,660 --> 01:06:18,240
actually the exit out of

1669
01:06:18,240 --> 01:06:21,520
QEMU. With 'Ctrl-a x' and then rebuild

1670
01:06:21,520 --> 01:06:23,700
the whole thing in order to re-compile

1671
01:06:23,920 --> 01:06:25,380
I modified.

1672
01:06:25,850 --> 01:06:27,650
Forkexec now run forkexec back again

1673
01:06:27,650 --> 01:06:29,500
after modifying it.

1674
01:06:29,800 --> 01:06:31,060
And this time because the program

1675
01:06:31,060 --> 01:06:32,280
we're asking to,

1676
01:06:32,760 --> 01:06:34,220
um, actually,

1677
01:06:36,600 --> 01:06:37,080
the program,

1678
01:06:37,080 --> 01:06:39,600
we're asking to execute doesn't exist,

1679
01:06:39,600 --> 01:06:43,560
exec does return we see the exec failed output.

1680
01:06:43,840 --> 01:06:46,180
Um, and the exit 1 you'll see

1681
01:06:46,180 --> 01:06:47,770
the 1 there is communicated back

1682
01:06:47,770 --> 01:06:48,880
to the parent which says the

1683
01:06:48,880 --> 01:06:50,760
child exited the status 1.

1684
01:06:52,280 --> 01:06:55,610
So exec returns back to the calling

1685
01:06:55,610 --> 01:06:57,680
function when something went wrong.

1686
01:06:57,740 --> 01:07:01,700
Yes. Yeah.

1687
01:07:08,700 --> 01:07:11,040
Okay good.

1688
01:07:14,680 --> 01:07:15,220
All right,

1689
01:07:15,220 --> 01:07:17,710
um, something that going to note

1690
01:07:17,710 --> 01:07:19,540
here that actually think many of you

1691
01:07:19,540 --> 01:07:21,240
already noted is that.

1692
01:07:21,300 --> 01:07:23,430
It is a common idiom here,

1693
01:07:23,430 --> 01:07:25,440
this fork followed by exec in the

1694
01:07:25,440 --> 01:07:28,710
child and it's potentially a bit wasteful

1695
01:07:28,710 --> 01:07:32,080
the fork copies the entire parent process.

1696
01:07:32,320 --> 01:07:34,840
But exec throws away all that copied

1697
01:07:34,840 --> 01:07:36,910
memory and replaces it with,

1698
01:07:36,910 --> 01:07:38,860
whatever is in the, um,

1699
01:07:39,670 --> 01:07:40,990
a file that you're running,

1700
01:07:40,990 --> 01:07:43,630
so you know if you're worried about

1701
01:07:43,630 --> 01:07:44,320
this kind of stuff,

1702
01:07:44,320 --> 01:07:47,580
the copy implied by the fork.

1703
01:07:48,160 --> 01:07:50,380
Is in some sense mostly wasted because

1704
01:07:50,380 --> 01:07:52,210
all that copied memory is just thrown

1705
01:07:52,210 --> 01:07:54,320
away and replaced by the exec.

1706
01:07:55,270 --> 01:07:57,220
And this affects actually would be significant

1707
01:07:57,220 --> 01:07:57,940
for big programs,

1708
01:07:57,940 --> 01:07:59,830
if you have a multi gigabyte program

1709
01:07:59,830 --> 01:08:01,000
that calls fork.

1710
01:08:01,050 --> 01:08:02,880
Um, and it did indeed copy all

1711
01:08:02,880 --> 01:08:04,380
the memory would actually take a

1712
01:08:04,380 --> 01:08:06,510
fair fraction of a second perhaps

1713
01:08:06,510 --> 01:08:07,620
to do the copy.

1714
01:08:07,740 --> 01:08:09,560
Um, which could be a problem.

1715
01:08:10,080 --> 01:08:13,180
Um, um,

1716
01:08:13,180 --> 01:08:15,850
but later in the course you'll actually

1717
01:08:15,850 --> 01:08:18,370
implement some optimization in particular something called

1718
01:08:18,370 --> 01:08:21,610
copy-on-write fork which will eliminate

1719
01:08:21,610 --> 01:08:25,360
almost all of the apparent inefficiency

1720
01:08:25,360 --> 01:08:27,820
of fork copying only to have exec

1721
01:08:27,820 --> 01:08:29,120
throw away the copy.

1722
01:08:29,180 --> 01:08:30,080
It turns out with a bunch of

1723
01:08:30,080 --> 01:08:32,760
tricks involving a virtual memory system.

1724
01:08:32,920 --> 01:08:35,050
Um, you can build a fork,

1725
01:08:35,050 --> 01:08:37,150
that's lazy about the copy and that

1726
01:08:37,150 --> 01:08:39,520
doesn't do in the common case of

1727
01:08:39,520 --> 01:08:41,320
fork immediately followed by exec.

1728
01:08:41,420 --> 01:08:42,800
Um, or you don't actually have to do

1729
01:08:42,800 --> 01:08:44,630
the copy because the child doesn't actually

1730
01:08:44,630 --> 01:08:46,060
use most of the memory.

1731
01:08:46,900 --> 01:08:49,510
Um, I think you'll find that's a fun

1732
01:08:49,510 --> 01:08:52,510
and interesting lab. Question from chat,

1733
01:08:52,510 --> 01:08:55,360
why does the parent process parent waiting

1734
01:08:55,360 --> 01:08:58,140
completely before the child calls exec.

1735
01:08:59,240 --> 01:09:03,000
Yeah. It's just chance.

1736
01:09:03,820 --> 01:09:09,970
Um, why is it that you know the observation is that,

1737
01:09:09,970 --> 01:09:12,060
um, you know.

1738
01:09:13,130 --> 01:09:15,290
Um, it could be that the parents output

1739
01:09:15,290 --> 01:09:17,540
could be interleaved with the child's output

1740
01:09:17,540 --> 01:09:18,530
in the same area that we saw

1741
01:09:18,530 --> 01:09:21,410
before with similar fork example,

1742
01:09:21,410 --> 01:09:23,780
um, it just happens not to be there's

1743
01:09:23,780 --> 01:09:25,700
no guarantee that this is the output,

1744
01:09:25,700 --> 01:09:27,800
we would see in fact we,

1745
01:09:28,070 --> 01:09:29,690
we shouldn't be surprised if we saw

1746
01:09:29,690 --> 01:09:30,770
the lines of the output in the

1747
01:09:30,770 --> 01:09:33,240
other order or interleaved.

1748
01:09:33,620 --> 01:09:35,960
I suspect what's going on, is

1749
01:09:35,960 --> 01:09:37,940
that it takes a bit of

1750
01:09:37,940 --> 01:09:39,240
time and effort.

1751
01:09:39,770 --> 01:09:41,240
The exec system caused a little bit

1752
01:09:41,240 --> 01:09:43,370
expensive, because it has to load all

1753
01:09:43,370 --> 01:09:45,560
those you have to access the file

1754
01:09:45,560 --> 01:09:47,240
system and access the disk and read

1755
01:09:47,240 --> 01:09:49,010
the contents of a file called echo

1756
01:09:49,010 --> 01:09:51,050
off the disk into memory,

1757
01:09:51,050 --> 01:09:53,330
after allocating some memory and

1758
01:09:53,330 --> 01:09:55,040
that even after freeing some memory

1759
01:09:55,040 --> 01:09:56,870
from the old process so there's

1760
01:09:56,870 --> 01:09:58,220
quite a bit of machinery involved

1761
01:09:58,220 --> 01:09:59,840
in the exec system call,

1762
01:09:59,840 --> 01:10:03,500
um. And apparently that takes long enough that

1763
01:10:03,500 --> 01:10:06,500
the parent can complete producing the output.

1764
01:10:06,580 --> 01:10:08,440
Before the exec is finished and

1765
01:10:08,440 --> 01:10:09,680
started running echo.

1766
01:10:10,400 --> 01:10:11,960
Does that make sense.

1767
01:10:15,360 --> 01:10:17,370
Another question is a convention that the

1768
01:10:17,370 --> 01:10:19,560
child can't wait for the parent.

1769
01:10:21,520 --> 01:10:25,420
There's not a way unix doesn't have

1770
01:10:25,420 --> 01:10:27,160
a way for the child.

1771
01:10:28,220 --> 01:10:30,290
There's no straightforward way for a child to wait

1772
01:10:30,290 --> 01:10:31,140
from a parent.

1773
01:10:31,930 --> 01:10:33,860
The wait system call.

1774
01:10:34,680 --> 01:10:37,080
Because it's the only mechanism available

1775
01:10:37,080 --> 01:10:40,170
well the wait system call waits

1776
01:10:40,170 --> 01:10:41,420
for your children.

1777
01:10:41,880 --> 01:10:42,700
And that's it.

1778
01:10:43,620 --> 01:10:46,350
And so what wait what wait does is,

1779
01:10:46,350 --> 01:10:48,980
um, if you have any children.

1780
01:10:49,080 --> 01:10:52,440
And one of them has already exited what does exit.

1781
01:10:52,740 --> 01:10:54,720
Then we will return but you know

1782
01:10:54,720 --> 01:10:56,070
if you don't have any children say,

1783
01:10:56,070 --> 01:10:57,300
because you are.

1784
01:10:57,360 --> 01:11:00,720
Because in this simple case,

1785
01:11:00,720 --> 01:11:03,950
um. It was just a parent and child

1786
01:11:03,950 --> 01:11:05,660
if the child called wait.

1787
01:11:06,890 --> 01:11:08,780
The child doesn't have any children and

1788
01:11:08,780 --> 01:11:09,200
in that case,

1789
01:11:09,200 --> 01:11:11,090
wait just returns immediately with a -1

1790
01:11:11,090 --> 01:11:13,910
error return saying this process doesn't

1791
01:11:13,910 --> 01:11:14,740
have any children.

1792
01:11:15,440 --> 01:11:17,450
Anyway, the short answer is there's no way

1793
01:11:17,450 --> 01:11:19,280
for a child to wait for its

1794
01:11:19,280 --> 01:11:20,400
parent to exit.

1795
01:11:21,930 --> 01:11:23,310
And another question when we say

1796
01:11:23,310 --> 01:11:25,770
the child copies all the memory

1797
01:11:25,770 --> 01:11:26,820
from the parent process,

1798
01:11:26,820 --> 01:11:28,980
what exactly do we refer to by

1799
01:11:28,980 --> 01:11:30,870
that I thought the child is going

1800
01:11:30,870 --> 01:11:33,260
to define the variables again.

1801
01:11:37,570 --> 01:11:40,250
Um, or when you compile this,

1802
01:11:40,250 --> 01:11:40,880
you know,

1803
01:11:40,880 --> 01:11:47,060
um. After compilation,

1804
01:11:47,060 --> 01:11:49,020
your C program.

1805
01:11:49,220 --> 01:11:50,450
It's just a bunch of instructions in

1806
01:11:50,450 --> 01:11:52,720
memory that live in ram.

1807
01:11:53,430 --> 01:11:57,000
Um, and so those can be copied.

1808
01:11:57,360 --> 01:11:58,920
Because they're just bytes living in ram,

1809
01:11:58,920 --> 01:12:01,170
those can be copied somewhere else,

1810
01:12:01,170 --> 01:12:04,380
um. And with appropriate trick having to do

1811
01:12:04,380 --> 01:12:05,620
with setting up.

1812
01:12:06,500 --> 01:12:08,930
A sort of virtual memory mapping's and

1813
01:12:08,930 --> 01:12:10,970
make map things look the same in

1814
01:12:10,970 --> 01:12:12,110
the child and the parent you can

1815
01:12:12,110 --> 01:12:14,270
just copy the parent's memory image to

1816
01:12:14,270 --> 01:12:15,780
the child and

1817
01:12:16,360 --> 01:12:17,760
executing the child.

1818
01:12:20,660 --> 01:12:22,310
And even though we're looking at C programs,

1819
01:12:22,310 --> 01:12:23,360
you should think of them as just

1820
01:12:23,360 --> 01:12:25,820
a bunch of machine instructions.

1821
01:12:26,920 --> 01:12:29,480
Um, which is bytes in memory that can be copied.

1822
01:12:31,280 --> 01:12:32,660
If a parent has multiple

1823
01:12:32,660 --> 01:12:34,460
children would wait just return

1824
01:12:34,460 --> 01:12:35,270
as soon as the first

1825
01:12:35,270 --> 01:12:36,860
child finishes meaning that there

1826
01:12:36,860 --> 01:12:38,300
could be some more interleaving

1827
01:12:38,300 --> 01:12:39,470
with the parent and unfinished

1828
01:12:39,470 --> 01:12:40,850
children with their need to

1829
01:12:40,850 --> 01:12:42,290
be multiple separate ways to

1830
01:12:42,290 --> 01:12:44,100
ensure all children finished.

1831
01:12:44,340 --> 01:12:45,480
Yes, yeah,

1832
01:12:45,480 --> 01:12:47,250
if you call fork more than one

1833
01:12:47,250 --> 01:12:50,820
if a given process calls for twice.

1834
01:12:51,360 --> 01:12:54,450
Um, then it wants to wait for both

1835
01:12:54,450 --> 01:12:56,850
children and has to call wait twice

1836
01:12:56,850 --> 01:12:58,140
each call to wait.

1837
01:12:58,280 --> 01:13:00,500
Will return as soon as one of

1838
01:13:00,500 --> 01:13:02,450
the children exits you don't when wait

1839
01:13:02,450 --> 01:13:05,210
returns you don't necessarily know which child

1840
01:13:05,210 --> 01:13:08,060
is exited the weight returns the child's

1841
01:13:08,060 --> 01:13:09,920
process id as its return value so

1842
01:13:09,920 --> 01:13:11,060
you can tell.

1843
01:13:11,420 --> 01:13:13,670
After we returns you know which one

1844
01:13:13,670 --> 01:13:14,740
it was at exit.

1845
01:13:19,030 --> 01:13:23,980
Um, as a final example,

1846
01:13:23,980 --> 01:13:27,520
um. I'd like to show,

1847
01:13:28,080 --> 01:13:32,520
um, how all these facilities combine,

1848
01:13:32,520 --> 01:13:37,460
um. To implement IO direction,

1849
01:13:37,460 --> 01:13:38,960
so if you remember,

1850
01:13:38,960 --> 01:13:40,670
um, the shell provides us with this

1851
01:13:40,670 --> 01:13:43,010
handy syntax I can say

1852
01:13:43,010 --> 01:13:44,500
'echo hello >  out'.

1853
01:13:44,830 --> 01:13:47,080
Um, that runs the echo command that

1854
01:13:47,080 --> 01:13:48,800
argument sending it.

1855
01:13:48,800 --> 01:13:51,200
First, um, that sends its output to the

1856
01:13:51,200 --> 01:13:52,980
file out and looked out.

1857
01:13:53,120 --> 01:13:54,480
Or yet.

1858
01:13:55,340 --> 01:13:57,260
Um, on the cat and with its

1859
01:13:57,260 --> 01:14:01,250
input connected from the out file,

1860
01:14:01,250 --> 01:14:02,960
we can see that saved output from

1861
01:14:02,960 --> 01:14:04,080
the echo command.

1862
01:14:04,980 --> 01:14:08,060
Um, the way the shell sets this up.

1863
01:14:08,840 --> 01:14:10,070
Um is,

1864
01:14:10,070 --> 01:14:11,860
um, as follows.

1865
01:14:13,390 --> 01:14:19,160
Um. It a shell first forks like on

1866
01:14:19,160 --> 01:14:22,160
line 13 and then in the child,

1867
01:14:22,160 --> 01:14:24,260
the shell changes the way the file

1868
01:14:24,260 --> 01:14:25,940
descriptors are set up so that the

1869
01:14:25,940 --> 01:14:27,950
child's file descriptor

1870
01:14:27,950 --> 01:14:28,980
1 which

1871
01:14:29,200 --> 01:14:32,350
by convention most programs used for the output,

1872
01:14:32,350 --> 01:14:36,260
um. This shell a changes the child's

1873
01:14:36,260 --> 01:14:38,300
file descriptor to 1 to refer

1874
01:14:38,300 --> 01:14:40,430
to this output file,

1875
01:14:40,430 --> 01:14:42,590
and then run whatever commands you wanted

1876
01:14:42,590 --> 01:14:45,470
and that leaves the parent shells file

1877
01:14:45,470 --> 01:14:48,950
descriptor 1 unchanged so this idiom of

1878
01:14:48,950 --> 01:14:51,590
forking and in a child, changing

1879
01:14:51,590 --> 01:14:53,260
around the file descriptors.

1880
01:14:53,360 --> 01:14:57,360
Um, is the usual way unix actually redirect

1881
01:14:57,460 --> 01:14:59,320
input an output for a command

1882
01:14:59,320 --> 01:15:01,090
that you run but not affect

1883
01:15:01,090 --> 01:15:03,370
the input and output for a

1884
01:15:03,370 --> 01:15:04,900
calling program because we don't want

1885
01:15:04,900 --> 01:15:06,720
to redirect the shell's output.

1886
01:15:07,150 --> 01:15:10,120
Um, we only want to redirect the

1887
01:15:10,120 --> 01:15:11,760
child programs output.

1888
01:15:12,670 --> 01:15:15,730
Anyway, the way this works we call fork unusual way,

1889
01:15:15,730 --> 01:15:18,720
a line 15 only executes in the child.

1890
01:15:18,860 --> 01:15:20,480
The reason for the close 1 on

1891
01:15:20,480 --> 01:15:23,200
line 15 is that in this program.

1892
01:15:23,590 --> 01:15:25,810
We're redirecting a just the output of

1893
01:15:25,810 --> 01:15:26,530
the echo command,

1894
01:15:26,530 --> 01:15:28,360
so when I run this redirect.

1895
01:15:28,640 --> 01:15:31,520
A program produces no output itself,

1896
01:15:31,520 --> 01:15:33,410
it ran echo with its output directly

1897
01:15:33,410 --> 01:15:35,380
to "output.txt".

1898
01:15:35,540 --> 01:15:38,900
So when I look at "output.txt",

1899
01:15:38,900 --> 01:15:41,750
um. I see this expected output,

1900
01:15:41,750 --> 01:15:44,540
the reason for the close 1 on line 15.

1901
01:15:44,900 --> 01:15:47,960
Is that we want 1 as

1902
01:15:47,960 --> 01:15:50,180
a sort of conventional output file script

1903
01:15:50,180 --> 01:15:52,010
to refer to something else,

1904
01:15:52,010 --> 01:15:54,650
it happens so we don't have a child,

1905
01:15:54,650 --> 01:15:56,360
we don't want to use the father descriptor

1906
01:15:56,360 --> 01:15:58,070
1 that the shell had that's connected

1907
01:15:58,070 --> 01:15:59,300
to the console.

1908
01:15:59,660 --> 01:16:01,160
Um the call to open on line

1909
01:16:01,160 --> 01:16:04,400
16 is guaranteed to return 1 because,

1910
01:16:04,400 --> 01:16:06,380
um the semantics of open are that

1911
01:16:06,380 --> 01:16:08,140
open returns the lowest

1912
01:16:08,410 --> 01:16:09,490
file descriptor number,

1913
01:16:09,490 --> 01:16:12,430
that's not currently in use in the

1914
01:16:12,430 --> 01:16:15,260
calling process since we just closed 1.

1915
01:16:15,420 --> 01:16:18,990
And file descriptor 0 is still connected

1916
01:16:18,990 --> 01:16:19,590
to the console,

1917
01:16:19,590 --> 01:16:20,400
I mean.

1918
01:16:20,460 --> 01:16:23,440
I'm open is guaranteed to return 1.

1919
01:16:24,290 --> 01:16:27,560
So after the line 16 file descriptor

1920
01:16:27,560 --> 01:16:29,880
1 is connected to this file.

1921
01:16:30,220 --> 01:16:32,890
When we exec echo, echo just writes its output,

1922
01:16:32,890 --> 01:16:35,020
the file descriptor 1 and now go

1923
01:16:35,020 --> 01:16:36,340
to this file and the cool thing

1924
01:16:36,340 --> 01:16:37,720
about this is echo had no idea

1925
01:16:37,720 --> 01:16:39,580
what's going on, echo doesn't need to

1926
01:16:39,580 --> 01:16:41,650
know about IO direction at all,

1927
01:16:41,650 --> 01:16:43,000
it just writes its output,

1928
01:16:43,000 --> 01:16:44,400
the file descriptor 1.

1929
01:16:45,160 --> 01:16:47,590
I'm only the shell

1930
01:16:47,590 --> 01:16:49,140
knows about

1931
01:16:49,330 --> 01:16:50,600
IO redirection.

1932
01:16:52,380 --> 01:16:55,540
This example also illustrates the sort of

1933
01:16:56,090 --> 01:16:59,330
kind of neatness of the separation between

1934
01:16:59,330 --> 01:17:00,950
fork and exec, the fact that fork

1935
01:17:00,950 --> 01:17:05,100
and exec our separate system calls separate.

1936
01:17:05,560 --> 01:17:07,720
Um functions.

1937
01:17:08,130 --> 01:17:09,840
Means that there's a period of time

1938
01:17:09,840 --> 01:17:11,720
in the child between the fork.

1939
01:17:11,980 --> 01:17:13,630
Between them for returns in the child

1940
01:17:13,630 --> 01:17:16,060
and exactly which were still running the

1941
01:17:16,060 --> 01:17:17,860
calling processes instructions,

1942
01:17:17,860 --> 01:17:20,080
so the calling process.

1943
01:17:20,160 --> 01:17:22,320
Even though it's running in those instructions

1944
01:17:22,320 --> 01:17:23,610
are running in the child,

1945
01:17:23,610 --> 01:17:25,890
it's still the calling processes instructions that

1946
01:17:25,890 --> 01:17:28,050
are executed and so the calling process

1947
01:17:28,050 --> 01:17:31,620
is still able to change things and

1948
01:17:31,620 --> 01:17:33,940
still in control up until line 19.

1949
01:17:34,380 --> 01:17:35,790
And this sort of interval between fork

1950
01:17:35,790 --> 01:17:38,010
and exec gives the show a chance

1951
01:17:38,010 --> 01:17:40,380
to change what the file descriptors,

1952
01:17:40,380 --> 01:17:41,820
refer to for example.

1953
01:17:43,180 --> 01:17:46,220
Any questions about this redirect example.

1954
01:17:46,560 --> 01:18:00,080
Yeah. All right, I'm about out of time.

1955
01:18:00,410 --> 01:18:02,690
Just wrap up, we look at unix is,

1956
01:18:02,690 --> 01:18:05,690
um. A bunch of the interfaces to

1957
01:18:05,690 --> 01:18:09,620
unix's IO and process abstractions, um,

1958
01:18:09,620 --> 01:18:10,820
thing to take away from this is

1959
01:18:10,820 --> 01:18:12,920
if the interfaces are relatively simple and

1960
01:18:12,920 --> 01:18:15,590
just pass integer like file descriptors

1961
01:18:15,590 --> 01:18:18,050
and process ids back and forth across

1962
01:18:18,050 --> 01:18:20,030
its arguments system calls,

1963
01:18:20,030 --> 01:18:21,900
um. But,

1964
01:18:22,360 --> 01:18:24,790
Well, the functionality inside the interface is

1965
01:18:24,790 --> 01:18:27,020
relatively sophisticated like

1966
01:18:27,180 --> 01:18:29,700
creating new processes and copying the current

1967
01:18:29,700 --> 01:18:32,820
process, and furthermore I show some examples

1968
01:18:32,820 --> 01:18:34,770
of ways in which the abstractions

1969
01:18:34,770 --> 01:18:38,550
individually simple combine in useful ways,

1970
01:18:38,550 --> 01:18:40,800
for example to produce

1971
01:18:40,890 --> 01:18:42,120
IO redirection.

1972
01:18:44,030 --> 01:18:45,260
There's a lab due at the end

1973
01:18:45,260 --> 01:18:48,200
of next week and that lab involves

1974
01:18:48,200 --> 01:18:50,600
writing more simple utilities like the ones

1975
01:18:50,600 --> 01:18:52,160
I showed that use the system calls

1976
01:18:52,160 --> 01:18:54,000
that we discuss.

1977
01:18:54,140 --> 01:18:56,570
So, have fun with that lab and I'll

1978
01:18:56,570 --> 01:18:57,880
see you in class next week.

1979
01:18:58,640 --> 01:19:02,580
Um, and that's it.

1980
01:19:08,480 --> 01:19:08,940
Thank you.

1981
01:19:15,170 --> 01:19:16,670
Since I'm the one recording,

1982
01:19:16,670 --> 01:19:18,980
how do I end this, first

1983
01:19:18,980 --> 01:19:20,900
time recording in lecture. They

1984
01:19:20,900 --> 01:19:22,320
will be exit.

1985
01:19:22,520 --> 01:19:24,470
Okay, nothing special I can just exit it

1986
01:19:24,470 --> 01:19:25,580
will be saved somewhere.

1987
01:19:26,220 --> 01:19:28,020
Yes, awesome.

1988
01:19:32,010 --> 01:19:34,520
I assume we'll create some directory and

1989
01:19:35,120 --> 01:19:36,840
sticking a file in that directory.

1990
01:19:38,600 --> 01:19:41,140
There's also office hours right after this right.

1991
01:19:41,930 --> 01:19:46,380
Yes, perfect cool.

1992
01:19:48,050 --> 01:19:51,220
Happy. All right.

1993
01:19:51,580 --> 01:19:52,450
All right,

1994
01:19:52,450 --> 01:19:54,640
thank you and I'll see you next week,

1995
01:19:54,640 --> 01:19:55,320
thanks.

