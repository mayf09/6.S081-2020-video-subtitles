1
00:00:01,920 --> 00:00:04,319
all right um

2
00:00:04,319 --> 00:00:08,720
welcome to six s081 operating systems

3
00:00:08,720 --> 00:00:11,200
um i'm robert i'll be co-lecturing with

4
00:00:11,200 --> 00:00:12,799
franz

5
00:00:12,799 --> 00:00:17,199
and david and nicholas for the tas

6
00:00:17,199 --> 00:00:19,119
please during these zoom lectures ask

7
00:00:19,119 --> 00:00:20,640
questions you can either

8
00:00:20,640 --> 00:00:24,080
interrupt me by audio or enter something

9
00:00:24,080 --> 00:00:26,320
into the chat window and

10
00:00:26,320 --> 00:00:27,680
one of the staff will see an ask

11
00:00:27,680 --> 00:00:30,720
question for you and by the way we'll be

12
00:00:30,720 --> 00:00:32,320
recording these lectures

13
00:00:32,320 --> 00:00:33,760
and we'll post the recordings later so

14
00:00:33,760 --> 00:00:36,079
you can review them or for

15
00:00:36,079 --> 00:00:38,160
people who can't make this time so they

16
00:00:38,160 --> 00:00:40,559
can never like see the lectures

17
00:00:40,559 --> 00:00:43,760
all right i want to start by um

18
00:00:43,760 --> 00:00:44,960
laying out some of the goals of the

19
00:00:44,960 --> 00:00:46,960
course so

20
00:00:46,960 --> 00:00:50,800
number one is to um understand

21
00:00:50,800 --> 00:00:54,079
uh the design and implementation of

22
00:00:54,079 --> 00:00:55,440
operating systems

23
00:00:55,440 --> 00:00:58,879
and you know the uh

24
00:00:58,879 --> 00:01:01,199
design is sort of high-level structure

25
00:01:01,199 --> 00:01:03,359
and implementation is really about what

26
00:01:03,359 --> 00:01:04,479
the code looks like

27
00:01:04,479 --> 00:01:06,000
and we'll be spending a lot of time with

28
00:01:06,000 --> 00:01:08,159
both um

29
00:01:08,159 --> 00:01:11,439
and in the interest of

30
00:01:11,439 --> 00:01:12,720
getting a deep understanding of what's

31
00:01:12,720 --> 00:01:15,920
going on you'll get hands-on experience

32
00:01:15,920 --> 00:01:21,670
with a small

33
00:01:21,680 --> 00:01:23,759
with a small operating system the xv6

34
00:01:23,759 --> 00:01:26,870
operating system

35
00:01:26,880 --> 00:01:28,880
and in addition to actually looking at

36
00:01:28,880 --> 00:01:30,320
an existing operating system

37
00:01:30,320 --> 00:01:33,840
you'll be in the labs get a bunch of

38
00:01:33,840 --> 00:01:34,560
experience

39
00:01:34,560 --> 00:01:36,799
extending the operating system modifying

40
00:01:36,799 --> 00:01:38,240
improving its behavior

41
00:01:38,240 --> 00:01:41,280
and writing system software that um it

42
00:01:41,280 --> 00:01:43,119
uses the operating system

43
00:01:43,119 --> 00:01:46,560
interfaces if it works an application

44
00:01:46,560 --> 00:01:48,560
so um so this is what you're going to be

45
00:01:48,560 --> 00:01:52,870
doing in the course

46
00:01:52,880 --> 00:01:55,360
we're also interested in what the

47
00:01:55,360 --> 00:01:56,960
purpose of the operating system itself

48
00:01:56,960 --> 00:02:00,870
is as well as of the course

49
00:02:00,880 --> 00:02:03,759
so for that i have a sort of list of a

50
00:02:03,759 --> 00:02:05,520
couple of things which

51
00:02:05,520 --> 00:02:07,920
um you know there's lots of operating

52
00:02:07,920 --> 00:02:08,560
system

53
00:02:08,560 --> 00:02:10,640
different operating systems out there

54
00:02:10,640 --> 00:02:12,720
they typically have a common set of

55
00:02:12,720 --> 00:02:16,150
purposes

56
00:02:16,160 --> 00:02:21,520
one of them is to abstract the hardware

57
00:02:21,520 --> 00:02:23,680
um that is you know what you're given

58
00:02:23,680 --> 00:02:25,360
typically as a kind of starting point is

59
00:02:25,360 --> 00:02:27,040
you buy a computer a computer as a cpu

60
00:02:27,040 --> 00:02:27,920
in memory

61
00:02:27,920 --> 00:02:30,959
but that's a very low level uh set of

62
00:02:30,959 --> 00:02:31,760
resources

63
00:02:31,760 --> 00:02:33,760
it's fantastic to have much higher level

64
00:02:33,760 --> 00:02:36,000
um interfaces and abstractions that

65
00:02:36,000 --> 00:02:38,080
applications can use

66
00:02:38,080 --> 00:02:41,040
such as processes or file systems both

67
00:02:41,040 --> 00:02:41,920
for convenience

68
00:02:41,920 --> 00:02:44,959
and for portability another very

69
00:02:44,959 --> 00:02:46,239
important

70
00:02:46,239 --> 00:02:48,160
task of an operating system is to

71
00:02:48,160 --> 00:02:50,160
multiplex the hardware

72
00:02:50,160 --> 00:02:53,040
among many applications you might be

73
00:02:53,040 --> 00:02:53,599
running

74
00:02:53,599 --> 00:02:57,200
a text editor and a compiler or

75
00:02:57,200 --> 00:03:00,560
maybe multiple different database

76
00:03:00,560 --> 00:03:01,920
servers or something on your operating

77
00:03:01,920 --> 00:03:02,400
system

78
00:03:02,400 --> 00:03:03,920
it's fantastic to be able to have the

79
00:03:03,920 --> 00:03:05,760
operating system run both of them at the

80
00:03:05,760 --> 00:03:07,760
same time or all the things are going on

81
00:03:07,760 --> 00:03:08,720
at the same time

82
00:03:08,720 --> 00:03:11,680
without having them interfere that's

83
00:03:11,680 --> 00:03:13,920
often called multiplexing

84
00:03:13,920 --> 00:03:16,319
um because there may be a lot of things

85
00:03:16,319 --> 00:03:17,680
happening on the operating system at the

86
00:03:17,680 --> 00:03:19,280
same time it's it's critical that they

87
00:03:19,280 --> 00:03:20,560
not interfere

88
00:03:20,560 --> 00:03:23,519
unintentionally even if they have bugs

89
00:03:23,519 --> 00:03:24,480
and that's

90
00:03:24,480 --> 00:03:30,229
a task is called isolation the idea that

91
00:03:30,239 --> 00:03:31,920
different activities should not be

92
00:03:31,920 --> 00:03:33,519
allowed to interfere on the other hand

93
00:03:33,519 --> 00:03:35,040
there are times when

94
00:03:35,040 --> 00:03:36,400
different activities would like to

95
00:03:36,400 --> 00:03:38,159
interfere we'd like to interact or

96
00:03:38,159 --> 00:03:39,200
cooperate so

97
00:03:39,200 --> 00:03:41,200
for example if i create a file with a

98
00:03:41,200 --> 00:03:42,239
text editor

99
00:03:42,239 --> 00:03:43,840
and i'd like my compiler to read the

100
00:03:43,840 --> 00:03:46,560
file we definitely want to allow that

101
00:03:46,560 --> 00:03:48,080
kind of sharing

102
00:03:48,080 --> 00:03:51,360
so we want to allow sharing when it's

103
00:03:51,360 --> 00:03:55,680
sort of what the user has in mind um

104
00:03:55,680 --> 00:03:58,239
but in many circumstances the user

105
00:03:58,239 --> 00:03:59,680
doesn't want sharing maybe you're logged

106
00:03:59,680 --> 00:04:00,000
into

107
00:04:00,000 --> 00:04:02,480
a time sharing machine like athena and

108
00:04:02,480 --> 00:04:03,840
you don't want other people to read your

109
00:04:03,840 --> 00:04:04,879
files

110
00:04:04,879 --> 00:04:06,400
so we also need as well as sharing we

111
00:04:06,400 --> 00:04:09,680
want to not share when we don't want to

112
00:04:09,680 --> 00:04:11,680
which we could call security or a

113
00:04:11,680 --> 00:04:13,040
permission system

114
00:04:13,040 --> 00:04:16,629
or an access control system

115
00:04:16,639 --> 00:04:18,000
another thing that people value in

116
00:04:18,000 --> 00:04:19,919
operating systems is if you spend a lot

117
00:04:19,919 --> 00:04:21,759
of money on hardware on a computer

118
00:04:21,759 --> 00:04:23,360
you'd like your application to be able

119
00:04:23,360 --> 00:04:25,680
to get the sort of full performance

120
00:04:25,680 --> 00:04:27,840
that the hardware ought to be able to

121
00:04:27,840 --> 00:04:29,600
provide

122
00:04:29,600 --> 00:04:31,440
and you know a lot of that is just

123
00:04:31,440 --> 00:04:34,080
application programming

124
00:04:34,080 --> 00:04:36,479
but inevitably unfortunately some of it

125
00:04:36,479 --> 00:04:38,479
is the operating system has to make sure

126
00:04:38,479 --> 00:04:38,960
that

127
00:04:38,960 --> 00:04:42,720
whatever services it provides

128
00:04:42,720 --> 00:04:44,639
don't get in the way of applications

129
00:04:44,639 --> 00:04:46,160
getting high performance

130
00:04:46,160 --> 00:04:47,759
so you want to at least not get in the

131
00:04:47,759 --> 00:04:49,840
way and maybe even help

132
00:04:49,840 --> 00:04:56,720
applications achieve good performance

133
00:04:56,720 --> 00:05:00,880
finally with most operating systems

134
00:05:00,880 --> 00:05:02,160
have to support a wide range of

135
00:05:02,160 --> 00:05:03,520
different applications maybe it's a

136
00:05:03,520 --> 00:05:04,240
laptop

137
00:05:04,240 --> 00:05:06,720
running a text editor maybe it's running

138
00:05:06,720 --> 00:05:07,759
games

139
00:05:07,759 --> 00:05:09,360
maybe your operating system needs to

140
00:05:09,360 --> 00:05:11,600
support database servers or

141
00:05:11,600 --> 00:05:14,160
cloud computation and usually because

142
00:05:14,160 --> 00:05:15,680
operating systems are

143
00:05:15,680 --> 00:05:18,800
quite expensive to design and build

144
00:05:18,800 --> 00:05:20,240
people use the same operating systems

145
00:05:20,240 --> 00:05:22,320
for many different tasks like linux for

146
00:05:22,320 --> 00:05:22,960
example which

147
00:05:22,960 --> 00:05:25,199
i'm sure many of you are running is used

148
00:05:25,199 --> 00:05:27,120
in all of the situations i mentioned so

149
00:05:27,120 --> 00:05:28,479
the same operating system really has to

150
00:05:28,479 --> 00:05:29,680
be able to support

151
00:05:29,680 --> 00:05:36,790
a range of often quite different uses

152
00:05:36,800 --> 00:05:39,759
so we're hoping to be able to support um

153
00:05:39,759 --> 00:05:41,120
sort of all these different goals

154
00:05:41,120 --> 00:05:44,639
uh simultaneously um and we'll hear more

155
00:05:44,639 --> 00:05:45,520
about all of them

156
00:05:45,520 --> 00:05:48,960
during the course all right uh operating

157
00:05:48,960 --> 00:05:49,680
systems

158
00:05:49,680 --> 00:05:53,120
uh sort of people worked out a set of um

159
00:05:53,120 --> 00:05:56,080
design ideas over the decades that have

160
00:05:56,080 --> 00:05:57,199
worked pretty well

161
00:05:57,199 --> 00:06:00,080
sort of ways of organizing things and

162
00:06:00,080 --> 00:06:04,830
i'm going to lay out for you the sort of

163
00:06:04,840 --> 00:06:06,160
classic

164
00:06:06,160 --> 00:06:08,560
organization it's a sort of standard

165
00:06:08,560 --> 00:06:09,280
deal for

166
00:06:09,280 --> 00:06:13,360
uh for this course and

167
00:06:13,360 --> 00:06:16,240
um is actually quite common around for

168
00:06:16,240 --> 00:06:17,759
many operating systems so this is sort

169
00:06:17,759 --> 00:06:18,160
of

170
00:06:18,160 --> 00:06:21,840
you know os internal organization or

171
00:06:21,840 --> 00:06:25,199
um the way i think about it is a

172
00:06:25,199 --> 00:06:28,240
in terms of a draw a box for the

173
00:06:28,240 --> 00:06:29,120
computer

174
00:06:29,120 --> 00:06:32,160
um the computer sort of

175
00:06:32,160 --> 00:06:33,759
comes with a bunch of hardware resources

176
00:06:33,759 --> 00:06:34,960
which i'll put at the bottom maybe

177
00:06:34,960 --> 00:06:35,919
there's cpu

178
00:06:35,919 --> 00:06:39,280
and ram and a disk for storage

179
00:06:39,280 --> 00:06:42,240
and maybe a network interface so this

180
00:06:42,240 --> 00:06:43,520
sort of hardware that's

181
00:06:43,520 --> 00:06:47,360
the lowest layer um so if at the top

182
00:06:47,360 --> 00:06:49,599
we want to run various applications

183
00:06:49,599 --> 00:06:51,680
maybe a text editor i happen to use

184
00:06:51,680 --> 00:06:53,919
vi as a text editor if you're going to

185
00:06:53,919 --> 00:06:55,360
run a c compiler

186
00:06:55,360 --> 00:06:58,479
say cc you know if you run lots of other

187
00:06:58,479 --> 00:06:59,840
things we're going to talk a lot today

188
00:06:59,840 --> 00:07:02,880
about the shell which is the

189
00:07:02,880 --> 00:07:04,880
command line interface so we have all

190
00:07:04,880 --> 00:07:05,840
these different programs that are

191
00:07:05,840 --> 00:07:07,759
running

192
00:07:07,759 --> 00:07:10,560
and this is the sort of world in which

193
00:07:10,560 --> 00:07:12,400
applications run is usually called user

194
00:07:12,400 --> 00:07:14,560
space

195
00:07:14,560 --> 00:07:16,880
and as distinct from that there's a

196
00:07:16,880 --> 00:07:19,440
single program

197
00:07:19,440 --> 00:07:21,280
um a special program that's always

198
00:07:21,280 --> 00:07:23,759
running called the kernel and the kernel

199
00:07:23,759 --> 00:07:24,639
is sort of the

200
00:07:24,639 --> 00:07:26,479
guardian of the resources of the

201
00:07:26,479 --> 00:07:28,000
computer it's what first

202
00:07:28,000 --> 00:07:30,639
boots up you turn on the computer

203
00:07:30,639 --> 00:07:33,599
there's just one of it it maintains data

204
00:07:33,599 --> 00:07:35,599
to help it manage each of these

205
00:07:35,599 --> 00:07:37,360
processes and the kernel also maintains

206
00:07:37,360 --> 00:07:40,080
lots of data structures to help it

207
00:07:40,080 --> 00:07:43,360
interface and all the different kinds of

208
00:07:43,360 --> 00:07:45,039
hardware that

209
00:07:45,039 --> 00:07:49,360
uh these user programs need to use

210
00:07:49,360 --> 00:07:51,360
the kernel also has built in a bunch of

211
00:07:51,360 --> 00:07:53,520
services um

212
00:07:53,520 --> 00:07:56,000
and so for example there's typically a

213
00:07:56,000 --> 00:07:59,199
file system implementation inside the

214
00:07:59,199 --> 00:08:00,080
kernel that

215
00:08:00,080 --> 00:08:02,720
implements things like file names and

216
00:08:02,720 --> 00:08:03,680
file contents

217
00:08:03,680 --> 00:08:06,479
and directories and understands how to

218
00:08:06,479 --> 00:08:06,960
store

219
00:08:06,960 --> 00:08:08,879
the files in the disk so your programs

220
00:08:08,879 --> 00:08:10,319
are going to talk to the files inside

221
00:08:10,319 --> 00:08:12,000
the kernel and the file system

222
00:08:12,000 --> 00:08:13,440
implementation is going to

223
00:08:13,440 --> 00:08:17,759
talk to the disk and in this course

224
00:08:17,759 --> 00:08:19,840
what we mostly focus on is all the

225
00:08:19,840 --> 00:08:21,360
things that have to happen inside the

226
00:08:21,360 --> 00:08:22,479
kernel

227
00:08:22,479 --> 00:08:24,560
and on the interfaces between user

228
00:08:24,560 --> 00:08:27,440
programs and the kernel

229
00:08:27,440 --> 00:08:29,199
as well as the sort of structure of the

230
00:08:29,199 --> 00:08:30,560
software

231
00:08:30,560 --> 00:08:34,240
inside the kernel so we care a lot about

232
00:08:34,240 --> 00:08:34,959
these

233
00:08:34,959 --> 00:08:37,240
services inside the kernel

234
00:08:37,240 --> 00:08:38,479
[Music]

235
00:08:38,479 --> 00:08:39,839
one of them is the file system i

236
00:08:39,839 --> 00:08:43,039
mentioned there's also uh

237
00:08:43,039 --> 00:08:44,959
management of processes each of these

238
00:08:44,959 --> 00:08:46,240
running programs

239
00:08:46,240 --> 00:08:47,839
is called a process and it has things

240
00:08:47,839 --> 00:08:50,080
like its own memory for example

241
00:08:50,080 --> 00:08:53,600
as well as a share of the cpu time

242
00:08:53,600 --> 00:08:56,800
so kernel manages

243
00:08:56,800 --> 00:09:00,160
processes as a kernel service

244
00:09:00,160 --> 00:09:02,000
[Music]

245
00:09:02,000 --> 00:09:05,040
the kernel manages the allocation of

246
00:09:05,040 --> 00:09:07,040
memory the different processes need

247
00:09:07,040 --> 00:09:11,110
different amounts of memory the kernel

248
00:09:11,120 --> 00:09:13,519
multiplexes and divides up the memory

249
00:09:13,519 --> 00:09:16,320
allocates the memory

250
00:09:16,320 --> 00:09:22,240
among all the different processes

251
00:09:22,240 --> 00:09:25,680
um the kernel as i mentioned

252
00:09:25,680 --> 00:09:27,040
influenced the file system file system

253
00:09:27,040 --> 00:09:28,800
really comes in two or three

254
00:09:28,800 --> 00:09:31,519
logical or a bunch of logical parts but

255
00:09:31,519 --> 00:09:33,360
for now we can think of it in terms of

256
00:09:33,360 --> 00:09:35,200
managing file content that's what's

257
00:09:35,200 --> 00:09:38,959
inside files figuring out where on disk

258
00:09:38,959 --> 00:09:40,880
each file's content ought to live the

259
00:09:40,880 --> 00:09:42,720
file system also somewhat separately

260
00:09:42,720 --> 00:09:45,040
manages a name space each file has a

261
00:09:45,040 --> 00:09:45,839
name

262
00:09:45,839 --> 00:09:48,880
and there's a hierarchy of directories

263
00:09:48,880 --> 00:09:50,480
every directory has a bunch of files in

264
00:09:50,480 --> 00:09:52,240
it all that's managed

265
00:09:52,240 --> 00:09:55,040
by the file system there's typically

266
00:09:55,040 --> 00:09:57,279
some sort of security arrangement

267
00:09:57,279 --> 00:10:01,590
maybe we'll call it access control

268
00:10:01,600 --> 00:10:03,519
by which the colonel decides that you

269
00:10:03,519 --> 00:10:06,240
know when a given process wants to read

270
00:10:06,240 --> 00:10:07,839
use some resource maybe read something

271
00:10:07,839 --> 00:10:09,440
from the disk or use some memory

272
00:10:09,440 --> 00:10:11,120
the access control machinery inside the

273
00:10:11,120 --> 00:10:12,800
kernel is what gets to decide yes is

274
00:10:12,800 --> 00:10:14,160
that allowed is that not allowed

275
00:10:14,160 --> 00:10:15,600
and that can get pretty complicated if

276
00:10:15,600 --> 00:10:17,360
we're talking about time sharing systems

277
00:10:17,360 --> 00:10:19,360
like athena systems where there's

278
00:10:19,360 --> 00:10:21,200
you know each of these processes may be

279
00:10:21,200 --> 00:10:22,880
run by a different user and

280
00:10:22,880 --> 00:10:24,880
have different access control rules

281
00:10:24,880 --> 00:10:26,240
applied to what it's allowed

282
00:10:26,240 --> 00:10:29,920
to get at and in a real

283
00:10:29,920 --> 00:10:31,680
full-blown operating system there's

284
00:10:31,680 --> 00:10:33,920
turns out to be many many other services

285
00:10:33,920 --> 00:10:35,760
you know there's typically some way for

286
00:10:35,760 --> 00:10:37,279
different processes to talk to each

287
00:10:37,279 --> 00:10:37,600
other

288
00:10:37,600 --> 00:10:40,240
called inter-process communication

289
00:10:40,240 --> 00:10:41,760
there's typically a whole bunch of

290
00:10:41,760 --> 00:10:43,519
software associated with the network

291
00:10:43,519 --> 00:10:46,720
things like the tcp ip protocols for

292
00:10:46,720 --> 00:10:49,910
talking in the network

293
00:10:49,920 --> 00:10:51,600
there's typically support for sound

294
00:10:51,600 --> 00:10:53,920
cards there may be drivers for hundreds

295
00:10:53,920 --> 00:10:55,360
of different disks and hundreds of

296
00:10:55,360 --> 00:10:56,480
different network cards

297
00:10:56,480 --> 00:10:58,079
so in a full blown operating system

298
00:10:58,079 --> 00:11:00,240
there's a huge amount of stuff here and

299
00:11:00,240 --> 00:11:02,000
this may run to millions of lines of

300
00:11:02,000 --> 00:11:02,800
code

301
00:11:02,800 --> 00:11:06,230
inside the kernel

302
00:11:06,240 --> 00:11:07,440
so that's sort of a quick overview of

303
00:11:07,440 --> 00:11:09,600
what's inside the kernel

304
00:11:09,600 --> 00:11:11,279
we're also interested in how

305
00:11:11,279 --> 00:11:13,360
applications interact with the kernel

306
00:11:13,360 --> 00:11:19,030
and what that interface looks like

307
00:11:19,040 --> 00:11:22,790
the

308
00:11:22,800 --> 00:11:26,640
usual so this is the api

309
00:11:26,640 --> 00:11:30,550
for the kernel

310
00:11:30,560 --> 00:11:33,120
how applications get at the kernel

311
00:11:33,120 --> 00:11:34,320
typically that's done with something

312
00:11:34,320 --> 00:11:36,079
called system calls and these are things

313
00:11:36,079 --> 00:11:36,560
that

314
00:11:36,560 --> 00:11:39,839
look like function calls that programs

315
00:11:39,839 --> 00:11:41,200
can make

316
00:11:41,200 --> 00:11:44,000
but actually jump into the kernel and

317
00:11:44,000 --> 00:11:45,120
execute a

318
00:11:45,120 --> 00:11:46,640
system called implementation in the

319
00:11:46,640 --> 00:11:48,320
kernel i'll talk a

320
00:11:48,320 --> 00:11:49,760
bunch about that in the latter part of

321
00:11:49,760 --> 00:11:52,079
this lecture for now just to give you a

322
00:11:52,079 --> 00:11:53,200
flavor here

323
00:11:53,200 --> 00:11:54,880
what a couple of different system calls

324
00:11:54,880 --> 00:11:56,639
might look like in the source code

325
00:11:56,639 --> 00:12:00,230
of an application

326
00:12:00,240 --> 00:12:02,240
one might be that if you want if an

327
00:12:02,240 --> 00:12:04,320
application wants to open a file

328
00:12:04,320 --> 00:12:07,360
it make it calls the open system call

329
00:12:07,360 --> 00:12:09,360
and tells the open system called the

330
00:12:09,360 --> 00:12:10,639
name of the file

331
00:12:10,639 --> 00:12:12,720
so maybe it wants to open a file for

332
00:12:12,720 --> 00:12:13,839
writing called

333
00:12:13,839 --> 00:12:15,600
out and it would be an extra argument

334
00:12:15,600 --> 00:12:17,680
here saying one in this case saying i

335
00:12:17,680 --> 00:12:18,959
want to write that file

336
00:12:18,959 --> 00:12:20,639
and so this thing that looks like a

337
00:12:20,639 --> 00:12:22,560
function call

338
00:12:22,560 --> 00:12:24,160
if opens the system calls actually

339
00:12:24,160 --> 00:12:26,399
special code that jumps into the kernel

340
00:12:26,399 --> 00:12:27,680
and the kernel can retrieve these

341
00:12:27,680 --> 00:12:28,639
arguments

342
00:12:28,639 --> 00:12:30,320
execute some kernel code that implements

343
00:12:30,320 --> 00:12:32,320
open maybe talks to the disk

344
00:12:32,320 --> 00:12:34,160
and then returns a value and that's this

345
00:12:34,160 --> 00:12:36,079
file descriptor

346
00:12:36,079 --> 00:12:39,040
as fd stands for file descriptor which

347
00:12:39,040 --> 00:12:39,440
is

348
00:12:39,440 --> 00:12:41,120
the program can then use as sort of a

349
00:12:41,120 --> 00:12:42,639
handle to refer

350
00:12:42,639 --> 00:12:45,839
to this open file

351
00:12:45,839 --> 00:12:48,240
if you want to write to a file the

352
00:12:48,240 --> 00:12:49,279
system called

353
00:12:49,279 --> 00:12:51,519
to do that is called write you have to

354
00:12:51,519 --> 00:12:53,279
pass it one of these file descriptors

355
00:12:53,279 --> 00:12:55,760
the same as was returned by open

356
00:12:55,760 --> 00:12:58,000
um these are now arguments that are

357
00:12:58,000 --> 00:12:59,760
passed in the system call

358
00:12:59,760 --> 00:13:02,160
from the program into the kernel you

359
00:13:02,160 --> 00:13:03,839
give it a pointer

360
00:13:03,839 --> 00:13:06,560
to a buffer of characters so an easy way

361
00:13:06,560 --> 00:13:07,440
to do that in the c

362
00:13:07,440 --> 00:13:08,720
programming language which these

363
00:13:08,720 --> 00:13:10,720
examples are written by is the double

364
00:13:10,720 --> 00:13:12,560
quotes and then

365
00:13:12,560 --> 00:13:14,959
the string the bytes of the string this

366
00:13:14,959 --> 00:13:17,120
backslash n is a new line

367
00:13:17,120 --> 00:13:18,880
and the third argument is the count of

368
00:13:18,880 --> 00:13:20,880
characters

369
00:13:20,880 --> 00:13:22,399
that you want to write and so this

370
00:13:22,399 --> 00:13:24,560
really gets point passed as an address

371
00:13:24,560 --> 00:13:25,760
in memory

372
00:13:25,760 --> 00:13:27,120
so you're telling the kernel look please

373
00:13:27,120 --> 00:13:29,519
write six bytes from this address

374
00:13:29,519 --> 00:13:31,680
to the file that this file descriptor

375
00:13:31,680 --> 00:13:34,240
refers to

376
00:13:34,240 --> 00:13:36,399
a much more exciting uh system call that

377
00:13:36,399 --> 00:13:39,120
you encounter is the fork system call

378
00:13:39,120 --> 00:13:41,440
fork is the system call that creates a

379
00:13:41,440 --> 00:13:42,560
new process

380
00:13:42,560 --> 00:13:46,079
um and it returns actually creates a

381
00:13:46,079 --> 00:13:48,240
process that's identical to the caller

382
00:13:48,240 --> 00:13:51,519
and fork returns the an identifier the

383
00:13:51,519 --> 00:13:54,720
process identifier or pid

384
00:13:54,720 --> 00:13:56,000
of the new process it's actually a

385
00:13:56,000 --> 00:13:57,199
little more complicated than that and

386
00:13:57,199 --> 00:13:58,079
we'll

387
00:13:58,079 --> 00:14:01,519
hear more about this so again these are

388
00:14:01,519 --> 00:14:04,399
all look like function calls

389
00:14:04,399 --> 00:14:05,839
but the system calls are special because

390
00:14:05,839 --> 00:14:08,320
they jump into the kernel

391
00:14:08,320 --> 00:14:15,670
that's just taste i'll see more later

392
00:14:15,680 --> 00:14:19,199
well that is a sort of quick overview um

393
00:14:19,199 --> 00:14:22,880
i want to just mention why i find

394
00:14:22,880 --> 00:14:25,199
operating the study of operating systems

395
00:14:25,199 --> 00:14:26,399
to be

396
00:14:26,399 --> 00:14:32,629
both challenging and interesting

397
00:14:32,639 --> 00:14:36,389
why you know why it's maybe worth

398
00:14:36,399 --> 00:14:37,839
intellectually worth taking a course in

399
00:14:37,839 --> 00:14:40,560
this area so one reason why it's hard is

400
00:14:40,560 --> 00:14:41,360
that the

401
00:14:41,360 --> 00:14:43,920
environment's unforgiving the

402
00:14:43,920 --> 00:14:45,360
programming environment inside the

403
00:14:45,360 --> 00:14:47,120
kernel is unforgiving because

404
00:14:47,120 --> 00:14:50,550
you're

405
00:14:50,560 --> 00:14:51,839
you're when you're programming when

406
00:14:51,839 --> 00:14:53,360
you're modifying the kernel or extending

407
00:14:53,360 --> 00:14:54,800
the kernel writing a new operating

408
00:14:54,800 --> 00:14:55,760
system kernel

409
00:14:55,760 --> 00:14:57,760
you're providing the infrastructure that

410
00:14:57,760 --> 00:14:59,519
everybody else assumes is already

411
00:14:59,519 --> 00:15:01,440
present to run their programs

412
00:15:01,440 --> 00:15:02,800
right and everybody else gets an

413
00:15:02,800 --> 00:15:04,160
operating system under their program

414
00:15:04,160 --> 00:15:06,000
when they write ordinary application

415
00:15:06,000 --> 00:15:07,279
programs but

416
00:15:07,279 --> 00:15:09,199
when we build operating systems what we

417
00:15:09,199 --> 00:15:11,360
get is the hardware underneath

418
00:15:11,360 --> 00:15:14,000
our operating system which turns out to

419
00:15:14,000 --> 00:15:14,480
be

420
00:15:14,480 --> 00:15:15,920
more difficult to deal with in this

421
00:15:15,920 --> 00:15:18,399
course we

422
00:15:18,399 --> 00:15:20,399
we get to use a hardware simulator

423
00:15:20,399 --> 00:15:22,720
called qmu

424
00:15:22,720 --> 00:15:25,360
that you know simulates a cpu and a

425
00:15:25,360 --> 00:15:26,800
computer and that makes life a little

426
00:15:26,800 --> 00:15:27,519
bit better but

427
00:15:27,519 --> 00:15:29,839
it's it's still a kind of a difficult

428
00:15:29,839 --> 00:15:32,240
environment to program it

429
00:15:32,240 --> 00:15:33,440
another reason why it's hard and

430
00:15:33,440 --> 00:15:35,120
interesting is because if you're

431
00:15:35,120 --> 00:15:36,800
designing an operating system you have

432
00:15:36,800 --> 00:15:38,839
to satisfy a bunch of

433
00:15:38,839 --> 00:15:41,360
tensions that require real design

434
00:15:41,360 --> 00:15:41,920
thought

435
00:15:41,920 --> 00:15:44,399
so one is that you'd like your operating

436
00:15:44,399 --> 00:15:47,440
system to be both efficient

437
00:15:47,440 --> 00:15:49,040
which often means that it sort of

438
00:15:49,040 --> 00:15:50,639
operates at a low level close to the

439
00:15:50,639 --> 00:15:51,680
hardware

440
00:15:51,680 --> 00:15:54,320
but for ease of use and because real

441
00:15:54,320 --> 00:15:56,399
live people have to write programs

442
00:15:56,399 --> 00:15:58,320
that use your operating system we'd like

443
00:15:58,320 --> 00:16:00,079
it also to be

444
00:16:00,079 --> 00:16:03,279
provide abstract high-level portable

445
00:16:03,279 --> 00:16:04,079
interfaces

446
00:16:04,079 --> 00:16:06,000
and it's a neat trick to provide

447
00:16:06,000 --> 00:16:08,240
abstract interfaces that are simple

448
00:16:08,240 --> 00:16:10,160
um affordable but that are also

449
00:16:10,160 --> 00:16:12,560
efficient

450
00:16:12,560 --> 00:16:14,720
another tension is that we'd like to

451
00:16:14,720 --> 00:16:16,880
provide a very powerful

452
00:16:16,880 --> 00:16:18,800
operating system services so that the

453
00:16:18,800 --> 00:16:20,480
operating system can shoulder a lot of

454
00:16:20,480 --> 00:16:22,959
the burden

455
00:16:22,959 --> 00:16:24,800
of running programs we'd like to

456
00:16:24,800 --> 00:16:26,079
powerful

457
00:16:26,079 --> 00:16:29,440
operating system services

458
00:16:29,440 --> 00:16:31,920
but we also want to have simple

459
00:16:31,920 --> 00:16:35,110
interfaces

460
00:16:35,120 --> 00:16:37,519
that is we don't want tremendously

461
00:16:37,519 --> 00:16:39,360
complex hard to understand interfaces

462
00:16:39,360 --> 00:16:41,519
for programmers to use because

463
00:16:41,519 --> 00:16:42,639
they're not going to understand them and

464
00:16:42,639 --> 00:16:45,839
they may find it hard to use

465
00:16:45,839 --> 00:16:48,959
um so this is really simple api and so

466
00:16:48,959 --> 00:16:52,320
this is possible to do to provide simple

467
00:16:52,320 --> 00:16:55,759
interfaces that have powerful machinery

468
00:16:55,759 --> 00:16:57,360
inside them and so we'll always be

469
00:16:57,360 --> 00:16:58,639
searching for

470
00:16:58,639 --> 00:17:02,959
sort of simple interfaces that provide

471
00:17:02,959 --> 00:17:05,679
powerful services hey robert we have a

472
00:17:05,679 --> 00:17:07,199
question in the chat

473
00:17:07,199 --> 00:17:09,520
uh what is unique slash different about

474
00:17:09,520 --> 00:17:11,679
saying system calls jump into the kernel

475
00:17:11,679 --> 00:17:13,679
i.e as opposed to a standard function

476
00:17:13,679 --> 00:17:18,079
call that jumps to another function

477
00:17:18,079 --> 00:17:21,919
well the colonel has the kernels um

478
00:17:21,919 --> 00:17:23,760
a piece of code that's always resident

479
00:17:23,760 --> 00:17:25,679
that has special privileges

480
00:17:25,679 --> 00:17:28,240
that were that because it booted the

481
00:17:28,240 --> 00:17:30,000
machine booted the kernel

482
00:17:30,000 --> 00:17:32,000
um the kernel has special inter

483
00:17:32,000 --> 00:17:34,240
privileges that can get directly at

484
00:17:34,240 --> 00:17:35,919
all kinds of hardware like the disk

485
00:17:35,919 --> 00:17:38,480
device that ordinary user programs can't

486
00:17:38,480 --> 00:17:39,200
get at

487
00:17:39,200 --> 00:17:40,720
so if you make a fun an ordinary

488
00:17:40,720 --> 00:17:43,840
function call um

489
00:17:43,840 --> 00:17:45,520
the the function you're calling doesn't

490
00:17:45,520 --> 00:17:47,280
get it just doesn't get any special

491
00:17:47,280 --> 00:17:49,360
privileges with respect to the hardware

492
00:17:49,360 --> 00:17:50,799
whereas if you make a system call into

493
00:17:50,799 --> 00:17:52,799
the kernel um

494
00:17:52,799 --> 00:17:54,559
we'll talk about how this works but that

495
00:17:54,559 --> 00:17:56,320
ends up um

496
00:17:56,320 --> 00:17:58,000
as it when it jumps into when the system

497
00:17:58,000 --> 00:17:59,919
call jumps into the kernel

498
00:17:59,919 --> 00:18:01,600
the system call implementation in the

499
00:18:01,600 --> 00:18:02,960
kernel then gets all these special

500
00:18:02,960 --> 00:18:04,160
privileges so that it

501
00:18:04,160 --> 00:18:07,600
it can modify all kinds of

502
00:18:07,600 --> 00:18:10,799
sensitive and protected uh hardware

503
00:18:10,799 --> 00:18:12,320
resources like for example getting

504
00:18:12,320 --> 00:18:13,360
directly at the

505
00:18:13,360 --> 00:18:17,039
hard disk we'll see a lot more detail

506
00:18:17,039 --> 00:18:17,840
for all this

507
00:18:17,840 --> 00:18:21,120
uh shortly okay so

508
00:18:21,120 --> 00:18:23,440
a final tension that we wanna that all

509
00:18:23,440 --> 00:18:25,200
operating systems need to satisfy is you

510
00:18:25,200 --> 00:18:26,960
wanna give programs as much flexibility

511
00:18:26,960 --> 00:18:28,320
as you can you don't want to constrain

512
00:18:28,320 --> 00:18:33,029
them so you want to have very flexible

513
00:18:33,039 --> 00:18:35,039
interfaces but you do need to constrain

514
00:18:35,039 --> 00:18:36,640
programs somewhat because you absolutely

515
00:18:36,640 --> 00:18:39,600
have to have some notion of security

516
00:18:39,600 --> 00:18:43,440
you can't you we'd love for programs to

517
00:18:43,440 --> 00:18:44,880
give programmers complete freedom but it

518
00:18:44,880 --> 00:18:46,080
can't be complete can't be really

519
00:18:46,080 --> 00:18:46,880
complete

520
00:18:46,880 --> 00:18:48,640
because we don't want programs to get

521
00:18:48,640 --> 00:18:50,400
directly at the hardware or to interfere

522
00:18:50,400 --> 00:18:51,440
with other programs

523
00:18:51,440 --> 00:18:54,240
or to sort of be able to interfere with

524
00:18:54,240 --> 00:18:55,600
the operation of the

525
00:18:55,600 --> 00:19:00,080
operating system itself so these are all

526
00:19:00,080 --> 00:19:02,720
you know it's possible to do a good job

527
00:19:02,720 --> 00:19:04,320
and we'll talk a lot about it but

528
00:19:04,320 --> 00:19:05,840
it's always a bit of a puzzle to provide

529
00:19:05,840 --> 00:19:08,240
sort of both of these

530
00:19:08,240 --> 00:19:11,760
the properties in both of these columns

531
00:19:11,760 --> 00:19:13,679
another thing that makes os design hard

532
00:19:13,679 --> 00:19:14,799
and interesting is that

533
00:19:14,799 --> 00:19:16,320
operating systems provide a lot of

534
00:19:16,320 --> 00:19:18,000
features and a lot of services but they

535
00:19:18,000 --> 00:19:20,160
actually tend to interact

536
00:19:20,160 --> 00:19:22,080
and sometimes in odd ways they require a

537
00:19:22,080 --> 00:19:23,919
lot of thought so even in the simple

538
00:19:23,919 --> 00:19:26,720
examples i gave

539
00:19:26,720 --> 00:19:28,799
with open and fork those two interact

540
00:19:28,799 --> 00:19:31,280
actually if a program

541
00:19:31,280 --> 00:19:32,960
allocates a file descriptor with the

542
00:19:32,960 --> 00:19:34,640
open system call

543
00:19:34,640 --> 00:19:37,679
and then that same program

544
00:19:37,679 --> 00:19:41,200
forks and the semantics of fork

545
00:19:41,200 --> 00:19:42,960
just turn out to be that you create a

546
00:19:42,960 --> 00:19:44,960
new process that's a copy of the current

547
00:19:44,960 --> 00:19:45,840
process

548
00:19:45,840 --> 00:19:49,669
this file descriptor you opened

549
00:19:49,679 --> 00:19:51,600
if that's truly to be a copy this file

550
00:19:51,600 --> 00:19:52,880
descriptor still has to

551
00:19:52,880 --> 00:19:56,160
um be present and usable in the child

552
00:19:56,160 --> 00:19:58,320
and you know so that's to be thought

553
00:19:58,320 --> 00:20:00,080
through that is the files the open and

554
00:20:00,080 --> 00:20:01,760
filed scripters interact with fork in

555
00:20:01,760 --> 00:20:03,760
this interesting way

556
00:20:03,760 --> 00:20:05,840
and somebody has to figure out oh should

557
00:20:05,840 --> 00:20:06,960
the child be able to

558
00:20:06,960 --> 00:20:09,440
get at the file descriptors created

559
00:20:09,440 --> 00:20:10,799
before fork was called

560
00:20:10,799 --> 00:20:12,640
and the answer happens to be yes in the

561
00:20:12,640 --> 00:20:17,029
operating systems we're going to look at

562
00:20:17,039 --> 00:20:18,880
all right and so other things that are

563
00:20:18,880 --> 00:20:20,320
turned out to be interesting

564
00:20:20,320 --> 00:20:22,000
i already mentioned that operating

565
00:20:22,000 --> 00:20:24,000
systems have to cater to a wide variety

566
00:20:24,000 --> 00:20:24,960
of uses

567
00:20:24,960 --> 00:20:28,080
the same os used both for database

568
00:20:28,080 --> 00:20:31,520
servers and and smartphones for example

569
00:20:31,520 --> 00:20:35,200
and operating systems as time goes on

570
00:20:35,200 --> 00:20:37,919
the hardware that you run the hardware

571
00:20:37,919 --> 00:20:40,400
you get with typical computers changes

572
00:20:40,400 --> 00:20:42,720
maybe you get super fast ssd storage

573
00:20:42,720 --> 00:20:44,320
instead of mechanical hard drives for

574
00:20:44,320 --> 00:20:45,520
example

575
00:20:45,520 --> 00:20:48,880
about 15 years ago multi-core computers

576
00:20:48,880 --> 00:20:51,360
went from being rare curiosities to

577
00:20:51,360 --> 00:20:51,919
being

578
00:20:51,919 --> 00:20:55,679
pervasive and recently we've seen you

579
00:20:55,679 --> 00:20:57,679
know order of magnitude speedups in how

580
00:20:57,679 --> 00:20:59,120
fast networks operate

581
00:20:59,120 --> 00:21:02,880
and so all these require rethinks um

582
00:21:02,880 --> 00:21:04,559
periodically of how operating systems

583
00:21:04,559 --> 00:21:06,480
are designed

584
00:21:06,480 --> 00:21:10,880
now um so so those are those are sort of

585
00:21:10,880 --> 00:21:12,080
intellectually why you might take the

586
00:21:12,080 --> 00:21:13,440
course there's also some even more

587
00:21:13,440 --> 00:21:16,159
practical reasons why you might be glad

588
00:21:16,159 --> 00:21:18,559
to have taken this course one is if

589
00:21:18,559 --> 00:21:20,159
you're interested in what happens inside

590
00:21:20,159 --> 00:21:21,520
computers what goes on under

591
00:21:21,520 --> 00:21:24,320
and saw under the hood sort of in secret

592
00:21:24,320 --> 00:21:25,840
when you turn on your computer

593
00:21:25,840 --> 00:21:28,000
this is a good course to take similarly

594
00:21:28,000 --> 00:21:30,080
if you like infrastructure that is if if

595
00:21:30,080 --> 00:21:30,720
you enjoy

596
00:21:30,720 --> 00:21:33,840
building uh sort of services that other

597
00:21:33,840 --> 00:21:36,400
programs can then use

598
00:21:36,400 --> 00:21:38,080
this is of course essentially all about

599
00:21:38,080 --> 00:21:39,760
infrastructure because that's that's

600
00:21:39,760 --> 00:21:42,400
what operating systems are

601
00:21:42,400 --> 00:21:43,919
if you ever need to spend a lot of time

602
00:21:43,919 --> 00:21:45,520
tracking down bugs in

603
00:21:45,520 --> 00:21:47,360
application code or tracking down

604
00:21:47,360 --> 00:21:48,799
security problems

605
00:21:48,799 --> 00:21:51,360
often that um involves understanding

606
00:21:51,360 --> 00:21:52,960
what was going on inside the operating

607
00:21:52,960 --> 00:21:53,600
system

608
00:21:53,600 --> 00:21:54,880
because it's ultimately the operating

609
00:21:54,880 --> 00:21:57,679
system that enforces a lot of security

610
00:21:57,679 --> 00:21:58,720
and

611
00:21:58,720 --> 00:22:00,320
when things go wrong it's sort of the

612
00:22:00,320 --> 00:22:01,679
operating system that has to pick up the

613
00:22:01,679 --> 00:22:02,480
pieces so

614
00:22:02,480 --> 00:22:05,120
that's often involved in uh tracking

615
00:22:05,120 --> 00:22:06,159
down bugs

616
00:22:06,159 --> 00:22:08,880
and finally yes two more questions from

617
00:22:08,880 --> 00:22:09,919
the chat so

618
00:22:09,919 --> 00:22:11,440
the first is how important is it for

619
00:22:11,440 --> 00:22:13,440
application developers to truly deeply

620
00:22:13,440 --> 00:22:15,039
understand the operating systems they're

621
00:22:15,039 --> 00:22:16,960
developing their applications for

622
00:22:16,960 --> 00:22:19,919
do they necessarily need to be experts

623
00:22:19,919 --> 00:22:21,600
you don't have to be an expert but if

624
00:22:21,600 --> 00:22:22,559
you spend

625
00:22:22,559 --> 00:22:24,720
um a lot of time developing and

626
00:22:24,720 --> 00:22:26,640
maintaining and debugging applications

627
00:22:26,640 --> 00:22:28,960
you'll eventually end up knowing a lot

628
00:22:28,960 --> 00:22:30,240
about the operating system

629
00:22:30,240 --> 00:22:32,480
whether you whether you meant to or not

630
00:22:32,480 --> 00:22:34,080
it just

631
00:22:34,080 --> 00:22:36,640
it just comes up and you're often forced

632
00:22:36,640 --> 00:22:39,590
to understand

633
00:22:39,600 --> 00:22:41,760
and the second question is do high-level

634
00:22:41,760 --> 00:22:43,039
programming languages like

635
00:22:43,039 --> 00:22:45,440
python use system calls directly are

636
00:22:45,440 --> 00:22:46,400
there built-ins

637
00:22:46,400 --> 00:22:48,960
slash wrappers for convenience a lot of

638
00:22:48,960 --> 00:22:50,480
high-level languages are

639
00:22:50,480 --> 00:22:53,440
sort of at one remove from system calls

640
00:22:53,440 --> 00:22:56,789
that's absolutely true so

641
00:22:56,799 --> 00:22:59,280
partially because a lot of languages

642
00:22:59,280 --> 00:23:00,400
want to provide

643
00:23:00,400 --> 00:23:02,799
portable a portable environment that

644
00:23:02,799 --> 00:23:04,000
works on many different operating

645
00:23:04,000 --> 00:23:06,000
systems so they can't necessarily commit

646
00:23:06,000 --> 00:23:08,320
to the specific system calls of any one

647
00:23:08,320 --> 00:23:09,919
operating system

648
00:23:09,919 --> 00:23:12,799
um so i'm the answer the question i

649
00:23:12,799 --> 00:23:14,480
think is if you use python

650
00:23:14,480 --> 00:23:17,600
uh you're somewhat insulated from the

651
00:23:17,600 --> 00:23:18,880
system call interface you know

652
00:23:18,880 --> 00:23:20,799
internally of course python makes

653
00:23:20,799 --> 00:23:22,320
has to make system calls to get its work

654
00:23:22,320 --> 00:23:24,400
done and

655
00:23:24,400 --> 00:23:25,840
certainly in python and many other

656
00:23:25,840 --> 00:23:27,919
languages there is usually a way to get

657
00:23:27,919 --> 00:23:31,039
directly at the system calls of whatever

658
00:23:31,039 --> 00:23:31,520
your

659
00:23:31,520 --> 00:23:35,440
operating system you're running on

660
00:23:35,440 --> 00:23:37,120
and folks for questions you can just

661
00:23:37,120 --> 00:23:38,640
feel free to jump in yourself and ask

662
00:23:38,640 --> 00:23:39,760
questions you don't need to go through

663
00:23:39,760 --> 00:23:43,350
the chat

664
00:23:43,360 --> 00:23:46,720
okay um all right

665
00:23:46,720 --> 00:23:50,559
sorry um

666
00:23:50,559 --> 00:23:52,000
i'm going to spend a couple of minutes

667
00:23:52,000 --> 00:23:53,760
now talking about

668
00:23:53,760 --> 00:23:57,039
the class structure of

669
00:23:57,039 --> 00:24:01,120
6 s081

670
00:24:01,120 --> 00:24:04,159
before switching back to actual

671
00:24:04,159 --> 00:24:05,440
technical content

672
00:24:05,440 --> 00:24:07,760
so the uh there's a website for the

673
00:24:07,760 --> 00:24:09,360
course which i don't want to write out

674
00:24:09,360 --> 00:24:10,240
just now but it's

675
00:24:10,240 --> 00:24:12,799
um you can find it by looking for 6s 081

676
00:24:12,799 --> 00:24:14,240
on google

677
00:24:14,240 --> 00:24:19,840
and the website um has

678
00:24:19,840 --> 00:24:23,919
um the schedule uh

679
00:24:23,919 --> 00:24:26,240
it has the assignments on the schedule

680
00:24:26,240 --> 00:24:28,720
it has the lab assignments

681
00:24:28,720 --> 00:24:30,880
um and it has the sort of information

682
00:24:30,880 --> 00:24:32,000
about course structure like

683
00:24:32,000 --> 00:24:35,919
the grading policy on it the other big

684
00:24:35,919 --> 00:24:37,840
resource you're gonna want to keep track

685
00:24:37,840 --> 00:24:40,240
of is piazza

686
00:24:40,240 --> 00:24:41,840
i guess everybody who's here got here by

687
00:24:41,840 --> 00:24:43,919
the way piazza but

688
00:24:43,919 --> 00:24:47,520
as well as so we use piazza really for

689
00:24:47,520 --> 00:24:48,720
two main things one is

690
00:24:48,720 --> 00:24:50,240
as a way of people to be able to ask

691
00:24:50,240 --> 00:24:53,360
questions about the lab assignments and

692
00:24:53,360 --> 00:24:55,840
uh course staff will try to answer these

693
00:24:55,840 --> 00:24:56,480
questions but

694
00:24:56,480 --> 00:24:58,000
you should feel absolutely free to

695
00:24:58,000 --> 00:25:00,640
answer each other's questions as well

696
00:25:00,640 --> 00:25:01,840
and the other big thing that happens on

697
00:25:01,840 --> 00:25:03,520
piazza if there's announcements if

698
00:25:03,520 --> 00:25:04,640
there's any announcements about the

699
00:25:04,640 --> 00:25:05,919
course

700
00:25:05,919 --> 00:25:07,679
we'll put the announcements on piazza so

701
00:25:07,679 --> 00:25:09,120
you should keep an eye on piazza for

702
00:25:09,120 --> 00:25:11,120
announcements even if

703
00:25:11,120 --> 00:25:16,630
you're not using it for lab help

704
00:25:16,640 --> 00:25:18,480
the one of the big parts of the course

705
00:25:18,480 --> 00:25:21,990
is that these lectures

706
00:25:22,000 --> 00:25:25,600
the lectures will

707
00:25:25,600 --> 00:25:30,240
cover basic ideas in operating systems

708
00:25:30,240 --> 00:25:32,000
some of the lectures will be devoted to

709
00:25:32,000 --> 00:25:33,520
detailed

710
00:25:33,520 --> 00:25:36,799
study of the code in xv6 which is our

711
00:25:36,799 --> 00:25:39,360
small teaching operating system

712
00:25:39,360 --> 00:25:41,520
and so talk about how it works we'll

713
00:25:41,520 --> 00:25:43,120
look at the code and sort of show the

714
00:25:43,120 --> 00:25:45,760
code executing during lectures

715
00:25:45,760 --> 00:25:47,360
and in addition before many of the

716
00:25:47,360 --> 00:25:48,880
lectures there'll be assignments

717
00:25:48,880 --> 00:25:51,520
reading assignments from a book that

718
00:25:51,520 --> 00:25:52,720
sort of describes how

719
00:25:52,720 --> 00:25:55,520
xv6 operates and why it's designed that

720
00:25:55,520 --> 00:25:56,640
way

721
00:25:56,640 --> 00:25:58,000
so you should do the readings before the

722
00:25:58,000 --> 00:26:00,559
class so that you'll understand

723
00:26:00,559 --> 00:26:02,799
the discussion in the class some of the

724
00:26:02,799 --> 00:26:04,240
lectures are devoted to

725
00:26:04,240 --> 00:26:07,120
background to help you do the labs sort

726
00:26:07,120 --> 00:26:09,840
of explanations about c works of how the

727
00:26:09,840 --> 00:26:12,000
risc 5 which is the microprocessor that

728
00:26:12,000 --> 00:26:13,679
we'll be using

729
00:26:13,679 --> 00:26:16,159
that you'll find helpful in in

730
00:26:16,159 --> 00:26:17,679
understanding how to do the labs

731
00:26:17,679 --> 00:26:20,159
and towards the end of the course i will

732
00:26:20,159 --> 00:26:21,760
spend some lectures

733
00:26:21,760 --> 00:26:24,320
discussing some operating system papers

734
00:26:24,320 --> 00:26:25,039
um

735
00:26:25,039 --> 00:26:26,960
research papers and and some classic

736
00:26:26,960 --> 00:26:28,320
papers in the field

737
00:26:28,320 --> 00:26:30,320
which uh you know we'll ask that you

738
00:26:30,320 --> 00:26:31,520
read before the lectures and then we'll

739
00:26:31,520 --> 00:26:33,120
sort of talk about the

740
00:26:33,120 --> 00:26:35,520
papers in during the lecture for all the

741
00:26:35,520 --> 00:26:37,279
lectures or almost all the lectures

742
00:26:37,279 --> 00:26:39,279
we ask that you submit a question about

743
00:26:39,279 --> 00:26:40,960
the reading

744
00:26:40,960 --> 00:26:44,320
for the lecture before the actual time

745
00:26:44,320 --> 00:26:45,200
of the lecture

746
00:26:45,200 --> 00:26:47,679
which many or all of you did for this

747
00:26:47,679 --> 00:26:49,760
lecture for which thank you

748
00:26:49,760 --> 00:26:51,279
and we will read those questions to help

749
00:26:51,279 --> 00:26:53,200
us

750
00:26:53,200 --> 00:26:55,279
guide us about what to talk about and

751
00:26:55,279 --> 00:26:56,480
we'll try to answer

752
00:26:56,480 --> 00:26:57,919
as many of the questions as we can

753
00:26:57,919 --> 00:26:59,760
although there's rarely time

754
00:26:59,760 --> 00:27:01,360
unfortunately for us to answer all of

755
00:27:01,360 --> 00:27:03,360
them

756
00:27:03,360 --> 00:27:06,320
the next big part the course of the labs

757
00:27:06,320 --> 00:27:07,760
there's a programming lab

758
00:27:07,760 --> 00:27:11,840
do almost every week

759
00:27:11,840 --> 00:27:13,279
and the point of the labs is to help you

760
00:27:13,279 --> 00:27:16,159
get hands-on experience with

761
00:27:16,159 --> 00:27:20,640
implementing and using operating systems

762
00:27:20,640 --> 00:27:23,760
um the lab that's due next week

763
00:27:23,760 --> 00:27:26,080
is actually about using using about

764
00:27:26,080 --> 00:27:27,520
writing applications that

765
00:27:27,520 --> 00:27:29,200
make the call the system calls we'll be

766
00:27:29,200 --> 00:27:31,440
talking about um

767
00:27:31,440 --> 00:27:33,279
whereas most of those labs after that

768
00:27:33,279 --> 00:27:35,039
are involve you

769
00:27:35,039 --> 00:27:37,039
either implementing basic operating

770
00:27:37,039 --> 00:27:38,880
system features or adding

771
00:27:38,880 --> 00:27:42,720
uh kernel extensions to the xv6

772
00:27:42,720 --> 00:27:45,600
uh operating system the very last slab

773
00:27:45,600 --> 00:27:46,159
and

774
00:27:46,159 --> 00:27:48,000
one in which you actually add a network

775
00:27:48,000 --> 00:27:49,840
stack and a network driver so you'll be

776
00:27:49,840 --> 00:27:51,440
able to connect in over the network

777
00:27:51,440 --> 00:27:55,600
to the operating system that you run um

778
00:27:55,600 --> 00:27:57,200
you should if you have problems with the

779
00:27:57,200 --> 00:27:59,760
labs uh there'll be office hours

780
00:27:59,760 --> 00:28:03,200
that the um tas will hold in addition

781
00:28:03,200 --> 00:28:04,720
you can

782
00:28:04,720 --> 00:28:07,120
post questions to piazza and very often

783
00:28:07,120 --> 00:28:08,399
you'll be able to get useful answers

784
00:28:08,399 --> 00:28:10,080
from piazza

785
00:28:10,080 --> 00:28:13,200
more quickly than from office hours

786
00:28:13,200 --> 00:28:15,919
we welcome you discussing the labs

787
00:28:15,919 --> 00:28:17,360
talking about the labs talking about how

788
00:28:17,360 --> 00:28:18,080
to

789
00:28:18,080 --> 00:28:21,200
design the lab solutions but we ask you

790
00:28:21,200 --> 00:28:22,480
please do not look at other people's

791
00:28:22,480 --> 00:28:23,520
solutions

792
00:28:23,520 --> 00:28:25,360
for the labs please all the code you

793
00:28:25,360 --> 00:28:26,640
write should be your own and

794
00:28:26,640 --> 00:28:29,600
you shouldn't share code or look at

795
00:28:29,600 --> 00:28:32,630
other solutions

796
00:28:32,640 --> 00:28:35,679
the grading

797
00:28:35,679 --> 00:28:40,000
for the course will be mostly determined

798
00:28:40,000 --> 00:28:42,960
from the labs this year so 70 of the

799
00:28:42,960 --> 00:28:44,080
grade will be

800
00:28:44,080 --> 00:28:48,000
um uh based on

801
00:28:48,000 --> 00:28:49,760
whether or not that your lab the lab you

802
00:28:49,760 --> 00:28:51,600
submit passes the tests and we for

803
00:28:51,600 --> 00:28:53,600
grading we run the same tests

804
00:28:53,600 --> 00:28:55,600
um that we supply you so if your lab

805
00:28:55,600 --> 00:28:57,600
passes the all the tests that we give

806
00:28:57,600 --> 00:28:59,120
you then chances are you get full credit

807
00:28:59,120 --> 00:29:00,399
for the lab

808
00:29:00,399 --> 00:29:03,600
um 20 of the grade

809
00:29:03,600 --> 00:29:05,600
um is going to be from lab check off

810
00:29:05,600 --> 00:29:06,640
meetings

811
00:29:06,640 --> 00:29:09,440
uh we'll for each of you we'll pick a

812
00:29:09,440 --> 00:29:11,279
couple of randomly selected labs

813
00:29:11,279 --> 00:29:13,360
and one of the teams will talk to you

814
00:29:13,360 --> 00:29:14,399
and ask you questions about your

815
00:29:14,399 --> 00:29:17,440
implementation just to make sure that

816
00:29:17,440 --> 00:29:20,159
you really understand what's going on so

817
00:29:20,159 --> 00:29:20,640
this

818
00:29:20,640 --> 00:29:23,830
lab check-offs

819
00:29:23,840 --> 00:29:27,360
there's um ten percent remaining

820
00:29:27,360 --> 00:29:30,559
there's a question be like a

821
00:29:30,559 --> 00:29:33,360
yes or no one or zero type of thing or

822
00:29:33,360 --> 00:29:35,039
would they be

823
00:29:35,039 --> 00:29:38,240
like could someone get like if they

824
00:29:38,240 --> 00:29:40,399
answered some of the questions right but

825
00:29:40,399 --> 00:29:41,679
not all the questions right would they

826
00:29:41,679 --> 00:29:42,080
get

827
00:29:42,080 --> 00:29:45,279
in between so they're great you know i

828
00:29:45,279 --> 00:29:47,360
haven't thought this through

829
00:29:47,360 --> 00:29:49,919
um there's certainly room for partial

830
00:29:49,919 --> 00:29:51,440
credit but

831
00:29:51,440 --> 00:29:53,760
it's not a it won't be binary it'll

832
00:29:53,760 --> 00:29:54,799
definitely be

833
00:29:54,799 --> 00:29:59,120
you can receive partial credit okay

834
00:29:59,120 --> 00:30:01,840
all right um the last 10 is going to be

835
00:30:01,840 --> 00:30:03,039
driven by the homework

836
00:30:03,039 --> 00:30:06,000
and participation during lecture and in

837
00:30:06,000 --> 00:30:08,950
piazza

838
00:30:08,960 --> 00:30:13,190
there'll be no exam or quizzes

839
00:30:13,200 --> 00:30:17,039
this year um and so what that means is

840
00:30:17,039 --> 00:30:18,399
that most of the

841
00:30:18,399 --> 00:30:21,919
you know ninety percent of the grade is

842
00:30:21,919 --> 00:30:23,760
being driven by the lab so

843
00:30:23,760 --> 00:30:25,760
you know you should spend a lot of time

844
00:30:25,760 --> 00:30:27,440
in the labs

845
00:30:27,440 --> 00:30:29,840
make sure that you start early and have

846
00:30:29,840 --> 00:30:31,279
enough time to

847
00:30:31,279 --> 00:30:34,080
complete them and work out bugs in order

848
00:30:34,080 --> 00:30:37,200
to get full credit

849
00:30:37,200 --> 00:30:39,440
and you know as a result of that this is

850
00:30:39,440 --> 00:30:42,000
going to be a very kind of hands-on

851
00:30:42,000 --> 00:30:44,960
software oriented course or any

852
00:30:44,960 --> 00:30:47,120
questions about the

853
00:30:47,120 --> 00:30:53,669
machinery of the course

854
00:30:53,679 --> 00:30:56,559
uh we've got a couple questions in chat

855
00:30:56,559 --> 00:30:59,039
so the first is a logistical question

856
00:30:59,039 --> 00:31:01,360
currently 6s081 isn't listed as usable

857
00:31:01,360 --> 00:31:03,840
for the systems concentration in the

858
00:31:03,840 --> 00:31:05,360
are there plans added to the list of

859
00:31:05,360 --> 00:31:07,519
classes later i think for that

860
00:31:07,519 --> 00:31:10,960
because it's not an aags it's an aus

861
00:31:10,960 --> 00:31:12,960
it can't be used to fulfill mn

862
00:31:12,960 --> 00:31:14,399
requirements as it's not a graduate

863
00:31:14,399 --> 00:31:14,799
level

864
00:31:14,799 --> 00:31:19,519
class but

865
00:31:19,519 --> 00:31:22,000
um and then we have is the only homework

866
00:31:22,000 --> 00:31:23,360
to submit questions looking at the

867
00:31:23,360 --> 00:31:28,149
calendar that appears to be the case

868
00:31:28,159 --> 00:31:31,360
unless i'm forgetting something i think

869
00:31:31,360 --> 00:31:32,080
that's the case

870
00:31:32,080 --> 00:31:35,600
yes so

871
00:31:35,600 --> 00:31:38,720
have uh are there gonna be cutoffs for

872
00:31:38,720 --> 00:31:40,640
grades like x percent gets an a

873
00:31:40,640 --> 00:31:43,919
y percent gets a b etc

874
00:31:43,919 --> 00:31:48,149
no no um

875
00:31:48,159 --> 00:31:51,269
you know we're going to try to

876
00:31:51,279 --> 00:31:54,480
free student estimate um

877
00:31:54,480 --> 00:31:56,880
our impression of how well you've

878
00:31:56,880 --> 00:31:59,200
understood the material

879
00:31:59,200 --> 00:32:00,480
and assign a grade based on that so

880
00:32:00,480 --> 00:32:07,909
there's there's no predetermined cutoffs

881
00:32:07,919 --> 00:32:13,590
all right anything else

882
00:32:13,600 --> 00:32:16,799
all right just real quick for folks

883
00:32:16,799 --> 00:32:21,039
in the chat uh asking about the

884
00:32:21,039 --> 00:32:23,200
concentration requirement i'm not a

885
00:32:23,200 --> 00:32:24,480
hundred percent certain

886
00:32:24,480 --> 00:32:27,279
uh but six soa one is not it's like a

887
00:32:27,279 --> 00:32:28,080
temporary number

888
00:32:28,080 --> 00:32:29,919
before the class gets this official one

889
00:32:29,919 --> 00:32:31,679
so it certainly won't be

890
00:32:31,679 --> 00:32:34,080
uh listed anywhere if you needed to

891
00:32:34,080 --> 00:32:35,440
fulfill a concentration i think your

892
00:32:35,440 --> 00:32:36,720
best bet is probably to fill out a

893
00:32:36,720 --> 00:32:37,360
petition

894
00:32:37,360 --> 00:32:39,519
or to email somebody like katrina

895
00:32:39,519 --> 00:32:40,720
lakerts

896
00:32:40,720 --> 00:32:43,840
to see what the status is we don't

897
00:32:43,840 --> 00:32:45,440
control

898
00:32:45,440 --> 00:32:48,159
you know what what classes fill these

899
00:32:48,159 --> 00:32:49,200
kind of requirements

900
00:32:49,200 --> 00:32:52,000
unfortunately and for what language

901
00:32:52,000 --> 00:32:58,710
we'll be using the class will be in c

902
00:32:58,720 --> 00:33:02,389
all right um

903
00:33:02,399 --> 00:33:04,000
all right for the rest of the lecture i

904
00:33:04,000 --> 00:33:06,159
want to uh talk about how

905
00:33:06,159 --> 00:33:08,840
um house what system calls look like to

906
00:33:08,840 --> 00:33:11,279
applications

907
00:33:11,279 --> 00:33:13,760
and you know since the system calls are

908
00:33:13,760 --> 00:33:14,480
the

909
00:33:14,480 --> 00:33:16,559
interface to the services that the

910
00:33:16,559 --> 00:33:18,159
operating system provides it

911
00:33:18,159 --> 00:33:19,760
it's actually pretty important what

912
00:33:19,760 --> 00:33:20,960
those system files look like what

913
00:33:20,960 --> 00:33:23,360
applications expect from system calls

914
00:33:23,360 --> 00:33:25,039
and how they behave so it's sort of

915
00:33:25,039 --> 00:33:26,559
worth understanding what the interface

916
00:33:26,559 --> 00:33:29,590
looks like

917
00:33:29,600 --> 00:33:31,279
you'll be using the system calls we talk

918
00:33:31,279 --> 00:33:33,360
about in the first lab

919
00:33:33,360 --> 00:33:36,159
and extending and improving the

920
00:33:36,159 --> 00:33:37,120
implementation

921
00:33:37,120 --> 00:33:38,720
internal implementation of these system

922
00:33:38,720 --> 00:33:41,039
calls in subsequent labs

923
00:33:41,039 --> 00:33:43,519
what i'm going to do is show some simple

924
00:33:43,519 --> 00:33:44,480
examples

925
00:33:44,480 --> 00:33:48,070
of little programs

926
00:33:48,080 --> 00:33:51,679
that call system calls and then i'll run

927
00:33:51,679 --> 00:33:52,000
them

928
00:33:52,000 --> 00:33:55,519
and and next v6 for you um

929
00:33:55,519 --> 00:33:58,720
i'm going to run them the xv6 is a it's

930
00:33:58,720 --> 00:33:59,440
a unix

931
00:33:59,440 --> 00:34:01,600
a simplified unix-like operating system

932
00:34:01,600 --> 00:34:02,960
unix is a

933
00:34:02,960 --> 00:34:06,480
old operating system sort of at least

934
00:34:06,480 --> 00:34:08,079
intellectual basis for many

935
00:34:08,079 --> 00:34:09,599
present day operating systems such as

936
00:34:09,599 --> 00:34:11,359
linux and os x

937
00:34:11,359 --> 00:34:14,560
so it's in very common use

938
00:34:14,560 --> 00:34:18,079
xv6 our teaching operating system is

939
00:34:18,079 --> 00:34:19,760
much simpler

940
00:34:19,760 --> 00:34:22,240
it's sort of inspired by unix and has

941
00:34:22,240 --> 00:34:23,760
the same overall structure but is

942
00:34:23,760 --> 00:34:26,960
dramatically simpler than any real unix

943
00:34:26,960 --> 00:34:30,629
operating system

944
00:34:30,639 --> 00:34:33,839
and it's simple enough that hopefully um

945
00:34:33,839 --> 00:34:34,720
you know

946
00:34:34,720 --> 00:34:36,560
it would be relatively straightforward

947
00:34:36,560 --> 00:34:38,560
for you to read all the source code

948
00:34:38,560 --> 00:34:41,119
as well as read the book um in a couple

949
00:34:41,119 --> 00:34:42,639
of weeks certainly during the semester

950
00:34:42,639 --> 00:34:43,599
in order to

951
00:34:43,599 --> 00:34:45,520
kind of understand all of what happens

952
00:34:45,520 --> 00:34:49,589
inside xv6

953
00:34:49,599 --> 00:34:53,119
x86 runs on the risc-5 processor

954
00:34:53,119 --> 00:34:55,440
risc-5 microprocessor and this is the

955
00:34:55,440 --> 00:34:57,599
same microprocessor that's the focus of

956
00:34:57,599 --> 00:34:59,920
recent 6004

957
00:34:59,920 --> 00:35:02,960
so many of you may actually know quite a

958
00:35:02,960 --> 00:35:06,640
bit about the risk 5 instruction set

959
00:35:06,640 --> 00:35:09,440
in theory you could run xv6 on top of a

960
00:35:09,440 --> 00:35:11,440
risk 5 computer

961
00:35:11,440 --> 00:35:14,550
and people have done that

962
00:35:14,560 --> 00:35:17,599
but we're going to run it under the qmu

963
00:35:17,599 --> 00:35:19,599
machine emulator so just to write this

964
00:35:19,599 --> 00:35:20,720
down we got

965
00:35:20,720 --> 00:35:24,160
our operating system is xv6

966
00:35:24,160 --> 00:35:28,400
it runs on risk 5 microprocessor

967
00:35:28,400 --> 00:35:30,400
and not just risk 5 microprocessor but

968
00:35:30,400 --> 00:35:31,839
we assume a certain amount of

969
00:35:31,839 --> 00:35:34,079
surrounding hardware like

970
00:35:34,079 --> 00:35:37,760
memory and a disk and a console

971
00:35:37,760 --> 00:35:40,960
interface for us to talk to it um but we

972
00:35:40,960 --> 00:35:41,520
actually run

973
00:35:41,520 --> 00:35:45,359
under the qmu

974
00:35:45,359 --> 00:35:49,280
machine simulator so that which

975
00:35:49,280 --> 00:35:51,680
runs under linux so that all of you can

976
00:35:51,680 --> 00:35:53,920
actually

977
00:35:53,920 --> 00:35:56,880
run xv6 without having to have hardware

978
00:35:56,880 --> 00:35:57,280
okay

979
00:35:57,280 --> 00:36:10,829
so i'm gonna switch to uh showing you

980
00:36:10,839 --> 00:36:15,589
code

981
00:36:15,599 --> 00:36:18,640
all right so um first thing is

982
00:36:18,640 --> 00:36:22,720
i've uh set up xv6 on my laptop

983
00:36:22,720 --> 00:36:25,200
um and i'm going to run it and type make

984
00:36:25,200 --> 00:36:26,720
qmu which you'll find yourself doing

985
00:36:26,720 --> 00:36:28,240
quite a bit during the labs

986
00:36:28,240 --> 00:36:30,800
um which compiles xv6 it's written in c

987
00:36:30,800 --> 00:36:32,480
so it's compiled with a

988
00:36:32,480 --> 00:36:35,520
c compiler maybe i'll make

989
00:36:35,520 --> 00:36:37,920
clean for you so you can see the actual

990
00:36:37,920 --> 00:36:38,960
compilation

991
00:36:38,960 --> 00:36:41,280
and i might type make qmu which has the

992
00:36:41,280 --> 00:36:42,480
effect of

993
00:36:42,480 --> 00:36:44,880
compiling and building xv6 kernel and

994
00:36:44,880 --> 00:36:45,760
all the user

995
00:36:45,760 --> 00:36:48,560
processes and then running them under

996
00:36:48,560 --> 00:36:51,680
the qmu emulator

997
00:36:51,680 --> 00:36:55,910
it takes a moment to run the compiles

998
00:36:55,920 --> 00:36:59,280
and now we're up and running xv6 and the

999
00:36:59,280 --> 00:37:02,320
dollar sign prompt you see is the shell

1000
00:37:02,320 --> 00:37:05,200
which is the command line interface to

1001
00:37:05,200 --> 00:37:06,000
xv6

1002
00:37:06,000 --> 00:37:09,680
modeled after the shell on unix which is

1003
00:37:09,680 --> 00:37:12,160
if you log into an athena workstation

1004
00:37:12,160 --> 00:37:13,599
it's the

1005
00:37:13,599 --> 00:37:15,520
it's like the shell that athena shows

1006
00:37:15,520 --> 00:37:18,150
you

1007
00:37:18,160 --> 00:37:20,640
x36 is itself tiny and it comes with a

1008
00:37:20,640 --> 00:37:23,040
small number of utility programs

1009
00:37:23,040 --> 00:37:25,839
and including for example the ls program

1010
00:37:25,839 --> 00:37:27,520
which i'm about to run

1011
00:37:27,520 --> 00:37:30,640
run ls and it gives me a list of all the

1012
00:37:30,640 --> 00:37:32,400
files in xv6 of which there are only

1013
00:37:32,400 --> 00:37:34,079
about two dozen

1014
00:37:34,079 --> 00:37:37,200
including things like grep and kill and

1015
00:37:37,200 --> 00:37:38,079
make deer

1016
00:37:38,079 --> 00:37:41,119
and rn which may be familiar to you as

1017
00:37:41,119 --> 00:37:44,960
uh as unix utilities

1018
00:37:44,960 --> 00:37:46,400
okay the first program i'm going to show

1019
00:37:46,400 --> 00:37:48,079
you to illustrate system calls

1020
00:37:48,079 --> 00:37:59,910
is um program called copy

1021
00:37:59,920 --> 00:38:08,630
um here's the source it's just a page

1022
00:38:08,640 --> 00:38:09,839
and so what you're seeing here is a

1023
00:38:09,839 --> 00:38:12,240
program that starts on line eight and

1024
00:38:12,240 --> 00:38:12,720
main

1025
00:38:12,720 --> 00:38:14,400
there's the sort of convention for c

1026
00:38:14,400 --> 00:38:18,079
programs it sits in a loop at line 12.

1027
00:38:18,079 --> 00:38:21,280
and over and over again it reads some

1028
00:38:21,280 --> 00:38:21,760
data

1029
00:38:21,760 --> 00:38:24,400
as input and on line 13 and then writes

1030
00:38:24,400 --> 00:38:26,240
the data just read

1031
00:38:26,240 --> 00:38:32,079
to its output on line 16. if i run copy

1032
00:38:32,079 --> 00:38:35,680
uh in xv6 just waiting to read input if

1033
00:38:35,680 --> 00:38:36,240
i

1034
00:38:36,240 --> 00:38:39,119
type some input and reads it and spits

1035
00:38:39,119 --> 00:38:40,160
it back out to me

1036
00:38:40,160 --> 00:38:43,119
so it's very simple program just does i

1037
00:38:43,119 --> 00:38:45,119
out

1038
00:38:45,119 --> 00:38:47,280
it's written in c as i mentioned um if

1039
00:38:47,280 --> 00:38:49,040
you're you don't already know c it's

1040
00:38:49,040 --> 00:38:50,800
worthwhile getting the

1041
00:38:50,800 --> 00:38:53,359
um standard c programming language book

1042
00:38:53,359 --> 00:38:55,040
by kernhan and ritchie

1043
00:38:55,040 --> 00:38:58,000
and i think there's a more full

1044
00:38:58,000 --> 00:38:59,440
reference to it on the

1045
00:38:59,440 --> 00:39:02,240
course website which explains to you in

1046
00:39:02,240 --> 00:39:03,200
a

1047
00:39:03,200 --> 00:39:04,640
very straightforward way how to program

1048
00:39:04,640 --> 00:39:08,230
and see

1049
00:39:08,240 --> 00:39:09,839
as i mentioned before read and write

1050
00:39:09,839 --> 00:39:11,520
this this program makes

1051
00:39:11,520 --> 00:39:13,520
two really three system calls read write

1052
00:39:13,520 --> 00:39:14,960
and exit are

1053
00:39:14,960 --> 00:39:18,079
system calls if you look at the call to

1054
00:39:18,079 --> 00:39:20,000
read on line 13

1055
00:39:20,000 --> 00:39:22,720
it takes three arguments the first

1056
00:39:22,720 --> 00:39:24,160
argument is a file descriptor which is

1057
00:39:24,160 --> 00:39:26,079
really a reference to a previously open

1058
00:39:26,079 --> 00:39:27,520
file

1059
00:39:27,520 --> 00:39:30,960
and the shell uh ensures that

1060
00:39:30,960 --> 00:39:33,680
when a program starts by default its

1061
00:39:33,680 --> 00:39:35,920
file descriptor 0 is connected to the

1062
00:39:35,920 --> 00:39:37,760
console input and its file

1063
00:39:37,760 --> 00:39:40,560
descriptive 1 is connected to the

1064
00:39:40,560 --> 00:39:42,320
console output and that's why i was able

1065
00:39:42,320 --> 00:39:43,839
to type to

1066
00:39:43,839 --> 00:39:49,349
this copy program and see the output

1067
00:39:49,359 --> 00:39:50,720
of course you know these file

1068
00:39:50,720 --> 00:39:53,040
descriptors are expected the program

1069
00:39:53,040 --> 00:39:54,720
expects these file descriptors have been

1070
00:39:54,720 --> 00:39:56,000
previously opened and set

1071
00:39:56,000 --> 00:39:58,720
up by the shell for it and this this

1072
00:39:58,720 --> 00:39:59,200
zero

1073
00:39:59,200 --> 00:40:02,880
one file descriptors is a pervasive unix

1074
00:40:02,880 --> 00:40:04,720
convention many many unix programs

1075
00:40:04,720 --> 00:40:06,000
expect to read

1076
00:40:06,000 --> 00:40:08,800
and file descriptor one and read file

1077
00:40:08,800 --> 00:40:10,319
scripture zero and write to file

1078
00:40:10,319 --> 00:40:12,720
description one

1079
00:40:12,720 --> 00:40:14,960
um the second argument to read is a

1080
00:40:14,960 --> 00:40:17,040
pointer to some memory

1081
00:40:17,040 --> 00:40:18,720
um where the program is asking the

1082
00:40:18,720 --> 00:40:21,359
operating system to read data

1083
00:40:21,359 --> 00:40:22,960
into that address and memory so that's

1084
00:40:22,960 --> 00:40:24,560
the buff argument

1085
00:40:24,560 --> 00:40:28,079
and line 10 allocates 64 bytes of memory

1086
00:40:28,079 --> 00:40:31,599
on the stack per read to read into

1087
00:40:31,599 --> 00:40:33,200
and the third argument to read is the

1088
00:40:33,200 --> 00:40:35,200
maximum number of bytes that the program

1089
00:40:35,200 --> 00:40:36,319
wants to read

1090
00:40:36,319 --> 00:40:38,800
and the size of buff says just 60

1091
00:40:38,800 --> 00:40:39,359
maximum

1092
00:40:39,359 --> 00:40:42,400
64 buckets so the recall reads up to 64

1093
00:40:42,400 --> 00:40:44,240
bytes from whatever

1094
00:40:44,240 --> 00:40:46,000
is connected to file descriptor zero and

1095
00:40:46,000 --> 00:40:48,720
that was my terminal in this example

1096
00:40:48,720 --> 00:40:51,359
the return value from read it either

1097
00:40:51,359 --> 00:40:51,839
repeat

1098
00:40:51,839 --> 00:40:53,599
it which may return the number of bytes

1099
00:40:53,599 --> 00:40:54,960
read

1100
00:40:54,960 --> 00:40:58,000
which would be six in the case of

1101
00:40:58,000 --> 00:41:01,119
me typing xyz y um

1102
00:41:01,119 --> 00:41:02,960
lead might be reading from a file if it

1103
00:41:02,960 --> 00:41:04,319
gets to the end of the file there's no

1104
00:41:04,319 --> 00:41:07,119
more bytes read will return zero

1105
00:41:07,119 --> 00:41:09,359
i know some other error occurred like

1106
00:41:09,359 --> 00:41:11,359
the file descriptor doesn't exist

1107
00:41:11,359 --> 00:41:14,640
read may return minus one and so

1108
00:41:14,640 --> 00:41:16,560
in many of these examples like on line

1109
00:41:16,560 --> 00:41:18,240
16 there

1110
00:41:18,240 --> 00:41:21,119
i don't my example code doesn't check

1111
00:41:21,119 --> 00:41:23,440
system call returns for errors

1112
00:41:23,440 --> 00:41:25,839
um but you should be more careful than

1113
00:41:25,839 --> 00:41:27,280
me um

1114
00:41:27,280 --> 00:41:29,520
uh the you should figure out how system

1115
00:41:29,520 --> 00:41:31,520
calls reflect errors is usually a minus

1116
00:41:31,520 --> 00:41:33,119
one return value

1117
00:41:33,119 --> 00:41:35,760
and check all system call returns for

1118
00:41:35,760 --> 00:41:37,200
errors

1119
00:41:37,200 --> 00:41:39,440
and if if you want to know what the

1120
00:41:39,440 --> 00:41:41,119
system call arguments and return values

1121
00:41:41,119 --> 00:41:42,800
are there's a table and

1122
00:41:42,800 --> 00:41:45,200
i think chapter 2 in the book that

1123
00:41:45,200 --> 00:41:47,599
explains all of the xv6

1124
00:41:47,599 --> 00:41:50,800
system call arguments and

1125
00:41:50,800 --> 00:41:54,079
return values the question regarding the

1126
00:41:54,079 --> 00:41:57,119
resist call what if we set the max read

1127
00:41:57,119 --> 00:41:57,839
bytes to

1128
00:41:57,839 --> 00:42:00,720
size of buff to one plus size of buff or

1129
00:42:00,720 --> 00:42:01,359
bigger

1130
00:42:01,359 --> 00:42:02,640
so what if we try to read more than the

1131
00:42:02,640 --> 00:42:04,560
size yeah then if there was

1132
00:42:04,560 --> 00:42:08,000
65 bytes to read then the operating

1133
00:42:08,000 --> 00:42:09,200
system would happily

1134
00:42:09,200 --> 00:42:12,560
we'll just copy those 65 bytes

1135
00:42:12,560 --> 00:42:15,599
to the memory that you provide and of

1136
00:42:15,599 --> 00:42:16,160
course

1137
00:42:16,160 --> 00:42:17,599
there's something else on the stack up

1138
00:42:17,599 --> 00:42:20,079
there maybe the return program encounter

1139
00:42:20,079 --> 00:42:21,520
or an argument or something

1140
00:42:21,520 --> 00:42:24,319
and so if you pass 65 then you're

1141
00:42:24,319 --> 00:42:25,680
inviting the colonel to

1142
00:42:25,680 --> 00:42:28,960
write junk um to an unexpected place in

1143
00:42:28,960 --> 00:42:30,240
your stack

1144
00:42:30,240 --> 00:42:32,880
and so that's a bug and it may cause you

1145
00:42:32,880 --> 00:42:34,240
for him to crash

1146
00:42:34,240 --> 00:42:37,280
or do something else unexpected um

1147
00:42:37,280 --> 00:42:38,960
so as a programmer you're you have to be

1148
00:42:38,960 --> 00:42:40,720
careful here there's nobody

1149
00:42:40,720 --> 00:42:42,319
writing in c with these kind of

1150
00:42:42,319 --> 00:42:44,800
interfaces there's

1151
00:42:44,800 --> 00:42:47,359
it's very very easy to write code that

1152
00:42:47,359 --> 00:42:49,119
the compiler is happy with and will run

1153
00:42:49,119 --> 00:42:49,440
but

1154
00:42:49,440 --> 00:42:53,190
absolutely does the wrong thing

1155
00:42:53,200 --> 00:42:56,560
so that's too bad but um that's the way

1156
00:42:56,560 --> 00:43:00,470
it is

1157
00:43:00,480 --> 00:43:03,760
okay uh one thing to note is that this

1158
00:43:03,760 --> 00:43:05,440
copy program and indeed the read and

1159
00:43:05,440 --> 00:43:06,560
write system calls

1160
00:43:06,560 --> 00:43:08,400
they don't care about the format of data

1161
00:43:08,400 --> 00:43:09,839
they're reading or writing

1162
00:43:09,839 --> 00:43:11,760
they just read them write and read and

1163
00:43:11,760 --> 00:43:14,000
write and this copy program

1164
00:43:14,000 --> 00:43:16,160
just deal with 8-bit bytes with streams

1165
00:43:16,160 --> 00:43:18,560
of 8-bit bytes

1166
00:43:18,560 --> 00:43:20,560
how you interpret them is totally up to

1167
00:43:20,560 --> 00:43:23,520
the application so the application maybe

1168
00:43:23,520 --> 00:43:26,160
parse these as data records or as c

1169
00:43:26,160 --> 00:43:28,880
source code or who knows what

1170
00:43:28,880 --> 00:43:32,640
the operating system um

1171
00:43:32,640 --> 00:43:34,560
it only thinks in terms of a stream of

1172
00:43:34,560 --> 00:43:36,240
8-bit bytes

1173
00:43:36,240 --> 00:43:39,200
okay so copy assume this code my copy

1174
00:43:39,200 --> 00:43:40,319
program assumed that the file

1175
00:43:40,319 --> 00:43:42,160
descriptors were already set up

1176
00:43:42,160 --> 00:43:44,560
um but we need to we need to have a way

1177
00:43:44,560 --> 00:43:46,240
to create file descriptors

1178
00:43:46,240 --> 00:43:47,839
and the most straightforward way to do

1179
00:43:47,839 --> 00:43:50,079
that is um

1180
00:43:50,079 --> 00:43:52,079
with the open system call and so here's

1181
00:43:52,079 --> 00:43:54,319
the source for a program that

1182
00:43:54,319 --> 00:43:58,230
called open that

1183
00:43:58,240 --> 00:44:00,720
uses the open system call a question

1184
00:44:00,720 --> 00:44:01,599
from the chat

1185
00:44:01,599 --> 00:44:07,109
what do you mean by a stream of bytes

1186
00:44:07,119 --> 00:44:10,480
i i i just mean that if a file contains

1187
00:44:10,480 --> 00:44:12,160
a bunch of bytes

1188
00:44:12,160 --> 00:44:14,640
then read and successive yes building a

1189
00:44:14,640 --> 00:44:16,800
file contains a million bytes

1190
00:44:16,800 --> 00:44:19,440
if you make a sequence of recalls each

1191
00:44:19,440 --> 00:44:21,359
for 100 bytes

1192
00:44:21,359 --> 00:44:22,800
it'll just read the first hundred bytes

1193
00:44:22,800 --> 00:44:24,000
and then the second hundred bytes and

1194
00:44:24,000 --> 00:44:24,480
then

1195
00:44:24,480 --> 00:44:27,839
the third hundred bytes um

1196
00:44:27,839 --> 00:44:31,910
that's all i mean

1197
00:44:31,920 --> 00:44:34,880
all right so this program um called open

1198
00:44:34,880 --> 00:44:36,880
first i'll run it for you

1199
00:44:36,880 --> 00:44:40,079
what it does is uh opens creates a new

1200
00:44:40,079 --> 00:44:42,480
file called output.txt and then writes

1201
00:44:42,480 --> 00:44:43,200
some

1202
00:44:43,200 --> 00:44:45,839
bytes to it and then it finishes so we

1203
00:44:45,839 --> 00:44:47,440
don't see anything because it

1204
00:44:47,440 --> 00:44:49,200
broke data to this file it opened but we

1205
00:44:49,200 --> 00:44:52,480
can look at this output.txt file that it

1206
00:44:52,480 --> 00:44:53,440
created

1207
00:44:53,440 --> 00:44:56,640
and see the ooo that it

1208
00:44:56,640 --> 00:45:00,400
wrote there so line 11 in the program is

1209
00:45:00,400 --> 00:45:02,960
makes the open system call gives it a

1210
00:45:02,960 --> 00:45:05,119
file name output.text and

1211
00:45:05,119 --> 00:45:08,079
the o underscore stuff um in the second

1212
00:45:08,079 --> 00:45:09,359
argument to open are

1213
00:45:09,359 --> 00:45:12,560
flags that tell the open system call

1214
00:45:12,560 --> 00:45:14,400
implementation in the kernel that we'd

1215
00:45:14,400 --> 00:45:16,480
like to create a file with its name

1216
00:45:16,480 --> 00:45:19,200
and that we're going to write it open

1217
00:45:19,200 --> 00:45:20,880
returns a newly allocated file

1218
00:45:20,880 --> 00:45:23,589
descriptor

1219
00:45:23,599 --> 00:45:25,040
and the file the script is just a small

1220
00:45:25,040 --> 00:45:26,640
number it's probably two or three or

1221
00:45:26,640 --> 00:45:28,560
four or something

1222
00:45:28,560 --> 00:45:29,760
and then we pass that same file

1223
00:45:29,760 --> 00:45:32,160
descriptor to write along with a buffer

1224
00:45:32,160 --> 00:45:35,200
and a number of bytes to write that

1225
00:45:35,200 --> 00:45:37,119
writes data to

1226
00:45:37,119 --> 00:45:39,440
the file that the file descriptor refers

1227
00:45:39,440 --> 00:45:41,440
to

1228
00:45:41,440 --> 00:45:42,880
what that file descriptor is actually

1229
00:45:42,880 --> 00:45:45,680
doing is indexing into a little table

1230
00:45:45,680 --> 00:45:47,520
inside the kernel the kernel maintains

1231
00:45:47,520 --> 00:45:48,880
state for each

1232
00:45:48,880 --> 00:45:50,720
process that's running each program that

1233
00:45:50,720 --> 00:45:52,640
you run and among other things the

1234
00:45:52,640 --> 00:45:55,040
kernel remembers a table for every

1235
00:45:55,040 --> 00:45:57,520
running process of index by file

1236
00:45:57,520 --> 00:45:59,040
descriptors

1237
00:45:59,040 --> 00:46:01,280
and the table sort of tells the kernel

1238
00:46:01,280 --> 00:46:02,720
what each file descriptor

1239
00:46:02,720 --> 00:46:08,470
refers to

1240
00:46:08,480 --> 00:46:10,880
a critical point is that each process

1241
00:46:10,880 --> 00:46:12,240
has its own

1242
00:46:12,240 --> 00:46:15,280
sort of space of file descriptors so uh

1243
00:46:15,280 --> 00:46:16,720
before running two different

1244
00:46:16,720 --> 00:46:18,400
processes two different programs and

1245
00:46:18,400 --> 00:46:20,560
different processes and they both open a

1246
00:46:20,560 --> 00:46:22,079
file they may actually get the same

1247
00:46:22,079 --> 00:46:24,319
number back as a file descriptor

1248
00:46:24,319 --> 00:46:25,920
but because the kernel maintains a

1249
00:46:25,920 --> 00:46:27,839
separate file descriptor for each

1250
00:46:27,839 --> 00:46:28,960
process

1251
00:46:28,960 --> 00:46:31,280
the same file descriptor number may

1252
00:46:31,280 --> 00:46:32,960
refer to different files

1253
00:46:32,960 --> 00:46:36,950
in different processes

1254
00:46:36,960 --> 00:46:38,560
any questions about open about this

1255
00:46:38,560 --> 00:46:40,079
little program

1256
00:46:40,079 --> 00:46:41,599
yeah we got a question in the chat a

1257
00:46:41,599 --> 00:46:43,200
question from someone not familiar with

1258
00:46:43,200 --> 00:46:43,920
c

1259
00:46:43,920 --> 00:46:46,079
uh how are these files being described

1260
00:46:46,079 --> 00:46:47,280
different from normalc

1261
00:46:47,280 --> 00:46:49,599
programs is it because we're only using

1262
00:46:49,599 --> 00:46:51,920
kernel calls i.e couldn't we also

1263
00:46:51,920 --> 00:46:59,349
open or write a file in python

1264
00:46:59,359 --> 00:47:02,400
i don't think i understand that it's a c

1265
00:47:02,400 --> 00:47:08,829
program that's opening and writing a

1266
00:47:08,839 --> 00:47:12,390
file

1267
00:47:12,400 --> 00:47:15,839
um okay

1268
00:47:15,839 --> 00:47:20,549
i think i'm gonna move on um

1269
00:47:20,559 --> 00:47:23,670
all right so

1270
00:47:23,680 --> 00:47:26,240
you um ask what actually happens when uh

1271
00:47:26,240 --> 00:47:26,880
maybe

1272
00:47:26,880 --> 00:47:29,280
the question is whether someone is doing

1273
00:47:29,280 --> 00:47:30,079
it in c

1274
00:47:30,079 --> 00:47:31,760
any different than doing it in python

1275
00:47:31,760 --> 00:47:34,400
minus the syntax

1276
00:47:34,400 --> 00:47:40,710
well it's it's not really um

1277
00:47:40,720 --> 00:47:44,319
there's certainly ways to um

1278
00:47:44,319 --> 00:47:47,680
python provides nice function calls for

1279
00:47:47,680 --> 00:47:48,240
opening

1280
00:47:48,240 --> 00:47:51,200
and doing all these things or opening

1281
00:47:51,200 --> 00:47:52,000
files for example

1282
00:47:52,000 --> 00:47:54,720
in reading writing files um they're sort

1283
00:47:54,720 --> 00:47:56,240
of a layer of

1284
00:47:56,240 --> 00:47:57,599
they're higher somewhat higher level

1285
00:47:57,599 --> 00:47:59,839
functions typically um not you know

1286
00:47:59,839 --> 00:48:03,599
pointers to memory for example um

1287
00:48:03,599 --> 00:48:05,920
and python does more error checking for

1288
00:48:05,920 --> 00:48:08,000
you

1289
00:48:08,000 --> 00:48:09,760
but when you open a file in python or

1290
00:48:09,760 --> 00:48:11,920
write a file in python the

1291
00:48:11,920 --> 00:48:15,200
python calls you make boil down

1292
00:48:15,200 --> 00:48:19,750
to system calls just like these

1293
00:48:19,760 --> 00:48:25,670
is that a good answer

1294
00:48:25,680 --> 00:48:31,190
i think so all right

1295
00:48:31,200 --> 00:48:34,400
all right um all right i've been

1296
00:48:34,400 --> 00:48:39,150
over here talking to the uh

1297
00:48:39,160 --> 00:48:42,400
xv6s unix like

1298
00:48:42,400 --> 00:48:44,880
shell and the shells what people often

1299
00:48:44,880 --> 00:48:47,280
call the command line interface

1300
00:48:47,280 --> 00:48:49,920
as opposed to some more graphical user

1301
00:48:49,920 --> 00:48:52,400
interface

1302
00:48:52,400 --> 00:48:54,079
the shell turns if you haven't used the

1303
00:48:54,079 --> 00:48:56,160
cell the shell turns out to be

1304
00:48:56,160 --> 00:48:57,680
a pretty useful interface for things

1305
00:48:57,680 --> 00:49:01,359
like system management of unix systems

1306
00:49:01,359 --> 00:49:03,680
it provides a lot of utilities for uh

1307
00:49:03,680 --> 00:49:05,040
messing around with files

1308
00:49:05,040 --> 00:49:07,440
and for programming development and for

1309
00:49:07,440 --> 00:49:08,480
writing scripts

1310
00:49:08,480 --> 00:49:10,800
to do all these things so you saw me

1311
00:49:10,800 --> 00:49:12,319
before run

1312
00:49:12,319 --> 00:49:14,079
i just want to demonstrate a few shell

1313
00:49:14,079 --> 00:49:16,720
features ordinarily when you type things

1314
00:49:16,720 --> 00:49:19,520
um you're telling the shell to run a

1315
00:49:19,520 --> 00:49:21,440
program so when i type ls what that

1316
00:49:21,440 --> 00:49:22,319
means is

1317
00:49:22,319 --> 00:49:25,440
i'm asking the shell to run the program

1318
00:49:25,440 --> 00:49:27,839
whose name is ls and what that really

1319
00:49:27,839 --> 00:49:29,680
means is there's a file

1320
00:49:29,680 --> 00:49:31,760
in the file system called ls that

1321
00:49:31,760 --> 00:49:33,520
contains some instructions

1322
00:49:33,520 --> 00:49:35,760
some machine instructions and i'm asking

1323
00:49:35,760 --> 00:49:37,119
the shell to run

1324
00:49:37,119 --> 00:49:39,040
the instructions that are in the file

1325
00:49:39,040 --> 00:49:40,640
called ls

1326
00:49:40,640 --> 00:49:44,800
run ls now ls what it actually does is

1327
00:49:44,800 --> 00:49:46,319
get a listing of the files in the

1328
00:49:46,319 --> 00:49:47,920
current directory and you can see up

1329
00:49:47,920 --> 00:49:49,599
there on the fourth line

1330
00:49:49,599 --> 00:49:52,960
that among the other files that

1331
00:49:52,960 --> 00:49:55,680
ls says exists in this list is a file

1332
00:49:55,680 --> 00:49:56,000
called

1333
00:49:56,000 --> 00:49:58,880
ls which is in fact the file containing

1334
00:49:58,880 --> 00:50:02,230
the instructions i just ran

1335
00:50:02,240 --> 00:50:03,680
the shell does a few other things for

1336
00:50:03,680 --> 00:50:05,920
you other than running programs

1337
00:50:05,920 --> 00:50:08,720
it allows you to redirect io so for

1338
00:50:08,720 --> 00:50:11,040
example if i say ls greater than out

1339
00:50:11,040 --> 00:50:12,160
what that means is

1340
00:50:12,160 --> 00:50:14,079
i'm asking the shell to run the ls

1341
00:50:14,079 --> 00:50:16,640
command but with its output redirected

1342
00:50:16,640 --> 00:50:17,680
to the file called

1343
00:50:17,680 --> 00:50:20,880
out and i run ls

1344
00:50:20,880 --> 00:50:22,559
we don't see any output because the

1345
00:50:22,559 --> 00:50:24,880
output all went out

1346
00:50:24,880 --> 00:50:27,760
um now i can out contains a bunch of

1347
00:50:27,760 --> 00:50:28,480
data

1348
00:50:28,480 --> 00:50:32,240
um we could the cat command

1349
00:50:32,240 --> 00:50:34,720
reads a file and displays the contents

1350
00:50:34,720 --> 00:50:35,680
of the file so

1351
00:50:35,680 --> 00:50:38,160
i say cat out i'm just going to see now

1352
00:50:38,160 --> 00:50:40,000
the now this is the saved output

1353
00:50:40,000 --> 00:50:42,319
of ls you can also run a command like

1354
00:50:42,319 --> 00:50:44,319
grep and i can give it an argument x and

1355
00:50:44,319 --> 00:50:44,720
what

1356
00:50:44,720 --> 00:50:47,680
grep x is the grep command searches for

1357
00:50:47,680 --> 00:50:49,119
patterns

1358
00:50:49,119 --> 00:50:52,319
again um if i run grep

1359
00:50:52,319 --> 00:50:55,680
x it's going to search for lines of

1360
00:50:55,680 --> 00:50:56,559
input that contain

1361
00:50:56,559 --> 00:50:59,040
x i can redirect tell the shell to

1362
00:50:59,040 --> 00:51:01,599
redirect its input from the file out

1363
00:51:01,599 --> 00:51:04,000
in order to look for instances of x in

1364
00:51:04,000 --> 00:51:07,040
that saved ls output

1365
00:51:07,040 --> 00:51:09,920
and turns out there's three files um

1366
00:51:09,920 --> 00:51:10,800
whose names

1367
00:51:10,800 --> 00:51:13,990
contain x's

1368
00:51:14,000 --> 00:51:16,559
um we're going to spend a bunch of time

1369
00:51:16,559 --> 00:51:17,359
with the shell

1370
00:51:17,359 --> 00:51:21,839
um it the shell is sort of the most

1371
00:51:21,839 --> 00:51:22,960
traditional

1372
00:51:22,960 --> 00:51:25,839
um and fundamental interface to uh to

1373
00:51:25,839 --> 00:51:26,559
unix

1374
00:51:26,559 --> 00:51:28,880
because when units was first developed

1375
00:51:28,880 --> 00:51:30,240
all there was was simple terminal

1376
00:51:30,240 --> 00:51:32,480
interfaces like the one we're using

1377
00:51:32,480 --> 00:51:35,440
and the main use of unix originally was

1378
00:51:35,440 --> 00:51:35,839
time

1379
00:51:35,839 --> 00:51:37,520
sharing a bunch of people logging into

1380
00:51:37,520 --> 00:51:40,480
the same machine much like athena

1381
00:51:40,480 --> 00:51:44,230
and talking to shells

1382
00:51:44,240 --> 00:51:46,720
a question about system calls and the

1383
00:51:46,720 --> 00:51:47,680
compiler

1384
00:51:47,680 --> 00:51:49,680
how does a compiler handle system calls

1385
00:51:49,680 --> 00:51:51,680
does assembly generated make a procedure

1386
00:51:51,680 --> 00:51:53,520
call to some code segment

1387
00:51:53,520 --> 00:51:56,960
uh defined by the operating system

1388
00:51:56,960 --> 00:51:58,960
uh there's a special risk five

1389
00:51:58,960 --> 00:52:01,119
instruction that a program can call that

1390
00:52:01,119 --> 00:52:02,800
transfers control into the kernel

1391
00:52:02,800 --> 00:52:05,359
so indeed when you write c code that

1392
00:52:05,359 --> 00:52:06,720
makes the system called like open or

1393
00:52:06,720 --> 00:52:08,480
right

1394
00:52:08,480 --> 00:52:10,240
i mean technically what actually happens

1395
00:52:10,240 --> 00:52:12,000
is open is a c

1396
00:52:12,000 --> 00:52:15,119
function in the c library

1397
00:52:15,119 --> 00:52:17,599
but the instructions in that function

1398
00:52:17,599 --> 00:52:18,480
are really

1399
00:52:18,480 --> 00:52:20,480
machine instructions it's not you know

1400
00:52:20,480 --> 00:52:21,680
open

1401
00:52:21,680 --> 00:52:23,119
the open function that we're calling

1402
00:52:23,119 --> 00:52:25,040
isn't a c function it's implemented

1403
00:52:25,040 --> 00:52:25,920
assembler

1404
00:52:25,920 --> 00:52:30,230
and the assembly code

1405
00:52:30,240 --> 00:52:32,079
consists of this special instruction

1406
00:52:32,079 --> 00:52:34,000
it's actually called e-call

1407
00:52:34,000 --> 00:52:35,839
on the risk 5 the special instruction

1408
00:52:35,839 --> 00:52:37,520
that transfers control

1409
00:52:37,520 --> 00:52:40,000
into the kernel and then the kernel

1410
00:52:40,000 --> 00:52:40,720
looks at the

1411
00:52:40,720 --> 00:52:42,559
process's memory and registers to figure

1412
00:52:42,559 --> 00:52:44,160
out what the

1413
00:52:44,160 --> 00:52:50,470
arguments were

1414
00:52:50,480 --> 00:52:53,599
all right um the next example i want to

1415
00:52:53,599 --> 00:52:54,800
look at is

1416
00:52:54,800 --> 00:52:58,319
an example program that calls fork

1417
00:52:58,319 --> 00:53:01,359
to create a new process um

1418
00:53:01,359 --> 00:53:04,640
so this is the very simple use of fork

1419
00:53:04,640 --> 00:53:05,760
at line 12

1420
00:53:05,760 --> 00:53:08,640
we're calling fork and what fork does is

1421
00:53:08,640 --> 00:53:10,000
creates a copy

1422
00:53:10,000 --> 00:53:12,559
of the memory of instructions and data

1423
00:53:12,559 --> 00:53:13,359
of the

1424
00:53:13,359 --> 00:53:14,960
calling process now we have two

1425
00:53:14,960 --> 00:53:16,800
processes with identical

1426
00:53:16,800 --> 00:53:19,440
memory fork the fork system called

1427
00:53:19,440 --> 00:53:20,160
returns

1428
00:53:20,160 --> 00:53:23,119
in both processes in the original

1429
00:53:23,119 --> 00:53:24,319
process

1430
00:53:24,319 --> 00:53:26,640
the fork system call returns the process

1431
00:53:26,640 --> 00:53:29,040
id which is a

1432
00:53:29,040 --> 00:53:32,400
an integer greater than zero for in the

1433
00:53:32,400 --> 00:53:33,280
original process

1434
00:53:33,280 --> 00:53:35,280
fork returns the process id of the newly

1435
00:53:35,280 --> 00:53:36,640
created process

1436
00:53:36,640 --> 00:53:38,800
and in the newly created process fork

1437
00:53:38,800 --> 00:53:40,000
returns

1438
00:53:40,000 --> 00:53:42,960
zero so we sort of break even though the

1439
00:53:42,960 --> 00:53:45,520
processes of identical memory

1440
00:53:45,520 --> 00:53:48,480
can break the symmetry of old versus new

1441
00:53:48,480 --> 00:53:50,880
process by the return value from fork

1442
00:53:50,880 --> 00:53:53,839
then in line 16 you can see code that

1443
00:53:53,839 --> 00:53:54,880
checks and says if

1444
00:53:54,880 --> 00:53:57,040
process id is equal 0 must be the child

1445
00:53:57,040 --> 00:54:00,400
we must now be running in the child

1446
00:54:00,400 --> 00:54:01,920
the course is two processes and in the

1447
00:54:01,920 --> 00:54:03,680
other process

1448
00:54:03,680 --> 00:54:05,119
in the calling process which is usually

1449
00:54:05,119 --> 00:54:07,200
called the parent the process id is

1450
00:54:07,200 --> 00:54:09,280
greater than zero

1451
00:54:09,280 --> 00:54:11,599
so the child will print child and the

1452
00:54:11,599 --> 00:54:14,480
parent a good parent

1453
00:54:14,480 --> 00:54:17,359
and then they'll both exit so when i run

1454
00:54:17,359 --> 00:54:19,359
for

1455
00:54:19,359 --> 00:54:22,710
um here's what we get

1456
00:54:22,720 --> 00:54:25,440
so it may look like garbage but what's

1457
00:54:25,440 --> 00:54:26,800
actually happening is that

1458
00:54:26,800 --> 00:54:28,559
after the fork both of these processes

1459
00:54:28,559 --> 00:54:30,079
are running they're both running at the

1460
00:54:30,079 --> 00:54:31,040
same time

1461
00:54:31,040 --> 00:54:34,160
um and qmu is actually emulating a multi

1462
00:54:34,160 --> 00:54:36,960
a multi-core microprocessor for me so

1463
00:54:36,960 --> 00:54:39,200
they really are running

1464
00:54:39,200 --> 00:54:40,559
at the very same time and so when they

1465
00:54:40,559 --> 00:54:42,559
produce output they're producing each

1466
00:54:42,559 --> 00:54:44,400
byte of their output at the same time as

1467
00:54:44,400 --> 00:54:45,200
the other process

1468
00:54:45,200 --> 00:54:46,640
is producing the corresponding byte of

1469
00:54:46,640 --> 00:54:48,480
its output so the outputs and the two

1470
00:54:48,480 --> 00:54:50,839
processes are

1471
00:54:50,839 --> 00:54:53,200
interleaved um you can see that they're

1472
00:54:53,200 --> 00:54:54,720
both typing f

1473
00:54:54,720 --> 00:54:56,319
um they're both going to type fork

1474
00:54:56,319 --> 00:54:57,760
returned

1475
00:54:57,760 --> 00:54:59,440
um so you can see the f from both of

1476
00:54:59,440 --> 00:55:00,880
them and the o for both of them and they

1477
00:55:00,880 --> 00:55:02,880
are for both them and so on

1478
00:55:02,880 --> 00:55:05,920
and one of them uh you can see the zero

1479
00:55:05,920 --> 00:55:07,839
at the end of that first line is

1480
00:55:07,839 --> 00:55:10,799
in the child fourth return zero um and

1481
00:55:10,799 --> 00:55:12,480
i'm guessing that the

1482
00:55:12,480 --> 00:55:15,359
in the parent four return 19 that is the

1483
00:55:15,359 --> 00:55:16,079
child's

1484
00:55:16,079 --> 00:55:18,480
process id is nineteen under exit six

1485
00:55:18,480 --> 00:55:20,400
that basically means the 19th process

1486
00:55:20,400 --> 00:55:20,960
that

1487
00:55:20,960 --> 00:55:23,440
was created since boot um and then one

1488
00:55:23,440 --> 00:55:24,400
of them prints

1489
00:55:24,400 --> 00:55:27,520
child and you can see the ch ild

1490
00:55:27,520 --> 00:55:29,359
and interleave with that is the other

1491
00:55:29,359 --> 00:55:30,640
one pretty parent

1492
00:55:30,640 --> 00:55:34,000
so this is sort of a silly use

1493
00:55:34,000 --> 00:55:36,559
of fork but we can see so vividly in

1494
00:55:36,559 --> 00:55:37,599
this output that

1495
00:55:37,599 --> 00:55:40,079
it's created two processes that are and

1496
00:55:40,079 --> 00:55:41,200
both of them are running

1497
00:55:41,200 --> 00:55:42,799
we're fork returning both processes and

1498
00:55:42,799 --> 00:55:44,720
they're both running

1499
00:55:44,720 --> 00:55:46,720
but also note that one printed child and

1500
00:55:46,720 --> 00:55:48,480
the other parent

1501
00:55:48,480 --> 00:55:50,559
so it's important that fork returns

1502
00:55:50,559 --> 00:55:52,000
differently

1503
00:55:52,000 --> 00:55:59,589
in the two processes

1504
00:55:59,599 --> 00:56:02,559
the question is the child process as a

1505
00:56:02,559 --> 00:56:04,400
result of fork always identical to the

1506
00:56:04,400 --> 00:56:05,839
parent process or could they be

1507
00:56:05,839 --> 00:56:08,390
different

1508
00:56:08,400 --> 00:56:11,510
i um

1509
00:56:11,520 --> 00:56:14,799
in xv6 are identical

1510
00:56:14,799 --> 00:56:17,200
except for the return value from fork

1511
00:56:17,200 --> 00:56:18,559
you know so the instructions are the

1512
00:56:18,559 --> 00:56:20,799
same the data's the same the stack is

1513
00:56:20,799 --> 00:56:24,160
is the same um and also both

1514
00:56:24,160 --> 00:56:27,040
processes you know the processes are

1515
00:56:27,040 --> 00:56:27,760
copies and

1516
00:56:27,760 --> 00:56:30,160
they both have their own separate

1517
00:56:30,160 --> 00:56:32,000
address spaces that is

1518
00:56:32,000 --> 00:56:33,920
you know they both have they both think

1519
00:56:33,920 --> 00:56:35,599
that their memory starts at zero and

1520
00:56:35,599 --> 00:56:37,359
goes on up from there

1521
00:56:37,359 --> 00:56:40,880
um but but it's different it's different

1522
00:56:40,880 --> 00:56:44,960
different memory um for the two of them

1523
00:56:44,960 --> 00:56:46,640
in a more sophisticated operating system

1524
00:56:46,640 --> 00:56:48,880
there are some details which we

1525
00:56:48,880 --> 00:56:50,400
definitely don't care about

1526
00:56:50,400 --> 00:56:53,359
um that may occasionally cause parent

1527
00:56:53,359 --> 00:56:55,119
and child to differ but in xv6 they're

1528
00:56:55,119 --> 00:56:58,240
the same except the return value

1529
00:56:58,240 --> 00:57:00,079
so the memory is the same in addition

1530
00:57:00,079 --> 00:57:02,000
the

1531
00:57:02,000 --> 00:57:05,200
file descriptor table is copied

1532
00:57:05,200 --> 00:57:09,599
so if the parent had some files open

1533
00:57:09,599 --> 00:57:12,240
then the child sees the same set of file

1534
00:57:12,240 --> 00:57:14,079
descriptors

1535
00:57:14,079 --> 00:57:16,079
although the child is seeing them in a

1536
00:57:16,079 --> 00:57:17,119
copy

1537
00:57:17,119 --> 00:57:18,960
of the table of file descriptor

1538
00:57:18,960 --> 00:57:21,440
information

1539
00:57:21,440 --> 00:57:22,960
and so we'll see in a moment that it's

1540
00:57:22,960 --> 00:57:24,720
quite important that

1541
00:57:24,720 --> 00:57:27,440
fork copies the table of open file

1542
00:57:27,440 --> 00:57:31,349
descriptors as well as the memory

1543
00:57:31,359 --> 00:57:34,960
okay so uh port creates a new process

1544
00:57:34,960 --> 00:57:35,520
but

1545
00:57:35,520 --> 00:57:38,960
when we run stuff in the shell um

1546
00:57:38,960 --> 00:57:40,880
the shell indeed creates a new process

1547
00:57:40,880 --> 00:57:43,440
to run each command that you type

1548
00:57:43,440 --> 00:57:44,799
but it needs to actually run the command

1549
00:57:44,799 --> 00:57:47,040
in it so you know if i type ls

1550
00:57:47,040 --> 00:57:49,599
we need to the shell forks to create a

1551
00:57:49,599 --> 00:57:51,200
process to run ls but

1552
00:57:51,200 --> 00:57:53,920
there needs to be some way for this for

1553
00:57:53,920 --> 00:57:54,640
that

1554
00:57:54,640 --> 00:57:55,920
new process actually run the

1555
00:57:55,920 --> 00:57:58,480
instructions from the ls program

1556
00:57:58,480 --> 00:58:00,000
to load those instructions from the file

1557
00:58:00,000 --> 00:58:02,240
called lx um

1558
00:58:02,240 --> 00:58:04,000
and the example program i mean i'll show

1559
00:58:04,000 --> 00:58:05,280
you in a minute

1560
00:58:05,280 --> 00:58:07,119
uh uses echo echo is a very simple

1561
00:58:07,119 --> 00:58:09,040
command that

1562
00:58:09,040 --> 00:58:10,640
just takes whatever arguments you pass

1563
00:58:10,640 --> 00:58:14,000
to it and writes them into its output

1564
00:58:14,000 --> 00:58:15,839
and i prepared for you a program called

1565
00:58:15,839 --> 00:58:21,270
exec

1566
00:58:21,280 --> 00:58:24,319
um which

1567
00:58:24,319 --> 00:58:28,000
uh run which makes the exact system

1568
00:58:28,000 --> 00:58:28,799
called which

1569
00:58:28,799 --> 00:58:31,680
replaces the calling process with the

1570
00:58:31,680 --> 00:58:33,119
instructions read from a

1571
00:58:33,119 --> 00:58:37,359
particular from the file you specify and

1572
00:58:37,359 --> 00:58:39,200
loads the instructions from that file

1573
00:58:39,200 --> 00:58:41,040
over the current process sort of discard

1574
00:58:41,040 --> 00:58:42,960
it discarding its current memory

1575
00:58:42,960 --> 00:58:44,960
and then starts executing those

1576
00:58:44,960 --> 00:58:46,160
instructions so

1577
00:58:46,160 --> 00:58:48,640
the call to exec the system call exec on

1578
00:58:48,640 --> 00:58:52,549
line 12.

1579
00:58:52,559 --> 00:58:54,000
it's going to have the effect of the

1580
00:58:54,000 --> 00:58:55,200
operating system loading the

1581
00:58:55,200 --> 00:58:56,960
instructions from the file called

1582
00:58:56,960 --> 00:58:59,520
echo into the current process sort of

1583
00:58:59,520 --> 00:59:00,799
replacing

1584
00:59:00,799 --> 00:59:03,040
the memory of the current process and

1585
00:59:03,040 --> 00:59:04,000
then starting to

1586
00:59:04,000 --> 00:59:06,880
execute uh those instructions and in

1587
00:59:06,880 --> 00:59:08,720
addition you can pass arguments command

1588
00:59:08,720 --> 00:59:10,000
line arguments echo

1589
00:59:10,000 --> 00:59:12,720
exec allows you to pass an array of

1590
00:59:12,720 --> 00:59:14,559
command line arguments

1591
00:59:14,559 --> 00:59:17,040
with just an array of pointers and see

1592
00:59:17,040 --> 00:59:17,680
line 10

1593
00:59:17,680 --> 00:59:20,319
set sets up an array of character

1594
00:59:20,319 --> 00:59:22,799
pointers which are essentially strings

1595
00:59:22,799 --> 00:59:25,839
and initializes that array to be

1596
00:59:25,839 --> 00:59:29,440
to contain the strings echo this is echo

1597
00:59:29,440 --> 00:59:31,680
and that's equivalent to calling running

1598
00:59:31,680 --> 00:59:33,280
the act with command with

1599
00:59:33,280 --> 00:59:35,520
the three arguments this is echo and so

1600
00:59:35,520 --> 00:59:38,870
when i want exec

1601
00:59:38,880 --> 00:59:41,920
indeed um i see this output this is echo

1602
00:59:41,920 --> 00:59:42,480
but

1603
00:59:42,480 --> 00:59:44,160
even though i ran the exact command the

1604
00:59:44,160 --> 00:59:47,040
exact program what the exact program

1605
00:59:47,040 --> 00:59:48,000
does is call it

1606
00:59:48,000 --> 00:59:50,160
the exact system call to replace itself

1607
00:59:50,160 --> 00:59:52,160
with echo and so it was really the echo

1608
00:59:52,160 --> 00:59:53,280
program

1609
00:59:53,280 --> 00:59:58,549
um producing this output

1610
00:59:58,559 --> 01:00:01,040
and uh something about the exact system

1611
01:00:01,040 --> 01:00:01,680
call that's

1612
01:00:01,680 --> 01:00:04,559
important for us is that um it exec

1613
01:00:04,559 --> 01:00:05,440
preserves

1614
01:00:05,440 --> 01:00:08,480
the current table of file descriptors so

1615
01:00:08,480 --> 01:00:10,720
whatever files descriptor zero one two

1616
01:00:10,720 --> 01:00:13,359
etc were referred to before exec they

1617
01:00:13,359 --> 01:00:15,040
refer to the same thing

1618
01:00:15,040 --> 01:00:18,319
in this new program whose instructions

1619
01:00:18,319 --> 01:00:20,160
we've loaded

1620
01:00:20,160 --> 01:00:22,400
another point is ordinarily exec does

1621
01:00:22,400 --> 01:00:23,520
not return

1622
01:00:23,520 --> 01:00:27,119
because exec replaces the current

1623
01:00:27,119 --> 01:00:29,520
is memory entirely um there's nothing

1624
01:00:29,520 --> 01:00:31,040
for exec to return to

1625
01:00:31,040 --> 01:00:34,000
so exact you know reads the instructions

1626
01:00:34,000 --> 01:00:35,280
from that file and executes them and

1627
01:00:35,280 --> 01:00:36,319
then that's it

1628
01:00:36,319 --> 01:00:38,960
um the only time exec returns is if some

1629
01:00:38,960 --> 01:00:40,319
error occurred

1630
01:00:40,319 --> 01:00:42,240
that prevented the operating system from

1631
01:00:42,240 --> 01:00:43,839
running that program for you

1632
01:00:43,839 --> 01:00:45,760
so for example if the program doesn't

1633
01:00:45,760 --> 01:00:47,520
exist at all

1634
01:00:47,520 --> 01:00:49,920
since the exec can't find a file called

1635
01:00:49,920 --> 01:00:51,359
echo for example

1636
01:00:51,359 --> 01:00:55,440
then exec would return negative one to

1637
01:00:55,440 --> 01:00:58,079
signal that you know something i'm wrong

1638
01:00:58,079 --> 01:00:58,559
it couldn't

1639
01:00:58,559 --> 01:01:00,240
couldn't find a file so ordinarily exact

1640
01:01:00,240 --> 01:01:03,200
does not return it only returns if

1641
01:01:03,200 --> 01:01:06,079
um the kernel couldn't actually run the

1642
01:01:06,079 --> 01:01:10,319
file for you

1643
01:01:10,319 --> 01:01:13,119
questions about exec one question in the

1644
01:01:13,119 --> 01:01:14,480
chat is what is the last

1645
01:01:14,480 --> 01:01:18,789
zero for in arc v

1646
01:01:18,799 --> 01:01:22,000
it marks the end of the array um

1647
01:01:22,000 --> 01:01:25,839
c is so low level that

1648
01:01:25,839 --> 01:01:29,599
there's no the c array

1649
01:01:29,599 --> 01:01:33,200
scheme doesn't have a way

1650
01:01:33,200 --> 01:01:36,240
for code to find out how long the array

1651
01:01:36,240 --> 01:01:37,440
is

1652
01:01:37,440 --> 01:01:40,960
and so to tell the kernel that um

1653
01:01:40,960 --> 01:01:42,799
you know we meant that the array

1654
01:01:42,799 --> 01:01:44,720
contains echo this is echo and nothing

1655
01:01:44,720 --> 01:01:45,520
more

1656
01:01:45,520 --> 01:01:48,640
um we put a zero as the last

1657
01:01:48,640 --> 01:01:51,599
strip as the last pointer each of those

1658
01:01:51,599 --> 01:01:53,359
strings in double quotes is actually a

1659
01:01:53,359 --> 01:01:55,359
pointer to some memory that contains

1660
01:01:55,359 --> 01:01:56,640
those bytes

1661
01:01:56,640 --> 01:01:59,520
that fifth element of the array is a

1662
01:01:59,520 --> 01:02:01,200
pointer whose value is zero

1663
01:02:01,200 --> 01:02:02,880
the convention is that a pointer whose

1664
01:02:02,880 --> 01:02:04,640
value is zero or what's called a null

1665
01:02:04,640 --> 01:02:07,200
pointer um

1666
01:02:07,200 --> 01:02:11,520
sort of signifies nothing um with it

1667
01:02:11,520 --> 01:02:14,480
you know we're done and so the code in

1668
01:02:14,480 --> 01:02:15,599
the kernel has actually

1669
01:02:15,599 --> 01:02:17,119
walks through this array until it finds

1670
01:02:17,119 --> 01:02:18,880
the element

1671
01:02:18,880 --> 01:02:24,710
whose value is zero

1672
01:02:24,720 --> 01:02:28,240
okay um right so this is how a program

1673
01:02:28,240 --> 01:02:29,760
can replace itself

1674
01:02:29,760 --> 01:02:32,160
um with another program from a file but

1675
01:02:32,160 --> 01:02:33,680
actually when we run stuff in the shell

1676
01:02:33,680 --> 01:02:35,680
like echo abc

1677
01:02:35,680 --> 01:02:38,799
or ls or anything else um

1678
01:02:38,799 --> 01:02:40,400
we don't want to replace the shell we

1679
01:02:40,400 --> 01:02:41,839
don't want to have the shell just

1680
01:02:41,839 --> 01:02:45,200
call exact um because that would replace

1681
01:02:45,200 --> 01:02:46,720
the shell with the echo command and then

1682
01:02:46,720 --> 01:02:48,160
when echo exited

1683
01:02:48,160 --> 01:02:50,720
that would be it you know we don't want

1684
01:02:50,720 --> 01:02:52,240
echo to replace the shell so

1685
01:02:52,240 --> 01:02:54,960
what the shell actually does is fork and

1686
01:02:54,960 --> 01:02:56,640
then the child calls it zac

1687
01:02:56,640 --> 01:02:59,440
and that's an extremely common unix

1688
01:02:59,440 --> 01:03:00,160
idiom

1689
01:03:00,160 --> 01:03:03,119
these programs that um want to run a

1690
01:03:03,119 --> 01:03:04,960
program but regain control what they do

1691
01:03:04,960 --> 01:03:05,440
is call

1692
01:03:05,440 --> 01:03:08,160
fork and have the child call exact so

1693
01:03:08,160 --> 01:03:08,960
here's a

1694
01:03:08,960 --> 01:03:14,150
simple example this fork exact program

1695
01:03:14,160 --> 01:03:16,720
so in this program um called fork on

1696
01:03:16,720 --> 01:03:17,520
line 12

1697
01:03:17,520 --> 01:03:19,599
and the child started line 14 we call

1698
01:03:19,599 --> 01:03:21,280
exec much like before

1699
01:03:21,280 --> 01:03:24,640
the child process um

1700
01:03:24,640 --> 01:03:27,039
has to replace itself with the echo

1701
01:03:27,039 --> 01:03:28,640
command

1702
01:03:28,640 --> 01:03:31,599
and echo does this thing and then exits

1703
01:03:31,599 --> 01:03:33,119
and then the parent process regains

1704
01:03:33,119 --> 01:03:33,680
control

1705
01:03:33,680 --> 01:03:37,680
because um when the fork returns

1706
01:03:37,680 --> 01:03:39,119
the greater than zero value in the

1707
01:03:39,119 --> 01:03:40,559
parent process so the parent process

1708
01:03:40,559 --> 01:03:42,559
then continues to execute at 19

1709
01:03:42,559 --> 01:03:45,280
and unix provides a weight system called

1710
01:03:45,280 --> 01:03:45,680
line

1711
01:03:45,680 --> 01:03:48,559
20 for a process to wait for one of the

1712
01:03:48,559 --> 01:03:49,119
for a

1713
01:03:49,119 --> 01:03:51,760
child that it created with four because

1714
01:03:51,760 --> 01:03:53,280
when i run a command

1715
01:03:53,280 --> 01:03:56,480
um here on the command line

1716
01:03:56,480 --> 01:03:59,520
we want uh we want the shell to wait

1717
01:03:59,520 --> 01:04:01,760
for the command to finish before it

1718
01:04:01,760 --> 01:04:03,119
prints the prop again

1719
01:04:03,119 --> 01:04:04,799
before it prints this dollar sign prompt

1720
01:04:04,799 --> 01:04:06,559
asking me for more input

1721
01:04:06,559 --> 01:04:08,799
and so it's the wait system call that

1722
01:04:08,799 --> 01:04:10,319
allows the process to wait for

1723
01:04:10,319 --> 01:04:12,880
any of its children to return and this

1724
01:04:12,880 --> 01:04:15,680
status argument is a

1725
01:04:15,680 --> 01:04:19,359
way for an exiting child

1726
01:04:19,359 --> 01:04:22,960
to communicate one integer

1727
01:04:22,960 --> 01:04:26,160
32-bit value from the exiting child um

1728
01:04:26,160 --> 01:04:28,240
to the waiting parent so in line 17 that

1729
01:04:28,240 --> 01:04:29,599
argument to exit

1730
01:04:29,599 --> 01:04:32,160
that one that's the argument to exit the

1731
01:04:32,160 --> 01:04:34,000
operating system

1732
01:04:34,000 --> 01:04:37,440
passes that one from the exiting child

1733
01:04:37,440 --> 01:04:39,839
um to the call to wait at line 20. so

1734
01:04:39,839 --> 01:04:42,960
weight that the ampersand and weight

1735
01:04:42,960 --> 01:04:45,039
is passing the address of the status

1736
01:04:45,039 --> 01:04:46,000
variable

1737
01:04:46,000 --> 01:04:48,000
to the kernel the colonel fills in that

1738
01:04:48,000 --> 01:04:50,079
address with the

1739
01:04:50,079 --> 01:04:52,880
child's argument to exit and the

1740
01:04:52,880 --> 01:04:54,640
convention in unix is that

1741
01:04:54,640 --> 01:04:57,280
if a program completes successfully it

1742
01:04:57,280 --> 01:04:58,480
exit with exits

1743
01:04:58,480 --> 01:05:01,440
with state of zero but if if it

1744
01:05:01,440 --> 01:05:02,559
encountered an error

1745
01:05:02,559 --> 01:05:05,839
as it lines 17 um then the unix

1746
01:05:05,839 --> 01:05:07,119
convention is that you pass

1747
01:05:07,119 --> 01:05:09,760
one to exit and so if you care the

1748
01:05:09,760 --> 01:05:11,680
calling process can look at the status

1749
01:05:11,680 --> 01:05:12,319
from weight

1750
01:05:12,319 --> 01:05:15,440
and decide whether the

1751
01:05:15,440 --> 01:05:18,559
child completed successfully enough

1752
01:05:18,559 --> 01:05:21,280
professor morris quick question yes

1753
01:05:21,280 --> 01:05:22,480
about

1754
01:05:22,480 --> 01:05:25,520
the exact call on 9 15. uh we mentioned

1755
01:05:25,520 --> 01:05:26,000
not

1756
01:05:26,000 --> 01:05:29,200
a bit ago that exec will completely go

1757
01:05:29,200 --> 01:05:31,280
into the echo program and not return

1758
01:05:31,280 --> 01:05:34,640
to fork exec so

1759
01:05:34,640 --> 01:05:38,160
would it ever reach lines 16 and 17

1760
01:05:38,160 --> 01:05:41,280
well not for this exact code because

1761
01:05:41,280 --> 01:05:42,400
there happens to be

1762
01:05:42,400 --> 01:05:44,880
a program called echo but but you know

1763
01:05:44,880 --> 01:05:46,960
if i modified that code here let me let

1764
01:05:46,960 --> 01:05:49,440
me just modify this code for you

1765
01:05:49,440 --> 01:05:52,880
okay so first let me just run fork exact

1766
01:05:52,880 --> 01:05:56,079
right it actually does execute echo with

1767
01:05:56,079 --> 01:05:57,680
those arguments we see the output this

1768
01:05:57,680 --> 01:05:59,119
is echo

1769
01:05:59,119 --> 01:06:01,520
and we see the child exited to show that

1770
01:06:01,520 --> 01:06:02,880
uh

1771
01:06:02,880 --> 01:06:05,520
echo exited successfully and the parent

1772
01:06:05,520 --> 01:06:06,319
waited for it

1773
01:06:06,319 --> 01:06:09,520
let me just modify the program for you

1774
01:06:09,520 --> 01:06:12,000
um instead of echo i'm going to run some

1775
01:06:12,000 --> 01:06:15,510
command that doesn't exist

1776
01:06:15,520 --> 01:06:19,200
i actually have to exit out of uh qmu

1777
01:06:19,200 --> 01:06:21,520
with control a x and then rebuild the

1778
01:06:21,520 --> 01:06:24,000
whole thing in order to recompile

1779
01:06:24,000 --> 01:06:26,720
my modified four gigs and i run four

1780
01:06:26,720 --> 01:06:29,039
pixel yen after modifying and compiling

1781
01:06:29,039 --> 01:06:29,680
it

1782
01:06:29,680 --> 01:06:31,119
and this time because the program we're

1783
01:06:31,119 --> 01:06:33,440
asking to

1784
01:06:33,440 --> 01:06:36,470
actually

1785
01:06:36,480 --> 01:06:38,400
the program we're asking to execute

1786
01:06:38,400 --> 01:06:39,599
doesn't exist

1787
01:06:39,599 --> 01:06:42,720
exec does return we see the exec failed

1788
01:06:42,720 --> 01:06:44,400
output

1789
01:06:44,400 --> 01:06:46,720
and the exit one you see the one there

1790
01:06:46,720 --> 01:06:48,480
is communicated back to the parent which

1791
01:06:48,480 --> 01:06:52,319
says the child exited the status one

1792
01:06:52,319 --> 01:06:55,599
so exec returns back to the calling

1793
01:06:55,599 --> 01:06:56,079
function

1794
01:06:56,079 --> 01:07:12,829
when something went wrong yes

1795
01:07:12,839 --> 01:07:14,720
okay

1796
01:07:14,720 --> 01:07:17,280
all right um something that uh something

1797
01:07:17,280 --> 01:07:18,240
to note here that

1798
01:07:18,240 --> 01:07:19,520
actually i think many of you have

1799
01:07:19,520 --> 01:07:21,280
already noted is that

1800
01:07:21,280 --> 01:07:24,319
uh this is a common idiom here this fork

1801
01:07:24,319 --> 01:07:27,280
followed by an exec and a child um and

1802
01:07:27,280 --> 01:07:29,520
it's potentially a bit wasteful the fork

1803
01:07:29,520 --> 01:07:32,480
copies the entire parent process but

1804
01:07:32,480 --> 01:07:33,280
exec

1805
01:07:33,280 --> 01:07:35,920
throws away all that copied memory and

1806
01:07:35,920 --> 01:07:40,000
replaces it with whatever is in the um

1807
01:07:40,000 --> 01:07:43,039
file that you're running so you know if

1808
01:07:43,039 --> 01:07:44,240
you're worried about this kind of stuff

1809
01:07:44,240 --> 01:07:45,119
the

1810
01:07:45,119 --> 01:07:48,160
copy implied by the fork

1811
01:07:48,160 --> 01:07:50,319
is in some sense mostly wasted because

1812
01:07:50,319 --> 01:07:52,160
all that copied memory is just thrown

1813
01:07:52,160 --> 01:07:53,520
away and replaced by the

1814
01:07:53,520 --> 01:07:56,400
exact um and this effects actually would

1815
01:07:56,400 --> 01:07:58,079
be significant for big programs if you

1816
01:07:58,079 --> 01:08:00,160
have a multi-gigabyte program that calls

1817
01:08:00,160 --> 01:08:01,039
fork

1818
01:08:01,039 --> 01:08:03,200
uh and it did indeed copy all the memory

1819
01:08:03,200 --> 01:08:04,880
would actually uh take a fair fraction

1820
01:08:04,880 --> 01:08:05,599
of a second

1821
01:08:05,599 --> 01:08:08,839
perhaps to do the copy which could be a

1822
01:08:08,839 --> 01:08:10,079
problem

1823
01:08:10,079 --> 01:08:13,190
um

1824
01:08:13,200 --> 01:08:15,839
but later in the course you'll actually

1825
01:08:15,839 --> 01:08:17,359
implement some optimizations in

1826
01:08:17,359 --> 01:08:18,319
particular something called

1827
01:08:18,319 --> 01:08:21,600
copy on right fork which will eliminate

1828
01:08:21,600 --> 01:08:22,080
almost

1829
01:08:22,080 --> 01:08:25,920
all of the apparent inefficiency of fork

1830
01:08:25,920 --> 01:08:28,159
copying only to have exact throw away

1831
01:08:28,159 --> 01:08:29,040
the copy

1832
01:08:29,040 --> 01:08:30,560
it turns out with a bunch of tricks

1833
01:08:30,560 --> 01:08:33,839
involving a virtual memory system

1834
01:08:33,839 --> 01:08:35,839
you can build a fork that's lazy about

1835
01:08:35,839 --> 01:08:38,719
the copy and that doesn't do in the

1836
01:08:38,719 --> 01:08:40,319
common case of fork immediately followed

1837
01:08:40,319 --> 01:08:42,400
by exact um where you don't actually

1838
01:08:42,400 --> 01:08:43,920
have to do the copy because the child

1839
01:08:43,920 --> 01:08:46,880
doesn't actually use most of the memory

1840
01:08:46,880 --> 01:08:49,600
um i think you'll find that's a fun and

1841
01:08:49,600 --> 01:08:50,960
interesting lab

1842
01:08:50,960 --> 01:08:53,679
question from chat why does the parent

1843
01:08:53,679 --> 01:08:56,080
process print parent waiting completely

1844
01:08:56,080 --> 01:09:00,630
before the child calls exec

1845
01:09:00,640 --> 01:09:04,870
it's just chance

1846
01:09:04,880 --> 01:09:08,400
the is it that you know the

1847
01:09:08,400 --> 01:09:13,120
the observation is that um you know

1848
01:09:13,120 --> 01:09:15,199
uh it could be that the parent's output

1849
01:09:15,199 --> 01:09:17,120
could be interleaved with the child's

1850
01:09:17,120 --> 01:09:18,480
output in the same area that we saw

1851
01:09:18,480 --> 01:09:22,000
before with the simpler fork example

1852
01:09:22,000 --> 01:09:23,920
it just happens not to be there's no

1853
01:09:23,920 --> 01:09:25,759
guarantee that this is the output we

1854
01:09:25,759 --> 01:09:26,880
would see

1855
01:09:26,880 --> 01:09:29,440
in fact we shouldn't be surprised if we

1856
01:09:29,440 --> 01:09:30,880
saw the lines of the output in the other

1857
01:09:30,880 --> 01:09:32,000
order

1858
01:09:32,000 --> 01:09:35,759
or interleaved i suspect what's going on

1859
01:09:35,759 --> 01:09:38,400
is that it takes a bit of time and

1860
01:09:38,400 --> 01:09:39,600
effort

1861
01:09:39,600 --> 01:09:41,199
now the exact system calls a little bit

1862
01:09:41,199 --> 01:09:42,640
expensive because it has to

1863
01:09:42,640 --> 01:09:45,120
load all those instructions to access

1864
01:09:45,120 --> 01:09:46,880
the file system and access the disk and

1865
01:09:46,880 --> 01:09:49,040
read the contents of a file called echo

1866
01:09:49,040 --> 01:09:51,920
off the disk into memory after

1867
01:09:51,920 --> 01:09:53,759
allocating some memory and that even

1868
01:09:53,759 --> 01:09:55,440
after freeing some memory from the old

1869
01:09:55,440 --> 01:09:56,560
process so

1870
01:09:56,560 --> 01:09:57,760
there's quite a bit of machinery

1871
01:09:57,760 --> 01:10:00,800
involved in the exact system call

1872
01:10:00,800 --> 01:10:03,280
and apparently that takes long enough

1873
01:10:03,280 --> 01:10:05,120
that the parent can complete

1874
01:10:05,120 --> 01:10:07,840
producing the output before the exec has

1875
01:10:07,840 --> 01:10:10,320
finished and started running echo

1876
01:10:10,320 --> 01:10:15,110
does that make sense

1877
01:10:15,120 --> 01:10:17,040
i have another question is it convention

1878
01:10:17,040 --> 01:10:21,590
that the child can't wait for the parent

1879
01:10:21,600 --> 01:10:25,440
there's not a way unix doesn't have a

1880
01:10:25,440 --> 01:10:28,320
way for the child

1881
01:10:28,320 --> 01:10:29,679
there's no straightforward way for the

1882
01:10:29,679 --> 01:10:31,840
child to wait for the parent

1883
01:10:31,840 --> 01:10:35,600
the weight system call is sort of

1884
01:10:35,600 --> 01:10:37,840
the only mechanism available well the

1885
01:10:37,840 --> 01:10:39,360
weight system call

1886
01:10:39,360 --> 01:10:43,520
waits for your children and that's it

1887
01:10:43,520 --> 01:10:45,280
and so what weight is what weight does

1888
01:10:45,280 --> 01:10:47,120
is um

1889
01:10:47,120 --> 01:10:49,600
if you have any children and one of them

1890
01:10:49,600 --> 01:10:51,120
has already exited

1891
01:10:51,120 --> 01:10:54,239
or does exit then weight will return

1892
01:10:54,239 --> 01:10:55,280
but you know if you don't have any

1893
01:10:55,280 --> 01:10:57,440
children say because you are

1894
01:10:57,440 --> 01:11:00,719
because in this simple case

1895
01:11:00,719 --> 01:11:03,120
um whether it was just a parent and a

1896
01:11:03,120 --> 01:11:03,840
child

1897
01:11:03,840 --> 01:11:07,120
if the child called weight the child

1898
01:11:07,120 --> 01:11:08,480
doesn't have any children

1899
01:11:08,480 --> 01:11:09,920
and in that case weight just returns

1900
01:11:09,920 --> 01:11:11,760
immediately with a minus one

1901
01:11:11,760 --> 01:11:13,840
error return saying this process doesn't

1902
01:11:13,840 --> 01:11:15,360
have any children

1903
01:11:15,360 --> 01:11:17,199
anyway the short answer is there's no

1904
01:11:17,199 --> 01:11:18,560
way for a child

1905
01:11:18,560 --> 01:11:22,000
to wait for its parent to exit

1906
01:11:22,000 --> 01:11:23,840
another question when we say the child

1907
01:11:23,840 --> 01:11:25,760
copies all the memory

1908
01:11:25,760 --> 01:11:27,440
from the parent process what i what

1909
01:11:27,440 --> 01:11:29,280
exactly do we refer to by that

1910
01:11:29,280 --> 01:11:31,440
i thought the child is going to divide

1911
01:11:31,440 --> 01:11:37,510
define the variables again

1912
01:11:37,520 --> 01:11:40,960
um well when you compile us you know

1913
01:11:40,960 --> 01:11:45,430
um

1914
01:11:45,440 --> 01:11:49,120
after compilation your c program

1915
01:11:49,120 --> 01:11:50,400
is just a bunch of instructions in

1916
01:11:50,400 --> 01:11:53,440
memory that live in ram

1917
01:11:53,440 --> 01:11:57,280
um and so those can be copied

1918
01:11:57,280 --> 01:11:59,120
because they're just bytes living in ram

1919
01:11:59,120 --> 01:12:01,120
those can be copied somewhere else

1920
01:12:01,120 --> 01:12:04,239
um and with appropriate tricks having to

1921
01:12:04,239 --> 01:12:06,400
do with setting up

1922
01:12:06,400 --> 01:12:09,679
a sort of virtual memory mappings um

1923
01:12:09,679 --> 01:12:10,960
and make the mappings look the same with

1924
01:12:10,960 --> 01:12:12,320
the child as an apparent you can just

1925
01:12:12,320 --> 01:12:14,480
copy the parent's memory image to the

1926
01:12:14,480 --> 01:12:15,040
child

1927
01:12:15,040 --> 01:12:20,470
and execute it in the child

1928
01:12:20,480 --> 01:12:21,840
i mean even though we're looking at c

1929
01:12:21,840 --> 01:12:23,120
programs you should think of them as

1930
01:12:23,120 --> 01:12:24,239
just a bunch of us

1931
01:12:24,239 --> 01:12:27,280
machine instructions um

1932
01:12:27,280 --> 01:12:28,640
which are just bytes in memory that can

1933
01:12:28,640 --> 01:12:31,189
be copied

1934
01:12:31,199 --> 01:12:33,520
if a parent has multiple children would

1935
01:12:33,520 --> 01:12:35,199
wait just return as soon as the first

1936
01:12:35,199 --> 01:12:36,159
child finishes

1937
01:12:36,159 --> 01:12:37,600
meaning that there could be some more

1938
01:12:37,600 --> 01:12:38,960
interleaving with the parent and

1939
01:12:38,960 --> 01:12:40,159
unfinished children

1940
01:12:40,159 --> 01:12:41,760
would there need to be multiple separate

1941
01:12:41,760 --> 01:12:44,480
weights to ensure all children finish

1942
01:12:44,480 --> 01:12:47,440
yes if you call forth more than one if a

1943
01:12:47,440 --> 01:12:48,960
sin if a given process

1944
01:12:48,960 --> 01:12:52,560
calls for twice um

1945
01:12:52,560 --> 01:12:54,400
then and it wants to wait for both

1946
01:12:54,400 --> 01:12:56,000
children it has to call weight

1947
01:12:56,000 --> 01:12:58,960
twice and each call to wait will return

1948
01:12:58,960 --> 01:13:00,000
as soon as

1949
01:13:00,000 --> 01:13:01,920
one of the children exits so you don't

1950
01:13:01,920 --> 01:13:02,960
when weight returns you don't

1951
01:13:02,960 --> 01:13:04,719
necessarily know which

1952
01:13:04,719 --> 01:13:07,600
child is exited the weight returns the

1953
01:13:07,600 --> 01:13:09,760
child's process id as its return value

1954
01:13:09,760 --> 01:13:11,360
so you can tell

1955
01:13:11,360 --> 01:13:13,600
after weight returns you know which one

1956
01:13:13,600 --> 01:13:22,470
it was that exited

1957
01:13:22,480 --> 01:13:25,679
as a final example um

1958
01:13:25,679 --> 01:13:28,790
i'd like to show

1959
01:13:28,800 --> 01:13:33,760
how all of these facilities combine

1960
01:13:33,760 --> 01:13:37,840
to implement i o redirection so

1961
01:13:37,840 --> 01:13:40,320
if you remember the shell provides us

1962
01:13:40,320 --> 01:13:42,159
with this handy syntax

1963
01:13:42,159 --> 01:13:43,840
and i can say echo hello greater than

1964
01:13:43,840 --> 01:13:45,280
out

1965
01:13:45,280 --> 01:13:47,040
and that runs the echo command that

1966
01:13:47,040 --> 01:13:48,880
argument sending its

1967
01:13:48,880 --> 01:13:51,440
first that sends this output to the file

1968
01:13:51,440 --> 01:13:53,040
out and we look it out

1969
01:13:53,040 --> 01:13:57,040
or better yet run the cap command with

1970
01:13:57,040 --> 01:13:58,320
its input

1971
01:13:58,320 --> 01:14:01,440
connected from the out file

1972
01:14:01,440 --> 01:14:02,960
we can see that saved output from the

1973
01:14:02,960 --> 01:14:04,960
echo command

1974
01:14:04,960 --> 01:14:09,280
um the way the shell sets this up

1975
01:14:09,280 --> 01:14:13,360
is as follows

1976
01:14:13,360 --> 01:14:17,280
um it uh the shell

1977
01:14:17,280 --> 01:14:20,640
first forks like on line 13 and then

1978
01:14:20,640 --> 01:14:23,760
in the child the shell changes the way

1979
01:14:23,760 --> 01:14:25,760
the file descriptors are set up so that

1980
01:14:25,760 --> 01:14:27,199
the child's

1981
01:14:27,199 --> 01:14:30,320
file descriptor one which by convention

1982
01:14:30,320 --> 01:14:33,440
most programs use for their output

1983
01:14:33,440 --> 01:14:36,400
the shell changes the child's file

1984
01:14:36,400 --> 01:14:38,239
descriptor to one to refer

1985
01:14:38,239 --> 01:14:41,360
to this output file and then runs

1986
01:14:41,360 --> 01:14:42,000
whatever command

1987
01:14:42,000 --> 01:14:44,480
you wanted and that leaves the parent

1988
01:14:44,480 --> 01:14:46,159
shells file descriptor one

1989
01:14:46,159 --> 01:14:49,600
unchanged so this idiom of forking and

1990
01:14:49,600 --> 01:14:50,880
in the child

1991
01:14:50,880 --> 01:14:53,440
um changing around the file descriptors

1992
01:14:53,440 --> 01:14:55,040
is the usual way in

1993
01:14:55,040 --> 01:14:58,800
to sort of redirect input and output for

1994
01:14:58,800 --> 01:15:00,960
a command that you run but not affect

1995
01:15:00,960 --> 01:15:02,080
the input and output

1996
01:15:02,080 --> 01:15:04,719
for the calling program because we don't

1997
01:15:04,719 --> 01:15:07,840
want to redirect the shell's output

1998
01:15:07,840 --> 01:15:10,640
we only want to redirect the child

1999
01:15:10,640 --> 01:15:12,560
programs output

2000
01:15:12,560 --> 01:15:14,560
anyway the way this works we call fork

2001
01:15:14,560 --> 01:15:16,159
in the usual way

2002
01:15:16,159 --> 01:15:19,040
line 15 only executes in the child the

2003
01:15:19,040 --> 01:15:20,320
reason for the close one

2004
01:15:20,320 --> 01:15:23,520
on line 15 is that in this program

2005
01:15:23,520 --> 01:15:25,840
we're redirecting just the output of the

2006
01:15:25,840 --> 01:15:26,719
echo command so

2007
01:15:26,719 --> 01:15:30,239
when i run this redirect program

2008
01:15:30,239 --> 01:15:32,000
produces no output itself but it ran

2009
01:15:32,000 --> 01:15:33,800
echo with this output directed to

2010
01:15:33,800 --> 01:15:35,440
output.txt

2011
01:15:35,440 --> 01:15:39,679
so when i look at output.txt

2012
01:15:39,679 --> 01:15:42,000
i see this expected output the reason

2013
01:15:42,000 --> 01:15:44,880
for the close one on line 15

2014
01:15:44,880 --> 01:15:48,080
is that we want one

2015
01:15:48,080 --> 01:15:49,600
sort of conventional output file

2016
01:15:49,600 --> 01:15:52,159
descriptor to refer to something else it

2017
01:15:52,159 --> 01:15:53,040
happens

2018
01:15:53,040 --> 01:15:54,960
so we don't from the child we don't want

2019
01:15:54,960 --> 01:15:56,880
to use the file descriptor one that the

2020
01:15:56,880 --> 01:15:58,239
shell had that's connected to the

2021
01:15:58,239 --> 01:15:59,600
console

2022
01:15:59,600 --> 01:16:01,840
um the call to open on line 16 is

2023
01:16:01,840 --> 01:16:04,719
guaranteed to return one because

2024
01:16:04,719 --> 01:16:06,640
the semantics of open are that open

2025
01:16:06,640 --> 01:16:08,320
returns the lowest

2026
01:16:08,320 --> 01:16:10,080
file descriptor number that's not

2027
01:16:10,080 --> 01:16:11,520
currently in use

2028
01:16:11,520 --> 01:16:14,000
um in the calling process since we just

2029
01:16:14,000 --> 01:16:15,280
closed one

2030
01:16:15,280 --> 01:16:18,320
and file descriptor 0 is

2031
01:16:18,320 --> 01:16:20,480
still connected to the console that mean

2032
01:16:20,480 --> 01:16:21,360
um

2033
01:16:21,360 --> 01:16:24,480
open is guaranteed to return one so

2034
01:16:24,480 --> 01:16:25,600
after the

2035
01:16:25,600 --> 01:16:28,159
line 16 file descriptor 1 is connected

2036
01:16:28,159 --> 01:16:30,159
to this file

2037
01:16:30,159 --> 01:16:32,560
when we exec echo echo just writes its

2038
01:16:32,560 --> 01:16:34,239
output to file scripter one

2039
01:16:34,239 --> 01:16:35,920
um and now it goes to this file and the

2040
01:16:35,920 --> 01:16:37,360
cool thing about this is echo had no

2041
01:16:37,360 --> 01:16:38,640
idea what's going on

2042
01:16:38,640 --> 01:16:40,239
echo doesn't need to know about io

2043
01:16:40,239 --> 01:16:42,239
redirection at all it just

2044
01:16:42,239 --> 01:16:45,840
writes its output to file descriptor one

2045
01:16:45,840 --> 01:16:49,360
only the shell knows about

2046
01:16:49,360 --> 01:16:52,390
io redirection

2047
01:16:52,400 --> 01:16:54,880
this example also illustrates the sort

2048
01:16:54,880 --> 01:16:56,239
of

2049
01:16:56,239 --> 01:16:58,880
kind of neatness of the separation

2050
01:16:58,880 --> 01:16:59,280
between

2051
01:16:59,280 --> 01:17:01,040
fork and exec the fact that fork and

2052
01:17:01,040 --> 01:17:04,239
exact are separate system calls

2053
01:17:04,239 --> 01:17:08,159
separate uh functions

2054
01:17:08,159 --> 01:17:09,840
means that there's a period of time but

2055
01:17:09,840 --> 01:17:11,840
in the child between the fork

2056
01:17:11,840 --> 01:17:13,840
between fork returns and the child and

2057
01:17:13,840 --> 01:17:14,880
exact in which

2058
01:17:14,880 --> 01:17:16,480
we're still running the calling

2059
01:17:16,480 --> 01:17:18,480
processes instructions so the

2060
01:17:18,480 --> 01:17:21,280
calling process even though it's running

2061
01:17:21,280 --> 01:17:22,560
even though its instructions are running

2062
01:17:22,560 --> 01:17:23,520
in the child

2063
01:17:23,520 --> 01:17:25,120
it's still the calling processes

2064
01:17:25,120 --> 01:17:26,880
instructions that are executing

2065
01:17:26,880 --> 01:17:29,920
and so the calling process is still able

2066
01:17:29,920 --> 01:17:30,560
to change

2067
01:17:30,560 --> 01:17:32,960
things um still in control up until line

2068
01:17:32,960 --> 01:17:34,239
19

2069
01:17:34,239 --> 01:17:35,760
and this sort of interval between fork

2070
01:17:35,760 --> 01:17:38,560
and sec uh gives the shell a chance to

2071
01:17:38,560 --> 01:17:40,719
change what the file descriptors refer

2072
01:17:40,719 --> 01:17:43,199
to for example

2073
01:17:43,199 --> 01:17:45,440
any questions about this redirect

2074
01:17:45,440 --> 01:17:55,110
example

2075
01:17:55,120 --> 01:18:00,239
all right um got out of time

2076
01:18:00,239 --> 01:18:03,920
i'll just wrap up we looked at unix's

2077
01:18:03,920 --> 01:18:07,199
a bunch of the interfaces to unix's i o

2078
01:18:07,199 --> 01:18:10,080
and process abstractions a thing to take

2079
01:18:10,080 --> 01:18:11,520
away from this is that the interfaces

2080
01:18:11,520 --> 01:18:12,640
are relatively simple

2081
01:18:12,640 --> 01:18:14,960
you just pass integers like file

2082
01:18:14,960 --> 01:18:16,800
descriptors and process ids back and

2083
01:18:16,800 --> 01:18:17,920
forth across

2084
01:18:17,920 --> 01:18:20,800
as arguments to these system calls um

2085
01:18:20,800 --> 01:18:21,199
but

2086
01:18:21,199 --> 01:18:24,080
sort of all the functionality inside the

2087
01:18:24,080 --> 01:18:25,600
interfaces is relatively

2088
01:18:25,600 --> 01:18:27,840
sophisticated like creating new

2089
01:18:27,840 --> 01:18:28,880
processes and

2090
01:18:28,880 --> 01:18:30,719
copying the current process and

2091
01:18:30,719 --> 01:18:31,920
furthermore

2092
01:18:31,920 --> 01:18:33,280
i showed some examples of ways in which

2093
01:18:33,280 --> 01:18:35,280
the abstractions though individually

2094
01:18:35,280 --> 01:18:36,080
simple

2095
01:18:36,080 --> 01:18:39,760
combine in useful ways for example

2096
01:18:39,760 --> 01:18:43,910
to produce iod direction

2097
01:18:43,920 --> 01:18:45,600
there's a lab due at the end of next

2098
01:18:45,600 --> 01:18:48,880
week and that lab involves writing

2099
01:18:48,880 --> 01:18:50,719
more simple utilities like the ones i

2100
01:18:50,719 --> 01:18:52,320
showed that use the system calls that we

2101
01:18:52,320 --> 01:18:54,080
discussed

2102
01:18:54,080 --> 01:18:56,560
so have fun with that lab and i'll see

2103
01:18:56,560 --> 01:19:01,510
you in class next week

2104
01:19:01,520 --> 01:19:15,189
and that's it

2105
01:19:15,199 --> 01:19:17,520
since i'm the one recording um how do i

2106
01:19:17,520 --> 01:19:18,719
end this

2107
01:19:18,719 --> 01:19:20,719
first time recording is in lecture i

2108
01:19:20,719 --> 01:19:22,480
think we exit

2109
01:19:22,480 --> 01:19:24,239
okay and nothing special i can just exit

2110
01:19:24,239 --> 01:19:26,480
and it'll be saved somewhere

2111
01:19:26,480 --> 01:19:31,990
yes awesome

2112
01:19:32,000 --> 01:19:35,040
and zoom will create some directory and

2113
01:19:35,040 --> 01:19:38,470
stick the vowel in that directory

2114
01:19:38,480 --> 01:19:40,000
there's also office hours right after

2115
01:19:40,000 --> 01:19:41,920
this right

2116
01:19:41,920 --> 01:19:48,830
yes perfect okay

2117
01:19:48,840 --> 01:19:50,320
cool

2118
01:19:50,320 --> 01:19:53,440
all right all right thank you and

2119
01:19:53,440 --> 01:19:59,199
i'll see you next week thanks

