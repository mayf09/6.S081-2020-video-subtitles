1
00:00:12,320 --> 00:00:12,880
okay

2
00:00:12,880 --> 00:00:18,950
quick sound check can everybody hear me

3
00:00:18,960 --> 00:00:22,480
yep okay good uh anyway let's

4
00:00:22,480 --> 00:00:25,439
get let's get going um you know good

5
00:00:25,439 --> 00:00:26,960
afternoon or good evening or good

6
00:00:26,960 --> 00:00:27,599
morning

7
00:00:27,599 --> 00:00:30,080
uh whatever good night wherever you are

8
00:00:30,080 --> 00:00:30,880
uh

9
00:00:30,880 --> 00:00:32,640
so today's lecture uh is going to be

10
00:00:32,640 --> 00:00:34,800
about the page faults

11
00:00:34,800 --> 00:00:38,320
and a particular uh we're gonna

12
00:00:38,320 --> 00:00:39,870
uh the plan is to

13
00:00:39,870 --> 00:00:41,920
[Music]

14
00:00:41,920 --> 00:00:46,079
cover or implement

15
00:00:46,079 --> 00:00:50,470
you know implement a number

16
00:00:50,480 --> 00:00:53,990
virtual memory features

17
00:00:54,000 --> 00:01:03,670
using page faults

18
00:01:03,680 --> 00:01:05,680
um and the features that we're going to

19
00:01:05,680 --> 00:01:07,760
be looking at are

20
00:01:07,760 --> 00:01:10,880
lazy allocation which is the uh topic of

21
00:01:10,880 --> 00:01:12,960
the next lab

22
00:01:12,960 --> 00:01:15,920
um yeah we're going to look at the

23
00:01:15,920 --> 00:01:16,799
demand

24
00:01:16,799 --> 00:01:20,789
copy and write fork

25
00:01:20,799 --> 00:01:27,360
demand paging

26
00:01:27,360 --> 00:01:32,550
and memory map files or map

27
00:01:32,560 --> 00:01:35,920
and almost

28
00:01:35,920 --> 00:01:37,439
you know sort of a series operating

29
00:01:37,439 --> 00:01:39,439
system actually implements all these

30
00:01:39,439 --> 00:01:42,159
features so if you look inside of linux

31
00:01:42,159 --> 00:01:43,680
you'll see all these features actually

32
00:01:43,680 --> 00:01:44,079
uh

33
00:01:44,079 --> 00:01:47,040
are implemented uh in xc6 as it stands

34
00:01:47,040 --> 00:01:48,960
none of them are implemented

35
00:01:48,960 --> 00:01:51,119
and uh and the fact that what a page

36
00:01:51,119 --> 00:01:53,040
fault does in xc6

37
00:01:53,040 --> 00:01:54,479
if the page vault happens in user phase

38
00:01:54,479 --> 00:01:56,479
basis basically kill the process

39
00:01:56,479 --> 00:01:58,799
but nothing interesting uh and so in

40
00:01:58,799 --> 00:01:59,920
this lecture we're going to explore

41
00:01:59,920 --> 00:02:01,119
again what interesting things you could

42
00:02:01,119 --> 00:02:03,200
do in the page fault handler

43
00:02:03,200 --> 00:02:04,399
to actually implement these three

44
00:02:04,399 --> 00:02:06,399
features so this lecture is a little bit

45
00:02:06,399 --> 00:02:07,280
less

46
00:02:07,280 --> 00:02:09,520
walking through code and understanding

47
00:02:09,520 --> 00:02:10,720
uh existing code

48
00:02:10,720 --> 00:02:13,360
a little bit more design level uh in the

49
00:02:13,360 --> 00:02:13,760
sense

50
00:02:13,760 --> 00:02:16,560
we don't even have code to look at uh

51
00:02:16,560 --> 00:02:17,599
another thing that's important to

52
00:02:17,599 --> 00:02:19,040
mention is that lazy allocation is the

53
00:02:19,040 --> 00:02:20,400
topic of the next lap and

54
00:02:20,400 --> 00:02:23,520
hopefully it will push out today um and

55
00:02:23,520 --> 00:02:26,160
copy and write fork it's going to be a

56
00:02:26,160 --> 00:02:27,760
topic of one of the labs

57
00:02:27,760 --> 00:02:30,480
and uh map is going to be another topic

58
00:02:30,480 --> 00:02:32,560
of one of the subsequent labs

59
00:02:32,560 --> 00:02:34,160
so this is going to you know this is one

60
00:02:34,160 --> 00:02:35,760
of the interesting parts of an operating

61
00:02:35,760 --> 00:02:36,560
system

62
00:02:36,560 --> 00:02:37,840
and we're going to be spending quite a

63
00:02:37,840 --> 00:02:41,120
bit of time on it in the labs

64
00:02:41,120 --> 00:02:43,920
now you know before diving sort of into

65
00:02:43,920 --> 00:02:45,519
details

66
00:02:45,519 --> 00:02:48,800
it is probably helpful to take a little

67
00:02:48,800 --> 00:02:49,440
bit of a

68
00:02:49,440 --> 00:02:51,920
step back and so you can think about

69
00:02:51,920 --> 00:02:54,640
virtual memory having

70
00:02:54,640 --> 00:03:02,470
two major benefits

71
00:03:02,480 --> 00:03:05,680
one is isolation so

72
00:03:05,680 --> 00:03:08,239
isolation in the sense that uh virtual

73
00:03:08,239 --> 00:03:09,920
memory allows the operating system to

74
00:03:09,920 --> 00:03:11,599
give every application its own address

75
00:03:11,599 --> 00:03:12,080
space

76
00:03:12,080 --> 00:03:14,560
and so it's impossible for you know one

77
00:03:14,560 --> 00:03:15,680
application to muck

78
00:03:15,680 --> 00:03:17,840
you know or by accident or maliciously

79
00:03:17,840 --> 00:03:20,159
to modify another application's address

80
00:03:20,159 --> 00:03:21,040
space

81
00:03:21,040 --> 00:03:22,640
uh it also provides isolation between

82
00:03:22,640 --> 00:03:24,319
the user and kernel address space as we

83
00:03:24,319 --> 00:03:26,560
talked about quite a bit and as you've

84
00:03:26,560 --> 00:03:29,120
seen in the page table lab

85
00:03:29,120 --> 00:03:31,040
but sort of another view or another

86
00:03:31,040 --> 00:03:32,879
benefit

87
00:03:32,879 --> 00:03:34,560
of you know virtual memory that you know

88
00:03:34,560 --> 00:03:36,239
i alluded to a couple times

89
00:03:36,239 --> 00:03:44,830
earlier is that it provides a level of

90
00:03:44,840 --> 00:03:47,280
interaction

91
00:03:47,280 --> 00:03:49,200
now the processor the instructions you

92
00:03:49,200 --> 00:03:51,680
can all use virtual addresses

93
00:03:51,680 --> 00:03:53,840
uh but the kernel gets to sort of define

94
00:03:53,840 --> 00:03:54,720
the mapping

95
00:03:54,720 --> 00:03:56,720
from virtual addresses to physical

96
00:03:56,720 --> 00:03:58,799
addresses

97
00:03:58,799 --> 00:04:01,599
and that allows all kinds of interesting

98
00:04:01,599 --> 00:04:02,560
uh

99
00:04:02,560 --> 00:04:05,680
uh interesting features

100
00:04:05,680 --> 00:04:06,879
like the ones i'm going to be talking

101
00:04:06,879 --> 00:04:10,949
about in the in this lecture um

102
00:04:10,959 --> 00:04:24,790
the second

103
00:04:24,800 --> 00:04:26,479
kernel has controls this particular

104
00:04:26,479 --> 00:04:29,360
mapping from a virtual to

105
00:04:29,360 --> 00:04:31,759
a physical address space and most so far

106
00:04:31,759 --> 00:04:33,280
in excuses that mapping has to be

107
00:04:33,280 --> 00:04:35,520
quite boring you know in fact in the

108
00:04:35,520 --> 00:04:37,520
kernel it's mostly direct mapping

109
00:04:37,520 --> 00:04:39,040
and a couple sort of interesting things

110
00:04:39,040 --> 00:04:41,919
that we do with the x26 kernel does you

111
00:04:41,919 --> 00:04:43,840
know with this mapping one as we've seen

112
00:04:43,840 --> 00:04:47,199
is the trampoline page allowed the

113
00:04:47,199 --> 00:04:48,400
kernel to map

114
00:04:48,400 --> 00:04:50,720
one page into many address spaces

115
00:04:50,720 --> 00:04:52,320
another interesting case that we have

116
00:04:52,320 --> 00:04:53,120
seen

117
00:04:53,120 --> 00:04:56,639
is the you know guard protect

118
00:04:56,639 --> 00:04:58,800
the stack uh both in the kernel and both

119
00:04:58,800 --> 00:05:01,039
and in kernel space both in user space

120
00:05:01,039 --> 00:05:02,960
any kernel space

121
00:05:02,960 --> 00:05:04,080
but if you sort of think about it you

122
00:05:04,080 --> 00:05:06,000
know so far that mapping

123
00:05:06,000 --> 00:05:08,080
you know has been relatively static you

124
00:05:08,080 --> 00:05:09,039
know the

125
00:05:09,039 --> 00:05:11,199
you we set it up once you know maybe per

126
00:05:11,199 --> 00:05:12,880
user uh with the kernel page table

127
00:05:12,880 --> 00:05:14,720
mapping we set up once in the beginning

128
00:05:14,720 --> 00:05:18,080
and for processes once at fork and there

129
00:05:18,080 --> 00:05:18,479
sort of

130
00:05:18,479 --> 00:05:19,840
the kernel doesn't really do anything

131
00:05:19,840 --> 00:05:21,600
else with this mapping

132
00:05:21,600 --> 00:05:24,720
and what page fault gives us is actually

133
00:05:24,720 --> 00:05:26,400
to make these mappings

134
00:05:26,400 --> 00:05:34,550
dynamic so i'm using page faults

135
00:05:34,560 --> 00:05:37,759
yeah we can change or the kernel can

136
00:05:37,759 --> 00:05:38,000
change

137
00:05:38,000 --> 00:05:45,430
the mapping

138
00:05:45,440 --> 00:05:47,600
so dynamically on the fly and this turns

139
00:05:47,600 --> 00:05:48,720
out to be an extra

140
00:05:48,720 --> 00:05:52,400
extremely uh powerful uh

141
00:05:52,400 --> 00:05:55,120
mechanism so if you can combine page

142
00:05:55,120 --> 00:05:56,319
tables

143
00:05:56,319 --> 00:05:59,600
and page faults uh you uh have an

144
00:05:59,600 --> 00:06:00,400
enormous

145
00:06:00,400 --> 00:06:01,759
the kernel has an enormous amount of

146
00:06:01,759 --> 00:06:04,240
flexibility and the flexibility comes

147
00:06:04,240 --> 00:06:05,199
down because you can

148
00:06:05,199 --> 00:06:07,360
change this level of direction on on the

149
00:06:07,360 --> 00:06:09,909
fly

150
00:06:09,919 --> 00:06:11,840
and so what we're going to be doing is

151
00:06:11,840 --> 00:06:13,759
basically looking at all kinds of

152
00:06:13,759 --> 00:06:17,600
usages of this dynamic remapping or

153
00:06:17,600 --> 00:06:20,479
dynamic changing of the page tables that

154
00:06:20,479 --> 00:06:21,600
gives us

155
00:06:21,600 --> 00:06:24,710
interesting features

156
00:06:24,720 --> 00:06:26,400
um so the first thing we may want to

157
00:06:26,400 --> 00:06:28,080
think about is a little bit

158
00:06:28,080 --> 00:06:30,319
uh is you know what information is

159
00:06:30,319 --> 00:06:32,319
needed you know so if you're in the

160
00:06:32,319 --> 00:06:35,680
page vault happens um

161
00:06:35,680 --> 00:06:39,360
and uh you know the kernel wants to

162
00:06:39,360 --> 00:06:41,039
respond to this page fault you know what

163
00:06:41,039 --> 00:06:42,479
you know information doesn't need

164
00:06:42,479 --> 00:06:45,600
to actually be able to respond and you

165
00:06:45,600 --> 00:06:47,199
know sort of quite

166
00:06:47,199 --> 00:06:48,720
know obviously you know we'd like to

167
00:06:48,720 --> 00:06:52,629
have the virtual dress

168
00:06:52,639 --> 00:06:55,680
off uh the virtual address with

169
00:06:55,680 --> 00:06:59,749
defaulting

170
00:06:59,759 --> 00:07:03,280
uh or the cost of page fault

171
00:07:03,280 --> 00:07:06,400
uh let me not say it actually i want to

172
00:07:06,400 --> 00:07:09,110
say is

173
00:07:09,120 --> 00:07:15,350
the folding virtual dress

174
00:07:15,360 --> 00:07:16,960
and you know you've seen presumably some

175
00:07:16,960 --> 00:07:18,800
of these panic uh calls in

176
00:07:18,800 --> 00:07:21,280
your page fault lab uh and you know the

177
00:07:21,280 --> 00:07:23,120
kernel actually has access to them

178
00:07:23,120 --> 00:07:24,800
uh in fact it prints them out when

179
00:07:24,800 --> 00:07:26,240
actually page fold happens

180
00:07:26,240 --> 00:07:28,479
and uh you know it happens to be sitting

181
00:07:28,479 --> 00:07:30,800
in the st

182
00:07:30,800 --> 00:07:35,510
valley register

183
00:07:35,520 --> 00:07:39,280
so when a user application

184
00:07:39,280 --> 00:07:41,680
causes a paid fault the paid fall

185
00:07:41,680 --> 00:07:43,440
basically invokes the same

186
00:07:43,440 --> 00:07:45,919
track machinery that robert discussed in

187
00:07:45,919 --> 00:07:47,199
the last lecture

188
00:07:47,199 --> 00:07:49,840
it's almost completely identical but in

189
00:07:49,840 --> 00:07:51,440
the case of a page fault it also will

190
00:07:51,440 --> 00:07:53,199
put the defaulting address

191
00:07:53,199 --> 00:07:57,280
into that st valve register

192
00:07:57,280 --> 00:07:59,199
so that is uh one thing that we probably

193
00:07:59,199 --> 00:08:00,319
want to know

194
00:08:00,319 --> 00:08:01,360
the second thing that we probably want

195
00:08:01,360 --> 00:08:11,589
to know is the type of default

196
00:08:11,599 --> 00:08:14,080
uh because it may be in terms of uh uh

197
00:08:14,080 --> 00:08:14,960
we may want to do

198
00:08:14,960 --> 00:08:17,120
respond differently differently in terms

199
00:08:17,120 --> 00:08:18,000
of to

200
00:08:18,000 --> 00:08:20,319
uh a page fault due to a load

201
00:08:20,319 --> 00:08:21,120
instruction

202
00:08:21,120 --> 00:08:23,120
or a page filter due to store

203
00:08:23,120 --> 00:08:25,520
instruction or page fall due to like a

204
00:08:25,520 --> 00:08:26,800
jump instruction

205
00:08:26,800 --> 00:08:29,840
um and so in fact you know if you look

206
00:08:29,840 --> 00:08:31,120
in the risc 5

207
00:08:31,120 --> 00:08:34,479
documentation um

208
00:08:34,479 --> 00:08:37,760
here's the race 5 documentation in here

209
00:08:37,760 --> 00:08:40,240
in the s-cause register that we was

210
00:08:40,240 --> 00:08:42,159
mentioned in the track lecture

211
00:08:42,159 --> 00:08:47,509
there are a number of uh

212
00:08:47,519 --> 00:08:49,360
causes that actually related to page

213
00:08:49,360 --> 00:08:53,120
faults so example if you look at

214
00:08:53,120 --> 00:08:56,959
number 13 is a load page fault number 15

215
00:08:56,959 --> 00:08:59,040
is the store page fault and the number

216
00:08:59,040 --> 00:09:01,360
12 is in the instruction page fault

217
00:09:01,360 --> 00:09:03,839
so these are the uh in the s cause

218
00:09:03,839 --> 00:09:04,560
register

219
00:09:04,560 --> 00:09:08,720
and we get that information

220
00:09:08,720 --> 00:09:10,880
and so there's three different types you

221
00:09:10,880 --> 00:09:12,080
know the read

222
00:09:12,080 --> 00:09:16,720
write and uh instruction

223
00:09:16,720 --> 00:09:19,920
and just going back you know the the one

224
00:09:19,920 --> 00:09:23,680
uh s know that actually uh was caused by

225
00:09:23,680 --> 00:09:25,680
uh the ecal instruction to do actually a

226
00:09:25,680 --> 00:09:26,720
kernel transfer

227
00:09:26,720 --> 00:09:29,120
is number eight right so that's the one

228
00:09:29,120 --> 00:09:30,080
that we saw in

229
00:09:30,080 --> 00:09:31,920
the trap lecture that we spent a lot of

230
00:09:31,920 --> 00:09:33,600
time thinking about in the trap lecture

231
00:09:33,600 --> 00:09:35,600
but basically all the other page faults

232
00:09:35,600 --> 00:09:37,360
or exceptions

233
00:09:37,360 --> 00:09:39,760
use the same you know mechanism to

234
00:09:39,760 --> 00:09:41,279
transfer from user space to kernel

235
00:09:41,279 --> 00:09:41,839
transfer

236
00:09:41,839 --> 00:09:44,880
to kernel space and um

237
00:09:44,880 --> 00:09:46,480
once given the kernel space in the case

238
00:09:46,480 --> 00:09:48,160
of the page fault you know the std value

239
00:09:48,160 --> 00:09:49,200
is

240
00:09:49,200 --> 00:09:52,399
set yes cause register set then the

241
00:09:52,399 --> 00:09:53,200
third thing

242
00:09:53,200 --> 00:09:56,240
that we probably want to know is the

243
00:09:56,240 --> 00:09:58,880
instruction

244
00:09:58,880 --> 00:10:02,839
or to address the virtual address of the

245
00:10:02,839 --> 00:10:05,519
instruction

246
00:10:05,519 --> 00:10:14,870
that cost the page fault

247
00:10:14,880 --> 00:10:17,519
and you know anybody remember where you

248
00:10:17,519 --> 00:10:19,200
know from the trap lecture where that

249
00:10:19,200 --> 00:10:20,880
where the instruction is where that

250
00:10:20,880 --> 00:10:25,190
address is

251
00:10:25,200 --> 00:10:28,560
anybody is it uh sepsi

252
00:10:28,560 --> 00:10:32,079
yeah exactly and there was this regisepc

253
00:10:32,079 --> 00:10:34,079
correct the supervisor exception

254
00:10:34,079 --> 00:10:35,760
exception program counter

255
00:10:35,760 --> 00:10:37,519
uh there is where it is and where is

256
00:10:37,519 --> 00:10:40,630
that saved

257
00:10:40,640 --> 00:10:44,949
as part of the trap handling code

258
00:10:44,959 --> 00:10:46,880
in the trap frame yeah it ends up in the

259
00:10:46,880 --> 00:10:49,120
trap frame correct there's a trap frame

260
00:10:49,120 --> 00:10:52,560
epc actually has the exception program

261
00:10:52,560 --> 00:10:54,000
camera

262
00:10:54,000 --> 00:10:55,440
so we sort of think about the hardware

263
00:10:55,440 --> 00:10:57,360
mechanism and what xv6 does

264
00:10:57,360 --> 00:10:58,959
uh we have free piece of information

265
00:10:58,959 --> 00:11:00,320
they're probably extremely valuable to

266
00:11:00,320 --> 00:11:02,640
us when we get actually paid for namely

267
00:11:02,640 --> 00:11:05,760
the the drastic cost default the type of

268
00:11:05,760 --> 00:11:06,720
default

269
00:11:06,720 --> 00:11:08,880
and the exception program counter like

270
00:11:08,880 --> 00:11:11,120
where how did it happen in user space

271
00:11:11,120 --> 00:11:12,399
and the reason that we care a lot about

272
00:11:12,399 --> 00:11:13,920
the exception program counter correct is

273
00:11:13,920 --> 00:11:14,560
because

274
00:11:14,560 --> 00:11:16,560
uh when that we probably want to repair

275
00:11:16,560 --> 00:11:17,680
you know in the handler we're going to

276
00:11:17,680 --> 00:11:18,160
repair

277
00:11:18,160 --> 00:11:20,320
the page table and then we're going to

278
00:11:20,320 --> 00:11:22,480
basically restart the same instruction

279
00:11:22,480 --> 00:11:24,240
and you know hopefully the after

280
00:11:24,240 --> 00:11:25,760
repairing the page fault or

281
00:11:25,760 --> 00:11:27,120
repairing the page tables that

282
00:11:27,120 --> 00:11:28,800
instruction can just run without any

283
00:11:28,800 --> 00:11:29,440
trouble

284
00:11:29,440 --> 00:11:30,560
and so it's important that we can be

285
00:11:30,560 --> 00:11:32,399
able to resume the instruction that

286
00:11:32,399 --> 00:11:33,519
actually

287
00:11:33,519 --> 00:11:38,230
that we that cost default

288
00:11:38,240 --> 00:11:42,880
does that all make sense

289
00:11:42,880 --> 00:11:46,000
okay um so now i want to look at

290
00:11:46,000 --> 00:11:47,600
you know also the basic mechanism and

291
00:11:47,600 --> 00:11:49,839
the basic information that the risk 5 is

292
00:11:49,839 --> 00:11:51,279
actually giving us

293
00:11:51,279 --> 00:11:54,800
and i want to look at a basically go

294
00:11:54,800 --> 00:11:56,720
through a list of

295
00:11:56,720 --> 00:11:59,920
uh you know features uh that will help

296
00:11:59,920 --> 00:12:00,720
us you know

297
00:12:00,720 --> 00:12:03,200
understand actually how we can uh use

298
00:12:03,200 --> 00:12:04,880
the patrol handler to

299
00:12:04,880 --> 00:12:08,560
uh repair the page table and

300
00:12:08,560 --> 00:12:10,880
do interesting things so the first thing

301
00:12:10,880 --> 00:12:12,000
i want to look at

302
00:12:12,000 --> 00:12:17,190
is allocation

303
00:12:17,200 --> 00:12:25,200
in particular you know s-break

304
00:12:25,200 --> 00:12:27,760
so fast break is the system call that

305
00:12:27,760 --> 00:12:29,279
xv6 provides

306
00:12:29,279 --> 00:12:31,920
that uh allows an application to

307
00:12:31,920 --> 00:12:32,959
basically grow

308
00:12:32,959 --> 00:12:34,480
grow its heap right so when the

309
00:12:34,480 --> 00:12:36,160
application uh

310
00:12:36,160 --> 00:12:39,600
starts uh you know s break uh points

311
00:12:39,600 --> 00:12:41,120
here

312
00:12:41,120 --> 00:12:42,800
you know at the bottom of the heap you

313
00:12:42,800 --> 00:12:44,320
know at the top of the stack

314
00:12:44,320 --> 00:12:45,839
and in fact you know it's the same place

315
00:12:45,839 --> 00:12:47,360
where you know p

316
00:12:47,360 --> 00:12:50,320
size basically you know points to and so

317
00:12:50,320 --> 00:12:52,399
when s break is called uh for example

318
00:12:52,399 --> 00:12:54,079
aspect is called with like one two three

319
00:12:54,079 --> 00:12:55,440
four five you know the number of pages

320
00:12:55,440 --> 00:12:57,440
that you know you want to allocate

321
00:12:57,440 --> 00:13:00,480
the uh aspect system call it basically

322
00:13:00,480 --> 00:13:01,680
bumps up

323
00:13:01,680 --> 00:13:06,800
you know this boundary

324
00:13:06,800 --> 00:13:09,839
do something there and then that uh

325
00:13:09,839 --> 00:13:12,320
and so what that means that when the s

326
00:13:12,320 --> 00:13:13,519
break actually happens

327
00:13:13,519 --> 00:13:15,519
or the aspect system call is called the

328
00:13:15,519 --> 00:13:16,880
kernel will allocate some physical

329
00:13:16,880 --> 00:13:17,680
memory

330
00:13:17,680 --> 00:13:20,800
uh map it into the address space of

331
00:13:20,800 --> 00:13:24,320
the user application uh zero the memory

332
00:13:24,320 --> 00:13:25,519
and then basically return it from the

333
00:13:25,519 --> 00:13:28,150
system call

334
00:13:28,160 --> 00:13:30,480
and you know every time it's just and

335
00:13:30,480 --> 00:13:31,839
the application can grow

336
00:13:31,839 --> 00:13:34,079
you know that physical memory that or

337
00:13:34,079 --> 00:13:35,360
memory that it needs

338
00:13:35,360 --> 00:13:37,760
or it might want uh by just calling

339
00:13:37,760 --> 00:13:38,880
multiple times to uh

340
00:13:38,880 --> 00:13:41,040
s-brick uh the application can also

341
00:13:41,040 --> 00:13:42,240
decrease or

342
00:13:42,240 --> 00:13:44,160
shrink in its address phase by calling

343
00:13:44,160 --> 00:13:46,720
estimate with a negative number

344
00:13:46,720 --> 00:13:48,079
but i want to focus on the case where

345
00:13:48,079 --> 00:13:50,800
we're growing uh the address space

346
00:13:50,800 --> 00:13:54,160
and in xy6 as it is uh

347
00:13:54,160 --> 00:13:57,360
the uh this break is eager

348
00:13:57,360 --> 00:13:59,199
and or does what we're going to call

349
00:13:59,199 --> 00:14:03,760
eager allocation

350
00:14:03,760 --> 00:14:07,920
namely as soon as the uh

351
00:14:07,920 --> 00:14:10,560
s-break is called the kernel will

352
00:14:10,560 --> 00:14:11,760
immediately allocate

353
00:14:11,760 --> 00:14:13,839
the physical memory that the application

354
00:14:13,839 --> 00:14:15,519
is asking for

355
00:14:15,519 --> 00:14:17,360
and now it turns out that in practice

356
00:14:17,360 --> 00:14:18,959
it's actually hard for applications to

357
00:14:18,959 --> 00:14:20,079
predict

358
00:14:20,079 --> 00:14:24,399
uh how much memory they need so

359
00:14:24,399 --> 00:14:28,790
typically applications

360
00:14:28,800 --> 00:14:36,470
tend to over ask

361
00:14:36,480 --> 00:14:37,920
and so they ask a lot more than they

362
00:14:37,920 --> 00:14:40,000
really need uh and

363
00:14:40,000 --> 00:14:42,639
uh often that will which means that

364
00:14:42,639 --> 00:14:44,480
basically you know the address space uh

365
00:14:44,480 --> 00:14:45,920
will grow quite a bit

366
00:14:45,920 --> 00:14:47,360
uh even with memory that's actually

367
00:14:47,360 --> 00:14:49,519
never used by the application

368
00:14:49,519 --> 00:14:51,360
you might think like oh that's stupid uh

369
00:14:51,360 --> 00:14:52,560
how could that happen

370
00:14:52,560 --> 00:14:54,240
well you know think about like if you

371
00:14:54,240 --> 00:14:55,680
write an application program

372
00:14:55,680 --> 00:14:58,560
and uh the typical application program

373
00:14:58,560 --> 00:15:00,320
maybe it read some input or you know it

374
00:15:00,320 --> 00:15:01,680
has a matrix something that

375
00:15:01,680 --> 00:15:04,800
uses for some computation um

376
00:15:04,800 --> 00:15:06,320
and often the application writers sort

377
00:15:06,320 --> 00:15:08,880
of plans for the worst case you know

378
00:15:08,880 --> 00:15:10,399
it you know allocates memory for the

379
00:15:10,399 --> 00:15:11,600
biggest matrix that you know the

380
00:15:11,600 --> 00:15:12,000
application

381
00:15:12,000 --> 00:15:14,800
might never ever need but in the common

382
00:15:14,800 --> 00:15:15,360
case

383
00:15:15,360 --> 00:15:16,880
the application may be computed with a

384
00:15:16,880 --> 00:15:18,800
much smaller you know input or a much

385
00:15:18,800 --> 00:15:19,760
smaller

386
00:15:19,760 --> 00:15:23,680
matrix and so it's quite common

387
00:15:23,680 --> 00:15:25,279
in fact for application programmers and

388
00:15:25,279 --> 00:15:26,399
probably if you know you think about

389
00:15:26,399 --> 00:15:27,839
your own application you've written

390
00:15:27,839 --> 00:15:30,639
to actually over ask and actually under

391
00:15:30,639 --> 00:15:32,079
use

392
00:15:32,079 --> 00:15:35,199
uh and again we'd like to in principle

393
00:15:35,199 --> 00:15:35,839
not a big

394
00:15:35,839 --> 00:15:37,680
problem but you know using actually uh

395
00:15:37,680 --> 00:15:39,920
virtual memory and page fault handlers

396
00:15:39,920 --> 00:15:42,240
we can actually totally

397
00:15:42,240 --> 00:15:44,480
totally respond to that in sort of an

398
00:15:44,480 --> 00:15:46,800
intelligent manner

399
00:15:46,800 --> 00:15:59,110
and by basically doing lazy allocation

400
00:15:59,120 --> 00:16:02,240
and then the basic idea is very simple

401
00:16:02,240 --> 00:16:06,310
and s break

402
00:16:06,320 --> 00:16:07,600
we're basically going to do almost

403
00:16:07,600 --> 00:16:09,279
nothing and the only thing that we need

404
00:16:09,279 --> 00:16:10,880
to know remember is of course that we

405
00:16:10,880 --> 00:16:12,399
did grow the address space so the only

406
00:16:12,399 --> 00:16:13,279
thing really what we're going to be

407
00:16:13,279 --> 00:16:13,759
doing

408
00:16:13,759 --> 00:16:18,150
is actually bumping up you know p size

409
00:16:18,160 --> 00:16:21,600
you know whatever with the number uh

410
00:16:21,600 --> 00:16:23,440
you know set two sides to whatever the

411
00:16:23,440 --> 00:16:25,519
new size plus you know n

412
00:16:25,519 --> 00:16:26,800
and where n is the amount of memory

413
00:16:26,800 --> 00:16:28,959
that's allocated and then

414
00:16:28,959 --> 00:16:30,800
you know so that but we don't allocate

415
00:16:30,800 --> 00:16:32,240
the kernel doesn't allocate any physical

416
00:16:32,240 --> 00:16:33,519
memory at that particular point of time

417
00:16:33,519 --> 00:16:34,720
it doesn't zero it that there's

418
00:16:34,720 --> 00:16:36,079
absolutely nothing

419
00:16:36,079 --> 00:16:38,639
um then at some point the application

420
00:16:38,639 --> 00:16:40,480
will use or might use that memory

421
00:16:40,480 --> 00:16:41,120
correctly if

422
00:16:41,120 --> 00:16:42,160
it's actually one of the pieces of

423
00:16:42,160 --> 00:16:44,399
memory that it really needs uh

424
00:16:44,399 --> 00:16:47,519
and that will cause a page fault

425
00:16:47,519 --> 00:16:51,040
because we didn't map that memory

426
00:16:51,040 --> 00:16:53,360
actually into the page map yet

427
00:16:53,360 --> 00:16:56,880
and so if we dereference a virtual dress

428
00:16:56,880 --> 00:16:59,040
you know above you know this piece size

429
00:16:59,040 --> 00:16:59,920
uh but below

430
00:16:59,920 --> 00:17:02,720
pcs plus n uh what we like to be

431
00:17:02,720 --> 00:17:03,279
happening

432
00:17:03,279 --> 00:17:05,120
is that you know the kernel will

433
00:17:05,120 --> 00:17:06,959
allocate a page and uh restarts

434
00:17:06,959 --> 00:17:08,240
instruction

435
00:17:08,240 --> 00:17:10,880
so if we get a page fault and we see

436
00:17:10,880 --> 00:17:12,559
that the virtual address

437
00:17:12,559 --> 00:17:15,280
is you know bigger than pizza uh it is

438
00:17:15,280 --> 00:17:16,000
below

439
00:17:16,000 --> 00:17:21,669
sorry it's a little key size

440
00:17:21,679 --> 00:17:23,839
for p size then we know that this must

441
00:17:23,839 --> 00:17:25,520
be a virtual address and i guess above

442
00:17:25,520 --> 00:17:28,710
the stack

443
00:17:28,720 --> 00:17:31,120
you know that this is a an address that

444
00:17:31,120 --> 00:17:32,480
actually comes out of the heap

445
00:17:32,480 --> 00:17:34,160
but for which we the kernel hasn't

446
00:17:34,160 --> 00:17:35,919
allocated any

447
00:17:35,919 --> 00:17:39,039
uh physical memory yet and so the

448
00:17:39,039 --> 00:17:40,400
response to this paid fault you know

449
00:17:40,400 --> 00:17:41,679
could be reasonable straightforward you

450
00:17:41,679 --> 00:17:43,679
know in the patrol panel itself

451
00:17:43,679 --> 00:17:48,559
we can allocate a page and using k alec

452
00:17:48,559 --> 00:17:55,669
allocate one page zero to page

453
00:17:55,679 --> 00:17:58,400
map the page into the page table so

454
00:17:58,400 --> 00:18:02,870
updating the page tables

455
00:18:02,880 --> 00:18:04,160
and then basically restart the

456
00:18:04,160 --> 00:18:06,870
instruction

457
00:18:06,880 --> 00:18:08,640
so for example if there was a load

458
00:18:08,640 --> 00:18:10,400
instruction or store instruction

459
00:18:10,400 --> 00:18:12,000
that wrote where i was trying to read

460
00:18:12,000 --> 00:18:14,240
you know from that uh not

461
00:18:14,240 --> 00:18:16,400
allocated you know piece of memory that

462
00:18:16,400 --> 00:18:18,320
actually the process has

463
00:18:18,320 --> 00:18:20,960
uh now after we mapped in this you know

464
00:18:20,960 --> 00:18:21,919
physical page

465
00:18:21,919 --> 00:18:23,760
uh the restarting instructions should

466
00:18:23,760 --> 00:18:25,200
just work

467
00:18:25,200 --> 00:18:28,240
i'm here go ahead

468
00:18:28,240 --> 00:18:31,200
right so i was wondering in in the case

469
00:18:31,200 --> 00:18:32,480
where we're doing eager

470
00:18:32,480 --> 00:18:35,360
allocation uh and there comes a point

471
00:18:35,360 --> 00:18:37,520
where a process consumes so much memory

472
00:18:37,520 --> 00:18:39,520
that it actually exhausts the physical

473
00:18:39,520 --> 00:18:40,080
memory

474
00:18:40,080 --> 00:18:43,120
resource uh if we don't do eager

475
00:18:43,120 --> 00:18:43,919
allocation

476
00:18:43,919 --> 00:18:47,360
we do lazy instead at what point would

477
00:18:47,360 --> 00:18:49,039
the application know that there's no

478
00:18:49,039 --> 00:18:50,720
physical memory

479
00:18:50,720 --> 00:18:53,760
ah that's a great question uh well

480
00:18:53,760 --> 00:18:54,720
basically you know

481
00:18:54,720 --> 00:18:56,000
it almost looks through the application

482
00:18:56,000 --> 00:18:58,320
there there's this illusion of

483
00:18:58,320 --> 00:19:00,960
unlimited physical about memory you know

484
00:19:00,960 --> 00:19:02,240
at some point of course you know

485
00:19:02,240 --> 00:19:04,160
it you know might use so much you know

486
00:19:04,160 --> 00:19:05,520
that basically okay so

487
00:19:05,520 --> 00:19:07,440
it may use all physical memory and so if

488
00:19:07,440 --> 00:19:09,360
then it touches one more page

489
00:19:09,360 --> 00:19:11,039
which there's no physical memory present

490
00:19:11,039 --> 00:19:12,880
at that particular point in time

491
00:19:12,880 --> 00:19:14,000
then you know there's a couple of

492
00:19:14,000 --> 00:19:15,360
actions that the colonel can take and

493
00:19:15,360 --> 00:19:16,240
i'll talk about

494
00:19:16,240 --> 00:19:18,480
the more sophisticated ones later uh

495
00:19:18,480 --> 00:19:20,240
what you're going to be doing in the

496
00:19:20,240 --> 00:19:24,160
lazy lab is you know if the is uh up

497
00:19:24,160 --> 00:19:26,799
and there's no no more free memory uh

498
00:19:26,799 --> 00:19:27,919
you just

499
00:19:27,919 --> 00:19:29,440
return an error or actually you kill the

500
00:19:29,440 --> 00:19:32,640
process in that particular case

501
00:19:32,640 --> 00:19:34,640
uh and so because you're out of memory

502
00:19:34,640 --> 00:19:36,160
so there's nothing the kernel can do

503
00:19:36,160 --> 00:19:38,080
and at that point you know you return or

504
00:19:38,080 --> 00:19:39,679
kill the process

505
00:19:39,679 --> 00:19:42,080
yeah that's a that you're going to do in

506
00:19:42,080 --> 00:19:43,120
the lazy lab we'll see

507
00:19:43,120 --> 00:19:44,480
later in this lecture you could be more

508
00:19:44,480 --> 00:19:47,990
sophisticated than that

509
00:19:48,000 --> 00:19:50,080
uh i think this is generally brings up a

510
00:19:50,080 --> 00:19:52,000
topic that is if we have a collection of

511
00:19:52,000 --> 00:19:53,840
processes running on

512
00:19:53,840 --> 00:19:55,600
an operating system there is a limited

513
00:19:55,600 --> 00:19:57,039
amount of physical memory and that

514
00:19:57,039 --> 00:19:57,679
limited

515
00:19:57,679 --> 00:19:59,120
physical memory must be shared in some

516
00:19:59,120 --> 00:20:00,960
way between the applications

517
00:20:00,960 --> 00:20:02,880
and so i'll talk a little bit much more

518
00:20:02,880 --> 00:20:04,240
about it in

519
00:20:04,240 --> 00:20:07,360
10-20 minutes

520
00:20:07,360 --> 00:20:10,480
okay uh there's a question to check uh

521
00:20:10,480 --> 00:20:11,520
in the chat

522
00:20:11,520 --> 00:20:16,230
why is the condition virtual address uh

523
00:20:16,240 --> 00:20:18,080
virtual justice loans next we start at

524
00:20:18,080 --> 00:20:19,760
zero

525
00:20:19,760 --> 00:20:22,480
okay this is a question about this

526
00:20:22,480 --> 00:20:26,149
particular check here

527
00:20:26,159 --> 00:20:30,230
so remember

528
00:20:30,240 --> 00:20:33,280
we have our stack here and

529
00:20:33,280 --> 00:20:36,640
we have our data here and we have our

530
00:20:36,640 --> 00:20:37,120
text

531
00:20:37,120 --> 00:20:39,840
in the user process and basically we

532
00:20:39,840 --> 00:20:40,559
bumped up

533
00:20:40,559 --> 00:20:44,870
you know p size to something bigger

534
00:20:44,880 --> 00:20:47,120
uh we've dumped it up the growth we

535
00:20:47,120 --> 00:20:48,720
haven't allocated memory here yet so

536
00:20:48,720 --> 00:20:49,520
this memory has

537
00:20:49,520 --> 00:20:51,280
not been physically allocated yet so

538
00:20:51,280 --> 00:20:52,960
this check just checks

539
00:20:52,960 --> 00:20:55,039
if the address falls below p size and it

540
00:20:55,039 --> 00:20:56,640
actually is a valid you know address

541
00:20:56,640 --> 00:20:58,400
in the user address space if it were

542
00:20:58,400 --> 00:21:00,400
above p size presumably that's a

543
00:21:00,400 --> 00:21:02,000
programming error

544
00:21:02,000 --> 00:21:03,840
in the program or the user application

545
00:21:03,840 --> 00:21:05,280
who's trying to dereference a memory

546
00:21:05,280 --> 00:21:07,360
that actually doesn't have

547
00:21:07,360 --> 00:21:11,350
hopefully that answers the question

548
00:21:11,360 --> 00:21:14,880
yeah thank you okay good so

549
00:21:14,880 --> 00:21:17,360
to get a little bit of a feel uh you

550
00:21:17,360 --> 00:21:18,400
know for what that actually

551
00:21:18,400 --> 00:21:22,000
means uh in uh this lazy allocation

552
00:21:22,000 --> 00:21:25,679
uh and that's probably uh the only

553
00:21:25,679 --> 00:21:27,600
uh sort of programming or tooth uh

554
00:21:27,600 --> 00:21:29,440
things that we're gonna be doing

555
00:21:29,440 --> 00:21:32,720
today is uh let's try to sort of uh

556
00:21:32,720 --> 00:21:34,960
sketch out or look actually how it would

557
00:21:34,960 --> 00:21:35,760
look in

558
00:21:35,760 --> 00:21:39,280
in code and the two holes you'll see

559
00:21:39,280 --> 00:21:40,480
that it will be surprising

560
00:21:40,480 --> 00:21:44,240
easy and furthermore it's probably a big

561
00:21:44,240 --> 00:21:45,120
help

562
00:21:45,120 --> 00:21:48,799
for the lazy lab and so that hopefully

563
00:21:48,799 --> 00:21:49,440
that will help you

564
00:21:49,440 --> 00:21:52,559
get going pretty straightforwardly

565
00:21:52,559 --> 00:21:54,080
and it allows us also to look at a

566
00:21:54,080 --> 00:21:59,679
couple uh page fault

567
00:21:59,679 --> 00:22:02,640
um i had a question actually regarding a

568
00:22:02,640 --> 00:22:04,000
point that i made in chat

569
00:22:04,000 --> 00:22:05,360
why do we actually need to kill the

570
00:22:05,360 --> 00:22:07,120
application couldn't the operating

571
00:22:07,120 --> 00:22:08,880
system just return like a narrative

572
00:22:08,880 --> 00:22:10,000
you are out of memory try and do

573
00:22:10,000 --> 00:22:12,159
something else

574
00:22:12,159 --> 00:22:13,440
let's respond that question to a little

575
00:22:13,440 --> 00:22:15,200
bit later you know

576
00:22:15,200 --> 00:22:16,400
in the page fault we're going to just

577
00:22:16,400 --> 00:22:18,960
kill the process uh but you know we can

578
00:22:18,960 --> 00:22:20,159
be more sophisticated

579
00:22:20,159 --> 00:22:22,799
uh in pixel lab real kernels are more

580
00:22:22,799 --> 00:22:25,039
sophisticated

581
00:22:25,039 --> 00:22:26,960
okay uh although in the end they might

582
00:22:26,960 --> 00:22:28,559
still kill us you know if there's just

583
00:22:28,559 --> 00:22:30,320
no more memory what whatsoever to be

584
00:22:30,320 --> 00:22:31,679
gotten you know there's basically no

585
00:22:31,679 --> 00:22:32,880
choice

586
00:22:32,880 --> 00:22:36,159
um okay uh so the first thing uh we're

587
00:22:36,159 --> 00:22:37,760
gonna do we're gonna modify so

588
00:22:37,760 --> 00:22:39,360
you remember that cis practice you know

589
00:22:39,360 --> 00:22:40,880
actually grows the address space of the

590
00:22:40,880 --> 00:22:42,400
application allocates memory and all

591
00:22:42,400 --> 00:22:43,200
that kind of stuff

592
00:22:43,200 --> 00:22:45,200
we're just not going to do that we're

593
00:22:45,200 --> 00:22:48,799
just going to set p size you know to

594
00:22:48,799 --> 00:22:52,000
p size plus n

595
00:22:52,000 --> 00:22:53,760
so let's assume that we're only growing

596
00:22:53,760 --> 00:22:56,159
and not worry about uh shrinking for now

597
00:22:56,159 --> 00:22:58,320
and that is what we're going to be doing

598
00:22:58,320 --> 00:23:00,880
so this grows the virtual dress space

599
00:23:00,880 --> 00:23:03,760
uh by end and that's all all we're going

600
00:23:03,760 --> 00:23:06,000
to be doing

601
00:23:06,000 --> 00:23:07,440
let's see if i can make no programming

602
00:23:07,440 --> 00:23:09,120
mistakes i did make a programming

603
00:23:09,120 --> 00:23:10,559
mistake

604
00:23:10,559 --> 00:23:14,480
uh i guess i don't have product key here

605
00:23:14,480 --> 00:23:23,760
so i'll like proc

606
00:23:23,760 --> 00:23:25,679
it's good yeah so the program just runs

607
00:23:25,679 --> 00:23:27,520
uh or at least we boot

608
00:23:27,520 --> 00:23:30,400
uh i think if we do like echo high uh

609
00:23:30,400 --> 00:23:32,240
we're gonna get actually a page fault

610
00:23:32,240 --> 00:23:33,919
and the reason that we get a paid fault

611
00:23:33,919 --> 00:23:35,280
is because uh

612
00:23:35,280 --> 00:23:38,480
the shell uh who's gonna fork you know

613
00:23:38,480 --> 00:23:39,280
echo and

614
00:23:39,280 --> 00:23:41,440
then you know the child is gonna exec

615
00:23:41,440 --> 00:23:43,520
echo uh the shell actually allocates

616
00:23:43,520 --> 00:23:44,559
some memory

617
00:23:44,559 --> 00:23:47,520
and so the shell calls s-break and

618
00:23:47,520 --> 00:23:48,640
things are not looking good

619
00:23:48,640 --> 00:23:50,720
but it's sort of interesting to look at

620
00:23:50,720 --> 00:23:51,679
you know the

621
00:23:51,679 --> 00:23:54,320
uh information here so here's our it

622
00:23:54,320 --> 00:23:55,679
prints out the s-cos

623
00:23:55,679 --> 00:23:58,880
uh register uh when the value in s-cos

624
00:23:58,880 --> 00:24:00,559
and we see it's 15.

625
00:24:00,559 --> 00:24:06,710
uh anybody remember what 15 is

626
00:24:06,720 --> 00:24:07,919
you know from the table i just showed

627
00:24:07,919 --> 00:24:09,360
you a little bit a while ago that

628
00:24:09,360 --> 00:24:10,320
actually is the write

629
00:24:10,320 --> 00:24:13,520
or store page fault we see that is

630
00:24:13,520 --> 00:24:16,480
process free that's probably the shell

631
00:24:16,480 --> 00:24:17,840
and we actually see the

632
00:24:17,840 --> 00:24:19,760
exception program encounter it's one two

633
00:24:19,760 --> 00:24:22,000
a four and we see the address given the

634
00:24:22,000 --> 00:24:23,600
virtual address on which we fault which

635
00:24:23,600 --> 00:24:25,360
is four thousand eight

636
00:24:25,360 --> 00:24:27,360
and so let's uh look at the you know we

637
00:24:27,360 --> 00:24:29,520
can look at the

638
00:24:29,520 --> 00:24:32,799
assembly of the shell the make files

639
00:24:32,799 --> 00:24:34,720
nice of us nice enough for us to

640
00:24:34,720 --> 00:24:36,240
actually generate that

641
00:24:36,240 --> 00:24:39,360
and we can look at the address uh

642
00:24:39,360 --> 00:24:42,400
1284 and

643
00:24:42,400 --> 00:24:44,320
you know we see indeed you know there

644
00:24:44,320 --> 00:24:45,919
there's a story instruction correct the

645
00:24:45,919 --> 00:24:47,200
store instruction

646
00:24:47,200 --> 00:24:49,440
and uh it looks like that's where we're

647
00:24:49,440 --> 00:24:50,880
faulting

648
00:24:50,880 --> 00:24:53,360
uh so if you scroll back a little bit

649
00:24:53,360 --> 00:24:55,360
and look at this assembly here

650
00:24:55,360 --> 00:24:58,240
uh you know we see uh that actually this

651
00:24:58,240 --> 00:25:00,080
is in part of the implementation of

652
00:25:00,080 --> 00:25:01,440
malloc

653
00:25:01,440 --> 00:25:03,600
so that seems uh totally reasonable

654
00:25:03,600 --> 00:25:05,360
correct here's the malek implementation

655
00:25:05,360 --> 00:25:07,520
not surprising that we presumably use

656
00:25:07,520 --> 00:25:08,720
s-break to get some

657
00:25:08,720 --> 00:25:13,039
memory for implementing the user malloc

658
00:25:13,039 --> 00:25:15,679
and we're basically initializing the

659
00:25:15,679 --> 00:25:17,039
free list of

660
00:25:17,039 --> 00:25:18,880
using the memory that we've just gotten

661
00:25:18,880 --> 00:25:20,159
from the kernel

662
00:25:20,159 --> 00:25:23,909
and this line 12 a4

663
00:25:23,919 --> 00:25:25,679
joomla writes you know i guess it's

664
00:25:25,679 --> 00:25:27,360
right something in size

665
00:25:27,360 --> 00:25:30,799
and uh but we we're writing to memory

666
00:25:30,799 --> 00:25:33,120
that actually hasn't been allocated

667
00:25:33,120 --> 00:25:34,480
another reason that we can see that the

668
00:25:34,480 --> 00:25:36,559
memory is probably not allocated is

669
00:25:36,559 --> 00:25:38,720
uh the i think the shell actually has

670
00:25:38,720 --> 00:25:39,760
four pages

671
00:25:39,760 --> 00:25:42,640
of text and data and we're basically

672
00:25:42,640 --> 00:25:44,559
sitting just above the fourth

673
00:25:44,559 --> 00:25:46,080
page in the fifth page in fact we're

674
00:25:46,080 --> 00:25:47,919
sitting eight bytes above it

675
00:25:47,919 --> 00:25:51,039
that sort of makes sense uh we look at

676
00:25:51,039 --> 00:25:54,640
the instruction again where's 1284

677
00:25:54,640 --> 00:25:56,559
you see here that basically probably a

678
00:25:56,559 --> 00:25:58,000
user general holds

679
00:25:58,000 --> 00:26:00,880
you know four thousand and eight is the

680
00:26:00,880 --> 00:26:02,720
uh additional offset you know that we're

681
00:26:02,720 --> 00:26:04,880
actually dereferencing

682
00:26:04,880 --> 00:26:07,840
so that's the default and now what we

683
00:26:07,840 --> 00:26:09,679
like to do is you know

684
00:26:09,679 --> 00:26:14,159
do something slightly more sophisticated

685
00:26:14,159 --> 00:26:16,559
than we're currently doing and so let's

686
00:26:16,559 --> 00:26:22,830
go to proc

687
00:26:22,840 --> 00:26:27,269
trap.c

688
00:26:27,279 --> 00:26:30,000
and uh look at user trap right because

689
00:26:30,000 --> 00:26:34,470
this happens in user trap

690
00:26:34,480 --> 00:26:36,159
uh mutual trap is the function that we

691
00:26:36,159 --> 00:26:39,200
uh that robert discussed uh a week ago

692
00:26:39,200 --> 00:26:41,120
uh and you know just go through the

693
00:26:41,120 --> 00:26:42,400
different causes

694
00:26:42,400 --> 00:26:44,720
and perform some action so we're a

695
00:26:44,720 --> 00:26:45,520
little bit here

696
00:26:45,520 --> 00:26:48,080
uh this line is s-class is eight and you

697
00:26:48,080 --> 00:26:49,440
know that's the point we're gonna do

698
00:26:49,440 --> 00:26:51,360
process system calls

699
00:26:51,360 --> 00:26:53,039
uh then there's a line that checks

700
00:26:53,039 --> 00:26:55,279
whether it was any uh device interrupt

701
00:26:55,279 --> 00:26:56,880
and processes inside of the device

702
00:26:56,880 --> 00:26:57,760
interrupt

703
00:26:57,760 --> 00:26:59,360
and if there's none of those to happen

704
00:26:59,360 --> 00:27:01,520
then basically we get this trap

705
00:27:01,520 --> 00:27:03,919
and the process is being killed and

706
00:27:03,919 --> 00:27:05,120
basically what we need to do

707
00:27:05,120 --> 00:27:06,960
is you know we need to add some code

708
00:27:06,960 --> 00:27:10,000
here that you know checks

709
00:27:10,000 --> 00:27:12,320
uh for another case right basically i

710
00:27:12,320 --> 00:27:13,840
guess the case that we want to look for

711
00:27:13,840 --> 00:27:15,679
outlet is if

712
00:27:15,679 --> 00:27:22,630
uh our s cos is causing a

713
00:27:22,640 --> 00:27:27,430
is 15

714
00:27:27,440 --> 00:27:31,990
we want to do something else

715
00:27:32,000 --> 00:27:35,120
does that make sense so what do you want

716
00:27:35,120 --> 00:27:41,990
to do here

717
00:27:42,000 --> 00:27:44,000
what is sort of the plan for attack you

718
00:27:44,000 --> 00:27:50,389
know for these couple lines of code

719
00:27:50,399 --> 00:27:53,520
we want to check if p size

720
00:27:53,520 --> 00:27:57,760
is more than the virtual address

721
00:27:57,760 --> 00:28:00,799
not um in

722
00:28:00,799 --> 00:28:04,080
sd val perhaps yeah

723
00:28:04,080 --> 00:28:08,480
yeah yeah oh and this is the case then

724
00:28:08,480 --> 00:28:11,760
do something like uv

725
00:28:11,760 --> 00:28:15,039
um um malloc i think

726
00:28:15,039 --> 00:28:17,200
there's one way we could do it uh so i'm

727
00:28:17,200 --> 00:28:18,480
going to cut some corners just

728
00:28:18,480 --> 00:28:20,799
for the demo and uh presumably in the in

729
00:28:20,799 --> 00:28:22,000
the lab itself you will need to do a

730
00:28:22,000 --> 00:28:23,200
little bit more work

731
00:28:23,200 --> 00:28:26,080
uh but basically here's the sort of i

732
00:28:26,080 --> 00:28:26,559
think the

733
00:28:26,559 --> 00:28:30,000
frequent segment of code that we need

734
00:28:30,000 --> 00:28:34,080
so let's see where i was

735
00:28:34,080 --> 00:28:38,070
here's usually trap

736
00:28:38,080 --> 00:28:41,120
let me just kind of paste it into it

737
00:28:41,120 --> 00:28:43,600
and then we can look at it you know just

738
00:28:43,600 --> 00:28:45,279
a print statement for debugging uh and

739
00:28:45,279 --> 00:28:46,240
basically

740
00:28:46,240 --> 00:28:48,000
what i'm going to do in this handler i'm

741
00:28:48,000 --> 00:28:50,159
going to allocate the physical page

742
00:28:50,159 --> 00:28:52,320
uh if there's no physical pace meaning

743
00:28:52,320 --> 00:28:53,840
we're out of memory i'm just

744
00:28:53,840 --> 00:28:55,919
we're going to kill the process for now

745
00:28:55,919 --> 00:28:58,159
uh if there's a physical page you know

746
00:28:58,159 --> 00:28:59,760
we'll zero the page

747
00:28:59,760 --> 00:29:02,640
and then we just map the page at the

748
00:29:02,640 --> 00:29:03,760
appropriate address

749
00:29:03,760 --> 00:29:06,799
in the uh address space of the user

750
00:29:06,799 --> 00:29:09,600
in particular we map it on the rounded

751
00:29:09,600 --> 00:29:10,880
down virtual address

752
00:29:10,880 --> 00:29:13,279
right so the faulting address is 4008

753
00:29:13,279 --> 00:29:14,080
here

754
00:29:14,080 --> 00:29:16,559
uh and so that's eight bytes into you

755
00:29:16,559 --> 00:29:17,760
know the fifth page

756
00:29:17,760 --> 00:29:19,840
and we want to map that physical page at

757
00:29:19,840 --> 00:29:21,120
the bottom of the physical

758
00:29:21,120 --> 00:29:23,600
the virtual page so at four thousand so

759
00:29:23,600 --> 00:29:25,120
round it down to four thousand and then

760
00:29:25,120 --> 00:29:26,640
we map four files into this physical

761
00:29:26,640 --> 00:29:27,840
page

762
00:29:27,840 --> 00:29:29,200
and then of course we have to set the

763
00:29:29,200 --> 00:29:31,440
usual permission bits you know the ubid

764
00:29:31,440 --> 00:29:33,919
the read and write

765
00:29:33,919 --> 00:29:38,310
does that make sense

766
00:29:38,320 --> 00:29:42,470
yeah i guess i can get rid of this line

767
00:29:42,480 --> 00:29:49,750
uh so let's see let's try this out

768
00:29:49,760 --> 00:29:54,480
and i guess i made some mistakes

769
00:29:54,480 --> 00:29:56,399
i think that on the else you don't have

770
00:29:56,399 --> 00:29:59,360
an opening bracket at the bottom

771
00:29:59,360 --> 00:30:00,620
oh yeah

772
00:30:00,620 --> 00:30:03,120
[Music]

773
00:30:03,120 --> 00:30:06,840
no i do have it do i need one more oh

774
00:30:06,840 --> 00:30:08,040
yeah

775
00:30:08,040 --> 00:30:10,240
[Music]

776
00:30:10,240 --> 00:30:12,240
oh sorry i meant on the ls right here

777
00:30:12,240 --> 00:30:14,000
you don't have an opening bracket

778
00:30:14,000 --> 00:30:17,679
right like uh lenses else printf user

779
00:30:17,679 --> 00:30:18,880
trap

780
00:30:18,880 --> 00:30:24,630
unexpected cause thank you thank you

781
00:30:24,640 --> 00:30:27,520
hopefully it'll help a lot with

782
00:30:27,520 --> 00:30:29,679
excellence so echo high

783
00:30:29,679 --> 00:30:31,039
uh now of course we're going to be

784
00:30:31,039 --> 00:30:32,640
optimistic and we hope that works uh

785
00:30:32,640 --> 00:30:34,480
i'll tell you it won't work but

786
00:30:34,480 --> 00:30:36,640
uh but we did get two page faults right

787
00:30:36,640 --> 00:30:38,000
we got a page filled at four thousand

788
00:30:38,000 --> 00:30:39,360
eight you know apparently we practiced

789
00:30:39,360 --> 00:30:41,279
them because we got another page fault

790
00:30:41,279 --> 00:30:43,440
and so we only problem that we've left

791
00:30:43,440 --> 00:30:44,720
is there's a

792
00:30:44,720 --> 00:30:48,840
uvm app you know comes complaining that

793
00:30:48,840 --> 00:30:51,360
um

794
00:30:51,360 --> 00:30:52,880
it's complaining that there's some page

795
00:30:52,880 --> 00:30:54,720
that we're uh

796
00:30:54,720 --> 00:30:57,039
trying to unmap is actually not mapped

797
00:30:57,039 --> 00:31:02,470
and what could that be

798
00:31:02,480 --> 00:31:03,919
why would you think even we get this

799
00:31:03,919 --> 00:31:07,269
panic

800
00:31:07,279 --> 00:31:13,590
anybody

801
00:31:13,600 --> 00:31:16,840
what memory is being unmapped here most

802
00:31:16,840 --> 00:31:21,830
likely

803
00:31:21,840 --> 00:31:24,320
the one that was lazily allocated and

804
00:31:24,320 --> 00:31:26,000
not actually allocated

805
00:31:26,000 --> 00:31:27,760
yeah exactly you know the memory that

806
00:31:27,760 --> 00:31:29,360
was lazily allocated but actually

807
00:31:29,360 --> 00:31:31,200
hasn't been used yet right and so there

808
00:31:31,200 --> 00:31:32,720
is no physical page for that particular

809
00:31:32,720 --> 00:31:34,159
laserly memory

810
00:31:34,159 --> 00:31:39,120
and so uh this case when the pt is zero

811
00:31:39,120 --> 00:31:41,200
you know there's no mapping yet it's not

812
00:31:41,200 --> 00:31:42,640
really a panic you know this is actually

813
00:31:42,640 --> 00:31:44,240
what we expected you know it could

814
00:31:44,240 --> 00:31:44,840
happen

815
00:31:44,840 --> 00:31:47,519
right and in fact for that page we just

816
00:31:47,519 --> 00:31:48,559
don't have to do anything

817
00:31:48,559 --> 00:31:50,320
right we can just continue you know go

818
00:31:50,320 --> 00:31:53,509
to the next page

819
00:31:53,519 --> 00:31:58,640
does that make sense so let's do that

820
00:31:58,640 --> 00:32:00,720
and now let's do the echo high and boom

821
00:32:00,720 --> 00:32:02,320
we got two page faults and but high

822
00:32:02,320 --> 00:32:02,799
works

823
00:32:02,799 --> 00:32:06,240
and so we're basically uh uh

824
00:32:06,240 --> 00:32:08,799
you know have sort of a very basic

825
00:32:08,799 --> 00:32:09,600
minimal

826
00:32:09,600 --> 00:32:14,640
lazy allocation scheme working

827
00:32:14,640 --> 00:32:17,679
any questions about this sorry i didn't

828
00:32:17,679 --> 00:32:18,640
really follow

829
00:32:18,640 --> 00:32:20,799
why you could just continue uh could you

830
00:32:20,799 --> 00:32:22,000
explain that again

831
00:32:22,000 --> 00:32:25,760
yeah um so the

832
00:32:25,760 --> 00:32:28,320
the bug indicated that we had that we're

833
00:32:28,320 --> 00:32:29,760
trying to free page

834
00:32:29,760 --> 00:32:32,960
that actually is not mapped and

835
00:32:32,960 --> 00:32:34,559
you know how could that happen well the

836
00:32:34,559 --> 00:32:37,120
only reason that could happen is because

837
00:32:37,120 --> 00:32:40,640
s-break moved up key size

838
00:32:40,640 --> 00:32:42,320
but never used the application never

839
00:32:42,320 --> 00:32:44,159
used in that memory and so

840
00:32:44,159 --> 00:32:45,760
it actually has no mapping yet because

841
00:32:45,760 --> 00:32:47,519
it was actually not allocated

842
00:32:47,519 --> 00:32:48,960
right because we're lazily allocating

843
00:32:48,960 --> 00:32:50,640
we're only allocating physical memory

844
00:32:50,640 --> 00:32:51,760
for those pages

845
00:32:51,760 --> 00:32:54,000
when we need it if we didn't need it

846
00:32:54,000 --> 00:32:55,360
then there will be no mapping and so

847
00:32:55,360 --> 00:32:56,480
it's totally reasonable that there

848
00:32:56,480 --> 00:32:58,240
actually is going to be a case

849
00:32:58,240 --> 00:33:00,480
where there's no mapping for a virtual

850
00:33:00,480 --> 00:33:01,919
address because it actually wasn't

851
00:33:01,919 --> 00:33:03,120
allocated yet

852
00:33:03,120 --> 00:33:05,279
and for that case we just have to do

853
00:33:05,279 --> 00:33:06,960
nothing you know

854
00:33:06,960 --> 00:33:08,640
uh we can't free the page correctly

855
00:33:08,640 --> 00:33:10,320
there is no free page and so the best

856
00:33:10,320 --> 00:33:11,919
thing is to do continue and just go to

857
00:33:11,919 --> 00:33:12,720
the next page and

858
00:33:12,720 --> 00:33:15,760
look okay that makes sense

859
00:33:15,760 --> 00:33:17,760
thank you yeah we didn't know do

860
00:33:17,760 --> 00:33:19,120
continue but basically

861
00:33:19,120 --> 00:33:21,360
you know just kept going then we would

862
00:33:21,360 --> 00:33:25,669
actually free the page and i'll be

863
00:33:25,679 --> 00:33:27,679
that's why it continues there makes

864
00:33:27,679 --> 00:33:30,710
sense

865
00:33:30,720 --> 00:33:34,000
uh another question in

866
00:33:34,000 --> 00:33:37,120
uvm on map i assume the panic was that

867
00:33:37,120 --> 00:33:38,000
was there

868
00:33:38,000 --> 00:33:41,039
was there for a reason so a more correct

869
00:33:41,039 --> 00:33:43,039
a more reasonable implementation is to

870
00:33:43,039 --> 00:33:44,480
have two versions

871
00:33:44,480 --> 00:33:45,679
and we would use the one that doesn't

872
00:33:45,679 --> 00:33:48,080
panic yeah okay

873
00:33:48,080 --> 00:33:50,399
why was the uvm the panic there well

874
00:33:50,399 --> 00:33:52,640
there was basically an invariant

875
00:33:52,640 --> 00:33:55,039
that used to be true for the unmodified

876
00:33:55,039 --> 00:33:55,919
xv6

877
00:33:55,919 --> 00:33:57,919
right actually unmodified xc6 should

878
00:33:57,919 --> 00:33:59,519
never have a case where there's user

879
00:33:59,519 --> 00:34:01,360
memory that was not mapped

880
00:34:01,360 --> 00:34:03,279
and so therefore the panel goes up we

881
00:34:03,279 --> 00:34:05,440
now changed the design of xc6

882
00:34:05,440 --> 00:34:07,679
and so we have to just uh and this

883
00:34:07,679 --> 00:34:08,720
invariant is just not

884
00:34:08,720 --> 00:34:10,399
no longer true and so we've got to

885
00:34:10,399 --> 00:34:12,399
remove the panic and you know

886
00:34:12,399 --> 00:34:17,430
uh because anybody is just not true

887
00:34:17,440 --> 00:34:20,639
legitimately not true anymore

888
00:34:20,639 --> 00:34:23,669
i see thanks

889
00:34:23,679 --> 00:34:27,359
does this make sense so um

890
00:34:27,359 --> 00:34:30,639
so a couple of comments

891
00:34:30,639 --> 00:34:33,119
this will hopefully help a lot with the

892
00:34:33,119 --> 00:34:35,119
next lap in fact this is like one of the

893
00:34:35,119 --> 00:34:37,359
three components of the labs of the next

894
00:34:37,359 --> 00:34:38,960
lap so it's one of the first things you

895
00:34:38,960 --> 00:34:40,079
have to do

896
00:34:40,079 --> 00:34:41,599
and hopefully this will save you some

897
00:34:41,599 --> 00:34:43,599
time uh maybe make up for

898
00:34:43,599 --> 00:34:44,800
you know all the pain that you went

899
00:34:44,800 --> 00:34:47,520
through in the patrol to

900
00:34:47,520 --> 00:34:50,800
lab but clearly it's not enough

901
00:34:50,800 --> 00:34:53,839
right so like what things are you know

902
00:34:53,839 --> 00:34:55,200
we made these changes but more things

903
00:34:55,200 --> 00:35:00,950
are still probably broken

904
00:35:00,960 --> 00:35:02,640
now one radio was mentioned i actually

905
00:35:02,640 --> 00:35:04,480
didn't do the check whether actually the

906
00:35:04,480 --> 00:35:05,520
virtual address

907
00:35:05,520 --> 00:35:07,359
was below p size correct which we

908
00:35:07,359 --> 00:35:08,800
probably should do

909
00:35:08,800 --> 00:35:17,440
any other things that might be broken

910
00:35:17,440 --> 00:35:24,950
anybody

911
00:35:24,960 --> 00:35:27,200
the number of bytes to grow the process

912
00:35:27,200 --> 00:35:28,320
by an s break

913
00:35:28,320 --> 00:35:30,720
is an int and not an unsigned end so

914
00:35:30,720 --> 00:35:33,520
negative numbers could be used

915
00:35:33,520 --> 00:35:34,880
yes and then negative numbers can use

916
00:35:34,880 --> 00:35:36,079
and that means shrinking the address

917
00:35:36,079 --> 00:35:36,560
space

918
00:35:36,560 --> 00:35:38,079
right and so we shrink the address space

919
00:35:38,079 --> 00:35:40,079
we also have to be a little bit careful

920
00:35:40,079 --> 00:35:41,920
uh so it turns out there's a whole bunch

921
00:35:41,920 --> 00:35:43,440
of as usual uh

922
00:35:43,440 --> 00:35:44,560
in an operating system there are a whole

923
00:35:44,560 --> 00:35:46,079
bunch of different cases right where in

924
00:35:46,079 --> 00:35:46,880
which

925
00:35:46,880 --> 00:35:48,560
uh we're going to be looking at this

926
00:35:48,560 --> 00:35:50,079
particular page table entry

927
00:35:50,079 --> 00:35:51,520
and for all those different cases we

928
00:35:51,520 --> 00:35:53,200
might actually have to modify xj6

929
00:35:53,200 --> 00:35:54,320
slightly

930
00:35:54,320 --> 00:35:56,000
and and that's exactly what basically

931
00:35:56,000 --> 00:35:58,240
the lab is about is you know doing good

932
00:35:58,240 --> 00:35:59,839
enough job that basically you can pass

933
00:35:59,839 --> 00:36:00,880
user tests

934
00:36:00,880 --> 00:36:02,560
and user tests will stress a whole bunch

935
00:36:02,560 --> 00:36:03,920
of other cases that

936
00:36:03,920 --> 00:36:07,510
you will need to deal with

937
00:36:07,520 --> 00:36:11,270
okay

938
00:36:11,280 --> 00:36:18,230
any questions so far

939
00:36:18,240 --> 00:36:20,320
okay let me uh in that case i want to

940
00:36:20,320 --> 00:36:21,359
talk about a bunch of

941
00:36:21,359 --> 00:36:25,440
other usages or cool

942
00:36:25,440 --> 00:36:27,440
things you can do once you have page

943
00:36:27,440 --> 00:36:29,359
faults and page tables and you update

944
00:36:29,359 --> 00:36:31,599
them dynamically

945
00:36:31,599 --> 00:36:34,960
another one that is almost trivial

946
00:36:34,960 --> 00:36:38,400
but you know commonly used is

947
00:36:38,400 --> 00:36:42,470
what's called zero fill

948
00:36:42,480 --> 00:36:51,270
zero fill on demand

949
00:36:51,280 --> 00:36:54,320
uh it turns out that in uh

950
00:36:54,320 --> 00:36:55,760
operating systems you know there are

951
00:36:55,760 --> 00:36:58,160
many null pages um

952
00:36:58,160 --> 00:37:01,040
and uh so for example if you look at the

953
00:37:01,040 --> 00:37:01,280
uh

954
00:37:01,280 --> 00:37:04,480
an address space in user space uh

955
00:37:04,480 --> 00:37:06,800
you know xp6 doesn't really is not

956
00:37:06,800 --> 00:37:08,800
advanced uh but like if you look at the

957
00:37:08,800 --> 00:37:10,640
layout of the binary

958
00:37:10,640 --> 00:37:12,240
uh and ain't it out you know there's

959
00:37:12,240 --> 00:37:14,160
some text there's what's called the data

960
00:37:14,160 --> 00:37:15,040
segment

961
00:37:15,040 --> 00:37:16,400
and there is typically also about

962
00:37:16,400 --> 00:37:20,950
something that's called the bss segment

963
00:37:20,960 --> 00:37:22,480
and so when the compiler you know

964
00:37:22,480 --> 00:37:24,079
produces uh

965
00:37:24,079 --> 00:37:25,599
the binary you know basically fills in

966
00:37:25,599 --> 00:37:27,440
these three segments the text is you

967
00:37:27,440 --> 00:37:28,400
know the instructions

968
00:37:28,400 --> 00:37:30,079
no the data is basically global

969
00:37:30,079 --> 00:37:32,000
variables that actually have a value

970
00:37:32,000 --> 00:37:35,440
that is not zero so an initialized uh

971
00:37:35,440 --> 00:37:41,829
data

972
00:37:41,839 --> 00:37:44,240
and bbzs is basically a description that

973
00:37:44,240 --> 00:37:44,960
says

974
00:37:44,960 --> 00:37:46,640
well there's a whole bunch of variables

975
00:37:46,640 --> 00:37:48,720
and at least basically their sizes

976
00:37:48,720 --> 00:37:51,839
and they also be zero and the reason

977
00:37:51,839 --> 00:37:53,200
that they're basically not

978
00:37:53,200 --> 00:37:55,680
listed out you know or the memory is not

979
00:37:55,680 --> 00:37:57,119
right there in the file is because you

980
00:37:57,119 --> 00:37:57,920
know that'll save

981
00:37:57,920 --> 00:37:59,040
a lot of you know for example if you

982
00:37:59,040 --> 00:38:01,359
declare a big matrix in c

983
00:38:01,359 --> 00:38:02,720
on the top of the file as a global

984
00:38:02,720 --> 00:38:04,480
variable and it's automatically going to

985
00:38:04,480 --> 00:38:06,160
distribute all zeros

986
00:38:06,160 --> 00:38:08,560
why allocate all that space in the file

987
00:38:08,560 --> 00:38:10,240
uh just like note that basically you

988
00:38:10,240 --> 00:38:11,760
know for this particular variable

989
00:38:11,760 --> 00:38:13,599
you know the in the content should be

990
00:38:13,599 --> 00:38:15,200
zero

991
00:38:15,200 --> 00:38:17,280
and then basically on exec on a normal

992
00:38:17,280 --> 00:38:18,800
operating system on exec

993
00:38:18,800 --> 00:38:22,720
you know we'll look at these three uh uh

994
00:38:22,720 --> 00:38:24,480
segments and that's the usual thing that

995
00:38:24,480 --> 00:38:26,720
xv6 does you know for text and data

996
00:38:26,720 --> 00:38:28,640
but they're from bess you know it will

997
00:38:28,640 --> 00:38:29,839
allocate you know

998
00:38:29,839 --> 00:38:32,560
memory uh to hold the bss and basically

999
00:38:32,560 --> 00:38:34,000
stick zeros in there

1000
00:38:34,000 --> 00:38:37,680
so you know allocate an address space

1001
00:38:37,680 --> 00:38:40,000
takes the data in it and sticks to avoid

1002
00:38:40,000 --> 00:38:41,680
it and then you know basically

1003
00:38:41,680 --> 00:38:45,200
uh you know the equivalent of the bzs

1004
00:38:45,200 --> 00:38:46,000
you know all the global

1005
00:38:46,000 --> 00:38:47,280
variables that are basically zero and

1006
00:38:47,280 --> 00:38:51,349
there may be many many pages

1007
00:38:51,359 --> 00:38:52,720
and all those pages basically have to

1008
00:38:52,720 --> 00:38:55,440
have the content zero

1009
00:38:55,440 --> 00:38:57,040
so that's the virtual address space and

1010
00:38:57,040 --> 00:38:58,960
so typical trick you know to do is to

1011
00:38:58,960 --> 00:38:59,839
say like wow

1012
00:38:59,839 --> 00:39:01,359
i got so many pages that need to have

1013
00:39:01,359 --> 00:39:02,960
zero what i'm going to do

1014
00:39:02,960 --> 00:39:06,000
in physical memory this is the virtual

1015
00:39:06,000 --> 00:39:07,200
address space

1016
00:39:07,200 --> 00:39:08,800
and it's the physical address you know

1017
00:39:08,800 --> 00:39:11,119
memory uh what i'm going to really do is

1018
00:39:11,119 --> 00:39:14,240
i'm just going to allocate one zero page

1019
00:39:14,240 --> 00:39:16,720
i fill it with zeros and basically map

1020
00:39:16,720 --> 00:39:18,480
all the other pages

1021
00:39:18,480 --> 00:39:24,069
to that one page

1022
00:39:24,079 --> 00:39:26,560
you know saving myself you know lots you

1023
00:39:26,560 --> 00:39:28,000
know lots of physical memory at least at

1024
00:39:28,000 --> 00:39:29,440
startup

1025
00:39:29,440 --> 00:39:31,280
um and of course those mappings has to

1026
00:39:31,280 --> 00:39:33,599
be limit care uh dominance care

1027
00:39:33,599 --> 00:39:36,000
we can't market you know we cannot allow

1028
00:39:36,000 --> 00:39:37,599
rights to it right because everybody's

1029
00:39:37,599 --> 00:39:38,880
relying on the fact that it actually

1030
00:39:38,880 --> 00:39:39,599
stays zero

1031
00:39:39,599 --> 00:39:43,359
so we just map it read only

1032
00:39:43,359 --> 00:39:44,960
and then at some point when an

1033
00:39:44,960 --> 00:39:47,440
application starts writing to one of you

1034
00:39:47,440 --> 00:39:48,000
know the

1035
00:39:48,000 --> 00:39:49,839
basically starts it doesn't load or

1036
00:39:49,839 --> 00:39:51,440
store to one of the

1037
00:39:51,440 --> 00:39:54,480
pages that actually are part of the vess

1038
00:39:54,480 --> 00:39:55,839
so because it wants you to you know

1039
00:39:55,839 --> 00:39:57,760
whatever store one or two variable

1040
00:39:57,760 --> 00:39:58,720
content in there

1041
00:39:58,720 --> 00:40:06,230
and we're going to get a page fault

1042
00:40:06,240 --> 00:40:08,839
and so what should we do on the page

1043
00:40:08,839 --> 00:40:10,480
fault

1044
00:40:10,480 --> 00:40:15,109
in this particular case

1045
00:40:15,119 --> 00:40:23,750
anybody

1046
00:40:23,760 --> 00:40:26,800
go ahead anybody idea what should we do

1047
00:40:26,800 --> 00:40:28,480
in the page fault here

1048
00:40:28,480 --> 00:40:31,599
i think we should make a new page

1049
00:40:31,599 --> 00:40:35,280
and uh write zeros there and rerun the

1050
00:40:35,280 --> 00:40:36,400
instruction

1051
00:40:36,400 --> 00:40:38,560
yeah exactly so let's let's assume this

1052
00:40:38,560 --> 00:40:40,160
for my drawing that actually the

1053
00:40:40,160 --> 00:40:41,839
uh store instruction happened to the one

1054
00:40:41,839 --> 00:40:43,280
at the top

1055
00:40:43,280 --> 00:40:44,640
and what we really want to do basically

1056
00:40:44,640 --> 00:40:46,880
is allocate a new physical page a new

1057
00:40:46,880 --> 00:40:48,880
page in memory you know catalog put

1058
00:40:48,880 --> 00:40:50,000
zeros in there because

1059
00:40:50,000 --> 00:40:51,680
that's what we're expecting and then we

1060
00:40:51,680 --> 00:40:53,040
can change the top

1061
00:40:53,040 --> 00:40:54,560
mapping right for the one for this

1062
00:40:54,560 --> 00:40:57,040
particular because for this guy

1063
00:40:57,040 --> 00:40:59,440
uh or let me assume that this is this

1064
00:40:59,440 --> 00:41:01,520
one we can change this mapping you know

1065
00:41:01,520 --> 00:41:02,000
to be

1066
00:41:02,000 --> 00:41:06,000
read write and point it to

1067
00:41:06,000 --> 00:41:11,829
the new page

1068
00:41:11,839 --> 00:41:15,440
and then you know basically so copy

1069
00:41:15,440 --> 00:41:20,720
let's update pte and then restart the

1070
00:41:20,720 --> 00:41:28,630
structure

1071
00:41:28,640 --> 00:41:33,280
and that's it why is this ineffective

1072
00:41:33,280 --> 00:41:34,480
why do you think this is actually in

1073
00:41:34,480 --> 00:41:39,670
good optimization

1074
00:41:39,680 --> 00:41:49,200
why do operating systems do it

1075
00:41:49,200 --> 00:41:52,309
anybody

1076
00:41:52,319 --> 00:41:57,119
you don't need it yeah um

1077
00:41:57,119 --> 00:41:59,200
you don't need to use as much memory as

1078
00:41:59,200 --> 00:42:01,440
the user requested so it's just better

1079
00:42:01,440 --> 00:42:02,560
to um

1080
00:42:02,560 --> 00:42:05,119
bill it when it when you need it yeah

1081
00:42:05,119 --> 00:42:05,680
actually

1082
00:42:05,680 --> 00:42:07,359
similar like to the lazy allocation

1083
00:42:07,359 --> 00:42:09,040
basically if the

1084
00:42:09,040 --> 00:42:12,079
program say allocated a huge array you

1085
00:42:12,079 --> 00:42:14,800
know for the worst possible input

1086
00:42:14,800 --> 00:42:16,240
it's a global array it all has to be

1087
00:42:16,240 --> 00:42:17,760
zeros but maybe the only fraction is

1088
00:42:17,760 --> 00:42:19,200
being used

1089
00:42:19,200 --> 00:42:28,790
right what's the second advantage

1090
00:42:28,800 --> 00:42:30,079
second advantage you have to do less

1091
00:42:30,079 --> 00:42:32,079
work in exec right and so

1092
00:42:32,079 --> 00:42:34,560
the program may start quicker and get

1093
00:42:34,560 --> 00:42:36,160
basically better interactive performance

1094
00:42:36,160 --> 00:42:37,520
okay because you don't really have to

1095
00:42:37,520 --> 00:42:38,800
allocate memory you don't really have a

1096
00:42:38,800 --> 00:42:40,160
zero memory you only have to allocate

1097
00:42:40,160 --> 00:42:41,359
the zero to one page

1098
00:42:41,359 --> 00:42:42,480
and the rest is you know you're just

1099
00:42:42,480 --> 00:42:44,400
mapping the page table so you just have

1100
00:42:44,400 --> 00:42:47,119
to write the pte entries

1101
00:42:47,119 --> 00:42:50,880
does that make sense but aren't

1102
00:42:50,880 --> 00:42:54,150
updates or writes

1103
00:42:54,160 --> 00:42:56,720
so they will become slower because every

1104
00:42:56,720 --> 00:42:57,200
time

1105
00:42:57,200 --> 00:43:00,319
a page fall will occur and yeah so you

1106
00:43:00,319 --> 00:43:01,760
know there's absolutely a good point

1107
00:43:01,760 --> 00:43:04,079
uh so we basically postpone some of the

1108
00:43:04,079 --> 00:43:04,960
cost to later

1109
00:43:04,960 --> 00:43:07,760
right um at the point that we do the

1110
00:43:07,760 --> 00:43:08,880
page fault

1111
00:43:08,880 --> 00:43:11,200
and you know we're partially relying or

1112
00:43:11,200 --> 00:43:12,640
hoping that maybe not all the pages are

1113
00:43:12,640 --> 00:43:13,760
being used

1114
00:43:13,760 --> 00:43:15,839
uh but like for example if the page is

1115
00:43:15,839 --> 00:43:18,480
496 496 bytes

1116
00:43:18,480 --> 00:43:19,839
uh you know basically we're gonna take

1117
00:43:19,839 --> 00:43:22,079
one page wall per four thousand ninety

1118
00:43:22,079 --> 00:43:22,400
six

1119
00:43:22,400 --> 00:43:25,280
zeros right and so do some rotation

1120
00:43:25,280 --> 00:43:27,680
there

1121
00:43:27,680 --> 00:43:29,359
but it's a good great point you know

1122
00:43:29,359 --> 00:43:30,640
certainly we have made paint we have

1123
00:43:30,640 --> 00:43:31,280
income

1124
00:43:31,280 --> 00:43:33,359
we have added the cost of the page fault

1125
00:43:33,359 --> 00:43:34,720
how much is the cost of the page fault

1126
00:43:34,720 --> 00:43:35,520
how

1127
00:43:35,520 --> 00:43:38,319
how should we think about that is that

1128
00:43:38,319 --> 00:43:39,119
comparable to

1129
00:43:39,119 --> 00:43:41,119
store instruction or is much more

1130
00:43:41,119 --> 00:43:48,630
expensive

1131
00:43:48,640 --> 00:43:52,640
more expensive right yeah why

1132
00:43:52,640 --> 00:43:56,319
well a store will just uh

1133
00:43:56,319 --> 00:43:59,040
like need to require it will take some

1134
00:43:59,040 --> 00:43:59,680
time to

1135
00:43:59,680 --> 00:44:02,960
get through the to ram but the

1136
00:44:02,960 --> 00:44:05,520
fault will have to go to the cornell

1137
00:44:05,520 --> 00:44:06,079
yeah

1138
00:44:06,079 --> 00:44:08,319
so in fact how many store instructions

1139
00:44:08,319 --> 00:44:10,079
were there even in the

1140
00:44:10,079 --> 00:44:12,160
uh the trap handling code that robert

1141
00:44:12,160 --> 00:44:13,520
showed you last week

1142
00:44:13,520 --> 00:44:15,200
or actually that you're doing currently

1143
00:44:15,200 --> 00:44:19,430
in the uh trap block

1144
00:44:19,440 --> 00:44:22,319
uh well oh at least like a hundred yeah

1145
00:44:22,319 --> 00:44:23,680
at least a hundred current used to save

1146
00:44:23,680 --> 00:44:25,680
restore registers

1147
00:44:25,680 --> 00:44:27,200
uh so there's quite a bit and so there's

1148
00:44:27,200 --> 00:44:28,720
the both the overhead of

1149
00:44:28,720 --> 00:44:30,480
transferring from user space to kernel

1150
00:44:30,480 --> 00:44:32,240
space as well like all the instructions

1151
00:44:32,240 --> 00:44:33,760
that are being executed

1152
00:44:33,760 --> 00:44:37,200
uh to save and restore state so the page

1153
00:44:37,200 --> 00:44:38,319
fault is definitely not

1154
00:44:38,319 --> 00:44:40,319
free so the question that was asked

1155
00:44:40,319 --> 00:44:45,510
earlier is a very good question

1156
00:44:45,520 --> 00:44:48,880
okay so let's uh look at some more

1157
00:44:48,880 --> 00:44:52,160
uh optimizations that one can do

1158
00:44:52,160 --> 00:44:54,160
these ones are sort of reasonably boring

1159
00:44:54,160 --> 00:44:56,079
or maybe reasonable straightforward

1160
00:44:56,079 --> 00:44:58,400
uh and we're gonna hopefully get a

1161
00:44:58,400 --> 00:44:59,359
little bit more

1162
00:44:59,359 --> 00:45:02,480
a couple more exciting ones

1163
00:45:02,480 --> 00:45:05,119
let's see what's next one i wanted to do

1164
00:45:05,119 --> 00:45:05,680
uh

1165
00:45:05,680 --> 00:45:09,280
next one is a very common one uh

1166
00:45:09,280 --> 00:45:10,960
many operating systems implemented and

1167
00:45:10,960 --> 00:45:12,960
in fact it will also be one of the

1168
00:45:12,960 --> 00:45:14,079
topics in

1169
00:45:14,079 --> 00:45:19,119
one of the labs so let's do the next one

1170
00:45:19,119 --> 00:45:22,400
uh and that is copy

1171
00:45:22,400 --> 00:45:27,670
on the right fork

1172
00:45:27,680 --> 00:45:34,950
or something it's called cow fork

1173
00:45:34,960 --> 00:45:38,079
um and you know the uh

1174
00:45:38,079 --> 00:45:39,920
the observation uh is you know pretty

1175
00:45:39,920 --> 00:45:41,520
straightforward in fact we made

1176
00:45:41,520 --> 00:45:42,800
this observation a couple times in

1177
00:45:42,800 --> 00:45:45,119
lecture um

1178
00:45:45,119 --> 00:45:48,630
but when uh

1179
00:45:48,640 --> 00:45:50,319
let's say you know the shell right there

1180
00:45:50,319 --> 00:45:52,560
we were in fact shot in a second ago

1181
00:45:52,560 --> 00:45:54,640
it's like if the shell runs

1182
00:45:54,640 --> 00:45:57,599
and it processes a command it actually

1183
00:45:57,599 --> 00:45:58,319
does a fork

1184
00:45:58,319 --> 00:46:01,520
to create a child and so the fork you

1185
00:46:01,520 --> 00:46:02,960
know basically creates a copy of the

1186
00:46:02,960 --> 00:46:04,079
shell

1187
00:46:04,079 --> 00:46:05,520
and so we've got a parent and we've got

1188
00:46:05,520 --> 00:46:07,760
the child and then the child of almost

1189
00:46:07,760 --> 00:46:09,200
one of the first things it does is an

1190
00:46:09,200 --> 00:46:09,760
exit

1191
00:46:09,760 --> 00:46:10,880
and then you execute a couple

1192
00:46:10,880 --> 00:46:13,200
instructions and then it actually exits

1193
00:46:13,200 --> 00:46:16,790
you know for example to run echo

1194
00:46:16,800 --> 00:46:19,920
and as we now know uh

1195
00:46:19,920 --> 00:46:21,680
in the last lap you know the fork

1196
00:46:21,680 --> 00:46:22,960
creates a complete duplicate

1197
00:46:22,960 --> 00:46:25,520
of the shell address space and then

1198
00:46:25,520 --> 00:46:26,800
exactly the first thing it basically

1199
00:46:26,800 --> 00:46:28,800
does it you know throws that away

1200
00:46:28,800 --> 00:46:30,720
and then replaces it with an address

1201
00:46:30,720 --> 00:46:33,040
face you know containing echo

1202
00:46:33,040 --> 00:46:35,680
and so it seems slightly wasteful right

1203
00:46:35,680 --> 00:46:37,520
like you know so here let's say we have

1204
00:46:37,520 --> 00:46:38,400
our

1205
00:46:38,400 --> 00:46:41,760
parent virtual dress space

1206
00:46:41,760 --> 00:46:46,069
and then here we have the child

1207
00:46:46,079 --> 00:46:48,960
and what we're actually doing and here's

1208
00:46:48,960 --> 00:46:52,870
physical memory

1209
00:46:52,880 --> 00:46:55,040
and in the normal case in xv6 or in

1210
00:46:55,040 --> 00:46:56,560
unmodified xv6

1211
00:46:56,560 --> 00:46:57,680
you know there's a bunch of like there

1212
00:46:57,680 --> 00:46:59,599
were four pages we saw

1213
00:46:59,599 --> 00:47:02,319
that the shell has one two three four

1214
00:47:02,319 --> 00:47:03,040
and

1215
00:47:03,040 --> 00:47:06,319
uh you know when we start when a fork

1216
00:47:06,319 --> 00:47:08,880
uh runs it basically gets a duplicate of

1217
00:47:08,880 --> 00:47:10,000
those four pages one

1218
00:47:10,000 --> 00:47:12,319
two three four and copies all the

1219
00:47:12,319 --> 00:47:13,200
content

1220
00:47:13,200 --> 00:47:15,440
you know from those pages the parenting

1221
00:47:15,440 --> 00:47:17,119
to the child

1222
00:47:17,119 --> 00:47:20,640
um and you know then as soon as exit

1223
00:47:20,640 --> 00:47:21,920
happens basically we're going to free

1224
00:47:21,920 --> 00:47:23,440
these pages

1225
00:47:23,440 --> 00:47:25,760
and allocate new pages to actually have

1226
00:47:25,760 --> 00:47:28,079
the content of echo in it

1227
00:47:28,079 --> 00:47:31,680
so a good optimization one that actually

1228
00:47:31,680 --> 00:47:33,200
tends to be very effective

1229
00:47:33,200 --> 00:47:35,599
for this particular sequence is that you

1230
00:47:35,599 --> 00:47:36,960
know if we

1231
00:47:36,960 --> 00:47:39,440
uh if the parent has these four mappings

1232
00:47:39,440 --> 00:47:41,839
you know in its address space

1233
00:47:41,839 --> 00:47:43,680
you know going from whatever the zero

1234
00:47:43,680 --> 00:47:45,920
goes here the first one goes there

1235
00:47:45,920 --> 00:47:49,200
and whatever instead you know when we

1236
00:47:49,200 --> 00:47:50,720
create the child address space instead

1237
00:47:50,720 --> 00:47:52,319
of creating copying and allocating new

1238
00:47:52,319 --> 00:47:53,200
physical memory

1239
00:47:53,200 --> 00:47:56,160
what we could do is just share the

1240
00:47:56,160 --> 00:47:57,040
physical pages

1241
00:47:57,040 --> 00:47:59,280
that the parent actually already has

1242
00:47:59,280 --> 00:48:00,400
allocated

1243
00:48:00,400 --> 00:48:02,800
and so we can just set the pte's for the

1244
00:48:02,800 --> 00:48:04,240
child you know to the same

1245
00:48:04,240 --> 00:48:06,400
pointing to the same physical pages as

1246
00:48:06,400 --> 00:48:08,559
in the parent

1247
00:48:08,559 --> 00:48:09,599
and we're going to be a little bit

1248
00:48:09,599 --> 00:48:11,119
careful again correct because if the

1249
00:48:11,119 --> 00:48:11,599
child

1250
00:48:11,599 --> 00:48:14,559
wants to modify one of these pages that

1251
00:48:14,559 --> 00:48:15,599
update should not be

1252
00:48:15,599 --> 00:48:17,359
visible to the parent because we want

1253
00:48:17,359 --> 00:48:18,960
strong isolation between the parent and

1254
00:48:18,960 --> 00:48:20,480
child so we need to be a little bit more

1255
00:48:20,480 --> 00:48:21,280
careful

1256
00:48:21,280 --> 00:48:22,880
so to be a little bit more careful now

1257
00:48:22,880 --> 00:48:25,440
what we can do is just map those pages

1258
00:48:25,440 --> 00:48:28,079
both in the child and in the parent

1259
00:48:28,079 --> 00:48:32,870
read-only

1260
00:48:32,880 --> 00:48:34,800
and then of course we're going to get a

1261
00:48:34,800 --> 00:48:36,640
page fault at some point

1262
00:48:36,640 --> 00:48:37,920
because the parent is going to run or

1263
00:48:37,920 --> 00:48:40,160
the child is going to run

1264
00:48:40,160 --> 00:48:43,359
and uh and maybe you know the child or

1265
00:48:43,359 --> 00:48:44,240
the parent will

1266
00:48:44,240 --> 00:48:46,880
do a store instruction to maybe save the

1267
00:48:46,880 --> 00:48:47,599
data

1268
00:48:47,599 --> 00:48:50,000
to some global variable or somewhere and

1269
00:48:50,000 --> 00:48:51,280
at that point you know where

1270
00:48:51,280 --> 00:48:53,119
the that will cause a page fault because

1271
00:48:53,119 --> 00:48:54,880
you know we're writing to a page that is

1272
00:48:54,880 --> 00:48:55,359
mapped

1273
00:48:55,359 --> 00:48:57,520
only so we get a page fault and so what

1274
00:48:57,520 --> 00:48:58,880
do we need to do well we need to make a

1275
00:48:58,880 --> 00:49:03,040
copy of the page

1276
00:49:03,040 --> 00:49:05,280
so let's assume that it's the child that

1277
00:49:05,280 --> 00:49:06,319
actually uh

1278
00:49:06,319 --> 00:49:08,319
does the story instruction so we

1279
00:49:08,319 --> 00:49:10,319
allocate a new page

1280
00:49:10,319 --> 00:49:13,440
uh we copy you know the content

1281
00:49:13,440 --> 00:49:16,240
uh off the page that were faulted on

1282
00:49:16,240 --> 00:49:17,760
into this new page

1283
00:49:17,760 --> 00:49:20,559
we mapped that page into the child and

1284
00:49:20,559 --> 00:49:21,359
this time we can

1285
00:49:21,359 --> 00:49:22,960
happen to read write because it's now

1286
00:49:22,960 --> 00:49:24,960
private page only you know visible in

1287
00:49:24,960 --> 00:49:26,559
the child's address space

1288
00:49:26,559 --> 00:49:28,319
and in fact the page that will actually

1289
00:49:28,319 --> 00:49:30,240
be folded on we can also now map read

1290
00:49:30,240 --> 00:49:31,200
write

1291
00:49:31,200 --> 00:49:35,280
into the parent and so we copy the page

1292
00:49:35,280 --> 00:49:44,880
map it and restart the instruction

1293
00:49:44,880 --> 00:49:46,240
and when restarting instruction really

1294
00:49:46,240 --> 00:49:48,240
means you know doing user read you know

1295
00:49:48,240 --> 00:49:51,040
the same way that uh we returned to user

1296
00:49:51,040 --> 00:49:51,920
space

1297
00:49:51,920 --> 00:49:56,549
uh in uh last week's lecture

1298
00:49:56,559 --> 00:49:58,400
does this make sense any questions about

1299
00:49:58,400 --> 00:49:59,680
this one

1300
00:49:59,680 --> 00:50:02,640
i'm sorry um when you say we mapped the

1301
00:50:02,640 --> 00:50:03,839
parents

1302
00:50:03,839 --> 00:50:07,280
um virtual address to we also

1303
00:50:07,280 --> 00:50:10,160
read write uh how do we find it out is

1304
00:50:10,160 --> 00:50:10,960
it the same as

1305
00:50:10,960 --> 00:50:13,680
the child's oh yeah because the the

1306
00:50:13,680 --> 00:50:15,520
dress space of the child is a duplicate

1307
00:50:15,520 --> 00:50:16,559
of the

1308
00:50:16,559 --> 00:50:19,440
apparent address space right so if we

1309
00:50:19,440 --> 00:50:21,599
fall to the particular virtual dress

1310
00:50:21,599 --> 00:50:23,440
since the address spaces are equal you

1311
00:50:23,440 --> 00:50:25,599
know the it's the same virtual address

1312
00:50:25,599 --> 00:50:26,480
both in the parent's

1313
00:50:26,480 --> 00:50:28,160
address space and in the child's address

1314
00:50:28,160 --> 00:50:31,510
space

1315
00:50:31,520 --> 00:50:36,710
makes sense thank you

1316
00:50:36,720 --> 00:50:40,960
another question for let's say

1317
00:50:40,960 --> 00:50:44,319
like some parentless process maybe like

1318
00:50:44,319 --> 00:50:46,160
the first one that launches

1319
00:50:46,160 --> 00:50:49,440
does it use its pages

1320
00:50:49,440 --> 00:50:52,640
does it set just read permissions or

1321
00:50:52,640 --> 00:50:54,000
does it start off with read

1322
00:50:54,000 --> 00:50:56,640
write well we can and when it forks it

1323
00:50:56,640 --> 00:50:57,920
modifies

1324
00:50:57,920 --> 00:51:01,440
yeah okay it's up to you in fact

1325
00:51:01,440 --> 00:51:04,480
this is also one lap uh you're gonna

1326
00:51:04,480 --> 00:51:05,760
implement copy and write

1327
00:51:05,760 --> 00:51:08,640
uh after the lazy lab uh and you know

1328
00:51:08,640 --> 00:51:09,920
you have some freedom you know the easy

1329
00:51:09,920 --> 00:51:11,520
thing to do is just also map it read

1330
00:51:11,520 --> 00:51:12,319
only

1331
00:51:12,319 --> 00:51:14,400
you will get a page fault and then

1332
00:51:14,400 --> 00:51:16,240
you'll do whatever you normally also

1333
00:51:16,240 --> 00:51:17,920
would do in the copy and write

1334
00:51:17,920 --> 00:51:20,240
so you can use the same mechanism in

1335
00:51:20,240 --> 00:51:22,720
both cases

1336
00:51:22,720 --> 00:51:24,319
there's no reason to actually specialize

1337
00:51:24,319 --> 00:51:26,319
or do something

1338
00:51:26,319 --> 00:51:29,990
separate for the first process

1339
00:51:30,000 --> 00:51:33,839
okay thanks so um

1340
00:51:33,839 --> 00:51:36,720
i also have a question um given that we

1341
00:51:36,720 --> 00:51:38,000
like kind of copy

1342
00:51:38,000 --> 00:51:41,040
whole tables sorry whole pages around

1343
00:51:41,040 --> 00:51:44,319
pretty often um does

1344
00:51:44,319 --> 00:51:47,359
any like memory hardware implement

1345
00:51:47,359 --> 00:51:49,280
like a specific instruction because

1346
00:51:49,280 --> 00:51:50,640
basically memory

1347
00:51:50,640 --> 00:51:52,800
hardware will usually just have like

1348
00:51:52,800 --> 00:51:54,240
some data lines to say

1349
00:51:54,240 --> 00:51:57,680
read me or store this memory

1350
00:51:57,680 --> 00:52:00,559
because we have like oh copy page a to

1351
00:52:00,559 --> 00:52:02,480
page b

1352
00:52:02,480 --> 00:52:05,440
yeah there's a x86 for example has uh

1353
00:52:05,440 --> 00:52:07,040
hardware instructions for copying

1354
00:52:07,040 --> 00:52:08,559
rangers memory

1355
00:52:08,559 --> 00:52:12,160
uh you know vs5 doesn't uh

1356
00:52:12,160 --> 00:52:15,839
uh but of course you know in a very high

1357
00:52:15,839 --> 00:52:17,520
performance implementation

1358
00:52:17,520 --> 00:52:20,319
uh the all these recent rights will be

1359
00:52:20,319 --> 00:52:22,000
pipelined

1360
00:52:22,000 --> 00:52:23,760
and you know hopefully run at the speed

1361
00:52:23,760 --> 00:52:28,150
of the memory bandwidth

1362
00:52:28,160 --> 00:52:30,319
note that actually uh you know in

1363
00:52:30,319 --> 00:52:32,160
principle we might be lucky and we're

1364
00:52:32,160 --> 00:52:33,359
saving correct on

1365
00:52:33,359 --> 00:52:35,599
loads and stores or copies because in

1366
00:52:35,599 --> 00:52:36,720
this particular picture

1367
00:52:36,720 --> 00:52:39,200
i made only one copy and in the

1368
00:52:39,200 --> 00:52:41,280
unmodified case we would have copied all

1369
00:52:41,280 --> 00:52:43,040
four pages

1370
00:52:43,040 --> 00:52:44,480
and so hopefully you know this is just

1371
00:52:44,480 --> 00:52:46,319
like strictly better both in terms of

1372
00:52:46,319 --> 00:52:47,520
memory consumption and

1373
00:52:47,520 --> 00:52:49,040
in terms of performance you know fork

1374
00:52:49,040 --> 00:52:53,990
will just be faster

1375
00:52:54,000 --> 00:52:57,440
i have a quick question um when

1376
00:52:57,440 --> 00:53:00,000
when the page fault occurs and and we

1377
00:53:00,000 --> 00:53:00,559
see that

1378
00:53:00,559 --> 00:53:02,640
like it was it was essentially like we

1379
00:53:02,640 --> 00:53:04,079
were trying to write to a read-only

1380
00:53:04,079 --> 00:53:04,800
address

1381
00:53:04,800 --> 00:53:07,599
um how does the colonel tell uh like

1382
00:53:07,599 --> 00:53:08,480
that this is a

1383
00:53:08,480 --> 00:53:10,400
situation where it's copy on right fork

1384
00:53:10,400 --> 00:53:12,240
versus just a situation where the memory

1385
00:53:12,240 --> 00:53:13,920
it was trying to write was was marked as

1386
00:53:13,920 --> 00:53:15,440
read only for some

1387
00:53:15,440 --> 00:53:17,200
like legitimate reason other than copy

1388
00:53:17,200 --> 00:53:18,640
on right fork is it just kind of an

1389
00:53:18,640 --> 00:53:19,280
invariant

1390
00:53:19,280 --> 00:53:22,000
that if if uh if it's user memory then

1391
00:53:22,000 --> 00:53:23,920
it will be mapped read write unless it

1392
00:53:23,920 --> 00:53:25,760
was a result of copy on port

1393
00:53:25,760 --> 00:53:29,200
yeah right so it is a an invariant that

1394
00:53:29,200 --> 00:53:30,720
needs to be maintained in the kernel and

1395
00:53:30,720 --> 00:53:31,119
the

1396
00:53:31,119 --> 00:53:32,880
kernel must recognize in some way that

1397
00:53:32,880 --> 00:53:34,400
this is a copy and write page if you

1398
00:53:34,400 --> 00:53:35,280
will

1399
00:53:35,280 --> 00:53:37,119
um and so i'm very glad you asked a

1400
00:53:37,119 --> 00:53:39,280
question because uh turns out you know

1401
00:53:39,280 --> 00:53:41,280
the risk five hardware almost all page

1402
00:53:41,280 --> 00:53:42,000
table hardware

1403
00:53:42,000 --> 00:53:45,119
actually has support for this uh and we

1404
00:53:45,119 --> 00:53:46,559
didn't mention that earlier but here's

1405
00:53:46,559 --> 00:53:47,040
our

1406
00:53:47,040 --> 00:53:48,960
you know our usual you know whatever two

1407
00:53:48,960 --> 00:53:51,920
level uh or multi-level uh page table

1408
00:53:51,920 --> 00:53:56,000
here's our pte

1409
00:53:56,000 --> 00:53:58,079
and if you look at the pte you know i

1410
00:53:58,079 --> 00:53:59,760
talked about the bits you know

1411
00:53:59,760 --> 00:54:02,079
one zero through seven but not about

1412
00:54:02,079 --> 00:54:03,200
these two bits

1413
00:54:03,200 --> 00:54:07,119
rsw and

1414
00:54:07,119 --> 00:54:09,119
they are reserved for supervisor

1415
00:54:09,119 --> 00:54:10,800
software so

1416
00:54:10,800 --> 00:54:12,480
the supervisor software you know this is

1417
00:54:12,480 --> 00:54:14,160
the kernel uh

1418
00:54:14,160 --> 00:54:17,520
can use these bits at its own free will

1419
00:54:17,520 --> 00:54:19,680
and so one thing one could do is like

1420
00:54:19,680 --> 00:54:21,440
say decide that bit a basically means

1421
00:54:21,440 --> 00:54:23,280
this is a copy and write page or copy to

1422
00:54:23,280 --> 00:54:24,480
write fault

1423
00:54:24,480 --> 00:54:27,359
and so when the kernel programs you know

1424
00:54:27,359 --> 00:54:28,880
these page tables

1425
00:54:28,880 --> 00:54:30,800
for you know copy and write you know you

1426
00:54:30,800 --> 00:54:32,800
can just pull to on the pte's you know

1427
00:54:32,800 --> 00:54:36,789
for these particular pages

1428
00:54:36,799 --> 00:54:38,799
the bits you know set a bit uh copy and

1429
00:54:38,799 --> 00:54:39,920
write so that when the

1430
00:54:39,920 --> 00:54:42,559
page fault happens and we see that the

1431
00:54:42,559 --> 00:54:44,240
copy and right bit is set

1432
00:54:44,240 --> 00:54:46,799
then we just go off and do this and

1433
00:54:46,799 --> 00:54:49,839
otherwise we do something else

1434
00:54:49,839 --> 00:54:54,069
for example maybe it's a lazy allocation

1435
00:54:54,079 --> 00:54:57,839
does that make sense yeah thank you

1436
00:54:57,839 --> 00:55:01,040
and in fact in uh in the lab you know

1437
00:55:01,040 --> 00:55:02,400
one of the things you will be doing is

1438
00:55:02,400 --> 00:55:03,599
probably use that bit

1439
00:55:03,599 --> 00:55:05,440
you know set a copy and write bit in the

1440
00:55:05,440 --> 00:55:07,990
pte

1441
00:55:08,000 --> 00:55:09,920
there's one more wrinkle that will show

1442
00:55:09,920 --> 00:55:12,559
up in the copy and write lab is that

1443
00:55:12,559 --> 00:55:16,000
there's some currently in xg6 basically

1444
00:55:16,000 --> 00:55:18,319
a physical page more or less only

1445
00:55:18,319 --> 00:55:19,760
belongs to one

1446
00:55:19,760 --> 00:55:21,599
process with the exception of the

1447
00:55:21,599 --> 00:55:23,119
trampoline page

1448
00:55:23,119 --> 00:55:24,480
which is the family page we're never

1449
00:55:24,480 --> 00:55:26,319
free so that is not really a particular

1450
00:55:26,319 --> 00:55:28,079
big issue

1451
00:55:28,079 --> 00:55:31,280
but for these pages you know now we have

1452
00:55:31,280 --> 00:55:33,440
multiple processes or multiple dress

1453
00:55:33,440 --> 00:55:35,040
spaces pointing to the same physical

1454
00:55:35,040 --> 00:55:36,000
address

1455
00:55:36,000 --> 00:55:39,040
and so for example if the parent exits

1456
00:55:39,040 --> 00:55:40,640
right away we got a little bit care and

1457
00:55:40,640 --> 00:55:42,240
be careful correct because

1458
00:55:42,240 --> 00:55:44,640
can we free that page immediately if the

1459
00:55:44,640 --> 00:55:49,760
parent exits

1460
00:55:49,760 --> 00:55:52,480
oh maybe not because there may be

1461
00:55:52,480 --> 00:55:53,599
multiple

1462
00:55:53,599 --> 00:55:55,599
children processes yeah there might be a

1463
00:55:55,599 --> 00:55:57,359
child correct using that page and so

1464
00:55:57,359 --> 00:55:59,760
we if the colonel would free that page

1465
00:55:59,760 --> 00:56:00,559
then

1466
00:56:00,559 --> 00:56:02,720
uh you know we're going to be in trouble

1467
00:56:02,720 --> 00:56:04,160
because basically the

1468
00:56:04,160 --> 00:56:06,880
if you look at k3 k3 actually uh writes

1469
00:56:06,880 --> 00:56:08,079
all kinds of ones on

1470
00:56:08,079 --> 00:56:10,319
three page and so then the child runs

1471
00:56:10,319 --> 00:56:11,280
with that page you know all kinds of

1472
00:56:11,280 --> 00:56:13,920
bizarre things are going to happen

1473
00:56:13,920 --> 00:56:15,599
so what should the rule be now for

1474
00:56:15,599 --> 00:56:23,430
freeing

1475
00:56:23,440 --> 00:56:27,599
i'm free if you don't have children

1476
00:56:27,599 --> 00:56:30,319
i guess yeah maybe a better way or sort

1477
00:56:30,319 --> 00:56:31,520
of a more general version of that

1478
00:56:31,520 --> 00:56:33,200
statement is to say well what we really

1479
00:56:33,200 --> 00:56:34,079
need to do

1480
00:56:34,079 --> 00:56:38,789
is we need to ref count

1481
00:56:38,799 --> 00:56:42,240
every physical page and when we free the

1482
00:56:42,240 --> 00:56:42,640
page

1483
00:56:42,640 --> 00:56:45,280
we decrease the ref count by one and if

1484
00:56:45,280 --> 00:56:46,960
the ref ground reaches zero then

1485
00:56:46,960 --> 00:56:48,880
actually we can free the page

1486
00:56:48,880 --> 00:56:50,640
and so you will have to introduce uh

1487
00:56:50,640 --> 00:56:52,640
some additional data structure or some

1488
00:56:52,640 --> 00:56:55,040
meta information in the copy and write a

1489
00:56:55,040 --> 00:56:59,680
lot to actually do that ref counting

1490
00:56:59,680 --> 00:57:01,440
where can we store this because this if

1491
00:57:01,440 --> 00:57:03,440
we ever have to ref count every single

1492
00:57:03,440 --> 00:57:05,280
page that could be a lot

1493
00:57:05,280 --> 00:57:07,599
yeah we well for every physical page of

1494
00:57:07,599 --> 00:57:08,960
memory we you'll have to do a rough

1495
00:57:08,960 --> 00:57:11,040
count yeah

1496
00:57:11,040 --> 00:57:12,400
you can get away with a little bit less

1497
00:57:12,400 --> 00:57:13,599
but then we're in the for the for

1498
00:57:13,599 --> 00:57:14,880
simplification in lab we're going to use

1499
00:57:14,880 --> 00:57:15,839
that for every one

1500
00:57:15,839 --> 00:57:19,040
physical so for every 496 bytes we need

1501
00:57:19,040 --> 00:57:23,589
to maintain a reference count

1502
00:57:23,599 --> 00:57:26,240
can we write that down in those other

1503
00:57:26,240 --> 00:57:27,119
two free

1504
00:57:27,119 --> 00:57:30,720
bits and say that no more

1505
00:57:30,720 --> 00:57:34,319
for um good good

1506
00:57:34,319 --> 00:57:37,440
yeah i'm

1507
00:57:37,440 --> 00:57:39,920
not unreasonable but uh you know if you

1508
00:57:39,920 --> 00:57:41,760
reform it multiple times

1509
00:57:41,760 --> 00:57:44,799
that'd be too bad right and after three

1510
00:57:44,799 --> 00:57:46,319
times your four times you can't don't

1511
00:57:46,319 --> 00:57:51,990
you can't do the optimization anymore

1512
00:57:52,000 --> 00:57:53,520
but yeah you know there's some freedom

1513
00:57:53,520 --> 00:57:55,200
here uh

1514
00:57:55,200 --> 00:57:58,720
also um do you really need to use that

1515
00:57:58,720 --> 00:58:01,040
bit to specify if it's a copy on write

1516
00:58:01,040 --> 00:58:02,000
because

1517
00:58:02,000 --> 00:58:05,359
the kernel could also uh maintain some

1518
00:58:05,359 --> 00:58:08,400
information about the processes that

1519
00:58:08,400 --> 00:58:11,200
yes yeah yeah yeah you could you could

1520
00:58:11,200 --> 00:58:12,720
maintain some other meta information

1521
00:58:12,720 --> 00:58:14,480
along with the process address days to

1522
00:58:14,480 --> 00:58:15,599
say basically well

1523
00:58:15,599 --> 00:58:17,119
virtual addresses between this and that

1524
00:58:17,119 --> 00:58:19,200
are text addresses so we have a page

1525
00:58:19,200 --> 00:58:20,319
fault there and

1526
00:58:20,319 --> 00:58:23,520
it must be copyright or something

1527
00:58:23,520 --> 00:58:24,960
and in fact one of the later labs you

1528
00:58:24,960 --> 00:58:27,040
know you you will certainly extend

1529
00:58:27,040 --> 00:58:29,359
uh the meta information that xv6

1530
00:58:29,359 --> 00:58:30,559
maintains

1531
00:58:30,559 --> 00:58:33,990
exactly for that reason

1532
00:58:34,000 --> 00:58:35,760
there's a bit of freedom here when you

1533
00:58:35,760 --> 00:58:40,870
start implementing these labs

1534
00:58:40,880 --> 00:59:03,990
any further questions about this

1535
00:59:04,000 --> 00:59:07,040
okay uh then let's go to the next one uh

1536
00:59:07,040 --> 00:59:08,240
this is something that's called

1537
00:59:08,240 --> 00:59:11,359
uh demand paging

1538
00:59:11,359 --> 00:59:13,280
another very popular one and most

1539
00:59:13,280 --> 00:59:15,839
operating systems implemented

1540
00:59:15,839 --> 00:59:19,200
um and so the the uh you know it just

1541
00:59:19,200 --> 00:59:20,480
goes back basically to

1542
00:59:20,480 --> 00:59:24,150
exec

1543
00:59:24,160 --> 00:59:27,359
so currently in unmodified xv6 you know

1544
00:59:27,359 --> 00:59:29,200
x6 actually loads

1545
00:59:29,200 --> 00:59:32,240
the text segment

1546
00:59:32,240 --> 00:59:35,440
and the data segment from file and maps

1547
00:59:35,440 --> 00:59:37,280
it in

1548
00:59:37,280 --> 00:59:40,640
eagerly in basically

1549
00:59:40,640 --> 00:59:46,960
into the page table

1550
00:59:46,960 --> 00:59:48,880
and basically the same observation that

1551
00:59:48,880 --> 00:59:50,079
we made for lazy

1552
00:59:50,079 --> 00:59:52,799
and zero filled is that well what we

1553
00:59:52,799 --> 00:59:54,640
could do is like why do it eagerly

1554
00:59:54,640 --> 00:59:57,119
why not let's wait a little while uh

1555
00:59:57,119 --> 00:59:59,040
until to see if actually the application

1556
00:59:59,040 --> 01:00:00,720
really needs you know those particular

1557
01:00:00,720 --> 01:00:02,160
set of instructions you know the

1558
01:00:02,160 --> 01:00:05,520
the binary might be very big uh and

1559
01:00:05,520 --> 01:00:08,720
instead of actually uh loading it all

1560
01:00:08,720 --> 01:00:10,160
in you know from disk it tends to be

1561
01:00:10,160 --> 01:00:12,160
expensive operation uh

1562
01:00:12,160 --> 01:00:13,599
maybe the data segment is much bigger

1563
01:00:13,599 --> 01:00:15,520
than it really needs than the typical

1564
01:00:15,520 --> 01:00:16,240
use case

1565
01:00:16,240 --> 01:00:18,640
uh requires we don't really have to do

1566
01:00:18,640 --> 01:00:19,599
that

1567
01:00:19,599 --> 01:00:22,720
and so instead of uh on exec

1568
01:00:22,720 --> 01:00:24,559
instead of actually you know we allocate

1569
01:00:24,559 --> 01:00:26,000
the virtual address space you know we'll

1570
01:00:26,000 --> 01:00:26,640
allocate the

1571
01:00:26,640 --> 01:00:30,079
address base for the text and the data

1572
01:00:30,079 --> 01:00:33,839
uh that's it in the file but in the ptes

1573
01:00:33,839 --> 01:00:35,680
we're going to not map them at all you

1574
01:00:35,680 --> 01:00:37,040
know it's going to keep you know in the

1575
01:00:37,040 --> 01:00:37,680
pte

1576
01:00:37,680 --> 01:00:39,280
for one of these pages you know we're

1577
01:00:39,280 --> 01:00:40,799
just going to not set the valid bit so

1578
01:00:40,799 --> 01:00:44,150
the validated to zero

1579
01:00:44,160 --> 01:00:46,240
uh and of course you know when we're

1580
01:00:46,240 --> 01:00:47,280
going to get our first

1581
01:00:47,280 --> 01:00:50,559
page fault if we do this

1582
01:00:50,559 --> 01:00:52,960
in exec and let's say we modify xc6 to

1583
01:00:52,960 --> 01:00:54,319
do this

1584
01:00:54,319 --> 01:00:59,910
when will our first default happen

1585
01:00:59,920 --> 01:01:01,280
what's the first instruction that is

1586
01:01:01,280 --> 01:01:05,190
being run for user address

1587
01:01:05,200 --> 01:01:09,670
or user program

1588
01:01:09,680 --> 01:01:12,559
where does the user program start is it

1589
01:01:12,559 --> 01:01:13,520
loading the

1590
01:01:13,520 --> 01:01:16,720
initial code newbie a minute yeah yeah

1591
01:01:16,720 --> 01:01:18,640
okay we were just keeping that

1592
01:01:18,640 --> 01:01:20,160
piece correct that's the whole point of

1593
01:01:20,160 --> 01:01:22,400
like modifying exec and not called the

1594
01:01:22,400 --> 01:01:23,040
uvm

1595
01:01:23,040 --> 01:01:28,549
in it where

1596
01:01:28,559 --> 01:01:30,400
so most you know when we actually if you

1597
01:01:30,400 --> 01:01:31,680
remember from four regret or something

1598
01:01:31,680 --> 01:01:33,280
like that you know that place where an

1599
01:01:33,280 --> 01:01:34,880
application starts is exactly address

1600
01:01:34,880 --> 01:01:35,839
zero so

1601
01:01:35,839 --> 01:01:37,440
my picture is a little bit you know he's

1602
01:01:37,440 --> 01:01:39,760
leading here but so here's text here's

1603
01:01:39,760 --> 01:01:40,559
zero

1604
01:01:40,559 --> 01:01:42,559
it goes up to some number and basically

1605
01:01:42,559 --> 01:01:44,720
the first instruction whatever sits here

1606
01:01:44,720 --> 01:01:45,920
that's the first instruction that we're

1607
01:01:45,920 --> 01:01:47,440
going to actually that address that's

1608
01:01:47,440 --> 01:01:48,720
the first instruction we're going to get

1609
01:01:48,720 --> 01:01:49,599
a page folder

1610
01:01:49,599 --> 01:02:02,789
right because we have not loaded it

1611
01:02:02,799 --> 01:02:07,839
so what to do on the page fault

1612
01:02:07,839 --> 01:02:08,960
well what we're going to do in the page

1613
01:02:08,960 --> 01:02:10,880
fault is basically we'll note

1614
01:02:10,880 --> 01:02:13,680
ah this is uh what's one of these uh uh

1615
01:02:13,680 --> 01:02:15,280
on demand pages

1616
01:02:15,280 --> 01:02:18,319
uh we have to remember somewhere earlier

1617
01:02:18,319 --> 01:02:20,000
that you know this corresponds to

1618
01:02:20,000 --> 01:02:23,119
some uh that this corresponds to some

1619
01:02:23,119 --> 01:02:25,750
file

1620
01:02:25,760 --> 01:02:26,960
and basically what we're going to do in

1621
01:02:26,960 --> 01:02:30,319
the patrol handler is read

1622
01:02:30,319 --> 01:02:34,319
you know that block or page

1623
01:02:34,319 --> 01:02:38,069
from file

1624
01:02:38,079 --> 01:02:41,910
into memory

1625
01:02:41,920 --> 01:02:45,670
map that memory

1626
01:02:45,680 --> 01:02:49,440
into the page table

1627
01:02:49,440 --> 01:02:56,710
and restart the instruction

1628
01:02:56,720 --> 01:02:59,359
and then we're off and running right and

1629
01:02:59,359 --> 01:03:00,880
so we're going to get

1630
01:03:00,880 --> 01:03:02,880
in the worst case if the user program

1631
01:03:02,880 --> 01:03:04,240
uses all of its text

1632
01:03:04,240 --> 01:03:05,920
uses all of this data then we're going

1633
01:03:05,920 --> 01:03:07,839
to get a page fault for every page you

1634
01:03:07,839 --> 01:03:08,400
know in

1635
01:03:08,400 --> 01:03:12,960
uh in the program

1636
01:03:12,960 --> 01:03:14,400
but you know we get lucky and the

1637
01:03:14,400 --> 01:03:16,000
program know doesn't use all of its

1638
01:03:16,000 --> 01:03:17,520
data segment or doesn't use all of this

1639
01:03:17,520 --> 01:03:19,920
text segment then you know we might save

1640
01:03:19,920 --> 01:03:22,079
some memory and uh we certainly make

1641
01:03:22,079 --> 01:03:24,240
exact you know perform you know

1642
01:03:24,240 --> 01:03:26,000
much quicker and so be a little bit more

1643
01:03:26,000 --> 01:03:27,359
interactive and as soon as the program

1644
01:03:27,359 --> 01:03:28,799
starts boom it's running

1645
01:03:28,799 --> 01:03:30,799
my we hardly have to do any work in

1646
01:03:30,799 --> 01:03:33,430
exactly

1647
01:03:33,440 --> 01:03:34,960
does that make this optimization make

1648
01:03:34,960 --> 01:03:42,069
sense

1649
01:03:42,079 --> 01:03:44,640
okay so then there's a sort of a slight

1650
01:03:44,640 --> 01:03:51,270
extension to demand paging

1651
01:03:51,280 --> 01:03:52,799
so this is the second part of the net

1652
01:03:52,799 --> 01:03:56,470
paging

1653
01:03:56,480 --> 01:04:01,620
yeah sorry right there more

1654
01:04:01,620 --> 01:04:04,640
[Music]

1655
01:04:04,640 --> 01:04:07,520
so part two demand paging this principle

1656
01:04:07,520 --> 01:04:09,200
there's a little bit of a problem here

1657
01:04:09,200 --> 01:04:11,200
that we haven't really discussed it

1658
01:04:11,200 --> 01:04:12,799
might be the case you know maybe the

1659
01:04:12,799 --> 01:04:14,559
file that we're actually reading or the

1660
01:04:14,559 --> 01:04:16,000
text and data segment are even bigger

1661
01:04:16,000 --> 01:04:17,680
than what actually is in physical memory

1662
01:04:17,680 --> 01:04:18,240
or

1663
01:04:18,240 --> 01:04:20,799
if multiple applications uh started with

1664
01:04:20,799 --> 01:04:21,760
demand paging

1665
01:04:21,760 --> 01:04:25,039
maybe their sum of their binaries

1666
01:04:25,039 --> 01:04:26,559
is basically bigger than actually it's a

1667
01:04:26,559 --> 01:04:28,640
physical memory

1668
01:04:28,640 --> 01:04:31,119
and so uh the typical thing you know

1669
01:04:31,119 --> 01:04:32,160
what

1670
01:04:32,160 --> 01:04:34,799
if you go down this demand paging uh

1671
01:04:34,799 --> 01:04:35,280
round

1672
01:04:35,280 --> 01:04:38,880
is to actually if you run out of memory

1673
01:04:38,880 --> 01:04:41,760
so if caliber returns zero if out of

1674
01:04:41,760 --> 01:04:45,349
memory

1675
01:04:45,359 --> 01:04:48,160
so for example you know your demand page

1676
01:04:48,160 --> 01:04:50,079
you get a page fault at some

1677
01:04:50,079 --> 01:04:53,839
uh page that needs to be uh paged in

1678
01:04:53,839 --> 01:04:56,799
from the file system but you don't have

1679
01:04:56,799 --> 01:04:58,240
any more free pages

1680
01:04:58,240 --> 01:05:00,319
you need to do something and so the

1681
01:05:00,319 --> 01:05:01,599
typical and this comes back

1682
01:05:01,599 --> 01:05:03,119
to an earlier question example the same

1683
01:05:03,119 --> 01:05:05,440
is true for lazy or

1684
01:05:05,440 --> 01:05:06,640
you know what to do if you run out of

1685
01:05:06,640 --> 01:05:08,799
memory so if you run out of memory

1686
01:05:08,799 --> 01:05:11,520
one option that you really clearly have

1687
01:05:11,520 --> 01:05:13,119
is to

1688
01:05:13,119 --> 01:05:19,109
evict a pitch

1689
01:05:19,119 --> 01:05:20,799
you can example instead of you know you

1690
01:05:20,799 --> 01:05:22,319
can for example invicta page and write

1691
01:05:22,319 --> 01:05:22,960
it you know

1692
01:05:22,960 --> 01:05:26,160
to the file back so for example if it's

1693
01:05:26,160 --> 01:05:27,039
a

1694
01:05:27,039 --> 01:05:28,960
data page that got modified you know you

1695
01:05:28,960 --> 01:05:30,799
can write it back you know to the file

1696
01:05:30,799 --> 01:05:32,160
system

1697
01:05:32,160 --> 01:05:34,880
um and then once you've hit the page

1698
01:05:34,880 --> 01:05:36,640
then you have a new free page

1699
01:05:36,640 --> 01:05:39,680
and you can put the uh use that you know

1700
01:05:39,680 --> 01:05:46,870
use the new the just free page

1701
01:05:46,880 --> 01:05:49,839
to satisfy you know the fault that you

1702
01:05:49,839 --> 01:05:50,559
had

1703
01:05:50,559 --> 01:05:51,760
and then basically restart the

1704
01:05:51,760 --> 01:05:58,710
instruction again

1705
01:05:58,720 --> 01:06:00,000
again restart the instruction is a

1706
01:06:00,000 --> 01:06:01,359
little bit more complicated because the

1707
01:06:01,359 --> 01:06:02,319
whole

1708
01:06:02,319 --> 01:06:05,520
machinery to basically do useret and

1709
01:06:05,520 --> 01:06:08,480
uh start it and transfer back to user

1710
01:06:08,480 --> 01:06:11,039
space etc

1711
01:06:11,039 --> 01:06:12,640
uh and so this is a you know typical

1712
01:06:12,640 --> 01:06:14,799
operating system we'll do this um

1713
01:06:14,799 --> 01:06:16,559
and of course the key question is like

1714
01:06:16,559 --> 01:06:19,990
what page to evict

1715
01:06:20,000 --> 01:06:23,119
which one to choose so what are what are

1716
01:06:23,119 --> 01:06:25,839
some candidates you know what

1717
01:06:25,839 --> 01:06:27,599
what would be your reasonable policy for

1718
01:06:27,599 --> 01:06:30,319
choosing a page to evict

1719
01:06:30,319 --> 01:06:33,599
least recently used yeah so this is the

1720
01:06:33,599 --> 01:06:36,559
most commonly used strategy least

1721
01:06:36,559 --> 01:06:43,910
recently used

1722
01:06:43,920 --> 01:06:47,839
or lru

1723
01:06:47,839 --> 01:06:51,200
and that is the page that uh that's

1724
01:06:51,200 --> 01:06:52,240
typically yours

1725
01:06:52,240 --> 01:06:54,640
is thrown out there's a couple sort of

1726
01:06:54,640 --> 01:06:56,559
twists that typically are

1727
01:06:56,559 --> 01:06:59,359
small optimizations that do if you have

1728
01:06:59,359 --> 01:07:01,440
to evict the page and

1729
01:07:01,440 --> 01:07:03,440
um you have a choice between a dirty

1730
01:07:03,440 --> 01:07:05,359
page and a non-dirty page so dirty page

1731
01:07:05,359 --> 01:07:07,359
is a page where there was a store to

1732
01:07:07,359 --> 01:07:09,119
and the non-dirty page is a store page

1733
01:07:09,119 --> 01:07:10,640
that basically only has been read but

1734
01:07:10,640 --> 01:07:11,680
not written to

1735
01:07:11,680 --> 01:07:16,630
which one would you prefer to vic first

1736
01:07:16,640 --> 01:07:18,799
a three one because you would have to

1737
01:07:18,799 --> 01:07:22,160
write the dirty one at some point anyway

1738
01:07:22,160 --> 01:07:24,880
yeah uh so so we're gonna say again

1739
01:07:24,880 --> 01:07:25,680
actually

1740
01:07:25,680 --> 01:07:28,400
double check there um i said dirty

1741
01:07:28,400 --> 01:07:29,119
because

1742
01:07:29,119 --> 01:07:30,960
30 pages would need to be written to

1743
01:07:30,960 --> 01:07:33,200
memory at some point

1744
01:07:33,200 --> 01:07:36,640
yeah that's true uh but then maybe now

1745
01:07:36,640 --> 01:07:37,680
you have to write it twice

1746
01:07:37,680 --> 01:07:39,119
you know once you write it maybe it's

1747
01:07:39,119 --> 01:07:41,359
modified later again

1748
01:07:41,359 --> 01:07:42,720
and so actually typically when an

1749
01:07:42,720 --> 01:07:44,720
operator oh i see okay the dropping

1750
01:07:44,720 --> 01:07:46,799
system is exactly the opposite

1751
01:07:46,799 --> 01:07:48,559
uh they choose a page that actually has

1752
01:07:48,559 --> 01:07:50,400
not been written or is not dirty because

1753
01:07:50,400 --> 01:07:51,680
you don't have to do anything

1754
01:07:51,680 --> 01:07:54,400
you can just reuse it you can just take

1755
01:07:54,400 --> 01:07:55,520
uh

1756
01:07:55,520 --> 01:07:57,440
if it was present in pt in page table

1757
01:07:57,440 --> 01:07:59,760
one your market there is non-valid

1758
01:07:59,760 --> 01:08:02,559
and then uh you're done and then you can

1759
01:08:02,559 --> 01:08:05,200
reuse that page in another page table

1760
01:08:05,200 --> 01:08:07,520
and so the preference and typically take

1761
01:08:07,520 --> 01:08:08,720
pages that have been

1762
01:08:08,720 --> 01:08:13,589
uh not you know non-dirty ones first

1763
01:08:13,599 --> 01:08:15,200
can i just ask for a clarification on

1764
01:08:15,200 --> 01:08:17,199
the 30

1765
01:08:17,199 --> 01:08:20,319
pages so

1766
01:08:20,319 --> 01:08:23,600
um i i know like in a cache

1767
01:08:23,600 --> 01:08:25,520
when we have memory and then we say okay

1768
01:08:25,520 --> 01:08:27,359
a line is dirty because it hasn't been

1769
01:08:27,359 --> 01:08:28,560
written to memory

1770
01:08:28,560 --> 01:08:30,400
but what about a page in memory like

1771
01:08:30,400 --> 01:08:32,239
what does it correspond to like how is

1772
01:08:32,239 --> 01:08:33,520
it dirty where does it have to be

1773
01:08:33,520 --> 01:08:34,719
written back to

1774
01:08:34,719 --> 01:08:36,319
it just exists in memory right isn't

1775
01:08:36,319 --> 01:08:38,159
that the whole whole thing like it

1776
01:08:38,159 --> 01:08:40,080
doesn't exist anywhere else really

1777
01:08:40,080 --> 01:08:42,400
so when can it be dirty yeah okay so for

1778
01:08:42,400 --> 01:08:43,920
example if it's the demand page file

1779
01:08:43,920 --> 01:08:45,199
page

1780
01:08:45,199 --> 01:08:46,560
uh actually we'll talk about this in a

1781
01:08:46,560 --> 01:08:49,359
second like in the next uh

1782
01:08:49,359 --> 01:08:50,960
maybe a prefetch a little bit too much

1783
01:08:50,960 --> 01:08:53,759
but if you uh with memory map files

1784
01:08:53,759 --> 01:08:56,880
where you map a file into uh

1785
01:08:56,880 --> 01:08:59,520
memory uh and then the restore to it

1786
01:08:59,520 --> 01:09:01,199
then you would dirty that page

1787
01:09:01,199 --> 01:09:03,359
okay so that only applies when like a

1788
01:09:03,359 --> 01:09:05,600
page actually responds not just to some

1789
01:09:05,600 --> 01:09:07,600
memory but also to a file or something

1790
01:09:07,600 --> 01:09:08,000
else

1791
01:09:08,000 --> 01:09:12,950
exactly okay okay that makes sense yeah

1792
01:09:12,960 --> 01:09:15,359
okay so just to uh you know just to make

1793
01:09:15,359 --> 01:09:17,359
one more two more points

1794
01:09:17,359 --> 01:09:20,880
related to this uh if you look at this

1795
01:09:20,880 --> 01:09:24,480
uh the ptes again so we saw this irish w

1796
01:09:24,480 --> 01:09:25,120
bit

1797
01:09:25,120 --> 01:09:26,880
uh and you'll notice there actually is a

1798
01:09:26,880 --> 01:09:29,279
bit seven that is the dirty bit

1799
01:09:29,279 --> 01:09:31,279
so when the paging hardware when the

1800
01:09:31,279 --> 01:09:33,279
hardware ever writes you know to a page

1801
01:09:33,279 --> 01:09:35,040
and watches at the dirty bits so the

1802
01:09:35,040 --> 01:09:36,560
operating system later can see you ah

1803
01:09:36,560 --> 01:09:37,600
this actually page

1804
01:09:37,600 --> 01:09:39,359
can easily see this page that's actually

1805
01:09:39,359 --> 01:09:41,279
written to

1806
01:09:41,279 --> 01:09:46,159
and similarly there is a uh an a bit

1807
01:09:46,159 --> 01:09:48,960
uh that stands for access and so

1808
01:09:48,960 --> 01:09:50,560
whenever a page is either written

1809
01:09:50,560 --> 01:09:53,359
or written either read or written the

1810
01:09:53,359 --> 01:09:55,040
access bit will be set

1811
01:09:55,040 --> 01:10:07,350
and uh and why is that useful to know

1812
01:10:07,360 --> 01:10:09,679
in what way could that help the colonel

1813
01:10:09,679 --> 01:10:12,239
well the ones that haven't been

1814
01:10:12,239 --> 01:10:15,600
accessed you can you can evict right

1815
01:10:15,600 --> 01:10:17,600
yeah like another way of saying that if

1816
01:10:17,600 --> 01:10:18,960
you want to implement these recently

1817
01:10:18,960 --> 01:10:20,320
used

1818
01:10:20,320 --> 01:10:23,920
uh if uh you find a page that basically

1819
01:10:23,920 --> 01:10:25,280
hasn't been accessed in some period of

1820
01:10:25,280 --> 01:10:26,560
time you know it actually hasn't been

1821
01:10:26,560 --> 01:10:28,159
recently used so it actually is a

1822
01:10:28,159 --> 01:10:29,520
candidate for eviction

1823
01:10:29,520 --> 01:10:31,440
while the pages that have the access bit

1824
01:10:31,440 --> 01:10:32,960
set are not really candidates for

1825
01:10:32,960 --> 01:10:34,719
eviction

1826
01:10:34,719 --> 01:10:37,360
and so the abit is typically used or the

1827
01:10:37,360 --> 01:10:39,040
actual bit is typically used

1828
01:10:39,040 --> 01:10:44,560
to actually implement this lru strategy

1829
01:10:44,560 --> 01:10:48,560
okay but would you have to reset um

1830
01:10:48,560 --> 01:10:52,320
the accessed bits to not accessed every

1831
01:10:52,320 --> 01:10:53,520
once in a while or

1832
01:10:53,520 --> 01:10:55,199
yeah exactly that's exactly what the

1833
01:10:55,199 --> 01:10:57,440
typical operating system will do

1834
01:10:57,440 --> 01:10:58,960
and if they don't do it maybe for all

1835
01:10:58,960 --> 01:11:00,719
memory they sweep through memory

1836
01:11:00,719 --> 01:11:02,480
that's a little you know there's some

1837
01:11:02,480 --> 01:11:03,840
famous algorithm for this called the

1838
01:11:03,840 --> 01:11:05,600
clock algorithm that is like one way of

1839
01:11:05,600 --> 01:11:10,870
doing it

1840
01:11:10,880 --> 01:11:12,719
very well would you need to set it why

1841
01:11:12,719 --> 01:11:14,640
would you need to reset it

1842
01:11:14,640 --> 01:11:16,400
well if you want to know whether page is

1843
01:11:16,400 --> 01:11:18,239
recently used uh

1844
01:11:18,239 --> 01:11:19,760
you need and you make a periodic

1845
01:11:19,760 --> 01:11:22,239
decision uh then say maybe every 100

1846
01:11:22,239 --> 01:11:24,080
milliseconds or whatever every second

1847
01:11:24,080 --> 01:11:26,320
you know you clear the axis bit

1848
01:11:26,320 --> 01:11:28,000
and if it then gets accessed in the next

1849
01:11:28,000 --> 01:11:29,199
hundred milliseconds you know it was

1850
01:11:29,199 --> 01:11:32,640
used in the last hundred milliseconds

1851
01:11:32,640 --> 01:11:34,560
and the pages that don't have the axis

1852
01:11:34,560 --> 01:11:36,159
bit set were not used in the last in the

1853
01:11:36,159 --> 01:11:39,030
milliseconds

1854
01:11:39,040 --> 01:11:40,560
and so then you can keep counters of

1855
01:11:40,560 --> 01:11:42,239
like how intentionally they're used and

1856
01:11:42,239 --> 01:11:44,239
what is the and throughout the really

1857
01:11:44,239 --> 01:11:45,679
it's basically the stepping stone to

1858
01:11:45,679 --> 01:11:47,520
build a sort of sophisticated lru

1859
01:11:47,520 --> 01:11:52,790
implementation

1860
01:11:52,800 --> 01:11:56,640
okay um i want to talk about one more

1861
01:11:56,640 --> 01:11:59,669
just to uh

1862
01:11:59,679 --> 01:12:01,040
and then that's the last one actually

1863
01:12:01,040 --> 01:12:02,880
that you also will be implementing in

1864
01:12:02,880 --> 01:12:06,719
uh one of the labs and that is

1865
01:12:06,719 --> 01:12:21,030
memory map files

1866
01:12:21,040 --> 01:12:23,440
and the idea is that uh you know here we

1867
01:12:23,440 --> 01:12:24,080
have

1868
01:12:24,080 --> 01:12:26,560
our address space what we really want to

1869
01:12:26,560 --> 01:12:27,920
do is basically be able to

1870
01:12:27,920 --> 01:12:30,080
load a whole file or parts of the file

1871
01:12:30,080 --> 01:12:31,280
into the address space

1872
01:12:31,280 --> 01:12:32,880
so that we can just manipulate you know

1873
01:12:32,880 --> 01:12:34,400
the content of the file using load and

1874
01:12:34,400 --> 01:12:38,149
store instructions

1875
01:12:38,159 --> 01:12:42,400
instead of read you know lc can write

1876
01:12:42,400 --> 01:12:44,159
and to be able to support that you know

1877
01:12:44,159 --> 01:12:45,760
a typical operating system

1878
01:12:45,760 --> 01:12:48,080
amongst modern operating systems could

1879
01:12:48,080 --> 01:12:52,159
provide a system call called nmap

1880
01:12:52,159 --> 01:12:54,800
and basically mf takes a virtual address

1881
01:12:54,800 --> 01:12:56,880
or you know pixel virtual address

1882
01:12:56,880 --> 01:13:00,800
length uh protection

1883
01:13:00,800 --> 01:13:02,880
from flags which we're not going to talk

1884
01:13:02,880 --> 01:13:05,360
about and then a file descriptor of an

1885
01:13:05,360 --> 01:13:06,640
open file

1886
01:13:06,640 --> 01:13:09,679
and then offset and basically what this

1887
01:13:09,679 --> 01:13:12,159
says is like you should you know map

1888
01:13:12,159 --> 01:13:14,800
you know this file descriptor if this is

1889
01:13:14,800 --> 01:13:16,400
address you know the virtual address

1890
01:13:16,400 --> 01:13:18,880
you know the file descriptor starting

1891
01:13:18,880 --> 01:13:20,080
from offset

1892
01:13:20,080 --> 01:13:22,640
you know in the file f you know map that

1893
01:13:22,640 --> 01:13:23,280
in

1894
01:13:23,280 --> 01:13:26,400
add to address at the virtual address va

1895
01:13:26,400 --> 01:13:28,400
and do that we have some protection like

1896
01:13:28,400 --> 01:13:30,560
read write etc

1897
01:13:30,560 --> 01:13:33,120
and so let's say it's a read write then

1898
01:13:33,120 --> 01:13:34,159
you know the

1899
01:13:34,159 --> 01:13:37,840
kernel uh when so the way the kernel

1900
01:13:37,840 --> 01:13:39,199
implements nmap

1901
01:13:39,199 --> 01:13:41,440
is you know if it does it eagerly uh

1902
01:13:41,440 --> 01:13:42,400
which is like most

1903
01:13:42,400 --> 01:13:44,320
the system don't do it easily you know

1904
01:13:44,320 --> 01:13:46,000
basically copy

1905
01:13:46,000 --> 01:13:47,600
read all the bytes they're starting from

1906
01:13:47,600 --> 01:13:49,600
offset uh lang bytes starting from

1907
01:13:49,600 --> 01:13:50,719
offset into

1908
01:13:50,719 --> 01:13:54,480
uh memory sets up the uh ptes

1909
01:13:54,480 --> 01:13:57,600
to point to the physical memory for

1910
01:13:57,600 --> 01:13:59,920
where their blocks are located and then

1911
01:13:59,920 --> 01:14:01,679
basically from then on

1912
01:14:01,679 --> 01:14:04,880
the uh application can usually should

1913
01:14:04,880 --> 01:14:06,400
use load and store instructions to

1914
01:14:06,400 --> 01:14:07,920
actually modify

1915
01:14:07,920 --> 01:14:10,480
the file and then maybe when they uh

1916
01:14:10,480 --> 01:14:11,920
where we're all done

1917
01:14:11,920 --> 01:14:13,520
there's typically a corresponding

1918
01:14:13,520 --> 01:14:15,280
unmapped call

1919
01:14:15,280 --> 01:14:18,400
that an app length

1920
01:14:18,400 --> 01:14:20,560
that allows the application to say like

1921
01:14:20,560 --> 01:14:22,320
okay i'm done with this particular file

1922
01:14:22,320 --> 01:14:24,080
and at the point of the unmapped and we

1923
01:14:24,080 --> 01:14:32,070
need to write back the dirty blocks

1924
01:14:32,080 --> 01:14:33,440
and we can easily figure out which

1925
01:14:33,440 --> 01:14:35,600
blocks are dirty because

1926
01:14:35,600 --> 01:14:38,640
they have to d bit set in the pte

1927
01:14:38,640 --> 01:14:41,040
now of course in any memory

1928
01:14:41,040 --> 01:14:42,239
sophisticated memory

1929
01:14:42,239 --> 01:14:44,960
uh implementation uh this is all done

1930
01:14:44,960 --> 01:14:46,560
lately you know you just don't map the

1931
01:14:46,560 --> 01:14:47,679
file immediately

1932
01:14:47,679 --> 01:14:49,280
uh you just keep a record somewhere on

1933
01:14:49,280 --> 01:14:51,120
the site saying like well you know this

1934
01:14:51,120 --> 01:14:52,000
pte

1935
01:14:52,000 --> 01:14:53,440
you know really belongs to this

1936
01:14:53,440 --> 01:14:54,960
particular file descriptor so there's

1937
01:14:54,960 --> 01:14:55,520
some

1938
01:14:55,520 --> 01:14:57,199
information maintained on the site which

1939
01:14:57,199 --> 01:14:58,800
is typically called

1940
01:14:58,800 --> 01:15:00,800
in the structure called the vma or the

1941
01:15:00,800 --> 01:15:07,590
virtual memory area

1942
01:15:07,600 --> 01:15:09,040
and for example for this file f that

1943
01:15:09,040 --> 01:15:11,679
would be one vma and in a vma we record

1944
01:15:11,679 --> 01:15:13,600
you know the file descriptor the offset

1945
01:15:13,600 --> 01:15:16,239
et cetera where the actual content of

1946
01:15:16,239 --> 01:15:17,520
that memory

1947
01:15:17,520 --> 01:15:20,640
lists and so when we uh get a page fault

1948
01:15:20,640 --> 01:15:22,400
for a particular address that sits in

1949
01:15:22,400 --> 01:15:23,679
this you know dma

1950
01:15:23,679 --> 01:15:25,520
and we can go off and the kernel can

1951
01:15:25,520 --> 01:15:26,719
read it from disk

1952
01:15:26,719 --> 01:15:30,239
and uh bring it into memory

1953
01:15:30,239 --> 01:15:32,320
and uh in response to an early question

1954
01:15:32,320 --> 01:15:33,280
this is like one of the reasons that

1955
01:15:33,280 --> 01:15:34,719
this dirty bit is important because at

1956
01:15:34,719 --> 01:15:35,040
the

1957
01:15:35,040 --> 01:15:36,960
map you have to write back the dirty

1958
01:15:36,960 --> 01:15:40,709
blocks

1959
01:15:40,719 --> 01:15:43,830
does this make sense

1960
01:15:43,840 --> 01:15:47,280
um i have a quick question yeah uh

1961
01:15:47,280 --> 01:15:50,080
maybe this is a more general issue but

1962
01:15:50,080 --> 01:15:51,440
could it ever be an issue if say

1963
01:15:51,440 --> 01:15:53,120
multiple processes are

1964
01:15:53,120 --> 01:15:55,120
memory mapping the same file on

1965
01:15:55,120 --> 01:15:56,159
secondary storage

1966
01:15:56,159 --> 01:15:58,320
and then they like like synchronization

1967
01:15:58,320 --> 01:15:59,440
issues yeah

1968
01:15:59,440 --> 01:16:01,760
good question uh so what is the

1969
01:16:01,760 --> 01:16:03,600
semantics in units in general like what

1970
01:16:03,600 --> 01:16:05,440
happens if multiple processes are read

1971
01:16:05,440 --> 01:16:06,880
or write to the same file using reading

1972
01:16:06,880 --> 01:16:18,790
over the right system calls

1973
01:16:18,800 --> 01:16:22,390
does unix guarantee anything

1974
01:16:22,400 --> 01:16:26,640
oh it's undefined yeah this is like no

1975
01:16:26,640 --> 01:16:28,080
the right the reason right will show up

1976
01:16:28,080 --> 01:16:29,920
in some order or the rights will show up

1977
01:16:29,920 --> 01:16:31,600
in some order so if two processes you

1978
01:16:31,600 --> 01:16:34,400
write to the same block off the file you

1979
01:16:34,400 --> 01:16:34,640
know

1980
01:16:34,640 --> 01:16:36,239
either the first process writes go or

1981
01:16:36,239 --> 01:16:37,679
the second process rights go

1982
01:16:37,679 --> 01:16:39,840
one of the two and so here's basically

1983
01:16:39,840 --> 01:16:41,040
the same thing you know we don't really

1984
01:16:41,040 --> 01:16:42,960
have to guarantee anything

1985
01:16:42,960 --> 01:16:44,719
if you want to do a more sophisticated

1986
01:16:44,719 --> 01:16:46,640
unix operating system support file

1987
01:16:46,640 --> 01:16:47,600
walking

1988
01:16:47,600 --> 01:16:50,159
where you can lock files and then you

1989
01:16:50,159 --> 01:16:50,640
can

1990
01:16:50,640 --> 01:16:52,880
properly synchronize but by default

1991
01:16:52,880 --> 01:16:55,440
there's no synchronization

1992
01:16:55,440 --> 01:17:01,840
or no synchronization at this level

1993
01:17:01,840 --> 01:17:06,080
makes sense i'm sorry what is length

1994
01:17:06,080 --> 01:17:09,280
and what is flags oh flags uh ling

1995
01:17:09,280 --> 01:17:11,360
is the length of the you know the area

1996
01:17:11,360 --> 01:17:12,800
you want to map the files the number of

1997
01:17:12,800 --> 01:17:13,840
bytes

1998
01:17:13,840 --> 01:17:16,960
uh prod is read write x flags you know

1999
01:17:16,960 --> 01:17:18,960
is you'll see that when you do the map

2000
01:17:18,960 --> 01:17:20,000
uh

2001
01:17:20,000 --> 01:17:21,840
i think this has to do with whether the

2002
01:17:21,840 --> 01:17:24,239
area is mapped private or shared

2003
01:17:24,239 --> 01:17:26,560
uh if it's not shared then you know it

2004
01:17:26,560 --> 01:17:35,030
can be shared among multiple processes

2005
01:17:35,040 --> 01:17:41,750
any further questions about this

2006
01:17:41,760 --> 01:17:44,000
if some other process modifies the file

2007
01:17:44,000 --> 01:17:46,239
and disk that means that this will not

2008
01:17:46,239 --> 01:17:48,480
be reflected here right

2009
01:17:48,480 --> 01:17:51,360
uh that's correct uh unless i think if

2010
01:17:51,360 --> 01:17:51,840
it's not

2011
01:17:51,840 --> 01:17:53,360
shared then you're supposed to reflect

2012
01:17:53,360 --> 01:17:55,120
those changes

2013
01:17:55,120 --> 01:17:56,640
right but then they would be using the

2014
01:17:56,640 --> 01:17:58,850
same file descriptor right

2015
01:17:58,850 --> 01:18:01,199
[Music]

2016
01:18:01,199 --> 01:18:03,679
i'm hazy on the exact you know semantics

2017
01:18:03,679 --> 01:18:04,480
of

2018
01:18:04,480 --> 01:18:06,320
nmap when things are shared and what

2019
01:18:06,320 --> 01:18:08,159
exactly happens there

2020
01:18:08,159 --> 01:18:09,760
okay i get so i guess in like the

2021
01:18:09,760 --> 01:18:11,679
idiomatic case yeah and the shared

2022
01:18:11,679 --> 01:18:14,800
they would have to reflect it but

2023
01:18:14,800 --> 01:18:16,880
if a process just like actually opened

2024
01:18:16,880 --> 01:18:18,000
the same file name

2025
01:18:18,000 --> 01:18:21,520
completely set separately i think

2026
01:18:21,520 --> 01:18:23,920
it could be unsynced even if it's shared

2027
01:18:23,920 --> 01:18:30,950
yeah that's correct

2028
01:18:30,960 --> 01:18:33,600
okay so uh so this is after the file

2029
01:18:33,600 --> 01:18:34,320
system lab

2030
01:18:34,320 --> 01:18:37,600
you actually do memory map files and

2031
01:18:37,600 --> 01:18:38,800
that will be our last

2032
01:18:38,800 --> 01:18:41,040
virtual memory sort of laugh unless you

2033
01:18:41,040 --> 01:18:42,560
decide at the end to do more virtual

2034
01:18:42,560 --> 01:18:43,679
memory uh

2035
01:18:43,679 --> 01:18:45,760
uh features or exercises uh whatever you

2036
01:18:45,760 --> 01:18:47,040
want to do uh

2037
01:18:47,040 --> 01:18:48,800
anyway so the main choice this will

2038
01:18:48,800 --> 01:18:51,199
conclude this lecture um

2039
01:18:51,199 --> 01:18:55,910
the you know sort of summary

2040
01:18:55,920 --> 01:18:57,520
you know we have loot in the past you

2041
01:18:57,520 --> 01:18:59,360
know sort of in great uh detail

2042
01:18:59,360 --> 01:19:02,640
exactly you know uh page tables work

2043
01:19:02,640 --> 01:19:04,560
uh you've done a couple laps and one lap

2044
01:19:04,560 --> 01:19:06,640
the page tables we've looked a lot at

2045
01:19:06,640 --> 01:19:08,480
like how traps work

2046
01:19:08,480 --> 01:19:11,920
and and you know page faults and it

2047
01:19:11,920 --> 01:19:13,520
turns out you know if you combine the

2048
01:19:13,520 --> 01:19:16,149
two

2049
01:19:16,159 --> 01:19:17,520
you know you're going to get you can

2050
01:19:17,520 --> 01:19:19,280
implement very powerful

2051
01:19:19,280 --> 01:19:22,480
and elegant

2052
01:19:22,480 --> 01:19:25,679
uh virtual memory features

2053
01:19:25,679 --> 01:19:27,040
and you know went through a whole list

2054
01:19:27,040 --> 01:19:28,800
of them uh

2055
01:19:28,800 --> 01:19:30,080
mostly focusing on the ones that

2056
01:19:30,080 --> 01:19:31,120
actually going to be implementing in

2057
01:19:31,120 --> 01:19:32,400
future labs

2058
01:19:32,400 --> 01:19:34,719
uh but you know this is only a subset

2059
01:19:34,719 --> 01:19:36,239
very sample

2060
01:19:36,239 --> 01:19:37,760
of the ones that you know some operating

2061
01:19:37,760 --> 01:19:39,199
systems implemented and the typical

2062
01:19:39,199 --> 01:19:40,640
operating systems implement all the ones

2063
01:19:40,640 --> 01:19:42,239
that actually discussed today

2064
01:19:42,239 --> 01:19:45,679
so you look at linux it has all of them

2065
01:19:45,679 --> 01:19:48,159
and many more interesting other tricks

2066
01:19:48,159 --> 01:19:49,280
but this hopefully gives you a good

2067
01:19:49,280 --> 01:19:51,120
sense you know sort of how the power of

2068
01:19:51,120 --> 01:19:52,080
virtual memory

2069
01:19:52,080 --> 01:19:54,080
uh once you dynamically can change the

2070
01:19:54,080 --> 01:19:55,760
page tables uh in the page fault

2071
01:19:55,760 --> 01:19:58,709
headline

2072
01:19:58,719 --> 01:20:01,679
i think this is exactly that 25 so maybe

2073
01:20:01,679 --> 01:20:02,640
it is a good point to

2074
01:20:02,640 --> 01:20:04,239
stop but if you have any questions you

2075
01:20:04,239 --> 01:20:07,750
know feel free to ask them

2076
01:20:07,760 --> 01:20:09,600
and if not you know we should good luck

2077
01:20:09,600 --> 01:20:11,920
finishing uh the trap lab

2078
01:20:11,920 --> 01:20:15,440
and i hope it's not as painful as the uh

2079
01:20:15,440 --> 01:20:21,590
or not as hard as the page table lab

2080
01:20:21,600 --> 01:20:23,920
oh sorry i had another question when you

2081
01:20:23,920 --> 01:20:24,800
map in the

2082
01:20:24,800 --> 01:20:27,760
in the previous slide um when you map

2083
01:20:27,760 --> 01:20:29,760
the whole file or like when you put it

2084
01:20:29,760 --> 01:20:30,719
into memory

2085
01:20:30,719 --> 01:20:32,560
and it turns out to be longer than

2086
01:20:32,560 --> 01:20:35,840
length um

2087
01:20:35,840 --> 01:20:38,800
then what happens so if the file doesn't

2088
01:20:38,800 --> 01:20:40,960
fit in the virtual address space

2089
01:20:40,960 --> 01:20:44,639
oh i guess so like length is how

2090
01:20:44,639 --> 01:20:48,320
much of the file we want yes

2091
01:20:48,320 --> 01:20:50,239
yeah so length is just like we want to

2092
01:20:50,239 --> 01:20:51,440
map like 10 bytes

2093
01:20:51,440 --> 01:20:53,760
out of the file descriptor starting and

2094
01:20:53,760 --> 01:20:55,600
offset off

2095
01:20:55,600 --> 01:20:58,400
oh okay okay so if the file is longer

2096
01:20:58,400 --> 01:20:59,520
then we're not gonna

2097
01:20:59,520 --> 01:21:01,679
put all of it into memory yeah yeah we

2098
01:21:01,679 --> 01:21:03,600
can always yeah exactly

2099
01:21:03,600 --> 01:21:08,390
okay i see thank you

2100
01:21:08,400 --> 01:21:10,000
um thank you i've got a question i've

2101
01:21:10,000 --> 01:21:10,960
got a question about

2102
01:21:10,960 --> 01:21:12,719
[Music]

2103
01:21:12,719 --> 01:21:16,719
evicting pages so

2104
01:21:16,719 --> 01:21:18,159
so we talked about it under like the man

2105
01:21:18,159 --> 01:21:19,840
caging part two but is that like a

2106
01:21:19,840 --> 01:21:20,480
general

2107
01:21:20,480 --> 01:21:22,000
procedure we would use in any of these

2108
01:21:22,000 --> 01:21:23,840
techniques if we discover that we're out

2109
01:21:23,840 --> 01:21:24,080
of

2110
01:21:24,080 --> 01:21:26,639
physical boundary yeah as the common

2111
01:21:26,639 --> 01:21:29,120
basically mechanisms like so even in

2112
01:21:29,120 --> 01:21:31,199
lazy allocation we run at the point

2113
01:21:31,199 --> 01:21:33,040
where uh

2114
01:21:33,040 --> 01:21:34,800
there's no memory available anymore to

2115
01:21:34,800 --> 01:21:36,159
allocate to the page

2116
01:21:36,159 --> 01:21:38,800
and you know we support demand paging or

2117
01:21:38,800 --> 01:21:40,639
whatever we use evict you know some page

2118
01:21:40,639 --> 01:21:41,040
you know

2119
01:21:41,040 --> 01:21:44,480
typically using lru okay and one way to

2120
01:21:44,480 --> 01:21:46,239
think about it is that in the steady

2121
01:21:46,239 --> 01:21:47,760
state the operating system basically

2122
01:21:47,760 --> 01:21:48,719
runs

2123
01:21:48,719 --> 01:21:52,480
uh with all memory in use at any time

2124
01:21:52,480 --> 01:21:56,639
and want to use old memory

2125
01:21:56,639 --> 01:21:58,320
and so when we start something new you

2126
01:21:58,320 --> 01:21:59,840
know we have to make some room

2127
01:21:59,840 --> 01:22:01,520
and you know lru is basically a way to

2128
01:22:01,520 --> 01:22:03,280
do it

2129
01:22:03,280 --> 01:22:10,000
okay make sense thank you

