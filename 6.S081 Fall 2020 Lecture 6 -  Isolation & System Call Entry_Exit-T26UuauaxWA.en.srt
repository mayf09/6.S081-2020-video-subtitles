1
00:00:02,320 --> 00:00:03,840
all right

2
00:00:03,840 --> 00:00:06,720
um i'd like to get started first can uh

3
00:00:06,720 --> 00:00:09,200
can anyone hear me

4
00:00:09,200 --> 00:00:13,200
yes good thank you very much

5
00:00:13,200 --> 00:00:16,480
all right today i want to talk about

6
00:00:16,480 --> 00:00:19,119
the transition between running and user

7
00:00:19,119 --> 00:00:19,680
code

8
00:00:19,680 --> 00:00:21,840
running programs in user code and

9
00:00:21,840 --> 00:00:23,359
executing in the kernel

10
00:00:23,359 --> 00:00:24,800
and this is the transition that has to

11
00:00:24,800 --> 00:00:26,720
happen whenever a program makes a system

12
00:00:26,720 --> 00:00:27,439
call

13
00:00:27,439 --> 00:00:29,359
or if it experiences a fault like a page

14
00:00:29,359 --> 00:00:30,960
fault or divide by zero

15
00:00:30,960 --> 00:00:33,920
or if a device decides to interrupt and

16
00:00:33,920 --> 00:00:36,000
needs to be served by a kernel device

17
00:00:36,000 --> 00:00:38,160
driver

18
00:00:38,160 --> 00:00:40,399
there's a lot of careful design and sort

19
00:00:40,399 --> 00:00:43,120
of important details that go into the

20
00:00:43,120 --> 00:00:46,079
how these traps from user to kernel

21
00:00:46,079 --> 00:00:46,800
happen

22
00:00:46,800 --> 00:00:49,440
and the details are pretty important for

23
00:00:49,440 --> 00:00:51,920
enforcing isolation security

24
00:00:51,920 --> 00:00:53,920
and also perform per performance there's

25
00:00:53,920 --> 00:00:55,600
many programs that

26
00:00:55,600 --> 00:00:57,520
transition to the kernel a lot either

27
00:00:57,520 --> 00:00:59,440
due to system calls or page

28
00:00:59,440 --> 00:01:02,160
page faults and it can be super

29
00:01:02,160 --> 00:01:02,719
important

30
00:01:02,719 --> 00:01:05,040
that the uh trap mechanism is as

31
00:01:05,040 --> 00:01:07,520
streamlined as possible

32
00:01:07,520 --> 00:01:10,960
all right so um starting situation is

33
00:01:10,960 --> 00:01:14,870
pretty familiar

34
00:01:14,880 --> 00:01:17,200
we have our user program i'll use the

35
00:01:17,200 --> 00:01:19,360
shell as an example

36
00:01:19,360 --> 00:01:23,510
it's running up in user space and

37
00:01:23,520 --> 00:01:24,960
we have the kernel and what the shell

38
00:01:24,960 --> 00:01:27,520
would like to do is make a system call

39
00:01:27,520 --> 00:01:29,759
into the kernel and i'm going to use

40
00:01:29,759 --> 00:01:31,920
write and use this shell writing its

41
00:01:31,920 --> 00:01:33,680
prompt the very first

42
00:01:33,680 --> 00:01:36,000
write that happens after you boot xv6

43
00:01:36,000 --> 00:01:37,439
and use the shell trying to write

44
00:01:37,439 --> 00:01:40,000
make the right system call as an example

45
00:01:40,000 --> 00:01:42,240
and so we need to figure out how to

46
00:01:42,240 --> 00:01:44,479
actually get execution to transfer from

47
00:01:44,479 --> 00:01:45,840
running in the show

48
00:01:45,840 --> 00:01:48,640
in user space with user privileges to

49
00:01:48,640 --> 00:01:50,079
running in the kernel with supervisor

50
00:01:50,079 --> 00:01:52,079
privileges

51
00:01:52,079 --> 00:01:54,399
the state of the hardware is it's going

52
00:01:54,399 --> 00:01:55,520
to be very important because a lot of

53
00:01:55,520 --> 00:01:56,960
what we're doing is kind of

54
00:01:56,960 --> 00:01:59,520
changing the hardware state from state

55
00:01:59,520 --> 00:02:02,880
appropriate for running user code to um

56
00:02:02,880 --> 00:02:04,320
state appropriate for running kernel

57
00:02:04,320 --> 00:02:06,000
code

58
00:02:06,000 --> 00:02:08,879
the state that we care about um you know

59
00:02:08,879 --> 00:02:10,879
the biggest state is maybe the uh

60
00:02:10,879 --> 00:02:14,400
32 user registers as you remember this

61
00:02:14,400 --> 00:02:15,440
from

62
00:02:15,440 --> 00:02:18,000
monday's discussion we have all the user

63
00:02:18,000 --> 00:02:20,000
registers things like a0

64
00:02:20,000 --> 00:02:24,400
and a1 risk 5 has a whole lot of these

65
00:02:24,400 --> 00:02:26,080
32 in total

66
00:02:26,080 --> 00:02:27,760
and we can expect user code to use all

67
00:02:27,760 --> 00:02:29,200
of them right it's going to get the

68
00:02:29,200 --> 00:02:30,800
highest performance if it uses all of

69
00:02:30,800 --> 00:02:31,760
them

70
00:02:31,760 --> 00:02:33,440
many of them have special purposes a few

71
00:02:33,440 --> 00:02:34,800
which we'll see

72
00:02:34,800 --> 00:02:36,480
a particularly interesting one is the

73
00:02:36,480 --> 00:02:38,560
stack pointer is actually one of these

74
00:02:38,560 --> 00:02:39,760
32

75
00:02:39,760 --> 00:02:44,390
general purpose registers

76
00:02:44,400 --> 00:02:46,319
okay we have these registers including a

77
00:02:46,319 --> 00:02:47,760
stack pointer

78
00:02:47,760 --> 00:02:49,360
there's a separate program counter

79
00:02:49,360 --> 00:02:52,720
register in the hardware

80
00:02:52,720 --> 00:02:55,440
there's the current mode either

81
00:02:55,440 --> 00:02:57,440
supervisor or user and of course it's

82
00:02:57,440 --> 00:03:00,319
user mode when we're executing up in the

83
00:03:00,319 --> 00:03:03,030
in the shell

84
00:03:03,040 --> 00:03:04,640
and then there's a bunch of registers

85
00:03:04,640 --> 00:03:06,879
special registers that control

86
00:03:06,879 --> 00:03:09,120
how the cpu works like there's the sat p

87
00:03:09,120 --> 00:03:10,159
register that

88
00:03:10,159 --> 00:03:13,120
contains a pointer to the page table and

89
00:03:13,120 --> 00:03:14,159
it'll turn out there's a couple of

90
00:03:14,159 --> 00:03:15,680
others that are super important for this

91
00:03:15,680 --> 00:03:16,560
discussion

92
00:03:16,560 --> 00:03:20,000
there's this st which is

93
00:03:20,000 --> 00:03:22,319
addressing the instruction that should

94
00:03:22,319 --> 00:03:24,000
handle traps in the kernel

95
00:03:24,000 --> 00:03:27,920
um there's a register called scpc for

96
00:03:27,920 --> 00:03:29,760
saving the program counter during a trap

97
00:03:29,760 --> 00:03:30,239
and

98
00:03:30,239 --> 00:03:32,400
we'll see there's another one called s

99
00:03:32,400 --> 00:03:33,440
scratch

100
00:03:33,440 --> 00:03:35,360
which is also very important so this is

101
00:03:35,360 --> 00:03:37,680
the state of the running machine

102
00:03:37,680 --> 00:03:39,200
at the time of the system call and we

103
00:03:39,200 --> 00:03:40,640
actually need to change a bunch of this

104
00:03:40,640 --> 00:03:41,920
state or do things

105
00:03:41,920 --> 00:03:44,400
to the state as part of getting into the

106
00:03:44,400 --> 00:03:46,239
kernel

107
00:03:46,239 --> 00:03:47,840
and setting ourselves up to run just

108
00:03:47,840 --> 00:03:50,239
ordinary c functions in the kernel

109
00:03:50,239 --> 00:03:52,959
certainly at the instant of the trap all

110
00:03:52,959 --> 00:03:54,560
the state of the cpu is set up to run

111
00:03:54,560 --> 00:03:55,439
user code

112
00:03:55,439 --> 00:03:58,319
not um not kernel code so the things

113
00:03:58,319 --> 00:03:58,720
that are

114
00:03:58,720 --> 00:04:00,000
going to need to happen is kind of a

115
00:04:00,000 --> 00:04:02,480
preview of what i'll talk about

116
00:04:02,480 --> 00:04:05,360
one is that we need to save all 32

117
00:04:05,360 --> 00:04:06,319
registers because

118
00:04:06,319 --> 00:04:09,439
we want to resume the user code

119
00:04:09,439 --> 00:04:11,040
transparently

120
00:04:11,040 --> 00:04:12,080
particularly if there's a device

121
00:04:12,080 --> 00:04:13,439
interrupt which the user code isn't

122
00:04:13,439 --> 00:04:14,400
expecting

123
00:04:14,400 --> 00:04:15,360
and we want to be able to have the

124
00:04:15,360 --> 00:04:17,600
kernel serve the interrupt and then

125
00:04:17,600 --> 00:04:19,440
resume the user code without ever

126
00:04:19,440 --> 00:04:20,880
noticing any difference and that means

127
00:04:20,880 --> 00:04:22,400
that these 32 registers can't be

128
00:04:22,400 --> 00:04:24,000
disturbed by the kernel

129
00:04:24,000 --> 00:04:26,000
which and since the kernel needs to use

130
00:04:26,000 --> 00:04:27,600
the registers it has to save them all

131
00:04:27,600 --> 00:04:28,000
somewhere

132
00:04:28,000 --> 00:04:31,120
first these need to be saved um the

133
00:04:31,120 --> 00:04:32,720
program counter also needs to be saved

134
00:04:32,720 --> 00:04:33,280
somewhere

135
00:04:33,280 --> 00:04:35,440
because we need to you know it's a user

136
00:04:35,440 --> 00:04:37,680
it's almost like a user register so

137
00:04:37,680 --> 00:04:39,680
we need to continue executing the user

138
00:04:39,680 --> 00:04:41,120
program where it left off

139
00:04:41,120 --> 00:04:43,440
we need to switch the mode to supervisor

140
00:04:43,440 --> 00:04:45,680
mode

141
00:04:45,680 --> 00:04:46,800
because we need to use various

142
00:04:46,800 --> 00:04:49,360
privileges in the kernel

143
00:04:49,360 --> 00:04:52,560
this page table pointer is currently

144
00:04:52,560 --> 00:04:54,400
pointing towards the user page table

145
00:04:54,400 --> 00:04:57,440
which only contains just the mappings

146
00:04:57,440 --> 00:04:59,440
that user programs need

147
00:04:59,440 --> 00:05:01,199
plus one or two more as we'll see but

148
00:05:01,199 --> 00:05:03,120
the user page table does not contain the

149
00:05:03,120 --> 00:05:05,199
mappings for the bulk of the kernel data

150
00:05:05,199 --> 00:05:06,960
so we need to switch page tables before

151
00:05:06,960 --> 00:05:10,479
we can run most kernel code

152
00:05:10,479 --> 00:05:12,240
we need to switch the stack pointer to

153
00:05:12,240 --> 00:05:13,840
point to a stack that's in the kernel

154
00:05:13,840 --> 00:05:14,720
somewhere because

155
00:05:14,720 --> 00:05:19,749
we need a stack to call c functions on

156
00:05:19,759 --> 00:05:21,919
and finally we need to jump into once

157
00:05:21,919 --> 00:05:23,440
we've set all this up and switched all

158
00:05:23,440 --> 00:05:25,520
this all these resources to be

159
00:05:25,520 --> 00:05:27,919
appropriate for use in the kernel we

160
00:05:27,919 --> 00:05:28,800
need to jump to

161
00:05:28,800 --> 00:05:32,560
kernel c code and once we're in c code

162
00:05:32,560 --> 00:05:36,240
life is much more sort of business as

163
00:05:36,240 --> 00:05:37,280
usual we're just running

164
00:05:37,280 --> 00:05:39,840
a c program in this kernel um and so for

165
00:05:39,840 --> 00:05:40,880
today at least we'll

166
00:05:40,880 --> 00:05:43,520
we'll talk about what the kernel does in

167
00:05:43,520 --> 00:05:44,639
the c code later

168
00:05:44,639 --> 00:05:46,720
but today the discussion is really how

169
00:05:46,720 --> 00:05:48,400
to get from user space into the kernel

170
00:05:48,400 --> 00:05:51,039
into a position where we can run

171
00:05:51,039 --> 00:05:54,479
c code in the kernel there's a couple of

172
00:05:54,479 --> 00:05:56,160
high level goals that can strain

173
00:05:56,160 --> 00:05:59,440
our design options for this one is that

174
00:05:59,440 --> 00:06:01,280
for security and isolation we really

175
00:06:01,280 --> 00:06:02,960
don't want to let user code

176
00:06:02,960 --> 00:06:05,440
interfere with this user kernel

177
00:06:05,440 --> 00:06:06,080
transition

178
00:06:06,080 --> 00:06:07,520
in a way that could be damaging to

179
00:06:07,520 --> 00:06:10,080
security and so that means that

180
00:06:10,080 --> 00:06:12,880
the sort of hardware and kernel

181
00:06:12,880 --> 00:06:14,800
mechanisms that are involved in traps

182
00:06:14,800 --> 00:06:17,120
really can't count on anything from user

183
00:06:17,120 --> 00:06:17,840
space

184
00:06:17,840 --> 00:06:19,600
you know we can't assume anything about

185
00:06:19,600 --> 00:06:20,960
these registers they could be just

186
00:06:20,960 --> 00:06:23,440
filled with terribly malicious values

187
00:06:23,440 --> 00:06:26,160
um so basically the xp6 scrap handler

188
00:06:26,160 --> 00:06:27,440
doesn't really even look at these

189
00:06:27,440 --> 00:06:31,199
registers it just saves them away um

190
00:06:31,199 --> 00:06:33,440
so okay so we're going to want to be

191
00:06:33,440 --> 00:06:34,240
careful

192
00:06:34,240 --> 00:06:35,919
to preserve isolation during this trap

193
00:06:35,919 --> 00:06:37,280
mechanism against

194
00:06:37,280 --> 00:06:40,160
intentionally malicious user code and

195
00:06:40,160 --> 00:06:41,440
the other thing that's important

196
00:06:41,440 --> 00:06:43,520
is that we want to be transparent to

197
00:06:43,520 --> 00:06:45,520
user code we'd like to be able to

198
00:06:45,520 --> 00:06:47,120
take the trap and do our business in the

199
00:06:47,120 --> 00:06:49,199
kernel and resume the user code without

200
00:06:49,199 --> 00:06:50,800
it ever having to notice that anything

201
00:06:50,800 --> 00:06:52,000
funny happened

202
00:06:52,000 --> 00:06:53,199
and that's just to make it easier to

203
00:06:53,199 --> 00:06:56,710
write user code

204
00:06:56,720 --> 00:07:00,319
and something to note we care about

205
00:07:00,319 --> 00:07:02,160
isolation security here today we're just

206
00:07:02,160 --> 00:07:04,800
going to talk about the

207
00:07:04,800 --> 00:07:06,319
sort of aspect of security that involves

208
00:07:06,319 --> 00:07:08,319
getting into the kernel but of course

209
00:07:08,319 --> 00:07:09,919
the system called implementations you

210
00:07:09,919 --> 00:07:11,919
know the actual right implementation in

211
00:07:11,919 --> 00:07:12,960
the kernel

212
00:07:12,960 --> 00:07:14,720
also everything in the kernel has to be

213
00:07:14,720 --> 00:07:16,400
careful has to be written carefully and

214
00:07:16,400 --> 00:07:18,400
securely also

215
00:07:18,400 --> 00:07:21,199
so even if this transition into the

216
00:07:21,199 --> 00:07:21,840
kernel is

217
00:07:21,840 --> 00:07:23,599
perfectly secure the whole rest of the

218
00:07:23,599 --> 00:07:24,880
kernel has to be

219
00:07:24,880 --> 00:07:26,800
written securely and sort of mindful

220
00:07:26,800 --> 00:07:31,909
that user code may be trying to trick it

221
00:07:31,919 --> 00:07:33,840
a particularly important thing i want to

222
00:07:33,840 --> 00:07:36,160
talk about is what it is that the mode

223
00:07:36,160 --> 00:07:39,199
flag controls

224
00:07:39,199 --> 00:07:41,280
this mode is either user or supervisor

225
00:07:41,280 --> 00:07:42,720
of course it's user

226
00:07:42,720 --> 00:07:44,800
when we're up in user space and the mode

227
00:07:44,800 --> 00:07:46,240
flag is set to supervisor when we're

228
00:07:46,240 --> 00:07:47,599
executing in the kernel

229
00:07:47,599 --> 00:07:50,720
but it's important to know exactly what

230
00:07:50,720 --> 00:07:53,680
privileges we gain by changing the mode

231
00:07:53,680 --> 00:07:55,199
from user to supervisor

232
00:07:55,199 --> 00:07:58,319
and it turns out these extra privileges

233
00:07:58,319 --> 00:07:59,039
are

234
00:07:59,039 --> 00:08:01,840
fairly restrictive that is what you can

235
00:08:01,840 --> 00:08:03,759
do in supervisor mode that you couldn't

236
00:08:03,759 --> 00:08:05,840
do in user mode

237
00:08:05,840 --> 00:08:09,830
is not maybe as

238
00:08:09,840 --> 00:08:11,199
privileged as you might think so this is

239
00:08:11,199 --> 00:08:13,840
supervisor mode like exactly what it

240
00:08:13,840 --> 00:08:17,110
controls

241
00:08:17,120 --> 00:08:19,919
one thing it does is you can now read

242
00:08:19,919 --> 00:08:20,639
and write

243
00:08:20,639 --> 00:08:25,039
the control registers and

244
00:08:25,039 --> 00:08:26,720
that is if if you're in supervisor mode

245
00:08:26,720 --> 00:08:29,039
you can read and write sat p

246
00:08:29,039 --> 00:08:31,280
uh the page table pointer this st vac

247
00:08:31,280 --> 00:08:32,880
pointer which controls

248
00:08:32,880 --> 00:08:36,000
where traps go in the kernel um

249
00:08:36,000 --> 00:08:37,919
this register that holds the save

250
00:08:37,919 --> 00:08:39,599
program counter during a trap in this

251
00:08:39,599 --> 00:08:42,880
s scratch register plus a few others

252
00:08:42,880 --> 00:08:44,240
so supervisor couldn't read and write

253
00:08:44,240 --> 00:08:46,880
these registers and user code could not

254
00:08:46,880 --> 00:08:48,880
the only other thing supervisor code can

255
00:08:48,880 --> 00:08:50,480
do is

256
00:08:50,480 --> 00:08:55,839
it can use pte's

257
00:08:55,839 --> 00:08:59,040
that have the pteu flag set

258
00:08:59,040 --> 00:09:00,160
i don't know if you remember but there's

259
00:09:00,160 --> 00:09:02,720
this ptu flag to be set or not said in

260
00:09:02,720 --> 00:09:03,120
each

261
00:09:03,120 --> 00:09:06,640
page table entry a flag

262
00:09:06,640 --> 00:09:09,920
that has this sorry sorry

263
00:09:09,920 --> 00:09:13,200
you can use ptes that

264
00:09:13,200 --> 00:09:16,640
don't have the ptu flag set if the pteu

265
00:09:16,640 --> 00:09:18,640
flag is set it means that user code can

266
00:09:18,640 --> 00:09:20,560
use that page table entry

267
00:09:20,560 --> 00:09:22,240
if this flag isn't set in a page table

268
00:09:22,240 --> 00:09:23,600
entry it means only

269
00:09:23,600 --> 00:09:26,720
supervisor mode can use it um and you

270
00:09:26,720 --> 00:09:26,959
know

271
00:09:26,959 --> 00:09:28,720
we'll see that's important in a little

272
00:09:28,720 --> 00:09:30,000
bit but

273
00:09:30,000 --> 00:09:31,440
um these are really the only things that

274
00:09:31,440 --> 00:09:32,800
supervisor mode can do it can't do

275
00:09:32,800 --> 00:09:35,519
anything else in particular for example

276
00:09:35,519 --> 00:09:38,560
supervisor mode code can't just

277
00:09:38,560 --> 00:09:41,519
read and write arbitrary addresses say

278
00:09:41,519 --> 00:09:42,480
physical addresses

279
00:09:42,480 --> 00:09:45,360
no supervisor mode is forced to go

280
00:09:45,360 --> 00:09:46,320
through the page table

281
00:09:46,320 --> 00:09:48,560
just like any other code if a virtual

282
00:09:48,560 --> 00:09:50,000
address isn't in the page

283
00:09:50,000 --> 00:09:51,360
isn't it in the current page table

284
00:09:51,360 --> 00:09:53,040
pointed to by sat p

285
00:09:53,040 --> 00:09:56,320
um or if it has the pteu bit flag

286
00:09:56,320 --> 00:09:58,480
set which means it's the user ppe then

287
00:09:58,480 --> 00:09:59,680
supervisor mode code

288
00:09:59,680 --> 00:10:02,959
cannot use that address so we're even

289
00:10:02,959 --> 00:10:05,279
in supervisor mode were restricted to

290
00:10:05,279 --> 00:10:06,399
whatever

291
00:10:06,399 --> 00:10:08,800
virtual address virtual addresses were

292
00:10:08,800 --> 00:10:12,160
set up in the current page table

293
00:10:12,160 --> 00:10:15,120
um and that's it so we're just allowed

294
00:10:15,120 --> 00:10:17,200
to do these things so you know we'll see

295
00:10:17,200 --> 00:10:20,880
as a significant constraint on what the

296
00:10:20,880 --> 00:10:24,079
trap code can do when we're entering the

297
00:10:24,079 --> 00:10:25,200
kernel

298
00:10:25,200 --> 00:10:27,360
can't do just anything i'm going to

299
00:10:27,360 --> 00:10:28,320
preview a bit

300
00:10:28,320 --> 00:10:30,959
i'm going to spend most of this lecture

301
00:10:30,959 --> 00:10:32,720
in gdb

302
00:10:32,720 --> 00:10:35,519
actually tracing through the execution

303
00:10:35,519 --> 00:10:36,320
of

304
00:10:36,320 --> 00:10:39,760
a trap entry into the kernel in return

305
00:10:39,760 --> 00:10:45,269
this can be a lot of details in order to

306
00:10:45,279 --> 00:10:48,959
uh maybe sort of help you

307
00:10:48,959 --> 00:10:51,440
see ahead to what's coming we're going

308
00:10:51,440 --> 00:10:53,040
to be

309
00:10:53,040 --> 00:10:56,240
tracing the shells call to

310
00:10:56,240 --> 00:10:58,000
right which from the shell's point of

311
00:10:58,000 --> 00:11:00,000
view is just a c function call as part

312
00:11:00,000 --> 00:11:01,839
of the shell

313
00:11:01,839 --> 00:11:04,480
in fact wright makes this uh might

314
00:11:04,480 --> 00:11:05,839
that's use the system call

315
00:11:05,839 --> 00:11:09,750
by issuing the e-call instruction

316
00:11:09,760 --> 00:11:12,640
which switches into the kernel which is

317
00:11:12,640 --> 00:11:14,399
a supervisor mode where that goes

318
00:11:14,399 --> 00:11:16,240
immediately that is the very first

319
00:11:16,240 --> 00:11:18,079
instruction that's executed in the

320
00:11:18,079 --> 00:11:20,160
kernel in supervisor mode

321
00:11:20,160 --> 00:11:22,560
is in a function written in assembler

322
00:11:22,560 --> 00:11:23,839
called

323
00:11:23,839 --> 00:11:27,440
userback and this is in the

324
00:11:27,440 --> 00:11:33,269
part of the trampoline um

325
00:11:33,279 --> 00:11:36,079
uh in trampoline.s in the kernel source

326
00:11:36,079 --> 00:11:37,760
so the very first code that's executed

327
00:11:37,760 --> 00:11:38,800
is this uservec

328
00:11:38,800 --> 00:11:43,120
assembler function um then next

329
00:11:43,120 --> 00:11:44,880
the that assembler function jumps into c

330
00:11:44,880 --> 00:11:46,800
code in particular a function called

331
00:11:46,800 --> 00:11:48,240
usertrap

332
00:11:48,240 --> 00:11:51,760
in trap.c um and now we're

333
00:11:51,760 --> 00:11:54,160
getting it to c code so things are much

334
00:11:54,160 --> 00:11:55,440
easier to understand

335
00:11:55,440 --> 00:11:57,760
user trap sees oh we're executing a

336
00:11:57,760 --> 00:11:58,880
system call

337
00:11:58,880 --> 00:12:02,710
and it calls a function called syscall

338
00:12:02,720 --> 00:12:04,160
which looks up the system call number in

339
00:12:04,160 --> 00:12:06,560
a table and calls the particular

340
00:12:06,560 --> 00:12:08,880
function inside the kernel that

341
00:12:08,880 --> 00:12:10,399
implements that system calling for us

342
00:12:10,399 --> 00:12:12,320
it's going to be right and right does

343
00:12:12,320 --> 00:12:15,040
this business it happens to you know

344
00:12:15,040 --> 00:12:17,120
uh arrange for the whatever bytes were

345
00:12:17,120 --> 00:12:20,160
written to appear on the console

346
00:12:20,160 --> 00:12:22,399
and when it's finished it returns back

347
00:12:22,399 --> 00:12:24,880
up to this system call function

348
00:12:24,880 --> 00:12:26,560
and then the system call function on in

349
00:12:26,560 --> 00:12:28,079
order to return back to user space

350
00:12:28,079 --> 00:12:29,680
because we want to resume

351
00:12:29,680 --> 00:12:32,240
after the z call there's a bunch of

352
00:12:32,240 --> 00:12:32,959
stuff

353
00:12:32,959 --> 00:12:35,360
we'll see that has to happen in order to

354
00:12:35,360 --> 00:12:36,639
return to user space so there's a

355
00:12:36,639 --> 00:12:40,310
separate function called user

356
00:12:40,320 --> 00:12:43,839
trap rat it's written in c

357
00:12:43,839 --> 00:12:47,040
it's in trap.c that does the part of

358
00:12:47,040 --> 00:12:48,800
this return to user space that's

359
00:12:48,800 --> 00:12:50,480
convenient to do in c code

360
00:12:50,480 --> 00:12:51,519
there's some final things that really

361
00:12:51,519 --> 00:12:54,800
can only be done in assembly code

362
00:12:54,800 --> 00:12:56,240
and the code for that is written in

363
00:12:56,240 --> 00:12:57,600
assembler and it's again in this

364
00:12:57,600 --> 00:12:58,880
trampoline page

365
00:12:58,880 --> 00:13:04,150
in a function called user ret

366
00:13:04,160 --> 00:13:07,120
to the last some last assembly stuff

367
00:13:07,120 --> 00:13:08,800
that has to happen and finally

368
00:13:08,800 --> 00:13:11,920
um this assembly function issues the

369
00:13:11,920 --> 00:13:13,760
machine instruction that returns back in

370
00:13:13,760 --> 00:13:15,360
the user space and

371
00:13:15,360 --> 00:13:20,639
resume execution after the e-column

372
00:13:20,639 --> 00:13:22,160
all right does anybody want to answer

373
00:13:22,160 --> 00:13:24,560
ask a question i'm about to switch into

374
00:13:24,560 --> 00:13:27,040
looking at stuff with gdb um any

375
00:13:27,040 --> 00:13:32,829
questions about the sort of high level

376
00:13:32,839 --> 00:13:37,030
picture

377
00:13:37,040 --> 00:13:40,800
all right i am going to

378
00:13:40,800 --> 00:13:44,079
sorry um let me see

379
00:13:44,079 --> 00:13:48,079
what mode our vm.c functions run in uh

380
00:13:48,079 --> 00:13:49,920
vm.c functions everything in there is a

381
00:13:49,920 --> 00:13:51,120
part of the kernel and it's running

382
00:13:51,120 --> 00:13:54,790
supervisor mode

383
00:13:54,800 --> 00:14:00,389
um yeah

384
00:14:00,399 --> 00:14:02,399
okay somebody asks why these functions

385
00:14:02,399 --> 00:14:03,680
are named this way

386
00:14:03,680 --> 00:14:07,680
um uh the naming is a bit of a disaster

387
00:14:07,680 --> 00:14:09,920
and for next year i'm resolved to

388
00:14:09,920 --> 00:14:13,670
make them more rational

389
00:14:13,680 --> 00:14:15,120
i think the naming question might have

390
00:14:15,120 --> 00:14:17,199
referred to the name of the registers

391
00:14:17,199 --> 00:14:19,519
in the previous board they all started

392
00:14:19,519 --> 00:14:20,240
like yes

393
00:14:20,240 --> 00:14:21,620
for supervisor

394
00:14:21,620 --> 00:14:24,079
[Music]

395
00:14:24,079 --> 00:14:27,680
other than that it's there's five people

396
00:14:27,680 --> 00:14:30,880
pick these names somebody's asking don't

397
00:14:30,880 --> 00:14:32,320
the vm.c functions

398
00:14:32,320 --> 00:14:34,720
access physical memory directly that's

399
00:14:34,720 --> 00:14:35,839
absolutely true

400
00:14:35,839 --> 00:14:37,120
the reason why they're allowed to do

401
00:14:37,120 --> 00:14:39,360
that though is that the kernel carefully

402
00:14:39,360 --> 00:14:41,680
sets up direct mappings in the page

403
00:14:41,680 --> 00:14:42,480
table

404
00:14:42,480 --> 00:14:44,320
there's many many pte's in the page

405
00:14:44,320 --> 00:14:46,720
table which cause

406
00:14:46,720 --> 00:14:49,040
whenever the colonel tries to read or

407
00:14:49,040 --> 00:14:50,720
write a physical address it actually is

408
00:14:50,720 --> 00:14:53,040
a virtual address that's translated

409
00:14:53,040 --> 00:14:55,040
by the kernel page table into the

410
00:14:55,040 --> 00:14:56,399
physical address that's equal

411
00:14:56,399 --> 00:14:59,199
to the virtual address it was issued so

412
00:14:59,199 --> 00:15:01,600
it's like super convenient in the kernel

413
00:15:01,600 --> 00:15:03,600
once you're using the kernel page table

414
00:15:03,600 --> 00:15:05,199
because the kernel has all these direct

415
00:15:05,199 --> 00:15:06,399
mappings

416
00:15:06,399 --> 00:15:10,000
but until we've set up the current

417
00:15:10,000 --> 00:15:12,320
until the trap machinery has switched to

418
00:15:12,320 --> 00:15:13,680
the kernel page table

419
00:15:13,680 --> 00:15:15,760
none of those mappings are available so

420
00:15:15,760 --> 00:15:16,880
until the

421
00:15:16,880 --> 00:15:18,160
kernel trap code is switched to the

422
00:15:18,160 --> 00:15:19,440
kernel page table we're still using the

423
00:15:19,440 --> 00:15:21,199
user page table which has none of these

424
00:15:21,199 --> 00:15:23,360
convenient mappings

425
00:15:23,360 --> 00:15:29,749
for physical addresses

426
00:15:29,759 --> 00:15:34,710
okay

427
00:15:34,720 --> 00:15:37,839
can i ask a question please um

428
00:15:37,839 --> 00:15:41,120
so um um

429
00:15:41,120 --> 00:15:43,120
i don't know this is maybe not exactly

430
00:15:43,120 --> 00:15:45,040
relevant to what was just said but

431
00:15:45,040 --> 00:15:48,240
um the read and write system calls right

432
00:15:48,240 --> 00:15:48,880
like those

433
00:15:48,880 --> 00:15:51,519
are pretty expensive compared to just a

434
00:15:51,519 --> 00:15:52,160
memory

435
00:15:52,160 --> 00:15:53,360
store because you have to actually

436
00:15:53,360 --> 00:15:55,440
switch modes and go back and forth

437
00:15:55,440 --> 00:15:57,759
would it be possible to just like

438
00:15:57,759 --> 00:16:00,000
instead of when when you open a file

439
00:16:00,000 --> 00:16:01,440
instead of getting back a file

440
00:16:01,440 --> 00:16:03,360
descriptor that you call with the system

441
00:16:03,360 --> 00:16:04,000
call

442
00:16:04,000 --> 00:16:07,120
to get a page table mapping

443
00:16:07,120 --> 00:16:08,959
and then you would just write to a

444
00:16:08,959 --> 00:16:10,560
certain address

445
00:16:10,560 --> 00:16:13,519
that's just mapped to the device and you

446
00:16:13,519 --> 00:16:15,360
can set up the restrictions so that

447
00:16:15,360 --> 00:16:17,839
the the program can only write to a

448
00:16:17,839 --> 00:16:19,120
device to like a

449
00:16:19,120 --> 00:16:20,800
file descriptor that it's allowed to

450
00:16:20,800 --> 00:16:22,560
which is allowed to through the virtual

451
00:16:22,560 --> 00:16:23,040
page

452
00:16:23,040 --> 00:16:24,800
table mapping instead of jumping to the

453
00:16:24,800 --> 00:16:26,160
kernel and back

454
00:16:26,160 --> 00:16:28,240
yeah that's a good observation and

455
00:16:28,240 --> 00:16:29,519
indeed uh

456
00:16:29,519 --> 00:16:31,199
many operating systems provide this

457
00:16:31,199 --> 00:16:33,759
what's called memory mapped file access

458
00:16:33,759 --> 00:16:34,399
where

459
00:16:34,399 --> 00:16:36,560
indeed you map pages that correspond to

460
00:16:36,560 --> 00:16:37,920
the file contents

461
00:16:37,920 --> 00:16:40,480
into the into your virtual into the user

462
00:16:40,480 --> 00:16:42,079
virtual address space so you can read or

463
00:16:42,079 --> 00:16:42,639
write them

464
00:16:42,639 --> 00:16:45,360
directly through memory in fact you'll

465
00:16:45,360 --> 00:16:46,959
be implementing a version of this

466
00:16:46,959 --> 00:16:51,199
in the map lab in a couple of weeks

467
00:16:51,199 --> 00:16:54,079
and indeed as you apply it's a good deal

468
00:16:54,079 --> 00:16:54,880
faster

469
00:16:54,880 --> 00:16:56,560
for many programs than calling a medium

470
00:16:56,560 --> 00:16:59,110
right

471
00:16:59,120 --> 00:17:02,310
okay

472
00:17:02,320 --> 00:17:19,520
i'm gonna switch to the gdb world

473
00:17:19,520 --> 00:17:20,959
all right at this point everybody should

474
00:17:20,959 --> 00:17:26,309
uh

475
00:17:26,319 --> 00:17:31,190
see my screen share

476
00:17:31,200 --> 00:17:33,280
we're going to watch an xv system call

477
00:17:33,280 --> 00:17:35,200
the write

478
00:17:35,200 --> 00:17:38,080
the shells right of its initial prompt

479
00:17:38,080 --> 00:17:39,440
make its way through the system you can

480
00:17:39,440 --> 00:17:39,760
see

481
00:17:39,760 --> 00:17:42,400
the user code that initiates this in

482
00:17:42,400 --> 00:17:44,799
sh.c

483
00:17:44,799 --> 00:17:46,000
and i'm showing that here it's just

484
00:17:46,000 --> 00:17:49,120
making the right system call

485
00:17:49,120 --> 00:17:52,000
with this dollar sign prompt um let me

486
00:17:52,000 --> 00:17:58,830
fire up

487
00:17:58,840 --> 00:18:03,350
gdb

488
00:18:03,360 --> 00:18:06,720
excellent so what actually happens when

489
00:18:06,720 --> 00:18:07,280
user

490
00:18:07,280 --> 00:18:09,919
code when the shell calls right right is

491
00:18:09,919 --> 00:18:10,799
just a

492
00:18:10,799 --> 00:18:13,919
it's a library function that's part of

493
00:18:13,919 --> 00:18:15,840
the

494
00:18:15,840 --> 00:18:18,400
that's linked into the shell and you can

495
00:18:18,400 --> 00:18:20,090
see the source for it in

496
00:18:20,090 --> 00:18:21,960
[Music]

497
00:18:21,960 --> 00:18:24,640
usys.s

498
00:18:24,640 --> 00:18:26,720
so it's this couple of instructions here

499
00:18:26,720 --> 00:18:29,440
is the implementation of the write

500
00:18:29,440 --> 00:18:30,240
function

501
00:18:30,240 --> 00:18:33,679
that the shell is actually calling and

502
00:18:33,679 --> 00:18:35,679
this is a very short function all it's

503
00:18:35,679 --> 00:18:37,679
doing is loading into a7

504
00:18:37,679 --> 00:18:40,000
a number cis write which is just

505
00:18:40,000 --> 00:18:42,160
symbolically defined to be 16 that tells

506
00:18:42,160 --> 00:18:43,760
the kernel

507
00:18:43,760 --> 00:18:47,039
i want to run the 16th system call which

508
00:18:47,039 --> 00:18:48,559
happens to be right

509
00:18:48,559 --> 00:18:50,559
and then this little function uses the

510
00:18:50,559 --> 00:18:52,480
e-call instruction

511
00:18:52,480 --> 00:18:55,039
which is what actually gets the code

512
00:18:55,039 --> 00:18:56,400
into the kernel the kernel

513
00:18:56,400 --> 00:18:59,039
does its thing um and then when the

514
00:18:59,039 --> 00:19:01,520
kernel is finally done it returns

515
00:19:01,520 --> 00:19:03,200
back into user space to execute the

516
00:19:03,200 --> 00:19:04,960
instruction after the e-call

517
00:19:04,960 --> 00:19:07,679
which is that rhett that returns back to

518
00:19:07,679 --> 00:19:08,880
the shell

519
00:19:08,880 --> 00:19:10,880
returns from that right library function

520
00:19:10,880 --> 00:19:12,960
back into the shell

521
00:19:12,960 --> 00:19:14,640
so what i'd like to do in order to show

522
00:19:14,640 --> 00:19:16,000
the system call part of this

523
00:19:16,000 --> 00:19:17,440
i'm going to start by putting a break

524
00:19:17,440 --> 00:19:19,039
point on that

525
00:19:19,039 --> 00:19:22,400
e-call instruction and

526
00:19:22,400 --> 00:19:24,320
we need to know its address of course

527
00:19:24,320 --> 00:19:26,039
but we can find that out by looking in

528
00:19:26,039 --> 00:19:28,160
sh.asm which the

529
00:19:28,160 --> 00:19:31,600
xp6 compilation process produces um and

530
00:19:31,600 --> 00:19:33,000
an

531
00:19:33,000 --> 00:19:36,240
xbsh.asm there's a assembly code with

532
00:19:36,240 --> 00:19:37,520
addresses

533
00:19:37,520 --> 00:19:41,520
of the um the instructions

534
00:19:41,520 --> 00:19:43,520
for the shell so i'm going to put a

535
00:19:43,520 --> 00:19:44,640
breakpoint on the e

536
00:19:44,640 --> 00:19:47,919
call instruction which is it d address

537
00:19:47,919 --> 00:19:51,270
de6

538
00:19:51,280 --> 00:19:52,880
excellent now i'm going to actually

539
00:19:52,880 --> 00:19:54,559
start xc6 running

540
00:19:54,559 --> 00:19:57,679
and i'm hoping to have the system break

541
00:19:57,679 --> 00:20:02,000
in the shell just before executing ecall

542
00:20:02,000 --> 00:20:04,799
all right excellent um we're now you can

543
00:20:04,799 --> 00:20:06,559
see from gdb we're about to

544
00:20:06,559 --> 00:20:11,360
uh we're about to execute that e call

545
00:20:11,360 --> 00:20:15,039
let's just check that we are where we

546
00:20:15,039 --> 00:20:16,000
think we are

547
00:20:16,000 --> 00:20:17,919
let's print we can print the program

548
00:20:17,919 --> 00:20:20,400
counter this is 0x to e6 just what we

549
00:20:20,400 --> 00:20:25,909
asked for

550
00:20:25,919 --> 00:20:30,080
we can also print the all 32 registers

551
00:20:30,080 --> 00:20:32,799
and some of these values whatever we

552
00:20:32,799 --> 00:20:34,080
don't know we don't care what they

553
00:20:34,080 --> 00:20:37,440
are but a0 a1 and a2 are the three

554
00:20:37,440 --> 00:20:38,960
arguments that the shell passed

555
00:20:38,960 --> 00:20:41,679
right so those arguments are file

556
00:20:41,679 --> 00:20:42,720
descriptor two

557
00:20:42,720 --> 00:20:45,440
in a zero um the pointer to the buffer

558
00:20:45,440 --> 00:20:47,120
of characters that the shell wants to

559
00:20:47,120 --> 00:20:48,720
write in a1

560
00:20:48,720 --> 00:20:50,320
and the number of characters it wants to

561
00:20:50,320 --> 00:20:52,400
write in a2

562
00:20:52,400 --> 00:20:53,760
and we can convince ourselves that we're

563
00:20:53,760 --> 00:20:55,280
looking at the code we think we're

564
00:20:55,280 --> 00:20:56,880
looking at

565
00:20:56,880 --> 00:21:00,390
by actually printing out

566
00:21:00,400 --> 00:21:02,159
the bytes in that buffer that the

567
00:21:02,159 --> 00:21:03,919
shuttle wants to write and indeed it's a

568
00:21:03,919 --> 00:21:05,120
dollar sign

569
00:21:05,120 --> 00:21:08,159
and a space so um

570
00:21:08,159 --> 00:21:10,080
we're at the system call that we we hope

571
00:21:10,080 --> 00:21:11,360
to be at

572
00:21:11,360 --> 00:21:13,280
one thing to notice is that the program

573
00:21:13,280 --> 00:21:14,720
counter and the stack point are both at

574
00:21:14,720 --> 00:21:16,000
low addresses

575
00:21:16,000 --> 00:21:18,159
address is quite close to zero and that

576
00:21:18,159 --> 00:21:19,520
um

577
00:21:19,520 --> 00:21:21,760
just reinforces our belief that we're

578
00:21:21,760 --> 00:21:22,640
still executing

579
00:21:22,640 --> 00:21:24,960
in user and the user address space where

580
00:21:24,960 --> 00:21:26,559
all the addresses are quite small once

581
00:21:26,559 --> 00:21:27,760
we get into the kernel you see the

582
00:21:27,760 --> 00:21:28,799
addresses are

583
00:21:28,799 --> 00:21:30,240
the kernels actually loaded much much

584
00:21:30,240 --> 00:21:34,950
higher in memory

585
00:21:34,960 --> 00:21:39,120
okay we the point of the system call is

586
00:21:39,120 --> 00:21:39,520
to

587
00:21:39,520 --> 00:21:41,120
switch around a lot of state one of the

588
00:21:41,120 --> 00:21:42,720
most important pieces of state

589
00:21:42,720 --> 00:21:44,400
that has to get switched and that we

590
00:21:44,400 --> 00:21:46,320
have to live with before it's switched

591
00:21:46,320 --> 00:21:48,880
is the current page table of course we

592
00:21:48,880 --> 00:21:50,000
can look at

593
00:21:50,000 --> 00:21:53,039
uh sat p

594
00:21:53,039 --> 00:21:55,039
um but all we get there is the address

595
00:21:55,039 --> 00:21:56,320
in physical memory the page table

596
00:21:56,320 --> 00:21:58,000
doesn't actually tell us much about what

597
00:21:58,000 --> 00:21:59,120
the mappings are

598
00:21:59,120 --> 00:22:02,320
what the page table looks like luckily

599
00:22:02,320 --> 00:22:05,760
there's a way in qmu to ask it to print

600
00:22:05,760 --> 00:22:06,960
the current page table

601
00:22:06,960 --> 00:22:10,159
and if i print ctrl a c i get into the

602
00:22:10,159 --> 00:22:11,440
qmu

603
00:22:11,440 --> 00:22:14,159
monitor or console and if i then type

604
00:22:14,159 --> 00:22:16,240
info mam

605
00:22:16,240 --> 00:22:19,440
it'll print the complete page table

606
00:22:19,440 --> 00:22:21,039
now this is a very small page table that

607
00:22:21,039 --> 00:22:23,679
contains only six mappings

608
00:22:23,679 --> 00:22:25,200
of course it's the page table for the

609
00:22:25,200 --> 00:22:28,080
shell shell's a pretty small

610
00:22:28,080 --> 00:22:30,960
program and these six mappings are in

611
00:22:30,960 --> 00:22:31,919
order

612
00:22:31,919 --> 00:22:34,960
the shell's instructions the shell's

613
00:22:34,960 --> 00:22:35,840
data

614
00:22:35,840 --> 00:22:39,520
an invalid page which access the

615
00:22:39,520 --> 00:22:41,520
stack a guard page in case the shuttle

616
00:22:41,520 --> 00:22:43,360
tries to use too much stack space

617
00:22:43,360 --> 00:22:45,440
and we can see it's invalid because it

618
00:22:45,440 --> 00:22:47,360
doesn't have the u flag set

619
00:22:47,360 --> 00:22:50,799
over here in this attribute or flag

620
00:22:50,799 --> 00:22:52,640
column

621
00:22:52,640 --> 00:22:54,799
these are all the pte underscore flags

622
00:22:54,799 --> 00:22:55,919
rw and x are

623
00:22:55,919 --> 00:22:58,000
just control whether a page can be read

624
00:22:58,000 --> 00:22:59,919
or written or executed

625
00:22:59,919 --> 00:23:01,679
the next column is you and that's

626
00:23:01,679 --> 00:23:03,679
whether or not the pteu flag is set and

627
00:23:03,679 --> 00:23:05,440
user code can only get at

628
00:23:05,440 --> 00:23:08,320
pde entries for which the u flag is set

629
00:23:08,320 --> 00:23:12,789
um

630
00:23:12,799 --> 00:23:14,320
i don't know what the next column is i

631
00:23:14,320 --> 00:23:16,640
have to admit and the next column is a

632
00:23:16,640 --> 00:23:18,400
for whether the page table entries have

633
00:23:18,400 --> 00:23:19,600
ever been used and

634
00:23:19,600 --> 00:23:22,640
d for whether or write has ever been

635
00:23:22,640 --> 00:23:28,149
issued for this address

636
00:23:28,159 --> 00:23:29,840
okay so we have this tiny page and the

637
00:23:29,840 --> 00:23:31,919
last two page table entries by the way

638
00:23:31,919 --> 00:23:32,640
are way up

639
00:23:32,640 --> 00:23:36,640
at um enormous virtual addresses

640
00:23:36,640 --> 00:23:38,960
close to the very close to the top of

641
00:23:38,960 --> 00:23:40,559
the virtual address space

642
00:23:40,559 --> 00:23:43,440
and this is these two um as you read

643
00:23:43,440 --> 00:23:44,640
about in the book and we'll hear much

644
00:23:44,640 --> 00:23:46,720
more about are the trap frame page

645
00:23:46,720 --> 00:23:49,039
and now the trampoline page and as you

646
00:23:49,039 --> 00:23:50,880
can see neither of them

647
00:23:50,880 --> 00:23:54,240
has the u-bits set so user code can't

648
00:23:54,240 --> 00:23:55,520
get at either of these

649
00:23:55,520 --> 00:23:57,760
can't use either of these addresses but

650
00:23:57,760 --> 00:23:59,360
once we enter supervisor mode we can get

651
00:23:59,360 --> 00:24:05,039
at these two pages

652
00:24:05,039 --> 00:24:08,559
all right um one thing you notice about

653
00:24:08,559 --> 00:24:10,000
this page table

654
00:24:10,000 --> 00:24:11,520
is there's no mappings for anything in

655
00:24:11,520 --> 00:24:13,360
the kernel you know there's no physical

656
00:24:13,360 --> 00:24:15,039
address mappings there's no mappings for

657
00:24:15,039 --> 00:24:16,559
the kernel's data or the kernel's

658
00:24:16,559 --> 00:24:18,080
instructions or anything else

659
00:24:18,080 --> 00:24:20,320
this is uh except for the last two just

660
00:24:20,320 --> 00:24:22,000
the very last two pages

661
00:24:22,000 --> 00:24:23,679
now this is a page table almost entirely

662
00:24:23,679 --> 00:24:26,080
dedicated to user execution and is not

663
00:24:26,080 --> 00:24:27,919
directly particularly useful for

664
00:24:27,919 --> 00:24:30,320
executing the kernel

665
00:24:30,320 --> 00:24:33,120
all right what's the what's the a

666
00:24:33,120 --> 00:24:34,320
attribute on the

667
00:24:34,320 --> 00:24:37,279
on the page table listing on the top i

668
00:24:37,279 --> 00:24:38,799
believe this means the page table has

669
00:24:38,799 --> 00:24:40,000
ever been

670
00:24:40,000 --> 00:24:41,919
this page table entry has ever been

671
00:24:41,919 --> 00:24:43,039
accessed

672
00:24:43,039 --> 00:24:46,240
uh by code that is

673
00:24:46,240 --> 00:24:49,039
whether it's ever issued an address that

674
00:24:49,039 --> 00:24:52,159
refers to this page table entry

675
00:24:52,159 --> 00:24:54,640
um and the d is whether the program has

676
00:24:54,640 --> 00:24:56,640
ever written

677
00:24:56,640 --> 00:25:00,000
uh ever done a store through this

678
00:25:00,000 --> 00:25:02,960
page table entry and these are bits that

679
00:25:02,960 --> 00:25:04,559
the hardware maintains for the

680
00:25:04,559 --> 00:25:06,159
convenience of the operating system and

681
00:25:06,159 --> 00:25:07,679
operating systems more sophisticated

682
00:25:07,679 --> 00:25:08,080
than

683
00:25:08,080 --> 00:25:12,480
xv6 may need to evict pages

684
00:25:12,480 --> 00:25:13,679
if they're running short on physical

685
00:25:13,679 --> 00:25:15,840
memory they may need to write

686
00:25:15,840 --> 00:25:18,960
some pages of memory to disk and

687
00:25:18,960 --> 00:25:21,120
invalidate the page table entries to

688
00:25:21,120 --> 00:25:22,960
free up the physical memory

689
00:25:22,960 --> 00:25:25,600
and many policies you could imagine a

690
00:25:25,600 --> 00:25:27,120
operating system using to

691
00:25:27,120 --> 00:25:29,200
pick which pages to exist um we'll

692
00:25:29,200 --> 00:25:30,960
consult the a bits to see whether this

693
00:25:30,960 --> 00:25:33,520
page table entry has ever even been used

694
00:25:33,520 --> 00:25:34,960
um and if it hasn't been used or haven't

695
00:25:34,960 --> 00:25:36,559
been used recently then

696
00:25:36,559 --> 00:25:38,880
that's a good candidate for evicting to

697
00:25:38,880 --> 00:25:40,880
disk

698
00:25:40,880 --> 00:25:44,400
and the d tells the kernel that

699
00:25:44,400 --> 00:25:47,200
oh this page has actually been written

700
00:25:47,200 --> 00:25:50,710
since it was read from disk

701
00:25:50,720 --> 00:25:55,430
xp6 doesn't actually use either of these

702
00:25:55,440 --> 00:26:02,390
all right other questions

703
00:26:02,400 --> 00:26:05,730
all right let's execute the um

704
00:26:05,730 --> 00:26:07,039
[Music]

705
00:26:07,039 --> 00:26:09,120
let me just remind us where we are i'm

706
00:26:09,120 --> 00:26:10,400
going to print out the

707
00:26:10,400 --> 00:26:12,000
contents of the right we're in the right

708
00:26:12,000 --> 00:26:13,679
library function

709
00:26:13,679 --> 00:26:16,870
in uh

710
00:26:16,880 --> 00:26:19,279
in the shell and the program counter is

711
00:26:19,279 --> 00:26:20,640
pointing to the e-call instruction we're

712
00:26:20,640 --> 00:26:23,120
about to execute the e-call instruction

713
00:26:23,120 --> 00:26:24,480
we're still in user space but we won't

714
00:26:24,480 --> 00:26:26,720
be for long um

715
00:26:26,720 --> 00:26:30,320
boom i executed the e-call instruction

716
00:26:30,320 --> 00:26:33,520
okay so first question is where are we

717
00:26:33,520 --> 00:26:36,400
after the e-call we can look at the

718
00:26:36,400 --> 00:26:38,480
program counter

719
00:26:38,480 --> 00:26:40,480
we see this now used to be a very low

720
00:26:40,480 --> 00:26:42,720
number de6 now it's a very high number

721
00:26:42,720 --> 00:26:44,240
in fact we look at the the program

722
00:26:44,240 --> 00:26:46,159
counter as a virtual address

723
00:26:46,159 --> 00:26:50,159
like all addresses that instructions use

724
00:26:50,159 --> 00:26:52,400
and we can look in the page table

725
00:26:52,400 --> 00:26:53,600
actually let's just check what the page

726
00:26:53,600 --> 00:26:54,400
table is

727
00:26:54,400 --> 00:26:58,080
just be sure i'm going to ask qmu for

728
00:26:58,080 --> 00:26:59,600
info mam again

729
00:26:59,600 --> 00:27:02,240
it's the very same page table so

730
00:27:02,240 --> 00:27:03,520
nothing's changed there

731
00:27:03,520 --> 00:27:05,919
we'll look up our new current program

732
00:27:05,919 --> 00:27:06,640
counter there

733
00:27:06,640 --> 00:27:10,159
the program counter is at the

734
00:27:10,159 --> 00:27:11,520
right at the beginning of this

735
00:27:11,520 --> 00:27:13,840
trampoline page that's mapped

736
00:27:13,840 --> 00:27:17,440
way up high and in the user memory

737
00:27:17,440 --> 00:27:19,279
that's where we're executing we can see

738
00:27:19,279 --> 00:27:21,279
the instructions that are there

739
00:27:21,279 --> 00:27:31,510
i'm going to use

740
00:27:31,520 --> 00:27:34,559
these are the instructions

741
00:27:34,559 --> 00:27:36,399
the very first instructions that the

742
00:27:36,399 --> 00:27:38,480
kernel executes in supervisor mode at

743
00:27:38,480 --> 00:27:39,120
the beginning

744
00:27:39,120 --> 00:27:40,960
very beginning of the trap and through

745
00:27:40,960 --> 00:27:42,799
some weirdness in gdb we've actually

746
00:27:42,799 --> 00:27:45,440
already executed the first instruction

747
00:27:45,440 --> 00:27:49,039
at the very beginning of this page

748
00:27:49,039 --> 00:27:51,279
and we're about to execute the second

749
00:27:51,279 --> 00:27:53,440
instruction

750
00:27:53,440 --> 00:27:57,029
we can look at the registers

751
00:27:57,039 --> 00:27:58,080
i don't know if you remember these

752
00:27:58,080 --> 00:28:00,240
register values but nothing has changed

753
00:28:00,240 --> 00:28:02,080
here these are exactly the same register

754
00:28:02,080 --> 00:28:04,480
contents that the user program has

755
00:28:04,480 --> 00:28:06,799
had so these are all full of user values

756
00:28:06,799 --> 00:28:07,600
for many of them

757
00:28:07,600 --> 00:28:09,440
or all of them for all we know they're

758
00:28:09,440 --> 00:28:11,360
the only locations these value exists so

759
00:28:11,360 --> 00:28:12,880
we have to be very careful that we can't

760
00:28:12,880 --> 00:28:13,679
actually use

761
00:28:13,679 --> 00:28:16,720
any registers at this point without

762
00:28:16,720 --> 00:28:19,039
first saving those registers somewhere

763
00:28:19,039 --> 00:28:20,480
so we can restore them

764
00:28:20,480 --> 00:28:22,080
because if the kernel was to use any of

765
00:28:22,080 --> 00:28:23,840
these registers at this point it would

766
00:28:23,840 --> 00:28:28,000
overwrite whatever that user value is

767
00:28:28,000 --> 00:28:29,679
and then if we try to resume the user

768
00:28:29,679 --> 00:28:30,960
program we wouldn't be able to set up

769
00:28:30,960 --> 00:28:32,799
its registers with the correct values

770
00:28:32,799 --> 00:28:33,600
and the

771
00:28:33,600 --> 00:28:35,200
user program would just do something

772
00:28:35,200 --> 00:28:37,039
totally wrong

773
00:28:37,039 --> 00:28:40,320
um a question yes could you return to

774
00:28:40,320 --> 00:28:40,640
the

775
00:28:40,640 --> 00:28:43,279
instructions panel that you had before

776
00:28:43,279 --> 00:28:46,240
i'm wondering what the crrw

777
00:28:46,240 --> 00:28:51,269
instruction is doing

778
00:28:51,279 --> 00:28:54,080
the csr rw okay we'll talk about this uh

779
00:28:54,080 --> 00:28:55,440
in in a few minutes

780
00:28:55,440 --> 00:28:57,279
um but the answer to your question is

781
00:28:57,279 --> 00:28:59,520
that instruction swaps

782
00:28:59,520 --> 00:29:02,720
a0 with the contents of the special

783
00:29:02,720 --> 00:29:07,039
scratch register um and so in

784
00:29:07,039 --> 00:29:09,120
yeah okay and this is like super

785
00:29:09,120 --> 00:29:10,399
important

786
00:29:10,399 --> 00:29:12,799
and basically answers the question how

787
00:29:12,799 --> 00:29:13,600
can the

788
00:29:13,600 --> 00:29:15,600
this kernel trap code do anything if it

789
00:29:15,600 --> 00:29:17,440
can't use any registers

790
00:29:17,440 --> 00:29:19,039
the answer to that question is it exit

791
00:29:19,039 --> 00:29:21,559
really has to execute this

792
00:29:21,559 --> 00:29:25,120
csrw a0 scratch instruction

793
00:29:25,120 --> 00:29:28,559
that simultaneously saves a0 in scratch

794
00:29:28,559 --> 00:29:31,760
and happens to load scratch into a0

795
00:29:31,760 --> 00:29:34,159
so now the kernel can use a0 for

796
00:29:34,159 --> 00:29:35,120
whatever it wants to

797
00:29:35,120 --> 00:29:38,950
after this instruction

798
00:29:38,960 --> 00:29:42,399
okay thanks yeah okay so

799
00:29:42,399 --> 00:29:44,760
we're currently this address this three

800
00:29:44,760 --> 00:29:46,000
ffff000

801
00:29:46,000 --> 00:29:48,080
um this last page is the trampoline page

802
00:29:48,080 --> 00:29:49,520
and we're currently executing

803
00:29:49,520 --> 00:29:51,760
in the trampoline page which contains

804
00:29:51,760 --> 00:29:54,159
the very first instructions

805
00:29:54,159 --> 00:29:58,000
of the kernel's trap handling code

806
00:29:58,000 --> 00:30:00,640
ecall doesn't switch page tables that's

807
00:30:00,640 --> 00:30:02,320
a very important thing about ecall and

808
00:30:02,320 --> 00:30:03,520
what that means is that

809
00:30:03,520 --> 00:30:05,200
these very first instructions have to be

810
00:30:05,200 --> 00:30:08,559
present in every user page table

811
00:30:08,559 --> 00:30:09,919
because since z-call doesn't switch page

812
00:30:09,919 --> 00:30:11,760
tables we need to be executing the first

813
00:30:11,760 --> 00:30:12,960
bit of the kernel

814
00:30:12,960 --> 00:30:14,480
somewhere in the user page table and

815
00:30:14,480 --> 00:30:16,080
it's this trampoline page

816
00:30:16,080 --> 00:30:17,520
which the kernel carefully maps into

817
00:30:17,520 --> 00:30:19,919
every user page table

818
00:30:19,919 --> 00:30:21,919
that gives the kernel a place to execute

819
00:30:21,919 --> 00:30:23,360
at the very beginning of a trap when

820
00:30:23,360 --> 00:30:25,279
we're still using the user page table

821
00:30:25,279 --> 00:30:28,789
and the way this is controlled

822
00:30:28,799 --> 00:30:30,559
is through the st vec register this is

823
00:30:30,559 --> 00:30:32,399
another privileged

824
00:30:32,399 --> 00:30:34,399
register only readable by the writable

825
00:30:34,399 --> 00:30:36,080
by the supervisor

826
00:30:36,080 --> 00:30:37,760
and the kernel before it entered user

827
00:30:37,760 --> 00:30:39,679
space set up the st vec

828
00:30:39,679 --> 00:30:41,360
to point to the place where the colonel

829
00:30:41,360 --> 00:30:42,960
wanted traps to go

830
00:30:42,960 --> 00:30:44,480
and so as you can see the kernel has

831
00:30:44,480 --> 00:30:46,640
previously set up this st deck

832
00:30:46,640 --> 00:30:49,919
to this three ffff000 address which is

833
00:30:49,919 --> 00:30:52,480
the beginning of the trampoline page

834
00:30:52,480 --> 00:30:55,360
and it's this st vec register that its

835
00:30:55,360 --> 00:30:57,200
contents is the reason why after the

836
00:30:57,200 --> 00:30:58,080
e-call

837
00:30:58,080 --> 00:31:01,720
we ended up executing at this particular

838
00:31:01,720 --> 00:31:04,960
place um

839
00:31:04,960 --> 00:31:06,159
and finally i just want to remind you

840
00:31:06,159 --> 00:31:07,760
that even though the trampoline and trap

841
00:31:07,760 --> 00:31:09,760
frame pages are mapped into the user

842
00:31:09,760 --> 00:31:12,000
page table user address space

843
00:31:12,000 --> 00:31:15,039
the user code cannot write them

844
00:31:15,039 --> 00:31:17,279
because the pdes for them don't have the

845
00:31:17,279 --> 00:31:20,000
pteu flag so they're protected

846
00:31:20,000 --> 00:31:22,480
against user code and that's why this

847
00:31:22,480 --> 00:31:23,039
trick is

848
00:31:23,039 --> 00:31:24,320
part of the reason why this trick is

849
00:31:24,320 --> 00:31:27,269
safe

850
00:31:27,279 --> 00:31:29,279
um i've been sort of telling you and

851
00:31:29,279 --> 00:31:31,600
assuming that we're in supervisor mode

852
00:31:31,600 --> 00:31:33,200
i don't know any way of finding out what

853
00:31:33,200 --> 00:31:34,640
mode the machine is in

854
00:31:34,640 --> 00:31:37,840
directly but i do observe that the

855
00:31:37,840 --> 00:31:39,760
program counter is currently executing

856
00:31:39,760 --> 00:31:41,760
in a page the trampoline page

857
00:31:41,760 --> 00:31:44,960
that doesn't have a pdeu flag set

858
00:31:44,960 --> 00:31:47,120
and that can only happen without a crash

859
00:31:47,120 --> 00:31:49,039
if we are in supervisor mode so i

860
00:31:49,039 --> 00:31:52,000
deduce from the lack of a crash um and

861
00:31:52,000 --> 00:31:52,320
the

862
00:31:52,320 --> 00:31:53,840
value of the program calendar that we

863
00:31:53,840 --> 00:31:57,990
must be in supervisor mode

864
00:31:58,000 --> 00:32:00,320
how we got here of course uh is through

865
00:32:00,320 --> 00:32:02,480
ecall ecall really just changes three

866
00:32:02,480 --> 00:32:03,360
things

867
00:32:03,360 --> 00:32:06,080
um first e call changes mode from user

868
00:32:06,080 --> 00:32:07,840
to supervisor

869
00:32:07,840 --> 00:32:10,320
second ecall saves the program counter

870
00:32:10,320 --> 00:32:13,200
register in the sepc register so we can

871
00:32:13,200 --> 00:32:14,880
see the effect of that

872
00:32:14,880 --> 00:32:16,880
print the program register program

873
00:32:16,880 --> 00:32:18,159
counter it's certainly no longer the

874
00:32:18,159 --> 00:32:19,360
user program counter

875
00:32:19,360 --> 00:32:22,399
even though all the other registers were

876
00:32:22,399 --> 00:32:26,559
it's this value copied from sdvac

877
00:32:26,559 --> 00:32:30,720
and we can also print uh the saved

878
00:32:30,720 --> 00:32:33,760
um it's the supervisor exception program

879
00:32:33,760 --> 00:32:35,279
counter is what that stands for

880
00:32:35,279 --> 00:32:37,279
but this is where ecall saves the user

881
00:32:37,279 --> 00:32:39,519
pro prime counter

882
00:32:39,519 --> 00:32:42,000
and that has the familiar value de6

883
00:32:42,000 --> 00:32:42,720
which is

884
00:32:42,720 --> 00:32:45,840
the address in user space of the e-call

885
00:32:45,840 --> 00:32:47,039
instruction

886
00:32:47,039 --> 00:32:48,480
so we got that one register at least

887
00:32:48,480 --> 00:32:50,399
saved away by e-call

888
00:32:50,399 --> 00:32:52,080
and the final thing that e-call does the

889
00:32:52,080 --> 00:32:53,840
third thing it does is jump

890
00:32:53,840 --> 00:32:56,799
to the instruction that s t vic points

891
00:32:56,799 --> 00:33:00,460
to

892
00:33:00,470 --> 00:33:02,320
[Music]

893
00:33:02,320 --> 00:33:06,000
all right um so what needs to happen now

894
00:33:06,000 --> 00:33:07,279
ecal has done a little bit of work for

895
00:33:07,279 --> 00:33:08,159
us but

896
00:33:08,159 --> 00:33:09,760
it turns out we're nowhere near ready to

897
00:33:09,760 --> 00:33:11,519
actually execute ordinary c code in the

898
00:33:11,519 --> 00:33:12,480
kernel

899
00:33:12,480 --> 00:33:14,720
what has to happen now is we need to

900
00:33:14,720 --> 00:33:17,919
save the 32 user register contents

901
00:33:17,919 --> 00:33:19,679
so we can later restore them and when we

902
00:33:19,679 --> 00:33:21,840
want to resume the user code

903
00:33:21,840 --> 00:33:23,679
now we need to switch to the kernel page

904
00:33:23,679 --> 00:33:25,200
table because currently we're using the

905
00:33:25,200 --> 00:33:26,720
user page table

906
00:33:26,720 --> 00:33:28,640
we need to create a stack or find a

907
00:33:28,640 --> 00:33:30,000
stack and set the stack point of

908
00:33:30,000 --> 00:33:31,440
register to point to the

909
00:33:31,440 --> 00:33:33,840
kernel stack so we can run c code which

910
00:33:33,840 --> 00:33:34,960
requires the stack

911
00:33:34,960 --> 00:33:36,320
and then we need to actually jump to

912
00:33:36,320 --> 00:33:38,559
some sensible place

913
00:33:38,559 --> 00:33:41,840
in the c code in the kernel now as an

914
00:33:41,840 --> 00:33:43,519
aside

915
00:33:43,519 --> 00:33:44,880
you know e-call didn't do any of these

916
00:33:44,880 --> 00:33:46,960
things for us um

917
00:33:46,960 --> 00:33:48,799
you know but you could have we the

918
00:33:48,799 --> 00:33:50,720
hardware could have defined e-call to do

919
00:33:50,720 --> 00:33:53,440
much more

920
00:33:53,440 --> 00:33:55,279
many more of these steps for us instead

921
00:33:55,279 --> 00:33:56,880
of leaving them to software and as

922
00:33:56,880 --> 00:33:59,360
we'll see the doing the software is not

923
00:33:59,360 --> 00:34:01,039
particularly straightforward

924
00:34:01,039 --> 00:34:02,720
um so you should ask yourself why the

925
00:34:02,720 --> 00:34:04,640
ecall doesn't do more of the work

926
00:34:04,640 --> 00:34:06,320
of getting from user space into the

927
00:34:06,320 --> 00:34:08,560
kernel and why doesn't it

928
00:34:08,560 --> 00:34:11,839
save their user registers or switch

929
00:34:11,839 --> 00:34:13,359
page table pointers to point to the

930
00:34:13,359 --> 00:34:15,119
kernel page table or

931
00:34:15,119 --> 00:34:17,040
automatically set the stack pointer to

932
00:34:17,040 --> 00:34:18,960
point to the kernel stack

933
00:34:18,960 --> 00:34:21,599
or jump right to kernel c code geez

934
00:34:21,599 --> 00:34:22,800
rather than having to go through all

935
00:34:22,800 --> 00:34:23,839
this

936
00:34:23,839 --> 00:34:26,879
complicated assembly code

937
00:34:26,879 --> 00:34:28,560
and there's actually been machines that

938
00:34:28,560 --> 00:34:30,960
have done all of these things

939
00:34:30,960 --> 00:34:35,679
in hardware during system calls

940
00:34:35,679 --> 00:34:36,960
the risk five doesn't do any of them

941
00:34:36,960 --> 00:34:38,399
numbers five really the attitude they've

942
00:34:38,399 --> 00:34:39,679
taken is that ecall

943
00:34:39,679 --> 00:34:41,760
does the absolute minimum that's

944
00:34:41,760 --> 00:34:43,839
required that it could possibly do and

945
00:34:43,839 --> 00:34:45,760
leave everything else up to software

946
00:34:45,760 --> 00:34:47,679
and the reason for this is because the

947
00:34:47,679 --> 00:34:49,919
risk 5 designers want to allow maximum

948
00:34:49,919 --> 00:34:51,119
flexibility

949
00:34:51,119 --> 00:34:53,200
to the software the operating system

950
00:34:53,200 --> 00:34:54,960
programmers to design the

951
00:34:54,960 --> 00:34:56,639
program operating system however they

952
00:34:56,639 --> 00:34:58,480
like

953
00:34:58,480 --> 00:35:01,280
and so you can imagine ways xv6 really

954
00:35:01,280 --> 00:35:02,960
doesn't use this freedom

955
00:35:02,960 --> 00:35:04,960
but other operating systems do so some

956
00:35:04,960 --> 00:35:06,560
examples of

957
00:35:06,560 --> 00:35:08,800
things that are kind of enabled for the

958
00:35:08,800 --> 00:35:10,320
software to do

959
00:35:10,320 --> 00:35:14,550
because e-call is so simple

960
00:35:14,560 --> 00:35:17,040
maybe some operating systems can execute

961
00:35:17,040 --> 00:35:18,079
some

962
00:35:18,079 --> 00:35:19,839
traps some system calls without

963
00:35:19,839 --> 00:35:21,359
switching page tables

964
00:35:21,359 --> 00:35:23,040
the switching page page table is

965
00:35:23,040 --> 00:35:25,920
expensive if vcall forces you to do it

966
00:35:25,920 --> 00:35:27,920
that rules out the possibility of very

967
00:35:27,920 --> 00:35:29,440
streamlined

968
00:35:29,440 --> 00:35:31,280
implementations for some system calls

969
00:35:31,280 --> 00:35:34,400
that don't switch page tables

970
00:35:34,400 --> 00:35:36,720
some operating systems map both user and

971
00:35:36,720 --> 00:35:38,000
kernel

972
00:35:38,000 --> 00:35:39,599
virtual addresses into a single page

973
00:35:39,599 --> 00:35:41,359
table and use the same page table for

974
00:35:41,359 --> 00:35:42,880
both user and kernel and therefore don't

975
00:35:42,880 --> 00:35:44,000
even have to switch page

976
00:35:44,000 --> 00:35:46,480
tables ever when transitioning between

977
00:35:46,480 --> 00:35:47,839
user and kernel

978
00:35:47,839 --> 00:35:49,359
and for them also if you call switch

979
00:35:49,359 --> 00:35:51,119
page tables that would just be a waste

980
00:35:51,119 --> 00:35:53,760
and slow things down maybe in some

981
00:35:53,760 --> 00:35:55,359
circumstances

982
00:35:55,359 --> 00:35:57,920
system calls for example some registers

983
00:35:57,920 --> 00:35:59,280
don't have to be saved

984
00:35:59,280 --> 00:36:00,640
and which ones have to be saved or not

985
00:36:00,640 --> 00:36:02,320
sort of depends on the software the

986
00:36:02,320 --> 00:36:04,160
language and the compiler but

987
00:36:04,160 --> 00:36:05,359
you might be able to save a lot of time

988
00:36:05,359 --> 00:36:07,839
by saving fewer than 32 registers so you

989
00:36:07,839 --> 00:36:09,920
don't want equal to kind of force you

990
00:36:09,920 --> 00:36:11,599
you don't necessarily want equal to

991
00:36:11,599 --> 00:36:14,640
force you to save all the registers

992
00:36:14,640 --> 00:36:16,320
and finally maybe no stack at all is

993
00:36:16,320 --> 00:36:18,960
required for some simple system calls so

994
00:36:18,960 --> 00:36:21,440
again for operating systems that care a

995
00:36:21,440 --> 00:36:22,960
lot about performance it's good that

996
00:36:22,960 --> 00:36:24,240
ecall doesn't force

997
00:36:24,240 --> 00:36:27,760
any particular stack policy on you

998
00:36:27,760 --> 00:36:31,040
and again there's many clever uh

999
00:36:31,040 --> 00:36:34,000
hardware software schemes for very

1000
00:36:34,000 --> 00:36:36,000
streamlined high performance

1001
00:36:36,000 --> 00:36:37,839
system calls and traps just because the

1002
00:36:37,839 --> 00:36:39,040
performance of this stuff is

1003
00:36:39,040 --> 00:36:40,880
like super important and people worry

1004
00:36:40,880 --> 00:36:43,119
about it a lot

1005
00:36:43,119 --> 00:36:46,560
okay so back to xv6 and risk five

1006
00:36:46,560 --> 00:36:49,680
um the first thing we need to do is save

1007
00:36:49,680 --> 00:36:50,800
some registers we

1008
00:36:50,800 --> 00:36:53,280
can do hardly anything on the risk 5

1009
00:36:53,280 --> 00:36:54,480
without a few

1010
00:36:54,480 --> 00:36:56,960
registers without being able to use

1011
00:36:56,960 --> 00:36:58,720
register so what are our options for

1012
00:36:58,720 --> 00:37:01,440
saving user registers

1013
00:37:01,440 --> 00:37:03,440
in on some other machine we might be

1014
00:37:03,440 --> 00:37:05,200
able to just write the contents of the

1015
00:37:05,200 --> 00:37:07,119
32 registers somewhere convenient in

1016
00:37:07,119 --> 00:37:09,119
physical memory

1017
00:37:09,119 --> 00:37:10,400
we can't actually really do that on the

1018
00:37:10,400 --> 00:37:12,160
risk 5 because

1019
00:37:12,160 --> 00:37:13,440
supervisor code isn't allowed to

1020
00:37:13,440 --> 00:37:15,200
directly access physical memory we can

1021
00:37:15,200 --> 00:37:16,720
only use what's in the page table

1022
00:37:16,720 --> 00:37:20,630
there's not much in the page table

1023
00:37:20,640 --> 00:37:23,760
another possibility that xv6 doesn't do

1024
00:37:23,760 --> 00:37:26,880
is simply setting the sat p to uh to the

1025
00:37:26,880 --> 00:37:28,320
kernel page table right and then we

1026
00:37:28,320 --> 00:37:28,880
could

1027
00:37:28,880 --> 00:37:30,640
use all the kernel mappings and use them

1028
00:37:30,640 --> 00:37:34,160
maybe to help us save the user registers

1029
00:37:34,160 --> 00:37:35,680
and that'd be legal the supervisor can

1030
00:37:35,680 --> 00:37:38,000
certainly change that b

1031
00:37:38,000 --> 00:37:40,079
however at this point in the trap

1032
00:37:40,079 --> 00:37:42,160
handler namely the beginning

1033
00:37:42,160 --> 00:37:43,599
we don't even know the address of the

1034
00:37:43,599 --> 00:37:46,079
kernel page table and furthermore the

1035
00:37:46,079 --> 00:37:47,760
instruction that you execute

1036
00:37:47,760 --> 00:37:50,880
to change sat p require that the address

1037
00:37:50,880 --> 00:37:52,800
that you're loading into sap come from a

1038
00:37:52,800 --> 00:37:53,599
register

1039
00:37:53,599 --> 00:37:56,000
so to even execute the instruction to

1040
00:37:56,000 --> 00:37:56,640
change

1041
00:37:56,640 --> 00:38:00,079
page tables we need some spare registers

1042
00:38:00,079 --> 00:38:02,320
in order to put the new page table

1043
00:38:02,320 --> 00:38:03,920
address in those registers so we can

1044
00:38:03,920 --> 00:38:05,200
execute

1045
00:38:05,200 --> 00:38:08,880
the sat p modifying instruction

1046
00:38:08,880 --> 00:38:11,119
all right so we really need to save the

1047
00:38:11,119 --> 00:38:13,359
user registers

1048
00:38:13,359 --> 00:38:17,119
there's two parts to the solution for

1049
00:38:17,119 --> 00:38:20,079
how xv6 does this on the on the risk 5

1050
00:38:20,079 --> 00:38:21,359
one is

1051
00:38:21,359 --> 00:38:25,200
part of the solution is that xv6

1052
00:38:25,200 --> 00:38:27,280
into every user address every user page

1053
00:38:27,280 --> 00:38:28,560
table maps this trap

1054
00:38:28,560 --> 00:38:32,400
frame page and every process has its own

1055
00:38:32,400 --> 00:38:34,160
trap frame page

1056
00:38:34,160 --> 00:38:37,440
um and the crafting free page

1057
00:38:37,440 --> 00:38:38,800
actually contains some interesting a

1058
00:38:38,800 --> 00:38:40,640
bunch of different kinds of data but

1059
00:38:40,640 --> 00:38:42,079
at this point the most important data it

1060
00:38:42,079 --> 00:38:44,880
contains is 32 slots

1061
00:38:44,880 --> 00:38:47,839
empty slots in memory in which to save

1062
00:38:47,839 --> 00:38:49,359
the 32 registers

1063
00:38:49,359 --> 00:38:52,000
so the good news right now in the trap

1064
00:38:52,000 --> 00:38:54,000
handling code is we have a mapping we're

1065
00:38:54,000 --> 00:38:55,599
guaranteed to have a mapping

1066
00:38:55,599 --> 00:38:57,520
set up by the kernel previously in the

1067
00:38:57,520 --> 00:38:59,280
user page table

1068
00:38:59,280 --> 00:39:01,760
that points to a place where that's

1069
00:39:01,760 --> 00:39:04,240
prepared for us to save this processes

1070
00:39:04,240 --> 00:39:07,750
user registers

1071
00:39:07,760 --> 00:39:09,599
and it's here it's three it's always

1072
00:39:09,599 --> 00:39:11,440
three f f

1073
00:39:11,440 --> 00:39:15,119
e zero zero zero virtual address

1074
00:39:15,119 --> 00:39:16,880
and if you want to see what's there

1075
00:39:16,880 --> 00:39:20,550
actually in that trap frame it's

1076
00:39:20,560 --> 00:39:28,960
what xv6 puts there is defined in

1077
00:39:28,960 --> 00:39:31,200
proc.h and struck frat frame which is

1078
00:39:31,200 --> 00:39:33,200
right here so you can see

1079
00:39:33,200 --> 00:39:36,240
um what's supposed to go in each slot

1080
00:39:36,240 --> 00:39:39,599
and there's a 32 slots you know named ra

1081
00:39:39,599 --> 00:39:42,480
sb gp whatever which are places to save

1082
00:39:42,480 --> 00:39:44,000
registers there's also these five things

1083
00:39:44,000 --> 00:39:45,599
at the beginning

1084
00:39:45,599 --> 00:39:47,359
which we'll see will come in handy very

1085
00:39:47,359 --> 00:39:49,200
soon which are values

1086
00:39:49,200 --> 00:39:50,880
that the colonel previously placed in

1087
00:39:50,880 --> 00:39:54,000
these slots in the trap frame

1088
00:39:54,000 --> 00:39:55,839
like for example this very first slot in

1089
00:39:55,839 --> 00:39:57,760
the trap frame contains a pointer to the

1090
00:39:57,760 --> 00:39:58,880
kernel page table

1091
00:39:58,880 --> 00:40:00,240
and this will be the value that we're

1092
00:40:00,240 --> 00:40:02,480
about we're very soon gonna

1093
00:40:02,480 --> 00:40:04,079
uh the trap handling code is gonna load

1094
00:40:04,079 --> 00:40:06,240
into sat p

1095
00:40:06,240 --> 00:40:08,960
okay so half the answer to how to say

1096
00:40:08,960 --> 00:40:10,800
the registers is that

1097
00:40:10,800 --> 00:40:12,960
the kernel has conveniently mapped this

1098
00:40:12,960 --> 00:40:14,319
trap frame

1099
00:40:14,319 --> 00:40:16,079
into every user page table the other is

1100
00:40:16,079 --> 00:40:18,240
this uh instruction this scratch

1101
00:40:18,240 --> 00:40:19,839
register which we

1102
00:40:19,839 --> 00:40:22,240
uh mentioned before um so there's the

1103
00:40:22,240 --> 00:40:24,160
special scratch register

1104
00:40:24,160 --> 00:40:26,640
provided by risk 5 for exactly the

1105
00:40:26,640 --> 00:40:30,150
purpose we're about to use it for

1106
00:40:30,160 --> 00:40:31,760
the kernel when it before goes into user

1107
00:40:31,760 --> 00:40:33,520
space puts a pointer there to the trap

1108
00:40:33,520 --> 00:40:35,280
frame basically just point

1109
00:40:35,280 --> 00:40:38,319
puts into sat p this

1110
00:40:38,319 --> 00:40:40,800
this address um just for the convenience

1111
00:40:40,800 --> 00:40:42,240
of the trap handling code

1112
00:40:42,240 --> 00:40:43,440
more importantly though there's an

1113
00:40:43,440 --> 00:40:45,119
instruction on the risk 5 that it's

1114
00:40:45,119 --> 00:40:46,319
going to allow us to swap

1115
00:40:46,319 --> 00:40:48,560
any register and that's scratch which

1116
00:40:48,560 --> 00:40:51,440
will save that register as well as

1117
00:40:51,440 --> 00:40:54,560
load the value of s scratch into

1118
00:40:54,560 --> 00:40:56,640
whatever register we specified

1119
00:40:56,640 --> 00:40:59,520
as you can see if i look at the

1120
00:40:59,520 --> 00:41:02,950
trampoline code

1121
00:41:02,960 --> 00:41:04,000
we're right at the beginning of the

1122
00:41:04,000 --> 00:41:06,000
trampoline code here

1123
00:41:06,000 --> 00:41:07,599
the very first thing it does is this

1124
00:41:07,599 --> 00:41:11,030
csrw

1125
00:41:11,040 --> 00:41:12,880
instruction this is the source in this

1126
00:41:12,880 --> 00:41:14,960
window over in this window we can

1127
00:41:14,960 --> 00:41:17,280
actually see what gdb sees in the kernel

1128
00:41:17,280 --> 00:41:20,240
and we've actually just executed this

1129
00:41:20,240 --> 00:41:22,160
swap instruction

1130
00:41:22,160 --> 00:41:24,560
and i swapped a0 with scratch in order

1131
00:41:24,560 --> 00:41:27,119
to see what it did let's print out

1132
00:41:27,119 --> 00:41:30,240
a0 a0 is now this

1133
00:41:30,240 --> 00:41:34,560
three fffe00 value which is a pointer

1134
00:41:34,560 --> 00:41:36,240
which is the virtual address of the trap

1135
00:41:36,240 --> 00:41:38,160
frame which used to be in s scratch but

1136
00:41:38,160 --> 00:41:39,520
we just swapped it

1137
00:41:39,520 --> 00:41:41,200
and then we can print out what's in s

1138
00:41:41,200 --> 00:41:43,670
scratch

1139
00:41:43,680 --> 00:41:45,599
and it's 2 which is the old value of the

1140
00:41:45,599 --> 00:41:48,480
a0 register of course a0 held the first

1141
00:41:48,480 --> 00:41:51,200
argument to the right function which is

1142
00:41:51,200 --> 00:41:52,720
file descriptor 2 which

1143
00:41:52,720 --> 00:41:54,640
you know is what the shell pass so we

1144
00:41:54,640 --> 00:41:56,880
saved away a0

1145
00:41:56,880 --> 00:42:00,240
and we have a pointer to the trap frame

1146
00:42:00,240 --> 00:42:02,160
and it turns out now that we're well on

1147
00:42:02,160 --> 00:42:04,000
our way to be able to save the registers

1148
00:42:04,000 --> 00:42:07,680
in fact that's what the very next um

1149
00:42:07,680 --> 00:42:10,160
30 odd instructions do in this

1150
00:42:10,160 --> 00:42:11,359
trampoline code

1151
00:42:11,359 --> 00:42:14,319
it just systematically executes these sd

1152
00:42:14,319 --> 00:42:16,400
instructions you just save

1153
00:42:16,400 --> 00:42:19,119
64-bit store instructions to store every

1154
00:42:19,119 --> 00:42:20,560
single register

1155
00:42:20,560 --> 00:42:24,000
to a different offset in the trap frame

1156
00:42:24,000 --> 00:42:24,960
a0

1157
00:42:24,960 --> 00:42:26,800
if you recall now contains after the

1158
00:42:26,800 --> 00:42:28,480
swap contains a pointer to the

1159
00:42:28,480 --> 00:42:32,079
trap frame that is contains the

1160
00:42:32,079 --> 00:42:34,720
virtual address of this page and we're

1161
00:42:34,720 --> 00:42:36,079
just storing

1162
00:42:36,079 --> 00:42:37,680
each register at a different offset in

1163
00:42:37,680 --> 00:42:41,990
the track frame

1164
00:42:42,000 --> 00:42:43,359
all these stores are a bit boring so i

1165
00:42:43,359 --> 00:42:45,440
think i'm going to skip over them

1166
00:42:45,440 --> 00:42:45,880
um

1167
00:42:45,880 --> 00:42:48,480
[Music]

1168
00:42:48,480 --> 00:42:49,680
and let me set a breakpoint a little

1169
00:42:49,680 --> 00:42:55,430
farther on

1170
00:42:55,440 --> 00:43:00,000
professor question yes how did the

1171
00:43:00,000 --> 00:43:03,359
address of the trap frame end up in s

1172
00:43:03,359 --> 00:43:05,920
scratch when we swapped it with a0

1173
00:43:05,920 --> 00:43:09,440
okay before the kernel

1174
00:43:09,440 --> 00:43:11,920
before it previously transitioned to

1175
00:43:11,920 --> 00:43:14,400
user space

1176
00:43:14,400 --> 00:43:17,839
set s scratch to be equal to

1177
00:43:17,839 --> 00:43:20,800
three f f e zero zero zero the virtual

1178
00:43:20,800 --> 00:43:22,720
address of the trap frame

1179
00:43:22,720 --> 00:43:24,160
so all the time when we were executing

1180
00:43:24,160 --> 00:43:26,000
in user space in the shell s scratch had

1181
00:43:26,000 --> 00:43:29,119
this pointer to the trap frame

1182
00:43:29,119 --> 00:43:34,390
and then the shell executes uh

1183
00:43:34,400 --> 00:43:37,440
ecall which jumps to the beginning of

1184
00:43:37,440 --> 00:43:39,040
the trampoline and the very first

1185
00:43:39,040 --> 00:43:40,079
instruction in the trampoline

1186
00:43:40,079 --> 00:43:42,960
is this csr rw instruction which swaps

1187
00:43:42,960 --> 00:43:44,800
a0 into scratch

1188
00:43:44,800 --> 00:43:46,240
and so now the old value of the scratch

1189
00:43:46,240 --> 00:43:47,680
namely the point of the trap frame is

1190
00:43:47,680 --> 00:43:50,000
now in a0

1191
00:43:50,000 --> 00:43:53,109
does that answer your question

1192
00:43:53,119 --> 00:43:55,599
as i guess i'm wondering where in the i

1193
00:43:55,599 --> 00:43:57,839
look does this happen

1194
00:43:57,839 --> 00:43:59,920
during the allocation of the process

1195
00:43:59,920 --> 00:44:01,440
like where does the scratch register

1196
00:44:01,440 --> 00:44:02,000
live

1197
00:44:02,000 --> 00:44:03,440
where does this as well the scratch

1198
00:44:03,440 --> 00:44:05,119
order itself lives

1199
00:44:05,119 --> 00:44:07,599
on the cpu it's a special register in

1200
00:44:07,599 --> 00:44:08,960
the cpu

1201
00:44:08,960 --> 00:44:12,240
where and the colonel sets it um

1202
00:44:12,240 --> 00:44:15,359
well uh

1203
00:44:15,359 --> 00:44:17,440
it's a little bit involved the actual

1204
00:44:17,440 --> 00:44:18,960
place where it's set or what i'm now

1205
00:44:18,960 --> 00:44:20,839
showing you on the right here

1206
00:44:20,839 --> 00:44:24,079
is um the code that the kernel x

1207
00:44:24,079 --> 00:44:26,560
the last two instructions that the

1208
00:44:26,560 --> 00:44:27,920
kernel executes

1209
00:44:27,920 --> 00:44:30,960
while returning a user space and what's

1210
00:44:30,960 --> 00:44:32,000
happening is that

1211
00:44:32,000 --> 00:44:33,599
the very last thing it does after the

1212
00:44:33,599 --> 00:44:35,599
kernel restores

1213
00:44:35,599 --> 00:44:37,760
all the user registers and is you know

1214
00:44:37,760 --> 00:44:39,680
just about ready to return to user space

1215
00:44:39,680 --> 00:44:40,960
it actually does another one of these

1216
00:44:40,960 --> 00:44:43,599
swaps the kernel has set up a0 to be

1217
00:44:43,599 --> 00:44:45,440
equal to the trap frame

1218
00:44:45,440 --> 00:44:48,839
and s scratch still holds the saved user

1219
00:44:48,839 --> 00:44:51,839
a0 so the kernel does this swap which

1220
00:44:51,839 --> 00:44:53,520
ends up with scratch having a pointer to

1221
00:44:53,520 --> 00:44:57,920
the trap frame and a0 having the saved

1222
00:44:57,920 --> 00:45:00,960
user a0 and then this s rep returns

1223
00:45:00,960 --> 00:45:03,440
to user space so you may wonder how a0

1224
00:45:03,440 --> 00:45:06,480
ever got to have the value of the uh

1225
00:45:06,480 --> 00:45:08,800
the address of the trap frame answer

1226
00:45:08,800 --> 00:45:09,520
that question

1227
00:45:09,520 --> 00:45:13,190
is that um

1228
00:45:13,200 --> 00:45:17,119
we're now looking in trap.c

1229
00:45:17,119 --> 00:45:20,319
at this last c function to run

1230
00:45:20,319 --> 00:45:24,640
on the way out to user space

1231
00:45:24,640 --> 00:45:26,319
and the last thing the c function does

1232
00:45:26,319 --> 00:45:29,440
is calls this function here

1233
00:45:29,440 --> 00:45:32,319
whatever this fn is and the arguments it

1234
00:45:32,319 --> 00:45:33,599
passes

1235
00:45:33,599 --> 00:45:37,200
are the trap frame and the user

1236
00:45:37,200 --> 00:45:40,800
page table and so in c code when you

1237
00:45:40,800 --> 00:45:42,560
call a function the first argument goes

1238
00:45:42,560 --> 00:45:42,960
into

1239
00:45:42,960 --> 00:45:46,640
a zero that's basically y why a0

1240
00:45:46,640 --> 00:45:49,119
held a pointer to the trap frame and

1241
00:45:49,119 --> 00:45:51,280
this function its value is set up here

1242
00:45:51,280 --> 00:45:52,560
to be

1243
00:45:52,560 --> 00:45:55,280
in that trampoline page towards the end

1244
00:45:55,280 --> 00:45:59,750
that code i showed you

1245
00:45:59,760 --> 00:46:03,920
this code is that uh

1246
00:46:03,920 --> 00:46:07,680
is that a good answer yes thanks

1247
00:46:07,680 --> 00:46:10,560
i'm sorry i also was confused about that

1248
00:46:10,560 --> 00:46:10,960
i was

1249
00:46:10,960 --> 00:46:13,200
not sure so when you start when you

1250
00:46:13,200 --> 00:46:15,280
start your process

1251
00:46:15,280 --> 00:46:17,280
and it's it's good and running and then

1252
00:46:17,280 --> 00:46:18,560
at some point it doesn't

1253
00:46:18,560 --> 00:46:21,599
equal i guess in some or something and

1254
00:46:21,599 --> 00:46:23,520
then

1255
00:46:23,520 --> 00:46:26,319
when did you call this return function

1256
00:46:26,319 --> 00:46:26,720
because

1257
00:46:26,720 --> 00:46:28,640
it should have been called before the

1258
00:46:28,640 --> 00:46:29,920
call

1259
00:46:29,920 --> 00:46:33,119
but it didn't return from you didn't

1260
00:46:33,119 --> 00:46:34,400
return before

1261
00:46:34,400 --> 00:46:35,680
i i don't know i don't understand what

1262
00:46:35,680 --> 00:46:38,960
you call the either trafford

1263
00:46:38,960 --> 00:46:40,880
okay well maybe one answer to this

1264
00:46:40,880 --> 00:46:42,079
question is that

1265
00:46:42,079 --> 00:46:46,720
the kernel always or the the machine

1266
00:46:46,720 --> 00:46:49,760
boots up in the kernel

1267
00:46:49,760 --> 00:46:51,119
so so when the machine starts it's in

1268
00:46:51,119 --> 00:46:53,599
the kernel anytime

1269
00:46:53,599 --> 00:46:56,800
the only way to get into user space

1270
00:46:56,800 --> 00:46:58,640
you know the very first time or when

1271
00:46:58,640 --> 00:47:01,200
returning from a system call

1272
00:47:01,200 --> 00:47:03,599
is in fact to execute this s-red

1273
00:47:03,599 --> 00:47:04,960
instruction

1274
00:47:04,960 --> 00:47:07,520
that that this escrow instruction is the

1275
00:47:07,520 --> 00:47:08,960
way that the risk find

1276
00:47:08,960 --> 00:47:11,119
five defines to transition from

1277
00:47:11,119 --> 00:47:12,560
supervisor mode

1278
00:47:12,560 --> 00:47:16,240
into user mode and so

1279
00:47:16,240 --> 00:47:19,119
before any user code ever executes the

1280
00:47:19,119 --> 00:47:20,240
kernel

1281
00:47:20,240 --> 00:47:21,920
executes the code i'm showing you here

1282
00:47:21,920 --> 00:47:25,119
in these these two editor buffers

1283
00:47:25,119 --> 00:47:27,760
that set up all kinds of things like

1284
00:47:27,760 --> 00:47:28,720
scratch and

1285
00:47:28,720 --> 00:47:33,190
st back

1286
00:47:33,200 --> 00:47:36,640
okay i see thank you you're welcome

1287
00:47:36,640 --> 00:47:38,640
oh i have a question i'm not sure if we

1288
00:47:38,640 --> 00:47:40,400
touched on this or if i'm like you know

1289
00:47:40,400 --> 00:47:41,520
i missed it but

1290
00:47:41,520 --> 00:47:43,599
uh when we called the e-call instruction

1291
00:47:43,599 --> 00:47:45,119
in the assembly code

1292
00:47:45,119 --> 00:47:47,200
uh what triggers the trampoline code to

1293
00:47:47,200 --> 00:47:48,240
start like

1294
00:47:48,240 --> 00:47:51,520
is it the switch of the um cpu mode from

1295
00:47:51,520 --> 00:47:52,559
supervisor

1296
00:47:52,559 --> 00:47:54,400
i'm sorry from user supervisor is it

1297
00:47:54,400 --> 00:47:55,599
something else

1298
00:47:55,599 --> 00:47:59,440
okay um so the code we're executing is

1299
00:47:59,440 --> 00:48:00,960
this e-call

1300
00:48:00,960 --> 00:48:03,440
the shell executes it in user space and

1301
00:48:03,440 --> 00:48:05,040
e-call does a couple things

1302
00:48:05,040 --> 00:48:07,920
the e-call instruction sets the mode to

1303
00:48:07,920 --> 00:48:09,440
supervisor

1304
00:48:09,440 --> 00:48:13,599
and the e-call instruction

1305
00:48:13,599 --> 00:48:16,880
saves the program counter and epc and

1306
00:48:16,880 --> 00:48:19,040
the e-call instruction sets the program

1307
00:48:19,040 --> 00:48:21,680
counter equal to

1308
00:48:21,680 --> 00:48:24,800
the control register called st vac so

1309
00:48:24,800 --> 00:48:26,079
and that seebeck is one of the many

1310
00:48:26,079 --> 00:48:27,760
things which the kernel sets up before

1311
00:48:27,760 --> 00:48:31,589
entering user space

1312
00:48:31,599 --> 00:48:34,160
and so here's sdvac scpec is just the

1313
00:48:34,160 --> 00:48:35,359
kernel set it

1314
00:48:35,359 --> 00:48:37,520
to the beginning of the trampoline page

1315
00:48:37,520 --> 00:48:38,720
that is

1316
00:48:38,720 --> 00:48:41,920
this address here so that when e-call

1317
00:48:41,920 --> 00:48:43,520
happens e-call just

1318
00:48:43,520 --> 00:48:45,440
copies s-t-vec into the program counter

1319
00:48:45,440 --> 00:48:47,359
and continues but now

1320
00:48:47,359 --> 00:48:49,520
and the program counter is executing

1321
00:48:49,520 --> 00:48:54,549
this address in the trampoline page

1322
00:48:54,559 --> 00:49:00,390
that clarifies it thank you okay

1323
00:49:00,400 --> 00:49:04,000
i also have a question um

1324
00:49:04,000 --> 00:49:07,040
why so some of the registers that are

1325
00:49:07,040 --> 00:49:08,160
saved

1326
00:49:08,160 --> 00:49:11,920
in the trap frame should not um

1327
00:49:11,920 --> 00:49:15,040
are also registers that um

1328
00:49:15,040 --> 00:49:18,079
the user program had access to

1329
00:49:18,079 --> 00:49:21,119
why why why did we

1330
00:49:21,119 --> 00:49:24,559
need to um

1331
00:49:24,559 --> 00:49:28,000
use a new

1332
00:49:28,000 --> 00:49:30,880
region in memory and not use the program

1333
00:49:30,880 --> 00:49:34,630
stack

1334
00:49:34,640 --> 00:49:37,440
okay um well there's maybe two questions

1335
00:49:37,440 --> 00:49:39,040
here one is

1336
00:49:39,040 --> 00:49:41,200
maybe why do we have to save the

1337
00:49:41,200 --> 00:49:43,760
registers at all

1338
00:49:43,760 --> 00:49:45,119
the the reason why the kernel has to

1339
00:49:45,119 --> 00:49:47,119
save the registers is that the kernel

1340
00:49:47,119 --> 00:49:50,480
is about to run c code that overwrites

1341
00:49:50,480 --> 00:49:52,079
those registers

1342
00:49:52,079 --> 00:49:54,559
um and if we ever want to resume the

1343
00:49:54,559 --> 00:49:56,240
user code correctly we need to resume it

1344
00:49:56,240 --> 00:49:57,440
with its registers

1345
00:49:57,440 --> 00:49:59,680
having their original values that you

1346
00:49:59,680 --> 00:50:00,960
know as of when the e call

1347
00:50:00,960 --> 00:50:03,119
was executed so we have to save all the

1348
00:50:03,119 --> 00:50:04,800
registers

1349
00:50:04,800 --> 00:50:08,000
in the trap frame so that later on we

1350
00:50:08,000 --> 00:50:08,720
can restore

1351
00:50:08,720 --> 00:50:12,079
all of their values just before resuming

1352
00:50:12,079 --> 00:50:14,319
the user code

1353
00:50:14,319 --> 00:50:15,520
maybe the other half of your question is

1354
00:50:15,520 --> 00:50:17,680
how come they're saved in the crap frame

1355
00:50:17,680 --> 00:50:19,520
and not on the user stack

1356
00:50:19,520 --> 00:50:22,079
um the answer to that is that we're not

1357
00:50:22,079 --> 00:50:24,800
sure the user program even has a stack

1358
00:50:24,800 --> 00:50:25,839
there are certainly programming

1359
00:50:25,839 --> 00:50:28,800
languages that don't have a stack

1360
00:50:28,800 --> 00:50:30,480
and the stack pointer doesn't point to

1361
00:50:30,480 --> 00:50:32,319
anything in particular or might be have

1362
00:50:32,319 --> 00:50:33,359
value zero

1363
00:50:33,359 --> 00:50:34,800
there's also programming languages that

1364
00:50:34,800 --> 00:50:36,880
yeah they have a stack but it's in like

1365
00:50:36,880 --> 00:50:38,480
a format that's

1366
00:50:38,480 --> 00:50:40,000
you know some weird format that the

1367
00:50:40,000 --> 00:50:41,839
kernel doesn't understand

1368
00:50:41,839 --> 00:50:43,359
uh maybe because the programming

1369
00:50:43,359 --> 00:50:45,440
language allocates its stack in small

1370
00:50:45,440 --> 00:50:46,720
blocks

1371
00:50:46,720 --> 00:50:49,359
uh from the heap and the programming

1372
00:50:49,359 --> 00:50:51,359
language runtime understands how to

1373
00:50:51,359 --> 00:50:52,720
you know use these small blocks of

1374
00:50:52,720 --> 00:50:54,400
memory as a stack but

1375
00:50:54,400 --> 00:50:57,680
you know the kernel has no idea

1376
00:50:57,680 --> 00:51:00,000
so we if we want to be able to run sort

1377
00:51:00,000 --> 00:51:01,440
of arbitrary user programs written in

1378
00:51:01,440 --> 00:51:02,640
lots of different languages

1379
00:51:02,640 --> 00:51:04,319
the kernel can't make any assumptions

1380
00:51:04,319 --> 00:51:05,839
about

1381
00:51:05,839 --> 00:51:08,880
what parts of user memory it's allowed

1382
00:51:08,880 --> 00:51:11,200
exists or valid or it's allowed to read

1383
00:51:11,200 --> 00:51:12,319
or write

1384
00:51:12,319 --> 00:51:13,599
and so the kernel has to be sort of

1385
00:51:13,599 --> 00:51:15,520
self-contained in saving and destroying

1386
00:51:15,520 --> 00:51:17,520
the registers

1387
00:51:17,520 --> 00:51:19,760
that's why the kernel saves this stuff

1388
00:51:19,760 --> 00:51:20,559
in its own

1389
00:51:20,559 --> 00:51:22,960
memory in the trap frame rather than in

1390
00:51:22,960 --> 00:51:24,559
user memory

1391
00:51:24,559 --> 00:51:29,829
okay

1392
00:51:29,839 --> 00:51:40,069
okay anything else

1393
00:51:40,079 --> 00:51:42,079
okay we're still right at the beginning

1394
00:51:42,079 --> 00:51:44,400
of um

1395
00:51:44,400 --> 00:51:48,079
the code in trampoline

1396
00:51:48,079 --> 00:51:51,280
um this code is unfortunately we refer

1397
00:51:51,280 --> 00:51:52,319
to it both

1398
00:51:52,319 --> 00:51:56,480
as uservac um and as the trampoline code

1399
00:51:56,480 --> 00:51:58,480
we barely started executing it i think i

1400
00:51:58,480 --> 00:52:00,480
just set a breakpoint

1401
00:52:00,480 --> 00:52:04,079
um in this code um

1402
00:52:04,079 --> 00:52:06,079
after all the registers have been saved

1403
00:52:06,079 --> 00:52:09,990
i think i set a

1404
00:52:10,000 --> 00:52:12,160
uh breakpoint of this instruction um so

1405
00:52:12,160 --> 00:52:13,599
we'll continue executing

1406
00:52:13,599 --> 00:52:15,200
skip over all these saves of all the

1407
00:52:15,200 --> 00:52:17,680
user registers the crap frame

1408
00:52:17,680 --> 00:52:20,240
okay and now we're executing this load

1409
00:52:20,240 --> 00:52:22,400
instruction this load instruction

1410
00:52:22,400 --> 00:52:24,640
is loading into the stack pointer

1411
00:52:24,640 --> 00:52:25,440
register

1412
00:52:25,440 --> 00:52:27,280
and what it's loading is the value is

1413
00:52:27,280 --> 00:52:29,359
the eighth slot

1414
00:52:29,359 --> 00:52:32,400
in the block of memory pointed to by a0

1415
00:52:32,400 --> 00:52:34,800
we remember a0 points this the trap

1416
00:52:34,800 --> 00:52:35,760
frame

1417
00:52:35,760 --> 00:52:38,480
to this uh virtual address you know the

1418
00:52:38,480 --> 00:52:40,880
second to last page

1419
00:52:40,880 --> 00:52:44,800
and the format of the trap page of the

1420
00:52:44,800 --> 00:52:47,760
trap frame here's the form of the trap

1421
00:52:47,760 --> 00:52:48,240
name

1422
00:52:48,240 --> 00:52:51,119
we've conveniently labeled each field

1423
00:52:51,119 --> 00:52:51,760
with its

1424
00:52:51,760 --> 00:52:54,240
offset in bytes so that means that load

1425
00:52:54,240 --> 00:52:54,880
in the

1426
00:52:54,880 --> 00:52:57,359
eighth starting at the eighth byte of

1427
00:52:57,359 --> 00:52:59,359
the trap frame means we're loading

1428
00:52:59,359 --> 00:53:01,440
the kernel stack pointer and the one of

1429
00:53:01,440 --> 00:53:02,960
the things the kernel sets up

1430
00:53:02,960 --> 00:53:05,040
before entering user space is it sets

1431
00:53:05,040 --> 00:53:07,040
this slot in the trap frame

1432
00:53:07,040 --> 00:53:10,079
to be equal to this processes

1433
00:53:10,079 --> 00:53:12,559
uh kernel stack so what this instruction

1434
00:53:12,559 --> 00:53:14,559
here is doing is

1435
00:53:14,559 --> 00:53:17,040
initializing the stack pointer to point

1436
00:53:17,040 --> 00:53:17,839
to the top

1437
00:53:17,839 --> 00:53:20,400
of this processes kernel stack which is

1438
00:53:20,400 --> 00:53:22,720
part of what you need to do in order to

1439
00:53:22,720 --> 00:53:25,910
to run user code

1440
00:53:25,920 --> 00:53:27,760
all right so what's left or within a few

1441
00:53:27,760 --> 00:53:29,119
instructions of getting to the end of

1442
00:53:29,119 --> 00:53:30,720
this trampoline code

1443
00:53:30,720 --> 00:53:34,480
um we loaded the stack pointer

1444
00:53:34,480 --> 00:53:36,079
so maybe i can print the stack pointer

1445
00:53:36,079 --> 00:53:39,109
for you let's see

1446
00:53:39,119 --> 00:53:46,790
yeah this is um

1447
00:53:46,800 --> 00:53:50,400
uh all right well this is the kernels

1448
00:53:50,400 --> 00:53:52,079
this process is kernel stack it's up in

1449
00:53:52,079 --> 00:53:55,280
high memory because xv6

1450
00:53:55,280 --> 00:53:59,119
um treats kernel sex especially so that

1451
00:53:59,119 --> 00:54:01,119
you can put a guard page

1452
00:54:01,119 --> 00:54:04,720
under each kernel stack okay so this

1453
00:54:04,720 --> 00:54:06,880
load into tp

1454
00:54:06,880 --> 00:54:09,760
it turns out that because there's no

1455
00:54:09,760 --> 00:54:11,680
direct way in risk five to figure out

1456
00:54:11,680 --> 00:54:12,800
what core

1457
00:54:12,800 --> 00:54:14,640
which of the multiple cores you're

1458
00:54:14,640 --> 00:54:16,000
running on

1459
00:54:16,000 --> 00:54:19,839
xv6 actually keeps the core number

1460
00:54:19,839 --> 00:54:22,880
called the heart id in the tp register

1461
00:54:22,880 --> 00:54:24,480
and this is used in a bunch of places in

1462
00:54:24,480 --> 00:54:26,720
the kernel for example

1463
00:54:26,720 --> 00:54:29,599
it's part of the machinery for kernel

1464
00:54:29,599 --> 00:54:31,359
code to figure out what process

1465
00:54:31,359 --> 00:54:36,710
is currently running on that core

1466
00:54:36,720 --> 00:54:41,040
okay and if we execute this hopefully uh

1467
00:54:41,040 --> 00:54:43,040
tp we're running on core zero and that

1468
00:54:43,040 --> 00:54:44,640
makes sense because i've configured

1469
00:54:44,640 --> 00:54:48,480
qmu to only give one core to xv6 so we

1470
00:54:48,480 --> 00:54:53,119
are indeed running on core zero

1471
00:54:53,119 --> 00:54:56,160
this next thing uh is loading the

1472
00:54:56,160 --> 00:54:57,200
address

1473
00:54:57,200 --> 00:55:00,720
of um well actually the

1474
00:55:00,720 --> 00:55:04,870
the load into t0

1475
00:55:04,880 --> 00:55:08,480
um i think loaded a

1476
00:55:08,480 --> 00:55:11,920
pointer to the first c

1477
00:55:11,920 --> 00:55:13,200
function that we're going to execute

1478
00:55:13,200 --> 00:55:14,960
which is user trap so we use that in a

1479
00:55:14,960 --> 00:55:16,079
few instructions to just

1480
00:55:16,079 --> 00:55:20,799
jump um to the user trap c function

1481
00:55:20,799 --> 00:55:24,319
this load into t1 here is loading the

1482
00:55:24,319 --> 00:55:27,119
address of the

1483
00:55:27,119 --> 00:55:30,240
kernel page table so we can print

1484
00:55:30,240 --> 00:55:32,720
so we're about to switch page tables

1485
00:55:32,720 --> 00:55:34,720
turns out the uh

1486
00:55:34,720 --> 00:55:36,000
this thing in t1 is not actually

1487
00:55:36,000 --> 00:55:37,680
literally the address of the kernel page

1488
00:55:37,680 --> 00:55:39,119
table it's the thing you need to put

1489
00:55:39,119 --> 00:55:40,960
into sat p

1490
00:55:40,960 --> 00:55:44,079
um which is a has the address of the

1491
00:55:44,079 --> 00:55:45,680
kernel page table but shifted around

1492
00:55:45,680 --> 00:55:48,240
with some extra flag bit set but as soon

1493
00:55:48,240 --> 00:55:49,839
as the csrw

1494
00:55:49,839 --> 00:55:51,680
instruction executes we'll switch page

1495
00:55:51,680 --> 00:55:53,359
tables from the user page table to the

1496
00:55:53,359 --> 00:55:54,319
kernel page table

1497
00:55:54,319 --> 00:55:55,599
and let me just reinforce that by

1498
00:55:55,599 --> 00:55:57,520
looking at the current page table

1499
00:55:57,520 --> 00:55:59,839
right now we're still executing with

1500
00:55:59,839 --> 00:56:00,880
this very small

1501
00:56:00,880 --> 00:56:03,359
user page table and run step by to

1502
00:56:03,359 --> 00:56:04,400
execute

1503
00:56:04,400 --> 00:56:10,950
the load into sat p

1504
00:56:10,960 --> 00:56:12,319
and we'll look again at the kernel page

1505
00:56:12,319 --> 00:56:13,760
and now we're in a completely different

1506
00:56:13,760 --> 00:56:15,359
page table right this is the kernel page

1507
00:56:15,359 --> 00:56:16,319
table

1508
00:56:16,319 --> 00:56:17,520
and you can see all these different

1509
00:56:17,520 --> 00:56:19,680
regions of memory and device control

1510
00:56:19,680 --> 00:56:22,960
registers and whatnot that the uh

1511
00:56:22,960 --> 00:56:26,079
kernel sets up in its own uh big kernel

1512
00:56:26,079 --> 00:56:26,799
page date

1513
00:56:26,799 --> 00:56:28,839
so we've successfully switched page

1514
00:56:28,839 --> 00:56:30,960
tables and now the kernel page tables

1515
00:56:30,960 --> 00:56:31,359
and

1516
00:56:31,359 --> 00:56:32,559
so we're like in pretty good shape at

1517
00:56:32,559 --> 00:56:34,400
this point because we have a stack

1518
00:56:34,400 --> 00:56:36,480
um we have the kernel page table we can

1519
00:56:36,480 --> 00:56:38,640
read my kernel data we're really

1520
00:56:38,640 --> 00:56:42,079
pretty much ready to execute c code in

1521
00:56:42,079 --> 00:56:43,280
the kernel

1522
00:56:43,280 --> 00:56:46,640
one puzzle though is how come

1523
00:56:46,640 --> 00:56:49,119
we didn't just crash after all we were

1524
00:56:49,119 --> 00:56:50,960
executing somewhere in memory

1525
00:56:50,960 --> 00:56:52,400
and the program counter holds a virtual

1526
00:56:52,400 --> 00:56:54,079
address if we

1527
00:56:54,079 --> 00:56:57,119
switch page tables why doesn't that

1528
00:56:57,119 --> 00:56:59,440
um just cause some random garbage or

1529
00:56:59,440 --> 00:57:00,720
nothing at all

1530
00:57:00,720 --> 00:57:03,040
uh to be mapped in the new page table

1531
00:57:03,040 --> 00:57:05,359
under foot where we were executing

1532
00:57:05,359 --> 00:57:06,559
and we're not crashing here actually

1533
00:57:06,559 --> 00:57:08,720
executing these instructions

1534
00:57:08,720 --> 00:57:13,280
um any guesses what's going on

1535
00:57:13,280 --> 00:57:16,960
i think it's because oh sorry

1536
00:57:16,960 --> 00:57:19,680
um because we're still in the trampoline

1537
00:57:19,680 --> 00:57:20,960
code and the trampoline

1538
00:57:20,960 --> 00:57:23,440
is mapped at the same virtual address

1539
00:57:23,440 --> 00:57:24,000
both in

1540
00:57:24,000 --> 00:57:26,880
user and kernel that's absolutely

1541
00:57:26,880 --> 00:57:28,079
correct

1542
00:57:28,079 --> 00:57:29,839
and so you i don't know if you remember

1543
00:57:29,839 --> 00:57:31,280
what was mapped here in the user page

1544
00:57:31,280 --> 00:57:31,839
table

1545
00:57:31,839 --> 00:57:33,760
but this mapping here at the end of the

1546
00:57:33,760 --> 00:57:35,920
kernel page table is exactly the same

1547
00:57:35,920 --> 00:57:38,400
mapping in the same place

1548
00:57:38,400 --> 00:57:41,200
as the trampoline mapping at the end of

1549
00:57:41,200 --> 00:57:42,400
the user page table

1550
00:57:42,400 --> 00:57:44,640
all the other mappings are different but

1551
00:57:44,640 --> 00:57:46,000
this mapping is the same this is the

1552
00:57:46,000 --> 00:57:47,359
mapping that holds the instructions we

1553
00:57:47,359 --> 00:57:48,960
were executing and because it didn't

1554
00:57:48,960 --> 00:57:51,839
change when we switch page tables

1555
00:57:51,839 --> 00:57:53,839
we actually continue executing and we're

1556
00:57:53,839 --> 00:57:55,520
still executing the same sequence of

1557
00:57:55,520 --> 00:57:57,200
instructions

1558
00:57:57,200 --> 00:58:00,309
and not crashing

1559
00:58:00,319 --> 00:58:01,920
and so that's the sort of special thing

1560
00:58:01,920 --> 00:58:03,520
about the trampoline page it's

1561
00:58:03,520 --> 00:58:07,440
it's mapped both into user

1562
00:58:07,440 --> 00:58:10,240
page tables and into the kernel page

1563
00:58:10,240 --> 00:58:10,880
table

1564
00:58:10,880 --> 00:58:12,400
and the reason it's called a trampoline

1565
00:58:12,400 --> 00:58:14,240
page is because you sort of

1566
00:58:14,240 --> 00:58:17,520
bounce on it on the way from user space

1567
00:58:17,520 --> 00:58:20,640
to kernel space

1568
00:58:20,640 --> 00:58:22,640
and with the next instruction this jr

1569
00:58:22,640 --> 00:58:24,240
we're about to bounce

1570
00:58:24,240 --> 00:58:26,799
right out of the trampoline um into

1571
00:58:26,799 --> 00:58:27,359
kernel c

1572
00:58:27,359 --> 00:58:30,000
code and to see where we're going jr is

1573
00:58:30,000 --> 00:58:30,960
just like

1574
00:58:30,960 --> 00:58:33,040
jump to a subroutine this operating is

1575
00:58:33,040 --> 00:58:36,720
pointed to by register t0 print t0 to

1576
00:58:36,720 --> 00:58:39,589
see where we're going

1577
00:58:39,599 --> 00:58:43,599
uh maybe we'll print some instructions

1578
00:58:43,599 --> 00:58:46,470
there

1579
00:58:46,480 --> 00:58:47,920
okay so these are the instructions we're

1580
00:58:47,920 --> 00:58:49,680
about to jump to they're in the

1581
00:58:49,680 --> 00:58:51,119
the beginning of the function called

1582
00:58:51,119 --> 00:58:53,599
user trap

1583
00:58:53,599 --> 00:58:57,359
user trap is just a c function

1584
00:58:57,359 --> 00:59:00,950
defined in trap dot c

1585
00:59:00,960 --> 00:59:02,799
here's user trap now we're about we're

1586
00:59:02,799 --> 00:59:04,400
about to jump from assembly code to user

1587
00:59:04,400 --> 00:59:05,440
trap with a stack

1588
00:59:05,440 --> 00:59:07,760
with a kernel page table uh let me

1589
00:59:07,760 --> 00:59:09,920
actually do the

1590
00:59:09,920 --> 00:59:12,319
execute the instruction and now i'm

1591
00:59:12,319 --> 00:59:13,260
going to turn on

1592
00:59:13,260 --> 00:59:14,720
[Music]

1593
00:59:14,720 --> 00:59:18,559
um turn on displaying of c

1594
00:59:18,559 --> 00:59:21,119
code and gdb now that we're executing c

1595
00:59:21,119 --> 00:59:23,750
code

1596
00:59:23,760 --> 00:59:25,040
okay so now we're in a much more sane

1597
00:59:25,040 --> 00:59:27,280
world we're just executing c code

1598
00:59:27,280 --> 00:59:28,240
should be a little bit easier to

1599
00:59:28,240 --> 00:59:30,880
understand and there's

1600
00:59:30,880 --> 00:59:32,240
you know we'll still spend some time

1601
00:59:32,240 --> 00:59:34,480
reading and writing various interesting

1602
00:59:34,480 --> 00:59:37,520
control registers but um

1603
00:59:37,520 --> 00:59:39,440
the environment is hopefully a good deal

1604
00:59:39,440 --> 00:59:40,720
less mysterious than

1605
00:59:40,720 --> 00:59:47,990
it was in the track frame all right

1606
00:59:48,000 --> 00:59:50,000
any function any any questions at this

1607
00:59:50,000 --> 00:59:53,829
point

1608
00:59:53,839 --> 00:59:56,480
um i have a question why didn't we see

1609
00:59:56,480 --> 00:59:58,160
with the gdb

1610
00:59:58,160 --> 01:00:02,950
um what equal does

1611
01:00:02,960 --> 01:00:06,160
i i maybe i missed it but um i

1612
01:00:06,160 --> 01:00:08,559
think we jumped directly into the

1613
01:00:08,559 --> 01:00:11,829
trampoline

1614
01:00:11,839 --> 01:00:16,240
he called ecall did jump

1615
01:00:16,240 --> 01:00:19,680
what ecall does is

1616
01:00:19,680 --> 01:00:22,319
just switch just changes the mode bit to

1617
01:00:22,319 --> 01:00:23,920
be supervisor

1618
01:00:23,920 --> 01:00:29,359
and equals sets the

1619
01:00:29,359 --> 01:00:31,280
program counter register to be equal to

1620
01:00:31,280 --> 01:00:32,799
the whatever happens

1621
01:00:32,799 --> 01:00:34,480
whatever the kernel happened to store in

1622
01:00:34,480 --> 01:00:36,240
st back

1623
01:00:36,240 --> 01:00:38,920
kernel stored this value i just printed

1624
01:00:38,920 --> 01:00:40,400
3dff00 which is

1625
01:00:40,400 --> 01:00:42,480
the beginning of the trampoline page the

1626
01:00:42,480 --> 01:00:43,680
kernel stores

1627
01:00:43,680 --> 01:00:45,599
this number in st vac before entering

1628
01:00:45,599 --> 01:00:47,200
user space

1629
01:00:47,200 --> 01:00:49,680
so where ecall goes that is where it

1630
01:00:49,680 --> 01:00:50,799
says the program

1631
01:00:50,799 --> 01:00:54,160
counter to is st vac which is the

1632
01:00:54,160 --> 01:00:58,390
beginning of the trampoline page

1633
01:00:58,400 --> 01:01:02,309
does that answer your question

1634
01:01:02,319 --> 01:01:08,549
yes i think so okay

1635
01:01:08,559 --> 01:01:11,359
okay so now we're in uh when user trap

1636
01:01:11,359 --> 01:01:13,280
user tribe is entered actually just like

1637
01:01:13,280 --> 01:01:16,950
the trampoline page and

1638
01:01:16,960 --> 01:01:18,960
just like the trampoline page for a

1639
01:01:18,960 --> 01:01:20,559
number of different kinds of traps

1640
01:01:20,559 --> 01:01:21,599
there's system calls

1641
01:01:21,599 --> 01:01:23,599
there's exceptions like dividing by zero

1642
01:01:23,599 --> 01:01:26,079
or using a unmapped virtual address

1643
01:01:26,079 --> 01:01:27,599
and there's a device interrupts and they

1644
01:01:27,599 --> 01:01:30,480
all come here and so

1645
01:01:30,480 --> 01:01:32,880
user trap sort of saves and restores

1646
01:01:32,880 --> 01:01:34,640
hardware state but it also needs to

1647
01:01:34,640 --> 01:01:37,680
look at the state at the cause of the of

1648
01:01:37,680 --> 01:01:38,480
the trap

1649
01:01:38,480 --> 01:01:42,160
to figure out what to do with it um

1650
01:01:42,160 --> 01:01:43,680
and so we're gonna see both things as we

1651
01:01:43,680 --> 01:01:46,240
execute along in user trap

1652
01:01:46,240 --> 01:01:49,440
let me just um

1653
01:01:49,440 --> 01:01:52,720
run stuff in user trap let's see

1654
01:01:52,720 --> 01:01:54,960
the first thing it does here is that it

1655
01:01:54,960 --> 01:01:55,920
changes that s

1656
01:01:55,920 --> 01:02:00,400
t back register um it turns out that the

1657
01:02:00,400 --> 01:02:03,440
the way xv6 handles traps is different

1658
01:02:03,440 --> 01:02:04,880
depending on whether they come from user

1659
01:02:04,880 --> 01:02:06,799
space or from the kernel

1660
01:02:06,799 --> 01:02:08,079
we've only been talking about what

1661
01:02:08,079 --> 01:02:10,880
happens if a trap occurs from user space

1662
01:02:10,880 --> 01:02:12,640
there's a quite different sequence of

1663
01:02:12,640 --> 01:02:14,079
events

1664
01:02:14,079 --> 01:02:16,079
for traps that come from the kernel that

1665
01:02:16,079 --> 01:02:17,760
occur while in the kernel because after

1666
01:02:17,760 --> 01:02:18,799
all for example

1667
01:02:18,799 --> 01:02:21,119
the kernel is already using the kernel

1668
01:02:21,119 --> 01:02:22,000
page table

1669
01:02:22,000 --> 01:02:24,160
um you know if a trap occurs while

1670
01:02:24,160 --> 01:02:25,200
you're in the kernel you already have

1671
01:02:25,200 --> 01:02:26,480
the kernel page tables there's a whole

1672
01:02:26,480 --> 01:02:27,520
bunch of stuff that doesn't have to

1673
01:02:27,520 --> 01:02:28,559
happen

1674
01:02:28,559 --> 01:02:31,760
if the trap occurred while in the kernel

1675
01:02:31,760 --> 01:02:33,760
so before getting much further in the

1676
01:02:33,760 --> 01:02:35,359
kernel code we change

1677
01:02:35,359 --> 01:02:37,359
sd vac to point to this kernel vect

1678
01:02:37,359 --> 01:02:38,559
which is the kernel

1679
01:02:38,559 --> 01:02:40,880
trap handler rather than the user trap

1680
01:02:40,880 --> 01:02:44,549
handler

1681
01:02:44,559 --> 01:02:46,160
we need to for various reasons we need

1682
01:02:46,160 --> 01:02:48,000
to figure out what process we're running

1683
01:02:48,000 --> 01:02:49,599
we do that by calling this myproc

1684
01:02:49,599 --> 01:02:51,599
function and my proc actually looks at

1685
01:02:51,599 --> 01:02:52,240
an array

1686
01:02:52,240 --> 01:02:55,039
indexed by the current core number the

1687
01:02:55,039 --> 01:02:56,000
heart id

1688
01:02:56,000 --> 01:03:00,079
which you remember we put in tp

1689
01:03:00,079 --> 01:03:01,440
that's how myproduct figures out what

1690
01:03:01,440 --> 01:03:07,190
process is currently running

1691
01:03:07,200 --> 01:03:09,760
we need to save that saved user program

1692
01:03:09,760 --> 01:03:11,280
counter it's still sitting there

1693
01:03:11,280 --> 01:03:15,119
in an sepc

1694
01:03:15,119 --> 01:03:17,280
but because one of the things that could

1695
01:03:17,280 --> 01:03:18,880
happen while we're in the kernel is that

1696
01:03:18,880 --> 01:03:19,200
we

1697
01:03:19,200 --> 01:03:21,760
might switch to another process and that

1698
01:03:21,760 --> 01:03:23,200
other process might

1699
01:03:23,200 --> 01:03:26,480
go into that process user space and that

1700
01:03:26,480 --> 01:03:29,119
other process might make a system call

1701
01:03:29,119 --> 01:03:30,000
which causes

1702
01:03:30,000 --> 01:03:32,720
scpc to be overwritten we have to save

1703
01:03:32,720 --> 01:03:33,280
our

1704
01:03:33,280 --> 01:03:36,720
sepc in um some memory associated with

1705
01:03:36,720 --> 01:03:37,599
this process

1706
01:03:37,599 --> 01:03:39,599
so it doesn't get overwritten and it

1707
01:03:39,599 --> 01:03:41,599
gets you know we use this trap frame

1708
01:03:41,599 --> 01:03:43,920
to save epc as well as lots of other

1709
01:03:43,920 --> 01:03:45,359
stuff

1710
01:03:45,359 --> 01:03:47,760
and anyway that's what this current line

1711
01:03:47,760 --> 01:03:49,599
of code is doing

1712
01:03:49,599 --> 01:03:52,319
the next thing that happens we need to

1713
01:03:52,319 --> 01:03:56,470
figure out

1714
01:03:56,480 --> 01:03:59,280
why we came here the s cause the risk

1715
01:03:59,280 --> 01:04:00,880
five s cause register

1716
01:04:00,880 --> 01:04:02,640
has a different number depending on why

1717
01:04:02,640 --> 01:04:04,160
this trap occurred

1718
01:04:04,160 --> 01:04:06,880
you know uh some kind of exception or

1719
01:04:06,880 --> 01:04:08,559
versus system call versus device

1720
01:04:08,559 --> 01:04:09,359
interrupt

1721
01:04:09,359 --> 01:04:11,760
value eight means we're here we took a

1722
01:04:11,760 --> 01:04:15,109
trap because of a system call

1723
01:04:15,119 --> 01:04:17,839
and hopefully indeed this calls us eight

1724
01:04:17,839 --> 01:04:19,280
it does have eight because

1725
01:04:19,280 --> 01:04:21,440
we're here because of a system call um

1726
01:04:21,440 --> 01:04:22,640
so we're gonna execute this

1727
01:04:22,640 --> 01:04:26,000
this if statement um

1728
01:04:26,000 --> 01:04:27,760
first thing is if some other process has

1729
01:04:27,760 --> 01:04:29,039
killed this process we don't want to

1730
01:04:29,039 --> 01:04:29,839
continue but

1731
01:04:29,839 --> 01:04:33,920
that's not the case for our shell um

1732
01:04:33,920 --> 01:04:37,119
it turns out that the risk 5 the program

1733
01:04:37,119 --> 01:04:40,000
counter that gets stored in sepc

1734
01:04:40,000 --> 01:04:42,799
is the address of the instruction that

1735
01:04:42,799 --> 01:04:45,280
caused the trap

1736
01:04:45,280 --> 01:04:47,359
but when we resume we want to resume at

1737
01:04:47,359 --> 01:04:48,720
the next instruction

1738
01:04:48,720 --> 01:04:51,440
after the e-call and so therefore we

1739
01:04:51,440 --> 01:04:51,839
this

1740
01:04:51,839 --> 01:04:53,680
code for system calls which need to

1741
01:04:53,680 --> 01:04:56,150
return

1742
01:04:56,160 --> 01:04:58,960
we add four to the saved user program

1743
01:04:58,960 --> 01:05:00,799
counter so that we

1744
01:05:00,799 --> 01:05:02,480
resume on the next instruction and don't

1745
01:05:02,480 --> 01:05:03,839
just re-execute

1746
01:05:03,839 --> 01:05:08,240
the e-call

1747
01:05:08,240 --> 01:05:11,839
all right next it turns out that xv6

1748
01:05:11,839 --> 01:05:13,680
enables interrupts while it's handling

1749
01:05:13,680 --> 01:05:16,240
system calls just so that interrupts

1750
01:05:16,240 --> 01:05:18,319
can be served faster some system calls

1751
01:05:18,319 --> 01:05:20,230
take a lot of time

1752
01:05:20,230 --> 01:05:21,359
[Music]

1753
01:05:21,359 --> 01:05:23,680
uh interrupts are always turned off by

1754
01:05:23,680 --> 01:05:24,640
the risc-v

1755
01:05:24,640 --> 01:05:27,280
trap hardware um and so we have to

1756
01:05:27,280 --> 01:05:28,079
explicitly

1757
01:05:28,079 --> 01:05:30,480
turn them back on at this point um and

1758
01:05:30,480 --> 01:05:32,559
the next thing that happens

1759
01:05:32,559 --> 01:05:34,400
is we call this syscall function the job

1760
01:05:34,400 --> 01:05:37,440
of syscall i'll just enter it

1761
01:05:37,440 --> 01:05:40,480
um it's defined in

1762
01:05:40,480 --> 01:05:43,520
just called.c here we are

1763
01:05:43,520 --> 01:05:44,960
what it does is it looks up the system

1764
01:05:44,960 --> 01:05:46,570
call number in this um

1765
01:05:46,570 --> 01:05:47,680
[Music]

1766
01:05:47,680 --> 01:05:50,160
big table of system calls at the top of

1767
01:05:50,160 --> 01:05:51,680
the page

1768
01:05:51,680 --> 01:05:54,319
um if you remember the shells write

1769
01:05:54,319 --> 01:05:54,799
function

1770
01:05:54,799 --> 01:05:57,760
set register a7 to be the system call

1771
01:05:57,760 --> 01:05:58,720
number namely

1772
01:05:58,720 --> 01:06:02,000
16 for write so what cisco does is it

1773
01:06:02,000 --> 01:06:04,559
retrieves the saved a7

1774
01:06:04,559 --> 01:06:06,880
that was saved away in the trap fame by

1775
01:06:06,880 --> 01:06:10,309
the trampoline code

1776
01:06:10,319 --> 01:06:11,920
and it uses that to index into this

1777
01:06:11,920 --> 01:06:13,359
table of

1778
01:06:13,359 --> 01:06:14,960
pointers to functions that implement

1779
01:06:14,960 --> 01:06:17,440
each system call

1780
01:06:17,440 --> 01:06:21,200
so we're going to fish this number

1781
01:06:21,200 --> 01:06:23,599
i'm going to print num now that's the

1782
01:06:23,599 --> 01:06:25,839
save d7 indeed it's 16

1783
01:06:25,839 --> 01:06:27,920
the same 16 that the shell originally

1784
01:06:27,920 --> 01:06:30,829
put there

1785
01:06:30,839 --> 01:06:34,079
um the system call

1786
01:06:34,079 --> 01:06:37,119
code indexes into that syscalls table we

1787
01:06:37,119 --> 01:06:38,319
can find out what function

1788
01:06:38,319 --> 01:06:40,960
come it's got out of the system call

1789
01:06:40,960 --> 01:06:42,319
table

1790
01:06:42,319 --> 01:06:44,319
uh by stepping into it right now we're

1791
01:06:44,319 --> 01:06:46,079
in write or insist write

1792
01:06:46,079 --> 01:06:49,680
so isn't this

1793
01:06:49,680 --> 01:06:53,599
file.c this write is the

1794
01:06:53,599 --> 01:06:56,240
kernel implementation of the write

1795
01:06:56,240 --> 01:06:57,920
system call

1796
01:06:57,920 --> 01:06:59,680
i'm not going to go into this it's like

1797
01:06:59,680 --> 01:07:01,200
fairly complicated what happens from

1798
01:07:01,200 --> 01:07:02,400
here on

1799
01:07:02,400 --> 01:07:04,000
in and the implementation of the system

1800
01:07:04,000 --> 01:07:05,920
call for this lecture i'm only really

1801
01:07:05,920 --> 01:07:07,200
interested in getting into and out of

1802
01:07:07,200 --> 01:07:08,079
the kernel

1803
01:07:08,079 --> 01:07:12,829
um so i'm going to

1804
01:07:12,839 --> 01:07:26,470
um step over

1805
01:07:26,480 --> 01:07:28,319
the actual implementation system call

1806
01:07:28,319 --> 01:07:29,920
one thing an interesting thing to note

1807
01:07:29,920 --> 01:07:30,559
is that

1808
01:07:30,559 --> 01:07:32,000
the system calls need to find their

1809
01:07:32,000 --> 01:07:33,760
arguments so you know remember the

1810
01:07:33,760 --> 01:07:35,119
arguments to write or

1811
01:07:35,119 --> 01:07:37,520
two and a buffer pointer and another two

1812
01:07:37,520 --> 01:07:38,880
and the way that the

1813
01:07:38,880 --> 01:07:40,559
system called code gets at them is just

1814
01:07:40,559 --> 01:07:45,990
looking at this um

1815
01:07:46,000 --> 01:07:49,520
well looking in the trap frame

1816
01:07:49,520 --> 01:07:50,880
so just like we could look in the trap

1817
01:07:50,880 --> 01:07:53,520
frame for a7 we can look for a0

1818
01:07:53,520 --> 01:07:55,119
and that's the first argument we look at

1819
01:07:55,119 --> 01:07:56,799
a1 that's that buffer pointer we can

1820
01:07:56,799 --> 01:07:58,720
look at a2 that's the second argument

1821
01:07:58,720 --> 01:08:02,470
the number of

1822
01:08:02,480 --> 01:08:06,240
bytes to write okay so the system call

1823
01:08:06,240 --> 01:08:07,760
does its job and then

1824
01:08:07,760 --> 01:08:13,109
cis write finally returns

1825
01:08:13,119 --> 01:08:15,280
and we're going to watch what happens

1826
01:08:15,280 --> 01:08:17,120
the reason for this assignment here the

1827
01:08:17,120 --> 01:08:19,040
reason why we're assigning

1828
01:08:19,040 --> 01:08:22,719
to a0 in the trap frame is that

1829
01:08:22,719 --> 01:08:24,480
this system calls all have a return

1830
01:08:24,480 --> 01:08:26,000
value

1831
01:08:26,000 --> 01:08:27,679
like write returns the number of bytes

1832
01:08:27,679 --> 01:08:30,159
written and the convention and for c

1833
01:08:30,159 --> 01:08:31,920
code on the risk five is that

1834
01:08:31,920 --> 01:08:34,960
return values are placed in register a0

1835
01:08:34,960 --> 01:08:36,880
by whatever function you're calling and

1836
01:08:36,880 --> 01:08:39,120
so to simulate a return value we just

1837
01:08:39,120 --> 01:08:40,480
stick the return value

1838
01:08:40,480 --> 01:08:43,120
in a0 in the trap frame and we'll see by

1839
01:08:43,120 --> 01:08:45,759
and by that when we return to user space

1840
01:08:45,759 --> 01:08:48,560
this a0 slot in the trap frame is

1841
01:08:48,560 --> 01:08:50,319
restored back into the actual a0

1842
01:08:50,319 --> 01:08:50,880
register

1843
01:08:50,880 --> 01:08:56,550
and the shell sees that a0 value as um

1844
01:08:56,560 --> 01:08:59,920
as the return value from right and if we

1845
01:08:59,920 --> 01:09:02,640
just execute through this and print pro

1846
01:09:02,640 --> 01:09:03,440
trap

1847
01:09:03,440 --> 01:09:06,799
frame starter we'll see it as value 2

1848
01:09:06,799 --> 01:09:08,719
what that means is that right

1849
01:09:08,719 --> 01:09:10,480
return value is 2 saying that it

1850
01:09:10,480 --> 01:09:12,480
actually wrote two bytes just as

1851
01:09:12,480 --> 01:09:13,920
instructed

1852
01:09:13,920 --> 01:09:18,709
okay at this point we're back in

1853
01:09:18,719 --> 01:09:22,719
trap.c in usertrap um

1854
01:09:22,719 --> 01:09:24,799
just after the called assist call so

1855
01:09:24,799 --> 01:09:26,560
we're now with this

1856
01:09:26,560 --> 01:09:28,400
pierrot which is checking if the func if

1857
01:09:28,400 --> 01:09:30,159
the process has been killed because

1858
01:09:30,159 --> 01:09:31,600
we don't want to resume executing it's

1859
01:09:31,600 --> 01:09:33,279
already been killed but of course

1860
01:09:33,279 --> 01:09:36,480
our shell has not been killed skip over

1861
01:09:36,480 --> 01:09:38,239
this

1862
01:09:38,239 --> 01:09:42,319
and then um user trap calls a separate

1863
01:09:42,319 --> 01:09:42,880
function

1864
01:09:42,880 --> 01:09:45,520
user trap red in order to set up all the

1865
01:09:45,520 --> 01:09:47,279
stuff that i talked about previously

1866
01:09:47,279 --> 01:09:48,319
whenever i said

1867
01:09:48,319 --> 01:09:50,159
well before entering user space the

1868
01:09:50,159 --> 01:09:52,880
kernel does blah blah blah

1869
01:09:52,880 --> 01:09:55,679
it's user trap red that's responsible

1870
01:09:55,679 --> 01:09:56,320
for

1871
01:09:56,320 --> 01:10:00,390
setting all that stuff up

1872
01:10:00,400 --> 01:10:01,600
and so we can look at all the different

1873
01:10:01,600 --> 01:10:09,590
things it does um

1874
01:10:09,600 --> 01:10:14,000
it um it turns interrupts off

1875
01:10:14,000 --> 01:10:15,360
they were turned on for the duration of

1876
01:10:15,360 --> 01:10:17,040
a system call they're turned off now

1877
01:10:17,040 --> 01:10:20,239
because we're about to change the st vec

1878
01:10:20,239 --> 01:10:24,080
to point to the user

1879
01:10:24,080 --> 01:10:26,480
trap handler whereas while we're in the

1880
01:10:26,480 --> 01:10:27,840
kernel it was pointing to the kernel

1881
01:10:27,840 --> 01:10:28,719
trap handler

1882
01:10:28,719 --> 01:10:30,480
so we turn off interrupts because once

1883
01:10:30,480 --> 01:10:32,800
we changed st vector point to the user

1884
01:10:32,800 --> 01:10:34,239
trap handler we're still executing in

1885
01:10:34,239 --> 01:10:34,960
the kernel

1886
01:10:34,960 --> 01:10:37,360
and if an interrupt should occur then it

1887
01:10:37,360 --> 01:10:39,120
would go to the user trap handler even

1888
01:10:39,120 --> 01:10:40,640
though we're executing in the kernel

1889
01:10:40,640 --> 01:10:44,239
and for various detailed reasons um

1890
01:10:44,239 --> 01:10:45,600
that would cause the kernel to

1891
01:10:45,600 --> 01:10:48,640
malfunction so we turn off interrupts

1892
01:10:48,640 --> 01:10:50,080
and they're left off from between the

1893
01:10:50,080 --> 01:10:52,800
time or from the very next line where we

1894
01:10:52,800 --> 01:10:55,040
set up the s t vec to point to the

1895
01:10:55,040 --> 01:10:56,080
trampoline

1896
01:10:56,080 --> 01:10:58,320
all the way through the final s red

1897
01:10:58,320 --> 01:11:01,199
instruction that returns to user space

1898
01:11:01,199 --> 01:11:02,640
it turns out that s red instruction at

1899
01:11:02,640 --> 01:11:04,400
the end of the trampoline

1900
01:11:04,400 --> 01:11:07,440
um turns interrupts back on so the

1901
01:11:07,440 --> 01:11:09,120
interrupts are on when we're executing

1902
01:11:09,120 --> 01:11:10,560
in uh

1903
01:11:10,560 --> 01:11:11,920
user code even though we just turned

1904
01:11:11,920 --> 01:11:14,880
them off the next couple of lines

1905
01:11:14,880 --> 01:11:17,679
fill in those trap frame slots that we

1906
01:11:17,679 --> 01:11:19,679
saw before that hold various

1907
01:11:19,679 --> 01:11:22,080
values that are convenient for the

1908
01:11:22,080 --> 01:11:23,280
trampoline code

1909
01:11:23,280 --> 01:11:27,199
so the code here stashes away a pointer

1910
01:11:27,199 --> 01:11:28,400
to the kernel

1911
01:11:28,400 --> 01:11:31,679
page table in the trap frame it stashes

1912
01:11:31,679 --> 01:11:32,000
away

1913
01:11:32,000 --> 01:11:36,880
a pointer to this processes kernel stack

1914
01:11:36,880 --> 01:11:41,280
uh it stashes away in the trap frame

1915
01:11:41,280 --> 01:11:42,880
a pointer to the user track function

1916
01:11:42,880 --> 01:11:44,800
which is what the trampoline code jumped

1917
01:11:44,800 --> 01:11:47,679
to at the very end

1918
01:11:47,679 --> 01:11:49,440
and it stashes the way the current core

1919
01:11:49,440 --> 01:11:50,800
number

1920
01:11:50,800 --> 01:11:54,159
read from the tp register so that the

1921
01:11:54,159 --> 01:11:55,840
trampoline code can just restore that

1922
01:11:55,840 --> 01:11:58,239
same value because user code may have

1923
01:11:58,239 --> 01:12:01,270
disturbed it

1924
01:12:01,280 --> 01:12:04,400
all right yes um why didn't we save the

1925
01:12:04,400 --> 01:12:08,320
sepc in the trampoline

1926
01:12:08,320 --> 01:12:11,350
it could have

1927
01:12:11,360 --> 01:12:13,360
uh yeah yeah i mean that that the scpc

1928
01:12:13,360 --> 01:12:14,400
could have been

1929
01:12:14,400 --> 01:12:16,080
the trampoline code happens not to save

1930
01:12:16,080 --> 01:12:17,920
it along with the other registers

1931
01:12:17,920 --> 01:12:21,440
we perfectly well could modify the xv6

1932
01:12:21,440 --> 01:12:23,120
to save it i mean where it is actually

1933
01:12:23,120 --> 01:12:25,040
saved as you

1934
01:12:25,040 --> 01:12:27,840
probably remember is just happen to save

1935
01:12:27,840 --> 01:12:29,840
it in user trap and c code instead of an

1936
01:12:29,840 --> 01:12:31,600
assembly code

1937
01:12:31,600 --> 01:12:34,950
in the trampoline code

1938
01:12:34,960 --> 01:12:36,880
um i don't think this i can't think of a

1939
01:12:36,880 --> 01:12:38,480
good reason to do it one way or the

1940
01:12:38,480 --> 01:12:40,320
other

1941
01:12:40,320 --> 01:12:42,480
the user registers really have to be

1942
01:12:42,480 --> 01:12:45,199
saved in the assembly code

1943
01:12:45,199 --> 01:12:47,760
because any c code is entitled for all

1944
01:12:47,760 --> 01:12:49,199
we know the compiler generates code

1945
01:12:49,199 --> 01:12:53,110
which modifies any

1946
01:12:53,120 --> 01:12:54,880
user register so those user registers

1947
01:12:54,880 --> 01:12:56,719
are pretty important to save them in

1948
01:12:56,719 --> 01:12:58,960
assembly code before entering c

1949
01:12:58,960 --> 01:13:00,960
but the epc we could have been saved

1950
01:13:00,960 --> 01:13:04,480
earlier or later

1951
01:13:04,480 --> 01:13:06,560
okay so we're in user trap red sort of

1952
01:13:06,560 --> 01:13:08,880
preparing the trap we prepared the trap

1953
01:13:08,880 --> 01:13:10,400
frame with all these values that are

1954
01:13:10,400 --> 01:13:12,080
going to be needed

1955
01:13:12,080 --> 01:13:15,040
um next time there's a transition from

1956
01:13:15,040 --> 01:13:16,320
user space to kernel

1957
01:13:16,320 --> 01:13:20,070
next trap

1958
01:13:20,080 --> 01:13:21,199
there's a couple things we have to set

1959
01:13:21,199 --> 01:13:23,440
up in the s status

1960
01:13:23,440 --> 01:13:27,120
control register it turns out this

1961
01:13:27,120 --> 01:13:30,320
spp bit in s status

1962
01:13:30,320 --> 01:13:33,360
controls weather controls the mode

1963
01:13:33,360 --> 01:13:36,880
that s red returns to and by clearing it

1964
01:13:36,880 --> 01:13:37,840
we're just saying

1965
01:13:37,840 --> 01:13:40,960
oh look next time we execute sret

1966
01:13:40,960 --> 01:13:42,719
we want to go to user mode instead of

1967
01:13:42,719 --> 01:13:44,719
supervisor mode

1968
01:13:44,719 --> 01:13:48,560
and this spie bit controls whether

1969
01:13:48,560 --> 01:13:51,679
interrupts will be enabled after we

1970
01:13:51,679 --> 01:13:52,800
execute s-red

1971
01:13:52,800 --> 01:13:54,719
and you know after we get into user

1972
01:13:54,719 --> 01:13:56,800
space and we do want them to be enabled

1973
01:13:56,800 --> 01:13:59,760
so i'm going to set that spie bit and

1974
01:13:59,760 --> 01:14:00,719
then we're going to write this new

1975
01:14:00,719 --> 01:14:03,360
modified status into the actual hardware

1976
01:14:03,360 --> 01:14:06,550
status register

1977
01:14:06,560 --> 01:14:10,310
it turns out what sret does

1978
01:14:10,320 --> 01:14:11,600
you know the sro we're going to execute

1979
01:14:11,600 --> 01:14:12,960
right at the end of the trampoline code

1980
01:14:12,960 --> 01:14:14,480
what that s red does

1981
01:14:14,480 --> 01:14:17,280
is um sets the program counter equal to

1982
01:14:17,280 --> 01:14:19,840
the sepc register

1983
01:14:19,840 --> 01:14:21,920
so we're now going to set up the sepc

1984
01:14:21,920 --> 01:14:23,280
register to have

1985
01:14:23,280 --> 01:14:27,360
the saved user program counter

1986
01:14:27,360 --> 01:14:30,000
which if you recall we recently saved in

1987
01:14:30,000 --> 01:14:31,440
the trap frame that's what's happening

1988
01:14:31,440 --> 01:14:34,149
here

1989
01:14:34,159 --> 01:14:36,560
if you remember also the trap frame

1990
01:14:36,560 --> 01:14:39,440
contain a pointer to

1991
01:14:39,440 --> 01:14:41,440
the kernel page table because the

1992
01:14:41,440 --> 01:14:43,600
trampoline needs to switch to it

1993
01:14:43,600 --> 01:14:45,760
we need to cook up the special bit

1994
01:14:45,760 --> 01:14:48,080
pattern that you need to write to satp

1995
01:14:48,080 --> 01:14:52,719
that's done here and

1996
01:14:52,719 --> 01:14:55,440
i'm sorry we're now preparing a pointer

1997
01:14:55,440 --> 01:14:57,840
to the user page table

1998
01:14:57,840 --> 01:14:59,600
which we need to switch to on the way

1999
01:14:59,600 --> 01:15:02,480
into user space

2000
01:15:02,480 --> 01:15:04,080
we're actually going to do that switch

2001
01:15:04,080 --> 01:15:06,000
in assembly code because it has to

2002
01:15:06,000 --> 01:15:06,480
happen

2003
01:15:06,480 --> 01:15:09,120
in the trampoline because only code in

2004
01:15:09,120 --> 01:15:10,880
the trampoline is mapped in both user

2005
01:15:10,880 --> 01:15:12,320
and kernel space

2006
01:15:12,320 --> 01:15:15,120
so we can only really switch page tables

2007
01:15:15,120 --> 01:15:16,480
when we're executing on the trampoline

2008
01:15:16,480 --> 01:15:17,600
but we're not executing on the

2009
01:15:17,600 --> 01:15:18,800
trampoline yet

2010
01:15:18,800 --> 01:15:20,239
we're still just in an ordinary c

2011
01:15:20,239 --> 01:15:22,560
function so we prepare this pointer

2012
01:15:22,560 --> 01:15:24,080
and we're going to pass it to the

2013
01:15:24,080 --> 01:15:26,560
assembly code as the second argument in

2014
01:15:26,560 --> 01:15:30,790
a1

2015
01:15:30,800 --> 01:15:32,320
what this line here doing is just

2016
01:15:32,320 --> 01:15:34,000
calculating the address

2017
01:15:34,000 --> 01:15:36,880
of where we want to jump to at the end

2018
01:15:36,880 --> 01:15:39,840
of the trampoline code and it turns out

2019
01:15:39,840 --> 01:15:42,480
that there's a that we where we want to

2020
01:15:42,480 --> 01:15:44,400
go is user read user writes the address

2021
01:15:44,400 --> 01:15:46,159
of the instructions that'll take us back

2022
01:15:46,159 --> 01:15:47,520
to user space

2023
01:15:47,520 --> 01:15:52,480
and this little formula works out um

2024
01:15:52,480 --> 01:15:55,120
the address and the virtual address and

2025
01:15:55,120 --> 01:15:56,320
the trampoline

2026
01:15:56,320 --> 01:15:58,000
that corresponds to that user rat

2027
01:15:58,000 --> 01:16:00,000
function

2028
01:16:00,000 --> 01:16:04,830
um

2029
01:16:04,840 --> 01:16:07,520
oops okay so we calculate the address of

2030
01:16:07,520 --> 01:16:09,600
that

2031
01:16:09,600 --> 01:16:12,719
user at function and then this mess this

2032
01:16:12,719 --> 01:16:14,080
next line

2033
01:16:14,080 --> 01:16:17,199
call uses this fn

2034
01:16:17,199 --> 01:16:19,199
variable as a function pointer and jumps

2035
01:16:19,199 --> 01:16:21,040
to that function with these two

2036
01:16:21,040 --> 01:16:24,239
arguments in a0 and a1

2037
01:16:24,239 --> 01:16:28,709
we can now just go to

2038
01:16:28,719 --> 01:16:33,669
trampoline code

2039
01:16:33,679 --> 01:16:36,480
in the trampoline code there's um

2040
01:16:36,480 --> 01:16:38,640
[Music]

2041
01:16:38,640 --> 01:16:39,920
well first we switch to the user page

2042
01:16:39,920 --> 01:16:41,360
table so it means actually execute this

2043
01:16:41,360 --> 01:16:43,520
and we can see the page tables change

2044
01:16:43,520 --> 01:16:45,920
just for chuckles we're still using the

2045
01:16:45,920 --> 01:16:48,480
giant kernel page table

2046
01:16:48,480 --> 01:16:52,400
um i'm going to run through user trapret

2047
01:16:52,400 --> 01:16:53,120
quickly

2048
01:16:53,120 --> 01:16:54,560
until we get to the point where it jumps

2049
01:16:54,560 --> 01:16:59,030
to the trampoline

2050
01:16:59,040 --> 01:17:07,189
all right we're in the trampoline um

2051
01:17:07,199 --> 01:17:08,400
these are the instructions so we're

2052
01:17:08,400 --> 01:17:09,920
about to start executing the trampoline

2053
01:17:09,920 --> 01:17:10,400
code

2054
01:17:10,400 --> 01:17:14,480
right here we can now again

2055
01:17:14,480 --> 01:17:16,560
let's print the page table it's still

2056
01:17:16,560 --> 01:17:18,480
the kernel page table

2057
01:17:18,480 --> 01:17:21,040
um the first thing that's going to

2058
01:17:21,040 --> 01:17:22,640
happen here though is that the

2059
01:17:22,640 --> 01:17:25,040
trampoline code is going to load the

2060
01:17:25,040 --> 01:17:27,679
that pointer to the user page table

2061
01:17:27,679 --> 01:17:30,800
into the sat p register so we switch

2062
01:17:30,800 --> 01:17:33,360
page tables if i type info map now

2063
01:17:33,360 --> 01:17:35,120
we now have a much smaller user page

2064
01:17:35,120 --> 01:17:36,880
table but luckily

2065
01:17:36,880 --> 01:17:38,640
still with the trampoline page map so we

2066
01:17:38,640 --> 01:17:43,189
don't crash on the next instruction

2067
01:17:43,199 --> 01:17:47,350
the next thing that happens is this um

2068
01:17:47,360 --> 01:17:51,600
um i showed you a while ago that the

2069
01:17:51,600 --> 01:17:53,840
second to last thing that this sequence

2070
01:17:53,840 --> 01:17:55,600
of code does on the way to user space

2071
01:17:55,600 --> 01:17:58,719
is swaps s scratch with a zero

2072
01:17:58,719 --> 01:18:00,800
so we need to set up s scratch with the

2073
01:18:00,800 --> 01:18:03,280
saved user a0 so that when we do that

2074
01:18:03,280 --> 01:18:04,640
swap

2075
01:18:04,640 --> 01:18:07,440
a0 will end up having the saved user a0

2076
01:18:07,440 --> 01:18:08,239
it turns out

2077
01:18:08,239 --> 01:18:10,560
a0 is a pointer to the trap frame

2078
01:18:10,560 --> 01:18:11,679
because

2079
01:18:11,679 --> 01:18:13,600
the c code passed that as the first

2080
01:18:13,600 --> 01:18:15,280
argument 112

2081
01:18:15,280 --> 01:18:18,800
of a0 is the address of the saved a0

2082
01:18:18,800 --> 01:18:19,840
in the track frame so we're going to

2083
01:18:19,840 --> 01:18:22,800
load that and then into t0 and then load

2084
01:18:22,800 --> 01:18:23,520
that into

2085
01:18:23,520 --> 01:18:25,360
scratch at this point we're still

2086
01:18:25,360 --> 01:18:27,040
running with the

2087
01:18:27,040 --> 01:18:31,199
kernel stuff and all the registers

2088
01:18:31,199 --> 01:18:34,400
the next 32 instructions though load out

2089
01:18:34,400 --> 01:18:35,600
of the trap frame which

2090
01:18:35,600 --> 01:18:38,640
a0 points to load all of the

2091
01:18:38,640 --> 01:18:41,120
saved user registers out of the trap

2092
01:18:41,120 --> 01:18:45,110
frame

2093
01:18:45,120 --> 01:18:47,040
into the actual register so we're like

2094
01:18:47,040 --> 01:18:48,880
really close to being able to

2095
01:18:48,880 --> 01:18:50,640
the point where we can run user code i'm

2096
01:18:50,640 --> 01:18:56,070
going to skip over all these loads

2097
01:18:56,080 --> 01:18:59,040
any questions before we uh approach

2098
01:18:59,040 --> 01:19:02,310
closer to user space

2099
01:19:02,320 --> 01:19:04,719
i have one quick question is the value

2100
01:19:04,719 --> 01:19:07,760
in the trap frame a0 now the return

2101
01:19:07,760 --> 01:19:11,430
value of that system call that we made

2102
01:19:11,440 --> 01:19:14,790
um

2103
01:19:14,800 --> 01:19:18,159
yeah yeah the relay zero holds just this

2104
01:19:18,159 --> 01:19:20,880
under the trap frame but the after we

2105
01:19:20,880 --> 01:19:21,600
execute

2106
01:19:21,600 --> 01:19:24,960
the well s

2107
01:19:24,960 --> 01:19:27,600
okay the current location of the user

2108
01:19:27,600 --> 01:19:29,199
saved

2109
01:19:29,199 --> 01:19:32,560
uh yes i was calling it the user saved

2110
01:19:32,560 --> 01:19:33,760
a0 but in fact

2111
01:19:33,760 --> 01:19:36,159
the system call returns stuff overwrote

2112
01:19:36,159 --> 01:19:39,199
it with the return value that we want

2113
01:19:39,199 --> 01:19:42,000
the shell to see in a0 so the current

2114
01:19:42,000 --> 01:19:44,080
location of that a0 which we overwrote

2115
01:19:44,080 --> 01:19:45,679
with 2

2116
01:19:45,679 --> 01:19:47,679
as the return value is s scrap so i'm

2117
01:19:47,679 --> 01:19:49,280
going to point s scratch and hope that

2118
01:19:49,280 --> 01:19:51,199
it's equal to two

2119
01:19:51,199 --> 01:19:55,750
it is equal to two um

2120
01:19:55,760 --> 01:19:58,239
does that answer your question yes i

2121
01:19:58,239 --> 01:19:58,960
think so

2122
01:19:58,960 --> 01:20:01,679
okay i'm gonna uh skip over all these

2123
01:20:01,679 --> 01:20:02,640
loads

2124
01:20:02,640 --> 01:20:05,440
the restore the saved user values out of

2125
01:20:05,440 --> 01:20:08,159
the trap frame into the registers

2126
01:20:08,159 --> 01:20:09,520
why don't i print out the registers at

2127
01:20:09,520 --> 01:20:11,360
this point

2128
01:20:11,360 --> 01:20:16,550
um actually gonna

2129
01:20:16,560 --> 01:20:18,239
print out the registers i don't know if

2130
01:20:18,239 --> 01:20:19,760
these look familiar but they happen to

2131
01:20:19,760 --> 01:20:20,400
be

2132
01:20:20,400 --> 01:20:22,239
the same set of user registers we saw

2133
01:20:22,239 --> 01:20:23,600
way back at the beginning of this

2134
01:20:23,600 --> 01:20:24,800
exercise

2135
01:20:24,800 --> 01:20:28,719
for example a1 or the stack pointer

2136
01:20:28,719 --> 01:20:30,639
holds this small value appropriate for a

2137
01:20:30,639 --> 01:20:32,880
user stack low in memory

2138
01:20:32,880 --> 01:20:35,600
a1 is that buffer pointer that we passed

2139
01:20:35,600 --> 01:20:36,560
to write

2140
01:20:36,560 --> 01:20:39,520
2 is that number of bytes a0 however is

2141
01:20:39,520 --> 01:20:40,719
the exception is

2142
01:20:40,719 --> 01:20:44,719
not a saved user value because it still

2143
01:20:44,719 --> 01:20:47,040
has the pointer to our trap frame in it

2144
01:20:47,040 --> 01:20:52,790
um but let's look we're about to execute

2145
01:20:52,800 --> 01:20:56,000
um we're about to execute is this

2146
01:20:56,000 --> 01:20:59,360
csr rwa0 scratch

2147
01:20:59,360 --> 01:21:02,080
right at the end of trampoline just

2148
01:21:02,080 --> 01:21:03,520
before returning to user space this is

2149
01:21:03,520 --> 01:21:06,320
going to swap a0 and scratch

2150
01:21:06,320 --> 01:21:12,629
scratch indeed has

2151
01:21:12,639 --> 01:21:16,629
ah that's scratch

2152
01:21:16,639 --> 01:21:18,159
has two which is going to be the return

2153
01:21:18,159 --> 01:21:19,679
value a0

2154
01:21:19,679 --> 01:21:26,709
has this kernel pointer and it points to

2155
01:21:26,719 --> 01:21:28,159
points to the trap frame but after

2156
01:21:28,159 --> 01:21:30,080
executing the csrw

2157
01:21:30,080 --> 01:21:32,239
instruction to swap them hopefully we'll

2158
01:21:32,239 --> 01:21:33,199
see that

2159
01:21:33,199 --> 01:21:36,880
um a0 holds this return value of two

2160
01:21:36,880 --> 01:21:40,159
and s

2161
01:21:40,159 --> 01:21:42,719
scratch holds a pointer to the trap

2162
01:21:42,719 --> 01:21:44,239
frame which is

2163
01:21:44,239 --> 01:21:47,440
the second to last page in memory um

2164
01:21:47,440 --> 01:21:49,120
and that value is going to stay in

2165
01:21:49,120 --> 01:21:50,639
scratch until the user

2166
01:21:50,639 --> 01:21:52,400
program does another trap and at that

2167
01:21:52,400 --> 01:21:54,719
point the trap handling code that we

2168
01:21:54,719 --> 01:21:56,080
talked about before we'll

2169
01:21:56,080 --> 01:21:57,600
be able to use that scratch to get at

2170
01:21:57,600 --> 01:22:01,600
the trap frame all right we're still

2171
01:22:01,600 --> 01:22:04,000
in the kernel but this is our last

2172
01:22:04,000 --> 01:22:06,560
instruction in the kernel

2173
01:22:06,560 --> 01:22:10,800
and when i execute this s-ret it will uh

2174
01:22:10,800 --> 01:22:14,159
switch to user mode um before i do that

2175
01:22:14,159 --> 01:22:17,270
let's look at

2176
01:22:17,280 --> 01:22:19,760
it'll switch to user mode it'll copy

2177
01:22:19,760 --> 01:22:22,960
sepc to the pc because we're still

2178
01:22:22,960 --> 01:22:26,950
um

2179
01:22:26,960 --> 01:22:28,960
we're still executing with the pc that's

2180
01:22:28,960 --> 01:22:30,560
in the trampoline

2181
01:22:30,560 --> 01:22:33,520
so esret's gonna switch to user mode

2182
01:22:33,520 --> 01:22:34,800
copy scpc

2183
01:22:34,800 --> 01:22:36,640
to pc

2184
01:22:36,640 --> 01:22:37,840
[Music]

2185
01:22:37,840 --> 01:22:40,639
and then resume executing so i'm gonna

2186
01:22:40,639 --> 01:22:41,199
run the

2187
01:22:41,199 --> 01:22:45,360
sret boom um

2188
01:22:45,360 --> 01:22:48,639
now we're back at um

2189
01:22:48,639 --> 01:22:51,120
back at address zero x dea which is a

2190
01:22:51,120 --> 01:22:52,400
low address

2191
01:22:52,400 --> 01:22:56,159
likely to be user memory and it's the

2192
01:22:56,159 --> 01:22:59,440
look back at sh.asm and address

2193
01:22:59,440 --> 01:23:03,990
xerox dea

2194
01:23:04,000 --> 01:23:06,880
is indeed the address of the return

2195
01:23:06,880 --> 01:23:09,920
function at the end of write

2196
01:23:09,920 --> 01:23:12,950
and

2197
01:23:12,960 --> 01:23:14,800
a0 is this return value that was

2198
01:23:14,800 --> 01:23:16,639
supposed to be turning

2199
01:23:16,639 --> 01:23:18,960
so we're back in user space and we can

2200
01:23:18,960 --> 01:23:20,000
about to do the return

2201
01:23:20,000 --> 01:23:22,239
back to the shell from the right system

2202
01:23:22,239 --> 01:23:23,520
from the right library function that

2203
01:23:23,520 --> 01:23:25,120
made the system call

2204
01:23:25,120 --> 01:23:28,790
okay any questions

2205
01:23:28,800 --> 01:23:30,800
uh sorry can you repeat again what

2206
01:23:30,800 --> 01:23:31,840
happens with the

2207
01:23:31,840 --> 01:23:37,669
interrupt during s red

2208
01:23:37,679 --> 01:23:40,159
what happened with interrupts you said

2209
01:23:40,159 --> 01:23:41,440
you are turning them

2210
01:23:41,440 --> 01:23:44,080
off but then something else turns them

2211
01:23:44,080 --> 01:23:46,830
back on

2212
01:23:46,840 --> 01:23:50,320
s-rat um s-red enables interrupts

2213
01:23:50,320 --> 01:23:52,960
so this s-ret the very last instruction

2214
01:23:52,960 --> 01:23:54,639
that we're executing in supervisor mode

2215
01:23:54,639 --> 01:23:56,159
in the kernel

2216
01:23:56,159 --> 01:23:58,239
um i forgot to say that just now but as

2217
01:23:58,239 --> 01:23:59,920
well as setting the program counter

2218
01:23:59,920 --> 01:24:00,639
equal to the

2219
01:24:00,639 --> 01:24:03,679
scpc and switching to user mode s

2220
01:24:03,679 --> 01:24:07,920
red is going to re-enable interrupts

2221
01:24:07,920 --> 01:24:10,400
does that mean you know that's you know

2222
01:24:10,400 --> 01:24:11,679
user programs that may run for a long

2223
01:24:11,679 --> 01:24:13,120
time it'd be nice to be able to take

2224
01:24:13,120 --> 01:24:15,840
disk interrupts or whatever

2225
01:24:15,840 --> 01:24:18,960
user programs are running i see thank

2226
01:24:18,960 --> 01:24:20,800
you

2227
01:24:20,800 --> 01:24:28,070
other questions

2228
01:24:28,080 --> 01:24:31,520
okay to uh to wrap up the system calls

2229
01:24:31,520 --> 01:24:33,040
sort of look like function calls that

2230
01:24:33,040 --> 01:24:35,199
are kind of meant to be thought of a lot

2231
01:24:35,199 --> 01:24:36,239
like function calls

2232
01:24:36,239 --> 01:24:39,199
but um the user kernel transitions are

2233
01:24:39,199 --> 01:24:41,120
much more complex than

2234
01:24:41,120 --> 01:24:43,360
than function calls are a lot of the

2235
01:24:43,360 --> 01:24:45,520
complexities due to the requirement

2236
01:24:45,520 --> 01:24:47,199
for isolation the kernel just can't

2237
01:24:47,199 --> 01:24:49,280
trust anything in user space

2238
01:24:49,280 --> 01:24:52,080
and also the desire to have simple and

2239
01:24:52,080 --> 01:24:54,960
very fast hardware mechanisms so really

2240
01:24:54,960 --> 01:24:56,320
xp6 doesn't care that much about

2241
01:24:56,320 --> 01:24:57,920
performance but in general operating

2242
01:24:57,920 --> 01:24:59,600
system designers and the

2243
01:24:59,600 --> 01:25:02,639
cpu designers are very interested in the

2244
01:25:02,639 --> 01:25:04,880
sort of speed at which you can do the

2245
01:25:04,880 --> 01:25:08,000
efficiency of traps

2246
01:25:08,000 --> 01:25:09,840
xp6 does it you know does all these

2247
01:25:09,840 --> 01:25:11,280
things in a particular way there's

2248
01:25:11,280 --> 01:25:13,760
certainly other ways to do them a few

2249
01:25:13,760 --> 01:25:14,400
questions

2250
01:25:14,400 --> 01:25:16,560
a few design questions alternatives you

2251
01:25:16,560 --> 01:25:18,960
could think about

2252
01:25:18,960 --> 01:25:21,040
one is is can you think of ways to make

2253
01:25:21,040 --> 01:25:22,000
the

2254
01:25:22,000 --> 01:25:24,800
hardware or software aspects redesign

2255
01:25:24,800 --> 01:25:26,719
xv6 redesigned the risk five

2256
01:25:26,719 --> 01:25:29,679
to make this whole sequence simpler um

2257
01:25:29,679 --> 01:25:31,360
or could you think of ways to make the

2258
01:25:31,360 --> 01:25:32,320
whole sequence

2259
01:25:32,320 --> 01:25:34,560
faster and another sort of set of

2260
01:25:34,560 --> 01:25:37,840
questions to keep in the back your head

2261
01:25:37,840 --> 01:25:41,120
is whether or not malicious programs

2262
01:25:41,120 --> 01:25:43,040
could abuse any of these mechanisms

2263
01:25:43,040 --> 01:25:48,000
to break isolation

2264
01:25:48,000 --> 01:25:50,000
all right that is all i have to say for

2265
01:25:50,000 --> 01:25:51,280
this lecture i'm

2266
01:25:51,280 --> 01:25:54,639
happy to take questions

2267
01:25:54,639 --> 01:25:56,719
uh sorry i have another question please

2268
01:25:56,719 --> 01:25:58,400
um i saw that there is

2269
01:25:58,400 --> 01:26:01,760
a um u i e regis

2270
01:26:01,760 --> 01:26:05,199
or yeah i think register in status

2271
01:26:05,199 --> 01:26:08,320
but we don't use it we just use

2272
01:26:08,320 --> 01:26:11,040
s i e and we set it to false in user

2273
01:26:11,040 --> 01:26:13,040
space why couldn't we use

2274
01:26:13,040 --> 01:26:17,120
the ui gosh

2275
01:26:17,120 --> 01:26:21,590
the answer is going to be i don't know

2276
01:26:21,600 --> 01:26:22,020
um

2277
01:26:22,020 --> 01:26:24,719
[Music]

2278
01:26:24,719 --> 01:26:27,920
uh we're sp what we set is s what we

2279
01:26:27,920 --> 01:26:28,400
said is

2280
01:26:28,400 --> 01:26:33,760
spi we may actually end up setting

2281
01:26:33,760 --> 01:26:36,480
um i know nothing about uie i'm going to

2282
01:26:36,480 --> 01:26:37,520
guess

2283
01:26:37,520 --> 01:26:39,600
let me see i'm going to guess that what

2284
01:26:39,600 --> 01:26:42,480
actually happens here

2285
01:26:42,480 --> 01:26:48,310
i'm in this code where we're

2286
01:26:48,320 --> 01:26:51,280
okay so here we are in user trap red

2287
01:26:51,280 --> 01:26:53,239
we're returning or setting

2288
01:26:53,239 --> 01:26:56,159
s-p-i-e in the s-status

2289
01:26:56,159 --> 01:27:00,080
and i believe the s-red instruction will

2290
01:27:00,080 --> 01:27:04,000
copy this s-p-i-e and this is this

2291
01:27:04,000 --> 01:27:05,520
previous the name of this is the

2292
01:27:05,520 --> 01:27:08,320
supervisor previous interrupt enable

2293
01:27:08,320 --> 01:27:11,360
i suspect s copies that bit

2294
01:27:11,360 --> 01:27:15,030
into the uh

2295
01:27:15,040 --> 01:27:16,800
into whatever controls interrupts in

2296
01:27:16,800 --> 01:27:20,159
user mode which is possibly this ui

2297
01:27:20,159 --> 01:27:24,480
and s status how's that for a guess

2298
01:27:24,480 --> 01:27:31,840
i see thank you

