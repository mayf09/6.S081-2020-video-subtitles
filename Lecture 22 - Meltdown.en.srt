1
00:00:00,950 --> 00:00:03,580
Alright, anyone hear me.

2
00:00:04,210 --> 00:00:05,980
Good.

3
00:00:07,480 --> 00:00:08,890
Alright today we got meltdown,

4
00:00:09,370 --> 00:00:13,210
the reason why I'm reading this paper is that

5
00:00:13,690 --> 00:00:21,880
security has kind of been a topic all along and comes up a lot in the design of the kernels

6
00:00:21,940 --> 00:00:23,530
that we talked about in the class

7
00:00:24,400 --> 00:00:27,820
and as we know the main strategy, we've talked about for,

8
00:00:28,330 --> 00:00:32,320
what it means for a kernel to provide security is isolation,

9
00:00:33,460 --> 00:00:36,280
in the sense that user programs can read data from the kernel

10
00:00:36,280 --> 00:00:40,780
and user programs can't read other user's data from other user programs

11
00:00:41,500 --> 00:00:48,740
and the specific techniques that you know we've seen operating systems used in order to get isolation

12
00:00:48,740 --> 00:00:51,620
or things like the user supervisor mode in the hardware

13
00:00:51,770 --> 00:00:53,870
and the page tables in the hardware

14
00:00:54,650 --> 00:00:59,090
as well as just sort of well designed kernel software,

15
00:00:59,090 --> 00:01:05,720
like the system calls are all defensive about how they use user supplied pointers.

16
00:01:07,460 --> 00:01:13,220
But it's worth thinking about, looking at examples of how this kind of stuff goes wrong,

17
00:01:13,250 --> 00:01:16,910
I mean in fact you know kernels try hard to provide isolation and security,

18
00:01:16,910 --> 00:01:19,400
but there are problems that come up,

19
00:01:19,550 --> 00:01:24,980
and this paper is a one of the most interesting problems,

20
00:01:24,980 --> 00:01:28,160
that's come up with operating system security in recent times.

21
00:01:28,520 --> 00:01:35,090
Meltdown is came out it, was published at the beginning of 2018 so not too long ago

22
00:01:35,810 --> 00:01:38,390
and a lot of people like me found it surprising

23
00:01:38,390 --> 00:01:43,570
and actually pretty disturbing, pretty disturbing attack on user kernel isolation.

24
00:01:46,020 --> 00:01:50,910
It really undermined faith or sort of this very basic assumption

25
00:01:50,910 --> 00:01:55,710
that the page tables that the hardware supplies, just get you isolation

26
00:01:55,710 --> 00:01:57,150
and that's the end of the story

27
00:01:57,390 --> 00:02:01,380
and this attack does not support that view at all,

28
00:02:01,830 --> 00:02:08,730
further it was an example of, one of a number of recent examples of what's called a micro architectural attack,

29
00:02:08,760 --> 00:02:17,550
an attack that involves exploitation of hidden implementation details inside the CPU,

30
00:02:17,580 --> 00:02:22,770
that are often not even known how this how CPU's work,

31
00:02:22,860 --> 00:02:32,460
but people guess and they're able to make successful attacks based on correct guesses about hidden details of CPU implementation.

32
00:02:34,060 --> 00:02:39,250
Meltdown turns out to be fixable and seems to be pretty completely fixed,

33
00:02:39,640 --> 00:02:43,450
but nevertheless people it sort of set people up to fear,

34
00:02:43,630 --> 00:02:49,450
that there might be an open-ended supply of similar micro architectural attacks.

35
00:02:49,920 --> 00:02:55,740
So it's a pretty important recent event worth understanding.

36
00:02:56,520 --> 00:03:06,320
Let me start by just laying out the basic core of the attack,

37
00:03:06,410 --> 00:03:08,450
and we'll talk about what's going on here,

38
00:03:08,450 --> 00:03:14,110
but this is somewhat simplified version of the code in the paper for how the attack works,

39
00:03:14,410 --> 00:03:16,840
the basic idea is that you're an attacker

40
00:03:16,990 --> 00:03:22,690
and for one reason or another you're able to run software on some computer

41
00:03:22,690 --> 00:03:24,910
that has some secrets that you'd like to steal,

42
00:03:24,940 --> 00:03:26,950
you're not allowed to directly get up the secrets,

43
00:03:26,950 --> 00:03:30,070
but they're in memory, maybe kernel memory or another processes memory,

44
00:03:30,130 --> 00:03:32,410
but you've been able to run a process,

45
00:03:32,410 --> 00:03:36,310
maybe because you logged into a time sharing machine like Athena machine,

46
00:03:36,310 --> 00:03:40,210
or maybe because you bought time on some hosting service.

47
00:03:40,900 --> 00:03:49,330
So what the attack allows you to do is run a program in which you declare a buffer in your own memory,

48
00:03:49,330 --> 00:03:53,920
so this buf is a just ordinary user memory, that's accessible,

49
00:03:54,670 --> 00:03:59,740
you have the virtual address in the kernel of something that you're interested in stealing.

50
00:04:02,590 --> 00:04:09,310
And you issue, what I'm writing out here is sort of you know mix of C and assembler,

51
00:04:09,310 --> 00:04:11,170
but what I mean in line 3 is that,

52
00:04:11,290 --> 00:04:15,550
you have the address of the kernel virtual address of the data you want to steal

53
00:04:15,550 --> 00:04:18,790
and register one and r1 and line 3 were,

54
00:04:19,270 --> 00:04:27,310
or just imagine that this is instructions to dereference register one and load its results into register two,

55
00:04:27,760 --> 00:04:29,680
that's the instruction that we're going to run

56
00:04:30,100 --> 00:04:37,120
and then there's an instruction that, just gets the low bit of register two,

57
00:04:37,120 --> 00:04:42,340
so this attack, this particular version of this attack reads just a single bit,

58
00:04:42,340 --> 00:04:46,600
just one low bit of a one memory location from the kernel,

59
00:04:47,200 --> 00:04:49,720
multiply that four thousand 4096

60
00:04:49,720 --> 00:04:54,580
and since it's either zero or one, that means that r2 will end up being zero or 4096

61
00:04:54,580 --> 00:04:59,810
and then we simply read the contents of our buffer, which is a buffer user memory,

62
00:04:59,870 --> 00:05:04,490
we simply read either buffer zero or buffer 4096,

63
00:05:06,200 --> 00:05:07,430
and that's the basic attack.

64
00:05:11,640 --> 00:05:15,510
So, one question is, why doesn't this just directly work,

65
00:05:15,600 --> 00:05:18,660
line three reading this kernel address,

66
00:05:19,540 --> 00:05:21,520
can we just read addresses from the kernel.

67
00:05:25,620 --> 00:05:29,220
No, no, we all have faith that the answer can't possibly be yes,

68
00:05:29,220 --> 00:05:32,970
we can't possibly be able to just directly read from the kernel for in user space

69
00:05:33,150 --> 00:05:39,510
and the machinery that we know the CPU somehow is invoking to make this not work out

70
00:05:39,630 --> 00:05:46,830
is that when we use kernel virtual address, that implies a lookup in the page table,

71
00:05:47,240 --> 00:05:49,010
and there's permission bits in the page table

72
00:05:49,100 --> 00:05:56,690
and we're just assuming that the operating system has not set the flag in the page table entries for kernel virtual addresses,

73
00:05:56,690 --> 00:06:01,750
has not set that flag that allows users to use those addresses,

74
00:06:01,750 --> 00:06:04,570
that's the PTE_U flag on the RISC-V

75
00:06:04,870 --> 00:06:08,590
and that therefore this instruction must fail, must cause a page fault.

76
00:06:09,220 --> 00:06:12,370
And indeed, if we ran this code, this instruction would cause a page fault,

77
00:06:12,550 --> 00:06:16,870
and if we tried to if we added a code after this,

78
00:06:16,870 --> 00:06:21,950
to say print the value in register three, we get a page fault on line three,

79
00:06:21,950 --> 00:06:23,480
and we never get to the print statement

80
00:06:23,720 --> 00:06:26,870
and we find we couldn't directly steal data out of the kernel.

81
00:06:30,920 --> 00:06:34,820
Nevertheless, the sequence turned out to be useful as the paper shows.

82
00:06:36,380 --> 00:06:45,660
One thing that, one thing that the paper assumes which is no longer really true for the most part is that

83
00:06:45,750 --> 00:06:51,840
the kernel is mapped into every user processes address space,

84
00:06:52,240 --> 00:07:00,250
that is a user user codes running a full set of kernel PTE is present in the page table,

85
00:07:00,280 --> 00:07:02,890
but they have the PTE_U bit clear,

86
00:07:03,130 --> 00:07:09,700
so user code will get a fault, if it tries to use a kernel virtual address,

87
00:07:09,940 --> 00:07:16,300
so all those mappings in, at the time this paper was written, all those mappings were there, when executing in user space,

88
00:07:16,450 --> 00:07:20,070
they just couldn't be used by user code

89
00:07:20,100 --> 00:07:22,560
or they cause a fault, they were used by user code,

90
00:07:22,560 --> 00:07:31,200
and the reason why people by operating system designers mapped both kernel and user addresses when running user code is

91
00:07:31,200 --> 00:07:33,690
that made system calls quite a bit faster,

92
00:07:33,930 --> 00:07:38,040
because that meant that on a system call happened, you don't have to switch page tables

93
00:07:38,040 --> 00:07:44,760
and switching page tables just usually takes time itself and also typically causes CPU caches to be flushed,

94
00:07:44,820 --> 00:07:46,650
which makes subsequent codes slower.

95
00:07:48,160 --> 00:07:53,020
So people got a boost by mapping both user and kernel mappings always in user space.

96
00:07:55,370 --> 00:07:58,460
But this attack actually, and this attack relies on that habit.

97
00:08:00,040 --> 00:08:05,440
Okay, I'm going to explain what's going on here, that makes this code useful,

98
00:08:05,440 --> 00:08:12,600
but before I do that, any any questions about, any questions about this, this code fragment.

99
00:08:15,280 --> 00:08:22,330
I was actually wondering if you could repeat what you just said about kernel to user mapping, and don't really register.

100
00:08:22,630 --> 00:08:24,370
Okay, let's see,

101
00:08:28,560 --> 00:08:30,150
you know how in xv6,

102
00:08:30,180 --> 00:08:33,480
when you're executing when the process is executing in user space,

103
00:08:33,540 --> 00:08:38,580
if you look at the page table, that page table has mapping for the user addresses,

104
00:08:38,970 --> 00:08:43,480
and for like the trampoline page and the trapframe page and nothing else,

105
00:08:44,160 --> 00:08:45,630
so that's how xv6 works.

106
00:08:46,110 --> 00:08:51,810
The page table that this paper assumes we're different from that,

107
00:08:52,380 --> 00:08:55,020
this, in the time this paper was written,

108
00:08:55,200 --> 00:09:05,200
most operating systems would have a set complete set of kernel mappings in the page table

109
00:09:06,100 --> 00:09:08,140
while user code was running,

110
00:09:09,930 --> 00:09:14,580
and so all those page table entries would be there,

111
00:09:14,580 --> 00:09:17,910
all the kernel page table entries would be there when user code is running,

112
00:09:17,910 --> 00:09:22,320
but since the PTE_U bit was clear on each of those page table entries,

113
00:09:22,320 --> 00:09:25,530
user code wouldn't actually be able to use a kernel virtual address,

114
00:09:25,710 --> 00:09:27,150
but the mappings were there

115
00:09:27,300 --> 00:09:29,760
and the reason for that is that when you do a system call,

116
00:09:29,880 --> 00:09:32,760
you didn't have to switch page tables,

117
00:09:33,060 --> 00:09:35,850
because you do a system call into the kernel

118
00:09:35,850 --> 00:09:37,620
and boom you're using the same page table,

119
00:09:37,620 --> 00:09:42,150
but now you can use all those kernel PTEs, because you're in supervisor mode

120
00:09:42,180 --> 00:09:46,440
and that saved a bunch of time getting into and out of the kernel during system calls.

121
00:09:47,230 --> 00:09:49,360
Everybody, everybody used that technique

122
00:09:49,390 --> 00:09:52,630
and that was almost certainly what Intel had in mind,

123
00:09:52,630 --> 00:09:54,920
for how you should write an operating system.

124
00:09:55,840 --> 00:10:01,300
Okay, so that for the whole paper that structure is assumed for the attack,

125
00:10:01,480 --> 00:10:06,130
of course getting rid of it is what's the most immediate solution to this problem,

126
00:10:07,150 --> 00:10:11,620
at the time, the paper was written all those kernel mappings were present in user space.

127
00:10:13,760 --> 00:10:14,630
Other questions?

128
00:10:16,860 --> 00:10:20,850
So you need to know the address and you want to get.

129
00:10:21,090 --> 00:10:25,980
Yeah, that's right, it is and.

130
00:10:28,790 --> 00:10:30,080
So you know that's a good point,

131
00:10:30,080 --> 00:10:34,820
you need to know the kernel virtual address and that's actually maybe no joke.

132
00:10:37,560 --> 00:10:41,370
Yeah, you might think that would make the attack harder.

133
00:10:44,600 --> 00:10:49,000
But first of all point of philosophy in security,

134
00:10:49,000 --> 00:10:53,020
you just have to assume that the attacker has infinite time and patience.

135
00:10:53,510 --> 00:10:55,220
And if there after some valuable secrets,

136
00:10:55,520 --> 00:10:59,990
they are probably willing to spend a couple of months trying to steal that secret,

137
00:11:00,590 --> 00:11:02,480
or longer right,

138
00:11:02,870 --> 00:11:04,640
because you know it's gonna be somebody's password,

139
00:11:04,640 --> 00:11:08,990
that protects all kinds of valuable stuff, maybe money or secret email.

140
00:11:09,640 --> 00:11:16,820
So that means for example the attacker probably has time to try every single kernel address, right,

141
00:11:16,850 --> 00:11:19,550
looking for whatever precious data there after,

142
00:11:19,640 --> 00:11:20,660
maybe a password,

143
00:11:20,870 --> 00:11:24,950
or the attacker may have time to study to look through the kernel code

144
00:11:24,950 --> 00:11:28,640
and look through typical compiled kernels and find addresses

145
00:11:28,640 --> 00:11:33,770
and maybe put print statements in their kernels to examine the structure of data in kernel memory,

146
00:11:33,770 --> 00:11:39,950
until they understand how the kernel works, well enough to be able to get an address here.

147
00:11:40,100 --> 00:11:45,610
Now, actually, because this game has been going on, other versions of this game,

148
00:11:46,000 --> 00:11:48,070
the security game had been going out for a long time,

149
00:11:48,130 --> 00:11:55,800
kernels actually defend themselves against attacks that involve guessing kernel addresses

150
00:11:55,920 --> 00:11:59,490
and one of the things that was actually mentioned this paper is

151
00:11:59,490 --> 00:12:06,360
this called thing called kernel address space layout randomization,

152
00:12:06,360 --> 00:12:09,720
so modern kernels actually load the kernel at a random address,

153
00:12:10,140 --> 00:12:15,970
in order to make it harder to guess kernel virtual addresses

154
00:12:15,970 --> 00:12:19,150
and they did this before this, long before this paper came out,

155
00:12:19,420 --> 00:12:22,180
because it was helpful in defeating other attacks.

156
00:12:22,700 --> 00:12:24,890
So, so this is the game,

157
00:12:24,890 --> 00:12:33,260
but we have to assume that the attacker, in the end, the attacker will probably win this game.

158
00:12:34,640 --> 00:12:39,680
Okay, so let's just assume the attacker either knows a juicy kernel virtual address

159
00:12:39,680 --> 00:12:43,850
to look at or can guess one or is willing to exhaustively try every address.

160
00:12:44,280 --> 00:12:49,290
And the paper suggests that that's a plausible strategy, once you have meltdown.

161
00:12:51,810 --> 00:12:52,470
Okay.

162
00:12:53,930 --> 00:12:55,340
Okay, so what's gonna happen,

163
00:12:55,460 --> 00:13:01,300
well, so we're wondering how can this code be, possibly be useful to an attacker

164
00:13:01,360 --> 00:13:03,340
and the answer has to do,

165
00:13:03,430 --> 00:13:08,740
like if the way CPU's work was just what you read in the CPU manual,

166
00:13:08,830 --> 00:13:13,390
this attack clearly is nonsense, like it'll fault at instruction three

167
00:13:13,420 --> 00:13:14,440
and that'll be the end of it,

168
00:13:14,590 --> 00:13:20,340
but it turns out CPU's work in far more complex ways than is in the manual,

169
00:13:20,490 --> 00:13:28,800
and the way the reason the attack works is because of some CPU implementation details.

170
00:13:30,350 --> 00:13:33,410
And there's actually two main things that the attack relies on,

171
00:13:33,410 --> 00:13:39,440
one is implementation trick of CPU's called speculative execution, which I'll talk about first

172
00:13:39,620 --> 00:13:45,620
and the other implementation trick, the attack relies on is the way CPU's do caching.

173
00:13:48,330 --> 00:13:49,050
Okay.

174
00:13:49,620 --> 00:13:51,300
So first speculative execution,

175
00:13:52,920 --> 00:13:56,700
let me, I have a code example for that also,

176
00:13:57,120 --> 00:14:00,390
and for the moment I'm not talking about security at all,

177
00:14:01,220 --> 00:14:07,520
the specular execution and stuff is just a technique to improve the performance of a CPU's,

178
00:14:08,300 --> 00:14:10,670
some optimization trick that CPU's use,

179
00:14:11,210 --> 00:14:17,050
so imagine that we're just, we have, which is running this code,

180
00:14:17,320 --> 00:14:19,360
this is somewhat contrived example,

181
00:14:19,360 --> 00:14:23,920
but it's sort of illustrates what speculative execution is all about,

182
00:14:25,120 --> 00:14:29,200
supposing I have address in some say register zero

183
00:14:29,320 --> 00:14:33,640
and just because the logic my program, the address is either valid or not valid,

184
00:14:33,640 --> 00:14:39,920
maybe it contains zero if under some circumstances, like we haven't initialize my data yet.

185
00:14:39,950 --> 00:14:44,180
So this will assume there's a valid variable that's sitting in memory somewhere,

186
00:14:44,660 --> 00:14:50,780
so before using the address here, so this address in register zero here on line four,

187
00:14:50,780 --> 00:14:53,090
we're going to test, we're gonna load valid from memory

188
00:14:53,090 --> 00:14:57,080
and we're only going to use the address if valid is set to one,

189
00:14:57,500 --> 00:15:00,410
then a valid is set to zero which is not going to see address at all,

190
00:15:00,620 --> 00:15:03,830
and if valid is set to one, then we're going to de reference the address,

191
00:15:03,890 --> 00:15:06,380
you know load the data points to at register two

192
00:15:06,530 --> 00:15:08,570
and add one to it and it doesn't really matter,

193
00:15:08,600 --> 00:15:10,460
we're going to do something with that data we loaded,

194
00:15:10,610 --> 00:15:16,800
in this case, add one to it and set register three equal to the data plus one.

195
00:15:17,800 --> 00:15:23,010
Alright, well, in a simple CPU implementation,

196
00:15:24,370 --> 00:15:27,780
at line two here, you can load,

197
00:15:28,380 --> 00:15:30,990
now it's a variable sitting in memory in RAM

198
00:15:32,070 --> 00:15:34,740
and you have to issue some kind of this is going to be,

199
00:15:34,740 --> 00:15:38,550
line two is going to be some sort of load instruction that reads valid out of RAM,

200
00:15:39,330 --> 00:15:41,790
all else being equal if we actually have to load it from RAM,

201
00:15:42,500 --> 00:15:47,660
that'll take hundreds of cycles on our say two Giga Hertz machine,

202
00:15:48,370 --> 00:15:52,240
like any load that actually has to go to RAM will take hundreds of cycles,

203
00:15:52,300 --> 00:15:57,250
the machine can execute an instruction, up to an instruction every cycle,

204
00:15:57,250 --> 00:16:01,240
so if we actually had to wait a couple of hundred cycles here,

205
00:16:01,480 --> 00:16:06,820
we'd be the machine to be sitting there idling for hundreds hundreds of cycles, are wasting its time.

206
00:16:07,440 --> 00:16:11,880
And because that's a significant significant slowdown right,

207
00:16:12,060 --> 00:16:17,430
if everything went well, we'd be able to execute an instruction every cycle, instead of every couple hundred cycles,

208
00:16:20,000 --> 00:16:24,530
all modern, all serious modern CPUs do use something called branch prediction,

209
00:16:24,620 --> 00:16:26,780
so this if statement is a branch,

210
00:16:27,530 --> 00:16:29,690
if we actually turned it into machine instructions,

211
00:16:29,690 --> 00:16:31,100
we see there was a branch here

212
00:16:31,280 --> 00:16:36,920
and it's a conditional branch, branch based on this test whether register one is equal to one

213
00:16:37,220 --> 00:16:39,080
and what CPU's do is they use,

214
00:16:39,620 --> 00:16:41,240
it's called branch branch prediction,

215
00:16:41,660 --> 00:16:51,290
that is for every branch more or less the CPU essentially remembers a cache of information about each of the branches in your program,

216
00:16:51,350 --> 00:16:53,600
or at least each recently executed branch,

217
00:16:53,810 --> 00:16:57,380
then remembers oh did that branch was the branch taken or not taken,

218
00:16:58,010 --> 00:17:03,660
and if the CPU doesn't have enough information to predict,

219
00:17:03,720 --> 00:17:06,390
so that's prediction based on the last time you executed the branch,

220
00:17:06,600 --> 00:17:13,640
even if the CPU doesn't have a prediction, it may still just go ahead and execute the instructions,

221
00:17:14,630 --> 00:17:18,230
either that the branch takes you to or the fall through instructions,

222
00:17:18,260 --> 00:17:20,300
assuming the branch wasn't taken, that is.

223
00:17:21,240 --> 00:17:25,530
Even before the CPU knows whether this conditional is true,

224
00:17:25,890 --> 00:17:30,300
it'll choose one way or the other and start executing down that path,

225
00:17:30,480 --> 00:17:33,680
even though it might be the wrong path, doesn't know yet.

226
00:17:34,320 --> 00:17:35,400
And so in this case,

227
00:17:35,580 --> 00:17:37,380
maybe before this load completes,

228
00:17:37,380 --> 00:17:39,780
and before or the value of valid is known,

229
00:17:40,020 --> 00:17:43,800
the CPU may start executing instruction four

230
00:17:44,250 --> 00:17:47,790
and do the load with whatever value is sitting in r0

231
00:17:47,880 --> 00:17:49,680
which may or may not be a valid pointer

232
00:17:50,100 --> 00:17:56,220
and once that load yields something, maybe even add one to it and set register three equal to that value.

233
00:17:56,840 --> 00:17:59,030
And then maybe a long time later,

234
00:17:59,030 --> 00:18:02,360
when this load at line two finally completes,

235
00:18:02,750 --> 00:18:06,320
now we know what the value of valid is,

236
00:18:06,590 --> 00:18:08,990
the CPU will then this real,

237
00:18:09,020 --> 00:18:16,310
you know you know it kept track of the fact that it executed lines four and five without really knowing whether that was proper,

238
00:18:17,060 --> 00:18:20,270
if valid is one then that's fine, it just keeps going,

239
00:18:20,300 --> 00:18:28,700
if valid is zero, then the CPU has enough cleverness to cancel the effects of its execution of line four and five

240
00:18:28,760 --> 00:18:33,140
and restart execution in the proper place after the branch at line seven.

241
00:18:34,260 --> 00:18:40,440
And this execution of code before you know whether you really should be executing it is called speculation,

242
00:18:46,700 --> 00:18:48,920
and again, the point is performance,

243
00:18:48,920 --> 00:18:54,540
if the CPU guess is right, then it got a big head start executing these instructions

244
00:18:54,540 --> 00:18:57,960
and didn't have to wait for the expensive memory load.

245
00:19:00,660 --> 00:19:02,220
Any questions about what this means?

246
00:19:08,940 --> 00:19:19,250
Okay, this machinery, the hardware, the transistors in the CPU for speculation are extremely complex,

247
00:19:19,610 --> 00:19:22,970
there's a huge amount going on in the CPU to make this work,

248
00:19:23,440 --> 00:19:25,000
none of which is published,

249
00:19:25,540 --> 00:19:31,970
right, it's a whole Intel internal stuff, not in, not in the machine manual.

250
00:19:32,550 --> 00:19:38,520
So surrounding meltdown and attacks like it is a huge amount of speculation

251
00:19:38,520 --> 00:19:41,400
about what's probably going on inside the CPU

252
00:19:41,400 --> 00:19:44,220
in order to make such attack work or not work.

253
00:19:45,090 --> 00:19:48,460
Okay, back to speculation though.

254
00:19:55,210 --> 00:19:57,160
One thing that's going on is that,

255
00:19:57,400 --> 00:20:05,460
in order to undo speculative failed specular mis mis predicted speculative execution,

256
00:20:05,670 --> 00:20:09,900
the machine had keeps shadow versions of registers essentially,

257
00:20:10,200 --> 00:20:12,690
you know it assigned to registers two, register three,

258
00:20:12,690 --> 00:20:15,900
but it's a sign it's kind of a temporary registers,

259
00:20:16,560 --> 00:20:23,010
if speculation succeeds then those registers those shadow registers become the real registers,

260
00:20:23,040 --> 00:20:28,380
if it fails then those shadow registers discarded the CPU discards the shadow registers.

261
00:20:28,710 --> 00:20:32,660
So these two assignments r2 and r3 would just be as if they never happened.

262
00:20:37,310 --> 00:20:45,920
So in this code, we need to think about what happens if register zero is a valid pointer

263
00:20:45,920 --> 00:20:49,270
and what happens if it's not a valid pointer, right.

264
00:20:49,300 --> 00:20:56,560
If we're speculatively executing line four, and register two is a valid pointer,

265
00:20:56,560 --> 00:21:00,010
then it turns out the CPU will actually do the load,

266
00:21:00,700 --> 00:21:04,900
and loaded into at least the transient version of register two,

267
00:21:04,900 --> 00:21:10,650
so we'll actually go out and and try to fetch what r0 points to

268
00:21:10,650 --> 00:21:17,040
and that will certainly work if the data r0 is pointed to, is sitting in the cache

269
00:21:17,130 --> 00:21:22,050
and I don't know if if the CPU will do the load,

270
00:21:22,080 --> 00:21:25,230
if it misses in the cache and has to load from RAM, it might.

271
00:21:27,880 --> 00:21:29,680
But, maybe the more interesting question for us,

272
00:21:29,680 --> 00:21:32,920
for this attack is what happens if register zero is not a valid pointer.

273
00:21:36,140 --> 00:21:40,010
In that case, if we're speculatively executing here,

274
00:21:40,980 --> 00:21:45,210
the machine can't fault at this point,

275
00:21:45,210 --> 00:21:48,000
because we're speculatively executing machine doesn't know,

276
00:21:48,030 --> 00:21:50,430
it may know that r0 was an invalid,

277
00:21:50,880 --> 00:21:56,490
that this speculatively executed instruction tried to use an invalid pointer, an invalid address,

278
00:21:56,490 --> 00:21:58,020
but it can't page fault,

279
00:21:58,110 --> 00:22:07,230
because it's not sure whether this execution is valve is correct speculative execution or mis mis speculation

280
00:22:07,230 --> 00:22:08,820
and so it's only,

281
00:22:09,120 --> 00:22:17,680
so, so it can't actually raise a fault on line four until after valid value of valid is known,

282
00:22:17,680 --> 00:22:23,770
and after this branch, this speculative predicted branch,

283
00:22:23,800 --> 00:22:28,120
after we know after the machine knows what the condition is,

284
00:22:28,510 --> 00:22:34,900
if the machine see if the machine's that line four sees oh register zero is an invalid address,

285
00:22:35,580 --> 00:22:38,100
and then valid turns out to be one,

286
00:22:38,370 --> 00:22:42,300
then, and only then does the machine actually generate the page fault,

287
00:22:42,570 --> 00:22:46,740
if r0 is an invalid address, then valid turns out to be zero,

288
00:22:46,770 --> 00:22:50,030
the machine does not generate a page fault.

289
00:22:50,960 --> 00:22:59,150
So the, the decision about whether to fault is deferred possibly for hundreds of cycles until the value of valid is known,

290
00:22:59,420 --> 00:23:03,110
then the technical term for the point at which we know

291
00:23:03,110 --> 00:23:13,040
whether an instruction was correctly speculatively executed rather than being thrown away is called Retirement.

292
00:23:15,600 --> 00:23:21,020
So we say an instruction is speculative and at some point it's retired

293
00:23:21,020 --> 00:23:25,450
and that's when we know it's either going to be thrown away or what's real

294
00:23:25,450 --> 00:23:29,530
and should be its effect should be committed to the visible state of the machine

295
00:23:29,800 --> 00:23:31,090
and the rule is that,

296
00:23:33,220 --> 00:23:40,990
instruction can only be retired, if first of all is finished executing loading memory, you're adding one to something,

297
00:23:40,990 --> 00:23:45,670
and every instruction before it, was executed before it has also retired,

298
00:23:46,090 --> 00:23:54,890
so this line four can't be retired until the load of valid completes and the conditions is evaluated,

299
00:23:54,890 --> 00:23:56,000
only then can be retired,

300
00:23:56,270 --> 00:24:03,260
so it's going to fault, it may it's gonna fault, possibly hundreds of instructions after it is the memory load,

301
00:24:05,370 --> 00:24:06,990
or tempted to do the memory load.

302
00:24:11,630 --> 00:24:14,240
And as a critical detail for this attack,

303
00:24:16,690 --> 00:24:19,060
there's an even more.

304
00:24:19,870 --> 00:24:27,350
If lets its, if the address in r0 is invalid and has no mapping in the page table at all,

305
00:24:27,530 --> 00:24:30,230
then actually don't know what happens.

306
00:24:32,850 --> 00:24:37,380
If the address in r0 has a page table mapping,

307
00:24:37,410 --> 00:24:41,940
but there's no permission for it, that is the PTE_U flag is not set,

308
00:24:42,120 --> 00:24:45,360
then what Intel machines actually do is,

309
00:24:45,390 --> 00:24:50,640
load that data and assign it into the transient register two,

310
00:24:51,840 --> 00:24:57,180
and where it can be used by the speculative execution of line five,

311
00:24:57,330 --> 00:25:01,320
so even if r0 was was an address for which we don't have permission,

312
00:25:01,320 --> 00:25:02,610
because it's a kernel address,

313
00:25:02,820 --> 00:25:06,930
we'll still see it's value loaded into r3 and its value plus one,

314
00:25:06,990 --> 00:25:10,320
sorry, we won't see it, but it will be loaded into r2

315
00:25:10,680 --> 00:25:12,630
and that plus one at r3

316
00:25:12,780 --> 00:25:16,050
and then when this load is retired,

317
00:25:16,290 --> 00:25:20,340
the machine will realize aha, that was an invalid load,

318
00:25:20,370 --> 00:25:22,620
because the page table entry didn't allow it

319
00:25:23,040 --> 00:25:24,690
and so we're going to raise a fault

320
00:25:24,690 --> 00:25:28,650
and cancel the execution of the subsequent instructions

321
00:25:28,650 --> 00:25:35,170
and cancel the effects of this instruction, undo the modification to r2 and r3.

322
00:25:35,380 --> 00:25:41,460
So in this example, there's two speculations going on,

323
00:25:41,490 --> 00:25:46,950
one is we're speculating about where this branch, machines speculating about where this branch went

324
00:25:47,400 --> 00:25:49,560
and just saying oh it went one way or the other,

325
00:25:49,560 --> 00:25:51,390
just gonna give that a shot speculatively,

326
00:25:51,990 --> 00:25:55,380
in addition there's speculative execution after each load

327
00:25:55,380 --> 00:25:59,580
were essentially speculating about whether the machine is speculating,

328
00:26:00,170 --> 00:26:03,560
about whether that load complete successfully.

329
00:26:03,920 --> 00:26:10,010
And in the case of a load, Intel machines always just go on, you know if data could be provided,

330
00:26:11,110 --> 00:26:12,130
because it's in the cache

331
00:26:12,130 --> 00:26:14,920
and at least the page table entry exists, permissions are not,

332
00:26:15,220 --> 00:26:18,160
the machine will speculatively continue to execute

333
00:26:18,520 --> 00:26:23,950
and only on retirement, the load will actually generate the fault,

334
00:26:24,040 --> 00:26:26,140
and that will cause the speculation to be cancelled.

335
00:26:28,660 --> 00:26:32,290
Alright, any questions about this stuff?

336
00:26:39,870 --> 00:26:43,230
I'm a little confused about, the second speculation

337
00:26:43,230 --> 00:26:45,630
which is loading r0 into r2,

338
00:26:46,290 --> 00:26:53,610
so, does that mean that like the value of r0 is loaded into r2 and the flags are checked later.

339
00:26:56,900 --> 00:27:01,180
Yes, yes, so what happens, yes, that's exactly right,

340
00:27:01,270 --> 00:27:04,630
so what actually happens is that during the speculative phase,

341
00:27:07,190 --> 00:27:08,930
whatever it is that r0 points to,

342
00:27:09,080 --> 00:27:12,590
if there's sort of if it points to anything,

343
00:27:12,620 --> 00:27:14,060
if r0 points to anything,

344
00:27:14,120 --> 00:27:18,770
then the data that memory location will be loaded into r2,

345
00:27:19,740 --> 00:27:22,590
later, when this load is retired,

346
00:27:24,280 --> 00:27:27,280
and it turned, then the permissions will be checked,

347
00:27:28,560 --> 00:27:30,930
and if we didn't have permission to do that load,

348
00:27:31,610 --> 00:27:35,510
then all subsequent instructions effects will be cancelled,

349
00:27:35,510 --> 00:27:38,270
like all these modifications registered will be undone,

350
00:27:39,180 --> 00:27:41,880
and fault will be raised,

351
00:27:42,180 --> 00:27:47,130
with the state of the machines and registers as they were just before instruction four.

352
00:27:47,250 --> 00:27:49,080
Okay, that's interesting.

353
00:27:49,780 --> 00:27:50,350
Yes.

354
00:27:52,700 --> 00:27:54,110
Yes, I also have a question,

355
00:27:54,350 --> 00:28:02,330
is there no possible way to restrict the CPU from checking permissions before doing a speculative load.

356
00:28:06,380 --> 00:28:12,140
Um, you mean, is there a way to cause the machine to do the check before the load.

357
00:28:13,370 --> 00:28:14,900
Yes, I guess more concrete,

358
00:28:14,900 --> 00:28:17,360
like the only reason this is a problem or,

359
00:28:17,360 --> 00:28:22,340
but one of the ways is that we're just loading a page that,

360
00:28:23,170 --> 00:28:29,020
if we can be aware that it has permissions that are going to be bad somehow,

361
00:28:29,110 --> 00:28:32,980
we're accessing a page that we don't we shouldn't be able to access,

362
00:28:33,310 --> 00:28:36,820
the can the speculative execution be cancelled,

363
00:28:36,820 --> 00:28:38,710
given that we can read these permissions.

364
00:28:40,500 --> 00:28:42,810
Yes, in a, yes that's,

365
00:28:42,810 --> 00:28:46,110
yeah, well, there's two answers,

366
00:28:46,110 --> 00:28:49,680
one is that's not the way the Intel chips CPUs actually worked,

367
00:28:50,700 --> 00:28:53,400
and the other answer is yes, it would have been,

368
00:28:54,300 --> 00:29:00,690
I I believe it would have been easy for them to have done and enforce that check even for speculative loads,

369
00:29:00,690 --> 00:29:04,530
so that even in speculation register two would never have been written.

370
00:29:05,980 --> 00:29:07,540
So maybe.

371
00:29:08,920 --> 00:29:11,080
And indeed, it turns out that

372
00:29:11,080 --> 00:29:17,290
you may know, I've noticed the paper mentioned that the meltdown seems not to work on AMD CPUs,

373
00:29:17,440 --> 00:29:24,030
even though AMD CPUs, the instruction manual is the same as for Intel CPU's,

374
00:29:24,030 --> 00:29:27,780
essentially on the same instruction set and the instructions mean the same things,

375
00:29:27,840 --> 00:29:30,810
the attack doesn't work on AMD CPUs

376
00:29:31,140 --> 00:29:35,190
and it's widely believed that the reason is that AMD CPUs,

377
00:29:36,080 --> 00:29:43,900
you even went speculatively executing, if you don't have permission to read this address,

378
00:29:43,930 --> 00:29:48,160
won't even speculatively loads, the value in r2,

379
00:29:49,470 --> 00:29:52,200
and that's why the attack didn't work on AMD CPUs

380
00:29:52,410 --> 00:29:57,840
and recent Intel CPUs apparently have adopted that approach

381
00:29:57,840 --> 00:30:05,330
and actually won't won't speculatively load, if they don't have permissions.

382
00:30:06,500 --> 00:30:11,290
And as far as I know, there's no particular sacrifice at performance,

383
00:30:11,320 --> 00:30:12,910
I think the information was all there,

384
00:30:13,540 --> 00:30:21,040
but for just I don't know, just say maybe a few [gates], they decided only to apply it on retirement.

385
00:30:23,620 --> 00:30:24,400
Because they seem to.

386
00:30:24,400 --> 00:30:25,510
That's very interesting.

387
00:30:28,400 --> 00:30:31,940
Yeah, I mean let me just warn you this there's a lot of guesswork here

388
00:30:33,050 --> 00:30:35,360
and I believe what I'm saying is true,

389
00:30:35,360 --> 00:30:40,940
but in Intel and AMD have not been very revealing about what's going on.

390
00:30:43,190 --> 00:30:49,130
Okay, thers's some terminology here that's important,

391
00:30:49,250 --> 00:30:53,090
the what you read in the manual for the CPU,

392
00:30:53,090 --> 00:30:56,900
that says oh you know an add structure takes two registers and adds them and puts them in a third,

393
00:30:56,930 --> 00:31:08,830
that stuff, that aspect of the design is called architectural, a sort of advertise, behavior,

394
00:31:10,350 --> 00:31:12,300
the advertised behavior of the machine,

395
00:31:12,690 --> 00:31:14,940
and so the advertised behavior of machine is that

396
00:31:14,940 --> 00:31:18,750
if your load from an address you turn permissions for you get a page fault period, you're not allowed to load,

397
00:31:19,710 --> 00:31:27,270
that's in distinction to what the machines actually doing which is called Micro-Architectural.

398
00:31:29,540 --> 00:31:34,670
That is actually the machine has specular executions doing all these crazy things without telling you

399
00:31:34,820 --> 00:31:43,490
and the intent of the CPU designers when they design all these complex micro-architectural optimizations is that they be transparent,

400
00:31:43,760 --> 00:31:45,710
that yeah yeah it's doing all this stuff internally,

401
00:31:45,710 --> 00:31:51,710
but it looks the results you get from programs are the same results you get from a simpler machine

402
00:31:51,710 --> 00:31:54,710
that just did the straightforward thing that was in the manual.

403
00:31:55,500 --> 00:31:57,210
They are intended to be transparent

404
00:31:57,240 --> 00:32:03,370
and so you know, for example, at some level, what Intel is doing here is transparent,

405
00:32:03,370 --> 00:32:06,970
yeah, maybe they don't check for permissions when you when you do the memory load,

406
00:32:07,180 --> 00:32:09,940
but if there was a problem on retirement,

407
00:32:09,940 --> 00:32:11,560
it's gonna undo all these effects

408
00:32:11,560 --> 00:32:14,410
and so you'll never see that memory you weren't supposed to see,

409
00:32:14,410 --> 00:32:17,890
so gosh that looks just like what the manual said,

410
00:32:17,980 --> 00:32:20,110
you're not allowed to load stuff you don't have permission for.

411
00:32:22,040 --> 00:32:27,730
So this distinction is, a lot of what this attack is playing,

412
00:32:27,730 --> 00:32:32,380
on that it knows all the attack knows a lot about what's going on inside.

413
00:32:35,840 --> 00:32:40,240
Okay, other questions about speculative execution?

414
00:32:47,840 --> 00:32:50,590
Okay, I'm gonna put that aside for a moment

415
00:32:50,590 --> 00:32:53,440
and talk about another piece of micro-architecture,

416
00:32:59,240 --> 00:33:03,410
that's a caches.

417
00:33:06,420 --> 00:33:08,730
And these again, everybody knows caches are there,

418
00:33:08,730 --> 00:33:12,090
but you know they're supposed to be more or less more or less transparent.

419
00:33:16,130 --> 00:33:17,720
And let me draw a picture of the caches,

420
00:33:17,720 --> 00:33:19,490
I think are relevant to the cache structure,

421
00:33:19,490 --> 00:33:21,590
I think is most relevant to meltdown.

422
00:33:21,650 --> 00:33:26,180
So first of all, you have the, we have the core which is the,

423
00:33:27,510 --> 00:33:31,650
you know part of the machine that parses instructions and has registers

424
00:33:31,650 --> 00:33:34,470
and has an addition unit and division unit

425
00:33:34,470 --> 00:33:39,300
and you know whatever the execution part of the machine,

426
00:33:39,300 --> 00:33:44,130
and then, whenever it needs to do a load or store,

427
00:33:45,710 --> 00:33:50,270
it talks to the memory system

428
00:33:51,380 --> 00:33:53,360
and the memory system has a bunch of caches,

429
00:33:53,360 --> 00:34:03,140
so in particular in the machines, we're talking about, there's a data cache called level one data cache,

430
00:34:03,620 --> 00:34:10,590
that is maybe you know 64 kilobytes in size or something not very big,

431
00:34:10,590 --> 00:34:11,940
but it's extremely fast,

432
00:34:12,150 --> 00:34:15,630
if you, if the data you need is in the L1 cache,

433
00:34:15,630 --> 00:34:18,360
that you get back to you in a couple of cycles

434
00:34:18,390 --> 00:34:22,200
and the structure of the L1 cache, it has a bunch of lines are called lines,

435
00:34:22,920 --> 00:34:25,770
each of which holds probably 64 bytes of data,

436
00:34:25,860 --> 00:34:29,520
the lines are indexed, it's a table really the cache,

437
00:34:29,670 --> 00:34:32,910
the lines are indexed by virtual address,

438
00:34:33,600 --> 00:34:36,150
if the virtual addresses in the cache,

439
00:34:36,150 --> 00:34:41,220
then, the cache holds the data with that virtual address

440
00:34:41,370 --> 00:34:43,080
and in addition as it turns out,

441
00:34:43,350 --> 00:34:54,870
it's believed, the L1 cache entry contains a copy of the permissions taken from the page table entry that corresponds to this virtual address.

442
00:34:55,460 --> 00:35:00,210
So, there's a whole, this is it a table,

443
00:35:01,270 --> 00:35:03,100
when the core is used load instruction,

444
00:35:03,460 --> 00:35:07,330
the first thing that happens is that the hardware looks in the L1 cache

445
00:35:07,330 --> 00:35:14,350
and see if there's a cache entry whose virtual address matches the requested,

446
00:35:15,610 --> 00:35:16,870
the address we're trying to load from it,

447
00:35:16,870 --> 00:35:22,030
and if so that we can just the machine just returns this data from the cache were done very quickly,

448
00:35:22,300 --> 00:35:24,190
if they did is not in L1 cache,

449
00:35:24,190 --> 00:35:31,910
then the next step is that we, the rest of the memory system is is in is addressed with physical addresses,

450
00:35:31,910 --> 00:35:33,980
so we at this point, we're going to need a physical address,

451
00:35:33,980 --> 00:35:36,020
if we missed the L1 cache,

452
00:35:36,350 --> 00:35:41,090
this translation look-aside buffer is a cache of page table entries,

453
00:35:41,240 --> 00:35:46,750
it's going to look up the virtual address that the program issued in the translation look aside buffer,

454
00:35:47,470 --> 00:35:49,810
it may not be there in which case now we got a lot of work to do,

455
00:35:49,810 --> 00:35:53,740
because we've got to load the relevant page table entry for memory.

456
00:35:54,290 --> 00:35:56,780
But let's assume we hittin the translation look-aside buffer,

457
00:35:56,900 --> 00:36:00,710
we can now get the needed physical address,

458
00:36:00,890 --> 00:36:04,130
typically there's another cache, another much bigger cache,

459
00:36:04,830 --> 00:36:09,000
that's physically indexed index with the physical address.

460
00:36:10,880 --> 00:36:14,000
And so we might now that we have a physical address, we can look at this cache

461
00:36:14,690 --> 00:36:19,910
and if we miss there, then we have to send the physical address after the RAM system,

462
00:36:20,150 --> 00:36:20,900
takes a long time,

463
00:36:20,900 --> 00:36:24,020
but when we finally get data back then we can populate the L2 cache

464
00:36:24,650 --> 00:36:28,220
and populate the L1 cache with the stuff we got back from RAM

465
00:36:28,400 --> 00:36:31,870
and return the the data back to the core.

466
00:36:36,730 --> 00:36:37,690
So this is caching.

467
00:36:43,060 --> 00:36:49,140
Just, by the, by the hidden L1 cache practice a few cycles,

468
00:36:49,140 --> 00:36:52,470
hidden the L2 cache probably takes a dozen or two cycles

469
00:36:52,620 --> 00:36:56,070
and miss that requires you to go around probably takes you a couple hundred cycles,

470
00:36:56,800 --> 00:37:03,540
these cycles are, you know, let's say half a second on a two Giga Hertz machine.

471
00:37:05,130 --> 00:37:08,100
So it's extremely advantageous to have caching you would,

472
00:37:08,100 --> 00:37:12,630
if you didn't have cache and you would be sacrificing a factor of a couple of hundred in performance,

473
00:37:12,750 --> 00:37:16,950
these are just absolutely critical to decent performance, these caches.

474
00:37:20,000 --> 00:37:26,590
Now, this caches is the L1 cache,

475
00:37:27,140 --> 00:37:30,740
well, both turns out both both these caches can contain,

476
00:37:31,010 --> 00:37:36,110
if we're running in user space, both these caches in the operating system's meltdown was aimed at,

477
00:37:36,320 --> 00:37:39,920
both of these caches can contain both user data and kernel data,

478
00:37:40,700 --> 00:37:42,680
the L2 cache can contain kernel data,

479
00:37:42,680 --> 00:37:49,420
because it's physically addressed, there's no problem.

480
00:37:49,540 --> 00:37:52,360
The L1 cache is a little bit trickier,

481
00:37:52,360 --> 00:37:55,180
it's virtually addressed when we change page tables,

482
00:37:55,390 --> 00:37:57,670
the contents of the L1 cache are no longer valid,

483
00:37:57,670 --> 00:38:01,990
because we change page tables, that means that the meaning of virtual addresses changed,

484
00:38:01,990 --> 00:38:04,750
so you'd have to flush the L1 cache, which change page tables,

485
00:38:04,960 --> 00:38:10,520
although there's more complex tricks that allow you to avoid that,

486
00:38:10,850 --> 00:38:15,140
and so but the fact that these operating systems in the days of this paper,

487
00:38:15,260 --> 00:38:20,000
didn't change page tables, when changing between user space and kernel space, because both were mapped,

488
00:38:20,150 --> 00:38:24,470
meant that, data we didn't have to flush the L1 cache

489
00:38:24,710 --> 00:38:28,010
and that meant the L1 cache would have both user and kernel data in it

490
00:38:28,010 --> 00:38:29,750
and that it made system calls even faster,

491
00:38:30,200 --> 00:38:37,750
if you call a system call, the system call returns there's still gonna be likely still to be useful user data in the caches,

492
00:38:37,750 --> 00:38:42,980
because we never changed, we never changed page tables are changed the meanings of these addresses.

493
00:38:45,620 --> 00:38:47,750
Anyway, so there's likely to be kernel data,

494
00:38:48,110 --> 00:38:52,710
even if you're running a user space is likely to be kernel data in the old one cache

495
00:38:53,070 --> 00:38:55,770
and it's these permissions which are copied out of the TLB,

496
00:38:55,770 --> 00:38:57,330
copied out of page table entries,

497
00:38:57,510 --> 00:39:01,290
that tells the machine that oh even though the data is in the cache,

498
00:39:01,320 --> 00:39:02,490
you're not allowed to see it,

499
00:39:03,130 --> 00:39:05,050
and raise raise a page fault.

500
00:39:11,870 --> 00:39:13,940
So this is a good time to mention that,

501
00:39:15,220 --> 00:39:22,390
even though the intent of micro-architectural optimizations is they be completely transparent,

502
00:39:24,910 --> 00:39:26,650
that can't possibly be true,

503
00:39:26,740 --> 00:39:33,040
because the whole point of these micro-architectural optimizations is almost always to improve performance

504
00:39:33,160 --> 00:39:39,250
and so they will be guaranteed to be at least visible in terms of performance

505
00:39:39,310 --> 00:39:41,680
as you could tell if your machine has a cache or not,

506
00:39:41,710 --> 00:39:46,600
because if it doesn't have a cache, it'll run a couple hundred times slower, right,

507
00:39:47,020 --> 00:39:50,980
in addition you can tell whether the data you're trying to fetch,

508
00:39:51,010 --> 00:39:53,350
if you're capable of measuring time accurately enough

509
00:39:53,590 --> 00:39:55,600
and you do a load, you can tell,

510
00:39:55,900 --> 00:39:59,440
if the load returned in a couple cycles, the data must have been cached,

511
00:39:59,440 --> 00:40:05,820
if the load returned after a hundred times that, they probably had to be loaded from RAM

512
00:40:06,210 --> 00:40:07,650
and so the differences are profound,

513
00:40:07,650 --> 00:40:12,600
and if you can measure time to you know a few nanoseconds or even tens of nanoseconds,

514
00:40:12,780 --> 00:40:14,070
you can tell the difference,

515
00:40:14,220 --> 00:40:18,390
so in the performance level, is micro-architecture is absolutely not transparent.

516
00:40:19,120 --> 00:40:22,330
And all the things we talk about branch prediction caches or whatever,

517
00:40:22,330 --> 00:40:28,300
all that stuff is at least indirectly visible to timing.

518
00:40:30,990 --> 00:40:40,020
And so, of course many people even though the micro-architectural design is sort of in any detailed level secret,

519
00:40:40,440 --> 00:40:42,990
to Intel, it's their private business how they implement this,

520
00:40:43,020 --> 00:40:48,630
in fact it's all along been of extremely intense interest to a lot of people,

521
00:40:48,630 --> 00:40:50,310
because it affects performance a lot.

522
00:40:50,520 --> 00:40:55,230
So a compiler writers for example know a lot about micro-architecture,

523
00:40:55,230 --> 00:41:04,890
because, the most many many compiler optimizations are implicitly exploiting people's good guesses about what the machines actually doing inside.

524
00:41:05,500 --> 00:41:11,800
And indeed the CPU manufacturers publish optimization guides,

525
00:41:11,830 --> 00:41:15,010
that reveal some of the micro-architectural tricks,

526
00:41:15,100 --> 00:41:16,840
but they rarely go into much detail,

527
00:41:17,410 --> 00:41:23,560
{} certainly not enough detail to really understand exactly why meltdown works.

528
00:41:24,180 --> 00:41:34,540
So the micro-architecture stuff is sort of sits somewhere between supposed to be transparent and visible and hidden and sort of partially,

529
00:41:34,630 --> 00:41:41,800
you know certainly a lot of people are interested and a lot of people know all kinds of random things about it.

530
00:41:43,800 --> 00:41:50,420
Okay, so the reason why this cache stuff is interesting for meltdown,

531
00:41:50,540 --> 00:41:53,390
first of all, any questions about about caching.

532
00:41:58,660 --> 00:42:09,300
Okay, let me talk then, about sort of main way that the paper uses caching,

533
00:42:09,300 --> 00:42:13,800
the paper talks about this technique called flush, flush and reload.

534
00:42:18,740 --> 00:42:21,760
And, what flush and reload is up to,

535
00:42:21,760 --> 00:42:33,350
is that it's answering the question did a particular piece of code use the memory at a particular address.

536
00:42:33,840 --> 00:42:39,120
And it's not directly a security exploit,

537
00:42:39,120 --> 00:42:41,820
because it only works for memory that you can get at.

538
00:42:42,210 --> 00:42:45,060
So if your user code and you have some memory, that's your memory

539
00:42:45,060 --> 00:42:45,960
and you're allowed to use it,

540
00:42:46,140 --> 00:42:48,600
you can and you call one of your own functions

541
00:42:48,600 --> 00:42:54,120
or then you'll be able to tell, you can use flush and reload to tell,

542
00:42:54,120 --> 00:42:58,800
whether the function your function, you just executed used your memory,

543
00:42:59,320 --> 00:43:02,740
you can't directly use this attack or it's not an attack,

544
00:43:02,770 --> 00:43:09,010
you can use this technique to figure out, if some other process use that process is private memory.

545
00:43:11,110 --> 00:43:14,590
Although, because processes sometimes share memory, yeah,

546
00:43:16,180 --> 00:43:18,220
you may still be able to do,

547
00:43:18,220 --> 00:43:22,760
well the right way to put it is you can only find out about memory you're allowed to access.

548
00:43:23,540 --> 00:43:29,620
Okay, so answering the question, did did a particular function use this memory.

549
00:43:29,650 --> 00:43:39,050
So, step one, is we're gonna flush, supposing we were interested in address x,

550
00:43:41,240 --> 00:43:43,130
we want to flush the cache,

551
00:43:43,130 --> 00:43:47,600
we want to make sure the cache doesn't contain the memory location x

552
00:43:47,600 --> 00:43:49,850
and it turns out that for our convenience,

553
00:43:50,270 --> 00:43:55,600
Intel supplies an instruction, called clFlash,

554
00:43:56,680 --> 00:43:58,210
and you give it an address

555
00:43:58,720 --> 00:44:06,730
and it will get rid of, it will ensure that that location is not cached any of the caches

556
00:44:07,120 --> 00:44:08,440
and so that's super convenient,

557
00:44:10,360 --> 00:44:12,790
even if the machine didn't provide this instruction,

558
00:44:12,790 --> 00:44:15,760
that it turns out there's ways of getting rid of stuff from the cache,

559
00:44:15,760 --> 00:44:19,810
like for example if you know the cache holds 64 kilobytes,

560
00:44:19,840 --> 00:44:26,410
then it's likely to be the case that if you load 64 kilobytes of random memory,

561
00:44:26,760 --> 00:44:28,710
you know just load instructions that,

562
00:44:29,010 --> 00:44:32,040
those will be loaded into the cache,

563
00:44:32,250 --> 00:44:35,760
and after you've loaded 64 kilobytes of new data into the cache,

564
00:44:36,360 --> 00:44:38,100
everything that used to be in it must be gone,

565
00:44:38,130 --> 00:44:41,130
because the cache can only hold 64 kilobytes or whatever it may be.

566
00:44:41,580 --> 00:44:44,540
So, even without this [] instruction,

567
00:44:44,600 --> 00:44:47,090
you can still flush everything in the cache.

568
00:44:47,660 --> 00:44:54,770
Then step two is you're interested in whether some particular piece of code uses data x,

569
00:44:54,770 --> 00:44:57,140
you just call that code whatever it is.

570
00:44:57,920 --> 00:45:01,580
and it does what it does maybe uses x, maybe doesn't,

571
00:45:02,590 --> 00:45:06,670
now you wanna tell effects is actually in the cache,

572
00:45:06,670 --> 00:45:08,980
because if it is since you flushed from the cache,

573
00:45:09,010 --> 00:45:09,970
if it's in the cache now,

574
00:45:09,970 --> 00:45:13,900
it must be that f causes to be loaded, unless something else is going on,

575
00:45:14,140 --> 00:45:17,170
so you need to, you want to do a load,

576
00:45:17,170 --> 00:45:19,120
but you wanna know how long the load takes,

577
00:45:19,450 --> 00:45:24,310
so we're only talking about nanoseconds like five nanoseconds versus hundred nanoseconds here,

578
00:45:24,310 --> 00:45:29,170
how can we measure time that accurately that's a tough assignment,

579
00:45:29,170 --> 00:45:32,740
however again the CPUs come to [ra],

580
00:45:32,740 --> 00:45:37,360
in fact provide instruction which gives you cycle granularity time,

581
00:45:39,620 --> 00:45:41,360
and it's called rdtsc,

582
00:45:42,010 --> 00:45:47,140
So we're just gonna execute the rdtsc instruction,

583
00:45:47,170 --> 00:45:53,620
which tells us essentially the number of cycles that have elapsed, since the machine cycles have elapsed since the machine started.

584
00:45:54,330 --> 00:45:56,580
And since it's probably two Giga Hertz machine,

585
00:45:56,580 --> 00:46:00,120
that means that the precision we have here is half a nanosecond,

586
00:46:00,830 --> 00:46:01,820
its pretty small.

587
00:46:02,360 --> 00:46:04,850
Now we're gonna load,

588
00:46:06,500 --> 00:46:13,840
we're just gonna say junk equals star x,

589
00:46:13,870 --> 00:46:17,860
we're going to load the data of location x,

590
00:46:18,250 --> 00:46:19,690
I get the time again,

591
00:46:23,300 --> 00:46:26,750
and look at the difference right, b minus a,

592
00:46:29,450 --> 00:46:33,620
if b minus a is you know five or six or seven or something,

593
00:46:33,620 --> 00:46:36,530
that means that this load hit in the cache,

594
00:46:36,530 --> 00:46:38,600
and that means that this function used the data,

595
00:46:38,870 --> 00:46:45,530
if b minus a is 150, then that means that x wasn't in the cache

596
00:46:45,980 --> 00:46:52,660
and yeah you know that may probably means that f that may mean that did never used x,

597
00:46:52,690 --> 00:46:54,520
that's not quite that cut and dry,

598
00:46:54,520 --> 00:46:57,970
because f might have used x and then use something else,

599
00:46:58,330 --> 00:47:00,940
that conflicted with x in the cache

600
00:47:00,940 --> 00:47:03,460
and caused x to be kicked out of the cache again.

601
00:47:03,580 --> 00:47:11,260
But, for simple situations, a very large value of b minus a, means f didn't use it,

602
00:47:11,260 --> 00:47:15,670
in a small value of b minus a, means that f did use that data.

603
00:47:18,070 --> 00:47:19,900
So this is not an attack yet,

604
00:47:19,900 --> 00:47:24,760
because again, we have to be able to access this memory,

605
00:47:24,760 --> 00:47:26,230
so this is our memory.

606
00:47:28,290 --> 00:47:31,560
Any questions about flush plus reload?

607
00:47:40,340 --> 00:47:46,360
Alright, I think that's all the preliminaries, let's go back to meltdown.

608
00:47:48,910 --> 00:47:53,800
So this is a more full version I showed you sort of core meltdown at the beginning,

609
00:47:53,920 --> 00:47:57,280
this is a more complete meltdown.

610
00:47:59,690 --> 00:48:02,960
And so we actually now have I added the flush reload part.

611
00:48:04,380 --> 00:48:06,150
Again we're going to declare this buffer.

612
00:48:06,210 --> 00:48:13,050
And the idea is that depending on we're gonna be just fetching one bit from the kernel,

613
00:48:13,200 --> 00:48:17,370
we're going to multiply that one bit by 4096,

614
00:48:17,370 --> 00:48:19,830
so we're hoping to use flush plus reload to see that

615
00:48:19,830 --> 00:48:24,540
either buf of zero is in the cache or buffer of 4096 is in the cache

616
00:48:24,690 --> 00:48:33,700
and the reason for the large separation there is that apparently the pref-, this hardware has a prefetcher in it,

617
00:48:33,700 --> 00:48:39,580
so if you load one thing from memory, it will load the next couple things up from memory too, the next couple of cache lines

618
00:48:39,760 --> 00:48:42,790
and so we can't have the two different cache lines,

619
00:48:42,820 --> 00:48:46,150
that we're going to apply flush and reload to be to be particularly close,

620
00:48:46,560 --> 00:48:52,320
need to be far enough apart that even prefetch, hardware prefetching won't cause confusion.

621
00:48:53,030 --> 00:48:56,750
So we put the whole page apart, the flash part now,

622
00:48:56,780 --> 00:49:05,970
we just call this clflush instruction to make sure that the relevant parts of our buffer are not catched.

623
00:49:06,700 --> 00:49:22,800
Now, we're exploiting, this line seven is not maybe may or may not be necessary,

624
00:49:22,800 --> 00:49:26,850
but what what's going on here is we're exploiting this sort of,

625
00:49:27,360 --> 00:49:35,000
I'm going to be exploiting the gap in time between,

626
00:49:36,030 --> 00:49:42,860
you know, we we're doing this load line ten to load a kernel address, so it's gonna fault,

627
00:49:43,700 --> 00:49:51,140
but we're hoping to be able to execute another couple of instructions speculatively before this instruction is retired

628
00:49:51,230 --> 00:49:55,520
and before it actually raises the fault and cancels these instructions right,

629
00:49:55,610 --> 00:49:58,880
if the fault if this load would be retired,

630
00:49:58,880 --> 00:50:02,440
say at this point, that would be too early for us,

631
00:50:02,620 --> 00:50:08,980
because it's going to turn out we actually need line thirteen to be speculatively executed in order to complete the attack,

632
00:50:09,160 --> 00:50:14,470
so we want to make sure that this load isn't retired for as long as possible,

633
00:50:15,150 --> 00:50:20,120
in order to delay the fault and delay the speculative cancellation.

634
00:50:20,480 --> 00:50:24,920
Now we know instructions aren't retired until all previous instructions have retired,

635
00:50:25,400 --> 00:50:26,480
it's one of the rules.

636
00:50:27,090 --> 00:50:33,600
So at line seven, I'm imagining that we're going to launch some expensive instruction that doesn't compete for a long time,

637
00:50:33,840 --> 00:50:37,110
maybe it loads something else that's known to have to come from RAM,

638
00:50:37,110 --> 00:50:38,580
so it'll take a few hundred cycles,

639
00:50:38,580 --> 00:50:41,760
or maybe it does a divider a square root or something,

640
00:50:41,760 --> 00:50:43,980
who knows what something that takes a long time,

641
00:50:44,070 --> 00:50:46,320
it won't be retired for a long time,

642
00:50:46,530 --> 00:50:50,340
and therefore will cause this load not to be retired for a long time,

643
00:50:50,550 --> 00:50:53,940
giving these instructions time to execute speculatively.

644
00:50:57,420 --> 00:51:01,830
Right, now we're assuming again we have a virtual address in the kernel,

645
00:51:04,680 --> 00:51:06,960
gonna execute line ten,

646
00:51:07,140 --> 00:51:09,150
line ten won't raise a fault, until that,

647
00:51:09,150 --> 00:51:12,120
we know it's going to raise a fault, won't raise a fault until retires,

648
00:51:12,120 --> 00:51:17,640
but we're intending, we believe we've set things up, so won't retire for a while, since it hasn't retired

649
00:51:18,390 --> 00:51:23,790
and because on Intel CPUs the data is returned even if you weren't allowed to see it,

650
00:51:23,940 --> 00:51:28,270
the data return for speculative execution, even if you did not permission,

651
00:51:28,840 --> 00:51:37,560
that means that we can speculatively execute, the machine will speculatively execute line eleven and get the low bit of kernel data now,

652
00:51:38,040 --> 00:51:40,140
multiplied by 4096,

653
00:51:40,350 --> 00:51:43,770
line thirteen is itself a load, it's another load,

654
00:51:44,570 --> 00:51:50,800
using an address basically the address of buffer plus the contents of r2,

655
00:51:51,570 --> 00:51:54,510
we know it's going to get cancelled,

656
00:51:55,160 --> 00:51:57,620
because we know this will fault right,

657
00:51:57,620 --> 00:52:00,440
we know the actual write to r3 will be cancelled,

658
00:52:00,470 --> 00:52:09,250
but line thirteen will cause some data from buffer to be loaded into the cache,

659
00:52:09,520 --> 00:52:12,400
even if it doesn't end up affecting register three,

660
00:52:12,490 --> 00:52:17,860
so r3 line thirteen is going to cause something to be loaded into the cache,

661
00:52:18,100 --> 00:52:21,250
and this case depending on whether the low bit is zero, one,

662
00:52:21,880 --> 00:52:28,660
line thirteen will cause the actual cache to contain either buffer zero or buffer 4096,

663
00:52:30,010 --> 00:52:35,440
then, right, then that even though r2 and r3 are cancelled,

664
00:52:35,500 --> 00:52:40,600
the change in the cache, because it's supposed to be hidden micro-architectural state,

665
00:52:40,600 --> 00:52:43,420
that will actually be the cache will be changed.

666
00:52:44,680 --> 00:52:46,600
Finally, at some point the fault will happen,

667
00:52:46,990 --> 00:52:50,740
and we need to sort of recover after the fault,

668
00:52:50,740 --> 00:52:52,510
but it's just a page fault,

669
00:52:52,510 --> 00:52:59,200
and it turns out you can or user process can register a page fault handler and get control back after a page fault

670
00:52:59,200 --> 00:53:03,730
and the paper mentions a couple of other ways of being able to continue after the fault.

671
00:53:05,470 --> 00:53:11,440
And now all we have to do is figure out whether it was buffet zero or buffet 4096, that was loaded into the cache,

672
00:53:11,620 --> 00:53:13,930
and now we can do the reload part of flush and reload,

673
00:53:14,050 --> 00:53:17,290
we read the accurate time,

674
00:53:18,120 --> 00:53:20,460
load buffet zero, read the time again,

675
00:53:20,460 --> 00:53:22,800
load buff one, read the time again

676
00:53:22,800 --> 00:53:24,780
and compare the two differences in time

677
00:53:24,930 --> 00:53:27,570
and whichever one of these took a shorter amount of time,

678
00:53:28,140 --> 00:53:34,520
is likely to indicate whether the low bit of the kernel data was zero or one.

679
00:53:39,350 --> 00:53:43,490
And then we report that repeat that a couple of billion times,

680
00:53:44,270 --> 00:53:45,770
we can scan all of kernel memory.

681
00:53:47,100 --> 00:53:52,560
But in this example, if b minus a smaller than c minus b,

682
00:53:52,560 --> 00:53:56,400
doesn't that mean that buf of zero was cached.

683
00:53:57,060 --> 00:54:00,420
Let's see if I got this wrong,

684
00:54:00,450 --> 00:54:03,630
you might say yeah means the buf zero was cache,

685
00:54:03,630 --> 00:54:06,600
oh yeah yeah yeah you're right.

686
00:54:10,790 --> 00:54:15,180
Now we're [cooking], good catch.

687
00:54:17,540 --> 00:54:25,010
Oh, sorry do you need for, before we had an if before like nine nine,

688
00:54:25,700 --> 00:54:30,050
do we need, if now or is it is still gonna.

689
00:54:31,980 --> 00:54:38,280
The efforts to help me illustrate the legitimate reasons for speculative execution,

690
00:54:38,820 --> 00:54:43,410
keep computing even though we don't know whether the branch took or not,

691
00:54:43,410 --> 00:54:51,740
but here the real core of the speculation is that we don't know if this load will fault, right,

692
00:54:51,740 --> 00:54:56,150
and so were the machines speculatively executing past the load,

693
00:54:56,330 --> 00:55:00,830
on the theory that it's probably most don't fault, right,

694
00:55:00,830 --> 00:55:02,090
even though they may take a long time,

695
00:55:02,090 --> 00:55:04,340
like a load could take hundreds of cycles

696
00:55:04,970 --> 00:55:09,530
and so we'd love to be able to, so the machine will speculatively execute pass the load,

697
00:55:10,040 --> 00:55:14,140
even though it doesn't, not knowing whether it's going to fault or not,

698
00:55:14,140 --> 00:55:16,300
and if the load did fault,

699
00:55:16,300 --> 00:55:18,460
it will then undo all this speculative execution,

700
00:55:18,730 --> 00:55:27,970
there's a speculative execution comes up, any time you have a long running instruction that may or may not succeed,

701
00:55:28,000 --> 00:55:31,030
so like divide, so we know whether it's going to be divided by zero or not,

702
00:55:31,030 --> 00:55:33,940
you know so instructions after divider also speculated.

703
00:55:35,980 --> 00:55:39,070
Anyway, the speculation, the real critical speculation starts here,

704
00:55:39,070 --> 00:55:43,930
now, in fact we tried, in order to make the attack likely more successful,

705
00:55:43,930 --> 00:55:46,570
we sort of ensure that speculation starts here,

706
00:55:46,570 --> 00:55:48,790
but this is the real speculation we care about.

707
00:56:01,640 --> 00:56:02,690
Other questions?

708
00:56:06,100 --> 00:56:10,730
For, this example we've only read one bit,

709
00:56:13,050 --> 00:56:19,890
is is there some likes really small, simple modification that we could make to read like a full register size of bits.

710
00:56:20,100 --> 00:56:22,590
Yeah, run this 64 times, one for each bit.

711
00:56:24,810 --> 00:56:29,760
Why is it not possible to just read 64 bits at a time.

712
00:56:30,790 --> 00:56:37,710
A sixty, sixty, well you need the buffer, the size of this buffer has to be a to the,

713
00:56:39,240 --> 00:56:44,430
you know two to the number of bits, you're reading times 4096 or something,

714
00:56:44,670 --> 00:56:48,810
so 64 bits is two big, we don't have enough memory to a make a buffer that big,

715
00:56:50,810 --> 00:56:52,700
we need this, the way this is set up.

716
00:56:54,810 --> 00:57:00,310
But anyway, yep, 64 bits too much,

717
00:57:00,310 --> 00:57:02,080
you could certainly read a bit of time

718
00:57:02,320 --> 00:57:09,350
and have this buffer size be 256 times 4096.

719
00:57:11,620 --> 00:57:13,060
The paper actually argues in a,

720
00:57:14,860 --> 00:57:23,500
the paper observes that, since the most of the time is here in the plus reload,

721
00:57:25,380 --> 00:57:36,750
if you read a byte at a time, then figuring out what the bits of that byte are takes flush and reloads,

722
00:57:38,310 --> 00:57:40,140
one for each possible value.

723
00:57:40,800 --> 00:57:47,470
If you load a bit at a time, then each bit takes just one flush plus reload,

724
00:57:47,470 --> 00:57:51,460
are sort of two two probes are two flush plus reloads,

725
00:57:51,610 --> 00:57:52,930
so if you need a bit of time,

726
00:57:53,140 --> 00:57:56,170
then you end up only doing sixteen flush plus reloads,

727
00:57:56,170 --> 00:57:59,800
if you read a byte at a time, you end up doing 256 flush plus reloads,

728
00:58:00,160 --> 00:58:04,000
the paper says that it's faster to do it a bit at a time than a byte at a time.

729
00:58:05,890 --> 00:58:10,500
Which seems a little counterintuitive, seems to be true.

730
00:58:18,960 --> 00:58:20,010
Other questions?

731
00:58:28,760 --> 00:58:32,810
So where would this user program, will this program have to be run from,

732
00:58:33,890 --> 00:58:38,690
is there any particular location on the machine, that doesn't have to be,

733
00:58:39,480 --> 00:58:41,220
where would you write it I guess.

734
00:58:43,650 --> 00:58:47,340
Where would this program be run from, can be a user program.

735
00:58:47,880 --> 00:58:53,250
Well yeah, that depends on what kind of access, you have to the machine

736
00:58:53,250 --> 00:58:55,740
and where the data is that you want to steal

737
00:58:56,070 --> 00:58:59,360
and then you know, who knows right.

738
00:58:59,360 --> 00:59:05,610
But one example is supposing, you're logged into Athena dial up machine,

739
00:59:06,030 --> 00:59:08,160
it was a couple hundred other users

740
00:59:08,250 --> 00:59:12,340
and you want to steal somebody's password, and you're patient,

741
00:59:13,030 --> 00:59:17,320
you can use and let's assume that Athena is now a couple years ago

742
00:59:17,320 --> 00:59:22,840
and Athena was running a version of Linux that mapped the kernel into every user's every processes address space,

743
00:59:23,140 --> 00:59:26,080
then you can use meltdown to get out bit by bit,

744
00:59:26,560 --> 00:59:30,820
everything in the kernel including [] IO buffers and the network buffers and stuff

745
00:59:30,910 --> 00:59:32,590
and if somebody's typing their password,

746
00:59:32,620 --> 00:59:36,570
if you're lucky or patient, and somebody's typing your password

747
00:59:36,570 --> 00:59:37,830
and you load all of kernel memory,

748
00:59:37,860 --> 00:59:41,760
you're going to see that password in kernel memory, right.

749
00:59:42,580 --> 00:59:47,590
And because in fact the kernel probably maps like xv6 maps all of physical memory,

750
00:59:47,830 --> 00:59:53,200
that means you can probably read all physical memory that is all of all other processes memory,

751
00:59:53,320 --> 00:59:55,690
using this technique on a time sharing machine.

752
00:59:56,640 --> 01:00:01,500
So I can see what's everybody's in text editor contents or whatever I like.

753
01:00:02,500 --> 01:00:08,010
Now you have to, that's a way you could use it, if you're using a time machine,

754
01:00:08,010 --> 01:00:11,600
for other situations, yeah it would be different.

755
01:00:12,270 --> 01:00:13,170
Make sense.

756
01:00:13,920 --> 01:00:16,740
In time sharing is not that pervasive anymore,

757
01:00:16,980 --> 01:00:21,990
but the sort of killer scenario would be some kind of cloud computing thing

758
01:00:21,990 --> 01:00:25,260
where you're using a cloud provider like Amazon

759
01:00:25,650 --> 01:00:28,620
and you know which runs many customers on the same machine.

760
01:00:29,280 --> 01:00:33,480
And depending on the details of how they set up their virtual machine monitor

761
01:00:33,480 --> 01:00:36,090
or container system or whatever it may be.

762
01:00:36,450 --> 01:00:40,640
If you buy time from Amazon,

763
01:00:41,330 --> 01:00:48,580
then you may be able to peer into the memory of other customer's software running on the same Amazon machine maybe.

764
01:00:50,730 --> 01:00:55,120
So I think that's really, yeah, that's how people actually use this probably.

765
01:00:55,300 --> 01:00:59,170
Actually another time that might be useful is your browser,

766
01:00:59,170 --> 01:01:03,070
when you're browsing the web browser actually runs a lot of code in it that is not trusted,

767
01:01:03,070 --> 01:01:05,350
that is supplied by the random websites you visit,

768
01:01:07,330 --> 01:01:08,860
maybe in the form of plugins,

769
01:01:09,070 --> 01:01:12,370
may be in the form of Javascript, that's loaded in your browser

770
01:01:12,370 --> 01:01:15,840
and compiled by the browser and execute it

771
01:01:15,990 --> 01:01:25,340
and it is possible that this attack could be carried out by code that you run in your browser when you browse the web.

772
01:01:26,190 --> 01:01:32,620
That you may not, even though it's running their load from websites and they would steal whatever stuff is sitting in your laptop.

773
01:01:33,790 --> 01:01:36,040
I don't know if the details of that quite work out.

774
01:01:37,180 --> 01:01:42,190
Has anyone demonstrated an attack through either Javascript or like WebAssembly.

775
01:01:42,250 --> 01:01:46,300
I don't know, I don't I I feel certainly people worried about WebAssembly.

776
01:01:46,920 --> 01:01:49,230
I don't know whether the attack was literally possible,

777
01:01:50,010 --> 01:01:57,760
for Javascript I know that, maybe the sticking point was the accurate time, I mean.

778
01:01:59,370 --> 01:02:01,620
You couldn't quite get this nanosecond timing,

779
01:02:01,680 --> 01:02:04,770
so you couldnt quite execute supposed to be load now,

780
01:02:04,770 --> 01:02:08,430
where somebody with a bit more cleverness could figure out a way to do it,

781
01:02:08,430 --> 01:02:13,250
I don't know we have assembly is much closer to running machine code

782
01:02:13,250 --> 01:02:16,610
and you know I I don't know exactly how the details worked out,

783
01:02:16,610 --> 01:02:21,160
but oh boy was, so many people rapidly thought about.

784
01:02:25,250 --> 01:02:29,180
Okay, it turns out the attack doesn't always work,

785
01:02:29,420 --> 01:02:35,120
like and for reasons that I don't think the authors never explained or only speculated about

786
01:02:35,120 --> 01:02:38,000
and you can see I don't know if you can see this,

787
01:02:38,000 --> 01:02:39,140
well maybe you can't see this,

788
01:02:39,170 --> 01:02:41,990
but if you turn the last page of their paper,

789
01:02:42,260 --> 01:02:44,060
you'll see the output it's actually,

790
01:02:44,150 --> 01:02:51,080
you know, they mounted the attack on their own machines and extracted a bunch of data from their own, the kernel on their own machine.

791
01:02:51,530 --> 01:03:01,410
And, if you look closer you'll see there's a huge all these lines are just xx xxx xxx, all these lines x x with dots,

792
01:03:01,560 --> 01:03:06,120
these are places where they didn't manage to extract anything, where meltdown failed,

793
01:03:06,540 --> 01:03:08,880
even though they repeated it many times.

794
01:03:09,340 --> 01:03:16,480
And you can tell they must have been, you know they were the papers version of this attack was re-trying many many times,

795
01:03:16,480 --> 01:03:19,570
because for example section 6.2 talks about performance,

796
01:03:19,870 --> 01:03:24,910
says that in some cases the rate at which they could extract data was only ten bytes per second,

797
01:03:25,450 --> 01:03:27,640
which means they were sitting there trying again and again and again,

798
01:03:27,640 --> 01:03:35,460
and after thousands of times they finally managed to get some data that is that, flush plus reload indicated

799
01:03:35,460 --> 01:03:37,860
that the two cache lines at different load times.

800
01:03:39,270 --> 01:03:45,180
So there's something unexplained going on about why it's quite frequent for meltdown actually fail,

801
01:03:45,210 --> 01:03:47,580
get some data actually got real data here,

802
01:03:48,140 --> 01:03:49,970
there's also a bunch of data that they didn't get,

803
01:03:50,420 --> 01:04:00,340
and I don't know if people as far as I know, people are not really sure what all the conditions are about when it succeeds when it doesn't,

804
01:04:00,490 --> 01:04:03,130
you know the most straightforward possibility is that

805
01:04:03,130 --> 01:04:07,420
if the kernel data is in the L1 cache, the meltdown succeeds

806
01:04:07,420 --> 01:04:10,540
and the kernel data is not in the L1 cache, doesn't succeed.

807
01:04:10,600 --> 01:04:15,010
That's very easy to believe that that could be what's going on,

808
01:04:15,760 --> 01:04:21,490
because if it's not in the L1 cache, then there's a whole bunch more machinery involved in a speculative load

809
01:04:21,730 --> 01:04:26,740
and it's easy to imagine that the CPU for a speculative load,

810
01:04:26,770 --> 01:04:28,990
that's maybe not known if it's even needed,

811
01:04:29,590 --> 01:04:34,840
would not bother doing all the work required to load stuff from RAM.

812
01:04:36,440 --> 01:04:39,280
But, it's not quite that simple,

813
01:04:40,150 --> 01:04:41,500
you can tell it's not quite that simple,

814
01:04:41,500 --> 01:04:47,650
because the paper says that sometimes when they tried, we tried many times and it finally worked,

815
01:04:47,710 --> 01:04:50,970
so there's some more complex condition,

816
01:04:51,000 --> 01:04:57,030
maybe a race effectively race inside the CPU under which it occasionally works,

817
01:04:57,800 --> 01:04:59,990
even for data that's not not in the cache.

818
01:05:06,670 --> 01:05:08,650
The end of the paper is actually also,

819
01:05:08,650 --> 01:05:10,420
if you didn't get that for worth reading,

820
01:05:10,420 --> 01:05:13,570
because it does explain a sort of more real world,

821
01:05:13,570 --> 01:05:15,700
like we wanted to find out this particular thing,

822
01:05:15,700 --> 01:05:20,410
you know this, we know there's passwords stored in our Firefox's password manager,

823
01:05:20,440 --> 01:05:23,680
we wanted to get them out and steal them using meltdown,

824
01:05:23,860 --> 01:05:26,680
you know what are all the, how do you find out what the addresses,

825
01:05:26,680 --> 01:05:30,100
for example, they sort of lay out a complete attack,

826
01:05:30,340 --> 01:05:35,070
I mean, a complete attack done by academics not real attackers, but nevertheless

827
01:05:35,310 --> 01:05:37,290
and filling many of the pragmatic details.

828
01:05:40,630 --> 01:05:44,290
The only thing I want to talk about is his fixes,

829
01:05:45,090 --> 01:05:46,380
you've already touched on a little bit.

830
01:05:47,230 --> 01:05:52,560
When this paper came out, it got a lot of attention

831
01:05:52,560 --> 01:05:57,960
and there was actually another second paper by overlapping set of people about a different attack,

832
01:05:57,960 --> 01:06:03,320
that also used different, different kind of speculation inside CPUs, called spectre.

833
01:06:03,350 --> 01:06:06,650
So the pair of papers came out at the same time

834
01:06:06,680 --> 01:06:09,920
and was very exciting.

835
01:06:10,160 --> 01:06:13,700
And so people hustled, people realize that boy, this is extremely damaging,

836
01:06:13,700 --> 01:06:17,510
because now we're talking about is that you know isolation has been broken, right.

837
01:06:17,940 --> 01:06:21,060
You're gonna hardly, so basically hardly even think about it anymore,

838
01:06:21,060 --> 01:06:26,430
but you know this thing, this is a technique for breaking page table protections,

839
01:06:26,460 --> 01:06:30,390
which is you know how we enforce isolation between user and kernel,

840
01:06:30,390 --> 01:06:33,840
it's like deeply fundamental attack,

841
01:06:34,350 --> 01:06:39,060
or anyway undermines an extremely important piece of security,

842
01:06:40,160 --> 01:06:41,330
in a very general way right,

843
01:06:41,330 --> 01:06:42,410
seems like you could read anything.

844
01:06:43,790 --> 01:06:47,600
And so people really really hustled, to a deploy fixes for this,

845
01:06:47,600 --> 01:06:56,730
in the immediate fix that a lot of operating systems installed within weeks of this paper coming out

846
01:06:56,730 --> 01:06:59,400
and sometimes had already installed this thing called KASLR,

847
01:07:00,180 --> 01:07:03,510
which is now called kpti in Linux

848
01:07:03,540 --> 01:07:06,060
and it's a pretty straightforward idea,

849
01:07:06,330 --> 01:07:10,470
the idea is just like not to put the kernel mappings in the user page table,

850
01:07:11,010 --> 01:07:19,290
and instead a as in xv6, switch page tables during system calls to user space,

851
01:07:19,290 --> 01:07:24,870
just user mappings make a system call, there's some kind of trampoline arrangement like in xv6

852
01:07:24,870 --> 01:07:30,240
and you switch page tables to a page table that has the kernel mappings in order to execute the kernel.

853
01:07:32,080 --> 01:07:34,780
And that causes attack cannot work,

854
01:07:34,990 --> 01:07:41,210
because the, in that because you switch page tables,

855
01:07:41,840 --> 01:07:51,780
this virtual address in r1, it's not only no longer valid, it's no longer meaningful,

856
01:07:51,990 --> 01:07:54,300
because there's no translation for it,

857
01:07:55,080 --> 01:07:58,140
so the CPU doesn't know what to do with it,

858
01:07:58,790 --> 01:08:00,950
like this virtual address won't be cached,

859
01:08:01,250 --> 01:08:03,470
it's not even in the TLB,

860
01:08:03,830 --> 01:08:08,930
so there's just no way for the kernel to decide what memory corresponds to this virtual address.

861
01:08:10,600 --> 01:08:12,670
You know when this attack is executed in user space,

862
01:08:12,880 --> 01:08:15,670
because this virtual this kernel virtual dress no longer means anything,

863
01:08:16,520 --> 01:08:19,520
it's not it's not illegal, it's just meaningless

864
01:08:20,300 --> 01:08:22,550
and so that would cause the attack not to work.

865
01:08:23,420 --> 01:08:30,110
The downside of this KASLR fixes, that now system calls are more expensive, because switching page tables.

866
01:08:32,610 --> 01:08:37,680
If you don't do anything switching page tables, causes the TLB flushed,

867
01:08:37,680 --> 01:08:41,430
because now all those virtual addresses and TLB are the wrong virtual addresses,

868
01:08:41,430 --> 01:08:43,200
that don't correspond to this page table anymore

869
01:08:43,350 --> 01:08:46,830
and it causes the L1 cache to be flushed, because it's virtually address

870
01:08:47,340 --> 01:08:54,160
and so on on some machines, the switching page tables made system calls considerably slower.

871
01:08:56,820 --> 01:09:01,380
In an recent machines actually have this trick called PCID which you can look up,

872
01:09:01,380 --> 01:09:05,610
but basically makes it so you can avoid flushing these caches on a page table switch,

873
01:09:05,640 --> 01:09:06,930
although it still takes some time.

874
01:09:07,920 --> 01:09:10,260
And if you [poke] around the web looking for people,

875
01:09:10,260 --> 01:09:17,310
there was a lot of worry at the time, that this split, that this two page table idea would be unacceptably slow,

876
01:09:17,640 --> 01:09:21,390
now in fact, that didn't really turn out to be a serious problem,

877
01:09:21,420 --> 01:09:26,130
and if you poke around you'll see that people's guesses about typical workloads,

878
01:09:26,460 --> 01:09:29,880
you know how much it impacts overall performance of typical workloads,

879
01:09:29,880 --> 01:09:34,950
which after all don't spend all their time entering and exiting kernel, is like 5%,

880
01:09:35,970 --> 01:09:37,770
so it wasn't such a bad deal.

881
01:09:41,690 --> 01:09:45,940
Any questions about this KASLR fix?

882
01:09:52,620 --> 01:09:54,930
So people adopted this pretty rapidly,

883
01:09:55,260 --> 01:09:57,750
in fact there had been kernels that had already adopted it,

884
01:09:57,750 --> 01:09:59,610
because it defended against some other attacks.

885
01:10:02,200 --> 01:10:04,450
There's also a reasonable hardware fix,

886
01:10:04,450 --> 01:10:09,730
that I believe Intel it's actually made in recent processors and that AMD had already made

887
01:10:09,730 --> 01:10:17,540
and that's basically to because the, in fact, the permission,

888
01:10:17,900 --> 01:10:20,480
you know this is the structure of the cache,

889
01:10:20,480 --> 01:10:24,110
when an instruction loads something from the L1 cache,

890
01:10:24,110 --> 01:10:26,300
like this kernel data, we're trying to attack,

891
01:10:27,050 --> 01:10:32,810
the permissions or people believe that the permissions are sitting right there in the cache entry

892
01:10:33,050 --> 01:10:36,200
and so there's no trouble with the CPU checking the permissions at that point

893
01:10:36,290 --> 01:10:43,930
and indeed, AMD. CPUs and perhaps modern Intel CPUs will actually do the permission check very early

894
01:10:43,930 --> 01:10:47,920
and won't return this data, they won't even return it to the core,

895
01:10:48,040 --> 01:10:49,780
if the permission checks don't workout.

896
01:10:49,930 --> 01:10:55,810
So there's none of this speculative instructions are able to see forbidden data.

897
01:10:57,120 --> 01:11:04,800
So I I don't know if you know the answer to this question is probably just speculative, but no [pun] intended,

898
01:11:04,830 --> 01:11:07,710
but why, why do you think Intel would do this,

899
01:11:07,740 --> 01:11:08,820
like this seems like.

900
01:11:09,120 --> 01:11:09,720
Okay.

901
01:11:09,930 --> 01:11:12,210
Because to me, it seems like it was a discussion,

902
01:11:12,210 --> 01:11:15,030
shall we check permissions on transient instructions

903
01:11:15,030 --> 01:11:18,990
and they were just like no why, why bother will need just a simple check.

904
01:11:19,740 --> 01:11:26,220
Why bother, indeed stuff transparent and the users not be able to see the data either way, during the check early.

905
01:11:26,540 --> 01:11:30,290
You know that's like some gates on a pretty critical path right,

906
01:11:30,290 --> 01:11:34,830
the the you know the core of L1 data cache,

907
01:11:35,340 --> 01:11:37,770
path is extremely performance critical,

908
01:11:38,010 --> 01:11:43,910
you know if you can shave a few transistors off the, you know off the critical path here

909
01:11:43,910 --> 01:11:46,640
between issuing instruction and getting the data back,

910
01:11:46,880 --> 01:11:51,770
you know that may may allow you to have a slightly faster cycle time and run programs faster.

911
01:11:53,820 --> 01:11:56,640
And so it's got to be the case, that I don't know got to be the case,

912
01:11:56,640 --> 01:12:04,320
but it's easy to imagine that it would have cost them a few transistors to actually enforce the permissions early,

913
01:12:04,650 --> 01:12:08,310
because after all they still need all of the stuff at retirement,

914
01:12:08,490 --> 01:12:11,880
it's not like doing it early would save them some work later on,

915
01:12:12,030 --> 01:12:15,210
they still have to defer the fault until retirement.

916
01:12:17,400 --> 01:12:18,750
So all that stuff, still there,

917
01:12:19,750 --> 01:12:23,860
just guessing that it didn't seem like it would have any advantages

918
01:12:23,860 --> 01:12:26,620
and would have been a little bit of extra work.

919
01:12:30,000 --> 01:12:35,790
And into either way completely invisible, theoretically invisible too, at the architectural level.

920
01:12:36,390 --> 01:12:41,700
Did any kernel decide to like revert this KASLR fix,

921
01:12:41,700 --> 01:12:47,250
now that be like Intel has fixed the CPU, do improve performance, again.

922
01:12:47,430 --> 01:12:49,200
I know it's optional on a lot of kernels,

923
01:12:49,290 --> 01:12:55,750
I I'm not totally sure what's going on with the Intel fix,

924
01:12:55,870 --> 01:12:57,970
I'm fairly sure that they have this fix out there,

925
01:12:57,970 --> 01:13:02,750
but exactly you know I I I don't really know what's going on.

926
01:13:03,140 --> 01:13:07,370
I think in the Linux kernel, you can just ask which hardware fixes have been implemented

927
01:13:07,370 --> 01:13:13,280
and Linux you know changes the mitigation that enables depending on what actually the hardware tells it.

928
01:13:14,840 --> 01:13:15,410
So might.

929
01:13:15,410 --> 01:13:18,140
Oh so, so you can, you can actually do that,

930
01:13:18,140 --> 01:13:23,750
like you can read enough info about the processor as the kernel to know whether what to do.

931
01:13:23,990 --> 01:13:26,750
You can run your run your laptop there's a Linux command,

932
01:13:26,750 --> 01:13:31,420
that is actually yeah on like which is why it tells you

933
01:13:31,420 --> 01:13:34,990
exactly what fixes have been implemented where things are mitigated in hardware,

934
01:13:36,040 --> 01:13:39,550
this is a wide range of these respective applications attacks.

935
01:13:40,380 --> 01:13:44,220
Are you saying that Linux will actually use the combined page table if the CPU.

936
01:13:45,360 --> 01:13:45,900
Cool.

937
01:13:51,020 --> 01:13:52,940
I think it was, for 99%,

938
01:13:52,940 --> 01:13:54,200
I haven't checked it recently,

939
01:13:54,230 --> 01:13:56,450
I believe that's still the case.

940
01:14:04,040 --> 01:14:08,840
Sorry, so what were people doing like like how did they find find this,

941
01:14:08,990 --> 01:14:10,820
what are they trying to do.

942
01:14:11,180 --> 01:14:14,480
What are they trying to do, trying to break into computers.

943
01:14:14,900 --> 01:14:20,980
Well, the, who knows what they're really trying to do,

944
01:14:21,040 --> 01:14:25,570
I mean the papers are written by various academics,

945
01:14:25,570 --> 01:14:32,300
maybe you know their research is finding security problems.

946
01:14:32,390 --> 01:14:38,990
I think more that guys find that one thing the motive for a long time is they wanted to break address space randomization.

947
01:14:40,020 --> 01:14:45,000
And they had earlier papers, you know the different schemes trying to make a great interest in [rotation],

948
01:14:45,000 --> 01:14:50,280
so only one group of one stream of researchers that were in this area had that as a background.

949
01:14:50,860 --> 01:14:54,400
I think project zero people came from a completely different angle.

950
01:15:00,170 --> 01:15:04,850
This is people have seen Roberts said before, people have been working in this area for decades,

951
01:15:04,850 --> 01:15:11,610
you know trying find bugs they can exploit I understand.

952
01:15:17,160 --> 01:15:20,730
So, I guess is how this is a hard question to answer,

953
01:15:20,730 --> 01:15:27,100
but like how likely is it that there's another like meltdown out there,

954
01:15:27,100 --> 01:15:27,790
because it seems.

955
01:15:27,790 --> 01:15:29,380
Extremely likely.

956
01:15:29,560 --> 01:15:35,530
Okay, like micro, the fundamentally clean with micro-architecture like exposing changes.

957
01:15:37,040 --> 01:15:39,920
That's right, I I think what's going on is that

958
01:15:39,920 --> 01:15:44,840
the CPU manufacturers have for decades and decades have been,

959
01:15:45,490 --> 01:15:49,600
you know often adding more and more and more optimistic,

960
01:15:49,600 --> 01:15:56,050
there's many many many sort of cool little tricks inside the micro-architecture for making things go faster

961
01:15:56,290 --> 01:16:02,050
and you know now and end people didn't worry that much

962
01:16:02,050 --> 01:16:06,880
or it just wasn't on the radar, that this could be a serious security problem

963
01:16:07,330 --> 01:16:11,710
and so now people now very aware that this stuff could be a serious security problem,

964
01:16:11,740 --> 01:16:18,280
but we're now in a position where we're living with you know thirty years of clever ideas inside the CPUs.

965
01:16:18,640 --> 01:16:23,950
And so, indeed a bunch of, since this paper came out, and indeed before this paper came out,

966
01:16:24,100 --> 01:16:42,490
a bunch of kind of, a bunch of this style of attacks have come to light exploiting various different micro-architectural, these and CPUs, so I think this is gonna be a while before this all day to rest.

967
01:16:42,760 --> 01:16:45,580
We've looked at security conferences in the last you know two years,

968
01:16:45,580 --> 01:16:53,370
basically every year every conference basically session on like exploiting speculative execution properties

969
01:16:53,460 --> 01:16:56,220
and see if they can make attacks work.

970
01:16:57,210 --> 01:17:01,800
And maybe a larger question is whether, you know whether the situation is,

971
01:17:01,830 --> 01:17:08,700
well you know there's you know fifteen or twenty or thirty things that sort of have to be worked out

972
01:17:08,700 --> 01:17:10,380
and then we'll be done,

973
01:17:11,470 --> 01:17:20,330
or whether there's some much higher levels approach gone wrong,

974
01:17:20,360 --> 01:17:23,970
you know that we all, this is probably way too pessimistic,

975
01:17:23,970 --> 01:17:27,510
but people have a lot of faith in isolation as an idea,

976
01:17:27,510 --> 01:17:29,460
that there's a totally reasonable thing to do,

977
01:17:30,900 --> 01:17:33,450
assume that isolation works and will design stuff

978
01:17:33,450 --> 01:17:38,970
like cloud computing and running Javascript in the browser and all this stuff under the assumption,

979
01:17:39,000 --> 01:17:43,020
which is not actually true, but it was close enough believed to be close enough to true,

980
01:17:43,260 --> 01:17:47,520
that isolation will just you know cause they're not to be serious security problems

981
01:17:47,850 --> 01:17:50,690
and that's actually probably still doable,

982
01:17:50,900 --> 01:17:59,750
but this whole bag of micro-architectural attacks not made that story seem more convincing, that's for sure.

983
01:18:02,400 --> 01:18:04,020
Just to add on to that,

984
01:18:04,410 --> 01:18:09,630
I'm not sure a payoff levels expertise would like CPU design,

985
01:18:09,630 --> 01:18:18,210
but to what extent can CPU design be made straightforwardly without a micro-architecture

986
01:18:18,390 --> 01:18:21,810
while still preserving its high performance.

987
01:18:21,990 --> 01:18:25,240
Performance, I mean, people believe this stuff.

988
01:18:25,480 --> 01:18:27,970
Nicely security too, but yeah.

989
01:18:28,060 --> 01:18:30,670
Well, some of this clearly can be fixed like this meltdown thing,

990
01:18:30,670 --> 01:18:34,780
I mean there is a fix this you actually check the permissions,

991
01:18:35,230 --> 01:18:39,010
that probably doesn't sacrifice any performance,

992
01:18:39,220 --> 01:18:40,870
for some of the other attacks that have come up,

993
01:18:43,590 --> 01:18:46,710
it's not clear that you could fix them without sacrificing performance,

994
01:18:46,770 --> 01:18:48,090
I mean some of this very very deep,

995
01:18:48,090 --> 01:18:53,870
like the fact that we're sharing you know, this there's a lot of sharing,

996
01:18:53,870 --> 01:18:57,050
like a time sharing a cloud environment, there's just a lot of sharing

997
01:18:57,290 --> 01:19:06,890
and so, for example suppose there's a disk drive or a network on your cloud server right,

998
01:19:07,400 --> 01:19:11,240
gosh, you might be able to get information about the other people on that cloud server,

999
01:19:11,450 --> 01:19:18,140
simply by watching how their traffic interferes with your traffic disk traffic or network traffic or memory traffic or something.

1000
01:19:18,290 --> 01:19:20,990
So there's some sort of, I, you know I don't know,

1001
01:19:20,990 --> 01:19:27,590
but that's practical, maybe it's not although you know for many many things in which people said point that attack just doesn't seem to be practical,

1002
01:19:27,920 --> 01:19:30,540
you know it turned out to be practical enough.

1003
01:19:32,170 --> 01:19:33,460
And I think.

1004
01:19:34,690 --> 01:19:38,860
And so a lot of this micro-architectural stuff, maybe could be cleaned up without performance loss,

1005
01:19:38,860 --> 01:19:41,050
or maybe can't be cleaned up without performance loss,

1006
01:19:41,350 --> 01:19:48,450
but I think it's, I think it's a much more serious problem than just we're gonna applies fixes,

1007
01:19:50,260 --> 01:19:51,130
they'll go away.

1008
01:19:52,650 --> 01:19:55,710
And the place is the most acute is cryptography,

1009
01:19:55,950 --> 01:20:01,220
there's been many many years of people looking into these kind of clever

1010
01:20:02,210 --> 01:20:12,510
often cache timing based ways of sensing bit set of keys and other people's cryptographic,

1011
01:20:12,930 --> 01:20:17,100
people running running at cryptographic encryption on the same machine as you,

1012
01:20:17,580 --> 01:20:24,130
can you guess anything about my key by watching, by doing cache timing,

1013
01:20:24,490 --> 01:20:25,810
answer is absolutely.

1014
01:20:26,530 --> 01:20:29,140
And it's not a micro-architectural bugs,

1015
01:20:32,010 --> 01:20:34,950
it's just a consequence of sharing often.

1016
01:20:35,620 --> 01:20:37,210
Anyway I don't know how this is gonna play out,

1017
01:20:37,210 --> 01:20:38,800
but it's not it's not straightforward.

1018
01:20:40,610 --> 01:20:44,480
I mean this curious part is when people made progress on,

1019
01:20:44,810 --> 01:20:53,000
just measuring the like [EM] radiation from a CPU and figuring out what instructions are run and what data is in it

1020
01:20:53,270 --> 01:20:55,910
with machine learning with like some accuracy,

1021
01:20:55,910 --> 01:21:01,100
you know not a hundred percent not nearly, but like a scary amount of accuracy,

1022
01:21:01,100 --> 01:21:02,870
because anything over zero is scary.

1023
01:21:07,840 --> 01:21:09,940
Yeah, we all live in you know that's all,

1024
01:21:12,180 --> 01:21:14,970
well there's a boundary between attacks that are,

1025
01:21:17,430 --> 01:21:20,520
there's some threshold between the attacks that are possible,

1026
01:21:20,520 --> 01:21:27,150
but you know gosh just seems like that would be too expensive or awkward painful whatever complex to carry out.

1027
01:21:28,270 --> 01:21:31,220
And, attacks really could be carried out,

1028
01:21:31,220 --> 01:21:33,260
of course we only should defend against the second class,

1029
01:21:33,260 --> 01:21:36,230
because the first class is often too expensive to defend against,

1030
01:21:36,620 --> 01:21:40,430
but as the value of stuff containing computers gets larger

1031
01:21:40,430 --> 01:21:46,220
and attackers get more clever get more closer access to shared environments,

1032
01:21:47,000 --> 01:21:53,590
kind of threshold by which attacks are feasible enough to defend against changes.

1033
01:21:58,610 --> 01:22:03,080
Alright, I'm done with the lecture,

1034
01:22:03,080 --> 01:22:06,110
I'm happy to take more questions, if people have.

1035
01:22:09,210 --> 01:22:09,930
Thank you.

1036
01:22:11,280 --> 01:22:11,880
Thank you.

1037
01:22:12,750 --> 01:22:15,360
Thanks, I actually had a question about the cache,

1038
01:22:15,600 --> 01:22:21,090
so the L1 cache is its per CPU right.

1039
01:22:21,930 --> 01:22:22,530
Yes.

1040
01:22:23,430 --> 01:22:25,080
And L2 isn't shared.

1041
01:22:25,260 --> 01:22:31,680
Well, so this picture is different for each CPU, for different models of CPU, etc,

1042
01:22:31,740 --> 01:22:40,040
the the habit today, is looks it's a little bit more complex than this,

1043
01:22:40,160 --> 01:22:42,080
typically a multiple cores,

1044
01:22:43,170 --> 01:22:46,230
two four eight or 64 something,

1045
01:22:46,980 --> 01:22:48,990
each one has a L1 cache,

1046
01:22:48,990 --> 01:22:50,700
that's quite close to the CPU,

1047
01:22:50,700 --> 01:22:52,830
but it's small fast and small,

1048
01:22:53,130 --> 01:22:55,620
each core typically also has a bigger L2 cache,

1049
01:22:55,620 --> 01:23:01,310
this you know it's sort of dedicated to that CPU.

1050
01:23:04,150 --> 01:23:14,580
And then, and then there's often a shared L3 cache, often but not always

1051
01:23:14,760 --> 01:23:22,430
and another approach is to make the summation of the L2 cache is sort of convenient for all the CPUs to use,

1052
01:23:22,430 --> 01:23:25,280
so that I have super high speed access to my L2 cache,

1053
01:23:25,280 --> 01:23:28,850
but I can get at other people said a slightly bigger penalties,

1054
01:23:28,850 --> 01:23:30,650
the effective cache size larger,

1055
01:23:30,740 --> 01:23:37,850
so often three see either three level caches or or a sort of joint to second level caches.

1056
01:23:41,000 --> 01:23:45,160
And typically the L2 and L3 are physically addressed, L1 is virtual.

1057
01:23:47,980 --> 01:23:54,830
Sorry, so what's the point of having physically address, yeah, yeah it's.

1058
01:23:54,830 --> 01:23:59,810
Yeah it's easy, the stuff in L1 cache, a virtual address cache.

1059
01:24:02,220 --> 01:24:05,850
If the same data is used with different virtual addresses,

1060
01:24:05,850 --> 01:24:09,510
you can't you know the virtual address cache doesn't help you find it,

1061
01:24:10,060 --> 01:24:15,910
if it was cache under a different address where these L2 caches, the data is independent is usable,

1062
01:24:15,910 --> 01:24:18,880
no matter what virtual address you address it and.

1063
01:24:22,380 --> 01:24:27,180
Where does the MMU use, it relative to all these caches in the TLB.

1064
01:24:27,210 --> 01:24:30,180
Oh, it's not it's distributed really,

1065
01:24:30,180 --> 01:24:33,570
because the I mean the most obvious,

1066
01:24:34,530 --> 01:24:37,500
I mean I think in real life,

1067
01:24:38,930 --> 01:24:42,050
the TLB the most critical thing is that TLB

1068
01:24:42,050 --> 01:24:45,200
and I believe it's indexed in parallel with the L1 cache typically.

1069
01:24:46,300 --> 01:24:50,350
So if you hit in the cache, the L1 cache great, although there may be a.

1070
01:24:52,740 --> 01:24:54,300
Anyway, and if you miss the L1 cache,

1071
01:24:54,300 --> 01:24:57,990
then now you have the physical you were looking up in that TLB at the same time,

1072
01:24:57,990 --> 01:25:00,000
now your physical can addressed,

1073
01:25:01,550 --> 01:25:05,690
the MMU that was not just a single box that sits somewhere,

1074
01:25:05,690 --> 01:25:08,350
it's actually kind of involved.

1075
01:25:09,890 --> 01:25:12,080
Okay, but isn't it hardware, so.

1076
01:25:12,230 --> 01:25:13,730
Oh, everything is yours hardware, yeah.

1077
01:25:15,530 --> 01:25:20,480
But remember these you know these chips have billions of transistors on them,

1078
01:25:20,630 --> 01:25:26,900
so yeah, maybe it's hardware, but we're talking about massively complex hardware,

1079
01:25:27,140 --> 01:25:31,700
that's designed using very sophisticated software like design techniques,

1080
01:25:31,730 --> 01:25:36,150
so that it can do very very complex and sophisticated things,

1081
01:25:36,510 --> 01:25:41,660
so yeah its hardware but, yeah, it's not at all at all straightforward.

1082
01:25:43,320 --> 01:25:49,800
So do table mapping like page table mappings ever end up in the caches at all

1083
01:25:49,800 --> 01:25:52,260
or are they always just routed through that TLB,

1084
01:25:52,290 --> 01:25:55,890
because if you miss it, that TLB you have to go to memory retrieve.

1085
01:25:55,890 --> 01:25:59,640
That right, so they're certainly the L2 cache will hold,

1086
01:26:00,790 --> 01:26:07,070
the form the point of view the L2 cache, TLB misses, TLB reloads are just memory accesses,

1087
01:26:07,070 --> 01:26:09,560
so that TLB needs to load a bunch of page table junk,

1088
01:26:09,860 --> 01:26:11,240
it's just a memory load

1089
01:26:11,240 --> 01:26:13,970
and it could use, stuff could easily be cached in the L2.

1090
01:26:13,970 --> 01:26:15,140
But it has to skip to L1,

1091
01:26:15,140 --> 01:26:17,180
because L1 has virtual addresses, but.

1092
01:26:17,180 --> 01:26:21,200
I don't know think that TLB would consult the L1 for its.

1093
01:26:21,200 --> 01:26:21,560
Okay.

1094
01:26:22,510 --> 01:26:24,700
Because it's virtually address, yes.

1095
01:26:25,980 --> 01:26:29,070
And then one thing about the spectre attack.

1096
01:26:30,110 --> 01:26:32,510
How would you, I,

1097
01:26:32,540 --> 01:26:37,190
so so the thing is like I've heard about meltdown inspector like at least a dozen times

1098
01:26:37,190 --> 01:26:39,710
and every time I looked it up I would not understand it,

1099
01:26:39,710 --> 01:26:42,230
so this is the first time I actually understand what's going on,

1100
01:26:42,410 --> 01:26:47,970
but for spectre is there, like how similar is it to meltdown.

1101
01:26:47,970 --> 01:26:48,600
It's not.

1102
01:26:48,840 --> 01:26:50,430
It's not, okay.

1103
01:26:52,230 --> 01:26:53,970
Or, that they will,

1104
01:26:55,560 --> 01:26:59,700
my understanding the spectre attack is by training the branch predictor,

1105
01:26:59,730 --> 01:27:05,880
that you know the other code that you're trying to get attack stuff from.

1106
01:27:05,910 --> 01:27:11,060
Let's suppose it's another process you share some memory with it, right.

1107
01:27:11,060 --> 01:27:14,180
Yeah, because you're it's really the same program as you,

1108
01:27:14,180 --> 01:27:17,090
but it's some other user running the program, right.

1109
01:27:18,040 --> 01:27:29,920
You can, the branch, the branch, the tables the branch predictor uses are shared between different,

1110
01:27:29,920 --> 01:27:34,390
if I run a CPU [forbidden], that you run or maybe run on different hyper threads of the same CPU,

1111
01:27:34,390 --> 01:27:37,990
everybody sees the same branch sees the same branch predictor,

1112
01:27:38,020 --> 01:27:41,350
so I can train the branch predictor to predict branches in a certain way,

1113
01:27:41,590 --> 01:27:42,970
and then I'll let you run,

1114
01:27:44,230 --> 01:27:47,890
you're running with my branch predictor training right

1115
01:27:47,890 --> 01:27:53,980
and so that means I can essentially trick your program into speculatively executing instructions of my choice.

1116
01:27:54,790 --> 01:27:56,830
Right, now it's only speculative, so of course they'll be undone,

1117
01:27:56,830 --> 01:28:00,370
but they they will cause cache loads,

1118
01:28:00,880 --> 01:28:03,580
that to some extent I can control.

1119
01:28:04,180 --> 01:28:05,920
Because I control how you speculatively execute

1120
01:28:05,920 --> 01:28:09,340
and then if we share memory I can use flush and reload to sense

1121
01:28:09,930 --> 01:28:13,890
what cache lines your program loaded this speculative execution.

1122
01:28:15,390 --> 01:28:20,130
Oh, so in that case, you don't need to, you don't need to,

1123
01:28:20,130 --> 01:28:24,750
like know like directly address address a piece of memory,

1124
01:28:24,750 --> 01:28:28,590
you just need to make sure that program will specularly executed,

1125
01:28:28,740 --> 01:28:31,020
like in meltdown, we did it ourselves,

1126
01:28:31,020 --> 01:28:34,200
but in spectre just directed there,

1127
01:28:34,590 --> 01:28:40,080
that's kind of cool, because you can just say oh you know just go and load that secret by training the branch predictor,

1128
01:28:40,080 --> 01:28:41,610
without knowing where the secret is,

1129
01:28:42,300 --> 01:28:43,650
like you gotta know someone,

1130
01:28:43,740 --> 01:28:45,510
yeah you kind of have to know.

1131
01:28:45,510 --> 01:28:47,160
You need to know great [] and great detail.

1132
01:28:47,160 --> 01:28:49,170
Yeah sorry, you have to know.

1133
01:28:49,350 --> 01:28:51,030
But you have to yourself.

1134
01:28:51,060 --> 01:28:51,390
Yes.

1135
01:28:51,390 --> 01:28:53,580
That's not secret, you're probably running a program that,

1136
01:28:54,000 --> 01:28:55,140
I know what program you're running.

1137
01:28:55,140 --> 01:28:59,380
Yeah, okay, that makes sense, thank you.

1138
01:29:01,700 --> 01:29:02,990
Yeah, I was just wondering,

1139
01:29:02,990 --> 01:29:06,830
it seems like when you when a research paper, like this gets released,

1140
01:29:06,830 --> 01:29:14,750
it's out there for like people, Linux and Windows and like Intel for them to try to go and scramble to patch the bug,

1141
01:29:14,750 --> 01:29:17,900
but it's also out there for hackers can start to learn from the paper,

1142
01:29:17,900 --> 01:29:19,640
like oh this is a method we could use,

1143
01:29:20,190 --> 01:29:25,470
and I'm I'm wondering, like it as a researcher is there a general practice

1144
01:29:25,470 --> 01:29:31,170
of like as we're working on the paper will sort of tipoff the quote unquote good guys first,

1145
01:29:31,170 --> 01:29:32,040
so that they can have.

1146
01:29:32,040 --> 01:29:38,550
Yeah, authors informed every you know the CPU manufacturers and OS manufacturers before they publish the paper.

1147
01:29:39,030 --> 01:29:40,830
There's a whole, there's a whole protocol,

1148
01:29:41,460 --> 01:29:46,020
you know these kind of things would even be accepted anymore, unless you follow the protocol.

1149
01:29:46,650 --> 01:29:48,660
That doesn't mean the attackers weren't already using it right,

1150
01:29:48,660 --> 01:29:52,650
because you probably know the attackers discovered this twenty years ago, but.

1151
01:29:53,070 --> 01:29:56,430
Great, thank you.

1152
01:29:57,480 --> 01:30:04,290
It's not straightforward, I think in this particular case, I think you know what some Intel was not too excited about,

1153
01:30:05,020 --> 01:30:08,530
the collaboration between the Linux community and Intel was not completely smooth, I think.

1154
01:30:10,940 --> 01:30:14,690
When this happened, I think they worked at some of the [], but.

1155
01:30:18,670 --> 01:30:19,990
I think it was kind of scary,

1156
01:30:19,990 --> 01:30:28,570
because I I read on Wikipedia, that the Ubuntu fix was published after the paper was published,

1157
01:30:28,600 --> 01:30:31,030
which I found scary, but.

1158
01:30:38,120 --> 01:30:40,490
Thank you so much.

1159
01:30:42,240 --> 01:30:42,960
Thank you.

1160
01:30:43,170 --> 01:30:45,660
Thank you, well see you next week.

