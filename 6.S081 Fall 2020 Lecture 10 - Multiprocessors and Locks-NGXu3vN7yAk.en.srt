1
00:00:00,080 --> 00:00:02,080
valid address yeah he had to be not so

2
00:00:02,080 --> 00:00:06,869
good

3
00:00:06,879 --> 00:00:10,639
good how about erica how's the

4
00:00:10,639 --> 00:00:13,120
lazy life for you um i also thought it

5
00:00:13,120 --> 00:00:13,679
was okay

6
00:00:13,679 --> 00:00:16,000
and um i also had a bug with the coffee

7
00:00:16,000 --> 00:00:17,600
and coffee app but uh

8
00:00:17,600 --> 00:00:20,880
got that result so yeah yeah i think

9
00:00:20,880 --> 00:00:21,680
it's one of those

10
00:00:21,680 --> 00:00:22,960
tricky cases that you might not think

11
00:00:22,960 --> 00:00:26,320
about when you start programming

12
00:00:26,320 --> 00:00:28,840
but luckily user tests will find it for

13
00:00:28,840 --> 00:00:34,150
you

14
00:00:34,160 --> 00:00:37,520
caroline ortega

15
00:00:37,520 --> 00:00:39,600
the lab is going good um i haven't

16
00:00:39,600 --> 00:00:42,950
finished yet actually

17
00:00:42,960 --> 00:00:52,470
all right so worry about copying i guess

18
00:00:52,480 --> 00:00:56,229
how about kendall garner

19
00:00:56,239 --> 00:00:59,440
i think for the most part it was

20
00:00:59,440 --> 00:01:02,239
not too bad for me probably the weirdest

21
00:01:02,239 --> 00:01:04,159
part was just trying to figure out when

22
00:01:04,159 --> 00:01:04,799
it went

23
00:01:04,799 --> 00:01:08,799
below bounds of the stack

24
00:01:08,799 --> 00:01:16,870
ah yeah into the guard page basically

25
00:01:16,880 --> 00:01:20,080
good okay well

26
00:01:20,080 --> 00:01:23,439
uh so it's about time to get started uh

27
00:01:23,439 --> 00:01:26,720
so welcome to the next lecture in

28
00:01:26,720 --> 00:01:29,280
s081 wherever you are in whatever time

29
00:01:29,280 --> 00:01:31,439
zone

30
00:01:31,439 --> 00:01:34,720
so today's lecture is about locks

31
00:01:34,720 --> 00:01:36,799
and you probably have seen locks in

32
00:01:36,799 --> 00:01:38,640
previous classes

33
00:01:38,640 --> 00:01:40,560
or at least i've been in touch with them

34
00:01:40,560 --> 00:01:42,079
in some way or another uh

35
00:01:42,079 --> 00:01:43,520
and so this lecture's a little bit of a

36
00:01:43,520 --> 00:01:45,439
conceptual lecture uh may overlap a

37
00:01:45,439 --> 00:01:47,040
little bit with some uh

38
00:01:47,040 --> 00:01:48,640
things you've seen before for locks but

39
00:01:48,640 --> 00:01:50,640
we'll uh have a little bit more of a

40
00:01:50,640 --> 00:01:52,479
kernel and os focus

41
00:01:52,479 --> 00:01:55,600
and that changes a couple things um so

42
00:01:55,600 --> 00:01:57,439
just to get started you know let's just

43
00:01:57,439 --> 00:01:58,320
remind ourselves

44
00:01:58,320 --> 00:02:01,759
uh why we need locks um you know and i

45
00:02:01,759 --> 00:02:03,040
guess the starting point is really that

46
00:02:03,040 --> 00:02:05,119
applications

47
00:02:05,119 --> 00:02:12,229
uh want to use multiple cores

48
00:02:12,239 --> 00:02:13,520
they want to use multiple cores to get

49
00:02:13,520 --> 00:02:16,869
performance

50
00:02:16,879 --> 00:02:20,080
and so if an application actually

51
00:02:20,080 --> 00:02:22,080
wants to do runs on multiple cores and

52
00:02:22,080 --> 00:02:23,599
presumably once the in

53
00:02:23,599 --> 00:02:24,720
this course or the parts of the

54
00:02:24,720 --> 00:02:26,640
application may invoke system calls

55
00:02:26,640 --> 00:02:30,160
and so the kernel must be able to handle

56
00:02:30,160 --> 00:02:45,430
uh you must handle parallel system calls

57
00:02:45,440 --> 00:02:47,840
uh and that means that you know if these

58
00:02:47,840 --> 00:02:49,760
system calls run in parallel on

59
00:02:49,760 --> 00:02:51,280
different course

60
00:02:51,280 --> 00:02:54,239
they may actually access shared data

61
00:02:54,239 --> 00:02:58,229
structures

62
00:02:58,239 --> 00:03:04,319
the instructions in parallel

63
00:03:04,319 --> 00:03:06,800
and as you've seen by now actually x6

64
00:03:06,800 --> 00:03:08,159
has quite a number of

65
00:03:08,159 --> 00:03:09,599
you know shared data structures you know

66
00:03:09,599 --> 00:03:12,000
whether it's the proc structures or

67
00:03:12,000 --> 00:03:16,080
uh you know ticks or you know

68
00:03:16,080 --> 00:03:17,840
later we'll see the buffer cache you

69
00:03:17,840 --> 00:03:19,360
know there's actually a ton of shared

70
00:03:19,360 --> 00:03:20,959
data structures

71
00:03:20,959 --> 00:03:24,400
um and so if you have parallaxis you

72
00:03:24,400 --> 00:03:25,200
know through

73
00:03:25,200 --> 00:03:28,000
a data structure and one of the you know

74
00:03:28,000 --> 00:03:29,360
course is a writer and the other course

75
00:03:29,360 --> 00:03:30,400
is a reader

76
00:03:30,400 --> 00:03:32,400
uh you know we need basically blocks you

77
00:03:32,400 --> 00:03:34,159
know to coordinate these updates to the

78
00:03:34,159 --> 00:03:36,080
shared data structure so that

79
00:03:36,080 --> 00:03:38,799
readers see a consistent view so we'll

80
00:03:38,799 --> 00:03:41,040
need logs

81
00:03:41,040 --> 00:03:44,000
you know to you know for controlled

82
00:03:44,000 --> 00:03:45,440
sharing

83
00:03:45,440 --> 00:03:52,949
or for correct sharing

84
00:03:52,959 --> 00:03:54,560
now this is in some sense a little bit

85
00:03:54,560 --> 00:03:56,159
of a bummer

86
00:03:56,159 --> 00:03:59,760
because you know we want this parallexis

87
00:03:59,760 --> 00:04:02,080
we want to run multiple uh consistent

88
00:04:02,080 --> 00:04:02,799
calls in

89
00:04:02,799 --> 00:04:06,159
uh in parallel on a different course

90
00:04:06,159 --> 00:04:08,400
but unfortunately you know if they share

91
00:04:08,400 --> 00:04:10,000
the data structures you know they need

92
00:04:10,000 --> 00:04:12,400
locks and locks no serialize

93
00:04:12,400 --> 00:04:14,959
basically operations and so in fact you

94
00:04:14,959 --> 00:04:16,400
know locks in the end can limit

95
00:04:16,400 --> 00:04:27,189
performance

96
00:04:27,199 --> 00:04:28,320
and so we're sort of in a tricky

97
00:04:28,320 --> 00:04:30,160
situation where you know for correctness

98
00:04:30,160 --> 00:04:31,040
we need locks

99
00:04:31,040 --> 00:04:33,040
you know but for performance uh they're

100
00:04:33,040 --> 00:04:34,320
not good

101
00:04:34,320 --> 00:04:36,320
uh but you know sort of it's going to be

102
00:04:36,320 --> 00:04:37,759
sort of a fact of life and

103
00:04:37,759 --> 00:04:40,320
uh you know we'll see what we can do

104
00:04:40,320 --> 00:04:41,520
about it

105
00:04:41,520 --> 00:04:43,520
but that's sort of the top-level uh

106
00:04:43,520 --> 00:04:44,720
scenario here

107
00:04:44,720 --> 00:04:47,120
and you know maybe just to really you

108
00:04:47,120 --> 00:04:47,840
know uh

109
00:04:47,840 --> 00:04:49,600
bring this point why do applications

110
00:04:49,600 --> 00:04:50,880
actually want to uh

111
00:04:50,880 --> 00:04:52,639
multiple course and now that really has

112
00:04:52,639 --> 00:04:54,639
to do with your technology trends you

113
00:04:54,639 --> 00:04:55,840
know over the last you know a couple

114
00:04:55,840 --> 00:04:56,800
decades

115
00:04:56,800 --> 00:04:58,160
uh and you know there's sort of this

116
00:04:58,160 --> 00:05:00,080
classic graph that sort of make these

117
00:05:00,080 --> 00:05:00,720
points

118
00:05:00,720 --> 00:05:02,639
uh so let me you know pull up one of

119
00:05:02,639 --> 00:05:03,600
them there's a little bit of a

120
00:05:03,600 --> 00:05:04,639
complicated graph

121
00:05:04,639 --> 00:05:08,639
uh but you know there's years on the

122
00:05:08,639 --> 00:05:12,160
x-axis and y-axis there's you know units

123
00:05:12,160 --> 00:05:13,440
uh they're different types of units

124
00:05:13,440 --> 00:05:14,960
depending on you know which line we're

125
00:05:14,960 --> 00:05:16,080
looking at

126
00:05:16,080 --> 00:05:17,680
uh but the thing that really to look at

127
00:05:17,680 --> 00:05:19,759
is that uh

128
00:05:19,759 --> 00:05:22,000
what has happened in the last couple

129
00:05:22,000 --> 00:05:24,000
years is that over the last decades is

130
00:05:24,000 --> 00:05:24,210
that

131
00:05:24,210 --> 00:05:25,440
[Music]

132
00:05:25,440 --> 00:05:28,080
starting in the 2000s that the clock

133
00:05:28,080 --> 00:05:29,199
frequency

134
00:05:29,199 --> 00:05:32,160
hasn't really increased anymore uh so

135
00:05:32,160 --> 00:05:33,520
basically this has you know

136
00:05:33,520 --> 00:05:36,960
plateaued or constant

137
00:05:36,960 --> 00:05:40,479
um and as a result you know basically

138
00:05:40,479 --> 00:05:41,039
single

139
00:05:41,039 --> 00:05:43,680
threat performance of the core also you

140
00:05:43,680 --> 00:05:44,880
know basically

141
00:05:44,880 --> 00:05:46,880
uh has reached you know sort of a limit

142
00:05:46,880 --> 00:05:52,000
you know or plotted

143
00:05:52,000 --> 00:05:54,080
uh and yet on the other hand given the

144
00:05:54,080 --> 00:05:56,160
minimum course of the number transistors

145
00:05:56,160 --> 00:05:58,000
still has been increasing over the same

146
00:05:58,000 --> 00:06:00,000
time period so if you can't like you

147
00:06:00,000 --> 00:06:01,680
know use transistors to make a single

148
00:06:01,680 --> 00:06:03,280
core sort of run faster

149
00:06:03,280 --> 00:06:04,639
uh you know the only other option

150
00:06:04,639 --> 00:06:05,680
basically have is you know i have

151
00:06:05,680 --> 00:06:07,520
multiple cores and you see indeed that's

152
00:06:07,520 --> 00:06:09,600
starting from 2001 or from the early

153
00:06:09,600 --> 00:06:11,280
2000s you know the number of course has

154
00:06:11,280 --> 00:06:13,360
gone up

155
00:06:13,360 --> 00:06:14,720
and so there's an application once more

156
00:06:14,720 --> 00:06:16,479
performance you know

157
00:06:16,479 --> 00:06:18,479
uh you know can rely on the single core

158
00:06:18,479 --> 00:06:20,160
it basically has to explode multiple

159
00:06:20,160 --> 00:06:21,039
cores

160
00:06:21,039 --> 00:06:22,960
and also this means if an application is

161
00:06:22,960 --> 00:06:24,800
you know kernel intensive os

162
00:06:24,800 --> 00:06:28,560
intensive you know whereas like a server

163
00:06:28,560 --> 00:06:29,680
then that means that the operating

164
00:06:29,680 --> 00:06:32,000
system also has to be

165
00:06:32,000 --> 00:06:34,800
run efficiently on multiple cores and so

166
00:06:34,800 --> 00:06:36,400
that's the main reason

167
00:06:36,400 --> 00:06:37,919
uh you know that we're sort of very

168
00:06:37,919 --> 00:06:39,840
interested in

169
00:06:39,840 --> 00:06:41,919
you know parallelism you know within the

170
00:06:41,919 --> 00:06:45,029
in the kernel

171
00:06:45,039 --> 00:06:51,909
any questions about this

172
00:06:51,919 --> 00:06:53,440
okay i've seen i i assume that you've

173
00:06:53,440 --> 00:06:55,120
seen some of these graphs uh before but

174
00:06:55,120 --> 00:06:55,680
it's

175
00:06:55,680 --> 00:06:56,960
good to remind us you know what the

176
00:06:56,960 --> 00:06:59,520
starting point of all the discussion is

177
00:06:59,520 --> 00:07:02,880
um so why logs

178
00:07:02,880 --> 00:07:04,400
you know already hinted at this you know

179
00:07:04,400 --> 00:07:06,720
they're there for uh correctness

180
00:07:06,720 --> 00:07:09,680
uh you know if we have you know readers

181
00:07:09,680 --> 00:07:10,720
and writers you know

182
00:07:10,720 --> 00:07:12,880
exiting a shared data structure and you

183
00:07:12,880 --> 00:07:14,240
know the thing that goes wrong

184
00:07:14,240 --> 00:07:23,350
is that we want to avoid race conditions

185
00:07:23,360 --> 00:07:25,440
so if you don't have locks you know we

186
00:07:25,440 --> 00:07:26,560
run the risk you know

187
00:07:26,560 --> 00:07:27,840
we have shear data structures that we're

188
00:07:27,840 --> 00:07:30,880
going to have uh

189
00:07:30,880 --> 00:07:32,639
we're going to have raised detect

190
00:07:32,639 --> 00:07:34,639
conditions and it turns out that the

191
00:07:34,639 --> 00:07:35,759
race conditions are

192
00:07:35,759 --> 00:07:39,039
uh pretty annoying um and so just

193
00:07:39,039 --> 00:07:40,479
first can we get a little bit of sense

194
00:07:40,479 --> 00:07:43,120
of what it actually is let's look at the

195
00:07:43,120 --> 00:07:45,199
let's just let's create a race condition

196
00:07:45,199 --> 00:07:46,319
in xv6 and

197
00:07:46,319 --> 00:07:48,000
sort of see how it actually shows up and

198
00:07:48,000 --> 00:07:49,599
then understand like look what actually

199
00:07:49,599 --> 00:07:51,199
happened

200
00:07:51,199 --> 00:07:54,400
uh so here's uh

201
00:07:54,400 --> 00:07:58,639
our function k3 uh in calc.c you know so

202
00:07:58,639 --> 00:08:00,479
this is the function that frees

203
00:08:00,479 --> 00:08:02,080
after you free page it puts it on the

204
00:08:02,080 --> 00:08:03,599
free list you know the

205
00:08:03,599 --> 00:08:05,360
kernel has a very simple data structure

206
00:08:05,360 --> 00:08:07,599
to keep the free list of all three pages

207
00:08:07,599 --> 00:08:09,520
uh so that one calendar needs a page

208
00:08:09,520 --> 00:08:10,639
that actually can grab it from the free

209
00:08:10,639 --> 00:08:11,599
glitch

210
00:08:11,599 --> 00:08:14,720
you see here the uh

211
00:08:14,720 --> 00:08:18,440
allocation has one uh the the

212
00:08:18,440 --> 00:08:21,039
the memory allocator has one lock came

213
00:08:21,039 --> 00:08:22,000
in lock

214
00:08:22,000 --> 00:08:24,319
and uh here it actually updates the free

215
00:08:24,319 --> 00:08:25,120
list

216
00:08:25,120 --> 00:08:27,280
uh within page that just has been

217
00:08:27,280 --> 00:08:29,840
treated or the argument to three

218
00:08:29,840 --> 00:08:31,520
so we're gonna do is like just comment

219
00:08:31,520 --> 00:08:32,959
out these two

220
00:08:32,959 --> 00:08:35,519
acquire releases that basically uh mark

221
00:08:35,519 --> 00:08:36,640
you know the

222
00:08:36,640 --> 00:08:38,240
acquiring of the lock and then releasing

223
00:08:38,240 --> 00:08:40,080
the lock you know and so this this

224
00:08:40,080 --> 00:08:42,159
this this piece of code that sits in the

225
00:08:42,159 --> 00:08:44,320
middle uh that used to be

226
00:08:44,320 --> 00:08:46,080
uh there's now not more it's not being

227
00:08:46,080 --> 00:08:47,519
executed anymore

228
00:08:47,519 --> 00:08:54,160
atomically uh

229
00:08:54,160 --> 00:08:57,440
so let's do that uh

230
00:08:57,440 --> 00:09:01,519
and then run uh

231
00:09:01,519 --> 00:09:05,269
qmu so we'll compile it

232
00:09:05,279 --> 00:09:08,160
and you know before i run it in a notice

233
00:09:08,160 --> 00:09:09,360
actually we already booted

234
00:09:09,360 --> 00:09:12,160
and actually uh presumably have made

235
00:09:12,160 --> 00:09:13,440
some calls probably to

236
00:09:13,440 --> 00:09:15,839
k3 as you probably as you know and so

237
00:09:15,839 --> 00:09:18,000
effective things seem to be working fine

238
00:09:18,000 --> 00:09:20,720
so let's run user tests and maybe you

239
00:09:20,720 --> 00:09:22,240
know it's interesting to think a little

240
00:09:22,240 --> 00:09:23,600
bit about this now what do you expect

241
00:09:23,600 --> 00:09:24,320
will this

242
00:09:24,320 --> 00:09:28,870
work will this not work

243
00:09:28,880 --> 00:09:33,350
anybody who tried it out

244
00:09:33,360 --> 00:09:36,000
i think it could potentially lose some

245
00:09:36,000 --> 00:09:36,640
pages

246
00:09:36,640 --> 00:09:39,680
but maybe it will not because

247
00:09:39,680 --> 00:09:42,800
uh maybe a race condition wouldn't occur

248
00:09:42,800 --> 00:09:44,320
yeah so one of the things is that these

249
00:09:44,320 --> 00:09:45,839
uh with race conditions they might not

250
00:09:45,839 --> 00:09:46,560
happen so let's

251
00:09:46,560 --> 00:09:48,839
run the user test and see actually what

252
00:09:48,839 --> 00:09:50,800
happens

253
00:09:50,800 --> 00:09:54,320
um so here we start it up

254
00:09:54,320 --> 00:09:55,920
uh take a little while zoom might

255
00:09:55,920 --> 00:09:58,399
complain a little bit because you know

256
00:09:58,399 --> 00:10:01,760
running a lot of put a lot of load in my

257
00:10:01,760 --> 00:10:03,040
machine here correctly if you probably

258
00:10:03,040 --> 00:10:03,440
know

259
00:10:03,440 --> 00:10:07,040
the q mu simulating free cores here and

260
00:10:07,040 --> 00:10:08,480
the discrete course might run in

261
00:10:08,480 --> 00:10:11,910
parallel

262
00:10:11,920 --> 00:10:14,160
and you know so far so good you know

263
00:10:14,160 --> 00:10:16,839
we're starting to pass

264
00:10:16,839 --> 00:10:21,430
tests

265
00:10:21,440 --> 00:10:22,720
that's a little bit slower because i'm

266
00:10:22,720 --> 00:10:27,030
running zoom at the same time

267
00:10:27,040 --> 00:10:29,360
let's wait a couple more and just uh see

268
00:10:29,360 --> 00:10:43,110
what's going on

269
00:10:43,120 --> 00:10:46,160
okay well uh

270
00:10:46,160 --> 00:10:48,480
let's uh just go back to the slides and

271
00:10:48,480 --> 00:10:50,240
then we'll check back in in a little

272
00:10:50,240 --> 00:10:52,880
while so to see what actually happens

273
00:10:52,880 --> 00:10:55,040
uh but you know as pointed out you know

274
00:10:55,040 --> 00:10:56,640
these race conditions may appear may not

275
00:10:56,640 --> 00:10:57,600
appear right because

276
00:10:57,600 --> 00:10:59,279
it is always the case that you know

277
00:10:59,279 --> 00:11:02,320
every core or every time we call k3

278
00:11:02,320 --> 00:11:04,480
these two u lines are executed

279
00:11:04,480 --> 00:11:05,360
atomically

280
00:11:05,360 --> 00:11:08,320
uh as as they would have done with the

281
00:11:08,320 --> 00:11:09,040
lock

282
00:11:09,040 --> 00:11:10,880
then there's no problem and the only

283
00:11:10,880 --> 00:11:12,959
problem is like between two frets or two

284
00:11:12,959 --> 00:11:14,000
processors executed

285
00:11:14,000 --> 00:11:15,680
at the same time and so becomes in

286
00:11:15,680 --> 00:11:17,120
between

287
00:11:17,120 --> 00:11:18,880
look at this actually you know while i'm

288
00:11:18,880 --> 00:11:20,320
talking you know we see actually there

289
00:11:20,320 --> 00:11:22,160
is a panic and so there is some race

290
00:11:22,160 --> 00:11:23,440
condition that can actually cause a

291
00:11:23,440 --> 00:11:25,680
panic

292
00:11:25,680 --> 00:11:27,279
there are other race conditions that

293
00:11:27,279 --> 00:11:29,120
will show up as indeed as uh

294
00:11:29,120 --> 00:11:32,079
as mentioned or as well answered that

295
00:11:32,079 --> 00:11:33,120
will show up as like

296
00:11:33,120 --> 00:11:34,720
not enough you know some free pages

297
00:11:34,720 --> 00:11:36,560
where some pages get lost so basically

298
00:11:36,560 --> 00:11:38,959
user test runs fine until the very end

299
00:11:38,959 --> 00:11:41,279
where it complains saying well you lost

300
00:11:41,279 --> 00:11:43,440
some pages during uh all usual

301
00:11:43,440 --> 00:11:46,560
all of the rounds of user test okay so

302
00:11:46,560 --> 00:11:48,000
these race conditions can show up in

303
00:11:48,000 --> 00:11:48,800
different ways

304
00:11:48,800 --> 00:11:50,959
uh they may happen they may not happen

305
00:11:50,959 --> 00:11:52,880
uh clearly something happened here

306
00:11:52,880 --> 00:11:55,120
uh so let's try to understand you know

307
00:11:55,120 --> 00:11:56,320
what what what actually

308
00:11:56,320 --> 00:12:01,190
uh what goes wrong

309
00:12:01,200 --> 00:12:07,030
back to the slides

310
00:12:07,040 --> 00:12:08,639
so the picture you should have in your

311
00:12:08,639 --> 00:12:10,240
head like so there's this

312
00:12:10,240 --> 00:12:13,120
multiple cores that we're running so

313
00:12:13,120 --> 00:12:14,639
here's cpu0

314
00:12:14,639 --> 00:12:17,519
so cpu0 is executing instructions and

315
00:12:17,519 --> 00:12:18,240
cpu one

316
00:12:18,240 --> 00:12:21,680
is executing instructions and

317
00:12:21,680 --> 00:12:24,160
they're both connected you know to a

318
00:12:24,160 --> 00:12:25,440
memory right if you're

319
00:12:25,440 --> 00:12:27,040
looking back think back up at the scheme

320
00:12:27,040 --> 00:12:28,320
schematics you know that we've shown a

321
00:12:28,320 --> 00:12:29,440
couple times before

322
00:12:29,440 --> 00:12:31,760
in fact there's a dram controller you

323
00:12:31,760 --> 00:12:33,680
know that actually

324
00:12:33,680 --> 00:12:36,560
uh connects you know to the drm chips

325
00:12:36,560 --> 00:12:38,639
where all the stage is living

326
00:12:38,639 --> 00:12:41,440
uh or all the memory is living so i'm

327
00:12:41,440 --> 00:12:42,480
going to make that memory a little bit

328
00:12:42,480 --> 00:12:45,910
bigger because i want to

329
00:12:45,920 --> 00:12:48,000
have some place to draw and so basically

330
00:12:48,000 --> 00:12:49,200
our tree list

331
00:12:49,200 --> 00:12:52,959
you know lives in

332
00:12:52,959 --> 00:12:55,200
in memory and let's say there's a free

333
00:12:55,200 --> 00:12:59,670
list with two pages on it

334
00:12:59,680 --> 00:13:03,920
and you know both

335
00:13:03,920 --> 00:13:06,959
both cpus you know call k3 roughly at

336
00:13:06,959 --> 00:13:13,430
the same time

337
00:13:13,440 --> 00:13:15,040
and so look at a little bit of the code

338
00:13:15,040 --> 00:13:16,720
again just to make sure that we

339
00:13:16,720 --> 00:13:18,320
have this variable in our head so we

340
00:13:18,320 --> 00:13:20,240
look at k3 uh

341
00:13:20,240 --> 00:13:23,040
you know they're get passed in some pa a

342
00:13:23,040 --> 00:13:24,480
physical address

343
00:13:24,480 --> 00:13:26,160
that we're going to use to actually hook

344
00:13:26,160 --> 00:13:29,920
up you know into the free list

345
00:13:29,920 --> 00:13:34,639
so you know cpu 0 has uh

346
00:13:34,639 --> 00:13:38,320
you know an r uh and

347
00:13:38,320 --> 00:13:40,399
that's pointing to to some you know free

348
00:13:40,399 --> 00:13:41,600
page

349
00:13:41,600 --> 00:13:44,959
and uh maybe yeah and

350
00:13:44,959 --> 00:13:47,519
cpu one has one let me actually use

351
00:13:47,519 --> 00:13:49,440
another column for cpu 1.

352
00:13:49,440 --> 00:13:52,320
so cpu knows it has an r it also is pin

353
00:13:52,320 --> 00:13:53,519
pointing to some page

354
00:13:53,519 --> 00:13:54,880
you know that we want to hook into the

355
00:13:54,880 --> 00:13:58,949
free list make sense

356
00:13:58,959 --> 00:14:01,199
and so you know we look back at the code

357
00:14:01,199 --> 00:14:02,240
uh

358
00:14:02,240 --> 00:14:04,160
you know the first thing they do is you

359
00:14:04,160 --> 00:14:05,839
know update our next to point to

360
00:14:05,839 --> 00:14:09,199
uh to point to the to the free list

361
00:14:09,199 --> 00:14:12,240
so let's assume you know that cpu one

362
00:14:12,240 --> 00:14:12,959
runs

363
00:14:12,959 --> 00:14:16,160
uh first and you know what it will do

364
00:14:16,160 --> 00:14:19,600
is we'll put its pointer you know to

365
00:14:19,600 --> 00:14:22,880
the beginning of the uh you know to

366
00:14:22,880 --> 00:14:25,040
wherever freelance is pointing to

367
00:14:25,040 --> 00:14:27,680
and if you know cpr and runs exactly at

368
00:14:27,680 --> 00:14:29,360
the same time

369
00:14:29,360 --> 00:14:32,639
then uh you know

370
00:14:32,639 --> 00:14:35,040
it could run you know before you know

371
00:14:35,040 --> 00:14:37,440
cpu0 executes a second instruction

372
00:14:37,440 --> 00:14:38,720
and so it actually might do the same

373
00:14:38,720 --> 00:14:40,000
thing you know it might actually also

374
00:14:40,000 --> 00:14:41,519
run that first instruction

375
00:14:41,519 --> 00:14:51,269
and update um

376
00:14:51,279 --> 00:14:55,360
and update the pointer 2. so now both

377
00:14:55,360 --> 00:14:57,839
are you know one from cpu 1 and from cpu

378
00:14:57,839 --> 00:14:59,519
zero one for cpo one are pointing to the

379
00:14:59,519 --> 00:15:00,639
beginning of the free list and the free

380
00:15:00,639 --> 00:15:02,160
list is also pointing to the

381
00:15:02,160 --> 00:15:04,240
beginning of the field list and so now

382
00:15:04,240 --> 00:15:05,440
there are two remaining instructions

383
00:15:05,440 --> 00:15:07,600
that are being executed in parallel

384
00:15:07,600 --> 00:15:10,160
so we'll go back again you know the code

385
00:15:10,160 --> 00:15:11,680
you know the remaining instruction is

386
00:15:11,680 --> 00:15:12,480
being executed

387
00:15:12,480 --> 00:15:13,920
is actually updating the free list to

388
00:15:13,920 --> 00:15:17,040
point to r you know uh

389
00:15:17,040 --> 00:15:20,079
and so uh you know cpu you know zero and

390
00:15:20,079 --> 00:15:21,360
one going to execute these instructions

391
00:15:21,360 --> 00:15:21,760
maybe

392
00:15:21,760 --> 00:15:24,160
exactly in the same uh rapidly at the

393
00:15:24,160 --> 00:15:25,680
same time but one is going to go first

394
00:15:25,680 --> 00:15:27,279
correct there's only one single shared

395
00:15:27,279 --> 00:15:28,240
memory

396
00:15:28,240 --> 00:15:30,160
and so one update is going to go first

397
00:15:30,160 --> 00:15:32,160
and the other one is going to go second

398
00:15:32,160 --> 00:15:35,120
so let's say cpu one you know goes first

399
00:15:35,120 --> 00:15:35,680
and now

400
00:15:35,680 --> 00:15:37,519
what will then happen well the cpu one

401
00:15:37,519 --> 00:15:38,800
goes first the three list is gonna be

402
00:15:38,800 --> 00:15:40,320
pointing to sr

403
00:15:40,320 --> 00:15:43,680
right and then cpu 2

404
00:15:43,680 --> 00:15:46,240
runs so now cp2 runs actually this x

405
00:15:46,240 --> 00:15:47,199
instruction

406
00:15:47,199 --> 00:15:49,360
and so what it's going to do it is going

407
00:15:49,360 --> 00:15:50,560
to actually update

408
00:15:50,560 --> 00:15:55,199
you know pre-list two-point

409
00:15:55,199 --> 00:15:58,240
so here's a free list and

410
00:15:58,240 --> 00:16:01,279
it's actually going to point to the r

411
00:16:01,279 --> 00:16:03,680
that actually get passed in and so you

412
00:16:03,680 --> 00:16:05,920
know we have a setting now correct we're

413
00:16:05,920 --> 00:16:08,800
we've lost you know basically one page

414
00:16:08,800 --> 00:16:10,800
the

415
00:16:10,800 --> 00:16:13,199
r you know that actually cpu zero

416
00:16:13,199 --> 00:16:14,160
actually three

417
00:16:14,160 --> 00:16:15,920
actually ended up not being on the free

418
00:16:15,920 --> 00:16:17,199
list at all so

419
00:16:17,199 --> 00:16:22,720
we lost the page

420
00:16:22,720 --> 00:16:24,959
um and that's one you know bad

421
00:16:24,959 --> 00:16:26,399
particular outcome of course it could be

422
00:16:26,399 --> 00:16:28,160
more bad outcomes because there could be

423
00:16:28,160 --> 00:16:30,160
more cpus after trying to do this three

424
00:16:30,160 --> 00:16:30,959
list

425
00:16:30,959 --> 00:16:33,040
uh they may observe the new one of the

426
00:16:33,040 --> 00:16:34,639
my observed three lists pointing

427
00:16:34,639 --> 00:16:36,000
temporarily to the cpu

428
00:16:36,000 --> 00:16:40,079
to zeros r uh and so we start using that

429
00:16:40,079 --> 00:16:41,920
uh well then immediately the freelancer

430
00:16:41,920 --> 00:16:43,519
is updated you know by

431
00:16:43,519 --> 00:16:45,839
uh the second cpu so the more cpu's

432
00:16:45,839 --> 00:16:47,120
involved you know presumably we could

433
00:16:47,120 --> 00:16:49,199
actually get more bizarre outcomes than

434
00:16:49,199 --> 00:16:55,749
just the loss page does this make sense

435
00:16:55,759 --> 00:17:04,799
any questions

436
00:17:04,799 --> 00:17:08,000
okay um so the way

437
00:17:08,000 --> 00:17:10,079
you know ask you know the code does you

438
00:17:10,079 --> 00:17:13,199
know the way to address this uh

439
00:17:13,199 --> 00:17:16,240
one way and a very common way uh is to

440
00:17:16,240 --> 00:17:17,600
address this problem

441
00:17:17,600 --> 00:17:20,720
is to use a lock so let me talk a little

442
00:17:20,720 --> 00:17:22,400
bit about locks

443
00:17:22,400 --> 00:17:26,789
in more detail

444
00:17:26,799 --> 00:17:30,840
so what is a you know what's the lock

445
00:17:30,840 --> 00:17:32,480
abstraction

446
00:17:32,480 --> 00:17:34,960
well uh it is just an object like any

447
00:17:34,960 --> 00:17:35,840
other sort of

448
00:17:35,840 --> 00:17:38,720
uh object in the kernel and then it has

449
00:17:38,720 --> 00:17:39,360
a

450
00:17:39,360 --> 00:17:40,559
there's in fact there's something called

451
00:17:40,559 --> 00:17:43,520
strut lock you know that has some fields

452
00:17:43,520 --> 00:17:46,559
you know to maintain state about locks

453
00:17:46,559 --> 00:17:49,440
and it has a pretty straightforward api

454
00:17:49,440 --> 00:17:51,120
you know there's a

455
00:17:51,120 --> 00:17:52,559
acquired in fact there are only two

456
00:17:52,559 --> 00:17:54,240
calls into this

457
00:17:54,240 --> 00:17:58,470
abstraction uh which

458
00:17:58,480 --> 00:18:01,600
require which takes the uh a pointer to

459
00:18:01,600 --> 00:18:06,640
uh a lock struck and and a release

460
00:18:06,640 --> 00:18:09,840
uh you know that actually uh

461
00:18:09,840 --> 00:18:10,960
also takes a point through the log

462
00:18:10,960 --> 00:18:13,039
struct uh to basically update you know

463
00:18:13,039 --> 00:18:14,799
the lock object

464
00:18:14,799 --> 00:18:16,000
and then basically the rule of the

465
00:18:16,000 --> 00:18:18,240
lighting you know the rule here is that

466
00:18:18,240 --> 00:18:23,590
uh the choir

467
00:18:23,600 --> 00:18:25,600
enforces this uh following rule that

468
00:18:25,600 --> 00:18:26,840
only one

469
00:18:26,840 --> 00:18:30,789
process

470
00:18:30,799 --> 00:18:32,720
you know can enter or can acquire the

471
00:18:32,720 --> 00:18:37,750
lock

472
00:18:37,760 --> 00:18:40,000
so at any particular point in time

473
00:18:40,000 --> 00:18:41,600
there's only going to be one process

474
00:18:41,600 --> 00:18:42,799
that is able to actually

475
00:18:42,799 --> 00:18:44,960
successfully acquire the lock and the

476
00:18:44,960 --> 00:18:46,320
other process the business is trying to

477
00:18:46,320 --> 00:18:48,080
acquire the lock at the same time

478
00:18:48,080 --> 00:18:50,000
has to wait until the first process

479
00:18:50,000 --> 00:18:52,480
actually calls a release

480
00:18:52,480 --> 00:18:55,520
and so this sequence you know the the

481
00:18:55,520 --> 00:18:57,520
instructions you know between

482
00:18:57,520 --> 00:18:59,919
you know the choir and release are often

483
00:18:59,919 --> 00:19:07,590
called the critical section

484
00:19:07,600 --> 00:19:08,960
and one reason it's called the critical

485
00:19:08,960 --> 00:19:11,280
section is because this is sort of the

486
00:19:11,280 --> 00:19:13,120
uh diffused instruction together that do

487
00:19:13,120 --> 00:19:14,480
the uh you know

488
00:19:14,480 --> 00:19:16,400
need to do the update you know to our

489
00:19:16,400 --> 00:19:18,160
whatever data structure that's protected

490
00:19:18,160 --> 00:19:19,039
by the lock

491
00:19:19,039 --> 00:19:22,000
in an atomic fashion uh and then ensures

492
00:19:22,000 --> 00:19:23,600
that basically

493
00:19:23,600 --> 00:19:25,200
if you have multiple instructions in

494
00:19:25,200 --> 00:19:27,360
this you know between the car and

495
00:19:27,360 --> 00:19:27,919
release

496
00:19:27,919 --> 00:19:31,760
that they all are executed all together

497
00:19:31,760 --> 00:19:34,799
or none and so there's never the case

498
00:19:34,799 --> 00:19:36,240
that basically these instructions in the

499
00:19:36,240 --> 00:19:37,200
critical section

500
00:19:37,200 --> 00:19:39,360
are interleaved as in the way that we

501
00:19:39,360 --> 00:19:40,799
saw in the race condition

502
00:19:40,799 --> 00:19:42,720
and actually exactly that is what avoids

503
00:19:42,720 --> 00:19:48,070
these race conditions

504
00:19:48,080 --> 00:19:55,190
any questions about the lock abstraction

505
00:19:55,200 --> 00:20:00,310
now programs typically have

506
00:20:00,320 --> 00:20:08,070
many locks in fact xv6 has many locks

507
00:20:08,080 --> 00:20:09,919
and the reason to have many locks is

508
00:20:09,919 --> 00:20:11,440
because you know even the you know the

509
00:20:11,440 --> 00:20:12,720
the the

510
00:20:12,720 --> 00:20:14,799
walk serializes you know the execution

511
00:20:14,799 --> 00:20:17,360
right the two processes you know want to

512
00:20:17,360 --> 00:20:18,799
enter this critical section only one

513
00:20:18,799 --> 00:20:21,200
succeeds then the other one

514
00:20:21,200 --> 00:20:22,559
runs that critical section after the

515
00:20:22,559 --> 00:20:24,799
first one

516
00:20:24,799 --> 00:20:26,640
finishes so there's no sort of

517
00:20:26,640 --> 00:20:28,720
parallelism at all

518
00:20:28,720 --> 00:20:31,120
so if the kernel had only one lock you

519
00:20:31,120 --> 00:20:32,559
know which is typically called the

520
00:20:32,559 --> 00:20:34,720
big kernel lock then basically every

521
00:20:34,720 --> 00:20:35,919
system call

522
00:20:35,919 --> 00:20:37,679
uh in this uh in the kernel would be

523
00:20:37,679 --> 00:20:39,120
serialized you know you would

524
00:20:39,120 --> 00:20:41,600
assist the call which one start gets the

525
00:20:41,600 --> 00:20:43,280
one the big kernel lock you know does

526
00:20:43,280 --> 00:20:44,240
whatever it needs to do

527
00:20:44,240 --> 00:20:45,760
and then releases the big kernel lock

528
00:20:45,760 --> 00:20:48,480
and then basically research use space

529
00:20:48,480 --> 00:20:49,679
and then the second system called the

530
00:20:49,679 --> 00:20:51,840
drum so we have an apparel application

531
00:20:51,840 --> 00:20:53,280
that runs you know once we run system

532
00:20:53,280 --> 00:20:54,320
calls in parallel

533
00:20:54,320 --> 00:20:56,559
suddenly you know all the system calls

534
00:20:56,559 --> 00:20:58,559
actually run serially if we had only one

535
00:20:58,559 --> 00:20:59,840
lock

536
00:20:59,840 --> 00:21:02,080
and so typically a program like you know

537
00:21:02,080 --> 00:21:03,120
xp6 has

538
00:21:03,120 --> 00:21:04,960
you know many locks because at least you

539
00:21:04,960 --> 00:21:09,590
know when you get some parallelism

540
00:21:09,600 --> 00:21:13,270
because

541
00:21:13,280 --> 00:21:15,039
you know if you have two system calls

542
00:21:15,039 --> 00:21:17,360
for example use two different locks

543
00:21:17,360 --> 00:21:19,760
uh then you know they can actually run

544
00:21:19,760 --> 00:21:21,280
uh completely in parallel

545
00:21:21,280 --> 00:21:24,559
uh without any uh you know serialization

546
00:21:24,559 --> 00:21:26,320
uh because they're basically you know uh

547
00:21:26,320 --> 00:21:31,120
using diff blocks to serialize

548
00:21:31,120 --> 00:21:34,480
now uh there's

549
00:21:34,480 --> 00:21:37,679
sort of a couple of important points uh

550
00:21:37,679 --> 00:21:40,320
the nobody really sort of enforces in

551
00:21:40,320 --> 00:21:41,200
this interface

552
00:21:41,200 --> 00:21:43,200
you know that you put in the acquires

553
00:21:43,200 --> 00:21:44,400
and releases you know it's up to the

554
00:21:44,400 --> 00:21:46,159
program to do so

555
00:21:46,159 --> 00:21:47,679
so if you want some particular piece of

556
00:21:47,679 --> 00:21:49,600
code to be

557
00:21:49,600 --> 00:21:52,320
atomic then it's up to the developer to

558
00:21:52,320 --> 00:21:52,960
actually

559
00:21:52,960 --> 00:21:55,440
put these acquire releases in and you

560
00:21:55,440 --> 00:21:57,600
know clearly as we'll see

561
00:21:57,600 --> 00:22:00,799
if you can imagine um and that is a

562
00:22:00,799 --> 00:22:01,360
little bit uh

563
00:22:01,360 --> 00:22:02,880
it can be tricky and so it's important

564
00:22:02,880 --> 00:22:04,480
to realize that you know the locking is

565
00:22:04,480 --> 00:22:06,880
not actually done automatically for you

566
00:22:06,880 --> 00:22:09,360
uh it's all up to the developer to

567
00:22:09,360 --> 00:22:10,240
figure out to

568
00:22:10,240 --> 00:22:14,080
associate with data structures

569
00:22:14,080 --> 00:22:16,480
and ensuring that you know the

570
00:22:16,480 --> 00:22:18,480
appropriate acquired releases

571
00:22:18,480 --> 00:22:23,029
are dead

572
00:22:23,039 --> 00:22:25,120
um so clearly it's the case like you

573
00:22:25,120 --> 00:22:26,480
know the the

574
00:22:26,480 --> 00:22:29,919
uh blocks limit imperialism and

575
00:22:29,919 --> 00:22:31,840
therefore their limit performance

576
00:22:31,840 --> 00:22:33,760
uh and so then i mean this raises the

577
00:22:33,760 --> 00:22:42,630
question when to lock

578
00:22:42,640 --> 00:22:44,000
and you know i'm going to give you sort

579
00:22:44,000 --> 00:22:47,600
of a very conservative rule

580
00:22:47,600 --> 00:22:49,039
but that's a good one as a starting

581
00:22:49,039 --> 00:22:50,640
point to think about things

582
00:22:50,640 --> 00:22:56,870
so to conserve the rule

583
00:22:56,880 --> 00:23:00,240
or maybe guideline is a better uh

584
00:23:00,240 --> 00:23:02,159
phrasing is that if you know two

585
00:23:02,159 --> 00:23:05,830
processes

586
00:23:05,840 --> 00:23:09,120
two processes access

587
00:23:09,120 --> 00:23:17,110
a shared data structure

588
00:23:17,120 --> 00:23:20,960
and one is a and one of them is a

589
00:23:20,960 --> 00:23:23,840
writer or an updater so meaning it's

590
00:23:23,840 --> 00:23:25,280
actually going to modify the shared data

591
00:23:25,280 --> 00:23:27,120
structure

592
00:23:27,120 --> 00:23:34,830
then you need a lock for that data

593
00:23:34,840 --> 00:23:39,350
structure

594
00:23:39,360 --> 00:23:42,159
uh so this is a conservative rule sort

595
00:23:42,159 --> 00:23:43,840
of like a red flag you know when you're

596
00:23:43,840 --> 00:23:44,640
programming

597
00:23:44,640 --> 00:23:47,760
and you have a data structure that was

598
00:23:47,760 --> 00:23:49,600
accessed by multiple processes and one

599
00:23:49,600 --> 00:23:50,480
can be a writer

600
00:23:50,480 --> 00:23:51,919
at that point you should be thinking

601
00:23:51,919 --> 00:23:53,360
okay there's a possibility of a race

602
00:23:53,360 --> 00:23:53,919
condition

603
00:23:53,919 --> 00:23:55,440
we want to avoid this in a race

604
00:23:55,440 --> 00:23:57,679
condition i'll just stick it in lock

605
00:23:57,679 --> 00:24:00,400
i will use a lock to guarantee that this

606
00:24:00,400 --> 00:24:02,960
race condition can't happen

607
00:24:02,960 --> 00:24:05,440
but you know there's rulers uh in some

608
00:24:05,440 --> 00:24:10,870
ways too strict

609
00:24:10,880 --> 00:24:12,799
uh there are cases where you know it's

610
00:24:12,799 --> 00:24:14,960
okay if two processes actually share

611
00:24:14,960 --> 00:24:17,360
data structure and one is a writer

612
00:24:17,360 --> 00:24:19,039
in particular there are sort of styles

613
00:24:19,039 --> 00:24:20,960
of programming called block free

614
00:24:20,960 --> 00:24:22,720
programming

615
00:24:22,720 --> 00:24:25,039
that actually totally were just where

616
00:24:25,039 --> 00:24:30,830
these kinds of scenarios actually do

617
00:24:30,840 --> 00:24:32,240
happen

618
00:24:32,240 --> 00:24:33,360
you might want to do log free

619
00:24:33,360 --> 00:24:34,640
programming just basically to get better

620
00:24:34,640 --> 00:24:35,600
performance or

621
00:24:35,600 --> 00:24:38,720
more parallelism uh

622
00:24:38,720 --> 00:24:41,279
mark free program is tricky uh even more

623
00:24:41,279 --> 00:24:43,360
tricky than programming with locks

624
00:24:43,360 --> 00:24:44,960
and you know we'll talk about it at the

625
00:24:44,960 --> 00:24:47,840
end of the semester we'll to study some

626
00:24:47,840 --> 00:24:50,240
lock-free styles of the programming that

627
00:24:50,240 --> 00:24:51,600
particularly are

628
00:24:51,600 --> 00:24:54,640
common in operating system kernels but

629
00:24:54,640 --> 00:24:56,240
basically for this lecture

630
00:24:56,240 --> 00:24:58,320
and for most of the rest of the semester

631
00:24:58,320 --> 00:24:59,679
we're going to be thinking about the

632
00:24:59,679 --> 00:25:00,720
case where

633
00:25:00,720 --> 00:25:04,000
uh using locks you know to uh

634
00:25:04,000 --> 00:25:07,440
control uh sharing um and that's hard

635
00:25:07,440 --> 00:25:07,840
enough

636
00:25:07,840 --> 00:25:09,919
you know just using locks it's not that

637
00:25:09,919 --> 00:25:12,480
straightforward either

638
00:25:12,480 --> 00:25:14,720
um so it's in one hand a little bit uh

639
00:25:14,720 --> 00:25:15,760
too strict

640
00:25:15,760 --> 00:25:17,520
uh because it's not always the case that

641
00:25:17,520 --> 00:25:20,240
you uh needed also some cases to lose

642
00:25:20,240 --> 00:25:23,520
uh you might just

643
00:25:23,520 --> 00:25:26,880
um you might even

644
00:25:26,880 --> 00:25:28,400
lose you want to actually maybe want to

645
00:25:28,400 --> 00:25:30,480
use locks you know to enforce some other

646
00:25:30,480 --> 00:25:33,440
uh properties like if you look at printf

647
00:25:33,440 --> 00:25:35,679
uh

648
00:25:35,679 --> 00:25:38,720
if we pass a stream to printf uh you

649
00:25:38,720 --> 00:25:39,200
know the

650
00:25:39,200 --> 00:25:41,200
xv6 kernel tries to at least you know

651
00:25:41,200 --> 00:25:42,720
get the whole string

652
00:25:42,720 --> 00:25:45,919
to be printed atomically and you know

653
00:25:45,919 --> 00:25:47,039
there's no shared data structure

654
00:25:47,039 --> 00:25:48,080
involved

655
00:25:48,080 --> 00:25:50,240
but it's still useful to actually use a

656
00:25:50,240 --> 00:25:51,600
lock in that particular case

657
00:25:51,600 --> 00:25:52,799
because we want the output to be

658
00:25:52,799 --> 00:25:54,799
serialized so

659
00:25:54,799 --> 00:25:56,640
this rule is not you know perfect but

660
00:25:56,640 --> 00:25:59,909
it's a pretty good guideline

661
00:25:59,919 --> 00:26:04,789
any questions about this rule

662
00:26:04,799 --> 00:26:06,799
um i had a question not about this rule

663
00:26:06,799 --> 00:26:07,919
but

664
00:26:07,919 --> 00:26:10,000
isn't it possible that two processes

665
00:26:10,000 --> 00:26:11,840
could acquire the lock at the same time

666
00:26:11,840 --> 00:26:13,360
and so

667
00:26:13,360 --> 00:26:16,400
would be able to modify the structure

668
00:26:16,400 --> 00:26:18,320
yeah no so so part of the sort of

669
00:26:18,320 --> 00:26:20,159
contract of the lock abstraction is is

670
00:26:20,159 --> 00:26:21,840
that it's impossible for two

671
00:26:21,840 --> 00:26:23,760
uh processes to acquire a lock at the

672
00:26:23,760 --> 00:26:25,279
same time

673
00:26:25,279 --> 00:26:28,880
uh if uh the the rule is that there's

674
00:26:28,880 --> 00:26:31,120
ever there's no there's never a case

675
00:26:31,120 --> 00:26:32,080
where two

676
00:26:32,080 --> 00:26:34,240
processes actually acquire the lock uh

677
00:26:34,240 --> 00:26:35,919
can hold the lock at the same time

678
00:26:35,919 --> 00:26:37,360
we'll see in a second how to implement

679
00:26:37,360 --> 00:26:39,600
that but the api or the specification

680
00:26:39,600 --> 00:26:40,320
for require

681
00:26:40,320 --> 00:26:42,320
is there's only one lock holder at any

682
00:26:42,320 --> 00:26:45,039
given point in time or zero

683
00:26:45,039 --> 00:26:49,269
nice

684
00:26:49,279 --> 00:26:52,559
um okay so uh you know if you see

685
00:26:52,559 --> 00:26:54,799
the programming block is here slightly

686
00:26:54,799 --> 00:26:56,240
uh it could be

687
00:26:56,240 --> 00:26:57,440
problematic because of these race

688
00:26:57,440 --> 00:27:00,080
conditions um

689
00:27:00,080 --> 00:27:02,000
yeah now of course the particular race

690
00:27:02,000 --> 00:27:03,200
condition that we looked at

691
00:27:03,200 --> 00:27:07,200
uh in k3 or that we created in crayfi

692
00:27:07,200 --> 00:27:08,880
which are like easily spottable in some

693
00:27:08,880 --> 00:27:10,480
ways and the fact you know if you use a

694
00:27:10,480 --> 00:27:11,919
race detection tool

695
00:27:11,919 --> 00:27:14,720
uh it would immediately find it um but

696
00:27:14,720 --> 00:27:15,919
you know they're more tricky

697
00:27:15,919 --> 00:27:19,279
cases and so you may want to wonder like

698
00:27:19,279 --> 00:27:20,799
why couldn't you like make you know

699
00:27:20,799 --> 00:27:22,320
could you make locks

700
00:27:22,320 --> 00:27:31,110
or could we make locking automatic

701
00:27:31,120 --> 00:27:32,640
so like if you follow this sort of

702
00:27:32,640 --> 00:27:34,399
simple rule that i just stated you know

703
00:27:34,399 --> 00:27:35,919
then if ever we see a shared data

704
00:27:35,919 --> 00:27:36,799
structure

705
00:27:36,799 --> 00:27:38,640
then you know operations and that shared

706
00:27:38,640 --> 00:27:40,000
data structure basically should require

707
00:27:40,000 --> 00:27:41,200
a walk you know we should

708
00:27:41,200 --> 00:27:42,720
we should associate a lot with the data

709
00:27:42,720 --> 00:27:44,240
structure and then every operation

710
00:27:44,240 --> 00:27:49,120
actually uh uh uh that is uh

711
00:27:49,120 --> 00:27:52,399
that's performed on that uh uh

712
00:27:52,399 --> 00:27:53,600
on that data structure basically

713
00:27:53,600 --> 00:27:55,679
required to release the lock so

714
00:27:55,679 --> 00:27:58,000
one way to think about it maybe in xv6

715
00:27:58,000 --> 00:28:00,559
terms like every struct

716
00:28:00,559 --> 00:28:04,470
you know has a lock

717
00:28:04,480 --> 00:28:07,279
and uh and that lock is automatically

718
00:28:07,279 --> 00:28:09,039
required when we do anything related to

719
00:28:09,039 --> 00:28:09,679
that struct

720
00:28:09,679 --> 00:28:12,559
and this turns out to be too rigid and

721
00:28:12,559 --> 00:28:13,679
this is why you know

722
00:28:13,679 --> 00:28:16,799
walking can not really be uh automatic

723
00:28:16,799 --> 00:28:19,360
so so we've been operating systems an

724
00:28:19,360 --> 00:28:20,880
example from one operating system is the

725
00:28:20,880 --> 00:28:21,600
following

726
00:28:21,600 --> 00:28:25,440
let's say we have a call like rename

727
00:28:25,440 --> 00:28:27,600
that moves a file name from one

728
00:28:27,600 --> 00:28:29,840
directory to another directory so let's

729
00:28:29,840 --> 00:28:32,159
say we have d1x

730
00:28:32,159 --> 00:28:36,240
and we rename it to you know d2

731
00:28:36,240 --> 00:28:39,120
y right so we have a file name in the

732
00:28:39,120 --> 00:28:39,760
directory

733
00:28:39,760 --> 00:28:43,600
uh d1 x and you know we rename it to

734
00:28:43,600 --> 00:28:46,880
d2 slash y so the way uh

735
00:28:46,880 --> 00:28:49,679
you presumably if we follow the rigid

736
00:28:49,679 --> 00:28:50,720
rule or like this

737
00:28:50,720 --> 00:28:52,559
rule of automatic locking now what would

738
00:28:52,559 --> 00:28:54,399
happen is uh

739
00:28:54,399 --> 00:28:56,080
you know that rule up soon we have two

740
00:28:56,080 --> 00:28:58,399
objects we have d1 and d2

741
00:28:58,399 --> 00:29:00,240
right and so we follow the rule then

742
00:29:00,240 --> 00:29:02,080
basically the automatic rule then you

743
00:29:02,080 --> 00:29:05,669
know we lock d1

744
00:29:05,679 --> 00:29:09,029
you know erase x

745
00:29:09,039 --> 00:29:12,880
and release

746
00:29:12,880 --> 00:29:17,669
the lock for uh d1

747
00:29:17,679 --> 00:29:19,760
and then you know we do the second part

748
00:29:19,760 --> 00:29:21,279
update you know d2

749
00:29:21,279 --> 00:29:25,200
lock d2 at

750
00:29:25,200 --> 00:29:29,840
yeah y and release

751
00:29:29,840 --> 00:29:33,360
d2 um

752
00:29:33,360 --> 00:29:34,799
and then we're done so this would be the

753
00:29:34,799 --> 00:29:37,039
sort of hypothetical scheme

754
00:29:37,039 --> 00:29:40,399
uh sort of you imagine

755
00:29:40,399 --> 00:29:42,320
uh would happen if we did automatic

756
00:29:42,320 --> 00:29:44,159
walking and

757
00:29:44,159 --> 00:29:46,080
uh and the point of this example is that

758
00:29:46,080 --> 00:29:48,240
you know we will have the wrong outcome

759
00:29:48,240 --> 00:29:52,080
and why why is this a problematic scheme

760
00:29:52,080 --> 00:30:02,950
why is this not gonna work

761
00:30:02,960 --> 00:30:04,880
and so think about like the thing to

762
00:30:04,880 --> 00:30:06,840
think about is like this

763
00:30:06,840 --> 00:30:10,480
period so we have done the first step

764
00:30:10,480 --> 00:30:14,880
step one we've not done step two yet

765
00:30:14,880 --> 00:30:24,149
what could another process observe

766
00:30:24,159 --> 00:30:28,870
anybody

767
00:30:28,880 --> 00:30:31,360
the file would just be gone yeah you

768
00:30:31,360 --> 00:30:32,559
know this

769
00:30:32,559 --> 00:30:34,080
between step one and two the file

770
00:30:34,080 --> 00:30:41,430
doesn't exist

771
00:30:41,440 --> 00:30:43,679
i mean that is clearly wrong because the

772
00:30:43,679 --> 00:30:45,200
file does exist

773
00:30:45,200 --> 00:30:47,679
it's just being renamed uh and another

774
00:30:47,679 --> 00:30:48,880
point of time really that it didn't

775
00:30:48,880 --> 00:30:50,399
exist

776
00:30:50,399 --> 00:30:53,360
but by implementing this in this way it

777
00:30:53,360 --> 00:30:55,279
just appears that the file might

778
00:30:55,279 --> 00:30:57,840
actually not exist even though it does

779
00:30:57,840 --> 00:30:59,760
so the really right you know solution to

780
00:30:59,760 --> 00:31:03,430
this is what we need

781
00:31:03,440 --> 00:31:07,509
is that we actually lock d1

782
00:31:07,519 --> 00:31:10,720
and d2 first at the beginning of rename

783
00:31:10,720 --> 00:31:15,750
then erase and add

784
00:31:15,760 --> 00:31:19,120
and then release

785
00:31:19,120 --> 00:31:24,310
the locks for d1 and d2

786
00:31:24,320 --> 00:31:27,519
so that makes sense so here's sort of an

787
00:31:27,519 --> 00:31:29,039
example where

788
00:31:29,039 --> 00:31:31,760
we have an operation that regression

789
00:31:31,760 --> 00:31:32,960
needs multiple locks

790
00:31:32,960 --> 00:31:35,760
and uh and the locks can not really be

791
00:31:35,760 --> 00:31:36,799
associated with the

792
00:31:36,799 --> 00:31:38,320
two objects that are the arguments of

793
00:31:38,320 --> 00:31:40,880
this operation uh it has to be the case

794
00:31:40,880 --> 00:31:42,720
that actually the operation itself first

795
00:31:42,720 --> 00:31:45,760
requires to both blocks then performs

796
00:31:45,760 --> 00:31:47,360
the operations

797
00:31:47,360 --> 00:31:49,360
so this automatic locking is not sort of

798
00:31:49,360 --> 00:31:50,960
you know directly possible

799
00:31:50,960 --> 00:31:52,399
uh there's gonna be cases where that

800
00:31:52,399 --> 00:31:54,320
just is not gonna run

801
00:31:54,320 --> 00:31:56,240
to the or this native scheme at least

802
00:31:56,240 --> 00:31:58,840
will run into a problem

803
00:31:58,840 --> 00:32:06,230
problems any questions about this

804
00:32:06,240 --> 00:32:09,360
yeah so could we just say that um

805
00:32:09,360 --> 00:32:11,200
when we're accessing a data structure we

806
00:32:11,200 --> 00:32:12,960
just have to access or we have to

807
00:32:12,960 --> 00:32:15,519
acquire all of the locks associated with

808
00:32:15,519 --> 00:32:17,679
all of the data structures we need at

809
00:32:17,679 --> 00:32:19,840
the beginning

810
00:32:19,840 --> 00:32:21,519
yeah so that'll be one way doing it and

811
00:32:21,519 --> 00:32:23,360
i think that this quickly will

812
00:32:23,360 --> 00:32:25,600
uh sort of come down to basically having

813
00:32:25,600 --> 00:32:27,519
a big kernel lock

814
00:32:27,519 --> 00:32:29,360
oh i think okay and then you're on the

815
00:32:29,360 --> 00:32:30,640
wrist basically you have no parallelism

816
00:32:30,640 --> 00:32:31,360
anymore

817
00:32:31,360 --> 00:32:33,200
and so you want to do better than that

818
00:32:33,200 --> 00:32:35,120
right yeah and i think this is always

819
00:32:35,120 --> 00:32:36,480
the tension you know you can make things

820
00:32:36,480 --> 00:32:37,200
simpler

821
00:32:37,200 --> 00:32:39,679
by basically what's called your coarse

822
00:32:39,679 --> 00:32:41,360
grain blocking

823
00:32:41,360 --> 00:32:44,000
but then you know you're loose there's

824
00:32:44,000 --> 00:32:44,880
performance

825
00:32:44,880 --> 00:32:47,039
or you may lose performance depending if

826
00:32:47,039 --> 00:32:49,039
the lock is contented or not

827
00:32:49,039 --> 00:32:52,950
yep makes sense thank you

828
00:32:52,960 --> 00:32:55,039
so lock perspective so there's different

829
00:32:55,039 --> 00:32:56,240
ways

830
00:32:56,240 --> 00:32:59,760
uh to think about locks

831
00:32:59,760 --> 00:33:02,640
and you know there are three common ones

832
00:33:02,640 --> 00:33:03,440
and

833
00:33:03,440 --> 00:33:05,679
uh you know go for all three of them and

834
00:33:05,679 --> 00:33:07,360
just maybe that may help you

835
00:33:07,360 --> 00:33:08,880
to think about locks and maybe one of

836
00:33:08,880 --> 00:33:10,559
them is your favorite and you can use

837
00:33:10,559 --> 00:33:11,919
that one

838
00:33:11,919 --> 00:33:13,440
as your way of thinking about it but

839
00:33:13,440 --> 00:33:14,799
it's probably helpful to see that there

840
00:33:14,799 --> 00:33:16,000
are actually different ways of thinking

841
00:33:16,000 --> 00:33:19,029
about logs

842
00:33:19,039 --> 00:33:20,640
so first of all you know one other way

843
00:33:20,640 --> 00:33:23,919
to think about it is actually a lot

844
00:33:23,919 --> 00:33:26,470
avoid

845
00:33:26,480 --> 00:33:29,760
uh lost updates or help

846
00:33:29,760 --> 00:33:31,519
if you use logs correctly you know

847
00:33:31,519 --> 00:33:33,600
lock's going to help avoiding

848
00:33:33,600 --> 00:33:38,559
lost updates

849
00:33:38,559 --> 00:33:41,279
and if you think about uh our early

850
00:33:41,279 --> 00:33:42,960
example in the catalog.c

851
00:33:42,960 --> 00:33:44,640
you know the lost update is basically

852
00:33:44,640 --> 00:33:46,640
the we lose one update to

853
00:33:46,640 --> 00:33:50,799
the k3 and by putting walks in it you

854
00:33:50,799 --> 00:33:51,840
know where actually we

855
00:33:51,840 --> 00:33:54,000
didn't lose that update so that's one

856
00:33:54,000 --> 00:33:55,840
way you're thinking about it

857
00:33:55,840 --> 00:33:58,559
it's a very low level way uh another way

858
00:33:58,559 --> 00:33:59,200
to think about it

859
00:33:59,200 --> 00:34:03,990
is you know you can make locked blocks

860
00:34:04,000 --> 00:34:10,550
make multi-step operations

861
00:34:10,560 --> 00:34:13,589
atomic

862
00:34:13,599 --> 00:34:14,800
and so there's sort of the view of a

863
00:34:14,800 --> 00:34:16,240
critical section you know we have a

864
00:34:16,240 --> 00:34:19,520
required walk we do a whole bunch of

865
00:34:19,520 --> 00:34:21,520
steps or instructions we executed all

866
00:34:21,520 --> 00:34:23,280
the instructions then release

867
00:34:23,280 --> 00:34:24,399
and basically that whole critical

868
00:34:24,399 --> 00:34:27,760
section execute as an atomic operation

869
00:34:27,760 --> 00:34:30,320
and that's sort of the uh and also a

870
00:34:30,320 --> 00:34:32,960
fine way you know to think about locks

871
00:34:32,960 --> 00:34:35,200
and then the third one uh you know that

872
00:34:35,200 --> 00:34:37,359
may be helpful is that

873
00:34:37,359 --> 00:34:42,079
really what locks do is locks health

874
00:34:42,079 --> 00:34:48,230
maintain an invariant

875
00:34:48,240 --> 00:34:49,599
data structure that you know it's

876
00:34:49,599 --> 00:34:52,079
protecting and

877
00:34:52,079 --> 00:34:55,280
uh what really is going on is that uh

878
00:34:55,280 --> 00:34:57,599
at the before a choir if there's no lock

879
00:34:57,599 --> 00:34:58,480
holder you know

880
00:34:58,480 --> 00:35:01,040
that invariant holds uh when we acquire

881
00:35:01,040 --> 00:35:03,119
the lock and we do some operations then

882
00:35:03,119 --> 00:35:05,760
temporarily that invariant may be

883
00:35:05,760 --> 00:35:08,640
uh violated but at the point that we do

884
00:35:08,640 --> 00:35:13,109
the release

885
00:35:13,119 --> 00:35:15,839
and so if you think about our free list

886
00:35:15,839 --> 00:35:16,480
uh

887
00:35:16,480 --> 00:35:18,960
case you know the invariant is there uh

888
00:35:18,960 --> 00:35:19,520
you know

889
00:35:19,520 --> 00:35:22,400
the three pointer points to uh one other

890
00:35:22,400 --> 00:35:23,359
next pointer

891
00:35:23,359 --> 00:35:26,000
and all the three pages are on a single

892
00:35:26,000 --> 00:35:27,440
list

893
00:35:27,440 --> 00:35:30,480
uh and that's temporarily violated uh

894
00:35:30,480 --> 00:35:34,069
at the point uh

895
00:35:34,079 --> 00:35:36,640
in the middle of the k3 because like

896
00:35:36,640 --> 00:35:37,280
multiple

897
00:35:37,280 --> 00:35:38,560
pointers actually point to the beginning

898
00:35:38,560 --> 00:35:41,349
of the free list

899
00:35:41,359 --> 00:35:42,640
and then it's established at the end of

900
00:35:42,640 --> 00:35:44,960
it so and you know for

901
00:35:44,960 --> 00:35:46,800
you know the free list it has a not so

902
00:35:46,800 --> 00:35:48,480
complicated variant but like for more

903
00:35:48,480 --> 00:35:50,000
uh complicated shared data structures

904
00:35:50,000 --> 00:35:51,599
you know it can be a helpful way of

905
00:35:51,599 --> 00:35:53,599
thinking actually what the lock is doing

906
00:35:53,599 --> 00:35:55,839
for you

907
00:35:55,839 --> 00:35:58,000
and so see even in this kind of the k3

908
00:35:58,000 --> 00:35:59,839
case you know all three lock perspective

909
00:35:59,839 --> 00:36:01,440
for reasonable perspective

910
00:36:01,440 --> 00:36:04,560
um and uh you know one of them

911
00:36:04,560 --> 00:36:08,000
you know uh brings more with you than so

912
00:36:08,000 --> 00:36:09,599
than one of the other ones and you know

913
00:36:09,599 --> 00:36:11,599
use that as your way to think about

914
00:36:11,599 --> 00:36:14,710
locks

915
00:36:14,720 --> 00:36:23,589
any questions about this point

916
00:36:23,599 --> 00:36:26,960
okay so i'm gonna now run for a couple

917
00:36:26,960 --> 00:36:27,440
things

918
00:36:27,440 --> 00:36:31,359
uh uh sort of uh

919
00:36:31,359 --> 00:36:33,280
you know undesirable properties or that

920
00:36:33,280 --> 00:36:34,880
can actually happen with locks

921
00:36:34,880 --> 00:36:37,359
and you know we know like locks are uh

922
00:36:37,359 --> 00:36:39,440
necessary to fix a correctness problem

923
00:36:39,440 --> 00:36:41,440
you know to avoid these race conditions

924
00:36:41,440 --> 00:36:42,880
blocks themselves in

925
00:36:42,880 --> 00:36:45,200
when inappropriate inappropriately used

926
00:36:45,200 --> 00:36:46,960
can also introduce their own set of

927
00:36:46,960 --> 00:36:48,240
problems

928
00:36:48,240 --> 00:36:49,599
and so i want to talk a little bit about

929
00:36:49,599 --> 00:36:51,440
that and so the obvious one

930
00:36:51,440 --> 00:36:57,190
of course is deadlock

931
00:36:57,200 --> 00:36:58,960
you know for example you know the the

932
00:36:58,960 --> 00:37:00,560
simplest case you know was a little bit

933
00:37:00,560 --> 00:37:01,680
boring but i mean you

934
00:37:01,680 --> 00:37:03,200
worthwhile thinking about you know if

935
00:37:03,200 --> 00:37:05,359
you do an acquire

936
00:37:05,359 --> 00:37:08,640
you know a lock and so you start the

937
00:37:08,640 --> 00:37:09,520
critical section

938
00:37:09,520 --> 00:37:11,280
and in the critical section you do

939
00:37:11,280 --> 00:37:13,520
another acquire

940
00:37:13,520 --> 00:37:16,870
of the same lock

941
00:37:16,880 --> 00:37:20,230
what will happen

942
00:37:20,240 --> 00:37:29,589
can the second acquirer succeed

943
00:37:29,599 --> 00:37:31,440
well with the spec that we've given

944
00:37:31,440 --> 00:37:33,200
early on uh you know

945
00:37:33,200 --> 00:37:34,800
this should be not allowed and so

946
00:37:34,800 --> 00:37:37,119
basically the second acquirer must block

947
00:37:37,119 --> 00:37:39,440
until the first acquire release the lock

948
00:37:39,440 --> 00:37:40,400
but that was

949
00:37:40,400 --> 00:37:42,240
you know the process itself so basically

950
00:37:42,240 --> 00:37:46,870
this resulted in a deadlock

951
00:37:46,880 --> 00:37:48,400
now this is a trivial example of a

952
00:37:48,400 --> 00:37:50,079
deadlock uh maybe now there's

953
00:37:50,079 --> 00:37:51,280
interesting in fact this is a deadlock

954
00:37:51,280 --> 00:37:53,839
that xv6 detects you know because when

955
00:37:53,839 --> 00:37:55,520
it sees that the same process requires

956
00:37:55,520 --> 00:37:57,760
the same walk again uh it actually

957
00:37:57,760 --> 00:38:00,400
causes a panic the more interesting

958
00:38:00,400 --> 00:38:01,200
cases are

959
00:38:01,200 --> 00:38:03,920
when multiple locks are involved so

960
00:38:03,920 --> 00:38:04,560
let's

961
00:38:04,560 --> 00:38:07,520
go to our previous example let's say we

962
00:38:07,520 --> 00:38:08,560
have the following

963
00:38:08,560 --> 00:38:12,160
uh we have core one or maybe

964
00:38:12,160 --> 00:38:16,230
cpu one

965
00:38:16,240 --> 00:38:19,910
we have cpu two

966
00:38:19,920 --> 00:38:22,960
and cpu 1 you know executes

967
00:38:22,960 --> 00:38:27,359
vname directory1x

968
00:38:27,359 --> 00:38:33,280
to directory2 y

969
00:38:33,280 --> 00:38:36,800
and cpu 2 executes at the same time

970
00:38:36,800 --> 00:38:41,270
uh rename

971
00:38:41,280 --> 00:38:43,839
uh in the other way in the other

972
00:38:43,839 --> 00:38:44,560
direction

973
00:38:44,560 --> 00:38:47,839
you know d2 a to

974
00:38:47,839 --> 00:38:51,440
the one you know why i say b

975
00:38:51,440 --> 00:38:54,000
just to make the names different so the

976
00:38:54,000 --> 00:38:56,079
critical

977
00:38:56,079 --> 00:38:59,119
thing to observe here is that cpu1 you

978
00:38:59,119 --> 00:39:02,160
know runs a rename from d1 to d2

979
00:39:02,160 --> 00:39:05,200
and cpu uh two does exactly the opposite

980
00:39:05,200 --> 00:39:08,960
that doesn't rename from d2 to d1

981
00:39:08,960 --> 00:39:10,640
so let's assume that we actually

982
00:39:10,640 --> 00:39:12,480
acquired the locks in the order of their

983
00:39:12,480 --> 00:39:13,359
arguments

984
00:39:13,359 --> 00:39:16,160
and so what will happen rick is that uh

985
00:39:16,160 --> 00:39:17,119
in this case

986
00:39:17,119 --> 00:39:18,800
you know we'll acquire both locks we

987
00:39:18,800 --> 00:39:20,480
know from our previous example that is

988
00:39:20,480 --> 00:39:20,960
actually

989
00:39:20,960 --> 00:39:25,190
important so we'll acquire

990
00:39:25,200 --> 00:39:28,560
v1 lock

991
00:39:28,560 --> 00:39:30,480
and you know let's say they really run

992
00:39:30,480 --> 00:39:32,320
they're truly concurrent

993
00:39:32,320 --> 00:39:34,160
so at that point you know this other guy

994
00:39:34,160 --> 00:39:35,760
might actually this other cpu might

995
00:39:35,760 --> 00:39:37,920
acquire

996
00:39:37,920 --> 00:39:40,839
d2 first because that is its first

997
00:39:40,839 --> 00:39:43,119
argument

998
00:39:43,119 --> 00:39:45,839
and now of course d2 d1 wants to acquire

999
00:39:45,839 --> 00:39:48,470
d2

1000
00:39:48,480 --> 00:39:51,520
so i'll try to acquire d2 will it

1001
00:39:51,520 --> 00:39:53,359
succeed

1002
00:39:53,359 --> 00:39:55,040
i won't succeed because you know the

1003
00:39:55,040 --> 00:39:57,440
other guy you know actually has the lock

1004
00:39:57,440 --> 00:40:00,320
and so this guy will stop here and not

1005
00:40:00,320 --> 00:40:01,440
proceed

1006
00:40:01,440 --> 00:40:04,160
now let's look at the other cpu cpu2

1007
00:40:04,160 --> 00:40:05,280
acquired d2

1008
00:40:05,280 --> 00:40:06,800
it's not going to require d1 for its

1009
00:40:06,800 --> 00:40:08,480
secondary argument

1010
00:40:08,480 --> 00:40:10,800
he's going to try to call it's going to

1011
00:40:10,800 --> 00:40:12,720
call acquire d1

1012
00:40:12,720 --> 00:40:14,960
and will it be able to proceed no it

1013
00:40:14,960 --> 00:40:16,240
won't be able to proceed

1014
00:40:16,240 --> 00:40:19,359
right because the cpu one actually has

1015
00:40:19,359 --> 00:40:20,960
to walk in d1

1016
00:40:20,960 --> 00:40:22,640
and so here we you know sometimes this

1017
00:40:22,640 --> 00:40:24,079
is called the deadly embrace

1018
00:40:24,079 --> 00:40:27,359
you know uh where you know the

1019
00:40:27,359 --> 00:40:29,040
because in the way we acquired the

1020
00:40:29,040 --> 00:40:30,960
ordering which we ordered which we quite

1021
00:40:30,960 --> 00:40:41,030
unlocked results actually in deadlock

1022
00:40:41,040 --> 00:40:45,589
does that make sense this example

1023
00:40:45,599 --> 00:40:46,800
this is like a little bit of a more

1024
00:40:46,800 --> 00:40:48,400
endangering example correct of deadlock

1025
00:40:48,400 --> 00:40:50,160
you know it's not an obvious

1026
00:40:50,160 --> 00:40:52,480
problem and the solution turns out in

1027
00:40:52,480 --> 00:40:56,230
some sense reasonably simple

1028
00:40:56,240 --> 00:40:57,760
the solution is that you know if you

1029
00:40:57,760 --> 00:41:00,079
have multiple locks then

1030
00:41:00,079 --> 00:41:03,910
you have to order the locks

1031
00:41:03,920 --> 00:41:07,119
and all operations have to acquire

1032
00:41:07,119 --> 00:41:17,430
locks in that order

1033
00:41:17,440 --> 00:41:19,119
so if you're a system designer you have

1034
00:41:19,119 --> 00:41:21,119
to decide you know what the

1035
00:41:21,119 --> 00:41:24,319
global order is for all log objects

1036
00:41:24,319 --> 00:41:26,640
and so for example in this case we may

1037
00:41:26,640 --> 00:41:28,000
want to decide that d1

1038
00:41:28,000 --> 00:41:30,960
should be always ordered before d2 and

1039
00:41:30,960 --> 00:41:32,640
that means that

1040
00:41:32,640 --> 00:41:34,720
when we execute a rename the rule of

1041
00:41:34,720 --> 00:41:36,720
life is we always acquire

1042
00:41:36,720 --> 00:41:40,160
uh the lower numbered uh

1043
00:41:40,160 --> 00:41:42,319
directories first before we acquire the

1044
00:41:42,319 --> 00:41:45,520
higher order directory numbers

1045
00:41:45,520 --> 00:41:48,079
and that will ensure that basically uh

1046
00:41:48,079 --> 00:41:49,200
there's a global order

1047
00:41:49,200 --> 00:41:51,119
and you know this particular case you

1048
00:41:51,119 --> 00:41:52,720
just cannot happen

1049
00:41:52,720 --> 00:41:55,839
uh because you know the block order is

1050
00:41:55,839 --> 00:41:56,560
going to be then

1051
00:41:56,560 --> 00:41:59,680
for v1 d2 for this guy

1052
00:41:59,680 --> 00:42:01,520
and this guy will acquire the locks

1053
00:42:01,520 --> 00:42:03,119
exactly in the same global order you

1054
00:42:03,119 --> 00:42:04,480
know d1 d2

1055
00:42:04,480 --> 00:42:06,480
and then we don't have this deadline

1056
00:42:06,480 --> 00:42:09,510
bridge

1057
00:42:09,520 --> 00:42:14,630
this makes sense

1058
00:42:14,640 --> 00:42:22,069
any questions about this

1059
00:42:22,079 --> 00:42:24,400
so this uh indicates a little bit of a a

1060
00:42:24,400 --> 00:42:25,839
problem

1061
00:42:25,839 --> 00:42:27,520
even though like okay so it fixes you

1062
00:42:27,520 --> 00:42:29,040
know this sort of deadlock problem by

1063
00:42:29,040 --> 00:42:30,240
having global order

1064
00:42:30,240 --> 00:42:33,440
notice this order is global

1065
00:42:33,440 --> 00:42:37,030
and this is uh

1066
00:42:37,040 --> 00:42:39,680
an issue a little bit when designing a

1067
00:42:39,680 --> 00:42:40,800
system because

1068
00:42:40,800 --> 00:43:05,990
um hold on

1069
00:43:06,000 --> 00:43:08,640
uh so if you think about the sort of

1070
00:43:08,640 --> 00:43:14,950
walk ordering

1071
00:43:14,960 --> 00:43:18,000
you know that has to be sort of global

1072
00:43:18,000 --> 00:43:21,680
and so if one module one m you know

1073
00:43:21,680 --> 00:43:25,680
calls a method in marshall

1074
00:43:25,680 --> 00:43:29,440
two um

1075
00:43:29,440 --> 00:43:32,000
and the collar you know and one g you

1076
00:43:32,000 --> 00:43:32,800
know might actually

1077
00:43:32,800 --> 00:43:34,720
needs to be aware or could be you need

1078
00:43:34,720 --> 00:43:37,040
to be aware actually or what locks

1079
00:43:37,040 --> 00:43:40,079
f acquires award walks you know and two

1080
00:43:40,079 --> 00:43:42,630
uses

1081
00:43:42,640 --> 00:43:46,160
uh because uh if you know and two

1082
00:43:46,160 --> 00:43:49,680
uh uses some set of locks uh then

1083
00:43:49,680 --> 00:43:51,520
you know if we follow our walk ordering

1084
00:43:51,520 --> 00:43:53,760
rule uh jesus got to make sure that you

1085
00:43:53,760 --> 00:43:55,119
know if it has some locks

1086
00:43:55,119 --> 00:43:57,119
that it acquires all locks you know from

1087
00:43:57,119 --> 00:43:59,280
f and g together actually in some

1088
00:43:59,280 --> 00:44:02,160
uh global order and so that really means

1089
00:44:02,160 --> 00:44:06,550
that these are the internals

1090
00:44:06,560 --> 00:44:09,520
the internals of m2 at least in terms of

1091
00:44:09,520 --> 00:44:15,829
locks

1092
00:44:15,839 --> 00:44:21,270
must be visible to m1

1093
00:44:21,280 --> 00:44:23,119
so that you know and one can ensure that

1094
00:44:23,119 --> 00:44:24,720
actually you know uh calls

1095
00:44:24,720 --> 00:44:28,079
uh at uh n2 in the in in the appropriate

1096
00:44:28,079 --> 00:44:29,119
way

1097
00:44:29,119 --> 00:44:30,640
uh and you know in some ways that is you

1098
00:44:30,640 --> 00:44:33,599
know sort of an abstraction violation

1099
00:44:33,599 --> 00:44:35,839
you know abstractions work out perfectly

1100
00:44:35,839 --> 00:44:37,119
you know m1 doesn't really know you need

1101
00:44:37,119 --> 00:44:38,800
to know anything about how m2 is

1102
00:44:38,800 --> 00:44:39,760
implemented

1103
00:44:39,760 --> 00:44:42,480
and unfortunately logs are a common

1104
00:44:42,480 --> 00:44:44,400
example where some of the internals you

1105
00:44:44,400 --> 00:44:47,280
know of m2 might actually leak out to m1

1106
00:44:47,280 --> 00:44:50,560
because m1 really needs to know and so

1107
00:44:50,560 --> 00:44:52,880
you know when you design a bigger system

1108
00:44:52,880 --> 00:44:54,000
uh you know

1109
00:44:54,000 --> 00:44:55,359
this makes the modularity more

1110
00:44:55,359 --> 00:45:00,630
complicated

1111
00:45:00,640 --> 00:45:03,520
um oh sorry i was just wondering does it

1112
00:45:03,520 --> 00:45:04,079
need to be

1113
00:45:04,079 --> 00:45:07,440
a complete um ordering of locks or

1114
00:45:07,440 --> 00:45:10,720
can there be some blocks that are um

1115
00:45:10,720 --> 00:45:14,240
like that can be ordered in whatever way

1116
00:45:14,240 --> 00:45:17,760
they yeah it depends if like f and g

1117
00:45:17,760 --> 00:45:20,160
you know share any locks right so for

1118
00:45:20,160 --> 00:45:22,720
example if you like and look at xv6

1119
00:45:22,720 --> 00:45:26,400
uh there uh are sort of multiple strands

1120
00:45:26,400 --> 00:45:27,839
of lock orderings because some

1121
00:45:27,839 --> 00:45:29,200
blockchain have nothing to do with other

1122
00:45:29,200 --> 00:45:30,480
locks and so they know

1123
00:45:30,480 --> 00:45:33,359
they're never required together and so

1124
00:45:33,359 --> 00:45:34,560
if they're never acquired together

1125
00:45:34,560 --> 00:45:36,160
they're just joined block sets if you

1126
00:45:36,160 --> 00:45:36,880
will

1127
00:45:36,880 --> 00:45:38,640
and then only you have to make sure that

1128
00:45:38,640 --> 00:45:40,720
the ordering in one particular lock set

1129
00:45:40,720 --> 00:45:41,599
is global

1130
00:45:41,599 --> 00:45:43,760
and the ordering in the other lock sets

1131
00:45:43,760 --> 00:45:45,200
is completely independent of the other

1132
00:45:45,200 --> 00:45:47,680
ordering

1133
00:45:47,680 --> 00:45:49,280
so it is correct that there is no

1134
00:45:49,280 --> 00:45:51,200
doesn't have to be a global ordering but

1135
00:45:51,200 --> 00:45:51,520
like

1136
00:45:51,520 --> 00:45:52,880
all the functions that you know

1137
00:45:52,880 --> 00:45:54,960
manipulate the same shared sort of

1138
00:45:54,960 --> 00:45:57,040
log set they need to agree on in global

1139
00:45:57,040 --> 00:45:59,200
order

1140
00:45:59,200 --> 00:46:04,390
thank you

1141
00:46:04,400 --> 00:46:08,560
okay so one you know another sort of

1142
00:46:08,560 --> 00:46:11,680
uh challenge uh with box uh we've seen

1143
00:46:11,680 --> 00:46:13,200
now two challenges one is deadlock one

1144
00:46:13,200 --> 00:46:14,480
is modularity

1145
00:46:14,480 --> 00:46:16,720
uh the second uh challenge or third

1146
00:46:16,720 --> 00:46:18,560
challenge is just walks

1147
00:46:18,560 --> 00:46:24,069
versus performance

1148
00:46:24,079 --> 00:46:26,240
and you know really hinted at this a

1149
00:46:26,240 --> 00:46:28,880
couple times but it needs to uh

1150
00:46:28,880 --> 00:46:31,680
is important enough to sort of actually

1151
00:46:31,680 --> 00:46:33,359
put some emphasis on

1152
00:46:33,359 --> 00:46:36,960
uh and so basically if you want to get

1153
00:46:36,960 --> 00:46:39,760
performance you need to split up data

1154
00:46:39,760 --> 00:46:40,240
structures

1155
00:46:40,240 --> 00:46:43,119
right so if you have one big kernel lock

1156
00:46:43,119 --> 00:46:44,800
uh that will limit your performance to

1157
00:46:44,800 --> 00:46:46,720
basically performance in a single cpu

1158
00:46:46,720 --> 00:46:48,319
if you want you know performance remove

1159
00:46:48,319 --> 00:46:50,640
uh you want that to perform scales

1160
00:46:50,640 --> 00:46:52,800
with the numerous cpus you got to split

1161
00:46:52,800 --> 00:46:54,079
up

1162
00:46:54,079 --> 00:47:04,950
you need to split up data structures

1163
00:47:04,960 --> 00:47:07,050
um and the best split you know

1164
00:47:07,050 --> 00:47:09,280
[Music]

1165
00:47:09,280 --> 00:47:17,750
is not obvious or can be a challenge

1166
00:47:17,760 --> 00:47:19,359
uh you know for example you know if you

1167
00:47:19,359 --> 00:47:20,800
do associate the lock with every

1168
00:47:20,800 --> 00:47:22,480
directory should you associate the lock

1169
00:47:22,480 --> 00:47:23,440
with every inode

1170
00:47:23,440 --> 00:47:24,640
you know should you associate a lock

1171
00:47:24,640 --> 00:47:26,800
with every process or not uh

1172
00:47:26,800 --> 00:47:29,040
or is it better you know to sort of

1173
00:47:29,040 --> 00:47:30,559
split the data structures in a different

1174
00:47:30,559 --> 00:47:31,920
way

1175
00:47:31,920 --> 00:47:35,359
um and uh and if you make a change you

1176
00:47:35,359 --> 00:47:35,920
know you

1177
00:47:35,920 --> 00:47:38,240
re redesigned sort of the locking

1178
00:47:38,240 --> 00:47:39,359
discipline

1179
00:47:39,359 --> 00:47:41,440
uh and then they've got to make sure

1180
00:47:41,440 --> 00:47:42,960
that you know you're still maintained in

1181
00:47:42,960 --> 00:47:44,640
variance that actually

1182
00:47:44,640 --> 00:47:47,680
the kernel is trying to maintain uh and

1183
00:47:47,680 --> 00:47:49,440
if you split locks you know you also

1184
00:47:49,440 --> 00:47:51,440
have to rewrite the goat

1185
00:47:51,440 --> 00:47:54,079
or you may have to need that may write

1186
00:47:54,079 --> 00:47:56,319
may need to

1187
00:47:56,319 --> 00:48:02,790
rewrite code too

1188
00:48:02,800 --> 00:48:05,839
and so it turns out that basically

1189
00:48:05,839 --> 00:48:08,880
you refactor you know the

1190
00:48:08,880 --> 00:48:10,400
parts of your kernel or part of your

1191
00:48:10,400 --> 00:48:13,359
apparel program to get better forms

1192
00:48:13,359 --> 00:48:15,040
by splitting data structure ops

1193
00:48:15,040 --> 00:48:16,559
introducing more locks

1194
00:48:16,559 --> 00:48:18,079
uh you know that it's just it's a lot of

1195
00:48:18,079 --> 00:48:19,440
work you have to carefully think through

1196
00:48:19,440 --> 00:48:20,960
that you maintain the values that you

1197
00:48:20,960 --> 00:48:22,720
intended to maintain

1198
00:48:22,720 --> 00:48:25,440
you have to rewrite code and so

1199
00:48:25,440 --> 00:48:28,000
generally this is just a lot of work

1200
00:48:28,000 --> 00:48:32,630
and not easy

1201
00:48:32,640 --> 00:48:34,079
and so this is a little bit of a

1202
00:48:34,079 --> 00:48:35,599
negative you know news point right

1203
00:48:35,599 --> 00:48:36,079
because

1204
00:48:36,079 --> 00:48:37,839
you know we want to get better

1205
00:48:37,839 --> 00:48:39,520
performance and that suggests you know

1206
00:48:39,520 --> 00:48:40,640
more locks

1207
00:48:40,640 --> 00:48:43,839
uh and uh but that

1208
00:48:43,839 --> 00:48:45,760
you know it's actually a you know a lot

1209
00:48:45,760 --> 00:48:46,960
of work

1210
00:48:46,960 --> 00:48:50,079
and so the general recipe you know to

1211
00:48:50,079 --> 00:48:51,599
how to go about this

1212
00:48:51,599 --> 00:49:00,829
is to you know start of course during

1213
00:49:00,839 --> 00:49:05,109
walks

1214
00:49:05,119 --> 00:49:11,430
and then measure

1215
00:49:11,440 --> 00:49:12,720
so i'm going to run a bunch of

1216
00:49:12,720 --> 00:49:14,839
applications on top of your kernel

1217
00:49:14,839 --> 00:49:17,520
and see whether you get actually any

1218
00:49:17,520 --> 00:49:19,040
speed up if they actually explode

1219
00:49:19,040 --> 00:49:20,559
multiple cars

1220
00:49:20,559 --> 00:49:22,559
and if they do you know your base will

1221
00:49:22,559 --> 00:49:23,680
be done right

1222
00:49:23,680 --> 00:49:26,400
your walking design is good enough if if

1223
00:49:26,400 --> 00:49:27,520
you don't get speed up

1224
00:49:27,520 --> 00:49:28,960
basically that means that some lock is

1225
00:49:28,960 --> 00:49:33,030
contended

1226
00:49:33,040 --> 00:49:35,040
multiple processes are trying to get the

1227
00:49:35,040 --> 00:49:36,640
same lock and therefore they are

1228
00:49:36,640 --> 00:49:37,680
serialized

1229
00:49:37,680 --> 00:49:40,480
and therefore you don't get speed up

1230
00:49:40,480 --> 00:49:42,319
then you know you have to rethink about

1231
00:49:42,319 --> 00:49:48,470
then you need to redesign

1232
00:49:48,480 --> 00:49:49,839
but the point is that you want to be

1233
00:49:49,839 --> 00:49:51,920
guided you know by these

1234
00:49:51,920 --> 00:49:54,000
measurements uh because it may be the

1235
00:49:54,000 --> 00:49:55,760
case that you know some module that

1236
00:49:55,760 --> 00:49:57,359
uses of course green block is just not

1237
00:49:57,359 --> 00:49:59,920
called uh in parallel often

1238
00:49:59,920 --> 00:50:01,680
and therefore it's not necessary to

1239
00:50:01,680 --> 00:50:02,960
actually redesign

1240
00:50:02,960 --> 00:50:04,720
and since redesign is a lot of work you

1241
00:50:04,720 --> 00:50:06,400
know and you know it also

1242
00:50:06,400 --> 00:50:08,000
can complicate the reasoning about that

1243
00:50:08,000 --> 00:50:09,760
code uh you know then

1244
00:50:09,760 --> 00:50:11,200
you know it's a good idea not actually

1245
00:50:11,200 --> 00:50:12,559
to do that redesign is it's not

1246
00:50:12,559 --> 00:50:14,400
necessary

1247
00:50:14,400 --> 00:50:18,319
um and so in general a good

1248
00:50:18,319 --> 00:50:20,240
rule of thumb is you know start with

1249
00:50:20,240 --> 00:50:21,359
course grade locks

1250
00:50:21,359 --> 00:50:23,440
measure whether a contention appears in

1251
00:50:23,440 --> 00:50:24,720
one of these locks and then

1252
00:50:24,720 --> 00:50:26,480
redesign that part of the system so that

1253
00:50:26,480 --> 00:50:30,549
you get better better parallelism

1254
00:50:30,559 --> 00:50:32,720
does it all make sense any questions so

1255
00:50:32,720 --> 00:50:38,950
far

1256
00:50:38,960 --> 00:50:42,000
okay let's look at uh uh

1257
00:50:42,000 --> 00:50:43,920
let's do a little uh let's look at the

1258
00:50:43,920 --> 00:50:46,640
in xc6 uh you know some code you know

1259
00:50:46,640 --> 00:50:48,160
so you can understand a little bit uh

1260
00:50:48,160 --> 00:50:50,160
how this locking sort of works out in

1261
00:50:50,160 --> 00:50:53,520
practice in xv6 uh

1262
00:50:53,520 --> 00:50:58,470
and so i'm going to go back to our uh

1263
00:50:58,480 --> 00:51:01,680
to the this screen

1264
00:51:01,680 --> 00:51:04,800
uh i really need this and i want to look

1265
00:51:04,800 --> 00:51:05,119
at

1266
00:51:05,119 --> 00:51:06,880
view art because you know we're start

1267
00:51:06,880 --> 00:51:08,559
talking about locking there

1268
00:51:08,559 --> 00:51:10,710
uh on

1269
00:51:10,710 --> 00:51:13,119
[Music]

1270
00:51:13,119 --> 00:51:14,559
a monday and i want to look a little bit

1271
00:51:14,559 --> 00:51:16,400
more in detail

1272
00:51:16,400 --> 00:51:17,920
uh now that we know a little bit more

1273
00:51:17,920 --> 00:51:19,599
about locks and then also

1274
00:51:19,599 --> 00:51:20,839
illustrate a couple of interesting

1275
00:51:20,839 --> 00:51:28,069
points

1276
00:51:28,079 --> 00:51:30,880
so first uh you know it turns out you

1277
00:51:30,880 --> 00:51:32,079
know i want to go to

1278
00:51:32,079 --> 00:51:35,359
you know looking at lock

1279
00:51:35,359 --> 00:51:37,119
you know turns out that the uart

1280
00:51:37,119 --> 00:51:39,040
actually has only one lock

1281
00:51:39,040 --> 00:51:40,559
so you can think about this as a

1282
00:51:40,559 --> 00:51:42,319
reasonable coarse grained uh

1283
00:51:42,319 --> 00:51:44,240
design at this particular point at least

1284
00:51:44,240 --> 00:51:45,359
for the uart

1285
00:51:45,359 --> 00:51:46,720
and that particular lock you know

1286
00:51:46,720 --> 00:51:48,720
protects uh basically the uart

1287
00:51:48,720 --> 00:51:51,359
transmission buffer and the right

1288
00:51:51,359 --> 00:51:52,079
pointer

1289
00:51:52,079 --> 00:51:55,599
and the read pointer and so when we

1290
00:51:55,599 --> 00:51:56,880
transmit you know the

1291
00:51:56,880 --> 00:51:59,040
right pointer points to the next free

1292
00:51:59,040 --> 00:52:01,200
slot in the transmission buffer

1293
00:52:01,200 --> 00:52:03,119
and the read pointer is the next law

1294
00:52:03,119 --> 00:52:05,200
that actually needs to be transmitted

1295
00:52:05,200 --> 00:52:09,119
okay this is our uh standard design

1296
00:52:09,119 --> 00:52:12,720
for uh parallelism uh over consumer

1297
00:52:12,720 --> 00:52:15,680
producer consumer parallelism so let me

1298
00:52:15,680 --> 00:52:18,319
go back and

1299
00:52:18,319 --> 00:52:24,790
brought it out so case study

1300
00:52:24,800 --> 00:52:29,839
uart and there's basically a buffer

1301
00:52:29,839 --> 00:52:31,440
and there's a read point there's a right

1302
00:52:31,440 --> 00:52:32,960
pointer or

1303
00:52:32,960 --> 00:52:37,040
right read index and read index

1304
00:52:37,040 --> 00:52:42,790
this has to go to the uart displayed

1305
00:52:42,800 --> 00:52:46,640
and this is the writer

1306
00:52:46,640 --> 00:52:49,200
printf maybe that actually sticks

1307
00:52:49,200 --> 00:52:52,559
characters into this buffer

1308
00:52:52,559 --> 00:52:55,359
okay and so you know what we can see is

1309
00:52:55,359 --> 00:52:56,240
that the lock

1310
00:52:56,240 --> 00:53:03,349
uh you know the lock has multiple rolls

1311
00:53:03,359 --> 00:53:05,680
one is to basically protect this data

1312
00:53:05,680 --> 00:53:11,510
structure

1313
00:53:11,520 --> 00:53:12,839
and this data structure has some

1314
00:53:12,839 --> 00:53:14,640
invariance

1315
00:53:14,640 --> 00:53:17,359
namely the read to proceed you know the

1316
00:53:17,359 --> 00:53:19,200
right

1317
00:53:19,200 --> 00:53:22,079
anything between r and w our characters

1318
00:53:22,079 --> 00:53:23,359
that need to be sent

1319
00:53:23,359 --> 00:53:25,520
anything between w and r are things that

1320
00:53:25,520 --> 00:53:29,040
actually are empty slots and the locks

1321
00:53:29,040 --> 00:53:30,480
basically help us

1322
00:53:30,480 --> 00:53:34,079
maintain that invariant

1323
00:53:34,079 --> 00:53:37,119
so here's our

1324
00:53:37,119 --> 00:53:40,240
code again and you know let's look at

1325
00:53:40,240 --> 00:53:42,319
the choirs so

1326
00:53:42,319 --> 00:53:45,520
here's the uart put c and you know the

1327
00:53:45,520 --> 00:53:46,160
first thing

1328
00:53:46,160 --> 00:53:47,599
you know you work with c does is

1329
00:53:47,599 --> 00:53:49,920
actually you know grab the lock

1330
00:53:49,920 --> 00:53:53,359
uh and then stick the character

1331
00:53:53,359 --> 00:53:55,359
if there's a place in the buffer sticks

1332
00:53:55,359 --> 00:53:57,119
the barrier character in the buffer

1333
00:53:57,119 --> 00:53:59,119
and starts you know the printing and

1334
00:53:59,119 --> 00:54:00,559
then releases

1335
00:54:00,559 --> 00:54:03,680
the lock so if two

1336
00:54:03,680 --> 00:54:06,720
processes at the same time call uart

1337
00:54:06,720 --> 00:54:07,839
quick c

1338
00:54:07,839 --> 00:54:10,640
then this lock will ensure that you know

1339
00:54:10,640 --> 00:54:12,079
one character from the first process

1340
00:54:12,079 --> 00:54:13,280
goes in the first slot

1341
00:54:13,280 --> 00:54:16,400
and then the uh second character

1342
00:54:16,400 --> 00:54:18,000
of the second process you know goes in

1343
00:54:18,000 --> 00:54:19,680
the next slot and they're known as

1344
00:54:19,680 --> 00:54:20,319
happen to

1345
00:54:20,319 --> 00:54:23,200
end up in the same slot right so this is

1346
00:54:23,200 --> 00:54:24,559
like a clear example where

1347
00:54:24,559 --> 00:54:27,760
luck you know helps us to uh

1348
00:54:27,760 --> 00:54:30,880
uh you know avoid the race condition

1349
00:54:30,880 --> 00:54:33,359
uh because otherwise you know the the

1350
00:54:33,359 --> 00:54:35,040
second process might over

1351
00:54:35,040 --> 00:54:36,880
write you know the first processes

1352
00:54:36,880 --> 00:54:38,640
character

1353
00:54:38,640 --> 00:54:41,359
so that's one part so then we go look at

1354
00:54:41,359 --> 00:54:43,040
uh

1355
00:54:43,040 --> 00:54:44,160
we did that a little bit before if you

1356
00:54:44,160 --> 00:54:45,680
look at start you know we see a couple

1357
00:54:45,680 --> 00:54:47,280
more things going on

1358
00:54:47,280 --> 00:54:50,400
um the uh

1359
00:54:50,400 --> 00:54:54,000
we see actually that the uh if the

1360
00:54:54,000 --> 00:54:57,280
buffer is not you know the uh

1361
00:54:57,280 --> 00:54:59,839
if the buffer is not empty then you know

1362
00:54:59,839 --> 00:55:00,559
we know that

1363
00:55:00,559 --> 00:55:02,559
basically there's a bunch of uh

1364
00:55:02,559 --> 00:55:04,799
characters that are being progressed

1365
00:55:04,799 --> 00:55:07,760
or being sent and you know the lock you

1366
00:55:07,760 --> 00:55:09,359
know make sure that we don't really

1367
00:55:09,359 --> 00:55:11,920
uh overwrite any of those and so

1368
00:55:11,920 --> 00:55:13,520
anything that's sort of at the

1369
00:55:13,520 --> 00:55:17,040
tail end of the queue uh is actually uh

1370
00:55:17,040 --> 00:55:18,160
being processed

1371
00:55:18,160 --> 00:55:21,910
by the uart uh

1372
00:55:21,920 --> 00:55:26,390
itself so tail end

1373
00:55:26,400 --> 00:55:30,230
is in flight

1374
00:55:30,240 --> 00:55:32,960
and we make sure that we basically don't

1375
00:55:32,960 --> 00:55:35,119
modify or interfere with that particular

1376
00:55:35,119 --> 00:55:36,240
aspect by you know

1377
00:55:36,240 --> 00:55:39,599
grabbing a lock and then finally

1378
00:55:39,599 --> 00:55:42,160
the sort of more and more thing is that

1379
00:55:42,160 --> 00:55:44,400
the rights

1380
00:55:44,400 --> 00:55:46,400
you know to the registers of the uart

1381
00:55:46,400 --> 00:55:47,839
like the thr register

1382
00:55:47,839 --> 00:55:49,599
which one there's only one you know

1383
00:55:49,599 --> 00:55:51,280
basically the lock ensures

1384
00:55:51,280 --> 00:55:52,960
uh you remember that you are start is

1385
00:55:52,960 --> 00:55:55,040
called with the lock held

1386
00:55:55,040 --> 00:55:57,359
uh ensures that there's only one writer

1387
00:55:57,359 --> 00:55:58,400
you know to the ta

1388
00:55:58,400 --> 00:56:01,520
register and so another sort of

1389
00:56:01,520 --> 00:56:02,000
invariant

1390
00:56:02,000 --> 00:56:04,480
or another aspect that the locking

1391
00:56:04,480 --> 00:56:05,920
enforces is that

1392
00:56:05,920 --> 00:56:10,470
hardware registers

1393
00:56:10,480 --> 00:56:16,559
have one writer

1394
00:56:16,559 --> 00:56:20,079
okay now there's one other instant thing

1395
00:56:20,079 --> 00:56:21,040
that i want to

1396
00:56:21,040 --> 00:56:24,160
uh talk a little bit about and that is

1397
00:56:24,160 --> 00:56:26,880
uh you know if the uart is done correct

1398
00:56:26,880 --> 00:56:28,559
the hard work is done then

1399
00:56:28,559 --> 00:56:31,839
there was an interrupt and uh

1400
00:56:31,839 --> 00:56:33,599
and as you know we noticed before york

1401
00:56:33,599 --> 00:56:36,160
start correct you know we have to

1402
00:56:36,160 --> 00:56:38,079
the color it's it's on the collar to

1403
00:56:38,079 --> 00:56:39,200
require the lock

1404
00:56:39,200 --> 00:56:42,559
to ensure uh that uh with

1405
00:56:42,559 --> 00:56:45,119
multiple uh entities writing to the

1406
00:56:45,119 --> 00:56:46,640
right register

1407
00:56:46,640 --> 00:56:50,559
um and so uh the uart interrupt itself

1408
00:56:50,559 --> 00:56:53,280
could run in parallel you know with

1409
00:56:53,280 --> 00:56:55,119
another process that called printf so if

1410
00:56:55,119 --> 00:56:56,880
some practical printf

1411
00:56:56,880 --> 00:56:59,760
that runs a cpu zero and on cpu one

1412
00:56:59,760 --> 00:57:01,520
actually takes the uart interrupt you

1413
00:57:01,520 --> 00:57:02,799
know because maybe it's doing nothing

1414
00:57:02,799 --> 00:57:03,920
and so it's ready to take an interrupt

1415
00:57:03,920 --> 00:57:05,680
at any particular point in time

1416
00:57:05,680 --> 00:57:08,960
and it will uh call your start

1417
00:57:08,960 --> 00:57:10,559
and it has to be the case correct you

1418
00:57:10,559 --> 00:57:11,920
know we want to ensure that there's a

1419
00:57:11,920 --> 00:57:13,359
single raider you know to these hardware

1420
00:57:13,359 --> 00:57:14,400
registers

1421
00:57:14,400 --> 00:57:17,440
uh or to protect you know the variance

1422
00:57:17,440 --> 00:57:18,160
actually of the

1423
00:57:18,160 --> 00:57:20,480
transmission buffer uh you know we have

1424
00:57:20,480 --> 00:57:21,680
to acquire the lock

1425
00:57:21,680 --> 00:57:24,480
and so it is the case that uh in xv6

1426
00:57:24,480 --> 00:57:25,440
actually that

1427
00:57:25,440 --> 00:57:27,680
interrupts you know can run you know so

1428
00:57:27,680 --> 00:57:29,680
the bottom half of the driver can run

1429
00:57:29,680 --> 00:57:32,960
truly concurrent on uh uh on different

1430
00:57:32,960 --> 00:57:33,680
processors

1431
00:57:33,680 --> 00:57:36,319
with the top half of the driver and so

1432
00:57:36,319 --> 00:57:37,839
therefore your interrupt

1433
00:57:37,839 --> 00:57:41,040
functions uh also acquire walks and in

1434
00:57:41,040 --> 00:57:42,640
fact in this particular case

1435
00:57:42,640 --> 00:57:44,400
uh you know it requires the one lock

1436
00:57:44,400 --> 00:57:46,640
that is actually in the uart and

1437
00:57:46,640 --> 00:57:48,000
then calls you right start and then

1438
00:57:48,000 --> 00:57:50,640
releases the lock

1439
00:57:50,640 --> 00:57:52,720
and i'll come back to that in a second

1440
00:57:52,720 --> 00:57:54,559
because there's a little bit trickiness

1441
00:57:54,559 --> 00:57:58,079
uh in implementing a lock in such a way

1442
00:57:58,079 --> 00:58:00,559
that this actually works out correctly

1443
00:58:00,559 --> 00:58:03,760
and the the thing that actually you

1444
00:58:03,760 --> 00:58:04,640
should be worried about

1445
00:58:04,640 --> 00:58:07,680
is that i'll actually talk about it in a

1446
00:58:07,680 --> 00:58:09,280
second let me postpone that until i get

1447
00:58:09,280 --> 00:58:12,950
there

1448
00:58:12,960 --> 00:58:16,559
okay so any uh questions about this is a

1449
00:58:16,559 --> 00:58:19,920
simple example of uh lock use

1450
00:58:19,920 --> 00:58:29,670
in the uart

1451
00:58:29,680 --> 00:58:32,720
okay let me uh that brings let me

1452
00:58:32,720 --> 00:58:36,000
talk about implementing a lock uh

1453
00:58:36,000 --> 00:58:38,880
and so the spec is that only one uh

1454
00:58:38,880 --> 00:58:39,680
process

1455
00:58:39,680 --> 00:58:42,480
can acquire a lock uh there's no more

1456
00:58:42,480 --> 00:58:43,040
than

1457
00:58:43,040 --> 00:58:44,640
one lock holder at any given point of

1458
00:58:44,640 --> 00:58:47,440
time and and we now want to look

1459
00:58:47,440 --> 00:58:48,880
and understand actually how you

1460
00:58:48,880 --> 00:58:50,160
implement the walk in such a way that

1461
00:58:50,160 --> 00:58:52,000
that actually is guaranteed

1462
00:58:52,000 --> 00:58:55,119
let me first write a broken lock so that

1463
00:58:55,119 --> 00:58:55,920
we understand

1464
00:58:55,920 --> 00:58:59,280
you know what the challenges for

1465
00:58:59,280 --> 00:59:05,200
broken acquire

1466
00:59:05,200 --> 00:59:06,720
so now we know what the challenge is

1467
00:59:06,720 --> 00:59:09,599
actually in implementing choir

1468
00:59:09,599 --> 00:59:14,400
uh so here's my broken one uh so

1469
00:59:14,400 --> 00:59:17,760
construct takes in environment front

1470
00:59:17,760 --> 00:59:18,480
lock

1471
00:59:18,480 --> 00:59:21,920
star l and

1472
00:59:21,920 --> 00:59:23,760
you know what it does is as follows it

1473
00:59:23,760 --> 00:59:26,400
has an infinite loop

1474
00:59:26,400 --> 00:59:31,280
while one uh you know if

1475
00:59:31,280 --> 00:59:34,480
uh l is

1476
00:59:34,480 --> 00:59:36,880
locked to zero meaning nobody's holding

1477
00:59:36,880 --> 00:59:37,920
it

1478
00:59:37,920 --> 00:59:39,920
then presumably the caller should grab

1479
00:59:39,920 --> 00:59:42,799
the log so

1480
00:59:42,799 --> 00:59:48,309
then we set l lock to one

1481
00:59:48,319 --> 00:59:50,079
and you know at that point we got the

1482
00:59:50,079 --> 00:59:51,680
lock so we can return

1483
00:59:51,680 --> 00:59:54,720
nothing to do anymore and close

1484
00:59:54,720 --> 00:59:56,240
loop if we didn't get the lock because

1485
00:59:56,240 --> 00:59:57,359
when the lock was one that means

1486
00:59:57,359 --> 00:59:58,799
somebody else is holding lock so we just

1487
00:59:58,799 --> 01:00:00,640
keep spinning

1488
01:00:00,640 --> 01:00:02,720
and waiting to go around the loop over

1489
01:00:02,720 --> 01:00:04,000
and over and over

1490
01:00:04,000 --> 01:00:06,880
until at some point you know the whole

1491
01:00:06,880 --> 01:00:07,760
lock holder called

1492
01:00:07,760 --> 01:00:11,040
release which will set lock to will set

1493
01:00:11,040 --> 01:00:14,720
lock to zero

1494
01:00:14,720 --> 01:00:17,359
and you know so what's wrong with this

1495
01:00:17,359 --> 01:00:20,870
particular implementation

1496
01:00:20,880 --> 01:00:23,839
i think two processes might read that

1497
01:00:23,839 --> 01:00:24,480
it's uh

1498
01:00:24,480 --> 01:00:29,599
not locked at the same time yeah right

1499
01:00:29,599 --> 01:00:31,280
yeah so there's a race condition here

1500
01:00:31,280 --> 01:00:33,599
right and uh

1501
01:00:33,599 --> 01:00:35,599
just to make sure that the race is right

1502
01:00:35,599 --> 01:00:39,349
here

1503
01:00:39,359 --> 01:00:42,319
we can have basically two cpus coming in

1504
01:00:42,319 --> 01:00:44,559
so if we talk a time diagram

1505
01:00:44,559 --> 01:00:48,079
you know cpu one uh cpu zero

1506
01:00:48,079 --> 01:00:52,480
cpu one you know this is statement a

1507
01:00:52,480 --> 01:00:55,839
maybe this is statement b uh both cpu

1508
01:00:55,839 --> 01:00:56,319
one

1509
01:00:56,319 --> 01:00:59,440
you know reaches statement a uh

1510
01:00:59,440 --> 01:01:03,910
and cpu zero and cpu uh

1511
01:01:03,920 --> 01:01:05,599
zero one both are each statement a so

1512
01:01:05,599 --> 01:01:07,040
they both see

1513
01:01:07,040 --> 01:01:10,160
uh locked being zero and then they above

1514
01:01:10,160 --> 01:01:13,349
execute b

1515
01:01:13,359 --> 01:01:16,960
all right so here they see lock to zero

1516
01:01:16,960 --> 01:01:20,630
this guy c lock to zero

1517
01:01:20,640 --> 01:01:22,720
and so they both execute statement b and

1518
01:01:22,720 --> 01:01:23,839
now both uh

1519
01:01:23,839 --> 01:01:27,280
have uh acquired the lock and uh which

1520
01:01:27,280 --> 01:01:29,359
violated you know the spec of this

1521
01:01:29,359 --> 01:01:31,520
particular function

1522
01:01:31,520 --> 01:01:35,589
this makes sense

1523
01:01:35,599 --> 01:01:38,160
so it turns out you know to solve this

1524
01:01:38,160 --> 01:01:38,720
problem

1525
01:01:38,720 --> 01:01:40,160
and sort of get a correct implementation

1526
01:01:40,160 --> 01:01:41,440
there are multiple ways of going about

1527
01:01:41,440 --> 01:01:42,400
it

1528
01:01:42,400 --> 01:01:44,799
but the most common way is to rely

1529
01:01:44,799 --> 01:01:46,160
basically on a special hardware

1530
01:01:46,160 --> 01:01:47,680
instruction

1531
01:01:47,680 --> 01:01:49,760
uh an art of instruction that basically

1532
01:01:49,760 --> 01:01:50,799
what it does

1533
01:01:50,799 --> 01:01:53,040
it does this test and this set

1534
01:01:53,040 --> 01:01:55,990
atomically

1535
01:01:56,000 --> 01:02:00,400
and so the solution to this

1536
01:02:00,400 --> 01:02:06,400
problem is hardware

1537
01:02:06,400 --> 01:02:17,349
test and set support

1538
01:02:17,359 --> 01:02:18,720
and the way you can think about it you

1539
01:02:18,720 --> 01:02:21,039
know on the risk five you know this

1540
01:02:21,039 --> 01:02:22,720
instruction actually is the

1541
01:02:22,720 --> 01:02:26,789
atomic memory operation swap

1542
01:02:26,799 --> 01:02:29,920
that we're going to be using uh and

1543
01:02:29,920 --> 01:02:31,599
it basically boils down to test and then

1544
01:02:31,599 --> 01:02:32,960
a set and you know basically what the

1545
01:02:32,960 --> 01:02:34,240
hardware guarantees

1546
01:02:34,240 --> 01:02:36,880
if you will so you take this uh it takes

1547
01:02:36,880 --> 01:02:38,720
two arguments or three arguments an

1548
01:02:38,720 --> 01:02:40,160
address

1549
01:02:40,160 --> 01:02:43,359
uh a register one r1

1550
01:02:43,359 --> 01:02:46,720
and a register two and essentially what

1551
01:02:46,720 --> 01:02:48,400
the hardware does the

1552
01:02:48,400 --> 01:02:51,839
just conceptually is basically it locks

1553
01:02:51,839 --> 01:02:53,440
the address

1554
01:02:53,440 --> 01:02:55,680
if you will i'll talk about that in a

1555
01:02:55,680 --> 01:02:57,039
second a little bit more with logs

1556
01:02:57,039 --> 01:02:58,160
address

1557
01:02:58,160 --> 01:03:01,190
it

1558
01:03:01,200 --> 01:03:04,160
it puts in a temporary variable you know

1559
01:03:04,160 --> 01:03:04,480
the

1560
01:03:04,480 --> 01:03:06,240
value that actually is at that

1561
01:03:06,240 --> 01:03:09,589
particular address

1562
01:03:09,599 --> 01:03:13,270
and then

1563
01:03:13,280 --> 01:03:17,520
writes the value of r1 into that address

1564
01:03:17,520 --> 01:03:20,160
and then basically puts the value that

1565
01:03:20,160 --> 01:03:21,359
was at the

1566
01:03:21,359 --> 01:03:24,720
originally at the address into the temp

1567
01:03:24,720 --> 01:03:27,599
uh the temporary value that was the

1568
01:03:27,599 --> 01:03:28,640
original value that was actually

1569
01:03:28,640 --> 01:03:30,400
addressed actually into an r2

1570
01:03:30,400 --> 01:03:35,589
and then basically unlocks and returns

1571
01:03:35,599 --> 01:03:38,640
um and you know

1572
01:03:38,640 --> 01:03:41,119
in the this lock if you will guarantee

1573
01:03:41,119 --> 01:03:42,640
is that basically this test

1574
01:03:42,640 --> 01:03:44,079
you know where the result of the test is

1575
01:03:44,079 --> 01:03:45,680
returned into r2

1576
01:03:45,680 --> 01:03:48,960
and the set actually happen atomically

1577
01:03:48,960 --> 01:03:50,960
and so this is a hardware instruction uh

1578
01:03:50,960 --> 01:03:52,799
most processors have an artwork

1579
01:03:52,799 --> 01:03:55,359
instruction like this

1580
01:03:55,359 --> 01:03:56,960
because it's a convenient way to

1581
01:03:56,960 --> 01:04:01,430
actually implement locks

1582
01:04:01,440 --> 01:04:03,280
and so basically what we've done is like

1583
01:04:03,280 --> 01:04:04,720
we've reduced you know sort of the

1584
01:04:04,720 --> 01:04:06,880
automaticity of this

1585
01:04:06,880 --> 01:04:09,839
or the software lock implementation to

1586
01:04:09,839 --> 01:04:10,480
basically

1587
01:04:10,480 --> 01:04:14,240
a hardware lock implementation uh

1588
01:04:14,240 --> 01:04:18,400
and uh so the processor might implement

1589
01:04:18,400 --> 01:04:18,880
this in

1590
01:04:18,880 --> 01:04:21,359
very different ways so basically uh the

1591
01:04:21,359 --> 01:04:22,960
instruction set itself where this is

1592
01:04:22,960 --> 01:04:24,400
like a specification it doesn't actually

1593
01:04:24,400 --> 01:04:25,760
say how it's implemented

1594
01:04:25,760 --> 01:04:27,599
and this is very dependent in the actual

1595
01:04:27,599 --> 01:04:30,309
implementation

1596
01:04:30,319 --> 01:04:34,710
of this is dependent

1597
01:04:34,720 --> 01:04:44,309
on how the memory system exactly works

1598
01:04:44,319 --> 01:04:47,520
so for example uh if you know the module

1599
01:04:47,520 --> 01:04:48,319
processor

1600
01:04:48,319 --> 01:04:50,960
uh share a single memory controller that

1601
01:04:50,960 --> 01:04:52,160
retail writes to memory

1602
01:04:52,160 --> 01:04:53,680
then the memory controller can actually

1603
01:04:53,680 --> 01:04:56,160
support this operation you can basically

1604
01:04:56,160 --> 01:04:58,480
allow uh basically you know set a lock

1605
01:04:58,480 --> 01:04:59,680
and a particular address you know and

1606
01:04:59,680 --> 01:05:00,079
then

1607
01:05:00,079 --> 01:05:01,839
let you know one processor do two

1608
01:05:01,839 --> 01:05:03,280
operations or three uh

1609
01:05:03,280 --> 01:05:05,280
instructions and then basically unlock

1610
01:05:05,280 --> 01:05:06,839
and so since all the

1611
01:05:06,839 --> 01:05:08,559
processors the reason writes go for this

1612
01:05:08,559 --> 01:05:10,000
memory controller the memory controller

1613
01:05:10,000 --> 01:05:12,240
can do the ordering or the blocking

1614
01:05:12,240 --> 01:05:16,240
uh if the memories are in this processor

1615
01:05:16,240 --> 01:05:18,799
sit on the shared bus

1616
01:05:18,799 --> 01:05:20,640
it's often the bus arbiter that can

1617
01:05:20,640 --> 01:05:22,000
actually do that where the bus arbiter

1618
01:05:22,000 --> 01:05:23,039
has support for

1619
01:05:23,039 --> 01:05:25,839
basically executing two uh memory

1620
01:05:25,839 --> 01:05:28,319
operations in an atomic way

1621
01:05:28,319 --> 01:05:31,359
uh if it's a if the processors have

1622
01:05:31,359 --> 01:05:32,400
caches

1623
01:05:32,400 --> 01:05:35,119
uh then it's sort of typically part of

1624
01:05:35,119 --> 01:05:37,039
the cash rehearse protocol where

1625
01:05:37,039 --> 01:05:39,839
uh the cash continues protocol will

1626
01:05:39,839 --> 01:05:40,480
ensure that

1627
01:05:40,480 --> 01:05:42,319
if there's a writer you know that that

1628
01:05:42,319 --> 01:05:44,720
particular uh

1629
01:05:44,720 --> 01:05:46,400
the cash line that holds you know the

1630
01:05:46,400 --> 01:05:48,640
the value that we want to update ends up

1631
01:05:48,640 --> 01:05:50,559
in one single cache

1632
01:05:50,559 --> 01:05:52,000
and then you know basically the

1633
01:05:52,000 --> 01:05:53,440
processor is going to sort of lock that

1634
01:05:53,440 --> 01:05:54,880
single cache line across

1635
01:05:54,880 --> 01:05:58,079
two uh operations and so the the

1636
01:05:58,079 --> 01:05:59,039
implementation of this

1637
01:05:59,039 --> 01:06:00,319
you know can be done in many different

1638
01:06:00,319 --> 01:06:02,720
ways uh but conceptually

1639
01:06:02,720 --> 01:06:04,640
the what's going on is like you lock the

1640
01:06:04,640 --> 01:06:07,760
address uh you read the original value

1641
01:06:07,760 --> 01:06:09,760
you store in the new value and you

1642
01:06:09,760 --> 01:06:12,160
return the old value

1643
01:06:12,160 --> 01:06:15,670
does that make sense

1644
01:06:15,680 --> 01:06:17,920
to make that to see how we can use that

1645
01:06:17,920 --> 01:06:19,520
instruction

1646
01:06:19,520 --> 01:06:20,400
let's actually look at the

1647
01:06:20,400 --> 01:06:24,240
implementation of acquire and release in

1648
01:06:24,240 --> 01:06:26,400
xv6 and then we'll expose a couple of

1649
01:06:26,400 --> 01:06:31,670
other interesting details

1650
01:06:31,680 --> 01:06:35,039
so let me first uh bring up spinlock.h

1651
01:06:35,039 --> 01:06:39,119
uh it's been locked at h as you can see

1652
01:06:39,119 --> 01:06:42,240
it's pretty straightforward uh it has

1653
01:06:42,240 --> 01:06:42,640
this

1654
01:06:42,640 --> 01:06:45,359
flight lock exactly as in our pseudocode

1655
01:06:45,359 --> 01:06:46,720
and then it has two other things for

1656
01:06:46,720 --> 01:06:48,720
debugging namely the name of the lock

1657
01:06:48,720 --> 01:06:52,160
and the cpu the last the current cpu

1658
01:06:52,160 --> 01:06:54,480
that actually is holding the lock

1659
01:06:54,480 --> 01:06:55,599
and this is mostly to print out

1660
01:06:55,599 --> 01:06:57,520
debugging messages for example if you do

1661
01:06:57,520 --> 01:07:01,599
two acquires on the same cpu

1662
01:07:01,599 --> 01:07:06,069
okay so then let's look at

1663
01:07:06,079 --> 01:07:11,990
the implementation

1664
01:07:12,000 --> 01:07:15,119
uh and so let's start out with the choir

1665
01:07:15,119 --> 01:07:19,520
um and let's first look at this loop

1666
01:07:19,520 --> 01:07:22,880
so this is actually uh the sort of test

1667
01:07:22,880 --> 01:07:25,280
and set loop that i just talked about

1668
01:07:25,280 --> 01:07:28,400
it turns out that in um

1669
01:07:28,400 --> 01:07:31,839
uh the c standard actually defines

1670
01:07:31,839 --> 01:07:35,599
uh one of these atomic operations and so

1671
01:07:35,599 --> 01:07:37,920
um and so the c standard actually has a

1672
01:07:37,920 --> 01:07:39,119
function that

1673
01:07:39,119 --> 01:07:42,000
uh says you know sync lock test and set

1674
01:07:42,000 --> 01:07:43,839
and basically it specifies behavior that

1675
01:07:43,839 --> 01:07:44,240
i

1676
01:07:44,240 --> 01:07:46,640
just described and then every processor

1677
01:07:46,640 --> 01:07:48,160
basically is required you know to

1678
01:07:48,160 --> 01:07:48,720
implement

1679
01:07:48,720 --> 01:07:51,440
uh that behavior and since most

1680
01:07:51,440 --> 01:07:52,799
processors have a

1681
01:07:52,799 --> 01:07:54,480
matching sort of test and set hardware

1682
01:07:54,480 --> 01:07:56,319
instruction this turns out to be a

1683
01:07:56,319 --> 01:07:57,520
reasonable straightforward or

1684
01:07:57,520 --> 01:07:58,559
approximate to implement

1685
01:07:58,559 --> 01:08:01,280
and so in fact if you look at kernel.asm

1686
01:08:01,280 --> 01:08:02,559
you know we can look at the assembly

1687
01:08:02,559 --> 01:08:04,240
instructions and see exactly you know

1688
01:08:04,240 --> 01:08:08,829
what the risk 5 processor does

1689
01:08:08,839 --> 01:08:12,240
so back here is

1690
01:08:12,240 --> 01:08:14,640
our assembly instructions for require

1691
01:08:14,640 --> 01:08:15,599
and

1692
01:08:15,599 --> 01:08:27,829
let's here's our atomic swap instruction

1693
01:08:27,839 --> 01:08:31,520
uh so as you can see uh if

1694
01:08:31,520 --> 01:08:33,600
you know an atomic swap basically uh is

1695
01:08:33,600 --> 01:08:35,199
called with the register a5

1696
01:08:35,199 --> 01:08:38,640
and uh as the input and the output also

1697
01:08:38,640 --> 01:08:40,080
ends up in a5

1698
01:08:40,080 --> 01:08:43,279
and s1 is to hold to the address and

1699
01:08:43,279 --> 01:08:46,560
uh and if it's not equal

1700
01:08:46,560 --> 01:08:49,679
uh we return and otherwise

1701
01:08:49,679 --> 01:08:52,880
basically we go back you know to uh

1702
01:08:52,880 --> 01:08:57,120
jump back to uh uh

1703
01:08:57,120 --> 01:08:58,400
double check i'm saying the right thing

1704
01:08:58,400 --> 01:09:00,239
here uh move a

1705
01:09:00,239 --> 01:09:04,159
four in six if not equal to go to ox

1706
01:09:04,159 --> 01:09:07,199
20 plus oaks 22.

1707
01:09:07,199 --> 01:09:09,359
uh that's a little bit hard to calculate

1708
01:09:09,359 --> 01:09:10,960
but that basically in one case we branch

1709
01:09:10,960 --> 01:09:11,359
out

1710
01:09:11,359 --> 01:09:14,159
and in the other case we branch back and

1711
01:09:14,159 --> 01:09:15,520
so this may be easier to

1712
01:09:15,520 --> 01:09:18,029
look at the c code

1713
01:09:18,029 --> 01:09:19,440
[Music]

1714
01:09:19,440 --> 01:09:22,159
so let's go in here so what happens so

1715
01:09:22,159 --> 01:09:22,719
if the

1716
01:09:22,719 --> 01:09:26,000
if the lock is not held uh what will be

1717
01:09:26,000 --> 01:09:27,279
the value of l locked well

1718
01:09:27,279 --> 01:09:30,640
l log will be zero all right and so

1719
01:09:30,640 --> 01:09:32,480
we call this test and set what will

1720
01:09:32,480 --> 01:09:34,319
happen is we'll write a one

1721
01:09:34,319 --> 01:09:37,359
yeah in walked but return the previous

1722
01:09:37,359 --> 01:09:38,480
value

1723
01:09:38,480 --> 01:09:41,679
so if the previous value is zero uh

1724
01:09:41,679 --> 01:09:43,839
then we're good right because that means

1725
01:09:43,839 --> 01:09:45,679
that nobody was holding the lock and we

1726
01:09:45,679 --> 01:09:46,319
fall through

1727
01:09:46,319 --> 01:09:49,600
and we're done with this while loop

1728
01:09:49,600 --> 01:09:51,920
now let's say the log value was one so

1729
01:09:51,920 --> 01:09:53,120
the pro the

1730
01:09:53,120 --> 01:09:55,600
the lock was actually locked well what

1731
01:09:55,600 --> 01:09:57,199
will this instruction do

1732
01:09:57,199 --> 01:10:00,719
it will uh read you know the old value

1733
01:10:00,719 --> 01:10:02,800
and put that at the site correct that is

1734
01:10:02,800 --> 01:10:04,800
one actually in this case and then write

1735
01:10:04,800 --> 01:10:07,760
a new one into that location

1736
01:10:07,760 --> 01:10:10,080
um and but that will change nothing

1737
01:10:10,080 --> 01:10:11,040
right because the

1738
01:10:11,040 --> 01:10:13,600
lock was already locked and and the

1739
01:10:13,600 --> 01:10:15,360
function will return one

1740
01:10:15,360 --> 01:10:16,640
indicating that actually somebody the

1741
01:10:16,640 --> 01:10:18,719
previous hold that it was already locked

1742
01:10:18,719 --> 01:10:19,840
and so in that case

1743
01:10:19,840 --> 01:10:22,400
it's unequal to zero and so we'll spin

1744
01:10:22,400 --> 01:10:23,679
and we'll keep spinning

1745
01:10:23,679 --> 01:10:27,040
until locked actually is set back to

1746
01:10:27,040 --> 01:10:29,679
uh zero and zoom level happened in the

1747
01:10:29,679 --> 01:10:32,390
release

1748
01:10:32,400 --> 01:10:51,270
any questions about this

1749
01:10:51,280 --> 01:10:55,990
no questions okay um

1750
01:10:56,000 --> 01:10:57,520
so now basically you know let's look at

1751
01:10:57,520 --> 01:11:00,159
the corresponding uh

1752
01:11:00,159 --> 01:11:03,520
the release operation and

1753
01:11:03,520 --> 01:11:07,510
uh

1754
01:11:07,520 --> 01:11:10,719
and uh here's uh the release operation

1755
01:11:10,719 --> 01:11:15,990
and if you look at the kernel asm again

1756
01:11:16,000 --> 01:11:18,960
that instruction uh so let's release

1757
01:11:18,960 --> 01:11:22,080
probably right after it here's release

1758
01:11:22,080 --> 01:11:24,000
so the release actually also uses this

1759
01:11:24,000 --> 01:11:27,910
atomic swap instruction

1760
01:11:27,920 --> 01:11:33,430
and putting basically zero into s1

1761
01:11:33,440 --> 01:11:35,840
and so this guarantee is basically that

1762
01:11:35,840 --> 01:11:38,480
this atomic update you know to

1763
01:11:38,480 --> 01:11:41,679
lock or lk locked uh

1764
01:11:41,679 --> 01:11:43,600
writing a zero into lk locked is an

1765
01:11:43,600 --> 01:11:46,239
atomic operation

1766
01:11:46,239 --> 01:11:48,400
many of you ask why not just you know

1767
01:11:48,400 --> 01:11:49,679
you store

1768
01:11:49,679 --> 01:11:51,120
a store instruction to actually write to

1769
01:11:51,120 --> 01:11:55,360
zero and anybody

1770
01:11:55,360 --> 01:11:59,040
may want to guess why why that might not

1771
01:11:59,040 --> 01:11:59,840
work or

1772
01:11:59,840 --> 01:12:03,199
what the problem could be because then

1773
01:12:03,199 --> 01:12:04,960
some other process might be writing a

1774
01:12:04,960 --> 01:12:06,800
one to the log or

1775
01:12:06,800 --> 01:12:09,520
no or writing another zero but that

1776
01:12:09,520 --> 01:12:11,280
can't be the case right

1777
01:12:11,280 --> 01:12:12,640
yeah well there could be okay so there

1778
01:12:12,640 --> 01:12:14,560
could be two processes or two cpus

1779
01:12:14,560 --> 01:12:16,239
writing to l locked at the same time

1780
01:12:16,239 --> 01:12:17,280
right

1781
01:12:17,280 --> 01:12:19,520
uh but i think what the the question

1782
01:12:19,520 --> 01:12:21,440
really is that you know for many people

1783
01:12:21,440 --> 01:12:23,360
and i often assume this too

1784
01:12:23,360 --> 01:12:24,880
is that you when you do a single store

1785
01:12:24,880 --> 01:12:26,000
instruction that's sort of like an

1786
01:12:26,000 --> 01:12:28,960
atomic operation

1787
01:12:28,960 --> 01:12:30,880
and that is not always the case you know

1788
01:12:30,880 --> 01:12:32,480
for example if you

1789
01:12:32,480 --> 01:12:34,239
uh and it really depends on the

1790
01:12:34,239 --> 01:12:35,520
architectural implementation

1791
01:12:35,520 --> 01:12:37,360
like for example if the cascadiers

1792
01:12:37,360 --> 01:12:39,280
protocol works or the cache system works

1793
01:12:39,280 --> 01:12:40,960
using cache lines where a cache line may

1794
01:12:40,960 --> 01:12:41,920
be

1795
01:12:41,920 --> 01:12:43,840
bigger than an integer typically bigger

1796
01:12:43,840 --> 01:12:44,960
than the integer

1797
01:12:44,960 --> 01:12:47,120
uh then really what's happening is the

1798
01:12:47,120 --> 01:12:48,719
first operation is loading the cache

1799
01:12:48,719 --> 01:12:50,719
line and then updating the cache line

1800
01:12:50,719 --> 01:12:52,239
so in fact you know a store instruction

1801
01:12:52,239 --> 01:12:53,600
basically has sort of two micro

1802
01:12:53,600 --> 01:12:54,800
operations in it

1803
01:12:54,800 --> 01:12:59,590
and and you can get the wrong result

1804
01:12:59,600 --> 01:13:03,360
and so uh you know the to the devoid you

1805
01:13:03,360 --> 01:13:03,679
know

1806
01:13:03,679 --> 01:13:04,960
having to understand anything of the

1807
01:13:04,960 --> 01:13:06,480
hardware implementation of exactly and

1808
01:13:06,480 --> 01:13:08,320
whether integers operations are atomic

1809
01:13:08,320 --> 01:13:08,880
or not

1810
01:13:08,880 --> 01:13:12,400
or writing to 64-bit 64

1811
01:13:12,400 --> 01:13:14,719
bit memory values and atomic operation

1812
01:13:14,719 --> 01:13:16,000
you know we use the

1813
01:13:16,000 --> 01:13:19,040
uh uh there is five

1814
01:13:19,040 --> 01:13:20,480
operation that is guaranteed to be

1815
01:13:20,480 --> 01:13:24,790
executed atomically

1816
01:13:24,800 --> 01:13:28,070
does that make sense

1817
01:13:28,080 --> 01:13:33,120
yes okay okay so just to uh

1818
01:13:33,120 --> 01:13:36,159
just for your amusement uh the

1819
01:13:36,159 --> 01:13:38,080
atomic swap is not the only instruction

1820
01:13:38,080 --> 01:13:40,239
uh that exists uh so here's the risk

1821
01:13:40,239 --> 01:13:41,440
five manual

1822
01:13:41,440 --> 01:13:43,840
uh and it lists a whole bunch of the

1823
01:13:43,840 --> 01:13:45,440
atomic operations so there's an atomic

1824
01:13:45,440 --> 01:13:45,760
end

1825
01:13:45,760 --> 01:13:48,880
an atomic ore and there's a max min

1826
01:13:48,880 --> 01:13:52,640
that all can read and write a value

1827
01:13:52,640 --> 01:13:58,830
in an atomic operation

1828
01:13:58,840 --> 01:14:01,280
okay so there's a couple other things

1829
01:14:01,280 --> 01:14:02,320
that i want to point out

1830
01:14:02,320 --> 01:14:06,400
uh in this particular implementation um

1831
01:14:06,400 --> 01:14:10,000
and let me start again and go back to

1832
01:14:10,000 --> 01:14:13,360
acquire uh so

1833
01:14:13,360 --> 01:14:16,159
one of the first things that the uh

1834
01:14:16,159 --> 01:14:17,760
acquire function does

1835
01:14:17,760 --> 01:14:20,800
uh is it uh turns off

1836
01:14:20,800 --> 01:14:24,560
interrupts and it'd be good to

1837
01:14:24,560 --> 01:14:26,400
understand why that is the case and so

1838
01:14:26,400 --> 01:14:28,640
for that i'm to go back to our uart exam

1839
01:14:28,640 --> 01:14:30,880
code and you think a little bit about

1840
01:14:30,880 --> 01:14:32,159
this

1841
01:14:32,159 --> 01:14:34,480
and so we want to think about the case

1842
01:14:34,480 --> 01:14:35,440
where

1843
01:14:35,440 --> 01:14:38,880
uh a query is actually maybe incorrectly

1844
01:14:38,880 --> 01:14:40,719
implemented and does not turn off

1845
01:14:40,719 --> 01:14:43,360
erupts so and the way to think about

1846
01:14:43,360 --> 01:14:44,960
this is if we go to europe

1847
01:14:44,960 --> 01:14:47,679
put c and here you know let's say your

1848
01:14:47,679 --> 01:14:49,199
qt runs

1849
01:14:49,199 --> 01:14:53,440
and uh acquires the lock

1850
01:14:53,440 --> 01:14:55,520
and but does not turn off interrupts

1851
01:14:55,520 --> 01:15:02,790
what can happen

1852
01:15:02,800 --> 01:15:04,239
i'll give everybody a couple seconds to

1853
01:15:04,239 --> 01:15:05,920
think about it but

1854
01:15:05,920 --> 01:15:07,840
if you have an idea or why it might be

1855
01:15:07,840 --> 01:15:09,440
wrong you know like

1856
01:15:09,440 --> 01:15:18,709
jump in

1857
01:15:18,719 --> 01:15:22,560
perhaps it could be interrupted because

1858
01:15:22,560 --> 01:15:25,840
of um because of the clock

1859
01:15:25,840 --> 01:15:29,040
and then something happens and it needs

1860
01:15:29,040 --> 01:15:30,480
to print something

1861
01:15:30,480 --> 01:15:33,840
else and it tries to do your put c again

1862
01:15:33,840 --> 01:15:36,000
but the lock is already taken yeah that

1863
01:15:36,000 --> 01:15:37,280
might be a possible scenario

1864
01:15:37,280 --> 01:15:39,679
uh there's a much more direct example

1865
01:15:39,679 --> 01:15:40,719
for this

1866
01:15:40,719 --> 01:15:42,239
so let's just say you are could see you

1867
01:15:42,239 --> 01:15:43,760
know drives lock

1868
01:15:43,760 --> 01:15:45,920
and the universe basically transmitting

1869
01:15:45,920 --> 01:15:47,520
some character

1870
01:15:47,520 --> 01:15:49,920
so one the urge is done uh transmitting

1871
01:15:49,920 --> 01:15:53,280
character what does it do

1872
01:15:53,280 --> 01:15:56,000
it causes an interrupt correct and you

1873
01:15:56,000 --> 01:15:57,840
are interrupted runs

1874
01:15:57,840 --> 01:16:01,120
and what does your interrupt do it grabs

1875
01:16:01,120 --> 01:16:02,400
the same lock

1876
01:16:02,400 --> 01:16:04,560
you know that the pc is holding right so

1877
01:16:04,560 --> 01:16:06,000
what will happen here

1878
01:16:06,000 --> 01:16:08,080
if there's only one cpu and so there's

1879
01:16:08,080 --> 01:16:09,520
no other cpu where this

1880
01:16:09,520 --> 01:16:12,800
interrupt could be running well we have

1881
01:16:12,800 --> 01:16:13,440
a deadlock

1882
01:16:13,440 --> 01:16:17,199
right because the current cpu is holding

1883
01:16:17,199 --> 01:16:19,840
the lock as part of you put see then

1884
01:16:19,840 --> 01:16:20,480
later

1885
01:16:20,480 --> 01:16:22,560
the interrupt came in and the first

1886
01:16:22,560 --> 01:16:23,600
thing it tries to do is actually

1887
01:16:23,600 --> 01:16:25,600
acquired a lot that's already held

1888
01:16:25,600 --> 01:16:27,360
in fact you know in the case of xv6 you

1889
01:16:27,360 --> 01:16:28,960
know we'll get a panic you know because

1890
01:16:28,960 --> 01:16:30,800
you know the same cpu

1891
01:16:30,800 --> 01:16:32,159
is actually trying to acquire the same

1892
01:16:32,159 --> 01:16:37,430
lock again

1893
01:16:37,440 --> 01:16:39,840
so basically you know what acquire or

1894
01:16:39,840 --> 01:16:41,520
spinlock deals with is sort of two

1895
01:16:41,520 --> 01:16:42,880
different types of concurrency

1896
01:16:42,880 --> 01:16:44,239
you know one there's sort of concurrency

1897
01:16:44,239 --> 01:16:45,920
between two different cpus

1898
01:16:45,920 --> 01:16:47,360
we got to make sure that for example if

1899
01:16:47,360 --> 01:16:49,360
the interrupter function runs on a

1900
01:16:49,360 --> 01:16:50,400
different cpu

1901
01:16:50,400 --> 01:16:51,920
that basically we don't get a raise on

1902
01:16:51,920 --> 01:16:53,520
the transmission buffer

1903
01:16:53,520 --> 01:16:55,280
but if they run in the same cpu we got

1904
01:16:55,280 --> 01:16:57,199
to make sure that it's still atomic

1905
01:16:57,199 --> 01:16:58,880
uh and that is not being interrupted and

1906
01:16:58,880 --> 01:17:00,320
therefore we actually turn the yarn

1907
01:17:00,320 --> 01:17:00,880
wraps off

1908
01:17:00,880 --> 01:17:04,400
in the choir and they're only turned on

1909
01:17:04,400 --> 01:17:05,120
again

1910
01:17:05,120 --> 01:17:08,239
at the end of release when the lock

1911
01:17:08,239 --> 01:17:09,760
actually has been released and at that

1912
01:17:09,760 --> 01:17:11,360
point it's safe again you know to take

1913
01:17:11,360 --> 01:17:12,400
these interrupts

1914
01:17:12,400 --> 01:17:14,320
because the lock actually is not

1915
01:17:14,320 --> 01:17:16,640
released anymore it's not acquired

1916
01:17:16,640 --> 01:17:18,960
holding it not health anymore

1917
01:17:18,960 --> 01:17:28,470
does that make sense

1918
01:17:28,480 --> 01:17:31,440
okay there's one more subtle thing in

1919
01:17:31,440 --> 01:17:32,080
this

1920
01:17:32,080 --> 01:17:35,600
implementation that i want to talk about

1921
01:17:35,600 --> 01:17:43,110
and that we need to deal with

1922
01:17:43,120 --> 01:17:53,830
and that is uh memory ordering

1923
01:17:53,840 --> 01:17:56,880
so uh for example if you think about you

1924
01:17:56,880 --> 01:17:57,520
know locked

1925
01:17:57,520 --> 01:18:00,719
is let's say acquires it's locked you

1926
01:18:00,719 --> 01:18:00,960
know

1927
01:18:00,960 --> 01:18:03,840
to one uh maybe we have a critical

1928
01:18:03,840 --> 01:18:05,760
section in which you know x is except x

1929
01:18:05,760 --> 01:18:06,960
plus one

1930
01:18:06,960 --> 01:18:10,960
and uh and then require

1931
01:18:10,960 --> 01:18:13,440
release you know says lock to zero so

1932
01:18:13,440 --> 01:18:14,880
you sort of think about the instruction

1933
01:18:14,880 --> 01:18:16,400
stream that's being executed on a

1934
01:18:16,400 --> 01:18:17,520
particular cpu

1935
01:18:17,520 --> 01:18:18,480
you know so these are sort of the

1936
01:18:18,480 --> 01:18:19,920
instructions that are being executed

1937
01:18:19,920 --> 01:18:22,149
right

1938
01:18:22,159 --> 01:18:24,880
now if the code were just purely uh

1939
01:18:24,880 --> 01:18:27,090
sequential

1940
01:18:27,090 --> 01:18:30,480
[Music]

1941
01:18:30,480 --> 01:18:34,070
the compiler or the

1942
01:18:34,080 --> 01:18:36,000
processor could actually or reorder

1943
01:18:36,000 --> 01:18:37,600
instructions you know just to get better

1944
01:18:37,600 --> 01:18:39,360
performance

1945
01:18:39,360 --> 01:18:42,159
so for example uh if it were a

1946
01:18:42,159 --> 01:18:43,120
sequential stream

1947
01:18:43,120 --> 01:18:44,560
would it be okay to move this

1948
01:18:44,560 --> 01:18:49,189
instruction to afterwards

1949
01:18:49,199 --> 01:18:51,600
would that change the correctness of the

1950
01:18:51,600 --> 01:18:58,070
single stream of execution

1951
01:18:58,080 --> 01:18:59,840
no not really right because lock and x

1952
01:18:59,840 --> 01:19:01,120
are totally independent of each other

1953
01:19:01,120 --> 01:19:03,199
there's no relation to it so it'd be

1954
01:19:03,199 --> 01:19:05,040
perfectly fine if it were a sequential

1955
01:19:05,040 --> 01:19:06,000
execution

1956
01:19:06,000 --> 01:19:07,920
that the x you know has moved after the

1957
01:19:07,920 --> 01:19:09,280
locked uh

1958
01:19:09,280 --> 01:19:14,310
log zero so that you know on the single

1959
01:19:14,320 --> 01:19:17,990
single serial execution

1960
01:19:18,000 --> 01:19:23,440
that's okay

1961
01:19:23,440 --> 01:19:25,600
and in fact so in effect processors you

1962
01:19:25,600 --> 01:19:27,040
know do this all the time you know they

1963
01:19:27,040 --> 01:19:29,040
do respectively execute stuff

1964
01:19:29,040 --> 01:19:31,040
uh or especially execute instructions

1965
01:19:31,040 --> 01:19:32,640
and so that can result in basically

1966
01:19:32,640 --> 01:19:34,719
these instructions reorderings

1967
01:19:34,719 --> 01:19:37,520
uh the compiler does it too you know to

1968
01:19:37,520 --> 01:19:39,199
maybe optimize you know some code path

1969
01:19:39,199 --> 01:19:40,800
and it also will reorder instructions as

1970
01:19:40,800 --> 01:19:41,920
long as it like you know

1971
01:19:41,920 --> 01:19:44,800
results in the same serial execution but

1972
01:19:44,800 --> 01:19:46,480
clearly during concurrent execution this

1973
01:19:46,480 --> 01:19:48,400
would be disaster correct because if

1974
01:19:48,400 --> 01:19:52,239
locked which a require and this was our

1975
01:19:52,239 --> 01:19:54,080
release

1976
01:19:54,080 --> 01:19:55,520
then basically what we've done we moved

1977
01:19:55,520 --> 01:19:57,760
to the critical section outside of the

1978
01:19:57,760 --> 01:20:00,000
the the acquiring release and then be

1979
01:20:00,000 --> 01:20:01,520
totally incorrect

1980
01:20:01,520 --> 01:20:04,719
so that's wrong wrong

1981
01:20:04,719 --> 01:20:12,709
in a concurrent execution

1982
01:20:12,719 --> 01:20:15,199
and so you know to forbid or tell the

1983
01:20:15,199 --> 01:20:16,639
compiler in the hardware not

1984
01:20:16,639 --> 01:20:19,520
you know to do this uh there's something

1985
01:20:19,520 --> 01:20:20,159
what's called

1986
01:20:20,159 --> 01:20:22,239
a memory fence or something kind of

1987
01:20:22,239 --> 01:20:23,280
synchronized

1988
01:20:23,280 --> 01:20:24,560
uh there's an instruction that basically

1989
01:20:24,560 --> 01:20:26,880
says like any loads of storage before

1990
01:20:26,880 --> 01:20:27,920
this point

1991
01:20:27,920 --> 01:20:30,080
you're not allowed to move beyond this

1992
01:20:30,080 --> 01:20:31,280
point

1993
01:20:31,280 --> 01:20:34,239
and so release has this and uh acquiring

1994
01:20:34,239 --> 01:20:35,040
has this

1995
01:20:35,040 --> 01:20:36,880
and so for example this x plus x plus

1996
01:20:36,880 --> 01:20:38,320
one if that was

1997
01:20:38,320 --> 01:20:41,120
uh uh updated after the choir and before

1998
01:20:41,120 --> 01:20:41,760
the release

1999
01:20:41,760 --> 01:20:43,920
that x plus x plus one has to stay

2000
01:20:43,920 --> 01:20:45,840
before you know this particular memory

2001
01:20:45,840 --> 01:20:47,440
synchronization point

2002
01:20:47,440 --> 01:20:49,600
and so it will not be there will be no

2003
01:20:49,600 --> 01:20:50,880
trouble uh

2004
01:20:50,880 --> 01:20:53,600
with uh memory ordering so this is the

2005
01:20:53,600 --> 01:20:54,159
reason

2006
01:20:54,159 --> 01:20:56,800
why sync synchronizes there uh both in

2007
01:20:56,800 --> 01:20:57,280
the

2008
01:20:57,280 --> 01:20:58,960
release and also there's one in the

2009
01:20:58,960 --> 01:21:03,350
acquire

2010
01:21:03,360 --> 01:21:06,390
does that make sense

2011
01:21:06,400 --> 01:21:10,000
i have a question um

2012
01:21:10,000 --> 01:21:14,239
is it is it by convention that the start

2013
01:21:14,239 --> 01:21:17,270
of

2014
01:21:17,280 --> 01:21:20,560
the port so i guess i guess

2015
01:21:20,560 --> 01:21:23,040
the compiler could figure out that there

2016
01:21:23,040 --> 01:21:23,760
is an

2017
01:21:23,760 --> 01:21:26,000
instruction before the lock is even

2018
01:21:26,000 --> 01:21:26,800
acquired

2019
01:21:26,800 --> 01:21:29,280
and that it can be just as well moved

2020
01:21:29,280 --> 01:21:31,520
after the lock is released

2021
01:21:31,520 --> 01:21:35,120
um can that happen or will it

2022
01:21:35,120 --> 01:21:38,000
encounter the barrier and see that we'll

2023
01:21:38,000 --> 01:21:39,360
see you know in this case

2024
01:21:39,360 --> 01:21:40,880
a choir has a barrier and releases a

2025
01:21:40,880 --> 01:21:42,800
barrier so anything that happened before

2026
01:21:42,800 --> 01:21:45,199
locked in sector one will happen before

2027
01:21:45,199 --> 01:21:47,600
that it will never pass that instruction

2028
01:21:47,600 --> 01:21:50,320
so this is a barrier so if you will

2029
01:21:50,320 --> 01:21:52,960
this is barrier one and this is barrier

2030
01:21:52,960 --> 01:21:55,430
two

2031
01:21:55,440 --> 01:21:56,960
and so that means that any instructions

2032
01:21:56,960 --> 01:21:59,040
before here stay here

2033
01:21:59,040 --> 01:22:01,360
any structure in between will happen

2034
01:22:01,360 --> 01:22:03,040
between the two between between required

2035
01:22:03,040 --> 01:22:04,800
release and then instruction after

2036
01:22:04,800 --> 01:22:08,830
it will stay after the release

2037
01:22:08,840 --> 01:22:11,120
okay

2038
01:22:11,120 --> 01:22:14,159
okay okay so i'm running uh you know

2039
01:22:14,159 --> 01:22:15,440
close to the end

2040
01:22:15,440 --> 01:22:18,480
so let me just actually uh

2041
01:22:18,480 --> 01:22:27,750
wrap up here

2042
01:22:27,760 --> 01:22:30,800
so uh so locks you know

2043
01:22:30,800 --> 01:22:40,310
blocks are good for correctness

2044
01:22:40,320 --> 01:22:47,430
uh but can be bad for performance

2045
01:22:47,440 --> 01:22:49,120
uh which is sort of a bummer correct

2046
01:22:49,120 --> 01:22:50,800
because one reason we actually

2047
01:22:50,800 --> 01:22:52,320
you know got into locks is basically to

2048
01:22:52,320 --> 01:22:54,560
get correctness during aerial execution

2049
01:22:54,560 --> 01:22:56,960
uh but the locks actually limit parallel

2050
01:22:56,960 --> 01:23:00,480
uh execution so that's one

2051
01:23:00,480 --> 01:23:05,430
and two locks complicate

2052
01:23:05,440 --> 01:23:08,400
uh programming and you will experience

2053
01:23:08,400 --> 01:23:09,600
that in some of the labs that we're

2054
01:23:09,600 --> 01:23:11,360
going to be doing in fact from now on

2055
01:23:11,360 --> 01:23:11,840
we'll see

2056
01:23:11,840 --> 01:23:14,159
locks showing up all the time and that

2057
01:23:14,159 --> 01:23:15,199
will give us uh

2058
01:23:15,199 --> 01:23:17,840
you know at least you know uh some

2059
01:23:17,840 --> 01:23:18,719
thought you know it's going to be

2060
01:23:18,719 --> 01:23:20,320
necessary to understand like why the

2061
01:23:20,320 --> 01:23:21,760
locks are there and you know what they

2062
01:23:21,760 --> 01:23:22,639
protect

2063
01:23:22,639 --> 01:23:24,880
um and but they're sort of inherent uh

2064
01:23:24,880 --> 01:23:26,719
if you didn't do parallel programming

2065
01:23:26,719 --> 01:23:30,639
uh the you know you need to use locks

2066
01:23:30,639 --> 01:23:32,560
and so you know if you want to avoid the

2067
01:23:32,560 --> 01:23:34,480
complications due to locks is you know

2068
01:23:34,480 --> 01:23:36,080
the couple things you could do you know

2069
01:23:36,080 --> 01:23:42,790
don't share if you don't have to

2070
01:23:42,800 --> 01:23:46,390
if you don't have shared data structures

2071
01:23:46,400 --> 01:23:48,719
these race conditions cannot happen uh

2072
01:23:48,719 --> 01:23:49,600
and so there

2073
01:23:49,600 --> 01:23:51,679
and so you you don't need locks and so

2074
01:23:51,679 --> 01:23:52,719
you don't need this complicated

2075
01:23:52,719 --> 01:23:54,000
programming

2076
01:23:54,000 --> 01:23:55,679
uh but you know typically you will have

2077
01:23:55,679 --> 01:23:57,440
some shared data structures you will do

2078
01:23:57,440 --> 01:24:00,000
uh you will need locks and i think the

2079
01:24:00,000 --> 01:24:04,070
thing to do is start with coarse grained

2080
01:24:04,080 --> 01:24:07,600
and then move to firing grain

2081
01:24:07,600 --> 01:24:09,440
if necessary based on you know

2082
01:24:09,440 --> 01:24:11,199
measurements you want to determine

2083
01:24:11,199 --> 01:24:12,320
make sure that the lock is actually

2084
01:24:12,320 --> 01:24:13,760
contended you know before you actually

2085
01:24:13,760 --> 01:24:15,360
start redesigning

2086
01:24:15,360 --> 01:24:17,600
and finally you know use a race detector

2087
01:24:17,600 --> 01:24:20,310
to

2088
01:24:20,320 --> 01:24:21,600
you know one of these race detector

2089
01:24:21,600 --> 01:24:23,679
tools to actually find

2090
01:24:23,679 --> 01:24:25,920
uh problems uh or race conditions

2091
01:24:25,920 --> 01:24:26,960
because you know you put the locks in

2092
01:24:26,960 --> 01:24:28,239
the wrong or you put the acquiring the

2093
01:24:28,239 --> 01:24:29,760
releases in the wrong place and in fact

2094
01:24:29,760 --> 01:24:30,639
you know you still have

2095
01:24:30,639 --> 01:24:33,840
uh races okay so this is a quick

2096
01:24:33,840 --> 01:24:35,360
introduction to logs uh we're going to

2097
01:24:35,360 --> 01:24:35,679
talk

2098
01:24:35,679 --> 01:24:37,840
a lot more about locks in the basically

2099
01:24:37,840 --> 01:24:38,880
for the rest of the semester that will

2100
01:24:38,880 --> 01:24:40,400
show up and we'll talk a little bit more

2101
01:24:40,400 --> 01:24:42,480
about lock free program and the end

2102
01:24:42,480 --> 01:24:45,520
and see how that is done in in kernels

2103
01:24:45,520 --> 01:24:48,320
okay so let me stop here so that anybody

2104
01:24:48,320 --> 01:24:50,239
who has to go to somewhere else can go

2105
01:24:50,239 --> 01:24:52,400
but if you have any more questions

2106
01:24:52,400 --> 01:24:54,719
please feel free to ask them

2107
01:24:54,719 --> 01:24:57,360
we have a question in the chat isn't the

2108
01:24:57,360 --> 01:24:59,199
fence instruction unnecessary because

2109
01:24:59,199 --> 01:24:59,440
the

2110
01:24:59,440 --> 01:25:01,360
amo swap instruction can have the

2111
01:25:01,360 --> 01:25:04,000
acquire release ordering

2112
01:25:04,000 --> 01:25:07,120
uh yeah uh okay so uh okay

2113
01:25:07,120 --> 01:25:09,679
so the two things uh there's the the the

2114
01:25:09,679 --> 01:25:11,199
the sync instructions there both for the

2115
01:25:11,199 --> 01:25:24,870
compiler and for the hardware

2116
01:25:24,880 --> 01:25:26,719
yeah i'm jumping off uh to start office

2117
01:25:26,719 --> 01:25:27,760
hours but i think there's still more

2118
01:25:27,760 --> 01:25:29,040
questions

2119
01:25:29,040 --> 01:25:31,440
how do you do it for the compiler only

2120
01:25:31,440 --> 01:25:32,239
uh

2121
01:25:32,239 --> 01:25:34,239
the the the compiler knows for which

2122
01:25:34,239 --> 01:25:35,760
architecture is compiling

2123
01:25:35,760 --> 01:25:37,280
and so it will know whether it actually

2124
01:25:37,280 --> 01:25:39,520
has to insert the appropriate fences you

2125
01:25:39,520 --> 01:25:40,239
know for

2126
01:25:40,239 --> 01:25:41,679
whatever architecture it's running on

2127
01:25:41,679 --> 01:25:43,520
and whatever memory consistency model it

2128
01:25:43,520 --> 01:25:44,719
has

2129
01:25:44,719 --> 01:25:45,840
so this gets in a little bit more

2130
01:25:45,840 --> 01:25:47,280
complicated discussion is that every

2131
01:25:47,280 --> 01:25:48,320
piece of hardware has

2132
01:25:48,320 --> 01:25:51,600
a memory model and the compiler has to

2133
01:25:51,600 --> 01:25:52,560
decide

2134
01:25:52,560 --> 01:25:54,880
uh you know given the memory model for

2135
01:25:54,880 --> 01:25:56,239
that particular architecture what

2136
01:25:56,239 --> 01:25:59,280
actually it can do what it cannot do

2137
01:25:59,280 --> 01:26:01,840
and i guess my question was that like

2138
01:26:01,840 --> 01:26:03,440
defense instruction only becomes

2139
01:26:03,440 --> 01:26:06,800
unnecessary if you call ammo swap

2140
01:26:06,800 --> 01:26:10,480
like w dot release

2141
01:26:10,480 --> 01:26:14,470
and uh

2142
01:26:14,480 --> 01:26:18,000
like putting in the the sync

2143
01:26:18,000 --> 01:26:20,400
and there that will sync with the you

2144
01:26:20,400 --> 01:26:21,600
know the compiler

2145
01:26:21,600 --> 01:26:25,360
ordering and then the um

2146
01:26:25,360 --> 01:26:27,520
the memory ordering and the out of

2147
01:26:27,520 --> 01:26:28,719
ordering

2148
01:26:28,719 --> 01:26:30,239
yeah machinery using the fence

2149
01:26:30,239 --> 01:26:31,520
instruction as well the fence

2150
01:26:31,520 --> 01:26:33,280
instruction is only unnecessary in the

2151
01:26:33,280 --> 01:26:34,400
case that you do

2152
01:26:34,400 --> 01:26:36,400
dot rl so it seems like it wouldn't

2153
01:26:36,400 --> 01:26:38,639
detect that so how would you do it

2154
01:26:38,639 --> 01:26:41,679
so the compiler enforces the ordering on

2155
01:26:41,679 --> 01:26:42,800
its end

2156
01:26:42,800 --> 01:26:45,520
but you already cover it using the

2157
01:26:45,520 --> 01:26:46,400
amazon yeah

2158
01:26:46,400 --> 01:26:49,199
so like uh if you uh it's a very good

2159
01:26:49,199 --> 01:26:50,080
question uh

2160
01:26:50,080 --> 01:26:51,760
and you know some more sophisticated

2161
01:26:51,760 --> 01:26:53,360
acquiring these implementation would be

2162
01:26:53,360 --> 01:26:57,120
uh we more like specialized uh

2163
01:26:57,120 --> 01:26:58,719
uh acquire a release implementation or

2164
01:26:58,719 --> 01:27:00,000
lease implementation for a risk fight we

2165
01:27:00,000 --> 01:27:01,440
will probably do more sophisticated

2166
01:27:01,440 --> 01:27:02,960
things than we do where we pretty of

2167
01:27:02,960 --> 01:27:04,639
course grain by just issuing defense

2168
01:27:04,639 --> 01:27:05,760
instruction

2169
01:27:05,760 --> 01:27:09,199
um the uh the

2170
01:27:09,199 --> 01:27:12,400
but it's slightly complicated um and so

2171
01:27:12,400 --> 01:27:14,560
if you uh if you're interested in this

2172
01:27:14,560 --> 01:27:15,520
uh

2173
01:27:15,520 --> 01:27:19,120
the memory model for the risk drive is a

2174
01:27:19,120 --> 01:27:20,719
reasonably complicated so if you look at

2175
01:27:20,719 --> 01:27:22,400
the instruction

2176
01:27:22,400 --> 01:27:25,040
manual for the unprevious instructions

2177
01:27:25,040 --> 01:27:26,560
there's a whole chapter

2178
01:27:26,560 --> 01:27:28,800
dedicated you know to memory ordering

2179
01:27:28,800 --> 01:27:30,320
and tells you what they have to what the

2180
01:27:30,320 --> 01:27:33,280
compiler should do

2181
01:27:33,280 --> 01:27:37,669
in this particular case

2182
01:27:37,679 --> 01:27:39,600
so you're saying the compiler would pick

2183
01:27:39,600 --> 01:27:41,760
up on the fact that we just put that

2184
01:27:41,760 --> 01:27:44,080
assembly instruction inside of there and

2185
01:27:44,080 --> 01:27:45,280
it wouldn't reorder

2186
01:27:45,280 --> 01:27:47,199
any of the memory accesses on its own

2187
01:27:47,199 --> 01:27:48,560
sorry the the

2188
01:27:48,560 --> 01:27:50,800
the synchronize this this synchronized

2189
01:27:50,800 --> 01:27:52,560
library function is a library function

2190
01:27:52,560 --> 01:27:53,760
right and can be implemented in

2191
01:27:53,760 --> 01:27:55,040
different ways

2192
01:27:55,040 --> 01:27:56,719
uh and this is one particular

2193
01:27:56,719 --> 01:27:58,400
implementation

2194
01:27:58,400 --> 01:28:00,159
and the library function is provided by

2195
01:28:00,159 --> 01:28:02,320
the compiler

2196
01:28:02,320 --> 01:28:04,320
so uh but is there like the option for

2197
01:28:04,320 --> 01:28:05,520
the compiler to do

2198
01:28:05,520 --> 01:28:08,080
optimization where it itself moves the

2199
01:28:08,080 --> 01:28:10,480
loads and stores around

2200
01:28:10,480 --> 01:28:12,960
uh yes compilers do so how do you

2201
01:28:12,960 --> 01:28:13,520
prevent

2202
01:28:13,520 --> 01:28:15,280
that without emitting defense

2203
01:28:15,280 --> 01:28:16,800
instruction that's what i was curious

2204
01:28:16,800 --> 01:28:17,360
about

2205
01:28:17,360 --> 01:28:20,880
i guess what i'm saying is that uh uh

2206
01:28:20,880 --> 01:28:22,880
maybe uh what i'm saying is that

2207
01:28:22,880 --> 01:28:24,480
basically the

2208
01:28:24,480 --> 01:28:26,320
this indication the sync synchronized

2209
01:28:26,320 --> 01:28:27,600
basically both tells the compiler and

2210
01:28:27,600 --> 01:28:28,000
hardware

2211
01:28:28,000 --> 01:28:28,960
but the compiler could actually

2212
01:28:28,960 --> 01:28:30,400
implement sync increment synchronized

2213
01:28:30,400 --> 01:28:31,679
differently it knows that they can't

2214
01:28:31,679 --> 01:28:32,719
move things around

2215
01:28:32,719 --> 01:28:34,159
but it doesn't have to issue a fence

2216
01:28:34,159 --> 01:28:36,159
instruction on the risk 5 it knew

2217
01:28:36,159 --> 01:28:37,679
that it was running in a particular way

2218
01:28:37,679 --> 01:28:42,000
on risk 5.

2219
01:28:42,000 --> 01:28:45,520
uh but isn't the risk five memory model

2220
01:28:45,520 --> 01:28:47,280
like loose enough to where the out of

2221
01:28:47,280 --> 01:28:48,080
order

2222
01:28:48,080 --> 01:28:50,960
machinery could reorganize stuff so you

2223
01:28:50,960 --> 01:28:53,760
do need like the acquire

2224
01:28:53,760 --> 01:28:55,760
like the whole point of having okay okay

2225
01:28:55,760 --> 01:28:57,280
so they're more

2226
01:28:57,280 --> 01:29:00,719
uh they're more complicated interfaces

2227
01:29:00,719 --> 01:29:01,120
than

2228
01:29:01,120 --> 01:29:04,480
seeing synchronized uh and which gives

2229
01:29:04,480 --> 01:29:05,600
the compiler writer

2230
01:29:05,600 --> 01:29:07,199
more it gives the programming more

2231
01:29:07,199 --> 01:29:08,719
freedom and will give the compiler

2232
01:29:08,719 --> 01:29:10,639
and sort decouple the compiler part and

2233
01:29:10,639 --> 01:29:12,960
the processor part

2234
01:29:12,960 --> 01:29:14,400
so for example i think there's a flag

2235
01:29:14,400 --> 01:29:15,840
that you can pass in you know to say

2236
01:29:15,840 --> 01:29:17,440
that this is a release consistent

2237
01:29:17,440 --> 01:29:20,719
uh synchronize uh

2238
01:29:20,719 --> 01:29:22,480
you know i i don't know the details

2239
01:29:22,480 --> 01:29:23,840
right of my head

2240
01:29:23,840 --> 01:29:26,400
but if you look into this this is sort

2241
01:29:26,400 --> 01:29:27,679
of the coarse grained interface and

2242
01:29:27,679 --> 01:29:29,040
there are more fine-grained interfaces

2243
01:29:29,040 --> 01:29:31,280
that give the programmer more control

2244
01:29:31,280 --> 01:29:35,910
okay thank you

2245
01:29:35,920 --> 01:29:39,360
i have a question one is um

2246
01:29:39,360 --> 01:29:42,320
how do you like for having multiple

2247
01:29:42,320 --> 01:29:43,360
threads on one

2248
01:29:43,360 --> 01:29:45,760
processor do you argue in roughly the

2249
01:29:45,760 --> 01:29:46,400
same way

2250
01:29:46,400 --> 01:29:50,880
as we did for multiple processors

2251
01:29:50,880 --> 01:29:54,400
uh so can you repeat that question just

2252
01:29:54,400 --> 01:29:56,159
to make sure i uh

2253
01:29:56,159 --> 01:29:59,199
um so we didn't i think i don't think we

2254
01:29:59,199 --> 01:30:01,760
really talked about multiple threads we

2255
01:30:01,760 --> 01:30:04,800
mostly talked about multiple cpus so

2256
01:30:04,800 --> 01:30:08,400
for multiple threads is the um i guess

2257
01:30:08,400 --> 01:30:10,000
the solution

2258
01:30:10,000 --> 01:30:13,199
the same as for when you have multiple

2259
01:30:13,199 --> 01:30:14,480
cpus like do you

2260
01:30:14,480 --> 01:30:17,280
have the same arguments there more or

2261
01:30:17,280 --> 01:30:17,840
less

2262
01:30:17,840 --> 01:30:19,679
uh at least conceptually is the right

2263
01:30:19,679 --> 01:30:21,360
way to think about it uh

2264
01:30:21,360 --> 01:30:23,440
so if you have multiple threads but only

2265
01:30:23,440 --> 01:30:24,880
one cpu

2266
01:30:24,880 --> 01:30:26,880
uh it's still the case that you want to

2267
01:30:26,880 --> 01:30:28,639
ensure that certain uh

2268
01:30:28,639 --> 01:30:30,239
kernel code sequences are executed

2269
01:30:30,239 --> 01:30:32,400
atomically

2270
01:30:32,400 --> 01:30:34,560
and so you still have to have a notion

2271
01:30:34,560 --> 01:30:36,000
of critical sections

2272
01:30:36,000 --> 01:30:39,040
uh you might not need locks or releases

2273
01:30:39,040 --> 01:30:40,960
explicitly but you do need a way of

2274
01:30:40,960 --> 01:30:42,719
turning on interrupts off and on in a

2275
01:30:42,719 --> 01:30:44,880
particular piece of code

2276
01:30:44,880 --> 01:30:47,760
so if you look at older operating system

2277
01:30:47,760 --> 01:30:49,840
kernels they typically don't have really

2278
01:30:49,840 --> 01:30:51,280
lock and acquire

2279
01:30:51,280 --> 01:30:53,040
uh in the kernel because they assume

2280
01:30:53,040 --> 01:30:54,800
they're running on a single processor

2281
01:30:54,800 --> 01:30:56,480
but they do have something like locks

2282
01:30:56,480 --> 01:30:58,080
you know to basically turn off

2283
01:30:58,080 --> 01:31:03,600
interrupts and interrupts on and off

2284
01:31:03,600 --> 01:31:06,639
okay i see um and my other question

2285
01:31:06,639 --> 01:31:10,000
was um actually on the slide with

2286
01:31:10,000 --> 01:31:13,199
um the yard picture

2287
01:31:13,199 --> 01:31:17,840
the buffer um

2288
01:31:17,840 --> 01:31:20,719
yeah is it yeah that one is it always

2289
01:31:20,719 --> 01:31:21,679
the case that

2290
01:31:21,679 --> 01:31:25,199
the read is going to be um like lagging

2291
01:31:25,199 --> 01:31:25,760
behind

2292
01:31:25,760 --> 01:31:28,000
i didn't understand that yeah okay so

2293
01:31:28,000 --> 01:31:29,280
the the

2294
01:31:29,280 --> 01:31:30,639
so this goes to the display yeah

2295
01:31:30,639 --> 01:31:32,239
whatever is in this you know basically

2296
01:31:32,239 --> 01:31:33,520
this is the sequence of characters that

2297
01:31:33,520 --> 01:31:36,709
needs to go to the display

2298
01:31:36,719 --> 01:31:38,639
and and the writer basically is

2299
01:31:38,639 --> 01:31:41,760
appending more and more more characters

2300
01:31:41,760 --> 01:31:44,560
right and so uh so the writer is going

2301
01:31:44,560 --> 01:31:45,199
that way

2302
01:31:45,199 --> 01:31:46,800
and basically the readers you know

2303
01:31:46,800 --> 01:31:48,639
following the writer right because you

2304
01:31:48,639 --> 01:31:49,760
know can't print the character that

2305
01:31:49,760 --> 01:31:50,320
hasn't been

2306
01:31:50,320 --> 01:31:53,440
you know put in the buffer yet um and so

2307
01:31:53,440 --> 01:31:53,920
what

2308
01:31:53,920 --> 01:31:57,199
you know the the the uart who

2309
01:31:57,199 --> 01:32:02,229
puts things on the display

2310
01:32:02,239 --> 01:32:04,400
you know we'll you know start basically

2311
01:32:04,400 --> 01:32:05,840
putting the first character as in this

2312
01:32:05,840 --> 01:32:08,159
slot you know onto the display

2313
01:32:08,159 --> 01:32:09,760
meanwhile printf could come in and

2314
01:32:09,760 --> 01:32:11,360
multiple printers come in that

2315
01:32:11,360 --> 01:32:13,199
they put more characters in here so that

2316
01:32:13,199 --> 01:32:14,560
the right point are staying standing

2317
01:32:14,560 --> 01:32:15,199
here

2318
01:32:15,199 --> 01:32:16,639
and then when this one character is

2319
01:32:16,639 --> 01:32:18,719
displayed then you know the uart will

2320
01:32:18,719 --> 01:32:20,239
move up this pointer

2321
01:32:20,239 --> 01:32:22,480
to display the next character right so

2322
01:32:22,480 --> 01:32:24,000
the uart is always lagging

2323
01:32:24,000 --> 01:32:27,360
a little bit behind the writer until the

2324
01:32:27,360 --> 01:32:29,440
point that it catches up right and

2325
01:32:29,440 --> 01:32:31,280
where r and w are the same and at that

2326
01:32:31,280 --> 01:32:32,639
point basically that means that there's

2327
01:32:32,639 --> 01:32:35,920
no character anymore in the buffer

2328
01:32:35,920 --> 01:32:38,080
oh okay i see that makes that makes a

2329
01:32:38,080 --> 01:32:40,239
lot more sense okay thank you so much

2330
01:32:40,239 --> 01:32:48,870
you're welcome any more questions

2331
01:32:48,880 --> 01:32:54,719
just us left here guys

2332
01:32:54,719 --> 01:32:57,760
see you later

