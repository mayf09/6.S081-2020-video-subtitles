1
00:00:00,000 --> 00:00:02,640
Sound check, can everybody hear me?

2
00:00:04,700 --> 00:00:08,060
Yep, yep. Okay okay,

3
00:00:08,060 --> 00:00:09,920
so welcome to the next lecture

4
00:00:09,920 --> 00:00:12,410
in the S081, wherever you

5
00:00:12,410 --> 00:00:14,380
are, particular,

6
00:00:14,740 --> 00:00:15,640
I hope that the folks on

7
00:00:15,640 --> 00:00:17,380
the west coast or in Florida

8
00:00:17,380 --> 00:00:19,450
and Alabama do OK, you know, all

9
00:00:19,450 --> 00:00:22,140
the terrible circumstances there.

10
00:00:22,510 --> 00:00:24,880
Um, so,

11
00:00:24,880 --> 00:00:26,350
um, the topic for today,

12
00:00:26,350 --> 00:00:29,110
where is virtual memory, particularly we're

13
00:00:29,110 --> 00:00:30,580
going to talk about page tables

14
00:00:30,580 --> 00:00:32,650
will return to this topic

15
00:00:32,650 --> 00:00:33,340
few times,

16
00:00:33,340 --> 00:00:34,390
there will be multiple [flickr

17
00:00:34,390 --> 00:00:35,380
lammy] lectures.

18
00:00:36,030 --> 00:00:37,920
Maybe just start off and

19
00:00:37,920 --> 00:00:39,690
we'll get our question and answer

20
00:00:39,690 --> 00:00:40,680
going again,

21
00:00:42,120 --> 00:00:43,320
I would like to ask you

22
00:00:43,320 --> 00:00:43,830
a little bit,

23
00:00:43,830 --> 00:00:45,930
what do you remember from

24
00:00:45,930 --> 00:00:47,910
about virtual memory from 6.004

25
00:00:47,910 --> 00:00:50,400
maybe [6.033],

26
00:00:50,400 --> 00:00:51,660
if you're taking that.

27
00:00:52,500 --> 00:00:53,970
I'll tell you my own sort

28
00:00:53,970 --> 00:00:55,320
of view on virtual memory,

29
00:00:55,320 --> 00:00:56,580
which is why I took it

30
00:00:56,580 --> 00:00:57,780
to a first learned about it,

31
00:00:57,780 --> 00:00:58,500
we learned about it as

32
00:00:58,500 --> 00:00:59,850
a student I thought it

33
00:00:59,850 --> 00:01:01,110
was pretty straightforward,

34
00:01:01,110 --> 00:01:01,680
you know how hard could

35
00:01:01,680 --> 00:01:02,010
it be,

36
00:01:02,010 --> 00:01:04,140
it's a table that maps virtual

37
00:01:04,140 --> 00:01:05,700
addresses to physical addresses.

38
00:01:05,870 --> 00:01:07,190
Now, as you know maybe a

39
00:01:07,190 --> 00:01:08,120
little more complicated,

40
00:01:08,120 --> 00:01:09,680
but you know not that

41
00:01:09,680 --> 00:01:11,300
complicated only when you start

42
00:01:11,300 --> 00:01:12,540
programming with it.

43
00:01:12,600 --> 00:01:15,210
I should really learn that virtual

44
00:01:15,210 --> 00:01:18,380
memory is tricky and fascinating,

45
00:01:18,540 --> 00:01:20,880
very powerful.

46
00:01:21,380 --> 00:01:23,300
And so hopefully in the

47
00:01:23,300 --> 00:01:25,100
next couple of lectures in

48
00:01:25,100 --> 00:01:26,060
the next couple of labs,

49
00:01:26,060 --> 00:01:29,090
you'll know appreciate

50
00:01:29,090 --> 00:01:30,820
virtual memory from that perspective.

51
00:01:31,060 --> 00:01:32,230
We will ask a couple

52
00:01:32,230 --> 00:01:34,000
people here are online, you know

53
00:01:34,000 --> 00:01:36,010
what do you remember about virtual

54
00:01:36,010 --> 00:01:38,860
memory from either 6.004 or

55
00:01:38,860 --> 00:01:40,120
[6.033] taking it.

56
00:01:40,340 --> 00:01:41,510
Again, I'm just gonna call some

57
00:01:41,510 --> 00:01:43,080
names and you know,

58
00:01:43,600 --> 00:01:47,080
share your memories. About the

59
00:01:47,080 --> 00:01:48,440
Adela Yang.

60
00:01:53,360 --> 00:01:55,160
Sorry, what's the question? What

61
00:01:55,160 --> 00:01:57,410
do you remember about

62
00:01:57,410 --> 00:01:58,940
virtual memory from maybe 6.004

63
00:01:58,940 --> 00:02:00,470
or 6.033

64
00:02:00,470 --> 00:02:01,460
if you have taken that.

65
00:02:02,020 --> 00:02:05,440
It uses like offset to save

66
00:02:05,440 --> 00:02:08,380
on like remembering virtual address

67
00:02:08,380 --> 00:02:10,300
to physical address mappings.

68
00:02:11,640 --> 00:02:13,020
OK, um,

69
00:02:13,020 --> 00:02:15,380
how about Abrams Caldera.

70
00:02:20,100 --> 00:02:20,700
Hey bro,

71
00:02:20,700 --> 00:02:21,840
are you online.

72
00:02:23,230 --> 00:02:24,970
Yeah, my memory is that

73
00:02:24,970 --> 00:02:26,640
it uses, um, like

74
00:02:26,940 --> 00:02:29,040
it's a way of one protecting

75
00:02:29,040 --> 00:02:30,960
the physical hardware by

76
00:02:30,960 --> 00:02:33,540
kind of [beautiful] representation of

77
00:02:33,540 --> 00:02:35,310
it and then yeah you just

78
00:02:35,310 --> 00:02:38,020
have some virtual address things like,

79
00:02:38,300 --> 00:02:40,310
at least [44 twelve]

80
00:02:40,310 --> 00:02:41,750
bit maps,

81
00:02:41,750 --> 00:02:43,200
some physical address.

82
00:02:43,530 --> 00:02:45,420
Um, that's usually I think 16

83
00:02:45,420 --> 00:02:47,620
bits were in fact.

84
00:02:48,090 --> 00:02:50,550
Okay, good,

85
00:02:51,730 --> 00:02:53,540
How about Bibic Pendant?

86
00:02:56,730 --> 00:02:58,080
What I remember was,

87
00:02:58,080 --> 00:03:00,380
um, you can have

88
00:03:00,840 --> 00:03:03,210
each process has a separate

89
00:03:03,210 --> 00:03:04,260
address space.

90
00:03:04,620 --> 00:03:05,820
And, um.

91
00:03:06,210 --> 00:03:09,060
The memory management unit or I

92
00:03:09,060 --> 00:03:10,470
mean some other technique can be

93
00:03:10,470 --> 00:03:11,620
used to map.

94
00:03:11,830 --> 00:03:13,960
Um the virtual addresses of the

95
00:03:13,960 --> 00:03:15,370
address space of each of the

96
00:03:15,370 --> 00:03:17,120
processes to the physical,

97
00:03:17,340 --> 00:03:19,420
physical address.

98
00:03:20,040 --> 00:03:23,910
And a virtual address that the

99
00:03:23,910 --> 00:03:24,920
lower bits

100
00:03:25,030 --> 00:03:25,930
are kind of the same,

101
00:03:25,930 --> 00:03:26,530
so that,

102
00:03:26,530 --> 00:03:28,690
um the the mapping is

103
00:03:28,690 --> 00:03:29,640
in blocks.

104
00:03:29,790 --> 00:03:32,100
Which helps with performance.

105
00:03:33,970 --> 00:03:35,540
Wiseley Wu.

106
00:03:39,570 --> 00:03:42,630
Yeah yeah I guess what I

107
00:03:42,630 --> 00:03:44,850
remember most is that virtual address

108
00:03:44,850 --> 00:03:47,180
allows us to,

109
00:03:47,750 --> 00:03:50,300
yeah, protect physical addresses from

110
00:03:50,300 --> 00:03:51,580
each process.

111
00:03:51,640 --> 00:03:54,070
And we can use some clever

112
00:03:54,070 --> 00:03:56,080
manipulation, so that the bits that

113
00:03:56,080 --> 00:03:57,730
correspond to the physical address can

114
00:03:57,730 --> 00:03:59,920
be used somehow in the virtual

115
00:03:59,920 --> 00:04:01,000
addresses as well.

116
00:04:02,600 --> 00:04:05,460
Wilson Spearmen.

117
00:04:09,040 --> 00:04:10,840
Yeah, I remember it's really fundamental

118
00:04:10,840 --> 00:04:11,950
to isolation,

119
00:04:11,950 --> 00:04:14,890
because every process can basically pretend

120
00:04:14,890 --> 00:04:16,620
that it has its own

121
00:04:16,760 --> 00:04:19,180
sort of memory to use.

122
00:04:20,470 --> 00:04:22,270
Good good well so clearly,

123
00:04:22,270 --> 00:04:23,830
um, that's awesome,

124
00:04:23,830 --> 00:04:26,080
the clear two themes here

125
00:04:26,080 --> 00:04:28,210
correct, one is you know

126
00:04:28,210 --> 00:04:30,400
there's some form of mapping and

127
00:04:30,400 --> 00:04:31,900
the mapping is helpful in sort

128
00:04:31,900 --> 00:04:33,670
of achieving isolation,

129
00:04:33,670 --> 00:04:35,800
this is exactly the reason we're

130
00:04:35,800 --> 00:04:38,560
talking about virtual memory isolation.

131
00:04:38,870 --> 00:04:39,620
And so what,

132
00:04:39,620 --> 00:04:41,570
we'll see is that in

133
00:04:41,570 --> 00:04:43,220
the next in the next couple

134
00:04:43,220 --> 00:04:43,580
of lectures,

135
00:04:43,580 --> 00:04:44,840
in particular when we start programming

136
00:04:44,840 --> 00:04:45,950
with virtual memory,

137
00:04:45,950 --> 00:04:48,680
really get an in-depth understanding

138
00:04:48,680 --> 00:04:50,360
of what its power is.

139
00:04:50,780 --> 00:04:52,250
Um, and so to get a

140
00:04:52,250 --> 00:04:53,570
sense that you know this is

141
00:04:53,570 --> 00:04:55,310
the first lecture and mostly focusing

142
00:04:55,310 --> 00:04:58,490
on the mechanisms for

143
00:04:58,490 --> 00:04:59,390
virtual memory,

144
00:04:59,390 --> 00:05:00,680
and then later we can see

145
00:05:00,680 --> 00:05:02,030
how we can use these mechanisms

146
00:05:02,030 --> 00:05:03,760
to achieve, you know, cool tricks.

147
00:05:04,660 --> 00:05:06,220
So the topic for today or

148
00:05:06,220 --> 00:05:08,740
agenda for today, the plan

149
00:05:08,740 --> 00:05:10,460
is sort of [pre fault].

150
00:05:10,800 --> 00:05:12,210
First, I'm going to talk about the

151
00:05:12,210 --> 00:05:14,130
address bases as some of you

152
00:05:14,130 --> 00:05:16,020
mentioning your um.

153
00:05:16,320 --> 00:05:17,420
Just what we need.

154
00:05:18,070 --> 00:05:19,840
Just mentioned just briefly mentioned,

155
00:05:19,840 --> 00:05:22,420
um, in response to this question,

156
00:05:22,420 --> 00:05:23,980
I'm going to talk about the

157
00:05:23,980 --> 00:05:26,200
paging hardware paging hardware.

158
00:05:27,020 --> 00:05:28,280
And I'm going to focus of

159
00:05:28,280 --> 00:05:29,600
course on the paging hardware of

160
00:05:29,600 --> 00:05:30,640
the RISC-V.

161
00:05:32,020 --> 00:05:36,400
But basically every processor, modern processor

162
00:05:36,400 --> 00:05:38,950
has some form of paging hardware

163
00:05:38,950 --> 00:05:40,200
sort of d.

164
00:05:40,230 --> 00:05:41,640
If you will the

165
00:05:41,640 --> 00:05:44,310
default mechanism for actually a

166
00:05:44,310 --> 00:05:45,820
supporting virtual memory.

167
00:05:46,250 --> 00:05:47,000
And then,

168
00:05:47,000 --> 00:05:48,260
um the last part of

169
00:05:48,260 --> 00:05:49,610
the lecture is going to

170
00:05:49,610 --> 00:05:52,100
walk through some xv6

171
00:05:52,100 --> 00:05:54,240
virtual memory code.

172
00:05:54,280 --> 00:05:55,920
And, um.

173
00:05:56,300 --> 00:06:00,770
Layout of kernel address space and

174
00:06:00,770 --> 00:06:02,000
user address spaces.

175
00:06:02,730 --> 00:06:04,580
So that's the main point.

176
00:06:08,250 --> 00:06:09,660
Okay, so um,

177
00:06:09,660 --> 00:06:11,160
if we answers you know number

178
00:06:11,160 --> 00:06:12,120
you mentioned,

179
00:06:12,120 --> 00:06:14,370
um in response to this question,

180
00:06:14,370 --> 00:06:15,280
you know.

181
00:06:15,370 --> 00:06:18,430
One driving reason to have

182
00:06:18,430 --> 00:06:20,020
virtual memory is because you can

183
00:06:20,020 --> 00:06:22,000
use it to achieve isolation,

184
00:06:22,000 --> 00:06:22,840
if you set up the page

185
00:06:22,840 --> 00:06:25,540
tables correctly and program them correctly,

186
00:06:25,540 --> 00:06:26,710
um, then you can in principle

187
00:06:26,710 --> 00:06:28,540
achieve strong isolation.

188
00:06:29,020 --> 00:06:30,340
And so this is your mind

189
00:06:30,340 --> 00:06:30,910
goes again,

190
00:06:30,910 --> 00:06:31,960
you know what we want with

191
00:06:31,960 --> 00:06:33,100
from isolation,

192
00:06:33,100 --> 00:06:34,540
let's say you know a

193
00:06:34,540 --> 00:06:35,380
standard picture,

194
00:06:35,380 --> 00:06:36,820
we have some user applications

195
00:06:36,820 --> 00:06:37,920
like shell.

196
00:06:37,950 --> 00:06:40,080
You know cat, all the util

197
00:06:40,080 --> 00:06:41,970
things that you've built in

198
00:06:41,970 --> 00:06:44,520
lab one and we have

199
00:06:44,630 --> 00:06:48,440
the kernel or kernel sitting below

200
00:06:48,440 --> 00:06:49,790
the operating system sitting in

201
00:06:49,790 --> 00:06:50,860
kernel space.

202
00:06:51,320 --> 00:06:52,730
And you know what we like

203
00:06:52,730 --> 00:06:55,100
to do is sort of have

204
00:06:55,100 --> 00:06:57,880
you know boxes around these

205
00:06:58,240 --> 00:07:00,850
applications, so that they can't'

206
00:07:00,850 --> 00:07:03,100
really affect each other and similar

207
00:07:03,100 --> 00:07:06,010
we want them to be completely

208
00:07:06,010 --> 00:07:07,930
independent of the kernel,

209
00:07:07,930 --> 00:07:09,310
the operating system so that if

210
00:07:09,310 --> 00:07:11,620
an application does something either accidentally

211
00:07:11,620 --> 00:07:13,600
bad or maliciously bad,

212
00:07:13,600 --> 00:07:14,950
that doesn't really affect the

213
00:07:14,950 --> 00:07:15,900
operating system.

214
00:07:16,580 --> 00:07:19,010
So that's our goal and the

215
00:07:19,010 --> 00:07:21,380
particular aspect of the problem that

216
00:07:21,380 --> 00:07:23,360
we want to focus on today

217
00:07:23,360 --> 00:07:25,220
is the memory side of things,

218
00:07:25,220 --> 00:07:26,390
um, so we really want to

219
00:07:26,390 --> 00:07:28,120
focus on memory isolation.

220
00:07:29,920 --> 00:07:31,900
And by default,

221
00:07:31,900 --> 00:07:33,430
if we don't do anything,

222
00:07:33,430 --> 00:07:35,470
we don't really have memory isolation,

223
00:07:35,470 --> 00:07:37,180
because if you think about

224
00:07:37,180 --> 00:07:38,890
it, there's going to be one

225
00:07:38,890 --> 00:07:40,480
RISC-V board that I showed

226
00:07:40,480 --> 00:07:41,140
you last week,

227
00:07:41,140 --> 00:07:42,730
it has a memory,

228
00:07:42,730 --> 00:07:44,220
a bunch of dram chips,

229
00:07:44,630 --> 00:07:46,490
and the in the dram

230
00:07:46,490 --> 00:07:48,200
chips go into the code for

231
00:07:48,200 --> 00:07:49,460
these applications,

232
00:07:49,460 --> 00:07:53,060
is stored somewhere in memory

233
00:07:53,060 --> 00:07:55,820
is the kernel, text data stack

234
00:07:55,820 --> 00:07:58,280
everything somewhere in memory used to

235
00:07:58,280 --> 00:07:59,740
shell if the shell is running.

236
00:07:59,980 --> 00:08:01,450
Somewhere in memory,

237
00:08:01,450 --> 00:08:02,680
the cat program.

238
00:08:04,640 --> 00:08:05,750
And so there's one sort of

239
00:08:05,750 --> 00:08:06,410
physical memory,

240
00:08:06,410 --> 00:08:07,280
you know starting from someone

241
00:08:07,280 --> 00:08:09,170
from zero to you know

242
00:08:09,170 --> 00:08:11,420
big big address, no

243
00:08:11,420 --> 00:08:12,500
depending how much memory we

244
00:08:12,500 --> 00:08:13,430
have really have in our

245
00:08:13,430 --> 00:08:15,020
machine and in that physical

246
00:08:15,020 --> 00:08:16,340
memory all these programs must

247
00:08:16,340 --> 00:08:17,140
be present.

248
00:08:17,230 --> 00:08:19,330
Yeah, otherwise you know the processor

249
00:08:19,330 --> 00:08:21,340
can't even execute their instructions.

250
00:08:22,420 --> 00:08:23,470
This is what the risk, you

251
00:08:23,470 --> 00:08:25,300
know clearly here is, that let's

252
00:08:25,300 --> 00:08:26,860
say you know let's make a

253
00:08:26,860 --> 00:08:27,310
little bit,

254
00:08:27,310 --> 00:08:28,780
you know simplistic but let's say

255
00:08:28,780 --> 00:08:29,950
the shell,

256
00:08:29,950 --> 00:08:31,300
you know sits for a min

257
00:08:31,300 --> 00:08:33,620
address zero to address 200,

258
00:08:34,830 --> 00:08:36,920
two thousand one thousand to 2000.

259
00:08:37,720 --> 00:08:39,220
And let's say you know the

260
00:08:39,220 --> 00:08:40,810
you know whatever cat has a

261
00:08:40,810 --> 00:08:41,890
programming error,

262
00:08:41,890 --> 00:08:43,570
um, it loads,

263
00:08:43,570 --> 00:08:47,060
you know in register a0.

264
00:08:47,770 --> 00:08:49,720
Let's say loads the thousand

265
00:08:49,720 --> 00:08:52,030
address basically corresponding to the

266
00:08:52,030 --> 00:08:54,010
start of the shell and then

267
00:08:54,010 --> 00:08:55,060
you know by accident,

268
00:08:55,060 --> 00:08:57,580
you know, executes the instruction,

269
00:08:57,800 --> 00:09:01,660
you know, $7, a0.

270
00:09:03,010 --> 00:09:04,210
Which has the effect of that,

271
00:09:04,210 --> 00:09:05,980
basically it writes the value 7

272
00:09:05,980 --> 00:09:08,230
to the address 1000 and so

273
00:09:08,230 --> 00:09:10,240
it would be scribbling over you

274
00:09:10,240 --> 00:09:12,550
know the basically the memory image,

275
00:09:12,550 --> 00:09:14,220
um that belongs to shell.

276
00:09:14,860 --> 00:09:15,130
And so,

277
00:09:15,130 --> 00:09:17,590
we're certainly not, certain

278
00:09:17,590 --> 00:09:20,380
would break isolation, and be

279
00:09:20,380 --> 00:09:21,780
quite undesirable.

280
00:09:22,400 --> 00:09:24,350
And so we want something that

281
00:09:24,350 --> 00:09:26,510
basically really separates these memories from

282
00:09:26,510 --> 00:09:27,860
the different programs from each other,

283
00:09:27,860 --> 00:09:29,060
so that things like that just

284
00:09:29,060 --> 00:09:30,080
cannot happen.

285
00:09:31,590 --> 00:09:33,450
So one way, to do that,

286
00:09:33,450 --> 00:09:36,120
um is an idea that's you

287
00:09:36,120 --> 00:09:38,120
know typically called address spaces.

288
00:09:44,500 --> 00:09:47,920
And the basic idea is straightforward,

289
00:09:47,920 --> 00:09:49,300
what we wanna do is basically

290
00:09:49,300 --> 00:09:52,580
give every application including the kernel,

291
00:09:52,670 --> 00:09:54,060
its own address space.

292
00:09:55,080 --> 00:09:56,310
And so we can think about

293
00:09:56,310 --> 00:09:58,260
this like we use cat running.

294
00:09:58,780 --> 00:09:59,800
You know it has an address

295
00:09:59,800 --> 00:10:01,870
space starting at 0, you know

296
00:10:01,870 --> 00:10:04,390
do whatever maximum value, you know

297
00:10:04,390 --> 00:10:06,430
shell run has an address space, its

298
00:10:06,430 --> 00:10:07,330
own address space,

299
00:10:07,330 --> 00:10:09,130
also starting at address 0,

300
00:10:09,130 --> 00:10:11,530
um, going to some value

301
00:10:11,530 --> 00:10:12,490
you know the kernel has

302
00:10:12,490 --> 00:10:13,780
its own address space.

303
00:10:14,660 --> 00:10:15,680
OS has its own

304
00:10:15,680 --> 00:10:16,680
address space.

305
00:10:17,640 --> 00:10:18,750
And so,

306
00:10:18,750 --> 00:10:20,340
one example when cat you know

307
00:10:20,340 --> 00:10:21,900
refers to, we go back to

308
00:10:21,900 --> 00:10:23,880
our example of the previous slide

309
00:10:23,880 --> 00:10:25,320
where we did.

310
00:10:25,470 --> 00:10:29,130
Um, whatever store 7 to, you

311
00:10:29,130 --> 00:10:30,580
know a0.

312
00:10:30,930 --> 00:10:32,730
And let's say in a0,

313
00:10:32,730 --> 00:10:34,740
there's value in 1000.

314
00:10:34,840 --> 00:10:36,400
You know if can execute

315
00:10:36,400 --> 00:10:37,540
an instruction,

316
00:10:37,540 --> 00:10:39,130
it will write to the address 1000,

317
00:10:40,420 --> 00:10:41,740
but it is its own

318
00:10:41,740 --> 00:10:42,970
address 1000,

319
00:10:42,970 --> 00:10:43,690
it's not,

320
00:10:43,690 --> 00:10:45,010
you know the address of the

321
00:10:45,010 --> 00:10:46,360
1000 of the shell.

322
00:10:46,390 --> 00:10:48,760
So basically, every program runs with

323
00:10:48,760 --> 00:10:50,320
its own address space, has its

324
00:10:50,320 --> 00:10:52,870
own value and those addresses are

325
00:10:52,870 --> 00:10:54,160
completely independent.

326
00:10:54,380 --> 00:10:56,120
Um, you know this notion of

327
00:10:56,120 --> 00:10:57,590
different address spaces,

328
00:10:57,590 --> 00:10:59,540
cat doesn't really have an ability to

329
00:10:59,540 --> 00:11:01,940
even refer to an address, that

330
00:11:01,940 --> 00:11:03,680
actually belongs to the shell.

331
00:11:04,900 --> 00:11:07,240
And so that's sort of the

332
00:11:07,240 --> 00:11:09,160
game that were the end goal

333
00:11:09,160 --> 00:11:10,630
that we'd like to achieve, because

334
00:11:10,630 --> 00:11:11,530
it's going to provide us with

335
00:11:11,530 --> 00:11:13,690
strong isolation, because you know it's

336
00:11:13,690 --> 00:11:15,010
just not possible for cat to

337
00:11:15,010 --> 00:11:16,480
refer to any other memory that

338
00:11:16,480 --> 00:11:18,100
is not, you know, its own.

339
00:11:19,080 --> 00:11:19,350
And so,

340
00:11:19,350 --> 00:11:20,790
our goal now basically

341
00:11:20,790 --> 00:11:22,980
sort of figure out how to

342
00:11:22,980 --> 00:11:25,200
multiplex if you will all these

343
00:11:25,200 --> 00:11:28,260
different address bases on a single

344
00:11:28,260 --> 00:11:29,190
physical memory,

345
00:11:29,190 --> 00:11:29,970
because in the end,

346
00:11:29,970 --> 00:11:31,050
we only have a bunch of

347
00:11:31,050 --> 00:11:32,140
dram chips.

348
00:11:32,240 --> 00:11:33,800
Um, were you know, ram

349
00:11:33,800 --> 00:11:35,720
chips were the memories look at.

350
00:11:36,950 --> 00:11:37,790
And so,

351
00:11:40,210 --> 00:11:41,470
Um, and so I sort of

352
00:11:41,470 --> 00:11:42,010
plan okay,

353
00:11:42,010 --> 00:11:43,150
yeah I'm here. You have

354
00:11:43,150 --> 00:11:43,510
a question,

355
00:11:43,510 --> 00:11:44,240
go ahead.

356
00:11:46,240 --> 00:11:47,380
Um, so I'm wondering,

357
00:11:47,380 --> 00:11:50,500
in the configuration of the

358
00:11:50,500 --> 00:11:52,030
physical hardware,

359
00:11:52,030 --> 00:11:54,550
there's only so much space and

360
00:11:54,550 --> 00:11:56,590
in the virtual memory layout,

361
00:11:56,590 --> 00:11:59,230
there's also a max virtual address

362
00:11:59,230 --> 00:12:02,230
by design is the virtual address

363
00:12:02,230 --> 00:12:04,180
made to be small enough.

364
00:12:04,500 --> 00:12:06,930
No, not necessarily,

365
00:12:06,930 --> 00:12:08,100
you know the virtual address

366
00:12:08,100 --> 00:12:09,240
space could be bigger than

367
00:12:09,240 --> 00:12:09,990
the physical memory,

368
00:12:09,990 --> 00:12:11,160
the physical memory could be bigger

369
00:12:11,160 --> 00:12:13,170
than the virtual address space

370
00:12:13,170 --> 00:12:13,950
and we'll see in a second

371
00:12:13,950 --> 00:12:15,240
how it all can happen and

372
00:12:15,240 --> 00:12:17,040
it's actually going to pull parts

373
00:12:17,040 --> 00:12:18,540
about, as we'll see with

374
00:12:18,540 --> 00:12:19,560
page tables,

375
00:12:19,560 --> 00:12:21,420
um that's extremely flexible.

376
00:12:22,120 --> 00:12:23,470
So, is it, is it

377
00:12:23,470 --> 00:12:25,690
possible that like the physical

378
00:12:25,690 --> 00:12:27,940
memory gets exhausted.

379
00:12:28,250 --> 00:12:30,500
Um, because so many processes use

380
00:12:30,500 --> 00:12:31,940
all their virtual space,

381
00:12:31,940 --> 00:12:34,790
yeah that's certainly possible and we'll

382
00:12:34,790 --> 00:12:35,780
see in the second, how,

383
00:12:35,780 --> 00:12:36,980
for example you know you have

384
00:12:36,980 --> 00:12:38,750
a bunch of big applications that

385
00:12:38,750 --> 00:12:40,340
each have big page tables,

386
00:12:40,340 --> 00:12:41,510
they allocate a lot of memory,

387
00:12:41,510 --> 00:12:42,350
you know some point you run

388
00:12:42,350 --> 00:12:43,260
out of memory.

389
00:12:43,810 --> 00:12:44,320
I see,

390
00:12:44,320 --> 00:12:46,840
thanks. And so where does this

391
00:12:46,840 --> 00:12:49,060
show up xv6, anybody.

392
00:12:52,530 --> 00:12:54,100
You, you sure.

393
00:12:54,430 --> 00:12:55,720
Touched on a little bit

394
00:12:55,720 --> 00:12:57,550
in the syscall lab, that

395
00:12:57,550 --> 00:12:58,660
you're currently doing.

396
00:13:01,330 --> 00:13:02,920
Where page is allocated.

397
00:13:08,670 --> 00:13:10,650
or, you do the syscall lab

398
00:13:10,650 --> 00:13:11,940
but you finished it in one

399
00:13:11,940 --> 00:13:13,380
part of the syscall lab,

400
00:13:13,380 --> 00:13:15,400
printing how much free memory address.

401
00:13:17,730 --> 00:13:20,220
Kalloc? Yeah, kalloc, right,

402
00:13:20,220 --> 00:13:21,270
for kalloc, I have some list of

403
00:13:21,270 --> 00:13:22,340
three pages.

404
00:13:22,420 --> 00:13:23,740
If that list of three pages

405
00:13:23,740 --> 00:13:25,330
it empty or runs out at

406
00:13:25,330 --> 00:13:26,160
some point.

407
00:13:26,150 --> 00:13:27,590
Then, you know, kalloc is going

408
00:13:27,590 --> 00:13:29,750
to return a null pointer and

409
00:13:29,750 --> 00:13:31,880
hopefully the operation does something sensible

410
00:13:31,880 --> 00:13:33,380
that basically propagated back to the

411
00:13:33,380 --> 00:13:35,150
user application saying like well, you

412
00:13:35,150 --> 00:13:36,530
know no more memory for you

413
00:13:36,530 --> 00:13:38,120
or no more memory in total

414
00:13:38,120 --> 00:13:38,960
for nobody.

415
00:13:43,120 --> 00:13:44,350
Ok? Then just a job for OS

416
00:13:44,350 --> 00:13:46,480
to handle those cases gracefully where

417
00:13:46,480 --> 00:13:48,700
basically generally means propagating an error

418
00:13:48,700 --> 00:13:50,320
message to user application.

419
00:13:57,280 --> 00:13:58,940
Okay, good.

420
00:13:59,410 --> 00:14:00,820
So how do you implement these

421
00:14:00,820 --> 00:14:01,780
address spaces,

422
00:14:01,780 --> 00:14:03,640
you know how basically multiplex

423
00:14:03,640 --> 00:14:05,050
all these address spaces across a

424
00:14:05,050 --> 00:14:08,440
single physical memory and the most

425
00:14:08,440 --> 00:14:10,480
common approach and a very flexible

426
00:14:10,480 --> 00:14:12,840
approach is to use page tables.

427
00:14:17,360 --> 00:14:18,830
Um the idea is,

428
00:14:18,830 --> 00:14:20,270
um, this is a hard

429
00:14:20,270 --> 00:14:21,080
work support,

430
00:14:21,080 --> 00:14:23,540
so this is implemented in hardware

431
00:14:23,540 --> 00:14:25,910
by the processor or by a

432
00:14:25,910 --> 00:14:28,040
unit called the memory management unit,

433
00:14:28,040 --> 00:14:29,390
so the picture that you should

434
00:14:29,390 --> 00:14:31,070
have your head is, you know

435
00:14:31,070 --> 00:14:32,360
the CPU,

436
00:14:32,730 --> 00:14:35,940
that executes instructions, whatever are,

437
00:14:35,940 --> 00:14:36,720
you know,

438
00:14:38,580 --> 00:14:40,440
um, our store instruction that

439
00:14:40,440 --> 00:14:41,640
was you know putting $7

440
00:14:41,640 --> 00:14:47,180
into a0 indirect.

441
00:14:47,560 --> 00:14:48,790
Also executes those kind of

442
00:14:48,790 --> 00:14:51,010
instructions and you know when

443
00:14:51,010 --> 00:14:51,970
it executes one of their

444
00:14:51,970 --> 00:14:53,380
stor instruction, load instruction,

445
00:14:53,380 --> 00:14:54,850
whatever anything that actually has

446
00:14:54,850 --> 00:14:55,780
an address.

447
00:14:55,810 --> 00:14:57,610
You now, that address we're going

448
00:14:57,610 --> 00:14:58,270
to think about it as

449
00:14:58,270 --> 00:14:59,230
a virtual address,

450
00:14:59,230 --> 00:15:00,370
so it's not a physical address,

451
00:15:00,370 --> 00:15:01,560
it's a virtual address.

452
00:15:02,100 --> 00:15:02,400
And so,

453
00:15:02,400 --> 00:15:03,630
for example the value in a0

454
00:15:03,630 --> 00:15:05,250
that we're using here,

455
00:15:05,250 --> 00:15:08,400
um, yeah, say that's 1000,

456
00:15:08,760 --> 00:15:11,160
0x1000 data is a

457
00:15:11,160 --> 00:15:13,170
virtual address and virtual addresses basically

458
00:15:13,170 --> 00:15:15,840
routed through something what's called

459
00:15:15,840 --> 00:15:17,860
the memory management unit.

460
00:15:21,180 --> 00:15:23,580
Um, and the memory manager unit

461
00:15:23,580 --> 00:15:26,380
translates into a physical address.

462
00:15:27,680 --> 00:15:29,990
And that physical address then was

463
00:15:29,990 --> 00:15:32,920
actually used to index into memory.

464
00:15:33,120 --> 00:15:35,550
And load whatever value or

465
00:15:35,550 --> 00:15:37,230
store whatever value needs to be

466
00:15:37,230 --> 00:15:37,940
written there.

467
00:15:38,720 --> 00:15:40,460
Um, and so the CPU from

468
00:15:40,460 --> 00:15:41,630
the CPU point of view,

469
00:15:41,630 --> 00:15:42,710
it always issues,

470
00:15:42,710 --> 00:15:44,720
every instruction that issues,

471
00:15:44,720 --> 00:15:46,940
once the MMU use, enabled

472
00:15:46,940 --> 00:15:48,320
our virtual addresses.

473
00:15:49,100 --> 00:15:51,080
And to translate these virtual addresses

474
00:15:51,080 --> 00:15:52,850
to physical addresses, basically,

475
00:15:52,850 --> 00:15:54,200
MMU has a table.

476
00:15:55,080 --> 00:15:57,090
And you know virtual address

477
00:15:57,090 --> 00:15:58,260
on one side, physical address

478
00:15:58,260 --> 00:15:59,340
on one side,

479
00:15:59,340 --> 00:16:01,650
the other side, for example here is

480
00:16:01,650 --> 00:16:05,040
our entry for 1000 and maybe

481
00:16:05,040 --> 00:16:07,340
that maps to whatever,

482
00:16:07,860 --> 00:16:09,930
you know, 0x whatever you're

483
00:16:09,930 --> 00:16:11,280
making something up with like

484
00:16:11,280 --> 00:16:12,600
some big value,

485
00:16:13,020 --> 00:16:14,490
somewhere in physical memory.

486
00:16:14,490 --> 00:16:16,200
So this mapping between virtual and

487
00:16:16,200 --> 00:16:17,360
physical map.

488
00:16:17,390 --> 00:16:19,260
Um, it's quite flexible.

489
00:16:19,880 --> 00:16:20,900
And so on one side,

490
00:16:20,900 --> 00:16:21,830
we have the virtual address

491
00:16:21,830 --> 00:16:22,460
of the other side of

492
00:16:22,460 --> 00:16:23,580
the physical addresses.

493
00:16:26,030 --> 00:16:28,580
Typically, you know this mapping itself

494
00:16:28,580 --> 00:16:29,900
is also stored in memory.

495
00:16:30,160 --> 00:16:31,660
And so the CPU has some

496
00:16:31,660 --> 00:16:35,020
register that basically points to,

497
00:16:35,090 --> 00:16:37,190
that contains the physical

498
00:16:37,190 --> 00:16:39,230
address of where the page

499
00:16:39,230 --> 00:16:40,480
table is stored.

500
00:16:40,670 --> 00:16:42,650
So somewhere in basically the page

501
00:16:42,650 --> 00:16:44,450
table or just map somewhere stored

502
00:16:44,450 --> 00:16:45,620
in physical memory.

503
00:16:45,770 --> 00:16:47,120
Let's say, you know,

504
00:16:47,120 --> 00:16:49,620
whatever, address 10,

505
00:16:49,860 --> 00:16:51,810
basically this register which is

506
00:16:51,810 --> 00:16:54,560
called on the RISC-V satp.

507
00:16:54,740 --> 00:16:57,770
You know stores the address 10

508
00:16:57,770 --> 00:17:00,320
and so, that the CPU

509
00:17:00,320 --> 00:17:01,940
can tell the memory managed units

510
00:17:01,940 --> 00:17:05,210
where to find, you know, basically the map

511
00:17:05,210 --> 00:17:07,640
to actually translate virtual to

512
00:17:07,640 --> 00:17:08,700
physical addresses.

513
00:17:10,020 --> 00:17:11,250
And then the basic idea

514
00:17:11,250 --> 00:17:12,900
is to give every application

515
00:17:12,900 --> 00:17:13,860
it's own map.

516
00:17:14,320 --> 00:17:15,760
So cat is going

517
00:17:15,760 --> 00:17:16,240
to have,

518
00:17:16,240 --> 00:17:17,740
it's map. Oops.

519
00:17:19,110 --> 00:17:20,360
So every map, it's own...

520
00:17:23,360 --> 00:17:27,400
Yeah, [Big Ben], go ahead.

521
00:17:29,420 --> 00:17:31,790
Um, so the MMU,

522
00:17:31,790 --> 00:17:35,120
you said it doesn't necessarily store

523
00:17:35,120 --> 00:17:36,140
the mapping.

524
00:17:36,190 --> 00:17:38,590
So does it just,

525
00:17:38,590 --> 00:17:40,480
just do the translation like

526
00:17:40,480 --> 00:17:42,190
it will read the memory

527
00:17:42,190 --> 00:17:43,480
and do the translation,

528
00:17:43,480 --> 00:17:45,040
but not necessarily

529
00:17:45,160 --> 00:17:46,870
store the mappings.

530
00:17:46,870 --> 00:17:48,670
That's exactly the right picture that

531
00:17:48,670 --> 00:17:49,800
you should have your head.

532
00:17:52,960 --> 00:17:55,510
But every map, okay, so the

533
00:17:55,510 --> 00:17:57,040
map itself stored memory,

534
00:17:57,040 --> 00:17:58,900
the MMU just basically walks or

535
00:17:58,900 --> 00:18:00,310
looks into the map and we'll

536
00:18:00,310 --> 00:18:01,330
see in a second, you know,

537
00:18:01,330 --> 00:18:02,770
this map is slightly more complicated

538
00:18:02,770 --> 00:18:04,160
than I used draw here.

539
00:18:05,340 --> 00:18:07,080
Um, so every app has

540
00:18:07,080 --> 00:18:10,740
its own, its own map.

541
00:18:12,320 --> 00:18:14,450
Right, and that map basically defines

542
00:18:14,450 --> 00:18:15,720
its address space.

543
00:18:16,380 --> 00:18:18,270
And so when with the CPU or

544
00:18:18,270 --> 00:18:19,860
when the operating system switches the

545
00:18:19,860 --> 00:18:21,870
CPU from one process from one

546
00:18:21,870 --> 00:18:23,610
application to another application,

547
00:18:23,610 --> 00:18:25,380
it also switches the content

548
00:18:25,380 --> 00:18:26,080
of this

549
00:18:26,130 --> 00:18:29,310
satp register to store

550
00:18:29,310 --> 00:18:31,410
the root of the map of

551
00:18:31,410 --> 00:18:32,740
the appropriate process.

552
00:18:33,400 --> 00:18:34,660
And so in that way,

553
00:18:34,660 --> 00:18:36,580
basically you know multiple applications to

554
00:18:36,580 --> 00:18:37,420
run on the

555
00:18:37,420 --> 00:18:38,770
CPU, every time we switch

556
00:18:38,770 --> 00:18:40,030
between from one application to the

557
00:18:40,030 --> 00:18:41,080
next application,

558
00:18:41,080 --> 00:18:43,900
we also switch the satp

559
00:18:43,900 --> 00:18:45,820
register to point to the appropriate

560
00:18:45,820 --> 00:18:47,160
map for that application.

561
00:18:47,420 --> 00:18:48,170
And in that way,

562
00:18:48,170 --> 00:18:51,290
basically, virtual addresses you know

563
00:18:51,290 --> 00:18:54,590
for cat are translated differently,

564
00:18:54,590 --> 00:18:56,960
than the virtual addresses for the

565
00:18:56,960 --> 00:18:58,280
shell, because you know each one

566
00:18:58,280 --> 00:18:59,800
of them has their own map.

567
00:19:02,380 --> 00:19:03,240
That makes sense.

568
00:19:07,710 --> 00:19:10,170
Okay, so do we, this is the

569
00:19:10,170 --> 00:19:12,060
basic plan and the way I've

570
00:19:12,060 --> 00:19:14,340
drawn or gonna explain it so

571
00:19:14,340 --> 00:19:16,050
far it's pretty naive,

572
00:19:16,050 --> 00:19:17,980
and unreasonable.

573
00:19:18,230 --> 00:19:19,880
Um, yeah, David, go ahead.

574
00:19:20,820 --> 00:19:21,450
I'm sorry,

575
00:19:22,880 --> 00:19:25,610
So, the you said the

576
00:19:25,610 --> 00:19:28,070
satp register gets modified a

577
00:19:28,070 --> 00:19:30,110
for the process, I am guessing

578
00:19:30,110 --> 00:19:32,270
the value of for

579
00:19:32,270 --> 00:19:34,680
satp register for each process

580
00:19:34,730 --> 00:19:36,500
is stored by the kernel.

581
00:19:36,500 --> 00:19:37,550
Yes yes,

582
00:19:37,550 --> 00:19:39,230
the kernel is writing satp register,

583
00:19:39,230 --> 00:19:41,510
in fact writing or reading a

584
00:19:41,510 --> 00:19:44,030
particular writing the satp register is

585
00:19:44,030 --> 00:19:45,300
a privilege instruction.

586
00:19:45,830 --> 00:19:48,290
So user application cannot just

587
00:19:48,290 --> 00:19:50,060
update the page map register, and

588
00:19:50,060 --> 00:19:50,990
say like I want to run

589
00:19:50,990 --> 00:19:52,320
with this page map now.

590
00:19:52,460 --> 00:19:52,910
Because,

591
00:19:52,910 --> 00:19:55,800
that would violate isolation.

592
00:19:56,070 --> 00:19:57,690
So it's only the kernel, only

593
00:19:57,690 --> 00:19:58,980
code in kernel mode can actually

594
00:19:58,980 --> 00:19:59,780
update it.

595
00:20:01,100 --> 00:20:02,000
I see.

596
00:20:03,730 --> 00:20:05,110
Okay, so as I said this

597
00:20:05,110 --> 00:20:06,190
picture is pretty naive,

598
00:20:06,190 --> 00:20:07,420
you know one thing I

599
00:20:07,420 --> 00:20:08,860
haven't really said anything about how

600
00:20:08,860 --> 00:20:10,440
this actually map works.

601
00:20:10,750 --> 00:20:12,160
Um, and,

602
00:20:12,160 --> 00:20:13,420
you know the way I've

603
00:20:13,420 --> 00:20:15,250
drawn out seems to indicate a

604
00:20:15,250 --> 00:20:17,350
basically for every virtual address,

605
00:20:17,350 --> 00:20:18,070
you have an entry in

606
00:20:18,070 --> 00:20:18,720
the map.

607
00:20:19,440 --> 00:20:21,450
Um, and if you do that,

608
00:20:21,450 --> 00:20:22,860
how big would that be

609
00:20:25,400 --> 00:20:26,540
on RISC-V.

610
00:20:36,150 --> 00:20:37,470
How many addresses are there on

611
00:20:37,470 --> 00:20:38,910
the RISC-V in principle, or

612
00:20:38,910 --> 00:20:40,650
how big, how many addresses go

613
00:20:40,650 --> 00:20:41,860
to registers store.

614
00:20:46,100 --> 00:20:48,560
Registers are 64 bit wide,

615
00:20:48,560 --> 00:20:49,900
so how many addresses.

616
00:20:53,830 --> 00:20:55,240
I know, so insulting your

617
00:20:55,240 --> 00:20:57,320
intelligence by asking these questions about.

618
00:21:00,110 --> 00:21:00,980
We have some answers in the

619
00:21:00,980 --> 00:21:02,600
chat, like two to the 64.

620
00:21:02,600 --> 00:21:03,770
I didn't see the chat,

621
00:21:03,770 --> 00:21:04,610
sorry, um,

622
00:21:04,610 --> 00:21:06,050
yeah, two to 64. Lets see

623
00:21:06,050 --> 00:21:07,340
if I can actually pop off

624
00:21:07,340 --> 00:21:07,970
the chip,

625
00:21:07,970 --> 00:21:08,980
so I could see it.

626
00:21:13,460 --> 00:21:14,450
Yeah, two to 64,

627
00:21:14,450 --> 00:21:15,180
thank you.

628
00:21:16,990 --> 00:21:19,090
Alright, so this table would

629
00:21:19,090 --> 00:21:20,280
be gigantic.

630
00:21:20,420 --> 00:21:22,130
Um, in fact we know

631
00:21:22,130 --> 00:21:23,540
all memory would be consumed

632
00:21:23,540 --> 00:21:24,590
by just having the table

633
00:21:24,590 --> 00:21:26,000
so that seems reasonable.

634
00:21:26,360 --> 00:21:27,590
Um, and so in fact you

635
00:21:27,590 --> 00:21:29,160
know that's not how things work.

636
00:21:29,520 --> 00:21:30,510
Um, in fact I'm going to

637
00:21:30,510 --> 00:21:32,250
go in two steps, to actually, how

638
00:21:32,250 --> 00:21:33,820
it actually works in RISC-V.

639
00:21:33,920 --> 00:21:36,800
Step one is don't play

640
00:21:36,800 --> 00:21:40,040
the game per address,

641
00:21:40,040 --> 00:21:41,720
but do per page.

642
00:21:44,580 --> 00:21:45,900
So you translate a page at

643
00:21:45,900 --> 00:21:47,880
a time and a page a

644
00:21:47,880 --> 00:21:50,380
on RISC-V is 4 kilobytes.

645
00:21:51,860 --> 00:21:52,940
Which is a four, and

646
00:21:52,940 --> 00:21:54,700
4096 bytes.

647
00:21:55,080 --> 00:21:56,430
This is pretty common,

648
00:21:56,430 --> 00:21:58,830
almost all processors, you know, use

649
00:21:58,830 --> 00:22:01,320
roughly page size 4 kilobytes, or support

650
00:22:01,320 --> 00:22:02,780
page size 4 kilobytes.

651
00:22:03,420 --> 00:22:05,070
And so now again, translation works

652
00:22:05,070 --> 00:22:06,000
slightly differently,

653
00:22:06,000 --> 00:22:07,230
so if here, we have our

654
00:22:07,230 --> 00:22:08,300
virtual address.

655
00:22:09,360 --> 00:22:11,340
Amazingly, we split it in two pieces,

656
00:22:11,340 --> 00:22:12,300
an index and

657
00:22:13,320 --> 00:22:14,580
an offset.

658
00:22:15,300 --> 00:22:16,620
And so the offset is basically

659
00:22:16,620 --> 00:22:18,240
the byte within the page.

660
00:22:18,880 --> 00:22:20,170
And so when we do,

661
00:22:20,170 --> 00:22:21,610
when the MMU does

662
00:22:21,610 --> 00:22:23,820
the translation it takes the index,

663
00:22:23,970 --> 00:22:27,240
indexes into the map that

664
00:22:27,240 --> 00:22:29,100
gives you some physical page number,

665
00:22:29,100 --> 00:22:31,280
or you know in memory.

666
00:22:31,480 --> 00:22:33,520
In the physical page number that

667
00:22:33,520 --> 00:22:35,680
points to some physical page of

668
00:22:35,680 --> 00:22:37,460
4096 bytes.

669
00:22:38,040 --> 00:22:39,870
And then the offset part,

670
00:22:39,870 --> 00:22:42,810
basically indexes into that physical page,

671
00:22:42,810 --> 00:22:43,530
so, for example,

672
00:22:43,530 --> 00:22:45,400
the offset is, you know, 12.

673
00:22:45,770 --> 00:22:48,100
Then you know there are

674
00:22:48,690 --> 00:22:51,120
the 12th entry of that

675
00:22:51,120 --> 00:22:53,680
page is actually used.

676
00:22:54,110 --> 00:22:55,490
A lot of people a lot

677
00:22:55,490 --> 00:22:57,590
of you entered in the message

678
00:22:57,590 --> 00:22:58,780
in the,

679
00:22:59,070 --> 00:23:00,300
in response to the question,

680
00:23:00,300 --> 00:23:02,340
there's always some scheme of taking

681
00:23:02,340 --> 00:23:04,770
an offset and adding that to

682
00:23:04,770 --> 00:23:06,570
the base of the page

683
00:23:06,570 --> 00:23:09,340
to obtain the actual

684
00:23:09,500 --> 00:23:11,690
memory, physical memory location, where

685
00:23:11,690 --> 00:23:13,820
a value store, where value will

686
00:23:13,820 --> 00:23:15,480
be loaded too.

687
00:23:16,400 --> 00:23:17,510
And one of the interesting things

688
00:23:17,510 --> 00:23:19,010
about the RISC-V is and

689
00:23:19,010 --> 00:23:20,690
this is a response to some

690
00:23:20,690 --> 00:23:21,320
questions again,

691
00:23:21,320 --> 00:23:22,400
somebody asked look a

692
00:23:22,400 --> 00:23:23,900
the physical,

693
00:23:24,110 --> 00:23:25,520
or virtual addresses are

694
00:23:25,520 --> 00:23:26,760
64 bits.

695
00:23:28,250 --> 00:23:29,630
Which makes totally sense correct,

696
00:23:29,630 --> 00:23:31,520
because the RISC-V is

697
00:23:31,520 --> 00:23:32,560
64-bit register.

698
00:23:33,210 --> 00:23:35,280
Um, but in fact on the

699
00:23:35,280 --> 00:23:38,190
RISC-V processor, that we're using,

700
00:23:38,190 --> 00:23:39,780
not all of the 64 bits

701
00:23:39,780 --> 00:23:40,800
actually used.

702
00:23:41,160 --> 00:23:43,890
Namely, the top 25 are

703
00:23:43,890 --> 00:23:45,220
actually not used at all.

704
00:23:45,800 --> 00:23:47,630
Um, and so that limits the

705
00:23:47,630 --> 00:23:49,520
size of a virtual address, that

706
00:23:49,520 --> 00:23:50,900
limits the size of a virtual

707
00:23:50,900 --> 00:23:52,460
address space two to the power

708
00:23:52,460 --> 00:23:53,360
of 49.

709
00:23:54,980 --> 00:23:57,590
Um, which is roughly

710
00:23:57,590 --> 00:23:58,740
512 gigabytes.

711
00:24:04,210 --> 00:24:06,310
Um, and so of course you

712
00:24:06,310 --> 00:24:08,560
know later version of the

713
00:24:08,560 --> 00:24:10,360
processor, might support bigger address spaces

714
00:24:10,360 --> 00:24:12,400
and that is necessary and could then

715
00:24:14,080 --> 00:24:15,850
be done, for example, some of those 25 bits

716
00:24:15,850 --> 00:24:18,310
that are basically unused, could be used to

717
00:24:18,310 --> 00:24:21,640
build bigger virtual address spaces.

718
00:24:22,390 --> 00:24:23,620
So, um,

719
00:24:23,620 --> 00:24:24,400
and so in the index

720
00:24:24,400 --> 00:24:25,300
and then, you know, where

721
00:24:25,300 --> 00:24:26,440
39 bits left,

722
00:24:26,440 --> 00:24:27,820
you know as the virtual address

723
00:24:27,820 --> 00:24:29,830
27, 27 bits are

724
00:24:29,830 --> 00:24:31,030
index and we'll see you in

725
00:24:31,030 --> 00:24:33,100
a second, why they are 27

726
00:24:33,480 --> 00:24:35,100
are index and then

727
00:24:35,100 --> 00:24:37,580
the 12 are offset.

728
00:24:38,280 --> 00:24:39,480
And you know there has to

729
00:24:39,480 --> 00:24:40,890
be 12, because two to the

730
00:24:40,890 --> 00:24:43,880
power 12 is 4096.

731
00:24:46,590 --> 00:24:48,360
So that's virtual addresses on the

732
00:24:48,360 --> 00:24:50,520
RISC-V physical addresses as you

733
00:24:50,520 --> 00:24:52,350
can see here are actually 56

734
00:24:52,350 --> 00:24:53,240
bits wide.

735
00:24:57,940 --> 00:24:59,140
So the physical memory,

736
00:24:59,140 --> 00:25:01,570
you can be bigger than the

737
00:25:01,570 --> 00:25:03,220
single virtual address space.

738
00:25:03,880 --> 00:25:05,110
But it's limited to two power up

739
00:25:05,110 --> 00:25:05,950
to 56,

740
00:25:05,950 --> 00:25:07,870
you know most boards probably, you know,

741
00:25:07,870 --> 00:25:09,190
don't support two to the power

742
00:25:09,190 --> 00:25:11,710
of 56 physical memory, because

743
00:25:11,710 --> 00:25:14,060
a gigantic amount of physical memory.

744
00:25:14,090 --> 00:25:15,290
Um, but in principle the

745
00:25:15,290 --> 00:25:16,160
board could,

746
00:25:16,160 --> 00:25:16,610
you know,

747
00:25:16,610 --> 00:25:18,500
if you could manufacture it

748
00:25:18,500 --> 00:25:19,760
support two to the power

749
00:25:19,760 --> 00:25:21,200
of 56 physical memory.

750
00:25:22,020 --> 00:25:23,130
And so in this scheme,

751
00:25:23,130 --> 00:25:25,620
then if 56 bit for

752
00:25:25,620 --> 00:25:27,330
the physical address 44 are basically

753
00:25:27,330 --> 00:25:28,440
the physical page number,

754
00:25:28,440 --> 00:25:30,720
the PPM, and twelve are the

755
00:25:30,720 --> 00:25:32,610
offset that are inherited directly from

756
00:25:32,610 --> 00:25:34,660
the virtual address.

757
00:25:36,840 --> 00:25:37,940
Does that make sense.

758
00:25:40,560 --> 00:25:41,640
So, um,

759
00:25:41,640 --> 00:25:42,630
you know stop for a second

760
00:25:42,630 --> 00:25:44,310
here. So you collect your thoughts,

761
00:25:44,310 --> 00:25:45,390
the only point I wanted to

762
00:25:45,390 --> 00:25:48,780
make here is that this material

763
00:25:48,780 --> 00:25:49,410
is important,

764
00:25:49,410 --> 00:25:51,000
so just ask questions,

765
00:25:51,000 --> 00:25:52,740
the details matter,

766
00:25:52,740 --> 00:25:54,480
and it will be a large

767
00:25:54,480 --> 00:25:55,560
part of you,

768
00:25:55,560 --> 00:25:56,760
you really need to understand all

769
00:25:56,760 --> 00:25:57,240
this stuff,

770
00:25:57,240 --> 00:25:58,980
to be able to basically

771
00:25:58,980 --> 00:26:00,990
do lab, the next lab, the page

772
00:26:00,990 --> 00:26:01,740
table lab.

773
00:26:02,570 --> 00:26:03,260
Yeah I'm here,

774
00:26:03,260 --> 00:26:03,770
go ahead, please.

775
00:26:05,200 --> 00:26:06,220
Um, if you can go back

776
00:26:06,220 --> 00:26:07,900
one slide, I have the screen

777
00:26:07,900 --> 00:26:09,080
is unclear.

778
00:26:10,740 --> 00:26:11,280
Which one,

779
00:26:11,280 --> 00:26:13,860
the page table slide? Yeah.

780
00:26:20,260 --> 00:26:21,220
This one?

781
00:26:21,220 --> 00:26:22,200
Um, no.

782
00:26:22,680 --> 00:26:24,210
The most recent one, but it

783
00:26:24,210 --> 00:26:25,320
also doesn't really matter,

784
00:26:25,320 --> 00:26:26,190
um, yeah,

785
00:26:26,190 --> 00:26:26,790
this is perfect,

786
00:26:26,790 --> 00:26:29,070
thank you so I'm wondering this

787
00:26:29,070 --> 00:26:33,330
4096 byte range which we've called

788
00:26:33,330 --> 00:26:35,430
a page, is that assigned as

789
00:26:35,430 --> 00:26:37,950
a continuous chunk in memory,

790
00:26:37,950 --> 00:26:40,200
yes that's a continuous physical,

791
00:26:40,200 --> 00:26:44,190
continuous range of 4096 bytes

792
00:26:44,190 --> 00:26:45,340
including memory.

793
00:26:46,510 --> 00:26:49,630
I see, and then. You know, the map,

794
00:26:49,630 --> 00:26:53,440
a granularity of 4096 bytes.

795
00:26:53,440 --> 00:26:55,390
Okay, and then 12, the

796
00:26:55,390 --> 00:26:57,250
offset like two to the

797
00:26:57,250 --> 00:26:58,630
twelve is 4096,

798
00:26:58,630 --> 00:27:00,760
so that's sufficient to cover each

799
00:27:00,760 --> 00:27:03,880
of the chunks? Yeah, each byte in the page.

800
00:27:04,770 --> 00:27:07,020
And where does the 56 come

801
00:27:07,020 --> 00:27:09,120
from, in the diagram I could

802
00:27:09,120 --> 00:27:10,680
follow up until then,

803
00:27:10,680 --> 00:27:11,640
but I didn't get where

804
00:27:11,640 --> 00:27:13,530
that came from. Um, the

805
00:27:13,530 --> 00:27:14,840
designers cook it up.

806
00:27:15,180 --> 00:27:16,800
So the hardware designers decide

807
00:27:16,800 --> 00:27:17,940
how big you know physical

808
00:27:17,940 --> 00:27:20,250
addresses basically for whatever board

809
00:27:20,250 --> 00:27:22,620
they want to design,

810
00:27:22,620 --> 00:27:24,270
and so the RISC-V

811
00:27:24,270 --> 00:27:26,850
designers who decided at 56,

812
00:27:26,850 --> 00:27:28,050
that physical addresses were a

813
00:27:28,050 --> 00:27:28,920
good idea.

814
00:27:30,560 --> 00:27:32,240
Um, and usually the way they

815
00:27:32,240 --> 00:27:33,530
come up with these numbers is

816
00:27:33,530 --> 00:27:35,260
they look at technology trends.

817
00:27:35,500 --> 00:27:36,970
And say like well we want

818
00:27:36,970 --> 00:27:37,990
to be able for the next

819
00:27:37,990 --> 00:27:38,980
sort of 5 years,

820
00:27:38,980 --> 00:27:40,870
you know to predict the physical

821
00:27:40,870 --> 00:27:42,340
memory will be ever bigger than

822
00:27:42,340 --> 00:27:43,840
two to the power 56.

823
00:27:44,740 --> 00:27:45,940
Probably they think it won't be

824
00:27:45,940 --> 00:27:47,590
bigger than something much smaller,

825
00:27:47,590 --> 00:27:48,910
but then you know give them

826
00:27:48,910 --> 00:27:50,650
some [v way], you know,

827
00:27:50,650 --> 00:27:51,550
in case you know their

828
00:27:51,550 --> 00:27:52,720
predictions wrong,

829
00:27:52,720 --> 00:27:54,460
they pick a slightly

830
00:27:54,460 --> 00:27:55,220
bigger number.

831
00:27:56,720 --> 00:27:58,060
Is that makes sense.

832
00:27:58,640 --> 00:28:00,440
Yeah, thanks. A lot of people

833
00:28:00,440 --> 00:28:01,790
ask about this.

834
00:28:03,870 --> 00:28:05,340
Anybody else, who raised a hand

835
00:28:05,340 --> 00:28:06,210
I think there's a bunch of

836
00:28:06,210 --> 00:28:08,610
people asking questions and unfortunately my

837
00:28:08,610 --> 00:28:10,200
zoom doesn't show its more than

838
00:28:10,200 --> 00:28:12,000
two people raised hands just multiple

839
00:28:12,000 --> 00:28:13,260
people are raising their hands.

840
00:28:13,720 --> 00:28:15,190
So you please jump in, if

841
00:28:15,190 --> 00:28:16,040
you have a question.

842
00:28:20,160 --> 00:28:23,730
Okay. I have a question,

843
00:28:23,730 --> 00:28:27,150
yeah, so if the virtual

844
00:28:27,150 --> 00:28:28,680
memory is up to two

845
00:28:28,680 --> 00:28:30,060
to the power of 27

846
00:28:30,060 --> 00:28:31,290
and the physical memory is

847
00:28:31,290 --> 00:28:32,670
up two to the power

848
00:28:32,670 --> 00:28:34,710
due to the 56, right,

849
00:28:34,710 --> 00:28:37,340
so, we could have,

850
00:28:38,550 --> 00:28:41,070
like we could have multiple processes

851
00:28:41,070 --> 00:28:42,630
that could exhaust all their virtual

852
00:28:42,630 --> 00:28:43,920
memories without

853
00:28:44,100 --> 00:28:46,140
using up all the physical memory,

854
00:28:46,140 --> 00:28:47,820
right? That's correct.

855
00:28:52,250 --> 00:28:53,280
That's absolutely correct.

856
00:28:54,040 --> 00:28:56,170
Okay I have a question, too.

857
00:28:56,170 --> 00:28:58,060
Yeah, go ahead.

858
00:28:58,190 --> 00:29:00,470
So this 56 for the physical

859
00:29:00,470 --> 00:29:02,960
address is that the,

860
00:29:03,240 --> 00:29:06,380
the number of possible memory locations.

861
00:29:06,510 --> 00:29:07,680
I don't think it's the

862
00:29:07,680 --> 00:29:09,990
number of bits because the 64

863
00:29:09,990 --> 00:29:11,140
bit machine.

864
00:29:11,170 --> 00:29:13,180
Um that 56 could go up

865
00:29:13,180 --> 00:29:14,410
to 64,

866
00:29:14,410 --> 00:29:16,100
but they just choose it

867
00:29:16,290 --> 00:29:17,850
to have just 56.

868
00:29:18,600 --> 00:29:19,350
That's correct,

869
00:29:19,350 --> 00:29:20,280
one way to think about it,

870
00:29:20,280 --> 00:29:21,120
then they only have to run

871
00:29:21,120 --> 00:29:23,220
56 wide on the board as

872
00:29:23,220 --> 00:29:24,520
opposed to 64.

873
00:29:25,530 --> 00:29:27,260
I see, I see.

874
00:29:30,220 --> 00:29:32,530
Okay. I also have a question,

875
00:29:32,530 --> 00:29:35,650
um, so kind of, could you

876
00:29:35,650 --> 00:29:36,670
go back one slide maybe,

877
00:29:38,820 --> 00:29:42,570
so from the CPU,

878
00:29:42,570 --> 00:29:44,700
we go through the MMU and

879
00:29:44,700 --> 00:29:47,010
then to the memory, but

880
00:29:47,010 --> 00:29:50,160
where, where here is the distinction

881
00:29:50,160 --> 00:29:53,460
for different processes, because like each

882
00:29:53,460 --> 00:29:56,040
process, like process, like the shell

883
00:29:56,040 --> 00:29:58,200
process has something at address like

884
00:29:58,200 --> 00:30:00,450
0x1000,

885
00:30:00,450 --> 00:30:02,610
and then the ls process

886
00:30:02,610 --> 00:30:04,200
also has something at address

887
00:30:04,200 --> 00:30:06,090
0x0000, so

888
00:30:06,090 --> 00:30:07,350
we need to translate those to

889
00:30:07,350 --> 00:30:12,680
different physical, so. Yeah, the satp register

890
00:30:13,330 --> 00:30:15,580
contains the register who contains the

891
00:30:15,580 --> 00:30:17,760
address of which map to use.

892
00:30:18,450 --> 00:30:20,580
So ls runs with its own map,

893
00:30:20,580 --> 00:30:22,710
you know cat with its own map.

894
00:30:22,710 --> 00:30:25,020
OK, so each process will have

895
00:30:25,020 --> 00:30:27,580
its completely own map. Yeah.

896
00:30:28,140 --> 00:30:28,680
Makes sense,

897
00:30:28,680 --> 00:30:29,700
thank you.

898
00:30:29,700 --> 00:30:31,380
In fact, there's a great a

899
00:30:31,380 --> 00:30:32,220
way to the next,

900
00:30:33,300 --> 00:30:35,310
point, so if every process has

901
00:30:35,310 --> 00:30:36,340
its own map.

902
00:30:36,870 --> 00:30:38,430
You know how big is this

903
00:30:38,430 --> 00:30:40,380
map, like that I've drawn here.

904
00:30:40,900 --> 00:30:42,220
Well, that map is two to

905
00:30:42,220 --> 00:30:44,520
the power 27 entries, correct.

906
00:30:46,460 --> 00:30:48,140
Um, and that's pretty big.

907
00:30:49,030 --> 00:30:50,500
Um, and I would fill physical

908
00:30:50,500 --> 00:30:51,910
memory reasonable quickly,

909
00:30:51,910 --> 00:30:53,650
if every process exactly how

910
00:30:53,650 --> 00:30:56,300
to complete you know populated map.

911
00:30:56,560 --> 00:30:58,450
And then there's gigantic, means that

912
00:30:58,450 --> 00:31:00,130
every process is very big,

913
00:31:00,130 --> 00:31:01,420
and so in fact this is

914
00:31:01,420 --> 00:31:03,700
not the way, hardware actually

915
00:31:03,700 --> 00:31:04,900
stores page tables,

916
00:31:04,900 --> 00:31:06,040
you can think about it

917
00:31:06,040 --> 00:31:07,690
conceptually as an array,

918
00:31:07,690 --> 00:31:08,980
you know going from zero to

919
00:31:08,980 --> 00:31:09,910
two power 27,

920
00:31:09,910 --> 00:31:11,080
but actually is not what happens

921
00:31:11,080 --> 00:31:11,840
in practice.

922
00:31:12,120 --> 00:31:13,110
In practice,

923
00:31:13,110 --> 00:31:15,750
it's a multi-level structure that

924
00:31:15,750 --> 00:31:18,260
here's actually the real RISC-V

925
00:31:20,900 --> 00:31:21,780
page table.

926
00:31:23,460 --> 00:31:25,820
Structure and what the hardware implements.

927
00:31:26,820 --> 00:31:28,350
And so what happens with the

928
00:31:28,350 --> 00:31:30,780
27 bits that we started earlier,

929
00:31:30,780 --> 00:31:31,820
the index.

930
00:31:32,240 --> 00:31:35,810
It's actually split in three

931
00:31:35,810 --> 00:31:37,860
nine bit numbers.

932
00:31:38,220 --> 00:31:40,230
And the first the top nine

933
00:31:40,230 --> 00:31:42,660
bits, are used to index into

934
00:31:42,660 --> 00:31:44,920
the top level page table,

935
00:31:44,990 --> 00:31:46,700
directory as they are called.

936
00:31:47,120 --> 00:31:47,480
And so,

937
00:31:47,480 --> 00:31:48,410
then one directory,

938
00:31:48,410 --> 00:31:49,520
you know one of these guys,

939
00:31:49,520 --> 00:31:51,620
you know is 4096 bytes,

940
00:31:51,620 --> 00:31:53,640
4096 bytes.

941
00:31:54,310 --> 00:31:55,800
Just like the page size.

942
00:31:56,150 --> 00:31:58,820
A PTE entry, one of

943
00:31:58,820 --> 00:32:00,080
the entries in the thing

944
00:32:00,080 --> 00:32:02,040
is 64 bytes.

945
00:32:03,520 --> 00:32:04,600
64 bit,

946
00:32:04,600 --> 00:32:07,090
I mean, sorry, like the register

947
00:32:07,090 --> 00:32:08,680
with so eight bytes.

948
00:32:09,000 --> 00:32:10,230
And so there's going to mean

949
00:32:10,230 --> 00:32:12,080
that you do 4096.

950
00:32:12,710 --> 00:32:14,390
Divided by eight, means there are

951
00:32:14,390 --> 00:32:17,090
512 entries in one of those

952
00:32:17,090 --> 00:32:18,300
directory pages.

953
00:32:19,400 --> 00:32:20,810
So basically what happens is

954
00:32:20,810 --> 00:32:22,310
like the satp points

955
00:32:22,310 --> 00:32:23,360
to the top,

956
00:32:23,480 --> 00:32:24,650
root directory,

957
00:32:24,650 --> 00:32:25,940
we take the top level 9

958
00:32:25,940 --> 00:32:29,040
bits index into the page directory.

959
00:32:29,190 --> 00:32:30,060
And now gives us a new

960
00:32:30,060 --> 00:32:31,340
physical page number.

961
00:32:32,040 --> 00:32:33,330
And that physical page number

962
00:32:33,330 --> 00:32:35,040
is the page directory for

963
00:32:35,040 --> 00:32:36,030
the next level,

964
00:32:36,030 --> 00:32:36,870
so when we use the

965
00:32:36,870 --> 00:32:39,1200
next level, index,

966
00:32:39,200 --> 00:32:41,210
To index into that page

967
00:32:41,210 --> 00:32:42,890
directory and then you know

968
00:32:42,890 --> 00:32:43,670
and so forth,

969
00:32:43,670 --> 00:32:44,600
you know, we'd like to find

970
00:32:44,600 --> 00:32:46,490
one we get the bottom level

971
00:32:46,490 --> 00:32:47,620
page directory.

972
00:32:47,780 --> 00:32:48,950
And that basically gives us

973
00:32:48,950 --> 00:32:49,760
the entry,

974
00:32:49,760 --> 00:32:51,560
that maps the virtual address

975
00:32:51,560 --> 00:32:52,600
to physical address.

976
00:32:55,680 --> 00:32:56,400
So in some sense,

977
00:32:56,400 --> 00:32:58,170
it's very similar to where I

978
00:32:58,170 --> 00:32:59,520
showed in the previous slide except

979
00:32:59,520 --> 00:33:00,930
they're basically the index happens in

980
00:33:00,930 --> 00:33:02,760
three steps instead of one step.

981
00:33:02,870 --> 00:33:04,070
And this is advantage,

982
00:33:04,070 --> 00:33:05,480
the main advantage of this scheme

983
00:33:05,480 --> 00:33:07,760
is that large parts of the

984
00:33:07,760 --> 00:33:09,470
address space are not being used,

985
00:33:09,470 --> 00:33:10,310
you don't have to have any

986
00:33:10,310 --> 00:33:11,880
page table entries for that.

987
00:33:12,920 --> 00:33:13,550
For example,

988
00:33:13,550 --> 00:33:14,570
let's say you have a new

989
00:33:14,570 --> 00:33:15,660
address base.

990
00:33:16,130 --> 00:33:18,470
That has only one page like

991
00:33:18,470 --> 00:33:19,500
the bottom page.

992
00:33:19,640 --> 00:33:21,500
Yeah, 4096.

993
00:33:22,790 --> 00:33:24,410
And no other pages or in

994
00:33:24,410 --> 00:33:25,550
the address space,

995
00:33:25,550 --> 00:33:27,860
so only addresses zero to 4095

996
00:33:27,860 --> 00:33:29,340
and 6 are actually mapped.

997
00:33:29,500 --> 00:33:30,880
How many page table entry or

998
00:33:30,880 --> 00:33:32,200
page table directories do you need

999
00:33:32,200 --> 00:33:33,280
to map that.

1000
00:33:33,370 --> 00:33:35,060
Particular page.

1001
00:33:39,280 --> 00:33:40,150
Well, you need one of the

1002
00:33:40,150 --> 00:33:41,280
top, correct.

1003
00:33:41,790 --> 00:33:43,440
And you need basically value in

1004
00:33:43,440 --> 00:33:45,440
that entry for zero.

1005
00:33:46,520 --> 00:33:47,840
The top level nine bits,

1006
00:33:47,840 --> 00:33:49,640
you know zero zero so you

1007
00:33:49,640 --> 00:33:51,500
need an entry for zero.

1008
00:33:51,860 --> 00:33:53,420
So that means you need one

1009
00:33:53,420 --> 00:33:54,740
middle level entry,

1010
00:33:54,740 --> 00:33:56,510
you know that basically a corresponds

1011
00:33:56,510 --> 00:33:57,170
to the next,

1012
00:33:57,170 --> 00:33:59,060
you know nine zero bits and

1013
00:33:59,060 --> 00:34:00,500
then one entry for the next

1014
00:34:00,500 --> 00:34:01,480
nine zero bits.

1015
00:34:02,170 --> 00:34:04,300
So basically we get away with

1016
00:34:04,300 --> 00:34:07,160
three page directories.

1017
00:34:11,420 --> 00:34:12,770
In our previous scheme on the

1018
00:34:12,770 --> 00:34:14,120
previous slide correct,

1019
00:34:14,120 --> 00:34:15,080
we have two to the power

1020
00:34:15,080 --> 00:34:17,390
27 entries and now we basically

1021
00:34:17,390 --> 00:34:18,800
have to have three times whatever

1022
00:34:18,800 --> 00:34:20,580
512 entries that we're done.

1023
00:34:21,940 --> 00:34:24,970
That's the main reason why

1024
00:34:24,970 --> 00:34:26,620
you know the actual hardware I

1025
00:34:26,620 --> 00:34:28,360
has this hierarchical,

1026
00:34:28,360 --> 00:34:31,060
um multi-level tree scheme.

1027
00:34:32,570 --> 00:34:34,010
Any questions about this, because it's

1028
00:34:34,010 --> 00:34:34,920
pretty important.

1029
00:34:36,280 --> 00:34:37,520
Samir, go ahead.

1030
00:34:38,980 --> 00:34:44,050
So my question is as since

1031
00:34:44,050 --> 00:34:46,090
the PPM number from each page

1032
00:34:46,090 --> 00:34:48,100
table is 44 bits.

1033
00:34:48,430 --> 00:34:50,770
And the second say the middle

1034
00:34:50,770 --> 00:34:53,880
table resides on the virtual memory.

1035
00:34:53,950 --> 00:34:55,390
Where do we get the missing

1036
00:34:55,390 --> 00:34:56,560
twelve bits from.

1037
00:34:57,290 --> 00:34:58,820
On the final twelve bits okay

1038
00:34:58,820 --> 00:35:00,260
so good good good,

1039
00:35:00,260 --> 00:35:02,740
so you're saying these 44, correct.

1040
00:35:02,940 --> 00:35:04,110
Yes, what is going on

1041
00:35:04,110 --> 00:35:04,380
with that,

1042
00:35:04,380 --> 00:35:06,210
while all page, all page directories

1043
00:35:06,210 --> 00:35:07,480
or page line.

1044
00:35:08,170 --> 00:35:10,360
And so they basically they're a

1045
00:35:10,360 --> 00:35:11,920
physical page number is 44 plus

1046
00:35:11,920 --> 00:35:16,120
twelve, twelve zero bits.

1047
00:35:18,920 --> 00:35:20,180
And so what actually happens if

1048
00:35:20,180 --> 00:35:21,860
we look at these PTE entries,

1049
00:35:21,860 --> 00:35:23,060
they all have the same sort

1050
00:35:23,060 --> 00:35:23,990
of form,

1051
00:35:23,990 --> 00:35:24,620
if you look at one of

1052
00:35:24,620 --> 00:35:25,840
these guys.

1053
00:35:25,920 --> 00:35:26,880
There are 44 bits,

1054
00:35:26,880 --> 00:35:28,590
there are 12 bits

1055
00:35:28,590 --> 00:35:30,060
zero, so that gives us a

1056
00:35:30,060 --> 00:35:32,280
44 plus 12 is 56, so

1057
00:35:32,280 --> 00:35:33,660
that gives us a physical address,

1058
00:35:36,620 --> 00:35:39,050
Um, and so that means there's

1059
00:35:39,050 --> 00:35:39,860
64 bits,

1060
00:35:39,860 --> 00:35:41,420
there's actually some bits left

1061
00:35:41,420 --> 00:35:42,470
there not being used and

1062
00:35:42,470 --> 00:35:43,850
in fact the bottom twelve

1063
00:35:43,850 --> 00:35:45,020
bits were basically or the

1064
00:35:45,020 --> 00:35:47,030
bottom ten definitely bottom based

1065
00:35:47,030 --> 00:35:48,320
on not used at all and

1066
00:35:48,320 --> 00:35:50,210
in fact the paging hardware

1067
00:35:50,210 --> 00:35:52,490
stores or stores a bunch

1068
00:35:52,490 --> 00:35:54,950
of flags that control the

1069
00:35:54,950 --> 00:35:56,090
translation and we'll talk about

1070
00:35:56,090 --> 00:35:57,480
those flags in the second.

1071
00:35:57,730 --> 00:36:00,520
Um, and with their

1072
00:36:00,520 --> 00:36:02,140
to control the translation and

1073
00:36:02,140 --> 00:36:03,520
they're stored basically in the bottom

1074
00:36:03,520 --> 00:36:04,860
10 bits.

1075
00:36:05,100 --> 00:36:06,780
Um, it also means that, you

1076
00:36:06,780 --> 00:36:07,890
know, if you add these two

1077
00:36:07,890 --> 00:36:09,660
up that's 54 bits,

1078
00:36:09,660 --> 00:36:11,680
basically there's 10 bits left.

1079
00:36:11,920 --> 00:36:13,660
There are unused, those 10 bits

1080
00:36:13,660 --> 00:36:14,650
are again,

1081
00:36:14,650 --> 00:36:16,810
you know for future growth,

1082
00:36:16,810 --> 00:36:17,920
so at some point we might

1083
00:36:17,920 --> 00:36:18,850
have a new type of

1084
00:36:18,850 --> 00:36:20,800
RISC-V processor, that will have a

1085
00:36:20,800 --> 00:36:22,840
slightly different structure page tables,

1086
00:36:22,840 --> 00:36:24,460
and it might actually have bigger

1087
00:36:24,460 --> 00:36:25,930
than 44 bits for the physical

1088
00:36:25,930 --> 00:36:27,040
page number, OK?

1089
00:36:29,460 --> 00:36:31,380
Thank you.

1090
00:36:31,380 --> 00:36:32,340
In fact you can see

1091
00:36:32,340 --> 00:36:33,090
it here like if you

1092
00:36:33,090 --> 00:36:33,990
look at a single entry

1093
00:36:33,990 --> 00:36:36,060
direct that's drawn here,

1094
00:36:36,060 --> 00:36:37,920
um, you know they're basically.

1095
00:36:38,490 --> 00:36:40,140
10, 10 bits left, that

1096
00:36:40,140 --> 00:36:41,200
are not being used.

1097
00:36:42,020 --> 00:36:43,010
Um, okay,

1098
00:36:43,010 --> 00:36:44,240
so let's look at the flags

1099
00:36:44,240 --> 00:36:45,680
for a second, because it's sort

1100
00:36:45,680 --> 00:36:46,620
of important.

1101
00:36:46,940 --> 00:36:48,020
Um, so,

1102
00:36:48,020 --> 00:36:50,180
every translation in the bottom 10

1103
00:36:50,180 --> 00:36:51,170
bits, there's a bunch of flag

1104
00:36:51,170 --> 00:36:53,810
stored and the first flag

1105
00:36:53,810 --> 00:36:54,960
is valid.

1106
00:36:55,540 --> 00:36:57,880
If a valid bit set,

1107
00:36:57,880 --> 00:36:58,780
that means this is a

1108
00:36:58,780 --> 00:37:00,130
valid PTE,

1109
00:37:00,130 --> 00:37:01,210
and you can use it

1110
00:37:01,210 --> 00:37:02,220
for translation.

1111
00:37:03,180 --> 00:37:05,190
And so, we're going to

1112
00:37:05,190 --> 00:37:06,630
run my little example, that I

1113
00:37:06,630 --> 00:37:08,790
used here, three page directories,

1114
00:37:08,790 --> 00:37:10,620
when only entry zero is used

1115
00:37:10,620 --> 00:37:12,390
then only entey zero will have

1116
00:37:12,390 --> 00:37:13,890
valid bit set and none of

1117
00:37:13,890 --> 00:37:15,390
the other five [and eleven] entries

1118
00:37:15,390 --> 00:37:17,220
will not have valid bit set.

1119
00:37:18,600 --> 00:37:21,300
And that basically tells, MMU

1120
00:37:21,300 --> 00:37:22,740
well you don't have to chase

1121
00:37:22,740 --> 00:37:25,590
down this PTE, PTE just contains no

1122
00:37:25,590 --> 00:37:26,680
valid information.

1123
00:37:27,820 --> 00:37:30,730
Then "r" means you're allowed

1124
00:37:30,730 --> 00:37:32,590
to read from that page, write

1125
00:37:32,590 --> 00:37:34,330
means you're allowed to write to

1126
00:37:34,330 --> 00:37:35,160
the page.

1127
00:37:35,240 --> 00:37:37,790
Execute means you're allowed to execute

1128
00:37:37,790 --> 00:37:39,040
instruction from it.

1129
00:37:39,330 --> 00:37:41,640
Um, in user, means you

1130
00:37:41,640 --> 00:37:42,810
know this page is

1131
00:37:42,810 --> 00:37:44,640
also accessible by a process

1132
00:37:44,640 --> 00:37:46,440
running in user space.

1133
00:37:47,340 --> 00:37:48,300
And then the other bits you

1134
00:37:48,300 --> 00:37:49,140
not that important,

1135
00:37:49,140 --> 00:37:49,740
it will show up at

1136
00:37:49,740 --> 00:37:51,570
some point, those are sort of five

1137
00:37:51,570 --> 00:37:52,920
define important bits.

1138
00:37:55,970 --> 00:37:57,040
Does that make sense.

1139
00:38:01,740 --> 00:38:03,960
Yeah, Nithya, I'd probably mispronouncing your

1140
00:38:03,960 --> 00:38:06,180
name I apologize to you.

1141
00:38:06,850 --> 00:38:08,440
That's, that's the representation,

1142
00:38:08,440 --> 00:38:09,340
thank you,

1143
00:38:09,340 --> 00:38:11,050
I had a quick question

1144
00:38:11,050 --> 00:38:11,860
about,

1145
00:38:11,860 --> 00:38:13,810
the three page tables,

1146
00:38:13,810 --> 00:38:16,540
so how are the addresses or

1147
00:38:16,540 --> 00:38:19,510
the PPM values combined to form

1148
00:38:19,510 --> 00:38:21,340
the final physical address I might

1149
00:38:21,340 --> 00:38:22,080
miss that.

1150
00:38:22,350 --> 00:38:22,950
Um, yeah,

1151
00:38:22,950 --> 00:38:24,330
well may not say that said it

1152
00:38:24,330 --> 00:38:26,940
very explicitly. So the first

1153
00:38:26,940 --> 00:38:29,340
PPM correcting tops the page table,

1154
00:38:29,340 --> 00:38:30,720
the first PPM in the top

1155
00:38:30,720 --> 00:38:32,200
level page directory.

1156
00:38:32,300 --> 00:38:35,150
And contains the physical address of

1157
00:38:35,150 --> 00:38:36,650
the next level down.

1158
00:38:37,780 --> 00:38:39,820
And one contains the one next

1159
00:38:39,820 --> 00:38:40,960
level down and then in the

1160
00:38:40,960 --> 00:38:43,210
final one we still have are

1161
00:38:43,210 --> 00:38:45,130
[few] 44 bits that contains then

1162
00:38:45,130 --> 00:38:47,110
the actual physical address off the

1163
00:38:47,110 --> 00:38:48,460
page that we're actually trying to

1164
00:38:48,460 --> 00:38:49,540
translate to.

1165
00:38:50,150 --> 00:38:50,900
Um, OK,

1166
00:38:50,900 --> 00:38:51,860
that makes sense, thank you.

1167
00:38:51,860 --> 00:38:53,750
Okay, and one interesting question,

1168
00:38:53,750 --> 00:38:54,860
just let us side note,

1169
00:38:54,860 --> 00:38:56,870
before let me answer my

1170
00:38:56,870 --> 00:38:58,490
own question before answering the

1171
00:38:58,490 --> 00:38:59,690
two raised hands here,

1172
00:38:59,690 --> 00:39:02,030
look back at this picture,

1173
00:39:02,030 --> 00:39:03,920
why, why are the physical page

1174
00:39:03,920 --> 00:39:05,800
numbers stored in these page directories.

1175
00:39:07,810 --> 00:39:09,960
Why not a virtual address.

1176
00:39:11,520 --> 00:39:12,870
Because we need to look it

1177
00:39:12,870 --> 00:39:14,460
up in memory, like look up

1178
00:39:14,460 --> 00:39:16,110
the next directory in memory.

1179
00:39:16,110 --> 00:39:16,800
Yeah right,

1180
00:39:16,800 --> 00:39:18,210
we could not have a

1181
00:39:18,210 --> 00:39:19,770
translation scheme depends on yet

1182
00:39:19,770 --> 00:39:20,940
another translation scheme,

1183
00:39:20,940 --> 00:39:21,780
you know we could sort of,

1184
00:39:21,780 --> 00:39:23,250
recursive intent look, so that

1185
00:39:23,250 --> 00:39:24,380
just doesn't make sense.

1186
00:39:24,620 --> 00:39:26,300
That's exactly the right answer,

1187
00:39:26,300 --> 00:39:26,870
it has to be a

1188
00:39:26,870 --> 00:39:27,590
physical number,

1189
00:39:27,590 --> 00:39:28,730
how about the satp,

1190
00:39:28,730 --> 00:39:29,930
what do you use the satp,

1191
00:39:29,930 --> 00:39:31,130
what does it store it store

1192
00:39:31,130 --> 00:39:32,860
a physical address or a virtual address.

1193
00:39:39,180 --> 00:39:41,340
Um, also physical, assuming that

1194
00:39:41,340 --> 00:39:42,480
the first page directory is

1195
00:39:42,480 --> 00:39:45,570
also memory. Right exactly so

1196
00:39:45,570 --> 00:39:46,080
it has to be a

1197
00:39:46,080 --> 00:39:47,580
physical number because we're actually

1198
00:39:47,580 --> 00:39:48,330
trying to use it for

1199
00:39:48,330 --> 00:39:49,960
translation.

1200
00:39:50,100 --> 00:39:51,390
And, um,

1201
00:39:51,390 --> 00:39:52,560
so you know the satp, you

1202
00:39:52,560 --> 00:39:53,700
need to know what the physical

1203
00:39:53,700 --> 00:39:54,820
page number is.

1204
00:39:54,930 --> 00:39:56,430
Um, on the route of the

1205
00:39:56,430 --> 00:39:57,400
page directory.

1206
00:39:59,170 --> 00:40:00,490
OK, there were two other questions

1207
00:40:00,490 --> 00:40:01,450
or two people who raise their

1208
00:40:01,450 --> 00:40:02,740
hands could do,

1209
00:40:06,120 --> 00:40:08,080
Repeat your question if.

1210
00:40:10,740 --> 00:40:13,260
So there's a hierarchy of three

1211
00:40:13,260 --> 00:40:15,210
tables and each of them is

1212
00:40:15,210 --> 00:40:16,740
indexed by a part of the

1213
00:40:16,740 --> 00:40:17,910
virtual address,

1214
00:40:17,910 --> 00:40:20,260
each nine bits long.

1215
00:40:22,730 --> 00:40:23,840
So I'm not sure

1216
00:40:23,840 --> 00:40:27,260
I understand how chaining between

1217
00:40:27,260 --> 00:40:28,640
them happens and what it's

1218
00:40:28,640 --> 00:40:30,020
meant to accomplish like shouldn't

1219
00:40:30,020 --> 00:40:31,400
it be sufficient to just

1220
00:40:31,400 --> 00:40:33,770
use those three 9 bit

1221
00:40:33,770 --> 00:40:34,910
addresses to index into each

1222
00:40:34,910 --> 00:40:35,540
of them.

1223
00:40:36,800 --> 00:40:37,310
That's correct,

1224
00:40:37,310 --> 00:40:39,110
so the first top level

1225
00:40:39,110 --> 00:40:39,890
nine bits are used to

1226
00:40:39,890 --> 00:40:40,760
mean that in the first

1227
00:40:40,760 --> 00:40:42,320
top page level directory,

1228
00:40:42,320 --> 00:40:43,370
the second and the next

1229
00:40:43,370 --> 00:40:44,300
one and the third in

1230
00:40:44,300 --> 00:40:45,300
the third one.

1231
00:40:48,230 --> 00:40:50,180
So maybe I'm just not understanding

1232
00:40:50,180 --> 00:40:51,020
this correctly,

1233
00:40:51,020 --> 00:40:54,080
so when a process requests

1234
00:40:54,080 --> 00:40:56,510
a certain virtual address to be

1235
00:40:56,510 --> 00:40:57,320
looked up,

1236
00:40:57,320 --> 00:40:58,730
it loads into the

1237
00:40:58,730 --> 00:41:00,410
satp register or the CPU

1238
00:41:00,410 --> 00:41:02,240
does and that,

1239
00:41:02,310 --> 00:41:05,070
get to the corresponding correct highest

1240
00:41:05,070 --> 00:41:07,240
level page table.

1241
00:41:07,640 --> 00:41:10,120
And then that page table.

1242
00:41:10,620 --> 00:41:13,080
will. We used in the top

1243
00:41:13,080 --> 00:41:15,390
level nine bits from the 27

1244
00:41:15,390 --> 00:41:17,380
to index into that page directory.

1245
00:41:18,670 --> 00:41:19,810
And then what is what is

1246
00:41:19,810 --> 00:41:20,830
the result of that,

1247
00:41:20,830 --> 00:41:22,690
like if the result is there's

1248
00:41:22,690 --> 00:41:24,490
nothing there does MMU

1249
00:41:24,490 --> 00:41:26,590
create a page table,

1250
00:41:26,590 --> 00:41:27,310
No, no,

1251
00:41:27,310 --> 00:41:28,900
MMU basically tells the operating

1252
00:41:28,900 --> 00:41:30,700
system or tells the processor,

1253
00:41:30,700 --> 00:41:33,070
sorry I couldn't translate that address,

1254
00:41:33,070 --> 00:41:35,140
and basically turns into a

1255
00:41:35,140 --> 00:41:36,340
page fault which we'll talk about

1256
00:41:36,340 --> 00:41:37,300
a little bit later.

1257
00:41:38,970 --> 00:41:41,370
But just cannot translate the address,

1258
00:41:41,370 --> 00:41:42,630
it doesn't translate it's like you

1259
00:41:42,630 --> 00:41:44,070
know you can't divide by zero,

1260
00:41:44,070 --> 00:41:45,120
you know if you try to

1261
00:41:45,120 --> 00:41:46,740
do that the prosecutor refuses to

1262
00:41:46,740 --> 00:41:47,380
do it.

1263
00:41:50,130 --> 00:41:50,700
I see, OK.

1264
00:41:54,060 --> 00:41:56,940
Brandon, what about you, Brandon.

1265
00:41:56,940 --> 00:41:58,320
Um, so I just wanted to

1266
00:41:58,320 --> 00:42:00,060
make sure I understand how I

1267
00:42:00,060 --> 00:42:03,210
think maybe we want to understand

1268
00:42:03,210 --> 00:42:07,170
how the intermediate page tables well

1269
00:42:07,170 --> 00:42:08,370
how we calculate the physical address

1270
00:42:08,370 --> 00:42:09,320
of those.

1271
00:42:09,550 --> 00:42:10,420
Um, so,

1272
00:42:10,420 --> 00:42:11,980
is it correct that say if

1273
00:42:11,980 --> 00:42:13,570
we're trying to find a second

1274
00:42:13,570 --> 00:42:15,400
level page tables physical address,

1275
00:42:15,400 --> 00:42:17,530
we would take the PPM from

1276
00:42:17,530 --> 00:42:18,850
the first level page table,

1277
00:42:18,850 --> 00:42:20,380
that's 44 bits and then we

1278
00:42:20,380 --> 00:42:22,150
add the 12 bit offset from

1279
00:42:22,150 --> 00:42:23,440
the original virtual address to get

1280
00:42:23,440 --> 00:42:25,060
the full 56 bit, this question

1281
00:42:25,060 --> 00:42:27,040
is. We don't add the offset

1282
00:42:27,040 --> 00:42:28,000
from the virtual address,

1283
00:42:28,000 --> 00:42:30,160
we just take twelve zero bits.

1284
00:42:30,970 --> 00:42:31,960
So we take the PPM

1285
00:42:31,960 --> 00:42:34,000
there's 44 bits. Okay, 12

1286
00:42:34,000 --> 00:42:35,530
zero bits on the bottom

1287
00:42:35,530 --> 00:42:36,580
and that gives us a

1288
00:42:36,580 --> 00:42:38,620
56 bit physical address and

1289
00:42:38,620 --> 00:42:39,490
that's where the next page

1290
00:42:39,490 --> 00:42:39,670
directories,

1291
00:42:39,670 --> 00:42:41,530
and this requires that basically every

1292
00:42:41,530 --> 00:42:43,800
page directories page aligned.

1293
00:42:45,460 --> 00:42:46,330
I see,

1294
00:42:46,330 --> 00:42:48,300
OK, that makes sense.

1295
00:42:49,890 --> 00:42:50,880
So these are all great questions

1296
00:42:50,880 --> 00:42:51,570
and these are all things,

1297
00:42:51,570 --> 00:42:52,620
you're gonna be struggling within the

1298
00:42:52,620 --> 00:42:53,960
page table lab so.

1299
00:42:54,020 --> 00:42:55,100
Yeah it's very good to ask

1300
00:42:55,100 --> 00:42:56,100
them right now.

1301
00:42:59,990 --> 00:43:01,160
Okay, um,

1302
00:43:01,160 --> 00:43:01,970
let me see,

1303
00:43:04,410 --> 00:43:06,600
Yes, yeah okay,

1304
00:43:06,600 --> 00:43:08,220
let me hold on for

1305
00:43:08,220 --> 00:43:09,040
a second.

1306
00:43:09,640 --> 00:43:11,180
And I quote my thoughts.

1307
00:43:11,730 --> 00:43:14,260
Um I see where I am.

1308
00:43:16,320 --> 00:43:16,800
Good good,

1309
00:43:16,800 --> 00:43:17,850
good, okay,

1310
00:43:17,850 --> 00:43:20,130
one a sort of a you

1311
00:43:20,130 --> 00:43:21,600
know one other thing that I

1312
00:43:21,600 --> 00:43:23,550
want to mention because you will

1313
00:43:23,550 --> 00:43:25,770
see that, is that if

1314
00:43:25,770 --> 00:43:27,390
we think about this,

1315
00:43:27,390 --> 00:43:28,290
you know the scheme that I

1316
00:43:28,290 --> 00:43:29,460
just showed right,

1317
00:43:29,460 --> 00:43:30,660
um what really seems to be

1318
00:43:30,660 --> 00:43:32,400
going on is that we load

1319
00:43:32,400 --> 00:43:34,440
or store value to memory.

1320
00:43:34,480 --> 00:43:35,920
Where the processor loads or stores

1321
00:43:35,920 --> 00:43:36,790
value memory,

1322
00:43:36,790 --> 00:43:37,930
we basically have to do free

1323
00:43:37,930 --> 00:43:39,310
memory lookups, right,

1324
00:43:39,310 --> 00:43:40,660
one in the top of the

1325
00:43:40,660 --> 00:43:41,230
page directory,

1326
00:43:41,230 --> 00:43:42,430
one intermediate page

1327
00:43:42,430 --> 00:43:43,840
directory and then one in the

1328
00:43:43,840 --> 00:43:45,280
bottom level page directory.

1329
00:43:45,500 --> 00:43:46,880
It looks like, that you know

1330
00:43:46,880 --> 00:43:49,010
any memory reference to virtual address

1331
00:43:49,010 --> 00:43:51,820
basically requires free memory to reach.

1332
00:43:52,380 --> 00:43:54,000
And so that seems expensive.

1333
00:43:54,530 --> 00:43:55,700
Um, and so,

1334
00:43:55,700 --> 00:43:57,980
um, what happens in practice where

1335
00:43:57,980 --> 00:43:59,690
almost all every processor does this,

1336
00:43:59,690 --> 00:44:00,980
it has a cache sitting

1337
00:44:00,980 --> 00:44:02,570
on the side, that contains

1338
00:44:02,570 --> 00:44:04,400
recently used translations.

1339
00:44:05,300 --> 00:44:07,240
And this is called translation look-aside buffer.

1340
00:44:11,800 --> 00:44:13,540
Then you'll see that term

1341
00:44:14,400 --> 00:44:17,640
quite often, of TLB.

1342
00:44:18,400 --> 00:44:19,900
Basically it's nothing else than

1343
00:44:19,900 --> 00:44:20,840
the cache of

1344
00:44:22,500 --> 00:44:24,090
entry, page table entries,

1345
00:44:24,090 --> 00:44:25,260
PTE entries.

1346
00:44:28,170 --> 00:44:29,670
So when the process has you

1347
00:44:29,670 --> 00:44:30,720
know the first time the process

1348
00:44:30,720 --> 00:44:32,100
routes look through virtual address,

1349
00:44:32,100 --> 00:44:34,440
you know walks this, hardware

1350
00:44:34,440 --> 00:44:37,140
walks this page, the the three

1351
00:44:37,140 --> 00:44:38,940
level page tables, that will come

1352
00:44:38,940 --> 00:44:40,470
out with you know the final

1353
00:44:40,470 --> 00:44:42,750
physical page, often called PPN,

1354
00:44:42,750 --> 00:44:44,520
for that particular virtual address,

1355
00:44:44,520 --> 00:44:46,320
and then basically the

1356
00:44:46,320 --> 00:44:47,160
TLB stores,

1357
00:44:47,160 --> 00:44:49,440
VA, PA, PN,

1358
00:44:49,980 --> 00:44:52,950
or PA mapping

1359
00:44:52,950 --> 00:44:53,900
on the side.

1360
00:44:53,930 --> 00:44:54,320
And so,

1361
00:44:54,320 --> 00:44:55,670
then the next time you refer

1362
00:44:55,670 --> 00:44:57,520
to that particular virtual address.

1363
00:44:57,490 --> 00:44:58,780
I can just look at straight

1364
00:44:58,780 --> 00:45:00,490
up in the TLB and the

1365
00:45:00,490 --> 00:45:02,290
TLB will respond instead of having

1366
00:45:02,290 --> 00:45:03,580
to do the page table walk.

1367
00:45:05,300 --> 00:45:07,400
Um, yep, Amiar.

1368
00:45:09,700 --> 00:45:13,260
So, the TLB map

1369
00:45:13,490 --> 00:45:16,010
virtual addresses to the physical address

1370
00:45:16,010 --> 00:45:17,960
of the page that the virtual

1371
00:45:17,960 --> 00:45:20,690
address along with the offset you're

1372
00:45:20,690 --> 00:45:22,490
absolutely right,

1373
00:45:22,490 --> 00:45:24,290
wouldn't it be more efficient

1374
00:45:24,290 --> 00:45:25,520
to like cache at the

1375
00:45:25,520 --> 00:45:27,060
page table level.

1376
00:45:27,770 --> 00:45:30,290
Um, okay so I let me

1377
00:45:30,290 --> 00:45:31,400
take a step back here,

1378
00:45:31,400 --> 00:45:33,020
um, there are many ways of

1379
00:45:33,020 --> 00:45:34,550
implementing the TLB,

1380
00:45:34,550 --> 00:45:35,930
um, the most important thing that

1381
00:45:35,930 --> 00:45:36,710
you need to know is that

1382
00:45:36,710 --> 00:45:37,760
there is a TLB.

1383
00:45:38,230 --> 00:45:40,300
Um, and the exact details

1384
00:45:40,300 --> 00:45:41,410
of actually how the TLB

1385
00:45:41,410 --> 00:45:42,430
has implemented, this sort of

1386
00:45:42,430 --> 00:45:43,690
you know not a topic

1387
00:45:43,690 --> 00:45:44,590
that we're going to talk

1388
00:45:44,590 --> 00:45:45,490
about in great amount of

1389
00:45:45,490 --> 00:45:46,260
detail.

1390
00:45:46,400 --> 00:45:47,930
Um, that's not at all,

1391
00:45:47,930 --> 00:45:49,520
um, and so this is really

1392
00:45:49,520 --> 00:45:50,900
something that sits inside of the

1393
00:45:50,900 --> 00:45:52,400
processor and is mostly hidden from

1394
00:45:52,400 --> 00:45:53,120
the operating system,

1395
00:45:53,120 --> 00:45:54,470
the operating system doesn't really know

1396
00:45:54,470 --> 00:45:57,020
how to TLB be operates, the

1397
00:45:57,020 --> 00:45:58,190
only thing the reason you need

1398
00:45:58,190 --> 00:45:59,180
to know that the TLB

1399
00:45:59,180 --> 00:46:01,550
exist is that if you switch

1400
00:46:01,550 --> 00:46:02,620
page tables.

1401
00:46:03,710 --> 00:46:06,470
Then, typically the operating system needs

1402
00:46:06,470 --> 00:46:08,960
to tell the processor that's switching

1403
00:46:08,960 --> 00:46:10,140
page tables.

1404
00:46:10,760 --> 00:46:12,560
And the

1405
00:46:12,950 --> 00:46:14,740
TLB needs to be flushed.

1406
00:46:16,810 --> 00:46:18,070
Because basically you send you

1407
00:46:18,070 --> 00:46:18,820
stale entries,

1408
00:46:18,820 --> 00:46:19,660
but if you switch to a

1409
00:46:19,660 --> 00:46:20,890
new page table,

1410
00:46:20,890 --> 00:46:22,360
the entries in the TLB may

1411
00:46:22,360 --> 00:46:24,130
not be valid anymore and so

1412
00:46:24,130 --> 00:46:25,840
they need to be removed because

1413
00:46:25,840 --> 00:46:27,370
otherwise you know the translation would

1414
00:46:27,370 --> 00:46:28,240
be incorrect.

1415
00:46:28,830 --> 00:46:30,540
And so the operating system is

1416
00:46:30,540 --> 00:46:32,100
typically where

1417
00:46:32,260 --> 00:46:33,340
it's aware that there's a,

1418
00:46:33,340 --> 00:46:34,960
that there is a TLB

1419
00:46:34,960 --> 00:46:36,880
only basically to tell the

1420
00:46:36,880 --> 00:46:37,990
hardware once in a while saying,

1421
00:46:37,990 --> 00:46:39,700
okay well don't use them anymore,

1422
00:46:39,700 --> 00:46:41,740
because I'm gonna switch page tables.

1423
00:46:44,140 --> 00:46:45,820
And in fact on you know

1424
00:46:45,820 --> 00:46:50,350
the, the RISC-V, the instruction

1425
00:46:50,350 --> 00:46:51,880
to flush the TLB is called

1426
00:46:51,880 --> 00:46:55,200
sfence_vma.

1427
00:46:57,280 --> 00:46:59,080
I'm not actually.

1428
00:46:59,750 --> 00:47:02,100
Flush the TLB. [Biback].

1429
00:47:04,770 --> 00:47:06,000
So I have a question,

1430
00:47:06,000 --> 00:47:08,190
like not regarding TLB

1431
00:47:08,190 --> 00:47:10,110
but that brought kind

1432
00:47:10,110 --> 00:47:11,820
of this question.

1433
00:47:11,970 --> 00:47:14,970
The three level support, that the

1434
00:47:14,970 --> 00:47:17,820
three level paging that we have,

1435
00:47:17,820 --> 00:47:19,710
is it implemented by the operating

1436
00:47:19,710 --> 00:47:21,690
system or the hardware itself. It

1437
00:47:21,690 --> 00:47:23,060
implemented in hardware.

1438
00:47:23,450 --> 00:47:24,830
So you know there's all happens

1439
00:47:24,830 --> 00:47:25,670
in hardware,

1440
00:47:25,670 --> 00:47:27,500
the MMU is a block

1441
00:47:27,500 --> 00:47:28,460
of hardware.

1442
00:47:28,730 --> 00:47:30,440
In the operating system we'll

1443
00:47:30,440 --> 00:47:32,120
see in a second when we

1444
00:47:32,120 --> 00:47:34,190
look at xv6, xv6

1445
00:47:34,190 --> 00:47:36,320
has a function that models the

1446
00:47:36,320 --> 00:47:37,640
page table walk, because once in

1447
00:47:37,640 --> 00:47:39,260
a while you know xv6

1448
00:47:39,260 --> 00:47:40,430
basically has to do what the

1449
00:47:40,430 --> 00:47:41,360
hardware does.

1450
00:47:42,040 --> 00:47:43,570
Um, and so it knows

1451
00:47:43,570 --> 00:47:44,380
it doesn't have a function

1452
00:47:44,380 --> 00:47:45,970
called walk, that basically does

1453
00:47:45,970 --> 00:47:47,560
exactly the same thing,

1454
00:47:47,560 --> 00:47:48,900
but in software.

1455
00:47:51,360 --> 00:47:54,510
So, can I ask a question?

1456
00:47:54,510 --> 00:47:56,140
So um,

1457
00:47:56,660 --> 00:47:58,670
where in this scheme does the

1458
00:47:58,670 --> 00:48:00,170
processor cache fit,

1459
00:48:00,170 --> 00:48:02,510
does it happen before the address

1460
00:48:02,510 --> 00:48:04,300
translation or after,

1461
00:48:04,510 --> 00:48:06,700
because. Yeah, okay let me so

1462
00:48:06,700 --> 00:48:07,840
let's switch back a little bit

1463
00:48:07,840 --> 00:48:10,800
a couple, let me see.

1464
00:48:13,120 --> 00:48:14,980
Okay, usually MMU will

1465
00:48:14,980 --> 00:48:17,170
really the way to think about

1466
00:48:17,170 --> 00:48:18,720
is that all this stuff.

1467
00:48:19,870 --> 00:48:21,220
You know the whole block is

1468
00:48:21,220 --> 00:48:22,900
inside the processor silicon.

1469
00:48:24,350 --> 00:48:25,310
So there's a RISC-V

1470
00:48:25,310 --> 00:48:27,080
chip and inside of it

1471
00:48:27,080 --> 00:48:27,920
is the CPU,

1472
00:48:27,920 --> 00:48:29,270
in fact there are multiple CPU

1473
00:48:29,270 --> 00:48:30,640
correct, there 4 cores.

1474
00:48:30,740 --> 00:48:32,240
And there's a MMU

1475
00:48:32,240 --> 00:48:33,500
and you know you can think

1476
00:48:33,500 --> 00:48:34,040
about that,

1477
00:48:34,040 --> 00:48:35,150
either on this on the

1478
00:48:35,150 --> 00:48:35,990
CPU side,

1479
00:48:35,990 --> 00:48:37,780
you know there's a TLB.

1480
00:48:44,460 --> 00:48:45,210
That makes sense,

1481
00:48:45,210 --> 00:48:47,190
um, but I guess my question

1482
00:48:47,190 --> 00:48:48,560
was about the like,

1483
00:48:48,700 --> 00:48:51,550
cache in terms of not

1484
00:48:51,550 --> 00:48:52,120
the TLB,

1485
00:48:52,120 --> 00:48:55,000
but just a normal cache like,

1486
00:48:55,000 --> 00:48:56,290
sometimes we don't actually go all

1487
00:48:56,290 --> 00:48:58,000
the way to access the memory.

1488
00:48:58,000 --> 00:48:59,470
Yeah, good points I think I

1489
00:48:59,470 --> 00:49:00,850
should like to scheme last week

1490
00:49:00,850 --> 00:49:02,590
correctly on monday of the RISC-V

1491
00:49:02,590 --> 00:49:04,300
processor and has now one cache

1492
00:49:04,300 --> 00:49:05,700
it has two cache.

1493
00:49:05,970 --> 00:49:08,100
Some caches are indexed by physical

1494
00:49:08,100 --> 00:49:10,530
address, some caches are indexed by

1495
00:49:10,530 --> 00:49:11,540
virtual address.

1496
00:49:11,800 --> 00:49:13,030
So the caches that are indexed

1497
00:49:13,030 --> 00:49:15,280
by virtual address sit before the

1498
00:49:15,280 --> 00:49:16,160
MMU.

1499
00:49:16,540 --> 00:49:17,800
And cache in their index by

1500
00:49:17,800 --> 00:49:19,820
physical addresses after the MMU.

1501
00:49:25,010 --> 00:49:25,820
Does that make sense?

1502
00:49:25,820 --> 00:49:27,410
Can I also ask a question

1503
00:49:27,410 --> 00:49:28,850
my question is,

1504
00:49:28,850 --> 00:49:31,760
you said that the TLB,

1505
00:49:31,760 --> 00:49:33,470
it walks so I like to

1506
00:49:33,470 --> 00:49:34,880
put stuff into TLB,

1507
00:49:34,880 --> 00:49:37,310
the hardware walks through the

1508
00:49:37,310 --> 00:49:38,600
page tables.

1509
00:49:39,830 --> 00:49:42,380
Why do we arrive walk function,

1510
00:49:42,380 --> 00:49:44,400
if hardware can do that.

1511
00:49:44,560 --> 00:49:45,790
Very good question,

1512
00:49:45,790 --> 00:49:48,220
um, one reason we have, a

1513
00:49:48,220 --> 00:49:49,270
couple of reasons why we do

1514
00:49:49,270 --> 00:49:51,370
it or why xv6 needs it,

1515
00:49:51,370 --> 00:49:52,630
one is when it actually sets

1516
00:49:52,630 --> 00:49:54,160
up the initial page tables.

1517
00:49:54,980 --> 00:49:56,360
Um, you know it needs to

1518
00:49:56,360 --> 00:49:58,560
program the the three levels.

1519
00:49:58,680 --> 00:49:59,940
And so it needs to basically

1520
00:49:59,940 --> 00:50:01,420
emulate the three levels.

1521
00:50:02,120 --> 00:50:03,980
Um, and um,

1522
00:50:03,980 --> 00:50:05,090
another example,

1523
00:50:05,090 --> 00:50:06,740
that you actually sort of run

1524
00:50:06,740 --> 00:50:08,630
into or are running into in

1525
00:50:08,630 --> 00:50:10,550
the syscall lab is that when

1526
00:50:10,550 --> 00:50:12,680
you copy the xv6, the

1527
00:50:12,680 --> 00:50:14,540
kernel has its own page table

1528
00:50:14,540 --> 00:50:16,550
and every user address space has

1529
00:50:16,550 --> 00:50:17,700
its own page table.

1530
00:50:18,140 --> 00:50:19,580
And with once in a while,

1531
00:50:19,580 --> 00:50:21,620
for example it says info go like

1532
00:50:21,620 --> 00:50:23,510
system, pointed to system infrastructure,

1533
00:50:23,510 --> 00:50:24,440
you know that lives in

1534
00:50:24,440 --> 00:50:25,460
user space.

1535
00:50:25,610 --> 00:50:27,260
The kernel needs to be translated

1536
00:50:27,260 --> 00:50:28,460
to an address that it can

1537
00:50:28,460 --> 00:50:29,760
use to write it.

1538
00:50:30,340 --> 00:50:31,120
And so,

1539
00:50:31,120 --> 00:50:32,710
for example if you're looking copy

1540
00:50:32,710 --> 00:50:34,600
in or copy out.

1541
00:50:34,730 --> 00:50:38,480
Um, basically the kernel translates the

1542
00:50:38,480 --> 00:50:41,420
user virtual address using the user

1543
00:50:41,420 --> 00:50:44,030
virtual, using a user page

1544
00:50:44,030 --> 00:50:45,410
table to get out of physical

1545
00:50:45,410 --> 00:50:46,520
address that that kernel,

1546
00:50:46,520 --> 00:50:49,760
then get an address out,

1547
00:50:49,760 --> 00:50:51,050
actually the kernel can use to

1548
00:50:51,050 --> 00:50:52,220
read and write that memory.

1549
00:50:54,580 --> 00:50:55,390
So there's a bunch of places

1550
00:50:55,390 --> 00:50:56,800
going to show up and I'll

1551
00:50:56,800 --> 00:50:58,630
talk about hopefully in whatever ten

1552
00:50:58,630 --> 00:51:00,000
minutes or fifteen minutes.

1553
00:51:00,610 --> 00:51:01,720
I have a question,

1554
00:51:01,720 --> 00:51:05,350
why doesn't the hardware like expose

1555
00:51:05,350 --> 00:51:06,430
that walk function,

1556
00:51:06,430 --> 00:51:07,300
so we don't have to write

1557
00:51:07,300 --> 00:51:08,890
our own and potentially have bugs

1558
00:51:08,890 --> 00:51:09,430
in it,

1559
00:51:09,430 --> 00:51:11,740
why isn't there like, maybe

1560
00:51:11,740 --> 00:51:12,970
a privileged instruction that you can

1561
00:51:12,970 --> 00:51:14,290
pass a virtual address and will

1562
00:51:14,290 --> 00:51:16,120
give back the physical address.

1563
00:51:16,370 --> 00:51:17,690
Well, this is just like just

1564
00:51:17,690 --> 00:51:18,770
store to the virtual address,

1565
00:51:18,770 --> 00:51:20,480
you get back and we'll do

1566
00:51:20,480 --> 00:51:21,740
it right for you,

1567
00:51:21,740 --> 00:51:23,450
um, so I will see

1568
00:51:23,450 --> 00:51:24,380
later on,

1569
00:51:24,380 --> 00:51:26,750
in the next lab,

1570
00:51:26,750 --> 00:51:27,890
the page table lab,

1571
00:51:27,890 --> 00:51:29,090
in fact is exactly what you'll

1572
00:51:29,090 --> 00:51:30,650
be doing you'll actually set up

1573
00:51:30,650 --> 00:51:32,240
the page table slightly differently,

1574
00:51:32,240 --> 00:51:33,440
so that you can avoid the

1575
00:51:33,440 --> 00:51:36,980
walk in or copyin and copyinstr.

1576
00:51:42,500 --> 00:51:43,640
I think this will become clear

1577
00:51:43,640 --> 00:51:44,780
in the second we when we

1578
00:51:44,780 --> 00:51:45,590
talk about we look at the

1579
00:51:45,590 --> 00:51:46,960
xv6, OK.

1580
00:51:49,700 --> 00:51:51,400
Okay, good.

1581
00:51:51,800 --> 00:51:54,260
One more sure basically before jumping

1582
00:51:54,260 --> 00:51:56,060
into xv6, I wanted to make

1583
00:51:56,060 --> 00:51:57,400
one point.

1584
00:51:57,540 --> 00:52:00,060
One way to think about,

1585
00:52:00,060 --> 00:52:01,770
um, you know,

1586
00:52:03,150 --> 00:52:04,200
page tables.

1587
00:52:05,980 --> 00:52:07,390
A popular way

1588
00:52:07,390 --> 00:52:07,870
to phrase,

1589
00:52:07,870 --> 00:52:09,720
this um.

1590
00:52:09,930 --> 00:52:13,040
It's the page tables provide

1591
00:52:13,300 --> 00:52:14,980
a level of indirection.

1592
00:52:25,100 --> 00:52:27,140
And, that and, so basically

1593
00:52:27,140 --> 00:52:27,890
this indirection,

1594
00:52:27,890 --> 00:52:28,880
what I'm talking about you know

1595
00:52:28,880 --> 00:52:30,200
this mapping from virtual address to

1596
00:52:30,200 --> 00:52:31,260
physical address.

1597
00:52:31,490 --> 00:52:33,440
And this mapping is completely

1598
00:52:33,440 --> 00:52:34,700
under control

1599
00:52:35,130 --> 00:52:36,500
of the operating system.

1600
00:52:38,350 --> 00:52:40,720
As we've seen, you know in the last

1601
00:52:40,720 --> 00:52:41,350
a couple slides that

1602
00:52:41,350 --> 00:52:42,280
we talk,

1603
00:52:42,280 --> 00:52:43,780
um, and that means that the

1604
00:52:43,780 --> 00:52:45,640
operating system because it has so

1605
00:52:45,640 --> 00:52:46,540
much control,

1606
00:52:46,540 --> 00:52:48,520
it has control complete control that

1607
00:52:48,520 --> 00:52:50,740
translation, it can do all

1608
00:52:50,740 --> 00:52:52,060
kinds of interesting tricks.

1609
00:52:52,660 --> 00:52:54,370
Um, and so for example, like

1610
00:52:54,370 --> 00:52:56,260
one trick, talk a little

1611
00:52:56,260 --> 00:52:56,860
bit about this,

1612
00:52:56,860 --> 00:52:58,630
like if a page, page entry is

1613
00:52:58,630 --> 00:53:00,790
invalid and will really return a

1614
00:53:00,790 --> 00:53:02,200
page you know the hardware will

1615
00:53:02,200 --> 00:53:04,440
raise page fault.

1616
00:53:04,820 --> 00:53:05,510
In response,

1617
00:53:05,510 --> 00:53:06,530
the page fault,

1618
00:53:06,530 --> 00:53:08,150
the operating system could update

1619
00:53:08,150 --> 00:53:09,410
the page tables and then

1620
00:53:09,410 --> 00:53:11,120
maybe restart the instruction.

1621
00:53:11,620 --> 00:53:12,640
And so there are all kinds

1622
00:53:12,640 --> 00:53:14,230
of things they can do, at

1623
00:53:14,230 --> 00:53:17,620
runtime, and by manipulating

1624
00:53:17,620 --> 00:53:18,740
the page tables.

1625
00:53:19,160 --> 00:53:20,660
And we're not going to talk

1626
00:53:20,660 --> 00:53:22,070
about it to today,

1627
00:53:22,070 --> 00:53:23,300
but in two weeks,

1628
00:53:23,300 --> 00:53:25,880
we'll have a lecture exactly about

1629
00:53:25,880 --> 00:53:27,680
this topic about what cool things

1630
00:53:27,680 --> 00:53:28,970
can you do once you have

1631
00:53:28,970 --> 00:53:30,420
page tables and page faults.

1632
00:53:31,170 --> 00:53:32,430
Um, but it's important to keep

1633
00:53:32,430 --> 00:53:35,310
in mind that this is

1634
00:53:35,310 --> 00:53:38,480
incredibly powerful mechanism.

1635
00:53:38,540 --> 00:53:39,230
Um that,

1636
00:53:39,230 --> 00:53:40,820
will provide the operating system

1637
00:53:40,820 --> 00:53:42,700
with a tremendous amount of flexibility.

1638
00:53:43,420 --> 00:53:44,890
And there's one reason why page

1639
00:53:44,890 --> 00:53:46,520
tables are so popular.

1640
00:53:49,520 --> 00:53:50,780
Okay, so what I wanna do

1641
00:53:50,780 --> 00:53:53,960
next is actually talk about xv6.

1642
00:53:54,570 --> 00:53:56,550
Um, sort of see how

1643
00:53:56,550 --> 00:53:59,240
it all plays out in xv6.

1644
00:53:59,600 --> 00:54:00,500
So the first thing I'm gonna

1645
00:54:00,500 --> 00:54:02,060
do, is going to look

1646
00:54:02,060 --> 00:54:05,000
at the kernel page layout,

1647
00:54:05,000 --> 00:54:08,380
if you will, and

1648
00:54:08,430 --> 00:54:10,200
the mapping is on this slide,

1649
00:54:10,200 --> 00:54:11,560
so here's the

1650
00:54:12,080 --> 00:54:13,680
virtual address space

1651
00:54:19,860 --> 00:54:21,900
of the kernel.

1652
00:54:23,470 --> 00:54:24,070
Here is,

1653
00:54:24,070 --> 00:54:25,390
actually the physical memory,

1654
00:54:25,390 --> 00:54:27,040
so this is basically whatever you

1655
00:54:27,040 --> 00:54:28,580
can think about this is DRAM.

1656
00:54:31,760 --> 00:54:33,470
And in fact it is not,

1657
00:54:33,470 --> 00:54:35,870
let me take that back immediately

1658
00:54:35,870 --> 00:54:37,780
one part is DRAM.

1659
00:54:38,560 --> 00:54:40,090
And one part is actually

1660
00:54:40,090 --> 00:54:41,440
IO devices.

1661
00:54:46,060 --> 00:54:46,990
Um, and so,

1662
00:54:46,990 --> 00:54:48,970
to sort of maybe, I'm

1663
00:54:48,970 --> 00:54:50,050
going to talk about the physical,

1664
00:54:50,050 --> 00:54:51,400
the right side of the slide a

1665
00:54:51,400 --> 00:54:52,330
little bit first and then we'll

1666
00:54:52,330 --> 00:54:53,320
talk about the left side in

1667
00:54:53,320 --> 00:54:54,020
the second.

1668
00:54:54,310 --> 00:54:55,450
So the left side of

1669
00:54:55,450 --> 00:54:57,700
the slide is completely determined

1670
00:54:57,700 --> 00:54:58,520
by the hardware.

1671
00:54:58,930 --> 00:55:00,670
Um, and so the hardware designers

1672
00:55:00,670 --> 00:55:02,620
basically determined the layout of that

1673
00:55:02,620 --> 00:55:04,270
fit and you know as you saw

1674
00:55:04,270 --> 00:55:05,580
before last week.

1675
00:55:05,640 --> 00:55:08,070
When the kernel starts,

1676
00:55:08,070 --> 00:55:11,060
it starts at this address 0x8000.

1677
00:55:11,740 --> 00:55:13,900
Um, and that's determined by the

1678
00:55:13,900 --> 00:55:15,000
hardware designers.

1679
00:55:15,130 --> 00:55:17,380
Um, and so you should be

1680
00:55:17,380 --> 00:55:18,370
more explicit,

1681
00:55:18,370 --> 00:55:19,810
um, if you look at

1682
00:55:19,810 --> 00:55:20,500
the board,

1683
00:55:20,500 --> 00:55:21,490
this is the same picture of

1684
00:55:21,490 --> 00:55:22,990
the board, that I showed on

1685
00:55:22,990 --> 00:55:24,190
monday but is hopefully a little

1686
00:55:24,190 --> 00:55:25,240
better picture,

1687
00:55:25,240 --> 00:55:26,290
it's easy to see,

1688
00:55:26,290 --> 00:55:28,260
here's our RISC-V processor.

1689
00:55:28,420 --> 00:55:29,650
And we now know correct in

1690
00:55:29,650 --> 00:55:30,640
the RISC-V processor,

1691
00:55:30,640 --> 00:55:32,230
there four cores, but there's also,

1692
00:55:32,230 --> 00:55:33,220
MMU.

1693
00:55:33,280 --> 00:55:35,650
And there's also a TLB or

1694
00:55:35,650 --> 00:55:37,330
multiple TLB, every core has its

1695
00:55:37,330 --> 00:55:38,890
own MMU and every

1696
00:55:38,890 --> 00:55:40,400
core has its own TLB.

1697
00:55:40,800 --> 00:55:42,880
And here are DRAM chips.

1698
00:55:43,780 --> 00:55:46,240
And so basically the designers of

1699
00:55:46,240 --> 00:55:47,890
the board have decided that,

1700
00:55:47,890 --> 00:55:50,800
when, you know, after, you

1701
00:55:50,800 --> 00:55:52,300
know, the translation from virtual to

1702
00:55:52,300 --> 00:55:54,670
physical address basic physical addresses that's

1703
00:55:54,670 --> 00:55:56,620
starting you know at 08,

1704
00:55:56,620 --> 00:55:58,420
you know, a lot of zeros actually go to

1705
00:55:58,420 --> 00:55:59,540
the dram chips.

1706
00:56:00,770 --> 00:56:03,350
Addresses above below 0a8, may go

1707
00:56:03,350 --> 00:56:04,900
to different IO devices.

1708
00:56:05,260 --> 00:56:07,690
And so the platform decides

1709
00:56:07,690 --> 00:56:10,120
basically the designers this board have

1710
00:56:10,120 --> 00:56:12,300
decided exactly what the physical layout.

1711
00:56:12,760 --> 00:56:13,720
I think you can look that

1712
00:56:13,720 --> 00:56:14,800
up the physical layout,

1713
00:56:14,800 --> 00:56:16,390
if you want to adjust,

1714
00:56:16,390 --> 00:56:17,710
let me show you so here's

1715
00:56:17,710 --> 00:56:19,420
the same manual that I showed

1716
00:56:19,420 --> 00:56:20,600
you on, um,

1717
00:56:21,990 --> 00:56:23,060
on um,

1718
00:56:24,230 --> 00:56:26,210
on um, Monday and if you

1719
00:56:26,210 --> 00:56:28,940
go to actually,

1720
00:56:29,510 --> 00:56:30,860
go to page,

1721
00:56:30,860 --> 00:56:32,360
31 I believe.

1722
00:56:32,820 --> 00:56:35,520
Yeah it's a page and

1723
00:56:35,520 --> 00:56:36,150
if you go down,

1724
00:56:36,150 --> 00:56:37,530
this is whats the memory,

1725
00:56:37,530 --> 00:56:39,000
it will spell out the memory

1726
00:56:39,000 --> 00:56:42,150
map is, of the  board

1727
00:56:42,150 --> 00:56:43,530
and we'll see at address zero

1728
00:56:43,530 --> 00:56:45,700
zero is reserved nothing is there.

1729
00:56:46,000 --> 00:56:48,940
Um, if you go scroll down

1730
00:56:48,940 --> 00:56:49,990
in this memory map,

1731
00:56:49,990 --> 00:56:52,810
you'll see some information about all

1732
00:56:52,810 --> 00:56:54,100
the different things that are mapped,

1733
00:56:54,100 --> 00:56:56,500
for example, ethernet board is mapped

1734
00:56:56,500 --> 00:56:58,300
at Ox1, you know,

1735
00:56:58,300 --> 00:56:59,440
0x something.

1736
00:57:00,040 --> 00:57:02,320
Um, if you might go further

1737
00:57:02,320 --> 00:57:04,940
down, oops, too much down.

1738
00:57:05,040 --> 00:57:05,910
Um, here,

1739
00:57:05,910 --> 00:57:08,100
you see the entry for

1740
00:57:08,100 --> 00:57:10,740
0x8000 worked

1741
00:57:10,740 --> 00:57:13,260
and that actually is DDR memory,

1742
00:57:13,260 --> 00:57:15,180
the Off-Chip Volatile Memory, so

1743
00:57:15,180 --> 00:57:16,500
those are the DRAM chips or

1744
00:57:16,500 --> 00:57:17,250
I can show you on the

1745
00:57:17,250 --> 00:57:18,220
previous slide.

1746
00:57:19,520 --> 00:57:20,390
And so it's just good

1747
00:57:20,390 --> 00:57:21,380
to keep your head correct

1748
00:57:21,380 --> 00:57:22,370
even though we're talking to

1749
00:57:22,370 --> 00:57:24,350
QEMU, you're overseeing software in

1750
00:57:24,350 --> 00:57:26,030
the end everything is determined,

1751
00:57:26,030 --> 00:57:27,590
by you know the actual

1752
00:57:27,590 --> 00:57:28,300
board.

1753
00:57:30,640 --> 00:57:33,520
Okay, so go back to a

1754
00:57:33,520 --> 00:57:34,520
my slides.

1755
00:57:34,780 --> 00:57:36,380
Um, so let's look at the

1756
00:57:37,270 --> 00:57:39,370
layout. Yeah, Noah,

1757
00:57:39,370 --> 00:57:40,160
go ahead.

1758
00:57:41,380 --> 00:57:42,760
Yeah, when you say that this

1759
00:57:42,760 --> 00:57:43,810
this layout is determined by the

1760
00:57:43,810 --> 00:57:45,850
hardware, do you specifically mean

1761
00:57:45,850 --> 00:57:48,370
like the CPU itself or the

1762
00:57:48,370 --> 00:57:50,800
board on which the CPU resides.

1763
00:57:50,800 --> 00:57:52,390
The board which should be resides,

1764
00:57:52,390 --> 00:57:54,010
correct. Because you're going to deport,

1765
00:57:54,010 --> 00:57:55,480
you know, the CPU is the

1766
00:57:55,480 --> 00:57:56,770
grey thing in the middle that

1767
00:57:56,770 --> 00:57:59,470
square thing, saying whatever RISC-V

1768
00:57:59,470 --> 00:58:01,660
the dram chips are sitting off,

1769
00:58:01,660 --> 00:58:04,600
the off the processor correct, it's

1770
00:58:04,600 --> 00:58:06,070
the board designers who put the

1771
00:58:06,070 --> 00:58:08,500
chip the dram, you know, do many

1772
00:58:08,500 --> 00:58:10,160
IO devices altogether.

1773
00:58:11,600 --> 00:58:13,430
And make a large part of

1774
00:58:13,430 --> 00:58:14,720
an operating system is actually,

1775
00:58:14,720 --> 00:58:16,130
you know the cpu is one part, but the

1776
00:58:16,130 --> 00:58:17,270
IO devices are at least as

1777
00:58:17,270 --> 00:58:19,040
important, right and so when you're

1778
00:58:19,040 --> 00:58:20,720
writing an operating system you both

1779
00:58:20,720 --> 00:58:21,860
have to deal with the CPU

1780
00:58:21,860 --> 00:58:22,790
as well as you know with

1781
00:58:22,790 --> 00:58:23,690
the IO devices,

1782
00:58:23,690 --> 00:58:24,500
you know and you want to

1783
00:58:24,500 --> 00:58:25,860
send a packet over the Internet.

1784
00:58:25,930 --> 00:58:27,380
Well, somebody has to

1785
00:58:28,800 --> 00:58:29,370
take over.

1786
00:58:29,370 --> 00:58:30,450
You know the network driver,

1787
00:58:30,450 --> 00:58:31,620
the NIC card to actually

1788
00:58:31,620 --> 00:58:31,980
do that,

1789
00:58:31,980 --> 00:58:33,160
and that's the operating system.

1790
00:58:35,450 --> 00:58:37,220
So going back to the right

1791
00:58:37,220 --> 00:58:38,240
side of this picture correct,

1792
00:58:38,240 --> 00:58:40,550
which is the physical address layout,

1793
00:58:40,550 --> 00:58:42,110
you know we see basically the

1794
00:58:42,110 --> 00:58:43,790
bottom was unused as I showed

1795
00:58:43,790 --> 00:58:45,680
you on that document.

1796
00:58:45,740 --> 00:58:46,760
It turns out that

1797
00:58:46,760 --> 00:58:48,680
0x100, that physical address,

1798
00:58:48,680 --> 00:58:49,910
that's where the boot rom

1799
00:58:49,910 --> 00:58:50,990
is, so when you turn

1800
00:58:50,990 --> 00:58:52,370
on that board,

1801
00:58:52,370 --> 00:58:53,480
the first thing that happens is

1802
00:58:53,480 --> 00:58:55,660
actually coding the boot rom runs.

1803
00:58:55,940 --> 00:58:56,780
And when the boot rom is

1804
00:58:56,780 --> 00:58:58,490
done it actually will jump to

1805
00:58:58,490 --> 00:59:00,950
this 0x000 and it's

1806
00:59:00,950 --> 00:59:02,240
a job of the operating system make

1807
00:59:02,240 --> 00:59:03,400
sure that there's some,

1808
00:59:03,760 --> 00:59:04,900
you know, some data there.

1809
00:59:05,460 --> 00:59:06,240
And then there's a bunch of

1810
00:59:06,240 --> 00:59:08,280
other devices that will talk about

1811
00:59:08,280 --> 00:59:09,100
goes to

1812
00:59:09,610 --> 00:59:11,440
interrupt controller,

1813
00:59:11,440 --> 00:59:12,430
we'll talk about it

1814
00:59:12,430 --> 00:59:13,300
next week.

1815
00:59:13,540 --> 00:59:16,210
Um, there's a client, another part

1816
00:59:16,210 --> 00:59:18,250
of the interrupt story that we'll

1817
00:59:18,250 --> 00:59:19,480
talk about next week,

1818
00:59:19,480 --> 00:59:21,490
so there's multiple devices can generate

1819
00:59:21,490 --> 00:59:22,930
interrupts there needs to be planned

1820
00:59:22,930 --> 00:59:24,850
to route those interrupts to the

1821
00:59:24,850 --> 00:59:26,860
to the appropriate request level and

1822
00:59:26,860 --> 00:59:28,960
it's all implemented by those

1823
00:59:28,960 --> 00:59:30,140
interrupt controllers.

1824
00:59:30,510 --> 00:59:32,160
Um, and let me finish for

1825
00:59:32,160 --> 00:59:33,210
a second you know this,

1826
00:59:33,210 --> 00:59:34,660
this slide before.

1827
00:59:34,780 --> 00:59:35,920
Answering question,

1828
00:59:35,920 --> 00:59:38,500
then there's a uart

1829
00:59:38,500 --> 00:59:39,880
that was the device,

1830
00:59:39,880 --> 00:59:41,590
that was actually the thing

1831
00:59:41,590 --> 00:59:42,500
that actually,

1832
00:59:42,630 --> 00:59:44,640
the device actually UART device actually

1833
00:59:44,640 --> 00:59:46,140
interacts with the console and the

1834
00:59:46,140 --> 00:59:48,300
display and then there's the virtual

1835
00:59:48,300 --> 00:59:49,320
there's the disk.

1836
00:59:49,510 --> 00:59:51,790
And that's the device,

1837
00:59:51,790 --> 00:59:53,080
there's a device belong,

1838
00:59:53,080 --> 00:59:54,130
it's that actually interacts with

1839
00:59:54,130 --> 00:59:54,800
the disk.

1840
00:59:54,870 --> 00:59:56,490
And so when you write through

1841
00:59:56,490 --> 00:59:58,680
location to address, let's say.

1842
00:59:58,790 --> 01:00:01,610
0x200 then

1843
01:00:01,610 --> 01:00:03,170
that physical address corresponds to the

1844
01:00:03,170 --> 01:00:04,430
CLINT and so do you want

1845
01:00:04,430 --> 01:00:05,450
to do store instruction,

1846
01:00:05,450 --> 01:00:06,380
load instruction,

1847
01:00:06,380 --> 01:00:09,530
your reading and writing to the

1848
01:00:09,530 --> 01:00:12,480
chip that implements the CLINT.

1849
01:00:13,190 --> 01:00:14,480
We'll see later what that exactly

1850
01:00:14,480 --> 01:00:15,890
means but basically you can think

1851
01:00:15,890 --> 01:00:17,600
about this as interacting directly with

1852
01:00:17,600 --> 01:00:18,860
the device and not reading or

1853
01:00:18,860 --> 01:00:20,020
writing physical memory.

1854
01:00:21,780 --> 01:00:22,900
Yeah there's a question.

1855
01:00:24,230 --> 01:00:25,760
Um, so just trying to make

1856
01:00:25,760 --> 01:00:29,450
sure the addresses below

1857
01:00:29,450 --> 01:00:31,580
0x800, they don't really exist

1858
01:00:31,580 --> 01:00:33,480
in dram.

1859
01:00:33,660 --> 01:00:35,220
If when we mention those addresses

1860
01:00:35,220 --> 01:00:36,480
we directly go to the other

1861
01:00:36,480 --> 01:00:37,200
hardwares.

1862
01:00:37,200 --> 01:00:38,070
Yeah yeah,

1863
01:00:38,070 --> 01:00:39,210
so if you go back to

1864
01:00:39,210 --> 01:00:40,280
this picture.

1865
01:00:40,330 --> 01:00:42,010
Anything of above

1866
01:00:42,010 --> 01:00:43,160
0x10, correct.

1867
01:00:45,330 --> 01:00:46,840
That's these dram chips.

1868
01:00:48,020 --> 01:00:49,670
And you know I can't

1869
01:00:49,670 --> 01:00:50,780
draw, I can't point you

1870
01:00:50,780 --> 01:00:51,590
to the CLINT,

1871
01:00:51,590 --> 01:00:53,680
but like generally hears that,

1872
01:00:53,770 --> 01:00:55,020
um, ethernet.

1873
01:00:55,980 --> 01:00:57,480
And so that's a particular physical

1874
01:00:57,480 --> 01:00:58,830
address and we can write you

1875
01:00:58,830 --> 01:01:00,570
know load store instructions is called

1876
01:01:00,570 --> 01:01:01,830
memory mapped IO,

1877
01:01:01,830 --> 01:01:03,450
we can load and store instructions,

1878
01:01:03,450 --> 01:01:05,520
we can program ethernet controller.

1879
01:01:09,340 --> 01:01:10,840
I also have a question,

1880
01:01:10,840 --> 01:01:13,480
why was this big chunk at

1881
01:01:13,480 --> 01:01:15,300
the top says unused.

1882
01:01:15,480 --> 01:01:18,630
Why is it not used. OK,

1883
01:01:18,630 --> 01:01:19,470
so remember,

1884
01:01:19,470 --> 01:01:21,930
um, not every machine not

1885
01:01:21,930 --> 01:01:23,550
every so there's two to

1886
01:01:23,550 --> 01:01:24,880
the power 56,

1887
01:01:25,190 --> 01:01:27,770
bytes physical address space,

1888
01:01:27,770 --> 01:01:29,300
but you don't have those,

1889
01:01:29,300 --> 01:01:30,830
you know, plug in that much memory

1890
01:01:30,830 --> 01:01:31,550
into the board,

1891
01:01:31,550 --> 01:01:32,560
if you don't want to.

1892
01:01:32,940 --> 01:01:34,170
And so some parts of it

1893
01:01:34,170 --> 01:01:36,150
may be unused, depending on how

1894
01:01:36,150 --> 01:01:37,710
much you're dram chips are sitting

1895
01:01:37,710 --> 01:01:38,480
on the board.

1896
01:01:42,300 --> 01:01:42,720
In fact,

1897
01:01:42,720 --> 01:01:44,220
they like in xv6,

1898
01:01:44,220 --> 01:01:46,590
we I think limit ourselves to

1899
01:01:46,590 --> 01:01:48,840
128 megabyte.

1900
01:01:50,440 --> 01:01:51,380
And no more.

1901
01:01:55,370 --> 01:01:58,970
So when a, when a

1902
01:01:58,970 --> 01:02:01,280
load store instruction goes out of

1903
01:02:01,280 --> 01:02:02,510
the CPU,

1904
01:02:02,510 --> 01:02:04,640
does that go,

1905
01:02:04,880 --> 01:02:06,800
like where does it get

1906
01:02:06,800 --> 01:02:08,600
routed to the correct IO, like

1907
01:02:08,600 --> 01:02:10,160
already from the CPU,

1908
01:02:10,160 --> 01:02:11,870
so kind of like if the

1909
01:02:11,870 --> 01:02:13,580
CPU before it sends it out

1910
01:02:13,580 --> 01:02:14,120
it says OK,

1911
01:02:14,120 --> 01:02:15,740
if it's lower than 0x8

1912
01:02:15,740 --> 01:02:17,900
and all the zeros then

1913
01:02:17,900 --> 01:02:19,100
I'm going to send it to

1914
01:02:19,100 --> 01:02:20,330
the correct IO devices,

1915
01:02:20,330 --> 01:02:21,320
and then otherwise I'm going to

1916
01:02:21,320 --> 01:02:24,380
send it to the to the

1917
01:02:24,380 --> 01:02:26,760
memory like dram chip.

1918
01:02:27,030 --> 01:02:28,200
Yeah, you can think about as

1919
01:02:28,200 --> 01:02:29,760
a demultiplexer sitting on the

1920
01:02:29,760 --> 01:02:31,710
inside of the RISC-V, you

1921
01:02:31,710 --> 01:02:33,160
know block.

1922
01:02:33,240 --> 01:02:34,110
Oh, so it's inside of

1923
01:02:34,110 --> 01:02:35,380
that block. OK.

1924
01:02:38,150 --> 01:02:40,610
As a memory controller and does

1925
01:02:40,610 --> 01:02:41,480
routing.

1926
01:02:44,700 --> 01:02:46,080
Because very important to have

1927
01:02:46,080 --> 01:02:46,830
that sort of all clear

1928
01:02:46,830 --> 01:02:47,780
in your head.

1929
01:02:51,420 --> 01:02:51,960
Are you okay,

1930
01:02:51,960 --> 01:02:52,740
so now I want to

1931
01:02:52,740 --> 01:02:54,270
switch to the right side

1932
01:02:54,270 --> 01:02:55,460
of this picture.

1933
01:02:55,610 --> 01:02:57,080
And this is basically what

1934
01:02:57,080 --> 01:03:00,140
xv6 sets up, to

1935
01:03:00,140 --> 01:03:01,520
the virtual address space, that

1936
01:03:01,520 --> 01:03:02,540
xv6 setup,

1937
01:03:02,540 --> 01:03:04,910
so when the machine boot, there's

1938
01:03:04,910 --> 01:03:06,740
no page enable yet,

1939
01:03:06,740 --> 01:03:08,570
xv6 sets up

1940
01:03:08,570 --> 01:03:11,690
the first page tables, virtual

1941
01:03:11,690 --> 01:03:12,830
address space and that's actually

1942
01:03:12,830 --> 01:03:13,580
the virtual address space,

1943
01:03:13,580 --> 01:03:14,900
the kernel uses and we'll look

1944
01:03:14,900 --> 01:03:16,000
at it in the second.

1945
01:03:16,050 --> 01:03:17,070
At the code,

1946
01:03:17,070 --> 01:03:17,850
but,

1947
01:03:17,850 --> 01:03:19,440
and this is the layout

1948
01:03:19,440 --> 01:03:20,560
and it turns out,

1949
01:03:20,620 --> 01:03:21,460
you know,

1950
01:03:21,460 --> 01:03:22,750
because we want to keep

1951
01:03:22,750 --> 01:03:24,160
xv6 as simple as possible,

1952
01:03:24,160 --> 01:03:26,020
it's easy for you to understand.

1953
01:03:25,990 --> 01:03:28,120
The mapping from virtual

1954
01:03:28,600 --> 01:03:29,680
to physical.

1955
01:03:30,780 --> 01:03:32,700
Is mostly in identity mapping.

1956
01:03:38,110 --> 01:03:39,490
So basically what that means is

1957
01:03:39,490 --> 01:03:42,700
that the virtual address 0x200

1958
01:03:43,180 --> 01:03:45,160
maps to physical address

1959
01:03:45,160 --> 01:03:47,080
0x200, the kernel

1960
01:03:47,080 --> 01:03:48,400
will set up the page tables

1961
01:03:48,400 --> 01:03:49,870
exactly in that way,

1962
01:03:49,870 --> 01:03:51,670
and so that means basically that

1963
01:03:51,670 --> 01:03:53,200
you know all virtual dresses,

1964
01:03:53,200 --> 01:03:54,980
below this top.

1965
01:03:55,840 --> 01:03:56,740
Which is the top of

1966
01:03:56,740 --> 01:03:59,170
physical memory are identical to the

1967
01:03:59,170 --> 01:04:00,730
physical addresses that are actually being

1968
01:04:00,730 --> 01:04:02,800
used on the right side.

1969
01:04:03,150 --> 01:04:04,260
And so this is why all

1970
01:04:04,260 --> 01:04:06,210
the arrows are straight, because it's

1971
01:04:06,210 --> 01:04:07,460
identity mapping.

1972
01:04:10,830 --> 01:04:13,440
The small changes to this,

1973
01:04:14,560 --> 01:04:16,120
there are two important things

1974
01:04:16,120 --> 01:04:16,900
to mention.

1975
01:04:17,610 --> 01:04:20,370
Let me hold on a second, while

1976
01:04:20,370 --> 01:04:21,810
try to first mention the two

1977
01:04:21,810 --> 01:04:23,300
important things to mention.

1978
01:04:23,500 --> 01:04:25,090
First of all,

1979
01:04:25,090 --> 01:04:26,800
there's some pages,

1980
01:04:26,800 --> 01:04:28,300
some maps very high up in

1981
01:04:28,300 --> 01:04:29,080
your memory.

1982
01:04:32,550 --> 01:04:34,320
Which some pages very high

1983
01:04:34,320 --> 01:04:35,040
up in memory,

1984
01:04:35,040 --> 01:04:38,550
for example the stack a

1985
01:04:38,550 --> 01:04:40,470
kernel stack actually sits up is

1986
01:04:40,470 --> 01:04:42,280
also map high up in memory.

1987
01:04:42,450 --> 01:04:43,590
Um, and the reason is high

1988
01:04:43,590 --> 01:04:44,880
up in memory is because we

1989
01:04:44,880 --> 01:04:46,320
have a guard page below it

1990
01:04:46,320 --> 01:04:47,500
that is not mapped.

1991
01:04:47,770 --> 01:04:49,540
So the PTE entry below

1992
01:04:49,540 --> 01:04:51,280
the kernel stack, of one of

1993
01:04:51,280 --> 01:04:52,720
the kernel stack [], does

1994
01:04:52,720 --> 01:04:54,610
have, not have it's valid

1995
01:04:54,610 --> 01:04:55,380
bit set.

1996
01:04:55,660 --> 01:04:56,560
And, um,

1997
01:04:56,560 --> 01:04:58,360
so if you know, the kernel

1998
01:04:58,360 --> 01:05:00,100
runs off its stack and will

1999
01:05:00,100 --> 01:05:01,840
result in a page fault,

2000
01:05:01,840 --> 01:05:04,060
which is better than basically scribbling

2001
01:05:04,060 --> 01:05:05,140
over some other memory that the

2002
01:05:05,140 --> 01:05:06,020
kernel has.

2003
01:05:06,080 --> 01:05:07,220
You get immediate panic,

2004
01:05:07,220 --> 01:05:09,020
you know that something's bad to stack.

2005
01:05:09,680 --> 01:05:11,540
Of course, we don't want

2006
01:05:11,540 --> 01:05:13,580
to waste physical memory and so

2007
01:05:13,580 --> 01:05:15,080
when we do that by basically

2008
01:05:15,080 --> 01:05:16,940
putting the stack high,

2009
01:05:16,940 --> 01:05:18,890
in,

2010
01:05:18,890 --> 01:05:20,690
a guard page, an empty guard

2011
01:05:20,690 --> 01:05:22,280
PTE entry below it.

2012
01:05:22,520 --> 01:05:24,590
Um, and the guard page

2013
01:05:24,590 --> 01:05:26,450
doesn't really consume any physical memory

2014
01:05:26,450 --> 01:05:27,560
records sitting high up in the

2015
01:05:27,560 --> 01:05:28,400
virtual address space,

2016
01:05:28,400 --> 01:05:30,620
so nothing is being consumed.

2017
01:05:31,190 --> 01:05:32,570
But that means that they're showing

2018
01:05:32,570 --> 01:05:33,560
this case, stack page,

2019
01:05:33,560 --> 01:05:35,140
for example is mapped twice.

2020
01:05:35,360 --> 01:05:36,230
It's mapped at a high

2021
01:05:36,230 --> 01:05:38,660
address and it's mapped directly

2022
01:05:38,660 --> 01:05:40,010
by one of the dresses

2023
01:05:40,010 --> 01:05:41,300
that below [this] top.

2024
01:05:42,590 --> 01:05:43,760
And so you can do, this

2025
01:05:43,760 --> 01:05:45,290
is one example of all the

2026
01:05:45,290 --> 01:05:46,970
sort of cool things, you can

2027
01:05:46,970 --> 01:05:48,230
do with page tables,

2028
01:05:48,230 --> 01:05:49,370
you can map a physical

2029
01:05:49,370 --> 01:05:50,480
address twice,

2030
01:05:50,480 --> 01:05:52,610
you cannot map a physical address,

2031
01:05:52,610 --> 01:05:53,930
you know it can be

2032
01:05:53,930 --> 01:05:55,160
one to one mapping, one to

2033
01:05:55,160 --> 01:05:56,900
many mapping, many to one mapping,

2034
01:05:56,900 --> 01:05:57,710
all that kind of stuff

2035
01:05:57,710 --> 01:05:58,560
is possible.

2036
01:05:58,930 --> 01:06:01,030
Um, actually it doesn't really use

2037
01:06:01,030 --> 01:06:01,930
many of them, but there's a

2038
01:06:01,930 --> 01:06:03,760
couple places we use those tricks.

2039
01:06:03,880 --> 01:06:05,110
And there's the stack in

2040
01:06:05,110 --> 01:06:06,070
the guard page is one

2041
01:06:06,070 --> 01:06:06,910
example, of one of the

2042
01:06:06,910 --> 01:06:09,280
cool trick then xv6 uses

2043
01:06:09,280 --> 01:06:11,020
mostly to track down bugs.

2044
01:06:12,880 --> 01:06:13,720
The second thing I wanted to

2045
01:06:13,720 --> 01:06:14,530
mention is that,

2046
01:06:14,530 --> 01:06:15,920
the permissions.

2047
01:06:16,570 --> 01:06:18,550
So, for example the kernel text,

2048
01:06:18,550 --> 01:06:19,720
the pages for the kernel text

2049
01:06:19,720 --> 01:06:20,320
are mapped

2050
01:06:20,320 --> 01:06:22,420
R-X, meaning you can

2051
01:06:22,420 --> 01:06:23,780
read it and execute it.

2052
01:06:23,780 --> 01:06:24,890
But you cannot write to

2053
01:06:24,890 --> 01:06:26,150
kernel text and again this

2054
01:06:26,150 --> 01:06:27,500
is basically devoid.

2055
01:06:27,530 --> 01:06:28,730
Box so that, we catch

2056
01:06:28,730 --> 01:06:30,650
them early, kernel data of course

2057
01:06:30,650 --> 01:06:31,610
needs to be able to be

2058
01:06:31,610 --> 01:06:33,110
written to, and so it has

2059
01:06:33,110 --> 01:06:34,250
mapped read write,

2060
01:06:34,250 --> 01:06:36,060
but you cannot execute

2061
01:06:36,130 --> 01:06:38,230
out of kernel data

2062
01:06:38,230 --> 01:06:39,880
pages instructions.

2063
01:06:40,680 --> 01:06:41,910
Um, so the execute bit is

2064
01:06:41,910 --> 01:06:42,680
not set.

2065
01:06:45,960 --> 01:06:47,040
Does that make sense.

2066
01:06:48,010 --> 01:06:49,510
Um I skipped one or

2067
01:06:49,510 --> 01:06:50,020
two questions,

2068
01:06:50,020 --> 01:06:51,280
so if these questions are still

2069
01:06:51,280 --> 01:06:52,060
not answered,

2070
01:06:52,060 --> 01:06:53,080
please ask them.

2071
01:06:55,790 --> 01:06:56,600
We have a question in the

2072
01:06:56,600 --> 01:06:58,460
chat.

2073
01:06:58,460 --> 01:07:00,320
Do we have multiple kernel stacks

2074
01:07:00,320 --> 01:07:02,240
for different processes like we have

2075
01:07:02,240 --> 01:07:04,560
n stacks for n processes.

2076
01:07:04,640 --> 01:07:05,960
And answers yes.

2077
01:07:06,850 --> 01:07:08,860
So every process every user process

2078
01:07:08,860 --> 01:07:10,820
has a corresponding kernel stack.

2079
01:07:13,130 --> 01:07:14,030
I will see that in a

2080
01:07:14,030 --> 01:07:14,960
little bit later.

2081
01:07:19,220 --> 01:07:20,660
Okay, so let me,

2082
01:07:20,660 --> 01:07:21,800
um, Samir,

2083
01:07:21,800 --> 01:07:22,500
go ahead.

2084
01:07:23,350 --> 01:07:26,080
Um, so what's the virtual memory

2085
01:07:26,080 --> 01:07:28,420
of another application

2086
01:07:28,720 --> 01:07:30,130
map to somewhere in the physical

2087
01:07:30,130 --> 01:07:32,440
memory in the unused space or.

2088
01:07:32,440 --> 01:07:34,540
Yes, a very good point,

2089
01:07:34,540 --> 01:07:36,730
so there's a bunch of

2090
01:07:36,730 --> 01:07:37,240
physical memory,

2091
01:07:37,240 --> 01:07:38,800
correct, here's free memory.

2092
01:07:39,340 --> 01:07:41,230
Um, now that's free memory

2093
01:07:41,230 --> 01:07:43,780
here to, right, and

2094
01:07:43,780 --> 01:07:45,310
we use that actually use

2095
01:07:45,310 --> 01:07:46,720
that free memory to basically

2096
01:07:46,720 --> 01:07:48,790
store pages of page tables,

2097
01:07:48,790 --> 01:07:51,190
user processes as well as you

2098
01:07:51,190 --> 01:07:53,440
know the text and data of

2099
01:07:53,440 --> 01:07:54,720
user level processes.

2100
01:07:55,790 --> 01:07:56,480
And if we are on

2101
01:07:56,480 --> 01:07:56,900
many many,

2102
01:07:56,900 --> 01:07:58,490
many user processes at some point

2103
01:07:58,490 --> 01:07:59,690
we'll run out of free memory,

2104
01:07:59,690 --> 01:08:01,520
and then basically fork or exec

2105
01:08:01,520 --> 01:08:03,480
will return an error.

2106
01:08:04,900 --> 01:08:05,770
But that means that the

2107
01:08:05,770 --> 01:08:08,620
virtual space for processes are

2108
01:08:08,620 --> 01:08:09,850
much smaller than the virtual

2109
01:08:09,850 --> 01:08:12,240
space for the kernel.

2110
01:08:12,500 --> 01:08:14,000
Well, the virtual spaces as

2111
01:08:14,000 --> 01:08:15,950
the same as the same

2112
01:08:15,950 --> 01:08:17,150
size in principle,

2113
01:08:17,150 --> 01:08:19,340
but it will be less populated.

2114
01:08:22,520 --> 01:08:24,200
Then let me let's look at

2115
01:08:24,200 --> 01:08:24,560
some code,

2116
01:08:24,560 --> 01:08:25,280
and I think that all this

2117
01:08:25,280 --> 01:08:26,720
stuff becomes a bit more clear.

2118
01:08:27,690 --> 01:08:29,280
I just want small thing,

2119
01:08:29,280 --> 01:08:32,760
um, is so given that

2120
01:08:32,760 --> 01:08:34,020
a lot of the like,

2121
01:08:34,020 --> 01:08:35,610
each process has a big part

2122
01:08:35,610 --> 01:08:37,080
of the memory map to the

2123
01:08:37,080 --> 01:08:39,810
same location is that optimized by

2124
01:08:39,810 --> 01:08:42,720
like consolidating that into one place

2125
01:08:42,720 --> 01:08:44,180
that mapping or no.

2126
01:08:44,280 --> 01:08:46,050
Um, it's good,

2127
01:08:46,050 --> 01:08:47,370
xv6 does not do that,

2128
01:08:47,370 --> 01:08:48,990
like one of the challenge

2129
01:08:48,990 --> 01:08:51,210
exercises in the page table lab

2130
01:08:51,210 --> 01:08:52,640
is to actually implement that.

2131
01:08:54,510 --> 01:08:56,130
I see. The real operating system

2132
01:08:56,130 --> 01:08:56,920
would do that.

2133
01:08:58,710 --> 01:09:00,240
Yeah. Makes sense.

2134
01:09:00,240 --> 01:09:01,220
Very good question.

2135
01:09:02,380 --> 01:09:03,220
I think you get a sense

2136
01:09:03,220 --> 01:09:04,240
of what all kinds of things

2137
01:09:04,240 --> 01:09:04,780
are possible,

2138
01:09:04,780 --> 01:09:06,120
once you have page tables.

2139
01:09:08,790 --> 01:09:09,780
Okay, um,

2140
01:09:09,780 --> 01:09:11,490
so let's do the usual thing,

2141
01:09:12,640 --> 01:09:14,830
boot xv6 again

2142
01:09:14,830 --> 01:09:15,370
and again,

2143
01:09:15,370 --> 01:09:16,900
you know QEMU uses basically implementing

2144
01:09:16,900 --> 01:09:17,780
the board.

2145
01:09:18,170 --> 01:09:21,460
Um, and you know let's. Oops,

2146
01:09:26,750 --> 01:09:28,260
-gdb,

2147
01:09:29,930 --> 01:09:31,880
last time we looked at

2148
01:09:31,880 --> 01:09:33,710
how the routing happens correct

2149
01:09:33,710 --> 01:09:34,310
and then we got to

2150
01:09:34,310 --> 01:09:35,510
main and then basically one

2151
01:09:35,510 --> 01:09:37,200
of the things that,

2152
01:09:37,270 --> 01:09:38,650
um, the kernel,

2153
01:09:38,650 --> 01:09:41,380
when one of the functions called

2154
01:09:41,380 --> 01:09:42,670
kvminit and that actually

2155
01:09:42,670 --> 01:09:44,110
sets up the address space for

2156
01:09:44,110 --> 01:09:44,820
the kernel.

2157
01:09:45,100 --> 01:09:46,330
And so we saw in the

2158
01:09:46,330 --> 01:09:47,740
picture where in the previous slide,

2159
01:09:47,740 --> 01:09:49,330
what that you know looks like

2160
01:09:49,330 --> 01:09:50,200
and here we go,

2161
01:09:50,200 --> 01:09:51,730
CC code how it actually is

2162
01:09:51,730 --> 01:09:52,580
being set up.

2163
01:09:58,380 --> 01:10:01,500
And why, hold on, something's

2164
01:10:01,500 --> 01:10:02,340
not going.

2165
01:10:02,510 --> 01:10:03,980
As I wanted to.

2166
01:10:04,380 --> 01:10:07,100
Am I the right directories.

2167
01:10:11,140 --> 01:10:12,130
Hold on a second here

2168
01:10:12,130 --> 01:10:13,180
while I'm trying to sort

2169
01:10:13,180 --> 01:10:14,720
out my problems.

2170
01:10:16,590 --> 01:10:17,940
That is good.

2171
01:10:21,390 --> 01:10:23,070
I mean the right directory,

2172
01:10:23,070 --> 01:10:24,630
yeah,

2173
01:10:28,050 --> 01:10:28,710
We want to send a

2174
01:10:28,710 --> 01:10:29,670
break from the main just

2175
01:10:29,670 --> 01:10:30,960
to make sure.

2176
01:10:31,050 --> 01:10:32,970
Good, and then a break point

2177
01:10:32,970 --> 01:10:35,940
at kvminit.

2178
01:10:36,340 --> 01:10:37,300
Actually I can just step to

2179
01:10:37,300 --> 01:10:40,540
it now, next consoleinit

2180
01:10:40,540 --> 01:10:41,050
printfinit,

2181
01:10:41,050 --> 01:10:42,760
you know, we saw it before,

2182
01:10:43,250 --> 01:10:45,320
physical memory allocator.

2183
01:10:51,100 --> 01:10:52,720
You know, something happens that I

2184
01:10:52,720 --> 01:10:55,200
not expecting.

2185
01:10:57,590 --> 01:10:59,840
What is going on.

2186
01:11:02,590 --> 01:11:03,970
We're gonna run this right before

2187
01:11:03,970 --> 01:11:04,900
lecture. Here,

2188
01:11:04,900 --> 01:11:06,700
that's what's going on actually printing,

2189
01:11:06,700 --> 01:11:08,220
um, okay.

2190
01:11:10,330 --> 01:11:11,620
Um, interesting,

2191
01:11:11,620 --> 01:11:12,460
okay one more time,

2192
01:11:12,460 --> 01:11:14,890
see if I can get lucky

2193
01:11:14,890 --> 01:11:15,840
more looks.

2194
01:11:19,270 --> 01:11:20,920
Very good.

2195
01:11:28,910 --> 01:11:32,140
Continue, hopefully it will get there,

2196
01:11:33,010 --> 01:11:34,210
wait a little bit. Okay great

2197
01:11:34,210 --> 01:11:35,860
we're at the kvminit,

2198
01:11:35,860 --> 01:11:37,390
so basically we're now this function

2199
01:11:37,390 --> 01:11:39,220
here, on the right side in

2200
01:11:39,220 --> 01:11:40,000
the emacs buffer,

2201
01:11:40,000 --> 01:11:40,900
you can see it.

2202
01:11:41,280 --> 01:11:43,640
And,

2203
01:11:44,220 --> 01:11:46,380
I think I've modified function

2204
01:11:46,380 --> 01:11:48,820
slightly I hope I did.

2205
01:11:52,570 --> 01:11:53,980
Um, I think I did, we'll

2206
01:11:53,980 --> 01:11:56,890
see, and what we knew

2207
01:11:56,890 --> 01:11:58,660
is going to walk step into

2208
01:11:58,660 --> 01:11:59,560
the function.

2209
01:12:00,080 --> 01:12:02,270
Give me layout split it's

2210
01:12:02,270 --> 01:12:03,280
easier to see.

2211
01:12:03,640 --> 01:12:04,630
And this is the first thing

2212
01:12:04,630 --> 01:12:05,530
that you can see, this section

2213
01:12:05,530 --> 01:12:06,640
of the current actually allocates a

2214
01:12:06,640 --> 01:12:08,470
physical page, for the top level

2215
01:12:08,470 --> 01:12:09,440
page directory.

2216
01:12:10,090 --> 01:12:12,250
And then zeroes it

2217
01:12:12,250 --> 01:12:13,690
out so that all the PTE

2218
01:12:13,690 --> 01:12:14,760
entries are zero.

2219
01:12:15,360 --> 01:12:17,490
And then basically starts mapping in

2220
01:12:17,490 --> 01:12:20,490
every device, IO device one

2221
01:12:20,490 --> 01:12:21,280
by one.

2222
01:12:21,620 --> 01:12:22,130
And so,

2223
01:12:22,130 --> 01:12:23,990
for example, the UART0, it

2224
01:12:23,990 --> 01:12:25,820
basically starts mapping maps that into

2225
01:12:25,820 --> 01:12:28,550
the kernel address space and so

2226
01:12:28,550 --> 01:12:29,960
we can look at a file

2227
01:12:29,960 --> 01:12:32,840
called memlayout.h, is basically translate

2228
01:12:32,840 --> 01:12:34,580
page 31 that I showed

2229
01:12:34,580 --> 01:12:35,930
you from the document into a

2230
01:12:35,930 --> 01:12:37,620
bunch of constants that we're using.

2231
01:12:38,010 --> 01:12:38,280
And so,

2232
01:12:38,280 --> 01:12:39,510
for example here it says what

2233
01:12:39,510 --> 01:12:42,700
the address of 0x1000 is.

2234
01:12:44,100 --> 01:12:46,800
Um, do you ideas.

2235
01:12:47,100 --> 01:12:47,940
And so,

2236
01:12:47,940 --> 01:12:50,040
you know, we can basically

2237
01:12:50,040 --> 01:12:52,110
map it into the address space

2238
01:12:52,110 --> 01:12:53,760
by calling this function

2239
01:12:53,760 --> 01:12:54,660
kvmmap which I will look in

2240
01:12:54,660 --> 01:12:55,520
a second.

2241
01:12:56,040 --> 01:12:57,000
And then,

2242
01:12:57,000 --> 01:13:00,390
in the first exercise of

2243
01:13:00,390 --> 01:13:01,260
the page table lab,

2244
01:13:01,260 --> 01:13:02,700
you are asked to implement a

2245
01:13:02,700 --> 01:13:04,040
function called vm_print.

2246
01:13:04,300 --> 01:13:06,400
Um, and I implemented it too,

2247
01:13:06,400 --> 01:13:07,900
and I'm going to step over

2248
01:13:07,900 --> 01:13:09,520
it and we'll see basically,

2249
01:13:09,720 --> 01:13:11,600
page tables,

2250
01:13:11,960 --> 01:13:13,790
kernel page table as it

2251
01:13:13,790 --> 01:13:15,350
is set up after that one

2252
01:13:15,350 --> 01:13:16,700
call to the kvmmap,

2253
01:13:16,700 --> 01:13:17,980
so I'm going to do that.

2254
01:13:18,250 --> 01:13:18,970
And we're going to print

2255
01:13:18,970 --> 01:13:19,780
out something.

2256
01:13:20,240 --> 01:13:20,750
And so we're going to

2257
01:13:20,750 --> 01:13:21,380
look a little bit of

2258
01:13:21,380 --> 01:13:22,160
the output here,

2259
01:13:22,160 --> 01:13:23,420
so here's the page table that

2260
01:13:23,420 --> 01:13:24,140
is the

2261
01:13:24,790 --> 01:13:28,030
physical address of the top level,

2262
01:13:28,030 --> 01:13:30,190
page directory,

2263
01:13:30,190 --> 01:13:31,240
so the thing that actually sits

2264
01:13:31,240 --> 01:13:32,020
in satp,

2265
01:13:32,020 --> 01:13:33,980
or will sit in satp.

2266
01:13:34,600 --> 01:13:36,850
And then we have

2267
01:13:36,850 --> 01:13:38,140
entry zero of the top

2268
01:13:38,140 --> 01:13:40,030
level page really has one

2269
01:13:40,030 --> 01:13:41,880
PTE entry in it.

2270
01:13:42,480 --> 01:13:45,300
Um, and that is the contains

2271
01:13:45,300 --> 01:13:46,710
the physical address for the middle

2272
01:13:46,710 --> 01:13:48,200
level page table directory.

2273
01:13:48,600 --> 01:13:50,190
The middle page level directory has

2274
01:13:50,190 --> 01:13:52,780
one entry namely 128.

2275
01:13:52,900 --> 01:13:53,950
And that points to the bottom

2276
01:13:53,950 --> 01:13:55,360
of page table directory and the

2277
01:13:55,360 --> 01:13:56,800
bottom page table directory has the

2278
01:13:56,800 --> 01:13:59,020
entry then for the physical page.

2279
01:13:59,390 --> 01:14:00,110
And you can see,

2280
01:14:00,110 --> 01:14:02,090
indeed that the physical address,

2281
01:14:02,090 --> 01:14:03,530
you know for that bottom level

2282
01:14:03,530 --> 01:14:05,570
is 0x1000

2283
01:14:05,570 --> 01:14:07,680
corresponding to uart0.

2284
01:14:08,350 --> 01:14:11,080
Right, so basically virtual address

2285
01:14:11,470 --> 01:14:13,300
1000 translates

2286
01:14:13,300 --> 01:14:15,820
to physical address 11100.

2287
01:14:16,570 --> 01:14:18,700
A weak unsure double-check,

2288
01:14:18,700 --> 01:14:20,920
this is indeed all legit.

2289
01:14:21,010 --> 01:14:22,690
Vary by um,

2290
01:14:22,690 --> 01:14:28,330
and let's take that address 0x100L

2291
01:14:28,330 --> 01:14:29,710
and we're going

2292
01:14:29,710 --> 01:14:30,960
to shift 12.

2293
01:14:31,700 --> 01:14:34,960
Um, and that should be,

2294
01:14:35,160 --> 01:14:36,240
you know, that gives the top

2295
01:14:36,240 --> 01:14:38,600
level 27 bits.

2296
01:14:39,070 --> 01:14:40,660
We shifted 9,

2297
01:14:40,660 --> 01:14:43,360
so I'm gonna take 0x100,

2298
01:14:43,970 --> 01:14:48,440
A 1000101 and we can

2299
01:14:48,440 --> 01:14:49,540
shift at 9,

2300
01:14:49,840 --> 01:14:50,920
print that.

2301
01:14:53,000 --> 01:14:54,620
And that is 0x000,

2302
01:14:54,620 --> 01:14:56,360
and actually print 0x0

2303
01:14:56,360 --> 01:14:58,460
as a decimal decimal number, it's

2304
01:14:58,460 --> 01:14:59,840
going to be 128, OK.

2305
01:15:02,330 --> 01:15:03,590
So we see actually sort of

2306
01:15:03,590 --> 01:15:04,640
you know it all sort of

2307
01:15:04,640 --> 01:15:05,540
makes sense.

2308
01:15:05,920 --> 01:15:07,390
We also see I printed out

2309
01:15:07,390 --> 01:15:08,650
the flags here,

2310
01:15:08,650 --> 01:15:11,230
and you know the bottom

2311
01:15:11,230 --> 01:15:12,280
level has read,

2312
01:15:12,280 --> 01:15:16,180
write and valid, because valid

2313
01:15:16,180 --> 01:15:16,920
is one.

2314
01:15:18,480 --> 01:15:19,740
Any questions about this.

2315
01:15:24,760 --> 01:15:26,960
Okay, so um.

2316
01:15:27,290 --> 01:15:30,080
The kernel basically proceeds, you know

2317
01:15:30,080 --> 01:15:32,000
doing setting up the whole address

2318
01:15:32,000 --> 01:15:33,160
space in this way.

2319
01:15:33,810 --> 01:15:35,580
And, so we've called

2320
01:15:35,580 --> 01:15:37,740
kvmmap for virtual IO, for the

2321
01:15:37,740 --> 01:15:39,100
CLINT, for the click.

2322
01:15:39,350 --> 01:15:42,320
Maps the kernel text, maps

2323
01:15:42,320 --> 01:15:44,480
the kernel memory or kernel data,

2324
01:15:44,480 --> 01:15:45,830
and then the trampoline page that

2325
01:15:45,830 --> 01:15:47,040
we'll talk about next week.

2326
01:15:47,460 --> 01:15:48,780
Um, and so in fact we

2327
01:15:48,780 --> 01:15:50,280
can single step through this and

2328
01:15:50,280 --> 01:15:52,290
then see what the final page

2329
01:15:52,290 --> 01:15:53,780
directory looks like.

2330
01:15:55,610 --> 01:15:58,760
Um, so next next next next.

2331
01:15:59,330 --> 01:16:01,190
Basically, you know set the trampoline,

2332
01:16:01,190 --> 01:16:02,030
so now we're going to print

2333
01:16:02,030 --> 01:16:03,860
the complete page table directory.

2334
01:16:04,160 --> 01:16:07,430
Um, you know we see basically

2335
01:16:07,430 --> 01:16:09,080
lot of PTE is actually

2336
01:16:09,080 --> 01:16:11,680
being setup.

2337
01:16:11,840 --> 01:16:13,310
Um, and I'm not going to

2338
01:16:13,310 --> 01:16:14,870
talk about in any detail,

2339
01:16:14,870 --> 01:16:16,610
um, but you know basically fills

2340
01:16:16,610 --> 01:16:17,480
out the

2341
01:16:17,920 --> 01:16:20,170
directory to actually create

2342
01:16:20,170 --> 01:16:21,730
virtual mapping that we

2343
01:16:21,730 --> 01:16:23,480
basically saw on the previous slide.

2344
01:16:24,840 --> 01:16:26,010
When I expect what I

2345
01:16:26,010 --> 01:16:26,910
wanna do next is actually

2346
01:16:26,910 --> 01:16:28,160
much more interesting.

2347
01:16:29,730 --> 01:16:31,080
Yeah I'm gonna.

2348
01:16:32,270 --> 01:16:33,350
Yeah I wanna go here,

2349
01:16:33,350 --> 01:16:34,730
actually, I guess maybe I already

2350
01:16:34,730 --> 01:16:37,010
did this, were 21,

2351
01:16:37,010 --> 01:16:38,450
no, I'm 21 okay so single

2352
01:16:38,450 --> 01:16:39,400
step not.

2353
01:16:40,560 --> 01:16:41,430
Um, OK that's too bad, I

2354
01:16:41,430 --> 01:16:43,800
got past it but basically.

2355
01:16:44,340 --> 01:16:46,800
Um, let me let me

2356
01:16:46,800 --> 01:16:47,840
restart this.

2357
01:16:53,210 --> 01:16:57,320
I wanna break point at kvminithart.

2358
01:17:00,580 --> 01:17:01,880
And continue,

2359
01:17:03,650 --> 01:17:06,020
are now here at kvminithart,

2360
01:17:06,020 --> 01:17:07,430
and you see here,

2361
01:17:07,430 --> 01:17:09,470
basically that we're writing the

2362
01:17:09,470 --> 01:17:10,310
satp register,

2363
01:17:10,310 --> 01:17:11,450
so basically the kernel is going

2364
01:17:11,450 --> 01:17:14,600
to enable page table or

2365
01:17:14,600 --> 01:17:15,740
the hard, MMU,

2366
01:17:15,740 --> 01:17:16,970
um, to basically start using

2367
01:17:16,970 --> 01:17:17,870
the page table that we

2368
01:17:17,870 --> 01:17:18,740
just set up.

2369
01:17:19,470 --> 01:17:22,860
And one interesting question.

2370
01:17:23,350 --> 01:17:24,730
Okay, so they do have layout

2371
01:17:24,730 --> 01:17:25,990
split again,

2372
01:17:25,990 --> 01:17:27,340
um so.

2373
01:17:27,760 --> 01:17:29,350
Somewhere here correct is going to

2374
01:17:29,350 --> 01:17:30,860
be,

2375
01:17:31,320 --> 01:17:32,940
here's the instruction,

2376
01:17:32,940 --> 01:17:34,860
in,

2377
01:17:36,070 --> 01:17:39,700
once, something really dramatic happens

2378
01:17:39,700 --> 01:17:41,480
after executing this instruction.

2379
01:17:42,270 --> 01:17:44,850
Um, let's say yeah I can

2380
01:17:44,850 --> 01:17:46,500
see the same instruction exactly but

2381
01:17:46,500 --> 01:17:48,960
there's this this extent,

2382
01:17:48,960 --> 01:17:50,820
once this instruction is executed what

2383
01:17:50,820 --> 01:17:52,200
will happen with the next address

2384
01:17:52,200 --> 01:17:53,420
that's being translated.

2385
01:17:58,310 --> 01:17:59,570
Well, at the point that

2386
01:17:59,570 --> 01:18:01,550
we execute this instruction before

2387
01:18:01,550 --> 01:18:02,810
executing this instruction,

2388
01:18:02,810 --> 01:18:04,550
there's no page tables enabled yet

2389
01:18:04,550 --> 01:18:06,200
so no translation happens.

2390
01:18:06,410 --> 01:18:07,820
But the next and then the

2391
01:18:07,820 --> 01:18:10,040
program counter is updated by 4.

2392
01:18:10,240 --> 01:18:11,380
And then the next instruction is

2393
01:18:11,380 --> 01:18:13,030
executed and the program counter will

2394
01:18:13,030 --> 01:18:15,060
be translated using the virtual page,

2395
01:18:15,290 --> 01:18:16,400
page table memory.

2396
01:18:17,140 --> 01:18:18,640
And so this is, you

2397
01:18:18,640 --> 01:18:19,750
know, the ways to think about this,

2398
01:18:19,750 --> 01:18:21,500
this is a dramatic moment.

2399
01:18:21,630 --> 01:18:24,450
Because basically the whole address translation,

2400
01:18:24,450 --> 01:18:25,500
they started to enable and

2401
01:18:25,500 --> 01:18:26,910
every address needs no maybe

2402
01:18:26,910 --> 01:18:28,480
potentially something different.

2403
01:18:29,660 --> 01:18:31,370
Right, because before we're running your

2404
01:18:31,370 --> 01:18:32,240
physical addresses,

2405
01:18:32,240 --> 01:18:33,050
then the page table,

2406
01:18:33,050 --> 01:18:34,310
haven't install, and whatever is in

2407
01:18:34,310 --> 01:18:34,760
the mapping,

2408
01:18:34,760 --> 01:18:36,290
now there's now the new meaning

2409
01:18:36,290 --> 01:18:37,500
of a virtual address.

2410
01:18:38,680 --> 01:18:40,090
Um, and here's how this works

2411
01:18:40,090 --> 01:18:41,230
out, you know, the fact that

2412
01:18:41,230 --> 01:18:42,820
this actually works out is remarkable

2413
01:18:42,820 --> 01:18:44,590
because like the next instruction,

2414
01:18:44,590 --> 01:18:46,180
the next value is a virtual

2415
01:18:46,180 --> 01:18:47,780
address and not a physical address.

2416
01:18:49,000 --> 01:18:50,020
The next instruction is going to

2417
01:18:50,020 --> 01:18:50,290
be this,

2418
01:18:50,290 --> 01:18:52,300
whatever 0x1110.

2419
01:18:52,750 --> 01:18:54,240
And why does this work out.

2420
01:18:55,960 --> 01:18:57,130
And the reason works out is

2421
01:18:57,130 --> 01:18:58,270
because the kernel is setup,

2422
01:18:58,270 --> 01:19:00,460
we can identity page mapping. So,

2423
01:19:00,730 --> 01:19:02,590
after we enable the virtual

2424
01:19:02,590 --> 01:19:03,760
paging hardware,

2425
01:19:03,760 --> 01:19:05,740
we actually know this translator will

2426
01:19:05,740 --> 01:19:07,540
translate again to the same physical

2427
01:19:07,540 --> 01:19:09,970
address and so indeed we'll actually

2428
01:19:09,970 --> 01:19:11,180
end up, you know,

2429
01:19:11,210 --> 01:19:13,430
executing the writing instruction, because that's

2430
01:19:13,430 --> 01:19:14,750
actually exactly the instruction,

2431
01:19:14,750 --> 01:19:16,490
the memory location that the virtual

2432
01:19:16,490 --> 01:19:17,700
hardware is programmed for.

2433
01:19:19,110 --> 01:19:20,400
So does this make sense.

2434
01:19:22,920 --> 01:19:25,560
Again, one reason why programming virtual

2435
01:19:25,560 --> 01:19:27,570
memory is difficult is because once

2436
01:19:27,570 --> 01:19:29,100
you execute one of these satp

2437
01:19:29,100 --> 01:19:31,410
instructions you load a page table

2438
01:19:31,410 --> 01:19:35,040
in the satp register, your world

2439
01:19:35,040 --> 01:19:36,320
completely changes.

2440
01:19:36,680 --> 01:19:38,720
And every address is now translated

2441
01:19:38,720 --> 01:19:39,800
with the page table, that you

2442
01:19:39,800 --> 01:19:40,520
set up.

2443
01:19:41,540 --> 01:19:42,590
And so what happens if the

2444
01:19:42,590 --> 01:19:44,320
page table setup incorrectly.

2445
01:19:44,840 --> 01:19:47,280
What would you, what might happen.

2446
01:19:53,650 --> 01:19:54,960
Anybody who wants to

2447
01:19:55,290 --> 01:19:56,790
say that answered or answered in

2448
01:19:56,790 --> 01:19:57,270
the chat,

2449
01:19:57,270 --> 01:19:58,120
you can wait.

2450
01:20:00,510 --> 01:20:02,520
You could override kernel data.

2451
01:20:02,980 --> 01:20:04,240
Yeah you could overwrite kernel data

2452
01:20:04,240 --> 01:20:05,020
what else could happen,

2453
01:20:05,020 --> 01:20:05,950
yeah page fault,

2454
01:20:05,950 --> 01:20:07,660
you basically do,

2455
01:20:07,720 --> 01:20:10,030
the mapping may be incorrect and

2456
01:20:10,030 --> 01:20:11,680
basically the address can be translated

2457
01:20:11,680 --> 01:20:12,010
at all,

2458
01:20:12,010 --> 01:20:13,150
and so the kernel can, you

2459
01:20:13,150 --> 01:20:14,650
know, the headware won't do it

2460
01:20:14,650 --> 01:20:15,820
and use the kernel there stops

2461
01:20:15,820 --> 01:20:16,620
and panics.

2462
01:20:18,760 --> 01:20:20,020
Does that make sense,

2463
01:20:20,020 --> 01:20:21,700
so if you get a bug

2464
01:20:21,700 --> 01:20:23,020
in your page tables.

2465
01:20:23,530 --> 01:20:24,490
You know you're going to see

2466
01:20:24,490 --> 01:20:28,020
these are errors or crashes.

2467
01:20:28,720 --> 01:20:29,080
And so,

2468
01:20:29,080 --> 01:20:30,370
one reason that exam the

2469
01:20:30,370 --> 01:20:31,300
next lab,

2470
01:20:31,300 --> 01:20:32,470
that page table lab, that

2471
01:20:32,470 --> 01:20:34,570
will hand out or release tonight,

2472
01:20:34,570 --> 01:20:35,980
is going to be hard,

2473
01:20:35,980 --> 01:20:37,150
because those kind of bugs will

2474
01:20:37,150 --> 01:20:37,840
show up.

2475
01:20:38,200 --> 01:20:39,820
If you're not careful enough for

2476
01:20:39,820 --> 01:20:42,420
you haven't fully internalized some aspect yet.

2477
01:20:42,520 --> 01:20:43,780
And you're basically going to

2478
01:20:43,780 --> 01:20:45,640
get kernel crash and

2479
01:20:45,640 --> 01:20:46,390
you're gonna have a hard

2480
01:20:46,390 --> 01:20:47,500
time when you will take

2481
01:20:47,500 --> 01:20:48,220
a little bit of time

2482
01:20:48,220 --> 01:20:50,050
and energy and detective work

2483
01:20:50,050 --> 01:20:51,460
to basically track down why

2484
01:20:51,460 --> 01:20:52,280
that happened.

2485
01:20:53,370 --> 01:20:55,860
And that's just the, that's just

2486
01:20:55,860 --> 01:20:57,860
part of like programming virtual memory.

2487
01:20:58,330 --> 01:20:59,170
Because it's such a

2488
01:20:59,170 --> 01:21:00,730
powerful primitive, you know, you

2489
01:21:00,730 --> 01:21:01,480
get it wrong,

2490
01:21:01,480 --> 01:21:02,780
you're gonna have

2491
01:21:03,470 --> 01:21:04,840
powerful consequences.

2492
01:21:08,090 --> 01:21:09,320
Yet the other hand is great

2493
01:21:09,320 --> 01:21:09,890
amount of fun,

2494
01:21:09,890 --> 01:21:10,760
so I don't want to end

2495
01:21:10,760 --> 01:21:12,560
on a negative note,

2496
01:21:12,560 --> 01:21:14,630
um, but all that will give

2497
01:21:14,630 --> 01:21:16,370
you a real understanding of actually

2498
01:21:16,370 --> 01:21:18,020
what really virtual memory is and

2499
01:21:18,020 --> 01:21:18,840
what it can do.

2500
01:21:20,180 --> 01:21:21,140
Okay I think I'm running

2501
01:21:21,140 --> 01:21:21,800
out of time so I'm

2502
01:21:21,800 --> 01:21:22,820
gonna stop here,

2503
01:21:22,820 --> 01:21:24,110
so people have time to

2504
01:21:24,110 --> 01:21:25,040
go to the next class or

2505
01:21:25,040 --> 01:21:26,060
next activity,

2506
01:21:26,060 --> 01:21:27,620
but if you have any questions

2507
01:21:27,620 --> 01:21:29,870
left, please hang on and

2508
01:21:29,870 --> 01:21:30,700
ask them.

2509
01:21:31,440 --> 01:21:32,550
And, um,

2510
01:21:32,550 --> 01:21:33,960
we'll see you on monday.

2511
01:21:35,360 --> 01:21:37,340
And good luck with finishing the

2512
01:21:37,340 --> 01:21:38,320
syscall lab.

2513
01:21:40,920 --> 01:21:42,630
Um, hi I have a question

2514
01:21:42,630 --> 01:21:44,190
about walk,

2515
01:21:44,190 --> 01:21:46,560
so it says and in

2516
01:21:46,560 --> 01:21:47,040
the code,

2517
01:21:47,040 --> 01:21:48,360
it returns the

2518
01:21:48,840 --> 01:21:52,360
like the first tables on PTE.

2519
01:21:52,480 --> 01:21:53,980
Yeah right,

2520
01:21:53,980 --> 01:21:56,020
um, but but how does

2521
01:21:56,020 --> 01:21:56,410
it work,

2522
01:21:56,410 --> 01:21:57,910
then like the other functions when

2523
01:21:57,910 --> 01:21:59,140
they expect

2524
01:21:59,450 --> 01:22:01,310
the actual PTE,

2525
01:22:01,310 --> 01:22:03,560
but like the physical address.

2526
01:22:05,690 --> 01:22:09,590
Yeah basically this returns the PTE

2527
01:22:09,590 --> 01:22:11,240
entry in the page table,

2528
01:22:12,100 --> 01:22:13,330
and the kernel can read or

2529
01:22:13,330 --> 01:22:14,680
write page table entries.

2530
01:22:15,070 --> 01:22:17,050
Um, and so now you can

2531
01:22:17,050 --> 01:22:19,200
stick values into the PTE.

2532
01:22:21,180 --> 01:22:22,560
And so maybe I can draw

2533
01:22:22,560 --> 01:22:24,640
a picture that is helpful.

2534
01:22:26,330 --> 01:22:27,160
Let's see.

2535
01:22:35,790 --> 01:22:36,780
So maybe we have a

2536
01:22:36,780 --> 01:22:37,980
page directory.

2537
01:22:45,000 --> 01:22:48,150
And, you know, this walk code,

2538
01:22:48,150 --> 01:22:49,350
so the page directory has

2539
01:22:49,350 --> 01:22:52,900
512 PTE in it.

2540
01:22:56,960 --> 01:22:57,800
Near zero,

2541
01:22:57,800 --> 01:23:00,560
here's 511 and basically what the

2542
01:23:00,560 --> 01:23:03,300
function does it returns a pointer

2543
01:23:03,410 --> 01:23:05,340
to one of these PTEs.

2544
01:23:06,040 --> 01:23:06,640
And so that's just a

2545
01:23:06,640 --> 01:23:07,600
virtual address,

2546
01:23:07,600 --> 01:23:08,620
and it points to that

2547
01:23:08,620 --> 01:23:09,740
particular PTE.

2548
01:23:10,220 --> 01:23:11,990
And now the kernel can, you

2549
01:23:11,990 --> 01:23:14,330
know manipulate that PTE, by whatever

2550
01:23:14,330 --> 01:23:15,680
writing values to it.

2551
01:23:16,010 --> 01:23:17,420
Like some physical address.

2552
01:23:17,820 --> 01:23:20,250
Maybe with some permissions or

2553
01:23:20,250 --> 01:23:21,180
into it for the top

2554
01:23:21,180 --> 01:23:22,320
bottom ten bits.

2555
01:23:23,730 --> 01:23:25,320
And then basically updates the page

2556
01:23:25,320 --> 01:23:26,130
table directory,

2557
01:23:26,130 --> 01:23:27,420
and then later on when you

2558
01:23:27,420 --> 01:23:29,540
load data into satp.

2559
01:23:29,810 --> 01:23:31,640
Now that affect that change will

2560
01:23:31,640 --> 01:23:32,660
go into effect.

2561
01:23:35,350 --> 01:23:36,480
Does that make sense.

2562
01:23:37,180 --> 01:23:38,440
Yeah that makes sense, I guess

2563
01:23:38,440 --> 01:23:39,880
I just confused like why does

2564
01:23:39,880 --> 01:23:41,560
it do the work of going

2565
01:23:41,560 --> 01:23:43,380
all the way to the third

2566
01:23:43,550 --> 01:23:46,010
page table and then only return

2567
01:23:46,010 --> 01:23:46,840
the first

2568
01:23:46,900 --> 01:23:49,450
PTE. No, return is actually the

2569
01:23:49,450 --> 01:23:50,440
bottom one.

2570
01:23:51,710 --> 01:23:53,510
Actually, let me be careful,

2571
01:23:55,340 --> 01:23:56,840
If, you know, it goes through

2572
01:23:56,840 --> 01:23:58,730
the n levels, started level 2

2573
01:23:58,730 --> 01:23:59,750
and then go to level 1,

2574
01:23:59,750 --> 01:24:01,120
again a level 0.

2575
01:24:01,730 --> 01:24:04,500
If the alloc bit set

2576
01:24:05,150 --> 01:24:06,920
and level doesn't exist,

2577
01:24:06,920 --> 01:24:08,930
it will create the intermediate page

2578
01:24:08,930 --> 01:24:09,980
table directory.

2579
01:24:10,580 --> 01:24:12,050
And zero it out and then

2580
01:24:12,050 --> 01:24:13,260
keep going to look.

2581
01:24:13,780 --> 01:24:16,300
So, you always end up

2582
01:24:16,300 --> 01:24:17,840
on the bottom PTE.

2583
01:24:18,580 --> 01:24:20,800
If alloc not set, you stop

2584
01:24:20,800 --> 01:24:22,750
at the first PTE, that doesn't

2585
01:24:22,750 --> 01:24:23,680
have value.

2586
01:24:25,550 --> 01:24:26,510
Okay, that makes sense,

2587
01:24:26,510 --> 01:24:27,800
this is the last one,

2588
01:24:27,800 --> 01:24:29,840
the actual on gonna have

2589
01:24:29,840 --> 01:24:31,880
okay okay,

2590
01:24:31,880 --> 01:24:32,880
thank you.

2591
01:24:36,850 --> 01:24:38,080
Any other questions.

2592
01:24:40,820 --> 01:24:42,740
Um, so I have a question,

2593
01:24:42,740 --> 01:24:45,590
basically everything made sense until

2594
01:24:45,590 --> 01:24:47,630
we mapped the virtual addresses

2595
01:24:47,630 --> 01:24:49,160
two of the kernel to

2596
01:24:49,160 --> 01:24:51,980
the physical addresses.

2597
01:24:53,800 --> 01:24:55,720
So my understanding is that

2598
01:24:55,720 --> 01:24:57,100
each process will have its

2599
01:24:57,100 --> 01:24:57,880
own page table,

2600
01:24:57,880 --> 01:24:59,380
which is also a three level

2601
01:24:59,380 --> 01:25:02,050
three which wraps its virtual addresses

2602
01:25:02,050 --> 01:25:03,730
to physical addresses,

2603
01:25:03,730 --> 01:25:06,190
but then we map the kernel

2604
01:25:06,190 --> 01:25:08,230
virtual addresses to physical addresses, I

2605
01:25:08,230 --> 01:25:09,760
don't think we accounted for the

2606
01:25:09,760 --> 01:25:11,220
actual three of them.

2607
01:25:11,810 --> 01:25:14,150
Virtual addresses of the kernel

2608
01:25:14,150 --> 01:25:17,330
or where other processes will have

2609
01:25:17,330 --> 01:25:19,320
their virtual addresses.

2610
01:25:19,380 --> 01:25:23,760
And I'm sorry virtual addresses like

2611
01:25:23,760 --> 01:25:25,940
the visual table trees and.

2612
01:25:26,200 --> 01:25:27,880
Whatever the page table tree points

2613
01:25:27,880 --> 01:25:30,430
at in the physical memory.

2614
01:25:30,430 --> 01:25:32,260
Yeah, so yeah so so you're

2615
01:25:32,260 --> 01:25:34,630
back, this is slide with kernel,

2616
01:25:35,870 --> 01:25:37,610
address based virtual kernel address

2617
01:25:37,610 --> 01:25:39,890
space and so when the kernel

2618
01:25:39,890 --> 01:25:41,060
allocates proc.

2619
01:25:41,370 --> 01:25:43,830
Um and page tables for

2620
01:25:43,830 --> 01:25:44,970
that particular process they're going

2621
01:25:44,970 --> 01:25:46,160
to be allocated

2622
01:25:46,260 --> 01:25:48,630
out of memory here, memory is

2623
01:25:48,630 --> 01:25:49,940
not being used yet.

2624
01:25:50,870 --> 01:25:52,430
And the kernel is going to

2625
01:25:52,430 --> 01:25:55,370
program, we'll probably allocate a

2626
01:25:55,370 --> 01:25:57,170
couple pages for the page table,

2627
01:25:57,170 --> 01:25:58,790
off the usual problem process and

2628
01:25:58,790 --> 01:26:00,340
will fill in the PTEs.

2629
01:26:01,460 --> 01:26:03,110
And at some point when the

2630
01:26:03,110 --> 01:26:04,800
kernel runs that process.

2631
01:26:04,900 --> 01:26:08,260
It will load the route,

2632
01:26:08,260 --> 01:26:10,540
physical address for those pages that

2633
01:26:10,540 --> 01:26:12,070
is allocated for that page table

2634
01:26:12,070 --> 01:26:14,200
or basically page table then built

2635
01:26:14,200 --> 01:26:15,880
into the satp register.

2636
01:26:16,650 --> 01:26:19,560
And at that point the processor

2637
01:26:19,560 --> 01:26:21,720
will run with the virtual address

2638
01:26:21,720 --> 01:26:23,460
base that the kernel constructed for

2639
01:26:23,460 --> 01:26:24,680
that particular process.

2640
01:26:27,140 --> 01:26:29,060
Um, so the kernel gave up

2641
01:26:29,060 --> 01:26:30,890
some of its memory,

2642
01:26:30,890 --> 01:26:32,270
for processes,

2643
01:26:32,270 --> 01:26:34,100
and then but then the virtual

2644
01:26:34,100 --> 01:26:36,470
space in theory is as big

2645
01:26:36,470 --> 01:26:38,640
for the process as

2646
01:26:38,740 --> 01:26:39,910
the kernel,

2647
01:26:39,910 --> 01:26:42,550
but in reality. It's really not

2648
01:26:42,550 --> 01:26:45,250
have a picture with the layout

2649
01:26:45,250 --> 01:26:46,330
of a virtual address space with

2650
01:26:46,330 --> 01:26:48,040
their usual level process and again

2651
01:26:48,040 --> 01:26:49,960
it goes from zero to MAXVA.

2652
01:26:51,930 --> 01:26:53,520
In the same way as the

2653
01:26:54,240 --> 01:26:56,100
kernel address space does and it's

2654
01:26:56,100 --> 01:26:57,120
basically has his own set of

2655
01:26:57,120 --> 01:26:58,770
page tables to map those trends

2656
01:26:58,770 --> 01:27:00,140
due to translation,

2657
01:27:00,500 --> 01:27:01,720
the kernel setup.

2658
01:27:03,200 --> 01:27:05,030
But we can't actually use all

2659
01:27:05,030 --> 01:27:06,530
of the MAXVA virtual.

2660
01:27:06,530 --> 01:27:07,580
No, we cannot.

2661
01:27:07,640 --> 01:27:09,720
If we run out of memory.

2662
01:27:11,620 --> 01:27:12,850
So many of the processes are

2663
01:27:12,850 --> 01:27:14,800
much much smaller, correct, than

2664
01:27:14,950 --> 01:27:16,800
all of the virtual address space.

2665
01:27:19,740 --> 01:27:21,360
I see thinking.

2666
01:27:23,250 --> 01:27:24,480
I've got a quick question,

2667
01:27:26,020 --> 01:27:27,100
Um, could you go back to

2668
01:27:27,100 --> 01:27:28,450
the walk code,

2669
01:27:28,450 --> 01:27:30,040
yeah yeah absolutely.

2670
01:27:31,490 --> 01:27:32,660
Um, it's one of my

2671
01:27:32,660 --> 01:27:34,680
favorite functions.

2672
01:27:35,290 --> 01:27:38,560
Um, so I guess, one

2673
01:27:38,560 --> 01:27:40,570
thing I'm confused about is after

2674
01:27:40,570 --> 01:27:41,800
you write to the satp

2675
01:27:41,800 --> 01:27:44,800
register can the kernel even access

2676
01:27:44,800 --> 01:27:46,750
physical addresses directly,

2677
01:27:46,750 --> 01:27:47,620
so it looks like in the

2678
01:27:47,620 --> 01:27:49,210
code that it's converting you know

2679
01:27:49,210 --> 01:27:50,260
like pay was being set to

2680
01:27:50,260 --> 01:27:51,250
a physical address,

2681
01:27:51,250 --> 01:27:53,500
but if satp is set,

2682
01:27:53,860 --> 01:27:55,960
won't that be interpreted as

2683
01:27:55,960 --> 01:27:57,580
a virtual address.

2684
01:27:57,580 --> 01:27:59,680
Yeah, um,

2685
01:27:59,680 --> 01:28:01,900
so, um okay so let's look

2686
01:28:01,900 --> 01:28:06,600
at hartinit.

2687
01:28:12,380 --> 01:28:14,720
kvm, so built in kernel address space.

2688
01:28:15,070 --> 01:28:17,860
The kernel page table,

2689
01:28:19,860 --> 01:28:23,280
Initially, the virtual physical, address

2690
01:28:23,280 --> 01:28:26,190
is translated to a physical

2691
01:28:26,190 --> 01:28:27,840
address and that's actually written into

2692
01:28:27,840 --> 01:28:29,300
the satp register.

2693
01:28:30,380 --> 01:28:32,360
Um, and at that point you

2694
01:28:32,360 --> 01:28:34,220
know we're running with the address

2695
01:28:34,220 --> 01:28:36,740
space that we've constructed right before

2696
01:28:36,740 --> 01:28:38,280
here, this kvminit.

2697
01:28:39,980 --> 01:28:41,480
And gave me a map is

2698
01:28:41,480 --> 01:28:44,700
basically nothing else than calling

2699
01:28:45,040 --> 01:28:47,710
walk for every address where

2700
01:28:47,710 --> 01:28:49,500
every page and at the range.

2701
01:28:50,340 --> 01:28:51,750
And so what was your question,

2702
01:28:53,660 --> 01:28:54,380
Um I guess,

2703
01:28:54,380 --> 01:28:56,810
it's does walks still work

2704
01:28:56,810 --> 01:28:57,680
the same way if you

2705
01:28:57,680 --> 01:28:59,480
call it after satp

2706
01:28:59,480 --> 01:29:02,160
is said. Yeah why.

2707
01:29:04,590 --> 01:29:06,900
Why we work out the reason

2708
01:29:06,900 --> 01:29:13,260
it won't work out the kernel set up in identity mapping.

2709
01:29:13,720 --> 01:29:15,100
Ok, right, right.

2710
01:29:15,100 --> 01:29:16,390
Very important,

2711
01:29:16,390 --> 01:29:18,580
very good question,

2712
01:29:18,580 --> 01:29:19,930
a lot of things just happened

2713
01:29:19,930 --> 01:29:21,130
to work out because actually the

2714
01:29:21,130 --> 01:29:23,040
identity mapping is set up.

2715
01:29:24,670 --> 01:29:27,310
I see I think that

2716
01:29:27,310 --> 01:29:27,610
makes sense,

2717
01:29:31,360 --> 01:29:33,220
I have a quick question.

2718
01:29:33,220 --> 01:29:36,340
Where the satp register stored

2719
01:29:36,340 --> 01:29:38,000
for all of the processes.

2720
01:29:38,480 --> 01:29:41,560
There only one satp per core.

2721
01:29:42,040 --> 01:29:44,260
Um, but in every proc structure.

2722
01:29:46,300 --> 01:29:48,280
If you look at proc.h.

2723
01:29:48,970 --> 01:29:49,840
Um, there is,

2724
01:29:52,740 --> 01:29:55,680
a pointer to the page table,

2725
01:29:55,680 --> 01:29:57,620
you're you're. okay, makes sense.

2726
01:29:58,460 --> 01:30:01,370
And also with regards to the

2727
01:30:01,370 --> 01:30:04,280
three page tables are like the

2728
01:30:04,280 --> 01:30:06,680
three tables that can complete the

2729
01:30:06,680 --> 01:30:08,060
full address and help you get

2730
01:30:08,060 --> 01:30:11,510
a full address for even something,

2731
01:30:11,510 --> 01:30:13,160
how does how is that better

2732
01:30:13,160 --> 01:30:15,500
I guess than than having one

2733
01:30:15,500 --> 01:30:17,120
giant page table I didn't really

2734
01:30:17,120 --> 01:30:20,090
fully understand what. A great question,

2735
01:30:20,090 --> 01:30:21,620
the reason is because in the

2736
01:30:21,620 --> 01:30:22,580
free level page table,

2737
01:30:22,580 --> 01:30:23,420
you can leave a lot of

2738
01:30:23,420 --> 01:30:24,460
entries empty.

2739
01:30:25,060 --> 01:30:26,920
So, for example if you leave

2740
01:30:26,920 --> 01:30:28,600
the entry in the top level

2741
01:30:28,600 --> 01:30:30,520
page table directly empty,

2742
01:30:30,520 --> 01:30:31,960
you don't have to create middle

2743
01:30:31,960 --> 01:30:33,910
level page tables or bottom level

2744
01:30:33,910 --> 01:30:35,120
page tables at all,

2745
01:30:35,150 --> 01:30:36,200
for those entries.

2746
01:30:37,070 --> 01:30:38,870
Like this means like a big

2747
01:30:38,870 --> 01:30:40,940
[swath] of the whole virtual address

2748
01:30:40,940 --> 01:30:42,230
space doesn't have to have any

2749
01:30:42,230 --> 01:30:43,400
mapping at all.

2750
01:30:44,890 --> 01:30:45,730
Okay, okay,

2751
01:30:45,730 --> 01:30:47,080
you don't have the table there,

2752
01:30:47,080 --> 01:30:48,240
it just doesn't exist.

2753
01:30:48,840 --> 01:30:49,230
I see,

2754
01:30:49,230 --> 01:30:52,500
basically allocating these chunks on demand

2755
01:30:52,500 --> 01:30:53,880
as volumes and types,

2756
01:30:53,880 --> 01:30:55,170
OK that makes sense,

2757
01:30:55,170 --> 01:30:56,880
yeah you're starting basically with three

2758
01:30:56,880 --> 01:30:58,410
page three pages namely,

2759
01:30:58,410 --> 01:30:59,490
one from the top level one

2760
01:30:59,490 --> 01:31:01,170
for, one intermediate one frame,

2761
01:31:01,170 --> 01:31:02,840
one bottom level.

2762
01:31:03,170 --> 01:31:03,740
And then,

2763
01:31:03,740 --> 01:31:05,090
as you go you create more

2764
01:31:05,090 --> 01:31:06,500
page table directories.

2765
01:31:06,750 --> 01:31:07,680
Okay, okay,

2766
01:31:09,140 --> 01:31:10,400
Cool, thank you so much.

2767
01:31:10,400 --> 01:31:11,220
You're welcome.

2768
01:31:12,930 --> 01:31:14,180
Any more questions.

2769
01:31:14,670 --> 01:31:16,020
I'm sorry I have another one,

2770
01:31:16,020 --> 01:31:18,270
it's really really small but

2771
01:31:18,270 --> 01:31:21,000
I'm in the vm.c

2772
01:31:21,000 --> 01:31:26,280
on line 43, 41,

2773
01:31:26,280 --> 01:31:28,380
um, it says that,

2774
01:31:28,820 --> 01:31:30,080
no, mignt 43,

2775
01:31:30,080 --> 01:31:30,680
my bad,

2776
01:31:30,680 --> 01:31:35,800
um, it says physical stop minus (uint64)etext

2777
01:31:35,800 --> 01:31:38,020
but wouldn't that,

2778
01:31:38,370 --> 01:31:40,580
would not go over the,

2779
01:31:41,100 --> 01:31:43,260
I guess the memory that

2780
01:31:43,260 --> 01:31:46,020
we shouldn't touch, I don't

2781
01:31:46,020 --> 01:31:47,070
know if that makes sense,

2782
01:31:47,070 --> 01:31:48,340
but,

2783
01:31:48,540 --> 01:31:50,240
Would that go.

2784
01:31:51,210 --> 01:31:53,130
I guess I don't understand, would

2785
01:31:53,130 --> 01:31:54,920
they go over free memory.

2786
01:31:55,790 --> 01:31:58,820
No, I don't think so,

2787
01:31:58,820 --> 01:32:03,680
so KERNBASE is 0x8000, right

2788
01:32:03,680 --> 01:32:05,800
so that's the beginning of memory.

2789
01:32:06,070 --> 01:32:09,400
Kernel sits there in,

2790
01:32:09,430 --> 01:32:11,320
basically,

2791
01:32:12,470 --> 01:32:14,340
this thing is a size,

2792
01:32:15,070 --> 01:32:16,450
right, so etext is the

2793
01:32:16,450 --> 01:32:18,280
last address of the kernel,

2794
01:32:18,280 --> 01:32:20,200
subtract KERNBASE, that basically gives

2795
01:32:20,200 --> 01:32:21,800
you the size of the kernel,

2796
01:32:22,730 --> 01:32:26,160
im, in byte.

2797
01:32:26,490 --> 01:32:28,140
And, you know, I don't know how

2798
01:32:28,140 --> 01:32:30,570
much it is, but it's

2799
01:32:30,570 --> 01:32:31,800
like you know 60 or 90

2800
01:32:31,800 --> 01:32:33,460
pages or something like that.

2801
01:32:33,990 --> 01:32:35,580
Um, and so this map

2802
01:32:35,580 --> 01:32:36,870
is basically the text part

2803
01:32:36,870 --> 01:32:37,760
of the kernel.

2804
01:32:38,350 --> 01:32:41,170
Um, and um,

2805
01:32:41,170 --> 01:32:42,640
and there's enough space.

2806
01:32:43,290 --> 01:32:45,330
Um, there's enough DRAM there to

2807
01:32:45,330 --> 01:32:48,460
map that the kernel text.

2808
01:32:48,830 --> 01:32:49,730
I'm not sure, I'm answering

2809
01:32:49,730 --> 01:32:50,240
your question,

2810
01:32:50,240 --> 01:32:53,030
but. I think I think

2811
01:32:53,030 --> 01:32:53,840
I understand.

2812
01:32:54,030 --> 01:32:56,670
I thought that etext starts

2813
01:32:56,670 --> 01:32:57,960
somewhere else, okay I think I

2814
01:32:57,960 --> 01:32:58,500
understand now,

2815
01:32:58,500 --> 01:32:59,250
thank you,

2816
01:32:59,250 --> 01:33:01,080
So etext basically the last instruction,

2817
01:33:01,080 --> 01:33:02,310
the address of the last instruction

2818
01:33:02,310 --> 01:33:03,080
of the kernel.

2819
01:33:03,690 --> 01:33:04,720
Okay, okay.
