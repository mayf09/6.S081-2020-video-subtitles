1
00:00:00,000 --> 00:00:02,430
For folks already signed in,


2
00:00:03,100 --> 00:00:07,180
whose curiosity how you experience being with the traps lab.


3
00:00:08,200 --> 00:00:11,380
If you already started on the lazy allocation lab,


4
00:00:11,380 --> 00:00:12,490
how's that going.


5
00:00:13,810 --> 00:00:18,670
Hear when I was was less painful than the page table lab.


6
00:00:20,580 --> 00:00:23,400
Andrew You, you want to say something about that.


7
00:00:32,000 --> 00:00:34,040
I thought the traps lab was OK,


8
00:00:35,030 --> 00:00:38,620
It was just making sure that


9
00:00:38,980 --> 00:00:43,270
I actually use the trampoline page properly was a little annoying.


10
00:00:43,720 --> 00:00:44,170
Yep.


11
00:00:44,410 --> 00:00:45,640
But once I figured that out,


12
00:00:45,640 --> 00:00:47,560
then then it just kind of worked.


13
00:00:47,770 --> 00:00:48,670
Good good, yeah,


14
00:00:48,670 --> 00:00:50,140
I did the whole goal was lab [us],


15
00:00:50,140 --> 00:00:57,140
you really expose you to the trap handling entry and exit.


16
00:01:01,990 --> 00:01:03,280
How about Amir,


17
00:01:03,490 --> 00:01:05,440
how was your experience with the trap lab.


18
00:01:08,180 --> 00:01:12,410
I thought that traps lab was good,


19
00:01:12,440 --> 00:01:17,150
very much more manageable than the page table lab.


20
00:01:17,620 --> 00:01:20,140
I noticed that there were opportunities


21
00:01:20,140 --> 00:01:22,570
to be clever about some aspects of the implementation


22
00:01:22,570 --> 00:01:23,410
which was nice


23
00:01:23,890 --> 00:01:28,750
and lazy lab is good so far debugging.


24
00:01:29,560 --> 00:01:32,170
But both better than the page table in my opinion.


25
00:01:32,410 --> 00:01:34,210
Glad to hear that,


26
00:01:34,240 --> 00:01:35,470
I'm sure you were glad to hear that,


27
00:01:35,470 --> 00:01:37,060
but I'm glad to hear it too.


28
00:01:40,480 --> 00:01:42,220
How about Timmy []?


29
00:01:44,180 --> 00:01:50,330
Yeah these two previous labs have been a lot better than the page table.


30
00:01:51,950 --> 00:01:55,890
I guess, the hardest part for the lazy lab,


31
00:01:55,890 --> 00:02:01,810
the lazy one was the read and write and all that stuff,


32
00:02:01,900 --> 00:02:04,870
but it's not it's not that bad in my opinion.


33
00:02:05,800 --> 00:02:06,280
Okay.


34
00:02:11,480 --> 00:02:12,380
How do Catherine,


35
00:02:13,010 --> 00:02:16,160
was the traps lab or the lazy lab for you


36
00:02:16,520 --> 00:02:19,180
in comparison to the page table lab.


37
00:02:33,340 --> 00:02:35,380
Are you there, Katherine, Katherine Weeks.


38
00:02:36,600 --> 00:02:37,890
Hello, I'm doing well,


39
00:02:37,920 --> 00:02:40,320
sorry I didn't know which Catherine you're talking to,


40
00:02:40,320 --> 00:02:41,370
I guess there's only twenty people,


41
00:02:41,370 --> 00:02:44,160
so you're probably not likely that there's another one.


42
00:02:45,420 --> 00:02:46,350
I'm doing quite well.


43
00:02:46,950 --> 00:02:47,940
Good good,


44
00:02:47,940 --> 00:02:51,030
so this lab is less painful than the pagetable lab or.


45
00:02:51,030 --> 00:02:52,950
Yeah, it's definitely less painful.


46
00:02:55,420 --> 00:02:55,960
Excellent.


47
00:02:56,260 --> 00:02:56,740
Yeah.


48
00:02:57,470 --> 00:02:58,310
Yeah.


49
00:02:59,420 --> 00:03:03,050
The the one the one after page tables,


50
00:03:03,050 --> 00:03:06,620
what was that traps, that was definitely much simpler.


51
00:03:09,300 --> 00:03:11,400
OK great, we're glad to hear that,


52
00:03:11,400 --> 00:03:13,680
I just wanted to get an informal poll see,


53
00:03:14,480 --> 00:03:17,030
you know the page table turned out harder than we thought it would,


54
00:03:17,090 --> 00:03:20,180
and so, like you know these ones are better.


55
00:03:20,810 --> 00:03:24,440
OK, so what do we get going .


56
00:03:24,800 --> 00:03:27,950
And welcome to the next lecture in 6.S081,


57
00:03:28,370 --> 00:03:29,480
wherever you are,


58
00:03:29,690 --> 00:03:32,630
so the topic in today is about interrupts,


59
00:03:32,690 --> 00:03:35,780
before jumping into sort of talking about interrupts,


60
00:03:35,960 --> 00:03:38,420
I wanted to share a little bit one thing,


61
00:03:38,420 --> 00:03:39,740
that I wanted to talk about,


62
00:03:39,740 --> 00:03:42,350
last week which I didn't get around to it through.


63
00:03:42,780 --> 00:03:44,730
And you know what you might find interesting.


64
00:03:47,840 --> 00:03:49,940
Let me see, if I can get my right screen,


65
00:03:49,940 --> 00:03:50,600
here up,


66
00:03:50,870 --> 00:03:51,680
so here ,


67
00:03:52,400 --> 00:03:55,100
you know you see my screen here on the bottom left,


68
00:03:55,370 --> 00:04:00,650
I'm actually logged into Athena through the dialogue machines.


69
00:04:01,180 --> 00:04:04,300
And there's a couple things I wanted to talk about,


70
00:04:04,390 --> 00:04:07,150
in terms of how memory is being used


71
00:04:07,180 --> 00:04:08,830
by a real operating system.


72
00:04:09,540 --> 00:04:11,130
Since we talked a lot about that last week,


73
00:04:11,130 --> 00:04:12,120
particularly the end of the lecture,


74
00:04:12,120 --> 00:04:13,170
a lot of questions about,


75
00:04:13,470 --> 00:04:17,250
you know page out, finding free memory and all that kind of stuff.


76
00:04:17,990 --> 00:04:20,750
So this is one of Athena machines,


77
00:04:20,810 --> 00:04:22,640
you're wanting to note,


78
00:04:22,640 --> 00:04:24,440
if you look at the memory line,


79
00:04:24,860 --> 00:04:29,360
it actually tells you how much the program running is called top,


80
00:04:29,990 --> 00:04:31,190
probably many of you have used it,


81
00:04:31,550 --> 00:04:34,460
you see how much machine memories in a machine


82
00:04:34,460 --> 00:04:35,030
as you can see,


83
00:04:35,030 --> 00:04:38,120
there's a quite a bit of memory in in this machine.


84
00:04:38,520 --> 00:04:41,670
And if you look a little bit carefully,


85
00:04:41,670 --> 00:04:45,800
actually most of it is used, right.


86
00:04:45,830 --> 00:04:50,180
The you know, a large part of the memory is actually not being used by applications,


87
00:04:50,180 --> 00:04:51,830
but actually used by the buffer cache.


88
00:04:52,410 --> 00:04:54,900
I said this is quite common in an operating system,


89
00:04:54,900 --> 00:04:58,980
you don't really want to leave your physical memory, sitting idle and do nothing,


90
00:04:59,190 --> 00:05:00,840
you might as well use it for something useful,


91
00:05:01,020 --> 00:05:02,070
and so in this case,


92
00:05:02,070 --> 00:05:06,060
use a good chunk of it is actually used for a buffer cache.


93
00:05:06,790 --> 00:05:10,390
A little bit of memory, free, not much,


94
00:05:10,780 --> 00:05:14,980
you know fraction of the total memory that actually in a machine


95
00:05:14,980 --> 00:05:16,690
and so this is a very common case,


96
00:05:16,690 --> 00:05:18,580
like most operating systems run.


97
00:05:19,080 --> 00:05:22,590
We basically almost no memory free at any particular instant in time.


98
00:05:23,620 --> 00:05:28,480
And so that means, for example, if an application or the kernel needs some memory


99
00:05:28,600 --> 00:05:30,250
and we'll have to throw out something,


100
00:05:30,370 --> 00:05:33,070
you know, maybe that's enough for a few pages


101
00:05:33,070 --> 00:05:34,660
where a handful of pages,


102
00:05:34,660 --> 00:05:36,460
but at some point it needs a lot of free memory,


103
00:05:36,520 --> 00:05:39,220
it will ask to evict something either from the applications


104
00:05:39,220 --> 00:05:40,360
or from the buffer cache.


105
00:05:41,380 --> 00:05:43,750
And so you know sort of the main point here


106
00:05:43,750 --> 00:05:46,210
basically is that here, when the kernel makes allocate memory,


107
00:05:46,210 --> 00:05:48,370
it's actually not generally not a cheap operation,


108
00:05:48,370 --> 00:05:49,630
because the memory is not,


109
00:05:50,400 --> 00:05:52,170
there's not a ton of memory free available.


110
00:05:53,270 --> 00:05:55,010
The other thing that's sort of interesting to look at is


111
00:05:55,010 --> 00:06:01,160
I sorted the output of top by the amount of resident memory.


112
00:06:01,660 --> 00:06:03,760
So you're looking at every line,


113
00:06:03,760 --> 00:06:08,020
for every process you see that, this is size of address space


114
00:06:08,290 --> 00:06:11,470
and then the next line actually tells you how much memory is actually being used


115
00:06:11,470 --> 00:06:12,760
like the amount of physical memory,


116
00:06:12,760 --> 00:06:16,850
you know, how the fraction of the address space actually is in physical memory,


117
00:06:17,240 --> 00:06:21,410
and as you can see it actually it's typically way smaller than the address space


118
00:06:21,440 --> 00:06:26,450
and so the tricks that we talked about last word, cool ideas and virtual memory,


119
00:06:26,450 --> 00:06:28,880
provides are being used here


120
00:06:28,880 --> 00:06:30,140
like demand paging,


121
00:06:30,380 --> 00:06:35,330
the shared column is shared pages, you know from the shared libraries


122
00:06:35,600 --> 00:06:36,740
and you see in general that


123
00:06:36,740 --> 00:06:42,580
basically the the resident memory is much much much smaller than the virtual address space.


124
00:06:43,740 --> 00:06:46,170
Maybe a couple other interesting things to note


125
00:06:46,200 --> 00:06:48,060
are just looking at this machine,


126
00:06:48,270 --> 00:06:49,410
the load is very low,


127
00:06:49,440 --> 00:06:53,100
even though they're a hundred twenty users and 102 users logged in.


128
00:06:53,620 --> 00:06:57,400
And you're gonna see there's a lot of processes,


129
00:06:57,400 --> 00:07:00,310
you know 950 or roughly,


130
00:07:00,550 --> 00:07:04,690
[] to note exactly how long the machine has been up, like 249 days,


131
00:07:05,080 --> 00:07:09,340
you're actually [ships] kernel is probably not up that long at all ever.


132
00:07:12,780 --> 00:07:15,000
Okay, so that's you know any questions about this,


133
00:07:15,000 --> 00:07:19,100
just sort of , you know the main point being that most memories in use


134
00:07:19,100 --> 00:07:23,030
and the resident memory is typically much smaller than the virtual address space.


135
00:07:27,420 --> 00:07:28,890
You're [going] to run this yourself,


136
00:07:28,890 --> 00:07:31,020
if you want to see you actually what's up.


137
00:07:33,360 --> 00:07:34,080
Any questions?


138
00:07:35,750 --> 00:07:39,230
You see some of the 6.S081 students being logged in


139
00:07:39,230 --> 00:07:41,630
and if you look around you see a whole bunch of QEMU running.


140
00:07:43,410 --> 00:07:46,250
Okay, no questions.


141
00:07:46,280 --> 00:07:49,970
Let me go back to the topic for today, which is interrupts.


142
00:07:52,270 --> 00:07:56,800
And the basic, you know, the basic idea is really straightforward,


143
00:07:56,830 --> 00:07:59,350
what we want to enable is that ,


144
00:07:59,970 --> 00:08:03,270
there's going to be cases where the hardware wants attention,


145
00:08:06,810 --> 00:08:07,950
wants to attention now.


146
00:08:10,800 --> 00:08:12,690
You know a packet comes in from the network


147
00:08:12,720 --> 00:08:17,760
and so the network Internet network card generates an interrupt ,


148
00:08:17,760 --> 00:08:22,920
user typed a key on the keyboard and the keyboard generates an interrupt.


149
00:08:23,490 --> 00:08:26,190
And you know what the software has to do,


150
00:08:26,520 --> 00:08:29,550
if the software has to save its work,


151
00:08:29,580 --> 00:08:31,410
whatever it was doing right now,


152
00:08:32,990 --> 00:08:34,220
put it on the side.


153
00:08:35,130 --> 00:08:36,570
You know process, the interrupt,


154
00:08:41,660 --> 00:08:45,430
and then resume or restore, into the work that is doing.


155
00:08:51,020 --> 00:08:58,640
And, basically that saving and restoring is very very similar to the mechanisms


156
00:08:58,640 --> 00:08:59,990
that we already have seen before,


157
00:08:59,990 --> 00:09:08,950
namely for system calls. and traps, like page fault,


158
00:09:09,040 --> 00:09:11,050
they all use the same mechanism.


159
00:09:18,920 --> 00:09:21,590
So in that sense, you know interrupts are no different whatever,


160
00:09:21,710 --> 00:09:24,710
compared to traps or you know system calls,


161
00:09:24,710 --> 00:09:27,620
but a couple things that make them a little bit different


162
00:09:27,620 --> 00:09:29,780
and why we're actually spending a lecture on them.


163
00:09:30,360 --> 00:09:31,950
So the three basically thinks


164
00:09:32,100 --> 00:09:38,850
that make interrupts, slightly different from system calls and exceptions,


165
00:09:38,850 --> 00:09:42,480
one, with a better word, I'm gonna call they're asynchronous.


166
00:09:46,310 --> 00:09:48,380
And with that I mean that,


167
00:09:48,440 --> 00:09:50,030
the system called,


168
00:09:50,030 --> 00:09:53,090
the interrupt happens when the hardware actually generate an interrupt


169
00:09:53,090 --> 00:09:54,740
and the interrupt handler runs,


170
00:09:54,980 --> 00:09:59,900
the interrupt handler might actually have nothing to do with the current running process on the CPU.


171
00:10:00,420 --> 00:10:02,790
So, unlike for example where you do a system call


172
00:10:02,790 --> 00:10:04,140
or when the system call happens


173
00:10:04,140 --> 00:10:05,610
and then you jump into the kernel


174
00:10:05,760 --> 00:10:08,700
then we're running in the context of the calling process.


175
00:10:09,220 --> 00:10:11,080
And this is not true with interrupt,


176
00:10:11,170 --> 00:10:14,890
they might have been completely unrelated to actually a process


177
00:10:14,890 --> 00:10:18,010
that you know who's running in the CPU might actually have nothing to do


178
00:10:18,010 --> 00:10:19,990
with the interrupt handler may not even if cost.


179
00:10:21,000 --> 00:10:22,260
So that's different.


180
00:10:22,380 --> 00:10:23,310
Second of all,


181
00:10:23,980 --> 00:10:28,840
there is a much more concurrency than we have seen so far,


182
00:10:28,840 --> 00:10:35,640
in fact, you know, so this is a starting place where talking about concurrency


183
00:10:35,790 --> 00:10:38,730
and we'll talk about it on Wednesday lecture a lot more ,


184
00:10:38,730 --> 00:10:40,020
the basic observation is that,


185
00:10:40,020 --> 00:10:45,030
basically the CPU and the device that generated in, this operate in parallel,


186
00:10:45,060 --> 00:10:47,220
you know the UART with a network card,


187
00:10:47,220 --> 00:10:50,850
you know just doing its thing you know picking packets from the network,


188
00:10:51,060 --> 00:10:52,860
and then at some point generating an interrupt.


189
00:10:53,240 --> 00:10:56,330
And at the same time, the CPU is running and also is doing its own thing,


190
00:10:56,360 --> 00:11:00,650
so we have true parallelism, going on between the device and the CPU


191
00:11:00,650 --> 00:11:04,190
and we have to manage that parallelism as we'll see in a second.


192
00:11:05,450 --> 00:11:10,280
And finally, I'm going to focus mostly on external devices,


193
00:11:10,280 --> 00:11:11,870
like network cards and UART


194
00:11:12,020 --> 00:11:13,400
and those have to be programmed.


195
00:11:21,310 --> 00:11:24,850
And basically every device has [with] its own programming manual,


196
00:11:24,850 --> 00:11:26,080
in the same way that


197
00:11:26,080 --> 00:11:30,400
RISC-V has manual with instructions and which registers do what,


198
00:11:30,760 --> 00:11:34,030
every device actually has a similar type manual,


199
00:11:34,270 --> 00:11:37,960
with you know describing what register it has,


200
00:11:37,990 --> 00:11:39,940
what operations you can conform,


201
00:11:39,970 --> 00:11:43,600
what the device does come in response to reading and writing control registers.


202
00:11:44,380 --> 00:11:51,850
Unfortunately often the manuals for the devices are less clear than the RISC-V manual


203
00:11:52,030 --> 00:11:55,780
and which makes a complex programming even more complicated.


204
00:11:56,820 --> 00:12:00,300
And so what I'm gonna do in this lecture is actually pretty straightforward,


205
00:12:00,510 --> 00:12:06,600
if you want to talk about how the [front] shows up,


206
00:12:06,780 --> 00:12:11,940
when you know the shell prompt and then if you type ls,


207
00:12:12,240 --> 00:12:15,810
you know how do these characters get read


208
00:12:15,810 --> 00:12:17,760
and actually then being displayed in the console


209
00:12:17,790 --> 00:12:21,000
and in fact, so basically the rest of these lectures about these three characters,


210
00:12:21,880 --> 00:12:27,130
um, you know, but all the mechanism, that's necessary to actually make that happen.


211
00:12:28,550 --> 00:12:32,630
Any questions so far, before I [extract] diving a little deeper.


212
00:12:38,470 --> 00:12:40,210
Okay .


213
00:12:41,850 --> 00:12:45,930
So the first question maybe to ask is where did the interrupts come from.


214
00:13:00,330 --> 00:13:05,090
And, so so we're going to be focusing mostly this lecture on external interrupts,


215
00:13:05,090 --> 00:13:07,490
you not timer interrupts or software interrupts,


216
00:13:07,760 --> 00:13:11,720
you know the external interrupts come from devices that are sitting on the board


217
00:13:11,810 --> 00:13:15,290
and here are a SiFive board,


218
00:13:15,290 --> 00:13:18,170
that QEMU more or less animates,


219
00:13:18,170 --> 00:13:20,900
you know there's some small modifications ,


220
00:13:21,140 --> 00:13:24,380
and we see there's actually you look around from this board,


221
00:13:24,440 --> 00:13:27,080
there's a lot of actually different devices there,


222
00:13:27,350 --> 00:13:28,850
can be connected to this board,


223
00:13:29,030 --> 00:13:31,360
here are Ethernet connector,


224
00:13:31,540 --> 00:13:35,860
in fact here's MicroUSB, that's over there,


225
00:13:36,100 --> 00:13:38,320
there's a MicroSD card,


226
00:13:38,620 --> 00:13:41,290
you know reset buttons


227
00:13:41,290 --> 00:13:46,810
and so there are all kinds of lines that must be running running from those devices into the CPU.


228
00:13:47,500 --> 00:13:49,150
And most of this lecture is basically sort of


229
00:13:49,150 --> 00:13:51,160
understanding, you know what happens,


230
00:13:51,160 --> 00:13:56,440
you know at the CPU when a device generates an interrupt


231
00:13:56,440 --> 00:13:59,080
and how to read and write the information from the device.


232
00:13:59,760 --> 00:14:06,050
I believe like these lower two pins here, at this expansion connector,


233
00:14:06,050 --> 00:14:12,690
I think one of them is UART, is the UART sent for transmission


234
00:14:12,720 --> 00:14:20,180
and the other one is the UART0 receive Re.


235
00:14:21,690 --> 00:14:23,820
And I think it's actually connected to both sides,


236
00:14:23,820 --> 00:14:26,040
the micro usb as well as through this extension cord,


237
00:14:26,040 --> 00:14:27,900
and I think the UART chip itself,


238
00:14:28,020 --> 00:14:31,870
you might actually be inside of this chip over there.


239
00:14:37,720 --> 00:14:43,120
Okay so, so basically there are a bunch of lines running on the board,


240
00:14:43,120 --> 00:14:44,320
you know into the CPU,


241
00:14:44,620 --> 00:14:48,070
you know we go zoom in a little bit more in detail in the CPU,


242
00:14:48,620 --> 00:14:56,640
use a schema from the you know, SiFive documentation for the board


243
00:14:56,640 --> 00:15:00,540
or the processor of the board were RISC-V processor using,


244
00:15:00,930 --> 00:15:02,940
we looked at this a little bit before,


245
00:15:03,210 --> 00:15:05,400
you know see here basically,


246
00:15:05,400 --> 00:15:08,220
here are the devices on the right side,


247
00:15:08,220 --> 00:15:13,050
here UART0 and we know that basically that UART0 memory


248
00:15:13,050 --> 00:15:15,690
maps somewhere in the physical address space.


249
00:15:16,140 --> 00:15:18,720
Like all the DRAM on this site,


250
00:15:18,720 --> 00:15:22,410
we know we know the DRAM sits above 0x8 zero zero zero


251
00:15:22,410 --> 00:15:25,980
and below eight zero they are different devices.


252
00:15:26,610 --> 00:15:28,800
Basically with load and store instructions,


253
00:15:28,800 --> 00:15:33,060
you know to those , to those physical addresses,


254
00:15:33,060 --> 00:15:34,500
we can actually program that UART,


255
00:15:34,560 --> 00:15:36,690
look at that in much more detail in a second.


256
00:15:37,800 --> 00:15:40,710
All the devices can basically coming to the processor


257
00:15:40,830 --> 00:15:46,070
and really what happens is this platform level inter- interrupt controller,


258
00:15:46,070 --> 00:15:47,810
which is called PLIC for short,


259
00:15:48,430 --> 00:15:50,890
is the one that sort of general managers,


260
00:15:50,890 --> 00:15:54,970
the interrupts coming in, you know, from external devices.


261
00:15:55,670 --> 00:15:57,590
And so if we zoom in a little bit more,


262
00:15:57,980 --> 00:16:04,760
here's a diagram of the the PLIC in on chip devices,


263
00:16:04,760 --> 00:16:10,460
so here we see there's you know 53 interrupt lines coming in from different devices.


264
00:16:10,980 --> 00:16:13,140
Probably, devices [on] interrupt line,


265
00:16:13,140 --> 00:16:16,890
they come into the PLIC and the PLIC and route interrupts.


266
00:16:24,410 --> 00:16:27,050
So, for example you know depending ,


267
00:16:27,050 --> 00:16:29,030
so here are our particular cores,


268
00:16:29,970 --> 00:16:31,740
here in our way, we run it,


269
00:16:31,740 --> 00:16:34,380
we run a free core


270
00:16:34,380 --> 00:16:37,980
and basically you know the PLIC can be programmed,


271
00:16:38,130 --> 00:16:40,560
so that the PLIC will raise interrupts to,


272
00:16:40,560 --> 00:16:43,080
you know, one of these cores or to the first core,


273
00:16:43,080 --> 00:16:45,330
that can take an interrupt


274
00:16:45,330 --> 00:16:47,040
and there's a bit of flexibility.


275
00:16:47,760 --> 00:16:50,550
And if none of the cores can take an interrupted at this point,


276
00:16:50,550 --> 00:16:52,020
for example they have disabled interrupts,


277
00:16:52,020 --> 00:16:54,300
because their processing another interrupt


278
00:16:54,390 --> 00:16:57,390
and the PLIC will just hold that interrupt


279
00:16:57,390 --> 00:17:00,930
until [across] the processor is available to take you interrupt.


280
00:17:02,130 --> 00:17:04,410
So the PLIC has some internal state,


281
00:17:04,410 --> 00:17:06,330
you know to keep track of that.


282
00:17:06,930 --> 00:17:09,000
If you saw the documentation a little bit,


283
00:17:09,000 --> 00:17:11,460
in a way you know real things are happening is the PLIC,


284
00:17:11,460 --> 00:17:13,620
indicates that their [] interrupt,


285
00:17:13,650 --> 00:17:16,110
pending one of the cores,


286
00:17:16,110 --> 00:17:17,490
you know basically claims it,


287
00:17:17,850 --> 00:17:21,720
so that will tell the PLIC not to give to any other core


288
00:17:21,870 --> 00:17:23,670
and once the core is completely done,


289
00:17:23,670 --> 00:17:26,370
with it will say OK I'm done with this particular interrupt


290
00:17:26,370 --> 00:17:28,620
and you know the PLIC will,


291
00:17:28,920 --> 00:17:33,000
inform the PLIC that [] this can forget about this interrupt.


292
00:17:35,770 --> 00:17:37,000
Any questions about this.


293
00:17:37,730 --> 00:17:42,220
There's sort of the internal RISC-V interrupt structure.


294
00:17:44,140 --> 00:17:47,620
Yeah, so when each core holds the PLIC,


295
00:17:47,650 --> 00:17:51,670
does the PLIC have some enforcement mechanism to ensure fairness.


296
00:17:52,520 --> 00:17:54,980
It is all up to the kernel


297
00:17:55,040 --> 00:17:58,640
to program the PLIC in whatever way it wants.


298
00:17:59,330 --> 00:18:01,490
You know PLIC doesn't really,


299
00:18:01,670 --> 00:18:05,120
choosing service of delivering interrupted writing done,


300
00:18:05,120 --> 00:18:09,980
but it takes the kernel programs [deploy compels] where interrupts should be delivered, etc.


301
00:18:10,460 --> 00:18:12,680
In fact, you know interrupts with priorities,


302
00:18:12,740 --> 00:18:16,700
the kernel could decide which interrupt is more important than another interrupt ,


303
00:18:16,700 --> 00:18:18,320
there's a huge amount of flexibility.


304
00:18:26,370 --> 00:18:28,230
Any other questions about the hardware.


305
00:18:33,930 --> 00:18:34,560
Okay.


306
00:18:37,640 --> 00:18:39,380
Okay, so that's the hardware side of it,


307
00:18:39,470 --> 00:18:43,370
yeah let's talk a little bit you know, at a high level about the software side.


308
00:18:44,360 --> 00:18:50,150
So, typically the code that manages devices called the driver.


309
00:19:00,230 --> 00:19:04,730
And you know basically as just just code,


310
00:19:04,760 --> 00:19:09,140
you know typically enforcing the kernels will be looking at C code


311
00:19:09,260 --> 00:19:13,580
and xv6, you know all the drivers are inside of the kernel


312
00:19:13,820 --> 00:19:19,800
and in the code, you know basically managing where the drivers


313
00:19:20,070 --> 00:19:21,810
are all inside of the kernel.


314
00:19:22,580 --> 00:19:25,880
And so we got one we're gonna be looking a little bit today,


315
00:19:25,880 --> 00:19:29,870
you know uart.c is the driver for uart chip.


316
00:19:30,860 --> 00:19:34,100
And if you look at the structure,


317
00:19:34,310 --> 00:19:37,100
internal structure of the that code,


318
00:19:37,100 --> 00:19:40,670
you know most drivers have a structure.


319
00:19:41,350 --> 00:19:42,640
Yeah I'm gonna draw this,


320
00:19:42,940 --> 00:19:44,140
not as an address space,


321
00:19:44,140 --> 00:19:45,670
are not intending to be using address space,


322
00:19:45,670 --> 00:19:51,030
but typically when people talk about drivers there's a bottom part and the top part.


323
00:19:54,500 --> 00:19:57,590
And basically the bottom part is the interrupt handler.


324
00:20:03,080 --> 00:20:05,510
So when an interrupt handler, when an interrupt comes in,


325
00:20:05,540 --> 00:20:09,380
you know the processor, the CPU has interruption enabled ,


326
00:20:09,380 --> 00:20:11,000
the interrupt will fire,


327
00:20:11,000 --> 00:20:13,610
you know, the processor will seeing the second


328
00:20:13,610 --> 00:20:17,240
will actually call the interrupt handler for that device


329
00:20:17,330 --> 00:20:19,070
basically calls into the code here.


330
00:20:19,910 --> 00:20:22,610
And the interrupt handler just runs in,


331
00:20:22,610 --> 00:20:27,080
run in any context of any specific process,


332
00:20:27,080 --> 00:20:31,040
you know just you know process, just process the enter a interrupt.


333
00:20:32,240 --> 00:20:35,690
The top part, if you will the driver is


334
00:20:35,690 --> 00:20:39,500
where user processes or you know the rest of the kernel calls into


335
00:20:39,500 --> 00:20:42,230
for example and the console case great [] where you are.


336
00:20:42,840 --> 00:20:44,460
There's read write interface,


337
00:20:46,320 --> 00:20:53,260
that actually, as a higher level code actually calls into


338
00:20:53,680 --> 00:20:57,400
and so typically cases actually there's some [queue] often in the driver


339
00:20:57,610 --> 00:21:05,890
and you know top level code, you know calls in sticks, you know characters into into this [queue]


340
00:21:05,890 --> 00:21:10,360
and the interrupt handler, you know puts calls depending on sending or receiving,


341
00:21:10,360 --> 00:21:17,100
but if it's a receiving maybe interrupt what else will stick actually a character's into queues.


342
00:21:17,850 --> 00:21:19,950
We'll see you have these queues are basically used


343
00:21:19,950 --> 00:21:22,410
to decouple the top and the bottom part from each other


344
00:21:22,770 --> 00:21:25,680
and allowing the device to run in parallel


345
00:21:25,680 --> 00:21:27,750
with the rest of the code on the CPU.


346
00:21:30,150 --> 00:21:32,040
And the interrupt handler,


347
00:21:32,040 --> 00:21:33,990
typically there are some restrictions on the interrupt handler,


348
00:21:33,990 --> 00:21:37,890
because those who run in any context you know any process context,


349
00:21:37,890 --> 00:21:40,380
generally you can call copyin or copyout,


350
00:21:40,590 --> 00:21:47,370
because you know the current page table might actually not be reflective of the page table


351
00:21:47,370 --> 00:21:50,130
that's a process to which character should be copied.


352
00:21:50,960 --> 00:21:56,090
And so it's the upper part of the driver generally does the interaction with usual level processes


353
00:21:56,090 --> 00:21:58,220
and maybe called copyin the copyout.


354
00:22:01,280 --> 00:22:04,880
Any questions about this high level picture?


355
00:22:07,630 --> 00:22:09,880
We'll look at it in quite a bit more detail,


356
00:22:09,910 --> 00:22:15,200
but this is sort of the main organization of a typical driver,


357
00:22:15,470 --> 00:22:18,860
if you're going to realize you know there are many drivers in an operating system,


358
00:22:18,860 --> 00:22:22,160
in fact, it's quite common


359
00:22:22,160 --> 00:22:28,220
that you know some of the driver code is quite bigger or larger than the core kernel itself.


360
00:22:29,060 --> 00:22:32,900
But, mostly because for every device, you need to drive, you need a driver.


361
00:22:33,720 --> 00:22:35,850
And most computers have a lot of devices.


362
00:22:42,520 --> 00:22:45,670
Okay, so let's talk a little bit about programming devices.


363
00:22:55,280 --> 00:22:59,270
And so typically programming is done using memory mapped IO.


364
00:23:06,450 --> 00:23:09,900
So as we've seen in in RISC-V


365
00:23:09,900 --> 00:23:11,190
or in the SiFive board,


366
00:23:11,190 --> 00:23:18,570
you know, devices show up at particular addresses in the physical address space,


367
00:23:18,570 --> 00:23:22,170
this is decided by the device board manufacturer.


368
00:23:22,770 --> 00:23:24,630
And given your operating system needs to know,


369
00:23:24,630 --> 00:23:29,700
what those were those devices are located in the physical memory space,


370
00:23:29,910 --> 00:23:38,250
and then basically programs them using ordinary load and store instructions to those addresses.


371
00:23:39,000 --> 00:23:44,730
But basically what these load store instructions do is they are.


372
00:23:45,430 --> 00:23:54,530
They read or write , read or write control registers of the device.


373
00:24:00,200 --> 00:24:04,550
And so typically when you store something in one of the control registers


374
00:24:04,670 --> 00:24:06,290
that causes your packet to be sent,


375
00:24:06,290 --> 00:24:08,060
so instead of reading, writing memory,


376
00:24:08,120 --> 00:24:10,850
these load store instructions typically have side effects,


377
00:24:10,880 --> 00:24:13,280
the [cost] of the device to do something.


378
00:24:15,080 --> 00:24:18,710
And you know you have to look basically the documentation of the device


379
00:24:18,710 --> 00:24:20,840
to actually figure out what the device does.


380
00:24:21,360 --> 00:24:24,930
And you know sometimes this documentation is very clear,


381
00:24:24,990 --> 00:24:26,880
sometimes this documentation is less clear.


382
00:24:27,430 --> 00:24:30,850
This should give you a little bit of a sample , the .


383
00:24:32,630 --> 00:24:34,460
Two things I wanted to show you here,


384
00:24:34,550 --> 00:24:37,940
on the right side of the screen,


385
00:24:38,180 --> 00:24:43,010
you see the memory map, physical memory map space,


386
00:24:43,010 --> 00:24:45,470
you know for the SiFive board,


387
00:24:45,830 --> 00:24:49,370
and you see what the addresses are where particular things are mapped,


388
00:24:49,490 --> 00:24:51,800
where they show up in the physical address space


389
00:24:52,340 --> 00:24:55,460
to use the [word] map where they actually show up in the physical address space.


390
00:24:56,050 --> 00:25:01,180
And so, for example the CLINT you know is there at 0x two zero zero,


391
00:25:01,540 --> 00:25:06,430
we we pick out another one .


392
00:25:07,400 --> 00:25:08,900
The PLIC was somewhere there too,


393
00:25:08,900 --> 00:25:12,200
okay, here's the PLIC at 0x c zero zero zero,


394
00:25:12,200 --> 00:25:17,510
that's the platform platform the interrupt controller ,


395
00:25:17,510 --> 00:25:21,970
and yeah, we see actually UART0 here at this particular address,


396
00:25:22,060 --> 00:25:26,590
that turns out that on the QEMU that we're using


397
00:25:26,590 --> 00:25:31,270
use [has to you are] actually at a different location.


398
00:25:31,960 --> 00:25:38,080
Yeah, that's because we use QEMU doesn't actually literally emulate the SiFive board,


399
00:25:38,080 --> 00:25:40,120
but something that's very close to the SiFive board.


400
00:25:41,610 --> 00:25:42,960
Okay, so that's the memory map,


401
00:25:43,110 --> 00:25:50,100
memory map, you know physical addresses, you know to to devices.


402
00:25:51,550 --> 00:25:54,790
And then, on the left side,


403
00:25:54,820 --> 00:26:00,790
is use piece of documentation for UART.


404
00:26:01,950 --> 00:26:08,170
This is the 1655, one six five five zero,


405
00:26:08,170 --> 00:26:12,640
that's actually UART chip that sits on the QEMU emulates,


406
00:26:12,640 --> 00:26:20,560
that we're using to actually interact with keyboard and console


407
00:26:20,620 --> 00:26:23,080
and you know this is a reasonable simple chip,


408
00:26:23,080 --> 00:26:26,260
there's not actually much going on in this device ,


409
00:26:26,290 --> 00:26:32,330
there's even then they're sort of complications here on the this table here.


410
00:26:33,160 --> 00:26:36,640
It shows the registers that the chip has,


411
00:26:37,060 --> 00:26:39,370
the controller registers as an example,


412
00:26:39,370 --> 00:26:44,260
you know control register zero zero zero in when you're doing load instruction,


413
00:26:44,350 --> 00:26:47,290
it holds, it's will hold the data,


414
00:26:47,650 --> 00:26:49,420
if you do store instruction,


415
00:26:49,630 --> 00:26:55,090
that's the register [double] basically the data will be copied into to be transmitted, you know, outside on the wire,


416
00:26:55,210 --> 00:27:04,880
UART basically, a device that allows you to send bits over a serial line,


417
00:27:04,880 --> 00:27:08,330
sent line is one line and the received line is another line,


418
00:27:09,590 --> 00:27:11,810
basically you take a byte


419
00:27:11,810 --> 00:27:17,480
and you know basically they're multiplex or serialized on this single line


420
00:27:17,780 --> 00:27:19,130
sent over to the other side,


421
00:27:19,130 --> 00:27:21,050
there's UART chip sitting on the other side


422
00:27:21,050 --> 00:27:29,410
and basically assembles the [] back into a single byte. And a couple other things that you can control on this device,


423
00:27:29,590 --> 00:27:36,970
you can actually, control the baud rate, of the device to some degree,


424
00:27:37,180 --> 00:27:46,530
and you know probably most important for us is register register one


425
00:27:46,590 --> 00:27:49,530
which is here which is the interrupt enable register


426
00:27:49,620 --> 00:27:55,110
and so we can program it to actually cause UART to generate interrupts.


427
00:27:57,640 --> 00:27:59,500
So, in particular scroll down,


428
00:27:59,500 --> 00:28:02,710
this document you'll see that the.


429
00:28:03,900 --> 00:28:10,980
Scroll down a bit , the document actually more detail basically describe what every bit in every register means ,


430
00:28:10,980 --> 00:28:16,830
in example in the interrupt enable register IER register


431
00:28:16,830 --> 00:28:18,060
which the actually for it,


432
00:28:18,360 --> 00:28:20,910
you know that basically this is a [] line stages,


433
00:28:20,910 --> 00:28:24,690
interrupt and transmit holding register interrupt.


434
00:28:25,030 --> 00:28:26,890
So that's what the bits mean.


435
00:28:27,500 --> 00:28:29,420
It goes on and on,


436
00:28:29,450 --> 00:28:31,010
there's a lot more documentation


437
00:28:31,010 --> 00:28:35,000
and that tells you what the more detailed the registers are,


438
00:28:35,000 --> 00:28:37,700
how you can use it in polling mode or interrupt mode,


439
00:28:37,700 --> 00:28:39,200
we'll talk about a little bit more,


440
00:28:39,230 --> 00:28:43,700
you know how, how you have to program the enable registers etc etc.


441
00:28:43,730 --> 00:28:47,750
So it turned out to be a short version of the real documents,


442
00:28:47,750 --> 00:28:50,900
you know the real documents where the chip manufacturers much more,


443
00:28:51,240 --> 00:28:54,090
has much more stuff in it and much more detail


444
00:28:54,330 --> 00:28:58,290
and it's sufficient for us to actually be able to talk about how the program UART.


445
00:28:59,100 --> 00:29:01,440
And you can see, this is like one of the most simple devices


446
00:29:01,440 --> 00:29:04,380
and even that document you know it's quite a bit to it.


447
00:29:10,050 --> 00:29:11,790
I'm sorry I was wondering,


448
00:29:11,910 --> 00:29:13,620
if you're writes,


449
00:29:13,650 --> 00:29:19,000
so if you write something to the transmit holding register


450
00:29:19,300 --> 00:29:22,930
and then you write again like right after that,


451
00:29:23,400 --> 00:29:31,940
it makes sure that like the previous number didn't just like get over it and write.


452
00:29:32,120 --> 00:29:36,170
Yes, just know, it's part of you,


453
00:29:36,170 --> 00:29:39,380
actually this is only one of the things that we're going to pay a bit of attention to,


454
00:29:39,740 --> 00:29:45,860
the you tell basically load instruction load, some value or store instruction load some value in that register


455
00:29:46,100 --> 00:29:51,330
and then the, the uart chip goes off


456
00:29:51,330 --> 00:29:54,420
and it's going to send off that that byte onto the line


457
00:29:54,420 --> 00:29:55,620
on the serial line right,


458
00:29:56,040 --> 00:29:57,960
and when it's done,


459
00:29:58,140 --> 00:30:00,750
it will generate an interrupt saying to the kernel,


460
00:30:00,750 --> 00:30:01,890
okay, I'm done with that byte,


461
00:30:01,920 --> 00:30:03,330
now you can give me the next byte.


462
00:30:04,300 --> 00:30:07,270
And so the kernel and the device has to follow a protocol


463
00:30:07,270 --> 00:30:09,190
to make sure that actually everything works out.


464
00:30:10,340 --> 00:30:13,400
This particular, UART you know that we're using as,


465
00:30:13,400 --> 00:30:20,330
sixteen fifty five five fifty eight actually internally has a FIFO


466
00:30:20,360 --> 00:30:24,410
and I think it can buffer a bunch of characters like I think up to sixteen.


467
00:30:25,560 --> 00:30:30,720
But you still have to play this game of like you can't move stick more than sixteen characters into it


468
00:30:30,720 --> 00:30:34,890
until the device actually has told you well, I've sent one character.


469
00:30:37,270 --> 00:30:38,110
Does that make sense.


470
00:30:39,130 --> 00:30:40,600
Okay, yeah, thank you.


471
00:30:41,780 --> 00:30:43,610
So we'll talk a little bit more,


472
00:30:43,640 --> 00:30:48,020
before we do look a little more detail,


473
00:30:48,170 --> 00:30:51,350
you know, you know the case [study],


474
00:30:51,350 --> 00:30:54,380
you know that we going to go through


475
00:30:54,650 --> 00:30:59,840
for a sort of explaining how devices and interrupts work is here's dollar ls,


476
00:30:59,840 --> 00:31:03,750
you know what happens when live.


477
00:31:04,660 --> 00:31:08,710
You know how actually how you print and so basically what happens is


478
00:31:08,710 --> 00:31:12,550
that the device as we actually discussed in the second go,


479
00:31:12,670 --> 00:31:18,180
basically puts the character of the dollar in this case you know into the UART,


480
00:31:18,390 --> 00:31:20,910
in fact in the register that we just looked at.


481
00:31:21,560 --> 00:31:29,720
And then the UART generates interrupt us the way we can set things up generates an interrupt,


482
00:31:30,310 --> 00:31:33,700
when the divi- when the character has been sent.


483
00:31:42,140 --> 00:31:43,910
And then on the other side


484
00:31:43,910 --> 00:31:46,940
and so basically, the way things are set up in QEMU


485
00:31:46,940 --> 00:31:49,010
and QEMU is a on the center line


486
00:31:49,040 --> 00:31:53,630
on the other side of the center line, it usually sits in another UART chip


487
00:31:53,630 --> 00:31:56,750
and that actually connects to the console


488
00:31:56,750 --> 00:31:59,570
to the virtual you knows a virtual console.


489
00:32:00,370 --> 00:32:03,280
On the other side, you know what happens in ls,


490
00:32:03,960 --> 00:32:06,210
is we need to use input


491
00:32:06,240 --> 00:32:10,080
and so the keyboard actually is connected to the received line,


492
00:32:15,880 --> 00:32:17,320
there, receive line.


493
00:32:18,490 --> 00:32:21,700
And, so basically the keyboard,


494
00:32:21,700 --> 00:32:25,480
you know you hit a key on the keyboard, keyboard, virtual keyboard


495
00:32:25,540 --> 00:32:29,020
in this case, you know, UART chip on that side,


496
00:32:29,020 --> 00:32:34,090
you know will serialize you know the character l send it to UART,


497
00:32:34,090 --> 00:32:36,820
on the other side, the other side,


498
00:32:36,820 --> 00:32:40,180
you know put the you know the bits, you know together again into one byte


499
00:32:40,450 --> 00:32:42,910
and then generate an interrupt,


500
00:32:45,080 --> 00:32:47,960
generate an interrupt to tell the processor,


501
00:32:47,960 --> 00:32:51,510
hey there's a character available from the keyboard.


502
00:32:53,320 --> 00:32:57,160
In an interrupt handles the interrupt handle reach the byte from the UART


503
00:32:57,190 --> 00:32:58,120
as we'll see in a second,


504
00:32:58,480 --> 00:33:03,520
so those are two things that we want to understand more detail actually how they work.


505
00:33:05,910 --> 00:33:06,690
Okay?


506
00:33:07,110 --> 00:33:08,250
Any questions about this?


507
00:33:13,720 --> 00:33:36,240
Okay, so , the RISC-V has a bunch of support, support for interrupts and number registers,


508
00:33:36,330 --> 00:33:40,050
yeah we'll see in more detail as they could use


509
00:33:40,050 --> 00:33:42,030
but it's useful to know which ones there are,


510
00:33:42,150 --> 00:33:48,630
there's the SIE, supervisor interrupt enable register


511
00:33:48,810 --> 00:33:57,180
and that has a bit, here one bit for external interrupts from devices,


512
00:33:57,180 --> 00:34:00,510
like the UART from software interrupts,


513
00:34:00,660 --> 00:34:02,790
which I'm really going to talk about it,


514
00:34:02,790 --> 00:34:09,480
but it is possible from one CPU from one RISC-V cores to send an interrupt to another RISC-V core.


515
00:34:10,070 --> 00:34:12,560
And timer interrupt.


516
00:34:14,740 --> 00:34:16,120
And I'm not really going to talk about


517
00:34:16,150 --> 00:34:20,950
either you know the supervisor of the software interruption or the timer interrupts


518
00:34:20,950 --> 00:34:22,420
are going to focus on external interrupts.


519
00:34:23,340 --> 00:34:26,220
There's another register that we've seen before,


520
00:34:26,220 --> 00:34:29,610
as the supervisor status register ,


521
00:34:30,480 --> 00:34:39,740
and that has a bit to disable and enable interrupts on this particular core.


522
00:34:41,720 --> 00:34:45,290
So every core has you know these registers


523
00:34:45,320 --> 00:34:49,970
and there's in addition to these three bits for individual control


524
00:34:49,970 --> 00:34:54,020
when you want to have external interrupts, software interrupt, timer interrupt,


525
00:34:54,230 --> 00:34:57,650
there's one bit that controls you're going to receive interrupts at all,


526
00:34:57,800 --> 00:35:03,320
so you can atomicly switch from not getting interrupts to having interrupted the other way around,


527
00:35:03,380 --> 00:35:07,140
just changing that one bit in the SSTATUS register.


528
00:35:08,660 --> 00:35:11,130
And then there's a SIP register


529
00:35:11,130 --> 00:35:15,330
are the called the supervisor interrupt pending register,


530
00:35:21,020 --> 00:35:22,970
and basically the process you can use that


531
00:35:23,030 --> 00:35:26,420
you want to interrupt it happened [] look at the SIP


532
00:35:26,420 --> 00:35:30,650
to see what, what interrupt actually has come in .


533
00:35:31,220 --> 00:35:35,150
And in addition, there will be even interrupt happens,


534
00:35:35,450 --> 00:35:39,020
in the SCAUSE register, we should that we have seen a couple times before now.


535
00:35:40,160 --> 00:35:44,480
There will be an indication of one interrupt actually came in


536
00:35:44,480 --> 00:35:45,530
with a look in the second


537
00:35:46,040 --> 00:35:48,350
and of course there's the STVEC register,


538
00:35:48,650 --> 00:35:54,020
basic holds the program or address to which the processors switch


539
00:35:54,230 --> 00:35:59,630
once either trap or trap system call


540
00:35:59,630 --> 00:36:02,660
or page fault happens when an interrupt happens,


541
00:36:02,690 --> 00:36:05,720
because basically uses for all three cases the same mechanism.


542
00:36:06,160 --> 00:36:09,310
I'm not gonna talk too much about SCAUSE and STVEC,


543
00:36:09,310 --> 00:36:12,970
because we've seen it in detail before,


544
00:36:13,390 --> 00:36:18,370
and basically operates exactly in the same way


545
00:36:18,370 --> 00:36:26,770
as as system calls in page faults or other exceptions.


546
00:36:30,080 --> 00:36:34,280
Okay, so let's see a little bit of sense,


547
00:36:34,460 --> 00:36:36,890
how this stuff is sort of initialized,


548
00:36:37,070 --> 00:36:40,820
so we're not talking even about how the drivers actually work,


549
00:36:40,820 --> 00:36:42,890
but just see how xv6 programs,


550
00:36:42,890 --> 00:36:48,710
this , these registers said we're going to be in a position to take a interrupt.


551
00:36:50,030 --> 00:36:53,300
This's a question from the chat make sure that.


552
00:37:03,140 --> 00:37:04,160
Alright, okay.


553
00:37:04,970 --> 00:37:06,170
A little behind on the chat,


554
00:37:06,290 --> 00:37:13,490
so let's see a little bit on the what, xv6 programs registers,


555
00:37:13,790 --> 00:37:16,130
so pull up some code.


556
00:37:16,920 --> 00:37:19,080
Let me get rid of the.


557
00:37:24,180 --> 00:37:26,610
This window, actually I don't really need that either.


558
00:37:26,940 --> 00:37:30,420
I'm not going to run use gdb to walk through things,


559
00:37:30,420 --> 00:37:34,560
I'm just going to look at particular functions that are relevant .


560
00:37:35,140 --> 00:37:38,350
So probably the first thing is in start.c,


561
00:37:38,380 --> 00:37:41,290
so when the machine boots, what processor boots.


562
00:37:41,780 --> 00:37:46,810
Um the , the start function is called,


563
00:37:46,810 --> 00:37:48,430
its runs in the M mode,


564
00:37:48,460 --> 00:37:52,750
and it disables paging,


565
00:37:53,350 --> 00:37:55,360
so right away,


566
00:37:55,450 --> 00:37:58,750
because you know sort of later on, the kernel can set up the page tables


567
00:37:58,960 --> 00:38:04,450
and we see here that basically delegates all interrupts and exceptions to supervisor mode ,


568
00:38:04,780 --> 00:38:10,480
then its programs, the supervisor enable interrupt


569
00:38:10,480 --> 00:38:17,390
enable register to take software interrupts, timer interrupts, external interrupts.


570
00:38:18,500 --> 00:38:21,080
And then for good measure,


571
00:38:21,080 --> 00:38:26,810
timer interrupts actually happened to coming to are handled in M mode,


572
00:38:27,110 --> 00:38:35,000
the. M mode code, actually programs, the timer registers


573
00:38:35,120 --> 00:38:39,230
and so that times timer interrupts are generated.


574
00:38:40,080 --> 00:38:41,700
I don't want to talk about that actually,


575
00:38:41,730 --> 00:38:43,440
so I'm gonna go to main.c.


576
00:38:46,980 --> 00:38:50,580
And so see how external devices are handled


577
00:38:50,610 --> 00:38:54,870
and so our first external devices to console where we print [too].


578
00:38:55,440 --> 00:38:57,930
And we can see what consoleinit does.


579
00:38:59,520 --> 00:39:01,440
So here's consoleinit,


580
00:39:01,560 --> 00:39:07,200
initialize lock, we actually care not much about that at all ,


581
00:39:07,200 --> 00:39:08,820
it's not for this lecture,


582
00:39:08,880 --> 00:39:12,090
and it actually basically calls that uartinit.


583
00:39:12,840 --> 00:39:16,890
And uartinit is right here.


584
00:39:18,380 --> 00:39:23,030
It actually sets up the uart chip ,


585
00:39:23,030 --> 00:39:25,310
configure uart chips that is ready for use.


586
00:39:25,740 --> 00:39:28,500
You know first actually disables interrupts,


587
00:39:28,500 --> 00:39:31,500
you know there's the sequence, you have to go through when you program it,


588
00:39:31,890 --> 00:39:35,280
then you can set the baud rate ,


589
00:39:35,310 --> 00:39:38,460
menu set in six you know seven bits,


590
00:39:38,460 --> 00:39:41,190
you know seven or eight bit bits well [repaired] uart.


591
00:39:43,080 --> 00:39:48,180
And, you reset the internal FIFO,


592
00:39:48,180 --> 00:39:53,850
that's uart has to clear out anything that actually might be in there


593
00:39:54,000 --> 00:40:00,780
and then, we receive , it will enable interrupts for transmission and interruption.


594
00:40:02,890 --> 00:40:04,930
Amir, I think you raise your hand.


595
00:40:07,140 --> 00:40:09,690
Yeah I'm wondering what the baud rate is exactly.


596
00:40:09,990 --> 00:40:12,540
Oh the speed which you know the lines runs.


597
00:40:14,740 --> 00:40:16,360
I see, thanks.


598
00:40:20,510 --> 00:40:21,890
Okay, so that's uartinit,


599
00:40:21,950 --> 00:40:27,410
now at this point you know the uart in principle improve can generate interrupts,


600
00:40:27,530 --> 00:40:29,990
but of course we are we haven't actually programmed


601
00:40:29,990 --> 00:40:34,370
to interrupt enabling stuff on the on the RISC-V process itself,


602
00:40:34,370 --> 00:40:35,870
we haven't programmed to PLIC yet,


603
00:40:36,020 --> 00:40:37,310
nothing really happens


604
00:40:37,990 --> 00:40:39,340
at this point yet.


605
00:40:39,340 --> 00:40:42,400
And so the next thing, we're going to move back to main.c,


606
00:40:42,820 --> 00:40:46,690
you will see a little bit, scroll down ,


607
00:40:46,690 --> 00:40:49,090
will see actually that the PLIC is initialized,


608
00:40:49,330 --> 00:40:50,590
so let's look at that.


609
00:40:52,540 --> 00:40:56,480
And basically, you know, plicinit code,


610
00:40:56,660 --> 00:41:00,590
if you look at this table that I showed you a little while ago,


611
00:41:00,590 --> 00:41:03,740
if the physical memory or the memory layout,


612
00:41:03,740 --> 00:41:06,890
you know the PLIC is in some particular location.


613
00:41:07,430 --> 00:41:09,770
Second location is in kernel memory layouts.


614
00:41:10,340 --> 00:41:13,550
We see the PLIC 0C zero zero zero zero correct,


615
00:41:13,550 --> 00:41:15,200
literally copied from that document.


616
00:41:15,890 --> 00:41:18,620
And you know the way we write stuff to the PLIC


617
00:41:18,620 --> 00:41:23,300
is basically you take the number when address for the PLIC


618
00:41:23,600 --> 00:41:28,460
cast to a 32 pointer integer,


619
00:41:28,460 --> 00:41:30,590
because the PLIC registers are 32 bit.


620
00:41:31,160 --> 00:41:33,140
And then basically write onto it,


621
00:41:33,170 --> 00:41:40,190
so this cast is basically one to be written to the register UART0_IRQ.


622
00:41:41,060 --> 00:41:42,320
And basically what this does


623
00:41:42,320 --> 00:41:45,920
is it enables interrupt requests from the uart,


624
00:41:46,370 --> 00:41:50,720
so remember to PLIC basically routes interrupts,


625
00:41:50,720 --> 00:41:54,770
and so the interrupt might come in from the left side from that picture into the plic


626
00:41:54,770 --> 00:41:58,820
and the plic like this programs plic to actually accept those interrupts.


627
00:42:00,270 --> 00:42:01,590
Similarly actually programs,


628
00:42:01,590 --> 00:42:04,740
the PLIC through accepting [] from the IO disk,


629
00:42:04,770 --> 00:42:06,270
which I'm not going to talk about at all.


630
00:42:08,510 --> 00:42:10,490
Okay, and then, we go back,


631
00:42:10,520 --> 00:42:12,530
you know to main.c


632
00:42:12,590 --> 00:42:18,580
and there right after the PLIC in that machine just plicinithart


633
00:42:18,610 --> 00:42:21,580
and then visually for every cores specifically.


634
00:42:24,260 --> 00:42:26,750
Every core individually, so only one core,


635
00:42:26,750 --> 00:42:29,930
the first core actually initialize this aspect,


636
00:42:30,170 --> 00:42:32,330
basically we're taking interrupts on those devices


637
00:42:32,720 --> 00:42:37,280
and then every core individually has to say I'm interested in those devices too.


638
00:42:37,980 --> 00:42:43,110
And so for example here, every core actually calls these functions,


639
00:42:43,110 --> 00:42:46,950
every cores, I'm interested in interrupt from uart


640
00:42:46,950 --> 00:42:49,800
and I'm interested the interrupts from the virtio.


641
00:42:50,730 --> 00:42:53,070
You can see here basically the uart0 IO too,


642
00:42:53,070 --> 00:43:00,840
basically is a unique number, you know for, the UART_IRQ for in what uart,


643
00:43:00,840 --> 00:43:04,630
and I think believes on the on QEMU number ten.


644
00:43:06,540 --> 00:43:09,180
And we're basically ignore priorities


645
00:43:09,180 --> 00:43:10,530
and so we just set it to zero.


646
00:43:11,880 --> 00:43:15,180
OK, and so does every CPU you already record individually


647
00:43:15,180 --> 00:43:16,290
has to indicate to the PLIC,


648
00:43:16,290 --> 00:43:20,220
that actually is interested in receiving interrupts.


649
00:43:22,290 --> 00:43:25,260
You know, at this point you know we're you know the PLIC basically,


650
00:43:25,380 --> 00:43:28,230
so we basically have to program the device to generate interrupts,


651
00:43:28,230 --> 00:43:33,300
we have program to PLIC you know to pass interrupts on the individual CPUs,


652
00:43:33,480 --> 00:43:36,900
but the CPU itself have actually are not accepting interrupt yet,


653
00:43:36,930 --> 00:43:40,650
because we haven't set the bit in the SSTATUS of yet


654
00:43:40,650 --> 00:43:44,640
and so let's go back to to main.c.


655
00:43:47,440 --> 00:43:51,160
And whatever means he does a bunch of organization ,


656
00:43:51,160 --> 00:43:52,960
but in the end it actually calls the scheduler.


657
00:43:53,940 --> 00:43:55,920
So let's look at proc.c.


658
00:43:56,960 --> 00:43:59,330
And get scheduler.


659
00:44:04,940 --> 00:44:06,020
And what we see here,


660
00:44:06,020 --> 00:44:10,730
is like when the around basically the whole machine is sort of the processors has been setup


661
00:44:10,910 --> 00:44:14,690
and scheduling schedules, virtual process run,


662
00:44:14,690 --> 00:44:19,370
before you know any of that actually enables interrupts.


663
00:44:20,180 --> 00:44:21,950
And so we look at riscv.


664
00:44:22,530 --> 00:44:27,110
You'll see, there's basically this is a C function.


665
00:44:28,240 --> 00:44:29,830
And basically enables interrupts


666
00:44:29,830 --> 00:44:33,070
and you can not surprising you know basically the only thing it does,


667
00:44:33,190 --> 00:44:36,520
it sets the interrupt enable bit in the sstatus register.


668
00:44:37,330 --> 00:44:39,070
So at this particular point time,


669
00:44:39,430 --> 00:44:44,050
write at this instance if there were an interrupt pending at the PLIC,


670
00:44:44,260 --> 00:44:47,590
then you know the this particular core would be interrupted.


671
00:44:48,770 --> 00:44:50,150
We ran a second later,


672
00:44:50,150 --> 00:44:52,370
but this is this point interrupts are enabled.


673
00:44:53,840 --> 00:44:55,400
And so this is the basic setup.


674
00:44:56,050 --> 00:44:57,160
Any questions about this?


675
00:45:02,020 --> 00:45:07,810
Oh, sorry, oh, what core would be interrupted when at that point?


676
00:45:08,420 --> 00:45:11,090
So every core runs the scheller loop, correct.


677
00:45:11,680 --> 00:45:14,680
And whatever core calls interrupt on,


678
00:45:15,250 --> 00:45:16,630
all cores will call interrupt,


679
00:45:16,630 --> 00:45:19,300
but let's say there's only one core gets there first.


680
00:45:19,830 --> 00:45:25,950
Like core one and if core one sets its interrupt enable bit at that point,


681
00:45:25,950 --> 00:45:27,360
it could receive an interrupt.


682
00:45:29,480 --> 00:45:31,820
And we'll see you second what happens exactly as an interrupt.


683
00:45:33,230 --> 00:45:34,430
Makes sense, thank you.


684
00:45:36,520 --> 00:45:39,790
OK, OK, so what do I want to do


685
00:45:39,820 --> 00:45:43,510
is look at this how,


686
00:45:43,540 --> 00:45:46,870
how to print the dollar you know the prompt at the shell prompt.


687
00:45:47,550 --> 00:45:51,660
And so for that we want to go back a little bit.


688
00:45:52,460 --> 00:45:54,470
And our first want to look at init again.


689
00:45:55,040 --> 00:45:57,230
So this was the first process that actually being,


690
00:45:57,320 --> 00:45:59,540
there in the code exec in it,


691
00:45:59,540 --> 00:46:01,970
and so that's basically first process running.


692
00:46:02,520 --> 00:46:04,740
And one of the things that it does,


693
00:46:05,040 --> 00:46:09,510
it makes a device that represents the console.


694
00:46:10,100 --> 00:46:14,990
Um, so here the devices created, using the mknod operation


695
00:46:15,350 --> 00:46:18,680
and returns a file descriptor, a file descriptor zero,


696
00:46:18,680 --> 00:46:22,280
because it's the first file descriptor open and then adopt it standard out,


697
00:46:22,310 --> 00:46:24,380
and then for standard error and adopt it again


698
00:46:24,680 --> 00:46:28,730
and so this basically sets up file descriptor zero one and two


699
00:46:29,030 --> 00:46:31,880
to a correspond to the console.


700
00:46:33,280 --> 00:46:38,710
Now, so [good at fourth off] the shell.


701
00:46:40,030 --> 00:46:42,100
Yeah, so let's get the shell for a second.


702
00:46:42,960 --> 00:46:47,190
So the shell opens you know starts running with ,


703
00:46:47,860 --> 00:46:51,940
we found descriptors one two three, zero one and two open,


704
00:46:51,940 --> 00:46:53,350
pointed to the console


705
00:46:53,620 --> 00:47:03,490
and then shell prints a character dollar in the space to file descriptor two.


706
00:47:04,200 --> 00:47:07,740
And so, so even though it console and uart,


707
00:47:07,800 --> 00:47:11,550
you know sort of all you blow all this to the application programmer,


708
00:47:11,550 --> 00:47:13,770
and like the shell of the person, we want to shell,


709
00:47:13,860 --> 00:47:15,450
it just looks like a regular file,


710
00:47:15,750 --> 00:47:17,940
so in fact the shell itself,


711
00:47:18,120 --> 00:47:20,430
since its writes to descriptor two has no idea


712
00:47:20,430 --> 00:47:21,870
what actually sits on the other side


713
00:47:21,900 --> 00:47:23,430
and we have seen in util lab,


714
00:47:23,430 --> 00:47:24,990
you can do all kinds of cool stuff with it.


715
00:47:25,460 --> 00:47:28,760
But here's an example where basically the device in Unix


716
00:47:28,850 --> 00:47:30,350
is represented as a file,


717
00:47:30,380 --> 00:47:32,180
that's not different than anything else.


718
00:47:33,650 --> 00:47:36,800
Okay, so let's see how this actually printf works.


719
00:47:37,340 --> 00:47:42,770
So there's a printf is in xv6 user application,


720
00:47:42,770 --> 00:47:45,710
a tiny little C library, which includes code printf.


721
00:47:46,340 --> 00:47:50,690
And you know printf, you know as you've seen in the traps lab,


722
00:47:50,690 --> 00:47:54,510
you know, sort of an instinct function itself,


723
00:47:54,510 --> 00:47:58,170
but in yet it basically calls the write system call,


724
00:47:58,440 --> 00:48:02,370
and in our case where the write system call would be you know file descriptor two


725
00:48:02,370 --> 00:48:06,690
and c would be hold the character dollar


726
00:48:06,690 --> 00:48:10,260
and so we pass the address of the memory location


727
00:48:10,260 --> 00:48:14,370
that holds the dollar to the file descriptor to write


728
00:48:14,640 --> 00:48:17,160
and we ask you know to write one character.


729
00:48:19,290 --> 00:48:21,270
So basically every character written by the shell,


730
00:48:21,270 --> 00:48:22,740
when it results in a system call.


731
00:48:23,340 --> 00:48:24,840
And so now we can go.


732
00:48:25,870 --> 00:48:27,430
Let's see what actually happens.


733
00:48:28,040 --> 00:48:31,610
So we you know you've seen the system called before,


734
00:48:31,640 --> 00:48:34,250
but sysfile.


735
00:48:36,960 --> 00:48:38,940
Yes, sys_write.


736
00:48:40,190 --> 00:48:41,870
So here's the write system call,


737
00:48:41,900 --> 00:48:43,340
[grabs] his arguments,


738
00:48:43,520 --> 00:48:46,910
a file descriptor number bytes to be written


739
00:48:46,910 --> 00:48:49,520
and the address with the, the address


740
00:48:49,520 --> 00:48:53,090
that it contains you know the character dollar call them filewrite.


741
00:48:58,080 --> 00:49:00,750
Let's quickly look at filewrite.


742
00:49:01,860 --> 00:49:05,490
Okay, we're getting close to actually were things that we want to talk about.


743
00:49:06,140 --> 00:49:10,790
And you know here if I'll write it looks for the type of the file descriptor is,


744
00:49:10,790 --> 00:49:12,890
it's a pipe called the pipe functions,


745
00:49:13,070 --> 00:49:16,700
and if its device which you make not does,


746
00:49:17,000 --> 00:49:21,020
then it will call a the write function for that particular device.


747
00:49:21,910 --> 00:49:29,020
And so we know that you know that actually is going to call the write function in the console.


748
00:49:30,330 --> 00:49:31,800
And so let's see what happens there,


749
00:49:31,830 --> 00:49:33,030
so here's consolewrite.


750
00:49:33,840 --> 00:49:36,930
[] walk, we really care about that right now,


751
00:49:37,080 --> 00:49:41,340
it copies in the one character use either_copyin,


752
00:49:41,890 --> 00:49:44,080
and then, calls uartputc.


753
00:49:45,530 --> 00:49:51,530
So that with calls into the uart, and so you can think about together, the consoles being the driver,


754
00:49:51,620 --> 00:49:54,380
we're looking at the top end of the driver


755
00:49:54,650 --> 00:49:58,280
and now makes you call in uart.c


756
00:49:58,550 --> 00:50:00,740
to actually a print a character.


757
00:50:02,060 --> 00:50:05,960
And so here uart.c, so this is going to be a little bit interesting,


758
00:50:07,780 --> 00:50:11,680
basically the internally the uart, keeps a buffer,


759
00:50:12,040 --> 00:50:14,500
so let's go back back up a little bit.


760
00:50:15,080 --> 00:50:18,290
At the top, in fact there's a buffer for transmission


761
00:50:18,620 --> 00:50:21,200
and buffer size is 32 characters.


762
00:50:21,770 --> 00:50:24,350
And there's a pointer the write pointer and the read pointer


763
00:50:24,350 --> 00:50:30,620
being used to put this character into a circular buffer,


764
00:50:30,950 --> 00:50:32,600
talk a little bit about that in more detail,


765
00:50:32,600 --> 00:50:37,970
but there's a pointer for the producer and as a pointer for the consumer.


766
00:50:38,620 --> 00:50:43,150
And in this case, you know the shell, if you will, as the producer


767
00:50:43,210 --> 00:50:46,210
and it actually checks the first thing,


768
00:50:46,210 --> 00:50:48,730
it does is actually check whether this circular buffer is full.


769
00:50:49,370 --> 00:50:52,010
So and the way the checks with the circular reference pool,


770
00:50:52,010 --> 00:50:56,960
so it starts out in the original state is both the write pointer and the read pointer is zero,


771
00:50:56,960 --> 00:50:58,910
correct zero index into the buffer,


772
00:50:59,240 --> 00:51:04,250
if the equal you know that they're a buffer is empty,


773
00:51:04,430 --> 00:51:06,410
but if you add one to the write pointer,


774
00:51:06,410 --> 00:51:08,000
it's the same as the receive pointer,


775
00:51:08,030 --> 00:51:13,160
so for example if you you fill in a zero one two three four five six seven eight nineteen thirty one


776
00:51:13,400 --> 00:51:15,770
and then you're about to wrap around,


777
00:51:16,040 --> 00:51:21,860
you add one if then and it's still equal to the receive index,


778
00:51:22,140 --> 00:51:23,970
or the reading that you know that the buffer is full.


779
00:51:24,820 --> 00:51:28,600
And so there's no point you know you can't write anything at that point ,


780
00:51:28,600 --> 00:51:31,870
because apparently you're still busy you're working its way through,


781
00:51:31,870 --> 00:51:37,870
trying to send off the appreciating, you know 31 characters or [] characters.


782
00:51:38,390 --> 00:51:40,430
In this case the buffer full,


783
00:51:40,550 --> 00:51:46,280
the shell basically were put to sleep and put on the [site]


784
00:51:46,280 --> 00:51:52,370
and the kernel will run some other program until shell woken up


785
00:51:52,370 --> 00:51:53,720
and it's actually ready to send.


786
00:51:55,180 --> 00:51:57,430
Or uart just ready to send more data.


787
00:51:58,090 --> 00:52:00,340
You know, of course in this case it's not the case right,


788
00:52:00,340 --> 00:52:02,800
because there's the first few characters that are being printed,


789
00:52:03,220 --> 00:52:04,660
so there's space in the buffer


790
00:52:04,900 --> 00:52:09,220
and so basically the driver puts a character into the buffer,


791
00:52:09,610 --> 00:52:12,640
updates the write point to go to the next slot


792
00:52:12,790 --> 00:52:14,230
and then calls uartstart.


793
00:52:15,960 --> 00:52:19,200
And basically uartstart nothing else sort of kicking the device


794
00:52:19,200 --> 00:52:21,780
and saying like hey go do some work for me.


795
00:52:23,620 --> 00:52:25,180
And, um.


796
00:52:25,800 --> 00:52:36,000
And basically, , first check if the device is still busy sending the current character [] recently,


797
00:52:36,300 --> 00:52:39,390
if if the device is busy,


798
00:52:39,390 --> 00:52:41,850
you know we just go back and it will go to sleep probably,


799
00:52:42,320 --> 00:52:43,820
[welcome to] sleep


800
00:52:44,060 --> 00:52:46,580
and otherwise will read the character [out the] buffer


801
00:52:46,820 --> 00:52:51,490
and put it in the transmission register,


802
00:52:51,640 --> 00:52:52,870
that we saw earlier.


803
00:52:54,480 --> 00:52:58,710
And so the transmission register just like this before ,


804
00:52:58,710 --> 00:53:01,170
let's look at that for a second .


805
00:53:02,410 --> 00:53:09,440
You know we register you know cast the particular register to the one of [] type,


806
00:53:09,440 --> 00:53:11,300
and then writes the value into it.


807
00:53:12,360 --> 00:53:15,510
And you know THR, the transmitter holding register is


808
00:53:15,570 --> 00:53:18,240
[register] zero which we saw before from the documentation.


809
00:53:20,390 --> 00:53:25,250
Okay, so , so basically you know the ,


810
00:53:26,570 --> 00:53:28,370
where was I in start.


811
00:53:28,920 --> 00:53:31,380
You should start basically kicks the device


812
00:53:31,380 --> 00:53:33,420
and saying like hey I gotta register,


813
00:53:33,420 --> 00:53:36,180
I got a byte for you available to send off.


814
00:53:36,790 --> 00:53:40,570
And that's basically all the.


815
00:53:42,430 --> 00:53:45,220
And that basically the if you will to shell,


816
00:53:45,250 --> 00:53:48,520
you know the system called the shell called will do


817
00:53:48,790 --> 00:53:52,960
and one's actually kick the devices will return to user space


818
00:53:52,960 --> 00:53:55,480
and the shell can go on and do whatever it wants to do


819
00:53:55,840 --> 00:53:58,600
and presumably the next thing the shell will do is called the read system call


820
00:53:58,600 --> 00:54:00,340
to actually read input from the keyboard.


821
00:54:00,740 --> 00:54:04,130
But so the shell will return to user space using the standard mechanism,


822
00:54:04,130 --> 00:54:06,620
that we have seen before, like userret,


823
00:54:06,950 --> 00:54:08,450
it just goes off and does its thing


824
00:54:08,630 --> 00:54:11,450
and in the meantime, the device has not got any kick


825
00:54:11,660 --> 00:54:13,700
to actually, send some bytes off.


826
00:54:16,240 --> 00:54:17,950
And so, .


827
00:54:19,400 --> 00:54:21,680
So at some point we're going to get interrupted,


828
00:54:22,720 --> 00:54:27,130
hopefully you know because we broke into the hardware to actually generate interrupts,


829
00:54:27,370 --> 00:54:28,720
let's go a little bit back


830
00:54:28,720 --> 00:54:30,730
and talk a little bit about what happens


831
00:54:30,850 --> 00:54:32,200
when the interrupt happens.


832
00:54:37,130 --> 00:54:42,270
Okay, so , so what does the hardware do.


833
00:54:44,320 --> 00:54:49,140
In this particular case the RISC-V, do what to interrupt actually happens,


834
00:54:49,140 --> 00:54:53,160
so we set this interrupt enable bit in the SSTATUS register,


835
00:54:53,280 --> 00:54:55,200
so the process can be interrupted,


836
00:54:55,440 --> 00:55:00,060
let's say the keyboard raises the interrupt line goes through the PLIC,


837
00:55:00,240 --> 00:55:03,660
PLIC routes the interrupt to particular core


838
00:55:03,900 --> 00:55:08,910
and that core you know, has the SIE bit set,


839
00:55:09,810 --> 00:55:11,520
so interrupt enable bit set,


840
00:55:13,260 --> 00:55:15,660
the supervisor interrupt enable bit set,


841
00:55:15,780 --> 00:55:17,160
so if the bit is set,


842
00:55:17,750 --> 00:55:18,770
the following things happen.


843
00:55:19,370 --> 00:55:20,840
And this will look very similar


844
00:55:20,870 --> 00:55:22,400
to what we've seen before,


845
00:55:22,430 --> 00:55:27,630
but the first thing the hardware does is clear the SIE bit.


846
00:55:29,330 --> 00:55:32,450
This stops you know any further interrupts coming in ,


847
00:55:32,450 --> 00:55:34,340
so that we can just deal with these interrupt first


848
00:55:34,340 --> 00:55:35,690
and then if we want more interrupts,


849
00:55:35,690 --> 00:55:37,730
you know we have to re-enable that bit,


850
00:55:37,730 --> 00:55:40,480
you know these to stops further interrupts


851
00:55:40,480 --> 00:55:42,340
were basically interrupt [interrupt] interrupt,


852
00:55:43,440 --> 00:55:51,800
then it sets the SEPC to the exception program counter to the current PC.


853
00:55:52,840 --> 00:55:54,730
For example, if we were interrupted ,


854
00:55:54,730 --> 00:55:56,710
let's say to shell return to user space


855
00:55:56,710 --> 00:55:59,290
what's happening running user space and interrupt comes in,


856
00:55:59,290 --> 00:56:00,850
because of that one character is sent,


857
00:56:01,150 --> 00:56:02,770
then the programmer can received


858
00:56:02,770 --> 00:56:04,960
is whatever program counter was in user space,


859
00:56:05,410 --> 00:56:10,860
it saves the save the current mode.


860
00:56:12,880 --> 00:56:15,520
So in this case would be an example would be


861
00:56:15,520 --> 00:56:19,270
we would save that extra processing supervisor mode, the user mode,


862
00:56:19,420 --> 00:56:21,910
then it's just the mode supervisor.


863
00:56:26,360 --> 00:56:30,710
And, basically sets the program counter to stvec,


864
00:56:31,300 --> 00:56:33,340
whatever value is in stvec, right,


865
00:56:33,340 --> 00:56:38,890
then it's going to be either usertrap or uservec or kernelvec.


866
00:56:39,670 --> 00:56:41,530
And depending whether the interrupt happens,


867
00:56:41,530 --> 00:56:44,230
you know whether we're in [] kernel space or user mode,


868
00:56:44,230 --> 00:56:47,440
but in our example, we're maybe shell return to user space.


869
00:56:47,980 --> 00:56:53,260
You know stvec will contain the user [] address


870
00:56:53,290 --> 00:56:57,070
and basically the hard will resume the kernel,


871
00:56:57,340 --> 00:57:01,630
at the instruction, that is located stvec


872
00:57:01,660 --> 00:57:04,100
and you know we remember from previous lecture,


873
00:57:04,100 --> 00:57:08,900
you know basically stvec goes off and calls usertrap.


874
00:57:09,900 --> 00:57:12,630
Okay, so in the end will basically end up in usertrap.


875
00:57:15,320 --> 00:57:16,970
And that's where we sort of pick up the [store],


876
00:57:16,970 --> 00:57:21,110
because like I don't really want to talk too much about the saving and restoring anymore,


877
00:57:21,110 --> 00:57:24,680
because one we explained it in detail in the previous lecture to,


878
00:57:24,680 --> 00:57:29,720
you already played [live] and also in this last traps [] lab,


879
00:57:29,750 --> 00:57:31,910
so you know you know exactly what's going on.


880
00:57:36,860 --> 00:57:37,550
And questions?


881
00:57:43,150 --> 00:57:44,950
Okay, so .


882
00:57:46,410 --> 00:57:47,970
So here back in usertrap,


883
00:57:48,120 --> 00:57:51,540
you know function you've looked in detail at in the traps lab.


884
00:57:51,720 --> 00:57:56,130
And you dealt with a case of system calls.


885
00:57:56,520 --> 00:58:00,690
And what we're gonna do, is basically the only thing we're gonna do


886
00:58:00,690 --> 00:58:04,690
is look at this case, which is the device interrupt.


887
00:58:05,260 --> 00:58:08,200
Okay, so so we're gonna.


888
00:58:09,150 --> 00:58:12,120
That's a little bit lower here in the file.


889
00:58:16,140 --> 00:58:17,790
So here's the device's interrupt


890
00:58:17,820 --> 00:58:23,280
and it looks basically the scause register


891
00:58:23,280 --> 00:58:25,890
and sees if this is an external interrupt,


892
00:58:26,220 --> 00:58:28,080
and if it's an external interrupt,


893
00:58:28,350 --> 00:58:30,330
that calls a function the plic_claim,


894
00:58:30,960 --> 00:58:34,590
to basically claim that particular claim interrupt.


895
00:58:34,800 --> 00:58:36,180
So let's go back to plic,


896
00:58:39,080 --> 00:58:40,520
and look at the plic_claim


897
00:58:41,000 --> 00:58:42,470
and basically what it boils down to


898
00:58:42,470 --> 00:58:45,380
is that the, in the,


899
00:58:45,530 --> 00:58:48,200
this particular CPU will tell the plic,


900
00:58:48,260 --> 00:58:51,380
hey I'm claiming you know it's CPU zero


901
00:58:51,380 --> 00:58:58,160
or if you want it will tell the plic that CPU one is claiming this particular interrupt


902
00:58:58,160 --> 00:59:02,120
and was claimed interrupt and plic returns which interrupts it gets,


903
00:59:02,640 --> 00:59:05,340
IRQ for the interrupt that actually came in


904
00:59:05,340 --> 00:59:09,750
and so in this case that will be an interrupt uart IRQ [ten].


905
00:59:10,280 --> 00:59:12,830
So plic plic will basically return ten.


906
00:59:13,660 --> 00:59:15,820
And then here in this code,


907
00:59:16,060 --> 00:59:19,180
you look you say hey is this a interrupt ten,


908
00:59:19,180 --> 00:59:21,850
if interrupt ten that must be a uart interrupt


909
00:59:22,150 --> 00:59:25,630
and we basically called uartintr function.


910
00:59:26,370 --> 00:59:28,950
And uartintr function,


911
00:59:31,690 --> 00:59:34,840
runs and basically gets the character off,


912
00:59:34,870 --> 00:59:37,690
you know the uart and way it gets the character of,


913
00:59:37,690 --> 00:59:43,360
you already is basically looks in first register, the received register


914
00:59:43,660 --> 00:59:45,850
and gets the character out of there.


915
00:59:47,240 --> 00:59:52,610
And, that is an integer and then it calls consoleintr,


916
00:59:53,120 --> 00:59:55,340
to do the rest of the work.


917
00:59:58,510 --> 00:59:59,200
Okay?


918
01:00:01,570 --> 01:00:04,000
Actually sorry, I just did the wrong thing,


919
01:00:04,000 --> 01:00:07,060
we were talking about transmission .


920
01:00:10,940 --> 01:00:14,960
So if there was a character on the read side


921
01:00:14,990 --> 01:00:18,170
and then we'll call consoleintr ,


922
01:00:18,170 --> 01:00:20,180
but there is no character correct, on the read side,


923
01:00:20,180 --> 01:00:23,270
because we haven't read any keyboard hasn't done anything yet,


924
01:00:23,480 --> 01:00:25,370
we're just transmitting a character,


925
01:00:25,640 --> 01:00:29,000
so [did you watch] return minus one fall through


926
01:00:29,150 --> 01:00:31,160
and then basically the only thing that will do


927
01:00:31,190 --> 01:00:35,960
is called it will call uartstart


928
01:00:36,020 --> 01:00:39,800
to basically send any any other characters that might be in the buffer,


929
01:00:39,830 --> 01:00:42,410
the shell, it might be stuck in there


930
01:00:42,710 --> 01:00:44,600
and resume there's another character in there,


931
01:00:44,600 --> 01:00:46,460
because after the dollar is the space


932
01:00:46,760 --> 01:00:52,130
and the write system call might write this space might have happened concurrently,


933
01:00:52,130 --> 01:00:53,630
while the device was sending off


934
01:00:53,960 --> 01:00:56,780
and so when we interrupt transmit interrupt complete,


935
01:00:57,190 --> 01:00:59,200
it's goes off you know the,


936
01:00:59,230 --> 01:01:01,330
will find in the buffer yet another character,


937
01:01:01,330 --> 01:01:03,970
the space character and we'll send space character off.


938
01:01:06,980 --> 01:01:08,150
Okay, that makes sense.


939
01:01:10,320 --> 01:01:12,900
I have a high level of question actually.


940
01:01:13,510 --> 01:01:18,070
So I understand the uart [] is like useful,


941
01:01:18,070 --> 01:01:20,050
if I'm like using the keyboard


942
01:01:20,410 --> 01:01:24,730
and like characters from the keyboard go through the uart


943
01:01:24,880 --> 01:01:26,080
and then through the CPU


944
01:01:26,080 --> 01:01:27,820
and then the kernel code that we wrote,


945
01:01:28,120 --> 01:01:33,730
but I am not sure I understand what the point of the uart is when the shell is printing characters,


946
01:01:33,910 --> 01:01:36,130
like the keyboard isn't being interacted with.


947
01:01:36,520 --> 01:01:37,210
No, it is correct,


948
01:01:37,210 --> 01:01:40,720
but the display is actually there's two devices here,


949
01:01:40,720 --> 01:01:43,390
one is the keyboard and one is the display on the console.


950
01:01:43,940 --> 01:01:49,760
And the way you QEMU interact with the console is by uart,


951
01:01:49,790 --> 01:01:53,030
by sending a character to the console


952
01:01:53,510 --> 01:01:57,860
and then the console's job is basically to draw that character on the display.


953
01:01:59,030 --> 01:02:00,710
Oh I see, okay, thanks.


954
01:02:02,920 --> 01:02:03,820
It might take time


955
01:02:03,850 --> 01:02:06,460
and that's why you know this thing, you're sort of being [driven].


956
01:02:08,040 --> 01:02:09,360
Okay, um.


957
01:02:10,100 --> 01:02:11,540
So a couple things now,


958
01:02:11,540 --> 01:02:13,100
you know want to step back a little bit


959
01:02:13,100 --> 01:02:17,270
and think a little bit higher level what's going on,


960
01:02:17,270 --> 01:02:18,590
so we should walk through the code,


961
01:02:18,590 --> 01:02:20,480
we get sort of a feeling for the [lay of the land],


962
01:02:20,960 --> 01:02:26,510
and like how the details,


963
01:02:26,630 --> 01:02:28,910
it's worthwhile to step back a second


964
01:02:28,910 --> 01:02:31,430
and think a little bit about you know what it all means.


965
01:02:32,470 --> 01:02:36,370
In particular, what is interesting is interrupting concurrency,


966
01:02:36,370 --> 01:02:38,920
sort of think about interrupting the perspective concurrency.


967
01:02:42,440 --> 01:02:48,110
And this is one of the things actually makes interrupts tricky or difficult to program,


968
01:02:48,380 --> 01:02:51,560
so first of all, you know you mentioned earlier,


969
01:02:51,620 --> 01:02:54,080
the device you know uart in our case,


970
01:02:54,320 --> 01:02:57,620
the device and the CPU running parallel.


971
01:03:03,140 --> 01:03:06,230
So, one example is our you know scenario, would you talk about,


972
01:03:06,380 --> 01:03:12,290
you know you already sending off you know a character to the console,


973
01:03:12,380 --> 01:03:16,880
and while that's happening, the CPU still go go about its business


974
01:03:16,880 --> 01:03:19,250
and in this case returning to the shell,


975
01:03:19,370 --> 01:03:24,800
the shell may make another system called attempt to write a space character


976
01:03:25,070 --> 01:03:26,330
and all happens in parallel


977
01:03:26,510 --> 01:03:29,270
and so we need to manage that parallelism a bit


978
01:03:29,270 --> 01:03:30,710
and we already saw a little bit,


979
01:03:30,710 --> 01:03:32,330
but I'm gonna talk a little bit more in detail.


980
01:03:32,620 --> 01:03:35,080
And the type of parallelism that actually shows up here


981
01:03:35,110 --> 01:03:37,570
is typically called producer consumer parallelism.


982
01:03:49,040 --> 01:03:50,330
Let me talk about, in a second,


983
01:03:50,330 --> 01:03:52,670
so now we're gonna talk about it a little more detail.


984
01:03:52,850 --> 01:03:53,840
The second is,


985
01:03:54,680 --> 01:04:03,790
that the interrupt stops the current running program,


986
01:04:08,450 --> 01:04:09,860
or the current program is running.


987
01:04:12,740 --> 01:04:14,150
So in the case of the shell,


988
01:04:14,360 --> 01:04:18,950
shell might be executing instruction like 212


989
01:04:19,250 --> 01:04:20,630
and boom interrupt comes in


990
01:04:20,630 --> 01:04:22,580
an immediate point is just stopped.


991
01:04:23,340 --> 01:04:26,070
And that's something you know for user space code,


992
01:04:26,070 --> 01:04:27,540
that's not a particularly big deal,


993
01:04:27,720 --> 01:04:30,180
because when we return from the interrupt,


994
01:04:30,180 --> 01:04:33,690
will we restore all the state of the user level program


995
01:04:33,870 --> 01:04:38,040
and it will resume you know at you know address which got interrupted


996
01:04:38,100 --> 01:04:41,230
and so we've seen that with traps and page faults,


997
01:04:41,230 --> 01:04:44,590
and so you know, actually works out reasonable well,


998
01:04:44,620 --> 01:04:46,450
but there's a little bit of tricky case,


999
01:04:46,450 --> 01:04:48,700
when the kernel itself interrupted,


1000
01:04:48,730 --> 01:04:50,110
so you're running in kernel mode


1001
01:04:50,260 --> 01:04:51,550
and the kernel gets interrupted.


1002
01:04:52,020 --> 01:04:55,650
That means that, and talk a little bit more detail,


1003
01:04:55,680 --> 01:04:59,400
that even the kernel doesn't really sort of executed straight sequentially,


1004
01:04:59,580 --> 01:05:02,640
if you see one kernel instruction followed by another internal instruction,


1005
01:05:03,030 --> 01:05:06,810
in the between those instructions and interrupt might happen,


1006
01:05:07,590 --> 01:05:11,070
depending whether interrupts are enabled or not.


1007
01:05:11,820 --> 01:05:14,340
In the [whether] and some piece of code


1008
01:05:14,340 --> 01:05:16,710
and it's not good to have an interrupt in between,


1009
01:05:16,800 --> 01:05:17,910
and the next case,


1010
01:05:17,910 --> 01:05:20,880
you know the kernel might actually have to disable or enable interrupts


1011
01:05:20,880 --> 01:05:23,700
to make basically code sequences atomic.


1012
01:05:24,930 --> 01:05:30,880
So interrupt enable and disable.


1013
01:05:35,230 --> 01:05:37,180
I'll talk about in a second in more detail


1014
01:05:37,270 --> 01:05:41,290
and sort of the third , sort of currency problem


1015
01:05:41,290 --> 01:05:45,770
that shows up in the, in interrupt handler.


1016
01:05:47,490 --> 01:05:49,320
Let me say let me say differently,


1017
01:05:49,530 --> 01:05:59,180
the top of the driver, and the bottom of the driver, may run in parallel.


1018
01:06:08,660 --> 01:06:11,180
So, for example in our example .


1019
01:06:12,370 --> 01:06:16,870
The shell is going to be called the write system call again,


1020
01:06:16,870 --> 01:06:19,840
you [pray] the write space after it printed the dollar


1021
01:06:20,050 --> 01:06:23,920
and while you may go back into the top level of the driver,


1022
01:06:24,010 --> 01:06:26,560
it might want to add may want to add,


1023
01:06:26,590 --> 01:06:30,670
you know, this white space to that queue the the uart actually has,


1024
01:06:30,820 --> 01:06:33,280
but at the same time on another CPU,


1025
01:06:33,370 --> 01:06:38,050
it might actually take interrupt you know for the uart


1026
01:06:38,200 --> 01:06:41,740
and basically also running in parallel


1027
01:06:41,740 --> 01:06:43,390
and that's sort of roughly the same code


1028
01:06:43,390 --> 01:06:44,680
and looking at the same queue.


1029
01:06:45,300 --> 01:06:46,380
And so it's really true


1030
01:06:46,380 --> 01:06:48,870
that basically the interrupt handler can run in parallel


1031
01:06:48,870 --> 01:06:50,400
at the bottom half of the device driver


1032
01:06:50,400 --> 01:06:52,530
may run in parallel on different CPU's,


1033
01:06:53,000 --> 01:06:56,660
on the different CPU with the top half of the driver.


1034
01:06:57,270 --> 01:06:58,650
So we have to manage that bit,


1035
01:06:58,950 --> 01:07:02,460
and the way we're going to manage that is using locks.


1036
01:07:06,060 --> 01:07:07,740
Because there's a shared data structure here


1037
01:07:07,740 --> 01:07:09,360
and then we need a buffer


1038
01:07:09,480 --> 01:07:13,800
and we're going to make sure that you know the buffer is updated correctly,


1039
01:07:14,040 --> 01:07:19,860
and you need to make sure that only one CPU at a time,


1040
01:07:19,860 --> 01:07:21,750
basically manipulates that particular buffer,


1041
01:07:21,750 --> 01:07:22,620
we're going to use locks.


1042
01:07:23,100 --> 01:07:25,500
And locks is going to be the topic of Wednesday's lecture,


1043
01:07:25,560 --> 01:07:27,180
I'm not gonna talk much about it at all,


1044
01:07:27,210 --> 01:07:29,190
but will show a big time on Wednesday.


1045
01:07:30,810 --> 01:07:38,090
The thing I want to focus on is actually to produce consumer parallelism,


1046
01:07:38,240 --> 01:07:41,300
and this is a typical thing that shows up in a drivers


1047
01:07:41,300 --> 01:07:44,990
and it's extremely common to see that,


1048
01:07:44,990 --> 01:07:48,260
so producer consumer.


1049
01:07:53,150 --> 01:07:55,520
And it's pretty straightforward ,


1050
01:07:55,550 --> 01:08:00,020
so when you see you know there's basically a buffer in the driver.


1051
01:08:01,750 --> 01:08:04,240
You know in our case, I think there were 32 entries in it,


1052
01:08:04,630 --> 01:08:07,210
so zero to three one


1053
01:08:07,420 --> 01:08:10,240
and there's two pointers,


1054
01:08:10,700 --> 01:08:12,890
there's a read pointer and the write pointer.


1055
01:08:13,870 --> 01:08:17,290
Yeah use, the write pointer read pointer


1056
01:08:17,320 --> 01:08:19,120
if they are equal,


1057
01:08:19,150 --> 01:08:20,380
you know the buffer is empty


1058
01:08:20,560 --> 01:08:24,250
and so when you know the shell, we do, write,


1059
01:08:24,280 --> 01:08:29,710
you know that basically puts the character like the dollar here


1060
01:08:29,860 --> 01:08:32,740
and bumps up the write pointer to the next entry.


1061
01:08:34,440 --> 01:08:36,030
So that's sort of the producer part


1062
01:08:36,240 --> 01:08:37,740
and the producer can keep going,


1063
01:08:37,740 --> 01:08:40,560
you know filling up you know all this characters


1064
01:08:40,560 --> 01:08:45,610
until you know it , until hits you know the point,


1065
01:08:45,610 --> 01:08:48,190
you know if the next increment would hit the read pointer,


1066
01:08:48,190 --> 01:08:50,980
we know that this circle buffer is full


1067
01:08:51,100 --> 01:08:53,170
and at that point you know the producer must stop


1068
01:08:53,200 --> 01:08:56,650
and we saw that happening in the, in the code a second ago,


1069
01:08:56,650 --> 01:08:59,440
where the user basically the uart called sleep


1070
01:08:59,470 --> 01:09:04,760
and we'll put this the shell on the side


1071
01:09:04,760 --> 01:09:06,410
and start running another process.


1072
01:09:07,940 --> 01:09:10,940
So the interrupt handler, uartinit or intr,


1073
01:09:12,870 --> 01:09:19,890
in this case at the consumer, immediately every time when it's a uartstart,


1074
01:09:19,920 --> 01:09:23,370
basically when you're in interrupts,


1075
01:09:23,370 --> 01:09:25,320
it will look at you know the read pointer,


1076
01:09:25,470 --> 01:09:28,320
if the read pointer is behind the write pointer,


1077
01:09:28,320 --> 01:09:29,730
are the write pointer any further,


1078
01:09:29,730 --> 01:09:31,410
let's say spaces here too, now,


1079
01:09:31,410 --> 01:09:33,900
I know actually how to draw a space but here's a space.


1080
01:09:34,500 --> 01:09:37,110
And so the write pointer might now be here.


1081
01:09:37,680 --> 01:09:39,570
So after the alteration being sent,


1082
01:09:39,570 --> 01:09:43,020
you know the uart sees, you know I'm behind the write pointer,


1083
01:09:43,020 --> 01:09:45,000
and that means I got to send the next one.


1084
01:09:46,280 --> 01:09:50,000
And so you can think about this as sort of these write, you know pointer,


1085
01:09:50,000 --> 01:09:56,390
the read pointer is changing the the write pointer and that's what's going on,


1086
01:09:56,390 --> 01:09:58,100
now it could be the case that at some point,


1087
01:09:58,460 --> 01:10:02,330
the uart keeps up with the right pointer


1088
01:10:02,330 --> 01:10:05,150
and when they're equal and then it knows that the buffer is empty


1089
01:10:05,150 --> 01:10:05,900
and there's nothing to do.


1090
01:10:09,220 --> 01:10:09,910
Does that make sense.


1091
01:10:12,190 --> 01:10:16,900
Sorry, so this data structure is the same for all cores?


1092
01:10:17,400 --> 01:10:20,520
Um, OK, so let me go back to the code right,


1093
01:10:20,550 --> 01:10:23,010
then a high-level picture.


1094
01:10:23,560 --> 01:10:25,090
And let's go back to uart,


1095
01:10:25,090 --> 01:10:28,920
so this data structure, that we just talked about is this buffer.


1096
01:10:32,600 --> 01:10:35,240
And the two pointers to the write and the read pointer,


1097
01:10:35,240 --> 01:10:38,430
are these two indexes use in [].


1098
01:10:39,330 --> 01:10:39,990
Okay?


1099
01:10:41,080 --> 01:10:44,110
And this data structure [using] memory,


1100
01:10:45,010 --> 01:10:47,200
and there's only one RAM right


1101
01:10:47,200 --> 01:10:51,790
and so all the cores, might be interacting with this data structure in parallel.


1102
01:10:53,220 --> 01:10:54,510
That's why we need locks.


1103
01:10:57,350 --> 01:10:58,340
Okay I see.


1104
01:10:58,370 --> 01:11:01,160
And rather the question was for sleep,


1105
01:11:02,180 --> 01:11:07,630
how does it know to, make the shell sleep,


1106
01:11:07,690 --> 01:11:09,640
like what is written there,


1107
01:11:09,940 --> 01:11:11,770
is just the address of.


1108
01:11:11,770 --> 01:11:19,810
Um, let me, basically the sleep puts the current process running,


1109
01:11:20,300 --> 01:11:22,640
on the sleep, in a sleep state,


1110
01:11:23,030 --> 01:11:25,160
we'll talk about it in next week


1111
01:11:25,160 --> 01:11:26,960
or the week after a great amount of detail.


1112
01:11:27,520 --> 01:11:31,120
And it passes in the thing that is waiting for.


1113
01:11:31,690 --> 01:11:34,990
And in this case that is the address,


1114
01:11:34,990 --> 01:11:36,580
you know basically has a channel idea


1115
01:11:36,580 --> 01:11:39,520
or a way of communicating from one actually sleeping on.


1116
01:11:40,260 --> 01:11:45,120
And so in this case, the [tx] is the address of uart_tx_r.


1117
01:11:45,750 --> 01:11:51,390
And, and the start function,


1118
01:11:51,600 --> 01:11:54,480
it wants their space again in the buffer,


1119
01:11:54,630 --> 01:11:58,670
it will wake up, we'll call the corresponding call,


1120
01:11:58,670 --> 01:12:01,850
wake up with the uart_tx_r to indicate that any process


1121
01:12:01,850 --> 01:12:04,640
that actually sleeping on this address should be woken up.


1122
01:12:07,190 --> 01:12:10,640
And how does exactly implemented is something that we'll see a little bit later.


1123
01:12:13,680 --> 01:12:14,310
So it makes sense.


1124
01:12:14,790 --> 01:12:17,280
So these two goals go together, sleep and wake up,


1125
01:12:21,470 --> 01:12:23,510
sometimes called conditional synchronization.


1126
01:12:27,440 --> 01:12:28,370
Any other questions?


1127
01:12:35,990 --> 01:12:36,560
Okay.


1128
01:12:37,590 --> 01:12:38,580
Good, um.


1129
01:12:39,530 --> 01:12:42,140
Let's , let's see .


1130
01:12:43,100 --> 01:12:48,470
So that there's basically the whole story for printing dollar


1131
01:12:48,470 --> 01:12:53,030
and as you can see it's actually quite involved a lot of pieces


1132
01:12:53,030 --> 01:12:56,870
that we're working together to actually get this dollar out to the console.


1133
01:12:57,710 --> 01:13:02,450
And something similar basically happens on the read side,


1134
01:13:02,450 --> 01:13:08,690
so at some point shell has printed the both the dollar and the white space,


1135
01:13:08,690 --> 01:13:13,280
and then will call read to basically read input from the keyboard,


1136
01:13:13,580 --> 01:13:16,010
so now we wanted to see what happens,


1137
01:13:16,070 --> 01:13:18,890
when that happening,


1138
01:13:18,890 --> 01:13:21,920
so that starts basically in the with file again.


1139
01:13:22,470 --> 01:13:24,630
So now there's a read system call,


1140
01:13:24,960 --> 01:13:27,630
if it's you know reading from the console,


1141
01:13:27,630 --> 01:13:29,550
it will calls, it will actually,


1142
01:13:30,140 --> 01:13:32,840
of course file of read, sorry not write.


1143
01:13:34,500 --> 01:13:38,610
If it's the device which in this case the case is a console,


1144
01:13:38,610 --> 01:13:41,910
then we call the read method for that device.


1145
01:13:42,320 --> 01:13:44,510
And that is in console.c


1146
01:13:44,510 --> 01:13:47,480
and so we're going to consoleread is being called.


1147
01:13:49,330 --> 01:13:52,150
And basically it has the same structure as uart,


1148
01:13:52,150 --> 01:13:55,470
you know there's a circular buffer on the top.


1149
01:13:56,700 --> 01:14:01,260
Here it is, it's an input buffer from the 128 characters in it


1150
01:14:01,500 --> 01:14:02,910
and basically it's the same game,


1151
01:14:02,940 --> 01:14:04,770
its producer consumer parallelism,


1152
01:14:04,950 --> 01:14:07,560
but in this case, the shell is the consumer right,


1153
01:14:07,560 --> 01:14:11,550
it actually is reading you know characters off the buffer.


1154
01:14:12,040 --> 01:14:13,930
And the keyboard is the producer,


1155
01:14:13,930 --> 01:14:16,540
it takes the characters into the buffer.


1156
01:14:17,250 --> 01:14:20,280
And so you know, let's go back to consoleread,


1157
01:14:20,310 --> 01:14:22,500
if there's nothing,


1158
01:14:22,500 --> 01:14:26,850
if the read pointer where to read index and write index are the same,


1159
01:14:26,850 --> 01:14:28,440
you know the buffer is empty


1160
01:14:28,650 --> 01:14:30,420
and it goes back to sleep again.


1161
01:14:31,320 --> 01:14:35,340
And so, so after it's printed dollar [m percent],


1162
01:14:35,520 --> 01:14:38,190
the shell is go to sleep,


1163
01:14:38,520 --> 01:14:44,340
were kernel put the shell sleep until character comes in.


1164
01:14:45,440 --> 01:14:49,280
And so at some point, let's say a user types in l,


1165
01:14:49,670 --> 01:14:52,370
you know the first character from ls on the keyboard,


1166
01:14:52,700 --> 01:15:00,110
that will calls, you know, the l to be sent into the uart chip on the on the board,


1167
01:15:00,530 --> 01:15:04,100
that will be round through the plic to show core,


1168
01:15:04,100 --> 01:15:07,220
that core will take the interrupt that will go to [devintr],


1169
01:15:07,220 --> 01:15:09,650
the devintr will see how that goes uart interrupt


1170
01:15:09,950 --> 01:15:14,630
and it will call the function that we looked at a second ago.


1171
01:15:15,020 --> 01:15:16,820
It goes back to the bottom,


1172
01:15:16,850 --> 01:15:19,190
where I got confused myself for a second,


1173
01:15:19,700 --> 01:15:22,550
so in this case, you know it will write,


1174
01:15:22,610 --> 01:15:25,250
will get a character from the device from uart device


1175
01:15:25,250 --> 01:15:29,480
that will get the character l and we'll call the consoleintr function,}


1176
01:15:29,690 --> 01:15:31,250
using the character l,


1177
01:15:31,370 --> 01:15:33,230
so we can go back to console.


1178
01:15:36,100 --> 01:15:39,490
And consoleintr does gets the character,


1179
01:15:39,490 --> 01:15:45,070
so now we have an l , it's a control P, you know actually printing list,


1180
01:15:45,160 --> 01:15:49,240
in the process list implements control H and control U,


1181
01:15:49,300 --> 01:15:51,880
to do back space and control whatever.


1182
01:15:52,320 --> 01:15:53,850
But in all other cases,


1183
01:15:53,880 --> 01:15:59,670
basically what it does it echoes the character back to the user by printing it to the console.


1184
01:16:00,300 --> 01:16:03,990
And then it basically sticks the character into the buffer,


1185
01:16:04,260 --> 01:16:09,330
so that and wake up, you know the process that's waiting for the buffer,


1186
01:16:09,390 --> 01:16:10,590
if there's a process waiting.


1187
01:16:11,190 --> 01:16:14,760
If it has hit new line and there's a process waiting,


1188
01:16:14,760 --> 01:16:17,010
it will wake up the waiting process,


1189
01:16:17,280 --> 01:16:20,370
and then the waiting process will read you know the characters out of the buffer.


1190
01:16:22,520 --> 01:16:28,310
Again, so here again we see this sort of decoupling using a buffer between the consumer and the producer,


1191
01:16:28,310 --> 01:16:30,620
so that the [precision] consumer can run in parallel,


1192
01:16:31,140 --> 01:16:33,210
independent each on their own speed,


1193
01:16:33,540 --> 01:16:34,950
and if one goes very fast,


1194
01:16:35,010 --> 01:16:37,170
you know either buffer will be empty or full,


1195
01:16:37,170 --> 01:16:39,990
and then block wait until the other guy catch up.


1196
01:16:43,380 --> 01:16:44,430
Any questions about this?


1197
01:16:55,150 --> 01:16:55,810
Okay .


1198
01:16:58,750 --> 01:17:05,810
Okay, wanna talk basically about one more thing. In that is.


1199
01:17:09,440 --> 01:17:13,610
You know I'm mostly talking a little bit about sort of interrupt evolution,


1200
01:17:13,640 --> 01:17:15,860
like what has happened over the last decades.


1201
01:17:25,230 --> 01:17:30,090
So few interviews to be relative to a processor reasonable fast.


1202
01:17:31,420 --> 01:17:37,350
In particular in there fast.


1203
01:17:38,120 --> 01:17:40,580
So in times the original Unix was developed,


1204
01:17:41,030 --> 01:17:42,710
you know that was the case


1205
01:17:42,980 --> 01:17:45,380
and that basically meant that the hardware is very simple.


1206
01:17:46,310 --> 01:17:50,360
There's gonna, if any really serious work needs to be done,


1207
01:17:50,480 --> 01:17:52,160
but we could just interrupt the processor


1208
01:17:52,430 --> 01:17:54,500
and the processor would do it on the work


1209
01:17:54,500 --> 01:17:58,760
and so [get] itself could be reasonable straight forward.


1210
01:17:59,850 --> 01:18:04,600
Now, interrupts are slow compared to the processor,


1211
01:18:04,960 --> 01:18:06,370
you can see that right,


1212
01:18:06,370 --> 01:18:10,060
because the interrupt handler, it needs to save and to registers,


1213
01:18:10,090 --> 01:18:11,590
it needs to take the interrupt,


1214
01:18:11,590 --> 01:18:16,420
so there's a couple you know a small budget instructions


1215
01:18:16,420 --> 01:18:18,880
that are just being used to actually serve the interrupt.


1216
01:18:19,460 --> 01:18:23,780
And so if device generates interrupts the high speed,


1217
01:18:23,780 --> 01:18:26,630
you know then the prosecutor's going to have a tough time keeping up.


1218
01:18:27,500 --> 01:18:30,530
And so you look at today's devices,


1219
01:18:30,560 --> 01:18:33,620
basically the hardware or the device there's a lot more work,


1220
01:18:39,400 --> 01:18:43,300
and so basically there's a bunch of work actually on the device itself,


1221
01:18:43,300 --> 01:18:45,130
before actually generating an interrupt.


1222
01:18:45,940 --> 01:18:50,590
And so, and just to avoid interrupting the processor too much.


1223
01:18:51,350 --> 01:18:54,920
Now, if you really have a high performance device,


1224
01:18:54,920 --> 01:18:59,130
like say you have gigabytes gigabytes Ethernet.


1225
01:19:01,000 --> 01:19:05,560
And you know that card you use a lot of small packages packets,


1226
01:19:05,830 --> 01:19:10,480
then you know you can actually generate were even itself could generate


1227
01:19:10,480 --> 01:19:13,600
about one five or 1.5 million packets per second,


1228
01:19:16,290 --> 01:19:19,110
for minimum of like 64 byte even a package,


1229
01:19:19,110 --> 01:19:21,330
you do a math roughly out to,


1230
01:19:21,330 --> 01:19:24,810
basically you generated 1.5 million packets per second you could receive.


1231
01:19:25,440 --> 01:19:28,110
And so that basically means you know one interrupt.


1232
01:19:30,280 --> 01:19:33,480
If you did it for every packet per microsecond.


1233
01:19:37,330 --> 01:19:40,390
In fact, a little more than ,


1234
01:19:40,960 --> 01:19:42,970
a little less than,


1235
01:19:42,970 --> 01:19:44,290
a little bit more than ,


1236
01:19:44,320 --> 01:19:48,400
so basically the way to think about if one interrupt microsecond,


1237
01:19:48,400 --> 01:19:50,500
there's basically two operations in a kernel,


1238
01:19:50,560 --> 01:19:53,830
basically has a budget of like one microsecond instructions


1239
01:19:53,830 --> 01:19:56,380
to actually process that packet in fact it's 1.5 million,


1240
01:19:56,380 --> 01:20:01,690
such a little bit less than a budget of a microsecond.


1241
01:20:02,540 --> 01:20:04,760
And you can compute how many instructions that is,


1242
01:20:04,940 --> 01:20:06,290
there's not gonna be that much


1243
01:20:06,650 --> 01:20:08,810
and so in that case,


1244
01:20:08,810 --> 01:20:11,000
you need to have a different plan,


1245
01:20:11,000 --> 01:20:15,350
so what do you do with the packets or to interrupt you know packages are coming in so fast,


1246
01:20:15,560 --> 01:20:18,800
that a pressure really can't keep up.


1247
01:20:19,550 --> 01:20:25,970
And the solution to that is to do a fast devices instructions,


1248
01:20:25,970 --> 01:20:27,620
sometimes uses called polling.


1249
01:20:32,960 --> 01:20:36,560
And , instead of writing interrupts,


1250
01:20:36,560 --> 01:20:38,960
you know what the CPU also could do


1251
01:20:38,960 --> 01:20:41,750
is just keep reading that control register


1252
01:20:41,780 --> 01:20:43,160
and to see if there's a byte there,


1253
01:20:43,160 --> 01:20:44,480
like in uart register,


1254
01:20:44,480 --> 01:20:47,660
we just keep reading that LHR register


1255
01:20:47,750 --> 01:20:49,580
and just check if there's a byte there.


1256
01:20:50,150 --> 01:20:56,330
In this basically, would you know what this boils down to is that the CPU [] spins,


1257
01:20:58,640 --> 01:21:00,950
it's spins on the device,


1258
01:21:01,490 --> 01:21:07,030
you know until device has input, has data.


1259
01:21:10,590 --> 01:21:13,230
And you know this waste CPU cycles right,


1260
01:21:13,230 --> 01:21:20,760
because while we're checking that register over and over and over again


1261
01:21:20,880 --> 01:21:22,920
to see if they're actually any data,


1262
01:21:23,070 --> 01:21:27,030
you know we're not using those cycles to run another application right


1263
01:21:27,030 --> 01:21:30,810
and you know before what you're seeing is that if there's nothing there,


1264
01:21:30,900 --> 01:21:33,120
basically the kernel push the shell to sleep,


1265
01:21:33,150 --> 01:21:34,680
so that another application could run.


1266
01:21:35,080 --> 01:21:39,250
But if we do polling, then that wouldn't happen ,


1267
01:21:39,430 --> 01:21:43,750
now for a slow device, you clearly want you not spin forever


1268
01:21:43,750 --> 01:21:46,810
until I finally gets around to actually doing its work,


1269
01:21:47,170 --> 01:21:51,910
we really like to basically switch out to the shell


1270
01:21:51,910 --> 01:21:53,200
and so that we can run something else.


1271
01:21:53,260 --> 01:21:55,420
But if the device is extremely fast,


1272
01:21:55,800 --> 01:21:58,770
then the overhead of the interrupt features high


1273
01:21:58,770 --> 01:22:02,310
and you know we're better off actually waiting basically polling the device,


1274
01:22:02,310 --> 01:22:04,560
because very quickly we're going to get success.


1275
01:22:06,840 --> 01:22:10,590
And so if but to show you ways to [] device slow.


1276
01:22:16,410 --> 01:22:24,880
But you know, but if devices fast,


1277
01:22:29,990 --> 01:22:33,440
it saves save saving a [story],


1278
01:22:36,740 --> 01:22:39,950
which saves the whole entry entry and exit costs.


1279
01:22:45,610 --> 01:22:48,550
And so for example high performing network card,


1280
01:22:48,550 --> 01:22:52,150
you know, will you know if it's a stream of packets coming in


1281
01:22:52,150 --> 01:22:53,650
and actually will use polling.


1282
01:22:54,180 --> 01:22:57,030
And you know more and the most sophisticated drivers


1283
01:22:57,210 --> 01:23:04,470
basically they dynamically switch, switch between polling and interrupts.


1284
01:23:18,170 --> 01:23:19,670
Okay, um.


1285
01:23:20,930 --> 01:23:21,830
Any questions?


1286
01:23:24,300 --> 01:23:27,030
Close to my my time budget is up.


1287
01:23:29,280 --> 01:23:30,540
And your remaining questions.


1288
01:23:35,170 --> 01:23:37,600
Okay, good, then I'll see you on Wednesday


1289
01:23:37,600 --> 01:23:42,250
and basically Wednesday, we're going to continue this story of concurrency parallelism,


1290
01:23:42,250 --> 01:23:45,370
we're gonna see some mechanisms to actually manage the parallelism


1291
01:23:45,490 --> 01:23:48,640
to make sure that shared data structures, get them data correctly.


1292
01:23:49,380 --> 01:23:51,000
So, see you on Wednesday.


1293
01:23:54,660 --> 01:23:55,710
Oh, I'm sorry,


1294
01:23:55,710 --> 01:23:59,010
I just I was trying to find where my question was,


1295
01:23:59,010 --> 01:24:00,120
because I lost it,


1296
01:24:00,210 --> 01:24:03,690
my question was in the ,


1297
01:24:03,720 --> 01:24:08,100
so I saw it, uartinit is just being called once,


1298
01:24:08,100 --> 01:24:16,580
is that why there's just one buffer for all the cores to share together.


1299
01:24:18,970 --> 01:24:21,160
Well, there's always the only one uart device.


1300
01:24:24,460 --> 01:24:30,760
[Offer menu] corresponds you know to the one uart device actually is being shared between all the cores.


1301
01:24:31,300 --> 01:24:35,560
You know like it might be multiple processes running on different cores,


1302
01:24:35,560 --> 01:24:37,060
all trying to print to the console.


1303
01:24:38,460 --> 01:24:39,930
Okay I see,


1304
01:24:39,960 --> 01:24:42,120
oh yeah, makes sense makes sense.


1305
01:24:42,820 --> 01:24:49,090
So like only one queue will do stuff with uart to the time.


1306
01:24:49,620 --> 01:24:52,200
Yeah, well you know it's slightly complicated,


1307
01:24:52,200 --> 01:24:55,680
but let's look like so let's say there's multiple guys writing.


1308
01:24:56,240 --> 01:25:00,080
Just afford as one experiment, correct.


1309
01:25:01,460 --> 01:25:03,470
And are.


1310
01:25:04,230 --> 01:25:06,570
And what we see there are multiple,


1311
01:25:06,660 --> 01:25:07,650
let me actually.


1312
01:25:11,630 --> 01:25:12,800
So here uartputc,


1313
01:25:12,800 --> 01:25:15,860
because the first thing you see is actually it actually requires a lock.


1314
01:25:16,790 --> 01:25:21,380
So the multiple cores are trying to put a character into the buffer


1315
01:25:21,650 --> 01:25:23,240
and one of them is going to get the lock


1316
01:25:23,270 --> 01:25:24,830
and none of the others are going to lock,


1317
01:25:25,190 --> 01:25:28,070
so that one guy you know the one CPU that actually got the lock,


1318
01:25:28,070 --> 01:25:29,420
required to lock successfully,


1319
01:25:29,660 --> 01:25:33,380
is able to go and look at the write pointer


1320
01:25:33,380 --> 01:25:38,180
and sticky character in if possible and otherwise go to sleep.


1321
01:25:38,850 --> 01:25:41,220
And you know and then if it's done,


1322
01:25:41,220 --> 01:25:43,230
you know releases the lock,


1323
01:25:43,650 --> 01:25:46,440
and then the next you know core can go in


1324
01:25:46,440 --> 01:25:48,450
and acquire the lock and do its work.


1325
01:25:48,910 --> 01:25:54,820
So this lock will serialize the concurrent accesses to the uart.


1326
01:25:58,400 --> 01:26:00,560
That makes sense, yeah, thank you.


1327
01:26:02,000 --> 01:26:04,700
Well, on Wednesday, we'll talk in detail about locks.


1328
01:26:07,210 --> 01:26:08,110
Thank you.


1329
01:26:10,160 --> 01:26:15,270
Any further questions? I have a question, so.


1330
01:26:16,760 --> 01:26:20,690
I, as far as I understand why we need the lock inside the interrupted,


1331
01:26:20,690 --> 01:26:24,920
because we there's only one console and they could multiple cores, right.


1332
01:26:27,000 --> 01:26:29,190
Oh, you mean going [we're just] lock, where.


1333
01:26:29,550 --> 01:26:34,770
I think so right, because usually we don't want to lock things inside interrupts right.


1334
01:26:34,800 --> 01:26:37,800
Yeah you asked this question by email.


1335
01:26:37,830 --> 01:26:38,880
Yeah.


1336
01:26:39,180 --> 01:26:42,750
Yes well the issue is that the as mentioned earlier,


1337
01:26:42,780 --> 01:26:48,930
the bottom half interrupt handler could run in parallel with the top half.


1338
01:26:49,480 --> 01:26:53,500
And so one core could be doing uartputc


1339
01:26:53,710 --> 01:26:56,140
and another core could be running uartintr,


1340
01:26:56,530 --> 01:26:59,440
we got to make sure that they sort of,


1341
01:26:59,440 --> 01:27:01,390
don't get tangled up together,


1342
01:27:01,420 --> 01:27:02,590
that they share [realized] correctly


1343
01:27:02,590 --> 01:27:04,870
and the lock basically ensures that they get serialized.


1344
01:27:05,480 --> 01:27:06,950
Okay, that makes sense,


1345
01:27:06,950 --> 01:27:10,430
but that does mean that sometimes


1346
01:27:10,430 --> 01:27:13,730
like all cores could potentially be waiting for one of them


1347
01:27:13,730 --> 01:27:15,410
to be handling this right.


1348
01:27:15,590 --> 01:27:15,980
Yeah.


1349
01:27:17,150 --> 01:27:21,770
Yeah, because the interrupt has to wait and then nothing else can get scheduled.


1350
01:27:22,220 --> 01:27:25,160
Well resume some other process maybe running,


1351
01:27:25,160 --> 01:27:28,070
it's unlikely, there's no deadlock,


1352
01:27:28,100 --> 01:27:29,810
okay, there is a risk of deadlock,


1353
01:27:29,810 --> 01:27:33,530
but not this one, that will talk about on Wednesday.


1354
01:27:34,670 --> 01:27:37,010
But but.


1355
01:27:38,140 --> 01:27:39,760
In the [room], what this means


1356
01:27:39,760 --> 01:27:44,820
like if there's multiple guys called uartputc, in the buffer full,


1357
01:27:45,180 --> 01:27:49,290
then some point, this interrupt they actually will release the lock.


1358
01:27:50,060 --> 01:27:53,330
So, for example let's go back to uartputc,


1359
01:27:53,330 --> 01:27:58,070
what actually what happened correct is that, they will call sleep.


1360
01:27:58,760 --> 01:28:00,980
And sleep actually takes the locks in argument


1361
01:28:01,010 --> 01:28:02,330
and we'll see later why,


1362
01:28:02,540 --> 01:28:06,710
but internally before sleep actually puts the process definitely to sleep


1363
01:28:06,710 --> 01:28:07,910
and will release the lock.


1364
01:28:08,920 --> 01:28:11,830
Oh I see, so basically you call sleep with the lock


1365
01:28:11,830 --> 01:28:14,500
and then that means OK release the lock while you sleep,


1366
01:28:14,500 --> 01:28:15,820
so someone else does not.


1367
01:28:16,570 --> 01:28:18,010
Okay interesting.


1368
01:28:18,810 --> 01:28:22,920
Yeah, and then when you return from sleep, you just reacquire, okay.


1369
01:28:23,160 --> 01:28:24,150
To lock back.


1370
01:28:24,510 --> 01:28:27,630
Right, right, yeah that makes.


1371
01:28:28,200 --> 01:28:29,640
Have to sleep has a seperate story,


1372
01:28:29,640 --> 01:28:31,170
that we'll talk about in a week or two weeks.


1373
01:28:32,100 --> 01:28:33,240
That makes sense, yeah yeah,


1374
01:28:33,270 --> 01:28:36,390
so I guess,


1375
01:28:37,540 --> 01:28:42,790
so I guess that wasn't that clear to me a do all CPUs get interrupted,


1376
01:28:42,790 --> 01:28:45,220
when somebody like send something through uart.


1377
01:28:45,870 --> 01:28:50,070
No, well depends, it depends on how you program the plic,


1378
01:28:50,460 --> 01:28:53,640
the way xv6 program the plic is


1379
01:28:53,640 --> 01:28:58,630
that only one CPU, all CPU might get interrupted, but.


1380
01:28:58,630 --> 01:28:59,020
Okay.


1381
01:28:59,050 --> 01:29:01,090
What is going to clean the interrupt.


1382
01:29:03,230 --> 01:29:03,860
Okay.


1383
01:29:04,540 --> 01:29:05,770
If you go back to the plic,


1384
01:29:05,770 --> 01:29:08,620
you know when you get interrupted, you call this plic claim


1385
01:29:08,650 --> 01:29:13,300
and that's CPU that particular core gonna get the ,


1386
01:29:13,820 --> 01:29:16,700
it's going to get the the IRQ


1387
01:29:17,030 --> 01:29:19,820
and then basically the plic will remember,


1388
01:29:19,820 --> 01:29:21,260
that IRQ is now being served


1389
01:29:21,260 --> 01:29:22,670
and won't give it to anybody else.


1390
01:29:24,720 --> 01:29:25,560
I see, okay,


1391
01:29:25,560 --> 01:29:29,400
so just one of them will get it randomly or no.


1392
01:29:31,260 --> 01:29:32,790
You can program to plic,


1393
01:29:32,790 --> 01:29:35,790
you'd say, maybe program to.


1394
01:29:35,790 --> 01:29:36,420
I see.


1395
01:29:37,050 --> 01:29:37,290
Plic.


1396
01:29:37,290 --> 01:29:40,410
I see, I see, so inside the yeah inside the plic


1397
01:29:40,410 --> 01:29:43,410
is the code that actually decides on who to bother.


1398
01:29:44,630 --> 01:29:47,330
Yeah, [like] a circle, there's no code in the plic, I think.


1399
01:29:47,330 --> 01:29:50,210
Yeah right, okay, okay I was.


1400
01:29:50,660 --> 01:29:51,620
CPU program.


1401
01:29:51,890 --> 01:29:55,890
I was, yeah great, okay.


1402
01:29:57,360 --> 01:29:59,850
Yeah I was just gonna say where does the plic code run,


1403
01:29:59,850 --> 01:30:01,440
but yeah it's not code, it's hardware,


1404
01:30:01,440 --> 01:30:02,460
okay that makes sense,


1405
01:30:02,940 --> 01:30:05,130
alright thanks I'll see you on Wednesday.


1406
01:30:06,290 --> 01:30:06,740
Yeah.


1407
01:30:07,440 --> 01:30:08,880
So I got a question,


1408
01:30:08,910 --> 01:30:14,430
kind of related to the thinking about multiple cores running at the same time.


1409
01:30:15,050 --> 01:30:17,690
So I think I recalling one of the labs


1410
01:30:17,690 --> 01:30:22,970
with say the prime question we saw that print actually like interleaves output often,


1411
01:30:23,060 --> 01:30:27,800
is that because the locks are only around like the putc,


1412
01:30:28,850 --> 01:30:32,510
but putc calls from multiple cores could interleave,


1413
01:30:32,510 --> 01:30:36,200
meaning that a single print [] is not guaranteed to be atomic .


1414
01:30:36,200 --> 01:30:36,740
You got it .


1415
01:30:37,160 --> 01:30:38,510
Okay, that makes sense.


1416
01:30:39,480 --> 01:30:40,320
Alright, thank you.


1417
01:30:40,560 --> 01:30:41,070
You're welcome.


1418
01:30:42,200 --> 01:30:43,160
I have a quick question,


1419
01:30:43,820 --> 01:30:51,050
so I remember reading in the like the reading said something about the timer interrupts being handled in machine mode


1420
01:30:51,680 --> 01:30:56,990
and I was wondering where that was handled when we were doing the traps lab,


1421
01:30:57,880 --> 01:31:02,260
like where the switch to machine mode was happening during the traps lab


1422
01:31:02,260 --> 01:31:04,330
and then what we were doing.


1423
01:31:04,880 --> 01:31:06,650
Yeah, okay great question ,


1424
01:31:06,650 --> 01:31:09,020
so you know the .


1425
01:31:09,870 --> 01:31:12,000
So I I'm pulling up the code,


1426
01:31:12,270 --> 01:31:14,400
so if you look at your start correctly,


1427
01:31:14,400 --> 01:31:16,920
there's a start [rooms] in at the beginning of time


1428
01:31:16,920 --> 01:31:17,790
when the machine boots.


1429
01:31:18,320 --> 01:31:21,350
And it programs the timer check,


1430
01:31:22,140 --> 01:31:24,180
and so here's timerinit


1431
01:31:24,660 --> 01:31:29,460
and timerinit basically programs, the plic the clint,


1432
01:31:29,490 --> 01:31:31,080
which is the local interrupt,


1433
01:31:31,080 --> 01:31:37,600
to generate interrupts when the clock interrupt happens


1434
01:31:37,930 --> 01:31:45,310
and basically here's probably the most important function here ,


1435
01:31:45,490 --> 01:31:48,850
it sets the machine mode trap handler


1436
01:31:48,850 --> 01:31:50,320
to this function called timervec,


1437
01:31:50,440 --> 01:31:51,850
that's written assembly.


1438
01:31:52,450 --> 01:31:55,120
And when the timer interrupt happens,


1439
01:31:55,120 --> 01:31:56,470
that function is being called.


1440
01:31:57,210 --> 01:32:01,620
And so when your kernel running user mode or in supervisor mode


1441
01:32:01,950 --> 01:32:06,400
and clint generates an interrupt [grazes] the line


1442
01:32:06,790 --> 01:32:10,480
and it will switch to machine mode


1443
01:32:10,480 --> 01:32:11,920
and call this function timervec,


1444
01:32:12,250 --> 01:32:18,160
in same way basically as almost equivalent to what we've seen for supervisor mode and user mode.


1445
01:32:18,560 --> 01:32:24,710
Okay, and then if you look in kernelvec.S.


1446
01:32:25,360 --> 01:32:27,550
We looked at kernelvec a lot right,


1447
01:32:27,550 --> 01:32:29,530
I mean that stuff function to see if it stores a lot.


1448
01:32:29,800 --> 01:32:31,180
And here's timervec,


1449
01:32:31,870 --> 01:32:34,270
it's basically the same sort of type of idea,


1450
01:32:34,390 --> 01:32:37,000
let's see if a couple registers so that it can do its job


1451
01:32:37,390 --> 01:32:40,810
and the only job it does actually these sort of six lines of code here,


1452
01:32:41,360 --> 01:32:44,690
or whatever five seven lines of code


1453
01:32:44,960 --> 01:32:49,670
and basically what it does you know [reprograms] the claims to generate future interrupts


1454
01:32:49,820 --> 01:32:54,140
and then basically raises a software interrupt to the supervisor,


1455
01:32:54,540 --> 01:32:56,670
so this goes to supervisor mode.


1456
01:32:57,410 --> 01:32:57,860
Okay.


1457
01:32:57,860 --> 01:33:01,250
So then at the point at mret,


1458
01:33:01,790 --> 01:33:06,260
mret, let's say the kernel was interrupted during a timer chip with a timer chip,


1459
01:33:06,260 --> 01:33:07,430
so it went to machine mode,


1460
01:33:07,760 --> 01:33:11,210
mret then returned from machine mode back to supervisor mode right,


1461
01:33:11,960 --> 01:33:16,100
and if the interrupt enabled supervisor mode at that point,


1462
01:33:16,100 --> 01:33:20,240
maybe the supervisor in the supervisor suffer interrupt will be generated.


1463
01:33:20,990 --> 01:33:22,070
Oh, okay.


1464
01:33:22,160 --> 01:33:24,710
And now basically the kernel will do the same thing,


1465
01:33:24,710 --> 01:33:28,730
basically will go to kernelvec, you know save restore all the registers


1466
01:33:28,970 --> 01:33:33,440
and and then go to a kernel trap


1467
01:33:33,740 --> 01:33:36,560
and the kernel trap, we'll see haha, that was the timer interrupt.


1468
01:33:37,360 --> 01:33:41,500
I see, and so what was the point of switching to machine mode in the first place


1469
01:33:41,530 --> 01:33:43,510
at like what exactly does it do.


1470
01:33:44,440 --> 01:33:46,360
I don't know what the point,


1471
01:33:46,360 --> 01:33:48,280
this is hardware works.


1472
01:33:48,670 --> 01:33:50,530
Okay gotcha.


1473
01:33:50,980 --> 01:33:53,830
Actually do a little bit more,


1474
01:33:53,830 --> 01:33:56,260
yeah yeah yeah,


1475
01:33:56,260 --> 01:34:01,000
there are some reasons I think why use a timer chip exposed to machine mode,


1476
01:34:01,000 --> 01:34:03,040
but from our perspective,


1477
01:34:03,480 --> 01:34:08,100
you know would be great if we could have delegated the timer interrupt [drug trade] to supervisor mode


1478
01:34:08,100 --> 01:34:10,350
and never had to deal with timer [mode],


1479
01:34:10,380 --> 01:34:14,310
but you know that doesn't work for this particular chip.


1480
01:34:14,930 --> 01:34:17,000
Okay, that makes sense, thank you so much.


1481
01:34:17,300 --> 01:34:17,930
Your welcome.


1482
01:34:19,300 --> 01:34:23,140
Oh I actually have a follow-up on this part of.


1483
01:34:23,710 --> 01:34:26,140
So keep adk your questions.


1484
01:34:26,140 --> 01:34:28,330
Yeah, um.


1485
01:34:28,760 --> 01:34:35,180
I saw that it allocates 32, you went sixty fours


1486
01:34:35,180 --> 01:34:40,970
but it only seems to be using four no three of them, right,


1487
01:34:41,000 --> 01:34:44,330
instead does see it.


1488
01:34:44,940 --> 01:34:48,960
And scratch, yeah I guess it allocates more than is necessary,


1489
01:34:48,960 --> 01:34:53,670
scratches thirty-two scratch area,


1490
01:34:53,700 --> 01:34:58,200
the reason, so ,


1491
01:34:59,520 --> 01:35:01,800
so for every CPU correct,


1492
01:35:01,920 --> 01:35:04,350
there has to be some scratch space


1493
01:35:04,380 --> 01:35:08,610
and there I guess we have three or something like that CPUs,


1494
01:35:08,610 --> 01:35:10,650
so basically allocates a little bit too much,


1495
01:35:17,970 --> 01:35:21,120
but there's no [] allocating too much.


1496
01:35:22,260 --> 01:35:27,300
Okay, okay, it's like it only uses scratch zero scratch one scratch two.


1497
01:35:27,300 --> 01:35:34,980
Or are you just three, I guess so as zero to three, that's for four or five current six.


1498
01:35:35,360 --> 01:35:41,150
So it's six integers and I guess,


1499
01:35:41,150 --> 01:35:43,670
we have we're running we could run with four CPUs,


1500
01:35:43,670 --> 01:35:44,690
but we're running with three,


1501
01:35:44,690 --> 01:35:45,920
but we could run four.


1502
01:35:47,840 --> 01:35:50,420
So six times four twenty four, [like I scare those].


1503
01:35:50,960 --> 01:35:52,730
You're definitely allocating too much memory.


1504
01:35:54,090 --> 01:35:56,160
I don't remember I thought about this a while back ago


1505
01:35:56,160 --> 01:36:04,220
and I don't remember exactly where 32 came from.


1506
01:36:05,290 --> 01:36:07,540
So we need double check.


1507
01:36:08,660 --> 01:36:09,980
So you can reconstruct it.


1508
01:36:41,430 --> 01:36:48,360
Oh yeah, same stores, they all they all eight bytes, right.


1509
01:36:49,520 --> 01:36:50,270
Yeah.


1510
01:36:53,190 --> 01:36:55,140
And it.


1511
01:37:03,830 --> 01:37:05,750
Okay, let me get back to you,


1512
01:37:05,750 --> 01:37:09,380
I can't recall right at the top my head you know why it is the way it is.


1513
01:37:10,450 --> 01:37:13,900
Okay makes sense, thank you so much.


1514
01:37:14,050 --> 01:37:15,220
You're welcome, good questions.


1515
01:37:15,580 --> 01:37:16,750
Thank you.


