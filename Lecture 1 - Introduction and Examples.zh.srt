1
00:00:01,900 --> 00:00:04,270
好的，
All right,

2
00:00:04,270 --> 00:00:08,770
欢迎学习 6.S081 操作系统，
welcome to 6.S081 operating systems,

3
00:00:08,770 --> 00:00:10,720
我是 Robert ，我将和 Frans 一起执教，
I'm Robert I'll be co-lecturing

4
00:00:10,720 --> 00:00:14,320
另外， David 和 Nicolass 作为
with Frans and David and Nicolaas

5
00:00:14,320 --> 00:00:16,180
助教。
of the TAs.

6
00:00:16,450 --> 00:00:18,850
在 zoom 讲座的时候，
So, please during the zoom lectures,

7
00:00:18,850 --> 00:00:19,690
随时可以提问，
ask questions,

8
00:00:19,690 --> 00:00:21,460
你可以讲话打断我，
you can either interrupt me by

9
00:00:21,460 --> 00:00:24,280
或者在聊天窗口中
audio or enter something into

10
00:00:24,280 --> 00:00:25,740
输入一些东西。
the chat window.

11
00:00:25,840 --> 00:00:27,730
我们会有一名工作人员查看
Um, one of the staff will see and ask

12
00:00:27,730 --> 00:00:28,840
question for you.
并替你提问。

13
00:00:29,900 --> 00:00:31,430
顺便说一下，我们会录下这些讲座，
By the way we'll be recording these

14
00:00:31,430 --> 00:00:33,680
然后把录音开放出来，
lectures and then we'll post recordings later

15
00:00:33,680 --> 00:00:36,170
这样你们可以复习，
so you can review them or for

16
00:00:36,170 --> 00:00:38,180
people who can't make this time so
或者对于这次来不了的人，

17
00:00:38,180 --> 00:00:39,740
they can nevertheless see lectures.
他们仍然可以看到讲座。

18
00:00:40,710 --> 00:00:43,680
好的，首先我想列出
All right, I want to start by

19
00:00:43,680 --> 00:00:44,850
课程的一些目标。
laying out some of the goals

20
00:00:44,850 --> 00:00:46,500
那么，
of the course. So,

21
00:00:46,750 --> 00:00:49,330
第一个是，
number one is to um,

22
00:00:49,330 --> 00:00:53,680
understand a design and implementation
理解操作系统的

23
00:00:53,680 --> 00:00:56,180
of operating systems.
设计和实现。

24
00:00:56,310 --> 00:00:58,120
嗯，
Um,

25
00:00:58,840 --> 00:01:01,210
设计是一种高层次的结构，
design is sort of high level structure

26
00:01:01,210 --> 00:01:03,550
而实现实际上是代码
and implementation is really about what the

27
00:01:03,550 --> 00:01:04,600
看起来的样子，
code looks like,

28
00:01:04,600 --> 00:01:06,740
我们将花费大量的时间在这两个方面。
and we'll spending a lot of time with both.

29
00:01:07,940 --> 00:01:11,840
为了更深入地理解
And in the interest of getting a

30
00:01:11,840 --> 00:01:13,640
deep understanding of what's going on,
这些怎么运行，

31
00:01:13,640 --> 00:01:18,280
you'll get hands-on experience with a small
你将获得实践经验，通过使用

32
00:01:18,420 --> 00:01:23,130
一个小型操作系统，
um, a small operating system,

33
00:01:23,130 --> 00:01:24,980
xv6 操作系统。
the xv6 operating system.

34
00:01:25,320 --> 00:01:27,420
嗯，
Um, and,

35
00:01:27,420 --> 00:01:29,010
除了实际查看
in addition to actually looking at an

36
00:01:29,010 --> 00:01:30,270
现有的操作系统，
existing operating system,

37
00:01:30,270 --> 00:01:33,270
在实验室中，你还可以
you'll be a in the labs

38
00:01:33,270 --> 00:01:35,070
获得以下经验，扩展操作系统，
get a bunch of experience extending

39
00:01:35,070 --> 00:01:37,410
改进操作系统，
the operating system modifying improving its

40
00:01:37,410 --> 00:01:41,100
编写使用操作系统接口的
behavior and writing system software that

41
00:01:41,100 --> 00:01:43,740
系统软件，
it uses the operating system interfaces,

42
00:01:43,740 --> 00:01:45,140
在操作系统运行应用程序时。
if it works an application.

43
00:01:45,320 --> 00:01:47,420
嗯，
Um,

44
00:01:47,420 --> 00:01:48,560
这就是你们
so this is what you're going to

45
00:01:48,560 --> 00:01:49,730
在课程中要做的。
be doing in the course.

46
00:01:49,730 --> 00:01:52,400
Um,

47
00:01:52,980 --> 00:01:55,710
在课程中，我们对操作系统
We're also interested in what the purpose

48
00:01:55,710 --> 00:01:57,360
本身的用途
of the operating system itself is as

49
00:01:57,360 --> 00:01:58,800
也很感兴趣。
well as the course.

50
00:02:00,980 --> 00:02:02,090
因此，
So for that I have a

51
00:02:02,090 --> 00:02:04,040
我有一系列
sort of list of a couple

52
00:02:04,040 --> 00:02:05,540
的东西，
of things which,

53
00:02:05,540 --> 00:02:08,630
你知道的，有很多操作系统，
um, you know there's lots of operating system,

54
00:02:08,630 --> 00:02:10,550
不同的操作系统，
different operating systems out there,

55
00:02:10,550 --> 00:02:13,780
它们通常有一套共同的用途.
they typically have a common set of purposes.

56
00:02:15,150 --> 00:02:20,080
其中一个就是对硬件的抽象，
Um, one of them is to abstract the hardware,

57
00:02:21,520 --> 00:02:23,770
就是通常
um, that is what you're given

58
00:02:23,770 --> 00:02:25,420
你的起点，
typically as a kind of starting point is

59
00:02:25,420 --> 00:02:26,170
就是买一台电脑，
you buy a computer,

60
00:02:26,170 --> 00:02:27,760
一台电脑有 CPU 和内存，
a computer has a CPU and memory

61
00:02:27,760 --> 00:02:29,880
但是这是一个非常低的层级。
but that's a very low level.

62
00:02:29,940 --> 00:02:31,770
作为一组资源，
A set of resources,

63
00:02:31,770 --> 00:02:33,300
拥有更高级别的接口
it's fantastic to have a much higher

64
00:02:33,300 --> 00:02:36,780
和抽象是非常棒的，
level interfaces and abstractions that applications can

65
00:02:36,780 --> 00:02:40,740
应用程序可以使用这些接口和抽象，
use such as processes or file systems

66
00:02:40,740 --> 00:02:43,740
例如为了方便和可移植性而使用进程或文件系统。
both for convenience and for portability.

67
00:02:44,360 --> 00:02:47,180
操作系统的另一个非常重要的任务是
Another very important task of an operating

68
00:02:47,180 --> 00:02:49,960
在许多应用程序中
system is to multiplex the hardware

69
00:02:50,190 --> 00:02:52,000
复用硬件。
among many applications.

70
00:02:52,360 --> 00:02:55,120
你可能正在运行文本编辑器和
Um, you might be running a text editor,

71
00:02:55,120 --> 00:02:56,470
编译器，
and a compiler,

72
00:02:56,470 --> 00:02:58,180
或者可能
or maybe

73
00:02:58,280 --> 00:03:01,400
在您的操作系统上运行
a multiple different database servers or something

74
00:03:01,400 --> 00:03:02,420
多个不同的数据库服务器或其他东西，
on your operating system,

75
00:03:02,420 --> 00:03:03,830
这非常棒，能够让
it's fantastic to be able to have

76
00:03:03,830 --> 00:03:05,210
操作系统
the operating system run

77
00:03:05,210 --> 00:03:06,020
同时运行，
both of them at the same

78
00:03:06,020 --> 00:03:07,250
或者所有的事情
time or all the things are

79
00:03:07,250 --> 00:03:08,690
都在同一时间进行，
going on at the same time

80
00:03:08,690 --> 00:03:10,360
而不会受到干扰。
without having them interfere.

81
00:03:11,420 --> 00:03:15,230
这通常被称为多路复用，
That's often called multiplexing, because

82
00:03:15,230 --> 00:03:15,980
因为操作系统中
there may be a lot of

83
00:03:15,980 --> 00:03:17,630
可能会同时
things happening in the operating system

84
00:03:17,630 --> 00:03:19,070
发生很多事情，
at the same time, it's critical

85
00:03:19,070 --> 00:03:21,770
关键是即使有 bug ，
that they not interfere unintentionally,

86
00:03:21,770 --> 00:03:24,500
它们也不会无意中干扰，
even if they have bugs and that's

87
00:03:24,500 --> 00:03:26,820
这就是所谓的隔离任务。
a task is called isolation.

88
00:03:27,120 --> 00:03:28,480
不同的活动
the idea that,

89
00:03:28,970 --> 00:03:32,270
不应该
a different activities should not be allowed

90
00:03:32,270 --> 00:03:33,620
互相干涉。另一方面，
to interfere. On the other hand,

91
00:03:33,620 --> 00:03:36,140
有时不同的活动
there are times when different activities would

92
00:03:36,140 --> 00:03:37,070
可能需要互相干扰、
like to interfere,

93
00:03:37,070 --> 00:03:38,870
交互或协作，
would like to interact or cooperate,

94
00:03:38,870 --> 00:03:40,550
例如，如果我
so for example if I create a

95
00:03:40,550 --> 00:03:42,230
使用编辑器创建了一个文件，
file with a text editor,

96
00:03:42,230 --> 00:03:43,790
我希望编译器可以读取该文件，
and I'd like my compiler to read

97
00:03:43,790 --> 00:03:45,830
我们肯定希望
the file and we definitely want to

98
00:03:45,830 --> 00:03:47,740
允许这种共享。
allow that kind of sharing.

99
00:03:47,860 --> 00:03:50,380
所以我们想允许分享，
Um, so we wanna allow sharing [minutes],

100
00:03:50,380 --> 00:03:55,120
像用户想的那样。
um，sort of what the user has in mind.

101
00:03:55,670 --> 00:03:57,230
但是在很多情况下，
But in many circumstances,

102
00:03:57,230 --> 00:03:59,360
用户不想分享，
user doesn't want sharing maybe

103
00:03:59,360 --> 00:04:00,800
可能你登录了像 Athena 这样的
you're logged into a time sharing

104
00:04:00,800 --> 00:04:02,300
分时处理服务器，
machine like Athena,

105
00:04:02,300 --> 00:04:03,500
你不想别人看到
and you don't want other people to

106
00:04:03,500 --> 00:04:04,760
你的文件，
read your files,

107
00:04:04,760 --> 00:04:06,380
所以需要的时候，我们分享，
um, so we also need as well sharing

108
00:04:06,380 --> 00:04:07,820
而不需要的时候，
we want, to not share when we

109
00:04:07,820 --> 00:04:09,640
我们不分享。
don't want to um.

110
00:04:09,760 --> 00:04:11,740
我们可以称其为安全系统或
Which we could call security or a

111
00:04:11,740 --> 00:04:15,400
权限系统，即访问控制系统。
permission system an access control system.

112
00:04:16,650 --> 00:04:18,360
人们看重操作系统的
Another thing that people value in operating

113
00:04:18,360 --> 00:04:20,040
另一个原因是，
systems is if you spend a lot

114
00:04:20,040 --> 00:04:21,180
如果你为一台计算机的硬件上花了很多钱，
of money on the hardware on a

115
00:04:21,180 --> 00:04:23,190
你希望应用程序
computer you'd like your application to be

116
00:04:23,190 --> 00:04:24,750
能够获得硬件
able to get a sort of full

117
00:04:24,750 --> 00:04:27,600
能够提供的全部性能。
performance that a hardware ought to be

118
00:04:27,600 --> 00:04:30,440
而且，
able to provide. And,

119
00:04:30,650 --> 00:04:33,260
很多都是应用编程，
a lot of that is just application programming,

120
00:04:33,260 --> 00:04:34,700
但是，
um, but,

121
00:04:34,700 --> 00:04:35,570
不可避免的，
um inevitably,

122
00:04:35,570 --> 00:04:37,760
不幸的是，其中一些问题是
unfortunately, some of it is the operating system

123
00:04:37,760 --> 00:04:41,240
操作系统必须确保它提供的任何服务
has to make sure that whatever services

124
00:04:41,240 --> 00:04:43,790
都不会阻碍
it provides don't get in the way

125
00:04:43,790 --> 00:04:46,250
应用程序获得高性能，
of applications getting high performance,

126
00:04:46,250 --> 00:04:47,510
所以你希望至少
so you want to at least not

127
00:04:47,510 --> 00:04:49,430
不要阻碍，
get in the way and maybe even

128
00:04:49,430 --> 00:04:51,540
甚至可能帮助应用程序
help applications achieve

129
00:04:51,650 --> 00:04:52,860
获得良好的性能。
good performance.

130
00:04:54,150 --> 00:04:58,740
嗯，最终。
Um, finally.

131
00:04:58,740 --> 00:04:58,880
TODO:

132
00:04:58,880 --> 00:05:01,460
由于大多数操作系统必须支持
With most operating systems have to support

133
00:05:01,460 --> 00:05:03,170
广泛的不同应用程序，
a wide range of different applications,

134
00:05:03,170 --> 00:05:05,990
可能是笔记本电脑运行编辑器，
maybe it's a laptop running a text editor,

135
00:05:05,990 --> 00:05:07,610
可能是运行游戏，
maybe it's running games,

136
00:05:07,610 --> 00:05:10,400
可能是您的操作系统需要支持
maybe your operating system needs to support

137
00:05:10,400 --> 00:05:12,860
数据库服务器或云计算，
database servers or cloud computation,

138
00:05:12,860 --> 00:05:15,950
通常因为操作系统的设计和构建
and usually because operating systems are quite

139
00:05:15,950 --> 00:05:19,280
成本很高，
expensive to design and build, people use

140
00:05:19,280 --> 00:05:21,110
所以人们使用相同的操作系统来执行许多不同的任务，
the same operating systems for many different

141
00:05:21,110 --> 00:05:22,250
例如 Linux，
tasks like Linux,

142
00:05:22,250 --> 00:05:23,720
在我提到的所有情况下，我相信
for example which I'm sure many of

143
00:05:23,720 --> 00:05:25,340
你们中的许多人都在
you are running a is used in

144
00:05:25,340 --> 00:05:27,170
运行相同的操作系统，
all of the situations I mentioned so

145
00:05:27,170 --> 00:05:28,520
因此相同的操作系统
the same operating system really has to

146
00:05:28,520 --> 00:05:31,380
必须能够支持一系列，
be able to support a range of,

147
00:05:31,430 --> 00:05:34,140
通常是非常不同的用途。
um, often quite different uses.

148
00:05:36,830 --> 00:05:38,180
所以我们希望能够
So we're hoping to be able

149
00:05:38,180 --> 00:05:40,430
同时支持
to support sort of all these

150
00:05:40,430 --> 00:05:42,740
所有这些不同的目标。
different goals simultaneously.

151
00:05:44,000 --> 00:05:45,170
在课程中，我们将听到
And we'll hear more about all of

152
00:05:45,170 --> 00:05:46,880
更多关于这些的信息。
them during the course.

153
00:05:47,810 --> 00:05:48,260
好的，
All right,

154
00:05:48,260 --> 00:05:49,790
操作系统，
um, operating systems,

155
00:05:49,790 --> 00:05:51,920
几十年来人们总结出
so people worked out a

156
00:05:51,920 --> 00:05:56,000
一套设计思想，
set of design ideas over the decades

157
00:05:56,000 --> 00:05:57,860
它们以一种很好的方式
have worked pretty well sort of ways

158
00:05:57,860 --> 00:05:59,240
组织事情。
of organizing things.

159
00:05:59,310 --> 00:06:01,320
我来给你们展示一下
I'm going to lay out for you,

160
00:06:01,320 --> 00:06:03,460
这种经典设计。
this sort of classic.

161
00:06:05,890 --> 00:06:10,000
这是这门课的的
A organization sort of standard deal for, um,

162
00:06:10,600 --> 00:06:12,560
标准组织方式，
this course and,

163
00:06:13,380 --> 00:06:15,960
其实在很多操作系统上
um, is actually quite common around

164
00:06:15,960 --> 00:06:17,100
都是很常见的。
for many operating systems.

165
00:06:17,100 --> 00:06:20,980
这是一种操作系统内部组织，
So this is sort of OS internal organization, or，

166
00:06:21,830 --> 00:06:24,380
或者，在我看来，
The way I think about it

167
00:06:24,380 --> 00:06:27,920
用这个方形
is in terms of a box

168
00:06:27,920 --> 00:06:29,810
表示计算机，
for the computer,

169
00:06:29,810 --> 00:06:31,600
计算机
the computer sort of

170
00:06:32,260 --> 00:06:33,850
附带了一堆硬件，
comes with a bunch of hardware resources,

171
00:06:33,850 --> 00:06:34,810
我把它们放在下面，
which I'll put at the bottom,

172
00:06:34,810 --> 00:06:38,440
有 CPU 、内存、存储的磁盘，
maybe their CPU and ram, disk for

173
00:06:38,440 --> 00:06:42,070
网络接口，
storage and maybe a network interface,

174
00:06:42,070 --> 00:06:43,240
这些硬件，
this sort of hardware,

175
00:06:43,240 --> 00:06:45,700
是最低的一层。
that's the lowest layer.

176
00:06:46,180 --> 00:06:47,830
在顶部，你想要
So at the top you want to

177
00:06:47,830 --> 00:06:49,570
运行各种应用程序，
run various applications,

178
00:06:49,570 --> 00:06:51,640
也许是一个文本编辑器，
maybe a text editor I have use

179
00:06:51,640 --> 00:06:53,590
我使用 VI ，
VI as a text editor,

180
00:06:53,590 --> 00:06:56,770
如果你要运行 C 编译器 CC，
if you're going to run a C compiler CC,

181
00:06:56,770 --> 00:06:58,270
如果你要运行很多其他的东西，
you know if you run lots of

182
00:06:58,270 --> 00:06:59,680
我们今天会讲很多
other things we're gonna talk a lot

183
00:06:59,680 --> 00:07:02,040
关于 Shell 的东西，
today about the Shell which is the,

184
00:07:02,030 --> 00:07:04,410
它是命令行界面，
um, command line interface,

185
00:07:04,410 --> 00:07:05,670
所以我们有所有这些不同的程序
so we have all these different programs

186
00:07:05,670 --> 00:07:07,000
在运行。
that are running.

187
00:07:07,260 --> 00:07:09,570
这里是应用程序运行的地方，
Um, and this is the sort of world

188
00:07:09,570 --> 00:07:11,820
通常被称为
in which a applications run is usually

189
00:07:11,820 --> 00:07:13,420
用户空间。
called user space.

190
00:07:14,260 --> 00:07:16,330
与此截然不同的是，
Um, and as distinct from that there's

191
00:07:16,330 --> 00:07:18,540
这里有一个程序，
a single program,

192
00:07:19,440 --> 00:07:20,910
一个特殊的程序，
a special program,

193
00:07:20,910 --> 00:07:23,460
它一直在运行，叫做内核，
that's always running called the kernel and

194
00:07:23,460 --> 00:07:25,440
内核是计算机资源的
the kernel is sort of the guardian

195
00:07:25,440 --> 00:07:27,270
守护者，
of the resources of the computer,

196
00:07:27,270 --> 00:07:30,270
它在你第一次开机时启动，
it's what first boots up you turn on the computer,

197
00:07:30,270 --> 00:07:32,730
只有一个，管理数据，
um, there's just one of it maintains data,

198
00:07:32,730 --> 00:07:36,280
帮助管理这些进程和
um. To help manage each of these processes

199
00:07:36,280 --> 00:07:37,690
内核也有大量的数据结构
and the kernel also means lots of

200
00:07:37,690 --> 00:07:41,660
data structures to help interface and,
来帮助接口和

201
00:07:42,120 --> 00:07:44,520
um, all the different kinds of hardware.
所有不同种类的硬件。

202
00:07:45,020 --> 00:07:49,550
这些用户程序需要使用服务，
Um, these user programs need to use,

203
00:07:49,550 --> 00:07:50,990
内核也内置了
the kernel also has built in

204
00:07:50,990 --> 00:07:53,240
很多服务。
a bunch of services.

205
00:07:53,550 --> 00:07:54,090
嗯，
Um，

206
00:07:54,090 --> 00:07:57,480
举个例子，通常有一个文件系统。
for example a there's typically a file system

207
00:07:57,980 --> 00:08:00,890
在内核内实现，它实现了
implementation inside the kernel that implements things

208
00:08:00,890 --> 00:08:03,980
文件名、文件内容和
like file names and file contents and

209
00:08:03,980 --> 00:08:07,190
目录，并且了解如何
directories and understands how to store the

210
00:08:07,190 --> 00:08:07,910
将文件存储在磁盘中，
files in the disk,

211
00:08:07,910 --> 00:08:09,410
因此你的程序
so your programs are going to talk

212
00:08:09,410 --> 00:08:11,420
访问内核中的文件，
to the files inside the kernel and

213
00:08:11,420 --> 00:08:13,440
而文件系统
file system implementations is going to

214
00:08:13,540 --> 00:08:14,760
访问磁盘。
talk to the disk.

215
00:08:15,410 --> 00:08:16,660
在这门课上，
In this course,

216
00:08:17,460 --> 00:08:19,800
我们主要关注的是
Um, where we mostly focus on is all

217
00:08:19,800 --> 00:08:21,330
内核内部发生的所有事情，
the things that has to happen inside

218
00:08:21,330 --> 00:08:23,880
以及用户程序和内核
the kernel and on the interfaces

219
00:08:23,880 --> 00:08:26,060
之间的接口。
between user programs and the kernel.

220
00:08:27,490 --> 00:08:30,370
还有内核里面的
As well as the structure of the software,

221
00:08:30,370 --> 00:08:32,110
软件结构。
um, inside the kernel.

222
00:08:32,110 --> 00:08:33,340
所以，
So,

223
00:08:33,430 --> 00:08:36,040
我们非常关心内核中的
we care a lot about these services

224
00:08:36,040 --> 00:08:38,560
这些服务。
inside the kernel.

225
00:08:38,610 --> 00:08:40,380
其中之一就是我提到的文件系统，
One of them is a file system I mentioned,

226
00:08:40,380 --> 00:08:42,000
还有
there's also a

227
00:08:42,570 --> 00:08:44,400
对进程的管理，
management of processes,

228
00:08:44,400 --> 00:08:46,620
每个正在运行的程序都称为进程，
each of these running programs is called

229
00:08:46,620 --> 00:08:48,300
它有
the process and it has things like

230
00:08:48,300 --> 00:08:49,230
自己的内存，
its own memory,

231
00:08:49,230 --> 00:08:54,420
还有共享的 CPU 时间。
for example as well as a share of the CPU time. So,

232
00:08:54,760 --> 00:08:58,140
因此，内核将进程作为内核服务
a kernel manages processes

233
00:08:58,540 --> 00:09:00,250
进行管理。
as a kernel service.

234
00:09:01,300 --> 00:09:02,080
嗯，
Um,

235
00:09:02,080 --> 00:09:05,950
内核负责内存的分配，
kernel manages the allocation of the memory,

236
00:09:05,950 --> 00:09:07,390
不同的进程需要
the different processes need different

237
00:09:07,390 --> 00:09:08,080
不同的内存量。
amounts of memory.

238
00:09:08,080 --> 00:09:09,000
内核
The kernel

239
00:09:10,970 --> 00:09:13,520
复用和划分内存，
multiplexes and divides up the memory

240
00:09:13,520 --> 00:09:14,940
在所有不同的进程之间
allocates the memory,

241
00:09:15,840 --> 00:09:18,200
分配内存。
um, among all the different processes.

242
00:09:22,240 --> 00:09:26,080
正如我提到的内核对文件系统的影响，
Um, the kernel as I mentioned a influence

243
00:09:26,080 --> 00:09:27,580
文件系统实际上
the file system, file system really comes

244
00:09:27,580 --> 00:09:30,190
分为三个逻辑部分或
into a three logical or a bunch

245
00:09:30,190 --> 00:09:31,030
一堆逻辑部分，
of logical parts,

246
00:09:31,030 --> 00:09:32,410
但现在我们可以从
but for now we can think of

247
00:09:32,410 --> 00:09:34,810
管理文件内容的角度来考虑它，
it in terms of managing file content,

248
00:09:34,810 --> 00:09:36,280
that's inside files,
也就是在文件内部，

249
00:09:36,280 --> 00:09:38,360
找出在磁盘上的位置。
figuring out where on disk.

250
00:09:39,080 --> 00:09:39,650
每个文件的内容
Each file's content

251
00:09:39,650 --> 00:09:41,750
都是活的，文件系统
ought to live, file system also somewhat

252
00:09:41,750 --> 00:09:44,150
还在某种程度上分开管理一个命名空间，
separately manages a name space that

253
00:09:44,150 --> 00:09:45,650
每个文件都有一个名称，
each file has a name and

254
00:09:45,650 --> 00:09:47,450
有一个层级目录，
there's a hierarchy of directories,

255
00:09:47,450 --> 00:09:49,940
每个目录中都有一堆文件，
every directory has a bunch of

256
00:09:49,940 --> 00:09:51,050
所有这些文件都是
files in it all that's managed

257
00:09:51,050 --> 00:09:53,640
由文件系统管理的。
by the file system.

258
00:09:54,030 --> 00:09:57,300
通常会有某种安全策略，
Um, there's typically some sort of security arrangement,

259
00:09:57,300 --> 00:09:59,440
也可以称为访问控制。
maybe we'll call it access control.

260
00:10:01,750 --> 00:10:03,910
内核决定，
Which the kernel decides that when a

261
00:10:03,910 --> 00:10:06,580
当给定进程想要读取，使用资源时，
given process wants to read, use

262
00:10:06,580 --> 00:10:08,530
可能从读取磁盘，
some resource, maybe read something from the disk,

263
00:10:08,530 --> 00:10:09,430
使用内存，
use some memory,

264
00:10:09,430 --> 00:10:11,200
内核内部的访问控制机制
the access control machinery inside the

265
00:10:11,200 --> 00:10:12,490
可以决定它
kernel is what gets to decide

266
00:10:12,490 --> 00:10:13,570
是允许
yes it's allowed is that

267
00:10:13,570 --> 00:10:14,950
或不允许，
not allowed, that can get pretty

268
00:10:14,950 --> 00:10:16,570
如果涉及到类似 Athena 系统这样的分时系统，
complicated if we're talking about time

269
00:10:16,570 --> 00:10:18,910
可能会变得非常复杂，
sharing systems like Athena systems where

270
00:10:18,910 --> 00:10:20,290
你知道，这些进程中的
there's you know each of these

271
00:10:20,290 --> 00:10:21,730
每个进程都可能
processes may be run by a

272
00:10:21,730 --> 00:10:23,890
由不同的用户运行，
different user and have different access

273
00:10:23,890 --> 00:10:25,690
并对其允许访问的内容
control rules apply to what it's

274
00:10:25,690 --> 00:10:27,180
使用不同的访问控制规则。
allowed to get at.

275
00:10:28,830 --> 00:10:31,710
在一个成熟的操作系统中，
And in a real full-blown operating system

276
00:10:31,710 --> 00:10:32,640
有很多很多
turns out to be many,

277
00:10:32,640 --> 00:10:34,050
其他的服务，
many other services,

278
00:10:34,050 --> 00:10:35,730
你知道，不同的进程
you know there's typically some way for

279
00:10:35,730 --> 00:10:37,650
通常有某种方式相互通信，
different processes to talk to each other

280
00:10:37,650 --> 00:10:40,200
这称为进程间通信，
called inter process communication,

281
00:10:40,200 --> 00:10:42,210
通常有一大堆
there's typically a whole bunch of software

282
00:10:42,210 --> 00:10:44,100
与网络相关的软件，
associated with the network things like the

283
00:10:44,100 --> 00:10:48,120
比如用于网络通信的 TCP/IP 协议。
TCP/IP protocols for talking the network.

284
00:10:48,120 --> 00:10:52,480
通常也会支持声卡，
Um, There's typically support for sound cards there

285
00:10:52,480 --> 00:10:54,400
可能会有数百个不同磁盘和
may be drivers for hundreds of different

286
00:10:54,400 --> 00:10:56,470
数百个不同网卡的驱动程序，
disk and hundreds of different network cards,

287
00:10:56,470 --> 00:10:58,690
所以在一个成熟的操作系统中，
so， in a full-blown operating system is

288
00:10:58,690 --> 00:11:00,310
这里有大量的东西，
a huge amount of stuff here and

289
00:11:00,310 --> 00:11:01,900
这可能会在内核中
this may run to millions of lines

290
00:11:01,900 --> 00:11:04,120
运行数百万行代码。
of code inside the kernel.

291
00:11:05,300 --> 00:11:07,490
这是对内核内部内容的
So, that's sort of a quick overview

292
00:11:07,490 --> 00:11:09,560
概述，
of whats inside the kernel,

293
00:11:09,560 --> 00:11:12,320
我们还对
we're also interested in how applications

294
00:11:12,320 --> 00:11:13,820
应用程序与内核交互
interact with the kernel and what

295
00:11:13,820 --> 00:11:16,320
以及接口定义感兴趣。
that interface looks like.

296
00:11:19,060 --> 00:11:20,520
这个，
The,

297
00:11:22,160 --> 00:11:24,140
一般，
a usual,

298
00:11:24,140 --> 00:11:27,860
这就是内核的 API 。
um, so this is the API for the kernel.

299
00:11:30,610 --> 00:11:32,500
应用程序是如何进入内核，
How applications get at the kernel,

300
00:11:32,500 --> 00:11:34,570
通常是通过 系统调用 来完成的，
a typically that's done with something called

301
00:11:34,570 --> 00:11:36,520
这些看起来
system calls and these are things that

302
00:11:36,520 --> 00:11:39,240
像程序定义的函数调用，
look like function calls that um

303
00:11:39,480 --> 00:11:42,300
但实际上是跳入内核，
programs can make, but actually jump into

304
00:11:42,300 --> 00:11:45,720
在内核中执行
the kernel and execute a system call

305
00:11:45,720 --> 00:11:47,430
系统调用实现，
implementation in the kernel,

306
00:11:47,430 --> 00:11:49,050
在这节课的后半部分，
I'll talk a bunch about that

307
00:11:49,050 --> 00:11:49,980
谈到这些。
in the latter part of this

308
00:11:49,980 --> 00:11:51,900
现在，我只想
lecture. For now just to give

309
00:11:51,900 --> 00:11:53,100
让你初步了解一下，
you a flavor here,

310
00:11:53,100 --> 00:11:54,960
应用程序代码中
what a couple of different system calls

311
00:11:54,960 --> 00:11:56,760
几个不同的系统调用
might look like in the source code

312
00:11:56,760 --> 00:11:58,180
是什么样子。
of an application.

313
00:12:00,310 --> 00:12:02,140
一种可能是，
One might be that if you want

314
00:12:02,140 --> 00:12:04,180
如果一个应用程序想要打开文件，
an application wants to open a file,

315
00:12:04,180 --> 00:12:07,000
它会调用 open 系统调用。
and it calls the open system call.

316
00:12:07,420 --> 00:12:09,400
把文件名传给
And tells the open system called the

317
00:12:09,400 --> 00:12:10,720
open 系统调用，
name of the file,

318
00:12:10,720 --> 00:12:12,280
可能想要打开
so maybe it wants to open a

319
00:12:12,280 --> 00:12:14,830
一个名为 out 的文件并写入，
file for writing called "out" and the

320
00:12:14,830 --> 00:12:17,050
本例中，
next argument here saying 1

321
00:12:17,050 --> 00:12:17,920
下一个参数是 1 。
in this case. I want to

322
00:12:17,920 --> 00:12:19,000
我想写那个文件，
write that file,

323
00:12:19,000 --> 00:12:21,820
所以这个看起来像函数调用。
and so this thing that looks like a function call.

324
00:12:22,670 --> 00:12:24,620
open 系统调用，
It opens the system calls actually special

325
00:12:24,620 --> 00:12:26,570
实际上是跳入内核的特殊代码，
code that jumps into the kernel and

326
00:12:26,570 --> 00:12:29,180
内核获得这些参数，
the kernel can retrieve these arguments executes

327
00:12:29,180 --> 00:12:30,680
执行一些实现 open 的内核代码，
some kernel code that implements open,

328
00:12:30,680 --> 00:12:32,150
可能会访问磁盘，
maybe talks to the disk,

329
00:12:32,150 --> 00:12:33,860
然后返回一个值，
and then returns a value and that's

330
00:12:33,860 --> 00:12:35,620
这就是文件描述符，
this file descriptor,

331
00:12:36,240 --> 00:12:38,610
fd 表示文件描述符。
as fd stands for file descriptor.

332
00:12:38,610 --> 00:12:40,200
程序可以
Um, which is the program can

333
00:12:40,200 --> 00:12:42,150
使用文件描述符
then use as a handle to

334
00:12:42,150 --> 00:12:44,540
来访问这个打开的文件。
refer to this open file.

335
00:12:44,760 --> 00:12:47,160
如果你想写一个文件，
Um, if you want to write to a file,

336
00:12:47,160 --> 00:12:49,340
使用的
the system call did,

337
00:12:49,400 --> 00:12:51,200
系统调用是 write ，
to do that is called write,

338
00:12:51,200 --> 00:12:52,190
你必须向它传递一个文件描述符，
you have to pass it one

339
00:12:52,190 --> 00:12:53,720
这个描述符与 open
of these file descriptors the same as

340
00:12:53,720 --> 00:12:55,420
返回的文件描述符相同。
was returned by open.

341
00:12:55,700 --> 00:12:58,460
这些是系统调用中
Um, these are arguments that are passed in

342
00:12:58,460 --> 00:12:59,600
传递的参数。
the system call.

343
00:12:59,770 --> 00:13:01,960
从程序到内核，
From the program into the kernel,

344
00:13:01,960 --> 00:13:03,740
你给它一个指针，
and you give it a pointer,

345
00:13:03,960 --> 00:13:06,300
指向一个字符缓冲区，
to a buffer of characters so an

346
00:13:06,300 --> 00:13:07,200
在 C 语言中，
easy way to do that in the

347
00:13:07,200 --> 00:13:08,310
一个简单的方法是，
C programming language,

348
00:13:08,310 --> 00:13:10,350
这个例子
which these examples are written by as

349
00:13:10,350 --> 00:13:12,080
使用双引号，
double quotes then,

350
00:13:12,340 --> 00:13:13,480
然后是字符串，
um, the string,

351
00:13:13,480 --> 00:13:15,670
字符串中的 '\n'
the bytes of the string '\n'

352
00:13:15,670 --> 00:13:17,830
表示换行，
is a new line and the third

353
00:13:17,830 --> 00:13:19,940
第三个参数是字符数。
argument is the count of characters.

354
00:13:20,160 --> 00:13:23,490
如果你想写入，这里是重点，
Um, if you want to write so this really gets point,

355
00:13:23,490 --> 00:13:25,620
把内存里的这个地址传过去。
pass this address in memory.

356
00:13:25,860 --> 00:13:26,850
你在告诉内核，
So you're telling the kernel, look,

357
00:13:26,850 --> 00:13:28,650
请把这个地址的 6 个字节
please write 6 bytes from this

358
00:13:28,650 --> 00:13:30,750
写到这个文件描述符
address to the file that this

359
00:13:30,750 --> 00:13:32,840
关联的文件中。
file descriptor refers to.

360
00:13:33,750 --> 00:13:36,270
一个更有意思的系统调用是
A much more exciting system call

361
00:13:36,270 --> 00:13:38,220
fork 系统调用，
the encounter is the fork system

362
00:13:38,220 --> 00:13:40,590
fork 可以
call, fork is the system call

363
00:13:40,590 --> 00:13:42,560
创建一个新进程，
that creates a new process,

364
00:13:42,620 --> 00:13:46,620
返回创建一个
um, and returns actually creates a process that's

365
00:13:46,620 --> 00:13:49,860
与调用方相同的进程，
identical to the caller and fork returns

366
00:13:49,860 --> 00:13:53,040
fork 返回标识符，即进程标识符 pid ，
the identifier the process identifier pid,

367
00:13:53,040 --> 00:13:56,370
新进程比[那]
um, new process is more

368
00:13:56,370 --> 00:13:57,920
复杂得多。
complicated than [that].

369
00:13:58,040 --> 00:13:59,440
我们还会听到更多关于这方面的内容。
We'll hear more about this.

370
00:14:00,740 --> 00:14:01,250
同样，
So again,

371
00:14:01,250 --> 00:14:04,400
这些看起来像函数调用，
these are all look like function calls,

372
00:14:04,400 --> 00:14:05,870
但是系统调用很特殊，
but the system calls are special because

373
00:14:05,870 --> 00:14:07,240
因为它们跳入内核。
they jump into the kernel.

374
00:14:08,200 --> 00:14:09,790
这是初步了解，
Um, that's taste,

375
00:14:09,790 --> 00:14:10,960
稍后我们会看到更多。
we'll see more later.

376
00:14:15,800 --> 00:14:17,600
这是一个快速的概述。
That is a sort of quick overview,

377
00:14:17,600 --> 00:14:20,380
嗯。
Um, I wanna.

378
00:14:20,530 --> 00:14:23,350
再提一下为什么我发现
Just mention why I find a operating

379
00:14:23,350 --> 00:14:25,220
操作系统的学习，
the study of operating systems,

380
00:14:25,300 --> 00:14:30,460
既有挑战性，又十分有趣。
to be both a challenging and interesting.

381
00:14:32,710 --> 00:14:34,620
为什么它值得
Why you know why it's maybe worth

382
00:14:35,360 --> 00:14:39,240
得在这方面开一门课。
um, intellectually worth taking a course in this area.

383
00:14:39,370 --> 00:14:40,900
这很难的一个原因是环境是难以应对的，
So, one reason why it's hard is that

384
00:14:40,900 --> 00:14:44,980
内核的编程环境是难以应对的，
the environment is unforgiving, programming environment

385
00:14:44,980 --> 00:14:48,180
因为当你在编程时，
inside the kernels unforgiving, because you're,

386
00:14:50,570 --> 00:14:52,550
当你修改内核或
your when you're programming when you're modifying

387
00:14:52,550 --> 00:14:53,870
扩展内核
the kernel or extending the kernel of

388
00:14:53,870 --> 00:14:55,640
编写新的操作系统内核时，
writing a new operating system kernel,

389
00:14:55,640 --> 00:14:58,220
你提供的是其他人
you're providing the infrastructure that everybody

390
00:14:58,220 --> 00:15:00,080
认为已经存在的基础设施
else assumes is already present to

391
00:15:00,080 --> 00:15:01,460
来运行他们的程序。
run their programs.

392
00:15:01,640 --> 00:15:03,200
每个人在编写普通应用程序时
And then everybody else gets an operating

393
00:15:03,200 --> 00:15:05,270
在他们的程序下
system under their program when they write

394
00:15:05,270 --> 00:15:06,500
都有一个操作系统，
ordinary application programs,

395
00:15:06,500 --> 00:15:08,990
但当我们构建操作系统时，
but when we build operating systems

396
00:15:08,990 --> 00:15:10,430
操作系统下
what we get is the hardware

397
00:15:10,430 --> 00:15:13,820
直接是硬件，
underneath our operating system which turns

398
00:15:13,820 --> 00:15:15,170
结果是更难处理。
out to be more difficult to

399
00:15:15,170 --> 00:15:16,310
在这个课程当中，
deal with. In this course,

400
00:15:16,310 --> 00:15:17,900
我们
we, um,

401
00:15:18,340 --> 00:15:20,890
我们用到一个叫 QEMU 的硬件模拟器，
we get to use a hardware simulator called QEMU,

402
00:15:20,890 --> 00:15:21,820
你，
um, you,

403
00:15:21,820 --> 00:15:25,970
它模拟一个 CPU 和一台计算机，
um. That simulates a CPU and a computer

404
00:15:25,970 --> 00:15:27,200
这样做会好一点，
and that makes a little bit better,

405
00:15:27,200 --> 00:15:29,690
但它仍然是困难的
but it's still a kind of a difficult

406
00:15:29,690 --> 00:15:31,260
环境编程。
um, environment programming.

407
00:15:32,360 --> 00:15:33,470
困难又有趣的
Another reason why it's hard and

408
00:15:33,470 --> 00:15:35,720
另一个原因是，
interesting is because if you're designing

409
00:15:35,720 --> 00:15:36,620
如果你在设计操作系统，
operating system,

410
00:15:36,620 --> 00:15:39,860
就必须满足一系列矛盾。
you have to satisfy a bunch of tensions.

411
00:15:39,980 --> 00:15:41,900
这需要真正的设计思想，
Um that require real design thought,

412
00:15:41,900 --> 00:15:44,030
其中之一就是
so one is that you'd like your

413
00:15:44,030 --> 00:15:46,480
你希望你的操作系统要有效率。
operating system to be both efficient.

414
00:15:46,720 --> 00:15:49,660
这通常意味着它在
Um, which often means that it operates at

415
00:15:49,660 --> 00:15:51,640
接近硬件的低层上运行，
a low level close to the hardware,

416
00:15:51,640 --> 00:15:53,290
但是为了便于使用，
but for ease of use,

417
00:15:53,290 --> 00:15:55,030
而且因为现实生活中的人
and because real live people have to

418
00:15:55,030 --> 00:15:57,820
必须使用你的操作系统编写程序，
write programs that use your operating system,

419
00:15:57,820 --> 00:16:00,220
所以我们希望它
we'd like it also to be a

420
00:16:00,220 --> 00:16:02,360
也是一个正确的高层次抽象。
right abstract high-level.

421
00:16:02,660 --> 00:16:04,460
一个可移植的接口，
A portable interfaces and it's a

422
00:16:04,460 --> 00:16:06,590
提供一个简单的抽象接口
neat trick to provide a abstract

423
00:16:06,590 --> 00:16:08,240
需要巧妙的技巧。
interfaces that are simple.

424
00:16:08,320 --> 00:16:11,320
便携的，但也很有效率的。
A portable but they are also efficient.

425
00:16:11,910 --> 00:16:14,820
另外一个矛盾就是
Um, another tension is that we'd like to

426
00:16:14,820 --> 00:16:18,240
我们要提供一个非常强大的操作系统服务，
provide a very powerful operating system services

427
00:16:18,240 --> 00:16:20,190
让操作系统可以承担
so that the operating system can shoulder

428
00:16:20,190 --> 00:16:21,580
很多负担。
a lot of the burden.

429
00:16:21,680 --> 00:16:26,000
运行程序像
Um, running programs like a powerful

430
00:16:26,070 --> 00:16:27,920
强大的操作系统服务。
operating system services.

431
00:16:28,630 --> 00:16:30,460
但是
Um, but,

432
00:16:30,860 --> 00:16:33,120
我们也希望有简单的接口。
we also want to have simple interfaces.

433
00:16:34,770 --> 00:16:36,960
我们不想让程序员
Um that we don't want a

434
00:16:36,960 --> 00:16:39,480
使用一个非常复杂、难以理解的接口，
tremendously complex hard to understand interfaces

435
00:16:39,480 --> 00:16:41,790
因为
for programmers to use because I'm

436
00:16:41,790 --> 00:16:42,600
我不会去理解它们，
not going to understand them,

437
00:16:42,600 --> 00:16:45,080
他们可能会发现很难使用。
and they may find it hard to use.

438
00:16:45,790 --> 00:16:48,400
所以这是一个非常简单的 API ，
Um, so this is really simple API,

439
00:16:48,400 --> 00:16:50,440
可以提供
and so this is possible to do

440
00:16:50,440 --> 00:16:53,440
一个简单的接口，
to provide a simple interfaces that have

441
00:16:53,440 --> 00:16:57,280
里面有一个强大的机器，
powerful a machinery inside them will always

442
00:16:57,280 --> 00:16:58,500
这一直在寻找。
be searching for.

443
00:16:58,700 --> 00:17:02,330
简单的接口提供了
Sort of simple interfaces provide

444
00:17:02,330 --> 00:17:04,760
强大的服务。
a powerful services.

445
00:17:04,760 --> 00:17:07,200
嗨， Robert ，有人提问。
Hey, Robbery, we've got a question in the chat.

446
00:17:07,280 --> 00:17:09,830
系统调用跳入内核
Um, what is unique/different about saying

447
00:17:09,830 --> 00:17:12,200
有什么独特/不同之处，
system calls jump into the kernel i.e

448
00:17:12,200 --> 00:17:13,970
与跳转到另一个函数的
as opposed to a standard function call

449
00:17:13,970 --> 00:17:15,540
标准函数调用相比。
that jumps to another function.

450
00:17:15,660 --> 00:17:18,550
好的，
Um, well,

451
00:17:18,550 --> 00:17:20,410
内核是
the kernel has, the kernels is,

452
00:17:20,410 --> 00:17:23,840
一段始终驻留的代码
um, a piece of code that's always resident

453
00:17:23,840 --> 00:17:26,540
并且具有特权，
that has special privileges that were that

454
00:17:26,540 --> 00:17:29,060
因为内核在机器启动时加载，
because it booted the machine booted the

455
00:17:29,060 --> 00:17:32,600
内核具有特权，
kernel a kernel has special privileges,

456
00:17:32,600 --> 00:17:34,700
它可以直接访问各种硬件，
it can get directly at all kinds

457
00:17:34,700 --> 00:17:37,100
比如普通用户程序
of hardware like the disk device that

458
00:17:37,100 --> 00:17:38,270
无法访问的磁盘设备，
ordinary user programs,

459
00:17:38,270 --> 00:17:39,800
所以如果你执行
can't get at, so if you make

460
00:17:39,800 --> 00:17:42,100
一个普通函数调用。
a an ordinary function call,

461
00:17:42,160 --> 00:17:46,440
你调用的函数没有
um, the function your calling doesn't get it

462
00:17:46,440 --> 00:17:48,600
获得任何关于硬件的特权，
doesn't get any special privileges with respect

463
00:17:48,600 --> 00:17:50,070
而如果你对内核
to the hardware whereas if you make

464
00:17:50,070 --> 00:17:53,040
执行系统调用，
a system call into the kernel, we'll

465
00:17:53,040 --> 00:17:54,000
后面我们会详细谈论这是如何工作的，
talk about how this works,

466
00:17:54,000 --> 00:17:57,000
但这就像当系统调用
but that ends up as when it

467
00:17:57,000 --> 00:17:58,590
跳到内核时，
jumps into when the system call jumps

468
00:17:58,590 --> 00:18:01,500
内核中的系统调用实现
into the kernel a system call implementation

469
00:18:01,500 --> 00:18:02,670
获得了所有这些特权，
in the kernel then gets all these

470
00:18:02,670 --> 00:18:06,360
这样它就可以修改
special privileges so that it can modify

471
00:18:06,360 --> 00:18:09,440
各种敏感的和受保护的
all kinds of sensitive and protected,

472
00:18:09,730 --> 00:18:12,340
硬件资源，
um, hardware resources like for example getting

473
00:18:12,340 --> 00:18:14,320
例如直接访问硬盘。
directly at the hard disk.

474
00:18:15,730 --> 00:18:19,020
我们稍后会看到更多关于这一切的细节。
Um, we'll see a lot more detail for all this shortly.

475
00:18:20,330 --> 00:18:22,310
好的，我们要说的最后一个矛盾是，
Okay, so a final tension that we

476
00:18:22,310 --> 00:18:24,290
所有的操作系统都需要满足你的要求，
want that all operating systems need

477
00:18:24,290 --> 00:18:25,910
你会给程序带来
to satisfy your gonna give programs

478
00:18:25,910 --> 00:18:27,560
尽可能多的灵活性，
as much flexibility as you can

479
00:18:27,560 --> 00:18:28,970
你不想限制它们，
you don't want to constrain them,

480
00:18:28,970 --> 00:18:30,680
所以你想要有很强的灵活性。
so you want to have very flexible.

481
00:18:30,740 --> 00:18:33,750
接口，
Um. Interfaces,

482
00:18:33,750 --> 00:18:35,400
但是确实需要在一定程度上约束程序，
but you do need to constrain program

483
00:18:35,400 --> 00:18:37,200
因为你绝对必须有
somewhat because you absolutely have to have

484
00:18:37,200 --> 00:18:38,740
一些安全概念。
some notion of security.

485
00:18:38,880 --> 00:18:44,770
我们喜欢程序，程序是很自由的，
We love for programs programs complete freedom

486
00:18:44,770 --> 00:18:45,910
但它不可能是完全的自由，
but it can't be complete can't be

487
00:18:45,910 --> 00:18:48,490
不可能真正的完全自由，
really complete because we don't want programs

488
00:18:48,490 --> 00:18:49,960
因为我们不想让程序直接访问硬件，
to get directly at the hardware or

489
00:18:49,960 --> 00:18:53,170
或者干扰其他程序，
to interfere with other programs or a

490
00:18:53,170 --> 00:18:54,310
或者某种程度上
sort of be able to interfere with

491
00:18:54,310 --> 00:18:57,140
干扰操作系统本身的操作。
the operation of the operating system itself.

492
00:18:57,360 --> 00:18:58,410
那么，
Um, so,

493
00:18:58,410 --> 00:19:00,820
这些就是你需要知道的。
these are all you know.

494
00:19:01,490 --> 00:19:02,810
做好这项工作是可能的，
It's possible to do a good job

495
00:19:02,810 --> 00:19:03,860
我们将对此进行大量讨论，
and we'll talk a lot about it

496
00:19:03,860 --> 00:19:05,120
但是在这两列中
but it's always a bit of a

497
00:19:05,120 --> 00:19:06,620
同时提供这两个属性
puzzle to provide sort of both of

498
00:19:06,620 --> 00:19:10,300
总是有点令人费解的。
these properties in both of these columns.

499
00:19:11,630 --> 00:19:13,730
另一个让操作系统设计
Another thing that makes OS design hard

500
00:19:13,730 --> 00:19:16,040
变得困难和有趣的事情是，
and interesting is that operating systems provide

501
00:19:16,040 --> 00:19:17,030
操作系统提供了很多功能和服务，
a lot of features and a lot

502
00:19:17,030 --> 00:19:18,710
但它们实际上倾向于交互，
of services but they actually tend to

503
00:19:18,710 --> 00:19:21,770
有时会以奇怪的方式进行交互，
interact and sometimes in odd ways that

504
00:19:21,770 --> 00:19:23,540
这需要很多思考，
require a lot of thought so even

505
00:19:23,540 --> 00:19:25,960
即使是我给出的简单示例。
the simple examples I gave.

506
00:19:26,640 --> 00:19:27,780
用 open 和 fork ，
Um, with open and fork,

507
00:19:27,780 --> 00:19:30,180
这两个交互，
those two interact actually if a program,

508
00:19:30,180 --> 00:19:32,930
实际上如果是一个程序使用 open 系统调用
um, allocates a file descriptor with the

509
00:19:32,930 --> 00:19:34,700
分配文件描述符，
open system call,

510
00:19:34,700 --> 00:19:36,680
然后分配相同的程序，
and then that same program,

511
00:19:36,780 --> 00:19:38,760
就是 fork 。
um, fork.

512
00:19:39,610 --> 00:19:41,470
fork 的语义是，
Um, and the semantics of fork just

513
00:19:41,470 --> 00:19:42,760
你创建了
turned out to be that you

514
00:19:42,760 --> 00:19:44,050
一个新进程，
create a new process that's a

515
00:19:44,050 --> 00:19:45,730
它是当前进程的副本，
copy of the current process,

516
00:19:45,730 --> 00:19:46,990
你打开了
this file descriptor,

517
00:19:46,990 --> 00:19:48,820
这个文件描述符
you opened.

518
00:19:49,640 --> 00:19:51,290
这是一个副本，
If that's truly to be a copy,

519
00:19:51,290 --> 00:19:53,660
这个文件描述符
this file descriptor still has to be

520
00:19:53,660 --> 00:19:56,920
仍然在孩子中存在并可用，
present and usable in the child and,

521
00:19:57,320 --> 00:19:58,370
所以必须仔细考虑，
and so that has to be thought

522
00:19:58,370 --> 00:19:59,660
这就是文件，
through that is the files,

523
00:19:59,660 --> 00:20:01,760
打开的文件描述符
the opened file descriptors interact with fork

524
00:20:01,760 --> 00:20:04,460
以这种方式与 fork 交互，
in this interesting way and somebody has

525
00:20:04,460 --> 00:20:06,380
必须找到一个能让子进程
to figure out a should the child

526
00:20:06,380 --> 00:20:07,900
读到的文件描述符。
be able to get at.

527
00:20:07,960 --> 00:20:10,270
在调用 fork 之前
The file descriptors created before fork

528
00:20:10,270 --> 00:20:11,560
创建的文件描述符，
is called and the answer has

529
00:20:11,560 --> 00:20:12,580
答案是肯定的，
to be yes,

530
00:20:12,580 --> 00:20:14,500
也就是我们要看的操作系统。
the operating systems we're going to look at.

531
00:20:14,620 --> 00:20:18,390
好的，
Um. All right, so other things

532
00:20:18,390 --> 00:20:19,320
其他有趣的事情
that are turned out to

533
00:20:19,320 --> 00:20:21,210
我已经提过了，
be interesting I already mentioned

534
00:20:21,210 --> 00:20:22,860
操作系统必须满足
that operating systems have to

535
00:20:22,860 --> 00:20:24,090
各种各样的用途，
cater to a wide variety

536
00:20:24,090 --> 00:20:26,280
就像数据库服务器
of uses the same OS

537
00:20:26,280 --> 00:20:28,620
和智能手机
used both for database servers

538
00:20:28,620 --> 00:20:29,820
使用相同的操作系统，
and smartphones,

539
00:20:29,820 --> 00:20:33,280
操作系统。
for example. And operating systems,

540
00:20:33,410 --> 00:20:36,350
随着时间的推移，
as time goes on the hardware

541
00:20:36,350 --> 00:20:37,940
你运行的硬件，
that you run, hardware

542
00:20:37,940 --> 00:20:38,360
你得到的硬件，
you get,

543
00:20:38,360 --> 00:20:40,400
典型的计算机会发生变化，
but typical computers changes,

544
00:20:40,400 --> 00:20:43,190
可能会得到超高速的固态硬盘存储，
maybe get superfast ssd storage instead of

545
00:20:43,190 --> 00:20:44,270
而不是机械硬盘。
mechanical hard drive.

546
00:20:44,270 --> 00:20:45,280
例如，
For example,

547
00:20:45,360 --> 00:20:47,610
大约 15 年前，
about fifteen years ago multi

548
00:20:47,610 --> 00:20:50,370
多核计算机
core computers went from being rare

549
00:20:50,370 --> 00:20:54,750
从稀有的发展到无处不在，
curiosities to being pervasive and and

550
00:20:54,750 --> 00:20:56,700
最近我们看到了数量级的提速和
recently we've seen order of magnitude

551
00:20:56,700 --> 00:20:59,190
网络运行的速度，
speedups and how fast networks operate

552
00:20:59,190 --> 00:21:01,340
所有这些都需要重新思考。
and so all these require rethinks.

553
00:21:01,440 --> 00:21:02,970
嗯，
Um,

554
00:21:02,970 --> 00:21:05,560
会定期介绍操作系统是怎么设计的。
periodically of how operating systems are designed.

555
00:21:06,510 --> 00:21:10,500
这些就是
Now so so those are those are

556
00:21:10,500 --> 00:21:12,090
为什么你可能会选择这门课程的原因，
sort of intellectually why you might take

557
00:21:12,090 --> 00:21:14,010
还有一些更实际的原因，
the course there's also some more practical

558
00:21:14,010 --> 00:21:16,320
你可能会很高兴
reasons why you might be glad to

559
00:21:16,320 --> 00:21:17,580
选修这门课程，
have taken this course,

560
00:21:17,580 --> 00:21:19,380
一个是如果你对
one is if you're interested in what

561
00:21:19,380 --> 00:21:20,730
计算机内部发生的事情感兴趣，
happens inside computers,

562
00:21:20,730 --> 00:21:22,410
想知道并
what goes on and saw under the

563
00:21:22,410 --> 00:21:24,390
探寻计算机内部的秘密，
hood a sort of in secret,

564
00:21:24,390 --> 00:21:25,710
当你打开你的计算机时，
when you turn on your computer,

565
00:21:25,710 --> 00:21:27,510
这是一个很好的课程，
um, this is a good course to take,

566
00:21:27,510 --> 00:21:29,430
类似地，如果你喜欢基础设施，
similarly if you like infrastructure that

567
00:21:29,430 --> 00:21:31,770
也就是如果你喜欢
is if if you enjoy building

568
00:21:31,770 --> 00:21:33,900
建立一种其他程序
a sort of services that other

569
00:21:33,900 --> 00:21:36,160
可以使用的服务。
programs can then use them.

570
00:21:36,510 --> 00:21:37,860
当然，这基本上都是
This is of course essentially all

571
00:21:37,860 --> 00:21:40,020
关于基础设施的，
about infrastructure because that's that's what

572
00:21:40,020 --> 00:21:41,340
因为这就是操作系统。
operating systems are.

573
00:21:42,350 --> 00:21:43,250
如果你曾经
If you ever need to

574
00:21:43,250 --> 00:21:44,000
花费大量时间
spend a lot of time

575
00:21:44,000 --> 00:21:46,160
来跟踪应用程序代码中的 bug 或
tracking down bugs in application

576
00:21:46,160 --> 00:21:47,870
跟踪安全问题，
code or tracking down security

577
00:21:47,870 --> 00:21:51,440
通常这涉及到
problems often that involves understanding

578
00:21:51,440 --> 00:21:52,490
了解操作系统内部
what was going on inside

579
00:21:52,490 --> 00:21:54,020
发生了什么，
the operating system because it's

580
00:21:54,020 --> 00:21:56,180
因为最终是操作系统
ultimately the operating system that

581
00:21:56,180 --> 00:21:57,710
实施了很多安全措施，
enforces a lot of security

582
00:21:57,710 --> 00:22:00,020
当出现问题时，
and when things go wrong,

583
00:22:00,020 --> 00:22:01,490
是操作系统必须收拾残局，
it's the operating system has to pick

584
00:22:01,490 --> 00:22:03,830
因此通常涉及到
up the pieces so that's often involved

585
00:22:03,830 --> 00:22:08,210
跟踪 bug ，最后是操作系统。
in tracking down bugs, and finally.

586
00:22:08,210 --> 00:22:09,440
有两个提问。
Two more questions from the chat,

587
00:22:09,440 --> 00:22:11,210
第一个问题是，
so the first is how important

588
00:22:11,210 --> 00:22:12,740
对于应用程序开发人员来说，
is it for application developers to

589
00:22:12,740 --> 00:22:15,050
真正深入了解开发应用程序的
truly deeply understand the operating systems

590
00:22:15,050 --> 00:22:17,180
操作系统有多重要，
of developing their applications for do

591
00:22:17,180 --> 00:22:19,420
他们是否需要成为专家。
they necessarily need to be experts.

592
00:22:19,810 --> 00:22:21,370
你不必是专家，
You don't have to be an expert,

593
00:22:21,370 --> 00:22:23,530
但是如果你花费大量时间
but if you spend a lot of

594
00:22:23,530 --> 00:22:26,650
开发、维护和调试应用程序，
time developing and maintaining and debugging applications,

595
00:22:26,650 --> 00:22:29,080
最终会对操作系统
you'll eventually end up knowing a lot

596
00:22:29,080 --> 00:22:30,160
有很多了解，
about the operating system,

597
00:22:30,160 --> 00:22:31,420
不管你
whether you,

598
00:22:31,520 --> 00:22:33,240
是不是有意或无意，
whether you meant to or not just,

599
00:22:34,140 --> 00:22:36,390
它就这样出现了，
it just comes up and you're often

600
00:22:36,390 --> 00:22:37,840
你经常被迫理解它。
forced to understand.

601
00:22:38,100 --> 00:22:41,290
第二个问题是，
Um. And the second question is do

602
00:22:41,290 --> 00:22:44,230
像 Python 这样的高级编程语言
high-level programming languages like python use

603
00:22:44,230 --> 00:22:46,030
是否直接使用系统调用，
system calls directly are there built

604
00:22:46,030 --> 00:22:48,340
为了方便，编写了内置的包装器。
in slash wrappers for convenience.

605
00:22:48,710 --> 00:22:50,750
很多高级语言
A lot of high-level languages are sort

606
00:22:50,750 --> 00:22:53,540
在某种程度上是从系统调用中转移出来的，
of at one of move from system calls

607
00:22:53,540 --> 00:22:54,500
这是正确的。
that's absolutely true.

608
00:22:54,500 --> 00:22:56,360
所以，
So, um,

609
00:22:56,600 --> 00:22:58,640
部分原因是
partially because a lot of

610
00:22:58,640 --> 00:23:01,760
许多语言想要提供可移植的，
languages want to provide portable a

611
00:23:01,760 --> 00:23:03,410
可以在
portable environment that works on many

612
00:23:03,410 --> 00:23:04,760
许多不同操作系统上运行，
different operating systems so they can't

613
00:23:04,760 --> 00:23:07,280
因此它们不一定要致力于
necessarily commit to the specific system

614
00:23:07,280 --> 00:23:09,580
任何一种操作系统的特定系统调用。
calls of any one operating system.

615
00:23:09,980 --> 00:23:12,410
所以答案是，
Um, so, the answer,

616
00:23:12,410 --> 00:23:13,490
我想问题是，
the question I think is if you

617
00:23:13,490 --> 00:23:16,460
如果你使用 python ，多少与系统有点隔离。
use python, you're somewhat insulated.

618
00:23:16,570 --> 00:23:18,790
从不是系统调用接口，
From not the system call interface,

619
00:23:18,790 --> 00:23:20,760
你知道 Python 内部当然会做，
you know internally of course python makes,

620
00:23:20,900 --> 00:23:23,060
必须让系统调用来完成它的工作，
has to make system calls get its work done,

621
00:23:23,060 --> 00:23:24,340
嗯，
um, and,

622
00:23:24,520 --> 00:23:26,380
当然，在 Python 和许多其他语言中，
certainly in python and many other languages,

623
00:23:26,380 --> 00:23:29,840
通常有一种方法
there is usually a way to get directly at

624
00:23:29,990 --> 00:23:32,330
可以直接进入系统调用，无论
the system calls whatever your operating system,

625
00:23:32,330 --> 00:23:34,060
你运行的是什么操作系统。
you're running on.

626
00:23:35,480 --> 00:23:37,280
各位同学，
And folks for questions, you can just

627
00:23:37,280 --> 00:23:38,540
你可以自己提问，
feel free to jump in yourself and

628
00:23:38,540 --> 00:23:39,650
不一定需要
ask questions you don't need to go

629
00:23:39,650 --> 00:23:40,880
通过聊天提出问题。
through the chat.

630
00:23:43,410 --> 00:23:45,260
好的，
Okay, Um,

631
00:23:46,020 --> 00:23:46,740
好的，
all right,

632
00:23:46,740 --> 00:23:51,700
抱歉。现在我要花几分钟
sorry. I'm going to spend a couple of

633
00:23:51,700 --> 00:23:56,230
讨论 6.S081 的
minutes now talking about class structure

634
00:23:56,230 --> 00:24:00,980
课程结构，
of 6.S081,

635
00:24:01,140 --> 00:24:05,430
然后再回到的技术内容部分。
before switching back to actual technical content.

636
00:24:05,430 --> 00:24:07,740
这有一个课程的网站，
So there is a website for the

637
00:24:07,740 --> 00:24:09,210
我现在不想写出来，
course which I don't want to write

638
00:24:09,210 --> 00:24:10,890
但是你可以
out just now but it's you

639
00:24:10,890 --> 00:24:11,940
在谷歌上搜索
can find it by looking for

640
00:24:11,940 --> 00:24:13,900
6.S081 找到它。
6.S081 on Google.

641
00:24:14,280 --> 00:24:16,350
而且这个网站，
And the website,

642
00:24:16,350 --> 00:24:18,520
有一个
um, has

643
00:24:19,890 --> 00:24:23,740
课程表，
a schedule,

644
00:24:23,980 --> 00:24:26,320
有课程表上的作业，
it has the assignments on the schedule

645
00:24:26,320 --> 00:24:28,560
还有有实验作业。
that has the lab assignments.

646
00:24:28,740 --> 00:24:30,300
它也有关于课程结构
Um, and it has the sort of

647
00:24:30,300 --> 00:24:32,370
的其他信息，
information about course structure like the

648
00:24:32,370 --> 00:24:33,900
比如它的评分标准。
grading policy on it.

649
00:24:34,240 --> 00:24:37,300
你会想要跟踪另一个
Um, the other big resource you're gonna

650
00:24:37,300 --> 00:24:39,260
重要资源是 piazza 。
wanna keep track of piazza.

651
00:24:39,960 --> 00:24:40,710
我猜，
Um I guess,

652
00:24:40,710 --> 00:24:42,090
每个人都是通过 piazza
everybody was here got here by way

653
00:24:42,090 --> 00:24:43,260
来到这里的，
piazza, um,

654
00:24:43,260 --> 00:24:45,960
但是还有，
but as well as um,

655
00:24:45,960 --> 00:24:48,150
所以我们定期用来做两件主要的事情，
so we used periodically for two main things,

656
00:24:48,150 --> 00:24:49,680
一是让人们能够
one is as a way of people

657
00:24:49,680 --> 00:24:51,270
就实验室作业
being able to ask questions about the

658
00:24:51,270 --> 00:24:53,200
提出问题，
lab assignments and,

659
00:24:53,420 --> 00:24:56,180
工作人员会试着回答这些问题，
a course staff will try to answer these questions,

660
00:24:56,180 --> 00:24:57,980
但你们也完全可以自由地
but you should feel absolutely free to

661
00:24:57,980 --> 00:25:00,740
回答彼此的问题。
answer each other's questions as well. And

662
00:25:00,740 --> 00:25:01,910
在 piazza 上发生的另一件事是，
the other big thing that happens on

663
00:25:01,910 --> 00:25:04,400
如果有公告，
piazza if there's announcements there's any announcements

664
00:25:04,400 --> 00:25:05,380
就会发布在上面。
about the course.

665
00:25:05,500 --> 00:25:07,720
我们会把公告放在 piazza 上，
Um, we'll put the announcement on piazza so

666
00:25:07,720 --> 00:25:09,100
所以你应该关注
you should keep an eye on piazza

667
00:25:09,100 --> 00:25:10,840
piazza 上的公告，
for announcements even if, um,

668
00:25:11,220 --> 00:25:12,760
即使你不用它来寻找实验帮助。
you're not using it for lab help.

669
00:25:13,580 --> 00:25:16,340
这个
Yeah. Um,

670
00:25:16,700 --> 00:25:17,000
这个
the, um,

671
00:25:17,000 --> 00:25:18,560
课程的一个很大的部分当然
one of the big parts of course

672
00:25:18,560 --> 00:25:20,150
就是这些讲座，
is that these lectures,

673
00:25:20,150 --> 00:25:23,080
嗯，
um,

674
00:25:24,150 --> 00:25:27,420
这个讲座会涉及到
lectures will cover basic ideas

675
00:25:27,420 --> 00:25:28,800
基本的理念和操作系统。
and operating systems.

676
00:25:28,860 --> 00:25:31,200
有些课程
Um, some of the lectures will

677
00:25:31,200 --> 00:25:33,480
会详细研究
be devoted to detailed a

678
00:25:33,480 --> 00:25:35,580
xv6 的代码，
study of the code in

679
00:25:35,580 --> 00:25:36,660
这是我们的
xv6 which is

680
00:25:36,660 --> 00:25:39,420
小型教学操作系统，
our small teaching operating system

681
00:25:39,420 --> 00:25:40,800
讨论它是如何工作的，
and so talk about how

682
00:25:40,800 --> 00:25:41,910
我们会在课堂上
it works we'll look at

683
00:25:41,910 --> 00:25:43,140
看代码，
the code and show the

684
00:25:43,140 --> 00:25:45,810
并演示代码的执行过程，
code executing during lectures,

685
00:25:45,810 --> 00:25:47,370
另外，在很多课程之前，
and in addition before many of

686
00:25:47,370 --> 00:25:49,200
我们会先做作业，
the lectures, we'll be assignments reading

687
00:25:49,200 --> 00:25:51,810
阅读书中的作业，
assignments from a book that sort

688
00:25:51,810 --> 00:25:54,600
这本书描述了 xv6 是如何运行的，
of describes how xv6 operates and

689
00:25:54,600 --> 00:25:56,220
以及为什么它是这样设计的。
why it's designed that way.

690
00:25:56,670 --> 00:25:57,990
所以你应该在上课前做阅读，
So you do the readings before the

691
00:25:57,990 --> 00:26:01,170
这样就能听懂
class so they understand the discussion

692
00:26:01,170 --> 00:26:02,400
课堂上的讨论，
in the class,

693
00:26:02,400 --> 00:26:04,080
一些课程专门讲授背景知识，
some of the lectures are devoted to

694
00:26:04,080 --> 00:26:06,540
帮助你做实验。
background to help you do the labs.

695
00:26:06,660 --> 00:26:09,180
像 C 语言是如何工作的，
Um, so like about C works of how

696
00:26:09,180 --> 00:26:11,940
RISC-V，也就是我们要使用的
the RISC-V, which is the microprocessor

697
00:26:11,940 --> 00:26:13,080
微处理器。
that we'll be using.

698
00:26:13,200 --> 00:26:16,620
你们会发现这对理解
Um that you'll find helpful in understanding

699
00:26:16,620 --> 00:26:18,210
如何做实验很有帮助，
how to do the labs and towards

700
00:26:18,210 --> 00:26:19,420
在课程接近尾声的时候，
the end of the course,

701
00:26:19,890 --> 00:26:22,710
我们会用一些课，
we'll spend some lectures discussing some

702
00:26:22,710 --> 00:26:25,080
讨论一些操作系统论文，
operating system papers,

703
00:26:25,080 --> 00:26:27,420
研究论文，和该领域的一些经典论文，
research papers and some classic papers in

704
00:26:27,420 --> 00:26:30,300
会要求你们在讲课前
the field which you will ask that

705
00:26:30,300 --> 00:26:31,470
阅读这些论文，
you read before the lecture and then

706
00:26:31,470 --> 00:26:33,630
然后我们会在课程中讨论这些论文。
we'll sort of talk about the papers

707
00:26:33,630 --> 00:26:36,090
所有的讲座，
during the lecture. For all the lectures

708
00:26:36,090 --> 00:26:37,290
几乎所有的讲座，
are almost all the lectures,

709
00:26:37,290 --> 00:26:39,150
我们要求你在
we ask that you submit a question

710
00:26:39,150 --> 00:26:40,320
讲座之前，
about the reading,

711
00:26:40,320 --> 00:26:44,190
为讲座提交
um for the lecture before the actual

712
00:26:44,190 --> 00:26:45,900
一个关于说读文章的问题。
time of the lecture which.

713
00:26:45,950 --> 00:26:47,270
你们中的许多人或所有人
Many or all of you did for

714
00:26:47,270 --> 00:26:49,220
都参加了这次讲座，谢谢你们，
this lecture for which thank you,

715
00:26:49,220 --> 00:26:52,580
我们会查看这些问题来帮助我们。
um, and we will read those questions to help us.

716
00:26:52,970 --> 00:26:54,800
指导我们讨论什么，
Guide us about what to talk about

717
00:26:54,800 --> 00:26:57,020
我们会尽力回答
and we'll try to answer as many

718
00:26:57,020 --> 00:26:58,040
尽可能多的问题，
of the questions as we can,

719
00:26:58,040 --> 00:26:59,840
尽管很少有时间，
although there's rarely time,

720
00:26:59,840 --> 00:27:02,460
不过，我们没有时间回答所有问题。
unfortunately for us to answer all of them.

721
00:27:02,800 --> 00:27:05,980
课程的下一个重要部分是实验。
Um, the next big part of the course of the labs.

722
00:27:06,400 --> 00:27:08,350
几乎每周都有
There's a programming lab do,

723
00:27:08,350 --> 00:27:12,490
一个编程实验，
um, almost every week and the point of

724
00:27:12,490 --> 00:27:13,510
这个实验的目的是
the labs is to help you get

725
00:27:13,510 --> 00:27:15,940
帮助你亲身体验，
hands on experience with,

726
00:27:16,110 --> 00:27:19,840
实现和使用操作系统。
implementing and using operating systems.

727
00:27:20,690 --> 00:27:24,170
下周到期的一个实验
A lab that's due next week is

728
00:27:24,170 --> 00:27:27,440
实际上是关于如何编写应用程序，
actually about using about writing applications that

729
00:27:27,440 --> 00:27:29,120
这些应用程序用到的系统调用
make the call the system calls will

730
00:27:29,120 --> 00:27:30,240
随后将会讨论。
be talking about.

731
00:27:31,520 --> 00:27:33,080
与此之后的
Whereas most of those labs after

732
00:27:33,080 --> 00:27:34,070
大多数实验不同，
that are involved,

733
00:27:34,070 --> 00:27:37,370
要么实现基本的操作系统功能，
you either implementing basic operating system

734
00:27:37,370 --> 00:27:38,860
要么
features or adding

735
00:27:39,020 --> 00:27:42,360
向 xv6 操作系统
a kernel extensions to the xv6

736
00:27:42,770 --> 00:27:44,780
添加内核扩展，
operating system,

737
00:27:44,780 --> 00:27:46,520
最后一个实验，
the very last lab and one in

738
00:27:46,520 --> 00:27:48,500
是实际添加网络堆栈和
which you actually add a network stack

739
00:27:48,500 --> 00:27:49,820
网络驱动程序的实验，
and a network driver so you'll be

740
00:27:49,820 --> 00:27:51,500
以便能够通过网络连接
able to connect in over the network

741
00:27:51,500 --> 00:27:53,540
到你运行的操作系统。
to the operating system that you run.

742
00:27:55,560 --> 00:27:56,310
你应该，
You should,

743
00:27:56,310 --> 00:27:57,990
如果你对实验有问题，
if you have problems with the lab's

744
00:27:57,990 --> 00:28:00,740
助教会在办公时间提供帮助。
they'll be office hours that,

745
00:28:00,830 --> 00:28:03,260
此外，
TA will hold. In addition

746
00:28:03,260 --> 00:28:06,230
你还可以把问题发布到 piazza 上，
you can post questions to piazza

747
00:28:06,230 --> 00:28:07,610
而且通常可以
and very often you'll be able

748
00:28:07,610 --> 00:28:09,890
比在办公时间更快地
to get useful answers from piazza

749
00:28:09,890 --> 00:28:11,980
得到有用的答案。
more quickly than from office hours.

750
00:28:13,060 --> 00:28:16,000
我们欢迎你讨论实验，
We welcome you discussing the labs

751
00:28:16,000 --> 00:28:17,230
谈论实验，
talking about the labs talking about

752
00:28:17,230 --> 00:28:20,410
讨论如何设计实验解决方案，
how to design the lab solutions

753
00:28:20,410 --> 00:28:21,610
但是我们要求不要
but we ask you please do

754
00:28:21,610 --> 00:28:23,600
看别人的解决方案。
not look at other people's solutions.

755
00:28:23,680 --> 00:28:25,810
重复一遍，你编写的所有代码
Relapse, please all the code you write should

756
00:28:25,810 --> 00:28:27,850
都应该是你自己的，并且你不应该
be your own and you shouldn't share

757
00:28:27,850 --> 00:28:30,620
共享代码或查看其他解决方案。
code or look at other solutions.

758
00:28:32,740 --> 00:28:36,970
评分。当然，
The grading. Of course,

759
00:28:36,970 --> 00:28:41,480
今年我们主要由实验决定，
um. We'll be mostly determined from the labs this year,

760
00:28:41,480 --> 00:28:44,120
所以 70% 的成绩将是，
so 70% of the grade will be,

761
00:28:44,120 --> 00:28:46,140
嗯，
um,

762
00:28:46,620 --> 00:28:49,620
根据你的实验结果，
Um, based on whether or not your lab,

763
00:28:49,620 --> 00:28:52,020
你提交的是否通过测试，我们进行评分，
you submit passes the tests and we for grading,

764
00:28:52,020 --> 00:28:54,210
我们运行的测试与提供给你的测试是相同的，
we run the same tests that we

765
00:28:54,210 --> 00:28:56,520
所以如果你的实验
supply you so if your lab passes

766
00:28:56,520 --> 00:28:57,810
通过了我们给你的所有测试，
all the tests that we give you

767
00:28:57,810 --> 00:28:58,920
你就可以得到实验的
the chance to show you that full

768
00:28:58,920 --> 00:29:00,260
全部分数。
credit for the lab.

769
00:29:00,500 --> 00:29:04,070
20% 的分数
A 20% of the grade is

770
00:29:04,070 --> 00:29:08,030
来自实验检查会议，
going to be from lab checkoff meetings

771
00:29:08,030 --> 00:29:09,500
你们每个人都将
for each of you will pick a

772
00:29:09,500 --> 00:29:11,660
随机选择几个实验，
couple of randomly selected labs and one

773
00:29:11,660 --> 00:29:13,280
其中一个小组将与你们交谈，
of the teams will talk to you

774
00:29:13,280 --> 00:29:14,990
询问你们关于实现的问题，
and ask you questions about your implementation

775
00:29:14,990 --> 00:29:17,180
以确保你们真的
just to make sure that um,

776
00:29:17,320 --> 00:29:19,620
理解发生了什么。
are you really understand what's going on.

777
00:29:20,180 --> 00:29:22,080
这是实验检查。
It's a lab check offs.

778
00:29:23,870 --> 00:29:26,600
还剩 10% 。
There's a 10% remaining.

779
00:29:28,040 --> 00:29:29,390
很多，有点像
A lot of, kind of

780
00:29:29,390 --> 00:29:31,790
是或不是
be like a yes or no

781
00:29:31,790 --> 00:29:33,290
一或零的事，
one or zero type of thing

782
00:29:33,290 --> 00:29:34,460
或者他们会是，
or would they be,

783
00:29:35,100 --> 00:29:38,250
就像有人会得到，
like could someone get like if they

784
00:29:38,250 --> 00:29:40,080
比如如果他们回答对了一些问题，
answered some of the questions right,

785
00:29:40,080 --> 00:29:41,580
但不是所有的问题
but not all the questions right when

786
00:29:41,580 --> 00:29:43,160
都回答对了，
they get in between,

787
00:29:43,570 --> 00:29:44,700
那么分数是怎样的。
so the grade.

788
00:29:45,060 --> 00:29:46,880
你知道，我还没有想过这件事。
You know I haven't thought this through.

789
00:29:47,380 --> 00:29:50,320
当然有部分学分的情况，
Um, there's certainly room for partial credit

790
00:29:50,320 --> 00:29:52,480
但这不是，
but it's not, it won't

791
00:29:52,480 --> 00:29:55,090
它不会是二进制的，
be binary, it'll definitely be you

792
00:29:55,090 --> 00:29:56,540
你肯定可以获得部分学分。
can receive partial credit.

793
00:29:56,940 --> 00:30:01,390
好吧。最后的 10% 将是由
Okay. Um, the last 10% is going to

794
00:30:01,390 --> 00:30:03,700
家庭作业和
be a driven by the homework and

795
00:30:03,700 --> 00:30:06,920
讲座和 piazza 的参与决定的。
participation during lecture and piazza.

796
00:30:07,480 --> 00:30:11,740
今年不会有考试或
Um. There will be no exams or quizzes,

797
00:30:13,300 --> 00:30:14,520
小测验。
this year.

798
00:30:15,150 --> 00:30:16,560
所以，
Um, and so what,

799
00:30:16,560 --> 00:30:18,480
这意味着大部分的，
that means is that most of the um,

800
00:30:18,480 --> 00:30:21,420
你知道 90% 的成绩是
you know 90% of the grade

801
00:30:21,420 --> 00:30:23,160
由实验决定的。
is being driven by the lab.

802
00:30:23,160 --> 00:30:24,780
所以你应该
So you should,

803
00:30:25,050 --> 00:30:26,730
花很多时间在实验上，
spend a lot of time in the labs,

804
00:30:26,730 --> 00:30:29,610
确保你早点开始，
um, make sure that you start early

805
00:30:29,610 --> 00:30:31,710
有足够的时间完成它们，
and have enough time to complete

806
00:30:31,710 --> 00:30:33,930
解决 bug ，
them and work out bugs in

807
00:30:33,930 --> 00:30:35,400
并获得满分。
order to get full credit.

808
00:30:37,270 --> 00:30:38,770
因此，
And you know as a result of

809
00:30:38,770 --> 00:30:40,000
这将是一门非常实用的
that this is going to be a

810
00:30:40,000 --> 00:30:43,660
面向软件的课程。
very kind of hands-on software oriented course.

811
00:30:44,580 --> 00:30:46,520
还有关于
Any questions about the

812
00:30:47,180 --> 00:30:49,000
课程组织问题吗？
machinery of the course.

813
00:30:53,760 --> 00:30:56,670
嗯，在聊天中有几个问题，
Um, we've got a couple questions in chat,

814
00:30:56,670 --> 00:30:58,050
第一个是组织管理的问题，
so the first is a logistical

815
00:30:58,050 --> 00:31:00,450
目前
question, currently 6.S081

816
00:31:00,450 --> 00:31:01,650
6.S081 没有像往常
isn't listed as usual for the

817
00:31:01,650 --> 00:31:03,990
一样列出来，在系统主修课程中，
system's concentration in the [?],

818
00:31:03,990 --> 00:31:05,370
以后有没有增加课程的计划。
are there plans added to the list

819
00:31:05,370 --> 00:31:07,350
我认为，
of classes later. I think for that

820
00:31:07,350 --> 00:31:09,750
因为它不是批准的高级研究生课程，
because it's not an AAGS

821
00:31:09,750 --> 00:31:11,880
它是高级本科课程，
it's an AUS, it can't be

822
00:31:11,880 --> 00:31:13,590
它不能满足安排要求，
used to fulfill arrange requirements,

823
00:31:13,590 --> 00:31:15,700
它不是研究生水平的课程。
so it's not a graduate level class.

824
00:31:15,970 --> 00:31:17,060
那么，
So, um,

825
00:31:19,270 --> 00:31:21,790
然后我们有唯一的
and then we have is the only

826
00:31:21,790 --> 00:31:23,410
家庭作业来提交问题，
homework to submit questions looking at the

827
00:31:23,410 --> 00:31:25,620
看看日历。
calendar that appears to be the case.

828
00:31:28,360 --> 00:31:30,400
除非我忘了什么。
Unless I'm forgetting something.

829
00:31:31,270 --> 00:31:32,110
我想是这样的，
I think that's the case,

830
00:31:32,110 --> 00:31:37,660
是的。那么，有没有分数比例的情况，
yes. So have, um, are there gonna

831
00:31:37,660 --> 00:31:39,670
像百分之 X 得 A，
be cutoffs for grades like X

832
00:31:39,670 --> 00:31:41,260
百分之 Y 得 B
percent gets an A, Y percent

833
00:31:41,260 --> 00:31:43,510
的情况。
gets a B etc.

834
00:31:43,510 --> 00:31:45,040
不，不，
No no,

835
00:31:45,040 --> 00:31:48,210
嗯，
um,

836
00:31:48,210 --> 00:31:49,680
你知道我们努力
you know we're going to try to

837
00:31:49,680 --> 00:31:53,100
给学生自由。
a free student estimate.

838
00:31:53,320 --> 00:31:56,950
我的评价是
I'm impression of how well you've

839
00:31:56,950 --> 00:31:58,090
你对材料理解得好坏，
understood the material,

840
00:31:58,090 --> 00:32:00,480
并在此基础上给出一个等级，
um, and assign a grade based on that

841
00:32:00,480 --> 00:32:03,080
不会有预先设定的比例。
so there's no predetermined cutoffs.

842
00:32:07,950 --> 00:32:10,020
好的，还有其他的吗。
All right, anything else.

843
00:32:13,660 --> 00:32:14,740
好的。
All right.

844
00:32:14,740 --> 00:32:17,140
对于在聊天中
Just real quick for folks in the

845
00:32:17,140 --> 00:32:20,980
询问主修要求
chat asking about the

846
00:32:21,070 --> 00:32:23,530
的人来说，
concentration requirement, I'm not a hundred

847
00:32:23,530 --> 00:32:24,820
我不是百分之百确定，
percent certain, um,

848
00:32:24,820 --> 00:32:26,890
但 6.S081 不是，
but 6.S081 is not,

849
00:32:26,890 --> 00:32:28,570
它就像是课程获得正式编号之前
it's like a temporary number before the

850
00:32:28,570 --> 00:32:30,340
的一个临时编号，
class gets official one, so it

851
00:32:30,340 --> 00:32:33,280
所以它不会出现在任何地方，
certainly won't be listed anywhere,

852
00:32:33,280 --> 00:32:34,540
如果你需要它来实现主修课程，
if you need it to fulfill a

853
00:32:34,540 --> 00:32:36,010
我想你最好的选择
concentration, I think your best bet is

854
00:32:36,010 --> 00:32:37,720
是填写一份请愿书，
probably to fill out a petition or

855
00:32:37,720 --> 00:32:40,480
给 Katrina Kurtz 他们发邮件。
to email somebody like Katrina Kurtz.

856
00:32:40,780 --> 00:32:44,920
要查看状态是什么，我们无法控制，
To see a what the status is, we don't control,

857
00:32:45,570 --> 00:32:48,180
你知道的，哪些课程
you know what what classes fill these

858
00:32:48,180 --> 00:32:49,260
满足这些要求。
kind of requirements,

859
00:32:49,260 --> 00:32:52,650
这门课将使用什么语言，
unfortunately. And for what language will be using

860
00:32:52,650 --> 00:32:55,180
将使用 C 语言。
the class will be in C.

861
00:32:55,490 --> 00:32:59,540
好的，
Yes, all right,

862
00:32:59,540 --> 00:33:01,380
嗯，
um, Yeah,

863
00:33:02,400 --> 00:33:03,900
好的，对于这堂课的剩下的时间，
All right, for the rest of the lecture

864
00:33:03,900 --> 00:33:06,660
我想谈一下，
I want to talk about how, um,

865
00:33:06,660 --> 00:33:09,990
什么系统调用看起来像应用程序，
what system calls look like applications,

866
00:33:09,990 --> 00:33:13,660
你知道，因为系统调用
um, and you know since the system calls

867
00:33:13,660 --> 00:33:16,480
是操作系统
are the interface to the services that

868
00:33:16,480 --> 00:33:18,880
提供服务的接口，
the operating system provides is actually pretty

869
00:33:18,880 --> 00:33:21,010
所以这些系统看起来是什么样子，
important what those systems look like what

870
00:33:21,010 --> 00:33:23,740
应用程序从系统调用中得到什么，
applications expect from system calls and how

871
00:33:23,740 --> 00:33:26,170
以及它们是如何运行的，
they behave so it's worth understanding what

872
00:33:26,170 --> 00:33:28,280
所以理解接口是什么样子是值得的。
the interface looks like.

873
00:33:29,380 --> 00:33:31,090
你将在第一个实验中
Um, you'll be using the system calls we

874
00:33:31,090 --> 00:33:32,840
使用我们谈到的系统调用，
talk about in the first lab,

875
00:33:32,960 --> 00:33:37,160
并在后续的实验中
um, and extending and improving the implementation

876
00:33:37,160 --> 00:33:39,140
扩展和完善这些系统调用
internal implementation of these system calls

877
00:33:39,140 --> 00:33:40,460
的内部实现。
in subsequent labs.

878
00:33:40,960 --> 00:33:43,120
我们将演示一些程序
What we're gonna do is show some

879
00:33:43,120 --> 00:33:47,260
的简单示例。
simple examples of little programs.

880
00:33:47,980 --> 00:33:51,760
它调用系统调用，我将在 xv6 中为
That call system calls and I'll run

881
00:33:51,760 --> 00:33:53,960
运行它们。
them in xv6 for you.

882
00:33:54,540 --> 00:33:56,370
我将运行它们，
I'm gonna run them,

883
00:33:56,370 --> 00:33:58,420
xv6 是一个，
the xv6 is a, um,

884
00:33:58,550 --> 00:33:58,910
它是一个 unix ，
it's a unix,

885
00:33:58,910 --> 00:34:01,250
一个简化的类 unix 操作系统，
a simplified unix-like operating system unix

886
00:34:01,250 --> 00:34:03,740
unix 是一个古老的操作系统，
is a old operating system that's at

887
00:34:03,740 --> 00:34:07,460
至少作为许多当今的操作系统的基础，
least intellectual basis for many present-day operating

888
00:34:07,460 --> 00:34:09,470
比如 Linux 和 OS X 来说，
systems such as Linux and OS X

889
00:34:09,470 --> 00:34:11,480
它是使用非常广泛的。
it's in very common use.

890
00:34:11,480 --> 00:34:18,140
xv6 我们的教学操作系统
Um, xv6 our teaching operating system is

891
00:34:18,140 --> 00:34:20,960
要简单得多，在某种程度上受到 unix 的启发，
much simpler and sort of inspired by

892
00:34:20,960 --> 00:34:23,390
具有相同的整体结构，
unix and has the same overall structure,

893
00:34:23,390 --> 00:34:26,540
但比任何真正的 unix 操作系统
but is dramatically simpler than any real

894
00:34:26,540 --> 00:34:28,180
都要简单得多。
unix operating system.

895
00:34:28,610 --> 00:34:33,120
它很简单足够，
Um, it's simple enough that hopefully,

896
00:34:33,120 --> 00:34:35,070
你知道，
um, you know it would

897
00:34:35,070 --> 00:34:36,600
你可以在几周内
be relatively straightforward

898
00:34:36,600 --> 00:34:38,550
阅读所有的源代码，
for you to read all the source code,

899
00:34:38,550 --> 00:34:40,080
也可以阅读这本书，
as well as read the book,

900
00:34:40,080 --> 00:34:41,910
当然在本学期，
in a couple of weeks certainly

901
00:34:41,910 --> 00:34:43,560
以便了解
during the semester in order to

902
00:34:43,560 --> 00:34:44,970
xv6 内部发生
kind of understand all of what

903
00:34:44,970 --> 00:34:47,200
的所有事情。
happens inside xv6.

904
00:34:47,680 --> 00:34:52,110
xv6 运行在 RISC-V 处理器上，
Um, xv6 runs on the RISC-V

905
00:34:52,110 --> 00:34:55,320
RISC-V 微处理器，
processor, RISC-V microprocessor and this is

906
00:34:55,320 --> 00:34:57,690
这也是最近 6.004 课程
the same microprocessor that's the focus of

907
00:34:57,690 --> 00:34:59,700
所使用的的微处理器，
recent 6.004

908
00:34:59,800 --> 00:35:01,750
所以你们中的许多人
Um, so many of you may actually

909
00:35:01,750 --> 00:35:03,520
实际上可能对 RISC-V 指令集
know quite a bit about the

910
00:35:03,520 --> 00:35:05,240
有相当多的了解。
RISC-V instruction set.

911
00:35:05,780 --> 00:35:08,720
理论上你可以在 RISC-V 计算机上
Um, in theory you could run xv6

912
00:35:08,720 --> 00:35:11,510
运行 xv6 ，
on top of a RISC-V computer

913
00:35:11,510 --> 00:35:13,370
已经有人这么做了。
and people done that.

914
00:35:13,370 --> 00:35:16,330
但是我们要在 QEMU，
Um, but we're going to run it under the QEMU,

915
00:35:16,330 --> 00:35:18,910
机器仿真器下运行，
um, machine emulator,

916
00:35:18,910 --> 00:35:20,680
只需要把我们得到的写下来。
just write this down we got.

917
00:35:20,810 --> 00:35:22,400
我们的操作系统是 xv6 ，
Our operating system is

918
00:35:22,400 --> 00:35:26,300
运行在 RISC-V
xv6, um, runs on RISC-V

919
00:35:26,720 --> 00:35:30,350
微处理器上，而且不仅是 RISC-V 微处理器，
microprocessor and not just RISC-V microprocessor,

920
00:35:30,350 --> 00:35:31,790
但我们假设周围有
but we assume a certain amount

921
00:35:31,790 --> 00:35:34,670
一定数量的硬件，
of surrounding hardware like memory

922
00:35:34,670 --> 00:35:36,120
比如内存和磁盘。
and disk.

923
00:35:36,280 --> 00:35:39,520
还有 console 界面，让我们可以访问它。
And console interface for us to talk to it.

924
00:35:39,520 --> 00:35:43,300
我们实际上是在 QEMU
Um, We actually run under the QEMU

925
00:35:44,720 --> 00:35:46,980
机器模拟器下运行的。
machine simulator.

926
00:35:48,440 --> 00:35:50,210
这是在 Linux 下运行的，
So that which runs under Linux,

927
00:35:50,210 --> 00:35:52,800
所以实际上这就是你们所能做的一切。
so all you can actually.

928
00:35:53,400 --> 00:35:56,120
在没有硬件的情况下运行 xv6 。
A run xv6 without having that hardware.

929
00:35:56,860 --> 00:36:01,260
好的，现在切换到演示代码。
Okay so kind of switch to a show the code.

930
00:36:15,570 --> 00:36:16,050
好的，
All right,

931
00:36:16,050 --> 00:36:22,660
那么，第一件事是在我的笔记本上安装了 xv6 ，
so, um, first thing is I've a setup xv6 on my laptop,

932
00:36:22,800 --> 00:36:25,440
我要运行它，输入 'make qemu'，
I'm going to run it type 'make qemu',

933
00:36:25,440 --> 00:36:25,740
输入 'make qemu'，
'make qemu',

934
00:36:25,740 --> 00:36:27,030
你会发现自己在实验中
you'll find yourself doing quite a

935
00:36:27,030 --> 00:36:28,320
做了相当多的工作，
bit during the labs,

936
00:36:28,320 --> 00:36:30,960
它编译 xv6 它是用 C 编写的，
um, which compiles xv6 it's written in C,

937
00:36:30,960 --> 00:36:32,440
所以它用 C 编译器
so it's compiled with

938
00:36:32,520 --> 00:36:33,990
编译，
C compiler,

939
00:36:33,990 --> 00:36:36,930
我可能输入 'make clean' 清理一下，
maybe I'll 'make clean' for you,

940
00:36:36,930 --> 00:36:39,000
这样你就可以看到实际的编译过程，
so you can see the actual compilation

941
00:36:39,000 --> 00:36:40,620
我输入 'make qemu' ，
and I might 'make qemu',

942
00:36:40,620 --> 00:36:43,170
它的效果是编译和
which has the effect of compiling and

943
00:36:43,170 --> 00:36:45,180
构建 xv6 内核和
building xv6 kernel and all the

944
00:36:45,180 --> 00:36:48,600
所有用户程序，然后在
user processes and then running them under

945
00:36:48,600 --> 00:36:50,300
QEMU 模拟器上运行。
the QEMU emulator.

946
00:36:51,860 --> 00:36:53,880
在编译过程中会花费一些时间，
Takes a moment around the compiles,

947
00:36:55,020 --> 00:36:58,220
是的，现在我们启动并运行
yeah, and now we're up and running

948
00:36:58,220 --> 00:36:59,990
xv6 和 '$' 提示符，
xv6 and the '$'

949
00:36:59,990 --> 00:37:02,570
你看到的是 shell ，
prompt you see as the shell which

950
00:37:02,570 --> 00:37:04,460
它是 xv6 的命令行界面，
is the command line interface,

951
00:37:04,460 --> 00:37:08,360
仿照 unix上 的shell，
um, to xv6, modeled after the shell on unix,

952
00:37:08,360 --> 00:37:09,160
也是
which is,

953
00:37:09,420 --> 00:37:12,240
如果你登录到 Athena 系统，
um, if you log into Athena organization and

954
00:37:12,240 --> 00:37:14,880
它就像 Athena 你看到的
it's, um, it's like the shell that

955
00:37:14,880 --> 00:37:16,080
那个 shell 。
Athena shows you.

956
00:37:18,180 --> 00:37:20,580
xv6 本身很小，
xv6 itself tiny and it comes with

957
00:37:20,580 --> 00:37:23,920
它附带了一些实用程序，
a small number of utility programs and

958
00:37:24,220 --> 00:37:26,110
例如，我将要运行的 'ls' 程序，
including for example the 'ls' program which

959
00:37:26,110 --> 00:37:28,390
运行 ls ，它给我
I'm about to run run ls and

960
00:37:28,390 --> 00:37:29,660
一个所有文件
it gives me a list of

961
00:37:30,210 --> 00:37:31,470
的列表，
all the files and xv6

962
00:37:31,470 --> 00:37:32,670
xv6 只有二十多个文件，
of which there are only about

963
00:37:32,670 --> 00:37:36,320
包括 grep kill
two dozen including things like grep and

964
00:37:36,410 --> 00:37:39,830
mkdir 和 rm ，
kill and mkdir, rm which

965
00:37:39,830 --> 00:37:41,210
是我们熟悉的
may be familiar to us,

966
00:37:41,210 --> 00:37:43,640
unix 实用程序。
um, as unix utilities.

967
00:37:44,930 --> 00:37:46,010
好的，第一个程序，
Okay, the first program,

968
00:37:46,010 --> 00:37:47,540
我要演示的是
I'm gonna show you to illustrate system

969
00:37:47,540 --> 00:37:52,380
copy 程序，
calls is a program called copy,

970
00:37:54,520 --> 00:38:01,220
嗯，
um,

971
00:38:01,900 --> 00:38:04,260
这里的代码只有一页，
here's the source is just a page,

972
00:38:07,320 --> 00:38:09,750
你在这里看到的程序，
um, so what you're seeing here is

973
00:38:09,750 --> 00:38:11,940
它从第 8 行开始， TODO:
a program that starts on line

974
00:38:11,940 --> 00:38:13,290
main 是 C 语言程序的
8 and main is that sort

975
00:38:13,290 --> 00:38:15,510
一种约定，
of convention for C programs,

976
00:38:15,510 --> 00:38:17,740
它位于第 12 行的循环中，
it sits in a loop at line 12,

977
00:38:17,940 --> 00:38:21,150
然后一次又一次地，
and over and over again, it reads

978
00:38:21,150 --> 00:38:23,280
它读取一些数据作为输入，
some data as input and on line

979
00:38:23,280 --> 00:38:25,110
在第 13 行，然后写入数据，
13 and then writes the data just

980
00:38:25,110 --> 00:38:28,180
只需在第 16 行读取它的输出，
read his output on line 16,

981
00:38:28,390 --> 00:38:29,800
通过运行 copy，
by run copy,

982
00:38:32,130 --> 00:38:35,550
在 xv6 中，它正在等待读取输入，
um, in xv6, it's waiting to read input,

983
00:38:35,550 --> 00:38:37,740
如果我在 xv6 中输入，
if I type some input,

984
00:38:37,840 --> 00:38:40,860
它正在等待读取输入，然后把它返回给我。
reads it and spits it back up to me.

985
00:38:41,640 --> 00:38:44,380
非常简单的程序只做 IO 。
Very simple program just does IO.

986
00:38:44,950 --> 00:38:47,170
就像我提到的，
Um, it's really see as I mentioned a

987
00:38:47,170 --> 00:38:49,090
如果你还不了解 C 语言，
if you don't already know C, it's

988
00:38:49,090 --> 00:38:53,290
这本标准的 C 编程语言书很值得读，
worthwhile getting the standard C programming language

989
00:38:53,290 --> 00:38:55,100
由 Kernighan 和 Ritchie 编写。
book by Kernighan and Ritchie.

990
00:38:55,180 --> 00:38:56,400
我认为课程网站上
And I think there's a

991
00:38:56,730 --> 00:38:59,490
有更完整的参考资料，
more full reference to it on the

992
00:38:59,490 --> 00:39:02,680
它向你们解释了如何用 C 语言编程，
course website which explains to you and,

993
00:39:02,760 --> 00:39:05,380
以及 C 语言最直接的使用方法。
um, very straightforward way how to program in C.

994
00:39:06,140 --> 00:39:09,200
是的，就像我之前提到的，
Yeah, as I mentioned before,

995
00:39:09,200 --> 00:39:11,870
我们甚至写这个程序用了两个，
we even write this program makes two

996
00:39:11,870 --> 00:39:13,340
实际上是三个系统调用，
really three system calls read

997
00:39:13,340 --> 00:39:16,320
read write 和 exit ，我们的系统调用。
write and exit, our system calls.

998
00:39:16,460 --> 00:39:18,140
如果你看一下第 13 行的 read 调用，
Um, if you look at the call to

999
00:39:18,140 --> 00:39:22,020
它有三个参数，
read on line 13, it takes three arguments,

1000
00:39:22,500 --> 00:39:23,970
第一个参数是一个文件描述符，
the first argument is a file descriptor

1001
00:39:23,970 --> 00:39:25,230
它实际上是对
which is really a reference to a

1002
00:39:25,230 --> 00:39:27,060
以前打开的文件的引用。
previously opened file.

1003
00:39:27,340 --> 00:39:29,140
shell 确保
Um, and the shell,

1004
00:39:29,140 --> 00:39:33,340
当程序默认启动时，
ensures that when a program starts by default,

1005
00:39:33,440 --> 00:39:35,750
它的文件描述符 0
it's file descriptor 0 is connected to

1006
00:39:35,750 --> 00:39:38,300
连接到控制台输入，
the console input, and its file descriptor

1007
00:39:38,300 --> 00:39:41,090
它的文件描述符 1 连接到控制台输出，
1 is connected to the console

1008
00:39:41,090 --> 00:39:42,170
这就是为什么我能够
output, and that's why I was

1009
00:39:42,170 --> 00:39:43,600
输入到
able to type to

1010
00:39:43,920 --> 00:39:46,900
copy 程序并查看输出。
this copy program and see the output.

1011
00:39:48,700 --> 00:39:52,660
当然，这些文件描述符是程序预期的，
Um, of course, these file descriptors are expected

1012
00:39:52,660 --> 00:39:54,640
这些文件描述符
the program expected these file descriptors have

1013
00:39:54,640 --> 00:39:56,350
已经提前打开，
been previously opened and set up by

1014
00:39:56,350 --> 00:39:57,500
并由 shell 为其设置。
the shell for it.

1015
00:39:57,600 --> 00:40:01,860
0 1 文件描述符，
And 0 1 file descriptors,

1016
00:40:01,920 --> 00:40:03,780
是普遍的约定，
pervasive units convention many,

1017
00:40:03,780 --> 00:40:06,240
有很多很多 unix 程序希望
many unix programs expect to read from

1018
00:40:06,240 --> 00:40:09,180
从文件描述符 1 读取，读取文件描述符 0 ， TODO:
file descriptor 1 and read file descriptor

1019
00:40:09,180 --> 00:40:11,520
并写入文件描述符 1 。
0 and write to file descriptor 1.

1020
00:40:12,730 --> 00:40:14,980
要读取的第二个参数是
A second argument to read is a

1021
00:40:14,980 --> 00:40:17,000
指向某个内存的指针，
pointer to some memory,

1022
00:40:17,160 --> 00:40:19,110
程序要求操作系统将数据
um, where the program is asking the operating

1023
00:40:19,110 --> 00:40:21,020
读取到
system to read data

1024
00:40:21,390 --> 00:40:22,710
内存中的那个地址，
into that address in memory,

1025
00:40:22,710 --> 00:40:25,800
这是 buff 参数，
so that's the buff argument and line 10

1026
00:40:26,000 --> 00:40:30,060
第 10 行在堆栈上分配 64 字节的内存
allocate 64 bytes of memory on the stack, um,

1027
00:40:30,350 --> 00:40:31,910
供 read 读取，
for read to read into, and the

1028
00:40:31,910 --> 00:40:33,800
而要读取的第三个参数是程序
third argument to read is the maximum

1029
00:40:33,800 --> 00:40:35,540
想要读取的最大字节数，
number of bytes that the program wants

1030
00:40:35,540 --> 00:40:37,490
缓冲区的大小
to read and the size of buffs

1031
00:40:37,490 --> 00:40:40,730
仅为 60 最大 64 字节， TODO:
as just sixty maximum 64 bytes,

1032
00:40:40,730 --> 00:40:42,410
因此 read 调用
so the read call reads up to 64

1033
00:40:42,410 --> 00:40:45,080
从连接到文件描述符 0 的任何内容
bytes from whatever is connected to file

1034
00:40:45,080 --> 00:40:46,860
读取最多 64 字节，
descriptor 0 and that was

1035
00:40:47,080 --> 00:40:48,820
在本例中， 0 这就是我的终端。
my terminal in this example.

1036
00:40:48,820 --> 00:40:51,460
read 的返回值
The return value from read it either

1037
00:40:51,460 --> 00:40:53,230
可能是
it may be sure of the number

1038
00:40:53,230 --> 00:40:54,640
读取的字节数，
of bytes read,

1039
00:40:54,640 --> 00:40:58,240
可能是 6 ，
um, which would be 6 and a piece of, um,

1040
00:40:58,240 --> 00:41:00,740
输入 "xyzzy" ，
typing "xyzzy" by

1041
00:41:01,150 --> 00:41:02,830
可能是从文件中读取的，
be might be reading from a file,

1042
00:41:02,830 --> 00:41:04,090
如果到达文件末尾，
if it gets to the end of the file,

1043
00:41:04,090 --> 00:41:05,110
就没有更多的字节，
there's no more bytes,

1044
00:41:05,110 --> 00:41:06,760
read 将返回 0 。
read will return 0.

1045
00:41:07,160 --> 00:41:09,470
如果发生其他错误，
And then some other error occurred like

1046
00:41:09,470 --> 00:41:11,900
如文件描述符不存在，
the file descriptor doesn't exist, read may

1047
00:41:11,900 --> 00:41:13,440
read 可能返回 -1 。
return -1.

1048
00:41:13,780 --> 00:41:15,940
在很多例子中，
And, so in many of these examples

1049
00:41:15,940 --> 00:41:17,860
就像在 16 行。 TODO:
like on line 16 there.

1050
00:41:17,940 --> 00:41:20,640
我的示例代码没有
Um I don't my example code doesn't

1051
00:41:20,640 --> 00:41:24,240
检查系统调用返回是否有错误。
check system call returns for errors.

1052
00:41:24,540 --> 00:41:26,340
但是你应该比我更小心，
But you should be more careful than me,

1053
00:41:26,340 --> 00:41:29,220
你应该弄清楚
um, um the you should figure out how

1054
00:41:29,220 --> 00:41:30,750
系统调用是如何返回错误的，
system calls reflect errors,

1055
00:41:30,750 --> 00:41:32,220
通常是返回 -1 ，
it's usually a -1 return

1056
00:41:32,220 --> 00:41:35,040
并检查所有系统调用的返回
value and check all system called

1057
00:41:35,040 --> 00:41:36,560
是否有错误。
returns for errors.

1058
00:41:37,280 --> 00:41:38,630
如果你想知道
And if you want to know

1059
00:41:38,630 --> 00:41:40,550
系统调用参数和返回值是什么，
what the system call arguments and

1060
00:41:40,550 --> 00:41:42,080
这有一个表格，
return values are, there's a table

1061
00:41:42,080 --> 00:41:43,760
我想在书中的第 2 章，
and I think chapter 2 in

1062
00:41:43,760 --> 00:41:46,250
解释了所有 xv6
the book explains all of the

1063
00:41:46,250 --> 00:41:50,500
系统调用参数和
xv6 system call arguments and

1064
00:41:50,880 --> 00:41:52,770
返回值。
return values.

1065
00:41:52,770 --> 00:41:55,440
关于 read 系统调用的问题，
The question regarding the read syscall,

1066
00:41:55,440 --> 00:41:57,120
如果我们将缓冲区大小的
what if we set the max read

1067
00:41:57,120 --> 00:41:59,520
最大读取字节数设置
bytes to size of buff to one

1068
00:41:59,520 --> 00:42:01,500
为缓冲区大小加 1 或更大，
plus size of buffer or bigger,

1069
00:42:01,500 --> 00:42:03,030
如果我们尝试读取的大小超过该大小会怎样。
so what if we try to read more than the size.

1070
00:42:03,030 --> 00:42:06,900
是的，如果有 65 个字节要读取，
Yeah, then if there was 65 bytes to read,

1071
00:42:06,900 --> 00:42:10,080
操作系统会很高兴地将
then the operating system would happily will just

1072
00:42:10,130 --> 00:42:12,800
这 65 个字节复制到
copy those 65 bytes to

1073
00:42:12,800 --> 00:42:14,780
你提供的内存中，
the memory that you provide

1074
00:42:14,780 --> 00:42:16,790
当然还有
and of course there's something

1075
00:42:16,790 --> 00:42:17,660
堆栈上的其他东西，
else on the stack up

1076
00:42:17,660 --> 00:42:19,700
可能是返回程序计数器，
there maybe the return program

1077
00:42:19,700 --> 00:42:20,870
或者参数或
counter or an argument or

1078
00:42:20,870 --> 00:42:22,460
其他东西，
something and so if you

1079
00:42:22,460 --> 00:42:23,930
所以如果你传递 65 个字节，
pass 65,

1080
00:42:23,930 --> 00:42:26,920
那么你就是在让内核写垃圾内存。
then you're inviting a kernel to write junk.

1081
00:42:27,120 --> 00:42:29,840
放到堆栈上一个意想不到的地方。
Um to an unexpected place in your stack.

1082
00:42:30,280 --> 00:42:32,470
因此，这是一个 bug ，
And so that's a bug and it

1083
00:42:32,470 --> 00:42:34,160
它可能会导致你的程序崩溃。
may cause your [firm] to crash.

1084
00:42:34,420 --> 00:42:37,390
或者做一些其他意想不到的事情，
Or do something else unexpected,

1085
00:42:37,390 --> 00:42:38,650
所以作为一个程序员，
so as a programmer,

1086
00:42:38,650 --> 00:42:39,580
你在这里必须小心，
you have to be careful here,

1087
00:42:39,580 --> 00:42:42,130
没有人用 C 语言
there's nobody writing in C with these

1088
00:42:42,130 --> 00:42:43,540
这样使用这些接口。
kind of interfaces there's.

1089
00:42:43,830 --> 00:42:46,320
这是非常非常容易编写的代码，
Um, it's very very easy to write

1090
00:42:46,320 --> 00:42:48,420
编译器可以通过，
code that the compiler is happy

1091
00:42:48,420 --> 00:42:50,130
并且可以运行，
with and will run but absolutely

1092
00:42:50,130 --> 00:42:51,340
但绝对是错误的事。
does the wrong thing.

1093
00:42:51,660 --> 00:42:57,320
那太糟糕了，但事情就是这样。
Um, so that's too bad but it's the way it is.

1094
00:43:00,540 --> 00:43:01,350
好的，
Okay, um,

1095
00:43:01,350 --> 00:43:03,750
有一件事需要注意，
one thing to note is that this

1096
00:43:03,750 --> 00:43:05,700
这个 copy 程序和 read write
copy program and indeed the read write

1097
00:43:05,700 --> 00:43:07,740
系统调用，它们不关心
system calls they don't care about the

1098
00:43:07,740 --> 00:43:08,460
数据的格式，
format of data,

1099
00:43:08,460 --> 00:43:10,470
他们在读或写，它们只是
they're reading or writing a they just

1100
00:43:10,470 --> 00:43:12,480
在这个 copy 程序中
read and write read and write in

1101
00:43:12,480 --> 00:43:13,820
读写读写。
this copy program.

1102
00:43:13,980 --> 00:43:15,780
处理 8 位字节
Just deal with 8 bit bytes with

1103
00:43:15,780 --> 00:43:17,600
用 8 位的流即可。
streams of 8 bit bytes.

1104
00:43:17,680 --> 00:43:20,500
如何解释它们完全取决于
Um, how you interpret them is totally up

1105
00:43:20,500 --> 00:43:21,220
应用程序，
to the application,

1106
00:43:21,220 --> 00:43:23,160
应用程序可能会
so the application maybe,

1107
00:43:23,300 --> 00:43:26,840
解析数据记录，作为 C 语言代码，
a parse there data records or as C source code,

1108
00:43:26,840 --> 00:43:28,100
或者谁知道是什么。
or who knows what.

1109
00:43:28,890 --> 00:43:30,390
操作系统，
The operating system,

1110
00:43:30,390 --> 00:43:34,200
只知道这是
um, the only things in terms of a

1111
00:43:34,200 --> 00:43:36,120
8 位字节流。
stream of 8 bit bytes.

1112
00:43:36,220 --> 00:43:37,420
好的， copy ，
Okay, so copy,

1113
00:43:37,420 --> 00:43:38,800
假设这段代码，
assumed this code,

1114
00:43:38,800 --> 00:43:40,120
copy ，我可以假设
my copy I can assume that the

1115
00:43:40,120 --> 00:43:42,850
文件描述符已经设置好了，
file descriptors are already set up,

1116
00:43:42,850 --> 00:43:44,380
但是我们需要有一种方法
but we need to need to have

1117
00:43:44,380 --> 00:43:46,220
来创建文件描述符。
a way to create file descriptors.

1118
00:43:46,280 --> 00:43:47,870
要做到这一点，最直接的方法就是
And the most straightforward way to do

1119
00:43:47,870 --> 00:43:51,140
使用 open 系统调用，
that is with the open system

1120
00:43:51,140 --> 00:43:52,910
这是一个名为 open 的程序
call and so here's the source for

1121
00:43:52,910 --> 00:43:55,520
的源代码。
a program that called open.

1122
00:43:55,720 --> 00:43:57,180
那个，
That um,

1123
00:43:58,120 --> 00:44:00,370
我用的是 open 系统调用。
I use the open system call. A

1124
00:44:00,370 --> 00:44:01,600
聊天中的提问，
question from the chat,

1125
00:44:01,600 --> 00:44:04,900
你说的字节流是什么意思。
what do you mean by a stream of bytes.

1126
00:44:07,190 --> 00:44:09,380
我的意思是
Um, I just mean that if a

1127
00:44:09,380 --> 00:44:12,060
如果一个文件包含一串字节，
file contains a bunch of bytes,

1128
00:44:12,180 --> 00:44:15,000
然后读取
then read then successive spilling a pile

1129
00:44:15,000 --> 00:44:16,860
连续一百万个字节的内容，
contains a million bytes,

1130
00:44:16,860 --> 00:44:21,040
如果您进行一系列的 read 调用，每个 400
字节。 TODO:
if you make a sequence of read calls each 400 bytes.

1131
00:44:21,160 --> 00:44:22,330
你知道，我只读第一个 100 字节，
You know I'll just read the first

1132
00:44:22,330 --> 00:44:23,710
然后是第二个 100 字节，
hundred bytes and then the second hundred

1133
00:44:23,710 --> 00:44:24,580
然后是第三个，
bytes and then third,

1134
00:44:24,580 --> 00:44:27,260
第三个 100 字节。
the third hundred bytes.

1135
00:44:27,960 --> 00:44:28,880
嗯。
And um.

1136
00:44:32,000 --> 00:44:32,330
好的，
All right,

1137
00:44:32,330 --> 00:44:33,350
那么这个程序，
so this program,

1138
00:44:33,350 --> 00:44:36,380
open ，我来运行它。
um, called open, I'll run it for you.

1139
00:44:36,720 --> 00:44:39,990
它所做的是创建一个
Um, what it does is a opens creates

1140
00:44:39,990 --> 00:44:41,940
名为 output.txt 的新文件，
a new file called "output.txt"

1141
00:44:41,940 --> 00:44:44,520
然后向其中写入一些字节，
and then write some bytes to it,

1142
00:44:44,520 --> 00:44:45,990
我将完成这个操作，
I'm gonna finish this so we don't

1143
00:44:45,990 --> 00:44:48,180
我们看不到任何东西，
see anything because it broke data to

1144
00:44:48,180 --> 00:44:49,020
因为它将数据放到这个文件中。
this file.

1145
00:44:49,020 --> 00:44:50,380
但是我们可以查看
But we can look

1146
00:44:50,700 --> 00:44:55,110
它创建的 output.txt 文件，可以看到

this "output.txt" file that created it and see,

1147
00:44:55,110 --> 00:44:57,390
"ooo" 写在那里，
um, the "ooo" wrote there,

1148
00:44:57,390 --> 00:45:00,100
所以程序中有一个 11 。 TODO:
so an 11 in the program.

1149
00:45:00,430 --> 00:45:02,380
进行 open 系统调用，
Makes the open system call,

1150
00:45:02,380 --> 00:45:04,750
给它一个文件名 output.txt
give it a filename "output.txt"

1151
00:45:04,750 --> 00:45:07,330
和第二个参数中的 "O_" 的选项，
and the "O_" stuff,

1152
00:45:07,330 --> 00:45:08,860
open 的标志，
um in the second argument to open

1153
00:45:08,860 --> 00:45:12,070
告诉内核中的 open 系统调用实现，
our flags that tell the open system

1154
00:45:12,070 --> 00:45:14,500
我们想
call implementation in the kernel, that we'd

1155
00:45:14,500 --> 00:45:16,030
用用这个名字创建一个文件，
like to create a file with its

1156
00:45:16,030 --> 00:45:18,020
然后写入。
name and we're going to write it.

1157
00:45:18,860 --> 00:45:22,000
open 返回新分配的文件描述符。
Open returns a newly allocated file descriptor.

1158
00:45:22,570 --> 00:45:24,670
文件描述符只是
Um, and the file descriptor is just

1159
00:45:24,670 --> 00:45:26,410
一个很小的数字，
a small number, probably 2 or

1160
00:45:26,410 --> 00:45:27,760
可能是 2 3 或 4 这些。
3 or 4 something.

1161
00:45:28,430 --> 00:45:29,840
然后我们将相同的文件描述符与
And then we pass that same file

1162
00:45:29,840 --> 00:45:32,960
缓冲区一起传递，
descriptor right along with the buffer and

1163
00:45:33,050 --> 00:45:36,760
以及多种写入数据的选项，
a number of ways to write a that writes data,

1164
00:45:37,040 --> 00:45:37,940
文件，
um, the file,

1165
00:45:37,940 --> 00:45:40,080
文件描述符所引用的。
the file descriptor refers to.

1166
00:45:41,430 --> 00:45:43,440
文件描述符实际上是
What that file descriptor is actually doing

1167
00:45:43,440 --> 00:45:46,170
索引到内核中的一个小表中，
is indexing into a little table inside

1168
00:45:46,170 --> 00:45:49,410
内核维护每个进程的状态，
the kernel, the kernel maintains state for each process,

1169
00:45:49,410 --> 00:45:51,660
也就是你运行的
that's running each program that you run

1170
00:45:51,660 --> 00:45:52,620
每个程序，
and among other things,

1171
00:45:52,620 --> 00:45:55,140
内核会记住一个表，
the kernel remembers a table for every

1172
00:45:55,140 --> 00:45:58,830
用于按文件描述符索引的每个正在运行的进程，
running process of index by file descriptors

1173
00:45:58,830 --> 00:46:01,020
该表可以告诉内核
and the table sort of tells the

1174
00:46:01,020 --> 00:46:04,380
每个文件描述符引用的是什么。
kernel what each file descriptor refers to.

1175
00:46:05,040 --> 00:46:10,960
好的，关键点是每个进程都有
Okay, a critical point is that each process

1176
00:46:10,960 --> 00:46:13,300
自己的文件描述符空间。
has its own sort of space of

1177
00:46:13,300 --> 00:46:15,040
因此，
file descriptors. So,

1178
00:46:15,200 --> 00:46:17,420
在运行两个不同的进程，
before running two different processes,

1179
00:46:17,420 --> 00:46:19,790
两个不同的程序和不同的进程，
two different programs and different processes and

1180
00:46:19,790 --> 00:46:20,990
它们都打开一个文件之前，
they both open a file,

1181
00:46:20,990 --> 00:46:22,640
它们可能会得到相同的
they may actually get the same number

1182
00:46:22,640 --> 00:46:24,350
文件描述符的编号，
back as a file descriptor,

1183
00:46:24,350 --> 00:46:26,450
但是因为内核为每个进程维护
but because the kernel maintains a separate

1184
00:46:26,450 --> 00:46:29,000
单独的文件描述符，
file descriptor for each process,

1185
00:46:29,080 --> 00:46:31,630
所以相同的文件描述符号
the same file descriptor number may refer

1186
00:46:31,630 --> 00:46:34,720
在不同进程中可能引用不同文件。
to different files in different processes.

1187
00:46:37,040 --> 00:46:39,640
关于这个 open 程序有什么问题。
Any questions that open about this little program.

1188
00:46:40,240 --> 00:46:41,050
在聊天中有一个问题，
Now we had a question in

1189
00:46:41,050 --> 00:46:42,640
一个不熟悉 C 语言的
chat, question from someone not

1190
00:46:42,640 --> 00:46:43,990
人提出的问题，
familiar with C,

1191
00:46:43,990 --> 00:46:46,540
这些文件和
how are these files being described different

1192
00:46:46,540 --> 00:46:47,830
普通的 C 程序有什么不同，
from normal C programs,

1193
00:46:47,830 --> 00:46:49,990
是不是因为我们只使用内核调用，
is it because we're only using kernel

1194
00:46:49,990 --> 00:46:52,480
也就是说，我们能不能用 python
calls, i.e couldn't we also open or

1195
00:46:52,480 --> 00:46:54,040
打开或写文件。
write a file in python.

1196
00:46:58,500 --> 00:47:01,260
嗯，我想我不明白这是
Um, I don't think I understand that

1197
00:47:02,000 --> 00:47:02,750
一个 C 程序，
it's a C program,

1198
00:47:02,750 --> 00:47:04,520
就是打开和写一个文件。
that's opening and writing a file.

1199
00:47:12,480 --> 00:47:18,040
嗯，那会继续下去的。
Um, that's going to move on.

1200
00:47:20,640 --> 00:47:24,780
好的，那么你可能
All right so you might ask what

1201
00:47:24,780 --> 00:47:27,480
问的是，当……也许问题是，
actually happens when ... Maybe the question

1202
00:47:27,480 --> 00:47:29,430
当有人用 C 语言做这件事时，
is when someone is doing it

1203
00:47:29,430 --> 00:47:31,110
除了语法，
in C any different than doing

1204
00:47:31,110 --> 00:47:33,300
与用 python 有什么不同。
it in Python minus the syntax.

1205
00:47:34,240 --> 00:47:38,380
它不是真的，
Well it's not really, um,

1206
00:47:38,620 --> 00:47:44,040
当然也有办法，
and, there's certainly ways to, um,

1207
00:47:44,410 --> 00:47:48,280
python 提供了很好的函数调用
python provides nice function calls for opening

1208
00:47:48,280 --> 00:47:50,040
来打开和做所有这些事情。
and doing all these things too.

1209
00:47:50,830 --> 00:47:51,640
或者打开文件，
Or opening files,

1210
00:47:51,640 --> 00:47:53,590
比如说在读写文件的时候，
for example in reading writing files,

1211
00:47:53,590 --> 00:47:56,890
有一个层级
um, there's a layer of a higher

1212
00:47:56,890 --> 00:47:59,920
比较高的函数，
somewhat higher level functions typically not

1213
00:47:59,920 --> 00:48:00,970
比如说一般不会有指针
pointers the memory,

1214
00:48:00,970 --> 00:48:01,940
指向内存。
for example.

1215
00:48:02,140 --> 00:48:06,680
python 为你提供了更多的错误检查。
Um, and python has more error checking for you.

1216
00:48:07,140 --> 00:48:09,120
但是当你用 python 打开一个文件，
Um, but when you open a file in

1217
00:48:09,120 --> 00:48:11,940
或者用 python 写一个文件的时候，
python or write a file on python, the

1218
00:48:11,960 --> 00:48:13,360
你使用的 python 调用，
python calls you make,

1219
00:48:14,300 --> 00:48:18,160
归根结底就是这样的系统调用。
boil down to system calls just like these.

1220
00:48:19,840 --> 00:48:21,520
这是个好答案吗。
Is that a good answer.

1221
00:48:25,860 --> 00:48:27,030
我想是的。
Think so.

1222
00:48:27,030 --> 00:48:28,940
好的，
All right,

1223
00:48:30,980 --> 00:48:32,840
好的。
all right, um.

1224
00:48:33,560 --> 00:48:36,680
我一直在这里讨论，
I've been over here talking to the, um,

1225
00:48:39,120 --> 00:48:43,440
xv6 是类似 unix 的 shell ，
xv6 is unix like shell

1226
00:48:43,440 --> 00:48:44,970
shell 是人们通常所说的
and the shell is what people often

1227
00:48:44,970 --> 00:48:46,890
命令行界面，
call the command line interface,

1228
00:48:46,890 --> 00:48:50,980
相对更图形化的用户界面。
um, as opposed to a more graphical user interface.

1229
00:48:51,240 --> 00:48:53,370
shell 是，
Um, the shell turns,

1230
00:48:53,370 --> 00:48:54,450
如果你没有用过 shell ，
if you haven't used the shell,

1231
00:48:54,450 --> 00:48:56,400
shell 对于 unix 系统的
the shell turns out to be a

1232
00:48:56,400 --> 00:48:58,200
系统管理来说
pretty useful interface for things like system

1233
00:48:58,200 --> 00:49:01,440
是一个非常有用的界面，
management of unix systems,

1234
00:49:01,440 --> 00:49:02,940
它提供了很多实用程序
it provides a lot of utilities

1235
00:49:02,940 --> 00:49:05,370
来处理文件和
for messing around with files and

1236
00:49:05,370 --> 00:49:07,080
程序开发，
for program development and

1237
00:49:07,140 --> 00:49:09,180
以及编写脚本来完成所有这些事情。
on writing scripts to do all these

1238
00:49:09,180 --> 00:49:12,340
所以，[在继续之前]，
things. So, [some before run],

1239
00:49:12,550 --> 00:49:13,660
我想在你输入的时候，
I just want to demonstrate a few

1240
00:49:13,660 --> 00:49:16,630
演示几个 shell 常用的功能，
shell features ordinarily when you type things,

1241
00:49:16,630 --> 00:49:20,080
你告诉 shell 运行一个程序，
um. You're telling the shell to run a program,

1242
00:49:20,080 --> 00:49:21,280
所以当我输入 ls 的时候，
so when I type ls what

1243
00:49:21,280 --> 00:49:23,410
意思是
that means is I'm asking the

1244
00:49:23,410 --> 00:49:25,480
要求 shell 运行程序，
shell to run the program

1245
00:49:25,530 --> 00:49:27,480
程序的名称是 ls ，
whose name is ls, and what

1246
00:49:27,480 --> 00:49:28,590
这实际上意味着
that really means is there's a

1247
00:49:28,590 --> 00:49:30,990
在文件系统中
file in the file system called

1248
00:49:30,990 --> 00:49:33,630
有一个叫做 ls 的文件，
ls that contains some instructions,

1249
00:49:33,630 --> 00:49:35,880
它包含一些指令，一些机器指令，
some machine instructions and I'm asking the

1250
00:49:35,880 --> 00:49:38,520
我要求 shell 运行
shell to run the instructions that are

1251
00:49:38,520 --> 00:49:40,770
文件 ls 中的指令，
in the file called ls,

1252
00:49:40,770 --> 00:49:44,660
其中一个 ls ，它的实际作用是， TODO:
one ls now ls what it actually does is, um,

1253
00:49:44,940 --> 00:49:46,290
获取当前目录中的
get a listing of the files in

1254
00:49:46,290 --> 00:49:47,250
文件列表，
the current directory,

1255
00:49:47,250 --> 00:49:48,150
你可以在上面的
and you can see up there

1256
00:49:48,150 --> 00:49:50,970
第 4 行看到，
on the 4 line that among

1257
00:49:50,970 --> 00:49:52,900
在其他文件中，
the other files that

1258
00:49:52,980 --> 00:49:54,420
ls 也是存在的，
ls as exists,

1259
00:49:54,420 --> 00:49:56,040
这个列表是一个 TODO:
and this list is a file called

1260
00:49:56,040 --> 00:49:58,560
名为 ls 的文件，它实际上
ls which is in fact the file

1261
00:49:58,560 --> 00:50:00,540
包含了我刚刚运行的指令。
containing the instructions I just ran.

1262
00:50:02,370 --> 00:50:03,660
除了运行程序，
The shell does a few other things

1263
00:50:03,660 --> 00:50:06,690
shell 还为你做了其他事情，
for you other than running programs allows

1264
00:50:06,690 --> 00:50:08,490
允许重定向 IO ，
you to redirect IO,

1265
00:50:08,490 --> 00:50:10,230
例如，如果我输入
so for example if I say

1266
00:50:10,230 --> 00:50:12,420
'ls>out' ，意思是
'ls > out' what that means is

1267
00:50:12,420 --> 00:50:15,030
要求 shell 运行 ls 命令，
asking the shell run the ls command,

1268
00:50:15,030 --> 00:50:16,980
但将其输出重定向到
but with its output redirected to the

1269
00:50:16,980 --> 00:50:18,260
名为 out 的文件。
file called out.

1270
00:50:18,520 --> 00:50:19,920
我运行 ls 。
I run ls.

1271
00:50:21,080 --> 00:50:22,640
我们看不到任何输出，
We don't see any output because the

1272
00:50:22,640 --> 00:50:24,080
因为输出都重定向了。
output all went out.

1273
00:50:24,960 --> 00:50:28,530
现在我可以出来一堆数据，
Um, now I can out contains a bunch of data,

1274
00:50:28,530 --> 00:50:30,380
我们可以，
um, we could,

1275
00:50:30,900 --> 00:50:33,300
cat 命令读取一个文件并
The cat command reads a file and

1276
00:50:33,300 --> 00:50:35,430
显示该文件的内容，
displays the contents of the file,

1277
00:50:35,430 --> 00:50:37,080
我输入 'cat out' 。
so I say 'cat out'.

1278
00:50:37,190 --> 00:50:38,870
现在我们来看看，
Just going to see now the now

1279
00:50:38,870 --> 00:50:41,080
这和 ls 的输出是相同的。
this is the same output of ls.

1280
00:50:41,170 --> 00:50:42,490
你还可以运行
You can also run a command like

1281
00:50:42,490 --> 00:50:43,420
像 'grep' 这样的命令，
'grep' and I can give it an

1282
00:50:43,420 --> 00:50:46,300
我给它一个参数 "x" 和 'grep x' 。
argument "x" and what 'grep x'.

1283
00:50:46,520 --> 00:50:48,700
grep 命令通过模式搜索。
The grep command searches for patterns.

1284
00:50:49,080 --> 00:50:54,360
同样，如果我运行 'grep x' ，它将搜索
Again a if I run 'grep x', it's gonna search for

1285
00:50:54,680 --> 00:50:58,250
包含 "x" 的输入行。我可以重定向，
lines of input to contain "x". I can redirect,

1286
00:50:58,250 --> 00:51:00,170
告诉 shell 将其输入
tell the shell to redirect its input

1287
00:51:00,170 --> 00:51:01,600
从文件 "out" 重定向。
from the file "out".

1288
00:51:01,700 --> 00:51:03,170
以便查找保存了ls个输出的动作的实例。
In order to look for instances of

1289
00:51:03,170 --> 00:51:06,020
acts that saved ls output.

1290
00:51:07,150 --> 00:51:10,210
原来有三个文件的名称包含“x”。
It turns out there's three files whose

1291
00:51:10,210 --> 00:51:12,080
names contain "x".

1292
00:51:13,000 --> 00:51:14,960
嗯。嗯，我们要花一些时间在外壳上，嗯，嗯，它的外壳是一种最传统和最基本的接口单元，因为在Unix最初开发的时候，所有的都是简单的终端接口，就像我们现在使用的那个，单元最初的主要用途是分享时间，让一群人登录到同一台机器上，很像雅典娜和贝壳交谈。
Yeah. Um,

1293
00:51:15,560 --> 00:51:16,430
we're going to spend a bunch of

1294
00:51:16,430 --> 00:51:17,450
time with the shell,

1295
00:51:17,450 --> 00:51:19,040
um, uh,

1296
00:51:19,040 --> 00:51:21,860
its shell is sort of the most

1297
00:51:21,860 --> 00:51:26,540
traditional and fundamental interface units,

1298
00:51:26,540 --> 00:51:29,180
because when unix was first developed, all

1299
00:51:29,180 --> 00:51:30,860
there was was simple terminal interfaces,

1300
00:51:30,860 --> 00:51:32,930
like the one we're using and

1301
00:51:32,930 --> 00:51:35,450
the main use of units originally was

1302
00:51:35,450 --> 00:51:37,370
time sharing a bunch of people logging

1303
00:51:37,370 --> 00:51:38,540
into the same machine,

1304
00:51:38,540 --> 00:51:41,960
much like Athena and talking to shells.

1305
00:51:43,300 --> 00:51:47,860
一个关于系统调用和编译器的问题，编译器如何处理生成的系统调用，汇编语言对操作系统定义的某些代码段进行过程调用。
A question about system calls and the compiler,

1306
00:51:47,860 --> 00:51:49,300
how does the compiler handles system

1307
00:51:49,300 --> 00:51:51,310
calls does assembly generated make a

1308
00:51:51,310 --> 00:51:53,620
procedure call to some code segment

1309
00:51:53,620 --> 00:51:55,480
defined by the operating system.

1310
00:51:57,020 --> 00:51:59,960
嗯，有一个特殊的RISC-V指令，程序可以调用它来转移内核下的控制权，所以实际上当你写C代码让系统叫做open write时，嗯。从技术上讲，实际上是开放的，是C库中的一个C函数。
Um, there's a special RISC-V instruction that

1311
00:51:59,960 --> 00:52:02,060
a program can call that transfers control

1312
00:52:02,060 --> 00:52:02,840
under the kernel,

1313
00:52:02,840 --> 00:52:05,360
so indeed when you write C code

1314
00:52:05,360 --> 00:52:07,550
that makes the system called open write,

1315
00:52:07,550 --> 00:52:10,520
um. And technically what actually happens is

1316
00:52:10,520 --> 00:52:12,950
open is a C function in

1317
00:52:12,950 --> 00:52:14,500
the C library.

1318
00:52:14,620 --> 00:52:17,860
嗯，但是那个功能里面的指令真的是机器指令，它不是打开的。
Um, but the instructions in that function are

1319
00:52:17,860 --> 00:52:19,630
really machine instructions,

1320
00:52:19,630 --> 00:52:21,360
it's not open.

1321
00:52:21,820 --> 00:52:23,470
我们调用的open函数不是用汇编语言实现的C函数，汇编代码，嗯，由这个叫做eCall的特殊指令组成。
The open function that we're calling isn't

1322
00:52:23,470 --> 00:52:26,820
a C function implemented in assembler and,

1323
00:52:26,950 --> 00:52:28,630
the assembly code,

1324
00:52:28,630 --> 00:52:32,300
um, consists of this special instructions

1325
00:52:32,300 --> 00:52:34,060
actually called ecall.

1326
00:52:34,140 --> 00:52:35,910
在RISC-V上，将控制权转移到内核的特殊指令，然后内核查看进程、内存和寄存器，以找出参数是什么。
On RISC-V the special instruction

1327
00:52:35,910 --> 00:52:37,440
that transfers control

1328
00:52:37,580 --> 00:52:38,900
into the kernel,

1329
00:52:38,900 --> 00:52:40,520
and then the kernel looks at

1330
00:52:40,520 --> 00:52:42,380
the processes memory and registers to

1331
00:52:42,380 --> 00:52:43,700
figure out what the

1332
00:52:44,260 --> 00:52:45,160
arguments were.

1333
00:52:50,610 --> 00:52:53,610
好的，我想看的下一个例子是调用‘fork’的示例程序。
All right, the next example I want

1334
00:52:53,610 --> 00:52:55,800
to look at is example program

1335
00:52:55,800 --> 00:52:58,180
that calls 'fork'.

1336
00:52:58,420 --> 00:53:00,220
创建进程，嗯，这是第12行fork非常简单的用法，我们调用fork，fork所做的是创建调用进程的指令和数据内存的副本，现在我们有两个内存相同的进程。
Creating process,

1337
00:53:00,220 --> 00:53:02,720
um, so this is the

1338
00:53:03,430 --> 00:53:04,780
very simple use of fork at

1339
00:53:04,780 --> 00:53:07,270
line 12, we're calling fork and

1340
00:53:07,270 --> 00:53:08,420
what fork does is

1341
00:53:08,670 --> 00:53:11,460
creates a copy of the memory of

1342
00:53:11,460 --> 00:53:14,490
instructions and data of the calling process,

1343
00:53:14,490 --> 00:53:17,720
now we have two processes with identical memory.

1344
00:53:18,010 --> 00:53:20,200
fork，则fork系统调用在两个进程中都返回。
Fork, the fork system call returns

1345
00:53:20,200 --> 00:53:22,080
in both processes.

1346
00:53:22,360 --> 00:53:24,430
在原始进程中，fork系统调用返回进程id，它是一个大于0的整数。
In the original process,

1347
00:53:24,430 --> 00:53:26,710
the fork system call returns the process

1348
00:53:26,710 --> 00:53:28,800
id which is, um

1349
00:53:29,080 --> 00:53:31,480
an integer greater than 0.

1350
00:53:32,100 --> 00:53:33,900
对于返回的原始进程，新创建的进程的进程id和在新创建的进程fork中返回0。
The original process for returns,

1351
00:53:33,900 --> 00:53:35,610
the process id of the newly created

1352
00:53:35,610 --> 00:53:38,580
process and in the newly created process

1353
00:53:38,580 --> 00:53:40,960
fork returns 0.

1354
00:53:41,630 --> 00:53:42,920
所以我们可以说，即使进程有相同的内存，你也可以通过从fork返回的值来打破新旧进程的对称性。
So we sort of break even though

1355
00:53:42,920 --> 00:53:45,230
the processes have identical memory,

1356
00:53:45,230 --> 00:53:47,720
you can break the symmetry of

1357
00:53:47,720 --> 00:53:49,310
old versus new process by the

1358
00:53:49,310 --> 00:53:50,800
return value from fork.

1359
00:53:50,940 --> 00:53:53,790
在第16行，您可以看到代码，检查并指出，如果进程id等于0，则必须是子进程，您现在必须在子进程中运行。
And in line 16 you can see code,

1360
00:53:53,790 --> 00:53:54,930
the checks and says if the

1361
00:53:54,930 --> 00:53:56,310
process id is equal 0 must

1362
00:53:56,310 --> 00:53:57,180
be the child,

1363
00:53:57,180 --> 00:53:59,100
you must now be running in the child.

1364
00:53:59,420 --> 00:54:01,850
嗯，当然另一个进程里面有两个进程，这个调用的进程，通常叫做父进程id大于0。
Um, of course there's two processes in

1365
00:54:01,850 --> 00:54:03,260
the other process,

1366
00:54:03,260 --> 00:54:04,970
um in the calling process which is

1367
00:54:04,970 --> 00:54:07,220
usually called the parent process id is

1368
00:54:07,220 --> 00:54:08,560
greater than 0.

1369
00:54:08,640 --> 00:54:11,520
嗯，所以孩子会打印“孩子”，家长会打印“家长”。
Um, so the child will print "child" and

1370
00:54:11,520 --> 00:54:13,500
the parent will print "parent".

1371
00:54:14,350 --> 00:54:18,540
然后他们两个都会离开。所以当我运行fork的时候，现在我们得到了，所以它可能看起来像垃圾。
And then they'll both exit. So when I run fork,

1372
00:54:19,380 --> 00:54:24,860
now here we get, so it may look like garbage.

1373
00:54:25,230 --> 00:54:27,630
实际上，在分叉之后，这两个进程都在运行，它们都是同时运行的，QEMU实际上为我模拟了一个多核微处理器，所以它们实际上是同时运行的，所以当它们产生输出时。
What's actually happening is that after the fork,

1374
00:54:27,630 --> 00:54:29,340
both of these processes are running they're

1375
00:54:29,340 --> 00:54:31,800
both running at the same time and

1376
00:54:31,800 --> 00:54:35,540
QEMU is actually emulating a multi-core,

1377
00:54:35,750 --> 00:54:36,890
microprocessor for me,

1378
00:54:36,890 --> 00:54:39,380
so they really are running at

1379
00:54:39,380 --> 00:54:40,280
the very same time,

1380
00:54:40,280 --> 00:54:41,820
so when they produce output.

1381
00:54:41,850 --> 00:54:43,200
它们同时产生输出的每个字节，而另一个进程产生输出的相应字节，所以这两个进程的输出是不同级别的，嗯，你可以看到它们都在键入“f”。
They're producing each byte of their

1382
00:54:43,200 --> 00:54:44,460
output at the same time as

1383
00:54:44,460 --> 00:54:45,840
the other process is producing the

1384
00:54:45,840 --> 00:54:47,670
corresponding bytes of its output,

1385
00:54:47,670 --> 00:54:50,360
so the output of the two processes are

1386
00:54:50,820 --> 00:54:52,260
inter league,

1387
00:54:52,260 --> 00:54:54,540
um, you can see that they're both typing "f".

1388
00:54:54,800 --> 00:54:57,380
嗯，他们两个都会输入Fork Return。
Um, they're both gonna type fork return.

1389
00:54:57,800 --> 00:54:59,030
嗯，所以你可以从两个字母中看到“f”，在字母“o”中可以看到，在字母“r”中也可以看到，以此类推。
Um, so you can see the "f"

1390
00:54:59,030 --> 00:54:59,960
from both of them, in the

1391
00:54:59,960 --> 00:55:00,890
"o" both of them and the

1392
00:55:00,890 --> 00:55:02,500
"r" both and so on.

1393
00:55:02,920 --> 00:55:04,080
嗯，其中之一。
Um, one of them.

1394
00:55:04,700 --> 00:55:06,200
嗯，你可以看到那1行末尾的0在子分叉返回值0中。
Um, you can see the 0 at the

1395
00:55:06,200 --> 00:55:08,060
end of that 1 line is in

1396
00:55:08,060 --> 00:55:10,040
the child fork return 0.

1397
00:55:10,100 --> 00:55:14,760
嗯，我猜父叉应该返回19。
Um, I'm guessing that the parent fork return 19.

1398
00:55:14,960 --> 00:55:16,850
也就是说，在xv6下，子进程的id是19，这基本上意味着自引导以来创建的19个进程。
That is the child's process id is

1399
00:55:16,850 --> 00:55:19,400
19, under xv6 that basically means the

1400
00:55:19,400 --> 00:55:22,500
19 process that was created since boot.

1401
00:55:22,860 --> 00:55:25,890
嗯，然后其中一个印上“孩子”，你可以看到“c”、“h”、“i”、“l”、“d”交错，另一个是准备的。
Um, and then one of them prints "child"

1402
00:55:25,890 --> 00:55:26,880
and you can see the "c" "h"

1403
00:55:26,880 --> 00:55:28,800
"i" "l" "d" interleave with that is

1404
00:55:28,800 --> 00:55:30,480
the other one prepare.

1405
00:55:30,670 --> 00:55:32,580
所以，是的。
So, yeah.

1406
00:55:32,930 --> 00:55:34,550
这是对fork的一种愚蠢的使用，但是我们可以在这个输出中生动地看到，它创建了两个进程，它们都在运行以返回这两个进程，并且它们都在运行。
This is a silly use of fork,

1407
00:55:34,550 --> 00:55:36,650
but we can see vividly in

1408
00:55:36,650 --> 00:55:38,330
this output that has created two

1409
00:55:38,330 --> 00:55:39,640
processes that are,

1410
00:55:39,920 --> 00:55:41,780
and both of them are running for

1411
00:55:41,780 --> 00:55:43,880
returning both processes and they're both running.

1412
00:55:44,710 --> 00:55:46,750
但还要注意一个打印子进程和另一个父进程，所以fork返回不同的Um和两个进程很重要。
But also note that one printed child

1413
00:55:46,750 --> 00:55:49,540
and the other parent so it's important

1414
00:55:49,540 --> 00:55:51,480
that fork returns differently

1415
00:55:51,770 --> 00:55:53,840
Um, and the two processes.

1416
00:55:59,680 --> 00:56:01,390
问题，嗯，作为派生结果的子进程是否总是与父进程相同，或者它们是否可能不同。
Question, um,

1417
00:56:01,390 --> 00:56:03,070
is the child process as a result of

1418
00:56:03,070 --> 00:56:05,290
fork always identical to the parent process

1419
00:56:05,290 --> 00:56:06,740
or could they be different.

1420
00:56:08,250 --> 00:56:13,560
嗯，在xv6中是一样的。
Um, in xv6 are identical.

1421
00:56:13,740 --> 00:56:17,120
嗯，除了来自fork的返回值。
Um, except the return value from fork.

1422
00:56:17,260 --> 00:56:18,880
你知道指令是一样的，数据是一样的，堆栈是一样的，嗯，也都一样。
You know the instructions are the same

1423
00:56:18,880 --> 00:56:19,960
that data is the same,

1424
00:56:19,960 --> 00:56:22,090
the stack is the same,

1425
00:56:22,090 --> 00:56:23,960
um, also both.

1426
00:56:24,140 --> 00:56:28,700
进程，处理器复制，它们都有各自独立的地址空间，也就是说，它们都有，它们都认为它们的内存从0开始，从那里往上走。
Processes, the processor copies and they both have

1427
00:56:28,700 --> 00:56:30,080
their own separate

1428
00:56:30,160 --> 00:56:32,590
address spaces that is they both

1429
00:56:32,590 --> 00:56:34,390
have they both think that their

1430
00:56:34,390 --> 00:56:35,890
memory starts at 0 and goes

1431
00:56:35,890 --> 00:56:37,160
on up from there.

1432
00:56:37,400 --> 00:56:42,240
嗯，但是不一样，是不同的不同的记忆。
Um, but it's different it's different different memory.

1433
00:56:42,340 --> 00:56:43,960
嗯，和他们两个一起。
Um, with the two of them.

1434
00:56:45,030 --> 00:56:46,680
在更复杂的操作系统中，有一些细节我们绝对不在乎，它们可能偶尔会导致父级和子级不同，但在xv6中，除了返回值之外，它们是相同的。
In a more sophisticated operating system,

1435
00:56:46,680 --> 00:56:49,260
there are some details which we definitely

1436
00:56:49,260 --> 00:56:51,060
don't care about them,

1437
00:56:51,060 --> 00:56:53,790
they may occasionally cause parent and child

1438
00:56:53,790 --> 00:56:55,020
to differ, but in xv6

1439
00:56:55,020 --> 00:56:57,020
they're the same except the return value.

1440
00:56:57,880 --> 00:56:59,410
嗯，所以内存是一样的，另外呢复制了这个文件描述符表。
Um, so the memory is the same,

1441
00:56:59,410 --> 00:57:01,100
in addition the, um,

1442
00:57:02,010 --> 00:57:04,800
file descriptor table is copied.

1443
00:57:05,260 --> 00:57:08,920
所以如果家长打开了一些文件。
So if the parent had some files open.

1444
00:57:09,140 --> 00:57:11,870
嗯，孩子看到的是同一组文件描述符。
Um, and the child sees the same set

1445
00:57:11,870 --> 00:57:13,580
of file descriptors.

1446
00:57:13,800 --> 00:57:17,060
嗯，虽然孩子看到的是复印件。
Um, although the child is seeing them in a copy.

1447
00:57:17,180 --> 00:57:20,780
文件描述符信息表的。
Of the table of file descriptor information.

1448
00:57:21,550 --> 00:57:22,600
所以我们稍后会看到，fork复制打开的文件描述符表和内存是非常重要的。
And so we'll see in a moment

1449
00:57:22,600 --> 00:57:25,210
that it's quite important that a fork

1450
00:57:25,210 --> 00:57:28,180
copies the table of open file descriptors

1451
00:57:28,180 --> 00:57:29,420
as well as the memory.

1452
00:57:31,340 --> 00:57:32,420
好的那么。
Okay so.

1453
00:57:33,360 --> 00:57:34,980
叉子创建了一个新的进程，但是当我们在shell中运行东西时，嗯。shell确实创建了一个新进程来运行您键入的每个命令。
A fork creates a new process,

1454
00:57:34,980 --> 00:57:37,680
but when we run stuff in the shell,

1455
00:57:37,680 --> 00:57:40,950
um. The shell indeed creates a new process

1456
00:57:40,950 --> 00:57:43,260
to run each command that you type.

1457
00:57:43,320 --> 00:57:45,330
嗯，但是它需要在其中实际运行命令，所以如果我输入ls，我们需要shell forks来创建一个进程来运行ls，但是需要有一些方法。
Um, but it needs to actually run the command in it,

1458
00:57:45,330 --> 00:57:47,160
so if I type ls,

1459
00:57:47,160 --> 00:57:49,590
we need to shell forks to create

1460
00:57:49,590 --> 00:57:50,790
a process to run ls,

1461
00:57:50,790 --> 00:57:52,860
but there needs to be some way.

1462
00:57:53,740 --> 00:57:55,930
对于这个新进程，实际运行ls程序中的指令。
For that new process actually run the

1463
00:57:55,930 --> 00:57:58,200
instructions from the ls program.

1464
00:57:58,510 --> 00:58:00,460
在名为ls的文件和示例程序中的指令下面，我将立即向你们展示。
Below those instructions from the file called

1465
00:58:00,460 --> 00:58:03,610
ls and the example program,

1466
00:58:03,610 --> 00:58:05,180
I'm gonna show you in a minute.

1467
00:58:05,320 --> 00:58:06,940
嗯，使用ECHO，ECHO是一个非常简单的命令，a只接受您传递给它的任何参数，并将它们写到它的输出中。
Um, uses echo, echo is a very

1468
00:58:06,940 --> 00:58:10,330
simple command a just takes whatever arguments

1469
00:58:10,330 --> 00:58:11,920
you pass to it and writes them

1470
00:58:11,920 --> 00:58:12,860
to its output.

1471
00:58:13,860 --> 00:58:17,060
我为你们准备了一个叫“EXEC”的节目。
And I prepared for you a program called 'exec'.

1472
00:58:17,470 --> 00:58:22,320
嗯，嗯。
Um, um.

1473
00:58:22,880 --> 00:58:26,020
这是一个运行，它进行exec系统调用，用从您指定的特定文件读取的指令替换调用进程。
Which a run which

1474
00:58:26,830 --> 00:58:29,590
makes the exec system call which replaces

1475
00:58:29,590 --> 00:58:32,650
the calling process with the instructions read

1476
00:58:32,650 --> 00:58:34,390
from a particular file

1477
00:58:34,390 --> 00:58:36,720
you specify.

1478
00:58:37,110 --> 00:58:39,510
在当前进程上加载该文件中的指令，或丢弃其当前内存，然后开始执行这些指令，因此对exec系统调用exec的调用在第12行。
Loads the instructions from that file over

1479
00:58:39,510 --> 00:58:42,240
the current process or discarding its current

1480
00:58:42,240 --> 00:58:45,600
memory and then starts executing those instructions,

1481
00:58:45,600 --> 00:58:48,270
so the call to exec system call

1482
00:58:48,270 --> 00:58:50,920
exec on line 12.

1483
00:58:52,620 --> 00:58:53,940
它将产生操作系统从名为echo的文件加载指令的效果。
It's going to have the effect of

1484
00:58:53,940 --> 00:58:55,980
the operating system loading the instructions from

1485
00:58:55,980 --> 00:58:57,900
the file called echo.

1486
00:58:57,980 --> 00:59:00,860
在当前进程中，类似于替换当前进程的内存，然后开始执行。
In the current process sort of replacing

1487
00:59:00,860 --> 00:59:03,140
the memory of the current process and

1488
00:59:03,140 --> 00:59:04,940
then starting to execute.

1489
00:59:05,260 --> 00:59:07,330
嗯，这些指令，还有，你可以传递参数，命令行参数，回显exec允许你传递一组命令行参数。
Um, those instructions and in addition,

1490
00:59:07,330 --> 00:59:09,550
you can pass arguments command line arguments

1491
00:59:09,550 --> 00:59:12,160
echo exec allows you to pass an

1492
00:59:12,160 --> 00:59:14,220
array of command line arguments.

1493
00:59:14,670 --> 00:59:15,540
它只是C行10中的一个指针数组，它建立了一个字符指针数组，它本质上是字符串，并将该数组初始化为，以包含字符串echo，这是echo，嗯。
It was just an array of

1494
00:59:15,540 --> 00:59:18,360
pointers in C line 10 sets

1495
00:59:18,360 --> 00:59:19,780
up an array of

1496
00:59:19,810 --> 00:59:23,050
character pointers which are essentially strings and

1497
00:59:23,050 --> 00:59:24,900
initialize that array to be,

1498
00:59:25,040 --> 00:59:29,420
to contain the strings echo, this is echo, um.

1499
00:59:29,480 --> 00:59:32,090
这等同于用它们和三个参数调用Running ECHO。
And that's equivalent to calling running echo

1500
00:59:32,090 --> 00:59:33,140
with them and with

1501
00:59:33,360 --> 00:59:34,170
the three arguments.

1502
00:59:34,170 --> 00:59:36,960
这是Echo，所以当我想要EXEC的时候。
This is echo and so when I want exec.

1503
00:59:38,200 --> 00:59:40,120
嗯，确实，嗯，我看到这个输出，这是echo，但是即使我运行了exec命令exec程序。
Um, indeed,

1504
00:59:40,120 --> 00:59:41,380
um I see this output,

1505
00:59:41,380 --> 00:59:41,980
this is echo,

1506
00:59:41,980 --> 00:59:43,690
but even though I ran the exec

1507
00:59:43,690 --> 00:59:45,920
command exec program.

1508
00:59:45,980 --> 00:59:48,080
exec程序所做的就是调用exec系统调用，将其自身替换为echo，因此它实际上就是echo程序。
What the exec program does is calling

1509
00:59:48,080 --> 00:59:50,270
the exec system call to replace itself

1510
00:59:50,270 --> 00:59:51,680
with echo and so it was really

1511
00:59:51,680 --> 00:59:53,220
the echo program.

1512
00:59:53,320 --> 00:59:55,260
我正在制作这个输出。
I'm producing this output.

1513
00:59:58,600 --> 01:00:01,360
关于exec系统调用，对我们来说很重要的一点是，exec保留了当前的文件描述符表，所以无论在exec之前引用了什么文件描述符0、1、2等，它们在这个新程序中引用的都是相同的东西，我们已经加载了它们的指令。
And something about the exec system call,

1514
01:00:01,360 --> 01:00:03,280
that's important for us is that

1515
01:00:03,280 --> 01:00:06,310
it exec preserves the current

1516
01:00:06,310 --> 01:00:08,380
table of file descriptors,

1517
01:00:08,380 --> 01:00:10,810
so whatever file descriptor 0 1 2

1518
01:00:10,810 --> 01:00:13,240
etc, were referred to before exec,

1519
01:00:13,240 --> 01:00:17,420
they refer to the same thing in this new program

1520
01:00:17,670 --> 01:00:19,280
whose instructions we've loaded.

1521
01:00:20,220 --> 01:00:22,470
另外一点是，通常exec不会返回，因为exec完全取代了当前进程的内存，嗯，exec没有什么可以返回给exec的。
Another point is that ordinarily exec does

1522
01:00:22,470 --> 01:00:25,780
not return because exec replaces

1523
01:00:26,040 --> 01:00:28,530
the current processes memory entirely,

1524
01:00:28,530 --> 01:00:31,170
um, there's nothing for exec to return to

1525
01:00:31,170 --> 01:00:32,620
exec you know.

1526
01:00:32,990 --> 01:00:34,730
读取该文件的指令并执行它们，然后，嗯，exec唯一转到的时候是，如果发生了一些错误，导致操作系统无法为您运行该程序，例如，如果该程序根本不存在。
Read the instructions for that file and

1527
01:00:34,730 --> 01:00:36,410
execute them and then that's it,

1528
01:00:36,410 --> 01:00:38,030
um, the only time exec turns

1529
01:00:38,030 --> 01:00:40,730
is if some error occurred that

1530
01:00:40,730 --> 01:00:42,620
prevented the operating system from running

1531
01:00:42,620 --> 01:00:43,940
that program for you,

1532
01:00:43,940 --> 01:00:45,770
so for example if the program doesn't

1533
01:00:45,770 --> 01:00:47,100
exist at all.

1534
01:00:48,080 --> 01:00:50,540
EXEC找不到名为ECHO的文件，例如EXEC将返回-1。
Exec can't find a file called echo,

1535
01:00:50,540 --> 01:00:54,060
for example an exec would return -1.

1536
01:00:54,220 --> 01:00:58,670
嗯，表示出了一些错误，它找不到文件，所以普通的exec不会返回。
Um, Signal that something wrong it couldn't

1537
01:00:58,670 --> 01:00:59,960
couldn't find the file so ordinarily

1538
01:00:59,960 --> 01:01:01,460
exec does not return.

1539
01:01:01,520 --> 01:01:05,100
只有当内核不能实际为您运行该文件时，它才会返回。
It only returns if the kernel

1540
01:01:05,220 --> 01:01:06,980
couldn't actually run the file for you.

1541
01:01:10,430 --> 01:01:11,740
关于高管的问题。
Questions about exec.

1542
01:01:12,620 --> 01:01:13,640
聊天中的问题是argv中的最后一个0是什么。
The question in the chat is

1543
01:01:13,640 --> 01:01:15,320
what is the last 0 for

1544
01:01:15,320 --> 01:01:16,360
in argv.

1545
01:01:18,850 --> 01:01:21,940
它标志着数组C的结尾是如此之低，以至于，嗯，没有C数组方案。
It marks the end of the array

1546
01:01:21,940 --> 01:01:24,720
C is so low level that,

1547
01:01:25,000 --> 01:01:27,280
um, there's no

1548
01:01:27,670 --> 01:01:30,760
the C array scheme.

1549
01:01:32,340 --> 01:01:33,960
没有办法让代码找出数组的长度，所以告诉内核，嗯，你知道我们在数组中遇到的Echo，这是Echo，仅此而已。
Doesn't have a way for

1550
01:01:34,650 --> 01:01:35,850
code to find out how long

1551
01:01:35,850 --> 01:01:37,830
the array is and so

1552
01:01:37,830 --> 01:01:39,400
tell the kernel that,

1553
01:01:39,570 --> 01:01:43,490
um, you know we met at the array contains echo,

1554
01:01:43,490 --> 01:01:46,300
this is echo and nothing more.

1555
01:01:46,560 --> 01:01:49,940
我们把0作为最后一个指针放在最后一个条带上。这些双引号中的每个字符串实际上都是指向包含这些字节的某些内存的指针。
We put zero was the last strip as the last

1556
01:01:50,030 --> 01:01:52,670
pointer. Each of those strings in double quotes

1557
01:01:52,670 --> 01:01:54,920
is actually a pointer to some memory

1558
01:01:54,920 --> 01:01:56,440
that contains those bytes.

1559
01:01:56,720 --> 01:01:58,760
数组的第五个元素是指针值为0，惯例是指针值为0的指针或所谓的空指针。
That fifth element of the array is

1560
01:01:58,760 --> 01:02:00,500
a pointer's value is 0,

1561
01:02:00,500 --> 01:02:02,270
the convention is that a pointer

1562
01:02:02,270 --> 01:02:04,010
whose value is 0 or what's

1563
01:02:04,010 --> 01:02:05,500
called a null pointer.

1564
01:02:05,590 --> 01:02:09,600
嗯，这没什么意义，嗯，有了它。
Um, sort of signifies nothing,

1565
01:02:09,600 --> 01:02:10,980
Um, with it.

1566
01:02:11,620 --> 01:02:13,600
您已经离开了，所以内核中的代码实际上已经遍历了这个数组，直到找到它为止。
You were gone,

1567
01:02:13,600 --> 01:02:14,920
so the code in the kernel

1568
01:02:14,920 --> 01:02:16,570
has actually walks through this array

1569
01:02:16,570 --> 01:02:17,680
until it finds it.

1570
01:02:18,090 --> 01:02:20,240
值为零的元素。
Element whose value is zero.

1571
01:02:24,690 --> 01:02:26,520
好的，嗯，好的，这就是程序如何自我替换。
Okay, um,

1572
01:02:26,520 --> 01:02:27,420
all right,

1573
01:02:27,420 --> 01:02:29,780
so this is how a program can replace itself.

1574
01:02:30,800 --> 01:02:32,090
使用文件中的另一个程序，但实际上当我们在shell中运行诸如‘echo abc’、um或ls或其他任何东西时，我们不想替换shell，我们没有shell，只需调用exec即可。
With another program from a file,

1575
01:02:32,090 --> 01:02:33,350
but actually when we run stuff in

1576
01:02:33,350 --> 01:02:35,510
the shell like 'echo abc',

1577
01:02:35,510 --> 01:02:38,900
um or ls or anything else,

1578
01:02:38,900 --> 01:02:40,400
we don't want to replace the shell,

1579
01:02:40,400 --> 01:02:41,570
we don't have a shell,

1580
01:02:41,570 --> 01:02:43,000
just call exec.

1581
01:02:43,420 --> 01:02:44,500
嗯，因为这会用echo命令替换shell，然后echo退出。
Um, because,

1582
01:02:44,500 --> 01:02:45,850
that would replace the shell with the

1583
01:02:45,850 --> 01:02:48,240
echo command then echo exited.

1584
01:02:48,320 --> 01:02:50,360
那就结束了，你知道我们不想要回声来代替贝壳，所以贝壳实际上是分叉的。
That would be end, you know

1585
01:02:50,360 --> 01:02:51,110
we don't want an echo to

1586
01:02:51,110 --> 01:02:52,040
replace the shell,

1587
01:02:52,040 --> 01:02:54,660
so the shell actually does is fork.

1588
01:02:54,940 --> 01:02:56,740
然后孩子调用exec，这是一个非常常见的Unix惯用程序。
And then the child calls exec

1589
01:02:56,740 --> 01:02:59,440
and that's an extremely common unix

1590
01:02:59,440 --> 01:03:01,540
idiom program instead.

1591
01:03:01,600 --> 01:03:03,520
嗯，想要运行一个程序，但是重新获得控制权，他们所做的就是叫fork，让孩子叫exec。
Um, want to run a program,

1592
01:03:03,520 --> 01:03:05,020
but regain control what they do

1593
01:03:05,020 --> 01:03:06,460
is call fork and have the

1594
01:03:06,460 --> 01:03:07,880
child called exec.

1595
01:03:08,000 --> 01:03:10,520
这里有一个简单的例子，这个forkexec程序。
So here's a simple example,

1596
01:03:10,520 --> 01:03:12,400
this forkexec program.

1597
01:03:14,310 --> 01:03:17,580
在这个程序中，调用fork行12，在子行14中，我们调用exec，与前面非常相似。
In this program call fork line 12

1598
01:03:17,580 --> 01:03:19,350
in the child sort of line 14

1599
01:03:19,350 --> 01:03:21,330
we call exec much like before.

1600
01:03:21,330 --> 01:03:22,940
子进程，嗯，必须用echo命令替换它自己。
The child process,

1601
01:03:23,380 --> 01:03:28,060
um, has to replace itself with the echo command.

1602
01:03:28,220 --> 01:03:29,090
嗯，Echo，做完这件事，然后退出。
Um, echo,

1603
01:03:29,090 --> 01:03:31,220
does this thing and then exits.

1604
01:03:31,680 --> 01:03:32,760
然后父进程重新获得控制权，因为嗯，当fork返回时。
And then the parent process,

1605
01:03:32,760 --> 01:03:37,360
regains control because um when fork returns.

1606
01:03:38,000 --> 01:03:39,860
父进程中的值大于零值，所以父进程在19继续执行，Unix提供一个等待系统调用行24的进程来等待用fork创建的子进程，因为当我在命令行上运行命令时。
Greater than zero value in the parent process,

1607
01:03:39,860 --> 01:03:41,330
so the parent process then continues to

1608
01:03:41,330 --> 01:03:43,760
execute at 19 and unix provides a

1609
01:03:43,760 --> 01:03:47,390
wait system call line 24 process to

1610
01:03:47,390 --> 01:03:50,180
wait for child that created

1611
01:03:50,180 --> 01:03:52,310
with fork, because when I run a

1612
01:03:52,310 --> 01:03:55,600
command on the command line.

1613
01:03:56,330 --> 01:04:00,020
我们希望shell在再次打印提示符之前等待命令完成，然后再打印$PROMPT，要求我输入更多信息。
We want shell to wait for the

1614
01:04:00,020 --> 01:04:02,210
command to finish before it prints the

1615
01:04:02,210 --> 01:04:04,310
prompt again, before it prints is $

1616
01:04:04,310 --> 01:04:06,620
prompt asking me for more input.

1617
01:04:06,730 --> 01:04:09,190
所以，等待系统调用允许进程等待它的任何子代返回，这个状态参数是，嗯，退出子代的一种方式，将一个整数32位值，从退出的子代传递给第17行上等待的父代，退出的参数是1，这是退出的参数。，。
So it's the wait system call allows

1618
01:04:09,190 --> 01:04:10,720
a process to wait for any of

1619
01:04:10,720 --> 01:04:13,390
its children to return and this status

1620
01:04:13,390 --> 01:04:15,400
argument is that, um,

1621
01:04:15,590 --> 01:04:17,080
a way for

1622
01:04:17,950 --> 01:04:22,450
exiting child to communicate one integer

1623
01:04:22,450 --> 01:04:25,900
32 bit value from the exiting child

1624
01:04:25,900 --> 01:04:28,330
to the waiting parents on line 17 that

1625
01:04:28,330 --> 01:04:30,700
argument to exit that 1 that's the

1626
01:04:30,700 --> 01:04:32,000
argument to exit.

1627
01:04:32,060 --> 01:04:35,750
操作系统将其从退出的子级传递给等待行20的调用，因此等待&WAIT将状态变量的地址传递给内核，内核用，嗯，Child的参数填充该地址以退出。
The operating system passes that one from

1628
01:04:35,750 --> 01:04:37,340
the exiting child

1629
01:04:37,460 --> 01:04:39,200
to the call to wait line

1630
01:04:39,200 --> 01:04:42,460
20 so wait the & wait,

1631
01:04:42,700 --> 01:04:44,350
is passing the address of the

1632
01:04:44,350 --> 01:04:46,720
status variable to the kernel,

1633
01:04:46,720 --> 01:04:49,400
the kernel fills in that address with,

1634
01:04:49,720 --> 01:04:51,800
um, child's argument to exit.

1635
01:04:52,770 --> 01:04:54,690
Unix中的约定是，如果程序成功完成，退出时状态为0。
And the convention in unix is that

1636
01:04:54,690 --> 01:04:58,560
if a program completes successfully exit exits

1637
01:04:58,560 --> 01:05:00,120
with status 0.

1638
01:05:00,430 --> 01:05:04,200
嗯，但是它在第17行遇到了一个错误。
Um, but it has encountered an error at line 17.

1639
01:05:04,280 --> 01:05:06,800
嗯，Unix的惯例是您传递1来退出，所以如果您在意的话，调用进程可以查看WAIT的状态。
Um, the unix convention is that you

1640
01:05:06,800 --> 01:05:08,810
pass 1 to exit and so if

1641
01:05:08,810 --> 01:05:10,940
you care the calling process can look

1642
01:05:10,940 --> 01:05:13,180
at the status from wait.

1643
01:05:13,240 --> 01:05:14,700
确定孩子是否成功完成。莫里斯教授的一个快速问题。
Decide whether the

1644
01:05:15,270 --> 01:05:19,080
child completed successfully. A professor

1645
01:05:19,080 --> 01:05:20,400
Morris quick question.

1646
01:05:20,560 --> 01:05:25,090
对，关于exec call 19，嗯，我们刚才提到，exec将完全进入echo程序，不会返回fork exec。
Yes, about the exec call 19, um,

1647
01:05:25,090 --> 01:05:27,280
we mentioned not a bit ago that

1648
01:05:27,280 --> 01:05:29,890
exec will completely go into the echo

1649
01:05:29,890 --> 01:05:32,660
program and not return to fork exec.

1650
01:05:33,060 --> 01:05:33,930
嗯，所以，哦，会不会到16号线和17号线。
Um, so,

1651
01:05:33,930 --> 01:05:37,260
oh, would ever reach line 16 and 17.

1652
01:05:38,170 --> 01:05:41,490
不适用于这段EXEC代码，因为恰好有一个名为ECHO的程序，但是如果我在这里修改该代码，让我只修改这段代码。
Well, not for this exec code because there

1653
01:05:41,490 --> 01:05:44,130
happens to be a program called echo,

1654
01:05:44,130 --> 01:05:46,560
but if I modify that code here,

1655
01:05:46,560 --> 01:05:49,470
let me just modify this code.

1656
01:05:49,470 --> 01:05:50,550
好的，那么首先让我运行一下forkexec。
Okay, so first let me just

1657
01:05:50,550 --> 01:05:51,820
run forkexec.

1658
01:05:53,590 --> 01:05:56,290
它实际上使用我们看到的输出“this is echo”这些参数执行echo，并且我们看到子级退出，以显示ECHO成功退出，父级在等待。让我为您修改一下程序。
It actually does execute echo with those

1659
01:05:56,290 --> 01:05:57,580
arguments we see the output,

1660
01:05:57,580 --> 01:05:59,650
"this is echo" and we see

1661
01:05:59,650 --> 01:06:02,280
the child exited to show that

1662
01:06:02,900 --> 01:06:05,840
echo exited successfully and the parent wait

1663
01:06:05,840 --> 01:06:07,180
for. Let me just

1664
01:06:07,370 --> 01:06:09,080
modify the program for you.

1665
01:06:09,630 --> 01:06:12,150
嗯，而不是ECHO要运行一些不存在的命令。
Um, instead of echo going to run some

1666
01:06:12,150 --> 01:06:13,580
command that doesn't exist.

1667
01:06:14,180 --> 01:06:15,660
嗯，嗯，实际上是QEMU的出口。用‘Ctrl-ax’，然后重新编译整个东西，以便重新编译，我修改了。
Um, um,

1668
01:06:15,660 --> 01:06:18,240
actually the exit out of

1669
01:06:18,240 --> 01:06:21,520
QEMU. With 'Ctrl-a x' and then rebuild

1670
01:06:21,520 --> 01:06:23,700
the whole thing in order to re-compile

1671
01:06:23,920 --> 01:06:25,380
I modified.

1672
01:06:25,850 --> 01:06:27,650
Forkexec现在修改后再次运行forkexec。
Forkexec now run forkexec back again

1673
01:06:27,650 --> 01:06:29,500
after modifying it.

1674
01:06:29,800 --> 01:06:31,060
这一次，因为我们要求执行的程序，嗯，实际上，我们要求执行的程序不存在，EXEC确实返回了，我们看到EXEC失败的输出。
And this time because the program

1675
01:06:31,060 --> 01:06:32,280
we're asking to,

1676
01:06:32,760 --> 01:06:34,220
um, actually,

1677
01:06:36,600 --> 01:06:37,080
the program,

1678
01:06:37,080 --> 01:06:39,600
we're asking to execute doesn't exist,

1679
01:06:39,600 --> 01:06:43,560
exec does return we see the exec failed output.

1680
01:06:43,840 --> 01:06:46,180
嗯，出口1，你会看到那里的1被传回给家长，说孩子退出了状态。
Um, and the exit 1 you'll see

1681
01:06:46,180 --> 01:06:47,770
the 1 there is communicated back

1682
01:06:47,770 --> 01:06:48,880
to the parent which says the

1683
01:06:48,880 --> 01:06:50,760
child exited the status 1.

1684
01:06:52,280 --> 01:06:55,610
因此，当出现错误时，exec返回到调用函数。
So exec returns back to the calling

1685
01:06:55,610 --> 01:06:57,680
function when something went wrong.

1686
01:06:57,740 --> 01:07:01,700
是。嗯。
Yes. Yeah.

1687
01:07:08,700 --> 01:07:11,040
好的很好。
Okay good.

1688
01:07:14,680 --> 01:07:15,220
好的，嗯，这里要注意的是，实际上你们中的许多人已经注意到了。
All right,

1689
01:07:15,220 --> 01:07:17,710
um, something that going to note

1690
01:07:17,710 --> 01:07:19,540
here that actually think many of you

1691
01:07:19,540 --> 01:07:21,240
already noted is that.

1692
01:07:21,300 --> 01:07:23,430
这在这里是一个常见的习惯用法，这个派生后面紧跟着子进程中的exec，派生复制整个父进程可能有点浪费。
It is a common idiom here,

1693
01:07:23,430 --> 01:07:25,440
this fork followed by exec in the

1694
01:07:25,440 --> 01:07:28,710
child and it's potentially a bit wasteful

1695
01:07:28,710 --> 01:07:32,080
the fork copies the entire parent process.

1696
01:07:32,320 --> 01:07:34,840
但是exec会丢弃所有复制的内存，并将其替换为，嗯，您正在运行的文件中的任何内容，所以您知道您是否担心这种东西，即分支所暗示的副本。
But exec throws away all that copied

1697
01:07:34,840 --> 01:07:36,910
memory and replaces it with,

1698
01:07:36,910 --> 01:07:38,860
whatever is in the, um,

1699
01:07:39,670 --> 01:07:40,990
a file that you're running,

1700
01:07:40,990 --> 01:07:43,630
so you know if you're worried about

1701
01:07:43,630 --> 01:07:44,320
this kind of stuff,

1702
01:07:44,320 --> 01:07:47,580
the copy implied by the fork.

1703
01:07:48,160 --> 01:07:50,380
在某种意义上大部分是浪费的，因为所有复制的内存都被丢弃，并由EXEC替换。
Is in some sense mostly wasted because

1704
01:07:50,380 --> 01:07:52,210
all that copied memory is just thrown

1705
01:07:52,210 --> 01:07:54,320
away and replaced by the exec.

1706
01:07:55,270 --> 01:07:57,220
如果你有一个调用fork的几千兆字节的程序，这实际上对大程序的影响是很大的。
And this affects actually would be significant

1707
01:07:57,220 --> 01:07:57,940
for big programs,

1708
01:07:57,940 --> 01:07:59,830
if you have a multi gigabyte program

1709
01:07:59,830 --> 01:08:01,000
that calls fork.

1710
01:08:01,050 --> 01:08:02,880
嗯，而且它确实复制了所有的内存，实际上可能只需要不到一秒钟的时间来复制。
Um, and it did indeed copy all

1711
01:08:02,880 --> 01:08:04,380
the memory would actually take a

1712
01:08:04,380 --> 01:08:06,510
fair fraction of a second perhaps

1713
01:08:06,510 --> 01:08:07,620
to do the copy.

1714
01:08:07,740 --> 01:08:09,560
嗯，这可能是个问题。
Um, which could be a problem.

1715
01:08:10,080 --> 01:08:13,180
嗯，嗯，但是在本课程的后面，您将实际实现一些优化，特别是所谓的写入时复制派生，它将消除几乎所有明显的低效派生复制，只会让exec丢弃该副本。
Um, um,

1716
01:08:13,180 --> 01:08:15,850
but later in the course you'll actually

1717
01:08:15,850 --> 01:08:18,370
implement some optimization in particular something called

1718
01:08:18,370 --> 01:08:21,610
copy-on-write fork which will eliminate

1719
01:08:21,610 --> 01:08:25,360
almost all of the apparent inefficiency

1720
01:08:25,360 --> 01:08:27,820
of fork copying only to have exec

1721
01:08:27,820 --> 01:08:29,120
throw away the copy.

1722
01:08:29,180 --> 01:08:30,080
事实证明，它使用了一系列涉及虚拟内存系统的技巧。
It turns out with a bunch of

1723
01:08:30,080 --> 01:08:32,760
tricks involving a virtual memory system.

1724
01:08:32,920 --> 01:08:35,050
嗯，你可以构建一个分支，这对于拷贝来说是懒惰的，在通常的情况下，分支后面紧跟着exec，不会这样做。
Um, you can build a fork,

1725
01:08:35,050 --> 01:08:37,150
that's lazy about the copy and that

1726
01:08:37,150 --> 01:08:39,520
doesn't do in the common case of

1727
01:08:39,520 --> 01:08:41,320
fork immediately followed by exec.

1728
01:08:41,420 --> 01:08:42,800
嗯，或者你实际上不需要复印，因为孩子实际上并没有使用大部分的内存。
Um, or you don't actually have to do

1729
01:08:42,800 --> 01:08:44,630
the copy because the child doesn't actually

1730
01:08:44,630 --> 01:08:46,060
use most of the memory.

1731
01:08:46,900 --> 01:08:49,510
嗯，我想你会发现那是个有趣的实验室。聊天中的问题，为什么父进程父进程在子进程调用EXEC之前完全等待。
Um, I think you'll find that's a fun

1732
01:08:49,510 --> 01:08:52,510
and interesting lab. Question from chat,

1733
01:08:52,510 --> 01:08:55,360
why does the parent process parent waiting

1734
01:08:55,360 --> 01:08:58,140
completely before the child calls exec.

1735
01:08:59,240 --> 01:09:03,000
嗯。这只是偶然。
Yeah. It's just chance.

1736
01:09:03,820 --> 01:09:09,970
嗯，为什么你知道观察结果是，嗯，你知道。
Um, why is it that you know the observation is that,

1737
01:09:09,970 --> 01:09:12,060
um, you know.

1738
01:09:13,130 --> 01:09:15,290
嗯，可能是父母的输出和孩子的输出可以交错在我们以前看到的类似叉子例子的同一个区域，嗯，只是不能保证这就是输出，我们会看到实际上我们，我们看到输出的行是另一种顺序或者交错的，我们应该不会感到惊讶。
Um, it could be that the parents output

1739
01:09:15,290 --> 01:09:17,540
could be interleaved with the child's output

1740
01:09:17,540 --> 01:09:18,530
in the same area that we saw

1741
01:09:18,530 --> 01:09:21,410
before with similar fork example,

1742
01:09:21,410 --> 01:09:23,780
um, it just happens not to be there's

1743
01:09:23,780 --> 01:09:25,700
no guarantee that this is the output,

1744
01:09:25,700 --> 01:09:27,800
we would see in fact we,

1745
01:09:28,070 --> 01:09:29,690
we shouldn't be surprised if we saw

1746
01:09:29,690 --> 01:09:30,770
the lines of the output in the

1747
01:09:30,770 --> 01:09:33,240
other order or interleaved.

1748
01:09:33,620 --> 01:09:35,960
我怀疑到底是怎么回事，这需要一点时间和精力。
I suspect what's going on, is

1749
01:09:35,960 --> 01:09:37,940
that it takes a bit of

1750
01:09:37,940 --> 01:09:39,240
time and effort.

1751
01:09:39,770 --> 01:09:41,240
exec系统造成了一些开销，因为它必须加载所有需要访问文件系统和磁盘的内容，并在分配了一些内存之后，将名为echo的文件的内容从磁盘读取到内存中，而且即使在从旧进程中释放了一些内存之后，exec系统调用也需要相当多的机器，嗯。显然，这需要足够长的时间，父母才能完成输出。
The exec system caused a little bit

1752
01:09:41,240 --> 01:09:43,370
expensive, because it has to load all

1753
01:09:43,370 --> 01:09:45,560
those you have to access the file

1754
01:09:45,560 --> 01:09:47,240
system and access the disk and read

1755
01:09:47,240 --> 01:09:49,010
the contents of a file called echo

1756
01:09:49,010 --> 01:09:51,050
off the disk into memory,

1757
01:09:51,050 --> 01:09:53,330
after allocating some memory and

1758
01:09:53,330 --> 01:09:55,040
that even after freeing some memory

1759
01:09:55,040 --> 01:09:56,870
from the old process so there's

1760
01:09:56,870 --> 01:09:58,220
quite a bit of machinery involved

1761
01:09:58,220 --> 01:09:59,840
in the exec system call,

1762
01:09:59,840 --> 01:10:03,500
um. And apparently that takes long enough that

1763
01:10:03,500 --> 01:10:06,500
the parent can complete producing the output.

1764
01:10:06,580 --> 01:10:08,440
在EXEC完成并开始运行ECHO之前。
Before the exec is finished and

1765
01:10:08,440 --> 01:10:09,680
started running echo.

1766
01:10:10,400 --> 01:10:11,960
这有意义吗。
Does that make sense.

1767
01:10:15,360 --> 01:10:17,370
另一个问题是孩子不能等父母的习俗。
Another question is a convention that the

1768
01:10:17,370 --> 01:10:19,560
child can't wait for the parent.

1769
01:10:21,520 --> 01:10:25,420
Unix不可能没有办法满足孩子们的需求。
There's not a way unix doesn't have

1770
01:10:25,420 --> 01:10:27,160
a way for the child.

1771
01:10:28,220 --> 01:10:30,290
对于孩子来说，没有直接的方式等待父母的到来。
There's no straightforward way for a child to wait

1772
01:10:30,290 --> 01:10:31,140
from a parent.

1773
01:10:31,930 --> 01:10:33,860
等待系统调用。
The wait system call.

1774
01:10:34,680 --> 01:10:37,080
因为这是唯一可用的机制，所以等待系统调用会等待您的孩子。
Because it's the only mechanism available

1775
01:10:37,080 --> 01:10:40,170
well the wait system call waits

1776
01:10:40,170 --> 01:10:41,420
for your children.

1777
01:10:41,880 --> 01:10:42,700
就这样了。
And that's it.

1778
01:10:43,620 --> 01:10:46,350
所以等待所做的就是，嗯，如果你有孩子的话。
And so what wait what wait does is,

1779
01:10:46,350 --> 01:10:48,980
um, if you have any children.

1780
01:10:49,080 --> 01:10:52,440
他们中的一个已经离开了正在退出的地方。
And one of them has already exited what does exit.

1781
01:10:52,740 --> 01:10:54,720
然后我们会回来，但是你知道，如果你没有孩子，那就说，因为你有。
Then we will return but you know

1782
01:10:54,720 --> 01:10:56,070
if you don't have any children say,

1783
01:10:56,070 --> 01:10:57,300
because you are.

1784
01:10:57,360 --> 01:11:00,720
因为在这个简单的情况下，嗯。如果孩子打电话给WAIT，那就只有父母和孩子了。
Because in this simple case,

1785
01:11:00,720 --> 01:11:03,950
um. It was just a parent and child

1786
01:11:03,950 --> 01:11:05,660
if the child called wait.

1787
01:11:06,890 --> 01:11:08,780
该子进程没有任何子级，在这种情况下，WAIT只是立即返回，并返回-1错误，说明该进程没有任何子级。
The child doesn't have any children and

1788
01:11:08,780 --> 01:11:09,200
in that case,

1789
01:11:09,200 --> 01:11:11,090
wait just returns immediately with a -1

1790
01:11:11,090 --> 01:11:13,910
error return saying this process doesn't

1791
01:11:13,910 --> 01:11:14,740
have any children.

1792
01:11:15,440 --> 01:11:17,450
无论如何，简短的答案是，孩子没有办法等待它的父母离开。
Anyway, the short answer is there's no way

1793
01:11:17,450 --> 01:11:19,280
for a child to wait for its

1794
01:11:19,280 --> 01:11:20,400
parent to exit.

1795
01:11:21,930 --> 01:11:23,310
另一个问题是，当我们说孩子复制了父进程的所有内存时，我们到底指的是什么，我认为孩子会再次定义变量。
And another question when we say

1796
01:11:23,310 --> 01:11:25,770
the child copies all the memory

1797
01:11:25,770 --> 01:11:26,820
from the parent process,

1798
01:11:26,820 --> 01:11:28,980
what exactly do we refer to by

1799
01:11:28,980 --> 01:11:30,870
that I thought the child is going

1800
01:11:30,870 --> 01:11:33,260
to define the variables again.

1801
01:11:37,570 --> 01:11:40,250
嗯，或者当你编辑这个的时候，你知道，嗯。编译后，您的C程序。
Um, or when you compile this,

1802
01:11:40,250 --> 01:11:40,880
you know,

1803
01:11:40,880 --> 01:11:47,060
um. After compilation,

1804
01:11:47,060 --> 01:11:49,020
your C program.

1805
01:11:49,220 --> 01:11:50,450
它只是内存中的一堆指令，它们驻留在RAM中。
It's just a bunch of instructions in

1806
01:11:50,450 --> 01:11:52,720
memory that live in ram.

1807
01:11:53,430 --> 01:11:57,000
嗯，所以那些是可以复制的。
Um, and so those can be copied.

1808
01:11:57,360 --> 01:11:58,920
因为它们只是存在于RAM中的字节，可以复制到其他地方，嗯。以及与设置有关的适当技巧。
Because they're just bytes living in ram,

1809
01:11:58,920 --> 01:12:01,170
those can be copied somewhere else,

1810
01:12:01,170 --> 01:12:04,380
um. And with appropriate trick having to do

1811
01:12:04,380 --> 01:12:05,620
with setting up.

1812
01:12:06,500 --> 01:12:08,930
一种虚拟内存映射，并使子进程和父进程中的映射看起来是一样的，您只需将父进程的内存映像复制到子进程并执行子进程即可。
A sort of virtual memory mapping's and

1813
01:12:08,930 --> 01:12:10,970
make map things look the same in

1814
01:12:10,970 --> 01:12:12,110
the child and the parent you can

1815
01:12:12,110 --> 01:12:14,270
just copy the parent's memory image to

1816
01:12:14,270 --> 01:12:15,780
the child and

1817
01:12:16,360 --> 01:12:17,760
executing the child.

1818
01:12:20,660 --> 01:12:22,310
即使我们在看C程序，你也应该把它们看作是一堆机器指令。
And even though we're looking at C programs,

1819
01:12:22,310 --> 01:12:23,360
you should think of them as just

1820
01:12:23,360 --> 01:12:25,820
a bunch of machine instructions.

1821
01:12:26,920 --> 01:12:29,480
嗯，这是内存中可以复制的字节。
Um, which is bytes in memory that can be copied.

1822
01:12:31,280 --> 01:12:32,660
如果父级有多个子级，只要等第一个子级完成就返回，这意味着可能会有更多与父级和未完成的子级交织在一起，他们需要多种不同的方式来确保所有子级都完成。
If a parent has multiple

1823
01:12:32,660 --> 01:12:34,460
children would wait just return

1824
01:12:34,460 --> 01:12:35,270
as soon as the first

1825
01:12:35,270 --> 01:12:36,860
child finishes meaning that there

1826
01:12:36,860 --> 01:12:38,300
could be some more interleaving

1827
01:12:38,300 --> 01:12:39,470
with the parent and unfinished

1828
01:12:39,470 --> 01:12:40,850
children with their need to

1829
01:12:40,850 --> 01:12:42,290
be multiple separate ways to

1830
01:12:42,290 --> 01:12:44,100
ensure all children finished.

1831
01:12:44,340 --> 01:12:45,480
是的，如果您调用一个以上的fork(如果给定的进程调用两次)。
Yes, yeah,

1832
01:12:45,480 --> 01:12:47,250
if you call fork more than one

1833
01:12:47,250 --> 01:12:50,820
if a given process calls for twice.

1834
01:12:51,360 --> 01:12:54,450
嗯，那两个孩子都要等，每个电话要等两次。
Um, then it wants to wait for both

1835
01:12:54,450 --> 01:12:56,850
children and has to call wait twice

1836
01:12:56,850 --> 01:12:58,140
each call to wait.

1837
01:12:58,280 --> 01:13:00,500
当等待返回时，您不一定知道退出的是哪个子进程，权重将返回子进程的进程id作为返回值，这样您就可以知道了。
Will return as soon as one of

1838
01:13:00,500 --> 01:13:02,450
the children exits you don't when wait

1839
01:13:02,450 --> 01:13:05,210
returns you don't necessarily know which child

1840
01:13:05,210 --> 01:13:08,060
is exited the weight returns the child's

1841
01:13:08,060 --> 01:13:09,920
process id as its return value so

1842
01:13:09,920 --> 01:13:11,060
you can tell.

1843
01:13:11,420 --> 01:13:13,670
等我们回来后，你就知道是在哪一个出口了。
After we returns you know which one

1844
01:13:13,670 --> 01:13:14,740
it was at exit.

1845
01:13:19,030 --> 01:13:23,980
嗯，最后举一个例子，嗯。我想给大家展示一下，嗯，这些设施是怎么结合的，嗯。来实现IO方向，所以如果您还记得，嗯，shell为我们提供了这个方便的语法，我可以说‘echo hello>out’。
Um, as a final example,

1846
01:13:23,980 --> 01:13:27,520
um. I'd like to show,

1847
01:13:28,080 --> 01:13:32,520
um, how all these facilities combine,

1848
01:13:32,520 --> 01:13:37,460
um. To implement IO direction,

1849
01:13:37,460 --> 01:13:38,960
so if you remember,

1850
01:13:38,960 --> 01:13:40,670
um, the shell provides us with this

1851
01:13:40,670 --> 01:13:43,010
handy syntax I can say

1852
01:13:43,010 --> 01:13:44,500
'echo hello >  out'.

1853
01:13:44,830 --> 01:13:47,080
嗯，这就运行了回显命令，这个参数发送它。
Um, that runs the echo command that

1854
01:13:47,080 --> 01:13:48,800
argument sending it.

1855
01:13:48,800 --> 01:13:51,200
首先，嗯，这会把它的输出发送到文件中，然后向外看。
First, um, that sends its output to the

1856
01:13:51,200 --> 01:13:52,980
file out and looked out.

1857
01:13:53,120 --> 01:13:54,480
或者现在还没有。
Or yet.

1858
01:13:55,340 --> 01:13:57,260
嗯，在cat上，在其输入从out文件连接的情况下，我们可以看到echo命令保存的输出。
Um, on the cat and with its

1859
01:13:57,260 --> 01:14:01,250
input connected from the out file,

1860
01:14:01,250 --> 01:14:02,960
we can see that saved output from

1861
01:14:02,960 --> 01:14:04,080
the echo command.

1862
01:14:04,980 --> 01:14:08,060
嗯，贝壳设置的方式。
Um, the way the shell sets this up.

1863
01:14:08,840 --> 01:14:10,070
这个是，嗯，如下所示。
Um is,

1864
01:14:10,070 --> 01:14:11,860
um, as follows.

1865
01:14:13,390 --> 01:14:19,160
恩。如果shell首先像第13行那样分叉，然后在子程序中，shell更改文件描述符的设置方式，以致子程序的文件描述符1，按照惯例大多数程序都用于输出，嗯。这个shell a将子shell的文件描述符更改为1以引用此输出文件，然后运行您想要的任何命令，这会使父shell文件描述符1保持不变，因此这种派生和在子shell中围绕文件描述符进行更改的习惯用法。
Um. It a shell first forks like on

1866
01:14:19,160 --> 01:14:22,160
line 13 and then in the child,

1867
01:14:22,160 --> 01:14:24,260
the shell changes the way the file

1868
01:14:24,260 --> 01:14:25,940
descriptors are set up so that the

1869
01:14:25,940 --> 01:14:27,950
child's file descriptor

1870
01:14:27,950 --> 01:14:28,980
1 which

1871
01:14:29,200 --> 01:14:32,350
by convention most programs used for the output,

1872
01:14:32,350 --> 01:14:36,260
um. This shell a changes the child's

1873
01:14:36,260 --> 01:14:38,300
file descriptor to 1 to refer

1874
01:14:38,300 --> 01:14:40,430
to this output file,

1875
01:14:40,430 --> 01:14:42,590
and then run whatever commands you wanted

1876
01:14:42,590 --> 01:14:45,470
and that leaves the parent shells file

1877
01:14:45,470 --> 01:14:48,950
descriptor 1 unchanged so this idiom of

1878
01:14:48,950 --> 01:14:51,590
forking and in a child, changing

1879
01:14:51,590 --> 01:14:53,260
around the file descriptors.

1880
01:14:53,360 --> 01:14:57,360
Unix通常会将您运行的命令的输入和输出重定向，但不会影响调用程序的输入和输出，因为我们不想重定向shell的输出。
Um, is the usual way unix actually redirect

1881
01:14:57,460 --> 01:14:59,320
input an output for a command

1882
01:14:59,320 --> 01:15:01,090
that you run but not affect

1883
01:15:01,090 --> 01:15:03,370
the input and output for a

1884
01:15:03,370 --> 01:15:04,900
calling program because we don't want

1885
01:15:04,900 --> 01:15:06,720
to redirect the shell's output.

1886
01:15:07,150 --> 01:15:10,120
嗯，我们只想重定向子程序的输出。
Um, we only want to redirect the

1887
01:15:10,120 --> 01:15:11,760
child programs output.

1888
01:15:12,670 --> 01:15:15,730
不管怎样，这种工作方式我们称之为fork不寻常的方式，第15行只在子级中执行。
Anyway, the way this works we call fork unusual way,

1889
01:15:15,730 --> 01:15:18,720
a line 15 only executes in the child.

1890
01:15:18,860 --> 01:15:20,480
第15行上关闭1的原因是在此程序中。
The reason for the close 1 on

1891
01:15:20,480 --> 01:15:23,200
line 15 is that in this program.

1892
01:15:23,590 --> 01:15:25,810
我们重定向的只是echo命令的输出，所以当我运行这个重定向时。
We're redirecting a just the output of

1893
01:15:25,810 --> 01:15:26,530
the echo command,

1894
01:15:26,530 --> 01:15:28,360
so when I run this redirect.

1895
01:15:28,640 --> 01:15:31,520
程序本身不会产生输出，它会将其输出直接运行到“output.txt”。
A program produces no output itself,

1896
01:15:31,520 --> 01:15:33,410
it ran echo with its output directly

1897
01:15:33,410 --> 01:15:35,380
to "output.txt".

1898
01:15:35,540 --> 01:15:38,900
所以当我看到“output.txt”时，嗯。我看到了这个预期的输出，也就是第15行关闭1的原因。
So when I look at "output.txt",

1899
01:15:38,900 --> 01:15:41,750
um. I see this expected output,

1900
01:15:41,750 --> 01:15:44,540
the reason for the close 1 on line 15.

1901
01:15:44,900 --> 01:15:47,960
我们希望1作为一种常规的输出文件脚本来引用其他内容，所以我们没有子级，我们不想使用shell中连接到控制台的父描述符1。
Is that we want 1 as

1902
01:15:47,960 --> 01:15:50,180
a sort of conventional output file script

1903
01:15:50,180 --> 01:15:52,010
to refer to something else,

1904
01:15:52,010 --> 01:15:54,650
it happens so we don't have a child,

1905
01:15:54,650 --> 01:15:56,360
we don't want to use the father descriptor

1906
01:15:56,360 --> 01:15:58,070
1 that the shell had that's connected

1907
01:15:58,070 --> 01:15:59,300
to the console.

1908
01:15:59,660 --> 01:16:01,160
嗯，第16行上对open的调用保证返回1，因为open的语义是open返回最低的文件描述符编号，因为我们刚刚关闭了1，所以调用过程中当前没有使用这个编号。
Um the call to open on line

1909
01:16:01,160 --> 01:16:04,400
16 is guaranteed to return 1 because,

1910
01:16:04,400 --> 01:16:06,380
um the semantics of open are that

1911
01:16:06,380 --> 01:16:08,140
open returns the lowest

1912
01:16:08,410 --> 01:16:09,490
file descriptor number,

1913
01:16:09,490 --> 01:16:12,430
that's not currently in use in the

1914
01:16:12,430 --> 01:16:15,260
calling process since we just closed 1.

1915
01:16:15,420 --> 01:16:18,990
我的意思是，文件描述符0仍然连接到控制台。
And file descriptor 0 is still connected

1916
01:16:18,990 --> 01:16:19,590
to the console,

1917
01:16:19,590 --> 01:16:20,400
I mean.

1918
01:16:20,460 --> 01:16:23,440
我是开放的，保证返回1。
I'm open is guaranteed to return 1.

1919
01:16:24,290 --> 01:16:27,560
因此，在第16行文件描述符1连接到该文件之后。
So after the line 16 file descriptor

1920
01:16:27,560 --> 01:16:29,880
1 is connected to this file.

1921
01:16:30,220 --> 01:16:32,890
当我们执行ECHO时，ECHO只是写入它的输出，文件描述符1，现在转到这个文件，最酷的是，ECHO不知道发生了什么，ECHO根本不需要知道IO方向，它只写入它的输出，文件描述符1。
When we exec echo, echo just writes its output,

1922
01:16:32,890 --> 01:16:35,020
the file descriptor 1 and now go

1923
01:16:35,020 --> 01:16:36,340
to this file and the cool thing

1924
01:16:36,340 --> 01:16:37,720
about this is echo had no idea

1925
01:16:37,720 --> 01:16:39,580
what's going on, echo doesn't need to

1926
01:16:39,580 --> 01:16:41,650
know about IO direction at all,

1927
01:16:41,650 --> 01:16:43,000
it just writes its output,

1928
01:16:43,000 --> 01:16:44,400
the file descriptor 1.

1929
01:16:45,160 --> 01:16:47,590
我是唯一知道IO重定向的外壳。
I'm only the shell

1930
01:16:47,590 --> 01:16:49,140
knows about

1931
01:16:49,330 --> 01:16:50,600
IO redirection.

1932
01:16:52,380 --> 01:16:55,540
这个示例还说明了fork和exec之间的一种巧妙分离，即fork和exec我们单独的系统调用是分开的。
This example also illustrates the sort of

1933
01:16:56,090 --> 01:16:59,330
kind of neatness of the separation between

1934
01:16:59,330 --> 01:17:00,950
fork and exec, the fact that fork

1935
01:17:00,950 --> 01:17:05,100
and exec our separate system calls separate.

1936
01:17:05,560 --> 01:17:07,720
嗯功能。
Um functions.

1937
01:17:08,130 --> 01:17:09,840
意味着孩子在分叉之间有一段时间。
Means that there's a period of time

1938
01:17:09,840 --> 01:17:11,720
in the child between the fork.

1939
01:17:11,980 --> 01:17:13,630
在它们之间查找子进程中的返回值和确切的哪些仍在运行调用进程的指令，因此调用进程。
Between them for returns in the child

1940
01:17:13,630 --> 01:17:16,060
and exactly which were still running the

1941
01:17:16,060 --> 01:17:17,860
calling processes instructions,

1942
01:17:17,860 --> 01:17:20,080
so the calling process.

1943
01:17:20,160 --> 01:17:22,320
即使它在子进程中运行，在子进程中运行的指令仍然是调用进程指令执行的，因此调用进程仍然能够进行更改，并且在第19行之前仍然处于控制状态。
Even though it's running in those instructions

1944
01:17:22,320 --> 01:17:23,610
are running in the child,

1945
01:17:23,610 --> 01:17:25,890
it's still the calling processes instructions that

1946
01:17:25,890 --> 01:17:28,050
are executed and so the calling process

1947
01:17:28,050 --> 01:17:31,620
is still able to change things and

1948
01:17:31,620 --> 01:17:33,940
still in control up until line 19.

1949
01:17:34,380 --> 01:17:35,790
fork和exec之间的这种间隔使该节目有机会更改文件描述符(例如，引用的内容)。
And this sort of interval between fork

1950
01:17:35,790 --> 01:17:38,010
and exec gives the show a chance

1951
01:17:38,010 --> 01:17:40,380
to change what the file descriptors,

1952
01:17:40,380 --> 01:17:41,820
refer to for example.

1953
01:17:43,180 --> 01:17:46,220
有关此重定向示例的任何问题。
Any questions about this redirect example.

1954
01:17:46,560 --> 01:18:00,080
嗯。好了，我快没时间了。
Yeah. All right, I'm about out of time.

1955
01:18:00,410 --> 01:18:02,690
总结一下，我们来看看Unix是，嗯。Unix的IO和进程抽象的一堆接口，嗯，如果接口相对简单，只是在它的参数系统调用之间来回传递像文件描述符和进程ID这样的整数，嗯。但是，接口内的功能相对复杂，比如创建新进程和复制当前进程，此外，我还展示了一些单独简单的抽象如何以有用的方式组合在一起的示例，例如，生成IO重定向。
Just wrap up, we look at unix is,

1956
01:18:02,690 --> 01:18:05,690
um. A bunch of the interfaces to

1957
01:18:05,690 --> 01:18:09,620
unix's IO and process abstractions, um,

1958
01:18:09,620 --> 01:18:10,820
thing to take away from this is

1959
01:18:10,820 --> 01:18:12,920
if the interfaces are relatively simple and

1960
01:18:12,920 --> 01:18:15,590
just pass integer like file descriptors

1961
01:18:15,590 --> 01:18:18,050
and process ids back and forth across

1962
01:18:18,050 --> 01:18:20,030
its arguments system calls,

1963
01:18:20,030 --> 01:18:21,900
um. But,

1964
01:18:22,360 --> 01:18:24,790
Well, the functionality inside the interface is

1965
01:18:24,790 --> 01:18:27,020
relatively sophisticated like

1966
01:18:27,180 --> 01:18:29,700
creating new processes and copying the current

1967
01:18:29,700 --> 01:18:32,820
process, and furthermore I show some examples

1968
01:18:32,820 --> 01:18:34,770
of ways in which the abstractions

1969
01:18:34,770 --> 01:18:38,550
individually simple combine in useful ways,

1970
01:18:38,550 --> 01:18:40,800
for example to produce

1971
01:18:40,890 --> 01:18:42,120
IO redirection.

1972
01:18:44,030 --> 01:18:45,260
下周末将有一个实验，该实验涉及编写更多简单的实用程序，就像我展示的那些使用我们讨论的系统调用的实用程序。
There's a lab due at the end

1973
01:18:45,260 --> 01:18:48,200
of next week and that lab involves

1974
01:18:48,200 --> 01:18:50,600
writing more simple utilities like the ones

1975
01:18:50,600 --> 01:18:52,160
I showed that use the system calls

1976
01:18:52,160 --> 01:18:54,000
that we discuss.

1977
01:18:54,140 --> 01:18:56,570
所以，祝你在实验室玩得开心，下周课堂上见。
So, have fun with that lab and I'll

1978
01:18:56,570 --> 01:18:57,880
see you in class next week.

1979
01:18:58,640 --> 01:19:02,580
嗯，仅此而已。
Um, and that's it.

1980
01:19:08,480 --> 01:19:08,940
谢谢。
Thank you.

1981
01:19:15,170 --> 01:19:16,670
既然我是录音的人，那么我该怎么结束呢，第一次在课堂上录音。他们将会离开。
Since I'm the one recording,

1982
01:19:16,670 --> 01:19:18,980
how do I end this, first

1983
01:19:18,980 --> 01:19:20,900
time recording in lecture. They

1984
01:19:20,900 --> 01:19:22,320
will be exit.

1985
01:19:22,520 --> 01:19:24,470
好的，没什么特别的我可以直接退出它会被保存在某个地方。
Okay, nothing special I can just exit it

1986
01:19:24,470 --> 01:19:25,580
will be saved somewhere.

1987
01:19:26,220 --> 01:19:28,020
是的，太棒了。
Yes, awesome.

1988
01:19:32,010 --> 01:19:34,520
我假设我们将创建一些目录，并在该目录中粘贴一个文件。
I assume we'll create some directory and

1989
01:19:35,120 --> 01:19:36,840
sticking a file in that directory.

1990
01:19:38,600 --> 01:19:41,140
右转之后还有办公时间。
There's also office hours right after this right.

1991
01:19:41,930 --> 01:19:46,380
是的，太酷了。
Yes, perfect cool.

1992
01:19:48,050 --> 01:19:51,220
高兴的。好的。
Happy. All right.

1993
01:19:51,580 --> 01:19:52,450
All right,
好的，谢谢，下周见，谢谢。

1994
01:19:52,450 --> 01:19:54,640
thank you and I'll see you next week,

1995
01:19:54,640 --> 01:19:55,320
thanks.
