1
00:00:07,270 --> 00:00:09,000
我说话清楚吗？
Yeah, am I loud and clear？

2
00:00:09,710 --> 00:00:11,540
是的，好的。
Yeah, okay,

3
00:00:11,540 --> 00:00:12,650
很好，嗯，
great, um,

4
00:00:12,650 --> 00:00:14,180
大家下午好，晚上好，
so good afternoon or good evening

5
00:00:14,180 --> 00:00:15,590
早上好，中午好，
or good morning or good night,

6
00:00:15,590 --> 00:00:17,580
不管你在哪里。
wherever you are.

7
00:00:17,710 --> 00:00:20,440
我们开始学习
Um, let's get started on the

8
00:00:20,440 --> 00:00:22,570
6.S081 的第三节课，
third lecture in 6.S081, which

9
00:00:22,570 --> 00:00:23,440
它是关于
are going to be about,

10
00:00:23,440 --> 00:00:25,140
操作系统结构的。
OS organization.

11
00:00:25,410 --> 00:00:28,950
今天的话题
And, topics for today

12
00:00:28,950 --> 00:00:30,840
包括
are, um,

13
00:00:32,200 --> 00:00:34,030
四项内容。
four things that I want to

14
00:00:34,030 --> 00:00:36,180
一个是隔离，
touch on. One is isolation,

15
00:00:36,440 --> 00:00:38,930
这是由
which you'll see is the driving

16
00:00:38,930 --> 00:00:40,160
操作系统
design goal

17
00:00:40,160 --> 00:00:41,360
设计目标驱动的。
for OS organization.

18
00:00:41,360 --> 00:00:43,070
讲一下内核模式和
Talk a little bit about

19
00:00:43,070 --> 00:00:45,600
用户模式。
kernel and user mode.

20
00:00:47,370 --> 00:00:49,350
这是将内核或
That's a way of isolating the

21
00:00:49,350 --> 00:00:51,210
操作系统与用户应用程序
kernel from, or the operating system

22
00:00:51,210 --> 00:00:53,100
隔离的一种方式。
from a user applications.

23
00:00:53,380 --> 00:00:55,440
然后，讨论系统调用，
Then, we'll talk about system calls,

24
00:00:55,790 --> 00:00:58,430
这是用户应用程序
which is a way for user

25
00:00:58,430 --> 00:01:00,770
访问内核的一种方式，
applications to basically, transition into the

26
00:01:00,770 --> 00:01:02,480
使得应用程序可以访问内核服务。
kernel, so they can ask

27
00:01:02,480 --> 00:01:04,010
我们看一下
for services. And we look a

28
00:01:04,010 --> 00:01:06,140
它是如何在 xv6 中
little bit how it always instantiated

29
00:01:06,140 --> 00:01:08,270
以简单的形式
in a simple form inside

30
00:01:08,270 --> 00:01:09,500
of xv6,
实例化的，

31
00:01:09,500 --> 00:01:10,970
这就是
so that is the point

32
00:01:10,970 --> 00:01:11,620
今天的重点。
for today.

33
00:01:12,160 --> 00:01:15,460
你还记得，
Um, and you still rethought of,

34
00:01:15,460 --> 00:01:18,610
回忆一下
remind you, where we were

35
00:01:18,610 --> 00:01:21,060
上节课的内容。
after the first lecture.

36
00:01:21,290 --> 00:01:23,210
你脑海中的画面，
Um, the picture in your head,

37
00:01:23,210 --> 00:01:24,080
你脑海中应该有这样的画面，
you should have in your head

38
00:01:24,080 --> 00:01:26,480
像 shell echo
is you know there are processes

39
00:01:26,480 --> 00:01:29,260
这样的进程，
like the shell, like echo.

40
00:01:29,590 --> 00:01:32,260
或者其他，
or, you know whatever,

41
00:01:34,280 --> 00:01:36,290
比如 find ，
find, you know, whatever utilities

42
00:01:36,290 --> 00:01:38,360
无论你实现的任何程序，
that you implement, they're running

43
00:01:38,360 --> 00:01:41,060
它们都运行操作系统之上。
on top of operating system.

44
00:01:42,520 --> 00:01:44,020
你知道操作系统
And you know the operating system

45
00:01:44,020 --> 00:01:44,590
是一种
of abstracts

46
00:01:44,590 --> 00:01:45,070
对硬件资源
you know, some of the

47
00:01:45,070 --> 00:01:46,540
的抽象。
hardware resources,

48
00:01:46,800 --> 00:01:47,040
你知道的，
You know,

49
00:01:47,040 --> 00:01:49,320
就像磁盘或 CPU 这种硬件。
like a disk or CPU,

50
00:01:49,320 --> 00:01:51,060
基本上
And, you know basically the interface

51
00:01:51,060 --> 00:01:52,830
操作系统和 shell 之间的接口
between the operating systems and the

52
00:01:52,830 --> 00:01:54,330
通常被称为
shells are typically referred to as

53
00:01:54,330 --> 00:01:55,530
系统调用接口，
system call interface,

54
00:01:55,530 --> 00:01:56,880
我们一直在研究的接口
an interface that we've been looking

55
00:01:56,880 --> 00:01:59,200
是 unix 接口。
at is unix interface.

56
00:02:01,710 --> 00:02:03,720
我们看到的
And here what we see,

57
00:02:03,720 --> 00:02:05,880
是，
um is,

58
00:02:05,880 --> 00:02:07,440
在实验 1 中，
um, so that was roughly you

59
00:02:07,440 --> 00:02:09,660
你已经差不多
know actually with that unix interface

60
00:02:09,660 --> 00:02:11,250
使用过
you've been playing around in

61
00:02:11,250 --> 00:02:12,090
unix 接口，
lab 1, um,

62
00:02:12,090 --> 00:02:14,310
就是 util 实验中使用的，
were in util lab you used,

63
00:02:14,310 --> 00:02:15,780
系统调用接口或
you know the system call interface

64
00:02:15,780 --> 00:02:17,670
unix API 来实现
or unix API to actually implement

65
00:02:17,670 --> 00:02:19,060
不同的应用程序。
different sets of applications.

66
00:02:19,480 --> 00:02:21,850
所以实验 1 ，一个有用的实验，
And so lab 1, a useful

67
00:02:21,850 --> 00:02:24,580
主要集中在
lab, is mostly focused on using

68
00:02:24,580 --> 00:02:25,800
这张图的
you know this part

69
00:02:26,100 --> 00:02:27,810
这一部分，
of the design picture

70
00:02:27,810 --> 00:02:29,190
我们现在要做的，
here, and what we're going

71
00:02:29,190 --> 00:02:30,780
在第一节课，
to be doing now, in

72
00:02:30,780 --> 00:02:32,130
这节课，
this first lecture or this

73
00:02:32,130 --> 00:02:33,930
和后续的许多课中要做的，
lecture and many subsequent lectures,

74
00:02:33,930 --> 00:02:35,910
我们将真正了解
we're gonna really look actually how

75
00:02:35,910 --> 00:02:38,020
接口是如何实际实现的。
the interface is actually implemented.

76
00:02:38,220 --> 00:02:39,300
事实上，
And in fact almost all of

77
00:02:39,300 --> 00:02:41,370
几乎整个学期都会
the semester will be spending time

78
00:02:41,370 --> 00:02:43,380
把时间花在弄清楚
on figuring out, actually, how

79
00:02:43,380 --> 00:02:45,060
如何实现接口上，
to implement interface and so this

80
00:02:45,060 --> 00:02:46,080
这节课将是
is going to be the first

81
00:02:46,080 --> 00:02:48,380
这类课程的开始。
lecture of that kind of style.

82
00:02:48,590 --> 00:02:49,640
嗯，
And, um,

83
00:02:49,640 --> 00:02:50,780
幸运的是，
fortunately, um,

84
00:02:50,780 --> 00:02:51,650
你们中的很多人
you know, a lot of you

85
00:02:51,650 --> 00:02:54,660
通过电子邮件问了很多很棒的问题。
asking really great questions over email.

86
00:02:54,740 --> 00:02:56,960
或者在网站上提交了
Um, or submitted a great question

87
00:02:56,960 --> 00:02:57,920
一个很棒的问题，
to the website,

88
00:02:57,920 --> 00:02:59,900
我们不会
um, and we won't be able

89
00:02:59,900 --> 00:03:01,580
直接讲很多细节，
to go into great amount of

90
00:03:01,580 --> 00:03:02,780
在这种
detail immediately in this sort of

91
00:03:02,780 --> 00:03:04,640
深入了解操作系统的
first lecture that types an inside

92
00:03:04,640 --> 00:03:05,960
第一次课程中，
look of the operating system,

93
00:03:05,960 --> 00:03:06,980
我们会触及
so we're going to touch on

94
00:03:06,980 --> 00:03:07,820
不同的东西，
different things,

95
00:03:07,820 --> 00:03:09,320
但是很多事情
but many things will become

96
00:03:09,320 --> 00:03:10,640
会在接下来的课程中，
more clear

97
00:03:10,640 --> 00:03:12,110
变得越来越清楚，
in subsequent lectures,

98
00:03:12,110 --> 00:03:13,190
我们会做更深入地
we're going to explore in

99
00:03:13,190 --> 00:03:14,060
探索。
more depth.

100
00:03:14,520 --> 00:03:17,010
但是不管怎样，
Um, but nevertheless, if there's

101
00:03:17,010 --> 00:03:18,180
如果有什么东西不清楚，
something unclear,

102
00:03:18,180 --> 00:03:19,860
可以打断我，
feel free to interrupt and ask

103
00:03:19,860 --> 00:03:20,920
提出问题。
a question.

104
00:03:22,020 --> 00:03:23,940
也许
And maybe just to start off

105
00:03:23,940 --> 00:03:26,700
在真正深入之前，
before actually going any further,

106
00:03:26,700 --> 00:03:27,930
让我先问你们一个问题，
let me ask you a question

107
00:03:27,930 --> 00:03:29,760
提问
and sort of get the question

108
00:03:29,760 --> 00:03:30,210
并回答，
and answering

109
00:03:30,210 --> 00:03:32,490
我要的问题是
hopefully going, and ask you like

110
00:03:32,490 --> 00:03:34,350
你从 util 实验
what is the most interesting thing

111
00:03:34,350 --> 00:03:36,260
学到的
that you've learned from the

112
00:03:36,330 --> 00:03:38,490
最有趣的事情是什么。
util lab. And, I'll

113
00:03:38,490 --> 00:03:40,350
首先，我会自己回答这个问题，
start by answering that question myself,

114
00:03:40,350 --> 00:03:41,790
在完成 util 实验后，
um, one of the things that

115
00:03:41,790 --> 00:03:44,310
令我惊讶的一件事是，
surprise me after writing or doing

116
00:03:44,310 --> 00:03:46,640
我比以前更频繁地
the util lab is that, um,

117
00:03:46,770 --> 00:03:48,390
使用 xargs ，
I use 'xargs' a lot more

118
00:03:48,390 --> 00:03:49,680
我有
frequently than I used to, I

119
00:03:49,680 --> 00:03:51,480
其他一些方法跟 xargs 做基本相同的事情，
had another way of doing basically

120
00:03:51,480 --> 00:03:52,800
一组命令，
the same thing as xargs,

121
00:03:52,800 --> 00:03:56,790
在
set of commands and after

122
00:03:56,790 --> 00:03:58,230
做了 xargs 实验之后，
actually doing the xargs lab,

123
00:03:58,230 --> 00:03:59,550
xargs 更方便
xargs has much

124
00:03:59,550 --> 00:04:00,780
以这种方式
more convenient actually to use it

125
00:04:00,780 --> 00:04:01,380
使用它。
in that way.

126
00:04:01,380 --> 00:04:02,580
从那时起，
And so since then,

127
00:04:02,580 --> 00:04:04,440
我成为一个使用 xargs 的
I been much more aggressive

128
00:04:04,440 --> 00:04:06,660
更积极的用户。我只是
user of xargs. And I'm

129
00:04:06,660 --> 00:04:10,590
想知道
just wondering what the experience has

130
00:04:10,590 --> 00:04:12,870
你们的收获了什么，
been for some of you, maybe

131
00:04:12,870 --> 00:04:14,700
我会点名提问，
I'll call out a few names

132
00:04:14,700 --> 00:04:16,680
你们可以取消麦克风的静音来
and maybe you can unmute your

133
00:04:16,680 --> 00:04:18,390
回答问题。
microphone answer, let's say,

134
00:04:18,390 --> 00:04:20,310
让我们来谈谈
um, let's say a little bit

135
00:04:20,310 --> 00:04:22,600
你们关于 util 实验的经历。
about your experience with util lab.

136
00:04:23,350 --> 00:04:25,450
我来
Um, so let me pick

137
00:04:25,450 --> 00:04:26,170
挑几个人，
some people,

138
00:04:26,170 --> 00:04:27,680
嗯， Andrew You 。
um, Andrew You.

139
00:04:33,100 --> 00:04:35,890
Andrew ，听到了吗？
Andrew, are you online listening?

140
00:04:35,890 --> 00:04:37,300
嗯，对我来说最有趣的事
um, the most interesting thing for

141
00:04:37,300 --> 00:04:38,780
是管道，
me was just the pipes,

142
00:04:39,060 --> 00:04:41,000
学习如何写并发程序。
learn how to write concurrent programs.

143
00:04:42,080 --> 00:04:43,640
很好，你以前
Good, have you done any sort

144
00:04:43,640 --> 00:04:45,170
做过管道编程吗？
of pipe programming before?

145
00:04:45,170 --> 00:04:46,550
不，没有，
No, I haven't, I've

146
00:04:46,550 --> 00:04:47,780
我见过并发的东西，
seen the all concurrent stuff,

147
00:04:47,780 --> 00:04:48,860
但我以前没有见过
but I haven't seen like OS

148
00:04:48,860 --> 00:04:50,240
操作系统级别的管道。
level pipes before.

149
00:04:51,660 --> 00:04:53,740
Elizabeth Weeks ，你觉得怎么样？
How about Elizabeth Weeks?

150
00:04:55,360 --> 00:04:57,130
是的，我同意这一点，
Yeah, I'd agree with that I

151
00:04:57,130 --> 00:04:59,470
我也认为操作系统管道
also thought that the OS pipes

152
00:04:59,470 --> 00:05:00,850
非常有趣，
are super interesting and like the

153
00:05:00,850 --> 00:05:02,180
同时也喜欢质数实验，
primes, um,

154
00:05:02,450 --> 00:05:05,150
这个例子特别酷，
example specifically was cool to kind

155
00:05:05,150 --> 00:05:06,500
要考虑，
of figure out and realize that

156
00:05:06,500 --> 00:05:08,000
我需要关闭某些管道，
I need to close certain pipes

157
00:05:08,000 --> 00:05:08,980
就像，
and just like, are they kind of

158
00:05:09,560 --> 00:05:12,440
它们之间有某种关联。是的，是的，
related to each other. Yeah, yeah I remember

159
00:05:12,440 --> 00:05:13,760
我记得你
you did find the pipes of

160
00:05:13,760 --> 00:05:15,020
发现使用管道的质数
primes are a little bit harder

161
00:05:15,020 --> 00:05:16,180
比想象的要难，
than,

162
00:05:16,450 --> 00:05:18,970
它每次都让我感到惊讶，
you might thought, it surprises

163
00:05:18,970 --> 00:05:20,350
完成它，
me every time, a little bit

164
00:05:20,350 --> 00:05:21,540
需要一点技巧。
tricky to get right.

165
00:05:23,340 --> 00:05:24,620
Jessica She.
Jessica She.

166
00:05:26,320 --> 00:05:29,170
我也认为质数练习
I also thought the primes exercise

167
00:05:29,170 --> 00:05:30,800
是最有趣的。
was most interesting.

168
00:05:33,080 --> 00:05:33,920
是不是
Did it take you a lot

169
00:05:33,920 --> 00:05:35,090
花了你很多时间，
of time or was it not

170
00:05:35,090 --> 00:05:35,920
还是还不错。
too bad.

171
00:05:36,610 --> 00:05:40,690
在我意识到，
Um, it took me more time

172
00:05:40,690 --> 00:05:42,370
我最初的实现不是并行的之后，
after I realized my initial implementation

173
00:05:42,370 --> 00:05:44,110
我花了更多的时间，
wasn't actually concurrent so it's interesting

174
00:05:44,110 --> 00:05:45,280
所以思考有什么不同
to think about like,

175
00:05:45,520 --> 00:05:47,040
是很有趣的。
what the differences are there.

176
00:05:47,750 --> 00:05:50,580
好的， Robert Murphy ？
Okay, how about Robert Murphy?

177
00:05:53,970 --> 00:05:56,180
我认为，
Yeah, I think that, the,

178
00:05:56,660 --> 00:05:59,720
我的体验是，
my experience was really just, I

179
00:05:59,720 --> 00:06:01,730
我发现用原始的方式编程
found it really challenging to program

180
00:06:01,730 --> 00:06:03,680
真的很有挑战性，
in the original way,

181
00:06:03,680 --> 00:06:04,370
它们很初级，
it was set up so I

182
00:06:04,370 --> 00:06:05,660
所以我实际上创建了一系列
actually created a bunch of helper

183
00:06:05,660 --> 00:06:07,400
围绕它们的帮助函数，
functions that wrapped around things,

184
00:06:08,290 --> 00:06:09,580
这就是
So that's I guess what

185
00:06:09,580 --> 00:06:10,120
我所做的。
I did.

186
00:06:13,730 --> 00:06:15,530
好的，还有人
Ok, any idea who have sort of

187
00:06:15,530 --> 00:06:17,760
有什么好想法吗？
any piece of wisdom?

188
00:06:18,000 --> 00:06:20,730
Amanda ，说吧。
Amanda, go ahead. I kind

189
00:06:20,730 --> 00:06:21,540
我喜欢
of liked it and found it

190
00:06:21,540 --> 00:06:24,630
并且发现它很酷，
surprising such cool, that stdin

191
00:06:24,630 --> 00:06:26,730
标准输入和标准输出
and stdout are just file

192
00:06:26,730 --> 00:06:28,740
用文件描述符 0 1 来表示。
descriptors themselves 0 and 1.

193
00:06:28,830 --> 00:06:29,780
对，对。
Yeah yeah.

194
00:06:30,140 --> 00:06:31,250
很好，
Good,

195
00:06:31,250 --> 00:06:33,050
xv6 完全没有
yeah xv6 doesn't hide that from

196
00:06:33,050 --> 00:06:33,740
隐藏这个，
you at all,

197
00:06:33,740 --> 00:06:35,540
至少在
um, at least in a normal C

198
00:06:35,540 --> 00:06:36,230
C 标准库中，
library,

199
00:06:36,230 --> 00:06:37,160
它对接口
that's a little bit wrapped up

200
00:06:37,160 --> 00:06:37,880
做了
in,

201
00:06:38,000 --> 00:06:40,280
一些封装，
um, in an interface,

202
00:06:40,280 --> 00:06:42,650
但是， xv6 没有隐藏它，
but, um xv6 doesn't hide it for you,

203
00:06:42,650 --> 00:06:43,520
而是最终它
but in the end it boils

204
00:06:43,520 --> 00:06:45,200
确实归结为
down indeed to know just file

205
00:06:45,200 --> 00:06:46,760
文件描述符 0 1 和 2 ，
descriptor 0 1 and 2 I

206
00:06:46,760 --> 00:06:47,840
2 是标准错误。
guess for standard error.

207
00:06:53,900 --> 00:06:55,190
很好， Alexander 。嗯，我想，
Good, Alexander. Um, I guess,

208
00:06:55,190 --> 00:06:57,320
让我感觉
um, one thing I was surprised

209
00:06:57,320 --> 00:06:59,120
惊讶的，
about was also from the

210
00:06:59,120 --> 00:07:01,300
也是质数问题。
prime problem.

211
00:07:02,920 --> 00:07:04,600
有一个 bug
I had this bug that I

212
00:07:04,600 --> 00:07:06,910
我花了几个小时的时间，
spent hours on and the thing

213
00:07:06,910 --> 00:07:08,500
这个 bug 是我没有意识到，
was that I didn't realize that

214
00:07:08,500 --> 00:07:11,380
每当你打开
actually they were whenever you were

215
00:07:14,050 --> 00:07:15,970
一个管道，
opening a pipe and then for

216
00:07:15,970 --> 00:07:18,670
然后调用 fork ，
like calling fork then basically they

217
00:07:18,670 --> 00:07:20,060
那么这个管道
were be four

218
00:07:20,260 --> 00:07:22,600
就有了 4 个末端，
ends to the pipe, because

219
00:07:22,600 --> 00:07:24,760
因为那个管道
that pipe is kind of a

220
00:07:24,760 --> 00:07:26,740
既通向子进程，
goes both to the child process

221
00:07:26,740 --> 00:07:28,760
又通向父进程，
and the process the parent process,

222
00:07:29,080 --> 00:07:30,550
但是我只关闭了
but I was only closing

223
00:07:30,550 --> 00:07:32,640
其中的两个。
two of those.

224
00:07:33,010 --> 00:07:33,490
是的，
So, yeah,

225
00:07:33,490 --> 00:07:36,940
这是一个非常普遍的问题。
that was a common, common problem.

226
00:07:36,940 --> 00:07:38,140
这是有道理的，
It made sense

227
00:07:38,140 --> 00:07:39,280
但因为某些原因，
but for some reason,

228
00:07:39,280 --> 00:07:42,190
特别是教科书上写到，
because especially the textbook says that

229
00:07:42,190 --> 00:07:44,920
当你使用 fork ，
when you fork, all of

230
00:07:44,920 --> 00:07:47,340
所有打开的文件描述符都会被复制，
the open file descriptors get copied,

231
00:07:47,440 --> 00:07:49,960
但我没有考虑到这一点。是的，
but I didn't think about it that. Yeah,

232
00:07:49,960 --> 00:07:50,620
很难，我的意思是，
it's hard to I mean

233
00:07:50,620 --> 00:07:51,370
在那个接口中
there's a lot of details

234
00:07:51,370 --> 00:07:52,000
有很多细节，
in that interface,

235
00:07:52,000 --> 00:07:52,840
唯一真正
and you know the only way

236
00:07:52,840 --> 00:07:54,460
熟悉它的方法，
to get actually really familiar with

237
00:07:54,460 --> 00:07:56,200
是用它来编程，
actually the program with it,

238
00:07:56,940 --> 00:07:58,320
实际使用它。
experience it.

239
00:07:58,880 --> 00:07:59,750
很好，
Good good,

240
00:07:59,750 --> 00:08:00,770
我希望你喜欢
well, I hope you enjoyed

241
00:08:00,770 --> 00:08:01,400
这个实验，
the lab,

242
00:08:01,400 --> 00:08:02,360
嗯，
um, and,

243
00:08:02,360 --> 00:08:03,290
当然我也希望
of course I hope you enjoy

244
00:08:03,290 --> 00:08:04,640
你喜欢后面的实验，
the subsequent labs too,

245
00:08:04,640 --> 00:08:05,600
所以今天的课程，
so the lecture for today,

246
00:08:05,600 --> 00:08:06,800
从某种意义上说，
in some sense is really you

247
00:08:06,800 --> 00:08:08,510
部分内容是为了帮助你
know partially to help you to

248
00:08:08,510 --> 00:08:12,230
开始 syscall 实验，
get going on the syscall lab,

249
00:08:12,230 --> 00:08:13,790
如果你还没有开始。
if you haven't already started. And

250
00:08:13,790 --> 00:08:14,480
再说一次，
so again,

251
00:08:14,480 --> 00:08:15,980
你可以随时打断我
you feel free to interrupt

252
00:08:15,980 --> 00:08:16,980
并提出问题。
and ask questions.

253
00:08:17,550 --> 00:08:18,780
好的，我想做的
Okay, so the first thing I

254
00:08:18,780 --> 00:08:21,720
第一件事是，
want to do is,

255
00:08:22,000 --> 00:08:23,500
讲一下
talk a little bit

256
00:08:23,500 --> 00:08:25,210
隔离，
about isolation,

257
00:08:25,210 --> 00:08:26,770
你知道为什么它很重要，
um, and you know why it's

258
00:08:26,770 --> 00:08:29,290
为什么我们会关心，
important and why we might care,

259
00:08:29,290 --> 00:08:30,820
基本的描述是
you know the basic stories are

260
00:08:30,820 --> 00:08:32,050
很简单的，
reasonable simple,

261
00:08:32,050 --> 00:08:33,490
你知道我们有多个应用程序，
you know we have multiple applications,

262
00:08:33,490 --> 00:08:34,420
我们有 shell ，
we got the shell,

263
00:08:34,420 --> 00:08:36,130
echo find ，
the echo find and it'll

264
00:08:36,130 --> 00:08:37,060
它必须正确，
be great correct,

265
00:08:37,060 --> 00:08:37,990
如果你的 shell 中有一个bug，
if you had a bug in

266
00:08:37,990 --> 00:08:39,550
或者你的
the shell or example in your

267
00:08:39,550 --> 00:08:40,720
prime 程序，
prime program,

268
00:08:40,720 --> 00:08:42,250
这不会影响
that actually didn't affect any

269
00:08:42,250 --> 00:08:43,450
任何其他应用程序，
of the other applications,

270
00:08:43,450 --> 00:08:44,740
特别是如果影响了 shell
particularly it would be bad, for

271
00:08:44,740 --> 00:08:46,030
会有很坏的结果，
example if it affected the shell

272
00:08:46,030 --> 00:08:47,620
因为当事情变坏时，
because probably the shell you're using

273
00:08:47,620 --> 00:08:49,240
shell 可能
to actually kill the program,

274
00:08:49,240 --> 00:08:50,420
会终止这个程序。
if something goes bad.

275
00:08:50,960 --> 00:08:53,240
因此，你需要在这些不同的应用程序之间
So you want sort of strong isolation

276
00:08:53,240 --> 00:08:55,480
进行某种程度上的强隔离。
between these different applications.

277
00:08:55,870 --> 00:08:58,000
类似地，你知道
Similarly you know the OS

278
00:08:58,000 --> 00:08:59,470
操作系统为
is sort of a servant for

279
00:08:59,470 --> 00:09:00,730
所有应用程序服务，
all the applications,

280
00:09:00,730 --> 00:09:01,960
你会希望情况
um, and you would like it

281
00:09:01,960 --> 00:09:02,920
是这样的，
to be the case, you

282
00:09:02,920 --> 00:09:04,660
如果你在某个 util 程序中
know, if, you know you make

283
00:09:04,660 --> 00:09:05,710
存在一个 bug ，
a bug in one of your

284
00:09:05,710 --> 00:09:07,270
实际上操作系统不会崩溃，
util programs, that actually the operating

285
00:09:07,270 --> 00:09:09,280
除非
system doesn't crash, until you pass some

286
00:09:09,280 --> 00:09:11,590
你把一些奇怪的参数传递给操作系统，
strange argument to the operating system,

287
00:09:11,590 --> 00:09:12,670
否则操作系统会
you should be the case that

288
00:09:12,670 --> 00:09:14,440
处理得很好。
the operating system handles that well.

289
00:09:14,720 --> 00:09:15,920
因此，我们希望，
And so again we would like

290
00:09:15,920 --> 00:09:16,520
应用程序和
to be there,

291
00:09:16,520 --> 00:09:19,540
操作系统之间
strong isolation between,

292
00:09:19,730 --> 00:09:22,910
进行
um, the applications and the operating

293
00:09:22,910 --> 00:09:23,900
强隔离。
system itself.

294
00:09:24,400 --> 00:09:25,960
思考这个问题的
Um, and one way to think

295
00:09:25,960 --> 00:09:26,920
一种方式是，
about this, a little bit is

296
00:09:26,920 --> 00:09:28,450
问我们
to say, is ask ourselves the

297
00:09:28,450 --> 00:09:30,520
自己一个问题，
question you know what would happen

298
00:09:30,520 --> 00:09:32,830
如果没有操作系统会发生什么，
if there's actually no operating system,

299
00:09:32,830 --> 00:09:34,480
所以考虑一些
so you know consider some

300
00:09:34,480 --> 00:09:36,300
strawman 设计，
strawman design, design,

301
00:09:41,670 --> 00:09:43,120
它没有操作系统。
there is no operating system.

302
00:09:45,400 --> 00:09:46,390
或者你可以把
Or you could think about it

303
00:09:46,390 --> 00:09:47,890
它想象成操作系统是 [] ，
as the operating system is [],

304
00:09:47,890 --> 00:09:49,420
仅仅是一个库，
just being a library,

305
00:09:49,420 --> 00:09:50,440
你知道类似从
you know sort of thinking about

306
00:09:50,440 --> 00:09:52,120
python 的角度考虑，
in terms of python,

307
00:09:52,120 --> 00:09:53,860
可能只是导入操作系统，
maybe just import OS,

308
00:09:53,860 --> 00:09:55,360
导入操作系统就是
and import OS basically loads

309
00:09:55,360 --> 00:09:57,130
会在你的应用程序中
the whole operating system inside

310
00:09:57,130 --> 00:09:58,870
加载整个操作系统，
of your application and that's

311
00:09:58,870 --> 00:09:59,980
然后这就是
then the programming interface,

312
00:09:59,980 --> 00:10:01,180
你使用的编程接口。
you use.

313
00:10:01,720 --> 00:10:02,770
所以
And so you think about

314
00:10:02,770 --> 00:10:04,150
你可以这样想，
that sort of way of

315
00:10:04,150 --> 00:10:05,230
假设
thinking so let's say we

316
00:10:05,230 --> 00:10:06,460
我们有 shell ，
have shell here,

317
00:10:06,460 --> 00:10:06,670
你知道，
you know,

318
00:10:06,670 --> 00:10:09,790
它可能包括
maybe it includes the library for

319
00:10:09,790 --> 00:10:11,830
操作系统的库，可能有一些
the OS and maybe we

320
00:10:11,830 --> 00:10:14,000
其他的应用程序 echo 。
have some other application echo.

321
00:10:14,490 --> 00:10:16,260
然后你知道
Um, and then basically you know

322
00:10:16,260 --> 00:10:18,080
这些应用程序，
these applications,

323
00:10:18,180 --> 00:10:20,520
如果没有操作系统，
if there's no operating system really,

324
00:10:20,520 --> 00:10:22,720
它们就会直接与硬件交互。
would directly interact with the hardware.

325
00:10:23,200 --> 00:10:23,920
例如，
For example,

326
00:10:23,920 --> 00:10:25,360
它们实际上会看到，
you know they would actually see

327
00:10:25,360 --> 00:10:26,860
这有一个 CPU 内核，
you know there's a CPU core

328
00:10:26,860 --> 00:10:28,600
这还有另一个 CPU 内核。
there's another CPU core.

329
00:10:28,840 --> 00:10:30,340
你知道，
Um, and you know maybe there's

330
00:10:30,340 --> 00:10:31,780
这有一个磁盘，
a disk and then we interact

331
00:10:31,780 --> 00:10:33,070
然后我们直接与磁盘块交互，
directly with the disk blocks, and

332
00:10:33,070 --> 00:10:34,450
还有内存，
maybe there's memory and they were

333
00:10:34,450 --> 00:10:35,860
然后它们直接与
directly interact with the memory of

334
00:10:35,860 --> 00:10:36,600
机器的内存交互。
the machine.

335
00:10:37,380 --> 00:10:39,090
所以应用程序和
Um, and so there's no layer

336
00:10:39,090 --> 00:10:41,730
硬件之间没有中间层，
between, no abstraction layer between basically

337
00:10:41,730 --> 00:10:42,780
没有抽象层，
the applications

338
00:10:42,780 --> 00:10:45,480
而且
and the hardware, and it

339
00:10:45,480 --> 00:10:47,040
事实证明
turns out that it's just not

340
00:10:47,040 --> 00:10:48,420
在隔离方面，
such a great design,

341
00:10:48,420 --> 00:10:51,100
这不是一个好设计。
um, for isolation.

342
00:10:51,540 --> 00:10:52,860
你可以看到
And you can see how isolation

343
00:10:52,860 --> 00:10:54,000
隔离是如何被打破的，
might be broken,

344
00:10:54,000 --> 00:10:56,070
例如，
let's assume for example that you

345
00:10:56,070 --> 00:10:57,240
你知道操作系统
know one of the goal of

346
00:10:57,240 --> 00:10:58,890
的一个目标
operating system is run

347
00:10:58,890 --> 00:11:00,320
就是运行多个应用程序。
multiple applications.

348
00:11:00,330 --> 00:11:01,020
所以，
And so,

349
00:11:01,020 --> 00:11:02,100
一定会有这样的情况，
there has to be the case

350
00:11:02,100 --> 00:11:03,270
每隔一段时间，
that once in a while,

351
00:11:03,270 --> 00:11:05,010
它会从一个应用程序切换到
it will switch from one application

352
00:11:05,010 --> 00:11:05,910
另一个应用程序，
to another application,

353
00:11:05,910 --> 00:11:07,320
假设硬件只有一个 CPU ，
let's say the hardware has only

354
00:11:07,320 --> 00:11:09,660
我们运行
one CPU and so we're running

355
00:11:09,660 --> 00:11:11,490
shell 程序，
the shell say about one CPU,

356
00:11:11,490 --> 00:11:12,720
但是
but they are periodically in

357
00:11:12,720 --> 00:11:13,890
其他应用程序应该
other applications should be able

358
00:11:13,890 --> 00:11:14,720
能够周期性运行。
to run to.

359
00:11:15,520 --> 00:11:17,470
如果没有操作系统
Well, we have no operating system

360
00:11:17,470 --> 00:11:18,670
为我们做这些，
to do for us,

361
00:11:18,670 --> 00:11:20,140
那么 shell 程序
then the shell basically has to

362
00:11:20,140 --> 00:11:20,650
必须
give up,

363
00:11:20,650 --> 00:11:21,600
每隔一段时间
you know the

364
00:11:21,630 --> 00:11:23,080
主动放弃 CPU 。
CPU once in a while.

365
00:11:24,220 --> 00:11:25,060
像是一个好人，
And sort of be a nice

366
00:11:25,060 --> 00:11:27,190
懂得我已经运行了
person, and say well I've run

367
00:11:27,190 --> 00:11:28,360
一段时间，
for a little while, you get

368
00:11:28,360 --> 00:11:29,560
现在你有机会运行了，
chance to run and there's

369
00:11:29,560 --> 00:11:31,420
这就是所谓的协作式调度。
something just called cooperative scheduling.

370
00:11:31,840 --> 00:11:33,550
但是它不是
Um, but it's not so great

371
00:11:33,550 --> 00:11:34,540
很适合隔离，
for isolation,

372
00:11:34,540 --> 00:11:35,140
例如，
for example,

373
00:11:35,140 --> 00:11:37,150
如果 shell 中的某个函数
what if some function in the

374
00:11:37,150 --> 00:11:38,920
有一个无限循环，
shell has an infinite loop,

375
00:11:38,920 --> 00:11:40,690
那么它实际上
and therefore it will never actually

376
00:11:40,690 --> 00:11:41,720
永远不会放弃 CPU 。
give up the CPU.

377
00:11:41,880 --> 00:11:42,210
然后，
And then,

378
00:11:42,210 --> 00:11:44,310
其他任何应用程序都不能运行，
no other applications could run

379
00:11:44,310 --> 00:11:46,110
包括想要停止或终止
including maybe the application that would

380
00:11:46,110 --> 00:11:48,140
shell 的应用程序。
like stop or kill the shell.

381
00:11:48,580 --> 00:11:49,300
所以，
And so,

382
00:11:49,300 --> 00:11:50,860
我们没有得到
um, we basically don't get

383
00:11:50,860 --> 00:11:51,940
任何形式的
any sort of form of

384
00:11:51,940 --> 00:11:53,680
强制复用。
enforced multiplexing.

385
00:11:54,090 --> 00:11:55,350
这才是我们想要的，
That's something that we'd like to

386
00:11:55,350 --> 00:11:57,420
在这种情况下，
have, where no matter what the

387
00:11:57,420 --> 00:11:59,640
无论应用程序做什么，
application does, it will be forced

388
00:11:59,640 --> 00:12:00,810
它都会偶尔
to give up the CPU once

389
00:12:00,810 --> 00:12:01,500
被迫放弃 CPU ，
in a while,

390
00:12:01,500 --> 00:12:03,540
这时其他应用程序可以运行。
that's what other applications go up.

391
00:12:04,760 --> 00:12:06,260
类似地，
Similarly, if you think about this

392
00:12:06,260 --> 00:12:08,660
考虑这个 strawman 设计，
strawman design, you know

393
00:12:08,660 --> 00:12:10,820
我们有一个物理内存，
we have there's a physical memory

394
00:12:10,820 --> 00:12:12,260
我在这里
right and all I drew a

395
00:12:12,260 --> 00:12:13,250
画了一张图，
picture here,

396
00:12:13,250 --> 00:12:14,390
应用程序位于
so the application sitting on the

397
00:12:14,390 --> 00:12:15,350
硬件的上一层，
top of the hardware,

398
00:12:15,350 --> 00:12:17,630
但你知道有物理内存，
but you know there's physical memory

399
00:12:17,630 --> 00:12:19,700
代码文本和
and basically text in the code

400
00:12:19,700 --> 00:12:21,290
应用程序数据
and the data for these applications

401
00:12:21,290 --> 00:12:22,910
实际上位于物理内存中，
actually sits in the physical memory,

402
00:12:22,910 --> 00:12:24,000
这是一个常用的内存。
it's a usual memory.

403
00:12:24,730 --> 00:12:27,190
这可能是
And here's maybe you know the

404
00:12:27,190 --> 00:12:28,120
shell 使用的
part of physical memory,

405
00:12:28,120 --> 00:12:29,620
物理内存部分，
that's used by the shell,

406
00:12:29,620 --> 00:12:30,700
这可能是 echo
here's maybe a part of

407
00:12:30,700 --> 00:12:32,050
使用的
a physical memory that's used

408
00:12:32,050 --> 00:12:34,040
物理内存部分。
by echo application.

409
00:12:34,760 --> 00:12:36,890
所以你会再次看到
And so you're going to again

410
00:12:36,890 --> 00:12:37,760
这里所看到的，
what was see here,

411
00:12:37,760 --> 00:12:39,860
如果你想简单地
if you'd like simply simplistically

412
00:12:39,860 --> 00:12:40,670
像这样，
like this,

413
00:12:40,670 --> 00:12:44,150
在它们之间
um, there sure no boundary

414
00:12:44,150 --> 00:12:45,960
没有明确的界限。
between these two guys.

415
00:12:46,150 --> 00:12:46,810
例如，
For example,

416
00:12:46,810 --> 00:12:48,480
如果 echo
if echo

417
00:12:49,110 --> 00:12:51,900
访问这个位置，
store to location, the example belongs

418
00:12:51,900 --> 00:12:54,540
这个位于 1000 的属于 shell 的位置，
to shell like location at 1000

419
00:12:54,540 --> 00:12:56,240
并在那里写入值。
and writes value there.

420
00:12:56,410 --> 00:12:56,620
您知道，
You know,

421
00:12:56,620 --> 00:12:58,540
无论什么，比如 "x" ，
whatever "x", then it will

422
00:12:58,540 --> 00:13:00,310
它会覆盖属于 shell 的
just overwrite the physical memory of

423
00:13:00,310 --> 00:13:02,080
物理内存。
the shell memory.

424
00:13:02,380 --> 00:13:03,280
你知道这是
And so that you know be

425
00:13:03,280 --> 00:13:05,410
非常错误的，因为有了一个 bug ，
pretty undesirable, because there's a bug,

426
00:13:05,410 --> 00:13:07,030
你知道 echo 实际上
you know echo could actually percolate

427
00:13:07,030 --> 00:13:08,740
可能会渗透到 shell 中，
into the shell and you know

428
00:13:08,740 --> 00:13:09,790
调试这类东西会
it's gonna be very tricky to

429
00:13:09,790 --> 00:13:10,900
非常困难，
debug that kind of stuff, and

430
00:13:10,900 --> 00:13:12,550
所以这再一次，
so this basically again, gives us

431
00:13:12,550 --> 00:13:14,840
给我们的没有强隔离。
like no strong isolation.

432
00:13:15,350 --> 00:13:16,800
我们喜欢的是
What we like is

433
00:13:17,600 --> 00:13:19,700
有内存隔离，
to have a memory isolation,

434
00:13:19,700 --> 00:13:22,430
这样一个应用程序就不能
so that one application cannot overwrite

435
00:13:22,430 --> 00:13:25,500
覆盖另一个应用程序的内存。
means, memory of another application.

436
00:13:26,190 --> 00:13:28,100
嗯，
Um,

437
00:13:28,640 --> 00:13:30,410
所以你知道，
and so you know,

438
00:13:30,410 --> 00:13:32,510
一个原因，
one reason, you know I mean, probably the

439
00:13:32,510 --> 00:13:33,890
一个需要操作系统的
main reason to actually have an

440
00:13:33,890 --> 00:13:36,380
主要原因可能是
operating system is basically to enforce

441
00:13:36,380 --> 00:13:39,860
在复用的同时，
both multiplexing, enforce you know,

442
00:13:39,860 --> 00:13:41,380
具有强内存隔离。
strong memory isolation.

443
00:13:41,520 --> 00:13:42,390
如果你没有
If you didn't have an

444
00:13:42,390 --> 00:13:43,800
操作系统，
operating system and the applications are

445
00:13:43,800 --> 00:13:45,690
并且应用程序直接与硬件交互，
directly interacting with the hardware that

446
00:13:45,690 --> 00:13:47,200
这将很难实现。
would be very hard to achieve.

447
00:13:48,050 --> 00:13:50,390
因此，这种将操作系统
So this design of basically operating

448
00:13:50,390 --> 00:13:52,040
设计成库的设计
system as a library is not

449
00:13:52,040 --> 00:13:53,120
并不是非常常见的设计，
a very common design,

450
00:13:53,120 --> 00:13:54,440
你可能会在一些实时系统中，
you may see things some real-time

451
00:13:54,440 --> 00:13:56,960
应用程序之间相互信任的情况下看到，
systems where basically applications trust each

452
00:13:56,960 --> 00:13:59,030
但在大多数其他
other, but in most other

453
00:13:59,030 --> 00:14:00,110
操作系统中，
operating systems,

454
00:14:00,110 --> 00:14:01,400
有一个操作系统
you know there's an operating system

455
00:14:01,400 --> 00:14:02,810
来强制
that really enforce you know that

456
00:14:02,810 --> 00:14:03,980
实施这种隔离。
kind of isolation.

457
00:14:05,460 --> 00:14:06,960
因此，
So if we look a little

458
00:14:06,960 --> 00:14:09,000
如果我们从这个角度
bit now, at the unix interface

459
00:14:09,000 --> 00:14:10,300
来看 unix 接口。
from this perspective.

460
00:14:14,350 --> 00:14:16,120
我们看到接口
Then we see that the interface

461
00:14:16,120 --> 00:14:18,100
实际上是经过精心设计的。
actually is carefully designed.

462
00:14:18,650 --> 00:14:21,410
因此，在复用方面，
So that actually is feasible to

463
00:14:21,410 --> 00:14:23,900
在物理内存方面，
implement that enforced,

464
00:14:23,940 --> 00:14:26,760
实现强制隔离
um, isolation in terms of multiplexing,

465
00:14:26,760 --> 00:14:28,500
实际上是可行的，
in terms of physical memory,

466
00:14:28,500 --> 00:14:30,030
其实现方式是
and the way that is done

467
00:14:30,030 --> 00:14:32,100
接口对
is that the interface basically

468
00:14:32,100 --> 00:14:34,160
硬件做了抽象，
abstracts the hardware,

469
00:14:37,370 --> 00:14:38,860
硬件资源。
hardware resources.

470
00:14:40,940 --> 00:14:42,350
在某种程度上，
In a way that then it

471
00:14:42,350 --> 00:14:44,390
这使得实际做或
makes it easy to actually do

472
00:14:44,390 --> 00:14:45,800
不做更容易。它使得，
or not easier. It makes it

473
00:14:45,800 --> 00:14:47,360
提供这种强隔离
possible to um,

474
00:14:47,360 --> 00:14:49,680
是可能的。
provide you know this strong isolation.

475
00:14:50,280 --> 00:14:51,930
你知道，
Um, and you know maybe you

476
00:14:51,930 --> 00:14:53,280
举一些例子，
should give you some examples,

477
00:14:53,280 --> 00:14:55,980
我们已经
um, so processes we've seen

478
00:14:55,980 --> 00:14:56,790
看过的进程，像是
that like things that are

479
00:14:56,790 --> 00:14:58,120
由 fork 创建的。
created by fork.

480
00:14:59,760 --> 00:15:01,650
你知道，它们不是字面意义上的 CPU ，
You know they're not literally a

481
00:15:01,650 --> 00:15:05,100
它们对应的是
CPU, I mean, they correspond to what

482
00:15:05,100 --> 00:15:06,510
允许运行计算
cpus that allows you to

483
00:15:06,510 --> 00:15:07,820
的 CPU 。
run computation.

484
00:15:07,910 --> 00:15:08,630
但是，
But you know,

485
00:15:08,630 --> 00:15:10,520
它们不能直接与
because you know they're the applicants

486
00:15:10,520 --> 00:15:12,530
这个 CPU 交互，
cannot directly interact with this CPU,

487
00:15:12,530 --> 00:15:14,630
而只是进程抽象，
but only for this process abstraction,

488
00:15:14,630 --> 00:15:17,090
幕后的内核
the kernel behind the scenes

489
00:15:17,090 --> 00:15:18,940
可以在进程之间切换。
can switch between processes.

490
00:15:20,300 --> 00:15:22,640
因此，该操作不是
So instead of having direct CPU

491
00:15:22,640 --> 00:15:25,040
直接使用 CPU 来操作或
used to manipulate or given to

492
00:15:25,040 --> 00:15:25,940
提供给应用程序，
the application,

493
00:15:25,940 --> 00:15:28,550
而是提供
the operation provides processes, that extract

494
00:15:28,550 --> 00:15:30,230
可以在 CPU 运行的进程，
away to the CPU itself,

495
00:15:30,230 --> 00:15:31,850
因此实际上操作系统
so that actually the operating system

496
00:15:31,850 --> 00:15:34,280
是复用的，多个应用程序运行在
multiplex, and one CPU or multiple

497
00:15:34,280 --> 00:15:36,220
一个 CPU 或多个 CPU 上。
cpus among multiple applications.

498
00:15:37,200 --> 00:15:38,900
同样，如果考虑 exec ，
Similarly, if you think about exec,

499
00:15:39,970 --> 00:15:42,360
则 exec 提供的是内存镜像。
exec provides a memory image.

500
00:15:42,970 --> 00:15:45,550
嗯，还有。
Um, and um.

501
00:15:45,550 --> 00:15:46,150
阿曼达，
Amanda, yeah,

502
00:15:46,150 --> 00:15:46,720
来吧，
go ahead,

503
00:15:46,720 --> 00:15:47,780
问你的问题。
ask your question.

504
00:15:47,930 --> 00:15:49,610
关于进程有一个问题，
One question about processes,

505
00:15:49,610 --> 00:15:53,270
进程有点像 CPU 的抽象。
sort of like abstracting the CPU.

506
00:15:53,270 --> 00:15:54,400
是不是
Is that

507
00:15:55,070 --> 00:15:57,290
一个进程使用
one process uses part of the

508
00:15:57,290 --> 00:16:00,620
CPU 的一部分，
CPU and another process uses,

509
00:16:00,620 --> 00:16:02,240
而另一个进程使用该 CPU 的更多或
more, different part of that

510
00:16:02,240 --> 00:16:03,770
不同的部分，或者
CPU or a different CPU,

511
00:16:03,770 --> 00:16:05,570
如果是多核的话，
if it's a multi-core

512
00:16:05,570 --> 00:16:06,360
另一个进程使用不同的 CPU 。
or like.

513
00:16:06,450 --> 00:16:07,800
你说的进程
What do you mean by processes

514
00:16:07,800 --> 00:16:09,030
而不是 CPU 是什么意思？
instead of the CPU?

515
00:16:09,030 --> 00:16:10,830
好的，我的意思是将
Yeah, okay so I really mean

516
00:16:10,830 --> 00:16:13,380
一个 CPU 抽象成一个进程，
one CPU abstracted away into a

517
00:16:13,380 --> 00:16:14,550
所以，
process, so okay so, the way

518
00:16:14,550 --> 00:16:16,110
可以这样想这个问题，
to think about it is

519
00:16:16,110 --> 00:16:19,110
我们在实验中使用的
RISC-V core or RISC-V processor that

520
00:16:19,110 --> 00:16:21,300
RISC-V 内核或处理器
we're using in the lab is

521
00:16:21,300 --> 00:16:22,580
实际上有四个核心。
actually four cores.

522
00:16:22,930 --> 00:16:24,190
所以你可以同时或者
Um, and so you can run

523
00:16:24,190 --> 00:16:27,040
并行运行四个进程，
four processes concurrently or in parallel,

524
00:16:27,040 --> 00:16:28,880
每个核一个进程。
one process on each core.

525
00:16:29,260 --> 00:16:30,670
假设操作系统
And what the operating system does

526
00:16:30,670 --> 00:16:31,810
有 8 或 7 个
is let's say you have eight

527
00:16:31,810 --> 00:16:33,790
应用程序，
applications or seven applications,

528
00:16:33,790 --> 00:16:35,320
它将需要一些内核和复用，
it will take some core and

529
00:16:35,320 --> 00:16:37,870
不同进程之间
multiplexes, time multiplexes between

530
00:16:37,870 --> 00:16:38,590
对 CPU 的时间复用。
different processes.

531
00:16:38,590 --> 00:16:40,390
例如，它运行
So for example it will run

532
00:16:40,390 --> 00:16:42,840
一个应用程序进程 100 毫秒，
you one app process for 100 milliseconds,

533
00:16:42,990 --> 00:16:45,900
然后停止，
then stop, unload that process out

534
00:16:45,900 --> 00:16:47,430
将该进程
of the CPU or out of

535
00:16:47,430 --> 00:16:48,390
从 CPU 或内核卸载，
the core,

536
00:16:48,390 --> 00:16:49,770
加载下一个应用程序，
loading the next

537
00:16:49,770 --> 00:16:52,530
运行
application, or next process that runs

538
00:16:52,530 --> 00:16:54,270
下一个进程 100 毫秒，
out for 100 milliseconds, and

539
00:16:54,270 --> 00:16:56,040
它强制
it just enforces that no application

540
00:16:56,040 --> 00:16:57,120
没有任何应用程序或进程
can run or no process can

541
00:16:57,120 --> 00:16:58,050
运行超过 100 毫秒。
run longer than 100 milliseconds.

542
00:16:59,260 --> 00:17:00,640
我们将在几节课中
We'll see exactly how this was

543
00:17:00,640 --> 00:17:02,080
具体了解这是如何做到的，
done in a couple lectures, but

544
00:17:02,080 --> 00:17:03,420
但这是基本思想。
that's sort of the basic idea.

545
00:17:04,200 --> 00:17:06,630
好的，但是多个进程不能
Okay, but multiple processes cannot use

546
00:17:06,630 --> 00:17:08,010
同时使用同一个CPU。
the same CPU at the same time.

547
00:17:08,010 --> 00:17:11,310
是的，这是时间复用，
No, it's time multiplexing, you're running

548
00:17:11,310 --> 00:17:12,330
你先运行一段时间，
for a while then you're run

549
00:17:12,330 --> 00:17:13,520
然后下一个再运行一段时间。
the next one for a while.

550
00:17:14,050 --> 00:17:15,080
好的，谢谢。
Alright, thank you.

551
00:17:16,130 --> 00:17:17,150
好的，那么，
Okay, so um,

552
00:17:17,150 --> 00:17:18,590
考虑 exec 的一种方式是，
one way to think about exec

553
00:17:18,590 --> 00:17:22,760
它实际上是对内存的抽象。
is that actually abstracts memory.

554
00:17:28,400 --> 00:17:29,330
例如，
So, for example if you

555
00:17:29,330 --> 00:17:30,170
考虑一下，
think about,

556
00:17:30,170 --> 00:17:32,180
exec 系统调用
um, the exec system call you

557
00:17:32,180 --> 00:17:33,260
使用一个文件名，
know takes a file name,

558
00:17:33,260 --> 00:17:34,760
你知道，该文件中
you know and in that file

559
00:17:34,760 --> 00:17:36,620
是存储在
is basically the memory image

560
00:17:36,670 --> 00:17:38,230
文本中的程序的
of a program stored in

561
00:17:38,230 --> 00:17:39,310
内存镜像，
its text,

562
00:17:39,310 --> 00:17:41,920
因此它是
so it's global data

563
00:17:41,920 --> 00:17:44,410
全局数据，
in and that forms the

564
00:17:44,410 --> 00:17:47,200
构成了应用程序的内存。
memory of the application.

565
00:17:47,230 --> 00:17:49,120
应用程序可以
The application can grow

566
00:17:49,120 --> 00:17:49,660
增加其内存，
its memory,

567
00:17:49,660 --> 00:17:50,740
例如，通过调用 sbrk ，
for example by calling 'sbrk',

568
00:17:50,740 --> 00:17:53,710
通过扩展其数据段，
extend there by extending

569
00:17:53,710 --> 00:17:55,810
但它
its data segment but it

570
00:17:55,810 --> 00:17:56,890
实际上对物理内存
doesn't really have a direct

571
00:17:56,890 --> 00:17:58,210
没有直接影响，
aspects to physical memory,

572
00:17:58,210 --> 00:17:59,770
你知道，你可以
you know you can just ask

573
00:17:59,770 --> 00:18:01,740
访问
I want, you know,

574
00:18:02,150 --> 00:18:04,040
物理内存地址，
addresses physical memory,

575
00:18:04,040 --> 00:18:06,140
1000 到 2000 。
1000 to 2000.

576
00:18:06,140 --> 00:18:07,670
没有办法做到这一点，
There's no way of getting at

577
00:18:07,670 --> 00:18:09,050
同样，
that, and again the reason there's

578
00:18:09,050 --> 00:18:10,070
你也没有办法做到这一点，
no way that you can get

579
00:18:10,070 --> 00:18:11,540
因为操作系统
at that is because the operating

580
00:18:11,540 --> 00:18:13,190
提供了内存隔离，
system means to wants to provide

581
00:18:13,190 --> 00:18:15,020
控制了
memory isolation and therefore what's being

582
00:18:15,020 --> 00:18:18,740
在应用程序和
controlled to intermediate between the

583
00:18:18,740 --> 00:18:20,600
物理硬件之间的交互。
applications and the physical hardware.

584
00:18:20,720 --> 00:18:21,920
exec 是
And exec is a sort of

585
00:18:21,920 --> 00:18:23,600
一种系统调用，
system call that you know

586
00:18:23,600 --> 00:18:26,060
可以捕获或显示 TODO:
capture or shows that there's no

587
00:18:26,060 --> 00:18:28,380
不能直接访问内存。
direct access to

588
00:18:28,540 --> 00:18:30,640
这方面的另一个例子
memory. Another example of this is

589
00:18:30,640 --> 00:18:31,600
是文件。
like files.

590
00:18:33,190 --> 00:18:34,600
文件基本上都是
Files basically abstract away

591
00:18:34,600 --> 00:18:35,600
抽象出来的。 TODO:
this walks.

592
00:18:41,660 --> 00:18:43,850
比起读写
Instead of reading or writing

593
00:18:43,850 --> 00:18:46,220
计算机磁盘的
the disk blocks of the disk,

594
00:18:46,220 --> 00:18:47,960
磁盘块，
that's attached to your computer,

595
00:18:47,960 --> 00:18:49,520
实际上，在 unix 中是
um, that actually just not allowed

596
00:18:49,520 --> 00:18:50,750
不允许的，
in unix, you know the only

597
00:18:50,750 --> 00:18:52,730
与存储系统交互的唯一方式
way to interact with the storage

598
00:18:52,730 --> 00:18:54,110
是通过文件，
system is through files,

599
00:18:54,110 --> 00:18:54,920
可以读取或写入文件，
and you can read or write

600
00:18:54,920 --> 00:18:56,900
提供方便的抽象，
files, provide a convenient abstraction,

601
00:18:56,900 --> 00:18:58,280
可以命名文件，
you can name files,

602
00:18:58,280 --> 00:18:59,540
等等，
etc etc,

603
00:18:59,540 --> 00:19:01,160
操作系统就可以
but then the operating system in

604
00:19:01,160 --> 00:19:02,990
决定如何将这些文件
itself can actually decide how to

605
00:19:02,990 --> 00:19:05,270
映射到磁盘块，
map those files to a disk

606
00:19:05,270 --> 00:19:06,950
并且确保，例如，
blocks and make sure, for example

607
00:19:06,950 --> 00:19:08,510
块只出现在一个文件中，
of this block only shows up

608
00:19:08,510 --> 00:19:09,770
并且
in one file and that you

609
00:19:09,770 --> 00:19:11,570
用户 a 不能操作
know user a cannot actually you

610
00:19:11,570 --> 00:19:13,880
读写
know manipulate to read, write

611
00:19:13,880 --> 00:19:16,400
用户 b 的文件。
the files of user b.

612
00:19:16,400 --> 00:19:18,140
再说一次，
Um, and again you know this,

613
00:19:18,140 --> 00:19:20,090
你知道那种接口，
you know that sort of interface,

614
00:19:20,090 --> 00:19:22,280
文件抽象
that the file abstraction allows that

615
00:19:22,280 --> 00:19:24,680
允许在不同的用户和
sort of strong isolation between even

616
00:19:24,680 --> 00:19:27,320
甚至同一用户的不同进程之间
different users and different processes of

617
00:19:27,320 --> 00:19:28,220
进行强隔离。
the same user.

618
00:19:29,370 --> 00:19:30,630
正如你所看到的，
As you can see, that in

619
00:19:30,630 --> 00:19:32,010
在某些方面，
some ways you know the system

620
00:19:32,010 --> 00:19:32,640
系统调用接口，
call interface,

621
00:19:32,640 --> 00:19:33,600
unix 接口，
that unix interface,

622
00:19:33,600 --> 00:19:35,250
你在 util 实验中用到的，
giving programming with you know the

623
00:19:35,250 --> 00:19:36,750
是经过
util lab, seems to be sort

624
00:19:36,750 --> 00:19:39,060
精心设计的，
of carefully designed to abstract the

625
00:19:39,060 --> 00:19:40,830
以抽象研究的方式， TODO:
research in way, so that you

626
00:19:40,830 --> 00:19:41,940
所以你知道，操作系统
know, the operating system,

627
00:19:41,940 --> 00:19:43,710
接口的实现
the implementation of the interface can

628
00:19:43,710 --> 00:19:46,440
可以让多个应用程序复用资源，
actually multiply the resource of multiple

629
00:19:46,440 --> 00:19:49,740
并提供强大的隔离。
applications and provide strong, strong isolation.

630
00:19:54,120 --> 00:19:55,480
对这个，有什么问题吗？
Any questions about that?

631
00:19:56,040 --> 00:19:56,580
在聊天中有一个问题，
We have a question in

632
00:19:56,580 --> 00:19:57,810
那就是
the chat, that says do

633
00:19:57,810 --> 00:19:59,130
更复杂的内核
more complex kernel try to

634
00:19:59,130 --> 00:20:00,810
是否会尝试重新调度同一内核上的进程，
reschedule processes on the same

635
00:20:00,810 --> 00:20:02,660
以减少缓存未命中。
core to reduce cache misses.

636
00:20:02,640 --> 00:20:03,930
是的，
Oh yeah,

637
00:20:03,930 --> 00:20:06,630
有一种叫做缓存亲和性的东西，
yeah there's something called cache affinity,

638
00:20:06,630 --> 00:20:07,890
嗯，
um, um,

639
00:20:07,890 --> 00:20:09,960
你知道现代操作系统中
you know this conversion in modern

640
00:20:09,960 --> 00:20:12,600
的这种转换非常复杂，
operating systems are very sophisticated, and

641
00:20:12,600 --> 00:20:13,800
实际上你知道努力
indeed you know trying to avoid

642
00:20:13,800 --> 00:20:15,420
避免缓存未命中，类似的事情
cache misses, and things like that

643
00:20:15,420 --> 00:20:17,180
来优化性能。
and to optimize the performance.

644
00:20:17,580 --> 00:20:19,110
你们将在本学期
And you will see some of

645
00:20:19,110 --> 00:20:20,820
晚些时候看到其中的一些，
them much later in the semester

646
00:20:20,820 --> 00:20:21,600
在那里你们将谈论
where you are going to be

647
00:20:21,600 --> 00:20:23,960
高性能网络。
talking about high performence networking.

648
00:20:24,140 --> 00:20:25,680
我们会出现在那里。
We'll show up there.

649
00:20:26,280 --> 00:20:28,560
聊天中的另一个问题，
Another question from chat, where in

650
00:20:28,560 --> 00:20:29,580
在 xv6 中，我们可以看到
xv6, can we see how

651
00:20:29,580 --> 00:20:34,680
操作系统是如何对进程复用的吗？
the OS multiplex processes?

652
00:20:34,680 --> 00:20:35,850
有几个相关的文件，
There's a couple piles of files that

653
00:20:35,850 --> 00:20:37,320
但 pro.c
are relevant but proc.c

654
00:20:37,320 --> 00:20:38,820
可能是最相关的一个，
is probably the most relevant one,

655
00:20:38,820 --> 00:20:40,620
这将是
um, this will be a topic

656
00:20:40,620 --> 00:20:42,060
两三周后的
of lecture in like two or

657
00:20:42,060 --> 00:20:42,820
课程主题。
three weeks.

658
00:20:43,060 --> 00:20:43,960
我们将
And we're going to go in

659
00:20:43,960 --> 00:20:45,190
非常详细地展示
great amount of detail and show

660
00:20:45,190 --> 00:20:47,060
复用是如何发生的。
exactly how the multiplex happens.

661
00:20:48,420 --> 00:20:49,200
所以，考虑这些课程
So one way to think about

662
00:20:49,200 --> 00:20:49,980
是对操作系统
these lectures a little bit of

663
00:20:49,980 --> 00:20:50,910
很多不同部分
an introduction to a lot of

664
00:20:50,910 --> 00:20:52,440
的简介， TODO:
different pieces and,

665
00:20:52,440 --> 00:20:53,490
你知道，因为我们必须
um, you know because we've got

666
00:20:53,490 --> 00:20:54,460
从某个地方开始。
to start somewhere.

667
00:20:57,850 --> 00:20:59,440
那么，
So, um,

668
00:20:59,440 --> 00:21:01,330
我们回到
we go back into this picture

669
00:21:01,330 --> 00:21:03,160
刚才展示的
here that I showed a little

670
00:21:03,160 --> 00:21:04,660
这张图片，
while ago we have this,

671
00:21:04,660 --> 00:21:06,760
shell 运行，
um, shell running the echo running

672
00:21:06,760 --> 00:21:07,270
echo 运行
or not,

673
00:21:07,270 --> 00:21:07,840
不是那张图片，
that picture,

674
00:21:07,840 --> 00:21:08,580
是这张图片。
this picture.

675
00:21:08,810 --> 00:21:09,860
在这边，
Here on this side,

676
00:21:09,860 --> 00:21:10,910
我们有操作系统，
we've got the operating system,

677
00:21:10,910 --> 00:21:13,190
我们让应用程序运行，
we get the applications running and

678
00:21:13,190 --> 00:21:14,480
有一件事我们应该担心， TODO:
one thing we should be worried

679
00:21:14,480 --> 00:21:15,980
操作系统
about this [word] that the operating

680
00:21:15,980 --> 00:21:17,360
应该是，
system should be,

681
00:21:19,080 --> 00:21:20,600
它应该是防御性的。
um, it should be defensive.

682
00:21:23,190 --> 00:21:24,630
这是一种重要的，
This is sort of an important,

683
00:21:24,630 --> 00:21:26,220
思维模式，
a mindset you know that you

684
00:21:26,220 --> 00:21:27,720
你必须习惯
have to get used to one

685
00:21:27,720 --> 00:21:29,550
做内核开发，
user doing kernel development,

686
00:21:29,550 --> 00:21:31,830
操作系统必须确保，
um, the operating system has to

687
00:21:31,830 --> 00:21:34,710
你知道的一切
ensure, everything you know everything

688
00:21:34,710 --> 00:21:36,180
都能正常工作，
works out and so,

689
00:21:36,180 --> 00:21:37,530
所以，
um, it has to set

690
00:21:37,530 --> 00:21:38,520
它必须进行设置，
up things up so that

691
00:21:38,520 --> 00:21:39,960
这样应用程序不会
you know an app cannot

692
00:21:39,960 --> 00:21:41,500
使操作系统崩溃。
crash the operating system.

693
00:21:45,660 --> 00:21:46,860
这会很糟糕，
It would be too bad, if

694
00:21:46,860 --> 00:21:49,050
如果一个应用程序，
an application, at either by

695
00:21:49,050 --> 00:21:51,630
无论是意外的或
accident or maliciously passers are tricky

696
00:21:51,630 --> 00:21:53,730
恶意的传递错误参数给操作系统
heartened bad argument to the operating

697
00:21:53,730 --> 00:21:55,530
操作系统将会崩溃，
system and the operating system would

698
00:21:55,530 --> 00:21:57,240
这意味着服务器 TODO:
corruption that basically means for denial

699
00:21:57,240 --> 00:21:59,480
拒绝每一个其他的应用程序。
servers for every other application.

700
00:21:59,710 --> 00:22:01,300
所以操作系统的
Um, so the operating system has

701
00:22:01,300 --> 00:22:02,290
编写方式
to be written in a way

702
00:22:02,290 --> 00:22:04,300
必须能够处理和解决
that it can deal and handle

703
00:22:04,300 --> 00:22:05,920
恶意应用程序。
malicious applications.

704
00:22:06,220 --> 00:22:07,330
特别是
Um, in particular,

705
00:22:07,330 --> 00:22:09,190
另一个考虑是，
another concern is that the application

706
00:22:09,190 --> 00:22:10,420
应用程序应该不能，
should not be able,

707
00:22:10,720 --> 00:22:14,120
不能突破隔离。
cannot break out of its isolation.

708
00:22:21,230 --> 00:22:21,590
我的意思是，
I mean,

709
00:22:21,590 --> 00:22:23,990
应用程序可能是恶意的，
the application might be definitely malicious,

710
00:22:23,990 --> 00:22:27,230
可能是攻击者编写的，
maybe written by an attacker and

711
00:22:27,230 --> 00:22:29,030
攻击者可能想要
the attacker probably would like to

712
00:22:29,030 --> 00:22:31,340
突破应用程序，例如，
break out of the application, for example

713
00:22:31,340 --> 00:22:32,990
控制内核，
and take control over the kernel,

714
00:22:32,990 --> 00:22:34,040
一旦控制了
and once you have control over

715
00:22:34,040 --> 00:22:34,550
内核，
the kernel,

716
00:22:34,550 --> 00:22:36,260
你就可以做任何事情，
then you can do anything because

717
00:22:36,260 --> 00:22:37,610
因为内核控制了
the kernel is in control of

718
00:22:37,610 --> 00:22:39,040
所有的硬件资源。
all the hardware resources.

719
00:22:39,330 --> 00:22:40,470
所以操作系统
And so the operating system has

720
00:22:40,470 --> 00:22:41,280
必须能够，
to be able to come has

721
00:22:41,280 --> 00:22:42,780
必须写成防御性的，
to be written defensively,

722
00:22:42,780 --> 00:22:45,030
以避免
um, you know to avoid

723
00:22:45,030 --> 00:22:46,120
这类事情。
those kinds of things.

724
00:22:46,660 --> 00:22:47,770
这被证明，
You know, if this turns out

725
00:22:47,770 --> 00:22:49,240
要正确实现是
to be very tricky to

726
00:22:49,240 --> 00:22:50,410
非常棘手的，
actually get right,

727
00:22:50,410 --> 00:22:51,010
嗯，
um,

728
00:22:51,010 --> 00:22:52,240
实际上在 linux 中，
in fact in Linux,

729
00:22:52,240 --> 00:22:53,560
仍然有
there still

730
00:22:53,610 --> 00:22:54,720
周期性的 bug ，
periodic bugs,

731
00:22:54,720 --> 00:22:56,280
你知道内核 bug ，
you know kernel bugs or bugs

732
00:22:56,280 --> 00:22:58,770
或者允许应用程序利用或
that actually allow an applications exploited

733
00:22:58,770 --> 00:23:00,810
突破这个隔离
or to break out of this

734
00:23:00,810 --> 00:23:03,560
并获得控制的 bug 。
isolation domain and take control.

735
00:23:03,980 --> 00:23:05,720
但这是一个
Um, but it's just a continuous

736
00:23:05,720 --> 00:23:07,010
持续的问题，
concern and we'd like to do

737
00:23:07,010 --> 00:23:08,360
我们想尽可能做好这项工作。
a good job as possible.

738
00:23:08,800 --> 00:23:09,910
这就是你要有的
And this is the mindset

739
00:23:09,910 --> 00:23:10,960
思维模式，
you have to have, when

740
00:23:10,960 --> 00:23:12,280
当你开发内核，
you're developing a kernel that

741
00:23:12,280 --> 00:23:14,800
可能运行
actually applications are,

742
00:23:14,860 --> 00:23:16,620
恶意应用程序的时候。
um, perhaps malicious.

743
00:23:17,250 --> 00:23:19,620
这意味着，
You know, this means, that means it

744
00:23:19,620 --> 00:23:21,720
应用程序和
has to be strong isolation,

745
00:23:26,630 --> 00:23:28,200
操作系统之间
between the apps

746
00:23:31,500 --> 00:23:32,560
必须是强隔离的。
and OS.

747
00:23:34,470 --> 00:23:36,090
如果操作系统
If the OS you know, needs

748
00:23:36,090 --> 00:23:38,040
需要防御性，
to be defensive and needs to

749
00:23:38,040 --> 00:23:38,910
并且需要处于可以防御的位置，
be in position that can

750
00:23:38,910 --> 00:23:40,290
那么
be defensive, there has to be

751
00:23:40,290 --> 00:23:42,240
在应用程序之间必须有一堵坚固的墙，
a strong wall between the applications

752
00:23:42,240 --> 00:23:43,380
这样操作系统
so that the operating system can

753
00:23:43,380 --> 00:23:45,960
才能真正执行
actually enforce whatever policies it wants

754
00:23:45,960 --> 00:23:46,780
它想要执行的任何策略。
to enforce.

755
00:23:47,550 --> 00:23:49,500
这通常是这样做的，
And this is typically done, the

756
00:23:49,500 --> 00:23:51,450
实现这种强隔离的一般方法是
typical approach to achieving this strong

757
00:23:51,450 --> 00:23:54,200
使用硬件支持。
isolation is using hardware support.

758
00:23:57,880 --> 00:23:58,630
我们在这节课中
And we get a little bit

759
00:23:58,630 --> 00:23:59,860
稍微了解了一下，
of flavor of that in this

760
00:23:59,860 --> 00:24:00,880
但是我们会在
lecture, but we'll come back to

761
00:24:00,880 --> 00:24:02,170
后面的课中更详细地
in much more detail in subsequent

762
00:24:02,170 --> 00:24:03,700
讲到这一点。
lectures. And two,

763
00:24:03,780 --> 00:24:06,330
有两种硬件支持，
two part series hardware support,

764
00:24:06,330 --> 00:24:08,370
一个是所谓的
one is something that's called user

765
00:24:08,370 --> 00:24:09,360
用户内核模式，
kernel mode,

766
00:24:10,290 --> 00:24:11,700
"/kernel模式"。
"/kernel mode".

767
00:24:12,500 --> 00:24:14,120
在 RISC-V 中称为管理模式，
In RISC-V is called supervisor

768
00:24:14,120 --> 00:24:15,780
但是是一回事。
mode, but it's the same thing.

769
00:24:16,260 --> 00:24:18,300
在页表中， TODO:
Um, in page tables,

770
00:24:18,300 --> 00:24:19,380
虚拟内存。
virtual memory.

771
00:24:24,230 --> 00:24:27,170
所以所有处理器，
So all processors, sort of

772
00:24:27,170 --> 00:24:28,460
某种系列处理器，
series processors,

773
00:24:28,460 --> 00:24:30,620
旨在运行操作系统和
um that are intended to run

774
00:24:30,620 --> 00:24:33,170
多个应用程序的处理器，
an operating system multiple applications,

775
00:24:33,170 --> 00:24:35,930
都支持用户内核模式和
have support for user kernel mode

776
00:24:35,930 --> 00:24:36,680
虚拟内存，
and virtual memory,

777
00:24:36,680 --> 00:24:38,180
这可能表现为
you know it might be manifested

778
00:24:38,180 --> 00:24:39,890
实现方式略有不同，
were implemented in a slightly different

779
00:24:39,890 --> 00:24:42,440
但物理上所有处理器都有，
ways but physical all processors have,

780
00:24:43,180 --> 00:24:45,130
我们使用的
um, and RISC-V processor

781
00:24:45,130 --> 00:24:47,260
RISC-V 处理器
that we're using in this class

782
00:24:47,260 --> 00:24:48,980
也有这种支持。
has that support too.

783
00:24:49,450 --> 00:24:50,470
所以让我简单地说一下，
So let me talk a little

784
00:24:50,470 --> 00:24:51,310
我要先谈一下
bit, I'm going to talk a

785
00:24:51,310 --> 00:24:52,600
用户模式和
little bit about user mode,

786
00:24:52,600 --> 00:24:53,770
内核模式，
kernel mode first, and then

787
00:24:53,770 --> 00:24:54,370
然后我们再谈一下
we'll talk a little bit

788
00:24:54,370 --> 00:24:55,440
虚拟内存。
about virtual memory.

789
00:24:55,680 --> 00:24:57,660
而且大多是
Um, and mostly at the highest

790
00:24:57,660 --> 00:24:59,360
从高层级讨论的。
level possible.

791
00:24:59,500 --> 00:25:00,400
因为有很多
Because there's a lot of

792
00:25:00,400 --> 00:25:01,330
重要的细节，
important details,

793
00:25:01,330 --> 00:25:02,080
但我不能
but I won't be able to

794
00:25:02,080 --> 00:25:03,320
在这节课中包含这些。
cover those in this lecture.

795
00:25:04,840 --> 00:25:06,070
让我们首先讨论一下
So let's first talk about user

796
00:25:06,070 --> 00:25:07,000
用户内核模式。
kernel mode.

797
00:25:14,600 --> 00:25:16,100
它的意思是
And basically what it means is

798
00:25:16,100 --> 00:25:17,960
处理器有
that the processor has two modes

799
00:25:17,960 --> 00:25:19,100
两种操作模式，
of operation,

800
00:25:19,100 --> 00:25:20,660
一种是用户模式，
one is user mode and the

801
00:25:20,660 --> 00:25:21,900
另一种是内核模式。
other one is kernel mode.

802
00:25:22,360 --> 00:25:24,780
在内核模式下运行时，
And when running in kernel mode,

803
00:25:25,430 --> 00:25:28,640
CPU 可以执行特权指令。
the CPU can execute privileged instructions.

804
00:25:35,500 --> 00:25:37,330
回到第二个出局。 TODO:
Come back to the second out.

805
00:25:37,330 --> 00:25:39,260
在用户模式下运行时，
When running in user mode,

806
00:25:39,700 --> 00:25:41,860
CPU 只能执行
CPU can only execute in

807
00:25:41,860 --> 00:25:43,240
非特权指令。
unprivileged instructions.

808
00:25:49,980 --> 00:25:51,120
改进结构， TODO:
And improve the structure,

809
00:25:51,120 --> 00:25:52,680
你很熟悉的结构，
the structure you're well familiar with

810
00:25:52,680 --> 00:25:53,010
你知道，
you know,

811
00:25:53,010 --> 00:25:55,860
比如 add sub ，
think about like 'add' 'sub', adding

812
00:25:55,860 --> 00:25:57,480
把两个寄存器加在一起，
to two registers together,

813
00:25:57,480 --> 00:25:58,860
对寄存器做减法，
you know subtracting to register

814
00:25:58,860 --> 00:26:00,120
所以这是你的
so it's your basic you

815
00:26:00,120 --> 00:26:02,200
基本过程调用，
know procedure calls,

816
00:26:02,270 --> 00:26:03,470
你的 jr ，
your jr,

817
00:26:03,470 --> 00:26:05,300
所有这类东西分支，
all that kind of stuff branches,

818
00:26:05,300 --> 00:26:06,620
这些都是
those are all

819
00:26:07,430 --> 00:26:09,410
没有特权的指令，
um, unprivileged instructions that any

820
00:26:09,410 --> 00:26:11,300
任何用户应用程序都允许执行。
user application is allowed to execute.

821
00:26:12,030 --> 00:26:15,030
特权结构基本上是
Privileged structures are structures that basically

822
00:26:15,030 --> 00:26:18,180
直接操作
are involved in manipulating the

823
00:26:18,180 --> 00:26:19,230
硬件的结构，
hardware directly,

824
00:26:19,230 --> 00:26:21,330
您知道设置保护
you know setting up protections and

825
00:26:21,330 --> 00:26:21,900
之类的东西，
things like that,

826
00:26:21,900 --> 00:26:22,890
例如设置
so for example setting up a

827
00:26:22,890 --> 00:26:24,260
页表寄存器。
page table register.

828
00:26:27,450 --> 00:26:28,800
我们稍后会谈到，
Which we'll talk about later,

829
00:26:28,800 --> 00:26:30,240
嗯，
um were,

830
00:26:31,840 --> 00:26:33,760
设置
you know, setting the disabling

831
00:26:33,760 --> 00:26:34,920
禁用时钟中断。
clock interrupts.

832
00:26:39,320 --> 00:26:40,100
所以在处理器上
So there are all kinds of

833
00:26:40,100 --> 00:26:42,110
有各种类型的状态，
sort of state on the processor

834
00:26:42,110 --> 00:26:43,760
操作系统
that the operating system intended to

835
00:26:43,760 --> 00:26:46,340
使用这些状态，
use and manipulating that state you

836
00:26:46,340 --> 00:26:47,450
你知道，
know completely,

837
00:26:47,450 --> 00:26:49,840
这种状态是针对特权指令完成的。
um, is done for privileged instructions.

838
00:26:50,360 --> 00:26:50,630
因此，
And so,

839
00:26:50,630 --> 00:26:51,560
例如当用户应用程序
for example when a user

840
00:26:51,560 --> 00:26:53,720
试图执行
application tries to actually execute

841
00:26:53,720 --> 00:26:55,020
特权指令时。
a privilege instruction.

842
00:26:55,250 --> 00:26:57,320
进程规则将不会执行，
Then the process rules won't

843
00:26:57,320 --> 00:26:59,810
因为如果个人指令 TODO:
execute because if personal instruction user

844
00:26:59,810 --> 00:27:01,700
用户模式是不允许的，
mode is disallowed and basically

845
00:27:01,700 --> 00:27:03,980
这将导致控制
that will result in the transfer

846
00:27:03,980 --> 00:27:06,170
从用户模式转移到
control from user space from user

847
00:27:06,170 --> 00:27:07,250
内核模式，
mode to kernel mode so that

848
00:27:07,250 --> 00:27:08,540
这样操作系统就可以
then the operating system can actually

849
00:27:08,540 --> 00:27:09,650
实际控制，也许会因为行为不端
take control and maybe if I

850
00:27:09,650 --> 00:27:12,040
而停止应用程序。
kill the application because of misbehaving.

851
00:27:12,960 --> 00:27:14,670
为了理解
To get a little bit

852
00:27:14,670 --> 00:27:15,720
这个，
of sense,

853
00:27:15,720 --> 00:27:17,280
特权指令和
um, the difference between the two

854
00:27:17,280 --> 00:27:19,280
非特权指令之间的区别。
and privilege and imprivilege instructions.

855
00:27:19,380 --> 00:27:21,720
嗯，让我把显示屏 TODO:
Um, let me switch display

856
00:27:21,720 --> 00:27:22,780
切换到第二个。
for second.

857
00:27:22,860 --> 00:27:24,480
在右侧，
And here on the right side,

858
00:27:24,480 --> 00:27:26,010
你必须显示的
you have to display is

859
00:27:26,010 --> 00:27:26,760
是一个文档，
a document,

860
00:27:26,760 --> 00:27:28,680
这是 RISC-V
you know the RISC-V

861
00:27:28,890 --> 00:27:32,400
特权结构文档，该文档
privilege architecture document and that document

862
00:27:32,400 --> 00:27:34,110
包含所有特权指令，
contains all the privilege instructions,

863
00:27:34,110 --> 00:27:35,860
它是从网站链接来的。
it's linked from the website.

864
00:27:35,940 --> 00:27:39,360
在 perferences 页面下，
Um, under the preferences page and

865
00:27:39,360 --> 00:27:41,730
在接下来的几周或
in the next couple of weeks

866
00:27:41,730 --> 00:27:44,070
几乎一个月内，
or almost months,

867
00:27:44,070 --> 00:27:45,630
你会看到
you will be playing around you

868
00:27:45,630 --> 00:27:47,280
所有这些特权指令，
know all these privileged instructions,

869
00:27:47,280 --> 00:27:48,420
你知道，
you know,

870
00:27:48,420 --> 00:27:50,130
所有特权指令都显示在这里，
are shown here and in

871
00:27:50,130 --> 00:27:52,170
事实上，它们中的许多都会出现，
fact many of them will show

872
00:27:52,170 --> 00:27:53,520
其中一些
up and some of them want

873
00:27:53,520 --> 00:27:54,360
会在下一节课中出现，
to show up in the next

874
00:27:54,360 --> 00:27:56,040
并提供更多的细节。
lecture in a great mount of detail.

875
00:27:56,280 --> 00:27:57,900
但是用户认为
Um, but users think about this

876
00:27:57,900 --> 00:28:00,210
这是特权指令是
as there are privilege instructions that

877
00:28:00,210 --> 00:28:01,470
用户应用程序不能执行的，
user applications should not be able

878
00:28:01,470 --> 00:28:03,330
只能
to execute and those can only

879
00:28:03,330 --> 00:28:04,660
在内核模式下执行。
be executed in kernel mode.

880
00:28:05,810 --> 00:28:08,240
这是强隔离
So that's one aspect of you

881
00:28:08,240 --> 00:28:09,710
一个方面，
know this sort of hardware support

882
00:28:09,710 --> 00:28:11,000
由硬件支持。
for strong isolation.

883
00:28:11,340 --> 00:28:12,270
是的，
Um, yeah,

884
00:28:12,270 --> 00:28:12,570
Amanda ，说出你的问题。
Amanda, go head.

885
00:28:13,750 --> 00:28:15,820
我想问一个简短的问题，
Just a quick question like,

886
00:28:15,820 --> 00:28:17,800
比如，
um, the what I'm imagining

887
00:28:17,800 --> 00:28:18,760
我脑海中的想象是，
in my head is something

888
00:28:18,760 --> 00:28:20,950
如果内核模式允许
like if kernel mode allow

889
00:28:20,950 --> 00:28:22,780
或不允许那个，
else don't like what,

890
00:28:22,780 --> 00:28:24,910
那么是谁在运行该代码
who is running that code and

891
00:28:24,910 --> 00:28:26,200
并检查其是否是内核模式，
checking if its kernel mode,

892
00:28:26,200 --> 00:28:27,250
它们如何知道
how do they know if it's

893
00:28:27,250 --> 00:28:28,960
它是否处于内核模式，
in kernel mode like a flag

894
00:28:28,960 --> 00:28:29,800
比如标志或其他什么。
or something.

895
00:28:29,900 --> 00:28:31,970
是的，基本上是标记处理器，
Yes, basically flagging the processor,

896
00:28:31,970 --> 00:28:33,920
字面上，处理器中
literally there are a bit

897
00:28:33,920 --> 00:28:34,850
有一个位来表示，
in the processor,

898
00:28:34,850 --> 00:28:36,350
那就是
that's just you know user

899
00:28:36,350 --> 00:28:36,830
用户模式
mode,

900
00:28:36,830 --> 00:28:38,540
用 1 表示，
1 is saying,

901
00:28:38,640 --> 00:28:40,650
通常 1 是用户模式，
typically 1 is user mode,

902
00:28:40,650 --> 00:28:41,980
0 是内核模式。
0 is kernel mode.

903
00:28:42,360 --> 00:28:43,920
因此，
And so when the processor decodes

904
00:28:43,920 --> 00:28:45,060
当处理器解码指令时，
an instruction,

905
00:28:45,060 --> 00:28:46,410
查看操作码，
looks at the op code

906
00:28:46,410 --> 00:28:47,490
如果操作码
if the op code is a

907
00:28:47,490 --> 00:28:50,190
是特权指令
privilege instruction and the bit is

908
00:28:50,190 --> 00:28:51,840
并且位被设置为 1 ，则拒绝
set to 1 and will deny

909
00:28:51,840 --> 00:28:53,200
执行该指令。
executing that instruction.

910
00:28:54,420 --> 00:28:56,880
你知道，除以零的操作，
You know divided by zero, you're not

911
00:28:56,880 --> 00:28:57,840
就是不被允许。
allowed to do that.

912
00:28:58,130 --> 00:28:59,780
好的，但是如果那个位 TODO:
Okay, but if that bit

913
00:28:59,780 --> 00:29:01,130
以某种方式改变了，
has changed in some way

914
00:29:01,130 --> 00:29:02,390
你只能覆盖那个位，
you were just able to

915
00:29:02,390 --> 00:29:04,610
那么
overwrite that bit then that's

916
00:29:04,610 --> 00:29:06,170
这是唯一可以控制的，
the only thing controlling yeah,

917
00:29:06,170 --> 00:29:07,430
那么你认为
so what do you think

918
00:29:07,430 --> 00:29:09,020
覆盖位的指令
what the instruction that overwrites

919
00:29:09,020 --> 00:29:10,220
是什么，
a bit is that

920
00:29:10,220 --> 00:29:12,440
特权指导者的非特权指令。
privilege instructor unprivileged instruction.

921
00:29:19,460 --> 00:29:20,580
有什么问题吗。
Is there a question.

922
00:29:22,970 --> 00:29:25,820
清除设置该位的指令
Clear the instruction that sets the

923
00:29:25,820 --> 00:29:27,800
必须是特权指令，
bit must be privilege instruction because

924
00:29:27,800 --> 00:29:29,420
因为用户应用程序
the user application should not be

925
00:29:29,420 --> 00:29:30,470
不能将该位设置为
able to set the bit to

926
00:29:30,470 --> 00:29:31,070
内核模式。
kernel mode.

927
00:29:31,070 --> 00:29:32,450
正确，然后才能
Correct and then be able

928
00:29:32,450 --> 00:29:34,310
运行所有类型的
to actually run all kinds

929
00:29:34,310 --> 00:29:35,420
特权指令。
of privilege instructions.

930
00:29:36,000 --> 00:29:37,400
因此数据是受保护的。
And so that data is protected.

931
00:29:39,210 --> 00:29:40,180
你理解了吗？
Does that make sense?

932
00:29:40,780 --> 00:29:41,980
好的。
Okay, yeah.

933
00:29:44,130 --> 00:29:45,300
嗯，好的，
Um, OK good,

934
00:29:45,300 --> 00:29:46,140
那么，
so um,

935
00:29:46,140 --> 00:29:47,220
那就是用户内核模式，
so that's user kernel mode

936
00:29:47,220 --> 00:29:48,270
或者至少你知道
or at least you know the

937
00:29:48,270 --> 00:29:50,160
用户内核模式的大概，
top view user kernel mode,

938
00:29:50,160 --> 00:29:51,360
结果是 RISC-V
turns out to RISC-V

939
00:29:51,360 --> 00:29:52,800
有很多人问到的
has a number of you

940
00:29:52,800 --> 00:29:54,270
第三种模式，
asked about have a third

941
00:29:54,270 --> 00:29:55,800
叫做机器模式。
mode called machine mode.

942
00:29:55,920 --> 00:29:57,630
我们基本上会忽略这一点，
Um, we're mostly going to ignore

943
00:29:57,630 --> 00:29:59,160
我很肯定地说，
that and so I'm very much

944
00:29:59,160 --> 00:30:00,990
基本上这是一个亮点， TODO:
say about it basically it's one

945
00:30:00,990 --> 00:30:02,430
因为基本上是
more light because basically three levels

946
00:30:02,430 --> 00:30:03,960
三个级别的特权，
of privileges instead of two levels

947
00:30:03,960 --> 00:30:04,860
替代两个级别的特权。
of privileges.

948
00:30:05,290 --> 00:30:06,400
Amir ，说吧。
Amir, go ahead.

949
00:30:07,770 --> 00:30:09,660
好的，我想知道
Alright, so I'm wondering with respect

950
00:30:09,660 --> 00:30:10,440
在安全方面，
to security,

951
00:30:10,440 --> 00:30:13,020
如果所有的用户代码
if all user code does go

952
00:30:13,020 --> 00:30:13,650
都通过内核，
through the kernel,

953
00:30:13,650 --> 00:30:14,700
那么其意图
the intent is that things

954
00:30:14,700 --> 00:30:15,630
是安全的，
are secure,

955
00:30:15,630 --> 00:30:17,760
但是有没有一种方式
but is there a way for

956
00:30:17,880 --> 00:30:19,380
让计算机的用户
um, a user of the

957
00:30:19,380 --> 00:30:22,950
完全绕过
computer to completely go around

958
00:30:22,950 --> 00:30:24,380
操作系统呢？
the operating system.

959
00:30:25,180 --> 00:30:26,620
不，不完全是，
No, not really,

960
00:30:26,620 --> 00:30:28,540
至少你知道，
at least you know if done

961
00:30:28,540 --> 00:30:30,000
如果做得不小心的话。
carefully not.

962
00:30:32,700 --> 00:30:34,170
如果可能的话，
And if possible like you know

963
00:30:34,170 --> 00:30:35,250
就像那样，
that might be the case that

964
00:30:35,250 --> 00:30:37,360
有些程序可能会有额外的特权。
some programs have additional privileges.

965
00:30:37,540 --> 00:30:39,010
操作系统会
Um, that the operating system

966
00:30:39,010 --> 00:30:40,780
重视的。
will respect.

967
00:30:41,020 --> 00:30:42,520
但是这些特权并不是
Um, but those privileges are not

968
00:30:42,520 --> 00:30:44,440
给每个用户的，你知道，
given to every user, you know, only

969
00:30:44,440 --> 00:30:46,120
只有 root 用户才有
root user has certain

970
00:30:46,120 --> 00:30:48,370
某些特权，允许你进行
privileges that allow you to do

971
00:30:48,370 --> 00:30:50,320
对安全敏感的操作。
security sensitive operations.

972
00:30:50,860 --> 00:30:53,860
那么BIOS呢？
What about BIOS, does BIOS

973
00:30:53,860 --> 00:30:56,530
BIOS 发生在操作系统之前还是之后。
happened before OS or after. Yeah,

974
00:30:56,530 --> 00:30:59,800
是的，所以 BIOS 是
so the BIOS is a piece

975
00:30:59,800 --> 00:31:01,600
计算机附带
of software that basically comes

976
00:31:01,600 --> 00:31:02,980
的一个软件，
with the computer,

977
00:31:02,980 --> 00:31:04,090
嗯，
um and um,

978
00:31:04,090 --> 00:31:06,280
那是先启动的，
that's booted first and the BIOS

979
00:31:06,280 --> 00:31:06,820
BIOS 引导
basically boots,

980
00:31:06,820 --> 00:31:08,050
操作系统，
the operating system,

981
00:31:08,050 --> 00:31:09,280
嗯，所以 BIOS 是一段
um, so the BIOS is a

982
00:31:09,280 --> 00:31:11,080
可信任的代码。
trusted piece of code.

983
00:31:11,450 --> 00:31:12,950
最好是正确的，
And better be correct and better

984
00:31:12,950 --> 00:31:14,360
最好不是恶意的。
be not malicious.

985
00:31:16,940 --> 00:31:17,510
Noah ，
Noah,

986
00:31:17,510 --> 00:31:18,200
说吧。
go ahead.

987
00:31:19,310 --> 00:31:19,970
嗯，是的，
Um, yeah,

988
00:31:19,970 --> 00:31:21,800
所以
so you mentioned that the

989
00:31:21,800 --> 00:31:23,690
你提到了
you know the instruction to

990
00:31:23,690 --> 00:31:24,920
设置
set the um,

991
00:31:24,920 --> 00:31:26,180
内核模式位是
the kernel mode bit is a

992
00:31:26,180 --> 00:31:27,590
特权指令，
privileged instruction,

993
00:31:27,590 --> 00:31:29,690
用户程序 TODO:
how would a user program ever,

994
00:31:29,690 --> 00:31:31,010
怎么能像
then be able to you

995
00:31:31,010 --> 00:31:33,650
完全拥有
know get like you essentially

996
00:31:33,650 --> 00:31:34,460
内核一样，
have the kernel,

997
00:31:34,460 --> 00:31:35,990
执行任何内核指令，
execute any kernel instructions,

998
00:31:35,990 --> 00:31:38,270
如果就像访问内核模式
if like the [very] instructions to

999
00:31:38,270 --> 00:31:40,160
的指令本身
access kernel mode is itself a

1000
00:31:40,160 --> 00:31:41,480
就是一条特权指令，
privileged instruction I guess it seems

1001
00:31:41,480 --> 00:31:43,490
我想应该有一个屏障，
like there's immediately a barrier for

1002
00:31:43,490 --> 00:31:45,940
让用户程序改变这一位。
user program ever changing that bit.

1003
00:31:45,990 --> 00:31:48,630
是的，这是正确的，
Yeah yeah that's correct and that's

1004
00:31:48,630 --> 00:31:49,500
这就是我们想要的方式，
exactly the way we want,

1005
00:31:49,500 --> 00:31:50,370
这是正确的，
that's correct,

1006
00:31:50,370 --> 00:31:51,660
所以可以
um, so one way to think

1007
00:31:51,660 --> 00:31:52,140
这样想，
about it,

1008
00:31:52,140 --> 00:31:53,370
这并不完全是
and this is not exactly how

1009
00:31:53,370 --> 00:31:54,750
RISC-V 上的工作方式，
it works on the RISC-V,

1010
00:31:54,750 --> 00:31:57,060
但是如果你在用户空间
but if you execute a privilege

1011
00:31:57,060 --> 00:31:58,560
执行特权指令，
instruction in user space will try

1012
00:31:58,560 --> 00:31:59,880
就会尝试
to execute a privileged

1013
00:31:59,880 --> 00:32:01,280
执行特权指令……
instruction...

1014
00:33:08,220 --> 00:33:08,760
我回来了，
I'm back,

1015
00:33:08,760 --> 00:33:10,590
不好意思，
sorry about that I look like

1016
00:33:10,590 --> 00:33:15,380
看起来我的 zoom 客户端崩溃了。
my zoom client crashed on me.

1017
00:33:17,500 --> 00:33:18,670
再次道歉，
I apologize for that I don't

1018
00:33:18,670 --> 00:33:19,930
我不知道为什么，
really know why,

1019
00:33:19,930 --> 00:33:21,080
但它确实发生了。
but it did.

1020
00:33:25,620 --> 00:33:27,060
大家能听到我说话吗？
Can everybody hear me again?

1021
00:33:27,860 --> 00:33:28,910
是的，你很好，
Yep, you're good,

1022
00:33:28,910 --> 00:33:29,660
一切都很好，
all good,

1023
00:33:29,660 --> 00:33:30,440
好的。
all right.

1024
00:33:31,460 --> 00:33:36,740
好吧，某个地方有个 bug ，好的，
Well there's somewhere a bug, okay,

1025
00:33:36,740 --> 00:33:40,080
那么回到，
um, so back to, um,

1026
00:33:42,080 --> 00:33:44,000
回到
back to a second piece

1027
00:33:44,000 --> 00:33:45,710
几乎所有 CPU 都
of hardware support which

1028
00:33:45,710 --> 00:33:47,750
提供的第二个硬件支持，
almost all CPU provide,

1029
00:33:47,750 --> 00:33:49,440
CPU 提供
whith CPU's

1030
00:33:49,980 --> 00:33:51,500
虚拟内存。
provide virtual memory.

1031
00:34:02,870 --> 00:34:03,860
我将在周三
I'm going to talk about this

1032
00:34:03,860 --> 00:34:07,130
更详细地谈到这一点，
on wednesday in much more detail

1033
00:34:07,130 --> 00:34:09,200
但基本上这个过程
but basically the process has something

1034
00:34:09,200 --> 00:34:09,650
有一些东西，
you know what,

1035
00:34:09,650 --> 00:34:11,060
被称为页表。
it's called page table.

1036
00:34:12,180 --> 00:34:13,440
你已经看到了这一点，
And you've seen this a little

1037
00:34:13,440 --> 00:34:15,270
我认为 6.004
bit I think 6.004 the

1038
00:34:15,270 --> 00:34:15,930
页表
page table,

1039
00:34:15,930 --> 00:34:18,220
基本上是将虚拟地址
basically maps virtual addresses

1040
00:34:21,550 --> 00:34:23,000
映射到物理地址。
to physical addresses.

1041
00:34:25,380 --> 00:34:26,550
其基本思想是
And the basic idea is to

1042
00:34:26,550 --> 00:34:27,920
给每个进程
give every process,

1043
00:34:28,680 --> 00:34:30,080
提供自己的页表。
its own page table.

1044
00:34:34,330 --> 00:34:36,740
这样，
In this way,

1045
00:34:38,130 --> 00:34:39,990
进程实际上只能使用，
the process can actually only use

1046
00:34:39,990 --> 00:34:41,520
只允许访问
whereas only allowed to access that

1047
00:34:41,520 --> 00:34:42,990
该页表中显示的
piece of physical memory that actually

1048
00:34:42,990 --> 00:34:44,640
那块物理内存。
shows up in this page table.

1049
00:34:44,670 --> 00:34:45,570
所以如果你设置，
And so if you set up

1050
00:34:45,570 --> 00:34:46,710
操作系统
if the operating system sets

1051
00:34:46,710 --> 00:34:47,700
设置页表的
the page tables up in a

1052
00:34:47,700 --> 00:34:49,560
方式，
way that um,

1053
00:34:49,560 --> 00:34:51,630
每个进程都有不相交的
every process has disjoint

1054
00:34:51,630 --> 00:34:52,560
物理内存，
physical memory,

1055
00:34:52,560 --> 00:34:54,390
那么一个进程不能访问
then a process can't even access

1056
00:34:54,390 --> 00:34:56,160
其他进程的物理内存，
somebody else's physical memory because it's

1057
00:34:56,160 --> 00:34:57,540
因为它甚至不是页表，
not even it's page tables,

1058
00:34:57,540 --> 00:34:58,860
所以甚至没有办法
so there's no way even

1059
00:34:58,860 --> 00:35:00,030
创建一个地址或者
to create an address or

1060
00:35:00,030 --> 00:35:01,590
写入一个允许一个进程
write down an address that

1061
00:35:01,590 --> 00:35:02,700
访问其他进程的
will allow a process to

1062
00:35:02,700 --> 00:35:05,260
物理内存的地址。
access somebody else's physical memory.

1063
00:35:05,380 --> 00:35:06,610
所以这给了我们
And so this gives us strong

1064
00:35:06,610 --> 00:35:07,800
强内存隔离。
memory isolation.

1065
00:35:09,950 --> 00:35:12,770
基本上，页表定义了
Basically page table defines a view

1066
00:35:12,770 --> 00:35:13,580
一个关于内存的视图，
on memory,

1067
00:35:13,580 --> 00:35:15,530
每个应用程序，
and every application,

1068
00:35:15,530 --> 00:35:17,120
每个用户进程都有
every user process has its own

1069
00:35:17,120 --> 00:35:18,420
自己的内存视图，
view of memory,

1070
00:35:18,470 --> 00:35:19,820
彼此独立。
independent of each other.

1071
00:35:20,220 --> 00:35:21,780
这给了我们非常强的
And this gives us very strong

1072
00:35:21,780 --> 00:35:23,220
内存隔离。
memory isolation.

1073
00:35:24,310 --> 00:35:25,690
现在我们能做的是，
And so now what we can

1074
00:35:25,690 --> 00:35:26,350
如果我们能以这种方式
do if we can think a

1075
00:35:26,350 --> 00:35:27,670
思考一点，
little bit in this way,

1076
00:35:27,670 --> 00:35:30,430
那么我们就能更早地
then we can redraw the picture

1077
00:35:30,430 --> 00:35:32,290
重新画出这幅图，
a little bit earlier and because

1078
00:35:32,290 --> 00:35:33,400
因为我们是这样思考的，
we're thinking about these as follows,

1079
00:35:33,400 --> 00:35:34,680
所以你就有了这个方框。
you have the box.

1080
00:35:35,600 --> 00:35:37,220
是的， ls 在
Yeah and ls sits in

1081
00:35:37,220 --> 00:35:38,720
那个盒子里，
that box and there's

1082
00:35:38,720 --> 00:35:40,160
还有另一个盒子，
another box,

1083
00:35:41,190 --> 00:35:42,920
echo 在那个盒子里。
when echo sits in that box.

1084
00:35:43,730 --> 00:35:45,230
在一个盒子里，
In a box basically has an

1085
00:35:45,230 --> 00:35:47,000
基本上有一个地址虚拟地址，
address virtual address range starting from

1086
00:35:47,000 --> 00:35:49,160
范围从 0 开始，
0 to whatever some number

1087
00:35:49,160 --> 00:35:50,720
到某个数字的幂。
to the power whatever

1088
00:35:50,780 --> 00:35:53,420
在 RISC-V 中，
number is. Um, in RISC-V, which

1089
00:35:53,420 --> 00:35:55,700
我们将在周三讨论，
we'll talk about on Wednesday and

1090
00:35:55,700 --> 00:35:57,590
同时，echo
similarly you know the address range

1091
00:35:57,590 --> 00:35:59,750
的地址范围是类似
for echo is something whatever

1092
00:35:59,750 --> 00:36:01,580
2^x 这样的。
same to 2^x.

1093
00:36:02,070 --> 00:36:04,200
因此 ls 的
And so ls has in

1094
00:36:04,200 --> 00:36:06,150
内存位置包含 0 ，
memory location 0, echo has a

1095
00:36:06,150 --> 00:36:07,770
echo 的位置包含 0 ，
location like a 0, and users

1096
00:36:07,770 --> 00:36:08,910
并且用户完全分开，
completely separated,

1097
00:36:08,910 --> 00:36:10,470
如果操作系统将
and if the operating system maps

1098
00:36:10,470 --> 00:36:12,150
这些虚拟地址 0 映射到
those virtual addresses 0 to different

1099
00:36:12,150 --> 00:36:14,700
不同的物理地址，
pieces of physical addresses then basically

1100
00:36:14,700 --> 00:36:16,500
那么 ls 不能访问 echo 的内存，
ls cannot access echo's memory and

1101
00:36:16,500 --> 00:36:18,560
echo 也不能访问 ls 的内存。
echo cannot access ls's memory.

1102
00:36:19,040 --> 00:36:21,140
类似的，你知道，内核实际上
Um, similarly the kernel actually you

1103
00:36:21,140 --> 00:36:22,380
位于它的下面。
know sits below it.

1104
00:36:22,560 --> 00:36:23,910
它也有自己的，
It also has its own, at

1105
00:36:23,910 --> 00:36:25,530
至少在 xv6 中，
least in xv6, has its own

1106
00:36:25,530 --> 00:36:26,600
有自己的地址范围。
address range.

1107
00:36:26,590 --> 00:36:28,660
独立于应用程序。
Um, independent of the applications.

1108
00:36:29,080 --> 00:36:30,370
我们可以考虑
And we could think about the

1109
00:36:30,370 --> 00:36:31,660
用户内核模式，
user kernel mode,

1110
00:36:31,660 --> 00:36:33,430
位于两者之间，
sort of sitting in between you

1111
00:36:33,430 --> 00:36:34,360
你知道边界，
know the boundary,

1112
00:36:34,360 --> 00:36:36,620
你知道实际运行的东西。
you know things that actually run.

1113
00:36:36,760 --> 00:36:39,060
在用户空间中运行用户模式。
In user space running user mode.

1114
00:36:41,020 --> 00:36:41,800
以及位于内核空间
And things that sit in the

1115
00:36:41,800 --> 00:36:43,420
运行内核模式。
kernel running kernel mode.

1116
00:36:47,580 --> 00:36:48,840
这是你应该知道的
And that's sort of the picture

1117
00:36:48,840 --> 00:36:50,460
操作系统的图片，
that you should actually know OS, you

1118
00:36:50,460 --> 00:36:51,450
你知道，
know sits there you know,

1119
00:36:51,450 --> 00:36:52,260
在内核模式下，
sitting in kernel mode,

1120
00:36:52,260 --> 00:36:53,580
所以这是你应该在
so this is the picture,

1121
00:36:53,580 --> 00:36:55,820
脑海中看到的图片。
you should have in your head.

1122
00:36:56,570 --> 00:36:58,190
正如到目前为止
Now, as described so far

1123
00:36:58,190 --> 00:36:58,880
所描述的，
this picture is a little

1124
00:36:58,880 --> 00:36:59,840
这张图片有点太严格了，
bit too strict,

1125
00:36:59,840 --> 00:37:01,070
你知道我们
you know we have a basically

1126
00:37:01,070 --> 00:37:02,480
把所有的东西都放在一个盒子里，
put everything in a box but

1127
00:37:02,480 --> 00:37:03,710
但是没有办法让一个盒子把控制权
there's no way for one box

1128
00:37:03,710 --> 00:37:05,640
转移到另一个盒子。
to transfer control to another box.

1129
00:37:05,840 --> 00:37:07,670
很显然，需要这些，
Clearly what needs to happen, because

1130
00:37:07,670 --> 00:37:09,410
因为比如 ls 可能想要
your example ls, you know probably want

1131
00:37:09,410 --> 00:37:10,300
调用，
to call,

1132
00:37:10,400 --> 00:37:11,810
你知道 read, read
you know, read, the read

1133
00:37:11,810 --> 00:37:12,800
系统调用。
system call.

1134
00:37:13,260 --> 00:37:15,630
或者 write 系统调用，
Or write system call or maybe

1135
00:37:15,630 --> 00:37:15,960
或者你知道的，
you know,

1136
00:37:15,960 --> 00:37:17,370
shell 想要调用 fork 或
whatever the shell want to call

1137
00:37:17,370 --> 00:37:18,900
exec 的任何东西。
fork or exec.

1138
00:37:18,950 --> 00:37:19,190
因此，
And so,

1139
00:37:19,190 --> 00:37:20,450
必须有一种方法
there has to be a way

1140
00:37:20,450 --> 00:37:22,970
让应用程序或用户应用程序
for an application or user application

1141
00:37:22,970 --> 00:37:25,100
以协调的方式将控制权
to transfer control in a coordinated

1142
00:37:25,100 --> 00:37:27,920
转移到内核，
manner to the kernel,

1143
00:37:27,920 --> 00:37:29,030
这样内核才能真正
so the kernel can actually

1144
00:37:29,030 --> 00:37:30,160
提供服务。
provide services.

1145
00:37:30,940 --> 00:37:32,800
嗯，那么
Um, and so,

1146
00:37:32,800 --> 00:37:34,540
这个还有一个方案，
um there's a plan basically in

1147
00:37:34,540 --> 00:37:35,410
除了这个，
addition to this,

1148
00:37:35,410 --> 00:37:36,700
我到目前为止
um, two pieces of hardware support

1149
00:37:36,700 --> 00:37:38,860
讲到的两个硬件支持，
I talked so far, talked about

1150
00:37:38,860 --> 00:37:40,920
到目前为止讲到的是
so far is a way

1151
00:37:41,000 --> 00:37:43,070
一种有控制的
of a controlled way of entering

1152
00:37:43,070 --> 00:37:43,860
进入内核的方式。
the kernel.

1153
00:37:49,440 --> 00:37:51,390
其实 RISC-V
It turns out actually RISC-V,

1154
00:37:51,390 --> 00:37:53,400
有一个指令，
there is an instruction,

1155
00:37:53,400 --> 00:37:54,690
这个叫做
um, for this,

1156
00:37:54,690 --> 00:37:56,680
ecall 指令。
it's called the 'ecall' instruction.

1157
00:37:58,000 --> 00:37:59,020
ecall 指令，
And ecall instruction,

1158
00:37:59,020 --> 00:38:01,100
它接受一个参数，一个数字。
it takes one argument, a number.

1159
00:38:02,200 --> 00:38:04,090
因此，当一个应用程序
And so when a user application

1160
00:38:04,090 --> 00:38:05,620
想要将控制权转移到
that wants to transfer control

1161
00:38:05,620 --> 00:38:07,480
内核，它应该
into the kernel basically called the

1162
00:38:07,480 --> 00:38:09,610
调用 ecall 指令，
ecall instruction with numbers like two

1163
00:38:09,610 --> 00:38:11,110
使用数字 2 3 或 4 5 ，
or three or four five and

1164
00:38:11,110 --> 00:38:12,850
这个数字就是
that number basically is the system

1165
00:38:12,850 --> 00:38:13,740
这个应用程序想要调用的
call number,

1166
00:38:14,950 --> 00:38:16,720
系统调用的编号。
that the application wants to invoke.

1167
00:38:21,740 --> 00:38:23,480
然后，
And then basically what that does

1168
00:38:23,480 --> 00:38:25,040
在 xv6 中我们看到，
and actually enters the kernel at

1169
00:38:25,040 --> 00:38:28,340
它在内核中
a particular point or particular

1170
00:38:28,340 --> 00:38:31,700
特定的点或
location in the kernel that's controlled by

1171
00:38:31,700 --> 00:38:33,680
特定位置
the kernel as we'll see

1172
00:38:33,680 --> 00:38:34,460
进入内核，
in xv6,

1173
00:38:34,460 --> 00:38:36,560
我的意思是在后面的一些课程里，
I mean some later lectures,

1174
00:38:36,560 --> 00:38:38,240
你知道只有
um, you know there's basically a

1175
00:38:38,240 --> 00:38:41,060
一个系统调用入口点。
single system call entry point.

1176
00:38:41,090 --> 00:38:42,680
而且，
And, um,

1177
00:38:42,680 --> 00:38:44,360
每次应用程序调用 ecall 时，
and every time an application calls

1178
00:38:44,360 --> 00:38:46,070
都知道应用程序
ecall, you know the application

1179
00:38:46,070 --> 00:38:47,820
进入内核的那个特定点。
enters the kernel that particular point.

1180
00:38:48,590 --> 00:38:49,310
所以，一种，
So, one,

1181
00:38:49,310 --> 00:38:51,020
一种方式来
um, one way to think

1182
00:38:51,020 --> 00:38:52,370
考虑这个问题，
about this is that if

1183
00:38:52,370 --> 00:38:53,420
如果你使用 fork 。
you have fork.

1184
00:38:53,900 --> 00:38:54,710
你知道 fork ，
You know fork,

1185
00:38:54,710 --> 00:38:57,260
在用户空间调用，
you know call in user space,

1186
00:38:57,260 --> 00:38:58,580
例如 shell 或者
for example the shell or your

1187
00:38:58,580 --> 00:39:01,310
你的质数程序调用 fork ，
prime program called fork, will whatever

1188
00:39:01,310 --> 00:39:02,870
不管什么调用 fork
calls fork doesn't really call

1189
00:39:02,870 --> 00:39:04,550
都不会直接调用操作系统，
the operating system directly,

1190
00:39:04,550 --> 00:39:06,680
内核中相应的函数，
the corresponding function in the kernel,

1191
00:39:06,680 --> 00:39:08,570
而是
instead you know what it does

1192
00:39:08,570 --> 00:39:10,200
实际上调用 ecall 。
it actually calls the ecall.

1193
00:39:11,710 --> 00:39:13,930
你知道 fork
With you know this number

1194
00:39:13,930 --> 00:39:15,000
的编号。
for fork.

1195
00:39:17,080 --> 00:39:18,940
然后它会
And then that actually jumps into

1196
00:39:18,940 --> 00:39:19,920
跳转到内核。
the kernel.

1197
00:39:20,690 --> 00:39:22,600
所以这是一个内核转换。
So this is a kernel transition.

1198
00:39:23,060 --> 00:39:24,530
这是用户端，
And here's the user side, here's

1199
00:39:24,530 --> 00:39:27,020
这是内核端，
kernel side, and then on

1200
00:39:27,020 --> 00:39:28,190
然后在内核端，
the kernel side,

1201
00:39:28,190 --> 00:39:29,390
你知道在 syscall.c 中
you know there's a function called

1202
00:39:29,390 --> 00:39:31,760
有一个名为 syscall 的函数，
syscall in syscall.c and

1203
00:39:31,760 --> 00:39:34,010
然后每个系统调用都会在
then basically every system call will

1204
00:39:34,010 --> 00:39:35,510
那个特定的系统调用函数结束，
end up at that particular system

1205
00:39:35,510 --> 00:39:37,250
系统调用
call function, and the system call

1206
00:39:37,250 --> 00:39:38,630
会查看这个数字，
will look at the number and

1207
00:39:38,630 --> 00:39:40,070
然后决定在寄存器中
then decide and the numerous action

1208
00:39:40,070 --> 00:39:41,540
传递的大量操作，
passed in register I think it's

1209
00:39:41,540 --> 00:39:42,460
我想它是 a0 。
a0.

1210
00:39:42,680 --> 00:39:44,660
嗯，去看看
Um, and just go and

1211
00:39:44,660 --> 00:39:45,860
那个寄存器，
look at that register look

1212
00:39:45,860 --> 00:39:47,300
看看 a0 ，
at a0, see what the

1213
00:39:47,300 --> 00:39:48,230
看看数字是多少，
number is and then,

1214
00:39:48,230 --> 00:39:49,310
比如调用 fork
for example called the fork

1215
00:39:49,310 --> 00:39:50,120
系统调用。
system call.

1216
00:39:52,670 --> 00:39:54,140
为了明确一下，
Um, and so just to make

1217
00:39:54,140 --> 00:39:55,610
这是用户和内核之间的
clear so this is this hard

1218
00:39:55,610 --> 00:39:57,590
硬边界，
boundary between the user and kernel,

1219
00:39:57,590 --> 00:40:00,400
所以用户不能调用，
so the user cannot call,

1220
00:40:00,600 --> 00:40:03,210
你知道这个 fork 直接，
you know this fork directly,

1221
00:40:03,210 --> 00:40:04,920
你知道用户应用程序
you know the only way user

1222
00:40:04,920 --> 00:40:07,320
实际调用系统调用 fork
application can actually invoke the system

1223
00:40:07,320 --> 00:40:09,150
的唯一方式是通过
call fork is actually through this

1224
00:40:09,150 --> 00:40:10,320
这个 ecall 指令。
ecall instruction.

1225
00:40:12,600 --> 00:40:14,440
我们还有另一个，
And so we have another, um,

1226
00:40:18,830 --> 00:40:20,580
如果我们有另一个，
if we have another, um,

1227
00:40:22,400 --> 00:40:23,870
另一个系统调用，
another system call let's

1228
00:40:23,870 --> 00:40:24,920
比如 write 。
say write.

1229
00:40:27,730 --> 00:40:28,810
它做了一些类似的事情，
It does something similar,

1230
00:40:28,810 --> 00:40:30,790
你知道 write 系统调用
you know the write system

1231
00:40:30,790 --> 00:40:32,410
不能直接调用
call cannot call you know the

1232
00:40:32,410 --> 00:40:34,450
内核中的
write, you know code directly into

1233
00:40:34,450 --> 00:40:35,080
write 代码，
the kernel,

1234
00:40:35,080 --> 00:40:36,910
相反，它所做的，
instead, um what it does,

1235
00:40:36,910 --> 00:40:39,250
它调用
it calls what's these little wrappers

1236
00:40:39,250 --> 00:40:40,000
小包装器， TODO:
are called,

1237
00:40:41,090 --> 00:40:42,530
系统调用停止，
system call stops it will call

1238
00:40:42,530 --> 00:40:43,400
它会调用 ecall。
ecall.

1239
00:40:44,560 --> 00:40:46,030
以及一个名为 write 的函数，
And function called write that actually

1240
00:40:46,030 --> 00:40:48,610
它实际执行 ecall 指令，
executes ecall instruction with the argument

1241
00:40:48,610 --> 00:40:49,210
参数为系统调用 write ，
you know syscall write,

1242
00:40:50,430 --> 00:40:52,530
以指示 write 系统调用，
to indicate the write system call,

1243
00:40:52,530 --> 00:40:54,510
然后再次将控制权
and then again transfer control to

1244
00:40:54,510 --> 00:40:55,460
转移给 syscall 。
syscall.

1245
00:40:55,600 --> 00:40:57,400
然后 syscall ，
And then syscall,

1246
00:40:57,400 --> 00:41:00,430
可以[一个视图多路复用] TODO:
um, can actually [a view multiplex]

1247
00:41:00,430 --> 00:41:01,720
到 write 系统调用中。
into the write system call.

1248
00:41:01,850 --> 00:41:03,170
有两个问题，
There are two questions,

1249
00:41:03,170 --> 00:41:04,140
请继续提问。
please go ahead.

1250
00:41:09,410 --> 00:41:10,820
所以，我想我们
So, I think my hands up

1251
00:41:10,820 --> 00:41:11,520
都举手了。
both.

1252
00:41:12,710 --> 00:41:15,020
好的，我可以先提问。
Okay I can go ahead.

1253
00:41:15,640 --> 00:41:17,560
我的问题是，
Oh, the question I had was,

1254
00:41:17,560 --> 00:41:19,870
内核如何或
um, how does or where does

1255
00:41:19,870 --> 00:41:21,600
在哪里检查，
the kernel check,

1256
00:41:21,830 --> 00:41:23,510
嗯，
um, for,

1257
00:41:23,510 --> 00:41:25,850
比如 fork 或 write ，
for example fork or write, if

1258
00:41:25,850 --> 00:41:27,180
是否允许或不允许。
it is allowed or not.

1259
00:41:27,510 --> 00:41:28,560
嗯，现在，
Um, right now,

1260
00:41:28,560 --> 00:41:29,880
你只是传入，
you're just passing in, like you

1261
00:41:29,880 --> 00:41:31,620
就像你只是在调用 ecall 和
know you're just calling ecall

1262
00:41:31,620 --> 00:41:33,060
系统调用号，
and the system call number,

1263
00:41:33,060 --> 00:41:34,950
但是内核决定
but where does the kernel

1264
00:41:34,950 --> 00:41:37,140
这个应用程序
basically decide whether this application

1265
00:41:37,140 --> 00:41:38,730
是否应该能够调用
should be able to invoke

1266
00:41:38,730 --> 00:41:41,300
这个特定的内核系统调用。
this particular kernel syscall.

1267
00:41:41,420 --> 00:41:42,710
是的，这是一个好问题，
Yeah, so a great question,

1268
00:41:42,710 --> 00:41:44,540
原则上，你知道
so in principle you know on

1269
00:41:44,540 --> 00:41:46,010
在内核方面是正确的，
the kernel side correct, when we

1270
00:41:46,010 --> 00:41:47,880
当我们使用 fork 调用运行的时候。
actually use fork call runs.

1271
00:41:48,230 --> 00:41:49,310
它可以实现它想要的
Um, it can implement any

1272
00:41:49,310 --> 00:41:49,910
任何安全检查，
secure check

1273
00:41:49,910 --> 00:41:51,170
你可以查看系统调用的参数，
it wants, you could look at

1274
00:41:51,170 --> 00:41:53,390
然后决定
the arguments if the system call

1275
00:41:53,390 --> 00:41:55,130
是否应该
and decide whether actually the application

1276
00:41:55,130 --> 00:41:56,660
允许应用程序
should all be allowed to execute

1277
00:41:56,660 --> 00:41:57,920
执行系统调用 fork 。
the system call fork.

1278
00:41:57,950 --> 00:42:00,200
在用户中，或者在 unix 中，
Now in user or in unix

1279
00:42:00,200 --> 00:42:01,520
或者任何应用程序中，都可以调用 fork ，
or any application can actually call

1280
00:42:01,520 --> 00:42:03,860
但是让我们假设 write 。
fork but let's say take write.

1281
00:42:03,960 --> 00:42:04,740
你知道， write ，
You know write,

1282
00:42:04,740 --> 00:42:06,840
你需要检查 write 的
you need to check whether

1283
00:42:06,840 --> 00:42:08,280
实现是否需要检查，
the implantation of write needs to

1284
00:42:08,280 --> 00:42:09,840
传递给 write
check, whether the address that is

1285
00:42:09,840 --> 00:42:13,110
的地址
actually passed into write, actually is

1286
00:42:13,110 --> 00:42:15,260
是否是用户应用程序的一部分。
part of the user applications.

1287
00:42:15,480 --> 00:42:16,650
所以
Um, and so that you

1288
00:42:16,650 --> 00:42:17,580
内核从其他地方写入数据
know the kernel is not

1289
00:42:17,580 --> 00:42:21,390
是不正确的，
correct to writing a data

1290
00:42:21,390 --> 00:42:22,290
它实际上
from somewhere else, it actually

1291
00:42:22,290 --> 00:42:23,880
不属于应用程序。
doesn't belong to the application.

1292
00:42:25,600 --> 00:42:26,350
还有更多的线索， TODO:
There more

1293
00:42:27,490 --> 00:42:29,040
你知道的。请提问。
hints, you know. Please ask.

1294
00:42:30,280 --> 00:42:31,180
嗯，我有一个
Um, yeah I had a

1295
00:42:31,180 --> 00:42:31,990
简短的问题，
quick question,

1296
00:42:31,990 --> 00:42:34,200
在用户应用程序
um, so how did the

1297
00:42:34,350 --> 00:42:36,360
恶意或无限循环的情况下，
kernel seize back control from a

1298
00:42:36,360 --> 00:42:38,700
内核是如何
user application in the case where

1299
00:42:38,700 --> 00:42:40,680
从用户应用程序手中
the user application is acting maliciously

1300
00:42:40,680 --> 00:42:42,400
夺回控制权的。
or in an infinite loop.

1301
00:42:42,660 --> 00:42:44,670
是的，方式是，计划是，
Yeah, so the way the plan

1302
00:42:44,670 --> 00:42:46,110
我们将
for that and again we're going

1303
00:42:46,110 --> 00:42:46,770
在几周内
to talk about in much more

1304
00:42:46,770 --> 00:42:47,760
再次详细讨论，
detail in a couple weeks,

1305
00:42:47,760 --> 00:42:49,770
内核实际上
um is that the kernel

1306
00:42:49,770 --> 00:42:50,550
是编程的，
actually programs,

1307
00:42:50,550 --> 00:42:52,200
使用硬件的
the hardware to a set

1308
00:42:52,200 --> 00:42:53,060
定时器。
of timer.

1309
00:42:53,460 --> 00:42:56,160
而在计时器关闭之后，
And after the timer goes off,

1310
00:42:56,160 --> 00:42:58,530
会导致从用户空间到
um, that will cause a transfer

1311
00:42:58,530 --> 00:42:59,970
内核模式的转换，
from user space to kernel mode,

1312
00:42:59,970 --> 00:43:00,960
在这一点上内核又
at that point the kernel is

1313
00:43:00,960 --> 00:43:02,200
回到了控制之中。
back in control.

1314
00:43:02,260 --> 00:43:04,090
然后内核可以将 CPU
And then the kernel can reschedule

1315
00:43:04,090 --> 00:43:06,860
重新调度到另一个进程。
the CPU to another process.

1316
00:43:07,600 --> 00:43:10,120
好的，有道理，谢谢。是的，
Okay makes sense, thank you. Yeah we'll

1317
00:43:10,120 --> 00:43:12,130
我们会看到确切的细节，
see the exact details you know

1318
00:43:12,130 --> 00:43:13,240
我们会
we'll see,

1319
00:43:13,240 --> 00:43:14,400
在一段时间内看到。
um, in a little while.

1320
00:43:15,200 --> 00:43:16,660
我们还有更多的问题要问。
We have more questions.

1321
00:43:18,580 --> 00:43:19,750
是的，
Yeah, so this is more of

1322
00:43:19,750 --> 00:43:20,800
这是一个更高层次的问题，
a high-level question,

1323
00:43:20,800 --> 00:43:24,220
是什么驱使操作系统
but what drives the designers of

1324
00:43:24,220 --> 00:43:27,010
实现的设计者
an operating systems implementation to use

1325
00:43:27,010 --> 00:43:28,440
使用像 C 这样的语言呢？
a language like C?

1326
00:43:29,120 --> 00:43:30,440
嗯，
Um, um,

1327
00:43:30,440 --> 00:43:32,330
好的，很好的问题，
okay, so great question,

1328
00:43:32,330 --> 00:43:35,120
C 语言给了你
um, C gives you a lot

1329
00:43:35,120 --> 00:43:35,960
对于硬件的
of control,

1330
00:43:35,960 --> 00:43:38,020
很大的控制权。
um over hardware.

1331
00:43:38,140 --> 00:43:39,220
还有，
And, um,

1332
00:43:39,220 --> 00:43:40,780
那么，
so, um,

1333
00:43:40,780 --> 00:43:41,530
举个例子，
for example,

1334
00:43:41,530 --> 00:43:42,490
你知道你需要
you know you need to program

1335
00:43:42,490 --> 00:43:43,420
对计时器芯片进行编程。
the timer chip.

1336
00:43:43,560 --> 00:43:45,870
在 C 语言中，
Um, and um in C that

1337
00:43:45,870 --> 00:43:47,490
这很容易做到，
is actually easy to do,

1338
00:43:47,490 --> 00:43:48,570
因为你可以对任何硬件资源
because you get a lot of

1339
00:43:48,570 --> 00:43:51,660
进行很多低级控制，
low-level control over any hardware resource

1340
00:43:51,660 --> 00:43:53,800
部分原因是你可以将任何东西
and partly because you can cast

1341
00:43:53,860 --> 00:43:55,240
强制转换为任何东西，
anything to anything,

1342
00:43:55,240 --> 00:43:56,560
所以，
um, and,

1343
00:43:56,560 --> 00:43:58,750
C 语言是非常
um, so C is basically very convenient

1344
00:43:58,750 --> 00:43:59,650
方便的语言，
programming language,

1345
00:43:59,650 --> 00:44:00,280
如果你必须
if you have to move

1346
00:44:00,280 --> 00:44:02,260
进行非常低级的编程，
very low-level programming and particularly

1347
00:44:02,260 --> 00:44:03,500
特别是与硬件交互。
interacting with hardware.

1348
00:44:06,620 --> 00:44:07,640
这并不意味着
It doesn't mean you can't do

1349
00:44:07,640 --> 00:44:08,720
你不能用其他语言来做，
it in other languages,

1350
00:44:08,720 --> 00:44:09,950
但是这是历史上
um, but this is historically the

1351
00:44:09,950 --> 00:44:11,980
C 语言成功的原因。
reason why C has been successful.

1352
00:44:12,940 --> 00:44:13,360
我明白了，
I see,

1353
00:44:13,360 --> 00:44:16,510
谢谢。为什么我看到
thanks. Why I see so much

1354
00:44:16,510 --> 00:44:18,790
像这些类型的应用程序
more popular than c++

1355
00:44:18,790 --> 00:44:20,890
这样的历史原因比 C++
only for historic reasons in like

1356
00:44:20,890 --> 00:44:23,530
流行得多，或者，
these kinds of applications or um,

1357
00:44:23,530 --> 00:44:26,170
大多数操作系统
is there any other reason that

1358
00:44:26,170 --> 00:44:28,390
没有采用 C++
like, like most OS don't

1359
00:44:28,390 --> 00:44:30,240
还有其他原因吗？
have adopted C++.

1360
00:44:30,580 --> 00:44:31,750
是的，大多数操作系统，
Yeah, so most operating system,

1361
00:44:31,750 --> 00:44:32,890
我认为使用 C++
there are I think operating

1362
00:44:32,890 --> 00:44:33,910
编写操作系统
systems written in C++

1363
00:44:33,910 --> 00:44:35,770
是完全可能的，
totally possible,

1364
00:44:35,770 --> 00:44:37,150
可能是你知道的，
probably the most ones that you

1365
00:44:37,150 --> 00:44:38,620
你知道的大多数操作系统
know, you know are not written

1366
00:44:38,620 --> 00:44:39,660
都不是用C++写的。
in C++.

1367
00:44:40,040 --> 00:44:41,930
还有各种原因，
Um, and the various reasons for,

1368
00:44:41,930 --> 00:44:44,150
你知道，linux 大部分
you know, Linux is mostly

1369
00:44:44,150 --> 00:44:45,680
是 C 而不是 C++ ，
C or no C++

1370
00:44:45,680 --> 00:44:47,000
我想部分原因是 Linus
and I think partially because Linus

1371
00:44:47,000 --> 00:44:48,620
不喜欢 C++ 。
just doesn't like C++.

1372
00:44:54,660 --> 00:44:55,800
还有其他问题吗？
Any other questions?

1373
00:45:04,300 --> 00:45:06,280
好的，那么，
Okay, so, so in this view

1374
00:45:06,280 --> 00:45:06,880
在这个世界观中，
of the world,

1375
00:45:06,880 --> 00:45:09,340
你知道我们有一种方法
were you know we have a

1376
00:45:09,340 --> 00:45:11,920
可以通过系统调用或 ecall 指令
way of transferring control into

1377
00:45:11,920 --> 00:45:14,140
将控制权转移到
the operating system using system calls

1378
00:45:14,140 --> 00:45:16,780
操作系统中，
or the ecall instruction and

1379
00:45:16,780 --> 00:45:18,760
并且内核不负责 TODO:
there's a kernel is not responsible

1380
00:45:18,760 --> 00:45:22,510
实际实现函数，
for implementing actually the actual functions

1381
00:45:22,510 --> 00:45:25,270
并确保检查参数
and ensuring checking arguments and

1382
00:45:25,270 --> 00:45:26,290
之类的东西，
things like that to make sure

1383
00:45:26,290 --> 00:45:27,580
以确保你知道这一点。
that you know that.

1384
00:45:27,880 --> 00:45:29,080
嗯，它不是被骗做了什么，嗯，做了一些坏事，所以在这个世界观里，内核有时被称为。
Um, it's not being tricked

1385
00:45:29,080 --> 00:45:29,530
into something,

1386
00:45:29,530 --> 00:45:31,300
um doing something badly and so

1387
00:45:31,300 --> 00:45:32,650
in this view of the world,

1388
00:45:32,650 --> 00:45:34,680
the kernel is sometimes called.

1389
00:45:37,200 --> 00:45:37,440
你知道，这是值得信赖的计算基地。
You know,

1390
00:45:37,440 --> 00:45:39,120
it's the trusted computing base.

1391
00:45:46,950 --> 00:45:48,660
在安全术语中有时被称为TCB。
Sometimes called in security terms

1392
00:45:48,660 --> 00:45:49,780
the TCB.

1393
00:45:50,530 --> 00:45:53,590
嗯，基本上你知道作为可信计算基础意味着什么，那么它必须是正确的，内核必须没有错误。
Um, and basically you know what

1394
00:45:53,590 --> 00:45:54,760
does it mean to be the

1395
00:45:54,760 --> 00:45:55,630
trusted computing base,

1396
00:45:55,630 --> 00:45:57,730
well it must be correct, kernel

1397
00:45:57,730 --> 00:45:58,900
must have no bugs.

1398
00:46:05,720 --> 00:46:06,650
因为如果内核里有个bug，你知道怎么想，这个东西，也许攻击者能够呃去挠这个bug，把bug变成一个漏洞..。
Because if there's a bug in

1399
00:46:06,650 --> 00:46:07,340
the kernel,

1400
00:46:07,340 --> 00:46:08,240
you know the way to think

1401
00:46:08,240 --> 00:46:08,570
about it,

1402
00:46:08,570 --> 00:46:08,900
this stuff,

1403
00:46:08,900 --> 00:46:11,420
maybe an attacker is able to

1404
00:46:11,420 --> 00:46:13,460
um to tickle the bug and

1405
00:46:13,460 --> 00:46:15,000
turn the bug into an exploit.

1406
00:46:15,260 --> 00:46:17,180
您知道可能会允许特定的攻击者打破孤立或者控制内核，所以您知道内核确实必须有尽可能少的错误，这一点非常重要。
And you know that exploit may

1407
00:46:17,180 --> 00:46:19,130
be allowed a particular attacker to

1408
00:46:19,130 --> 00:46:21,200
break out of isolation or maybe

1409
00:46:21,200 --> 00:46:23,090
take control over the kernel,

1410
00:46:23,090 --> 00:46:24,350
and so it's really important

1411
00:46:24,350 --> 00:46:25,070
that you know the kernel

1412
00:46:25,070 --> 00:46:26,270
really has to have as

1413
00:46:26,270 --> 00:46:27,580
few bugs as possible.

1414
00:46:29,620 --> 00:46:31,000
看不见的内核，你必须治疗。
Invisibly the kernel,

1415
00:46:31,000 --> 00:46:32,480
you must treat.

1416
00:46:35,460 --> 00:46:38,430
让我们将用户应用程序或应用程序或进程视为恶意。
Let's treat user apps or applications

1417
00:46:38,430 --> 00:46:39,560
or processes

1418
00:46:41,820 --> 00:46:42,940
as malicious.

1419
00:46:47,200 --> 00:46:49,180
基本上就像我之前说的，入侵内核设计器应该有一种安全的心态，嗯，你知道在编写和实现内核代码的时候。
Basically as I said before, invading

1420
00:46:49,180 --> 00:46:50,470
the kernel designer should have

1421
00:46:50,470 --> 00:46:52,210
a security mindset,

1422
00:46:52,210 --> 00:46:53,890
um, you know when writing and

1423
00:46:53,890 --> 00:46:55,640
implementing a kernel code.

1424
00:46:56,040 --> 00:46:58,770
在，在它的核心，为了实现这个目标，我们没有错误，如果你的操作系统非常大，不是那么简单，几乎每一个操作系统，你知道用户被广泛使用，有时实际上有一个安全漏洞，他们会随着时间的推移得到修复，但基本上是这样。
In, in its heart to

1425
00:46:58,770 --> 00:46:59,610
achieve this goal,

1426
00:46:59,610 --> 00:47:00,810
we have no bugs,

1427
00:47:00,810 --> 00:47:03,420
if your operating system gigantically big,

1428
00:47:03,420 --> 00:47:05,370
is not that straightforward and

1429
00:47:05,370 --> 00:47:06,900
almost every operating system,

1430
00:47:06,900 --> 00:47:09,030
you know the user is widely

1431
00:47:09,030 --> 00:47:10,980
used, once in a while

1432
00:47:10,980 --> 00:47:13,050
actually has a security bug and

1433
00:47:13,050 --> 00:47:15,180
they get fixed over time,

1434
00:47:15,180 --> 00:47:16,320
but basically.

1435
00:47:16,520 --> 00:47:18,170
不管发生什么，总会有新的漏洞出现，以后你就会明白为什么把它做好是如此的棘手，嗯，但是你知道内核必须做棘手的事情，这是可以理解的。
No matter what there's always a

1436
00:47:18,170 --> 00:47:20,360
new exploit at some point, down

1437
00:47:20,360 --> 00:47:22,250
the line and you will see

1438
00:47:22,250 --> 00:47:23,810
later why it's so tricky to get

1439
00:47:23,810 --> 00:47:24,980
it all and right,

1440
00:47:24,980 --> 00:47:26,750
um, but you know the sort

1441
00:47:26,750 --> 00:47:29,450
of understandable like the kernel has

1442
00:47:29,450 --> 00:47:30,680
to do tricky stuff.

1443
00:47:30,850 --> 00:47:33,010
它必须操作硬件，嗯，它必须非常小心，而且它正在检查，它很容易犯一个小错误，你知道它有一个错误。
It has to manipulate hardware,

1444
00:47:33,010 --> 00:47:33,940
um, it has to be

1445
00:47:33,940 --> 00:47:35,620
very careful and it's checking

1446
00:47:35,620 --> 00:47:36,880
it's very easy to make

1447
00:47:36,880 --> 00:47:38,710
a small slip up and

1448
00:47:38,710 --> 00:47:40,040
you know have a bug.

1449
00:47:42,150 --> 00:47:43,120
所以。
And so.

1450
00:47:47,140 --> 00:47:49,510
那么一个即时的问题就是应该在内核模式下运行什么，因为实际上内核代码实际上是在内核模式下运行的，这是敏感代码的权利，也就是可信计算的时代。
An instant question is then what

1451
00:47:49,510 --> 00:47:51,370
should run in kernel mode because

1452
00:47:51,370 --> 00:47:52,990
it's really the kernel code actually

1453
00:47:52,990 --> 00:47:54,880
is in kernel mode that is

1454
00:47:54,880 --> 00:47:57,640
the sensitive code right that is

1455
00:47:57,640 --> 00:47:59,140
the trusted computing days.

1456
00:47:59,330 --> 00:48:02,750
嗯，这个问题的一个答案是，你知道我们有自己的用户内核边界，所以这是用户，这是内核。
Um, and one answer to that

1457
00:48:02,750 --> 00:48:03,950
question is like

1458
00:48:03,950 --> 00:48:05,980
well you know we have our

1459
00:48:06,650 --> 00:48:07,880
user kernel boundary,

1460
00:48:07,880 --> 00:48:08,630
so here's user,

1461
00:48:08,630 --> 00:48:10,400
here's kernel.

1462
00:48:10,760 --> 00:48:13,760
用户应用程序运行，这里的程序运行在内核模式下，一种选择是将整个操作系统置于内核模式。
A user applications running,

1463
00:48:13,760 --> 00:48:16,010
and here is the program running

1464
00:48:16,010 --> 00:48:16,790
in kernel mode,

1465
00:48:16,790 --> 00:48:18,140
one option is to stick the

1466
00:48:18,140 --> 00:48:20,600
whole operating system in kernel mode.

1467
00:48:20,840 --> 00:48:21,770
例如，在大多数Unix操作系统中，整个Unix实现都在内核模式内运行。
For example,

1468
00:48:21,770 --> 00:48:24,170
in most unix operating systems,

1469
00:48:24,170 --> 00:48:26,870
the whole unix implementation runs inside

1470
00:48:26,870 --> 00:48:27,740
of kernel mode.

1471
00:48:27,800 --> 00:48:29,480
因此，在xv6中，所有操作系统服务基本上都处于内核模式，这被称为单片内核设计。
So in the xv6,

1472
00:48:29,480 --> 00:48:32,390
all the operating system services are

1473
00:48:32,390 --> 00:48:35,300
basically in kernel mode,

1474
00:48:35,300 --> 00:48:37,180
and this is called monolithic

1475
00:48:39,860 --> 00:48:40,960
kernel design.

1476
00:48:47,550 --> 00:48:50,490
你知道有几件事阻碍了我们的思考。
And you know there there's a

1477
00:48:50,490 --> 00:48:51,540
couple things in the way to think

1478
00:48:51,540 --> 00:48:52,110
about it.

1479
00:48:53,080 --> 00:48:55,060
一方面，它可能对虫子不太好。
One way, it's probably not so good

1480
00:48:55,060 --> 00:48:55,660
for bugs.

1481
00:48:58,910 --> 00:49:00,620
因为你所知道的在单片设计中可能有的任何错误实际上都可能变成一个漏洞，这将是不好的，嗯，所以我们有一个在内核中运行的大型操作系统，它们很可能会是更多的错误，但任何可以查询到的统计数据，比如每几千行代码，都会让你知道一些小错误。
Because any bug you know that

1482
00:49:00,620 --> 00:49:02,060
you might have in a monolithic

1483
00:49:02,060 --> 00:49:04,760
design might actually turn into an

1484
00:49:04,760 --> 00:49:06,830
exploit and that would be bad,

1485
00:49:06,830 --> 00:49:07,640
um, so we have a

1486
00:49:07,640 --> 00:49:09,560
large operating system running inside

1487
00:49:09,560 --> 00:49:10,160
of the kernel,

1488
00:49:10,160 --> 00:49:11,300
it's likely they're going to be

1489
00:49:11,300 --> 00:49:11,900
more bugs,

1490
00:49:11,900 --> 00:49:13,100
but any statistics that can

1491
00:49:13,100 --> 00:49:14,000
look up who says like

1492
00:49:14,000 --> 00:49:15,440
every few thousand lines of

1493
00:49:15,440 --> 00:49:16,790
code will have you know

1494
00:49:16,790 --> 00:49:18,240
some small number of bugs.

1495
00:49:18,420 --> 00:49:19,200
所以如果你有更多的代码行在内核挡路中运行，你知道的，你有可能有这样的机会。
And so if you have many,

1496
00:49:19,200 --> 00:49:20,430
many more lines of code running

1497
00:49:20,430 --> 00:49:21,270
in the kernel block,

1498
00:49:21,270 --> 00:49:22,890
you know, the probability the chance that

1499
00:49:22,890 --> 00:49:23,780
you have.

1500
00:49:23,880 --> 00:49:26,640
嗯，然后巨大的错误会增加一点，所以从安全的角度来看，单片内核设计的缺点是内核中有很多代码。
Um, and then huge bug

1501
00:49:26,640 --> 00:49:27,510
goes up a little bit

1502
00:49:27,510 --> 00:49:29,130
and so downside from the

1503
00:49:29,130 --> 00:49:30,600
monolithic kernel design from a

1504
00:49:30,600 --> 00:49:31,980
security perspective is that there's a

1505
00:49:31,980 --> 00:49:33,660
lot of code in the

1506
00:49:33,660 --> 00:49:34,300
kernel.

1507
00:49:34,840 --> 00:49:37,390
嗯，不过，好处是你知道的。
Um the plus though is

1508
00:49:37,390 --> 00:49:38,140
you know.

1509
00:49:38,200 --> 00:49:39,430
通常，如果您考虑一个包含各种不同部分的操作系统，您知道您可能不得不使用文件系统部分。
Typically, if you think about an

1510
00:49:39,430 --> 00:49:40,810
operating system that contains all kinds

1511
00:49:40,810 --> 00:49:41,590
of different pieces,

1512
00:49:41,590 --> 00:49:42,280
you know you might have to

1513
00:49:42,280 --> 00:49:43,460
file system piece.

1514
00:49:43,690 --> 00:49:44,560
你可能有虚拟内存片，嗯，你可能有进程，你知道。
You might have the virtual

1515
00:49:44,560 --> 00:49:45,670
memory piece,

1516
00:49:45,670 --> 00:49:48,100
um, you might have processes

1517
00:49:48,100 --> 00:49:48,780
you know.

1518
00:49:48,920 --> 00:49:49,580
因此，操作系统内部有各种实现特定功能的子模块。
And so there are all kinds

1519
00:49:49,580 --> 00:49:51,170
of sub modules inside of the

1520
00:49:51,170 --> 00:49:53,840
operating system that implement particular functionality.

1521
00:49:54,120 --> 00:49:55,230
有利的一面是将会有紧密的整合。
And the plus side of

1522
00:49:55,230 --> 00:49:56,040
that is there's going to

1523
00:49:56,040 --> 00:49:57,460
be tight integration.

1524
00:49:57,900 --> 00:50:00,780
在这些不同的子模块之间是可能的，如果它们都在同一个程序中的话。
Possible between these different sub modules,

1525
00:50:00,780 --> 00:50:01,860
if they're all sitting in the

1526
00:50:01,860 --> 00:50:02,840
same program.

1527
00:50:03,420 --> 00:50:05,010
这种联系会带来出色的表现。
And that connection leads to

1528
00:50:05,010 --> 00:50:06,140
great performance.

1529
00:50:11,250 --> 00:50:12,450
举个例子，如果你看一个Linux操作系统，它实际上实现了非常令人印象深刻的性能。
An example if you look at

1530
00:50:12,450 --> 00:50:14,040
an operating system Linux,

1531
00:50:14,040 --> 00:50:16,080
it actually achieves a very

1532
00:50:16,080 --> 00:50:17,300
impressive performance.

1533
00:50:17,420 --> 00:50:18,890
嗯，所以有一种，一种设计，另一种设计主要集中在减少内核中的代码量，这就是所谓的微内核设计。
Um, and so there's a one,

1534
00:50:18,890 --> 00:50:22,310
one design, another design

1535
00:50:22,310 --> 00:50:24,290
which basically focuses on reducing the

1536
00:50:24,290 --> 00:50:25,910
amount of code in the kernel

1537
00:50:25,910 --> 00:50:28,220
is what's called micro kernel design.

1538
00:50:35,100 --> 00:50:36,270
在这个设计中，您的目标实际上是在内核模式下运行尽可能少的行，例如，通常有一些东西是内核的。
And in this design,

1539
00:50:36,270 --> 00:50:37,410
your goal is actually to run

1540
00:50:37,410 --> 00:50:39,690
as few lines as possible in

1541
00:50:39,690 --> 00:50:41,580
kernel mode and for example there

1542
00:50:41,580 --> 00:50:43,640
is something often kernel.

1543
00:50:44,250 --> 00:50:46,260
但是内核只有很少的组件，所以General通常有某种形式的IPC或消息传递。
But the kernel has very few,

1544
00:50:46,260 --> 00:50:48,210
um, components to it,

1545
00:50:48,210 --> 00:50:50,190
so general typically has some form

1546
00:50:50,190 --> 00:50:52,400
of IPC or message passing.

1547
00:50:53,030 --> 00:50:55,190
少量VM支持非常少。
A little bit of vm support

1548
00:50:55,190 --> 00:50:56,340
very minimal.

1549
00:50:56,920 --> 00:50:59,020
基本上，只需要页表和多路复用不同的CPU。
Basically, only thing necessary for page

1550
00:50:59,020 --> 00:51:01,780
tables and something to multiplex

1551
00:51:01,930 --> 00:51:04,220
different CPUs.

1552
00:51:04,820 --> 00:51:06,480
所以这是一个多路复用代码。
So it's a multiplexing code.

1553
00:51:09,610 --> 00:51:11,320
但通常我们的目标是[获取]内核外操作系统的错误，例如，由于我们在这里有自己的边界，嗯，我们要做的实际上是我们将内核的其他部分作为普通用户应用程序来运行，例如，我们可能有，您可能有一个用户进程，仍然不是有意的，但没关系，您知道我刚刚做的是文件服务器。
But generally the goal is to

1554
00:51:11,320 --> 00:51:13,060
[earn] the bug of the operating

1555
00:51:13,060 --> 00:51:14,920
system outside of the kernel,

1556
00:51:14,920 --> 00:51:16,480
and so for example again, as we

1557
00:51:16,480 --> 00:51:18,610
have our boundary here,

1558
00:51:18,610 --> 00:51:20,380
um what we'll do is actually

1559
00:51:20,380 --> 00:51:22,300
we'll run other parts of the

1560
00:51:22,300 --> 00:51:24,730
kernel as normal user applications,

1561
00:51:24,730 --> 00:51:27,220
for example we might have,

1562
00:51:34,380 --> 00:51:36,570
you might have a user process,

1563
00:51:36,570 --> 00:51:39,450
still not intended but doesn't matter,

1564
00:51:39,450 --> 00:51:40,660
you know I just did

1565
00:51:40,870 --> 00:51:41,880
file server.

1566
00:51:42,160 --> 00:51:43,660
然后是文件服务器，只是普通的用户空间。
And so and then the

1567
00:51:43,660 --> 00:51:44,170
file servers,

1568
00:51:44,170 --> 00:51:46,060
just regular user space.

1569
00:51:46,620 --> 00:51:48,000
用户空间内核，所以即使我不小心画了红色的，我打算画黑色的，水龙头是我的，运行用户应用程序，你知道，就像ECHO一样。
User space kernel,

1570
00:51:48,000 --> 00:51:49,440
so even though I drew,

1571
00:51:49,440 --> 00:51:50,040
by accident,

1572
00:51:50,040 --> 00:51:51,780
in red, I intended to draw out

1573
00:51:51,780 --> 00:51:53,850
in black, the faucets are mine, running

1574
00:51:53,850 --> 00:51:57,120
user application like, you know, echo.

1575
00:51:57,320 --> 00:51:58,580
您知道shell，它们都在用户空间中运行，我们可能会有其他用户应用程序，比如VM系统的某些部分实际上可能会在用户模式下运行常规用户应用程序。
You know the shell,

1576
00:51:58,580 --> 00:52:00,050
they're all running in user space

1577
00:52:00,050 --> 00:52:01,640
and we might have other user

1578
00:52:01,640 --> 00:52:03,320
applications like parts of the vm

1579
00:52:03,320 --> 00:52:05,000
system might actually run the regular

1580
00:52:05,000 --> 00:52:06,360
user application

1581
00:52:06,930 --> 00:52:09,460
in user mode.

1582
00:52:09,860 --> 00:52:10,610
所以这是一个很好的设计，正确的，因为大概在内核中的代码量很小。
And so this is sort of

1583
00:52:10,610 --> 00:52:11,450
a nice design correct,

1584
00:52:11,450 --> 00:52:13,100
because the amount of code

1585
00:52:13,100 --> 00:52:14,180
that presumably that's in the

1586
00:52:14,180 --> 00:52:15,900
kernel is small.

1587
00:52:18,820 --> 00:52:21,430
这是很小很小的手段，希望更少的虫子。
It's small and small means,

1588
00:52:21,430 --> 00:52:23,060
hopefully fewer bugs.

1589
00:52:28,050 --> 00:52:30,000
当然，有一个问题您知道，我们必须安排shell可以与文件系统对话，例如，shell调用exec，并且必须有一种访问文件系统的方法。
The one issue of course is

1590
00:52:30,000 --> 00:52:30,720
like you know we have to

1591
00:52:30,720 --> 00:52:32,340
arrange that shell can talk to

1592
00:52:32,340 --> 00:52:33,630
the file system, for example,

1593
00:52:33,630 --> 00:52:35,610
the shell calls exec and there

1594
00:52:35,610 --> 00:52:36,390
has to be a way of

1595
00:52:36,390 --> 00:52:37,920
getting to the file system.

1596
00:52:38,000 --> 00:52:38,990
因此，通常它的工作方式是外壳将通过IPC系统向内核发送消息。
And so typically the way

1597
00:52:38,990 --> 00:52:40,220
it works is that the

1598
00:52:40,220 --> 00:52:41,900
shell will send a message

1599
00:52:41,900 --> 00:52:43,600
through the IPC system

1600
00:52:44,030 --> 00:52:45,290
to the kernel.

1601
00:52:45,290 --> 00:52:46,190
内核会看着并说，哦，你知道这是针对文件系统和文件系统的，对文件系统很敏感。
The kernel will look at and

1602
00:52:46,190 --> 00:52:47,060
say like, oh you know this

1603
00:52:47,060 --> 00:52:48,410
is intended for the file systems

1604
00:52:48,410 --> 00:52:49,580
and file systems and sensitive to

1605
00:52:49,580 --> 00:52:50,700
the file system.

1606
00:52:51,590 --> 00:52:53,220
文件系统无法工作。
The file system doesn't work.

1607
00:52:53,640 --> 00:52:55,410
您知道，会发回一条消息，告诉您，这是您的exec系统调用的结果，然后您将其发送回shell。
You know sends a message back

1608
00:52:55,410 --> 00:52:56,160
saying you know,

1609
00:52:56,160 --> 00:52:57,840
here's the results of your exec

1610
00:52:57,840 --> 00:52:59,790
system call and then you send

1611
00:52:59,790 --> 00:53:01,200
it back to the shell.

1612
00:53:01,830 --> 00:53:02,640
因此，嗯，这些通常是使用消息来实现的。
And so,

1613
00:53:02,640 --> 00:53:04,770
um, these are typically implemented

1614
00:53:04,770 --> 00:53:05,780
using messages.

1615
00:53:06,020 --> 00:53:08,330
嗯，所以对于与文件服务器的任何交互，现在您必须跳出内核一次，跳入内核一次，跳出内核一次。
Um, and so for any interaction

1616
00:53:08,330 --> 00:53:09,470
with the file server,

1617
00:53:09,470 --> 00:53:11,330
now you have to jump once

1618
00:53:12,080 --> 00:53:13,490
once out of the kernel, once

1619
00:53:13,490 --> 00:53:14,300
into the kernel,

1620
00:53:14,300 --> 00:53:15,480
once out of the kernel.

1621
00:53:15,740 --> 00:53:16,550
如果您将其与之前的设计进行比较，例如，如果此人想要与文件系统对话，则只需一次系统调用和一次基本的回调。
If you compare that with

1622
00:53:16,550 --> 00:53:18,620
the previous design like if

1623
00:53:18,620 --> 00:53:19,580
this guy wants to talk

1624
00:53:19,580 --> 00:53:20,570
to the file system,

1625
00:53:20,570 --> 00:53:22,160
it's one system call in and

1626
00:53:22,160 --> 00:53:23,980
one basically call back out.

1627
00:53:24,190 --> 00:53:25,510
因此，您将系统调用条目的数量翻了一番。
And so you double the number

1628
00:53:25,510 --> 00:53:28,280
of a system call entries.

1629
00:53:28,860 --> 00:53:32,040
因此，提供微内核方法的一个典型问题或挑战实际上是如何获得良好的性能。
And so, one typical problem

1630
00:53:32,040 --> 00:53:32,700
or challenge,

1631
00:53:32,700 --> 00:53:34,950
with offer the micro kernel approaches

1632
00:53:34,950 --> 00:53:36,360
is actually how to achieve

1633
00:53:36,360 --> 00:53:37,340
good performance.

1634
00:53:37,900 --> 00:53:38,680
它有两个组成部分。
And it has sort of two

1635
00:53:38,680 --> 00:53:39,800
components to it.

1636
00:53:42,180 --> 00:53:43,770
嗯，您知道只是在用户模式和内核模式之间来回切换才能真正完成一些事情，第二部分是因为您知道不同的部分彼此之间确实很好地隔离了紧密集成较少，您知道安排起来比单片内核更复杂，例如，基本上每个人都可以在单片内核中举例，虚拟内存系统中的文件系统可以很容易地共享页面缓存，这在微内核设计中有点难实现，因此有时更难获得高性能。
Um, you know just jumping back

1637
00:53:43,770 --> 00:53:45,450
and forth between user mode and

1638
00:53:45,450 --> 00:53:46,830
kernel mode to actually get something

1639
00:53:46,830 --> 00:53:48,630
done and the second part is

1640
00:53:48,630 --> 00:53:50,460
because you know the different pieces

1641
00:53:50,460 --> 00:53:52,080
are really well isolated from each

1642
00:53:52,080 --> 00:53:54,210
other a tight integration is less,

1643
00:53:54,210 --> 00:53:56,640
you know more complicated to arrange

1644
00:53:56,640 --> 00:53:57,870
than for example in the monolithic

1645
00:53:57,870 --> 00:54:00,600
kernel where basically everybody can example

1646
00:54:00,600 --> 00:54:01,590
the file system in the virtual

1647
00:54:01,590 --> 00:54:03,840
memory system can easily share a

1648
00:54:03,840 --> 00:54:05,310
page cache which a little bit

1649
00:54:05,310 --> 00:54:06,720
harder to achieve in the micro

1650
00:54:06,720 --> 00:54:08,310
kernel design and therefore it's sometimes

1651
00:54:08,310 --> 00:54:10,800
more difficult to get high performance.

1652
00:54:12,170 --> 00:54:14,600
现在，微型和单片之间的这些区别非常高。
Now these distinctions between micro

1653
00:54:14,600 --> 00:54:16,790
and monolithic very high-level.

1654
00:54:16,790 --> 00:54:17,900
所以在实践中，这两种类型的内核设计都出现了，大多数桌面操作系统都是典型的单片系统，由于历史原因而运动。
So in practice,

1655
00:54:17,960 --> 00:54:19,820
both types of kernel design

1656
00:54:19,820 --> 00:54:22,910
show up, most desktop operating

1657
00:54:22,910 --> 00:54:25,670
systems are typically monolithic systems,

1658
00:54:25,670 --> 00:54:27,620
motion for historical reasons.

1659
00:54:27,780 --> 00:54:29,820
如果您运行非常密集的操作系统密集型应用程序，例如在数据中心，它们通常运行在单片内核上，这主要是因为示例Linux提供了很好的性能。
A lot of the if you

1660
00:54:29,820 --> 00:54:31,860
run a very intense you know

1661
00:54:31,860 --> 00:54:33,810
OS intense applications for example in

1662
00:54:33,810 --> 00:54:34,530
the data center,

1663
00:54:34,530 --> 00:54:36,600
they typically run on a monolithic

1664
00:54:36,600 --> 00:54:39,570
kernel, mostly because example Linux

1665
00:54:39,570 --> 00:54:41,060
provides great performance.

1666
00:54:41,060 --> 00:54:44,120
但许多，例如，像Minix或[cell4]这样的嵌入式设置，往往是微内核设计。
But many, for example, embedding settings

1667
00:54:44,120 --> 00:54:48,320
like minix or [cell4], those tend

1668
00:54:48,320 --> 00:54:50,600
to be micro kernel designs.

1669
00:54:51,470 --> 00:54:53,180
所以这两种设计都很流行，嗯，你可以从头开始一个新的操作系统。
And so both designs are popular,

1670
00:54:53,180 --> 00:54:54,530
um, you could probably start a

1671
00:54:54,530 --> 00:54:56,420
new operation system from scratch.

1672
00:54:56,480 --> 00:54:59,150
嗯，你可能会从，你知道，你可能会从微内核设计开始。
Um, you probably start with,

1673
00:54:59,150 --> 00:55:01,460
you know, you may start

1674
00:55:01,460 --> 00:55:03,040
with a micro kernel design.

1675
00:55:03,240 --> 00:55:05,310
一旦你有了像Linux这样的单片设计，重写微内核设计的任何东西都将是一项繁重的工作，因为这可能不利于人们可能想要花费的时间来包括新功能，而不是真正地重组内核。
Once you have a monolithic

1676
00:55:05,310 --> 00:55:06,990
design like for example Linux,

1677
00:55:06,990 --> 00:55:08,130
it's going to be would

1678
00:55:08,130 --> 00:55:09,150
be a ton of work

1679
00:55:09,150 --> 00:55:10,080
to rewrite anything to a

1680
00:55:10,080 --> 00:55:12,060
micro kernel design as maybe

1681
00:55:12,060 --> 00:55:13,710
not conducive to the incentives

1682
00:55:13,710 --> 00:55:14,790
people probably want to spend

1683
00:55:14,790 --> 00:55:16,770
rather time including new features

1684
00:55:16,770 --> 00:55:17,760
than actually,

1685
00:55:18,660 --> 00:55:20,580
restructuring,

1686
00:55:20,580 --> 00:55:21,340
the kernel.

1687
00:55:22,180 --> 00:55:23,110
嗯，那么，这是两种主要的设计，嗯，正如你所知道的，xv6属于单片设计，这是最经典的Unix系统所做的，但在本学期晚些时候，嗯，我们会更详细地讨论一些微内核设计。
Um, so,

1688
00:55:23,110 --> 00:55:25,630
these are sort of two main designs,

1689
00:55:25,630 --> 00:55:27,970
um, as you know xv6 is

1690
00:55:27,970 --> 00:55:30,280
falls into monolithic design is

1691
00:55:30,280 --> 00:55:32,380
most classic unix systems do,

1692
00:55:32,380 --> 00:55:34,120
but later in the semester,

1693
00:55:34,120 --> 00:55:35,470
um, we'll talk a lot more

1694
00:55:35,470 --> 00:55:37,000
in detail about some of the

1695
00:55:37,000 --> 00:55:38,320
micro kernel designs.

1696
00:55:40,170 --> 00:55:41,580
对此有任何疑问，因为这是问题电子邮件中的热门话题。
Any questions about this because this

1697
00:55:41,580 --> 00:55:43,240
was a hot topic in the,

1698
00:55:43,810 --> 00:55:45,300
in the email of questions.

1699
00:55:56,060 --> 00:55:56,870
嗯，好的，让我换一下。
Um, okay,

1700
00:55:56,870 --> 00:55:58,670
let me switch little bit.

1701
00:55:58,670 --> 00:55:59,750
我将转到一些代码，看看这在xv6中是如何发挥作用的。
I'm going to get to some

1702
00:55:59,750 --> 00:56:01,760
code and see how this plays

1703
00:56:01,760 --> 00:56:04,120
out in xv6.

1704
00:56:05,930 --> 00:56:09,140
嗯，所以我们这里有两个窗户。
Um, so we're here two windows.

1705
00:56:09,840 --> 00:56:12,390
嗯，你知道，emacs，你知道的，就像proc结构。
Um, and you know, emacs, you

1706
00:56:12,390 --> 00:56:14,260
know with like the proc structure.

1707
00:56:14,420 --> 00:56:15,680
嗯，我想做的第一件事是，嗯，你稍微看一下代码库，你可能已经这样做了，但你会看到代码是按照三个，三个部分组成的，一个是内核。
Um, and the first thing I

1708
00:56:15,680 --> 00:56:16,880
wanna do is,

1709
00:56:16,880 --> 00:56:18,620
um, you look a little bit

1710
00:56:18,620 --> 00:56:19,880
at the code base, you've

1711
00:56:19,880 --> 00:56:21,050
probably already done this,

1712
00:56:21,050 --> 00:56:22,070
but you see that the code

1713
00:56:22,070 --> 00:56:23,930
is sort of organized along three,

1714
00:56:23,930 --> 00:56:27,540
three parts one the kernel.

1715
00:56:27,720 --> 00:56:29,700
你知道，基本上包括所有内核文件的内核，xv6是一个单片内核，基本上所有这些程序都被编译成一个称为内核的二进制文件，这实际上就是你在内核模式下运行的。
And you know kernel that basically

1716
00:56:29,700 --> 00:56:33,690
includes all the kernel files xv6

1717
00:56:33,690 --> 00:56:35,370
being a monolithic kernel,

1718
00:56:35,370 --> 00:56:38,460
basically all these programs are compiled

1719
00:56:38,460 --> 00:56:39,690
into a single binary called the

1720
00:56:39,690 --> 00:56:41,070
kernel and that's actually what you

1721
00:56:41,070 --> 00:56:42,400
run in kernel mode.

1722
00:56:43,360 --> 00:56:45,250
嗯，然后你知道有用户，这些基本上都是在用户模式下运行的程序，这就是为什么你想要的程序叫做内核，另一个叫做当前用户。
Um, and then you know there's

1723
00:56:45,250 --> 00:56:47,020
user and those are basically the

1724
00:56:47,020 --> 00:56:48,430
programs that run in user mode,

1725
00:56:48,430 --> 00:56:49,450
and this is why you're going

1726
00:56:49,450 --> 00:56:50,350
to want is called kernel and

1727
00:56:50,350 --> 00:56:51,600
the other called current user.

1728
00:56:52,080 --> 00:56:53,460
然后还有一个名为‘mkfs’的程序，嗯，它实际上构建了一个空文件系统映像，我们已经将其存储在磁盘上。
And then there's one more program

1729
00:56:53,460 --> 00:56:54,810
called 'mkfs',

1730
00:56:54,810 --> 00:56:56,850
um, which actually builds an

1731
00:56:56,850 --> 00:56:59,400
empty file system image that we've

1732
00:56:59,400 --> 00:57:00,480
stored on disk.

1733
00:57:00,590 --> 00:57:01,760
嗯，这样我们就可以从一个空的文件系统开始。
Um, so that we can get

1734
00:57:01,760 --> 00:57:03,740
off the ground with an empty

1735
00:57:03,740 --> 00:57:04,500
file system.

1736
00:57:09,160 --> 00:57:11,560
好的，在此之前，你们再次切换到，我想说一下内核是如何编译的。
Okay so before so you switch

1737
00:57:11,560 --> 00:57:13,240
back again to I want to

1738
00:57:13,240 --> 00:57:14,080
say a little bit about how

1739
00:57:14,080 --> 00:57:15,600
the kernel is compiled.

1740
00:57:16,130 --> 00:57:17,600
嗯，因为你可能已经看过了，你可能还没有真正意识到，所以了解一下是很重要的。
Um, because you probably have seen

1741
00:57:17,600 --> 00:57:18,650
this and you might not really

1742
00:57:18,650 --> 00:57:21,200
have realized it, it's important

1743
00:57:21,200 --> 00:57:22,100
to understand.

1744
00:57:22,420 --> 00:57:24,900
嗯，所以当内核，内核的构造，Makefile基本上都是这些C文件中的一个，像proc.c。
Um, so when the kernel,

1745
00:57:25,270 --> 00:57:26,680
the construction of the kernel,

1746
00:57:26,680 --> 00:57:28,870
the makefile basically takes one

1747
00:57:28,870 --> 00:57:30,430
of these C files like

1748
00:57:30,430 --> 00:57:31,460
proc.c.

1749
00:57:31,950 --> 00:57:33,120
调用GCC，这是GCC的编译器，它生成一个名为pro.S的文件。
You know invokes you know

1750
00:57:33,120 --> 00:57:34,590
the GCC,

1751
00:57:34,590 --> 00:57:37,980
the GCC compiler that generates a

1752
00:57:37,980 --> 00:57:40,020
file called proc.S.

1753
00:57:40,190 --> 00:57:41,920
这是类似的。
That goes to the similar.

1754
00:57:44,800 --> 00:57:46,150
这基本上是RISC-V组件。
And this is basically

1755
00:57:46,150 --> 00:57:47,400
RISC-V assembly.

1756
00:57:49,360 --> 00:57:50,680
这实际上会产生一个文件proc.o，基本上就是汇编程序的二进制版本。
And that actually produces a

1757
00:57:50,680 --> 00:57:51,490
file proc.o,

1758
00:57:51,490 --> 00:57:53,410
and basically that's you know

1759
00:57:53,410 --> 00:57:55,860
the binary version of the assembler.

1760
00:57:56,260 --> 00:57:58,120
嗯，你知道Makefile执行这个规则，你知道内核中的部分文件，比如管道。
Um, and you know the makefile

1761
00:57:58,120 --> 00:57:59,590
does this rule, you know

1762
00:57:59,590 --> 00:58:00,940
part files in the kernel,

1763
00:58:00,940 --> 00:58:03,120
so example, pipe.

1764
00:58:03,380 --> 00:58:04,880
还有一个你知道的，就是GCC编成管子的同一个故事。
Another one you know,

1765
00:58:04,880 --> 00:58:07,640
same story GCC compiles to

1766
00:58:07,640 --> 00:58:08,640
pipe.S.

1767
00:58:09,240 --> 00:58:10,680
你知道，经过类似的测试，我们会得到管子。
And you know go to through

1768
00:58:10,680 --> 00:58:13,300
similar and we get pipe.o.

1769
00:58:14,080 --> 00:58:16,020
基本上，然后是加载器，它接受所有这些.o文件。
And basically then the loader,

1770
00:58:17,020 --> 00:58:19,040
it takes all these .o files.

1771
00:58:19,450 --> 00:58:20,830
从所有不同的文件中，你知道文件，并将它们链接在一起，然后产生，产生内核。
From all the different you know

1772
00:58:20,830 --> 00:58:23,290
files and links them together and

1773
00:58:23,290 --> 00:58:25,660
produces, produces the kernel.

1774
00:58:28,480 --> 00:58:29,560
就像我们实际运行的那样。
And as actually then what

1775
00:58:29,560 --> 00:58:30,320
we run.

1776
00:58:30,900 --> 00:58:32,850
为了方便起见，Makefile还会生成一个名为kernel.asm的文件。
And you know, for your convenience,

1777
00:58:32,850 --> 00:58:33,630
you know the makefile

1778
00:58:33,630 --> 00:58:34,890
also produces a file called

1779
00:58:34,890 --> 00:58:36,280
kernel.asm.

1780
00:58:39,110 --> 00:58:43,250
它有完整的内核，反汇编的，你可以只看它，当你有内核错误的时候，你知道这会有帮助，很容易看出哪条指令，嗯，是在你得到错误的时候执行的。
That has the complete kernel,

1781
00:58:43,250 --> 00:58:45,410
disassembled and you can just look

1782
00:58:45,410 --> 00:58:46,610
at it and you know that

1783
00:58:46,610 --> 00:58:47,990
helps later on when you have

1784
00:58:47,990 --> 00:58:49,040
kernel bugs and it's easy to

1785
00:58:49,040 --> 00:58:50,540
see which instruction,

1786
00:58:50,540 --> 00:58:52,160
um, was executed at the point

1787
00:58:52,160 --> 00:58:53,520
you got the bug.

1788
00:58:53,790 --> 00:58:55,200
举个例子，如果我在这里，kernel.asm。
As an example if I,

1789
00:58:57,060 --> 00:58:59,640
here, kernel.asm.

1790
00:58:59,990 --> 00:59:00,980
嗯，我们看到了，嗯，这是内核文件，如果您发送指令的话。
Um, we see,

1791
00:59:00,980 --> 00:59:03,830
um, here's the kernel file

1792
00:59:03,830 --> 00:59:05,360
if you send instructions.

1793
00:59:05,570 --> 00:59:07,670
而且，嗯，你知道的，比如说，不是第一件事。
And, um one thing you know,

1794
00:59:07,670 --> 00:59:09,260
for example is not the first.

1795
00:59:09,480 --> 00:59:11,160
指令位于该地址800000，并且这是任何AUPC指令RISC-V指令。
A instruction is located at

1796
00:59:11,160 --> 00:59:12,480
this address 800000

1797
00:59:12,480 --> 00:59:14,850
and

1798
00:59:14,850 --> 00:59:16,140
that is whatever

1799
00:59:16,140 --> 00:59:18,240
aupc instruction RISC-V instruction.

1800
00:59:19,470 --> 00:59:21,740
嗯，进来。
Um in.

1801
00:59:22,560 --> 00:59:24,360
有人知道这是什么吗，008117183136505八三一三六五零五。
Anybody knows what this is,

1802
00:59:24,360 --> 00:59:25,800
008117183136505

1803
00:59:25,800 --> 00:59:27,300
eight three one three six five

1804
00:59:27,300 --> 00:59:28,180
o five.

1805
00:59:34,760 --> 00:59:35,720
有人想回答这个问题吗？右边是祸不单行版的汇编说明。
Anybody want to answer that

1806
00:59:35,720 --> 00:59:38,840
question? That's the hex version of

1807
00:59:38,840 --> 00:59:40,680
the assembly instructions on the right.

1808
00:59:41,010 --> 00:59:41,850
没错，008117上的符号和符号是完全一样的，你知道，它的文本版本，aupc，所以基本上这是实际指令的二进制编码。
Yeah exactly,

1809
00:59:41,850 --> 00:59:43,260
so what here on the

1810
00:59:43,260 --> 00:59:44,370
008117

1811
00:59:44,370 --> 00:59:45,570
is exactly the same

1812
00:59:45,570 --> 00:59:47,760
thing as symbolic you know

1813
00:59:47,760 --> 00:59:49,360
the textual version of that,

1814
00:59:49,540 --> 00:59:51,190
aupc and so basically

1815
00:59:51,190 --> 00:59:53,680
this is the binary encoding of

1816
00:59:53,680 --> 00:59:54,940
the actual instruction.

1817
00:59:56,120 --> 00:59:57,500
所以，每条指令都有一个二进制编码，你知道kernel.asm文件实际上显示了这些二进制编码。
So, and every instruction has a

1818
00:59:57,500 --> 00:59:59,480
binary encoding and you know the

1819
00:59:59,480 --> 01:00:00,770
kernel.asm file actually

1820
01:00:00,770 --> 01:00:02,500
shows those binary encodings.

1821
01:00:03,600 --> 01:00:04,650
这有时很方便，当您查看gdb并想知道实际发生了什么时，您可以看到实际的二进制编码是什么。
And this is sometimes convenient,

1822
01:00:04,650 --> 01:00:06,060
when you look at gdb and

1823
01:00:06,060 --> 01:00:06,960
you want to know what actually

1824
01:00:06,960 --> 01:00:07,830
is going on,

1825
01:00:07,830 --> 01:00:08,580
you can see actually what the

1826
01:00:08,580 --> 01:00:09,720
binary encoding is.

1827
01:00:13,630 --> 01:00:15,970
好的，那么当我们运行xv6时，我将在内部运行，实际上让我先在没有gdb的情况下运行。
Okay, so then when we run

1828
01:00:15,970 --> 01:00:17,110
xv6, I'm going to run

1829
01:00:17,110 --> 01:00:18,070
on the inside actually let me

1830
01:00:18,070 --> 01:00:20,300
first run it without gdb.

1831
01:00:20,660 --> 01:00:21,950
嗯，你知道的，编译一堆东西，然后调用QEMU。
Um, you know compile a

1832
01:00:21,950 --> 01:00:23,000
bunch of stuff and then

1833
01:00:23,000 --> 01:00:25,460
invokes QEMU.

1834
01:00:25,920 --> 01:00:27,030
这是一个很明显的C程序，嗯，模拟或模拟RISC-V处理器。
And this is a visibly

1835
01:00:27,030 --> 01:00:28,320
C program,

1836
01:00:28,320 --> 01:00:30,510
um that simulates or emulates a

1837
01:00:30,510 --> 01:00:31,740
RISC-V processor.

1838
01:00:32,180 --> 01:00:33,080
您可以在这里看到-kernel标志实际上传递内核。
You can see here in

1839
01:00:33,080 --> 01:00:34,670
the -kernel flag actually

1840
01:00:34,670 --> 01:00:36,040
passes the kernel.

1841
01:00:36,340 --> 01:00:38,950
由于要在qemu内部运行的程序和qemu与内核基本一致，所以任何程序的起始点都是地址80000。
As the program to

1842
01:00:38,950 --> 01:00:41,170
be run inside of QEMU

1843
01:00:41,170 --> 01:00:43,420
and QEMU and the kernel

1844
01:00:43,420 --> 01:00:45,940
agreed basically the starting place

1845
01:00:45,940 --> 01:00:47,380
for any program is to

1846
01:00:47,380 --> 01:00:48,670
address

1847
01:00:48,670 --> 01:00:49,300
80000.

1848
01:00:50,120 --> 01:00:51,050
我们看到我们在QEMU中传递了几个标志，只是您知道，嗯，这是虚拟机拥有的内存量。
And we see that we passed

1849
01:00:51,050 --> 01:00:52,220
a couple of flags in QEMU,

1850
01:00:52,220 --> 01:00:52,850
it's just you know,

1851
01:00:52,850 --> 01:00:54,320
um, that's an amount of

1852
01:00:54,320 --> 01:00:56,390
memory that the machine does

1853
01:00:56,390 --> 01:00:57,840
virtual machine has.

1854
01:00:57,840 --> 01:00:59,670
这个虚拟的RISC-V机器，嗯，它传入了多少遍，当然机器里面有多少遍，包含文件fs.img的磁盘驱动器。
This virtual RISC-V machine,

1855
01:00:59,670 --> 01:01:01,200
um, it passes in how many

1856
01:01:01,200 --> 01:01:02,480
of course there are

1857
01:01:02,540 --> 01:01:05,120
passes in the machine,

1858
01:01:05,120 --> 01:01:06,920
the disk drive which contains

1859
01:01:06,920 --> 01:01:07,880
the file

1860
01:01:07,880 --> 01:01:08,700
fs.img.

1861
01:01:08,860 --> 01:01:09,700
所以基本上有一堆东西是为了让QEMU表现得像一台真正的计算机而设置的。
And so basically a bunch of

1862
01:01:09,700 --> 01:01:10,720
things are sort of set up

1863
01:01:10,720 --> 01:01:12,130
to make QEMU behave

1864
01:01:12,130 --> 01:01:13,180
like a real computer.

1865
01:01:14,610 --> 01:01:16,200
所以当你考虑QEMU的时候，一种方式是，你真的不应该把它当作一个C程序，你应该这样考虑它。
And so one way when you

1866
01:01:16,200 --> 01:01:16,800
think about QEMU,

1867
01:01:16,800 --> 01:01:18,990
you really should not think about

1868
01:01:18,990 --> 01:01:20,820
it as a C program, really

1869
01:01:20,820 --> 01:01:21,720
the way you should think about

1870
01:01:21,720 --> 01:01:23,760
it is as follows.

1871
01:01:24,630 --> 01:01:26,460
嗯，你应该把它想成是，像这样。
Um, you should think about it

1872
01:01:26,460 --> 01:01:28,640
as,

1873
01:01:30,900 --> 01:01:31,960
as this.

1874
01:01:32,550 --> 01:01:35,460
也就是一个真正的电路板，嗯，那么比如说左边的，你知道这是一个RISC-V电路板。
Namely a real board,

1875
01:01:35,460 --> 01:01:36,090
um, so,

1876
01:01:36,090 --> 01:01:37,260
for example the on the left

1877
01:01:37,260 --> 01:01:38,610
you know this is a

1878
01:01:38,610 --> 01:01:39,600
RISC-V board.

1879
01:01:39,630 --> 01:01:41,130
嗯，实际上就是我办公室里的RISC-V板，你知道它或多或少可以引导xv6。
Um, actually the RISC-V board that

1880
01:01:41,130 --> 01:01:43,320
sits in my office and you

1881
01:01:43,320 --> 01:01:44,640
know it can boot more

1882
01:01:44,640 --> 01:01:45,860
or less xv6.

1883
01:01:46,340 --> 01:01:47,900
所以当你运行QEMU的时候，你知道QEMU，你的内核过去常常认为它实际上是在这块板上运行的。
And so when you're running you

1884
01:01:47,900 --> 01:01:50,180
know QEMU, with your kernel

1885
01:01:50,180 --> 01:01:51,110
used to think about it that

1886
01:01:51,110 --> 01:01:52,960
actually running it on this board.

1887
01:01:53,330 --> 01:01:54,920
我知道电路板一直处于关闭状态，这是给RISC-V处理器的。
And I know the board has

1888
01:01:54,920 --> 01:01:56,420
been on off button,

1889
01:01:56,420 --> 01:01:58,490
here's actually to

1890
01:01:58,490 --> 01:02:00,240
RISC-V processor.

1891
01:02:00,360 --> 01:02:01,920
嗯，你知道外设是有空间的，比如说有一个接口是以太网的接口。
Um, you know there's room

1892
01:02:01,920 --> 01:02:03,330
for peripherals,

1893
01:02:03,330 --> 01:02:05,370
for example one of these connectors

1894
01:02:05,370 --> 01:02:07,120
is a connector for ethernet.

1895
01:02:07,480 --> 01:02:09,520
嗯，一个是PCI插槽，是的，电路板上有一些RAM芯片，我不太清楚它们在哪里，但确实有。
Um, one is that PCI

1896
01:02:09,520 --> 01:02:10,540
slots,

1897
01:02:10,540 --> 01:02:12,490
yeah there's some ram chips on

1898
01:02:12,490 --> 01:02:14,620
the board I don't exactly know

1899
01:02:14,620 --> 01:02:15,250
where they are,

1900
01:02:15,250 --> 01:02:16,140
but there are.

1901
01:02:16,480 --> 01:02:18,070
嗯，这是一种物理硬件，实际上是计算机，实际上你在编程，所以xv6管理着这块电路板。
Um, and so this is sort

1902
01:02:18,070 --> 01:02:20,260
of a that's the physical hardware,

1903
01:02:20,260 --> 01:02:22,570
the computer actually, actually you're programming

1904
01:02:22,570 --> 01:02:24,190
so xv6 manages

1905
01:02:24,190 --> 01:02:25,020
this board.

1906
01:02:25,590 --> 01:02:27,390
嗯，这就是你脑海中通常会有的画面。
Um, and that's the picture usually

1907
01:02:27,390 --> 01:02:28,400
have in your head.

1908
01:02:29,030 --> 01:02:30,740
事实上，如果你把它放大，你可以找到所有的文档，关于它里面到底有什么。
And in fact if you zoom

1909
01:02:30,740 --> 01:02:32,450
in you can find all the

1910
01:02:32,450 --> 01:02:34,730
documentation of what actually sits inside

1911
01:02:34,730 --> 01:02:35,440
of this.

1912
01:02:35,790 --> 01:02:37,620
嗯，在这个里面，你知道这个RISC-V处理器的内部，RISC-V处理器的模式如图所示。
Um, and inside of this,

1913
01:02:37,620 --> 01:02:39,060
you know there's a inside of

1914
01:02:39,060 --> 01:02:41,160
this RISC-V processor,

1915
01:02:41,160 --> 01:02:42,690
the schema for the

1916
01:02:42,690 --> 01:02:44,310
RISC-V processor is shown in

1917
01:02:44,310 --> 01:02:45,340
this picture here.

1918
01:02:45,730 --> 01:02:47,380
嗯，你知道，你看这里，例如有多个核心。
Um, and you know see here,

1919
01:02:47,380 --> 01:02:49,380
for example there are multiple cores.

1920
01:02:49,650 --> 01:02:50,130
事实上，四核，嗯，你知道有一个二级缓存，嗯，有一个到DRAM的连接器。
In fact,

1921
01:02:50,130 --> 01:02:51,540
four cores,

1922
01:02:51,540 --> 01:02:53,610
um, you know there's a

1923
01:02:53,610 --> 01:02:55,050
l2 cache,

1924
01:02:55,050 --> 01:02:57,320
um, there's a connector to dram.

1925
01:02:57,380 --> 01:02:59,330
嗯，你知道有很多种方式可以连接到外部世界，所以你这里的UART0和UART0实际上一端连接到键盘，另一端连接到显示器。
Um, you know there's a bunch

1926
01:02:59,330 --> 01:03:00,230
of ways to connect to the

1927
01:03:00,230 --> 01:03:01,910
outside world, so you here

1928
01:03:01,910 --> 01:03:03,860
UART0 and UART0 was

1929
01:03:03,860 --> 01:03:06,260
actually connected on one end to

1930
01:03:06,260 --> 01:03:07,670
the keyboard and to the other

1931
01:03:07,670 --> 01:03:09,040
end to the display.

1932
01:03:09,320 --> 01:03:10,760
嗯，你知道有一些方法可以，嗯，让钟走起来。稍后我将更详细地讨论，但这些组件基本上都是您知道的xv6或您将修改以与实际工作交互的内容。
Um, and you know there are

1933
01:03:10,760 --> 01:03:12,740
some ways to actually, um, get

1934
01:03:12,740 --> 01:03:15,740
clocks going. I'll talk about in

1935
01:03:15,740 --> 01:03:17,090
much more detail later,

1936
01:03:17,090 --> 01:03:18,680
but these are all the components

1937
01:03:18,680 --> 01:03:20,180
that basically you know the

1938
01:03:20,180 --> 01:03:21,590
xv6 or things that you will

1939
01:03:21,590 --> 01:03:23,570
be modifying to interact with the

1940
01:03:23,570 --> 01:03:24,460
real hard work.

1941
01:03:24,910 --> 01:03:26,220
事实上，QEMU实际模拟的计算机系统或计算机板非常接近，除了SiFive制造的这个特殊的无计算机板的一些小细节。
And in fact the

1942
01:03:26,890 --> 01:03:28,600
computer system or the computer board

1943
01:03:28,600 --> 01:03:31,060
that actually is emulated by QEMU

1944
01:03:31,060 --> 01:03:33,040
is pretty close,

1945
01:03:33,040 --> 01:03:35,200
you know minus some small details

1946
01:03:35,200 --> 01:03:37,120
to this particular no computer board

1947
01:03:37,120 --> 01:03:38,660
which is made by SiFive.

1948
01:03:39,470 --> 01:03:41,600
嗯，不幸的是，我不能告诉你真正的事情，我只是坐在办公室里，你知道的，而且我从三月份以来就没有在我的办公室里了。
Um, unfortunately I can't tell you

1949
01:03:41,600 --> 01:03:43,310
the real thing I just sit

1950
01:03:43,310 --> 01:03:44,060
in my office,

1951
01:03:44,060 --> 01:03:45,200
you know and I haven't been in

1952
01:03:45,200 --> 01:03:46,500
my office since March.

1953
01:03:46,540 --> 01:03:47,440
虽然收集了大量灰尘，但在运行QEMU时记住这一点很重要，因为您基本上是在真正的硬件上运行。
From collecting a lot of

1954
01:03:47,440 --> 01:03:49,900
dust, but it's important to

1955
01:03:49,900 --> 01:03:51,010
keep in your head when

1956
01:03:51,010 --> 01:03:52,390
you're running QEMU, you're

1957
01:03:52,390 --> 01:03:54,620
running basically on real hardware.

1958
01:03:55,060 --> 01:03:56,080
只是碰巧能够使用软件。
And just happens to be able

1959
01:03:56,080 --> 01:03:57,060
to software.

1960
01:04:02,630 --> 01:04:03,640
这有意义吗。
Does that make sense.

1961
01:04:04,820 --> 01:04:06,180
[密码]第二年。
[Password] second year.

1962
01:04:11,560 --> 01:04:12,730
那么让我再多说一点，那么QEMU模拟RISC-V处理器意味着什么呢？
So let me say a little

1963
01:04:12,730 --> 01:04:13,570
bit more about it,

1964
01:04:13,570 --> 01:04:14,560
so what does it mean for

1965
01:04:14,560 --> 01:04:16,580
QEMU to emulate

1966
01:04:20,450 --> 01:04:22,080
RISC-V processor.

1967
01:04:24,940 --> 01:04:26,440
从字面上看，如果你仔细想想，你知道，就像我说的，QEMU模拟程序，这是一个开源的C程序，它是一个很大的程序，你可以直接下载或者克隆它。
Well, literally you know if you

1968
01:04:26,440 --> 01:04:27,400
think about it,

1969
01:04:27,400 --> 01:04:28,870
you know as I said, QEMU

1970
01:04:28,870 --> 01:04:30,430
simulate program it's an open

1971
01:04:30,430 --> 01:04:31,420
source C program,

1972
01:04:31,420 --> 01:04:32,350
it's a big program,

1973
01:04:32,350 --> 01:04:34,240
you can actually just download it

1974
01:04:34,240 --> 01:04:35,820
or get clone it.

1975
01:04:35,890 --> 01:04:37,720
嗯，但是在内部变成C，基本上是for循环，一个无限的for循环。
Um, but internally into C,

1976
01:04:37,720 --> 01:04:39,700
is basically for loop,

1977
01:04:39,880 --> 01:04:41,340
an infinite for loop.

1978
01:04:42,220 --> 01:04:43,690
那除了读指令什么也做不了。
That does nothing else than

1979
01:04:43,690 --> 01:04:44,900
read instruction.

1980
01:04:48,700 --> 01:04:52,030
RISC-V指令基本上达到了4个字节或8个字节，嗯，基本上是查看该指令中的位并对其进行解码。
RISC-V instruction basically reached four

1981
01:04:52,030 --> 01:04:53,410
byte or eight bytes,

1982
01:04:53,410 --> 01:04:55,870
um, and basically looks at

1983
01:04:55,870 --> 01:04:57,400
the bits in that instruction

1984
01:04:57,400 --> 01:04:58,520
and decodes them.

1985
01:04:58,840 --> 01:04:59,950
弄清楚操作码是什么。
Figures out what the op

1986
01:04:59,950 --> 01:05:00,760
code is.

1987
01:05:03,630 --> 01:05:04,860
我们看到了一些指令，即.asm文件中这些指令的二进制版本。
And we saw back for some

1988
01:05:04,860 --> 01:05:05,550
of the instructions,

1989
01:05:05,550 --> 01:05:07,230
the binary version of those instructions

1990
01:05:07,230 --> 01:05:09,120
in the .asm file.

1991
01:05:09,280 --> 01:05:10,570
因此对指令进行解码，例如，它可能会确定这是一条ADD指令、SUB指令、RISC-V SUB指令，然后基本上执行该指令。
So decodes the instruction,

1992
01:05:10,570 --> 01:05:11,110
so for example,

1993
01:05:11,110 --> 01:05:12,250
maybe it will decide this is

1994
01:05:12,250 --> 01:05:13,320
an add instruction,

1995
01:05:14,250 --> 01:05:15,900
sub instruction,

1996
01:05:15,900 --> 01:05:16,710
RISC-V sub instruction,

1997
01:05:16,710 --> 01:05:18,240
and then basically it executes

1998
01:05:18,240 --> 01:05:19,140
the instruction.

1999
01:05:21,840 --> 01:05:22,940
我是说软件。
I mean software.

2000
01:05:25,240 --> 01:05:26,650
你知道，这基本上就是它对每个核心所做的一切，你知道，运行这个特定的循环。
And you know that basically

2001
01:05:26,650 --> 01:05:27,610
is all what it does

2002
01:05:27,610 --> 01:05:28,540
for every core,

2003
01:05:28,540 --> 01:05:30,520
you know runs this particular loop.

2004
01:05:30,990 --> 01:05:32,490
此外，在某种程度上，执行此循环必须保持某些状态，以维护所有寄存器的状态。
And in addition sort of doing

2005
01:05:32,490 --> 01:05:33,630
this loop has to maintain some

2006
01:05:33,630 --> 01:05:35,130
states to maintain state for all

2007
01:05:35,130 --> 01:05:36,020
the registers.

2008
01:05:37,020 --> 01:05:39,510
所以它有类似于x0，寄存器0，x1等的C修饰。
So it has C decoration for

2009
01:05:39,510 --> 01:05:41,460
like x0, register 0,

2010
01:05:41,460 --> 01:05:42,920
x1 etc.

2011
01:05:44,360 --> 01:05:45,590
所以基本上，当它执行指令时，例如，指令就像任何东西。
And so basically when it executes

2012
01:05:45,590 --> 01:05:46,730
instruction, for example,

2013
01:05:46,730 --> 01:05:48,440
the instruction is like whatever.

2014
01:05:50,000 --> 01:05:53,620
你知道a0，1到7，存储在a0中，看不见，它需要常数7，1把它们相加，然后粘到a0中。
You know a0,

2015
01:05:53,730 --> 01:05:55,020
one to seven, and stored in

2016
01:05:55,020 --> 01:05:57,060
a0, invisible it takes constant

2017
01:05:57,060 --> 01:05:58,470
seven one adds them up and

2018
01:05:58,470 --> 01:05:59,720
sticks into a0.

2019
01:06:00,300 --> 01:06:02,490
里面有7个例子，然后它实际上得到了下一条指令，它继续前进，继续前进。
Examples for seven in it, and then

2020
01:06:02,490 --> 01:06:03,660
it actually gets next instruction

2021
01:06:03,660 --> 01:06:05,120
and it keeps going, keeps going.

2022
01:06:05,890 --> 01:06:07,840
除了直观地模拟或正确地模拟所有非特权指令之外，它还模拟所有特权指令。
In addition to visually emulating or

2023
01:06:07,840 --> 01:06:10,600
correctly all the imprivilege instructions,

2024
01:06:10,600 --> 01:06:11,680
it also emulates all the

2025
01:06:11,680 --> 01:06:12,840
privileged instructions.

2026
01:06:13,440 --> 01:06:13,980
这就是QEMU在本质上所做的，对你来说，最好的图像是你在一个真正的RISC-V处理器上运行的可见图像。
So that is,

2027
01:06:13,980 --> 01:06:16,410
in essence, what QEMU does,

2028
01:06:16,410 --> 01:06:18,210
in, the best picture for

2029
01:06:18,210 --> 01:06:19,290
you to have your head is

2030
01:06:19,290 --> 01:06:20,310
the visible you're running on a

2031
01:06:20,310 --> 01:06:22,260
real physical RISC-V processor.

2032
01:06:22,620 --> 01:06:23,850
就像你们已经拥有的那些，你们可能知道，你们中的许多人在6.004之后实现了一个。
Like the ones you have probably

2033
01:06:23,850 --> 01:06:25,200
you know many of you implemented

2034
01:06:25,200 --> 01:06:27,200
one after 6.004.

2035
01:06:30,340 --> 01:06:31,620
有任何关于这个的问题吗。
Any questions about this.

2036
01:06:32,780 --> 01:06:33,560
嗯，嗨，是的，我想知道它有没有硬件技巧，比如指令重叠之类的。
Um, hi,

2037
01:06:33,560 --> 01:06:35,120
yeah I was wondering if it

2038
01:06:35,120 --> 01:06:37,370
does any hardware tricks,

2039
01:06:37,370 --> 01:06:40,500
so like overlapping instructions or anything.

2040
01:06:41,000 --> 01:06:42,650
嗯，我知道，嗯，它是在它下面的一个真实的进程上正确运行的，当你运行qemu的时候，它可能是在x86处理器上运行的。
Um I know,

2041
01:06:42,650 --> 01:06:43,970
um, it runs on a real

2042
01:06:43,970 --> 01:06:45,560
process below it correctly when you

2043
01:06:45,560 --> 01:06:46,580
run QEMU,

2044
01:06:46,580 --> 01:06:47,600
it runs probably on an

2045
01:06:47,600 --> 01:06:49,040
x86 processor.

2046
01:06:49,290 --> 01:06:50,880
x86处理器，做了各种技巧来流水线指令和类似的事情，所以你对QEMU的看法是，只是一个C程序。
The x86 processor and does all

2047
01:06:50,880 --> 01:06:53,340
kinds of tricks to pipeline instructions

2048
01:06:53,340 --> 01:06:54,480
and things like that right,

2049
01:06:54,480 --> 01:06:55,830
so the way you think about

2050
01:06:55,830 --> 01:06:57,380
QEMU, just a C program.

2051
01:07:00,570 --> 01:07:01,140
有道理，谢谢。
Makes sense,

2052
01:07:01,140 --> 01:07:02,040
thank you.

2053
01:07:08,410 --> 01:07:10,210
那么多线程呢？如果QEMU支持您所说的四核，或者它只支持一个，在这种情况下，它是否真的有多个线程在运行它。
What about multi threading so if

2054
01:07:10,210 --> 01:07:12,880
the, the QEMU supports you

2055
01:07:12,880 --> 01:07:14,440
said four cores or does it

2056
01:07:14,440 --> 01:07:16,540
only support one and it's in

2057
01:07:16,540 --> 01:07:17,080
that case,

2058
01:07:17,080 --> 01:07:18,820
does it have actually multiple threads

2059
01:07:18,820 --> 01:07:19,660
running it.

2060
01:07:20,040 --> 01:07:21,990
是的，所以实际上我们在雅典娜上使用的QEMU，可能是您实际下载的QEMU，嗯，他们将在内部使用多线程，所以您在内部使用它来获得并行性，所以实际上，这四个核心正在被仿真或被并行仿真。
Yeah, so actually the QEMU that

2061
01:07:21,990 --> 01:07:23,820
we use on the Athena, and

2062
01:07:23,820 --> 01:07:24,570
were probably the ones that you

2063
01:07:24,570 --> 01:07:25,770
actually download,

2064
01:07:25,770 --> 01:07:28,500
um, they will use multiple threads

2065
01:07:28,500 --> 01:07:30,420
internally so you internally use it

2066
01:07:30,420 --> 01:07:31,260
to get parallelism,

2067
01:07:31,260 --> 01:07:32,700
so in fact,

2068
01:07:32,720 --> 01:07:34,610
these four cores that are being

2069
01:07:34,610 --> 01:07:37,220
emulated or being emulated in parallel.

2070
01:07:40,040 --> 01:07:40,910
我们稍后将在其中一个实验室看到这一点，它是如何发挥作用的。
And we'll see that in one

2071
01:07:40,910 --> 01:07:43,040
of the labs later, how how

2072
01:07:43,040 --> 01:07:44,060
that plays out.

2073
01:07:44,540 --> 01:07:45,740
是的，所以在不同的核心之间肯定存在真正的平行度。
Yeah, so definitely there's a

2074
01:07:45,740 --> 01:07:47,270
real parallelism going on between

2075
01:07:47,270 --> 01:07:48,160
the different cores.

2076
01:07:54,100 --> 01:07:55,750
好的，嗯，所以我要做一点，在xv6中走一走，来了解一下土地的布局是怎么一回事。
Okay, um,

2077
01:07:55,750 --> 01:07:57,070
so I'm gonna do a little

2078
01:07:57,070 --> 01:08:01,390
bit of, walking through

2079
01:08:01,390 --> 01:08:02,680
xv6 to get a

2080
01:08:02,680 --> 01:08:03,340
little bit of sense,

2081
01:08:03,340 --> 01:08:04,060
what the layout of the

2082
01:08:04,060 --> 01:08:04,920
land is.

2083
01:08:05,090 --> 01:08:07,070
嗯，在后面的课程中，我们会讲得更详细。
Um in, in later lecture again

2084
01:08:07,070 --> 01:08:07,700
we're going to go in much

2085
01:08:07,700 --> 01:08:08,480
more detail.

2086
01:08:08,800 --> 01:08:10,420
嗯，所以我要启动QEMU，嗯，有了gdb支持，基本qemu里面有一个gdb服务器。
Um, so I'm gonna fire up

2087
01:08:10,420 --> 01:08:12,370
QEMU and um,

2088
01:08:12,370 --> 01:08:14,260
with gdb supports, basic

2089
01:08:14,260 --> 01:08:15,760
QEMU has inside of it

2090
01:08:15,760 --> 01:08:17,220
a gdb server.

2091
01:08:17,560 --> 01:08:19,600
嗯，所以它启动了，然后就等着，你知道的，让gdb连接。
Um, and so it started up

2092
01:08:19,600 --> 01:08:20,740
and then just wait,

2093
01:08:20,740 --> 01:08:22,390
you know for a gdb

2094
01:08:22,390 --> 01:08:23,160
to connect.

2095
01:08:23,620 --> 01:08:25,720
为此，我将从我的计算机开始，这是一个RISC-64-Linux新的gdb。
To that I'm going to start

2096
01:08:25,720 --> 01:08:26,890
here on my computer,

2097
01:08:26,890 --> 01:08:28,690
this is a risc-64-linux

2098
01:08:28,690 --> 01:08:29,820
new gdb.

2099
01:08:30,050 --> 01:08:31,700
嗯，你们的一些机器可能是多拱门之类的。
Um, some of your machines might

2100
01:08:31,700 --> 01:08:34,180
be multi arch or something else.

2101
01:08:34,230 --> 01:08:35,490
嗯，但是基本上是为RISC-64，RISC-V 64编译的gdb。
Um, but basically the gdb

2102
01:08:35,490 --> 01:08:37,380
compiled for risc-64,

2103
01:08:37,380 --> 01:08:38,360
RISC-V 64.

2104
01:08:39,580 --> 01:08:41,650
我将在入口处设置断点，因为这是我们第一次知道它有大概第一条指令。
And I'm going to set the

2105
01:08:41,650 --> 01:08:43,570
break point at entry because that's

2106
01:08:43,570 --> 01:08:44,920
the first we know it has

2107
01:08:44,920 --> 01:08:46,440
roughly the first instruction.

2108
01:08:46,570 --> 01:08:48,400
实际工作会跳到。
That actually working is going to

2109
01:08:48,400 --> 01:08:49,640
jump to.

2110
01:08:50,060 --> 01:08:52,160
我设置了断点运行，基本上，它实际上不会准确地在8000处中断，而是在0A处，如果我们看右边，我们会看到0A是，正确地读取控制系统寄存器mhartid并将该值加载到a1中。
I set the break point run

2111
01:08:52,160 --> 01:08:54,290
and basically, it doesn't actually break

2112
01:08:54,290 --> 01:08:56,000
exactly at 8000

2113
01:08:56,000 --> 01:08:57,740
but at 0a and if we

2114
01:08:57,740 --> 01:08:59,390
look here on the right we

2115
01:08:59,390 --> 01:09:01,020
see that 0a is,

2116
01:09:01,100 --> 01:09:03,200
right reading the

2117
01:09:03,950 --> 01:09:05,600
control system register

2118
01:09:05,600 --> 01:09:07,910
mhartid and loading that value

2119
01:09:07,910 --> 01:09:09,020
into a1.

2120
01:09:09,720 --> 01:09:11,580
所以基本上QEMU模拟指令，然后我们可以执行该指令，然后我们进入下一条指令。
And so basically QEMU simulates

2121
01:09:11,580 --> 01:09:12,360
the instruction,

2122
01:09:12,360 --> 01:09:13,710
then we can execute that instruction,

2123
01:09:13,710 --> 01:09:14,310
then we go to the

2124
01:09:14,310 --> 01:09:15,220
next instruction.

2125
01:09:16,790 --> 01:09:19,760
嗯，基本上，这个地址8000基本上是大家同意的，你知道，由QEMU或QEMU告诉，你知道，基本上说，你想使用QEMU的第一个指令，我们要跳到那个特定的位置。
Um, in basically, this address 8000

2126
01:09:19,760 --> 01:09:21,320
it's just basically something

2127
01:09:21,320 --> 01:09:23,480
that was agreed on, you know

2128
01:09:23,480 --> 01:09:26,870
by QEMU or QEMU told,

2129
01:09:26,870 --> 01:09:28,190
you know basically says,

2130
01:09:28,190 --> 01:09:29,660
you want to use QEMU

2131
01:09:29,660 --> 01:09:30,350
the first instruction,

2132
01:09:30,350 --> 01:09:31,370
we're going to jump to is

2133
01:09:31,370 --> 01:09:32,900
at that particular location.

2134
01:09:33,170 --> 01:09:36,020
我们基本上安排了内核加载器。
And we basically arranged for the

2135
01:09:36,020 --> 01:09:37,200
kernel loader.

2136
01:09:38,320 --> 01:09:40,180
加载该程序的内核，因此有一个文件kernel.ld。
To load the kernel that

2137
01:09:40,180 --> 01:09:41,410
program so there's a file

2138
01:09:41,410 --> 01:09:42,680
kernel.ld.

2139
01:09:42,740 --> 01:09:44,870
这基本上指定了内核应该如何加载，您在这里可以看到，内核将使用的第一个地址，实际上是您指定的特定地址，即基本视图。
That basically specifies how the kernel

2140
01:09:44,870 --> 01:09:46,010
should be loaded,

2141
01:09:46,010 --> 01:09:47,540
and you see here that basically

2142
01:09:47,540 --> 01:09:49,370
the first address that the kernel

2143
01:09:49,370 --> 01:09:50,540
is going to use, is actually

2144
01:09:50,540 --> 01:09:51,380
that particular address,

2145
01:09:51,380 --> 01:09:52,960
the basic view you specified.

2146
01:09:54,120 --> 01:09:54,930
我们就是这样离开地面的。
This is how we get off

2147
01:09:54,930 --> 01:09:55,720
the ground.

2148
01:09:58,430 --> 01:09:59,900
这有意义吗。
Does that make sense.

2149
01:10:04,820 --> 01:10:06,560
好的，嗯，我们还看到，在这里，gdb实际上显示了指令的二进制编码。
Okay, um,

2150
01:10:06,560 --> 01:10:07,970
we see also that here actually

2151
01:10:07,970 --> 01:10:10,070
gdb shows the binary encoding of

2152
01:10:10,070 --> 01:10:11,120
the instructions.

2153
01:10:11,660 --> 01:10:12,920
所以我们可以看到，基本上我猜csrr，是一条，嗯，是的，四字节指令，而addi是一条双字节指令。
And so we see that basically

2154
01:10:12,920 --> 01:10:15,100
I guess the csrr, is a,

2155
01:10:15,750 --> 01:10:16,760
um, yeah,

2156
01:10:17,320 --> 01:10:19,000
four byte instruction and addi is

2157
01:10:19,000 --> 01:10:20,140
a two byte instruction.

2158
01:10:22,090 --> 01:10:25,270
好的，我来看看，基本上，实际上是从entr.s开始的。
Okay, I'm going to see, basically

2159
01:10:25,270 --> 01:10:27,130
so actually starts basically starts at

2160
01:10:27,130 --> 01:10:28,260
entry.S .

2161
01:10:28,360 --> 01:10:30,400
嗯，是的，我们在没有隔离的情况下没有寻呼，事实上我们是从[模式]开始的。
Um, yeah we've no paging with

2162
01:10:30,400 --> 01:10:31,660
no isolation and in fact we're

2163
01:10:31,660 --> 01:10:32,780
starting in [mode].

2164
01:10:33,260 --> 01:10:35,660
以独占方式尽可能快地跳转到内核模式或管理模式，这在RISC-V中被调用，我只是要在Main上设置一个断点，它实际上是在管理模式下运行的，我将在那里运行。
Exclusive jumps as quickly as

2165
01:10:35,660 --> 01:10:37,880
possible to

2166
01:10:37,940 --> 01:10:39,320
kernel mode or supervisor mode,

2167
01:10:39,320 --> 01:10:40,910
that called in RISC-V, I'm just

2168
01:10:40,910 --> 01:10:41,930
going to set a break point

2169
01:10:41,930 --> 01:10:43,790
at main which actually runs in

2170
01:10:43,790 --> 01:10:44,630
supervisor mode,

2171
01:10:44,630 --> 01:10:45,800
I'm going to run there.

2172
01:10:46,350 --> 01:10:47,550
然后我就到了Main的第一条指令。那么，让我展示一下，这是Main in，嗯，我想在这种布局下运行gdb，拆分模式。
And then I get to the

2173
01:10:47,550 --> 01:10:49,620
first instruction of main. So,

2174
01:10:50,750 --> 01:10:53,210
let me show this, here's main

2175
01:10:53,210 --> 01:10:54,720
in,

2176
01:10:54,980 --> 01:10:57,710
um, I'd like to run gdb

2177
01:10:57,710 --> 01:10:58,310
in this layout,

2178
01:10:58,310 --> 01:10:59,380
split mode.

2179
01:11:02,290 --> 01:11:03,460
所以你可以在gdb中看到，以及下一条指令正在被执行，所以你可以看到，在那个特定的指令处有一个断点。
So you can see in gdb

2180
01:11:03,460 --> 01:11:05,050
actually and what the next instruction

2181
01:11:05,050 --> 01:11:06,430
is being executed so you see,

2182
01:11:06,430 --> 01:11:07,690
there's a break point at that

2183
01:11:07,690 --> 01:11:08,980
particular instruction.

2184
01:11:09,180 --> 01:11:12,640
嗯，因为有一个只有一个CPU的运行QEMU，这使得gdb变得更容易一些，所以现在只有一个活动的内核。
Um, since there's a run

2185
01:11:12,750 --> 01:11:14,610
QEMU with one CPU,

2186
01:11:14,610 --> 01:11:15,690
just makes it, gdb a

2187
01:11:15,690 --> 01:11:16,770
little bit easier,

2188
01:11:16,770 --> 01:11:17,970
so there's now only one

2189
01:11:17,970 --> 01:11:19,080
core active.

2190
01:11:19,450 --> 01:11:21,130
qemu只模拟一个内核，我可以逐步完成，所以我可以执行下一条指令，其他人调用一个名为console init的函数，该函数的功能与您想象的完全一样，它实际设置了控制台。
QEMU emulates only one

2191
01:11:21,130 --> 01:11:22,840
single core and I can

2192
01:11:22,840 --> 01:11:24,190
step through that,

2193
01:11:24,190 --> 01:11:25,450
so I can go through

2194
01:11:25,450 --> 01:11:27,310
the next instruction and others

2195
01:11:27,310 --> 01:11:28,480
calls a function called console

2196
01:11:28,480 --> 01:11:30,040
init which does exactly

2197
01:11:30,040 --> 01:11:31,000
what you imagine it does

2198
01:11:31,000 --> 01:11:31,750
it actually sets up the

2199
01:11:31,750 --> 01:11:32,580
console.

2200
01:11:32,960 --> 01:11:34,040
一旦我们设置了控制台，我们就可以打印到它了，所以，你们会看到，我们很快就会得到一条新的行，并且会得到xv6引导。
And so once we set up

2201
01:11:34,040 --> 01:11:34,520
the console,

2202
01:11:34,520 --> 01:11:36,200
we can actually print to it

2203
01:11:36,200 --> 01:11:37,180
and so,

2204
01:11:37,240 --> 01:11:38,530
you'll see in a second we'll

2205
01:11:38,530 --> 01:11:40,060
get a new line and will

2206
01:11:40,060 --> 01:11:41,520
get xv6 booting.

2207
01:11:42,250 --> 01:11:43,870
好的，所以有一大堆额外的，嗯，代码来设置东西，你知道有一个设置页面分配器，设置一个虚拟内存，我们将在周三讨论，加载实际上开始打开分页，这也是我在周三讨论的。
Okay so there's a whole bunch

2208
01:11:43,870 --> 01:11:45,720
of additional, um,

2209
01:11:45,970 --> 01:11:47,200
code to set things up,

2210
01:11:47,200 --> 01:11:49,000
you know there's a setting up

2211
01:11:49,000 --> 01:11:50,290
the page allocator,

2212
01:11:50,290 --> 01:11:52,780
setting up a virtual memory, which

2213
01:11:52,780 --> 01:11:54,730
we'll talk about on wednesday, loading

2214
01:11:54,730 --> 01:11:56,530
actually starting turning paging on, which

2215
01:11:56,530 --> 01:11:58,160
I also talk about on wednesday.

2216
01:11:58,300 --> 01:12:00,640
嗯，设置初始进程或者发送进程表，由于内核位置的使用而设置代码，设置中断控制plic，我们在讨论中断的时候再谈，但是这是一回事。
Um, setting up the initial processes

2217
01:12:00,640 --> 01:12:02,470
or sending the process table,

2218
01:12:02,470 --> 01:12:04,330
setting up code due to

2219
01:12:04,330 --> 01:12:06,250
the use of the kernel position,

2220
01:12:06,250 --> 01:12:08,860
setting up the interrupt control

2221
01:12:08,860 --> 01:12:10,720
the plic, we'll talk about when

2222
01:12:10,720 --> 01:12:11,590
we talk about interrupts,

2223
01:12:11,590 --> 01:12:13,060
but this is one thing that.

2224
01:12:13,320 --> 01:12:14,970
嗯，我们主要用来与磁盘对话或使用中断与控制台对话，设置文件系统，分配缓冲区缓存，初始化索引节点缓存，初始化文件系统，初始化磁盘。
Um, we're gonna be using to

2225
01:12:14,970 --> 01:12:16,290
basically talk to the disk or

2226
01:12:16,290 --> 01:12:17,500
talk to the

2227
01:12:17,520 --> 01:12:19,140
console using interrupts,

2228
01:12:19,140 --> 01:12:21,060
sets up the file system

2229
01:12:21,060 --> 01:12:25,110
allocates a buffer cache initialize the

2230
01:12:25,110 --> 01:12:27,270
inode cache, initialize the file system

2231
01:12:27,270 --> 01:12:28,760
initialize the disk.

2232
01:12:29,060 --> 01:12:31,100
基本上，一旦所有的事情都设置好了，你就知道当操作系统运行的时候，它将开始运行第一个进程，这就是用户初始化。
And then basically once all sort

2233
01:12:31,100 --> 01:12:32,030
of things are set up,

2234
01:12:32,030 --> 01:12:32,990
you know when the operating system

2235
01:12:32,990 --> 01:12:33,680
is running,

2236
01:12:33,680 --> 01:12:34,580
it's going to start running the

2237
01:12:34,580 --> 01:12:36,470
first process and this is the

2238
01:12:36,470 --> 01:12:37,400
user init.

2239
01:12:38,010 --> 01:12:39,030
这里有一点有趣，所以我将转到user init，嗯，稍等片刻，我将在这里进行单步操作。
So there's a little bit of

2240
01:12:39,030 --> 01:12:40,380
interesting, so I'm going to go

2241
01:12:40,380 --> 01:12:41,250
to user init,

2242
01:12:41,250 --> 01:12:42,840
um, for a second I'm going

2243
01:12:42,840 --> 01:12:43,920
to single step there.

2244
01:12:46,040 --> 01:12:48,170
嗯，在继续之前，有任何关于这个的问题吗。
Um, before continue, any questions

2245
01:12:48,170 --> 01:12:48,900
about this.

2246
01:12:54,180 --> 01:12:55,590
是否存在需要调用设置函数的特定顺序。
Is there a specific order in

2247
01:12:55,590 --> 01:12:57,510
which the set-up functions need to

2248
01:12:57,510 --> 01:12:58,340
be called.

2249
01:12:58,410 --> 01:13:00,990
是的，有些函数，一旦我们追逐其他函数，嗯，它们特别在里面，有些无关紧要，但是有几个，对，它们追逐其他函数是很重要的。
Yes, some function,

2250
01:13:00,990 --> 01:13:02,580
once we run after other functions

2251
01:13:02,580 --> 01:13:03,450
and um,

2252
01:13:03,450 --> 01:13:05,580
they're in particular in there some

2253
01:13:05,580 --> 01:13:06,360
of them doesn't matter,

2254
01:13:06,360 --> 01:13:07,170
but a few of them yeah

2255
01:13:07,170 --> 01:13:08,310
it's important that they run after

2256
01:13:08,310 --> 01:13:08,980
other ones.

2257
01:13:11,350 --> 01:13:12,100
说得好。
Good point.

2258
01:13:12,840 --> 01:13:14,040
好的，嗯，让我转到，嗯，用户初始化。
Okay, um,

2259
01:13:14,040 --> 01:13:15,500
let me go to,

2260
01:13:16,920 --> 01:13:18,740
um, so user init.

2261
01:13:19,300 --> 01:13:20,320
基本上是用户初始化，有一点胶水代码，组织代码利用了所有通用的基础设施，卡片组基本上都得到了基础的第一个过程。
And basically user init there's

2262
01:13:20,320 --> 01:13:22,000
a little bit of glue code

2263
01:13:22,000 --> 01:13:24,250
organization code to take advantage of

2264
01:13:24,250 --> 01:13:26,830
all the general infrastructure decks have

2265
01:13:26,830 --> 01:13:28,180
basically get the first process of

2266
01:13:28,180 --> 01:13:28,960
the ground.

2267
01:13:29,430 --> 01:13:30,600
嗯，你知道xv6需要一些映像，我们还不能真正运行文件系统。
Um, you know xv6 needs

2268
01:13:30,600 --> 01:13:31,590
some image,

2269
01:13:31,590 --> 01:13:32,970
we can't run the file system

2270
01:13:32,970 --> 01:13:33,860
really yet.

2271
01:13:33,940 --> 01:13:35,740
嗯，或者做exec，嗯，等等xv6服务器的小程序，开始运行，那个小程序是初始化代码。
Um, or do exec,

2272
01:13:35,740 --> 01:13:37,870
um, and so xv6 server

2273
01:13:37,870 --> 01:13:39,340
small little program to get off

2274
01:13:39,340 --> 01:13:40,630
the ground and that small little

2275
01:13:40,630 --> 01:13:43,780
program is init code.

2276
01:13:44,100 --> 01:13:45,420
该程序的二进制版本实际上静态地链接或声明到内核中，并且代码对应于这个特定的用户程序。
And the binary version of that

2277
01:13:45,420 --> 01:13:48,270
program is actually linked or declared

2278
01:13:48,270 --> 01:13:50,190
statically into the kernel and the

2279
01:13:50,190 --> 01:13:52,160
fact that code corresponds

2280
01:13:54,300 --> 01:13:57,220
to this particular user program.

2281
01:14:00,290 --> 01:14:02,150
这是一个用汇编语言编写的小程序，基本上是这样做的，把里面的地址加载到a0中，把argv的地址加载到a1中。
It's a, it's a little

2282
01:14:02,150 --> 01:14:04,550
program written in assembly and basically

2283
01:14:04,550 --> 01:14:06,590
it does, loads the address in it

2284
01:14:06,590 --> 01:14:08,510
into a0, it loads

2285
01:14:08,510 --> 01:14:10,100
the address of argv into

2286
01:14:10,100 --> 01:14:11,020
a1.

2287
01:14:11,160 --> 01:14:12,390
然后它将这个SYS_EXEC的号码加载到A7中，然后看一下这里，它调用eCall。
And then it loads the number

2288
01:14:12,390 --> 01:14:14,010
for this SYS_exec in

2289
01:14:14,010 --> 01:14:15,960
to a7 and then look

2290
01:14:15,960 --> 01:14:17,880
at the here, that calls ecall.

2291
01:14:18,510 --> 01:14:19,740
基本上，它所做的就是运行三条指令，然后运行第四条指令，这些指令基本上是将控制权转移回操作系统，所以通常如果我在syscall中设置一个断点。
So basically what it does is

2292
01:14:19,740 --> 01:14:22,200
running three instructions and then running

2293
01:14:22,200 --> 01:14:24,120
the fourth instructions which basically transfer

2294
01:14:24,120 --> 01:14:26,720
back control to the,

2295
01:14:28,430 --> 01:14:30,980
back control to the operating system,

2296
01:14:30,980 --> 01:14:31,970
so generally if I set a

2297
01:14:31,970 --> 01:14:32,940
break point

2298
01:14:33,120 --> 01:14:34,800
in syscall.

2299
01:14:35,300 --> 01:14:36,650
嗯，现在继续运行，那么基本上你知道用户init，你知道将创建初始进程，返回到用户空间运行屏幕指令。
Um, and now keep running then

2300
01:14:36,650 --> 01:14:38,510
basically you know user init,

2301
01:14:38,510 --> 01:14:40,700
you know will create the initial

2302
01:14:40,700 --> 01:14:43,580
process return to user space run

2303
01:14:43,580 --> 01:14:45,060
the screen instructions.

2304
01:14:45,210 --> 01:14:46,200
或者用于指令，基本上回到内核空间。
Or for instruction,

2305
01:14:46,200 --> 01:14:47,430
and basically come back into

2306
01:14:47,430 --> 01:14:48,400
kernel space.

2307
01:14:49,040 --> 01:14:50,120
假设这是xv6中任何用户应用程序运行的第一个系统调用，那么让我们看看会发生什么。
So imagine this is the first

2308
01:14:50,120 --> 01:14:52,850
system call that any user application

2309
01:14:52,850 --> 01:14:53,930
in xv6 runs,

2310
01:14:53,930 --> 01:14:55,200
so let's see what happens.

2311
01:14:55,320 --> 01:14:56,320
如果我是对的话。
If I'm right.

2312
01:14:57,090 --> 01:14:59,520
所以我们继续，我们实际上到达了SysCall。
So we're continue and we

2313
01:14:59,520 --> 01:15:00,900
actually got to syscall.

2314
01:15:04,540 --> 01:15:05,650
嗯，所以我们可以系统调用，我们可以看一下，这是底部的一个函数。
Um, so we can syscall we

2315
01:15:05,650 --> 01:15:07,270
can look at it it's a

2316
01:15:07,270 --> 01:15:08,520
function at the bottom.

2317
01:15:09,340 --> 01:15:10,660
现在我们回到内核空间，我们要走一遍，看看在syscall中到底发生了什么，我也会简单地说一步。
And so we're back into kernel

2318
01:15:10,660 --> 01:15:12,610
space now and we're going to

2319
01:15:12,610 --> 01:15:13,960
walk through and see actually what

2320
01:15:13,960 --> 01:15:15,660
happens exactly in

2321
01:15:15,750 --> 01:15:17,700
syscall, also I'm gonna single

2322
01:15:17,700 --> 01:15:18,800
step a little bit.

2323
01:15:19,190 --> 01:15:21,080
嗯，它看起来是关于当前的，它里面的进程，你知道的，取出系统调用号，我们现在可以打印Num了。
Um, it looks about the current,

2324
01:15:21,080 --> 01:15:22,490
the processes within it,

2325
01:15:22,490 --> 01:15:24,440
you know that pulls out the

2326
01:15:24,440 --> 01:15:25,280
system call number,

2327
01:15:25,280 --> 01:15:26,330
that's used so we can now

2328
01:15:26,330 --> 01:15:27,440
print num.

2329
01:15:27,890 --> 01:15:29,540
让我们看看这是7个。
And let's see that's seven.

2330
01:15:29,980 --> 01:15:32,200
如果我们看一下哪一个，当内核syscall.h。
And if we look at which,

2331
01:15:34,130 --> 01:15:37,160
user when kernel

2332
01:15:37,160 --> 01:15:38,200
syscall.h .

2333
01:15:38,660 --> 01:15:40,130
它声明了所有的系统调用号，我们看到7个确实是系统调用的EXEC。
That declares all the system call

2334
01:15:40,130 --> 01:15:42,200
numbers and we see seven that

2335
01:15:42,200 --> 01:15:44,200
is indeed system called exec.

2336
01:15:44,940 --> 01:15:45,900
基本上，这会告诉内核您知道一些用户应用程序。
And so basically this tells

2337
01:15:45,900 --> 01:15:46,950
the kernel that you know

2338
01:15:46,950 --> 01:15:48,380
some user application.

2339
01:15:48,510 --> 01:15:51,330
A调用了回显指令，并且意图调用该系统调用，意图运行EXEC系统调用。
A called an echo instruction and

2340
01:15:51,330 --> 01:15:52,680
with the intention of calling this

2341
01:15:52,680 --> 01:15:55,320
system call for,

2342
01:15:58,180 --> 01:15:59,020
with the intention of running the

2343
01:15:59,020 --> 01:16:00,160
exec system call.

2344
01:16:00,910 --> 01:16:02,140
所以我们可以再往前走一步，嗯，我们来看看下一步，这是执行系统调用的那一行，所以让我们转到那里。
And so we can single step

2345
01:16:02,140 --> 01:16:03,280
a little bit further um,

2346
01:16:03,280 --> 01:16:04,570
we go through the next thing,

2347
01:16:04,570 --> 01:16:05,740
this is the line that executes

2348
01:16:05,740 --> 01:16:06,430
a system call,

2349
01:16:06,430 --> 01:16:07,540
so let's go there.

2350
01:16:07,800 --> 01:16:09,450
你可以看到，数字基本上是用来索引数组的，数组是一串函数指针。
And you see that basically the

2351
01:16:09,450 --> 01:16:11,100
number is used to index into

2352
01:16:11,100 --> 01:16:12,570
an array and arrays as a

2353
01:16:12,570 --> 01:16:14,040
bunch of function pointers.

2354
01:16:14,240 --> 01:16:17,120
您知道，大概sys条目指向sys exec函数，所以我们将单步进入这一步。
And presumably, the sys entry,

2355
01:16:17,120 --> 01:16:18,560
you know points to the sys

2356
01:16:18,560 --> 01:16:19,580
exec function,

2357
01:16:19,580 --> 01:16:20,900
so we're going to single step

2358
01:16:20,900 --> 01:16:22,020
into this.

2359
01:16:22,920 --> 01:16:24,180
嗯，我们看到我们实际上是在系统执行部门。
And, um,

2360
01:16:24,180 --> 01:16:25,410
we see that we're actually at

2361
01:16:25,410 --> 01:16:26,760
the sys exec.

2362
01:16:29,540 --> 01:16:30,800
嗯，所以这是在sys文件里。
Um, so this is in

2363
01:16:30,800 --> 01:16:32,060
sys file.

2364
01:16:32,810 --> 01:16:33,680
现在我们可以把它移动得更多一点，窗口更大一些。
Now we can move it a

2365
01:16:33,680 --> 01:16:36,460
little bit more and bigger window.

2366
01:16:36,520 --> 01:16:38,040
我们基本上可以在这里看到系统调用。
And we basically see

2367
01:16:38,310 --> 01:16:41,220
here, the system call.

2368
01:16:41,650 --> 01:16:42,790
嗯，你看到的第一件事实际上是从用户空间获取参数，所以它获得了路径名。
Um, and the first thing that

2369
01:16:42,790 --> 01:16:44,560
you see actually it actually gets

2370
01:16:44,560 --> 01:16:46,210
arguments from user space so it

2371
01:16:46,210 --> 01:16:47,540
gets the path name.

2372
01:16:47,790 --> 01:16:49,320
所以我们想跳得更远一点。
So we want jump a little

2373
01:16:49,320 --> 01:16:50,340
bit further.

2374
01:16:50,950 --> 01:16:54,040
Memset，嗯，嗯，基本上是为参数分配空间，您知道将所有参数从用户空间复制到内核空间，我们将在几周内详细介绍，所以现在不要太担心。
memset, um,

2375
01:16:55,430 --> 01:16:56,780
um,

2376
01:16:57,220 --> 01:16:59,470
basically allocates space for arguments,

2377
01:16:59,470 --> 01:17:00,760
you know copys all the arguments

2378
01:17:00,760 --> 01:17:02,080
from user space to kernel space,

2379
01:17:02,080 --> 01:17:03,760
we'll look down in great amount

2380
01:17:03,760 --> 01:17:05,050
of detail in a couple weeks

2381
01:17:05,050 --> 01:17:06,130
so don't worry about it too

2382
01:17:06,130 --> 01:17:06,920
much yet.

2383
01:17:07,190 --> 01:17:09,110
但是基本上有一些代码可以将参数从用户空间移动到内核空间，你知道，从内核，从用户地址空间到内核地址空间。
But basically there's some code to

2384
01:17:09,110 --> 01:17:10,730
move arguments user space to

2385
01:17:10,730 --> 01:17:11,480
kernel space,

2386
01:17:11,480 --> 01:17:12,590
you know from the kernel, from

2387
01:17:12,590 --> 01:17:13,880
the user address space to kernel

2388
01:17:13,880 --> 01:17:15,000
address space.

2389
01:17:15,110 --> 01:17:15,860
如果我们现在看PATH，你就有希望打印出PATH。
And if we now look

2390
01:17:15,860 --> 01:17:16,520
at path,

2391
01:17:16,520 --> 01:17:18,520
you can print the path hopefully.

2392
01:17:18,780 --> 01:17:20,190
你会看到，实际上你知道这是一个字符串，你会看到，基本上，这个小的内部代码程序所做的，就是试图执行init程序。
You'll see actually that you

2393
01:17:20,190 --> 01:17:21,720
know that is a string

2394
01:17:21,720 --> 01:17:23,550
and you'll see that basically

2395
01:17:23,550 --> 01:17:25,320
what that little inner code

2396
01:17:25,320 --> 01:17:27,210
program does is trying to

2397
01:17:27,210 --> 01:17:28,830
exex you know the init

2398
01:17:28,830 --> 01:17:29,580
program.

2399
01:17:29,790 --> 01:17:31,650
这是另一个程序，我们来看一下，看看是什么。
Which is yet another program,

2400
01:17:31,650 --> 01:17:32,760
so let's look at that for

2401
01:17:32,760 --> 01:17:34,240
a second just to see

2402
01:17:34,370 --> 01:17:35,420
what that is.

2403
01:17:38,140 --> 01:17:39,130
这里我们有init，init基本上设置了一些用于用户空间的东西，它向控制台打开，控制台的文件描述符，重复几次。
So here we have init

2404
01:17:39,130 --> 01:17:40,780
and init basically

2405
01:17:40,780 --> 01:17:41,860
sets up a couple things

2406
01:17:41,860 --> 01:17:43,030
use for user space,

2407
01:17:43,030 --> 01:17:44,650
it opens to console, the file

2408
01:17:44,650 --> 01:17:46,660
descriptor for the console, dup it

2409
01:17:46,660 --> 01:17:47,840
a couple times.

2410
01:17:48,000 --> 01:17:50,610
调用fork，基本上它实际做的第一件事就是开始创建一个新进程。
Calls fork and basically the first

2411
01:17:50,610 --> 01:17:52,050
thing it does actually it starts

2412
01:17:52,050 --> 01:17:53,840
to create a new process.

2413
01:17:53,920 --> 01:17:56,650
我们将退出shell，所以这最终会导致shell运行。
And we'll exit the shell and

2414
01:17:56,650 --> 01:17:58,120
so this will in the end

2415
01:17:58,120 --> 01:18:00,380
result as the shell being run.

2416
01:18:01,020 --> 01:18:01,980
例如，如果我要继续，我可能会再次中断，它显示为exec，如果我查看参数，我会发现实际上正在调用exec系统调用来执行shell。
So, for example if I would

2417
01:18:01,980 --> 01:18:03,480
continue I probably break again,

2418
01:18:03,480 --> 01:18:04,230
it says exec,

2419
01:18:04,230 --> 01:18:05,010
and if I look at the

2420
01:18:05,010 --> 01:18:06,810
arguments I will see that actually

2421
01:18:06,810 --> 01:18:08,550
the exec system call is being

2422
01:18:08,550 --> 01:18:11,140
called to execs the shell.

2423
01:18:11,510 --> 01:18:12,830
一旦你退出外壳，你知道，让我们这样做，然后我们会做更多的系统调用，在某个时刻，你会看到这一点。
And once you exit the shell,

2424
01:18:12,830 --> 01:18:13,040
you know,

2425
01:18:13,040 --> 01:18:14,450
let's do that,

2426
01:18:14,450 --> 01:18:16,280
then we'll do a couple more

2427
01:18:16,280 --> 01:18:17,960
system calls and at some point

2428
01:18:17,960 --> 01:18:19,000
you'll see that.

2429
01:18:19,900 --> 01:18:22,480
我要继续，然后外壳就开始运行了。
I'm gonna do continue then basically

2430
01:18:22,480 --> 01:18:23,700
the shell starts running.

2431
01:18:24,930 --> 01:18:25,680
所以它给了您一点感觉，您知道xv6实际上是如何开始的，第一个shell出口是如何运行的，我们看到了关于第一个系统调用实际发生时第一个出口是如何发生的。
So it gives you a little

2432
01:18:25,680 --> 01:18:26,700
bit of sense,

2433
01:18:26,700 --> 01:18:28,170
you know actually how xv6

2434
01:18:28,170 --> 01:18:29,850
gets off the ground, the

2435
01:18:29,850 --> 01:18:31,890
first shell exit gets run and

2436
01:18:31,890 --> 01:18:33,360
we saw this sort of a

2437
01:18:33,360 --> 01:18:34,710
little bit of an overview about

2438
01:18:34,710 --> 01:18:36,150
how the first when the first

2439
01:18:36,150 --> 01:18:37,540
system call actually happened.

2440
01:18:38,160 --> 01:18:39,510
我们还没有真正了解这些系统调用的潜水机制如何进入和离开内核，我们将在几周或两周的课程中详细讨论这一点，但这已经足够让你们了解如何实际做系统调用实验室了，你知道我们这周布置的。
We haven't really looked at the

2441
01:18:39,510 --> 01:18:41,430
dive machinery for these system calls

2442
01:18:41,430 --> 01:18:42,390
how to get in and out

2443
01:18:42,390 --> 01:18:43,260
of the kernel,

2444
01:18:43,260 --> 01:18:44,160
we're going to talk about it

2445
01:18:44,160 --> 01:18:45,570
in a couple weeks or two

2446
01:18:45,570 --> 01:18:47,190
weeks in lecture, in great

2447
01:18:47,190 --> 01:18:48,000
amount of detail,

2448
01:18:48,000 --> 01:18:48,630
but this is sort of

2449
01:18:48,630 --> 01:18:50,220
enough for you to understand

2450
01:18:50,220 --> 01:18:51,510
actually how to do the

2451
01:18:51,510 --> 01:18:52,710
syscall lab, you know that

2452
01:18:52,710 --> 01:18:54,360
we assigned for this week.

2453
01:18:54,670 --> 01:18:55,960
嗯，那么这些就是你们将要互动的片段。
Um, and so these are

2454
01:18:55,960 --> 01:18:56,740
the pieces that you will

2455
01:18:56,740 --> 01:18:57,720
be interacting with.

2456
01:18:59,120 --> 01:19:00,980
在我结束之前有什么问题吗，因为我们快没时间了。
Any questions before I wrap up,

2457
01:19:00,980 --> 01:19:02,600
because we're almost out of time.

2458
01:19:08,330 --> 01:19:09,720
你可以随心所欲地射击。
You're free to fire away.

2459
01:19:15,680 --> 01:19:17,240
我们要做什么，嗯，网络就像网络和实验室。
Are we going to do anything

2460
01:19:17,240 --> 01:19:20,180
with, um, networks are like networking

2461
01:19:20,180 --> 01:19:21,680
and labs.

2462
01:19:21,810 --> 01:19:23,580
是的，最后一个实验是实现网络驱动程序。
Yes, the last lab is

2463
01:19:23,580 --> 01:19:25,360
you implement a network driver.

2464
01:19:25,560 --> 01:19:26,340
因此，您将编写与硬件交互的代码，您必须操作网络驱动程序或网卡的寄存器。
And so you will write the

2465
01:19:26,340 --> 01:19:28,050
code that interacts with the hardware

2466
01:19:28,050 --> 01:19:30,080
you have to manipulate the

2467
01:19:30,280 --> 01:19:32,380
register for the network driver or

2468
01:19:32,380 --> 01:19:34,480
a network card.

2469
01:19:34,680 --> 01:19:36,300
嗯，它基本上将你连接到这个RISC-V板，你知道你看到的是一个挡路，基本上是插入以太网控制器，一根电缆，所以有一块以太网卡。
Um that basically connects you to

2470
01:19:36,300 --> 01:19:37,560
this RISC-V board, you know

2471
01:19:37,560 --> 01:19:38,940
you saw that was a block

2472
01:19:38,940 --> 01:19:40,800
basically to plugin an ethernet control,

2473
01:19:40,800 --> 01:19:42,330
a cable so there's an

2474
01:19:42,330 --> 01:19:43,940
ethernet card.

2475
01:19:44,260 --> 01:19:45,580
因此，您将对该卡进行编程，实际上您将通过Internet发送一些数据包。
And so you're gonna be programming

2476
01:19:45,580 --> 01:19:47,410
that card and you're gonna actually

2477
01:19:47,410 --> 01:19:49,160
send some packets across the Internet.

2478
01:19:51,690 --> 01:19:53,100
太好了，谢谢。是的，这是最后一个实验室。
Great, thanks. Yeah,

2479
01:19:53,100 --> 01:19:54,140
it's the last lab.

2480
01:19:58,160 --> 01:19:59,280
还有其他问题吗。
Any other questions.

2481
01:20:04,270 --> 01:20:05,110
我认为Syscall实验室本身，嗯，因为我们不会讲太多细节，希望不会太糟糕，可能比Util实验室更容易。
We're gonna let me wrap up

2482
01:20:05,110 --> 01:20:06,520
here I think the syscall

2483
01:20:06,520 --> 01:20:07,660
lab itself,

2484
01:20:07,660 --> 01:20:10,030
um because we're not really going

2485
01:20:10,030 --> 01:20:11,080
great amount of detail,

2486
01:20:11,080 --> 01:20:12,430
hopefully shouldn't be too bad,

2487
01:20:12,430 --> 01:20:13,480
might be easier than

2488
01:20:13,480 --> 01:20:14,680
the util lab.

2489
01:20:14,880 --> 01:20:16,650
然而，下一个实验可能会更困难，所以总是很难把所有这些实验都做好，但SysCall实验室希望它不会太难，但请不要开始，不要等到前一天晚上才开始，这样如果你运行的是一些晦涩难懂的错误，我们可以真正帮助你，确保你的程序在其中工作。
Labs, next lab,

2490
01:20:16,650 --> 01:20:18,210
however might be more difficult,

2491
01:20:18,210 --> 01:20:19,200
so it's always hard to get

2492
01:20:19,200 --> 01:20:20,130
all these labs right,

2493
01:20:20,130 --> 01:20:21,810
but syscall lab hopefully it shouldn't

2494
01:20:21,810 --> 01:20:23,280
be too difficult,

2495
01:20:23,280 --> 01:20:24,990
but please don't start don't

2496
01:20:24,990 --> 01:20:26,340
wait until the night before

2497
01:20:26,340 --> 01:20:27,660
get going early,

2498
01:20:27,660 --> 01:20:28,650
so that if you're running some

2499
01:20:28,650 --> 01:20:30,060
obscure bug that we can actually

2500
01:20:30,060 --> 01:20:31,470
help you out and make sure

2501
01:20:31,470 --> 01:20:33,500
that your program works in it.

2502
01:20:35,270 --> 01:20:36,200
到此为止，嗯，我要签字了，周三见。
With that,

2503
01:20:36,200 --> 01:20:38,900
um, I'll sign off and I'll

2504
01:20:38,900 --> 01:20:40,060
see you in Wednesday.
