1
00:00:00,180 --> 00:00:06,020
And can everybody see my screen or the whiteboard that I shared.

2
00:00:06,890 --> 00:00:07,550
Okay good.

3
00:00:09,250 --> 00:00:11,650
How are people doing with the lock lab,

4
00:00:11,680 --> 00:00:20,330
let me start there, just ask if, how progress and what its more difficult or it's looking.

5
00:00:20,330 --> 00:00:24,650
Okay, anybody who want to report on their experience so far.

6
00:00:30,520 --> 00:00:32,560
I hope lots of people have started.

7
00:00:37,130 --> 00:00:37,430
Oh yeah.

8
00:00:37,460 --> 00:00:39,920
Yeah, go ahead.

9
00:00:40,250 --> 00:00:41,390
Oh, sorry, go ahead.

10
00:00:42,050 --> 00:00:42,980
Okay, cool.

11
00:00:45,130 --> 00:00:46,660
I'll go, I'll go.

12
00:00:47,440 --> 00:00:57,420
The lock lab, I think the first part, the the kalloc on was not as bad,

13
00:00:57,450 --> 00:01:01,830
well, and then the second part was a bit harder,

14
00:01:01,890 --> 00:01:04,800
well it's a lot harder in my opinion.

15
00:01:06,180 --> 00:01:10,780
You just have to figure out a,

16
00:01:11,730 --> 00:01:16,530
I guess the hard part was thinking of a solution that,

17
00:01:17,460 --> 00:01:19,410
It's like hey this doesn't cause deadlock,

18
00:01:19,410 --> 00:01:26,300
but then if you think there are cases where like deadlock ha- could happen

19
00:01:26,300 --> 00:01:30,350
if you acquire a [] it's lock again and all that stuff,

20
00:01:30,350 --> 00:01:34,520
but yeah I just have to think, you have to think

21
00:01:34,520 --> 00:01:37,280
like about extra cases and all that stuff

22
00:01:37,280 --> 00:01:39,200
and after that it shouldn't be that bad.

23
00:01:40,130 --> 00:01:43,910
Anybody else who want to share their experience so far.

24
00:01:44,240 --> 00:01:49,010
I want to ask, are we allowed to do any part of the lab like lock free,

25
00:01:49,010 --> 00:01:51,350
because I know like their first part,

26
00:01:51,350 --> 00:01:57,170
for example it's pretty the instructions said pretty clearly like make apparel memory allocator,

27
00:01:57,170 --> 00:02:00,230
but can we do it just lock free

28
00:02:00,230 --> 00:02:03,410
and think, you know leave it as it is.

29
00:02:03,560 --> 00:02:06,920
You're free to do any solution to pass which made great,

30
00:02:07,700 --> 00:02:11,480
it's fine lock free,

31
00:02:11,480 --> 00:02:14,120
I would be a you are certainly free to do it.

32
00:02:14,510 --> 00:02:16,400
I'd be hesitant to start there,

33
00:02:16,430 --> 00:02:21,110
if I were you I would start first with a more fine-grained lock implementation

34
00:02:21,110 --> 00:02:23,210
and then move to the lock free implementation.

35
00:02:24,140 --> 00:02:27,320
So the reason there is not started with a walk free,

36
00:02:27,320 --> 00:02:31,160
because if you go to a fine grain you need to do all of the parallel stuff,

37
00:02:31,160 --> 00:02:33,170
but if you just go directly to a lock free one,

38
00:02:33,170 --> 00:02:36,020
then you can keep it on a single free list

39
00:02:36,020 --> 00:02:40,940
and you just need to you just need to [automata] size,

40
00:02:40,940 --> 00:02:44,240
the free and allocate operations which actually isn't that bad.

41
00:02:45,120 --> 00:02:47,010
Yeah I think maybe in a,

42
00:02:47,010 --> 00:02:49,890
if there's a single list in the case of the kalloc that might be the case,

43
00:02:49,890 --> 00:02:54,030
I think you know the lock free [balloc] is going to be a more complicated.

44
00:02:54,360 --> 00:02:56,580
Yeah, that I'm scared to do.

45
00:02:56,640 --> 00:02:59,730
But that's the right reaction to have.

46
00:03:01,440 --> 00:03:02,520
Anybody else?

47
00:03:04,950 --> 00:03:08,370
I found it a bit hard to debug those problems,

48
00:03:08,370 --> 00:03:11,040
because it's not immediately clear what is happening,

49
00:03:11,040 --> 00:03:18,090
so we have to go and set with gdb and break break break, and yeah.

50
00:03:18,980 --> 00:03:23,810
Yeah I think the only, one reason I'm always scared to get these lock labs I said,

51
00:03:23,810 --> 00:03:26,030
labs you know they're harder to debug,

52
00:03:26,510 --> 00:03:30,620
and you know the bug might not show up on every run.

53
00:03:31,200 --> 00:03:35,070
And but hopefully it is very educational,

54
00:03:35,070 --> 00:03:39,270
because learning a program locks inside the kernel is a real thing,

55
00:03:39,270 --> 00:03:43,050
and but it is definitely a core challenge.

56
00:03:44,100 --> 00:03:48,900
One thing about maybe there's a node for the course,

57
00:03:48,900 --> 00:03:51,270
you know the next lab actually doesn't involve,

58
00:03:51,300 --> 00:03:56,610
basically any concurrency and should hopefully that will be much more straightforward.

59
00:03:59,760 --> 00:04:00,150
Okay.

60
00:04:00,150 --> 00:04:07,410
I gue-, I guess, how do you how do you efficiently or effectively debug concurrent programs,

61
00:04:07,410 --> 00:04:10,950
like with all those multiple threads using gdb.

62
00:04:10,950 --> 00:04:15,570
I use very basic stuff, I have use print statements.

63
00:04:15,990 --> 00:04:22,230
But the main thing I rely on is I sort of tried to write down or assertions for invariants,

64
00:04:22,230 --> 00:04:24,810
that I think should be true at every point.

65
00:04:25,490 --> 00:04:27,650
And if the assertion goes off,

66
00:04:27,650 --> 00:04:31,400
then I know that you know there's something wrong in my thinking or assertion was wrong.

67
00:04:31,900 --> 00:04:36,580
And then I think for a while and try to decide what it is,

68
00:04:36,610 --> 00:04:38,140
and then go from there.

69
00:04:38,620 --> 00:04:44,830
The normal for many other settings,

70
00:04:44,830 --> 00:04:47,680
there are race detectors that can help you,

71
00:04:47,680 --> 00:04:55,270
and again basically flag code that mean looks like it might be having problems

72
00:04:55,360 --> 00:04:57,640
or as prone to race conditions,

73
00:04:57,820 --> 00:05:00,940
but that's a whole set of other tools,

74
00:05:01,060 --> 00:05:03,010
that we're not using.

75
00:05:03,770 --> 00:05:06,770
And it's not that [good],

76
00:05:06,770 --> 00:05:10,490
but there's a little bit of a big step to actually get that all up and going and running.

77
00:05:11,270 --> 00:05:14,480
So that's the other mechanism that people use race detectors.

78
00:05:16,960 --> 00:05:22,270
Basically flag, any any shared variable that is updated or read without actually holding a lock.

79
00:05:24,460 --> 00:05:25,930
That doesn't help with deadlocks,

80
00:05:25,930 --> 00:05:30,970
for example in this lab in a bcache lock, you and you get deadlocks,

81
00:05:31,060 --> 00:05:33,280
deadlocks are tend to be easier to do debug correct,

82
00:05:33,280 --> 00:05:38,110
because you can get the panic and then you can look at the gdb in the backtrace

83
00:05:38,110 --> 00:05:40,720
and see actually was involved in the deadlock.

84
00:05:44,620 --> 00:05:47,830
Does that make sense? Thank you.

85
00:05:50,050 --> 00:05:54,430
Okay, another suggestion, actually somebody posted on the feedback,

86
00:05:54,430 --> 00:05:59,500
is you know classes are ten is getting a little bit lower than in the beginning of the semester,

87
00:05:59,500 --> 00:06:02,230
and I think we might be small enough for the size

88
00:06:02,230 --> 00:06:05,080
that it may be perfectly fine to actually have cameras on.

89
00:06:05,630 --> 00:06:10,700
And so maybe I want to encourage you to if you ask a question to turn on your camera,

90
00:06:11,210 --> 00:06:14,840
you know will hopefully improve in our experiences,

91
00:06:14,840 --> 00:06:17,630
if you've seen the classroom as opposed to in a virtual meeting.

92
00:06:18,980 --> 00:06:21,380
And you don't have to look at me.

93
00:06:22,720 --> 00:06:27,760
Okay, so, okay, today's lecture,

94
00:06:27,850 --> 00:06:32,560
so today's lecture is going to be about crash safety and crash safety file systems,

95
00:06:32,800 --> 00:06:35,590
and this is not crash safety in its most general form,

96
00:06:35,590 --> 00:06:43,450
actually I'm really focusing on a particular problem, or a specific problem,

97
00:06:43,480 --> 00:07:00,360
namely a crash or power failure can lead on-disk file system to be in an inconsistent state for an incorrect state.

98
00:07:04,080 --> 00:07:05,970
And what I mean, with an incorrect state is known

99
00:07:05,970 --> 00:07:08,760
for example a data block belongs two files,

100
00:07:08,790 --> 00:07:13,500
or an inode is allocated to different files.

101
00:07:14,140 --> 00:07:18,940
And so the scenario where this problem might sort of appear is,

102
00:07:18,940 --> 00:07:25,530
let's say you know your running make, makes pretty file system interact with the file system,

103
00:07:25,740 --> 00:07:26,970
reads writes files

104
00:07:27,180 --> 00:07:31,320
and somewhere during you know that thing [] a power failure happens,

105
00:07:33,920 --> 00:07:36,110
you know if maybe your laptop run out of battery,

106
00:07:36,290 --> 00:07:40,370
you know maybe the power just dropped to your house,

107
00:07:40,370 --> 00:07:47,980
and you know you reboot, the power comes back on at some point,

108
00:07:48,370 --> 00:07:51,340
you reboot the machine, machine comes back up

109
00:07:51,370 --> 00:07:54,280
and then you get a prompt again,

110
00:07:54,280 --> 00:07:58,450
you run ls and you hope basically that your file system is in a good state,

111
00:07:59,200 --> 00:08:01,120
in the state actually can still use it.

112
00:08:01,880 --> 00:08:05,060
And so the particular failures or crashes that we're concerned about

113
00:08:05,060 --> 00:08:08,300
are basically power failures during file system operations

114
00:08:08,510 --> 00:08:15,260
or the kernel panics you know while running some file system operation, xv6 is panics,

115
00:08:15,260 --> 00:08:19,400
most kernels are panics, you know maybe they're some kernel bug that causes a panic

116
00:08:19,580 --> 00:08:21,560
and you know suddenly your system just fails.

117
00:08:22,350 --> 00:08:23,520
And what you'd like to be the case

118
00:08:23,520 --> 00:08:25,470
that after rebooting you can actually do something,

119
00:08:26,430 --> 00:08:28,080
or you can still use the file system.

120
00:08:28,590 --> 00:08:30,570
And this might be something where you're thinking well,

121
00:08:30,600 --> 00:08:35,730
how could that not be right, because the file system stored on a persistent storage medium

122
00:08:35,730 --> 00:08:41,100
and so if the power fails, you know that medium should be good, then so once machine comes back up,

123
00:08:41,100 --> 00:08:43,050
you know all the blocks that you've written should be there.

124
00:08:43,730 --> 00:08:50,780
And we'll see that the tricky cases that many file system operations have multi-step operations.

125
00:08:51,240 --> 00:08:54,300
And really what is important to note

126
00:08:54,300 --> 00:08:59,490
and if we if we crash just in the wrong place, in these multi-step operations,

127
00:08:59,580 --> 00:09:04,530
the file system actually may end up being an this inconsistent for that short period of time

128
00:09:04,650 --> 00:09:07,980
and if the power fail just happened there, you know something bad could happen.

129
00:09:08,740 --> 00:09:13,450
And so that is sort of the problem that we're focusing on today

130
00:09:13,870 --> 00:09:18,100
and so this is different from the problem that for example whatever you know there's a power failure

131
00:09:18,100 --> 00:09:22,060
and your disk caught fire and so there's nothing there anymore

132
00:09:22,090 --> 00:09:26,860
and you need to in that case, you need you need there's a completely different problem,

133
00:09:26,860 --> 00:09:32,160
that has different solutions, you know, for example you have to go back to backup of your file system,

134
00:09:32,160 --> 00:09:34,470
reinstall your file system, etc etc,

135
00:09:35,310 --> 00:09:37,020
so that's the problem, we're not worried about.

136
00:09:37,020 --> 00:09:44,160
We're really worried about the specific problem of failure happening right during a multi-step operation.

137
00:09:46,380 --> 00:09:49,270
Okay, and the solution for that specific problem that

138
00:09:49,270 --> 00:09:53,050
we're going to be exploring is something that is called logging,

139
00:09:53,260 --> 00:09:56,950
and this is a very popular solution,

140
00:09:56,950 --> 00:10:00,970
originally coming out of the database world,

141
00:10:00,970 --> 00:10:04,600
but a lot of file systems that use logging these days.

142
00:10:05,100 --> 00:10:10,440
We're gonna, it's very one reason it's popular is because it's a very principled solution,

143
00:10:10,650 --> 00:10:16,440
and we're going to see the institution of logging in xv6

144
00:10:16,650 --> 00:10:19,230
and of course xv6 has a very simple implementation,

145
00:10:19,230 --> 00:10:24,840
like a bare minimal implementation of logging, just to demonstrate in the key ideas,

146
00:10:25,270 --> 00:10:29,110
and even that sort of a very bare bone,

147
00:10:29,110 --> 00:10:32,740
log implementation actually has several issues, that were going to be talking about

148
00:10:32,800 --> 00:10:34,750
and that's why it's worth you know studying it.

149
00:10:35,410 --> 00:10:39,220
One downside as we'll see, is the xv6 solution is

150
00:10:39,220 --> 00:10:42,190
because of simplicity, its performance is also not so great.

151
00:10:42,900 --> 00:10:45,900
Even though logging systems in principle can get a good performance,

152
00:10:46,170 --> 00:10:53,400
and so what we'll do next week is actually look how, how to implement a high performance logging system

153
00:10:53,490 --> 00:10:58,680
by studying the logging system, the Linux ext3 file system uses,

154
00:10:59,320 --> 00:11:00,820
but that's next week.

155
00:11:01,860 --> 00:11:05,910
Another, may be small a point I want to make today

156
00:11:05,910 --> 00:11:08,460
is this is our last xv6 lecture

157
00:11:08,850 --> 00:11:13,770
and from now on, we're going to be switching to papers,

158
00:11:13,950 --> 00:11:18,480
because in some ways, what we've done is we've covered you know the basic concepts

159
00:11:18,630 --> 00:11:24,030
and we can start looking at more advance operating system ideas by reading papers.

160
00:11:24,830 --> 00:11:25,550
Okay.

161
00:11:27,130 --> 00:11:28,210
Any questions so far?

162
00:11:34,590 --> 00:11:35,280
Well good.

163
00:11:38,080 --> 00:11:43,300
Okay, so let me go back a little bit about the scenarios that were really,

164
00:11:43,420 --> 00:11:46,990
that we're focusing about in in this lecture.

165
00:11:47,470 --> 00:11:51,190
So file systems, file system operations,

166
00:11:52,380 --> 00:11:58,170
like creating a file, writing a file, are multi-step disk operations.

167
00:12:06,400 --> 00:12:09,940
And we saw that last week on Monday,

168
00:12:09,940 --> 00:12:11,770
we talked about how create is implemented,

169
00:12:11,770 --> 00:12:13,690
like creating a file, or writing to a file,

170
00:12:13,690 --> 00:12:19,630
we often see that you know the sequence of events, or something the sequence of steps are allocated inode,

171
00:12:19,630 --> 00:12:21,370
mark the inode allocated on disk,

172
00:12:21,460 --> 00:12:24,700
then you know write the directory block that contains that inode

173
00:12:24,730 --> 00:12:26,980
and so those are the multi-steps that I'm talking about.

174
00:12:27,540 --> 00:12:30,960
If we get a crash between two of the steps,

175
00:12:31,080 --> 00:12:41,720
that can crash can leave, maybe mayb leave the file system invariance violated.

176
00:12:45,440 --> 00:12:50,150
And violent, the invariance I'm talking about are invariance of the form,

177
00:12:50,390 --> 00:12:56,900
you know every block is either free or allocated to one file and not to two files.

178
00:12:57,420 --> 00:13:00,390
And you know we want to make sure that this happens,

179
00:13:00,390 --> 00:13:05,310
despite you know these failures right between these operations.

180
00:13:06,880 --> 00:13:13,280
Yeah, and the risk is if if the invariance are violated,

181
00:13:13,790 --> 00:13:16,220
that bad things can happen after reboot,

182
00:13:17,510 --> 00:13:20,960
you know the you might crash again immediately.

183
00:13:21,930 --> 00:13:25,380
Because you know there's some data structure, the file system you know in a state

184
00:13:25,380 --> 00:13:29,640
that the file system actually can't really deal with on this data structures in such a state,

185
00:13:29,760 --> 00:13:32,910
[shape] that the file system really can't process them anymore,

186
00:13:33,240 --> 00:13:37,730
or more likely you're not crash, no crash,

187
00:13:37,790 --> 00:13:40,460
but you know data may get lost,

188
00:13:41,340 --> 00:13:43,920
or you read or write incorrect data.

189
00:13:52,630 --> 00:13:56,050
And we'll see a couple of examples, you know to make it more clear,

190
00:13:56,140 --> 00:13:59,260
but so these are the risks that we're worried about.

191
00:14:02,020 --> 00:14:07,600
I don't know if anybody actually every personal life or in your daily life using computers

192
00:14:07,600 --> 00:14:13,360
actually has experienced a problem where basically, you had a failure in the file system

193
00:14:13,360 --> 00:14:15,670
where you had a failure had a power failure,

194
00:14:15,670 --> 00:14:23,110
your machine rebooted or your phone restarted and a basically unusable afterwards.

195
00:14:23,980 --> 00:14:25,450
One reason that might be unusual,

196
00:14:25,450 --> 00:14:28,000
because actually the file system just didn't recover correctly.

197
00:14:37,370 --> 00:14:42,500
Okay, so to make it more clear, let's just let's look at an example in the context of xv-,

198
00:14:42,500 --> 00:14:45,560
I like to make this risk a little bit more concrete,

199
00:14:45,740 --> 00:14:51,110
let's look at an example in the context of xv6 and to see what actually go could go wrong.

200
00:14:52,020 --> 00:15:00,120
So remember the, for Monday the xv6 file system, very simple file system has a simple disk layou,

201
00:15:00,510 --> 00:15:04,440
you know super block, a super block,

202
00:15:04,440 --> 00:15:08,070
there's the log, that we're going to be talking about a lot today, that we didn't talk about on Monday,

203
00:15:08,280 --> 00:15:13,530
where inodes you know set of blocks that actually contain each and each block may contain multiply inodes,

204
00:15:13,650 --> 00:15:17,880
just bitmap that block to record which blocks are free and which are not free,

205
00:15:18,120 --> 00:15:22,530
and then the data blocks actually contain the actual data of the file system.

206
00:15:23,460 --> 00:15:27,750
You remember from Monday's lecture I reproduce the trace here,

207
00:15:27,750 --> 00:15:30,600
you know we looked at actually a how files created

208
00:15:31,020 --> 00:15:34,680
and you know we see that the creation of a single file.

209
00:15:35,370 --> 00:15:36,900
Well, wait a second.

210
00:15:41,460 --> 00:15:46,240
The, the creation of a single file consists of multiple operations,

211
00:15:46,360 --> 00:15:51,340
for example in this particular scenario that I've here on the, on on this slide,

212
00:15:51,670 --> 00:15:57,610
we see the, you know inode it's allocated

213
00:15:57,670 --> 00:16:01,300
and we know this because there's block 33 is being written,

214
00:16:01,570 --> 00:16:05,380
do we see that the inode is being initialized,

215
00:16:05,380 --> 00:16:07,090
then write again to block 33,

216
00:16:07,330 --> 00:16:10,030
then we see the block 46 is written

217
00:16:10,030 --> 00:16:15,970
and that reason is written is presumably, because you know the directory block that actually contains x

218
00:16:16,120 --> 00:16:18,820
and the inode number for x is written to the disk.

219
00:16:19,240 --> 00:16:28,630
Then the inode, root inode updated to reflect that the directory has grown in size to contain this particular file x

220
00:16:28,840 --> 00:16:30,820
and then you know inode updated.

221
00:16:31,650 --> 00:16:38,680
So, what we want to understand is what happens, like what could possibly go wrong, right,

222
00:16:39,040 --> 00:16:44,890
so let's say you know we have a power failure right here,

223
00:16:45,100 --> 00:16:49,060
so here is power failure or kernel crash.

224
00:16:52,160 --> 00:16:53,660
So what happens after the power failure,

225
00:16:53,660 --> 00:16:56,300
correct all the in-memory state is lost,

226
00:16:56,600 --> 00:17:00,260
because in-memory state data that's actually in RAM,

227
00:17:00,260 --> 00:17:06,930
like all the processes all the file descriptors, all the in-memory caches are gone,

228
00:17:07,140 --> 00:17:09,420
because memory is not persistent

229
00:17:09,600 --> 00:17:13,110
and the only thing that we have left is what actually is on the disk,

230
00:17:13,650 --> 00:17:18,090
so only the data structures, the bits and bytes,

231
00:17:18,090 --> 00:17:22,200
they're actually sitting on the disk are survived the power failure,

232
00:17:22,410 --> 00:17:27,120
because that actually medium is you know persistence or has durability.

233
00:17:28,100 --> 00:17:29,810
And so we want to know, like we understand,

234
00:17:30,380 --> 00:17:34,370
so if we crash here and we have no additional mechanisms,

235
00:17:34,520 --> 00:17:37,910
or no logging as we're going to be talking about,

236
00:17:37,970 --> 00:17:41,120
we have no additional mechanisms, how how bad is it.

237
00:17:42,750 --> 00:17:45,300
What risk are we running here.

238
00:17:53,750 --> 00:17:54,380
Anybody?

239
00:17:57,670 --> 00:18:03,520
So basically you know we've written block 33 to record the inode has been allocated,

240
00:18:03,580 --> 00:18:05,650
then we had a power failure and then we come back up.

241
00:18:07,780 --> 00:18:08,260
Go ahead Brandon.

242
00:18:13,300 --> 00:18:18,280
This does that mean we lose the, lose this block,

243
00:18:18,780 --> 00:18:21,810
it's like it seems like it's populated, but it's actually not.

244
00:18:22,290 --> 00:18:25,830
Yeah, correctly, I think we're losing we're losing the whole block,

245
00:18:25,830 --> 00:18:28,500
but we used inode x, correct inode x,

246
00:18:29,070 --> 00:18:34,320
and inode for x that was allocated os marked as allocated is allocated on disk,

247
00:18:34,470 --> 00:18:40,350
but we have not put in any, we've not succeeded, correct, put in any directory.

248
00:18:41,120 --> 00:18:43,880
So basically on the disk, you know there's an inode allocated,

249
00:18:43,880 --> 00:18:45,860
but it doesn't appear in any directory,

250
00:18:46,160 --> 00:18:48,110
so we can't even remove it right.

251
00:18:48,830 --> 00:18:52,970
And so basically what will this cause has to happen is we lose lose an inode.

252
00:18:57,200 --> 00:18:57,920
Does that make sense?

253
00:19:01,260 --> 00:19:05,100
You might think, well maybe what I should do is maybe I should reorder the write.

254
00:19:05,830 --> 00:19:09,610
And, in a way you know then hopefully you know this, you know we don't lose the inode,

255
00:19:09,610 --> 00:19:12,820
so for example another thing we could try doing is say well what we'll do is,

256
00:19:12,940 --> 00:19:21,320
we'll write 46 first, basically update the inode updated directory, right,

257
00:19:21,320 --> 00:19:25,920
the directory inode you know write 32

258
00:19:25,950 --> 00:19:35,900
and then will actually mark the inode is allocated on disk, to mark indicate that mark is allocated.

259
00:19:36,650 --> 00:19:39,470
So we do the same set of operations in a slightly different order.

260
00:19:40,050 --> 00:19:44,580
In the hope that we should avoid this losing of the inode problem.

261
00:19:45,680 --> 00:19:46,910
And would this work.

262
00:19:50,980 --> 00:19:55,600
Well, the thing that we should ask ourselves like you know let's think about this point in time,

263
00:19:55,810 --> 00:19:57,970
let's say a crash happens like right here

264
00:19:57,970 --> 00:20:05,180
or power failure happens right between updating the directory basically, but before we allocated the inode on disk

265
00:20:05,210 --> 00:20:08,720
and now you know we power fails machine comes back up

266
00:20:08,960 --> 00:20:10,220
and we look at the file system,

267
00:20:10,250 --> 00:20:12,500
you know what state will the file system be in.

268
00:20:15,200 --> 00:20:17,780
You'll still think it's a free inode in.

269
00:20:19,420 --> 00:20:24,490
Yeah what would happen if for example we read you know file x in the directory, in the root directory,

270
00:20:24,490 --> 00:20:26,620
because it is in there, now correcting this data block.

271
00:20:30,080 --> 00:20:34,160
We're going to be reading the inode, that actually is not even allocated correct, marked unallocated.

272
00:20:34,950 --> 00:20:39,480
And worse, what could happen is correct inode it might be allocated again,

273
00:20:39,540 --> 00:20:41,250
or it might actually really be allocated,

274
00:20:41,610 --> 00:20:46,560
because marks unallocated to actually in fact a different file, right,

275
00:20:46,950 --> 00:20:50,130
and so now we have two files that might actually,

276
00:20:50,130 --> 00:20:53,550
two files that actually share even though they're completely different,

277
00:20:53,550 --> 00:20:54,690
they share the same inode,

278
00:20:55,350 --> 00:20:58,950
for example if one file would be owned by user one and one by user two,

279
00:20:58,950 --> 00:21:02,130
then basically user two could read user one file data right.

280
00:21:03,770 --> 00:21:05,150
So that's no good, either, right.

281
00:21:11,230 --> 00:21:11,980
Does that make sense?

282
00:21:13,980 --> 00:21:17,730
So basically switching the order you know it's not really going to solve our problem.

283
00:21:18,500 --> 00:21:21,800
You would just basically get a different problem that we had before.

284
00:21:23,630 --> 00:21:25,160
Okay, let's look at one more example.

285
00:21:25,840 --> 00:21:32,210
Here's the example of writing to file x.

286
00:21:35,120 --> 00:21:37,850
So once we have the files allocated, let's say that all succeeded,

287
00:21:37,880 --> 00:21:39,950
and now we're executing the write system call

288
00:21:40,160 --> 00:21:44,300
and the write system call also does a multiple writes operations which we saw on Monday,

289
00:21:44,690 --> 00:21:48,740
for example it will allocate a block, in this case block 45,

290
00:21:49,160 --> 00:21:52,130
so it sets a bit in the free map,

291
00:21:52,130 --> 00:21:55,130
block 45 is the bitmap block,

292
00:21:55,430 --> 00:21:57,980
so it allocates a block in the bitmap,

293
00:21:57,980 --> 00:22:03,190
allocates a bit in the bitmap block to indicate the the block has to be allocated,

294
00:22:03,580 --> 00:22:06,250
that block turns out to be I guess 595.

295
00:22:06,780 --> 00:22:10,800
And then we write you know at the character h you know to 596

296
00:22:10,800 --> 00:22:12,870
and then the character i you know we update the inode.

297
00:22:13,990 --> 00:22:15,940
Right, now we can ask ourselves the same question,

298
00:22:15,940 --> 00:22:21,670
like what will happen if we crash,

299
00:22:21,760 --> 00:22:24,940
so for example let's say we allocate crashed right here,

300
00:22:25,000 --> 00:22:32,850
between you know writing the bitmap block, before we allocate before we actually write a inode,

301
00:22:33,700 --> 00:22:34,780
so crash here.

302
00:22:39,980 --> 00:22:42,350
And so we reboot, we come back up

303
00:22:42,380 --> 00:22:47,600
and this is in a particular state and you know what, what is the risk.

304
00:22:50,520 --> 00:22:53,430
We use it data block, but we lose it.

305
00:22:53,790 --> 00:22:54,930
Yeah, we lose it again, right,

306
00:22:54,930 --> 00:22:57,930
because the block is allocated but doesn't show up in any file,

307
00:22:58,950 --> 00:23:03,180
because it hasn't been written into any inode, so we lose a data block.

308
00:23:08,680 --> 00:23:12,100
You might think okay, well maybe you know just because we wrote them in the wrong order,

309
00:23:12,100 --> 00:23:17,260
what we should have done is a what we should have done is at first write in the inode,

310
00:23:17,650 --> 00:23:26,870
so first write 33 with the, you know with 595 as in the ether is an indirect block a direct block.

311
00:23:27,520 --> 00:23:32,680
And then you know actually we will mark the inode, a block is allocated,

312
00:23:32,680 --> 00:23:35,350
so then we'll write you know 45.

313
00:23:37,000 --> 00:23:40,990
If we change the order, because we want to avoid these lost data block, we change order in this way.

314
00:23:42,530 --> 00:23:46,100
And now let's consider the case if there's a failure right here.

315
00:23:50,370 --> 00:23:51,330
What is the risk.

316
00:23:56,960 --> 00:24:03,800
The size of the file is not compatible with actually how many data blocks are allocated.

317
00:24:04,710 --> 00:24:10,470
That might be, although I think it's the write of 33 actually update both the size and you know the the block number.

318
00:24:11,970 --> 00:24:12,630
Oh.

319
00:24:13,450 --> 00:24:15,340
So that might be might work out OK.

320
00:24:16,780 --> 00:24:19,180
If there were two separate writes, that would be a problem,

321
00:24:20,950 --> 00:24:22,270
but there's some bigger problem here.

322
00:24:27,400 --> 00:24:32,320
Is that the, so the file has the,

323
00:24:33,820 --> 00:24:40,810
so things that it has the data block, but the data block is marked as unallocated

324
00:24:40,900 --> 00:24:45,100
and other files can also use it.

325
00:24:45,220 --> 00:24:47,740
Yeah, that's the real big problem here is that,

326
00:24:47,740 --> 00:24:53,950
you know the the inode things 595, block 595 belonged belonged to that file,

327
00:24:54,130 --> 00:24:58,050
but actually on disk it's still marked as unallocated

328
00:24:58,110 --> 00:25:01,080
and so when later another file was created,

329
00:25:01,110 --> 00:25:04,500
you know that block actually might be used for that other file.

330
00:25:05,140 --> 00:25:09,520
And so now certainly one file things, it owns 595,

331
00:25:09,520 --> 00:25:16,990
but actually other file does, in fact both files will have 595 in there block numbers for their inode

332
00:25:17,350 --> 00:25:23,710
and basically you know if one user owns that file, the other user in the other file,

333
00:25:23,710 --> 00:25:26,020
the connection read right to each other's data, right,

334
00:25:26,020 --> 00:25:27,910
that's clearly not what we want.

335
00:25:28,390 --> 00:25:30,310
You know the file system should guarantee

336
00:25:30,490 --> 00:25:35,350
that every block only belongs in one file and no other file or is free.

337
00:25:37,630 --> 00:25:38,200
Okay.

338
00:25:38,860 --> 00:25:40,990
So this could lead to security problems,

339
00:25:41,020 --> 00:25:48,070
basically block is shared among multiple files.

340
00:25:49,640 --> 00:25:50,990
And that's definitely wrong.

341
00:25:55,480 --> 00:25:58,600
Does it make sense, in terms of the problems that can appear.

342
00:25:59,300 --> 00:26:03,950
And again, you know the real issue here is, not to watch the ordering of the writes,

343
00:26:04,190 --> 00:26:07,340
but the real underlying problem here is that we're just doing multiple writes

344
00:26:07,340 --> 00:26:12,590
and it basically have to show up on disk as an atomic operation.

345
00:26:18,920 --> 00:26:26,760
Okay, so the solution that we're gonna explore in this lecture is logging.

346
00:26:28,380 --> 00:26:34,080
And as I said before, this is a common solution used in file systems

347
00:26:34,080 --> 00:26:37,590
and originating actually out of the database literature,

348
00:26:37,740 --> 00:26:39,810
and it actually has a couple good properties,

349
00:26:39,870 --> 00:26:44,400
one it's going to make basically system calls or file system calls atomic.

350
00:26:47,520 --> 00:26:52,950
With that, I mean, so if a create file or you can call create you call write,

351
00:26:53,070 --> 00:26:58,200
basically all the effects of that system call use all appeared altogether or none of them,

352
00:26:58,470 --> 00:27:05,010
so that avoids this problem of only some subset of the writes actually showing up on disk.

353
00:27:06,800 --> 00:27:10,850
Second good property, it has, it allows for fast recovery.

354
00:27:12,870 --> 00:27:18,220
So after reboot, turns out we don't actually have to do a lot of work to repair the file system,

355
00:27:18,310 --> 00:27:19,870
actually a very minimal amount of work.

356
00:27:20,730 --> 00:27:24,840
And this is in contrast to some other solution and I'm not talking about,

357
00:27:24,840 --> 00:27:27,510
which is basically you go and inspect the file system,

358
00:27:27,720 --> 00:27:32,700
maybe you read all the blocks of the file system or read all the inode blocks, read all the bitmap blocks

359
00:27:33,000 --> 00:27:37,320
and so check out whether the file system is still in the correct shape and maybe repair things.

360
00:27:38,260 --> 00:27:42,130
Logging has this nice property that actually the recovery is fast.

361
00:27:43,020 --> 00:27:47,130
And finally, it is in principle, it can be actually very high performance,

362
00:27:47,610 --> 00:27:52,890
although the one, you know what we're going to be looking in the context of xv6 is not high performance,

363
00:27:53,070 --> 00:27:55,140
so we're going to look at that next week,

364
00:27:55,170 --> 00:28:01,330
we'll see actually how to build a logging system that has atomic file system calls faster recovery in high performance,

365
00:28:01,330 --> 00:28:03,190
today we're going to be just focusing on the first two.

366
00:28:05,560 --> 00:28:06,280
Okay.

367
00:28:06,780 --> 00:28:10,590
The basic idea of logging is actually straightforward,

368
00:28:11,330 --> 00:28:15,980
and so basically what you do is you divide this into two pieces.

369
00:28:16,590 --> 00:28:19,350
One is the log, one is the file system.

370
00:28:20,600 --> 00:28:22,760
And file system might be much bigger than log.

371
00:28:23,580 --> 00:28:28,050
And when you need to update the file system,

372
00:28:28,050 --> 00:28:32,820
so update, let's say a block 33 or update the bitmap block,

373
00:28:33,360 --> 00:28:36,210
we're actually not going to update the file system blocks,

374
00:28:36,210 --> 00:28:38,940
so we're not going to update bitmap block directly,

375
00:28:38,940 --> 00:28:42,240
instead the only thing we're gonna do on the right is,

376
00:28:42,540 --> 00:28:49,290
so here's our memory, we have a block in memory, is say the bitmap block, it's 45

377
00:28:49,650 --> 00:28:52,830
and instead of writing it to 45, where we normally would have done,

378
00:28:52,950 --> 00:28:55,440
what we're gonna do is actually going to write into the log,

379
00:28:55,740 --> 00:28:59,730
we're going to stick it here and remember that definitely should go to 45,

380
00:29:01,160 --> 00:29:02,060
we will put it there.

381
00:29:02,760 --> 00:29:04,230
And we do that with all the other writes too,

382
00:29:04,260 --> 00:29:08,460
so for example we'll put inode block there,

383
00:29:08,610 --> 00:29:12,150
you know like maybe 33 I think, if I remember correctly

384
00:29:12,450 --> 00:29:13,710
and we'll stick it in there

385
00:29:13,770 --> 00:29:16,710
and you know, remember that actually has to go to 33.

386
00:29:18,320 --> 00:29:21,950
So basically what we do any right is first log.

387
00:29:24,660 --> 00:29:27,600
And so we don't write directly to the home location of the block,

388
00:29:27,600 --> 00:29:29,970
but we just put it always a log.

389
00:29:30,930 --> 00:29:34,140
Then, at some point when the file system operation is done,

390
00:29:34,470 --> 00:29:39,540
for example as you know these four five writes that we saw in the previous slides are in the log,

391
00:29:39,570 --> 00:29:40,710
we commit the operation.

392
00:29:44,830 --> 00:29:47,140
Basically what it means is somewhere in the log,

393
00:29:47,260 --> 00:29:50,440
we just record a record, you know in a fixed location,

394
00:29:50,440 --> 00:29:55,450
that basically says okay, well you know there are like five logs in the log,

395
00:29:55,660 --> 00:29:59,800
and that is you know the log, set of log the writes.

396
00:30:01,720 --> 00:30:05,920
And then you know when we have all the writes stably on disk,

397
00:30:05,950 --> 00:30:09,310
we're going to actually install them, was called the installation phase.

398
00:30:10,470 --> 00:30:15,630
And really what that means is, we're gonna move you know these logs from the log to their home location,

399
00:30:15,630 --> 00:30:18,690
so we know this one has to go to 45, so we put it at 45,

400
00:30:18,690 --> 00:30:22,260
this one has to go to 33, we put it to 33, etc etc.

401
00:30:23,420 --> 00:30:26,360
And once we're done, you know basically we can clean the log

402
00:30:26,690 --> 00:30:33,240
and cleaning the log, basically you're rewriting, you know basically setting this five to zero.

403
00:30:34,460 --> 00:30:37,370
And that is a basic plan.

404
00:30:38,640 --> 00:30:41,190
And why is this plan good, well let's think about it.

405
00:30:41,820 --> 00:30:46,760
Let's say we crash before here, what would happen.

406
00:30:50,900 --> 00:30:56,060
So let me hold that question, when you actually talk about one thing before asking the question.

407
00:30:57,710 --> 00:31:02,050
Let's say we crash and so we reboot,

408
00:31:02,470 --> 00:31:06,580
and on the reboot, there's basically what the file system does,

409
00:31:07,280 --> 00:31:08,630
it looks at the commit record,

410
00:31:09,900 --> 00:31:11,910
sees what the value of the commit record is,

411
00:31:12,330 --> 00:31:17,260
even zero, you know do nothing in our simple scheme.

412
00:31:18,560 --> 00:31:20,300
And if it's bigger to zero,

413
00:31:20,300 --> 00:31:24,260
we know that there are basically blocks in the log that need to be actually installed.

414
00:31:24,720 --> 00:31:26,940
And we apparently didn't finish the installation,

415
00:31:27,120 --> 00:31:30,540
we crashed you know after the commit, but before cleaning the log,

416
00:31:30,750 --> 00:31:39,550
so basically we re-install, and after we re-install, we clean the log.

417
00:31:43,990 --> 00:31:44,710
Okay?

418
00:31:45,290 --> 00:31:47,540
And this scheme is good,

419
00:31:47,930 --> 00:31:51,740
because it actually ensures that no matter where the crash happens,

420
00:31:51,830 --> 00:31:55,490
we're either install all the blocks of the writes or we install none of them,

421
00:31:55,790 --> 00:32:02,420
but we were never into we will never end up in a situation where we installed some of the writes, but not all of them.

422
00:32:02,950 --> 00:32:06,850
Just to see why this is [true], let's consider a couple cases where things could crash.

423
00:32:07,930 --> 00:32:10,900
So things could crash and between one and two, what will happen,

424
00:32:16,660 --> 00:32:18,550
in what situation do we end up.

425
00:32:23,020 --> 00:32:25,990
Situation in which on recovery, we do nothing

426
00:32:25,990 --> 00:32:30,720
and that's okay because nothing has been written to the file system.

427
00:32:31,590 --> 00:32:32,670
Yeah exactly,

428
00:32:32,670 --> 00:32:36,120
so this is the case where basically we we just do nothing,

429
00:32:36,270 --> 00:32:39,030
you know as if the system could basically never executed,

430
00:32:39,150 --> 00:32:43,590
because if the failure happened slightly earlier, right, before the file system calls started.

431
00:32:44,240 --> 00:32:46,250
And so that's perfectly okay, that's acceptable.

432
00:32:47,040 --> 00:32:55,730
Okay, what happens, if we crash, okay between after committing before being installed.

433
00:32:58,310 --> 00:33:02,270
Then you'll just redo all the installs, so you'll kind of restore the correct state.

434
00:33:02,870 --> 00:33:04,190
Yeah, so exactly,

435
00:33:04,190 --> 00:33:09,110
so at that point correct, we have we know there are all the blocks are in the log

436
00:33:09,140 --> 00:33:11,180
and they'll be all written, because we committed,

437
00:33:11,270 --> 00:33:14,030
so it must be the case that the whole file system operation finished.

438
00:33:14,630 --> 00:33:17,660
So we can basically put them in their location where they should be.

439
00:33:18,760 --> 00:33:23,350
And then we're all in good shape and so in this case now all the file in this case will end up

440
00:33:23,350 --> 00:33:31,400
as if the, it is if the file system call actually completely just before the crash, there's no difference.

441
00:33:32,280 --> 00:33:32,880
Okay.

442
00:33:33,820 --> 00:33:39,310
So what happens if we crash during install or like install during install before re-cleaning,

443
00:33:39,930 --> 00:33:44,190
crash here, in this case, in this case and I will do the first case,

444
00:33:44,550 --> 00:33:50,700
we'll install during installation, or just before install after installing before cleaning.

445
00:33:51,620 --> 00:33:53,690
What, what what, what happened then.

446
00:33:55,420 --> 00:33:56,860
On the.

447
00:33:58,110 --> 00:34:00,660
Oh, sorry, on the next restart,

448
00:34:00,690 --> 00:34:04,950
nothing has really changed, in terms of the recovery process

449
00:34:05,130 --> 00:34:07,380
and so we're just going to redo the log.

450
00:34:07,680 --> 00:34:08,970
We're going to redo the log again

451
00:34:08,970 --> 00:34:13,110
and we're gonna copy basically the content again, you know to the locations,

452
00:34:13,110 --> 00:34:15,390
where maybe in fact we might do it multiple times,

453
00:34:15,970 --> 00:34:16,720
is that okay.

454
00:34:24,410 --> 00:34:27,710
Yes, because those are just writes,

455
00:34:28,490 --> 00:34:35,000
and it's they are to a specific location that we don't change, like it's written in the log,

456
00:34:35,000 --> 00:34:38,060
so we know where we should write every time.

457
00:34:38,670 --> 00:34:40,710
Yeah basically every time we do the same write, correct,

458
00:34:40,710 --> 00:34:43,860
so let's say in block 45, you know there's the value ten,

459
00:34:44,570 --> 00:34:47,570
and we're going to write ten at location 45 every time

460
00:34:48,050 --> 00:34:49,280
and that's exactly what it should be

461
00:34:49,370 --> 00:34:53,090
and repeating that write multiple times doesn't really do any harm, right.

462
00:34:54,160 --> 00:34:56,920
Because we're writing the same value, that actually should be there anyway.

463
00:34:57,720 --> 00:35:01,590
And so it's perfectly fine, for us to do re-installation multiple times.

464
00:35:03,440 --> 00:35:06,590
Of course, we shouldn't serve any other file system calls at this particular point of time,

465
00:35:06,590 --> 00:35:09,080
we should do this before we restart the file system,

466
00:35:09,560 --> 00:35:14,990
but while you know what, during reboot during recovery, you know we can just do this, right.

467
00:35:16,080 --> 00:35:19,260
Another way of saying, that is that installation is basically idempotent,

468
00:35:19,290 --> 00:35:23,580
you can just execute it many many times and will have the same effect yet.

469
00:35:25,780 --> 00:35:28,210
Question about that.

470
00:35:29,720 --> 00:35:32,060
Because the interface is just read and write,

471
00:35:32,060 --> 00:35:36,260
if we had an append, this would not be safe, right.

472
00:35:36,980 --> 00:35:39,080
Yeah yeah, this [],

473
00:35:39,110 --> 00:35:42,710
you can make append safe too, a more fancy logging schemes,

474
00:35:42,710 --> 00:35:45,410
but for these particular logging scheme, we don't have to worry about that.

475
00:35:46,620 --> 00:35:49,800
In fact, in some sense, the append is file system level operation

476
00:35:49,890 --> 00:35:56,590
and at that level we can make it a topic using the logging scheme, that we're, what we have here.

477
00:35:58,280 --> 00:35:59,360
I see, thank you.

478
00:35:59,940 --> 00:36:00,960
I also have a question,

479
00:36:01,560 --> 00:36:05,400
what would happen if the file system crashed while you are committing,

480
00:36:05,400 --> 00:36:10,110
so you want to execute multiple writes and then you only commit like half of them.

481
00:36:11,480 --> 00:36:14,540
Yeah OK, so can you speak up a little bit more, because your volume is low.

482
00:36:14,630 --> 00:36:15,470
Oh, yeah sorry,

483
00:36:15,740 --> 00:36:22,100
so if you wanted to like commit multiple writes at once, like in an atomic way,

484
00:36:22,130 --> 00:36:25,700
but your system crashes in the middle of committing,

485
00:36:25,700 --> 00:36:28,820
so you are only able to commit like half of the writes,

486
00:36:28,970 --> 00:36:30,890
what would happen in that instance.

487
00:36:31,070 --> 00:36:34,160
Okay, so there's a very important point, I'm glad you ask the question.

488
00:36:34,190 --> 00:36:40,320
So first of all, the the you commit, in writing this commit operation here, correct,

489
00:36:40,320 --> 00:36:41,610
this you know step two,

490
00:36:41,940 --> 00:36:47,670
you only execute that commit operation after you've already logged all the writes, that you were planning to execute, right.

491
00:36:48,660 --> 00:36:51,900
So at the point you do to commit, all the writes are in the log.

492
00:36:53,320 --> 00:36:58,380
And so, the commit operation itself is an interesting question, what happens there.

493
00:36:58,620 --> 00:37:02,220
So, the way the way I indicated this on this,

494
00:37:02,220 --> 00:37:06,860
like commit operation writes a single block, like a single sector on the disk.

495
00:37:07,360 --> 00:37:16,310
And the standard assumption that file systems make is that a single block write or single sector write is an atomic operation.

496
00:37:17,060 --> 00:37:22,010
Meaning that if you write it, the whole sector will be written, or none of the sector will be written.

497
00:37:22,010 --> 00:37:23,900
So the sector will never be written partially.

498
00:37:24,940 --> 00:37:28,690
And so there's always you know clearly you valid data in that particular sector

499
00:37:28,990 --> 00:37:33,220
and so basically this operation that commit operation writing the log header,

500
00:37:33,580 --> 00:37:37,120
is writing the commit record is the real commit operation,

501
00:37:37,420 --> 00:37:42,010
if that succeeds, and there's basically say of five in the commit header,

502
00:37:42,160 --> 00:37:47,380
you know we know that there are five blocks in the log and we have to reinstall those five blocks.

503
00:37:48,600 --> 00:37:53,550
If the commit header didn't make it to disk, then the value will still be zero

504
00:37:53,940 --> 00:37:56,250
and we'll just treat it as if that transaction never happened.

505
00:37:59,010 --> 00:37:59,670
Thank you.

506
00:38:00,300 --> 00:38:05,610
And the key rule that you're sort of hinting at, that has to be true,

507
00:38:05,700 --> 00:38:15,750
is something what's called the write-ahead rule, which means that a logging system cannot install writes, until all the writes into, are into log.

508
00:38:20,000 --> 00:38:22,430
Any more questions about this sort of basic plan.

509
00:38:28,770 --> 00:38:29,430
Okay.

510
00:38:36,530 --> 00:38:37,040
Let's see.

511
00:38:42,300 --> 00:38:47,910
So what I want to there are many many different versions of logging schemes

512
00:38:47,910 --> 00:38:50,340
and I sketched out here a very simple one,

513
00:38:50,640 --> 00:38:52,470
you know it's perfectly fine,

514
00:38:52,470 --> 00:38:56,130
you know their schemes where basically the cleaning of the log is postponed,

515
00:38:56,430 --> 00:38:58,680
installation is postponed until later,

516
00:38:58,860 --> 00:39:02,790
but I'm going to run sort of this very simple scheme,

517
00:39:03,000 --> 00:39:07,050
and then next week we'll see more sophisticated logging protocols.

518
00:39:07,480 --> 00:39:09,850
But all those logging protocols, follow this write-ahead rule,

519
00:39:09,850 --> 00:39:16,150
that before you're ready to commit record, you have to make sure that all the writes are in the log.

520
00:39:18,950 --> 00:39:20,570
But then there's a lot of within that,

521
00:39:20,570 --> 00:39:26,330
still there's a ton of flexibility in designing a particular logging protocols typically called.

522
00:39:27,460 --> 00:39:32,740
Okay, I'm gonna look a little bit, how this then is manifest itself in xv6,

523
00:39:32,740 --> 00:39:35,290
you know as a case study and to make things really concrete.

524
00:39:40,000 --> 00:39:45,400
Okay, so in xv6, there's sort of, you're going to look at two sort of piece of estate you will,

525
00:39:45,550 --> 00:39:47,170
the stuff that is actually on disk.

526
00:39:48,080 --> 00:39:57,230
And that's you know things that are in memory, [] [] in-memory contents will disappear,

527
00:39:57,230 --> 00:40:02,450
on the way we should think about it is that in-memory content will disappear on a crash or power failure.

528
00:40:04,660 --> 00:40:12,010
And the structure of the xv6 log as always pretty simple.

529
00:40:12,600 --> 00:40:17,430
There's actually, we have one block in the beginning, the header block,

530
00:40:18,020 --> 00:40:19,670
and that's basically our commit record,

531
00:40:19,670 --> 00:40:24,390
you know it contains the number n, which is like the number of blocks in the log

532
00:40:24,600 --> 00:40:33,230
and then for each block, the block number, the home location of that block, blah blah blah,

533
00:40:33,230 --> 00:40:34,310
are going to be any of those.

534
00:40:37,960 --> 00:40:43,180
And so, then in the log itself are basically is the data, that it belongs to that,

535
00:40:43,180 --> 00:40:49,690
so here is the data of bn0, here's the data of bn1, etc,

536
00:40:50,210 --> 00:40:52,490
to b n minus one.

537
00:40:54,460 --> 00:40:55,930
So that's what's in the log.

538
00:40:56,340 --> 00:40:59,700
And there's the only thing, that's sort of in the log, there's nothing more to it.

539
00:41:00,600 --> 00:41:03,870
Then in memory where, while the file systems running,

540
00:41:03,870 --> 00:41:07,620
there's an in copy version in-memory version of the header.

541
00:41:09,390 --> 00:41:18,490
And it basically has n and it has array of block numbers, etc.

542
00:41:19,000 --> 00:41:26,140
And then you know these block numbers refer to block, that are sitting in the data,

543
00:41:26,170 --> 00:41:31,180
that actually corresponds to the block numbers that are sort of sitting in this in-memory data structure,

544
00:41:31,240 --> 00:41:33,160
they live in the block cache.

545
00:41:33,820 --> 00:41:36,160
Which you know, but now you're well familiar with.

546
00:41:36,760 --> 00:41:41,740
And so, maybe this is like block ten, is the first block in the log,

547
00:41:41,740 --> 00:41:48,130
or maybe let me take a more concrete example, from that lines up with our previous things, maybe this is like 45.

548
00:41:49,440 --> 00:41:52,110
And basically you know somewhere in the in cache,

549
00:41:52,290 --> 00:41:56,610
the block cache there's of course whatever block for 45, here is data.

550
00:41:56,880 --> 00:41:57,510
Okay.

551
00:41:58,200 --> 00:41:59,430
That's sort of the structures,

552
00:41:59,580 --> 00:42:08,620
that the [on disk] in-memory file system has and on disk file system has,

553
00:42:08,620 --> 00:42:10,240
on-disk file system just has the log,

554
00:42:10,390 --> 00:42:13,030
the in-memory has these data structures to orchestrate.

555
00:42:13,360 --> 00:42:15,850
These multi write operations that were going to be doing.

556
00:42:17,080 --> 00:42:17,740
Okay.

557
00:42:20,240 --> 00:42:24,620
So, to make this a little more concrete, let's look at some code.

558
00:42:25,740 --> 00:42:30,030
Then that will help us understand how everything works.

559
00:42:33,580 --> 00:42:37,640
So let me pull up some code.

560
00:42:38,350 --> 00:42:42,960
Okay, let me put this next to it, we keep that picture.

561
00:42:42,960 --> 00:42:47,490
So that we can look at if we want to or I can point to it.

562
00:42:48,490 --> 00:42:49,600
Can everybody see my code.

563
00:42:54,410 --> 00:42:57,920
Somebody have to confirmed they seen emacs window.

564
00:42:58,130 --> 00:42:59,450
{Yeah,we can see it.

565
00:42:59,450 --> 00:42:59,660
Good.

566
00:43:00,380 --> 00:43:01,280
Is it big enough.

567
00:43:04,080 --> 00:43:05,190
I think it's good.

568
00:43:05,520 --> 00:43:05,790
Okay.

569
00:43:05,790 --> 00:43:06,570
That looks good.

570
00:43:07,140 --> 00:43:07,800
Thank you.

571
00:43:08,440 --> 00:43:10,870
Okay, so let's start with,

572
00:43:11,230 --> 00:43:13,150
you know I I talked about transactions,

573
00:43:13,150 --> 00:43:19,030
where you you know the fact that you know we should not commit until,

574
00:43:19,060 --> 00:43:21,610
we should not write to commit a writer, until all the writes have done.

575
00:43:22,420 --> 00:43:25,720
And so this means that you should file system operations,

576
00:43:25,720 --> 00:43:30,730
must indicates what the beginning of transaction is and particularly at the end of the transaction is.

577
00:43:31,340 --> 00:43:35,510
And the way that happens in xv6, that every file system call,

578
00:43:36,640 --> 00:43:40,960
here's open corresponds to create basically starts with begin_op

579
00:43:41,020 --> 00:43:44,050
and basically indicates like, okay I want to start a transaction

580
00:43:44,260 --> 00:43:51,400
and I want all the block writes that I've been doing between begin_op and end_op which is basically the end of the transaction to be atomic,

581
00:43:51,490 --> 00:43:54,400
meaning they should be all applied to, or none of them should applied.

582
00:43:54,940 --> 00:44:01,060
Okay, so every file system call in xv6 has that structure,

583
00:44:01,120 --> 00:44:05,830
basically has begin_op, then the code and implements the file system call and then end_op.

584
00:44:07,080 --> 00:44:09,690
And that end_op is basically where the commit operation happens.

585
00:44:10,430 --> 00:44:16,730
So basically between begin_op and end_op, on disk or in-memory data structure should be updated,

586
00:44:16,730 --> 00:44:21,020
whenever the in-memory log may be updated the block cache might be updated,

587
00:44:21,020 --> 00:44:24,020
but nothing really happens until end_op

588
00:44:24,230 --> 00:44:27,890
and then end of time, we're basically going to put things into the log

589
00:44:28,130 --> 00:44:31,670
and then we are done with putting everything in the log,

590
00:44:31,760 --> 00:44:34,700
will actually you know write to commit record or log header.

591
00:44:36,030 --> 00:44:36,630
Okay.

592
00:44:37,180 --> 00:44:37,570
So let's.

593
00:44:39,280 --> 00:44:42,340
So what is interesting, of course what happens is every write correctly,

594
00:44:42,340 --> 00:44:48,610
whenever one of these file system calls does a disk write, you know something must happen,

595
00:44:48,640 --> 00:44:54,130
so if we go back for example to fs.c, you look at ialloc,

596
00:44:54,580 --> 00:44:59,530
ialloc basically what it calls it doesn't call bwrite directly,

597
00:44:59,830 --> 00:45:03,160
but it actually calls a log_write.

598
00:45:04,250 --> 00:45:06,320
And so we're going to see what log_write does,

599
00:45:06,590 --> 00:45:10,430
log_write is basically a function implemented by logging system,

600
00:45:10,610 --> 00:45:16,640
and every write basically a file system called us between begin_op and end_op, always goes through log_write.

601
00:45:23,350 --> 00:45:29,320
So here's log_write and log_write actually reasonable straightforward.

602
00:45:29,900 --> 00:45:34,700
Yeah, you know we've written the block, in the block cache,

603
00:45:34,730 --> 00:45:38,480
so somewhere basically 45, maybe this is like the write to 45,

604
00:45:38,720 --> 00:45:42,590
we've updated you know 45 in the block cache,

605
00:45:42,740 --> 00:45:45,890
now we basically record in the in-memory data structures,

606
00:45:45,890 --> 00:45:50,720
that at some point later, at commit point we were able to write this log into log.

607
00:45:51,430 --> 00:45:54,040
And so you know basically you know the code is,

608
00:45:54,280 --> 00:45:54,730
oops,

609
00:45:55,480 --> 00:45:57,040
the code is reasonably straightforward,

610
00:45:57,340 --> 00:46:03,310
it acquired a lock on the header and basically updates the header,

611
00:46:04,100 --> 00:46:09,890
in particular, what does goes through you know the updates,

612
00:46:09,890 --> 00:46:15,410
and when actually the first thing it does it actually sees, if there's already a copy of 45 in the,

613
00:46:16,420 --> 00:46:20,410
if 45 is already recorded as being having to write to written to,

614
00:46:20,740 --> 00:46:24,040
and if that's the case nothing has to be done, because 45 will be written to.

615
00:46:24,750 --> 00:46:28,020
And so we're done, sometimes called log absorption.

616
00:46:30,980 --> 00:46:35,240
If you know block 45 is not in the array yet

617
00:46:35,240 --> 00:46:38,990
or not in the the list of blocks or the array of blocks,

618
00:46:38,990 --> 00:46:40,640
that needs to be written to disk,

619
00:46:40,730 --> 00:46:44,900
then basically you know the only thing, this particular piece of code does is

620
00:46:44,900 --> 00:46:48,710
basically bump up and stick that block number that needs to be written

621
00:46:48,710 --> 00:46:51,710
into the next entry or into that entry.

622
00:46:53,210 --> 00:46:55,730
Then the only other thing it does and I'll talk about this later,

623
00:46:55,970 --> 00:47:00,020
it will [ping] the block in the buffer cache

624
00:47:00,260 --> 00:47:03,620
and let me postpone why a little while,

625
00:47:03,650 --> 00:47:05,180
but I will come back to that later.

626
00:47:06,560 --> 00:47:08,360
And that's actually all that log_write there doing,

627
00:47:08,480 --> 00:47:14,120
so every file system call that needs to update a block, updates to block in the block cache

628
00:47:14,150 --> 00:47:19,130
and it basically it appends it to this in-memory data structure,

629
00:47:19,130 --> 00:47:22,820
unless you know it's already there, in which case, you know just absorbs it.

630
00:47:24,630 --> 00:47:25,380
Does that make sense?

631
00:47:29,190 --> 00:47:33,900
So does it mean that bwrite shouldn't be used by itself at all.

632
00:47:34,200 --> 00:47:35,160
Sorry, say again.

633
00:47:35,760 --> 00:47:39,780
Bwrite shouldn't be used by itself, only as.

634
00:47:39,930 --> 00:47:41,640
Yes that's correct,

635
00:47:41,820 --> 00:47:43,950
basically all you, one way to think about is

636
00:47:43,950 --> 00:47:47,640
that every bwrite in the file system is replaced by log_write.

637
00:47:53,820 --> 00:47:58,410
Okay, so now let's see what actually happens at end_op,

638
00:47:58,410 --> 00:48:01,170
because that's where the exciting part happens.

639
00:48:02,160 --> 00:48:09,240
And there's a couple of cases that I just wanna avoid talking about, a little bit later,

640
00:48:09,270 --> 00:48:13,980
because they even this simple logging system actually has some subtle complexities

641
00:48:13,980 --> 00:48:17,580
and most of the beginning of this code deals with these subtle complexities.

642
00:48:18,090 --> 00:48:20,550
But if you want to get a normal case,

643
00:48:20,550 --> 00:48:22,350
you know there's or there's the simple case

644
00:48:22,350 --> 00:48:25,890
where no other term file system operations are in progress,

645
00:48:26,160 --> 00:48:31,260
we are executing create file and basically we're getting to the point where we want to commit.

646
00:48:31,940 --> 00:48:36,050
And so the code is pretty straightforward and calls commit,

647
00:48:36,890 --> 00:48:38,090
so let's look at the commit.

648
00:48:41,680 --> 00:48:47,340
So here's commit, [] commit does to basically steps basically writes the log,

649
00:48:48,140 --> 00:48:52,500
that's basically writing all these, all these block numbers,

650
00:48:52,500 --> 00:48:55,740
that are sitting you know in the in-memory header,

651
00:48:55,920 --> 00:49:00,480
writes them basically all to the header on disk, including you know there's number n.

652
00:49:02,360 --> 00:49:03,920
Right, and so let's see,

653
00:49:04,340 --> 00:49:06,890
that is that's what write_head does, sorry,

654
00:49:07,440 --> 00:49:15,780
write_log basically writes you know the blocks from the buffer cache into their respective into the log itself.

655
00:49:16,280 --> 00:49:18,830
So let's see write_log, right above here.

656
00:49:19,640 --> 00:49:21,440
You see what it does,

657
00:49:21,470 --> 00:49:24,770
it goes through you know this array one at a time

658
00:49:25,100 --> 00:49:30,810
and basically writes down to the log position in the log.

659
00:49:31,500 --> 00:49:36,050
Okay so read you know the log block, then sticks it in there,

660
00:49:36,290 --> 00:49:39,560
by copying it, and then writing it actually out to the disk.

661
00:49:40,880 --> 00:49:43,970
So this basically ensures that log 45 land up here,

662
00:49:43,970 --> 00:49:47,510
you know say this is [32] that will end up there etc etc.

663
00:49:49,050 --> 00:49:52,020
Then, at the end, so at this point we have not committed yet, correct,

664
00:49:52,020 --> 00:49:55,080
the only thing we've done is basically putting blocks into the log,

665
00:49:55,470 --> 00:49:57,930
and if we were crash at this particular point in time,

666
00:49:57,930 --> 00:50:01,890
before calling write_head before write_head succeeded,

667
00:50:02,010 --> 00:50:05,520
and basically as if the transaction didn't execute at all.

668
00:50:06,810 --> 00:50:08,610
So let's look at the write_head.

669
00:50:09,430 --> 00:50:11,560
So that write_head is what I called earlier,

670
00:50:11,560 --> 00:50:14,970
basically the commit point, and the commit point,

671
00:50:14,970 --> 00:50:21,590
basically you know basically it's straightforward and reach the head of block from disk,

672
00:50:21,590 --> 00:50:23,420
which is probably sitting in the buffer cache,

673
00:50:23,780 --> 00:50:27,770
it you know puts the copies the end,

674
00:50:27,830 --> 00:50:33,920
you know this end into that block, puts all the block numbers into that array into that block

675
00:50:34,040 --> 00:50:36,410
and it basically writes that that particular block.

676
00:50:37,210 --> 00:50:40,870
This is the this bwrite, what is that is that the commit point.

677
00:50:45,420 --> 00:50:47,820
If a crash happens before this bwrite, what happens then.

678
00:50:57,180 --> 00:50:57,780
Anybody?

679
00:50:58,700 --> 00:51:07,790
If the crash happens before bwrite, isn't the only modification that we've made to the in memory hb data structure,

680
00:51:08,030 --> 00:51:10,220
so it's not, it's going to be fine.

681
00:51:10,610 --> 00:51:11,630
Yeah, it's gonna be fine,

682
00:51:11,630 --> 00:51:15,830
because basically we may have written [db one zero db n] whatever to log,

683
00:51:15,830 --> 00:51:18,290
but we have not succeeded in writing the log header.

684
00:51:18,980 --> 00:51:21,770
And so will do not, on recovery nothing will happen.

685
00:51:22,950 --> 00:51:26,490
And what happens if there's a crash right after to bwrite, so like crash here.

686
00:51:32,220 --> 00:51:36,330
And it's no longer zero, so the log headers correctly read and it's recovered.

687
00:51:36,570 --> 00:51:38,280
Yeah, will be recovered, correct.

688
00:51:38,280 --> 00:51:41,070
Well, at some point hopefully during recovery as we expect that,

689
00:51:41,070 --> 00:51:46,830
we expect the recovery will actually read the log header see that there is a five in there for example,

690
00:51:47,070 --> 00:51:49,680
and then copy the first five logs through their home location.

691
00:51:50,530 --> 00:51:53,320
So this is really this, this, this one line,

692
00:51:53,860 --> 00:51:56,770
there's one disk write, there's one sector write is really the commit point.

693
00:51:58,440 --> 00:51:58,860
Right.

694
00:52:03,380 --> 00:52:08,300
Before the commitment point, the transaction, is the transaction didn't happen after the commit point,

695
00:52:08,300 --> 00:52:12,760
the transaction will definitely be finished, assuming your recovery is correct.

696
00:52:18,220 --> 00:52:22,720
Okay, so let's you know go back to commit.

697
00:52:25,020 --> 00:52:30,510
So commit, after its committed it actually installs the transactions and that's pretty straightforward,

698
00:52:30,510 --> 00:52:34,440
basically it takes the blocks looks at the header where the blocks belongs

699
00:52:34,440 --> 00:52:36,390
and then basically writes into that particular location.

700
00:52:37,660 --> 00:52:40,930
Yeah, so we can actually look at install_trans,

701
00:52:41,930 --> 00:52:43,910
you see that actually that's what it does.

702
00:52:45,110 --> 00:52:50,750
It has a copy of the log header and use or reads log header,

703
00:52:50,750 --> 00:52:53,720
it reach the destination block the home location,

704
00:52:54,290 --> 00:52:59,030
copies the data from the log block into the destination,

705
00:52:59,360 --> 00:53:01,280
and then writes the buffer to the destination.

706
00:53:03,170 --> 00:53:03,830
Okay.

707
00:53:04,730 --> 00:53:06,440
So basically effectively what this does is

708
00:53:06,440 --> 00:53:08,810
basically you know you go back to this previous slide here

709
00:53:08,810 --> 00:53:14,780
and copies, you know it just does these copies from the log into the home location or actually in the file system.

710
00:53:17,160 --> 00:53:20,340
And of course you know we might get a failure somewhere in you know this code

711
00:53:20,340 --> 00:53:21,630
or while we're doing this,

712
00:53:21,930 --> 00:53:25,980
but you know it should be OK, because hopefully in recovery will start over from the beginning.

713
00:53:29,150 --> 00:53:32,540
So let's look at we, so that was installed.

714
00:53:33,160 --> 00:53:42,980
So once install is done, then basically it sets you know the in-memory header and back to zero

715
00:53:43,100 --> 00:53:44,630
and then writes that lock header.

716
00:53:45,500 --> 00:53:51,650
And effectively that causes to cleans the log,

717
00:53:51,650 --> 00:53:53,270
because basically there's now zero in it.

718
00:53:53,900 --> 00:53:54,500
Question.

719
00:53:56,130 --> 00:54:02,470
So, you have the function you're in just before,

720
00:54:02,740 --> 00:54:06,970
like whereas, does the from to, or to, from getting,

721
00:54:07,150 --> 00:54:13,790
so that puts the, the block that you're going to like update log

722
00:54:13,790 --> 00:54:17,030
that you're going to update into the buffer cache,

723
00:54:17,840 --> 00:54:21,950
could you make it faster by not putting into the buffer cache

724
00:54:21,950 --> 00:54:25,770
and just directly writing it to the device instead.

725
00:54:26,680 --> 00:54:30,490
Let me, which function we're talking about.

726
00:54:31,770 --> 00:54:38,790
I forget its name, it's the one, where you a copy, yeah, everything into the log.

727
00:54:39,030 --> 00:54:45,680
Okay, install install_trnas. I think so.

728
00:54:47,160 --> 00:54:48,840
Oh, maybe it was this one.

729
00:54:50,220 --> 00:54:53,760
So this I thinking probably of write_head, but it's the same thing.

730
00:54:54,180 --> 00:54:55,770
Okay good.

731
00:54:57,630 --> 00:55:01,490
The only reason, the only reason to this,

732
00:55:01,490 --> 00:55:03,320
you know basically our interface is not particularly good,

733
00:55:03,320 --> 00:55:07,370
you could just read straight, you know you're wondering why you are doing the read.

734
00:55:07,980 --> 00:55:13,110
There's no reason to do the read, because we're going to write anyway, is that the question.

735
00:55:14,980 --> 00:55:18,760
Yeah that and you're also a doing the memmove.

736
00:55:19,450 --> 00:55:20,560
And [] the memmove, yeah,

737
00:55:20,620 --> 00:55:23,380
so these are actually a sequence of code can definitely be optimized,

738
00:55:23,470 --> 00:55:26,140
you can save you know one or two disk writes.

739
00:55:26,600 --> 00:55:29,690
Just for simplicity, we don't do any of that.

740
00:55:30,270 --> 00:55:31,200
Okay, thank you.

741
00:55:35,170 --> 00:55:39,650
Okay, so I think we're in over commit,

742
00:55:40,410 --> 00:55:43,980
just like, just go back. and double check.

743
00:55:44,540 --> 00:55:47,210
So we did the write_log, we did the write_head

744
00:55:47,270 --> 00:55:54,030
and basically this the cleaning operation, we erased you know transaction by sending it to zero.

745
00:55:54,150 --> 00:55:54,690
Okay.

746
00:55:55,880 --> 00:56:00,290
So the only thing to further inspect is like how, how does recovery work

747
00:56:00,320 --> 00:56:06,300
and recovery happens when you know when xv6 starts,

748
00:56:06,720 --> 00:56:11,340
so now we had a crash, and the system failed, we reboot it,

749
00:56:11,370 --> 00:56:17,070
and the, one of the first things that xv6,

750
00:56:17,430 --> 00:56:22,650
one of the things that xv6 does during initialization, it actually in the log.

751
00:56:23,390 --> 00:56:27,050
And in the log, basically calls this function recover from log

752
00:56:27,230 --> 00:56:28,790
and so let's see what that does.

753
00:56:30,110 --> 00:56:38,220
And basically recover block you know calls read_head, to basically extract or read the.

754
00:56:39,300 --> 00:56:42,120
Then, let me see if I can scroll down here a little bit.

755
00:56:45,580 --> 00:56:47,290
Basically reads the header from disk,

756
00:56:48,100 --> 00:56:52,560
and sees if n, well doesn't really see if n is zero or not,

757
00:56:52,560 --> 00:56:54,450
but it just calls install_trans

758
00:56:54,600 --> 00:57:00,480
and you know this is exactly the same install_trans we use look for it, for a look at it a while ago

759
00:57:00,720 --> 00:57:02,430
and basically you know look at this n

760
00:57:02,430 --> 00:57:07,080
and installs all the blocks from zero to n out of the log into their home location.

761
00:57:07,850 --> 00:57:14,020
And if it's done, once it succeeds you know then actually it calls clear log as before.

762
00:57:14,820 --> 00:57:20,370
And so that's actually all what the recovery does, recovery is basically always called [dust] installation.

763
00:57:21,010 --> 00:57:23,740
And if we crash during installation here,

764
00:57:24,130 --> 00:57:25,720
no particular problem again, correct,

765
00:57:25,720 --> 00:57:31,660
because we'll crash we'll boot xv6 rebooting will call log in it,

766
00:57:31,840 --> 00:57:37,060
which will call recovery log and it will basically re-install, replay the log is sometimes called,

767
00:57:37,300 --> 00:57:43,750
again and this might have this might end, if we crash every time or you know many many times,

768
00:57:44,020 --> 00:57:47,320
you know we'll reinstall or replace the log many many many times,

769
00:57:47,380 --> 00:57:49,480
they'll tell hopefully at some point it succeeds

770
00:57:49,600 --> 00:57:54,880
and actually you know gets the whole log written gets the whole log installed,

771
00:57:54,910 --> 00:57:57,790
you know to the, to home locations.

772
00:57:59,430 --> 00:58:00,030
Does it make sense?

773
00:58:03,580 --> 00:58:05,410
I had a question about,

774
00:58:05,740 --> 00:58:11,560
so if a process just runs normally, it writes some data to disk,

775
00:58:11,920 --> 00:58:16,870
and then at some point after that before it commits and installs the changes,

776
00:58:17,370 --> 00:58:24,380
there's a failure, from the process, the further process point of view nothing happened,

777
00:58:24,380 --> 00:58:32,430
but something like, I guess the failure happened after the process ended of what I was doing,

778
00:58:33,060 --> 00:58:35,100
so, is there anything bad about that.

779
00:58:36,170 --> 00:58:41,450
Not hundred percent getting it, but a short answer is there's nothing bad,

780
00:58:41,480 --> 00:58:47,240
because the disk won't be updated at all, so just as if you know that file system operation didn't happen.

781
00:58:48,130 --> 00:58:50,960
Alright, I guess.

782
00:58:50,990 --> 00:58:56,420
Process disappears too, but, you know we don't expect the process to survive failures anyway.

783
00:58:58,150 --> 00:59:00,740
Right or I guess,

784
00:59:01,200 --> 00:59:04,050
Okay I I think that answers my question, thank you.

785
00:59:05,720 --> 00:59:07,370
Yeah it's important to remember to

786
00:59:07,370 --> 00:59:13,070
basically the only thing that really survives failures or that's persistence across failures is

787
00:59:13,070 --> 00:59:15,980
the disk or the state on the disk nothing else, right.

788
00:59:19,620 --> 00:59:24,450
Okay, so just to make this all concrete, one little more to let's.

789
00:59:25,160 --> 00:59:29,270
I put a statement in bwrite,

790
00:59:29,270 --> 00:59:33,380
so actually the thing that actually does write to disk, like in the block cache.

791
00:59:33,920 --> 00:59:37,970
And we're going to see what the trace of actual disk writes are.

792
00:59:38,600 --> 00:59:45,210
Because basically on Monday I sort of, I didn't tell the full truth,

793
00:59:45,240 --> 00:59:49,560
because basically I put the print statement in log_write and not in bwrite,

794
00:59:49,650 --> 00:59:53,670
and so now I put it in the bwrite and so we can actually see all the blocks are being written.

795
00:59:54,380 --> 00:59:57,290
So we'll do the same thing as before, you know echo hi x,

796
00:59:57,650 --> 00:59:59,930
and just look at actually the actual disk writes.

797
01:00:01,120 --> 01:00:02,290
And see if that makes sense,

798
01:00:02,350 --> 01:00:07,390
you know so the first thing to note correctly, that this traces way longer than the trace that we looked at last time,

799
01:00:07,390 --> 01:00:10,600
the fact that we looked at a slide a couple slides ago, right.

800
01:00:11,480 --> 01:00:14,120
Because you're looking at, in fact you just demonstrate this,

801
01:00:15,440 --> 01:00:20,210
here was the same echo hi correct.

802
01:00:20,980 --> 01:00:26,220
And when we see there's like only it's five log write operations,

803
01:00:26,400 --> 01:00:32,120
but it turns into many disk operations, right.

804
01:00:32,780 --> 01:00:33,650
So let's look at it.

805
01:00:34,680 --> 01:00:40,110
So what we think bwrite three four and five are and what is bwrite 2.

806
01:00:48,710 --> 01:00:49,370
Anybody?

807
01:00:50,080 --> 01:00:53,620
So writing to the log and then the super block.

808
01:00:54,580 --> 01:00:55,990
Not the super block.

809
01:00:56,110 --> 01:00:57,610
Now let's say that log_head.

810
01:00:57,640 --> 01:01:00,550
Yeah, so just look at, you got it right,

811
01:01:00,550 --> 01:01:02,290
you know just looking at this picture again, correct,

812
01:01:02,680 --> 01:01:07,720
the log structure two, so, that's probably the header block to commit record if you will,

813
01:01:08,110 --> 01:01:12,310
and then freeze the first data block, [] the second data block, finds the third data block.

814
01:01:13,540 --> 01:01:19,790
So going back, you know this is the first write, the second write, the third write,

815
01:01:20,210 --> 01:01:24,290
they're all going into the log and they're written to disk,

816
01:01:24,890 --> 01:01:26,900
in the log log part of the disk,

817
01:01:27,170 --> 01:01:30,470
and then this is the commit record header.

818
01:01:31,060 --> 01:01:32,680
And then presumably what is this face.

819
01:01:41,720 --> 01:01:42,680
What is this part?

820
01:01:43,340 --> 01:01:45,080
Is that the bitmap setting?

821
01:01:45,900 --> 01:01:49,710
No, so what do we think actually stored in this bwrite three.

822
01:01:51,980 --> 01:01:57,440
Here you creating the file of the inode for x,

823
01:01:57,440 --> 01:02:02,900
updating the directory and then also actually making the file itself.

824
01:02:03,360 --> 01:02:05,760
Yeah, and so and we didn't do it here, right,

825
01:02:05,760 --> 01:02:08,310
because in these bwrites that didn't happen.

826
01:02:08,900 --> 01:02:09,800
Now we're doing it.

827
01:02:11,090 --> 01:02:13,700
So what, what what phases of the transaction.

828
01:02:16,200 --> 01:02:17,940
Installing the changes.

829
01:02:17,970 --> 01:02:19,440
Yeah, installing the changes, correct,

830
01:02:19,440 --> 01:02:24,260
what we did here is, we log the write,

831
01:02:24,650 --> 01:02:28,370
then we committed the file system operation to create operation

832
01:02:28,370 --> 01:02:29,540
and now we're installing it.

833
01:02:30,430 --> 01:02:32,440
For now we're putting the blocks in their home location.

834
01:02:34,300 --> 01:02:37,370
And now, and what does this bwrite two [then].

835
01:02:44,500 --> 01:02:45,760
Clearing the log.

836
01:02:45,760 --> 01:02:47,140
Yeah, it's clear log exactly.

837
01:02:47,760 --> 01:02:53,540
So basically this, this this, the system called was writing 33 46 32

838
01:02:53,840 --> 01:03:00,510
and to actually do that using the logging system that basically turns into this set of disk write,

839
01:03:01,620 --> 01:03:07,860
right, where the first part is installing the log, in the first part is actually logging the writes, in the second part is installing the log.

840
01:03:09,860 --> 01:03:11,810
And these are the two writes due to commit records.

841
01:03:15,040 --> 01:03:15,700
So it makes sense?

842
01:03:15,790 --> 01:03:21,160
Is it possible to infer where begin_op and end_op would run from this trace.

843
01:03:21,760 --> 01:03:24,640
Well, so we're sort of no, correct,

844
01:03:24,640 --> 01:03:27,400
so where did, we don't really know what begin_op start,

845
01:03:27,400 --> 01:03:30,550
but this is any file system calls starts with the begin_op.

846
01:03:31,420 --> 01:03:37,530
And it must be the case that, the commit record, correct is written in end_op,

847
01:03:37,890 --> 01:03:44,050
so we know that this is the end_op of some file system operation.

848
01:03:48,010 --> 01:03:48,910
Does that make sense?

849
01:03:53,270 --> 01:03:58,520
Okay, so that's basically xv6 logging logging in action,

850
01:03:58,880 --> 01:04:01,370
and when I talk about a couple complications,

851
01:04:01,700 --> 01:04:09,860
and even this dirt simple naive logging scheme actually has complications.

852
01:04:10,540 --> 01:04:17,440
One thing to immediately note of course is, you know is this a very performance implementation.

853
01:04:18,710 --> 01:04:20,060
Did you by looking at this trace.

854
01:04:26,990 --> 01:04:27,620
No.

855
01:04:28,190 --> 01:04:34,790
Why not, I know this is a basically two simple questions, but it's important to ask.

856
01:04:36,510 --> 01:04:41,230
Like, you're writing the stuff twice right.

857
01:04:41,260 --> 01:04:42,790
Yeah, you're writing your stuff twice,

858
01:04:42,790 --> 01:04:44,920
you write a file f or a big file f,

859
01:04:44,950 --> 01:04:46,660
I'm going to write that big file f twice.

860
01:04:48,000 --> 01:04:51,030
And so, certainly not particularly high performance,

861
01:04:51,030 --> 01:04:56,940
where I mean basically re-cutting the performance immediately by a factor of two, just to get crash safety.

862
01:04:57,620 --> 01:05:05,570
And so we'll see on on you when you're reading the ext ext3 paper for Monday

863
01:05:05,660 --> 01:05:12,060
and one thing you should keep in your head, while reading is get how, how do I get around for this factor of two.

864
01:05:15,140 --> 01:05:15,710
Okay?

865
01:05:16,660 --> 01:05:20,500
So, is it the case that you write the h and the i separately.

866
01:05:21,460 --> 01:05:23,260
Yeah, I think so.

867
01:05:23,960 --> 01:05:25,010
Okay, okay.

868
01:05:25,010 --> 01:05:29,420
I'll I'll show you in a second why, what is happening there.

869
01:05:31,760 --> 01:05:39,580
Or maybe well, let me not commit too much to answer, but I will get back to it.

870
01:05:40,210 --> 01:05:44,140
Oh, sorry, am I having the empty line, not the h and i, but yeah.

871
01:05:44,620 --> 01:05:49,480
The new line, new line is a separate right.

872
01:05:49,810 --> 01:05:50,920
Okay, thank you.

873
01:05:51,760 --> 01:05:52,450
You're welcome.

874
01:05:52,960 --> 01:05:59,260
Okay, there's complications and I want to talk a little bit about these complications.

875
01:06:05,970 --> 01:06:08,490
Here's our basic scheme, basic data structures,

876
01:06:08,910 --> 01:06:11,880
and there's three complications I want to talk about.

877
01:06:15,360 --> 01:06:17,760
Maybe I'll call them challenges whatever you wanna call them.

878
01:06:21,490 --> 01:06:23,260
The first is eviction.

879
01:06:29,080 --> 01:06:30,940
And the issue is as follows,

880
01:06:31,000 --> 01:06:32,950
let's say we go back to this picture here,

881
01:06:33,920 --> 01:06:35,840
and you know bcache is full,

882
01:06:37,950 --> 01:06:42,000
and, and sort of transaction in progress,

883
01:06:42,090 --> 01:06:45,000
let's see, we've just updated 45,

884
01:06:45,570 --> 01:06:48,750
it's now gone block 45, so it's going to write the next block,

885
01:06:49,530 --> 01:06:50,790
and the cache is full.

886
01:06:51,700 --> 01:06:56,480
And, the and,

887
01:06:57,910 --> 01:07:01,150
let's say you know we don't we don't have a solution for this yet,

888
01:07:01,360 --> 01:07:07,060
but the cache decides, it wants to evict 45 correct,

889
01:07:07,300 --> 01:07:12,040
and if it wants to evict 45, but will mean that will mean we have to write it through its home location.

890
01:07:13,720 --> 01:07:16,600
How bad would it be to write the block here,

891
01:07:17,600 --> 01:07:23,250
you know evict 45, and write 45 to home location.

892
01:07:28,600 --> 01:07:29,800
Is that good or bad.

893
01:07:44,290 --> 01:07:46,270
Would any rule be broken, if we did that.

894
01:07:47,410 --> 01:07:59,170
I guess, that as if a crash happens before the other writes in the same transaction occurs, then basically atomicity it is broken.

895
01:08:02,980 --> 01:08:06,280
That is basically violates this write-ahead rule that I talked about,

896
01:08:07,610 --> 01:08:12,380
you have to write all the blocks to the log, before you write any block to each home location.

897
01:08:25,780 --> 01:08:27,040
So it has to be the case right,

898
01:08:27,040 --> 01:08:31,660
the cache does not evict any block that sits in the log.

899
01:08:32,640 --> 01:08:33,420
Does that make sense?

900
01:08:34,750 --> 01:08:43,490
So the solution is don't evict blocks, those are in the log.

901
01:08:49,330 --> 01:08:52,990
And this is exactly what you were [showing] a little bit earlier

902
01:08:52,990 --> 01:08:56,830
and said I didn't want to talk about, so you go to log_write.

903
01:08:57,760 --> 01:08:59,830
Again just to see for a second there,

904
01:09:00,480 --> 01:09:03,720
log_write here log_write again

905
01:09:04,140 --> 01:09:09,000
and here we see this call to bpin, and what do you think bpin does,

906
01:09:11,240 --> 01:09:12,710
name sort of indicates it.

907
01:09:16,590 --> 01:09:21,970
It [bends] the block in the, in the cache.

908
01:09:22,000 --> 01:09:27,340
Yeah, how does it do it, since you've been looking at this where your current lab extensively.

909
01:09:28,890 --> 01:09:29,700
What do you think it does.

910
01:09:30,840 --> 01:09:33,180
So we can look at the implementation with bpin,

911
01:09:33,180 --> 01:09:34,710
but we can also guess what it does.

912
01:09:40,000 --> 01:09:44,740
Doesn't it essentially just make it, so that it doesn't get evicted by increasing the ref counts.

913
01:09:44,770 --> 01:09:46,300
Yeah, exactly this is all thing does,

914
01:09:46,330 --> 01:09:50,080
bpin just to increases the ref count and we know from the bcache code, correct,

915
01:09:50,530 --> 01:09:54,520
evict won't evict any blocks, we have record higher than zero.

916
01:09:56,440 --> 01:10:00,010
And so presumably somewhere later in a logging code,

917
01:10:00,010 --> 01:10:02,440
when once actually a thing is logged,

918
01:10:02,440 --> 01:10:05,170
we can actually unpin the block, right.

919
01:10:06,530 --> 01:10:09,800
Okay, so that's one complication, so we have this pinning and unpinning going on.

920
01:10:11,080 --> 01:10:14,170
Let's look at another complication.

921
01:10:29,970 --> 01:10:34,260
And the file system operations must fit in log.

922
01:10:41,460 --> 01:10:45,570
If you seem to go back to our picture here, or actually maybe this is a better picture,

923
01:10:46,120 --> 01:10:48,040
how big is the log in xv6.

924
01:10:53,520 --> 01:10:54,600
Thirty blocks.

925
01:10:54,630 --> 01:10:56,340
Yeah, thirty blocks, 32 minus two,

926
01:10:56,700 --> 01:11:01,110
so you know max size, max log size is 30.

927
01:11:03,840 --> 01:11:08,160
Of course we could bump it up in real file system runs with a much bigger log,

928
01:11:08,160 --> 01:11:12,090
but it doesn't really matter, no matter what it has to be the case, correct,

929
01:11:12,090 --> 01:11:15,120
the file system operation must fit in 30 blocks.

930
01:11:16,010 --> 01:11:19,010
Because if a system operation would try to write more to 30 blocks,

931
01:11:19,280 --> 01:11:22,430
that means we would have to spill something on this location

932
01:11:22,430 --> 01:11:23,480
and we're not allowed to do that,

933
01:11:23,510 --> 01:11:25,610
because that would violate the write-ahead rule again.

934
01:11:26,270 --> 01:11:29,600
So it has to be the case that every file system operation fits into the log.

935
01:11:31,440 --> 01:11:32,190
Does that make sense?

936
01:11:35,040 --> 01:11:39,050
In fact, you know how do you think we got to 32 or 30.

937
01:11:50,670 --> 01:11:53,970
Does it have to do anything with how many blocks actually fit.

938
01:11:55,060 --> 01:12:03,190
You were a way to like basically how many blocks does the maximum blocks correct, the file system operation could write.

939
01:12:04,280 --> 01:12:21,280
And that is really what the number 30 has to be definitely bigger than any you know the max number of blocks the file system operation write.

940
01:12:26,570 --> 01:12:31,070
And so, in fact you know Robert and I did, because we went through all the file system operations, looked at them

941
01:12:31,070 --> 01:12:34,460
and decide whether what's the maximum number is

942
01:12:34,460 --> 01:12:37,040
and it turns out that the actual number is much lower than the thirty,

943
01:12:37,340 --> 01:12:41,120
but you know we'll see in a second a couple interesting complications,

944
01:12:42,870 --> 01:12:45,930
like, for example the operation that we look so far like creating a file correct,

945
01:12:45,930 --> 01:12:49,590
is only a handful of blocks, the file system operation is like five blocks,

946
01:12:49,920 --> 01:12:54,600
in fact most operations are a handful of blocks not that many,

947
01:12:54,690 --> 01:12:58,080
do you think of any operations that might write many many, many blocks.

948
01:13:13,470 --> 01:13:15,450
You're right on a huge file.

949
01:13:15,600 --> 01:13:16,890
Yeah right, a huge file, right,

950
01:13:16,890 --> 01:13:22,330
so, what if we you know, called the write system call and we pass the buffer,

951
01:13:22,330 --> 01:13:25,940
we have a megabyte of data, like a thousand blocks.

952
01:13:27,030 --> 01:13:31,410
It seems like we're being serious trouble right, it would violate you know these maximum.

953
01:13:32,010 --> 01:13:44,680
And so, let's look at, write, write,

954
01:13:48,070 --> 01:13:53,440
sys_write calls filewrite, filewrite here's filewrite.

955
01:13:54,180 --> 01:13:57,810
Okay, so here's an inode, file descriptor, inode

956
01:13:57,840 --> 01:14:00,720
and bring to my code or the code that I've on the display

957
01:14:01,110 --> 01:14:04,380
and notice that what does this code do.

958
01:14:09,440 --> 01:14:13,070
Yeah, you read the comments write on top here and then basically explains it,

959
01:14:13,070 --> 01:14:17,330
but this is what happens when the write is split in many number smaller writes.

960
01:14:18,710 --> 01:14:21,560
So what really is going on here correctly,

961
01:14:21,560 --> 01:14:28,150
we are ensuring that the the whole write as a whole is not atomic,

962
01:14:28,180 --> 01:14:34,600
that's OK, you know the write Unix system called semantics, don't actually require that actually all the thousand blocks,

963
01:14:34,630 --> 01:14:37,060
if a megabyte or actually written atomically

964
01:14:37,270 --> 01:14:39,970
and user requires that we don't corrupt the file system,

965
01:14:40,120 --> 01:14:43,570
between don't corrupt the file system while doing it.

966
01:14:44,090 --> 01:14:49,880
And so basically we, yeah xv6 splits a big write in a number of smaller writes

967
01:14:49,880 --> 01:14:51,920
and writes them as individual transactions.

968
01:14:53,160 --> 01:14:57,360
And this would basically ensures that our example if transaction allocates a block number,

969
01:14:57,360 --> 01:15:00,030
because we need a new block for an intermediate block were,

970
01:15:00,030 --> 01:15:01,980
because we need a new block because we're going to write to it,

971
01:15:02,310 --> 01:15:07,230
at least that part is completely atomic and the file system will be never left in an incorrect state,

972
01:15:07,440 --> 01:15:10,020
violating any of the file system invariance.

973
01:15:10,490 --> 01:15:18,120
And so the write is displayed in many, many, many system in many smaller writes or many transactions.

974
01:15:19,310 --> 01:15:20,060
Okay.

975
01:15:20,560 --> 01:15:30,920
In fact, that's the main one that actually is write fs split in many, many transactions.

976
01:15:37,490 --> 01:15:38,510
Any questions about this?

977
01:15:43,590 --> 01:15:47,340
A note because you know things are pins correct in cache that means also that

978
01:15:47,340 --> 01:15:53,130
the block cache was may bigger than the [reader] through the block size.

979
01:15:57,910 --> 01:15:58,630
Okay.

980
01:15:59,250 --> 01:16:08,660
So now the final challenge that I want to talk about is a concurrent file system calls.

981
01:16:18,110 --> 01:16:19,670
And the issue as follows,

982
01:16:19,700 --> 01:16:23,900
let me first try to explain what the problem is and then we'll see what the solution is.

983
01:16:25,730 --> 01:16:27,740
So let's say we have our log.

984
01:16:29,240 --> 01:16:34,760
And, and we're writing and maybe there are two transactions executing concurrently.

985
01:16:36,010 --> 01:16:42,490
And usually imagine for a second, that you know they read a lot of blocks,

986
01:16:42,520 --> 01:16:50,870
so really t0 is executing t0 is executing and there also is the beginning of the log, here end of log.

987
01:16:51,430 --> 01:16:57,070
And, you know t1 executes some blocks and etc, etc,

988
01:16:57,310 --> 01:17:00,490
and by the time we run to the end of the log, neither one is complete,

989
01:17:00,490 --> 01:17:03,430
yet you know, so both have still more writes to do.

990
01:17:04,600 --> 01:17:10,950
And, at this point, can we commit any of the two transactions.

991
01:17:14,740 --> 01:17:20,140
No, we can't correct, because if we would commit a transaction that is partially done.

992
01:17:20,700 --> 01:17:24,420
Then we violate the write-ahead rule again

993
01:17:24,420 --> 01:17:27,510
and you know the whole purpose [action] log in there doesn't work out.

994
01:17:28,440 --> 01:17:35,730
So it has to be the case, that basically a number of concurrent transactions must fit in the log,

995
01:17:35,790 --> 01:17:55,500
in fact all concurrent operations, must fit.

996
01:17:55,710 --> 01:17:59,250
And so, in the way,

997
01:18:00,370 --> 01:18:01,600
so this is sort of a challenge correct,

998
01:18:01,600 --> 01:18:14,250
we have a file system called starting and you know we gotta arranged basically the that we, we basically do a sort of a an entrance you know check,

999
01:18:14,250 --> 01:18:17,580
you know before we actually let the file system operation go,

1000
01:18:17,610 --> 01:18:20,370
we must check whether there actually is enough blocks still,

1001
01:18:20,400 --> 01:18:23,640
you know if we have n file system operations already in progress,

1002
01:18:23,700 --> 01:18:27,540
we have to make sure that if we add an, allow one more guy to start,

1003
01:18:27,630 --> 01:18:31,950
that actually the total number of blocks right, they could write together actually fits in the log.

1004
01:18:33,000 --> 01:18:39,690
And the way you know basically xv6 you know gets around this, basically limits the number of concurrent file system calls.

1005
01:18:49,150 --> 01:19:00,450
And the way it basically works is that, and begin_op you would see, how many outstanding concurrent files with transaction are in progress,

1006
01:19:00,540 --> 01:19:05,790
if there are too many in progress, we just stock the current file system operation and goes to sleep

1007
01:19:06,000 --> 01:19:09,450
and it will wait until all the other guys are done and have committed.

1008
01:19:10,870 --> 01:19:13,030
And all the other guys will commit together,

1009
01:19:13,060 --> 01:19:16,240
in fact you know at some point t1 to two, they're basically done,

1010
01:19:16,450 --> 01:19:19,180
maybe freeze into two, they finish

1011
01:19:19,270 --> 01:19:25,300
and then basically in all these transactions and in single a single [] basically committed together.

1012
01:19:27,870 --> 01:19:29,430
This is sometimes called group commit.

1013
01:19:30,060 --> 01:19:34,290
Because you're committing multiple system calls, you know all the ones that were concurrent in action,

1014
01:19:34,650 --> 01:19:41,130
you committed together as a single big transactions, so that older updates are visible.

1015
01:19:41,840 --> 01:19:49,160
So that although they all place all [] [] take place or none of them take place.

1016
01:19:50,390 --> 01:19:50,990
Okay.

1017
01:19:52,990 --> 01:19:56,620
and we see that at you, if you go to.

1018
01:19:56,620 --> 01:19:57,460
A quick question.

1019
01:19:58,780 --> 01:19:59,320
Yeah.

1020
01:19:59,320 --> 01:20:04,910
That is a group commit, this group to commit necessary,

1021
01:20:05,210 --> 01:20:12,810
but could you say if one system calls finish first, just commit it's it's transaction

1022
01:20:12,810 --> 01:20:14,310
and then commit other ones later,

1023
01:20:14,310 --> 01:20:16,080
or is it a necessary property.

1024
01:20:16,140 --> 01:20:18,600
You gotta be very careful,

1025
01:20:18,600 --> 01:20:22,350
because you remember one thing I didn't really state it explicitly as a goal early on is

1026
01:20:22,350 --> 01:20:25,230
that we basically execute the system calls still in the write order.

1027
01:20:25,980 --> 01:20:32,670
Right, if a if a if a reader observes write and then those are write,

1028
01:20:32,850 --> 01:20:36,390
then it has to be the case that that second write happens later than the first write.

1029
01:20:37,120 --> 01:20:39,790
And the reason that this is a log correct,

1030
01:20:39,790 --> 01:20:43,000
because that basically reflects the order in which the writes haven't happened.

1031
01:20:44,090 --> 01:20:49,700
And so you can really really nearly changed the order of the writes in the log,

1032
01:20:49,700 --> 01:20:56,930
because that made me actually result into [bizarre] behavior, observable by user programs.

1033
01:20:58,120 --> 01:21:00,220
And so it has to be the case that basically you commit,

1034
01:21:00,250 --> 01:21:03,730
you know the operations of these actions in the order they happened.

1035
01:21:05,240 --> 01:21:07,370
We also perform the writes in the order they happened.

1036
01:21:09,250 --> 01:21:14,080
And so in general you know, it's, it's safer,

1037
01:21:14,080 --> 01:21:17,680
you know it's safe to basically commit them all together you're always in good shape.

1038
01:21:18,510 --> 01:21:20,690
Okay. good question, though.

1039
01:21:23,780 --> 01:21:27,560
Okay I just want to go back to one more thing,

1040
01:21:27,800 --> 01:21:30,380
and then look at the begin_op yet I talked a little bit,

1041
01:21:30,380 --> 01:21:33,110
because like all [] I don't even want to talk about it right now.

1042
01:21:35,460 --> 01:21:39,280
But, there we can see.

1043
01:21:41,000 --> 01:21:47,080
So here's the begin_op, first of all, if we're already committing the log,

1044
01:21:47,080 --> 01:21:48,970
we're just gonna wait until the log has committed,

1045
01:21:49,000 --> 01:21:53,260
because you know we can't write to the log while the lock actually being installed.

1046
01:21:53,930 --> 01:22:02,450
If we're end, concurrent operation that basically makes us go across the block size,

1047
01:22:02,450 --> 01:22:09,700
we could go to sleep, and wait until basically all the preceding concurrent transactions are done,

1048
01:22:10,150 --> 01:22:15,130
and if we're allowed to proceed basically our [entrance] is allowed,

1049
01:22:15,250 --> 01:22:17,530
we increase log.outstanding by one,

1050
01:22:17,680 --> 01:22:21,790
because they reflect our thing and then we basically proceed and start doing file system operations.

1051
01:22:22,920 --> 01:22:25,860
And if you look at end_op again just to.

1052
01:22:26,550 --> 01:22:32,010
So you see the end_op basically decreases log.outstanding by one because one transaction is finished.

1053
01:22:32,590 --> 01:22:37,510
It certainly would be an error in [creating] states with panic in that case

1054
01:22:37,810 --> 01:22:41,380
and we actually are the last one from that set of concurrent transactions.

1055
01:22:41,930 --> 01:22:45,560
Then, actually, and lockouts and goes to zero, we immediately start committing.

1056
01:22:46,880 --> 01:22:57,020
And then when we're done, we're when actually, if we're not the log, yeah, yeah we commit.

1057
01:22:59,460 --> 01:23:04,530
And if there's space you know left, we wake up the guy so they can actually start running.

1058
01:23:06,380 --> 01:23:06,920
Okay.

1059
01:23:07,620 --> 01:23:15,180
So even though this dirt simple file system, that are just dirt simple logging system that xv6 actually has a bunch of complications.

1060
01:23:18,160 --> 01:23:21,490
So I'm starting to run out of time, so let me wrap up here.

1061
01:23:22,320 --> 01:23:29,850
So in summary, you know what we what we talk about is basically logging,

1062
01:23:30,600 --> 01:23:41,090
as a solution for, for crash safety, or really for multi step file system operations.

1063
01:23:43,660 --> 01:23:48,190
And you know if you've seen so far, it works great for crash safety,

1064
01:23:48,190 --> 01:23:53,360
but you know performance, and that's going to be the topic for Monday

1065
01:23:53,360 --> 01:23:57,950
and as you read the ext3 file system paper for Monday,

1066
01:23:58,100 --> 01:24:00,110
you know that's the thing you should be thinking about.

1067
01:24:01,900 --> 01:24:03,730
Okay any more final questions,

1068
01:24:04,000 --> 01:24:07,180
in fact anybody who has to leave, please feel free to leave,

1069
01:24:07,180 --> 01:24:11,290
but if you want to hang around and ask more questions, you know, please do so.

1070
01:24:14,510 --> 01:24:19,670
Oh, I have a question regarding cache size and the log size,

1071
01:24:19,760 --> 01:24:24,260
so you said that the cache size has to be a place as big as the log size,

1072
01:24:24,290 --> 01:24:28,130
but they seem to be the same size for this case,

1073
01:24:28,250 --> 01:24:38,920
so that means that if the log pins 30 buffers and then some other operation tries to do something,

1074
01:24:39,760 --> 01:24:47,440
it just fails because it it runs out of a free [spots] in the buffet.

1075
01:24:47,470 --> 01:24:51,340
No, maybe let's let's look at the,

1076
01:24:52,830 --> 01:24:54,120
okay so,

1077
01:24:56,600 --> 01:24:58,130
let me first check one thing.

1078
01:25:02,590 --> 01:25:04,390
Okay, let's go to bio.

1079
01:25:07,070 --> 01:25:08,240
Yeah, okay.

1080
01:25:10,240 --> 01:25:17,780
Let's actually first check NBUF is bigger than size of [match], [excitedly] buffer cache,

1081
01:25:17,780 --> 01:25:19,550
okay, so it's set up to something big.

1082
01:25:20,610 --> 01:25:26,780
So what happens actually if we can't find bget and find a buffer, actually it's panics.

1083
01:25:28,840 --> 01:25:35,520
And, so we we, there's no free slot in the buffer cache,

1084
01:25:35,520 --> 01:25:37,890
you know xv6 expense that's not particularly ideal,

1085
01:25:37,920 --> 01:25:42,210
in fact would be terrible and so you hope never to be in this situation

1086
01:25:42,210 --> 01:25:45,390
and hopefully picked numbers correctly basically is unlikely to happen.

1087
01:25:46,040 --> 01:25:47,840
But why can't we return an error.

1088
01:25:49,520 --> 01:25:51,110
Because that seems like the obvious thing to do,

1089
01:25:51,110 --> 01:26:11,480
like, is return an error to the caller and the caller, maybe returns back up to the file system interface

1090
01:26:11,480 --> 01:26:14,150
and just return minus one saying like oh this operation failed.

1091
01:26:15,140 --> 01:26:17,630
Why is that a problem?

1092
01:26:21,060 --> 01:26:26,460
So ready to think about this is that you know many file system operations are multi-step operations, right.

1093
01:26:27,030 --> 01:26:31,440
As we've seen now, in this lecture and in the previous lecture

1094
01:26:31,740 --> 01:26:37,050
and let's say, we did two writes and then the third write,

1095
01:26:37,080 --> 01:26:40,590
we run into this case, where we can actually do the write,

1096
01:26:40,590 --> 01:26:42,600
because there's no place in the block cache.

1097
01:26:44,380 --> 01:26:46,390
We have done two writes, right.

1098
01:26:47,380 --> 01:26:49,420
Can we just [bail] out of the file system call.

1099
01:26:53,760 --> 01:26:55,290
Okay I see right.

1100
01:26:55,500 --> 01:27:03,710
We cannot correct, because we might have updated to in the directory, directory block of some file,

1101
01:27:03,740 --> 01:27:06,320
if we might have to update the directory block in some directory,

1102
01:27:06,350 --> 01:27:09,170
and if we wanted to make this work,

1103
01:27:09,170 --> 01:27:15,310
what we would have to do is undo those changes, like any writes that we did before,

1104
01:27:15,310 --> 01:27:17,260
as part of that system call, we have to undo.

1105
01:27:18,770 --> 01:27:20,180
Okay.

1106
01:27:20,180 --> 01:27:23,210
That was painful, that's what we don't do it.

1107
01:27:24,270 --> 01:27:24,900
Does that make sense.

1108
01:27:25,640 --> 01:27:26,990
Okay so it's not a problem,

1109
01:27:26,990 --> 01:27:34,540
if they log the log pins everything and there's no more space for cache,

1110
01:27:34,540 --> 01:27:36,820
but it will just panic, okay.

1111
01:27:38,320 --> 01:27:43,510
Yeah, of course this panic never really happen, like there's a only a [corner] cases where this hopefully happens.

1112
01:27:45,120 --> 01:27:46,080
I guess you just,

1113
01:27:46,780 --> 01:27:49,990
okay, yeah that makes sense okay, thank you.

1114
01:27:51,940 --> 01:27:52,960
Any more questions?

1115
01:27:54,120 --> 01:27:55,440
I have a question about,

1116
01:27:55,470 --> 01:28:00,720
I guess following up my earlier one about the group commits,

1117
01:28:01,080 --> 01:28:06,930
I was trying to think of, like I think I kind of understand it a high level was trying to make sure

1118
01:28:06,930 --> 01:28:11,160
I understand concrete example, why it is important

1119
01:28:11,160 --> 01:28:15,560
and may is this an example that kind of demonstrates its,

1120
01:28:15,560 --> 01:28:22,790
like I guess I was thinking of a situation where you have say like this might be convoluted,

1121
01:28:22,790 --> 01:28:30,860
like one process generating a stream of numbers like one through n and then two processes consuming,

1122
01:28:31,100 --> 01:28:33,470
that maybe they're listening on the same pipe,

1123
01:28:33,500 --> 01:28:37,910
and say like n like stops an even number,

1124
01:28:38,060 --> 01:28:45,110
one process is consuming and printing out the odd numbers, one process is consuming part of the even numbers,

1125
01:28:45,380 --> 01:28:48,200
and if you didn't have group commits,

1126
01:28:48,200 --> 01:28:54,230
so like the correct behavior and say they're printing it for like their writing the same file.

1127
01:28:54,600 --> 01:28:55,260
Um.

1128
01:28:55,740 --> 01:29:00,030
And so the correct behavior would be at the end of at the end of all this,

1129
01:29:00,030 --> 01:29:04,080
you would expect the file to have like an even number, the last number,

1130
01:29:04,600 --> 01:29:06,370
but if you didn't have group commits,

1131
01:29:06,370 --> 01:29:14,920
it's possible that the second [to last] process actually gets committed after the last one and it actually see nine,

1132
01:29:14,920 --> 01:29:17,920
is just like a correct example, why this is important.

1133
01:29:17,920 --> 01:29:20,710
I think I have to think a little bit more carefully about it,

1134
01:29:20,800 --> 01:29:24,490
but that is definitely the flavour of the problem,

1135
01:29:24,490 --> 01:29:27,040
you might run into if you reorder system calls.

1136
01:29:28,290 --> 01:29:29,900
Okay, okay.

1137
01:29:30,680 --> 01:29:33,500
I have a great example in the lecture note,

1138
01:29:33,560 --> 01:29:39,980
if the lecture notes you know shell command that really you know behave weirdly if you didn't commit to,

1139
01:29:40,700 --> 01:29:42,740
this is not really an issue in some sense from group commit,

1140
01:29:42,740 --> 01:29:45,890
is really an issue that transactions need to be committed in order.

1141
01:29:47,320 --> 01:29:51,710
Mhm, I see, and group if he didn't have group commit, then.

1142
01:29:52,100 --> 01:29:56,960
Yeah, people might think like well what if you don't have group commit,

1143
01:29:56,960 --> 01:30:00,410
then there's a temptation to basically you know commit some later transaction,

1144
01:30:00,410 --> 01:30:02,930
because it's already finished, but the first one isn't finished yet,

1145
01:30:03,440 --> 01:30:04,850
and to create space,

1146
01:30:04,850 --> 01:30:05,900
but that's not a solution.

1147
01:30:07,490 --> 01:30:09,590
Okay, that makes sense,

1148
01:30:09,590 --> 01:30:12,140
where in the lecture notes this example of.

1149
01:30:12,140 --> 01:30:16,460
I think shell command, where were illustrated by ordering is important.

1150
01:30:17,270 --> 01:30:17,690
Okay.

1151
01:30:17,810 --> 01:30:21,590
It doesn't, it doesn't tie it directly to a group commits,

1152
01:30:21,590 --> 01:30:24,740
but it basically makes the point that ordering system calls is important.

1153
01:30:25,820 --> 01:30:28,850
I see, is this in the the like the text.

