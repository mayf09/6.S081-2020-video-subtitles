1
00:00:01,280 --> 00:00:05,749
yep

2
00:00:05,759 --> 00:00:08,000
can anybody people hear what i'm saying

3
00:00:08,000 --> 00:00:11,350
or you're good

4
00:00:11,360 --> 00:00:13,679
awesome so i just want to get started

5
00:00:13,679 --> 00:00:15,599
with similar to last week where we asked

6
00:00:15,599 --> 00:00:17,440
you about

7
00:00:17,440 --> 00:00:19,199
the util lab i just want to get started

8
00:00:19,199 --> 00:00:20,800
by asking a little bit about cisco lab

9
00:00:20,800 --> 00:00:22,320
since that was due

10
00:00:22,320 --> 00:00:26,320
on thursday so if anybody just has

11
00:00:26,320 --> 00:00:27,920
like something particularly interesting

12
00:00:27,920 --> 00:00:30,000
they found about the lab or a nasty bug

13
00:00:30,000 --> 00:00:31,439
that they found or

14
00:00:31,439 --> 00:00:33,120
just a silly mistake they made anything

15
00:00:33,120 --> 00:00:34,800
you want to share about the syscall lab

16
00:00:34,800 --> 00:00:35,680
that'd be

17
00:00:35,680 --> 00:00:39,760
that'd be great i somehow managed to

18
00:00:39,760 --> 00:00:40,960
delete the part

19
00:00:40,960 --> 00:00:44,320
from where from fork where you have to

20
00:00:44,320 --> 00:00:46,399
copy over the mask so i had that working

21
00:00:46,399 --> 00:00:47,760
and then i changed something else and

22
00:00:47,760 --> 00:00:50,239
then i tested it

23
00:00:50,239 --> 00:00:51,840
your audio is like cutting out i think

24
00:00:51,840 --> 00:00:53,920
oh it is sorry

25
00:00:53,920 --> 00:00:58,000
you heard me

26
00:00:58,000 --> 00:01:02,079
i hear you oh okay um

27
00:01:02,079 --> 00:01:05,439
yeah i guess so basically i deleted

28
00:01:05,439 --> 00:01:06,080
somehow

29
00:01:06,080 --> 00:01:09,760
the copy of the mask and then my my fork

30
00:01:09,760 --> 00:01:11,920
didn't work anymore so then i was just

31
00:01:11,920 --> 00:01:12,880
like i did that

32
00:01:12,880 --> 00:01:15,119
how does it not work so spend a lot of

33
00:01:15,119 --> 00:01:16,640
time figuring out

34
00:01:16,640 --> 00:01:18,960
what i did wrong and i realized i just

35
00:01:18,960 --> 00:01:22,710
deleted that line somehow

36
00:01:22,720 --> 00:01:24,479
is anybody having trouble hearing luca

37
00:01:24,479 --> 00:01:26,159
or is that on my end

38
00:01:26,159 --> 00:01:28,560
i think it's on your end yeah i hear him

39
00:01:28,560 --> 00:01:32,149
fine

40
00:01:32,159 --> 00:01:56,230
this must be on my end

41
00:01:56,240 --> 00:02:02,630
sorry maybe that'll work better now

42
00:02:02,640 --> 00:02:06,399
can you hear me now perfect okay great

43
00:02:06,399 --> 00:02:08,720
i was worried that i was just talking no

44
00:02:08,720 --> 00:02:09,920
no no

45
00:02:09,920 --> 00:02:17,190
it seems to be on my end all right

46
00:02:17,200 --> 00:02:19,440
awesome will anybody else have anything

47
00:02:19,440 --> 00:02:20,720
they'd like to share about you

48
00:02:20,720 --> 00:02:24,150
our a syscall

49
00:02:24,160 --> 00:02:26,959
anything particularly interesting or was

50
00:02:26,959 --> 00:02:27,520
the lab

51
00:02:27,520 --> 00:02:29,120
absolutely horrendous and you think we

52
00:02:29,120 --> 00:02:31,200
should cut it out of the class

53
00:02:31,200 --> 00:02:36,080
never do it again i have something

54
00:02:36,080 --> 00:02:38,959
apparently the order of things matters

55
00:02:38,959 --> 00:02:40,800
which is a general statement

56
00:02:40,800 --> 00:02:44,720
uh so i tried to determine

57
00:02:44,720 --> 00:02:47,840
the mass computation inside the syscall

58
00:02:47,840 --> 00:02:49,040
function

59
00:02:49,040 --> 00:02:50,959
before determining whether i actually

60
00:02:50,959 --> 00:02:53,120
needed to do the tracing

61
00:02:53,120 --> 00:02:56,319
and so all the sys calls were getting

62
00:02:56,319 --> 00:02:59,519
correctly traced except the trace call

63
00:02:59,519 --> 00:03:02,159
and i was really getting disturbed by

64
00:03:02,159 --> 00:03:03,920
that until i think it was david who

65
00:03:03,920 --> 00:03:05,040
pointed out you know you should do the

66
00:03:05,040 --> 00:03:06,800
computation after you

67
00:03:06,800 --> 00:03:10,720
you should trace she's like ah that's

68
00:03:10,720 --> 00:03:14,080
all right i'm glad you were able to

69
00:03:14,080 --> 00:03:15,280
catch that

70
00:03:15,280 --> 00:03:18,000
uh yeah order does matter um especially

71
00:03:18,000 --> 00:03:19,920
for page tables you'll find i think that

72
00:03:19,920 --> 00:03:20,879
order

73
00:03:20,879 --> 00:03:22,640
matters there as well and generally

74
00:03:22,640 --> 00:03:24,000
throughout the class

75
00:03:24,000 --> 00:03:25,440
paying attention to the order of things

76
00:03:25,440 --> 00:03:28,000
will be important

77
00:03:28,000 --> 00:03:29,680
it's good to not overwrite things in

78
00:03:29,680 --> 00:03:31,760
page table

79
00:03:31,760 --> 00:03:34,159
also had something which i'm actually

80
00:03:34,159 --> 00:03:34,879
still

81
00:03:34,879 --> 00:03:38,400
confused about um well i

82
00:03:38,400 --> 00:03:40,799
had a lot of debugging print statements

83
00:03:40,799 --> 00:03:42,879
in the kernel code

84
00:03:42,879 --> 00:03:46,000
i then ran the trace thing with

85
00:03:46,000 --> 00:03:49,599
all of the bits set so basically tracing

86
00:03:49,599 --> 00:03:52,879
all the system calls and

87
00:03:52,879 --> 00:03:56,480
i think i saw a lot of

88
00:03:56,480 --> 00:03:58,799
tracing for the print statements in the

89
00:03:58,799 --> 00:04:00,400
kernel and then

90
00:04:00,400 --> 00:04:03,040
because and then i assumed that my

91
00:04:03,040 --> 00:04:03,760
prints

92
00:04:03,760 --> 00:04:06,959
my print apps were trying to

93
00:04:06,959 --> 00:04:09,840
read and write to the console but that

94
00:04:09,840 --> 00:04:12,000
to write to the console but then

95
00:04:12,000 --> 00:04:15,200
i was wondering why are we

96
00:04:15,200 --> 00:04:17,040
i guess i'm just confused why we're able

97
00:04:17,040 --> 00:04:22,629
to use printf in the kernel

98
00:04:22,639 --> 00:04:24,639
yeah i'm not uh i haven't looked at the

99
00:04:24,639 --> 00:04:26,240
printf code

100
00:04:26,240 --> 00:04:28,800
recently but i think there's a file uh

101
00:04:28,800 --> 00:04:30,720
printf.c that you might be able to look

102
00:04:30,720 --> 00:04:34,550
at if you want to

103
00:04:34,560 --> 00:04:36,080
figure out what was going on there so i

104
00:04:36,080 --> 00:04:37,280
think the printf function should be

105
00:04:37,280 --> 00:04:41,110
implemented in there

106
00:04:41,120 --> 00:04:43,040
at least our version of it i don't know

107
00:04:43,040 --> 00:04:44,560
perhaps one of the

108
00:04:44,560 --> 00:04:45,919
one of some of the other core staff

109
00:04:45,919 --> 00:04:49,520
might know what's going on

110
00:04:49,520 --> 00:04:51,120
the the print ups in the kernel

111
00:04:51,120 --> 00:04:52,639
shouldn't show up as

112
00:04:52,639 --> 00:04:54,639
in your traces because printf in the

113
00:04:54,639 --> 00:04:56,000
kernel doesn't call any system

114
00:04:56,000 --> 00:04:59,440
calls yeah that's what i

115
00:04:59,440 --> 00:05:02,800
thought maybe then maybe the tracing was

116
00:05:02,800 --> 00:05:04,720
not from that

117
00:05:04,720 --> 00:05:05,919
yeah i don't think it is from your

118
00:05:05,919 --> 00:05:08,840
printers in the kernel

119
00:05:08,840 --> 00:05:12,469
okay

120
00:05:12,479 --> 00:05:16,240
okay well unless anybody has any other

121
00:05:16,240 --> 00:05:18,800
burning comments about uh cisco i think

122
00:05:18,800 --> 00:05:19,680
we can

123
00:05:19,680 --> 00:05:23,440
uh get started with lecture for today

124
00:05:23,440 --> 00:05:26,560
we'll be talking a little bit about

125
00:05:26,560 --> 00:05:31,680
the uh process of converting c2 assembly

126
00:05:31,680 --> 00:05:33,919
and processors and this is more of kind

127
00:05:33,919 --> 00:05:35,840
of a practical lecture today or at least

128
00:05:35,840 --> 00:05:38,320
that's the aim so the goal here is

129
00:05:38,320 --> 00:05:42,479
to get you all familiarized with

130
00:05:42,479 --> 00:05:45,039
risk five the processor the assembly

131
00:05:45,039 --> 00:05:45,919
language

132
00:05:45,919 --> 00:05:48,320
and the calling conventions for risk

133
00:05:48,320 --> 00:05:49,280
five

134
00:05:49,280 --> 00:05:51,759
and this will be important in not not

135
00:05:51,759 --> 00:05:53,759
super important for a page table but

136
00:05:53,759 --> 00:05:56,560
certainly for the traps lab which is

137
00:05:56,560 --> 00:05:58,160
will be assigned later this week this

138
00:05:58,160 --> 00:05:59,919
will be essential for

139
00:05:59,919 --> 00:06:01,919
debugging and implementing things

140
00:06:01,919 --> 00:06:03,120
because you'll be working

141
00:06:03,120 --> 00:06:05,360
quite intimately with trap frames and

142
00:06:05,360 --> 00:06:07,520
the stack and things like that

143
00:06:07,520 --> 00:06:08,880
so that's the that's kind of the goal

144
00:06:08,880 --> 00:06:10,880
for today and

145
00:06:10,880 --> 00:06:13,600
my first aim was to and this might be a

146
00:06:13,600 --> 00:06:14,880
little bit of review

147
00:06:14,880 --> 00:06:18,720
from 6004 or any other computer

148
00:06:18,720 --> 00:06:20,720
architecture theme classes that you may

149
00:06:20,720 --> 00:06:22,160
have taken in the past

150
00:06:22,160 --> 00:06:24,800
but i just want to go over briefly kind

151
00:06:24,800 --> 00:06:25,520
of

152
00:06:25,520 --> 00:06:28,479
see the c language how we get to

153
00:06:28,479 --> 00:06:29,759
assembly

154
00:06:29,759 --> 00:06:32,840
and maybe a little bit about processor

155
00:06:32,840 --> 00:06:34,720
so throughout and then

156
00:06:34,720 --> 00:06:36,240
of course throughout this lecture feel

157
00:06:36,240 --> 00:06:38,400
free to interrupt uh with any

158
00:06:38,400 --> 00:06:41,840
questions that you have so

159
00:06:41,840 --> 00:06:43,759
uh you know we have our normal main

160
00:06:43,759 --> 00:06:45,600
functions in c

161
00:06:45,600 --> 00:06:47,600
you know they do something maybe they

162
00:06:47,600 --> 00:06:50,629
print something

163
00:06:50,639 --> 00:06:54,880
then they exit and this all looks

164
00:06:54,880 --> 00:06:58,000
uh well and good but as any of you are

165
00:06:58,000 --> 00:06:59,360
aware from 6004

166
00:06:59,360 --> 00:07:02,479
processors don't actually understand the

167
00:07:02,479 --> 00:07:02,720
c

168
00:07:02,720 --> 00:07:05,039
language rather they understand what we

169
00:07:05,039 --> 00:07:05,919
call

170
00:07:05,919 --> 00:07:07,759
assembly or more specifically they

171
00:07:07,759 --> 00:07:09,280
understand the binary encodings of

172
00:07:09,280 --> 00:07:10,160
assembly

173
00:07:10,160 --> 00:07:13,039
and so this here i've circled a picture

174
00:07:13,039 --> 00:07:15,280
of an actual risk five processor from a

175
00:07:15,280 --> 00:07:16,639
sci-5 board

176
00:07:16,639 --> 00:07:20,080
and when we say a processor is risk 5

177
00:07:20,080 --> 00:07:22,400
that means that it understands the risk

178
00:07:22,400 --> 00:07:24,319
5 instruction set

179
00:07:24,319 --> 00:07:28,080
so every processor has an associated isa

180
00:07:28,080 --> 00:07:32,160
or instruction and that's kind of the

181
00:07:32,160 --> 00:07:36,000
set of instructions that make sense to

182
00:07:36,000 --> 00:07:37,440
that processor so

183
00:07:37,440 --> 00:07:39,280
every instruction has an associated

184
00:07:39,280 --> 00:07:42,400
binary encoding or an op code

185
00:07:42,400 --> 00:07:45,039
and when a processor is running and it

186
00:07:45,039 --> 00:07:46,319
sees a particular

187
00:07:46,319 --> 00:07:50,160
encoding it knows what to do and so

188
00:07:50,160 --> 00:07:52,160
you know this processor on this board

189
00:07:52,160 --> 00:07:53,199
happens to

190
00:07:53,199 --> 00:07:56,960
understand the risk 5 assembly which is

191
00:07:56,960 --> 00:07:59,120
what c code is compiled to so the

192
00:07:59,120 --> 00:08:00,879
general process of getting

193
00:08:00,879 --> 00:08:03,680
c code to actually run on your processor

194
00:08:03,680 --> 00:08:05,039
is we start with c

195
00:08:05,039 --> 00:08:07,120
it gets compiled to assembly and there's

196
00:08:07,120 --> 00:08:08,720
some linking and things like that that

197
00:08:08,720 --> 00:08:10,639
happen between the step but that's

198
00:08:10,639 --> 00:08:13,360
we're not a compilers class so and then

199
00:08:13,360 --> 00:08:14,960
the assembly will

200
00:08:14,960 --> 00:08:18,479
then be translated into binary and so

201
00:08:18,479 --> 00:08:19,039
this is

202
00:08:19,039 --> 00:08:22,639
the object or

203
00:08:22,639 --> 00:08:26,080
dot o files that you see

204
00:08:26,080 --> 00:08:29,280
so if you've ever paid attention to

205
00:08:29,280 --> 00:08:31,759
what's inside of your lab directory

206
00:08:31,759 --> 00:08:34,000
after you run make qmu you'll see a

207
00:08:34,000 --> 00:08:36,240
bunch of dot o files lying around

208
00:08:36,240 --> 00:08:37,839
and those are the actual object files

209
00:08:37,839 --> 00:08:40,959
that the processor understands

210
00:08:40,959 --> 00:08:43,279
and the asm files you've also seen um

211
00:08:43,279 --> 00:08:45,440
you haven't really written any but

212
00:08:45,440 --> 00:08:48,480
if you recall from syscall usas.pl is

213
00:08:48,480 --> 00:08:50,680
compiled to a file called

214
00:08:50,680 --> 00:08:54,320
usys.s and so dot s files

215
00:08:54,320 --> 00:08:57,519
are assembly language and so you've seen

216
00:08:57,519 --> 00:08:59,040
you've certainly seen some risk five

217
00:08:59,040 --> 00:09:01,040
assembly and if you took double 04

218
00:09:01,040 --> 00:09:02,880
i believe you you've also seen a good

219
00:09:02,880 --> 00:09:05,440
amount of assembly language

220
00:09:05,440 --> 00:09:08,800
and assembly looks in general much less

221
00:09:08,800 --> 00:09:09,680
structured than

222
00:09:09,680 --> 00:09:11,920
c so you'll just see lines after line

223
00:09:11,920 --> 00:09:13,040
after line

224
00:09:13,040 --> 00:09:14,880
of instructions you know you'll see

225
00:09:14,880 --> 00:09:17,200
simple things like add

226
00:09:17,200 --> 00:09:20,399
malt etc

227
00:09:20,399 --> 00:09:22,720
and so on and so forth and this doesn't

228
00:09:22,720 --> 00:09:23,920
have there's no

229
00:09:23,920 --> 00:09:27,440
um nice control flow there's no loops

230
00:09:27,440 --> 00:09:29,279
there are functions but not in the sense

231
00:09:29,279 --> 00:09:30,959
that you might remember know from c

232
00:09:30,959 --> 00:09:33,040
you know we see labels as opposed to

233
00:09:33,040 --> 00:09:36,480
true function definitions

234
00:09:36,480 --> 00:09:38,560
and assembly so it's it's a much lower

235
00:09:38,560 --> 00:09:39,760
language and there are plenty of other

236
00:09:39,760 --> 00:09:41,440
languages that are also compiled to

237
00:09:41,440 --> 00:09:42,800
assembly so

238
00:09:42,800 --> 00:09:45,440
um the same process holds true for

239
00:09:45,440 --> 00:09:46,240
things like c

240
00:09:46,240 --> 00:09:49,519
plus plus um

241
00:09:49,519 --> 00:09:51,120
you know any any language that's

242
00:09:51,120 --> 00:09:53,440
compiled will go to the same

243
00:09:53,440 --> 00:09:56,640
assembly language at the base

244
00:09:56,640 --> 00:09:59,920
and uh and so that's that's kind of the

245
00:09:59,920 --> 00:10:01,920
basic process of getting our

246
00:10:01,920 --> 00:10:04,880
computer to actually understand the c

247
00:10:04,880 --> 00:10:06,399
code that we're writing

248
00:10:06,399 --> 00:10:08,320
but you'll notice that we've been

249
00:10:08,320 --> 00:10:10,399
referring to

250
00:10:10,399 --> 00:10:13,680
risk five assembly

251
00:10:13,680 --> 00:10:15,200
throughout the course and the processor

252
00:10:15,200 --> 00:10:17,360
is risk five and that's because

253
00:10:17,360 --> 00:10:19,360
uh it's important because there's many

254
00:10:19,360 --> 00:10:20,880
different kinds of assembly so

255
00:10:20,880 --> 00:10:23,360
it's unlikely that you're using risk

256
00:10:23,360 --> 00:10:24,640
five

257
00:10:24,640 --> 00:10:26,560
yourself like you're not going to be

258
00:10:26,560 --> 00:10:27,920
running linux on it

259
00:10:27,920 --> 00:10:30,959
uh instead most modern computers will

260
00:10:30,959 --> 00:10:31,360
run

261
00:10:31,360 --> 00:10:34,480
on what's called x86 or you'll sometimes

262
00:10:34,480 --> 00:10:37,760
see it as x86 64.

263
00:10:37,760 --> 00:10:40,959
and this is this is a different isa

264
00:10:40,959 --> 00:10:42,399
this is a different instruction set it

265
00:10:42,399 --> 00:10:44,240
looks pretty similar to risk five

266
00:10:44,240 --> 00:10:46,720
but this is what you see in kind of your

267
00:10:46,720 --> 00:10:51,750
personal computers often

268
00:10:51,760 --> 00:10:55,120
so if you use an intel so

269
00:10:55,120 --> 00:10:58,399
intel cpus implement x86

270
00:10:58,399 --> 00:11:02,240
and i believe amd also do

271
00:11:02,240 --> 00:11:06,560
and this is a relatively important

272
00:11:06,560 --> 00:11:08,160
distinction between the two they're not

273
00:11:08,160 --> 00:11:09,600
quite as similar as they may

274
00:11:09,600 --> 00:11:12,880
look at first and that comes down to the

275
00:11:12,880 --> 00:11:15,839
fact that risk five is what we call

276
00:11:15,839 --> 00:11:18,640
as a risk the risk part of risk five

277
00:11:18,640 --> 00:11:20,079
refers to

278
00:11:20,079 --> 00:11:23,839
a reduced instruction set and

279
00:11:23,839 --> 00:11:28,079
x86 64 is what's called a cisc

280
00:11:28,079 --> 00:11:34,790
or complex instruction set

281
00:11:34,800 --> 00:11:37,920
and there's a couple of key differences

282
00:11:37,920 --> 00:11:38,640
here one

283
00:11:38,640 --> 00:11:40,320
is just the number of instructions that

284
00:11:40,320 --> 00:11:42,000
are present in x86

285
00:11:42,000 --> 00:11:45,120
64 in fact one of the big motivations

286
00:11:45,120 --> 00:11:48,240
for writing um for for

287
00:11:48,240 --> 00:11:51,279
making risk five was how

288
00:11:51,279 --> 00:11:55,120
many uh instructions we we actually have

289
00:11:55,120 --> 00:11:58,000
in the intel kind of handbook so for

290
00:11:58,000 --> 00:11:59,120
reference there's

291
00:11:59,120 --> 00:12:02,160
three full books

292
00:12:02,160 --> 00:12:05,600
that encompass the isa and

293
00:12:05,600 --> 00:12:08,720
some statistics i think there's

294
00:12:08,720 --> 00:12:11,760
new instructions have been added at a

295
00:12:11,760 --> 00:12:16,639
rate of three instructions

296
00:12:16,639 --> 00:12:21,360
per month since x86 64 was added

297
00:12:21,360 --> 00:12:24,320
it was uh first published in the 70s so

298
00:12:24,320 --> 00:12:24,800
i

299
00:12:24,800 --> 00:12:28,320
believe there's like north of uh 15 000

300
00:12:28,320 --> 00:12:31,350
instructions

301
00:12:31,360 --> 00:12:35,760
in x 86 64. and risk five on the other

302
00:12:35,760 --> 00:12:37,440
hand

303
00:12:37,440 --> 00:12:39,440
the assembly for risk five can be nicely

304
00:12:39,440 --> 00:12:42,880
contained within two documents and so

305
00:12:42,880 --> 00:12:44,959
kind of going off of that we don't

306
00:12:44,959 --> 00:12:45,920
expect you

307
00:12:45,920 --> 00:12:48,639
in this course to memorize every single

308
00:12:48,639 --> 00:12:50,399
risk five instruction

309
00:12:50,399 --> 00:12:52,720
but if you are interested or you ever

310
00:12:52,720 --> 00:12:54,160
find yourself confused by what a

311
00:12:54,160 --> 00:12:55,920
specific instruction

312
00:12:55,920 --> 00:12:58,959
is or does if you go to the course

313
00:12:58,959 --> 00:13:00,000
website

314
00:13:00,000 --> 00:13:03,519
and we look under the references tab

315
00:13:03,519 --> 00:13:05,680
under risk five we give you the links to

316
00:13:05,680 --> 00:13:07,440
both the privileged

317
00:13:07,440 --> 00:13:10,639
and unprivileged instruction sets so

318
00:13:10,639 --> 00:13:12,880
this is kind of the document

319
00:13:12,880 --> 00:13:15,200
that gives you a whole bunch of

320
00:13:15,200 --> 00:13:16,800
information about the isa

321
00:13:16,800 --> 00:13:19,200
but you'll note that like this is 240

322
00:13:19,200 --> 00:13:20,480
pages

323
00:13:20,480 --> 00:13:23,040
and this is 135 pages so it's

324
00:13:23,040 --> 00:13:25,360
significantly significantly smaller

325
00:13:25,360 --> 00:13:28,800
than uh the x86 instruction set that's

326
00:13:28,800 --> 00:13:31,839
one of the the nice things about

327
00:13:31,839 --> 00:13:36,000
about risk five so we have

328
00:13:36,000 --> 00:13:38,800
in risk five we have uh fewer

329
00:13:38,800 --> 00:13:39,920
instructions

330
00:13:39,920 --> 00:13:43,040
and not only that the instructions are

331
00:13:43,040 --> 00:13:44,320
simpler

332
00:13:44,320 --> 00:13:48,800
so what i mean by that is that

333
00:13:48,800 --> 00:13:52,399
there are many instructions in x8664 and

334
00:13:52,399 --> 00:13:53,519
by instruction i'm referring to

335
00:13:53,519 --> 00:13:55,760
something like at or malt or sub

336
00:13:55,760 --> 00:13:58,720
um in x8664 there's plenty of

337
00:13:58,720 --> 00:14:00,079
instructions that do

338
00:14:00,079 --> 00:14:02,560
more than one thing so they perform some

339
00:14:02,560 --> 00:14:03,920
complicated

340
00:14:03,920 --> 00:14:06,639
uh set of operations and then get you

341
00:14:06,639 --> 00:14:07,360
the result

342
00:14:07,360 --> 00:14:09,519
and that's uh not not the case with risk

343
00:14:09,519 --> 00:14:12,000
five uh risk five instructions tend to

344
00:14:12,000 --> 00:14:12,399
be

345
00:14:12,399 --> 00:14:14,240
smaller in scope and so they take you

346
00:14:14,240 --> 00:14:16,000
know it's less cycles to run each

347
00:14:16,000 --> 00:14:19,279
instruction than maybe x8664 is and this

348
00:14:19,279 --> 00:14:21,040
is just a trade-off that the designers

349
00:14:21,040 --> 00:14:21,920
chose to uh

350
00:14:21,920 --> 00:14:25,360
chose to undertake um there's nothing

351
00:14:25,360 --> 00:14:28,399
or you know there's no

352
00:14:28,399 --> 00:14:30,480
canonical reason why a reduced

353
00:14:30,480 --> 00:14:31,519
instruction set

354
00:14:31,519 --> 00:14:34,320
is better than you know a complex

355
00:14:34,320 --> 00:14:35,199
induction

356
00:14:35,199 --> 00:14:37,279
instruction set they each have their own

357
00:14:37,279 --> 00:14:38,320
uses

358
00:14:38,320 --> 00:14:40,480
um and so on and so forth and another

359
00:14:40,480 --> 00:14:42,399
another cool thing about risk five as

360
00:14:42,399 --> 00:14:43,519
opposed to

361
00:14:43,519 --> 00:14:47,760
x86 is that this is open source

362
00:14:47,760 --> 00:14:51,760
so it's one of the only open source

363
00:14:51,760 --> 00:14:53,839
instruction sets on the market so that

364
00:14:53,839 --> 00:14:55,760
means anybody can develop a board for

365
00:14:55,760 --> 00:14:57,279
risk five

366
00:14:57,279 --> 00:14:59,040
and it was it came out of a research

367
00:14:59,040 --> 00:15:00,560
project from

368
00:15:00,560 --> 00:15:02,720
uc berkeley and so that's kind of where

369
00:15:02,720 --> 00:15:04,000
risk five started

370
00:15:04,000 --> 00:15:05,440
and since then it's been picked up and

371
00:15:05,440 --> 00:15:07,839
supported by a number of companies

372
00:15:07,839 --> 00:15:09,760
uh you can find the list online but you

373
00:15:09,760 --> 00:15:11,120
know there's tons of big companies that

374
00:15:11,120 --> 00:15:13,279
are interested in supporting an open

375
00:15:13,279 --> 00:15:16,079
instruction set and actually i think

376
00:15:16,079 --> 00:15:17,760
quite recently there was an announcement

377
00:15:17,760 --> 00:15:18,720
made by

378
00:15:18,720 --> 00:15:22,320
sci-5 who are sort of the premier

379
00:15:22,320 --> 00:15:25,279
board manufacturer for risk 5 processors

380
00:15:25,279 --> 00:15:26,079
that they will

381
00:15:26,079 --> 00:15:29,680
be releasing a board for

382
00:15:29,680 --> 00:15:31,279
personal computers that should

383
00:15:31,279 --> 00:15:32,639
ostensibly you know a risk five

384
00:15:32,639 --> 00:15:34,560
processor designed to run linux for

385
00:15:34,560 --> 00:15:35,839
personal computers

386
00:15:35,839 --> 00:15:37,759
and i think that that's been released in

387
00:15:37,759 --> 00:15:39,199
the last week or two the

388
00:15:39,199 --> 00:15:41,600
announcement about it um so if you're if

389
00:15:41,600 --> 00:15:43,040
you're curious if you're

390
00:15:43,040 --> 00:15:44,720
find yourself you know absolutely you

391
00:15:44,720 --> 00:15:46,880
know i want to use risk 5 after i finish

392
00:15:46,880 --> 00:15:48,320
6s081

393
00:15:48,320 --> 00:15:50,160
hopefully by that time there will be a

394
00:15:50,160 --> 00:15:51,759
processor available that you can run

395
00:15:51,759 --> 00:15:55,120
linux on on your own computer

396
00:15:55,120 --> 00:15:56,880
but even in your day to day lives you're

397
00:15:56,880 --> 00:15:59,360
most likely using reduced instruction

398
00:15:59,360 --> 00:16:02,079
sets even if you don't realize it so

399
00:16:02,079 --> 00:16:05,519
the arm assembly so that's

400
00:16:05,519 --> 00:16:09,360
arm this is also a reduced instruction

401
00:16:09,360 --> 00:16:11,199
set

402
00:16:11,199 --> 00:16:14,480
and arm is implemented by

403
00:16:14,480 --> 00:16:17,759
qualcomm the the snapdragon series of

404
00:16:17,759 --> 00:16:19,040
processors

405
00:16:19,040 --> 00:16:22,800
so if you have an android phone

406
00:16:22,800 --> 00:16:26,800
you are most likely

407
00:16:26,800 --> 00:16:30,160
running a reduced instruction set

408
00:16:30,160 --> 00:16:34,079
and even if you're using ios ios i think

409
00:16:34,079 --> 00:16:35,680
i forget what the name of it is but

410
00:16:35,680 --> 00:16:36,000
apple

411
00:16:36,000 --> 00:16:39,199
has some has some version

412
00:16:39,199 --> 00:16:41,440
of of arm that they also implement in

413
00:16:41,440 --> 00:16:42,800
their own processors

414
00:16:42,800 --> 00:16:46,480
that runs on ipads iphones and most

415
00:16:46,480 --> 00:16:48,800
mobile apple devices so you know reduced

416
00:16:48,800 --> 00:16:50,000
instruction sets are present

417
00:16:50,000 --> 00:16:51,519
all over the place and if you're looking

418
00:16:51,519 --> 00:16:54,800
for a risk five in the real world

419
00:16:54,800 --> 00:16:58,079
uh you know outside of your qmu

420
00:16:58,079 --> 00:17:01,680
you'll be able to find that in uh like

421
00:17:01,680 --> 00:17:05,280
integrated devices so it is present

422
00:17:05,280 --> 00:17:07,039
it's not as it's certainly not as

423
00:17:07,039 --> 00:17:10,240
ubiquitous as something like x8664

424
00:17:10,240 --> 00:17:13,360
but it's it's uh yes i

425
00:17:13,360 --> 00:17:15,679
yes i think apple is as lucas just said

426
00:17:15,679 --> 00:17:18,240
in the chat i think apple is moving max

427
00:17:18,240 --> 00:17:20,559
to arm i believe that's also the case

428
00:17:20,559 --> 00:17:21,839
there's been in the last few years

429
00:17:21,839 --> 00:17:23,199
there's definitely been a push towards

430
00:17:23,199 --> 00:17:25,919
reduced instruction sets

431
00:17:25,919 --> 00:17:28,720
given given how big the intel isa has

432
00:17:28,720 --> 00:17:29,440
gotten

433
00:17:29,440 --> 00:17:31,520
and the reason why intel's isa is so big

434
00:17:31,520 --> 00:17:33,200
is because they're

435
00:17:33,200 --> 00:17:34,320
very concerned with backwards

436
00:17:34,320 --> 00:17:36,799
compatibility so if you write

437
00:17:36,799 --> 00:17:39,120
you know a modern intel processor can

438
00:17:39,120 --> 00:17:40,000
run the same

439
00:17:40,000 --> 00:17:42,880
instructions that intel code from you

440
00:17:42,880 --> 00:17:43,440
know

441
00:17:43,440 --> 00:17:46,320
30 40 years ago was written in so they

442
00:17:46,320 --> 00:17:48,160
don't really deprecate any instruction

443
00:17:48,160 --> 00:17:49,360
so that they maintain backwards

444
00:17:49,360 --> 00:17:50,320
compatibility

445
00:17:50,320 --> 00:17:52,559
and risk five is more modern so that's

446
00:17:52,559 --> 00:17:55,200
not a worry risk five is also so if we

447
00:17:55,200 --> 00:17:58,160
jump back to those manuals risk five is

448
00:17:58,160 --> 00:18:01,120
unique in that it's divided we have

449
00:18:01,120 --> 00:18:02,400
what's called the base integer

450
00:18:02,400 --> 00:18:04,559
instruction set which all risk five

451
00:18:04,559 --> 00:18:06,080
processors

452
00:18:06,080 --> 00:18:09,039
uh if we have fifth so gabriel asks in

453
00:18:09,039 --> 00:18:10,880
the chat if we have 15 000 instructions

454
00:18:10,880 --> 00:18:12,559
is it nearly impossible to efficiently

455
00:18:12,559 --> 00:18:13,679
pipeline them

456
00:18:13,679 --> 00:18:15,600
why do we need so many i like i was

457
00:18:15,600 --> 00:18:17,120
saying we need so many for backwards

458
00:18:17,120 --> 00:18:19,039
compatibility reasons it's up to you to

459
00:18:19,039 --> 00:18:20,880
decide you know whether you

460
00:18:20,880 --> 00:18:22,400
think that that's super important but

461
00:18:22,400 --> 00:18:24,400
many of those instructions i think a ton

462
00:18:24,400 --> 00:18:25,840
of them are also

463
00:18:25,840 --> 00:18:28,000
eaten up by cmd instructions which are

464
00:18:28,000 --> 00:18:28,880
their own

465
00:18:28,880 --> 00:18:32,320
kind of special class of things um

466
00:18:32,320 --> 00:18:34,880
you won't i i've never seen intel

467
00:18:34,880 --> 00:18:36,720
assembly code that makes full uses

468
00:18:36,720 --> 00:18:38,480
full usage out of the 15 000

469
00:18:38,480 --> 00:18:40,640
instructions but mostly this comes from

470
00:18:40,640 --> 00:18:42,320
from a need for backwards compatibility

471
00:18:42,320 --> 00:18:44,000
and cmd but

472
00:18:44,000 --> 00:18:46,080
like i was saying so risk five has uh

473
00:18:46,080 --> 00:18:47,039
what's called the base

474
00:18:47,039 --> 00:18:50,160
integer instruction set which uh

475
00:18:50,160 --> 00:18:52,640
contains all of the normal add and

476
00:18:52,640 --> 00:18:53,679
multiply

477
00:18:53,679 --> 00:18:56,720
things and then processors can choose to

478
00:18:56,720 --> 00:18:58,559
implement a number of other modules

479
00:18:58,559 --> 00:19:00,400
which you can see along the side here

480
00:19:00,400 --> 00:19:02,480
it's probably impossible to read on your

481
00:19:02,480 --> 00:19:03,919
screen but for example

482
00:19:03,919 --> 00:19:06,160
if you want a processor you know that

483
00:19:06,160 --> 00:19:07,840
supports standard extension for single

484
00:19:07,840 --> 00:19:09,440
precision floating point

485
00:19:09,440 --> 00:19:12,160
then you can include the f module and

486
00:19:12,160 --> 00:19:13,919
this makes it easier for risk five to

487
00:19:13,919 --> 00:19:14,640
support

488
00:19:14,640 --> 00:19:18,080
um backwards compatibility because if uh

489
00:19:18,080 --> 00:19:19,760
you can just say you know what set of

490
00:19:19,760 --> 00:19:22,240
the modules do i include and support

491
00:19:22,240 --> 00:19:25,360
and the compiler can choose then the

492
00:19:25,360 --> 00:19:27,280
compiler can say okay you know

493
00:19:27,280 --> 00:19:28,960
this processor is telling me it supports

494
00:19:28,960 --> 00:19:30,799
these modules so i can only compile this

495
00:19:30,799 --> 00:19:33,679
code with these modules

496
00:19:33,679 --> 00:19:36,400
okay bibx says it seems that the only

497
00:19:36,400 --> 00:19:38,400
advantage of using x86 instead of risk

498
00:19:38,400 --> 00:19:39,440
five processors is the kind of

499
00:19:39,440 --> 00:19:40,640
performance you can get

500
00:19:40,640 --> 00:19:42,559
however that performance comes as a

501
00:19:42,559 --> 00:19:44,000
massive cost and complexity and

502
00:19:44,000 --> 00:19:45,280
potential security

503
00:19:45,280 --> 00:19:46,880
my question is why are we still using

504
00:19:46,880 --> 00:19:48,799
x86 instead of moving to something like

505
00:19:48,799 --> 00:19:50,000
risk five

506
00:19:50,000 --> 00:19:52,720
uh well the big answer is that is the

507
00:19:52,720 --> 00:19:54,720
world has run on x86

508
00:19:54,720 --> 00:19:57,679
for i i don't have a great answer for

509
00:19:57,679 --> 00:19:58,400
why

510
00:19:58,400 --> 00:20:02,000
risk five is pretty modern too so

511
00:20:02,000 --> 00:20:04,320
the world as a whole pretty much runs on

512
00:20:04,320 --> 00:20:06,159
x86 so if you suddenly

513
00:20:06,159 --> 00:20:09,919
start converting your processors

514
00:20:09,919 --> 00:20:14,000
to risk five you run the risk of uh

515
00:20:14,000 --> 00:20:16,240
you know losing support for a bunch of

516
00:20:16,240 --> 00:20:17,440
important things

517
00:20:17,440 --> 00:20:19,760
also there are like intel does do

518
00:20:19,760 --> 00:20:21,520
interesting things within their

519
00:20:21,520 --> 00:20:22,799
processors

520
00:20:22,799 --> 00:20:25,200
it's like security wise there are

521
00:20:25,200 --> 00:20:27,360
enclaves and intel processors and

522
00:20:27,360 --> 00:20:28,799
there's things that um

523
00:20:28,799 --> 00:20:30,559
they've been doing in recent years to

524
00:20:30,559 --> 00:20:32,720
try to try and give you extra

525
00:20:32,720 --> 00:20:35,440
added security and uh some of those

526
00:20:35,440 --> 00:20:37,120
instructions that intel does implement

527
00:20:37,120 --> 00:20:38,799
which are hyper-specific

528
00:20:38,799 --> 00:20:41,840
can be really efficient for certain

529
00:20:41,840 --> 00:20:44,480
computations uh and so they have so many

530
00:20:44,480 --> 00:20:46,720
instructions that there's often you know

531
00:20:46,720 --> 00:20:48,799
a perfect instruction for a situation

532
00:20:48,799 --> 00:20:50,880
that may be more efficient than

533
00:20:50,880 --> 00:20:54,080
than what exists within risk five but a

534
00:20:54,080 --> 00:20:55,679
more practical answer is that risk five

535
00:20:55,679 --> 00:20:57,360
is relatively new and we just don't

536
00:20:57,360 --> 00:20:58,640
you know nobody's really making

537
00:20:58,640 --> 00:21:00,320
processors for personal computers i

538
00:21:00,320 --> 00:21:01,120
think the

539
00:21:01,120 --> 00:21:04,080
sci 5 announcement is super recent um

540
00:21:04,080 --> 00:21:04,640
and

541
00:21:04,640 --> 00:21:06,080
they're kind of the first people to be

542
00:21:06,080 --> 00:21:08,880
doing that so on a practical level

543
00:21:08,880 --> 00:21:10,960
that and the inability to run all the

544
00:21:10,960 --> 00:21:12,880
software design for intel

545
00:21:12,880 --> 00:21:17,280
is is my best answer

546
00:21:17,280 --> 00:21:19,679
so we've been now chatting a little bit

547
00:21:19,679 --> 00:21:22,880
about assembly so i just wanted to

548
00:21:22,880 --> 00:21:26,640
take a look at some actual assembly code

549
00:21:26,640 --> 00:21:30,000
so here is uh the

550
00:21:30,000 --> 00:21:32,000
c code for what's below so this is a

551
00:21:32,000 --> 00:21:34,320
simple function that has an accumulator

552
00:21:34,320 --> 00:21:37,679
we loop from zero to n and we

553
00:21:37,679 --> 00:21:40,640
sum up all the numbers from uh from zero

554
00:21:40,640 --> 00:21:41,919
to n

555
00:21:41,919 --> 00:21:44,960
and then return that value and uh

556
00:21:44,960 --> 00:21:46,480
at its simplest level you know this is

557
00:21:46,480 --> 00:21:48,400
the easiest kind of assembly that you

558
00:21:48,400 --> 00:21:50,799
can get out of compiling that program

559
00:21:50,799 --> 00:21:53,840
if you actually go into your own

560
00:21:53,840 --> 00:21:55,360
computer and you write the c

561
00:21:55,360 --> 00:21:57,200
code and you try to compile it you will

562
00:21:57,200 --> 00:21:58,480
end up with something

563
00:21:58,480 --> 00:22:01,440
that likely looks quite different and

564
00:22:01,440 --> 00:22:03,360
that's true for a variety of reasons we

565
00:22:03,360 --> 00:22:03,919
haven't

566
00:22:03,919 --> 00:22:05,280
some of which we'll get to and some of

567
00:22:05,280 --> 00:22:07,120
which are compiler specific

568
00:22:07,120 --> 00:22:10,480
so modern compilers make a large number

569
00:22:10,480 --> 00:22:12,159
of optimizations

570
00:22:12,159 --> 00:22:15,440
um within when they compile your c2

571
00:22:15,440 --> 00:22:16,799
assembly and so your assembly

572
00:22:16,799 --> 00:22:18,400
instructions may look different

573
00:22:18,400 --> 00:22:20,640
for instance while you're debugging in

574
00:22:20,640 --> 00:22:22,400
gdv you may come across something that

575
00:22:22,400 --> 00:22:23,360
tells you that it's

576
00:22:23,360 --> 00:22:26,159
some variable has been optimized out and

577
00:22:26,159 --> 00:22:27,919
that means that the compiler decided it

578
00:22:27,919 --> 00:22:29,440
didn't need that variable

579
00:22:29,440 --> 00:22:32,400
uh and so that'll be gone effectively

580
00:22:32,400 --> 00:22:33,600
from the program

581
00:22:33,600 --> 00:22:35,200
but yeah and it's at its most

582
00:22:35,200 --> 00:22:36,960
straightforward

583
00:22:36,960 --> 00:22:39,840
we're moving uh the value that's in a

584
00:22:39,840 --> 00:22:40,480
zero to t

585
00:22:40,480 --> 00:22:43,039
zero we're setting a zero to zero and

586
00:22:43,039 --> 00:22:43,840
then

587
00:22:43,840 --> 00:22:47,280
we are just adding what's in t zero to a

588
00:22:47,280 --> 00:22:47,760
zero

589
00:22:47,760 --> 00:22:50,080
for every iteration of a loop until t

590
00:22:50,080 --> 00:22:52,400
zero reaches zero

591
00:22:52,400 --> 00:22:53,679
and that's all that's going on in this

592
00:22:53,679 --> 00:22:57,350
piece uh amir your hands erased

593
00:22:57,360 --> 00:22:59,919
yeah i was wondering what dot section

594
00:22:59,919 --> 00:23:00,720
dot text

595
00:23:00,720 --> 00:23:03,679
and dot global do global means that you

596
00:23:03,679 --> 00:23:04,240
can

597
00:23:04,240 --> 00:23:06,880
include this from other files so if we

598
00:23:06,880 --> 00:23:08,960
actually hop into

599
00:23:08,960 --> 00:23:14,240
uh let's see def.h

600
00:23:14,240 --> 00:23:17,360
this is the file that you're uh will if

601
00:23:17,360 --> 00:23:18,880
you aren't already you will become quite

602
00:23:18,880 --> 00:23:20,159
familiar with this

603
00:23:20,159 --> 00:23:22,320
includes basically all of the functions

604
00:23:22,320 --> 00:23:23,679
within the kernel that you may want to

605
00:23:23,679 --> 00:23:24,880
be using

606
00:23:24,880 --> 00:23:28,159
and uh within here you know we can see

607
00:23:28,159 --> 00:23:29,600
that in my

608
00:23:29,600 --> 00:23:32,159
my file i've included the definitions to

609
00:23:32,159 --> 00:23:33,360
these functions

610
00:23:33,360 --> 00:23:37,600
and so that dot global make sure that

611
00:23:37,600 --> 00:23:39,679
that these these functions can be called

612
00:23:39,679 --> 00:23:41,120
from other places

613
00:23:41,120 --> 00:23:44,159
and dot text just says this is code

614
00:23:44,159 --> 00:23:47,760
so if you recall from figure 3.4

615
00:23:47,760 --> 00:23:51,679
in the book so that's if we go

616
00:23:51,679 --> 00:23:56,310
to the book

617
00:23:56,320 --> 00:23:59,600
and we go into page tables

618
00:23:59,600 --> 00:24:02,640
process address space so in here in this

619
00:24:02,640 --> 00:24:03,760
diagram

620
00:24:03,760 --> 00:24:05,760
that's the same thing this is text so it

621
00:24:05,760 --> 00:24:09,269
just means code

622
00:24:09,279 --> 00:24:14,789
that answer your question okay thanks

623
00:24:14,799 --> 00:24:18,159
and so if we want to run let's say we

624
00:24:18,159 --> 00:24:19,600
have some assembly

625
00:24:19,600 --> 00:24:21,840
also if you ever find yourself

626
00:24:21,840 --> 00:24:23,200
interested in

627
00:24:23,200 --> 00:24:26,240
what the kernel looks like we can go

628
00:24:26,240 --> 00:24:28,960
inside the after you compile you can

629
00:24:28,960 --> 00:24:30,840
look in the file kernel

630
00:24:30,840 --> 00:24:35,520
kernel.asm and this is the full kind of

631
00:24:35,520 --> 00:24:39,360
assembly for the kernel

632
00:24:39,360 --> 00:24:41,919
of xv6 and each of these numbers on the

633
00:24:41,919 --> 00:24:43,120
left here

634
00:24:43,120 --> 00:24:45,520
is a label that tells you where in

635
00:24:45,520 --> 00:24:46,320
memory this

636
00:24:46,320 --> 00:24:48,960
in this instruction will be and that'll

637
00:24:48,960 --> 00:24:50,640
come in quite handy

638
00:24:50,640 --> 00:24:54,720
and so here is the here's the actual uh

639
00:24:54,720 --> 00:24:56,240
here's the actual assembly code and you

640
00:24:56,240 --> 00:24:59,039
can see the labels for the functions

641
00:24:59,039 --> 00:25:00,320
and where they're declared so this is

642
00:25:00,320 --> 00:25:03,279
this is a can be really really useful as

643
00:25:03,279 --> 00:25:04,320
we're debugging code

644
00:25:04,320 --> 00:25:06,080
and hopefully i'll be able to show that

645
00:25:06,080 --> 00:25:07,600
in a second

646
00:25:07,600 --> 00:25:10,720
but for now we'll jump back to this

647
00:25:10,720 --> 00:25:11,520
first function

648
00:25:11,520 --> 00:25:14,320
sum2 and we'll just see how we can

649
00:25:14,320 --> 00:25:15,440
examine that

650
00:25:15,440 --> 00:25:19,600
inside of gdd so the first step is i

651
00:25:19,600 --> 00:25:21,760
have my two windows here

652
00:25:21,760 --> 00:25:23,840
what's the difference between asm and s

653
00:25:23,840 --> 00:25:25,200
files

654
00:25:25,200 --> 00:25:28,720
um i'm not 100

655
00:25:28,720 --> 00:25:31,039
certain they're both assembly i think

656
00:25:31,039 --> 00:25:33,440
the dot asm file includes a bunch of

657
00:25:33,440 --> 00:25:35,360
extra annotations that aren't included

658
00:25:35,360 --> 00:25:35,760
in dot

659
00:25:35,760 --> 00:25:38,080
s so usually when you compile your c

660
00:25:38,080 --> 00:25:40,000
code to

661
00:25:40,000 --> 00:25:42,000
dot s you'll end up with something that

662
00:25:42,000 --> 00:25:43,360
doesn't include all of those line

663
00:25:43,360 --> 00:25:45,600
numbers and things like that so

664
00:25:45,600 --> 00:25:46,799
if you're curious about how we get the

665
00:25:46,799 --> 00:25:49,039
dot asm file i think the makefile

666
00:25:49,039 --> 00:25:52,080
um will tell you the exact steps used to

667
00:25:52,080 --> 00:25:56,880
get that and so

668
00:25:56,880 --> 00:25:58,480
if we're we're in our terminal we have

669
00:25:58,480 --> 00:26:00,559
our two uh two windows

670
00:26:00,559 --> 00:26:03,919
so the first thing to do is of course uh

671
00:26:03,919 --> 00:26:08,480
get qmu up and running so we can

672
00:26:08,480 --> 00:26:10,640
start it within gdb mode so now we're

673
00:26:10,640 --> 00:26:11,919
we're frozen here

674
00:26:11,919 --> 00:26:15,919
and then we can start gdb uh

675
00:26:15,919 --> 00:26:18,480
and what uh what what what uh professor

676
00:26:18,480 --> 00:26:20,559
crasher showed last week

677
00:26:20,559 --> 00:26:22,400
and which i think some people were

678
00:26:22,400 --> 00:26:24,000
excited about if you type tui

679
00:26:24,000 --> 00:26:26,559
enable you get this nice window which is

680
00:26:26,559 --> 00:26:28,400
empty for now but will come in

681
00:26:28,400 --> 00:26:30,799
quite useful as you're debugging so we

682
00:26:30,799 --> 00:26:32,960
can set a breakpoint and i should note

683
00:26:32,960 --> 00:26:35,360
that all this code is living inside the

684
00:26:35,360 --> 00:26:37,360
kernel none of this is in user space

685
00:26:37,360 --> 00:26:38,720
so we don't have any of those annoying

686
00:26:38,720 --> 00:26:40,720
problems setting breakpoints so i can

687
00:26:40,720 --> 00:26:42,080
set a breakpoint

688
00:26:42,080 --> 00:26:44,799
in the function sum2 and then just

689
00:26:44,799 --> 00:26:47,200
continue running

690
00:26:47,200 --> 00:26:50,640
and run that function and now

691
00:26:50,640 --> 00:26:53,679
so the first window that you see in tui

692
00:26:53,679 --> 00:26:57,279
is the source window

693
00:26:57,279 --> 00:26:59,840
uh yes as david is saying those those

694
00:26:59,840 --> 00:27:01,919
numbers on the left of kernel.asm

695
00:27:01,919 --> 00:27:05,279
are really useful when you're debugging

696
00:27:05,279 --> 00:27:07,440
things and you get an address

697
00:27:07,440 --> 00:27:09,679
it'll tell you so you can see now even

698
00:27:09,679 --> 00:27:11,760
here we can see that the program so pc

699
00:27:11,760 --> 00:27:13,360
here in gdb

700
00:27:13,360 --> 00:27:15,200
is the program counter so we can see

701
00:27:15,200 --> 00:27:16,880
this address 8 0 0

702
00:27:16,880 --> 00:27:20,360
so on and so forth if we go into

703
00:27:20,360 --> 00:27:21,840
kernel.asm

704
00:27:21,840 --> 00:27:24,320
and we search for that specific address

705
00:27:24,320 --> 00:27:26,880
we can see that it's the

706
00:27:26,880 --> 00:27:28,799
uh well it comes up twice because it's a

707
00:27:28,799 --> 00:27:30,880
function call but if we look here this

708
00:27:30,880 --> 00:27:32,080
is that address

709
00:27:32,080 --> 00:27:35,120
it's the top of the sum2 function so

710
00:27:35,120 --> 00:27:37,600
if you see any time you see one of these

711
00:27:37,600 --> 00:27:38,399
um

712
00:27:38,399 --> 00:27:39,760
all the kernel addresses will look

713
00:27:39,760 --> 00:27:44,159
something like 0x8000

714
00:27:44,159 --> 00:27:48,080
some numbers those uh those addresses

715
00:27:48,080 --> 00:27:50,240
you can jump straight into kernel.asm

716
00:27:50,240 --> 00:27:51,760
and find the exact

717
00:27:51,760 --> 00:27:53,679
line of assembly where the problem is

718
00:27:53,679 --> 00:27:54,880
occurring and then you can set your

719
00:27:54,880 --> 00:27:56,480
breakpoints accordingly

720
00:27:56,480 --> 00:27:59,840
but for now uh that top window in tui

721
00:27:59,840 --> 00:28:03,039
is source and if we want to look at

722
00:28:03,039 --> 00:28:04,640
specifically the assembly we can do

723
00:28:04,640 --> 00:28:08,000
layout ngdasm

724
00:28:08,000 --> 00:28:10,000
and that'll give us all of the assembly

725
00:28:10,000 --> 00:28:11,120
instructions

726
00:28:11,120 --> 00:28:13,760
and we can also look at the registers if

727
00:28:13,760 --> 00:28:16,159
we type layout reg we'll get assembly

728
00:28:16,159 --> 00:28:18,559
and registers and if you find yourself

729
00:28:18,559 --> 00:28:19,919
you know wanting to scroll through

730
00:28:19,919 --> 00:28:21,360
things

731
00:28:21,360 --> 00:28:22,799
now that we have three windows we need

732
00:28:22,799 --> 00:28:24,559
to specify which one is focused so if i

733
00:28:24,559 --> 00:28:25,919
want to look through all the registers

734
00:28:25,919 --> 00:28:26,720
i'm going to focus

735
00:28:26,720 --> 00:28:29,760
reg and now my focus is on the register

736
00:28:29,760 --> 00:28:31,520
window so if i

737
00:28:31,520 --> 00:28:33,600
move the arrow keys or scroll it'll

738
00:28:33,600 --> 00:28:35,360
start scrolling that window

739
00:28:35,360 --> 00:28:38,080
so for now we can focus on the assembly

740
00:28:38,080 --> 00:28:39,520
window

741
00:28:39,520 --> 00:28:41,039
and once we're here we can see all of

742
00:28:41,039 --> 00:28:42,559
the things uh

743
00:28:42,559 --> 00:28:44,960
so let's see we can see in the registry

744
00:28:44,960 --> 00:28:46,640
register window we can see that t

745
00:28:46,640 --> 00:28:49,760
0 contains this value we can see that a0

746
00:28:49,760 --> 00:28:51,840
contains this value

747
00:28:51,840 --> 00:28:54,159
and as we step through the assembly we

748
00:28:54,159 --> 00:28:55,200
can watch

749
00:28:55,200 --> 00:28:59,279
see okay t 0 just got the value of a0

750
00:28:59,279 --> 00:28:59,760
which was

751
00:28:59,760 --> 00:29:01,600
5 and it's nicely highlighted the

752
00:29:01,600 --> 00:29:03,279
register that's changed

753
00:29:03,279 --> 00:29:05,679
here and we can just keep remember if we

754
00:29:05,679 --> 00:29:07,679
if we push enter we get the

755
00:29:07,679 --> 00:29:09,679
most recently executed instructions so

756
00:29:09,679 --> 00:29:10,960
we can go through

757
00:29:10,960 --> 00:29:13,440
all right we set a0 to 0 and now we can

758
00:29:13,440 --> 00:29:15,120
just kind of watch ourselves go through

759
00:29:15,120 --> 00:29:16,399
this loop

760
00:29:16,399 --> 00:29:19,919
and sum up the values

761
00:29:19,919 --> 00:29:21,760
and again this is like a complete you

762
00:29:21,760 --> 00:29:23,440
know toy function

763
00:29:23,440 --> 00:29:26,320
and then we can continue and you know

764
00:29:26,320 --> 00:29:27,600
live our lives and if you're ever

765
00:29:27,600 --> 00:29:29,760
curious about

766
00:29:29,760 --> 00:29:31,760
what kind of breakpoints you've set or

767
00:29:31,760 --> 00:29:34,000
you lose track of what you were doing

768
00:29:34,000 --> 00:29:38,080
if you type info break or break points

769
00:29:38,080 --> 00:29:39,919
you can see all of the breakpoints that

770
00:29:39,919 --> 00:29:41,360
you've set in your code

771
00:29:41,360 --> 00:29:43,279
and you can even see okay this

772
00:29:43,279 --> 00:29:45,520
breakpoint has already been hit one time

773
00:29:45,520 --> 00:29:47,840
and you get lots of useful information

774
00:29:47,840 --> 00:29:49,600
doing that

775
00:29:49,600 --> 00:29:51,520
if you don't want to have the register

776
00:29:51,520 --> 00:29:53,360
window but you do want to look at the

777
00:29:53,360 --> 00:29:54,799
registers

778
00:29:54,799 --> 00:29:58,240
info reg or info registers or ireg or

779
00:29:58,240 --> 00:29:59,279
any of the

780
00:29:59,279 --> 00:30:02,320
numerous gdb shortenings

781
00:30:02,320 --> 00:30:03,840
will bring up the register window as

782
00:30:03,840 --> 00:30:05,919
well

783
00:30:05,919 --> 00:30:08,320
um so with that is there any are there

784
00:30:08,320 --> 00:30:09,360
any questions about

785
00:30:09,360 --> 00:30:12,480
gdd um simple ones i know it's been

786
00:30:12,480 --> 00:30:14,880
um there's been lots of post sump shots

787
00:30:14,880 --> 00:30:15,919
about it so

788
00:30:15,919 --> 00:30:17,840
now is a good time to just ask uh some

789
00:30:17,840 --> 00:30:19,679
straightforward we'll i'll be showing

790
00:30:19,679 --> 00:30:20,640
more

791
00:30:20,640 --> 00:30:23,200
usage of ddb what command did you use to

792
00:30:23,200 --> 00:30:25,760
open the multiple windows so i use tmux

793
00:30:25,760 --> 00:30:28,880
so i can show just from scratch uh if we

794
00:30:28,880 --> 00:30:29,200
go

795
00:30:29,200 --> 00:30:31,679
here and i open a new terminal so here's

796
00:30:31,679 --> 00:30:33,760
just a blank terminal

797
00:30:33,760 --> 00:30:35,840
if you type tmux and this is available

798
00:30:35,840 --> 00:30:40,070
on athena

799
00:30:40,080 --> 00:30:41,600
i'll address the next question in a

800
00:30:41,600 --> 00:30:43,600
second so now i'm in tmux which you can

801
00:30:43,600 --> 00:30:44,720
tell by this

802
00:30:44,720 --> 00:30:47,919
green bar at the bottom and if you want

803
00:30:47,919 --> 00:30:48,399
to

804
00:30:48,399 --> 00:30:49,919
get so there's a couple ways you can do

805
00:30:49,919 --> 00:30:51,919
multiple windows in tebow tmux

806
00:30:51,919 --> 00:30:55,679
uh if you're so you can type control bc

807
00:30:55,679 --> 00:30:58,320
and uh i know that's sometimes if you're

808
00:30:58,320 --> 00:30:59,919
used to using emacs that will make a lot

809
00:30:59,919 --> 00:31:00,960
of sense but

810
00:31:00,960 --> 00:31:04,159
um normal people who don't use emacs

811
00:31:04,159 --> 00:31:06,799
that's hitting control and then d and

812
00:31:06,799 --> 00:31:07,600
then hitting

813
00:31:07,600 --> 00:31:09,840
c on its own afterwards that will get

814
00:31:09,840 --> 00:31:11,519
you a second window which you can then

815
00:31:11,519 --> 00:31:13,519
navigate between with control b

816
00:31:13,519 --> 00:31:16,640
and then p control b and then n to go

817
00:31:16,640 --> 00:31:17,760
previous and next

818
00:31:17,760 --> 00:31:19,360
yeah and david just posted a t-much

819
00:31:19,360 --> 00:31:21,279
cheat sheet which is useful

820
00:31:21,279 --> 00:31:22,880
and if you want to split the windows i

821
00:31:22,880 --> 00:31:24,320
think it's ctrl b and then

822
00:31:24,320 --> 00:31:28,000
the percent sign will split them um

823
00:31:28,000 --> 00:31:30,559
vertically and then sing a double

824
00:31:30,559 --> 00:31:31,279
control b

825
00:31:31,279 --> 00:31:34,000
and then double quote we'll split them

826
00:31:34,000 --> 00:31:35,840
uh horizontally

827
00:31:35,840 --> 00:31:37,120
and so that's how we get them and if

828
00:31:37,120 --> 00:31:39,120
we're in this state we can use control b

829
00:31:39,120 --> 00:31:42,880
and o to jump between our windows

830
00:31:42,880 --> 00:31:44,720
so that's what's that's how i got the

831
00:31:44,720 --> 00:31:46,640
multiple windows yeah i don't care

832
00:31:46,640 --> 00:31:49,840
um and then ahmed asked

833
00:31:49,840 --> 00:31:51,200
why is this displaying assembly

834
00:31:51,200 --> 00:31:52,960
addresses again instead of c line

835
00:31:52,960 --> 00:31:53,760
numbers

836
00:31:53,760 --> 00:31:57,919
ah so because the the function

837
00:31:57,919 --> 00:32:00,240
so if we go back to the assembly

838
00:32:00,240 --> 00:32:00,960
function

839
00:32:00,960 --> 00:32:02,880
this is implemented entirely in assembly

840
00:32:02,880 --> 00:32:04,320
and not at all in c

841
00:32:04,320 --> 00:32:06,000
and so there just aren't any associated

842
00:32:06,000 --> 00:32:07,840
c line numbers for this

843
00:32:07,840 --> 00:32:10,960
um if we were to

844
00:32:10,960 --> 00:32:14,000
set a breakpoint so if you type delete

845
00:32:14,000 --> 00:32:16,399
you'll delete all your breakpoints uh so

846
00:32:16,399 --> 00:32:18,640
i cleared the old one if i now set a

847
00:32:18,640 --> 00:32:19,679
breakpoint in

848
00:32:19,679 --> 00:32:22,240
demo one so that's a c breakpoint and

849
00:32:22,240 --> 00:32:23,600
continue

850
00:32:23,600 --> 00:32:26,240
and run this now if i go here and type

851
00:32:26,240 --> 00:32:27,360
layout split

852
00:32:27,360 --> 00:32:30,559
i'll get the c and the assembly um or if

853
00:32:30,559 --> 00:32:31,519
i just want the c

854
00:32:31,519 --> 00:32:33,120
source i can do layout source and i'll

855
00:32:33,120 --> 00:32:35,440
just get the c

856
00:32:35,440 --> 00:32:37,120
so that's uh that's what's going on it's

857
00:32:37,120 --> 00:32:39,279
just a quirk of the fact that this

858
00:32:39,279 --> 00:32:41,120
doesn't have associated c code and so we

859
00:32:41,120 --> 00:32:46,230
don't see seedline numbers

860
00:32:46,240 --> 00:32:49,600
any other any other questions about gdb

861
00:32:49,600 --> 00:32:53,120
tmox and that that sort of thing

862
00:32:53,120 --> 00:32:55,120
so layout split is the one that you use

863
00:32:55,120 --> 00:32:57,279
to bring up this extra window of the

864
00:32:57,279 --> 00:32:59,200
source and assembly and so on right

865
00:32:59,200 --> 00:33:02,240
yes yes so layout uh if you do layout

866
00:33:02,240 --> 00:33:03,600
split that'll get you

867
00:33:03,600 --> 00:33:05,600
source and assembly layout source will

868
00:33:05,600 --> 00:33:06,640
get you just source

869
00:33:06,640 --> 00:33:08,960
asm we'll get you just assembly and the

870
00:33:08,960 --> 00:33:10,480
registers are their own thing where if

871
00:33:10,480 --> 00:33:11,679
you type layout reg

872
00:33:11,679 --> 00:33:13,840
i think yeah that'll bring up the

873
00:33:13,840 --> 00:33:15,279
registers but

874
00:33:15,279 --> 00:33:17,679
unfortunately i don't know of a way to

875
00:33:17,679 --> 00:33:18,640
get

876
00:33:18,640 --> 00:33:20,399
the register of the assembly and the c

877
00:33:20,399 --> 00:33:22,159
code all at the same time outside of

878
00:33:22,159 --> 00:33:24,960
using inforeg with layout split

879
00:33:24,960 --> 00:33:28,159
i have a question um so when we set the

880
00:33:28,159 --> 00:33:31,440
break point uh add a line right it

881
00:33:31,440 --> 00:33:34,559
displays the address of the like in this

882
00:33:34,559 --> 00:33:36,000
case break point to add

883
00:33:36,000 --> 00:33:39,279
0x 354. um

884
00:33:39,279 --> 00:33:42,080
what any instruction might have multiple

885
00:33:42,080 --> 00:33:42,559
uh

886
00:33:42,559 --> 00:33:45,519
any like line of code in c might have

887
00:33:45,519 --> 00:33:46,960
multiple instructions

888
00:33:46,960 --> 00:33:49,440
so which one does its uh show i believe

889
00:33:49,440 --> 00:33:51,519
it shows the first one

890
00:33:51,519 --> 00:33:54,240
and uh it's to you for the person who

891
00:33:54,240 --> 00:33:54,799
asked to

892
00:33:54,799 --> 00:33:58,000
start the tui it's i think it's tui

893
00:33:58,000 --> 00:34:08,389
enable not enable to ui sorry i think

894
00:34:08,399 --> 00:34:10,879
um yeah again there's like a hundred

895
00:34:10,879 --> 00:34:13,280
cheat sheets out here for gdb

896
00:34:13,280 --> 00:34:15,520
and for tmux as well so if you ever find

897
00:34:15,520 --> 00:34:16,480
yourself lost

898
00:34:16,480 --> 00:34:21,440
i t gdp even has its own inbuilt um

899
00:34:21,440 --> 00:34:24,000
its own thing called apropos so if you

900
00:34:24,000 --> 00:34:25,520
look for apropos

901
00:34:25,520 --> 00:34:28,560
tui it will actually show you all of the

902
00:34:28,560 --> 00:34:33,440
commands that involve tui

903
00:34:33,440 --> 00:34:36,320
so yeah uh this can be quite useful but

904
00:34:36,320 --> 00:34:38,720
it can also be a little bit overwhelming

905
00:34:38,720 --> 00:34:41,839
um if you do apropos dash b it'll give

906
00:34:41,839 --> 00:34:44,560
you even more information i think

907
00:34:44,560 --> 00:34:48,399
um i don't remember i i don't use it

908
00:34:48,399 --> 00:34:50,079
often myself but if you if you do

909
00:34:50,079 --> 00:34:52,240
find or if you forget the exact way to

910
00:34:52,240 --> 00:34:54,079
type the command in in gdb and you don't

911
00:34:54,079 --> 00:34:56,000
feel like googling it apropos

912
00:34:56,000 --> 00:34:58,000
will will uh often be able to find

913
00:34:58,000 --> 00:34:59,359
exactly what you're looking for in

914
00:34:59,359 --> 00:35:00,720
addition to a whole bunch of stuff you

915
00:35:00,720 --> 00:35:02,240
weren't looking for

916
00:35:02,240 --> 00:35:05,280
um yeah so

917
00:35:05,280 --> 00:35:06,800
that can be quite useful gdp is

918
00:35:06,800 --> 00:35:08,480
extremely well documented as well

919
00:35:08,480 --> 00:35:11,040
so um yeah if you ever find yourself

920
00:35:11,040 --> 00:35:12,079
lost

921
00:35:12,079 --> 00:35:16,720
you know google is your friend um

922
00:35:16,720 --> 00:35:18,720
so now that we we've kind of been over

923
00:35:18,720 --> 00:35:20,160
assembly and

924
00:35:20,160 --> 00:35:22,960
and risk five and these sort of things i

925
00:35:22,960 --> 00:35:24,480
want to dive a little bit more into the

926
00:35:24,480 --> 00:35:25,760
specifics

927
00:35:25,760 --> 00:35:28,480
um of what you you really need to know

928
00:35:28,480 --> 00:35:29,599
for the

929
00:35:29,599 --> 00:35:32,320
lab coming up and also is this will be a

930
00:35:32,320 --> 00:35:33,839
little bit of review from the document

931
00:35:33,839 --> 00:35:34,640
that you've all

932
00:35:34,640 --> 00:35:37,040
of course as diligent students read

933
00:35:37,040 --> 00:35:38,880
through thoroughly

934
00:35:38,880 --> 00:35:42,839
uh in preparation for this lecture

935
00:35:42,839 --> 00:35:45,680
um so you know this table will of course

936
00:35:45,680 --> 00:35:47,839
be uh wildly familiar to you all

937
00:35:47,839 --> 00:35:51,119
and uh from from both double o4

938
00:35:51,119 --> 00:35:53,119
and from what you've read and this is

939
00:35:53,119 --> 00:35:55,280
the table of registers and

940
00:35:55,280 --> 00:35:58,720
registers are little you know locations

941
00:35:58,720 --> 00:36:02,800
on the cpu or on the processor

942
00:36:02,800 --> 00:36:05,440
pre-defined that it can use to store

943
00:36:05,440 --> 00:36:06,400
values

944
00:36:06,400 --> 00:36:08,640
and this is important because assembly

945
00:36:08,640 --> 00:36:09,520
operations

946
00:36:09,520 --> 00:36:11,520
if we remember from the assembly code

947
00:36:11,520 --> 00:36:14,079
the assembly doesn't operate on memory

948
00:36:14,079 --> 00:36:16,079
it operates on registers so when we do

949
00:36:16,079 --> 00:36:17,520
add when we do subtract

950
00:36:17,520 --> 00:36:20,960
we're operating on registers um

951
00:36:20,960 --> 00:36:22,800
and so what you'll often see as the

952
00:36:22,800 --> 00:36:24,160
pattern for

953
00:36:24,160 --> 00:36:26,079
for writing assembly is we'll have some

954
00:36:26,079 --> 00:36:27,520
kind of a load

955
00:36:27,520 --> 00:36:30,960
so we'll load some value

956
00:36:30,960 --> 00:36:34,640
to a register and that value can be from

957
00:36:34,640 --> 00:36:35,119
memory

958
00:36:35,119 --> 00:36:38,320
or it can be from another uh register

959
00:36:38,320 --> 00:36:40,560
and and here i'm referring to load in

960
00:36:40,560 --> 00:36:42,320
general not the load instruction

961
00:36:42,320 --> 00:36:45,760
um and then we'll operate

962
00:36:45,760 --> 00:36:48,640
so we'll perform some operation on the

963
00:36:48,640 --> 00:36:49,359
register

964
00:36:49,359 --> 00:36:50,880
and then if we care about the result of

965
00:36:50,880 --> 00:36:52,560
that operation outside of the return

966
00:36:52,560 --> 00:36:53,359
address

967
00:36:53,359 --> 00:36:56,880
we will um will store that

968
00:36:56,880 --> 00:37:00,480
register to somewhere

969
00:37:00,480 --> 00:37:02,000
to some locate that will store that

970
00:37:02,000 --> 00:37:04,000
register to some location

971
00:37:04,000 --> 00:37:08,160
do that in memory or to another register

972
00:37:08,160 --> 00:37:09,760
and so that's that's uh generally the

973
00:37:09,760 --> 00:37:11,760
way things work and and registers are

974
00:37:11,760 --> 00:37:14,000
the absolute fastest way to perform

975
00:37:14,000 --> 00:37:16,560
any sort of calculation uh or to access

976
00:37:16,560 --> 00:37:18,320
any value and that's why

977
00:37:18,320 --> 00:37:21,040
um it's important to use them and also

978
00:37:21,040 --> 00:37:21,760
why

979
00:37:21,760 --> 00:37:24,160
we prefer using registers over using

980
00:37:24,160 --> 00:37:26,079
memory so if you remember from

981
00:37:26,079 --> 00:37:28,400
the reading when we call functions so

982
00:37:28,400 --> 00:37:30,160
you can see here that registers

983
00:37:30,160 --> 00:37:33,839
a0 to 7 and

984
00:37:33,839 --> 00:37:35,839
in general when we speak about registers

985
00:37:35,839 --> 00:37:37,040
we

986
00:37:37,040 --> 00:37:39,040
we will be referring to them by their

987
00:37:39,040 --> 00:37:41,280
abi name um

988
00:37:41,280 --> 00:37:43,200
not only is it less confusing it's just

989
00:37:43,200 --> 00:37:44,560
a standard and it's also the way that

990
00:37:44,560 --> 00:37:46,079
you'll write assembly code

991
00:37:46,079 --> 00:37:49,440
um this you know these actual numbers

992
00:37:49,440 --> 00:37:51,119
are not super important

993
00:37:51,119 --> 00:37:54,400
the only case where it does matter is

994
00:37:54,400 --> 00:37:57,280
for the compressed version of risk 5

995
00:37:57,280 --> 00:37:58,320
instructions

996
00:37:58,320 --> 00:38:01,040
and if you want to know more about that

997
00:38:01,040 --> 00:38:02,720
feel free to read up about it the basic

998
00:38:02,720 --> 00:38:04,000
idea is that risk

999
00:38:04,000 --> 00:38:07,200
5 normal instructions are 64 bits

1000
00:38:07,200 --> 00:38:08,880
but there's also a compressed version in

1001
00:38:08,880 --> 00:38:10,800
which instructions are 16 bits

1002
00:38:10,800 --> 00:38:12,800
and we use less registers and the

1003
00:38:12,800 --> 00:38:14,800
registers we use in that case

1004
00:38:14,800 --> 00:38:17,520
are 8 through 15. those are the

1005
00:38:17,520 --> 00:38:19,200
registers that are available to us

1006
00:38:19,200 --> 00:38:20,800
so i think somebody had a question about

1007
00:38:20,800 --> 00:38:23,440
you know why is this s1 register

1008
00:38:23,440 --> 00:38:26,640
x9 why is it separated from all of the

1009
00:38:26,640 --> 00:38:27,200
other s

1010
00:38:27,200 --> 00:38:29,680
registers and my guess is that that's

1011
00:38:29,680 --> 00:38:31,839
why

1012
00:38:31,839 --> 00:38:33,119
that we separated from all of the other

1013
00:38:33,119 --> 00:38:34,880
ones because it's available

1014
00:38:34,880 --> 00:38:37,760
in compressed instruction mode whereas

1015
00:38:37,760 --> 00:38:40,079
s2 to 11 or not

1016
00:38:40,079 --> 00:38:41,839
and so that's the idea so that's that's

1017
00:38:41,839 --> 00:38:43,599
for compressed but outside of that

1018
00:38:43,599 --> 00:38:46,480
registers will always be referred to by

1019
00:38:46,480 --> 00:38:47,200
their

1020
00:38:47,200 --> 00:38:50,079
abi name and so a0 to a7 are used for

1021
00:38:50,079 --> 00:38:51,280
function arguments

1022
00:38:51,280 --> 00:38:52,640
but if we have a function that takes

1023
00:38:52,640 --> 00:38:55,119
more than the eight arguments that those

1024
00:38:55,119 --> 00:38:57,520
registers give us access to

1025
00:38:57,520 --> 00:39:00,000
we do need to use memory but that's this

1026
00:39:00,000 --> 00:39:01,200
is kind of an illustration of the fact

1027
00:39:01,200 --> 00:39:02,720
that we don't want to use memory when we

1028
00:39:02,720 --> 00:39:04,320
can use registers

1029
00:39:04,320 --> 00:39:07,200
we only we only use a memory if we have

1030
00:39:07,200 --> 00:39:08,720
to

1031
00:39:08,720 --> 00:39:10,800
and this uh this column here the saver

1032
00:39:10,800 --> 00:39:12,079
column

1033
00:39:12,079 --> 00:39:14,079
this is also extremely important when

1034
00:39:14,079 --> 00:39:16,240
we're discussing registers caller versus

1035
00:39:16,240 --> 00:39:17,839
callee saved

1036
00:39:17,839 --> 00:39:21,280
and um the terms are

1037
00:39:21,280 --> 00:39:24,000
i confuse them regularly caller and

1038
00:39:24,000 --> 00:39:26,160
callie they only differ by one letter

1039
00:39:26,160 --> 00:39:29,200
the easiest way that i found to remember

1040
00:39:29,200 --> 00:39:30,480
them is that

1041
00:39:30,480 --> 00:39:34,400
caller saved registers are not

1042
00:39:34,400 --> 00:39:37,589
preserved

1043
00:39:37,599 --> 00:39:42,240
across a function call

1044
00:39:42,240 --> 00:39:46,800
so and callee saved registers

1045
00:39:46,800 --> 00:39:52,079
are preserved what i mean by this

1046
00:39:52,079 --> 00:39:55,190
is that

1047
00:39:55,200 --> 00:39:58,079
a caller saved register can be

1048
00:39:58,079 --> 00:39:59,200
overwritten

1049
00:39:59,200 --> 00:40:02,320
by the function so let's say i have

1050
00:40:02,320 --> 00:40:03,040
function a

1051
00:40:03,040 --> 00:40:05,599
which calls function b any registers

1052
00:40:05,599 --> 00:40:07,119
being used by function a

1053
00:40:07,119 --> 00:40:10,319
that are caller saved call function b

1054
00:40:10,319 --> 00:40:12,720
can overwrite when it gets called and i

1055
00:40:12,720 --> 00:40:14,560
think a good illustration of this

1056
00:40:14,560 --> 00:40:17,359
is the return address because you know

1057
00:40:17,359 --> 00:40:19,040
you can see that the return address is

1058
00:40:19,040 --> 00:40:21,119
caller saved

1059
00:40:21,119 --> 00:40:23,119
and that's important because every

1060
00:40:23,119 --> 00:40:25,760
function needs to use the return address

1061
00:40:25,760 --> 00:40:28,640
so when a calls b it's important that b

1062
00:40:28,640 --> 00:40:30,079
be able to

1063
00:40:30,079 --> 00:40:32,000
overwrite the value in the return

1064
00:40:32,000 --> 00:40:34,400
address hence why it's caller saved

1065
00:40:34,400 --> 00:40:37,760
and callee saved registers are just our

1066
00:40:37,760 --> 00:40:40,079
convention that we use

1067
00:40:40,079 --> 00:40:42,160
the frame pointer is important for that

1068
00:40:42,160 --> 00:40:44,079
reason

1069
00:40:44,079 --> 00:40:45,680
and those are preserved across the

1070
00:40:45,680 --> 00:40:47,440
function calls so basically any register

1071
00:40:47,440 --> 00:40:49,040
that is caller saved

1072
00:40:49,040 --> 00:40:50,480
the function that is making the call

1073
00:40:50,480 --> 00:40:52,560
needs to worry about those registers

1074
00:40:52,560 --> 00:40:54,079
and if they're calling saved the

1075
00:40:54,079 --> 00:40:55,839
function that is being called

1076
00:40:55,839 --> 00:40:57,359
needs to worry about preserving the

1077
00:40:57,359 --> 00:40:59,760
value in those registers

1078
00:40:59,760 --> 00:41:02,720
and again you know i i regularly confuse

1079
00:41:02,720 --> 00:41:03,280
the two

1080
00:41:03,280 --> 00:41:07,760
and find myself returning to this table

1081
00:41:07,760 --> 00:41:11,119
to remind myself about what they do

1082
00:41:11,119 --> 00:41:14,160
and so you know you if you remember from

1083
00:41:14,160 --> 00:41:14,880
the reading

1084
00:41:14,880 --> 00:41:18,160
all of these registers are 64 bits wide

1085
00:41:18,160 --> 00:41:19,359
so they have 64

1086
00:41:19,359 --> 00:41:22,560
places where we can put things and

1087
00:41:22,560 --> 00:41:24,960
the various data types are made to fit

1088
00:41:24,960 --> 00:41:27,200
into those 64 bits

1089
00:41:27,200 --> 00:41:28,960
based on the calling convention so if we

1090
00:41:28,960 --> 00:41:30,720
have a 32-bit integer

1091
00:41:30,720 --> 00:41:32,319
depending on how it's whether or not

1092
00:41:32,319 --> 00:41:34,240
it's sign extended you know we'll either

1093
00:41:34,240 --> 00:41:36,160
add zeros or ones to the front of that

1094
00:41:36,160 --> 00:41:37,119
integer

1095
00:41:37,119 --> 00:41:38,880
in order to make it 64 bits to put in

1096
00:41:38,880 --> 00:41:40,480
these registers

1097
00:41:40,480 --> 00:41:42,800
so before we move on uh does anybody

1098
00:41:42,800 --> 00:41:44,720
have questions about

1099
00:41:44,720 --> 00:41:47,520
registers or things things of that

1100
00:41:47,520 --> 00:41:58,069
nature

1101
00:41:58,079 --> 00:42:01,119
i have a question can you have a

1102
00:42:01,119 --> 00:42:05,359
can you put a return value in a1

1103
00:42:05,359 --> 00:42:08,560
yes it's a good question so um i think

1104
00:42:08,560 --> 00:42:09,440
in theory

1105
00:42:09,440 --> 00:42:14,560
you can the reason why we say a0 to a1

1106
00:42:14,560 --> 00:42:16,960
is if a function returns a long long

1107
00:42:16,960 --> 00:42:18,800
which is 128 bits

1108
00:42:18,800 --> 00:42:21,440
so if you remember from the reading if a

1109
00:42:21,440 --> 00:42:23,599
function argument is 100 is more than

1110
00:42:23,599 --> 00:42:26,079
a pointer word and so when we refer to

1111
00:42:26,079 --> 00:42:28,160
the prior word size we're saying 64 bits

1112
00:42:28,160 --> 00:42:29,760
so if we have something that is twice

1113
00:42:29,760 --> 00:42:32,319
the size of a pointer word

1114
00:42:32,319 --> 00:42:35,359
um we can put that in a register pair

1115
00:42:35,359 --> 00:42:37,520
and so the same convention holds true

1116
00:42:37,520 --> 00:42:39,280
for return addresses where if we have

1117
00:42:39,280 --> 00:42:40,160
something that's

1118
00:42:40,160 --> 00:42:42,800
the size of twice a pointer word we can

1119
00:42:42,800 --> 00:42:44,160
stick that in a0 and

1120
00:42:44,160 --> 00:42:46,400
a1 and use that as the return address i

1121
00:42:46,400 --> 00:42:47,839
think you'll run into problems if you

1122
00:42:47,839 --> 00:42:49,839
only try to put something in a1

1123
00:42:49,839 --> 00:42:55,829
make sense thanks

1124
00:42:55,839 --> 00:42:58,720
why are the registers not like

1125
00:42:58,720 --> 00:42:59,520
continuous

1126
00:42:59,520 --> 00:43:03,119
so why is like a zero and one separate

1127
00:43:03,119 --> 00:43:06,000
from sorry no that's a that's a bad

1128
00:43:06,000 --> 00:43:08,400
example what's why is s1

1129
00:43:08,400 --> 00:43:10,560
separate from s2 why are the a's in

1130
00:43:10,560 --> 00:43:13,119
between like is there any point in that

1131
00:43:13,119 --> 00:43:15,440
yeah so uh i mentioned this briefly

1132
00:43:15,440 --> 00:43:16,960
earlier but there is a

1133
00:43:16,960 --> 00:43:19,119
compressed this is a guess i don't i

1134
00:43:19,119 --> 00:43:20,319
don't know for sure

1135
00:43:20,319 --> 00:43:23,119
but there's a compressed version of the

1136
00:43:23,119 --> 00:43:23,920
risc 5

1137
00:43:23,920 --> 00:43:26,960
instructions which are 16 bits in size

1138
00:43:26,960 --> 00:43:28,960
as opposed to 64.

1139
00:43:28,960 --> 00:43:32,319
and you would use that to try and

1140
00:43:32,319 --> 00:43:34,480
make your code take less space in memory

1141
00:43:34,480 --> 00:43:36,720
and when you use those 16-bit

1142
00:43:36,720 --> 00:43:38,319
instructions you only have

1143
00:43:38,319 --> 00:43:42,079
accesses to registers 8 through 15.

1144
00:43:42,079 --> 00:43:46,000
so i think s1 is separate from s2 to 11

1145
00:43:46,000 --> 00:43:47,920
because they want to make it clear that

1146
00:43:47,920 --> 00:43:50,000
s1 is available to you

1147
00:43:50,000 --> 00:43:52,000
in the compressed instruction mode

1148
00:43:52,000 --> 00:43:54,560
whereas s2 to 11 aren't

1149
00:43:54,560 --> 00:43:56,800
um and the reason you know i don't know

1150
00:43:56,800 --> 00:43:58,480
why they picked x

1151
00:43:58,480 --> 00:44:01,680
x eight to 15 but i suspect that that's

1152
00:44:01,680 --> 00:44:03,040
just they looked at a bunch of code and

1153
00:44:03,040 --> 00:44:04,079
we're like oh these are the most

1154
00:44:04,079 --> 00:44:09,850
commonly used registers

1155
00:44:09,860 --> 00:44:17,109
[Music]

1156
00:44:17,119 --> 00:44:20,870
any other questions

1157
00:44:20,880 --> 00:44:24,880
i had a question um besides the frame

1158
00:44:24,880 --> 00:44:27,040
pointer the stack pointer and all

1159
00:44:27,040 --> 00:44:29,839
uh i i don't know why we would need more

1160
00:44:29,839 --> 00:44:30,560
call

1161
00:44:30,560 --> 00:44:33,599
callista registers but we do have

1162
00:44:33,599 --> 00:44:37,680
like a bunch of them yeah the s1s

1163
00:44:37,680 --> 00:44:40,560
to 11s those are just for i believe used

1164
00:44:40,560 --> 00:44:42,480
there for freedom for the compiler

1165
00:44:42,480 --> 00:44:45,359
or for the programmer to use um so there

1166
00:44:45,359 --> 00:44:46,800
are maybe there are certain cases where

1167
00:44:46,800 --> 00:44:47,520
you want

1168
00:44:47,520 --> 00:44:49,200
you want to guarantee that something is

1169
00:44:49,200 --> 00:44:50,960
still around

1170
00:44:50,960 --> 00:44:53,839
after after your function call the

1171
00:44:53,839 --> 00:44:55,839
compiler can choose to use

1172
00:44:55,839 --> 00:45:00,150
s1 211 to do that

1173
00:45:00,160 --> 00:45:02,720
i don't have like on hand a specific

1174
00:45:02,720 --> 00:45:04,720
example of where that's useful

1175
00:45:04,720 --> 00:45:07,920
but i'm sure it shows up where

1176
00:45:07,920 --> 00:45:14,309
having a callee save value is important

1177
00:45:14,319 --> 00:45:15,760
but these are basically basically you

1178
00:45:15,760 --> 00:45:17,440
know programmer or compiler's choice to

1179
00:45:17,440 --> 00:45:18,160
use

1180
00:45:18,160 --> 00:45:22,390
that's 1 to 11.

1181
00:45:22,400 --> 00:45:23,599
and i should note that these these

1182
00:45:23,599 --> 00:45:25,119
floating point registers they're for

1183
00:45:25,119 --> 00:45:27,040
floating point arithmetic

1184
00:45:27,040 --> 00:45:30,079
i as far as i'm aware you won't see them

1185
00:45:30,079 --> 00:45:31,680
in this class

1186
00:45:31,680 --> 00:45:33,359
and so you don't really need to worry

1187
00:45:33,359 --> 00:45:38,550
about them

1188
00:45:38,560 --> 00:45:41,839
okay so we started talking a little bit

1189
00:45:41,839 --> 00:45:45,440
about function calls

1190
00:45:45,440 --> 00:45:48,640
and so with that i want to

1191
00:45:48,640 --> 00:45:54,400
move us into discussion of the stack

1192
00:45:54,400 --> 00:45:57,839
so this is this is

1193
00:45:57,839 --> 00:46:01,040
we're talking about the stack and

1194
00:46:01,040 --> 00:46:03,920
the stack if you've seen it likely

1195
00:46:03,920 --> 00:46:04,560
before

1196
00:46:04,560 --> 00:46:07,440
the reason why the stack is important is

1197
00:46:07,440 --> 00:46:07,760
it

1198
00:46:07,760 --> 00:46:11,280
it's what keeps our functions

1199
00:46:11,280 --> 00:46:14,640
organized and sane and it's what allows

1200
00:46:14,640 --> 00:46:16,560
and what makes functions work it what

1201
00:46:16,560 --> 00:46:18,000
it's what makes return

1202
00:46:18,000 --> 00:46:21,040
work and it's also uh where often we'll

1203
00:46:21,040 --> 00:46:22,000
find ourselves

1204
00:46:22,000 --> 00:46:24,800
saving our registers and things like

1205
00:46:24,800 --> 00:46:26,839
that

1206
00:46:26,839 --> 00:46:29,440
um

1207
00:46:29,440 --> 00:46:32,720
so here i've

1208
00:46:32,720 --> 00:46:35,720
given just a pretty simple um

1209
00:46:35,720 --> 00:46:36,960
[Music]

1210
00:46:36,960 --> 00:46:39,839
layout of what a stack looks like and so

1211
00:46:39,839 --> 00:46:41,440
each of these

1212
00:46:41,440 --> 00:46:44,800
boxes here is what we refer to

1213
00:46:44,800 --> 00:46:49,040
as a stack frame

1214
00:46:49,040 --> 00:46:52,400
and every time we get

1215
00:46:52,400 --> 00:46:59,910
which are generated by function calls

1216
00:46:59,920 --> 00:47:03,280
um every time we call a function

1217
00:47:03,280 --> 00:47:06,319
that function makes for itself its own

1218
00:47:06,319 --> 00:47:07,680
stack frame

1219
00:47:07,680 --> 00:47:11,040
and which is in which it uses itself and

1220
00:47:11,040 --> 00:47:13,760
does that by moving around the stack

1221
00:47:13,760 --> 00:47:14,480
pointer

1222
00:47:14,480 --> 00:47:17,200
so here's the stack pointer and this is

1223
00:47:17,200 --> 00:47:17,839
uh

1224
00:47:17,839 --> 00:47:20,160
and it's very important to remember with

1225
00:47:20,160 --> 00:47:21,760
stacks

1226
00:47:21,760 --> 00:47:24,800
we start from high addresses

1227
00:47:24,800 --> 00:47:28,160
and we grow downwards to

1228
00:47:28,160 --> 00:47:30,720
low addresses so the stack grows down

1229
00:47:30,720 --> 00:47:32,160
always

1230
00:47:32,160 --> 00:47:34,400
and so you'll see that the arithmetic

1231
00:47:34,400 --> 00:47:36,240
for a stack pointer is uh

1232
00:47:36,240 --> 00:47:38,480
is usually done via subtraction when we

1233
00:47:38,480 --> 00:47:40,240
want to make a new stack frame

1234
00:47:40,240 --> 00:47:43,280
in assembly so the stack grows downwards

1235
00:47:43,280 --> 00:47:46,240
and stack frames for a function contain

1236
00:47:46,240 --> 00:47:48,960
saved registers local variables

1237
00:47:48,960 --> 00:47:51,520
um also like i like i was saying if you

1238
00:47:51,520 --> 00:47:52,000
run out

1239
00:47:52,000 --> 00:47:54,640
of argument registers additional

1240
00:47:54,640 --> 00:47:56,319
arguments will show up on the stack

1241
00:47:56,319 --> 00:47:58,160
and so not at stack frames are not all

1242
00:47:58,160 --> 00:47:59,440
the same size

1243
00:47:59,440 --> 00:48:00,800
even though they are in this diagram

1244
00:48:00,800 --> 00:48:02,640
that's not the case different functions

1245
00:48:02,640 --> 00:48:04,000
have different numbers of local

1246
00:48:04,000 --> 00:48:06,640
variables different safe registers

1247
00:48:06,640 --> 00:48:08,800
so on and so forth and so stack frames

1248
00:48:08,800 --> 00:48:10,480
will be different sizes but the two

1249
00:48:10,480 --> 00:48:12,800
things that you can definitely count on

1250
00:48:12,800 --> 00:48:14,960
which are important is that uh the

1251
00:48:14,960 --> 00:48:16,480
return address will always be

1252
00:48:16,480 --> 00:48:19,280
on the first thing and the frame pointer

1253
00:48:19,280 --> 00:48:21,119
the previous frames frame pointer is

1254
00:48:21,119 --> 00:48:23,200
also going to show up on the stack

1255
00:48:23,200 --> 00:48:26,640
at a predictable location so

1256
00:48:26,640 --> 00:48:29,280
the two important registers here are sp

1257
00:48:29,280 --> 00:48:30,720
which you know as we discussed

1258
00:48:30,720 --> 00:48:33,359
is used for this is the bottom of the

1259
00:48:33,359 --> 00:48:35,680
stack

1260
00:48:35,680 --> 00:48:38,240
or generally you know it's the location

1261
00:48:38,240 --> 00:48:39,280
of the stack

1262
00:48:39,280 --> 00:48:43,280
and then fp is our also important

1263
00:48:43,280 --> 00:48:46,319
register and this points to the top of

1264
00:48:46,319 --> 00:48:48,880
the current

1265
00:48:48,880 --> 00:48:52,480
frame and this is important because

1266
00:48:52,480 --> 00:48:54,800
that means that the return address and

1267
00:48:54,800 --> 00:48:56,240
the previous fp

1268
00:48:56,240 --> 00:48:59,599
will always be at a fixed location

1269
00:48:59,599 --> 00:49:02,720
from the current frame pointer so that

1270
00:49:02,720 --> 00:49:03,839
means that

1271
00:49:03,839 --> 00:49:06,000
if i want to find my return address or i

1272
00:49:06,000 --> 00:49:07,839
want to find the previous frame

1273
00:49:07,839 --> 00:49:10,640
i can always get to those values by

1274
00:49:10,640 --> 00:49:13,599
looking at the current frame pointer

1275
00:49:13,599 --> 00:49:15,520
and the reason why we store the previous

1276
00:49:15,520 --> 00:49:17,760
frame pointer is to allow us

1277
00:49:17,760 --> 00:49:19,760
to jump back so once this function

1278
00:49:19,760 --> 00:49:22,720
returns we can move this into fp

1279
00:49:22,720 --> 00:49:25,359
and all of a sudden fp again will go

1280
00:49:25,359 --> 00:49:26,559
from pointing to this

1281
00:49:26,559 --> 00:49:29,359
this stack frame to now pointing to this

1282
00:49:29,359 --> 00:49:30,319
stack frame

1283
00:49:30,319 --> 00:49:32,160
and so we use the frame pointer to

1284
00:49:32,160 --> 00:49:34,079
manipulate our stack frames

1285
00:49:34,079 --> 00:49:35,520
and make sure we're always pointing to

1286
00:49:35,520 --> 00:49:37,280
the one corresponding

1287
00:49:37,280 --> 00:49:40,960
to the correct function

1288
00:49:40,960 --> 00:49:42,880
and that's that's kind of how things uh

1289
00:49:42,880 --> 00:49:44,160
how things are done

1290
00:49:44,160 --> 00:49:47,839
and uh the these pieces of the stack

1291
00:49:47,839 --> 00:49:50,880
um need to be created by assembly

1292
00:49:50,880 --> 00:49:52,720
and so everything's everything in that

1293
00:49:52,720 --> 00:49:54,319
calling conventions

1294
00:49:54,319 --> 00:49:57,200
document that you read about that's all

1295
00:49:57,200 --> 00:49:59,359
um enforced by

1296
00:49:59,359 --> 00:50:01,040
effectively by the compiler so the

1297
00:50:01,040 --> 00:50:03,040
compiler adheres to

1298
00:50:03,040 --> 00:50:05,599
the calling convention and it's what

1299
00:50:05,599 --> 00:50:06,960
generates the stack frame

1300
00:50:06,960 --> 00:50:08,960
it generates the assembly code that

1301
00:50:08,960 --> 00:50:10,400
makes our stack frames look

1302
00:50:10,400 --> 00:50:13,200
correct so often at the top of a

1303
00:50:13,200 --> 00:50:15,280
function you'll see what's called

1304
00:50:15,280 --> 00:50:21,270
a function prolog

1305
00:50:21,280 --> 00:50:23,280
and then there will be the body of the

1306
00:50:23,280 --> 00:50:24,400
function

1307
00:50:24,400 --> 00:50:27,599
and then there will be an epilogue

1308
00:50:27,599 --> 00:50:30,240
that shows up after that so this is kind

1309
00:50:30,240 --> 00:50:31,920
of like

1310
00:50:31,920 --> 00:50:35,280
what an assembly uh

1311
00:50:35,280 --> 00:50:37,760
function will often look like and we'll

1312
00:50:37,760 --> 00:50:39,760
take a look at that

1313
00:50:39,760 --> 00:50:43,200
now so here i have another function

1314
00:50:43,200 --> 00:50:45,680
something so you you'll you'll note that

1315
00:50:45,680 --> 00:50:48,160
studently that sum2 did not have

1316
00:50:48,160 --> 00:50:50,559
any of these things that it it should if

1317
00:50:50,559 --> 00:50:52,079
it was a proper function

1318
00:50:52,079 --> 00:50:53,760
and this works fine because it's simple

1319
00:50:53,760 --> 00:50:55,200
enough so it does all of its

1320
00:50:55,200 --> 00:50:56,400
computations on

1321
00:50:56,400 --> 00:50:59,119
a0 and so things are things are good and

1322
00:50:59,119 --> 00:51:00,800
we're also not it's a it's a leaf

1323
00:51:00,800 --> 00:51:01,599
function

1324
00:51:01,599 --> 00:51:03,920
so you'll see if you see the term leaf

1325
00:51:03,920 --> 00:51:05,280
function that's a function that doesn't

1326
00:51:05,280 --> 00:51:06,960
call another function

1327
00:51:06,960 --> 00:51:08,880
and the functions are special in that

1328
00:51:08,880 --> 00:51:11,119
they don't need to

1329
00:51:11,119 --> 00:51:14,240
worry about saving their own return

1330
00:51:14,240 --> 00:51:15,040
address

1331
00:51:15,040 --> 00:51:17,440
or saving really any of the caller saved

1332
00:51:17,440 --> 00:51:18,720
registers

1333
00:51:18,720 --> 00:51:21,760
because they're going to they're not

1334
00:51:21,760 --> 00:51:23,200
going to make another function call so

1335
00:51:23,200 --> 00:51:24,319
they don't have to be

1336
00:51:24,319 --> 00:51:27,119
as careful some then double on the other

1337
00:51:27,119 --> 00:51:27,680
hand

1338
00:51:27,680 --> 00:51:29,839
is not a leaf function so you can see

1339
00:51:29,839 --> 00:51:31,440
here it calls

1340
00:51:31,440 --> 00:51:35,760
um sum2 and so it does need to include

1341
00:51:35,760 --> 00:51:36,480
that

1342
00:51:36,480 --> 00:51:39,200
that prolog and so we see here that we

1343
00:51:39,200 --> 00:51:40,160
are subtracting

1344
00:51:40,160 --> 00:51:42,880
16 from the stack pointer so we're

1345
00:51:42,880 --> 00:51:43,839
making space

1346
00:51:43,839 --> 00:51:46,559
on our stack we're storing the return

1347
00:51:46,559 --> 00:51:47,200
address

1348
00:51:47,200 --> 00:51:50,160
for something double on the stack and

1349
00:51:50,160 --> 00:51:52,319
then we make our call to sum2

1350
00:51:52,319 --> 00:51:53,839
and after that all this this function

1351
00:51:53,839 --> 00:51:55,599
does is it calls sum2 and then

1352
00:51:55,599 --> 00:51:59,119
doubles the result doubles the result

1353
00:51:59,119 --> 00:52:01,839
turned by some two and here you can see

1354
00:52:01,839 --> 00:52:02,400
the

1355
00:52:02,400 --> 00:52:05,920
epilog so we load the return address

1356
00:52:05,920 --> 00:52:08,960
back in to ra and

1357
00:52:08,960 --> 00:52:11,599
delete our stack frame and then jump out

1358
00:52:11,599 --> 00:52:13,760
of the function

1359
00:52:13,760 --> 00:52:16,160
and so we can run that to make sure it

1360
00:52:16,160 --> 00:52:20,630
does what we would expect

1361
00:52:20,640 --> 00:52:24,230
we can go here

1362
00:52:24,240 --> 00:52:27,599
we can run so if we run demo2 or demo

1363
00:52:27,599 --> 00:52:29,520
one we got a result of 15

1364
00:52:29,520 --> 00:52:31,200
for the sum and i'll tell you that demo

1365
00:52:31,200 --> 00:52:33,599
two just uh just calls something double

1366
00:52:33,599 --> 00:52:34,640
and indeed

1367
00:52:34,640 --> 00:52:38,000
you know it happily doubles the sum

1368
00:52:38,000 --> 00:52:41,200
returned by some two and

1369
00:52:41,200 --> 00:52:45,359
so a question i have for for anybody

1370
00:52:45,359 --> 00:52:48,480
what happens if we uh delete

1371
00:52:48,480 --> 00:52:52,240
this prologue and f so what happens

1372
00:52:52,240 --> 00:52:55,040
if we just have this as our function

1373
00:52:55,040 --> 00:52:56,559
something double can anybody predict

1374
00:52:56,559 --> 00:53:01,520
what's going to happen

1375
00:53:01,520 --> 00:53:03,119
i mean one thing is that some then

1376
00:53:03,119 --> 00:53:05,119
double wouldn't know

1377
00:53:05,119 --> 00:53:07,280
the return address that it should return

1378
00:53:07,280 --> 00:53:09,119
to so upon calling

1379
00:53:09,119 --> 00:53:12,000
sum to that's going to override the

1380
00:53:12,000 --> 00:53:13,280
return address to be

1381
00:53:13,280 --> 00:53:15,680
some then double so at the end of thumb

1382
00:53:15,680 --> 00:53:16,319
then double

1383
00:53:16,319 --> 00:53:18,000
it's not going to return to its original

1384
00:53:18,000 --> 00:53:19,440
call

1385
00:53:19,440 --> 00:53:22,319
yeah exactly um and we can see that

1386
00:53:22,319 --> 00:53:24,000
that's what happens

1387
00:53:24,000 --> 00:53:27,040
again so if we

1388
00:53:27,040 --> 00:53:31,119
exit out of this and we exit out of this

1389
00:53:31,119 --> 00:53:33,200
and we recompile with now with our

1390
00:53:33,200 --> 00:53:35,599
broken function

1391
00:53:35,599 --> 00:53:37,200
we can take a look at exactly what's

1392
00:53:37,200 --> 00:53:39,359
going to happen so we can actually

1393
00:53:39,359 --> 00:53:45,270
set our breakpoint for something double

1394
00:53:45,280 --> 00:53:49,440
and set up tui and let it continue so if

1395
00:53:49,440 --> 00:53:50,880
we now run demo 2

1396
00:53:50,880 --> 00:53:54,240
okay we're at some then double and

1397
00:53:54,240 --> 00:53:56,319
again this is an assembly only function

1398
00:53:56,319 --> 00:53:58,640
so we're going to want to look at it in

1399
00:53:58,640 --> 00:54:02,640
assembly so we'll do layout asm layout

1400
00:54:02,640 --> 00:54:04,400
reg because it's important what's in the

1401
00:54:04,400 --> 00:54:06,559
registers in this case

1402
00:54:06,559 --> 00:54:08,240
and you'll see that gdb knows a whole

1403
00:54:08,240 --> 00:54:10,000
bunch of extra information

1404
00:54:10,000 --> 00:54:14,710
and so we can see that

1405
00:54:14,720 --> 00:54:16,720
we can see that ra currently so the

1406
00:54:16,720 --> 00:54:19,440
return address currently points to demo2

1407
00:54:19,440 --> 00:54:22,480
the plus 18 so

1408
00:54:22,480 --> 00:54:24,240
it points effectively into the function

1409
00:54:24,240 --> 00:54:26,160
demo2

1410
00:54:26,160 --> 00:54:29,680
and now we can run um we can just kind

1411
00:54:29,680 --> 00:54:31,440
of step through our function and see

1412
00:54:31,440 --> 00:54:35,760
what happens so we've called sum2

1413
00:54:35,760 --> 00:54:37,359
and immediately we can see that the

1414
00:54:37,359 --> 00:54:39,280
return address was

1415
00:54:39,280 --> 00:54:42,000
overwritten by sum 2 to now point to sum

1416
00:54:42,000 --> 00:54:43,359
then double plus 4

1417
00:54:43,359 --> 00:54:44,640
which makes sense you know that's what

1418
00:54:44,640 --> 00:54:46,960
we'd expect if we go back into our code

1419
00:54:46,960 --> 00:54:48,319
we call sum 2

1420
00:54:48,319 --> 00:54:52,720
and so sum2 should return to uh to here

1421
00:54:52,720 --> 00:54:54,670
and now we can step through

1422
00:54:54,670 --> 00:54:55,920
[Music]

1423
00:54:55,920 --> 00:54:59,280
you know so on up and uh

1424
00:54:59,280 --> 00:55:05,349
then we get back into

1425
00:55:05,359 --> 00:55:14,470
whoops the wrong s

1426
00:55:14,480 --> 00:55:16,400
okay so now we're here and now when sum

1427
00:55:16,400 --> 00:55:18,000
then double returns

1428
00:55:18,000 --> 00:55:21,119
as exactly as amir pointed out um its

1429
00:55:21,119 --> 00:55:23,040
return it has not restored its own

1430
00:55:23,040 --> 00:55:24,240
return address

1431
00:55:24,240 --> 00:55:26,079
and instead its return address is still

1432
00:55:26,079 --> 00:55:28,000
the one that was used by

1433
00:55:28,000 --> 00:55:31,760
um sum two and so we will

1434
00:55:31,760 --> 00:55:34,880
get into an infinite loop where we just

1435
00:55:34,880 --> 00:55:37,280
keep doing this over and over and over

1436
00:55:37,280 --> 00:55:39,839
again and we'll never terminate from it

1437
00:55:39,839 --> 00:55:42,079
and so this is a i think this is a good

1438
00:55:42,079 --> 00:55:44,000
illustration of why it's important to

1439
00:55:44,000 --> 00:55:46,240
keep track of our caller versus callee

1440
00:55:46,240 --> 00:55:47,760
saved registers

1441
00:55:47,760 --> 00:55:49,200
and hopefully this also shows that you

1442
00:55:49,200 --> 00:55:51,760
can use kind of gdb to

1443
00:55:51,760 --> 00:55:54,720
debug these sorts of these sorts of

1444
00:55:54,720 --> 00:55:55,920
problems so let's

1445
00:55:55,920 --> 00:55:59,040
restore what we had and we'll go

1446
00:55:59,040 --> 00:56:04,240
into some other demos to talk about

1447
00:56:04,240 --> 00:56:07,280
to illustrate uh somebody asked why are

1448
00:56:07,280 --> 00:56:08,880
we subtracting 16

1449
00:56:08,880 --> 00:56:11,280
that's to put space to get our stack

1450
00:56:11,280 --> 00:56:12,079
frame

1451
00:56:12,079 --> 00:56:15,359
so this is subtracting 16 from the stack

1452
00:56:15,359 --> 00:56:17,359
pointer so it's moving it down basically

1453
00:56:17,359 --> 00:56:18,480
in memory

1454
00:56:18,480 --> 00:56:21,119
um moving it down so that we now have

1455
00:56:21,119 --> 00:56:22,720
space for our own stack frame and then

1456
00:56:22,720 --> 00:56:24,240
we can stick stuff there

1457
00:56:24,240 --> 00:56:27,040
so because uh at this point in fact we

1458
00:56:27,040 --> 00:56:28,400
don't want to override what's at the

1459
00:56:28,400 --> 00:56:30,319
stack pointer uh

1460
00:56:30,319 --> 00:56:33,760
why not four is just um

1461
00:56:33,760 --> 00:56:36,789
well four

1462
00:56:36,799 --> 00:56:39,040
we need to do 16 because instructions

1463
00:56:39,040 --> 00:56:42,829
are 64.

1464
00:56:42,839 --> 00:56:45,520
uh yeah i guess i guess we wouldn't

1465
00:56:45,520 --> 00:56:48,799
don't actually need to do 16 but that's

1466
00:56:48,799 --> 00:56:51,040
generally what you'll see

1467
00:56:51,040 --> 00:56:52,960
um you'll generally just see i don't

1468
00:56:52,960 --> 00:56:54,400
think yeah

1469
00:56:54,400 --> 00:56:56,480
you you can't you can't do four because

1470
00:56:56,480 --> 00:56:58,720
uh you need eight so four doesn't work

1471
00:56:58,720 --> 00:56:59,599
but i think you can do

1472
00:56:59,599 --> 00:57:03,200
uh you need the instruction size

1473
00:57:03,200 --> 00:57:04,640
and the size of the register right so

1474
00:57:04,640 --> 00:57:06,240
registers are 64.

1475
00:57:06,240 --> 00:57:08,079
yeah and then so the convention why you

1476
00:57:08,079 --> 00:57:10,160
usually see 16 is because if we jump

1477
00:57:10,160 --> 00:57:11,440
back to our document

1478
00:57:11,440 --> 00:57:13,359
usually we have the return address and

1479
00:57:13,359 --> 00:57:14,559
the frame pointer

1480
00:57:14,559 --> 00:57:17,359
uh but we're not doing that here because

1481
00:57:17,359 --> 00:57:19,040
we're being uh

1482
00:57:19,040 --> 00:57:22,160
not super careful with our assembly

1483
00:57:22,160 --> 00:57:25,440
so normally if we if we look in

1484
00:57:25,440 --> 00:57:27,520
i'm sure if we look in kernel.asm we'll

1485
00:57:27,520 --> 00:57:28,960
see

1486
00:57:28,960 --> 00:57:32,000
yeah so if we look in kernel. we see

1487
00:57:32,000 --> 00:57:33,680
it's also you know 16 this is generally

1488
00:57:33,680 --> 00:57:37,990
what you'll see with the compiler

1489
00:57:38,000 --> 00:57:41,200
um okay so

1490
00:57:41,200 --> 00:57:46,789
now we can go back to this

1491
00:57:46,799 --> 00:57:49,280
fixed our function and now we can look

1492
00:57:49,280 --> 00:57:52,829
at some c

1493
00:57:52,839 --> 00:57:54,559
code

1494
00:57:54,559 --> 00:57:57,760
all right so here we have demo four

1495
00:57:57,760 --> 00:58:01,359
which is just basically um a copy of a

1496
00:58:01,359 --> 00:58:02,160
main function

1497
00:58:02,160 --> 00:58:05,520
like a imitation of the main function

1498
00:58:05,520 --> 00:58:08,960
so we have our args

1499
00:58:08,960 --> 00:58:11,680
which is an array of strings and we have

1500
00:58:11,680 --> 00:58:13,440
dummy main which takes

1501
00:58:13,440 --> 00:58:15,680
uh the number of arguments and the

1502
00:58:15,680 --> 00:58:16,799
arguments frame

1503
00:58:16,799 --> 00:58:20,079
and just prints it out um for us

1504
00:58:20,079 --> 00:58:21,680
and so that's all that's that's all

1505
00:58:21,680 --> 00:58:23,200
that's happening here it's pretty

1506
00:58:23,200 --> 00:58:24,640
straightforward

1507
00:58:24,640 --> 00:58:27,920
uh if we set a breakpoint in

1508
00:58:27,920 --> 00:58:31,190
dummy main

1509
00:58:31,200 --> 00:58:35,520
and we pop over let this

1510
00:58:35,520 --> 00:58:38,640
okay we let this continue and we we

1511
00:58:38,640 --> 00:58:39,359
start this

1512
00:58:39,359 --> 00:58:42,079
we run down four okay so we now we've

1513
00:58:42,079 --> 00:58:42,880
hit

1514
00:58:42,880 --> 00:58:46,240
um dummy main and there's a couple of uh

1515
00:58:46,240 --> 00:58:51,440
important things to uh remember about

1516
00:58:51,440 --> 00:58:53,680
uh that you can use gdp for regarding

1517
00:58:53,680 --> 00:58:54,559
stack frames

1518
00:58:54,559 --> 00:58:58,240
so if we type i so again that's info

1519
00:58:58,240 --> 00:59:00,559
if we type iframe we can see a whole

1520
00:59:00,559 --> 00:59:01,520
bunch of uh

1521
00:59:01,520 --> 00:59:03,839
useful information about the current

1522
00:59:03,839 --> 00:59:04,799
stack frame

1523
00:59:04,799 --> 00:59:06,720
so we can see we're at stack level zero

1524
00:59:06,720 --> 00:59:08,079
level zero means

1525
00:59:08,079 --> 00:59:10,480
it's uh earth is down in the call stack

1526
00:59:10,480 --> 00:59:12,000
that we can go

1527
00:59:12,000 --> 00:59:15,599
and the frame is at this address

1528
00:59:15,599 --> 00:59:18,000
the program counter which is okay that's

1529
00:59:18,000 --> 00:59:19,200
all well and good

1530
00:59:19,200 --> 00:59:22,079
we have a save program counter as well

1531
00:59:22,079 --> 00:59:22,720
and if we

1532
00:59:22,720 --> 00:59:25,359
again if we take this address and we

1533
00:59:25,359 --> 00:59:26,000
jump

1534
00:59:26,000 --> 00:59:28,330
into kernel.asm

1535
00:59:28,330 --> 00:59:29,680
[Music]

1536
00:59:29,680 --> 00:59:32,000
and we search for that address we can

1537
00:59:32,000 --> 00:59:33,200
indeed see

1538
00:59:33,200 --> 00:59:38,400
that that address is inside of

1539
00:59:38,400 --> 00:59:40,799
inside of demo form which is exactly

1540
00:59:40,799 --> 00:59:42,240
where we expect

1541
00:59:42,240 --> 00:59:45,760
the program to return to and it was

1542
00:59:45,760 --> 00:59:48,640
called by a frame at this address source

1543
00:59:48,640 --> 00:59:49,520
language c

1544
00:59:49,520 --> 00:59:51,839
you know that's that's nice to know and

1545
00:59:51,839 --> 00:59:53,680
then we have the argument list

1546
00:59:53,680 --> 00:59:57,040
also starts at this address of course

1547
00:59:57,040 --> 00:59:59,119
in this case we have most of our

1548
00:59:59,119 --> 01:00:00,240
arguments in

1549
01:00:00,240 --> 01:00:03,119
registers uh and then we can even see

1550
01:00:03,119 --> 01:00:03,440
what

1551
01:00:03,440 --> 01:00:06,880
args are we mean rxc is three

1552
01:00:06,880 --> 01:00:10,400
and rv is this address

1553
01:00:10,400 --> 01:00:13,520
and if we want to more in depth examine

1554
01:00:13,520 --> 01:00:15,680
things we can look at things like

1555
01:00:15,680 --> 01:00:19,119
info arcs which will tell us information

1556
01:00:19,119 --> 01:00:21,359
about the arguments of the function

1557
01:00:21,359 --> 01:00:25,200
we can look at but more importantly

1558
01:00:25,200 --> 01:00:28,559
we can type if we type back trace or bt

1559
01:00:28,559 --> 01:00:30,079
works as well

1560
01:00:30,079 --> 01:00:34,000
we get a full back trace of all of the

1561
01:00:34,000 --> 01:00:37,040
stacks uh the all of the stack frames

1562
01:00:37,040 --> 01:00:38,960
from the call stack so you can see you

1563
01:00:38,960 --> 01:00:40,240
know something questionable happened

1564
01:00:40,240 --> 01:00:42,000
here that's when we invoked a system

1565
01:00:42,000 --> 01:00:44,880
call um then we get to the user track

1566
01:00:44,880 --> 01:00:45,599
function

1567
01:00:45,599 --> 01:00:48,000
then to the syscall function then to

1568
01:00:48,000 --> 01:00:49,280
sysdemo

1569
01:00:49,280 --> 01:00:52,480
then to demo four and then finally to

1570
01:00:52,480 --> 01:00:54,160
dummy main

1571
01:00:54,160 --> 01:00:56,079
and if we want to investigate any of

1572
01:00:56,079 --> 01:00:57,359
these stack frames

1573
01:00:57,359 --> 01:01:00,240
more in depth we can do frame and then

1574
01:01:00,240 --> 01:01:01,599
whatever number

1575
01:01:01,599 --> 01:01:03,760
uh is along the side here so let's say i

1576
01:01:03,760 --> 01:01:05,839
want to look at what was my stack frame

1577
01:01:05,839 --> 01:01:07,680
when six calls are called i can go to

1578
01:01:07,680 --> 01:01:10,000
frame three and so now i'm

1579
01:01:10,000 --> 01:01:11,920
inside of gdb i'm looking at that stack

1580
01:01:11,920 --> 01:01:13,839
frame so if i type info frame

1581
01:01:13,839 --> 01:01:16,559
i can get this and here we get a lot

1582
01:01:16,559 --> 01:01:17,119
more

1583
01:01:17,119 --> 01:01:19,119
a lot more information we have a bunch

1584
01:01:19,119 --> 01:01:22,400
of saved registers

1585
01:01:22,400 --> 01:01:25,280
we have some local variables we don't

1586
01:01:25,280 --> 01:01:27,520
have any arguments to this function

1587
01:01:27,520 --> 01:01:29,280
we can see where the program counter

1588
01:01:29,280 --> 01:01:31,200
where we're supposed to jump back to

1589
01:01:31,200 --> 01:01:32,960
um all kinds of things like that so this

1590
01:01:32,960 --> 01:01:34,640
is super super useful for

1591
01:01:34,640 --> 01:01:36,160
if you're debugging things and in fact

1592
01:01:36,160 --> 01:01:38,559
it's so useful we make you implement

1593
01:01:38,559 --> 01:01:41,599
um your own version not nowhere near and

1594
01:01:41,599 --> 01:01:41,839
as

1595
01:01:41,839 --> 01:01:44,960
in depth as what udb tells you but we're

1596
01:01:44,960 --> 01:01:46,720
one of the exercises on the next lab

1597
01:01:46,720 --> 01:01:48,640
will be to implement your own

1598
01:01:48,640 --> 01:01:51,200
backtrace helper function for use when

1599
01:01:51,200 --> 01:01:54,000
debugging things inside the lab

1600
01:01:54,000 --> 01:01:56,079
and so back back traces uh is quite

1601
01:01:56,079 --> 01:01:58,319
useful and then if we type frame 0 or we

1602
01:01:58,319 --> 01:01:59,359
go back to

1603
01:01:59,359 --> 01:02:02,880
where we were supposed to be

1604
01:02:02,880 --> 01:02:04,720
and if we want to investigate you

1605
01:02:04,720 --> 01:02:06,720
probably noticed it's not super helpful

1606
01:02:06,720 --> 01:02:09,280
you know rv is a string

1607
01:02:09,280 --> 01:02:11,039
as an array of strings and so we just

1608
01:02:11,039 --> 01:02:12,799
get a ref we just get a

1609
01:02:12,799 --> 01:02:15,039
an address for where that's actually

1610
01:02:15,039 --> 01:02:15,920
stored

1611
01:02:15,920 --> 01:02:17,359
and if we want to look at what's in

1612
01:02:17,359 --> 01:02:18,559
there there's a couple ways of doing

1613
01:02:18,559 --> 01:02:19,200
this

1614
01:02:19,200 --> 01:02:22,720
uh the easiest is uh if we type print p

1615
01:02:22,720 --> 01:02:26,160
is for print and then if we d

1616
01:02:26,160 --> 01:02:28,480
uh dereference the address so we go look

1617
01:02:28,480 --> 01:02:29,280
at what's at the

1618
01:02:29,280 --> 01:02:32,319
address we can do that and

1619
01:02:32,319 --> 01:02:35,119
you know as you would expect we get the

1620
01:02:35,119 --> 01:02:37,520
first element of that array because

1621
01:02:37,520 --> 01:02:39,760
when it tries to print a string it'll go

1622
01:02:39,760 --> 01:02:41,440
you know as c says it'll go in until it

1623
01:02:41,440 --> 01:02:43,039
hits the null character

1624
01:02:43,039 --> 01:02:44,720
so we get foo which is the first element

1625
01:02:44,720 --> 01:02:46,160
that array and if we want to get more

1626
01:02:46,160 --> 01:02:47,039
things

1627
01:02:47,039 --> 01:02:50,400
we can put in the length so if we do

1628
01:02:50,400 --> 01:02:51,680
and then a number it'll go up to a

1629
01:02:51,680 --> 01:02:53,839
certain index so then we can see

1630
01:02:53,839 --> 01:02:57,119
both of the strings here and

1631
01:02:57,119 --> 01:02:59,520
you know again gdb is quite smart so we

1632
01:02:59,520 --> 01:03:01,359
can even

1633
01:03:01,359 --> 01:03:03,839
use rxe to print out the whole argument

1634
01:03:03,839 --> 01:03:05,520
array

1635
01:03:05,520 --> 01:03:07,760
and so all of that information is

1636
01:03:07,760 --> 01:03:10,400
available to you

1637
01:03:10,400 --> 01:03:12,720
however you you want to get it so gdp is

1638
01:03:12,720 --> 01:03:14,799
a super powerful tool

1639
01:03:14,799 --> 01:03:17,200
why does gdb or sorry why does the

1640
01:03:17,200 --> 01:03:18,319
compiler sometimes

1641
01:03:18,319 --> 01:03:21,440
optimize out rg c

1642
01:03:21,440 --> 01:03:24,319
and rgb that has happened to be before

1643
01:03:24,319 --> 01:03:25,680
yeah uh that just means that the

1644
01:03:25,680 --> 01:03:28,160
compiler found a more efficient way

1645
01:03:28,160 --> 01:03:29,599
likely it just got rid of the variable

1646
01:03:29,599 --> 01:03:31,839
and it's doing all of its operations

1647
01:03:31,839 --> 01:03:34,480
um directly you know via regis it might

1648
01:03:34,480 --> 01:03:36,640
be doing all of its operations on a0 for

1649
01:03:36,640 --> 01:03:37,839
example

1650
01:03:37,839 --> 01:03:39,039
it might just be doing all of its

1651
01:03:39,039 --> 01:03:41,039
computations on the return address

1652
01:03:41,039 --> 01:03:42,640
it's pretty common to see something like

1653
01:03:42,640 --> 01:03:44,559
that if you um

1654
01:03:44,559 --> 01:03:46,319
if it's a variable that's not you know

1655
01:03:46,319 --> 01:03:47,599
100

1656
01:03:47,599 --> 01:03:50,319
necessary uh if you you know we don't

1657
01:03:50,319 --> 01:03:50,720
let

1658
01:03:50,720 --> 01:03:51,920
we don't give you control over the

1659
01:03:51,920 --> 01:03:53,440
compiler but if you ever find that in

1660
01:03:53,440 --> 01:03:54,480
your day-to-day

1661
01:03:54,480 --> 01:03:57,039
you can try setting the optimization

1662
01:03:57,039 --> 01:03:59,599
flag for the compiler to zero

1663
01:03:59,599 --> 01:04:01,920
um but even then you know the compiler

1664
01:04:01,920 --> 01:04:03,839
will do we'll do its we'll do some level

1665
01:04:03,839 --> 01:04:05,520
of optimization

1666
01:04:05,520 --> 01:04:08,799
uh your hand is raised yeah

1667
01:04:08,799 --> 01:04:12,160
um what's the address besides

1668
01:04:12,160 --> 01:04:14,319
that dollar one or dollar two you know

1669
01:04:14,319 --> 01:04:15,760
like before foo

1670
01:04:15,760 --> 01:04:18,960
or bar uh dollar this

1671
01:04:18,960 --> 01:04:21,359
yeah so what's that address is that the

1672
01:04:21,359 --> 01:04:22,319
address where

1673
01:04:22,319 --> 01:04:26,079
foo is probably yeah

1674
01:04:26,079 --> 01:04:28,319
but but then rv points to some other

1675
01:04:28,319 --> 01:04:30,799
address shouldn't those be the same

1676
01:04:30,799 --> 01:04:35,119
uh so our rv is on the stack

1677
01:04:35,119 --> 01:04:38,240
and it'll so the reason why

1678
01:04:38,240 --> 01:04:39,920
you know if you look at these addresses

1679
01:04:39,920 --> 01:04:41,680
we can see that they're in the kernel

1680
01:04:41,680 --> 01:04:44,720
uh just by the eight zero zero zero

1681
01:04:44,720 --> 01:04:47,520
um which makes sense because we they're

1682
01:04:47,520 --> 01:04:49,920
declared statically right so in demos if

1683
01:04:49,920 --> 01:04:51,920
i go here they're declared here

1684
01:04:51,920 --> 01:04:53,280
and so they're basically they're sitting

1685
01:04:53,280 --> 01:04:55,280
somewhere in the kernel and they're all

1686
01:04:55,280 --> 01:04:56,079
car stars

1687
01:04:56,079 --> 01:05:00,000
args arcs or rv is an array of car stars

1688
01:05:00,000 --> 01:05:02,240
and so i imagine that each element

1689
01:05:02,240 --> 01:05:05,760
points to points to

1690
01:05:05,760 --> 01:05:08,240
its own string right so it's an array of

1691
01:05:08,240 --> 01:05:20,829
pointers

1692
01:05:20,839 --> 01:05:24,630
crazy

1693
01:05:24,640 --> 01:05:27,359
i also have a question about this uh the

1694
01:05:27,359 --> 01:05:29,280
dollar three version of

1695
01:05:29,280 --> 01:05:32,480
the array has if i look

1696
01:05:32,480 --> 01:05:35,280
at these addresses the first one is

1697
01:05:35,280 --> 01:05:36,000
suffixed by

1698
01:05:36,000 --> 01:05:39,599
38. second one is suffixed by 40.

1699
01:05:39,599 --> 01:05:43,200
the third one is 48 which is

1700
01:05:43,200 --> 01:05:45,520
not uniform even though the length of

1701
01:05:45,520 --> 01:05:48,000
each of the three arguments

1702
01:05:48,000 --> 01:05:51,119
is three so why why are they different

1703
01:05:51,119 --> 01:05:54,480
uh not in i'm not 100

1704
01:05:54,480 --> 01:05:56,160
certain my guess is that this is an

1705
01:05:56,160 --> 01:05:58,720
attempt to align things

1706
01:05:58,720 --> 01:06:03,440
um right so to get them on a reasonable

1707
01:06:03,440 --> 01:06:06,079
alignment and it is uniform in hex as

1708
01:06:06,079 --> 01:06:08,400
people are pointing out

1709
01:06:08,400 --> 01:06:11,760
oh right yeah yeah that makes sense

1710
01:06:11,760 --> 01:06:14,880
oh oh yes i see it now yeah right

1711
01:06:14,880 --> 01:06:17,039
thanks so you'll sometimes see where

1712
01:06:17,039 --> 01:06:18,160
straight things are

1713
01:06:18,160 --> 01:06:20,319
laid out strangely where there might be

1714
01:06:20,319 --> 01:06:22,400
two things at strange offsets and that's

1715
01:06:22,400 --> 01:06:22,720
just

1716
01:06:22,720 --> 01:06:24,799
because not everything is uh naturally

1717
01:06:24,799 --> 01:06:26,319
the same size

1718
01:06:26,319 --> 01:06:37,270
um okay any other questions

1719
01:06:37,280 --> 01:06:41,119
okay uh we can skip the fifth demo

1720
01:06:41,119 --> 01:06:43,680
and so another useful function that we

1721
01:06:43,680 --> 01:06:44,160
get

1722
01:06:44,160 --> 01:06:48,069
from gdb are

1723
01:06:48,079 --> 01:06:50,400
instead of just break points uh there

1724
01:06:50,400 --> 01:06:52,400
are also watch points and we can also

1725
01:06:52,400 --> 01:06:53,520
set

1726
01:06:53,520 --> 01:06:58,150
conditional break points so

1727
01:06:58,160 --> 01:07:02,069
i'll just briefly go over that

1728
01:07:02,079 --> 01:07:05,680
we run demo six so we can set

1729
01:07:05,680 --> 01:07:08,000
inside this function we can watch so we

1730
01:07:08,000 --> 01:07:09,680
can set a watch point

1731
01:07:09,680 --> 01:07:15,599
um i think here you'll see um

1732
01:07:15,599 --> 01:07:18,319
yeah so here you'll see what uh luca was

1733
01:07:18,319 --> 01:07:20,160
talking about where

1734
01:07:20,160 --> 01:07:22,720
we see that sum has been optimized out

1735
01:07:22,720 --> 01:07:24,480
likely because it's just being

1736
01:07:24,480 --> 01:07:27,599
put in a zero or something we can look

1737
01:07:27,599 --> 01:07:29,359
even at the assembly for this right so

1738
01:07:29,359 --> 01:07:31,359
we can do layout

1739
01:07:31,359 --> 01:07:34,559
splits and yeah indeed we can see that

1740
01:07:34,559 --> 01:07:36,400
it all just being uh

1741
01:07:36,400 --> 01:07:37,920
it's all just being done on the stack it

1742
01:07:37,920 --> 01:07:40,160
looks like to me

1743
01:07:40,160 --> 01:07:41,960
oh no it's all just being done in s0

1744
01:07:41,960 --> 01:07:43,280
s013

1745
01:07:43,280 --> 01:07:46,950
so here you can see that the the

1746
01:07:46,960 --> 01:07:48,799
compiler decided even to use the quality

1747
01:07:48,799 --> 01:07:51,359
saved registers

1748
01:07:51,359 --> 01:07:54,240
and so we can set things like we can do

1749
01:07:54,240 --> 01:07:55,039
watch

1750
01:07:55,039 --> 01:07:58,240
on i

1751
01:07:58,240 --> 01:08:00,240
or we haven't declared i yet because

1752
01:08:00,240 --> 01:08:02,720
we're not inside

1753
01:08:02,720 --> 01:08:06,000
we're not inside the for loop so if we

1754
01:08:06,000 --> 01:08:08,640
step through the c instructions now if

1755
01:08:08,640 --> 01:08:11,440
we do information for the locals we see

1756
01:08:11,440 --> 01:08:12,400
we get i

1757
01:08:12,400 --> 01:08:16,159
we can even watch um watchpoint on

1758
01:08:16,159 --> 01:08:20,480
sum so now anytime that sum changes

1759
01:08:20,480 --> 01:08:23,440
we'll actually get a notification so we

1760
01:08:23,440 --> 01:08:24,799
can continue

1761
01:08:24,799 --> 01:08:27,600
and then we'll get a delete here because

1762
01:08:27,600 --> 01:08:28,000
some

1763
01:08:28,000 --> 01:08:30,560
has been removed so we can't we can't

1764
01:08:30,560 --> 01:08:31,839
actually watch it

1765
01:08:31,839 --> 01:08:35,920
we can even do things like break points

1766
01:08:35,920 --> 01:08:37,759
on sum2 so this is a conditional

1767
01:08:37,759 --> 01:08:39,040
breakpoint

1768
01:08:39,040 --> 01:08:42,239
if well let's actually see what is i

1769
01:08:42,239 --> 01:08:44,640
currently so i is currently one let's

1770
01:08:44,640 --> 01:08:45,279
say

1771
01:08:45,279 --> 01:08:47,600
i think my loop is breaking and whenever

1772
01:08:47,600 --> 01:08:48,799
i is five

1773
01:08:48,799 --> 01:08:50,640
well if i want to specifically debug

1774
01:08:50,640 --> 01:08:53,759
that case i can set a breakpoint

1775
01:08:53,759 --> 01:08:58,630
on sum2

1776
01:08:58,640 --> 01:09:02,799
if i equals five

1777
01:09:02,799 --> 01:09:05,279
so now we have this breakpoint and if we

1778
01:09:05,279 --> 01:09:06,640
continue along

1779
01:09:06,640 --> 01:09:09,679
we'll get to some two and uh we can see

1780
01:09:09,679 --> 01:09:11,520
that it actually printed out

1781
01:09:11,520 --> 01:09:14,159
the first couple values and so we only

1782
01:09:14,159 --> 01:09:15,920
break now on some two

1783
01:09:15,920 --> 01:09:19,520
if if i if we hit that breakpoint

1784
01:09:19,520 --> 01:09:21,199
condition

1785
01:09:21,199 --> 01:09:22,880
and so that's uh this can be again this

1786
01:09:22,880 --> 01:09:24,560
can be useful if you want to debug

1787
01:09:24,560 --> 01:09:26,480
specific edge cases of your code

1788
01:09:26,480 --> 01:09:29,199
and watch points can be useful if for

1789
01:09:29,199 --> 01:09:30,560
instance you think that something

1790
01:09:30,560 --> 01:09:31,839
shouldn't be changing

1791
01:09:31,839 --> 01:09:34,880
but you suspect that it is or you think

1792
01:09:34,880 --> 01:09:36,159
that something is going wrong

1793
01:09:36,159 --> 01:09:39,839
every time you change a certain variable

1794
01:09:39,839 --> 01:09:41,920
and so that's that's uh that's one one

1795
01:09:41,920 --> 01:09:43,600
usage for that

1796
01:09:43,600 --> 01:09:45,520
and uh the last thing i want to talk

1797
01:09:45,520 --> 01:09:48,319
about today is structs

1798
01:09:48,319 --> 01:09:50,080
structs are pretty important and they'll

1799
01:09:50,080 --> 01:09:51,600
come up in

1800
01:09:51,600 --> 01:09:55,040
um in the labs often

1801
01:09:55,040 --> 01:09:58,800
and also so what asks

1802
01:09:58,800 --> 01:10:00,480
i'll talk a little bit about the way

1803
01:10:00,480 --> 01:10:03,600
structs are laid out in memory

1804
01:10:03,600 --> 01:10:06,560
and so a struct is basically um it's a

1805
01:10:06,560 --> 01:10:08,640
continuous contiguous area of memory so

1806
01:10:08,640 --> 01:10:11,440
if we have some struct

1807
01:10:11,440 --> 01:10:14,800
and we have like field one field two

1808
01:10:14,800 --> 01:10:18,159
field three when we make that struck

1809
01:10:18,159 --> 01:10:19,520
those fields are going to be

1810
01:10:19,520 --> 01:10:22,640
aligned next to each other in memories

1811
01:10:22,640 --> 01:10:24,320
and you can kind of think of this

1812
01:10:24,320 --> 01:10:27,120
like an array but f1 f2 and f3 can all

1813
01:10:27,120 --> 01:10:28,480
be different types

1814
01:10:28,480 --> 01:10:31,840
and uh we can uh

1815
01:10:31,840 --> 01:10:33,280
pass them as functions usually they're

1816
01:10:33,280 --> 01:10:34,880
past uh pass them as arguments to

1817
01:10:34,880 --> 01:10:35,840
functions

1818
01:10:35,840 --> 01:10:38,159
usually they're passed by reference so

1819
01:10:38,159 --> 01:10:40,239
here i've made a struct person

1820
01:10:40,239 --> 01:10:44,159
with two integer arguments and

1821
01:10:44,159 --> 01:10:46,560
i'm passing them passing a person as an

1822
01:10:46,560 --> 01:10:48,320
argument to print person

1823
01:10:48,320 --> 01:10:51,120
and uh printing out some of that

1824
01:10:51,120 --> 01:10:52,159
information

1825
01:10:52,159 --> 01:10:54,880
so if we hop into gdb and let's delete

1826
01:10:54,880 --> 01:10:57,040
all of our breakpoints and watch points

1827
01:10:57,040 --> 01:11:00,320
and now we can set a breakpoint at

1828
01:11:00,320 --> 01:11:04,159
person and let's continue

1829
01:11:04,159 --> 01:11:07,600
and run seventh demo

1830
01:11:07,600 --> 01:11:09,280
we can see that now we're here and so if

1831
01:11:09,280 --> 01:11:11,040
we type iframe

1832
01:11:11,040 --> 01:11:15,360
we can see that we have an argument p

1833
01:11:15,360 --> 01:11:18,880
and indeed we can if we do print

1834
01:11:18,880 --> 01:11:22,719
p if we can even tell that it's a struct

1835
01:11:22,719 --> 01:11:23,520
person

1836
01:11:23,520 --> 01:11:26,880
at this address and

1837
01:11:26,880 --> 01:11:30,239
we can if we dereference it

1838
01:11:30,239 --> 01:11:32,560
gdb will tell us exactly what p looks

1839
01:11:32,560 --> 01:11:35,280
like it has id 1215

1840
01:11:35,280 --> 01:11:39,120
age is 22 and just to show kind of how

1841
01:11:39,120 --> 01:11:40,640
things are

1842
01:11:40,640 --> 01:11:43,760
laid out we can take this address

1843
01:11:43,760 --> 01:11:53,669
and we do x hd at this

1844
01:11:53,679 --> 01:12:02,149
i address exactly

1845
01:12:02,159 --> 01:12:04,320
so if we again so we can use this to

1846
01:12:04,320 --> 01:12:05,280
debug

1847
01:12:05,280 --> 01:12:08,719
our structures in

1848
01:12:08,719 --> 01:12:11,920
in the code we can take a look at what's

1849
01:12:11,920 --> 01:12:13,760
going on

1850
01:12:13,760 --> 01:12:16,880
with structures this way so gdb is a

1851
01:12:16,880 --> 01:12:18,080
super powerful tool

1852
01:12:18,080 --> 01:12:20,239
not just for you know stepping through

1853
01:12:20,239 --> 01:12:22,800
code but also for examining

1854
01:12:22,800 --> 01:12:26,239
all kinds of potentially problematic

1855
01:12:26,239 --> 01:12:28,159
pieces in your code and looking at

1856
01:12:28,159 --> 01:12:30,000
arguments and stack frames and things

1857
01:12:30,000 --> 01:12:30,880
like that

1858
01:12:30,880 --> 01:12:32,480
and this will be hopefully will be

1859
01:12:32,480 --> 01:12:35,360
useful in the next lab

1860
01:12:35,360 --> 01:12:38,000
when you have to work with um with stack

1861
01:12:38,000 --> 01:12:40,080
frames and with assembly code

1862
01:12:40,080 --> 01:12:42,719
so that's that's mostly what i wanted to

1863
01:12:42,719 --> 01:12:44,080
talk about today so

1864
01:12:44,080 --> 01:12:47,360
with the last kind of seven minutes of

1865
01:12:47,360 --> 01:12:47,920
lecture

1866
01:12:47,920 --> 01:12:50,560
i'll open it up to any any other

1867
01:12:50,560 --> 01:12:59,350
questions that you guys have

1868
01:12:59,360 --> 01:13:02,800
i had a bit of a tangential question who

1869
01:13:02,800 --> 01:13:05,120
is in who manages the the creation of

1870
01:13:05,120 --> 01:13:05,920
compilers

1871
01:13:05,920 --> 01:13:08,719
from like to get from c to various uh

1872
01:13:08,719 --> 01:13:10,239
instruction set architectures is that

1873
01:13:10,239 --> 01:13:11,920
the creator of the instruction set

1874
01:13:11,920 --> 01:13:13,280
architecture is it a third party

1875
01:13:13,280 --> 01:13:14,560
something like that

1876
01:13:14,560 --> 01:13:18,080
um i believe that it is

1877
01:13:18,080 --> 01:13:19,920
not the creator of the instruction set

1878
01:13:19,920 --> 01:13:22,320
so it's often a third party

1879
01:13:22,320 --> 01:13:24,159
so the two big c compilers that you'll

1880
01:13:24,159 --> 01:13:26,239
see refer to are gcc

1881
01:13:26,239 --> 01:13:28,640
which is maintained by i think the gnu

1882
01:13:28,640 --> 01:13:30,000
foundation

1883
01:13:30,000 --> 01:13:33,440
and uh c lang or llvm

1884
01:13:33,440 --> 01:13:36,080
which is its own thing so i think you

1885
01:13:36,080 --> 01:13:37,280
know you can find

1886
01:13:37,280 --> 01:13:39,679
i believe lovm is even open source so

1887
01:13:39,679 --> 01:13:40,960
you can find

1888
01:13:40,960 --> 01:13:43,120
um you can you can find the code

1889
01:13:43,120 --> 01:13:44,560
specifically that does this

1890
01:13:44,560 --> 01:13:46,800
uh when a new instruction set is

1891
01:13:46,800 --> 01:13:48,800
released such as risk five

1892
01:13:48,800 --> 01:13:50,880
that calling convention document as well

1893
01:13:50,880 --> 01:13:53,360
as all of those instruction documents

1894
01:13:53,360 --> 01:13:54,960
uh i think you're careful but i assume

1895
01:13:54,960 --> 01:13:56,800
there's like a high level of cooperation

1896
01:13:56,800 --> 01:13:58,480
between the compiler designer and the

1897
01:13:58,480 --> 01:14:00,239
instruction set designer

1898
01:14:00,239 --> 01:14:03,760
um but yeah short answer is i i believe

1899
01:14:03,760 --> 01:14:04,560
it's a third

1900
01:14:04,560 --> 01:14:07,120
third party who does it likely with a

1901
01:14:07,120 --> 01:14:08,719
lot of cooperation from the people who

1902
01:14:08,719 --> 01:14:09,840
make the instruction set

1903
01:14:09,840 --> 01:14:12,719
risk five is probably risk five might be

1904
01:14:12,719 --> 01:14:14,880
an exception where because it came out

1905
01:14:14,880 --> 01:14:16,560
of a research project

1906
01:14:16,560 --> 01:14:18,560
they may have written the the compiler

1907
01:14:18,560 --> 01:14:20,159
for it themselves

1908
01:14:20,159 --> 01:14:23,280
as well i i don't think intel has

1909
01:14:23,280 --> 01:14:26,880
for example has input in uh in gcc or

1910
01:14:26,880 --> 01:14:45,510
llvm

1911
01:14:45,520 --> 01:14:54,630
other questions

1912
01:14:54,640 --> 01:14:57,840
okay well uh thanks

1913
01:14:57,840 --> 01:14:59,920
for listening in that case and i guess

1914
01:14:59,920 --> 01:15:01,760
we can uh

1915
01:15:01,760 --> 01:15:04,880
we can end the lecture here uh with five

1916
01:15:04,880 --> 01:15:06,480
minutes to spare so

1917
01:15:06,480 --> 01:15:09,520
have a nice rest of

