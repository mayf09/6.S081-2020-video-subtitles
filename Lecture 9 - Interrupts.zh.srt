1
00:00:00,000 --> 00:00:02,430
对于已经登录的用户，
For folks already signed in,

2
00:00:03,100 --> 00:00:07,180
好奇你在 traps 实验的经历。
curiosity how you experience being with the traps lab.

3
00:00:08,200 --> 00:00:12,490
如果你已经开始了懒分配实验，进展如何。
If you already started on the lazy allocation lab, how's that going.

4
00:00:13,810 --> 00:00:18,670
[]是不是比页表实验轻松。
[] that was was less painful than the page table lab.

5
00:00:20,580 --> 00:00:23,400
Andrew You ，你有什么想说的吗？
Andrew You, you want to say something about that.

6
00:00:32,000 --> 00:00:34,040
我认为 traps 实验没问题，
I thought the traps lab was OK,

7
00:00:35,030 --> 00:00:38,620
我只是想确认一下，
It was just making sure that

8
00:00:38,980 --> 00:00:43,270
我使用 trampoline 页面有点烦人。
I actually use the trampoline page properly was a little annoying.

9
00:00:43,720 --> 00:00:44,170
是的。
Yep.

10
00:00:44,410 --> 00:00:47,560
但是一旦我弄清楚了，然后它就可以工作了。
But once I figured that out, then then it just kind of worked.

11
00:00:47,770 --> 00:00:50,140
好的，是的，实验的整个目标是，
Good good, yeah, the whole goal was lab [],

12
00:00:50,140 --> 00:00:57,140
把 trap 处理入口和出口完全暴露给你。
you really expose you to the trap handling entry and exit.

13
00:01:01,990 --> 00:01:05,440
Amir 呢，你在 traps 实验的经历如何。
How about Amir, how was your experience with the traps lab.

14
00:01:08,180 --> 00:01:17,150
我觉得 traps 实验很好，比页表实验易于管理。
I thought that traps lab was good, very much more manageable than the page table lab.

15
00:01:17,620 --> 00:01:23,410
我注意到有机会更精巧地实现的某些方面，这很好，这真是太好了
I noticed that there were like opportunities to be clever about some aspects of the implementation, which was nice

16
00:01:23,890 --> 00:01:28,750
到目前为止，懒分配实验的调试情况还不错。
and lazy lab is good so far debugging.

17
00:01:29,560 --> 00:01:32,170
但在我看来，两者都比页表要好。
But both better than the page table in my opinion.

18
00:01:32,410 --> 00:01:34,210
很高兴听到你这么说，
Glad to hear that,

19
00:01:34,240 --> 00:01:35,470
我相信你也很高兴听到这个，
I'm sure you were glad to hear that,

20
00:01:35,470 --> 00:01:37,060
但我也很高兴听到你这么说。
but I'm glad to hear it too.

21
00:01:40,480 --> 00:01:42,220
Timmy 怎么样？
How about Timmy []?

22
00:01:44,180 --> 00:01:50,330
是的，前两个实验比页表要好得多。
Yeah, these two previous labs have been a lot better than the page table.

23
00:01:51,950 --> 00:01:57,480
我想，对于懒分配实验来说最难的是，
I guess, the hardest part for the lazy lab, the lazy one

24
00:01:57,480 --> 00:02:01,810
读写和所有的东西，
was the read and write and all that stuff,

25
00:02:01,900 --> 00:02:04,870
但在我看来并不是那么糟糕。
but it's not it's not that bad in my opinion.

26
00:02:05,800 --> 00:02:06,280
好的。
Okay.

27
00:02:11,480 --> 00:02:12,380
Catherine 怎么样，
How do Catherine,

28
00:02:13,010 --> 00:02:19,180
对你来说， traps 实验或懒分配实验与页表实验相比较。
was the traps lab or the lazy lab for you in comparison to the page table lab.

29
00:02:33,340 --> 00:02:35,380
你在吗，Katherine ， Katherine Weeks 。
Are you there, Katherine, Katherine Weeks.

30
00:02:36,600 --> 00:02:37,890
你好，我做得很好，
Hello, I'm doing well,

31
00:02:37,920 --> 00:02:40,320
抱歉，我不知道你在跟哪个 Catherine 说话，
sorry I didn't know which Catherine you're talking to,

32
00:02:40,320 --> 00:02:41,370
我想大概只有 20 个人，
I guess there's only twenty people,

33
00:02:41,370 --> 00:02:44,160
所以你可能不太可能还有另一个。
so you're probably not likely that there's another one.

34
00:02:45,420 --> 00:02:46,350
我做得很好。
I'm doing quite well.

35
00:02:46,950 --> 00:02:51,030
很好，所以这个实验比页表实验少了很多痛苦.
Good good, so this lab is less painful than the pagetable lab or.

36
00:02:51,030 --> 00:02:52,950
是的，绝对不会那么痛苦。
Yeah, it's definitely less painful.

37
00:02:55,420 --> 00:02:55,960
太棒了。
Excellent.

38
00:02:56,260 --> 00:02:56,740
嗯。
Yeah.

39
00:02:57,470 --> 00:02:58,310
嗯。
Yeah.

40
00:02:59,420 --> 00:03:06,620
页表后面的那个 traps （实验），绝对简单的多。
The the one the one after page tables, what was that traps, that was definitely much simpler.

41
00:03:09,300 --> 00:03:11,400
好的，很高兴听到你们这么说，
OK great, we're glad to hear that,

42
00:03:11,400 --> 00:03:13,680
我只想做个非正式的民意测验，
I just wanted to get an informal poll see,

43
00:03:14,480 --> 00:03:17,030
页表实验比我们预想的要难，
you know the page table turned out harder than we thought it would,

44
00:03:17,090 --> 00:03:20,180
所以，这些更好。
and so, like you know these ones are better.

45
00:03:20,810 --> 00:03:24,440
好的，那么我们要做什么呢。
OK, so what do we get going.

46
00:03:24,800 --> 00:03:29,480
不管你在哪里，欢迎收看 6.S081 的下一节课，
And welcome to the next lecture in 6.S081 wherever you are,

47
00:03:29,690 --> 00:03:32,630
今天的主题是关于中断，
so the topic in today is about interrupts,

48
00:03:32,690 --> 00:03:35,780
在开始讨论中断之前，
before jumping into sort of talking about interrupts,

49
00:03:35,960 --> 00:03:38,420
我想分享一点东西，
I wanted to share a little bit one thing,

50
00:03:38,420 --> 00:03:39,740
我想说的是，
that I wanted to talk about,

51
00:03:39,740 --> 00:03:42,350
上个星期，我没能抽出时间来做这件事。
last week which I didn't get around do it through.

52
00:03:42,780 --> 00:03:44,730
你可能会感兴趣的。
And you know what you might find interesting.

53
00:03:47,840 --> 00:03:50,600
让我看下，在这里找到我正确的屏幕，
Let me see, if I can get my right screen here up,

54
00:03:50,870 --> 00:03:55,100
所以在这里，看我屏幕的左下角，
so here, you know you see my screen here on the bottom left,

55
00:03:55,370 --> 00:04:00,650
我通过对话机登录到 Athena 。
I'm actually logged into Athena through the dialogue machines.

56
00:04:01,180 --> 00:04:04,300
我有几件事想谈谈，
And there's a couple things I wanted to talk about,

57
00:04:04,390 --> 00:04:08,830
在真正的操作系统中，内存是如何使用的。
in terms of how memory is being used by a real operating system.

58
00:04:09,540 --> 00:04:12,120
因为我们上周谈了很多，特别是在课程的最后，
Since we talked a lot about that last week, particularly the end of the lecture,

59
00:04:12,120 --> 00:04:17,250
很多问题关于逐出页面，寻找空闲内存之类的东西。
a lot of questions about, you know page out, finding free memory and all that kind of stuff.

60
00:04:17,990 --> 00:04:20,750
这是一台 Athena 机器，
So this is one of Athena machines,

61
00:04:20,810 --> 00:04:22,640
你要注意的是，
you're wanting to note,

62
00:04:22,640 --> 00:04:27,410
如果你看一下内存这一行，它告诉你有多少，
if you look at the memory line, it actually tells you how much,

63
00:04:27,590 --> 00:04:31,190
运行的程序是 top ，可能你们很多人都用过它，
the program running is called top, probably many of you have used it,

64
00:04:31,550 --> 00:04:34,460
你可以看到一台机器里有多少内存，
you see how much machine memories in a machine

65
00:04:34,460 --> 00:04:38,120
如你所见，这台机器里有很多内存。
as you can see, there's a quite a bit of memory in in this machine.

66
00:04:38,520 --> 00:04:45,800
如果你仔细看一下，实际上大部分都是在使用的。
And if you look a little bit carefully, actually most of it is used, right.

67
00:04:45,830 --> 00:04:50,180
很大一部分内存实际上并没有被应用程序使用，
The you know, a large part of the memory is actually not being used by applications,

68
00:04:50,180 --> 00:04:51,830
而是由缓冲器高速缓存使用。
but actually used by the buffer cache.

69
00:04:52,410 --> 00:04:54,900
这在操作系统中很常见，
I said this is quite common in an operating system,

70
00:04:54,900 --> 00:04:58,980
你不想让你的内存无所事事，
you don't really want to leave your physical memory, sitting idle and do nothing,

71
00:04:59,190 --> 00:05:00,840
你可能把它用在有用的东西上，
you might as well use it for something useful,

72
00:05:01,020 --> 00:05:06,060
在这种情况下，它的很大一部分用于缓冲区缓存。
and so in this case, use a good chunk of it is actually used for a buffer cache.

73
00:05:06,790 --> 00:05:10,390
一些内存是空闲的，不是很多，
A little bit of memory, free, not much,

74
00:05:10,780 --> 00:05:14,980
在一台机器中总内存的一小部分，
you know fraction of the total memory that actually in a machine

75
00:05:14,980 --> 00:05:18,580
这是一个非常常见的情况，像大多数操作系统一样。
and so this is a very common case, like most operating systems run.

76
00:05:19,080 --> 00:05:22,590
我们在任何时刻都几乎没有可用的内存。
We basically almost no memory free at any particular instant in time.

77
00:05:23,620 --> 00:05:28,480
这意味着，如果应用程序或内核需要一些内存，
And so that means, for example, if an application or the kernel needs some memory

78
00:05:28,600 --> 00:05:30,250
我们得扔掉一些东西，
and we'll have to throw out something,

79
00:05:30,370 --> 00:05:34,660
也许这几页就足够了，
you know, maybe that's enough for a few pages where a handful of pages,

80
00:05:34,660 --> 00:05:36,460
但在某种情况下，它需要大量的空闲内存，
but at some point it needs a lot of free memory,

81
00:05:36,520 --> 00:05:40,360
它会要求从应用程序或缓冲器告诉缓存中中逐出某些内容。
it will ask to evict something either from the applications or from the buffer cache.

82
00:05:41,380 --> 00:05:44,710
所以这里的主要观点是，
And so you know sort of the main point here basically is that here,

83
00:05:44,710 --> 00:05:46,210
当内核分配内存时，
when the kernel makes allocate memory,

84
00:05:46,210 --> 00:05:48,370
通常不是一个便宜的操作，
it's actually not generally not a cheap operation,

85
00:05:48,370 --> 00:05:52,170
因为没有太多空闲内存可用。
because the memory is not, there's not a ton of memory free available.

86
00:05:53,270 --> 00:05:55,010
另一件有趣的事情是，
The other thing that's sort of interesting to look at is

87
00:05:55,010 --> 00:06:01,160
我根据驻留内存量对 top 的输出进行排序。
I sorted the output of top by the amount of resident memory.

88
00:06:01,660 --> 00:06:03,760
所以你看的每一行，
So you're looking at every line,

89
00:06:03,760 --> 00:06:08,020
对于每个进程，这是地址空间的大小，
for every process you see that, this is size of address space

90
00:06:08,290 --> 00:06:11,470
然后，下一行告诉你实际使用了多少内存，
and then the next line actually tells you how much memory is actually being used

91
00:06:11,470 --> 00:06:12,760
比如物理内存量，
like the amount of physical memory,

92
00:06:12,760 --> 00:06:16,850
地址空间的一小部分在物理内存中，
you know, how the fraction of the address space actually is in physical memory,

93
00:06:17,240 --> 00:06:21,410
正如你看到的，它通常比地址空间小得多，
and as you can see it actually it's typically way smaller than the address space

94
00:06:21,440 --> 00:06:27,260
所以我们最后谈到的虚拟内存提供的技巧，很酷的想法，
and so the tricks that we talked about last word, cool ideas and virtual memory provides

95
00:06:27,410 --> 00:06:30,140
在这里使用，比如按需调页，
are being used here like demand paging,

96
00:06:30,380 --> 00:06:35,330
共享列是共享页面，来自共享库中，
the shared column is shared pages, you know from the shared libraries

97
00:06:35,600 --> 00:06:42,580
你大体上可以看到，常驻内存比虚拟地址空间小得多。
and you see in general that basically the the resident memory is much much much smaller than the virtual address space.

98
00:06:43,740 --> 00:06:46,170
也许还有几件有趣的事需要注意，
Maybe a couple other interesting things to note

99
00:06:46,200 --> 00:06:49,410
看着这台机器，负载很低，
are just looking at this machine, the load is very low,

100
00:06:49,440 --> 00:06:53,100
即使有 102 个用户登录。
even though they're a hundred twenty users and 102 users logged in.

101
00:06:53,620 --> 00:07:00,310
你会看到有很多进程， 950 左右，
And you're gonna see there's a lot of processes, you know 950 or roughly,

102
00:07:00,550 --> 00:07:04,690
注意机器已开机多长时间， 249 天，
[] note exactly how long the machine has been up, like 249 days,

103
00:07:05,080 --> 00:07:09,340
你的 xv6 内核可能根本不会运行那么长时间。
your xv6 kernel is probably not up that long at all ever.

104
00:07:12,780 --> 00:07:15,000
好的，这就是，关于这个有什么问题吗，
Okay, so that's you know any questions about this,

105
00:07:15,000 --> 00:07:19,100
主要的一点是，大多数内存正在使用，
just sort of, you know the main point being that most memories in use

106
00:07:19,100 --> 00:07:23,030
并且常驻内存通常比虚拟地址空间小得多。
and the resident memory is typically much smaller than the virtual address space.

107
00:07:27,420 --> 00:07:31,020
你可以自己运行这个，如果你想看看是怎么发生的。
You're [going] to run this yourself, if you want to see you actually what's up.

108
00:07:33,360 --> 00:07:34,080
有什么问题吗？
Any questions?

109
00:07:35,750 --> 00:07:39,230
您可以看到 6.S081 学生中的一些人登录，
You see some of the 6.S081 students being logged in

110
00:07:39,230 --> 00:07:41,630
如果你看一下，会看到很多 QEMU 在运行。
and if you look around you see a whole bunch of QEMU running.

111
00:07:43,410 --> 00:07:46,250
好的，没有问题。
Okay, no questions.

112
00:07:46,280 --> 00:07:49,970
让我回到今天的话题，中断。
Let me go back to the topic for today, which is interrupts.

113
00:07:52,270 --> 00:07:56,800
基本的想法是很直接的，
And the basic, you know, the basic idea is really straightforward,

114
00:07:56,830 --> 00:07:59,350
我们想要实现的是，
what we want to enable is that,

115
00:07:59,970 --> 00:08:07,950
某种情况下，硬件需要关注。
there's going to be cases where the hardware wants attention, wants to attention now.

116
00:08:10,800 --> 00:08:12,690
从网络传入数据包，
You know a packet comes in from the network

117
00:08:12,720 --> 00:08:17,760
互联网网卡产生中断，
and so the network Internet network card generates an interrupt,

118
00:08:17,760 --> 00:08:22,920
用户在键盘上键入一个键，键盘会产生中断。
user typed a key on the keyboard and the keyboard generates an interrupt.

119
00:08:23,490 --> 00:08:26,190
软件要做什么，
And you know what the software has to do,

120
00:08:26,520 --> 00:08:29,550
如果软件必须保存它的工作，
if the software has to save its work,

121
00:08:29,580 --> 00:08:31,410
不管它现在在做什么，
whatever it was doing right now,

122
00:08:32,990 --> 00:08:36,570
把它放在一边，进程中断，
put it on the side, you know process interrupt,

123
00:08:41,660 --> 00:08:45,430
然后恢复到正在进行的工作中。
and then resume or restore, into the work that is doing.

124
00:08:51,020 --> 00:08:59,990
保存和恢复与我们之前看到的机制非常相似，
And, basically that saving and restoring is very very similar to the mechanisms that we already have seen before,

125
00:08:59,990 --> 00:09:08,950
即用于系统调用，还有 traps ，比如页面错误，
namely for system calls, and traps, like page fault,

126
00:09:09,040 --> 00:09:11,050
它们都使用相同的机制。
they all use the same mechanism.

127
00:09:18,920 --> 00:09:24,710
所以在这个意义上，中断与 traps 或系统调用没有什么不同，
So in that sense, you know interrupts are no different whatever, compared to traps or you know system calls,

128
00:09:24,710 --> 00:09:27,620
但有几件事让它们有点不同，
but a couple things that make them a little bit different

129
00:09:27,620 --> 00:09:29,780
以及为什么我们要花一节课来讲解它们。
and why we're actually spending a lecture on them.

130
00:09:30,360 --> 00:09:33,450
所以有三个东西组成中断，
So there three basically things that make interrupts,

131
00:09:34,740 --> 00:09:38,850
与系统调用和异常略有不同。
slightly different from system calls and exceptions.

132
00:09:38,850 --> 00:09:42,480
第一，用一个更好的词来说，它们是异步的，
One, with a better word, I'm gonna call they're asynchronous,

133
00:09:46,310 --> 00:09:50,030
我的意思是，系统调用，
and with that I mean that, the system call,

134
00:09:50,030 --> 00:09:54,740
当硬件生成中断时，中断处理程序运行，
the interrupt happens when the hardware actually generate an interrupt and the interrupt handler runs,

135
00:09:54,980 --> 00:09:59,900
中断处理程序可能与 CPU 上当前运行的进程无关。
the interrupt handler might actually have nothing to do with the current running process on the CPU.

136
00:10:00,420 --> 00:10:02,790
所以，与进行系统调用的情况不同，
So, unlike for example where you do a system call

137
00:10:02,790 --> 00:10:05,610
当系统调用发生时，你跳入内核，
or when the system call happens and then you jump into the kernel

138
00:10:05,760 --> 00:10:08,700
然后我们在调用进程的上下文中运行。
then we're running in the context of the calling process.

139
00:10:09,220 --> 00:10:11,080
而对于中断则不是这样，
And this is not true with interrupt,

140
00:10:11,170 --> 00:10:16,960
它们可能与你正在 CPU 中运行的进程完全无关，
they might have been completely unrelated to actually a process that you know who's running in the CPU

141
00:10:16,960 --> 00:10:19,990
可能与中断处理程序无关，甚至不是它调用的。
might actually have nothing to do with the interrupt handler, may not even it calls.

142
00:10:21,000 --> 00:10:22,260
所以那是不同的。
So that's different.

143
00:10:22,380 --> 00:10:28,840
第二，到目前为止，我们看到的并发性比以往任何时候都要多。
Second of all, there is a much more concurrency than we have seen so far,

144
00:10:28,840 --> 00:10:35,640
实际上，这是讨论并发性的开始，
in fact, you know, so this is a starting place where talking about concurrency

145
00:10:35,790 --> 00:10:38,730
我们将在周三的课程中详细讨论这个问题，
and we'll talk about it on Wednesday lecture a lot more,

146
00:10:38,730 --> 00:10:45,030
基本的观点是，CPU 和生成的设备是并行运行的，
the basic observation is that, basically the CPU and the device that generated in, this operate in parallel,

147
00:10:45,060 --> 00:10:47,220
你知道有网卡的 UART ，
you know the UART with a network card,

148
00:10:47,220 --> 00:10:50,850
只是做它的事情，从网络中挑选数据包，
you know just doing its thing you know picking packets from the network,

149
00:10:51,060 --> 00:10:52,860
然后在某一时刻产生中断。
and then at some point generating an interrupt.

150
00:10:53,240 --> 00:10:56,330
同时，CPU 也在运行，也在做自己的事情，
And at the same time, the CPU is running and also is doing its own thing,

151
00:10:56,360 --> 00:11:00,650
所以，在设备和 CPU 之间，我们有真正的并行性，
so we have true parallelism, going on between the device and the CPU

152
00:11:00,650 --> 00:11:04,190
我们必须管理这种并行性，我们稍后会看到。
and we have to manage that parallelism as we'll see in a second.

153
00:11:05,450 --> 00:11:10,280
最后，我将主要关注外部设备，
And finally, I'm going to focus mostly on external devices,

154
00:11:10,280 --> 00:11:13,400
比如网卡和 UART ，这些必须被编程。
like network cards and UART and those have to be programmed.

155
00:11:21,310 --> 00:11:24,850
每个设备都有自己的编程手册，
And basically every device has its own programming manual,

156
00:11:24,850 --> 00:11:30,400
以 RISC-V 同样的方式，包含指令和寄存器作用，RISC-V有说明书和哪些寄存器做什么的手册，
in the same way that RISC-V has manual with instructions and which registers do what,

157
00:11:30,760 --> 00:11:34,030
每个设备都有类似的手册，
every device actually has a similar [] manual,

158
00:11:34,270 --> 00:11:39,940
描述它有什么寄存器，你可以遵循哪些操作，
with you know describing what register it has, what operations you can conform,

159
00:11:39,970 --> 00:11:43,600
设备对于读取和写入控制寄存器的回应。
what the device does come in response to reading and writing control registers.

160
00:11:44,380 --> 00:11:51,850
不幸的是，设备手册通常不如 RISC-V 手册清楚，
Unfortunately often the manuals for the devices are less clear than the RISC-V manual

161
00:11:52,030 --> 00:11:55,780
这使得复杂的编程变得更加复杂。
and which makes a complex programming even more complicated.

162
00:11:56,820 --> 00:12:00,300
我在这节课上要做的其实很简单，
And so what I'm gonna do in this lecture is actually pretty straightforward,

163
00:12:00,510 --> 00:12:09,990
讨论 shell 提示符（$）是如何出现的，
if you want to talk about how the prompt shows up, when you know the shell prompt

164
00:12:09,990 --> 00:12:11,940
然后如果你键入 ls ，
and then if you type ls,

165
00:12:12,240 --> 00:12:15,810
这些字符是怎么读入的，
you know how do these characters get read

166
00:12:15,810 --> 00:12:17,760
然后显示在控制台中，
and actually then being displayed in the console

167
00:12:17,790 --> 00:12:21,000
实际上，基本上剩下的课程都是关于这三个字符的，
and in fact, so basically the rest of these lectures about these three characters,

168
00:12:21,880 --> 00:12:27,130
以及实现这一目标所必需的的所有机制。
Um you know, but all the mechanism, that's necessary to actually make that happen.

169
00:12:28,550 --> 00:12:32,630
到目前为止，在我继续深入讨论之前，有什么问题吗？
Any questions so far, before I [extract] diving a little deeper.

170
00:12:38,470 --> 00:12:40,210
好的。
Okay.

171
00:12:41,850 --> 00:12:45,930
所以可能要问的第一个问题是，中断是从哪里来的。
So the first question maybe to ask is where did the interrupts come from.

172
00:13:00,330 --> 00:13:05,090
我们这节课将主要关注外部中断，
And, so so we're going to be focusing mostly this lecture on external interrupts,

173
00:13:05,090 --> 00:13:07,490
不是计时器中断或软件中断，
you know not timer interrupts or software interrupts,

174
00:13:07,760 --> 00:13:11,720
外部中断来自电路板上的设备，
you know the external interrupts come from devices that are sitting on the board

175
00:13:11,810 --> 00:13:18,170
这是一块 SiFive 电路板，就是 QEMU 模拟的那个，
and here are a SiFive board, that QEMU more or less animates,

176
00:13:18,170 --> 00:13:20,900
这里有一些小的改动，
you know there's some small modifications,

177
00:13:21,140 --> 00:13:24,380
我们看到，你在这块板上看到，
and we see there's actually you look around from this board,

178
00:13:24,440 --> 00:13:27,080
那里有很多不同的设备，
there's a lot of actually different devices there,

179
00:13:27,350 --> 00:13:28,850
可以连接到这块板上，
can be connected to this board,

180
00:13:29,030 --> 00:13:31,360
这里是以太网连接器，
here are Ethernet connector,

181
00:13:31,540 --> 00:13:35,860
这是 MicroUSB，在那里，
in fact here's MicroUSB, that's over there,

182
00:13:36,100 --> 00:13:38,320
这是 MicroSD 卡，
there's a MicroSD card,

183
00:13:38,620 --> 00:13:41,290
这是重置按钮，
you know reset buttons

184
00:13:41,290 --> 00:13:46,810
这是从这些设备到 CPU 的各种线路。
and so there are all kinds of lines that must be running running from those devices into the CPU.

185
00:13:47,500 --> 00:13:49,150
这节课的大部分内容是，
And most of this lecture is basically sort of

186
00:13:49,150 --> 00:13:56,440
理解当设备发生中断时， CPU 上会发生什么，
understanding, you know what happens, you know at the CPU when a device generates an interrupt

187
00:13:56,440 --> 00:13:59,080
以及如何从设备读取和写入信息。
and how to read and write the information from the device.

188
00:13:59,760 --> 00:14:06,050
我相信下面的两个针脚，在这个扩展接头上，
I believe like these lower two pins here, at this expansion connector,

189
00:14:06,050 --> 00:14:12,690
我想其中一个是用来传输的 UART Tx ，
I think one of them is UART, is the UART sent, for transmission

190
00:14:12,720 --> 00:14:20,180
另一个是用来接收的 UART0 Re 。
and the other one is the UART0 receive Re.

191
00:14:21,690 --> 00:14:23,820
<---我认为它实际上与两边都有联系，
And I think it's actually connected to both sides,

192
00:14:23,820 --> 00:14:26,040
微型USB以及通过该延长线，--->
the micro usb as well as to this extension cord,

193
00:14:26,040 --> 00:14:31,870
我认为 UART 芯片本身，你可能在那边的芯片里。
and I think the UART chip itself, you know might actually be inside of this chip over there.

194
00:14:37,720 --> 00:14:44,320
好的，所以电路板上有很多线到 CPU ，
Okay so, so basically there are a bunch of lines running on the board, you know into the CPU,

195
00:14:44,620 --> 00:14:48,070
我们放大一点，详细看看 CPU ，
you know we go zoom in a little bit more in detail in the CPU,

196
00:14:48,620 --> 00:14:56,640
电路板使用 SiFive 文档中的方案，
use a schema from the you know, SiFive documentation for the board

197
00:14:56,640 --> 00:15:00,540
或者电路板的处理器使用 RISC-V 处理器，
or the processor of the board were RISC-V processor using,

198
00:15:00,930 --> 00:15:02,940
我们之前看过这个，
we looked at this a little bit before,

199
00:15:03,210 --> 00:15:08,220
看这里，右边是设备，
you know see here basically, here are the devices on the right side,

200
00:15:08,220 --> 00:15:09,540
这里是 UART0 ，
here UART0

201
00:15:09,870 --> 00:15:15,690
我们知道 UART0 内存映射到物理地址空间中的某个位置。
and we know that basically that UART0 memory maps somewhere in the physical address space,

202
00:15:16,140 --> 00:15:18,720
这边的所有 DRAM ，
like all the DRAM on this side,

203
00:15:18,720 --> 00:15:22,410
我们知道 DRAM 位于 0x8000 之上，
we know we know the DRAM sits above 0x8000

204
00:15:22,410 --> 00:15:25,980
而在 0x8000 之下，是不同的设备。
and below 0x8000 they are different devices.

205
00:15:26,610 --> 00:15:33,060
基本上对那些物理地址使用 load 和 store 指令，
Basically with load and store instructions, you know to those, to those physical addresses,

206
00:15:33,060 --> 00:15:34,500
我们实际上可以对 UART 进行编程，
we can actually program that UART,

207
00:15:34,560 --> 00:15:36,690
稍后会更详细地了解这一点。
look at that in much more detail in a second.

208
00:15:37,800 --> 00:15:40,710
所有设备都可以到达处理器，
All the devices can basically coming to the processor

209
00:15:40,830 --> 00:15:46,070
真正发生的是这个平台级别的中断间控制器，
and really what happens is this platform level inter- interrupt controller,

210
00:15:46,070 --> 00:15:47,810
简称为 PLIC ，
which is called PLIC for short,

211
00:15:48,430 --> 00:15:54,970
是对外部设备中断的管理者。
is the one that sort of general managers, the interrupts coming in, you know, from external devices.

212
00:15:55,670 --> 00:15:57,590
所以如果我们再放大一点，
And so if we zoom in a little bit more,

213
00:15:57,980 --> 00:16:04,760
这是片上设备 PLIC 的示意图，
here's a diagram of the the PLIC in on-chip devices,

214
00:16:04,760 --> 00:16:10,460
这里看到，有 53 条中断线路来自不同的设备。
so here we see there's you know 53 interrupt lines coming in from different devices,

215
00:16:10,980 --> 00:16:14,250
可能，中断线路上的设备，进入 PLIC ，
probably, devices on interrupt line, they come into the PLIC

216
00:16:14,580 --> 00:16:16,890
然后 PLIC 路由这些中断。
and the PLIC and route interrupts.

217
00:16:24,410 --> 00:16:27,050
举个例子，这取决于，
So, for example you know depending,

218
00:16:27,050 --> 00:16:29,030
所以这是我们的核心，
so here are our particular cores,

219
00:16:29,970 --> 00:16:34,380
在这里，我们运行的是三个内核，
here in our way, we run it, we run three cores

220
00:16:34,380 --> 00:16:37,980
PLIC 是可以编程的，
and basically you know the PLIC can be programmed,

221
00:16:38,130 --> 00:16:43,080
所以 PLIC 将中断交给这些核心中的一个或者第一个，
so that the PLIC will raise interrupts to, you know, one of these cores or to the first core,

222
00:16:43,080 --> 00:16:45,330
它可以获得中断，
that can take an interrupt

223
00:16:45,330 --> 00:16:47,040
而且有一些灵活性。
and there's a bit of flexibility.

224
00:16:47,760 --> 00:16:50,550
如果此时没有一个核心可以接受中断，
And if none of the cores can take an interrupted at this point,

225
00:16:50,550 --> 00:16:52,020
比如它们禁用了中断，
for example they have disabled interrupts,

226
00:16:52,020 --> 00:16:54,300
因为他们在处理另一个中断，
because their processing another interrupt

227
00:16:54,390 --> 00:16:57,390
PLIC 将持有这个中断，
and the PLIC will just hold that interrupt

228
00:16:57,390 --> 00:17:00,930
直到有处理器可以处理中断。
until you know a processor is available to take interrupt.

229
00:17:02,130 --> 00:17:06,330
所以 PLIC 有一些内部状态来记录这些。
So the PLIC has some internal state, you know to keep track of that.

230
00:17:06,930 --> 00:17:09,000
如果你看一下文档，
If you saw the documentation a little bit,

231
00:17:09,000 --> 00:17:11,460
PLIC 中真正发生的是，
in a way you know real things are happening is the PLIC,

232
00:17:11,460 --> 00:17:13,620
表示有一个中断，等待其中一个核心，声称拥有它，
indicates that there is a interrupt,

233
00:17:13,650 --> 00:17:17,490
pending one of the cores, you know basically claims it,

234
00:17:17,850 --> 00:17:21,720
所以这告诉 PLIC 不要给任何其他核心，
so that will tell the PLIC not to give to any other core

235
00:17:21,870 --> 00:17:24,060
一旦核心完全完成，
and once the core is completely done with it,

236
00:17:24,060 --> 00:17:26,370
它会说好的，我完成了这个中断，
it will say OK I'm done with this particular interrupt

237
00:17:26,370 --> 00:17:28,620
然后 PLIC 会，
and you know the PLIC will,

238
00:17:28,920 --> 00:17:33,000
通知 PLIC 可以忘记这个中断。
inform the PLIC that [] this can forget about this interrupt.

239
00:17:35,770 --> 00:17:37,000
有任何关于这个的问题吗？
Any questions about this?

240
00:17:37,730 --> 00:17:42,220
这是 RISC-V 的内部中断结构。
There's sort of the internal RISC-V interrupt structure.

241
00:17:44,140 --> 00:17:47,620
是的，所以当每个核心持有 PLIC 时，
Yeah, so when each core holds the PLIC,

242
00:17:47,650 --> 00:17:51,670
PLIC 是否有某种执行机制来确保公平。
does the PLIC have some enforcement mechanism to ensure fairness.

243
00:17:52,520 --> 00:17:54,980
这一切都取决于内核，
It is all up to the kernel

244
00:17:55,040 --> 00:17:58,640
以任何它想要的方式对 PLIC 进行编程。
to program the PLIC in whatever way it wants.

245
00:17:59,330 --> 00:18:05,120
PLIC 不是真的选择传送中断服务，[写入它们]，
You know PLIC doesn't really, choosing service of delivering interrupted [writing them],

246
00:18:05,120 --> 00:18:09,980
但是从内核程序获取[]，将中断传递到哪里，等等。
but it takes the kernel programs [] [] where interrupts should be delivered, etc.

247
00:18:10,460 --> 00:18:12,680
实际上，有优先级的中断，
In fact, you know interrupts with priorities,

248
00:18:12,740 --> 00:18:16,700
内核可以决定哪个中断比另一个中断更重要，
the kernel could decide which interrupt is more important than another interrupt,

249
00:18:16,700 --> 00:18:18,320
这里有很大的灵活性。
there's a huge amount of flexibility.

250
00:18:26,370 --> 00:18:28,230
关于硬件的任何其他问题？
Any other questions about the hardware?

251
00:18:33,930 --> 00:18:34,560
好的。
Okay.

252
00:18:37,640 --> 00:18:39,380
好的，这就是它的硬件方面，
Okay, so that's the hardware side of it,

253
00:18:39,470 --> 00:18:43,370
让我们从高层次上谈一下软件方面的问题。
you know let's talk a little bit you know, at a high level about the software side.

254
00:18:44,360 --> 00:18:50,150
通常情况下，管理设备的代码称为驱动程序。
So, typically the code that manages devices called the driver.

255
00:19:00,230 --> 00:19:04,730
你知道，基本上就是代码，
And you know basically these just just code,

256
00:19:04,760 --> 00:19:09,140
通常内核查看 C 代码，
you know typically in kernels, the kernels will be looking at C code

257
00:19:09,260 --> 00:19:13,580
在 xv6 中，所有的驱动程序都在内核内部，
and in xv6, you know all the drivers are inside of the kernel

258
00:19:13,820 --> 00:19:19,800
这些用于管理的代码就是驱动程序，
and the code, you know basically managing were the drivers

259
00:19:20,070 --> 00:19:21,810
都在内核内部。
are all inside of the kernel.

260
00:19:22,580 --> 00:19:25,880
所以我们今天来看一下，
And so we got one we're gonna be looking a little bit today,

261
00:19:25,880 --> 00:19:29,870
你知道 uart.c 是 UART 芯片的驱动程序。
you know uart.c is the driver for uart chip.

262
00:19:30,860 --> 00:19:37,100
如果你看一下代码的内部结构，
And if you look at the structure, internal structure of the that code,

263
00:19:37,100 --> 00:19:40,670
大多数驱动都有一种结构。
you know most drivers have a structure.

264
00:19:41,350 --> 00:19:42,640
我来画一下，
Yeah I'm gonna draw this,

265
00:19:42,940 --> 00:19:45,670
不是作为地址空间，不是使用地址空间，
not as an address space, are not intending to be using address space,

266
00:19:45,670 --> 00:19:47,530
但通常情况下，当人们谈论驱动时，
but typically when people talk about drivers,

267
00:19:47,620 --> 00:19:51,030
会有底部和顶部。
there's a bottom part and the top part.

268
00:19:54,500 --> 00:19:57,590
一般底部是中断处理程序。
And basically the bottom part is the interrupt handler.

269
00:20:03,080 --> 00:20:05,510
所以中断处理程序，当中断进入时，
So when an interrupt handler, when an interrupt comes in,

270
00:20:05,540 --> 00:20:11,000
如果处理器， CPU 启用了中断，中断将会触发，
you know the processor, the CPU has interruption enabled, the interrupt will fire,

271
00:20:11,000 --> 00:20:13,610
处理器随后会看到，
you know, the processor will seeing in a second,

272
00:20:13,610 --> 00:20:17,240
调用该设备的中断处理程序，
will actually call the interrupt handler for that device

273
00:20:17,330 --> 00:20:19,070
就是调用这里的代码。
basically calls into the code here.

274
00:20:19,910 --> 00:20:27,080
并且中断处理程序运行在，任何特定进程的任意上下文中，
And the interrupt handler just runs in, run in any context of any specific process,

275
00:20:27,080 --> 00:20:31,040
就是引发中断的进程。
you know just you know process, just process the interrupt.

276
00:20:32,240 --> 00:20:35,690
驱动程序的顶部是，
The top part, if you will the driver is

277
00:20:35,690 --> 00:20:39,500
是用户进程或者其他内核要调用的，
where user processes or you know the rest of the kernel calls into

278
00:20:39,500 --> 00:20:41,570
比如 console 的例子，
for example and the console case correct

279
00:20:41,570 --> 00:20:44,460
UART 有读写接口，
where UART, there's read/write interface,

280
00:20:46,320 --> 00:20:53,260
是更高级别的代码调用的，
that actually, the higher level code actually calls into

281
00:20:53,680 --> 00:20:57,400
通常情况下，在驱动程序中经常会有一些队列，
and so typically cases actually there's some queue often in the driver

282
00:20:57,610 --> 00:21:05,890
顶部代码调用，将字符放入队列中，
and you know top level code, you know calls in, sticks you know characters into into this queue

283
00:21:05,890 --> 00:21:08,500
而中断处理程序放入或，
and the interrupt handler, you know puts or,

284
00:21:08,890 --> 00:21:10,360
根据发送或接收，
depending on sending or receiving,

285
00:21:10,360 --> 00:21:11,980
如果是接受，
but if it's a receiving,

286
00:21:11,980 --> 00:21:17,100
也许中断处理程序也会将字符放入队列中。
maybe interrupt handler else will stick actually a character's into queues.

287
00:21:17,850 --> 00:21:22,410
我们会看到，使用这些队列可以使顶部和底部解耦，
We'll see you have these queues are basically used to decouple the top and the bottom part from each other

288
00:21:22,770 --> 00:21:27,750
并且允许设备与 CPU 上的其他代码并行运行。
and allowing the device to run in parallel with the rest of the code on the CPU.

289
00:21:30,150 --> 00:21:33,990
中断处理程序，通常对中断处理程序有一些限制，
And the interrupt handler, typically there are some restrictions on the interrupt handler,

290
00:21:33,990 --> 00:21:35,760
因为它们运行在任何上下文中，
because those are run in any context,

291
00:21:35,760 --> 00:21:40,380
在你可以调用 copyin 或 copyout 的进程上下文中，
you know any process context, generally you can call copyin or copyout,

292
00:21:40,590 --> 00:21:43,860
因为当前页表，
because you know the current page table

293
00:21:43,860 --> 00:21:47,370
可能不是对应页表，
might actually not be reflective of the page table

294
00:21:47,370 --> 00:21:50,130
进程的字符应该[复制]。
that's a process to which character should be copied.

295
00:21:50,960 --> 00:21:56,090
所以驱动程序的上部，通常与用户进程进行交互，
And so it's the upper part of the driver generally does the interaction with user level processes

296
00:21:56,090 --> 00:21:58,220
可能调用 copyin 或 copyout 。
and maybe called copyin the copyout.

297
00:22:01,280 --> 00:22:04,880
对这张高级别（示例）图片有什么问题吗？
Any questions about this high level picture?

298
00:22:07,630 --> 00:22:09,880
我们会更详细地研究它，
We'll look at it in quite a bit more detail,

299
00:22:09,910 --> 00:22:15,200
但这是典型驱动程序的主要组织方式，
but this is sort of the main organization of a typical driver,

300
00:22:15,470 --> 00:22:18,860
如果你注意到，操作系统中有很多驱动程序，
if you're going to realize, you know there are many drivers in an operating system,

301
00:22:18,860 --> 00:22:28,220
实际上，有些驱动程序代码比内核本身要大是很常见的。
in fact, it's quite common, that you know some of the driver code is quite bigger or larger than the core kernel itself.

302
00:22:29,060 --> 00:22:32,900
最主要的原因是，对于每个设备，你需要一个驱动程序。
And mostly because for every device, you need to drive-, you need a driver.

303
00:22:33,720 --> 00:22:35,850
而且大多数计算机都有很多设备。
And most computers have a lot of devices.

304
00:22:42,520 --> 00:22:45,670
好的，让我们来谈谈对设备编程。
Okay, so let's talk a little bit about programming devices.

305
00:22:55,280 --> 00:22:59,270
通常，设备编程使用内存映射 IO 。
And so typically programming is done using memory mapped IO.

306
00:23:06,450 --> 00:23:11,190
正如我们在 RISC-V 或 SiFive 电路板上看到的，
So as we've seen in in RISC-V or in the SiFive board,

307
00:23:11,190 --> 00:23:18,570
设备出现在物理地址空间的特定地址，
you know, devices show up at particular addresses in the physical address space,

308
00:23:18,570 --> 00:23:22,170
这是由设备电路板制造商决定。
this is decided by the device board manufacturer.

309
00:23:22,770 --> 00:23:24,630
操作系统需要知道，
And you know operating system needs to know,

310
00:23:24,630 --> 00:23:29,700
这些设备位于物理内存空间中的哪个位置，
what those were those devices are located in the physical memory space,

311
00:23:29,910 --> 00:23:31,740
然后对它们进行编程，
and then basically programs them,

312
00:23:31,740 --> 00:23:38,250
对这些地址使用普通的加载存储指令。
using ordinary load and store instructions to those addresses.

313
00:23:39,000 --> 00:23:42,960
这些加载存储指令所做的是，
But basically what these load store instructions do is

314
00:23:43,020 --> 00:23:54,530
它们读或写设备的控制寄存器。
they they read or write, read or write control registers of the device.

315
00:24:00,200 --> 00:24:04,550
所以，当你在其中一个控制寄存器中存储某些内容时，
And so typically when you store something in one of the control registers

316
00:24:04,670 --> 00:24:06,290
发送你的数据包，
that causes your packet to be sent,

317
00:24:06,290 --> 00:24:08,060
所以不是读或写内存，
so instead of reading, writing memory,

318
00:24:08,120 --> 00:24:10,850
这些加载存储指令通常具有副作用，
these load store instructions typically have side effects,

319
00:24:10,880 --> 00:24:13,280
引起设备做某些事。
the cause of the device to do something.

320
00:24:15,080 --> 00:24:18,710
你必须查看设备文档，
And you know you have to look basically the documentation of the device

321
00:24:18,710 --> 00:24:20,840
才能弄清楚这个设备是做什么的。
to actually figure out what the device does.

322
00:24:21,360 --> 00:24:24,930
有时候文档非常清楚，
And you know sometimes this documentation is very clear,

323
00:24:24,990 --> 00:24:26,880
有时候文档不太清楚。
sometimes this documentation is less clear.

324
00:24:27,430 --> 00:24:30,850
这里给你一个小的示例。
This should give you a little bit of a sample, the.

325
00:24:32,630 --> 00:24:34,460
在这里我想给你们看两样东西，
Two things I wanted to show you in here,

326
00:24:34,550 --> 00:24:37,940
在屏幕的右侧，
on the right side of the screen,

327
00:24:38,180 --> 00:24:45,470
你可以看到 SiFive 电路板的物理内存映射空间，
you see the memory map, physical memory map space, you know for the SiFive board,

328
00:24:45,830 --> 00:24:49,370
你可以看到特定事物映射的地址是什么，
and you see what the addresses are where particular things are mapped,

329
00:24:49,490 --> 00:24:53,330
它们出现在物理地址空间中的位置，
where they show up in the physical address space to use the [] map

330
00:24:53,330 --> 00:24:55,460
它们实际出现在物理地址空间的位置。
where they actually show up in the physical address space.

331
00:24:56,050 --> 00:25:01,180
比如， CLINT 在 0x0200 。
And so, for example we see the CLINT you know is there at 0x0200.

332
00:25:01,540 --> 00:25:06,430
我们再挑一个。
We we pick out another one.

333
00:25:07,400 --> 00:25:08,900
PLIC 也在那里的某个地方，
The PLIC was somewhere there too,

334
00:25:08,900 --> 00:25:12,200
好的，这里是 PLIC ，在 0x0C00 ，
okay, here's the PLIC at 0x0C00,

335
00:25:12,200 --> 00:25:17,510
这是平台中断控制器，
that's the platform platform the interrupt controller,

336
00:25:17,510 --> 00:25:21,970
我们看到 UART0 在这个特定地址，
and you know we see actually UART0 here at this particular address,

337
00:25:22,060 --> 00:25:26,590
实际上，在我们使用的 QEMU 上，
that turns out that on the QEMU that we're using

338
00:25:26,590 --> 00:25:31,270
UART 实际上在另一个位置。
use has to UART actually at a different location.

339
00:25:31,960 --> 00:25:35,200
那是因为我们使用 QEMU ，
You know, that's because we use QEMU

340
00:25:35,200 --> 00:25:38,080
并不是完全模仿 SiFive 电路板，
doesn't actually literally emulate the SiFive board,

341
00:25:38,080 --> 00:25:40,120
而是跟 SiFive 电路板很相似。
but something that's very close to the SiFive board.

342
00:25:41,610 --> 00:25:42,960
好的，这就是内存映射，
Okay, so that's the memory map,

343
00:25:43,110 --> 00:25:50,100
从物理地址到设备的内存映射。
memory map, you know physical addresses, you know to to devices.

344
00:25:51,550 --> 00:25:54,790
然后，在左边，
And then, on the left side,

345
00:25:54,820 --> 00:26:00,790
是 UART 文档的一部分。
is piece of documentation for UART.

346
00:26:01,950 --> 00:26:08,170
这是 16550 ，
This is the 1655-, 16550,

347
00:26:08,170 --> 00:26:12,640
这是位于 QEMU 上模拟的 UART 芯片，
that's actually UART chip that sits on the QEMU emulates,

348
00:26:12,640 --> 00:26:20,560
我们用来与键盘和控制台交互，
that we're using to actually interact with keyboard and console

349
00:26:20,620 --> 00:26:23,080
这是一个很简单的芯片，
and you know this is a reasonable simple chip,

350
00:26:23,080 --> 00:26:26,260
这个设备并没有太多的功能，
there's not actually much going on in this device,

351
00:26:26,290 --> 00:26:29,080
即便如此，它们还是有点复杂。
there's even then they're sort of complications.

352
00:26:29,260 --> 00:26:32,330
在这张表中，
Here on the this table here,

353
00:26:33,160 --> 00:26:38,440
显示了芯片拥有的寄存器，控制器寄存器，
it shows the registers that the chip has, the controller registers

354
00:26:38,440 --> 00:26:41,440
比如，控制寄存器 0 0 0 ，
as for example, you know control register zero zero zero

355
00:26:41,740 --> 00:26:44,260
当你执行加载指令时，
in when you're doing load instruction,

356
00:26:44,350 --> 00:26:47,290
它将持有数据，
it holds, it's will hold the data,

357
00:26:47,650 --> 00:26:49,420
如果执行存储指令，
if you do store instruction,

358
00:26:49,630 --> 00:26:52,690
寄存器会，数据会复制进来，
that's the register, that will basically, the data will be copied into

359
00:26:52,690 --> 00:26:55,090
传输到线路之外，
to be transmitted, you know, outside of the wire,

360
00:26:55,210 --> 00:27:04,880
UART 是一种允许你通过串行线发送比特的设备，
UART basically a device that allows you to send bits over a serial line,

361
00:27:04,880 --> 00:27:08,330
发送是一条线路，接收是另一条线路，
sent line is one line and the received line is another line,

362
00:27:09,590 --> 00:27:11,810
基本上，你取一个字节
basically you take a byte

363
00:27:11,810 --> 00:27:17,480
它们在这一条线上是多路复用或串行化的，
and you know basically they're multiplex or serialized on this single line

364
00:27:17,780 --> 00:27:19,130
送到另一边，
sent over to the other side,

365
00:27:19,130 --> 00:27:21,050
有一个 UART 芯片在另一边，
there's UART chip sitting on the other side

366
00:27:21,050 --> 00:27:24,670
将比特组装回单个字节。
and basically assembles the bit back into a single byte.

367
00:27:25,780 --> 00:27:29,410
你还可以在这个设备上，控制其他几件事情，
And a couple other things that you can control on this device,

368
00:27:29,590 --> 00:27:36,970
你可以一定程度上控制设备的波特率，
you can actually control the baud rate of the device, to some degree,

369
00:27:37,180 --> 00:27:46,530
对我们来说最重要的可能是寄存器 1 ，
and you know probably most important for us is register register one

370
00:27:46,590 --> 00:27:49,530
在这里，是中断启用寄存器，
which is here which is the interrupt enable register

371
00:27:49,620 --> 00:27:51,630
我们可以对它编程，
and so we can program it

372
00:27:51,630 --> 00:27:55,110
使 UART 生成中断。
to actually cause UART to generate interrupts.

373
00:27:57,640 --> 00:27:59,500
向下滚动，
So, in particular scroll down,

374
00:27:59,500 --> 00:28:02,710
在这份文档中，你会看到。
this document you'll see that the.

375
00:28:03,900 --> 00:28:04,860
向下滚动一点，
Scroll down a bit,

376
00:28:04,860 --> 00:28:10,980
文档更详细地描述了每个寄存器中的每一位的含义，
the document actually more detail basically describe what every bit in every register means,

377
00:28:10,980 --> 00:28:18,060
比如，在中断启用寄存器 IER 中，
in for example in the interrupt enable register IER register, which the abbr name for it,

378
00:28:18,360 --> 00:28:21,510
有接收行状态中断，
you know that basically this is a receive line state interrupt

379
00:28:21,570 --> 00:28:24,690
和传输保持状态中断。
and transmit holding register interrupt.

380
00:28:25,030 --> 00:28:26,890
这是这些位的含义。
So that's what the bits mean.

381
00:28:27,500 --> 00:28:31,010
它还有很多，有更多的文档，
It goes on and on, there's a lot more documentation

382
00:28:31,010 --> 00:28:35,000
告诉你寄存器的更多细节，
and that tells you what the more detailed the registers are,

383
00:28:35,000 --> 00:28:37,700
如何在轮询模式或中断模式下使用它，
how you can use it in polling mode or interrupt mode,

384
00:28:37,700 --> 00:28:39,200
我们会多谈一点，
we'll talk about a little bit more,

385
00:28:39,230 --> 00:28:43,700
如何对启用寄存器等进行编程，等等。
you know how, how you have to program the enable registers etc etc.

386
00:28:43,730 --> 00:28:47,750
这是真实文档的一个简短版本，
So it turned out to be a short version of the real documents,

387
00:28:47,750 --> 00:28:50,900
真正芯片制造商的文档要多得多，
you know the real documents where the chip manufacturers much more,

388
00:28:51,240 --> 00:28:54,090
有更多的内容和更多的细节，
has much more stuff in it and much more detail

389
00:28:54,330 --> 00:28:58,290
这个对我们谈论 UART 编程足够了。
and it's sufficient for us to actually be able to talk about how the program UART.

390
00:28:59,100 --> 00:29:01,440
你可以看到，这是最简单的设备之一，
And you can see, this is like one of the most simple devices

391
00:29:01,440 --> 00:29:04,380
即使那份文档，它也相当复杂。
and even that document you know it's quite a bit to it.

392
00:29:10,050 --> 00:29:13,620
抱歉，我想知道，如果你写入，
Sorry, I was wondering, if you're writes,

393
00:29:13,650 --> 00:29:19,000
如果你将某些内容写入传输保持寄存器，
so if you write something to the transmit holding register

394
00:29:19,300 --> 00:29:22,930
然后你再写一遍，在那之后，
and then you write again like write after that,

395
00:29:23,400 --> 00:29:31,940
它是不是确保了之前的数字不会被覆盖。
it makes sure that like the previous number didn't just like get over written, right.

396
00:29:32,120 --> 00:29:36,170
是或不是，这是你来决定的，
Yes, or no, it's part of you,

397
00:29:36,170 --> 00:29:39,380
实际上这是我们要关注的一件事，
actually this is one of the things that we're going to pay a bit of attention to,

398
00:29:39,740 --> 00:29:43,910
你告诉，加载指令加载一些值，
the you tell, basically load instruction load some value

399
00:29:43,910 --> 00:29:45,860
或存储指令将一些值加载到寄存器中，
or store instruction load some value in that register

400
00:29:46,100 --> 00:29:51,330
然后， UART 芯片继续，
and then the, the UART chip goes of

401
00:29:51,330 --> 00:29:55,620
它会把那个字节发送到串行线路上，
and it's going to send of that that byte onto the line, on the serial line right,

402
00:29:56,040 --> 00:29:57,960
当它完成时，
and when it's done,

403
00:29:58,140 --> 00:30:00,750
它将生成一个中断，告诉内核，
it will generate an interrupt saying to the kernel,

404
00:30:00,750 --> 00:30:01,890
好了，完成了那个字节，
okay, I'm done with that byte,

405
00:30:01,920 --> 00:30:03,330
现在你可以给我下一个字节了。
now you can give me the next byte.

406
00:30:04,300 --> 00:30:07,270
因此内核和设备必须遵循一个协议，
And so the kernel and the device has to follow a protocol

407
00:30:07,270 --> 00:30:09,190
以确保一切都能顺利解决。
to make sure that actually everything works out.

408
00:30:10,340 --> 00:30:13,130
这个我们使用的 UART ，
This particular, UART you know that we're using

409
00:30:13,130 --> 00:30:20,330
16550A 实际上内部有一个 FIFO ，
has, 16550A actually internally has a FIFO

410
00:30:20,360 --> 00:30:23,060
我想它可以缓冲一些字符，
and I think it can buffer a bunch of characters,

411
00:30:23,060 --> 00:30:24,410
我想最多是 16 个字符。
like I think up to sixteen.

412
00:30:25,560 --> 00:30:27,720
但是你仍然要玩这个游戏，
But you still have to play this game of

413
00:30:27,720 --> 00:30:30,720
你不能放入超过 16 个字符，
like you can't stick more than sixteen characters into it

414
00:30:30,720 --> 00:30:34,890
在设备告诉你已经发送了一个字符之前。
until the device actually has told you well, I've sent one character.

415
00:30:37,270 --> 00:30:38,110
这能理解吗？
Does that make sense?

416
00:30:39,130 --> 00:30:40,600
是的，谢谢。
Okay, yeah, thank you.

417
00:30:41,780 --> 00:30:43,610
我们会再多说一点，
So we'll talk a little bit more,

418
00:30:43,640 --> 00:30:48,020
在看更多细节之前，
before we do look a little more detail,

419
00:30:48,170 --> 00:30:54,380
我们要看的个例研究，
you know, you know the case study, you know that we going to go through

420
00:30:54,650 --> 00:30:58,610
为了解释设备和中断是如何工作的，
for a sort of explaining how devices and interrupts work

421
00:30:58,610 --> 00:30:59,840
是 $ ls，
is here's $ ls,

422
00:30:59,840 --> 00:31:03,750
你知道这里发生了什么。
you know what happens when the.

423
00:31:04,660 --> 00:31:06,850
实际上是如何打印的，
You know how actually how you print

424
00:31:06,910 --> 00:31:08,710
发生的事情是，
and so basically what happens is

425
00:31:08,710 --> 00:31:12,550
就像我们刚才讨论的那样，
that the device as we actually discussed in the second go,

426
00:31:12,670 --> 00:31:18,180
在本例中，基本上就是把 $ 符放入 UART ，
basically puts the character of the $ in this case you know into the UART,

427
00:31:18,390 --> 00:31:20,910
实际上，是我们刚看过的寄存器中。
in fact in the register that we just looked at.

428
00:31:21,560 --> 00:31:26,210
然后 UART 产生中断，
And then the UART generates interrupt,

429
00:31:26,540 --> 00:31:28,610
我们可以设置，
the way we can set things up,

430
00:31:28,670 --> 00:31:33,700
当发送字符时产生一个中断。
generates an interrupt, when the when the character has been sent.

431
00:31:42,140 --> 00:31:43,910
然后在另一边，
And then on the other side

432
00:31:43,910 --> 00:31:46,940
所以 QEMU 中的事情是这样设置的，
and so basically, the way things are set up in QEMU

433
00:31:46,940 --> 00:31:49,010
QEMU 在一个在发送线上，
and QEMU is on the sent line,

434
00:31:49,040 --> 00:31:51,470
在发送线路的另一边，
on the other side of the sent line,

435
00:31:51,470 --> 00:31:53,630
通常是另一个 UART 芯片，
it usually sits in another UART chip

436
00:31:53,630 --> 00:31:56,750
它连接到控制台，
and that actually connects to the console

437
00:31:56,750 --> 00:31:59,570
连接到一个虚拟控制台。
to the virtual you knows a virtual console.

438
00:32:00,370 --> 00:32:03,280
另一方面，你知道 ls 会发生什么，
On the other side, you know what happens in ls,

439
00:32:03,960 --> 00:32:06,210
我们需要使用输入，
is we need to use input

440
00:32:06,240 --> 00:32:10,080
所以，键盘实际上连接到接收的线路，
and so the keyboard actually is connected to the receive line,

441
00:32:15,880 --> 00:32:17,320
接收线。
um, receive line.

442
00:32:18,490 --> 00:32:21,700
基本上就是键盘，
And, so basically the keyboard,

443
00:32:21,700 --> 00:32:23,560
你按了键盘上的一个键，
you know you hit a key on the keyboard,

444
00:32:23,560 --> 00:32:26,440
在本例中的虚拟键盘，
keyboard, virtual keyboard in this case,

445
00:32:26,680 --> 00:32:29,020
另一边的 UART 芯片，
you know, UART chip on that side,

446
00:32:29,020 --> 00:32:33,340
会序列化字符 l ，
you know will serialize you know the character l,

447
00:32:33,340 --> 00:32:34,780
把它发送给另一边的 UART ，
send it to UART, on the other side,

448
00:32:34,780 --> 00:32:40,180
另一边把位放在一起变成一个字节，
the other side, you know put the you know the bits, you know together again into one byte

449
00:32:40,450 --> 00:32:42,910
然后产生中断，
and then generate an interrupt,

450
00:32:45,080 --> 00:32:47,960
生成中断告知处理器，
generate an interrupt to tell the processor,

451
00:32:47,960 --> 00:32:51,510
嘿，键盘上有一个字符可用。
hey there's a character available from the keyboard.

452
00:32:53,320 --> 00:32:57,160
在中断处理程序中，收到 UART 的字节，
In the interrupt handler, the interrupt handle reach the byte from the UART

453
00:32:57,190 --> 00:32:58,120
正如我们稍后看到的，
as we'll see in a second,

454
00:32:58,480 --> 00:33:00,970
所以，这里有两个事情需要理解，
so those are two things that we want to understand

455
00:33:00,970 --> 00:33:03,520
更详细地了解它们是如何工作的。
more detail actually how they work.

456
00:33:05,910 --> 00:33:06,690
好的?
Okay?

457
00:33:07,110 --> 00:33:08,250
这个有什么问题吗？
Any questions about this?

458
00:33:13,720 --> 00:33:19,530
好的， RISC-V 有一系列的支持，
Okay, so, the RISC-V has a bunch of support,

459
00:33:23,600 --> 00:33:25,130
对中断的支持。
support for interrupts.

460
00:33:34,380 --> 00:33:40,050
我们会更详细地了解一些会使用的寄存器的细节，
And numbers of registers, you know we'll see in more detail as we could use,

461
00:33:40,050 --> 00:33:42,030
但是知道有哪些是有用的，
but it's useful to know which ones there are,

462
00:33:42,150 --> 00:33:48,630
这是 SIE ，管理程序中断启用寄存器，
there's the SIE, supervisor interrupt enable register

463
00:33:48,810 --> 00:33:56,220
它有一位，用于外部中断，
and that has a bit, one bit for external interrupts,

464
00:33:56,400 --> 00:33:58,020
来自设备，比如 UART ，
from devices, like the UART,

465
00:33:58,320 --> 00:34:02,790
来自软件中断，这一点我会讨论一下，
from software interrupts, which I'm really going to talk about it,

466
00:34:02,790 --> 00:34:06,870
但这是可能的，从一个 RISC-V 核心
but it is possible from one CPU from one RISC-V cores

467
00:34:06,870 --> 00:34:09,480
向另一个 RISC-V 核心发送中断，
to send an interrupt to another RISC-V core,

468
00:34:10,070 --> 00:34:12,560
还有定时器中断。
and timer interrupt.

469
00:34:14,740 --> 00:34:20,950
我不准备谈论管理者模式的软件中断或计时器中断，
And I'm not really going to talk about either you know the supervisor of the software interruption or the timer interrupts,

470
00:34:20,950 --> 00:34:22,420
而是重点放在外部中断。
are going to focus on external interrupts.

471
00:34:23,340 --> 00:34:26,220
还有另一个我们见过的寄存器，
There's another register that we've seen before,

472
00:34:26,220 --> 00:34:29,610
管理者状态寄存器，
the supervisor status register,

473
00:34:30,480 --> 00:34:39,740
它有一个位用来禁用和启用特定内核上的中断。
and that has a bit to disable and enable interrupts on this particular core.

474
00:34:41,720 --> 00:34:45,290
所以，每个核心都有这些寄存器，
So every core has you know these registers

475
00:34:45,320 --> 00:34:48,830
除了这三个位之外，
and there's, in addition to these three bits,

476
00:34:48,830 --> 00:34:54,020
对于每个控制，你有外部中断、软件中断、计时器中断，
for individual control, when you want to have external interrupts, software interrupt, timer interrupt,

477
00:34:54,230 --> 00:34:57,650
有一个位可以控制收到的中断，
there's one bit that controls you're going to receive interrupts at all,

478
00:34:57,800 --> 00:35:02,450
所以，你可以原子地从没有中断切换到可以中断，
so you can atomicly switch from not getting interrupts to having interrupted,

479
00:35:02,450 --> 00:35:03,320
反之亦然，
the other way around,

480
00:35:03,380 --> 00:35:07,140
只需要修改 SSTATUS 寄存器中的这一位。
just changing that one bit in the SSTATUS register.

481
00:35:08,660 --> 00:35:11,130
然后是 SIP 寄存器，
And then there's a SIP register

482
00:35:11,130 --> 00:35:15,330
称为管理程序中断挂起寄存器，
are the called the supervisor interrupt pending register,

483
00:35:21,020 --> 00:35:22,970
基本上进程可以使用它，
and basically the process you can use that

484
00:35:23,030 --> 00:35:25,220
当中断发生，
you know want to interrupt it happened,

485
00:35:25,220 --> 00:35:30,650
查看 SIP ，看是什么中断。
look at the SIP to see what, what interrupt actually has come in.

486
00:35:31,220 --> 00:35:35,150
另外，当中断发生时，
And in addition, there will be even interrupt happens,

487
00:35:35,450 --> 00:35:39,020
在 SCAUSE 寄存器，我们之前已经看过几次，
in the SCAUSE register, we should that we have seen a couple times before now,

488
00:35:40,160 --> 00:35:45,530
将会出现一个进入的中断的指示，我们随后会看到，
there will be an indication of one interrupt actually came in, we'll look in the second

489
00:35:46,040 --> 00:35:48,350
当然还有 STVEC 寄存器，
and of course there's the STVEC register,

490
00:35:48,650 --> 00:35:54,020
保存程序，或处理器切换的地址，
basically holds the program or address to which the processors switch

491
00:35:54,230 --> 00:35:59,630
当 trap 系统调用，
once either trap or trap system call

492
00:35:59,630 --> 00:36:02,660
或发生页面错误，产生中断，
or page fault happens when an interrupt happens,

493
00:36:02,690 --> 00:36:05,720
因为这三种情况都使用相同的机制。
because basically uses for all three cases the same mechanism.

494
00:36:06,160 --> 00:36:09,310
我不会说太多关于 SCAUSE 和 STVEC ，
I'm not gonna talk too much about SCAUSE and STVEC,

495
00:36:09,310 --> 00:36:12,970
因为我们之前已经详细看过了，
because we've seen it in detail before,

496
00:36:13,390 --> 00:36:18,370
基本上以相同的方式运行，
and basically operates exactly in the same way

497
00:36:18,370 --> 00:36:26,770
与页面错误或其他异常的系统调用一样。
as as system calls in page faults or other exceptions.

498
00:36:30,080 --> 00:36:34,280
好的，让我们来看看，
Okay, so let's see a little bit of sense,

499
00:36:34,460 --> 00:36:36,890
这些东西是如何初始化的，
how this stuff is sort of initialized,

500
00:36:37,070 --> 00:36:40,820
我们不会谈论驱动的实际工作方式，
so we're not talking even about how the drivers actually work,

501
00:36:40,820 --> 00:36:43,220
而是看看 xv6 程序是如何对它编程，
but just see how xv6 programs this,

502
00:36:43,670 --> 00:36:48,710
设置这些寄存器，让我们处于中断的位置。
these registers set we're going to be in a position to take a interrupt.

503
00:36:50,030 --> 00:36:53,300
聊天中有一个问题，确认一下。
These's a question from the chat, make sure that.

504
00:37:03,140 --> 00:37:04,160
好的，
Alright, okay.

505
00:37:04,970 --> 00:37:06,170
聊天有点落后，
A little behind on the chat,

506
00:37:06,290 --> 00:37:13,490
那么让我们来看一下， xv6 如何对寄存器编程，
so let's see a little bit on the what, xv6 programs registers,

507
00:37:13,790 --> 00:37:16,130
所以找出一些代码。
so pull up some code.

508
00:37:16,920 --> 00:37:24,930
让我跳出这个这个窗口，
Let me get rid of the this window,

509
00:37:24,930 --> 00:37:26,610
其实我也不需要这个。
actually I don't really need that either.

510
00:37:26,940 --> 00:37:30,420
我不打算使用 gdb 来遍历代码，
I'm not going to run use gdb to walk through things,

511
00:37:30,420 --> 00:37:34,560
我只想看看相关的特定函数。
I'm just going to look at you know particular functions that are relevant.

512
00:37:35,140 --> 00:37:38,350
所以，第一件事可能是在 start.c 中，
So probably the first thing is in start.c.

513
00:37:38,380 --> 00:37:41,290
当机器启动时，处理器启动时，
So when the machine boots, what processor boots,

514
00:37:41,780 --> 00:37:46,810
start 函数被调用，
the the start function is called,

515
00:37:46,810 --> 00:37:48,430
它以 M 模式运行，
its runs in the M mode,

516
00:37:48,460 --> 00:37:52,750
它禁用了页表，
and it disables paging,

517
00:37:53,350 --> 00:37:57,190
因为很快，稍后，
so right away, because you know sort of later on,

518
00:37:57,190 --> 00:37:58,750
内核可以设置页表，
the kernel can set up the page tables

519
00:37:58,960 --> 00:38:00,130
我们在这里看到，
and we see here that

520
00:38:00,130 --> 00:38:04,450
将所有中断和异常交给管理者模式，
basically delegates all interrupts and exceptions to supervisor mode,

521
00:38:04,780 --> 00:38:11,200
然后，对管理者中断启用寄存器编程，
then it's programs the supervisor enable interrupt enable register

522
00:38:11,200 --> 00:38:17,390
用来接受软件中断，定时器中断，以及外部中断。
to take software interrupts, timer interrupts, and external interrupts.

523
00:38:18,500 --> 00:38:21,080
然后为了更好的[衡量]，
And then for good [measure],

524
00:38:21,080 --> 00:38:26,810
定时器中断发生在 M 模式，
timer interrupts actually happened to coming to are handled in M mode,

525
00:38:27,110 --> 00:38:35,000
M 模式代码对定时器寄存器编程，
the M mode code, actually programs, the timer registers

526
00:38:35,120 --> 00:38:39,230
然后产生计时器中断。
and so that timer timer interrupts are generated.

527
00:38:40,080 --> 00:38:41,700
我不想讨论这个，
I don't want to talk about that actually,

528
00:38:41,730 --> 00:38:43,440
所以，我要去看 main.c 。
so I'm gonna go to main.c.

529
00:38:46,980 --> 00:38:50,580
看看外部设备是如何处理的，
And so see how external devices are handled

530
00:38:50,610 --> 00:38:54,870
我们的第一个外部设备是可以打印的 console 。
and so our first external devices is the console where we print to.

531
00:38:55,440 --> 00:38:57,930
我们可以看看 consoleinit 做了什么。
And we can see what consoleinit does.

532
00:38:59,520 --> 00:39:01,440
这是 consoleinit ，
So here's consoleinit,

533
00:39:01,560 --> 00:39:07,200
初始化锁，实际上我们不关心这个，
initialize lock, we actually care not much about that at all,

534
00:39:07,200 --> 00:39:08,820
它不是这节课（的内容），
it's not for this lecture,

535
00:39:08,880 --> 00:39:12,090
它调用了 uartinit 。
and it actually basically calls that uartinit.

536
00:39:12,840 --> 00:39:16,890
uartinit 在这里。
And uartinit is right here.

537
00:39:18,380 --> 00:39:23,030
它设置了 UART 芯片，
It actually sets up the uart chip,

538
00:39:23,030 --> 00:39:25,310
配置要使用的 UART 芯片。
configure uart chips that is ready for use.

539
00:39:25,740 --> 00:39:28,500
首先是禁用中断，
You know first actually disables interrupts,

540
00:39:28,500 --> 00:39:29,670
你知道有一个顺序，
you know there's the sequence,

541
00:39:29,670 --> 00:39:31,500
当你对它编程时，必须遵守，
you have to go through when you program it,

542
00:39:31,890 --> 00:39:35,280
然后，你可以设置波特率，
then you can set the baud rate,

543
00:39:35,310 --> 00:39:38,460
然后设置 6 7 位，
then you set in six you know seven bits,

544
00:39:38,460 --> 00:39:41,190
7 位或 8 位[修复] UART 。
you know seven or eight bit bits will [repaired] uart.

545
00:39:43,080 --> 00:39:51,090
然后，重新设置 UART 的内部 FIFO ，
And, you reset the internal FIFO that's uart has

546
00:39:51,090 --> 00:39:53,850
清除那里可能存在的任何东西，
to clear out anything that actually might be in there

547
00:39:54,000 --> 00:39:56,910
然后，接收到，
and then, will receive,

548
00:39:56,910 --> 00:40:00,780
它将启用传输中断和接收中断。
it will enable interrupts for transmission and receive interruption.

549
00:40:02,890 --> 00:40:04,930
Amir ，我想你举手了。
Amir, I think you raise your hand.

550
00:40:07,140 --> 00:40:09,690
是的，我想知道波特率是什么。
Yeah, I'm wondering what the baud rate is exactly.

551
00:40:09,990 --> 00:40:12,540
哦，是线路运行的速度。
Oh the speed which you know the lines runs.

552
00:40:14,740 --> 00:40:16,360
我知道了，谢谢。
I see, thanks.

553
00:40:20,510 --> 00:40:21,890
好的，那就是 uartinit 。
Okay, so that's uartinit.

554
00:40:21,950 --> 00:40:27,410
现在，原则上 UART 可以生成中断，
Now at this point you know the uart in principle can generate interrupts,

555
00:40:27,530 --> 00:40:31,340
但是当然我们还没有对中断启用寄存器编程，
but of course we are we haven't actually programm the interrupt enabling stuff

556
00:40:31,340 --> 00:40:34,370
在 RISC-V 处理器上，
on the on the RISC-V processor itself,

557
00:40:34,370 --> 00:40:35,870
我们还没有对 PLIC 编程，
we haven't programmed to PLIC yet,

558
00:40:36,020 --> 00:40:39,340
这个时候，什么都不会发生。
nothing really happens at this point yet.

559
00:40:39,340 --> 00:40:42,400
所以下一件事，我们将回到 main.c ，
And so the next thing, we're going to move back to main.c,

560
00:40:42,820 --> 00:40:46,690
我们会看到，向下滚动一点，
you know we'll see, a little bit scroll down,

561
00:40:46,690 --> 00:40:49,090
我们会看到 PLIC 初始化，
we'll see actually that the PLIC is initialized,

562
00:40:49,330 --> 00:40:50,590
让我们来看看这个。
so let's look at that.

563
00:40:52,540 --> 00:40:56,480
基本上， plicinit 代码，
And basically, you know, plicinit code,

564
00:40:56,660 --> 00:41:00,590
如果看一下我刚才给你的这张表格，
if you look at this table that I showed you a little while ago,

565
00:41:00,590 --> 00:41:03,740
物理内存或内存布局，
with the physical memory or the memory layout,

566
00:41:03,740 --> 00:41:07,730
你知道， PLIC 在某个特定的位置，
you know the PLIC is in some particular location right,

567
00:41:07,730 --> 00:41:09,770
位置在 kernel/memlayout.h 。
location is in kernel/memlayout.h.

568
00:41:10,340 --> 00:41:13,550
我们看到 PLIC 是 0C000000 ，
We see the PLIC 0C000000 correct,

569
00:41:13,550 --> 00:41:15,200
字面上是从那份文档复制过来的。
literally copied from that document.

570
00:41:15,890 --> 00:41:18,620
我们向 PLIC 写东西，
And you know the way we write stuff to the PLIC

571
00:41:18,620 --> 00:41:23,300
使用 PLIC 的地址编号，
is basically you take the number the address for the PLIC

572
00:41:23,600 --> 00:41:28,460
强制转换为 32 整数指针，
cast to a 32 pointer integer,

573
00:41:28,460 --> 00:41:30,590
因为 PLIC 寄存器是 32 位的。
because the PLIC registers are 32 bit.

574
00:41:31,160 --> 00:41:33,140
然后写入，
And then basically write onto it,

575
00:41:33,170 --> 00:41:40,190
这个强制转换是将 1 写入寄存器 UART0_IRQ 。
so this cast is basically one to be written to the register UART0_IRQ.

576
00:41:41,060 --> 00:41:42,800
这个说做的就是，
And basically what this does is

577
00:41:42,800 --> 00:41:45,920
它启用来自 UART 的中断请求，
it enables interrupt requests from the uart,

578
00:41:46,370 --> 00:41:50,720
记得 PLIC 路由中断，
so remember the PLIC basically routes interrupts,

579
00:41:50,720 --> 00:41:54,770
所以中断可能从图片左侧进入 PLIC ，
and so the interrupt might come in from the left side from that picture into the PLIC

580
00:41:54,770 --> 00:41:58,820
这个程序中， PLIC 可以接受这些中断。
and the PLIC, like this program PLIC to actually accept those interrupts.

581
00:42:00,270 --> 00:42:04,740
类似地，对 PLIC 编程，从 IO 磁盘接收中断，
Similarly, actually programs the PLIC to accepting interrupts from the IO disk,

582
00:42:04,770 --> 00:42:06,270
我不会讨论论这个。
which I'm not going to talk about at all.

583
00:42:08,510 --> 00:42:12,530
好的，然后，我们回到 main.c 。
Okay, and then, we go back, you know to main.c.

584
00:42:12,590 --> 00:42:18,580
在 plicinit 之后，是 plicinithart ，
And there right after the plicinit is just plicinithart

585
00:42:18,610 --> 00:42:25,370
针对每个核心，每个独立核心，
and then basically for every cores specifically, every core individually,

586
00:42:25,370 --> 00:42:29,930
只有一个核心，第一个核心初始化该方面，
so only one core, the first core actually initialize this [aspect],

587
00:42:30,170 --> 00:42:32,330
我们接收这些设备的中断，
basically we're taking interrupts on those devices

588
00:42:32,720 --> 00:42:37,280
然后，每个核心都必须单独地说我也对这些设备感兴趣。
and then every core individually has to say I'm interested in those devices too.

589
00:42:37,980 --> 00:42:39,960
比如，在这里，
And so for example here,

590
00:42:40,110 --> 00:42:43,110
每个核心都调用这些函数，
every core actually calls these functions,

591
00:42:43,110 --> 00:42:46,950
每个核心，都对来自 UART 的中断感兴趣，
every cores, interested in interrupt from uart

592
00:42:46,950 --> 00:42:49,800
也对 VIRTIO 的中断感兴趣。
and I'm interested the interrupts from the virtio.

593
00:42:50,730 --> 00:42:53,070
你在这里可以看到 UART0_IRQ ，
You can see here basically the UART0_IRQ,

594
00:42:53,070 --> 00:42:55,920
是一个唯一的数字，
basically is a unique number,

595
00:42:55,920 --> 00:43:00,840
UART_IRQ 在 UART 中，
you know for, the UART_IRQ for in what uart,

596
00:43:00,840 --> 00:43:04,630
我想在 QEMU 上是编号 10 。
and I think believes on the on QEMU number ten.

597
00:43:06,540 --> 00:43:09,180
我们忽略 priority ，
And we're basically ignore priority

598
00:43:09,180 --> 00:43:10,530
所以我们把它设为零。
and so we just set it to zero.

599
00:43:11,880 --> 00:43:15,180
好的，每个 CPU 单独调用，
Okay, and so does every CPU already called individually

600
00:43:15,180 --> 00:43:16,290
必须向 PLIC 表明，
has to indicate to the PLIC,

601
00:43:16,290 --> 00:43:20,220
它对接收中断感兴趣。
that actually is interested in receiving interrupts.

602
00:43:22,290 --> 00:43:25,260
在这一点，你知道 PLIC ，
You know, at this point you know we're you know the PLIC basically,

603
00:43:25,380 --> 00:43:28,230
所以我们必须对设备进行编程以产生中断，
so we basically have to program the device to generate interrupts,

604
00:43:28,230 --> 00:43:33,300
我们对 PLIC 编程在各个 CPU 上传递中断，
we have program to PLIC you know to pass interrupts on the individual CPUs,

605
00:43:33,480 --> 00:43:36,900
但是 CPU 本身还没有接受中断，
but the CPU itself have actually are not accepting interrupt yet,

606
00:43:36,930 --> 00:43:40,650
因为我们还没有设置 SSTATUS 寄存器中的位，
because we haven't set the bit in the SSTATUS register yet

607
00:43:40,650 --> 00:43:44,640
所以，让我们回到 main.c 。
and so let's go back to to main.c.

608
00:43:47,440 --> 00:43:51,160
main.c 做了更多初始化，
And whatever main.c does a bunch of more initialization,

609
00:43:51,160 --> 00:43:52,960
但是，最后它调用了 scheduler 。
but in the end it actually calls the scheduler.

610
00:43:53,940 --> 00:43:55,920
所以，我们来看一下 proc.c ，
So let's look at proc.c,

611
00:43:56,960 --> 00:43:59,330
搜索 scheduler 。
and get scheduler.

612
00:44:04,940 --> 00:44:06,020
我们在这里看到的是，
And what we see here,

613
00:44:06,020 --> 00:44:08,900
整个机器的，
is like when the around basically the whole machine

614
00:44:08,900 --> 00:44:10,730
处理器已经设置，
is sort of the processors has been setup

615
00:44:10,910 --> 00:44:14,690
调度器调度虚拟进程运行，
and scheduler schedules virtual process run,

616
00:44:14,690 --> 00:44:19,370
在任何一个启用中断之前。
before you know any of that actually enables interrupts.

617
00:44:20,180 --> 00:44:21,950
所以，我们来看看 riscv.h 。
And so we look at riscv.h.

618
00:44:22,530 --> 00:44:27,110
你们会看到，这是一个 C 函数。
You'll see, there's basically this is a C function.

619
00:44:28,240 --> 00:44:29,830
它启用中断
And basically enables interrupts

620
00:44:29,830 --> 00:44:31,570
你不会感到惊讶，
and you can not surprising

621
00:44:31,570 --> 00:44:33,070
它唯一能做的就是，
you know basically the only thing it does,

622
00:44:33,190 --> 00:44:36,520
设置 SSTATUS 寄存器中的中断启用位。
it sets the interrupt enable bit in the sstatus register.

623
00:44:37,330 --> 00:44:39,070
在这个特殊的时刻，
So at this particular point time,

624
00:44:39,430 --> 00:44:44,050
如果在 PLIC 处存在挂起的中断，
right at this instance if there were an interrupt pending at the PLIC,

625
00:44:44,260 --> 00:44:47,590
那么这个特殊的核心会被中断。
then you know the this particular core would be interrupted.

626
00:44:48,770 --> 00:44:50,150
我们随后会看到，
We see that a second later,

627
00:44:50,150 --> 00:44:52,370
但是，此时启用了中断。
but this is this point interrupts are enabled.

628
00:44:53,840 --> 00:44:55,400
这就是基本设置。
And so this is the basic setup.

629
00:44:56,050 --> 00:44:57,160
对于这个，有什么问题吗？
Any questions about this?

630
00:45:02,020 --> 00:45:02,800
不好意思，
Oh, sorry,

631
00:45:02,830 --> 00:45:07,810
在那个时刻，哪个核心会被打断呢？
oh, what core would be interrupted when at that point?

632
00:45:08,420 --> 00:45:11,090
所以，每个核心都运行调度器循环。
So every core runs the scheller loop, correct.

633
00:45:11,680 --> 00:45:14,680
无论什么核心启用中断，
And whatever core calls interrupt on,

634
00:45:15,250 --> 00:45:16,630
所有内核都会启用中断，
all cores will call interrupt on,

635
00:45:16,630 --> 00:45:21,390
但是我们假设只有一个核心最先到达那里，比如核心 1 ，
but let's say there's only one core gets there first, like core one

636
00:45:21,660 --> 00:45:25,950
如果核心 1 在这个时刻设置中断启用位，
and if core one sets its interrupt enable bit at that point,

637
00:45:25,950 --> 00:45:27,360
它可能会收到中断。
it could receive an interrupt.

638
00:45:29,480 --> 00:45:31,820
我们随后会看到，一次中断到底发生了什么。
And we'll see in second what happens exactly in an interrupt.

639
00:45:33,230 --> 00:45:34,430
理解了，谢谢。
Makes sense, thank you.

640
00:45:36,520 --> 00:45:39,790
好的，那么我想做的是，
Okay, okay, so what do I want to do

641
00:45:39,820 --> 00:45:42,160
就是看看这个，
is look at this,

642
00:45:42,280 --> 00:45:44,650
如何打印 $ ，
how, how to print the $

643
00:45:44,710 --> 00:45:46,870
也就是 shell 提示符。
you know the prompt at the shell prompt.

644
00:45:47,550 --> 00:45:51,660
所以，我们往回一点。
And so for that we want to go back a little bit.

645
00:45:52,460 --> 00:45:54,470
我们首先再次查看 init 。
And our first want to look at init again.

646
00:45:55,040 --> 00:45:57,230
所以，这是第一个出现的进程，
So this was the first process that actually being,

647
00:45:57,320 --> 00:45:59,540
在 execinit 代码中，
there in the code execinit,

648
00:45:59,540 --> 00:46:01,970
这是第一个运行的进程。
and so that's basically first process running.

649
00:46:02,520 --> 00:46:04,740
它所做的一件事是，
And one of the things that it does,

650
00:46:05,040 --> 00:46:09,510
它建立了一个代表控制台的设备。
it makes a device that represents the console.

651
00:46:10,100 --> 00:46:12,740
这是创建的设备，
So here the device created,

652
00:46:12,860 --> 00:46:14,990
使用 mknod 操作，
using the mknod operation

653
00:46:15,350 --> 00:46:18,680
并且返回文件描述符，文件描述符零，
and returns a file descriptor, a file descriptor zero,

654
00:46:18,680 --> 00:46:20,300
因为它是第一个打开的文件描述符，
because it's the first file descriptor open

655
00:46:20,300 --> 00:46:22,280
然后分配给标准输出，
and then adopt it for stdout,

656
00:46:22,310 --> 00:46:24,380
然后再分配给标准错误，
and then for stderr and adopt it again

657
00:46:24,680 --> 00:46:28,730
所以，这设置了文件描述符 0 、 1 和 2 ，
and so this basically sets up file descriptor zero one and two

658
00:46:29,030 --> 00:46:31,880
对应于 console 。
to correspond to the console.

659
00:46:33,280 --> 00:46:38,710
现在，对于 shell 。
Now, so you know then for the shell.

660
00:46:40,030 --> 00:46:42,100
让我们来看一下 shell 。
So let's look at shell for a second.

661
00:46:42,960 --> 00:46:50,050
shell 打开使用文件描述符 1 2 3 ，
So the shell opens you know starts running with the file descriptors one two three,

662
00:46:50,530 --> 00:46:53,350
不好意思， 0 1 2 open 只想 console ，
sorry zero one and two open pointed to the console

663
00:46:53,620 --> 00:47:03,490
然后 shell 将打印 $ 和空格到文件描述符 2 。
and then shell prints the character $ and the space to file descriptor two.

664
00:47:04,200 --> 00:47:07,740
因此，尽管 console 和 UART ，
And so, so even though the console and uart,

665
00:47:07,800 --> 00:47:11,550
这些都属于应用程序员，
you know sort of all you know [] this to the application programmer,

666
00:47:11,550 --> 00:47:13,770
比如 shell ，当然，我们需要 shell ，
and like the shell, of course, we want the shell,

667
00:47:13,860 --> 00:47:15,450
它看起来就像一个普通文件，
it just looks like a regular file,

668
00:47:15,750 --> 00:47:17,940
所以实际上， shell 本身，
so in fact the shell itself,

669
00:47:18,120 --> 00:47:19,710
它写入文件描述符 2 ，
since its writes to descriptor two

670
00:47:19,740 --> 00:47:21,870
实际上并不知道另一边是什么，
has no idea what actually sits on the other side

671
00:47:21,900 --> 00:47:23,430
我们已经在 util 实验中看到，
and we have seen in util lab,

672
00:47:23,430 --> 00:47:24,990
你可以用它做各种很酷的事情。
you can do all kinds of cool stuff with it.

673
00:47:25,460 --> 00:47:26,600
这里有一个例子，
But here's an example

674
00:47:26,600 --> 00:47:30,350
Unix 中的设备表示为一个文件，
where basically the device in Unix is represented as a file,

675
00:47:30,380 --> 00:47:32,180
这和其他东西没什么不同。
that's not different than anything else.

676
00:47:33,650 --> 00:47:36,800
好的，让我们看看这个 printf 是如何工作的。
Okay, so let's see how this actually printf works.

677
00:47:37,340 --> 00:47:42,770
所以， xv6 用户应用程序中有一个 printf ，
So there's a printf is in xv6 user application,

678
00:47:42,770 --> 00:47:45,710
一个很小的 C 库，包括 printf 代码。
a tiny little C library, which includes code printf.

679
00:47:46,340 --> 00:47:50,690
printf ，像你在 traps 实验中看到的，
And you know printf, you know as you've seen in the traps lab,

680
00:47:50,690 --> 00:47:54,510
是某种[本能]函数，
you know, sort of an instinct function itself,

681
00:47:54,510 --> 00:47:58,170
但是，最终它调用了 write 系统调用，
but in the end it basically calls the write system call,

682
00:47:58,440 --> 00:48:02,370
在我们的示例中， write 系统调用是文件描述符 2 ，
and in our case where the write system call would be you know file descriptor two

683
00:48:02,370 --> 00:48:06,690
而 c 包含 $ 符号，
and c would be hold the character $

684
00:48:06,690 --> 00:48:11,370
因此我们传递包含 $ 的内存地址
and so we pass the address of the memory location that holds the $

685
00:48:11,370 --> 00:48:14,370
给文件描述符用来写入，
to the file descriptor to write

686
00:48:14,640 --> 00:48:17,160
我们要求写入一个字符。
and we ask you know to write one character.

687
00:48:19,290 --> 00:48:21,270
所以 shell 写入的每个字符，
So basically every character written by the shell,

688
00:48:21,270 --> 00:48:22,740
它会引起系统调用。
it results in a system call.

689
00:48:23,340 --> 00:48:24,840
现在我们可以去。
And so now we can go.

690
00:48:25,870 --> 00:48:27,430
让我们看看实际会发生什么。
Let's see what actually happens.

691
00:48:28,040 --> 00:48:31,610
你之前看见过系统调用，
So we you know you've seen the system call before,

692
00:48:31,640 --> 00:48:34,250
但是， sysfile.h 。
but sysfile.

693
00:48:36,960 --> 00:48:38,940
sys_write 。
sys_write.

694
00:48:40,190 --> 00:48:44,090
这是 write 系统调用和它的参数，
So here's the write system call, [] its arguments,

695
00:48:44,150 --> 00:48:46,910
文件描述符，要写入的字节数，
file descriptor, number bytes to be written

696
00:48:46,910 --> 00:48:47,990
还有地址，
and the address with the,

697
00:48:49,100 --> 00:48:51,890
包含 $ 的地址，
the address that it contains you know the character $,

698
00:48:51,920 --> 00:48:53,090
调用 filewrite 。
call them filewrite.

699
00:48:58,080 --> 00:49:00,750
让我们快速看一下 filewrite 。
Let's quickly look at filewrite.

700
00:49:01,860 --> 00:49:05,490
好的，我们离我们想要讨论的东西越来越近了。
Okay, we're getting close to actually things that we want to talk about.

701
00:49:06,140 --> 00:49:10,790
在这里， filewrite 查看文件描述符类型，
And you know here is filewrite it looks for the type of the file descriptor is,

702
00:49:10,790 --> 00:49:12,890
如果是管道，调用管道的函数，
it's a pipe called the pipe functions,

703
00:49:13,070 --> 00:49:16,700
如果是设备，不起作用，
and if its device which you know [make not does],

704
00:49:17,000 --> 00:49:21,020
然后，它对那个设备调用 write 函数。
then it will call the write function for that particular device.

705
00:49:21,910 --> 00:49:29,020
所以，这实际上会调用 console 中的 write 函数。
And so we know that you know that actually is going to call the write function in the console.

706
00:49:30,330 --> 00:49:31,800
让我们看看那里会发生什么。
And so let's see what happens there.

707
00:49:31,830 --> 00:49:33,030
这里是 consolewrite ，
So here's consolewrite,

708
00:49:33,840 --> 00:49:36,930
获取锁，我们现在不关心这个，
grab lock, we don't care about that right now,

709
00:49:37,080 --> 00:49:41,340
它使用 either_copyin 复制进一个字符，
it copies in the one character use either_copyin,

710
00:49:41,890 --> 00:49:44,080
然后，调用 uartputc 。
and then, calls uartputc.

711
00:49:45,530 --> 00:49:48,650
它调用进入 UART ，
So that basically calls into the uart,

712
00:49:48,680 --> 00:49:49,940
你可以这样考虑，
and so you can think about to it,

713
00:49:49,940 --> 00:49:51,530
console 是驱动程序，
the console is being the driver,

714
00:49:51,620 --> 00:49:54,380
我们现在看的是驱动程序的顶端，
we're looking at the top end of the driver

715
00:49:54,650 --> 00:49:58,280
现在调用 uart.c 中的东西，
and now make some call in uart.c

716
00:49:58,550 --> 00:50:00,740
来打印一个字符。
to actually a print a character.

717
00:50:02,060 --> 00:50:05,960
这是 uart.c ，这会有点有趣，
And so here uart.c, so this is going to be a little bit interesting,

718
00:50:07,780 --> 00:50:11,680
基本上，UART 内部保持一个缓冲区，
basically the internally the uart keeps a buffer,

719
00:50:12,040 --> 00:50:14,500
让我们回退一点。
so let's go back back up a little bit.

720
00:50:15,080 --> 00:50:18,290
在顶部，有一个用于传输的缓冲区，
At the top, in fact there's a buffer for transmission

721
00:50:18,620 --> 00:50:21,200
缓冲区大小是 32 个字符。
and buffer size is 32 characters.

722
00:50:21,770 --> 00:50:24,350
这里有一个指针，写指针和读指针，
And there's a pointer the write pointer and the read pointer

723
00:50:24,350 --> 00:50:30,620
用来将该字符放入循环缓冲区中，
that being used to put this character into a circular buffer,

724
00:50:30,950 --> 00:50:32,600
更详细地讨论一下这个，
talk a little bit about that in more detail,

725
00:50:32,600 --> 00:50:37,970
但是，有一个指向生产者的指针和一个指向消费者的指针。
but there's a pointer for the producer and as a pointer for the consumer.

726
00:50:38,620 --> 00:50:43,150
在这种情况下， shell 是生产者，
And in this case, you know the shell, if you will, as the producer

727
00:50:43,210 --> 00:50:45,760
它检查，
and it actually checks,

728
00:50:45,760 --> 00:50:46,690
它做的第一件事是
the first thing it does is

729
00:50:46,690 --> 00:50:48,730
检查这个循环缓冲区是否已满。
actually check whether this circular buffer is full.

730
00:50:49,370 --> 00:50:52,010
检查循环缓冲区是否已满的方法，
So and the way the checks with the circular buffer is full,

731
00:50:52,010 --> 00:50:57,350
它的初始状态是写指针和读指针都是零，
so it starts out in the original state is both the write pointer and the read pointer is zero, correct,

732
00:50:57,350 --> 00:50:58,910
缓冲区的零索引，
zero index into the buffer,

733
00:50:59,240 --> 00:51:04,250
如果它们相等，则缓冲器是空的，
if the equal you know that there buffer is empty,

734
00:51:04,430 --> 00:51:06,410
但是如果在写指针上加一，
but if you add one to the write pointer,

735
00:51:06,410 --> 00:51:08,000
与接收指针相同，
it's the same as the receive pointer,

736
00:51:08,030 --> 00:51:13,160
比如，如果你填入 0 1 2 3 4 5 6 7 8 9 到 31 ，
so for example if you you fill in a zero one two three four five six seven eight nine to thirty one

737
00:51:13,400 --> 00:51:15,770
然后你要绕回来，
and then you're about to wrap around,

738
00:51:16,040 --> 00:51:22,680
加上一，它仍然等于接收索引或读索引，
you know add one if then and it's still equal to the receive index or the read index

739
00:51:22,680 --> 00:51:23,970
你知道缓冲区已满。
that you know that the buffer is full.

740
00:51:24,820 --> 00:51:28,600
所以，这一点上你不能写任何东西，
And so there's no point you know you can't write anything at that point,

741
00:51:28,600 --> 00:51:30,640
因为很明显 UART 正忙，
because apparently UART still busy,

742
00:51:30,640 --> 00:51:31,870
以它的方式工作，
you know working its way through,

743
00:51:31,870 --> 00:51:37,870
试着发送之前的 31 个或 30 个字符。
trying to send off the [] you know 31 characters or 30 characters.

744
00:51:38,390 --> 00:51:40,430
在这种缓冲已满的情况下，
In this case, the buffer full,

745
00:51:40,550 --> 00:51:46,280
shell 会休眠，在旁边等待，
the shell basically were put to sleep and put on the side

746
00:51:46,280 --> 00:51:48,590
内核将运行其他程序，
and the kernel will run some other program

747
00:51:48,890 --> 00:51:53,720
直到 shell 唤醒，已经准备好发送，
until shell woken up and it's actually ready to send,

748
00:51:55,180 --> 00:51:57,430
或者 UART 准备好发送更多数据。
or the uart just ready to send more data.

749
00:51:58,090 --> 00:52:00,340
当然这种情况下不是这样的，
You know, of course in this case it's not the case right,

750
00:52:00,340 --> 00:52:02,800
因为有几个字符正在打印，
because there's the first few characters that are being printed,

751
00:52:03,220 --> 00:52:04,660
所以缓冲里有空间，
so there's space in the buffer

752
00:52:04,900 --> 00:52:09,220
所以驱动程序将一个字符放入缓冲区，
and so basically the driver puts character into the buffer,

753
00:52:09,610 --> 00:52:12,640
更新写指针到下一个插槽，
updates the write pointer to go to the next slot

754
00:52:12,790 --> 00:52:14,230
然后调用 uartstart 。
and then calls uartstart.

755
00:52:15,960 --> 00:52:17,910
基本上 uartstart 不做别的事，
And basically uartstart is nothing else,

756
00:52:17,910 --> 00:52:21,780
通知设备，去帮我做点事吧。
sort of kicking the device and saying like hey go do some work for me.

757
00:52:23,620 --> 00:52:25,180
还有，嗯。
And, um.

758
00:52:25,800 --> 00:52:32,880
基本上，首先检查设备是否正忙，
And basically, first checks if the device is still busy,

759
00:52:32,880 --> 00:52:36,000
发送当前字符，
sending the current character [] recently,

760
00:52:36,300 --> 00:52:39,390
如果设备正忙，
if if the device is busy,

761
00:52:39,390 --> 00:52:41,850
我们只要回去，可能会睡眠，
you know we just go back and we'll go to sleep probably,

762
00:52:42,320 --> 00:52:43,820
我们会睡眠，
we'll go to sleep

763
00:52:44,060 --> 00:52:46,580
否则我们从缓冲区读取字符，
and otherwise we'll read the character out the buffer

764
00:52:46,820 --> 00:52:51,490
并将其放入传输寄存器中，
and put it in the transmission register,

765
00:52:51,640 --> 00:52:52,870
就像我们之前看到的。
that we saw earlier.

766
00:52:54,480 --> 00:52:58,710
所以传输寄存器就像之前这样，
And so the transmission register just like this before,

767
00:52:58,710 --> 00:53:01,170
稍后我们看一下。
let's look at that for a second.

768
00:53:02,410 --> 00:53:09,440
WriteReg 把指定的寄存器转换成 Reg 类型，
You know WriteReg you know cast the particular register to the one of Reg type,

769
00:53:09,440 --> 00:53:11,300
然后，将值写入其中。
and then writes the value into it.

770
00:53:12,360 --> 00:53:15,510
传输保持寄存器 THR 是
And you know THR the transmitter holding register is

771
00:53:15,570 --> 00:53:18,240
我们之前在文档中看到的寄存器 0 。
register zero which we saw before from the documentation.

772
00:53:20,390 --> 00:53:25,250
好的，所以，你知道，
Okay, so, so basically you know the,

773
00:53:26,570 --> 00:53:28,370
我从哪里开始。
where am I start.

774
00:53:28,920 --> 00:53:31,380
你应该首先从通知设备，
You should start basically kicks the device

775
00:53:31,380 --> 00:53:33,420
然后说，我有一个寄存器，
and saying like hey I gotta register,

776
00:53:33,420 --> 00:53:36,180
我有一个字节可以发送。
I got a byte for you available to send off.

777
00:53:36,790 --> 00:53:40,570
这就是所有的。
And that's basically all the.

778
00:53:42,430 --> 00:53:45,220
这就是， shell ，
And that basically the if you will, the shell,

779
00:53:45,250 --> 00:53:48,520
系统调用 shell 所做的，
you know the system call, the shell call will do

780
00:53:48,790 --> 00:53:52,960
如果通知设备，会回到用户空间，
and once actually kick the devices will return to user space

781
00:53:52,960 --> 00:53:55,480
shell 可以继续运行，做它想做的任何事情，
and the shell can go on and do whatever it wants to do

782
00:53:55,840 --> 00:53:58,600
shell 要做的下一件事就是调用 read 系统调用，
and presumably the next thing the shell will do is called the read system call

783
00:53:58,600 --> 00:54:00,340
真正读取来自键盘的输入。
to actually read input from the keyboard.

784
00:54:00,740 --> 00:54:02,750
所以 shell 将返回用户空间，
So the shell will return to user space,

785
00:54:02,750 --> 00:54:06,620
使用我们看过的机制，比如 userret ，
using the standard mechanism, that we have seen before, like userret,

786
00:54:06,950 --> 00:54:08,450
它继续，并做着自己的事，
it just goes off and does its thing

787
00:54:08,630 --> 00:54:11,450
同时，那个设备没有被通知，
and in the meantime, the device has not got any kick

788
00:54:11,660 --> 00:54:13,700
来真正发送一些字节。
to actually, send some bytes off.

789
00:54:16,240 --> 00:54:17,950
所以。
And so.

790
00:54:19,400 --> 00:54:21,680
所以，在某个时候我们会被中断，
So, at some point we're going to get interrupted,

791
00:54:22,720 --> 00:54:27,130
希望，因为我们进入产生中断的硬件，
hopefully you know because we broke into the hardware to actually generate interrupts,

792
00:54:27,370 --> 00:54:28,720
我们往回一点，
let's go a little bit back

793
00:54:28,720 --> 00:54:32,200
讨论一下，当中断发生时发生了什么。
and talk a little bit about what happens when the interrupt happens.

794
00:54:37,130 --> 00:54:42,270
好的，那么硬件做了什么。
Okay, so, so what does the hardware do.

795
00:54:44,320 --> 00:54:49,140
在这种情况下， RISC-V 实际发生中断，
In this particular case, the RISC-V, do what interrupt actually happens,

796
00:54:49,140 --> 00:54:53,160
所以，我们设置 SSTATUS 寄存器中的中断启用位，
so we set this interrupt enable bit in the SSTATUS register,

797
00:54:53,280 --> 00:54:55,200
所以，这个进程可以被中断，
so the process can be interrupted,

798
00:54:55,440 --> 00:55:00,060
比如，键盘发起中断到 PLIC ，
let's say the keyboard raises the interrupt line goes through the PLIC,

799
00:55:00,240 --> 00:55:03,660
PLIC 将中断路由到特定的内核，
PLIC routes the interrupt to particular core

800
00:55:03,900 --> 00:55:08,910
那个核心设置了 SIE 位，
and that core you know, has the SIE bit set,

801
00:55:09,810 --> 00:55:11,520
所以，设置中断启用位，
so interrupt enable bit set,

802
00:55:13,260 --> 00:55:15,660
设置管理者中断启用位，
the supervisor interrupt enable bit set,

803
00:55:15,780 --> 00:55:17,160
所以，如果设置了该位，
so if the bit is set,

804
00:55:17,750 --> 00:55:18,770
会发生以下情况。
the following things happen.

805
00:55:19,370 --> 00:55:22,400
这个跟我们之前看到的很像，
And this will look very similar to what we've seen before,

806
00:55:22,430 --> 00:55:27,630
硬件要做的第一件事就是清除 SIE 位。
but the first thing the hardware does is clear the SIE bit.

807
00:55:29,330 --> 00:55:32,450
这会阻止任何进来的中断，
This stops you know any further interrupts coming in,

808
00:55:32,450 --> 00:55:34,340
这样我们就可以先处理这些中断，
so that we can just deal with these interrupt first

809
00:55:34,340 --> 00:55:35,690
如果我们想要更多的中断，
and then if we want more interrupts,

810
00:55:35,690 --> 00:55:37,730
我们必须重新启用那个位，
you know we have to re-enable that bit,

811
00:55:37,730 --> 00:55:40,480
你知道这些阻止更多的中断，
you know these to stops further interrupts

812
00:55:40,480 --> 00:55:42,340
中断，中断，中断，
were basically interrupt interrupt interrupt,

813
00:55:43,440 --> 00:55:51,800
然后，设置异常程序计数器 SEPC 为当前 PC 。
then it sets the SEPC to the exception program counter to the current PC.

814
00:55:52,840 --> 00:55:54,730
比如，如果中断，
For example, if we were interrupted,

815
00:55:54,730 --> 00:55:56,710
比如 shell 返回用户空间，
let's say the shell return to user space

816
00:55:56,710 --> 00:55:59,290
在用户空间运行时发生中断，
what's happening run in user space and interrupt comes in,

817
00:55:59,290 --> 00:56:00,850
因为发送了一个字符，
because of that one character is sent,

818
00:56:01,150 --> 00:56:04,960
然后，程序计数器收到，在用户空间中的程序计数器，
then the program counter can receive is whatever program counter was in user space,

819
00:56:05,410 --> 00:56:10,860
它保存当前模式。
it saves the save the current mode.

820
00:56:12,880 --> 00:56:15,520
比如，在这种情况下，
So in this case would be an example would be

821
00:56:15,520 --> 00:56:19,270
我们将保存 xv6 的用户模式，
we would save that xv6 supervisor mode, the user mode,

822
00:56:19,420 --> 00:56:21,910
然后，它设置为管理者模式。
then it's sets the mode supervisor.

823
00:56:26,360 --> 00:56:30,710
将程序计数器设置为 stvec 的值，
And, basically sets the program counter to stvec,

824
00:56:31,300 --> 00:56:33,340
不管 stvec 的值是什么，
whatever value is in stvec, right,

825
00:56:33,340 --> 00:56:38,890
然后，继续 usertrap ，或 uservec ，或 kernelvec ，
then it's going to be either usertrap or uservec or kernelvec,

826
00:56:39,670 --> 00:56:41,530
取决于中断发生在什么地方，
depending whether the interrupt happens,

827
00:56:41,530 --> 00:56:44,230
我们是在内核空间还是在用户模式，
you know whether we're in [] kernel space or user mode,

828
00:56:44,230 --> 00:56:47,440
在我们的例子中，shell 可能会返回用户空间。
but in our example, where maybe shell return to user space,

829
00:56:47,980 --> 00:56:53,260
stvec 会包含用户[]地址，
you know stvec will contain the user [] address

830
00:56:53,290 --> 00:56:57,070
核心将恢复内核，
and basically the hart will resume the kernel,

831
00:56:57,340 --> 00:57:01,630
到位于 stvec 中的指令，
at the instruction that is located stvec

832
00:57:01,660 --> 00:57:04,100
我们还记得上一节课，
and you know we remember from previous lecture,

833
00:57:04,100 --> 00:57:08,900
stvec 继续并调用 usertrap 。
you know basically stvec goes off and calls usertrap.

834
00:57:09,900 --> 00:57:12,630
好的，最后我们会在 usertrap 中。
Okay, so in the end, we'll basically end up in usertrap.

835
00:57:15,320 --> 00:57:16,970
这就是我们讲的故事，
And that's where we sort of pick up the [story],

836
00:57:16,970 --> 00:57:21,110
我不想谈论太多关于保存和恢复的事情，
because like I don't really want to talk too much about the saving and restoring anymore,

837
00:57:21,110 --> 00:57:24,440
因为，第一我们在之前的课中详细解释过，
because one we explained it in detail in the previous lecture,

838
00:57:24,440 --> 00:57:29,720
第二，你已经看见过，在之前的的 traps 实验中，
two, you already played with and also in this last traps [] lab,

839
00:57:29,750 --> 00:57:31,910
所以，你很清楚发生了什么。
so you know you know exactly what's going on.

840
00:57:36,860 --> 00:57:37,550
有什么问题呢？
And questions?

841
00:57:43,150 --> 00:57:44,950
好的，那么。
Okay, so.

842
00:57:46,410 --> 00:57:47,970
所以，这里我们回到 usertrap ，
So here we back in usertrap,

843
00:57:48,120 --> 00:57:51,540
它是你在 traps 实验里详细研究过的函数。
you know function you've looked in detail at in the traps lab.

844
00:57:51,720 --> 00:57:56,130
我们处理了一个系统调用的案例。
And you know we dealt with a case of system calls.

845
00:57:56,520 --> 00:58:00,810
我们要做的，我们要做的一件事是，
And what we're gonna do, is basically the only thing we're gonna do is

846
00:58:00,810 --> 00:58:04,690
看看这个例子，设备中断。
look at this case, which is the device interrupt.

847
00:58:05,260 --> 00:58:08,200
好的，所以我们要。
Okay, so so we're gonna.

848
00:58:09,150 --> 00:58:12,120
这在文件的稍低一点的地方。
That's a little bit lower here in the file.

849
00:58:16,140 --> 00:58:17,790
这是设备的中断，
So here's the device's interrupt

850
00:58:17,820 --> 00:58:23,280
它查看 scause 寄存器，
and it looks basically the scause register

851
00:58:23,280 --> 00:58:25,890
查看这是否是外部中断，
and sees if this is an external interrupt,

852
00:58:26,220 --> 00:58:28,080
如果是外部中断，
and if it's an external interrupt,

853
00:58:28,350 --> 00:58:30,330
它调用函数 plic_claim ，
that calls a function the plic_claim,

854
00:58:30,960 --> 00:58:34,590
声称那个特定的中断。
to basically claim that particular claim interrupt.

855
00:58:34,800 --> 00:58:36,180
让我们回到 plic ，
So let's go back to plic,

856
00:58:39,080 --> 00:58:40,520
查看 plic_claim ，
and look at the plic_claim

857
00:58:41,000 --> 00:58:45,380
归结起来就是，这个，
and basically what it boils down to is that the, in the,

858
00:58:45,530 --> 00:58:48,200
特定的 CPU 会告诉 PLIC ，
this particular CPU will tell the plic,

859
00:58:48,260 --> 00:58:52,250
嘿，我在请求说 CPU 0 或 CPU 1 ，
hey I'm claiming you know it's CPU zero or CPU one,

860
00:58:52,310 --> 00:58:58,160
它会告诉 PLIC CPU 1 正在请求这个特定的中断，
it will tell the plic that CPU one is claiming this particular interrupt

861
00:58:58,160 --> 00:59:02,120
一旦收到中断请求， PLIC 返回它得到的中断，
and once claim interrupt and plic returns which interrupts it gets,

862
00:59:02,640 --> 00:59:05,340
实际传入的中断的 irq ，
irq for the interrupt that actually came in

863
00:59:05,340 --> 00:59:09,750
在这种情况下，这是一个中断 UART0_IRQ 10 。
and so in this case that will be an interrupt UART0_IRQ ten.

864
00:59:10,280 --> 00:59:12,830
所以 plic_claim 会返回 10 。
So plic_claim will basically return ten.

865
00:59:13,660 --> 00:59:15,820
然后在这段代码中，
And then here in this code,

866
00:59:16,060 --> 00:59:19,180
嘿，这是中断 10 ，
you know look you say hey is this a interrupt ten,

867
00:59:19,180 --> 00:59:21,850
如果是中断 10 一定是 UART 中断，
if interrupt ten that must be a uart interrupt

868
00:59:22,150 --> 00:59:25,630
然后我们调用 uartintr 函数。
and we basically called uartintr function.

869
00:59:26,370 --> 00:59:28,950
而 uartintr 函数，
And uartintr function,

870
00:59:31,690 --> 00:59:36,010
从 UART 把字符拿出来，
runs and basically gets the character off you know the uart

871
00:59:36,250 --> 00:59:38,350
它从 uart 获取字符的方式是，
and the way it gets the character of uart is

872
00:59:38,350 --> 00:59:43,360
在第一个寄存器中查找，接收寄存器，
basically looks in first register, the receive register

873
00:59:43,660 --> 00:59:45,850
从那里拿出字符。
and gets the character out of there.

874
00:59:47,240 --> 00:59:52,610
这是一个整数，然后它调用 consoleintr ，
And, that is an integer and then it calls consoleintr,

875
00:59:53,120 --> 00:59:55,340
来做剩下的工作。
to do the rest of the work.

876
00:59:58,510 --> 00:59:59,200
好的?
Okay?

877
01:00:01,570 --> 01:00:04,000
不好意思，我说错了，
Actually sorry, I just did the wrong thing,

878
01:00:04,000 --> 01:00:07,060
我们在谈论传输。
we were talking about transmission.

879
01:00:10,940 --> 01:00:14,960
所以，如果在读取端有一个字符，
So if there was a character on the read side

880
01:00:14,990 --> 01:00:18,170
然后我们会调用 consoleintr ，
and then we'll call consoleintr,

881
01:00:18,170 --> 01:00:20,180
但是在读取端没有字符，
but there is no character correct, on the read side,

882
01:00:20,180 --> 01:00:23,270
因为我们没有读取，键盘还没有做任何事情，
because we haven't read any, keyboard hasn't done anything yet,

883
01:00:23,480 --> 01:00:25,370
我们只是在传输一个字符，
we're just transmitting a character,

884
01:00:25,640 --> 01:00:29,000
那么这个会返回 -1 ，
so this like return minus one fall through

885
01:00:29,150 --> 01:00:31,160
然后唯一能做的就是，
and then basically the only thing that will do

886
01:00:31,190 --> 01:00:35,960
将调用 uartstart ，
is called it will call uartstart

887
01:00:36,020 --> 01:00:39,800
发送在缓冲器中的任何其他字符，
to basically send any any other characters that might be in the buffer,

888
01:00:39,830 --> 01:00:42,410
可能是 shell 放在这里的，
the shell, it might be stuck in there

889
01:00:42,710 --> 01:00:44,600
有另一个字符的时候恢复，
and resume there's another character in there,

890
01:00:44,600 --> 01:00:46,460
因为 $ 之后是空格，
because after the $ is the space

891
01:00:46,760 --> 01:00:49,340
并且 write 系统调用可能，
and the write system call might,

892
01:00:49,640 --> 01:00:53,630
写空格可能跟设备发送同时发生，
write this space might have happened concurrently while the device was sending off

893
01:00:53,960 --> 01:00:56,780
所以，当传输中断完成时，
and so when we interrupt transmit interrupt complete,

894
01:00:57,190 --> 01:01:01,330
它继续在缓冲器中找另一个字符，
it's goes off you know the, will find in the buffer yet another character,

895
01:01:01,330 --> 01:01:03,970
空格字符，然后把空格字符送出。
the space character and will send space character off.

896
01:01:06,980 --> 01:01:08,150
好的，这能理解吗？
Okay, that makes sense?

897
01:01:10,320 --> 01:01:12,900
我有一个高层次的问题。
I have a high level of question actually.

898
01:01:13,510 --> 01:01:18,070
我知道 UART 很有用，
So I understand the uart [] is like useful,

899
01:01:18,070 --> 01:01:20,050
比如使用键盘，
if like using the keyboard

900
01:01:20,410 --> 01:01:24,730
键盘上的字符通过 UART ，
and like characters from the keyboard go through the uart

901
01:01:24,880 --> 01:01:26,080
然后通过 CPU ，
and then through the CPU

902
01:01:26,080 --> 01:01:27,820
然后是我们编写的内核代码，
and then the kernel code that we wrote,

903
01:01:28,120 --> 01:01:29,950
但是我不理解的是，
but I am not sure I understand what

904
01:01:29,950 --> 01:01:33,730
当 UART 打印字符时，
the point of the uart is when the shell is printing characters,

905
01:01:33,910 --> 01:01:36,130
比如没有键盘交互。
like the keyboard isn't being interacted with.

906
01:01:36,520 --> 01:01:37,210
这是正确的，
You know, it is correct,

907
01:01:37,210 --> 01:01:38,560
但是显示器是，
but the display is,

908
01:01:38,800 --> 01:01:40,720
实际上有两个设备，
actually there's two devices here,

909
01:01:40,720 --> 01:01:43,390
一个是键盘，一个是 console 上的显示器。
one is the keyboard and one is the display on the console.

910
01:01:43,940 --> 01:01:49,760
QEMU 与 console 交互是通过 UART ，
And the way you know QEMU interact with the console is by uart,

911
01:01:49,790 --> 01:01:53,030
通过发送字符到控制台，
by sending a character to the console

912
01:01:53,510 --> 01:01:54,770
然后 console 的工作是
and then the console's job is

913
01:01:54,770 --> 01:01:57,860
在显示器上绘制该字符。
basically to draw that character on the display.

914
01:01:59,030 --> 01:02:00,710
哦，我明白了，好的，谢谢。
Oh I see, okay, thanks.

915
01:02:02,920 --> 01:02:03,820
这可能需要时间，
It might take time

916
01:02:03,850 --> 01:02:06,460
它需要画出这些东西。
and that's why you know this thing you know sort of being drawing.

917
01:02:08,040 --> 01:02:09,360
好的。
Okay, um.

918
01:02:10,100 --> 01:02:11,540
所以现在有几件事，
So a couple things now,

919
01:02:11,540 --> 01:02:13,100
我想退回去一点，
you know I want to step back a little bit

920
01:02:13,100 --> 01:02:17,270
从更高层次上考虑这件事，
and think a little bit higher level what's going on,

921
01:02:17,270 --> 01:02:18,590
所以我们应该遍历代码，
so we should walk through the code,

922
01:02:18,590 --> 01:02:20,480
我们对这里的情况有一些理解，
we get sort of a feeling for the lay of the land,

923
01:02:20,960 --> 01:02:26,510
比如细节怎样，
and like how the details,

924
01:02:26,630 --> 01:02:28,910
它值得退回一点，
it's worthwhile to step back a second

925
01:02:28,910 --> 01:02:31,430
想一想这一切意味着什么。
and think a little bit about you know what it all means.

926
01:02:32,470 --> 01:02:36,370
特别是，有趣的是并发中断，
In particular, what is interesting is interrupting concurrency,

927
01:02:36,370 --> 01:02:38,920
从并发的角度考虑中断。
sort of think about interrupting the perspective concurrency.

928
01:02:42,440 --> 01:02:48,110
这是使中断变得棘手或难以编程的一件事，
And this is one of the things actually makes interrupts tricky or difficult to program,

929
01:02:48,380 --> 01:02:51,560
首先是我们之前提到过，
so first of all, you know we mentioned earlier,

930
01:02:51,620 --> 01:02:54,080
在我们的例子中的 UART 设备，
the device you know uart in our case,

931
01:02:54,320 --> 01:02:57,620
设备和 CPU 并行运行。
the device and the CPU run in parallel.

932
01:03:03,140 --> 01:03:06,230
所以，比如，在我们讨论的场景中，
So, one example is in our you know scenario, what you know talk about,

933
01:03:06,380 --> 01:03:12,290
UART 发送一个字符给 console ，
you know uart sending off you know a character to the console,

934
01:03:12,380 --> 01:03:16,880
在这个发生的同时， CPU 仍在继续它的工作，
and while that's happening, the CPU still you know go about its business

935
01:03:16,880 --> 01:03:19,250
在这种情况下，返回到 shell ，
and in this case, returning to the shell,

936
01:03:19,370 --> 01:03:24,800
shell 可以调用其他的系统调用写入空格字符，
the shell may make another system call attempt to write space character

937
01:03:25,070 --> 01:03:26,330
所有这些都是并行进行的，
and all happens in parallel

938
01:03:26,510 --> 01:03:29,270
所以我们需要管理这种并行性，
and so we need to manage that parallelism a bit

939
01:03:29,270 --> 01:03:30,710
我们已经看过一点，
and we already saw a little bit,

940
01:03:30,710 --> 01:03:32,330
但我会更详细地讨论一下。
but I'm gonna talk a little bit more in detail.

941
01:03:32,620 --> 01:03:35,080
这里显示的并行性，
And the type of parallelism that actually shows up here

942
01:03:35,110 --> 01:03:37,570
通常称为生产者-消费者并行性。
is typically called producer consumer parallelism.

943
01:03:49,040 --> 01:03:50,330
我稍后讲一下，
Let me talk about in a second,

944
01:03:50,330 --> 01:03:52,670
所以现在我们更详细地讨论一下。
so now we're gonna talk about it a little more detail.

945
01:03:52,850 --> 01:03:53,840
第二个是，
The second is,

946
01:03:54,680 --> 01:04:03,790
中断停止了当前正在运行的程序，
that the interrupt stops the current running program,

947
01:04:08,450 --> 01:04:09,860
或者正在运行的当前程序。
or the current program is running.

948
01:04:12,740 --> 01:04:14,150
所以在 shell 的情况下，
So in the case of the shell,

949
01:04:14,360 --> 01:04:18,950
shell 程序可能正在执行类似 212 的指令，
shell might be executing instruction like 212

950
01:04:19,250 --> 01:04:20,630
然后突然出现了中断，
and boom interrupt comes in

951
01:04:20,630 --> 01:04:22,580
直接在这一点停下来。
and immediate that point is just stopped.

952
01:04:23,340 --> 01:04:27,540
对用户空间的代码来说，这没什么大不了的，
And that's something, you know for user space code, that's not a particularly big deal,

953
01:04:27,720 --> 01:04:30,180
因为当我们从中断返回，
because when we return from the interrupt,

954
01:04:30,180 --> 01:04:33,690
我们会恢复用户级别程序的所有状态，
when we restore all the state of the user level program

955
01:04:33,870 --> 01:04:38,040
它会恢复出现中断的地址，
and it will resume you know at you know address which got interrupted

956
01:04:38,100 --> 01:04:41,230
我们已经在 traps 和页面错误中看到了，
and so we've seen that with traps and page faults,

957
01:04:41,230 --> 01:04:44,590
实际上是相当不错的，
and so you know, actually works out reasonable well,

958
01:04:44,620 --> 01:04:46,450
不过，这里有个棘手的情况，
but there's a little bit of tricky case,

959
01:04:46,450 --> 01:04:48,700
当内核本身中断时，
when the kernel itself interrupted,

960
01:04:48,730 --> 01:04:50,110
所以如果是在内核模式下运行，
so you're running in kernel mode

961
01:04:50,260 --> 01:04:51,550
而且内核被中断，
and the kernel gets interrupted,

962
01:04:52,020 --> 01:04:55,650
这意味着，再说得更详细一点，
that means that, and talk a little bit more detail,

963
01:04:55,680 --> 01:04:59,400
即使是内核也不是直接按顺序执行的，
that even the kernel doesn't really sort of executed straight sequentially,

964
01:04:59,580 --> 01:05:02,640
如果你看到一条内核指令后跟另一条内核指令，
if you see one kernel instruction followed by another kernel instruction,

965
01:05:03,030 --> 01:05:06,810
在这些指令之间，中断可能发生，
in the between those instructions and interrupt might happen,

966
01:05:07,590 --> 01:05:11,070
取决于是否启用中断。
depending whether interrupts are enabled or not.

967
01:05:11,820 --> 01:05:14,340
在一些代码中，
In so whether, and some piece of code

968
01:05:14,340 --> 01:05:16,710
在中间可以中断是不好的，
and it's not good to have an interrupt in between,

969
01:05:16,800 --> 01:05:17,910
在下一个示例中，
and in next case,

970
01:05:17,910 --> 01:05:20,880
内核可能必须禁用或启用中断，
you know the kernel might actually have to disable or enable interrupts

971
01:05:20,880 --> 01:05:23,700
使代码序列是原子的。
to make basically code sequences atomic.

972
01:05:24,930 --> 01:05:30,880
中断启用和禁用。
So interrupt enable and disable.

973
01:05:35,230 --> 01:05:37,180
稍后我会更详细地谈到，
I'll talk about in a second in more detail

974
01:05:37,270 --> 01:05:41,290
第三关于并发的问题，
and sort of the third sort of concurrency problem

975
01:05:41,290 --> 01:05:45,770
出现在中断处理程序中。
that shows up in the, in interrupt handler.

976
01:05:47,490 --> 01:05:49,320
让我换个说法，
Let me say, let me say differently,

977
01:05:49,530 --> 01:05:59,180
驱动的顶部和底部可以并行运行。
the top of the driver and the bottom of the driver may run in parallel.

978
01:06:08,660 --> 01:06:11,180
比如，在我们的例子中，
So, for example in our example,

979
01:06:12,370 --> 01:06:16,870
shell 会再次调用 write 系统调用，
the shell is going to be called the write system call again,

980
01:06:16,870 --> 01:06:19,840
在打印 $ 之后打印空格，
you know to print the white space after it printed the $

981
01:06:20,050 --> 01:06:23,920
如果你回到驱动的顶部，
and while you may go back into the top level of the driver,

982
01:06:24,010 --> 01:06:26,080
它可能想，
it might want to and may want to

983
01:06:26,080 --> 01:06:30,670
添加这个空格到 UART 的队列中，
add you know, this white space to that queue the the uart actually has,

984
01:06:30,820 --> 01:06:33,280
但同时在另一个 CPU 上，
but at the same time on another CPU,

985
01:06:33,370 --> 01:06:38,050
它可能在处理来自 UART 的中断，
it might actually take interrupt you know for the uart

986
01:06:38,200 --> 01:06:41,740
这也是并行运行的，
and basically also running in parallel

987
01:06:41,740 --> 01:06:44,680
这是相同的代码，查看相同的队列。
and that's sort of roughly the same code and looking at the same queue.

988
01:06:45,300 --> 01:06:46,380
所以这是真的，
And so it's really true

989
01:06:46,380 --> 01:06:48,870
中断处理程序可以并行运行，
that basically the interrupt handler can run in parallel

990
01:06:48,870 --> 01:06:50,400
设备驱动的底部，
at the bottom half of the device driver

991
01:06:50,400 --> 01:06:52,530
可能并行运行在不同的 CPU 上，
may run in parallel on different CPUs,

992
01:06:53,000 --> 01:06:56,660
与驱动程序的顶部位于不同的 CPU 上。
on the different CPU with the top half of the driver.

993
01:06:57,270 --> 01:06:58,650
所以我们必须处理好这个，
So we have to manage that a bit,

994
01:06:58,950 --> 01:07:02,460
而我们管理的方式就是使用锁。
and the way we're going to manage that is using locks.

995
01:07:06,060 --> 01:07:07,740
因为这里有一个共享的数据结构，
Because there's a shared data structure here

996
01:07:07,740 --> 01:07:09,360
我们需要一个缓冲区，
and then we need a buffer

997
01:07:09,480 --> 01:07:13,800
我们要确保缓冲区正确更新，
and we're going to make sure that you know the buffer is updated correctly,

998
01:07:14,040 --> 01:07:19,860
需要确保一次只有一个 CPU
and you need to make sure that only one CPU at a time,

999
01:07:19,860 --> 01:07:21,750
操纵这个特定的缓冲区，
basically manipulates that particular buffer,

1000
01:07:21,750 --> 01:07:22,620
我们需要使用锁。
we're going to use locks.

1001
01:07:23,100 --> 01:07:25,500
锁将是周三课程的主题，
And locks is going to be the topic of Wednesday's lecture,

1002
01:07:25,560 --> 01:07:27,180
我不会讨论太多，
I'm not gonna talk much about it at all,

1003
01:07:27,210 --> 01:07:29,190
但是在周三会有很多讨论。
but it will show a big time on Wednesday.

1004
01:07:30,810 --> 01:07:38,090
我想关注的是生产者-消费者平行性，
The thing I want to focus on is actually to producer consumer parallelism,

1005
01:07:38,240 --> 01:07:41,300
这是一种在驱动程序出现的典型模式，
and this is a typical thing that shows up in drivers

1006
01:07:41,300 --> 01:07:44,990
这是非常常见的。
and it's extremely common to see that.

1007
01:07:44,990 --> 01:07:48,260
生产者和消费者。
So producer consumer.

1008
01:07:53,150 --> 01:07:55,520
这也很简单，
And it's pretty straightforward,

1009
01:07:55,550 --> 01:08:00,020
当你看到，驱动程序中有一个缓冲区，
so when you see, you know there's basically a buffer in the driver,

1010
01:08:01,750 --> 01:08:04,240
在我们的示例中，我想有 32 个条目，
you know in our case, I think there were 32 entries in it,

1011
01:08:04,630 --> 01:08:07,210
从 0 到 31 ，
so zero to three one

1012
01:08:07,420 --> 01:08:10,240
并且有两个指针，
and there's two pointers,

1013
01:08:10,700 --> 01:08:12,890
有一个读指针和一个写指针。
there's a read pointer and the write pointer.

1014
01:08:13,870 --> 01:08:17,290
写指针，读指针，
You know, the write pointer read pointer

1015
01:08:17,320 --> 01:08:20,380
如果它们相等，缓冲区就是空的，
if they are equal, you know the buffer is empty

1016
01:08:20,560 --> 01:08:24,760
当 shell 写入时，比如使用 putc ，
and so when you know the shell, we do a write, you know putc,

1017
01:08:26,800 --> 01:08:29,710
就是把像 $ 这样的字符放到这里，
that basically puts the character like the $ here

1018
01:08:29,860 --> 01:08:32,740
并将写指针指向下一条目。
and bumps up the write pointer to the next entry.

1019
01:08:34,440 --> 01:08:36,030
这就是生产者的部分，
So that's sort of the producer part

1020
01:08:36,240 --> 01:08:37,740
生产者可以继续，
and the producer can keep going,

1021
01:08:37,740 --> 01:08:40,560
填满所有这些字符，
you know filling up you know all this characters

1022
01:08:40,560 --> 01:08:45,610
直到到达，
until you know it, until hits you know the,

1023
01:08:45,610 --> 01:08:48,190
直到如果下一个将达到读指针，
until you know if the next increment would hit the read pointer,

1024
01:08:48,190 --> 01:08:50,980
我们知道这个循环缓冲区已满，
we know that this circle buffer is full

1025
01:08:51,100 --> 01:08:53,170
在这时，生产者必须停止，
and at that point you know the producer must stop

1026
01:08:53,200 --> 01:08:56,650
我们之前在代码中看到了，
and we saw that happening in the, in the code a second ago,

1027
01:08:56,650 --> 01:08:59,440
UART 调用 sleep ，
where the uart, basically the uart called sleep

1028
01:08:59,470 --> 01:09:04,760
把 shell 放在边上，
and will put this the shell on the side

1029
01:09:04,760 --> 01:09:06,410
并运行另一个进程。
and start running another process.

1030
01:09:07,940 --> 01:09:10,940
所以中断处理程序 uartinit 或 intr ，
So the interrupt handler, uartinit or intr,

1031
01:09:12,870 --> 01:09:14,640
这种情况下，在消费者这边，
in this case at the consumer,

1032
01:09:14,730 --> 01:09:20,580
每次都是 uartstart ，
immediately every time when it's a uartstart basically,

1033
01:09:20,820 --> 01:09:25,320
当你在中断中，它查看读指针，
when you're in interrupts, it will look at you know the read pointer,

1034
01:09:25,470 --> 01:09:28,320
如果读指针在写指针之后，
if the read pointer is behind the write pointer,

1035
01:09:28,320 --> 01:09:29,730
写指针已经走远，
so the write pointer already further,

1036
01:09:29,730 --> 01:09:31,410
假设这里是空格，
let's say spaces here too, now,

1037
01:09:31,410 --> 01:09:33,900
我不知道怎么画空格，但这有一个空格。
I don't know actually how to draw a space, but here's a space.

1038
01:09:34,500 --> 01:09:37,110
所以写指针现在可能在这里。
And so the write pointer might now be here.

1039
01:09:37,680 --> 01:09:39,570
所以在[]发出之后，
So after the [] being sent,

1040
01:09:39,570 --> 01:09:43,020
UART 看到，在写指针后面，
you know the uart sees, you know I'm behind the write pointer,

1041
01:09:43,020 --> 01:09:45,000
这意味着得发送下一个。
and that means I got to send the next one.

1042
01:09:46,280 --> 01:09:48,290
所以你可以把它看作是，
And so you can think about this as sort of

1043
01:09:48,290 --> 01:09:52,430
写指针，读指针在改变写指针，
the write you know pointer, the read pointer is changing the the write pointer

1044
01:09:52,640 --> 01:09:56,390
这就是正在发生的事情，
and that's what's going on,

1045
01:09:56,390 --> 01:09:57,290
现在可能出现，
now it could be the case,

1046
01:09:57,290 --> 01:10:02,330
在某个时候， UART 与写指针保持同步，
that at some point, the uart keeps up with the write pointer

1047
01:10:02,330 --> 01:10:05,150
当它们相等时，它知道缓冲区是空的，
and when they're equal and then it knows that the buffer is empty

1048
01:10:05,150 --> 01:10:05,900
没什么事情可做。
and there's nothing to do.

1049
01:10:09,220 --> 01:10:09,910
这能理解吗？
Does that make sense?

1050
01:10:12,190 --> 01:10:16,900
不好意思，这个数据结构对所有核心都是相同的吗？
Sorry, so this data structure is the same for all cores?

1051
01:10:17,400 --> 01:10:20,520
好的，让我回到代码上来，
Okay, so let me go back to the code right,

1052
01:10:20,550 --> 01:10:23,010
然后是高层级的图片。
then a high-level picture.

1053
01:10:23,560 --> 01:10:25,090
让我们回到 UART ，
And let's go back to uart,

1054
01:10:25,090 --> 01:10:26,260
所以这个数据结构，
so this data structure,

1055
01:10:26,820 --> 01:10:28,920
刚才谈到的就是这个缓冲区。
that we just talked about is this buffer.

1056
01:10:32,600 --> 01:10:35,240
这两个指针，写指针和读指针，
And the two pointers you know the write and the read pointer,

1057
01:10:35,240 --> 01:10:38,430
是两个索引用来[]。
are these two indexes use in [].

1058
01:10:39,330 --> 01:10:39,990
好的?
Okay?

1059
01:10:41,080 --> 01:10:44,110
并且这个数据结构在内存中，
And this data structure is in memory,

1060
01:10:45,010 --> 01:10:47,200
这里只有一个 RAM ，
and there's only one RAM right

1061
01:10:47,200 --> 01:10:51,790
所以，所有核心都可能与这个数据结构并行交互。
and so all the cores might be interacting with this data structure in parallel.

1062
01:10:53,220 --> 01:10:54,510
这就是为什么我们需要锁。
That's why we need locks.

1063
01:10:57,350 --> 01:10:58,340
好的，我知道了。
Okay I see.

1064
01:10:58,370 --> 01:11:01,160
还有一个关于 sleep 的问题，
And rather the question was for sleep,

1065
01:11:02,180 --> 01:11:07,630
它怎么知道让 shell 睡觉，
how does it know to make the shell sleep,

1066
01:11:07,690 --> 01:11:11,770
比如，那里写入的只有地址。
like what is written there is just the address of.

1067
01:11:11,770 --> 01:11:22,640
基本上， sleep 让当前运行的进程进入睡眠状态，
Let me, basically the sleep puts the current process running on the sleep, in a sleep state,

1068
01:11:23,030 --> 01:11:26,960
我们下周会讨论它的很多细节。
we'll talk about it in next week or the week after a great amount of detail.

1069
01:11:27,520 --> 01:11:31,120
它传入的是，正在等待的东西。
And it passes in the thing that is waiting for.

1070
01:11:31,690 --> 01:11:33,040
在这种情况下，
And in this case,

1071
01:11:33,040 --> 01:11:36,580
这个地址有一个 channel id ，
that is the address, you know basically has a channel id

1072
01:11:36,580 --> 01:11:39,520
或者一种与睡眠程序交互的方式。
or a way of communicating from what actually sleeping on.

1073
01:11:40,260 --> 01:11:45,120
在本例中，[] 是 uart_tx_r 的地址。
And so in this case, the [] is the address of uart_tx_r.

1074
01:11:45,750 --> 01:11:51,390
并且 start 函数，
And, and the start function,

1075
01:11:51,600 --> 01:11:54,480
它需要缓冲区中的空间，
it wants their space again in the buffer,

1076
01:11:54,630 --> 01:11:56,520
它会唤醒，
it will wakeup,

1077
01:11:57,380 --> 01:12:00,500
使用对应的 wakeup 以及 urat_tx_r ，
call the corresponding call wakeup with the uart_tx_r

1078
01:12:00,500 --> 01:12:04,640
表示睡眠在这个地址的任何进程都应该唤醒。
to indicate that any process that actually sleeping on this address should be woken up.

1079
01:12:07,190 --> 01:12:10,640
具体是如何实现的，我们稍后会看到。
And how does exactly implemented is something that we'll see a little bit later.

1080
01:12:13,680 --> 01:12:14,310
这能理解吗。
So, it makes sense.

1081
01:12:14,790 --> 01:12:17,280
所以，这两个调用是相互的， sleep 和 wakeup ，
So these two calls go together, sleep and wakeup,

1082
01:12:21,470 --> 01:12:23,510
有时称为条件同步。
sometimes called conditional synchronization.

1083
01:12:27,440 --> 01:12:28,370
还有其他问题吗？
Any other questions?

1084
01:12:35,990 --> 01:12:36,560
好的。
Okay.

1085
01:12:37,590 --> 01:12:38,580
很好。
Good.

1086
01:12:39,530 --> 01:12:42,140
让我们看看。
Let's, let's see.

1087
01:12:43,100 --> 01:12:48,470
所以，这就是打印 $ 的全部故事，
So that there's basically the whole story for printing $

1088
01:12:48,470 --> 01:12:53,030
正如你所看到的，它涉及到很多部分，
and as you can see it's actually quite involved a lot of pieces

1089
01:12:53,030 --> 01:12:56,870
（这些部分）一起将 $ 发送到 console 。
that you know working together to actually get this $ out to the console.

1090
01:12:57,710 --> 01:13:02,450
类似的事情也发生在读取端，
And something similar basically happens on the read side,

1091
01:13:02,450 --> 01:13:08,690
在某个时候， shell 打印 $ 和空格，
so at some point shell has printed the both the $ and the white space,

1092
01:13:08,690 --> 01:13:13,280
然后调用 read 读取来自键盘的输入，
and then will call read to basically read input from the keyboard,

1093
01:13:13,580 --> 01:13:16,010
所以现在我们看看发生了什么，
so now we wanted to see what happens,

1094
01:13:16,070 --> 01:13:18,890
当它发生时，
when that happening,

1095
01:13:18,890 --> 01:13:21,920
这也是从 file 开始的。
so that starts basically in the with file again.

1096
01:13:22,470 --> 01:13:24,630
所以现在有一个读系统调用，
So now there's a read system call,

1097
01:13:24,960 --> 01:13:27,630
如果从 console 上读，
if it's you know reading from the console,

1098
01:13:27,630 --> 01:13:31,280
它会调用 fileread ，
it will calls, it will actually of course fileread,

1099
01:13:31,310 --> 01:13:32,840
抱歉，不是 write 。
sorry not write.

1100
01:13:34,500 --> 01:13:38,610
如果它是设备，在本例中是 console ，
If it's the device which in this case, the case is a console,

1101
01:13:38,610 --> 01:13:41,910
然后，我们调用该设备的读方法，
then we call the read method for that device,

1102
01:13:42,320 --> 01:13:44,510
这在 console.c 中，
and that is in console.c

1103
01:13:44,510 --> 01:13:47,480
所以，我们调用 consoleread 。
and so we're going to, consoleread is being called.

1104
01:13:49,330 --> 01:13:52,150
基本上它与 UART 有相同的结构，
And basically it has the same structure as uart,

1105
01:13:52,150 --> 01:13:55,470
在顶部有一个环形缓冲区。
you know there's a circular buffer on the top.

1106
01:13:56,700 --> 01:14:01,260
这就是它， INPUT_BUF ，有 128 个字符，
Here it is, it's INPUT_BUF [] the 128 characters in it

1107
01:14:01,500 --> 01:14:02,910
基本上是相同的游戏，
and basically it's the same game,

1108
01:14:02,940 --> 01:14:04,770
是生产者-消费者并行性，
its producer consumer parallelism,

1109
01:14:04,950 --> 01:14:07,560
但是，在这种情况下， shell 是消费者，
but in this case, the shell is the consumer, right,

1110
01:14:07,560 --> 01:14:11,550
它从缓冲区中读取字符。
it actually is reading you know characters off the buffer.

1111
01:14:12,040 --> 01:14:13,930
键盘是生产者，
And the keyboard is the producer,

1112
01:14:13,930 --> 01:14:16,540
它将字符放入缓冲区。
it takes the characters into the buffer.

1113
01:14:17,250 --> 01:14:20,280
所以，让我们回到 consoleread ，
And so you know, let's go back to consoleread,

1114
01:14:20,310 --> 01:14:22,500
如果什么都没有，
if there's nothing,

1115
01:14:22,500 --> 01:14:26,850
如果读指针，读索引和写索引相同，
if the read pointer where to read index and write index are the same,

1116
01:14:26,850 --> 01:14:28,440
缓冲区是空的，
you know the buffer is empty

1117
01:14:28,650 --> 01:14:30,420
它又回到睡眠状态。
and it goes back to sleep again.

1118
01:14:31,320 --> 01:14:35,340
所以，在打印 $ 之后，
And so, so after it's printed dollar [],

1119
01:14:35,520 --> 01:14:38,190
shell 会去睡眠，
the shell is go to sleep,

1120
01:14:38,520 --> 01:14:44,340
内核将 shell 置于睡眠状态，直到字符进入。
kernel put the shell sleep until character comes in.

1121
01:14:45,440 --> 01:14:49,280
在某一时刻，用户输入 l ，
And so at some point, let's say user types in l,

1122
01:14:49,670 --> 01:14:52,370
ls 的第一个字符，
you know the first character from ls on the keyboard,

1123
01:14:52,700 --> 01:15:00,110
这将导致 l 发送到电路板上的 UART 芯片，
that will calls, you know, the l to be sent into the uart chip on the on the board,

1124
01:15:00,530 --> 01:15:04,100
它将通过 PLIC 到某个核心，
that will be round through the plic to some core,

1125
01:15:04,100 --> 01:15:07,220
核心将接受中断，到 devintr ，
that core will take the interrupt that will go to devintr,

1126
01:15:07,220 --> 01:15:09,650
devintr ，我们会看到 UART 中断是如何进行的，
the devintr we'll see how that goes uart interrupt

1127
01:15:09,950 --> 01:15:14,630
它将调用我们刚才看到的函数。
and it will call the function that we looked at a second ago.

1128
01:15:15,020 --> 01:15:16,820
它会回到底部，
It goes back to the bottom,

1129
01:15:16,850 --> 01:15:19,190
我自己迷惑了一下的地方，
where I got confused myself for a second,

1130
01:15:19,700 --> 01:15:22,550
所以在这种情况下，它会写，
so in this case, you know it will write,

1131
01:15:22,610 --> 01:15:25,250
它会从 UART 设备获取字符，
it will get a character from the device from uart device

1132
01:15:25,250 --> 01:15:26,630
获得字符 l ，
that will get the character l

1133
01:15:26,870 --> 01:15:31,250
使用字符 l 调用 consoleintr 函数，
and will call the consoleintr function using the character l,

1134
01:15:31,370 --> 01:15:33,230
这样我们就可以回到 console 。
so we can go back to console.

1135
01:15:36,100 --> 01:15:39,490
consoleintr 得到那个字符，
And consoleintr does gets the character,

1136
01:15:39,490 --> 01:15:42,070
所以现在我们有一个 l ，
so now we have an l,

1137
01:15:42,070 --> 01:15:46,330
它是控制 P ，打印进程列表，
it's a control P, you know actually printing list, in the process list,

1138
01:15:46,780 --> 01:15:49,240
实现控制 H 和 控制 U ，
implements control H and control U,

1139
01:15:49,300 --> 01:15:51,880
用来回退和控制别的东西。
to do backspace and control whatever.

1140
01:15:52,320 --> 01:15:53,850
但是，在所有其他情况下，
But in all other cases,

1141
01:15:53,880 --> 01:15:55,170
基本上所做的是，
basically what it does,

1142
01:15:55,440 --> 01:15:59,670
通过将字符打印到 console 将其回显给用户。
it echoes the character back to the user by printing it to the console.

1143
01:16:00,300 --> 01:16:03,990
然后它将字符放入缓冲区，
And then it basically sticks the character into the buffer,

1144
01:16:04,260 --> 01:16:09,330
并唤醒等待缓冲区的进程，
so that and wakeup you know the process that's waiting for the buffer,

1145
01:16:09,390 --> 01:16:10,590
如果有进程在等待。
if there's a process waiting.

1146
01:16:11,190 --> 01:16:14,760
如果它达到换行，并且有进程等待，
If it has hit newline and there's a process waiting,

1147
01:16:14,760 --> 01:16:17,010
它会唤醒等待进程，
it will wake up the waiting process,

1148
01:16:17,280 --> 01:16:20,370
然后等待进程将从缓冲区中读取字符。
and then the waiting process will read you know the characters out of the buffer.

1149
01:16:22,520 --> 01:16:25,100
这里我们又看到了这种解耦，
Okay, so here again we see this sort of decoupling

1150
01:16:25,100 --> 01:16:28,310
在生产者和消费者之间使用缓冲区，
using a buffer between the consumer and the producer,

1151
01:16:28,310 --> 01:16:30,620
以便生产者消费者可以并行运行，
so that the producer consumer can run in parallel,

1152
01:16:31,140 --> 01:16:33,210
以各自的速度独立运行，
independent each on their own speed,

1153
01:16:33,540 --> 01:16:34,950
如果一个跑得很快，
and if one goes very fast,

1154
01:16:35,010 --> 01:16:37,170
无论缓冲区是空，还是满，
you know either buffer will be empty or full,

1155
01:16:37,170 --> 01:16:39,990
就阻塞并等待对方追赶上来。
and then block wait until the other guy catch up.

1156
01:16:43,380 --> 01:16:44,430
这个，有什么问题吗？
Any questions about this?

1157
01:16:55,150 --> 01:16:55,810
好的。
Okay.

1158
01:16:58,750 --> 01:17:01,570
好的，我想再谈一件事。
Okay, I wanna talk basically about one more thing.

1159
01:17:04,760 --> 01:17:05,810
那就是。
In that is.

1160
01:17:09,440 --> 01:17:13,610
我主要谈论中断的发展，
You know I'm mostly talking a little bit about sort of interrupt evolution,

1161
01:17:13,640 --> 01:17:15,860
比如，过去几十年发生的事情。
like what has happened over the last decades.

1162
01:17:25,230 --> 01:17:30,090
所以，对于处理器来说，中断曾经是相当快的，
So the interrupts used to be relative to processor reasonable fast,

1163
01:17:31,420 --> 01:17:32,320
特别是在，
in particular in the,

1164
01:17:32,320 --> 01:17:37,350
曾经很快。
used to be fast.

1165
01:17:38,120 --> 01:17:40,580
所以，在最初的 Unix 被开发的时候，
So in times the original Unix was developed,

1166
01:17:41,030 --> 01:17:42,710
就是这种情况，
you know that was the case

1167
01:17:42,980 --> 01:17:45,380
意味着硬件非常简单。
and that basically meant that the hardware is very simple.

1168
01:17:46,310 --> 01:17:50,360
因为，如果有什么重要的工作要做，
Because you know if any really serious work needs to be done,

1169
01:17:50,480 --> 01:17:52,160
我们可以直接中断处理器，
[] we could just interrupt the processor

1170
01:17:52,430 --> 01:17:54,500
处理器会做这些工作，
and the processor would do it on the work

1171
01:17:54,500 --> 01:17:58,760
所以硬件本身是非常直接的。
and so hardware itself could be reasonable straight forward.

1172
01:17:59,850 --> 01:18:04,600
现在，与处理器相比，中断比较慢，
Now, interrupts are slow compared to the processor,

1173
01:18:04,960 --> 01:18:06,370
你可以看到，
you can see that right,

1174
01:18:06,370 --> 01:18:10,060
因为中断处理程序需要保存寄存器，
because the interrupt handler, it needs to save to registers,

1175
01:18:10,090 --> 01:18:11,590
它需要接受中断，
it needs to take the interrupt,

1176
01:18:11,590 --> 01:18:16,420
有几个预算指令，
so there's a couple you know a small budget instructions

1177
01:18:16,420 --> 01:18:18,880
它们只用来服务于中断。
that are just being used to actually serve the interrupt.

1178
01:18:19,460 --> 01:18:23,780
因此如果设备产生高速中断，
And so if device generates interrupts the high speed,

1179
01:18:23,780 --> 01:18:26,630
处理器很难跟上。
you know then the processor going to have a tough time keeping up.

1180
01:18:27,500 --> 01:18:30,530
所以，你看今天的设备，
And so you look at today's devices,

1181
01:18:30,560 --> 01:18:33,620
硬件或设备有更多的工作要做，
basically the hardware or the device there's a lot more work,

1182
01:18:39,400 --> 01:18:43,300
设备本身有很多工作要做，
and so basically there's a bunch of work actually on the device itself,

1183
01:18:43,300 --> 01:18:45,130
在实际生成中断之前。
before actually generating an interrupt.

1184
01:18:45,940 --> 01:18:50,590
所以，为了避免过多地中断处理器，
And so, and just to avoid interrupting the processor too much,

1185
01:18:51,350 --> 01:18:54,920
现在，如果你有一个高性能设备，
now, if you really have a high performance device,

1186
01:18:54,920 --> 01:18:59,130
比如，你有千兆以太网，
like say you have gigabytes gigabits Ethernet,

1187
01:19:01,000 --> 01:19:05,560
这块网卡使用很多小包，
and you know that card is use a lot of small packages packets,

1188
01:19:05,830 --> 01:19:10,480
那么网卡可以产生，
then you know you can actually generate or Ethernet itself could generate

1189
01:19:10,480 --> 01:19:13,600
大约每秒 150 万个包，
about one five or 1.5 million packets per second,

1190
01:19:16,290 --> 01:19:19,110
对于最小的 64 字节以太网包，
for minimum of like 64 byte Ethernet package,

1191
01:19:19,110 --> 01:19:21,330
你粗略计算一下，
you do a math roughly out to,

1192
01:19:21,330 --> 01:19:24,810
每秒生成 150 万个包，你可以接收。
basically you generated 1.5 million packets per second you could receive.

1193
01:19:25,440 --> 01:19:31,570
所以，这意味着如果你对每个包中断，
And so that basically means you know one interrupt, if you did it for every packet,

1194
01:19:32,280 --> 01:19:33,480
那就是一微秒一个中断
per microsecond.

1195
01:19:37,330 --> 01:19:40,390
事实上，略高于，
In fact, a little more than,

1196
01:19:40,960 --> 01:19:42,970
略低于，
a little less than,

1197
01:19:42,970 --> 01:19:44,290
略高于，
a little bit more than,

1198
01:19:44,320 --> 01:19:48,400
所以，考虑如果一微秒一个中断，
so basically one way to think about if one interrupt microsecond,

1199
01:19:48,400 --> 01:19:50,500
内核中的操作，
there's basically the operations in a kernel,

1200
01:19:50,560 --> 01:19:55,000
有一微秒的预算指令来处理这个包，
basically has a budget of like one microsecond instructions to actually process that packet,

1201
01:19:55,000 --> 01:19:56,380
实际上是 150 万，
in fact it's 1.5 million,

1202
01:19:56,380 --> 01:20:01,690
这比一微秒的预算要少一点。
such a little bit less than a budget of a microsecond.

1203
01:20:02,540 --> 01:20:04,760
你可以计算出有多少条指令，
And you can compute how many instructions that is,

1204
01:20:04,940 --> 01:20:06,290
不会有那么多，
there's not gonna be that much

1205
01:20:06,650 --> 01:20:08,810
所以在这种情况下，
and so in that case,

1206
01:20:08,810 --> 01:20:11,000
我们需要有一个不同的计划，
you know we need to have a different plan,

1207
01:20:11,000 --> 01:20:14,210
那么你怎么处理这些中断包，
so what do you do with the packets or interrupt you know packets

1208
01:20:14,210 --> 01:20:18,800
以超过处理器速度进来的包。
are coming in so fast that processor really can't keep up.

1209
01:20:19,550 --> 01:20:25,310
对于快速设备的解决方案是，
And the solution to that is to with fast devices is

1210
01:20:25,400 --> 01:20:27,620
有时称为轮询。
actually sometimes uses called polling.

1211
01:20:32,960 --> 01:20:36,560
不是写入中断，
And, instead of writing interrupts,

1212
01:20:36,560 --> 01:20:39,140
CPU 也可以，
you know what the CPU also could do is

1213
01:20:39,140 --> 01:20:41,750
只是读取控制寄存器，
just keep reading that control register

1214
01:20:41,780 --> 01:20:43,160
查看那里是否有一个字节，
and to see if there's a byte there,

1215
01:20:43,160 --> 01:20:44,480
比如在 UART 寄存器中，
like in uart register,

1216
01:20:44,480 --> 01:20:47,660
我们只是不停读取 LHR 寄存器，
we just keep reading that LHR register

1217
01:20:47,750 --> 01:20:49,580
只是检查那里是否有一个字节。
and just check if there's a byte there.

1218
01:20:50,150 --> 01:20:56,330
说到底，这是 CPU 旋转，
In basically, would you know what this boils down to is that the CPU you know spins,

1219
01:20:58,640 --> 01:21:00,950
它在设备上旋转，
it spins on the device,

1220
01:21:01,490 --> 01:21:07,030
直到设备有输入，有数据。
you know until device has input, has data.

1221
01:21:10,590 --> 01:21:13,230
这会浪费 CPU 周期，
And you know this waste CPU cycles right,

1222
01:21:13,230 --> 01:21:20,760
因为我们一遍又一遍地检查那个寄存器，
because while we're checking that register over and over and over again

1223
01:21:20,880 --> 01:21:22,920
看它是否是数据，
to see if they're actually any data,

1224
01:21:23,070 --> 01:21:27,030
我们没有使用这些周期来运行另一个应用程序，
you know we're not using those cycles to run another application right

1225
01:21:27,030 --> 01:21:29,580
我们之前看到的，
and you know before what you're seeing is that

1226
01:21:29,580 --> 01:21:33,120
如果没有任何东西，内核会让 shell 睡眠，
if there's nothing there, basically the kernel push the shell to sleep,

1227
01:21:33,150 --> 01:21:34,680
以便另一个应用程序可以运行。
so that another application could run.

1228
01:21:35,080 --> 01:21:39,250
但是如果我们做轮询，那就不会发生了，
But if we do polling, then that wouldn't happen,

1229
01:21:39,430 --> 01:21:41,080
现在，对于速度慢的设备，
now for a slow device,

1230
01:21:41,170 --> 01:21:43,750
你当然希望不是永远旋转，
you clearly want you know not spin forever

1231
01:21:43,750 --> 01:21:46,810
直到设备来做它的工作，
until device finally gets around to actually doing its work,

1232
01:21:47,170 --> 01:21:51,910
我们想从 shell 切换出去，
we really like to basically switch out the shell

1233
01:21:51,910 --> 01:21:53,200
并运行其他东西。
and so that we can run something else.

1234
01:21:53,260 --> 01:21:55,420
但如果设备速度非常快，
But if the device is extremely fast,

1235
01:21:55,800 --> 01:21:58,770
则中断的开销很高，
then the overhead of the interrupt features high

1236
01:21:58,770 --> 01:22:02,310
我们最好还是轮询设备，
and you know we're better off actually waiting basically polling the device,

1237
01:22:02,310 --> 01:22:04,560
因为我们很快就会成功。
because very quickly we're going to get success.

1238
01:22:06,840 --> 01:22:10,590
但是，如果设备比较慢，又浪费 CPU 。
And so if, but so if waste CPU, if device slow.

1239
01:22:16,410 --> 01:22:24,880
但是如果设备速度很快，
But you know, but if devices fast,

1240
01:22:29,990 --> 01:22:33,440
它节省了保存时间，
it saves save saving or storing,

1241
01:22:36,740 --> 01:22:39,950
节省了 entry 和 exit 成本。
which saves the all entry entry and exit costs.

1242
01:22:45,610 --> 01:22:48,550
所以，比如高性能网卡，
And so for example, high performing network card,

1243
01:22:48,550 --> 01:22:52,150
如果有一连串包进来，
you know, will you know if it's a stream of packets coming in

1244
01:22:52,150 --> 01:22:53,650
将使用轮询。
and actually will use polling.

1245
01:22:54,180 --> 01:22:57,030
更多的复杂驱动，
And you know more and the most sophisticated drivers

1246
01:22:57,210 --> 01:23:04,470
它们会动态切换地在轮询和中断之间切换。
basically they dynamically switch, switch between polling and interrupts.

1247
01:23:18,170 --> 01:23:19,670
好的。
Okay.

1248
01:23:20,930 --> 01:23:21,830
有什么问题吗？
Any questions?

1249
01:23:24,300 --> 01:23:27,030
我的安排时间快到了。
Close to my, my time budget is up.

1250
01:23:29,180 --> 01:23:30,440
有什么剩下的问题吗？
Any your remaining questions?

1251
01:23:35,170 --> 01:23:37,600
好的，那我们周三见，
Okay, good, then I'll see you on Wednesday

1252
01:23:37,600 --> 01:23:42,250
在周三，我们将继续并发并行的故事，
and basically Wednesday, we're going to continue the story of concurrency parallelism,

1253
01:23:42,250 --> 01:23:45,370
我们将看到一些机制管理并行，
we're gonna see some mechanisms to actually manage the parallelism

1254
01:23:45,490 --> 01:23:48,640
确保共享数据结构正确获取它们的数据。
to make sure that shared data structures, get them data correctly.

1255
01:23:49,380 --> 01:23:51,000
那么，周三见。
So, see you on Wednesday.

1256
01:23:54,660 --> 01:23:59,010
抱歉，我想找出我的问题在哪里，
Oh, I'm sorry, I just I was trying to find where my question was,

1257
01:23:59,010 --> 01:24:00,120
因为我把它弄丢了，
because I lost it,

1258
01:24:00,210 --> 01:24:03,690
我的问题是，
my question was in the,

1259
01:24:03,720 --> 01:24:08,100
所以我看到 uartinit 只被调用了一次，
so I saw it, uartinit is just being called once,

1260
01:24:08,100 --> 01:24:16,580
这是为什么只有一个缓冲区供所有核心共享的原因吗？
is that why there's just one buffer for all the cores to share together.

1261
01:24:18,970 --> 01:24:21,160
好的，这里只有一个 UART 设备。
Well, there's always the only one uart device.

1262
01:24:24,460 --> 01:24:28,690
缓冲区对应于 UART 设备，
Buffer corresponds you know to the one uart device

1263
01:24:28,690 --> 01:24:30,760
实际上是由多个核心共享的。
actually is being shared between all the cores.

1264
01:24:31,300 --> 01:24:35,560
它可能是在不同核心上运行的多个进程，
You know like it might be multiple processes running on different cores,

1265
01:24:35,560 --> 01:24:37,060
都在试图打印到控制台。
all trying to print to the console.

1266
01:24:38,460 --> 01:24:39,930
好的，我明白了，
Okay I see,

1267
01:24:39,960 --> 01:24:42,120
是的，有道理。
oh yeah, makes sense makes sense.

1268
01:24:42,820 --> 01:24:49,090
所以，只有一个队列会使用 UART 执行任务。
So like only one queue will do stuff with uart to the time.

1269
01:24:49,620 --> 01:24:52,200
是的，这有点复杂，
Yeah, well you know it's slightly complicated,

1270
01:24:52,200 --> 01:24:55,680
但是假设有多个人在写，
but let's look, like, so let's say there's multiple guys writing,

1271
01:24:56,240 --> 01:25:00,080
只需做一次实验就行了。
just afford as one [experiment], correct.

1272
01:25:01,460 --> 01:25:06,570
我们看到有多个，
And and what we see there are multiple,

1273
01:25:06,660 --> 01:25:07,650
让我。
let me actually.

1274
01:25:11,630 --> 01:25:13,160
这里是 uartputc ，
So here uartputc,

1275
01:25:13,160 --> 01:25:15,860
你看到的第一件事是它需要一个锁。
the first thing you see is actually it actually requires a lock.

1276
01:25:16,790 --> 01:25:21,380
多个核心正在将一个字符放入缓冲区，
So the multiple cores are trying to put a character into the buffer

1277
01:25:21,650 --> 01:25:23,240
它们中的一个获得锁，
and one of them is going to get the lock

1278
01:25:23,270 --> 01:25:24,830
其他都不会获得锁，
and none of the others are going to lock,

1279
01:25:25,190 --> 01:25:29,420
所以那个获得锁的 CPU ，
so that one guy you know the one CPU that actually got the lock, required to lock successfully,

1280
01:25:29,660 --> 01:25:33,380
可以查看写指针，
is able to go and look at the write pointer

1281
01:25:33,380 --> 01:25:36,800
把字符放入其中，
and stick character in it possible

1282
01:25:36,800 --> 01:25:38,180
否则去睡眠。
and otherwise go to sleep.

1283
01:25:38,850 --> 01:25:43,230
如果它完成了，就可以解锁，
And you know and then if it's done, you know releases the lock,

1284
01:25:43,650 --> 01:25:46,440
然后下一个核心可以进入，
and then the next you know core can go in

1285
01:25:46,440 --> 01:25:48,450
获取锁并做它的工作。
and acquire the lock and do its work.

1286
01:25:48,910 --> 01:25:54,820
所以，这个锁会序列化对 UART 的并发访问。
So this lock will serialize the concurrent accesses to the uart.

1287
01:25:58,400 --> 01:26:00,560
理解了，是的，谢谢。
That makes sense, yeah, thank you.

1288
01:26:02,000 --> 01:26:04,700
好的，星期三我们将详细讨论锁的问题。
Well, on Wednesday, we'll talk in detail about locks.

1289
01:26:07,210 --> 01:26:08,110
谢谢。
Thank you.

1290
01:26:10,160 --> 01:26:11,420
还有什么问题吗？
Any further questions?

1291
01:26:12,750 --> 01:26:13,860
我有个问题。
I have a question.

1292
01:26:14,730 --> 01:26:20,690
我知道我们要在中断使用锁，
So, as far as I understand why we need the lock inside the interrupted,

1293
01:26:20,690 --> 01:26:22,910
因为只有一个控制台，
because we there's only one console

1294
01:26:22,910 --> 01:26:24,920
而有多个核心。
and they could multiple cores, right.

1295
01:26:27,000 --> 01:26:29,190
你是说哪里的锁。
You mean the where is the lock, where.

1296
01:26:29,550 --> 01:26:31,380
我想是这样的，
I think so right,

1297
01:26:31,410 --> 01:26:34,770
因为通常我们不想在中断内部使用锁。
because usually we don't want to lock things inside interrupts right.

1298
01:26:34,800 --> 01:26:37,800
是的，你通过电子邮件问了这个问题。
Yeah you asked this question by email.

1299
01:26:37,830 --> 01:26:38,880
是的。
Yeah.

1300
01:26:39,180 --> 01:26:41,010
是的，问题是，
Yes, well the issue is,

1301
01:26:41,010 --> 01:26:42,750
正如前面提到的，
that the as mentioned earlier,

1302
01:26:42,780 --> 01:26:48,930
底部的中断处理可以和顶部的并行运行。
the bottom half interrupt handler could run in parallel with the top half.

1303
01:26:49,480 --> 01:26:53,500
所以，一个核心可能正在执行 uartputc ，
And so one core could be doing uartputc

1304
01:26:53,710 --> 01:26:56,140
而另一个核心可能正在运行 uartintr ，
and another core could be running uartintr,

1305
01:26:56,530 --> 01:26:59,440
我们要确保它们在某种程度上，
we got to make sure that they sort of,

1306
01:26:59,440 --> 01:27:01,390
不会纠缠在一起，
don't get tangled up together,

1307
01:27:01,420 --> 01:27:02,590
让它们串行，
that they serialized correctly

1308
01:27:02,590 --> 01:27:04,870
锁确保了它们被序列化。
and the lock basically ensures that they get serialized.

1309
01:27:05,480 --> 01:27:06,950
好的，有道理，
Okay, that makes sense,

1310
01:27:06,950 --> 01:27:10,430
但是否意味着有时候
but that does mean that sometimes

1311
01:27:10,430 --> 01:27:13,160
所有的核心都可能在等待
like all cores could potentially be waiting for

1312
01:27:13,160 --> 01:27:15,410
其中的一个处理这件事。
one of them to be handling this, right.

1313
01:27:15,590 --> 01:27:15,980
是的。
Yeah.

1314
01:27:17,150 --> 01:27:19,640
是，因为中断必须等待，
Yeah, because the interrupt has to wait

1315
01:27:19,640 --> 01:27:22,880
没有什么事情可以调度了。
and then nothing else can get scheduled.

1316
01:27:22,880 --> 01:27:25,160
一些其他进程可能在运行，
Well, presumably some other process maybe running,

1317
01:27:25,160 --> 01:27:28,070
它不是，这不是死锁，
it's unlikely, there's no deadlock,

1318
01:27:28,100 --> 01:27:31,550
好的，有死锁的风险，但不是这个，
okay, there is a risk of deadlock, but not this one,

1319
01:27:31,760 --> 01:27:33,530
那个我们将在周三谈论。
that we'll talk about on Wednesday.

1320
01:27:34,670 --> 01:27:39,760
但是，它的大概意思是，
But in the, presumably, what this means

1321
01:27:39,760 --> 01:27:43,150
如果有多个调用 uartputc ，
like if there's multiple guys called uartputc,

1322
01:27:43,770 --> 01:27:44,820
缓冲区已满，
in the buffer full,

1323
01:27:45,180 --> 01:27:49,290
然后在某个时刻，这个中断会释放锁。
then some point, this interrupt they actually will release the lock.

1324
01:27:50,060 --> 01:27:53,330
让我们回到 uartputc ，
So, for example let's go back to uartputc,

1325
01:27:53,330 --> 01:27:55,280
实际上发生的事情是，
what actually what happened correct is that,

1326
01:27:55,670 --> 01:27:58,070
它们会调用 sleep ，
they will call sleep,

1327
01:27:58,760 --> 01:28:00,980
而 sleep 使用那个锁作为参数，
and sleep actually takes the locks in argument

1328
01:28:01,010 --> 01:28:02,330
我们后面会知道为什么，
and we'll see later why,

1329
01:28:02,540 --> 01:28:06,710
但是在内部，在 sleep 将进程睡眠之前，
but internally before sleep actually puts the process definitely to sleep

1330
01:28:06,710 --> 01:28:07,910
它会释放锁。
and will release the lock.

1331
01:28:08,920 --> 01:28:09,670
哦，我明白了，
Oh, I see,

1332
01:28:09,670 --> 01:28:11,830
所以是调用 sleep 带上锁参数，
so basically you call sleep with the lock

1333
01:28:11,830 --> 01:28:14,500
然后意味着可以在睡眠的时候释放锁，
and then that means okay release the lock while you sleep,

1334
01:28:14,500 --> 01:28:15,820
让其他进程去做。
so someone else does it.

1335
01:28:16,570 --> 01:28:18,010
好的，有意思。
Okay interesting.

1336
01:28:18,810 --> 01:28:19,080
是的。
Yeah.

1337
01:28:19,080 --> 01:28:20,820
然后，当从 sleep 返回，
And then when you return from sleep,

1338
01:28:20,820 --> 01:28:22,920
再次获取，好的。
you just reacquire, okay.

1339
01:28:23,160 --> 01:28:24,150
重新获得锁。
To get lock back.

1340
01:28:24,510 --> 01:28:27,630
对，是的，有道理。
Right, right, yeah that make sence.

1341
01:28:28,200 --> 01:28:29,640
sleep 也有单独的故事，
And the sleep has a seperate story,

1342
01:28:29,640 --> 01:28:31,170
我们将在一周或两周后讨论这个。
that we'll talk about in a week or two weeks.

1343
01:28:32,100 --> 01:28:33,240
有道理，是的，是的，
That makes sense, yeah yeah,

1344
01:28:33,270 --> 01:28:36,390
所以我想，
so I guess,

1345
01:28:37,540 --> 01:28:40,240
所以我想这对我来说不是很清楚，
so I guess that wasn't that clear to me

1346
01:28:40,240 --> 01:28:42,790
是不是所有的 CPU 都会被中断，
do all CPUs get interrupted,

1347
01:28:42,790 --> 01:28:45,220
当有人通过 UART 发送东西的时候。
when somebody like send something through uart.

1348
01:28:45,870 --> 01:28:47,910
不，要看情况，
No, well depends,

1349
01:28:47,970 --> 01:28:50,070
这取决于你怎么对 PLIC 编程，
it depends on how you program the plic,

1350
01:28:50,460 --> 01:28:55,020
xv6 对 PLIC 的编程方式是只有一个 CPU ，
the way xv6 program the plic is that only one CPU,

1351
01:28:55,230 --> 01:28:58,630
所有的 CPU 都可能被中断，但是。
all CPU might get interrupted, but.

1352
01:28:58,630 --> 01:28:59,020
好的。
Okay.

1353
01:28:59,050 --> 01:29:01,090
只有一个去处理中断。
One is going to clean the interrupt.

1354
01:29:03,230 --> 01:29:03,860
好的。
Okay.

1355
01:29:04,540 --> 01:29:05,770
如果你回到 PLIC ，
If you go back to the plic,

1356
01:29:05,770 --> 01:29:08,620
当你获得中断，会调用 plic_claim ，
you know when you get interrupted, you call this plic_claim

1357
01:29:08,650 --> 01:29:13,300
那个 CPU 会得到，
and that CPU that particular core gonna get the,

1358
01:29:13,820 --> 01:29:16,700
它会得到 IRQ ，
it's going to get the the IRQ

1359
01:29:17,030 --> 01:29:19,820
然后 PLIC 会记住，
and then basically the plic will remember,

1360
01:29:19,820 --> 01:29:21,260
那个 IRQ 正在处理，
that IRQ is now being served

1361
01:29:21,260 --> 01:29:22,670
不会把它给其他任何人。
and won't give it to anybody else.

1362
01:29:24,720 --> 01:29:25,560
我明白了，好的，
I see, okay,

1363
01:29:25,560 --> 01:29:29,400
所以，它们中的一个会获得它，随机的还是别的。
so just one of them will get it randomly or no.

1364
01:29:31,260 --> 01:29:32,790
你可以编程 PLIC ，
You can program to plic,

1365
01:29:32,790 --> 01:29:35,790
比如编程到一个 CPU 。
you know say maybe program to one CPU.

1366
01:29:35,790 --> 01:29:36,420
我明白了。
Oh I see.

1367
01:29:37,050 --> 01:29:37,290
PLIC。
Plic.

1368
01:29:37,290 --> 01:29:37,980
我明白了，
I see, I see,

1369
01:29:37,980 --> 01:29:40,950
所以在 PLIC 里面是相关的代码，
so inside the, yeah inside the plic is the code

1370
01:29:40,950 --> 01:29:43,410
来决定打扰谁。
that actually decides on who to bother.

1371
01:29:44,630 --> 01:29:45,620
是的， PLIC 是一个[]，
Yeah, the plic a [],

1372
01:29:45,800 --> 01:29:47,330
我想 PLIC 里面没有代码。
there's no code in the plic, I think.

1373
01:29:47,330 --> 01:29:50,210
是啊，好的。
Yeah right, okay, okay I was.

1374
01:29:50,660 --> 01:29:51,620
CPU 编程。
CPU program.

1375
01:29:51,890 --> 01:29:55,890
我是，是的，好的。
I was, yeah great, okay.

1376
01:29:57,360 --> 01:29:59,850
是的，我想说 PLIC 代码在哪里运行，
Yeah, I was just gonna say where does the plic code run,

1377
01:29:59,850 --> 01:30:01,440
但是，是的，它不是代码，而是硬件，
but yeah it's not code, it's hardware.

1378
01:30:01,440 --> 01:30:02,460
好的，理解了。
Okay that makes sense.

1379
01:30:02,940 --> 01:30:05,130
谢谢，星期三见。
Alright, thanks, I'll see you on Wednesday.

1380
01:30:06,290 --> 01:30:06,740
好的。
Yeah.

1381
01:30:07,440 --> 01:30:08,880
我有个问题，
So I got a question,

1382
01:30:08,910 --> 01:30:14,430
与同时运行多个核心的想法有关。
kind of related to the thinking about multiple cores running at the same time.

1383
01:30:15,050 --> 01:30:17,690
我想起其中一个实验，
So I think I recalling one of the labs

1384
01:30:17,690 --> 01:30:19,100
在 prime 问题中，
with say the prime question

1385
01:30:19,100 --> 01:30:22,970
我们看到实际上是交错输出，
we saw that print actually like interleaves output [],

1386
01:30:23,060 --> 01:30:27,800
是不是因为锁只是在 putc ，
is that because the locks are only around like the putc,

1387
01:30:28,850 --> 01:30:32,510
但是来自多个核心的 putc 调用可以交错，
but the putc calls from multiple cores could interleave,

1388
01:30:32,510 --> 01:30:36,200
意味着单个 print[] 不能保证是原子的。
meaning that a single print [] is not guaranteed to be atomic.

1389
01:30:36,200 --> 01:30:36,740
你是对的。
You got it.

1390
01:30:37,160 --> 01:30:38,510
好的，理解了。
Okay, that makes sense.

1391
01:30:39,480 --> 01:30:40,320
好的，谢谢。
Alright, thank you.

1392
01:30:40,560 --> 01:30:41,070
不用谢。
You're welcome.

1393
01:30:42,200 --> 01:30:43,160
我有一个简短的问题，
I have a quick question,

1394
01:30:43,820 --> 01:30:47,210
我记得阅读材料里有，
so I remember reading in the like,

1395
01:30:47,210 --> 01:30:51,050
阅读材料表示计时器中断是在机器模式下处理的，
the reading said something about the timer interrupts being handled in machine mode

1396
01:30:51,680 --> 01:30:55,400
我想知道是在哪里处理的，
and I was wondering where that was handled

1397
01:30:55,400 --> 01:30:56,990
当我们做 traps 实验时，
when we were doing the traps lab,

1398
01:30:57,880 --> 01:31:02,260
比如，在 traps 实验中，在哪里切换到机器模式，
like where the switch to machine mode was happening during the traps lab

1399
01:31:02,260 --> 01:31:04,330
然后我们在做什么。
and then what we were doing.

1400
01:31:04,880 --> 01:31:06,650
好的，好问题，
Yeah, okay great question,

1401
01:31:06,650 --> 01:31:09,020
你知道。
so you know the.

1402
01:31:09,870 --> 01:31:12,000
所以我调出代码，
So I I'm pulling up the code,

1403
01:31:12,270 --> 01:31:14,400
所以如果你查看 start ，
so if you look at your start correctly,

1404
01:31:14,400 --> 01:31:15,690
有一个 start 运行在 M 模式，
there's a start runs in M mode

1405
01:31:15,690 --> 01:31:17,790
当机器启动时的开始时间，
at the beginning of time when the machine boots,

1406
01:31:18,320 --> 01:31:21,350
并且它对计时器检查进行编程，
and it programs the timer check,

1407
01:31:22,140 --> 01:31:24,180
这是 timerinit
and so here's timerinit

1408
01:31:24,660 --> 01:31:29,460
而 timerinit 对 CLINT 进行编程，
and timerinit basically programs the plic the clint,

1409
01:31:29,490 --> 01:31:31,080
这是本地中断，
which is the local interrupt,

1410
01:31:31,080 --> 01:31:37,600
在时钟中断发生时生成中断，
to generate interrupts when the clock interrupt happens

1411
01:31:37,930 --> 01:31:45,310
这可能是这里最重要的函数，
and basically here's probably the most important function here,

1412
01:31:45,490 --> 01:31:50,320
它将机器模式的 trap 处理函数设置为这个 timervec 函数，这个名为timervec的函数，
it sets the machine mode trap handler to this function called timervec,

1413
01:31:50,440 --> 01:31:51,850
那是由汇编编写的。
that's written assembly.

1414
01:31:52,450 --> 01:31:55,120
当计时器中断发生时，
And when the timer interrupt happens,

1415
01:31:55,120 --> 01:31:56,470
这个函数会被调用。
that function is being called.

1416
01:31:57,210 --> 01:32:01,620
所以，当内核在用户模式或管理模式下运行时，
And so when your kernel running user mode or in supervisor mode

1417
01:32:01,950 --> 01:32:06,400
CLINT 生成一个中断到达这一行，
and clint generates an interrupt [reach] the line

1418
01:32:06,790 --> 01:32:10,480
它将切换到机器模式，
and it will switch to machine mode

1419
01:32:10,480 --> 01:32:11,920
并且调用这个函数 timervec ，
and call this function timervec,

1420
01:32:12,250 --> 01:32:18,160
基本上与管理模式和用户模式中看到的相同。
in same way basically as almost equivalent to what we've seen for supervisor mode and user mode.

1421
01:32:18,560 --> 01:32:19,010
好的？
Okay?

1422
01:32:19,160 --> 01:32:19,820
是的。
Sure.

1423
01:32:20,120 --> 01:32:24,710
然后，如果你看一下 kernelvec.S 。
And then if you look in kernelvec.S.

1424
01:32:25,360 --> 01:32:27,550
我们看了很多次 kernelvec ，
We looked at kernelvec a lot right,

1425
01:32:27,550 --> 01:32:28,300
我的意思是那个函数，
I mean that stuff function

1426
01:32:28,300 --> 01:32:29,530
看看它是否保存了很多东西。
to see if it stores a lot.

1427
01:32:29,800 --> 01:32:31,180
这是 timervec ，
And here's timervec,

1428
01:32:31,870 --> 01:32:34,270
它基本上是类似的想法，
it's basically the same sort of type of idea,

1429
01:32:34,390 --> 01:32:35,740
我们看看它是一些寄存器，
let's see it's a couple registers,

1430
01:32:35,740 --> 01:32:37,000
让它可以完成工作，
so that it can do its job

1431
01:32:37,390 --> 01:32:40,810
它做的就是在这里编写六行代码，
and the only job it does actually these sort of six lines of code here,

1432
01:32:41,360 --> 01:32:44,690
或者五行，七行代码，
or whatever five seven lines of code

1433
01:32:44,960 --> 01:32:48,140
它所做的就是对 CLINT 重新编程，
and basically what it does you know re-programs the clint

1434
01:32:48,140 --> 01:32:49,670
以生成未来的中断，
to generate future interrupts

1435
01:32:49,820 --> 01:32:54,140
然后向管理程序发出软件中断，
and then basically raises a software interrupt to the supervisor,

1436
01:32:54,540 --> 01:32:56,670
所以，它将进入管理者模式。
so that goes to supervisor mode.

1437
01:32:57,410 --> 01:32:57,860
好吧。
Okay.

1438
01:32:57,860 --> 01:33:01,250
然后，在 mret 的时候，
So then at the point at mret,

1439
01:33:01,790 --> 01:33:06,260
mret ，比如内核使用计时器中断，
mret, let's say the kernel was interrupted during a timer chip with a timer chip,

1440
01:33:06,260 --> 01:33:07,430
它进入机器模式，
so it went to machine mode,

1441
01:33:07,760 --> 01:33:11,210
然后 mret 从机器模式返回到管理者模式，
mret then returned from machine mode back to supervisor mode, right,

1442
01:33:11,960 --> 01:33:15,320
如果中断启用了管理者模式，
and if the interrupt enabled supervisor mode,

1443
01:33:15,350 --> 01:33:20,240
这个时刻，可能产生管理者软件中断。
at that point, maybe the supervisor, in the supervisor software interrupt will be generated.

1444
01:33:20,990 --> 01:33:22,070
哦，好的。
Oh, okay.

1445
01:33:22,160 --> 01:33:24,710
现在，内核也会做同样的事情，
And now basically the kernel will do the same thing,

1446
01:33:24,710 --> 01:33:26,540
转到 kernelvec ，
basically will go to kernelvec,

1447
01:33:26,780 --> 01:33:28,730
保存恢复所有寄存器，
you know save restore all the registers

1448
01:33:28,970 --> 01:33:33,440
然后转到内核 trap ，
and and then go to a kernel trap

1449
01:33:33,740 --> 01:33:36,560
内核 trap 会看到那是计时器中断。
and the kernel trap will see aha, that was the timer interrupt.

1450
01:33:37,360 --> 01:33:37,840
我明白了，
I see,

1451
01:33:38,020 --> 01:33:41,500
那么切换到机器模式是在哪一点，
and so what was the point of switching to machine mode in the first place

1452
01:33:41,530 --> 01:33:43,510
它到底做了什么。
at like what exactly does it do.

1453
01:33:44,440 --> 01:33:46,360
我不知道在哪一点，
I don't know what the point is,

1454
01:33:46,360 --> 01:33:48,280
这是硬件工作。
this is hardware works.

1455
01:33:48,670 --> 01:33:50,530
好的，知道了。
Okay, gotcha.

1456
01:33:50,980 --> 01:33:53,830
实际上做得更多一点，
Actually do a little bit more,

1457
01:33:53,830 --> 01:33:57,040
是的，这里有一些原因，
yeah yeah yeah, there are some reasons

1458
01:33:57,040 --> 01:34:01,000
我想为什么在机器模式使用计时器，
I think why use a timer chip exposed to machine mode,

1459
01:34:01,000 --> 01:34:03,040
但从我们的角度来看，
but from our perspective,

1460
01:34:03,480 --> 01:34:04,440
这很好，
you know would be great,

1461
01:34:04,440 --> 01:34:08,100
如果我们能把定时器中断交给管理者模式，
if we could have delegated the timer interrupt [] to supervisor mode

1462
01:34:08,100 --> 01:34:10,350
而不用处理定时器模式，
and never had to deal with timer mode,

1463
01:34:10,380 --> 01:34:14,310
但是，对这个特殊的芯片是不起作用的。
but you know that doesn't work for this particular chip.

1464
01:34:14,930 --> 01:34:17,000
好的，有道理，非常感谢。
Okay, that makes sense, thank you so much.

1465
01:34:17,300 --> 01:34:17,930
不用谢。
You're welcome.

1466
01:34:19,300 --> 01:34:23,140
哦，我有一个关于这部分的跟进问题。
Oh, I actually have a follow-up on this part of.

1467
01:34:23,710 --> 01:34:26,140
请继续你的问题。
So keep ask your questions.

1468
01:34:26,140 --> 01:34:28,330
好的。
Yeah.

1469
01:34:28,760 --> 01:34:35,180
我看到它分配了 32 个 uint64 ，
I saw that it allocates 32 uint64,

1470
01:34:35,180 --> 01:34:40,970
但是它似乎只用了四个或三个，
but it only seems to be using four, no three of them, right.

1471
01:34:41,000 --> 01:34:41,150
嗯。
Um.

1472
01:34:41,150 --> 01:34:44,330
在 start.c 中。
In start.c, it.

1473
01:34:44,940 --> 01:34:45,900
在 scratch ，
At scratch,

1474
01:34:45,900 --> 01:34:48,960
是的，我想它分配的比需要的多，
yeah I guess it allocates more than is necessary,

1475
01:34:48,960 --> 01:34:53,670
32 个暂存区域，
scratches thirty-two scratch area,

1476
01:34:53,700 --> 01:34:55,200
原因是，
the reason,

1477
01:34:55,200 --> 01:35:01,800
对于每一个 CPU ，
so, so for every CPU correct,

1478
01:35:01,920 --> 01:35:04,350
必须有一些暂存空间，
there has to be some scratch space

1479
01:35:04,380 --> 01:35:08,610
我想那里有三个或类似的 CPU ，
and there I guess we have three or something like that CPUs,

1480
01:35:08,610 --> 01:35:10,650
所以多分配一点，
so basically allocates a little bit too much,

1481
01:35:17,970 --> 01:35:21,120
但不会[]分配太多。
but there's no [] allocating too much.

1482
01:35:22,260 --> 01:35:27,300
好的，比如，它只用 scratch[0] scratch[1] scratch[1] ，
Okay, okay, it's like it only uses scratch zero scratch one scratch two.

1483
01:35:27,300 --> 01:35:30,300
不，我想是使用 3 ，
No, you know [uses] three, I guess,

1484
01:35:30,300 --> 01:35:32,760
从 0 到 3 ，是四个，
so as zero to three, that's four,

1485
01:35:32,970 --> 01:35:34,980
4 和 5 是六个，
four or five current six,

1486
01:35:35,360 --> 01:35:37,670
所以是六个整数，
so it's six integers

1487
01:35:38,030 --> 01:35:43,670
我想，我们可以运行四个 CPU ，
and I guess, we have we're running we could run with four CPUs,

1488
01:35:43,670 --> 01:35:44,690
但我们运行了三个，
but we're running with three,

1489
01:35:44,690 --> 01:35:45,920
但我们可以运行四个。
but we could run four.

1490
01:35:47,840 --> 01:35:49,340
所以 6 乘以 24 ，
So six times four twenty four,

1491
01:35:49,340 --> 01:35:52,730
我想肯定分配了太多内存。
I guess you know the, we definitely allocating too much memory.

1492
01:35:54,090 --> 01:35:56,160
我不记得，不久前我想过这件事，
I don't remember I thought about this a while back ago

1493
01:35:56,160 --> 01:36:04,220
我也记不清 32 是从哪里来的了。
and I don't remember exactly where 32 came from.

1494
01:36:05,290 --> 01:36:07,540
所以，我们需要再检查一遍。
So we need double check.

1495
01:36:08,660 --> 01:36:09,980
你可以重建它。
So you can reconstruct it.

1496
01:36:41,430 --> 01:36:48,360
哦，是的，保存恢复，都是 8 字节的。
Oh yeah, save restore, they all they all eight bytes, right.

1497
01:36:49,520 --> 01:36:50,270
是的。
Yeah.

1498
01:36:53,190 --> 01:36:55,140
还有，它。
And it.

1499
01:37:03,830 --> 01:37:05,750
好的，我晚点给你说，
Okay, let me get back to you,

1500
01:37:05,750 --> 01:37:08,000
我现在想不起来了，
I can't recall right at the top my head

1501
01:37:08,000 --> 01:37:09,380
为什么是这样的。
you know why it is the way it is.

1502
01:37:10,450 --> 01:37:13,900
好的，有道理，非常感谢。
Okay, makes sense, thank you so much.

1503
01:37:14,050 --> 01:37:15,220
不客气，问得好。
You're welcome, good questions.

1504
01:37:15,580 --> 01:37:16,750
谢谢。
Thank you.

