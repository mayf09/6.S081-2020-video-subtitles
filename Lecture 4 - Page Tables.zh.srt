1
00:00:00,000 --> 00:00:02,640
声音检查，大家能听到我说话吗？
Sound check, can everybody hear me?

2
00:00:04,700 --> 00:00:08,060
是的。好的，
Yep, yep. Okay okay,

3
00:00:08,060 --> 00:00:09,920
欢迎收听 6.S081
so welcome to the next lecture

4
00:00:09,920 --> 00:00:12,410
的下一节课，
in the 6.S081, wherever you

5
00:00:12,410 --> 00:00:14,380
无论你在哪里，
are, particular,

6
00:00:14,740 --> 00:00:15,640
我希望西海岸，
I hope that the folks on

7
00:00:15,640 --> 00:00:17,380
佛罗里达和
the west coast or in Florida

8
00:00:17,380 --> 00:00:19,450
阿拉巴马州的人们都还好，
and Alabama do OK, you know, all

9
00:00:19,450 --> 00:00:22,140
那里糟糕的情况会好起来。
the terrible circumstances there.

10
00:00:22,510 --> 00:00:24,880
嗯，那么，
Um, so,

11
00:00:24,880 --> 00:00:26,350
今天的话题是
um, the topic for today,

12
00:00:26,350 --> 00:00:29,110
虚拟内存，
is virtual memory, particularly we're

13
00:00:29,110 --> 00:00:30,580
特别是我们要讲的页表，
going to talk about page tables

14
00:00:30,580 --> 00:00:32,650
我们多次讲到
we'll return to this topic

15
00:00:32,650 --> 00:00:33,340
这个话题，
few times,

16
00:00:33,340 --> 00:00:34,390
有多次关于
there will be multiple

17
00:00:34,390 --> 00:00:35,380
这个的讲座。
[] lectures.

18
00:00:36,030 --> 00:00:37,920
一开始，
Maybe just start off and,

19
00:00:37,920 --> 00:00:39,690
我们会再次开始
you know, get our question and answer

20
00:00:39,690 --> 00:00:40,680
我们的问答环节，
going again,

21
00:00:42,120 --> 00:00:43,320
我想问
I would like to ask you

22
00:00:43,320 --> 00:00:43,830
一些问题，
a little bit,

23
00:00:43,830 --> 00:00:45,930
你对 6.004 或
what do you remember from，

24
00:00:45,930 --> 00:00:47,910
6.033 的讲的
about virtual memory from 6.004

25
00:00:47,910 --> 00:00:50,400
虚拟内存
maybe from 6.033,

26
00:00:50,400 --> 00:00:51,660
有什么印象。
if you're taking that.

27
00:00:52,500 --> 00:00:53,970
我要告诉你们，
I'll tell you, my own sort

28
00:00:53,970 --> 00:00:55,320
我自己对虚拟内存的看法，
of view on virtual memory,

29
00:00:55,320 --> 00:00:56,580
这就是当我
which is when I took it,

30
00:00:56,580 --> 00:00:57,780
第一次了解它的时候，
to first learned about it,

31
00:00:57,780 --> 00:00:58,500
还是个学生的时候，
learned about it as

32
00:00:58,500 --> 00:00:59,850
我认为
a student, I thought it

33
00:00:59,850 --> 00:01:01,110
它很简单，很直接，
was pretty straightforward,

34
00:01:01,110 --> 00:01:01,680
你知道的，
you know how hard could

35
00:01:01,680 --> 00:01:02,010
它能有多难，
it be,

36
00:01:02,010 --> 00:01:04,140
就是一个将虚拟地址
it's a table that maps virtual

37
00:01:04,140 --> 00:01:05,700
映射到物理地址的表。
addresses to physical addresses.

38
00:01:05,870 --> 00:01:07,190
你知道，
You know, maybe a

39
00:01:07,190 --> 00:01:08,120
可能有一点复杂，
little more complicated,

40
00:01:08,120 --> 00:01:09,680
但没有那么复杂。
but you know not that

41
00:01:09,680 --> 00:01:11,300
只有当你实际
complicated, only when you start

42
00:01:11,300 --> 00:01:12,540
用它来编程的时候，
programming with it.

43
00:01:12,600 --> 00:01:15,210
我真的知道了，
I should really learn, virtual

44
00:01:15,210 --> 00:01:18,380
虚拟内存是巧妙的，迷人的，
memory is tricky and fascinating,

45
00:01:18,540 --> 00:01:20,880
而且非常强大。
and very powerful.

46
00:01:21,380 --> 00:01:23,300
所以，
So, hopefully in the

47
00:01:23,300 --> 00:01:25,100
希望在接下来的几节课，
next couple of lectures, in

48
00:01:25,100 --> 00:01:26,060
接下来的几个实验中，
the next couple of labs,

49
00:01:26,060 --> 00:01:29,090
你们能从这个角度
you'll know appreciate

50
00:01:29,090 --> 00:01:30,820
理解虚拟内存。
virtual memory from that perspective.

51
00:01:31,060 --> 00:01:32,230
我们将提问
We will ask a couple

52
00:01:32,230 --> 00:01:34,000
在线的的几个人，
people here are online, you know

53
00:01:34,000 --> 00:01:36,010
关于你对
what do you remember about virtual

54
00:01:36,010 --> 00:01:38,860
6.004 或 6.033
memory from either 6.004 or

55
00:01:38,860 --> 00:01:40,120
虚拟内存的印象是什么。
6.033 taking it.

56
00:01:40,340 --> 00:01:41,510
我要叫几个名字，
Again, I'm just gonna call some

57
00:01:41,510 --> 00:01:43,080
你知道，
names and you know,

58
00:01:43,600 --> 00:01:47,080
分享你的印象。
share your memories. About the

59
00:01:47,080 --> 00:01:48,440
Adela Yang.
Adela Yang.

60
00:01:53,360 --> 00:01:55,160
抱歉，问题是什么？
Sorry, what's the question? What

61
00:01:55,160 --> 00:01:57,410
你对
do you remember about

62
00:01:57,410 --> 00:01:58,940
6.004 或
virtual memory from maybe 6.004

63
00:01:58,940 --> 00:02:00,470
6.033
or 6.033

64
00:02:00,470 --> 00:02:01,460
的虚拟内存有什么印象？
if you have taken that.

65
00:02:02,020 --> 00:02:05,440
它使用
It uses like, offset to save

66
00:02:05,440 --> 00:02:08,380
偏移量来记录
on like, remembering virtual address

67
00:02:08,380 --> 00:02:10,300
虚拟地址到物理地址的映射。
to physical address mappings.

68
00:02:11,640 --> 00:02:15,380
好的，下一个， Abrams Caldera 。
OK, how about Abrams Caldera.

69
00:02:20,100 --> 00:02:21,840
Abrams ，你在线吗？
Abrams, are you online?

70
00:02:23,230 --> 00:02:24,970
是的，我的印象是
Yeah, my memory is that

71
00:02:24,970 --> 00:02:26,640
它使用，
it uses like,

72
00:02:26,940 --> 00:02:29,040
就像通过
it's a way of one protecting

73
00:02:29,040 --> 00:02:30,960
一种[]表示
the physical hardware by

74
00:02:30,960 --> 00:02:33,540
来保护物理硬件，
kind of [] representation of

75
00:02:33,540 --> 00:02:35,310
然后，
it and then you just

76
00:02:35,310 --> 00:02:38,020
你使用一些
have some virtual address things like,

77
00:02:38,300 --> 00:02:41,750
至少 44 位的虚拟地址，
at least 44 bit, that map

78
00:02:41,750 --> 00:02:43,200
来映射一些物理地址，
some physical address,

79
00:02:43,530 --> 00:02:45,420
这些物理地址
that's usually I think 16

80
00:02:45,420 --> 00:02:47,620
通常是 64 位的。
bits were in fact.

81
00:02:48,090 --> 00:02:53,540
好的，下一个， Bibic Pendant 。
Okay, good, how about Bibic Pendant.

82
00:02:56,730 --> 00:02:58,080
我记得的是，
What I remember was,

83
00:02:58,080 --> 00:03:00,380
你可以让
um, you can have

84
00:03:00,840 --> 00:03:03,210
每个进程有一个
each process has a separate

85
00:03:03,210 --> 00:03:04,260
单独的地址空间。
address space.

86
00:03:04,620 --> 00:03:05,820
还有，
And,

87
00:03:06,210 --> 00:03:09,060
可以使用内存管理单元
the memory management unit or I

88
00:03:09,060 --> 00:03:10,470
或者一些其他技术
mean some other technique can be

89
00:03:10,470 --> 00:03:11,620
来映射，
used to map,

90
00:03:11,830 --> 00:03:13,960
将每个进程
the virtual addresses of the

91
00:03:13,960 --> 00:03:15,370
地址空间的
address space of each of the

92
00:03:15,370 --> 00:03:17,120
虚拟地址转换为
processes to the physical,

93
00:03:17,340 --> 00:03:19,420
物理地址。
physical address.

94
00:03:20,040 --> 00:03:23,910
还有，虚拟地址的
And the virtual address, the

95
00:03:23,910 --> 00:03:24,920
最后几位
lower bits

96
00:03:25,030 --> 00:03:25,930
是相同的，
are kind of the same,

97
00:03:25,930 --> 00:03:26,530
因此，
so that,

98
00:03:26,530 --> 00:03:29,640
映射是以块为单位的，
the the mapping is in blocks,

99
00:03:29,790 --> 00:03:32,100
这有助于提高性能。
which helps with performance.

100
00:03:33,970 --> 00:03:35,540
Wiseley Wu.
Wiseley Wu.

101
00:03:39,570 --> 00:03:42,630
是的，
Yeah, I guess what I

102
00:03:42,630 --> 00:03:44,850
我印象最深的是
remember most is that virtual address

103
00:03:44,850 --> 00:03:47,180
虚拟地址允许我们
allows us to,

104
00:03:47,750 --> 00:03:50,300
保护物理地址
yeah, protect physical addresses from

105
00:03:50,300 --> 00:03:51,580
不受每个进程的影响。
each process.

106
00:03:51,640 --> 00:03:54,070
我们可以使用
And we can use some clever

107
00:03:54,070 --> 00:03:56,080
一些巧妙的操作，
manipulation, so that the bits that

108
00:03:56,080 --> 00:03:57,730
这样对应于物理地址的位
correspond to the physical address can

109
00:03:57,730 --> 00:03:59,920
也可以
be used somehow in the virtual

110
00:03:59,920 --> 00:04:01,000
在虚拟地址中使用。
addresses as well.

111
00:04:02,600 --> 00:04:05,460
Wilson Spearmen.
Wilson Spearmen.

112
00:04:09,040 --> 00:04:10,840
是的，我记得
Yeah, I remember it's really fundamental

113
00:04:10,840 --> 00:04:11,950
这是隔离的基础，
to isolation,

114
00:04:11,950 --> 00:04:14,890
因为每个进程都
because every process can basically pretend

115
00:04:14,890 --> 00:04:16,620
可以假装
that it has its own

116
00:04:16,760 --> 00:04:19,180
它有自己的内存可以使用。
sort of memory to use.

117
00:04:20,470 --> 00:04:22,270
很好，很清楚，
Good good well so clearly,

118
00:04:22,270 --> 00:04:23,830
很棒，
that's awesome,

119
00:04:23,830 --> 00:04:26,080
显然，这里有两个主题，
the clear, two themes here

120
00:04:26,080 --> 00:04:28,210
一个是
correct, one is you know

121
00:04:28,210 --> 00:04:30,400
有某种形式的映射，
there's some form of mapping and

122
00:04:30,400 --> 00:04:31,900
这种映射有助于
the mapping is helpful in sort

123
00:04:31,900 --> 00:04:33,670
实现某种程度的隔离，
of achieving isolation,

124
00:04:33,670 --> 00:04:35,800
这正是我们讨论
this is exactly the reason, we're

125
00:04:35,800 --> 00:04:38,560
虚拟内存隔离的原因。
talking about virtual memory isolation.

126
00:04:38,870 --> 00:04:39,620
因此，
So, what

127
00:04:39,620 --> 00:04:41,570
我们在接下来的
we'll see is that in

128
00:04:41,570 --> 00:04:43,580
几节课中会看到，
the next, in the next couple of lectures,

129
00:04:43,580 --> 00:04:44,840
特别是，当我们开始
in particular, when we start programming

130
00:04:44,840 --> 00:04:45,950
使用虚拟内存编程时，
with virtual memory,

131
00:04:45,950 --> 00:04:48,680
我们会真正深入了解
really get an in-depth understanding

132
00:04:48,680 --> 00:04:50,360
它的力量。
of what its power is.

133
00:04:50,780 --> 00:04:52,250
为了让你理解，
And, so to get a

134
00:04:52,250 --> 00:04:53,570
你知道，
sense, that you know, this is

135
00:04:53,570 --> 00:04:55,310
这是第一节课，
the first lecture and mostly focusing

136
00:04:55,310 --> 00:04:59,390
内容主要集中在虚拟内存的机制上，
on the mechanisms for virtual memory,

137
00:04:59,390 --> 00:05:00,680
稍后我们可以看到，
and then later we can see

138
00:05:00,680 --> 00:05:02,030
如何使用这些机制来实现
how we can use these mechanisms

139
00:05:02,030 --> 00:05:03,760
那些很棒的技巧。
to achieve, you know, cool tricks.

140
00:05:04,660 --> 00:05:06,220
所以
So the topic for today, or

141
00:05:06,220 --> 00:05:08,740
今天的话题或议程是，
agenda for today, the plan

142
00:05:08,740 --> 00:05:10,460
计划分为三部分。
is sort of three part.

143
00:05:10,800 --> 00:05:12,210
首先，
First, I'm going to talk about the

144
00:05:12,210 --> 00:05:14,130
我要谈谈地址空间，
address spaces, as some of you

145
00:05:14,130 --> 00:05:16,020
你们中有些人也提到这个。
mentioning in your.

146
00:05:16,320 --> 00:05:17,420
这正是我们需要的。
Just what we need.

147
00:05:18,070 --> 00:05:19,840
刚才回答问题的时候
Just mentioned just briefly mentioned,

148
00:05:19,840 --> 00:05:22,420
简单提了一下，
in response to the question,

149
00:05:22,420 --> 00:05:23,980
我还要讲一下
I'm going to talk about the

150
00:05:23,980 --> 00:05:26,200
分页硬件。
paging hardware paging hardware.

151
00:05:27,020 --> 00:05:28,280
当然，
And I'm going to focus of

152
00:05:28,280 --> 00:05:29,600
我将重点介绍
course on the paging hardware of

153
00:05:29,600 --> 00:05:30,640
RISC-V 的分页硬件。
the RISC-V.

154
00:05:32,020 --> 00:05:36,400
但是基本上每个处理器，
But basically every processor, modern processor

155
00:05:36,400 --> 00:05:38,950
现代处理器都有
has some form of paging hardware

156
00:05:38,950 --> 00:05:40,200
某种形式的分页硬件。
sort of,

157
00:05:40,230 --> 00:05:41,640
实际上它是
if you will, the

158
00:05:41,640 --> 00:05:44,310
支持虚拟内存的
default mechanism for actually

159
00:05:44,310 --> 00:05:45,820
默认机制。
supporting virtual memory.

160
00:05:46,250 --> 00:05:47,000
然后，
And then,

161
00:05:47,000 --> 00:05:48,260
课程的最后一部分
the last part of

162
00:05:48,260 --> 00:05:49,610
将介绍一些
the lecture is going to

163
00:05:49,610 --> 00:05:52,100
xv6 的
walk through some xv6

164
00:05:52,100 --> 00:05:54,240
虚拟内存代码。
virtual memory code.

165
00:05:54,280 --> 00:06:00,770
还有，内核地址空间和
And, layout of kernel address space and

166
00:06:00,770 --> 00:06:02,000
用户地址空间的布局。
user address spaces.

167
00:06:02,730 --> 00:06:04,580
所以这是主要的计划。
So that's the main plan.

168
00:06:08,250 --> 00:06:09,660
好的，那么
Okay, so,

169
00:06:09,660 --> 00:06:11,160
如果我们回答，
if we answers, you know, []

170
00:06:11,160 --> 00:06:12,120
你所提到的[]，
you mentioned,

171
00:06:12,120 --> 00:06:14,370
回答这个问题，
in response to this question,

172
00:06:14,370 --> 00:06:15,280
你知道，
you know,

173
00:06:15,370 --> 00:06:18,430
有虚拟内存的一个驱动力
one driving reason to have

174
00:06:18,430 --> 00:06:20,020
是因为
virtual memory is because you can

175
00:06:20,020 --> 00:06:22,000
你可以用它来实现隔离，
use it to achieve isolation,

176
00:06:22,000 --> 00:06:22,840
如果页表设置正确，
if you set up the page

177
00:06:22,840 --> 00:06:25,540
并且编程正确，
tables correctly and program them correctly,

178
00:06:25,540 --> 00:06:26,710
那么原则上
then you can in principle

179
00:06:26,710 --> 00:06:28,540
就可以实现强隔离。
achieve strong isolation.

180
00:06:29,020 --> 00:06:30,910
这再次提醒我们，
And so this is to remind us again,

181
00:06:30,910 --> 00:06:31,960
我们想从隔离中
you know what we want with

182
00:06:31,960 --> 00:06:33,100
得到什么，
from isolation,

183
00:06:33,100 --> 00:06:34,540
比如，
let's say, you know a

184
00:06:34,540 --> 00:06:35,380
你知道一张标准图片，
standard picture,

185
00:06:35,380 --> 00:06:36,820
我们有一些用户应用程序，
we have some user applications

186
00:06:36,820 --> 00:06:37,920
比如 shell ，
like shell,

187
00:06:37,950 --> 00:06:40,080
cat ，还有
you know cat, you know, all the util

188
00:06:40,080 --> 00:06:41,970
你在实验一中构建的
things, that you've built in

189
00:06:41,970 --> 00:06:44,520
所有实用工具，
lab one, and we have

190
00:06:44,630 --> 00:06:48,440
我们还有内核，内核在下面，
the kernel, the kernel sitting below,

191
00:06:48,440 --> 00:06:49,790
操作系统在
the operating system sitting in

192
00:06:49,790 --> 00:06:50,860
内核空间里。
kernel space.

193
00:06:51,320 --> 00:06:52,730
你知道，
And you know what we like

194
00:06:52,730 --> 00:06:55,100
我们要做的是
to do is sort of have

195
00:06:55,100 --> 00:06:57,880
把这些应用程序框起来，
you know boxes around these

196
00:06:58,240 --> 00:07:00,850
这样它们
applications, so that they can't

197
00:07:00,850 --> 00:07:03,100
就不会真正相互影响，
really affect each other and similar

198
00:07:03,100 --> 00:07:06,010
类似的，我们希望它们
we want them to be completely

199
00:07:06,010 --> 00:07:07,930
完全独立于内核和操作系统，
independent of the kernel,

200
00:07:07,930 --> 00:07:09,310
这样即使
the operating system, so that if

201
00:07:09,310 --> 00:07:11,620
一个应用程序做了
an application does something either accidentally

202
00:07:11,620 --> 00:07:13,600
一些意外或恶意的事情，
bad or maliciously bad,

203
00:07:13,600 --> 00:07:14,950
也不会
that doesn't really affect the

204
00:07:14,950 --> 00:07:15,900
真正影响操作系统。
operating system.

205
00:07:16,580 --> 00:07:19,010
这就是我们的目标，
So that's our goal and the

206
00:07:19,010 --> 00:07:21,380
今天我们关注的
particular aspect of the problem that

207
00:07:21,380 --> 00:07:23,360
具体方面是
we want to focus on today

208
00:07:23,360 --> 00:07:25,220
内存方面的问题，
is the memory side of things,

209
00:07:25,220 --> 00:07:26,390
所以我们关注的是
so we really want to

210
00:07:26,390 --> 00:07:28,120
内存隔离。
focus on memory isolation.

211
00:07:29,920 --> 00:07:31,900
默认情况下，
And by default,

212
00:07:31,900 --> 00:07:33,430
如果我们什么都不做，
if we don't do anything,

213
00:07:33,430 --> 00:07:35,470
我们就没有内存隔离，
we don't really have memory isolation,

214
00:07:35,470 --> 00:07:37,180
因为如果你想一下，
because if you think about

215
00:07:37,180 --> 00:07:38,890
这有一个 RISC-V 板，
it, there's going to be one

216
00:07:38,890 --> 00:07:40,480
就是我上周给你们
RISC-V board that I showed

217
00:07:40,480 --> 00:07:41,140
展示的那个，
you last week,

218
00:07:41,140 --> 00:07:42,730
它有一个内存，
it has a memory,

219
00:07:42,730 --> 00:07:44,220
一堆 DRAM 芯片，
a bunch of DRAM chips,

220
00:07:44,630 --> 00:07:46,490
在 DRAM 芯片中
and the in the DRAM

221
00:07:46,490 --> 00:07:48,200
存储着
chips, the code for

222
00:07:48,200 --> 00:07:49,460
这些应用程序的代码，
these applications

223
00:07:49,460 --> 00:07:53,060
内存中的
is stored, somewhere in memory

224
00:07:53,060 --> 00:07:55,820
某个地方是内核，文本数据堆栈或其他，
is the kernel, text data stack

225
00:07:55,820 --> 00:07:58,280
如果 shell 正在运行，
everything, somewhere in memory used to

226
00:07:58,280 --> 00:07:59,740
内存中的某个地方是 shell ，
shell if the shell is running,

227
00:07:59,980 --> 00:08:02,680
还有某个地方是 cat 程序。
somewhere in memory the cat program.

228
00:08:04,640 --> 00:08:06,410
只有一个物理内存，
So, there's one physical memory,

229
00:08:06,410 --> 00:08:09,170
从 0 开始，
you know starting from zero to

230
00:08:09,170 --> 00:08:11,420
到一个大地址，
big, big address,

231
00:08:11,420 --> 00:08:12,500
它取决于机器
depending how much memory we

232
00:08:12,500 --> 00:08:13,430
有多少内存，
have, really have in our

233
00:08:13,430 --> 00:08:15,020
在这个物理内存中，
machine and in that physical

234
00:08:15,020 --> 00:08:17,140
所有这些程序都必须存在。
memory all these programs must be present.

235
00:08:17,230 --> 00:08:19,330
否则，你知道，
Otherwise, you know, the processor

236
00:08:19,330 --> 00:08:21,340
处理器甚至不能执行它们的指令。
can't even execute their instructions.

237
00:08:22,420 --> 00:08:23,470
这就是风险所在，
This is what the risk, you

238
00:08:23,470 --> 00:08:25,300
在这里很明显，
know clearly here is, that let's

239
00:08:25,300 --> 00:08:27,310
比如，举个简单的例子，
say, let's make a little bit

240
00:08:27,310 --> 00:08:29,950
比如 shell ，
simplistic, let's say the shell,

241
00:08:29,950 --> 00:08:31,300
位于地址 0 到 200 ，
you know sits for

242
00:08:31,300 --> 00:08:33,620
应该是 2000 ，
address 0 to address 200,

243
00:08:34,830 --> 00:08:36,920
1000 到 2000 。
two thousand, 1000 to 2000.

244
00:08:37,720 --> 00:08:39,220
假设，
And let's say you know,

245
00:08:39,220 --> 00:08:40,810
cat 有一个
you know whatever cat has a

246
00:08:40,810 --> 00:08:41,890
编程错误，
programming error,

247
00:08:41,890 --> 00:08:47,060
它加载某个东西到寄存器 a0 中。
it loads, you know, in register a0.

248
00:08:47,770 --> 00:08:49,720
假设，加载的是 1000 ，
Let's say, loads the 1000

249
00:08:49,720 --> 00:08:52,030
地址对应于
address basically corresponding to the

250
00:08:52,030 --> 00:08:54,010
shell 的起始地址，
start of the shell and then

251
00:08:54,010 --> 00:08:55,060
然后意外地
you know by accident,

252
00:08:55,060 --> 00:08:57,580
执行了 sd $7, (a0) 指令。
executes the instruction 'sd $7, (a0)'.

253
00:09:03,010 --> 00:09:04,210
这条指令的作用是，
Which has the effect of that,

254
00:09:04,210 --> 00:09:05,980
将值 7 写到
basically it writes the value 7

255
00:09:05,980 --> 00:09:08,230
地址 1000 ，
to the address 1000 and so

256
00:09:08,230 --> 00:09:10,240
所以
it would be scribbling over, you

257
00:09:10,240 --> 00:09:12,550
它会修改
know the basically the memory image,

258
00:09:12,550 --> 00:09:14,220
属于 shell 的内存镜像。
that belongs to shell.

259
00:09:14,860 --> 00:09:15,130
因此，
And so,

260
00:09:15,130 --> 00:09:17,590
我们肯定不会，
we're certainly not, certain

261
00:09:17,590 --> 00:09:20,380
这肯定会打破隔离，
would break isolation, and be

262
00:09:20,380 --> 00:09:21,780
是我们不想要的。
quite undesirable.

263
00:09:22,400 --> 00:09:24,350
所以我们想要，
And so we want something that

264
00:09:24,350 --> 00:09:26,510
从根本上把不同程序的
basically really separates these memories from

265
00:09:26,510 --> 00:09:27,860
内存隔离起来，
the different programs from each other,

266
00:09:27,860 --> 00:09:30,080
让这样的事情不会发生。
so that things like that just cannot happen.

267
00:09:31,590 --> 00:09:33,450
要做到这一点，
So one way, to do that,

268
00:09:33,450 --> 00:09:36,120
有一种方法是，
is an idea that's you

269
00:09:36,120 --> 00:09:38,120
叫做地址空间的方法。
know typically called address spaces.

270
00:09:44,500 --> 00:09:47,920
基本思路很简单，
And the basic idea is straightforward,

271
00:09:47,920 --> 00:09:49,300
我们想要做的基本上
what we wanna do, is basically

272
00:09:49,300 --> 00:09:52,580
是给包括内核在内的每个应用程序，
give every application including the kernel,

273
00:09:52,670 --> 00:09:54,060
它自己的地址空间。
its own address space.

274
00:09:55,080 --> 00:09:56,310
所以我们像下面这样思考，
And so we can think about

275
00:09:56,310 --> 00:09:58,260
我们运行 cat ，
this like, we use cat running,

276
00:09:58,780 --> 00:09:59,800
它有一个从 0 开始
you know, it has an address

277
00:09:59,800 --> 00:10:01,870
到最大值的
space starting at 0, you know

278
00:10:01,870 --> 00:10:04,390
地址空间，
to whatever maximum value, you know

279
00:10:04,390 --> 00:10:06,430
shell 也运行在一个地址空间，
shell run has an address space, its

280
00:10:06,430 --> 00:10:07,330
它自己的地址空间，
own address space,

281
00:10:07,330 --> 00:10:09,130
也从地址 0 开始
also starting at address 0,

282
00:10:09,130 --> 00:10:11,530
到某个地址，
going to some value,

283
00:10:11,530 --> 00:10:12,490
内核也有
you know the kernel has

284
00:10:12,490 --> 00:10:13,780
它自己的地址空间。
its own address space.

285
00:10:14,660 --> 00:10:15,680
也就是操作系统
OS has its own

286
00:10:15,680 --> 00:10:16,680
有自己的地址空间。
address space.

287
00:10:17,640 --> 00:10:18,750
所以，
And so,

288
00:10:18,750 --> 00:10:20,340
让我们回到
one example when cat you know

289
00:10:20,340 --> 00:10:21,900
刚才使用 cat 的例子，
refers to, we go back to

290
00:10:21,900 --> 00:10:23,880
像上一张讲稿中
our example of the previous slide

291
00:10:23,880 --> 00:10:25,320
做的那样，
where we did,

292
00:10:25,470 --> 00:10:30,580
对于指令 'st 7, (a0)' ,
whatever 'st 7, (a0)',

293
00:10:30,930 --> 00:10:34,740
假设 a0 中的值是 1000 。
and let's say in a0, there's value 1000.

294
00:10:34,840 --> 00:10:36,400
你知道如果 cat
You know if cat execute

295
00:10:36,400 --> 00:10:37,540
执行这条指令，
the instruction,

296
00:10:37,540 --> 00:10:39,130
它会写地址 1000 ，
it will write to the address 1000,

297
00:10:40,420 --> 00:10:42,970
但这是它自己的地址 1000 ，
but it is its own address 1000,

298
00:10:42,970 --> 00:10:43,690
而不是，
it's not,

299
00:10:43,690 --> 00:10:46,360
shell 的地址 1000 。
the address of the 1000 of the shell.

300
00:10:46,390 --> 00:10:48,760
所以基本上，每个程序
So basically, every program runs with

301
00:10:48,760 --> 00:10:50,320
都有自己的地址空间，
its own address space, has its

302
00:10:50,320 --> 00:10:52,870
有自己的值，
own value and those addresses are

303
00:10:52,870 --> 00:10:54,160
并且这些地址是完全独立的。
completely independent.

304
00:10:54,380 --> 00:10:56,120
你知道，这个
You know this notion of

305
00:10:56,120 --> 00:10:57,590
不同地址空间的概念，
different address spaces,

306
00:10:57,590 --> 00:10:59,540
cat 甚至不能
cat doesn't really have an ability to

307
00:10:59,540 --> 00:11:01,940
访问实际上
even refer to an address, that

308
00:11:01,940 --> 00:11:03,680
属于 shell 的地址。
actually belongs to the shell.

309
00:11:04,900 --> 00:11:07,240
所以这就是
And so that sort of the

310
00:11:07,240 --> 00:11:09,160
我们想要达到
game that were the end goal

311
00:11:09,160 --> 00:11:10,630
的最终目标，
that we'd like to achieve, because

312
00:11:10,630 --> 00:11:11,530
因为它提供了强隔离，
it's going to provide us with

313
00:11:11,530 --> 00:11:13,690
因为你知道，
strong isolation, because you know it's

314
00:11:13,690 --> 00:11:15,010
cat 不可能
just not possible for cat to

315
00:11:15,010 --> 00:11:16,480
引用任何
refer to any other memory that

316
00:11:16,480 --> 00:11:18,100
不属于它的内存。
is not, you know, its own.

317
00:11:19,080 --> 00:11:20,790
因此，我们现在的目标
And so, our goal now basically

318
00:11:20,790 --> 00:11:22,980
是解决如何
sort of figure out how to

319
00:11:22,980 --> 00:11:25,200
在单个物理内存上
multiplex if you will all these

320
00:11:25,200 --> 00:11:28,260
复用这些
different address bases on a single

321
00:11:28,260 --> 00:11:29,190
不同的地址，
physical memory,

322
00:11:29,190 --> 00:11:29,970
因为根本上，
because in the end,

323
00:11:29,970 --> 00:11:32,140
我们只有一堆 DRAM 芯片。
we only have a bunch of DRAM chips.

324
00:11:32,240 --> 00:11:33,800
你知道，
were you know, ram

325
00:11:33,800 --> 00:11:35,720
RAM 芯片是内存使用的。
chips were the memories locate.

326
00:11:36,950 --> 00:11:42,010
所以，我的计划是。
And so, um, and so I sort of plan.

327
00:11:42,010 --> 00:11:43,150
好的，Amiar ，
Okay, yeah, Amiar,

328
00:11:43,150 --> 00:11:44,240
你有什么问题，说吧。
you have a question, go ahead.

329
00:11:46,240 --> 00:11:47,380
我想知道，
So I'm wondering,

330
00:11:47,380 --> 00:11:50,500
在物理硬件的
in the configuration of the

331
00:11:50,500 --> 00:11:52,030
配置中，
physical hardware,

332
00:11:52,030 --> 00:11:54,550
只有这么大的空间，
there's only so much space and

333
00:11:54,550 --> 00:11:56,590
而在虚拟内存布局中，
the virtual memory layout,

334
00:11:56,590 --> 00:11:59,230
也有一个最大地址，
there's also a max virtual address,

335
00:11:59,230 --> 00:12:02,230
从设计上来说，虚拟地址对于物理地址
by design is the virtual address

336
00:12:02,230 --> 00:12:04,180
是否要足够小。
made to be small enough.

337
00:12:04,500 --> 00:12:06,930
不，不需要，
No, not necessarily,

338
00:12:06,930 --> 00:12:08,100
虚拟地址空间
you know the virtual address

339
00:12:08,100 --> 00:12:09,240
可能比
space could be bigger than

340
00:12:09,240 --> 00:12:09,990
物理内存大，
the physical memory,

341
00:12:09,990 --> 00:12:11,160
物理内存也可能比
the physical memory could be bigger

342
00:12:11,160 --> 00:12:13,170
虚拟地址空间大，
than the virtual address space

343
00:12:13,170 --> 00:12:13,950
我们很快就会看到
and we'll see in a second

344
00:12:13,950 --> 00:12:15,240
这一切是如何发生的，
how it all can happen and

345
00:12:15,240 --> 00:12:17,040
它实际上会[]，
it's actually going to []

346
00:12:17,040 --> 00:12:19,560
就像我们将在页表中看到的那样，
about, as we'll see with page tables,

347
00:12:19,560 --> 00:12:21,420
这是非常灵活的。
that's extremely flexible.

348
00:12:22,120 --> 00:12:23,470
那么，
So, is it, is it

349
00:12:23,470 --> 00:12:25,690
有没有可能，
possible that like the physical

350
00:12:25,690 --> 00:12:27,940
就像物理内存耗尽一样，
memory gets exhausted,

351
00:12:28,250 --> 00:12:30,500
因为这么多进程
because so many processes use

352
00:12:30,500 --> 00:12:31,940
使用了自己的虚拟空间。
all their virtual space.

353
00:12:31,940 --> 00:12:34,790
是的，这当然是可能的，
Yeah, that's certainly possible and we'll

354
00:12:34,790 --> 00:12:35,780
我们很快会看到，
see in the second, how,

355
00:12:35,780 --> 00:12:36,980
例如，你知道，
for example you know you have

356
00:12:36,980 --> 00:12:38,750
有一堆大型应用程序，
a bunch of big applications that

357
00:12:38,750 --> 00:12:40,340
每个应用程序都有很大的页表，
each have big page tables,

358
00:12:40,340 --> 00:12:41,510
它们分配了很多内存，
they allocate a lot of memory,

359
00:12:41,510 --> 00:12:42,350
有些时候
you know some point you run

360
00:12:42,350 --> 00:12:43,260
内存就会用完。
out of memory.

361
00:12:43,810 --> 00:12:44,320
我明白了，
I see,

362
00:12:44,320 --> 00:12:46,840
谢谢。那么，有没有人知道
thanks. And so where does this

363
00:12:46,840 --> 00:12:49,060
这在 xv6 中哪里用到了？
show up xv6, anybody.

364
00:12:52,530 --> 00:12:54,100
你肯定
You, you sure,

365
00:12:54,430 --> 00:12:55,720
在目前做的
touched on a little bit

366
00:12:55,720 --> 00:12:57,550
syscall 实验中
in the syscall lab, that

367
00:12:57,550 --> 00:12:58,660
用到了一点，
you're currently doing,

368
00:13:01,330 --> 00:13:02,920
分配页面的位置。
where page is allocated.

369
00:13:08,670 --> 00:13:10,650
或者，你做的 syscall 实验，
Or, you do the syscall lab,

370
00:13:10,650 --> 00:13:11,940
在 syscall 实验的一部分
you finished it in one

371
00:13:11,940 --> 00:13:13,380
完成了它，
part of the syscall lab,

372
00:13:13,380 --> 00:13:15,400
打印有多少空闲内存地址。
printing how much free memory address.

373
00:13:17,730 --> 00:13:20,220
Kalloc ？是的，kalloc ，
Kalloc? Yeah, kalloc, right,

374
00:13:20,220 --> 00:13:22,340
kalloc ，有空闲页的列表，
for kalloc, have a list of free pages,

375
00:13:22,420 --> 00:13:23,740
如果这个列表
if that list of free pages

376
00:13:23,740 --> 00:13:26,160
在某一时刻为空或用完。
is empty or runs out at some point.

377
00:13:26,150 --> 00:13:27,590
然后， kalloc 将返回
Then, you know, kalloc is going

378
00:13:27,590 --> 00:13:29,750
一个空指针，
to return a null pointer, and

379
00:13:29,750 --> 00:13:31,880
希望操作系统能做一些明智的事情，
hopefully the operation system does something sensible,

380
00:13:31,880 --> 00:13:33,380
把消息传回给用户应用程序，
that basically propagated back to the

381
00:13:33,380 --> 00:13:35,150
告诉应用程序，
user application saying like well, you

382
00:13:35,150 --> 00:13:36,530
没有更多的内存给你，
know no more memory for you

383
00:13:36,530 --> 00:13:38,960
或者任何人都没有更多的内存。
or no more memory in total, nobody.

384
00:13:43,120 --> 00:13:44,350
好的？操作系统只需要做一项工作
Ok? Then just a job for OS

385
00:13:44,350 --> 00:13:46,480
就可以很好地处理这些情况，
to handle those cases gracefully where

386
00:13:46,480 --> 00:13:48,700
将错误消息
basically generally means propagating an error

387
00:13:48,700 --> 00:13:50,320
传回到用户应用程序。
message to user application.

388
00:13:57,280 --> 00:13:58,940
好的，很好。
Okay, good.

389
00:13:59,410 --> 00:14:00,820
那么如何实现
So how do you implement these

390
00:14:00,820 --> 00:14:01,780
这些地址空间，
address spaces,

391
00:14:01,780 --> 00:14:03,640
如何在单个物理内存中
you know how basically multiplex

392
00:14:03,640 --> 00:14:05,050
复用所有
all these address spaces across a

393
00:14:05,050 --> 00:14:08,440
这些地址空间，
single physical memory and the most

394
00:14:08,440 --> 00:14:10,480
最常用的并且非常灵活的方法
common approach and a very flexible

395
00:14:10,480 --> 00:14:12,840
就是使用页表。
approach is to use pagetables.

396
00:14:17,360 --> 00:14:18,830
这个想法是，
The idea is,

397
00:14:18,830 --> 00:14:21,080
这是一项艰苦的工作支持，
this is a hard work support,

398
00:14:21,080 --> 00:14:23,540
这是由处理器
so this is implemented in hardware

399
00:14:23,540 --> 00:14:25,910
在硬件中实现的，或者
by the processor or by a

400
00:14:25,910 --> 00:14:28,040
称为内存管理单元（MMU），
unit called the memory management unit,

401
00:14:28,040 --> 00:14:29,390
所以你应该想到的画面是，
so the picture that you should

402
00:14:29,390 --> 00:14:32,360
你知道，
have your head is, you know, the CPU

403
00:14:32,730 --> 00:14:35,940
执行指令的 CPU ，
that executes instructions, whatever are,

404
00:14:35,940 --> 00:14:40,440
无论是什么指令，
you know, are store instruction that

405
00:14:40,440 --> 00:14:47,180
比如存储指令， sd $7, (a0) ，
was you know 'sd $7, (a0)',

406
00:14:47,560 --> 00:14:48,790
也执行这些类型的指令，
also executes those kind of

407
00:14:48,790 --> 00:14:51,010
你知道
instructions and you know when

408
00:14:51,010 --> 00:14:51,970
当它执行 store 指令，
it executes one of their

409
00:14:51,970 --> 00:14:53,380
load 指令，
store instruction, load instruction,

410
00:14:53,380 --> 00:14:54,850
无论任何指令实际上
whatever anything that actually has

411
00:14:54,850 --> 00:14:55,780
都包含一个地址。
an address.

412
00:14:55,810 --> 00:14:57,610
那个地址，
You know, that address we're going

413
00:14:57,610 --> 00:14:58,270
我们要把它
to think about it as

414
00:14:58,270 --> 00:14:59,230
当成一个虚拟地址，
a virtual address,

415
00:14:59,230 --> 00:15:00,370
它不是一个物理地址，
so it's not a physical address,

416
00:15:00,370 --> 00:15:01,560
而是一个虚拟地址。
it's a virtual address.

417
00:15:02,100 --> 00:15:02,400
例如，
And so,

418
00:15:02,400 --> 00:15:03,630
我们在这里使用的
for example the value in a0

419
00:15:03,630 --> 00:15:05,250
a0 中的值，
that we're using here,

420
00:15:05,250 --> 00:15:08,400
假设它是 1000 ，
yeah, say that's 1000,

421
00:15:08,760 --> 00:15:11,160
这个 0x1000 是一个虚拟地址，
0x1000 data is a

422
00:15:11,160 --> 00:15:13,170
虚拟地址基本上
virtual address and virtual addresses basically

423
00:15:13,170 --> 00:15:15,840
是通过所谓的
routed through something what's called

424
00:15:15,840 --> 00:15:17,860
内存管理单元路由的，
the memory management unit,

425
00:15:21,180 --> 00:15:23,580
并且内存管理单元将其
and the memory manager unit

426
00:15:23,580 --> 00:15:26,380
转换成物理地址。
translates into a physical address.

427
00:15:27,680 --> 00:15:29,990
然后这个物理地址
And that physical address then was

428
00:15:29,990 --> 00:15:32,920
实际上指向内存。
actually used to index into memory.

429
00:15:33,120 --> 00:15:35,550
加载值或
And load whatever value or

430
00:15:35,550 --> 00:15:37,940
存储需要写入的任何值。
store whatever value needs to be written there.

431
00:15:38,720 --> 00:15:40,460
所以从 CPU 的
And so the CPU from

432
00:15:40,460 --> 00:15:41,630
角度来看，
the CPU point of view,

433
00:15:41,630 --> 00:15:42,710
它总是发出，
it always issues,

434
00:15:42,710 --> 00:15:44,720
一旦 MMU 启用，
every instruction that issues,

435
00:15:44,720 --> 00:15:46,940
它发出的每条指令
once the MMU use, enabled

436
00:15:46,940 --> 00:15:48,320
都使用了虚拟地址。
our virtual addresses.

437
00:15:49,100 --> 00:15:51,080
为了将这些虚拟地址
And to translate these virtual addresses

438
00:15:51,080 --> 00:15:52,850
转换成物理地址，基本上，
to physical addresses, basically,

439
00:15:52,850 --> 00:15:54,200
MMU 有一个表。
MMU has a table.

440
00:15:55,080 --> 00:15:57,090
这个表中，
And you know virtual address

441
00:15:57,090 --> 00:15:58,260
虚拟地址在一边，
on one side, physical address

442
00:15:58,260 --> 00:15:59,340
物理地址在另一边，
on one side,

443
00:15:59,340 --> 00:16:01,650
例如，
the other side, for example here is

444
00:16:01,650 --> 00:16:05,040
这里是我们的 1000 的条目，
our entry for 1000 and maybe

445
00:16:05,040 --> 00:16:07,340
可能映射到任何，
that maps to whatever,

446
00:16:07,860 --> 00:16:09,930
你知道， 0x （开头的）
you know, 0x whatever you're

447
00:16:09,930 --> 00:16:11,280
无论什么东西，
making something up with like

448
00:16:11,280 --> 00:16:12,600
比如某个值，
something value,

449
00:16:13,020 --> 00:16:14,490
在物理内存中的某个地方。
somewhere in physical memory.

450
00:16:14,490 --> 00:16:16,200
所以这个在虚拟和物理之间的映射，
So this mapping between virtual and

451
00:16:16,200 --> 00:16:19,260
它相当灵活。
physical, it's quite flexible.

452
00:16:19,880 --> 00:16:20,900
因此，
And so on one side,

453
00:16:20,900 --> 00:16:21,830
在一侧是虚拟地址，
we have the virtual address

454
00:16:21,830 --> 00:16:22,460
在另一侧的是
of the other side of

455
00:16:22,460 --> 00:16:23,580
物理地址。
the physical addresses.

456
00:16:26,030 --> 00:16:28,580
通常，这个映射
Typically, you know this mapping itself

457
00:16:28,580 --> 00:16:29,900
也存储在内存中。
is also stored in memory.

458
00:16:30,160 --> 00:16:31,660
所以 CPU 有一些
And so the CPU has some

459
00:16:31,660 --> 00:16:35,020
寄存器，
register that basically points to,

460
00:16:35,090 --> 00:16:37,190
寄存器包含
that contains the physical

461
00:16:37,190 --> 00:16:40,480
存储页表的物理地址，
address of where the page table is stored

462
00:16:40,670 --> 00:16:42,650
在这里，
somewhere, in basically the page

463
00:16:42,650 --> 00:16:44,450
页表或映射
table or just map somewhere stored

464
00:16:44,450 --> 00:16:45,620
存储在物理内存中。
in physical memory.

465
00:16:45,770 --> 00:16:47,120
比方说，你知道，
Let's say, you know,

466
00:16:47,120 --> 00:16:49,620
地址 10 ，
whatever, address 10,

467
00:16:49,860 --> 00:16:51,810
在 RISC-V 上
basically this register which is

468
00:16:51,810 --> 00:16:54,560
这个寄存器是 satp 。
called on the RISC-V satp.

469
00:16:54,740 --> 00:16:57,770
你知道存储着地址 10 ，
You know stores the address 10

470
00:16:57,770 --> 00:17:00,320
因此， CPU 可以
and so, that the CPU

471
00:17:00,320 --> 00:17:01,940
告诉内存管理单元
can tell the memory manager units

472
00:17:01,940 --> 00:17:05,210
在哪里查找映射，
where to find, you know, basically the map

473
00:17:05,210 --> 00:17:07,640
这个映射将虚拟地址
to actually translate virtual to

474
00:17:07,640 --> 00:17:08,700
转换为物理地址。
physical addresses.

475
00:17:10,020 --> 00:17:11,250
然后，基本的想法
And then the basic idea

476
00:17:11,250 --> 00:17:12,900
是给每个应用程序
is to give every application

477
00:17:12,900 --> 00:17:13,860
提供它自己的映射。
it's own map.

478
00:17:14,320 --> 00:17:17,740
所以 cat 有它的映射。
So cat is going to have it's map.

479
00:17:19,110 --> 00:17:20,360
所以每一个映射，有它自己的……。
So every map, it's own...

480
00:17:23,360 --> 00:17:27,400
是的，[Big Ben]，继续。
Yeah, [Big Ben], go ahead.

481
00:17:29,420 --> 00:17:31,790
那么 MMU ，
So the MMU,

482
00:17:31,790 --> 00:17:35,120
你说它不需要
you said it doesn't necessarily store

483
00:17:35,120 --> 00:17:36,140
存储映射。
the mapping.

484
00:17:36,190 --> 00:17:38,590
所以它只是，
So does it just,

485
00:17:38,590 --> 00:17:40,480
只是做转换，
just do the translation like

486
00:17:40,480 --> 00:17:42,190
就像它会读取内存
it will read the memory

487
00:17:42,190 --> 00:17:43,480
并进行转换，
and do the translation,

488
00:17:43,480 --> 00:17:45,040
但不需要
but not necessarily

489
00:17:45,160 --> 00:17:46,870
存储映射。
store the mappings.

490
00:17:46,870 --> 00:17:48,670
这正是你头脑中
That's exactly the right picture that

491
00:17:48,670 --> 00:17:49,800
应该有的的图像。
you should have your head.

492
00:17:52,960 --> 00:17:55,510
但是每个映射，
But every map, okay, so the

493
00:17:55,510 --> 00:17:57,040
所以映射存储在内存中，
map itself stored memory,

494
00:17:57,040 --> 00:17:58,900
MMU 只是
the MMU just basically walks or

495
00:17:58,900 --> 00:18:00,310
访问或查看映射，
looks into the map and we'll

496
00:18:00,310 --> 00:18:01,330
我们很快就会看到，
see in a second, you know,

497
00:18:01,330 --> 00:18:02,770
映射比我在这里画的
the map is slightly more complicated

498
00:18:02,770 --> 00:18:04,160
稍微复杂一些。
than I just draw here.

499
00:18:05,340 --> 00:18:07,080
所以每个应用
So every app has

500
00:18:07,080 --> 00:18:10,740
都有自己的映射。
its own, its own map.

501
00:18:12,320 --> 00:18:14,450
这个映射定义了
Right, and that map basically defines

502
00:18:14,450 --> 00:18:15,720
它的地址空间。
its address space.

503
00:18:16,380 --> 00:18:18,270
因此，当使用 CPU 或
And so when with the CPU or

504
00:18:18,270 --> 00:18:19,860
当操作系统将 CPU
when the operating system switches the

505
00:18:19,860 --> 00:18:21,870
从一个应用程序切换到
CPU from one process from one

506
00:18:21,870 --> 00:18:23,610
另一个应用程序时，
application to another application,

507
00:18:23,610 --> 00:18:25,380
它还切换该 satp 寄存器
it also switches the content

508
00:18:25,380 --> 00:18:29,310
的内容
of this satp register to store

509
00:18:29,310 --> 00:18:31,410
以存储对应进程的
the root of the map of

510
00:18:31,410 --> 00:18:32,740
映射的根地址。
the appropriate process.

511
00:18:33,400 --> 00:18:34,660
因此，通过这种方式，
And so in that way,

512
00:18:34,660 --> 00:18:36,580
你知道在 CPU 上
basically you know multiple applications to

513
00:18:36,580 --> 00:18:37,420
运行多个应用程序，
run on the

514
00:18:37,420 --> 00:18:38,770
每次我们
CPU, every time we switch

515
00:18:38,770 --> 00:18:40,030
从一个应用程序切换到
between from one application to the

516
00:18:40,030 --> 00:18:41,080
下一个应用程序时，
next application,

517
00:18:41,080 --> 00:18:43,900
我们还会切换 satp 寄存器
we also switch the satp

518
00:18:43,900 --> 00:18:45,820
以指向该应用程序
register to point to the appropriate

519
00:18:45,820 --> 00:18:47,160
对应的映射。
map for that application.

520
00:18:47,420 --> 00:18:48,170
通过这种方式，
And in that way,

521
00:18:48,170 --> 00:18:51,290
cat 虚拟地址
basically, virtual addresses you know

522
00:18:51,290 --> 00:18:54,590
与 shell 虚拟地址
for cat are translated differently,

523
00:18:54,590 --> 00:18:56,960
的转换不同，
than the virtual addresses for the

524
00:18:56,960 --> 00:18:58,280
因为每个应用程序
shell, because you know each one

525
00:18:58,280 --> 00:18:59,800
都有自己的映射。
of them has their own map.

526
00:19:02,380 --> 00:19:03,240
理解了吗？
That makes sense?

527
00:19:07,710 --> 00:19:10,170
好的，
Okay, so we, this is the

528
00:19:10,170 --> 00:19:12,060
这是基本的计划，
basic plan and the way I've

529
00:19:12,060 --> 00:19:14,340
到目前为止，我画的或者将要解释的方式，
drawn or gonna explain it so

530
00:19:14,340 --> 00:19:16,050
是相当幼稚的，
far it's pretty naive,

531
00:19:16,050 --> 00:19:17,980
也是不合理的。
and unreasonable.

532
00:19:18,230 --> 00:19:19,880
是的，大卫，说吧。
Yeah, David, go ahead.

533
00:19:20,820 --> 00:19:21,450
很抱歉，
I'm sorry,

534
00:19:22,880 --> 00:19:25,610
你说的 satp 寄存器
so, the you said the

535
00:19:25,610 --> 00:19:28,070
因为进程修改了，
satp register gets modified

536
00:19:28,070 --> 00:19:30,110
我想
for the process, I am guessing

537
00:19:30,110 --> 00:19:32,270
每个进程的
the value of for

538
00:19:32,270 --> 00:19:34,680
satp 寄存器的值
satp register for each process

539
00:19:34,730 --> 00:19:36,500
都是由内核存储的。
is stored by the kernel.

540
00:19:36,500 --> 00:19:37,550
是的，
Yes yes,

541
00:19:37,550 --> 00:19:39,230
内核写入 satp 寄存器，
the kernel is writing satp register,

542
00:19:39,230 --> 00:19:41,510
实际上写入或读取，
in fact writing or reading,

543
00:19:41,510 --> 00:19:44,030
特别是写入 satp 寄存器
particular writing the satp register is

544
00:19:44,030 --> 00:19:45,300
是特权指令。
a privilege instruction.

545
00:19:45,830 --> 00:19:48,290
因此，用户应用程序不能
So user application cannot just

546
00:19:48,290 --> 00:19:50,060
更新页面映射寄存器，
update the page map register, and

547
00:19:50,060 --> 00:19:50,990
然后说我现在要
say like I want to run

548
00:19:50,990 --> 00:19:52,320
使用此页面映射运行。
with this page map now.

549
00:19:52,460 --> 00:19:55,800
因为，那会违反隔离性。
Because, that would violate isolation.

550
00:19:56,070 --> 00:19:57,690
所以它只有内核，
So it's only the kernel, only

551
00:19:57,690 --> 00:19:58,980
只有内核模式下的代码
code in kernel mode can actually

552
00:19:58,980 --> 00:19:59,780
才能真正更新它。
update it.

553
00:20:01,100 --> 00:20:02,000
我明白了。
I see.

554
00:20:03,730 --> 00:20:05,110
好的，正如我所说的，
Okay, so as I said this

555
00:20:05,110 --> 00:20:06,190
这张图片相当幼稚，
picture is pretty naive,

556
00:20:06,190 --> 00:20:07,420
你知道，有一件事
you know one thing I

557
00:20:07,420 --> 00:20:08,860
我没有真正说过
haven't really said anything about how

558
00:20:08,860 --> 00:20:10,440
这个映射是如何工作的。
this actually map works.

559
00:20:10,750 --> 00:20:13,420
而且，我画的方式
And, you know the way I've

560
00:20:13,420 --> 00:20:15,250
似乎表明，
drawn out seems to indicate a

561
00:20:15,250 --> 00:20:17,350
每个虚拟地址，
basically for every virtual address,

562
00:20:17,350 --> 00:20:18,720
在映射上都有一个条目。
you have an entry in the map.

563
00:20:19,440 --> 00:20:21,450
如果你这么做了，
And if you do that,

564
00:20:21,450 --> 00:20:26,540
那么在 RISC-V 上，映射会有多大呢？
how big would that be on RISC-V.

565
00:20:36,150 --> 00:20:37,470
有人回答吗， RISC-V 理论上
Anybody, how many addresses are there on

566
00:20:37,470 --> 00:20:38,910
有多少地址，
the RISC-V in principle, or

567
00:20:38,910 --> 00:20:40,650
或者有多大，
how big, how many addresses go

568
00:20:40,650 --> 00:20:41,860
寄存器可以存储多少地址。
to registers store.

569
00:20:46,100 --> 00:20:48,560
寄存器是 64 位宽，
Registers are 64 bit wide,

570
00:20:48,560 --> 00:20:49,900
那么有多少个地址呢？
so how many addresses.

571
00:20:53,830 --> 00:20:55,240
有人吗？我知道，
Anybody, I know, so insulting your

572
00:20:55,240 --> 00:20:57,320
问这些问题是对你智力的侮辱。
intelligence by asking these questions about.

573
00:21:00,110 --> 00:21:00,980
我们在聊天中有一些答案，
We have some answers in the

574
00:21:00,980 --> 00:21:02,600
是 2 的 64 次方。
chat, like two to the 64.

575
00:21:02,600 --> 00:21:04,610
我没看到聊天内容，抱歉，
I didn't see the chat, sorry,

576
00:21:04,610 --> 00:21:06,050
是的，2 的 64 次方。
yeah, two to 64. Lets see

577
00:21:06,050 --> 00:21:07,970
让我们看看是否能把芯片拿出来，
if I can actually pop off the chip,

578
00:21:07,970 --> 00:21:08,980
这样我就能看到它了。
so I could see it.

579
00:21:13,460 --> 00:21:15,180
是的， 2 的 64 次方，谢谢。
Yeah, two to 64, thank you.

580
00:21:16,990 --> 00:21:20,280
好的，那么这张表会很大。
Alright, so this table would be gigantic.

581
00:21:20,420 --> 00:21:22,130
事实上，我们知道
In fact, we know

582
00:21:22,130 --> 00:21:23,540
只有这张表就会
all memory would be consumed

583
00:21:23,540 --> 00:21:24,590
消耗掉所有的内存，
by just having the table

584
00:21:24,590 --> 00:21:26,000
所以这是不合理的。
so that seems unreasonable.

585
00:21:26,360 --> 00:21:27,590
所以事实上，
And so in fact you

586
00:21:27,590 --> 00:21:29,160
事情不是这样的。
know that's not how things work.

587
00:21:29,520 --> 00:21:30,510
实际上，
In fact, going to

588
00:21:30,510 --> 00:21:32,250
在 RISC-V 中，
in two steps, to actually, how

589
00:21:32,250 --> 00:21:33,820
它的工作分为两个步骤。
it actually works in RISC-V.

590
00:21:33,920 --> 00:21:36,800
第一步是
Step one is don't play

591
00:21:36,800 --> 00:21:40,040
不按地址，
the game per address,

592
00:21:40,040 --> 00:21:41,720
而是按页面操作。
but do per page.

593
00:21:44,580 --> 00:21:45,900
所以一次
So you translate a page at

594
00:21:45,900 --> 00:21:47,880
转换一页， RISC-V 上的
a time and a page

595
00:21:47,880 --> 00:21:50,380
一页是 4 千字节。
on RISC-V is 4 kilobytes.

596
00:21:51,860 --> 00:21:54,700
它是 4096 字节。
Which is a four, 4096 bytes.

597
00:21:55,080 --> 00:21:56,430
这很常见，
This is pretty common,

598
00:21:56,430 --> 00:21:58,830
几乎所有处理器
almost all processors, you know, use

599
00:21:58,830 --> 00:22:01,320
都使用大约 4 千字节的页面大小，
roughly page size 4 kilobytes, or support

600
00:22:01,320 --> 00:22:02,780
或者支持 4 千字节的页面大小。
page size 4 kilobytes.

601
00:22:03,420 --> 00:22:05,070
所以现在，
And so now again, translation works

602
00:22:05,070 --> 00:22:06,000
转换的工作略有不同，
slightly differently,

603
00:22:06,000 --> 00:22:08,300
在这里，我们有虚拟地址。
so if here, we have our virtual address.

604
00:22:09,360 --> 00:22:11,340
惊讶的是，我们将其一分为二，
Amazingly, we split it in two pieces,

605
00:22:11,340 --> 00:22:14,580
一个索引和一个偏移量。
an index and an offset.

606
00:22:15,300 --> 00:22:16,620
偏移量就是
And so the offset is basically

607
00:22:16,620 --> 00:22:18,240
在页面中的字节。
the byte within the page.

608
00:22:18,880 --> 00:22:20,170
因此，当我们，
And so when we do,

609
00:22:20,170 --> 00:22:21,610
当 MMU 进行转换时，
when the MMU does

610
00:22:21,610 --> 00:22:23,820
它会获取索引，
the translation it takes the index,

611
00:22:23,970 --> 00:22:27,240
索引到映射中，
indexes into the map that

612
00:22:27,240 --> 00:22:29,100
给出一些在内存中
gives you some physical page number,

613
00:22:29,100 --> 00:22:31,280
的物理页号。
you know in memory.

614
00:22:31,480 --> 00:22:33,520
物理页号指向
The physical page number that

615
00:22:33,520 --> 00:22:37,460
4096 字节的某个物理页。
points to some physical page of 4096 bytes.

616
00:22:38,040 --> 00:22:39,870
然后是偏移量部分，
And then the offset part,

617
00:22:39,870 --> 00:22:42,810
索引到该物理页面中，
basically indexes into that physical page,

618
00:22:42,810 --> 00:22:45,400
例如，如果偏移量是 12 ，
so, for example, the offset is, you know, 12.

619
00:22:45,770 --> 00:22:48,100
那么你就知道
then you know there are

620
00:22:48,690 --> 00:22:51,120
它使用的是
the 12th entry of that

621
00:22:51,120 --> 00:22:53,680
那一页的第 12 个条目。
page is actually used.

622
00:22:54,110 --> 00:22:55,490
很多人，
A lot of people a lot

623
00:22:55,490 --> 00:22:57,590
很多人，你们中的很多人，
of you entered in the message

624
00:22:57,590 --> 00:23:00,300
在回答这个问题时，
in the, in response to the question,

625
00:23:00,300 --> 00:23:02,340
总是有一些方案，
there's always some scheme of taking

626
00:23:02,340 --> 00:23:04,770
取一个偏移量，
an offset and adding that to

627
00:23:04,770 --> 00:23:09,340
然后把它加到页面的底部，以获得实际的内存，
the base of the page to obtain the actual

628
00:23:09,500 --> 00:23:11,690
物理内存位置，
memory, physical memory location, where

629
00:23:11,690 --> 00:23:15,480
值存储或加载到那里。
a value store, where value will be loaded too.

630
00:23:16,400 --> 00:23:17,510
关于 RISC-V 的
And one of the interesting things

631
00:23:17,510 --> 00:23:19,010
一个有趣的事情是，
about the RISC-V is and

632
00:23:19,010 --> 00:23:20,690
这是再次对
this is in response to some

633
00:23:20,690 --> 00:23:21,320
一些问题的回答，
questions again,

634
00:23:21,320 --> 00:23:23,900
有人问到物理地址
somebody asked look the physical

635
00:23:24,110 --> 00:23:26,760
或虚拟地址都是 64 位。
or virtual addresses are 64 bits.

636
00:23:28,250 --> 00:23:29,630
这完全正确，
Which makes totally sense correct,

637
00:23:29,630 --> 00:23:31,520
因为 RISC-V 是
because the RISC-V is

638
00:23:31,520 --> 00:23:32,560
64 位寄存器。
64-bit register.

639
00:23:33,210 --> 00:23:35,280
但实际上
But in fact on the

640
00:23:35,280 --> 00:23:38,190
在我们使用的
RISC-V processor, that we're using,

641
00:23:38,190 --> 00:23:39,780
RISC-V 处理器上，
not all of the 64 bits

642
00:23:39,780 --> 00:23:40,800
并不是使用了所有 64 位，
actually used,

643
00:23:41,160 --> 00:23:43,890
也就是说，前 25 位
namely, the top 25 are

644
00:23:43,890 --> 00:23:45,220
实际上根本没有使用。
actually not used at all.

645
00:23:45,800 --> 00:23:47,630
这限制了
So that limits the

646
00:23:47,630 --> 00:23:49,520
虚拟地址的大小，
size of a virtual address, that

647
00:23:49,520 --> 00:23:50,900
这将虚拟地址空间的大小
limits the size of a virtual

648
00:23:50,900 --> 00:23:53,360
限制为 2 的 39 次方，
address space 2 to the power of 39,

649
00:23:54,980 --> 00:23:58,740
大约是 512 吉字节。
which is roughly 512 gigabytes.

650
00:24:04,210 --> 00:24:06,310
当然，你知道
So, of course you

651
00:24:06,310 --> 00:24:08,560
更高版本的处理器
know later version of the

652
00:24:08,560 --> 00:24:10,360
可能支持更大的地址空间，
processor, might support bigger address spaces

653
00:24:10,360 --> 00:24:12,400
这是必要的，
and that is necessary and could then

654
00:24:14,080 --> 00:24:15,850
可以完成，例如，
be done, for example, some of those 25 bits

655
00:24:15,850 --> 00:24:18,310
这 25 位没有使用，
that are basically unused, could be used to

656
00:24:18,310 --> 00:24:21,640
可以用来构建更大的虚拟地址空间。
build bigger virtual address spaces.

657
00:24:22,390 --> 00:24:24,400
在索引中，
So, and so in the index

658
00:24:24,400 --> 00:24:26,440
你知道，剩下的 39 位
and, you know, where 39 bits left,

659
00:24:26,440 --> 00:24:27,820
作为虚拟地址，
you know as the virtual address

660
00:24:27,820 --> 00:24:29,830
其中 27 位是索引，
27, 27 bits are

661
00:24:29,830 --> 00:24:31,030
我们一会儿就会看到，
index and we'll see you in

662
00:24:31,030 --> 00:24:33,100
为什么
a second, why they are 27

663
00:24:33,480 --> 00:24:35,100
27 位是索引，
are index and then

664
00:24:35,100 --> 00:24:37,580
其他 12 位是偏移量。
the 12 are offset.

665
00:24:38,280 --> 00:24:39,480
你知道，
And you know there has to

666
00:24:39,480 --> 00:24:40,890
偏移量必须是 12 ，
be 12, because 2 to the

667
00:24:40,890 --> 00:24:43,880
因为 2 的 12 次方是 4096 。
power 12 is 4096.

668
00:24:46,590 --> 00:24:48,360
所以这是 RISC-V 的虚拟地址。
So that's virtual addresses on the

669
00:24:48,360 --> 00:24:50,520
而物理地址
RISC-V. Physical addresses as you

670
00:24:50,520 --> 00:24:52,350
正如你在看到的，
can see here are actually 56

671
00:24:52,350 --> 00:24:53,240
实际上是 56 位宽。
bits wide.

672
00:24:57,940 --> 00:24:59,140
所以物理内存，
So the physical memory,

673
00:24:59,140 --> 00:25:01,570
可以大于
can be bigger than the

674
00:25:01,570 --> 00:25:03,220
单个虚拟地址空间。
single virtual address space.

675
00:25:03,880 --> 00:25:05,950
但它被限制在 2 的 56 次方，
But it's limited to 2 power to 56,

676
00:25:05,950 --> 00:25:07,870
你知道，大多数主板可能
you know most boards probably, you know,

677
00:25:07,870 --> 00:25:09,190
不支持 2 的 56 次方内存，
don't support 2 to the power

678
00:25:09,190 --> 00:25:11,710
因为这是一个
of 56 physical memory, because

679
00:25:11,710 --> 00:25:14,060
很大的物理内存。
a gigantic amount of physical memory.

680
00:25:14,090 --> 00:25:15,290
但原则上这块板可以，
But in principle the

681
00:25:15,290 --> 00:25:16,610
你知道，
board could, you know,

682
00:25:16,610 --> 00:25:18,500
如果你能制造出
if you could manufacture it

683
00:25:18,500 --> 00:25:19,760
2 的 56 次方的内存，
support two to the power

684
00:25:19,760 --> 00:25:21,200
它也能支持。
of 56 physical memory.

685
00:25:22,020 --> 00:25:23,130
因此，在该方案中，
And so in this scheme,

686
00:25:23,130 --> 00:25:25,620
物理地址 56 位中，
then 56 bit for

687
00:25:25,620 --> 00:25:27,330
44 位是物理页号，
the physical address, 44 are basically

688
00:25:27,330 --> 00:25:28,440
即 PPM ，
the physical page number,

689
00:25:28,440 --> 00:25:30,720
12 位是
the PPM, and 12 are the

690
00:25:30,720 --> 00:25:32,610
直接从虚拟地址
offset that are inherited directly from

691
00:25:32,610 --> 00:25:34,660
继承的偏移量。
the virtual address.

692
00:25:36,840 --> 00:25:37,940
这能理解吗？
Does that make sense.

693
00:25:40,560 --> 00:25:42,630
所以，在这里停一下。
So, um, you know stop for a second

694
00:25:42,630 --> 00:25:44,310
你可以整理一下思绪，
here. So you collect your thoughts,

695
00:25:44,310 --> 00:25:45,390
我想在这里指出的是，
the only point I wanted to

696
00:25:45,390 --> 00:25:49,410
这个材料很重要，
make here is that this material is important,

697
00:25:49,410 --> 00:25:51,000
所以可以问问题，
so just ask questions,

698
00:25:51,000 --> 00:25:52,740
细节很重要，
the details matter,

699
00:25:52,740 --> 00:25:54,480
它将是
and it will be a large

700
00:25:54,480 --> 00:25:55,560
一大部分，
part of you,

701
00:25:55,560 --> 00:25:56,760
你真的需要理解
you really need to understand all

702
00:25:56,760 --> 00:25:57,240
所有这些东西，
this stuff,

703
00:25:57,240 --> 00:25:58,980
才能做下一个实验，
to be able to basically

704
00:25:58,980 --> 00:26:01,740
页表实验。
do lab, the next lab, the page table lab.

705
00:26:02,570 --> 00:26:03,770
是的， Amiar ，说吧。
Yeah, Amiar, go ahead, please.

706
00:26:05,200 --> 00:26:06,220
你能退一张幻灯片吗，
If you can go back

707
00:26:06,220 --> 00:26:09,080
我的屏幕不清楚。
one slide, I have the screen is unclear.

708
00:26:10,740 --> 00:26:11,280
哪一页，
Which one,

709
00:26:11,280 --> 00:26:13,860
页表这张吗？是的。
the page table slide? Yeah.

710
00:26:20,260 --> 00:26:22,200
这张吗？嗯，不是。
This one? Um, no.

711
00:26:22,680 --> 00:26:24,210
最新的那一张，
The most recent one, but it

712
00:26:24,210 --> 00:26:25,320
但也不要紧，
also doesn't really matter,

713
00:26:25,320 --> 00:26:26,790
是的，就是这张，
yeah, this is perfect,

714
00:26:26,790 --> 00:26:29,070
谢谢你，所以我想知道的是
thank you, so I'm wondering this

715
00:26:29,070 --> 00:26:33,330
这个叫做页的 4096 字节的范围，
4096 byte range which we've called

716
00:26:33,330 --> 00:26:35,430
是作为内存中的
a page, is that assigned as

717
00:26:35,430 --> 00:26:37,950
连续区块分配的吗？
a continuous chunk in memory.

718
00:26:37,950 --> 00:26:40,200
是的，这是
Yes, that's a continuous physical,

719
00:26:40,200 --> 00:26:44,190
物理内存中
continuous range of 4096 bytes

720
00:26:44,190 --> 00:26:45,340
连续的的 4096 字节。
including memory.

721
00:26:46,510 --> 00:26:49,630
我明白了，然后。你知道，
I see, and then. You know, the map,

722
00:26:49,630 --> 00:26:53,440
映射是以 4096 字节作为粒度。
granularity of 4096 bytes.

723
00:26:53,440 --> 00:26:55,390
好的，然后是偏移量 12 ，
Okay, and then 12, the

724
00:26:55,390 --> 00:26:58,630
2 的 12 次方是 4096 ，
offset, like 2 to the 12 is 4096,

725
00:26:58,630 --> 00:27:00,760
那么这足以
so that's sufficient to cover each

726
00:27:00,760 --> 00:27:03,880
覆盖每一块？是的，页面中的每个字节。
of the chunks? Yeah, each byte in the page.

727
00:27:04,770 --> 00:27:07,020
在这个图表中，
And where does the 56 come

728
00:27:07,020 --> 00:27:09,120
数字 56 是从哪里来的，
from, in the diagram, I could

729
00:27:09,120 --> 00:27:10,680
这之前我一直可以理解，
follow up until then,

730
00:27:10,680 --> 00:27:11,640
但我不知道
but I didn't get where

731
00:27:11,640 --> 00:27:13,530
它是从哪里来的。
that came from.

732
00:27:13,530 --> 00:27:14,840
这是设计师们决定的的。
The designers cook it up.

733
00:27:15,180 --> 00:27:16,800
硬件设计师决定
So the hardware designers decide

734
00:27:16,800 --> 00:27:17,940
物理地址有多大，
how big you know physical

735
00:27:17,940 --> 00:27:20,250
对于他们想要
addresses, basically for whatever board

736
00:27:20,250 --> 00:27:22,620
设计的任何电路板，
they want to design,

737
00:27:22,620 --> 00:27:24,270
所以 RISC-V 设计师
and so the RISC-V

738
00:27:24,270 --> 00:27:26,850
决定使用 56 ，
designers who decided at 56,

739
00:27:26,850 --> 00:27:28,050
觉得选择这个物理地址
that physical addresses were a

740
00:27:28,050 --> 00:27:28,920
是一个好主意。
good idea.

741
00:27:30,560 --> 00:27:32,240
通常，他们得出
And usually the way they

742
00:27:32,240 --> 00:27:33,530
这些数字的方式
come up with these numbers is

743
00:27:33,530 --> 00:27:35,260
是看技术趋势。
they look at technology trends.

744
00:27:35,500 --> 00:27:36,970
然后说，我们
And say like, well, we want

745
00:27:36,970 --> 00:27:37,990
希望电路板
to be able for the next

746
00:27:37,990 --> 00:27:38,980
在接下来的 5 年里适用，
sort of 5 years,

747
00:27:38,980 --> 00:27:40,870
你知道，他们预测
you know, we don't predict the physical

748
00:27:40,870 --> 00:27:42,340
物理内存不会
memory will be ever bigger than

749
00:27:42,340 --> 00:27:43,840
大于 2 的 56 次方。
2 to the power 56.

750
00:27:44,740 --> 00:27:45,940
也许他们认为它
Probably they think it won't be

751
00:27:45,940 --> 00:27:47,590
不会比小于 2^56 的东西更大，
bigger than something much smaller,

752
00:27:47,590 --> 00:27:48,910
但你知道，
but then you know give them

753
00:27:48,910 --> 00:27:50,650
留一些余量，
sort of leeway, you know,

754
00:27:50,650 --> 00:27:52,720
为了防止他们的预测是错误的，
in case you know their predictions wrong,

755
00:27:52,720 --> 00:27:55,220
他们会选择一个稍微大一点的数字。
they pick a slightly bigger number.

756
00:27:56,720 --> 00:27:58,060
这个能理解吗？
Is that makes sense.

757
00:27:58,640 --> 00:28:00,440
好的，谢谢。是的，很多人
Yeah, thanks. Yeah, a lot of people

758
00:28:00,440 --> 00:28:01,790
问起这个。
ask about this.

759
00:28:03,870 --> 00:28:05,340
还有其他人吗，谁举手了，
Anybody else, who raised a hand,

760
00:28:05,340 --> 00:28:06,210
我想
I think there's a bunch of

761
00:28:06,210 --> 00:28:08,610
有很多人在提问，
people asking questions and unfortunately my

762
00:28:08,610 --> 00:28:10,200
不过，我的 zoom
zoom doesn't show its more than

763
00:28:10,200 --> 00:28:12,000
在有多个人举手的时候，
two people raised hands just multiple

764
00:28:12,000 --> 00:28:13,260
不会显示超过两个人。
people are raising their hands.

765
00:28:13,720 --> 00:28:15,190
所以如果你有问题，
So you please jump in, if

766
00:28:15,190 --> 00:28:16,040
请直接说吧。
you have a question.

767
00:28:20,160 --> 00:28:23,730
好的。我有一个问题，
Okay. I have a question,

768
00:28:23,730 --> 00:28:27,150
是的，说吧。如果虚拟内存
yeah, go ahead. So if the virtual

769
00:28:27,150 --> 00:28:30,060
是 2 的 27 次方，
memory is up to 2 to the power of 27

770
00:28:30,060 --> 00:28:31,290
而物理内存
and the physical memory is

771
00:28:31,290 --> 00:28:34,710
是 2 的 56 次方，
up 2 to the power of 56, right,

772
00:28:34,710 --> 00:28:37,340
那么，我们可以
so, we could have,

773
00:28:38,550 --> 00:28:41,070
有多个进程，
like we could have multiple processes

774
00:28:41,070 --> 00:28:42,630
这些进程可以耗尽
that could exhaust all their virtual

775
00:28:42,630 --> 00:28:43,920
所有的虚拟内存，
memories without

776
00:28:44,100 --> 00:28:46,140
而不会用完所有的物理内存，
using up all the physical memory,

777
00:28:46,140 --> 00:28:47,820
对吗？是的，没错。
right? That's correct.

778
00:28:52,250 --> 00:28:53,280
这是完全正确的。
That's absolutely correct.

779
00:28:54,040 --> 00:28:56,170
好的。我也有个问题。
Okay. I have a question, too.

780
00:28:56,170 --> 00:28:58,060
好的，说吧。
Yeah, go ahead.

781
00:28:58,190 --> 00:29:00,470
所以这个物理地址
So this 56 for the physical

782
00:29:00,470 --> 00:29:02,960
的 56 是可能的
address is that the,

783
00:29:03,240 --> 00:29:06,380
n内存位置的数目。
the number of possible memory locations.

784
00:29:06,510 --> 00:29:07,680
我认为这不是位的数目，
I don't think it's the

785
00:29:07,680 --> 00:29:11,140
因为处理器是 64 位的机器。
number of bits because the 64 bit machine.

786
00:29:11,170 --> 00:29:14,410
56 可以扩大到 64 ，
That 56 could go up to 64,

787
00:29:14,410 --> 00:29:17,850
但是他们选择只使用 56 位。
but they just choose it to have just 56.

788
00:29:18,600 --> 00:29:19,350
没错，
That's correct,

789
00:29:19,350 --> 00:29:20,280
从一种角度来看，
one way to think about it,

790
00:29:20,280 --> 00:29:21,120
他们在板上只使用 56 位，
then they only have to run

791
00:29:21,120 --> 00:29:24,520
而不是 64 位。
56 wide on the board as opposed to 64.

792
00:29:25,530 --> 00:29:27,260
我明白了。
I see, I see.

793
00:29:30,220 --> 00:29:32,530
好吧。我也有一个问题，
Okay. I also have a question,

794
00:29:32,530 --> 00:29:35,650
你能
um, so kind of, could you

795
00:29:35,650 --> 00:29:36,670
倒退一张幻灯片吗。好的。
go back one slide maybe. Yeah.

796
00:29:38,820 --> 00:29:42,570
从 CPU 开始，
so from the CPU,

797
00:29:42,570 --> 00:29:44,700
我们通过 MMU ，
we go through the MMU and

798
00:29:44,700 --> 00:29:47,010
然后再到内存，
then to the memory, but

799
00:29:47,010 --> 00:29:50,160
但是不同进程的
where, where here is the distinction

800
00:29:50,160 --> 00:29:53,460
区别在哪里，
for different processes, because like each

801
00:29:53,460 --> 00:29:56,040
因为每个进程，
process, like process, like the shell

802
00:29:56,040 --> 00:30:00,450
比如 shell 进程有地址 0x1000 ，
process has something at address like 0x1000,

803
00:30:00,450 --> 00:30:02,610
然后 ls 进程
and then the ls process

804
00:30:02,610 --> 00:30:06,090
也有地址 0x1000 ，
also has something at address 0x1000, so

805
00:30:06,090 --> 00:30:07,350
所以我们需要将它们
we need to translate those to

806
00:30:07,350 --> 00:30:12,680
转换成不同的物理地址，所以。是的，
different physical, so. Yeah, the satp register,

807
00:30:13,330 --> 00:30:15,580
通过 satp 寄存器，这个寄存器包含
contains, the register who contains the

808
00:30:15,580 --> 00:30:17,760
要使用的映射的地址。
address of which map to use.

809
00:30:18,450 --> 00:30:20,580
所以 ls 使用自己的映射，
So ls runs with its own map,

810
00:30:20,580 --> 00:30:22,710
cat 也使用自己的映射。
you know cat with its own map.

811
00:30:22,710 --> 00:30:25,020
好的，所以是每个进程
OK, so each process will have

812
00:30:25,020 --> 00:30:27,580
都有自己的映射。是的。
its completely own map. Yeah.

813
00:30:28,140 --> 00:30:29,700
理解了，谢谢。
Makes sense, thank you.

814
00:30:29,700 --> 00:30:31,380
事实上，有一个很好的方法
In fact, there's a great a

815
00:30:31,380 --> 00:30:32,220
到达下一个知识点，
way to the next,

816
00:30:33,300 --> 00:30:36,340
所以如果每个进程都有自己的映射。
point, so if every process has its own map.

817
00:30:36,870 --> 00:30:38,430
这个映射有多大，
You know how big is this

818
00:30:38,430 --> 00:30:40,380
就像我在这里画的那样。
map, like that I've drawn here.

819
00:30:40,900 --> 00:30:42,220
是的，这张图里是
Well, that map is 2 to

820
00:30:42,220 --> 00:30:44,520
2 的 27 次方，
the power 27 entries, correct,

821
00:30:46,460 --> 00:30:48,140
那可是相当大的一个数。
and that's pretty big.

822
00:30:49,030 --> 00:30:50,500
如果每个进程
And I would fill physical

823
00:30:50,500 --> 00:30:51,910
都完全填充映射，
memory reasonable quickly,

824
00:30:51,910 --> 00:30:53,650
物理内存将会
if every process exactly how

825
00:30:53,650 --> 00:30:56,300
很快用完。
to complete you know populated map.

826
00:30:56,560 --> 00:30:58,450
然后是巨大的，
And then there's gigantic, means that

827
00:30:58,450 --> 00:31:00,130
意味着每个进程都非常大，
every process is very big,

828
00:31:00,130 --> 00:31:01,420
所以实际上
and so in fact this is

829
00:31:01,420 --> 00:31:03,700
硬件不是这样
not the way hardware actually

830
00:31:03,700 --> 00:31:04,900
存储页表的，
stores page tables,

831
00:31:04,900 --> 00:31:06,040
你可以把它想成
you can think about it

832
00:31:06,040 --> 00:31:07,690
一个数组，
conceptually as an array,

833
00:31:07,690 --> 00:31:09,910
从 0 到 2 的 27 次方，
you know going from zero to 2 power 27,

834
00:31:09,910 --> 00:31:11,840
但实际上并不是这样的。
but actually is not what happens in practice.

835
00:31:12,120 --> 00:31:13,110
实际上，
In practice,

836
00:31:13,110 --> 00:31:15,750
这是一个多级结构，
it's a multi-level structure that

837
00:31:15,750 --> 00:31:21,780
这才是真正的 RISC-V 页表。
here's actually the real RISC-V page table.

838
00:31:23,460 --> 00:31:25,820
页表结构以及硬件实现。
Structure and what the hardware implements.

839
00:31:26,820 --> 00:31:28,350
我们之前知道的
And so what happens with the

840
00:31:28,350 --> 00:31:31,820
作为索引的开始的 27 位会发生什么变化。
27 bits that we started earlier, the index.

841
00:31:32,240 --> 00:31:35,810
它实际上被分成
It's actually split in three

842
00:31:35,810 --> 00:31:37,860
三个 9 位数字。
9 bit numbers.

843
00:31:38,220 --> 00:31:40,230
最前面的九位
And the first, the top nine

844
00:31:40,230 --> 00:31:42,660
用于索引
bits, are used to index into

845
00:31:42,660 --> 00:31:44,920
顶层页表，
the top level page table,

846
00:31:44,990 --> 00:31:46,700
也就是他们所称的目录。
directory as they are called.

847
00:31:47,120 --> 00:31:48,410
然后一个目录，
And so, then one directory,

848
00:31:48,410 --> 00:31:49,520
它们中的一个，
you know one of these guys,

849
00:31:49,520 --> 00:31:53,640
大小是 4096 字节，
you know is 4096 bytes, 4096 bytes,

850
00:31:54,310 --> 00:31:55,800
就像页面大小一样。
just like the page size.

851
00:31:56,150 --> 00:31:58,820
一个 PTE 条目，
A PTE entry, one of

852
00:31:58,820 --> 00:32:02,040
其中的一个条目是 64 字节，
the entries in the thing is 64 bytes,

853
00:32:03,520 --> 00:32:07,090
不好意思，我的意思是 64 位，，就像寄存器一样，
64 bit, I mean, sorry, like the register

854
00:32:07,090 --> 00:32:08,680
有 8 个字节。
with so eight bytes.

855
00:32:09,000 --> 00:32:10,230
所以这就意味着
And so there's going to mean

856
00:32:10,230 --> 00:32:12,080
使用 4096 处以 8 ，
that you do 4096

857
00:32:12,710 --> 00:32:14,390
表示
divided by eight, means there are

858
00:32:14,390 --> 00:32:17,090
其中一个目录页中
512 entries in one of those

859
00:32:17,090 --> 00:32:18,300
有 512 个条目。
directory pages.

860
00:32:19,400 --> 00:32:20,810
因此，基本上情况是，
So basically what happens is

861
00:32:20,810 --> 00:32:23,360
satp 寄存器指向
like the satp points to the top

862
00:32:23,480 --> 00:32:24,650
顶层根目录，
root directory,

863
00:32:24,650 --> 00:32:25,940
我们将顶层的 9 位索引
we take the top level 9

864
00:32:25,940 --> 00:32:29,040
放入页目录中。
bits index into the page directory.

865
00:32:29,190 --> 00:32:30,060
现在给了我们
And now gives us a new

866
00:32:30,060 --> 00:32:31,340
一个新的物理页码。
physical page number.

867
00:32:32,040 --> 00:32:33,330
这个物理页码是
And that physical page number

868
00:32:33,330 --> 00:32:36,030
下一级页面目录的地址，
is the page directory for the next level,

869
00:32:36,030 --> 00:32:36,870
所以当我们使用
so when we use the

870
00:32:36,870 --> 00:32:40,200
下一级索引，
next level index,

871
00:32:39,200 --> 00:32:41,210
来索引到
to index into that page

872
00:32:41,210 --> 00:32:42,890
该页面目录，
directory and then you know

873
00:32:42,890 --> 00:32:43,670
然后继续，
and so forth,

874
00:32:43,670 --> 00:32:44,600
我们想要找到一个，
you know, we'd like to find

875
00:32:44,600 --> 00:32:46,490
我们想得到
one we get the bottom level

876
00:32:46,490 --> 00:32:47,620
最低级别的页面目录。
page directory.

877
00:32:47,780 --> 00:32:49,760
它为我们提供了条目，
And that basically gives us the entry,

878
00:32:49,760 --> 00:32:51,560
将虚拟地址映射到
that maps the virtual address

879
00:32:51,560 --> 00:32:52,600
物理地址。
to physical address.

880
00:32:55,680 --> 00:32:56,400
在某种意义上，
So in some sense,

881
00:32:56,400 --> 00:32:58,170
它与我在上一张幻灯片中展示的
it's very similar to where I

882
00:32:58,170 --> 00:32:59,520
非常相似，
showed in the previous slide except

883
00:32:59,520 --> 00:33:00,930
除了索引发生在三个步骤
they're basically the index happens in

884
00:33:00,930 --> 00:33:02,760
而不是一个步骤中。
three steps instead of one step.

885
00:33:02,870 --> 00:33:04,070
这就是优点，
And this is advantage,

886
00:33:04,070 --> 00:33:05,480
这种方案的主要优点是
the main advantage of this scheme

887
00:33:05,480 --> 00:33:07,760
大部分地址空间
is that large parts of the

888
00:33:07,760 --> 00:33:09,470
没有被使用，
address space are not being used,

889
00:33:09,470 --> 00:33:10,310
你不需要为
you don't have to have any

890
00:33:10,310 --> 00:33:11,880
没有使用的地址空间创建页表条目。
page table entries for that.

891
00:33:12,920 --> 00:33:13,550
例如，
For example,

892
00:33:13,550 --> 00:33:14,570
假设你有一个
let's say you have a new

893
00:33:14,570 --> 00:33:15,660
新的地址空间。
address space.

894
00:33:16,130 --> 00:33:18,470
它只有一页，
That has only one page like

895
00:33:18,470 --> 00:33:19,500
比如最下面的一页。
the bottom page.

896
00:33:19,640 --> 00:33:21,500
是的，4096 。
Yeah, 4096.

897
00:33:22,790 --> 00:33:24,410
并且没有其他页面
And no other pages in

898
00:33:24,410 --> 00:33:25,550
在地址空间中，
the address space,

899
00:33:25,550 --> 00:33:27,860
因此实际只映射地址
so only addresses 0 to 4095(6)

900
00:33:27,860 --> 00:33:29,340
0 到 4095(6) 。
are actually mapped.

901
00:33:29,500 --> 00:33:30,880
你需要多少个页表条目
How many page table entry or

902
00:33:30,880 --> 00:33:32,200
或页表目录
page table directories you need

903
00:33:32,200 --> 00:33:35,060
来映射这个特殊的页。
to map that particular page.

904
00:33:39,280 --> 00:33:41,280
嗯，你需要一个顶层的。
Well, you need one of the top, correct.

905
00:33:41,790 --> 00:33:43,440
你需要该条目中的
And you need basically value in

906
00:33:43,440 --> 00:33:45,440
值为 0 ，
that entry for zero,

907
00:33:46,520 --> 00:33:47,840
最高级别的 9 位，
the top level 9 bits,

908
00:33:47,840 --> 00:33:49,640
你知道 0 ，
you know zero, zero so you

909
00:33:49,640 --> 00:33:51,500
所以你需要一个 0 的条目。
need an entry for 0.

910
00:33:51,860 --> 00:33:53,420
然后你需要
So that means you need one

911
00:33:53,420 --> 00:33:54,740
一个中级条目，
middle level entry,

912
00:33:54,740 --> 00:33:56,510
你知道它对应于
you know that basically corresponds

913
00:33:56,510 --> 00:33:57,170
下一个，
to the next,

914
00:33:57,170 --> 00:33:59,060
你知道九个 0 比特，
you know nine 0 bits and

915
00:33:59,060 --> 00:34:00,500
然后一个条目对应接下来的
then one entry for the next

916
00:34:00,500 --> 00:34:01,480
九个 0 比特。
nine zero bits.

917
00:34:02,170 --> 00:34:04,300
所以我们只需要
So basically we get away with

918
00:34:04,300 --> 00:34:07,160
三个页目录就可以了。
three page directories.

919
00:34:11,420 --> 00:34:12,770
在我们上一张幻灯片的
In our previous scheme on the

920
00:34:12,770 --> 00:34:14,120
方案中，
previous slide correct,

921
00:34:14,120 --> 00:34:15,080
我们有 2 的 27 次方个条目，
we have 2 to the power

922
00:34:15,080 --> 00:34:17,390
现在我们
27 entries and now we basically

923
00:34:17,390 --> 00:34:18,800
只需要有 3 乘以 512 个
have to have 3 times whatever

924
00:34:18,800 --> 00:34:20,580
条目就可以了。
512 entries that we're done.

925
00:34:21,940 --> 00:34:24,970
这就是
That's the main reason why

926
00:34:24,970 --> 00:34:26,620
实际硬件
you know the actual hardware

927
00:34:26,620 --> 00:34:28,360
使用多级树方案的
has this hierarchical,

928
00:34:28,360 --> 00:34:31,060
主要原因。
multi-level tree scheme.

929
00:34:32,570 --> 00:34:34,010
有人要提问吗，
Any questions about this, because it's

930
00:34:34,010 --> 00:34:34,920
因为这很重要。
pretty important.

931
00:34:36,280 --> 00:34:37,520
Samir ，说吧。
Samir, go ahead.

932
00:34:38,980 --> 00:34:44,050
我的问题是，
So my question is as since

933
00:34:44,050 --> 00:34:46,090
每个页表的 PPN 号
the PPM number from each page

934
00:34:46,090 --> 00:34:48,100
是 44 位。
table is 44 bits.

935
00:34:48,430 --> 00:34:50,770
第二个，比如
And the second say the middle

936
00:34:50,770 --> 00:34:53,880
虚拟内存中间的表。
table resides on the virtual memory.

937
00:34:53,950 --> 00:34:56,560
我们从哪里得到丢失的 12 位。
Where do we get the missing 12 bits from.

938
00:34:57,290 --> 00:34:58,820
最后 12 位，
Well, the final twelve bits okay

939
00:34:58,820 --> 00:35:00,260
好的，
so good good good,

940
00:35:00,260 --> 00:35:02,740
所以你说的是这 44 位，对吗。
so you're saying these 44, correct.

941
00:35:02,940 --> 00:35:04,380
是的。这是怎么回事，
Yes. What is going on with that,

942
00:35:04,380 --> 00:35:06,210
所有的页面目录或
while all page, all page directories

943
00:35:06,210 --> 00:35:07,480
页面行，
or page line,

944
00:35:08,170 --> 00:35:10,360
它们是
and so they basically they're a

945
00:35:10,360 --> 00:35:11,920
44 位物理页码
physical page number is 44 plus

946
00:35:11,920 --> 00:35:16,120
加上 12 个零位。
twelve, twelve zero bits.

947
00:35:18,920 --> 00:35:20,180
如果我们看
And so what actually happens if

948
00:35:20,180 --> 00:35:21,860
这些PTE条目，
we look at these PTE entries,

949
00:35:21,860 --> 00:35:23,990
它们都有相同的形式，
they all have the same sort of form,

950
00:35:23,990 --> 00:35:25,840
如果你看这中的一个。
if you look at one of these guys.

951
00:35:25,920 --> 00:35:26,880
有 44 位，
There are 44 bits,

952
00:35:26,880 --> 00:35:28,590
还有 12 位是 0 ，
there are 12 bits 0,

953
00:35:28,590 --> 00:35:30,060
所以我们得到了
so that gives us a

954
00:35:30,060 --> 00:35:32,280
44 加 12 是 56 ，
44 plus 12 is 56, so

955
00:35:32,280 --> 00:35:33,660
这是一个物理地址，
that gives us a physical address,

956
00:35:36,620 --> 00:35:39,860
这意味着 64 位中，
and so that means there's 64 bits,

957
00:35:39,860 --> 00:35:41,420
实际上还有一些位
there's actually some bits left

958
00:35:41,420 --> 00:35:42,470
没有使用，
there not being used and

959
00:35:42,470 --> 00:35:43,850
事实上，
in fact the bottom 12

960
00:35:43,850 --> 00:35:45,020
最下面的 12 位，
bits were basically or the

961
00:35:45,020 --> 00:35:47,030
或者说最下面的 10 位，
bottom 10 definitely bottom based

962
00:35:47,030 --> 00:35:48,320
完全没有使用，
on not used at all, and

963
00:35:48,320 --> 00:35:50,210
事实上，页面硬件
in fact the paging hardware

964
00:35:50,210 --> 00:35:52,490
存储了一系列
stores or stores a bunch

965
00:35:52,490 --> 00:35:54,950
控制转换的标志，
of flags that control the

966
00:35:54,950 --> 00:35:56,090
我们很快会
translation and we'll talk about

967
00:35:56,090 --> 00:35:57,480
讨论这些标志。
those flags in the second.

968
00:35:57,730 --> 00:36:00,520
用它们来
And with their

969
00:36:00,520 --> 00:36:02,140
控制转换，
to control the translation and

970
00:36:02,140 --> 00:36:03,520
它们存储在
they're stored basically in the bottom

971
00:36:03,520 --> 00:36:04,860
最下面的10位。
10 bits.

972
00:36:05,100 --> 00:36:06,780
这也意味着，
It also means that, you

973
00:36:06,780 --> 00:36:07,890
这两个加起来
know, if you add these two

974
00:36:07,890 --> 00:36:09,660
就是 54 位，
up that's 54 bits,

975
00:36:09,660 --> 00:36:11,680
还剩下 10 位
basically there's 10 bits left.

976
00:36:11,920 --> 00:36:13,660
没有使用，这 10 位
There are unused, those 10 bits

977
00:36:13,660 --> 00:36:14,650
也是
are again,

978
00:36:14,650 --> 00:36:16,810
为了将来的增长（保留的），
you know for future growth,

979
00:36:16,810 --> 00:36:17,920
所以在某个时候，
so at some point we might

980
00:36:17,920 --> 00:36:18,850
我们可能会有
have a new type of

981
00:36:18,850 --> 00:36:20,800
一种新型的 RISC-V 处理器，
RISC-V processor, that will have a

982
00:36:20,800 --> 00:36:22,840
它的页表结构会略有不同，
slightly different structure page tables,

983
00:36:22,840 --> 00:36:24,460
它实际上可能会
and it might actually have bigger

984
00:36:24,460 --> 00:36:25,930
有比 44 位更大的
than 44 bits for the physical

985
00:36:25,930 --> 00:36:31,380
物理页码。理解了吗？谢谢。
page number. OK? Thank you.

986
00:36:31,380 --> 00:36:32,340
事实上，
In fact you can see

987
00:36:32,340 --> 00:36:33,090
你可以在这里看到，
it here like if you

988
00:36:33,090 --> 00:36:33,990
如果你看一下
look at a single entry

989
00:36:33,990 --> 00:36:36,060
这里画的单个条目，
direct that's drawn here,

990
00:36:36,060 --> 00:36:37,920
你知道它们还
you know they're basically.

991
00:36:38,490 --> 00:36:40,140
剩下 10 位，
10, 10 bits left, that

992
00:36:40,140 --> 00:36:41,200
未被使用。
are not being used.

993
00:36:42,020 --> 00:36:44,240
好的，我们来看一下
Okay, so let's look at the flags

994
00:36:44,240 --> 00:36:45,680
这些标志位，
for a second, because it's sort

995
00:36:45,680 --> 00:36:46,620
因为它们很重要。
of important.

996
00:36:46,940 --> 00:36:50,180
那么，每个转换条目的最后 10 位，
so, every translation in the bottom 10

997
00:36:50,180 --> 00:36:51,170
都存储了一系列标志位，
bits, there's a bunch of flag

998
00:36:51,170 --> 00:36:54,960
第一个标志位是 valid 。
stored and the first flag is valid.

999
00:36:55,540 --> 00:36:57,880
如果设置了有效位，
If a valid bit set,

1000
00:36:57,880 --> 00:37:00,130
则意味着这是有效 PTE ，
that means this is a valid PTE,

1001
00:37:00,130 --> 00:37:02,220
你可以用它来转换。
and you can use it for translation.

1002
00:37:03,180 --> 00:37:05,190
因此，我们
And so, we're going to

1003
00:37:05,190 --> 00:37:06,630
这里使用的例子，
run my little example, that I

1004
00:37:06,630 --> 00:37:08,790
三个页面目录，
used here, three page directories,

1005
00:37:08,790 --> 00:37:10,620
当只使用条目 0 时，
when only entry 0 is used

1006
00:37:10,620 --> 00:37:12,390
只有条目 0 设置
then only entey 0 will have

1007
00:37:12,390 --> 00:37:13,890
有效位，
valid bit set and none of

1008
00:37:13,890 --> 00:37:15,390
其他 511 个条目
the other 511 entries

1009
00:37:15,390 --> 00:37:17,220
都不会设置有效位。
will not have valid bit set.

1010
00:37:18,600 --> 00:37:21,300
这告诉 MMU ，
And that basically tells MMU,

1011
00:37:21,300 --> 00:37:22,740
你不需要追查这个 PTE ，
well, you don't have to chase

1012
00:37:22,740 --> 00:37:25,590
这个 PTE
down this PTE, PTE just contains no

1013
00:37:25,590 --> 00:37:26,680
不包含有效信息。
valid information.

1014
00:37:27,820 --> 00:37:30,730
然后 R 表示允许
Then "R" means you're allowed

1015
00:37:30,730 --> 00:37:32,590
从该页读取，
to read from that page, write

1016
00:37:32,590 --> 00:37:35,160
write 表示允许向该页写入。
means you're allowed to write to the page.

1017
00:37:35,240 --> 00:37:37,790
Execute 表示允许
Execute means you're allowed to execute

1018
00:37:37,790 --> 00:37:39,040
执行其中的指令。
instruction from it.

1019
00:37:39,330 --> 00:37:42,810
User 表示本页
User, means you know this page is

1020
00:37:42,810 --> 00:37:44,640
可以被在用户空间中
also accessible by a process

1021
00:37:44,640 --> 00:37:46,440
运行的进程访问。
running in user space.

1022
00:37:47,340 --> 00:37:48,300
然后，其他的位
And then the other bits you

1023
00:37:48,300 --> 00:37:49,140
不那么重要，
not that important,

1024
00:37:49,140 --> 00:37:49,740
它会在某个时候出现，
it will show up at

1025
00:37:49,740 --> 00:37:51,570
这是五个比较重要的
some point, those are sort of five

1026
00:37:51,570 --> 00:37:52,920
标志位。
important bits.

1027
00:37:55,970 --> 00:37:57,040
理解了吗？
Does that make sense.

1028
00:38:01,740 --> 00:38:03,960
是的， Nithya ，我可能会念错你的名字，
Yeah, Nithya, I'd probably mispronouncing your

1029
00:38:03,960 --> 00:38:06,180
我向你道歉。
name I apologize to you.

1030
00:38:06,850 --> 00:38:08,440
就是这样读的，
That's, that's the representation,

1031
00:38:08,440 --> 00:38:09,340
谢谢，
thank you,

1032
00:38:09,340 --> 00:38:11,860
我有一个关于
I had a quick question about,

1033
00:38:11,860 --> 00:38:13,810
三个页表的问题，
the three page table,

1034
00:38:13,810 --> 00:38:16,540
那么地址或
so how are the addresses or

1035
00:38:16,540 --> 00:38:19,510
PPN 值是如何组合在一起
like the PPN values combined to form

1036
00:38:19,510 --> 00:38:21,340
形成最终物理地址的，
the final physical address, I might

1037
00:38:21,340 --> 00:38:22,080
我可能错过了这个。
miss that.

1038
00:38:22,350 --> 00:38:22,950
嗯，是的，
Um, yeah,

1039
00:38:22,950 --> 00:38:24,330
我可能说得
I may not say that said it

1040
00:38:24,330 --> 00:38:26,940
不是很清楚。
very explicitly. So the first

1041
00:38:26,940 --> 00:38:29,340
因此，第一个 PPN 位于页表的顶部，
PPN correcting tops the page table,

1042
00:38:29,340 --> 00:38:30,720
即顶级页面目录中的
the first PPN in the top

1043
00:38:30,720 --> 00:38:32,200
第一个 PPN 。
level page directory.

1044
00:38:32,300 --> 00:38:35,150
它包含下一级
And contains the physical address of

1045
00:38:35,150 --> 00:38:36,650
的物理地址。
the next level down.

1046
00:38:37,780 --> 00:38:39,820
这个页目录
And one contains the one next

1047
00:38:39,820 --> 00:38:40,960
又包含下一级，
level down and then in the

1048
00:38:40,960 --> 00:38:43,210
在最后一级仍然包含 44 位，
final one we still have are

1049
00:38:43,210 --> 00:38:45,130
它包含了
[] 44 bits that contains then

1050
00:38:45,130 --> 00:38:47,110
我们实际上
the actual physical address off the

1051
00:38:47,110 --> 00:38:48,460
需要转换的页面的
page that we're actually trying to

1052
00:38:48,460 --> 00:38:49,540
物理地址。
translate to.

1053
00:38:50,150 --> 00:38:51,860
好的，理解了，谢谢。
OK, that makes sense, thank you.

1054
00:38:51,860 --> 00:38:53,750
好的，还有一个有趣的问题，
Okay, and one interesting question,

1055
00:38:53,750 --> 00:38:54,860
让我们先说一下，
just let us side note,

1056
00:38:54,860 --> 00:38:56,870
在回答其他两个问题之前，
before let me answer my

1057
00:38:56,870 --> 00:38:58,490
我先回答一下
own question before answering the

1058
00:38:58,490 --> 00:38:59,690
自己的问题，
two raised hands here,

1059
00:38:59,690 --> 00:39:02,030
回顾这张图片，
look back at this picture,

1060
00:39:02,030 --> 00:39:03,920
为什么是物理页码
why, why are the physical page

1061
00:39:03,920 --> 00:39:05,800
存储在这些页面目录中。
numbers stored in these page directories.

1062
00:39:07,810 --> 00:39:09,960
为什么不是虚拟地址？
Why not a virtual address.

1063
00:39:11,520 --> 00:39:12,870
因为我们需要
Because we need to look it

1064
00:39:12,870 --> 00:39:14,460
在内存中查找它，比如
up in memory, like look up

1065
00:39:14,460 --> 00:39:16,110
在内存中查找下一个目录。
the next directory in memory.

1066
00:39:16,110 --> 00:39:16,800
是的，
Yeah right,

1067
00:39:16,800 --> 00:39:18,210
我们不能让
we could not have a

1068
00:39:18,210 --> 00:39:19,770
一种转换方式
translation scheme depends on yet

1069
00:39:19,770 --> 00:39:20,940
依赖另一种转换方式，
another translation scheme,

1070
00:39:20,940 --> 00:39:21,780
你知道我们可以
you know we could sort of,

1071
00:39:21,780 --> 00:39:23,250
递归查找，
recursive intent look, so that

1072
00:39:23,250 --> 00:39:24,380
所以这里解释一下。
just make sense.

1073
00:39:24,620 --> 00:39:26,300
这就是正确的答案，
That's exactly the right answer,

1074
00:39:26,300 --> 00:39:27,590
它必须是一个物理地址数，
it has to be a physical number,

1075
00:39:27,590 --> 00:39:28,730
那么 satp 寄存器呢，
how about the satp,

1076
00:39:28,730 --> 00:39:29,930
你怎么使用 satp 寄存器，
what do you use the satp,

1077
00:39:29,930 --> 00:39:31,130
它存储什么，
what does it store it store

1078
00:39:31,130 --> 00:39:32,860
存储的是物理地址还是虚拟地址？
a physical address or a virtual address.

1079
00:39:39,180 --> 00:39:41,340
也是物理的，
Also physical, assuming that

1080
00:39:41,340 --> 00:39:42,480
第一页目录也是在内存中。
the first page directory is

1081
00:39:42,480 --> 00:39:45,570
完全正确，
also memory, right. Exactly so

1082
00:39:45,570 --> 00:39:46,080
所以它必须是
it has to be a

1083
00:39:46,080 --> 00:39:47,580
一个物理地址数，因为我们实际上
physical number because we're actually

1084
00:39:47,580 --> 00:39:49,960
是用它来转换。
trying to use it for translation.

1085
00:39:50,100 --> 00:39:52,560
而且，你知道 satp 寄存器，
And, so you know the satp, you

1086
00:39:52,560 --> 00:39:53,700
你需要知道
need to know what the physical

1087
00:39:53,700 --> 00:39:54,820
路由到
page number is,

1088
00:39:54,930 --> 00:39:56,430
页面目录的
on the route of the

1089
00:39:56,430 --> 00:39:57,400
物理页码是什么。
page directory.

1090
00:39:59,170 --> 00:40:00,490
好的，还有两个问题，
OK, there were two other questions

1091
00:40:00,490 --> 00:40:01,450
两个人举手，
or two people who raise their

1092
00:40:01,450 --> 00:40:02,740
你可以，
hands, you do,

1093
00:40:06,120 --> 00:40:08,080
重复你的问题，如果。
repeat your question if.

1094
00:40:10,740 --> 00:40:13,260
这里有一个
So there's a hierarchy of three

1095
00:40:13,260 --> 00:40:15,210
由三个表组成的层次结构，
tables and each of them is

1096
00:40:15,210 --> 00:40:16,740
每个表都由虚拟地址的
indexed by a part of the

1097
00:40:16,740 --> 00:40:17,910
一部分进行索引，
virtual address,

1098
00:40:17,910 --> 00:40:20,260
每个索引是 9 位。
each 9 bits long.

1099
00:40:22,730 --> 00:40:23,840
我不确定
So I'm not sure

1100
00:40:23,840 --> 00:40:27,260
我是否理解它们之间的链接
I understand how chaining between

1101
00:40:27,260 --> 00:40:28,640
是如何发生的，
them happens and what it's

1102
00:40:28,640 --> 00:40:30,020
以及它意味着什么，比如，
meant to accomplish, like shouldn't

1103
00:40:30,020 --> 00:40:31,400
仅仅使用
it be sufficient to just

1104
00:40:31,400 --> 00:40:33,770
这三个 9 位地址
use those three 9 bit

1105
00:40:33,770 --> 00:40:34,910
来索引它们中的每一个
addresses to index into each

1106
00:40:34,910 --> 00:40:35,540
难道不够吗？
of them.

1107
00:40:36,800 --> 00:40:37,310
没错，
That's correct,

1108
00:40:37,310 --> 00:40:39,110
所以第一个
so the first, top level

1109
00:40:39,110 --> 00:40:39,890
顶层 9 位用来
9 bits are used to

1110
00:40:39,890 --> 00:40:40,760
在页顶层目录
index the first

1111
00:40:40,760 --> 00:40:42,320
中索引，
top, page top directory,

1112
00:40:42,320 --> 00:40:43,370
第二个在下一个中进行索引，
the second and the next

1113
00:40:43,370 --> 00:40:45,300
第三个在第三个目录中。
one and the third in the third one.

1114
00:40:48,230 --> 00:40:50,180
因此，可能我没有正确
So maybe I'm just not understanding

1115
00:40:50,180 --> 00:40:51,020
理解这一点，
this correctly,

1116
00:40:51,020 --> 00:40:54,080
所以当一个进程
so when a process requests

1117
00:40:54,080 --> 00:40:56,510
请求查找
a certain virtual address to be

1118
00:40:56,510 --> 00:40:57,320
某个虚拟地址时，
looked up,

1119
00:40:57,320 --> 00:40:58,730
它会加载到
it loads into the

1120
00:40:58,730 --> 00:41:00,410
satp 寄存器，
satp register or the CPU

1121
00:41:00,410 --> 00:41:02,240
CPU 会
does and that,

1122
00:41:02,310 --> 00:41:05,070
得到相应的
get to the corresponding correct highest

1123
00:41:05,070 --> 00:41:07,240
最高级别页表。
level page table.

1124
00:41:07,640 --> 00:41:10,120
然后是那个页表，将。
And then that page table will.

1125
00:41:10,620 --> 00:41:13,080
我们使用了
We used in the top

1126
00:41:13,080 --> 00:41:15,390
27 位中的开头的 9 位
level 9 bits from the 27

1127
00:41:15,390 --> 00:41:17,380
来索引该页目录。
to index into that page directory.

1128
00:41:18,670 --> 00:41:19,810
然后结果是什么呢，
And then what is what is

1129
00:41:19,810 --> 00:41:20,830
结果是，
the result of that,

1130
00:41:20,830 --> 00:41:22,690
比如什么都没有，
like if the result is there's

1131
00:41:22,690 --> 00:41:24,490
MMU 会创建
nothing there does MMU

1132
00:41:24,490 --> 00:41:26,590
一个页面表吗？
create a page table,

1133
00:41:26,590 --> 00:41:27,310
不，
No, no,

1134
00:41:27,310 --> 00:41:28,900
MMU 基本上会告诉
MMU basically tells the operating

1135
00:41:28,900 --> 00:41:30,700
操作系统或处理器，
system or tells the processor,

1136
00:41:30,700 --> 00:41:33,070
很抱歉我无法转换该地址，
sorry I couldn't translate that address,

1137
00:41:33,070 --> 00:41:35,140
会导致页面错误，
and basically turns into a

1138
00:41:35,140 --> 00:41:36,340
我们稍后
page fault which we'll talk about

1139
00:41:36,340 --> 00:41:37,300
会讨论这个问题。
a little bit later.

1140
00:41:38,970 --> 00:41:41,370
但是不能转换地址，
But just cannot translate the address,

1141
00:41:41,370 --> 00:41:42,630
它不能转换，
it doesn't translate it's like you

1142
00:41:42,630 --> 00:41:44,070
就像你知道被零除，
know you can't divide by zero,

1143
00:41:44,070 --> 00:41:45,120
你知道如果你试图
you know if you try to

1144
00:41:45,120 --> 00:41:46,740
这样做，处理器会
do that, the processor refuses to

1145
00:41:46,740 --> 00:41:47,380
拒绝这样做。
do it.

1146
00:41:50,130 --> 00:41:50,700
我明白了，好的。
I see, OK.

1147
00:41:54,060 --> 00:41:56,940
Brandon ，你呢。
Brandon, what about you, Brandon.

1148
00:41:56,940 --> 00:41:58,320
我只是想
So I just wanted to

1149
00:41:58,320 --> 00:42:00,060
确保我理解是正确的，
make sure I understand, how I

1150
00:42:00,060 --> 00:42:03,210
也许想知道
think maybe we want to understand

1151
00:42:03,210 --> 00:42:07,170
中间页表是怎么，
how the intermediate page tables well,

1152
00:42:07,170 --> 00:42:09,320
怎么计算它们的物理地址的。
how we calculate the physical address of those.

1153
00:42:09,550 --> 00:42:11,980
那么，这个是否正确，
So, is it correct that say if

1154
00:42:11,980 --> 00:42:13,570
如果我们试图找到
we're trying to find a second

1155
00:42:13,570 --> 00:42:15,400
第二级页表的物理地址，
level page tables physical address,

1156
00:42:15,400 --> 00:42:17,530
我们将从第一级页表中
we would take the PPN from

1157
00:42:17,530 --> 00:42:18,850
拿到 PPN ，
the first level page table,

1158
00:42:18,850 --> 00:42:20,380
即 44 位，
that's 44 bits and then we

1159
00:42:20,380 --> 00:42:22,150
然后我们将原始虚拟地址
add the 12 bit offset from

1160
00:42:22,150 --> 00:42:23,440
的 12 位偏移量相加，
the original virtual address to get

1161
00:42:23,440 --> 00:42:25,060
以获得完整的 56 位，就是这个问题。
the full 56 bit, this question is.

1162
00:42:25,060 --> 00:42:27,040
我们不需要将
We don't add the offset

1163
00:42:27,040 --> 00:42:28,000
虚拟地址的偏移量相加，
from the virtual address,

1164
00:42:28,000 --> 00:42:30,160
我们只取 12 个零位。
we just take twelve 0 bits.

1165
00:42:30,970 --> 00:42:31,960
所以我们取 PPN ，
So we take the PPN

1166
00:42:31,960 --> 00:42:34,000
有 44 位。好的。
there's 44 bits. Okay,

1167
00:42:34,000 --> 00:42:35,530
底部有 12 个零位，
12 0 bits on the bottom

1168
00:42:35,530 --> 00:42:36,580
这给了我们一个
and that gives us a

1169
00:42:36,580 --> 00:42:38,620
56 位的物理地址，
56 bit physical address and

1170
00:42:38,620 --> 00:42:39,670
这就是下一页目录的位置，
that's where the next page directories,

1171
00:42:39,670 --> 00:42:41,530
这要求每个页目录的页
and this requires that basically every

1172
00:42:41,530 --> 00:42:43,800
都是对齐的。
page directories page aligned.

1173
00:42:45,460 --> 00:42:48,300
我明白了，好的，我理解了。
I see, OK, that makes sense.

1174
00:42:49,890 --> 00:42:50,880
这些都是很棒的问题，
So these are all great questions

1175
00:42:50,880 --> 00:42:51,570
这些都是
and these are all things,

1176
00:42:51,570 --> 00:42:52,620
你们会在 page table 实验
you're gonna be struggling within the

1177
00:42:52,620 --> 00:42:53,960
中用到的。
page table lab so.

1178
00:42:54,020 --> 00:42:55,100
现在提问是
Yeah it's very good to ask

1179
00:42:55,100 --> 00:42:56,100
非常好的。
them right now.

1180
00:42:59,990 --> 00:43:01,970
好的，让我想想，
Okay, let me see,

1181
00:43:04,410 --> 00:43:06,600
好的，
Yes, yeah okay,

1182
00:43:06,600 --> 00:43:09,040
让我稍等一下。
let me hold on for a second.

1183
00:43:09,640 --> 00:43:11,180
我整理一下思绪，
And I quote my thoughts

1184
00:43:11,730 --> 00:43:14,260
看看到哪里了。
see where I am.

1185
00:43:16,320 --> 00:43:16,800
好的，
Good good,

1186
00:43:16,800 --> 00:43:17,850
好的，
good, okay,

1187
00:43:17,850 --> 00:43:20,130
一种，
one a sort of you

1188
00:43:20,130 --> 00:43:21,600
还有一件事
know one other thing that I

1189
00:43:21,600 --> 00:43:23,550
我想提一下，
want to mention because you will

1190
00:43:23,550 --> 00:43:25,770
因为你会看到，
see that, is that if

1191
00:43:25,770 --> 00:43:27,390
如果我们想一想，
we think about this,

1192
00:43:27,390 --> 00:43:28,290
你知道我刚才
you know the scheme that I

1193
00:43:28,290 --> 00:43:29,460
展示的方案，
just showed right,

1194
00:43:29,460 --> 00:43:30,660
看起来发生的是
what really seems to be

1195
00:43:30,660 --> 00:43:32,400
我们将值
going on is that we load

1196
00:43:32,400 --> 00:43:34,440
加载或存储到内存中。
or store value to memory.

1197
00:43:34,480 --> 00:43:35,920
在处理器加载或存储值
What the processor loads or stores

1198
00:43:35,920 --> 00:43:36,790
到内存中，
value to memory,

1199
00:43:36,790 --> 00:43:37,930
我们必须查找
we basically have to do free

1200
00:43:37,930 --> 00:43:39,310
空闲内存，对吧，
memory lookups, right,

1201
00:43:39,310 --> 00:43:40,660
一个在页面目录
one in the top of the

1202
00:43:40,660 --> 00:43:41,230
的顶部，
page directory,

1203
00:43:41,230 --> 00:43:42,430
一个在中间页面目录，
one intermediate page

1204
00:43:42,430 --> 00:43:43,840
然后
directory and then one in the

1205
00:43:43,840 --> 00:43:45,280
一个在最底层的页面目录。
bottom level page directory.

1206
00:43:45,500 --> 00:43:46,880
看起来，
It looks like, that you know

1207
00:43:46,880 --> 00:43:49,010
任何对虚拟地址的内存引用
any memory reference to virtual address

1208
00:43:49,010 --> 00:43:51,820
都需要访问空闲内存。
basically requires free memory reach.

1209
00:43:52,380 --> 00:43:54,000
这是很昂贵的。
And so that seems expensive.

1210
00:43:54,530 --> 00:43:55,700
那么，
And so,

1211
00:43:55,700 --> 00:43:57,980
实际上，
what happens in practice where

1212
00:43:57,980 --> 00:43:59,690
在几乎所有处理器都这样做的，
almost all every processor does this,

1213
00:43:59,690 --> 00:44:00,980
它的有一个缓存，
it has a cache sitting

1214
00:44:00,980 --> 00:44:02,570
其中包含
on the side, that contains

1215
00:44:02,570 --> 00:44:04,400
最近使用的转换。
recently used translations.

1216
00:44:05,300 --> 00:44:07,240
这被称为转换后备缓冲器。
And this is called translation look-aside buffer.

1217
00:44:11,800 --> 00:44:13,540
你会经常看到
Then you'll see that term

1218
00:44:14,400 --> 00:44:17,640
这个术语， TLB 。
quite often, of TLB.

1219
00:44:18,400 --> 00:44:19,900
基本上，
Basically it's nothing else than

1220
00:44:19,900 --> 00:44:20,840
它只是
the cache of

1221
00:44:22,500 --> 00:44:25,260
页表条目、 PTE 条目的缓存。
entry, page table entries, PTE entries.

1222
00:44:28,170 --> 00:44:29,670
因此，当进程
So when the process has you

1223
00:44:29,670 --> 00:44:30,720
进程路由第一次
know the first time the process

1224
00:44:30,720 --> 00:44:32,100
查找虚拟地址时，
routes look through virtual address,

1225
00:44:32,100 --> 00:44:34,440
你知道，
you know walks this, hardware

1226
00:44:34,440 --> 00:44:37,140
硬件遍历此页，
walks this page, the three

1227
00:44:37,140 --> 00:44:38,940
即三级页面表，
level page tables, that will come

1228
00:44:38,940 --> 00:44:40,470
会得到最终物理页，
out with you know the final

1229
00:44:40,470 --> 00:44:42,750
叫做那个特定虚拟地址的
physical page, often called final PPN,

1230
00:44:42,750 --> 00:44:44,520
最终 PPN ，
for that particular virtual address,

1231
00:44:44,520 --> 00:44:46,320
然后 TLB
and then basically the

1232
00:44:46,320 --> 00:44:49,440
存储了 VA PA PN
TLB stores, VA, PA, PN,

1233
00:44:49,980 --> 00:44:53,900
或 PA 映射。
or PA mapping on the side.

1234
00:44:53,930 --> 00:44:54,320
因此，
And so,

1235
00:44:54,320 --> 00:44:55,670
下一次查找那个
then the next time you refer

1236
00:44:55,670 --> 00:44:57,520
特定的虚拟地址时，
to that particular virtual address,

1237
00:44:57,490 --> 00:44:58,780
我只需直接
I can just look at straight

1238
00:44:58,780 --> 00:45:00,490
访问 TLB ，
up in the TLB and the

1239
00:45:00,490 --> 00:45:02,290
TLB 就会做出响应，
TLB will respond instead of having

1240
00:45:02,290 --> 00:45:03,580
而不必执行页表遍历。
to do the page table walk.

1241
00:45:05,300 --> 00:45:07,400
是的， Amiar 。
Yep, Amiar.

1242
00:45:09,700 --> 00:45:13,260
因此， TLB 将
So, the TLB map

1243
00:45:13,490 --> 00:45:16,010
虚拟地址映射到
virtual addresses to the physical address

1244
00:45:16,010 --> 00:45:17,960
页面的物理地址，
of the page, that the virtual

1245
00:45:17,960 --> 00:45:20,690
虚拟地址和偏移量
address along with the offset

1246
00:45:20,690 --> 00:45:22,490
一起，
absolutely,

1247
00:45:22,490 --> 00:45:24,290
那么在页表级别
wouldn't it be more efficient

1248
00:45:24,290 --> 00:45:25,520
进行缓存
to like cache at the

1249
00:45:25,520 --> 00:45:27,060
不是更有效吗？
page table level.

1250
00:45:27,770 --> 00:45:30,290
好的，
Okay, so I let me

1251
00:45:30,290 --> 00:45:31,400
让我退一步，
take a step back here,

1252
00:45:31,400 --> 00:45:33,020
实现 TLB 有
there are many ways of

1253
00:45:33,020 --> 00:45:34,550
很多种方式，
implementing the TLB,

1254
00:45:34,550 --> 00:45:35,930
最重要的是，
the most important thing that

1255
00:45:35,930 --> 00:45:36,710
你需要知道
you need to know is that

1256
00:45:36,710 --> 00:45:37,760
有一个 TLB 。
there is a TLB.

1257
00:45:38,230 --> 00:45:40,300
至于 TLB 具体
And the exact details

1258
00:45:40,300 --> 00:45:41,410
是怎么实现的，
of actually how the TLB

1259
00:45:41,410 --> 00:45:42,430
你知道，
has implemented, this sort of

1260
00:45:42,430 --> 00:45:43,690
这个话题
you know not a topic

1261
00:45:43,690 --> 00:45:44,590
我们不会
that we're going to talk

1262
00:45:44,590 --> 00:45:46,260
讲太多细节。
about in great amount of detail.

1263
00:45:46,400 --> 00:45:47,930
那根本不是，
That's not at all,

1264
00:45:47,930 --> 00:45:49,520
所以这实际上
and so this is really

1265
00:45:49,520 --> 00:45:50,900
是位于处理器内部的东西，
something that sits inside of the

1266
00:45:50,900 --> 00:45:52,400
大部分对操作系统
processor and is mostly hidden from

1267
00:45:52,400 --> 00:45:53,120
是隐藏的，
the operating system,

1268
00:45:53,120 --> 00:45:54,470
操作系统并不知道
the operating system doesn't really know

1269
00:45:54,470 --> 00:45:57,020
TLB 是如何操作的，
how to TLB be operates, the

1270
00:45:57,020 --> 00:45:58,190
你需要知道 TLB 存在
only thing the reason you need

1271
00:45:58,190 --> 00:45:59,180
的唯一原因是，
to know that the TLB

1272
00:45:59,180 --> 00:46:02,620
如果你切换页表，
exist is that if you switch page tables,

1273
00:46:03,710 --> 00:46:06,470
然后，通常操作系统需要
then, typically the operating system needs

1274
00:46:06,470 --> 00:46:08,960
告诉处理器
to tell the processor that's switching

1275
00:46:08,960 --> 00:46:10,140
正在切换页表。
page tables.

1276
00:46:10,760 --> 00:46:14,740
并且需要刷新TLB。
And the TLB needs to be flushed.

1277
00:46:16,810 --> 00:46:18,070
因为如果发送的是
Because basically you send

1278
00:46:18,070 --> 00:46:18,820
旧的条目，
stale entries,

1279
00:46:18,820 --> 00:46:19,660
但是如果你切换到
but if you switch to a

1280
00:46:19,660 --> 00:46:20,890
新的页表，
new page table,

1281
00:46:20,890 --> 00:46:22,360
TLB 中的条目
the entries in the TLB may

1282
00:46:22,360 --> 00:46:24,130
可能不再有效，
not be valid anymore and so

1283
00:46:24,130 --> 00:46:25,840
因此需要删除它们，
they need to be removed because

1284
00:46:25,840 --> 00:46:27,370
否则转换将是
otherwise you know the translation would

1285
00:46:27,370 --> 00:46:28,240
不正确的。
be incorrect.

1286
00:46:28,830 --> 00:46:30,540
所以操作系统
And so the operating system is

1287
00:46:30,540 --> 00:46:32,100
通常
typically aware

1288
00:46:32,260 --> 00:46:33,340
会知道
it's aware that there's a,

1289
00:46:33,340 --> 00:46:34,960
有一个 TLB ，
that there is a TLB

1290
00:46:34,960 --> 00:46:36,880
只是偶尔
only basically to tell the

1291
00:46:36,880 --> 00:46:37,990
告诉硬件，
hardware once in a while saying,

1292
00:46:37,990 --> 00:46:39,700
好的，我们不再使用它们了，
okay we'll don't use them anymore,

1293
00:46:39,700 --> 00:46:41,740
因为我要交换页表。
because I'm gonna switch page tables.

1294
00:46:44,140 --> 00:46:45,820
事实上，
And in fact on you know

1295
00:46:45,820 --> 00:46:50,350
在 RISC-V 上，
the, the RISC-V, the instruction

1296
00:46:50,350 --> 00:46:55,200
刷新 TLB 的指令是 sfence_vma。
to flush the TLB is called sfence_vma.

1297
00:46:57,280 --> 00:46:59,080
我不是很确定，
I'm not actually,

1298
00:46:59,750 --> 00:47:02,100
刷新 TLB 。[Biback] 。
flush the TLB. [Biback].

1299
00:47:04,770 --> 00:47:06,000
所以我有一个问题，
So I have a question,

1300
00:47:06,000 --> 00:47:08,190
不是关于 TLB ，
like not regarding TLB

1301
00:47:08,190 --> 00:47:10,110
而是带来了
but that brought kind

1302
00:47:10,110 --> 00:47:11,820
这个问题。
of this question.

1303
00:47:11,970 --> 00:47:14,970
三级支持，
The three level support, that the

1304
00:47:14,970 --> 00:47:17,820
我们拥有的三级分页，
three level paging that we have,

1305
00:47:17,820 --> 00:47:19,710
是由操作系统还是
is it implemented by the operating

1306
00:47:19,710 --> 00:47:21,690
硬件本身实现的？
system or the hardware itself. It

1307
00:47:21,690 --> 00:47:23,060
它是在硬件中实现的。
implemented in hardware.

1308
00:47:23,450 --> 00:47:24,830
你知道所有这些
So you know there's all happens

1309
00:47:24,830 --> 00:47:25,670
都发生在硬件上，
in hardware,

1310
00:47:25,670 --> 00:47:28,460
MMU 是硬件的一部分。
the MMU is a block of hardware.

1311
00:47:28,730 --> 00:47:30,440
在操作系统中，
In the operating system we'll

1312
00:47:30,440 --> 00:47:32,120
我们很快
see in a second when we

1313
00:47:32,120 --> 00:47:34,190
就会看到 xv6 ，
look at xv6, xv6

1314
00:47:34,190 --> 00:47:36,320
xv6 有一个模拟
has a function that models the

1315
00:47:36,320 --> 00:47:37,640
页表遍历的函数，
page table walk, because once in

1316
00:47:37,640 --> 00:47:39,260
因为有时 xv6
a while you know xv6

1317
00:47:39,260 --> 00:47:40,430
必须做硬件
basically has to do what the

1318
00:47:40,430 --> 00:47:41,360
所做的事情。
hardware does.

1319
00:47:42,040 --> 00:47:43,570
所以它有一个
And so it knows

1320
00:47:43,570 --> 00:47:44,380
叫 walk 的函数，
it does have a function

1321
00:47:44,380 --> 00:47:45,970
基本上
called walk, that basically does

1322
00:47:45,970 --> 00:47:47,560
做的是完全一样的事情，
exactly the same thing,

1323
00:47:47,560 --> 00:47:48,900
但是是在软件中。
but in software.

1324
00:47:51,360 --> 00:47:54,510
那么，我能问个问题吗？
So, can I ask a question?

1325
00:47:54,510 --> 00:47:58,670
那么，在此方案中，
So, where in this scheme does the

1326
00:47:58,670 --> 00:48:00,170
处理器缓存适合的位置，
processor cache fit,

1327
00:48:00,170 --> 00:48:02,510
是在地址转换之前
does it happen before the address

1328
00:48:02,510 --> 00:48:04,300
还是之后，
translation or after,

1329
00:48:04,510 --> 00:48:06,700
因为。好的，
because. Yeah, okay let me so

1330
00:48:06,700 --> 00:48:07,840
让我们往后调几个，
let's switch back a little bit

1331
00:48:07,840 --> 00:48:10,800
让我找一下。
a couple, let me see.

1332
00:48:13,120 --> 00:48:14,980
好的，通常 MMU ，
Okay, usually MMU will

1333
00:48:14,980 --> 00:48:17,170
思考的方式是
really the way to think about

1334
00:48:17,170 --> 00:48:18,720
所有这些东西，
is that all this stuff,

1335
00:48:19,870 --> 00:48:21,220
整个部分
you know the whole block is

1336
00:48:21,220 --> 00:48:22,900
都在处理器里。
inside the processor silicon.

1337
00:48:24,350 --> 00:48:25,310
所以这里有一个
So there's a RISC-V

1338
00:48:25,310 --> 00:48:27,080
RISC-V 芯片，
chip and inside of it

1339
00:48:27,080 --> 00:48:27,920
它的内部是 CPU ，
is the CPU,

1340
00:48:27,920 --> 00:48:29,270
实际上有多个 CPU ，
in fact there are multiple CPU

1341
00:48:29,270 --> 00:48:30,640
有 4 个内核。
correct, there 4 cores.

1342
00:48:30,740 --> 00:48:32,240
这是一个 MMU ，
And there's a MMU

1343
00:48:32,240 --> 00:48:34,040
你可以想一想，
and you know you can think about that,

1344
00:48:34,040 --> 00:48:35,990
在 CPU 这一边，
either on this on the CPU side,

1345
00:48:35,990 --> 00:48:37,780
有一个 TLB 。
you know there's a TLB.

1346
00:48:44,460 --> 00:48:45,210
这个理解了，
That makes sense,

1347
00:48:45,210 --> 00:48:47,190
但我想
but I guess my question

1348
00:48:47,190 --> 00:48:48,560
我的问题是关于，
was about the like,

1349
00:48:48,700 --> 00:48:52,120
缓存不只是 TLB ，
cache in terms of not the TLB,

1350
00:48:52,120 --> 00:48:55,000
而是一个普通的缓存，
but just a normal cache like,

1351
00:48:55,000 --> 00:48:56,290
比如，有时我们实际上
sometimes we don't actually go all

1352
00:48:56,290 --> 00:48:58,000
不会一直访问内存。
the way to access the memory.

1353
00:48:58,000 --> 00:48:59,470
好的，不错的想法。
Yeah, good points I think I

1354
00:48:59,470 --> 00:49:00,850
我想我应该在上周的周一，
should like to scheme last week

1355
00:49:00,850 --> 00:49:02,590
RISC-V 处理器
correctly, on monday of the RISC-V

1356
00:49:02,590 --> 00:49:04,300
有一个缓存，
processor and has one cache

1357
00:49:04,300 --> 00:49:05,700
有两个缓存。
it has two cache.

1358
00:49:05,970 --> 00:49:08,100
有些缓存使用物理地址索引，
Some caches are indexed by physical

1359
00:49:08,100 --> 00:49:10,530
有些缓存使用
address, some caches are indexed by

1360
00:49:10,530 --> 00:49:11,540
虚拟地址索引。
virtual address.

1361
00:49:11,800 --> 00:49:13,030
因此，按虚拟地址索引的缓存
So the caches that are indexed

1362
00:49:13,030 --> 00:49:16,160
位于 MMU 之前。
by virtual address sit before the MMU.

1363
00:49:16,540 --> 00:49:17,800
按物理地址索引缓存
And cache in their index by

1364
00:49:17,800 --> 00:49:19,820
位于 MMU 之后。
physical addresses after the MMU.

1365
00:49:25,010 --> 00:49:25,820
这个可以理解吗？
Does that make sense?

1366
00:49:25,820 --> 00:49:27,410
我也有一个问题，
Can I also ask a question

1367
00:49:27,410 --> 00:49:28,850
我的问题是，
my question is,

1368
00:49:28,850 --> 00:49:31,760
你说 TLB ，
you said that the TLB,

1369
00:49:31,760 --> 00:49:33,470
它遍历，所以我把东西
it walks so I like to

1370
00:49:33,470 --> 00:49:34,880
放进 TLB ，
put stuff into TLB,

1371
00:49:34,880 --> 00:49:38,600
硬件遍历页表。
the hardware walks through the page tables.

1372
00:49:39,830 --> 00:49:42,380
如果硬件可以做到这一点，
Why do we arrive walk function,

1373
00:49:42,380 --> 00:49:44,400
我们为什么要实现遍历功能。
if hardware can do that.

1374
00:49:44,560 --> 00:49:45,790
很好的问题，
Very good question,

1375
00:49:45,790 --> 00:49:48,220
一个原因是，
one reason we have, a

1376
00:49:48,220 --> 00:49:49,270
其实有几个原因，
couple of reasons why we do

1377
00:49:49,270 --> 00:49:51,370
或者为什么 xv6 需要它，
it or why xv6 needs it,

1378
00:49:51,370 --> 00:49:52,630
一个是它实际
one is when it actually sets

1379
00:49:52,630 --> 00:49:54,160
设置初始页表的时候。
up the initial page tables.

1380
00:49:54,980 --> 00:49:56,360
你知道它需要
you know it needs to

1381
00:49:56,360 --> 00:49:58,560
对三级页表进行编程。
program the the three levels.

1382
00:49:58,680 --> 00:49:59,940
所以它需要
And so it needs to basically

1383
00:49:59,940 --> 00:50:01,420
模仿这三个层级。
emulate the three levels.

1384
00:50:02,120 --> 00:50:05,090
嗯，还有另一个例子，
Um, and um, another example,

1385
00:50:05,090 --> 00:50:06,740
在 syscall 实验中
that you actually sort of run

1386
00:50:06,740 --> 00:50:08,630
遇到或
into or are running into in

1387
00:50:08,630 --> 00:50:10,550
正在遇到的是，
the syscall lab is that when

1388
00:50:10,550 --> 00:50:12,680
当你复制， xv6 ，
you copy, the xv6, the

1389
00:50:12,680 --> 00:50:14,540
或者说内核有自己的页表，
kernel has its own page table

1390
00:50:14,540 --> 00:50:16,550
每个用户地址空间
and every user address space has

1391
00:50:16,550 --> 00:50:17,700
都有自己的页表。
its own page table.

1392
00:50:18,140 --> 00:50:19,580
偶尔，
And once in a while,

1393
00:50:19,580 --> 00:50:21,620
例如，有些信息
for example it says [info], you know, like

1394
00:50:21,620 --> 00:50:23,510
指向系统基础设施，
system, pointed to system infrastructure,

1395
00:50:23,510 --> 00:50:25,460
它运行在用户空间。
you know that lives in user space.

1396
00:50:25,610 --> 00:50:27,260
内核需要
The kernel needs to translate

1397
00:50:27,260 --> 00:50:28,460
将其转换为
to an address that it can

1398
00:50:28,460 --> 00:50:29,760
可以用来读写的地址。
use to read and write.

1399
00:50:30,340 --> 00:50:31,120
所以，
And so,

1400
00:50:31,120 --> 00:50:32,710
举个例子，如果你看
for example if you're looking

1401
00:50:32,710 --> 00:50:34,600
copyin 和 copyout 。
copyin or copyout.

1402
00:50:34,730 --> 00:50:38,480
基本上，内核使用
Basically, the kernel translates the

1403
00:50:38,480 --> 00:50:41,420
用户页表来转换
user virtual address using the user

1404
00:50:41,420 --> 00:50:44,030
用户虚拟地址，
virtual, using a user page

1405
00:50:44,030 --> 00:50:45,410
获取物理地址，
table to get out of physical

1406
00:50:45,410 --> 00:50:46,520
然后内核
address, that kernel

1407
00:50:46,520 --> 00:50:49,760
获得一个地址，
then get an address out,

1408
00:50:49,760 --> 00:50:51,050
内核可以使用该地址
actually the kernel can use to

1409
00:50:51,050 --> 00:50:52,220
来读写该内存。
read and write that memory.

1410
00:50:54,580 --> 00:50:55,390
有好几个地方
So there's a bunch of places

1411
00:50:55,390 --> 00:50:56,800
会出现这种情况，
going to show up, and I'll

1412
00:50:56,800 --> 00:50:58,630
我希望在 10 分钟或
talk about hopefully in whatever ten

1413
00:50:58,630 --> 00:51:00,000
15 分钟内谈到。
minutes or fifteen minutes.

1414
00:51:00,610 --> 00:51:01,720
我有一个问题，
I have a question,

1415
00:51:01,720 --> 00:51:05,350
为什么硬件不
why doesn't the hardware like expose

1416
00:51:05,350 --> 00:51:06,430
公开遍历函数，
that walk function,

1417
00:51:06,430 --> 00:51:07,300
这样我们就不必
so we don't have to write

1418
00:51:07,300 --> 00:51:08,890
编写自己的函数，而且里面
our own and potentially have bugs

1419
00:51:08,890 --> 00:51:09,430
可能有 bug ，
in it,

1420
00:51:09,430 --> 00:51:11,740
为什么不像这样，
why isn't there like, maybe

1421
00:51:11,740 --> 00:51:12,970
也许有一个特权指令，
a privileged instruction that you can

1422
00:51:12,970 --> 00:51:14,290
你可以传递一个虚拟地址，
pass a virtual address and will

1423
00:51:14,290 --> 00:51:16,120
然后返回物理地址。
give back the physical address.

1424
00:51:16,370 --> 00:51:17,690
好的，这就像
Well, this is just like just

1425
00:51:17,690 --> 00:51:18,770
是存储到虚拟地址，
store to the virtual address

1426
00:51:18,770 --> 00:51:20,480
你又绕回来了，
you get back and will do

1427
00:51:20,480 --> 00:51:21,740
硬件会为你做好，
it right for you,

1428
00:51:21,740 --> 00:51:24,380
所以我稍后会看到，
so I will see later on,

1429
00:51:24,380 --> 00:51:26,750
在下一个实验中，
in the next lab,

1430
00:51:26,750 --> 00:51:27,890
page table 实验，
the page table lab,

1431
00:51:27,890 --> 00:51:29,090
实际上就是
in fact is exactly what you'll

1432
00:51:29,090 --> 00:51:30,650
你要做的事情，
be doing you'll actually set up

1433
00:51:30,650 --> 00:51:32,240
你会以稍微不同的方式设置页表，
the page table slightly differently,

1434
00:51:32,240 --> 00:51:33,440
这样你就可以避免
so that you can avoid the

1435
00:51:33,440 --> 00:51:36,980
在 copyin 和 copyinstr 中遍历。
walk in copyin and copyinstr.

1436
00:51:42,500 --> 00:51:43,640
我想这一点
I think this will become clear

1437
00:51:43,640 --> 00:51:44,780
在我们讨论查看 xv6 的时候
in the second we when we

1438
00:51:44,780 --> 00:51:46,960
就会变得清晰起来，好吗。
talk about we look at the xv6, OK.

1439
00:51:49,700 --> 00:51:51,400
好的。
Okay, good.

1440
00:51:51,800 --> 00:51:54,260
在跳到 xv6 之前，
One more sure basically before jumping

1441
00:51:54,260 --> 00:51:57,400
我想说明一点。
into xv6, I wanted to make one point.

1442
00:51:57,540 --> 00:52:04,200
说明一种考虑页表的方式。
One way to think about, you know, page tables.

1443
00:52:05,980 --> 00:52:09,720
一种流行的说法。
A popular way to phrase this.

1444
00:52:09,930 --> 00:52:13,040
页表提供了
It's the page tables provide

1445
00:52:13,300 --> 00:52:14,980
一定程度的间接性。
a level of indirection.

1446
00:52:25,100 --> 00:52:27,140
基本上
And, that and, so basically

1447
00:52:27,140 --> 00:52:27,890
这种间接性，
this indirection,

1448
00:52:27,890 --> 00:52:28,880
就是
what I'm talking about you know

1449
00:52:28,880 --> 00:52:30,200
之前讨论的从虚拟地址到
this mapping from virtual address to

1450
00:52:30,200 --> 00:52:31,260
物理地址的映射。
physical address.

1451
00:52:31,490 --> 00:52:33,440
并且该映射完全
And this mapping is completely

1452
00:52:33,440 --> 00:52:36,500
在操作系统的控制之下。
under control of the operating system.

1453
00:52:38,350 --> 00:52:40,720
正如我们已经看到的，
As we've seen, you know in the last

1454
00:52:40,720 --> 00:52:42,280
在最后几张幻灯片中我们谈到的，
a couple slides that we talk,

1455
00:52:42,280 --> 00:52:43,780
这意味着
and that means that the

1456
00:52:43,780 --> 00:52:45,640
操作系统因为它
operating system because it has so

1457
00:52:45,640 --> 00:52:46,540
有这么多的控制权，
much control,

1458
00:52:46,540 --> 00:52:48,520
它有完全的控制权，
it has control complete control that

1459
00:52:48,520 --> 00:52:50,740
控制转换，
translation, it can do all

1460
00:52:50,740 --> 00:52:52,060
它可以做各种有意思的技巧。
kinds of interesting tricks.

1461
00:52:52,660 --> 00:52:54,370
举个例子，
And so for example, like

1462
00:52:54,370 --> 00:52:56,260
有一个技巧，
one trick, talk a little

1463
00:52:56,260 --> 00:52:56,860
稍微谈谈这个，
bit about this,

1464
00:52:56,860 --> 00:52:58,630
比如如果一个
like if a page, page entry is

1465
00:52:58,630 --> 00:53:00,790
页面条目是无效的，
invalid and will really return a

1466
00:53:00,790 --> 00:53:02,200
你知道硬件
page you know the hardware will

1467
00:53:02,200 --> 00:53:04,440
会抛出页面错误。
raise page fault.

1468
00:53:04,820 --> 00:53:06,530
作为对页面错误的响应，
In response the page fault,

1469
00:53:06,530 --> 00:53:08,150
操作系统
the operating system could update

1470
00:53:08,150 --> 00:53:09,410
可以更新页表，
the page tables and then

1471
00:53:09,410 --> 00:53:11,120
然后重新启动该指令。
maybe restart the instruction.

1472
00:53:11,620 --> 00:53:12,640
因此，
And so there are all kinds

1473
00:53:12,640 --> 00:53:14,230
在运行时，
of things they can do, at

1474
00:53:14,230 --> 00:53:17,620
通过操作页表，
runtime, and by manipulating

1475
00:53:17,620 --> 00:53:18,740
可以做各种各样的事情。
the page tables.

1476
00:53:19,160 --> 00:53:20,660
我们今天不会
And we're not going to talk

1477
00:53:20,660 --> 00:53:22,070
讨论这个话题，
about it today,

1478
00:53:22,070 --> 00:53:23,300
但是两周后，
but in two weeks,

1479
00:53:23,300 --> 00:53:25,880
我们有一节课来
we'll have a lecture exactly about

1480
00:53:25,880 --> 00:53:27,680
讨论这个话题，一旦你有了
this topic about what cool things

1481
00:53:27,680 --> 00:53:28,970
页表和页面错误，
can you do, once you have

1482
00:53:28,970 --> 00:53:30,420
你可以做什么很酷的事情。
page tables and page faults.

1483
00:53:31,170 --> 00:53:32,430
但重要的是
But it's important to keep

1484
00:53:32,430 --> 00:53:35,310
要记住，这是一种
in mind that this is

1485
00:53:35,310 --> 00:53:38,480
令人难以置信的强大机制。
incredibly powerful mechanism.

1486
00:53:38,540 --> 00:53:40,820
那会给操作系统
That, will provide the operating system

1487
00:53:40,820 --> 00:53:42,700
带来极大的灵活性。
with a tremendous amount of flexibility.

1488
00:53:43,420 --> 00:53:44,890
这也是页表
And there's one reason why page

1489
00:53:44,890 --> 00:53:46,520
如此受欢迎的原因之一。
tables are so popular.

1490
00:53:49,520 --> 00:53:50,780
好的，我接下来
Okay, so what I wanna do

1491
00:53:50,780 --> 00:53:53,960
要做的是讨论 xv6 。
next is actually talk about xv6.

1492
00:53:54,570 --> 00:53:56,550
看看在 xv6 中
Sort of see how

1493
00:53:56,550 --> 00:53:59,240
这些是怎么发生的。
it all plays out in xv6.

1494
00:53:59,600 --> 00:54:00,500
所以我要做的第一件事，
So the first thing I'm gonna

1495
00:54:00,500 --> 00:54:02,060
是看看
do, is going to look

1496
00:54:02,060 --> 00:54:05,000
内核页面布局，
at the kernel page layout,

1497
00:54:05,000 --> 00:54:08,380
如果你愿意的话，
if you will, and

1498
00:54:08,430 --> 00:54:10,200
整个映射在这张幻灯片上，
the mapping is on this slide,

1499
00:54:10,200 --> 00:54:11,560
这是内核的
so here's the

1500
00:54:12,080 --> 00:54:21,900
虚拟地址空间，
virtual address space of the kernel,

1501
00:54:23,470 --> 00:54:25,390
这是物理内存，
here is, actually the physical memory,

1502
00:54:25,390 --> 00:54:27,040
所以这就是你
so this is basically whatever you

1503
00:54:27,040 --> 00:54:28,580
想到的东西，是 DRAM 。
can think about this is DRAM.

1504
00:54:31,760 --> 00:54:33,470
然而事实上并非如此，
And in fact it is not,

1505
00:54:33,470 --> 00:54:35,870
让我收回来一点，
let me take that back immediately

1506
00:54:35,870 --> 00:54:37,780
其中一个部分是 DRAM 。
one part is DRAM.

1507
00:54:38,560 --> 00:54:41,440
还有一部分实际上是 IO 设备。
And one part is actually IO devices.

1508
00:54:46,060 --> 00:54:48,970
也许我会
And so, to sort of maybe, I'm

1509
00:54:48,970 --> 00:54:50,050
先谈一下
going to talk about the physical,

1510
00:54:50,050 --> 00:54:51,400
幻灯片的右边，
the right side of the slide a

1511
00:54:51,400 --> 00:54:52,330
然后我们再谈
little bit first, and then we'll

1512
00:54:52,330 --> 00:54:54,020
幻灯片的左边。
talk about the left side in a second.

1513
00:54:54,310 --> 00:54:55,450
因此，
So the left side of

1514
00:54:55,450 --> 00:54:58,520
幻灯片的左侧完全由硬件决定。
the slide is completely determined by the hardware.

1515
00:54:58,930 --> 00:55:00,670
所以硬件设计师
And so the hardware designers

1516
00:55:00,670 --> 00:55:02,620
决定了合适的布局，
basically determined the layout of that

1517
00:55:02,620 --> 00:55:05,580
就像你上周看到的那样。
fit and you know as you saw before last week.

1518
00:55:05,640 --> 00:55:11,060
当内核启动时，它从地址 0x8000 开始。
When the kernel starts, it starts at this address 0x8000.

1519
00:55:11,740 --> 00:55:15,000
这是由硬件设计师决定的。
And that's determined by the hardware designers.

1520
00:55:15,130 --> 00:55:18,370
所以你应该更清楚，
And so you should be more explicit,

1521
00:55:18,370 --> 00:55:20,500
如果你查看电路板，
if you look at the board,

1522
00:55:20,500 --> 00:55:22,990
这是我周一展示的同一张电路板的图片，
this is the same picture of the board, that I showed on

1523
00:55:22,990 --> 00:55:25,240
但是一张更好的图片，
Monday but is hopefully a little better picture,

1524
00:55:25,240 --> 00:55:26,290
很容易看到，
it's easy to see,

1525
00:55:26,290 --> 00:55:28,260
这是我们的 RISC-V 处理器。
here's our RISC-V processor.

1526
00:55:28,420 --> 00:55:30,640
我们知道 RISC-V 处理器有四个内核，
And we now know correct in the RISC-V processor,

1527
00:55:30,640 --> 00:55:33,220
也有 MMU 。
there four cores, but there's also, MMU.

1528
00:55:33,280 --> 00:55:35,650
还有一个 TLB 或多个 TLB ，
And there's also a TLB or

1529
00:55:35,650 --> 00:55:38,890
每个内核都有自己的 MMU ，
multiple TLB, every core has its own MMU and every

1530
00:55:38,890 --> 00:55:40,400
每个内核都有自己的 TLB 。
core has its own TLB.

1531
00:55:40,800 --> 00:55:42,880
这是 DRAM 芯片。
And here are DRAM chips.

1532
00:55:43,780 --> 00:55:46,240
所以由电路板的设计者
And so basically the designers of

1533
00:55:46,240 --> 00:55:47,890
决定，
the board have decided that,

1534
00:55:47,890 --> 00:55:50,800
你知道，
when, you know, after, you

1535
00:55:50,800 --> 00:55:52,300
在从虚拟地址到
know, the translation from virtual to

1536
00:55:52,300 --> 00:55:54,670
物理地址的转换之后，
physical address basic physical addresses that's

1537
00:55:54,670 --> 00:55:56,620
基本物理地址从 08 开始，
starting you know at 08,

1538
00:55:56,620 --> 00:55:59,540
DRAM 芯片很多地方置零。
you know, a lot of zeros actually go to the DRAM chips.

1539
00:56:00,770 --> 00:56:03,350
0x8 以下的地址
Addresses above below 0x8, may go

1540
00:56:03,350 --> 00:56:04,900
可能是不同的 IO 设备。
to different IO devices.

1541
00:56:05,260 --> 00:56:07,690
所以平台决定，
And so the platform decides

1542
00:56:07,690 --> 00:56:10,120
设计者来决定，
basically the designers this board have

1543
00:56:10,120 --> 00:56:12,300
这块板的物理布局。
decided exactly what the physical layout.

1544
00:56:12,760 --> 00:56:14,800
我想你可以查一下物理布局，
I think you can look that up the physical layout,

1545
00:56:14,800 --> 00:56:17,710
如果你想看，让我给你看看，
if you want to, just let me show you so here's

1546
00:56:17,710 --> 00:56:19,420
这是我在星期一
the same manual that I showed

1547
00:56:19,420 --> 00:56:23,060
给你们看的同一本手册，
you on, um,

1548
00:56:24,230 --> 00:56:28,940
如果你转到第 31 页，
on um, Monday and if you go to actually,

1549
00:56:29,510 --> 00:56:32,360
我记得是。
go to page 31, I believe.

1550
00:56:32,820 --> 00:56:36,150
是的，这一页，如果你往下看，
Yeah it's a page and if you go down,

1551
00:56:36,150 --> 00:56:37,530
这就是内存，
this is whats the memory,

1552
00:56:37,530 --> 00:56:42,150
它会写出内存映射，在电路板上，
it will spell out the memory map is, of the board

1553
00:56:42,150 --> 00:56:43,530
我们会看到在地址 0 ，
and we'll see at address zero

1554
00:56:43,530 --> 00:56:45,700
0 是预留的，那里什么都没有。
zero is reserved nothing is there.

1555
00:56:46,000 --> 00:56:49,990
如果你往下滚动这张内存映射图，
If you go scroll down in this memory map,

1556
00:56:49,990 --> 00:56:52,810
你会看到关于映射的
you'll see some information about all

1557
00:56:52,810 --> 00:56:54,100
所有不同事物的一些信息，
the different things that are mapped,

1558
00:56:54,100 --> 00:56:56,500
例如，以太网板映射到 OX1 ，
for example, ethernet board is mapped

1559
00:56:56,500 --> 00:56:59,440
你知道，0x 的一个地址。
at Ox1, you know, 0x something.

1560
00:57:00,040 --> 00:57:04,940
如果你可以再往下一点的话，太往下了。
If you might go further down, oops, too much down.

1561
00:57:05,040 --> 00:57:10,740
在这里，你可以看到 0x8000 的条目效，
Here, you see the entry for 0x8000 worked

1562
00:57:10,740 --> 00:57:13,260
这实际上是 DDR 内存，
and that actually is DDR memory,

1563
00:57:13,260 --> 00:57:15,180
片外易失性存储器，
the Off-Chip Volatile Memory, so

1564
00:57:15,180 --> 00:57:16,500
所以这些是 DRAM 芯片，
those are the DRAM chips or

1565
00:57:16,500 --> 00:57:18,220
我可以在上一张幻灯片上展示给你看。
I can show you on the previous slide.

1566
00:57:19,520 --> 00:57:21,380
所以，保持头脑清醒是很好的，
And so it's just good to keep your head correct

1567
00:57:21,380 --> 00:57:22,370
即使我们在和 QEMU 交互，
even though we're talking to

1568
00:57:22,370 --> 00:57:24,350
你是在使用软件，
QEMU, you're overseeing software in

1569
00:57:24,350 --> 00:57:26,030
但最终一切都是由
the end everything is determined,

1570
00:57:26,030 --> 00:57:28,300
实际的电路板会决定的。
by you know the actual board.

1571
00:57:30,640 --> 00:57:34,520
好的，回到我的幻灯片。
Okay, so go back to a my slides.

1572
00:57:34,780 --> 00:57:38,270
那我们来看一下布局。
So let's look at the layout.

1573
00:57:38,270 --> 00:57:40,160
好的，诺亚，说吧。
Yeah, Noah, go ahead.

1574
00:57:41,380 --> 00:57:42,760
您说这个布局
Yeah, when you say that this

1575
00:57:42,760 --> 00:57:43,810
是由硬件决定的，
this layout is determined by the

1576
00:57:43,810 --> 00:57:45,850
具体是指
hardware, do you specifically mean

1577
00:57:45,850 --> 00:57:48,370
CPU 本身
like the CPU itself or the

1578
00:57:48,370 --> 00:57:50,800
还是 CPU 所在的板。
board on which the CPU resides.

1579
00:57:50,800 --> 00:57:52,390
是 CPU 所在的板，对的。
The board which the CPU resides,

1580
00:57:52,390 --> 00:57:54,010
因为这块板，
correct. Because you know the borad,

1581
00:57:54,010 --> 00:57:55,480
你知道， CPU 是中间
you know, the CPU is the

1582
00:57:55,480 --> 00:57:56,770
那个正方形的
grey thing in the middle that

1583
00:57:56,770 --> 00:57:59,470
灰色东西，比如 RISC-V ，
square thing, saying whatever RISC-V,

1584
00:57:59,470 --> 00:58:01,660
DRAM 芯片
the DRAM chips are sitting off,

1585
00:58:01,660 --> 00:58:04,600
在处理器旁边，
the off the processor correct, it's

1586
00:58:04,600 --> 00:58:06,070
是电路板设计师
the board designers who put the

1587
00:58:06,070 --> 00:58:08,500
把芯片、 DRAM 和很多 IO 设备
chip the DRAM, you know, do many

1588
00:58:08,500 --> 00:58:10,160
放在一起。
IO devices altogether.

1589
00:58:11,600 --> 00:58:13,430
操作系统的
And large part of

1590
00:58:13,430 --> 00:58:14,720
很大一部分
an operating system is actually,

1591
00:58:14,720 --> 00:58:16,130
是 CPU ，但
you know the CPU is one part, but the

1592
00:58:16,130 --> 00:58:17,270
IO 设备也同样重要，
IO devices are at least as

1593
00:58:17,270 --> 00:58:19,040
对吧，所以
important, right, and so when you're

1594
00:58:19,040 --> 00:58:20,720
当你编写操作系统时，
writing an operating system you both

1595
00:58:20,720 --> 00:58:21,860
你既要处理 CPU ，
have to deal with the CPU

1596
00:58:21,860 --> 00:58:23,690
也要处理 IO 设备，
as well as you know with the IO devices,

1597
00:58:23,690 --> 00:58:24,500
你知道，你想要
you know and you want to

1598
00:58:24,500 --> 00:58:25,860
通过互联网发送数据包，
send a packet over the Internet.

1599
00:58:25,930 --> 00:58:29,370
总得有人来接手。
Well, somebody has to take over.

1600
00:58:29,370 --> 00:58:30,450
你知道网络驱动程序，
You know the network driver,

1601
00:58:30,450 --> 00:58:31,980
网卡来发送数据包，
the NIC card to actually do that,

1602
00:58:31,980 --> 00:58:33,160
这就是操作系统。
and that's the operating system.

1603
00:58:35,450 --> 00:58:37,220
所以回到
So going back to the right

1604
00:58:37,220 --> 00:58:38,240
这张图片的右侧，
side of this picture,

1605
00:58:38,240 --> 00:58:40,550
这是物理地址布局，
which is the physical address layout,

1606
00:58:40,550 --> 00:58:42,110
正如我在
you know we see basically the

1607
00:58:42,110 --> 00:58:43,790
文档中显示的，
bottom was unused as I showed

1608
00:58:43,790 --> 00:58:45,680
底部是未使用的。
you on that document.

1609
00:58:45,740 --> 00:58:46,760
物理地址
It turns out that

1610
00:58:46,760 --> 00:58:48,680
0x1000 ，
0x1000, that physical address,

1611
00:58:48,680 --> 00:58:49,910
是引导 ROM 所在的位置，
that's where the boot ROM

1612
00:58:49,910 --> 00:58:52,370
所以当你打开那块板时，
is, so when you turn on that board,

1613
00:58:52,370 --> 00:58:53,480
首先发生的就是
the first thing that happens is

1614
00:58:53,480 --> 00:58:55,660
引导 ROM 编码开始进行。
actually coding the boot ROM runs.

1615
00:58:55,940 --> 00:58:56,780
当启动 ROM 完成时，
And when the boot rom is

1616
00:58:56,780 --> 00:58:58,490
它实际上会跳到
done it actually will jump to

1617
00:58:58,490 --> 00:59:00,950
这个 0x000 地址，
this 0x000 and it's

1618
00:59:00,950 --> 00:59:02,240
这是操作系统的工作，
a job of the operating system make

1619
00:59:02,240 --> 00:59:03,400
确保那里有
sure that there's some,

1620
00:59:03,760 --> 00:59:04,900
一些数据。
you know, some data there.

1621
00:59:05,460 --> 00:59:06,240
然后还有一堆
And then there's a bunch of

1622
00:59:06,240 --> 00:59:08,280
其他的设备
other devices that will talk about

1623
00:59:08,280 --> 00:59:11,440
与中断控制器交互，
goes to interrupt controller,

1624
00:59:11,440 --> 00:59:13,300
我们将在下周讨论这个问题。
we'll talk about it next week.

1625
00:59:13,540 --> 00:59:16,210
有一个 CLENT ，
There's a CLENT, another part

1626
00:59:16,210 --> 00:59:18,250
是关于中断的另一个故事，
of the interrupt story that we'll

1627
00:59:18,250 --> 00:59:19,480
我们会在下周讨论，
talk about next week,

1628
00:59:19,480 --> 00:59:21,490
所以有多个设备可以生成中断，
so there's multiple devices can generate

1629
00:59:21,490 --> 00:59:22,930
需要计划将
interrupts there needs to be planned

1630
00:59:22,930 --> 00:59:24,850
这些中断路由到
to route those interrupts to the

1631
00:59:24,850 --> 00:59:26,860
适当的请求级别，
to the appropriate request level and

1632
00:59:26,860 --> 00:59:28,960
这都是由中断控制器
it's all implemented by those

1633
00:59:28,960 --> 00:59:30,140
实现的。
interrupt controllers.

1634
00:59:30,510 --> 00:59:32,160
在回答问题之前，
And let me finish for

1635
00:59:32,160 --> 00:59:33,210
让我把这个说完，
a second you know this,

1636
00:59:33,210 --> 00:59:34,660
你知道，
this slide before

1637
00:59:34,780 --> 00:59:35,920
就是这张张幻灯片。
answering question.

1638
00:59:35,920 --> 00:59:38,500
然后有一个
Then there's a uart

1639
00:59:38,500 --> 00:59:39,880
UART 设备，
that was the device,

1640
00:59:39,880 --> 00:59:42,500
这实际上是
that was actually the thing that actually,

1641
00:59:42,630 --> 00:59:44,640
UART 设备与
the device actually UART device actually

1642
00:59:44,640 --> 00:59:46,140
控制台和显示器交互，
interacts with the console and the

1643
00:59:46,140 --> 00:59:48,300
然后是
display and then there's the VIRTIO

1644
00:59:48,300 --> 00:59:49,320
VIRTIO 磁盘.
there's the disk.

1645
00:59:49,510 --> 00:59:51,790
这就是设备，
And that's the device,

1646
00:59:51,790 --> 00:59:53,080
它属于，
there's a device belong,

1647
00:59:53,080 --> 00:59:54,800
它实际上是与磁盘交互的。
it's that actually interacts with the disk.

1648
00:59:54,870 --> 00:59:56,490
所以当你
And so when you write to

1649
00:59:56,490 --> 00:59:58,680
往地址写入时，比如，
location to address, let's say,

1650
00:59:58,790 --> 01:00:01,610
0x200 ，然后
0x200 then

1651
01:00:01,610 --> 01:00:03,170
该物理地址
that physical address corresponds to the

1652
01:00:03,170 --> 01:00:04,430
对应于 CLINT ，因此你想要
CLINT and so do you want

1653
01:00:04,430 --> 01:00:05,450
执行存储指令
to do store instruction,

1654
01:00:05,450 --> 01:00:06,380
加载指令
load instruction,

1655
01:00:06,380 --> 01:00:09,530
对实现 CLINT 的芯片
your reading and writing to the

1656
01:00:09,530 --> 01:00:12,480
进行读取和写入。
chip that implements the CLINT.

1657
01:00:13,190 --> 01:00:14,480
我们稍后会看到
We'll see later what that exactly

1658
01:00:14,480 --> 01:00:15,890
这到底意味着什么，
means but basically you can think

1659
01:00:15,890 --> 01:00:17,600
但你可以认为
about this as interacting directly with

1660
01:00:17,600 --> 01:00:18,860
这是直接与设备交互，
the device and not reading or

1661
01:00:18,860 --> 01:00:20,020
而不是读或写物理内存。
writing physical memory.

1662
01:00:21,780 --> 01:00:22,900
是的，我有个问题。
Yeah there's a question.

1663
01:00:24,230 --> 01:00:25,760
我只是想确认
So just trying to make

1664
01:00:25,760 --> 01:00:29,450
0x800 以下的地址
sure the addresses below

1665
01:00:29,450 --> 01:00:33,480
并不存在于 DRAM 中。
0x800, they don't really exist in DRAM.

1666
01:00:33,660 --> 01:00:35,220
如果我们访问这些地址时，
If when we mention those addresses

1667
01:00:35,220 --> 01:00:37,200
我们会直接访问其他硬件。
we directly go to the other hardwares.

1668
01:00:37,200 --> 01:00:38,070
是的，
Yeah yeah,

1669
01:00:38,070 --> 01:00:40,280
所以如果你回到这张照片。
so if you go back to this picture.

1670
01:00:40,330 --> 01:00:42,010
任何大于
Anything of above

1671
01:00:42,010 --> 01:00:43,160
0x8000 的，
0x8000, correct，

1672
01:00:45,330 --> 01:00:46,840
这些就是 DRAM 芯片。
That's these DRAM chips.

1673
01:00:48,020 --> 01:00:49,670
你知道我画不出，
And you know I can't

1674
01:00:49,670 --> 01:00:50,780
我不能给你
draw, I can't point you

1675
01:00:50,780 --> 01:00:51,590
指出 CLINT ，
to the CLINT,

1676
01:00:51,590 --> 01:00:53,680
但我一般都听说过的，
but like generally hears that,

1677
01:00:53,770 --> 01:00:55,020
比如以太网。
ethernet.

1678
01:00:55,980 --> 01:00:57,480
这是一个特定的
And so that's a particular physical

1679
01:00:57,480 --> 01:00:58,830
物理地址，
address and we can write you

1680
01:00:58,830 --> 01:01:00,570
我们可以写入加载存储指令，
know load store instructions is called

1681
01:01:00,570 --> 01:01:01,830
也称为内存映射 IO ，
memory mapped IO,

1682
01:01:01,830 --> 01:01:03,450
我们可以加载和存储指令，
we can load and store instructions,

1683
01:01:03,450 --> 01:01:05,520
我们可以对以太网控制器编程。
we can program ethernet controller.

1684
01:01:09,340 --> 01:01:10,840
我也有一个问题，
I also have a question,

1685
01:01:10,840 --> 01:01:13,480
为什么上面的这一大块
why was this big chunk at

1686
01:01:13,480 --> 01:01:15,300
写着没有使用。
the top says unused.

1687
01:01:15,480 --> 01:01:18,630
为什么没有使用。好的，
Why is it not used. OK,

1688
01:01:18,630 --> 01:01:19,470
记住，
so remember,

1689
01:01:19,470 --> 01:01:21,930
不是每台机器都有
not every machine not

1690
01:01:21,930 --> 01:01:24,880
2 的 56 次方字节的
every so there's 2 to the power 56,

1691
01:01:25,190 --> 01:01:27,770
物理地址空间，
bytes physical address space,

1692
01:01:27,770 --> 01:01:29,300
如果你不想的话，
but you don't have those,

1693
01:01:29,300 --> 01:01:30,830
你不需要
you know, plug in that much memory

1694
01:01:30,830 --> 01:01:31,550
那么多内存
into the board,

1695
01:01:31,550 --> 01:01:32,560
插到电路板上。
if you don't want to.

1696
01:01:32,940 --> 01:01:34,170
所以，它的一些部分
And so some parts of it

1697
01:01:34,170 --> 01:01:36,150
可能是未使用的，
may be unused, depending on how

1698
01:01:36,150 --> 01:01:37,710
这取决于你在电路板上
much you're DRAM chips are sitting

1699
01:01:37,710 --> 01:01:38,480
有多少 DRAM 芯片。
on the board.

1700
01:01:42,300 --> 01:01:44,220
事实上，在 xv6 中，
In fact, they like in xv6,

1701
01:01:44,220 --> 01:01:46,590
我想我们把内存限制在
we I think limit ourselves to

1702
01:01:46,590 --> 01:01:48,840
128 兆字节。
128 megabyte.

1703
01:01:50,440 --> 01:01:51,380
仅此而已。
And no more.

1704
01:01:55,370 --> 01:01:58,970
那么，
So when a, when a

1705
01:01:58,970 --> 01:02:01,280
当加载存储指令
load store instruction goes out of

1706
01:02:01,280 --> 01:02:04,640
从 CPU 发出时，会不会发生，
the CPU, does that go,

1707
01:02:04,880 --> 01:02:06,800
比如它从哪里
like where does it get

1708
01:02:06,800 --> 01:02:08,600
路由到正确的 IO ，
routed to the correct IO, like

1709
01:02:08,600 --> 01:02:10,160
比如已经从 CPU
already from the CPU,

1710
01:02:10,160 --> 01:02:11,870
路由到正确的 IO ，
so kind of like if the

1711
01:02:11,870 --> 01:02:13,580
在 CPU 发出指令之前，
CPU before it sends it out

1712
01:02:13,580 --> 01:02:14,120
它保证
it says OK,

1713
01:02:14,120 --> 01:02:17,900
如果小于 0x8000 ，
if it's lower than 0x8 and all the zeros then

1714
01:02:17,900 --> 01:02:19,100
那么我会将其
I'm going to send it to

1715
01:02:19,100 --> 01:02:20,330
发送到正确的 IO 设备，
the correct IO devices,

1716
01:02:20,330 --> 01:02:21,320
否则我会
and then otherwise I'm going to

1717
01:02:21,320 --> 01:02:24,380
将其发送给内存，
send it to the to the

1718
01:02:24,380 --> 01:02:26,760
比如 DRAM 芯片。
memory like DRAM chip.

1719
01:02:27,030 --> 01:02:28,200
是的，你可以把它想象成
Yeah, you can think about as

1720
01:02:28,200 --> 01:02:29,760
一个安装在 RISC-V 内部的
a demultiplexer sitting on the

1721
01:02:29,760 --> 01:02:31,710
多路分解器，
inside of the RISC-V, you

1722
01:02:31,710 --> 01:02:33,160
你知道，块。
know block.

1723
01:02:33,240 --> 01:02:34,110
哦，那么它已经在
Oh, so it's inside of

1724
01:02:34,110 --> 01:02:35,380
那个块里面了。好的。
that block. OK.

1725
01:02:38,150 --> 01:02:41,480
作为存储控制器并进行路由。
As a memory controller and does routing.

1726
01:02:44,700 --> 01:02:46,080
因为非常重要，
Because very important to have

1727
01:02:46,080 --> 01:02:47,780
你要把这一切都弄清楚。
that sort of all clear in your head.

1728
01:02:51,420 --> 01:02:51,960
还好吗，
Are you okay,

1729
01:02:51,960 --> 01:02:52,740
现在我想
so now I want to

1730
01:02:52,740 --> 01:02:55,460
换到这张图片的右边。
switch to the right side of this picture.

1731
01:02:55,610 --> 01:02:57,080
这就是 xv6
And this is basically what

1732
01:02:57,080 --> 01:03:00,140
设置的，
xv6 sets up, to

1733
01:03:00,140 --> 01:03:01,520
虚拟地址空间，
the virtual address space, that

1734
01:03:01,520 --> 01:03:02,540
xv6 设置，
xv6 setup,

1735
01:03:02,540 --> 01:03:04,910
所以当机器启动时，
so when the machine boot, there's

1736
01:03:04,910 --> 01:03:06,740
还没有页面可用，
no page enable yet,

1737
01:03:06,740 --> 01:03:08,570
xv6 设置了
xv6 sets up

1738
01:03:08,570 --> 01:03:11,690
第一个页表，
the first page tables, virtual

1739
01:03:11,690 --> 01:03:12,830
虚拟地址空间，
address space and that's actually

1740
01:03:12,830 --> 01:03:13,580
这实际上是内核使用的
the virtual address space

1741
01:03:13,580 --> 01:03:14,900
虚拟地址空间，
the kernel uses and we'll look

1742
01:03:14,900 --> 01:03:16,000
我们稍后会看到它。
at it in the second.

1743
01:03:16,050 --> 01:03:17,850
在代码中，
At the code, but,

1744
01:03:17,850 --> 01:03:19,440
这就是布局，
and this is the layout

1745
01:03:19,440 --> 01:03:21,460
你知道，
and it turns out, you know,

1746
01:03:21,460 --> 01:03:22,750
因为我们想让 xv6
because we want to keep

1747
01:03:22,750 --> 01:03:24,160
尽可能简单，
xv6 as simple as possible,

1748
01:03:24,160 --> 01:03:26,020
让你很容易理解。
it's easy for you to understand.

1749
01:03:25,990 --> 01:03:29,680
从虚拟到物理的映射。
The mapping from virtual to physical

1750
01:03:30,780 --> 01:03:32,700
主要是恒等映射。
is mostly in identity mapping.

1751
01:03:38,110 --> 01:03:39,490
这意味着
So basically what that means is

1752
01:03:39,490 --> 01:03:42,700
虚拟地址 0x200
that the virtual address 0x200

1753
01:03:43,180 --> 01:03:45,160
映射到物理地址 0x200 ，
maps to physical address

1754
01:03:45,160 --> 01:03:47,080
内核将
0x200, the kernel

1755
01:03:47,080 --> 01:03:48,400
完全按照这种方式
will set up the page tables

1756
01:03:48,400 --> 01:03:49,870
设置页表，
exactly in that way,

1757
01:03:49,870 --> 01:03:51,670
这意味着
and so that means basically that

1758
01:03:51,670 --> 01:03:53,200
此顶部下面的
you know all virtual addresses,

1759
01:03:53,200 --> 01:03:54,980
所有虚拟地址。
below this top.

1760
01:03:55,840 --> 01:03:56,740
这是物理内存的
Which is the top of

1761
01:03:56,740 --> 01:03:59,170
顶部，与右侧
physical memory are identical to the

1762
01:03:59,170 --> 01:04:00,730
实际使用的物理地址
physical addresses that are actually being

1763
01:04:00,730 --> 01:04:02,800
相同。
used on the right side.

1764
01:04:03,150 --> 01:04:04,260
这就是为什么
And so this is why all

1765
01:04:04,260 --> 01:04:06,210
所有的箭头都是直的，
the arrows are straight, because it's

1766
01:04:06,210 --> 01:04:07,460
因为这是恒等映射。
identity mapping.

1767
01:04:10,830 --> 01:04:13,440
对于这一点的小的变化，
The small changes to this,

1768
01:04:14,560 --> 01:04:16,900
有两件重要的事情要提。
there are two important things to mention.

1769
01:04:17,610 --> 01:04:20,370
Amiar ，稍等一下，
Amiar, hold on a second, while

1770
01:04:20,370 --> 01:04:21,810
我先说一下
try to first mention the two

1771
01:04:21,810 --> 01:04:23,300
这两件重要的事情。
important things to mention.

1772
01:04:23,500 --> 01:04:25,090
首先，
First of all,

1773
01:04:25,090 --> 01:04:26,800
有一些页面，
there's some pages,

1774
01:04:26,800 --> 01:04:28,300
一些映射在
some maps very high up in

1775
01:04:28,300 --> 01:04:29,080
内存中非常高。
your memory.

1776
01:04:32,550 --> 01:04:34,320
其中一些页面在内存中的
Which some pages very high

1777
01:04:34,320 --> 01:04:35,040
位置非常高，
up in memory,

1778
01:04:35,040 --> 01:04:38,550
例如内核堆栈
for example the stack a

1779
01:04:38,550 --> 01:04:40,470
实际也映射到
kernel stack actually sits up is

1780
01:04:40,470 --> 01:04:42,280
内存位置较高的位置。
also map high up in memory.

1781
01:04:42,450 --> 01:04:43,590
内存较高的原因
And the reason is high

1782
01:04:43,590 --> 01:04:44,880
是因为我们在
up in memory is because we

1783
01:04:44,880 --> 01:04:46,320
它下面有一个
have a guard page below it

1784
01:04:46,320 --> 01:04:47,500
未映射的保护页。
that is not mapped.

1785
01:04:47,770 --> 01:04:49,540
因此，
So the PTE entry below

1786
01:04:49,540 --> 01:04:51,280
内核堆栈下面的
the kernel stack, of one of

1787
01:04:51,280 --> 01:04:52,720
PTE条目，
the kernel stack [], does

1788
01:04:52,720 --> 01:04:55,380
没有设置有效位。
have, not have it's valid bit set.

1789
01:04:55,660 --> 01:04:58,360
而且，如果内核
And, so if you know, the kernel

1790
01:04:58,360 --> 01:05:00,100
在堆栈之外运行，
runs off its stack and will

1791
01:05:00,100 --> 01:05:01,840
会导致页面错误，
result in a page fault,

1792
01:05:01,840 --> 01:05:04,060
这比在内核拥有的
which is better than basically scribbling

1793
01:05:04,060 --> 01:05:05,140
其他内存上乱涂乱画
over some other memory that the

1794
01:05:05,140 --> 01:05:06,020
要好得多。
kernel has.

1795
01:05:06,080 --> 01:05:07,220
你会直接得到异常，
You get immediate panic,

1796
01:05:07,220 --> 01:05:09,020
你知道有些东西堆积起来是不好的。
you know that something's bad to stack.

1797
01:05:09,680 --> 01:05:11,540
当然，我们不想
Of course, we don't want

1798
01:05:11,540 --> 01:05:13,580
浪费物理内存，
to waste physical memory and so

1799
01:05:13,580 --> 01:05:15,080
所以当我们这样做的时候，
when we do that by basically

1800
01:05:15,080 --> 01:05:18,890
基本上是把堆栈放得很高，
putting the stack high, um,

1801
01:05:18,890 --> 01:05:20,690
在它下面放一个保护页，
a guard page, an empty guard

1802
01:05:20,690 --> 01:05:22,280
一个空的保护 PTE 条目。
PTE entry below it.

1803
01:05:22,520 --> 01:05:24,590
而且守卫页面
And the guard page

1804
01:05:24,590 --> 01:05:26,450
实际上并不会消耗任何物理内存，
doesn't really consume any physical memory

1805
01:05:26,450 --> 01:05:27,560
它位于
records sitting high up in the

1806
01:05:27,560 --> 01:05:28,400
虚拟地址空间高处，
virtual address space,

1807
01:05:28,400 --> 01:05:30,620
所以没有消耗任何东西。
so nothing is being consumed.

1808
01:05:31,190 --> 01:05:32,570
但这意味着，在这种情况下
But that means that they're showing

1809
01:05:32,570 --> 01:05:33,560
堆栈页面
this case, stack page,

1810
01:05:33,560 --> 01:05:35,140
被映射了两次。
for example is mapped twice.

1811
01:05:35,360 --> 01:05:36,230
它被映射到一个
It's mapped at a high

1812
01:05:36,230 --> 01:05:38,660
很高的地址，也被直接映射到
address and it's mapped directly

1813
01:05:38,660 --> 01:05:40,010
一个 PHYSTOP
by one of the dresses

1814
01:05:40,010 --> 01:05:41,300
下面的地址。
that below PHYSTOP.

1815
01:05:42,590 --> 01:05:43,760
所以你可以这样做，
And so you can do, this

1816
01:05:43,760 --> 01:05:45,290
这是你可以用
is one example of all the

1817
01:05:45,290 --> 01:05:46,970
页表来做的
sort of cool things, you can

1818
01:05:46,970 --> 01:05:48,230
很酷的事情的一个例子，
do with page tables,

1819
01:05:48,230 --> 01:05:50,480
你可以映射一个物理地址两次，
you can map a physical address twice,

1820
01:05:50,480 --> 01:05:52,610
你可以不映射一个物理地址，
you cannot map a physical address,

1821
01:05:52,610 --> 01:05:53,930
你知道
you know it can be

1822
01:05:53,930 --> 01:05:55,160
可以是一对一映射，
one to one mapping, one to

1823
01:05:55,160 --> 01:05:56,900
一对多映射，多对一映射，
many mapping, many to one mapping,

1824
01:05:56,900 --> 01:05:58,560
所有这些事情都是可能的。
all that kind of stuff is possible.

1825
01:05:58,930 --> 01:06:01,030
实际上它用的很多，
Actually it does really use

1826
01:06:01,030 --> 01:06:01,930
有几个地方
many of them, but there's a

1827
01:06:01,930 --> 01:06:03,760
我们用到了这些技巧。
couple places we use those tricks.

1828
01:06:03,880 --> 01:06:05,110
保护页面中的堆栈
And there's the stack in

1829
01:06:05,110 --> 01:06:06,070
就是一个例子，
the guard page is one

1830
01:06:06,070 --> 01:06:06,910
这是 xv6 用来
example, of one of the

1831
01:06:06,910 --> 01:06:09,280
跟踪 bug 的
cool trick then xv6 uses

1832
01:06:09,280 --> 01:06:11,020
一个很酷的技巧。
mostly to track down bugs.

1833
01:06:12,880 --> 01:06:13,720
我想提的第二件事
The second thing I wanted to

1834
01:06:13,720 --> 01:06:15,920
是权限。
mention is that, the permissions.

1835
01:06:16,570 --> 01:06:18,550
例如内核文本，
So, for example the kernel text,

1836
01:06:18,550 --> 01:06:19,720
内核文本的页面
the pages for the kernel text

1837
01:06:19,720 --> 01:06:22,420
被映射为 R-X ，这意味着
are mapped R-X, meaning you can

1838
01:06:22,420 --> 01:06:23,780
你可以读取并执行它。
read it and execute it.

1839
01:06:23,780 --> 01:06:24,890
但是你不能写入内核文本，
But you cannot write to

1840
01:06:24,890 --> 01:06:26,150
同样，
kernel text and again this

1841
01:06:26,150 --> 01:06:27,500
这个位是空的。
is basically devoid,

1842
01:06:27,530 --> 01:06:28,730
我们尽早捕捉到 bug ，
[bugs] we catch

1843
01:06:28,730 --> 01:06:30,650
内核数据当然
them early, kernel data of course

1844
01:06:30,650 --> 01:06:31,610
需要能够被写入，
needs to be able to be

1845
01:06:31,610 --> 01:06:33,110
所以
written to, and so it has

1846
01:06:33,110 --> 01:06:34,250
它映射了读写，
mapped read write,

1847
01:06:34,250 --> 01:06:36,060
但是你不能执行
but you cannot execute

1848
01:06:36,130 --> 01:06:39,880
内核数据页的指令。
out of kernel data pages instructions.

1849
01:06:40,680 --> 01:06:42,680
所以执行位没有设置。
So the execute bit is not set.

1850
01:06:45,960 --> 01:06:47,040
这个能理解吗？
Does that make sense.

1851
01:06:48,010 --> 01:06:50,020
我跳过了一两个问题，
I skipped one or two questions,

1852
01:06:50,020 --> 01:06:51,280
如果这些问题还没有回答，
so if these questions are still

1853
01:06:51,280 --> 01:06:53,080
现在可以提问。
not answered, please ask them.

1854
01:06:55,790 --> 01:06:58,460
我们在聊天中有一个问题。
We have a question in the chat.

1855
01:06:58,460 --> 01:07:00,320
我们是否有
Do we have multiple kernel stacks

1856
01:07:00,320 --> 01:07:02,240
多个内核堆栈用于不同的进程，比如
for different processes like we have

1857
01:07:02,240 --> 01:07:04,560
n 个 kstack 用于 n 个进程。
n kstacks for n processes.

1858
01:07:04,640 --> 01:07:05,960
答案是肯定的。
And answers yes.

1859
01:07:06,850 --> 01:07:08,860
因此，每个进程，每个用户进程
So every process every user process

1860
01:07:08,860 --> 01:07:10,820
都有一个对应的内核堆栈。
has a corresponding kernel stack.

1861
01:07:13,130 --> 01:07:14,030
稍后我会
I will see that in a

1862
01:07:14,030 --> 01:07:14,960
看到这一点。
little bit later.

1863
01:07:19,220 --> 01:07:20,660
好的，那么让我，
Okay, so let me,

1864
01:07:20,660 --> 01:07:22,500
Samir ，说吧。
Samir, go ahead.

1865
01:07:23,350 --> 01:07:26,080
那么另一个应用程序的
So what's the virtual memory

1866
01:07:26,080 --> 01:07:28,420
虚拟内存映射到
of another application

1867
01:07:28,720 --> 01:07:30,130
物理内存中
map to somewhere in the physical

1868
01:07:30,130 --> 01:07:32,440
未使用的空间或。
memory in the unused space or.

1869
01:07:32,440 --> 01:07:34,540
是的，一个非常好的观点，
Yes, a very good point,

1870
01:07:34,540 --> 01:07:36,730
所以有一堆
so there's a bunch of

1871
01:07:36,730 --> 01:07:37,240
物理内存，
physical memory,

1872
01:07:37,240 --> 01:07:38,800
是的，这是空闲内存。
correct, here's free memory.

1873
01:07:39,340 --> 01:07:41,230
这里也有
Um, that's free memory

1874
01:07:41,230 --> 01:07:43,780
空闲内存，对，
here too, right, and

1875
01:07:43,780 --> 01:07:45,310
我们使用
we use that actually use

1876
01:07:45,310 --> 01:07:46,720
这些空闲内存来
that free memory to basically

1877
01:07:46,720 --> 01:07:48,790
存储页表的页面，
store pages of page tables,

1878
01:07:48,790 --> 01:07:51,190
用户进程，以及
user processes as well as you

1879
01:07:51,190 --> 01:07:53,440
用户进程的
know the text and data of

1880
01:07:53,440 --> 01:07:54,720
文本和数据。
user level processes.

1881
01:07:55,790 --> 01:07:56,900
如果我们在
And if we are on many many,

1882
01:07:56,900 --> 01:07:58,490
很多用户进程上，
many user processes at some point

1883
01:07:58,490 --> 01:07:59,690
在某个时候我们会用完空闲内存，
we'll run out of free memory,

1884
01:07:59,690 --> 01:08:01,520
然后 fork 或 exec
and then basically fork or exec

1885
01:08:01,520 --> 01:08:03,480
会返回一个错误。
will return an error.

1886
01:08:04,900 --> 01:08:05,770
但这意味着
But that means that the

1887
01:08:05,770 --> 01:08:08,620
进程的虚拟空间
virtual space for processes are

1888
01:08:08,620 --> 01:08:09,850
比内核的虚拟空间
much smaller than the virtual

1889
01:08:09,850 --> 01:08:12,240
小得多，是吗？
space for the kernel, right?

1890
01:08:12,500 --> 01:08:14,000
虚拟空间的大小
Well, the virtual spaces as

1891
01:08:14,000 --> 01:08:17,150
理论上是一样的，
the same as the same size in principle,

1892
01:08:17,150 --> 01:08:19,340
但是会比较少。
but it will be less populated.

1893
01:08:22,520 --> 01:08:24,200
然后让我们来
Then let me let's look at

1894
01:08:24,200 --> 01:08:24,560
看一些代码，
some code,

1895
01:08:24,560 --> 01:08:25,280
我认为所有这些东西
and I think that all this

1896
01:08:25,280 --> 01:08:26,720
都会变得更清楚。
stuff becomes a bit more clear.

1897
01:08:27,690 --> 01:08:29,280
我有个小问题，
I just want small thing,

1898
01:08:29,280 --> 01:08:34,020
有很多，比如
is so given that a lot of the like,

1899
01:08:34,020 --> 01:08:35,610
每个进程都有
each process has a big part

1900
01:08:35,610 --> 01:08:37,080
很大一部分内存
of the memory map to the

1901
01:08:37,080 --> 01:08:39,810
映射到相同的位置，是否可以通过
same location, is that optimized by

1902
01:08:39,810 --> 01:08:42,720
将其合并到一个映射的位置
like consolidating that into one place

1903
01:08:42,720 --> 01:08:44,180
进行优化。
that mapping or no.

1904
01:08:44,280 --> 01:08:46,050
嗯，这很好，
Um, it's good,

1905
01:08:46,050 --> 01:08:47,370
xv6 没有做这个，
xv6 does not do that,

1906
01:08:47,370 --> 01:08:48,990
比如 page table 实验中的
like one of the challenge

1907
01:08:48,990 --> 01:08:51,210
挑战练习之一
exercises in the page table lab

1908
01:08:51,210 --> 01:08:52,640
就是实现它。
is to actually implement that.

1909
01:08:54,510 --> 01:08:56,130
我明白了。真正的操作系统
I see. The real operating system

1910
01:08:56,130 --> 01:08:56,920
会做到这一点。
would do that.

1911
01:08:58,710 --> 01:09:00,240
嗯。了解了。
Yeah. Makes sense.

1912
01:09:00,240 --> 01:09:01,220
问得好。
Very good question.

1913
01:09:02,380 --> 01:09:03,220
我想一旦你有了页表，
I think you get a sense

1914
01:09:03,220 --> 01:09:04,240
你就会明白
of what all kinds of things

1915
01:09:04,240 --> 01:09:06,120
什么事情都是可能的。
are possible, once you have page tables.

1916
01:09:08,790 --> 01:09:09,780
好的，
Okay,

1917
01:09:09,780 --> 01:09:11,490
让我们开始常做的事，
so let's do the usual thing,

1918
01:09:12,640 --> 01:09:15,370
再一次启动 xv6 ，
boot xv6 again and again,

1919
01:09:15,370 --> 01:09:16,900
你知道 QEMU 用来
you know QEMU uses basically implementing

1920
01:09:16,900 --> 01:09:17,780
模拟电路板。
the board.

1921
01:09:18,170 --> 01:09:28,260
让我们，糟糕， -gdb ，
And you know let's. Oops, -gdb,

1922
01:09:29,930 --> 01:09:31,880
上一次我们看了
last time we looked at

1923
01:09:31,880 --> 01:09:33,710
路由是如何
how the routing happens correct

1924
01:09:33,710 --> 01:09:34,310
发生的，
and then we got to

1925
01:09:34,310 --> 01:09:35,510
然后我们到了 main ，
main and then basically one

1926
01:09:35,510 --> 01:09:38,650
然后是内核，
of the things that, the kernel,

1927
01:09:38,650 --> 01:09:41,380
其中一个函数 kvminit ，
when one of the functions called

1928
01:09:41,380 --> 01:09:42,670
它实际上为内核
kvminit and that actually

1929
01:09:42,670 --> 01:09:44,820
设置了地址空间。
sets up the address space for the kernel.

1930
01:09:45,100 --> 01:09:46,330
我们在上一张幻灯片的
And so we saw in the

1931
01:09:46,330 --> 01:09:47,740
图片中看到，
picture where in the previous slide,

1932
01:09:47,740 --> 01:09:49,330
你知道，
what that you know looks like

1933
01:09:49,330 --> 01:09:50,200
现在我们开始，
and here we go,

1934
01:09:50,200 --> 01:09:52,580
C 编码是如何实际设置的。
C code how it actually is being set up.

1935
01:09:58,380 --> 01:10:01,500
还有为什么，等等，
And why, hold on, something's

1936
01:10:01,500 --> 01:10:03,980
有些东西没像我想的那样。
not going as I wanted to.

1937
01:10:04,380 --> 01:10:07,100
我找对目录了吗？
Am I the right directories.

1938
01:10:11,140 --> 01:10:12,130
等一下，
Hold on a second here

1939
01:10:12,130 --> 01:10:13,180
我正在想办法
while I'm trying to sort

1940
01:10:13,180 --> 01:10:14,720
解决我的问题。
out my problems.

1941
01:10:16,590 --> 01:10:17,940
那很好。
That is good.

1942
01:10:21,390 --> 01:10:23,070
我的意思是正确的目录，
I mean the right directory,

1943
01:10:23,070 --> 01:10:28,710
是的，我们想在
yeah, We want to set a

1944
01:10:28,710 --> 01:10:29,670
main 设置一个中断，
break from the main just

1945
01:10:29,670 --> 01:10:30,960
为了确保。
to make sure.

1946
01:10:31,050 --> 01:10:35,940
很好，然后是 kvminit 的中断点。
Good, and then a break point at kvminit.

1947
01:10:36,340 --> 01:10:37,300
实际上我现在可以
Actually I can just step to

1948
01:10:37,300 --> 01:10:40,540
单步运行它了，下一个是 consoleinit
it now, next consoleinit

1949
01:10:40,540 --> 01:10:41,050
printfinit，
printfinit,

1950
01:10:41,050 --> 01:10:42,760
你知道，我们之前已经看到了，
you know, we saw it before,

1951
01:10:43,250 --> 01:10:45,320
物理内存分配器。
physical memory allocator.

1952
01:10:51,100 --> 01:10:52,720
你知道吗，发生了一些
You know, something happens that I

1953
01:10:52,720 --> 01:10:55,200
我意想不到的事情。
not expecting.

1954
01:10:57,590 --> 01:10:59,840
这是怎么回事。
What is going on.

1955
01:11:02,590 --> 01:11:03,970
我们在讲课前运行是正确的。
We're gonna run this right before

1956
01:11:03,970 --> 01:11:04,900
这里，
lecture. Here,

1957
01:11:04,900 --> 01:11:06,700
这就是实际打印的情况，
that's what's going on actually printing,

1958
01:11:06,700 --> 01:11:08,220
好的。
Okay.

1959
01:11:10,330 --> 01:11:11,620
有意思。
Interesting.

1960
01:11:11,620 --> 01:11:12,460
好吧，再来一次，
Okay one more time,

1961
01:11:12,460 --> 01:11:15,840
看看我会不会更幸运[]。
see if I can get lucky more [].

1962
01:11:19,270 --> 01:11:20,920
非常好。
Very good.

1963
01:11:28,910 --> 01:11:32,140
继续，希望它能到达那里，
Continue, hopefully it will get there,

1964
01:11:33,010 --> 01:11:34,210
稍等片刻。很好，
wait a little bit. Okay great

1965
01:11:34,210 --> 01:11:35,860
我们在 kvminit ，
we're at the kvminit,

1966
01:11:35,860 --> 01:11:37,390
所以现在这个函数，
so basically we're now this function

1967
01:11:37,390 --> 01:11:39,220
在 emacs 缓冲区的右边，
here, on the right side in

1968
01:11:39,220 --> 01:11:40,900
你可以看到它。
the emacs buffer, you can see it.

1969
01:11:41,280 --> 01:11:43,640
而且，
And,

1970
01:11:44,220 --> 01:11:46,380
我想我稍微修改了一下函数，
I think I've modified function

1971
01:11:46,380 --> 01:11:48,820
我希望我是这样做的。
slightly I hope I did.

1972
01:11:52,570 --> 01:11:53,980
我想我做过了，
I think I did, we'll

1973
01:11:53,980 --> 01:11:56,890
我们拭目以待，
see, and what we knew

1974
01:11:56,890 --> 01:11:59,560
我们将进入函数。
is going to walk step into the function.

1975
01:12:00,080 --> 01:12:02,270
给我拆分布局，
Give me layout split it's

1976
01:12:02,270 --> 01:12:03,280
这样更容易看到。
easier to see.

1977
01:12:03,640 --> 01:12:04,630
你可以看到的
And this is the first thing

1978
01:12:04,630 --> 01:12:05,530
第一件事，是
that you can see, this section

1979
01:12:05,530 --> 01:12:06,640
当前的这一部分
of the current actually allocates a

1980
01:12:06,640 --> 01:12:08,470
实际上为顶级页面目录
physical page, for the top level

1981
01:12:08,470 --> 01:12:09,440
分配了一个物理页面。
page directory.

1982
01:12:10,090 --> 01:12:12,250
然后将其置零，
And then zeroes it

1983
01:12:12,250 --> 01:12:14,760
使得所有 PTE 条目都为零。
out so that all the PTE entries are zero.

1984
01:12:15,360 --> 01:12:17,490
然后开始在每个设备，
And then basically starts mapping in

1985
01:12:17,490 --> 01:12:21,280
IO 设备中逐个映射。
every device, IO device one by one.

1986
01:12:21,620 --> 01:12:23,990
例如， UART0 ，它开始
And so, for example, the UART0, it

1987
01:12:23,990 --> 01:12:25,820
将映射映射到
basically starts mapping maps that into

1988
01:12:25,820 --> 01:12:28,550
内核地址空间，
the kernel address space and so

1989
01:12:28,550 --> 01:12:29,960
我们可以看到一个
we can look at a file

1990
01:12:29,960 --> 01:12:32,840
名为 memlayout.h 的文件，
called memlayout.h, is basically translate

1991
01:12:32,840 --> 01:12:34,580
它将文档中展示的第 31 页
page 31 that I showed

1992
01:12:34,580 --> 01:12:35,930
转换成我们
you from the document into a

1993
01:12:35,930 --> 01:12:37,620
正在使用的一系列常量。
bunch of constants that we're using.

1994
01:12:38,010 --> 01:12:39,510
对于 UART0 ，这里是
And so, for example here it says what

1995
01:12:39,510 --> 01:12:42,700
地址 0x1000 。
the address of 0x1000 is.

1996
01:12:44,100 --> 01:12:46,800
嗯，你有什么想法。
Um, [do you ideas].

1997
01:12:47,100 --> 01:12:47,940
所以，
And so,

1998
01:12:47,940 --> 01:12:50,040
我们可以
you know, we can basically

1999
01:12:50,040 --> 01:12:52,110
通过调用
map it into the address space

2000
01:12:52,110 --> 01:12:53,760
这个函数 kvmmap
by calling this function

2001
01:12:53,760 --> 01:12:54,660
将其映射到地址空间，
kvmmap which I will look in

2002
01:12:54,660 --> 01:12:55,520
我稍后会看到这个函数。
a second.

2003
01:12:56,040 --> 01:12:57,000
然后，
And then,

2004
01:12:57,000 --> 01:13:00,390
在 page table 实验的
in the first exercise of

2005
01:13:00,390 --> 01:13:01,260
第一个练习中，
the page table lab,

2006
01:13:01,260 --> 01:13:02,700
要求你实现一个
you are asked to implement a

2007
01:13:02,700 --> 01:13:04,040
名为 vmprint 的函数。
function called vmprint.

2008
01:13:04,300 --> 01:13:06,400
我也实现了它，
Um, and I implemented it too,

2009
01:13:06,400 --> 01:13:07,900
我将调试它，
and I'm going to step over

2010
01:13:07,900 --> 01:13:09,520
我们将看到，
it and we'll see basically,

2011
01:13:09,720 --> 01:13:13,790
页表，内核页表，
page tables, kernel page table as it

2012
01:13:13,790 --> 01:13:15,350
它是在对 kvmmap 的
is set up after that one

2013
01:13:15,350 --> 01:13:16,700
一次调用之后设置的，
call to the kvmmap,

2014
01:13:16,700 --> 01:13:17,980
这是我要做的。
so I'm going to do that.

2015
01:13:18,250 --> 01:13:18,970
我们要打印
And we're going to print

2016
01:13:18,970 --> 01:13:19,780
一些东西。
out something.

2017
01:13:20,240 --> 01:13:20,750
我们要看一下
And so we're going to

2018
01:13:20,750 --> 01:13:22,160
这里的输出，
look a little bit of the output here,

2019
01:13:22,160 --> 01:13:23,420
这是页表，
so here's the page table that

2020
01:13:23,420 --> 01:13:24,140
它是
is the

2021
01:13:24,790 --> 01:13:28,030
顶层的物理地址，
physical address of the top level,

2022
01:13:28,030 --> 01:13:30,190
页面目录，
page directory,

2023
01:13:30,190 --> 01:13:31,240
实际上位于
so the thing that actually sits

2024
01:13:31,240 --> 01:13:33,980
satp 寄存器中。
in satp, or will sit in satp.

2025
01:13:34,600 --> 01:13:36,850
然后我们有了
And then we have

2026
01:13:36,850 --> 01:13:38,140
顶级页面的条目 0 ，
entry 0 of the top

2027
01:13:38,140 --> 01:13:40,030
其中有
level page really has one

2028
01:13:40,030 --> 01:13:41,880
一个 PTE 条目。
PTE entry in it.

2029
01:13:42,480 --> 01:13:45,300
那就是
And that is the contains

2030
01:13:45,300 --> 01:13:46,710
包含中级页表目录的
the physical address for the middle

2031
01:13:46,710 --> 01:13:48,200
物理地址。
level page table directory.

2032
01:13:48,600 --> 01:13:50,190
中间页面目录
The middle page level directory has

2033
01:13:50,190 --> 01:13:52,780
有一个条目，即 128 。
one entry namely 128.

2034
01:13:52,900 --> 01:13:53,950
它指向页表目录的底部，
And that points to the bottom

2035
01:13:53,950 --> 01:13:55,360
并且
of page table directory and the

2036
01:13:55,360 --> 01:13:56,800
底部的页表目录有
bottom page table directory has the

2037
01:13:56,800 --> 01:13:59,020
用于物理页面的条目。
entry then for the physical page.

2038
01:13:59,390 --> 01:14:00,110
你可以看到，
And you can see,

2039
01:14:00,110 --> 01:14:02,090
实际上，你知道
indeed that the physical address,

2040
01:14:02,090 --> 01:14:03,530
该底层的物理地址
you know for that bottom level

2041
01:14:03,530 --> 01:14:05,570
是 0x1000 ，
is 0x1000

2042
01:14:05,570 --> 01:14:07,680
对应于 UART0 。
corresponding to uart0.

2043
01:14:08,350 --> 01:14:11,080
对，虚拟地址
Right, so basically virtual address

2044
01:14:11,470 --> 01:14:13,300
1000 转换成
1000 translates

2045
01:14:13,300 --> 01:14:15,820
物理地址 1000 。
to physical address [1000].

2046
01:14:16,570 --> 01:14:18,700
我们可以再次确定，
We can sure double check,

2047
01:14:18,700 --> 01:14:20,920
这确实是合法的。
this is indeed all legit.

2048
01:14:21,010 --> 01:14:22,690
根据，
By,

2049
01:14:22,690 --> 01:14:28,330
我们取那个地址 0x10000000L ，
and let's take that address 0x100L

2050
01:14:28,330 --> 01:14:30,960
我们将右移 12 位。
and we're going to shift 12.

2051
01:14:31,700 --> 01:14:34,960
这应该是，
And that should be,

2052
01:14:35,160 --> 01:14:36,240
你知道的，
you know, that gives the top

2053
01:14:36,240 --> 01:14:38,600
得到最高级别的 27 位。
level 27 bits.

2054
01:14:39,070 --> 01:14:40,660
我们再右移 9 位，
We shifted 9,

2055
01:14:40,660 --> 01:14:43,360
所以我取 0x10000 ，
so I'm gonna take 0x100,

2056
01:14:43,970 --> 01:14:48,440
我们可以右移 9 位，
0x10000, and we can

2057
01:14:48,440 --> 01:14:50,920
并打印出来。
shift at 9, print that.

2058
01:14:53,000 --> 01:14:54,620
那就是 0x80 ，
And that is 0x80,

2059
01:14:54,620 --> 01:14:56,360
实际上把 0x80
and actually print 0x80

2060
01:14:56,360 --> 01:14:58,460
打印成一个十进制数字，
as a decimal number, it's

2061
01:14:58,460 --> 01:14:59,840
它将是 128 ，好的。
going to be 128, OK.

2062
01:15:02,330 --> 01:15:03,590
所以我们看到，
So we see actually sort of

2063
01:15:03,590 --> 01:15:04,640
实际上，你知道，
you know it all sort of

2064
01:15:04,640 --> 01:15:05,540
这一切都是有意义的。
makes sense.

2065
01:15:05,920 --> 01:15:07,390
我们还看到
We also see I printed out

2066
01:15:07,390 --> 01:15:08,650
这里打印出了标志位，
the flags here,

2067
01:15:08,650 --> 01:15:11,230
最下面的级别是
and you know the bottom

2068
01:15:11,230 --> 01:15:12,280
读取、写入和有效，
level has read,

2069
01:15:12,280 --> 01:15:16,920
因为 valid 是 1 。
write and valid, because valid is one.

2070
01:15:18,480 --> 01:15:19,740
有关于这个的问题吗？
Any questions about this.

2071
01:15:24,760 --> 01:15:26,960
好的，那么。
Okay, so.

2072
01:15:27,290 --> 01:15:30,080
内核继续
The kernel basically proceeds, you know

2073
01:15:30,080 --> 01:15:32,000
用这种方式
doing setting up the whole address

2074
01:15:32,000 --> 01:15:33,160
设置整个地址空间。
space in this way.

2075
01:15:33,810 --> 01:15:35,580
因此，我们
And, so we've called

2076
01:15:35,580 --> 01:15:37,740
为 VIRTIO 调用 kvmmap ，也为
kvmmap for VIRTIO, for the

2077
01:15:37,740 --> 01:15:39,100
CLINT ， PLIC 调用。
CLINT, for the PLIC.

2078
01:15:39,350 --> 01:15:42,320
映射内核文本，
Maps the kernel text, maps

2079
01:15:42,320 --> 01:15:44,480
映射内核内存或内核数据，
the kernel memory or kernel data,

2080
01:15:44,480 --> 01:15:45,830
然后映射 TRAMPOLINE 页，
and then the TRAMPOLINE page that

2081
01:15:45,830 --> 01:15:47,040
这个我们将在下周讨论。
we'll talk about next week.

2082
01:15:47,460 --> 01:15:48,780
实际上我们
And so in fact we

2083
01:15:48,780 --> 01:15:50,280
可以单步运行，
can single step through this and

2084
01:15:50,280 --> 01:15:52,290
然后看看最终的页面目录
then see what the final page

2085
01:15:52,290 --> 01:15:53,780
是什么样子。
directory looks like.

2086
01:15:55,610 --> 01:15:58,760
嗯，下一个，下一个。
Um, so next next next next.

2087
01:15:59,330 --> 01:16:01,190
基本上，设置 TRAMPOLINE ，
Basically, you know set the TRAMPOLINE,

2088
01:16:01,190 --> 01:16:02,030
现在我们要
so now we're going to print

2089
01:16:02,030 --> 01:16:03,860
打印完整的页表目录。
the complete page table directory.

2090
01:16:04,160 --> 01:16:07,430
我们看到
You know we see basically

2091
01:16:07,430 --> 01:16:11,680
很多 PTE 正在设置中。
lot of PTE is actually being setup.

2092
01:16:11,840 --> 01:16:13,310
我不会
And I'm not going to

2093
01:16:13,310 --> 01:16:14,870
详细讨论，
talk about in any detail,

2094
01:16:14,870 --> 01:16:16,610
但是您知道，基本上是
but you know basically fills

2095
01:16:16,610 --> 01:16:17,480
填充页目录
out the page

2096
01:16:17,920 --> 01:16:20,170
来实际创建
directory to actually create

2097
01:16:20,170 --> 01:16:21,730
虚拟映射，
virtual mapping that we

2098
01:16:21,730 --> 01:16:23,480
就像我们在上一张幻灯片中看到的那样。
basically saw on the previous slide.

2099
01:16:24,840 --> 01:16:26,010
我下一步要做的
When I expect what I

2100
01:16:26,010 --> 01:16:26,910
事情是
wanna do next is actually

2101
01:16:26,910 --> 01:16:28,160
更有趣的。
much more interesting.

2102
01:16:29,730 --> 01:16:31,080
是的，我要做的是。
Yeah I'm gonna.

2103
01:16:32,270 --> 01:16:33,350
是的，我想去这里，
Yeah I wanna go here,

2104
01:16:33,350 --> 01:16:34,730
实际上，我猜我可能
actually, I guess maybe I already

2105
01:16:34,730 --> 01:16:37,010
已经这样做了，第 21 行，
did this, were 21,

2106
01:16:37,010 --> 01:16:39,400
不，我在第 21 行，好的，单步执行一下。
no, I'm 21, okay so single step that.

2107
01:16:40,560 --> 01:16:41,430
好吧，那太糟糕了，
OK that's too bad, I

2108
01:16:41,430 --> 01:16:43,800
我已经过去了。但基本上是这样。
got past it. But basically,

2109
01:16:44,340 --> 01:16:47,840
让我再运行一遍。
let me, let me restart this.

2110
01:16:53,210 --> 01:16:57,320
我要在 kvminithart 的设置断点。
I wanna break point at kvminithart.

2111
01:17:00,580 --> 01:17:01,880
然后继续，
And continue,

2112
01:17:03,650 --> 01:17:06,020
我们现在在 kvminithart ，
are now here at kvminithart,

2113
01:17:06,020 --> 01:17:07,430
你可以看到，
and you see here,

2114
01:17:07,430 --> 01:17:09,470
我们正在写入
basically that we're writing the

2115
01:17:09,470 --> 01:17:10,310
satp 寄存器，
satp register,

2116
01:17:10,310 --> 01:17:11,450
所以基本上内核
so basically the kernel is going

2117
01:17:11,450 --> 01:17:14,600
将启用页表或
to enable page table or

2118
01:17:14,600 --> 01:17:15,740
硬件， MMU ，
the hard, MMU,

2119
01:17:15,740 --> 01:17:16,970
开始使用
to basically start using

2120
01:17:16,970 --> 01:17:18,740
我们刚刚设置的页表。
the page table that we just set up.

2121
01:17:19,470 --> 01:17:22,860
还有一个有趣的问题。
And one interesting question.

2122
01:17:23,350 --> 01:17:24,730
好的，再次切换到
Okay, so they do have layout

2123
01:17:24,730 --> 01:17:25,990
拆分布局，
split again,

2124
01:17:25,990 --> 01:17:27,340
所以，
So,

2125
01:17:27,760 --> 01:17:30,860
这里的某个地方将会，
somewhere here is going to be,

2126
01:17:31,320 --> 01:17:34,860
这是一条指令，
here's the instruction in,

2127
01:17:36,070 --> 01:17:39,700
在执行这条指令后，
so once, something really dramatic happens

2128
01:17:39,700 --> 01:17:41,480
发生了一些非常戏剧性的事情。
after executing this instruction.

2129
01:17:42,270 --> 01:17:44,850
是的，我完全可以
Um, let's say yeah I can

2130
01:17:44,850 --> 01:17:46,500
看到相同的指令，
see the same instruction exactly but

2131
01:17:46,500 --> 01:17:48,960
但是在这个范围内，
there's this this extent,

2132
01:17:48,960 --> 01:17:50,820
一旦执行了这条指令，
once this instruction is executed what

2133
01:17:50,820 --> 01:17:52,200
下一个要转换的地址
will happen with the next address

2134
01:17:52,200 --> 01:17:53,420
会发生什么。
that's being translated.

2135
01:17:58,310 --> 01:17:59,570
在我们
Well, at the point that

2136
01:17:59,570 --> 01:18:01,550
执行这条指令
we execute this instruction, before

2137
01:18:01,550 --> 01:18:02,810
之前，
executing this instruction,

2138
01:18:02,810 --> 01:18:04,550
还没有启用页表，
there's no page tables enabled yet

2139
01:18:04,550 --> 01:18:06,200
所以没有发生转换。
so no translation happens.

2140
01:18:06,410 --> 01:18:07,820
但是下一次，
But the next and then the

2141
01:18:07,820 --> 01:18:10,040
程序计数器更新为 4 。
program counter is updated by [4].

2142
01:18:10,240 --> 01:18:11,380
然后执行下一条指令，
And then the next instruction is

2143
01:18:11,380 --> 01:18:13,030
并且将使用
executed and the program counter will

2144
01:18:13,030 --> 01:18:15,060
虚拟页、页表存储器
be translated using the virtual page,

2145
01:18:15,290 --> 01:18:16,400
来转换程序计数器。
page table memory.

2146
01:18:17,140 --> 01:18:18,640
所以这是，
And so this is, you

2147
01:18:18,640 --> 01:18:19,750
思考这个问题的方式，
know, the ways to think about this,

2148
01:18:19,750 --> 01:18:21,500
这是一个激动人心的时刻。
this is a dramatic moment.

2149
01:18:21,630 --> 01:18:24,450
因为整个地址转换
Because basically the whole address translation,

2150
01:18:24,450 --> 01:18:25,500
都开始启用，
they started to enable and

2151
01:18:25,500 --> 01:18:26,910
每个地址都可能
every address needs no maybe

2152
01:18:26,910 --> 01:18:28,480
潜在会有所不同。
potentially something different.

2153
01:18:29,660 --> 01:18:31,370
因为在我们运行
Right, because before we're running your

2154
01:18:31,370 --> 01:18:32,240
物理地址之前，
physical addresses,

2155
01:18:32,240 --> 01:18:33,050
然后是页表，
then the page table,

2156
01:18:33,050 --> 01:18:34,310
还没有安装，
haven't install, and whatever is in

2157
01:18:34,310 --> 01:18:34,760
无论映射中有什么，
the mapping,

2158
01:18:34,760 --> 01:18:36,290
现在都有了
now there's now the new meaning

2159
01:18:36,290 --> 01:18:37,500
虚拟地址的新含义。
of a virtual address.

2160
01:18:38,680 --> 01:18:40,090
这就是它的工作原理，
And here's how this works

2161
01:18:40,090 --> 01:18:41,230
你知道，
out, you know, the fact that

2162
01:18:41,230 --> 01:18:42,820
这个实际工作是值得注意的，
this actually works out is remarkable

2163
01:18:42,820 --> 01:18:44,590
因为就像下一条指令一样，
because like the next instruction,

2164
01:18:44,590 --> 01:18:46,180
下一个值是一个虚拟地址，
the next value is a virtual

2165
01:18:46,180 --> 01:18:47,780
而不是一个物理地址。
address and not a physical address.

2166
01:18:49,000 --> 01:18:50,020
下一条指令是这个，
The next instruction is going to

2167
01:18:50,020 --> 01:18:52,300
是 0x80001110 。
be this, whatever 0x1110.

2168
01:18:52,750 --> 01:18:54,240
为什么这会成功呢。
And why does this work out.

2169
01:18:55,960 --> 01:18:57,130
原因是因为
And the reason works out is

2170
01:18:57,130 --> 01:18:58,270
内核已经设置好了，
because the kernel is setup,

2171
01:18:58,270 --> 01:19:00,460
我们可以标识页面映射。
we can identity page mapping. So,

2172
01:19:00,730 --> 01:19:03,760
因此，在我们启用虚拟分页硬件之后，
after we enable the virtual paging hardware,

2173
01:19:03,760 --> 01:19:05,740
我们知道这个转换器将再次
we actually know this translator will

2174
01:19:05,740 --> 01:19:07,540
转换为相同的物理地址，
translate again to the same physical

2175
01:19:07,540 --> 01:19:11,180
因此我们实际上将结束
address and so indeed we'll actually end up, you know,

2176
01:19:11,210 --> 01:19:13,430
执行写入指令，
executing the writing instruction, because that's

2177
01:19:13,430 --> 01:19:14,750
因为这正是
actually exactly the instruction,

2178
01:19:14,750 --> 01:19:16,490
虚拟硬件编程
the memory location that the virtual

2179
01:19:16,490 --> 01:19:17,700
所针对的指令和内存位置。
hardware is programmed for.

2180
01:19:19,110 --> 01:19:20,400
这个能理解吗？
So does this make sense.

2181
01:19:22,920 --> 01:19:25,560
同样，虚拟内存编程困难的
Again, one reason why programming virtual

2182
01:19:25,560 --> 01:19:27,570
一个原因是，
memory is difficult is because once

2183
01:19:27,570 --> 01:19:29,100
一旦执行了这些 satp 指令，
you execute one of these satp

2184
01:19:29,100 --> 01:19:31,410
你就在 satp 寄存器中
instructions you load a page table

2185
01:19:31,410 --> 01:19:35,040
加载了页表，
in the satp register, your world

2186
01:19:35,040 --> 01:19:36,320
你的世界就完全不同了。
completely changes.

2187
01:19:36,680 --> 01:19:38,720
现在，每个地址都会使用
And every address is now translated

2188
01:19:38,720 --> 01:19:40,520
你设置的页表进行转换。
with the page table, that you set up.

2189
01:19:41,540 --> 01:19:42,590
那么，如果页表设置不正确
And so what happens if the

2190
01:19:42,590 --> 01:19:44,320
会发生什么呢？
page table setup incorrectly.

2191
01:19:44,840 --> 01:19:47,280
你会怎么做，可能会发生什么。
What would you, what might happen.

2192
01:19:53,650 --> 01:19:54,960
有人想回答这个问题吗，
Anybody who wants to

2193
01:19:55,290 --> 01:19:56,790
或者在聊天中回答，
say that answered or answered in

2194
01:19:56,790 --> 01:19:58,120
可以等待。
the chat, you can wait.

2195
01:20:00,510 --> 01:20:02,520
你可以覆盖内核数据。
You could override kernel data.

2196
01:20:02,980 --> 01:20:04,240
是的，你可以覆盖内核数据，
Yeah you could overwrite kernel data

2197
01:20:04,240 --> 01:20:05,020
还有其他可能发生的事情，
what else could happen,

2198
01:20:05,020 --> 01:20:07,660
页面错误，
yeah page fault, you basically do,

2199
01:20:07,720 --> 01:20:10,030
映射可能是不正确的，
the mapping may be incorrect and

2200
01:20:10,030 --> 01:20:12,010
地址完全可以转换，
basically the address can be translated at all,

2201
01:20:12,010 --> 01:20:13,150
所以内核可以，
and so the kernel can, you

2202
01:20:13,150 --> 01:20:14,650
你知道，硬件不会这样做，
know, the hardware won't do it

2203
01:20:14,650 --> 01:20:16,620
通常内核会停顿和死机。
and usally the kernel there stops and panics.

2204
01:20:18,760 --> 01:20:20,020
这个能理解吗？
Does that make sense,

2205
01:20:20,020 --> 01:20:21,700
所以
so if you get a bug

2206
01:20:21,700 --> 01:20:23,020
如果您的页表中有 bug ，
in your page tables,

2207
01:20:23,530 --> 01:20:24,490
你会看到这些
you know you're going to see

2208
01:20:24,490 --> 01:20:28,020
错误或崩溃信息。
these are errors or crashes.

2209
01:20:28,720 --> 01:20:29,080
所以，
And so,

2210
01:20:29,080 --> 01:20:31,300
下一个实验，
one reason that example, the next lab,

2211
01:20:31,300 --> 01:20:32,470
今晚分发或发布的
that page table lab, that

2212
01:20:32,470 --> 01:20:34,570
page table 实验，
will hand out or release tonight,

2213
01:20:34,570 --> 01:20:35,980
会很难，
is going to be hard,

2214
01:20:35,980 --> 01:20:37,840
因为那些 bug 会出现。
because those kind of bugs will show up.

2215
01:20:38,200 --> 01:20:39,820
如果你不够小心，
If you're not careful enough or

2216
01:20:39,820 --> 01:20:42,420
或者你还没有完全理解某些方面。
you haven't fully internalized some aspect yet.

2217
01:20:42,520 --> 01:20:43,780
你基本上
And you're basically going to

2218
01:20:43,780 --> 01:20:45,640
会遇到内核崩溃，
get kernel crash and

2219
01:20:45,640 --> 01:20:46,390
你会很艰难，
you're gonna have a hard

2220
01:20:46,390 --> 01:20:48,220
需要花一些时间、
time when you will take a little bit of time

2221
01:20:48,220 --> 01:20:50,050
精力和调试工作
and energy and detective work

2222
01:20:50,050 --> 01:20:52,280
来追踪发生这种情况的原因。
to basically track down why that happened.

2223
01:20:53,370 --> 01:20:55,860
这只是
And that's just the, that's just

2224
01:20:55,860 --> 01:20:57,860
虚拟内存编程的一部分。
part of like programming virtual memory.

2225
01:20:58,330 --> 01:20:59,170
因为它是如此强大，
Because it's such a

2226
01:20:59,170 --> 01:21:00,730
你知道，
powerful primitive, you know, you

2227
01:21:00,730 --> 01:21:01,480
如果你弄错了，
get it wrong,

2228
01:21:01,480 --> 01:21:04,840
会产生严重的后果。
you're gonna have powerful consequences.

2229
01:21:08,090 --> 01:21:09,890
然而，另一方面是非常有趣的，
Yet the other hand is great amount of fun,

2230
01:21:09,890 --> 01:21:12,560
所以我不想以负面结束。
so I don't want to end on a negative node,

2231
01:21:12,560 --> 01:21:14,630
但所有这些都会
But all that will give

2232
01:21:14,630 --> 01:21:16,370
让你真正理解什么是
you a real understanding of actually

2233
01:21:16,370 --> 01:21:18,020
真正的虚拟内存，
what really virtual memory is and

2234
01:21:18,020 --> 01:21:18,840
以及它能做什么。
what it can do.

2235
01:21:20,180 --> 01:21:21,140
好的，我想
Okay I think I'm running

2236
01:21:21,140 --> 01:21:21,800
时间不多了，
out of time so I'm

2237
01:21:21,800 --> 01:21:22,820
所以到此为止了，
gonna stop here,

2238
01:21:22,820 --> 01:21:24,110
这样大家有时间
so people have time to

2239
01:21:24,110 --> 01:21:26,060
去下一节课或下一个活动，
go to the next class or next activity,

2240
01:21:26,060 --> 01:21:27,620
但是如果你们还有什么问题，
but if you have any questions

2241
01:21:27,620 --> 01:21:30,700
请稍等，然后继续提问。
left, please hang on and ask them.

2242
01:21:31,440 --> 01:21:33,960
我们下周一见。
And, we'll see you on monday.

2243
01:21:35,360 --> 01:21:38,320
祝你们顺利完成 syscall 实验。
And good luck with finishing the syscall lab.

2244
01:21:40,920 --> 01:21:44,190
我有一个关于 walk 的问题，
Um, hi, I have a question about walk,

2245
01:21:44,190 --> 01:21:47,040
在代码中，
so it says and in the code,

2246
01:21:47,040 --> 01:21:52,360
它返回的 PTE 的第一个表。
it returns the like the first tables of PTE.

2247
01:21:52,480 --> 01:21:53,980
是的。
Yeah right.

2248
01:21:53,980 --> 01:21:56,410
但是它是怎么工作的，
But how does it work,

2249
01:21:56,410 --> 01:21:57,910
比如其他函数
then like the other functions when

2250
01:21:57,910 --> 01:21:01,310
它们期望 PTE
they expect the actual PTE,

2251
01:22:01,310 --> 01:22:03,560
而不是物理地址。
than the physical address.

2252
01:22:05,690 --> 01:22:09,590
基本上这会返回
Yeah basically this returns the PTE

2253
01:22:09,590 --> 01:22:11,240
页表中的 PTE 条目，
entry in the page table,

2254
01:22:12,100 --> 01:22:13,330
内核可以
and the kernel can read or

2255
01:22:13,330 --> 01:22:14,680
读取或写入页表条目。
write page table entries.

2256
01:22:15,070 --> 01:22:17,050
现在你可以
Um, and so now you can

2257
01:22:17,050 --> 01:22:19,200
把值放到 PTE 里。
stick values into the PTE.

2258
01:22:21,180 --> 01:22:22,560
也许我可以画一幅图，
And so maybe I can draw

2259
01:22:22,560 --> 01:22:24,640
来帮助解释这个问题。
a picture that is helpful.

2260
01:22:26,330 --> 01:22:27,160
让我们看看。
Let's see.

2261
01:22:35,790 --> 01:22:37,980
所以我们有一个页面目录。
So maybe we have a page directory.

2262
01:22:45,000 --> 01:22:48,150
而且，这个 walk 代码，
And, you know, this walk code,

2263
01:22:48,150 --> 01:22:52,900
页面目录中有 512 个 PTE 。
so the page directory has 512 PTE in it.

2264
01:22:56,960 --> 01:23:00,560
从 0 到 511 ，函数的作用是
Here's zero, here's 511 and basically what the

2265
01:23:00,560 --> 01:23:05,340
返回一个指向其中一个 PTE 的指针。
function does it returns a pointer to one of these PTEs.

2266
01:23:06,040 --> 01:23:07,600
这只是一个虚拟地址，
And so that's just a virtual address,

2267
01:23:07,600 --> 01:23:09,740
它指向那个特定的 PTE 。
and it points to that particular PTE.

2268
01:23:10,220 --> 01:23:11,990
现在内核可以，
And now the kernel can, you

2269
01:23:11,990 --> 01:23:14,330
通过向它写入值，
know manipulate that PTE, by whatever

2270
01:23:14,330 --> 01:23:15,680
来操纵那个 PTE 。
writing values to it.

2271
01:23:16,010 --> 01:23:17,420
比如某个物理地址，
Like some physical address,

2272
01:23:17,820 --> 01:23:20,250
也许有一些权限
maybe with some permissions

2273
01:23:20,250 --> 01:23:22,320
在它的后十位。
into it for the bottom ten bits.

2274
01:23:23,730 --> 01:23:26,130
然后更新页表目录，
And then basically updates the page table directory,

2275
01:23:26,130 --> 01:23:29,540
稍后将数据加载到 satp 中时，
and then later on when you load data into satp,

2276
01:23:29,810 --> 01:23:32,660
这一修改将会生效。
now, that affect that change will go into effect.

2277
01:23:35,350 --> 01:23:36,480
这个能理解吗？
Does that make sense.

2278
01:23:37,180 --> 01:23:38,440
是的，理解了，
Yeah that makes sense, I guess

2279
01:23:38,440 --> 01:23:39,880
我想我只是搞不懂，
I just confused like why does

2280
01:23:39,880 --> 01:23:43,380
为什么它要一直转到第三个页表，
it do the work of going all the way to the third,

2281
01:23:43,550 --> 01:23:46,840
然后只返回第一个 PTE 。
page table and then only return the first PTE.

2282
01:23:46,900 --> 01:23:50,440
不是，返回的实际上是最底层的。
No, return is actually the bottom one.

2283
01:23:51,710 --> 01:23:53,510
实际上，我讲详细一点，
Actually, let me be careful,

2284
01:23:55,340 --> 01:23:56,840
如果它通过了 n 级，
if, you know, it goes through

2285
01:23:56,840 --> 01:23:59,750
从 2 级开始，然后到 1 级，
the n levels, started level 2 and then go to level 1,

2286
01:23:59,750 --> 01:24:01,120
再到 0 级。
again a level 0.

2287
01:24:01,730 --> 01:24:06,920
如果 alloc 位设置，但是这个级别不存在，
If the alloc bit set and level doesn't exist,

2288
01:24:06,920 --> 01:24:09,980
将会创建中间页表目录。
it will create the intermediate page table directory.

2289
01:24:10,580 --> 01:24:13,260
把它清零，然后继续查找。
And zero it out and then keep going to look.

2290
01:24:13,780 --> 01:24:17,840
所以，你总是落在最底层 PTE 。
So, you always end up on the bottom PTE.

2291
01:24:18,580 --> 01:24:20,800
如果 alloc 位没有设置，
If alloc not set, you stop

2292
01:24:20,800 --> 01:24:23,680
你会在第一个 PTE 停止，它没有值。
at the first PTE, that doesn't have value.

2293
01:24:25,550 --> 01:24:26,510
好的，理解了，
Okay, that makes sense,

2294
01:24:26,510 --> 01:24:29,840
实际得到的是最后一个。
this is the last one, the actual on gonna have.

2295
01:24:29,840 --> 01:24:32,880
好的，谢谢。
Okay okay, thank you.

2296
01:24:36,850 --> 01:24:38,080
还有其他问题吗？
Any other questions.

2297
01:24:40,820 --> 01:24:42,740
我有一个问题，
So I have a question,

2298
01:24:42,740 --> 01:24:45,590
前面都能理解，
basically everything made sense until

2299
01:24:45,590 --> 01:24:47,630
直到我们将内核的虚拟地址
we mapped the virtual addresses

2300
01:24:47,630 --> 01:24:51,980
映射到物理地址，
to, of the kernel to the physical addresses.

2301
01:24:53,800 --> 01:24:55,720
我的理解是，
So my understanding is that

2302
01:24:55,720 --> 01:24:57,880
每个进程都会有自己的页表，
each process will have its own page table,

2303
01:24:57,880 --> 01:24:59,380
它也是一个三级表，
which is also a three level tree

2304
01:24:59,380 --> 01:25:03,730
将其虚拟地址映射到物理地址，
which wraps its virtual addresses to physical addresses,

2305
01:25:03,730 --> 01:25:06,190
但然后我们将内核虚拟地址
but then we map the kernel

2306
01:25:06,190 --> 01:25:08,230
映射到物理地址，
virtual addresses to physical addresses, I

2307
01:25:08,230 --> 01:25:09,760
我认为我们没有考虑到
don't think we accounted for the

2308
01:25:09,760 --> 01:25:14,150
[实际的内核虚拟内存]
actual tree of them virtual addresses of the kernel

2309
01:25:14,150 --> 01:25:19,320
或其他进程将拥有其虚拟地址的位置。
or where other processes will have their virtual addresses.

2310
01:25:19,380 --> 01:25:23,760
虚拟地址
And I'm sorry, virtual addresses like

2311
01:25:23,760 --> 01:25:25,940
就像虚拟[表树]，
the virtual table trees and

2312
01:25:26,200 --> 01:25:27,880
[页表树]指向
whatever the page table tree points

2313
01:25:27,880 --> 01:25:30,430
物理内存。
at in the physical memory.

2314
01:25:30,430 --> 01:25:32,260
是的，
Yeah, so yeah so so you're

2315
01:25:32,260 --> 01:25:34,630
所以回到这张关于内核的幻灯片，
back this is slide with kernel,

2316
01:25:35,870 --> 01:25:37,610
虚拟内核地址空间，
address space, virtual kernel address

2317
01:25:37,610 --> 01:25:41,060
当内核分配特定进程的
space and so when the kernel allocates proc,

2318
01:25:41,370 --> 01:25:44,970
proc 和页表时，
and page tables for that particular process, they're going

2319
01:25:44,970 --> 01:25:48,630
它们将被分配到内存这里，
to be allocated at memory here, memory is

2320
01:25:48,630 --> 01:25:49,940
内存还没有被使用。
not being used yet.

2321
01:25:50,870 --> 01:25:52,430
内核将进行编程，
And the kernel is going to

2322
01:25:52,430 --> 01:25:55,370
我们可能会为页表
program, we'll probably allocate a

2323
01:25:55,370 --> 01:25:57,170
分配几个页面，
couple pages for the page table,

2324
01:25:57,170 --> 01:25:58,790
远离普通进程，
off the usual process and

2325
01:25:58,790 --> 01:26:00,340
并填充 [PTE] 。
will fill in the PTEs.

2326
01:26:01,460 --> 01:26:03,110
在内核运行该进程的
And at some point when the

2327
01:26:03,110 --> 01:26:04,800
某个时刻，
kernel runs that process,

2328
01:26:04,900 --> 01:26:08,260
它将加载路由，
it will load the route,

2329
01:26:08,260 --> 01:26:10,540
加载这些页分配的
physical address for those pages that

2330
01:26:10,540 --> 01:26:12,070
物理地址，
is allocated for that page table

2331
01:26:12,070 --> 01:26:14,200
或页表，
or basically page table then built

2332
01:26:14,200 --> 01:26:15,880
然后将其构建到 satp 寄存器中。
into the satp register.

2333
01:26:16,650 --> 01:26:19,560
这时，
And at that point the processor

2334
01:26:19,560 --> 01:26:21,720
处理器将运行在虚拟地址空间，
will run with the virtual address

2335
01:26:21,720 --> 01:26:23,460
那是内核为
space that the kernel constructed for

2336
01:26:23,460 --> 01:26:24,680
该特定进程构造的。
that particular process.

2337
01:26:27,140 --> 01:26:29,060
所以
So the kernel gave up

2338
01:26:29,060 --> 01:26:32,270
内核为进程释放了一些内存，
some of its memory for processes,

2339
01:26:32,270 --> 01:26:36,470
在理论上进程的虚拟空间
and then the virtual space in theory is as big

2340
01:26:36,470 --> 01:26:39,910
和内核一样大，
for the process as the kernel,

2341
01:26:39,910 --> 01:26:42,550
但在现实中，不是那样的。
but in reality, it's really not.

2342
01:26:42,550 --> 01:26:45,250
这里有一张
Yeah, have a picture with the layout

2343
01:26:45,250 --> 01:26:46,330
普通进程的
of a virtual address space with

2344
01:26:46,330 --> 01:26:48,040
虚拟地址空间布局图片，
their usual level process and again

2345
01:26:48,040 --> 01:26:49,960
它也是从 0 到 MAXVA 。
it goes from zero to MAXVA.

2346
01:26:51,930 --> 01:26:53,520
就像内核地址空间一样，
In the same way as the

2347
01:26:54,240 --> 01:26:56,100
它有
kernel address space does and it's

2348
01:26:56,100 --> 01:26:57,120
自己的一组页表
basically has his own set of

2349
01:26:57,120 --> 01:27:00,140
来映射这些
page tables to map those translation

2350
01:27:00,500 --> 01:27:01,720
内核设置的转换。
the kernel setup.

2351
01:27:03,200 --> 01:27:06,530
但是我们不能实际使用所有的 MAXVA 虚拟地址。
But we can't actually use all of the MAXVA virtual.

2352
01:27:06,530 --> 01:27:07,580
是的，我们不能。
No, we cannot.

2353
01:27:07,640 --> 01:27:09,720
我们的内存用完了。
We run out of memory.

2354
01:27:11,620 --> 01:27:14,800
因此，许多进程
So many of the processes are much smaller than

2355
01:27:14,950 --> 01:27:16,800
比所有虚拟地址空间都要小得多。
all of the virtual address space.

2356
01:27:19,740 --> 01:27:21,360
我理解了，谢谢。
I see, thank you.

2357
01:27:23,250 --> 01:27:24,480
我有一个问题，
I've got a quick question,

2358
01:27:26,020 --> 01:27:28,450
你能不能回到 walk 代码，
could you go back to the walk code,

2359
01:27:28,450 --> 01:27:30,040
好的，当然可以。
yeah yeah absolutely.

2360
01:27:31,490 --> 01:27:34,680
这是我最喜欢的功能之一。
It's one of my favorite functions.

2361
01:27:35,290 --> 01:27:38,560
所以我想，
So I guess, one

2362
01:27:38,560 --> 01:27:40,570
有一件事我很困惑，
thing I'm confused about is after

2363
01:27:40,570 --> 01:27:44,800
那就是在你写到 satp 寄存器之后，
you write to the satp register, can the kernel even access

2364
01:27:44,800 --> 01:27:46,750
内核甚至可以直接访问物理地址，
physical addresses directly,

2365
01:27:46,750 --> 01:27:47,620
所以
so it looks like in the

2366
01:27:47,620 --> 01:27:49,210
在它正在转换的代码中，
code that it's converting you know

2367
01:27:49,210 --> 01:27:51,250
比如页设置为物理地址，
like page was being set to a physical address,

2368
01:27:51,250 --> 01:27:53,500
但是如果已经设置了 satp ，
but if satp is set,

2369
01:27:53,860 --> 01:27:57,580
那不会被解释为虚拟地址吗？
won't that be interpreted as a virtual address.

2370
01:27:57,580 --> 01:27:59,680
是的，
Yeah,

2371
01:27:59,680 --> 01:28:06,600
所以，让我们来看一下 hartinit 。
so, okay so let's look at hartinit.

2372
01:28:12,380 --> 01:28:14,720
内置在内核地址空间中。
That's kvm, so built in kernel address space.

2373
01:28:15,070 --> 01:28:17,860
对于内核页表，
The kernel page table,

2374
01:28:19,860 --> 01:28:23,280
最初，
initially, the virtual physical, address

2375
01:28:23,280 --> 01:28:26,190
地址被转换为物理地址，
is translated to a physical

2376
01:28:26,190 --> 01:28:29,300
并且该地址被写入到 satp 寄存器中。
address and that's actually written into the satp register.

2377
01:28:30,380 --> 01:28:32,360
在这一点，
And at that point you

2378
01:28:32,360 --> 01:28:34,220
我们使用的是
know we're running with the address

2379
01:28:34,220 --> 01:28:36,740
在此之前构建的地址空间，
space that we've constructed right before

2380
01:28:36,740 --> 01:28:38,280
比如运行 kvminit 。
here, this kvminit.

2381
01:28:39,980 --> 01:28:41,480
给了我一张映射，
And gave me a map is

2382
01:28:41,480 --> 01:28:44,700
基本上就是
basically nothing else than calling

2383
01:28:45,040 --> 01:28:47,710
对每一个这个范围的地址
walk for every address where

2384
01:28:47,710 --> 01:28:49,500
调用 walk 函数。
every page and at the range.

2385
01:28:50,340 --> 01:28:51,750
那么你的问题是什么？
And so what was your question?

2386
01:28:53,660 --> 01:28:54,380
我想是，
I guess,

2387
01:28:54,380 --> 01:28:56,810
如果你在设置了 satp 之后，
it's does walks still work

2388
01:28:56,810 --> 01:28:59,480
walk 仍然是一样的方式工作吗。
the same way if you call it after satp

2389
01:28:59,480 --> 01:29:02,160
是啊，怎么了。
is set. Yeah why.

2390
01:29:04,590 --> 01:29:06,900
能够成功的原因是
Why we work out the reason

2391
01:29:06,900 --> 01:29:13,260
内核页表设置是恒等映射。
it work out the kernel set up in identity mapping.

2392
01:29:13,720 --> 01:29:15,100
好的，对。
Ok, right, right.

2393
01:29:15,100 --> 01:29:16,390
非常重要，
Very important,

2394
01:29:16,390 --> 01:29:18,580
非常好的问题，
very good question,

2395
01:29:18,580 --> 01:29:19,930
很多事情都解决了，
a lot of things just happened

2396
01:29:19,930 --> 01:29:23,040
因为实际上设置了恒等映射。
to work out because actually the identity mapping is set up.

2397
01:29:24,670 --> 01:29:27,610
我明白了，我想这是有道理的。
I see, I think that makes sense,

2398
01:29:31,360 --> 01:29:33,220
我有一个简短的问题。
I have a quick question.

2399
01:29:33,220 --> 01:29:38,000
所有进程的 satp 寄存器存储在哪，
Where the satp register stored for all of the processes.

2400
01:29:38,480 --> 01:29:41,560
每个内核只有一个 satp ，
There only one satp per core,

2401
01:29:42,040 --> 01:29:44,260
但是在每一个程序结构中。
but in every proc structure.

2402
01:29:46,300 --> 01:29:49,840
如果你看一下 proc.h ,
If you look at proc.h, there is,

2403
01:29:52,740 --> 01:29:55,680
有一个指向页表的指针，在这。
a pointer to the page table,

2404
01:29:55,680 --> 01:29:57,620
好的，理解了。
here, here. okay, makes sense.

2405
01:29:58,460 --> 01:30:01,370
另外，
And also with regards to the

2406
01:30:01,370 --> 01:30:04,280
关于三个页表，
three page tables are like the

2407
01:30:04,280 --> 01:30:06,680
可以组成完整的地址，
three tables that can complete the

2408
01:30:06,680 --> 01:30:08,060
甚至
full address and help you get

2409
01:30:08,060 --> 01:30:11,510
可以帮助你获得一些东西的完整地址，
a full address for even something,

2410
01:30:11,510 --> 01:30:13,160
这比拥有一个巨大的页表
how does how is that better

2411
01:30:13,160 --> 01:30:15,500
有什么更好的地方，
I guess than than having one

2412
01:30:15,500 --> 01:30:17,120
我并没有真正完全理解。
giant page table I didn't really

2413
01:30:17,120 --> 01:30:20,090
这是一个很好的问题，
fully understand what. A great question,

2414
01:30:20,090 --> 01:30:22,580
原因是在自由级别的页面表中，
the reason is because in the free level page table,

2415
01:30:22,580 --> 01:30:24,460
你可以将许多条目留空。
you can leave a lot of entries empty.

2416
01:30:25,060 --> 01:30:26,920
例如，如果
So, for example if you leave

2417
01:30:26,920 --> 01:30:30,520
你将顶层页表中的条目直接留空，
the entry in the top level page table directly empty,

2418
01:30:30,520 --> 01:30:31,960
则根本不必
you don't have to create middle

2419
01:30:31,960 --> 01:30:33,910
为这些条目创建
level page tables or bottom level

2420
01:30:33,910 --> 01:30:36,200
中层页表或底层页表。
page tables at all, for those entries.

2421
01:30:37,070 --> 01:30:38,870
这意味着
Like this means like a big

2422
01:30:38,870 --> 01:30:40,940
整个虚拟地址空间的一大块
[] of the whole virtual address

2423
01:30:40,940 --> 01:30:43,400
根本不需要任何映射。
space doesn't have to have any mapping at all.

2424
01:30:44,890 --> 01:30:45,730
好的，好的。
Okay, okay.

2425
01:30:45,730 --> 01:30:47,080
你不需要表，
You don't have the table there,

2426
01:30:47,080 --> 01:30:48,240
它根本不存在。
it just doesn't exist.

2427
01:30:48,840 --> 01:30:49,230
我明白了，
I see,

2428
01:30:49,230 --> 01:30:52,500
基本上这些块
basically allocating these chunks on demand

2429
01:30:52,500 --> 01:30:53,880
是按数量和类型分配的，
as volumes and types,

2430
01:30:53,880 --> 01:30:55,170
好的，理解了。
OK that makes sense,

2431
01:30:55,170 --> 01:30:56,880
是的，
Yeah you're starting basically with three

2432
01:30:56,880 --> 01:30:58,410
从三页开始，
page three pages namely,

2433
01:30:58,410 --> 01:30:59,490
一个高层的，
one from the top level one

2434
01:30:59,490 --> 01:31:01,170
一个中间的，
for, one intermediate one from,

2435
01:31:01,170 --> 01:31:02,840
一个底层的。
one bottom level.

2436
01:31:03,170 --> 01:31:03,740
然后，
And then,

2437
01:31:03,740 --> 01:31:05,090
随着操作的进行，
as you go you create more

2438
01:31:05,090 --> 01:31:06,500
你将创建更多的页表目录。
page table directories.

2439
01:31:06,750 --> 01:31:07,680
好的，好的，
Okay, okay,

2440
01:31:09,140 --> 01:31:10,400
太好了，太感谢你了。
cool, thank you so much.

2441
01:31:10,400 --> 01:31:11,220
不用谢。
You're welcome.

2442
01:31:12,930 --> 01:31:14,180
还有什么问题吗。
Any more questions.

2443
01:31:14,670 --> 01:31:16,020
我有一个问题，
I'm sorry I have another one,

2444
01:31:16,020 --> 01:31:18,270
它真的很小，
it's really really small but

2445
01:31:18,270 --> 01:31:26,280
在 vm.c 的 43 ， 41 行，
in the vm.c on line 43, 41,

2446
01:31:26,280 --> 01:31:30,680
写到，不，或许是 43 行，
it says that, no, might 43, my bad,

2447
01:31:30,680 --> 01:31:38,020
有一个 PHYSTOP-(uint64)etext ，但是会不会
it says 'PHYSTOP-(uint64)etext', but wouldn't that,

2448
01:31:38,370 --> 01:31:43,260
访问到
would not go over the, I guess the memory that

2449
01:31:43,260 --> 01:31:46,020
我们不应该接触的内存，
we shouldn't touch, I don't

2450
01:31:46,020 --> 01:31:47,070
我不知道这是否有意义，
know if that makes sense,

2451
01:31:47,070 --> 01:31:50,240
但是，会不会这样。
but, would that go.

2452
01:31:51,210 --> 01:31:53,130
我想我不明白，
I guess I don't understand, would

2453
01:31:53,130 --> 01:31:54,920
他们会不会检查一下空闲内存。
they go over free memory.

2454
01:31:55,790 --> 01:31:58,820
不，我不这么认为，
No, I don't think so,

2455
01:31:58,820 --> 01:32:03,680
KERNBASE 是 0x8000 ，对吧，
so KERNBASE is 0x8000, right

2456
01:32:03,680 --> 01:32:05,800
所以这是内存的开始。
so that's the beginning of memory.

2457
01:32:06,070 --> 01:32:09,400
内核在那里，
Kernel sits there in,

2458
01:32:09,430 --> 01:32:14,340
基本上，这是一个大小，
basically, this thing is a size,

2459
01:32:15,070 --> 01:32:18,280
所以 etext 是内核的最后一个地址，
right, so etext is the last address of the kernel,

2460
01:32:18,280 --> 01:32:20,200
减去 KERNBASE ，
subtract KERNBASE, that basically gives

2461
01:32:20,200 --> 01:32:26,160
它给出了内核的大小，以字节为单位。
you the size of the kernel, in byte.

2462
01:32:26,490 --> 01:32:28,140
而且，你知道，我不知道它有多少，
And, you know, I don't know how

2463
01:32:28,140 --> 01:32:31,800
但它大概是 60 或 90 页，
much it is, but it's like you know 60 or 90

2464
01:32:31,800 --> 01:32:33,460
或差不多大小。
pages or something like that.

2465
01:32:33,990 --> 01:32:35,580
所以这个映射
And so this map

2466
01:32:35,580 --> 01:32:37,760
是内核的文本部分。
is basically the text part of the kernel.

2467
01:32:38,350 --> 01:32:42,640
嗯，还有足够的空间。
Um, and there's enough space.

2468
01:32:43,290 --> 01:32:48,460
那里有足够的 DRAM 来映射内核文本。
There's enough DRAM there to map that the kernel text.

2469
01:32:48,830 --> 01:32:50,240
我不确定，我是否回答了你的问题，但是。
I'm not sure, I'm answering your question,

2470
01:32:50,240 --> 01:32:53,840
我想我明白了。
but. I think, I think I understand.

2471
01:32:54,030 --> 01:32:56,670
我以为 etext 是从别的地方开始的，
I thought that etext starts

2472
01:32:56,670 --> 01:32:59,250
好的，我想我现在明白了，谢谢。
somewhere else, okay, I think I understand now, thank you.

2473
01:32:59,250 --> 01:33:01,080
所以 etext 是最后一条指令，
So etext basically the last instruction,

2474
01:33:01,080 --> 01:33:03,080
内核最后一条指令的地址。
the address of the last instruction of the kernel.

2475
01:33:03,690 --> 01:33:04,720
好的，好的。
Okay, okay.
