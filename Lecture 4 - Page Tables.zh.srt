1
00:00:00,000 --> 00:00:02,640
声音检查，大家能听到我说话吗？
Sound check, can everybody hear me?

2
00:00:04,700 --> 00:00:08,060
是的。好的，
Yep, yep. Okay okay,

3
00:00:08,060 --> 00:00:09,920
欢迎收听 6.S081
so welcome to the next lecture

4
00:00:09,920 --> 00:00:12,410
的下一节课，
in the 6.S081, wherever you

5
00:00:12,410 --> 00:00:14,380
无论你在哪里，
are, particular,

6
00:00:14,740 --> 00:00:15,640
我希望西海岸，
I hope that the folks on

7
00:00:15,640 --> 00:00:17,380
佛罗里达和
the west coast or in Florida

8
00:00:17,380 --> 00:00:19,450
阿拉巴马州的人们都还好，
and Alabama do OK, you know, all

9
00:00:19,450 --> 00:00:22,140
那里糟糕的情况会好起来。
the terrible circumstances there.

10
00:00:22,510 --> 00:00:24,880
嗯，那么，
Um, so,

11
00:00:24,880 --> 00:00:26,350
今天的话题是
um, the topic for today,

12
00:00:26,350 --> 00:00:29,110
虚拟内存，
is virtual memory, particularly we're

13
00:00:29,110 --> 00:00:30,580
特别是我们要讲的页表，
going to talk about page tables

14
00:00:30,580 --> 00:00:32,650
我们多次讲到
we'll return to this topic

15
00:00:32,650 --> 00:00:33,340
这个话题，
few times,

16
00:00:33,340 --> 00:00:34,390
有多次关于
there will be multiple

17
00:00:34,390 --> 00:00:35,380
这个的讲座。
[] lectures.

18
00:00:36,030 --> 00:00:37,920
一开始，
Maybe just start off and,

19
00:00:37,920 --> 00:00:39,690
我们会再次开始
you know, get our question and answer

20
00:00:39,690 --> 00:00:40,680
我们的问答环节，
going again,

21
00:00:42,120 --> 00:00:43,320
我想问
I would like to ask you

22
00:00:43,320 --> 00:00:43,830
一些问题，
a little bit,

23
00:00:43,830 --> 00:00:45,930
你对 6.004 或
what do you remember from，

24
00:00:45,930 --> 00:00:47,910
6.033 的讲的
about virtual memory from 6.004

25
00:00:47,910 --> 00:00:50,400
虚拟内存
maybe from 6.033,

26
00:00:50,400 --> 00:00:51,660
有什么印象。
if you're taking that.

27
00:00:52,500 --> 00:00:53,970
我要告诉你们，
I'll tell you, my own sort

28
00:00:53,970 --> 00:00:55,320
我自己对虚拟内存的看法，
of view on virtual memory,

29
00:00:55,320 --> 00:00:56,580
这就是当我
which is when I took it,

30
00:00:56,580 --> 00:00:57,780
第一次了解它的时候，
to first learned about it,

31
00:00:57,780 --> 00:00:58,500
还是个学生的时候，
learned about it as

32
00:00:58,500 --> 00:00:59,850
我认为
a student, I thought it

33
00:00:59,850 --> 00:01:01,110
它很简单，很直接，
was pretty straightforward,

34
00:01:01,110 --> 00:01:01,680
你知道的，
you know how hard could

35
00:01:01,680 --> 00:01:02,010
它能有多难，
it be,

36
00:01:02,010 --> 00:01:04,140
就是一个将虚拟地址
it's a table that maps virtual

37
00:01:04,140 --> 00:01:05,700
映射到物理地址的表。
addresses to physical addresses.

38
00:01:05,870 --> 00:01:07,190
你知道，
You know, maybe a

39
00:01:07,190 --> 00:01:08,120
可能有一点复杂，
little more complicated,

40
00:01:08,120 --> 00:01:09,680
但没有那么复杂。
but you know not that

41
00:01:09,680 --> 00:01:11,300
只有当你实际
complicated, only when you start

42
00:01:11,300 --> 00:01:12,540
用它来编程的时候，
programming with it.

43
00:01:12,600 --> 00:01:15,210
我真的知道了，
I should really learn, virtual

44
00:01:15,210 --> 00:01:18,380
虚拟内存是巧妙的，迷人的，
memory is tricky and fascinating,

45
00:01:18,540 --> 00:01:20,880
而且非常强大。
and very powerful.

46
00:01:21,380 --> 00:01:23,300
所以，
So, hopefully in the

47
00:01:23,300 --> 00:01:25,100
希望在接下来的几节课，
next couple of lectures, in

48
00:01:25,100 --> 00:01:26,060
接下来的几个实验中，
the next couple of labs,

49
00:01:26,060 --> 00:01:29,090
你们能从这个角度
you'll know appreciate

50
00:01:29,090 --> 00:01:30,820
理解虚拟内存。
virtual memory from that perspective.

51
00:01:31,060 --> 00:01:32,230
我们将提问
We will ask a couple

52
00:01:32,230 --> 00:01:34,000
在线的的几个人，
people here are online, you know

53
00:01:34,000 --> 00:01:36,010
关于你对
what do you remember about virtual

54
00:01:36,010 --> 00:01:38,860
6.004 或 6.033
memory from either 6.004 or

55
00:01:38,860 --> 00:01:40,120
虚拟内存的印象是什么。
6.033 taking it.

56
00:01:40,340 --> 00:01:41,510
我要叫几个名字，
Again, I'm just gonna call some

57
00:01:41,510 --> 00:01:43,080
你知道，
names and you know,

58
00:01:43,600 --> 00:01:47,080
分享你的印象。
share your memories. About the

59
00:01:47,080 --> 00:01:48,440
Adela Yang.
Adela Yang.

60
00:01:53,360 --> 00:01:55,160
抱歉，问题是什么？
Sorry, what's the question? What

61
00:01:55,160 --> 00:01:57,410
你对
do you remember about

62
00:01:57,410 --> 00:01:58,940
6.004 或
virtual memory from maybe 6.004

63
00:01:58,940 --> 00:02:00,470
6.033
or 6.033

64
00:02:00,470 --> 00:02:01,460
的虚拟内存有什么印象？
if you have taken that.

65
00:02:02,020 --> 00:02:05,440
它使用
It uses like, offset to save

66
00:02:05,440 --> 00:02:08,380
偏移量来记录
on like, remembering virtual address

67
00:02:08,380 --> 00:02:10,300
虚拟地址到物理地址的映射。
to physical address mappings.

68
00:02:11,640 --> 00:02:15,380
好的，下一个， Abrams Caldera 。
OK, how about Abrams Caldera.

69
00:02:20,100 --> 00:02:21,840
Abrams ，你在线吗？
Abrams, are you online?

70
00:02:23,230 --> 00:02:24,970
是的，我的印象是
Yeah, my memory is that

71
00:02:24,970 --> 00:02:26,640
它使用，
it uses like,

72
00:02:26,940 --> 00:02:29,040
就像通过
it's a way of one protecting

73
00:02:29,040 --> 00:02:30,960
一种[]表示
the physical hardware by

74
00:02:30,960 --> 00:02:33,540
来保护物理硬件，
kind of [] representation of

75
00:02:33,540 --> 00:02:35,310
然后，
it and then you just

76
00:02:35,310 --> 00:02:38,020
你使用一些
have some virtual address things like,

77
00:02:38,300 --> 00:02:41,750
至少 44 位的虚拟地址，
at least 44 bit, that map

78
00:02:41,750 --> 00:02:43,200
来映射一些物理地址，
some physical address,

79
00:02:43,530 --> 00:02:45,420
这些物理地址
that's usually I think 16

80
00:02:45,420 --> 00:02:47,620
通常是 64 位的。
bits were in fact.

81
00:02:48,090 --> 00:02:53,540
好的，下一个， Bibic Pendant 。
Okay, good, how about Bibic Pendant.

82
00:02:56,730 --> 00:02:58,080
我记得的是，
What I remember was,

83
00:02:58,080 --> 00:03:00,380
你可以让
um, you can have

84
00:03:00,840 --> 00:03:03,210
每个进程有一个
each process has a separate

85
00:03:03,210 --> 00:03:04,260
单独的地址空间。
address space.

86
00:03:04,620 --> 00:03:05,820
还有，
And,

87
00:03:06,210 --> 00:03:09,060
可以使用内存管理单元
the memory management unit or I

88
00:03:09,060 --> 00:03:10,470
或者一些其他技术
mean some other technique can be

89
00:03:10,470 --> 00:03:11,620
来映射，
used to map,

90
00:03:11,830 --> 00:03:13,960
将每个进程
the virtual addresses of the

91
00:03:13,960 --> 00:03:15,370
地址空间的
address space of each of the

92
00:03:15,370 --> 00:03:17,120
虚拟地址转换为
processes to the physical,

93
00:03:17,340 --> 00:03:19,420
物理地址。
physical address.

94
00:03:20,040 --> 00:03:23,910
还有，虚拟地址的
And the virtual address, the

95
00:03:23,910 --> 00:03:24,920
最后几位
lower bits

96
00:03:25,030 --> 00:03:25,930
是相同的，
are kind of the same,

97
00:03:25,930 --> 00:03:26,530
因此，
so that,

98
00:03:26,530 --> 00:03:29,640
映射是以块为单位的，
the the mapping is in blocks,

99
00:03:29,790 --> 00:03:32,100
这有助于提高性能。
which helps with performance.

100
00:03:33,970 --> 00:03:35,540
Wiseley Wu.
Wiseley Wu.

101
00:03:39,570 --> 00:03:42,630
是的，
Yeah, I guess what I

102
00:03:42,630 --> 00:03:44,850
我印象最深的是
remember most is that virtual address

103
00:03:44,850 --> 00:03:47,180
虚拟地址允许我们
allows us to,

104
00:03:47,750 --> 00:03:50,300
保护物理地址
yeah, protect physical addresses from

105
00:03:50,300 --> 00:03:51,580
不受每个进程的影响。
each process.

106
00:03:51,640 --> 00:03:54,070
我们可以使用
And we can use some clever

107
00:03:54,070 --> 00:03:56,080
一些巧妙的操作，
manipulation, so that the bits that

108
00:03:56,080 --> 00:03:57,730
这样对应于物理地址的位
correspond to the physical address can

109
00:03:57,730 --> 00:03:59,920
也可以
be used somehow in the virtual

110
00:03:59,920 --> 00:04:01,000
在虚拟地址中使用。
addresses as well.

111
00:04:02,600 --> 00:04:05,460
Wilson Spearmen.
Wilson Spearmen.

112
00:04:09,040 --> 00:04:10,840
是的，我记得
Yeah, I remember it's really fundamental

113
00:04:10,840 --> 00:04:11,950
这是隔离的基础，
to isolation,

114
00:04:11,950 --> 00:04:14,890
因为每个进程都
because every process can basically pretend

115
00:04:14,890 --> 00:04:16,620
可以假装
that it has its own

116
00:04:16,760 --> 00:04:19,180
它有自己的内存可以使用。
sort of memory to use.

117
00:04:20,470 --> 00:04:22,270
很好，很清楚，
Good good well so clearly,

118
00:04:22,270 --> 00:04:23,830
很棒，
that's awesome,

119
00:04:23,830 --> 00:04:26,080
显然，这里有两个主题，
the clear, two themes here

120
00:04:26,080 --> 00:04:28,210
一个是
correct, one is you know

121
00:04:28,210 --> 00:04:30,400
有某种形式的映射，
there's some form of mapping and

122
00:04:30,400 --> 00:04:31,900
这种映射有助于
the mapping is helpful in sort

123
00:04:31,900 --> 00:04:33,670
实现某种程度的隔离，
of achieving isolation,

124
00:04:33,670 --> 00:04:35,800
这正是我们讨论
this is exactly the reason, we're

125
00:04:35,800 --> 00:04:38,560
虚拟内存隔离的原因。
talking about virtual memory isolation.

126
00:04:38,870 --> 00:04:39,620
因此，
So, what

127
00:04:39,620 --> 00:04:41,570
我们在接下来的
we'll see is that in

128
00:04:41,570 --> 00:04:43,580
几节课中会看到，
the next, in the next couple of lectures,

129
00:04:43,580 --> 00:04:44,840
特别是，当我们开始
in particular, when we start programming

130
00:04:44,840 --> 00:04:45,950
使用虚拟内存编程时，
with virtual memory,

131
00:04:45,950 --> 00:04:48,680
我们会真正深入了解
really get an in-depth understanding

132
00:04:48,680 --> 00:04:50,360
它的力量。
of what its power is.

133
00:04:50,780 --> 00:04:52,250
为了让你理解，
And, so to get a

134
00:04:52,250 --> 00:04:53,570
你知道，
sense, that you know, this is

135
00:04:53,570 --> 00:04:55,310
这是第一节课，
the first lecture and mostly focusing

136
00:04:55,310 --> 00:04:59,390
内容主要集中在虚拟内存的机制上，
on the mechanisms for virtual memory,

137
00:04:59,390 --> 00:05:00,680
稍后我们可以看到，
and then later we can see

138
00:05:00,680 --> 00:05:02,030
如何使用这些机制来实现
how we can use these mechanisms

139
00:05:02,030 --> 00:05:03,760
那些很棒的技巧。
to achieve, you know, cool tricks.

140
00:05:04,660 --> 00:05:06,220
所以
So the topic for today, or

141
00:05:06,220 --> 00:05:08,740
今天的话题或议程是，
agenda for today, the plan

142
00:05:08,740 --> 00:05:10,460
计划分为三部分。
is sort of three part.

143
00:05:10,800 --> 00:05:12,210
首先，
First, I'm going to talk about the

144
00:05:12,210 --> 00:05:14,130
我要谈谈地址空间，
address spaces, as some of you

145
00:05:14,130 --> 00:05:16,020
你们中有些人也提到这个。
mentioning in your.

146
00:05:16,320 --> 00:05:17,420
这正是我们需要的。
Just what we need.

147
00:05:18,070 --> 00:05:19,840
刚才回答问题的时候
Just mentioned just briefly mentioned,

148
00:05:19,840 --> 00:05:22,420
简单提了一下，
in response to the question,

149
00:05:22,420 --> 00:05:23,980
我还要讲一下
I'm going to talk about the

150
00:05:23,980 --> 00:05:26,200
分页硬件。
paging hardware paging hardware.

151
00:05:27,020 --> 00:05:28,280
当然，
And I'm going to focus of

152
00:05:28,280 --> 00:05:29,600
我将重点介绍
course on the paging hardware of

153
00:05:29,600 --> 00:05:30,640
RISC-V 的分页硬件。
the RISC-V.

154
00:05:32,020 --> 00:05:36,400
但是基本上每个处理器，
But basically every processor, modern processor

155
00:05:36,400 --> 00:05:38,950
现代处理器都有
has some form of paging hardware

156
00:05:38,950 --> 00:05:40,200
某种形式的分页硬件。
sort of,

157
00:05:40,230 --> 00:05:41,640
实际上它是
if you will, the

158
00:05:41,640 --> 00:05:44,310
支持虚拟内存的
default mechanism for actually

159
00:05:44,310 --> 00:05:45,820
默认机制。
supporting virtual memory.

160
00:05:46,250 --> 00:05:47,000
然后，
And then,

161
00:05:47,000 --> 00:05:48,260
课程的最后一部分
the last part of

162
00:05:48,260 --> 00:05:49,610
将介绍一些
the lecture is going to

163
00:05:49,610 --> 00:05:52,100
xv6 的
walk through some xv6

164
00:05:52,100 --> 00:05:54,240
虚拟内存代码。
virtual memory code.

165
00:05:54,280 --> 00:06:00,770
还有，内核地址空间和
And, layout of kernel address space and

166
00:06:00,770 --> 00:06:02,000
用户地址空间的布局。
user address spaces.

167
00:06:02,730 --> 00:06:04,580
所以这是主要的计划。
So that's the main plan.

168
00:06:08,250 --> 00:06:09,660
好的，那么
Okay, so,

169
00:06:09,660 --> 00:06:11,160
如果我们回答，
if we answers, you know, []

170
00:06:11,160 --> 00:06:12,120
你所提到的[]，
you mentioned,

171
00:06:12,120 --> 00:06:14,370
回答这个问题，
in response to this question,

172
00:06:14,370 --> 00:06:15,280
你知道，
you know,

173
00:06:15,370 --> 00:06:18,430
有虚拟内存的一个驱动力
one driving reason to have

174
00:06:18,430 --> 00:06:20,020
是因为
virtual memory is because you can

175
00:06:20,020 --> 00:06:22,000
你可以用它来实现隔离，
use it to achieve isolation,

176
00:06:22,000 --> 00:06:22,840
如果页表设置正确，
if you set up the page

177
00:06:22,840 --> 00:06:25,540
并且编程正确，
tables correctly and program them correctly,

178
00:06:25,540 --> 00:06:26,710
那么原则上
then you can in principle

179
00:06:26,710 --> 00:06:28,540
就可以实现强隔离。
achieve strong isolation.

180
00:06:29,020 --> 00:06:30,910
这再次提醒我们，
And so this is to remind us again,

181
00:06:30,910 --> 00:06:31,960
我们想从隔离中
you know what we want with

182
00:06:31,960 --> 00:06:33,100
得到什么，
from isolation,

183
00:06:33,100 --> 00:06:34,540
比如，
let's say, you know a

184
00:06:34,540 --> 00:06:35,380
你知道一张标准图片，
standard picture,

185
00:06:35,380 --> 00:06:36,820
我们有一些用户应用程序，
we have some user applications

186
00:06:36,820 --> 00:06:37,920
比如 shell ，
like shell,

187
00:06:37,950 --> 00:06:40,080
cat ，还有
you know cat, you know, all the util

188
00:06:40,080 --> 00:06:41,970
你在实验一中构建的
things, that you've built in

189
00:06:41,970 --> 00:06:44,520
所有实用工具，
lab one, and we have

190
00:06:44,630 --> 00:06:48,440
我们还有内核，内核在下面，
the kernel, the kernel sitting below,

191
00:06:48,440 --> 00:06:49,790
操作系统在
the operating system sitting in

192
00:06:49,790 --> 00:06:50,860
内核空间里。
kernel space.

193
00:06:51,320 --> 00:06:52,730
你知道，
And you know what we like

194
00:06:52,730 --> 00:06:55,100
我们要做的是
to do is sort of have

195
00:06:55,100 --> 00:06:57,880
把这些应用程序框起来，
you know boxes around these

196
00:06:58,240 --> 00:07:00,850
这样它们
applications, so that they can't

197
00:07:00,850 --> 00:07:03,100
就不会真正相互影响，
really affect each other and similar

198
00:07:03,100 --> 00:07:06,010
类似的，我们希望它们
we want them to be completely

199
00:07:06,010 --> 00:07:07,930
完全独立于内核和操作系统，
independent of the kernel,

200
00:07:07,930 --> 00:07:09,310
这样即使
the operating system, so that if

201
00:07:09,310 --> 00:07:11,620
一个应用程序做了
an application does something either accidentally

202
00:07:11,620 --> 00:07:13,600
一些意外或恶意的事情，
bad or maliciously bad,

203
00:07:13,600 --> 00:07:14,950
也不会
that doesn't really affect the

204
00:07:14,950 --> 00:07:15,900
真正影响操作系统。
operating system.

205
00:07:16,580 --> 00:07:19,010
这就是我们的目标，
So that's our goal and the

206
00:07:19,010 --> 00:07:21,380
今天我们关注的
particular aspect of the problem that

207
00:07:21,380 --> 00:07:23,360
具体方面是
we want to focus on today

208
00:07:23,360 --> 00:07:25,220
内存方面的问题，
is the memory side of things,

209
00:07:25,220 --> 00:07:26,390
所以我们关注的是
so we really want to

210
00:07:26,390 --> 00:07:28,120
内存隔离。
focus on memory isolation.

211
00:07:29,920 --> 00:07:31,900
默认情况下，
And by default,

212
00:07:31,900 --> 00:07:33,430
如果我们什么都不做，
if we don't do anything,

213
00:07:33,430 --> 00:07:35,470
我们就没有内存隔离，
we don't really have memory isolation,

214
00:07:35,470 --> 00:07:37,180
因为如果你想一下，
because if you think about

215
00:07:37,180 --> 00:07:38,890
这有一个 RISC-V 板，
it, there's going to be one

216
00:07:38,890 --> 00:07:40,480
就是我上周给你们
RISC-V board that I showed

217
00:07:40,480 --> 00:07:41,140
展示的那个，
you last week,

218
00:07:41,140 --> 00:07:42,730
它有一个内存，
it has a memory,

219
00:07:42,730 --> 00:07:44,220
一堆 DRAM 芯片，
a bunch of DRAM chips,

220
00:07:44,630 --> 00:07:46,490
在 DRAM 芯片中
and the in the DRAM

221
00:07:46,490 --> 00:07:48,200
存储着
chips, the code for

222
00:07:48,200 --> 00:07:49,460
这些应用程序的代码，
these applications

223
00:07:49,460 --> 00:07:53,060
内存中的
is stored, somewhere in memory

224
00:07:53,060 --> 00:07:55,820
某个地方是内核，文本数据堆栈或其他，
is the kernel, text data stack

225
00:07:55,820 --> 00:07:58,280
如果 shell 正在运行，
everything, somewhere in memory used to

226
00:07:58,280 --> 00:07:59,740
内存中的某个地方是 shell ，
shell if the shell is running,

227
00:07:59,980 --> 00:08:02,680
还有某个地方是 cat 程序。
somewhere in memory the cat program.

228
00:08:04,640 --> 00:08:05,750
所以有一种物理内存，你知道，从零开始，到你知道的大地址，并不取决于我们的机器真正有多少内存，在那个物理内存中，所有这些程序都必须存在。
And so there's one sort of

229
00:08:05,750 --> 00:08:06,410
physical memory,

230
00:08:06,410 --> 00:08:07,280
you know starting from someone

231
00:08:07,280 --> 00:08:09,170
from zero to you know

232
00:08:09,170 --> 00:08:11,420
big big address, no

233
00:08:11,420 --> 00:08:12,500
depending how much memory we

234
00:08:12,500 --> 00:08:13,430
have really have in our

235
00:08:13,430 --> 00:08:15,020
machine and in that physical

236
00:08:15,020 --> 00:08:16,340
memory all these programs must

237
00:08:16,340 --> 00:08:17,140
be present.

238
00:08:17,230 --> 00:08:19,330
是啊，否则你就会知道处理器甚至不能执行他们的指令。
Yeah, otherwise you know the processor

239
00:08:19,330 --> 00:08:21,340
can't even execute their instructions.

240
00:08:22,420 --> 00:08:23,470
这就是风险所在，你清楚地知道这里是什么，让我们说你知道，让我们做一点，你知道，简单化，但让我们说外壳，你知道，对于最小地址0到200,2000到2000，你知道的，你知道的，坐在一个最小的地址0到200,2000到2000之间。
This is what the risk, you

241
00:08:23,470 --> 00:08:25,300
know clearly here is, that let's

242
00:08:25,300 --> 00:08:26,860
say you know let's make a

243
00:08:26,860 --> 00:08:27,310
little bit,

244
00:08:27,310 --> 00:08:28,780
you know simplistic but let's say

245
00:08:28,780 --> 00:08:29,950
the shell,

246
00:08:29,950 --> 00:08:31,300
you know sits for a min

247
00:08:31,300 --> 00:08:33,620
address zero to address 200,

248
00:08:34,830 --> 00:08:36,920
two thousand one thousand to 2000.

249
00:08:37,720 --> 00:08:39,220
假设你知道，你知道，不管什么猫有编程错误，嗯，它加载到，你知道的寄存器a0中。
And let's say you know the

250
00:08:39,220 --> 00:08:40,810
you know whatever cat has a

251
00:08:40,810 --> 00:08:41,890
programming error,

252
00:08:41,890 --> 00:08:43,570
um, it loads,

253
00:08:43,570 --> 00:08:47,060
you know in register a0.

254
00:08:47,770 --> 00:08:49,720
假设加载的千位地址基本上对应于外壳的开始，然后你知道，意外地执行了指令，你知道，$7，a0。
Let's say loads the thousand

255
00:08:49,720 --> 00:08:52,030
address basically corresponding to the

256
00:08:52,030 --> 00:08:54,010
start of the shell and then

257
00:08:54,010 --> 00:08:55,060
you know by accident,

258
00:08:55,060 --> 00:08:57,580
you know, executes the instruction,

259
00:08:57,800 --> 00:09:01,660
you know, $7, a0.

260
00:09:03,010 --> 00:09:04,210
它的作用是，基本上它将值7写到地址1000，所以它会在基本上属于shell的内存映像上乱涂乱画。
Which has the effect of that,

261
00:09:04,210 --> 00:09:05,980
basically it writes the value 7

262
00:09:05,980 --> 00:09:08,230
to the address 1000 and so

263
00:09:08,230 --> 00:09:10,240
it would be scribbling over you

264
00:09:10,240 --> 00:09:12,550
know the basically the memory image,

265
00:09:12,550 --> 00:09:14,220
um that belongs to shell.

266
00:09:14,860 --> 00:09:15,130
因此，我们肯定不会，肯定会打破孤立，是相当不受欢迎的。
And so,

267
00:09:15,130 --> 00:09:17,590
we're certainly not, certain

268
00:09:17,590 --> 00:09:20,380
would break isolation, and be

269
00:09:20,380 --> 00:09:21,780
quite undesirable.

270
00:09:22,400 --> 00:09:24,350
所以我们想要一些东西，从根本上把这些记忆从不同的程序中分离出来，这样就不会发生这样的事情了。
And so we want something that

271
00:09:24,350 --> 00:09:26,510
basically really separates these memories from

272
00:09:26,510 --> 00:09:27,860
the different programs from each other,

273
00:09:27,860 --> 00:09:29,060
so that things like that just

274
00:09:29,060 --> 00:09:30,080
cannot happen.

275
00:09:31,590 --> 00:09:33,450
要做到这一点，一种方法是，嗯，你知道，这是一种通常被称为地址空间的想法。
So one way, to do that,

276
00:09:33,450 --> 00:09:36,120
um is an idea that's you

277
00:09:36,120 --> 00:09:38,120
know typically called address spaces.

278
00:09:44,500 --> 00:09:47,920
基本思想很简单，我们想要做的基本上是给每个应用程序，包括内核，它自己的地址空间。
And the basic idea is straightforward,

279
00:09:47,920 --> 00:09:49,300
what we wanna do is basically

280
00:09:49,300 --> 00:09:52,580
give every application including the kernel,

281
00:09:52,670 --> 00:09:54,060
its own address space.

282
00:09:55,080 --> 00:09:56,310
所以我们可以像使用猫奔跑一样思考这个问题。
And so we can think about

283
00:09:56,310 --> 00:09:58,260
this like we use cat running.

284
00:09:58,780 --> 00:09:59,800
你知道它有一个从0开始的地址空间，你知道做任何最大的值，你知道shell run有一个地址空间，它自己的地址空间，也从地址0开始，嗯，到某个值你知道内核有它自己的地址空间。
You know it has an address

285
00:09:59,800 --> 00:10:01,870
space starting at 0, you know

286
00:10:01,870 --> 00:10:04,390
do whatever maximum value, you know

287
00:10:04,390 --> 00:10:06,430
shell run has an address space, its

288
00:10:06,430 --> 00:10:07,330
own address space,

289
00:10:07,330 --> 00:10:09,130
also starting at address 0,

290
00:10:09,130 --> 00:10:11,530
um, going to some value

291
00:10:11,530 --> 00:10:12,490
you know the kernel has

292
00:10:12,490 --> 00:10:13,780
its own address space.

293
00:10:14,660 --> 00:10:15,680
操作系统有自己的地址空间。
OS has its own

294
00:10:15,680 --> 00:10:16,680
address space.

295
00:10:17,640 --> 00:10:18,750
所以，有一个例子，当我们提到猫的时候，我们回到上一张幻灯片的例子，我们确实是这样做的。
And so,

296
00:10:18,750 --> 00:10:20,340
one example when cat you know

297
00:10:20,340 --> 00:10:21,900
refers to, we go back to

298
00:10:21,900 --> 00:10:23,880
our example of the previous slide

299
00:10:23,880 --> 00:10:25,320
where we did.

300
00:10:25,470 --> 00:10:29,130
嗯，不管7号店到哪家店，你都知道0。
Um, whatever store 7 to, you

301
00:10:29,130 --> 00:10:30,580
know a0.

302
00:10:30,930 --> 00:10:32,730
比方说在0中，1000就有价值。
And let's say in a0,

303
00:10:32,730 --> 00:10:34,740
there's value in 1000.

304
00:10:34,840 --> 00:10:36,400
你知道如果可以执行一条指令，它会写到地址1000，但它是它自己的地址1000，不是的，你知道外壳的1000的地址。
You know if can execute

305
00:10:36,400 --> 00:10:37,540
an instruction,

306
00:10:37,540 --> 00:10:39,130
it will write to the address 1000,

307
00:10:40,420 --> 00:10:41,740
but it is its own

308
00:10:41,740 --> 00:10:42,970
address 1000,

309
00:10:42,970 --> 00:10:43,690
it's not,

310
00:10:43,690 --> 00:10:45,010
you know the address of the

311
00:10:45,010 --> 00:10:46,360
1000 of the shell.

312
00:10:46,390 --> 00:10:48,760
所以基本上，每个程序都有自己的地址空间，有自己的值，这些地址是完全独立的。
So basically, every program runs with

313
00:10:48,760 --> 00:10:50,320
its own address space, has its

314
00:10:50,320 --> 00:10:52,870
own value and those addresses are

315
00:10:52,870 --> 00:10:54,160
completely independent.

316
00:10:54,380 --> 00:10:56,120
嗯，你知道这个不同地址空间的概念，CAT甚至没有能力引用一个地址，那实际上是属于shell的。
Um, you know this notion of

317
00:10:56,120 --> 00:10:57,590
different address spaces,

318
00:10:57,590 --> 00:10:59,540
cat doesn't really have an ability to

319
00:10:59,540 --> 00:11:01,940
even refer to an address, that

320
00:11:01,940 --> 00:11:03,680
actually belongs to the shell.

321
00:11:04,900 --> 00:11:07,240
所以这就是我们想要达到的最终目标，因为它将给我们提供强大的隔离，因为你知道，猫不可能引用任何不属于它自己的其他记忆。这就是我们想要达到的最终目标，因为它将给我们提供强大的隔离，因为你知道，猫不可能引用任何不属于它自己的记忆。
And so that's sort of the

322
00:11:07,240 --> 00:11:09,160
game that were the end goal

323
00:11:09,160 --> 00:11:10,630
that we'd like to achieve, because

324
00:11:10,630 --> 00:11:11,530
it's going to provide us with

325
00:11:11,530 --> 00:11:13,690
strong isolation, because you know it's

326
00:11:13,690 --> 00:11:15,010
just not possible for cat to

327
00:11:15,010 --> 00:11:16,480
refer to any other memory that

328
00:11:16,480 --> 00:11:18,100
is not, you know, its own.

329
00:11:19,080 --> 00:11:19,350
因此，我们现在的目标基本上是解决如何在单个物理内存上多路复用所有这些不同的地址，因为最终，我们只有一堆DRAM芯片。
And so,

330
00:11:19,350 --> 00:11:20,790
our goal now basically

331
00:11:20,790 --> 00:11:22,980
sort of figure out how to

332
00:11:22,980 --> 00:11:25,200
multiplex if you will all these

333
00:11:25,200 --> 00:11:28,260
different address bases on a single

334
00:11:28,260 --> 00:11:29,190
physical memory,

335
00:11:29,190 --> 00:11:29,970
because in the end,

336
00:11:29,970 --> 00:11:31,050
we only have a bunch of

337
00:11:31,050 --> 00:11:32,140
dram chips.

338
00:11:32,240 --> 00:11:33,800
嗯，你知道吗，公羊芯片是用来看记忆的。
Um, were you know, ram

339
00:11:33,800 --> 00:11:35,720
chips were the memories look at.

340
00:11:36,950 --> 00:11:37,790
所以，嗯，所以我计划好了，是的，我在这里。如果你有问题，请便。
And so,

341
00:11:40,210 --> 00:11:41,470
Um, and so I sort of

342
00:11:41,470 --> 00:11:42,010
plan okay,

343
00:11:42,010 --> 00:11:43,150
yeah I'm here. You have

344
00:11:43,150 --> 00:11:43,510
a question,

345
00:11:43,510 --> 00:11:44,240
go ahead.

346
00:11:46,240 --> 00:11:47,380
嗯，所以我想知道，在物理硬件的配置中，只有这么大的空间，而在虚拟内存布局中，还有一个最大的虚拟地址被设计成足够小的虚拟地址。
Um, so I'm wondering,

347
00:11:47,380 --> 00:11:50,500
in the configuration of the

348
00:11:50,500 --> 00:11:52,030
physical hardware,

349
00:11:52,030 --> 00:11:54,550
there's only so much space and

350
00:11:54,550 --> 00:11:56,590
in the virtual memory layout,

351
00:11:56,590 --> 00:11:59,230
there's also a max virtual address

352
00:11:59,230 --> 00:12:02,230
by design is the virtual address

353
00:12:02,230 --> 00:12:04,180
made to be small enough.

354
00:12:04,500 --> 00:12:06,930
不，不一定，您知道虚拟地址空间可能比物理内存大，物理内存可能比虚拟地址空间大，我们很快就会看到这一切是如何发生的，它实际上会拉动各个部分，就像我们将在页表中看到的那样，嗯，这是非常灵活的。
No, not necessarily,

355
00:12:06,930 --> 00:12:08,100
you know the virtual address

356
00:12:08,100 --> 00:12:09,240
space could be bigger than

357
00:12:09,240 --> 00:12:09,990
the physical memory,

358
00:12:09,990 --> 00:12:11,160
the physical memory could be bigger

359
00:12:11,160 --> 00:12:13,170
than the virtual address space

360
00:12:13,170 --> 00:12:13,950
and we'll see in a second

361
00:12:13,950 --> 00:12:15,240
how it all can happen and

362
00:12:15,240 --> 00:12:17,040
it's actually going to pull parts

363
00:12:17,040 --> 00:12:18,540
about, as we'll see with

364
00:12:18,540 --> 00:12:19,560
page tables,

365
00:12:19,560 --> 00:12:21,420
um that's extremely flexible.

366
00:12:22,120 --> 00:12:23,470
那么，有没有可能，就像物理内存耗尽一样。
So, is it, is it

367
00:12:23,470 --> 00:12:25,690
possible that like the physical

368
00:12:25,690 --> 00:12:27,940
memory gets exhausted.

369
00:12:28,250 --> 00:12:30,500
嗯，因为这么多进程使用了所有的虚拟空间，是的，这当然是可能的，我们将在第二部分看到，例如，你知道你有一堆大型应用程序，每个应用程序都有很大的页表，它们分配了很多内存，你知道有些时候内存会用完。
Um, because so many processes use

370
00:12:30,500 --> 00:12:31,940
all their virtual space,

371
00:12:31,940 --> 00:12:34,790
yeah that's certainly possible and we'll

372
00:12:34,790 --> 00:12:35,780
see in the second, how,

373
00:12:35,780 --> 00:12:36,980
for example you know you have

374
00:12:36,980 --> 00:12:38,750
a bunch of big applications that

375
00:12:38,750 --> 00:12:40,340
each have big page tables,

376
00:12:40,340 --> 00:12:41,510
they allocate a lot of memory,

377
00:12:41,510 --> 00:12:42,350
you know some point you run

378
00:12:42,350 --> 00:12:43,260
out of memory.

379
00:12:43,810 --> 00:12:44,320
我明白了，谢谢。那么，有没有人知道这在xv6中有什么用武之地呢？
I see,

380
00:12:44,320 --> 00:12:46,840
thanks. And so where does this

381
00:12:46,840 --> 00:12:49,060
show up xv6, anybody.

382
00:12:52,530 --> 00:12:54,100
你，你确定吗。
You, you sure.

383
00:12:54,430 --> 00:12:55,720
我在SysCall实验室谈到了一点，就是您目前正在做的事情。
Touched on a little bit

384
00:12:55,720 --> 00:12:57,550
in the syscall lab, that

385
00:12:57,550 --> 00:12:58,660
you're currently doing.

386
00:13:01,330 --> 00:13:02,920
分配页面的位置。
Where page is allocated.

387
00:13:08,670 --> 00:13:10,650
或者，您做的是syscall实验室，但是您在syscall实验室的一个部分完成了它，打印了多少空闲内存地址。
or, you do the syscall lab

388
00:13:10,650 --> 00:13:11,940
but you finished it in one

389
00:13:11,940 --> 00:13:13,380
part of the syscall lab,

390
00:13:13,380 --> 00:13:15,400
printing how much free memory address.

391
00:13:17,730 --> 00:13:20,220
卡洛克？是的，卡洛克，对，卡洛克，我有一个长达三页的单子。
Kalloc? Yeah, kalloc, right,

392
00:13:20,220 --> 00:13:21,270
for kalloc, I have some list of

393
00:13:21,270 --> 00:13:22,340
three pages.

394
00:13:22,420 --> 00:13:23,740
如果三页列表在某一时刻为空或用完。
If that list of three pages

395
00:13:23,740 --> 00:13:25,330
it empty or runs out at

396
00:13:25,330 --> 00:13:26,160
some point.

397
00:13:26,150 --> 00:13:27,590
然后，你知道，kalloc将返回一个空指针，希望这个操作能做一些明智的事情，基本上传播回用户应用程序，说，好吧，你知道没有更多的内存给你，或者没有人有更多的内存。
Then, you know, kalloc is going

398
00:13:27,590 --> 00:13:29,750
to return a null pointer and

399
00:13:29,750 --> 00:13:31,880
hopefully the operation does something sensible

400
00:13:31,880 --> 00:13:33,380
that basically propagated back to the

401
00:13:33,380 --> 00:13:35,150
user application saying like well, you

402
00:13:35,150 --> 00:13:36,530
know no more memory for you

403
00:13:36,530 --> 00:13:38,120
or no more memory in total

404
00:13:38,120 --> 00:13:38,960
for nobody.

405
00:13:43,120 --> 00:13:44,350
好的?然后，操作系统只需要做一项工作就可以很好地处理这些情况，这通常意味着将错误消息传播到用户应用程序。
Ok? Then just a job for OS

406
00:13:44,350 --> 00:13:46,480
to handle those cases gracefully where

407
00:13:46,480 --> 00:13:48,700
basically generally means propagating an error

408
00:13:48,700 --> 00:13:50,320
message to user application.

409
00:13:57,280 --> 00:13:58,940
好的，很好。
Okay, good.

410
00:13:59,410 --> 00:14:00,820
那么如何实现这些地址空间，您知道基本上如何在单个物理内存中多路复用所有这些地址空间，最常用的方法和非常灵活的方法是使用页表。
So how do you implement these

411
00:14:00,820 --> 00:14:01,780
address spaces,

412
00:14:01,780 --> 00:14:03,640
you know how basically multiplex

413
00:14:03,640 --> 00:14:05,050
all these address spaces across a

414
00:14:05,050 --> 00:14:08,440
single physical memory and the most

415
00:14:08,440 --> 00:14:10,480
common approach and a very flexible

416
00:14:10,480 --> 00:14:12,840
approach is to use page tables.

417
00:14:17,360 --> 00:14:18,830
嗯，这个想法是，嗯，这是一项艰苦的工作支持，所以这是由处理器或由一个称为内存管理单元的单元在硬件中实现的，所以你应该想到的画面是，你知道，执行指令的CPU，无论是什么，你知道，嗯，我们的存储指令，你知道，你知道，把7美元放到一个间接的0中。
Um the idea is,

418
00:14:18,830 --> 00:14:20,270
um, this is a hard

419
00:14:20,270 --> 00:14:21,080
work support,

420
00:14:21,080 --> 00:14:23,540
so this is implemented in hardware

421
00:14:23,540 --> 00:14:25,910
by the processor or by a

422
00:14:25,910 --> 00:14:28,040
unit called the memory management unit,

423
00:14:28,040 --> 00:14:29,390
so the picture that you should

424
00:14:29,390 --> 00:14:31,070
have your head is, you know

425
00:14:31,070 --> 00:14:32,360
the CPU,

426
00:14:32,730 --> 00:14:35,940
that executes instructions, whatever are,

427
00:14:35,940 --> 00:14:36,720
you know,

428
00:14:38,580 --> 00:14:40,440
um, our store instruction that

429
00:14:40,440 --> 00:14:41,640
was you know putting $7

430
00:14:41,640 --> 00:14:47,180
into a0 indirect.

431
00:14:47,560 --> 00:14:48,790
也执行这些类型的指令，您知道它何时执行它们的STOR指令之一，LOAD指令，任何实际有地址的指令。
Also executes those kind of

432
00:14:48,790 --> 00:14:51,010
instructions and you know when

433
00:14:51,010 --> 00:14:51,970
it executes one of their

434
00:14:51,970 --> 00:14:53,380
stor instruction, load instruction,

435
00:14:53,380 --> 00:14:54,850
whatever anything that actually has

436
00:14:54,850 --> 00:14:55,780
an address.

437
00:14:55,810 --> 00:14:57,610
你现在，那个地址，我们会把它看作一个虚拟地址，所以它不是一个物理地址，而是一个虚拟地址。
You now, that address we're going

438
00:14:57,610 --> 00:14:58,270
to think about it as

439
00:14:58,270 --> 00:14:59,230
a virtual address,

440
00:14:59,230 --> 00:15:00,370
so it's not a physical address,

441
00:15:00,370 --> 00:15:01,560
it's a virtual address.

442
00:15:02,100 --> 00:15:02,400
例如，我们在这里使用的a0中的值，嗯，是的，假设是1000，0x1000数据是一个虚拟地址，虚拟地址基本上是通过所谓的内存管理单元路由的。
And so,

443
00:15:02,400 --> 00:15:03,630
for example the value in a0

444
00:15:03,630 --> 00:15:05,250
that we're using here,

445
00:15:05,250 --> 00:15:08,400
um, yeah, say that's 1000,

446
00:15:08,760 --> 00:15:11,160
0x1000 data is a

447
00:15:11,160 --> 00:15:13,170
virtual address and virtual addresses basically

448
00:15:13,170 --> 00:15:15,840
routed through something what's called

449
00:15:15,840 --> 00:15:17,860
the memory management unit.

450
00:15:21,180 --> 00:15:23,580
嗯，并且存储器管理器单元转换成物理地址。
Um, and the memory manager unit

451
00:15:23,580 --> 00:15:26,380
translates into a physical address.

452
00:15:27,680 --> 00:15:29,990
然后该物理地址实际上被用来索引到存储器中。
And that physical address then was

453
00:15:29,990 --> 00:15:32,920
actually used to index into memory.

454
00:15:33,120 --> 00:15:35,550
并加载或存储需要写入的任何值。
And load whatever value or

455
00:15:35,550 --> 00:15:37,230
store whatever value needs to be

456
00:15:37,230 --> 00:15:37,940
written there.

457
00:15:38,720 --> 00:15:40,460
嗯，所以CPU从CPU的角度来看，它总是发出，一旦MMU使用，它发出的每条指令都启用了我们的虚拟地址。
Um, and so the CPU from

458
00:15:40,460 --> 00:15:41,630
the CPU point of view,

459
00:15:41,630 --> 00:15:42,710
it always issues,

460
00:15:42,710 --> 00:15:44,720
every instruction that issues,

461
00:15:44,720 --> 00:15:46,940
once the MMU use, enabled

462
00:15:46,940 --> 00:15:48,320
our virtual addresses.

463
00:15:49,100 --> 00:15:51,080
为了将这些虚拟地址转换成物理地址，基本上，MMU有一个表。
And to translate these virtual addresses

464
00:15:51,080 --> 00:15:52,850
to physical addresses, basically,

465
00:15:52,850 --> 00:15:54,200
MMU has a table.

466
00:15:55,080 --> 00:15:57,090
你知道，虚拟地址在一边，物理地址在一边，另一边，例如，这里是我们的1000的条目，可能映射到任何，你知道，0x任何你正在虚构的东西，比如某个大的值，在物理内存中的某个地方。
And you know virtual address

467
00:15:57,090 --> 00:15:58,260
on one side, physical address

468
00:15:58,260 --> 00:15:59,340
on one side,

469
00:15:59,340 --> 00:16:01,650
the other side, for example here is

470
00:16:01,650 --> 00:16:05,040
our entry for 1000 and maybe

471
00:16:05,040 --> 00:16:07,340
that maps to whatever,

472
00:16:07,860 --> 00:16:09,930
you know, 0x whatever you're

473
00:16:09,930 --> 00:16:11,280
making something up with like

474
00:16:11,280 --> 00:16:12,600
some big value,

475
00:16:13,020 --> 00:16:14,490
somewhere in physical memory.

476
00:16:14,490 --> 00:16:16,200
所以虚拟地图和物理地图之间的这种映射。
So this mapping between virtual and

477
00:16:16,200 --> 00:16:17,360
physical map.

478
00:16:17,390 --> 00:16:19,260
嗯，相当灵活。
Um, it's quite flexible.

479
00:16:19,880 --> 00:16:20,900
因此，在一侧，我们有物理地址的另一侧的虚拟地址。
And so on one side,

480
00:16:20,900 --> 00:16:21,830
we have the virtual address

481
00:16:21,830 --> 00:16:22,460
of the other side of

482
00:16:22,460 --> 00:16:23,580
the physical addresses.

483
00:16:26,030 --> 00:16:28,580
通常，您知道此映射本身也存储在内存中。
Typically, you know this mapping itself

484
00:16:28,580 --> 00:16:29,900
is also stored in memory.

485
00:16:30,160 --> 00:16:31,660
所以CPU有一些基本上指向的寄存器，它包含存储页表的物理地址。
And so the CPU has some

486
00:16:31,660 --> 00:16:35,020
register that basically points to,

487
00:16:35,090 --> 00:16:37,190
that contains the physical

488
00:16:37,190 --> 00:16:39,230
address of where the page

489
00:16:39,230 --> 00:16:40,480
table is stored.

490
00:16:40,670 --> 00:16:42,650
所以基本上是在页表中的某个地方，或者只是映射存储在物理内存中的某个地方。
So somewhere in basically the page

491
00:16:42,650 --> 00:16:44,450
table or just map somewhere stored

492
00:16:44,450 --> 00:16:45,620
in physical memory.

493
00:16:45,770 --> 00:16:47,120
比方说，你知道，不管怎么说，地址10，基本上就是在RISC-V SATP上调用的这个寄存器。
Let's say, you know,

494
00:16:47,120 --> 00:16:49,620
whatever, address 10,

495
00:16:49,860 --> 00:16:51,810
basically this register which is

496
00:16:51,810 --> 00:16:54,560
called on the RISC-V satp.

497
00:16:54,740 --> 00:16:57,770
您知道存储地址10，因此，CPU可以告诉内存管理单元在哪里查找，您知道，基本上是将虚拟地址转换为物理地址的映射。
You know stores the address 10

498
00:16:57,770 --> 00:17:00,320
and so, that the CPU

499
00:17:00,320 --> 00:17:01,940
can tell the memory managed units

500
00:17:01,940 --> 00:17:05,210
where to find, you know, basically the map

501
00:17:05,210 --> 00:17:07,640
to actually translate virtual to

502
00:17:07,640 --> 00:17:08,700
physical addresses.

503
00:17:10,020 --> 00:17:11,250
然后，基本的想法是给每个应用程序提供它自己的地图。
And then the basic idea

504
00:17:11,250 --> 00:17:12,900
is to give every application

505
00:17:12,900 --> 00:17:13,860
it's own map.

506
00:17:14,320 --> 00:17:15,760
所以猫会有，它是地图。哎呀。
So cat is going

507
00:17:15,760 --> 00:17:16,240
to have,

508
00:17:16,240 --> 00:17:17,740
it's map. Oops.

509
00:17:19,110 --> 00:17:20,360
所以每一张地图都是自己的..。
So every map, it's own...

510
00:17:23,360 --> 00:17:27,400
是的，[大本钟]，去吧。
Yeah, [Big Ben], go ahead.

511
00:17:29,420 --> 00:17:31,790
嗯，那么MMU，您说它不一定存储地图。
Um, so the MMU,

512
00:17:31,790 --> 00:17:35,120
you said it doesn't necessarily store

513
00:17:35,120 --> 00:17:36,140
the mapping.

514
00:17:36,190 --> 00:17:38,590
所以它只是，只是做翻译，就像它会读取内存并进行翻译一样，但不一定存储映射。
So does it just,

515
00:17:38,590 --> 00:17:40,480
just do the translation like

516
00:17:40,480 --> 00:17:42,190
it will read the memory

517
00:17:42,190 --> 00:17:43,480
and do the translation,

518
00:17:43,480 --> 00:17:45,040
but not necessarily

519
00:17:45,160 --> 00:17:46,870
store the mappings.

520
00:17:46,870 --> 00:17:48,670
这正是你应该有头脑的照片。
That's exactly the right picture that

521
00:17:48,670 --> 00:17:49,800
you should have your head.

522
00:17:52,960 --> 00:17:55,510
但是每张地图，好的，所以地图本身存储了记忆，MMU基本上只是走进或者看着地图，我们很快就会看到，你知道，这张地图比我在这里画的稍微复杂一些。
But every map, okay, so the

523
00:17:55,510 --> 00:17:57,040
map itself stored memory,

524
00:17:57,040 --> 00:17:58,900
the MMU just basically walks or

525
00:17:58,900 --> 00:18:00,310
looks into the map and we'll

526
00:18:00,310 --> 00:18:01,330
see in a second, you know,

527
00:18:01,330 --> 00:18:02,770
this map is slightly more complicated

528
00:18:02,770 --> 00:18:04,160
than I used draw here.

529
00:18:05,340 --> 00:18:07,080
嗯，所以每个应用都有自己的，自己的地图。
Um, so every app has

530
00:18:07,080 --> 00:18:10,740
its own, its own map.

531
00:18:12,320 --> 00:18:14,450
对，这个映射基本上定义了它的地址空间。
Right, and that map basically defines

532
00:18:14,450 --> 00:18:15,720
its address space.

533
00:18:16,380 --> 00:18:18,270
因此，当使用CPU时或当操作系统将CPU从一个应用程序切换到另一个应用程序时，它还切换该SATP寄存器的内容以存储适当进程的映射的根。
And so when with the CPU or

534
00:18:18,270 --> 00:18:19,860
when the operating system switches the

535
00:18:19,860 --> 00:18:21,870
CPU from one process from one

536
00:18:21,870 --> 00:18:23,610
application to another application,

537
00:18:23,610 --> 00:18:25,380
it also switches the content

538
00:18:25,380 --> 00:18:26,080
of this

539
00:18:26,130 --> 00:18:29,310
satp register to store

540
00:18:29,310 --> 00:18:31,410
the root of the map of

541
00:18:31,410 --> 00:18:32,740
the appropriate process.

542
00:18:33,400 --> 00:18:34,660
因此，通过这种方式，基本上您知道在CPU上运行多个应用程序，每次我们从一个应用程序切换到下一个应用程序时，我们还会切换SATP寄存器以指向该应用程序的适当映射。
And so in that way,

543
00:18:34,660 --> 00:18:36,580
basically you know multiple applications to

544
00:18:36,580 --> 00:18:37,420
run on the

545
00:18:37,420 --> 00:18:38,770
CPU, every time we switch

546
00:18:38,770 --> 00:18:40,030
between from one application to the

547
00:18:40,030 --> 00:18:41,080
next application,

548
00:18:41,080 --> 00:18:43,900
we also switch the satp

549
00:18:43,900 --> 00:18:45,820
register to point to the appropriate

550
00:18:45,820 --> 00:18:47,160
map for that application.

551
00:18:47,420 --> 00:18:48,170
通过这种方式，基本上，您所知道的cat虚拟地址的转换方式与shell的虚拟地址的转换方式不同，因为您知道每个虚拟地址都有自己的映射。
And in that way,

552
00:18:48,170 --> 00:18:51,290
basically, virtual addresses you know

553
00:18:51,290 --> 00:18:54,590
for cat are translated differently,

554
00:18:54,590 --> 00:18:56,960
than the virtual addresses for the

555
00:18:56,960 --> 00:18:58,280
shell, because you know each one

556
00:18:58,280 --> 00:18:59,800
of them has their own map.

557
00:19:02,380 --> 00:19:03,240
这事儿可以理解。
That makes sense.

558
00:19:07,710 --> 00:19:10,170
好的，我们也是，这是基本的计划，到目前为止，我画的或者将要解释的方式，是相当幼稚的，也是不合理的。
Okay, so do we, this is the

559
00:19:10,170 --> 00:19:12,060
basic plan and the way I've

560
00:19:12,060 --> 00:19:14,340
drawn or gonna explain it so

561
00:19:14,340 --> 00:19:16,050
far it's pretty naive,

562
00:19:16,050 --> 00:19:17,980
and unreasonable.

563
00:19:18,230 --> 00:19:19,880
嗯，是的，大卫，说吧。
Um, yeah, David, go ahead.

564
00:19:20,820 --> 00:19:21,450
很抱歉，您说的SATP寄存器为进程修改了a，我猜每个进程的FOR SATP寄存器的值都是由内核存储的。
I'm sorry,

565
00:19:22,880 --> 00:19:25,610
So, the you said the

566
00:19:25,610 --> 00:19:28,070
satp register gets modified a

567
00:19:28,070 --> 00:19:30,110
for the process, I am guessing

568
00:19:30,110 --> 00:19:32,270
the value of for

569
00:19:32,270 --> 00:19:34,680
satp register for each process

570
00:19:34,730 --> 00:19:36,500
is stored by the kernel.

571
00:19:36,500 --> 00:19:37,550
是的，内核正在写入SATP寄存器，实际上写入或读取特定写入SATP寄存器是特权指令。
Yes yes,

572
00:19:37,550 --> 00:19:39,230
the kernel is writing satp register,

573
00:19:39,230 --> 00:19:41,510
in fact writing or reading a

574
00:19:41,510 --> 00:19:44,030
particular writing the satp register is

575
00:19:44,030 --> 00:19:45,300
a privilege instruction.

576
00:19:45,830 --> 00:19:48,290
因此，用户应用程序不能只更新页面映射寄存器，然后说我现在要使用此页面映射运行。
So user application cannot just

577
00:19:48,290 --> 00:19:50,060
update the page map register, and

578
00:19:50,060 --> 00:19:50,990
say like I want to run

579
00:19:50,990 --> 00:19:52,320
with this page map now.

580
00:19:52,460 --> 00:19:52,910
因为，那会违反孤立。
Because,

581
00:19:52,910 --> 00:19:55,800
that would violate isolation.

582
00:19:56,070 --> 00:19:57,690
所以它只是内核，只有内核模式下的代码才能真正更新它。
So it's only the kernel, only

583
00:19:57,690 --> 00:19:58,980
code in kernel mode can actually

584
00:19:58,980 --> 00:19:59,780
update it.

585
00:20:01,100 --> 00:20:02,000
我明白了。
I see.

586
00:20:03,730 --> 00:20:05,110
好的，正如我所说的，这张图片相当幼稚，你知道有一件事我没有真正说过这张地图是如何工作的。
Okay, so as I said this

587
00:20:05,110 --> 00:20:06,190
picture is pretty naive,

588
00:20:06,190 --> 00:20:07,420
you know one thing I

589
00:20:07,420 --> 00:20:08,860
haven't really said anything about how

590
00:20:08,860 --> 00:20:10,440
this actually map works.

591
00:20:10,750 --> 00:20:12,160
嗯，而且，你知道，我画出来的方式似乎表明，基本上每个虚拟地址，你在地图上都有一个条目。
Um, and,

592
00:20:12,160 --> 00:20:13,420
you know the way I've

593
00:20:13,420 --> 00:20:15,250
drawn out seems to indicate a

594
00:20:15,250 --> 00:20:17,350
basically for every virtual address,

595
00:20:17,350 --> 00:20:18,070
you have an entry in

596
00:20:18,070 --> 00:20:18,720
the map.

597
00:20:19,440 --> 00:20:21,450
嗯，如果你这么做了，那在RISC-V上会有多大的影响呢？
Um, and if you do that,

598
00:20:21,450 --> 00:20:22,860
how big would that be

599
00:20:25,400 --> 00:20:26,540
on RISC-V.

600
00:20:36,150 --> 00:20:37,470
RISC-V上原则上有多少地址，或者有多大，有多少地址进入寄存器存储。
How many addresses are there on

601
00:20:37,470 --> 00:20:38,910
the RISC-V in principle, or

602
00:20:38,910 --> 00:20:40,650
how big, how many addresses go

603
00:20:40,650 --> 00:20:41,860
to registers store.

604
00:20:46,100 --> 00:20:48,560
寄存器是64位宽，那么有多少个地址呢？
Registers are 64 bit wide,

605
00:20:48,560 --> 00:20:49,900
so how many addresses.

606
00:20:53,830 --> 00:20:55,240
我知道，问这些问题是对你智力的侮辱。
I know, so insulting your

607
00:20:55,240 --> 00:20:57,320
intelligence by asking these questions about.

608
00:21:00,110 --> 00:21:00,980
我们在聊天中有一些答案，比如两个对64个。
We have some answers in the

609
00:21:00,980 --> 00:21:02,600
chat, like two to the 64.

610
00:21:02,600 --> 00:21:03,770
我没看到聊天内容，抱歉，嗯，是的，2比64。让我们看看我是否真的能把芯片弹出来，这样我就能看到它了。
I didn't see the chat,

611
00:21:03,770 --> 00:21:04,610
sorry, um,

612
00:21:04,610 --> 00:21:06,050
yeah, two to 64. Lets see

613
00:21:06,050 --> 00:21:07,340
if I can actually pop off

614
00:21:07,340 --> 00:21:07,970
the chip,

615
00:21:07,970 --> 00:21:08,980
so I could see it.

616
00:21:13,460 --> 00:21:14,450
是的，2比64，谢谢。
Yeah, two to 64,

617
00:21:14,450 --> 00:21:15,180
thank you.

618
00:21:16,990 --> 00:21:19,090
好的，那么这张桌子会很大。
Alright, so this table would

619
00:21:19,090 --> 00:21:20,280
be gigantic.

620
00:21:20,420 --> 00:21:22,130
嗯，事实上，我们知道光有桌子就会消耗所有的内存，所以这似乎是合理的。
Um, in fact we know

621
00:21:22,130 --> 00:21:23,540
all memory would be consumed

622
00:21:23,540 --> 00:21:24,590
by just having the table

623
00:21:24,590 --> 00:21:26,000
so that seems reasonable.

624
00:21:26,360 --> 00:21:27,590
嗯，所以事实上你知道事情不是这样的。
Um, and so in fact you

625
00:21:27,590 --> 00:21:29,160
know that's not how things work.

626
00:21:29,520 --> 00:21:30,510
嗯，实际上我要分两个步骤，来了解它在RISC-V中的实际工作原理。
Um, in fact I'm going to

627
00:21:30,510 --> 00:21:32,250
go in two steps, to actually, how

628
00:21:32,250 --> 00:21:33,820
it actually works in RISC-V.

629
00:21:33,920 --> 00:21:36,800
第一步不是按地址玩游戏，而是按页面玩。
Step one is don't play

630
00:21:36,800 --> 00:21:40,040
the game per address,

631
00:21:40,040 --> 00:21:41,720
but do per page.

632
00:21:44,580 --> 00:21:45,900
所以你一次翻译一页，RISC-V上的一页a是4千字节。
So you translate a page at

633
00:21:45,900 --> 00:21:47,880
a time and a page a

634
00:21:47,880 --> 00:21:50,380
on RISC-V is 4 kilobytes.

635
00:21:51,860 --> 00:21:52,940
它是一个4,4096字节。
Which is a four, and

636
00:21:52,940 --> 00:21:54,700
4096 bytes.

637
00:21:55,080 --> 00:21:56,430
这很常见，您知道，几乎所有处理器都使用大约4千字节的页面大小，或者支持4千字节的页面大小。
This is pretty common,

638
00:21:56,430 --> 00:21:58,830
almost all processors, you know, use

639
00:21:58,830 --> 00:22:01,320
roughly page size 4 kilobytes, or support

640
00:22:01,320 --> 00:22:02,780
page size 4 kilobytes.

641
00:22:03,420 --> 00:22:05,070
现在再说一遍，转换的工作原理略有不同，因此，如果在这里，我们就有了虚拟地址。
And so now again, translation works

642
00:22:05,070 --> 00:22:06,000
slightly differently,

643
00:22:06,000 --> 00:22:07,230
so if here, we have our

644
00:22:07,230 --> 00:22:08,300
virtual address.

645
00:22:09,360 --> 00:22:11,340
令人惊讶的是，我们将其一分为二，一个索引和一个偏移量。
Amazingly, we split it in two pieces,

646
00:22:11,340 --> 00:22:12,300
an index and

647
00:22:13,320 --> 00:22:14,580
an offset.

648
00:22:15,300 --> 00:22:16,620
所以偏移量基本上就是页面中的字节。
And so the offset is basically

649
00:22:16,620 --> 00:22:18,240
the byte within the page.

650
00:22:18,880 --> 00:22:20,170
因此，当我们这样做时，当MMU进行转换时，它会获取索引，索引到映射中，给出一些物理页码，或者您知道的在内存中。
And so when we do,

651
00:22:20,170 --> 00:22:21,610
when the MMU does

652
00:22:21,610 --> 00:22:23,820
the translation it takes the index,

653
00:22:23,970 --> 00:22:27,240
indexes into the map that

654
00:22:27,240 --> 00:22:29,100
gives you some physical page number,

655
00:22:29,100 --> 00:22:31,280
or you know in memory.

656
00:22:31,480 --> 00:22:33,520
在指向4096字节的某个物理页的物理页号中。
In the physical page number that

657
00:22:33,520 --> 00:22:35,680
points to some physical page of

658
00:22:35,680 --> 00:22:37,460
4096 bytes.

659
00:22:38,040 --> 00:22:39,870
然后是偏移量部分，基本上索引到该物理页面中，例如，偏移量是，您知道的，12。
And then the offset part,

660
00:22:39,870 --> 00:22:42,810
basically indexes into that physical page,

661
00:22:42,810 --> 00:22:43,530
so, for example,

662
00:22:43,530 --> 00:22:45,400
the offset is, you know, 12.

663
00:22:45,770 --> 00:22:48,100
那么你就知道那一页的第12个条目是实际使用的。
Then you know there are

664
00:22:48,690 --> 00:22:51,120
the 12th entry of that

665
00:22:51,120 --> 00:22:53,680
page is actually used.

666
00:22:54,110 --> 00:22:55,490
很多人，很多人，你们中的很多人，在回答这个问题时，总是有一些方案，取一个偏移量，然后把它加到页面的底部，以获得实际的内存，物理内存位置，值存储的位置，值也将被加载到那里。
A lot of people a lot

667
00:22:55,490 --> 00:22:57,590
of you entered in the message

668
00:22:57,590 --> 00:22:58,780
in the,

669
00:22:59,070 --> 00:23:00,300
in response to the question,

670
00:23:00,300 --> 00:23:02,340
there's always some scheme of taking

671
00:23:02,340 --> 00:23:04,770
an offset and adding that to

672
00:23:04,770 --> 00:23:06,570
the base of the page

673
00:23:06,570 --> 00:23:09,340
to obtain the actual

674
00:23:09,500 --> 00:23:11,690
memory, physical memory location, where

675
00:23:11,690 --> 00:23:13,820
a value store, where value will

676
00:23:13,820 --> 00:23:15,480
be loaded too.

677
00:23:16,400 --> 00:23:17,510
关于RISC-V的一个有趣的事情是，这是对一些问题的再次回答，有人问到看起来物理地址或虚拟地址是64位。
And one of the interesting things

678
00:23:17,510 --> 00:23:19,010
about the RISC-V is and

679
00:23:19,010 --> 00:23:20,690
this is a response to some

680
00:23:20,690 --> 00:23:21,320
questions again,

681
00:23:21,320 --> 00:23:22,400
somebody asked look a

682
00:23:22,400 --> 00:23:23,900
the physical,

683
00:23:24,110 --> 00:23:25,520
or virtual addresses are

684
00:23:25,520 --> 00:23:26,760
64 bits.

685
00:23:28,250 --> 00:23:29,630
这使得意义完全正确，因为RISC-V是64位寄存器。
Which makes totally sense correct,

686
00:23:29,630 --> 00:23:31,520
because the RISC-V is

687
00:23:31,520 --> 00:23:32,560
64-bit register.

688
00:23:33,210 --> 00:23:35,280
嗯，但实际上在我们使用的RISC-V处理器上，并不是所有实际使用的64位。
Um, but in fact on the

689
00:23:35,280 --> 00:23:38,190
RISC-V processor, that we're using,

690
00:23:38,190 --> 00:23:39,780
not all of the 64 bits

691
00:23:39,780 --> 00:23:40,800
actually used.

692
00:23:41,160 --> 00:23:43,890
也就是说，前25名实际上根本没有使用。
Namely, the top 25 are

693
00:23:43,890 --> 00:23:45,220
actually not used at all.

694
00:23:45,800 --> 00:23:47,630
嗯，这限制了虚拟地址的大小，这将虚拟地址空间的大小限制为49的幂。
Um, and so that limits the

695
00:23:47,630 --> 00:23:49,520
size of a virtual address, that

696
00:23:49,520 --> 00:23:50,900
limits the size of a virtual

697
00:23:50,900 --> 00:23:52,460
address space two to the power

698
00:23:52,460 --> 00:23:53,360
of 49.

699
00:23:54,980 --> 00:23:57,590
嗯，大约是512G字节。
Um, which is roughly

700
00:23:57,590 --> 00:23:58,740
512 gigabytes.

701
00:24:04,210 --> 00:24:06,310
嗯，当然您知道更高版本的处理器可能支持更大的地址空间，这是必要的，然后可以完成，例如，这25位中的一些基本上没有使用，可以用来构建更大的虚拟地址空间。
Um, and so of course you

702
00:24:06,310 --> 00:24:08,560
know later version of the

703
00:24:08,560 --> 00:24:10,360
processor, might support bigger address spaces

704
00:24:10,360 --> 00:24:12,400
and that is necessary and could then

705
00:24:14,080 --> 00:24:15,850
be done, for example, some of those 25 bits

706
00:24:15,850 --> 00:24:18,310
that are basically unused, could be used to

707
00:24:18,310 --> 00:24:21,640
build bigger virtual address spaces.

708
00:24:22,390 --> 00:24:23,620
所以，嗯，等等，在索引中，然后，你知道，剩下的39位，你知道，你知道虚拟地址27，27位是索引，我们一会儿就会看到，为什么他们是27位是索引，然后12位是偏移量。
So, um,

709
00:24:23,620 --> 00:24:24,400
and so in the index

710
00:24:24,400 --> 00:24:25,300
and then, you know, where

711
00:24:25,300 --> 00:24:26,440
39 bits left,

712
00:24:26,440 --> 00:24:27,820
you know as the virtual address

713
00:24:27,820 --> 00:24:29,830
27, 27 bits are

714
00:24:29,830 --> 00:24:31,030
index and we'll see you in

715
00:24:31,030 --> 00:24:33,100
a second, why they are 27

716
00:24:33,480 --> 00:24:35,100
are index and then

717
00:24:35,100 --> 00:24:37,580
the 12 are offset.

718
00:24:38,280 --> 00:24:39,480
你知道必须是12，因为2的12次方是4096。
And you know there has to

719
00:24:39,480 --> 00:24:40,890
be 12, because two to the

720
00:24:40,890 --> 00:24:43,880
power 12 is 4096.

721
00:24:46,590 --> 00:24:48,360
这是RISC-V物理地址上的虚拟地址，正如您在这里看到的，实际上是56位宽。
So that's virtual addresses on the

722
00:24:48,360 --> 00:24:50,520
RISC-V physical addresses as you

723
00:24:50,520 --> 00:24:52,350
can see here are actually 56

724
00:24:52,350 --> 00:24:53,240
bits wide.

725
00:24:57,940 --> 00:24:59,140
所以物理内存，可以大于单个虚拟地址空间。
So the physical memory,

726
00:24:59,140 --> 00:25:01,570
you can be bigger than the

727
00:25:01,570 --> 00:25:03,220
single virtual address space.

728
00:25:03,880 --> 00:25:05,110
但它被限制在两次电源最多56次，您知道，大多数主板可能不支持两次56次物理内存的能力，因为大量的物理内存。
But it's limited to two power up

729
00:25:05,110 --> 00:25:05,950
to 56,

730
00:25:05,950 --> 00:25:07,870
you know most boards probably, you know,

731
00:25:07,870 --> 00:25:09,190
don't support two to the power

732
00:25:09,190 --> 00:25:11,710
of 56 physical memory, because

733
00:25:11,710 --> 00:25:14,060
a gigantic amount of physical memory.

734
00:25:14,090 --> 00:25:15,290
嗯，但原则上这块板可以，你知道，如果你能制造它支持2到56物理内存的幂。
Um, but in principle the

735
00:25:15,290 --> 00:25:16,160
board could,

736
00:25:16,160 --> 00:25:16,610
you know,

737
00:25:16,610 --> 00:25:18,500
if you could manufacture it

738
00:25:18,500 --> 00:25:19,760
support two to the power

739
00:25:19,760 --> 00:25:21,200
of 56 physical memory.

740
00:25:22,020 --> 00:25:23,130
因此，在该方案中，如果物理地址44的56位基本上是物理页号，则PPM和12是直接从虚拟地址继承的偏移量。
And so in this scheme,

741
00:25:23,130 --> 00:25:25,620
then if 56 bit for

742
00:25:25,620 --> 00:25:27,330
the physical address 44 are basically

743
00:25:27,330 --> 00:25:28,440
the physical page number,

744
00:25:28,440 --> 00:25:30,720
the PPM, and twelve are the

745
00:25:30,720 --> 00:25:32,610
offset that are inherited directly from

746
00:25:32,610 --> 00:25:34,660
the virtual address.

747
00:25:36,840 --> 00:25:37,940
这有意义吗。
Does that make sense.

748
00:25:40,560 --> 00:25:41,640
所以，嗯，你知道在这里停一下。所以你要集中你的思想，我想在这里指出的唯一的一点是，这个材料很重要，所以只要问问题，细节很重要，它将是你的一大部分，你真的需要理解所有这些东西，才能基本上做实验，下一个实验，页表实验。
So, um,

749
00:25:41,640 --> 00:25:42,630
you know stop for a second

750
00:25:42,630 --> 00:25:44,310
here. So you collect your thoughts,

751
00:25:44,310 --> 00:25:45,390
the only point I wanted to

752
00:25:45,390 --> 00:25:48,780
make here is that this material

753
00:25:48,780 --> 00:25:49,410
is important,

754
00:25:49,410 --> 00:25:51,000
so just ask questions,

755
00:25:51,000 --> 00:25:52,740
the details matter,

756
00:25:52,740 --> 00:25:54,480
and it will be a large

757
00:25:54,480 --> 00:25:55,560
part of you,

758
00:25:55,560 --> 00:25:56,760
you really need to understand all

759
00:25:56,760 --> 00:25:57,240
this stuff,

760
00:25:57,240 --> 00:25:58,980
to be able to basically

761
00:25:58,980 --> 00:26:00,990
do lab, the next lab, the page

762
00:26:00,990 --> 00:26:01,740
table lab.

763
00:26:02,570 --> 00:26:03,260
是的，我在这里，请说吧。
Yeah I'm here,

764
00:26:03,260 --> 00:26:03,770
go ahead, please.

765
00:26:05,200 --> 00:26:06,220
嗯，如果你能倒退一张幻灯片，我的屏幕不清楚。
Um, if you can go back

766
00:26:06,220 --> 00:26:07,900
one slide, I have the screen

767
00:26:07,900 --> 00:26:09,080
is unclear.

768
00:26:10,740 --> 00:26:11,280
哪一个，页表幻灯片？嗯。
Which one,

769
00:26:11,280 --> 00:26:13,860
the page table slide? Yeah.

770
00:26:20,260 --> 00:26:21,220
这一个?嗯，没有。
This one?

771
00:26:21,220 --> 00:26:22,200
Um, no.

772
00:26:22,680 --> 00:26:24,210
最新的一个，但也不要紧，嗯，是的，这很完美，谢谢你，所以我想知道这个4096字节的范围，我们称之为页面，是作为内存中的连续区块分配的，是的，这是包括内存在内的4096字节的连续物理范围。
The most recent one, but it

773
00:26:24,210 --> 00:26:25,320
also doesn't really matter,

774
00:26:25,320 --> 00:26:26,190
um, yeah,

775
00:26:26,190 --> 00:26:26,790
this is perfect,

776
00:26:26,790 --> 00:26:29,070
thank you so I'm wondering this

777
00:26:29,070 --> 00:26:33,330
4096 byte range which we've called

778
00:26:33,330 --> 00:26:35,430
a page, is that assigned as

779
00:26:35,430 --> 00:26:37,950
a continuous chunk in memory,

780
00:26:37,950 --> 00:26:40,200
yes that's a continuous physical,

781
00:26:40,200 --> 00:26:44,190
continuous range of 4096 bytes

782
00:26:44,190 --> 00:26:45,340
including memory.

783
00:26:46,510 --> 00:26:49,630
我明白了，然后。你知道，地图，4096字节的粒度。
I see, and then. You know, the map,

784
00:26:49,630 --> 00:26:53,440
a granularity of 4096 bytes.

785
00:26:53,440 --> 00:26:55,390
好的，然后是12，比如2到12的偏移量是4096，那么这足以覆盖每一块了吗？是的，页面中的每个字节。
Okay, and then 12, the

786
00:26:55,390 --> 00:26:57,250
offset like two to the

787
00:26:57,250 --> 00:26:58,630
twelve is 4096,

788
00:26:58,630 --> 00:27:00,760
so that's sufficient to cover each

789
00:27:00,760 --> 00:27:03,880
of the chunks? Yeah, each byte in the page.

790
00:27:04,770 --> 00:27:07,020
在图表中，56是从哪里来的，我可以一直跟踪到那时，但我不知道它是从哪里来的。嗯，这是设计师们炮制出来的。
And where does the 56 come

791
00:27:07,020 --> 00:27:09,120
from, in the diagram I could

792
00:27:09,120 --> 00:27:10,680
follow up until then,

793
00:27:10,680 --> 00:27:11,640
but I didn't get where

794
00:27:11,640 --> 00:27:13,530
that came from. Um, the

795
00:27:13,530 --> 00:27:14,840
designers cook it up.

796
00:27:15,180 --> 00:27:16,800
所以硬件设计师决定你知道的物理地址有多大，基本上是他们想要设计的任何电路板的物理地址，所以RISC-V设计师在56岁时决定物理地址是一个好主意。
So the hardware designers decide

797
00:27:16,800 --> 00:27:17,940
how big you know physical

798
00:27:17,940 --> 00:27:20,250
addresses basically for whatever board

799
00:27:20,250 --> 00:27:22,620
they want to design,

800
00:27:22,620 --> 00:27:24,270
and so the RISC-V

801
00:27:24,270 --> 00:27:26,850
designers who decided at 56,

802
00:27:26,850 --> 00:27:28,050
that physical addresses were a

803
00:27:28,050 --> 00:27:28,920
good idea.

804
00:27:30,560 --> 00:27:32,240
嗯，通常他们得出这些数字的方式是看技术趋势。
Um, and usually the way they

805
00:27:32,240 --> 00:27:33,530
come up with these numbers is

806
00:27:33,530 --> 00:27:35,260
they look at technology trends.

807
00:27:35,500 --> 00:27:36,970
然后说，我们希望在接下来的5年里，你知道预测物理内存将会大于2的56次方。
And say like well we want

808
00:27:36,970 --> 00:27:37,990
to be able for the next

809
00:27:37,990 --> 00:27:38,980
sort of 5 years,

810
00:27:38,980 --> 00:27:40,870
you know to predict the physical

811
00:27:40,870 --> 00:27:42,340
memory will be ever bigger than

812
00:27:42,340 --> 00:27:43,840
two to the power 56.

813
00:27:44,740 --> 00:27:45,940
也许他们认为它不会比小得多的东西更大，但你知道，给他们一些[v方式]，你知道，如果你知道他们的预测是错误的，他们会选择一个稍微大一点的数字。
Probably they think it won't be

814
00:27:45,940 --> 00:27:47,590
bigger than something much smaller,

815
00:27:47,590 --> 00:27:48,910
but then you know give them

816
00:27:48,910 --> 00:27:50,650
some [v way], you know,

817
00:27:50,650 --> 00:27:51,550
in case you know their

818
00:27:51,550 --> 00:27:52,720
predictions wrong,

819
00:27:52,720 --> 00:27:54,460
they pick a slightly

820
00:27:54,460 --> 00:27:55,220
bigger number.

821
00:27:56,720 --> 00:27:58,060
这是有道理的。
Is that makes sense.

822
00:27:58,640 --> 00:28:00,440
好的，谢谢。很多人问起这件事。
Yeah, thanks. A lot of people

823
00:28:00,440 --> 00:28:01,790
ask about this.

824
00:28:03,870 --> 00:28:05,340
其他举手的人，我想有一群人在提问，不幸的是，我的变焦没有显示超过两个人举手，只有多个人举手。
Anybody else, who raised a hand

825
00:28:05,340 --> 00:28:06,210
I think there's a bunch of

826
00:28:06,210 --> 00:28:08,610
people asking questions and unfortunately my

827
00:28:08,610 --> 00:28:10,200
zoom doesn't show its more than

828
00:28:10,200 --> 00:28:12,000
two people raised hands just multiple

829
00:28:12,000 --> 00:28:13,260
people are raising their hands.

830
00:28:13,720 --> 00:28:15,190
所以如果你有问题，请进来吧。
So you please jump in, if

831
00:28:15,190 --> 00:28:16,040
you have a question.

832
00:28:20,160 --> 00:28:23,730
好吧。我有一个问题，是的，如果虚拟内存是2的27次方，而物理内存是56的2次方，那么，我们可以有多个进程，这些进程可以耗尽所有的虚拟内存，而不会用完所有的物理内存，对吗？没错。
Okay. I have a question,

833
00:28:23,730 --> 00:28:27,150
yeah, so if the virtual

834
00:28:27,150 --> 00:28:28,680
memory is up to two

835
00:28:28,680 --> 00:28:30,060
to the power of 27

836
00:28:30,060 --> 00:28:31,290
and the physical memory is

837
00:28:31,290 --> 00:28:32,670
up two to the power

838
00:28:32,670 --> 00:28:34,710
due to the 56, right,

839
00:28:34,710 --> 00:28:37,340
so, we could have,

840
00:28:38,550 --> 00:28:41,070
like we could have multiple processes

841
00:28:41,070 --> 00:28:42,630
that could exhaust all their virtual

842
00:28:42,630 --> 00:28:43,920
memories without

843
00:28:44,100 --> 00:28:46,140
using up all the physical memory,

844
00:28:46,140 --> 00:28:47,820
right? That's correct.

845
00:28:52,250 --> 00:28:53,280
这是完全正确的。
That's absolutely correct.

846
00:28:54,040 --> 00:28:56,170
好的，我也有个问题。
Okay I have a question, too.

847
00:28:56,170 --> 00:28:58,060
好的，去吧。
Yeah, go ahead.

848
00:28:58,190 --> 00:29:00,470
所以这56个物理地址就是可能的存储器位置的数目。
So this 56 for the physical

849
00:29:00,470 --> 00:29:02,960
address is that the,

850
00:29:03,240 --> 00:29:06,380
the number of possible memory locations.

851
00:29:06,510 --> 00:29:07,680
我认为这不是位的数量，因为64位的机器。
I don't think it's the

852
00:29:07,680 --> 00:29:09,990
number of bits because the 64

853
00:29:09,990 --> 00:29:11,140
bit machine.

854
00:29:11,170 --> 00:29:13,180
嗯，五十六个可以涨到六十四个，但是他们就是选择只有五十六个。
Um that 56 could go up

855
00:29:13,180 --> 00:29:14,410
to 64,

856
00:29:14,410 --> 00:29:16,100
but they just choose it

857
00:29:16,290 --> 00:29:17,850
to have just 56.

858
00:29:18,600 --> 00:29:19,350
没错，从一种角度来看，他们只需要在棋盘上跑56码，而不是64码。
That's correct,

859
00:29:19,350 --> 00:29:20,280
one way to think about it,

860
00:29:20,280 --> 00:29:21,120
then they only have to run

861
00:29:21,120 --> 00:29:23,220
56 wide on the board as

862
00:29:23,220 --> 00:29:24,520
opposed to 64.

863
00:29:25,530 --> 00:29:27,260
我明白了，我明白了。
I see, I see.

864
00:29:30,220 --> 00:29:32,530
好吧。我还有一个问题，嗯，你能不能倒退一张幻灯片，从CPU开始，我们先检查内存，然后再到内存，但是哪里有不同进程的区别，因为像每个进程，像进程，像shell进程的地址是0x1000，然后ls进程也有地址0x0000的东西，所以我们需要将它们转换成不同的物理进程，所以。是的，SATP寄存器包含寄存器，该寄存器包含要使用的映射的地址。
Okay. I also have a question,

865
00:29:32,530 --> 00:29:35,650
um, so kind of, could you

866
00:29:35,650 --> 00:29:36,670
go back one slide maybe,

867
00:29:38,820 --> 00:29:42,570
so from the CPU,

868
00:29:42,570 --> 00:29:44,700
we go through the MMU and

869
00:29:44,700 --> 00:29:47,010
then to the memory, but

870
00:29:47,010 --> 00:29:50,160
where, where here is the distinction

871
00:29:50,160 --> 00:29:53,460
for different processes, because like each

872
00:29:53,460 --> 00:29:56,040
process, like process, like the shell

873
00:29:56,040 --> 00:29:58,200
process has something at address like

874
00:29:58,200 --> 00:30:00,450
0x1000,

875
00:30:00,450 --> 00:30:02,610
and then the ls process

876
00:30:02,610 --> 00:30:04,200
also has something at address

877
00:30:04,200 --> 00:30:06,090
0x0000, so

878
00:30:06,090 --> 00:30:07,350
we need to translate those to

879
00:30:07,350 --> 00:30:12,680
different physical, so. Yeah, the satp register

880
00:30:13,330 --> 00:30:15,580
contains the register who contains the

881
00:30:15,580 --> 00:30:17,760
address of which map to use.

882
00:30:18,450 --> 00:30:20,580
所以ls有自己的地图，你知道猫有自己的地图。
So ls runs with its own map,

883
00:30:20,580 --> 00:30:22,710
you know cat with its own map.

884
00:30:22,710 --> 00:30:25,020
好的，所以每个进程都有自己的地图。嗯。
OK, so each process will have

885
00:30:25,020 --> 00:30:27,580
its completely own map. Yeah.

886
00:30:28,140 --> 00:30:28,680
有道理，谢谢。
Makes sense,

887
00:30:28,680 --> 00:30:29,700
thank you.

888
00:30:29,700 --> 00:30:31,380
事实上，有一个很好的方法可以到达下一个点，所以如果每个进程都有自己的地图。
In fact, there's a great a

889
00:30:31,380 --> 00:30:32,220
way to the next,

890
00:30:33,300 --> 00:30:35,310
point, so if every process has

891
00:30:35,310 --> 00:30:36,340
its own map.

892
00:30:36,870 --> 00:30:38,430
你知道这张地图有多大，就像我在这里画的那样。
You know how big is this

893
00:30:38,430 --> 00:30:40,380
map, like that I've drawn here.

894
00:30:40,900 --> 00:30:42,220
嗯，这张图是27的2次方，正确。
Well, that map is two to

895
00:30:42,220 --> 00:30:44,520
the power 27 entries, correct.

896
00:30:46,460 --> 00:30:48,140
嗯，那可是相当大的一笔钱。
Um, and that's pretty big.

897
00:30:49,030 --> 00:30:50,500
嗯，如果每个进程都准确地完成你知道的填充地图，我会相当快地填满物理内存。
Um, and I would fill physical

898
00:30:50,500 --> 00:30:51,910
memory reasonable quickly,

899
00:30:51,910 --> 00:30:53,650
if every process exactly how

900
00:30:53,650 --> 00:30:56,300
to complete you know populated map.

901
00:30:56,560 --> 00:30:58,450
然后是巨大的，意味着每个进程都非常大，所以实际上不是这样的，硬件实际上存储页表，你可以把它概念上想成一个数组，你知道从0到2的27次方，但实际上并不是这样发生的。
And then there's gigantic, means that

902
00:30:58,450 --> 00:31:00,130
every process is very big,

903
00:31:00,130 --> 00:31:01,420
and so in fact this is

904
00:31:01,420 --> 00:31:03,700
not the way, hardware actually

905
00:31:03,700 --> 00:31:04,900
stores page tables,

906
00:31:04,900 --> 00:31:06,040
you can think about it

907
00:31:06,040 --> 00:31:07,690
conceptually as an array,

908
00:31:07,690 --> 00:31:08,980
you know going from zero to

909
00:31:08,980 --> 00:31:09,910
two power 27,

910
00:31:09,910 --> 00:31:11,080
but actually is not what happens

911
00:31:11,080 --> 00:31:11,840
in practice.

912
00:31:12,120 --> 00:31:13,110
实际上，这是一个多级结构，这里实际上是真正的RISC-V页表。
In practice,

913
00:31:13,110 --> 00:31:15,750
it's a multi-level structure that

914
00:31:15,750 --> 00:31:18,260
here's actually the real RISC-V

915
00:31:20,900 --> 00:31:21,780
page table.

916
00:31:23,460 --> 00:31:25,820
结构以及硬件实现的内容。
Structure and what the hardware implements.

917
00:31:26,820 --> 00:31:28,350
那么我们之前开始的27位会发生什么，索引。
And so what happens with the

918
00:31:28,350 --> 00:31:30,780
27 bits that we started earlier,

919
00:31:30,780 --> 00:31:31,820
the index.

920
00:31:32,240 --> 00:31:35,810
它实际上被分成三个9位数字。
It's actually split in three

921
00:31:35,810 --> 00:31:37,860
nine bit numbers.

922
00:31:38,220 --> 00:31:40,230
前九位用于索引顶层页表，也就是它们所称的目录。
And the first the top nine

923
00:31:40,230 --> 00:31:42,660
bits, are used to index into

924
00:31:42,660 --> 00:31:44,920
the top level page table,

925
00:31:44,990 --> 00:31:46,700
directory as they are called.

926
00:31:47,120 --> 00:31:47,480
所以，然后是一个目录，你知道这些人中的一个，你知道是4096字节，4096字节。
And so,

927
00:31:47,480 --> 00:31:48,410
then one directory,

928
00:31:48,410 --> 00:31:49,520
you know one of these guys,

929
00:31:49,520 --> 00:31:51,620
you know is 4096 bytes,

930
00:31:51,620 --> 00:31:53,640
4096 bytes.

931
00:31:54,310 --> 00:31:55,800
就像页面大小一样。
Just like the page size.

932
00:31:56,150 --> 00:31:58,820
PTE条目，其中一个条目是64字节。
A PTE entry, one of

933
00:31:58,820 --> 00:32:00,080
the entries in the thing

934
00:32:00,080 --> 00:32:02,040
is 64 bytes.

935
00:32:03,520 --> 00:32:04,600
64位，我是说，对不起，就像寄存器有8个字节一样。
64 bit,

936
00:32:04,600 --> 00:32:07,090
I mean, sorry, like the register

937
00:32:07,090 --> 00:32:08,680
with so eight bytes.

938
00:32:09,000 --> 00:32:10,230
所以这就意味着你要做4096次。
And so there's going to mean

939
00:32:10,230 --> 00:32:12,080
that you do 4096.

940
00:32:12,710 --> 00:32:14,390
除以8表示其中一个目录页中有512个条目。
Divided by eight, means there are

941
00:32:14,390 --> 00:32:17,090
512 entries in one of those

942
00:32:17,090 --> 00:32:18,300
directory pages.

943
00:32:19,400 --> 00:32:20,810
因此，基本上发生的情况是，SATP指向顶层根目录，我们将顶层9位索引放入页目录。
So basically what happens is

944
00:32:20,810 --> 00:32:22,310
like the satp points

945
00:32:22,310 --> 00:32:23,360
to the top,

946
00:32:23,480 --> 00:32:24,650
root directory,

947
00:32:24,650 --> 00:32:25,940
we take the top level 9

948
00:32:25,940 --> 00:32:29,040
bits index into the page directory.

949
00:32:29,190 --> 00:32:30,060
现在给我们一个新的物理页码。
And now gives us a new

950
00:32:30,060 --> 00:32:31,340
physical page number.

951
00:32:32,040 --> 00:32:33,330
物理页码是下一级别的页面目录，所以当我们使用下一级别索引来索引到该页面目录时，您知道，等等，我们想要找到一个，我们会得到最低级别的页面目录。
And that physical page number

952
00:32:33,330 --> 00:32:35,040
is the page directory for

953
00:32:35,040 --> 00:32:36,030
the next level,

954
00:32:36,030 --> 00:32:36,870
so when we use the

955
00:32:36,870 --> 00:32:40,200
next level, index,

956
00:32:39,200 --> 00:32:41,210
To index into that page

957
00:32:41,210 --> 00:32:42,890
directory and then you know

958
00:32:42,890 --> 00:32:43,670
and so forth,

959
00:32:43,670 --> 00:32:44,600
you know, we'd like to find

960
00:32:44,600 --> 00:32:46,490
one we get the bottom level

961
00:32:46,490 --> 00:32:47,620
page directory.

962
00:32:47,780 --> 00:32:48,950
这基本上为我们提供了将虚拟地址映射到物理地址的条目。
And that basically gives us

963
00:32:48,950 --> 00:32:49,760
the entry,

964
00:32:49,760 --> 00:32:51,560
that maps the virtual address

965
00:32:51,560 --> 00:32:52,600
to physical address.

966
00:32:55,680 --> 00:32:56,400
所以在某种意义上，它与我在上一张幻灯片中展示的非常相似，除了它们基本上是索引发生在三个步骤而不是一个步骤中。
So in some sense,

967
00:32:56,400 --> 00:32:58,170
it's very similar to where I

968
00:32:58,170 --> 00:32:59,520
showed in the previous slide except

969
00:32:59,520 --> 00:33:00,930
they're basically the index happens in

970
00:33:00,930 --> 00:33:02,760
three steps instead of one step.

971
00:33:02,870 --> 00:33:04,070
这就是优点，这种方案的主要优点是大部分地址空间没有被使用，您不需要有任何页表条目来实现这一点。
And this is advantage,

972
00:33:04,070 --> 00:33:05,480
the main advantage of this scheme

973
00:33:05,480 --> 00:33:07,760
is that large parts of the

974
00:33:07,760 --> 00:33:09,470
address space are not being used,

975
00:33:09,470 --> 00:33:10,310
you don't have to have any

976
00:33:10,310 --> 00:33:11,880
page table entries for that.

977
00:33:12,920 --> 00:33:13,550
例如，假设您有一个新的地址库。
For example,

978
00:33:13,550 --> 00:33:14,570
let's say you have a new

979
00:33:14,570 --> 00:33:15,660
address base.

980
00:33:16,130 --> 00:33:18,470
它只有一页，就像最下面的一页。
That has only one page like

981
00:33:18,470 --> 00:33:19,500
the bottom page.

982
00:33:19,640 --> 00:33:21,500
是的，4096号。
Yeah, 4096.

983
00:33:22,790 --> 00:33:24,410
并且没有其他页面或在地址空间中，因此实际只映射地址0到4095和6。
And no other pages or in

984
00:33:24,410 --> 00:33:25,550
the address space,

985
00:33:25,550 --> 00:33:27,860
so only addresses zero to 4095

986
00:33:27,860 --> 00:33:29,340
and 6 are actually mapped.

987
00:33:29,500 --> 00:33:30,880
您需要映射多少个页表条目或页表目录。
How many page table entry or

988
00:33:30,880 --> 00:33:32,200
page table directories do you need

989
00:33:32,200 --> 00:33:33,280
to map that.

990
00:33:33,370 --> 00:33:35,060
特定的页面。
Particular page.

991
00:33:39,280 --> 00:33:40,150
嗯，你需要一个顶层的，对吧。
Well, you need one of the

992
00:33:40,150 --> 00:33:41,280
top, correct.

993
00:33:41,790 --> 00:33:43,440
你基本上需要该条目中的值为零。
And you need basically value in

994
00:33:43,440 --> 00:33:45,440
that entry for zero.

995
00:33:46,520 --> 00:33:47,840
最高级别的9位，你知道0，所以你需要一个0的条目。
The top level nine bits,

996
00:33:47,840 --> 00:33:49,640
you know zero zero so you

997
00:33:49,640 --> 00:33:51,500
need an entry for zero.

998
00:33:51,860 --> 00:33:53,420
这意味着你需要一个中级条目，你知道基本上a对应于下一个，你知道九个零比特，然后一个条目对应接下来的九个零比特。
So that means you need one

999
00:33:53,420 --> 00:33:54,740
middle level entry,

1000
00:33:54,740 --> 00:33:56,510
you know that basically a corresponds

1001
00:33:56,510 --> 00:33:57,170
to the next,

1002
00:33:57,170 --> 00:33:59,060
you know nine zero bits and

1003
00:33:59,060 --> 00:34:00,500
then one entry for the next

1004
00:34:00,500 --> 00:34:01,480
nine zero bits.

1005
00:34:02,170 --> 00:34:04,300
所以基本上我们只需要三页目录就可以了。
So basically we get away with

1006
00:34:04,300 --> 00:34:07,160
three page directories.

1007
00:34:11,420 --> 00:34:12,770
在我们上一张幻灯片上的前一个方案中，我们有2的27次幂的参赛作品，现在我们基本上必须有3倍于512个参赛作品的参赛作品。
In our previous scheme on the

1008
00:34:12,770 --> 00:34:14,120
previous slide correct,

1009
00:34:14,120 --> 00:34:15,080
we have two to the power

1010
00:34:15,080 --> 00:34:17,390
27 entries and now we basically

1011
00:34:17,390 --> 00:34:18,800
have to have three times whatever

1012
00:34:18,800 --> 00:34:20,580
512 entries that we're done.

1013
00:34:21,940 --> 00:34:24,970
这就是为什么你知道实际硬件的主要原因，我有这个分层的，嗯，多层树方案。
That's the main reason why

1014
00:34:24,970 --> 00:34:26,620
you know the actual hardware I

1015
00:34:26,620 --> 00:34:28,360
has this hierarchical,

1016
00:34:28,360 --> 00:34:31,060
um multi-level tree scheme.

1017
00:34:32,570 --> 00:34:34,010
任何关于这个的问题，因为这很重要。
Any questions about this, because it's

1018
00:34:34,010 --> 00:34:34,920
pretty important.

1019
00:34:36,280 --> 00:34:37,520
萨米尔，说吧。
Samir, go ahead.

1020
00:34:38,980 --> 00:34:44,050
所以我的问题是，因为每个页表的PPM号是44位。
So my question is as since

1021
00:34:44,050 --> 00:34:46,090
the PPM number from each page

1022
00:34:46,090 --> 00:34:48,100
table is 44 bits.

1023
00:34:48,430 --> 00:34:50,770
第二个表示中间表驻留在虚拟内存上。
And the second say the middle

1024
00:34:50,770 --> 00:34:53,880
table resides on the virtual memory.

1025
00:34:53,950 --> 00:34:55,390
我们从哪里得到丢失的十二个比特。
Where do we get the missing

1026
00:34:55,390 --> 00:34:56,560
twelve bits from.

1027
00:34:57,290 --> 00:34:58,820
最后十二位好的，所以你说的是这44个，正确的。
On the final twelve bits okay

1028
00:34:58,820 --> 00:35:00,260
so good good good,

1029
00:35:00,260 --> 00:35:02,740
so you're saying these 44, correct.

1030
00:35:02,940 --> 00:35:04,110
是的，这是怎么回事，而所有的页面，所有的页面目录或页面行。
Yes, what is going on

1031
00:35:04,110 --> 00:35:04,380
with that,

1032
00:35:04,380 --> 00:35:06,210
while all page, all page directories

1033
00:35:06,210 --> 00:35:07,480
or page line.

1034
00:35:08,170 --> 00:35:10,360
所以它们基本上是一个物理页码是44加上12，12个零位。
And so they basically they're a

1035
00:35:10,360 --> 00:35:11,920
physical page number is 44 plus

1036
00:35:11,920 --> 00:35:16,120
twelve, twelve zero bits.

1037
00:35:18,920 --> 00:35:20,180
如果我们看这些PTE条目，它们都有相同的形式，如果你看这些人中的一个，会发生什么呢？
And so what actually happens if

1038
00:35:20,180 --> 00:35:21,860
we look at these PTE entries,

1039
00:35:21,860 --> 00:35:23,060
they all have the same sort

1040
00:35:23,060 --> 00:35:23,990
of form,

1041
00:35:23,990 --> 00:35:24,620
if you look at one of

1042
00:35:24,620 --> 00:35:25,840
these guys.

1043
00:35:25,920 --> 00:35:26,880
有44位，有12位是0，所以我们得到了44加12是56的物理地址，Um，这意味着有64位，实际上还有一些位没有使用，事实上，最下面的12位基本上是最低的，或者说最下面的10位肯定是最低的，因为根本没有使用，事实上，寻呼硬件存储或存储了一系列控制转换的标志，我们将在第二节中讨论这些标志的情况。(=
There are 44 bits,

1044
00:35:26,880 --> 00:35:28,590
there are 12 bits

1045
00:35:28,590 --> 00:35:30,060
zero, so that gives us a

1046
00:35:30,060 --> 00:35:32,280
44 plus 12 is 56, so

1047
00:35:32,280 --> 00:35:33,660
that gives us a physical address,

1048
00:35:36,620 --> 00:35:39,050
Um, and so that means there's

1049
00:35:39,050 --> 00:35:39,860
64 bits,

1050
00:35:39,860 --> 00:35:41,420
there's actually some bits left

1051
00:35:41,420 --> 00:35:42,470
there not being used and

1052
00:35:42,470 --> 00:35:43,850
in fact the bottom twelve

1053
00:35:43,850 --> 00:35:45,020
bits were basically or the

1054
00:35:45,020 --> 00:35:47,030
bottom ten definitely bottom based

1055
00:35:47,030 --> 00:35:48,320
on not used at all and

1056
00:35:48,320 --> 00:35:50,210
in fact the paging hardware

1057
00:35:50,210 --> 00:35:52,490
stores or stores a bunch

1058
00:35:52,490 --> 00:35:54,950
of flags that control the

1059
00:35:54,950 --> 00:35:56,090
translation and we'll talk about

1060
00:35:56,090 --> 00:35:57,480
those flags in the second.

1061
00:35:57,730 --> 00:36:00,520
嗯，用它们来控制翻译，它们基本上存储在最下面的10位。
Um, and with their

1062
00:36:00,520 --> 00:36:02,140
to control the translation and

1063
00:36:02,140 --> 00:36:03,520
they're stored basically in the bottom

1064
00:36:03,520 --> 00:36:04,860
10 bits.

1065
00:36:05,100 --> 00:36:06,780
嗯，这也意味着，你知道，如果你把这两个加起来就是54位，基本上还剩下10位。
Um, it also means that, you

1066
00:36:06,780 --> 00:36:07,890
know, if you add these two

1067
00:36:07,890 --> 00:36:09,660
up that's 54 bits,

1068
00:36:09,660 --> 00:36:11,680
basically there's 10 bits left.

1069
00:36:11,920 --> 00:36:13,660
还有未使用的，这10位也是为了将来的增长，所以在某个时候，我们可能会有一种新型的RISC-V处理器，它的页表结构会略有不同，它实际上可能会有比44位更大的物理页码，好吗？谢谢。
There are unused, those 10 bits

1070
00:36:13,660 --> 00:36:14,650
are again,

1071
00:36:14,650 --> 00:36:16,810
you know for future growth,

1072
00:36:16,810 --> 00:36:17,920
so at some point we might

1073
00:36:17,920 --> 00:36:18,850
have a new type of

1074
00:36:18,850 --> 00:36:20,800
RISC-V processor, that will have a

1075
00:36:20,800 --> 00:36:22,840
slightly different structure page tables,

1076
00:36:22,840 --> 00:36:24,460
and it might actually have bigger

1077
00:36:24,460 --> 00:36:25,930
than 44 bits for the physical

1078
00:36:25,930 --> 00:36:27,040
page number, OK?

1079
00:36:29,460 --> 00:36:31,380
Thank you.

1080
00:36:31,380 --> 00:36:32,340
事实上，你可以在这里看到，如果你看一下这里画的单个条目，嗯，你知道它们基本上是。
In fact you can see

1081
00:36:32,340 --> 00:36:33,090
it here like if you

1082
00:36:33,090 --> 00:36:33,990
look at a single entry

1083
00:36:33,990 --> 00:36:36,060
direct that's drawn here,

1084
00:36:36,060 --> 00:36:37,920
um, you know they're basically.

1085
00:36:38,490 --> 00:36:40,140
10，10位未使用的剩余位。
10, 10 bits left, that

1086
00:36:40,140 --> 00:36:41,200
are not being used.

1087
00:36:42,020 --> 00:36:43,010
嗯，好的，我们来看一下旗帜，因为这很重要。
Um, okay,

1088
00:36:43,010 --> 00:36:44,240
so let's look at the flags

1089
00:36:44,240 --> 00:36:45,680
for a second, because it's sort

1090
00:36:45,680 --> 00:36:46,620
of important.

1091
00:36:46,940 --> 00:36:48,020
嗯，那么，在最下面的10位中的每一个翻译，都有一串标志存储，第一个标志是有效的。
Um, so,

1092
00:36:48,020 --> 00:36:50,180
every translation in the bottom 10

1093
00:36:50,180 --> 00:36:51,170
bits, there's a bunch of flag

1094
00:36:51,170 --> 00:36:53,810
stored and the first flag

1095
00:36:53,810 --> 00:36:54,960
is valid.

1096
00:36:55,540 --> 00:36:57,880
如果设置了有效位，则意味着这是有效PTE，您可以将其用于转换。
If a valid bit set,

1097
00:36:57,880 --> 00:36:58,780
that means this is a

1098
00:36:58,780 --> 00:37:00,130
valid PTE,

1099
00:37:00,130 --> 00:37:01,210
and you can use it

1100
00:37:01,210 --> 00:37:02,220
for translation.

1101
00:37:03,180 --> 00:37:05,190
因此，我们将运行我在这里使用的小示例，三个页面目录，当只使用条目零时，只有条目零将设置有效位，其他五个[和十一个]条目都不会设置有效位。
And so, we're going to

1102
00:37:05,190 --> 00:37:06,630
run my little example, that I

1103
00:37:06,630 --> 00:37:08,790
used here, three page directories,

1104
00:37:08,790 --> 00:37:10,620
when only entry zero is used

1105
00:37:10,620 --> 00:37:12,390
then only entey zero will have

1106
00:37:12,390 --> 00:37:13,890
valid bit set and none of

1107
00:37:13,890 --> 00:37:15,390
the other five [and eleven] entries

1108
00:37:15,390 --> 00:37:17,220
will not have valid bit set.

1109
00:37:18,600 --> 00:37:21,300
这基本上告诉我们，MMU，你不需要追查这个PTE，PTE只是不包含有效信息。
And that basically tells, MMU

1110
00:37:21,300 --> 00:37:22,740
well you don't have to chase

1111
00:37:22,740 --> 00:37:25,590
down this PTE, PTE just contains no

1112
00:37:25,590 --> 00:37:26,680
valid information.

1113
00:37:27,820 --> 00:37:30,730
那么“r”表示允许您从该页读取，“Write”表示允许您向该页写入。
Then "r" means you're allowed

1114
00:37:30,730 --> 00:37:32,590
to read from that page, write

1115
00:37:32,590 --> 00:37:34,330
means you're allowed to write to

1116
00:37:34,330 --> 00:37:35,160
the page.

1117
00:37:35,240 --> 00:37:37,790
Execute意味着允许您执行其中的指令。
Execute means you're allowed to execute

1118
00:37:37,790 --> 00:37:39,040
instruction from it.

1119
00:37:39,330 --> 00:37:41,640
嗯，在User中，意味着您知道在用户空间中运行的进程也可以访问此页面。
Um, in user, means you

1120
00:37:41,640 --> 00:37:42,810
know this page is

1121
00:37:42,810 --> 00:37:44,640
also accessible by a process

1122
00:37:44,640 --> 00:37:46,440
running in user space.

1123
00:37:47,340 --> 00:37:48,300
然后是其他你不那么重要的部分，它会在某个时候出现，那是定义重要部分的5个部分。
And then the other bits you

1124
00:37:48,300 --> 00:37:49,140
not that important,

1125
00:37:49,140 --> 00:37:49,740
it will show up at

1126
00:37:49,740 --> 00:37:51,570
some point, those are sort of five

1127
00:37:51,570 --> 00:37:52,920
define important bits.

1128
00:37:55,970 --> 00:37:57,040
这有意义吗。
Does that make sense.

1129
00:38:01,740 --> 00:38:03,960
是的，妮思娅，我可能会念错你的名字，我向你道歉。
Yeah, Nithya, I'd probably mispronouncing your

1130
00:38:03,960 --> 00:38:06,180
name I apologize to you.

1131
00:38:06,850 --> 00:38:08,440
这就是表示法，谢谢，我有一个关于三个页面表的快速问题，那么地址或PPM值是如何组合在一起形成我可能会错过的最终物理地址的。
That's, that's the representation,

1132
00:38:08,440 --> 00:38:09,340
thank you,

1133
00:38:09,340 --> 00:38:11,050
I had a quick question

1134
00:38:11,050 --> 00:38:11,860
about,

1135
00:38:11,860 --> 00:38:13,810
the three page tables,

1136
00:38:13,810 --> 00:38:16,540
so how are the addresses or

1137
00:38:16,540 --> 00:38:19,510
the PPM values combined to form

1138
00:38:19,510 --> 00:38:21,340
the final physical address I might

1139
00:38:21,340 --> 00:38:22,080
miss that.

1140
00:38:22,350 --> 00:38:22,950
嗯，是的，我们可能不会说得很清楚。因此，第一个PPM校正位于页表的顶部，即顶级页面目录中的第一个PPM。
Um, yeah,

1141
00:38:22,950 --> 00:38:24,330
well may not say that said it

1142
00:38:24,330 --> 00:38:26,940
very explicitly. So the first

1143
00:38:26,940 --> 00:38:29,340
PPM correcting tops the page table,

1144
00:38:29,340 --> 00:38:30,720
the first PPM in the top

1145
00:38:30,720 --> 00:38:32,200
level page directory.

1146
00:38:32,300 --> 00:38:35,150
并且包含下一层的物理地址。
And contains the physical address of

1147
00:38:35,150 --> 00:38:36,650
the next level down.

1148
00:38:37,780 --> 00:38:39,820
其中一个包含下一层，最后一个包含[几个]44位，它包含了我们实际上试图转换到的页面上的实际物理地址。
And one contains the one next

1149
00:38:39,820 --> 00:38:40,960
level down and then in the

1150
00:38:40,960 --> 00:38:43,210
final one we still have are

1151
00:38:43,210 --> 00:38:45,130
[few] 44 bits that contains then

1152
00:38:45,130 --> 00:38:47,110
the actual physical address off the

1153
00:38:47,110 --> 00:38:48,460
page that we're actually trying to

1154
00:38:48,460 --> 00:38:49,540
translate to.

1155
00:38:50,150 --> 00:38:50,900
嗯，好的，有道理，谢谢。
Um, OK,

1156
00:38:50,900 --> 00:38:51,860
that makes sense, thank you.

1157
00:38:51,860 --> 00:38:53,750
好的，还有一个有趣的问题，让我们边说一下，在我回答我自己的问题之前，在回答这里的两个举手之前，回顾这张图片，为什么，为什么物理页码存储在这些页面目录中。
Okay, and one interesting question,

1158
00:38:53,750 --> 00:38:54,860
just let us side note,

1159
00:38:54,860 --> 00:38:56,870
before let me answer my

1160
00:38:56,870 --> 00:38:58,490
own question before answering the

1161
00:38:58,490 --> 00:38:59,690
two raised hands here,

1162
00:38:59,690 --> 00:39:02,030
look back at this picture,

1163
00:39:02,030 --> 00:39:03,920
why, why are the physical page

1164
00:39:03,920 --> 00:39:05,800
numbers stored in these page directories.

1165
00:39:07,810 --> 00:39:09,960
为什么不是虚拟地址呢？
Why not a virtual address.

1166
00:39:11,520 --> 00:39:12,870
因为我们需要在内存中查找它，就像在内存中查找下一个目录一样。
Because we need to look it

1167
00:39:12,870 --> 00:39:14,460
up in memory, like look up

1168
00:39:14,460 --> 00:39:16,110
the next directory in memory.

1169
00:39:16,110 --> 00:39:16,800
是的，我们不能有依赖于另一种翻译方案的翻译方案，你知道我们可以，递归地看意图，所以这就没有意义了。
Yeah right,

1170
00:39:16,800 --> 00:39:18,210
we could not have a

1171
00:39:18,210 --> 00:39:19,770
translation scheme depends on yet

1172
00:39:19,770 --> 00:39:20,940
another translation scheme,

1173
00:39:20,940 --> 00:39:21,780
you know we could sort of,

1174
00:39:21,780 --> 00:39:23,250
recursive intent look, so that

1175
00:39:23,250 --> 00:39:24,380
just doesn't make sense.

1176
00:39:24,620 --> 00:39:26,300
这就是正确的答案，它必须是一个物理数，那么SATP呢？你怎么使用SATP，它存储什么，它存储物理地址还是虚拟地址。
That's exactly the right answer,

1177
00:39:26,300 --> 00:39:26,870
it has to be a

1178
00:39:26,870 --> 00:39:27,590
physical number,

1179
00:39:27,590 --> 00:39:28,730
how about the satp,

1180
00:39:28,730 --> 00:39:29,930
what do you use the satp,

1181
00:39:29,930 --> 00:39:31,130
what does it store it store

1182
00:39:31,130 --> 00:39:32,860
a physical address or a virtual address.

1183
00:39:39,180 --> 00:39:41,340
嗯，也是物理的，假设第一页目录也是内存。完全正确，所以它必须是一个物理数，因为我们实际上是在试着用它来翻译。
Um, also physical, assuming that

1184
00:39:41,340 --> 00:39:42,480
the first page directory is

1185
00:39:42,480 --> 00:39:45,570
also memory. Right exactly so

1186
00:39:45,570 --> 00:39:46,080
it has to be a

1187
00:39:46,080 --> 00:39:47,580
physical number because we're actually

1188
00:39:47,580 --> 00:39:48,330
trying to use it for

1189
00:39:48,330 --> 00:39:49,960
translation.

1190
00:39:50,100 --> 00:39:51,390
而且，嗯，你知道SATP，你需要知道物理页码是什么。
And, um,

1191
00:39:51,390 --> 00:39:52,560
so you know the satp, you

1192
00:39:52,560 --> 00:39:53,700
need to know what the physical

1193
00:39:53,700 --> 00:39:54,820
page number is.

1194
00:39:54,930 --> 00:39:56,430
嗯，在页面目录的路径上。
Um, on the route of the

1195
00:39:56,430 --> 00:39:57,400
page directory.

1196
00:39:59,170 --> 00:40:00,490
好的，还有另外两个问题，或者两个举手的人可以做，重复你的问题，如果。
OK, there were two other questions

1197
00:40:00,490 --> 00:40:01,450
or two people who raise their

1198
00:40:01,450 --> 00:40:02,740
hands could do,

1199
00:40:06,120 --> 00:40:08,080
Repeat your question if.

1200
00:40:10,740 --> 00:40:13,260
因此，有一个由三个表组成的层次结构，每个表都由虚拟地址的一部分进行索引，每个虚拟地址有9位长。
So there's a hierarchy of three

1201
00:40:13,260 --> 00:40:15,210
tables and each of them is

1202
00:40:15,210 --> 00:40:16,740
indexed by a part of the

1203
00:40:16,740 --> 00:40:17,910
virtual address,

1204
00:40:17,910 --> 00:40:20,260
each nine bits long.

1205
00:40:22,730 --> 00:40:23,840
因此，我不确定我是否理解它们之间的链接是如何发生的，以及它意味着什么，比如，仅仅使用这三个9位地址来索引它们中的每一个难道不够吗？
So I'm not sure

1206
00:40:23,840 --> 00:40:27,260
I understand how chaining between

1207
00:40:27,260 --> 00:40:28,640
them happens and what it's

1208
00:40:28,640 --> 00:40:30,020
meant to accomplish like shouldn't

1209
00:40:30,020 --> 00:40:31,400
it be sufficient to just

1210
00:40:31,400 --> 00:40:33,770
use those three 9 bit

1211
00:40:33,770 --> 00:40:34,910
addresses to index into each

1212
00:40:34,910 --> 00:40:35,540
of them.

1213
00:40:36,800 --> 00:40:37,310
没错，所以第一个顶层9位用来表示在第一个顶层页级目录中，第二个、下一个和第三个位在第三个目录中。
That's correct,

1214
00:40:37,310 --> 00:40:39,110
so the first top level

1215
00:40:39,110 --> 00:40:39,890
nine bits are used to

1216
00:40:39,890 --> 00:40:40,760
mean that in the first

1217
00:40:40,760 --> 00:40:42,320
top page level directory,

1218
00:40:42,320 --> 00:40:43,370
the second and the next

1219
00:40:43,370 --> 00:40:44,300
one and the third in

1220
00:40:44,300 --> 00:40:45,300
the third one.

1221
00:40:48,230 --> 00:40:50,180
因此，可能我只是没有正确理解这一点，所以当一个进程请求查找某个虚拟地址时，它会加载到SATP寄存器或CPU中，这样就会得到相应的正确的最高级别页表。
So maybe I'm just not understanding

1222
00:40:50,180 --> 00:40:51,020
this correctly,

1223
00:40:51,020 --> 00:40:54,080
so when a process requests

1224
00:40:54,080 --> 00:40:56,510
a certain virtual address to be

1225
00:40:56,510 --> 00:40:57,320
looked up,

1226
00:40:57,320 --> 00:40:58,730
it loads into the

1227
00:40:58,730 --> 00:41:00,410
satp register or the CPU

1228
00:41:00,410 --> 00:41:02,240
does and that,

1229
00:41:02,310 --> 00:41:05,070
get to the corresponding correct highest

1230
00:41:05,070 --> 00:41:07,240
level page table.

1231
00:41:07,640 --> 00:41:10,120
然后是那个页表。
And then that page table.

1232
00:41:10,620 --> 00:41:13,080
将要。我们在顶层使用了27位中的9位来索引该页目录。
will. We used in the top

1233
00:41:13,080 --> 00:41:15,390
level nine bits from the 27

1234
00:41:15,390 --> 00:41:17,380
to index into that page directory.

1235
00:41:18,670 --> 00:41:19,810
然后是什么结果呢，比如如果结果是什么都没有，MMU会创建一个页面表，不，不，MMU基本上会告诉操作系统或处理器，很抱歉我无法转换该地址，基本上会变成页面错误，我们稍后会讨论这个问题。
And then what is what is

1236
00:41:19,810 --> 00:41:20,830
the result of that,

1237
00:41:20,830 --> 00:41:22,690
like if the result is there's

1238
00:41:22,690 --> 00:41:24,490
nothing there does MMU

1239
00:41:24,490 --> 00:41:26,590
create a page table,

1240
00:41:26,590 --> 00:41:27,310
No, no,

1241
00:41:27,310 --> 00:41:28,900
MMU basically tells the operating

1242
00:41:28,900 --> 00:41:30,700
system or tells the processor,

1243
00:41:30,700 --> 00:41:33,070
sorry I couldn't translate that address,

1244
00:41:33,070 --> 00:41:35,140
and basically turns into a

1245
00:41:35,140 --> 00:41:36,340
page fault which we'll talk about

1246
00:41:36,340 --> 00:41:37,300
a little bit later.

1247
00:41:38,970 --> 00:41:41,370
但就是不能翻译地址，它不能翻译，就像你知道你不能被零除，你知道如果你试图这样做，检察官会拒绝这样做。
But just cannot translate the address,

1248
00:41:41,370 --> 00:41:42,630
it doesn't translate it's like you

1249
00:41:42,630 --> 00:41:44,070
know you can't divide by zero,

1250
00:41:44,070 --> 00:41:45,120
you know if you try to

1251
00:41:45,120 --> 00:41:46,740
do that the prosecutor refuses to

1252
00:41:46,740 --> 00:41:47,380
do it.

1253
00:41:50,130 --> 00:41:50,700
我明白了，好的。
I see, OK.

1254
00:41:54,060 --> 00:41:56,940
布兰登，你呢，布兰登。
Brandon, what about you, Brandon.

1255
00:41:56,940 --> 00:41:58,320
嗯，所以我只是想确保我理解我是怎么想的，也许我们想知道中间页是怎么排好表的，我们是怎么计算它们的物理地址的。
Um, so I just wanted to

1256
00:41:58,320 --> 00:42:00,060
make sure I understand how I

1257
00:42:00,060 --> 00:42:03,210
think maybe we want to understand

1258
00:42:03,210 --> 00:42:07,170
how the intermediate page tables well

1259
00:42:07,170 --> 00:42:08,370
how we calculate the physical address

1260
00:42:08,370 --> 00:42:09,320
of those.

1261
00:42:09,550 --> 00:42:10,420
嗯，那么，如果我们试图找到第二级页表物理地址，我们将从第一级页表中提取PPM，即44位，然后我们将原始虚拟地址的12位偏移量相加，以获得完整的56位，这是正确的吗，这个问题是。我们不将虚拟地址的偏移量相加，我们只取12个零位。
Um, so,

1262
00:42:10,420 --> 00:42:11,980
is it correct that say if

1263
00:42:11,980 --> 00:42:13,570
we're trying to find a second

1264
00:42:13,570 --> 00:42:15,400
level page tables physical address,

1265
00:42:15,400 --> 00:42:17,530
we would take the PPM from

1266
00:42:17,530 --> 00:42:18,850
the first level page table,

1267
00:42:18,850 --> 00:42:20,380
that's 44 bits and then we

1268
00:42:20,380 --> 00:42:22,150
add the 12 bit offset from

1269
00:42:22,150 --> 00:42:23,440
the original virtual address to get

1270
00:42:23,440 --> 00:42:25,060
the full 56 bit, this question

1271
00:42:25,060 --> 00:42:27,040
is. We don't add the offset

1272
00:42:27,040 --> 00:42:28,000
from the virtual address,

1273
00:42:28,000 --> 00:42:30,160
we just take twelve zero bits.

1274
00:42:30,970 --> 00:42:31,960
所以我们取PPM，有44位。好的，底部有12个零位，这给了我们一个56位的物理地址，这就是下一页目录的位置，这要求基本上每个页目录的页都要对齐。
So we take the PPM

1275
00:42:31,960 --> 00:42:34,000
there's 44 bits. Okay, 12

1276
00:42:34,000 --> 00:42:35,530
zero bits on the bottom

1277
00:42:35,530 --> 00:42:36,580
and that gives us a

1278
00:42:36,580 --> 00:42:38,620
56 bit physical address and

1279
00:42:38,620 --> 00:42:39,490
that's where the next page

1280
00:42:39,490 --> 00:42:39,670
directories,

1281
00:42:39,670 --> 00:42:41,530
and this requires that basically every

1282
00:42:41,530 --> 00:42:43,800
page directories page aligned.

1283
00:42:45,460 --> 00:42:46,330
我明白了，好的，这是有道理的。
I see,

1284
00:42:46,330 --> 00:42:48,300
OK, that makes sense.

1285
00:42:49,890 --> 00:42:50,880
这些都是很棒的问题，这些都是东西，你们会在页表实验室里苦苦挣扎。
So these are all great questions

1286
00:42:50,880 --> 00:42:51,570
and these are all things,

1287
00:42:51,570 --> 00:42:52,620
you're gonna be struggling within the

1288
00:42:52,620 --> 00:42:53,960
page table lab so.

1289
00:42:54,020 --> 00:42:55,100
是啊，现在就去问他们是非常好的。
Yeah it's very good to ask

1290
00:42:55,100 --> 00:42:56,100
them right now.

1291
00:42:59,990 --> 00:43:01,160
好的，嗯，让我想想，好的，好的，让我稍等一下。
Okay, um,

1292
00:43:01,160 --> 00:43:01,970
let me see,

1293
00:43:04,410 --> 00:43:06,600
Yes, yeah okay,

1294
00:43:06,600 --> 00:43:08,220
let me hold on for

1295
00:43:08,220 --> 00:43:09,040
a second.

1296
00:43:09,640 --> 00:43:11,180
我引用我的想法。
And I quote my thoughts.

1297
00:43:11,730 --> 00:43:14,260
嗯，我知道我在哪里了
Um I see where I am.

1298
00:43:16,320 --> 00:43:16,800
好的，一种，你知道，还有一件事我想提一下，因为你会看到，如果我们想一想，你知道我刚才展示的方案，嗯，看起来真正发生的事情是我们将价值加载或存储到内存中。
Good good,

1299
00:43:16,800 --> 00:43:17,850
good, okay,

1300
00:43:17,850 --> 00:43:20,130
one a sort of a you

1301
00:43:20,130 --> 00:43:21,600
know one other thing that I

1302
00:43:21,600 --> 00:43:23,550
want to mention because you will

1303
00:43:23,550 --> 00:43:25,770
see that, is that if

1304
00:43:25,770 --> 00:43:27,390
we think about this,

1305
00:43:27,390 --> 00:43:28,290
you know the scheme that I

1306
00:43:28,290 --> 00:43:29,460
just showed right,

1307
00:43:29,460 --> 00:43:30,660
um what really seems to be

1308
00:43:30,660 --> 00:43:32,400
going on is that we load

1309
00:43:32,400 --> 00:43:34,440
or store value to memory.

1310
00:43:34,480 --> 00:43:35,920
在处理器加载或存储价值内存的地方，我们基本上必须进行空闲内存查找，对吧，一个在页面目录的顶部，一个在中间页面目录，然后一个在最底层的页面目录。
Where the processor loads or stores

1311
00:43:35,920 --> 00:43:36,790
value memory,

1312
00:43:36,790 --> 00:43:37,930
we basically have to do free

1313
00:43:37,930 --> 00:43:39,310
memory lookups, right,

1314
00:43:39,310 --> 00:43:40,660
one in the top of the

1315
00:43:40,660 --> 00:43:41,230
page directory,

1316
00:43:41,230 --> 00:43:42,430
one intermediate page

1317
00:43:42,430 --> 00:43:43,840
directory and then one in the

1318
00:43:43,840 --> 00:43:45,280
bottom level page directory.

1319
00:43:45,500 --> 00:43:46,880
看起来，您知道任何对虚拟地址的内存引用基本上都需要空闲内存才能到达。
It looks like, that you know

1320
00:43:46,880 --> 00:43:49,010
any memory reference to virtual address

1321
00:43:49,010 --> 00:43:51,820
basically requires free memory to reach.

1322
00:43:52,380 --> 00:43:54,000
所以这似乎很贵。
And so that seems expensive.

1323
00:43:54,530 --> 00:43:55,700
嗯，那么，嗯，在几乎所有处理器都这样做的实践中会发生什么，它的一侧有一个缓存，其中包含最近使用的翻译。
Um, and so,

1324
00:43:55,700 --> 00:43:57,980
um, what happens in practice where

1325
00:43:57,980 --> 00:43:59,690
almost all every processor does this,

1326
00:43:59,690 --> 00:44:00,980
it has a cache sitting

1327
00:44:00,980 --> 00:44:02,570
on the side, that contains

1328
00:44:02,570 --> 00:44:04,400
recently used translations.

1329
00:44:05,300 --> 00:44:07,240
这被称为翻译后备缓冲器。
And this is called translation look-aside buffer.

1330
00:44:11,800 --> 00:44:13,540
那么你会经常看到这个术语，TLB。
Then you'll see that term

1331
00:44:14,400 --> 00:44:17,640
quite often, of TLB.

1332
00:44:18,400 --> 00:44:19,900
基本上，它只是条目、页表条目、PTE条目的缓存。
Basically it's nothing else than

1333
00:44:19,900 --> 00:44:20,840
the cache of

1334
00:44:22,500 --> 00:44:24,090
entry, page table entries,

1335
00:44:24,090 --> 00:44:25,260
PTE entries.

1336
00:44:28,170 --> 00:44:29,670
因此，当进程让您知道进程路由第一次查找虚拟地址时，您知道这个，硬件遍历此页，即三级页面表，您知道该特定虚拟地址的最终物理页(通常称为PPN)，然后基本上TLB存储VA、PA、PN或PA映射。
So when the process has you

1337
00:44:29,670 --> 00:44:30,720
know the first time the process

1338
00:44:30,720 --> 00:44:32,100
routes look through virtual address,

1339
00:44:32,100 --> 00:44:34,440
you know walks this, hardware

1340
00:44:34,440 --> 00:44:37,140
walks this page, the the three

1341
00:44:37,140 --> 00:44:38,940
level page tables, that will come

1342
00:44:38,940 --> 00:44:40,470
out with you know the final

1343
00:44:40,470 --> 00:44:42,750
physical page, often called PPN,

1344
00:44:42,750 --> 00:44:44,520
for that particular virtual address,

1345
00:44:44,520 --> 00:44:46,320
and then basically the

1346
00:44:46,320 --> 00:44:47,160
TLB stores,

1347
00:44:47,160 --> 00:44:49,440
VA, PA, PN,

1348
00:44:49,980 --> 00:44:52,950
or PA mapping

1349
00:44:52,950 --> 00:44:53,900
on the side.

1350
00:44:53,930 --> 00:44:54,320
因此，下一次您提到那个特定的虚拟地址时。
And so,

1351
00:44:54,320 --> 00:44:55,670
then the next time you refer

1352
00:44:55,670 --> 00:44:57,520
to that particular virtual address.

1353
00:44:57,490 --> 00:44:58,780
我只需直视TLB中的上方，TLB就会做出响应，而不必执行页表遍历。
I can just look at straight

1354
00:44:58,780 --> 00:45:00,490
up in the TLB and the

1355
00:45:00,490 --> 00:45:02,290
TLB will respond instead of having

1356
00:45:02,290 --> 00:45:03,580
to do the page table walk.

1357
00:45:05,300 --> 00:45:07,400
嗯，是的，艾米亚。
Um, yep, Amiar.

1358
00:45:09,700 --> 00:45:13,260
因此，TLB将虚拟地址映射到页面的物理地址，虚拟地址和偏移量是绝对正确的，在页表级别进行缓存不是更有效吗？
So, the TLB map

1359
00:45:13,490 --> 00:45:16,010
virtual addresses to the physical address

1360
00:45:16,010 --> 00:45:17,960
of the page that the virtual

1361
00:45:17,960 --> 00:45:20,690
address along with the offset you're

1362
00:45:20,690 --> 00:45:22,490
absolutely right,

1363
00:45:22,490 --> 00:45:24,290
wouldn't it be more efficient

1364
00:45:24,290 --> 00:45:25,520
to like cache at the

1365
00:45:25,520 --> 00:45:27,060
page table level.

1366
00:45:27,770 --> 00:45:30,290
嗯，好的，我再退一步，嗯，实施<foreign language=“English”>TLB</foreign>有很多种方式，嗯，最重要的是要知道，有一个<foreign language=“English”>TLB</foreign>。
Um, okay so I let me

1367
00:45:30,290 --> 00:45:31,400
take a step back here,

1368
00:45:31,400 --> 00:45:33,020
um, there are many ways of

1369
00:45:33,020 --> 00:45:34,550
implementing the TLB,

1370
00:45:34,550 --> 00:45:35,930
um, the most important thing that

1371
00:45:35,930 --> 00:45:36,710
you need to know is that

1372
00:45:36,710 --> 00:45:37,760
there is a TLB.

1373
00:45:38,230 --> 00:45:40,300
嗯，TLB具体是怎么实施的，这种你知道的，我们不会讲太多细节的话题。
Um, and the exact details

1374
00:45:40,300 --> 00:45:41,410
of actually how the TLB

1375
00:45:41,410 --> 00:45:42,430
has implemented, this sort of

1376
00:45:42,430 --> 00:45:43,690
you know not a topic

1377
00:45:43,690 --> 00:45:44,590
that we're going to talk

1378
00:45:44,590 --> 00:45:45,490
about in great amount of

1379
00:45:45,490 --> 00:45:46,260
detail.

1380
00:45:46,400 --> 00:45:47,930
嗯，那根本不是，嗯，所以这实际上是位于处理器内部的东西，大部分对操作系统是隐藏的，操作系统并不真的知道TLB BE是如何操作的，你需要知道TLB存在的唯一原因是，如果你切换页表。
Um, that's not at all,

1381
00:45:47,930 --> 00:45:49,520
um, and so this is really

1382
00:45:49,520 --> 00:45:50,900
something that sits inside of the

1383
00:45:50,900 --> 00:45:52,400
processor and is mostly hidden from

1384
00:45:52,400 --> 00:45:53,120
the operating system,

1385
00:45:53,120 --> 00:45:54,470
the operating system doesn't really know

1386
00:45:54,470 --> 00:45:57,020
how to TLB be operates, the

1387
00:45:57,020 --> 00:45:58,190
only thing the reason you need

1388
00:45:58,190 --> 00:45:59,180
to know that the TLB

1389
00:45:59,180 --> 00:46:01,550
exist is that if you switch

1390
00:46:01,550 --> 00:46:02,620
page tables.

1391
00:46:03,710 --> 00:46:06,470
然后，通常操作系统需要告诉处理器正在切换页表。
Then, typically the operating system needs

1392
00:46:06,470 --> 00:46:08,960
to tell the processor that's switching

1393
00:46:08,960 --> 00:46:10,140
page tables.

1394
00:46:10,760 --> 00:46:12,560
并且需要刷新TLB。
And the

1395
00:46:12,950 --> 00:46:14,740
TLB needs to be flushed.

1396
00:46:16,810 --> 00:46:18,070
因为基本上您发送的是陈旧的条目，但是如果您切换到新的页表，TLB中的条目可能不再有效，因此需要删除它们，否则您知道转换将是不正确的。
Because basically you send you

1397
00:46:18,070 --> 00:46:18,820
stale entries,

1398
00:46:18,820 --> 00:46:19,660
but if you switch to a

1399
00:46:19,660 --> 00:46:20,890
new page table,

1400
00:46:20,890 --> 00:46:22,360
the entries in the TLB may

1401
00:46:22,360 --> 00:46:24,130
not be valid anymore and so

1402
00:46:24,130 --> 00:46:25,840
they need to be removed because

1403
00:46:25,840 --> 00:46:27,370
otherwise you know the translation would

1404
00:46:27,370 --> 00:46:28,240
be incorrect.

1405
00:46:28,830 --> 00:46:30,540
所以操作系统通常会意识到有一个，有一个TLB，基本上只是偶尔告诉硬件，好的，我们不再使用它们了，因为我要交换页表。
And so the operating system is

1406
00:46:30,540 --> 00:46:32,100
typically where

1407
00:46:32,260 --> 00:46:33,340
it's aware that there's a,

1408
00:46:33,340 --> 00:46:34,960
that there is a TLB

1409
00:46:34,960 --> 00:46:36,880
only basically to tell the

1410
00:46:36,880 --> 00:46:37,990
hardware once in a while saying,

1411
00:46:37,990 --> 00:46:39,700
okay well don't use them anymore,

1412
00:46:39,700 --> 00:46:41,740
because I'm gonna switch page tables.

1413
00:46:44,140 --> 00:46:45,820
事实上，在RISC-V上，刷新TLB的指令称为sfence_vma。
And in fact on you know

1414
00:46:45,820 --> 00:46:50,350
the, the RISC-V, the instruction

1415
00:46:50,350 --> 00:46:51,880
to flush the TLB is called

1416
00:46:51,880 --> 00:46:55,200
sfence_vma.

1417
00:46:57,280 --> 00:46:59,080
实际上我不是。
I'm not actually.

1418
00:46:59,750 --> 00:47:02,100
刷新TLB。[双背]。
Flush the TLB. [Biback].

1419
00:47:04,770 --> 00:47:06,000
所以我有一个问题，不是关于TLB，而是带来了这个问题。
So I have a question,

1420
00:47:06,000 --> 00:47:08,190
like not regarding TLB

1421
00:47:08,190 --> 00:47:10,110
but that brought kind

1422
00:47:10,110 --> 00:47:11,820
of this question.

1423
00:47:11,970 --> 00:47:14,970
三级支持，即我们拥有的三级分页，是由操作系统还是硬件本身实现的。它是在硬件中实现的。
The three level support, that the

1424
00:47:14,970 --> 00:47:17,820
three level paging that we have,

1425
00:47:17,820 --> 00:47:19,710
is it implemented by the operating

1426
00:47:19,710 --> 00:47:21,690
system or the hardware itself. It

1427
00:47:21,690 --> 00:47:23,060
implemented in hardware.

1428
00:47:23,450 --> 00:47:24,830
所以你知道所有的事情都发生在硬件上，内存管理单元是硬件的挡路。
So you know there's all happens

1429
00:47:24,830 --> 00:47:25,670
in hardware,

1430
00:47:25,670 --> 00:47:27,500
the MMU is a block

1431
00:47:27,500 --> 00:47:28,460
of hardware.

1432
00:47:28,730 --> 00:47:30,440
在操作系统中，我们很快就会看到xv6，xv6有一个模拟页表遍历的函数，因为有时您知道xv6基本上必须做硬件所做的事情。
In the operating system we'll

1433
00:47:30,440 --> 00:47:32,120
see in a second when we

1434
00:47:32,120 --> 00:47:34,190
look at xv6, xv6

1435
00:47:34,190 --> 00:47:36,320
has a function that models the

1436
00:47:36,320 --> 00:47:37,640
page table walk, because once in

1437
00:47:37,640 --> 00:47:39,260
a while you know xv6

1438
00:47:39,260 --> 00:47:40,430
basically has to do what the

1439
00:47:40,430 --> 00:47:41,360
hardware does.

1440
00:47:42,040 --> 00:47:43,570
嗯，所以它知道它没有一个叫WALK的功能，基本上做的是完全一样的事情，但是是在软件中。
Um, and so it knows

1441
00:47:43,570 --> 00:47:44,380
it doesn't have a function

1442
00:47:44,380 --> 00:47:45,970
called walk, that basically does

1443
00:47:45,970 --> 00:47:47,560
exactly the same thing,

1444
00:47:47,560 --> 00:47:48,900
but in software.

1445
00:47:51,360 --> 00:47:54,510
那么，我能问个问题吗？那么，嗯，在此方案中，处理器缓存适合的位置是在地址转换之前还是之后，因为。好的，好的，让我来，让我们往后调几个，让我想想。
So, can I ask a question?

1446
00:47:54,510 --> 00:47:56,140
So um,

1447
00:47:56,660 --> 00:47:58,670
where in this scheme does the

1448
00:47:58,670 --> 00:48:00,170
processor cache fit,

1449
00:48:00,170 --> 00:48:02,510
does it happen before the address

1450
00:48:02,510 --> 00:48:04,300
translation or after,

1451
00:48:04,510 --> 00:48:06,700
because. Yeah, okay let me so

1452
00:48:06,700 --> 00:48:07,840
let's switch back a little bit

1453
00:48:07,840 --> 00:48:10,800
a couple, let me see.

1454
00:48:13,120 --> 00:48:14,980
好的，通常MMU真正思考的方式就是所有这些东西。
Okay, usually MMU will

1455
00:48:14,980 --> 00:48:17,170
really the way to think about

1456
00:48:17,170 --> 00:48:18,720
is that all this stuff.

1457
00:48:19,870 --> 00:48:21,220
你知道整个挡路都在处理器硅里。
You know the whole block is

1458
00:48:21,220 --> 00:48:22,900
inside the processor silicon.

1459
00:48:24,350 --> 00:48:25,310
所以这里有一个RISC-V芯片，它的内部是CPU，实际上有多个正确的CPU，有4个核心。
So there's a RISC-V

1460
00:48:25,310 --> 00:48:27,080
chip and inside of it

1461
00:48:27,080 --> 00:48:27,920
is the CPU,

1462
00:48:27,920 --> 00:48:29,270
in fact there are multiple CPU

1463
00:48:29,270 --> 00:48:30,640
correct, there 4 cores.

1464
00:48:30,740 --> 00:48:32,240
这是一个MMU，你可以想一想，在CPU这一边，你知道有一个TLB。
And there's a MMU

1465
00:48:32,240 --> 00:48:33,500
and you know you can think

1466
00:48:33,500 --> 00:48:34,040
about that,

1467
00:48:34,040 --> 00:48:35,150
either on this on the

1468
00:48:35,150 --> 00:48:35,990
CPU side,

1469
00:48:35,990 --> 00:48:37,780
you know there's a TLB.

1470
00:48:44,460 --> 00:48:45,210
这是有道理的，嗯，但我想我的问题是关于类似的，缓存不是TLB，而是一个普通的缓存，比如，有时我们实际上不会一直访问内存。
That makes sense,

1471
00:48:45,210 --> 00:48:47,190
um, but I guess my question

1472
00:48:47,190 --> 00:48:48,560
was about the like,

1473
00:48:48,700 --> 00:48:51,550
cache in terms of not

1474
00:48:51,550 --> 00:48:52,120
the TLB,

1475
00:48:52,120 --> 00:48:55,000
but just a normal cache like,

1476
00:48:55,000 --> 00:48:56,290
sometimes we don't actually go all

1477
00:48:56,290 --> 00:48:58,000
the way to access the memory.

1478
00:48:58,000 --> 00:48:59,470
好的，我想我应该在上周的周一正确地计划RISC-V处理器，现在有一个缓存，有两个缓存。
Yeah, good points I think I

1479
00:48:59,470 --> 00:49:00,850
should like to scheme last week

1480
00:49:00,850 --> 00:49:02,590
correctly on monday of the RISC-V

1481
00:49:02,590 --> 00:49:04,300
processor and has now one cache

1482
00:49:04,300 --> 00:49:05,700
it has two cache.

1483
00:49:05,970 --> 00:49:08,100
有些高速缓存按物理地址索引，有些高速缓存按虚拟地址索引。
Some caches are indexed by physical

1484
00:49:08,100 --> 00:49:10,530
address, some caches are indexed by

1485
00:49:10,530 --> 00:49:11,540
virtual address.

1486
00:49:11,800 --> 00:49:13,030
因此，按虚拟地址索引的高速缓存位于MMU之前。
So the caches that are indexed

1487
00:49:13,030 --> 00:49:15,280
by virtual address sit before the

1488
00:49:15,280 --> 00:49:16,160
MMU.

1489
00:49:16,540 --> 00:49:17,800
并通过MMU之后的物理地址在它们的索引中进行高速缓存。
And cache in their index by

1490
00:49:17,800 --> 00:49:19,820
physical addresses after the MMU.

1491
00:49:25,010 --> 00:49:25,820
这说得通吗？我也可以问一个问题吗？我的问题是，你说TLB，它是行走的，所以我喜欢把东西放进TLB，硬件遍历页表。
Does that make sense?

1492
00:49:25,820 --> 00:49:27,410
Can I also ask a question

1493
00:49:27,410 --> 00:49:28,850
my question is,

1494
00:49:28,850 --> 00:49:31,760
you said that the TLB,

1495
00:49:31,760 --> 00:49:33,470
it walks so I like to

1496
00:49:33,470 --> 00:49:34,880
put stuff into TLB,

1497
00:49:34,880 --> 00:49:37,310
the hardware walks through the

1498
00:49:37,310 --> 00:49:38,600
page tables.

1499
00:49:39,830 --> 00:49:42,380
如果硬件可以做到这一点，我们为什么要达到步行功能。
Why do we arrive walk function,

1500
00:49:42,380 --> 00:49:44,400
if hardware can do that.

1501
00:49:44,560 --> 00:49:45,790
很好的问题，嗯，我们有几个原因，或者为什么xv6需要它，一个是它实际设置初始页表的时候。
Very good question,

1502
00:49:45,790 --> 00:49:48,220
um, one reason we have, a

1503
00:49:48,220 --> 00:49:49,270
couple of reasons why we do

1504
00:49:49,270 --> 00:49:51,370
it or why xv6 needs it,

1505
00:49:51,370 --> 00:49:52,630
one is when it actually sets

1506
00:49:52,630 --> 00:49:54,160
up the initial page tables.

1507
00:49:54,980 --> 00:49:56,360
嗯，你知道它需要对三级进行编程。
Um, you know it needs to

1508
00:49:56,360 --> 00:49:58,560
program the the three levels.

1509
00:49:58,680 --> 00:49:59,940
所以它需要基本上模仿这三个层次。
And so it needs to basically

1510
00:49:59,940 --> 00:50:01,420
emulate the three levels.

1511
00:50:02,120 --> 00:50:03,980
嗯，还有另一个例子，您实际上在syscall实验室中遇到或正在遇到的是，当您复制xv6时，内核有自己的页表，每个用户地址空间都有自己的页表。
Um, and um,

1512
00:50:03,980 --> 00:50:05,090
another example,

1513
00:50:05,090 --> 00:50:06,740
that you actually sort of run

1514
00:50:06,740 --> 00:50:08,630
into or are running into in

1515
00:50:08,630 --> 00:50:10,550
the syscall lab is that when

1516
00:50:10,550 --> 00:50:12,680
you copy the xv6, the

1517
00:50:12,680 --> 00:50:14,540
kernel has its own page table

1518
00:50:14,540 --> 00:50:16,550
and every user address space has

1519
00:50:16,550 --> 00:50:17,700
its own page table.

1520
00:50:18,140 --> 00:50:19,580
偶尔，例如，它会说信息就像系统一样，指向系统基础设施，你知道它生活在用户空间。
And with once in a while,

1521
00:50:19,580 --> 00:50:21,620
for example it says info go like

1522
00:50:21,620 --> 00:50:23,510
system, pointed to system infrastructure,

1523
00:50:23,510 --> 00:50:24,440
you know that lives in

1524
00:50:24,440 --> 00:50:25,460
user space.

1525
00:50:25,610 --> 00:50:27,260
需要将内核转换为它可以用来写入它的地址。
The kernel needs to be translated

1526
00:50:27,260 --> 00:50:28,460
to an address that it can

1527
00:50:28,460 --> 00:50:29,760
use to write it.

1528
00:50:30,340 --> 00:50:31,120
所以，举个例子，如果你看的是拷贝入或拷贝出。
And so,

1529
00:50:31,120 --> 00:50:32,710
for example if you're looking copy

1530
00:50:32,710 --> 00:50:34,600
in or copy out.

1531
00:50:34,730 --> 00:50:38,480
嗯，基本上内核使用用户虚拟来转换用户虚拟地址，使用用户页表来获取该内核的物理地址，然后获得一个地址，实际上内核可以使用该地址来读写该内存。
Um, basically the kernel translates the

1532
00:50:38,480 --> 00:50:41,420
user virtual address using the user

1533
00:50:41,420 --> 00:50:44,030
virtual, using a user page

1534
00:50:44,030 --> 00:50:45,410
table to get out of physical

1535
00:50:45,410 --> 00:50:46,520
address that that kernel,

1536
00:50:46,520 --> 00:50:49,760
then get an address out,

1537
00:50:49,760 --> 00:50:51,050
actually the kernel can use to

1538
00:50:51,050 --> 00:50:52,220
read and write that memory.

1539
00:50:54,580 --> 00:50:55,390
所以有一大堆地方会出现，我希望在10分钟或15分钟内谈到。
So there's a bunch of places

1540
00:50:55,390 --> 00:50:56,800
going to show up and I'll

1541
00:50:56,800 --> 00:50:58,630
talk about hopefully in whatever ten

1542
00:50:58,630 --> 00:51:00,000
minutes or fifteen minutes.

1543
00:51:00,610 --> 00:51:01,720
我有一个问题，为什么像这样的硬件不公开那个遍历函数，这样我们就不必编写自己的函数，而且里面可能有bug，为什么不像这样，也许有一个特权指令，你可以传递一个虚拟地址，然后返回物理地址。
I have a question,

1544
00:51:01,720 --> 00:51:05,350
why doesn't the hardware like expose

1545
00:51:05,350 --> 00:51:06,430
that walk function,

1546
00:51:06,430 --> 00:51:07,300
so we don't have to write

1547
00:51:07,300 --> 00:51:08,890
our own and potentially have bugs

1548
00:51:08,890 --> 00:51:09,430
in it,

1549
00:51:09,430 --> 00:51:11,740
why isn't there like, maybe

1550
00:51:11,740 --> 00:51:12,970
a privileged instruction that you can

1551
00:51:12,970 --> 00:51:14,290
pass a virtual address and will

1552
00:51:14,290 --> 00:51:16,120
give back the physical address.

1553
00:51:16,370 --> 00:51:17,690
嗯，这就像是存储到虚拟地址，你回来，我们会为你做好的，嗯，所以我稍后会看到，在下一个实验中，页表实验室，实际上就是你要做的事情，你实际上会以稍微不同的方式设置页表，这样你就可以避免走进或复制和复制。
Well, this is just like just

1554
00:51:17,690 --> 00:51:18,770
store to the virtual address,

1555
00:51:18,770 --> 00:51:20,480
you get back and we'll do

1556
00:51:20,480 --> 00:51:21,740
it right for you,

1557
00:51:21,740 --> 00:51:23,450
um, so I will see

1558
00:51:23,450 --> 00:51:24,380
later on,

1559
00:51:24,380 --> 00:51:26,750
in the next lab,

1560
00:51:26,750 --> 00:51:27,890
the page table lab,

1561
00:51:27,890 --> 00:51:29,090
in fact is exactly what you'll

1562
00:51:29,090 --> 00:51:30,650
be doing you'll actually set up

1563
00:51:30,650 --> 00:51:32,240
the page table slightly differently,

1564
00:51:32,240 --> 00:51:33,440
so that you can avoid the

1565
00:51:33,440 --> 00:51:36,980
walk in or copyin and copyinstr.

1566
00:51:42,500 --> 00:51:43,640
我想这一点在我们谈到xv6的时候就会变得清晰起来，好的。
I think this will become clear

1567
00:51:43,640 --> 00:51:44,780
in the second we when we

1568
00:51:44,780 --> 00:51:45,590
talk about we look at the

1569
00:51:45,590 --> 00:51:46,960
xv6, OK.

1570
00:51:49,700 --> 00:51:51,400
好的，很好。
Okay, good.

1571
00:51:51,800 --> 00:51:54,260
在跳到xv6之前，还有一个基本上可以肯定的是，我想说明一点。
One more sure basically before jumping

1572
00:51:54,260 --> 00:51:56,060
into xv6, I wanted to make

1573
00:51:56,060 --> 00:51:57,400
one point.

1574
00:51:57,540 --> 00:52:00,060
一种方式来考虑，嗯，你知道，页表。
One way to think about,

1575
00:52:00,060 --> 00:52:01,770
um, you know,

1576
00:52:03,150 --> 00:52:04,200
page tables.

1577
00:52:05,980 --> 00:52:07,390
一种流行的说法，这个嗯。
A popular way

1578
00:52:07,390 --> 00:52:07,870
to phrase,

1579
00:52:07,870 --> 00:52:09,720
this um.

1580
00:52:09,930 --> 00:52:13,040
页表提供了一定程度的间接性。
It's the page tables provide

1581
00:52:13,300 --> 00:52:14,980
a level of indirection.

1582
00:52:25,100 --> 00:52:27,140
基本上这是间接的，你知道从虚拟地址到物理地址的映射。
And, that and, so basically

1583
00:52:27,140 --> 00:52:27,890
this indirection,

1584
00:52:27,890 --> 00:52:28,880
what I'm talking about you know

1585
00:52:28,880 --> 00:52:30,200
this mapping from virtual address to

1586
00:52:30,200 --> 00:52:31,260
physical address.

1587
00:52:31,490 --> 00:52:33,440
并且该映射完全在操作系统的控制之下。
And this mapping is completely

1588
00:52:33,440 --> 00:52:34,700
under control

1589
00:52:35,130 --> 00:52:36,500
of the operating system.

1590
00:52:38,350 --> 00:52:40,720
正如我们已经看到的，你知道在最后几张幻灯片中，我们谈到，嗯，这意味着操作系统因为它有这么多的控制权，它有完全的控制权，翻译，它可以做各种有趣的把戏。
As we've seen, you know in the last

1591
00:52:40,720 --> 00:52:41,350
a couple slides that

1592
00:52:41,350 --> 00:52:42,280
we talk,

1593
00:52:42,280 --> 00:52:43,780
um, and that means that the

1594
00:52:43,780 --> 00:52:45,640
operating system because it has so

1595
00:52:45,640 --> 00:52:46,540
much control,

1596
00:52:46,540 --> 00:52:48,520
it has control complete control that

1597
00:52:48,520 --> 00:52:50,740
translation, it can do all

1598
00:52:50,740 --> 00:52:52,060
kinds of interesting tricks.

1599
00:52:52,660 --> 00:52:54,370
嗯，举个例子，就像一个小把戏，稍微谈谈这个，比如如果一个页面，页面条目是无效的，并且真的会返回一个页面，你知道硬件会引发页面错误。
Um, and so for example, like

1600
00:52:54,370 --> 00:52:56,260
one trick, talk a little

1601
00:52:56,260 --> 00:52:56,860
bit about this,

1602
00:52:56,860 --> 00:52:58,630
like if a page, page entry is

1603
00:52:58,630 --> 00:53:00,790
invalid and will really return a

1604
00:53:00,790 --> 00:53:02,200
page you know the hardware will

1605
00:53:02,200 --> 00:53:04,440
raise page fault.

1606
00:53:04,820 --> 00:53:05,510
作为响应，页错误，操作系统可以更新页表，然后可能重新启动指令。
In response,

1607
00:53:05,510 --> 00:53:06,530
the page fault,

1608
00:53:06,530 --> 00:53:08,150
the operating system could update

1609
00:53:08,150 --> 00:53:09,410
the page tables and then

1610
00:53:09,410 --> 00:53:11,120
maybe restart the instruction.

1611
00:53:11,620 --> 00:53:12,640
因此，在运行时，通过操作页表，它们可以做各种各样的事情。
And so there are all kinds

1612
00:53:12,640 --> 00:53:14,230
of things they can do, at

1613
00:53:14,230 --> 00:53:17,620
runtime, and by manipulating

1614
00:53:17,620 --> 00:53:18,740
the page tables.

1615
00:53:19,160 --> 00:53:20,660
我们今天不会讨论这个话题，但是两周后，我们会讲授这个话题，一旦你有了页表和页面错误，你可以做什么很酷的事情。
And we're not going to talk

1616
00:53:20,660 --> 00:53:22,070
about it to today,

1617
00:53:22,070 --> 00:53:23,300
but in two weeks,

1618
00:53:23,300 --> 00:53:25,880
we'll have a lecture exactly about

1619
00:53:25,880 --> 00:53:27,680
this topic about what cool things

1620
00:53:27,680 --> 00:53:28,970
can you do once you have

1621
00:53:28,970 --> 00:53:30,420
page tables and page faults.

1622
00:53:31,170 --> 00:53:32,430
嗯，但重要的是要记住，这是一种令人难以置信的强大机制。
Um, but it's important to keep

1623
00:53:32,430 --> 00:53:35,310
in mind that this is

1624
00:53:35,310 --> 00:53:38,480
incredibly powerful mechanism.

1625
00:53:38,540 --> 00:53:39,230
嗯，那会给操作系统带来极大的灵活性。
Um that,

1626
00:53:39,230 --> 00:53:40,820
will provide the operating system

1627
00:53:40,820 --> 00:53:42,700
with a tremendous amount of flexibility.

1628
00:53:43,420 --> 00:53:44,890
页表如此受欢迎的原因有一个。
And there's one reason why page

1629
00:53:44,890 --> 00:53:46,520
tables are so popular.

1630
00:53:49,520 --> 00:53:50,780
好的，我接下来要做的实际上是讨论xv6。
Okay, so what I wanna do

1631
00:53:50,780 --> 00:53:53,960
next is actually talk about xv6.

1632
00:53:54,570 --> 00:53:56,550
嗯，稍微看看在xv6中会有什么效果。
Um, sort of see how

1633
00:53:56,550 --> 00:53:59,240
it all plays out in xv6.

1634
00:53:59,600 --> 00:54:00,500
所以我要做的第一件事，是看看内核页面布局，如果你愿意的话，映射在这张幻灯片上，这是内核的虚拟地址空间。
So the first thing I'm gonna

1635
00:54:00,500 --> 00:54:02,060
do, is going to look

1636
00:54:02,060 --> 00:54:05,000
at the kernel page layout,

1637
00:54:05,000 --> 00:54:08,380
if you will, and

1638
00:54:08,430 --> 00:54:10,200
the mapping is on this slide,

1639
00:54:10,200 --> 00:54:11,560
so here's the

1640
00:54:12,080 --> 00:54:13,680
virtual address space

1641
00:54:19,860 --> 00:54:21,900
of the kernel.

1642
00:54:23,470 --> 00:54:24,070
这是，实际上是物理内存，所以这基本上就是你能想到的任何东西，这就是DRAM。
Here is,

1643
00:54:24,070 --> 00:54:25,390
actually the physical memory,

1644
00:54:25,390 --> 00:54:27,040
so this is basically whatever you

1645
00:54:27,040 --> 00:54:28,580
can think about this is DRAM.

1646
00:54:31,760 --> 00:54:33,470
事实上并非如此，让我马上收回这一点，其中一个部分是DRAM。
And in fact it is not,

1647
00:54:33,470 --> 00:54:35,870
let me take that back immediately

1648
00:54:35,870 --> 00:54:37,780
one part is DRAM.

1649
00:54:38,560 --> 00:54:40,090
其中一部分实际上是IO设备。
And one part is actually

1650
00:54:40,090 --> 00:54:41,440
IO devices.

1651
00:54:46,060 --> 00:54:46,990
嗯，也许我会先谈一下幻灯片的右边，然后我们再谈第二张幻灯片的左边。
Um, and so,

1652
00:54:46,990 --> 00:54:48,970
to sort of maybe, I'm

1653
00:54:48,970 --> 00:54:50,050
going to talk about the physical,

1654
00:54:50,050 --> 00:54:51,400
the right side of the slide a

1655
00:54:51,400 --> 00:54:52,330
little bit first and then we'll

1656
00:54:52,330 --> 00:54:53,320
talk about the left side in

1657
00:54:53,320 --> 00:54:54,020
the second.

1658
00:54:54,310 --> 00:54:55,450
因此，幻灯片的左侧完全由硬件决定。
So the left side of

1659
00:54:55,450 --> 00:54:57,700
the slide is completely determined

1660
00:54:57,700 --> 00:54:58,520
by the hardware.

1661
00:54:58,930 --> 00:55:00,670
嗯，所以硬件设计师基本上决定了合身的布局，你知道的，就像你上周看到的那样。
Um, and so the hardware designers

1662
00:55:00,670 --> 00:55:02,620
basically determined the layout of that

1663
00:55:02,620 --> 00:55:04,270
fit and you know as you saw

1664
00:55:04,270 --> 00:55:05,580
before last week.

1665
00:55:05,640 --> 00:55:08,070
当内核启动时，它从此地址0x8000开始。
When the kernel starts,

1666
00:55:08,070 --> 00:55:11,060
it starts at this address 0x8000.

1667
00:55:11,740 --> 00:55:13,900
嗯，这是由硬件设计师决定的。
Um, and that's determined by the

1668
00:55:13,900 --> 00:55:15,000
hardware designers.

1669
00:55:15,130 --> 00:55:17,380
嗯，所以你应该更清楚地说，嗯，如果你看电路板，这是我周一展示的同一张电路板的图片，但希望是更好的图片，很容易看到，这是我们的RISC-V处理器。
Um, and so you should be

1670
00:55:17,380 --> 00:55:18,370
more explicit,

1671
00:55:18,370 --> 00:55:19,810
um, if you look at

1672
00:55:19,810 --> 00:55:20,500
the board,

1673
00:55:20,500 --> 00:55:21,490
this is the same picture of

1674
00:55:21,490 --> 00:55:22,990
the board, that I showed on

1675
00:55:22,990 --> 00:55:24,190
monday but is hopefully a little

1676
00:55:24,190 --> 00:55:25,240
better picture,

1677
00:55:25,240 --> 00:55:26,290
it's easy to see,

1678
00:55:26,290 --> 00:55:28,260
here's our RISC-V processor.

1679
00:55:28,420 --> 00:55:29,650
我们现在知道RISC-V处理器是正确的，有四个内核，但也有MMU。
And we now know correct in

1680
00:55:29,650 --> 00:55:30,640
the RISC-V processor,

1681
00:55:30,640 --> 00:55:32,230
there four cores, but there's also,

1682
00:55:32,230 --> 00:55:33,220
MMU.

1683
00:55:33,280 --> 00:55:35,650
还有一个TLB或多个TLB，每个内核都有自己的MMU，每个内核都有自己的TLB。
And there's also a TLB or

1684
00:55:35,650 --> 00:55:37,330
multiple TLB, every core has its

1685
00:55:37,330 --> 00:55:38,890
own MMU and every

1686
00:55:38,890 --> 00:55:40,400
core has its own TLB.

1687
00:55:40,800 --> 00:55:42,880
这是DRAM芯片。
And here are DRAM chips.

1688
00:55:43,780 --> 00:55:46,240
所以基本上电路板的设计者已经决定，当你知道，在你知道，在从虚拟地址到物理地址的转换之后，你知道，从08开始的基本物理地址，你知道，很多零实际上进入了DRAM芯片，你知道，当你知道，你知道，在从虚拟地址到物理地址的转换之后，你知道，很多零实际上进入了DRAM芯片。
And so basically the designers of

1689
00:55:46,240 --> 00:55:47,890
the board have decided that,

1690
00:55:47,890 --> 00:55:50,800
when, you know, after, you

1691
00:55:50,800 --> 00:55:52,300
know, the translation from virtual to

1692
00:55:52,300 --> 00:55:54,670
physical address basic physical addresses that's

1693
00:55:54,670 --> 00:55:56,620
starting you know at 08,

1694
00:55:56,620 --> 00:55:58,420
you know, a lot of zeros actually go to

1695
00:55:58,420 --> 00:55:59,540
the dram chips.

1696
00:56:00,770 --> 00:56:03,350
0a8以下的地址可能去往不同的IO设备。
Addresses above below 0a8, may go

1697
00:56:03,350 --> 00:56:04,900
to different IO devices.

1698
00:56:05,260 --> 00:56:07,690
所以平台基本上决定了设计者，这块板确切地决定了物理布局。
And so the platform decides

1699
00:56:07,690 --> 00:56:10,120
basically the designers this board have

1700
00:56:10,120 --> 00:56:12,300
decided exactly what the physical layout.

1701
00:56:12,760 --> 00:56:13,720
我想你可以查一下物理布局，如果你想调整，让我给你看看，这是我在，嗯，在，嗯，星期一给你看的同一本手册，如果你真的转到第31页，我相信。
I think you can look that

1702
00:56:13,720 --> 00:56:14,800
up the physical layout,

1703
00:56:14,800 --> 00:56:16,390
if you want to adjust,

1704
00:56:16,390 --> 00:56:17,710
let me show you so here's

1705
00:56:17,710 --> 00:56:19,420
the same manual that I showed

1706
00:56:19,420 --> 00:56:20,600
you on, um,

1707
00:56:21,990 --> 00:56:23,060
on um,

1708
00:56:24,230 --> 00:56:26,210
on um, Monday and if you

1709
00:56:26,210 --> 00:56:28,940
go to actually,

1710
00:56:29,510 --> 00:56:30,860
go to page,

1711
00:56:30,860 --> 00:56:32,360
31 I believe.

1712
00:56:32,820 --> 00:56:35,520
是的，这是一页，如果你往下看，这就是内存，它会写出内存图，在电路板上，我们会看到在地址0，0是预留的，那里什么都没有。
Yeah it's a page and

1713
00:56:35,520 --> 00:56:36,150
if you go down,

1714
00:56:36,150 --> 00:56:37,530
this is whats the memory,

1715
00:56:37,530 --> 00:56:39,000
it will spell out the memory

1716
00:56:39,000 --> 00:56:42,150
map is, of the  board

1717
00:56:42,150 --> 00:56:43,530
and we'll see at address zero

1718
00:56:43,530 --> 00:56:45,700
zero is reserved nothing is there.

1719
00:56:46,000 --> 00:56:48,940
嗯，如果你往下滚动这张内存映射图，你会看到关于映射的所有不同事物的一些信息，例如，以太网板映射到OX1，你知道，0x什么的。
Um, if you go scroll down

1720
00:56:48,940 --> 00:56:49,990
in this memory map,

1721
00:56:49,990 --> 00:56:52,810
you'll see some information about all

1722
00:56:52,810 --> 00:56:54,100
the different things that are mapped,

1723
00:56:54,100 --> 00:56:56,500
for example, ethernet board is mapped

1724
00:56:56,500 --> 00:56:58,300
at Ox1, you know,

1725
00:56:58,300 --> 00:56:59,440
0x something.

1726
00:57:00,040 --> 00:57:02,320
嗯，如果你可以再往下一点的话，哎呀，太往下了。
Um, if you might go further

1727
00:57:02,320 --> 00:57:04,940
down, oops, too much down.

1728
00:57:05,040 --> 00:57:05,910
嗯，在这里，您可以看到0x8000的条目有效，这实际上是DDR内存，片外易失性存储器，所以这些是DRAM芯片，或者我可以在上一张幻灯片上展示给您看。
Um, here,

1729
00:57:05,910 --> 00:57:08,100
you see the entry for

1730
00:57:08,100 --> 00:57:10,740
0x8000 worked

1731
00:57:10,740 --> 00:57:13,260
and that actually is DDR memory,

1732
00:57:13,260 --> 00:57:15,180
the Off-Chip Volatile Memory, so

1733
00:57:15,180 --> 00:57:16,500
those are the DRAM chips or

1734
00:57:16,500 --> 00:57:17,250
I can show you on the

1735
00:57:17,250 --> 00:57:18,220
previous slide.

1736
00:57:19,520 --> 00:57:20,390
所以，保持头脑清醒是很好的，即使我们在和QEMU交谈，你是在监督软件，最终一切都是由你知道的实际董事会决定的。
And so it's just good

1737
00:57:20,390 --> 00:57:21,380
to keep your head correct

1738
00:57:21,380 --> 00:57:22,370
even though we're talking to

1739
00:57:22,370 --> 00:57:24,350
QEMU, you're overseeing software in

1740
00:57:24,350 --> 00:57:26,030
the end everything is determined,

1741
00:57:26,030 --> 00:57:27,590
by you know the actual

1742
00:57:27,590 --> 00:57:28,300
board.

1743
00:57:30,640 --> 00:57:33,520
好的，回到我的幻灯片。
Okay, so go back to a

1744
00:57:33,520 --> 00:57:34,520
my slides.

1745
00:57:34,780 --> 00:57:36,380
嗯，那我们来看一下布局。好的，诺亚，去吧。
Um, so let's look at the

1746
00:57:37,270 --> 00:57:39,370
layout. Yeah, Noah,

1747
00:57:39,370 --> 00:57:40,160
go ahead.

1748
00:57:41,380 --> 00:57:42,760
嗯，您说这个布局是由硬件决定的，具体是指CPU本身还是CPU所在的板。
Yeah, when you say that this

1749
00:57:42,760 --> 00:57:43,810
this layout is determined by the

1750
00:57:43,810 --> 00:57:45,850
hardware, do you specifically mean

1751
00:57:45,850 --> 00:57:48,370
like the CPU itself or the

1752
00:57:48,370 --> 00:57:50,800
board on which the CPU resides.

1753
00:57:50,800 --> 00:57:52,390
应该驻留的板，对吗？因为你要驱逐出去，你知道，CPU是中间那个正方形的灰色东西，说无论RISC-V DRAM芯片处于什么位置，关闭处理器是正确的，是电路板设计师把芯片放在DRAM上，你知道，总共做很多IO设备。
The board which should be resides,

1754
00:57:52,390 --> 00:57:54,010
correct. Because you're going to deport,

1755
00:57:54,010 --> 00:57:55,480
you know, the CPU is the

1756
00:57:55,480 --> 00:57:56,770
grey thing in the middle that

1757
00:57:56,770 --> 00:57:59,470
square thing, saying whatever RISC-V

1758
00:57:59,470 --> 00:58:01,660
the dram chips are sitting off,

1759
00:58:01,660 --> 00:58:04,600
the off the processor correct, it's

1760
00:58:04,600 --> 00:58:06,070
the board designers who put the

1761
00:58:06,070 --> 00:58:08,500
chip the dram, you know, do many

1762
00:58:08,500 --> 00:58:10,160
IO devices altogether.

1763
00:58:11,600 --> 00:58:13,430
操作系统的很大一部分实际上是CPU的一部分，但IO设备至少同样重要，对吧，所以当你编写操作系统时，你既要处理CPU，也要处理IO设备，你知道，你想要通过互联网发送数据包，你知道的，你知道的，你想要通过互联网发送数据包，是这样的，你知道，但IO设备至少是同样重要的，所以当你编写操作系统时，你必须同时处理CPU和IO设备，你知道，你想要通过互联网发送数据包。
And make a large part of

1764
00:58:13,430 --> 00:58:14,720
an operating system is actually,

1765
00:58:14,720 --> 00:58:16,130
you know the cpu is one part, but the

1766
00:58:16,130 --> 00:58:17,270
IO devices are at least as

1767
00:58:17,270 --> 00:58:19,040
important, right and so when you're

1768
00:58:19,040 --> 00:58:20,720
writing an operating system you both

1769
00:58:20,720 --> 00:58:21,860
have to deal with the CPU

1770
00:58:21,860 --> 00:58:22,790
as well as you know with

1771
00:58:22,790 --> 00:58:23,690
the IO devices,

1772
00:58:23,690 --> 00:58:24,500
you know and you want to

1773
00:58:24,500 --> 00:58:25,860
send a packet over the Internet.

1774
00:58:25,930 --> 00:58:27,380
嗯，总得有人来接手。
Well, somebody has to

1775
00:58:28,800 --> 00:58:29,370
take over.

1776
00:58:29,370 --> 00:58:30,450
你知道网络驱动程序，真正做到这一点的网卡，那就是操作系统。
You know the network driver,

1777
00:58:30,450 --> 00:58:31,620
the NIC card to actually

1778
00:58:31,620 --> 00:58:31,980
do that,

1779
00:58:31,980 --> 00:58:33,160
and that's the operating system.

1780
00:58:35,450 --> 00:58:37,220
回到这张图片的右侧，这是物理地址布局，您知道，正如我在文档中显示的，底部基本上是未使用的。
So going back to the right

1781
00:58:37,220 --> 00:58:38,240
side of this picture correct,

1782
00:58:38,240 --> 00:58:40,550
which is the physical address layout,

1783
00:58:40,550 --> 00:58:42,110
you know we see basically the

1784
00:58:42,110 --> 00:58:43,790
bottom was unused as I showed

1785
00:58:43,790 --> 00:58:45,680
you on that document.

1786
00:58:45,740 --> 00:58:46,760
结果是0x100，也就是物理地址，这就是引导ROM所在的位置，所以当你打开那块板时，首先要做的就是对引导ROM运行进行编码。
It turns out that

1787
00:58:46,760 --> 00:58:48,680
0x100, that physical address,

1788
00:58:48,680 --> 00:58:49,910
that's where the boot rom

1789
00:58:49,910 --> 00:58:50,990
is, so when you turn

1790
00:58:50,990 --> 00:58:52,370
on that board,

1791
00:58:52,370 --> 00:58:53,480
the first thing that happens is

1792
00:58:53,480 --> 00:58:55,660
actually coding the boot rom runs.

1793
00:58:55,940 --> 00:58:56,780
当启动ROM完成时，它实际上会跳到这个0x000，这是操作系统的工作，确保那里有一些，你知道，一些数据。
And when the boot rom is

1794
00:58:56,780 --> 00:58:58,490
done it actually will jump to

1795
00:58:58,490 --> 00:59:00,950
this 0x000 and it's

1796
00:59:00,950 --> 00:59:02,240
a job of the operating system make

1797
00:59:02,240 --> 00:59:03,400
sure that there's some,

1798
00:59:03,760 --> 00:59:04,900
you know, some data there.

1799
00:59:05,460 --> 00:59:06,240
然后还有一堆其他的设备将会讨论到中断控制器，我们将在下周讨论这个问题。
And then there's a bunch of

1800
00:59:06,240 --> 00:59:08,280
other devices that will talk about

1801
00:59:08,280 --> 00:59:09,100
goes to

1802
00:59:09,610 --> 00:59:11,440
interrupt controller,

1803
00:59:11,440 --> 00:59:12,430
we'll talk about it

1804
00:59:12,430 --> 00:59:13,300
next week.

1805
00:59:13,540 --> 00:59:16,210
嗯，有一个客户端，我们将在下周讨论中断故事的另一个部分，所以有多个设备可以生成中断，需要计划将这些中断路由到适当的请求级别，这都是由那些中断控制器实现的。
Um, there's a client, another part

1806
00:59:16,210 --> 00:59:18,250
of the interrupt story that we'll

1807
00:59:18,250 --> 00:59:19,480
talk about next week,

1808
00:59:19,480 --> 00:59:21,490
so there's multiple devices can generate

1809
00:59:21,490 --> 00:59:22,930
interrupts there needs to be planned

1810
00:59:22,930 --> 00:59:24,850
to route those interrupts to the

1811
00:59:24,850 --> 00:59:26,860
to the appropriate request level and

1812
00:59:26,860 --> 00:59:28,960
it's all implemented by those

1813
00:59:28,960 --> 00:59:30,140
interrupt controllers.

1814
00:59:30,510 --> 00:59:32,160
嗯，让我说完，你知道这个，这张幻灯片之前。
Um, and let me finish for

1815
00:59:32,160 --> 00:59:33,210
a second you know this,

1816
00:59:33,210 --> 00:59:34,660
this slide before.

1817
00:59:34,780 --> 00:59:35,920
回答问题，然后有一个UART是设备，这实际上是设备实际上UART设备实际上与控制台和显示器交互，然后是虚拟的，这是磁盘。
Answering question,

1818
00:59:35,920 --> 00:59:38,500
then there's a uart

1819
00:59:38,500 --> 00:59:39,880
that was the device,

1820
00:59:39,880 --> 00:59:41,590
that was actually the thing

1821
00:59:41,590 --> 00:59:42,500
that actually,

1822
00:59:42,630 --> 00:59:44,640
the device actually UART device actually

1823
00:59:44,640 --> 00:59:46,140
interacts with the console and the

1824
00:59:46,140 --> 00:59:48,300
display and then there's the virtual

1825
00:59:48,300 --> 00:59:49,320
there's the disk.

1826
00:59:49,510 --> 00:59:51,790
这就是设备，有一个设备属于它，它实际上是与磁盘交互的。
And that's the device,

1827
00:59:51,790 --> 00:59:53,080
there's a device belong,

1828
00:59:53,080 --> 00:59:54,130
it's that actually interacts with

1829
00:59:54,130 --> 00:59:54,800
the disk.

1830
00:59:54,870 --> 00:59:56,490
所以当你把位置写到地址时，比方说。
And so when you write through

1831
00:59:56,490 --> 00:59:58,680
location to address, let's say.

1832
00:59:58,790 --> 01:00:01,610
0x200，则该物理地址对应于CLINT，因此您想要执行存储指令、加载指令以及对实现CLINT的芯片的读取和写入。
0x200 then

1833
01:00:01,610 --> 01:00:03,170
that physical address corresponds to the

1834
01:00:03,170 --> 01:00:04,430
CLINT and so do you want

1835
01:00:04,430 --> 01:00:05,450
to do store instruction,

1836
01:00:05,450 --> 01:00:06,380
load instruction,

1837
01:00:06,380 --> 01:00:09,530
your reading and writing to the

1838
01:00:09,530 --> 01:00:12,480
chip that implements the CLINT.

1839
01:00:13,190 --> 01:00:14,480
我们稍后会看到这到底意味着什么，但基本上您可以认为这是直接与设备交互，而不是读或写物理内存。
We'll see later what that exactly

1840
01:00:14,480 --> 01:00:15,890
means but basically you can think

1841
01:00:15,890 --> 01:00:17,600
about this as interacting directly with

1842
01:00:17,600 --> 01:00:18,860
the device and not reading or

1843
01:00:18,860 --> 01:00:20,020
writing physical memory.

1844
01:00:21,780 --> 01:00:22,900
是的，我有个问题。
Yeah there's a question.

1845
01:00:24,230 --> 01:00:25,760
嗯，所以我只是想确认0x800以下的地址并不存在于DRAM中。
Um, so just trying to make

1846
01:00:25,760 --> 01:00:29,450
sure the addresses below

1847
01:00:29,450 --> 01:00:31,580
0x800, they don't really exist

1848
01:00:31,580 --> 01:00:33,480
in dram.

1849
01:00:33,660 --> 01:00:35,220
如果当我们提到这些地址时，我们会直接转到其他硬件。
If when we mention those addresses

1850
01:00:35,220 --> 01:00:36,480
we directly go to the other

1851
01:00:36,480 --> 01:00:37,200
hardwares.

1852
01:00:37,200 --> 01:00:38,070
是的，是的，所以如果你回到这张照片。
Yeah yeah,

1853
01:00:38,070 --> 01:00:39,210
so if you go back to

1854
01:00:39,210 --> 01:00:40,280
this picture.

1855
01:00:40,330 --> 01:00:42,010
任何大于0x10的，都是正确的。
Anything of above

1856
01:00:42,010 --> 01:00:43,160
0x10, correct.

1857
01:00:45,330 --> 01:00:46,840
这就是这些DRAM薯片。
That's these dram chips.

1858
01:00:48,020 --> 01:00:49,670
你知道我不会画画，我不能指给你看克林特，但我一般都听人说，嗯，以太网。
And you know I can't

1859
01:00:49,670 --> 01:00:50,780
draw, I can't point you

1860
01:00:50,780 --> 01:00:51,590
to the CLINT,

1861
01:00:51,590 --> 01:00:53,680
but like generally hears that,

1862
01:00:53,770 --> 01:00:55,020
um, ethernet.

1863
01:00:55,980 --> 01:00:57,480
这是一个特定的物理地址，我们可以写入加载存储指令，称为内存映射IO，我们可以加载和存储指令，我们可以编程以太网控制器。
And so that's a particular physical

1864
01:00:57,480 --> 01:00:58,830
address and we can write you

1865
01:00:58,830 --> 01:01:00,570
know load store instructions is called

1866
01:01:00,570 --> 01:01:01,830
memory mapped IO,

1867
01:01:01,830 --> 01:01:03,450
we can load and store instructions,

1868
01:01:03,450 --> 01:01:05,520
we can program ethernet controller.

1869
01:01:09,340 --> 01:01:10,840
我还有一个问题，为什么上面的这一大块写着没有使用。
I also have a question,

1870
01:01:10,840 --> 01:01:13,480
why was this big chunk at

1871
01:01:13,480 --> 01:01:15,300
the top says unused.

1872
01:01:15,480 --> 01:01:18,630
为什么不用呢？好的，记住，嗯，不是每台机器都有，所以有2的56次方，字节的物理地址空间，但是你没有，你知道，如果你不想的话，把那么多内存插到电路板上。
Why is it not used. OK,

1873
01:01:18,630 --> 01:01:19,470
so remember,

1874
01:01:19,470 --> 01:01:21,930
um, not every machine not

1875
01:01:21,930 --> 01:01:23,550
every so there's two to

1876
01:01:23,550 --> 01:01:24,880
the power 56,

1877
01:01:25,190 --> 01:01:27,770
bytes physical address space,

1878
01:01:27,770 --> 01:01:29,300
but you don't have those,

1879
01:01:29,300 --> 01:01:30,830
you know, plug in that much memory

1880
01:01:30,830 --> 01:01:31,550
into the board,

1881
01:01:31,550 --> 01:01:32,560
if you don't want to.

1882
01:01:32,940 --> 01:01:34,170
因此，它的一些部分可能是未使用的，这取决于你在电路板上有多少DRAM芯片。
And so some parts of it

1883
01:01:34,170 --> 01:01:36,150
may be unused, depending on how

1884
01:01:36,150 --> 01:01:37,710
much you're dram chips are sitting

1885
01:01:37,710 --> 01:01:38,480
on the board.

1886
01:01:42,300 --> 01:01:42,720
事实上，他们喜欢xv6，我想我们把自己限制在128兆字节。
In fact,

1887
01:01:42,720 --> 01:01:44,220
they like in xv6,

1888
01:01:44,220 --> 01:01:46,590
we I think limit ourselves to

1889
01:01:46,590 --> 01:01:48,840
128 megabyte.

1890
01:01:50,440 --> 01:01:51,380
仅此而已。
And no more.

1891
01:01:55,370 --> 01:01:58,970
那么，当加载存储指令从CPU发出时，会不会发生这样的情况：它从哪里路由到正确的IO，比如已经从CPU路由到正确的IO，就像CPU在发出指令之前说OK一样，如果它小于0x8且全是零，那么我会将其发送到正确的IO设备，否则我会像DRAM芯片一样将其发送到内存。
So when a, when a

1892
01:01:58,970 --> 01:02:01,280
load store instruction goes out of

1893
01:02:01,280 --> 01:02:02,510
the CPU,

1894
01:02:02,510 --> 01:02:04,640
does that go,

1895
01:02:04,880 --> 01:02:06,800
like where does it get

1896
01:02:06,800 --> 01:02:08,600
routed to the correct IO, like

1897
01:02:08,600 --> 01:02:10,160
already from the CPU,

1898
01:02:10,160 --> 01:02:11,870
so kind of like if the

1899
01:02:11,870 --> 01:02:13,580
CPU before it sends it out

1900
01:02:13,580 --> 01:02:14,120
it says OK,

1901
01:02:14,120 --> 01:02:15,740
if it's lower than 0x8

1902
01:02:15,740 --> 01:02:17,900
and all the zeros then

1903
01:02:17,900 --> 01:02:19,100
I'm going to send it to

1904
01:02:19,100 --> 01:02:20,330
the correct IO devices,

1905
01:02:20,330 --> 01:02:21,320
and then otherwise I'm going to

1906
01:02:21,320 --> 01:02:24,380
send it to the to the

1907
01:02:24,380 --> 01:02:26,760
memory like dram chip.

1908
01:02:27,030 --> 01:02:28,200
是的，你可以把它想象成一个安装在RISC-V内部的多路分解器，你知道挡路。
Yeah, you can think about as

1909
01:02:28,200 --> 01:02:29,760
a demultiplexer sitting on the

1910
01:02:29,760 --> 01:02:31,710
inside of the RISC-V, you

1911
01:02:31,710 --> 01:02:33,160
know block.

1912
01:02:33,240 --> 01:02:34,110
哦，那么它就在那个挡路里面了。好的。
Oh, so it's inside of

1913
01:02:34,110 --> 01:02:35,380
that block. OK.

1914
01:02:38,150 --> 01:02:40,610
作为存储控制器并进行路由。
As a memory controller and does

1915
01:02:40,610 --> 01:02:41,480
routing.

1916
01:02:44,700 --> 01:02:46,080
因为非常重要的是要把这一切都弄清楚。
Because very important to have

1917
01:02:46,080 --> 01:02:46,830
that sort of all clear

1918
01:02:46,830 --> 01:02:47,780
in your head.

1919
01:02:51,420 --> 01:02:51,960
你还好吗，所以现在我想换到这张照片的右边。
Are you okay,

1920
01:02:51,960 --> 01:02:52,740
so now I want to

1921
01:02:52,740 --> 01:02:54,270
switch to the right side

1922
01:02:54,270 --> 01:02:55,460
of this picture.

1923
01:02:55,610 --> 01:02:57,080
这基本上就是xv6设置的虚拟地址空间，也就是xv6设置，所以当机器启动时，还没有启用页面，xv6设置了第一个页表，虚拟地址空间，这实际上是虚拟地址空间，内核使用，我们将在第二个中看到它。
And this is basically what

1924
01:02:57,080 --> 01:03:00,140
xv6 sets up, to

1925
01:03:00,140 --> 01:03:01,520
the virtual address space, that

1926
01:03:01,520 --> 01:03:02,540
xv6 setup,

1927
01:03:02,540 --> 01:03:04,910
so when the machine boot, there's

1928
01:03:04,910 --> 01:03:06,740
no page enable yet,

1929
01:03:06,740 --> 01:03:08,570
xv6 sets up

1930
01:03:08,570 --> 01:03:11,690
the first page tables, virtual

1931
01:03:11,690 --> 01:03:12,830
address space and that's actually

1932
01:03:12,830 --> 01:03:13,580
the virtual address space,

1933
01:03:13,580 --> 01:03:14,900
the kernel uses and we'll look

1934
01:03:14,900 --> 01:03:16,000
at it in the second.

1935
01:03:16,050 --> 01:03:17,070
在代码中，但是，这就是布局，你知道，因为我们想让xv6尽可能简单，所以你很容易理解。
At the code,

1936
01:03:17,070 --> 01:03:17,850
but,

1937
01:03:17,850 --> 01:03:19,440
and this is the layout

1938
01:03:19,440 --> 01:03:20,560
and it turns out,

1939
01:03:20,620 --> 01:03:21,460
you know,

1940
01:03:21,460 --> 01:03:22,750
because we want to keep

1941
01:03:22,750 --> 01:03:24,160
xv6 as simple as possible,

1942
01:03:24,160 --> 01:03:26,020
it's easy for you to understand.

1943
01:03:25,990 --> 01:03:28,120
从虚拟到物理的映射。
The mapping from virtual

1944
01:03:28,600 --> 01:03:29,680
to physical.

1945
01:03:30,780 --> 01:03:32,700
主要是身份映射。
Is mostly in identity mapping.

1946
01:03:38,110 --> 01:03:39,490
基本上，这意味着虚拟地址0x200映射到物理地址0x200，内核将完全按照这种方式设置页面表，这基本上意味着您知道此顶部下面的所有虚拟服装。
So basically what that means is

1947
01:03:39,490 --> 01:03:42,700
that the virtual address 0x200

1948
01:03:43,180 --> 01:03:45,160
maps to physical address

1949
01:03:45,160 --> 01:03:47,080
0x200, the kernel

1950
01:03:47,080 --> 01:03:48,400
will set up the page tables

1951
01:03:48,400 --> 01:03:49,870
exactly in that way,

1952
01:03:49,870 --> 01:03:51,670
and so that means basically that

1953
01:03:51,670 --> 01:03:53,200
you know all virtual dresses,

1954
01:03:53,200 --> 01:03:54,980
below this top.

1955
01:03:55,840 --> 01:03:56,740
这是物理内存的顶部，与右侧实际使用的物理地址相同。
Which is the top of

1956
01:03:56,740 --> 01:03:59,170
physical memory are identical to the

1957
01:03:59,170 --> 01:04:00,730
physical addresses that are actually being

1958
01:04:00,730 --> 01:04:02,800
used on the right side.

1959
01:04:03,150 --> 01:04:04,260
这就是为什么所有的箭头都是直的，因为这是身份映射。
And so this is why all

1960
01:04:04,260 --> 01:04:06,210
the arrows are straight, because it's

1961
01:04:06,210 --> 01:04:07,460
identity mapping.

1962
01:04:10,830 --> 01:04:13,440
对于这一点的小变化，有两件重要的事情要提。
The small changes to this,

1963
01:04:14,560 --> 01:04:16,120
there are two important things

1964
01:04:16,120 --> 01:04:16,900
to mention.

1965
01:04:17,610 --> 01:04:20,370
让我稍等片刻，试着先提一下要提到的两件重要的事情。
Let me hold on a second, while

1966
01:04:20,370 --> 01:04:21,810
try to first mention the two

1967
01:04:21,810 --> 01:04:23,300
important things to mention.

1968
01:04:23,500 --> 01:04:25,090
首先，有一些页面，一些地图在你的记忆中非常高。
First of all,

1969
01:04:25,090 --> 01:04:26,800
there's some pages,

1970
01:04:26,800 --> 01:04:28,300
some maps very high up in

1971
01:04:28,300 --> 01:04:29,080
your memory.

1972
01:04:32,550 --> 01:04:34,320
其中一些页面在内存中的位置非常高，例如内核堆栈实际所在的堆栈也映射到内存位置较高的位置。
Which some pages very high

1973
01:04:34,320 --> 01:04:35,040
up in memory,

1974
01:04:35,040 --> 01:04:38,550
for example the stack a

1975
01:04:38,550 --> 01:04:40,470
kernel stack actually sits up is

1976
01:04:40,470 --> 01:04:42,280
also map high up in memory.

1977
01:04:42,450 --> 01:04:43,590
嗯，内存较高的原因是因为我们在它下面有一个未映射的保护页。
Um, and the reason is high

1978
01:04:43,590 --> 01:04:44,880
up in memory is because we

1979
01:04:44,880 --> 01:04:46,320
have a guard page below it

1980
01:04:46,320 --> 01:04:47,500
that is not mapped.

1981
01:04:47,770 --> 01:04:49,540
因此，内核堆栈[]之一的内核堆栈下面的PTE条目没有设置有效位。
So the PTE entry below

1982
01:04:49,540 --> 01:04:51,280
the kernel stack, of one of

1983
01:04:51,280 --> 01:04:52,720
the kernel stack [], does

1984
01:04:52,720 --> 01:04:54,610
have, not have it's valid

1985
01:04:54,610 --> 01:04:55,380
bit set.

1986
01:04:55,660 --> 01:04:56,560
而且，嗯，如果你知道，内核在堆栈之外运行，会导致页面错误，这比基本上在内核拥有的其他内存上乱涂乱画要好得多。
And, um,

1987
01:04:56,560 --> 01:04:58,360
so if you know, the kernel

1988
01:04:58,360 --> 01:05:00,100
runs off its stack and will

1989
01:05:00,100 --> 01:05:01,840
result in a page fault,

1990
01:05:01,840 --> 01:05:04,060
which is better than basically scribbling

1991
01:05:04,060 --> 01:05:05,140
over some other memory that the

1992
01:05:05,140 --> 01:05:06,020
kernel has.

1993
01:05:06,080 --> 01:05:07,220
你马上就会惊慌失措，你知道有些东西堆积如山是不好的。
You get immediate panic,

1994
01:05:07,220 --> 01:05:09,020
you know that something's bad to stack.

1995
01:05:09,680 --> 01:05:11,540
当然，我们不想浪费物理内存，所以当我们这样做的时候，基本上是把堆栈放得很高，在它下面放一个保护页，一个空的保护PTE条目。
Of course, we don't want

1996
01:05:11,540 --> 01:05:13,580
to waste physical memory and so

1997
01:05:13,580 --> 01:05:15,080
when we do that by basically

1998
01:05:15,080 --> 01:05:16,940
putting the stack high,

1999
01:05:16,940 --> 01:05:18,890
in,

2000
01:05:18,890 --> 01:05:20,690
a guard page, an empty guard

2001
01:05:20,690 --> 01:05:22,280
PTE entry below it.

2002
01:05:22,520 --> 01:05:24,590
嗯，而且守卫页面实际上并不会消耗位于虚拟地址空间高处的任何物理内存记录，所以没有消耗任何内容。
Um, and the guard page

2003
01:05:24,590 --> 01:05:26,450
doesn't really consume any physical memory

2004
01:05:26,450 --> 01:05:27,560
records sitting high up in the

2005
01:05:27,560 --> 01:05:28,400
virtual address space,

2006
01:05:28,400 --> 01:05:30,620
so nothing is being consumed.

2007
01:05:31,190 --> 01:05:32,570
但这意味着他们展示了这种情况，例如，堆栈页面被映射了两次。
But that means that they're showing

2008
01:05:32,570 --> 01:05:33,560
this case, stack page,

2009
01:05:33,560 --> 01:05:35,140
for example is mapped twice.

2010
01:05:35,360 --> 01:05:36,230
它被映射到一个很高的地址，它直接由[这个]上衣下面的一件连衣裙映射。
It's mapped at a high

2011
01:05:36,230 --> 01:05:38,660
address and it's mapped directly

2012
01:05:38,660 --> 01:05:40,010
by one of the dresses

2013
01:05:40,010 --> 01:05:41,300
that below [this] top.

2014
01:05:42,590 --> 01:05:43,760
所以你可以这样做，这是所有很酷的事情的一个例子，你可以用页表来做，你可以映射一个物理地址两次，你不能映射一个物理地址，你知道它可以是一对一映射，一对多映射，多对一映射，所有这些事情都是可能的。
And so you can do, this

2015
01:05:43,760 --> 01:05:45,290
is one example of all the

2016
01:05:45,290 --> 01:05:46,970
sort of cool things, you can

2017
01:05:46,970 --> 01:05:48,230
do with page tables,

2018
01:05:48,230 --> 01:05:49,370
you can map a physical

2019
01:05:49,370 --> 01:05:50,480
address twice,

2020
01:05:50,480 --> 01:05:52,610
you cannot map a physical address,

2021
01:05:52,610 --> 01:05:53,930
you know it can be

2022
01:05:53,930 --> 01:05:55,160
one to one mapping, one to

2023
01:05:55,160 --> 01:05:56,900
many mapping, many to one mapping,

2024
01:05:56,900 --> 01:05:57,710
all that kind of stuff

2025
01:05:57,710 --> 01:05:58,560
is possible.

2026
01:05:58,930 --> 01:06:01,030
嗯，实际上它用的不是很多，但是有几个地方我们用到了这些招数。
Um, actually it doesn't really use

2027
01:06:01,030 --> 01:06:01,930
many of them, but there's a

2028
01:06:01,930 --> 01:06:03,760
couple places we use those tricks.

2029
01:06:03,880 --> 01:06:05,110
保护页面中的堆栈就是一个例子，这是xv6主要用来跟踪bug的一个很酷的技巧。
And there's the stack in

2030
01:06:05,110 --> 01:06:06,070
the guard page is one

2031
01:06:06,070 --> 01:06:06,910
example, of one of the

2032
01:06:06,910 --> 01:06:09,280
cool trick then xv6 uses

2033
01:06:09,280 --> 01:06:11,020
mostly to track down bugs.

2034
01:06:12,880 --> 01:06:13,720
我想提的第二件事是权限。
The second thing I wanted to

2035
01:06:13,720 --> 01:06:14,530
mention is that,

2036
01:06:14,530 --> 01:06:15,920
the permissions.

2037
01:06:16,570 --> 01:06:18,550
因此，例如内核文本，内核文本的页面被映射为R-X，这意味着您可以读取并执行它。
So, for example the kernel text,

2038
01:06:18,550 --> 01:06:19,720
the pages for the kernel text

2039
01:06:19,720 --> 01:06:20,320
are mapped

2040
01:06:20,320 --> 01:06:22,420
R-X, meaning you can

2041
01:06:22,420 --> 01:06:23,780
read it and execute it.

2042
01:06:23,780 --> 01:06:24,890
但是您不能写入内核文本，同样，这基本上是空的。
But you cannot write to

2043
01:06:24,890 --> 01:06:26,150
kernel text and again this

2044
01:06:26,150 --> 01:06:27,500
is basically devoid.

2045
01:06:27,530 --> 01:06:28,730
框，所以，我们提前捕捉到它们，内核数据当然需要能够被写入，所以它映射了读写，但是你不能执行内核数据页之外的指令。
Box so that, we catch

2046
01:06:28,730 --> 01:06:30,650
them early, kernel data of course

2047
01:06:30,650 --> 01:06:31,610
needs to be able to be

2048
01:06:31,610 --> 01:06:33,110
written to, and so it has

2049
01:06:33,110 --> 01:06:34,250
mapped read write,

2050
01:06:34,250 --> 01:06:36,060
but you cannot execute

2051
01:06:36,130 --> 01:06:38,230
out of kernel data

2052
01:06:38,230 --> 01:06:39,880
pages instructions.

2053
01:06:40,680 --> 01:06:41,910
嗯，所以执行位没有设置。
Um, so the execute bit is

2054
01:06:41,910 --> 01:06:42,680
not set.

2055
01:06:45,960 --> 01:06:47,040
这有意义吗。
Does that make sense.

2056
01:06:48,010 --> 01:06:49,510
嗯，我跳过了一两个问题，如果这些问题还没有回答，请你问一下。
Um I skipped one or

2057
01:06:49,510 --> 01:06:50,020
two questions,

2058
01:06:50,020 --> 01:06:51,280
so if these questions are still

2059
01:06:51,280 --> 01:06:52,060
not answered,

2060
01:06:52,060 --> 01:06:53,080
please ask them.

2061
01:06:55,790 --> 01:06:56,600
我们在聊天中有一个问题。
We have a question in the

2062
01:06:56,600 --> 01:06:58,460
chat.

2063
01:06:58,460 --> 01:07:00,320
我们是否有多个内核堆栈用于不同的进程，就像我们有n个堆栈用于n个进程一样。
Do we have multiple kernel stacks

2064
01:07:00,320 --> 01:07:02,240
for different processes like we have

2065
01:07:02,240 --> 01:07:04,560
n stacks for n processes.

2066
01:07:04,640 --> 01:07:05,960
回答是肯定的。
And answers yes.

2067
01:07:06,850 --> 01:07:08,860
因此，每个进程、每个用户进程都有一个对应的内核堆栈。
So every process every user process

2068
01:07:08,860 --> 01:07:10,820
has a corresponding kernel stack.

2069
01:07:13,130 --> 01:07:14,030
稍后我会看到这一点。
I will see that in a

2070
01:07:14,030 --> 01:07:14,960
little bit later.

2071
01:07:19,220 --> 01:07:20,660
好的，那么让我，嗯，萨米尔，继续。
Okay, so let me,

2072
01:07:20,660 --> 01:07:21,800
um, Samir,

2073
01:07:21,800 --> 01:07:22,500
go ahead.

2074
01:07:23,350 --> 01:07:26,080
嗯，那么另一个应用程序的虚拟内存映射到物理内存中未使用的空间或。
Um, so what's the virtual memory

2075
01:07:26,080 --> 01:07:28,420
of another application

2076
01:07:28,720 --> 01:07:30,130
map to somewhere in the physical

2077
01:07:30,130 --> 01:07:32,440
memory in the unused space or.

2078
01:07:32,440 --> 01:07:34,540
是的，一个非常好的观点，所以有一堆物理内存，对，这是空闲内存。
Yes, a very good point,

2079
01:07:34,540 --> 01:07:36,730
so there's a bunch of

2080
01:07:36,730 --> 01:07:37,240
physical memory,

2081
01:07:37,240 --> 01:07:38,800
correct, here's free memory.

2082
01:07:39,340 --> 01:07:41,230
嗯，现在这里有空闲的内存，对，我们实际上使用这些空闲内存来存储页表的页面，用户进程，以及你知道的用户级进程的文本和数据。
Um, now that's free memory

2083
01:07:41,230 --> 01:07:43,780
here to, right, and

2084
01:07:43,780 --> 01:07:45,310
we use that actually use

2085
01:07:45,310 --> 01:07:46,720
that free memory to basically

2086
01:07:46,720 --> 01:07:48,790
store pages of page tables,

2087
01:07:48,790 --> 01:07:51,190
user processes as well as you

2088
01:07:51,190 --> 01:07:53,440
know the text and data of

2089
01:07:53,440 --> 01:07:54,720
user level processes.

2090
01:07:55,790 --> 01:07:56,480
如果我们在很多用户进程上，在某个时候我们会用完空闲内存，然后基本上fork或exec会返回一个错误。
And if we are on

2091
01:07:56,480 --> 01:07:56,900
many many,

2092
01:07:56,900 --> 01:07:58,490
many user processes at some point

2093
01:07:58,490 --> 01:07:59,690
we'll run out of free memory,

2094
01:07:59,690 --> 01:08:01,520
and then basically fork or exec

2095
01:08:01,520 --> 01:08:03,480
will return an error.

2096
01:08:04,900 --> 01:08:05,770
但这意味着进程的虚拟空间比内核的虚拟空间小得多。
But that means that the

2097
01:08:05,770 --> 01:08:08,620
virtual space for processes are

2098
01:08:08,620 --> 01:08:09,850
much smaller than the virtual

2099
01:08:09,850 --> 01:08:12,240
space for the kernel.

2100
01:08:12,500 --> 01:08:14,000
嗯，虚拟空间的大小原则上是一样的，但是人口会少一些。
Well, the virtual spaces as

2101
01:08:14,000 --> 01:08:15,950
the same as the same

2102
01:08:15,950 --> 01:08:17,150
size in principle,

2103
01:08:17,150 --> 01:08:19,340
but it will be less populated.

2104
01:08:22,520 --> 01:08:24,200
然后让我们来看一些代码，我认为所有这些东西都变得更清楚了。
Then let me let's look at

2105
01:08:24,200 --> 01:08:24,560
some code,

2106
01:08:24,560 --> 01:08:25,280
and I think that all this

2107
01:08:25,280 --> 01:08:26,720
stuff becomes a bit more clear.

2108
01:08:27,690 --> 01:08:29,280
我只想要一些小东西，嗯，考虑到很多类似的东西，每个进程都有很大一部分内存映射到相同的位置，这是通过将其合并到一个映射或不映射的位置进行优化的。
I just want small thing,

2109
01:08:29,280 --> 01:08:32,760
um, is so given that

2110
01:08:32,760 --> 01:08:34,020
a lot of the like,

2111
01:08:34,020 --> 01:08:35,610
each process has a big part

2112
01:08:35,610 --> 01:08:37,080
of the memory map to the

2113
01:08:37,080 --> 01:08:39,810
same location is that optimized by

2114
01:08:39,810 --> 01:08:42,720
like consolidating that into one place

2115
01:08:42,720 --> 01:08:44,180
that mapping or no.

2116
01:08:44,280 --> 01:08:46,050
嗯，这很好，xv6不能做到这一点，就像页表实验中的挑战练习之一就是实际实现它一样。
Um, it's good,

2117
01:08:46,050 --> 01:08:47,370
xv6 does not do that,

2118
01:08:47,370 --> 01:08:48,990
like one of the challenge

2119
01:08:48,990 --> 01:08:51,210
exercises in the page table lab

2120
01:08:51,210 --> 01:08:52,640
is to actually implement that.

2121
01:08:54,510 --> 01:08:56,130
我明白了。真正的操作系统会做到这一点。
I see. The real operating system

2122
01:08:56,130 --> 01:08:56,920
would do that.

2123
01:08:58,710 --> 01:09:00,240
嗯。合乎道理。
Yeah. Makes sense.

2124
01:09:00,240 --> 01:09:01,220
问得好。
Very good question.

2125
01:09:02,380 --> 01:09:03,220
我想一旦你有了页表，你就会明白什么事情都是可能的。
I think you get a sense

2126
01:09:03,220 --> 01:09:04,240
of what all kinds of things

2127
01:09:04,240 --> 01:09:04,780
are possible,

2128
01:09:04,780 --> 01:09:06,120
once you have page tables.

2129
01:09:08,790 --> 01:09:09,780
好的，嗯，让我们做些平常的事情，一遍又一遍地引导xv6，你知道QEMU基本上是用来实现电路板的。
Okay, um,

2130
01:09:09,780 --> 01:09:11,490
so let's do the usual thing,

2131
01:09:12,640 --> 01:09:14,830
boot xv6 again

2132
01:09:14,830 --> 01:09:15,370
and again,

2133
01:09:15,370 --> 01:09:16,900
you know QEMU uses basically implementing

2134
01:09:16,900 --> 01:09:17,780
the board.

2135
01:09:18,170 --> 01:09:21,460
嗯，你知道让我们。哎呀，-gdb，上一次我们看了路由是如何正确发生的，然后我们到了main，然后基本上是内核，当其中一个函数调用kvminit时，它实际上为内核设置了地址空间。
Um, and you know let's. Oops,

2136
01:09:26,750 --> 01:09:28,260
-gdb,

2137
01:09:29,930 --> 01:09:31,880
last time we looked at

2138
01:09:31,880 --> 01:09:33,710
how the routing happens correct

2139
01:09:33,710 --> 01:09:34,310
and then we got to

2140
01:09:34,310 --> 01:09:35,510
main and then basically one

2141
01:09:35,510 --> 01:09:37,200
of the things that,

2142
01:09:37,270 --> 01:09:38,650
um, the kernel,

2143
01:09:38,650 --> 01:09:41,380
when one of the functions called

2144
01:09:41,380 --> 01:09:42,670
kvminit and that actually

2145
01:09:42,670 --> 01:09:44,110
sets up the address space for

2146
01:09:44,110 --> 01:09:44,820
the kernel.

2147
01:09:45,100 --> 01:09:46,330
我们在图片中看到，在上一张幻灯片中，您知道它看起来是什么样子，现在我们开始，CC编码它是如何实际设置的。
And so we saw in the

2148
01:09:46,330 --> 01:09:47,740
picture where in the previous slide,

2149
01:09:47,740 --> 01:09:49,330
what that you know looks like

2150
01:09:49,330 --> 01:09:50,200
and here we go,

2151
01:09:50,200 --> 01:09:51,730
CC code how it actually is

2152
01:09:51,730 --> 01:09:52,580
being set up.

2153
01:09:58,380 --> 01:10:01,500
还有为什么，等等，有些事不对劲。
And why, hold on, something's

2154
01:10:01,500 --> 01:10:02,340
not going.

2155
01:10:02,510 --> 01:10:03,980
如我所愿。
As I wanted to.

2156
01:10:04,380 --> 01:10:07,100
我找对目录了吗？
Am I the right directories.

2157
01:10:11,140 --> 01:10:12,130
等一下，我正在想办法解决我的问题。
Hold on a second here

2158
01:10:12,130 --> 01:10:13,180
while I'm trying to sort

2159
01:10:13,180 --> 01:10:14,720
out my problems.

2160
01:10:16,590 --> 01:10:17,940
那很好。
That is good.

2161
01:10:21,390 --> 01:10:23,070
我的意思是正确的目录，是的，我们想从主要发送一个中断，只是为了确保。
I mean the right directory,

2162
01:10:23,070 --> 01:10:24,630
yeah,

2163
01:10:28,050 --> 01:10:28,710
We want to send a

2164
01:10:28,710 --> 01:10:29,670
break from the main just

2165
01:10:29,670 --> 01:10:30,960
to make sure.

2166
01:10:31,050 --> 01:10:32,970
很好，然后是kvminit的中断点。
Good, and then a break point

2167
01:10:32,970 --> 01:10:35,940
at kvminit.

2168
01:10:36,340 --> 01:10:37,300
实际上我现在可以直接跳到它，下一个consoleinit printfinit，你知道，我们之前已经看到了，物理内存分配器。
Actually I can just step to

2169
01:10:37,300 --> 01:10:40,540
it now, next consoleinit

2170
01:10:40,540 --> 01:10:41,050
printfinit,

2171
01:10:41,050 --> 01:10:42,760
you know, we saw it before,

2172
01:10:43,250 --> 01:10:45,320
physical memory allocator.

2173
01:10:51,100 --> 01:10:52,720
你知道吗，发生了一些我意想不到的事情。
You know, something happens that I

2174
01:10:52,720 --> 01:10:55,200
not expecting.

2175
01:10:57,590 --> 01:10:59,840
这是怎么回事。
What is going on.

2176
01:11:02,590 --> 01:11:03,970
我们要在讲课前播放这段视频。这里，这就是实际打印的情况，嗯，好的。
We're gonna run this right before

2177
01:11:03,970 --> 01:11:04,900
lecture. Here,

2178
01:11:04,900 --> 01:11:06,700
that's what's going on actually printing,

2179
01:11:06,700 --> 01:11:08,220
um, okay.

2180
01:11:10,330 --> 01:11:11,620
嗯，有意思，好吧，再来一次，看看我能不能多看几眼。
Um, interesting,

2181
01:11:11,620 --> 01:11:12,460
okay one more time,

2182
01:11:12,460 --> 01:11:14,890
see if I can get lucky

2183
01:11:14,890 --> 01:11:15,840
more looks.

2184
01:11:19,270 --> 01:11:20,920
非常好。
Very good.

2185
01:11:28,910 --> 01:11:32,140
继续，希望它能到达那里，稍等片刻。很好，我们在kvminit，所以基本上我们现在是这个函数，在emacs缓冲区的右边，你可以看到它。
Continue, hopefully it will get there,

2186
01:11:33,010 --> 01:11:34,210
wait a little bit. Okay great

2187
01:11:34,210 --> 01:11:35,860
we're at the kvminit,

2188
01:11:35,860 --> 01:11:37,390
so basically we're now this function

2189
01:11:37,390 --> 01:11:39,220
here, on the right side in

2190
01:11:39,220 --> 01:11:40,000
the emacs buffer,

2191
01:11:40,000 --> 01:11:40,900
you can see it.

2192
01:11:41,280 --> 01:11:43,640
而且，我想我稍微修改了一下函数，我希望我是这样做的。
And,

2193
01:11:44,220 --> 01:11:46,380
I think I've modified function

2194
01:11:46,380 --> 01:11:48,820
slightly I hope I did.

2195
01:11:52,570 --> 01:11:53,980
嗯，我想我做到了，我们拭目以待，我们所知道的将步入函数。
Um, I think I did, we'll

2196
01:11:53,980 --> 01:11:56,890
see, and what we knew

2197
01:11:56,890 --> 01:11:58,660
is going to walk step into

2198
01:11:58,660 --> 01:11:59,560
the function.

2199
01:12:00,080 --> 01:12:02,270
给我布局拆分，这样更容易看到。
Give me layout split it's

2200
01:12:02,270 --> 01:12:03,280
easier to see.

2201
01:12:03,640 --> 01:12:04,630
这是您可以看到的第一件事，当前的这一部分实际上为顶级页面目录分配了一个物理页面。
And this is the first thing

2202
01:12:04,630 --> 01:12:05,530
that you can see, this section

2203
01:12:05,530 --> 01:12:06,640
of the current actually allocates a

2204
01:12:06,640 --> 01:12:08,470
physical page, for the top level

2205
01:12:08,470 --> 01:12:09,440
page directory.

2206
01:12:10,090 --> 01:12:12,250
然后将其置零，使得所有PTE条目都为零。
And then zeroes it

2207
01:12:12,250 --> 01:12:13,690
out so that all the PTE

2208
01:12:13,690 --> 01:12:14,760
entries are zero.

2209
01:12:15,360 --> 01:12:17,490
然后基本上开始在每个设备、IO设备中逐个映射。
And then basically starts mapping in

2210
01:12:17,490 --> 01:12:20,490
every device, IO device one

2211
01:12:20,490 --> 01:12:21,280
by one.

2212
01:12:21,620 --> 01:12:22,130
例如，UART0，它基本上开始将映射映射到内核地址空间，所以我们可以看到一个名为memlayout.h的文件，它基本上是将我从文档中向您展示的第31页转换成我们正在使用的一系列常量。
And so,

2213
01:12:22,130 --> 01:12:23,990
for example, the UART0, it

2214
01:12:23,990 --> 01:12:25,820
basically starts mapping maps that into

2215
01:12:25,820 --> 01:12:28,550
the kernel address space and so

2216
01:12:28,550 --> 01:12:29,960
we can look at a file

2217
01:12:29,960 --> 01:12:32,840
called memlayout.h, is basically translate

2218
01:12:32,840 --> 01:12:34,580
page 31 that I showed

2219
01:12:34,580 --> 01:12:35,930
you from the document into a

2220
01:12:35,930 --> 01:12:37,620
bunch of constants that we're using.

2221
01:12:38,010 --> 01:12:38,280
举个例子，这里说的是0x1000的地址。
And so,

2222
01:12:38,280 --> 01:12:39,510
for example here it says what

2223
01:12:39,510 --> 01:12:42,700
the address of 0x1000 is.

2224
01:12:44,100 --> 01:12:46,800
嗯，你有什么想法。
Um, do you ideas.

2225
01:12:47,100 --> 01:12:47,940
所以，你知道，我们基本上可以通过调用这个函数kvmmap将其映射到地址空间，我稍后会看到这个函数。
And so,

2226
01:12:47,940 --> 01:12:50,040
you know, we can basically

2227
01:12:50,040 --> 01:12:52,110
map it into the address space

2228
01:12:52,110 --> 01:12:53,760
by calling this function

2229
01:12:53,760 --> 01:12:54,660
kvmmap which I will look in

2230
01:12:54,660 --> 01:12:55,520
a second.

2231
01:12:56,040 --> 01:12:57,000
然后，在页表实验的第一个练习中，要求您实现一个名为vm_print的函数。
And then,

2232
01:12:57,000 --> 01:13:00,390
in the first exercise of

2233
01:13:00,390 --> 01:13:01,260
the page table lab,

2234
01:13:01,260 --> 01:13:02,700
you are asked to implement a

2235
01:13:02,700 --> 01:13:04,040
function called vm_print.

2236
01:13:04,300 --> 01:13:06,400
嗯，我也实现了它，我将跳过它，我们将看到，页表，内核页表，它是在对kvmmap的一次调用之后设置的，所以我要这样做。
Um, and I implemented it too,

2237
01:13:06,400 --> 01:13:07,900
and I'm going to step over

2238
01:13:07,900 --> 01:13:09,520
it and we'll see basically,

2239
01:13:09,720 --> 01:13:11,600
page tables,

2240
01:13:11,960 --> 01:13:13,790
kernel page table as it

2241
01:13:13,790 --> 01:13:15,350
is set up after that one

2242
01:13:15,350 --> 01:13:16,700
call to the kvmmap,

2243
01:13:16,700 --> 01:13:17,980
so I'm going to do that.

2244
01:13:18,250 --> 01:13:18,970
我们要打印一些东西。
And we're going to print

2245
01:13:18,970 --> 01:13:19,780
out something.

2246
01:13:20,240 --> 01:13:20,750
所以我们要看一下这里的输出，这是页表，它是顶层的物理地址，页面目录，所以实际上位于SATP中，或将位于SATP中的东西。
And so we're going to

2247
01:13:20,750 --> 01:13:21,380
look a little bit of

2248
01:13:21,380 --> 01:13:22,160
the output here,

2249
01:13:22,160 --> 01:13:23,420
so here's the page table that

2250
01:13:23,420 --> 01:13:24,140
is the

2251
01:13:24,790 --> 01:13:28,030
physical address of the top level,

2252
01:13:28,030 --> 01:13:30,190
page directory,

2253
01:13:30,190 --> 01:13:31,240
so the thing that actually sits

2254
01:13:31,240 --> 01:13:32,020
in satp,

2255
01:13:32,020 --> 01:13:33,980
or will sit in satp.

2256
01:13:34,600 --> 01:13:36,850
然后我们有了顶级页面的条目0，其中实际上有一个PTE条目。
And then we have

2257
01:13:36,850 --> 01:13:38,140
entry zero of the top

2258
01:13:38,140 --> 01:13:40,030
level page really has one

2259
01:13:40,030 --> 01:13:41,880
PTE entry in it.

2260
01:13:42,480 --> 01:13:45,300
嗯，那就是包含中级页表目录的物理地址。
Um, and that is the contains

2261
01:13:45,300 --> 01:13:46,710
the physical address for the middle

2262
01:13:46,710 --> 01:13:48,200
level page table directory.

2263
01:13:48,600 --> 01:13:50,190
中间页面级目录具有一个条目，即128。
The middle page level directory has

2264
01:13:50,190 --> 01:13:52,780
one entry namely 128.

2265
01:13:52,900 --> 01:13:53,950
它指向页表目录的底部，并且底部的页表目录具有用于物理页面的条目。
And that points to the bottom

2266
01:13:53,950 --> 01:13:55,360
of page table directory and the

2267
01:13:55,360 --> 01:13:56,800
bottom page table directory has the

2268
01:13:56,800 --> 01:13:59,020
entry then for the physical page.

2269
01:13:59,390 --> 01:14:00,110
您可以看到，实际上，您知道该底层的物理地址是0x1000，对应于uart0。
And you can see,

2270
01:14:00,110 --> 01:14:02,090
indeed that the physical address,

2271
01:14:02,090 --> 01:14:03,530
you know for that bottom level

2272
01:14:03,530 --> 01:14:05,570
is 0x1000

2273
01:14:05,570 --> 01:14:07,680
corresponding to uart0.

2274
01:14:08,350 --> 01:14:11,080
对，基本上虚拟地址转换成物理地址11100。
Right, so basically virtual address

2275
01:14:11,470 --> 01:14:13,300
1000 translates

2276
01:14:13,300 --> 01:14:15,820
to physical address 11100.

2277
01:14:16,570 --> 01:14:18,700
软弱的不确定的复核，这确实是完全合法的。
A weak unsure double-check,

2278
01:14:18,700 --> 01:14:20,920
this is indeed all legit.

2279
01:14:21,010 --> 01:14:22,690
根据嗯的不同，我们取那个地址0x100L，我们将移位12。
Vary by um,

2280
01:14:22,690 --> 01:14:28,330
and let's take that address 0x100L

2281
01:14:28,330 --> 01:14:29,710
and we're going

2282
01:14:29,710 --> 01:14:30,960
to shift 12.

2283
01:14:31,700 --> 01:14:34,960
嗯，这应该是，你知道的，那就是最高级别的27位。
Um, and that should be,

2284
01:14:35,160 --> 01:14:36,240
you know, that gives the top

2285
01:14:36,240 --> 01:14:38,600
level 27 bits.

2286
01:14:39,070 --> 01:14:40,660
我们移了9，所以我取0x100，A 1000101，我们可以9移，打印出来。
We shifted 9,

2287
01:14:40,660 --> 01:14:43,360
so I'm gonna take 0x100,

2288
01:14:43,970 --> 01:14:48,440
A 1000101 and we can

2289
01:14:48,440 --> 01:14:49,540
shift at 9,

2290
01:14:49,840 --> 01:14:50,920
print that.

2291
01:14:53,000 --> 01:14:54,620
那就是0x000，实际上把0x0打印成一个十进制数字，它将是128，好的。
And that is 0x000,

2292
01:14:54,620 --> 01:14:56,360
and actually print 0x0

2293
01:14:56,360 --> 01:14:58,460
as a decimal decimal number, it's

2294
01:14:58,460 --> 01:14:59,840
going to be 128, OK.

2295
01:15:02,330 --> 01:15:03,590
所以我们看到，实际上，你知道，这一切都是有意义的。
So we see actually sort of

2296
01:15:03,590 --> 01:15:04,640
you know it all sort of

2297
01:15:04,640 --> 01:15:05,540
makes sense.

2298
01:15:05,920 --> 01:15:07,390
我们还看到我在这里打印出了标志，您知道最下面的级别是读取、写入和有效，因为Valid是1。
We also see I printed out

2299
01:15:07,390 --> 01:15:08,650
the flags here,

2300
01:15:08,650 --> 01:15:11,230
and you know the bottom

2301
01:15:11,230 --> 01:15:12,280
level has read,

2302
01:15:12,280 --> 01:15:16,180
write and valid, because valid

2303
01:15:16,180 --> 01:15:16,920
is one.

2304
01:15:18,480 --> 01:15:19,740
有任何关于这个的问题吗。
Any questions about this.

2305
01:15:24,760 --> 01:15:26,960
好的，那么嗯。
Okay, so um.

2306
01:15:27,290 --> 01:15:30,080
内核基本上在继续，你知道，用这种方式设置整个地址空间。
The kernel basically proceeds, you know

2307
01:15:30,080 --> 01:15:32,000
doing setting up the whole address

2308
01:15:32,000 --> 01:15:33,160
space in this way.

2309
01:15:33,810 --> 01:15:35,580
因此，我们为虚拟IO调用了kvmmap，为客户端调用了kvmmap，用于单击。
And, so we've called

2310
01:15:35,580 --> 01:15:37,740
kvmmap for virtual IO, for the

2311
01:15:37,740 --> 01:15:39,100
CLINT, for the click.

2312
01:15:39,350 --> 01:15:42,320
映射内核文本，映射内核内存或内核数据，然后映射我们将在下周讨论的蹦床页面。
Maps the kernel text, maps

2313
01:15:42,320 --> 01:15:44,480
the kernel memory or kernel data,

2314
01:15:44,480 --> 01:15:45,830
and then the trampoline page that

2315
01:15:45,830 --> 01:15:47,040
we'll talk about next week.

2316
01:15:47,460 --> 01:15:48,780
嗯，所以实际上我们可以单步走一步，然后看看最终的页面目录是什么样子。
Um, and so in fact we

2317
01:15:48,780 --> 01:15:50,280
can single step through this and

2318
01:15:50,280 --> 01:15:52,290
then see what the final page

2319
01:15:52,290 --> 01:15:53,780
directory looks like.

2320
01:15:55,610 --> 01:15:58,760
嗯，那么下一个。
Um, so next next next next.

2321
01:15:59,330 --> 01:16:01,190
基本上，您知道设置蹦床，所以现在我们要打印完整的页表目录。
Basically, you know set the trampoline,

2322
01:16:01,190 --> 01:16:02,030
so now we're going to print

2323
01:16:02,030 --> 01:16:03,860
the complete page table directory.

2324
01:16:04,160 --> 01:16:07,430
嗯，你知道我们基本上看到很多PTE实际上正在设置中。
Um, you know we see basically

2325
01:16:07,430 --> 01:16:09,080
lot of PTE is actually

2326
01:16:09,080 --> 01:16:11,680
being setup.

2327
01:16:11,840 --> 01:16:13,310
嗯，我不会详细讨论，嗯，但是您知道，基本上是填写目录来实际创建虚拟映射，就像我们在上一张幻灯片中看到的那样。
Um, and I'm not going to

2328
01:16:13,310 --> 01:16:14,870
talk about in any detail,

2329
01:16:14,870 --> 01:16:16,610
um, but you know basically fills

2330
01:16:16,610 --> 01:16:17,480
out the

2331
01:16:17,920 --> 01:16:20,170
directory to actually create

2332
01:16:20,170 --> 01:16:21,730
virtual mapping that we

2333
01:16:21,730 --> 01:16:23,480
basically saw on the previous slide.

2334
01:16:24,840 --> 01:16:26,010
当我预料到我下一步要做的事情实际上要有趣得多的时候。
When I expect what I

2335
01:16:26,010 --> 01:16:26,910
wanna do next is actually

2336
01:16:26,910 --> 01:16:28,160
much more interesting.

2337
01:16:29,730 --> 01:16:31,080
是的我会的。
Yeah I'm gonna.

2338
01:16:32,270 --> 01:16:33,350
是的，我想去这里，实际上，我猜我可能已经这样做了，当时21岁，不，我21岁还可以，所以单步走不了。
Yeah I wanna go here,

2339
01:16:33,350 --> 01:16:34,730
actually, I guess maybe I already

2340
01:16:34,730 --> 01:16:37,010
did this, were 21,

2341
01:16:37,010 --> 01:16:38,450
no, I'm 21 okay so single

2342
01:16:38,450 --> 01:16:39,400
step not.

2343
01:16:40,560 --> 01:16:41,430
嗯，好吧，那太糟糕了，我已经过去了，但基本上是这样。
Um, OK that's too bad, I

2344
01:16:41,430 --> 01:16:43,800
got past it but basically.

2345
01:16:44,340 --> 01:16:46,800
嗯，让我再说一遍。
Um, let me let me

2346
01:16:46,800 --> 01:16:47,840
restart this.

2347
01:16:53,210 --> 01:16:57,320
我想要在kvminithart的转折点。
I wanna break point at kvminithart.

2348
01:17:00,580 --> 01:17:01,880
继续，我们现在在kvminithart，您在这里看到，基本上我们正在写入SATP寄存器，所以基本上内核将启用页表或硬MMU，嗯，基本上开始使用我们刚刚设置的页表。
And continue,

2349
01:17:03,650 --> 01:17:06,020
are now here at kvminithart,

2350
01:17:06,020 --> 01:17:07,430
and you see here,

2351
01:17:07,430 --> 01:17:09,470
basically that we're writing the

2352
01:17:09,470 --> 01:17:10,310
satp register,

2353
01:17:10,310 --> 01:17:11,450
so basically the kernel is going

2354
01:17:11,450 --> 01:17:14,600
to enable page table or

2355
01:17:14,600 --> 01:17:15,740
the hard, MMU,

2356
01:17:15,740 --> 01:17:16,970
um, to basically start using

2357
01:17:16,970 --> 01:17:17,870
the page table that we

2358
01:17:17,870 --> 01:17:18,740
just set up.

2359
01:17:19,470 --> 01:17:22,860
还有一个有趣的问题。
And one interesting question.

2360
01:17:23,350 --> 01:17:24,730
好的，所以他们确实又把版面拆分了，嗯，所以。
Okay, so they do have layout

2361
01:17:24,730 --> 01:17:25,990
split again,

2362
01:17:25,990 --> 01:17:27,340
um so.

2363
01:17:27,760 --> 01:17:29,350
这里的某个地方是正确的，这是一条指令，在执行这条指令后，发生了一些非常戏剧性的事情。
Somewhere here correct is going to

2364
01:17:29,350 --> 01:17:30,860
be,

2365
01:17:31,320 --> 01:17:32,940
here's the instruction,

2366
01:17:32,940 --> 01:17:34,860
in,

2367
01:17:36,070 --> 01:17:39,700
once, something really dramatic happens

2368
01:17:39,700 --> 01:17:41,480
after executing this instruction.

2369
01:17:42,270 --> 01:17:44,850
嗯，比方说，是的，我完全可以看到相同的指令，但是在这个范围内，一旦执行了这条指令，下一个要翻译的地址会发生什么。
Um, let's say yeah I can

2370
01:17:44,850 --> 01:17:46,500
see the same instruction exactly but

2371
01:17:46,500 --> 01:17:48,960
there's this this extent,

2372
01:17:48,960 --> 01:17:50,820
once this instruction is executed what

2373
01:17:50,820 --> 01:17:52,200
will happen with the next address

2374
01:17:52,200 --> 01:17:53,420
that's being translated.

2375
01:17:58,310 --> 01:17:59,570
嗯，在我们执行这条指令之前执行这条指令的时候，还没有启用页表，所以没有发生转换。
Well, at the point that

2376
01:17:59,570 --> 01:18:01,550
we execute this instruction before

2377
01:18:01,550 --> 01:18:02,810
executing this instruction,

2378
01:18:02,810 --> 01:18:04,550
there's no page tables enabled yet

2379
01:18:04,550 --> 01:18:06,200
so no translation happens.

2380
01:18:06,410 --> 01:18:07,820
但是下一次然后程序计数器被更新4。
But the next and then the

2381
01:18:07,820 --> 01:18:10,040
program counter is updated by 4.

2382
01:18:10,240 --> 01:18:11,380
然后执行下一条指令，并且将使用虚拟页、页表存储器来转换程序计数器。
And then the next instruction is

2383
01:18:11,380 --> 01:18:13,030
executed and the program counter will

2384
01:18:13,030 --> 01:18:15,060
be translated using the virtual page,

2385
01:18:15,290 --> 01:18:16,400
page table memory.

2386
01:18:17,140 --> 01:18:18,640
所以这是，你知道，思考这个问题的方式，这是一个戏剧性的时刻。
And so this is, you

2387
01:18:18,640 --> 01:18:19,750
know, the ways to think about this,

2388
01:18:19,750 --> 01:18:21,500
this is a dramatic moment.

2389
01:18:21,630 --> 01:18:24,450
因为基本上整个地址转换都开始启用，每个地址都不需要，可能潜在会有所不同。
Because basically the whole address translation,

2390
01:18:24,450 --> 01:18:25,500
they started to enable and

2391
01:18:25,500 --> 01:18:26,910
every address needs no maybe

2392
01:18:26,910 --> 01:18:28,480
potentially something different.

2393
01:18:29,660 --> 01:18:31,370
对，因为在我们运行您的物理地址之前，然后是页表，还没有安装，无论映射中有什么，现在都有了虚拟地址的新含义。
Right, because before we're running your

2394
01:18:31,370 --> 01:18:32,240
physical addresses,

2395
01:18:32,240 --> 01:18:33,050
then the page table,

2396
01:18:33,050 --> 01:18:34,310
haven't install, and whatever is in

2397
01:18:34,310 --> 01:18:34,760
the mapping,

2398
01:18:34,760 --> 01:18:36,290
now there's now the new meaning

2399
01:18:36,290 --> 01:18:37,500
of a virtual address.

2400
01:18:38,680 --> 01:18:40,090
嗯，这就是它的工作原理，你知道，这个实际工作的事实是值得注意的，因为就像下一条指令一样，下一个值是一个虚拟地址，而不是一个物理地址。
Um, and here's how this works

2401
01:18:40,090 --> 01:18:41,230
out, you know, the fact that

2402
01:18:41,230 --> 01:18:42,820
this actually works out is remarkable

2403
01:18:42,820 --> 01:18:44,590
because like the next instruction,

2404
01:18:44,590 --> 01:18:46,180
the next value is a virtual

2405
01:18:46,180 --> 01:18:47,780
address and not a physical address.

2406
01:18:49,000 --> 01:18:50,020
下一条指令将是这个，不管是0x1110。
The next instruction is going to

2407
01:18:50,020 --> 01:18:50,290
be this,

2408
01:18:50,290 --> 01:18:52,300
whatever 0x1110.

2409
01:18:52,750 --> 01:18:54,240
为什么这会成功呢。
And why does this work out.

2410
01:18:55,960 --> 01:18:57,130
原因是因为内核已经设置好了，我们可以标识页面映射。因此，在我们启用虚拟分页硬件之后，我们实际上知道这个翻译器将再次转换为相同的物理地址，因此我们实际上将结束执行写入指令，因为这实际上正是虚拟硬件编程所针对的指令和内存位置。
And the reason works out is

2411
01:18:57,130 --> 01:18:58,270
because the kernel is setup,

2412
01:18:58,270 --> 01:19:00,460
we can identity page mapping. So,

2413
01:19:00,730 --> 01:19:02,590
after we enable the virtual

2414
01:19:02,590 --> 01:19:03,760
paging hardware,

2415
01:19:03,760 --> 01:19:05,740
we actually know this translator will

2416
01:19:05,740 --> 01:19:07,540
translate again to the same physical

2417
01:19:07,540 --> 01:19:09,970
address and so indeed we'll actually

2418
01:19:09,970 --> 01:19:11,180
end up, you know,

2419
01:19:11,210 --> 01:19:13,430
executing the writing instruction, because that's

2420
01:19:13,430 --> 01:19:14,750
actually exactly the instruction,

2421
01:19:14,750 --> 01:19:16,490
the memory location that the virtual

2422
01:19:16,490 --> 01:19:17,700
hardware is programmed for.

2423
01:19:19,110 --> 01:19:20,400
那么这有意义吗。
So does this make sense.

2424
01:19:22,920 --> 01:19:25,560
同样，虚拟内存编程困难的一个原因是，一旦执行了这些SATP指令之一，您就在SATP寄存器中加载了页表，您的世界就完全不同了。
Again, one reason why programming virtual

2425
01:19:25,560 --> 01:19:27,570
memory is difficult is because once

2426
01:19:27,570 --> 01:19:29,100
you execute one of these satp

2427
01:19:29,100 --> 01:19:31,410
instructions you load a page table

2428
01:19:31,410 --> 01:19:35,040
in the satp register, your world

2429
01:19:35,040 --> 01:19:36,320
completely changes.

2430
01:19:36,680 --> 01:19:38,720
现在，每个地址都会使用您设置的页表进行转换。
And every address is now translated

2431
01:19:38,720 --> 01:19:39,800
with the page table, that you

2432
01:19:39,800 --> 01:19:40,520
set up.

2433
01:19:41,540 --> 01:19:42,590
那么，如果页表设置不正确会发生什么呢？
And so what happens if the

2434
01:19:42,590 --> 01:19:44,320
page table setup incorrectly.

2435
01:19:44,840 --> 01:19:47,280
你会怎么做，可能会发生什么。
What would you, what might happen.

2436
01:19:53,650 --> 01:19:54,960
任何想在聊天中回答或回答的人，可以等待。
Anybody who wants to

2437
01:19:55,290 --> 01:19:56,790
say that answered or answered in

2438
01:19:56,790 --> 01:19:57,270
the chat,

2439
01:19:57,270 --> 01:19:58,120
you can wait.

2440
01:20:00,510 --> 01:20:02,520
您可以覆盖内核数据。
You could override kernel data.

2441
01:20:02,980 --> 01:20:04,240
是的，你可以覆盖内核数据，还有其他可能发生的事情，是的，页面错误，你基本上是这样做的，映射可能是不正确的，基本上地址完全可以转换，所以内核可以，你知道，头件不会这样做，而使用内核时会停顿和死机。
Yeah you could overwrite kernel data

2442
01:20:04,240 --> 01:20:05,020
what else could happen,

2443
01:20:05,020 --> 01:20:05,950
yeah page fault,

2444
01:20:05,950 --> 01:20:07,660
you basically do,

2445
01:20:07,720 --> 01:20:10,030
the mapping may be incorrect and

2446
01:20:10,030 --> 01:20:11,680
basically the address can be translated

2447
01:20:11,680 --> 01:20:12,010
at all,

2448
01:20:12,010 --> 01:20:13,150
and so the kernel can, you

2449
01:20:13,150 --> 01:20:14,650
know, the headware won't do it

2450
01:20:14,650 --> 01:20:15,820
and use the kernel there stops

2451
01:20:15,820 --> 01:20:16,620
and panics.

2452
01:20:18,760 --> 01:20:20,020
这有意义吗？所以如果您的页表中有错误。
Does that make sense,

2453
01:20:20,020 --> 01:20:21,700
so if you get a bug

2454
01:20:21,700 --> 01:20:23,020
in your page tables.

2455
01:20:23,530 --> 01:20:24,490
你知道你会看到这些都是错误或崩溃。
You know you're going to see

2456
01:20:24,490 --> 01:20:28,020
these are errors or crashes.

2457
01:20:28,720 --> 01:20:29,080
所以，下一个实验室考试的原因之一，就是今晚分发或发布的那个页桌实验室，会很难，因为那些细菌会出现。
And so,

2458
01:20:29,080 --> 01:20:30,370
one reason that exam the

2459
01:20:30,370 --> 01:20:31,300
next lab,

2460
01:20:31,300 --> 01:20:32,470
that page table lab, that

2461
01:20:32,470 --> 01:20:34,570
will hand out or release tonight,

2462
01:20:34,570 --> 01:20:35,980
is going to be hard,

2463
01:20:35,980 --> 01:20:37,150
because those kind of bugs will

2464
01:20:37,150 --> 01:20:37,840
show up.

2465
01:20:38,200 --> 01:20:39,820
如果你不够小心，因为你还没有完全内化某些方面。
If you're not careful enough for

2466
01:20:39,820 --> 01:20:42,420
you haven't fully internalized some aspect yet.

2467
01:20:42,520 --> 01:20:43,780
你基本上会遇到内核崩溃，当你需要花一点时间、精力和侦察工作来基本上追踪发生这种情况的原因时，你会遇到一段艰难的时期。
And you're basically going to

2468
01:20:43,780 --> 01:20:45,640
get kernel crash and

2469
01:20:45,640 --> 01:20:46,390
you're gonna have a hard

2470
01:20:46,390 --> 01:20:47,500
time when you will take

2471
01:20:47,500 --> 01:20:48,220
a little bit of time

2472
01:20:48,220 --> 01:20:50,050
and energy and detective work

2473
01:20:50,050 --> 01:20:51,460
to basically track down why

2474
01:20:51,460 --> 01:20:52,280
that happened.

2475
01:20:53,370 --> 01:20:55,860
这只是，这只是虚拟内存编程的一部分。
And that's just the, that's just

2476
01:20:55,860 --> 01:20:57,860
part of like programming virtual memory.

2477
01:20:58,330 --> 01:20:59,170
因为它是如此强大的原始体，你知道，如果你弄错了，你会产生强大的后果。
Because it's such a

2478
01:20:59,170 --> 01:21:00,730
powerful primitive, you know, you

2479
01:21:00,730 --> 01:21:01,480
get it wrong,

2480
01:21:01,480 --> 01:21:02,780
you're gonna have

2481
01:21:03,470 --> 01:21:04,840
powerful consequences.

2482
01:21:08,090 --> 01:21:09,320
然而，另一方面是非常有趣的，所以我不想以负面的笔记结束，嗯，但所有这些都会让你真正理解什么是真正的虚拟内存，以及它能做什么。
Yet the other hand is great

2483
01:21:09,320 --> 01:21:09,890
amount of fun,

2484
01:21:09,890 --> 01:21:10,760
so I don't want to end

2485
01:21:10,760 --> 01:21:12,560
on a negative note,

2486
01:21:12,560 --> 01:21:14,630
um, but all that will give

2487
01:21:14,630 --> 01:21:16,370
you a real understanding of actually

2488
01:21:16,370 --> 01:21:18,020
what really virtual memory is and

2489
01:21:18,020 --> 01:21:18,840
what it can do.

2490
01:21:20,180 --> 01:21:21,140
好的，我想我的时间不多了，所以我就到此为止了，这样人们就有时间去下一节课或下一次活动了，但是如果你们还有什么问题，请稍等，然后问他们。
Okay I think I'm running

2491
01:21:21,140 --> 01:21:21,800
out of time so I'm

2492
01:21:21,800 --> 01:21:22,820
gonna stop here,

2493
01:21:22,820 --> 01:21:24,110
so people have time to

2494
01:21:24,110 --> 01:21:25,040
go to the next class or

2495
01:21:25,040 --> 01:21:26,060
next activity,

2496
01:21:26,060 --> 01:21:27,620
but if you have any questions

2497
01:21:27,620 --> 01:21:29,870
left, please hang on and

2498
01:21:29,870 --> 01:21:30,700
ask them.

2499
01:21:31,440 --> 01:21:32,550
我们周一见。
And, um,

2500
01:21:32,550 --> 01:21:33,960
we'll see you on monday.

2501
01:21:35,360 --> 01:21:37,340
祝你顺利完成SysCall实验室。
And good luck with finishing the

2502
01:21:37,340 --> 01:21:38,320
syscall lab.

2503
01:21:40,920 --> 01:21:42,630
嗯，嗨，我有一个关于Walk的问题，它说，在代码中，它返回的就像PTE上的第一个表。
Um, hi I have a question

2504
01:21:42,630 --> 01:21:44,190
about walk,

2505
01:21:44,190 --> 01:21:46,560
so it says and in

2506
01:21:46,560 --> 01:21:47,040
the code,

2507
01:21:47,040 --> 01:21:48,360
it returns the

2508
01:21:48,840 --> 01:21:52,360
like the first tables on PTE.

2509
01:21:52,480 --> 01:21:53,980
是的，是的，嗯，但是它是如何工作的，那么就像其他函数一样，当它们期望实际的PTE时，但是像物理地址一样。
Yeah right,

2510
01:21:53,980 --> 01:21:56,020
um, but but how does

2511
01:21:56,020 --> 01:21:56,410
it work,

2512
01:21:56,410 --> 01:21:57,910
then like the other functions when

2513
01:21:57,910 --> 01:21:59,140
they expect

2514
01:21:59,450 --> 01:22:01,310
the actual PTE,

2515
01:22:01,310 --> 01:22:03,560
but like the physical address.

2516
01:22:05,690 --> 01:22:09,590
基本上这会返回页表中的PTE条目，内核可以读取或写入页表条目。
Yeah basically this returns the PTE

2517
01:22:09,590 --> 01:22:11,240
entry in the page table,

2518
01:22:12,100 --> 01:22:13,330
and the kernel can read or

2519
01:22:13,330 --> 01:22:14,680
write page table entries.

2520
01:22:15,070 --> 01:22:17,050
嗯，现在你可以把值放到PTE里了。
Um, and so now you can

2521
01:22:17,050 --> 01:22:19,200
stick values into the PTE.

2522
01:22:21,180 --> 01:22:22,560
所以也许我可以画一幅有帮助的画。
And so maybe I can draw

2523
01:22:22,560 --> 01:22:24,640
a picture that is helpful.

2524
01:22:26,330 --> 01:22:27,160
让我们看看。
Let's see.

2525
01:22:35,790 --> 01:22:36,780
所以也许我们有一个页面目录。
So maybe we have a

2526
01:22:36,780 --> 01:22:37,980
page directory.

2527
01:22:45,000 --> 01:22:48,150
而且，你知道，这个行进代码，所以页面目录中有512 PTE。
And, you know, this walk code,

2528
01:22:48,150 --> 01:22:49,350
so the page directory has

2529
01:22:49,350 --> 01:22:52,900
512 PTE in it.

2530
01:22:56,960 --> 01:22:57,800
在接近零的位置，这里是511，基本上函数的作用是返回一个指向其中一个PTE的指针。
Near zero,

2531
01:22:57,800 --> 01:23:00,560
here's 511 and basically what the

2532
01:23:00,560 --> 01:23:03,300
function does it returns a pointer

2533
01:23:03,410 --> 01:23:05,340
to one of these PTEs.

2534
01:23:06,040 --> 01:23:06,640
这只是一个虚拟地址，它指向那个特定的PTE。
And so that's just a

2535
01:23:06,640 --> 01:23:07,600
virtual address,

2536
01:23:07,600 --> 01:23:08,620
and it points to that

2537
01:23:08,620 --> 01:23:09,740
particular PTE.

2538
01:23:10,220 --> 01:23:11,990
现在内核可以，你知道的，通过向它写入值，来操纵那个PTE。
And now the kernel can, you

2539
01:23:11,990 --> 01:23:14,330
know manipulate that PTE, by whatever

2540
01:23:14,330 --> 01:23:15,680
writing values to it.

2541
01:23:16,010 --> 01:23:17,420
就像某个物理地址。
Like some physical address.

2542
01:23:17,820 --> 01:23:20,250
也许有一些权限，或者进入它的前十位。
Maybe with some permissions or

2543
01:23:20,250 --> 01:23:21,180
into it for the top

2544
01:23:21,180 --> 01:23:22,320
bottom ten bits.

2545
01:23:23,730 --> 01:23:25,320
然后基本上更新页表目录，然后在稍后将数据加载到SATP中时更新页表目录。
And then basically updates the page

2546
01:23:25,320 --> 01:23:26,130
table directory,

2547
01:23:26,130 --> 01:23:27,420
and then later on when you

2548
01:23:27,420 --> 01:23:29,540
load data into satp.

2549
01:23:29,810 --> 01:23:31,640
现在，这一影响将会生效。
Now that affect that change will

2550
01:23:31,640 --> 01:23:32,660
go into effect.

2551
01:23:35,350 --> 01:23:36,480
这有意义吗。
Does that make sense.

2552
01:23:37,180 --> 01:23:38,440
是的，这是有道理的，我想我只是搞不懂，为什么它要一直转到第三个页表，然后只返回第一个PTE。不，退货实际上是最底层的。
Yeah that makes sense, I guess

2553
01:23:38,440 --> 01:23:39,880
I just confused like why does

2554
01:23:39,880 --> 01:23:41,560
it do the work of going

2555
01:23:41,560 --> 01:23:43,380
all the way to the third

2556
01:23:43,550 --> 01:23:46,010
page table and then only return

2557
01:23:46,010 --> 01:23:46,840
the first

2558
01:23:46,900 --> 01:23:49,450
PTE. No, return is actually the

2559
01:23:49,450 --> 01:23:50,440
bottom one.

2560
01:23:51,710 --> 01:23:53,510
实际上，让我小心点，如果它通过了n级，从2级开始，然后到1级，再到0级。
Actually, let me be careful,

2561
01:23:55,340 --> 01:23:56,840
If, you know, it goes through

2562
01:23:56,840 --> 01:23:58,730
the n levels, started level 2

2563
01:23:58,730 --> 01:23:59,750
and then go to level 1,

2564
01:23:59,750 --> 01:24:01,120
again a level 0.

2565
01:24:01,730 --> 01:24:04,500
如果分配位设置和级别不存在，将创建中间页表目录。
If the alloc bit set

2566
01:24:05,150 --> 01:24:06,920
and level doesn't exist,

2567
01:24:06,920 --> 01:24:08,930
it will create the intermediate page

2568
01:24:08,930 --> 01:24:09,980
table directory.

2569
01:24:10,580 --> 01:24:12,050
把它清零，然后继续找。
And zero it out and then

2570
01:24:12,050 --> 01:24:13,260
keep going to look.

2571
01:24:13,780 --> 01:24:16,300
所以，你总是落在最底层。
So, you always end up

2572
01:24:16,300 --> 01:24:17,840
on the bottom PTE.

2573
01:24:18,580 --> 01:24:20,800
如果没有设置分配，你会在第一个PTE停止，这是没有价值的。
If alloc not set, you stop

2574
01:24:20,800 --> 01:24:22,750
at the first PTE, that doesn't

2575
01:24:22,750 --> 01:24:23,680
have value.

2576
01:24:25,550 --> 01:24:26,510
好的，这就说得通了，这是最后一张了，实际上会有好的，好的，谢谢。
Okay, that makes sense,

2577
01:24:26,510 --> 01:24:27,800
this is the last one,

2578
01:24:27,800 --> 01:24:29,840
the actual on gonna have

2579
01:24:29,840 --> 01:24:31,880
okay okay,

2580
01:24:31,880 --> 01:24:32,880
thank you.

2581
01:24:36,850 --> 01:24:38,080
还有其他问题吗。
Any other questions.

2582
01:24:40,820 --> 01:24:42,740
嗯，所以我有一个问题，在我们将内核的两个虚拟地址映射到物理地址之前，基本上一切都是有意义的。
Um, so I have a question,

2583
01:24:42,740 --> 01:24:45,590
basically everything made sense until

2584
01:24:45,590 --> 01:24:47,630
we mapped the virtual addresses

2585
01:24:47,630 --> 01:24:49,160
two of the kernel to

2586
01:24:49,160 --> 01:24:51,980
the physical addresses.

2587
01:24:53,800 --> 01:24:55,720
所以我的理解是，每个进程都会有自己的页表，这也是一个三级表，它将其虚拟地址包装到物理地址，但然后我们将内核虚拟地址映射到物理地址，我认为我们没有考虑到实际的三个地址。
So my understanding is that

2588
01:24:55,720 --> 01:24:57,100
each process will have its

2589
01:24:57,100 --> 01:24:57,880
own page table,

2590
01:24:57,880 --> 01:24:59,380
which is also a three level

2591
01:24:59,380 --> 01:25:02,050
three which wraps its virtual addresses

2592
01:25:02,050 --> 01:25:03,730
to physical addresses,

2593
01:25:03,730 --> 01:25:06,190
but then we map the kernel

2594
01:25:06,190 --> 01:25:08,230
virtual addresses to physical addresses, I

2595
01:25:08,230 --> 01:25:09,760
don't think we accounted for the

2596
01:25:09,760 --> 01:25:11,220
actual three of them.

2597
01:25:11,810 --> 01:25:14,150
内核的虚拟地址或其他进程将拥有其虚拟地址的位置。
Virtual addresses of the kernel

2598
01:25:14,150 --> 01:25:17,330
or where other processes will have

2599
01:25:17,330 --> 01:25:19,320
their virtual addresses.

2600
01:25:19,380 --> 01:25:23,760
我很抱歉虚拟地址就像可视的桌树和。
And I'm sorry virtual addresses like

2601
01:25:23,760 --> 01:25:25,940
the visual table trees and.

2602
01:25:26,200 --> 01:25:27,880
页表树在物理内存中指向的任何内容。
Whatever the page table tree points

2603
01:25:27,880 --> 01:25:30,430
at in the physical memory.

2604
01:25:30,430 --> 01:25:32,260
是的，所以你又回来了，这是关于内核的幻灯片，基于地址的虚拟内核地址空间，所以当内核分配proc时。
Yeah, so yeah so so you're

2605
01:25:32,260 --> 01:25:34,630
back, this is slide with kernel,

2606
01:25:35,870 --> 01:25:37,610
address based virtual kernel address

2607
01:25:37,610 --> 01:25:39,890
space and so when the kernel

2608
01:25:39,890 --> 01:25:41,060
allocates proc.

2609
01:25:41,370 --> 01:25:43,830
UM和该特定进程的页表，在这里它们将被分配到内存之外，内存还没有被使用。
Um and page tables for

2610
01:25:43,830 --> 01:25:44,970
that particular process they're going

2611
01:25:44,970 --> 01:25:46,160
to be allocated

2612
01:25:46,260 --> 01:25:48,630
out of memory here, memory is

2613
01:25:48,630 --> 01:25:49,940
not being used yet.

2614
01:25:50,870 --> 01:25:52,430
内核将进行编程，我们可能会为页表分配几个页面，脱离通常的问题过程，并填充PTE。
And the kernel is going to

2615
01:25:52,430 --> 01:25:55,370
program, we'll probably allocate a

2616
01:25:55,370 --> 01:25:57,170
couple pages for the page table,

2617
01:25:57,170 --> 01:25:58,790
off the usual problem process and

2618
01:25:58,790 --> 01:26:00,340
will fill in the PTEs.

2619
01:26:01,460 --> 01:26:03,110
在内核运行该进程的某个时刻。
And at some point when the

2620
01:26:03,110 --> 01:26:04,800
kernel runs that process.

2621
01:26:04,900 --> 01:26:08,260
它将加载为该页表或基本上页表分配的那些页的路由、物理地址，然后将其构建到SATP寄存器中。
It will load the route,

2622
01:26:08,260 --> 01:26:10,540
physical address for those pages that

2623
01:26:10,540 --> 01:26:12,070
is allocated for that page table

2624
01:26:12,070 --> 01:26:14,200
or basically page table then built

2625
01:26:14,200 --> 01:26:15,880
into the satp register.

2626
01:26:16,650 --> 01:26:19,560
在这一点上，处理器将使用内核为该特定进程构造的虚拟地址库运行。
And at that point the processor

2627
01:26:19,560 --> 01:26:21,720
will run with the virtual address

2628
01:26:21,720 --> 01:26:23,460
base that the kernel constructed for

2629
01:26:23,460 --> 01:26:24,680
that particular process.

2630
01:26:27,140 --> 01:26:29,060
嗯，所以内核为进程释放了一些内存，然后在理论上虚拟空间和内核一样大，但在现实中，虚拟空间对进程来说和内核一样大。这真的不是一个虚拟地址空间布局的图片，他们通常的水平过程，再一次，它从零到MAXVA。
Um, so the kernel gave up

2631
01:26:29,060 --> 01:26:30,890
some of its memory,

2632
01:26:30,890 --> 01:26:32,270
for processes,

2633
01:26:32,270 --> 01:26:34,100
and then but then the virtual

2634
01:26:34,100 --> 01:26:36,470
space in theory is as big

2635
01:26:36,470 --> 01:26:38,640
for the process as

2636
01:26:38,740 --> 01:26:39,910
the kernel,

2637
01:26:39,910 --> 01:26:42,550
but in reality. It's really not

2638
01:26:42,550 --> 01:26:45,250
have a picture with the layout

2639
01:26:45,250 --> 01:26:46,330
of a virtual address space with

2640
01:26:46,330 --> 01:26:48,040
their usual level process and again

2641
01:26:48,040 --> 01:26:49,960
it goes from zero to MAXVA.

2642
01:26:51,930 --> 01:26:53,520
就像内核地址空间一样，它基本上有自己的一组页表来映射这些趋势，因为转换，内核设置。
In the same way as the

2643
01:26:54,240 --> 01:26:56,100
kernel address space does and it's

2644
01:26:56,100 --> 01:26:57,120
basically has his own set of

2645
01:26:57,120 --> 01:26:58,770
page tables to map those trends

2646
01:26:58,770 --> 01:27:00,140
due to translation,

2647
01:27:00,500 --> 01:27:01,720
the kernel setup.

2648
01:27:03,200 --> 01:27:05,030
但是我们不能实际使用所有的MAXVA虚拟。
But we can't actually use all

2649
01:27:05,030 --> 01:27:06,530
of the MAXVA virtual.

2650
01:27:06,530 --> 01:27:07,580
不，我们不能。
No, we cannot.

2651
01:27:07,640 --> 01:27:09,720
如果我们的内存用完了。
If we run out of memory.

2652
01:27:11,620 --> 01:27:12,850
因此，许多进程比所有虚拟地址空间都要小得多，这是正确的。
So many of the processes are

2653
01:27:12,850 --> 01:27:14,800
much much smaller, correct, than

2654
01:27:14,950 --> 01:27:16,800
all of the virtual address space.

2655
01:27:19,740 --> 01:27:21,360
我看到了思考。
I see thinking.

2656
01:27:23,250 --> 01:27:24,480
我有一个简短的问题，嗯，你能不能回到行走规则上来，好的，好的，当然可以。
I've got a quick question,

2657
01:27:26,020 --> 01:27:27,100
Um, could you go back to

2658
01:27:27,100 --> 01:27:28,450
the walk code,

2659
01:27:28,450 --> 01:27:30,040
yeah yeah absolutely.

2660
01:27:31,490 --> 01:27:32,660
嗯，这是我最喜欢的功能之一。
Um, it's one of my

2661
01:27:32,660 --> 01:27:34,680
favorite functions.

2662
01:27:35,290 --> 01:27:38,560
嗯，所以我猜，有一件事我很困惑，那就是在你写到SATP寄存器之后，内核甚至可以直接访问物理地址吗，所以在它正在转换的代码中，你看起来就像是将Pay设置为物理地址，但是如果设置了SATP，那不会被解释为虚拟地址吗？
Um, so I guess, one

2663
01:27:38,560 --> 01:27:40,570
thing I'm confused about is after

2664
01:27:40,570 --> 01:27:41,800
you write to the satp

2665
01:27:41,800 --> 01:27:44,800
register can the kernel even access

2666
01:27:44,800 --> 01:27:46,750
physical addresses directly,

2667
01:27:46,750 --> 01:27:47,620
so it looks like in the

2668
01:27:47,620 --> 01:27:49,210
code that it's converting you know

2669
01:27:49,210 --> 01:27:50,260
like pay was being set to

2670
01:27:50,260 --> 01:27:51,250
a physical address,

2671
01:27:51,250 --> 01:27:53,500
but if satp is set,

2672
01:27:53,860 --> 01:27:55,960
won't that be interpreted as

2673
01:27:55,960 --> 01:27:57,580
a virtual address.

2674
01:27:57,580 --> 01:27:59,680
是的，嗯，所以，嗯，好的，让我们来看看哈提尼特。
Yeah, um,

2675
01:27:59,680 --> 01:28:01,900
so, um okay so let's look

2676
01:28:01,900 --> 01:28:06,600
at hartinit.

2677
01:28:12,380 --> 01:28:14,720
KVM，所以内置在内核地址空间中。
kvm, so built in kernel address space.

2678
01:28:15,070 --> 01:28:17,860
内核页表(最初是虚拟物理地址)被转换为物理地址，并且该地址实际上被写入到SATP寄存器中。
The kernel page table,

2679
01:28:19,860 --> 01:28:23,280
Initially, the virtual physical, address

2680
01:28:23,280 --> 01:28:26,190
is translated to a physical

2681
01:28:26,190 --> 01:28:27,840
address and that's actually written into

2682
01:28:27,840 --> 01:28:29,300
the satp register.

2683
01:28:30,380 --> 01:28:32,360
嗯，在这一点上，您知道我们使用的是我们在此之前构建的地址空间，这个kvminit。
Um, and at that point you

2684
01:28:32,360 --> 01:28:34,220
know we're running with the address

2685
01:28:34,220 --> 01:28:36,740
space that we've constructed right before

2686
01:28:36,740 --> 01:28:38,280
here, this kvminit.

2687
01:28:39,980 --> 01:28:41,480
给了我一张地图，基本上就是给每一个地址打电话，每一页都在这个范围内。
And gave me a map is

2688
01:28:41,480 --> 01:28:44,700
basically nothing else than calling

2689
01:28:45,040 --> 01:28:47,710
walk for every address where

2690
01:28:47,710 --> 01:28:49,500
every page and at the range.

2691
01:28:50,340 --> 01:28:51,750
那么你的问题是什么，嗯，我想，如果你在说了SATP之后，步行仍然是一样的工作方式。是啊，怎么了。
And so what was your question,

2692
01:28:53,660 --> 01:28:54,380
Um I guess,

2693
01:28:54,380 --> 01:28:56,810
it's does walks still work

2694
01:28:56,810 --> 01:28:57,680
the same way if you

2695
01:28:57,680 --> 01:28:59,480
call it after satp

2696
01:28:59,480 --> 01:29:02,160
is said. Yeah why.

2697
01:29:04,590 --> 01:29:06,900
为什么我们要找出它不能解决在身份映射中设置的内核的原因。
Why we work out the reason

2698
01:29:06,900 --> 01:29:13,260
it won't work out the kernel set up in identity mapping.

2699
01:29:13,720 --> 01:29:15,100
好的，对，对。
Ok, right, right.

2700
01:29:15,100 --> 01:29:16,390
非常重要，非常好的问题，很多事情碰巧都解决了，因为实际上身份映射已经设置好了。
Very important,

2701
01:29:16,390 --> 01:29:18,580
very good question,

2702
01:29:18,580 --> 01:29:19,930
a lot of things just happened

2703
01:29:19,930 --> 01:29:21,130
to work out because actually the

2704
01:29:21,130 --> 01:29:23,040
identity mapping is set up.

2705
01:29:24,670 --> 01:29:27,310
我明白了，我想这是有道理的，我有一个简短的问题。
I see I think that

2706
01:29:27,310 --> 01:29:27,610
makes sense,

2707
01:29:31,360 --> 01:29:33,220
I have a quick question.

2708
01:29:33,220 --> 01:29:36,340
其中为所有进程存储SATP寄存器。
Where the satp register stored

2709
01:29:36,340 --> 01:29:38,000
for all of the processes.

2710
01:29:38,480 --> 01:29:41,560
每个核心只有一个SATP。
There only one satp per core.

2711
01:29:42,040 --> 01:29:44,260
嗯，但是在每一个程序结构中。
Um, but in every proc structure.

2712
01:29:46,300 --> 01:29:48,280
如果你看一下pro.h。
If you look at proc.h.

2713
01:29:48,970 --> 01:29:49,840
嗯，有一个指向页表的指针，你是你是。好的，有道理。
Um, there is,

2714
01:29:52,740 --> 01:29:55,680
a pointer to the page table,

2715
01:29:55,680 --> 01:29:57,620
you're you're. okay, makes sense.

2716
01:29:58,460 --> 01:30:01,370
另外，关于三个页表就像三个表，可以完成完整的地址，甚至可以帮助您获得一些东西的完整地址，我想这比拥有一个巨大的页表有什么更好的地方，我并没有真正完全理解什么。这是一个很好的问题，原因是在自由级别的页面表中，您可以将许多条目留空。
And also with regards to the

2717
01:30:01,370 --> 01:30:04,280
three page tables are like the

2718
01:30:04,280 --> 01:30:06,680
three tables that can complete the

2719
01:30:06,680 --> 01:30:08,060
full address and help you get

2720
01:30:08,060 --> 01:30:11,510
a full address for even something,

2721
01:30:11,510 --> 01:30:13,160
how does how is that better

2722
01:30:13,160 --> 01:30:15,500
I guess than than having one

2723
01:30:15,500 --> 01:30:17,120
giant page table I didn't really

2724
01:30:17,120 --> 01:30:20,090
fully understand what. A great question,

2725
01:30:20,090 --> 01:30:21,620
the reason is because in the

2726
01:30:21,620 --> 01:30:22,580
free level page table,

2727
01:30:22,580 --> 01:30:23,420
you can leave a lot of

2728
01:30:23,420 --> 01:30:24,460
entries empty.

2729
01:30:25,060 --> 01:30:26,920
因此，例如，如果您将顶层页表中的条目直接留空，则根本不必为这些条目创建中层页表或底层页表。
So, for example if you leave

2730
01:30:26,920 --> 01:30:28,600
the entry in the top level

2731
01:30:28,600 --> 01:30:30,520
page table directly empty,

2732
01:30:30,520 --> 01:30:31,960
you don't have to create middle

2733
01:30:31,960 --> 01:30:33,910
level page tables or bottom level

2734
01:30:33,910 --> 01:30:35,120
page tables at all,

2735
01:30:35,150 --> 01:30:36,200
for those entries.

2736
01:30:37,070 --> 01:30:38,870
这意味着整个虚拟地址空间的一大块(条带)根本不需要任何映射。
Like this means like a big

2737
01:30:38,870 --> 01:30:40,940
[swath] of the whole virtual address

2738
01:30:40,940 --> 01:30:42,230
space doesn't have to have any

2739
01:30:42,230 --> 01:30:43,400
mapping at all.

2740
01:30:44,890 --> 01:30:45,730
好的，好的，你那里没有桌子，它根本不存在。
Okay, okay,

2741
01:30:45,730 --> 01:30:47,080
you don't have the table there,

2742
01:30:47,080 --> 01:30:48,240
it just doesn't exist.

2743
01:30:48,840 --> 01:30:49,230
我明白了，基本上这些块是按数量和类型分配的，好的，这是有道理的，是的，你基本上是从三页开始，三页，一幅。
I see,

2744
01:30:49,230 --> 01:30:52,500
basically allocating these chunks on demand

2745
01:30:52,500 --> 01:30:53,880
as volumes and types,

2746
01:30:53,880 --> 01:30:55,170
OK that makes sense,

2747
01:30:55,170 --> 01:30:56,880
yeah you're starting basically with three

2748
01:30:56,880 --> 01:30:58,410
page three pages namely,

2749
01:30:58,410 --> 01:30:59,490
one from the top level one

2750
01:30:59,490 --> 01:31:01,170
for, one intermediate one frame,

2751
01:31:01,170 --> 01:31:02,840
one bottom level.

2752
01:31:03,170 --> 01:31:03,740
然后，随着操作的进行，您将创建更多的页表目录。
And then,

2753
01:31:03,740 --> 01:31:05,090
as you go you create more

2754
01:31:05,090 --> 01:31:06,500
page table directories.

2755
01:31:06,750 --> 01:31:07,680
好的，好的，太好了，太感谢你了。
Okay, okay,

2756
01:31:09,140 --> 01:31:10,400
Cool, thank you so much.

2757
01:31:10,400 --> 01:31:11,220
不用谢。
You're welcome.

2758
01:31:12,930 --> 01:31:14,180
还有什么问题吗。
Any more questions.

2759
01:31:14,670 --> 01:31:16,020
我很抱歉我有另一个，它真的很小，但是我在vm.c的43，41行，嗯，它说，不，Mignt 43，我的错，嗯，它说物理停止减去(Uint64)etext，但不会，不会复习一下，我想我们不应该接触的记忆，我不知道这是否有意义，但是，会不会这样。
I'm sorry I have another one,

2760
01:31:16,020 --> 01:31:18,270
it's really really small but

2761
01:31:18,270 --> 01:31:21,000
I'm in the vm.c

2762
01:31:21,000 --> 01:31:26,280
on line 43, 41,

2763
01:31:26,280 --> 01:31:28,380
um, it says that,

2764
01:31:28,820 --> 01:31:30,080
no, mignt 43,

2765
01:31:30,080 --> 01:31:30,680
my bad,

2766
01:31:30,680 --> 01:31:35,800
um, it says physical stop minus (uint64)etext

2767
01:31:35,800 --> 01:31:38,020
but wouldn't that,

2768
01:31:38,370 --> 01:31:40,580
would not go over the,

2769
01:31:41,100 --> 01:31:43,260
I guess the memory that

2770
01:31:43,260 --> 01:31:46,020
we shouldn't touch, I don't

2771
01:31:46,020 --> 01:31:47,070
know if that makes sense,

2772
01:31:47,070 --> 01:31:48,340
but,

2773
01:31:48,540 --> 01:31:50,240
Would that go.

2774
01:31:51,210 --> 01:31:53,130
我想我不明白，他们会不会检查一下空闲内存。
I guess I don't understand, would

2775
01:31:53,130 --> 01:31:54,920
they go over free memory.

2776
01:31:55,790 --> 01:31:58,820
不，我不这么认为，所以KERNBASE是0x8000，对，所以这是内存的开始。
No, I don't think so,

2777
01:31:58,820 --> 01:32:03,680
so KERNBASE is 0x8000, right

2778
01:32:03,680 --> 01:32:05,800
so that's the beginning of memory.

2779
01:32:06,070 --> 01:32:09,400
内核在那里，基本上，这是一个大小，对，所以etext是内核的最后一个地址，减去KERNBASE，它基本上给出了内核的大小，im，以字节为单位。
Kernel sits there in,

2780
01:32:09,430 --> 01:32:11,320
basically,

2781
01:32:12,470 --> 01:32:14,340
this thing is a size,

2782
01:32:15,070 --> 01:32:16,450
right, so etext is the

2783
01:32:16,450 --> 01:32:18,280
last address of the kernel,

2784
01:32:18,280 --> 01:32:20,200
subtract KERNBASE, that basically gives

2785
01:32:20,200 --> 01:32:21,800
you the size of the kernel,

2786
01:32:22,730 --> 01:32:26,160
im, in byte.

2787
01:32:26,490 --> 01:32:28,140
而且，你知道，我不知道它有多少，但它就像你知道的60或90页或类似的东西。
And, you know, I don't know how

2788
01:32:28,140 --> 01:32:30,570
much it is, but it's

2789
01:32:30,570 --> 01:32:31,800
like you know 60 or 90

2790
01:32:31,800 --> 01:32:33,460
pages or something like that.

2791
01:32:33,990 --> 01:32:35,580
嗯，所以这个映射基本上是内核的文本部分。
Um, and so this map

2792
01:32:35,580 --> 01:32:36,870
is basically the text part

2793
01:32:36,870 --> 01:32:37,760
of the kernel.

2794
01:32:38,350 --> 01:32:41,170
嗯，还有嗯，还有足够的空间。
Um, and um,

2795
01:32:41,170 --> 01:32:42,640
and there's enough space.

2796
01:32:43,290 --> 01:32:45,330
嗯，那里有足够的DRAM来映射内核文本。
Um, there's enough DRAM there to

2797
01:32:45,330 --> 01:32:48,460
map that the kernel text.

2798
01:32:48,830 --> 01:32:49,730
我不确定，我在回答你的问题，但是。我想我明白了。
I'm not sure, I'm answering

2799
01:32:49,730 --> 01:32:50,240
your question,

2800
01:32:50,240 --> 01:32:53,030
but. I think I think

2801
01:32:53,030 --> 01:32:53,840
I understand.

2802
01:32:54,030 --> 01:32:56,670
我以为etext是从别的地方开始的，好的，我想我现在明白了，谢谢，所以etext基本上是最后一条指令，内核最后一条指令的地址。
I thought that etext starts

2803
01:32:56,670 --> 01:32:57,960
somewhere else, okay I think I

2804
01:32:57,960 --> 01:32:58,500
understand now,

2805
01:32:58,500 --> 01:32:59,250
thank you,

2806
01:32:59,250 --> 01:33:01,080
So etext basically the last instruction,

2807
01:33:01,080 --> 01:33:02,310
the address of the last instruction

2808
01:33:02,310 --> 01:33:03,080
of the kernel.

2809
01:33:03,690 --> 01:33:04,720
好的，好的。
Okay, okay.
