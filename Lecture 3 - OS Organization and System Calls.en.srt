1
00:00:07,759 --> 00:00:11,280
am i loud and clear yep sounds good

2
00:00:11,280 --> 00:00:13,840
okay great uh so good afternoon or good

3
00:00:13,840 --> 00:00:15,519
evening or good morning or a good night

4
00:00:15,519 --> 00:00:17,920
wherever you are

5
00:00:17,920 --> 00:00:20,000
let's get started on the like i said

6
00:00:20,000 --> 00:00:21,359
this third lecture in

7
00:00:21,359 --> 00:00:23,920
so 81 which is going to be about ois

8
00:00:23,920 --> 00:00:25,359
organization

9
00:00:25,359 --> 00:00:28,960
and the topics for today

10
00:00:28,960 --> 00:00:32,229
are

11
00:00:32,239 --> 00:00:34,880
four things that i want to touch on one

12
00:00:34,880 --> 00:00:36,480
is isolation

13
00:00:36,480 --> 00:00:39,280
which you'll see is the driving design

14
00:00:39,280 --> 00:00:40,399
goal

15
00:00:40,399 --> 00:00:42,879
for os organization i'll talk a little

16
00:00:42,879 --> 00:00:43,520
bit about

17
00:00:43,520 --> 00:00:47,270
kernel and user mode

18
00:00:47,280 --> 00:00:50,239
as a way of isolating the kernel from or

19
00:00:50,239 --> 00:00:51,680
the operating system from

20
00:00:51,680 --> 00:00:54,079
user applications uh then i'll talk

21
00:00:54,079 --> 00:00:55,680
about system calls

22
00:00:55,680 --> 00:00:58,399
which is a way for you know user

23
00:00:58,399 --> 00:01:00,320
applications to basically transition

24
00:01:00,320 --> 00:01:01,359
into the kernel

25
00:01:01,359 --> 00:01:03,440
uh so they can ask for services and

26
00:01:03,440 --> 00:01:04,879
we'll look at a little bit how this all

27
00:01:04,879 --> 00:01:05,280
is

28
00:01:05,280 --> 00:01:08,240
instantiated in a simple form uh inside

29
00:01:08,240 --> 00:01:08,640
of

30
00:01:08,640 --> 00:01:12,159
x36 so that is the the point for today

31
00:01:12,159 --> 00:01:15,600
um and just to sort of

32
00:01:15,600 --> 00:01:19,520
remind you uh where we were

33
00:01:19,520 --> 00:01:22,159
after the first lecture uh the picture

34
00:01:22,159 --> 00:01:22,960
sort of in your head

35
00:01:22,960 --> 00:01:24,720
that you should have in your head is you

36
00:01:24,720 --> 00:01:26,400
know there are processes

37
00:01:26,400 --> 00:01:30,789
like the shell like echo

38
00:01:30,799 --> 00:01:34,310
or whatever

39
00:01:34,320 --> 00:01:35,680
find you know whatever some of the

40
00:01:35,680 --> 00:01:37,840
utilities that you implemented

41
00:01:37,840 --> 00:01:40,159
they're running on top of an operating

42
00:01:40,159 --> 00:01:42,479
system

43
00:01:42,479 --> 00:01:43,920
and you know the operating system

44
00:01:43,920 --> 00:01:45,439
abstracts you know some of the hardware

45
00:01:45,439 --> 00:01:46,720
resources

46
00:01:46,720 --> 00:01:50,000
you know like a disk or cpu and you know

47
00:01:50,000 --> 00:01:51,360
basically the interface between the

48
00:01:51,360 --> 00:01:53,040
operating systems and the

49
00:01:53,040 --> 00:01:54,560
is not typically referred to as a system

50
00:01:54,560 --> 00:01:56,240
called interface and the interface that

51
00:01:56,240 --> 00:01:57,360
we've been looking at

52
00:01:57,360 --> 00:02:01,749
is the unix interface

53
00:02:01,759 --> 00:02:05,030
and here what we see

54
00:02:05,040 --> 00:02:08,239
is so that was roughly you know actually

55
00:02:08,239 --> 00:02:10,080
with that unix interface you've been

56
00:02:10,080 --> 00:02:11,920
playing around in lab one

57
00:02:11,920 --> 00:02:14,239
uh were in the util app where you used

58
00:02:14,239 --> 00:02:15,599
you know the system called interstates

59
00:02:15,599 --> 00:02:16,800
or the unix api

60
00:02:16,800 --> 00:02:18,160
to actually implement different sets of

61
00:02:18,160 --> 00:02:20,160
applications and so

62
00:02:20,160 --> 00:02:22,800
lab one uh user lab was mostly focused

63
00:02:22,800 --> 00:02:23,280
on

64
00:02:23,280 --> 00:02:25,040
you know sort of using you know this

65
00:02:25,040 --> 00:02:26,640
part uh

66
00:02:26,640 --> 00:02:28,800
of the design picture here and what

67
00:02:28,800 --> 00:02:30,560
we're gonna be doing now

68
00:02:30,560 --> 00:02:32,400
in this first lecture or this lecture

69
00:02:32,400 --> 00:02:33,840
and many subsequent lectures

70
00:02:33,840 --> 00:02:35,840
we're gonna really look actually how

71
00:02:35,840 --> 00:02:38,319
that interface is actually implemented

72
00:02:38,319 --> 00:02:39,840
in fact almost all the semester we're

73
00:02:39,840 --> 00:02:42,160
going to be spending time on

74
00:02:42,160 --> 00:02:43,760
figuring out actually how to implement

75
00:02:43,760 --> 00:02:45,519
the interface and so this is going to be

76
00:02:45,519 --> 00:02:46,720
the first lecture

77
00:02:46,720 --> 00:02:49,519
of that kind of style and uh

78
00:02:49,519 --> 00:02:50,319
unfortunately

79
00:02:50,319 --> 00:02:52,400
uh you know a lot of you asked really

80
00:02:52,400 --> 00:02:53,519
great questions uh

81
00:02:53,519 --> 00:02:56,560
over email um or submitted a great

82
00:02:56,560 --> 00:02:57,920
question to the website

83
00:02:57,920 --> 00:03:00,560
uh and we won't be able uh you know to

84
00:03:00,560 --> 00:03:01,840
go into great amount of detail

85
00:03:01,840 --> 00:03:03,440
immediately in the sort of first lecture

86
00:03:03,440 --> 00:03:04,959
that takes an inside loop of the

87
00:03:04,959 --> 00:03:05,840
operating system

88
00:03:05,840 --> 00:03:06,959
so we're going to touch on a lot of

89
00:03:06,959 --> 00:03:08,959
different things but many things will

90
00:03:08,959 --> 00:03:11,040
become more clear

91
00:03:11,040 --> 00:03:12,400
in subsequent lectures where we're going

92
00:03:12,400 --> 00:03:14,800
to explore them in more depth

93
00:03:14,800 --> 00:03:17,280
but nevertheless if there's something

94
00:03:17,280 --> 00:03:18,080
unclear

95
00:03:18,080 --> 00:03:20,159
uh feel free to interrupt and ask a

96
00:03:20,159 --> 00:03:21,920
question

97
00:03:21,920 --> 00:03:24,640
and maybe just to start off uh before

98
00:03:24,640 --> 00:03:26,239
actually going any further

99
00:03:26,239 --> 00:03:28,720
uh let me ask you a question and sort of

100
00:03:28,720 --> 00:03:29,360
get yes

101
00:03:29,360 --> 00:03:31,360
questions and answering hopefully going

102
00:03:31,360 --> 00:03:32,560
and ask you like

103
00:03:32,560 --> 00:03:34,000
what is the sort of most interesting

104
00:03:34,000 --> 00:03:36,239
thing that you learned from the

105
00:03:36,239 --> 00:03:38,879
beautiful app and i'll start by

106
00:03:38,879 --> 00:03:40,239
answering that question myself

107
00:03:40,239 --> 00:03:41,840
uh one of the things that actually

108
00:03:41,840 --> 00:03:44,319
surprised me after writing or doing the

109
00:03:44,319 --> 00:03:46,720
usual app is that

110
00:03:46,720 --> 00:03:49,040
i use xrx a lot more frequently than i

111
00:03:49,040 --> 00:03:50,480
used to do i had another

112
00:03:50,480 --> 00:03:52,080
way of doing basically the same thing as

113
00:03:52,080 --> 00:03:53,519
xrx

114
00:03:53,519 --> 00:03:56,959
instead of commands and after actually

115
00:03:56,959 --> 00:03:57,760
doing the

116
00:03:57,760 --> 00:03:59,439
xrg lab i was just like oh that's much

117
00:03:59,439 --> 00:04:00,879
more convenient actually to use it in

118
00:04:00,879 --> 00:04:01,360
that way

119
00:04:01,360 --> 00:04:03,840
and so since then i've been a much more

120
00:04:03,840 --> 00:04:04,879
aggressive user

121
00:04:04,879 --> 00:04:07,360
of x-arcs and i'm just wondering you

122
00:04:07,360 --> 00:04:08,239
know what the

123
00:04:08,239 --> 00:04:10,720
you know what the experience has been

124
00:04:10,720 --> 00:04:11,680
for some of you

125
00:04:11,680 --> 00:04:14,640
and so maybe i'll call out a few names

126
00:04:14,640 --> 00:04:15,599
and

127
00:04:15,599 --> 00:04:17,519
maybe you can mute your microphone then

128
00:04:17,519 --> 00:04:19,120
and sort of test it

129
00:04:19,120 --> 00:04:20,880
and say a little bit about like your

130
00:04:20,880 --> 00:04:23,360
experience with the youtube lab

131
00:04:23,360 --> 00:04:26,080
uh so let me you know pick some people

132
00:04:26,080 --> 00:04:26,560
uh

133
00:04:26,560 --> 00:04:33,030
andrew you

134
00:04:33,040 --> 00:04:36,080
andrew are you online we're listening uh

135
00:04:36,080 --> 00:04:37,520
the most interesting thing for me was

136
00:04:37,520 --> 00:04:38,880
just the pipes

137
00:04:38,880 --> 00:04:42,639
on how to write concurrent programs

138
00:04:42,639 --> 00:04:43,840
had you done any sort of pipe

139
00:04:43,840 --> 00:04:46,479
programming before no i haven't i've

140
00:04:46,479 --> 00:04:48,000
seen the old concurrent stuff but i

141
00:04:48,000 --> 00:04:50,560
haven't seen like os level pipes before

142
00:04:50,560 --> 00:04:55,350
okay how about uh elizabeth weeks

143
00:04:55,360 --> 00:04:57,520
uh yeah i'd agree with that i also

144
00:04:57,520 --> 00:04:58,720
thought that the like

145
00:04:58,720 --> 00:05:00,639
os pipes were super interesting and like

146
00:05:00,639 --> 00:05:02,479
the primes um

147
00:05:02,479 --> 00:05:05,120
example specifically was cool to kind of

148
00:05:05,120 --> 00:05:06,560
figure out and realize that like i

149
00:05:06,560 --> 00:05:08,320
needed to close certain pipes and just

150
00:05:08,320 --> 00:05:09,120
like

151
00:05:09,120 --> 00:05:11,120
are they kind of related to each other

152
00:05:11,120 --> 00:05:13,120
yeah yeah presumably you did find the

153
00:05:13,120 --> 00:05:13,840
pipes of

154
00:05:13,840 --> 00:05:16,479
crime is a little bit harder than uh you

155
00:05:16,479 --> 00:05:17,440
might have thought

156
00:05:17,440 --> 00:05:20,000
uh because it surprises me every time a

157
00:05:20,000 --> 00:05:22,080
little bit tricky to get it right

158
00:05:22,080 --> 00:05:26,310
uh jessica she

159
00:05:26,320 --> 00:05:29,039
um i also thought the primes exercise

160
00:05:29,039 --> 00:05:33,029
was most interesting

161
00:05:33,039 --> 00:05:34,800
did it take you a lot of time or was it

162
00:05:34,800 --> 00:05:36,840
not too bad

163
00:05:36,840 --> 00:05:40,000
um it took me

164
00:05:40,000 --> 00:05:41,759
more time after i realized my initial

165
00:05:41,759 --> 00:05:42,880
implementation wasn't actually

166
00:05:42,880 --> 00:05:44,160
concurrent so it was interesting to

167
00:05:44,160 --> 00:05:45,440
think about like

168
00:05:45,440 --> 00:05:48,560
what the differences are there okay

169
00:05:48,560 --> 00:05:53,909
how about the uh robert murphy

170
00:05:53,919 --> 00:05:57,120
yeah i think that the the my experience

171
00:05:57,120 --> 00:05:58,080
was really just

172
00:05:58,080 --> 00:06:01,120
um i found it really challenging to

173
00:06:01,120 --> 00:06:01,680
program

174
00:06:01,680 --> 00:06:04,000
in in the uh original way that was set

175
00:06:04,000 --> 00:06:05,280
up so i actually created like a bunch of

176
00:06:05,280 --> 00:06:06,800
helper functions that wrapped around

177
00:06:06,800 --> 00:06:07,360
things

178
00:06:07,360 --> 00:06:11,600
um so that's i guess what i did

179
00:06:11,600 --> 00:06:14,639
okay any uh i might

180
00:06:14,639 --> 00:06:18,000
also have sort of any piece of wisdom

181
00:06:18,000 --> 00:06:21,120
amanda go ahead i i kind of liked it and

182
00:06:21,120 --> 00:06:23,440
found it surprising slash cool that

183
00:06:23,440 --> 00:06:26,639
um s2d and and std out are just filed

184
00:06:26,639 --> 00:06:27,759
scripters themselves

185
00:06:27,759 --> 00:06:31,280
zero and one yeah yeah yeah good yeah

186
00:06:31,280 --> 00:06:33,120
yeah and xv6 doesn't hide that from you

187
00:06:33,120 --> 00:06:35,759
at all at least in a normal ce

188
00:06:35,759 --> 00:06:37,120
library that's a little bit wrapped up

189
00:06:37,120 --> 00:06:39,520
in a uh in a

190
00:06:39,520 --> 00:06:42,240
in an interface but uh xv6 doesn't hide

191
00:06:42,240 --> 00:06:43,759
it for you but in the end it boils down

192
00:06:43,759 --> 00:06:44,400
in d2

193
00:06:44,400 --> 00:06:46,160
you know just file descriptor zero one

194
00:06:46,160 --> 00:06:49,280
and two i guess for standard error

195
00:06:49,280 --> 00:06:53,840
good good alexander

196
00:06:53,840 --> 00:06:57,280
um i guess um one thing i was surprised

197
00:06:57,280 --> 00:06:57,840
about

198
00:06:57,840 --> 00:07:02,880
uh was also from the primes problem um

199
00:07:02,880 --> 00:07:06,080
i had this bug that i spent hours on

200
00:07:06,080 --> 00:07:08,240
and the thing was that i didn't realize

201
00:07:08,240 --> 00:07:09,840
that actually there were

202
00:07:09,840 --> 00:07:14,070
whenever you were um

203
00:07:14,080 --> 00:07:16,800
opening a pipe and then for like calling

204
00:07:16,800 --> 00:07:17,360
fork

205
00:07:17,360 --> 00:07:20,560
then basically there would be four uh

206
00:07:20,560 --> 00:07:23,520
ends to the pipe because that pipe it's

207
00:07:23,520 --> 00:07:24,400
kind of

208
00:07:24,400 --> 00:07:26,880
uh goes both to the child process and

209
00:07:26,880 --> 00:07:27,440
the price

210
00:07:27,440 --> 00:07:30,000
the parent process and but i was only

211
00:07:30,000 --> 00:07:32,960
closing two of those

212
00:07:32,960 --> 00:07:36,880
so yeah that was a common common problem

213
00:07:36,880 --> 00:07:39,280
it made sense but for some reason

214
00:07:39,280 --> 00:07:40,160
because

215
00:07:40,160 --> 00:07:43,120
especially the textbook says that when

216
00:07:43,120 --> 00:07:44,160
you fork

217
00:07:44,160 --> 00:07:46,479
uh all of the open file descriptors get

218
00:07:46,479 --> 00:07:47,360
copied

219
00:07:47,360 --> 00:07:49,840
but i didn't think about it then yeah no

220
00:07:49,840 --> 00:07:50,960
it's hard to i mean there's a lot of

221
00:07:50,960 --> 00:07:52,319
details in that interface and you know

222
00:07:52,319 --> 00:07:53,759
the only way to get actually really

223
00:07:53,759 --> 00:07:55,199
familiar with it actually is to program

224
00:07:55,199 --> 00:07:56,879
with it and then

225
00:07:56,879 --> 00:08:00,080
experience it okay good well

226
00:08:00,080 --> 00:08:02,160
i hope you enjoyed the lab uh and you

227
00:08:02,160 --> 00:08:03,360
know of course i hope you'll enjoy the

228
00:08:03,360 --> 00:08:04,560
subsequent labs too

229
00:08:04,560 --> 00:08:06,080
so the lecture for today in some sense

230
00:08:06,080 --> 00:08:08,319
is really you know partially to help you

231
00:08:08,319 --> 00:08:10,160
to get going on the

232
00:08:10,160 --> 00:08:13,120
uh the cisco lab if you haven't already

233
00:08:13,120 --> 00:08:14,479
started and so again

234
00:08:14,479 --> 00:08:16,080
uh you know feel free to interrupt and

235
00:08:16,080 --> 00:08:17,599
ask questions

236
00:08:17,599 --> 00:08:20,879
okay so the first thing i want to do uh

237
00:08:20,879 --> 00:08:23,919
is uh talk a little bit about

238
00:08:23,919 --> 00:08:26,720
isolation uh and you know why it's

239
00:08:26,720 --> 00:08:27,840
important and

240
00:08:27,840 --> 00:08:30,160
why we might care and you know the basic

241
00:08:30,160 --> 00:08:31,919
stories you know reasonably simple

242
00:08:31,919 --> 00:08:33,360
you know we have multiple applications

243
00:08:33,360 --> 00:08:34,959
here we got the shell we got echo

244
00:08:34,959 --> 00:08:36,880
we find and it would be great correct

245
00:08:36,880 --> 00:08:38,800
that if you had a bug in the shell or

246
00:08:38,800 --> 00:08:41,200
for example in your primes program that

247
00:08:41,200 --> 00:08:42,640
actually didn't affect any of the other

248
00:08:42,640 --> 00:08:44,000
applications you know particularly it

249
00:08:44,000 --> 00:08:45,519
would be bad for example if it affected

250
00:08:45,519 --> 00:08:46,959
the shell because probably the seller

251
00:08:46,959 --> 00:08:48,560
you're using to actually you know kill

252
00:08:48,560 --> 00:08:50,959
the program if something goes bad

253
00:08:50,959 --> 00:08:53,120
so you want sort of strong isolation

254
00:08:53,120 --> 00:08:54,240
between these uh

255
00:08:54,240 --> 00:08:56,720
different applications and similarly you

256
00:08:56,720 --> 00:08:57,920
know the os

257
00:08:57,920 --> 00:08:59,519
is sort of the servant you know for all

258
00:08:59,519 --> 00:09:01,200
the applications uh

259
00:09:01,200 --> 00:09:02,480
and you would like it to be the case

260
00:09:02,480 --> 00:09:04,560
that you know if again you know you make

261
00:09:04,560 --> 00:09:06,560
a bug in one of your util programs that

262
00:09:06,560 --> 00:09:07,760
actually the operating system doesn't

263
00:09:07,760 --> 00:09:09,279
crash you know exactly you pass some

264
00:09:09,279 --> 00:09:10,399
strange argument to the

265
00:09:10,399 --> 00:09:12,160
operating system uh you know should be

266
00:09:12,160 --> 00:09:13,279
the case that the operating system

267
00:09:13,279 --> 00:09:14,640
handles that well

268
00:09:14,640 --> 00:09:16,160
and so again you would like to be

269
00:09:16,160 --> 00:09:18,240
there's a strong isolation between

270
00:09:18,240 --> 00:09:22,320
uh the the applications and

271
00:09:22,320 --> 00:09:25,360
the operating system itself um and one

272
00:09:25,360 --> 00:09:26,880
way to think about this a little bit is

273
00:09:26,880 --> 00:09:27,519
to say

274
00:09:27,519 --> 00:09:29,279
is ask ourselves the question you know

275
00:09:29,279 --> 00:09:30,800
what what would happen if there's

276
00:09:30,800 --> 00:09:31,680
actually

277
00:09:31,680 --> 00:09:33,519
no operating system so like you know

278
00:09:33,519 --> 00:09:35,360
consider some straw man design

279
00:09:35,360 --> 00:09:40,070
design

280
00:09:40,080 --> 00:09:45,350
where there is no operating system

281
00:09:45,360 --> 00:09:46,880
or you can think about it as the

282
00:09:46,880 --> 00:09:48,320
operating system basically basically

283
00:09:48,320 --> 00:09:49,839
just being a library you know sort of

284
00:09:49,839 --> 00:09:50,320
thinking of

285
00:09:50,320 --> 00:09:52,640
you know in terms of python uh maybe

286
00:09:52,640 --> 00:09:53,839
just import os

287
00:09:53,839 --> 00:09:56,320
and import os basically loads the whole

288
00:09:56,320 --> 00:09:57,680
operating system inside of your

289
00:09:57,680 --> 00:09:58,640
application

290
00:09:58,640 --> 00:09:59,920
and that's you know the programming

291
00:09:59,920 --> 00:10:01,839
interface you use

292
00:10:01,839 --> 00:10:04,000
so if you think about that sort of way

293
00:10:04,000 --> 00:10:05,440
of thinking so let's say we have to

294
00:10:05,440 --> 00:10:06,320
shell here

295
00:10:06,320 --> 00:10:07,920
you know maybe it includes the you know

296
00:10:07,920 --> 00:10:09,680
the library for

297
00:10:09,680 --> 00:10:12,480
the os and maybe we have some other

298
00:10:12,480 --> 00:10:14,480
application echo

299
00:10:14,480 --> 00:10:16,720
uh and then basically you know these

300
00:10:16,720 --> 00:10:18,079
these applications

301
00:10:18,079 --> 00:10:20,640
if there's no operating system really it

302
00:10:20,640 --> 00:10:21,920
would directly interact with the

303
00:10:21,920 --> 00:10:23,040
hardware

304
00:10:23,040 --> 00:10:24,560
so for example you know they would

305
00:10:24,560 --> 00:10:26,800
actually see you know there's a cpu core

306
00:10:26,800 --> 00:10:29,600
you know there's another cpu core and

307
00:10:29,600 --> 00:10:30,880
you know maybe there's a disk

308
00:10:30,880 --> 00:10:32,560
and they interact directly with the disc

309
00:10:32,560 --> 00:10:34,240
blocks and maybe there's memory and they

310
00:10:34,240 --> 00:10:35,680
will directly interact with the memory

311
00:10:35,680 --> 00:10:37,680
of the machine

312
00:10:37,680 --> 00:10:40,000
and so there's really no layer between

313
00:10:40,000 --> 00:10:41,680
no abstraction layer between basically

314
00:10:41,680 --> 00:10:43,279
the applications

315
00:10:43,279 --> 00:10:46,240
and the hardware and it turns out that

316
00:10:46,240 --> 00:10:48,399
it's just not such a great design

317
00:10:48,399 --> 00:10:51,440
uh for uh isolation

318
00:10:51,440 --> 00:10:53,200
and you can see how isolation might be

319
00:10:53,200 --> 00:10:56,000
broken let's assume for example that you

320
00:10:56,000 --> 00:10:56,560
know

321
00:10:56,560 --> 00:10:57,920
one of the goals graph the operating

322
00:10:57,920 --> 00:11:00,320
system is run multiple applications

323
00:11:00,320 --> 00:11:02,320
and so that has to be the case that in

324
00:11:02,320 --> 00:11:04,000
once in a while it will switch

325
00:11:04,000 --> 00:11:05,360
from one application to another

326
00:11:05,360 --> 00:11:07,040
application let's say the hardware has

327
00:11:07,040 --> 00:11:07,839
only one

328
00:11:07,839 --> 00:11:09,920
cpu and so we're running the shell

329
00:11:09,920 --> 00:11:11,440
saying that one cpu

330
00:11:11,440 --> 00:11:12,880
but you know periodically and other

331
00:11:12,880 --> 00:11:15,440
applications should be able to run too

332
00:11:15,440 --> 00:11:17,200
well we have no operating system you

333
00:11:17,200 --> 00:11:18,720
know to do it for us

334
00:11:18,720 --> 00:11:20,079
then the shell basically has to sort of

335
00:11:20,079 --> 00:11:24,079
give up you know the cpu once in a while

336
00:11:24,079 --> 00:11:26,320
and so to be a nice person and say like

337
00:11:26,320 --> 00:11:27,440
well you know i've run for a little

338
00:11:27,440 --> 00:11:29,120
while now you get a chance to run

339
00:11:29,120 --> 00:11:30,640
and this is sometimes called cooperative

340
00:11:30,640 --> 00:11:32,560
scheduling um

341
00:11:32,560 --> 00:11:34,399
but that's not so great for isolation

342
00:11:34,399 --> 00:11:36,079
you know for example what what if you

343
00:11:36,079 --> 00:11:37,839
know some function in the shell has an

344
00:11:37,839 --> 00:11:38,880
infinite loop

345
00:11:38,880 --> 00:11:40,560
and therefore it will never actually

346
00:11:40,560 --> 00:11:42,720
give up the cpu and then no other

347
00:11:42,720 --> 00:11:44,320
you know applications could run

348
00:11:44,320 --> 00:11:45,839
including maybe the application that

349
00:11:45,839 --> 00:11:47,120
would like stop or kill

350
00:11:47,120 --> 00:11:49,680
you know the shell and so uh we

351
00:11:49,680 --> 00:11:51,839
basically don't get any sort of form of

352
00:11:51,839 --> 00:11:52,560
enforced

353
00:11:52,560 --> 00:11:54,800
multiplexing and that's something that

354
00:11:54,800 --> 00:11:55,760
we'd like to have

355
00:11:55,760 --> 00:11:57,440
where you know no matter what the

356
00:11:57,440 --> 00:11:59,680
application does it will be forced to

357
00:11:59,680 --> 00:12:01,680
give up the cpu once in a while

358
00:12:01,680 --> 00:12:04,880
so that other applications go wrong

359
00:12:04,880 --> 00:12:06,000
similarly you know if you think about

360
00:12:06,000 --> 00:12:08,320
this drama and design uh

361
00:12:08,320 --> 00:12:10,240
you know we have there's like physical

362
00:12:10,240 --> 00:12:11,519
memory right and all

363
00:12:11,519 --> 00:12:13,519
i drew the picture here as for the

364
00:12:13,519 --> 00:12:14,639
application sitting on the top of the

365
00:12:14,639 --> 00:12:15,519
hardware

366
00:12:15,519 --> 00:12:17,839
but you know there's physical memory and

367
00:12:17,839 --> 00:12:18,880
basically the text

368
00:12:18,880 --> 00:12:20,639
in the code and the data for these

369
00:12:20,639 --> 00:12:22,320
applications actually sits in physical

370
00:12:22,320 --> 00:12:24,639
memory right so here's memory

371
00:12:24,639 --> 00:12:27,120
and here's me saying the you know the

372
00:12:27,120 --> 00:12:28,639
part of physical memory that's used by

373
00:12:28,639 --> 00:12:29,360
the shell

374
00:12:29,360 --> 00:12:30,959
and here's maybe the part of the

375
00:12:30,959 --> 00:12:32,720
physical memory that's used by

376
00:12:32,720 --> 00:12:35,680
echo application and so you're gonna you

377
00:12:35,680 --> 00:12:36,399
know and

378
00:12:36,399 --> 00:12:38,560
again what we see here if we use like

379
00:12:38,560 --> 00:12:40,720
simply simplistically like this

380
00:12:40,720 --> 00:12:44,079
uh there's sort of no uh boundary

381
00:12:44,079 --> 00:12:47,279
between these two guys if for example if

382
00:12:47,279 --> 00:12:49,680
you know echo you know stores through

383
00:12:49,680 --> 00:12:51,680
location that for example belongs you

384
00:12:51,680 --> 00:12:52,800
know to

385
00:12:52,800 --> 00:12:55,040
the shell like location 1000 and writes

386
00:12:55,040 --> 00:12:56,320
a value there

387
00:12:56,320 --> 00:12:58,480
you know whatever x uh then it would

388
00:12:58,480 --> 00:13:00,240
just overwrite the physical memory of

389
00:13:00,240 --> 00:13:00,959
the

390
00:13:00,959 --> 00:13:03,200
shell memory and so that you know be

391
00:13:03,200 --> 00:13:05,040
pretty undesirable okay because then a

392
00:13:05,040 --> 00:13:06,000
bug you know an echo

393
00:13:06,000 --> 00:13:08,079
could actually percolate into the shell

394
00:13:08,079 --> 00:13:09,279
and you know it's going to be very

395
00:13:09,279 --> 00:13:10,720
tricky to debug and that kind of stuff

396
00:13:10,720 --> 00:13:12,079
and so this basically again

397
00:13:12,079 --> 00:13:15,360
gives us like no strong isolation

398
00:13:15,360 --> 00:13:18,720
what we'd like is uh to have

399
00:13:18,720 --> 00:13:21,279
memory isolation so that one application

400
00:13:21,279 --> 00:13:22,720
cannot overwrite

401
00:13:22,720 --> 00:13:26,240
the uh memory of another application

402
00:13:26,240 --> 00:13:29,279
um and it's a

403
00:13:29,279 --> 00:13:32,160
you know one reason you know i mean

404
00:13:32,160 --> 00:13:33,519
probably the main reason to actually

405
00:13:33,519 --> 00:13:34,800
have an operating system

406
00:13:34,800 --> 00:13:36,720
is basically to enforce you know both

407
00:13:36,720 --> 00:13:38,000
the multiplexing

408
00:13:38,000 --> 00:13:40,480
uh and to enforce you know strong memory

409
00:13:40,480 --> 00:13:41,440
isolation

410
00:13:41,440 --> 00:13:42,639
and if you didn't have an operating

411
00:13:42,639 --> 00:13:44,160
system and the applicants were directly

412
00:13:44,160 --> 00:13:45,440
interacting with the hardware

413
00:13:45,440 --> 00:13:47,920
it would be very hard to achieve that

414
00:13:47,920 --> 00:13:48,560
and so

415
00:13:48,560 --> 00:13:50,000
this design of basically you know

416
00:13:50,000 --> 00:13:51,600
operating system as a library

417
00:13:51,600 --> 00:13:53,600
is not a very common design you may see

418
00:13:53,600 --> 00:13:55,199
it in some real-time systems

419
00:13:55,199 --> 00:13:56,959
where basically applications trust each

420
00:13:56,959 --> 00:13:58,959
other but in most other

421
00:13:58,959 --> 00:14:00,720
operating systems you know there's an

422
00:14:00,720 --> 00:14:02,320
operating system that really enforces

423
00:14:02,320 --> 00:14:03,120
you know that kind of

424
00:14:03,120 --> 00:14:06,399
isolation so if we

425
00:14:06,399 --> 00:14:08,480
look a little bit now at the unix

426
00:14:08,480 --> 00:14:14,310
interface from this perspective

427
00:14:14,320 --> 00:14:16,399
then we see that the interface actually

428
00:14:16,399 --> 00:14:18,639
is carefully designed

429
00:14:18,639 --> 00:14:21,519
so that it actually is feasible to

430
00:14:21,519 --> 00:14:22,240
implement

431
00:14:22,240 --> 00:14:25,680
that enforced uh isolation

432
00:14:25,680 --> 00:14:27,279
in terms of multiplexing in terms of

433
00:14:27,279 --> 00:14:29,440
physical memory and the way that is sort

434
00:14:29,440 --> 00:14:29,680
of

435
00:14:29,680 --> 00:14:32,160
done is that the interface basically

436
00:14:32,160 --> 00:14:33,040
abstracts

437
00:14:33,040 --> 00:14:37,269
the hardware

438
00:14:37,279 --> 00:14:40,870
the hardware resources

439
00:14:40,880 --> 00:14:43,279
in a way that then it makes it easy to

440
00:14:43,279 --> 00:14:44,320
actually do

441
00:14:44,320 --> 00:14:46,399
or not easier and it makes it possible

442
00:14:46,399 --> 00:14:48,720
you know to provide you know the strong

443
00:14:48,720 --> 00:14:51,920
isolation um and you know maybe

444
00:14:51,920 --> 00:14:54,720
it gives you some examples uh so

445
00:14:54,720 --> 00:14:56,320
processes now we've seen them like the

446
00:14:56,320 --> 00:14:59,600
things that are created by fork

447
00:14:59,600 --> 00:15:01,519
you know they're not you know literally

448
00:15:01,519 --> 00:15:03,680
a cpu right i mean

449
00:15:03,680 --> 00:15:05,600
but they correspond to like what a cpu

450
00:15:05,600 --> 00:15:07,920
is and it allows you to run computation

451
00:15:07,920 --> 00:15:09,680
but you know because you know they're

452
00:15:09,680 --> 00:15:11,279
the applications cannot directly

453
00:15:11,279 --> 00:15:13,279
interact with the cpu but only for this

454
00:15:13,279 --> 00:15:14,639
process abstraction

455
00:15:14,639 --> 00:15:16,880
the kernel sort of behind the scenes you

456
00:15:16,880 --> 00:15:20,160
know can switch between processes

457
00:15:20,160 --> 00:15:22,320
so instead of having you know direct

458
00:15:22,320 --> 00:15:24,160
cpus to manipulate

459
00:15:24,160 --> 00:15:26,000
or given to the application the

460
00:15:26,000 --> 00:15:27,760
operating system provides processes

461
00:15:27,760 --> 00:15:29,759
that extract the weight or the cpu

462
00:15:29,759 --> 00:15:31,360
itself so that actually the operating

463
00:15:31,360 --> 00:15:32,560
system can multiplex

464
00:15:32,560 --> 00:15:34,880
and one cpu or multiple cpus among

465
00:15:34,880 --> 00:15:37,199
multiple applications

466
00:15:37,199 --> 00:15:40,639
similarly if you think about exec exec

467
00:15:40,639 --> 00:15:44,560
provides a memory image um and

468
00:15:44,560 --> 00:15:47,040
uh armando yeah go ahead ask your

469
00:15:47,040 --> 00:15:47,839
question

470
00:15:47,839 --> 00:15:49,759
one question about like processes sort

471
00:15:49,759 --> 00:15:51,680
of like obstructing

472
00:15:51,680 --> 00:15:55,199
the cpu is it that

473
00:15:55,199 --> 00:15:58,320
one process uses part of the cpu

474
00:15:58,320 --> 00:16:01,360
and another process uses a like more a

475
00:16:01,360 --> 00:16:02,880
different part of that cpu or a

476
00:16:02,880 --> 00:16:03,839
different cpu

477
00:16:03,839 --> 00:16:06,720
if it's like a multi-core or like what

478
00:16:06,720 --> 00:16:08,320
do you mean by processes instead of a

479
00:16:08,320 --> 00:16:09,040
cpu

480
00:16:09,040 --> 00:16:12,000
yeah okay so i really mean one cpu

481
00:16:12,000 --> 00:16:14,079
abstracted away into a process so okay

482
00:16:14,079 --> 00:16:15,680
so the way to think about it is the

483
00:16:15,680 --> 00:16:18,880
uh the risc 5 core or risk 5 processor

484
00:16:18,880 --> 00:16:19,759
that we're using

485
00:16:19,759 --> 00:16:22,880
in the lab that's actually four cores

486
00:16:22,880 --> 00:16:25,360
uh and so you can run four processes

487
00:16:25,360 --> 00:16:27,440
concurrently or in parallel you know one

488
00:16:27,440 --> 00:16:29,199
process on each core

489
00:16:29,199 --> 00:16:30,720
and what the operating system does is

490
00:16:30,720 --> 00:16:32,399
let's say you have eight applications or

491
00:16:32,399 --> 00:16:33,680
seven applications

492
00:16:33,680 --> 00:16:36,240
it will take some core and multiplexes

493
00:16:36,240 --> 00:16:37,440
time multiplexes

494
00:16:37,440 --> 00:16:38,800
between different processes so for

495
00:16:38,800 --> 00:16:41,120
example it will run you know one app

496
00:16:41,120 --> 00:16:43,040
process for 100 milliseconds

497
00:16:43,040 --> 00:16:45,680
then stop unload you know that process

498
00:16:45,680 --> 00:16:46,320
out of the

499
00:16:46,320 --> 00:16:49,759
cpu or out of the core loading the next

500
00:16:49,759 --> 00:16:50,560
uh

501
00:16:50,560 --> 00:16:52,399
application or the next process and runs

502
00:16:52,399 --> 00:16:54,000
that for 100 milliseconds

503
00:16:54,000 --> 00:16:55,920
and it just enforces that no application

504
00:16:55,920 --> 00:16:57,519
can run or no process can run longer

505
00:16:57,519 --> 00:16:59,120
than 100 milliseconds

506
00:16:59,120 --> 00:17:00,800
and we'll see exactly how this is done

507
00:17:00,800 --> 00:17:02,320
in a couple lectures but that's sort of

508
00:17:02,320 --> 00:17:04,160
the basic idea

509
00:17:04,160 --> 00:17:06,559
okay but multiple processes cannot use

510
00:17:06,559 --> 00:17:08,480
the same cpu at the same time

511
00:17:08,480 --> 00:17:11,280
no it's time multiplied you run for one

512
00:17:11,280 --> 00:17:12,640
for a while then you run the next one

513
00:17:12,640 --> 00:17:14,000
for a while

514
00:17:14,000 --> 00:17:17,120
all right thank you okay so

515
00:17:17,120 --> 00:17:19,120
one way to think about exec is that it

516
00:17:19,120 --> 00:17:20,640
actually

517
00:17:20,640 --> 00:17:28,309
abstracts memory

518
00:17:28,319 --> 00:17:31,039
so for example if you think about the

519
00:17:31,039 --> 00:17:32,799
actual system call you know takes a file

520
00:17:32,799 --> 00:17:33,760
name you know

521
00:17:33,760 --> 00:17:35,760
and in that file is basically the memory

522
00:17:35,760 --> 00:17:36,960
image of

523
00:17:36,960 --> 00:17:39,120
a program store you know it's text you

524
00:17:39,120 --> 00:17:40,240
know sometimes it's uh

525
00:17:40,240 --> 00:17:43,760
global data uh and and that forms

526
00:17:43,760 --> 00:17:47,200
the the memory uh of the application

527
00:17:47,200 --> 00:17:49,600
now the application can grow its memory

528
00:17:49,600 --> 00:17:51,360
for example by calling s-break

529
00:17:51,360 --> 00:17:54,320
uh and uh extend there by extending its

530
00:17:54,320 --> 00:17:55,520
data segment

531
00:17:55,520 --> 00:17:57,200
but it doesn't really have a direct

532
00:17:57,200 --> 00:17:59,039
aspect to physical memory you know

533
00:17:59,039 --> 00:18:02,080
you can't just ask or no i want you know

534
00:18:02,080 --> 00:18:04,640
addresses you know physical memory uh 1k

535
00:18:04,640 --> 00:18:05,520
to 2k

536
00:18:05,520 --> 00:18:07,600
uh you know there's no way of getting at

537
00:18:07,600 --> 00:18:08,960
that and again the reason that there's

538
00:18:08,960 --> 00:18:10,640
no way that you can get at that

539
00:18:10,640 --> 00:18:12,320
is because the operating system usually

540
00:18:12,320 --> 00:18:14,160
wants to provide memory isolation

541
00:18:14,160 --> 00:18:15,600
and therefore wants to be in control or

542
00:18:15,600 --> 00:18:18,080
sort of intermediate and intermediate

543
00:18:18,080 --> 00:18:19,520
between the applications and the

544
00:18:19,520 --> 00:18:21,600
physical hardware and exec is you know

545
00:18:21,600 --> 00:18:23,120
sort of a system call that

546
00:18:23,120 --> 00:18:25,600
you know capture or shows that there's

547
00:18:25,600 --> 00:18:27,039
like no direct

548
00:18:27,039 --> 00:18:30,240
access to the memory another example of

549
00:18:30,240 --> 00:18:33,200
this is like files

550
00:18:33,200 --> 00:18:34,799
files basically abstract away disk

551
00:18:34,799 --> 00:18:41,430
blocks

552
00:18:41,440 --> 00:18:44,000
so instead of reading and writing uh the

553
00:18:44,000 --> 00:18:45,679
disc blocks of the the

554
00:18:45,679 --> 00:18:47,120
the disc that sits attached to your

555
00:18:47,120 --> 00:18:49,120
computer uh that's actually just not

556
00:18:49,120 --> 00:18:51,120
allowed in unix you know the only way to

557
00:18:51,120 --> 00:18:53,200
interact or with the storage system

558
00:18:53,200 --> 00:18:54,640
is through files and you can read and

559
00:18:54,640 --> 00:18:56,320
write files you provide a convenient

560
00:18:56,320 --> 00:18:58,240
abstraction you can name files

561
00:18:58,240 --> 00:19:00,000
et cetera et cetera but then the

562
00:19:00,000 --> 00:19:02,160
operating system in itself can actually

563
00:19:02,160 --> 00:19:04,960
decide how to map those files to

564
00:19:04,960 --> 00:19:06,960
this box and make sure that for example

565
00:19:06,960 --> 00:19:09,360
this block only shows up in one file and

566
00:19:09,360 --> 00:19:10,559
that you know user a

567
00:19:10,559 --> 00:19:12,720
cannot actually you know manipulate or

568
00:19:12,720 --> 00:19:13,600
read or write

569
00:19:13,600 --> 00:19:17,039
you know the files of uh user b uh and

570
00:19:17,039 --> 00:19:17,520
again

571
00:19:17,520 --> 00:19:19,200
you know this you know that sort of

572
00:19:19,200 --> 00:19:20,640
interface that

573
00:19:20,640 --> 00:19:22,480
the file abstraction allows that sort of

574
00:19:22,480 --> 00:19:24,400
strong isolation between

575
00:19:24,400 --> 00:19:26,000
even different users and you know to

576
00:19:26,000 --> 00:19:29,280
different processes of the same user

577
00:19:29,280 --> 00:19:30,799
and so you see that you know in some

578
00:19:30,799 --> 00:19:32,160
ways you know the system called

579
00:19:32,160 --> 00:19:33,520
interface or the unix interface that

580
00:19:33,520 --> 00:19:35,120
you've been programming with you know in

581
00:19:35,120 --> 00:19:36,080
the util lab

582
00:19:36,080 --> 00:19:38,080
seems to be sort of carefully designed

583
00:19:38,080 --> 00:19:40,240
to abstract the resources in a way

584
00:19:40,240 --> 00:19:41,840
so that you know the operating system

585
00:19:41,840 --> 00:19:43,440
the implementation of the interface

586
00:19:43,440 --> 00:19:45,039
can actually multiplex you know the

587
00:19:45,039 --> 00:19:47,200
resources on multiple applications

588
00:19:47,200 --> 00:19:53,990
and provides strong strong isolation

589
00:19:54,000 --> 00:19:56,240
any questions about that we have a

590
00:19:56,240 --> 00:19:57,760
question in the chat that says uh do

591
00:19:57,760 --> 00:19:59,679
more complex kernels try to reschedule

592
00:19:59,679 --> 00:20:01,600
processes on the same core to reduce

593
00:20:01,600 --> 00:20:02,720
cash misses

594
00:20:02,720 --> 00:20:05,600
oh yeah uh there's something called

595
00:20:05,600 --> 00:20:06,559
cache affinity

596
00:20:06,559 --> 00:20:09,200
uh uh you know the scan version in you

597
00:20:09,200 --> 00:20:10,880
know modern operating systems are

598
00:20:10,880 --> 00:20:13,200
very sophisticated and indeed you know

599
00:20:13,200 --> 00:20:14,880
trying to avoid cache misses and things

600
00:20:14,880 --> 00:20:16,320
like that and to optimize in the

601
00:20:16,320 --> 00:20:17,600
performance

602
00:20:17,600 --> 00:20:19,440
and you know we'll see some of that much

603
00:20:19,440 --> 00:20:20,960
later in the semester you know when

604
00:20:20,960 --> 00:20:21,280
we're

605
00:20:21,280 --> 00:20:22,559
going to be talking about high

606
00:20:22,559 --> 00:20:24,960
performance networking uh that will show

607
00:20:24,960 --> 00:20:26,240
up there

608
00:20:26,240 --> 00:20:28,880
another question from chat where in xv6

609
00:20:28,880 --> 00:20:30,799
can we see how the os multiplexes

610
00:20:30,799 --> 00:20:31,919
processes

611
00:20:31,919 --> 00:20:35,360
uh we're gonna there's a couple pile of

612
00:20:35,360 --> 00:20:37,200
files that are relevant but proc.c

613
00:20:37,200 --> 00:20:39,440
is probably the most relevant one uh

614
00:20:39,440 --> 00:20:40,799
this will be a topic of

615
00:20:40,799 --> 00:20:43,200
lecture in like two or three weeks and

616
00:20:43,200 --> 00:20:44,480
we're going to go in great amount of

617
00:20:44,480 --> 00:20:45,840
detail and show exactly how the

618
00:20:45,840 --> 00:20:48,240
multiplexing happens

619
00:20:48,240 --> 00:20:49,520
so one way to think about this lecture

620
00:20:49,520 --> 00:20:50,640
is a little bit of an introduction to a

621
00:20:50,640 --> 00:20:51,760
lot of different pieces

622
00:20:51,760 --> 00:20:53,679
and you know because we've got to start

623
00:20:53,679 --> 00:20:56,390
somewhere

624
00:20:56,400 --> 00:21:00,880
okay so um so we go back into this

625
00:21:00,880 --> 00:21:03,120
picture here that i showed a little bit

626
00:21:03,120 --> 00:21:04,159
a while ago

627
00:21:04,159 --> 00:21:06,000
we have this uh the shell running the

628
00:21:06,000 --> 00:21:07,840
echo running or not that picture i want

629
00:21:07,840 --> 00:21:08,720
this picture

630
00:21:08,720 --> 00:21:10,159
here on this side we've got the

631
00:21:10,159 --> 00:21:11,200
operating system we have the

632
00:21:11,200 --> 00:21:12,559
applications running

633
00:21:12,559 --> 00:21:14,640
and one thing we should be worried about

634
00:21:14,640 --> 00:21:15,919
this square words that the operating

635
00:21:15,919 --> 00:21:17,600
system so it should be

636
00:21:17,600 --> 00:21:23,029
uh oh i should be defensive

637
00:21:23,039 --> 00:21:25,440
and this is sort of an important mindset

638
00:21:25,440 --> 00:21:26,159
you know that you

639
00:21:26,159 --> 00:21:28,240
have to get used to uh when you're doing

640
00:21:28,240 --> 00:21:30,159
kernel development

641
00:21:30,159 --> 00:21:31,760
the operating system you know has to

642
00:21:31,760 --> 00:21:33,440
ensure uh

643
00:21:33,440 --> 00:21:34,640
that everything you know everything

644
00:21:34,640 --> 00:21:36,559
works out and so uh

645
00:21:36,559 --> 00:21:38,400
yeah it has to set up things up so that

646
00:21:38,400 --> 00:21:40,400
you know an app cannot crash the

647
00:21:40,400 --> 00:21:45,600
operating system

648
00:21:45,600 --> 00:21:46,960
it would be too bad they have an

649
00:21:46,960 --> 00:21:49,440
application uh that either by accident

650
00:21:49,440 --> 00:21:51,600
or maliciously passes you know a tricky

651
00:21:51,600 --> 00:21:53,200
argument bad argument to

652
00:21:53,200 --> 00:21:54,799
the operating system and the oxford

653
00:21:54,799 --> 00:21:56,559
system would crash that basically means

654
00:21:56,559 --> 00:21:58,000
sort of denial service for

655
00:21:58,000 --> 00:22:00,880
every other application so the operating

656
00:22:00,880 --> 00:22:02,480
system has to be written in a way that

657
00:22:02,480 --> 00:22:04,400
you know it can deal and handle

658
00:22:04,400 --> 00:22:06,240
malicious applications

659
00:22:06,240 --> 00:22:08,320
and particularly another concern is that

660
00:22:08,320 --> 00:22:10,720
an application should not be able

661
00:22:10,720 --> 00:22:21,110
cannot break out of its isolation

662
00:22:21,120 --> 00:22:23,120
i mean the application might be

663
00:22:23,120 --> 00:22:24,320
definitely malicious maybe

664
00:22:24,320 --> 00:22:27,840
written by an attacker and attacker

665
00:22:27,840 --> 00:22:28,240
probably

666
00:22:28,240 --> 00:22:30,240
you know would like to break out of the

667
00:22:30,240 --> 00:22:31,919
application for example and take control

668
00:22:31,919 --> 00:22:32,880
over the kernel

669
00:22:32,880 --> 00:22:34,080
and once you have control over the

670
00:22:34,080 --> 00:22:35,919
kernel then you can do anything because

671
00:22:35,919 --> 00:22:36,960
you know the kernel is

672
00:22:36,960 --> 00:22:39,280
in control of all the hardware resources

673
00:22:39,280 --> 00:22:40,799
and so the operating system has to be or

674
00:22:40,799 --> 00:22:42,799
the kernel has to be written defensively

675
00:22:42,799 --> 00:22:45,520
uh you know to avoid uh those kinds of

676
00:22:45,520 --> 00:22:46,640
things

677
00:22:46,640 --> 00:22:49,280
uh it turns out to be very tricky uh to

678
00:22:49,280 --> 00:22:50,960
actually get right

679
00:22:50,960 --> 00:22:52,640
in fact using linux you know they're

680
00:22:52,640 --> 00:22:54,159
still periodic

681
00:22:54,159 --> 00:22:56,400
bugs you know kernel bugs or blocks that

682
00:22:56,400 --> 00:22:57,280
actually allow

683
00:22:57,280 --> 00:23:00,320
an application to exploit uh or to break

684
00:23:00,320 --> 00:23:02,000
out of this isolation domain

685
00:23:02,000 --> 00:23:05,200
and to take control uh but this is

686
00:23:05,200 --> 00:23:07,039
continuous concern and we like to do as

687
00:23:07,039 --> 00:23:08,799
a good job as possible

688
00:23:08,799 --> 00:23:10,480
and this is the mindset you have to have

689
00:23:10,480 --> 00:23:11,840
you know when you're developing a kernel

690
00:23:11,840 --> 00:23:12,320
that

691
00:23:12,320 --> 00:23:15,360
actually applications are uh

692
00:23:15,360 --> 00:23:18,720
perhaps malicious now this means that

693
00:23:18,720 --> 00:23:19,280
the means

694
00:23:19,280 --> 00:23:26,549
there has to be strong isolation

695
00:23:26,559 --> 00:23:31,430
between the apps

696
00:23:31,440 --> 00:23:35,760
and the os and if the os you know

697
00:23:35,760 --> 00:23:38,080
needs to be defensive and uh needs to be

698
00:23:38,080 --> 00:23:39,760
in a position that can defenses there

699
00:23:39,760 --> 00:23:41,360
has to be sort of a strong wall between

700
00:23:41,360 --> 00:23:42,880
the applications so that the operating

701
00:23:42,880 --> 00:23:44,480
system can actually enforce

702
00:23:44,480 --> 00:23:46,000
you know whatever policies it wants to

703
00:23:46,000 --> 00:23:47,520
enforce

704
00:23:47,520 --> 00:23:49,760
and this is typically done the typical

705
00:23:49,760 --> 00:23:51,360
approach to achieving this strong

706
00:23:51,360 --> 00:23:52,480
isolation

707
00:23:52,480 --> 00:23:57,750
is using hardware support

708
00:23:57,760 --> 00:23:59,120
and we'll give a little bit of flavor of

709
00:23:59,120 --> 00:24:00,640
that in this lecture but we'll come back

710
00:24:00,640 --> 00:24:02,080
to it in much more detail in subsequent

711
00:24:02,080 --> 00:24:04,000
lectures and those are two

712
00:24:04,000 --> 00:24:07,120
two parts of this hardware support one

713
00:24:07,120 --> 00:24:08,640
is something that's called user kernel

714
00:24:08,640 --> 00:24:10,159
mode

715
00:24:10,159 --> 00:24:13,279
slash kernel mode in risk five it's

716
00:24:13,279 --> 00:24:15,120
called supervisor mode but it's the same

717
00:24:15,120 --> 00:24:16,720
thing

718
00:24:16,720 --> 00:24:24,149
and then page tables or virtual memory

719
00:24:24,159 --> 00:24:27,120
so all processors uh sort of all sort of

720
00:24:27,120 --> 00:24:28,480
series processors

721
00:24:28,480 --> 00:24:31,039
uh that are intended to run an operating

722
00:24:31,039 --> 00:24:32,880
system in multiple applications

723
00:24:32,880 --> 00:24:34,960
uh have support you know for either for

724
00:24:34,960 --> 00:24:36,640
user kernel mode and virtual memory you

725
00:24:36,640 --> 00:24:38,240
know it might mean men of stated or

726
00:24:38,240 --> 00:24:39,200
implemented in all

727
00:24:39,200 --> 00:24:40,960
slightly different ways but basically

728
00:24:40,960 --> 00:24:43,120
all processors have it

729
00:24:43,120 --> 00:24:45,440
um and our risk 5 processor that we're

730
00:24:45,440 --> 00:24:46,480
using in this

731
00:24:46,480 --> 00:24:49,760
class has that support too so

732
00:24:49,760 --> 00:24:51,039
let me talk a little bit i'm going to

733
00:24:51,039 --> 00:24:52,559
talk a little bit about user mode in

734
00:24:52,559 --> 00:24:54,000
kernel mode first and then i'll talk a

735
00:24:54,000 --> 00:24:56,480
little bit about virtual memory

736
00:24:56,480 --> 00:24:59,520
mostly at the highest level possible

737
00:24:59,520 --> 00:25:00,720
because there's a lot of important

738
00:25:00,720 --> 00:25:02,240
details that i won't be able to cover

739
00:25:02,240 --> 00:25:04,720
those in this lecture

740
00:25:04,720 --> 00:25:12,830
so let's first talk about user kernel

741
00:25:12,840 --> 00:25:14,559
mode

742
00:25:14,559 --> 00:25:16,320
and basically what it means is that the

743
00:25:16,320 --> 00:25:17,600
processor has two

744
00:25:17,600 --> 00:25:19,760
modes of operation you know one is user

745
00:25:19,760 --> 00:25:22,400
mode and the other one is kernel mode

746
00:25:22,400 --> 00:25:25,440
and when running in kernel mode

747
00:25:25,440 --> 00:25:27,679
the cpu can execute privilege

748
00:25:27,679 --> 00:25:35,269
instructions

749
00:25:35,279 --> 00:25:37,600
i'll come back to the in a second it out

750
00:25:37,600 --> 00:25:39,520
when running in user mode

751
00:25:39,520 --> 00:25:42,240
the cpu can only execute in unprivileged

752
00:25:42,240 --> 00:25:49,830
instructions

753
00:25:49,840 --> 00:25:51,520
and um structures are the instructions

754
00:25:51,520 --> 00:25:52,960
you're well familiar with you know

755
00:25:52,960 --> 00:25:55,919
think about like add sub you know adding

756
00:25:55,919 --> 00:25:56,240
the

757
00:25:56,240 --> 00:25:57,600
two registers together you know

758
00:25:57,600 --> 00:25:59,120
subtracting through register so it's

759
00:25:59,120 --> 00:25:59,919
really basic

760
00:25:59,919 --> 00:26:02,240
you know you know procedure calls you

761
00:26:02,240 --> 00:26:03,360
know jr

762
00:26:03,360 --> 00:26:05,440
all that kind of stuff branches you know

763
00:26:05,440 --> 00:26:07,360
those are all

764
00:26:07,360 --> 00:26:09,600
uh privilege instructions that any user

765
00:26:09,600 --> 00:26:11,919
application is allowed to execute

766
00:26:11,919 --> 00:26:14,240
privileged instructions are structured

767
00:26:14,240 --> 00:26:15,039
basically

768
00:26:15,039 --> 00:26:18,159
are involved in manipulating the

769
00:26:18,159 --> 00:26:19,360
hardware directly

770
00:26:19,360 --> 00:26:21,600
setting up protections and things like

771
00:26:21,600 --> 00:26:23,120
that so for example setting up a page

772
00:26:23,120 --> 00:26:27,350
table register

773
00:26:27,360 --> 00:26:31,750
which we'll talk about later or

774
00:26:31,760 --> 00:26:39,200
you know disabling clock interrupts

775
00:26:39,200 --> 00:26:40,400
and so there's all kinds of sort of

776
00:26:40,400 --> 00:26:42,320
state on the processor that the

777
00:26:42,320 --> 00:26:43,760
operating system you know is tended to

778
00:26:43,760 --> 00:26:44,480
use

779
00:26:44,480 --> 00:26:46,480
and manipulating that state is you know

780
00:26:46,480 --> 00:26:48,000
completely uh

781
00:26:48,000 --> 00:26:50,320
is done for privileged instructions and

782
00:26:50,320 --> 00:26:52,400
so for example when a user application

783
00:26:52,400 --> 00:26:54,080
tries to actually execute a privileged

784
00:26:54,080 --> 00:26:56,240
instruction uh then the

785
00:26:56,240 --> 00:26:57,919
processor voltage won't execute it

786
00:26:57,919 --> 00:26:59,440
because if a critical instruction in

787
00:26:59,440 --> 00:27:01,039
user mode is disallowed

788
00:27:01,039 --> 00:27:03,440
and basically that will result in the

789
00:27:03,440 --> 00:27:04,720
transfer control

790
00:27:04,720 --> 00:27:06,720
from user space from user mode to kernel

791
00:27:06,720 --> 00:27:08,080
mode so that then the operating system

792
00:27:08,080 --> 00:27:09,600
can actually take control and maybe if i

793
00:27:09,600 --> 00:27:11,039
kill the application because it's

794
00:27:11,039 --> 00:27:14,799
misbehaving to get a little bit of a

795
00:27:14,799 --> 00:27:15,679
sense

796
00:27:15,679 --> 00:27:17,279
uh the difference between the two and

797
00:27:17,279 --> 00:27:18,399
the privilege and imprivillage

798
00:27:18,399 --> 00:27:20,080
instructions

799
00:27:20,080 --> 00:27:23,120
let me switch display for a second and

800
00:27:23,120 --> 00:27:24,720
here on the right side you have the

801
00:27:24,720 --> 00:27:25,840
display

802
00:27:25,840 --> 00:27:29,039
is a document you know the risk 5

803
00:27:29,039 --> 00:27:31,840
privilege architecture document and that

804
00:27:31,840 --> 00:27:33,440
document contains all the previous

805
00:27:33,440 --> 00:27:34,000
instructions

806
00:27:34,000 --> 00:27:36,640
you know it's linked from the website uh

807
00:27:36,640 --> 00:27:37,120
under

808
00:27:37,120 --> 00:27:40,399
the references page and in the

809
00:27:40,399 --> 00:27:42,960
next couple of weeks uh you know or

810
00:27:42,960 --> 00:27:43,840
almost months

811
00:27:43,840 --> 00:27:45,520
you know you will be playing around you

812
00:27:45,520 --> 00:27:47,200
know all these prisoners instructions

813
00:27:47,200 --> 00:27:49,279
that you know are

814
00:27:49,279 --> 00:27:51,600
shown here and in fact many of them will

815
00:27:51,600 --> 00:27:52,799
you know show up and

816
00:27:52,799 --> 00:27:54,000
some of them will actually show up in

817
00:27:54,000 --> 00:27:55,360
the next lecture in a great amount of

818
00:27:55,360 --> 00:27:56,559
detail

819
00:27:56,559 --> 00:27:58,960
but users think about this as there are

820
00:27:58,960 --> 00:28:00,399
previous instructions that user

821
00:28:00,399 --> 00:28:01,520
applications should not be able to

822
00:28:01,520 --> 00:28:02,320
execute

823
00:28:02,320 --> 00:28:04,159
and those can only be executed in kernel

824
00:28:04,159 --> 00:28:05,760
mode

825
00:28:05,760 --> 00:28:08,559
so that's one aspect of you know this

826
00:28:08,559 --> 00:28:10,000
sort of hardware support for strong

827
00:28:10,000 --> 00:28:13,669
isolation

828
00:28:13,679 --> 00:28:16,960
just a quick question like the

829
00:28:16,960 --> 00:28:18,399
what i'm imagining in my head is

830
00:28:18,399 --> 00:28:20,159
something like if kernel mode

831
00:28:20,159 --> 00:28:23,760
allow else don't like what who is

832
00:28:23,760 --> 00:28:25,520
running that code and checking if it's

833
00:28:25,520 --> 00:28:27,039
current mode and how do they know if

834
00:28:27,039 --> 00:28:28,080
it's in kernel mode

835
00:28:28,080 --> 00:28:30,159
is it like a flag or something yeah it's

836
00:28:30,159 --> 00:28:31,840
basically a flag in the processor

837
00:28:31,840 --> 00:28:34,240
you know literally there's a bit in the

838
00:28:34,240 --> 00:28:36,080
processor that says you know your

839
00:28:36,080 --> 00:28:39,279
user mode you know one is saying uh

840
00:28:39,279 --> 00:28:41,120
typically one is user mode and zero is

841
00:28:41,120 --> 00:28:42,320
kernel mode

842
00:28:42,320 --> 00:28:44,000
and so when the processor decodes an

843
00:28:44,000 --> 00:28:46,480
instruction uh looks at the op code

844
00:28:46,480 --> 00:28:47,840
if the op code is a privilege

845
00:28:47,840 --> 00:28:49,760
instruction and the

846
00:28:49,760 --> 00:28:51,760
bit is set to one and will deny

847
00:28:51,760 --> 00:28:54,240
executing that instruction

848
00:28:54,240 --> 00:28:56,799
it's like divided by zero you're not

849
00:28:56,799 --> 00:28:58,159
allowed to do that

850
00:28:58,159 --> 00:29:00,559
okay but if that bit has changed like if

851
00:29:00,559 --> 00:29:01,360
some way you

852
00:29:01,360 --> 00:29:03,440
you were just able to overwrite that bit

853
00:29:03,440 --> 00:29:05,919
then that's the only thing controlling

854
00:29:05,919 --> 00:29:07,919
yeah so what do you think what the

855
00:29:07,919 --> 00:29:09,919
instruction that overrides a bit is that

856
00:29:09,919 --> 00:29:11,600
a prefix instructor or an unprivileged

857
00:29:11,600 --> 00:29:19,269
instruction

858
00:29:19,279 --> 00:29:22,870
is it a question

859
00:29:22,880 --> 00:29:24,880
clearly you know the the instruction

860
00:29:24,880 --> 00:29:26,159
that you know sets the bit

861
00:29:26,159 --> 00:29:27,679
must be a previous instruction because

862
00:29:27,679 --> 00:29:29,520
the user application should not be able

863
00:29:29,520 --> 00:29:31,279
to set the bit to kernel mode correct

864
00:29:31,279 --> 00:29:33,120
and then you know be able to actually

865
00:29:33,120 --> 00:29:34,640
uh run all kinds of preflight

866
00:29:34,640 --> 00:29:36,640
instructions and so that bit is

867
00:29:36,640 --> 00:29:39,039
protected

868
00:29:39,039 --> 00:29:44,149
does that make sense okay yeah

869
00:29:44,159 --> 00:29:46,559
um okay good so uh so let's use the

870
00:29:46,559 --> 00:29:48,080
kernel mode or at least you know

871
00:29:48,080 --> 00:29:50,559
the top view of the kernel mode it turns

872
00:29:50,559 --> 00:29:52,080
out the risk five has a

873
00:29:52,080 --> 00:29:53,919
as a number of you asked about has a

874
00:29:53,919 --> 00:29:55,919
third mode called machine mode

875
00:29:55,919 --> 00:29:58,320
uh we're mostly going to ignore that and

876
00:29:58,320 --> 00:30:00,080
so i'm not going to much say about it

877
00:30:00,080 --> 00:30:01,600
basically there's one more left because

878
00:30:01,600 --> 00:30:03,039
basically three levels of privileges

879
00:30:03,039 --> 00:30:05,120
instead of two level three figures

880
00:30:05,120 --> 00:30:08,880
i'm here go ahead right so i'm wondering

881
00:30:08,880 --> 00:30:11,120
with respect to security if

882
00:30:11,120 --> 00:30:13,600
all user code does go through the kernel

883
00:30:13,600 --> 00:30:15,520
the intent is that things are secure

884
00:30:15,520 --> 00:30:19,360
but is there a way for uh a user of the

885
00:30:19,360 --> 00:30:20,480
computer

886
00:30:20,480 --> 00:30:23,440
to completely uh go around the operating

887
00:30:23,440 --> 00:30:25,200
system

888
00:30:25,200 --> 00:30:28,559
no not really at least you know if done

889
00:30:28,559 --> 00:30:29,200
carefully

890
00:30:29,200 --> 00:30:32,630
not

891
00:30:32,640 --> 00:30:34,399
and if possible like you know that might

892
00:30:34,399 --> 00:30:36,000
be the case that some programs have

893
00:30:36,000 --> 00:30:37,520
additional privileges

894
00:30:37,520 --> 00:30:39,919
uh that the operating system will uh

895
00:30:39,919 --> 00:30:40,960
respect

896
00:30:40,960 --> 00:30:42,799
uh but those privileges are not given to

897
00:30:42,799 --> 00:30:45,039
every user you know example only the

898
00:30:45,039 --> 00:30:47,120
root user has certain privileges that

899
00:30:47,120 --> 00:30:48,320
allow you to do

900
00:30:48,320 --> 00:30:51,120
uh security sensitive operations what

901
00:30:51,120 --> 00:30:52,240
about bios

902
00:30:52,240 --> 00:30:55,440
does bias happen before os or

903
00:30:55,440 --> 00:30:59,360
after yeah so the bios this is the

904
00:30:59,360 --> 00:31:01,200
the piece of software that basically

905
00:31:01,200 --> 00:31:03,279
comes with the computer

906
00:31:03,279 --> 00:31:06,240
and that's booted first and now the buys

907
00:31:06,240 --> 00:31:08,000
basically boots the operating system

908
00:31:08,000 --> 00:31:11,279
uh so the bios is a trusted pieces code

909
00:31:11,279 --> 00:31:13,519
that better be correct and better be not

910
00:31:13,519 --> 00:31:16,950
malicious

911
00:31:16,960 --> 00:31:20,799
noah go ahead uh yeah so you mentioned

912
00:31:20,799 --> 00:31:21,760
that the uh

913
00:31:21,760 --> 00:31:24,640
you know the um instruction to set the

914
00:31:24,640 --> 00:31:25,919
uh the kernel mode bit

915
00:31:25,919 --> 00:31:28,399
is a privileged instruction how would a

916
00:31:28,399 --> 00:31:29,360
user program

917
00:31:29,360 --> 00:31:32,480
ever then be able to you know get like

918
00:31:32,480 --> 00:31:34,000
like you know essentially have the

919
00:31:34,000 --> 00:31:36,000
kernel execute any kernel instructions

920
00:31:36,000 --> 00:31:36,480
if

921
00:31:36,480 --> 00:31:38,640
like the very instruction to access

922
00:31:38,640 --> 00:31:39,519
kernel mode

923
00:31:39,519 --> 00:31:40,960
is itself a privileged instruction i

924
00:31:40,960 --> 00:31:42,640
guess it seems like there's immediately

925
00:31:42,640 --> 00:31:44,159
a barrier for a user program

926
00:31:44,159 --> 00:31:47,200
ever changing that bit yeah yeah uh

927
00:31:47,200 --> 00:31:48,320
that's correct and

928
00:31:48,320 --> 00:31:49,600
that's exactly the way we want it

929
00:31:49,600 --> 00:31:52,080
correct uh so one way to think about it

930
00:31:52,080 --> 00:31:53,919
and this is not exactly how it works in

931
00:31:53,919 --> 00:31:55,840
on the risk five but like if you

932
00:31:55,840 --> 00:31:57,840
execute a previous instruction in user

933
00:31:57,840 --> 00:31:59,200
space would try to execute

934
00:31:59,200 --> 00:33:08,149
a privileged instruction

935
00:33:08,159 --> 00:33:10,559
i'm back sorry about that it looked like

936
00:33:10,559 --> 00:33:11,600
my

937
00:33:11,600 --> 00:33:15,840
zoom client uh crashed uh on me

938
00:33:15,840 --> 00:33:18,799
uh i apologize for that i don't really

939
00:33:18,799 --> 00:33:20,080
know why

940
00:33:20,080 --> 00:33:25,519
but it did um

941
00:33:25,519 --> 00:33:28,240
can everybody hear me again yep you're

942
00:33:28,240 --> 00:33:28,880
good

943
00:33:28,880 --> 00:33:32,159
all good all right well

944
00:33:32,159 --> 00:33:35,909
they're somewhere a bug

945
00:33:35,919 --> 00:33:39,039
okay so back to

946
00:33:39,039 --> 00:33:42,559
uh back to

947
00:33:42,559 --> 00:33:45,440
uh the second piece of hardware support

948
00:33:45,440 --> 00:33:47,360
which almost all cpus provide

949
00:33:47,360 --> 00:33:50,559
uh which cpus provide

950
00:33:50,559 --> 00:34:02,710
virtual memory

951
00:34:02,720 --> 00:34:04,000
and i'm going to talk about this on

952
00:34:04,000 --> 00:34:06,240
wednesday much much more

953
00:34:06,240 --> 00:34:08,720
detail but basically the process has

954
00:34:08,720 --> 00:34:10,000
something you know what it's called the

955
00:34:10,000 --> 00:34:12,079
page table

956
00:34:12,079 --> 00:34:13,679
and you've seen this a little bit i

957
00:34:13,679 --> 00:34:15,839
think in double o4 and the page bagel

958
00:34:15,839 --> 00:34:16,399
basically

959
00:34:16,399 --> 00:34:21,440
maps virtual addresses

960
00:34:21,440 --> 00:34:25,270
to physical addresses

961
00:34:25,280 --> 00:34:27,040
and the basic idea is to give every

962
00:34:27,040 --> 00:34:28,639
process

963
00:34:28,639 --> 00:34:34,240
its own page table

964
00:34:34,240 --> 00:34:38,159
and in this way you know the

965
00:34:38,159 --> 00:34:40,240
the process can actually only use or is

966
00:34:40,240 --> 00:34:41,760
only allowed to access that piece of

967
00:34:41,760 --> 00:34:43,280
physical memory that actually shows up

968
00:34:43,280 --> 00:34:44,639
in this page table

969
00:34:44,639 --> 00:34:46,079
and so if you set up if the operating

970
00:34:46,079 --> 00:34:48,320
system sets the page tables up in a way

971
00:34:48,320 --> 00:34:51,359
that uh every uh process has disjoined

972
00:34:51,359 --> 00:34:52,480
you know physical memory

973
00:34:52,480 --> 00:34:54,159
then a process can't even access you

974
00:34:54,159 --> 00:34:55,760
know somebody else's physical memory

975
00:34:55,760 --> 00:34:57,440
because it's not even in its page tables

976
00:34:57,440 --> 00:34:58,880
so there's nothing like no way even to

977
00:34:58,880 --> 00:35:00,160
create an address or

978
00:35:00,160 --> 00:35:02,079
write down an address that will allow a

979
00:35:02,079 --> 00:35:04,240
process to access somebody else's

980
00:35:04,240 --> 00:35:06,160
physical memory and so this gives us

981
00:35:06,160 --> 00:35:09,910
strong memory isolation

982
00:35:09,920 --> 00:35:12,960
basically page stable defines a view on

983
00:35:12,960 --> 00:35:13,520
memory

984
00:35:13,520 --> 00:35:16,640
and every where the user process has

985
00:35:16,640 --> 00:35:19,119
its own view of memory independent of

986
00:35:19,119 --> 00:35:20,160
each other

987
00:35:20,160 --> 00:35:22,320
and this gives us very strong memory

988
00:35:22,320 --> 00:35:24,320
isolation

989
00:35:24,320 --> 00:35:26,079
and so now what we can do if we can

990
00:35:26,079 --> 00:35:27,760
think a little bit in this way

991
00:35:27,760 --> 00:35:30,720
then we can redraw the picture a little

992
00:35:30,720 --> 00:35:31,680
bit earlier

993
00:35:31,680 --> 00:35:32,880
and because we think about this as

994
00:35:32,880 --> 00:35:35,520
follows you know we have a box

995
00:35:35,520 --> 00:35:38,560
yeah and ls sits in that box and we have

996
00:35:38,560 --> 00:35:39,440
another box

997
00:35:39,440 --> 00:35:43,680
and you know echo sits in that box

998
00:35:43,680 --> 00:35:45,680
and that box basically has an address a

999
00:35:45,680 --> 00:35:47,359
virtual address range starting from zero

1000
00:35:47,359 --> 00:35:49,359
to like whatever some number two to the

1001
00:35:49,359 --> 00:35:50,800
power whatever the

1002
00:35:50,800 --> 00:35:53,520
number is uh in risk five which we'll

1003
00:35:53,520 --> 00:35:54,560
talk about on

1004
00:35:54,560 --> 00:35:56,880
on wednesday and similarly you know the

1005
00:35:56,880 --> 00:35:58,640
dress range for echo is you know

1006
00:35:58,640 --> 00:35:59,119
something

1007
00:35:59,119 --> 00:36:00,560
whatever it's saying to to the

1008
00:36:00,560 --> 00:36:02,880
powershell max and so

1009
00:36:02,880 --> 00:36:05,839
uh ls has a member location zero echo

1010
00:36:05,839 --> 00:36:07,760
has a location like a zero and you just

1011
00:36:07,760 --> 00:36:08,880
completely separate it

1012
00:36:08,880 --> 00:36:10,720
and if the operating system maps those

1013
00:36:10,720 --> 00:36:12,079
virtual addresses zero to different

1014
00:36:12,079 --> 00:36:13,839
pieces of physical addresses

1015
00:36:13,839 --> 00:36:16,000
then basically ls cannot access echo's

1016
00:36:16,000 --> 00:36:18,960
memory and echo cannot access ls memory

1017
00:36:18,960 --> 00:36:20,160
and similarly you know the kernel

1018
00:36:20,160 --> 00:36:22,400
actually you know sits below it

1019
00:36:22,400 --> 00:36:24,160
you know also has his own at least an

1020
00:36:24,160 --> 00:36:25,440
xv6 has his own

1021
00:36:25,440 --> 00:36:27,680
address range independent of the

1022
00:36:27,680 --> 00:36:29,040
applications

1023
00:36:29,040 --> 00:36:30,960
and we can think about the user kernel

1024
00:36:30,960 --> 00:36:32,400
mode as sort of sitting

1025
00:36:32,400 --> 00:36:34,720
in between you know the boundary uh you

1026
00:36:34,720 --> 00:36:36,720
know things that actually run

1027
00:36:36,720 --> 00:36:40,880
in user space running user mode

1028
00:36:40,880 --> 00:36:42,480
and things that sit in the kernel run in

1029
00:36:42,480 --> 00:36:47,430
kernel mode

1030
00:36:47,440 --> 00:36:48,800
and that's sort of the picture you know

1031
00:36:48,800 --> 00:36:50,400
that you should answer like the os you

1032
00:36:50,400 --> 00:36:51,920
know sits there you know sitting in

1033
00:36:51,920 --> 00:36:52,880
kernel mode

1034
00:36:52,880 --> 00:36:54,400
and so this is the picture that you

1035
00:36:54,400 --> 00:36:56,480
should have in your head

1036
00:36:56,480 --> 00:36:58,640
now as described so far this picture is

1037
00:36:58,640 --> 00:36:59,760
a little bit too strict

1038
00:36:59,760 --> 00:37:01,200
you know we have basically put

1039
00:37:01,200 --> 00:37:02,880
everything in the box but there's no way

1040
00:37:02,880 --> 00:37:04,640
for one box to transfer control to

1041
00:37:04,640 --> 00:37:05,680
another box

1042
00:37:05,680 --> 00:37:07,119
and clearly when that needs to happen

1043
00:37:07,119 --> 00:37:08,880
right because for example als you know

1044
00:37:08,880 --> 00:37:10,240
probably wants to call

1045
00:37:10,240 --> 00:37:13,440
you know reit the read system call or

1046
00:37:13,440 --> 00:37:14,960
write system call

1047
00:37:14,960 --> 00:37:16,720
or maybe you know whatever the shell

1048
00:37:16,720 --> 00:37:18,800
wants to call fork or an exit

1049
00:37:18,800 --> 00:37:21,359
and so there has to be a way for an

1050
00:37:21,359 --> 00:37:22,000
application

1051
00:37:22,000 --> 00:37:24,160
or user application to transfer control

1052
00:37:24,160 --> 00:37:26,160
in a coordinated manner

1053
00:37:26,160 --> 00:37:28,720
to the kernel so that the kernel can

1054
00:37:28,720 --> 00:37:31,829
actually provide services

1055
00:37:31,839 --> 00:37:34,480
and so there's a plan basically in

1056
00:37:34,480 --> 00:37:35,520
addition to this

1057
00:37:35,520 --> 00:37:36,800
two pieces of hardware support that i

1058
00:37:36,800 --> 00:37:39,520
talked so far talked about so far

1059
00:37:39,520 --> 00:37:42,960
is a way of controlled way of entering

1060
00:37:42,960 --> 00:37:49,430
the kernel

1061
00:37:49,440 --> 00:37:51,599
it turns out actually on risk five uh

1062
00:37:51,599 --> 00:37:53,440
there is a an instruction

1063
00:37:53,440 --> 00:37:55,680
uh for this it's called the e-call

1064
00:37:55,680 --> 00:37:57,920
instruction

1065
00:37:57,920 --> 00:37:59,599
and the e-call instruction takes one

1066
00:37:59,599 --> 00:38:02,079
argument a number

1067
00:38:02,079 --> 00:38:04,640
and so in a user application that wants

1068
00:38:04,640 --> 00:38:06,560
to transfer control into the kernel

1069
00:38:06,560 --> 00:38:07,760
basically can call the e-call

1070
00:38:07,760 --> 00:38:09,520
instruction with a number it's like two

1071
00:38:09,520 --> 00:38:10,880
or three or four or five

1072
00:38:10,880 --> 00:38:12,800
and that number basically is the system

1073
00:38:12,800 --> 00:38:14,880
call number

1074
00:38:14,880 --> 00:38:21,750
that the application wants to invoke

1075
00:38:21,760 --> 00:38:23,599
and that uh basically what that does it

1076
00:38:23,599 --> 00:38:25,040
actually enters the kernel at a

1077
00:38:25,040 --> 00:38:25,920
particular

1078
00:38:25,920 --> 00:38:28,880
uh point uh or a particular location in

1079
00:38:28,880 --> 00:38:30,160
the cont

1080
00:38:30,160 --> 00:38:31,760
in the kernel that's controlled by the

1081
00:38:31,760 --> 00:38:34,560
kernel and as we'll see in xv6

1082
00:38:34,560 --> 00:38:37,520
uh in some later lectures uh you know

1083
00:38:37,520 --> 00:38:39,040
there's basically a single

1084
00:38:39,040 --> 00:38:42,720
system called entry point and um

1085
00:38:42,720 --> 00:38:44,320
and every time an application calls

1086
00:38:44,320 --> 00:38:46,000
e-call you know the application

1087
00:38:46,000 --> 00:38:47,280
enters the kernel of that particular

1088
00:38:47,280 --> 00:38:49,280
point so one

1089
00:38:49,280 --> 00:38:51,520
um so one way to think about this is

1090
00:38:51,520 --> 00:38:53,760
that if you have fork

1091
00:38:53,760 --> 00:38:56,880
you know fork you know call in user

1092
00:38:56,880 --> 00:38:58,480
space for example the shell or your

1093
00:38:58,480 --> 00:38:59,200
prangs

1094
00:38:59,200 --> 00:39:01,280
program called fork well whatever it

1095
00:39:01,280 --> 00:39:02,960
calls fork it doesn't really call the

1096
00:39:02,960 --> 00:39:04,640
operating system directly you know the

1097
00:39:04,640 --> 00:39:06,720
corresponding function in the kernel

1098
00:39:06,720 --> 00:39:08,640
instead you know what it does it

1099
00:39:08,640 --> 00:39:11,750
actually calls an e-call

1100
00:39:11,760 --> 00:39:15,200
with you know the number for a fork

1101
00:39:15,200 --> 00:39:18,400
which you know and then that actually

1102
00:39:18,400 --> 00:39:20,720
jumps into the kernel

1103
00:39:20,720 --> 00:39:23,200
so this is a kernel transition and

1104
00:39:23,200 --> 00:39:24,960
there's the user side here's the kernel

1105
00:39:24,960 --> 00:39:25,920
side

1106
00:39:25,920 --> 00:39:28,400
and then on the kernel side you know

1107
00:39:28,400 --> 00:39:30,000
there's a function called syscall

1108
00:39:30,000 --> 00:39:33,200
in cisco.c and that basically every

1109
00:39:33,200 --> 00:39:34,480
system call will end up

1110
00:39:34,480 --> 00:39:36,320
at that particular system call function

1111
00:39:36,320 --> 00:39:37,680
and the system call will look at the

1112
00:39:37,680 --> 00:39:38,400
number

1113
00:39:38,400 --> 00:39:39,839
and then decide and the number is

1114
00:39:39,839 --> 00:39:41,280
actually passed in the register i think

1115
00:39:41,280 --> 00:39:43,200
it's a0

1116
00:39:43,200 --> 00:39:45,040
and it's just called can look at that

1117
00:39:45,040 --> 00:39:46,800
register look at a0

1118
00:39:46,800 --> 00:39:48,240
see what the number is and then for

1119
00:39:48,240 --> 00:39:52,950
example call the forex system call

1120
00:39:52,960 --> 00:39:54,800
and so just to make a little clear so

1121
00:39:54,800 --> 00:39:56,079
this is this hard boundary

1122
00:39:56,079 --> 00:39:58,640
between the user and kernel so the user

1123
00:39:58,640 --> 00:39:59,440
cannot

1124
00:39:59,440 --> 00:40:03,119
call you know the disks for directly

1125
00:40:03,119 --> 00:40:04,880
you know the only way you know user

1126
00:40:04,880 --> 00:40:06,800
application can actually invoke you know

1127
00:40:06,800 --> 00:40:08,319
the system call for fork

1128
00:40:08,319 --> 00:40:09,440
is actually through this e-coll

1129
00:40:09,440 --> 00:40:12,470
instruction

1130
00:40:12,480 --> 00:40:18,710
and so i have another

1131
00:40:18,720 --> 00:40:22,710
if i have another

1132
00:40:22,720 --> 00:40:27,670
another system called let's say right

1133
00:40:27,680 --> 00:40:29,119
it does something similar you know the

1134
00:40:29,119 --> 00:40:31,760
right uh system called cannot call

1135
00:40:31,760 --> 00:40:33,839
you know the right you know code

1136
00:40:33,839 --> 00:40:35,040
directly into the kernel

1137
00:40:35,040 --> 00:40:37,599
instead uh what it does it calls what's

1138
00:40:37,599 --> 00:40:38,319
these these

1139
00:40:38,319 --> 00:40:41,119
these little rappers are called uh

1140
00:40:41,119 --> 00:40:44,480
system call stops and we'll call ecall

1141
00:40:44,480 --> 00:40:46,000
a function called write that actually

1142
00:40:46,000 --> 00:40:47,599
execute the equal instruction you know

1143
00:40:47,599 --> 00:40:50,319
with the argument you know says right

1144
00:40:50,319 --> 00:40:51,920
to indicate you know the write system

1145
00:40:51,920 --> 00:40:53,920
call and add again you know transcript

1146
00:40:53,920 --> 00:40:55,520
control to syscall

1147
00:40:55,520 --> 00:40:58,960
and then syscall uh can actually

1148
00:40:58,960 --> 00:41:01,119
uh view multiplexing to the right system

1149
00:41:01,119 --> 00:41:02,560
call for two

1150
00:41:02,560 --> 00:41:09,349
questions please go ahead

1151
00:41:09,359 --> 00:41:12,800
um so i think my hand was off

1152
00:41:12,800 --> 00:41:16,000
okay i can go ahead um um

1153
00:41:16,000 --> 00:41:19,119
the question i had was um how does

1154
00:41:19,119 --> 00:41:23,040
or where does the kernel check um

1155
00:41:23,040 --> 00:41:26,079
for for example fork or write if it is

1156
00:41:26,079 --> 00:41:27,520
allowed or not

1157
00:41:27,520 --> 00:41:29,680
um right now you're just passing in like

1158
00:41:29,680 --> 00:41:31,680
you know you're just calling ecall and

1159
00:41:31,680 --> 00:41:33,280
the system call number

1160
00:41:33,280 --> 00:41:35,440
but where does the kernel basically

1161
00:41:35,440 --> 00:41:37,359
decide whether this application

1162
00:41:37,359 --> 00:41:39,599
should be able to invoke this particular

1163
00:41:39,599 --> 00:41:41,440
uh kernel syscall

1164
00:41:41,440 --> 00:41:43,680
yeah so a great question so in principle

1165
00:41:43,680 --> 00:41:45,920
the on the kernel side correct when we

1166
00:41:45,920 --> 00:41:46,800
actually spark

1167
00:41:46,800 --> 00:41:49,599
call runs i can implement any secure

1168
00:41:49,599 --> 00:41:51,119
check it wants you know i can look at

1169
00:41:51,119 --> 00:41:52,640
the arguments you know of the system

1170
00:41:52,640 --> 00:41:53,280
call

1171
00:41:53,280 --> 00:41:54,560
and decide whether actually the

1172
00:41:54,560 --> 00:41:56,560
application should be allowed to execute

1173
00:41:56,560 --> 00:41:58,000
the system call fork

1174
00:41:58,000 --> 00:42:01,040
now in user in unix any application can

1175
00:42:01,040 --> 00:42:02,319
actually call farc

1176
00:42:02,319 --> 00:42:04,240
but let's say you take write you know

1177
00:42:04,240 --> 00:42:05,520
right you know needs to check

1178
00:42:05,520 --> 00:42:07,920
whether uh the implementation of write

1179
00:42:07,920 --> 00:42:09,599
needs to check whether the address that

1180
00:42:09,599 --> 00:42:10,560
is actually passed

1181
00:42:10,560 --> 00:42:13,920
into right actually is a part of the

1182
00:42:13,920 --> 00:42:15,760
user applications

1183
00:42:15,760 --> 00:42:17,520
and so that you know the kernel is not

1184
00:42:17,520 --> 00:42:18,880
tricked to

1185
00:42:18,880 --> 00:42:22,000
writing data for somewhere else it

1186
00:42:22,000 --> 00:42:23,040
actually doesn't belong to the

1187
00:42:23,040 --> 00:42:25,599
application

1188
00:42:25,599 --> 00:42:30,319
they're more hints you know please ask

1189
00:42:30,319 --> 00:42:33,040
uh yeah i had a quick question um so how

1190
00:42:33,040 --> 00:42:33,440
does

1191
00:42:33,440 --> 00:42:36,240
the kernel seize back control from a

1192
00:42:36,240 --> 00:42:37,440
user application

1193
00:42:37,440 --> 00:42:39,520
in the case where the user application

1194
00:42:39,520 --> 00:42:40,640
is acting maliciously

1195
00:42:40,640 --> 00:42:43,839
or it's in an infinite loop yeah so the

1196
00:42:43,839 --> 00:42:45,920
way the plan for that and again we're

1197
00:42:45,920 --> 00:42:46,960
going to talk about in much more detail

1198
00:42:46,960 --> 00:42:47,839
in a couple weeks

1199
00:42:47,839 --> 00:42:50,480
uh is that the kernel actually programs

1200
00:42:50,480 --> 00:42:51,920
the hardware to

1201
00:42:51,920 --> 00:42:55,520
set a timer and uh after the timer goes

1202
00:42:55,520 --> 00:42:56,160
off

1203
00:42:56,160 --> 00:42:58,880
uh that will cause a transfer from usage

1204
00:42:58,880 --> 00:43:00,400
space to kernel mode so at that point

1205
00:43:00,400 --> 00:43:02,240
the kernel isn't backing control

1206
00:43:02,240 --> 00:43:04,480
and then the kernel can reschedule uh

1207
00:43:04,480 --> 00:43:05,760
the cpu to another

1208
00:43:05,760 --> 00:43:09,599
uh process okay make sense thank you

1209
00:43:09,599 --> 00:43:11,200
yeah and we'll see that the exact

1210
00:43:11,200 --> 00:43:12,720
details you know we'll

1211
00:43:12,720 --> 00:43:15,839
see in a little while you have one more

1212
00:43:15,839 --> 00:43:18,790
questions

1213
00:43:18,800 --> 00:43:20,319
yeah so this is more of a high level

1214
00:43:20,319 --> 00:43:22,240
question but what drives

1215
00:43:22,240 --> 00:43:25,599
the designers of an operating system's

1216
00:43:25,599 --> 00:43:29,040
implementation to use a language like c

1217
00:43:29,040 --> 00:43:32,319
ah okay so great question

1218
00:43:32,319 --> 00:43:36,720
um she gives you a lot of control

1219
00:43:36,720 --> 00:43:40,720
over hardware and so uh

1220
00:43:40,720 --> 00:43:42,400
so example you know you need to program

1221
00:43:42,400 --> 00:43:44,800
the timer chip uh

1222
00:43:44,800 --> 00:43:47,599
the in c that is actually easy to do uh

1223
00:43:47,599 --> 00:43:48,960
because you get a lot of low level

1224
00:43:48,960 --> 00:43:50,400
control over

1225
00:43:50,400 --> 00:43:52,640
any hardware resource and partly because

1226
00:43:52,640 --> 00:43:56,079
you can cast anything to anything

1227
00:43:56,079 --> 00:43:58,800
and so c is basically very convenient

1228
00:43:58,800 --> 00:44:00,400
program language if you have to do very

1229
00:44:00,400 --> 00:44:01,760
low level programming

1230
00:44:01,760 --> 00:44:06,630
particularly interacting with hardware

1231
00:44:06,640 --> 00:44:08,000
it doesn't mean you can't do it in other

1232
00:44:08,000 --> 00:44:09,839
languages uh but this is historically

1233
00:44:09,839 --> 00:44:12,880
the reason why ce has been successful

1234
00:44:12,880 --> 00:44:16,640
i see thanks why is c so much more

1235
00:44:16,640 --> 00:44:17,920
popular than uh

1236
00:44:17,920 --> 00:44:20,800
c plus only for historic reasons in like

1237
00:44:20,800 --> 00:44:22,800
these kinds of applications

1238
00:44:22,800 --> 00:44:26,079
or uh is there uh any other reason that

1239
00:44:26,079 --> 00:44:26,560
like

1240
00:44:26,560 --> 00:44:29,359
no like most os don't haven't adopted c

1241
00:44:29,359 --> 00:44:30,480
plus plus

1242
00:44:30,480 --> 00:44:31,920
yeah so most operating system you know

1243
00:44:31,920 --> 00:44:33,119
there are i think operating systems

1244
00:44:33,119 --> 00:44:34,400
written in c plus plus

1245
00:44:34,400 --> 00:44:36,319
uh totally possible probably the most

1246
00:44:36,319 --> 00:44:37,920
ones that you know you know

1247
00:44:37,920 --> 00:44:40,640
are not written in c plus plus uh and

1248
00:44:40,640 --> 00:44:41,920
the various reasons for it

1249
00:44:41,920 --> 00:44:45,119
uh you know linux is mostly c or no c

1250
00:44:45,119 --> 00:44:46,560
plus plus nothing partially because

1251
00:44:46,560 --> 00:44:48,839
linus just doesn't like c

1252
00:44:48,839 --> 00:44:54,550
plus

1253
00:44:54,560 --> 00:45:04,240
any other questions

1254
00:45:04,240 --> 00:45:06,800
okay so so in this view of the world

1255
00:45:06,800 --> 00:45:07,599
right where

1256
00:45:07,599 --> 00:45:09,599
uh you know we have a way of

1257
00:45:09,599 --> 00:45:10,640
transferring control

1258
00:45:10,640 --> 00:45:13,359
into uh the operating system using uh

1259
00:45:13,359 --> 00:45:15,839
system calls or this e-call instruction

1260
00:45:15,839 --> 00:45:18,720
uh and so the kernel is now responsible

1261
00:45:18,720 --> 00:45:19,599
for

1262
00:45:19,599 --> 00:45:21,680
uh implementing actually the the actual

1263
00:45:21,680 --> 00:45:22,880
functions and

1264
00:45:22,880 --> 00:45:25,040
ensuring uh you know checking arguments

1265
00:45:25,040 --> 00:45:26,480
and things like that to make sure that

1266
00:45:26,480 --> 00:45:27,839
you know the

1267
00:45:27,839 --> 00:45:29,440
uh it's not being tricked in something

1268
00:45:29,440 --> 00:45:30,960
uh doing something badly

1269
00:45:30,960 --> 00:45:33,040
and so in this view of the world the

1270
00:45:33,040 --> 00:45:37,109
kernel is sometimes called

1271
00:45:37,119 --> 00:45:46,960
you know it's the trusted computing base

1272
00:45:46,960 --> 00:45:48,720
sometimes called in security terms the

1273
00:45:48,720 --> 00:45:50,480
tcp

1274
00:45:50,480 --> 00:45:53,520
um and you know basically you know what

1275
00:45:53,520 --> 00:45:54,960
does it mean for it to be the trusted

1276
00:45:54,960 --> 00:45:56,160
computing mix well

1277
00:45:56,160 --> 00:45:57,839
it must be correct you know kernels must

1278
00:45:57,839 --> 00:46:05,670
have no bugs

1279
00:46:05,680 --> 00:46:07,280
because if there's a bug in the kernel

1280
00:46:07,280 --> 00:46:08,640
you know the way to think about it is

1281
00:46:08,640 --> 00:46:10,640
that maybe an attacker is able sort of

1282
00:46:10,640 --> 00:46:11,920
to

1283
00:46:11,920 --> 00:46:14,240
tickle the bug and turn the bug into an

1284
00:46:14,240 --> 00:46:15,280
exploit

1285
00:46:15,280 --> 00:46:17,280
and you know that exploit may maybe

1286
00:46:17,280 --> 00:46:19,119
allow that particular attacker to

1287
00:46:19,119 --> 00:46:21,280
break out of isolation or maybe take

1288
00:46:21,280 --> 00:46:23,119
some control over the kernel

1289
00:46:23,119 --> 00:46:24,560
and so it's really important that you

1290
00:46:24,560 --> 00:46:25,920
know the kernel really you know has to

1291
00:46:25,920 --> 00:46:29,599
have as few bugs as possible

1292
00:46:29,599 --> 00:46:31,520
and basically the kernel you know must

1293
00:46:31,520 --> 00:46:35,349
treat

1294
00:46:35,359 --> 00:46:38,480
let's treat user apps or applications or

1295
00:46:38,480 --> 00:46:41,670
processes

1296
00:46:41,680 --> 00:46:47,030
that's malicious

1297
00:46:47,040 --> 00:46:48,800
and basically as i said before you know

1298
00:46:48,800 --> 00:46:50,319
basically the german designer seems to

1299
00:46:50,319 --> 00:46:52,160
have sort of a security mindset

1300
00:46:52,160 --> 00:46:53,839
uh you know when writing and

1301
00:46:53,839 --> 00:46:56,079
implementing uh kernel code

1302
00:46:56,079 --> 00:46:58,960
and uh and you know it's hard to achieve

1303
00:46:58,960 --> 00:46:59,920
this goal right we're

1304
00:46:59,920 --> 00:47:02,160
having no bugs if you're playing system

1305
00:47:02,160 --> 00:47:03,440
gigantically big

1306
00:47:03,440 --> 00:47:05,200
uh is not that straightforward and you

1307
00:47:05,200 --> 00:47:06,960
know almost every operating system you

1308
00:47:06,960 --> 00:47:08,000
know that this

1309
00:47:08,000 --> 00:47:10,560
you use or is widely used uh once in a

1310
00:47:10,560 --> 00:47:12,319
while actually has a security bug

1311
00:47:12,319 --> 00:47:15,119
and you know they get fixed over time

1312
00:47:15,119 --> 00:47:16,480
but basically

1313
00:47:16,480 --> 00:47:18,400
no matter what there's always a new

1314
00:47:18,400 --> 00:47:20,079
exploit at some point

1315
00:47:20,079 --> 00:47:22,240
down the line and you know we'll see

1316
00:47:22,240 --> 00:47:24,400
later why it's so tricky to get it all

1317
00:47:24,400 --> 00:47:26,800
right but you know the sort of

1318
00:47:26,800 --> 00:47:28,559
understandable like

1319
00:47:28,559 --> 00:47:30,000
you know the kernel has to do tricky

1320
00:47:30,000 --> 00:47:33,040
stuff uh it has to manipulate hardware

1321
00:47:33,040 --> 00:47:34,960
uh it has to be very careful and it's

1322
00:47:34,960 --> 00:47:36,880
checking and it's very easy to make a

1323
00:47:36,880 --> 00:47:38,160
small slip up

1324
00:47:38,160 --> 00:47:42,069
and you know half a buck

1325
00:47:42,079 --> 00:47:47,030
and so

1326
00:47:47,040 --> 00:47:49,200
an interesting question correct is then

1327
00:47:49,200 --> 00:47:50,160
what should run

1328
00:47:50,160 --> 00:47:51,760
in kernel mode because it's really the

1329
00:47:51,760 --> 00:47:53,680
kernel code that actually is in kernel

1330
00:47:53,680 --> 00:47:54,319
mode

1331
00:47:54,319 --> 00:47:57,440
that is the uh sensitive code right that

1332
00:47:57,440 --> 00:47:59,280
is the trusted computing days

1333
00:47:59,280 --> 00:48:02,880
um and one answer you know to that

1334
00:48:02,880 --> 00:48:05,280
question is like well you know we have

1335
00:48:05,280 --> 00:48:06,640
our

1336
00:48:06,640 --> 00:48:08,559
user kernel boundary so here's user

1337
00:48:08,559 --> 00:48:10,720
here's kernel and

1338
00:48:10,720 --> 00:48:13,760
uh here's our applications running

1339
00:48:13,760 --> 00:48:15,920
and here is you know the program running

1340
00:48:15,920 --> 00:48:16,800
in kernel mode

1341
00:48:16,800 --> 00:48:18,720
one option is to stick the whole

1342
00:48:18,720 --> 00:48:20,000
operating system in kernel

1343
00:48:20,000 --> 00:48:23,200
mode so example uh in most unix

1344
00:48:23,200 --> 00:48:24,880
operating systems the whole

1345
00:48:24,880 --> 00:48:26,880
unix implementation runs inside of

1346
00:48:26,880 --> 00:48:29,599
kernel mode so for example in xv6

1347
00:48:29,599 --> 00:48:32,400
all the operating system services are

1348
00:48:32,400 --> 00:48:33,040
basically

1349
00:48:33,040 --> 00:48:36,000
in kernel mode and this is called

1350
00:48:36,000 --> 00:48:39,829
monolithic

1351
00:48:39,839 --> 00:48:47,510
kernel design

1352
00:48:47,520 --> 00:48:50,720
and you know there there's a couple

1353
00:48:50,720 --> 00:48:52,079
things in the way to think about it

1354
00:48:52,079 --> 00:48:54,800
um one you know it's probably not so

1355
00:48:54,800 --> 00:48:56,640
good for bugs right

1356
00:48:56,640 --> 00:49:00,079
um because any bug

1357
00:49:00,079 --> 00:49:01,520
you know that you might have in a

1358
00:49:01,520 --> 00:49:03,280
monolithical design you know might

1359
00:49:03,280 --> 00:49:04,720
actually turn into an

1360
00:49:04,720 --> 00:49:07,359
exploit and that would be bad uh so we

1361
00:49:07,359 --> 00:49:09,119
have a large operating system running

1362
00:49:09,119 --> 00:49:10,880
inside of the kernel it's likely that

1363
00:49:10,880 --> 00:49:12,240
they're going to be more books like any

1364
00:49:12,240 --> 00:49:14,079
statistics that you look up it says like

1365
00:49:14,079 --> 00:49:16,559
every 3000 lines of code will have you

1366
00:49:16,559 --> 00:49:18,319
know some small number of bucks

1367
00:49:18,319 --> 00:49:19,760
and so if you have many many more lines

1368
00:49:19,760 --> 00:49:21,200
of code you're running in the kernel box

1369
00:49:21,200 --> 00:49:22,720
you know the probability of the chance

1370
00:49:22,720 --> 00:49:23,839
that you have

1371
00:49:23,839 --> 00:49:26,559
uh and then the series buck you know it

1372
00:49:26,559 --> 00:49:27,440
goes up a little bit

1373
00:49:27,440 --> 00:49:29,599
and so the downside from the molecular

1374
00:49:29,599 --> 00:49:30,880
kernel design from the security

1375
00:49:30,880 --> 00:49:32,319
perspective is that there's a lot of

1376
00:49:32,319 --> 00:49:33,440
code in

1377
00:49:33,440 --> 00:49:36,800
the kernel uh the plus though

1378
00:49:36,800 --> 00:49:39,119
is you know typically if you're thinking

1379
00:49:39,119 --> 00:49:40,480
about an operating system it contains of

1380
00:49:40,480 --> 00:49:41,680
all kinds of different pieces you know

1381
00:49:41,680 --> 00:49:43,599
you might have to file system piece

1382
00:49:43,599 --> 00:49:45,760
you might have the virtual memory piece

1383
00:49:45,760 --> 00:49:48,240
uh you might have you know processes you

1384
00:49:48,240 --> 00:49:48,800
know

1385
00:49:48,800 --> 00:49:50,079
and so there are all kinds of sub

1386
00:49:50,079 --> 00:49:51,760
modules inside of the operating system

1387
00:49:51,760 --> 00:49:54,079
that implement particular functionality

1388
00:49:54,079 --> 00:49:55,760
and the plus side of that is there's

1389
00:49:55,760 --> 00:49:58,960
going to be tight integration possible

1390
00:49:58,960 --> 00:50:00,880
between these different sub modules if

1391
00:50:00,880 --> 00:50:03,440
they're all sitting in the same program

1392
00:50:03,440 --> 00:50:05,040
and that can actually lead you know to

1393
00:50:05,040 --> 00:50:11,109
great performance

1394
00:50:11,119 --> 00:50:12,480
uh an example if you look at an

1395
00:50:12,480 --> 00:50:14,640
operating system on linux it actually

1396
00:50:14,640 --> 00:50:17,680
achieves uh very impressive performance

1397
00:50:17,680 --> 00:50:20,880
and so this is one uh sort of one design

1398
00:50:20,880 --> 00:50:22,960
uh another design which basically

1399
00:50:22,960 --> 00:50:24,800
focuses on reducing the amount of code

1400
00:50:24,800 --> 00:50:25,920
in the kernel

1401
00:50:25,920 --> 00:50:35,030
is what's called microkernel design

1402
00:50:35,040 --> 00:50:37,040
and in this design the goal is actually

1403
00:50:37,040 --> 00:50:38,480
to run as few

1404
00:50:38,480 --> 00:50:40,960
lights as possible in kernel mode and so

1405
00:50:40,960 --> 00:50:41,920
for example there is

1406
00:50:41,920 --> 00:50:44,960
something often kernel but the kernel

1407
00:50:44,960 --> 00:50:46,240
has very few

1408
00:50:46,240 --> 00:50:48,720
uh components to it so for example it

1409
00:50:48,720 --> 00:50:50,160
typically has some form

1410
00:50:50,160 --> 00:50:53,520
of ipc or message passing a little bit

1411
00:50:53,520 --> 00:50:54,240
of

1412
00:50:54,240 --> 00:50:57,680
vm support very minimal basically only

1413
00:50:57,680 --> 00:50:58,079
the thing

1414
00:50:58,079 --> 00:51:00,000
necessarily for page tables and

1415
00:51:00,000 --> 00:51:01,920
something to multiplex

1416
00:51:01,920 --> 00:51:06,839
uh different cpus so some multiplexing

1417
00:51:06,839 --> 00:51:09,599
code

1418
00:51:09,599 --> 00:51:11,760
but generally the goal is to run the

1419
00:51:11,760 --> 00:51:14,000
bulk of the operating system outside of

1420
00:51:14,000 --> 00:51:14,880
the kernel

1421
00:51:14,880 --> 00:51:17,040
and so for example again as we have our

1422
00:51:17,040 --> 00:51:18,559
you know boundary here

1423
00:51:18,559 --> 00:51:21,040
uh what we'll do is actually we'll run

1424
00:51:21,040 --> 00:51:23,280
other parts of the kernel as usual

1425
00:51:23,280 --> 00:51:25,760
normal user applications so example we

1426
00:51:25,760 --> 00:51:26,640
might have an

1427
00:51:26,640 --> 00:51:34,390
oops

1428
00:51:34,400 --> 00:51:37,520
you might have a user process still okay

1429
00:51:37,520 --> 00:51:38,319
it's not going to intended but it

1430
00:51:38,319 --> 00:51:39,280
doesn't really matter

1431
00:51:39,280 --> 00:51:42,720
you know that's the file server and

1432
00:51:42,720 --> 00:51:44,880
so and the file server is just a regular

1433
00:51:44,880 --> 00:51:46,240
user space

1434
00:51:46,240 --> 00:51:48,559
so user space kernel so even though i

1435
00:51:48,559 --> 00:51:50,000
drew uh by accident

1436
00:51:50,000 --> 00:51:52,400
in red i intended to draw out in black

1437
00:51:52,400 --> 00:51:54,240
uh the faucets are mine run like a user

1438
00:51:54,240 --> 00:51:55,839
application like you know

1439
00:51:55,839 --> 00:51:59,040
echo you know the shell they're all

1440
00:51:59,040 --> 00:52:00,640
running user space and we might have

1441
00:52:00,640 --> 00:52:02,079
other you know user applications like

1442
00:52:02,079 --> 00:52:02,559
the

1443
00:52:02,559 --> 00:52:04,079
parts of the vm system might actually

1444
00:52:04,079 --> 00:52:06,960
run a regular user application

1445
00:52:06,960 --> 00:52:10,400
in um in user mode and so this is sort

1446
00:52:10,400 --> 00:52:12,000
of a nice design correct because

1447
00:52:12,000 --> 00:52:13,119
you know the amount of code that

1448
00:52:13,119 --> 00:52:18,720
presumably that's in the kernel is small

1449
00:52:18,720 --> 00:52:22,000
it's small and small means hopefully

1450
00:52:22,000 --> 00:52:28,069
fewer bucks

1451
00:52:28,079 --> 00:52:30,079
the one issue and of course it's like

1452
00:52:30,079 --> 00:52:31,440
you know we have to arrange that the

1453
00:52:31,440 --> 00:52:33,040
shell can talk to the file system for

1454
00:52:33,040 --> 00:52:35,040
example you know the shell calls exec

1455
00:52:35,040 --> 00:52:36,640
and there has to be a way you've got to

1456
00:52:36,640 --> 00:52:38,240
get into the file system and so

1457
00:52:38,240 --> 00:52:40,000
typically that way that works is that

1458
00:52:40,000 --> 00:52:42,000
the shell will send a message you know

1459
00:52:42,000 --> 00:52:43,920
through the ipc system

1460
00:52:43,920 --> 00:52:46,000
to the kernel the kernel will look at it

1461
00:52:46,000 --> 00:52:47,040
and say like oh you know this is

1462
00:52:47,040 --> 00:52:48,720
intended for the file system so the file

1463
00:52:48,720 --> 00:52:51,440
system sends it to the file system

1464
00:52:51,440 --> 00:52:53,839
the file system doesn't work you know

1465
00:52:53,839 --> 00:52:55,359
sends a message back

1466
00:52:55,359 --> 00:52:56,880
saying like you know here's the results

1467
00:52:56,880 --> 00:52:58,720
of your exact system call

1468
00:52:58,720 --> 00:53:00,640
and then you know sends it back to the

1469
00:53:00,640 --> 00:53:01,760
shell

1470
00:53:01,760 --> 00:53:04,240
and so uh these are typically

1471
00:53:04,240 --> 00:53:05,920
implemented using messages

1472
00:53:05,920 --> 00:53:08,559
uh and so for any interaction with the

1473
00:53:08,559 --> 00:53:09,520
file server

1474
00:53:09,520 --> 00:53:11,520
now you have to jump once into the

1475
00:53:11,520 --> 00:53:13,119
kernel once out of the kernel

1476
00:53:13,119 --> 00:53:14,800
once into the kernel once out of the

1477
00:53:14,800 --> 00:53:16,640
kernel if you compare that with the

1478
00:53:16,640 --> 00:53:17,839
previous design

1479
00:53:17,839 --> 00:53:19,680
like if this guy wants to talk to the

1480
00:53:19,680 --> 00:53:21,839
file system it's one system to call in

1481
00:53:21,839 --> 00:53:24,400
and one basically called back out and so

1482
00:53:24,400 --> 00:53:25,040
you double

1483
00:53:25,040 --> 00:53:28,800
the numer of system call entries

1484
00:53:28,800 --> 00:53:32,160
and so uh one typical problem or

1485
00:53:32,160 --> 00:53:33,680
challenge with offer with the micro

1486
00:53:33,680 --> 00:53:34,880
kernel approach is

1487
00:53:34,880 --> 00:53:36,480
uh is actually how to achieve good

1488
00:53:36,480 --> 00:53:38,640
performance and it has sort of two

1489
00:53:38,640 --> 00:53:40,839
components to it

1490
00:53:40,839 --> 00:53:43,839
one uh you know just jumping back and

1491
00:53:43,839 --> 00:53:44,240
forth

1492
00:53:44,240 --> 00:53:45,680
you know between user mode and kernel

1493
00:53:45,680 --> 00:53:47,440
mode to actually get something done

1494
00:53:47,440 --> 00:53:49,520
and the second part is because you know

1495
00:53:49,520 --> 00:53:51,280
the different pieces are really well

1496
00:53:51,280 --> 00:53:52,880
isolated from each other a tight

1497
00:53:52,880 --> 00:53:55,200
integration is less you know

1498
00:53:55,200 --> 00:53:56,880
more complicated to range than for

1499
00:53:56,880 --> 00:53:58,240
example in the monolithic kernel where

1500
00:53:58,240 --> 00:53:58,880
basically

1501
00:53:58,880 --> 00:54:00,640
everybody can you know for example the

1502
00:54:00,640 --> 00:54:02,000
file system in the virtual memory system

1503
00:54:02,000 --> 00:54:02,880
can easily

1504
00:54:02,880 --> 00:54:05,280
share a page cache which is a little bit

1505
00:54:05,280 --> 00:54:06,960
harder to achieve in the microkernel

1506
00:54:06,960 --> 00:54:08,480
design and therefore it's sometimes more

1507
00:54:08,480 --> 00:54:09,440
difficult

1508
00:54:09,440 --> 00:54:12,480
to get high performance now these

1509
00:54:12,480 --> 00:54:13,520
distinctions

1510
00:54:13,520 --> 00:54:14,800
you know between microcurrent and

1511
00:54:14,800 --> 00:54:16,640
monocle are very high level

1512
00:54:16,640 --> 00:54:19,200
so in practice both types of kernel

1513
00:54:19,200 --> 00:54:19,760
designs

1514
00:54:19,760 --> 00:54:23,440
show up most desktop operating systems

1515
00:54:23,440 --> 00:54:24,319
are typically

1516
00:54:24,319 --> 00:54:26,240
monolithical systems mostly for

1517
00:54:26,240 --> 00:54:27,760
historical reasons

1518
00:54:27,760 --> 00:54:31,520
uh a lot of the if you run very intense

1519
00:54:31,520 --> 00:54:33,359
you know os intense applications for

1520
00:54:33,359 --> 00:54:34,480
example in the data center

1521
00:54:34,480 --> 00:54:35,920
they typically run on a mole

1522
00:54:35,920 --> 00:54:38,079
monolithical kernel

1523
00:54:38,079 --> 00:54:39,520
mostly because for example linux

1524
00:54:39,520 --> 00:54:41,119
provides great performance

1525
00:54:41,119 --> 00:54:44,559
but many uh embedding settings uh

1526
00:54:44,559 --> 00:54:47,760
like minix or cell 4

1527
00:54:47,760 --> 00:54:49,920
those all tend to be micro kernel

1528
00:54:49,920 --> 00:54:51,359
designs

1529
00:54:51,359 --> 00:54:53,839
and so both designs are popular uh if

1530
00:54:53,839 --> 00:54:55,119
you probably start a new operating

1531
00:54:55,119 --> 00:54:56,799
system from scratch

1532
00:54:56,799 --> 00:54:59,599
you probably start with uh you may you

1533
00:54:59,599 --> 00:55:00,799
know uh

1534
00:55:00,799 --> 00:55:03,920
you may start with a microkernel design

1535
00:55:03,920 --> 00:55:05,680
and once you have a monolithical design

1536
00:55:05,680 --> 00:55:07,200
like for example linux you know it's

1537
00:55:07,200 --> 00:55:07,680
going to be

1538
00:55:07,680 --> 00:55:09,760
it would be a ton of work to rewrite it

1539
00:55:09,760 --> 00:55:11,359
into a micro kernel design and that's

1540
00:55:11,359 --> 00:55:12,960
maybe you know just not conducive to the

1541
00:55:12,960 --> 00:55:14,319
incentives you know people probably want

1542
00:55:14,319 --> 00:55:15,440
to spend rather time

1543
00:55:15,440 --> 00:55:17,760
implementing new features than actually

1544
00:55:17,760 --> 00:55:18,640
uh

1545
00:55:18,640 --> 00:55:22,799
uh you know restructuring their kernel

1546
00:55:22,799 --> 00:55:24,799
and so these are sort of the two main

1547
00:55:24,799 --> 00:55:25,839
designs

1548
00:55:25,839 --> 00:55:29,200
uh as you know xv6 is a it falls into

1549
00:55:29,200 --> 00:55:31,359
monolithical design as most classic unix

1550
00:55:31,359 --> 00:55:34,480
systems do but later in the semester

1551
00:55:34,480 --> 00:55:36,240
we'll talk a lot more in detail about

1552
00:55:36,240 --> 00:55:40,069
some of the microkernel designs

1553
00:55:40,079 --> 00:55:41,520
any questions about this because this

1554
00:55:41,520 --> 00:55:43,760
was a hot topic in the

1555
00:55:43,760 --> 00:55:54,630
in the email questions

1556
00:55:54,640 --> 00:55:57,760
okay uh okay so let me switch

1557
00:55:57,760 --> 00:55:59,599
a little bit i'm going to fill it to

1558
00:55:59,599 --> 00:56:01,440
some code and so to see how all this

1559
00:56:01,440 --> 00:56:02,079
plays out

1560
00:56:02,079 --> 00:56:05,990
in xv6

1561
00:56:06,000 --> 00:56:09,839
uh so here's a two windows

1562
00:56:09,839 --> 00:56:12,799
uh and you know your emacs we know with

1563
00:56:12,799 --> 00:56:14,960
like the proc structure

1564
00:56:14,960 --> 00:56:17,520
and the first thing i want to do is uh

1565
00:56:17,520 --> 00:56:18,000
you know

1566
00:56:18,000 --> 00:56:19,599
look a little bit at the code base uh

1567
00:56:19,599 --> 00:56:21,040
you've probably already done this

1568
00:56:21,040 --> 00:56:22,319
but you see that the code is sort of

1569
00:56:22,319 --> 00:56:24,960
organized along three uh

1570
00:56:24,960 --> 00:56:28,079
in three parts one the kernel and

1571
00:56:28,079 --> 00:56:30,079
we can kernel that basically includes

1572
00:56:30,079 --> 00:56:31,520
all the

1573
00:56:31,520 --> 00:56:34,160
kernel files and so xv6 being a

1574
00:56:34,160 --> 00:56:35,440
monolithical kernel

1575
00:56:35,440 --> 00:56:37,839
basically all these programs are

1576
00:56:37,839 --> 00:56:39,359
compiled things there's a single binary

1577
00:56:39,359 --> 00:56:40,720
called the kernel and that's actually

1578
00:56:40,720 --> 00:56:43,359
what we run in kernel mode

1579
00:56:43,359 --> 00:56:45,760
um and then you know there's user and

1580
00:56:45,760 --> 00:56:46,480
those are the

1581
00:56:46,480 --> 00:56:48,000
basically the programs that run in user

1582
00:56:48,000 --> 00:56:49,680
mode and this is why you know one is

1583
00:56:49,680 --> 00:56:50,960
called kernel the other called

1584
00:56:50,960 --> 00:56:53,359
user and then there's one more program

1585
00:56:53,359 --> 00:56:54,960
called makefs

1586
00:56:54,960 --> 00:56:57,280
which actually builds an empty file

1587
00:56:57,280 --> 00:56:58,559
system image

1588
00:56:58,559 --> 00:57:01,119
that we have stored on disk so that we

1589
00:57:01,119 --> 00:57:01,680
can get

1590
00:57:01,680 --> 00:57:09,109
off the ground with an empty file system

1591
00:57:09,119 --> 00:57:11,920
okay so before so let me switch back

1592
00:57:11,920 --> 00:57:12,319
again

1593
00:57:12,319 --> 00:57:14,000
to i want to say a little bit about how

1594
00:57:14,000 --> 00:57:16,079
the kernel is compiled

1595
00:57:16,079 --> 00:57:17,760
uh because you probably have seen this

1596
00:57:17,760 --> 00:57:19,839
and might not really have realized it

1597
00:57:19,839 --> 00:57:22,400
uh and sort of important to understand

1598
00:57:22,400 --> 00:57:23,119
uh

1599
00:57:23,119 --> 00:57:25,920
so when the kernel the construction of

1600
00:57:25,920 --> 00:57:26,559
the kernel

1601
00:57:26,559 --> 00:57:28,319
the make file basically you know takes

1602
00:57:28,319 --> 00:57:30,079
you know one of these cs files like

1603
00:57:30,079 --> 00:57:31,839
proc.c

1604
00:57:31,839 --> 00:57:34,880
you know invokes you know the gcc the

1605
00:57:34,880 --> 00:57:38,839
cc compiler that generates a file called

1606
00:57:38,839 --> 00:57:40,160
proc.s

1607
00:57:40,160 --> 00:57:44,710
that goes to the assembler

1608
00:57:44,720 --> 00:57:49,270
and this is basically a risk 5 assembly

1609
00:57:49,280 --> 00:57:51,200
and that actually produces a file called

1610
00:57:51,200 --> 00:57:52,319
proc.o

1611
00:57:52,319 --> 00:57:54,000
and basically that's you know the binary

1612
00:57:54,000 --> 00:57:56,240
version of the assembler so

1613
00:57:56,240 --> 00:57:58,559
um and you know the makefile does this

1614
00:57:58,559 --> 00:57:59,280
for all

1615
00:57:59,280 --> 00:58:01,119
you know part files of the kernel so for

1616
00:58:01,119 --> 00:58:02,400
example uh you know

1617
00:58:02,400 --> 00:58:05,119
pipe there's another one you know same

1618
00:58:05,119 --> 00:58:05,760
story

1619
00:58:05,760 --> 00:58:09,200
gcc compiles it to pipe.s

1620
00:58:09,200 --> 00:58:10,640
and we're going to go through 3d

1621
00:58:10,640 --> 00:58:14,000
assembler and we've got a pipe.o

1622
00:58:14,000 --> 00:58:17,119
and basically then the loader you know

1623
00:58:17,119 --> 00:58:19,440
takes all these dot o files

1624
00:58:19,440 --> 00:58:22,160
from all the different files and links

1625
00:58:22,160 --> 00:58:23,040
them together

1626
00:58:23,040 --> 00:58:24,799
and produces the current and produces

1627
00:58:24,799 --> 00:58:28,390
the kernel

1628
00:58:28,400 --> 00:58:29,760
and that is actually and then what we've

1629
00:58:29,760 --> 00:58:31,520
run and the

1630
00:58:31,520 --> 00:58:32,960
you know for your convenience you know

1631
00:58:32,960 --> 00:58:34,839
the makefile also produces a file called

1632
00:58:34,839 --> 00:58:39,030
kernel.asm

1633
00:58:39,040 --> 00:58:43,280
that has the complete kernel

1634
00:58:43,280 --> 00:58:45,760
disassembled and you can just look at it

1635
00:58:45,760 --> 00:58:47,520
and you know that helps later on

1636
00:58:47,520 --> 00:58:48,880
when you have kernel bugs and it's easy

1637
00:58:48,880 --> 00:58:50,880
to see which instruction

1638
00:58:50,880 --> 00:58:52,720
was executed at the point you got the

1639
00:58:52,720 --> 00:58:54,079
debug so

1640
00:58:54,079 --> 00:58:57,200
example if i uh

1641
00:58:57,200 --> 00:59:00,319
here kernel.asm

1642
00:59:00,319 --> 00:59:03,359
we see here's the kernel file

1643
00:59:03,359 --> 00:59:06,720
uh disassembly instructions and uh

1644
00:59:06,720 --> 00:59:08,240
and one thing you note for example is

1645
00:59:08,240 --> 00:59:10,960
that the first uh instruction is located

1646
00:59:10,960 --> 00:59:12,720
at this address eight zero zero zero

1647
00:59:12,720 --> 00:59:13,920
zero zero

1648
00:59:13,920 --> 00:59:16,480
um and that is in whatever aupc

1649
00:59:16,480 --> 00:59:19,670
instruction the risk life instruction

1650
00:59:19,670 --> 00:59:20,720
[Music]

1651
00:59:20,720 --> 00:59:24,000
and anybody knows what this is

1652
00:59:24,000 --> 00:59:25,920
zero zero eight one one seven or eight

1653
00:59:25,920 --> 00:59:34,630
three one or three six five oh five

1654
00:59:34,640 --> 00:59:36,799
anyone who wants to answer that question

1655
00:59:36,799 --> 00:59:38,000
that's the

1656
00:59:38,000 --> 00:59:39,839
hex version of the assembly instructions

1657
00:59:39,839 --> 00:59:41,040
on the right

1658
00:59:41,040 --> 00:59:43,440
yeah exactly so what here on the zero

1659
00:59:43,440 --> 00:59:46,640
zero a117 is exactly the same thing as

1660
00:59:46,640 --> 00:59:48,240
the symbolic you know the textual

1661
00:59:48,240 --> 00:59:50,400
version of that a upc

1662
00:59:50,400 --> 00:59:52,400
and so basically this is the binary

1663
00:59:52,400 --> 00:59:55,599
encoding of the actual instruction

1664
00:59:55,599 --> 00:59:57,440
and so and every instruction has a

1665
00:59:57,440 --> 00:59:58,640
binary encoding

1666
00:59:58,640 --> 01:00:00,480
and you know the kernel of the exam file

1667
01:00:00,480 --> 01:00:03,520
actually shows those binary encodings

1668
01:00:03,520 --> 01:00:04,720
and this is sometimes convenient when

1669
01:00:04,720 --> 01:00:06,400
you look at gdb and you want to know

1670
01:00:06,400 --> 01:00:07,839
what actually is going on you know you

1671
01:00:07,839 --> 01:00:08,880
can see actually what the binary

1672
01:00:08,880 --> 01:00:12,069
encoding is

1673
01:00:12,079 --> 01:00:15,200
okay okay so then when we

1674
01:00:15,200 --> 01:00:17,440
run xv6 i'm going to run on the inside

1675
01:00:17,440 --> 01:00:18,960
of actually let me first run it

1676
01:00:18,960 --> 01:00:21,920
without gdb uh you know we'll compile a

1677
01:00:21,920 --> 01:00:23,040
bunch of stuff and then it

1678
01:00:23,040 --> 01:00:26,559
invokes uh qmu right then this is a

1679
01:00:26,559 --> 01:00:28,640
basically c program

1680
01:00:28,640 --> 01:00:30,880
that simulates or emulates a risk five

1681
01:00:30,880 --> 01:00:32,079
processor

1682
01:00:32,079 --> 01:00:33,680
and you can see here in the dash kernel

1683
01:00:33,680 --> 01:00:36,319
flag it actually passes the kernel

1684
01:00:36,319 --> 01:00:39,599
uh and uh the program to be run

1685
01:00:39,599 --> 01:00:42,880
inside of qmu and qmu and

1686
01:00:42,880 --> 01:00:45,200
the kernel agreed uh basically the the

1687
01:00:45,200 --> 01:00:46,960
starting place for any program

1688
01:00:46,960 --> 01:00:48,720
is this address eight zero zero zero

1689
01:00:48,720 --> 01:00:50,000
zero

1690
01:00:50,000 --> 01:00:51,440
and we see that we pass a couple other

1691
01:00:51,440 --> 01:00:53,440
flags to team u it says here m that's

1692
01:00:53,440 --> 01:00:56,079
the amount of memory that the machine

1693
01:00:56,079 --> 01:00:57,760
this virtual machine has

1694
01:00:57,760 --> 01:01:00,240
this virtual risk fight machine it

1695
01:01:00,240 --> 01:01:02,960
passes in how many of course there are

1696
01:01:02,960 --> 01:01:06,240
it passes in the machine the disk drive

1697
01:01:06,240 --> 01:01:08,799
which contains the file fsnf image and

1698
01:01:08,799 --> 01:01:10,160
so basically a bunch of things are sort

1699
01:01:10,160 --> 01:01:12,000
of set up to make you know qmu behave

1700
01:01:12,000 --> 01:01:14,480
like a real computer

1701
01:01:14,480 --> 01:01:17,200
and so one way when you think about qmu

1702
01:01:17,200 --> 01:01:17,760
you really

1703
01:01:17,760 --> 01:01:20,079
should not think about it as a cd

1704
01:01:20,079 --> 01:01:21,440
program really the way you should think

1705
01:01:21,440 --> 01:01:22,240
about it

1706
01:01:22,240 --> 01:01:25,440
is as follows uh

1707
01:01:25,440 --> 01:01:30,870
you should think about it as um

1708
01:01:30,880 --> 01:01:34,319
as this uh namely a real

1709
01:01:34,319 --> 01:01:37,119
board uh so for example this on the left

1710
01:01:37,119 --> 01:01:38,240
you know this is a

1711
01:01:38,240 --> 01:01:40,400
risk five board uh actually there's a

1712
01:01:40,400 --> 01:01:42,480
risk five board that sits in my office

1713
01:01:42,480 --> 01:01:44,880
and you know it can boot uh more or less

1714
01:01:44,880 --> 01:01:46,240
xv6

1715
01:01:46,240 --> 01:01:49,040
and so when you're running you know qmu

1716
01:01:49,040 --> 01:01:50,480
uh with your kernel you should think

1717
01:01:50,480 --> 01:01:51,839
about it that actually you're running it

1718
01:01:51,839 --> 01:01:53,280
on this board

1719
01:01:53,280 --> 01:01:55,599
and you know the board has an on off

1720
01:01:55,599 --> 01:01:56,400
button

1721
01:01:56,400 --> 01:02:00,319
uh here's actually the risk 5 processor

1722
01:02:00,319 --> 01:02:03,200
uh you know there's room for peripherals

1723
01:02:03,200 --> 01:02:04,720
as for example one of these

1724
01:02:04,720 --> 01:02:07,440
connectors is a connector for ethernet

1725
01:02:07,440 --> 01:02:08,319
uh

1726
01:02:08,319 --> 01:02:11,440
one is the pcie slots uh there are some

1727
01:02:11,440 --> 01:02:13,039
ram chips on the

1728
01:02:13,039 --> 01:02:14,559
you know the board i don't exactly know

1729
01:02:14,559 --> 01:02:16,480
where they are but there are

1730
01:02:16,480 --> 01:02:19,359
um and so this is sort of a that's the

1731
01:02:19,359 --> 01:02:21,119
physical hardware the computer actually

1732
01:02:21,119 --> 01:02:23,599
that actually you're programming so xv6

1733
01:02:23,599 --> 01:02:26,720
manages this board uh and that's the the

1734
01:02:26,720 --> 01:02:28,960
picture you should have in your head

1735
01:02:28,960 --> 01:02:31,839
and in fact if you zoom in you know you

1736
01:02:31,839 --> 01:02:33,119
can find all the documentation

1737
01:02:33,119 --> 01:02:34,799
of like what actually sits inside of

1738
01:02:34,799 --> 01:02:36,400
this uh

1739
01:02:36,400 --> 01:02:38,640
and inside of this you know this is the

1740
01:02:38,640 --> 01:02:40,000
inside of this risc five

1741
01:02:40,000 --> 01:02:42,319
you know processor the the schema for

1742
01:02:42,319 --> 01:02:43,920
the risk five processor is

1743
01:02:43,920 --> 01:02:46,720
shown in this picture here uh and you

1744
01:02:46,720 --> 01:02:48,160
know we see here for example there are

1745
01:02:48,160 --> 01:02:51,520
multiple cores in fact the four cores

1746
01:02:51,520 --> 01:02:55,039
uh you know there is a l2 cache

1747
01:02:55,039 --> 01:02:58,079
uh there's a connector to dram uh

1748
01:02:58,079 --> 01:02:59,680
you know there's a bunch of ways to

1749
01:02:59,680 --> 01:03:01,119
connect to the outside world so for

1750
01:03:01,119 --> 01:03:02,079
example here's your

1751
01:03:02,079 --> 01:03:04,799
zero and uh zero is actually connected

1752
01:03:04,799 --> 01:03:05,680
on one end

1753
01:03:05,680 --> 01:03:07,359
you know to the keyboard and to the

1754
01:03:07,359 --> 01:03:09,280
other end to the display

1755
01:03:09,280 --> 01:03:11,280
um and you know there's some ways to

1756
01:03:11,280 --> 01:03:12,480
actually uh

1757
01:03:12,480 --> 01:03:15,440
get clocks uh going i'm i'll talk about

1758
01:03:15,440 --> 01:03:17,280
it in much more detail later

1759
01:03:17,280 --> 01:03:18,799
but these are all the components that

1760
01:03:18,799 --> 01:03:20,880
basically you know the xv6 or

1761
01:03:20,880 --> 01:03:22,559
and things that you'll be modifying to

1762
01:03:22,559 --> 01:03:24,960
interact with actually the real hardware

1763
01:03:24,960 --> 01:03:27,839
in fact the computer system or the

1764
01:03:27,839 --> 01:03:29,599
computer board that actually is

1765
01:03:29,599 --> 01:03:32,960
emulated by qmu is pretty close

1766
01:03:32,960 --> 01:03:35,280
you know minor some small details to

1767
01:03:35,280 --> 01:03:36,960
this particular you know computer board

1768
01:03:36,960 --> 01:03:40,309
which is made by sci-fi

1769
01:03:40,319 --> 01:03:41,680
and unfortunately i can't show you the

1770
01:03:41,680 --> 01:03:44,000
real thing as i said sits in my office

1771
01:03:44,000 --> 01:03:45,520
you know and i haven't been in my office

1772
01:03:45,520 --> 01:03:47,440
since march probably collecting a lot of

1773
01:03:47,440 --> 01:03:47,920
dust

1774
01:03:47,920 --> 01:03:50,240
uh but it's important to keep in your

1775
01:03:50,240 --> 01:03:52,079
head and when you're running qmu

1776
01:03:52,079 --> 01:03:53,839
you're running basically on real

1777
01:03:53,839 --> 01:03:55,839
hardware and just happens to be

1778
01:03:55,839 --> 01:04:02,470
implementing the software

1779
01:04:02,480 --> 01:04:05,359
does that make sense password second

1780
01:04:05,359 --> 01:04:11,430
tier

1781
01:04:11,440 --> 01:04:13,200
so let me say a little bit more about

1782
01:04:13,200 --> 01:04:15,520
this so what does it mean for qmu to

1783
01:04:15,520 --> 01:04:20,309
emulate

1784
01:04:20,319 --> 01:04:24,870
a risk 5 processor

1785
01:04:24,880 --> 01:04:26,559
well literally you know if you think

1786
01:04:26,559 --> 01:04:28,400
about it like you know as i said you

1787
01:04:28,400 --> 01:04:29,680
know people use a csv

1788
01:04:29,680 --> 01:04:31,359
program it's an open source c program

1789
01:04:31,359 --> 01:04:33,119
it's a big program you can actually just

1790
01:04:33,119 --> 01:04:36,319
you know download it or git clone it but

1791
01:04:36,319 --> 01:04:38,720
internally into c uh it is basically a

1792
01:04:38,720 --> 01:04:42,079
for loop an infinite for loop

1793
01:04:42,079 --> 01:04:43,599
that basically does nothing else then

1794
01:04:43,599 --> 01:04:48,630
read instruction

1795
01:04:48,640 --> 01:04:50,000
the risk five instruction you know

1796
01:04:50,000 --> 01:04:51,680
basically reach you know

1797
01:04:51,680 --> 01:04:54,880
four bytes or eight bytes and

1798
01:04:54,880 --> 01:04:56,799
basically looks at the bits in that

1799
01:04:56,799 --> 01:04:58,720
instruction and decodes them

1800
01:04:58,720 --> 01:05:03,510
you know figures out what the op code is

1801
01:05:03,520 --> 01:05:04,960
and we saw that for some of the

1802
01:05:04,960 --> 01:05:06,720
instructions the binary version of those

1803
01:05:06,720 --> 01:05:07,680
instructions in the

1804
01:05:07,680 --> 01:05:10,000
dot asm file and so it decodes the

1805
01:05:10,000 --> 01:05:11,440
instructions so for example maybe it

1806
01:05:11,440 --> 01:05:13,520
will decide this is an ad instruction

1807
01:05:13,520 --> 01:05:15,599
or there's a sub instruction you know

1808
01:05:15,599 --> 01:05:16,880
risk five sub-construction and then

1809
01:05:16,880 --> 01:05:17,520
basically

1810
01:05:17,520 --> 01:05:25,190
it executes the instruction in software

1811
01:05:25,200 --> 01:05:26,960
and you know that basically is all what

1812
01:05:26,960 --> 01:05:28,400
it does you know for every core

1813
01:05:28,400 --> 01:05:30,880
you know it runs this particular loop

1814
01:05:30,880 --> 01:05:32,799
and in addition sort of doing this loop

1815
01:05:32,799 --> 01:05:34,079
it has to maintain some state so

1816
01:05:34,079 --> 01:05:36,960
maintain state for all the registers

1817
01:05:36,960 --> 01:05:40,319
so it has a c declaration for like x0

1818
01:05:40,319 --> 01:05:44,240
register 0 x1 etc

1819
01:05:44,240 --> 01:05:45,520
and so basically when it executes

1820
01:05:45,520 --> 01:05:47,200
instruction for example the instruction

1821
01:05:47,200 --> 01:05:48,839
is like whatever

1822
01:05:48,839 --> 01:05:51,839
and you know a0

1823
01:05:51,839 --> 01:05:54,559
you know you know one through seven and

1824
01:05:54,559 --> 01:05:55,760
store it in a zero

1825
01:05:55,760 --> 01:05:57,280
then basically takes a constant seven

1826
01:05:57,280 --> 01:05:59,039
and one adds them up and sticks it in a

1827
01:05:59,039 --> 01:05:59,920
zero

1828
01:05:59,920 --> 01:06:01,280
right so examples towards the seven

1829
01:06:01,280 --> 01:06:03,119
meter and then it executes the next

1830
01:06:03,119 --> 01:06:04,480
instruction and it keeps going keeps

1831
01:06:04,480 --> 01:06:05,760
going

1832
01:06:05,760 --> 01:06:07,760
in addition to basically emulating or

1833
01:06:07,760 --> 01:06:09,280
correctly all the improv

1834
01:06:09,280 --> 01:06:11,359
privilege instructions it also emulates

1835
01:06:11,359 --> 01:06:13,359
all the privilege instructions

1836
01:06:13,359 --> 01:06:15,680
so that is in essence uh what key mu

1837
01:06:15,680 --> 01:06:16,480
does

1838
01:06:16,480 --> 01:06:18,480
uh and but the best picture for you to

1839
01:06:18,480 --> 01:06:19,599
have in your head is that basically

1840
01:06:19,599 --> 01:06:21,200
you're running on a real physical risk

1841
01:06:21,200 --> 01:06:22,559
five processor

1842
01:06:22,559 --> 01:06:24,160
like the ones you have probably you know

1843
01:06:24,160 --> 01:06:26,160
many of you implemented one i think in

1844
01:06:26,160 --> 01:06:30,230
double o4

1845
01:06:30,240 --> 01:06:33,599
any questions about this um hi

1846
01:06:33,599 --> 01:06:36,079
yeah i was wondering if it does any

1847
01:06:36,079 --> 01:06:37,359
hardware tricks

1848
01:06:37,359 --> 01:06:39,280
so like overlapping instructions or

1849
01:06:39,280 --> 01:06:41,039
anything

1850
01:06:41,039 --> 01:06:44,319
uh no uh it runs on a real processor

1851
01:06:44,319 --> 01:06:46,480
below it correct so when you run qmu

1852
01:06:46,480 --> 01:06:49,200
and runs probably on an x86 processor

1853
01:06:49,200 --> 01:06:50,559
that x86 processor

1854
01:06:50,559 --> 01:06:52,160
does all kinds of tricks you know to

1855
01:06:52,160 --> 01:06:53,680
pipeline instructions and things like

1856
01:06:53,680 --> 01:06:54,160
that

1857
01:06:54,160 --> 01:06:56,079
right so the way you think about qmu

1858
01:06:56,079 --> 01:07:00,480
it's just a c program

1859
01:07:00,480 --> 01:07:08,309
makes sense thank you

1860
01:07:08,319 --> 01:07:11,440
what about multi-threading so if the the

1861
01:07:11,440 --> 01:07:12,160
cmu

1862
01:07:12,160 --> 01:07:14,400
supports you said four cores or does it

1863
01:07:14,400 --> 01:07:15,599
only support one

1864
01:07:15,599 --> 01:07:17,599
and it is if that case does it have

1865
01:07:17,599 --> 01:07:20,000
actually multiple threads running it

1866
01:07:20,000 --> 01:07:22,319
yeah so uh actually the qmu that we use

1867
01:07:22,319 --> 01:07:23,039
on uh

1868
01:07:23,039 --> 01:07:24,480
athena and probably the ones that you

1869
01:07:24,480 --> 01:07:26,319
actually download uh

1870
01:07:26,319 --> 01:07:28,480
they will use multiple threads

1871
01:07:28,480 --> 01:07:30,319
internally so kim you internally use it

1872
01:07:30,319 --> 01:07:31,280
to get parallelism

1873
01:07:31,280 --> 01:07:34,319
so in fact these four cores that are

1874
01:07:34,319 --> 01:07:35,680
being emulated are sort of being

1875
01:07:35,680 --> 01:07:39,990
emulated in parallel

1876
01:07:40,000 --> 01:07:41,359
and we'll see that in one of the labs

1877
01:07:41,359 --> 01:07:44,400
later how that plays out

1878
01:07:44,400 --> 01:07:45,920
and so definitely there's a real

1879
01:07:45,920 --> 01:07:47,280
parallelism going on between the

1880
01:07:47,280 --> 01:07:54,150
different cores

1881
01:07:54,160 --> 01:07:58,319
okay so i'm gonna do a little bit of uh

1882
01:07:58,319 --> 01:08:01,440
uh you know walking through uh

1883
01:08:01,440 --> 01:08:03,359
uh xv6 to get a little bit of sense what

1884
01:08:03,359 --> 01:08:05,119
the layout of the land is

1885
01:08:05,119 --> 01:08:06,720
uh and you know in the later lecture

1886
01:08:06,720 --> 01:08:09,039
again we're gonna go in much more detail

1887
01:08:09,039 --> 01:08:12,319
so i'm gonna fire up uh qmu under uh

1888
01:08:12,319 --> 01:08:15,039
uh with gdp support so basically qmu has

1889
01:08:15,039 --> 01:08:17,520
inside of it a gdp server

1890
01:08:17,520 --> 01:08:19,920
um and so it starts it up and then it

1891
01:08:19,920 --> 01:08:21,440
just waits you know for

1892
01:08:21,440 --> 01:08:24,880
uh gdp to connect to that

1893
01:08:24,880 --> 01:08:26,319
so i'm going to start here on my

1894
01:08:26,319 --> 01:08:28,880
computer and this is a risc 64 linux new

1895
01:08:28,880 --> 01:08:30,000
gdb

1896
01:08:30,000 --> 01:08:31,839
on some of your machines it might be

1897
01:08:31,839 --> 01:08:33,120
multi-arch or

1898
01:08:33,120 --> 01:08:35,440
something else but basically the gdp

1899
01:08:35,440 --> 01:08:37,040
compiled for risk 64.

1900
01:08:37,040 --> 01:08:40,960
risk 564. and

1901
01:08:40,960 --> 01:08:43,040
i'm going to set the breakpoint at entry

1902
01:08:43,040 --> 01:08:44,239
because that's the first

1903
01:08:44,239 --> 01:08:45,520
we know that's roughly the first

1904
01:08:45,520 --> 01:08:48,080
instruction that actually where team

1905
01:08:48,080 --> 01:08:50,400
is going to jump to so i set the

1906
01:08:50,400 --> 01:08:52,159
breakpoint i run

1907
01:08:52,159 --> 01:08:54,239
and basically it doesn't actually break

1908
01:08:54,239 --> 01:08:56,239
exactly at eight zero zero zero but at

1909
01:08:56,239 --> 01:08:57,279
zero a

1910
01:08:57,279 --> 01:08:59,040
and if we look here on the right you

1911
01:08:59,040 --> 01:09:01,120
know we see that zero a is

1912
01:09:01,120 --> 01:09:04,640
uh right reading the control system

1913
01:09:04,640 --> 01:09:05,600
register

1914
01:09:05,600 --> 01:09:09,520
mr id and loading that value into a1

1915
01:09:09,520 --> 01:09:11,759
and so basically qmu simulates that

1916
01:09:11,759 --> 01:09:13,120
instruction then we can execute that

1917
01:09:13,120 --> 01:09:14,480
instruction then we go to the next

1918
01:09:14,480 --> 01:09:17,669
instruction

1919
01:09:17,679 --> 01:09:20,400
and basically this address address800 is

1920
01:09:20,400 --> 01:09:21,839
just basically something that was

1921
01:09:21,839 --> 01:09:24,880
agreed on you know uh

1922
01:09:24,880 --> 01:09:27,759
by qmu or commutal you know basically

1923
01:09:27,759 --> 01:09:29,600
says like you want to use qmu

1924
01:09:29,600 --> 01:09:30,640
the first instruction we're going to

1925
01:09:30,640 --> 01:09:33,040
jump to is at that particular location

1926
01:09:33,040 --> 01:09:36,319
and we basically arranged for the kernel

1927
01:09:36,319 --> 01:09:38,239
loader

1928
01:09:38,239 --> 01:09:40,719
to load the kernel of that program so

1929
01:09:40,719 --> 01:09:42,640
there's a file kernel ld

1930
01:09:42,640 --> 01:09:44,799
that basically specifies how the kernel

1931
01:09:44,799 --> 01:09:45,920
should be loaded

1932
01:09:45,920 --> 01:09:47,679
and you see here that basically the

1933
01:09:47,679 --> 01:09:49,520
first address that the kernel is going

1934
01:09:49,520 --> 01:09:50,960
to use is actually that particular

1935
01:09:50,960 --> 01:09:54,080
address that basic pmu specified

1936
01:09:54,080 --> 01:09:58,070
this is how we get off the ground

1937
01:09:58,080 --> 01:10:04,790
let's make that does that make sense

1938
01:10:04,800 --> 01:10:07,679
okay um and we see also that here

1939
01:10:07,679 --> 01:10:08,480
actually gdp

1940
01:10:08,480 --> 01:10:10,159
shows the binary encoding of the

1941
01:10:10,159 --> 01:10:11,600
instructions

1942
01:10:11,600 --> 01:10:13,440
and so we see that basically i guess the

1943
01:10:13,440 --> 01:10:17,280
csrr is a

1944
01:10:17,280 --> 01:10:19,120
four by destruction and an eye is a two

1945
01:10:19,120 --> 01:10:22,070
byte instruction

1946
01:10:22,080 --> 01:10:24,880
okay um so i'm going to see you know

1947
01:10:24,880 --> 01:10:26,080
basically so actually

1948
01:10:26,080 --> 01:10:29,280
six basically starts at entry.s uh and

1949
01:10:29,280 --> 01:10:31,199
we have no paging with no isolation and

1950
01:10:31,199 --> 01:10:33,199
in fact it starts in m mode

1951
01:10:33,199 --> 01:10:35,600
uh the exclusive jumps as quickly as

1952
01:10:35,600 --> 01:10:36,560
possible to

1953
01:10:36,560 --> 01:10:39,440
uh kernel mode or supervisor mode that's

1954
01:10:39,440 --> 01:10:40,480
called in risk five

1955
01:10:40,480 --> 01:10:42,000
i'm just going to set a breakpoint and

1956
01:10:42,000 --> 01:10:43,760
main uh which actually runs in

1957
01:10:43,760 --> 01:10:45,040
supervisor mode so i'm going to run

1958
01:10:45,040 --> 01:10:46,320
there

1959
01:10:46,320 --> 01:10:48,159
and then i get to the first instruction

1960
01:10:48,159 --> 01:10:50,640
of main so

1961
01:10:50,640 --> 01:10:53,840
let me show this here's main

1962
01:10:53,840 --> 01:10:57,199
and i'd like to run

1963
01:10:57,199 --> 01:11:01,910
gdb in this layout split mode

1964
01:11:01,920 --> 01:11:04,080
and so you can see in gdb actually and

1965
01:11:04,080 --> 01:11:05,520
what the next instruction is being

1966
01:11:05,520 --> 01:11:06,880
executed so you see there's a great

1967
01:11:06,880 --> 01:11:07,280
point

1968
01:11:07,280 --> 01:11:09,760
at that particular instruction since

1969
01:11:09,760 --> 01:11:10,840
this is a

1970
01:11:10,840 --> 01:11:14,239
wren uh qmu with one cpu

1971
01:11:14,239 --> 01:11:15,920
uh just makes it the gdp a little bit

1972
01:11:15,920 --> 01:11:18,320
easier so there's not only one core

1973
01:11:18,320 --> 01:11:21,120
active so commute emulates only one

1974
01:11:21,120 --> 01:11:22,159
single core

1975
01:11:22,159 --> 01:11:25,040
and i can step through that and so i can

1976
01:11:25,040 --> 01:11:26,480
go to the next instruction

1977
01:11:26,480 --> 01:11:28,000
and that is calls a function called

1978
01:11:28,000 --> 01:11:30,239
console init which does exactly what you

1979
01:11:30,239 --> 01:11:31,679
imagine it does it actually sets up the

1980
01:11:31,679 --> 01:11:32,880
console

1981
01:11:32,880 --> 01:11:34,719
and so once we set up the console we can

1982
01:11:34,719 --> 01:11:36,159
actually uh print to it

1983
01:11:36,159 --> 01:11:38,640
and so you'll see in a second we'll get

1984
01:11:38,640 --> 01:11:39,679
a new line

1985
01:11:39,679 --> 01:11:43,199
and we'll get xv6 booting okay so

1986
01:11:43,199 --> 01:11:46,000
there's a whole bunch of additional uh

1987
01:11:46,000 --> 01:11:48,560
code to set things up you know there's a

1988
01:11:48,560 --> 01:11:50,320
setting up the page allocator you know

1989
01:11:50,320 --> 01:11:51,920
setting up uh

1990
01:11:51,920 --> 01:11:53,360
virtual memory which i'll talk about on

1991
01:11:53,360 --> 01:11:55,360
wednesday loading actually starting

1992
01:11:55,360 --> 01:11:56,880
turning paging on which i also talked

1993
01:11:56,880 --> 01:11:58,239
about on wednesday

1994
01:11:58,239 --> 01:12:00,719
uh setting up the initial processes or

1995
01:12:00,719 --> 01:12:02,480
sending the process table

1996
01:12:02,480 --> 01:12:04,400
uh setting up code you know to do the

1997
01:12:04,400 --> 01:12:06,239
usual kernel transition

1998
01:12:06,239 --> 01:12:08,960
uh setting up the interrupt control the

1999
01:12:08,960 --> 01:12:09,440
click

2000
01:12:09,440 --> 01:12:11,120
uh we'll talk about when we talk about

2001
01:12:11,120 --> 01:12:12,480
interrupts but this is one like thing

2002
01:12:12,480 --> 01:12:13,280
that

2003
01:12:13,280 --> 01:12:15,280
uh we're going to be using to basically

2004
01:12:15,280 --> 01:12:17,440
talk to the disk or talk to the

2005
01:12:17,440 --> 01:12:19,840
console using interrupts uh sets up the

2006
01:12:19,840 --> 01:12:21,040
file system

2007
01:12:21,040 --> 01:12:23,520
allocates a buffer cache internet

2008
01:12:23,520 --> 01:12:24,239
emulation

2009
01:12:24,239 --> 01:12:26,400
initializes the inode cache initialize

2010
01:12:26,400 --> 01:12:28,960
the file system initializes the disk

2011
01:12:28,960 --> 01:12:31,040
and then basically once all sort of

2012
01:12:31,040 --> 01:12:32,400
things are set up you know when the

2013
01:12:32,400 --> 01:12:33,600
operating system is running

2014
01:12:33,600 --> 01:12:34,880
it's going to start running the first

2015
01:12:34,880 --> 01:12:38,000
process and this is the user in it

2016
01:12:38,000 --> 01:12:39,679
so this is a little bit of interesting

2017
01:12:39,679 --> 01:12:41,679
so i'm going to go to user init

2018
01:12:41,679 --> 01:12:43,360
for a second and i've got a single step

2019
01:12:43,360 --> 01:12:46,229
there

2020
01:12:46,239 --> 01:12:48,080
before continuing you know any questions

2021
01:12:48,080 --> 01:12:54,149
about this

2022
01:12:54,159 --> 01:12:56,400
is there a specific order in which the

2023
01:12:56,400 --> 01:12:58,480
setup functions need to be called

2024
01:12:58,480 --> 01:13:01,760
yes some function must be run after

2025
01:13:01,760 --> 01:13:02,560
other functions

2026
01:13:02,560 --> 01:13:05,440
and they're in particular in their some

2027
01:13:05,440 --> 01:13:06,719
of them doesn't matter but for you of

2028
01:13:06,719 --> 01:13:08,000
them yeah it's important that they run

2029
01:13:08,000 --> 01:13:11,270
after other ones

2030
01:13:11,280 --> 01:13:16,870
good point okay uh let me go to

2031
01:13:16,880 --> 01:13:19,679
uh so here's user in it and basically

2032
01:13:19,679 --> 01:13:21,040
user in it there's a little bit of

2033
01:13:21,040 --> 01:13:23,199
glue code or immunization code to sort

2034
01:13:23,199 --> 01:13:24,960
of take advantage of all the

2035
01:13:24,960 --> 01:13:26,880
general infrastructure that xv6 had to

2036
01:13:26,880 --> 01:13:28,239
basically get the first process of the

2037
01:13:28,239 --> 01:13:29,600
ground

2038
01:13:29,600 --> 01:13:31,840
you know x26 needs some image right we

2039
01:13:31,840 --> 01:13:34,239
can't run the file system really yet

2040
01:13:34,239 --> 01:13:37,760
or do exec and so the x36 needs sort of

2041
01:13:37,760 --> 01:13:39,120
a small little program to sort of get

2042
01:13:39,120 --> 01:13:39,840
off the ground

2043
01:13:39,840 --> 01:13:43,040
and that small little program is in its

2044
01:13:43,040 --> 01:13:44,080
code

2045
01:13:44,080 --> 01:13:45,679
and the binary version of that program

2046
01:13:45,679 --> 01:13:47,760
is actually linked or

2047
01:13:47,760 --> 01:13:50,159
declared statically into the kernel in

2048
01:13:50,159 --> 01:13:54,229
fact that code corresponds

2049
01:13:54,239 --> 01:14:00,239
to this particular user program

2050
01:14:00,239 --> 01:14:02,400
uh it's a but it's a little program

2051
01:14:02,400 --> 01:14:03,760
written in assembly

2052
01:14:03,760 --> 01:14:05,440
and basically it does it loads the

2053
01:14:05,440 --> 01:14:07,280
address within it into

2054
01:14:07,280 --> 01:14:10,080
a zero it draws the address of rv into

2055
01:14:10,080 --> 01:14:11,040
a1

2056
01:14:11,040 --> 01:14:12,960
and then it loads the number for this

2057
01:14:12,960 --> 01:14:14,880
exact system call into a7

2058
01:14:14,880 --> 01:14:18,400
and then look at here it calls e call

2059
01:14:18,400 --> 01:14:19,840
so basically what ina does is like

2060
01:14:19,840 --> 01:14:21,520
running three instructions

2061
01:14:21,520 --> 01:14:22,880
and then running the fourth instruction

2062
01:14:22,880 --> 01:14:25,760
to basically transfer back control to

2063
01:14:25,760 --> 01:14:30,159
the uh back control to the

2064
01:14:30,159 --> 01:14:31,840
operating system so for example if i set

2065
01:14:31,840 --> 01:14:33,679
a breakpoint in

2066
01:14:33,679 --> 01:14:36,560
syscall uh and i keep running then

2067
01:14:36,560 --> 01:14:37,600
basically you know

2068
01:14:37,600 --> 01:14:40,320
user init you know will create the

2069
01:14:40,320 --> 01:14:41,280
initial process

2070
01:14:41,280 --> 01:14:44,000
return to user space run these three

2071
01:14:44,000 --> 01:14:45,199
instructions

2072
01:14:45,199 --> 01:14:46,719
or four instructions and basically come

2073
01:14:46,719 --> 01:14:48,960
back into kernel space

2074
01:14:48,960 --> 01:14:50,400
so basically this is the first system

2075
01:14:50,400 --> 01:14:52,239
call that any user

2076
01:14:52,239 --> 01:14:54,320
application in xv6 runs so let's see

2077
01:14:54,320 --> 01:14:56,960
what happens if i'm right

2078
01:14:56,960 --> 01:14:59,440
so we're going to continue and we

2079
01:14:59,440 --> 01:15:01,120
actually got to syscall

2080
01:15:01,120 --> 01:15:04,630
so

2081
01:15:04,640 --> 01:15:06,960
so against this call we can look at it

2082
01:15:06,960 --> 01:15:09,280
it's a function at the bottom

2083
01:15:09,280 --> 01:15:11,760
and so we're back into kernel space now

2084
01:15:11,760 --> 01:15:13,520
and we can sort of walk through and see

2085
01:15:13,520 --> 01:15:14,960
actually what happens exactly

2086
01:15:14,960 --> 01:15:18,000
in syscall so i'm going to single step a

2087
01:15:18,000 --> 01:15:19,199
little bit

2088
01:15:19,199 --> 01:15:21,199
uh it looks about the current the

2089
01:15:21,199 --> 01:15:22,800
process is if it's in it you know

2090
01:15:22,800 --> 01:15:25,199
that pulls out the system call number

2091
01:15:25,199 --> 01:15:27,920
that's used so we can now print num

2092
01:15:27,920 --> 01:15:30,560
and we'll see it at seven and if we look

2093
01:15:30,560 --> 01:15:31,440
at

2094
01:15:31,440 --> 01:15:34,550
oops

2095
01:15:34,560 --> 01:15:38,560
user or kernel syscall.h

2096
01:15:38,560 --> 01:15:40,080
that declares all the system call

2097
01:15:40,080 --> 01:15:41,840
numbers and we see seven

2098
01:15:41,840 --> 01:15:45,120
that is indeed system called exec and so

2099
01:15:45,120 --> 01:15:46,640
basically this tells the kernel that you

2100
01:15:46,640 --> 01:15:46,880
know

2101
01:15:46,880 --> 01:15:49,840
some user application uh called an ecall

2102
01:15:49,840 --> 01:15:50,560
instruction

2103
01:15:50,560 --> 01:15:52,560
and with the intention of calling the

2104
01:15:52,560 --> 01:15:53,760
system call

2105
01:15:53,760 --> 01:15:58,000
for uh uh

2106
01:15:58,000 --> 01:15:59,280
with the intention of running the exact

2107
01:15:59,280 --> 01:16:01,840
system hall and so again we can single

2108
01:16:01,840 --> 01:16:03,040
step a little bit further

2109
01:16:03,040 --> 01:16:04,880
uh we go to the next thing this is the

2110
01:16:04,880 --> 01:16:06,480
line that executes the system call so

2111
01:16:06,480 --> 01:16:07,679
let's go there

2112
01:16:07,679 --> 01:16:09,840
and you see that basically the number is

2113
01:16:09,840 --> 01:16:11,760
used into index into an array

2114
01:16:11,760 --> 01:16:13,120
and the array has a bunch of function

2115
01:16:13,120 --> 01:16:14,800
pointers and

2116
01:16:14,800 --> 01:16:17,600
presumably the sys entry you know points

2117
01:16:17,600 --> 01:16:18,640
to the

2118
01:16:18,640 --> 01:16:20,880
sysex function so we're going to single

2119
01:16:20,880 --> 01:16:22,960
step into this

2120
01:16:22,960 --> 01:16:25,600
and we see that we're actually at the

2121
01:16:25,600 --> 01:16:29,830
system

2122
01:16:29,840 --> 01:16:33,520
so this is in sys file now we can move

2123
01:16:33,520 --> 01:16:34,880
it a little bit more

2124
01:16:34,880 --> 01:16:38,320
in a bigger window and we basically see

2125
01:16:38,320 --> 01:16:41,840
here the system call

2126
01:16:41,840 --> 01:16:43,199
and the first thing that you see is

2127
01:16:43,199 --> 01:16:45,120
actually it actually gets arguments from

2128
01:16:45,120 --> 01:16:47,679
user space so it gets the path name

2129
01:16:47,679 --> 01:16:50,960
so we can like jump a little bit further

2130
01:16:50,960 --> 01:16:57,110
uh mindsets

2131
01:16:57,120 --> 01:16:59,360
basically allocates space for arguments

2132
01:16:59,360 --> 01:17:00,800
you know copies all the arguments from

2133
01:17:00,800 --> 01:17:02,320
user space to kernel space

2134
01:17:02,320 --> 01:17:03,760
we'll look at that in great amount of

2135
01:17:03,760 --> 01:17:05,679
detail in a couple weeks so don't worry

2136
01:17:05,679 --> 01:17:07,199
about it too much yet

2137
01:17:07,199 --> 01:17:09,600
but basically there's some code to move

2138
01:17:09,600 --> 01:17:10,960
arguments from user space to kernel

2139
01:17:10,960 --> 01:17:12,400
space you know from the kernel

2140
01:17:12,400 --> 01:17:13,600
from the user address space to the

2141
01:17:13,600 --> 01:17:15,760
kernel address space and if we now look

2142
01:17:15,760 --> 01:17:16,000
at

2143
01:17:16,000 --> 01:17:18,800
path we can print the path hopefully and

2144
01:17:18,800 --> 01:17:20,800
we'll see actually that you know that is

2145
01:17:20,800 --> 01:17:21,679
a string

2146
01:17:21,679 --> 01:17:24,239
and we'll see that basically what that

2147
01:17:24,239 --> 01:17:25,280
little inner code

2148
01:17:25,280 --> 01:17:28,000
program does is trying to exec you know

2149
01:17:28,000 --> 01:17:28,800
the init

2150
01:17:28,800 --> 01:17:31,120
program which is yet another you know

2151
01:17:31,120 --> 01:17:32,719
program so let's look at that for a

2152
01:17:32,719 --> 01:17:34,320
second just to see

2153
01:17:34,320 --> 01:17:38,070
what that is

2154
01:17:38,080 --> 01:17:40,400
so here we have in it and in it

2155
01:17:40,400 --> 01:17:41,840
basically sets up a couple things

2156
01:17:41,840 --> 01:17:43,760
just for user space you know it opens to

2157
01:17:43,760 --> 01:17:45,199
console the file descriptor for the

2158
01:17:45,199 --> 01:17:46,480
console it dubs it

2159
01:17:46,480 --> 01:17:49,840
you know a couple times calls fork and

2160
01:17:49,840 --> 01:17:51,120
basically the first thing it does is

2161
01:17:51,120 --> 01:17:52,960
actually it tries to create a new

2162
01:17:52,960 --> 01:17:53,920
process

2163
01:17:53,920 --> 01:17:56,719
and it will exit the jail shell and so

2164
01:17:56,719 --> 01:17:57,600
this will

2165
01:17:57,600 --> 01:17:59,760
in the end result uh as the shell being

2166
01:17:59,760 --> 01:18:00,880
run

2167
01:18:00,880 --> 01:18:02,560
so for example if i would continue i

2168
01:18:02,560 --> 01:18:04,400
probably break again it says exec and if

2169
01:18:04,400 --> 01:18:06,080
i look at the arguments i will see that

2170
01:18:06,080 --> 01:18:06,960
actually

2171
01:18:06,960 --> 01:18:09,679
the exact system call is being called to

2172
01:18:09,679 --> 01:18:10,320
execs

2173
01:18:10,320 --> 01:18:12,719
the shell and once you accept the shell

2174
01:18:12,719 --> 01:18:14,480
you know let's do that

2175
01:18:14,480 --> 01:18:17,040
then we'll do a couple more system calls

2176
01:18:17,040 --> 01:18:21,430
and at some point we'll see the

2177
01:18:21,440 --> 01:18:23,040
continue then basically the shell starts

2178
01:18:23,040 --> 01:18:24,880
running

2179
01:18:24,880 --> 01:18:26,560
so it gives you a little bit of a sense

2180
01:18:26,560 --> 01:18:28,640
you know actually how xv6 gets off the

2181
01:18:28,640 --> 01:18:29,440
ground

2182
01:18:29,440 --> 01:18:31,600
how the first shell actually has to run

2183
01:18:31,600 --> 01:18:33,199
and we saw the sort of

2184
01:18:33,199 --> 01:18:34,800
a little bit of an overview about how

2185
01:18:34,800 --> 01:18:36,320
the first you know when the first system

2186
01:18:36,320 --> 01:18:38,159
call actually happened

2187
01:18:38,159 --> 01:18:39,760
we haven't really looked at the detail

2188
01:18:39,760 --> 01:18:41,600
machinery for these system calls now how

2189
01:18:41,600 --> 01:18:43,199
to get in and out of the kernel

2190
01:18:43,199 --> 01:18:44,320
we're going to talk about that in a

2191
01:18:44,320 --> 01:18:46,239
couple weeks or two weeks in the in

2192
01:18:46,239 --> 01:18:47,920
lecture in great amount of detail

2193
01:18:47,920 --> 01:18:49,679
but this is sort of enough for you to

2194
01:18:49,679 --> 01:18:51,440
understand actually how to do the uh

2195
01:18:51,440 --> 01:18:53,600
cisco lab you know that we assigned for

2196
01:18:53,600 --> 01:18:55,120
this week

2197
01:18:55,120 --> 01:18:56,480
and so these are the pieces that you

2198
01:18:56,480 --> 01:18:59,040
will be interacting with

2199
01:18:59,040 --> 01:19:01,199
any questions before i wrap up because

2200
01:19:01,199 --> 01:19:08,239
we're almost out of time

2201
01:19:08,239 --> 01:19:15,590
you're free to fire away

2202
01:19:15,600 --> 01:19:18,640
are we going to do anything with uh

2203
01:19:18,640 --> 01:19:22,080
networks or like networking and labs yes

2204
01:19:22,080 --> 01:19:23,199
the last lap is

2205
01:19:23,199 --> 01:19:25,440
uh you will implement a network driver

2206
01:19:25,440 --> 01:19:26,719
and so you will write the code that

2207
01:19:26,719 --> 01:19:28,159
interacts with the hardware and you have

2208
01:19:28,159 --> 01:19:29,280
to manipulate the

2209
01:19:29,280 --> 01:19:32,320
the registers of the network driver

2210
01:19:32,320 --> 01:19:35,199
uh over the network cart that basically

2211
01:19:35,199 --> 01:19:35,760
connects

2212
01:19:35,760 --> 01:19:37,440
you know to this risk 5 board you know

2213
01:19:37,440 --> 01:19:38,880
you saw that it was a block

2214
01:19:38,880 --> 01:19:40,960
basically to plug in an ethernet control

2215
01:19:40,960 --> 01:19:43,199
cable and so there's an ethernet

2216
01:19:43,199 --> 01:19:45,040
card and so you're going to be

2217
01:19:45,040 --> 01:19:46,239
programming that card and you're going

2218
01:19:46,239 --> 01:19:46,880
to

2219
01:19:46,880 --> 01:19:48,840
actually send some packets across the

2220
01:19:48,840 --> 01:19:51,679
internet

2221
01:19:51,679 --> 01:19:58,070
great thanks yeah it's the last lap

2222
01:19:58,080 --> 01:20:04,159
any other questions

2223
01:20:04,159 --> 01:20:06,000
okay let me wrap up here i think the

2224
01:20:06,000 --> 01:20:07,600
system called lab itself

2225
01:20:07,600 --> 01:20:10,159
um because we're not really going great

2226
01:20:10,159 --> 01:20:11,120
amount of detail

2227
01:20:11,120 --> 01:20:12,719
hopefully shouldn't be too bad uh might

2228
01:20:12,719 --> 01:20:14,880
be easier than the util app

2229
01:20:14,880 --> 01:20:17,280
uh the last next lap however might be

2230
01:20:17,280 --> 01:20:18,000
more difficult

2231
01:20:18,000 --> 01:20:19,440
and so it's always hard to get all these

2232
01:20:19,440 --> 01:20:21,440
labs right but this is collab hopefully

2233
01:20:21,440 --> 01:20:22,560
it shouldn't be uh

2234
01:20:22,560 --> 01:20:24,719
too difficult but please don't start

2235
01:20:24,719 --> 01:20:26,320
don't wait until the night before you

2236
01:20:26,320 --> 01:20:27,600
know get going early

2237
01:20:27,600 --> 01:20:28,960
so that if you're running some obscure

2238
01:20:28,960 --> 01:20:30,639
bug that we can actually help you out

2239
01:20:30,639 --> 01:20:32,080
and make sure that

2240
01:20:32,080 --> 01:20:35,199
your program works in the end

2241
01:20:35,199 --> 01:20:39,120
with that i'll sign off and i'll see you

2242
01:20:39,120 --> 01:20:47,840
in wednesday

