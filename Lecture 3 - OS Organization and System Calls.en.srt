1
00:00:07,270 --> 00:00:09,000
Yeah, am I loud and clear.

2
00:00:09,710 --> 00:00:11,540
Yeah, okay,

3
00:00:11,540 --> 00:00:12,650
great, um,

4
00:00:12,650 --> 00:00:14,180
so good afternoon or good evening

5
00:00:14,180 --> 00:00:15,590
or good morning or good night,

6
00:00:15,590 --> 00:00:17,580
wherever you are.

7
00:00:17,710 --> 00:00:20,440
Um, let's get started on the

8
00:00:20,440 --> 00:00:22,570
third lecture in 6.S081, which

9
00:00:22,570 --> 00:00:23,440
are going to be about,

10
00:00:23,440 --> 00:00:25,140
OS organization.

11
00:00:25,410 --> 00:00:28,950
And, a topics for today

12
00:00:28,950 --> 00:00:30,840
are, um,

13
00:00:32,200 --> 00:00:34,030
four things that I want to

14
00:00:34,030 --> 00:00:36,180
touch on. One is isolation,

15
00:00:36,440 --> 00:00:38,930
which you'll see is the driving

16
00:00:38,930 --> 00:00:40,160
design goal,

17
00:00:40,160 --> 00:00:41,360
for OS organization,

18
00:00:41,360 --> 00:00:43,070
now talk a little bit about

19
00:00:43,070 --> 00:00:45,600
kernel and user mode.

20
00:00:47,370 --> 00:00:49,350
That's a way of isolating the

21
00:00:49,350 --> 00:00:51,210
kernel from, or the operating system

22
00:00:51,210 --> 00:00:53,100
from a user applications.

23
00:00:53,380 --> 00:00:55,440
Um, they'll talk about system calls,

24
00:00:55,790 --> 00:00:58,430
which is a way for user

25
00:00:58,430 --> 00:01:00,770
applications to basically transition into the

26
00:01:00,770 --> 00:01:02,480
kernel, so they can ask

27
00:01:02,480 --> 00:01:04,010
for services and we look a

28
00:01:04,010 --> 00:01:06,140
little bit how it always instantiated

29
00:01:06,140 --> 00:01:08,270
in a simple form inside

30
00:01:08,270 --> 00:01:09,500
of xv6,

31
00:01:09,500 --> 00:01:10,970
so that is the point

32
00:01:10,970 --> 00:01:11,620
for today.

33
00:01:12,160 --> 00:01:15,460
Um, and you're [saying] sort of

34
00:01:15,460 --> 00:01:18,610
remind you a where we were

35
00:01:18,610 --> 00:01:21,060
after the first lecture.

36
00:01:21,290 --> 00:01:23,210
Um, the picture in your head,

37
00:01:23,210 --> 00:01:24,080
you should have in your head

38
00:01:24,080 --> 00:01:26,480
is you know there are processes

39
00:01:26,480 --> 00:01:29,260
like the shell, like echo.

40
00:01:29,590 --> 00:01:32,260
Um, were you know whatever,

41
00:01:34,280 --> 00:01:36,290
Find whatever some of utilities

42
00:01:36,290 --> 00:01:38,360
that you implement, they're running

43
00:01:38,360 --> 00:01:41,060
on top of an operating system.

44
00:01:42,520 --> 00:01:44,020
And you know the operating system

45
00:01:44,020 --> 00:01:44,590
of abstracts,

46
00:01:44,590 --> 00:01:45,070
you know some of the

47
00:01:45,070 --> 00:01:46,540
hardware resources.

48
00:01:46,800 --> 00:01:47,040
You know,

49
00:01:47,040 --> 00:01:49,320
like a disk or CPU,

50
00:01:49,320 --> 00:01:51,060
and you know basically the interface

51
00:01:51,060 --> 00:01:52,830
between the operating systems and the

52
00:01:52,830 --> 00:01:54,330
shells are typically referred to as

53
00:01:54,330 --> 00:01:55,530
a system call interface,

54
00:01:55,530 --> 00:01:56,880
an interface that we've been looking

55
00:01:56,880 --> 00:01:59,200
at is unix interface.

56
00:02:01,710 --> 00:02:03,720
And here what we see,

57
00:02:03,720 --> 00:02:05,880
um is,

58
00:02:05,880 --> 00:02:07,440
um, so that was roughly you

59
00:02:07,440 --> 00:02:09,660
know actually with that unique interface

60
00:02:09,660 --> 00:02:11,250
you've been playing around in

61
00:02:11,250 --> 00:02:12,090
lab 1, um,

62
00:02:12,090 --> 00:02:14,310
we're in util lab you used,

63
00:02:14,310 --> 00:02:15,780
you know the system call interface

64
00:02:15,780 --> 00:02:17,670
or unix API to actually implement

65
00:02:17,670 --> 00:02:19,060
different sets of applications.

66
00:02:19,480 --> 00:02:21,850
And so lab 1, a useful

67
00:02:21,850 --> 00:02:24,580
lab is mostly focused on using

68
00:02:24,580 --> 00:02:25,800
you know this part

69
00:02:26,100 --> 00:02:27,810
of the design picture

70
00:02:27,810 --> 00:02:29,190
here and what we're going

71
00:02:29,190 --> 00:02:30,780
to be doing now in

72
00:02:30,780 --> 00:02:32,130
this first lecture or this

73
00:02:32,130 --> 00:02:33,930
lecture in many subsequent lectures,

74
00:02:33,930 --> 00:02:35,910
we're gonna really look actually how

75
00:02:35,910 --> 00:02:38,020
the interface is actually implemented.

76
00:02:38,220 --> 00:02:39,300
And in fact almost all of

77
00:02:39,300 --> 00:02:41,370
the semester will be spending time

78
00:02:41,370 --> 00:02:43,380
on a figuring out actually how

79
00:02:43,380 --> 00:02:45,060
to implement interface and so this

80
00:02:45,060 --> 00:02:46,080
is going to be the first

81
00:02:46,080 --> 00:02:48,380
lecture of that kind of style.

82
00:02:48,590 --> 00:02:49,640
And, um,

83
00:02:49,640 --> 00:02:50,780
unfortunately, um,

84
00:02:50,780 --> 00:02:51,650
you know, a lot of you

85
00:02:51,650 --> 00:02:54,660
asking really great questions over email.

86
00:02:54,740 --> 00:02:56,960
Um, or submitted a great question

87
00:02:56,960 --> 00:02:57,920
to the website,

88
00:02:57,920 --> 00:02:59,900
um, and we won't be able

89
00:02:59,900 --> 00:03:01,580
to go into great amount of

90
00:03:01,580 --> 00:03:02,780
detail immediately in this sort of

91
00:03:02,780 --> 00:03:04,640
first lecture that types an inside

92
00:03:04,640 --> 00:03:05,960
look of the operating system,

93
00:03:05,960 --> 00:03:06,980
so we're going to touch on

94
00:03:06,980 --> 00:03:07,820
different things,

95
00:03:07,820 --> 00:03:09,320
but many things will become

96
00:03:09,320 --> 00:03:10,640
more clear,

97
00:03:10,640 --> 00:03:12,110
in subsequent lectures,

98
00:03:12,110 --> 00:03:13,190
we're going to explore in

99
00:03:13,190 --> 00:03:14,060
more depth.

100
00:03:14,520 --> 00:03:17,010
Um, but nevertheless, if there's

101
00:03:17,010 --> 00:03:18,180
something unclear,

102
00:03:18,180 --> 00:03:19,860
feel free to interrupt and ask

103
00:03:19,860 --> 00:03:20,920
a question.

104
00:03:22,020 --> 00:03:23,940
And maybe just to start off

105
00:03:23,940 --> 00:03:26,700
before actually going any further,

106
00:03:26,700 --> 00:03:27,930
let me ask you a question

107
00:03:27,930 --> 00:03:29,760
and sort of get the question

108
00:03:29,760 --> 00:03:30,210
and answering

109
00:03:30,210 --> 00:03:32,490
hopefully going, and ask you like

110
00:03:32,490 --> 00:03:34,350
what is the most interesting thing

111
00:03:34,350 --> 00:03:36,260
that you've learned from the

112
00:03:36,330 --> 00:03:38,490
util lab. And, I'll

113
00:03:38,490 --> 00:03:40,350
start by answering that question myself,

114
00:03:40,350 --> 00:03:41,790
um, one of the things that

115
00:03:41,790 --> 00:03:44,310
surprise me after writing or doing

116
00:03:44,310 --> 00:03:46,640
the util lab is that, um,

117
00:03:46,770 --> 00:03:48,390
I use 'xargs' a lot more

118
00:03:48,390 --> 00:03:49,680
frequently than I used to, I

119
00:03:49,680 --> 00:03:51,480
had another way of doing basically

120
00:03:51,480 --> 00:03:52,800
the same thing as xargs,

121
00:03:52,800 --> 00:03:56,790
a set of commands and after

122
00:03:56,790 --> 00:03:58,230
actually doing the xargs lab,

123
00:03:58,230 --> 00:03:59,550
[while there's] has much

124
00:03:59,550 --> 00:04:00,780
more convenient actually to use it

125
00:04:00,780 --> 00:04:01,380
in that way.

126
00:04:01,380 --> 00:04:02,580
And so since then,

127
00:04:02,580 --> 00:04:04,440
I mean a much more aggressive

128
00:04:04,440 --> 00:04:06,660
user of xargs and I'm

129
00:04:06,660 --> 00:04:10,590
just wondering what the experience has

130
00:04:10,590 --> 00:04:12,870
been for some of you, maybe

131
00:04:12,870 --> 00:04:14,700
I'll call out a few names

132
00:04:14,700 --> 00:04:16,680
and maybe you can unmute your

133
00:04:16,680 --> 00:04:18,390
microphone answer, let's say,

134
00:04:18,390 --> 00:04:20,310
um, let's say a little bit

135
00:04:20,310 --> 00:04:22,600
about your experience with util lab.

136
00:04:23,350 --> 00:04:25,450
Um, so let me pick

137
00:04:25,450 --> 00:04:26,170
some people,

138
00:04:26,170 --> 00:04:27,680
um, Andrew You.

139
00:04:33,100 --> 00:04:35,890
Andrew, are you online listening?

140
00:04:35,890 --> 00:04:37,300
um, the most interesting thing for

141
00:04:37,300 --> 00:04:38,780
me was just the pipes,

142
00:04:39,060 --> 00:04:41,000
learn how to write concurrent programs.

143
00:04:42,080 --> 00:04:43,640
Good, have you done any sort

144
00:04:43,640 --> 00:04:45,170
of pipe programming before?

145
00:04:45,170 --> 00:04:46,550
No, I haven't, I've

146
00:04:46,550 --> 00:04:47,780
seen the all concurrent stuff,

147
00:04:47,780 --> 00:04:48,860
but I haven't seen like OS

148
00:04:48,860 --> 00:04:50,240
level pipes before.

149
00:04:51,660 --> 00:04:53,740
How about Elizabeth Weeks.

150
00:04:55,360 --> 00:04:57,130
Yeah, I'd agree with that I

151
00:04:57,130 --> 00:04:59,470
also thought that the OS pipes

152
00:04:59,470 --> 00:05:00,850
are super interesting and like the

153
00:05:00,850 --> 00:05:02,180
primes, um,

154
00:05:02,450 --> 00:05:05,150
example specifically was cool to kind

155
00:05:05,150 --> 00:05:06,500
of figure out and realize that

156
00:05:06,500 --> 00:05:08,000
I need to close certain pipes

157
00:05:08,000 --> 00:05:08,980
and just like, are they kind of

158
00:05:09,560 --> 00:05:12,440
related to each other. Yeah, yeah I remember

159
00:05:12,440 --> 00:05:13,760
you did find the types of

160
00:05:13,760 --> 00:05:15,020
crimes are a little bit harder

161
00:05:15,020 --> 00:05:16,180
than, a,

162
00:05:16,450 --> 00:05:18,970
you might have thought this surprises

163
00:05:18,970 --> 00:05:20,350
me every time a little bit

164
00:05:20,350 --> 00:05:21,540
tricky to get right.

165
00:05:23,340 --> 00:05:24,620
Jessica She.

166
00:05:26,320 --> 00:05:29,170
I also thought the primes exercise

167
00:05:29,170 --> 00:05:30,800
was most interesting.

168
00:05:33,080 --> 00:05:33,920
Did it take you a lot

169
00:05:33,920 --> 00:05:35,090
of time or was it not

170
00:05:35,090 --> 00:05:35,920
too bad.

171
00:05:36,610 --> 00:05:40,690
Um, it took me more time

172
00:05:40,690 --> 00:05:42,370
after I realized my initial implementation

173
00:05:42,370 --> 00:05:44,110
wasn't actually concurrent so it's interesting

174
00:05:44,110 --> 00:05:45,280
to think about like,

175
00:05:45,520 --> 00:05:47,040
what the differences are there.

176
00:05:47,750 --> 00:05:50,580
Okay, how about Robert Murphy.

177
00:05:53,970 --> 00:05:56,180
Yeah, I think that, the,

178
00:05:56,660 --> 00:05:59,720
my experience was really just, I

179
00:05:59,720 --> 00:06:01,730
found it really challenging to program

180
00:06:01,730 --> 00:06:03,680
in the original way,

181
00:06:03,680 --> 00:06:04,370
it was set up so I

182
00:06:04,370 --> 00:06:05,660
actually created a bunch of helper

183
00:06:05,660 --> 00:06:07,400
functions that wrapped around things,

184
00:06:08,290 --> 00:06:09,580
So that's I guess what

185
00:06:09,580 --> 00:06:10,120
I did.

186
00:06:13,730 --> 00:06:15,530
Ok, any idea who have sort of

187
00:06:15,530 --> 00:06:17,760
any piece of wisdom.

188
00:06:18,000 --> 00:06:20,730
Amanda, go ahead. I kind

189
00:06:20,730 --> 00:06:21,540
of liked it and found it

190
00:06:21,540 --> 00:06:24,630
surprising slash cool that stdin

191
00:06:24,630 --> 00:06:26,730
and stdout are just filed

192
00:06:26,730 --> 00:06:28,740
scriptures themselves 0 and 1.

193
00:06:28,830 --> 00:06:29,780
Yeah yeah.

194
00:06:30,140 --> 00:06:31,250
Good,

195
00:06:31,250 --> 00:06:33,050
yeah xv6 doesn't hide that from

196
00:06:33,050 --> 00:06:33,740
you at all,

197
00:06:33,740 --> 00:06:35,540
um, at least in a normal C

198
00:06:35,540 --> 00:06:36,230
library,

199
00:06:36,230 --> 00:06:37,160
that's a little bit wrapped up

200
00:06:37,160 --> 00:06:37,880
in a,

201
00:06:38,000 --> 00:06:40,280
um, in an interface,

202
00:06:40,280 --> 00:06:42,650
but, um xv6 doesn't hide it for you,

203
00:06:42,650 --> 00:06:43,520
but in the end it boils

204
00:06:43,520 --> 00:06:45,200
down indeed to know just file

205
00:06:45,200 --> 00:06:46,760
descriptor 0 1 and 2 I

206
00:06:46,760 --> 00:06:47,840
guess for standard error.

207
00:06:53,900 --> 00:06:55,190
Good, Alexander. Um, I guess,

208
00:06:55,190 --> 00:06:57,320
um, one thing I was surprised

209
00:06:57,320 --> 00:06:59,120
about was also from the

210
00:06:59,120 --> 00:07:01,300
primes problem.

211
00:07:02,920 --> 00:07:04,600
I had this bug that I

212
00:07:04,600 --> 00:07:06,910
spent hours on and the thing

213
00:07:06,910 --> 00:07:08,500
was that I didn't realize that

214
00:07:08,500 --> 00:07:11,380
actually they were whenever you were

215
00:07:14,050 --> 00:07:15,970
opening a pipe and then for

216
00:07:15,970 --> 00:07:18,670
like calling fork then basically they

217
00:07:18,670 --> 00:07:20,060
were before,

218
00:07:20,260 --> 00:07:22,600
um, ends to the pipe because

219
00:07:22,600 --> 00:07:24,760
that pipe is kind of a

220
00:07:24,760 --> 00:07:26,740
goes both to the child process

221
00:07:26,740 --> 00:07:28,760
and the process the parent process.

222
00:07:29,080 --> 00:07:30,550
And but I was only closing

223
00:07:30,550 --> 00:07:32,640
two of those.

224
00:07:33,010 --> 00:07:33,490
So, yeah,

225
00:07:33,490 --> 00:07:36,940
that was a common, common problem.

226
00:07:36,940 --> 00:07:38,140
It made sense,

227
00:07:38,140 --> 00:07:39,280
but for some reason,

228
00:07:39,280 --> 00:07:42,190
because especially the textbook says that

229
00:07:42,190 --> 00:07:44,920
when you fork, all of

230
00:07:44,920 --> 00:07:47,340
the open file descriptors get copied,

231
00:07:47,440 --> 00:07:49,960
but I didn't think about it that. Yeah,

232
00:07:49,960 --> 00:07:50,620
it's hard to I mean

233
00:07:50,620 --> 00:07:51,370
there's a lot of details

234
00:07:51,370 --> 00:07:52,000
in that interface,

235
00:07:52,000 --> 00:07:52,840
and you know the only way

236
00:07:52,840 --> 00:07:54,460
to get actually really familiar with

237
00:07:54,460 --> 00:07:56,200
actually the program with it,

238
00:07:56,940 --> 00:07:58,320
experience it.

239
00:07:58,880 --> 00:07:59,750
Good good,

240
00:07:59,750 --> 00:08:00,770
well, I hope you enjoyed

241
00:08:00,770 --> 00:08:01,400
the lab,

242
00:08:01,400 --> 00:08:02,360
um, and,

243
00:08:02,360 --> 00:08:03,290
of course I hope you enjoy

244
00:08:03,290 --> 00:08:04,640
the subsequent labs too,

245
00:08:04,640 --> 00:08:05,600
so the lecture for today,

246
00:08:05,600 --> 00:08:06,800
in some sense is really you

247
00:08:06,800 --> 00:08:08,510
know partially to help you to

248
00:08:08,510 --> 00:08:12,230
get going on the syscall lab,

249
00:08:12,230 --> 00:08:13,790
if you haven't already started and

250
00:08:13,790 --> 00:08:14,480
so again,

251
00:08:14,480 --> 00:08:15,980
you feel free to interrupt

252
00:08:15,980 --> 00:08:16,980
and ask questions.

253
00:08:17,550 --> 00:08:18,780
Okay, so the first thing I

254
00:08:18,780 --> 00:08:21,720
want to do is,

255
00:08:22,000 --> 00:08:23,500
talk a little bit

256
00:08:23,500 --> 00:08:25,210
about isolation,

257
00:08:25,210 --> 00:08:26,770
um, and you know why it's

258
00:08:26,770 --> 00:08:29,290
important and why we might care,

259
00:08:29,290 --> 00:08:30,820
you know the basic stories are

260
00:08:30,820 --> 00:08:32,050
reasonable simple,

261
00:08:32,050 --> 00:08:33,490
you know we have multiple applications,

262
00:08:33,490 --> 00:08:34,420
here, we got the shell,

263
00:08:34,420 --> 00:08:36,130
the echo we find and it'll

264
00:08:36,130 --> 00:08:37,060
be great [correct],

265
00:08:37,060 --> 00:08:37,990
if you had a bug in

266
00:08:37,990 --> 00:08:39,550
the shell or example in your

267
00:08:39,550 --> 00:08:40,720
primes program,

268
00:08:40,720 --> 00:08:42,250
that actually didn't affect any

269
00:08:42,250 --> 00:08:43,450
of the other applications,

270
00:08:43,450 --> 00:08:44,740
particularly it would be bad, for

271
00:08:44,740 --> 00:08:46,030
example if it affected the shell

272
00:08:46,030 --> 00:08:47,620
because probably the shell you're using

273
00:08:47,620 --> 00:08:49,240
to actually kill the program,

274
00:08:49,240 --> 00:08:50,420
if something goes bad.

275
00:08:50,960 --> 00:08:53,240
So you want sort of strong isolation

276
00:08:53,240 --> 00:08:55,480
between these different applications.

277
00:08:55,870 --> 00:08:58,000
A similarly you know the OS

278
00:08:58,000 --> 00:08:59,470
is sort of a servant for

279
00:08:59,470 --> 00:09:00,730
all the applications,

280
00:09:00,730 --> 00:09:01,960
um, and you would like it

281
00:09:01,960 --> 00:09:02,920
to be the case now you

282
00:09:02,920 --> 00:09:04,660
know if you know you make

283
00:09:04,660 --> 00:09:05,710
a bug in one of your

284
00:09:05,710 --> 00:09:07,270
util programs, that actually the operating

285
00:09:07,270 --> 00:09:09,280
system doesn't crash, until you pass some

286
00:09:09,280 --> 00:09:11,590
strange argument to the operating system,

287
00:09:11,590 --> 00:09:12,670
you should be the case that

288
00:09:12,670 --> 00:09:14,440
the operating system handles that well.

289
00:09:14,720 --> 00:09:15,920
And so again we would like

290
00:09:15,920 --> 00:09:16,520
to be there,

291
00:09:16,520 --> 00:09:19,540
strong isolation between,

292
00:09:19,730 --> 00:09:22,910
um, the applications and the operating

293
00:09:22,910 --> 00:09:23,900
system itself.

294
00:09:24,400 --> 00:09:25,960
Um, and one way to think

295
00:09:25,960 --> 00:09:26,920
about this a little bit is

296
00:09:26,920 --> 00:09:28,450
to say is ask ourselves the

297
00:09:28,450 --> 00:09:30,520
question you know what would happen

298
00:09:30,520 --> 00:09:32,830
if there's actually no operating system

299
00:09:32,830 --> 00:09:34,480
so you know consider some

300
00:09:34,480 --> 00:09:36,300
Strawman design, design,

301
00:09:41,670 --> 00:09:43,120
there is no operating system.

302
00:09:45,400 --> 00:09:46,390
Or you could think about it

303
00:09:46,390 --> 00:09:47,890
as the operating system is [],

304
00:09:47,890 --> 00:09:49,420
just being a library,

305
00:09:49,420 --> 00:09:50,440
you know sort of thinking about

306
00:09:50,440 --> 00:09:52,120
in terms of python,

307
00:09:52,120 --> 00:09:53,860
maybe just import OS,

308
00:09:53,860 --> 00:09:55,360
and import OS basically loads

309
00:09:55,360 --> 00:09:57,130
the whole operating system inside

310
00:09:57,130 --> 00:09:58,870
of your application and that's

311
00:09:58,870 --> 00:09:59,980
then the programming interface,

312
00:09:59,980 --> 00:10:01,180
you use.

313
00:10:01,720 --> 00:10:02,770
And so you think about

314
00:10:02,770 --> 00:10:04,150
that sort of way of

315
00:10:04,150 --> 00:10:05,230
thinking so let's say we

316
00:10:05,230 --> 00:10:06,460
have shell here,

317
00:10:06,460 --> 00:10:06,670
you know,

318
00:10:06,670 --> 00:10:09,790
maybe it includes the library for

319
00:10:09,790 --> 00:10:11,830
the OS and now maybe we

320
00:10:11,830 --> 00:10:14,000
have some other application echo.

321
00:10:14,490 --> 00:10:16,260
Um, and then basically you know

322
00:10:16,260 --> 00:10:18,080
these applications.

323
00:10:18,180 --> 00:10:20,520
If there's no operating system really,

324
00:10:20,520 --> 00:10:22,720
would directly interact with the hardware.

325
00:10:23,200 --> 00:10:23,920
For example,

326
00:10:23,920 --> 00:10:25,360
you know they would actually see

327
00:10:25,360 --> 00:10:26,860
you know there's a CPU core

328
00:10:26,860 --> 00:10:28,600
there's another CPU core.

329
00:10:28,840 --> 00:10:30,340
Um, and you know maybe there's

330
00:10:30,340 --> 00:10:31,780
a disk and then we interact

331
00:10:31,780 --> 00:10:33,070
directly with the disk blocks, and

332
00:10:33,070 --> 00:10:34,450
maybe there's memory and they were

333
00:10:34,450 --> 00:10:35,860
directly interact with the memory of

334
00:10:35,860 --> 00:10:36,600
the machine.

335
00:10:37,380 --> 00:10:39,090
Um, and so there's no layer

336
00:10:39,090 --> 00:10:41,730
between, no abstraction layer between basically

337
00:10:41,730 --> 00:10:42,780
the applications

338
00:10:42,780 --> 00:10:45,480
and the hardware, and it

339
00:10:45,480 --> 00:10:47,040
turns out that it's just not

340
00:10:47,040 --> 00:10:48,420
such a great design,

341
00:10:48,420 --> 00:10:51,100
um, for isolation.

342
00:10:51,540 --> 00:10:52,860
And you can see how isolation

343
00:10:52,860 --> 00:10:54,000
might be broken,

344
00:10:54,000 --> 00:10:56,070
let's assume for example that you

345
00:10:56,070 --> 00:10:57,240
know one of the goal,

346
00:10:57,240 --> 00:10:58,890
operating system is run

347
00:10:58,890 --> 00:11:00,320
multiple applications.

348
00:11:00,330 --> 00:11:01,020
And so,

349
00:11:01,020 --> 00:11:02,100
there has to be the case

350
00:11:02,100 --> 00:11:03,270
that once in a while,

351
00:11:03,270 --> 00:11:05,010
it will switch from one application

352
00:11:05,010 --> 00:11:05,910
to another application,

353
00:11:05,910 --> 00:11:07,320
let's say the hardware has only

354
00:11:07,320 --> 00:11:09,660
one CPU and so we're running

355
00:11:09,660 --> 00:11:11,490
the shell say about one CPU,

356
00:11:11,490 --> 00:11:12,720
but they are periodically in

357
00:11:12,720 --> 00:11:13,890
other applications should be able

358
00:11:13,890 --> 00:11:14,720
to run to.

359
00:11:15,520 --> 00:11:17,470
Well, we have no operating system

360
00:11:17,470 --> 00:11:18,670
to do for us,

361
00:11:18,670 --> 00:11:20,140
then the shell basically has to

362
00:11:20,140 --> 00:11:20,650
give up,

363
00:11:20,650 --> 00:11:21,600
you know the

364
00:11:21,630 --> 00:11:23,080
CPU once in a while.

365
00:11:24,220 --> 00:11:25,060
And sort of be a nice

366
00:11:25,060 --> 00:11:27,190
person, and say well I've run

367
00:11:27,190 --> 00:11:28,360
for a little while, you get

368
00:11:28,360 --> 00:11:29,560
a chance to run and there's

369
00:11:29,560 --> 00:11:31,420
something just called cooperative scheduling.

370
00:11:31,840 --> 00:11:33,550
Um, but it's not so great

371
00:11:33,550 --> 00:11:34,540
for isolation,

372
00:11:34,540 --> 00:11:35,140
for example,

373
00:11:35,140 --> 00:11:37,150
what if some function in the

374
00:11:37,150 --> 00:11:38,920
shell has an infinite loop,

375
00:11:38,920 --> 00:11:40,690
and therefore it will never actually

376
00:11:40,690 --> 00:11:41,720
give up the CPU.

377
00:11:41,880 --> 00:11:42,210
And then,

378
00:11:42,210 --> 00:11:44,310
no other applications could run

379
00:11:44,310 --> 00:11:46,110
including maybe the application that would

380
00:11:46,110 --> 00:11:48,140
like stop or kill the shell.

381
00:11:48,580 --> 00:11:49,300
And so,

382
00:11:49,300 --> 00:11:50,860
um, we basically don't get

383
00:11:50,860 --> 00:11:51,940
any sort of form of

384
00:11:51,940 --> 00:11:53,680
enforced multiplexing.

385
00:11:54,090 --> 00:11:55,350
That's something that we'd like to

386
00:11:55,350 --> 00:11:57,420
have, where no matter what the

387
00:11:57,420 --> 00:11:59,640
application does, it will be forced

388
00:11:59,640 --> 00:12:00,810
to give up the CPU once

389
00:12:00,810 --> 00:12:01,500
in a while,

390
00:12:01,500 --> 00:12:03,540
that's what other applications go up.

391
00:12:04,760 --> 00:12:06,260
Similarly, if you think about this

392
00:12:06,260 --> 00:12:08,660
drama and design, you know

393
00:12:08,660 --> 00:12:10,820
we have there's a physical memory

394
00:12:10,820 --> 00:12:12,260
right and all I drew a

395
00:12:12,260 --> 00:12:13,250
picture here,

396
00:12:13,250 --> 00:12:14,390
so the application sitting on the

397
00:12:14,390 --> 00:12:15,350
top of the hardware,

398
00:12:15,350 --> 00:12:17,630
but you know there's physical memory

399
00:12:17,630 --> 00:12:19,700
and basically detects in the code

400
00:12:19,700 --> 00:12:21,290
and the data for these applications

401
00:12:21,290 --> 00:12:22,910
actually sits in the physical memory,

402
00:12:22,910 --> 00:12:24,000
it's a huge memory.

403
00:12:24,730 --> 00:12:27,190
And here's maybe you know the

404
00:12:27,190 --> 00:12:28,120
part of physical memory,

405
00:12:28,120 --> 00:12:29,620
that's used by the shell,

406
00:12:29,620 --> 00:12:30,700
here's maybe a part of

407
00:12:30,700 --> 00:12:32,050
a physical memory that's used

408
00:12:32,050 --> 00:12:34,040
by echo application.

409
00:12:34,760 --> 00:12:36,890
And so you're going to again

410
00:12:36,890 --> 00:12:37,760
what was see here,

411
00:12:37,760 --> 00:12:39,860
if you'd like simply simplistically

412
00:12:39,860 --> 00:12:40,670
like this,

413
00:12:40,670 --> 00:12:44,150
um, there sure know a boundary

414
00:12:44,150 --> 00:12:45,960
between these two guys.

415
00:12:46,150 --> 00:12:46,810
For example,

416
00:12:46,810 --> 00:12:48,480
if echo

417
00:12:49,110 --> 00:12:51,900
stores through location, the example belongs

418
00:12:51,900 --> 00:12:54,540
to shell like location at 1000

419
00:12:54,540 --> 00:12:56,240
and writes value there.

420
00:12:56,410 --> 00:12:56,620
You know,

421
00:12:56,620 --> 00:12:58,540
whatever "x", then it will

422
00:12:58,540 --> 00:13:00,310
just overwrite the physical memory of

423
00:13:00,310 --> 00:13:02,080
the shell memory.

424
00:13:02,380 --> 00:13:03,280
And so that you know be

425
00:13:03,280 --> 00:13:05,410
pretty undesirable, because then a bug,

426
00:13:05,410 --> 00:13:07,030
you know echo could actually percolate

427
00:13:07,030 --> 00:13:08,740
into the shell and you know

428
00:13:08,740 --> 00:13:09,790
it's gonna be very tricky to

429
00:13:09,790 --> 00:13:10,900
debug that kind of stuff, and

430
00:13:10,900 --> 00:13:12,550
so this basically again, gives us

431
00:13:12,550 --> 00:13:14,840
like no strong isolation.

432
00:13:15,350 --> 00:13:16,800
What we like is

433
00:13:17,600 --> 00:13:19,700
to have a memory isolation,

434
00:13:19,700 --> 00:13:22,430
so that one application cannot overwrite

435
00:13:22,430 --> 00:13:25,500
means, memory of another application.

436
00:13:26,190 --> 00:13:28,100
Um,

437
00:13:28,640 --> 00:13:30,410
and so you know,

438
00:13:30,410 --> 00:13:32,510
one reason, you know I mean, probably the

439
00:13:32,510 --> 00:13:33,890
main reason to actually have an

440
00:13:33,890 --> 00:13:36,380
operating system is basically to enforce

441
00:13:36,380 --> 00:13:39,860
both multiplexing, enforce you know,

442
00:13:39,860 --> 00:13:41,380
strong memory isolation.

443
00:13:41,520 --> 00:13:42,390
If you didn't have an

444
00:13:42,390 --> 00:13:43,800
operating system and the applications are

445
00:13:43,800 --> 00:13:45,690
directly interacting with the hardware that

446
00:13:45,690 --> 00:13:47,200
would be very hard to achieve.

447
00:13:48,050 --> 00:13:50,390
So this design of basically operating

448
00:13:50,390 --> 00:13:52,040
system as a library is not

449
00:13:52,040 --> 00:13:53,120
a very common design,

450
00:13:53,120 --> 00:13:54,440
you may see things some real-time

451
00:13:54,440 --> 00:13:56,960
systems where basically applications trust each

452
00:13:56,960 --> 00:13:59,030
other, but in most other

453
00:13:59,030 --> 00:14:00,110
operating systems,

454
00:14:00,110 --> 00:14:01,400
you know there's an operating system

455
00:14:01,400 --> 00:14:02,810
that really enforce you know that

456
00:14:02,810 --> 00:14:03,980
kind of isolation.

457
00:14:05,460 --> 00:14:06,960
So if we look a little

458
00:14:06,960 --> 00:14:09,000
bit now, at the unix interface

459
00:14:09,000 --> 00:14:10,300
from this perspective.

460
00:14:14,350 --> 00:14:16,120
Then we see that the interface

461
00:14:16,120 --> 00:14:18,100
actually is carefully designed.

462
00:14:18,650 --> 00:14:21,410
So that actually is feasible to

463
00:14:21,410 --> 00:14:23,900
implement that enforced

464
00:14:23,940 --> 00:14:26,760
um, isolation in terms of multiplexing

465
00:14:26,760 --> 00:14:28,500
in terms of physical memory

466
00:14:28,500 --> 00:14:30,030
and the way that is done

467
00:14:30,030 --> 00:14:32,100
is that the interface basically

468
00:14:32,100 --> 00:14:34,160
abstracts the hardware,

469
00:14:37,370 --> 00:14:38,860
hardware resources.

470
00:14:40,940 --> 00:14:42,350
In a way that then it

471
00:14:42,350 --> 00:14:44,390
makes it easy to actually do

472
00:14:44,390 --> 00:14:45,800
or not easier. It makes it

473
00:14:45,800 --> 00:14:47,360
possible to um,

474
00:14:47,360 --> 00:14:49,680
provide you know this strong isolation.

475
00:14:50,280 --> 00:14:51,930
Um, and you know maybe you

476
00:14:51,930 --> 00:14:53,280
should give you some examples,

477
00:14:53,280 --> 00:14:55,980
um, so processes we've seen

478
00:14:55,980 --> 00:14:56,790
that like things that are

479
00:14:56,790 --> 00:14:58,120
created by fork.

480
00:14:59,760 --> 00:15:01,650
You know they're not literally a

481
00:15:01,650 --> 00:15:05,100
CPU right, I mean, they correspond to what

482
00:15:05,100 --> 00:15:06,510
cpus that allows you to

483
00:15:06,510 --> 00:15:07,820
run computation.

484
00:15:07,910 --> 00:15:08,630
But you know,

485
00:15:08,630 --> 00:15:10,520
because you know they're the applicants

486
00:15:10,520 --> 00:15:12,530
cannot directly interact with this CPU,

487
00:15:12,530 --> 00:15:14,630
but only for this process abstraction,

488
00:15:14,630 --> 00:15:17,090
the kernel behind the scenes you

489
00:15:17,090 --> 00:15:18,940
can switch between processes.

490
00:15:20,300 --> 00:15:22,640
So instead of having direct CPU

491
00:15:22,640 --> 00:15:25,040
used to manipulate or given to

492
00:15:25,040 --> 00:15:25,940
the application,

493
00:15:25,940 --> 00:15:28,550
the operation provides processes that extract

494
00:15:28,550 --> 00:15:30,230
away to the CPU itself,

495
00:15:30,230 --> 00:15:31,850
so that actually the operating system

496
00:15:31,850 --> 00:15:34,280
multiplex, and one CPU or multiple

497
00:15:34,280 --> 00:15:36,220
cpus among multiple applications.

498
00:15:37,200 --> 00:15:38,900
Similarly, if you think about exec,

499
00:15:39,970 --> 00:15:42,360
exec provides a memory image.

500
00:15:42,970 --> 00:15:45,550
Um, and um.

501
00:15:45,550 --> 00:15:46,150
Amanda, yeah,

502
00:15:46,150 --> 00:15:46,720
go ahead,

503
00:15:46,720 --> 00:15:47,780
ask your question.

504
00:15:47,930 --> 00:15:49,610
One question about processes,

505
00:15:49,610 --> 00:15:53,270
sort of like abstracting the CPU.

506
00:15:53,270 --> 00:15:54,400
Is that

507
00:15:55,070 --> 00:15:57,290
one process uses part of the

508
00:15:57,290 --> 00:16:00,620
CPU and another process uses, a

509
00:16:00,620 --> 00:16:02,240
more, a different part of that

510
00:16:02,240 --> 00:16:03,770
CPU or a different CPU,

511
00:16:03,770 --> 00:16:05,570
if it's a multi-core

512
00:16:05,570 --> 00:16:06,360
or like.

513
00:16:06,450 --> 00:16:07,800
What do you mean by processes

514
00:16:07,800 --> 00:16:09,030
instead of the CPU?

515
00:16:09,030 --> 00:16:10,830
Yeah, okay so I really mean

516
00:16:10,830 --> 00:16:13,380
one CPU abstracted away into a

517
00:16:13,380 --> 00:16:14,550
process, so okay so, the way

518
00:16:14,550 --> 00:16:16,110
to think about it is

519
00:16:16,110 --> 00:16:19,110
RISC-V core or RISC-V processor that

520
00:16:19,110 --> 00:16:21,300
we're using in the lab is

521
00:16:21,300 --> 00:16:22,580
actually four cores.

522
00:16:22,930 --> 00:16:24,190
Um, and so you can run

523
00:16:24,190 --> 00:16:27,040
four processes concurrently or in parallel,

524
00:16:27,040 --> 00:16:28,880
one process on each core.

525
00:16:29,260 --> 00:16:30,670
And what the operating system does

526
00:16:30,670 --> 00:16:31,810
is let's say you have eight

527
00:16:31,810 --> 00:16:33,790
applications or seven applications,

528
00:16:33,790 --> 00:16:35,320
it will take some core and

529
00:16:35,320 --> 00:16:37,870
multiplexes, time multiplexes between

530
00:16:37,870 --> 00:16:38,590
different processes.

531
00:16:38,590 --> 00:16:40,390
So for example it will run

532
00:16:40,390 --> 00:16:42,840
you one app process for 100 milliseconds,

533
00:16:42,990 --> 00:16:45,900
then stop, unload that process out

534
00:16:45,900 --> 00:16:47,430
of the CPU or out of

535
00:16:47,430 --> 00:16:48,390
the core,

536
00:16:48,390 --> 00:16:49,770
loading the next

537
00:16:49,770 --> 00:16:52,530
application, or next process that runs

538
00:16:52,530 --> 00:16:54,270
out for 100 milliseconds, and

539
00:16:54,270 --> 00:16:56,040
it just enforces that no application

540
00:16:56,040 --> 00:16:57,120
can run or no process can

541
00:16:57,120 --> 00:16:58,050
run longer than 100 milliseconds.

542
00:16:59,260 --> 00:17:00,640
We'll see exactly how this was

543
00:17:00,640 --> 00:17:02,080
done in a couple lectures, but

544
00:17:02,080 --> 00:17:03,420
that's sort of the basic idea.

545
00:17:04,200 --> 00:17:06,630
Okay, but multiple processes cannot use

546
00:17:06,630 --> 00:17:08,010
the same CPU at the same time.

547
00:17:08,010 --> 00:17:11,310
No, it's time multiplexing, you're running

548
00:17:11,310 --> 00:17:12,330
for a while then you're run

549
00:17:12,330 --> 00:17:13,520
the next one for a while.

550
00:17:14,050 --> 00:17:15,080
Alright, thank you.

551
00:17:16,130 --> 00:17:17,150
Okay, so um,

552
00:17:17,150 --> 00:17:18,590
one way to think about exec

553
00:17:18,590 --> 00:17:22,760
is that actually abstracts memory.

554
00:17:28,400 --> 00:17:29,330
So, for example if you

555
00:17:29,330 --> 00:17:30,170
think about,

556
00:17:30,170 --> 00:17:32,180
um, the exec system call you

557
00:17:32,180 --> 00:17:33,260
know takes a file name,

558
00:17:33,260 --> 00:17:34,760
you know and in that file

559
00:17:34,760 --> 00:17:36,620
is basically the memory image

560
00:17:36,670 --> 00:17:38,230
of a program stored in

561
00:17:38,230 --> 00:17:39,310
its text,

562
00:17:39,310 --> 00:17:41,920
so it's global data

563
00:17:41,920 --> 00:17:44,410
in and that forms the

564
00:17:44,410 --> 00:17:47,200
memory of the application.

565
00:17:47,230 --> 00:17:49,120
Now the application can grow

566
00:17:49,120 --> 00:17:49,660
its memory,

567
00:17:49,660 --> 00:17:50,740
for example by calling 'sbrk',

568
00:17:50,740 --> 00:17:53,710
extend there by extending

569
00:17:53,710 --> 00:17:55,810
its data segment but it

570
00:17:55,810 --> 00:17:56,890
doesn't really have a direct

571
00:17:56,890 --> 00:17:58,210
aspects to physical memory,

572
00:17:58,210 --> 00:17:59,770
you know you can just ask

573
00:17:59,770 --> 00:18:01,740
I want, you know,

574
00:18:02,150 --> 00:18:04,040
addresses physical memory,

575
00:18:04,040 --> 00:18:06,140
1k to 2k.

576
00:18:06,140 --> 00:18:07,670
There's no way of getting at

577
00:18:07,670 --> 00:18:09,050
that, and again the reason there's

578
00:18:09,050 --> 00:18:10,070
no way that you can get

579
00:18:10,070 --> 00:18:11,540
at that is because the operating

580
00:18:11,540 --> 00:18:13,190
system means to wants to provide

581
00:18:13,190 --> 00:18:15,020
memory isolation and therefore what's being

582
00:18:15,020 --> 00:18:18,740
controlled to intermediate between the

583
00:18:18,740 --> 00:18:20,600
applications and the physical hardware.

584
00:18:20,720 --> 00:18:21,920
And exec is a sort of

585
00:18:21,920 --> 00:18:23,600
system call that you know

586
00:18:23,600 --> 00:18:26,060
capture or shows that there's no

587
00:18:26,060 --> 00:18:28,380
direct access to

588
00:18:28,540 --> 00:18:30,640
memory. Another example of this is

589
00:18:30,640 --> 00:18:31,600
like files.

590
00:18:33,190 --> 00:18:34,600
Files basically abstract away

591
00:18:34,600 --> 00:18:35,600
this walks.

592
00:18:41,660 --> 00:18:43,850
Instead of reading or writing

593
00:18:43,850 --> 00:18:46,220
the disk blocks of the disk,

594
00:18:46,220 --> 00:18:47,960
that's attached to your computer,

595
00:18:47,960 --> 00:18:49,520
um, that actually just not allowed

596
00:18:49,520 --> 00:18:50,750
in unix, you know the only

597
00:18:50,750 --> 00:18:52,730
way to interact with the storage

598
00:18:52,730 --> 00:18:54,110
system is through files,

599
00:18:54,110 --> 00:18:54,920
and you can read or write

600
00:18:54,920 --> 00:18:56,900
files, provide a convenient abstraction,

601
00:18:56,900 --> 00:18:58,280
you can name files,

602
00:18:58,280 --> 00:18:59,540
etc etc,

603
00:18:59,540 --> 00:19:01,160
but then the operating system in

604
00:19:01,160 --> 00:19:02,990
itself can actually decide how to

605
00:19:02,990 --> 00:19:05,270
map those files to a disk

606
00:19:05,270 --> 00:19:06,950
blocks and make sure, for example

607
00:19:06,950 --> 00:19:08,510
of this block only shows up

608
00:19:08,510 --> 00:19:09,770
in one file and that you

609
00:19:09,770 --> 00:19:11,570
know user a cannot actually you

610
00:19:11,570 --> 00:19:13,880
know manipulate to read, write

611
00:19:13,880 --> 00:19:16,400
the files of user b.

612
00:19:16,400 --> 00:19:18,140
Um, and again you know this,

613
00:19:18,140 --> 00:19:20,090
you know that sort of interface,

614
00:19:20,090 --> 00:19:22,280
that the file abstraction allows that

615
00:19:22,280 --> 00:19:24,680
sort of strong isolation between even

616
00:19:24,680 --> 00:19:27,320
different users and different processes of

617
00:19:27,320 --> 00:19:28,220
the same user.

618
00:19:29,370 --> 00:19:30,630
As you can see, that in

619
00:19:30,630 --> 00:19:32,010
some ways you know the system

620
00:19:32,010 --> 00:19:32,640
call interface,

621
00:19:32,640 --> 00:19:33,600
that unix interface,

622
00:19:33,600 --> 00:19:35,250
giving programming with you know the

623
00:19:35,250 --> 00:19:36,750
util lab, seems to be sort

624
00:19:36,750 --> 00:19:39,060
of carefully designed to abstract the

625
00:19:39,060 --> 00:19:40,830
research in way, so that you

626
00:19:40,830 --> 00:19:41,940
know, the operating system,

627
00:19:41,940 --> 00:19:43,710
the implementation of the interface can

628
00:19:43,710 --> 00:19:46,440
actually multiply the resource of multiple

629
00:19:46,440 --> 00:19:49,740
applications and provide strong, strong isolation.

630
00:19:54,120 --> 00:19:55,480
Any questions about that.

631
00:19:56,040 --> 00:19:56,580
We have a question in

632
00:19:56,580 --> 00:19:57,810
the chat, that says do

633
00:19:57,810 --> 00:19:59,130
more complex kernel try to

634
00:19:59,130 --> 00:20:00,810
reschedule processes on the same

635
00:20:00,810 --> 00:20:02,660
core to reduce cache misses.

636
00:20:02,640 --> 00:20:03,930
Oh yeah,

637
00:20:03,930 --> 00:20:06,630
yeah there's something called cache affinity,

638
00:20:06,630 --> 00:20:07,890
um, um,

639
00:20:07,890 --> 00:20:09,960
you know this conversion in modern

640
00:20:09,960 --> 00:20:12,600
operating systems are very sophisticated, and

641
00:20:12,600 --> 00:20:13,800
indeed you know trying to avoid

642
00:20:13,800 --> 00:20:15,420
cache misses, and things like that

643
00:20:15,420 --> 00:20:17,180
and to optimize the performance.

644
00:20:17,580 --> 00:20:19,110
And you will see some of

645
00:20:19,110 --> 00:20:20,820
them much later in the semester

646
00:20:20,820 --> 00:20:21,600
where you are going to be

647
00:20:21,600 --> 00:20:23,960
talking about high performers networking.

648
00:20:24,140 --> 00:20:25,680
We'll show up there.

649
00:20:26,280 --> 00:20:28,560
Another question from chat, where in

650
00:20:28,560 --> 00:20:29,580
xv6, can we see how

651
00:20:29,580 --> 00:20:34,680
the OS multiplex processes?

652
00:20:34,680 --> 00:20:35,850
There's a couple piles of files that

653
00:20:35,850 --> 00:20:37,320
are relevant but proc.c

654
00:20:37,320 --> 00:20:38,820
is probably the most relevant one,

655
00:20:38,820 --> 00:20:40,620
um, this will be a topic

656
00:20:40,620 --> 00:20:42,060
of lecture in like two or

657
00:20:42,060 --> 00:20:42,820
three weeks.

658
00:20:43,060 --> 00:20:43,960
And we're going to go in

659
00:20:43,960 --> 00:20:45,190
great amount of detail and show

660
00:20:45,190 --> 00:20:47,060
exactly how the multiplex happens.

661
00:20:48,420 --> 00:20:49,200
So one way to think about

662
00:20:49,200 --> 00:20:49,980
these lectures a little bit of

663
00:20:49,980 --> 00:20:50,910
an introduction to a lot of

664
00:20:50,910 --> 00:20:52,440
different pieces and,

665
00:20:52,440 --> 00:20:53,490
um, you know because we've got

666
00:20:53,490 --> 00:20:54,460
to start somewhere.

667
00:20:57,850 --> 00:20:59,440
So, um,

668
00:20:59,440 --> 00:21:01,330
we go back into this picture

669
00:21:01,330 --> 00:21:03,160
here that I showed a little

670
00:21:03,160 --> 00:21:04,660
while ago we have this,

671
00:21:04,660 --> 00:21:06,760
um, shell running the echo running

672
00:21:06,760 --> 00:21:07,270
or not,

673
00:21:07,270 --> 00:21:07,840
that picture,

674
00:21:07,840 --> 00:21:08,580
this picture.

675
00:21:08,810 --> 00:21:09,860
Here on this side,

676
00:21:09,860 --> 00:21:10,910
we've got the operating system,

677
00:21:10,910 --> 00:21:13,190
we get the applications running and

678
00:21:13,190 --> 00:21:14,480
one thing we should be worried

679
00:21:14,480 --> 00:21:15,980
about this word that the operating

680
00:21:15,980 --> 00:21:17,360
system should be,

681
00:21:19,080 --> 00:21:20,600
um, it should be defensive.

682
00:21:23,190 --> 00:21:24,630
This is sort of an important,

683
00:21:24,630 --> 00:21:26,220
a mindset you know that you

684
00:21:26,220 --> 00:21:27,720
have to get used to one

685
00:21:27,720 --> 00:21:29,550
user doing kernel development,

686
00:21:29,550 --> 00:21:31,830
um, the operating system has to

687
00:21:31,830 --> 00:21:34,710
ensure, everything you know everything

688
00:21:34,710 --> 00:21:36,180
works out and so,

689
00:21:36,180 --> 00:21:37,530
um, it has to set

690
00:21:37,530 --> 00:21:38,520
up things up so that

691
00:21:38,520 --> 00:21:39,960
you know an app cannot

692
00:21:39,960 --> 00:21:41,500
crash the operating system.

693
00:21:45,660 --> 00:21:46,860
It would be too bad, if

694
00:21:46,860 --> 00:21:49,050
an application, at either by

695
00:21:49,050 --> 00:21:51,630
accident or maliciously passers are tricky

696
00:21:51,630 --> 00:21:53,730
heartened bad argument to the operating

697
00:21:53,730 --> 00:21:55,530
system and the operating system would

698
00:21:55,530 --> 00:21:57,240
corruption that basically means for denial

699
00:21:57,240 --> 00:21:59,480
servers for every other application.

700
00:21:59,710 --> 00:22:01,300
Um, so the operating system has

701
00:22:01,300 --> 00:22:02,290
to be written in a way

702
00:22:02,290 --> 00:22:04,300
that it can deal and handle

703
00:22:04,300 --> 00:22:05,920
malicious applications.

704
00:22:06,220 --> 00:22:07,330
Um, in particular,

705
00:22:07,330 --> 00:22:09,190
another concern is that the application

706
00:22:09,190 --> 00:22:10,420
should not be able,

707
00:22:10,720 --> 00:22:14,120
cannot break out of its isolation.

708
00:22:21,230 --> 00:22:21,590
I mean,

709
00:22:21,590 --> 00:22:23,990
the application might be definitely malicious,

710
00:22:23,990 --> 00:22:27,230
maybe written by an attacker and

711
00:22:27,230 --> 00:22:29,030
the attacker probably would like to

712
00:22:29,030 --> 00:22:31,340
break out of the application, for example

713
00:22:31,340 --> 00:22:32,990
and take control over the kernel,

714
00:22:32,990 --> 00:22:34,040
and once you have control over

715
00:22:34,040 --> 00:22:34,550
the kernel,

716
00:22:34,550 --> 00:22:36,260
then you can do anything because

717
00:22:36,260 --> 00:22:37,610
the kernel is in control of

718
00:22:37,610 --> 00:22:39,040
all the hardware resources.

719
00:22:39,330 --> 00:22:40,470
And so the operating system has

720
00:22:40,470 --> 00:22:41,280
to be able to come has

721
00:22:41,280 --> 00:22:42,780
to be written defensively,

722
00:22:42,780 --> 00:22:45,030
um, you know to avoid

723
00:22:45,030 --> 00:22:46,120
those kinds of things.

724
00:22:46,660 --> 00:22:47,770
Now, if this turns out

725
00:22:47,770 --> 00:22:49,240
to be very tricky to

726
00:22:49,240 --> 00:22:50,410
actually get right,

727
00:22:50,410 --> 00:22:51,010
um,

728
00:22:51,010 --> 00:22:52,240
in fact in Linux,

729
00:22:52,240 --> 00:22:53,560
there still

730
00:22:53,610 --> 00:22:54,720
periodic bugs,

731
00:22:54,720 --> 00:22:56,280
you know kernel bugs or bugs

732
00:22:56,280 --> 00:22:58,770
that actually allow an applications exploited

733
00:22:58,770 --> 00:23:00,810
or to break out of this

734
00:23:00,810 --> 00:23:03,560
isolation domain and take control.

735
00:23:03,980 --> 00:23:05,720
Um, but it's just a continuous

736
00:23:05,720 --> 00:23:07,010
concern and we'd like to do

737
00:23:07,010 --> 00:23:08,360
a good job as possible.

738
00:23:08,800 --> 00:23:09,910
And this is the mindset

739
00:23:09,910 --> 00:23:10,960
you have to have, when

740
00:23:10,960 --> 00:23:12,280
you're developing a kernel that

741
00:23:12,280 --> 00:23:14,800
actually applications are,

742
00:23:14,860 --> 00:23:16,620
um, perhaps malicious.

743
00:23:17,250 --> 00:23:19,620
Now, this means, that means it

744
00:23:19,620 --> 00:23:21,720
has to be strong isolation,

745
00:23:26,630 --> 00:23:28,200
between the apps

746
00:23:31,500 --> 00:23:32,560
and OS.

747
00:23:34,470 --> 00:23:36,090
If the OS you know, needs

748
00:23:36,090 --> 00:23:38,040
to be defensive and needs to

749
00:23:38,040 --> 00:23:38,910
be in position that can

750
00:23:38,910 --> 00:23:40,290
be defensive, there has to be

751
00:23:40,290 --> 00:23:42,240
a strong wall between the applications

752
00:23:42,240 --> 00:23:43,380
so that the operating system can

753
00:23:43,380 --> 00:23:45,960
actually enforce whatever policies it wants

754
00:23:45,960 --> 00:23:46,780
to enforce.

755
00:23:47,550 --> 00:23:49,500
And this is typically done, the

756
00:23:49,500 --> 00:23:51,450
typical approach to achieving this strong

757
00:23:51,450 --> 00:23:54,200
isolation is using hardware support.

758
00:23:57,880 --> 00:23:58,630
And we get a little bit

759
00:23:58,630 --> 00:23:59,860
of flavor of that in this

760
00:23:59,860 --> 00:24:00,880
lecture, but we'll come back to

761
00:24:00,880 --> 00:24:02,170
in much more detail in subsequent

762
00:24:02,170 --> 00:24:03,700
lectures. And two,

763
00:24:03,780 --> 00:24:06,330
two part series hardware support,

764
00:24:06,330 --> 00:24:08,370
one is something that's called user

765
00:24:08,370 --> 00:24:09,360
kernel mode,

766
00:24:10,290 --> 00:24:11,700
"/kernel mode".

767
00:24:12,500 --> 00:24:14,120
In RISC-V is called supervisor

768
00:24:14,120 --> 00:24:15,780
mode, but it's the same thing.

769
00:24:16,260 --> 00:24:18,300
Um, in page tables,

770
00:24:18,300 --> 00:24:19,380
virtual memory.

771
00:24:24,230 --> 00:24:27,170
So all processors, sort of

772
00:24:27,170 --> 00:24:28,460
series processors,

773
00:24:28,460 --> 00:24:30,620
um that are intended to run

774
00:24:30,620 --> 00:24:33,170
an operating system multiple applications,

775
00:24:33,170 --> 00:24:35,930
have support for user kernel mode

776
00:24:35,930 --> 00:24:36,680
and virtual memory,

777
00:24:36,680 --> 00:24:38,180
you know it might be manifested

778
00:24:38,180 --> 00:24:39,890
were implemented in a slightly different

779
00:24:39,890 --> 00:24:42,440
ways but physical all processors have,

780
00:24:43,180 --> 00:24:45,130
um, and RISC-V processor

781
00:24:45,130 --> 00:24:47,260
that we're using in this class

782
00:24:47,260 --> 00:24:48,980
has that support too.

783
00:24:49,450 --> 00:24:50,470
So let me talk a little

784
00:24:50,470 --> 00:24:51,310
bit, I'm going to talk a

785
00:24:51,310 --> 00:24:52,600
little bit about user mode,

786
00:24:52,600 --> 00:24:53,770
kernel mode first and then

787
00:24:53,770 --> 00:24:54,370
we'll talk a little bit

788
00:24:54,370 --> 00:24:55,440
about virtual memory.

789
00:24:55,680 --> 00:24:57,660
Um, and mostly at the highest

790
00:24:57,660 --> 00:24:59,360
level possible.

791
00:24:59,500 --> 00:25:00,400
Because there's a lot of

792
00:25:00,400 --> 00:25:01,330
important details,

793
00:25:01,330 --> 00:25:02,080
but I won't be able to

794
00:25:02,080 --> 00:25:03,320
cover those in this lecture.

795
00:25:04,840 --> 00:25:06,070
So let's first talk about user

796
00:25:06,070 --> 00:25:07,000
kernel mode.

797
00:25:14,600 --> 00:25:16,100
And basically what it means is

798
00:25:16,100 --> 00:25:17,960
that the processor has two modes

799
00:25:17,960 --> 00:25:19,100
of operation,

800
00:25:19,100 --> 00:25:20,660
one is user mode and the

801
00:25:20,660 --> 00:25:21,900
other one is kernel mode.

802
00:25:22,360 --> 00:25:24,780
And when running in kernel mode,

803
00:25:25,430 --> 00:25:28,640
the CPU can execute privileged instructions.

804
00:25:35,500 --> 00:25:37,330
Come back to the second out.

805
00:25:37,330 --> 00:25:39,260
When running in user mode,

806
00:25:39,700 --> 00:25:41,860
CPU can only execute in

807
00:25:41,860 --> 00:25:43,240
unprivileged instructions.

808
00:25:49,980 --> 00:25:51,120
And improve the structure,

809
00:25:51,120 --> 00:25:52,680
the structure you're well familiar with

810
00:25:52,680 --> 00:25:53,010
you know,

811
00:25:53,010 --> 00:25:55,860
think about like 'add' 'sub', adding

812
00:25:55,860 --> 00:25:57,480
to two registers together,

813
00:25:57,480 --> 00:25:58,860
you know subtracting to register

814
00:25:58,860 --> 00:26:00,120
so it's your basic you

815
00:26:00,120 --> 00:26:02,200
know procedure calls,

816
00:26:02,270 --> 00:26:03,470
your jr,

817
00:26:03,470 --> 00:26:05,300
all that kind of stuff branches,

818
00:26:05,300 --> 00:26:06,620
those are all

819
00:26:07,430 --> 00:26:09,410
um, unprivileged instructions that any

820
00:26:09,410 --> 00:26:11,300
user application is allowed to execute.

821
00:26:12,030 --> 00:26:15,030
Privileged structures are structures that basically

822
00:26:15,030 --> 00:26:18,180
are involved in manipulating the

823
00:26:18,180 --> 00:26:19,230
hardware directly,

824
00:26:19,230 --> 00:26:21,330
you know setting up protections and

825
00:26:21,330 --> 00:26:21,900
things like that,

826
00:26:21,900 --> 00:26:22,890
so for example setting up a

827
00:26:22,890 --> 00:26:24,260
page table register.

828
00:26:27,450 --> 00:26:28,800
Which we'll talk about later,

829
00:26:28,800 --> 00:26:30,240
um were,

830
00:26:31,840 --> 00:26:33,760
you know, setting the disabling

831
00:26:33,760 --> 00:26:34,920
clock interrupts.

832
00:26:39,320 --> 00:26:40,100
So there are all kinds of

833
00:26:40,100 --> 00:26:42,110
sort of state on the processor

834
00:26:42,110 --> 00:26:43,760
that the operating system intended to

835
00:26:43,760 --> 00:26:46,340
use and manipulating that state you

836
00:26:46,340 --> 00:26:47,450
know completely,

837
00:26:47,450 --> 00:26:49,840
um, is done for privileged instructions.

838
00:26:50,360 --> 00:26:50,630
And so,

839
00:26:50,630 --> 00:26:51,560
for example when a user

840
00:26:51,560 --> 00:26:53,720
application tries to actually execute

841
00:26:53,720 --> 00:26:55,020
a privilege instruction.

842
00:26:55,250 --> 00:26:57,320
Then the process rules won't

843
00:26:57,320 --> 00:26:59,810
execute because if personal instruction user

844
00:26:59,810 --> 00:27:01,700
mode is disallowed and basically

845
00:27:01,700 --> 00:27:03,980
that will result in the transfer

846
00:27:03,980 --> 00:27:06,170
control from user space from user

847
00:27:06,170 --> 00:27:07,250
mode to kernel mode so that

848
00:27:07,250 --> 00:27:08,540
then the operating system can actually

849
00:27:08,540 --> 00:27:09,650
take control and maybe if I

850
00:27:09,650 --> 00:27:12,040
kill the application because of misbehaving.

851
00:27:12,960 --> 00:27:14,670
To get a little bit

852
00:27:14,670 --> 00:27:15,720
of sense,

853
00:27:15,720 --> 00:27:17,280
um, the difference between the two

854
00:27:17,280 --> 00:27:19,280
and privilege and imprivilege instructions.

855
00:27:19,380 --> 00:27:21,720
Um, let me switch display

856
00:27:21,720 --> 00:27:22,780
for second.

857
00:27:22,860 --> 00:27:24,480
And here on the right side,

858
00:27:24,480 --> 00:27:26,010
you have to display is

859
00:27:26,010 --> 00:27:26,760
a document,

860
00:27:26,760 --> 00:27:28,680
you know the RISC-V.

861
00:27:28,890 --> 00:27:32,400
Privilege architecture document and that document

862
00:27:32,400 --> 00:27:34,110
contains all the privilege instructions,

863
00:27:34,110 --> 00:27:35,860
it's linked from the website.

864
00:27:35,940 --> 00:27:39,360
Um, under the preferences page and

865
00:27:39,360 --> 00:27:41,730
in the next couple of weeks

866
00:27:41,730 --> 00:27:44,070
or almost months now,

867
00:27:44,070 --> 00:27:45,630
you will be playing around you

868
00:27:45,630 --> 00:27:47,280
know all these privileged instructions,

869
00:27:47,280 --> 00:27:48,420
you know,

870
00:27:48,420 --> 00:27:50,130
are shown here and in

871
00:27:50,130 --> 00:27:52,170
fact many of them will show

872
00:27:52,170 --> 00:27:53,520
up and some of them want

873
00:27:53,520 --> 00:27:54,360
to show up in the next

874
00:27:54,360 --> 00:27:56,040
lecture in a great mount of detail.

875
00:27:56,280 --> 00:27:57,900
Um, but users think about this

876
00:27:57,900 --> 00:28:00,210
as there are privilege instructions that

877
00:28:00,210 --> 00:28:01,470
user applications should not be able

878
00:28:01,470 --> 00:28:03,330
to execute and those can only

879
00:28:03,330 --> 00:28:04,660
be executed in kernel mode.

880
00:28:05,810 --> 00:28:08,240
So that's one aspect of you

881
00:28:08,240 --> 00:28:09,710
know this sort of hardware support

882
00:28:09,710 --> 00:28:11,000
for strong isolation.

883
00:28:11,340 --> 00:28:12,270
Um, yeah,

884
00:28:12,270 --> 00:28:12,570
Amanda, go head.

885
00:28:13,750 --> 00:28:15,820
Just a quick question like,

886
00:28:15,820 --> 00:28:17,800
um, the what I'm imagining

887
00:28:17,800 --> 00:28:18,760
in my head is something

888
00:28:18,760 --> 00:28:20,950
like if kernel mode allow

889
00:28:20,950 --> 00:28:22,780
else don't like what,

890
00:28:22,780 --> 00:28:24,910
who is running that code and

891
00:28:24,910 --> 00:28:26,200
checking if its kernel mode,

892
00:28:26,200 --> 00:28:27,250
how do they know if it's

893
00:28:27,250 --> 00:28:28,960
in kernel mode like a flag

894
00:28:28,960 --> 00:28:29,800
or something.

895
00:28:29,900 --> 00:28:31,970
Yes, basically flagging the processor,

896
00:28:31,970 --> 00:28:33,920
literally there are a bit

897
00:28:33,920 --> 00:28:34,850
in the processor,

898
00:28:34,850 --> 00:28:36,350
that's just you know user

899
00:28:36,350 --> 00:28:36,830
mode,

900
00:28:36,830 --> 00:28:38,540
1 is saying,

901
00:28:38,640 --> 00:28:40,650
typically 1 is user mode,

902
00:28:40,650 --> 00:28:41,980
0 is kernel mode.

903
00:28:42,360 --> 00:28:43,920
And so when the processor decodes

904
00:28:43,920 --> 00:28:45,060
an instruction,

905
00:28:45,060 --> 00:28:46,410
looks at the op code

906
00:28:46,410 --> 00:28:47,490
if the op code is a

907
00:28:47,490 --> 00:28:50,190
privilege instruction and the bit is

908
00:28:50,190 --> 00:28:51,840
set to 1 and will deny

909
00:28:51,840 --> 00:28:53,200
executing that instruction.

910
00:28:54,420 --> 00:28:56,880
You know divided by zero, you're not

911
00:28:56,880 --> 00:28:57,840
allowed to do that.

912
00:28:58,130 --> 00:28:59,780
Okay, but if that bit

913
00:28:59,780 --> 00:29:01,130
has changed in some way

914
00:29:01,130 --> 00:29:02,390
you were just able to

915
00:29:02,390 --> 00:29:04,610
overwrite that bit then that's

916
00:29:04,610 --> 00:29:06,170
the only thing controlling yeah,

917
00:29:06,170 --> 00:29:07,430
so what do you think

918
00:29:07,430 --> 00:29:09,020
what the instruction that overwrites

919
00:29:09,020 --> 00:29:10,220
a bit is that

920
00:29:10,220 --> 00:29:12,440
privilege instructor unprivileged instruction.

921
00:29:19,460 --> 00:29:20,580
Is there a question.

922
00:29:22,970 --> 00:29:25,820
Clear the instruction that sets the

923
00:29:25,820 --> 00:29:27,800
bit must be privilege instruction because

924
00:29:27,800 --> 00:29:29,420
the user application should not be

925
00:29:29,420 --> 00:29:30,470
able to set the bit to

926
00:29:30,470 --> 00:29:31,070
kernel mode,

927
00:29:31,070 --> 00:29:32,450
correct and then be able

928
00:29:32,450 --> 00:29:34,310
to actually run all kinds

929
00:29:34,310 --> 00:29:35,420
of privilege instructions.

930
00:29:36,000 --> 00:29:37,400
And so that data is protected.

931
00:29:39,210 --> 00:29:40,180
Does that make sense.

932
00:29:40,780 --> 00:29:41,980
Okay, yeah.

933
00:29:44,130 --> 00:29:45,300
Um, OK good,

934
00:29:45,300 --> 00:29:46,140
so um,

935
00:29:46,140 --> 00:29:47,220
so that's user kernel mode

936
00:29:47,220 --> 00:29:48,270
or at least you know the

937
00:29:48,270 --> 00:29:50,160
top view user kernel mode,

938
00:29:50,160 --> 00:29:51,360
turns out to RISC-V

939
00:29:51,360 --> 00:29:52,800
has a number of you

940
00:29:52,800 --> 00:29:54,270
asked about have a third

941
00:29:54,270 --> 00:29:55,800
mode called machine mode.

942
00:29:55,920 --> 00:29:57,630
Um, we're mostly going to ignore

943
00:29:57,630 --> 00:29:59,160
that and so I'm very much

944
00:29:59,160 --> 00:30:00,990
say about it basically it's one

945
00:30:00,990 --> 00:30:02,430
more light because basically three levels

946
00:30:02,430 --> 00:30:03,960
of privileges instead of two levels

947
00:30:03,960 --> 00:30:04,860
of privileges.

948
00:30:05,290 --> 00:30:06,400
Amir, go ahead.

949
00:30:07,770 --> 00:30:09,660
Alright, so I'm wondering with respect

950
00:30:09,660 --> 00:30:10,440
to security,

951
00:30:10,440 --> 00:30:13,020
if all user code does go

952
00:30:13,020 --> 00:30:13,650
through the kernel,

953
00:30:13,650 --> 00:30:14,700
the intent is that things

954
00:30:14,700 --> 00:30:15,630
are secure,

955
00:30:15,630 --> 00:30:17,760
but is there a way for

956
00:30:17,880 --> 00:30:19,380
um, a user of the

957
00:30:19,380 --> 00:30:22,950
computer to completely go around

958
00:30:22,950 --> 00:30:24,380
the operating system.

959
00:30:25,180 --> 00:30:26,620
No, not really,

960
00:30:26,620 --> 00:30:28,540
at least you know if done

961
00:30:28,540 --> 00:30:30,000
carefully not.

962
00:30:32,700 --> 00:30:34,170
And if possible like you know

963
00:30:34,170 --> 00:30:35,250
that might be the case that

964
00:30:35,250 --> 00:30:37,360
some programs have additional privileges.

965
00:30:37,540 --> 00:30:39,010
Um, that the operating system

966
00:30:39,010 --> 00:30:40,780
will respect.

967
00:30:41,020 --> 00:30:42,520
Um, but those privileges are not

968
00:30:42,520 --> 00:30:44,440
given to every user, you know, only

969
00:30:44,440 --> 00:30:46,120
root user has certain

970
00:30:46,120 --> 00:30:48,370
privileges that allow you to do

971
00:30:48,370 --> 00:30:50,320
security sensitive operations.

972
00:30:50,860 --> 00:30:53,860
What about BIOS, does BIOS

973
00:30:53,860 --> 00:30:56,530
happened before OS or after. Yeah,

974
00:30:56,530 --> 00:30:59,800
so the BIOS is a piece

975
00:30:59,800 --> 00:31:01,600
of software that basically comes

976
00:31:01,600 --> 00:31:02,980
with the computer,

977
00:31:02,980 --> 00:31:04,090
um and um,

978
00:31:04,090 --> 00:31:06,280
that's booted first and the BIOS

979
00:31:06,280 --> 00:31:06,820
basically boots,

980
00:31:06,820 --> 00:31:08,050
the operating system,

981
00:31:08,050 --> 00:31:09,280
um, so the BIOS is a

982
00:31:09,280 --> 00:31:11,080
trusted piece of code.

983
00:31:11,450 --> 00:31:12,950
And better be correct and better

984
00:31:12,950 --> 00:31:14,360
be not malicious.

985
00:31:16,940 --> 00:31:17,510
Noah,

986
00:31:17,510 --> 00:31:18,200
go ahead.

987
00:31:19,310 --> 00:31:19,970
Um, yeah,

988
00:31:19,970 --> 00:31:21,800
so you mentioned that the

989
00:31:21,800 --> 00:31:23,690
you know the instruction to

990
00:31:23,690 --> 00:31:24,920
set the um,

991
00:31:24,920 --> 00:31:26,180
the kernel mode bit is a

992
00:31:26,180 --> 00:31:27,590
privileged instruction,

993
00:31:27,590 --> 00:31:29,690
how would a user program ever,

994
00:31:29,690 --> 00:31:31,010
then be able to you

995
00:31:31,010 --> 00:31:33,650
know get like you essentially

996
00:31:33,650 --> 00:31:34,460
have the kernel,

997
00:31:34,460 --> 00:31:35,990
execute any kernel instructions,

998
00:31:35,990 --> 00:31:38,270
if like the very instructions to

999
00:31:38,270 --> 00:31:40,160
access kernel mode is itself a

1000
00:31:40,160 --> 00:31:41,480
privileged instruction I guess it seems

1001
00:31:41,480 --> 00:31:43,490
like there's immediately a barrier for

1002
00:31:43,490 --> 00:31:45,940
user program ever changing that bit.

1003
00:31:45,990 --> 00:31:48,630
Yeah yeah that's correct and that's

1004
00:31:48,630 --> 00:31:49,500
exactly the way we want,

1005
00:31:49,500 --> 00:31:50,370
that's correct,

1006
00:31:50,370 --> 00:31:51,660
um, so one way to think

1007
00:31:51,660 --> 00:31:52,140
about it,

1008
00:31:52,140 --> 00:31:53,370
and this is not exactly how

1009
00:31:53,370 --> 00:31:54,750
it works on the RISC-V,

1010
00:31:54,750 --> 00:31:57,060
but if you execute a privilege

1011
00:31:57,060 --> 00:31:58,560
instruction in user space will try

1012
00:31:58,560 --> 00:31:59,880
to execute a privileged

1013
00:31:59,880 --> 00:32:01,280
instruction...

1014
00:33:08,220 --> 00:33:08,760
I'm back,

1015
00:33:08,760 --> 00:33:10,590
sorry about that I look like

1016
00:33:10,590 --> 00:33:15,380
my zoom client crashed on me.

1017
00:33:17,500 --> 00:33:18,670
I apologize for that I don't

1018
00:33:18,670 --> 00:33:19,930
really know why,

1019
00:33:19,930 --> 00:33:21,080
but it did.

1020
00:33:25,620 --> 00:33:27,060
Can everybody hear me again.

1021
00:33:27,860 --> 00:33:28,910
Yep, you're good,

1022
00:33:28,910 --> 00:33:29,660
all good,

1023
00:33:29,660 --> 00:33:30,440
all right.

1024
00:33:31,460 --> 00:33:36,740
Well there's somewhere a bug, okay,

1025
00:33:36,740 --> 00:33:40,080
um, so back to um.

1026
00:33:42,080 --> 00:33:44,000
Back to a second piece

1027
00:33:44,000 --> 00:33:45,710
of hardware support which

1028
00:33:45,710 --> 00:33:47,750
almost all CPU provide,

1029
00:33:47,750 --> 00:33:49,440
whith CPU's

1030
00:33:49,980 --> 00:33:51,500
provide virtual memory.

1031
00:34:02,870 --> 00:34:03,860
I'm going to talk about this

1032
00:34:03,860 --> 00:34:07,130
on wednesday in much more detail

1033
00:34:07,130 --> 00:34:09,200
but basically the process has something

1034
00:34:09,200 --> 00:34:09,650
you know what,

1035
00:34:09,650 --> 00:34:11,060
it's called page table.

1036
00:34:12,180 --> 00:34:13,440
And you've seen this a little

1037
00:34:13,440 --> 00:34:15,270
bit I think 6.004 the

1038
00:34:15,270 --> 00:34:15,930
page table,

1039
00:34:15,930 --> 00:34:18,220
basically maps virtual addresses

1040
00:34:21,550 --> 00:34:23,000
to physical addresses.

1041
00:34:25,380 --> 00:34:26,550
And the basic idea is to

1042
00:34:26,550 --> 00:34:27,920
give every process,

1043
00:34:28,680 --> 00:34:30,080
its own page table.

1044
00:34:34,330 --> 00:34:36,740
In this way,

1045
00:34:38,130 --> 00:34:39,990
the process can actually only use

1046
00:34:39,990 --> 00:34:41,520
whereas only allowed to access that

1047
00:34:41,520 --> 00:34:42,990
piece of physical memory that actually

1048
00:34:42,990 --> 00:34:44,640
shows up in this page table.

1049
00:34:44,670 --> 00:34:45,570
And so if you set up

1050
00:34:45,570 --> 00:34:46,710
if the operating system sets

1051
00:34:46,710 --> 00:34:47,700
the page tables up in a

1052
00:34:47,700 --> 00:34:49,560
way that um,

1053
00:34:49,560 --> 00:34:51,630
every process has disjoint

1054
00:34:51,630 --> 00:34:52,560
physical memory,

1055
00:34:52,560 --> 00:34:54,390
then a process can't even access

1056
00:34:54,390 --> 00:34:56,160
somebody else's physical memory because it's

1057
00:34:56,160 --> 00:34:57,540
not even it's page tables,

1058
00:34:57,540 --> 00:34:58,860
so there's no way even

1059
00:34:58,860 --> 00:35:00,030
to create an address or

1060
00:35:00,030 --> 00:35:01,590
write down an address that

1061
00:35:01,590 --> 00:35:02,700
will allow a process to

1062
00:35:02,700 --> 00:35:05,260
access somebody else's physical memory.

1063
00:35:05,380 --> 00:35:06,610
And so this gives us strong

1064
00:35:06,610 --> 00:35:07,800
memory isolation.

1065
00:35:09,950 --> 00:35:12,770
Basically page table defines a view

1066
00:35:12,770 --> 00:35:13,580
on memory,

1067
00:35:13,580 --> 00:35:15,530
and every application,

1068
00:35:15,530 --> 00:35:17,120
every user process has its own

1069
00:35:17,120 --> 00:35:18,420
view of memory,

1070
00:35:18,470 --> 00:35:19,820
independent of each other.

1071
00:35:20,220 --> 00:35:21,780
And this gives us very strong

1072
00:35:21,780 --> 00:35:23,220
memory isolation.

1073
00:35:24,310 --> 00:35:25,690
And so now what we can

1074
00:35:25,690 --> 00:35:26,350
do if we can think a

1075
00:35:26,350 --> 00:35:27,670
little bit in this way,

1076
00:35:27,670 --> 00:35:30,430
then we can redraw the picture

1077
00:35:30,430 --> 00:35:32,290
a little bit earlier and because

1078
00:35:32,290 --> 00:35:33,400
we're thinking about these as follows,

1079
00:35:33,400 --> 00:35:34,680
you have the box.

1080
00:35:35,600 --> 00:35:37,220
Yeah and ls sits in

1081
00:35:37,220 --> 00:35:38,720
that box and there's

1082
00:35:38,720 --> 00:35:40,160
another box,

1083
00:35:41,190 --> 00:35:42,920
when echo sits in that box.

1084
00:35:43,730 --> 00:35:45,230
In a box basically has an

1085
00:35:45,230 --> 00:35:47,000
address virtual address range starting from

1086
00:35:47,000 --> 00:35:49,160
0 to whatever some number

1087
00:35:49,160 --> 00:35:50,720
to the power whatever

1088
00:35:50,780 --> 00:35:53,420
number is. Um, in RISC-V, which

1089
00:35:53,420 --> 00:35:55,700
we'll talk about on Wednesday and

1090
00:35:55,700 --> 00:35:57,590
similarly you know the address range

1091
00:35:57,590 --> 00:35:59,750
for echo is something whatever

1092
00:35:59,750 --> 00:36:01,580
same to 2^x.

1093
00:36:02,070 --> 00:36:04,200
And so ls has in

1094
00:36:04,200 --> 00:36:06,150
memory location 0, echo has a

1095
00:36:06,150 --> 00:36:07,770
location like a 0, and users

1096
00:36:07,770 --> 00:36:08,910
completely separated,

1097
00:36:08,910 --> 00:36:10,470
and if the operating system maps

1098
00:36:10,470 --> 00:36:12,150
those virtual addresses 0 to different

1099
00:36:12,150 --> 00:36:14,700
pieces of physical addresses then basically

1100
00:36:14,700 --> 00:36:16,500
ls cannot access echo's memory and

1101
00:36:16,500 --> 00:36:18,560
echo cannot access ls's memory.

1102
00:36:19,040 --> 00:36:21,140
Um, similarly the kernel actually you

1103
00:36:21,140 --> 00:36:22,380
know sits below it.

1104
00:36:22,560 --> 00:36:23,910
It also has its own, at

1105
00:36:23,910 --> 00:36:25,530
least in xv6, has its own

1106
00:36:25,530 --> 00:36:26,600
address range.

1107
00:36:26,590 --> 00:36:28,660
Um, independent of the applications.

1108
00:36:29,080 --> 00:36:30,370
And we could think about the

1109
00:36:30,370 --> 00:36:31,660
user kernel mode,

1110
00:36:31,660 --> 00:36:33,430
sort of sitting in between you

1111
00:36:33,430 --> 00:36:34,360
know the boundary,

1112
00:36:34,360 --> 00:36:36,620
you know things that actually run.

1113
00:36:36,760 --> 00:36:39,060
In user space running user mode.

1114
00:36:41,020 --> 00:36:41,800
And things that sit in the

1115
00:36:41,800 --> 00:36:43,420
kernel running kernel mode.

1116
00:36:47,580 --> 00:36:48,840
And that's sort of the picture

1117
00:36:48,840 --> 00:36:50,460
that you should actually know OS, you

1118
00:36:50,460 --> 00:36:51,450
know sits there you know,

1119
00:36:51,450 --> 00:36:52,260
sitting in kernel mode,

1120
00:36:52,260 --> 00:36:53,580
so this is the picture,

1121
00:36:53,580 --> 00:36:55,820
you should have in your head.

1122
00:36:56,570 --> 00:36:58,190
Now, as described so far

1123
00:36:58,190 --> 00:36:58,880
this picture is a little

1124
00:36:58,880 --> 00:36:59,840
bit too strict,

1125
00:36:59,840 --> 00:37:01,070
you know we have a basically

1126
00:37:01,070 --> 00:37:02,480
put everything in a box but

1127
00:37:02,480 --> 00:37:03,710
there's no way for one box

1128
00:37:03,710 --> 00:37:05,640
to transfer control to another box.

1129
00:37:05,840 --> 00:37:07,670
Clearly what needs to happen, because

1130
00:37:07,670 --> 00:37:09,410
your example ls, you know probably want

1131
00:37:09,410 --> 00:37:10,300
to call,

1132
00:37:10,400 --> 00:37:11,810
you know, read, the read

1133
00:37:11,810 --> 00:37:12,800
system call.

1134
00:37:13,260 --> 00:37:15,630
Or write system call or maybe

1135
00:37:15,630 --> 00:37:15,960
you know,

1136
00:37:15,960 --> 00:37:17,370
whatever the shell want to call

1137
00:37:17,370 --> 00:37:18,900
fork or exec.

1138
00:37:18,950 --> 00:37:19,190
And so,

1139
00:37:19,190 --> 00:37:20,450
there has to be a way

1140
00:37:20,450 --> 00:37:22,970
for an application or user application

1141
00:37:22,970 --> 00:37:25,100
to transfer control in a coordinated

1142
00:37:25,100 --> 00:37:27,920
manner to the kernel,

1143
00:37:27,920 --> 00:37:29,030
so the kernel can actually

1144
00:37:29,030 --> 00:37:30,160
provide services.

1145
00:37:30,940 --> 00:37:32,800
Um, and so,

1146
00:37:32,800 --> 00:37:34,540
um there's a plan basically in

1147
00:37:34,540 --> 00:37:35,410
addition to this,

1148
00:37:35,410 --> 00:37:36,700
um, two pieces of hardware support

1149
00:37:36,700 --> 00:37:38,860
I talked so far, talked about

1150
00:37:38,860 --> 00:37:40,920
so far is a way

1151
00:37:41,000 --> 00:37:43,070
of a controlled way of entering

1152
00:37:43,070 --> 00:37:43,860
the kernel.

1153
00:37:49,440 --> 00:37:51,390
It turns out actually RISC-V,

1154
00:37:51,390 --> 00:37:53,400
there is an instruction,

1155
00:37:53,400 --> 00:37:54,690
um, for this,

1156
00:37:54,690 --> 00:37:56,680
it's called the 'ecall' instruction.

1157
00:37:58,000 --> 00:37:59,020
And ecall instruction,

1158
00:37:59,020 --> 00:38:01,100
it takes one argument, a number.

1159
00:38:02,200 --> 00:38:04,090
And so when a user application

1160
00:38:04,090 --> 00:38:05,620
that wants to transfer control

1161
00:38:05,620 --> 00:38:07,480
into the kernel basically called the

1162
00:38:07,480 --> 00:38:09,610
ecall instruction with numbers like two

1163
00:38:09,610 --> 00:38:11,110
or three or four five and

1164
00:38:11,110 --> 00:38:12,850
that number basically is the system

1165
00:38:12,850 --> 00:38:13,740
call number,

1166
00:38:14,950 --> 00:38:16,720
that the application wants to invoke.

1167
00:38:21,740 --> 00:38:23,480
And then basically what that does

1168
00:38:23,480 --> 00:38:25,040
and actually enters the kernel at

1169
00:38:25,040 --> 00:38:28,340
a particular point or particular

1170
00:38:28,340 --> 00:38:31,700
location in the kernel that's controlled by

1171
00:38:31,700 --> 00:38:33,680
the kernel as we'll see

1172
00:38:33,680 --> 00:38:34,460
in xv6,

1173
00:38:34,460 --> 00:38:36,560
I mean some later lectures,

1174
00:38:36,560 --> 00:38:38,240
um, you know there's basically a

1175
00:38:38,240 --> 00:38:41,060
single system call entry point.

1176
00:38:41,090 --> 00:38:42,680
And, um,

1177
00:38:42,680 --> 00:38:44,360
and every time an application calls

1178
00:38:44,360 --> 00:38:46,070
ecall, you know the application

1179
00:38:46,070 --> 00:38:47,820
enters the kernel that particular point.

1180
00:38:48,590 --> 00:38:49,310
So, one,

1181
00:38:49,310 --> 00:38:51,020
um, one way to think

1182
00:38:51,020 --> 00:38:52,370
about this is that if

1183
00:38:52,370 --> 00:38:53,420
you have fork.

1184
00:38:53,900 --> 00:38:54,710
You know fork,

1185
00:38:54,710 --> 00:38:57,260
you know call in user space,

1186
00:38:57,260 --> 00:38:58,580
for example the shell or your

1187
00:38:58,580 --> 00:39:01,310
primes program called fork, well whatever

1188
00:39:01,310 --> 00:39:02,870
calls fork doesn't really call

1189
00:39:02,870 --> 00:39:04,550
the operating system directly,

1190
00:39:04,550 --> 00:39:06,680
the corresponding function in the kernel,

1191
00:39:06,680 --> 00:39:08,570
instead you know what it does

1192
00:39:08,570 --> 00:39:10,200
it actually calls the ecall.

1193
00:39:11,710 --> 00:39:13,930
With you know this number

1194
00:39:13,930 --> 00:39:15,000
for fork.

1195
00:39:17,080 --> 00:39:18,940
And then that actually jumps into

1196
00:39:18,940 --> 00:39:19,920
the kernel.

1197
00:39:20,690 --> 00:39:22,600
So this is a kernel transition.

1198
00:39:23,060 --> 00:39:24,530
And here's the user side, here's

1199
00:39:24,530 --> 00:39:27,020
a kernel side, and then on

1200
00:39:27,020 --> 00:39:28,190
the kernel side,

1201
00:39:28,190 --> 00:39:29,390
you know there's a function called

1202
00:39:29,390 --> 00:39:31,760
syscall in syscall.c and

1203
00:39:31,760 --> 00:39:34,010
then basically every system call will

1204
00:39:34,010 --> 00:39:35,510
end up at that particular system,

1205
00:39:35,510 --> 00:39:37,250
call function and the system call

1206
00:39:37,250 --> 00:39:38,630
will look at the number and

1207
00:39:38,630 --> 00:39:40,070
then decide and the numerous action

1208
00:39:40,070 --> 00:39:41,540
passed in register I think it's

1209
00:39:41,540 --> 00:39:42,460
a0.

1210
00:39:42,680 --> 00:39:44,660
Um, and just go and

1211
00:39:44,660 --> 00:39:45,860
look at that register look

1212
00:39:45,860 --> 00:39:47,300
at a0, see what the

1213
00:39:47,300 --> 00:39:48,230
number is and then,

1214
00:39:48,230 --> 00:39:49,310
for example called the fork

1215
00:39:49,310 --> 00:39:50,120
system call.

1216
00:39:52,670 --> 00:39:54,140
Um, and so just to make

1217
00:39:54,140 --> 00:39:55,610
clear so this is this hard

1218
00:39:55,610 --> 00:39:57,590
boundary between the user and kernel,

1219
00:39:57,590 --> 00:40:00,400
so the user cannot call,

1220
00:40:00,600 --> 00:40:03,210
you know this fork directly,

1221
00:40:03,210 --> 00:40:04,920
you know the only way user

1222
00:40:04,920 --> 00:40:07,320
application can actually invoke the system

1223
00:40:07,320 --> 00:40:09,150
call fork is actually through this

1224
00:40:09,150 --> 00:40:10,320
ecall instruction.

1225
00:40:12,600 --> 00:40:14,440
And so we have another, um,

1226
00:40:18,830 --> 00:40:20,580
if we have another, um,

1227
00:40:22,400 --> 00:40:23,870
another system call let's

1228
00:40:23,870 --> 00:40:24,920
say write.

1229
00:40:27,730 --> 00:40:28,810
It does something similar,

1230
00:40:28,810 --> 00:40:30,790
you know the write system

1231
00:40:30,790 --> 00:40:32,410
call cannot call you know the

1232
00:40:32,410 --> 00:40:34,450
write, you know code directly into

1233
00:40:34,450 --> 00:40:35,080
the kernel,

1234
00:40:35,080 --> 00:40:36,910
instead, um what it does,

1235
00:40:36,910 --> 00:40:39,250
it calls what's these little wrappers

1236
00:40:39,250 --> 00:40:40,000
are called,

1237
00:40:41,090 --> 00:40:42,530
system call stops it will call

1238
00:40:42,530 --> 00:40:43,400
ecall.

1239
00:40:44,560 --> 00:40:46,030
And function called write that actually

1240
00:40:46,030 --> 00:40:48,610
executes ecall instruction with the argument

1241
00:40:48,610 --> 00:40:49,210
you know syscall write,

1242
00:40:50,430 --> 00:40:52,530
to indicate the write system call,

1243
00:40:52,530 --> 00:40:54,510
and then again transfer control to

1244
00:40:54,510 --> 00:40:55,460
syscall.

1245
00:40:55,600 --> 00:40:57,400
And then syscall,

1246
00:40:57,400 --> 00:41:00,430
um, can actually [a view multiplex]

1247
00:41:00,430 --> 00:41:01,720
into the write system call.

1248
00:41:01,850 --> 00:41:03,170
There are two questions,

1249
00:41:03,170 --> 00:41:04,140
please go ahead.

1250
00:41:09,410 --> 00:41:10,820
So, I think my hands up 

1251
00:41:10,820 --> 00:41:11,520
both.

1252
00:41:12,710 --> 00:41:15,020
Okay I can go ahead.

1253
00:41:15,640 --> 00:41:17,560
Oh, the question I had was,

1254
00:41:17,560 --> 00:41:19,870
um, how does or where does

1255
00:41:19,870 --> 00:41:21,600
the kernel check,

1256
00:41:21,830 --> 00:41:23,510
um, for,

1257
00:41:23,510 --> 00:41:25,850
for example fork or write, if

1258
00:41:25,850 --> 00:41:27,180
it is allowed or not.

1259
00:41:27,510 --> 00:41:28,560
Um, right now,

1260
00:41:28,560 --> 00:41:29,880
you're just passing in, like you

1261
00:41:29,880 --> 00:41:31,620
know you're just calling ecall

1262
00:41:31,620 --> 00:41:33,060
and the system call number,

1263
00:41:33,060 --> 00:41:34,950
but where does the kernel

1264
00:41:34,950 --> 00:41:37,140
basically decide whether this application

1265
00:41:37,140 --> 00:41:38,730
should be able to invoke

1266
00:41:38,730 --> 00:41:41,300
this particular kernel syscall.

1267
00:41:41,420 --> 00:41:42,710
Yeah, so a great question,

1268
00:41:42,710 --> 00:41:44,540
so in principle you know on

1269
00:41:44,540 --> 00:41:46,010
the kernel side correct, when we

1270
00:41:46,010 --> 00:41:47,880
actually use fork call runs.

1271
00:41:48,230 --> 00:41:49,310
Um, it can implement any

1272
00:41:49,310 --> 00:41:49,910
secure check

1273
00:41:49,910 --> 00:41:51,170
it wants, you could look at

1274
00:41:51,170 --> 00:41:53,390
the arguments if the system call

1275
00:41:53,390 --> 00:41:55,130
and decide whether actually the application

1276
00:41:55,130 --> 00:41:56,660
should all be allowed to execute

1277
00:41:56,660 --> 00:41:57,920
the system call fork.

1278
00:41:57,950 --> 00:42:00,200
Now in user or in unix

1279
00:42:00,200 --> 00:42:01,520
or any application can actually call

1280
00:42:01,520 --> 00:42:03,860
fork but let's say take write.

1281
00:42:03,960 --> 00:42:04,740
You know write,

1282
00:42:04,740 --> 00:42:06,840
you need to check whether a

1283
00:42:06,840 --> 00:42:08,280
the implantation of write needs to

1284
00:42:08,280 --> 00:42:09,840
check, whether the address that is

1285
00:42:09,840 --> 00:42:13,110
actually passed into write, actually is

1286
00:42:13,110 --> 00:42:15,260
part of the user applications.

1287
00:42:15,480 --> 00:42:16,650
Um, and so that you

1288
00:42:16,650 --> 00:42:17,580
know the kernel is not

1289
00:42:17,580 --> 00:42:21,390
correct to writing a data

1290
00:42:21,390 --> 00:42:22,290
from somewhere else, it actually

1291
00:42:22,290 --> 00:42:23,880
doesn't belong to the application.

1292
00:42:25,600 --> 00:42:26,350
There more

1293
00:42:27,490 --> 00:42:29,040
hints, you know. Please ask.

1294
00:42:30,280 --> 00:42:31,180
Um, yeah I had a

1295
00:42:31,180 --> 00:42:31,990
quick question,

1296
00:42:31,990 --> 00:42:34,200
um, so how did the

1297
00:42:34,350 --> 00:42:36,360
kernel seize back control from a

1298
00:42:36,360 --> 00:42:38,700
user application in the case where

1299
00:42:38,700 --> 00:42:40,680
the user application is acting maliciously

1300
00:42:40,680 --> 00:42:42,400
or in an infinite loop.

1301
00:42:42,660 --> 00:42:44,670
Yeah, so the way the plan

1302
00:42:44,670 --> 00:42:46,110
for that and again we're going

1303
00:42:46,110 --> 00:42:46,770
to talk about in much more

1304
00:42:46,770 --> 00:42:47,760
detail in a couple weeks,

1305
00:42:47,760 --> 00:42:49,770
um is that the kernel

1306
00:42:49,770 --> 00:42:50,550
actually programs,

1307
00:42:50,550 --> 00:42:52,200
the hardware to a set

1308
00:42:52,200 --> 00:42:53,060
of timer.

1309
00:42:53,460 --> 00:42:56,160
And after the timer goes off,

1310
00:42:56,160 --> 00:42:58,530
um, that will cause a transfer

1311
00:42:58,530 --> 00:42:59,970
from user space to kernel mode,

1312
00:42:59,970 --> 00:43:00,960
at that point the kernel is

1313
00:43:00,960 --> 00:43:02,200
back in control.

1314
00:43:02,260 --> 00:43:04,090
And then the kernel can reschedule

1315
00:43:04,090 --> 00:43:06,860
the CPU to another process.

1316
00:43:07,600 --> 00:43:10,120
Okay makes sense, thank you. Yeah we'll

1317
00:43:10,120 --> 00:43:12,130
see the exact details you know

1318
00:43:12,130 --> 00:43:13,240
we'll see,

1319
00:43:13,240 --> 00:43:14,400
um in a little while.

1320
00:43:15,200 --> 00:43:16,660
We have more questions.

1321
00:43:18,580 --> 00:43:19,750
Yeah, so this is more of

1322
00:43:19,750 --> 00:43:20,800
a high-level question,

1323
00:43:20,800 --> 00:43:24,220
but what drives the designers of

1324
00:43:24,220 --> 00:43:27,010
an operating systems implementation to use

1325
00:43:27,010 --> 00:43:28,440
a language like C.

1326
00:43:29,120 --> 00:43:30,440
Um, um,

1327
00:43:30,440 --> 00:43:32,330
okay, so great question,

1328
00:43:32,330 --> 00:43:35,120
um, C gives you a lot

1329
00:43:35,120 --> 00:43:35,960
of control,

1330
00:43:35,960 --> 00:43:38,020
um over hardware.

1331
00:43:38,140 --> 00:43:39,220
And, um,

1332
00:43:39,220 --> 00:43:40,780
so, um,

1333
00:43:40,780 --> 00:43:41,530
for example,

1334
00:43:41,530 --> 00:43:42,490
you know you need to program

1335
00:43:42,490 --> 00:43:43,420
the timer chip.

1336
00:43:43,560 --> 00:43:45,870
Um, and um in C that

1337
00:43:45,870 --> 00:43:47,490
is actually easy to do,

1338
00:43:47,490 --> 00:43:48,570
because you get a lot of

1339
00:43:48,570 --> 00:43:51,660
low-level control over any hardware resource

1340
00:43:51,660 --> 00:43:53,800
and partly because you can cast

1341
00:43:53,860 --> 00:43:55,240
anything to anything,

1342
00:43:55,240 --> 00:43:56,560
um, and,

1343
00:43:56,560 --> 00:43:58,750
um, so C is basically very convenient

1344
00:43:58,750 --> 00:43:59,650
programming language,

1345
00:43:59,650 --> 00:44:00,280
if you have to move

1346
00:44:00,280 --> 00:44:02,260
very low-level programming and particularly

1347
00:44:02,260 --> 00:44:03,500
interacting with hardware.

1348
00:44:06,620 --> 00:44:07,640
It doesn't mean you can't do

1349
00:44:07,640 --> 00:44:08,720
it in other languages,

1350
00:44:08,720 --> 00:44:09,950
um, but this is historically the

1351
00:44:09,950 --> 00:44:11,980
reason why C has been successful.

1352
00:44:12,940 --> 00:44:13,360
I see,

1353
00:44:13,360 --> 00:44:16,510
thanks. Why I see so much

1354
00:44:16,510 --> 00:44:18,790
more popular than c++

1355
00:44:18,790 --> 00:44:20,890
only for historic reasons in like

1356
00:44:20,890 --> 00:44:23,530
these kinds of applications or um,

1357
00:44:23,530 --> 00:44:26,170
is there any other reason that

1358
00:44:26,170 --> 00:44:28,390
like, like most OS don't

1359
00:44:28,390 --> 00:44:30,240
have adopted C++.

1360
00:44:30,580 --> 00:44:31,750
Yeah, so most operating system,

1361
00:44:31,750 --> 00:44:32,890
there are I think operating

1362
00:44:32,890 --> 00:44:33,910
systems written in C++

1363
00:44:33,910 --> 00:44:35,770
totally possible,

1364
00:44:35,770 --> 00:44:37,150
probably the most ones that you

1365
00:44:37,150 --> 00:44:38,620
know, you know are not written

1366
00:44:38,620 --> 00:44:39,660
in C++.

1367
00:44:40,040 --> 00:44:41,930
Um, and the various reasons for,

1368
00:44:41,930 --> 00:44:44,150
you know, Linux is mostly

1369
00:44:44,150 --> 00:44:45,680
C or no C++

1370
00:44:45,680 --> 00:44:47,000
and I think partially because Linus

1371
00:44:47,000 --> 00:44:48,620
just doesn't like C++.

1372
00:44:54,660 --> 00:44:55,800
Any other questions.

1373
00:45:04,300 --> 00:45:06,280
Okay, so, so in this view

1374
00:45:06,280 --> 00:45:06,880
of the world,

1375
00:45:06,880 --> 00:45:09,340
were you know we have a

1376
00:45:09,340 --> 00:45:11,920
way of transferring control into

1377
00:45:11,920 --> 00:45:14,140
the operating system using system calls

1378
00:45:14,140 --> 00:45:16,780
or the ecall instruction and

1379
00:45:16,780 --> 00:45:18,760
there's a kernel is not responsible

1380
00:45:18,760 --> 00:45:22,510
for implementing actually the actual functions

1381
00:45:22,510 --> 00:45:25,270
and ensuring checking arguments and

1382
00:45:25,270 --> 00:45:26,290
things like that to make sure

1383
00:45:26,290 --> 00:45:27,580
that you know that.

1384
00:45:27,880 --> 00:45:29,080
Um, it's not being tricked

1385
00:45:29,080 --> 00:45:29,530
into something,

1386
00:45:29,530 --> 00:45:31,300
um doing something badly and so

1387
00:45:31,300 --> 00:45:32,650
in this view of the world,

1388
00:45:32,650 --> 00:45:34,680
the kernel is sometimes called.

1389
00:45:37,200 --> 00:45:37,440
You know,

1390
00:45:37,440 --> 00:45:39,120
it's the trusted computing base.

1391
00:45:46,950 --> 00:45:48,660
Sometimes called in security terms

1392
00:45:48,660 --> 00:45:49,780
the TCB.

1393
00:45:50,530 --> 00:45:53,590
Um, and basically you know what

1394
00:45:53,590 --> 00:45:54,760
does it mean to be the

1395
00:45:54,760 --> 00:45:55,630
trusted computing base,

1396
00:45:55,630 --> 00:45:57,730
well it must be correct, kernel

1397
00:45:57,730 --> 00:45:58,900
must have no bugs.

1398
00:46:05,720 --> 00:46:06,650
Because if there's a bug in

1399
00:46:06,650 --> 00:46:07,340
the kernel,

1400
00:46:07,340 --> 00:46:08,240
you know the way to think

1401
00:46:08,240 --> 00:46:08,570
about it,

1402
00:46:08,570 --> 00:46:08,900
this stuff,

1403
00:46:08,900 --> 00:46:11,420
maybe an attacker is able to

1404
00:46:11,420 --> 00:46:13,460
um to tickle the bug and

1405
00:46:13,460 --> 00:46:15,000
turn the bug into an exploit.

1406
00:46:15,260 --> 00:46:17,180
And you know that exploit may

1407
00:46:17,180 --> 00:46:19,130
be allowed a particular attacker to

1408
00:46:19,130 --> 00:46:21,200
break out of isolation or maybe

1409
00:46:21,200 --> 00:46:23,090
take control over the kernel,

1410
00:46:23,090 --> 00:46:24,350
and so it's really important

1411
00:46:24,350 --> 00:46:25,070
that you know the kernel

1412
00:46:25,070 --> 00:46:26,270
really has to have as

1413
00:46:26,270 --> 00:46:27,580
few bugs as possible.

1414
00:46:29,620 --> 00:46:31,000
Invisibly the kernel,

1415
00:46:31,000 --> 00:46:32,480
you must treat.

1416
00:46:35,460 --> 00:46:38,430
Let's treat user apps or applications

1417
00:46:38,430 --> 00:46:39,560
or processes

1418
00:46:41,820 --> 00:46:42,940
as malicious.

1419
00:46:47,200 --> 00:46:49,180
Basically as I said before, invading

1420
00:46:49,180 --> 00:46:50,470
the kernel designer should have

1421
00:46:50,470 --> 00:46:52,210
a security mindset,

1422
00:46:52,210 --> 00:46:53,890
um, you know when writing and

1423
00:46:53,890 --> 00:46:55,640
implementing a kernel code.

1424
00:46:56,040 --> 00:46:58,770
In, in its heart to

1425
00:46:58,770 --> 00:46:59,610
achieve this goal,

1426
00:46:59,610 --> 00:47:00,810
we have no bugs,

1427
00:47:00,810 --> 00:47:03,420
if your operating system gigantically big,

1428
00:47:03,420 --> 00:47:05,370
is not that straightforward and

1429
00:47:05,370 --> 00:47:06,900
almost every operating system,

1430
00:47:06,900 --> 00:47:09,030
you know the user is widely

1431
00:47:09,030 --> 00:47:10,980
used, once in a while

1432
00:47:10,980 --> 00:47:13,050
actually has a security bug and

1433
00:47:13,050 --> 00:47:15,180
they get fixed over time,

1434
00:47:15,180 --> 00:47:16,320
but basically.

1435
00:47:16,520 --> 00:47:18,170
No matter what there's always a

1436
00:47:18,170 --> 00:47:20,360
new exploit at some point, down

1437
00:47:20,360 --> 00:47:22,250
the line and you will see

1438
00:47:22,250 --> 00:47:23,810
later why it's so tricky to get

1439
00:47:23,810 --> 00:47:24,980
it all and right,

1440
00:47:24,980 --> 00:47:26,750
um, but you know the sort

1441
00:47:26,750 --> 00:47:29,450
of understandable like the kernel has

1442
00:47:29,450 --> 00:47:30,680
to do tricky stuff.

1443
00:47:30,850 --> 00:47:33,010
It has to manipulate hardware,

1444
00:47:33,010 --> 00:47:33,940
um, it has to be

1445
00:47:33,940 --> 00:47:35,620
very careful and it's checking

1446
00:47:35,620 --> 00:47:36,880
it's very easy to make

1447
00:47:36,880 --> 00:47:38,710
a small slip up and

1448
00:47:38,710 --> 00:47:40,040
you know have a bug.

1449
00:47:42,150 --> 00:47:43,120
And so.

1450
00:47:47,140 --> 00:47:49,510
An instant question is then what

1451
00:47:49,510 --> 00:47:51,370
should run in kernel mode because

1452
00:47:51,370 --> 00:47:52,990
it's really the kernel code actually

1453
00:47:52,990 --> 00:47:54,880
is in kernel mode that is

1454
00:47:54,880 --> 00:47:57,640
the sensitive code right that is

1455
00:47:57,640 --> 00:47:59,140
the trusted computing days.

1456
00:47:59,330 --> 00:48:02,750
Um, and one answer to that

1457
00:48:02,750 --> 00:48:03,950
question is like

1458
00:48:03,950 --> 00:48:05,980
well you know we have our

1459
00:48:06,650 --> 00:48:07,880
user kernel boundary,

1460
00:48:07,880 --> 00:48:08,630
so here's user,

1461
00:48:08,630 --> 00:48:10,400
here's kernel.

1462
00:48:10,760 --> 00:48:13,760
A user applications running,

1463
00:48:13,760 --> 00:48:16,010
and here is the program running

1464
00:48:16,010 --> 00:48:16,790
in kernel mode,

1465
00:48:16,790 --> 00:48:18,140
one option is to stick the

1466
00:48:18,140 --> 00:48:20,600
whole operating system in kernel mode.

1467
00:48:20,840 --> 00:48:21,770
For example,

1468
00:48:21,770 --> 00:48:24,170
in most unix operating systems,

1469
00:48:24,170 --> 00:48:26,870
the whole unix implementation runs inside

1470
00:48:26,870 --> 00:48:27,740
of kernel mode.

1471
00:48:27,800 --> 00:48:29,480
So in the xv6,

1472
00:48:29,480 --> 00:48:32,390
all the operating system services are

1473
00:48:32,390 --> 00:48:35,300
basically in kernel mode,

1474
00:48:35,300 --> 00:48:37,180
and this is called monolithic

1475
00:48:39,860 --> 00:48:40,960
kernel design.

1476
00:48:47,550 --> 00:48:50,490
And you know there there's a

1477
00:48:50,490 --> 00:48:51,540
couple things in the way to think

1478
00:48:51,540 --> 00:48:52,110
about it.

1479
00:48:53,080 --> 00:48:55,060
One way, it's probably not so good

1480
00:48:55,060 --> 00:48:55,660
for bugs.

1481
00:48:58,910 --> 00:49:00,620
Because any bug you know that

1482
00:49:00,620 --> 00:49:02,060
you might have in a monolithic

1483
00:49:02,060 --> 00:49:04,760
design might actually turn into an

1484
00:49:04,760 --> 00:49:06,830
exploit and that would be bad,

1485
00:49:06,830 --> 00:49:07,640
um, so we have a

1486
00:49:07,640 --> 00:49:09,560
large operating system running inside

1487
00:49:09,560 --> 00:49:10,160
of the kernel,

1488
00:49:10,160 --> 00:49:11,300
it's likely they're going to be

1489
00:49:11,300 --> 00:49:11,900
more bugs,

1490
00:49:11,900 --> 00:49:13,100
but any statistics that can

1491
00:49:13,100 --> 00:49:14,000
look up who says like

1492
00:49:14,000 --> 00:49:15,440
every few thousand lines of

1493
00:49:15,440 --> 00:49:16,790
code will have you know

1494
00:49:16,790 --> 00:49:18,240
some small number of bugs.

1495
00:49:18,420 --> 00:49:19,200
And so if you have many,

1496
00:49:19,200 --> 00:49:20,430
many more lines of code running

1497
00:49:20,430 --> 00:49:21,270
in the kernel block,

1498
00:49:21,270 --> 00:49:22,890
you know, the probability the chance that

1499
00:49:22,890 --> 00:49:23,780
you have.

1500
00:49:23,880 --> 00:49:26,640
Um, and then huge bug

1501
00:49:26,640 --> 00:49:27,510
goes up a little bit

1502
00:49:27,510 --> 00:49:29,130
and so downside from the

1503
00:49:29,130 --> 00:49:30,600
monolithic kernel design from a

1504
00:49:30,600 --> 00:49:31,980
security perspective is that there's a

1505
00:49:31,980 --> 00:49:33,660
lot of code in the

1506
00:49:33,660 --> 00:49:34,300
kernel.

1507
00:49:34,840 --> 00:49:37,390
Um the plus though is

1508
00:49:37,390 --> 00:49:38,140
you know.

1509
00:49:38,200 --> 00:49:39,430
Typically, if you think about an

1510
00:49:39,430 --> 00:49:40,810
operating system that contains all kinds

1511
00:49:40,810 --> 00:49:41,590
of different pieces,

1512
00:49:41,590 --> 00:49:42,280
you know you might have to

1513
00:49:42,280 --> 00:49:43,460
file system piece.

1514
00:49:43,690 --> 00:49:44,560
You might have the virtual

1515
00:49:44,560 --> 00:49:45,670
memory piece,

1516
00:49:45,670 --> 00:49:48,100
um, you might have processes

1517
00:49:48,100 --> 00:49:48,780
you know.

1518
00:49:48,920 --> 00:49:49,580
And so there are all kinds

1519
00:49:49,580 --> 00:49:51,170
of sub modules inside of the

1520
00:49:51,170 --> 00:49:53,840
operating system that implement particular functionality.

1521
00:49:54,120 --> 00:49:55,230
And the plus side of

1522
00:49:55,230 --> 00:49:56,040
that is there's going to

1523
00:49:56,040 --> 00:49:57,460
be tight integration.

1524
00:49:57,900 --> 00:50:00,780
Possible between these different sub modules,

1525
00:50:00,780 --> 00:50:01,860
if they're all sitting in the

1526
00:50:01,860 --> 00:50:02,840
same program.

1527
00:50:03,420 --> 00:50:05,010
And that connection leads to

1528
00:50:05,010 --> 00:50:06,140
great performance.

1529
00:50:11,250 --> 00:50:12,450
An example if you look at

1530
00:50:12,450 --> 00:50:14,040
an operating system Linux,

1531
00:50:14,040 --> 00:50:16,080
it actually achieves a very

1532
00:50:16,080 --> 00:50:17,300
impressive performance.

1533
00:50:17,420 --> 00:50:18,890
Um, and so there's a one,

1534
00:50:18,890 --> 00:50:22,310
one design, another design

1535
00:50:22,310 --> 00:50:24,290
which basically focuses on reducing the

1536
00:50:24,290 --> 00:50:25,910
amount of code in the kernel

1537
00:50:25,910 --> 00:50:28,220
is what's called micro kernel design.

1538
00:50:35,100 --> 00:50:36,270
And in this design,

1539
00:50:36,270 --> 00:50:37,410
your goal is actually to run

1540
00:50:37,410 --> 00:50:39,690
as few lines as possible in

1541
00:50:39,690 --> 00:50:41,580
kernel mode and for example there

1542
00:50:41,580 --> 00:50:43,640
is something often kernel.

1543
00:50:44,250 --> 00:50:46,260
But the kernel has very few,

1544
00:50:46,260 --> 00:50:48,210
um, components to it,

1545
00:50:48,210 --> 00:50:50,190
so general typically has some form

1546
00:50:50,190 --> 00:50:52,400
of IPC or message passing.

1547
00:50:53,030 --> 00:50:55,190
A little bit of vm support

1548
00:50:55,190 --> 00:50:56,340
very minimal.

1549
00:50:56,920 --> 00:50:59,020
Basically, only thing necessary for page

1550
00:50:59,020 --> 00:51:01,780
tables and something to multiplex

1551
00:51:01,930 --> 00:51:04,220
different CPUs.

1552
00:51:04,820 --> 00:51:06,480
So it's a multiplexing code.

1553
00:51:09,610 --> 00:51:11,320
But generally the goal is to

1554
00:51:11,320 --> 00:51:13,060
[earn] the bug of the operating

1555
00:51:13,060 --> 00:51:14,920
system outside of the kernel,

1556
00:51:14,920 --> 00:51:16,480
and so for example again, as we

1557
00:51:16,480 --> 00:51:18,610
have our boundary here,

1558
00:51:18,610 --> 00:51:20,380
um what we'll do is actually

1559
00:51:20,380 --> 00:51:22,300
we'll run other parts of the

1560
00:51:22,300 --> 00:51:24,730
kernel as normal user applications,

1561
00:51:24,730 --> 00:51:27,220
for example we might have,

1562
00:51:34,380 --> 00:51:36,570
you might have a user process,

1563
00:51:36,570 --> 00:51:39,450
still not intended but doesn't matter,

1564
00:51:39,450 --> 00:51:40,660
you know I just did

1565
00:51:40,870 --> 00:51:41,880
file server.

1566
00:51:42,160 --> 00:51:43,660
And so and then the

1567
00:51:43,660 --> 00:51:44,170
file servers,

1568
00:51:44,170 --> 00:51:46,060
just regular user space.

1569
00:51:46,620 --> 00:51:48,000
User space kernel,

1570
00:51:48,000 --> 00:51:49,440
so even though I drew,

1571
00:51:49,440 --> 00:51:50,040
by accident,

1572
00:51:50,040 --> 00:51:51,780
in red, I intended to draw out

1573
00:51:51,780 --> 00:51:53,850
in black, the faucets are mine, running

1574
00:51:53,850 --> 00:51:57,120
user application like, you know, echo.

1575
00:51:57,320 --> 00:51:58,580
You know the shell,

1576
00:51:58,580 --> 00:52:00,050
they're all running in user space

1577
00:52:00,050 --> 00:52:01,640
and we might have other user

1578
00:52:01,640 --> 00:52:03,320
applications like parts of the vm

1579
00:52:03,320 --> 00:52:05,000
system might actually run the regular

1580
00:52:05,000 --> 00:52:06,360
user application

1581
00:52:06,930 --> 00:52:09,460
in user mode.

1582
00:52:09,860 --> 00:52:10,610
And so this is sort of

1583
00:52:10,610 --> 00:52:11,450
a nice design correct,

1584
00:52:11,450 --> 00:52:13,100
because the amount of code

1585
00:52:13,100 --> 00:52:14,180
that presumably that's in the

1586
00:52:14,180 --> 00:52:15,900
kernel is small.

1587
00:52:18,820 --> 00:52:21,430
It's small and small means,

1588
00:52:21,430 --> 00:52:23,060
hopefully fewer bugs.

1589
00:52:28,050 --> 00:52:30,000
The one issue of course is

1590
00:52:30,000 --> 00:52:30,720
like you know we have to

1591
00:52:30,720 --> 00:52:32,340
arrange that shell can talk to

1592
00:52:32,340 --> 00:52:33,630
the file system, for example,

1593
00:52:33,630 --> 00:52:35,610
the shell calls exec and there

1594
00:52:35,610 --> 00:52:36,390
has to be a way of

1595
00:52:36,390 --> 00:52:37,920
getting to the file system.

1596
00:52:38,000 --> 00:52:38,990
And so typically the way

1597
00:52:38,990 --> 00:52:40,220
it works is that the

1598
00:52:40,220 --> 00:52:41,900
shell will send a message

1599
00:52:41,900 --> 00:52:43,600
through the IPC system

1600
00:52:44,030 --> 00:52:45,290
to the kernel.

1601
00:52:45,290 --> 00:52:46,190
The kernel will look at and

1602
00:52:46,190 --> 00:52:47,060
say like, oh you know this

1603
00:52:47,060 --> 00:52:48,410
is intended for the file systems

1604
00:52:48,410 --> 00:52:49,580
and file systems and sensitive to

1605
00:52:49,580 --> 00:52:50,700
the file system.

1606
00:52:51,590 --> 00:52:53,220
The file system doesn't work.

1607
00:52:53,640 --> 00:52:55,410
You know sends a message back

1608
00:52:55,410 --> 00:52:56,160
saying you know,

1609
00:52:56,160 --> 00:52:57,840
here's the results of your exec

1610
00:52:57,840 --> 00:52:59,790
system call and then you send

1611
00:52:59,790 --> 00:53:01,200
it back to the shell.

1612
00:53:01,830 --> 00:53:02,640
And so,

1613
00:53:02,640 --> 00:53:04,770
um, these are typically implemented

1614
00:53:04,770 --> 00:53:05,780
using messages.

1615
00:53:06,020 --> 00:53:08,330
Um, and so for any interaction

1616
00:53:08,330 --> 00:53:09,470
with the file server,

1617
00:53:09,470 --> 00:53:11,330
now you have to jump once

1618
00:53:12,080 --> 00:53:13,490
once out of the kernel, once

1619
00:53:13,490 --> 00:53:14,300
into the kernel,

1620
00:53:14,300 --> 00:53:15,480
once out of the kernel.

1621
00:53:15,740 --> 00:53:16,550
If you compare that with

1622
00:53:16,550 --> 00:53:18,620
the previous design like if

1623
00:53:18,620 --> 00:53:19,580
this guy wants to talk

1624
00:53:19,580 --> 00:53:20,570
to the file system,

1625
00:53:20,570 --> 00:53:22,160
it's one system call in and

1626
00:53:22,160 --> 00:53:23,980
one basically call back out.

1627
00:53:24,190 --> 00:53:25,510
And so you double the number

1628
00:53:25,510 --> 00:53:28,280
of a system call entries.

1629
00:53:28,860 --> 00:53:32,040
And so, one typical problem

1630
00:53:32,040 --> 00:53:32,700
or challenge,

1631
00:53:32,700 --> 00:53:34,950
with offer the micro kernel approaches

1632
00:53:34,950 --> 00:53:36,360
is actually how to achieve

1633
00:53:36,360 --> 00:53:37,340
good performance.

1634
00:53:37,900 --> 00:53:38,680
And it has sort of two

1635
00:53:38,680 --> 00:53:39,800
components to it.

1636
00:53:42,180 --> 00:53:43,770
Um, you know just jumping back

1637
00:53:43,770 --> 00:53:45,450
and forth between user mode and

1638
00:53:45,450 --> 00:53:46,830
kernel mode to actually get something

1639
00:53:46,830 --> 00:53:48,630
done and the second part is

1640
00:53:48,630 --> 00:53:50,460
because you know the different pieces

1641
00:53:50,460 --> 00:53:52,080
are really well isolated from each

1642
00:53:52,080 --> 00:53:54,210
other a tight integration is less,

1643
00:53:54,210 --> 00:53:56,640
you know more complicated to arrange

1644
00:53:56,640 --> 00:53:57,870
than for example in the monolithic

1645
00:53:57,870 --> 00:54:00,600
kernel where basically everybody can example

1646
00:54:00,600 --> 00:54:01,590
the file system in the virtual

1647
00:54:01,590 --> 00:54:03,840
memory system can easily share a

1648
00:54:03,840 --> 00:54:05,310
page cache which a little bit

1649
00:54:05,310 --> 00:54:06,720
harder to achieve in the micro

1650
00:54:06,720 --> 00:54:08,310
kernel design and therefore it's sometimes

1651
00:54:08,310 --> 00:54:10,800
more difficult to get high performance.

1652
00:54:12,170 --> 00:54:14,600
Now these distinctions between micro

1653
00:54:14,600 --> 00:54:16,790
and monolithic very high-level.

1654
00:54:16,790 --> 00:54:17,900
So in practice,

1655
00:54:17,960 --> 00:54:19,820
both types of kernel design

1656
00:54:19,820 --> 00:54:22,910
show up, most desktop operating

1657
00:54:22,910 --> 00:54:25,670
systems are typically monolithic systems,

1658
00:54:25,670 --> 00:54:27,620
motion for historical reasons.

1659
00:54:27,780 --> 00:54:29,820
A lot of the if you

1660
00:54:29,820 --> 00:54:31,860
run a very intense you know

1661
00:54:31,860 --> 00:54:33,810
OS intense applications for example in

1662
00:54:33,810 --> 00:54:34,530
the data center,

1663
00:54:34,530 --> 00:54:36,600
they typically run on a monolithic

1664
00:54:36,600 --> 00:54:39,570
kernel, mostly because example Linux

1665
00:54:39,570 --> 00:54:41,060
provides great performance.

1666
00:54:41,060 --> 00:54:44,120
But many, for example, embedding settings

1667
00:54:44,120 --> 00:54:48,320
like minix or [cell4], those tend

1668
00:54:48,320 --> 00:54:50,600
to be micro kernel designs.

1669
00:54:51,470 --> 00:54:53,180
And so both designs are popular,

1670
00:54:53,180 --> 00:54:54,530
um, you could probably start a

1671
00:54:54,530 --> 00:54:56,420
new operation system from scratch.

1672
00:54:56,480 --> 00:54:59,150
Um, you probably start with,

1673
00:54:59,150 --> 00:55:01,460
you know, you may start

1674
00:55:01,460 --> 00:55:03,040
with a micro kernel design.

1675
00:55:03,240 --> 00:55:05,310
Once you have a monolithic

1676
00:55:05,310 --> 00:55:06,990
design like for example Linux,

1677
00:55:06,990 --> 00:55:08,130
it's going to be would

1678
00:55:08,130 --> 00:55:09,150
be a ton of work

1679
00:55:09,150 --> 00:55:10,080
to rewrite anything to a

1680
00:55:10,080 --> 00:55:12,060
micro kernel design as maybe

1681
00:55:12,060 --> 00:55:13,710
not conducive to the incentives

1682
00:55:13,710 --> 00:55:14,790
people probably want to spend

1683
00:55:14,790 --> 00:55:16,770
rather time including new features

1684
00:55:16,770 --> 00:55:17,760
than actually,

1685
00:55:18,660 --> 00:55:20,580
restructuring,

1686
00:55:20,580 --> 00:55:21,340
the kernel.

1687
00:55:22,180 --> 00:55:23,110
Um, so,

1688
00:55:23,110 --> 00:55:25,630
these are sort of two main designs,

1689
00:55:25,630 --> 00:55:27,970
um, as you know xv6 is

1690
00:55:27,970 --> 00:55:30,280
falls into monolithic design is

1691
00:55:30,280 --> 00:55:32,380
most classic unix systems do,

1692
00:55:32,380 --> 00:55:34,120
but later in the semester,

1693
00:55:34,120 --> 00:55:35,470
um, we'll talk a lot more

1694
00:55:35,470 --> 00:55:37,000
in detail about some of the

1695
00:55:37,000 --> 00:55:38,320
micro kernel designs.

1696
00:55:40,170 --> 00:55:41,580
Any questions about this because this

1697
00:55:41,580 --> 00:55:43,240
was a hot topic in the,

1698
00:55:43,810 --> 00:55:45,300
in the email of questions.

1699
00:55:56,060 --> 00:55:56,870
Um, okay,

1700
00:55:56,870 --> 00:55:58,670
let me switch little bit.

1701
00:55:58,670 --> 00:55:59,750
I'm going to get to some

1702
00:55:59,750 --> 00:56:01,760
code and see how this plays

1703
00:56:01,760 --> 00:56:04,120
out in xv6.

1704
00:56:05,930 --> 00:56:09,140
Um, so we're here two windows.

1705
00:56:09,840 --> 00:56:12,390
Um, and you know, emacs, you

1706
00:56:12,390 --> 00:56:14,260
know with like the proc structure.

1707
00:56:14,420 --> 00:56:15,680
Um, and the first thing I

1708
00:56:15,680 --> 00:56:16,880
wanna do is,

1709
00:56:16,880 --> 00:56:18,620
um, you look a little bit

1710
00:56:18,620 --> 00:56:19,880
at the code base, you've

1711
00:56:19,880 --> 00:56:21,050
probably already done this,

1712
00:56:21,050 --> 00:56:22,070
but you see that the code

1713
00:56:22,070 --> 00:56:23,930
is sort of organized along three,

1714
00:56:23,930 --> 00:56:27,540
three parts one the kernel.

1715
00:56:27,720 --> 00:56:29,700
And you know kernel that basically

1716
00:56:29,700 --> 00:56:33,690
includes all the kernel files xv6

1717
00:56:33,690 --> 00:56:35,370
being a monolithic kernel,

1718
00:56:35,370 --> 00:56:38,460
basically all these programs are compiled

1719
00:56:38,460 --> 00:56:39,690
into a single binary called the

1720
00:56:39,690 --> 00:56:41,070
kernel and that's actually what you

1721
00:56:41,070 --> 00:56:42,400
run in kernel mode.

1722
00:56:43,360 --> 00:56:45,250
Um, and then you know there's

1723
00:56:45,250 --> 00:56:47,020
user and those are basically the

1724
00:56:47,020 --> 00:56:48,430
programs that run in user mode,

1725
00:56:48,430 --> 00:56:49,450
and this is why you're going

1726
00:56:49,450 --> 00:56:50,350
to want is called kernel and

1727
00:56:50,350 --> 00:56:51,600
the other called current user.

1728
00:56:52,080 --> 00:56:53,460
And then there's one more program

1729
00:56:53,460 --> 00:56:54,810
called 'mkfs',

1730
00:56:54,810 --> 00:56:56,850
um, which actually builds an

1731
00:56:56,850 --> 00:56:59,400
empty file system image that we've

1732
00:56:59,400 --> 00:57:00,480
stored on disk.

1733
00:57:00,590 --> 00:57:01,760
Um, so that we can get

1734
00:57:01,760 --> 00:57:03,740
off the ground with an empty

1735
00:57:03,740 --> 00:57:04,500
file system.

1736
00:57:09,160 --> 00:57:11,560
Okay so before so you switch

1737
00:57:11,560 --> 00:57:13,240
back again to I want to

1738
00:57:13,240 --> 00:57:14,080
say a little bit about how

1739
00:57:14,080 --> 00:57:15,600
the kernel is compiled.

1740
00:57:16,130 --> 00:57:17,600
Um, because you probably have seen

1741
00:57:17,600 --> 00:57:18,650
this and you might not really

1742
00:57:18,650 --> 00:57:21,200
have realized it, it's important

1743
00:57:21,200 --> 00:57:22,100
to understand.

1744
00:57:22,420 --> 00:57:24,900
Um, so when the kernel,

1745
00:57:25,270 --> 00:57:26,680
the construction of the kernel,

1746
00:57:26,680 --> 00:57:28,870
the makefile basically takes one

1747
00:57:28,870 --> 00:57:30,430
of these C files like

1748
00:57:30,430 --> 00:57:31,460
proc.c.

1749
00:57:31,950 --> 00:57:33,120
You know invokes you know

1750
00:57:33,120 --> 00:57:34,590
the GCC,

1751
00:57:34,590 --> 00:57:37,980
the GCC compiler that generates a

1752
00:57:37,980 --> 00:57:40,020
file called proc.S.

1753
00:57:40,190 --> 00:57:41,920
That goes to the similar.

1754
00:57:44,800 --> 00:57:46,150
And this is basically

1755
00:57:46,150 --> 00:57:47,400
RISC-V assembly.

1756
00:57:49,360 --> 00:57:50,680
And that actually produces a

1757
00:57:50,680 --> 00:57:51,490
file proc.o,

1758
00:57:51,490 --> 00:57:53,410
and basically that's you know

1759
00:57:53,410 --> 00:57:55,860
the binary version of the assembler.

1760
00:57:56,260 --> 00:57:58,120
Um, and you know the makefile

1761
00:57:58,120 --> 00:57:59,590
does this rule, you know

1762
00:57:59,590 --> 00:58:00,940
part files in the kernel,

1763
00:58:00,940 --> 00:58:03,120
so example, pipe.

1764
00:58:03,380 --> 00:58:04,880
Another one you know,

1765
00:58:04,880 --> 00:58:07,640
same story GCC compiles to

1766
00:58:07,640 --> 00:58:08,640
pipe.S.

1767
00:58:09,240 --> 00:58:10,680
And you know go to through

1768
00:58:10,680 --> 00:58:13,300
similar and we get pipe.o.

1769
00:58:14,080 --> 00:58:16,020
And basically then the loader,

1770
00:58:17,020 --> 00:58:19,040
it takes all these .o files.

1771
00:58:19,450 --> 00:58:20,830
From all the different you know

1772
00:58:20,830 --> 00:58:23,290
files and links them together and

1773
00:58:23,290 --> 00:58:25,660
produces, produces the kernel.

1774
00:58:28,480 --> 00:58:29,560
And as actually then what

1775
00:58:29,560 --> 00:58:30,320
we run.

1776
00:58:30,900 --> 00:58:32,850
And you know, for your convenience,

1777
00:58:32,850 --> 00:58:33,630
you know the makefile

1778
00:58:33,630 --> 00:58:34,890
also produces a file called

1779
00:58:34,890 --> 00:58:36,280
kernel.asm.

1780
00:58:39,110 --> 00:58:43,250
That has the complete kernel,

1781
00:58:43,250 --> 00:58:45,410
disassembled and you can just look

1782
00:58:45,410 --> 00:58:46,610
at it and you know that

1783
00:58:46,610 --> 00:58:47,990
helps later on when you have

1784
00:58:47,990 --> 00:58:49,040
kernel bugs and it's easy to

1785
00:58:49,040 --> 00:58:50,540
see which instruction,

1786
00:58:50,540 --> 00:58:52,160
um, was executed at the point

1787
00:58:52,160 --> 00:58:53,520
you got the bug.

1788
00:58:53,790 --> 00:58:55,200
As an example if I,

1789
00:58:57,060 --> 00:58:59,640
here, kernel.asm.

1790
00:58:59,990 --> 00:59:00,980
Um, we see,

1791
00:59:00,980 --> 00:59:03,830
um, here's the kernel file

1792
00:59:03,830 --> 00:59:05,360
if you send instructions.

1793
00:59:05,570 --> 00:59:07,670
And, um one thing you know,

1794
00:59:07,670 --> 00:59:09,260
for example is not the first.

1795
00:59:09,480 --> 00:59:11,160
A instruction is located at

1796
00:59:11,160 --> 00:59:12,480
this address 800000

1797
00:59:12,480 --> 00:59:14,850
and

1798
00:59:14,850 --> 00:59:16,140
that is whatever

1799
00:59:16,140 --> 00:59:18,240
aupc instruction RISC-V instruction.

1800
00:59:19,470 --> 00:59:21,740
Um in.

1801
00:59:22,560 --> 00:59:24,360
Anybody knows what this is,

1802
00:59:24,360 --> 00:59:25,800
008117183136505

1803
00:59:25,800 --> 00:59:27,300
eight three one three six five

1804
00:59:27,300 --> 00:59:28,180
o five.

1805
00:59:34,760 --> 00:59:35,720
Anybody want to answer that
 
1806
00:59:35,720 --> 00:59:38,840
question? That's the hex version of

1807
00:59:38,840 --> 00:59:40,680
the assembly instructions on the right.

1808
00:59:41,010 --> 00:59:41,850
Yeah exactly,

1809
00:59:41,850 --> 00:59:43,260
so what here on the

1810
00:59:43,260 --> 00:59:44,370
008117

1811
00:59:44,370 --> 00:59:45,570
is exactly the same

1812
00:59:45,570 --> 00:59:47,760
thing as symbolic you know

1813
00:59:47,760 --> 00:59:49,360
the textual version of that,

1814
00:59:49,540 --> 00:59:51,190
aupc and so basically

1815
00:59:51,190 --> 00:59:53,680
this is the binary encoding of

1816
00:59:53,680 --> 00:59:54,940
the actual instruction.

1817
00:59:56,120 --> 00:59:57,500
So, and every instruction has a

1818
00:59:57,500 --> 00:59:59,480
binary encoding and you know the

1819
00:59:59,480 --> 01:00:00,770
kernel.asm file actually

1820
01:00:00,770 --> 01:00:02,500
shows those binary encodings.

1821
01:00:03,600 --> 01:00:04,650
And this is sometimes convenient,

1822
01:00:04,650 --> 01:00:06,060
when you look at gdb and

1823
01:00:06,060 --> 01:00:06,960
you want to know what actually

1824
01:00:06,960 --> 01:00:07,830
is going on,

1825
01:00:07,830 --> 01:00:08,580
you can see actually what the

1826
01:00:08,580 --> 01:00:09,720
binary encoding is.

1827
01:00:13,630 --> 01:00:15,970
Okay, so then when we run

1828
01:00:15,970 --> 01:00:17,110
xv6, I'm going to run

1829
01:00:17,110 --> 01:00:18,070
on the inside actually let me

1830
01:00:18,070 --> 01:00:20,300
first run it without gdb.

1831
01:00:20,660 --> 01:00:21,950
Um, you know compile a

1832
01:00:21,950 --> 01:00:23,000
bunch of stuff and then

1833
01:00:23,000 --> 01:00:25,460
invokes QEMU.

1834
01:00:25,920 --> 01:00:27,030
And this is a visibly

1835
01:00:27,030 --> 01:00:28,320
C program,

1836
01:00:28,320 --> 01:00:30,510
um that simulates or emulates a

1837
01:00:30,510 --> 01:00:31,740
RISC-V processor.

1838
01:00:32,180 --> 01:00:33,080
You can see here in

1839
01:00:33,080 --> 01:00:34,670
the -kernel flag actually

1840
01:00:34,670 --> 01:00:36,040
passes the kernel.

1841
01:00:36,340 --> 01:00:38,950
As the program to

1842
01:00:38,950 --> 01:00:41,170
be run inside of QEMU

1843
01:00:41,170 --> 01:00:43,420
and QEMU and the kernel

1844
01:00:43,420 --> 01:00:45,940
agreed basically the starting place

1845
01:00:45,940 --> 01:00:47,380
for any program is to

1846
01:00:47,380 --> 01:00:48,670
address

1847
01:00:48,670 --> 01:00:49,300
80000.

1848
01:00:50,120 --> 01:00:51,050
And we see that we passed

1849
01:00:51,050 --> 01:00:52,220
a couple of flags in QEMU,

1850
01:00:52,220 --> 01:00:52,850
it's just you know,

1851
01:00:52,850 --> 01:00:54,320
um, that's an amount of

1852
01:00:54,320 --> 01:00:56,390
memory that the machine does

1853
01:00:56,390 --> 01:00:57,840
virtual machine has.

1854
01:00:57,840 --> 01:00:59,670
This virtual RISC-V machine,

1855
01:00:59,670 --> 01:01:01,200
um, it passes in how many

1856
01:01:01,200 --> 01:01:02,480
of course there are

1857
01:01:02,540 --> 01:01:05,120
passes in the machine,

1858
01:01:05,120 --> 01:01:06,920
the disk drive which contains

1859
01:01:06,920 --> 01:01:07,880
the file

1860
01:01:07,880 --> 01:01:08,700
fs.img.

1861
01:01:08,860 --> 01:01:09,700
And so basically a bunch of

1862
01:01:09,700 --> 01:01:10,720
things are sort of set up

1863
01:01:10,720 --> 01:01:12,130
to make QEMU behave

1864
01:01:12,130 --> 01:01:13,180
like a real computer.

1865
01:01:14,610 --> 01:01:16,200
And so one way when you

1866
01:01:16,200 --> 01:01:16,800
think about QEMU,

1867
01:01:16,800 --> 01:01:18,990
you really should not think about

1868
01:01:18,990 --> 01:01:20,820
it as a C program, really

1869
01:01:20,820 --> 01:01:21,720
the way you should think about

1870
01:01:21,720 --> 01:01:23,760
it is as follows.

1871
01:01:24,630 --> 01:01:26,460
Um, you should think about it

1872
01:01:26,460 --> 01:01:28,640
as,

1873
01:01:30,900 --> 01:01:31,960
as this.

1874
01:01:32,550 --> 01:01:35,460
Namely a real board,

1875
01:01:35,460 --> 01:01:36,090
um, so,

1876
01:01:36,090 --> 01:01:37,260
for example the on the left

1877
01:01:37,260 --> 01:01:38,610
you know this is a

1878
01:01:38,610 --> 01:01:39,600
RISC-V board.

1879
01:01:39,630 --> 01:01:41,130
Um, actually the RISC-V board that

1880
01:01:41,130 --> 01:01:43,320
sits in my office and you

1881
01:01:43,320 --> 01:01:44,640
know it can boot more

1882
01:01:44,640 --> 01:01:45,860
or less xv6.

1883
01:01:46,340 --> 01:01:47,900
And so when you're running you

1884
01:01:47,900 --> 01:01:50,180
know QEMU, with your kernel

1885
01:01:50,180 --> 01:01:51,110
used to think about it that

1886
01:01:51,110 --> 01:01:52,960
actually running it on this board.

1887
01:01:53,330 --> 01:01:54,920
And I know the board has

1888
01:01:54,920 --> 01:01:56,420
been on off button,

1889
01:01:56,420 --> 01:01:58,490
here's actually to

1890
01:01:58,490 --> 01:02:00,240
RISC-V processor.

1891
01:02:00,360 --> 01:02:01,920
Um, you know there's room

1892
01:02:01,920 --> 01:02:03,330
for peripherals,

1893
01:02:03,330 --> 01:02:05,370
for example one of these connectors

1894
01:02:05,370 --> 01:02:07,120
is a connector for ethernet.

1895
01:02:07,480 --> 01:02:09,520
Um, one is that PCI

1896
01:02:09,520 --> 01:02:10,540
slots,

1897
01:02:10,540 --> 01:02:12,490
yeah there's some ram chips on

1898
01:02:12,490 --> 01:02:14,620
the board I don't exactly know

1899
01:02:14,620 --> 01:02:15,250
where they are,

1900
01:02:15,250 --> 01:02:16,140
but there are.

1901
01:02:16,480 --> 01:02:18,070
Um, and so this is sort

1902
01:02:18,070 --> 01:02:20,260
of a that's the physical hardware,

1903
01:02:20,260 --> 01:02:22,570
the computer actually, actually you're programming

1904
01:02:22,570 --> 01:02:24,190
so xv6 manages

1905
01:02:24,190 --> 01:02:25,020
this board.

1906
01:02:25,590 --> 01:02:27,390
Um, and that's the picture usually

1907
01:02:27,390 --> 01:02:28,400
have in your head.

1908
01:02:29,030 --> 01:02:30,740
And in fact if you zoom

1909
01:02:30,740 --> 01:02:32,450
in you can find all the

1910
01:02:32,450 --> 01:02:34,730
documentation of what actually sits inside

1911
01:02:34,730 --> 01:02:35,440
of this.

1912
01:02:35,790 --> 01:02:37,620
Um, and inside of this,

1913
01:02:37,620 --> 01:02:39,060
you know there's a inside of

1914
01:02:39,060 --> 01:02:41,160
this RISC-V processor,

1915
01:02:41,160 --> 01:02:42,690
the schema for the

1916
01:02:42,690 --> 01:02:44,310
RISC-V processor is shown in

1917
01:02:44,310 --> 01:02:45,340
this picture here.

1918
01:02:45,730 --> 01:02:47,380
Um, and you know see here,

1919
01:02:47,380 --> 01:02:49,380
for example there are multiple cores.

1920
01:02:49,650 --> 01:02:50,130
In fact,

1921
01:02:50,130 --> 01:02:51,540
four cores,

1922
01:02:51,540 --> 01:02:53,610
um, you know there's a

1923
01:02:53,610 --> 01:02:55,050
l2 cache,

1924
01:02:55,050 --> 01:02:57,320
um, there's a connector to dram.

1925
01:02:57,380 --> 01:02:59,330
Um, you know there's a bunch

1926
01:02:59,330 --> 01:03:00,230
of ways to connect to the

1927
01:03:00,230 --> 01:03:01,910
outside world, so you here

1928
01:03:01,910 --> 01:03:03,860
UART0 and UART0 was

1929
01:03:03,860 --> 01:03:06,260
actually connected on one end to

1930
01:03:06,260 --> 01:03:07,670
the keyboard and to the other

1931
01:03:07,670 --> 01:03:09,040
end to the display.

1932
01:03:09,320 --> 01:03:10,760
Um, and you know there are

1933
01:03:10,760 --> 01:03:12,740
some ways to actually, um, get

1934
01:03:12,740 --> 01:03:15,740
clocks going. I'll talk about in

1935
01:03:15,740 --> 01:03:17,090
much more detail later,

1936
01:03:17,090 --> 01:03:18,680
but these are all the components

1937
01:03:18,680 --> 01:03:20,180
that basically you know the

1938
01:03:20,180 --> 01:03:21,590
xv6 or things that you will

1939
01:03:21,590 --> 01:03:23,570
be modifying to interact with the

1940
01:03:23,570 --> 01:03:24,460
real hard work.

1941
01:03:24,910 --> 01:03:26,220
And in fact the

1942
01:03:26,890 --> 01:03:28,600
computer system or the computer board

1943
01:03:28,600 --> 01:03:31,060
that actually is emulated by QEMU

1944
01:03:31,060 --> 01:03:33,040
is pretty close,

1945
01:03:33,040 --> 01:03:35,200
you know minus some small details

1946
01:03:35,200 --> 01:03:37,120
to this particular no computer board

1947
01:03:37,120 --> 01:03:38,660
which is made by SiFive.

1948
01:03:39,470 --> 01:03:41,600
Um, unfortunately I can't tell you

1949
01:03:41,600 --> 01:03:43,310
the real thing I just sit

1950
01:03:43,310 --> 01:03:44,060
in my office,

1951
01:03:44,060 --> 01:03:45,200
you know and I haven't been in

1952
01:03:45,200 --> 01:03:46,500
my office since March.

1953
01:03:46,540 --> 01:03:47,440
From collecting a lot of

1954
01:03:47,440 --> 01:03:49,900
dust, but it's important to

1955
01:03:49,900 --> 01:03:51,010
keep in your head when

1956
01:03:51,010 --> 01:03:52,390
you're running QEMU, you're

1957
01:03:52,390 --> 01:03:54,620
running basically on real hardware.

1958
01:03:55,060 --> 01:03:56,080
And just happens to be able

1959
01:03:56,080 --> 01:03:57,060
to software.

1960
01:04:02,630 --> 01:04:03,640
Does that make sense.

1961
01:04:04,820 --> 01:04:06,180
[Password] second year.

1962
01:04:11,560 --> 01:04:12,730
So let me say a little

1963
01:04:12,730 --> 01:04:13,570
bit more about it,

1964
01:04:13,570 --> 01:04:14,560
so what does it mean for

1965
01:04:14,560 --> 01:04:16,580
QEMU to emulate

1966
01:04:20,450 --> 01:04:22,080
RISC-V processor.

1967
01:04:24,940 --> 01:04:26,440
Well, literally you know if you

1968
01:04:26,440 --> 01:04:27,400
think about it,

1969
01:04:27,400 --> 01:04:28,870
you know as I said, QEMU

1970
01:04:28,870 --> 01:04:30,430
simulate program it's an open

1971
01:04:30,430 --> 01:04:31,420
source C program,

1972
01:04:31,420 --> 01:04:32,350
it's a big program,

1973
01:04:32,350 --> 01:04:34,240
you can actually just download it

1974
01:04:34,240 --> 01:04:35,820
or get clone it.

1975
01:04:35,890 --> 01:04:37,720
Um, but internally into C,

1976
01:04:37,720 --> 01:04:39,700
is basically for loop,

1977
01:04:39,880 --> 01:04:41,340
an infinite for loop.

1978
01:04:42,220 --> 01:04:43,690
That does nothing else than

1979
01:04:43,690 --> 01:04:44,900
read instruction.

1980
01:04:48,700 --> 01:04:52,030
RISC-V instruction basically reached four

1981
01:04:52,030 --> 01:04:53,410
byte or eight bytes,

1982
01:04:53,410 --> 01:04:55,870
um, and basically looks at

1983
01:04:55,870 --> 01:04:57,400
the bits in that instruction

1984
01:04:57,400 --> 01:04:58,520
and decodes them.

1985
01:04:58,840 --> 01:04:59,950
Figures out what the op

1986
01:04:59,950 --> 01:05:00,760
code is.

1987
01:05:03,630 --> 01:05:04,860
And we saw back for some

1988
01:05:04,860 --> 01:05:05,550
of the instructions,

1989
01:05:05,550 --> 01:05:07,230
the binary version of those instructions

1990
01:05:07,230 --> 01:05:09,120
in the .asm file.

1991
01:05:09,280 --> 01:05:10,570
So decodes the instruction,

1992
01:05:10,570 --> 01:05:11,110
so for example,

1993
01:05:11,110 --> 01:05:12,250
maybe it will decide this is

1994
01:05:12,250 --> 01:05:13,320
an add instruction,

1995
01:05:14,250 --> 01:05:15,900
sub instruction,

1996
01:05:15,900 --> 01:05:16,710
RISC-V sub instruction,

1997
01:05:16,710 --> 01:05:18,240
and then basically it executes

1998
01:05:18,240 --> 01:05:19,140
the instruction.

1999
01:05:21,840 --> 01:05:22,940
I mean software.

2000
01:05:25,240 --> 01:05:26,650
And you know that basically

2001
01:05:26,650 --> 01:05:27,610
is all what it does

2002
01:05:27,610 --> 01:05:28,540
for every core,

2003
01:05:28,540 --> 01:05:30,520
you know runs this particular loop.

2004
01:05:30,990 --> 01:05:32,490
And in addition sort of doing

2005
01:05:32,490 --> 01:05:33,630
this loop has to maintain some

2006
01:05:33,630 --> 01:05:35,130
states to maintain state for all

2007
01:05:35,130 --> 01:05:36,020
the registers.

2008
01:05:37,020 --> 01:05:39,510
So it has C decoration for

2009
01:05:39,510 --> 01:05:41,460
like x0, register 0,

2010
01:05:41,460 --> 01:05:42,920
x1 etc.

2011
01:05:44,360 --> 01:05:45,590
And so basically when it executes

2012
01:05:45,590 --> 01:05:46,730
instruction, for example,

2013
01:05:46,730 --> 01:05:48,440
the instruction is like whatever.

2014
01:05:50,000 --> 01:05:53,620
You know a0,

2015
01:05:53,730 --> 01:05:55,020
one to seven, and stored in

2016
01:05:55,020 --> 01:05:57,060
a0, invisible it takes constant

2017
01:05:57,060 --> 01:05:58,470
seven one adds them up and

2018
01:05:58,470 --> 01:05:59,720
sticks into a0.

2019
01:06:00,300 --> 01:06:02,490
Examples for seven in it, and then

2020
01:06:02,490 --> 01:06:03,660
it actually gets next instruction

2021
01:06:03,660 --> 01:06:05,120
and it keeps going, keeps going.

2022
01:06:05,890 --> 01:06:07,840
In addition to visually emulating or

2023
01:06:07,840 --> 01:06:10,600
correctly all the imprivilege instructions,

2024
01:06:10,600 --> 01:06:11,680
it also emulates all the

2025
01:06:11,680 --> 01:06:12,840
privileged instructions.

2026
01:06:13,440 --> 01:06:13,980
So that is,

2027
01:06:13,980 --> 01:06:16,410
in essence, what QEMU does,

2028
01:06:16,410 --> 01:06:18,210
in, the best picture for

2029
01:06:18,210 --> 01:06:19,290
you to have your head is

2030
01:06:19,290 --> 01:06:20,310
the visible you're running on a

2031
01:06:20,310 --> 01:06:22,260
real physical RISC-V processor.

2032
01:06:22,620 --> 01:06:23,850
Like the ones you have probably

2033
01:06:23,850 --> 01:06:25,200
you know many of you implemented

2034
01:06:25,200 --> 01:06:27,200
one after 6.004.

2035
01:06:30,340 --> 01:06:31,620
Any questions about this.

2036
01:06:32,780 --> 01:06:33,560
Um, hi,

2037
01:06:33,560 --> 01:06:35,120
yeah I was wondering if it

2038
01:06:35,120 --> 01:06:37,370
does any hardware tricks,

2039
01:06:37,370 --> 01:06:40,500
so like overlapping instructions or anything.

2040
01:06:41,000 --> 01:06:42,650
Um I know,

2041
01:06:42,650 --> 01:06:43,970
um, it runs on a real

2042
01:06:43,970 --> 01:06:45,560
process below it correctly when you

2043
01:06:45,560 --> 01:06:46,580
run QEMU,

2044
01:06:46,580 --> 01:06:47,600
it runs probably on an

2045
01:06:47,600 --> 01:06:49,040
x86 processor.

2046
01:06:49,290 --> 01:06:50,880
The x86 processor and does all

2047
01:06:50,880 --> 01:06:53,340
kinds of tricks to pipeline instructions

2048
01:06:53,340 --> 01:06:54,480
and things like that right,

2049
01:06:54,480 --> 01:06:55,830
so the way you think about

2050
01:06:55,830 --> 01:06:57,380
QEMU, just a C program.

2051
01:07:00,570 --> 01:07:01,140
Makes sense,

2052
01:07:01,140 --> 01:07:02,040
thank you.

2053
01:07:08,410 --> 01:07:10,210
What about multi threading so if

2054
01:07:10,210 --> 01:07:12,880
the, the QEMU supports you

2055
01:07:12,880 --> 01:07:14,440
said four cores or does it

2056
01:07:14,440 --> 01:07:16,540
only support one and it's in

2057
01:07:16,540 --> 01:07:17,080
that case,

2058
01:07:17,080 --> 01:07:18,820
does it have actually multiple threads

2059
01:07:18,820 --> 01:07:19,660
running it.

2060
01:07:20,040 --> 01:07:21,990
Yeah, so actually the QEMU that

2061
01:07:21,990 --> 01:07:23,820
we use on the Athena, and

2062
01:07:23,820 --> 01:07:24,570
were probably the ones that you

2063
01:07:24,570 --> 01:07:25,770
actually download,

2064
01:07:25,770 --> 01:07:28,500
um, they will use multiple threads

2065
01:07:28,500 --> 01:07:30,420
internally so you internally use it

2066
01:07:30,420 --> 01:07:31,260
to get parallelism,

2067
01:07:31,260 --> 01:07:32,700
so in fact,

2068
01:07:32,720 --> 01:07:34,610
these four cores that are being

2069
01:07:34,610 --> 01:07:37,220
emulated or being emulated in parallel.

2070
01:07:40,040 --> 01:07:40,910
And we'll see that in one

2071
01:07:40,910 --> 01:07:43,040
of the labs later, how how

2072
01:07:43,040 --> 01:07:44,060
that plays out.

2073
01:07:44,540 --> 01:07:45,740
Yeah, so definitely there's a

2074
01:07:45,740 --> 01:07:47,270
real parallelism going on between

2075
01:07:47,270 --> 01:07:48,160
the different cores.

2076
01:07:54,100 --> 01:07:55,750
Okay, um,

2077
01:07:55,750 --> 01:07:57,070
so I'm gonna do a little

2078
01:07:57,070 --> 01:08:01,390
bit of, walking through

2079
01:08:01,390 --> 01:08:02,680
xv6 to get a

2080
01:08:02,680 --> 01:08:03,340
little bit of sense,

2081
01:08:03,340 --> 01:08:04,060
what the layout of the

2082
01:08:04,060 --> 01:08:04,920
land is.

2083
01:08:05,090 --> 01:08:07,070
Um in, in later lecture again

2084
01:08:07,070 --> 01:08:07,700
we're going to go in much

2085
01:08:07,700 --> 01:08:08,480
more detail.

2086
01:08:08,800 --> 01:08:10,420
Um, so I'm gonna fire up

2087
01:08:10,420 --> 01:08:12,370
QEMU and um,

2088
01:08:12,370 --> 01:08:14,260
with gdb supports, basic

2089
01:08:14,260 --> 01:08:15,760
QEMU has inside of it

2090
01:08:15,760 --> 01:08:17,220
a gdb server.

2091
01:08:17,560 --> 01:08:19,600
Um, and so it started up

2092
01:08:19,600 --> 01:08:20,740
and then just wait,

2093
01:08:20,740 --> 01:08:22,390
you know for a gdb

2094
01:08:22,390 --> 01:08:23,160
to connect.

2095
01:08:23,620 --> 01:08:25,720
To that I'm going to start

2096
01:08:25,720 --> 01:08:26,890
here on my computer,

2097
01:08:26,890 --> 01:08:28,690
this is a risc-64-linux

2098
01:08:28,690 --> 01:08:29,820
new gdb.

2099
01:08:30,050 --> 01:08:31,700
Um, some of your machines might

2100
01:08:31,700 --> 01:08:34,180
be multi arch or something else.

2101
01:08:34,230 --> 01:08:35,490
Um, but basically the gdb

2102
01:08:35,490 --> 01:08:37,380
compiled for risc-64,

2103
01:08:37,380 --> 01:08:38,360
RISC-V 64.

2104
01:08:39,580 --> 01:08:41,650
And I'm going to set the

2105
01:08:41,650 --> 01:08:43,570
break point at entry because that's

2106
01:08:43,570 --> 01:08:44,920
the first we know it has

2107
01:08:44,920 --> 01:08:46,440
roughly the first instruction.

2108
01:08:46,570 --> 01:08:48,400
That actually working is going to

2109
01:08:48,400 --> 01:08:49,640
jump to.

2110
01:08:50,060 --> 01:08:52,160
I set the break point run

2111
01:08:52,160 --> 01:08:54,290
and basically, it doesn't actually break

2112
01:08:54,290 --> 01:08:56,000
exactly at 8000

2113
01:08:56,000 --> 01:08:57,740
but at 0a and if we

2114
01:08:57,740 --> 01:08:59,390
look here on the right we

2115
01:08:59,390 --> 01:09:01,020
see that 0a is,

2116
01:09:01,100 --> 01:09:03,200
right reading the

2117
01:09:03,950 --> 01:09:05,600
control system register

2118
01:09:05,600 --> 01:09:07,910
mhartid and loading that value

2119
01:09:07,910 --> 01:09:09,020
into a1.

2120
01:09:09,720 --> 01:09:11,580
And so basically QEMU simulates

2121
01:09:11,580 --> 01:09:12,360
the instruction,

2122
01:09:12,360 --> 01:09:13,710
then we can execute that instruction,

2123
01:09:13,710 --> 01:09:14,310
then we go to the

2124
01:09:14,310 --> 01:09:15,220
next instruction.

2125
01:09:16,790 --> 01:09:19,760
Um, in basically, this address 8000

2126
01:09:19,760 --> 01:09:21,320
it's just basically something

2127
01:09:21,320 --> 01:09:23,480
that was agreed on, you know

2128
01:09:23,480 --> 01:09:26,870
by QEMU or QEMU told,

2129
01:09:26,870 --> 01:09:28,190
you know basically says,

2130
01:09:28,190 --> 01:09:29,660
you want to use QEMU

2131
01:09:29,660 --> 01:09:30,350
the first instruction,

2132
01:09:30,350 --> 01:09:31,370
we're going to jump to is

2133
01:09:31,370 --> 01:09:32,900
at that particular location.

2134
01:09:33,170 --> 01:09:36,020
And we basically arranged for the

2135
01:09:36,020 --> 01:09:37,200
kernel loader.

2136
01:09:38,320 --> 01:09:40,180
To load the kernel that

2137
01:09:40,180 --> 01:09:41,410
program so there's a file

2138
01:09:41,410 --> 01:09:42,680
kernel.ld.

2139
01:09:42,740 --> 01:09:44,870
That basically specifies how the kernel

2140
01:09:44,870 --> 01:09:46,010
should be loaded,

2141
01:09:46,010 --> 01:09:47,540
and you see here that basically

2142
01:09:47,540 --> 01:09:49,370
the first address that the kernel

2143
01:09:49,370 --> 01:09:50,540
is going to use, is actually

2144
01:09:50,540 --> 01:09:51,380
that particular address,

2145
01:09:51,380 --> 01:09:52,960
the basic view you specified.

2146
01:09:54,120 --> 01:09:54,930
This is how we get off

2147
01:09:54,930 --> 01:09:55,720
the ground.

2148
01:09:58,430 --> 01:09:59,900
Does that make sense.

2149
01:10:04,820 --> 01:10:06,560
Okay, um,

2150
01:10:06,560 --> 01:10:07,970
we see also that here actually

2151
01:10:07,970 --> 01:10:10,070
gdb shows the binary encoding of

2152
01:10:10,070 --> 01:10:11,120
the instructions.

2153
01:10:11,660 --> 01:10:12,920
And so we see that basically

2154
01:10:12,920 --> 01:10:15,100
I guess the csrr, is a,

2155
01:10:15,750 --> 01:10:16,760
um, yeah,

2156
01:10:17,320 --> 01:10:19,000
four byte instruction and addi is

2157
01:10:19,000 --> 01:10:20,140
a two byte instruction.

2158
01:10:22,090 --> 01:10:25,270
Okay, I'm going to see, basically

2159
01:10:25,270 --> 01:10:27,130
so actually starts basically starts at

2160
01:10:27,130 --> 01:10:28,260
entry.S .

2161
01:10:28,360 --> 01:10:30,400
Um, yeah we've no paging with

2162
01:10:30,400 --> 01:10:31,660
no isolation and in fact we're

2163
01:10:31,660 --> 01:10:32,780
starting in [mode].

2164
01:10:33,260 --> 01:10:35,660
Exclusive jumps as quickly as

2165
01:10:35,660 --> 01:10:37,880
possible to

2166
01:10:37,940 --> 01:10:39,320
kernel mode or supervisor mode,

2167
01:10:39,320 --> 01:10:40,910
that called in RISC-V, I'm just

2168
01:10:40,910 --> 01:10:41,930
going to set a break point

2169
01:10:41,930 --> 01:10:43,790
at main which actually runs in

2170
01:10:43,790 --> 01:10:44,630
supervisor mode,

2171
01:10:44,630 --> 01:10:45,800
I'm going to run there.

2172
01:10:46,350 --> 01:10:47,550
And then I get to the

2173
01:10:47,550 --> 01:10:49,620
first instruction of main. So,

2174
01:10:50,750 --> 01:10:53,210
let me show this, here's main

2175
01:10:53,210 --> 01:10:54,720
in,

2176
01:10:54,980 --> 01:10:57,710
um, I'd like to run gdb

2177
01:10:57,710 --> 01:10:58,310
in this layout,

2178
01:10:58,310 --> 01:10:59,380
split mode.

2179
01:11:02,290 --> 01:11:03,460
So you can see in gdb

2180
01:11:03,460 --> 01:11:05,050
actually and what the next instruction

2181
01:11:05,050 --> 01:11:06,430
is being executed so you see,

2182
01:11:06,430 --> 01:11:07,690
there's a break point at that

2183
01:11:07,690 --> 01:11:08,980
particular instruction.

2184
01:11:09,180 --> 01:11:12,640
Um, since there's a run

2185
01:11:12,750 --> 01:11:14,610
QEMU with one CPU,

2186
01:11:14,610 --> 01:11:15,690
just makes it, gdb a

2187
01:11:15,690 --> 01:11:16,770
little bit easier,

2188
01:11:16,770 --> 01:11:17,970
so there's now only one

2189
01:11:17,970 --> 01:11:19,080
core active.

2190
01:11:19,450 --> 01:11:21,130
QEMU emulates only one

2191
01:11:21,130 --> 01:11:22,840
single core and I can

2192
01:11:22,840 --> 01:11:24,190
step through that,

2193
01:11:24,190 --> 01:11:25,450
so I can go through

2194
01:11:25,450 --> 01:11:27,310
the next instruction and others

2195
01:11:27,310 --> 01:11:28,480
calls a function called console

2196
01:11:28,480 --> 01:11:30,040
init which does exactly

2197
01:11:30,040 --> 01:11:31,000
what you imagine it does

2198
01:11:31,000 --> 01:11:31,750
it actually sets up the

2199
01:11:31,750 --> 01:11:32,580
console.

2200
01:11:32,960 --> 01:11:34,040
And so once we set up

2201
01:11:34,040 --> 01:11:34,520
the console,

2202
01:11:34,520 --> 01:11:36,200
we can actually print to it

2203
01:11:36,200 --> 01:11:37,180
and so,

2204
01:11:37,240 --> 01:11:38,530
you'll see in a second we'll

2205
01:11:38,530 --> 01:11:40,060
get a new line and will

2206
01:11:40,060 --> 01:11:41,520
get xv6 booting.

2207
01:11:42,250 --> 01:11:43,870
Okay so there's a whole bunch

2208
01:11:43,870 --> 01:11:45,720
of additional, um,

2209
01:11:45,970 --> 01:11:47,200
code to set things up,

2210
01:11:47,200 --> 01:11:49,000
you know there's a setting up

2211
01:11:49,000 --> 01:11:50,290
the page allocator,

2212
01:11:50,290 --> 01:11:52,780
setting up a virtual memory, which

2213
01:11:52,780 --> 01:11:54,730
we'll talk about on wednesday, loading

2214
01:11:54,730 --> 01:11:56,530
actually starting turning paging on, which

2215
01:11:56,530 --> 01:11:58,160
I also talk about on wednesday.

2216
01:11:58,300 --> 01:12:00,640
Um, setting up the initial processes

2217
01:12:00,640 --> 01:12:02,470
or sending the process table,

2218
01:12:02,470 --> 01:12:04,330
setting up code due to

2219
01:12:04,330 --> 01:12:06,250
the use of the kernel position,

2220
01:12:06,250 --> 01:12:08,860
setting up the interrupt control

2221
01:12:08,860 --> 01:12:10,720
the plic, we'll talk about when

2222
01:12:10,720 --> 01:12:11,590
we talk about interrupts,

2223
01:12:11,590 --> 01:12:13,060
but this is one thing that.

2224
01:12:13,320 --> 01:12:14,970
Um, we're gonna be using to

2225
01:12:14,970 --> 01:12:16,290
basically talk to the disk or

2226
01:12:16,290 --> 01:12:17,500
talk to the

2227
01:12:17,520 --> 01:12:19,140
console using interrupts,

2228
01:12:19,140 --> 01:12:21,060
sets up the file system

2229
01:12:21,060 --> 01:12:25,110
allocates a buffer cache initialize the

2230
01:12:25,110 --> 01:12:27,270
inode cache, initialize the file system

2231
01:12:27,270 --> 01:12:28,760
initialize the disk.

2232
01:12:29,060 --> 01:12:31,100
And then basically once all sort

2233
01:12:31,100 --> 01:12:32,030
of things are set up,

2234
01:12:32,030 --> 01:12:32,990
you know when the operating system

2235
01:12:32,990 --> 01:12:33,680
is running,

2236
01:12:33,680 --> 01:12:34,580
it's going to start running the

2237
01:12:34,580 --> 01:12:36,470
first process and this is the

2238
01:12:36,470 --> 01:12:37,400
user init.

2239
01:12:38,010 --> 01:12:39,030
So there's a little bit of

2240
01:12:39,030 --> 01:12:40,380
interesting, so I'm going to go

2241
01:12:40,380 --> 01:12:41,250
to user init,

2242
01:12:41,250 --> 01:12:42,840
um, for a second I'm going

2243
01:12:42,840 --> 01:12:43,920
to single step there.

2244
01:12:46,040 --> 01:12:48,170
Um, before continue, any questions

2245
01:12:48,170 --> 01:12:48,900
about this.

2246
01:12:54,180 --> 01:12:55,590
Is there a specific order in

2247
01:12:55,590 --> 01:12:57,510
which the set-up functions need to

2248
01:12:57,510 --> 01:12:58,340
be called.

2249
01:12:58,410 --> 01:13:00,990
Yes, some function,

2250
01:13:00,990 --> 01:13:02,580
once we run after other functions

2251
01:13:02,580 --> 01:13:03,450
and um,

2252
01:13:03,450 --> 01:13:05,580
they're in particular in there some

2253
01:13:05,580 --> 01:13:06,360
of them doesn't matter,

2254
01:13:06,360 --> 01:13:07,170
but a few of them yeah

2255
01:13:07,170 --> 01:13:08,310
it's important that they run after

2256
01:13:08,310 --> 01:13:08,980
other ones.

2257
01:13:11,350 --> 01:13:12,100
Good point.

2258
01:13:12,840 --> 01:13:14,040
Okay, um,

2259
01:13:14,040 --> 01:13:15,500
let me go to,

2260
01:13:16,920 --> 01:13:18,740
um, so user init.

2261
01:13:19,300 --> 01:13:20,320
And basically user init there's

2262
01:13:20,320 --> 01:13:22,000
a little bit of glue code

2263
01:13:22,000 --> 01:13:24,250
organization code to take advantage of

2264
01:13:24,250 --> 01:13:26,830
all the general infrastructure decks have

2265
01:13:26,830 --> 01:13:28,180
basically get the first process of

2266
01:13:28,180 --> 01:13:28,960
the ground.

2267
01:13:29,430 --> 01:13:30,600
Um, you know xv6 needs

2268
01:13:30,600 --> 01:13:31,590
some image,

2269
01:13:31,590 --> 01:13:32,970
we can't run the file system

2270
01:13:32,970 --> 01:13:33,860
really yet.

2271
01:13:33,940 --> 01:13:35,740
Um, or do exec,

2272
01:13:35,740 --> 01:13:37,870
um, and so xv6 server

2273
01:13:37,870 --> 01:13:39,340
small little program to get off

2274
01:13:39,340 --> 01:13:40,630
the ground and that small little

2275
01:13:40,630 --> 01:13:43,780
program is init code.

2276
01:13:44,100 --> 01:13:45,420
And the binary version of that

2277
01:13:45,420 --> 01:13:48,270
program is actually linked or declared

2278
01:13:48,270 --> 01:13:50,190
statically into the kernel and the

2279
01:13:50,190 --> 01:13:52,160
fact that code corresponds

2280
01:13:54,300 --> 01:13:57,220
to this particular user program.

2281
01:14:00,290 --> 01:14:02,150
It's a, it's a little

2282
01:14:02,150 --> 01:14:04,550
program written in assembly and basically

2283
01:14:04,550 --> 01:14:06,590
it does, loads the address in it

2284
01:14:06,590 --> 01:14:08,510
into a0, it loads

2285
01:14:08,510 --> 01:14:10,100
the address of argv into

2286
01:14:10,100 --> 01:14:11,020
a1.

2287
01:14:11,160 --> 01:14:12,390
And then it loads the number

2288
01:14:12,390 --> 01:14:14,010
for this SYS_exec in

2289
01:14:14,010 --> 01:14:15,960
to a7 and then look

2290
01:14:15,960 --> 01:14:17,880
at the here, that calls ecall.

2291
01:14:18,510 --> 01:14:19,740
So basically what it does is

2292
01:14:19,740 --> 01:14:22,200
running three instructions and then running

2293
01:14:22,200 --> 01:14:24,120
the fourth instructions which basically transfer

2294
01:14:24,120 --> 01:14:26,720
back control to the,

2295
01:14:28,430 --> 01:14:30,980
back control to the operating system,

2296
01:14:30,980 --> 01:14:31,970
so generally if I set a

2297
01:14:31,970 --> 01:14:32,940
break point

2298
01:14:33,120 --> 01:14:34,800
in syscall.

2299
01:14:35,300 --> 01:14:36,650
Um, and now keep running then

2300
01:14:36,650 --> 01:14:38,510
basically you know user init,

2301
01:14:38,510 --> 01:14:40,700
you know will create the initial

2302
01:14:40,700 --> 01:14:43,580
process return to user space run

2303
01:14:43,580 --> 01:14:45,060
the screen instructions.

2304
01:14:45,210 --> 01:14:46,200
Or for instruction,

2305
01:14:46,200 --> 01:14:47,430
and basically come back into

2306
01:14:47,430 --> 01:14:48,400
kernel space.

2307
01:14:49,040 --> 01:14:50,120
So imagine this is the first

2308
01:14:50,120 --> 01:14:52,850
system call that any user application

2309
01:14:52,850 --> 01:14:53,930
in xv6 runs,

2310
01:14:53,930 --> 01:14:55,200
so let's see what happens.

2311
01:14:55,320 --> 01:14:56,320
If I'm right.

2312
01:14:57,090 --> 01:14:59,520
So we're continue and we

2313
01:14:59,520 --> 01:15:00,900
actually got to syscall.

2314
01:15:04,540 --> 01:15:05,650
Um, so we can syscall we

2315
01:15:05,650 --> 01:15:07,270
can look at it it's a

2316
01:15:07,270 --> 01:15:08,520
function at the bottom.

2317
01:15:09,340 --> 01:15:10,660
And so we're back into kernel

2318
01:15:10,660 --> 01:15:12,610
space now and we're going to

2319
01:15:12,610 --> 01:15:13,960
walk through and see actually what

2320
01:15:13,960 --> 01:15:15,660
happens exactly in

2321
01:15:15,750 --> 01:15:17,700
syscall, also I'm gonna single

2322
01:15:17,700 --> 01:15:18,800
step a little bit.

2323
01:15:19,190 --> 01:15:21,080
Um, it looks about the current,

2324
01:15:21,080 --> 01:15:22,490
the processes within it,

2325
01:15:22,490 --> 01:15:24,440
you know that pulls out the

2326
01:15:24,440 --> 01:15:25,280
system call number,

2327
01:15:25,280 --> 01:15:26,330
that's used so we can now

2328
01:15:26,330 --> 01:15:27,440
print num.

2329
01:15:27,890 --> 01:15:29,540
And let's see that's seven.

2330
01:15:29,980 --> 01:15:32,200
And if we look at which,

2331
01:15:34,130 --> 01:15:37,160
user when kernel

2332
01:15:37,160 --> 01:15:38,200
syscall.h .

2333
01:15:38,660 --> 01:15:40,130
That declares all the system call

2334
01:15:40,130 --> 01:15:42,200
numbers and we see seven that

2335
01:15:42,200 --> 01:15:44,200
is indeed system called exec.

2336
01:15:44,940 --> 01:15:45,900
And so basically this tells

2337
01:15:45,900 --> 01:15:46,950
the kernel that you know

2338
01:15:46,950 --> 01:15:48,380
some user application.

2339
01:15:48,510 --> 01:15:51,330
A called an echo instruction and

2340
01:15:51,330 --> 01:15:52,680
with the intention of calling this

2341
01:15:52,680 --> 01:15:55,320
system call for,

2342
01:15:58,180 --> 01:15:59,020
with the intention of running the

2343
01:15:59,020 --> 01:16:00,160
exec system call.

2344
01:16:00,910 --> 01:16:02,140
And so we can single step

2345
01:16:02,140 --> 01:16:03,280
a little bit further um,

2346
01:16:03,280 --> 01:16:04,570
we go through the next thing,

2347
01:16:04,570 --> 01:16:05,740
this is the line that executes

2348
01:16:05,740 --> 01:16:06,430
a system call,

2349
01:16:06,430 --> 01:16:07,540
so let's go there.

2350
01:16:07,800 --> 01:16:09,450
And you see that basically the

2351
01:16:09,450 --> 01:16:11,100
number is used to index into

2352
01:16:11,100 --> 01:16:12,570
an array and arrays as a

2353
01:16:12,570 --> 01:16:14,040
bunch of function pointers.

2354
01:16:14,240 --> 01:16:17,120
And presumably, the sys entry,

2355
01:16:17,120 --> 01:16:18,560
you know points to the sys

2356
01:16:18,560 --> 01:16:19,580
exec function,

2357
01:16:19,580 --> 01:16:20,900
so we're going to single step

2358
01:16:20,900 --> 01:16:22,020
into this.

2359
01:16:22,920 --> 01:16:24,180
And, um,

2360
01:16:24,180 --> 01:16:25,410
we see that we're actually at

2361
01:16:25,410 --> 01:16:26,760
the sys exec.

2362
01:16:29,540 --> 01:16:30,800
Um, so this is in

2363
01:16:30,800 --> 01:16:32,060
sys file.

2364
01:16:32,810 --> 01:16:33,680
Now we can move it a

2365
01:16:33,680 --> 01:16:36,460
little bit more and bigger window.

2366
01:16:36,520 --> 01:16:38,040
And we basically see

2367
01:16:38,310 --> 01:16:41,220
here, the system call.

2368
01:16:41,650 --> 01:16:42,790
Um, and the first thing that

2369
01:16:42,790 --> 01:16:44,560
you see actually it actually gets

2370
01:16:44,560 --> 01:16:46,210
arguments from user space so it

2371
01:16:46,210 --> 01:16:47,540
gets the path name.

2372
01:16:47,790 --> 01:16:49,320
So we want jump a little

2373
01:16:49,320 --> 01:16:50,340
bit further.

2374
01:16:50,950 --> 01:16:54,040
memset, um,

2375
01:16:55,430 --> 01:16:56,780
um,

2376
01:16:57,220 --> 01:16:59,470
basically allocates space for arguments,

2377
01:16:59,470 --> 01:17:00,760
you know copys all the arguments

2378
01:17:00,760 --> 01:17:02,080
from user space to kernel space,

2379
01:17:02,080 --> 01:17:03,760
we'll look down in great amount

2380
01:17:03,760 --> 01:17:05,050
of detail in a couple weeks

2381
01:17:05,050 --> 01:17:06,130
so don't worry about it too

2382
01:17:06,130 --> 01:17:06,920
much yet.

2383
01:17:07,190 --> 01:17:09,110
But basically there's some code to

2384
01:17:09,110 --> 01:17:10,730
move arguments user space to

2385
01:17:10,730 --> 01:17:11,480
kernel space,

2386
01:17:11,480 --> 01:17:12,590
you know from the kernel, from

2387
01:17:12,590 --> 01:17:13,880
the user address space to kernel

2388
01:17:13,880 --> 01:17:15,000
address space.

2389
01:17:15,110 --> 01:17:15,860
And if we now look

2390
01:17:15,860 --> 01:17:16,520
at path,

2391
01:17:16,520 --> 01:17:18,520
you can print the path hopefully.

2392
01:17:18,780 --> 01:17:20,190
You'll see actually that you

2393
01:17:20,190 --> 01:17:21,720
know that is a string

2394
01:17:21,720 --> 01:17:23,550
and you'll see that basically

2395
01:17:23,550 --> 01:17:25,320
what that little inner code

2396
01:17:25,320 --> 01:17:27,210
program does is trying to

2397
01:17:27,210 --> 01:17:28,830
exex you know the init

2398
01:17:28,830 --> 01:17:29,580
program.

2399
01:17:29,790 --> 01:17:31,650
Which is yet another program,

2400
01:17:31,650 --> 01:17:32,760
so let's look at that for

2401
01:17:32,760 --> 01:17:34,240
a second just to see

2402
01:17:34,370 --> 01:17:35,420
what that is.

2403
01:17:38,140 --> 01:17:39,130
So here we have init

2404
01:17:39,130 --> 01:17:40,780
and init basically

2405
01:17:40,780 --> 01:17:41,860
sets up a couple things

2406
01:17:41,860 --> 01:17:43,030
use for user space,

2407
01:17:43,030 --> 01:17:44,650
it opens to console, the file

2408
01:17:44,650 --> 01:17:46,660
descriptor for the console, dup it

2409
01:17:46,660 --> 01:17:47,840
a couple times.

2410
01:17:48,000 --> 01:17:50,610
Calls fork and basically the first

2411
01:17:50,610 --> 01:17:52,050
thing it does actually it starts

2412
01:17:52,050 --> 01:17:53,840
to create a new process.

2413
01:17:53,920 --> 01:17:56,650
And we'll exit the shell and

2414
01:17:56,650 --> 01:17:58,120
so this will in the end

2415
01:17:58,120 --> 01:18:00,380
result as the shell being run.

2416
01:18:01,020 --> 01:18:01,980
So, for example if I would

2417
01:18:01,980 --> 01:18:03,480
continue I probably break again,

2418
01:18:03,480 --> 01:18:04,230
it says exec,

2419
01:18:04,230 --> 01:18:05,010
and if I look at the

2420
01:18:05,010 --> 01:18:06,810
arguments I will see that actually

2421
01:18:06,810 --> 01:18:08,550
the exec system call is being

2422
01:18:08,550 --> 01:18:11,140
called to execs the shell.

2423
01:18:11,510 --> 01:18:12,830
And once you exit the shell,

2424
01:18:12,830 --> 01:18:13,040
you know,

2425
01:18:13,040 --> 01:18:14,450
let's do that,

2426
01:18:14,450 --> 01:18:16,280
then we'll do a couple more

2427
01:18:16,280 --> 01:18:17,960
system calls and at some point

2428
01:18:17,960 --> 01:18:19,000
you'll see that.

2429
01:18:19,900 --> 01:18:22,480
I'm gonna do continue then basically

2430
01:18:22,480 --> 01:18:23,700
the shell starts running.

2431
01:18:24,930 --> 01:18:25,680
So it gives you a little

2432
01:18:25,680 --> 01:18:26,700
bit of sense,

2433
01:18:26,700 --> 01:18:28,170
you know actually how xv6

2434
01:18:28,170 --> 01:18:29,850
gets off the ground, the

2435
01:18:29,850 --> 01:18:31,890
first shell exit gets run and

2436
01:18:31,890 --> 01:18:33,360
we saw this sort of a

2437
01:18:33,360 --> 01:18:34,710
little bit of an overview about

2438
01:18:34,710 --> 01:18:36,150
how the first when the first

2439
01:18:36,150 --> 01:18:37,540
system call actually happened.

2440
01:18:38,160 --> 01:18:39,510
We haven't really looked at the

2441
01:18:39,510 --> 01:18:41,430
dive machinery for these system calls

2442
01:18:41,430 --> 01:18:42,390
how to get in and out

2443
01:18:42,390 --> 01:18:43,260
of the kernel,

2444
01:18:43,260 --> 01:18:44,160
we're going to talk about it

2445
01:18:44,160 --> 01:18:45,570
in a couple weeks or two

2446
01:18:45,570 --> 01:18:47,190
weeks in lecture, in great

2447
01:18:47,190 --> 01:18:48,000
amount of detail,

2448
01:18:48,000 --> 01:18:48,630
but this is sort of

2449
01:18:48,630 --> 01:18:50,220
enough for you to understand

2450
01:18:50,220 --> 01:18:51,510
actually how to do the

2451
01:18:51,510 --> 01:18:52,710
syscall lab, you know that

2452
01:18:52,710 --> 01:18:54,360
we assigned for this week.

2453
01:18:54,670 --> 01:18:55,960
Um, and so these are

2454
01:18:55,960 --> 01:18:56,740
the pieces that you will

2455
01:18:56,740 --> 01:18:57,720
be interacting with.

2456
01:18:59,120 --> 01:19:00,980
Any questions before I wrap up,

2457
01:19:00,980 --> 01:19:02,600
because we're almost out of time.

2458
01:19:08,330 --> 01:19:09,720
You're free to fire away.

2459
01:19:15,680 --> 01:19:17,240
Are we going to do anything

2460
01:19:17,240 --> 01:19:20,180
with, um, networks are like networking

2461
01:19:20,180 --> 01:19:21,680
and labs.

2462
01:19:21,810 --> 01:19:23,580
Yes, the last lab is

2463
01:19:23,580 --> 01:19:25,360
you implement a network driver.

2464
01:19:25,560 --> 01:19:26,340
And so you will write the

2465
01:19:26,340 --> 01:19:28,050
code that interacts with the hardware

2466
01:19:28,050 --> 01:19:30,080
you have to manipulate the

2467
01:19:30,280 --> 01:19:32,380
register for the network driver or

2468
01:19:32,380 --> 01:19:34,480
a network card.

2469
01:19:34,680 --> 01:19:36,300
Um that basically connects you to

2470
01:19:36,300 --> 01:19:37,560
this RISC-V board, you know

2471
01:19:37,560 --> 01:19:38,940
you saw that was a block

2472
01:19:38,940 --> 01:19:40,800
basically to plugin an ethernet control,

2473
01:19:40,800 --> 01:19:42,330
a cable so there's an

2474
01:19:42,330 --> 01:19:43,940
ethernet card.

2475
01:19:44,260 --> 01:19:45,580
And so you're gonna be programming

2476
01:19:45,580 --> 01:19:47,410
that card and you're gonna actually

2477
01:19:47,410 --> 01:19:49,160
send some packets across the Internet.

2478
01:19:51,690 --> 01:19:53,100
Great, thanks. Yeah,

2479
01:19:53,100 --> 01:19:54,140
it's the last lab.

2480
01:19:58,160 --> 01:19:59,280
Any other questions.

2481
01:20:04,270 --> 01:20:05,110
We're gonna let me wrap up

2482
01:20:05,110 --> 01:20:06,520
here I think the syscall

2483
01:20:06,520 --> 01:20:07,660
lab itself,

2484
01:20:07,660 --> 01:20:10,030
um because we're not really going

2485
01:20:10,030 --> 01:20:11,080
great amount of detail,

2486
01:20:11,080 --> 01:20:12,430
hopefully shouldn't be too bad,

2487
01:20:12,430 --> 01:20:13,480
might be easier than

2488
01:20:13,480 --> 01:20:14,680
the util lab.

2489
01:20:14,880 --> 01:20:16,650
Labs, next lab,

2490
01:20:16,650 --> 01:20:18,210
however might be more difficult,

2491
01:20:18,210 --> 01:20:19,200
so it's always hard to get

2492
01:20:19,200 --> 01:20:20,130
all these labs right,

2493
01:20:20,130 --> 01:20:21,810
but syscall lab hopefully it shouldn't

2494
01:20:21,810 --> 01:20:23,280
be too difficult,

2495
01:20:23,280 --> 01:20:24,990
but please don't start don't

2496
01:20:24,990 --> 01:20:26,340
wait until the night before

2497
01:20:26,340 --> 01:20:27,660
get going early,

2498
01:20:27,660 --> 01:20:28,650
so that if you're running some

2499
01:20:28,650 --> 01:20:30,060
obscure bug that we can actually

2500
01:20:30,060 --> 01:20:31,470
help you out and make sure

2501
01:20:31,470 --> 01:20:33,500
that your program works in it.

2502
01:20:35,270 --> 01:20:36,200
With that,

2503
01:20:36,200 --> 01:20:38,900
um, I'll sign off and I'll

2504
01:20:38,900 --> 01:20:40,060
see you in Wednesday.

