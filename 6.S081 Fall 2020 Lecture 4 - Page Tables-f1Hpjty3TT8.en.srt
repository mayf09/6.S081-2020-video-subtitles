1
00:00:00,080 --> 00:00:04,630
sound check can everybody hear me

2
00:00:04,640 --> 00:00:07,759
oh yep yup all right

3
00:00:07,759 --> 00:00:09,920
okay so welcome to uh the next lecture

4
00:00:09,920 --> 00:00:11,200
in s081

5
00:00:11,200 --> 00:00:14,639
uh wherever you are a particular

6
00:00:14,639 --> 00:00:16,240
i hope that the folks on the west coast

7
00:00:16,240 --> 00:00:18,880
or in florida and alabama do okay

8
00:00:18,880 --> 00:00:21,439
given all the terrible circumstances

9
00:00:21,439 --> 00:00:22,480
there

10
00:00:22,480 --> 00:00:27,199
um so uh the topic for today

11
00:00:27,199 --> 00:00:29,039
is virtual memory particularly we're

12
00:00:29,039 --> 00:00:30,480
going to talk about page tables

13
00:00:30,480 --> 00:00:32,880
uh we'll return to this topic uh a few

14
00:00:32,880 --> 00:00:34,640
times there will be multiple filicular

15
00:00:34,640 --> 00:00:36,000
lectures

16
00:00:36,000 --> 00:00:38,160
and maybe just to start off and you know

17
00:00:38,160 --> 00:00:42,160
get our question and answer going again

18
00:00:42,160 --> 00:00:43,760
i would like to ask you a little bit

19
00:00:43,760 --> 00:00:45,280
what do you remember from

20
00:00:45,280 --> 00:00:47,840
uh about virtual memory from double o4

21
00:00:47,840 --> 00:00:48,879
maybe and or

22
00:00:48,879 --> 00:00:50,879
uh nor six or two three if you're taking

23
00:00:50,879 --> 00:00:52,480
that uh

24
00:00:52,480 --> 00:00:54,559
i'll tell you my own sort of view on

25
00:00:54,559 --> 00:00:56,160
virtual memory which is you know why i

26
00:00:56,160 --> 00:00:57,760
took it when i first heard about it or

27
00:00:57,760 --> 00:00:59,199
learned about it as a student

28
00:00:59,199 --> 00:01:00,320
i thought you know it's pretty

29
00:01:00,320 --> 00:01:01,920
straightforward you know hard can it be

30
00:01:01,920 --> 00:01:03,199
it's a table that

31
00:01:03,199 --> 00:01:04,479
you know maps virtual addresses to

32
00:01:04,479 --> 00:01:06,560
physical addresses now uh

33
00:01:06,560 --> 00:01:08,000
you know maybe a little more complicated

34
00:01:08,000 --> 00:01:10,320
but you know not that complicated

35
00:01:10,320 --> 00:01:11,840
and only when you start programming them

36
00:01:11,840 --> 00:01:14,080
with it i should really have learned

37
00:01:14,080 --> 00:01:17,280
that uh future memory is tricky and uh

38
00:01:17,280 --> 00:01:21,360
fascinating um and very powerful

39
00:01:21,360 --> 00:01:23,759
and so hopefully in the next you know

40
00:01:23,759 --> 00:01:24,400
couple

41
00:01:24,400 --> 00:01:26,080
lectures in the next couple laps you

42
00:01:26,080 --> 00:01:27,680
know you'll you'll uh

43
00:01:27,680 --> 00:01:29,759
you'll appreciate uh virtual memory from

44
00:01:29,759 --> 00:01:30,960
that perspective

45
00:01:30,960 --> 00:01:32,479
uh but we'll ask you a couple people

46
00:01:32,479 --> 00:01:34,320
here that are online you know what do

47
00:01:34,320 --> 00:01:35,040
you remember from

48
00:01:35,040 --> 00:01:37,280
uh about virtual memory uh from either

49
00:01:37,280 --> 00:01:38,479
double o four or

50
00:01:38,479 --> 00:01:40,320
six or five if you're taking it and

51
00:01:40,320 --> 00:01:41,520
again i'm just going to call out some

52
00:01:41,520 --> 00:01:42,399
names and

53
00:01:42,399 --> 00:01:45,439
you know share your your

54
00:01:45,439 --> 00:01:52,950
your memories about the adela yang

55
00:01:52,960 --> 00:01:55,119
oh sorry what was the question uh what

56
00:01:55,119 --> 00:01:56,159
do you remember

57
00:01:56,159 --> 00:01:59,280
uh about virtual memory from maybe 04

58
00:01:59,280 --> 00:02:03,119
or 623 if you have taken that um

59
00:02:03,119 --> 00:02:06,560
it uses like offset to save on like uh

60
00:02:06,560 --> 00:02:09,039
remembering virtual address to physical

61
00:02:09,039 --> 00:02:11,599
address mappings

62
00:02:11,599 --> 00:02:20,070
okay uh how about abraham skandera

63
00:02:20,080 --> 00:02:23,200
abram are you online

64
00:02:23,200 --> 00:02:26,800
yeah uh my memory is that it uses uh

65
00:02:26,800 --> 00:02:29,120
like it's a way of one protecting the

66
00:02:29,120 --> 00:02:30,160
physical hardware

67
00:02:30,160 --> 00:02:33,599
by kind of using your representation of

68
00:02:33,599 --> 00:02:34,319
it

69
00:02:34,319 --> 00:02:36,080
um and then yeah you just have like some

70
00:02:36,080 --> 00:02:38,160
virtual address like

71
00:02:38,160 --> 00:02:40,239
at least and double it for just like 12

72
00:02:40,239 --> 00:02:41,680
bits that match

73
00:02:41,680 --> 00:02:44,560
some physical address uh that's usually

74
00:02:44,560 --> 00:02:44,959
i think

75
00:02:44,959 --> 00:02:50,640
16 bits like that

76
00:02:50,640 --> 00:02:55,430
uh how about the bibic pendant

77
00:02:55,440 --> 00:02:59,120
um what i remember was um

78
00:02:59,120 --> 00:03:02,159
you can have each process

79
00:03:02,159 --> 00:03:07,110
has a separate address space and

80
00:03:07,120 --> 00:03:09,200
the memory management unit or i mean

81
00:03:09,200 --> 00:03:11,840
some other technique can be used to map

82
00:03:11,840 --> 00:03:14,239
uh the virtual addresses of the address

83
00:03:14,239 --> 00:03:16,239
space of each of the processes to the

84
00:03:16,239 --> 00:03:17,280
physical

85
00:03:17,280 --> 00:03:20,400
um physical address and

86
00:03:20,400 --> 00:03:23,680
um the the virtual address the

87
00:03:23,680 --> 00:03:26,000
the lower bits are kind of the same so

88
00:03:26,000 --> 00:03:27,280
that uh the

89
00:03:27,280 --> 00:03:30,640
the mapping is in blocks which

90
00:03:30,640 --> 00:03:33,990
helps with performance

91
00:03:34,000 --> 00:03:39,509
uh

92
00:03:39,519 --> 00:03:42,879
i yeah um yeah i guess what i remember

93
00:03:42,879 --> 00:03:43,680
most is that

94
00:03:43,680 --> 00:03:47,680
virtual addressing allows us to um

95
00:03:47,680 --> 00:03:50,000
yeah protect physical addresses from

96
00:03:50,000 --> 00:03:51,599
from each process

97
00:03:51,599 --> 00:03:54,080
and we can use some like clever

98
00:03:54,080 --> 00:03:55,599
manipulations so that the

99
00:03:55,599 --> 00:03:57,200
bits that correspond to the physical

100
00:03:57,200 --> 00:03:59,200
address can be used somehow in the

101
00:03:59,200 --> 00:04:03,030
virtual addresses as well

102
00:04:03,040 --> 00:04:08,949
wilson spearman or spearman

103
00:04:08,959 --> 00:04:10,799
yeah i remember it's really fundamental

104
00:04:10,799 --> 00:04:13,360
to isolation because every process can

105
00:04:13,360 --> 00:04:14,080
basically

106
00:04:14,080 --> 00:04:17,199
uh pretend that it has its own uh

107
00:04:17,199 --> 00:04:20,959
set of memory to use yeah good good

108
00:04:20,959 --> 00:04:24,240
well so clearly uh that's awesome the

109
00:04:24,240 --> 00:04:26,000
the here so clear two themes a year

110
00:04:26,000 --> 00:04:27,280
correct

111
00:04:27,280 --> 00:04:28,880
one is you know there's some form of

112
00:04:28,880 --> 00:04:31,440
mapping uh and that mapping is helpful

113
00:04:31,440 --> 00:04:33,840
in sort of achieving isolation and this

114
00:04:33,840 --> 00:04:34,800
is exactly the

115
00:04:34,800 --> 00:04:37,199
reason we're talking about uh virtual

116
00:04:37,199 --> 00:04:38,960
memory you know isolation

117
00:04:38,960 --> 00:04:41,919
so what we'll see is that uh in the next

118
00:04:41,919 --> 00:04:42,479
you know the

119
00:04:42,479 --> 00:04:43,600
the next couple lectures and

120
00:04:43,600 --> 00:04:44,720
particularly when we start programming

121
00:04:44,720 --> 00:04:46,000
with virtual memory

122
00:04:46,000 --> 00:04:48,639
i really get an in-depth understanding

123
00:04:48,639 --> 00:04:49,040
uh

124
00:04:49,040 --> 00:04:52,160
what its power is uh and so to get a

125
00:04:52,160 --> 00:04:53,120
sense of that you know

126
00:04:53,120 --> 00:04:54,800
this is the first lecture and i'm mostly

127
00:04:54,800 --> 00:04:56,720
focusing on the mechanisms

128
00:04:56,720 --> 00:04:59,919
uh for uh virtual memory and then later

129
00:04:59,919 --> 00:05:01,360
we can see how we can use these

130
00:05:01,360 --> 00:05:02,560
mechanisms to achieve

131
00:05:02,560 --> 00:05:05,520
you know cool tricks so the topic for

132
00:05:05,520 --> 00:05:05,919
today

133
00:05:05,919 --> 00:05:09,039
or the agenda for today uh the plan is

134
00:05:09,039 --> 00:05:10,720
sort of free fault

135
00:05:10,720 --> 00:05:12,160
uh first i'm going to talk about the

136
00:05:12,160 --> 00:05:14,639
dress spaces as some of you mentioned in

137
00:05:14,639 --> 00:05:15,199
your

138
00:05:15,199 --> 00:05:18,960
uh just in the just mentioned

139
00:05:18,960 --> 00:05:21,440
just briefly mentioned in a response to

140
00:05:21,440 --> 00:05:22,400
this question

141
00:05:22,400 --> 00:05:23,919
uh now i'm going to talk about the

142
00:05:23,919 --> 00:05:26,960
paging hardware or paging hardener

143
00:05:26,960 --> 00:05:28,639
and i'm going to focus of course on the

144
00:05:28,639 --> 00:05:32,080
paging hardware of the risk 5

145
00:05:32,080 --> 00:05:35,520
but basically every processor uh

146
00:05:35,520 --> 00:05:38,240
modem processor has some form of aging

147
00:05:38,240 --> 00:05:38,960
hardware

148
00:05:38,960 --> 00:05:42,000
sort of d uh if you will the default

149
00:05:42,000 --> 00:05:44,400
mechanism for actually uh

150
00:05:44,400 --> 00:05:47,520
supporting virtual memory and then uh

151
00:05:47,520 --> 00:05:49,600
the last part of the lecture is going to

152
00:05:49,600 --> 00:05:50,720
walk through

153
00:05:50,720 --> 00:05:54,320
some xp6 virtual memory code

154
00:05:54,320 --> 00:05:57,520
and layout

155
00:05:57,520 --> 00:06:00,639
of you know the kernel address space and

156
00:06:00,639 --> 00:06:02,639
user address spaces

157
00:06:02,639 --> 00:06:08,230
so that's the the main plan

158
00:06:08,240 --> 00:06:11,120
okay so uh so i guess you know number of

159
00:06:11,120 --> 00:06:12,479
you mentioned

160
00:06:12,479 --> 00:06:14,400
in the response to this question you

161
00:06:14,400 --> 00:06:15,600
know

162
00:06:15,600 --> 00:06:18,639
one driving uh reason to have virtual

163
00:06:18,639 --> 00:06:20,000
memory is because you can

164
00:06:20,000 --> 00:06:22,319
use it to achieve isolation if you set

165
00:06:22,319 --> 00:06:24,080
up the page tables correctly

166
00:06:24,080 --> 00:06:26,160
and program them correctly then you can

167
00:06:26,160 --> 00:06:27,120
in principle achieve

168
00:06:27,120 --> 00:06:29,919
a strong isolation and so this is to

169
00:06:29,919 --> 00:06:31,600
remind us again you know what we want

170
00:06:31,600 --> 00:06:32,000
with

171
00:06:32,000 --> 00:06:34,160
from isolation let's just say you know

172
00:06:34,160 --> 00:06:36,000
our standard picture we have some user

173
00:06:36,000 --> 00:06:37,840
applications like the shell

174
00:06:37,840 --> 00:06:40,000
you know cat you know all the util

175
00:06:40,000 --> 00:06:41,280
things that you built

176
00:06:41,280 --> 00:06:44,639
uh in lab one and you know we have

177
00:06:44,639 --> 00:06:47,600
the kernel or you know the kernel

178
00:06:47,600 --> 00:06:48,960
sitting below through the operating

179
00:06:48,960 --> 00:06:51,280
system or sitting in kernel space

180
00:06:51,280 --> 00:06:54,400
and you know what we like to do is sort

181
00:06:54,400 --> 00:06:55,039
of have

182
00:06:55,039 --> 00:06:58,160
you know boxes around these

183
00:06:58,160 --> 00:07:01,039
uh applications so that they can really

184
00:07:01,039 --> 00:07:02,160
effective each other

185
00:07:02,160 --> 00:07:04,319
and similarly you know we want them uh

186
00:07:04,319 --> 00:07:05,360
to be

187
00:07:05,360 --> 00:07:07,520
completely sort of independent of the

188
00:07:07,520 --> 00:07:08,880
kernel in the operating system so that

189
00:07:08,880 --> 00:07:10,319
like if an application does something

190
00:07:10,319 --> 00:07:10,960
either

191
00:07:10,960 --> 00:07:14,000
accidentally bad or maliciously bad that

192
00:07:14,000 --> 00:07:15,280
doesn't really affect the operating

193
00:07:15,280 --> 00:07:17,919
system and so that's our goal

194
00:07:17,919 --> 00:07:21,199
and the particular aspect of the problem

195
00:07:21,199 --> 00:07:21,680
that we

196
00:07:21,680 --> 00:07:24,319
want to focus on today is the memory

197
00:07:24,319 --> 00:07:25,440
side of things

198
00:07:25,440 --> 00:07:28,840
so we really want to focus on memory

199
00:07:28,840 --> 00:07:30,639
isolation and

200
00:07:30,639 --> 00:07:32,639
by default you know if we don't do

201
00:07:32,639 --> 00:07:34,479
anything you know we don't really have

202
00:07:34,479 --> 00:07:36,400
memory isolation right because

203
00:07:36,400 --> 00:07:37,919
if you think about it you know there's

204
00:07:37,919 --> 00:07:39,599
going to be one you know there is five

205
00:07:39,599 --> 00:07:41,120
boards that i showed you last week you

206
00:07:41,120 --> 00:07:42,639
know it has like a memory

207
00:07:42,639 --> 00:07:45,759
a bunch of dram chips uh and

208
00:07:45,759 --> 00:07:48,080
in the drm chips you know the code for

209
00:07:48,080 --> 00:07:49,599
these applications

210
00:07:49,599 --> 00:07:51,680
uh is stored and so for example

211
00:07:51,680 --> 00:07:54,319
somewhere in the memory is the kernel

212
00:07:54,319 --> 00:07:56,639
you know text and data stack everything

213
00:07:56,639 --> 00:07:58,720
somewhere in memory is the shell if the

214
00:07:58,720 --> 00:07:59,919
shell is running

215
00:07:59,919 --> 00:08:01,919
uh somewhere in memory is the cat

216
00:08:01,919 --> 00:08:03,360
program

217
00:08:03,360 --> 00:08:06,000
um and so there's one sort of physical

218
00:08:06,000 --> 00:08:07,199
memory you know starting from someone

219
00:08:07,199 --> 00:08:08,160
through zero to

220
00:08:08,160 --> 00:08:11,120
you know so you know a big big address

221
00:08:11,120 --> 00:08:12,479
you know depending how much memory we

222
00:08:12,479 --> 00:08:14,080
actually have in our machine

223
00:08:14,080 --> 00:08:15,599
and in that physical memory all these

224
00:08:15,599 --> 00:08:17,199
programs must be present

225
00:08:17,199 --> 00:08:19,280
and otherwise you know the processor

226
00:08:19,280 --> 00:08:22,240
can't even execute their instructions

227
00:08:22,240 --> 00:08:23,919
and so what the risk you know clearly

228
00:08:23,919 --> 00:08:26,400
here is that let's say you know

229
00:08:26,400 --> 00:08:27,599
let's make it a little bit you know

230
00:08:27,599 --> 00:08:29,120
simplistic but let's say you know the

231
00:08:29,120 --> 00:08:29,840
shell

232
00:08:29,840 --> 00:08:32,159
you know sits from being addressed zero

233
00:08:32,159 --> 00:08:34,640
to address 200

234
00:08:34,640 --> 00:08:37,680
or 2000 from 1000 to 2000.

235
00:08:37,680 --> 00:08:39,360
and let's say you know the you know

236
00:08:39,360 --> 00:08:40,719
whatever cat has a

237
00:08:40,719 --> 00:08:44,159
programming error uh it loads you know

238
00:08:44,159 --> 00:08:47,680
in a register a0

239
00:08:47,680 --> 00:08:50,320
let's say it loads a thousand the

240
00:08:50,320 --> 00:08:52,000
address basically corresponding to the

241
00:08:52,000 --> 00:08:53,360
start of the shell

242
00:08:53,360 --> 00:08:55,760
and then you know by accident uh you

243
00:08:55,760 --> 00:08:57,680
know it executes the instruction

244
00:08:57,680 --> 00:09:00,720
you know dollar seven uh

245
00:09:00,720 --> 00:09:03,920
a zero correct which has the effect of

246
00:09:03,920 --> 00:09:04,160
the

247
00:09:04,160 --> 00:09:06,240
basically it writes value seven to the

248
00:09:06,240 --> 00:09:08,160
address you know one thousand and so and

249
00:09:08,160 --> 00:09:10,000
then it would be scribbling over

250
00:09:10,000 --> 00:09:12,560
you know the basically the memory image

251
00:09:12,560 --> 00:09:14,800
uh that belongs to the shell

252
00:09:14,800 --> 00:09:16,640
and so that would you know certainly not

253
00:09:16,640 --> 00:09:19,120
uh that certainly would break isolation

254
00:09:19,120 --> 00:09:22,320
uh and be quite undesirable

255
00:09:22,320 --> 00:09:24,240
and so you know we want something that

256
00:09:24,240 --> 00:09:25,839
basically really separates these

257
00:09:25,839 --> 00:09:27,200
memories from the different programs

258
00:09:27,200 --> 00:09:28,800
from each other so that things like that

259
00:09:28,800 --> 00:09:32,240
just cannot happen so one way

260
00:09:32,240 --> 00:09:36,000
you know to do that uh is an idea that's

261
00:09:36,000 --> 00:09:37,279
you know typically called the dress

262
00:09:37,279 --> 00:09:44,470
basis

263
00:09:44,480 --> 00:09:47,839
and the basic idea is straightforward

264
00:09:47,839 --> 00:09:49,600
what we want to do is basically give

265
00:09:49,600 --> 00:09:50,240
every

266
00:09:50,240 --> 00:09:53,040
application including the kernel its own

267
00:09:53,040 --> 00:09:55,120
address space

268
00:09:55,120 --> 00:09:56,560
and so we can think about this like

269
00:09:56,560 --> 00:09:58,640
example use cat running

270
00:09:58,640 --> 00:10:00,160
you know it has an address space

271
00:10:00,160 --> 00:10:01,839
starting at zero you know

272
00:10:01,839 --> 00:10:04,160
to whatever so maximum value you know

273
00:10:04,160 --> 00:10:05,200
there's a shelra

274
00:10:05,200 --> 00:10:06,880
has an address space its own address

275
00:10:06,880 --> 00:10:09,120
space also starting at address zero

276
00:10:09,120 --> 00:10:11,839
uh going to some value you know the

277
00:10:11,839 --> 00:10:14,640
kernel has its own address space

278
00:10:14,640 --> 00:10:17,680
os has its own address space

279
00:10:17,680 --> 00:10:20,320
and and so one example when cat you know

280
00:10:20,320 --> 00:10:22,160
refers to really we go back to our you

281
00:10:22,160 --> 00:10:23,839
know the example of the previous slide

282
00:10:23,839 --> 00:10:24,240
where

283
00:10:24,240 --> 00:10:27,600
you know we did uh whatever store

284
00:10:27,600 --> 00:10:30,880
seven to you know a0

285
00:10:30,880 --> 00:10:33,519
and let's say in a0 there's the value of

286
00:10:33,519 --> 00:10:34,720
1000.

287
00:10:34,720 --> 00:10:36,480
you know if cat you know executes an

288
00:10:36,480 --> 00:10:39,120
instruction uh it will write to the

289
00:10:39,120 --> 00:10:42,160
address 1000 but it is its own address

290
00:10:42,160 --> 00:10:42,959
1000.

291
00:10:42,959 --> 00:10:44,959
it's not you know the address of the

292
00:10:44,959 --> 00:10:46,320
1000 of the shell

293
00:10:46,320 --> 00:10:48,800
so basically every program runs with its

294
00:10:48,800 --> 00:10:49,920
own address space

295
00:10:49,920 --> 00:10:52,480
has its own value and those address

296
00:10:52,480 --> 00:10:54,399
spaces are completely independent

297
00:10:54,399 --> 00:10:56,399
uh you know in this notion of different

298
00:10:56,399 --> 00:10:57,680
different address spaces

299
00:10:57,680 --> 00:10:59,440
cat doesn't really have an ability to

300
00:10:59,440 --> 00:11:01,200
even refer to

301
00:11:01,200 --> 00:11:03,040
an address that actually belongs to the

302
00:11:03,040 --> 00:11:04,800
shell

303
00:11:04,800 --> 00:11:08,000
and so that's sort of the the game that

304
00:11:08,000 --> 00:11:09,680
we're the end goal that we'd like to

305
00:11:09,680 --> 00:11:10,240
achieve

306
00:11:10,240 --> 00:11:11,519
because this is going to provide us with

307
00:11:11,519 --> 00:11:13,360
strong isolation because you know

308
00:11:13,360 --> 00:11:15,279
it is just not possible for cat to refer

309
00:11:15,279 --> 00:11:16,959
to any other memory that is not

310
00:11:16,959 --> 00:11:20,079
you know its own and so our goal now is

311
00:11:20,079 --> 00:11:21,440
to basically sort of

312
00:11:21,440 --> 00:11:24,720
figure out how to multiplex if you will

313
00:11:24,720 --> 00:11:27,200
all these different address spaces on a

314
00:11:27,200 --> 00:11:28,399
single

315
00:11:28,399 --> 00:11:30,079
physical memory because in the end we

316
00:11:30,079 --> 00:11:32,240
only have a bunch of dram chips

317
00:11:32,240 --> 00:11:34,560
uh where you know or ram chips where the

318
00:11:34,560 --> 00:11:36,880
memory is located

319
00:11:36,880 --> 00:11:40,230
and so uh

320
00:11:40,240 --> 00:11:42,640
uh that's another plan okay yeah uh i'm

321
00:11:42,640 --> 00:11:46,150
here you have a question go ahead

322
00:11:46,160 --> 00:11:48,720
yeah so i'm wondering uh in the

323
00:11:48,720 --> 00:11:50,560
configuration of the

324
00:11:50,560 --> 00:11:52,959
physical hardware there's only so much

325
00:11:52,959 --> 00:11:54,160
space

326
00:11:54,160 --> 00:11:56,800
and in the virtual memory layout there's

327
00:11:56,800 --> 00:11:59,200
also a max virtual address

328
00:11:59,200 --> 00:12:02,240
uh by design is the virtual address

329
00:12:02,240 --> 00:12:05,600
made to be small enough i know that it

330
00:12:05,600 --> 00:12:07,839
no not necessarily you know the virtual

331
00:12:07,839 --> 00:12:09,200
dress space could be bigger than the

332
00:12:09,200 --> 00:12:10,639
physical memory the physical memory

333
00:12:10,639 --> 00:12:11,920
could be bigger than the virtual address

334
00:12:11,920 --> 00:12:12,720
phase

335
00:12:12,720 --> 00:12:14,240
uh and we'll see in a second how that

336
00:12:14,240 --> 00:12:15,760
all can happen and it's actually one of

337
00:12:15,760 --> 00:12:16,079
the

338
00:12:16,079 --> 00:12:18,320
you know cool parts about as we will see

339
00:12:18,320 --> 00:12:19,680
with page tables

340
00:12:19,680 --> 00:12:23,120
that's extremely flexible so is it

341
00:12:23,120 --> 00:12:25,680
is it possible that like the physical

342
00:12:25,680 --> 00:12:26,320
memory

343
00:12:26,320 --> 00:12:29,279
gets exhausted uh because so many

344
00:12:29,279 --> 00:12:30,560
processes use up

345
00:12:30,560 --> 00:12:32,399
all their virtual space yeah that's

346
00:12:32,399 --> 00:12:33,760
certainly possible

347
00:12:33,760 --> 00:12:35,760
uh and we'll see in a second how for

348
00:12:35,760 --> 00:12:37,360
example you know if you have a

349
00:12:37,360 --> 00:12:38,959
bunch of big applications that each have

350
00:12:38,959 --> 00:12:40,959
big page tables and they allocate a lot

351
00:12:40,959 --> 00:12:42,079
of memory you know at some point you're

352
00:12:42,079 --> 00:12:43,839
gonna run out of memory

353
00:12:43,839 --> 00:12:46,959
i see thanks and so where does it show

354
00:12:46,959 --> 00:12:50,829
up in xv6

355
00:12:50,839 --> 00:12:52,720
anybody

356
00:12:52,720 --> 00:12:55,440
you you sort of touched on it a little

357
00:12:55,440 --> 00:12:56,639
bit in the

358
00:12:56,639 --> 00:13:01,269
cisco lab that you're currently doing

359
00:13:01,279 --> 00:13:08,629
where are pages allocated

360
00:13:08,639 --> 00:13:10,800
or if you did the cisco lab and you

361
00:13:10,800 --> 00:13:12,320
finished it you know one part of the

362
00:13:12,320 --> 00:13:13,760
physical life correctly is printing how

363
00:13:13,760 --> 00:13:17,750
much free memory there is

364
00:13:17,760 --> 00:13:20,880
k alec yeah chaok right for chao it has

365
00:13:20,880 --> 00:13:22,320
some list of three pages

366
00:13:22,320 --> 00:13:24,639
if that list of three places is empty or

367
00:13:24,639 --> 00:13:26,240
runs out at some point

368
00:13:26,240 --> 00:13:28,000
then you know chaotic is going to return

369
00:13:28,000 --> 00:13:29,279
a null pointer

370
00:13:29,279 --> 00:13:30,880
and hopefully the operating system does

371
00:13:30,880 --> 00:13:32,320
something sensible and that basically

372
00:13:32,320 --> 00:13:34,240
propagates back to the user application

373
00:13:34,240 --> 00:13:35,360
saying like well you know

374
00:13:35,360 --> 00:13:37,200
no more memory for you or no more memory

375
00:13:37,200 --> 00:13:40,949
in total for nobody

376
00:13:40,959 --> 00:13:44,720
okay and just a job for the os to handle

377
00:13:44,720 --> 00:13:46,160
those cases gracefully

378
00:13:46,160 --> 00:13:47,680
where it basically generally means you

379
00:13:47,680 --> 00:13:49,199
know propagating an error message to the

380
00:13:49,199 --> 00:13:57,189
user application

381
00:13:57,199 --> 00:14:00,399
okay good um so how do we implement

382
00:14:00,399 --> 00:14:00,720
these

383
00:14:00,720 --> 00:14:02,959
address spaces you know how basically

384
00:14:02,959 --> 00:14:04,560
multiplex all these address spaces

385
00:14:04,560 --> 00:14:06,560
across a single physical memory

386
00:14:06,560 --> 00:14:09,920
and the most common approach and a very

387
00:14:09,920 --> 00:14:11,760
flexible approach is to use

388
00:14:11,760 --> 00:14:17,360
page tables

389
00:14:17,360 --> 00:14:19,920
um and the idea is uh and this is a

390
00:14:19,920 --> 00:14:21,040
hardware support

391
00:14:21,040 --> 00:14:23,760
so this is implemented in hardware by

392
00:14:23,760 --> 00:14:24,560
the processor

393
00:14:24,560 --> 00:14:26,720
or uh by a unit called the memory

394
00:14:26,720 --> 00:14:28,000
management unit

395
00:14:28,000 --> 00:14:29,199
and so the picture that you sort of

396
00:14:29,199 --> 00:14:31,120
should have in your head is you know you

397
00:14:31,120 --> 00:14:32,639
have the cpu

398
00:14:32,639 --> 00:14:34,320
that executes instructions you know

399
00:14:34,320 --> 00:14:35,920
whatever our

400
00:14:35,920 --> 00:14:40,000
you know uh uh our store instruction

401
00:14:40,000 --> 00:14:42,839
that was you know putting dollar seven

402
00:14:42,839 --> 00:14:44,480
into

403
00:14:44,480 --> 00:14:47,519
uh a zero indirect

404
00:14:47,519 --> 00:14:48,720
so it executes those kind of

405
00:14:48,720 --> 00:14:51,040
instructions and you know one that

406
00:14:51,040 --> 00:14:52,639
executes one is their story instruction

407
00:14:52,639 --> 00:14:53,760
load instruction or whatever

408
00:14:53,760 --> 00:14:55,680
anything that actually has an address

409
00:14:55,680 --> 00:14:56,800
you know that address

410
00:14:56,800 --> 00:14:58,320
uh we're going to think about as a

411
00:14:58,320 --> 00:15:00,000
virtual address so it's not a physical

412
00:15:00,000 --> 00:15:02,000
address it's a virtual address

413
00:15:02,000 --> 00:15:04,160
and so for example the value in a0 that

414
00:15:04,160 --> 00:15:05,279
we're using here

415
00:15:05,279 --> 00:15:08,720
uh yeah say that's 1000

416
00:15:08,720 --> 00:15:11,600
oh x you know 1000 data is a virtual

417
00:15:11,600 --> 00:15:12,000
address

418
00:15:12,000 --> 00:15:14,000
and that virtual address is basically

419
00:15:14,000 --> 00:15:16,000
routed through something what's called

420
00:15:16,000 --> 00:15:16,320
the

421
00:15:16,320 --> 00:15:21,750
memory management unit

422
00:15:21,760 --> 00:15:24,320
and the memory manager unit translates

423
00:15:24,320 --> 00:15:25,120
it into

424
00:15:25,120 --> 00:15:28,160
a physical address and

425
00:15:28,160 --> 00:15:29,920
that physical address then you know is

426
00:15:29,920 --> 00:15:32,000
actually used to you know index into

427
00:15:32,000 --> 00:15:33,120
memory

428
00:15:33,120 --> 00:15:36,000
and load whatever value or store

429
00:15:36,000 --> 00:15:39,199
whatever value needs to be written there

430
00:15:39,199 --> 00:15:41,199
and so the cpu from the cpu point of

431
00:15:41,199 --> 00:15:42,720
view it always issues

432
00:15:42,720 --> 00:15:45,440
every instruction that it issues uh once

433
00:15:45,440 --> 00:15:46,959
the mmu is enabled

434
00:15:46,959 --> 00:15:50,160
are virtual addresses and to translate

435
00:15:50,160 --> 00:15:51,440
these virtual addresses to physical

436
00:15:51,440 --> 00:15:52,160
addresses

437
00:15:52,160 --> 00:15:55,680
basically the mmu has a table and

438
00:15:55,680 --> 00:15:57,600
you know the virtual address on one side

439
00:15:57,600 --> 00:15:59,199
physical drafts on one side

440
00:15:59,199 --> 00:16:01,360
on the other side an example here is you

441
00:16:01,360 --> 00:16:02,720
know our entry for

442
00:16:02,720 --> 00:16:07,759
1000 and maybe that maps to whatever uh

443
00:16:07,759 --> 00:16:10,079
you know ox whatever i'm just making

444
00:16:10,079 --> 00:16:12,720
something up with like some big value

445
00:16:12,720 --> 00:16:14,240
you know somewhere in physical memory

446
00:16:14,240 --> 00:16:16,079
and so this mapping between virtual and

447
00:16:16,079 --> 00:16:17,360
physical ma

448
00:16:17,360 --> 00:16:20,800
uh it is quite flexible so on one side

449
00:16:20,800 --> 00:16:22,079
we have the virtual address of the other

450
00:16:22,079 --> 00:16:24,639
side of the physical addresses

451
00:16:24,639 --> 00:16:28,079
um typically you know this this mapping

452
00:16:28,079 --> 00:16:30,639
itself is also stored in memory and so

453
00:16:30,639 --> 00:16:32,800
the cpu has some register

454
00:16:32,800 --> 00:16:36,000
that basically points to uh

455
00:16:36,000 --> 00:16:38,560
that contains the physical address of

456
00:16:38,560 --> 00:16:40,560
where the page table is stored

457
00:16:40,560 --> 00:16:42,560
so somewhere in the basically the page

458
00:16:42,560 --> 00:16:44,480
table or this map is somewhere stored in

459
00:16:44,480 --> 00:16:45,759
physical memory

460
00:16:45,759 --> 00:16:48,399
uh let's say you know whatever you know

461
00:16:48,399 --> 00:16:49,839
address

462
00:16:49,839 --> 00:16:51,759
and basically this register which is

463
00:16:51,759 --> 00:16:53,040
called on the risk 5

464
00:16:53,040 --> 00:16:56,720
satp you know stores the

465
00:16:56,720 --> 00:16:59,839
address 10 and so uh that the

466
00:16:59,839 --> 00:17:02,240
cpu can tell the memory manage unit

467
00:17:02,240 --> 00:17:03,600
where to find

468
00:17:03,600 --> 00:17:05,600
you know basically the map to actually

469
00:17:05,600 --> 00:17:07,120
translate uh

470
00:17:07,120 --> 00:17:10,400
virtual to physical addresses and then

471
00:17:10,400 --> 00:17:12,240
the basic idea is to give every

472
00:17:12,240 --> 00:17:14,319
application its own map

473
00:17:14,319 --> 00:17:26,549
so you know cad is going to have its map

474
00:17:26,559 --> 00:17:30,400
go ahead um

475
00:17:30,400 --> 00:17:33,679
so the mmu you said it doesn't

476
00:17:33,679 --> 00:17:34,640
necessarily

477
00:17:34,640 --> 00:17:37,760
store the mapping so does it

478
00:17:37,760 --> 00:17:40,160
does it just just do the translation

479
00:17:40,160 --> 00:17:41,039
like it will

480
00:17:41,039 --> 00:17:43,360
read the memory and do the translation

481
00:17:43,360 --> 00:17:45,760
but not necessarily

482
00:17:45,760 --> 00:17:47,840
store the mappings that's that's exactly

483
00:17:47,840 --> 00:17:48,960
the right picture that you should have

484
00:17:48,960 --> 00:17:52,870
in your head

485
00:17:52,880 --> 00:17:55,760
but every map okay so the the the map

486
00:17:55,760 --> 00:17:57,840
itself is stored in memory the mmu just

487
00:17:57,840 --> 00:17:59,679
basically walks or looks ups into the

488
00:17:59,679 --> 00:18:01,120
map and we'll see in a second that you

489
00:18:01,120 --> 00:18:02,160
know this map is slightly more

490
00:18:02,160 --> 00:18:02,880
complicated than

491
00:18:02,880 --> 00:18:06,799
what you're drawing here so every app

492
00:18:06,799 --> 00:18:12,240
has its own its own map

493
00:18:12,240 --> 00:18:14,400
correct and that map basically defines

494
00:18:14,400 --> 00:18:16,240
its address space

495
00:18:16,240 --> 00:18:18,480
and so when with the cpu or when the

496
00:18:18,480 --> 00:18:20,400
operating system switches the cpu from

497
00:18:20,400 --> 00:18:21,280
one process

498
00:18:21,280 --> 00:18:22,720
or from one application to another

499
00:18:22,720 --> 00:18:24,880
application it also switches to you know

500
00:18:24,880 --> 00:18:26,080
the content of this

501
00:18:26,080 --> 00:18:29,200
satp register to store

502
00:18:29,200 --> 00:18:31,919
the root of the map of the appropriate

503
00:18:31,919 --> 00:18:33,360
process

504
00:18:33,360 --> 00:18:35,520
and so in that way basically you know

505
00:18:35,520 --> 00:18:36,960
multiple applications can run

506
00:18:36,960 --> 00:18:38,960
on the cpu every time we switch between

507
00:18:38,960 --> 00:18:40,240
from one application to the next

508
00:18:40,240 --> 00:18:41,039
application

509
00:18:41,039 --> 00:18:44,720
we also switch the satp register to

510
00:18:44,720 --> 00:18:46,320
point to the appropriate map for that

511
00:18:46,320 --> 00:18:47,360
application

512
00:18:47,360 --> 00:18:50,320
and in that way basically the virtual

513
00:18:50,320 --> 00:18:51,200
addresses

514
00:18:51,200 --> 00:18:54,880
for cad are translated differently than

515
00:18:54,880 --> 00:18:56,000
the virtual addresses

516
00:18:56,000 --> 00:18:58,240
for the shell because you know each one

517
00:18:58,240 --> 00:19:02,230
of them has their own map

518
00:19:02,240 --> 00:19:06,470
that makes sense

519
00:19:06,480 --> 00:19:09,520
okay so the way

520
00:19:09,520 --> 00:19:11,360
this is sort of the basic plan and the

521
00:19:11,360 --> 00:19:12,720
way i've drawn

522
00:19:12,720 --> 00:19:14,960
or you know explained it so far is

523
00:19:14,960 --> 00:19:16,559
pretty naive

524
00:19:16,559 --> 00:19:19,360
and unreasonable uh yeah did that go

525
00:19:19,360 --> 00:19:20,799
ahead

526
00:19:20,799 --> 00:19:24,400
i'm sorry um so um

527
00:19:24,400 --> 00:19:27,039
the you said the satp register gets

528
00:19:27,039 --> 00:19:28,000
modified uh

529
00:19:28,000 --> 00:19:30,880
for the process i am guessing the value

530
00:19:30,880 --> 00:19:31,440
of

531
00:19:31,440 --> 00:19:33,600
uh for the satp register for each

532
00:19:33,600 --> 00:19:34,720
process

533
00:19:34,720 --> 00:19:37,520
is stored by the kernel yes yes the

534
00:19:37,520 --> 00:19:39,200
kernel is writing the sntp your editor

535
00:19:39,200 --> 00:19:39,840
in fact

536
00:19:39,840 --> 00:19:42,000
writing or reading the or particularly

537
00:19:42,000 --> 00:19:42,960
writing the uh

538
00:19:42,960 --> 00:19:45,840
satp register is a privilege instruction

539
00:19:45,840 --> 00:19:46,240
so

540
00:19:46,240 --> 00:19:48,400
a user application cannot just you know

541
00:19:48,400 --> 00:19:50,160
update the page map register and say

542
00:19:50,160 --> 00:19:51,600
like i want to run with this page map

543
00:19:51,600 --> 00:19:52,559
now

544
00:19:52,559 --> 00:19:55,840
because that would violate isolation

545
00:19:55,840 --> 00:19:57,760
right so it's only the kernel only a

546
00:19:57,760 --> 00:19:59,280
code in kernel mode can actually update

547
00:19:59,280 --> 00:20:00,960
it

548
00:20:00,960 --> 00:20:04,559
i see okay so

549
00:20:04,559 --> 00:20:06,159
as i said this picture is pretty naive

550
00:20:06,159 --> 00:20:07,760
uh you know one thing i haven't really

551
00:20:07,760 --> 00:20:09,360
said anything about how this actually

552
00:20:09,360 --> 00:20:10,720
map works

553
00:20:10,720 --> 00:20:13,760
uh and you know the way actually drawn

554
00:20:13,760 --> 00:20:15,440
out seems to indicate that you know

555
00:20:15,440 --> 00:20:16,480
basically for every

556
00:20:16,480 --> 00:20:18,159
virtual address you have an entry in the

557
00:20:18,159 --> 00:20:19,840
map

558
00:20:19,840 --> 00:20:22,240
and if you do that how big would the map

559
00:20:22,240 --> 00:20:25,270
be

560
00:20:25,280 --> 00:20:32,830
on risk five

561
00:20:32,840 --> 00:20:35,990
anybody

562
00:20:36,000 --> 00:20:37,760
how many addresses are there on the risk

563
00:20:37,760 --> 00:20:39,440
five in principle or how big

564
00:20:39,440 --> 00:20:41,120
how many addresses could a register

565
00:20:41,120 --> 00:20:46,230
store

566
00:20:46,240 --> 00:20:48,960
registers are 64 bit wide so how many

567
00:20:48,960 --> 00:20:52,470
addresses

568
00:20:52,480 --> 00:20:55,200
anybody i know i'm so insulting your

569
00:20:55,200 --> 00:20:56,720
intelligence by asking these questions

570
00:20:56,720 --> 00:20:59,990
but

571
00:21:00,000 --> 00:21:01,440
we have some answers in the chat like

572
00:21:01,440 --> 00:21:03,440
two to the 64. uh so yeah i didn't see

573
00:21:03,440 --> 00:21:04,240
the chat sorry

574
00:21:04,240 --> 00:21:06,159
uh yeah two to the 64. let's see if i

575
00:21:06,159 --> 00:21:07,919
can actually pop up the chip

576
00:21:07,919 --> 00:21:13,350
so i can see it

577
00:21:13,360 --> 00:21:16,880
yeah 2264. thank you

578
00:21:16,880 --> 00:21:19,120
all right so this table would be

579
00:21:19,120 --> 00:21:20,400
gigantic

580
00:21:20,400 --> 00:21:22,880
uh in fact you know all memory would be

581
00:21:22,880 --> 00:21:24,640
consumed by just having that table so

582
00:21:24,640 --> 00:21:24,960
that's

583
00:21:24,960 --> 00:21:27,600
unreasonable and so in fact you know

584
00:21:27,600 --> 00:21:29,840
that's not how things work

585
00:21:29,840 --> 00:21:31,760
in fact i'm going to go in two steps to

586
00:21:31,760 --> 00:21:32,960
actually how it actually works in the

587
00:21:32,960 --> 00:21:33,840
race five

588
00:21:33,840 --> 00:21:36,880
so step one is you know don't play the

589
00:21:36,880 --> 00:21:38,240
game

590
00:21:38,240 --> 00:21:44,480
per address but do it per page

591
00:21:44,480 --> 00:21:46,640
so you translate the page at a time and

592
00:21:46,640 --> 00:21:47,840
the page uh

593
00:21:47,840 --> 00:21:51,679
on the risk five is four kilobyte

594
00:21:51,679 --> 00:21:53,520
and which is four and four thousand

595
00:21:53,520 --> 00:21:54,960
ninety six bytes

596
00:21:54,960 --> 00:21:57,440
and this is pretty common uh almost all

597
00:21:57,440 --> 00:21:59,440
processors you know use roughly a page

598
00:21:59,440 --> 00:22:01,200
size or four kilobytes or support

599
00:22:01,200 --> 00:22:03,840
a page size or four kilobytes and so now

600
00:22:03,840 --> 00:22:05,360
again translation works slightly

601
00:22:05,360 --> 00:22:06,720
differently so if here

602
00:22:06,720 --> 00:22:09,360
we have our virtual address and

603
00:22:09,360 --> 00:22:11,280
basically we split it in two pieces

604
00:22:11,280 --> 00:22:15,200
an index and an offset

605
00:22:15,200 --> 00:22:17,039
and so the offset is basically the byte

606
00:22:17,039 --> 00:22:18,799
within the page

607
00:22:18,799 --> 00:22:21,679
and so when we do when the mmu does the

608
00:22:21,679 --> 00:22:22,480
translation

609
00:22:22,480 --> 00:22:25,679
it takes the index uh indexes into

610
00:22:25,679 --> 00:22:28,240
the map that gives you you know some

611
00:22:28,240 --> 00:22:29,360
physical page number

612
00:22:29,360 --> 00:22:32,400
you know the in memory and that physical

613
00:22:32,400 --> 00:22:34,960
page number that points to some you know

614
00:22:34,960 --> 00:22:38,000
physical page of 4096 bytes

615
00:22:38,000 --> 00:22:40,240
and then the offset part basically

616
00:22:40,240 --> 00:22:41,840
indexes into that

617
00:22:41,840 --> 00:22:44,000
physical page so for example the offset

618
00:22:44,000 --> 00:22:45,760
is you know 12

619
00:22:45,760 --> 00:22:48,880
then you know the

620
00:22:48,880 --> 00:22:52,960
the 12th entry of that page is actually

621
00:22:52,960 --> 00:22:55,840
used a lot of you people a lot of you

622
00:22:55,840 --> 00:22:57,039
answered this and

623
00:22:57,039 --> 00:22:59,760
mentioned this in the uh in response to

624
00:22:59,760 --> 00:23:00,640
the question that

625
00:23:00,640 --> 00:23:02,000
there's always some scheme of like

626
00:23:02,000 --> 00:23:04,080
taking an offset and uh

627
00:23:04,080 --> 00:23:06,559
adding that to the base of the page uh

628
00:23:06,559 --> 00:23:07,360
to uh

629
00:23:07,360 --> 00:23:10,400
obtain the actual uh memory fiscal

630
00:23:10,400 --> 00:23:11,600
memory location where

631
00:23:11,600 --> 00:23:14,000
a value is stored or where value will be

632
00:23:14,000 --> 00:23:16,320
uh loaded to

633
00:23:16,320 --> 00:23:17,679
and one of the interesting things about

634
00:23:17,679 --> 00:23:19,840
the risk five is and there's a

635
00:23:19,840 --> 00:23:21,039
in response to some other question to

636
00:23:21,039 --> 00:23:22,880
them or somebody asked earlier the

637
00:23:22,880 --> 00:23:25,520
physical uh or the virtual dresses are

638
00:23:25,520 --> 00:23:28,159
64 bits

639
00:23:28,159 --> 00:23:29,600
which makes totally sense correct

640
00:23:29,600 --> 00:23:33,679
because the risk 5 is 64-bit register

641
00:23:33,679 --> 00:23:36,320
but in fact on the risc-v processor that

642
00:23:36,320 --> 00:23:37,679
we're using

643
00:23:37,679 --> 00:23:41,760
uh not all of the 64 bits actually used

644
00:23:41,760 --> 00:23:44,480
namely the top 25 are actually not used

645
00:23:44,480 --> 00:23:46,400
at all

646
00:23:46,400 --> 00:23:48,559
and so that limits the size of a virtual

647
00:23:48,559 --> 00:23:50,480
address right that limits the size of a

648
00:23:50,480 --> 00:23:51,760
virtual address space to

649
00:23:51,760 --> 00:23:55,029
2 to the power 39

650
00:23:55,039 --> 00:24:02,830
which is roughly 512

651
00:24:02,840 --> 00:24:04,240
gigabytes

652
00:24:04,240 --> 00:24:08,000
um and so of course you know later uh

653
00:24:08,000 --> 00:24:09,760
versions of the processor might support

654
00:24:09,760 --> 00:24:11,360
bigger address spaces if that isn't

655
00:24:11,360 --> 00:24:12,159
necessary

656
00:24:12,159 --> 00:24:13,600
and that could then be done and so that

657
00:24:13,600 --> 00:24:15,760
for example some of those 25 bits that

658
00:24:15,760 --> 00:24:17,840
are basically unused you know could be

659
00:24:17,840 --> 00:24:18,880
used to

660
00:24:18,880 --> 00:24:22,240
uh build bigger virtual address spaces

661
00:24:22,240 --> 00:24:24,720
and so uh and so in the index in that

662
00:24:24,720 --> 00:24:26,320
you know we're 39 bits left

663
00:24:26,320 --> 00:24:29,200
you know as the virtual address 20 27

664
00:24:29,200 --> 00:24:29,600
bits

665
00:24:29,600 --> 00:24:31,520
are indexed and we'll see in a second

666
00:24:31,520 --> 00:24:33,520
why they're 27

667
00:24:33,520 --> 00:24:36,720
uh our index and then the 12 are

668
00:24:36,720 --> 00:24:39,919
offset and you know they have to be 12

669
00:24:39,919 --> 00:24:41,760
correct because 2 to the power 12

670
00:24:41,760 --> 00:24:45,360
is you know 4 5 and 96

671
00:24:45,360 --> 00:24:48,159
all right so that's virtual addresses on

672
00:24:48,159 --> 00:24:49,279
the risk 5

673
00:24:49,279 --> 00:24:51,200
physical addresses as you can see here

674
00:24:51,200 --> 00:24:57,830
are actually 56 bits wide

675
00:24:57,840 --> 00:24:59,600
so the physical memory you know can be

676
00:24:59,600 --> 00:25:01,520
bigger than the

677
00:25:01,520 --> 00:25:04,159
single virtual address space but it's

678
00:25:04,159 --> 00:25:05,840
limited to two power up to 56

679
00:25:05,840 --> 00:25:07,840
you know most boards probably you know

680
00:25:07,840 --> 00:25:10,320
that don't support two to the power 56

681
00:25:10,320 --> 00:25:12,559
uh physical memory because of gigantic

682
00:25:12,559 --> 00:25:14,240
amount of physical memory

683
00:25:14,240 --> 00:25:16,159
but in principle the board could you

684
00:25:16,159 --> 00:25:18,640
know if you could manufacture it

685
00:25:18,640 --> 00:25:20,640
support 2 to the power 56 of physical

686
00:25:20,640 --> 00:25:21,919
memory

687
00:25:21,919 --> 00:25:23,760
and so in this scheme then if you have

688
00:25:23,760 --> 00:25:25,120
56

689
00:25:25,120 --> 00:25:27,200
bits for the physical address 44 are

690
00:25:27,200 --> 00:25:28,799
basically the physical page number

691
00:25:28,799 --> 00:25:31,360
the ppn and 12 again are the offset that

692
00:25:31,360 --> 00:25:33,600
are inherited directly from the

693
00:25:33,600 --> 00:25:36,630
virtual address

694
00:25:36,640 --> 00:25:40,470
does that all make sense

695
00:25:40,480 --> 00:25:42,799
so i'm going to stop for a second here

696
00:25:42,799 --> 00:25:44,240
usually you're collecting foss

697
00:25:44,240 --> 00:25:45,600
the other thing point i wanted to make

698
00:25:45,600 --> 00:25:47,520
here is that uh

699
00:25:47,520 --> 00:25:49,760
this material uh is important so just

700
00:25:49,760 --> 00:25:50,880
ask questions

701
00:25:50,880 --> 00:25:53,840
uh the details matter uh and it will be

702
00:25:53,840 --> 00:25:54,960
a large part

703
00:25:54,960 --> 00:25:56,159
of you know you really need to

704
00:25:56,159 --> 00:25:58,240
understand all this stuff uh to be able

705
00:25:58,240 --> 00:25:59,679
to basically do lab

706
00:25:59,679 --> 00:26:02,799
the next lap the page table lab yeah i'm

707
00:26:02,799 --> 00:26:03,679
here go ahead

708
00:26:03,679 --> 00:26:07,039
please if you can go back one slide

709
00:26:07,039 --> 00:26:10,720
uh the screen is unclear

710
00:26:10,720 --> 00:26:20,149
which one the page table slide

711
00:26:20,159 --> 00:26:23,919
this one uh no the most recent one all

712
00:26:23,919 --> 00:26:25,279
right it also doesn't really matter

713
00:26:25,279 --> 00:26:27,600
uh yeah that this is perfect thank you

714
00:26:27,600 --> 00:26:28,720
so i'm wondering

715
00:26:28,720 --> 00:26:32,240
this 4096 byte range

716
00:26:32,240 --> 00:26:34,720
which we've called a page is that

717
00:26:34,720 --> 00:26:36,159
assigned as a

718
00:26:36,159 --> 00:26:38,400
continuous chunk in memory yes there's a

719
00:26:38,400 --> 00:26:39,840
continuous physical

720
00:26:39,840 --> 00:26:43,760
you know continuous range of 4096

721
00:26:43,760 --> 00:26:47,440
bytes in memory i see

722
00:26:47,440 --> 00:26:50,640
and then the snap at a granularity

723
00:26:50,640 --> 00:26:53,919
of 496 bytes okay

724
00:26:53,919 --> 00:26:57,520
and then 12 the offset like 2 to the 12

725
00:26:57,520 --> 00:26:59,760
is 4096 so that's sufficient to

726
00:26:59,760 --> 00:27:02,559
uh to cover each of the chunks yeah each

727
00:27:02,559 --> 00:27:04,720
byte and webpage

728
00:27:04,720 --> 00:27:07,679
and where does the 56 come from in the

729
00:27:07,679 --> 00:27:08,799
diagram

730
00:27:08,799 --> 00:27:10,799
i could follow up until then but i

731
00:27:10,799 --> 00:27:12,559
didn't get where that came from

732
00:27:12,559 --> 00:27:15,520
uh the designers cook it up so the

733
00:27:15,520 --> 00:27:17,279
hardware designers decide how big you

734
00:27:17,279 --> 00:27:18,559
know a physical dress is

735
00:27:18,559 --> 00:27:20,880
uh basically for the whatever board they

736
00:27:20,880 --> 00:27:22,640
want to design

737
00:27:22,640 --> 00:27:26,080
and so the risk 5 designers decided that

738
00:27:26,080 --> 00:27:26,799
56

739
00:27:26,799 --> 00:27:30,870
bit physical addresses were a good idea

740
00:27:30,880 --> 00:27:32,640
and presumably the way they come up with

741
00:27:32,640 --> 00:27:34,399
these numbers is they look at technology

742
00:27:34,399 --> 00:27:35,520
trends

743
00:27:35,520 --> 00:27:37,520
and say like well we want to be able for

744
00:27:37,520 --> 00:27:39,200
the next sort of five years you know we

745
00:27:39,200 --> 00:27:40,080
don't want to predict

746
00:27:40,080 --> 00:27:42,080
that physical memory will be ever bigger

747
00:27:42,080 --> 00:27:44,640
than 2 to the power 56

748
00:27:44,640 --> 00:27:45,760
and probably they're thinking it won't

749
00:27:45,760 --> 00:27:47,039
be bigger than you know something much

750
00:27:47,039 --> 00:27:49,600
smaller but then you know give them some

751
00:27:49,600 --> 00:27:51,440
v-way you know in case you know their

752
00:27:51,440 --> 00:27:52,799
prediction is wrong

753
00:27:52,799 --> 00:27:56,559
uh they pick a slightly bigger number

754
00:27:56,559 --> 00:27:59,679
does that make sense see yeah thanks

755
00:27:59,679 --> 00:28:03,840
yeah a lot of people ask about this

756
00:28:03,840 --> 00:28:05,600
anybody else who raised a hand i think

757
00:28:05,600 --> 00:28:06,799
there's a bunch of people asking

758
00:28:06,799 --> 00:28:07,520
questions and

759
00:28:07,520 --> 00:28:09,760
unfortunately my zoom doesn't show it's

760
00:28:09,760 --> 00:28:11,120
more than two people ranked hands it's

761
00:28:11,120 --> 00:28:11,600
just

762
00:28:11,600 --> 00:28:13,679
multiple people are raising their hands

763
00:28:13,679 --> 00:28:20,230
so please jump in if you have a question

764
00:28:20,240 --> 00:28:23,679
okay if not i have a question

765
00:28:23,679 --> 00:28:27,120
yeah go ahead um so if the virtual

766
00:28:27,120 --> 00:28:27,840
memory is

767
00:28:27,840 --> 00:28:30,320
up to 2 to the power of 27 and the

768
00:28:30,320 --> 00:28:32,559
physical memory is up 2 to the power

769
00:28:32,559 --> 00:28:35,679
2 to the 56 right so

770
00:28:35,679 --> 00:28:39,279
we could have like we could

771
00:28:39,279 --> 00:28:41,120
we could have multiple processes that

772
00:28:41,120 --> 00:28:42,960
could exhaust all their virtual memories

773
00:28:42,960 --> 00:28:44,080
without

774
00:28:44,080 --> 00:28:46,559
using up all the physical memory right

775
00:28:46,559 --> 00:28:52,070
that's correct

776
00:28:52,080 --> 00:28:55,279
that's absolutely correct okay i have a

777
00:28:55,279 --> 00:28:56,159
question too

778
00:28:56,159 --> 00:28:59,679
yeah go ahead um so this 56

779
00:28:59,679 --> 00:29:03,200
for the physical address is that the

780
00:29:03,200 --> 00:29:06,399
the number of possible memory locations

781
00:29:06,399 --> 00:29:08,480
i i don't think it's the number of bits

782
00:29:08,480 --> 00:29:10,240
right because this is a 64-bit

783
00:29:10,240 --> 00:29:13,679
machine that 56 could go up to

784
00:29:13,679 --> 00:29:16,960
64 but they just chose it to have just

785
00:29:16,960 --> 00:29:17,840
56.

786
00:29:17,840 --> 00:29:19,679
that's right that's correct and one way

787
00:29:19,679 --> 00:29:20,880
to think about it then they only have to

788
00:29:20,880 --> 00:29:22,080
run 56 wire

789
00:29:22,080 --> 00:29:25,520
wires on the board as opposed to 64.

790
00:29:25,520 --> 00:29:30,310
i see i see

791
00:29:30,320 --> 00:29:33,679
okay i also have a question um

792
00:29:33,679 --> 00:29:36,240
so kind of um could you go back one

793
00:29:36,240 --> 00:29:37,279
slide maybe

794
00:29:37,279 --> 00:29:40,640
yep um so

795
00:29:40,640 --> 00:29:44,399
from the cpu um we go through the mmu

796
00:29:44,399 --> 00:29:46,159
and then to the memory

797
00:29:46,159 --> 00:29:48,880
uh but where where here is the

798
00:29:48,880 --> 00:29:50,240
distinction

799
00:29:50,240 --> 00:29:53,120
for different processes because like

800
00:29:53,120 --> 00:29:54,240
each process

801
00:29:54,240 --> 00:29:56,720
like process like the shell process has

802
00:29:56,720 --> 00:29:57,360
something at

803
00:29:57,360 --> 00:30:01,200
address like 0x uh one zero zero zero

804
00:30:01,200 --> 00:30:02,960
and then the ls process also has

805
00:30:02,960 --> 00:30:04,960
something at address zero x one zero

806
00:30:04,960 --> 00:30:05,840
zero zero

807
00:30:05,840 --> 00:30:07,360
so we need to translate those to

808
00:30:07,360 --> 00:30:09,120
different physical

809
00:30:09,120 --> 00:30:13,279
so the satp register

810
00:30:13,279 --> 00:30:15,520
contains the register it contains the

811
00:30:15,520 --> 00:30:18,399
address of which map to use

812
00:30:18,399 --> 00:30:21,360
so ls runs with its own map you know cat

813
00:30:21,360 --> 00:30:22,720
runs with zone map

814
00:30:22,720 --> 00:30:25,039
okay so so each process will have com

815
00:30:25,039 --> 00:30:26,000
it's completely

816
00:30:26,000 --> 00:30:29,600
own map yep makes sense thank you

817
00:30:29,600 --> 00:30:31,600
and in fact there's a great uh leeway to

818
00:30:31,600 --> 00:30:33,279
the next

819
00:30:33,279 --> 00:30:35,600
point so if every process has its own

820
00:30:35,600 --> 00:30:36,799
map

821
00:30:36,799 --> 00:30:39,120
you know how big is this map like that

822
00:30:39,120 --> 00:30:40,799
i've drawn here

823
00:30:40,799 --> 00:30:43,440
well that map is 2 to the power of 47

824
00:30:43,440 --> 00:30:46,549
entries correct

825
00:30:46,559 --> 00:30:49,679
uh and that's pretty big uh and i would

826
00:30:49,679 --> 00:30:50,080
feel

827
00:30:50,080 --> 00:30:52,240
physical memory reasonable quickly uh if

828
00:30:52,240 --> 00:30:54,559
every process exactly had a complete you

829
00:30:54,559 --> 00:30:55,039
know

830
00:30:55,039 --> 00:30:57,760
populated map right then it was gigantic

831
00:30:57,760 --> 00:30:59,120
you know means that every process is

832
00:30:59,120 --> 00:31:00,080
very big

833
00:31:00,080 --> 00:31:02,880
and so in fact this is not the way uh

834
00:31:02,880 --> 00:31:04,799
the hardware actually stores page tables

835
00:31:04,799 --> 00:31:05,919
uh you know you can think about it

836
00:31:05,919 --> 00:31:07,600
conceptually as an array

837
00:31:07,600 --> 00:31:09,360
you know going from zero to two to power

838
00:31:09,360 --> 00:31:11,120
27 but actually is not what happens in

839
00:31:11,120 --> 00:31:12,080
practice

840
00:31:12,080 --> 00:31:14,960
in practice it's a multi-level uh

841
00:31:14,960 --> 00:31:15,519
structure

842
00:31:15,519 --> 00:31:20,789
and here's actually the real risk five

843
00:31:20,799 --> 00:31:24,080
page table structure

844
00:31:24,080 --> 00:31:27,519
and what the hardware implements and so

845
00:31:27,519 --> 00:31:29,519
what happens with the 27 bits that we

846
00:31:29,519 --> 00:31:30,799
saw earlier

847
00:31:30,799 --> 00:31:34,240
the index it's actually split in

848
00:31:34,240 --> 00:31:38,240
three nine bit numbers

849
00:31:38,240 --> 00:31:41,519
and the first the top nine bits are used

850
00:31:41,519 --> 00:31:42,240
to index

851
00:31:42,240 --> 00:31:45,600
into the top level page table directory

852
00:31:45,600 --> 00:31:47,039
as they're called

853
00:31:47,039 --> 00:31:48,799
and so in one directory you know one of

854
00:31:48,799 --> 00:31:51,840
these guys you know is 496 bytes

855
00:31:51,840 --> 00:31:56,159
496 bytes just like a page size

856
00:31:56,159 --> 00:31:59,600
uh a pte entry one of these entries in

857
00:31:59,600 --> 00:32:00,640
that thing is

858
00:32:00,640 --> 00:32:03,669
64 bytes

859
00:32:07,190 --> 00:32:07,200
64 bits i mean sorry like the register

860
00:32:07,200 --> 00:32:09,679
with so eight bytes and so this is going

861
00:32:09,679 --> 00:32:12,640
to mean that if you do 496

862
00:32:12,640 --> 00:32:16,159
divided by 8 means there are 512 entries

863
00:32:16,159 --> 00:32:19,279
in one of those directory pages

864
00:32:19,279 --> 00:32:21,919
so basically what happens is the satp

865
00:32:21,919 --> 00:32:23,440
points to the top

866
00:32:23,440 --> 00:32:25,600
uh root directory we take the top level

867
00:32:25,600 --> 00:32:26,799
nine bits index

868
00:32:26,799 --> 00:32:29,679
into the page directory and that gives

869
00:32:29,679 --> 00:32:31,919
us a new physical page number

870
00:32:31,919 --> 00:32:34,000
and that physical page number is the

871
00:32:34,000 --> 00:32:35,919
page directory for the next level

872
00:32:35,919 --> 00:32:39,279
so whenever we use the next level index

873
00:32:39,279 --> 00:32:42,080
to index into that page directory and

874
00:32:42,080 --> 00:32:44,000
then you know and so forth you know we

875
00:32:44,000 --> 00:32:45,760
like the final one you know we get the

876
00:32:45,760 --> 00:32:48,159
bottom level page directory and that

877
00:32:48,159 --> 00:32:49,679
basically gives us the entry

878
00:32:49,679 --> 00:32:51,679
uh that maps the virtual address to a

879
00:32:51,679 --> 00:32:55,509
fiscal address

880
00:32:55,519 --> 00:32:57,120
so in some sense again it's very similar

881
00:32:57,120 --> 00:32:58,880
to uh what i showed you in the previous

882
00:32:58,880 --> 00:33:00,080
slide except you know basically the

883
00:33:00,080 --> 00:33:01,840
index happens in three steps instead of

884
00:33:01,840 --> 00:33:02,799
one step

885
00:33:02,799 --> 00:33:04,799
and this is advantage the main advantage

886
00:33:04,799 --> 00:33:06,320
of this scheme is that then

887
00:33:06,320 --> 00:33:08,159
if large paid parts of the address phase

888
00:33:08,159 --> 00:33:09,360
are not being used

889
00:33:09,360 --> 00:33:10,799
you don't have to have any page table

890
00:33:10,799 --> 00:33:12,720
entries for them

891
00:33:12,720 --> 00:33:14,480
as for example let's say you have an

892
00:33:14,480 --> 00:33:16,159
address space

893
00:33:16,159 --> 00:33:18,799
that has only one page like the bottom

894
00:33:18,799 --> 00:33:19,519
page

895
00:33:19,519 --> 00:33:22,799
you know it's a 4096

896
00:33:22,799 --> 00:33:24,720
and no other pages are in the address

897
00:33:24,720 --> 00:33:26,960
page so only the addresses zero to four

898
00:33:26,960 --> 00:33:27,919
thousand ninety five

899
00:33:27,919 --> 00:33:30,000
six are actually mapped how many page

900
00:33:30,000 --> 00:33:31,840
table entry or page table directors do

901
00:33:31,840 --> 00:33:32,240
you need

902
00:33:32,240 --> 00:33:39,200
to map that particular page

903
00:33:39,200 --> 00:33:41,840
well you need one at the top correct and

904
00:33:41,840 --> 00:33:42,320
you need

905
00:33:42,320 --> 00:33:46,399
basically value in that entry for zero

906
00:33:46,399 --> 00:33:48,240
the top level nine bits you know of the

907
00:33:48,240 --> 00:33:50,559
zero earned zero so you need an entry

908
00:33:50,559 --> 00:33:51,760
for zero

909
00:33:51,760 --> 00:33:53,919
so that means you need one middle level

910
00:33:53,919 --> 00:33:55,840
entry you know that basically uh

911
00:33:55,840 --> 00:33:57,120
corresponds to the next

912
00:33:57,120 --> 00:33:59,360
you know nine zero bits and then one

913
00:33:59,360 --> 00:34:00,159
entry for the

914
00:34:00,159 --> 00:34:02,880
next nine zero bits so basically we get

915
00:34:02,880 --> 00:34:03,600
away

916
00:34:03,600 --> 00:34:11,270
with three uh page directories

917
00:34:11,280 --> 00:34:12,720
and in our previous scheme on the

918
00:34:12,720 --> 00:34:14,720
previous slide correct we had 2 to the

919
00:34:14,720 --> 00:34:15,760
power of 27

920
00:34:15,760 --> 00:34:17,599
entries and now we basically have to

921
00:34:17,599 --> 00:34:19,839
have 3 times whatever 512 entries and

922
00:34:19,839 --> 00:34:21,839
we're done

923
00:34:21,839 --> 00:34:25,119
and that's the main reason why

924
00:34:25,119 --> 00:34:27,280
the actual hardware has this

925
00:34:27,280 --> 00:34:28,879
hierarchical

926
00:34:28,879 --> 00:34:32,480
or multi-level 3 scheme

927
00:34:32,480 --> 00:34:34,000
any questions about this because it's

928
00:34:34,000 --> 00:34:36,159
pretty important

929
00:34:36,159 --> 00:34:39,760
samir go ahead um

930
00:34:39,760 --> 00:34:42,960
so my question is

931
00:34:42,960 --> 00:34:46,079
since the ppn number from each page

932
00:34:46,079 --> 00:34:48,399
table is 44 bits

933
00:34:48,399 --> 00:34:51,599
and the second say the middle table

934
00:34:51,599 --> 00:34:54,159
resides on the virtual memory where do

935
00:34:54,159 --> 00:34:54,960
we get the

936
00:34:54,960 --> 00:34:58,160
missing 12 bits from well the final 12

937
00:34:58,160 --> 00:34:58,560
bits

938
00:34:58,560 --> 00:35:01,280
okay so good good so you're saying these

939
00:35:01,280 --> 00:35:02,880
44 correct

940
00:35:02,880 --> 00:35:04,880
yes what is going on with that well all

941
00:35:04,880 --> 00:35:06,400
pages all page directories are

942
00:35:06,400 --> 00:35:10,240
page lines and so basically their uh

943
00:35:10,240 --> 00:35:13,040
physical page number is 44 plus the 12

944
00:35:13,040 --> 00:35:13,480
uh

945
00:35:13,480 --> 00:35:14,640
[Music]

946
00:35:14,640 --> 00:35:18,870
12 zero bits

947
00:35:18,880 --> 00:35:20,320
and so what actually happens if we look

948
00:35:20,320 --> 00:35:22,320
at these pte entries you know they all

949
00:35:22,320 --> 00:35:23,599
have the same sort of form

950
00:35:23,599 --> 00:35:25,760
right if you look at one of these guys

951
00:35:25,760 --> 00:35:26,960
they're 44

952
00:35:26,960 --> 00:35:29,839
bits they're 12 bits zeros so that gives

953
00:35:29,839 --> 00:35:30,400
us a

954
00:35:30,400 --> 00:35:33,599
44 plus 12 is 56 so that gives us a

955
00:35:33,599 --> 00:35:34,800
physical address

956
00:35:34,800 --> 00:35:38,320
correct um and so that means

957
00:35:38,320 --> 00:35:40,400
in this 64 bits there's actually some

958
00:35:40,400 --> 00:35:43,040
bits left they're not being used in fact

959
00:35:43,040 --> 00:35:44,960
the bottom 12 bits will basically or the

960
00:35:44,960 --> 00:35:46,160
bottom 10 would definitely

961
00:35:46,160 --> 00:35:47,599
you know the bottom bits are not not

962
00:35:47,599 --> 00:35:49,359
used at all and in fact the paging

963
00:35:49,359 --> 00:35:50,240
hardware

964
00:35:50,240 --> 00:35:52,560
stores or stores that are a bunch of

965
00:35:52,560 --> 00:35:53,359
flags

966
00:35:53,359 --> 00:35:55,599
that control the translation and we'll

967
00:35:55,599 --> 00:35:58,640
talk about those flags in a second

968
00:35:58,640 --> 00:36:01,359
and but they're there to control the

969
00:36:01,359 --> 00:36:02,960
translation and they're stored basically

970
00:36:02,960 --> 00:36:05,280
in the bottom 10 bits

971
00:36:05,280 --> 00:36:06,960
and it also means correct that you know

972
00:36:06,960 --> 00:36:09,680
if you add these two up that's 54 bits

973
00:36:09,680 --> 00:36:12,240
basically there's 10 bits left that are

974
00:36:12,240 --> 00:36:14,000
unused and those 10 bits are

975
00:36:14,000 --> 00:36:17,040
again you know for future growth so

976
00:36:17,040 --> 00:36:18,480
at some point we might have a new type

977
00:36:18,480 --> 00:36:20,720
of risk five processor that will have

978
00:36:20,720 --> 00:36:22,720
slightly different structure page tables

979
00:36:22,720 --> 00:36:24,400
and it might actually have bigger

980
00:36:24,400 --> 00:36:26,400
than 44 bits for the physical page

981
00:36:26,400 --> 00:36:29,349
number

982
00:36:29,359 --> 00:36:32,400
okay and in fact you know you can see it

983
00:36:32,400 --> 00:36:33,599
here like if you look at the single

984
00:36:33,599 --> 00:36:34,400
entry correct

985
00:36:34,400 --> 00:36:36,880
that's drawn here uh you know they're

986
00:36:36,880 --> 00:36:38,400
basically

987
00:36:38,400 --> 00:36:42,000
10 10 bits left that are not being used

988
00:36:42,000 --> 00:36:44,320
um okay so let's look at the flags for a

989
00:36:44,320 --> 00:36:45,040
second

990
00:36:45,040 --> 00:36:47,920
because that's sort of important uh so

991
00:36:47,920 --> 00:36:49,200
every translation

992
00:36:49,200 --> 00:36:50,720
in the bottom 10 bits there are a bunch

993
00:36:50,720 --> 00:36:52,720
of flags stored and the first

994
00:36:52,720 --> 00:36:56,640
flag uh is valid and if

995
00:36:56,640 --> 00:36:58,640
the valid bit is set that means this is

996
00:36:58,640 --> 00:37:00,079
a valid pte

997
00:37:00,079 --> 00:37:03,119
and you can use it for translation

998
00:37:03,119 --> 00:37:06,240
and so for uh so for my little example

999
00:37:06,240 --> 00:37:07,520
that i used here with

1000
00:37:07,520 --> 00:37:09,680
three page directories where only entry

1001
00:37:09,680 --> 00:37:10,560
zero is used

1002
00:37:10,560 --> 00:37:12,640
then only enter zero will have the valve

1003
00:37:12,640 --> 00:37:14,560
bit set and none the other five and

1004
00:37:14,560 --> 00:37:16,480
eleven entries will not have the valve

1005
00:37:16,480 --> 00:37:18,480
bit set

1006
00:37:18,480 --> 00:37:21,520
and that basically tells the uh mmu well

1007
00:37:21,520 --> 00:37:22,880
you know you don't have to change down

1008
00:37:22,880 --> 00:37:23,359
this

1009
00:37:23,359 --> 00:37:25,920
uh pt this pte just contains no valid

1010
00:37:25,920 --> 00:37:27,920
information

1011
00:37:27,920 --> 00:37:30,800
then r means you know you're allowed to

1012
00:37:30,800 --> 00:37:32,240
read from the page

1013
00:37:32,240 --> 00:37:34,240
right means you're allowed to write to

1014
00:37:34,240 --> 00:37:36,640
the page execute means

1015
00:37:36,640 --> 00:37:38,240
you're allowed to execute instructions

1016
00:37:38,240 --> 00:37:39,760
from it uh

1017
00:37:39,760 --> 00:37:42,800
and user means you know uh this page is

1018
00:37:42,800 --> 00:37:44,720
also accessible by a process user

1019
00:37:44,720 --> 00:37:45,200
running

1020
00:37:45,200 --> 00:37:48,000
in user space and then the other bits

1021
00:37:48,000 --> 00:37:49,280
you know not that important they'll all

1022
00:37:49,280 --> 00:37:50,800
show up at some point

1023
00:37:50,800 --> 00:37:52,240
but those are sort of the five important

1024
00:37:52,240 --> 00:37:55,829
bits

1025
00:37:55,839 --> 00:37:59,270
does it all make sense

1026
00:37:59,280 --> 00:38:02,720
yeah nithya

1027
00:38:02,720 --> 00:38:06,790
i'm

1028
00:38:06,800 --> 00:38:08,400
that's that's the right presentation

1029
00:38:08,400 --> 00:38:10,160
thank you um i had

1030
00:38:10,160 --> 00:38:12,640
a quick question about uh the three page

1031
00:38:12,640 --> 00:38:13,359
tables

1032
00:38:13,359 --> 00:38:16,640
no so um how are the addresses or like

1033
00:38:16,640 --> 00:38:18,320
the ppn values

1034
00:38:18,320 --> 00:38:20,240
combined to form the final physical

1035
00:38:20,240 --> 00:38:22,320
address and i might have missed that

1036
00:38:22,320 --> 00:38:24,160
i know well i may have not said i said

1037
00:38:24,160 --> 00:38:25,440
it very explicitly

1038
00:38:25,440 --> 00:38:28,079
uh so the first ppn correct in top step

1039
00:38:28,079 --> 00:38:29,280
page

1040
00:38:29,280 --> 00:38:31,280
the first vpn in the top level page

1041
00:38:31,280 --> 00:38:32,400
directory

1042
00:38:32,400 --> 00:38:35,280
contains the physical address of the

1043
00:38:35,280 --> 00:38:35,760
next

1044
00:38:35,760 --> 00:38:39,119
level down right and that one contains

1045
00:38:39,119 --> 00:38:40,960
the one next level down and then in the

1046
00:38:40,960 --> 00:38:41,920
final one

1047
00:38:41,920 --> 00:38:44,560
we still have our few 44 bits that

1048
00:38:44,560 --> 00:38:46,079
contains then the actual

1049
00:38:46,079 --> 00:38:47,920
physical address of the page that we're

1050
00:38:47,920 --> 00:38:50,079
actually trying to translate to

1051
00:38:50,079 --> 00:38:52,480
ah okay that makes sense thank you okay

1052
00:38:52,480 --> 00:38:53,119
and one

1053
00:38:53,119 --> 00:38:54,480
interesting question just like a side

1054
00:38:54,480 --> 00:38:56,560
note before let me answer this

1055
00:38:56,560 --> 00:38:58,640
my own question before answering the two

1056
00:38:58,640 --> 00:39:00,320
raised hands here uh

1057
00:39:00,320 --> 00:39:03,040
if you look back at this picture why why

1058
00:39:03,040 --> 00:39:04,480
are there physical page numbers stored

1059
00:39:04,480 --> 00:39:07,829
in these page directories

1060
00:39:07,839 --> 00:39:11,520
why not a virtual address

1061
00:39:11,520 --> 00:39:13,760
because we need to look it up in memory

1062
00:39:13,760 --> 00:39:15,440
like look up the next directory in

1063
00:39:15,440 --> 00:39:16,079
memory

1064
00:39:16,079 --> 00:39:18,000
yeah right we could not have you know

1065
00:39:18,000 --> 00:39:19,760
our translation scheme depend on yet

1066
00:39:19,760 --> 00:39:21,200
another translation scheme you know we

1067
00:39:21,200 --> 00:39:22,480
could sort of in a recursive intent

1068
00:39:22,480 --> 00:39:24,480
would look so it just doesn't make sense

1069
00:39:24,480 --> 00:39:26,320
so that's exactly the right answer it

1070
00:39:26,320 --> 00:39:27,599
has to be a physical number

1071
00:39:27,599 --> 00:39:29,359
how about the satp what do you use the

1072
00:39:29,359 --> 00:39:31,119
satp what does it store does it store a

1073
00:39:31,119 --> 00:39:39,589
physical address or a virtual address

1074
00:39:39,599 --> 00:39:41,680
also physical assuming that the first

1075
00:39:41,680 --> 00:39:43,599
page directory is also memory right

1076
00:39:43,599 --> 00:39:46,000
yep yeah exactly so it has to be a

1077
00:39:46,000 --> 00:39:47,119
physical number because

1078
00:39:47,119 --> 00:39:48,320
we're actually trying to use it for

1079
00:39:48,320 --> 00:39:50,720
translation and

1080
00:39:50,720 --> 00:39:52,960
uh so you know the sap needs to know

1081
00:39:52,960 --> 00:39:55,119
what the physical page number is

1082
00:39:55,119 --> 00:39:59,040
of the root of the page directory

1083
00:39:59,040 --> 00:40:00,640
okay there were two other questions or

1084
00:40:00,640 --> 00:40:02,160
two people raised their hands

1085
00:40:02,160 --> 00:40:02,570
could you

1086
00:40:02,570 --> 00:40:05,990
[Music]

1087
00:40:06,000 --> 00:40:09,200
repeat your question if if it hasn't

1088
00:40:09,200 --> 00:40:10,800
been answered yet

1089
00:40:10,800 --> 00:40:14,319
so there's a hierarchy of three tables

1090
00:40:14,319 --> 00:40:16,560
and each of them is indexed by a part of

1091
00:40:16,560 --> 00:40:18,000
the virtual address

1092
00:40:18,000 --> 00:40:22,720
each nine bits long uh

1093
00:40:22,720 --> 00:40:26,000
so i i'm not sure i understand how

1094
00:40:26,000 --> 00:40:28,400
chaining between them happens and what

1095
00:40:28,400 --> 00:40:30,000
it's meant to accomplish like shouldn't

1096
00:40:30,000 --> 00:40:30,880
it be sufficient

1097
00:40:30,880 --> 00:40:33,680
to just use those three nine bit

1098
00:40:33,680 --> 00:40:36,640
addresses to index into each of them

1099
00:40:36,640 --> 00:40:38,800
that's correct so the first the top

1100
00:40:38,800 --> 00:40:40,400
level nine bits are usually index in the

1101
00:40:40,400 --> 00:40:41,040
first top

1102
00:40:41,040 --> 00:40:43,040
uh page level directory the second and

1103
00:40:43,040 --> 00:40:44,560
the next one and the third in the third

1104
00:40:44,560 --> 00:40:46,079
one

1105
00:40:46,079 --> 00:40:50,079
and so maybe i'm just not understanding

1106
00:40:50,079 --> 00:40:51,040
this correctly

1107
00:40:51,040 --> 00:40:54,800
so when uh a process requests a certain

1108
00:40:54,800 --> 00:40:57,359
like virtual address to be looked up it

1109
00:40:57,359 --> 00:41:00,400
loads into the satp register or the cpu

1110
00:41:00,400 --> 00:41:01,119
does

1111
00:41:01,119 --> 00:41:04,560
and that gets the corresponding correct

1112
00:41:04,560 --> 00:41:07,599
highest level page table yeah

1113
00:41:07,599 --> 00:41:10,640
and then that page table

1114
00:41:10,640 --> 00:41:13,280
will and we'll use then the top level

1115
00:41:13,280 --> 00:41:15,200
nine bits from the 27

1116
00:41:15,200 --> 00:41:18,560
to index into that page directory

1117
00:41:18,560 --> 00:41:20,400
and then what is what is the result of

1118
00:41:20,400 --> 00:41:22,319
that like if the result is

1119
00:41:22,319 --> 00:41:25,040
there's nothing there does the mmu

1120
00:41:25,040 --> 00:41:25,680
create

1121
00:41:25,680 --> 00:41:28,160
a page table no no the mmu basically

1122
00:41:28,160 --> 00:41:29,760
tells the operating system

1123
00:41:29,760 --> 00:41:31,280
or tells the processor sorry i couldn't

1124
00:41:31,280 --> 00:41:33,040
translate that address and

1125
00:41:33,040 --> 00:41:35,520
uh and basically turns into a page fault

1126
00:41:35,520 --> 00:41:36,640
which we'll talk about a little bit

1127
00:41:36,640 --> 00:41:38,880
later

1128
00:41:38,880 --> 00:41:40,800
but just you just can't not translate

1129
00:41:40,800 --> 00:41:42,160
the address so it doesn't translate it

1130
00:41:42,160 --> 00:41:43,359
it's like you know you can't divide by

1131
00:41:43,359 --> 00:41:43,920
zero

1132
00:41:43,920 --> 00:41:45,760
you know you try to do that the process

1133
00:41:45,760 --> 00:41:50,069
just refuses to do it

1134
00:41:50,079 --> 00:41:53,910
i see okay

1135
00:41:53,920 --> 00:41:57,280
brandman what about you brandon yep um

1136
00:41:57,280 --> 00:41:58,720
so i just wanted to make sure i

1137
00:41:58,720 --> 00:41:59,520
understand

1138
00:41:59,520 --> 00:42:04,230
how i think maybe we covered

1139
00:42:04,240 --> 00:42:07,280
kind of intermediate page table how we

1140
00:42:07,280 --> 00:42:09,520
calculate the physical address of those

1141
00:42:09,520 --> 00:42:12,400
um so is it correct that say if we were

1142
00:42:12,400 --> 00:42:14,000
trying to find a second level page

1143
00:42:14,000 --> 00:42:16,000
table's physical address we would take

1144
00:42:16,000 --> 00:42:18,720
the ppn from the first level page table

1145
00:42:18,720 --> 00:42:20,079
that's 44 bits

1146
00:42:20,079 --> 00:42:22,240
and then we add the 12-bit offset from

1147
00:42:22,240 --> 00:42:23,680
the original virtual address to get the

1148
00:42:23,680 --> 00:42:24,800
full 56-bit

1149
00:42:24,800 --> 00:42:27,359
fiscal address we don't add the offset

1150
00:42:27,359 --> 00:42:29,200
from the virtual address we just take 12

1151
00:42:29,200 --> 00:42:30,880
zero bits

1152
00:42:30,880 --> 00:42:33,520
so we take the ppn there's 44 bits oh

1153
00:42:33,520 --> 00:42:33,920
okay

1154
00:42:33,920 --> 00:42:36,000
we do 12 zero bits in the bottom and

1155
00:42:36,000 --> 00:42:38,560
that gives us a 56 bit physical address

1156
00:42:38,560 --> 00:42:40,079
and that's where the next page directory

1157
00:42:40,079 --> 00:42:41,520
is and this requires that basically

1158
00:42:41,520 --> 00:42:45,440
every page directory is page aligned

1159
00:42:45,440 --> 00:42:49,750
i see okay that makes sense

1160
00:42:49,760 --> 00:42:50,880
so these are all great questions and

1161
00:42:50,880 --> 00:42:51,839
these are all things you're going to be

1162
00:42:51,839 --> 00:42:54,079
struggling with in the page table lab so

1163
00:42:54,079 --> 00:42:59,910
it's very good to ask them right now um

1164
00:42:59,920 --> 00:43:02,480
okay uh let me see uh

1165
00:43:02,480 --> 00:43:04,319
[Music]

1166
00:43:04,319 --> 00:43:07,599
yes uh okay let me

1167
00:43:07,599 --> 00:43:10,839
hold on for a second and collect my

1168
00:43:10,839 --> 00:43:12,560
thoughts

1169
00:43:12,560 --> 00:43:16,230
and see where i am

1170
00:43:16,240 --> 00:43:19,920
good good good okay one uh sort of uh

1171
00:43:19,920 --> 00:43:21,760
you know one other thing that i want to

1172
00:43:21,760 --> 00:43:25,280
mention because you will see that

1173
00:43:25,280 --> 00:43:27,599
is that if we think about this you know

1174
00:43:27,599 --> 00:43:29,040
the scheme that i just showed

1175
00:43:29,040 --> 00:43:30,880
correct uh what really seems to be going

1176
00:43:30,880 --> 00:43:32,319
on is that when you load

1177
00:43:32,319 --> 00:43:34,720
or store a value to memory or the

1178
00:43:34,720 --> 00:43:36,720
processor motor storage value to memory

1179
00:43:36,720 --> 00:43:38,240
we basically have to do three memory

1180
00:43:38,240 --> 00:43:40,160
lookups right one in the

1181
00:43:40,160 --> 00:43:41,599
top level page directory one in the

1182
00:43:41,599 --> 00:43:43,040
intermediate page therefore library and

1183
00:43:43,040 --> 00:43:44,560
then one in the bottom level page

1184
00:43:44,560 --> 00:43:45,359
directory

1185
00:43:45,359 --> 00:43:47,119
so it looks like that you know any

1186
00:43:47,119 --> 00:43:48,960
memory reference to a virtual address

1187
00:43:48,960 --> 00:43:52,319
basically requires free memory reads

1188
00:43:52,319 --> 00:43:55,680
and so that seems expensive uh and so

1189
00:43:55,680 --> 00:43:58,160
uh what happens in practice where almost

1190
00:43:58,160 --> 00:43:59,599
all every prussian does this

1191
00:43:59,599 --> 00:44:01,680
it has a cache sitting on the side that

1192
00:44:01,680 --> 00:44:05,200
contains recently used translations

1193
00:44:05,200 --> 00:44:07,760
and this is called the translation

1194
00:44:07,760 --> 00:44:10,319
leukocyte

1195
00:44:10,319 --> 00:44:14,400
buffer and you'll see that term

1196
00:44:14,400 --> 00:44:18,640
quite often and it's called the tlb

1197
00:44:18,640 --> 00:44:19,920
basically it's nothing else than the

1198
00:44:19,920 --> 00:44:22,480
cache of

1199
00:44:22,480 --> 00:44:28,069
entry page table entries pt entries

1200
00:44:28,079 --> 00:44:29,920
so when the processor has you know the

1201
00:44:29,920 --> 00:44:31,359
first time the processor looks enough a

1202
00:44:31,359 --> 00:44:33,839
virtual address you know walks this uh

1203
00:44:33,839 --> 00:44:36,880
the hardware walks this uh page the

1204
00:44:36,880 --> 00:44:38,400
three level page tables

1205
00:44:38,400 --> 00:44:40,400
it will come out with you know the final

1206
00:44:40,400 --> 00:44:42,400
physical uh page or the finder called

1207
00:44:42,400 --> 00:44:44,480
ppn for that particular virtual address

1208
00:44:44,480 --> 00:44:48,829
and then basically the the tob

1209
00:44:48,839 --> 00:44:50,720
store.vnpapn

1210
00:44:50,720 --> 00:44:53,920
or pa mapping uh on the site

1211
00:44:53,920 --> 00:44:55,520
and so then when the next time you refer

1212
00:44:55,520 --> 00:44:57,520
to that particular virtual address

1213
00:44:57,520 --> 00:44:59,040
i can just look at the straight up in

1214
00:44:59,040 --> 00:45:01,599
the tlb and the tlb will respond

1215
00:45:01,599 --> 00:45:03,040
instead of having to do the page table

1216
00:45:03,040 --> 00:45:06,150
walk

1217
00:45:06,160 --> 00:45:09,750
yep i'm here

1218
00:45:09,760 --> 00:45:13,680
so the tlb maps

1219
00:45:13,680 --> 00:45:15,599
virtual addresses to the physical

1220
00:45:15,599 --> 00:45:17,040
address of the page

1221
00:45:17,040 --> 00:45:19,280
that the virtual address uh along with

1222
00:45:19,280 --> 00:45:20,319
the offset

1223
00:45:20,319 --> 00:45:23,760
yeah right wouldn't it be more

1224
00:45:23,760 --> 00:45:25,839
efficient to like cache at the page

1225
00:45:25,839 --> 00:45:27,760
table level

1226
00:45:27,760 --> 00:45:30,880
uh okay so i let me uh take a step back

1227
00:45:30,880 --> 00:45:31,359
here

1228
00:45:31,359 --> 00:45:33,440
um there's many ways of implementing the

1229
00:45:33,440 --> 00:45:34,480
tob

1230
00:45:34,480 --> 00:45:35,920
uh the most important thing that you

1231
00:45:35,920 --> 00:45:38,240
need to know is that there is a top

1232
00:45:38,240 --> 00:45:40,720
uh and the exact details of actually how

1233
00:45:40,720 --> 00:45:42,400
the pov is implemented to sort of

1234
00:45:42,400 --> 00:45:44,079
you know now the topic that we're going

1235
00:45:44,079 --> 00:45:45,440
to talk about in a great amount of

1236
00:45:45,440 --> 00:45:46,480
detail

1237
00:45:46,480 --> 00:45:49,440
in fact not at all and so this is really

1238
00:45:49,440 --> 00:45:50,400
something that sort of sits

1239
00:45:50,400 --> 00:45:51,920
inside of the processor and is mostly

1240
00:45:51,920 --> 00:45:53,119
hidden from the operating system the

1241
00:45:53,119 --> 00:45:54,560
operating system doesn't really know how

1242
00:45:54,560 --> 00:45:55,119
the top

1243
00:45:55,119 --> 00:45:58,000
operates the only thing the reason you

1244
00:45:58,000 --> 00:46:00,000
need to know that the qob exists

1245
00:46:00,000 --> 00:46:03,839
is that if you switch page tables

1246
00:46:03,839 --> 00:46:06,160
then typically the operating system

1247
00:46:06,160 --> 00:46:07,520
needs to tell

1248
00:46:07,520 --> 00:46:09,200
the processor that it's switching page

1249
00:46:09,200 --> 00:46:10,720
tables

1250
00:46:10,720 --> 00:46:16,710
and the be needs to be flushed

1251
00:46:16,720 --> 00:46:18,400
because basically you can't use tail

1252
00:46:18,400 --> 00:46:20,079
entries like if you switch to a new cage

1253
00:46:20,079 --> 00:46:20,800
table

1254
00:46:20,800 --> 00:46:22,960
the entries in the tob may not be valid

1255
00:46:22,960 --> 00:46:25,520
anymore and so they need to be removed

1256
00:46:25,520 --> 00:46:26,640
because otherwise you know the

1257
00:46:26,640 --> 00:46:28,800
translation would be incorrect

1258
00:46:28,800 --> 00:46:31,119
and so the operating system is typically

1259
00:46:31,119 --> 00:46:32,160
where

1260
00:46:32,160 --> 00:46:33,760
it's aware that there's a t that there

1261
00:46:33,760 --> 00:46:35,440
is a tlb

1262
00:46:35,440 --> 00:46:37,280
only basically to tell the hardware once

1263
00:46:37,280 --> 00:46:38,640
in a while saying like okay well don't

1264
00:46:38,640 --> 00:46:39,920
use them anymore

1265
00:46:39,920 --> 00:46:44,069
because i'm going to switch page tables

1266
00:46:44,079 --> 00:46:48,800
and in fact on you know the uh

1267
00:46:48,800 --> 00:46:50,400
on the risk files the instruction to

1268
00:46:50,400 --> 00:46:51,920
flush the tov is called

1269
00:46:51,920 --> 00:46:57,280
s fence underscore vma

1270
00:46:57,280 --> 00:47:01,280
and that will actually flush the top

1271
00:47:01,280 --> 00:47:04,800
be back um

1272
00:47:04,800 --> 00:47:07,200
so i have a question uh like not

1273
00:47:07,200 --> 00:47:08,720
regarding tlb but

1274
00:47:08,720 --> 00:47:12,000
that brought kind of uh this question

1275
00:47:12,000 --> 00:47:15,119
the three level support that the three

1276
00:47:15,119 --> 00:47:16,079
level um

1277
00:47:16,079 --> 00:47:19,040
paging that we have is it implemented by

1278
00:47:19,040 --> 00:47:20,800
the operating system or the hardware

1279
00:47:20,800 --> 00:47:21,440
itself

1280
00:47:21,440 --> 00:47:23,839
it's implemented by the hardware so you

1281
00:47:23,839 --> 00:47:25,760
know this all happens in hardware

1282
00:47:25,760 --> 00:47:29,280
the mmu is a block of hardware not in

1283
00:47:29,280 --> 00:47:30,160
the operating system

1284
00:47:30,160 --> 00:47:32,319
we'll see in a second when we look at

1285
00:47:32,319 --> 00:47:33,280
xv6

1286
00:47:33,280 --> 00:47:36,240
that xv6 has a function that models the

1287
00:47:36,240 --> 00:47:38,079
page table walk because once in a while

1288
00:47:38,079 --> 00:47:40,240
you know sv6 basically has to do what

1289
00:47:40,240 --> 00:47:42,000
the hardware does

1290
00:47:42,000 --> 00:47:44,000
uh and so it also doesn't have a

1291
00:47:44,000 --> 00:47:45,200
function called walk

1292
00:47:45,200 --> 00:47:46,720
that basically does exactly the same

1293
00:47:46,720 --> 00:47:51,430
thing but in software

1294
00:47:51,440 --> 00:47:54,559
so can i ask a question yeah go ahead

1295
00:47:54,559 --> 00:47:58,640
so um where in this scheme does the

1296
00:47:58,640 --> 00:48:00,079
processor cache fit

1297
00:48:00,079 --> 00:48:02,480
does it happen before the address

1298
00:48:02,480 --> 00:48:04,559
translation or after

1299
00:48:04,559 --> 00:48:06,800
because yeah yeah okay let me just

1300
00:48:06,800 --> 00:48:07,839
switch back a little bit

1301
00:48:07,839 --> 00:48:11,280
a couple uh let me see

1302
00:48:11,280 --> 00:48:14,400
uh okay here's your mmu

1303
00:48:14,400 --> 00:48:16,480
the whale really the way to think if i

1304
00:48:16,480 --> 00:48:19,839
think about it is that all this

1305
00:48:19,839 --> 00:48:21,680
know this whole block is inside of the

1306
00:48:21,680 --> 00:48:24,240
processor silicon

1307
00:48:24,240 --> 00:48:26,880
so there's a risc-v chip and inside of

1308
00:48:26,880 --> 00:48:28,000
it is the cpu

1309
00:48:28,000 --> 00:48:29,440
in fact they're multiple cpu correct

1310
00:48:29,440 --> 00:48:32,240
they're four cores and there's an mmu

1311
00:48:32,240 --> 00:48:33,920
and you know you can think about that

1312
00:48:33,920 --> 00:48:36,079
either on this on the cpu site you know

1313
00:48:36,079 --> 00:48:41,270
there's a you know tlb

1314
00:48:41,280 --> 00:48:44,390
okay

1315
00:48:44,400 --> 00:48:46,880
that makes sense um but i guess my

1316
00:48:46,880 --> 00:48:48,720
question was about the like

1317
00:48:48,720 --> 00:48:52,480
um cash in terms of not the tlb but just

1318
00:48:52,480 --> 00:48:53,040
the

1319
00:48:53,040 --> 00:48:55,440
normal cash like uh because sometimes we

1320
00:48:55,440 --> 00:48:57,119
don't actually go all the way to access

1321
00:48:57,119 --> 00:48:57,920
the memory

1322
00:48:57,920 --> 00:48:59,440
yeah yeah good good point so like i

1323
00:48:59,440 --> 00:49:00,720
showed you like the schema last week

1324
00:49:00,720 --> 00:49:01,680
correctly the

1325
00:49:01,680 --> 00:49:03,440
monday of the risk five processor it has

1326
00:49:03,440 --> 00:49:06,000
now one cache it has an l2 cache

1327
00:49:06,000 --> 00:49:08,079
uh some caches are indexed by physical

1328
00:49:08,079 --> 00:49:10,480
address and some caches are indexed by

1329
00:49:10,480 --> 00:49:11,680
virtual address

1330
00:49:11,680 --> 00:49:13,119
so the caches that are indexed by

1331
00:49:13,119 --> 00:49:15,040
virtual address sit before

1332
00:49:15,040 --> 00:49:17,760
the mmu and cache their index by

1333
00:49:17,760 --> 00:49:24,549
physical addressing after the mmu

1334
00:49:24,559 --> 00:49:26,640
does that make sense can i also ask a

1335
00:49:26,640 --> 00:49:27,920
question

1336
00:49:27,920 --> 00:49:31,040
my question is you said that the um

1337
00:49:31,040 --> 00:49:34,240
tlb it walks so like to put stuff into

1338
00:49:34,240 --> 00:49:34,960
tlb

1339
00:49:34,960 --> 00:49:37,680
the hardware walks through the page

1340
00:49:37,680 --> 00:49:38,800
tables

1341
00:49:38,800 --> 00:49:42,480
um why do we write walk function if

1342
00:49:42,480 --> 00:49:44,720
hardware can do that

1343
00:49:44,720 --> 00:49:47,920
very good question um one reason

1344
00:49:47,920 --> 00:49:49,599
there's a couple of reasons why we do it

1345
00:49:49,599 --> 00:49:51,440
or why xv6 needs it

1346
00:49:51,440 --> 00:49:52,720
one is when it actually sets up the

1347
00:49:52,720 --> 00:49:54,960
initial page tables

1348
00:49:54,960 --> 00:49:57,520
uh you know it needs to program the the

1349
00:49:57,520 --> 00:49:58,559
three levels

1350
00:49:58,559 --> 00:50:00,480
and so it needs to basically emulate the

1351
00:50:00,480 --> 00:50:02,079
three levels

1352
00:50:02,079 --> 00:50:06,079
uh another uh example that you actually

1353
00:50:06,079 --> 00:50:08,480
sort of ran into or are running into in

1354
00:50:08,480 --> 00:50:09,839
the cisco lab

1355
00:50:09,839 --> 00:50:12,480
is that when you cop you know the in xv6

1356
00:50:12,480 --> 00:50:14,480
the kernel has its own page table

1357
00:50:14,480 --> 00:50:16,800
and every user address space has its own

1358
00:50:16,800 --> 00:50:18,079
page table

1359
00:50:18,079 --> 00:50:20,079
and but once in a while you know for

1360
00:50:20,079 --> 00:50:21,119
example it says info

1361
00:50:21,119 --> 00:50:22,480
you know like this is the pointer to the

1362
00:50:22,480 --> 00:50:24,319
system construct you know that lives in

1363
00:50:24,319 --> 00:50:25,599
user space

1364
00:50:25,599 --> 00:50:27,440
the kernel needs to be translated to an

1365
00:50:27,440 --> 00:50:29,040
address that it can use to read and

1366
00:50:29,040 --> 00:50:30,319
write it

1367
00:50:30,319 --> 00:50:32,559
and so for example if you look in copy

1368
00:50:32,559 --> 00:50:33,520
in or

1369
00:50:33,520 --> 00:50:36,880
copy out basically the kernel

1370
00:50:36,880 --> 00:50:40,079
translates the user virtual address

1371
00:50:40,079 --> 00:50:43,680
using the user uh virtual using the user

1372
00:50:43,680 --> 00:50:45,680
page table to get out a physical address

1373
00:50:45,680 --> 00:50:47,200
that that kernel then

1374
00:50:47,200 --> 00:50:49,920
uh to get an address out that actually

1375
00:50:49,920 --> 00:50:51,200
then the kernel can use to read and

1376
00:50:51,200 --> 00:50:54,400
write that memory

1377
00:50:54,400 --> 00:50:55,520
so there's a bunch of places like the

1378
00:50:55,520 --> 00:50:57,200
show job and i'll talk about it

1379
00:50:57,200 --> 00:50:57,839
hopefully in

1380
00:50:57,839 --> 00:50:59,200
you know whatever 10 minutes or 15

1381
00:50:59,200 --> 00:51:01,760
minutes um i have a question

1382
00:51:01,760 --> 00:51:05,280
why doesn't the hardware like expose

1383
00:51:05,280 --> 00:51:07,040
that walk function so we don't have to

1384
00:51:07,040 --> 00:51:08,559
write our own and like potentially have

1385
00:51:08,559 --> 00:51:09,440
bugs in it

1386
00:51:09,440 --> 00:51:11,680
uh why isn't there like a you know maybe

1387
00:51:11,680 --> 00:51:12,880
a privileged instruction that you can

1388
00:51:12,880 --> 00:51:14,480
pass a virtual address and it'll give

1389
00:51:14,480 --> 00:51:16,319
back the physical address

1390
00:51:16,319 --> 00:51:18,079
well this is just like just store to the

1391
00:51:18,079 --> 00:51:19,920
virtual address and you get back

1392
00:51:19,920 --> 00:51:22,720
and we'll do it right for you uh so and

1393
00:51:22,720 --> 00:51:23,359
we'll see

1394
00:51:23,359 --> 00:51:26,960
later on uh in the next lap the page

1395
00:51:26,960 --> 00:51:27,839
table app

1396
00:51:27,839 --> 00:51:29,520
in fact is exactly what you'll be doing

1397
00:51:29,520 --> 00:51:31,200
you will actually set up the page table

1398
00:51:31,200 --> 00:51:32,720
slightly differently so that you can

1399
00:51:32,720 --> 00:51:33,280
avoid

1400
00:51:33,280 --> 00:51:42,390
the walk and copy in and copy and string

1401
00:51:42,400 --> 00:51:43,680
i think this will become clear in a

1402
00:51:43,680 --> 00:51:45,359
second that we when we talk about look

1403
00:51:45,359 --> 00:51:49,670
at the xv6 okay

1404
00:51:49,680 --> 00:51:52,960
okay good um one more issue

1405
00:51:52,960 --> 00:51:54,400
and basically before jumping into the

1406
00:51:54,400 --> 00:51:56,480
x86 uh i wanted to make one

1407
00:51:56,480 --> 00:52:00,079
point um one way to think about

1408
00:52:00,079 --> 00:52:05,910
uh you know uh page tables

1409
00:52:05,920 --> 00:52:09,839
uh a popular way to phrase this

1410
00:52:09,839 --> 00:52:13,280
is the page tables uh provide

1411
00:52:13,280 --> 00:52:19,680
a level of indirection

1412
00:52:19,680 --> 00:52:25,030
and

1413
00:52:25,040 --> 00:52:27,280
and that uh and so basically this

1414
00:52:27,280 --> 00:52:28,559
indirection grid what i'm talking about

1415
00:52:28,559 --> 00:52:29,760
you know this mapping from virtual

1416
00:52:29,760 --> 00:52:31,440
address the physical address

1417
00:52:31,440 --> 00:52:33,680
and this mapping is completely under the

1418
00:52:33,680 --> 00:52:35,040
control

1419
00:52:35,040 --> 00:52:38,230
of the operating system

1420
00:52:38,240 --> 00:52:40,720
as we've seen you know in the last in a

1421
00:52:40,720 --> 00:52:42,640
couple of slides that we talked

1422
00:52:42,640 --> 00:52:44,960
and that means that the operating system

1423
00:52:44,960 --> 00:52:46,640
because it has so much control over it

1424
00:52:46,640 --> 00:52:48,240
has control over the complete control of

1425
00:52:48,240 --> 00:52:49,440
that translation

1426
00:52:49,440 --> 00:52:51,359
um it can do all kinds of interesting

1427
00:52:51,359 --> 00:52:52,640
tricks

1428
00:52:52,640 --> 00:52:55,440
uh and so for example like one trick uh

1429
00:52:55,440 --> 00:52:56,559
you know we talked a little bit about

1430
00:52:56,559 --> 00:52:57,760
this like if a pitch

1431
00:52:57,760 --> 00:53:00,240
pedal entry is invalid and will really

1432
00:53:00,240 --> 00:53:03,119
return a page you know the hardware will

1433
00:53:03,119 --> 00:53:05,839
raise a page fault in response that page

1434
00:53:05,839 --> 00:53:06,559
fault

1435
00:53:06,559 --> 00:53:08,160
the operating system could update the

1436
00:53:08,160 --> 00:53:09,680
page tables and then maybe

1437
00:53:09,680 --> 00:53:12,319
restart the instruction and so there's

1438
00:53:12,319 --> 00:53:14,000
all kinds of things that they can do

1439
00:53:14,000 --> 00:53:17,920
at runtime by manipulating the page

1440
00:53:17,920 --> 00:53:19,119
tables

1441
00:53:19,119 --> 00:53:21,200
and we're not going to talk about that

1442
00:53:21,200 --> 00:53:22,720
to today but in

1443
00:53:22,720 --> 00:53:25,359
two weeks we'll have a lecture exactly

1444
00:53:25,359 --> 00:53:26,800
sort of about this topic about

1445
00:53:26,800 --> 00:53:28,559
what cool things can you do once you

1446
00:53:28,559 --> 00:53:31,440
have page tables and page faults

1447
00:53:31,440 --> 00:53:34,319
but it's important to keep in mind that

1448
00:53:34,319 --> 00:53:35,280
this is a

1449
00:53:35,280 --> 00:53:38,800
incredibly powerful mechanism

1450
00:53:38,800 --> 00:53:40,720
that will provide the operating system

1451
00:53:40,720 --> 00:53:43,440
with a tremendous amount of flexibility

1452
00:53:43,440 --> 00:53:45,200
and there's one reason why page tables

1453
00:53:45,200 --> 00:53:49,430
are so popular

1454
00:53:49,440 --> 00:53:51,599
okay so what i want to do next is

1455
00:53:51,599 --> 00:53:52,880
actually talk about

1456
00:53:52,880 --> 00:53:56,240
xv6 and sort of see

1457
00:53:56,240 --> 00:53:59,520
how this all plays out in xv6

1458
00:53:59,520 --> 00:54:01,520
so the first thing i'm going to do is

1459
00:54:01,520 --> 00:54:03,040
i'm going to look at the

1460
00:54:03,040 --> 00:54:06,720
kernel page layout if you will um

1461
00:54:06,720 --> 00:54:10,319
and the the mapping is on this slide

1462
00:54:10,319 --> 00:54:20,790
so here's the virtual address space

1463
00:54:20,800 --> 00:54:24,480
of the kernel and here is actually the

1464
00:54:24,480 --> 00:54:25,920
physical memory so this is what

1465
00:54:25,920 --> 00:54:27,359
basically whatever you can think about

1466
00:54:27,359 --> 00:54:31,670
this is drm

1467
00:54:31,680 --> 00:54:34,800
and in fact it is not uh let me take the

1468
00:54:34,800 --> 00:54:35,920
back immediately

1469
00:54:35,920 --> 00:54:39,599
one part is drm and one part

1470
00:54:39,599 --> 00:54:46,309
is actually i o devices

1471
00:54:46,319 --> 00:54:49,040
and so to sort of maybe i'm going to

1472
00:54:49,040 --> 00:54:50,640
talk about the physical the right side

1473
00:54:50,640 --> 00:54:52,160
of the slide a little bit first and then

1474
00:54:52,160 --> 00:54:53,440
we'll talk about the left side in a

1475
00:54:53,440 --> 00:54:54,240
second

1476
00:54:54,240 --> 00:54:56,880
so the left side of the slide is

1477
00:54:56,880 --> 00:54:59,200
completely determined by the hardware

1478
00:54:59,200 --> 00:55:01,040
and so the hardware designers basically

1479
00:55:01,040 --> 00:55:02,960
determine the layout of that fit

1480
00:55:02,960 --> 00:55:06,720
and you know as you saw before last week

1481
00:55:06,720 --> 00:55:08,799
when the kernel starts it starts at this

1482
00:55:08,799 --> 00:55:12,400
address ox880

1483
00:55:12,400 --> 00:55:13,839
and that's just determined by the

1484
00:55:13,839 --> 00:55:15,680
hardware designers uh

1485
00:55:15,680 --> 00:55:19,119
and so to be more explicit

1486
00:55:19,119 --> 00:55:20,880
so if you look at the board this is the

1487
00:55:20,880 --> 00:55:22,559
same picture of the board that i showed

1488
00:55:22,559 --> 00:55:24,000
on monday but it's hopefully a little

1489
00:55:24,000 --> 00:55:24,799
bit better

1490
00:55:24,799 --> 00:55:26,720
picture it's easier to see here's our

1491
00:55:26,720 --> 00:55:28,319
risk five processor

1492
00:55:28,319 --> 00:55:29,839
and we now know correct that in the risk

1493
00:55:29,839 --> 00:55:31,599
five processor there are four cores

1494
00:55:31,599 --> 00:55:34,240
but there's also an mmu and there's also

1495
00:55:34,240 --> 00:55:35,359
a tob

1496
00:55:35,359 --> 00:55:37,920
or multiple tv every cord has his own

1497
00:55:37,920 --> 00:55:40,799
mmu and every core has his own tlb

1498
00:55:40,799 --> 00:55:44,720
and here are the d-ring chips and so

1499
00:55:44,720 --> 00:55:46,559
basically the designers of the board

1500
00:55:46,559 --> 00:55:48,559
have decided that uh

1501
00:55:48,559 --> 00:55:51,280
when you know the after you know the

1502
00:55:51,280 --> 00:55:52,559
translation for virtual to fiscal

1503
00:55:52,559 --> 00:55:53,200
address

1504
00:55:53,200 --> 00:55:54,640
basically physical addresses that's

1505
00:55:54,640 --> 00:55:57,040
starting you know at 08 you know a lot

1506
00:55:57,040 --> 00:55:57,760
of zeros

1507
00:55:57,760 --> 00:56:00,799
actually go to the dram chips and

1508
00:56:00,799 --> 00:56:02,079
dresses above below

1509
00:56:02,079 --> 00:56:05,119
oa8 may go to different io devices

1510
00:56:05,119 --> 00:56:08,319
and so the the platform decides

1511
00:56:08,319 --> 00:56:08,960
basically

1512
00:56:08,960 --> 00:56:10,640
the designers of this board have decided

1513
00:56:10,640 --> 00:56:12,640
exactly what the physical layout

1514
00:56:12,640 --> 00:56:14,079
in fact you can look that up the

1515
00:56:14,079 --> 00:56:16,079
physical layout if you want to

1516
00:56:16,079 --> 00:56:17,920
just let me show you that so here's the

1517
00:56:17,920 --> 00:56:22,000
the same manual that i showed you on uh

1518
00:56:22,000 --> 00:56:25,680
on on monday

1519
00:56:25,680 --> 00:56:29,440
and if you go to actually escape

1520
00:56:29,440 --> 00:56:32,720
you go to page 31 i believe

1521
00:56:32,720 --> 00:56:36,000
here is the page um and if you go down

1522
00:56:36,000 --> 00:56:36,480
this

1523
00:56:36,480 --> 00:56:38,400
is what's the memory it will spell out

1524
00:56:38,400 --> 00:56:39,520
what the memory map is

1525
00:56:39,520 --> 00:56:42,799
of the uh the board and it will say like

1526
00:56:42,799 --> 00:56:44,000
at address zero zero

1527
00:56:44,000 --> 00:56:47,520
is reserved nothing is there uh if you

1528
00:56:47,520 --> 00:56:49,920
go scroll down in this memory map you

1529
00:56:49,920 --> 00:56:51,119
know you'll see

1530
00:56:51,119 --> 00:56:53,119
some information about all the different

1531
00:56:53,119 --> 00:56:54,559
things that are mapped for example

1532
00:56:54,559 --> 00:56:57,839
ethernet board is mapped at ox 1

1533
00:56:57,839 --> 00:57:01,119
you know x something

1534
00:57:01,119 --> 00:57:03,920
if you go further down oops that was too

1535
00:57:03,920 --> 00:57:05,520
much down

1536
00:57:05,520 --> 00:57:08,880
here you see the entry for ox 8

1537
00:57:08,880 --> 00:57:12,559
0 0 0 correct and that actually is ddr

1538
00:57:12,559 --> 00:57:14,960
memory the off chip volatile memory and

1539
00:57:14,960 --> 00:57:16,640
so those are the dram chips that i just

1540
00:57:16,640 --> 00:57:19,359
showed you on the previous slide

1541
00:57:19,359 --> 00:57:20,799
and so it's just good to keep in your

1542
00:57:20,799 --> 00:57:21,920
head correct even though we're not

1543
00:57:21,920 --> 00:57:23,599
talking to keemu and your old osc

1544
00:57:23,599 --> 00:57:24,160
software

1545
00:57:24,160 --> 00:57:26,480
in the end everything is determined uh

1546
00:57:26,480 --> 00:57:30,549
by you know the actual board

1547
00:57:30,559 --> 00:57:34,640
okay so go back to uh my slides

1548
00:57:34,640 --> 00:57:38,160
uh so let's look at the layout

1549
00:57:38,160 --> 00:57:41,359
yeah uh noah go ahead

1550
00:57:41,359 --> 00:57:43,119
yeah when you say that this this layout

1551
00:57:43,119 --> 00:57:44,480
is determined by the hardware uh

1552
00:57:44,480 --> 00:57:47,040
do you specifically mean uh like the cpu

1553
00:57:47,040 --> 00:57:48,400
itself or the

1554
00:57:48,400 --> 00:57:50,880
the board on which the cpu resides the

1555
00:57:50,880 --> 00:57:52,640
board in which the cpu resides correct

1556
00:57:52,640 --> 00:57:54,400
because you know the board you know the

1557
00:57:54,400 --> 00:57:55,520
the cpu is that that

1558
00:57:55,520 --> 00:57:57,040
gray thing in the middle that square

1559
00:57:57,040 --> 00:57:59,440
thing saying uh whatever risk five

1560
00:57:59,440 --> 00:58:02,960
the dram chips are sitting off the uh

1561
00:58:02,960 --> 00:58:04,720
of the processor correct and it's the

1562
00:58:04,720 --> 00:58:06,160
board designers who put the

1563
00:58:06,160 --> 00:58:09,440
chip the the the many i o devices all

1564
00:58:09,440 --> 00:58:12,390
together

1565
00:58:12,400 --> 00:58:14,240
the large part of an operating system is

1566
00:58:14,240 --> 00:58:15,760
actually you know the cpu is one part

1567
00:58:15,760 --> 00:58:17,280
but the i o devices are at least as

1568
00:58:17,280 --> 00:58:18,960
important right and so when you're

1569
00:58:18,960 --> 00:58:20,240
writing an operating system

1570
00:58:20,240 --> 00:58:21,920
you both have to deal with the cpu as

1571
00:58:21,920 --> 00:58:23,520
well as you know with the i o devices

1572
00:58:23,520 --> 00:58:24,640
you know you and you want to send a

1573
00:58:24,640 --> 00:58:25,839
packet over the internet

1574
00:58:25,839 --> 00:58:29,280
well somebody has to tickle

1575
00:58:29,280 --> 00:58:30,880
you know the network drive or the nic

1576
00:58:30,880 --> 00:58:32,240
card to actually do that and that's the

1577
00:58:32,240 --> 00:58:35,349
operating system

1578
00:58:35,359 --> 00:58:37,599
so going back to the right side of this

1579
00:58:37,599 --> 00:58:38,880
picture correct this is the physical

1580
00:58:38,880 --> 00:58:39,680
dress

1581
00:58:39,680 --> 00:58:41,839
layout you know we see basically that

1582
00:58:41,839 --> 00:58:43,440
you know the bottom was unused as i

1583
00:58:43,440 --> 00:58:44,720
showed you on that uh

1584
00:58:44,720 --> 00:58:47,920
document it turns out that ox100 that

1585
00:58:47,920 --> 00:58:49,839
physical address does where the boot rom

1586
00:58:49,839 --> 00:58:51,359
is so when you turn on

1587
00:58:51,359 --> 00:58:52,960
you know that board the first thing that

1588
00:58:52,960 --> 00:58:54,880
happens is actually code in the boot rom

1589
00:58:54,880 --> 00:58:57,599
runs and when the boot run is done it

1590
00:58:57,599 --> 00:59:00,400
actually will jump to this ox000

1591
00:59:00,400 --> 00:59:02,000
and it's a job of the operating system

1592
00:59:02,000 --> 00:59:03,599
make sure that there's some

1593
00:59:03,599 --> 00:59:05,680
you know some data there and then

1594
00:59:05,680 --> 00:59:07,200
there's a bunch of other devices

1595
00:59:07,200 --> 00:59:10,319
that we'll talk about here's the uh an

1596
00:59:10,319 --> 00:59:11,359
interrupt controller

1597
00:59:11,359 --> 00:59:13,760
uh we'll talk about it next week uh

1598
00:59:13,760 --> 00:59:14,880
there's a clint

1599
00:59:14,880 --> 00:59:17,920
another a part of the interrupt story

1600
00:59:17,920 --> 00:59:19,359
that we'll talk about next week

1601
00:59:19,359 --> 00:59:21,040
so basically multiple devices can

1602
00:59:21,040 --> 00:59:22,559
generate interrupts there needs to be a

1603
00:59:22,559 --> 00:59:24,640
plan to route those interrupts to

1604
00:59:24,640 --> 00:59:26,720
the to the appropriate request level and

1605
00:59:26,720 --> 00:59:28,640
that's all implemented by

1606
00:59:28,640 --> 00:59:31,680
those interrupt controllers and let me

1607
00:59:31,680 --> 00:59:33,359
finish for a second you know this this

1608
00:59:33,359 --> 00:59:34,720
slide before

1609
00:59:34,720 --> 00:59:37,839
answering the question um then there's a

1610
00:59:37,839 --> 00:59:39,839
uart that was the device

1611
00:59:39,839 --> 00:59:41,680
uh that was actually the thing that

1612
00:59:41,680 --> 00:59:44,000
actually the device is actually in a new

1613
00:59:44,000 --> 00:59:45,280
device that actually interacts with the

1614
00:59:45,280 --> 00:59:47,040
console and the display

1615
00:59:47,040 --> 00:59:48,640
and then there's the virtual there's the

1616
00:59:48,640 --> 00:59:50,240
disk uh

1617
00:59:50,240 --> 00:59:52,160
and that's the device there's where the

1618
00:59:52,160 --> 00:59:54,160
device sits that actually interacts with

1619
00:59:54,160 --> 00:59:54,799
the disk

1620
00:59:54,799 --> 00:59:57,040
and so when you write to location to

1621
00:59:57,040 --> 00:59:58,839
address let's say

1622
00:59:58,839 --> 01:00:02,400
ox200 then that physical address

1623
01:00:02,400 --> 01:00:03,680
corresponds to the clint

1624
01:00:03,680 --> 01:00:04,880
and so do you when you do store

1625
01:00:04,880 --> 01:00:06,960
instruction or load instruction you're

1626
01:00:06,960 --> 01:00:10,079
reading and writing to the chip that

1627
01:00:10,079 --> 01:00:10,799
implements the

1628
01:00:10,799 --> 01:00:14,079
uh clint and we'll see later what that

1629
01:00:14,079 --> 01:00:14,880
exactly means

1630
01:00:14,880 --> 01:00:16,240
but basically you can think about this

1631
01:00:16,240 --> 01:00:18,079
as interacting directly with the device

1632
01:00:18,079 --> 01:00:19,359
and not reading and writing physical

1633
01:00:19,359 --> 01:00:21,599
memory

1634
01:00:21,599 --> 01:00:24,640
yeah there was a question um

1635
01:00:24,640 --> 01:00:26,640
so just trying to make sure the

1636
01:00:26,640 --> 01:00:29,079
addresses below

1637
01:00:29,079 --> 01:00:33,680
ox800 they don't really exist in dram

1638
01:00:33,680 --> 01:00:35,280
if when we mention those addresses we

1639
01:00:35,280 --> 01:00:37,200
directly go to the other hardwares

1640
01:00:37,200 --> 01:00:39,280
yeah yeah so like if you go back to this

1641
01:00:39,280 --> 01:00:40,319
picture

1642
01:00:40,319 --> 01:00:45,190
anything above ox one zero correct

1643
01:00:45,200 --> 01:00:48,799
that's these dram chips and

1644
01:00:48,799 --> 01:00:50,640
you know i can't draw you i can't point

1645
01:00:50,640 --> 01:00:52,799
you to the clint uh but like for example

1646
01:00:52,799 --> 01:00:53,760
here's the

1647
01:00:53,760 --> 01:00:57,119
uh and so that's it's a particular

1648
01:00:57,119 --> 01:00:58,559
physical address and we can write

1649
01:00:58,559 --> 01:00:59,599
you know with load and store

1650
01:00:59,599 --> 01:01:00,799
instructions this is called memory

1651
01:01:00,799 --> 01:01:01,760
mapped io

1652
01:01:01,760 --> 01:01:03,520
we can do load and store instructions we

1653
01:01:03,520 --> 01:01:09,190
can program the ethernet controller

1654
01:01:09,200 --> 01:01:12,079
um i also have a question uh why why is

1655
01:01:12,079 --> 01:01:13,280
this big chunk

1656
01:01:13,280 --> 01:01:16,240
at the top says and used why is it not

1657
01:01:16,240 --> 01:01:17,040
used

1658
01:01:17,040 --> 01:01:20,640
oh uh okay so remember uh

1659
01:01:20,640 --> 01:01:23,119
not every machine not every so there's

1660
01:01:23,119 --> 01:01:25,200
two to the power 56

1661
01:01:25,200 --> 01:01:28,000
uh bytes of physical address space uh

1662
01:01:28,000 --> 01:01:29,200
but you don't have to

1663
01:01:29,200 --> 01:01:31,040
you know plug in that much memory into

1664
01:01:31,040 --> 01:01:32,880
the board if you don't want to

1665
01:01:32,880 --> 01:01:35,520
and so some parts of it may be unused

1666
01:01:35,520 --> 01:01:36,880
depending on how much you know dram

1667
01:01:36,880 --> 01:01:42,230
chips are sitting on the board

1668
01:01:42,240 --> 01:01:45,520
in fact like in xv6 we i think

1669
01:01:45,520 --> 01:01:50,319
limit ourselves to 128 megabytes

1670
01:01:50,319 --> 01:01:55,349
and no more

1671
01:01:55,359 --> 01:01:59,039
so when um um when a

1672
01:01:59,039 --> 01:02:01,440
load restore instruction goes out of the

1673
01:02:01,440 --> 01:02:02,480
cpu

1674
01:02:02,480 --> 01:02:05,839
um does that go like

1675
01:02:05,839 --> 01:02:07,839
where does it get routed to the correct

1676
01:02:07,839 --> 01:02:10,160
i o like already from the cpu

1677
01:02:10,160 --> 01:02:12,880
so kind of like if the cpu before it

1678
01:02:12,880 --> 01:02:13,520
sends it out

1679
01:02:13,520 --> 01:02:16,400
it says okay if it's lower than 0x8 and

1680
01:02:16,400 --> 01:02:17,520
all the zeros

1681
01:02:17,520 --> 01:02:19,200
then i'm gonna send it to like the

1682
01:02:19,200 --> 01:02:20,960
correct i o device and then otherwise

1683
01:02:20,960 --> 01:02:22,559
i'm going to send it to

1684
01:02:22,559 --> 01:02:27,440
the um to the memory like the dram chip

1685
01:02:27,440 --> 01:02:29,039
you can think about as a demultiplexer

1686
01:02:29,039 --> 01:02:30,640
sitting on the inside of the

1687
01:02:30,640 --> 01:02:33,920
risc-5 you know blob oh so it's inside

1688
01:02:33,920 --> 01:02:35,680
of that block

1689
01:02:35,680 --> 01:02:39,359
okay that's your memory controller

1690
01:02:39,359 --> 01:02:45,270
and that doesn't do routing

1691
01:02:45,280 --> 01:02:46,559
very important to have that sort of all

1692
01:02:46,559 --> 01:02:51,270
clear in your head

1693
01:02:51,280 --> 01:02:53,200
are we okay so now i want to switch to

1694
01:02:53,200 --> 01:02:55,520
the right side of this picture

1695
01:02:55,520 --> 01:02:58,640
and this is basically what xv6 sets up

1696
01:02:58,640 --> 01:03:02,000
to uh the virtual dress space that xv6

1697
01:03:02,000 --> 01:03:04,559
sets up so when the machine boots

1698
01:03:04,559 --> 01:03:05,359
there's no

1699
01:03:05,359 --> 01:03:08,720
aging enabler yet uh xv6 sets up the

1700
01:03:08,720 --> 01:03:09,200
first

1701
01:03:09,200 --> 01:03:11,280
you know page page tables the first

1702
01:03:11,280 --> 01:03:12,559
virtual address space and that's

1703
01:03:12,559 --> 01:03:13,599
actually the virtual address space that

1704
01:03:13,599 --> 01:03:15,200
the kernel uses and we'll look at it in

1705
01:03:15,200 --> 01:03:17,280
a second at the code

1706
01:03:17,280 --> 01:03:19,599
but uh and this is the layout and it

1707
01:03:19,599 --> 01:03:20,559
turns out

1708
01:03:20,559 --> 01:03:22,960
uh you know because we want to keep xv6

1709
01:03:22,960 --> 01:03:24,319
as simple as possible it's

1710
01:03:24,319 --> 01:03:26,799
easy for you to understand the mapping

1711
01:03:26,799 --> 01:03:28,480
from virtual

1712
01:03:28,480 --> 01:03:31,920
to physical is mostly in identity

1713
01:03:31,920 --> 01:03:37,990
mapping

1714
01:03:38,000 --> 01:03:40,480
so basically what that means is that the

1715
01:03:40,480 --> 01:03:43,280
virtual address ox200

1716
01:03:43,280 --> 01:03:46,480
maps to physical address ox2000

1717
01:03:46,480 --> 01:03:48,400
the kernel will set up the page tables

1718
01:03:48,400 --> 01:03:49,839
exactly in that way

1719
01:03:49,839 --> 01:03:51,680
and so that means basically that you

1720
01:03:51,680 --> 01:03:53,280
know for all virtual addresses

1721
01:03:53,280 --> 01:03:56,640
below this top which is the top of

1722
01:03:56,640 --> 01:03:57,839
physical memory

1723
01:03:57,839 --> 01:03:59,839
are identical to the physical addresses

1724
01:03:59,839 --> 01:04:01,119
that are actually being used

1725
01:04:01,119 --> 01:04:03,760
uh on the right side and so this is like

1726
01:04:03,760 --> 01:04:05,440
why all the arrows are straight

1727
01:04:05,440 --> 01:04:09,270
because it's you know identity mapping

1728
01:04:09,280 --> 01:04:13,440
okay there's a small changes to this

1729
01:04:13,440 --> 01:04:16,160
uh uh the two important things to

1730
01:04:16,160 --> 01:04:17,599
mention

1731
01:04:17,599 --> 01:04:20,480
uh let me hold one second uh while i try

1732
01:04:20,480 --> 01:04:20,960
to

1733
01:04:20,960 --> 01:04:22,240
first mention the two important things

1734
01:04:22,240 --> 01:04:24,240
to mention um

1735
01:04:24,240 --> 01:04:27,280
first of all there's some pages some map

1736
01:04:27,280 --> 01:04:33,349
is very high up in memory

1737
01:04:33,359 --> 01:04:35,359
some pages very high up in memory uh for

1738
01:04:35,359 --> 01:04:36,400
example

1739
01:04:36,400 --> 01:04:39,599
the stack uh the kernel stack actually

1740
01:04:39,599 --> 01:04:40,240
sits up

1741
01:04:40,240 --> 01:04:42,720
it's also mapped high up in memory and

1742
01:04:42,720 --> 01:04:44,319
the reason it's high up in memory is

1743
01:04:44,319 --> 01:04:46,240
because we have a guard page below it

1744
01:04:46,240 --> 01:04:47,680
that is not mapped

1745
01:04:47,680 --> 01:04:50,880
so the pte entry below the kernel stack

1746
01:04:50,880 --> 01:04:52,400
of one of the kernel stacks

1747
01:04:52,400 --> 01:04:55,680
does have not have uh it's valid bit set

1748
01:04:55,680 --> 01:04:58,559
and uh so if you know the kernel runs

1749
01:04:58,559 --> 01:04:59,680
off its stack

1750
01:04:59,680 --> 01:05:02,079
it will result in a page fault which is

1751
01:05:02,079 --> 01:05:03,200
better than basically

1752
01:05:03,200 --> 01:05:04,559
you know scribbling over some other

1753
01:05:04,559 --> 01:05:06,400
memory that the kernel has you get an

1754
01:05:06,400 --> 01:05:07,599
immediate panic and you know that

1755
01:05:07,599 --> 01:05:08,319
something's bad

1756
01:05:08,319 --> 01:05:11,599
to stack um of course we don't want to

1757
01:05:11,599 --> 01:05:13,039
waste physical memory

1758
01:05:13,039 --> 01:05:15,280
and so when we do that by basically uh

1759
01:05:15,280 --> 01:05:16,960
putting the stack high

1760
01:05:16,960 --> 01:05:20,640
uh in a guard page an empty guard

1761
01:05:20,640 --> 01:05:23,920
pte entry below it and the guard

1762
01:05:23,920 --> 01:05:26,000
page doesn't really consume any physical

1763
01:05:26,000 --> 01:05:27,520
memory like it's sitting high up in the

1764
01:05:27,520 --> 01:05:29,200
virtual address space so

1765
01:05:29,200 --> 01:05:31,920
nothing is being consumed but that means

1766
01:05:31,920 --> 01:05:33,440
that they're showing this k stack page

1767
01:05:33,440 --> 01:05:35,280
for example is mapped twice

1768
01:05:35,280 --> 01:05:37,520
it's mapped at a high address and it's

1769
01:05:37,520 --> 01:05:38,559
mapped directly

1770
01:05:38,559 --> 01:05:40,079
you know by one of the addresses that

1771
01:05:40,079 --> 01:05:42,480
below this top

1772
01:05:42,480 --> 01:05:44,960
and so you can do this is one example of

1773
01:05:44,960 --> 01:05:46,000
all the sort of

1774
01:05:46,000 --> 01:05:48,160
cool things you can do with page tables

1775
01:05:48,160 --> 01:05:50,559
you can map a physical address twice

1776
01:05:50,559 --> 01:05:53,440
you cannot map a physical address uh you

1777
01:05:53,440 --> 01:05:54,799
know it can be one-to-one mapping

1778
01:05:54,799 --> 01:05:56,960
one-to-many mapping many-to-one mapping

1779
01:05:56,960 --> 01:05:59,680
all that kind of stuff is possible xv6

1780
01:05:59,680 --> 01:06:00,720
doesn't really

1781
01:06:00,720 --> 01:06:02,160
use many of them but there's a couple

1782
01:06:02,160 --> 01:06:04,480
places we use those tricks and

1783
01:06:04,480 --> 01:06:06,000
the stack and the guard page is one

1784
01:06:06,000 --> 01:06:07,839
example of one of the cool trick that

1785
01:06:07,839 --> 01:06:10,319
you know xv6 uses mostly to track down

1786
01:06:10,319 --> 01:06:12,720
bugs

1787
01:06:12,720 --> 01:06:14,160
the second thing i wanted to mention is

1788
01:06:14,160 --> 01:06:16,480
that the permissions

1789
01:06:16,480 --> 01:06:18,880
so for example the kernel text the pages

1790
01:06:18,880 --> 01:06:20,319
for the kernel text are mapped

1791
01:06:20,319 --> 01:06:22,880
read nx meaning you can read it and

1792
01:06:22,880 --> 01:06:23,760
execute it

1793
01:06:23,760 --> 01:06:25,599
but you cannot write the kernel text and

1794
01:06:25,599 --> 01:06:27,760
again this is basically the void

1795
01:06:27,760 --> 01:06:29,839
box so that we catch them early kernel

1796
01:06:29,839 --> 01:06:31,520
data of course needs to be able to be

1797
01:06:31,520 --> 01:06:32,160
written to

1798
01:06:32,160 --> 01:06:34,640
and so it has is mapped read write but

1799
01:06:34,640 --> 01:06:36,799
you cannot execute

1800
01:06:36,799 --> 01:06:41,039
out of kernel data pages instructions

1801
01:06:41,039 --> 01:06:46,000
so the xbit is not set

1802
01:06:46,000 --> 01:06:49,440
it all make sense uh i skipped one or

1803
01:06:49,440 --> 01:06:50,480
two questions so if

1804
01:06:50,480 --> 01:06:51,760
these questions are still not answered

1805
01:06:51,760 --> 01:06:55,670
you know please ask them

1806
01:06:55,680 --> 01:06:58,799
we have a question in the chat um do we

1807
01:06:58,799 --> 01:06:59,520
have multiple

1808
01:06:59,520 --> 01:07:01,359
kernel stacks for different processes

1809
01:07:01,359 --> 01:07:02,559
like will we have n

1810
01:07:02,559 --> 01:07:06,799
k stacks for n processes answers yes

1811
01:07:06,799 --> 01:07:08,960
so every process every user process has

1812
01:07:08,960 --> 01:07:13,029
a corresponding kernel stack

1813
01:07:13,039 --> 01:07:17,270
and we'll see that in a little bit later

1814
01:07:17,280 --> 01:07:20,640
okay okay so let me uh

1815
01:07:20,640 --> 01:07:24,000
uh samir go ahead um

1816
01:07:24,000 --> 01:07:27,119
so what the virtual memory of another

1817
01:07:27,119 --> 01:07:29,680
application mapped to somewhere in the

1818
01:07:29,680 --> 01:07:31,599
physical memory in the unused space

1819
01:07:31,599 --> 01:07:35,280
or yes uh very good point so there's

1820
01:07:35,280 --> 01:07:37,440
a bunch of physical memory correct

1821
01:07:37,440 --> 01:07:39,359
here's free memory

1822
01:07:39,359 --> 01:07:42,559
uh and that's free memory year two right

1823
01:07:42,559 --> 01:07:45,280
uh and uh we use that or xpc it uses

1824
01:07:45,280 --> 01:07:47,039
that free memory to basically store

1825
01:07:47,039 --> 01:07:50,240
pages of page tables of user processes

1826
01:07:50,240 --> 01:07:53,280
as well as you know the text and data of

1827
01:07:53,280 --> 01:07:56,640
user level processes and if we run many

1828
01:07:56,640 --> 01:07:58,160
many many usual level processes at some

1829
01:07:58,160 --> 01:07:59,599
point we'll run out of free memory

1830
01:07:59,599 --> 01:08:01,599
and then basically fork or exact will

1831
01:08:01,599 --> 01:08:04,880
return an error

1832
01:08:04,880 --> 01:08:06,720
but that means that the virtual space

1833
01:08:06,720 --> 01:08:09,359
for processes are much smaller than the

1834
01:08:09,359 --> 01:08:10,880
virtual space for

1835
01:08:10,880 --> 01:08:13,359
the kernel right well the virtual stages

1836
01:08:13,359 --> 01:08:14,640
is the same

1837
01:08:14,640 --> 01:08:17,040
as the same you know size in principle

1838
01:08:17,040 --> 01:08:22,709
but it will be less populated

1839
01:08:22,719 --> 01:08:24,480
let me uh let's let's look at some code

1840
01:08:24,480 --> 01:08:25,600
and i think that all the stuff becomes a

1841
01:08:25,600 --> 01:08:28,000
little bit more clear

1842
01:08:28,000 --> 01:08:31,520
uh just one small thing um is so given

1843
01:08:31,520 --> 01:08:32,080
that

1844
01:08:32,080 --> 01:08:34,960
um a lot of the like each process has a

1845
01:08:34,960 --> 01:08:37,279
big part of the memory mapped the same

1846
01:08:37,279 --> 01:08:38,319
location

1847
01:08:38,319 --> 01:08:41,279
is that optimized by like consolidating

1848
01:08:41,279 --> 01:08:41,600
in

1849
01:08:41,600 --> 01:08:44,480
that into one place that mapping or no

1850
01:08:44,480 --> 01:08:44,799
because

1851
01:08:44,799 --> 01:08:47,839
you could uh xp6 does not do that uh

1852
01:08:47,839 --> 01:08:49,679
but like one of the challenge exercises

1853
01:08:49,679 --> 01:08:51,679
in the page table app is to actually

1854
01:08:51,679 --> 01:08:52,080
implement

1855
01:08:52,080 --> 01:08:55,759
that let's see and the real operating

1856
01:08:55,759 --> 01:08:58,630
system would do that

1857
01:08:58,640 --> 01:09:02,159
yeah that makes sense very good question

1858
01:09:02,159 --> 01:09:03,600
and i think you get a sense of like what

1859
01:09:03,600 --> 01:09:04,880
all kinds of things are possible once

1860
01:09:04,880 --> 01:09:08,789
you have page tables

1861
01:09:08,799 --> 01:09:12,719
okay so let's do the usual thing

1862
01:09:12,719 --> 01:09:15,520
boot our xv6 again and again you know

1863
01:09:15,520 --> 01:09:16,960
qmu is just basically implementing the

1864
01:09:16,960 --> 01:09:19,349
board

1865
01:09:19,359 --> 01:09:27,139
and you know let's oops

1866
01:09:27,149 --> 01:09:29,759
[Music]

1867
01:09:29,759 --> 01:09:32,640
so last time we looked at uh how the

1868
01:09:32,640 --> 01:09:34,159
booting happens correct and then we got

1869
01:09:34,159 --> 01:09:35,600
to main and then basically one of the

1870
01:09:35,600 --> 01:09:36,239
things that

1871
01:09:36,239 --> 01:09:40,000
uh uh the kernel uh when

1872
01:09:40,000 --> 01:09:41,279
one of the functions is called called

1873
01:09:41,279 --> 01:09:43,040
kva minute and that actually sets up the

1874
01:09:43,040 --> 01:09:43,839
address space

1875
01:09:43,839 --> 01:09:46,239
for the kernel and so we saw in the

1876
01:09:46,239 --> 01:09:47,839
picture or in the previous slide what

1877
01:09:47,839 --> 01:09:48,159
that

1878
01:09:48,159 --> 01:09:50,480
you know looks like and here we can see

1879
01:09:50,480 --> 01:09:52,159
seeing code how it actually is being set

1880
01:09:52,159 --> 01:09:54,390
up

1881
01:09:54,400 --> 01:09:58,390
uh

1882
01:09:58,400 --> 01:10:02,400
and why hold on something is not going

1883
01:10:02,400 --> 01:10:05,840
as i wanted to am i in the right

1884
01:10:05,840 --> 01:10:10,950
directories

1885
01:10:10,960 --> 01:10:12,719
hold on a second here while i'm trying

1886
01:10:12,719 --> 01:10:16,560
to sort out my problems

1887
01:10:16,560 --> 01:10:21,350
that is good

1888
01:10:21,360 --> 01:10:24,480
and in the right directories yeah

1889
01:10:24,480 --> 01:10:27,920
okay gdp

1890
01:10:27,920 --> 01:10:29,360
and let's have a break from the main

1891
01:10:29,360 --> 01:10:31,040
just to make sure

1892
01:10:31,040 --> 01:10:35,040
good and then i set a breakpoint at kvm

1893
01:10:35,040 --> 01:10:37,360
in it actually i can just stack to it

1894
01:10:37,360 --> 01:10:38,719
now

1895
01:10:38,719 --> 01:10:41,199
next console in it greendev in it you

1896
01:10:41,199 --> 01:10:43,280
know we shot it before

1897
01:10:43,280 --> 01:10:47,030
uh physical memory allocator

1898
01:10:47,040 --> 01:10:51,030
and

1899
01:10:51,040 --> 01:10:52,880
now something happens that i'm not

1900
01:10:52,880 --> 01:10:55,560
expecting

1901
01:10:55,570 --> 01:10:57,600
[Music]

1902
01:10:57,600 --> 01:11:02,470
what is going on

1903
01:11:02,480 --> 01:11:03,920
we're gonna run this right before

1904
01:11:03,920 --> 01:11:05,520
lecture ah here that's what's going on

1905
01:11:05,520 --> 01:11:06,719
that actually is printing

1906
01:11:06,719 --> 01:11:10,239
uh okay um

1907
01:11:10,239 --> 01:11:12,560
huh interesting okay one more time see

1908
01:11:12,560 --> 01:11:14,320
if i can get

1909
01:11:14,320 --> 01:11:28,870
lucky more looks

1910
01:11:28,880 --> 01:11:32,719
continue and hopefully it will get there

1911
01:11:32,719 --> 01:11:33,840
it's going to wait a little bit okay

1912
01:11:33,840 --> 01:11:35,760
great we're at the kvm unit

1913
01:11:35,760 --> 01:11:37,360
so basically we're now at this function

1914
01:11:37,360 --> 01:11:39,600
here on the right side in the emacs

1915
01:11:39,600 --> 01:11:40,000
buffer

1916
01:11:40,000 --> 01:11:45,030
you can see it and

1917
01:11:45,040 --> 01:11:47,679
i think i modified the function slightly

1918
01:11:47,679 --> 01:11:53,110
i hope i did

1919
01:11:53,120 --> 01:11:56,400
i think i did well we'll see um and what

1920
01:11:56,400 --> 01:11:57,040
we're going to do is

1921
01:11:57,040 --> 01:11:58,719
again we're going to walk step into that

1922
01:11:58,719 --> 01:12:00,159
function

1923
01:12:00,159 --> 01:12:02,159
uh it'll give me the layout split it's

1924
01:12:02,159 --> 01:12:03,600
easier to see

1925
01:12:03,600 --> 01:12:04,880
and that's the first thing that you can

1926
01:12:04,880 --> 01:12:06,159
see is actually the kernel actually

1927
01:12:06,159 --> 01:12:08,080
allocates a physical page for the top

1928
01:12:08,080 --> 01:12:10,159
level page directory

1929
01:12:10,159 --> 01:12:13,199
and then it zeros it out so that all the

1930
01:12:13,199 --> 01:12:15,280
pte entries are zero

1931
01:12:15,280 --> 01:12:17,520
and then basically it starts mapping in

1932
01:12:17,520 --> 01:12:18,960
every

1933
01:12:18,960 --> 01:12:22,159
device i o device one by one and so for

1934
01:12:22,159 --> 01:12:23,760
example the uart0

1935
01:12:23,760 --> 01:12:25,360
it basically starts mapping and maps

1936
01:12:25,360 --> 01:12:27,199
that into the kernel

1937
01:12:27,199 --> 01:12:29,520
address space and so we can look at a

1938
01:12:29,520 --> 01:12:31,199
file called mem layout

1939
01:12:31,199 --> 01:12:34,080
this basically translates a page 31 that

1940
01:12:34,080 --> 01:12:35,840
i showed you from the document into a

1941
01:12:35,840 --> 01:12:37,920
bunch of constants that we're using

1942
01:12:37,920 --> 01:12:39,520
and so for example here it says what the

1943
01:12:39,520 --> 01:12:44,080
address of you ox1000 is

1944
01:12:44,080 --> 01:12:47,920
uh over the year it is and so

1945
01:12:47,920 --> 01:12:50,960
uh you know we can basically uh map it

1946
01:12:50,960 --> 01:12:52,800
into the address space by calling this

1947
01:12:52,800 --> 01:12:54,800
function kvmf which i will look in in a

1948
01:12:54,800 --> 01:12:56,000
second

1949
01:12:56,000 --> 01:13:00,239
and then in the first exercise of

1950
01:13:00,239 --> 01:13:02,239
the page table app you are asked to

1951
01:13:02,239 --> 01:13:04,560
implement a function called vm print

1952
01:13:04,560 --> 01:13:07,120
and i implemented it too and we're going

1953
01:13:07,120 --> 01:13:08,560
to step over it and we'll see

1954
01:13:08,560 --> 01:13:11,920
basically uh the page tables

1955
01:13:11,920 --> 01:13:14,320
uh the kernel page table as it is set up

1956
01:13:14,320 --> 01:13:16,960
after that one call to tpm map so i'm

1957
01:13:16,960 --> 01:13:18,080
going to do that

1958
01:13:18,080 --> 01:13:20,239
and boom and it prints out something and

1959
01:13:20,239 --> 01:13:21,199
so we're going to look at a little bit

1960
01:13:21,199 --> 01:13:22,880
of the output here so here's the page

1961
01:13:22,880 --> 01:13:24,800
table that is the

1962
01:13:24,800 --> 01:13:28,080
physical address of the top level

1963
01:13:28,080 --> 01:13:30,719
uh page directory so the thing that

1964
01:13:30,719 --> 01:13:32,000
actually sits in satp

1965
01:13:32,000 --> 01:13:35,120
or will sit in satp and then

1966
01:13:35,120 --> 01:13:38,000
you know we have entry 0 of the top

1967
01:13:38,000 --> 01:13:39,280
level page directly has

1968
01:13:39,280 --> 01:13:43,199
one pte entry in it

1969
01:13:43,199 --> 01:13:45,600
and that is the contains the physical

1970
01:13:45,600 --> 01:13:47,440
address for the middle level page table

1971
01:13:47,440 --> 01:13:48,480
directory

1972
01:13:48,480 --> 01:13:50,400
the middle page table directory has one

1973
01:13:50,400 --> 01:13:52,800
entry namely 128

1974
01:13:52,800 --> 01:13:54,560
and that points to the bottom page table

1975
01:13:54,560 --> 01:13:56,080
directory and the bottom plane table

1976
01:13:56,080 --> 01:13:57,920
directory has the entry then for the

1977
01:13:57,920 --> 01:14:00,400
physical page and you can see indeed

1978
01:14:00,400 --> 01:14:00,960
that the

1979
01:14:00,960 --> 01:14:02,880
physical address you know for that the

1980
01:14:02,880 --> 01:14:04,880
bottom level is ox

1981
01:14:04,880 --> 01:14:08,880
1 0 0 0 corresponding to uh 0.

1982
01:14:08,880 --> 01:14:12,719
so basically virtual address 1 0 0 0

1983
01:14:12,719 --> 01:14:14,560
translates to physical address one one

1984
01:14:14,560 --> 01:14:17,360
one zero zero

1985
01:14:17,360 --> 01:14:18,640
and we can sort of double check that

1986
01:14:18,640 --> 01:14:20,960
this is uh indeed all legit

1987
01:14:20,960 --> 01:14:26,630
right by uh let's take that address

1988
01:14:26,640 --> 01:14:29,520
on that ox one zero zero l and we're

1989
01:14:29,520 --> 01:14:31,679
going to shift to 12.

1990
01:14:31,679 --> 01:14:35,040
um and that should be uh

1991
01:14:35,040 --> 01:14:37,440
you know that gives us the top level 27

1992
01:14:37,440 --> 01:14:38,960
27 bits

1993
01:14:38,960 --> 01:14:41,600
we've shifted nine so i'm going to take

1994
01:14:41,600 --> 01:14:43,920
ox one zero zero

1995
01:14:43,920 --> 01:14:47,760
uh one zero zero zero one zero one more

1996
01:14:47,760 --> 01:14:50,159
and we're gonna shift at nine and print

1997
01:14:50,159 --> 01:14:52,950
that

1998
01:14:52,960 --> 01:14:55,360
and that is ox zero and actually if we

1999
01:14:55,360 --> 01:14:58,159
print ox0 as a decimal decimal number

2000
01:14:58,159 --> 01:15:02,159
it's going to be 128. okay

2001
01:15:02,159 --> 01:15:03,920
so we see you actually sort of you know

2002
01:15:03,920 --> 01:15:05,840
it all sort of makes sense

2003
01:15:05,840 --> 01:15:08,719
we also see i printed out the flags here

2004
01:15:08,719 --> 01:15:09,440
uh

2005
01:15:09,440 --> 01:15:12,239
and you know the bottom level has read

2006
01:15:12,239 --> 01:15:13,040
write

2007
01:15:13,040 --> 01:15:18,400
and uh invalid because valid is one

2008
01:15:18,400 --> 01:15:24,800
any questions about this

2009
01:15:24,800 --> 01:15:28,880
okay so um the kernel basically proceeds

2010
01:15:28,880 --> 01:15:31,600
uh you know doing setting up the whole

2011
01:15:31,600 --> 01:15:33,840
address space in this way

2012
01:15:33,840 --> 01:15:36,400
uh and so we've calls kvn map you know

2013
01:15:36,400 --> 01:15:37,360
for virgil

2014
01:15:37,360 --> 01:15:40,800
for the clint for the click uh maps the

2015
01:15:40,800 --> 01:15:43,360
kernel text maps the kernel memory or

2016
01:15:43,360 --> 01:15:44,400
kernel data

2017
01:15:44,400 --> 01:15:45,840
and then the trampoline page that we'll

2018
01:15:45,840 --> 01:15:47,440
talk about next week

2019
01:15:47,440 --> 01:15:48,960
uh and so in fact you know we can sort

2020
01:15:48,960 --> 01:15:50,800
of single step through this and then

2021
01:15:50,800 --> 01:15:53,120
see what the final page directory looks

2022
01:15:53,120 --> 01:15:54,159
like

2023
01:15:54,159 --> 01:15:57,520
uh next next

2024
01:15:57,520 --> 01:16:00,480
next next basically you know we set the

2025
01:16:00,480 --> 01:16:01,679
trampoline and so now we're going to

2026
01:16:01,679 --> 01:16:04,159
print the complete page table directory

2027
01:16:04,159 --> 01:16:07,440
and you know we see you know basically

2028
01:16:07,440 --> 01:16:10,719
a lot of pte is actually being uh

2029
01:16:10,719 --> 01:16:13,280
set up um and we're not gonna really

2030
01:16:13,280 --> 01:16:14,880
talk about in any detail

2031
01:16:14,880 --> 01:16:16,719
uh but you know basically it fills out

2032
01:16:16,719 --> 01:16:19,040
the page directory

2033
01:16:19,040 --> 01:16:20,560
uh to actually create that virtual

2034
01:16:20,560 --> 01:16:22,320
mapping mapping that we basically saw on

2035
01:16:22,320 --> 01:16:24,800
the previous slide

2036
01:16:24,800 --> 01:16:26,480
when i in fact what i'm going to do next

2037
01:16:26,480 --> 01:16:29,990
is actually much more interesting

2038
01:16:30,000 --> 01:16:33,280
i'm going to yeah i want to go here

2039
01:16:33,280 --> 01:16:34,880
actually i guess maybe i already did

2040
01:16:34,880 --> 01:16:35,280
this

2041
01:16:35,280 --> 01:16:38,400
uh we're 21 no i'm 21 okay so single

2042
01:16:38,400 --> 01:16:38,719
step

2043
01:16:38,719 --> 01:16:42,080
not okay that's too bad i got past that

2044
01:16:42,080 --> 01:16:42,719
but

2045
01:16:42,719 --> 01:16:46,239
basically uh let me

2046
01:16:46,239 --> 01:16:51,110
let me restart this

2047
01:16:51,120 --> 01:16:55,000
and i want to break point at

2048
01:16:55,000 --> 01:17:00,470
kvm in at heart

2049
01:17:00,480 --> 01:17:03,600
and continue

2050
01:17:03,600 --> 01:17:06,800
boom i'm now here at kvm at heart and we

2051
01:17:06,800 --> 01:17:08,239
see here basically

2052
01:17:08,239 --> 01:17:10,400
that we're writing the satp register so

2053
01:17:10,400 --> 01:17:12,480
basically the kernel is going to enable

2054
01:17:12,480 --> 01:17:16,000
uh the page table or the mmu to

2055
01:17:16,000 --> 01:17:17,600
basically start using the page table

2056
01:17:17,600 --> 01:17:19,440
that we just set up

2057
01:17:19,440 --> 01:17:23,199
and one uh interesting question

2058
01:17:23,199 --> 01:17:26,480
okay so i do have layout split again

2059
01:17:26,480 --> 01:17:31,280
so somewhere here correct is going to be

2060
01:17:31,280 --> 01:17:34,960
here's the instruction uh and

2061
01:17:34,960 --> 01:17:38,719
so once so something really dramatic

2062
01:17:38,719 --> 01:17:39,600
happens

2063
01:17:39,600 --> 01:17:43,040
after executing this instruction

2064
01:17:43,040 --> 01:17:45,199
once i say you know i can't see the

2065
01:17:45,199 --> 01:17:46,640
assembly instruction exactly but there

2066
01:17:46,640 --> 01:17:47,760
are there is this

2067
01:17:47,760 --> 01:17:50,080
this extent once this instruction is

2068
01:17:50,080 --> 01:17:51,679
executed what will happen with the next

2069
01:17:51,679 --> 01:17:58,320
address that's being translated

2070
01:17:58,320 --> 01:18:00,080
well at the point that we execute this

2071
01:18:00,080 --> 01:18:01,440
instruction before

2072
01:18:01,440 --> 01:18:03,360
executing this instruction there's no

2073
01:18:03,360 --> 01:18:04,960
page tables enabled yet so no

2074
01:18:04,960 --> 01:18:06,320
translation happens

2075
01:18:06,320 --> 01:18:08,080
but the next and then the program

2076
01:18:08,080 --> 01:18:10,159
counter is updated by four

2077
01:18:10,159 --> 01:18:11,360
and then the next instruction are

2078
01:18:11,360 --> 01:18:13,120
executed and the program counter will be

2079
01:18:13,120 --> 01:18:15,199
translated using the virtual page

2080
01:18:15,199 --> 01:18:18,400
page table memory and so this is a

2081
01:18:18,400 --> 01:18:19,679
you know the way to think about this

2082
01:18:19,679 --> 01:18:21,520
this is a dramatic moment

2083
01:18:21,520 --> 01:18:23,760
because basically the whole address

2084
01:18:23,760 --> 01:18:25,440
translation is starting to enable and

2085
01:18:25,440 --> 01:18:26,000
every address

2086
01:18:26,000 --> 01:18:27,440
needs to know maybe potentially

2087
01:18:27,440 --> 01:18:29,520
something different

2088
01:18:29,520 --> 01:18:30,800
right because before we're running

2089
01:18:30,800 --> 01:18:32,320
there's like the physical addresses then

2090
01:18:32,320 --> 01:18:33,600
the page table henderson

2091
01:18:33,600 --> 01:18:34,960
and whatever is in the mapping that is

2092
01:18:34,960 --> 01:18:38,800
now the new meaning of a virtual dress

2093
01:18:38,800 --> 01:18:40,719
and this is how this works out you know

2094
01:18:40,719 --> 01:18:41,920
the fact that this actually works out is

2095
01:18:41,920 --> 01:18:43,920
sort of remarkable because like the next

2096
01:18:43,920 --> 01:18:46,080
instruction the next value is a virtual

2097
01:18:46,080 --> 01:18:49,199
address and not a physical address

2098
01:18:49,199 --> 01:18:50,239
next instruction is going to be this

2099
01:18:50,239 --> 01:18:52,640
whatever ox1110

2100
01:18:52,640 --> 01:18:55,760
and why does this work out

2101
01:18:55,760 --> 01:18:57,440
well the reason works out is because the

2102
01:18:57,440 --> 01:18:59,199
kernel is set up with an identity page

2103
01:18:59,199 --> 01:18:59,679
mapping

2104
01:18:59,679 --> 01:19:02,880
so after we enable the virtual paging

2105
01:19:02,880 --> 01:19:03,679
hardware

2106
01:19:03,679 --> 01:19:05,360
we actually you know this translation

2107
01:19:05,360 --> 01:19:07,120
will translate again to the same

2108
01:19:07,120 --> 01:19:08,159
physical address

2109
01:19:08,159 --> 01:19:09,920
and so indeed you know we'll actually

2110
01:19:09,920 --> 01:19:11,199
end up you know

2111
01:19:11,199 --> 01:19:13,120
executing the right instruction because

2112
01:19:13,120 --> 01:19:14,719
that's actually exactly the instructions

2113
01:19:14,719 --> 01:19:16,080
the memory location that the

2114
01:19:16,080 --> 01:19:19,120
virtual hardware is programmed for so

2115
01:19:19,120 --> 01:19:22,800
does this make sense

2116
01:19:22,800 --> 01:19:25,199
again one reason why programming with

2117
01:19:25,199 --> 01:19:26,800
virtual memory is difficult

2118
01:19:26,800 --> 01:19:28,480
is because once you execute one of these

2119
01:19:28,480 --> 01:19:29,920
satp instructions

2120
01:19:29,920 --> 01:19:33,040
you know you load a page table in the

2121
01:19:33,040 --> 01:19:35,440
satp register your world completely

2122
01:19:35,440 --> 01:19:36,640
changes

2123
01:19:36,640 --> 01:19:38,800
and every address is now translated with

2124
01:19:38,800 --> 01:19:41,440
the pay stable that you set up

2125
01:19:41,440 --> 01:19:43,040
and so what happens if the page table

2126
01:19:43,040 --> 01:19:44,800
set up incorrectly

2127
01:19:44,800 --> 01:19:53,590
what would you what might happen

2128
01:19:53,600 --> 01:19:56,080
anybody who wants to say that answer it

2129
01:19:56,080 --> 01:20:00,390
or answer it in the chat either way

2130
01:20:00,400 --> 01:20:03,120
you could override kernel data yeah you

2131
01:20:03,120 --> 01:20:04,560
could overwrite kernel data what else

2132
01:20:04,560 --> 01:20:06,080
could happen yeah page fault you know

2133
01:20:06,080 --> 01:20:07,600
basically the

2134
01:20:07,600 --> 01:20:09,920
the mapping may be uh incorrect and

2135
01:20:09,920 --> 01:20:11,600
basically the dress can't be translated

2136
01:20:11,600 --> 01:20:12,960
at all and so the kernel can

2137
01:20:12,960 --> 01:20:14,639
you know the heart rate won't do it and

2138
01:20:14,639 --> 01:20:18,639
use the kernel just stops it panics

2139
01:20:18,639 --> 01:20:21,600
does that make sense so if you get a bug

2140
01:20:21,600 --> 01:20:23,440
in your page tables

2141
01:20:23,440 --> 01:20:26,159
you know you're going to see bizarre

2142
01:20:26,159 --> 01:20:26,880
errors

2143
01:20:26,880 --> 01:20:29,920
or crashes and so one reason that for

2144
01:20:29,920 --> 01:20:31,120
example the next lab

2145
01:20:31,120 --> 01:20:32,960
uh the page table app that we'll hand

2146
01:20:32,960 --> 01:20:34,880
out or release tonight

2147
01:20:34,880 --> 01:20:36,400
is going to be hard is because those

2148
01:20:36,400 --> 01:20:38,080
kind of bugs will show up

2149
01:20:38,080 --> 01:20:39,199
and you're going to be not careful

2150
01:20:39,199 --> 01:20:41,120
enough or you haven't fully internalized

2151
01:20:41,120 --> 01:20:42,480
some aspect yet

2152
01:20:42,480 --> 01:20:43,920
and you're basically going to get a

2153
01:20:43,920 --> 01:20:46,080
kernel crash and you're going to have a

2154
01:20:46,080 --> 01:20:47,520
hard time or you know it will take a

2155
01:20:47,520 --> 01:20:49,199
little bit of time and energy and

2156
01:20:49,199 --> 01:20:51,199
detective work to basically track down

2157
01:20:51,199 --> 01:20:53,360
why that happened

2158
01:20:53,360 --> 01:20:56,239
and that's just the that's just part of

2159
01:20:56,239 --> 01:20:58,400
like programming virtual memory

2160
01:20:58,400 --> 01:21:00,239
because it's such a powerful primitive

2161
01:21:00,239 --> 01:21:01,840
you know if you get it wrong you're also

2162
01:21:01,840 --> 01:21:03,360
going to have

2163
01:21:03,360 --> 01:21:08,070
powerful consequences

2164
01:21:08,080 --> 01:21:09,520
yet the other hand is a great amount of

2165
01:21:09,520 --> 01:21:11,199
fun so i don't want to end on a negative

2166
01:21:11,199 --> 01:21:13,440
note

2167
01:21:13,440 --> 01:21:15,120
but all that will give you sort of a

2168
01:21:15,120 --> 01:21:16,639
real understanding of actually what

2169
01:21:16,639 --> 01:21:17,840
really virtual memory is

2170
01:21:17,840 --> 01:21:20,800
and what it can do okay i think i'm

2171
01:21:20,800 --> 01:21:22,320
running out of time so i'm going to stop

2172
01:21:22,320 --> 01:21:22,960
here

2173
01:21:22,960 --> 01:21:24,639
so people have time to go to the next

2174
01:21:24,639 --> 01:21:26,000
class or next activity

2175
01:21:26,000 --> 01:21:28,239
uh but if you have any questions left uh

2176
01:21:28,239 --> 01:21:29,360
you know please hang on

2177
01:21:29,360 --> 01:21:32,480
and ask them and

2178
01:21:32,480 --> 01:21:36,000
we'll see you on monday and good luck

2179
01:21:36,000 --> 01:21:36,639
with

2180
01:21:36,639 --> 01:21:40,870
finishing the cisco lab

2181
01:21:40,880 --> 01:21:44,320
um hi i have a question about walk

2182
01:21:44,320 --> 01:21:47,679
um so it says and in the code it returns

2183
01:21:47,679 --> 01:21:48,800
the

2184
01:21:48,800 --> 01:21:52,400
like the first tables on pte

2185
01:21:52,400 --> 01:21:55,440
yeah right um but

2186
01:21:55,440 --> 01:21:57,120
but how does it work then like the other

2187
01:21:57,120 --> 01:21:59,440
functions when they expect

2188
01:21:59,440 --> 01:22:02,639
the actual pte that like the physical

2189
01:22:02,639 --> 01:22:04,320
address

2190
01:22:04,320 --> 01:22:07,600
like yeah so basically this

2191
01:22:07,600 --> 01:22:11,120
returns the pt entry in the page table

2192
01:22:11,120 --> 01:22:12,080
correct

2193
01:22:12,080 --> 01:22:13,679
and the kernel can read and write page

2194
01:22:13,679 --> 01:22:15,760
table entries

2195
01:22:15,760 --> 01:22:18,320
and so now you can stick values into the

2196
01:22:18,320 --> 01:22:21,110
pte

2197
01:22:21,120 --> 01:22:23,440
and so maybe i can draw a picture if

2198
01:22:23,440 --> 01:22:24,880
that is helpful

2199
01:22:24,880 --> 01:22:35,750
um let's see

2200
01:22:35,760 --> 01:22:45,030
so basically we have a page directory

2201
01:22:45,040 --> 01:22:48,560
and you know this walk code so the page

2202
01:22:48,560 --> 01:22:50,960
directory has 512

2203
01:22:50,960 --> 01:22:57,030
ptes in it

2204
01:22:57,040 --> 01:22:59,920
here's zero here's five and eleven and

2205
01:22:59,920 --> 01:23:01,679
basically what the function does

2206
01:23:01,679 --> 01:23:04,840
it returns a pointer to one of these

2207
01:23:04,840 --> 01:23:06,880
pkes and so that's just a virtual

2208
01:23:06,880 --> 01:23:07,520
address

2209
01:23:07,520 --> 01:23:08,880
and it just points to that particular

2210
01:23:08,880 --> 01:23:11,760
pte and now the kernel can

2211
01:23:11,760 --> 01:23:13,840
you know manipulate that pte by like

2212
01:23:13,840 --> 01:23:16,000
whatever writing values to it

2213
01:23:16,000 --> 01:23:19,120
like some physical address maybe

2214
01:23:19,120 --> 01:23:20,560
with some permissions ordered into it

2215
01:23:20,560 --> 01:23:23,760
for the top bottom 10 bits

2216
01:23:23,760 --> 01:23:25,199
and then that basically updates the page

2217
01:23:25,199 --> 01:23:27,040
sample directory and then later on

2218
01:23:27,040 --> 01:23:30,239
when you load that into satp now that

2219
01:23:30,239 --> 01:23:30,719
effect

2220
01:23:30,719 --> 01:23:35,199
that that change will go into effect

2221
01:23:35,199 --> 01:23:37,760
does that make sense yeah that makes

2222
01:23:37,760 --> 01:23:39,440
sense i guess i was just confused like

2223
01:23:39,440 --> 01:23:41,760
why does it do the work of going all the

2224
01:23:41,760 --> 01:23:42,639
way to the

2225
01:23:42,639 --> 01:23:46,000
third page table and then only return

2226
01:23:46,000 --> 01:23:48,880
the first pte no the return is actually

2227
01:23:48,880 --> 01:23:49,360
the

2228
01:23:49,360 --> 01:23:52,239
the bottom one all right actually but

2229
01:23:52,239 --> 01:23:52,639
let me

2230
01:23:52,639 --> 01:23:56,560
be careful uh if you notice it goes

2231
01:23:56,560 --> 01:23:58,159
through the end levels so it starts at

2232
01:23:58,159 --> 01:23:59,600
level two and then it goes to level one

2233
01:23:59,600 --> 01:24:01,760
then it goes to level zero

2234
01:24:01,760 --> 01:24:05,120
if uh the alkbit is set

2235
01:24:05,120 --> 01:24:07,520
and and level doesn't exist it will

2236
01:24:07,520 --> 01:24:09,120
create the intermediate page default

2237
01:24:09,120 --> 01:24:10,480
directory

2238
01:24:10,480 --> 01:24:12,560
and zero it out and then keep going in

2239
01:24:12,560 --> 01:24:13,679
the loop

2240
01:24:13,679 --> 01:24:16,560
so in what you always end up on the

2241
01:24:16,560 --> 01:24:18,480
bottom pte

2242
01:24:18,480 --> 01:24:21,679
if alex is not set you stop at the first

2243
01:24:21,679 --> 01:24:25,510
pte that doesn't have a value

2244
01:24:25,520 --> 01:24:26,880
okay that makes sense so this is the

2245
01:24:26,880 --> 01:24:28,560
last one the actual

2246
01:24:28,560 --> 01:24:36,790
one that gonna have okay okay thank you

2247
01:24:36,800 --> 01:24:40,709
any other questions

2248
01:24:40,719 --> 01:24:43,760
um so i have a question uh basically

2249
01:24:43,760 --> 01:24:45,120
everything made sense

2250
01:24:45,120 --> 01:24:48,320
until we mapped the virtual addresses to

2251
01:24:48,320 --> 01:24:51,040
of the kernel to the physical addresses

2252
01:24:51,040 --> 01:24:53,750
um

2253
01:24:53,760 --> 01:24:56,400
so my understanding is that each process

2254
01:24:56,400 --> 01:24:58,320
will have its own page table which is

2255
01:24:58,320 --> 01:24:59,840
also a three level tree

2256
01:24:59,840 --> 01:25:02,400
which maps its virtual addresses to

2257
01:25:02,400 --> 01:25:03,600
physical addresses

2258
01:25:03,600 --> 01:25:05,679
but then when we map the kernel address

2259
01:25:05,679 --> 01:25:07,360
the kernel virtual addresses to physical

2260
01:25:07,360 --> 01:25:08,000
addresses

2261
01:25:08,000 --> 01:25:09,679
i don't think we accounted for the

2262
01:25:09,679 --> 01:25:12,480
actual tree of the

2263
01:25:12,480 --> 01:25:15,360
virtual addresses of the kernel or where

2264
01:25:15,360 --> 01:25:16,719
other processes

2265
01:25:16,719 --> 01:25:20,880
will have their virtual addresses and

2266
01:25:20,880 --> 01:25:23,840
i'm sorry virtual addresses um like the

2267
01:25:23,840 --> 01:25:25,040
page table trees

2268
01:25:25,040 --> 01:25:27,840
and whatever the page table tree points

2269
01:25:27,840 --> 01:25:28,320
at

2270
01:25:28,320 --> 01:25:31,520
in the physical memory yeah so so

2271
01:25:31,520 --> 01:25:33,280
so you know you're back so this is the

2272
01:25:33,280 --> 01:25:34,639
slide with the kernel

2273
01:25:34,639 --> 01:25:37,280
uh uh address space the virtual kernel

2274
01:25:37,280 --> 01:25:38,480
address space

2275
01:25:38,480 --> 01:25:41,360
and so when the kernel allocates a proc

2276
01:25:41,360 --> 01:25:42,159
uh

2277
01:25:42,159 --> 01:25:44,239
and the page tables for that particular

2278
01:25:44,239 --> 01:25:46,239
process they're going to be allocated

2279
01:25:46,239 --> 01:25:48,400
out of memory here you know memory

2280
01:25:48,400 --> 01:25:50,800
that's not being used yet

2281
01:25:50,800 --> 01:25:54,159
and the kernel is going to program uh

2282
01:25:54,159 --> 01:25:56,000
we will probably allocate a couple pages

2283
01:25:56,000 --> 01:25:58,239
for the page table of the user level

2284
01:25:58,239 --> 01:26:01,360
process and we'll fill in the ptes

2285
01:26:01,360 --> 01:26:03,679
and then some point when the kernel runs

2286
01:26:03,679 --> 01:26:04,800
that process

2287
01:26:04,800 --> 01:26:08,159
it will load the root

2288
01:26:08,159 --> 01:26:10,639
physical address for those pages that it

2289
01:26:10,639 --> 01:26:12,639
allocated for that page table or

2290
01:26:12,639 --> 01:26:14,080
basically for the page table then built

2291
01:26:14,080 --> 01:26:16,560
into the satp register

2292
01:26:16,560 --> 01:26:20,480
and at that point the processor will run

2293
01:26:20,480 --> 01:26:22,239
with the virtual address space that the

2294
01:26:22,239 --> 01:26:23,920
kernel constructed for that particular

2295
01:26:23,920 --> 01:26:27,030
process

2296
01:26:27,040 --> 01:26:29,679
uh so the kernel give up some of its

2297
01:26:29,679 --> 01:26:31,199
memory

2298
01:26:31,199 --> 01:26:33,360
for processes and then but then the

2299
01:26:33,360 --> 01:26:34,880
virtual space

2300
01:26:34,880 --> 01:26:38,639
in theory is as big for the process as

2301
01:26:38,639 --> 01:26:41,280
the current but in reality it's really

2302
01:26:41,280 --> 01:26:42,320
not

2303
01:26:42,320 --> 01:26:44,639
yeah for example yes here's a picture

2304
01:26:44,639 --> 01:26:46,000
with the layout of a virtual address

2305
01:26:46,000 --> 01:26:47,440
space over user level process

2306
01:26:47,440 --> 01:26:51,910
and again it goes from zero to max va

2307
01:26:51,920 --> 01:26:54,719
in the same way as the kernel address

2308
01:26:54,719 --> 01:26:55,600
space does

2309
01:26:55,600 --> 01:26:57,040
and it just basically has his own set of

2310
01:26:57,040 --> 01:26:58,639
page tables to map those

2311
01:26:58,639 --> 01:27:01,280
do do do translation that the kernel set

2312
01:27:01,280 --> 01:27:03,199
up

2313
01:27:03,199 --> 01:27:05,440
but we can't actually use all of the max

2314
01:27:05,440 --> 01:27:07,920
va virtually no we cannot

2315
01:27:07,920 --> 01:27:11,510
we run out of memory

2316
01:27:11,520 --> 01:27:13,280
so many of the processes are much much

2317
01:27:13,280 --> 01:27:14,880
smaller correct than

2318
01:27:14,880 --> 01:27:19,760
all of the virtual address space

2319
01:27:19,760 --> 01:27:23,110
i see thinking

2320
01:27:23,120 --> 01:27:26,400
i've got a quick question yep um

2321
01:27:26,400 --> 01:27:28,880
could you go back to the walk code yeah

2322
01:27:28,880 --> 01:27:31,440
yeah yeah absolutely

2323
01:27:31,440 --> 01:27:32,960
and it's like one of my favorite

2324
01:27:32,960 --> 01:27:35,280
functions

2325
01:27:35,280 --> 01:27:38,800
uh so i guess um i think one thing i'm

2326
01:27:38,800 --> 01:27:40,159
confused about is

2327
01:27:40,159 --> 01:27:42,880
after you write to the set p register

2328
01:27:42,880 --> 01:27:44,239
can the colonel even

2329
01:27:44,239 --> 01:27:46,880
access physical addresses directly so it

2330
01:27:46,880 --> 01:27:48,320
looks like in the code that it's

2331
01:27:48,320 --> 01:27:49,760
converting you know like page tables

2332
01:27:49,760 --> 01:27:51,520
being set to a physical address but if

2333
01:27:51,520 --> 01:27:53,840
sap is set

2334
01:27:53,840 --> 01:27:56,159
um won't that be interpreted as a

2335
01:27:56,159 --> 01:27:57,920
virtual address

2336
01:27:57,920 --> 01:28:00,960
yeah uh so uh

2337
01:28:00,960 --> 01:28:04,000
okay so let's look at uh whatever the

2338
01:28:04,000 --> 01:28:09,669
heart in it

2339
01:28:09,679 --> 01:28:13,679
so there's kvm so built in the kernel

2340
01:28:13,679 --> 01:28:15,040
address space

2341
01:28:15,040 --> 01:28:19,840
uh the kernel page table uh

2342
01:28:19,840 --> 01:28:22,480
initially is a ver physical you know

2343
01:28:22,480 --> 01:28:24,800
there's an address it's translated to

2344
01:28:24,800 --> 01:28:26,719
uh a physical address and that's

2345
01:28:26,719 --> 01:28:31,189
actually written into the satp register

2346
01:28:31,199 --> 01:28:32,880
and at that point you know we're running

2347
01:28:32,880 --> 01:28:34,719
with the address space that we

2348
01:28:34,719 --> 01:28:35,679
constructed

2349
01:28:35,679 --> 01:28:37,600
like right before here in this kvm

2350
01:28:37,600 --> 01:28:39,920
minute

2351
01:28:39,920 --> 01:28:42,320
and kvn map is basically nothing else

2352
01:28:42,320 --> 01:28:42,960
than

2353
01:28:42,960 --> 01:28:46,320
calling uh uh walk

2354
01:28:46,320 --> 01:28:48,639
for every address or every page in that

2355
01:28:48,639 --> 01:28:50,320
range

2356
01:28:50,320 --> 01:28:53,600
and so what was your question uh

2357
01:28:53,600 --> 01:28:56,880
um i guess it's does walk still work the

2358
01:28:56,880 --> 01:28:58,639
same way if you call it after

2359
01:28:58,639 --> 01:29:04,550
set p is set yeah why

2360
01:29:04,560 --> 01:29:06,560
yeah why why would it work out the

2361
01:29:06,560 --> 01:29:07,920
reason it will work out is because the

2362
01:29:07,920 --> 01:29:11,679
kernel set up in identity mapping

2363
01:29:11,679 --> 01:29:15,360
uh okay right right

2364
01:29:15,360 --> 01:29:18,480
very important very good question

2365
01:29:18,480 --> 01:29:20,239
like a lot of things just happen to work

2366
01:29:20,239 --> 01:29:21,520
out because actually the identity

2367
01:29:21,520 --> 01:29:24,639
mapping is set up

2368
01:29:24,639 --> 01:29:28,719
i see okay i think that makes sense yeah

2369
01:29:28,719 --> 01:29:32,560
thanks i have a good question

2370
01:29:32,560 --> 01:29:35,840
no um where are the satp registers

2371
01:29:35,840 --> 01:29:36,560
stored for

2372
01:29:36,560 --> 01:29:39,840
all of the processes there's only one

2373
01:29:39,840 --> 01:29:42,000
satp per core

2374
01:29:42,000 --> 01:29:45,040
uh but in every proc structure

2375
01:29:45,040 --> 01:29:48,960
okay in every if you look in proctored h

2376
01:29:48,960 --> 01:29:52,719
uh there is a

2377
01:29:52,719 --> 01:29:56,000
uh uh pointed to the page table here

2378
01:29:56,000 --> 01:29:58,800
here okay that makes sense yep um and

2379
01:29:58,800 --> 01:29:59,440
also

2380
01:29:59,440 --> 01:30:02,880
um with regards to the three uh page

2381
01:30:02,880 --> 01:30:05,760
tables are like the three tables that

2382
01:30:05,760 --> 01:30:06,080
can

2383
01:30:06,080 --> 01:30:07,760
complete the full address and help you

2384
01:30:07,760 --> 01:30:09,520
get a full address for

2385
01:30:09,520 --> 01:30:12,480
um given something um how does how is

2386
01:30:12,480 --> 01:30:13,920
that better i guess than

2387
01:30:13,920 --> 01:30:16,639
than having one giant page table i

2388
01:30:16,639 --> 01:30:18,159
didn't really fully understand that okay

2389
01:30:18,159 --> 01:30:18,719
good good

2390
01:30:18,719 --> 01:30:20,719
there's a good great question the reason

2391
01:30:20,719 --> 01:30:22,159
is is because in the free level page

2392
01:30:22,159 --> 01:30:23,760
table you can leave a lot of entries

2393
01:30:23,760 --> 01:30:25,040
empty

2394
01:30:25,040 --> 01:30:27,840
so for example if you leave the an entry

2395
01:30:27,840 --> 01:30:29,360
in the top level page table

2396
01:30:29,360 --> 01:30:31,600
directly empty you don't have to create

2397
01:30:31,600 --> 01:30:33,120
middle level page tables

2398
01:30:33,120 --> 01:30:35,199
or bottom level page tables at all for

2399
01:30:35,199 --> 01:30:36,560
those entries

2400
01:30:36,560 --> 01:30:38,880
okay and so like this means like a big

2401
01:30:38,880 --> 01:30:39,679
swath

2402
01:30:39,679 --> 01:30:41,120
of the whole virtual address page

2403
01:30:41,120 --> 01:30:44,880
doesn't have to have any mappings at all

2404
01:30:44,880 --> 01:30:46,960
okay okay you don't have the table there

2405
01:30:46,960 --> 01:30:48,960
it just doesn't exist

2406
01:30:48,960 --> 01:30:51,760
see basically allocating these chunks on

2407
01:30:51,760 --> 01:30:52,400
demand

2408
01:30:52,400 --> 01:30:54,239
as opposed to auditing and typing okay

2409
01:30:54,239 --> 01:30:55,760
that makes sense yeah you start out

2410
01:30:55,760 --> 01:30:56,800
basically with three

2411
01:30:56,800 --> 01:30:58,880
page three pages namely one from the top

2412
01:30:58,880 --> 01:31:00,480
level one for the and one intermediate

2413
01:31:00,480 --> 01:31:03,199
and one for a and one bottom level

2414
01:31:03,199 --> 01:31:05,199
and then as you go you create more page

2415
01:31:05,199 --> 01:31:06,800
stable directories

2416
01:31:06,800 --> 01:31:10,239
okay okay cool cool thank you so much

2417
01:31:10,239 --> 01:31:14,560
are you welcome any more questions

2418
01:31:14,560 --> 01:31:17,199
oh sorry i have another one it's really

2419
01:31:17,199 --> 01:31:18,400
really small but

2420
01:31:18,400 --> 01:31:21,600
um in the vm dot c

2421
01:31:21,600 --> 01:31:24,800
online 43 yep or sorry 40

2422
01:31:24,800 --> 01:31:28,719
1 40 yeah um it says that it

2423
01:31:28,719 --> 01:31:32,159
no never nevermind 43. my bad um it says

2424
01:31:32,159 --> 01:31:33,199
physical stop

2425
01:31:33,199 --> 01:31:36,719
minus um un-64 e-text

2426
01:31:36,719 --> 01:31:39,760
but wouldn't that would not go over

2427
01:31:39,760 --> 01:31:43,280
the um i guess the memory that

2428
01:31:43,280 --> 01:31:46,560
we shouldn't touch i don't know if that

2429
01:31:46,560 --> 01:31:47,600
makes sense but

2430
01:31:47,600 --> 01:31:51,120
um wouldn't that go

2431
01:31:51,120 --> 01:31:52,800
i guess i don't i don't understand

2432
01:31:52,800 --> 01:31:55,840
wouldn't i go over free memory

2433
01:31:55,840 --> 01:31:59,840
uh no i don't think so uh

2434
01:31:59,840 --> 01:32:03,679
so current base is ox8800 correct so

2435
01:32:03,679 --> 01:32:04,639
that's the beginning

2436
01:32:04,639 --> 01:32:08,400
of memory uh and the kernel sits there

2437
01:32:08,400 --> 01:32:12,560
and uh basically

2438
01:32:12,560 --> 01:32:16,159
this thing is a size right so e-text is

2439
01:32:16,159 --> 01:32:18,239
the last address of the kernel

2440
01:32:18,239 --> 01:32:19,920
subtract current base that basically

2441
01:32:19,920 --> 01:32:22,800
gives you the size of the kernel

2442
01:32:22,800 --> 01:32:26,480
uh in uh in bytes

2443
01:32:26,480 --> 01:32:28,639
and you know i don't know how much it is

2444
01:32:28,639 --> 01:32:29,840
but the uh

2445
01:32:29,840 --> 01:32:32,239
uh it's like you know 60 or 90 pages or

2446
01:32:32,239 --> 01:32:34,000
something like that

2447
01:32:34,000 --> 01:32:36,480
uh and so this map is basically the text

2448
01:32:36,480 --> 01:32:39,430
part of the kernel

2449
01:32:39,440 --> 01:32:43,280
and uh and there's enough space

2450
01:32:43,280 --> 01:32:45,600
uh there's enough dram you know to map

2451
01:32:45,600 --> 01:32:47,440
that

2452
01:32:47,440 --> 01:32:49,360
the kernel text i'm not sure i'm

2453
01:32:49,360 --> 01:32:51,199
answering your question but

2454
01:32:51,199 --> 01:32:54,159
oh oh i think i think i understand i

2455
01:32:54,159 --> 01:32:54,880
thought that

2456
01:32:54,880 --> 01:32:57,679
attacks starts somewhere else okay i

2457
01:32:57,679 --> 01:32:58,800
think i understand now thank you

2458
01:32:58,800 --> 01:33:00,239
so much is basically the last

2459
01:33:00,239 --> 01:33:01,840
instruction the address of the last

2460
01:33:01,840 --> 01:33:03,679
instruction of the kernel

2461
01:33:03,679 --> 01:33:06,560
okay okay

