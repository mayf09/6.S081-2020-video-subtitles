1
00:00:10,990 --> 00:00:13,220
0,960
Alright.|
好的。|

2
00:00:13,470 --> 00:00:14,760
0,240 240,600 600,720 720,870 870,1290
Good morning or good afternoon
大家早上好，下午好，

3
00:00:14,760 --> 00:00:17,610
0,510 660,1110 1530,2040 2040,2250 2250,2850
everyone,| I'm {like,to} get started,|
|我要开始了，|

4
00:00:17,670 --> 00:00:19,880
0,720 750,1050 1050,1260 1260,1560
can people hear me?|
大家能听到我说话吗？|

5
00:00:20,000 --> 00:00:20,980
0,660
Yep.|
是的。|

6
00:00:20,980 --> 00:00:23,440
0,270 270,420 870,1680 1680,1980 1980,2460
Thank you.| Alright, today, what
谢谢。|好的，今天我想做的是

7
00:00:23,440 --> 00:00:24,700
0,120 120,270 270,360 360,690 690,1260
I'd like to do is|
|

8
00:00:24,940 --> 00:00:26,200
0,750 750,810 810,870 870,1110 1110,1260
give you a chance to
给你们一个机会询问关于 xv6 的问题，

9
00:00:26,200 --> 00:00:27,730
0,420 420,900 900,1170 1170,1380 1380,1530
ask questions about {xv6 -

10
00:00:27,730 --> 00:00:28,990
0,510 510,630 630,840 840,930 930,1260
-}| and about the recent
|以及最近的实验，

11
00:00:28,990 --> 00:00:31,660
0,720 990,1620 1650,1860 1860,2100 2100,2670
labs,| {} in order to
|为了给我们提供一些可以谈论的东西，

12
00:00:31,720 --> 00:00:33,400
0,240 240,330 330,600 600,1050 1200,1680
give us something to talk

13
00:00:33,400 --> 00:00:34,990
0,450 570,1200 1200,1410 1410,1470 1470,1590
about,| I'm going to do
|我会尽可能多地做写入时复制 fork 实验，

14
00:00:34,990 --> 00:00:36,130
0,120 120,330 330,450 450,540 540,1140
as much as I can

15
00:00:36,130 --> 00:00:37,480
0,240 240,780
of the

16
00:00:38,000 --> 00:00:40,340
0,810 840,1530 1530,1680 1680,1950 1950,2340
{} {copy-on-write - -} fork

17
00:00:40,340 --> 00:00:42,110
0,300 300,750 780,1260 1290,1710 1710,1770
lab here,| {} just to
|给我们一些可以考虑的东西，

18
00:00:42,110 --> 00:00:43,730
0,150 150,690 690,1170 1170,1290 1290,1620
give us something to chew

19
00:00:43,730 --> 00:00:45,590
0,300 600,1260 1290,1530 1530,1650 1650,1860
on| and you should feel
|你可以随意问任何问题，

20
00:00:45,590 --> 00:00:46,850
0,330 330,420 420,690 690,840 840,1260
free to ask any questions

21
00:00:46,850 --> 00:00:48,470
0,120 120,600 780,1290 1380,1530 1530,1620
you like,| {} you can
|你可以问为什么我的解决方案与你的不同，

22
00:00:48,470 --> 00:00:50,030
0,270 270,540 540,780 780,1020 1020,1560
ask about why my solution

23
00:00:50,030 --> 00:00:51,770
0,390 390,720 720,900 900,1050 1050,1740
is different from your solution|
|

24
00:00:51,770 --> 00:00:53,330
0,270 480,930 930,1110 1110,1230 1230,1560
or why {xv6 - -}
或者为什么 xv6 这样工作，

25
00:00:53,330 --> 00:00:54,620
0,270 270,360 360,510 510,630 630,1290
works the way it does|
|

26
00:00:54,620 --> 00:00:56,570
0,270 330,1350 1410,1560 1560,1860 1860,1950
or why the bugs that
为什么我们遇到的 bug 以这种方式出现。

27
00:00:56,570 --> 00:00:58,600
0,90 90,930
we encounter

28
00:00:58,860 --> 00:00:59,970
0,510 510,780 780,960 960,1050 1050,1110
{} show up in the

29
00:00:59,970 --> 00:01:01,260
0,150 150,300 300,690
way they do.|
|

30
00:01:02,040 --> 00:01:03,390
0,450 450,720 720,780 780,1140 1140,1350
So just to remind you,|
所以只想提醒一下，|

31
00:01:03,390 --> 00:01:04,530
0,240 240,330 330,570 570,750 750,1140
although I'm sure this is
虽然我相信不需要提醒你们，

32
00:01:04,620 --> 00:01:06,390
0,690 960,1410 1410,1440 1440,1620 1620,1770
I'm sure I don't need

33
00:01:06,390 --> 00:01:07,770
0,120 120,420 420,660 780,1140 1140,1380
to remind you,| the point
|写入时复制 fork 的关键点是

34
00:01:07,770 --> 00:01:08,850
0,90 90,480 480,690 690,930 930,1080
of {copy-on-write -} fork is|
|

35
00:01:08,850 --> 00:01:11,280
0,120 120,840 870,1500 1500,2190 2190,2430
to avoid copying costs for
为了避免在 fork 时对未修改页面的复制成本。

36
00:01:11,280 --> 00:01:13,380
0,900 1230,1620 1620,1680 1680,1980 1980,2100
pages at {} fork that

37
00:01:13,380 --> 00:01:16,140
0,90 90,330 330,1020 1620,2280 2580,2760
are never modified.| {} I
|我输入了几行代码，

38
00:01:16,140 --> 00:01:17,490
0,210 210,510 510,930 930,1110 1110,1350
put in a few lines

39
00:01:17,490 --> 00:01:18,480
0,90 90,330 330,420 420,840 840,990
of code| to measure the
|来测量 memcpy 必须复制的字节数的减少，

40
00:01:18,480 --> 00:01:20,550
0,660 660,1260 1380,1530 1530,1830 1830,2070
reduction in the number of

41
00:01:20,550 --> 00:01:22,170
0,570 570,750 750,1050 1050,1470 1470,1620
bytes that {memcpy -} had

42
00:01:22,170 --> 00:01:24,930
0,90 90,750 1080,1680 1710,2100 2100,2760
to copy| {} during {usertests
|对于我的写入时复制解决方案在 usertests 时，

43
00:01:24,930 --> 00:01:27,030
0,690 690,840 840,1140 1140,1710 1710,2100
-} for my copy-on-write solution|
|

44
00:01:27,030 --> 00:01:28,830
0,120 120,390 390,600 750,1230 1230,1800
and found that actually reduce
结果发现实际上减少了 90% 的复制量。

45
00:01:28,830 --> 00:01:29,540
0,300
the

46
00:01:29,600 --> 00:01:31,820
0,360 360,420 420,930 930,1080 1080,2220
amount of copying by 90%.|
|

47
00:01:32,630 --> 00:01:33,470
0,210 210,330 330,420 420,570 570,840
And this is for {usertests
这是针对 usertests 的，

48
00:01:33,470 --> 00:01:34,550
0,330 330,510 510,810 840,1020 1020,1080
-}| which is kind of
|虽然是一个有点怪异的程序，但无所谓，

49
00:01:34,550 --> 00:01:36,200
0,60 60,270 270,600 600,780 780,1650
a weird program, but nevertheless,|
|

50
00:01:36,410 --> 00:01:38,060
0,690 930,1170 1170,1350 1350,1410 1410,1650
and I think a lot
我认为这很大程度上是因为指令页的复制减少了，

51
00:01:38,060 --> 00:01:39,440
0,90 90,210 210,540 540,1080 1080,1380
of it is reductions {in's

52
00:01:39,440 --> 00:01:41,000
0,300 330,750 750,840 840,930 930,1560
-} copy of the instruction

53
00:01:41,000 --> 00:01:42,650
0,570 570,750 750,810 810,1290 1290,1650
pages,| because the instruction pages
|因为指令页从来不会修改，

54
00:01:42,650 --> 00:01:46,280
0,450 660,810 810,1230 1230,2160 3030,3630
for are never modified,| so
|所以不需要复制它们，

55
00:01:46,310 --> 00:01:47,330
0,180 180,480 480,660 660,960 960,1020
there's never any point in

56
00:01:47,330 --> 00:01:48,800
0,240 240,660 660,750 750,960 1170,1470
having copies of them| and
|我认为这就是很多优势的来源。

57
00:01:48,800 --> 00:01:49,460
0,120 120,240 240,420 420,570 570,660
I think that's where a

58
00:01:49,460 --> 00:01:50,180
0,180 180,240 240,330 330,540 540,720
lot of the win was

59
00:01:50,180 --> 00:01:50,980
0,390
from.|
|

60
00:01:51,040 --> 00:01:52,780
0,300 300,810 810,1050 1050,1320 1320,1740
And copy-on-write fork also reduces
并且写入时复制 fork 还减少了 RAM 的使用，

61
00:01:52,780 --> 00:01:55,000
0,390 390,990 1230,1920 1950,2160 2160,2220
RAM use,| the sort of
|你需要使用的最大 RAM 量，

62
00:01:55,000 --> 00:01:55,960
0,420 420,570 570,630 630,840 840,960
maximum amount of RAM you

63
00:01:55,960 --> 00:01:57,280
0,150 150,330 330,450 450,900 1020,1320
ever need to use| and
|它减少了你花在 fork 上的时间，

64
00:01:57,280 --> 00:01:58,090
0,90 90,450 450,540 540,750 750,810
it reduces the amount of

65
00:01:58,090 --> 00:01:59,500
0,300 300,390 390,690 690,840 840,1410
time you spend in fork,|
|

66
00:02:01,040 --> 00:02:02,120
0,120 120,270 270,480 480,930 930,1080
and so fork returns more
所以 fork 返回得更快。

67
00:02:02,120 --> 00:02:03,170
0,660 660,780 780,870 870,960 960,1050
quickly.| You know on the
|从另一方面来说，当然总成本可能会更高，

68
00:02:03,170 --> 00:02:03,980
0,150 150,300 300,360 360,660 660,810
other hand, of course the

69
00:02:04,040 --> 00:02:05,840
0,420 420,900 900,1050 1050,1230 1230,1800
total cost may be larger,|
|

70
00:02:05,870 --> 00:02:07,970
0,630 960,1230 1230,1710 1710,1890 1890,2100
because if programs end up
因为如果程序最终修改了所有写入时复制页面，

71
00:02:07,970 --> 00:02:09,260
0,630 630,780 780,870 870,1200 1200,1290
modifying all the {copy-on-write -

72
00:02:09,260 --> 00:02:11,060
0,210 210,990 1260,1530 1530,1710 1710,1800
-} pages,| {} you end
|你不得不做所有的复制，再加上所有的页面错误，

73
00:02:11,060 --> 00:02:11,720
0,90 90,330 330,390 390,540 540,660
up having to do all

74
00:02:11,720 --> 00:02:13,250
0,60 60,660 660,1170 1170,1410 1410,1530
the copies plus take all

75
00:02:13,250 --> 00:02:15,710
0,90 90,390 390,960 2070,2340 2340,2460
the page faults,| which can
|这可能有点昂贵，

76
00:02:15,710 --> 00:02:17,450
0,120 120,900 930,1170 1170,1290 1290,1740
be a little bit expensive,|
|

77
00:02:17,450 --> 00:02:19,190
0,120 120,840 870,1380 1380,1650 1650,1740
but nevertheless, people found that,
但尽管如此，人们发现，一般说来，这是一种净收益。

78
00:02:19,190 --> 00:02:21,120
0,120 120,570 570,900
in general, it's

79
00:02:21,450 --> 00:02:23,440
0,480 570,900 900,1410
a net benefit.|
|

80
00:02:23,770 --> 00:02:24,580
0,270 270,390 390,510 510,690 690,810
And as you know the
如你所知，主要的挑战是，

81
00:02:24,580 --> 00:02:26,980
0,240 240,1020 1020,1440 1830,2100 2100,2400
main challenges are,| {} one
|一个挑战是如何避免释放内存，

82
00:02:26,980 --> 00:02:28,660
0,420 420,540 540,690 690,810 810,1680
challenge is how to avoid

83
00:02:28,690 --> 00:02:30,610
0,690 690,1410 1440,1740 1740,1800 1800,1920
freeing memory| and now we're
|现在我们在进程之间共享页面，

84
00:02:30,610 --> 00:02:32,860
0,540 540,930 930,1140 1140,1890 1980,2250
sharing pages among processes,| have
|没有释放它们，

85
00:02:32,860 --> 00:02:34,240
0,420 420,570 570,1080 1080,1230 1230,1380
not {de-allocate -} them, have

86
00:02:34,240 --> 00:02:35,770
0,240 240,480 480,660 660,1200 1290,1530
not free them,| until the
|直到最后一个进程完成使用它们。

87
00:02:35,770 --> 00:02:37,240
0,330 330,780 780,930 930,1230 1230,1470
last process is finished using

88
00:02:37,240 --> 00:02:40,150
0,330 480,690 690,990 990,1920 2430,2910
them,| so anymore bookkeeping.| And
|所以任何[]。|另一个有趣的挑战是，

89
00:02:40,480 --> 00:02:42,670
0,240 240,450 450,810 810,1530 1530,2190
the other interesting {challenge,is}| that
|特别是 xv6 中的 copyout ，

90
00:02:42,880 --> 00:02:44,710
0,630 660,900 900,1050 1050,1500 1500,1830
there's a in {copyout -}

91
00:02:44,710 --> 00:02:46,080
0,90 90,690 690,930
in particular the

92
00:02:46,250 --> 00:02:48,620
0,390 390,960 990,1830 1830,2040 2040,2370
{xv6 -},| modifies user memory
|修改用户内存，而无需实际使用 MMU 分页硬件，

93
00:02:48,620 --> 00:02:50,030
0,330 330,660 660,870 870,1050 1050,1410
without actually going to the

94
00:02:50,090 --> 00:02:52,800
0,330 330,570 570,990 990,1590
{MMU -} paging hardware,|
|

95
00:02:53,410 --> 00:02:54,610
0,270 270,360 360,450 450,570 570,1200
and we have to mimic
我们必须在这里模仿页面错误。

96
00:02:54,760 --> 00:02:57,000
0,480 480,780 780,990
page faults here.|
|

97
00:02:57,090 --> 00:02:58,770
0,540 810,1230 1230,1440 1440,1560 1560,1680
I'm gonna go to the
我要看实验了，

98
00:02:58,770 --> 00:03:00,330
0,570 600,1020 1020,1410 1410,1500 1500,1560
lab,| {} starting at the
|从写入时复制实验的开头开始，

99
00:03:00,330 --> 00:03:02,670
0,450 450,540 540,1140 1140,1680 1800,2340
beginning the copy-on-write lab, {}|
|

100
00:03:02,820 --> 00:03:03,630
0,270 270,300 300,540 540,600 600,810
before I start,| I just
在我开始之前，|我想提一下，

101
00:03:03,630 --> 00:03:04,500
0,330
wanna

102
00:03:04,500 --> 00:03:06,390
0,300 300,600 600,990 990,1080 1080,1890
{} just mentioned| the strategy
|我在做实验时遵循的策略，

103
00:03:06,390 --> 00:03:07,890
0,390 480,750 750,990 990,1080 1080,1500
that I think of myself

104
00:03:07,890 --> 00:03:08,940
0,150 150,630 630,810 810,870 870,1050
as following when I do

105
00:03:08,940 --> 00:03:10,020
0,690 720,840 840,900 900,1020 1020,1080
labs| and I do a
|我做了很多实验，一年又一年，

106
00:03:10,020 --> 00:03:11,460
0,180 180,300 300,1020 1080,1290 1290,1440
lot of labs from one

107
00:03:11,460 --> 00:03:12,090
0,180 180,270 270,330 330,570 570,630
year to the next,| I
|我不记得做实验的细节了，

108
00:03:12,090 --> 00:03:13,860
0,150 150,780 990,1230 1230,1680 1680,1770
don't remember the details of

109
00:03:13,860 --> 00:03:15,000
0,120 120,210 210,330 330,450 450,1140
how to do the labs,|
|

110
00:03:16,890 --> 00:03:18,750
0,210 210,300 300,660 660,1050 1050,1860
and in addition labs change.|
另外，实验也发生了变化。|

111
00:03:19,180 --> 00:03:20,650
0,360 360,630 630,930 960,1260 1260,1470
Alright, so, { -} when
好的，当我做实验的时候，

112
00:03:20,650 --> 00:03:21,310
0,60 60,270 270,330 330,600 600,660
I'm doing the labs,| I
|我总是迈出一小步，

113
00:03:21,310 --> 00:03:22,660
0,210 210,420 420,720 720,1260 1260,1350
always take small steps,| I
|我可能会发现要解决的问题的下一个子集，

114
00:03:22,660 --> 00:03:24,730
0,240 480,990 1020,1110 1110,1230 1230,2070
may find you know some

115
00:03:24,940 --> 00:03:26,080
0,270 270,330 330,630 630,1080 1080,1140
sort of next subset of

116
00:03:26,080 --> 00:03:27,610
0,60 60,330 330,420 420,1020 1170,1530
the problem to solve,| maybe
|可能有五到十行代码，

117
00:03:27,610 --> 00:03:28,660
0,330 330,390 390,690 690,960 960,1050
five or ten lines of

118
00:03:28,660 --> 00:03:30,850
0,570 600,900 900,1530 1530,1890 1950,2190
code,| I programmed up and
|我编写程序并运行它，然后试着让它工作，

119
00:03:30,850 --> 00:03:31,660
0,300 300,450 450,570 570,720 720,810
run it and try to

120
00:03:31,660 --> 00:03:33,910
0,210 210,330 330,930 1650,2160 2160,2250
get to working,| before I
|在我继续下一步之前，

121
00:03:33,910 --> 00:03:34,900
0,150 150,270 270,330 330,420 420,990
go on to the next,

122
00:03:34,990 --> 00:03:36,430
0,570 690,1050 1050,1110 1110,1200 1200,1440
{} proceeding to the next

123
00:03:36,430 --> 00:03:37,930
0,480 540,750 750,900 900,1290 1350,1500
step| and this is you
|这是，而不是整体思考并编写一个完整的解决方案，

124
00:03:37,930 --> 00:03:38,710
0,90 90,240 240,540 540,630 630,780
know as opposed to for

125
00:03:38,710 --> 00:03:41,020
0,570 690,1230 1230,1620 1620,1800 1800,2310
example thinking through and writing

126
00:03:41,050 --> 00:03:42,760
0,180 180,600 600,1320
a complete solution,|
|

127
00:03:42,850 --> 00:03:45,910
0,660 960,2100 2190,2640 2640,2760 2760,3060
{} before starting to test
在开始测试和调试之前，

128
00:03:45,910 --> 00:03:47,840
0,90 90,450 450,600 750,1410
and debug,| it always
|它总是一次测试和调试一点，

129
00:03:47,990 --> 00:03:49,100
0,300 300,390 390,660 660,840 840,1110
test and debug a little

130
00:03:49,100 --> 00:03:50,360
0,120 120,210 210,270 270,660 960,1260
bit at a time,| a
|这很大程度上是因为，

131
00:03:50,360 --> 00:03:50,930
0,120 120,180 180,240 240,480 480,570
lot of the reason for

132
00:03:50,930 --> 00:03:52,460
0,240 240,360 360,630 840,1260 1290,1530
that is that,| {} even
|即使你可能对很多事情都有一些想法，

133
00:03:52,460 --> 00:03:54,650
0,120 120,270 270,1050 1320,1950 1980,2190
though you may, {} you

134
00:03:54,650 --> 00:03:55,940
0,120 120,240 240,660 660,780 810,1290
may have sort of thought

135
00:03:55,940 --> 00:03:57,110
0,150 150,210 210,390 390,570 570,1170
through a lot of things,|
|

136
00:03:57,110 --> 00:03:58,130
0,90 90,240 240,300 300,390 390,1020
a lot of the challenges,|
很多挑战，|

137
00:03:58,130 --> 00:03:58,640
0,90 90,150 150,360 360,420 420,510
and a lot of the
还有很多设计，

138
00:03:58,640 --> 00:04:00,290
0,840 870,1200 1200,1440 1440,1530 1530,1650
design,| for what you're going
|你要做什么才能解决实验的问题，

139
00:04:00,290 --> 00:04:00,770
0,60 60,180 180,270 270,390 390,480
to have to do to

140
00:04:00,770 --> 00:04:02,300
0,270 270,360 360,810 900,1290 1290,1530
solve the lab,| I find
|我发现至少经常会有惊喜。

141
00:04:02,300 --> 00:04:04,250
0,60 60,300 300,480 480,930 930,1950
at least there's often surprises.|
|

142
00:04:04,620 --> 00:04:06,750
0,450 510,690 690,1020 1230,1590 1590,2130
{} And so if I
所以如果我先实现所有的东西，

143
00:04:06,780 --> 00:04:08,700
0,480 480,840 840,1590 1620,1740 1740,1920
implement everything first,| I may
|我可能会发现我浪费了很多时间，

144
00:04:08,700 --> 00:04:10,140
0,450 450,780 780,1020 1020,1140 1140,1440
find then that I've wasted

145
00:04:10,140 --> 00:04:11,640
0,60 60,270 270,330 330,840 840,1500
a lot of time,| because
|因为我没有完全理解这个问题，

146
00:04:11,670 --> 00:04:12,960
0,210 210,420 420,780 780,1230 1230,1290
I didn't fully understand the

147
00:04:12,960 --> 00:04:15,210
0,420 420,1080 1290,1530 1530,1980 1980,2250
problem,| until I actually got
|直到我真正开始调试它。

148
00:04:15,210 --> 00:04:16,900
0,390 390,900 900,1080
into debugging it.|
|

149
00:04:17,360 --> 00:04:18,950
0,510 1170,1320 1320,1410 1410,1530 1530,1590
{} And the way I
我在每个点上选择下一步的方式是

150
00:04:18,950 --> 00:04:19,880
0,240 240,330 330,540 540,810 810,930
choose the next step at

151
00:04:19,880 --> 00:04:21,740
0,150 150,540 540,1050 1050,1530 1530,1860
each point is| usually driven
|通常是由测试失败引起的 panic 或崩溃引起的，

152
00:04:21,740 --> 00:04:23,900
0,480 510,1080 1080,1590 1590,1680 1680,2160
by whatever panic or crash

153
00:04:23,900 --> 00:04:24,950
0,60 60,390 390,780 780,780 780,1050
a test failure I see

154
00:04:24,950 --> 00:04:26,390
0,480 480,690 690,930 1050,1350 1350,1440
that,| sort of tells me
|告诉我下一步需要解决的问题。

155
00:04:26,390 --> 00:04:28,220
0,390 510,660 660,900 900,1200 1500,1830
what I need to fix

156
00:04:28,220 --> 00:04:29,200
0,540
next.|
|

157
00:04:29,350 --> 00:04:30,820
0,480 840,1080 1080,1170 1170,1290 1290,1470
{} Well I'm doing this
我在做这个实验，

158
00:04:30,820 --> 00:04:32,200
0,510 570,750 750,1020 1020,1200 1200,1380
lab,| I'll make a few
|我会犯几个错误，

159
00:04:32,200 --> 00:04:33,550
0,450 450,570 570,660 660,960 960,1350
mistakes,| that I actually made
|这是我上一次做实验时做的，

160
00:04:33,550 --> 00:04:34,330
0,90 90,390 390,600 600,630 630,780
the last time I did

161
00:04:34,330 --> 00:04:36,490
0,120 120,720 780,1500 1830,2040 2040,2160
the lab,| {} so that
|我们可以一起做一个小的调试练习。

162
00:04:36,490 --> 00:04:37,870
0,120 120,270 270,690 720,1170 1170,1380
we can do a have

163
00:04:37,870 --> 00:04:39,430
0,30 30,210 210,660 660,1110 1110,1560
a little practice debugging together.|
|

164
00:04:41,360 --> 00:04:42,770
0,510 510,780 780,1020 1020,1140 1140,1410
Again, feel free to break
再说一遍，你可以随时打断，问任何问题。

165
00:04:42,770 --> 00:04:43,880
0,120 120,240 240,420 420,810 810,1110
in at any time and

166
00:04:44,030 --> 00:04:46,280
0,360 360,990 990,1230 1230,1710
ask questions about anything.|
|

167
00:04:47,040 --> 00:04:49,140
0,630 720,1110 1110,1470 1470,1710 1710,2100
{} I'm starting here with
我从写入时复制实验的最新拷贝开始，

168
00:04:49,820 --> 00:04:51,260
0,390 390,870 870,960 960,1080 1080,1440
fresh copy of the {copy-on-write

169
00:04:51,260 --> 00:04:52,840
0,120 120,390 390,1050
- -} lab,|
|

170
00:04:53,100 --> 00:04:54,690
0,360 360,1110 1140,1230 1230,1470 1470,1590
{} source the same as
和你们所有人一样的源码。

171
00:04:54,690 --> 00:04:55,920
0,120 120,180 180,330 330,660
all of you did.|
|

172
00:04:55,920 --> 00:04:56,910
0,360 360,450 450,540 540,720 720,990
{} So, I'll just fire
所以，我要开始了。

173
00:04:56,910 --> 00:04:58,180
0,210 210,690
this up.|
|

174
00:04:58,830 --> 00:05:00,420
0,1050
And,
并且，运行写入时复制测试，

175
00:05:00,920 --> 00:05:02,200
0,780
{}

176
00:05:03,340 --> 00:05:04,330
0,270 270,330 330,690 690,780 780,990
run the {copy-on-write - -}

177
00:05:04,330 --> 00:05:05,860
0,330 330,600 1050,1290 1290,1350 1350,1530
tests| and you know maybe
|也许我很幸运，

178
00:05:05,860 --> 00:05:06,700
0,90 90,270 270,600 600,720 720,840
I'll get lucky| and all
|所有测试都会通过，不需要做任何事，

179
00:05:06,700 --> 00:05:07,570
0,60 60,330 330,420 420,780 780,870
the tests will pass and

180
00:05:07,570 --> 00:05:08,590
0,150 150,240 240,330 330,480 480,1020
don't have to do anything,|
|

181
00:05:08,980 --> 00:05:10,480
0,900

182
00:05:10,510 --> 00:05:11,410
0,150 150,450 450,540 540,600 600,900
too bad, on the test
不好，测试失败了，

183
00:05:11,410 --> 00:05:12,700
0,480 510,810 810,990 990,1170 1170,1290
failed,| okay, so not too
|好的，不用太惊讶。

184
00:05:12,700 --> 00:05:14,940
0,630 780,1620
surprising. {}|
|

185
00:05:16,680 --> 00:05:18,660
0,510 900,1170 1170,1380 1380,1500 1500,1980
And you know a good
这时好的步骤就是

186
00:05:18,690 --> 00:05:19,710
0,390 390,450 450,630 630,930 930,1020
step at this point is|
|

187
00:05:19,710 --> 00:05:20,550
0,120 120,420 420,630 630,660 660,840
to go have a look
去看看测试，

188
00:05:20,550 --> 00:05:22,200
0,90 90,180 180,870 900,1320 1320,1650
at the tests| and figure
|弄清楚它想要做什么，

189
00:05:22,200 --> 00:05:22,920
0,90 90,210 210,330 330,660 660,720
out what it's trying to

190
00:05:22,920 --> 00:05:24,810
0,330 780,1230 1230,1500 1500,1650 1650,1890
do,| {} and the sad
|令人难受的是，有些测试很复杂，很难理解，

191
00:05:24,810 --> 00:05:25,500
0,240 240,360 360,540 540,600 600,690
truth is some of the

192
00:05:25,500 --> 00:05:26,880
0,390 390,750
tests are

193
00:05:26,910 --> 00:05:28,470
0,510 540,1170 1170,1320 1320,1500 1500,1560
{} complicated and hard to

194
00:05:28,470 --> 00:05:30,540
0,660 660,870 870,1080 1080,1680 1680,2070
understand| and don't necessarily test
|不一定是测试任何特定的东西，

195
00:05:30,540 --> 00:05:32,550
0,570 810,1590 1590,1680 1680,1860 1860,2010
anything specific,| they just sort
|它们只是尝试不同的东西，看看会不会断掉，

196
00:05:32,550 --> 00:05:33,460
0,300
of

197
00:05:33,460 --> 00:05:34,840
0,210 210,450 450,900 1020,1290 1290,1380
try different things, see if

198
00:05:34,840 --> 00:05:36,340
0,240 240,330 330,720 780,1200 1200,1500
something will break,| but luckily
|但幸运的是，这个简单的测试，

199
00:05:36,340 --> 00:05:39,400
0,150 150,300 300,600 600,1230 2850,3060
with this simple test,| it's
|它的作用非常清楚。

200
00:05:39,400 --> 00:05:40,570
0,210 210,420 420,570 570,720 720,1170
pretty clear what its doing.|
|

201
00:05:40,930 --> 00:05:43,600
0,330 660,1200 1320,2250 2280,2490 2490,2670
A question.| Yeah.| You need
一个问题。|嗯。|你需要显示一下你的屏幕，我们什么也看不见。

202
00:05:43,600 --> 00:05:44,500
0,120 120,330 330,480 480,780 780,900
to show your screen, we

203
00:05:44,500 --> 00:05:46,840
0,270 270,450 450,840 990,1620 1620,2340
cannot see anything.| Oh gosh.|
|哦，天哪。|

204
00:05:47,450 --> 00:05:49,970
0,540 540,990 990,1260 1260,1470 1470,2520
{} I'm sorry about that,|
不好意思,|

205
00:05:50,240 --> 00:05:51,980
0,540 540,660 660,840 960,1620 1620,1740
thank you for, thank you
谢谢你让我知道。

206
00:05:51,980 --> 00:05:53,640
0,90 90,330 330,420 420,870
for letting me know.|
|

207
00:05:55,280 --> 00:05:56,720
0,150 150,270 270,420 420,960
How is that better?|
这好了吗？|

208
00:05:57,820 --> 00:06:01,960
0,540 1320,1500 1500,1920 1920,2280 3150,4140
Yes.| {} Brilliant, alright.| Okay,
是的。|太棒了，好的。|好的，这是第一个 bug 。

209
00:06:01,960 --> 00:06:03,370
0,360 390,630 630,840 840,1020 1020,1410
well, that's bug number one.|
|

210
00:06:06,030 --> 00:06:08,550
0,390 390,840 1110,1860 1890,2040 2040,2520
Okay, so {} I'll just,
好的，我在这里，

211
00:06:08,580 --> 00:06:09,900
0,630 690,960 960,1050 1050,1230 1230,1320
{} here I am,| in
|在我的写入时复制测试中，

212
00:06:09,900 --> 00:06:11,730
0,300 330,660 660,810 810,1260 1260,1830
my {copy-on-write - -} test,|
|

213
00:06:11,850 --> 00:06:14,800
0,1080 1110,1770 1770,2430
{I,ran} copy-on-write test,
我运行了写入时复制测试，但是失败了。

214
00:06:14,830 --> 00:06:17,820
0,450 450,570 570,1410
and it fails.|
|

215
00:06:18,690 --> 00:06:20,100
0,390 450,720 720,780 780,840 840,1410
{} Look at the test,|
看看这个测试，|

216
00:06:20,100 --> 00:06:21,840
0,120 120,510 510,1140 1470,1680 1680,1740
this {simpletest -} on the
屏幕右边的 simpletest 失败了，

217
00:06:21,840 --> 00:06:23,910
0,360 360,600 600,960 1200,1560 1560,2070
screen right is actually failed,|
|

218
00:06:24,150 --> 00:06:26,640
0,480 750,1140 1140,1710 1740,2130 2160,2490
and this test, we're lucky
这个测试，我们很幸运，它告诉我们它在做什么，

219
00:06:26,640 --> 00:06:27,690
0,390 390,480 480,690 690,960 960,1050
enough, it actually tells us

220
00:06:27,690 --> 00:06:29,910
0,120 120,240 240,630 990,1350 1350,2220
what it's doing| and allocates
|分配 xv6 中超过一半的可用内存，然后 fork ，

221
00:06:30,090 --> 00:06:30,990
0,150 150,270 270,660 660,780 780,900
what it knows to be

222
00:06:30,990 --> 00:06:32,460
0,270 270,390 390,870 870,1020 1020,1470
more than half the available

223
00:06:32,460 --> 00:06:34,500
0,600 1050,1380 1380,1530 1530,1920 1920,2040
memory in {xv6 -} and

224
00:06:34,500 --> 00:06:37,620
0,150 150,870 2070,2640
then forks| and
|当然，这个失败的原因是 fork 复制了一份，

225
00:06:37,620 --> 00:06:38,340
0,90 90,270 270,360 360,570 570,720
of course, the reason this

226
00:06:38,340 --> 00:06:40,260
0,420 420,540 540,780 900,1620 1710,1920
fails is that fork makes

227
00:06:40,260 --> 00:06:42,630
0,60 60,600 780,1530 1800,2220 2220,2370
a copy,| then ordinary {xv6
|然后 xv6 从字面上复制了，

228
00:06:42,630 --> 00:06:44,580
0,120 120,330 330,1020 1350,1770 1770,1950
- -} actually literally makes

229
00:06:44,580 --> 00:06:46,620
0,60 60,450 450,600 600,1020 1440,2040
a copy| and so {}
|所以，如果我们必须复制一半以上的内存，

230
00:06:46,860 --> 00:06:47,580
0,180 180,270 270,360 360,450 450,720
if we have to copy

231
00:06:47,580 --> 00:06:48,660
0,240 240,360 360,540 540,630 630,1080
more than half of memory,|
|

232
00:06:48,660 --> 00:06:49,680
0,240 240,420 420,540 540,690 690,1020
there's just not enough space
就会没有足够的空间。

233
00:06:49,680 --> 00:06:52,120
0,90 90,270 1230,1530 1530,1950
for that.| Okay, so,
|好的，所以，这就是写入时复制的意义所在，

234
00:06:52,180 --> 00:06:53,410
0,120 120,450 450,630 630,1050 1050,1230
of course, this is what

235
00:06:53,410 --> 00:06:54,610
0,300 300,390 390,630 630,750 750,1200
{copy-on-write - -} all about,|
|

236
00:06:55,000 --> 00:06:56,770
0,630 720,1200 1290,1440 1440,1620 1620,1770
{} and we know that
我们知道游戏是不用复制进程的内存，

237
00:06:56,770 --> 00:06:57,970
0,90 90,420 420,810 810,990 990,1200
the basic game is that

238
00:06:57,970 --> 00:06:59,800
0,330 330,420 420,1260
instead of copying

239
00:06:59,800 --> 00:07:01,630
0,390 480,930 930,990 990,1530 1560,1830
the {process's -} memory,| we
|我们只复制它的页表，而不是内存，

240
00:07:01,630 --> 00:07:03,160
0,120 120,300 390,960 960,1350 1350,1530
want to just copy its

241
00:07:03,160 --> 00:07:04,840
0,330 330,840 1020,1320 1320,1590 1590,1680
page table and not the

242
00:07:04,840 --> 00:07:06,790
0,540 900,1110 1110,1560 1560,1770 1770,1950
memory,| the child just has
|子进程只有一份父进程页表的复制，而不是内存，

243
00:07:06,790 --> 00:07:08,710
0,210 420,1230 1230,1620 1620,1710 1710,1920
a carbon copy of the

244
00:07:08,710 --> 00:07:10,120
0,420 420,810 810,1080 1080,1350 1350,1410
parent's page table, instead of

245
00:07:10,120 --> 00:07:11,120
0,480
memory,|
|

246
00:07:11,240 --> 00:07:12,110
0,210 210,540 540,630 630,780 780,870
{} referring to all the
指向所有相同的物理页面。

247
00:07:12,110 --> 00:07:14,020
0,270 270,630 630,1380
same physical pages.|
|

248
00:07:14,390 --> 00:07:17,460
0,870 1110,1380 1380,1740 1740,2490
{} The place where,
fork 执行复制的位置在 vm.c 和 uvmcopy 中。

249
00:07:17,950 --> 00:07:19,400
0,900
{}

250
00:07:20,370 --> 00:07:22,020
0,540 540,750 750,930 930,1500 1500,1650
fork does it's copying is

251
00:07:22,020 --> 00:07:23,670
0,120 120,450 450,660 660,1260 1260,1650
in {vm.c - -} and

252
00:07:24,030 --> 00:07:25,840
0,630 630,1260
{uvmcopy -}.|
|

253
00:07:26,180 --> 00:07:27,420
0,630

254
00:07:27,820 --> 00:07:28,930
0,330 510,720 720,810 810,930 930,1110
And so we can just
所以我们只需修改这个代码，

255
00:07:28,930 --> 00:07:32,360
0,570 570,750 750,1650
modify this code,|
|

256
00:07:33,320 --> 00:07:35,090
0,570 570,900 900,990 990,1680 1680,1770
to instead of allocating a
以代替分配页面内存，

257
00:07:35,090 --> 00:07:36,780
0,330 330,1080
page memory,|
|

258
00:07:36,870 --> 00:07:38,620
0,420 420,1230
{} here,
在这里，并复制到上面，

259
00:07:38,710 --> 00:07:40,630
0,420 420,900 900,1200 1200,1470 1590,1920
and copying onto it,| we're
|我们要去掉这三行。

260
00:07:40,630 --> 00:07:42,370
0,180 180,450 630,1290 1290,1530 1530,1740
going to eliminate those three

261
00:07:42,370 --> 00:07:43,940
0,900
lines,|
|

262
00:07:43,940 --> 00:07:45,980
0,480 480,1470
and instead,|
取而代之的是，|

263
00:07:45,980 --> 00:07:47,520
0,900

264
00:07:48,880 --> 00:07:50,080
0,240 240,450 450,720 720,960 960,1200
I just copied page table
我只是复制页表条目，

265
00:07:50,080 --> 00:07:54,040
0,660 840,1560 2520,3360
entries,| so um,|
|所以，|

266
00:07:55,740 --> 00:07:58,110
0,1020 1170,1650 1650,1830 1830,2010 2010,2370
{} actually just gonna hack,
实际上就是想 hack 这个 mappages 的复制，

267
00:07:58,110 --> 00:07:59,980
0,480 660,1050
this {}

268
00:08:01,060 --> 00:08:02,280
0,630
{}

269
00:08:05,480 --> 00:08:07,860
0,630 630,1650
copy of

270
00:08:08,240 --> 00:08:10,850
0,420 600,1080 1080,2070 2220,2520 2520,2610
{} {mappages -},| since we
|因为我们没有在这里分配内存，

271
00:08:10,850 --> 00:08:12,110
0,150 150,450 450,840 840,1110 1110,1260
didn't actually allocate memory here,|
|

272
00:08:12,110 --> 00:08:12,590
0,120 120,180 180,330 330,420 420,480
going to get rid of
我要把删掉这个 free ，

273
00:08:12,590 --> 00:08:14,360
0,180 180,750 930,1500 1500,1710 1710,1770
this free,| I'm going to
|我将修复这个 mappages ，

274
00:08:14,360 --> 00:08:15,590
0,240 240,420 420,660 660,1110 1110,1230
fix this {mappages -},| to
|而不是将 mem 映射到地址 i ，

275
00:08:15,590 --> 00:08:18,230
0,390 390,660 1050,1410 1410,1890 1890,2640
instead of {} mapping mem

276
00:08:18,260 --> 00:08:20,460
0,690 1020,1680
at {}

277
00:08:21,700 --> 00:08:23,650
0,570 570,1080 1560,1770 1770,1890 1890,1950
address i,| I'm going to
|我要映射 pa ，

278
00:08:23,650 --> 00:08:25,570
0,360 360,780 870,1560 1560,1740 1740,1920
map the pa,| which is
|它是我们从父进程页表中取出的物理地址。

279
00:08:25,570 --> 00:08:26,950
0,180 180,510 510,840 840,960 960,1380
the physical address, we pulled

280
00:08:26,950 --> 00:08:28,180
0,180 180,300 300,480 480,960 960,1230
out of the parents' page

281
00:08:28,180 --> 00:08:29,180
0,390
table.|
|

282
00:08:29,710 --> 00:08:31,220
0,180 180,330 330,930
{So,is} that clear?|
这里能明白吗？|

283
00:08:31,650 --> 00:08:32,610
0,150 150,360 360,720 720,810 810,960
And so this will just
所以这会产生这样的效果

284
00:08:32,610 --> 00:08:34,470
0,120 120,240 240,690 690,990 1380,1860
have the effect of| mapping
|将所有父页面映射到子页面的地址空间。

285
00:08:34,470 --> 00:08:36,090
0,240 240,300 300,390 390,780 780,1620
all of the parents pages

286
00:08:36,150 --> 00:08:38,180
0,210 210,300 300,690 690,1530
into the child's {address,space}.|
|

287
00:08:39,280 --> 00:08:41,470
0,300 300,720 720,1320 1320,1560 1560,2190
Isn't pa already {uint64 -}?|
pa 不是已经是 uint64 了吗？|

288
00:08:44,940 --> 00:08:46,740
0,630 1020,1170 1170,1320 1320,1590 1620,1800
Probably.| Or is it is
可能吧。|或者，如果你强制转换为已经是的类型，是不是很糟糕？

289
00:08:46,740 --> 00:08:47,400
0,120 120,360 360,480 480,570 570,660
it bad, if you were

290
00:08:47,400 --> 00:08:48,960
0,120 120,570 570,990 990,1350 1350,1560
to cast its already that

291
00:08:48,960 --> 00:08:51,000
0,510 510,660 660,990 990,1290 1320,2040
type?| The cast does absolutely
|强制转换什么也没做，除了让编译器闭嘴，

292
00:08:51,000 --> 00:08:52,740
0,360 360,600 600,870 900,1380 1380,1740
nothing other than shut the

293
00:08:52,800 --> 00:08:54,420
0,630 630,1110
compiler up,|
|

294
00:08:54,540 --> 00:08:55,950
0,240 240,390 390,600 600,1080 1080,1410
since it's already, since addresses
因为地址已经是 64 位，

295
00:08:55,950 --> 00:08:57,300
0,90 90,570 570,960 960,1260 1260,1350
already 64 bits| and you
|你想要 64 位，

296
00:08:57,300 --> 00:08:58,440
0,150 150,420 420,630 630,960 960,1140
want {64 -} {64 -}

297
00:08:58,440 --> 00:09:00,030
0,270 420,720 720,1140 1140,1350 1350,1590
bit,| that cast doesn't change
|那个强制转换不会改变位，

298
00:09:00,030 --> 00:09:01,440
0,90 90,720
the bits,|
|

299
00:09:01,440 --> 00:09:02,880
0,90 90,600 870,1110 1110,1200 1200,1440
it just makes the type
它只是让类型检查器不那么烦躁，

300
00:09:02,880 --> 00:09:04,020
0,600
checker

301
00:09:04,290 --> 00:09:06,330
0,480 480,1140 1290,1560 1560,1920 1920,2040
less upset,| but [] you
|但是[]你并不知道是哪一种类型。

302
00:09:06,330 --> 00:09:07,590
0,330 330,450 450,570 570,1050 1050,1260
actually don't know whether any

303
00:09:07,590 --> 00:09:09,180
0,60 60,210 210,540 540,810
of these types are.|
|

304
00:09:10,160 --> 00:09:11,000
0,240 240,480 480,630 630,750 750,840
However, one thing is we
但是，有一件事是我们不需要这个 mem 变量。

305
00:09:11,000 --> 00:09:13,100
0,150 150,300 300,420 420,1200
don't need this {mem,variable}.|
|

306
00:09:15,550 --> 00:09:17,500
0,270 270,1020 1080,1590 1620,1770 1770,1950
{} Okay, {} so you
好的，那么你写下 pa ，

307
00:09:17,500 --> 00:09:19,200
0,240 240,510 510,1170
write about pa,|
|

308
00:09:19,590 --> 00:09:21,040
0,870

309
00:09:21,250 --> 00:09:22,030
0,420 420,450 450,600 600,690 690,780
gosh, I wonder if we're
天哪，我在想我们是不是完成了。

310
00:09:22,030 --> 00:09:23,920
0,180 180,570 900,1470 1470,1680 1680,1890
done now.| Let's run the
|我们来运行 cowtest ，看看会发生什么，

311
00:09:23,920 --> 00:09:24,850
0,420 420,570 570,660 660,810 810,930
{cowtest -} and see what

312
00:09:24,850 --> 00:09:27,490
0,810 900,1440 1500,2040 2040,2250 2250,2640
happens,| {} definitely not done.|
|绝对没完成。|

313
00:09:28,330 --> 00:09:29,700
0,390 390,810
Okay, so,
好的，我们在这里有，

314
00:09:29,700 --> 00:09:31,650
0,240 240,510 510,930 930,1620 1680,1950
we got here is, {}|
|

315
00:09:31,650 --> 00:09:33,740
0,420 420,810 810,1530
this {usertrap -}
这个 usertrap 和 scause 2 。

316
00:09:33,740 --> 00:09:35,600
0,270 270,570 570,1140 1140,1290 1290,1860
with {scause -} of two.|
|

317
00:09:36,740 --> 00:09:38,030
0,360 360,630 630,780 780,930 930,1290
Anybody remember what {scause -}
有人记得 scause 2 是什么吗？

318
00:09:38,030 --> 00:09:39,680
0,240 240,690
two is?|
|

319
00:09:41,410 --> 00:09:43,390
0,240 240,420 420,630 630,990 1020,1980
I'll just tell you.| Instruction
我就直接告诉你吧。|指令失效？

320
00:09:43,420 --> 00:09:45,550
0,690 720,930 930,1050 1050,1560 1560,2130
failure?| It's an illegal instruction,|
|这是非法指令，|

321
00:09:45,550 --> 00:09:47,590
0,300 540,1020 1020,1200 1200,1350 1350,2040
so why would we getting
那么我们为什么会得到非法指令。

322
00:09:47,590 --> 00:09:49,800
0,120 120,600 600,1260 1260,1710
an illegal instruction now.|
|

323
00:09:51,320 --> 00:09:52,700
0,150 150,300 300,420 420,510 510,1380
Is this what we expected?|
这是我们所期待的吗？|

324
00:09:58,070 --> 00:10:00,440
0,330 330,720 720,1140 1170,1770 1800,2370
{Did,we} {overwrite -} {} them
我们有没有覆盖有指令的位置？

325
00:10:00,440 --> 00:10:03,050
0,480 690,1650 1650,1980 1980,2100 2100,2610
like position where we have

326
00:10:03,200 --> 00:10:04,680
0,1020
instructions?|
|

327
00:10:05,310 --> 00:10:07,020
0,450 450,810 810,1020 1020,1590 1590,1710
Yes, something is damaging the
是的，有些东西破坏了用户程序的指令。

328
00:10:07,020 --> 00:10:09,960
0,1080 1350,1650 1650,2040 2070,2370 2370,2940
instructions of the user program.|
|

329
00:10:11,090 --> 00:10:12,380
0,720

330
00:10:12,440 --> 00:10:13,730
0,180 180,240 240,480 480,570 570,1290
And of course the fault,
当然，我们在这里得到错误并不奇怪。

331
00:10:13,760 --> 00:10:14,600
0,120 120,240 240,600 600,690 690,840
we're not surprised we get

332
00:10:14,600 --> 00:10:16,380
0,150 150,630 630,1200
a fault here.|
|

333
00:10:17,180 --> 00:10:18,470
0,150 150,270 270,720 720,990 990,1290
But we're hoping for write,
但我们希望是保存的错误，

334
00:10:18,470 --> 00:10:20,930
0,510 510,930 930,1560 1920,2040 2040,2460
for stored faults| to drive
|驱动复制进程和写入时复制。

335
00:10:20,930 --> 00:10:22,820
0,120 120,870 930,1440 1440,1560 1560,1890
the copying process and {copy-on-write

336
00:10:22,820 --> 00:10:23,920
0,180 180,660
- -}.|
|

337
00:10:24,760 --> 00:10:25,690
0,150 150,300 300,540 540,630 630,930
We're not getting the store
我们没有得到保存的错误。

338
00:10:25,690 --> 00:10:26,700
0,630
fault.|
|

339
00:10:28,790 --> 00:10:30,040
0,660

340
00:10:31,980 --> 00:10:34,860
0,270 270,1170 1200,2160 2160,2310 2310,2880
Any other hypotheses for this?|
对此还有其他假设吗？|这并不公平，

341
00:10:35,960 --> 00:10:37,100
0,180 180,360 360,540 540,840 840,1140
It's not really fair,| because
|因为这是我的 bug ，不是你的 bug ，

342
00:10:37,100 --> 00:10:38,690
0,540 780,960 960,1170 1170,1410 1410,1590
like this, my bug not

343
00:10:38,690 --> 00:10:39,980
0,150 150,750
your bug,|
|

344
00:10:39,980 --> 00:10:41,620
0,150 150,990
but nevertheless.|
但是不管怎样。|

345
00:10:43,540 --> 00:10:44,500
0,330 330,450 450,630 630,720 720,960
Does it have to do
一定要操作 flags 吗？

346
00:10:44,500 --> 00:10:45,720
0,150 150,690
the flags?|
|

347
00:10:46,270 --> 00:10:49,180
0,600 600,1080 1080,1920
Yes, it does.|
是的，确实如此。|

348
00:10:53,520 --> 00:10:55,230
0,330 330,810 1260,1410 1410,1560 1560,1710
Okay, so I'll just leave
好的，那我把它放在一边，

349
00:10:55,230 --> 00:10:56,130
0,150 150,240 240,360 360,720 720,900
that to the side,| they'll
|它们会再次出现。

350
00:10:56,130 --> 00:10:57,960
0,270 270,420 420,540 540,1110 1380,1830
actually come up again. {}|
|

351
00:10:57,990 --> 00:11:00,390
0,270 270,660 660,990 1770,1950 1950,2400
Another question is we're hoping
另一个问题是我们希望出现保存页面错误，

352
00:11:00,390 --> 00:11:03,030
0,270 300,900 900,1290 1290,2040 2460,2640
for store page faults,| which
|这将驱动复制进程。

353
00:11:03,030 --> 00:11:06,030
0,360 600,1710 1710,1770 1770,2280 2280,3000
will drive the copying process.|
|

354
00:11:07,090 --> 00:11:07,750
0,240 240,420 420,510 510,600 600,660
Why didn't we get a
为什么我们没有得到保存页面错误？

355
00:11:07,750 --> 00:11:09,300
0,300 300,690 690,1260
store page fault?|
|

356
00:11:21,210 --> 00:11:23,320
0,690 780,1380
Alright, um.|
好的，嗯。|

357
00:11:23,750 --> 00:11:24,890
0,450 450,810 810,930 930,1110 1110,1140
Why would we get a
为什么我们会得到保存页面错误？

358
00:11:24,890 --> 00:11:26,860
0,330 330,660 660,1230
store page fault?|
|

359
00:11:27,400 --> 00:11:28,750
0,180 180,330 330,1080 1080,1260 1260,1350
Under what circumstances, does the
RISC-V 在什么情况下会产生保存页面错误。

360
00:11:28,750 --> 00:11:30,560
0,240 240,540 540,1200
{RISC-V -} generate

361
00:11:30,590 --> 00:11:32,660
0,180 180,600 600,900 900,1440
{} store page fault.|
|

362
00:11:34,770 --> 00:11:35,910
0,330 330,480 480,720 720,990 990,1140
We would get if the
如果没有设置写标志，我们会得到，

363
00:11:35,910 --> 00:11:37,470
0,330 330,660 660,810 810,1110 1110,1560
write flag is not set,|
|

364
00:11:37,590 --> 00:11:38,730
0,360 390,690 690,810 810,960 960,1140
but now we can just
但现在我们可以正常地写任何东西。

365
00:11:38,730 --> 00:11:41,340
0,270 270,360 360,1020 1200,2040 2280,2610
write to everything normally.| Yeah,
|是的，设置写标志，

366
00:11:41,340 --> 00:11:42,510
0,210 210,270 270,480 480,840 840,1170
left the write flag set,|
|

367
00:11:42,510 --> 00:11:43,680
0,330 330,420 420,600 600,840 840,1170
alright, so that's bug one|
好的，这就是第一个 bug ，|

368
00:11:43,680 --> 00:11:45,600
0,570 600,780 780,1020 1020,1350 1350,1920
which I did actually make
我上一次做这个实验的时候，

369
00:11:45,900 --> 00:11:46,770
0,360 360,480 480,540 540,690 690,870
last time I did this

370
00:11:46,770 --> 00:11:48,090
0,270 270,660 780,1050 1050,1230 1230,1320
lab,| so I've left the
|所以，我在父级中设置了写标志，

371
00:11:48,090 --> 00:11:48,960
0,180 180,480 480,720 720,810 810,870
write flag set in the

372
00:11:48,960 --> 00:11:50,430
0,540 540,780 780,930 930,1200 1230,1470
parent,| I've done I haven't
|我没有对写标志做任何事情，

373
00:11:50,430 --> 00:11:51,270
0,180 180,480 480,540 540,630 630,840
done anything to the write

374
00:11:51,270 --> 00:11:53,610
0,660 690,1050 1050,1440 1440,1770 1770,2340
flags,| this flags variable here
|这里的标志变量是，

375
00:11:53,910 --> 00:11:55,400
0,360 360,1050
is, {}|
|

376
00:11:55,750 --> 00:11:56,530
0,210 210,390 390,480 480,660 660,780
it's just the way we
就是我们从父页表获得的，

377
00:11:56,530 --> 00:11:57,430
0,300 300,450 450,510 510,600 600,900
pulled out of the parents'

378
00:11:57,430 --> 00:11:58,690
0,270 270,570 570,810 810,990 990,1260
page table,| it's all its
|它的所有页面都是可写的，

379
00:11:58,840 --> 00:12:00,700
0,330 330,480 480,900 1170,1410 1410,1860
pages are writable| and so
|所以这意味着它在子页表也可写，

380
00:12:00,850 --> 00:12:01,540
0,180 180,390 390,480 480,570 570,690
that means that it's going

381
00:12:01,540 --> 00:12:02,110
0,60 60,180 180,360 360,480 480,570
to be {writable -} on

382
00:12:02,110 --> 00:12:02,920
0,90 90,420 420,570 570,660 660,810
the child two,| we won't
|我们不会得到保存页面错误，

383
00:12:02,920 --> 00:12:03,910
0,90 90,360 360,630 630,900 900,990
get store page faults,| so
|所以只是共享一个页面可读写，

384
00:12:03,910 --> 00:12:05,620
0,60 60,720 720,1110 1110,1170 1170,1710
{} just sharing a page

385
00:12:05,710 --> 00:12:07,900
0,570 570,1200 1710,1920 1920,2100 2100,2190
read, write,| {}  which is
|这不是我们想要的，

386
00:12:07,900 --> 00:12:09,100
0,180 180,270 270,390 390,810 960,1200
not what we wanted,| so
|那我怎么才能关掉，

387
00:12:09,100 --> 00:12:09,520
0,120 120,210 210,240 240,360 360,420
how am I going to

388
00:12:09,520 --> 00:12:10,960
0,330 330,840 840,1260 1290,1440 1440,1440
turn off the,| {how,am} I
|我该如何写保护这些页面。

389
00:12:10,960 --> 00:12:13,360
0,240 240,480 480,1140 1230,1650 1650,2400
gonna write protect these pages.|
|

390
00:12:20,930 --> 00:12:23,040
0,240 240,990
Any proposals,
有什么建议吗，我应该输入什么。

391
00:12:23,250 --> 00:12:24,840
0,180 180,300 300,360 360,1110
what should I type.|
|

392
00:12:27,730 --> 00:12:29,240
0,210 210,1080
How about.|
怎么样。|

393
00:12:29,360 --> 00:12:31,700
0,270 270,450 450,810 810,1680 1950,2340
You can do flags {}
你可以使用 flags &= ~PTE_W 。

394
00:12:31,700 --> 00:12:33,540
0,420 450,1380
and equals

395
00:12:33,540 --> 00:12:34,600
0,480
{}

396
00:12:34,600 --> 00:12:39,340
0,360 660,1260 1260,2010 2040,3090 3510,4740
the wave sign {} underscore

397
00:12:40,280 --> 00:12:42,980
0,840 1110,1560 1560,1830 1830,1950 1950,2700
W.| Yeah, yeah we're gonna
|是的，我们需要一个波浪号，

398
00:12:43,010 --> 00:12:44,240
0,300 300,330 330,750 750,1140 1140,1230
need a tilde there,| I
|我把那个波浪标志叫做波浪号，

399
00:12:44,240 --> 00:12:45,500
0,210 210,420 420,660 660,930 930,1260
call that wave sign tilde,|
|

400
00:12:45,500 --> 00:12:47,240
0,240 510,840 840,990 990,1170 1560,1740
the we need to the
我们需要波浪号，

401
00:12:47,240 --> 00:12:48,890
0,390 390,690 900,1200 1200,1530 1530,1650
waves,| the it's clear we
|我们需要清除 flags 上的这一位，

402
00:12:48,890 --> 00:12:49,880
0,90 90,180 210,600 600,810 810,990
need to clear this bit

403
00:12:49,880 --> 00:12:50,690
0,60 60,150 150,570 570,690 690,810
on the flags,| we're going
|我们将保留所有其他 flags 的设置。

404
00:12:50,690 --> 00:12:51,350
0,60 60,210 210,390 390,510 510,660
to leave all the other

405
00:12:51,350 --> 00:12:53,210
0,330 330,660 1080,1410 1410,1560 1560,1860
flags set.| Okay, so that's
|好的，这样清除了父页表还是子页表的标志？

406
00:12:53,210 --> 00:12:54,530
0,420 630,810 810,930 930,1230 1230,1320
gonna with this clear the

407
00:12:54,530 --> 00:12:55,340
0,240 240,330 330,420 420,750 750,810
flag of the parent or

408
00:12:55,340 --> 00:12:56,440
0,90 90,690
the child?|
|

409
00:13:01,870 --> 00:13:04,040
0,570 720,1020 1020,1080 1080,1770
Child?| Just {} child.|
子页表？|只是子页表。|

410
00:13:04,040 --> 00:13:05,150
0,180 180,270 270,390 390,480 480,1110
So how do I clear,|
那么我如何清除，|

411
00:13:05,180 --> 00:13:05,870
0,150 150,240 240,480 480,630 630,690
do I also need to
我需要清除父页表中的标志吗？

412
00:13:05,870 --> 00:13:06,920
0,240 240,360 600,900 900,960 960,1050
clear the flag in the

413
00:13:06,920 --> 00:13:08,200
0,600
parent?|
|

414
00:13:10,390 --> 00:13:13,720
0,600 630,1500 1890,2520 2790,3150 3150,3330
Yes, because {} we want
是的，因为我们希望子页表独立于父页表，

415
00:13:13,720 --> 00:13:15,040
0,120 120,420 420,510 510,630 630,1320
the child to be independent

416
00:13:15,040 --> 00:13:16,150
0,150 150,270 270,750 750,990 990,1110
to the parents,| if we
|如果我们写了一些东西，

417
00:13:16,150 --> 00:13:17,740
0,300 300,870 870,1020 1020,1170 1170,1590
write something,| we don't want
|我们不想让子页表也得到父页表的修改。

418
00:13:17,740 --> 00:13:19,060
0,120 120,480 480,570 570,1080 1080,1320
the child to also get

419
00:13:19,060 --> 00:13:20,650
0,150 150,900 900,1080 1080,1200 1200,1590
them modification from their parents.|
|

420
00:13:20,890 --> 00:13:22,270
0,390 390,810 810,1080 1110,1230 1230,1380
That's absolutely right,| we need
完全正确，|我们也需要对父页表进行写保护，

421
00:13:22,270 --> 00:13:23,140
0,90 90,270 270,570 570,630 630,870
to write protect the page

422
00:13:23,140 --> 00:13:23,860
0,90 90,150 150,420 420,510 510,720
at the parent as well,|
|

423
00:13:23,860 --> 00:13:24,520
0,180 180,270 270,420 420,570 570,660
because we don't want the
因为我们不想让子页表看到父页表的修改，

424
00:13:24,520 --> 00:13:26,200
0,480 480,570 570,720 720,810 810,1680
child to see the parents

425
00:13:26,620 --> 00:13:28,300
0,690 690,750 750,930 930,990 990,1680
modifications,| so trying to mimic,
|所以试图模仿完全不同的副本。

426
00:13:28,880 --> 00:13:30,710
0,90 90,390 390,870 870,1230 1230,1830
{} having completely separate copies.|
|

427
00:13:30,890 --> 00:13:31,970
0,240 240,780 780,900 900,930 930,1080
So what can I do
那么我能怎么来清除父页表中的标志呢？

428
00:13:31,970 --> 00:13:33,830
0,150 450,960 960,1050 1050,1710 1740,1860
to clear the flag in

429
00:13:33,830 --> 00:13:35,900
0,90 90,870 870,1170 1170,1590
the parents' page table?|
|

430
00:13:43,790 --> 00:13:44,930
0,180 180,270 270,450 450,810 810,1140
You can do something like
你可以使用 *pte &= ~PTE ，对吧。

431
00:13:44,930 --> 00:13:48,080
0,390 390,1290 1350,1650 1650,2400 2430,3150
star pte and equals not

432
00:13:48,290 --> 00:13:49,720
0,570 570,870
pte, right.|
|

433
00:13:49,720 --> 00:13:50,530
0,330 390,540 540,630 630,750 750,810
Yeah, so I have the
是的，我有父页表的，

434
00:13:50,530 --> 00:13:51,940
0,540 540,840 840,990 990,1350 1350,1410
parents p-,| a pointer to
|一个指向父页表条目的指针，就在 pte 中，

435
00:13:51,940 --> 00:13:53,260
0,90 90,510 510,810 810,1020 1020,1320
the parents' page table entry

436
00:13:53,260 --> 00:13:54,460
0,270 270,450 450,510 510,900 900,1200
right here in {pte -}|
|

437
00:13:54,970 --> 00:13:56,230
0,600 600,720 720,780 780,870 870,1260
and so I can clear
所以我可以这里清除 PTE 标志，

438
00:13:56,230 --> 00:13:57,460
0,600
the

439
00:13:57,550 --> 00:13:59,020
0,450 450,750 750,900 900,1230 1260,1470
PTE flag here too,| so
|这是很方便的。

440
00:13:59,020 --> 00:14:00,560
0,240 240,420 420,930
that's pretty convenient.|
|

441
00:14:00,980 --> 00:14:02,160
0,630

442
00:14:02,160 --> 00:14:04,500
0,330 870,1650 1650,2010 2010,2130 2130,2340
And my belief is that
我相信这会使页面的两个拷贝，

443
00:14:04,500 --> 00:14:06,220
0,450 450,750 780,1110
enough to make

444
00:14:06,460 --> 00:14:07,900
0,270 270,720 720,780 780,870 870,1440
both copies of the page,|
|

445
00:14:07,900 --> 00:14:08,860
0,60 60,270 270,810 810,870 870,960
so both mappings of the
页面的两个映射都是只读的。

446
00:14:08,860 --> 00:14:10,220
0,810
page

447
00:14:11,420 --> 00:14:13,000
0,360 360,960
read only.|
|

448
00:14:13,000 --> 00:14:14,230
0,180 180,480 480,780 780,900 900,1230
So hopefully now we'll start
所以，希望现在我们可以得到写入错误。

449
00:14:14,230 --> 00:14:15,920
0,450 450,1080
getting {}

450
00:14:17,230 --> 00:14:18,860
0,330 330,990
write faults.|
|

451
00:14:19,330 --> 00:14:21,640
0,150 150,360 690,1200 1200,1770 1800,2310
Is it possible to do
是否可以清除 PTE_W 位，

452
00:14:21,640 --> 00:14:22,930
0,150 150,630 630,780 780,990 990,1290
to clear the {PTE_W -

453
00:14:22,930 --> 00:14:25,000
0,450 450,690 690,1560 1560,1830 1830,2070
-} bit,| before you say
|在 flags = PTE_FLAGS(*pte) 之前，

454
00:14:25,000 --> 00:14:28,000
0,510 510,870 870,1320 1320,1860 2250,3000
flags equals {PTE_FLAGS -} {of,pte},|
|

455
00:14:28,600 --> 00:14:29,500
0,150 150,330 330,570 570,810 810,900
and that way like the
这样原来的 flags 才是正确的。

456
00:14:29,500 --> 00:14:31,510
0,450 450,810 810,990 990,1410 1890,2010
original flags is just the

457
00:14:31,510 --> 00:14:32,950
0,300 300,600 810,1020 1020,1050 1050,1440
correct thing.| {} Oh I
|哦，我明白了，把东西放在这里。

458
00:14:32,950 --> 00:14:34,060
0,330 330,600 600,780 780,990 990,1110
see, you put away up

459
00:14:34,060 --> 00:14:36,700
0,750 960,1410 1650,2310 2310,2520 2520,2640
here.| Yeah.| Yeah, I'll get
|是的。|好的，我会试一下，

460
00:14:36,700 --> 00:14:38,140
0,180 180,510
that shot,|
|

461
00:14:46,080 --> 00:14:47,580
0,300 300,360 360,930
seems to work,
似乎正常工作了，那就说得通了。

462
00:14:47,580 --> 00:14:49,040
0,180 180,360 360,840
that makes sense.|
|

463
00:14:50,860 --> 00:14:51,910
0,510 540,750 750,840 840,930 930,1050
Okay, so now I get
好了，我现在得到了写入错误，

464
00:14:51,910 --> 00:14:53,440
0,90 90,360 360,840
my write fault,|
|

465
00:14:53,630 --> 00:14:55,200
0,870

466
00:14:55,230 --> 00:14:56,070
0,240 240,330 330,480 480,570 570,840
which is what we're hoping
正是我们所希望的，

467
00:14:56,070 --> 00:14:57,420
0,270 300,600 600,1020 1020,1200 1200,1350
for| and hopefully what this
|这个写入错误意味着

468
00:14:57,420 --> 00:14:58,320
0,330 330,540 540,630 630,720 720,900
{write,fault} means is| that one
|其他进程试图修改这个页面，

469
00:14:58,320 --> 00:14:59,430
0,60 60,120 120,300 300,900 900,1110
of the other processes tried

470
00:14:59,430 --> 00:15:00,630
0,60 60,330 330,420 420,870 870,1200
to modify the page| and
|而 RISC-V 对此产生了页面错误。

471
00:15:00,870 --> 00:15:02,400
0,420 420,540 540,750 750,1020 1020,1530
{} the {RISC-V -} generated

472
00:15:02,400 --> 00:15:03,450
0,60 60,330 330,570 570,720 720,1050
a page fault from that.|
|

473
00:15:04,080 --> 00:15:05,600
0,390 390,870
And, {}
我们要[]它，

474
00:15:05,660 --> 00:15:06,590
0,210 210,360 360,510 510,600 600,930
we're gonna want to []

475
00:15:06,590 --> 00:15:08,240
0,90 90,390 390,1050
to that| by
|通过复制这个页面，并映射为读写。

476
00:15:08,330 --> 00:15:09,620
0,510
{}

477
00:15:11,150 --> 00:15:12,110
0,270 270,510 510,600 600,900 900,960
{} making a copy of

478
00:15:12,110 --> 00:15:13,790
0,90 90,750 1080,1320 1320,1560 1560,1680
the page and mapping it

479
00:15:13,790 --> 00:15:15,800
0,180 180,510 840,1290 1440,1890 1890,2010
read write.| {} Before we
|在我们这样做之前，

480
00:15:15,800 --> 00:15:17,540
0,120 120,510 1020,1470 1470,1530 1530,1740
do that,| just to make
|为了确保我们所看到的，

481
00:15:17,540 --> 00:15:19,760
0,420 420,870 1020,1500 1500,1620 1620,2220
sure that what we're seeing,|
|

482
00:15:19,760 --> 00:15:21,290
0,150 150,210 210,660 660,960 960,1530
you know this, this, this
你知道这里的 f ，这个 scause ，

483
00:15:21,320 --> 00:15:23,900
0,450 450,1320 1560,1830 1830,2010 2010,2580
f here, this {scause -},|
|

484
00:15:24,260 --> 00:15:25,760
0,420 450,570 570,780 780,960 1080,1500
that is sort of making
让我想到，

485
00:15:25,760 --> 00:15:27,470
0,90 90,630 630,810 810,1110 1380,1710
{} imagine that| we're seeing
|我们希望是保存错误，

486
00:15:27,470 --> 00:15:28,100
0,90 90,150 150,360 360,420 420,630
what we want to see

487
00:15:28,100 --> 00:15:29,120
0,300 300,330 330,690 690,870 870,1020
namely a store fault,| let's
|让我们看看实际发生了什么。

488
00:15:29,120 --> 00:15:30,680
0,210 210,300 300,690 690,930 960,1560
actually go look and see

489
00:15:30,680 --> 00:15:33,140
0,210 210,390 390,900
where that happened.|
|

490
00:15:33,170 --> 00:15:34,370
0,240 240,360 360,510 510,900 900,1200
We know it's process id
我们知道这是进程 id 是 3 ，

491
00:15:34,370 --> 00:15:36,230
0,750 780,1020 1020,1320 1320,1530 1530,1860
3,| {} process id 1
|进程 id 1 是 init ，

492
00:15:36,230 --> 00:15:37,550
0,120 120,180 180,690 690,990 990,1320
is {init -},| process id
|进程 id 2 是 shell ，

493
00:15:37,550 --> 00:15:40,370
0,510 510,750 750,1260 1590,2340 2670,2820
2 is the shell| and
|所以进程 id 3 可能是 cowtest 。

494
00:15:40,370 --> 00:15:41,660
0,120 120,360 360,780 780,1050 1050,1290
so maybe process id 3

495
00:15:41,660 --> 00:15:42,560
0,150 150,300 300,360 360,600 600,900
is going to be {cowtest

496
00:15:42,560 --> 00:15:43,680
0,630
-}.|
|

497
00:15:43,680 --> 00:15:45,000
0,180 180,330 330,480 480,720 720,1320
{} We can look in,
我们可以看看 cowtest.asm 。

498
00:15:51,320 --> 00:15:52,700
0,180 180,360 360,630 630,960 960,1380
we can look in {cowtest.asm

499
00:15:52,700 --> 00:15:54,880
0,810 810,1590
- -}.|
|

500
00:15:54,910 --> 00:15:58,180
0,360 360,570 570,1380 1830,2550 2580,3270
And look for {9da -}|
看看 9da ，|

501
00:15:58,180 --> 00:15:59,110
0,150 150,390 390,540 540,630 630,930
and see if it makes
它是否是一个可以生成保存页面错误的指令。

502
00:15:59,110 --> 00:16:00,940
0,420 420,570 570,810
sense, as a

503
00:16:01,580 --> 00:16:04,100
0,1170 1260,1530 1530,1770 1770,2340 2340,2520
instruction that could generate a

504
00:16:04,100 --> 00:16:06,080
0,630 630,990 990,1530
store page fault.|
|

505
00:16:08,880 --> 00:16:10,380
0,330 330,510 510,690 690,840 840,1500
Oops, don't look so good.|
糟糕，看起来不太好。|

506
00:16:11,680 --> 00:16:13,220
0,870

507
00:16:14,480 --> 00:16:15,530
0,240 240,420 420,690 690,900 900,1050
I can't remember what {auipc
我不记得 auipc 是做什么的，

508
00:16:15,530 --> 00:16:16,700
0,360 360,690 690,960 960,1110 1110,1170
- -} does,| but I
|但我不相信它有保存的操作。

509
00:16:16,700 --> 00:16:18,290
0,180 180,510 510,810 960,1500 1500,1590
don't believe it performs a

510
00:16:18,290 --> 00:16:19,560
0,540
store.|
|

511
00:16:20,120 --> 00:16:21,290
0,240 240,360 360,720 720,930 930,1170
{Any -} guesses what's going
有人想到，发生了什么事吗？

512
00:16:21,290 --> 00:16:22,700
0,420
on?|
|

513
00:16:29,000 --> 00:16:30,140
0,150 150,240 240,600 600,750 750,1140
It'd be nice, if the
如果看到的页面错误有意义，那就太好了。

514
00:16:30,680 --> 00:16:31,820
0,480 480,600 600,660 660,870 870,1140
{page,fault} who are seeing actually

515
00:16:31,820 --> 00:16:33,480
0,180 180,720
make sense.|
|

516
00:16:36,580 --> 00:16:39,100
0,630 840,1380 1380,1650 1650,2160 2190,2520
{} I'll tell you, {}
我告诉你，这个页面错误发生在 shell 中，

517
00:16:39,100 --> 00:16:40,720
0,150 150,420 420,570 570,1050 1200,1620
it turns out this page

518
00:16:40,720 --> 00:16:41,680
0,420
fault

519
00:16:41,770 --> 00:16:43,900
0,750 780,960 960,1050 1050,1710 1740,2130
occurred in the shell| after
|在 shell fork 之后， exec cowtest 之前，

520
00:16:43,900 --> 00:16:45,700
0,60 60,360 360,750 750,1050 1050,1800
the shell fork, but before

521
00:16:45,700 --> 00:16:47,950
0,270 300,1020 1020,1290 1290,1920 2070,2250
it exec {cowtest -}| and
|所以，我们查看的是错误的 asm 文件，

522
00:16:47,950 --> 00:16:48,700
0,120 120,210 210,420 420,660 660,750
so we're really looking at

523
00:16:48,700 --> 00:16:50,200
0,60 60,510 510,720 720,900 900,1500
the wrong {asm -} file,|
|

524
00:16:50,700 --> 00:16:51,570
0,240 240,330 330,420 420,690 690,870
turns out the right {asm
正确的 asm 文件是 shell.asm 文件，

525
00:16:51,570 --> 00:16:53,370
0,90 90,450 450,840 840,1290 1290,1800
-} {file,is} {shell.asm -} file,|
|

526
00:16:53,370 --> 00:16:55,530
0,300 510,660 660,1020 1020,1530 1530,2160
{we'll,look} for {9da -} there.|
我们去那里找 9da 。|

527
00:16:56,880 --> 00:16:58,440
0,510 510,750 750,1020 1350,1470 1470,1560
{} Yes, and in the
是的，在 shell 中， 9da 是一条存储指令，

528
00:16:58,440 --> 00:17:00,240
0,420 420,1140 1170,1350 1350,1440 1440,1800
shell 9da is a store

529
00:17:00,240 --> 00:17:01,950
0,720 1020,1200 1200,1470 1470,1590 1590,1710
instruction| and it's at the
|它位于这个 parsecmd 函数的开头，

530
00:17:01,950 --> 00:17:04,050
0,840 900,1110 1110,1320 1320,1680 1680,2100
beginning of this {parsecmd -}

531
00:17:04,050 --> 00:17:06,060
0,450 450,570 570,1140 1470,1920 1920,2010
function,| that actually parses the
|它解析我们输入的 cowtest 命令，

532
00:17:06,060 --> 00:17:07,470
0,240 240,840 870,1230 1230,1320 1320,1410
{cowtest -} command that we

533
00:17:07,470 --> 00:17:09,180
0,480 480,600 600,930 930,1260 1470,1710
typed| and figures out what
|并如何处理它，也就是 exec ，

534
00:17:09,180 --> 00:17:09,990
0,90 90,210 210,360 360,540 540,810
to do with it, namely

535
00:17:09,990 --> 00:17:11,910
0,240 240,780 1440,1680 1680,1860 1860,1920
call exec,| as doing a
|就像保存到堆栈一样，

536
00:17:11,910 --> 00:17:13,950
0,450 450,600 600,720 720,1410 1560,2040
store into the stack,| it's
|它是前言，保存被调用者保存寄存器。

537
00:17:13,950 --> 00:17:15,570
0,120 120,600 600,720 720,1260 1260,1620
the preamble that stores the

538
00:17:16,860 --> 00:17:20,860
0,960 960,1530 1530,2520
callee saved registers.|
|

539
00:17:20,920 --> 00:17:22,150
0,210 210,360 360,900 900,1080 1080,1230
And not surprisingly that,| this
这不令人惊讶，|这应该是我们收到的第一个页面错误，

540
00:17:22,150 --> 00:17:23,260
0,180 180,480 480,600 600,870 870,1110
should be the first page

541
00:17:23,260 --> 00:17:24,730
0,210 210,300 300,600 600,1080 1290,1470
fault we get,| because it's
|因为它在堆栈上，

542
00:17:24,730 --> 00:17:25,720
0,120 120,210 210,780 810,900 900,990
on the stack,| you know
|函数在 fork 之后做的第一件事返回是

543
00:17:25,720 --> 00:17:26,830
0,120 270,570 570,810 810,930 930,1110
the very first thing those

544
00:17:26,830 --> 00:17:28,420
0,390 390,600 600,870 870,1140 1140,1590
functions do after fork returns

545
00:17:28,420 --> 00:17:29,800
0,150 150,330 330,780 780,900 900,1380
is| they modify their variables
|它们修改在堆栈中的变量，

546
00:17:29,800 --> 00:17:30,880
0,60 60,120 120,480 480,600 600,1080
in the stack| and boom,
|然后砰的一声，不出所料，这导致了保存页面错误。

547
00:17:31,180 --> 00:17:33,550
0,570 1020,1710 1710,1860 1860,2250 2250,2370
{} unsurprisingly that causes a

548
00:17:33,550 --> 00:17:34,980
0,420 420,690 690,960
store page fault.|
|

549
00:17:35,440 --> 00:17:37,000
0,210 210,660 660,1020
Any questions about
关于为什么得到错误，有什么问题吗？

550
00:17:37,050 --> 00:17:38,760
0,330 330,480 480,990
why we're faulting?|
|

551
00:17:41,600 --> 00:17:42,680
0,210 210,300 300,360 360,570 570,1080
I have a quick question,|
我有一个简短的问题，|

552
00:17:42,680 --> 00:17:43,640
0,240 240,360 360,540 540,840 840,960
how did you figure out
你怎么知道是在 shell 中而不是 cowtest ？

553
00:17:43,640 --> 00:17:45,170
0,90 90,330 330,840 930,1080 1080,1530
it was in the shell

554
00:17:45,170 --> 00:17:47,140
0,330 330,540 540,690 690,1500
rather than in cowtest?|
|

555
00:17:47,300 --> 00:17:49,310
0,510 510,1230 1260,1560 1560,1920 1920,2010
{} Because I looked at
因为我在 cowtest 里面看到 9da ，

556
00:17:49,310 --> 00:17:51,020
0,420 420,600 600,960 960,1440 1530,1710
{9da -} in cowtest| and
|而那个不是保存指令。

557
00:17:51,020 --> 00:17:51,950
0,90 90,210 210,510 510,600 600,930
that is not a store

558
00:17:51,950 --> 00:17:53,800
0,570
instruction.|
|

559
00:17:53,800 --> 00:17:56,710
0,180 180,600 810,1770 2490,2790 2790,2910
I thought gosh what could
我想，天哪，这是怎么回事。

560
00:17:56,710 --> 00:17:58,460
0,450 450,570 570,840 840,1290
possibly be going on.|
|

561
00:17:59,430 --> 00:18:01,080
0,420 420,600 600,660 660,1140 1140,1650
Now, look at {process,id}.| Three,
现在，看看进程 id 。|那么 pid 3 是 shell ，还是。

562
00:18:01,110 --> 00:18:02,010
0,210 210,360 360,600 600,810 810,900
so is pid 3 to

563
00:18:02,010 --> 00:18:03,630
0,420 450,660 660,840 1080,1260 1260,1620
shell or is it.| {Pid,3}
|pid 3 是， pid 2 是打印提示符的 shell ，

564
00:18:03,630 --> 00:18:05,400
0,510 930,1230 1230,1530 1530,1650 1650,1770
is, pid 2 is the

565
00:18:05,400 --> 00:18:07,110
0,390 390,510 510,810 810,1020 1020,1710
shell that printed that prompt,|
|

566
00:18:07,440 --> 00:18:09,240
0,480 480,1200 1200,1350 1350,1470 1470,1800
pid 3 is the next
pid 3 它创建的下一个进程，

567
00:18:09,240 --> 00:18:11,220
0,420 420,600 600,1350 1620,1830 1830,1980
process that's created| and so
|所以最初 shell fork 得到 pid 3 。

568
00:18:11,220 --> 00:18:13,460
0,510 510,630 630,870 870,1830
initially the shell forks

569
00:18:14,590 --> 00:18:16,380
0,360 360,630 630,1230
{to,make} pid 3.|
|

570
00:18:16,380 --> 00:18:17,160
0,90 90,300 300,390 390,630 630,780
But after the fork, it's
但 fork 之后，它仍在运行 shell ，

571
00:18:17,160 --> 00:18:19,500
0,690 690,1020 1020,1110 1110,1890 2070,2340
still running the shell,| it's
|它是 shell 的子进程运行着 shell ，

572
00:18:19,500 --> 00:18:20,580
0,60 60,510 510,570 570,660 660,1080
a child of the shell

573
00:18:20,580 --> 00:18:21,800
0,600
running

574
00:18:22,320 --> 00:18:23,610
0,120 120,540 540,630 630,720 720,1290
a copy of the shell,|
|

575
00:18:23,820 --> 00:18:25,920
0,360 360,840 840,1200 1200,1530 1530,2100
it's going to call exec
它将调用 exec 来运行 cowtest ，

576
00:18:25,950 --> 00:18:26,970
0,180 180,330 330,840 840,960 960,1020
to run cowtest,| but it
|但它还没有做，

577
00:18:26,970 --> 00:18:28,440
0,270 270,450 450,540 540,990
hasn't done it yet,|
|

578
00:18:28,980 --> 00:18:29,850
0,240 240,360 360,600 600,690 690,870
{} it hasn't been able
它没有到达那里，

579
00:18:29,850 --> 00:18:30,870
0,60 60,240 240,450 450,690 690,1020
to get that far,| with
|因为当它写入堆栈时，得到一个保存页面错误。

580
00:18:30,870 --> 00:18:32,340
0,240 240,300 300,630 630,930 930,1470
taking a store page fault,

581
00:18:35,320 --> 00:18:36,520
0,450 480,750 750,900 900,1110 1110,1200
{} when it writes to

582
00:18:36,520 --> 00:18:37,580
0,570
stack.|
|

583
00:18:38,900 --> 00:18:40,010
0,240 240,390 390,510 510,990 990,1110
So, can you clarify,| does
那么，您能澄清一下，|这是否意味着进程 id 为 2 的 shell 存在错误，

584
00:18:40,010 --> 00:18:41,360
0,210 210,360 360,600 600,960 960,1350
that mean that there's an

585
00:18:41,450 --> 00:18:44,300
0,780 870,1350 1350,1560 1560,2370 2460,2850
error with the shell related

586
00:18:44,300 --> 00:18:45,770
0,390 390,750 750,1080 1080,1380 1380,1470
process id 2,| because it
|因为它没有正确的数据让子进程拥有正确的数据，

587
00:18:45,770 --> 00:18:47,690
0,390 420,840 840,960 960,1320 1320,1920
doesn't have the proper data

588
00:18:47,930 --> 00:18:49,790
0,150 150,420 420,930 960,1200 1290,1860
in order for the child

589
00:18:49,790 --> 00:18:50,600
0,90 90,300 300,360 360,540 540,810
to have the right data|
|

590
00:18:50,600 --> 00:18:51,860
0,270 270,390 390,480 480,780 870,1260
or is it a error
或者是进程 id 为 3 的错误。

591
00:18:51,860 --> 00:18:54,260
0,330 330,840 840,1320 1320,1950
with process id 3.|
|

592
00:18:55,190 --> 00:18:57,000
0,180 180,270 270,690 690,1200
It's a page fault,
这是一个页面错误，发生在进程 id 3 中。

593
00:18:57,000 --> 00:18:58,500
0,90 90,510 510,750 750,1200 1200,1500
that occurs in process id

594
00:18:58,500 --> 00:18:59,740
0,690
3.|
|

595
00:19:00,620 --> 00:19:01,580
0,330 330,450 450,570 570,810 810,960
Right, but the bug that
是的，但是我们看到的 bug 就像。

596
00:19:01,580 --> 00:19:03,320
0,120 120,510 510,720 720,900 900,1740
we're seeing right here like.|
|

597
00:19:05,380 --> 00:19:07,810
0,450 450,870 990,1890 1890,2280 2280,2430
This is implementing {copy-on-write -
这是在实现写入时复制 fork ，

598
00:19:07,810 --> 00:19:10,720
0,480 510,1350 1830,2370 2400,2610 2610,2910
-} fork| and what we
|我们刚才在 vm.c 中所做的是

599
00:19:10,720 --> 00:19:12,760
0,570 570,1020 1020,1410 1410,1800 1800,2040
just did in {vm.c -

600
00:19:12,760 --> 00:19:16,450
0,540 540,1110 1140,2040 2040,2880 3090,3690
-} was| write protect every
|写保护父进程和子进程中的每一页。

601
00:19:16,450 --> 00:19:18,100
0,450 450,1020 1020,1140 1140,1230 1230,1650
single page in the parent

602
00:19:18,100 --> 00:19:19,600
0,120 120,180 180,930
and the child,

603
00:19:19,600 --> 00:19:20,820
0,840
right.|
|

604
00:19:20,820 --> 00:19:21,600
0,150 150,270 270,450 450,660 660,780
That's what this line is
这是这行正在做的事情，

605
00:19:21,600 --> 00:19:23,550
0,420 720,1200 1260,1440 1440,1710 1710,1950
doing,| so the next time
|所以，下次父进程或子进程在用户代码有保存时，

606
00:19:23,550 --> 00:19:24,540
0,360 360,450 450,780 780,900 900,990
either the parent or the

607
00:19:24,540 --> 00:19:26,280
0,330 330,450 450,540 540,1290 1440,1740
child has a store from

608
00:19:26,280 --> 00:19:27,620
0,270 270,810
user code,|
|

609
00:19:27,710 --> 00:19:28,250
0,180 180,330 330,390 390,480 480,540
it's going to be a
它将保存到写保护页中，

610
00:19:28,250 --> 00:19:29,570
0,330 330,510 510,660 660,870 870,1320
store into a write protected

611
00:19:29,570 --> 00:19:30,860
0,570 600,780 780,960 960,1200 1200,1290
page,| because every page is
|因为每一页都是写保护的，

612
00:19:30,860 --> 00:19:32,150
0,180 180,810 900,1080 1080,1230 1230,1290
write protected,| and so it
|所以它会导致页面错误。

613
00:19:32,150 --> 00:19:33,650
0,330 330,630 630,690 690,960 960,1500
will cause a page fault.|
|

614
00:19:34,330 --> 00:19:35,200
0,390 390,480 480,660 660,750 750,870
Oh, so this is the
哦，这就是我们想要的页面错误。

615
00:19:35,200 --> 00:19:36,430
0,390 390,690 690,930 930,1080 1080,1230
proper page fault that we

616
00:19:36,430 --> 00:19:37,780
0,330 360,960 960,1230 1230,1320 1320,1350
want.| This, right and I
|对，我只是在检查那个，

617
00:19:37,780 --> 00:19:39,220
0,150 150,450 1110,1260 1260,1350 1350,1440
was just all I was

618
00:19:39,220 --> 00:19:41,500
0,210 210,390 390,1080 1080,1740
doing was checking that,|
|

619
00:19:42,430 --> 00:19:43,600
0,330 330,600 600,810 810,1050 1050,1170
that what's going on is
所发生的事情正是我们认为的，

620
00:19:43,600 --> 00:19:44,740
0,510 510,660 660,810 810,1020 1020,1140
exactly what we think is

621
00:19:44,740 --> 00:19:46,300
0,240 240,690 960,1170 1170,1470 1470,1560
going on,| as opposed to
|而不是其他的 bug 。

622
00:19:46,300 --> 00:19:49,960
0,210 210,420 420,930 2340,2850 3330,3660
some other bug.| Okay alright.|
|好的。|

623
00:19:49,960 --> 00:19:50,560
0,120 120,180 180,300 300,360 360,600
So we took a page
所以我们在这里得到一个保存页面错误，

624
00:19:50,560 --> 00:19:51,820
0,240 240,450 450,510 510,660 660,1260
fault here in this store|
|

625
00:19:51,820 --> 00:19:52,960
0,150 150,240 240,660 660,780 780,1140
which is presumably the first
是 shell 在 fork 之后的第一个保存。

626
00:19:52,960 --> 00:19:54,040
0,240 240,330 330,570 570,780 780,1080
store the shell does after

627
00:19:54,040 --> 00:19:55,160
0,90 90,630
the fork.|
|

628
00:19:55,220 --> 00:19:56,660
0,840

629
00:19:57,090 --> 00:19:57,930
0,420 420,570 570,690 690,750 750,840
Okay, so now we have
好的，所以现在我们要处理这些，

630
00:19:57,930 --> 00:20:00,020
0,90 90,510 510,840 840,1290
to handle these, {}|
|

631
00:20:00,020 --> 00:20:00,590
0,210 210,270 270,390 390,450 450,570
now you want to do
现在你要在这个页面错误中做一些有用的事情。

632
00:20:00,590 --> 00:20:02,520
0,300 300,960
something useful

633
00:20:02,800 --> 00:20:04,570
0,150 150,330 330,660 660,1230 1290,1770
in this page fault.| So,
|所以， trap.c 和用户错误中的页面错误处理程序。

634
00:20:04,570 --> 00:20:06,010
0,0 600,810 810,900 900,1170 1170,1440
{} where's the page fault

635
00:20:06,010 --> 00:20:08,710
0,660 660,840 1260,1830 1830,2040 2040,2700
handlers in {trap.c - -}

636
00:20:09,590 --> 00:20:11,040
0,840
and

637
00:20:11,390 --> 00:20:13,060
0,480 480,1140
user fault.|
|

638
00:20:13,790 --> 00:20:15,040
0,660

639
00:20:16,020 --> 00:20:17,460
0,210 210,330 330,600 1020,1200 1200,1440
I think it pretty much
我想我们在哪里插入代码无关紧要。

640
00:20:17,460 --> 00:20:18,930
0,330 330,630 630,840 840,990 990,1470
doesn't matter where we insert

641
00:20:18,930 --> 00:20:20,960
0,570 570,870 870,1410
code to. {}|
|

642
00:20:20,960 --> 00:20:22,190
0,30 30,330 330,870 870,960 960,1230
I mean, there's all these
我是说，这里有很多不同的 uservec 的情况，

643
00:20:22,190 --> 00:20:24,590
0,270 270,690 690,960 960,1170 1650,2400
different cases here that {uservec

644
00:20:24,590 --> 00:20:27,170
0,810 870,1110 1110,1350 1350,1890 2400,2580
-},| this {uservec -} or
|uservec 或 usertrap ，

645
00:20:27,170 --> 00:20:28,100
0,180 180,270 270,600 600,720 720,930
{usertrap - -},| the {usertrap
|usertrap 就是添加另一个 usertrap ，

646
00:20:28,100 --> 00:20:29,810
0,270 270,390 390,720 720,1080 1350,1710
-} is dealing with just

647
00:20:29,810 --> 00:20:30,560
0,120 120,180 180,390 390,480 480,750
going to throw in another

648
00:20:30,560 --> 00:20:33,950
0,810 1140,1770 2160,2640 2640,2940 2940,3390
else,| {} we only interested
|我们只对写入错误感兴趣，

649
00:20:33,950 --> 00:20:35,390
0,180 180,420 420,1080 1080,1170 1170,1440
in write faults,| we're happy
|我们很高兴读这些共享页面，

650
00:20:35,390 --> 00:20:36,890
0,90 90,600 600,750 750,1020 1020,1500
to read these shared pages,|
|

651
00:20:36,890 --> 00:20:38,600
0,630 660,900 900,1020 1020,1260 1260,1710
because all that is there,
因为所有的东西都在那里，只是写[]，

652
00:20:39,040 --> 00:20:40,000
0,180 180,330 330,510 510,750 750,960
{} it's just write to

653
00:20:40,000 --> 00:20:41,660
0,90 90,150 150,630 630,1050
on {} [],| so.|
|所以。|

654
00:20:47,620 --> 00:20:48,900
0,660
Now,
现在，我相信你知道，

655
00:20:48,900 --> 00:20:50,220
0,60 60,300 300,510 510,840 1110,1320
it turns out as, I'm

656
00:20:50,220 --> 00:20:51,570
0,180 180,300 300,630 630,990 1170,1350
sure you know,| that we're
|我们将需要使用代码，

657
00:20:51,570 --> 00:20:52,410
0,120 120,210 210,390 390,510 510,840
going to need to use

658
00:20:52,410 --> 00:20:53,550
0,150 150,570 570,840 840,930 930,1140
the code,| {I'm,about} to write
|我要在两个不同的地方写代码，

659
00:20:53,550 --> 00:20:55,140
0,150 150,330 330,570 570,1290 1320,1590
from two different places,| I'm
|我要把它封装在代码中，

660
00:20:55,140 --> 00:20:56,380
0,330 330,630
going to

661
00:20:56,380 --> 00:20:57,340
0,210 210,450 450,540 540,780 780,960
just wrap it up in

662
00:20:57,340 --> 00:20:58,320
0,390
{}

663
00:20:58,970 --> 00:21:00,800
0,210 210,390 390,870 870,1110 1440,1830
{} the code,| that makes
|让页面的复制在一个函数中，我称为 cowfault 。

664
00:21:00,800 --> 00:21:02,120
0,90 90,450 450,510 510,660 660,1320
the copy of this page

665
00:21:02,300 --> 00:21:03,680
0,390 390,690 690,1140 1140,1230 1230,1380
in a function, I'm gonna

666
00:21:03,680 --> 00:21:05,460
0,210 210,540 540,1200
call {cowfault -}.|
|

667
00:21:05,930 --> 00:21:06,890
0,300 300,450 450,630 630,720 720,960
{} It needs to know
它需要知道当前的页表，

668
00:21:06,890 --> 00:21:09,110
0,120 120,390 390,690 690,1200 1650,2220
the current page table| and
|也需要知道我们在 stval 上出错的虚拟地址。

669
00:21:09,110 --> 00:21:09,950
0,60 60,270 270,360 360,600 600,840
it needs to know the

670
00:21:09,950 --> 00:21:11,270
0,330 330,720 720,810 810,930 930,1320
virtual address that we faulted

671
00:21:11,270 --> 00:21:13,800
0,510 840,1500 1500,2010
on {stval -}.|
|

672
00:21:13,960 --> 00:21:15,610
0,360 360,780 780,870 870,990 990,1650
{} Sometimes it can fail,
有时它可能会因为内存不足而失败，

673
00:21:15,670 --> 00:21:16,960
0,600 600,840 840,990 990,1170 1170,1290
because say it runs out

674
00:21:16,960 --> 00:21:19,960
0,60 60,630 1560,1890 1890,2370 2400,3000
of memory,| maybe kall- kalloc
|可能 kalloc 会失败，

675
00:21:19,960 --> 00:21:20,560
0,90 90,300 300,420 420,480 480,600
will fail,| so we need
|所以我们需要为返回值做好准备。

676
00:21:20,560 --> 00:21:21,520
0,60 60,480 480,600 600,630 630,960
to prepare for {} return

677
00:21:21,520 --> 00:21:23,110
0,450 750,1140 1170,1350 1350,1500 1500,1590
value.| And pretty much no
|不管失败的原因是什么，

678
00:21:23,110 --> 00:21:24,610
0,180 180,300 300,390 390,900 900,1500
matter what the failure is,|
|

679
00:21:25,190 --> 00:21:26,510
0,480 510,660 660,840 840,1140 1140,1320
{} we're gonna kill this
我们都会杀死这个进程，

680
00:21:26,510 --> 00:21:27,880
0,870
process,

681
00:21:28,350 --> 00:21:29,550
0,420 480,690 690,780 780,960 960,1200
right,| if we didn't kill
|如果我们没有杀死它，

682
00:21:29,550 --> 00:21:30,990
0,150 510,750 750,990 990,1170 1170,1440
it,| {} we'll have {cowfault
|如果出现失败，我们让 cowfault 返回 -1 ，

683
00:21:30,990 --> 00:21:32,160
0,210 210,480 480,810 810,1080 1080,1170
-} return {-1 -}, if

684
00:21:32,160 --> 00:21:34,260
0,120 120,180 180,780 1080,1920 1920,2100
there's a failure,| returns 0,
|如果没有失败，则返回 0 。

685
00:21:34,260 --> 00:21:36,150
0,90 90,240 240,390 390,960 1470,1890
if there's no failure.| There's
|如果没有失败，

686
00:21:36,150 --> 00:21:37,590
0,120 120,570 570,840 840,1170 1200,1440
no failure,| then we're going
|我们将依赖于 cowfault 使虚拟地址可写，

687
00:21:37,590 --> 00:21:38,520
0,60 60,330 330,390 390,660 660,930
to rely on {cowfault -}

688
00:21:38,520 --> 00:21:40,110
0,210 210,450 450,840 840,1230 1230,1590
having made this virtual address

689
00:21:40,110 --> 00:21:41,610
0,240 240,570 690,870 870,1020 1020,1500
{writable -},| so that when
|所以当 usertrap 返回时，

690
00:21:41,640 --> 00:21:43,020
0,300 300,510 510,900 900,990 990,1380
{usertrap -} returns,| the process
|这个进程可以继续成功。

691
00:21:43,020 --> 00:21:45,400
0,240 540,900 900,1290 1290,1950
can actually continue successfully.|
|

692
00:21:47,510 --> 00:21:50,600
0,870 1590,1950 1950,2100 2100,2460 2550,3090
Why that you put, {}|
为什么这么放，|

693
00:21:50,600 --> 00:21:51,650
0,240 240,450 450,600 600,630 630,1050
like is there a reason|
有没有理由|

694
00:21:51,770 --> 00:21:52,880
0,150 150,300 300,540 540,810 810,1110
why you put this line
为什么把这一行放在 else if devintr 之上。

695
00:21:52,880 --> 00:21:55,280
0,720 1110,1290 1290,1620 1620,2040 2070,2400
above the else if which

696
00:21:55,280 --> 00:21:58,180
0,330 330,540 540,960
dev- {devintr -}.|
|

697
00:21:59,520 --> 00:22:01,260
0,180 180,300 300,450 450,720 1230,1740
I don't think so, {}|
我不这样认为,|

698
00:22:01,410 --> 00:22:03,630
0,420 420,540 540,990 1680,1920 1920,2220
whether it's correct {} depends
它是否正确，取决于 devintr 做了什么，

699
00:22:03,630 --> 00:22:04,740
0,60 60,240 240,420 420,630 630,1110
on what {devintr -} does,|
|

700
00:22:04,740 --> 00:22:06,330
0,480 510,720 720,750 750,1200 1230,1590
just take a look,| the
查看一下，|风险是 devintr 可能会，

701
00:22:06,330 --> 00:22:08,310
0,300 300,420 420,690 840,1290 1290,1980
risk is that devintr might,|
|

702
00:22:08,370 --> 00:22:09,860
0,870

703
00:22:10,080 --> 00:22:12,060
0,870 870,960 960,1470 1470,1890 1890,1980
see a device interrupt for
因为某种原因看到设备中断，

704
00:22:12,060 --> 00:22:13,230
0,270 270,660 690,930 930,1050 1050,1170
some reason,| even though we
|即使我们出现了页面错误。

705
00:22:13,230 --> 00:22:14,130
0,90 90,150 150,210 210,570 570,900
are on a page fault.|
|

706
00:22:14,700 --> 00:22:15,840
0,150 150,210 210,480 480,660 660,1140
So we just gotta check
所以我们只要看看 devintr ，

707
00:22:15,840 --> 00:22:18,340
0,240 240,540 540,960 1260,1920
that {devintr -}, {}|

708
00:22:18,340 --> 00:22:20,720
0,390 390,540 540,750 750,1470
looks at {scause -},
看一下 scause 是 f ，

709
00:22:20,820 --> 00:22:22,320
0,630 630,840 840,930 930,1110 1110,1500
{} and {scause,is - -}

710
00:22:22,320 --> 00:22:23,640
0,720
f,|
|

711
00:22:23,640 --> 00:22:25,080
0,120 120,240 240,300 300,660 660,1440
it's going to return 0.|
它将返回 0 。|

712
00:22:25,760 --> 00:22:28,400
0,780 1230,2100
So, {}
所以，我只想确定如果。

713
00:22:28,520 --> 00:22:29,480
0,300 300,420 420,480 480,660 660,960
just want to make sure

714
00:22:29,480 --> 00:22:30,860
0,210 210,720
that if.|
|

715
00:22:32,400 --> 00:22:33,630
0,240 240,420 420,720 720,870 870,1230
Yeah, if {devintr -} returns
是的，如果 devintr 返回 0 ，

716
00:22:33,630 --> 00:22:34,940
0,270 270,690
0,| then
|那么它将继续执行我们的代码，那很好。

717
00:22:34,940 --> 00:22:36,380
0,210 210,420 420,570 570,900 900,1440
it's gonna go on to

718
00:22:37,450 --> 00:22:39,380
0,300 300,780 810,1080 1080,1470
our code, that's fine.|
|

719
00:22:40,220 --> 00:22:41,280
0,570
Okay.|
好的。|

720
00:22:41,430 --> 00:22:42,240
0,240 240,390 390,510 510,660 660,810
Okay, now we only need
好的，现在我们只需要写。

721
00:22:42,240 --> 00:22:43,200
0,90 90,390
to write.|
|

722
00:22:44,210 --> 00:22:45,380
0,300 300,780 780,900 900,1050 1050,1170
{} Actually this one thing
实际上，有一件事我想在这里提醒，

723
00:22:45,380 --> 00:22:46,550
0,60 60,210 210,330 330,810 810,1170
I want to observe here|
|

724
00:22:46,700 --> 00:22:48,060
0,240 240,480 480,750
and that's that
如果出现失败，我们就会杀死这个进程。

725
00:22:48,090 --> 00:22:48,840
0,120 120,270 270,360 360,690 690,750
if there's a failure, we

726
00:22:48,840 --> 00:22:51,680
0,270 270,360 360,1080 1770,2250
kill the process.| So,
|所以，这很不幸，

727
00:22:51,880 --> 00:22:53,530
0,150 150,210 210,960 1110,1500 1530,1650
this is unfortunate,| {} it
|那就太棒了，

728
00:22:53,530 --> 00:22:55,690
0,90 90,210 210,1110 1140,1410 1410,2160
would be fantastic,| if instead
|大多数情况下，

729
00:22:55,690 --> 00:22:56,680
0,60 60,270 300,870 870,930 930,990
you know most of the

730
00:22:56,680 --> 00:22:58,630
0,540 600,1110 1110,1530 1530,1890 1890,1950
time,| processes allocate memory or
|进程通过调用系统调用来分配内存或其他什么，

731
00:22:58,630 --> 00:23:00,190
0,450 450,600 600,870 870,1170 1170,1560
whatever by calling system calls,|
|

732
00:23:00,190 --> 00:23:01,660
0,90 90,360 360,690 690,810 810,1470
the system calls can return
系统调用可以返回一些错误值 -1 或其他，

733
00:23:01,660 --> 00:23:03,190
0,210 210,480 480,960 960,1290 1290,1530
some error value {-1 -}

734
00:23:03,190 --> 00:23:04,030
0,90 90,480 480,600 600,780 780,840
or something,| if there's a
|如果出现失败，进程就可以做一些适当的事情，

735
00:23:04,030 --> 00:23:05,530
0,540 660,900 900,960 960,1350 1350,1500
failure and the process can

736
00:23:05,530 --> 00:23:08,170
0,120 120,270 270,600 600,1200 2490,2640
then do something appropriate,| if
|它知道如何处理这一失败，

737
00:23:08,170 --> 00:23:09,040
0,90 90,270 270,570 570,660 660,870
it knows how in order

738
00:23:09,040 --> 00:23:10,120
0,90 90,300 300,420 420,570 570,1080
to deal with that failure,|
|

739
00:23:10,360 --> 00:23:11,530
0,540 540,690 690,900 900,1050 1050,1170
here though because there's no
但是这里，因为没有系统调用，

740
00:23:11,530 --> 00:23:13,120
0,420 420,870 900,1200 1200,1350 1350,1590
system call,| there's not any
|没有任何明显的方式来告诉进程出了问题，

741
00:23:13,150 --> 00:23:14,500
0,600 600,930 930,1080 1080,1260 1260,1350
obvious way to tell the

742
00:23:14,500 --> 00:23:16,720
0,810 840,1170 1200,1620 1620,1770 1770,2220
process that something went wrong,|
|

743
00:23:17,980 --> 00:23:20,800
0,390 750,960 960,1380 1410,2040 2610,2820
{} which is irritating,| you
这是令人恼火的，|你可以想象解决这个问题的方法，

744
00:23:20,800 --> 00:23:22,270
0,90 90,540 540,1050 1050,1170 1170,1470
can imagine solutions to this,|
|

745
00:23:22,270 --> 00:23:23,830
0,120 120,660 930,1230 1230,1380 1380,1560
for example in some more
例如在一些更复杂的操作系统中，

746
00:23:23,830 --> 00:23:26,470
0,600 600,960 960,1530 2370,2520 2520,2640
sophisticated operating system,| we could
|我们可以有比如 alarm 的用户故障处理程序，

747
00:23:26,470 --> 00:23:28,750
0,360 390,840 840,1140 1140,1260 1260,2280
have something like the alarm

748
00:23:29,050 --> 00:23:30,940
0,420 510,1050 1050,1410 1410,1800 1800,1890
{} user fault handler that

749
00:23:30,940 --> 00:23:32,110
0,180 180,780 780,960 960,1050 1050,1170
you implemented,| that we could
|我们可以调用，

750
00:23:32,110 --> 00:23:33,190
0,360 360,510 510,780 780,870 870,1080
call up into| to say
|表示我们不能继续你的进程了，

751
00:23:33,190 --> 00:23:34,390
0,300 300,390 390,690 750,960 960,1200
look you know we can't

752
00:23:34,390 --> 00:23:36,560
0,390 390,510 510,1080 1080,1710
continue your process,| because
|因为我们无法修复这个页面错误，

753
00:23:36,560 --> 00:23:37,490
0,90 90,330 330,510 510,660 660,930
we can't fix this page

754
00:23:37,490 --> 00:23:38,570
0,390 450,750 750,870 870,1020 1020,1080
fault,| but we want to
|但我们想告诉你出了问题。

755
00:23:38,570 --> 00:23:39,770
0,210 210,360 360,630 630,810 810,1200
tell you something went wrong.|
|

756
00:23:41,660 --> 00:23:42,980
0,450 780,900 900,1050 1050,1230 1230,1320
But we're not gonna do
但我们现在不会这么做，

757
00:23:42,980 --> 00:23:44,020
0,180 180,420
that now,|
|

758
00:23:44,490 --> 00:23:45,420
0,240 240,390 390,660 660,750 750,930
it's much simpler to just
杀死这个进程要简单得多。

759
00:23:45,420 --> 00:23:47,550
0,150 150,240 240,810 1350,1740 1740,2130
kill the process.| Okay, so
|好的，所以我们要实现这个 cowfault 程序，

760
00:23:48,030 --> 00:23:49,260
0,210 210,300 300,420 420,840 840,1230
we have to implement page,

761
00:23:49,260 --> 00:23:51,390
0,150 150,450 450,780 780,1650 1680,2130
this {cowfault -} program, {}|
|

762
00:23:51,420 --> 00:23:52,820
0,390 390,810
takes a,
使用一个对应当前页表的 pagetable ，

763
00:23:55,740 --> 00:23:57,210
0,420 420,600 600,750 750,1170 1170,1470
{} on a {pagetable -}

764
00:23:57,210 --> 00:23:58,440
0,120 120,570 570,720 720,990 990,1230
to current this {page,table},| this
|这个参数，出现错误的虚拟地址。

765
00:23:58,440 --> 00:24:00,480
0,510 510,690 690,870 870,1260 1260,2040
argument, {} the virtual address

766
00:24:00,660 --> 00:24:01,980
0,240 240,330 330,600 600,930 930,1320
that the fault occurred on.|
|

767
00:24:03,530 --> 00:24:05,000
0,810

768
00:24:05,780 --> 00:24:07,250
0,300 300,570 600,900 900,1170 1170,1470
Okay, so the first question
好的，所以我们要考虑的第一个问题，

769
00:24:07,250 --> 00:24:08,060
0,90 90,300 300,390 390,540 540,810
we {have -} to worry

770
00:24:08,060 --> 00:24:09,920
0,270 270,480 480,810 810,1260 1440,1860
about,| when dealing with virtual
|什么时候处理用户程序产生的虚拟地址，

771
00:24:09,920 --> 00:24:11,300
0,420 420,600 600,690 690,990 990,1380
addresses that the user program

772
00:24:11,300 --> 00:24:13,520
0,840 870,1080 1080,1290 1290,1650 1770,2220
produced,| like this one,| is
|就像这个地址一样，|如果它是一个完全疯狂的地址，

773
00:24:13,550 --> 00:24:14,630
0,330 330,450 450,570 570,630 630,1080
what if it's a completely

774
00:24:14,630 --> 00:24:18,260
0,840 1140,2400 2520,3030 3120,3480 3480,3630
crazy address,| like way up
|比如在进程[顶部]上方，

775
00:24:18,260 --> 00:24:19,040
0,300 300,390 390,630 630,690 690,780
above the top of the

776
00:24:19,040 --> 00:24:20,180
0,570 570,840 840,930 930,1080 1080,1140
process,| what if it's an
|如果地址在 trapframe 或 trampoine 页面上，

777
00:24:20,180 --> 00:24:22,910
0,360 360,630 780,1470 1470,2190 2250,2730
address like in the {trapframe

778
00:24:22,910 --> 00:24:24,140
0,360 360,480 480,540 540,630 630,1230
-} or in the trampoline

779
00:24:24,140 --> 00:24:26,570
0,690 690,870 870,1170 1200,2220 2250,2430
page,| {or,in} the page, the
|或者在堆栈保护页上。

780
00:24:26,570 --> 00:24:28,640
0,480 480,870 870,1740
stack guard page.|
|

781
00:24:29,360 --> 00:24:30,680
0,450

782
00:24:33,300 --> 00:24:34,200
0,180 180,270 270,630 630,810 810,900
So can anybody sort of
所以有人可以想出一种方法，

783
00:24:34,200 --> 00:24:35,910
0,300 300,360 360,990 990,1320 1320,1710
outline a strategy| for {}
|保护自己不受用户进程故意在疯狂地址上出错的影响。

784
00:24:37,370 --> 00:24:39,820
0,510 540,960 960,1350 1350,1890
{} defending ourselves against

785
00:24:39,820 --> 00:24:42,040
0,150 150,390 390,810 810,1590 1590,2220
the user process intentionally faulting

786
00:24:42,100 --> 00:24:44,300
0,420 450,930 930,1620
on crazy addresses.|
|

787
00:24:50,100 --> 00:24:51,720
0,330 330,540 540,750 750,900 900,1620
Isn't there like a max
是不是有个最大虚拟地址。

788
00:24:51,720 --> 00:24:55,290
0,420 420,1230 2370,3060 3090,3390 3390,3570
virtual address.| Yes, yes there
|是的，确实会出现，

789
00:24:55,290 --> 00:24:56,580
0,270 270,450 450,630 630,840 840,1290
is and that will actually

790
00:24:56,580 --> 00:24:59,520
0,210 210,1230 1590,2490
come up,| but
|但是用户地址空间的顶部在 MAXVA 下面，

791
00:24:59,820 --> 00:25:01,290
0,750 780,1110 1110,1170 1170,1260 1260,1470
the top of the user

792
00:25:01,290 --> 00:25:03,920
0,270 270,1080 1080,2130
address {space,is} below

793
00:25:05,350 --> 00:25:07,060
0,420 420,630 630,1170
{MAXVA - -},|
|

794
00:25:08,010 --> 00:25:09,940
0,360 360,570 570,1320
and the {}
而且堆栈保护页面，

795
00:25:11,090 --> 00:25:13,190
0,300 300,390 390,750 750,1110 1110,2100
like the stack guard page,|
|

796
00:25:13,580 --> 00:25:14,600
0,180 180,300 300,600 600,660 660,1020
which we shouldn't be allowing,
我们不应该允许，

797
00:25:14,600 --> 00:25:15,950
0,240 240,660 660,960 960,1050 1050,1350
{right },| shouldn't be treating
|不应该把它当作写入时复制的东西。

798
00:25:15,950 --> 00:25:18,200
0,120 120,180 180,810 810,1170 1710,2250
as a copy-on-write thing.| Alright,
|好的，我会在这里展示一个解决方案。

799
00:25:18,230 --> 00:25:19,780
0,120 120,390 390,1020
I will, {}

800
00:25:20,370 --> 00:25:21,720
0,660
{}

801
00:25:22,930 --> 00:25:24,310
0,180 180,390 390,450 450,870 870,1380
I'll show a solution here.|
|

802
00:25:24,860 --> 00:25:25,730
0,240 240,420 420,540 540,660 660,870
{} We're just gonna call
我们在这里调用 walk 。

803
00:25:25,730 --> 00:25:27,280
0,360 360,480 480,930
walk for now.|
|

804
00:25:28,370 --> 00:25:29,500
0,240 240,450

805
00:25:29,910 --> 00:25:31,440
0,510 660,960 990,1320 1320,1440 1440,1530
{} And one thing that
有一件事可能会出错的是，

806
00:25:31,440 --> 00:25:32,490
0,120 120,270 270,480 480,600 600,1050
can go wrong is| walk
|walk 找不到页表条目，

807
00:25:32,490 --> 00:25:34,050
0,390 390,870 870,930 930,1230 1230,1560
doesn't find a page table

808
00:25:34,050 --> 00:25:37,080
0,450 840,1110 1110,1590 1620,2130 2130,3030
entry,| {so,for} most illegal pages
|所以，对于进程可能引用的大多数非法页面，

809
00:25:37,110 --> 00:25:39,300
0,360 360,1080 1260,1710 1710,1890 1890,2190
that a process might refer

810
00:25:39,300 --> 00:25:41,600
0,390 570,840 840,960 960,1890
to,| theres no pte,|
|没有 pte ，|

811
00:25:41,630 --> 00:25:42,590
0,390 390,540 540,720 720,900 900,960
{} and there's only a
而且只有几个例外，

812
00:25:42,590 --> 00:25:44,240
0,270 270,870 870,960 960,1230 1260,1650
few exceptions to that,| so
|所以如果我们检测到非法，

813
00:25:44,270 --> 00:25:46,430
0,330 330,750 780,1350 1350,1470 1470,2160
if we detect the illegal,|
|

814
00:25:46,430 --> 00:25:48,110
0,180 180,240 240,960 960,1440 1440,1680
if we detect detect the
如果我们检测到 pte 没有找到，

815
00:25:48,530 --> 00:25:49,730
0,300 300,420 420,630 630,900 900,1200
{pte -} not found,| return
|从 walk 返回 -1 ，

816
00:25:49,730 --> 00:25:51,020
0,270 270,450 450,930 930,1020 1020,1290
value from walk and return

817
00:25:51,020 --> 00:25:53,340
0,300 300,750 960,1740
{-1 -}, {}|
|

818
00:25:53,370 --> 00:25:55,020
0,270 270,570 570,870 870,1080 1080,1650
we've handled almost every case,|
我们几乎处理了所有的情况，|

819
00:25:55,380 --> 00:25:56,640
0,240 240,420 420,720 720,840 840,1260
the only cases I'm aware
唯一的情况是 walk 会在哪里返回页表条目，

820
00:25:56,640 --> 00:25:58,800
0,450 600,990 1200,1680 1680,1830 1830,2160
of, where walk would return

821
00:25:58,800 --> 00:25:59,970
0,60 60,360 360,660 660,1020 1020,1170
a page table entry,| but
|但是我们不想允许对其进行写入，

822
00:25:59,970 --> 00:26:01,110
0,210 330,630 630,780 780,840 840,1140
we don't want to allow

823
00:26:01,110 --> 00:26:02,670
0,360 360,540 540,720 930,1260 1260,1560
writes to it| are for
|是 trampoline tramframe 和堆栈保护页面，

824
00:26:02,670 --> 00:26:05,820
0,690 960,2130 2310,2760 2760,3030 3030,3150
the trampoline {trapframe -} and

825
00:26:05,820 --> 00:26:07,720
0,360 360,690 690,1410
stack guard pages,|
|

826
00:26:07,780 --> 00:26:08,860
0,330 330,510 510,750 750,900 900,1080
{} and those all have
这些都没有 PTE_U 。

827
00:26:08,860 --> 00:26:11,640
0,480 480,690 690,1350
{PTE_U -} clear.|
|

828
00:26:11,700 --> 00:26:12,510
0,270 270,390 390,540 540,660 660,810
So the way I'm going
所以我要检测非法地址的方法是

829
00:26:12,510 --> 00:26:15,030
0,120 120,750 1110,1560 1560,2160 2160,2520
to detect crazy addresses illegal

830
00:26:15,030 --> 00:26:17,430
0,540 540,750 750,1230 1470,1920 1920,2400
addresses is| by {} checking
|通过检查 PTE_U 是否被设置，

831
00:26:17,430 --> 00:26:18,440
0,420
that

832
00:26:18,740 --> 00:26:21,050
0,390 780,1200 1200,1650 1650,1800 1800,2310
{} {PTE_U -} is set,|
|

833
00:26:22,700 --> 00:26:25,070
0,360 360,1020 1260,1560 1560,1890 1890,2370
and also, {} just checks
另外，只要检查一下 PTE_V ，

834
00:26:25,070 --> 00:26:27,180
0,210 210,420 420,720 750,1560
look at {} PTE_V,|
|

835
00:26:29,500 --> 00:26:30,190
0,150 150,240 240,420 420,480 480,690
and if either of those
如果其中任何一个没有设置，

836
00:26:30,190 --> 00:26:31,540
0,120 120,630 630,930 930,1020 1020,1350
is clear,| then we know
|那我们就知道这是个不好的地址，

837
00:26:31,540 --> 00:26:33,040
0,210 210,390 390,870
this is like

838
00:26:33,240 --> 00:26:34,480
0,630
{}

839
00:26:34,660 --> 00:26:36,680
0,420 420,540 540,780 780,1500
not an okay address,|
|

840
00:26:37,540 --> 00:26:38,800
0,360 360,630 630,780 780,990 990,1260
and just return {-1 -},
只需返回 -1 ，杀死进程，

841
00:26:39,340 --> 00:26:41,620
0,450 450,960 1650,1860 1860,1980 1980,2280
{so,killed} process,| so I believe
|所以我相信处理了所有的非法地址，

842
00:26:41,620 --> 00:26:42,760
0,240 240,450 450,540 540,870 870,1140
taking care of all the,

843
00:26:42,760 --> 00:26:43,780
0,0
{}

844
00:26:46,760 --> 00:26:49,240
0,120 120,840
{ -}

845
00:26:50,350 --> 00:26:52,870
0,540 540,1230 1230,1560 1590,2010 2130,2520
illegal addresses,| the user process
|用户进程可以使用的。

846
00:26:52,870 --> 00:26:54,370
0,150 150,630 750,990 990,1080 1080,1500
could use, try to use.|
|

847
00:26:55,800 --> 00:26:57,210
0,240 240,360 360,480 480,600 600,1410
Alright, how can we find
好的，我们怎么才能知道，

848
00:26:57,210 --> 00:26:57,900
0,300 300,390 390,510 510,570 570,690
out,| we want to do
|我们想要一份拷贝，

849
00:26:57,900 --> 00:26:58,680
0,60 60,390 390,540 540,660 660,780
a copy,| now we want
|现在我们想要这个进程页面的复制，

850
00:26:58,680 --> 00:27:00,300
0,60 60,210 210,780 780,1320 1320,1620
to make this process {}

851
00:27:00,330 --> 00:27:02,610
0,750 750,840 840,960 960,1620 2100,2280
copy of the page,| how
|我们怎样才能找到要复制的页面。

852
00:27:02,610 --> 00:27:03,780
0,90 90,180 180,360 360,420 420,1170
do we find the page

853
00:27:03,780 --> 00:27:05,180
0,90 90,450 450,630
to copy from.|
|

854
00:27:05,270 --> 00:27:06,200
0,180 180,420 420,570 570,630 630,930
{} I have a question
这里我有个问题。

855
00:27:06,200 --> 00:27:07,780
0,420 570,1110
here.| Please.|
|请说。|

856
00:27:07,780 --> 00:27:10,210
0,600 840,1350 1350,1440 1440,2250 2250,2430
{} Wouldn't the strategy of
使用 PTE_U 来判断页面是否，

857
00:27:10,210 --> 00:27:12,490
0,480 480,660 660,1230 1230,1740 1980,2280
using the {PTE_U -} {}

858
00:27:12,490 --> 00:27:14,890
0,270 270,630 630,870 870,1290 1320,2400
to judge if the pages,|
|

859
00:27:15,550 --> 00:27:17,530
0,270 270,870 900,1410 1410,1830 1830,1980
{} if they're, if it's
如果是合法的写入时复制页面，

860
00:27:17,530 --> 00:27:19,660
0,60 60,480 480,900 930,1350 1350,2130
a legit page for copy-on-write,|
|

861
00:27:19,810 --> 00:27:21,610
0,420 420,540 540,1170 1170,1650 1650,1800
wouldn't this strategy not be
这个策略是不是对长期进程不友好，

862
00:27:21,610 --> 00:27:23,500
0,390 390,780 960,1320 1320,1410 1410,1890
very good for the long-term

863
00:27:23,500 --> 00:27:25,030
0,480 480,780 780,960 960,1320 1320,1530
process,| maybe you add some
|也许你会地址空间中添加一些其他部分，

864
00:27:25,030 --> 00:27:28,630
0,510 660,1620 1710,2730 2730,3330 3360,3600
other {} part to the

865
00:27:28,630 --> 00:27:30,250
0,330 330,660 660,930 930,1170 1350,1620
address space,| which is which
|它可能是可写的，

866
00:27:30,250 --> 00:27:31,620
0,90 90,450 450,540 540,960
is supposed to be

867
00:27:31,650 --> 00:27:33,840
0,180 180,810 900,1620 1830,2100 2100,2190
a writable,| {} which are
|它们应该是只是可读的，

868
00:27:33,840 --> 00:27:35,130
0,270 270,570 570,630 630,750 750,1290
only supposed to be readable,|
|

869
00:27:35,220 --> 00:27:36,510
0,360 360,510 510,750 750,960 960,1290
but that doesn't get taken
但这在这里没有考虑到，

870
00:27:36,510 --> 00:27:38,190
0,330 330,450 450,960 1200,1590 1590,1680
care of here,| as in
|你还得再回来一次。

871
00:27:38,190 --> 00:27:38,970
0,120 120,270 270,360 360,510 510,780
you'll have to come back

872
00:27:38,970 --> 00:27:41,370
0,180 180,570 1080,1410 1410,1920 1920,2400
here again.| You're absolutely right,|
|你说得对，|

873
00:27:41,400 --> 00:27:42,450
0,300 300,360 360,450 450,510 510,1050
if we are to add
如果我们要添加任何其他有趣的分页功能，

874
00:27:43,280 --> 00:27:46,490
0,270 270,1410 1530,2010 2010,2430 2430,3210
any other interesting paging feature,|
|

875
00:27:46,520 --> 00:27:48,530
0,420 420,720 720,1260 1260,1530 1530,2010
like maybe lazy page allocation,
比如懒分页，

876
00:27:48,530 --> 00:27:50,390
0,120 120,600 1410,1650 1650,1740 1740,1860
for example,| we have to
|我们必须重新审视这些决定，

877
00:27:50,390 --> 00:27:51,710
0,420 420,600 600,1110 1110,1200 1200,1320
revisit these decisions| and come
|然后想出一些其他的策略来决定，

878
00:27:51,710 --> 00:27:52,880
0,120 120,210 210,390 390,540 540,1170
up with some other strategy

879
00:27:52,880 --> 00:27:54,590
0,120 120,750 960,1260 1260,1500 1500,1710
for deciding| is this a
|这是不是写入时复制页面，

880
00:27:54,620 --> 00:27:56,060
0,600 600,1050 1050,1170 1170,1350 1350,1440
copy-on-write page,| is this a
|这是不是一个懒分配页面，

881
00:27:56,060 --> 00:27:58,370
0,870 870,1530 1530,1950 1950,2070 2070,2310
lazy allocation page,| is this
|这是不是一个调出到磁盘的页面，

882
00:27:58,370 --> 00:27:59,900
0,330 420,990 990,1140 1140,1200 1200,1530
a {page-out -} to disk

883
00:27:59,900 --> 00:28:01,910
0,750 750,870 870,1230 1260,1740 1740,2010
pages,| to say memory map
|比如内存映射文件。

884
00:28:01,910 --> 00:28:02,840
0,540
file.|
|

885
00:28:02,840 --> 00:28:04,670
0,660 930,1320 1320,1440 1440,1620 1620,1830
{} And we need more
我们需要更复杂的，

886
00:28:04,670 --> 00:28:06,380
0,1110
sophisticated,|
|

887
00:28:06,470 --> 00:28:07,940
0,180 180,480 990,1110 1110,1230 1230,1470
you know, in the end
最终我认为，

888
00:28:07,940 --> 00:28:09,040
0,60 60,480
I think,|
|

889
00:28:09,040 --> 00:28:11,050
0,180 180,810 840,1320 1320,1680 1680,2010
and most serious operating systems
大多数正式的操作系统都保留了自己的数据结构，

890
00:28:11,050 --> 00:28:12,340
0,210 210,390 390,600 600,1020 1020,1290
actually keep their own data

891
00:28:12,340 --> 00:28:13,820
0,780
structure,|
|

892
00:28:13,820 --> 00:28:15,290
0,300 300,390 390,480 480,720 1320,1470
nothing to do with, {you,know}
不是一个页表，

893
00:28:15,290 --> 00:28:16,340
0,300 300,330 330,630 630,930 930,1050
not a page table,| but
|而是某种程度上模仿页表，

894
00:28:16,340 --> 00:28:17,390
0,180 180,240 240,720 720,780 780,1050
sort of mimicking a page

895
00:28:17,390 --> 00:28:19,370
0,360 420,630 630,1230 1230,1320 1320,1980
table,| that describes the process's
|它描述了进程的地址空间，

896
00:28:19,370 --> 00:28:20,870
0,300 300,750 750,1080 1200,1440 1440,1500
address space| and sort of
|并在描述了每个页面的含义，

897
00:28:20,870 --> 00:28:22,670
0,510 510,750 750,930 930,1290 1290,1800
describes what each page means|
|

898
00:28:22,670 --> 00:28:23,750
0,120 120,240 240,390 390,750 750,1080
and what its state is|
以及它的状态是什么，|

899
00:28:23,780 --> 00:28:24,620
0,90 90,180 180,300 300,390 390,840
and we have to consult
我们必须参考那张表。

900
00:28:24,620 --> 00:28:26,820
0,180 180,600
that table.|
|

901
00:28:27,230 --> 00:28:29,120
0,300 300,450 450,750 750,1320 1590,1890
But for this lab,| since
但是对这个实验来说，|因为我们没有其他功能，

902
00:28:29,120 --> 00:28:30,050
0,90 90,270 270,480 480,720 720,930
we don't have those other

903
00:28:30,050 --> 00:28:31,070
0,480 480,570 570,630 630,840 840,1020
features| and we're not sure
|我们不确定它们会是什么样子，

904
00:28:31,070 --> 00:28:33,020
0,150 150,270 270,420 420,930 1200,1950
what they would be, {}|
|

905
00:28:33,800 --> 00:28:34,640
0,240 240,390 390,540 540,630 630,840
I'm just gonna do something
我只想做些简单的事，

906
00:28:34,640 --> 00:28:35,960
0,690 720,840 840,1140 1140,1230 1230,1320
straightforward| and indeed we would
|事实上，我们不得不回来修复它，

907
00:28:35,960 --> 00:28:36,590
0,120 120,210 210,330 330,540 540,630
have to come back and

908
00:28:36,590 --> 00:28:38,540
0,270 270,450 600,810 810,1170 1440,1950
fix it,| if we made
|如果我们把 xv6 做得更复杂。

909
00:28:38,570 --> 00:28:40,040
0,210 210,330 330,540 540,660 660,1470
{xv6 - -} more sophisticated.|
|

910
00:28:41,740 --> 00:28:43,870
0,210 210,510 510,900 930,1620 1650,2130
And wouldn't that panic if
如果 va 大于 MAXVA ，不会产生 panic 吗，

911
00:28:43,870 --> 00:28:46,240
0,450 450,990 1200,1560 1560,1950 1980,2370
va is more than {MAXVA

912
00:28:46,240 --> 00:28:47,800
0,390 390,750 750,810 810,960 960,1560
-},| because of the walk.|
|因为 walk 。|

913
00:28:51,630 --> 00:28:54,150
0,1110 1560,1920 1920,2040 2040,2160 2160,2520
{} [] me, you would.|
[]，会的。|

914
00:28:58,630 --> 00:28:59,500
0,240 240,480 480,540 540,720 720,870
Now, look at that, {}
看看这个，也许是这个过程。

915
00:28:59,500 --> 00:29:01,820
0,330 330,480 480,570 570,1740
maybe it's the process.|
|

916
00:29:03,310 --> 00:29:04,750
0,720 720,960 960,1110 1110,1200 1200,1440
Yeah, I think you're right.|
是的，我想你是对的。|

917
00:29:05,660 --> 00:29:07,370
0,420 420,510 510,810 1050,1530 1530,1710
That's too bad.| Okay, so
太糟糕了。|好的，你说得对，

918
00:29:07,370 --> 00:29:09,180
0,210 210,720 720,1170
we're certainly, {}

919
00:29:09,210 --> 00:29:10,260
0,300 300,510 510,750 750,900 900,1050
you're right,| alright, well I
|好的，在这件事上我错了。

920
00:29:10,260 --> 00:29:12,500
0,570 600,870 870,1080 1080,1470
was wrong about this.|
|

921
00:29:12,680 --> 00:29:14,360
0,360 360,570 570,690 690,960 960,1680
Wait, can you just return
等等，如果你检查 MAXVA ，能直接返回 -1 吗？

922
00:29:14,390 --> 00:29:15,530
0,180 180,540 540,840 870,1020 1020,1140
a {-1 -}, if you

923
00:29:15,530 --> 00:29:16,670
0,330 330,570 570,660 660,990 990,1140
just check the {MAXVA -

924
00:29:16,670 --> 00:29:18,050
0,210 240,420 420,570 570,660 660,1380
-}.| I think the observation
|我认为观察到的情况是，

925
00:29:18,050 --> 00:29:20,300
0,210 210,600 1650,1890 1890,1980 1980,2250
is| that if the user
|如果用户试图编写程序写入非常大的地址，

926
00:29:20,300 --> 00:29:22,490
0,480 480,630 630,1590 1620,1950 1950,2190
tries to intentionally program tries

927
00:29:22,490 --> 00:29:23,720
0,90 90,270 270,570
to write to

928
00:29:23,720 --> 00:29:25,500
0,180 180,450 450,1230
very large address,|
|

929
00:29:25,500 --> 00:29:27,240
0,60 60,690 900,1170 1170,1440 1440,1740
of course, you can't expect
当然，你不能避免这个，

930
00:29:27,240 --> 00:29:29,920
0,90 90,540 540,930 1470,2070
to survive that, {}|
|

931
00:29:30,660 --> 00:29:31,680
0,300 300,570 570,720 720,870 870,1020
but what we would do
但是在这里是用一个非常大的地址调用 walk ，

932
00:29:31,680 --> 00:29:33,480
0,540 540,720 720,1080 1080,1590 1620,1800
here is call walk with

933
00:29:33,480 --> 00:29:35,220
0,60 60,300 300,570 570,1350 1590,1740
a very large address| and
|看看这里， walk 的实现，

934
00:29:35,220 --> 00:29:36,120
0,60 60,330 330,510 510,810 810,900
{} looking at here, the

935
00:29:36,120 --> 00:29:38,010
0,570 570,690 690,1140 1140,1470 1470,1890
implementation of walk in the,|
|

936
00:29:39,780 --> 00:29:41,420
0,150 150,270 270,450 450,1050
and it's {going,to} panic.|
它会产生一个 panic 。|

937
00:29:42,120 --> 00:29:43,650
0,300 300,420 420,570 570,990 1200,1530
Then we can just use
然后我们就可以使用相同的方法 walk 地址，

938
00:29:43,650 --> 00:29:45,210
0,120 120,330 330,840 840,1170 1170,1560
the same approaches walk address,|
|

939
00:29:45,210 --> 00:29:46,230
0,270 270,420 420,570 570,750 750,1020
does I had this same
我也有同样的 bug ，

940
00:29:46,230 --> 00:29:47,180
0,360
bug,|
|

941
00:29:47,180 --> 00:29:48,410
0,180 180,330 330,600 600,930 930,1230
you can just return {-1
你可以像其他人说的那样返回 -1 ，

942
00:29:48,410 --> 00:29:49,520
0,240 240,450 450,660 660,960 960,1110
-} like other people are

943
00:29:49,520 --> 00:29:51,200
0,510 540,750 750,1080 1080,1350 1350,1680
saying,| if va is greater
|如果在 walk 之前 va 大于 MAXVA 。

944
00:29:51,200 --> 00:29:53,450
0,150 150,450 450,870 1320,1770 1770,2250
than {MAXVA -} before walk.|
|

945
00:29:55,300 --> 00:29:56,290
0,240 240,300 300,630 630,870 870,990
What I'm upset about is
让我失望的是，测试似乎没有测试这一点。

946
00:29:56,290 --> 00:29:57,370
0,120 120,210 210,630 630,900 900,1080
that the tests don't seem

947
00:29:57,370 --> 00:29:59,060
0,120 120,480 480,930
to test this.|
|

948
00:29:59,720 --> 00:30:00,530
0,150 150,270 270,480 480,630 630,810
Because I didn't put this
因为我没有把这个放进我的解决方案里。

949
00:30:00,530 --> 00:30:02,820
0,90 90,540 570,1200
in my solution.|
|

950
00:30:03,050 --> 00:30:04,300
0,810
Okay.|
好的。|

951
00:30:04,300 --> 00:30:05,680
0,660

952
00:30:08,350 --> 00:30:09,400
0,540
Okay.|
好的。|

953
00:30:10,200 --> 00:30:12,000
0,360 360,750 1380,1620 1620,1680 1680,1800
Okay, so how do we
好的，那么我们怎么才能找到，

954
00:30:12,000 --> 00:30:12,840
0,240 240,360 360,450 450,720 720,840
find,| that we need, we
|我们想要复制页面，

955
00:30:12,840 --> 00:30:14,520
0,120 120,180 180,600 600,690 690,1680
want to copy the page,|
|

956
00:30:14,790 --> 00:30:15,450
0,300 300,420 420,510 510,630 630,660
how do I get a
如何获得指向页面的指针，

957
00:30:15,450 --> 00:30:17,190
0,420 420,540 540,870 1140,1470 1470,1740
pointer to the page| to
|指向我可以复制的页面的指针。

958
00:30:17,190 --> 00:30:18,100
0,360
the

959
00:30:18,370 --> 00:30:19,300
0,360 360,450 450,750 750,840 840,930
pointer to something I can

960
00:30:19,300 --> 00:30:20,420
0,570
copy.|
|

961
00:30:22,720 --> 00:30:24,760
0,150 150,570 570,780 780,1320 1590,2040
The {PTE2PA - -}.| Yeah,
PTE2PA 。|是的，所以，它在 pte ，

962
00:30:25,440 --> 00:30:26,910
0,660 690,900 900,1140 1170,1410 1410,1470
so, it's just in the

963
00:30:26,910 --> 00:30:28,340
0,870
pte,|
|

964
00:30:28,370 --> 00:30:29,700
0,690

965
00:30:33,790 --> 00:30:35,230
0,780 900,1170 1170,1230 1230,1290 1290,1440
{} where am I gonna
我要复制到哪里，

966
00:30:35,230 --> 00:30:36,720
0,330 330,870
copy to,|
|

967
00:30:41,040 --> 00:30:42,240
0,150 150,270 270,330 330,660 660,1200
what should I copy to.|
我应该复制到什么地方。|

968
00:30:44,140 --> 00:30:46,630
0,180 180,480 480,1020 1020,1500 1860,2490
A nearly allocated page.| Yeah,
一个几乎被分配的页面。|是的，所以我调用 kalloc ，

969
00:30:46,930 --> 00:30:48,790
0,270 270,390 390,570 570,810 810,1860
so I just called kalloc,|
|

970
00:30:50,190 --> 00:30:52,440
0,300 300,960 960,1410 1740,2190 2190,2250
{of,course} kalloc is likely to
当然， kalloc 可能会失败，

971
00:30:52,440 --> 00:30:54,240
0,600 600,1230
fail,| so
|所以我会捕获它，

972
00:30:54,390 --> 00:30:56,640
0,660 690,930 930,1200 1200,1620
I'm gonna catch that,|
|

973
00:30:57,520 --> 00:30:59,260
0,300 300,510 510,690 690,1020 1020,1740
we're actually gonna see this,|
我们要看看这个，|

974
00:31:01,770 --> 00:31:02,430
0,240 240,300 300,420 420,600 600,660
so I'm gonna put a
所以我放一个 print 语句，这样我们就知道了。

975
00:31:02,430 --> 00:31:03,900
0,240 240,510 510,690 690,780 780,1470
print statement, so we know.|
|

976
00:31:05,670 --> 00:31:06,990
0,300 300,480 480,690 690,1140 1140,1320
Okay, we.| {Is,that,pa2 -}, that
好的，我们。|那不是 pa2 吗，那个等于。

977
00:31:06,990 --> 00:31:09,660
0,570 900,2070
{equal -}.|
|

978
00:31:10,390 --> 00:31:12,040
0,1020
Hey,
嘿，我留了这个错误，

979
00:31:13,340 --> 00:31:14,390
0,120 120,330 330,540 540,720 720,1050
I actually made this error|
|

980
00:31:14,390 --> 00:31:15,530
0,90 90,150 150,450 450,630 630,1140
and I wanted to reproduce
我想重现它，

981
00:31:15,530 --> 00:31:16,160
0,150 150,330 330,420 420,540 540,630
it,| so that we would
|这样我们才能追踪到它，

982
00:31:16,160 --> 00:31:17,000
0,150 150,270 270,480 480,570 570,840
have to track it down,|
|

983
00:31:17,000 --> 00:31:18,740
0,420 930,1200 1200,1320 1320,1620 1620,1740
but you're too clever for
对我来说，你太聪明了。

984
00:31:18,740 --> 00:31:20,780
0,240 630,1410
me. {}|
|

985
00:31:21,320 --> 00:31:23,510
0,270 270,450 450,510 510,1290 1320,2190
I want to copy two
我要从 pa1 复制到 pa2 。

986
00:31:24,160 --> 00:31:27,520
0,600 600,1080 1080,2100 2190,2610 2610,3360
{pa2 -} from {pa1 -}.|
|

987
00:31:28,830 --> 00:31:30,500
0,1020

988
00:31:31,330 --> 00:31:33,340
0,330 330,690 840,1530 1530,1800 1800,2010
Okay, so how can I,
好的，那么我该怎么，我需要做些什么，

989
00:31:33,340 --> 00:31:34,240
0,180 180,540 540,600 600,810 810,900
what do I need to

990
00:31:34,240 --> 00:31:35,200
0,240 240,330 330,570 570,690 690,960
do| in order to map
|为了映射新的页面 pa2 进入地址空间。

991
00:31:35,200 --> 00:31:37,210
0,180 180,990 1110,1380 1380,1620 1620,2010
this page, this new page

992
00:31:37,210 --> 00:31:39,120
0,240 240,690 690,960 960,1350
{pa2 -} into the

993
00:31:39,210 --> 00:31:40,440
0,570
{}

994
00:31:40,500 --> 00:31:41,900
0,360 360,900
address space.|
|

995
00:31:46,340 --> 00:31:47,740
0,120 120,270 270,1050
What {should,I} type?|
我应该输入什么？|

996
00:31:48,610 --> 00:31:50,350
0,540 540,810 810,1050 1050,1410 1410,1740
There's like two broad ways,|
有两种方法，|

997
00:31:50,350 --> 00:31:52,690
0,270 270,990 1170,1380 1380,2040 2040,2340
there's either {unmapping -} and
可以使用已存在的取消映射和映射，

998
00:31:52,690 --> 00:31:53,710
0,150 150,540 540,720 720,780 780,1020
then mapping with the built-in

999
00:31:53,710 --> 00:31:55,780
0,180 180,300 300,990 1470,1860 1860,2070
{} that exist,| or you
|或者你可以操纵这些位。

1000
00:31:55,780 --> 00:31:59,290
0,480 840,1530 1530,1620 1620,2250 2730,3510
could manipulate the bits.| Yeah
|是的，我太懒了，

1001
00:31:59,410 --> 00:32:01,180
0,300 300,660 690,1110 1110,1350 1350,1770
I am way too lazy|
|

1002
00:32:01,180 --> 00:32:02,500
0,120 120,420 420,720 840,1230 1230,1320
to figure out how to
不想解决如何使用 munmap 和 mmap ，

1003
00:32:02,500 --> 00:32:04,000
0,480 600,780 780,930 930,1350 1350,1500
use {munmap - -} and

1004
00:32:04,000 --> 00:32:06,100
0,330 330,780 960,1200 1200,1380 1380,2100
mmap,| so I'm gonna just
|所以我在这里创造一个新的页表条目。

1005
00:32:06,600 --> 00:32:07,470
0,270 270,420 420,480 480,600 600,870
cook up a new page

1006
00:32:07,470 --> 00:32:09,140
0,240 240,480 480,720 720,1080
table entry right here.|
|

1007
00:32:13,400 --> 00:32:14,840
0,360 360,570 570,720 720,780 780,1440
{} I have a question,|
我有个问题，|

1008
00:32:14,870 --> 00:32:16,970
0,270 270,1020 1020,1350 1350,1590 1590,2100
so actually I ran into
实际上我几乎在每个实验都遇到了这个问题，

1009
00:32:16,970 --> 00:32:18,230
0,240 240,570 570,690 690,1050 1050,1260
this issue in almost every

1010
00:32:18,230 --> 00:32:20,750
0,300 300,390 390,930 1080,2100 2130,2520
lab| in which {} I
|因为某种原因，我需要重新映射，

1011
00:32:20,750 --> 00:32:22,760
0,570 570,1140 1140,1470 1470,1650 1650,2010
somehow needed to {re-map -}

1012
00:32:22,760 --> 00:32:26,630
0,630 630,1320 1680,2430 2670,3570 3570,3870
things| and {} because it
|因为它经常发生，

1013
00:32:26,630 --> 00:32:29,180
0,300 300,450 450,960 960,1440 1440,2550
occurred too often,| I implemented
|我实现了一个可以重新映射，

1014
00:32:29,640 --> 00:32:31,520
0,150 150,780 780,1350
a map that

1015
00:32:31,980 --> 00:32:33,960
0,450 450,750 750,870 870,1200 1200,1980
which could {re-map, -} basically,|
|

1016
00:32:34,290 --> 00:32:36,540
0,690 690,870 870,960 960,1500 1620,2250
{} and I was wondering
我想知道这是不是一个糟糕的设计，

1017
00:32:36,540 --> 00:32:38,310
0,150 150,360 360,570 570,1260 1260,1770
is that a bad design

1018
00:32:38,310 --> 00:32:41,280
0,810 810,1110 1110,2070 2070,2430 2700,2970
choices,| like dangerous, so.| No,
|比如危险，所以。|不，这完全合理，

1019
00:32:41,280 --> 00:32:44,220
0,510 1500,1800 1800,2250 2250,2820 2820,2940
no, that's totally reasonable,| you
|xv6 中的函数是，

1020
00:32:44,220 --> 00:32:45,120
0,60 60,180 180,600 600,690 690,900
know the functions in {xv6

1021
00:32:45,120 --> 00:32:47,140
0,150 150,690 690,1140
- -} are,|
|

1022
00:32:47,140 --> 00:32:49,240
0,210 210,330 330,660 840,1830 1830,2100
are you know specialized to
专门针对现有的 xv6 ，

1023
00:32:49,510 --> 00:32:51,220
0,270 270,420 420,1170 1350,1620 1620,1710
{xv6 - -} as it

1024
00:32:51,220 --> 00:32:54,970
0,810 1230,1950 2160,2730 2790,3210 3210,3750
exists,| {} and so they
|它们假设其他代码是如何工作的，

1025
00:32:56,240 --> 00:32:57,170
0,150 150,240 240,330 330,450 450,930
you know they make assumptions

1026
00:32:57,170 --> 00:32:58,130
0,180 180,300 300,420 420,630 630,960
about how the other code

1027
00:32:58,130 --> 00:32:59,390
0,390 390,510 510,630 630,1110 1110,1260
works,| they have panics in
|它们产生 panic ，

1028
00:32:59,390 --> 00:33:00,740
0,270 270,450 450,630 630,1110 1110,1350
them,| that are intended to
|捕获以意外方式使用它们的代码，

1029
00:33:00,800 --> 00:33:02,300
0,480 480,690 690,990 990,1290 1290,1500
catch other code using them

1030
00:33:02,300 --> 00:33:03,890
0,120 120,690 690,1050 1050,1230 1350,1590
in unexpected ways,| but if
|但是如果你改变了 xv6 的工作方式，

1031
00:33:03,890 --> 00:33:04,610
0,120 120,390 390,450 450,570 570,720
you change the way {xv6

1032
00:33:04,610 --> 00:33:05,510
0,150 150,420 420,720 720,810 810,900
- -} works| and you
|你需要做不同的事情，

1033
00:33:05,510 --> 00:33:06,590
0,150 150,210 210,330 330,630 630,1080
need to do different things,|
|

1034
00:33:06,590 --> 00:33:08,030
0,300 360,600 600,930 930,1350 1350,1440
then it's totally reasonable| to
|它是完全合理的，|你需要能够在重新映射时没有 panic ，

1035
00:33:08,030 --> 00:33:10,760
0,1230 1860,2040 2040,2340 2340,2490 2490,2730
modify you know you need

1036
00:33:10,760 --> 00:33:11,560
0,330
to

1037
00:33:11,730 --> 00:33:12,570
0,150 150,300 300,420 420,540 540,840
be able to {re-map -}

1038
00:33:12,570 --> 00:33:14,070
0,270 270,510 510,570 570,1140 1140,1500
this without a panic,| well,
|旧的 xv6 不需要这样做。

1039
00:33:14,130 --> 00:33:15,390
0,360 360,630 630,870 870,1050 1050,1260
old {xv6 -} never needs

1040
00:33:15,390 --> 00:33:16,640
0,60 60,240 240,660
to do that.|
|

1041
00:33:16,640 --> 00:33:17,660
0,300

1042
00:33:18,440 --> 00:33:19,550
0,60 60,210 210,450 450,690 690,1110
If your code does so,|
如果你的代码这样做了，|

1043
00:33:19,670 --> 00:33:20,390
0,210 210,330 330,480 480,660 660,720
you should feel free to
你可以随意修改所需的任何内容。

1044
00:33:20,390 --> 00:33:22,250
0,780 1050,1410 1410,1500 1500,1680 1680,1860
modify anything you need to.|
|

1045
00:33:25,340 --> 00:33:27,680
0,330 330,780 870,1530 1680,2010 2010,2340
Okay, so {} okay, so
好的，所以，方法就在这里，

1046
00:33:28,160 --> 00:33:29,180
0,150 150,390 390,600 600,900 900,1020
the deal is here,| we
|我们有一个写保护的页面，

1047
00:33:29,180 --> 00:33:30,440
0,120 120,360 390,630 630,960 960,1260
had a write protected page|
|

1048
00:33:30,440 --> 00:33:31,550
0,120 120,240 240,570 570,990 990,1110
that was probably shared with
可能与另一个进程共享，

1049
00:33:31,550 --> 00:33:32,990
0,270 270,900 930,1290 1290,1350 1350,1440
another process,| what do we
|在这里，我们必须对另一个进程做些什么，

1050
00:33:32,990 --> 00:33:33,620
0,120 120,210 210,360 360,450 450,630
have to do to that

1051
00:33:33,650 --> 00:33:35,420
0,300 300,870 870,960 960,1140 1140,1770
other process at this point,|
|

1052
00:33:35,870 --> 00:33:37,200
0,750

1053
00:33:39,240 --> 00:33:39,720
0,120 120,180 180,240 240,420 420,480
what do we need to
我们需要对另一个进程做些什么。

1054
00:33:39,720 --> 00:33:40,920
0,120 120,210 210,300 300,450 450,1200
do to the other process.|
|

1055
00:33:46,340 --> 00:33:48,320
0,210 210,450 450,960 990,1710 1710,1980
We can just not do
我们可以什么都不做，

1056
00:33:48,320 --> 00:33:50,030
0,660 660,870 870,1230 1260,1530 1530,1710
anything,| and then when it
|然后当出现页面错误时，

1057
00:33:50,030 --> 00:33:51,560
0,330 330,1050
page faults,|
|

1058
00:33:51,560 --> 00:33:53,210
0,300 300,780 780,810 810,1020 1020,1650
we allocate a new page
我们分配一个新页面并删除原始页面。

1059
00:33:53,240 --> 00:33:55,970
0,480 750,1530 1590,1770 1770,2280 2280,2730
and remove the original one.|
|

1060
00:33:56,550 --> 00:33:57,900
0,210 210,600 600,870 1080,1290 1290,1350
That's absolutely right,| so you
完全正确，|所以你可以想象做一件事，

1061
00:33:57,900 --> 00:33:59,160
0,90 90,450 450,690 690,1080 1080,1260
could imagine doing something,| but
|但是要正确地做它是相当复杂的，

1062
00:33:59,160 --> 00:34:00,450
0,180 180,360 360,480 480,720 720,1290
it would be quite complex

1063
00:34:00,450 --> 00:34:02,190
0,90 90,210 210,300 300,900 1290,1740
to do it correctly| and
|所以我们什么都不做，

1064
00:34:02,340 --> 00:34:03,630
0,270 270,360 360,570 570,690 690,1290
so we just do nothing,|
|

1065
00:34:03,870 --> 00:34:05,850
0,690 870,1020 1020,1110 1110,1530 1560,1980
and if the other process
如果另一个进程从来没有写入这一页，

1066
00:34:05,850 --> 00:34:07,080
0,210 210,480 480,600 600,930 930,1230
never write this page,| well
|那么就不是问题，

1067
00:34:07,290 --> 00:34:08,310
0,150 150,240 240,270 270,660 780,1020
it's not a problem,| if
|如果它写了这一页，

1068
00:34:08,310 --> 00:34:09,120
0,60 60,210 210,390 390,420 420,810
it does write a page,|
|

1069
00:34:09,120 --> 00:34:10,200
0,450 480,600 600,720 720,870 870,1080
then it will go through
那么它就会经历这一切，

1070
00:34:10,200 --> 00:34:11,190
0,120 120,390 390,480 480,810 810,990
all this,| it will make
|它会复制一份，也会安全地进行，

1071
00:34:11,190 --> 00:34:13,080
0,90 90,720 720,1170
a copy and

1072
00:34:13,080 --> 00:34:14,670
0,330 330,540 540,1050 1050,1440 1440,1590
{} it'll proceed safely as

1073
00:34:14,670 --> 00:34:16,560
0,420 930,1110 1110,1320 1320,1650 1650,1890
well,| so doing nothing is
|所以什么都不做，是完全合理的。

1074
00:34:16,560 --> 00:34:18,000
0,390 390,840
totally reasonable.|
|

1075
00:34:18,540 --> 00:34:20,550
0,600 1380,1650 1650,1800 1800,1920 1920,2010
{} Okay, so now we're
好的，现在我们将返回，

1076
00:34:20,550 --> 00:34:22,140
0,120 120,180 180,720 720,870 870,1590
going to return,| the return
|返回值是 0 ，因为没有错误，

1077
00:34:22,170 --> 00:34:23,430
0,600 600,660 660,930 930,1140 1140,1260
value of 0, since there

1078
00:34:23,430 --> 00:34:25,620
0,150 150,270 270,750 930,1560 1590,2190
was no error| and hopefully
|希望这个过程会。

1079
00:34:25,620 --> 00:34:28,020
0,600 630,1140 1140,1560
the process will.|
|

1080
00:34:29,000 --> 00:34:30,740
0,510 510,660 660,1110 1110,1410 1410,1740
Maybe we should should free
也许我们应该释放物理页面，

1081
00:34:30,740 --> 00:34:33,110
0,120 120,600 600,900 900,1290 2070,2370
the physical page right,| or
|或者我们还没有到那一步。

1082
00:34:33,110 --> 00:34:34,100
0,120 120,210 210,480 480,660 660,990
are we not there yet.|
|

1083
00:34:34,490 --> 00:34:38,930
0,540 540,1170 1170,1200 1200,1650 3540,4440
{} We are not.| I
我们没有。|我想我们要单步了，我们不应该，是的。

1084
00:34:38,960 --> 00:34:40,610
0,630 630,810 810,1170 1170,1530 1530,1650
guess we're going steps, we

1085
00:34:40,610 --> 00:34:42,860
0,390 390,690 960,1440 1920,2130 2130,2250
shouldn't, yeah.| So if I
|如果我这么做了，会发生什么。

1086
00:34:42,860 --> 00:34:44,270
0,270 270,540 540,810 810,930 930,1410
did this, what would happen.|
|

1087
00:34:44,930 --> 00:34:46,400
0,270 270,420 420,570 570,930 930,1470
Well they would definitely crash,
它们肯定会崩溃，是的。

1088
00:34:46,610 --> 00:34:47,960
0,570 570,870 870,1020 1020,1170 1170,1350
right, alright.| So let's not
|所以我们不要这样做，

1089
00:34:47,960 --> 00:34:51,260
0,120 120,480 1920,2340
do this| or
|或者我不知道我们会不会崩溃，

1090
00:34:51,850 --> 00:34:52,630
0,300 300,450 450,510 510,600 600,780
I don't know if we'll

1091
00:34:52,630 --> 00:34:54,160
0,390 390,690 720,1110 1110,1350 1350,1530
crash,| but {} we would
|但是我们，

1092
00:34:54,160 --> 00:34:55,570
0,150 150,330 600,810 810,1110 1200,1410
then be,| if we if
|如果我们释放页面，

1093
00:34:55,570 --> 00:34:57,430
0,90 90,360 360,420 420,1350 1620,1860
we free the page,| it
|它肯定是 pa1 ，

1094
00:34:57,430 --> 00:34:59,110
0,150 150,600 930,1320 1320,1500 1500,1680
would be presumably {pa1 -

1095
00:34:59,110 --> 00:35:00,520
0,390 390,900 960,1080 1080,1290 1290,1410
-},| because we don't have
|因为我们不会释放 pa2 ，

1096
00:35:00,520 --> 00:35:02,860
0,210 210,960 1260,1980 1980,2070 2070,2340
free pa2,| because we're using
|因为我们用的是 pa2 ，

1097
00:35:02,860 --> 00:35:04,270
0,480 480,630 630,750 750,1200 1200,1410
pa2,| if we free pa1,
|如果我们释放 pa1 ，这意味着另一个进程会有问题，

1098
00:35:04,270 --> 00:35:06,370
0,180 180,510 510,810 930,1380 1380,2100
that means the other process

1099
00:35:06,370 --> 00:35:07,900
0,120 120,270 270,330 330,810 1350,1530
has got a problem,| it
|它现在已经映射到地址空间，

1100
00:35:07,900 --> 00:35:08,890
0,120 120,300 300,690 690,870 870,990
has now mapped into its

1101
00:35:08,890 --> 00:35:10,780
0,300 300,630 630,750 750,1140 1140,1890
address space| and presumably using
|大概是使用执行指令，我不知道是什么，

1102
00:35:10,870 --> 00:35:12,460
0,750 750,1260 1260,1410 1410,1530 1530,1590
executing instructions in, {} I

1103
00:35:12,460 --> 00:35:13,990
0,120 120,180 180,480 900,1200 1200,1530
don't know what,| a page
|我们刚刚释放的页面，

1104
00:35:13,990 --> 00:35:15,070
0,90 90,210 210,450 450,930 930,1080
that we just freed| and
|可能会被重新用于其他目的，

1105
00:35:15,070 --> 00:35:16,180
0,180 180,330 330,810 810,960 960,1110
might be reusing for some

1106
00:35:16,180 --> 00:35:17,480
0,150 150,750
other purpose,|
|

1107
00:35:17,480 --> 00:35:19,430
0,390 390,690 690,900 900,1290 1470,1950
writing something else over,| so
写些别的东西，|所以我不愿意释放它，尽管它是。

1108
00:35:19,430 --> 00:35:20,930
0,450 450,1020 1020,1110 1110,1320 1320,1500
I'm reluctant to free it,

1109
00:35:23,130 --> 00:35:24,680
0,480 480,960
although it's.|
|

1110
00:35:26,880 --> 00:35:29,300
0,450 450,690 690,990 990,1770
Oh yeah, so sadly,
是的，很遗憾，出现很多事情，

1111
00:35:29,460 --> 00:35:31,740
0,390 390,630 630,780 780,1770
among many other things,|
|

1112
00:35:31,960 --> 00:35:33,960
0,450 450,690 690,780 780,1500
{} {xv6 - -}
在原始的 xv6 中， walk 不会从 vm.c 以外调用，

1113
00:35:34,080 --> 00:35:35,700
0,450 450,570 570,900 900,1440 1440,1620
walk is never called from

1114
00:35:35,700 --> 00:35:36,720
0,480 480,570 570,660 660,810 810,1020
outside of the {vm.c -

1115
00:35:36,720 --> 00:35:37,900
0,600
-},

1116
00:35:38,420 --> 00:35:40,670
0,210 210,600 600,1140 1140,1290 1290,2250
in ordinary xv6,| but now
|但是现在我们正在做。

1117
00:35:40,700 --> 00:35:42,100
0,90 90,390 390,570
we're doing it.|
|

1118
00:35:51,120 --> 00:35:54,040
0,510 840,1110 1110,1290 1290,1770
Alright, where were we.|
好了，我们到哪儿了。|

1119
00:35:59,230 --> 00:36:00,480
0,840
Okay,
好的，记得我们得到的第一个页面是 scause 2 ，

1120
00:36:00,970 --> 00:36:02,080
0,210 210,300 300,510 510,870 870,1110
remeber the very first page

1121
00:36:02,080 --> 00:36:02,770
0,120 120,240 240,450 450,600 600,690
what we got was {scause

1122
00:36:02,770 --> 00:36:04,960
0,180 180,570 570,1020 1440,2100 2100,2190
- -} 2,| why are
|为什么我们会得到 scause 2 页面错误。

1123
00:36:04,960 --> 00:36:06,280
0,120 120,510 510,780 780,1110 1110,1320
we getting {scause -} 2

1124
00:36:06,280 --> 00:36:07,780
0,300 300,810
page faults.|
|

1125
00:36:14,300 --> 00:36:16,200
0,270 270,360 360,720 720,1350
It's an illegal instruction,|
这是非法指令，|

1126
00:36:20,920 --> 00:36:21,670
0,180 180,360 360,420 420,480 480,750
like this is the next
这是下一个问题，

1127
00:36:21,670 --> 00:36:23,380
0,510 960,1260 1260,1350 1350,1440 1440,1710
problem,| we have to solve
|我们现在必须解决这个问题。

1128
00:36:23,380 --> 00:36:24,940
0,120 120,480 480,1050
this problem now.|
|

1129
00:36:26,020 --> 00:36:27,380
0,180 180,390 390,930
What's gone wrong,|
出了什么问题，|

1130
00:36:32,300 --> 00:36:33,020
0,180 180,330 330,450 450,630 630,720
or what are what are
或者猜一下可能出了什么问题？

1131
00:36:33,020 --> 00:36:35,150
0,360 840,1350 1350,1830 1830,1950 1950,2130
some plausible guesses for what

1132
00:36:35,150 --> 00:36:36,620
0,180 180,270 270,480 480,900
might have gone wrong.|
|

1133
00:36:43,270 --> 00:36:44,590
0,330 330,450 450,990 990,1140 1140,1320
So the sequence we when
所以当我输入 cowtest ，

1134
00:36:44,590 --> 00:36:46,420
0,180 210,570 570,900 900,1620 1650,1830
I type {cowtest -},| what
|我们认为发生的情况是 shell fork 是写入时复制 fork 。

1135
00:36:46,420 --> 00:36:47,620
0,150 150,390 390,870 870,990 990,1200
we think happens is that

1136
00:36:47,620 --> 00:36:49,870
0,120 120,540 540,1650 1800,1980 1980,2250
the shell fork is {copy-on-write

1137
00:36:49,870 --> 00:36:51,320
0,90 90,300 300,930
- -} fork.|
|

1138
00:36:51,710 --> 00:36:53,390
0,150 150,240 240,300 300,1020 1020,1680
We have a child running
我们有个子进程在运行 shell 指令，

1139
00:36:55,590 --> 00:36:57,840
0,180 180,570 570,1710
the shell's instructions,|
|

1140
00:36:58,280 --> 00:37:01,460
0,720 750,1290 1290,2010 2310,2730 2730,3180
{} probably taking store faults,|
可能接受保存错误，|

1141
00:37:01,460 --> 00:37:02,750
0,210 510,660 660,930 930,1080 1080,1290
but for handling those store
但是为了处理这些保存错误，

1142
00:37:02,750 --> 00:37:04,100
0,210 210,750 870,1140 1140,1260 1260,1350
faults correctly| and then the
|然后子进程执行，

1143
00:37:04,100 --> 00:37:05,900
0,390 390,1290
child execs,|
|

1144
00:37:05,900 --> 00:37:07,010
0,60 60,450 450,720 720,810 810,1110
the child copy the shell
子进程复制 shell 执行 cowtest 。

1145
00:37:07,010 --> 00:37:08,900
0,390 390,630 630,1350
execs {cowtest -}.|

1146
00:37:10,550 --> 00:37:12,000
0,570

1147
00:37:13,920 --> 00:37:15,180
0,240 240,570 570,840 840,1020 1020,1260
What bad thing might that
这可能会对父进程 shell 造成什么坏事。

1148
00:37:15,180 --> 00:37:16,920
0,270 270,420 420,570 570,1020 1020,1740
do to the parent shell.|
|

1149
00:37:22,480 --> 00:37:23,740
0,210 210,360 360,480 480,690 690,1260
Well, when you call exec,|
当你调用 exec 的时候，|

1150
00:37:23,740 --> 00:37:25,780
0,150 150,780 780,870 870,1440
the implementation of exec
exec 的实现冻结了所有进程的当前页面，

1151
00:37:26,260 --> 00:37:28,330
0,420 420,1110 1110,1410 1410,1590 1590,2070
{} freeze up all the

1152
00:37:28,330 --> 00:37:30,680
0,540 540,870 870,1770
process's current pages,|
|

1153
00:37:31,140 --> 00:37:33,840
0,270 270,960 1080,1950 1980,2190 2190,2700
and then allocates new pages
然后分配新页面将文件加载到你的 exec 中。

1154
00:37:33,840 --> 00:37:35,880
0,150 150,960 1110,1260 1260,1620 1620,2040
to load the file into

1155
00:37:36,030 --> 00:37:37,320
0,240 240,720
your exec.|
|

1156
00:37:39,160 --> 00:37:39,880
0,180 180,300 300,360 360,600 600,720
What's going to happen in
子进程会发生什么，

1157
00:37:39,880 --> 00:37:41,890
0,90 90,990 1110,1230 1230,1680 1680,2010
the child,| the child shell
|子进程 shell 调用 exec ，

1158
00:37:41,890 --> 00:37:43,510
0,240 240,720 720,870 870,1440 1440,1620
calls exec,| it freeze all
|它冻结了所有的页面，

1159
00:37:43,510 --> 00:37:45,020
0,90 90,270 270,1050
of its pages,|
|

1160
00:37:50,630 --> 00:37:51,380
0,240 240,390 390,600 600,690 690,750
what's that gonna do to
这会对父进程 shell 造成什么影响。

1161
00:37:51,380 --> 00:37:53,150
0,60 60,420 420,1230 1290,1470 1470,1770
the parent shell.| Is it
|会不会。

1162
00:37:53,150 --> 00:37:55,280
0,300 300,480 480,810 900,1620 1620,2130
gonna end up.| {} {Oh,sorry}.|
|哦，对不起。|

1163
00:37:56,260 --> 00:37:57,670
0,150 150,360 360,480 480,990 990,1410
{Is,it} going to accidentally free
它会不会意外地释放 shell 的页面。

1164
00:37:57,670 --> 00:38:00,100
0,540 1080,1950
the shell's

1165
00:38:00,130 --> 00:38:03,400
0,510 600,1230 1230,2580 2850,3180 3180,3270
{} page pages.| Yes, we're
|是的，我们会释放 shell 的每一个页面，

1166
00:38:03,400 --> 00:38:04,270
0,150 150,360 360,540 540,750 750,870
gonna free every single one

1167
00:38:04,270 --> 00:38:05,890
0,270 270,600 600,1230 1230,1560 1560,1620
of shell's pages,| except the
|除了一两个要写入的页面。

1168
00:38:05,890 --> 00:38:07,060
0,210 210,300 300,600 600,810 810,1170
one or two that the

1169
00:38:07,850 --> 00:38:09,260
0,150 150,300 300,780 990,1260 1260,1410
that were written.| So this
|所以这包括了 shell 指令页面，

1170
00:38:09,260 --> 00:38:11,330
0,540 540,630 630,930 930,1380 1380,2070
includes the shells instruction pages,|
|

1171
00:38:11,630 --> 00:38:12,740
0,510 510,720 720,780 780,900 900,1110
and then we're going to
然后我们要重新分配它们，

1172
00:38:12,980 --> 00:38:14,330
0,900 900,1080 1080,1170 1170,1290 1290,1350
reallocate them,| they're going to
|它们会立即被 exec 重新分配，用来存放其他东西，

1173
00:38:14,330 --> 00:38:15,920
0,90 90,420 420,1020 1020,1110 1110,1590
be instantly reallocated by exec

1174
00:38:15,920 --> 00:38:17,510
0,60 60,420 420,600 600,1260 1260,1590
to hold other stuff,| loaded
|从我们运行的 cowtest 文件中加载，

1175
00:38:17,510 --> 00:38:18,590
0,240 240,480 480,840 840,960 960,1080
from the file that we're

1176
00:38:18,590 --> 00:38:20,390
0,360 450,720 720,1320 1500,1650 1650,1800
running {cowtest -},| so that's
|所以这会彻底改变 shell 的任何东西，

1177
00:38:20,390 --> 00:38:21,470
0,120 120,180 180,480 480,810 810,1080
going to totally change everything

1178
00:38:21,470 --> 00:38:22,940
0,60 60,150 150,390 390,960 990,1470
in the shell underfoot| and
|不出所料，它会立即崩溃。

1179
00:38:23,030 --> 00:38:25,040
0,1080 1230,1440 1440,1560 1560,1620 1620,2010
unsurprisingly, it's going to instantly

1180
00:38:25,040 --> 00:38:26,080
0,660
crash.|
|

1181
00:38:26,840 --> 00:38:28,940
0,690 990,1260 1260,1350 1350,1860 1860,2100
So, we have not free
所以，我们没有以某种方式释放这些页面，

1182
00:38:28,940 --> 00:38:30,640
0,240 240,600 600,1110
those pages somehow,|
|

1183
00:38:31,180 --> 00:38:32,420
0,630

1184
00:38:32,700 --> 00:38:34,740
0,120 120,330 330,480 480,1380
they don't see that.|
它们看不到这个。|

1185
00:38:34,740 --> 00:38:36,420
0,90 90,300 300,840 960,1320 1350,1680
A quick question,| {} what
我有一个简短的问题，|这里的 sepc 指向哪里，

1186
00:38:36,420 --> 00:38:38,640
0,210 210,510 510,1290 1290,1740 1740,2220
does the sepc here point

1187
00:38:38,640 --> 00:38:40,170
0,150 150,570 570,990 990,1320 1320,1530
to| which assembly file would
|你能从哪个汇编文件中找到那个指令吗？

1188
00:38:40,200 --> 00:38:42,060
0,180 180,420 420,570 570,1320
you find that instruction?|
|

1189
00:38:42,960 --> 00:38:44,520
0,870
Well.|
好。|

1190
00:38:47,200 --> 00:38:49,720
0,750

1191
00:38:53,270 --> 00:38:54,680
0,180 180,420 420,540 540,930 930,1410
You said its shell, right,
你说它是 shell ，它是。

1192
00:38:55,210 --> 00:38:57,160
0,270 270,360 420,1200 1260,1650 1650,1950
it's the.| Last time was
|上次是因为其他错误，

1193
00:38:57,160 --> 00:38:58,720
0,120 120,390 390,660 660,1080 1110,1560
for some other fault,| somewhere
|在那里它是 shell ，

1194
00:38:58,720 --> 00:39:00,250
0,630 660,780 780,900 900,1350 1380,1530
else it would shell,| what
|这里，我不知道是什么，

1195
00:39:00,250 --> 00:39:01,150
0,120 120,270 270,540 540,660 660,900
it is here I actually

1196
00:39:01,150 --> 00:39:02,880
0,210 210,360 360,450 450,1200
don't know,| I never,|
|我从来没有，|

1197
00:39:03,200 --> 00:39:05,120
0,900 930,1050 1050,1230 1230,1500 1500,1920
{} I did not unfortunately
我没有花时间去追查这件事。

1198
00:39:05,120 --> 00:39:05,990
0,180 180,270 270,480 480,570 570,870
take the time to track

1199
00:39:05,990 --> 00:39:07,320
0,180 180,690
this down.|
|

1200
00:39:07,500 --> 00:39:10,320
0,570 960,1320 1380,1860 1890,2280 2520,2820
{} The, { -} so
所以这个问题可能有多个答案，

1201
00:39:10,320 --> 00:39:11,490
0,210 210,540 540,690 690,900 900,1170
one problem with any answer,|
|

1202
00:39:11,490 --> 00:39:12,360
0,210 210,360 360,540 540,720 720,870
even if I could give
即使我能给你答案，

1203
00:39:12,360 --> 00:39:13,860
0,120 120,210 210,840 870,1170 1170,1500
you an answer,| so the
|所以答案是 shell 或者 cowtest ，

1204
00:39:13,860 --> 00:39:14,790
0,180 180,240 240,480 480,570 570,930
answer is either the shell

1205
00:39:14,790 --> 00:39:17,280
0,90 90,300 300,1020 1380,1890
or {cowtest -}, {}|
|

1206
00:39:17,370 --> 00:39:19,620
0,210 210,630 630,930 930,1710
for process id 3,
对于进程 id 3 ，也可能是 cowtest 。

1207
00:39:20,060 --> 00:39:21,840
0,270 270,540 540,720 720,1170
that again is the,

1208
00:39:22,420 --> 00:39:24,660
0,180 180,570 570,990 990,1710
it's probably {cowtest -}.|
|

1209
00:39:25,140 --> 00:39:25,860
0,210 210,330 330,450 450,510 510,720
I just say I don't
我只是说我不完全知道这是怎么回事，

1210
00:39:25,860 --> 00:39:26,940
0,390 390,510 510,660 660,900 900,1080
completely know what's going on

1211
00:39:26,940 --> 00:39:28,920
0,330 450,960 1200,1770 1770,1860 1860,1980
here,| {} looking at the
|查看 asm 文件可能没有帮助，

1212
00:39:28,920 --> 00:39:30,570
0,420 420,660 660,870 900,1560 1560,1650
asm file is unlikely to

1213
00:39:30,570 --> 00:39:32,400
0,120 120,900 1080,1410 1410,1500 1500,1830
be helpful,| because the whole
|因为我们认为已经发生的整个问题是，

1214
00:39:32,400 --> 00:39:33,900
0,720 720,930 930,1050 1050,1380 1380,1500
problem that we believe has

1215
00:39:33,900 --> 00:39:35,920
0,630 660,870 870,1290
happened is that,|
|

1216
00:39:36,590 --> 00:39:39,500
0,180 180,960 960,1470 1470,2430 2460,2910
the page holding instructions was
保存指令的页面被释放并重新使用，

1217
00:39:39,500 --> 00:39:41,720
0,630 630,780 780,1800 1920,2100 2100,2220
freed and reused,| and so
|所以，它们不再执行 asm 文件中的指令，

1218
00:39:41,720 --> 00:39:44,660
0,90 90,390 390,1170 1440,1890 1920,2940
they were therefore not executing

1219
00:39:45,110 --> 00:39:46,310
0,180 180,750 750,810 810,870 870,1200
the instructions in the {asm

1220
00:39:46,310 --> 00:39:49,130
0,540 540,810 810,1470 1950,2400 2430,2820
-} file anymore,| or executing
|或者执行一些垃圾，

1221
00:39:49,130 --> 00:39:50,540
0,150 150,1020
some garbage,|
|

1222
00:39:52,370 --> 00:39:53,120
0,210 210,300 300,420 420,540 540,750
so we could look at
所以我们可以看看地址 1004 ，但是它，

1223
00:39:53,120 --> 00:39:55,180
0,300 300,750 750,990 990,1140 1140,1410
address {1004,but - -} it,|
|

1224
00:39:55,970 --> 00:39:56,840
0,180 180,360 360,510 510,750 750,870
it wouldn't really tell us
它不会真正告诉我们发生了什么。

1225
00:39:56,840 --> 00:39:58,380
0,270 270,510 510,1140
what had happened.|
|

1226
00:39:58,740 --> 00:39:59,910
0,210 210,480 480,720 720,930 930,1170
{} We might we probably
我们可能使用调试器找出这一点，

1227
00:39:59,910 --> 00:40:00,900
0,150 150,330 330,480 480,720 720,990
could find this out using

1228
00:40:00,900 --> 00:40:02,100
0,150 150,630
the debugger,|
|

1229
00:40:02,400 --> 00:40:04,770
0,450 660,1080 1080,1350 1350,1560 1560,2370
{} we could {} break
我们可以在 gdb 中打断，然后查看指令，

1230
00:40:05,440 --> 00:40:06,490
0,150 150,600 600,690 690,870 870,1050
in gdb and then look

1231
00:40:06,490 --> 00:40:08,200
0,60 60,150 150,660 660,960 960,1710
at the instructions,| it's actually
|它实际上是一个 1004 指向的虚拟地址。

1232
00:40:08,710 --> 00:40:10,390
0,330 330,480 480,1080 1080,1380 1380,1680
{} at whatever virtual address

1233
00:40:10,390 --> 00:40:12,100
0,60 60,480 480,990 1230,1530 1530,1710
{1004 - -} points to.|
|

1234
00:40:13,190 --> 00:40:15,860
0,480 480,990 990,1620 1740,2370 2400,2670
Quick follow-up question, {} about
更进一步的问题，关于那个[]，

1235
00:40:15,860 --> 00:40:19,250
0,300 300,1020 1380,1860 1890,2520 3240,3390
that [],| {} so my
|所以我的理解是我们得到了一个非法指令错误，

1236
00:40:19,250 --> 00:40:20,480
0,360 360,450 450,690 690,780 780,1230
understanding is that we're getting

1237
00:40:20,480 --> 00:40:22,190
0,270 270,840 840,960 960,1380 1380,1710
an invalid {} instruction fault,|
|

1238
00:40:22,190 --> 00:40:25,100
0,900 990,1500 1500,1620 1620,2400
because like we're changing
因为我们改变了指令页指令物理内存，

1239
00:40:25,300 --> 00:40:27,310
0,210 210,660 660,930 930,1710 1710,2010
the instruction page instruction physical

1240
00:40:27,310 --> 00:40:28,570
0,240 240,870 870,960 960,1170 1170,1260
memory underfoot,| and like the
|那些内存被写了别的东西，

1241
00:40:28,570 --> 00:40:29,830
0,540 540,750 750,960 960,1170 1170,1260
memories just being written to

1242
00:40:29,830 --> 00:40:32,530
0,330 330,1050 1110,1650 2160,2370 2370,2700
something else,| {} is it
|有没有可能，比如某些幸运的情况下，

1243
00:40:32,680 --> 00:40:34,440
0,780 780,1230
possible that,

1244
00:40:34,440 --> 00:40:36,270
0,300 630,780 780,1080 1080,1410 1410,1830
like in some lucky case,|
|

1245
00:40:36,270 --> 00:40:37,300
0,450
that
它们正在被重写，

1246
00:40:37,360 --> 00:40:38,800
0,150 150,360 360,540 540,1200 1320,1440
they are being rewritten,| but
|但是当我们再次查看它时，

1247
00:40:38,800 --> 00:40:39,370
0,120 120,210 210,360 360,450 450,570
when we look at it

1248
00:40:39,370 --> 00:40:41,500
0,330 330,480 480,690 690,1980 1980,2130
again,| it's being rewritten to
|它正在被重写为有效的指令页，

1249
00:40:41,500 --> 00:40:42,880
0,300 300,780 780,1170 1170,1260 1260,1380
valid instruction pages,| so we
|所以我们开始执行随机指令，

1250
00:40:42,880 --> 00:40:44,380
0,180 180,240 240,360 360,780 930,1500
{actually -} to start executing

1251
00:40:44,380 --> 00:40:45,280
0,330
like

1252
00:40:45,370 --> 00:40:46,570
0,360 360,900 900,990 990,1050 1050,1200
random instructions| and we don't
|却没有得到非法指令错误，

1253
00:40:46,570 --> 00:40:48,040
0,300 300,420 420,480 480,960 960,1470
actually get an invalid instruction

1254
00:40:48,040 --> 00:40:48,880
0,240 240,300 300,450 450,600 600,840
fault,| we get some other
|我们得到一些其他错误。

1255
00:40:48,880 --> 00:40:52,960
0,330 600,1350 1410,2220 2700,3570
fault.| Yes, absolutely, absolutely.|
|是的，绝对的。|

1256
00:40:53,440 --> 00:40:54,790
0,300 300,450 450,630 630,750 750,1350
Yeah, yeah I mean really
是的，我是说什么事都有可能发生。

1257
00:40:54,820 --> 00:40:56,200
0,150 150,780
we're now,

1258
00:40:56,350 --> 00:40:58,420
0,240 270,690 690,810 810,1260 1680,2070
like anything could happen. {}|
|

1259
00:40:58,630 --> 00:41:00,100
0,540 690,1050 1050,1200 1200,1380 1380,1470
{I,see}.| I would not have
我明白了。|我猜不到，

1260
00:41:00,100 --> 00:41:01,390
0,90 90,270 270,390 390,1110 1140,1290
been able to guess,| if
|如果我没有做这个实验，

1261
00:41:01,390 --> 00:41:02,700
0,120 120,300 300,750
I had not

1262
00:41:03,160 --> 00:41:04,880
0,180 180,360 360,1410
done this lab,|
|

1263
00:41:04,940 --> 00:41:06,380
0,900
I
在这里，我猜不出会出什么问题。

1264
00:41:06,620 --> 00:41:07,370
0,300 300,360 360,480 480,570 570,750
wouldn't be able to guess

1265
00:41:07,370 --> 00:41:08,120
0,210 210,300 300,450 450,660 660,750
what will go wrong at

1266
00:41:08,120 --> 00:41:09,180
0,150 150,420
this point.|
|

1267
00:41:09,530 --> 00:41:10,580
0,480

1268
00:41:11,720 --> 00:41:13,070
0,390 390,510 510,810 810,1020 1020,1350
Indeed I think I've seen
事实上，我认为我在这一点上还看到了其他奇怪的事情发生。

1269
00:41:13,070 --> 00:41:16,100
0,450 450,1110 1110,2100 2520,2940 2940,3030
other strange things happen at

1270
00:41:16,100 --> 00:41:18,160
0,180 180,750
this point.|
|

1271
00:41:18,540 --> 00:41:19,620
0,180 180,450 450,570 570,960 960,1080
It's maybe the data, may
可能是第一页数据有垃圾，

1272
00:41:19,620 --> 00:41:20,730
0,90 90,180 180,450 450,870 870,1110
be the first page that

1273
00:41:20,850 --> 00:41:21,900
0,240 240,600 600,690 690,810 810,1050
has garbage| and it actually
|它里面有数据，

1274
00:41:21,900 --> 00:41:23,100
0,180 180,450 450,630 630,870 870,1200
has data { -}| and
|并且 shell 会遍历完整的垃圾数据，

1275
00:41:23,730 --> 00:41:25,200
0,300 300,630 630,840 840,1080 1080,1470
shell trips over some complete

1276
00:41:25,200 --> 00:41:27,630
0,360 360,900 930,1170 1170,1830 2100,2430
garbage data,| like stack, instead
|比如堆栈，而不是指令。

1277
00:41:27,630 --> 00:41:28,960
0,60 60,810
of instructions.|
|

1278
00:41:30,940 --> 00:41:31,750
0,270 270,480 480,570 570,690 690,810
Okay, so we don't want
好的，所以我们不想马上释放页面，

1279
00:41:31,750 --> 00:41:32,500
0,60 60,210 210,300 300,600 600,750
to free the page right

1280
00:41:32,500 --> 00:41:34,150
0,210 210,510 720,1290 1290,1470 1470,1650
away,| we, we only want
|我们只想在页面真的不再使用的时候释放它。

1281
00:41:34,150 --> 00:41:34,960
0,60 60,210 210,300 300,600 600,810
to free the page when

1282
00:41:34,960 --> 00:41:36,250
0,330 330,570 570,750 750,900 900,1290
it's really not being used

1283
00:41:36,250 --> 00:41:38,580
0,600
anymore.|
|

1284
00:41:39,730 --> 00:41:43,090
0,540 750,930 930,1410 1410,1980 2130,3360
So can anybody {} propose
那么有没有人能提出标准，

1285
00:41:43,090 --> 00:41:46,570
0,660 1050,2070 2070,2280 2280,3060 3090,3480
{} criterion| for when we
|何时应该或不应该释放每个页面的内存？

1286
00:41:46,570 --> 00:41:48,010
0,570 570,690 690,1140 1140,1350 1350,1440
should or shouldn't free the

1287
00:41:48,010 --> 00:41:49,720
0,360 390,660 660,1290 1320,1620 1620,1710
page for each page of

1288
00:41:49,720 --> 00:41:50,720
0,510
memory?|
|

1289
00:41:51,080 --> 00:41:52,280
0,150 150,300 300,570 570,960 960,1200
We could keep track of
我们可以记录有多少次，

1290
00:41:52,280 --> 00:41:54,980
0,180 180,420 420,690 690,1620 2460,2700
like how many times are|
|

1291
00:41:54,980 --> 00:41:57,590
0,240 240,660 660,1380 1380,1770 1770,2610
like basically whenever in kalloc
就像在 kalloc 中，无论你什么时候，

1292
00:41:57,590 --> 00:41:59,220
0,420 420,990
whenever you,|
|

1293
00:41:59,250 --> 00:42:01,020
0,360 360,570 570,1020 1020,1200 1200,1770
you should increment and decrement
你应该递增和递减某些类型变量，

1294
00:42:01,020 --> 00:42:02,880
0,210 210,480 480,1290 1470,1650 1650,1860
some type variable| and keep
|并保持所有不同地址的数组。

1295
00:42:02,880 --> 00:42:04,560
0,90 90,630 630,1140 1170,1440 1440,1680
an array of like all

1296
00:42:04,560 --> 00:42:06,870
0,120 120,390 390,1050 1260,2040 2040,2310
the different addresses.| Yes, yeah
|是的，没错。

1297
00:42:06,870 --> 00:42:08,310
0,390 390,810 840,1020 1020,1260 1260,1440
exactly.| So, {} one way
|所以，考虑这个问题的一种方式是，

1298
00:42:08,310 --> 00:42:09,240
0,120 120,300 300,540 540,780 780,930
to think about this is|
|

1299
00:42:09,240 --> 00:42:10,080
0,270 270,390 390,540 540,600 600,840
that we want to only
我们只想在页面引用为零的情况下，释放该页面，

1300
00:42:10,080 --> 00:42:12,300
0,210 210,270 270,1140 1230,1740 1860,2220
free a page, when there's

1301
00:42:12,300 --> 00:42:15,210
0,960 1200,1710 1710,2430 2430,2610 2610,2910
zero page tables that refer

1302
00:42:15,210 --> 00:42:17,190
0,120 120,510 750,1380 1620,1890 1890,1980
to it,| {} but there
|但是，可能会有很多，

1303
00:42:17,190 --> 00:42:18,900
0,210 210,300 300,780 780,960 960,1710
could be many,| if a
|如果一个程序 fork 再 fork ，

1304
00:42:18,900 --> 00:42:20,550
0,270 270,630 630,780 780,1050 1050,1650
program forks and forks again

1305
00:42:20,550 --> 00:42:21,990
0,270 270,660 660,1200 1200,1320 1320,1440
forks again,| boy, we can
|我们现在可以有三到四个不同的进程，

1306
00:42:21,990 --> 00:42:23,250
0,150 150,390 390,720 780,1170 1170,1260
now have like three or

1307
00:42:23,250 --> 00:42:24,780
0,210 210,450 450,1110 1110,1260 1260,1530
four different processes,| that all
|都引用写入时复制 fork 到这一页，

1308
00:42:24,780 --> 00:42:26,340
0,690 900,990 990,1290 1290,1380 1380,1560
refer to {copy-on-write - -}

1309
00:42:26,340 --> 00:42:27,900
0,300 360,480 480,660 660,870 870,1560
fork to this one page,|
|

1310
00:42:28,560 --> 00:42:30,240
0,510 540,750 750,990 990,1440
{} so that this,
所以这个计数，

1311
00:42:30,330 --> 00:42:31,230
0,90 90,150 150,330 330,810 810,900
you know this count of|
|

1312
00:42:31,230 --> 00:42:32,190
0,120 120,330 330,600 600,750 750,960
how many times how many
有多少页表引用一个页面，

1313
00:42:32,190 --> 00:42:33,330
0,360 360,780 780,990 990,1080 1080,1140
page tables refer to a

1314
00:42:33,330 --> 00:42:34,290
0,270 270,390 390,540 540,780 780,960
page| and go up due
|因为 fork 继续增长，

1315
00:42:34,290 --> 00:42:35,610
0,90 90,630 840,1140 1140,1200 1200,1320
to fork| and they can
|当进程退出时，可以下降，

1316
00:42:35,610 --> 00:42:37,080
0,120 120,390 390,1110 1170,1440 1440,1470
go back down when a

1317
00:42:37,080 --> 00:42:39,120
0,390 390,960 960,1020 1020,1350 1350,2040
process exits| or calls exec
|或者调用 exec ，它会清除所有页表条目的引用，

1318
00:42:39,570 --> 00:42:41,190
0,390 450,690 690,990 1020,1440 1440,1620
you know it clears all
它会将所有这些引用从页表条目中清除，

1319
00:42:41,190 --> 00:42:42,300
0,330 330,780 780,900 900,960 960,1110
these references out of its

1320
00:42:42,300 --> 00:42:43,770
0,270 270,540 540,960 1020,1380 1380,1470
page table entry| or if
|或者如果进程进行写入并导致写入错误，

1321
00:42:43,770 --> 00:42:45,390
0,90 90,570 570,1140 1230,1530 1530,1620
a process actually does a

1322
00:42:45,390 --> 00:42:46,980
0,540 810,990 990,1230 1230,1320 1320,1590
write and causes a write

1323
00:42:46,980 --> 00:42:49,260
0,510 690,1110 1110,1500 1500,1710 1710,2280
fault,| that's also a situation
|这也是我们减少一个引用的情况，

1324
00:42:49,260 --> 00:42:50,520
0,60 60,600 630,750 750,840 840,1260
in which we have one

1325
00:42:50,520 --> 00:42:53,490
0,420 420,1140 1710,2160 2160,2460 2460,2970
fewer reference,| fewer page tables
|减少一个到页面的页表引用。

1326
00:42:53,490 --> 00:42:55,120
0,390 390,510 510,570 570,1170
referring to a page.|
|

1327
00:42:55,210 --> 00:42:55,870
0,210 210,270 270,420 420,480 480,660
So we want to keep
所以我们需要一个计数，

1328
00:42:55,870 --> 00:42:57,880
0,660 930,1560 1680,1830 1830,1890 1890,2010
{a,count},| {} and we want
|我们想要通过计算引用页面的页表条目来进行计数。

1329
00:42:57,880 --> 00:42:59,530
0,60 60,480 480,540 540,1170 1440,1650
to count by counting the

1330
00:42:59,530 --> 00:43:00,700
0,210 210,270 270,570 570,840 840,1170
number of page table entries

1331
00:43:00,700 --> 00:43:01,930
0,150 150,420 420,510 510,600 600,1230
that refer to a page.|
|

1332
00:43:02,840 --> 00:43:03,740
0,300 300,390 390,660 660,750 750,900
So we need to think
所以我们需要考虑如何保持这个计数，

1333
00:43:03,740 --> 00:43:05,330
0,360 750,990 990,1080 1080,1440 1440,1590
about how to maintain this

1334
00:43:05,330 --> 00:43:06,710
0,270 270,390 390,780 780,900 900,1380
count,| and when to increment
|什么时候增加它，

1335
00:43:06,710 --> 00:43:09,050
0,180 570,1920 1920,2160 2160,2280 2280,2340
it,| exactly where in the
|在代码中的什么位置递增和递减。

1336
00:43:09,050 --> 00:43:10,190
0,240 240,300 300,690 690,960 960,1140
code to increment it and

1337
00:43:10,190 --> 00:43:11,620
0,810
{decrement,it}.|
|

1338
00:43:12,870 --> 00:43:15,030
0,780 870,1140 1140,1410 1410,1710 1710,2160
{} Okay so they {},|
好的，所以它们，|

1339
00:43:15,940 --> 00:43:17,800
0,240 240,660 660,1410 1500,1680 1680,1860
if there's as you maybe
如果，你可能意识到，

1340
00:43:17,800 --> 00:43:20,590
0,420 420,780 840,1620 1620,2130 2130,2790
aware,| there's multiple ways to
|有多种方法可以维持这一计数，

1341
00:43:20,860 --> 00:43:22,120
0,630
{}

1342
00:43:22,180 --> 00:43:24,700
0,390 390,540 540,930 1560,2340 2340,2520
maintain this count,| {the,way} I
|我的方法是创建一个名为 refcount 的数组，

1343
00:43:24,700 --> 00:43:27,130
0,210 210,660 690,1290 1290,1380 1380,2430
do it is I {make,an,array}

1344
00:43:27,430 --> 00:43:30,130
0,960 1260,1590 1590,1830 1830,2310 2430,2700
{} called {refcount -},| just
|给每一页一个计数。

1345
00:43:30,130 --> 00:43:31,060
0,150 150,240 240,360 510,720 720,930
gonna have it for every

1346
00:43:31,060 --> 00:43:32,340
0,780
page

1347
00:43:32,340 --> 00:43:33,580
0,570
{a,count}.|
|

1348
00:43:33,640 --> 00:43:34,450
0,390 390,540 540,660 660,720 720,810
{} We need to know
我们需要知道有多少条目在 refcount 中，

1349
00:43:34,450 --> 00:43:35,560
0,300 300,570 570,930 930,1020 1020,1110
how many entries are in

1350
00:43:35,560 --> 00:43:37,540
0,240 240,570 870,1110 1110,1680 1680,1980
{refcount -},| in xv6, so
|在 xv6 中，很简单，

1351
00:43:37,540 --> 00:43:40,300
0,600 840,1620 1890,2340 2400,2550 2550,2760
simple,| {} that it just
|它只使用固定数量的物理内存，

1352
00:43:40,300 --> 00:43:41,440
0,510 510,630 630,840 840,1080 1080,1140
has it just uses a

1353
00:43:41,440 --> 00:43:43,120
0,390 390,600 600,690 690,1260 1290,1680
fixed amount of memory, physical

1354
00:43:43,120 --> 00:43:44,290
0,510 540,810 810,960 960,1080 1080,1170
memory,| we only need to
|我们只需要对每页物理内存一个计数，

1355
00:43:44,290 --> 00:43:45,490
0,210 210,270 270,660 660,900 900,1200
keep a count per page

1356
00:43:45,490 --> 00:43:47,920
0,60 60,390 390,900 1110,1860 1980,2430
of physical memory,| {} we
|我们知道，根据对 kinit 的观察，

1357
00:43:47,920 --> 00:43:49,380
0,570 570,960
know that,

1358
00:43:49,440 --> 00:43:52,380
0,270 270,480 480,1230 1470,2100 2370,2940
{} from inspecting kinit,| that
|xv6 仅使用 PHYSTOP ，物理内存量，

1359
00:43:52,650 --> 00:43:53,840
0,600
{}

1360
00:43:53,840 --> 00:43:54,980
0,240 240,360 360,600 600,870 870,1140
{xv6 - -} uses only

1361
00:43:54,980 --> 00:43:57,140
0,360 360,960 1230,1650 1650,1800 1800,2160
{PHYSTOP -}, amount of physical

1362
00:43:57,140 --> 00:43:58,880
0,480 990,1320 1320,1530 1530,1620 1620,1740
memory,| we only need to
|我们只需要保持每页的计数，而不是每字节，

1363
00:43:58,880 --> 00:44:00,500
0,240 240,330 330,660 660,810 810,1620
keep a count per page,

1364
00:44:00,500 --> 00:44:01,400
0,210 210,330 330,690 690,840 840,900
not per byte,| so we're
|所以我们要把 PHYSTOP 除以 4096 ，

1365
00:44:01,400 --> 00:44:02,690
0,120 120,210 210,630 750,1050 1050,1290
going to divide {PHYSTOP -}

1366
00:44:02,690 --> 00:44:04,680
0,150 150,1530
by 4096,|
|

1367
00:44:04,710 --> 00:44:05,880
0,240 240,330 330,540 540,750 750,1170
that's how many array elements
这就是我们需要的数组元素。

1368
00:44:05,880 --> 00:44:06,820
0,90 90,450
we need.|
|

1369
00:44:09,150 --> 00:44:10,500
0,480 540,660 660,720 720,870 870,1350
{} In a more serious
在更正式的操作系统中，

1370
00:44:10,500 --> 00:44:11,640
0,330 330,660 660,870 870,1050 1050,1140
operating system,| we don't know
|我们不知道有多少内存可用，

1371
00:44:11,640 --> 00:44:12,870
0,120 120,300 300,510 510,600 600,1230
how much memory is available,|

1372
00:44:13,460 --> 00:44:15,230
0,660 660,810 810,1290 1290,1350 1350,1770
until we inspect the hardware,|
除非我们检查硬件，|

1373
00:44:15,230 --> 00:44:16,580
0,120 120,300 300,420 420,750
we might have to,
我们不得不动态分配这个数组。

1374
00:44:16,580 --> 00:44:17,660
0,120 120,360 360,540 540,660 660,1080
we would have to allocate

1375
00:44:17,660 --> 00:44:21,620
0,150 150,660 2190,2910 3330,3510 3510,3960
this array dynamically.| Any questions
|有什么问题吗，把计数放在哪里？

1376
00:44:21,620 --> 00:44:22,480
0,300
about,

1377
00:44:22,870 --> 00:44:23,890
0,180 180,240 240,360 360,450 450,1020
where to put the counts?|
|

1378
00:44:28,410 --> 00:44:31,380
0,420 450,960 1320,1680 1680,2310 2340,2970
Alright. {}| Actually.| Yes.| I'm
好的。|事实上。|是。|我在想，你直接使用 4096 是什么原因，

1379
00:44:31,410 --> 00:44:32,490
0,450 450,570 570,750 750,810 810,1080
wondering is there a reason

1380
00:44:32,490 --> 00:44:34,710
0,120 120,270 270,600 600,1590 1590,2220
that you're using 4096 specifically|
|

1381
00:44:34,710 --> 00:44:36,030
0,150 150,360 360,690 720,960 960,1320
and not the page size
而不是页面大小的宏。

1382
00:44:36,030 --> 00:44:37,160
0,510
macro.|
|

1383
00:44:37,850 --> 00:44:38,840
0,360 360,510 510,630 630,900 900,990
{} Yeah the reason is
是的，原因是我记得 4096 ，

1384
00:44:38,840 --> 00:44:40,820
0,120 120,240 240,390 390,810 810,1980
that I can remember 4096|
|

1385
00:44:40,970 --> 00:44:42,230
0,600 600,690 690,900 900,1170 1170,1260
and I don't remember the
我不记得页面大小宏的名称了，

1386
00:44:42,230 --> 00:44:43,100
0,180 180,240 240,300 300,570 570,870
name of the page size

1387
00:44:43,100 --> 00:44:44,600
0,510 810,1050 1050,1140 1140,1440 1440,1500
macro,| but I'm happy to
|不过，如果你愿意的话，我很乐意用。

1388
00:44:44,600 --> 00:44:45,470
0,180 180,270 270,360 360,480 480,870
use it, if you like.|
|

1389
00:44:46,360 --> 00:44:47,620
0,690

1390
00:44:47,850 --> 00:44:49,660
0,210 210,570 570,1170
It actually if
实际上，如果 xv6 的目的是可移植的，

1391
00:44:50,340 --> 00:44:51,840
0,300 300,720 720,930 930,1080 1080,1500
if {xv6 -} was intended

1392
00:44:51,840 --> 00:44:52,680
0,90 90,210 210,690 690,780 780,840
to be portable| and to
|并且能够在具有不同页面大小的各种不同的机器上运行，

1393
00:44:52,680 --> 00:44:53,820
0,60 60,180 180,270 270,690 690,1140
be able to run on

1394
00:44:53,910 --> 00:44:55,020
0,270 270,480 480,540 540,750 750,1110
all kinds of different machines

1395
00:44:55,020 --> 00:44:56,460
0,90 90,330 330,540 540,1080 1140,1440
with different page sizes,| we
|我们必须对此更加小心，

1396
00:44:56,460 --> 00:44:57,060
0,120 120,180 180,270 270,480 480,600
have to be much more

1397
00:44:57,060 --> 00:44:58,920
0,360 360,570 570,900 900,1200 1350,1860
careful about this,| but there's
|但是有 500 种方式使得 xv6 完全不能移植。

1398
00:44:58,950 --> 00:45:00,570
0,570 570,930 930,990 990,1170 1170,1620
500 ways in which xv6

1399
00:45:00,570 --> 00:45:03,720
0,270 570,960 960,1170 1170,1710
is totally not portable.|
|

1400
00:45:04,390 --> 00:45:05,880
0,900
So,
所以，我不担心这件事。

1401
00:45:07,450 --> 00:45:08,830
0,420 660,900 900,1080 1080,1260 1260,1380
{} {I,don't} worry about it.|
|

1402
00:45:09,250 --> 00:45:11,440
0,450 450,900 900,1380 1380,1500 1500,2190
Page sizes determined in hardware
我猜页面大小是由硬件决定的，在哪里。

1403
00:45:11,440 --> 00:45:13,400
0,120 120,210 210,660 690,1410
and I guess where.|

1404
00:45:15,100 --> 00:45:16,500
0,120 120,180 180,840
In the hardware,
在硬件中，RISC-V 手册上说，页面是多大。

1405
00:45:17,310 --> 00:45:20,100
0,270 270,420 420,960 960,1770 1800,2790
that {RISC-V -} manual says,

1406
00:45:20,710 --> 00:45:22,220
0,150 150,270 270,270 270,960
how big a pages.|
|

1407
00:45:22,560 --> 00:45:24,740
0,450 450,780 780,1020 1020,1500
Yeah, because the, {}|
是的，因为，|

1408
00:45:24,940 --> 00:45:27,700
0,300 300,510 510,930 930,1620 1770,2760
it's the {MMU -} that
是 MMU 接受虚拟地址，

1409
00:45:28,380 --> 00:45:30,240
0,420 420,510 510,930 930,1650 1650,1860
takes a virtual address| and
|并使用它来索引页表。

1410
00:45:30,240 --> 00:45:31,380
0,330 330,480 480,570 570,990 990,1140
uses it to index into

1411
00:45:31,380 --> 00:45:33,690
0,120 120,480 480,870 1170,1920 1920,2310
the page table.| Oh, right
|哦，对，因为地址转换是在硬件中进行的，

1412
00:45:33,720 --> 00:45:35,550
0,330 330,540 540,810 810,1200 1200,1830
right, because the address translation

1413
00:45:35,550 --> 00:45:37,080
0,540 540,690 690,1110 1110,1380 1380,1530
happens in hardware,| so the
|所以硬件必须知道页面大小，好的。

1414
00:45:37,080 --> 00:45:38,040
0,330 330,570 570,660 660,810 810,960
hardware has to know how

1415
00:45:38,040 --> 00:45:40,590
0,270 300,900 900,1110 1140,1560 2220,2550
big pages are, okay.| It's
|它是可配置的，

1416
00:45:40,590 --> 00:45:42,720
0,750 750,1050 1410,1740 1740,1830 1830,2130
configurable,| but you know there's
|但是有几种不同的策略可以告诉硬件使用，

1417
00:45:42,720 --> 00:45:43,800
0,60 60,300 300,510 510,990 990,1080
a couple different strategies you

1418
00:45:43,800 --> 00:45:44,490
0,90 90,300 300,360 360,570 570,690
can tell the {hardware -}

1419
00:45:44,490 --> 00:45:45,630
0,90 90,390 390,600 750,930 930,1140
to use,| but we tell
|但是我们告诉它使用 4096 字节的页面。

1420
00:45:45,630 --> 00:45:47,580
0,60 60,150 150,450 450,1470 1470,1950
it to use 4096 byte

1421
00:45:47,670 --> 00:45:48,720
0,690
pages.|
|

1422
00:45:49,670 --> 00:45:52,370
0,570 960,1350 1350,1650 1650,2190 2220,2700
Okay.| Where, sorry professor, {}|
好的。|抱歉，教授，|

1423
00:45:52,400 --> 00:45:53,690
0,240 240,510 510,1080 1080,1140 1140,1290
so where are, I guess
哪里，我想这是个 C 的问题，

1424
00:45:53,690 --> 00:45:54,740
0,120 120,210 210,360 360,780 780,1050
is a C question,| so
|所以我们的全局变量比如 refcount 存储在哪里，

1425
00:45:54,740 --> 00:45:58,220
0,390 510,780 780,1080 1080,1890 2250,3480
in where our global variables

1426
00:45:58,220 --> 00:46:00,540
0,210 210,390 390,720 780,1860
like {refcount -} stored,|
|

1427
00:46:00,690 --> 00:46:01,680
0,270 270,450
like what,
比如它们与特定的处理器绑定吗？

1428
00:46:02,030 --> 00:46:03,290
0,510 540,660 660,750 750,1140 1140,1260
like are they associated with

1429
00:46:03,290 --> 00:46:04,560
0,690
specific

1430
00:46:04,560 --> 00:46:06,780
0,990 990,1380 1410,2040 2040,2130 2130,2220
{processor -}?| This is the
|这是内核，

1431
00:46:06,780 --> 00:46:08,080
0,660
kernel,|
|

1432
00:46:08,200 --> 00:46:10,720
0,630 1260,1830 1830,2130 2130,2400 2400,2520
{} what's going on is
所发生的是可执行文件，

1433
00:46:10,720 --> 00:46:12,400
0,180 180,300 300,930 930,1080 1080,1680
that the file, the executable

1434
00:46:12,400 --> 00:46:13,720
0,780
file,|
|

1435
00:46:14,200 --> 00:46:15,800
0,1020

1436
00:46:16,420 --> 00:46:18,130
0,360 570,690 690,1320 1320,1440 1440,1710
that the compiler and the
编译器和加载器或链接器产生的，

1437
00:46:18,160 --> 00:46:20,840
0,570 570,690 690,1080 1080,2130
loader or linker produces,|
|

1438
00:46:22,270 --> 00:46:24,010
0,630 660,900 900,1140 1140,1560 1560,1740
{} has this sort of
有这种，|

1439
00:46:24,520 --> 00:46:28,390
0,540 600,1590 2220,3090 3120,3510 3510,3870
this,| {} indicates how much
|表明有多少数据，

1440
00:46:28,390 --> 00:46:29,800
0,300 300,540 540,750 750,1140 1140,1410
data,| how the total size
|程序中所有全局变量的总大小是多少。

1441
00:46:29,800 --> 00:46:31,000
0,90 90,240 240,330 330,630 630,1200
of all the global variables

1442
00:46:31,000 --> 00:46:32,300
0,60 60,150 150,780
in the program.|
|

1443
00:46:32,760 --> 00:46:34,160
0,750
And,
我们看不到这些代码，

1444
00:46:34,340 --> 00:46:35,120
0,270 270,390 390,540 540,690 690,780
so we don't see the

1445
00:46:35,120 --> 00:46:36,260
0,300 300,390 390,690 690,810 810,1140
code for this,| but when
|但是当 QEMU 加载内核时，

1446
00:46:36,620 --> 00:46:38,690
0,180 180,720 750,1260 1260,1380 1380,2070
{QEMU -} loads the kernel,|
|

1447
00:46:41,710 --> 00:46:45,010
0,870 1230,1980 2460,2880 2880,3060 3060,3300
{} well what's really going
实际上是这样的，

1448
00:46:45,010 --> 00:46:45,610
0,180 180,270 270,360 360,480 480,600
on is| {} when you
|当你编译的时候，

1449
00:46:45,610 --> 00:46:48,460
0,840 990,1980 2010,2550 2550,2760 2760,2850
compile,| the program call the
|程序调用链接器，计算基于，

1450
00:46:48,460 --> 00:46:49,820
0,750
linker

1451
00:46:49,820 --> 00:46:51,590
0,330 330,570 570,960 960,1320 1320,1770
figures out based on, {}|
|

1452
00:46:51,620 --> 00:46:52,580
0,420 420,540 540,600 600,690 690,960
look at all the global
查看所有全局变量及其大小，

1453
00:46:52,580 --> 00:46:54,650
0,510 510,600 600,720 720,1530 1650,2070
variables and their sizes| and
|并在内存中分配一个地址，

1454
00:46:54,650 --> 00:46:56,690
0,480 480,600 600,1200 1200,1320 1320,2040
assigns an address in memory,|
|

1455
00:46:57,340 --> 00:46:59,650
0,420 810,1020 1020,1350 1350,1620 1620,2310
yeah, to each global variable.|
是的，分配给每个全局变量。|

1456
00:47:01,570 --> 00:47:03,040
0,870

1457
00:47:04,340 --> 00:47:05,210
0,270 270,480 480,630 630,690 690,870
And that's where it lives
这就是它在内存中的地方。

1458
00:47:05,210 --> 00:47:08,060
0,90 90,870
in memory.|
|

1459
00:47:08,090 --> 00:47:09,440
0,510
{I,mean},
我是说，我们只是安排，

1460
00:47:10,310 --> 00:47:11,640
0,750
{}

1461
00:47:13,600 --> 00:47:16,060
0,870 990,1770
{} and,

1462
00:47:16,930 --> 00:47:18,730
0,180 180,390 390,1050 1050,1380 1380,1800
we just arrange that the

1463
00:47:18,760 --> 00:47:19,630
0,120 120,210 210,450 450,720 720,870
you know,| so {xv6 -
|所以 xv6 内核使用 10000 字节各种全局变量，

1464
00:47:19,630 --> 00:47:22,300
0,540 540,1020 1020,1650 1890,2130 2130,2670
-} kernel uses you know

1465
00:47:22,330 --> 00:47:24,460
0,570 570,1050 1050,1410 1440,1860 1860,2130
10,000 bytes of various global

1466
00:47:24,460 --> 00:47:25,940
0,1020
variables,|
|

1467
00:47:26,090 --> 00:47:28,010
0,210 210,660 660,1080 1140,1500 1500,1920
and wherever the boot process
并且在引导过程将其加载到存储器中的任何地方，

1468
00:47:28,010 --> 00:47:29,360
0,240 240,360 360,540 540,1140 1170,1350
loads it into memory,| say
|比如在地址一百万处，

1469
00:47:29,360 --> 00:47:31,460
0,240 360,720 720,780 780,1380 1770,2100
at address a million, {}|
|

1470
00:47:31,460 --> 00:47:32,520
0,120 120,570
it just
它就使用这些地址用于全局变量。

1471
00:47:34,550 --> 00:47:36,920
0,510 510,750 750,1680
uses those addresses

1472
00:47:38,000 --> 00:47:39,920
0,90 90,360 360,1110 1200,1590 1590,1920
{for,the} global variables.| I see,|
|我明白了，|

1473
00:47:39,920 --> 00:47:41,630
0,150 150,720 1020,1170 1170,1350 1350,1710
is this, is this similar
这是不是跟这个类似，

1474
00:47:41,630 --> 00:47:43,520
0,150 150,750 780,1080 1080,1290 1290,1890
to how,| like there's only
|就像在磁盘上只有一份程序的指令的副本，

1475
00:47:43,670 --> 00:47:45,320
0,450 450,930 930,1170 1260,1530 1530,1650
one copy of like the

1476
00:47:45,320 --> 00:47:47,450
0,1230 1290,1500 1500,1560 1560,1950 1950,2130
instructions for a program on

1477
00:47:47,450 --> 00:47:48,440
0,360 360,450 450,630 630,810 810,990
disk| and there's only like
|这个程序只有一份全局变量的副本。

1478
00:47:48,440 --> 00:47:50,060
0,300 300,720 720,1170
one copy of

1479
00:47:50,060 --> 00:47:51,470
0,30 30,210 210,270 270,570 570,1410
a kind of global variables

1480
00:47:51,530 --> 00:47:52,760
0,180 180,360 360,780 780,900 900,1230
for that program on this.|
|

1481
00:47:55,330 --> 00:47:57,100
0,510
Well,
好的，一个程序，

1482
00:47:58,630 --> 00:48:01,120
0,660 690,1110 1110,1500 1500,1920
a program this,| well,
|好的，我不知道该怎么回答，

1483
00:48:02,850 --> 00:48:04,050
0,540 540,780 780,960 960,1140 1140,1200
I'm not really sure how

1484
00:48:04,050 --> 00:48:05,310
0,420 420,690 690,960 960,1050 1050,1260
to answer this,| I mean
|我的意思是，当你声明一个全局变量时，比如 int x ，

1485
00:48:05,490 --> 00:48:07,900
0,540 900,1590
the the,

1486
00:48:09,100 --> 00:48:10,000
0,330 330,510 510,600 600,870 870,900
{} when you declare a

1487
00:48:10,000 --> 00:48:11,980
0,300 300,780 780,1020 1020,1140 1140,1980
global variable, like int x,|
|

1488
00:48:12,440 --> 00:48:13,880
0,180 180,270 270,900 900,1020 1020,1440
when you compile, the compiler
当你编译时，编译编译器和链接器决定

1489
00:48:13,880 --> 00:48:15,590
0,90 90,180 180,480 480,720 720,1710
and the linker just decide|
|

1490
00:48:15,650 --> 00:48:17,000
0,360 360,480 480,660 660,900 900,1350
based on who knows what
基于谁知道它是什么或者它是可配置的，

1491
00:48:17,000 --> 00:48:18,290
0,210 240,480 480,1080 1080,1200 1200,1290
or it's configurable,| but they
|但是它们决定了变量的地址，

1492
00:48:18,290 --> 00:48:19,910
0,600 780,990 990,1320 1320,1410 1410,1620
decide the address for that

1493
00:48:19,910 --> 00:48:21,950
0,690 900,1110 1110,1470 1470,1800 1800,2040
variable,| they decide alright boy
|它们决定 x 地址定为 1000 ，

1494
00:48:21,950 --> 00:48:22,970
0,240 240,360 360,480 480,630 630,1020
x is going to address

1495
00:48:22,970 --> 00:48:24,260
0,810
1000,|

1496
00:48:24,580 --> 00:48:25,660
0,180 180,420 420,510 510,930 930,1080
and then the code that
然后代码读取或写入 x ，

1497
00:48:25,660 --> 00:48:27,070
0,210 210,330 330,600 600,1320 1320,1410
reads or write x,| you
|如果我们有代码 refcount[0] 等于 1 ，

1498
00:48:27,070 --> 00:48:27,880
0,120 120,210 210,300 300,420 420,810
know if we have code

1499
00:48:27,880 --> 00:48:29,380
0,120 120,600 720,1170 1170,1410 1410,1500
that says {refcount -} of

1500
00:48:29,380 --> 00:48:31,400
0,420 420,840 840,1380
zero equals one,|
|

1501
00:48:31,990 --> 00:48:33,200
0,300 300,660
you know,
但是编译只是把内存设置在 1000 地址，

1502
00:48:33,200 --> 00:48:34,430
0,180 180,330 330,750 750,1080 1080,1230
but that compiled into was

1503
00:48:34,430 --> 00:48:36,260
0,360 360,810 810,900 900,1650 1650,1830
just setting the memory at

1504
00:48:36,260 --> 00:48:37,640
0,270 270,360 360,930 930,990 990,1380
address a thousand| or wherever
|或者链接器决定把 refcount 放在哪里，

1505
00:48:37,640 --> 00:48:39,230
0,210 570,960 960,1320 1320,1410 1410,1590
we linker decided to put

1506
00:48:39,230 --> 00:48:41,540
0,180 180,660 720,1260 1260,1590 1650,2310
{refcount -}| which is does
|进行存储，设置存储器地址 1001 。

1507
00:48:41,540 --> 00:48:42,980
0,60 60,480 480,600 600,960
a store to set

1508
00:48:43,160 --> 00:48:45,480
0,120 120,420 420,780 780,1740
the memory address 1001.|
|

1509
00:48:48,550 --> 00:48:49,860
0,420

1510
00:48:50,790 --> 00:48:51,880
0,660
Yeah,
是的，它不是，

1511
00:48:54,410 --> 00:48:55,820
0,450 450,900
it's not,|
|

1512
00:48:55,820 --> 00:48:57,500
0,390 390,900 900,1140 1140,1590 1590,1680
it's actually almost exactly the
它实际上是类似的事情，

1513
00:48:57,500 --> 00:48:58,550
0,210 210,510 510,630 630,930 930,1050
same thing| that happens when
|和你运行普通用户程序时发生的。

1514
00:48:58,550 --> 00:48:59,630
0,120 120,270 270,360 360,780 780,1080
you run an ordinary user

1515
00:48:59,630 --> 00:49:00,820
0,570
program.|
|

1516
00:49:01,230 --> 00:49:02,340
0,630

1517
00:49:02,980 --> 00:49:04,060
0,180 180,270 270,510 510,660 660,1080
{You,know} the linker and compiler
链接器和编译器决定内存全局变量的位置。

1518
00:49:04,060 --> 00:49:06,250
0,390 390,660 660,1410 1410,1710 1710,2190
decide where memory global variables

1519
00:49:06,250 --> 00:49:07,400
0,420
are.|
|

1520
00:49:07,400 --> 00:49:08,810
0,120 120,570 570,810 810,1050 1050,1410
They just being right there
它们就在那里，而且可以工作。

1521
00:49:08,810 --> 00:49:09,860
0,420
and,

1522
00:49:10,500 --> 00:49:12,040
0,180 180,270 270,450 450,960
and it just works.|
|

1523
00:49:13,050 --> 00:49:14,070
0,300 300,540 540,720 720,840 840,1020
I'm sorry, that's not much
我很抱歉，这不是一个很好的解释。

1524
00:49:14,070 --> 00:49:16,020
0,60 60,150 150,1410
of an explanation.|
|

1525
00:49:18,560 --> 00:49:20,990
0,750 900,1140 1140,1530 1770,2070 2070,2430
Alright, so just a define
好的，只需定义此全局计数数组，每个物理页一个，

1526
00:49:20,990 --> 00:49:22,550
0,480 510,870 870,1110 1110,1170 1170,1560
this global array of counts

1527
00:49:22,550 --> 00:49:25,160
0,480 480,660 660,1020 1020,1710 1890,2610
one per physical page {}|
|

1528
00:49:25,730 --> 00:49:26,920
0,630
and
我们需要在不同的地方修改这些计数，

1529
00:49:26,920 --> 00:49:28,000
0,120 120,420 420,570 570,630 630,1080
{} we need to modify

1530
00:49:28,000 --> 00:49:29,470
0,180 180,450 450,540 540,840 840,1470
these counts in various places,|
|

1531
00:49:29,530 --> 00:49:31,060
0,570 570,720 720,840 840,1140 1140,1530
certainly when we first allocate
当然，当我们第一次分配页面时，

1532
00:49:31,060 --> 00:49:33,130
0,60 60,840 870,1290 1680,1980 1980,2070
a page,| we're going to
|我们会说它有一个引用，

1533
00:49:33,130 --> 00:49:34,600
0,510 510,810 840,990 990,1140 1140,1470
say that it has one

1534
00:49:34,600 --> 00:49:35,890
0,630 630,810 810,930 930,1230 1230,1290
reference,| because we return the
|因为我们把页面地址给调用 kalloc 的程序，

1535
00:49:35,890 --> 00:49:36,790
0,330 330,390 390,450 450,810 810,900
address of the page to

1536
00:49:36,790 --> 00:49:38,890
0,960 960,1320 1320,1530 1530,1680 1680,2100
whoever called {kalloc - -}|
|

1537
00:49:39,130 --> 00:49:41,080
0,540 540,630 630,720 720,1230 1260,1950
and at the moment only
这时，只有该程序引用了这个页面，

1538
00:49:41,080 --> 00:49:42,820
0,540 780,1140 1140,1290 1290,1350 1350,1740
that program has a reference

1539
00:49:42,820 --> 00:49:43,600
0,60 60,240 240,570 570,690 690,780
to this page,| so I'm
|因此，我将此页面的引用计数设置为 1 。

1540
00:49:43,600 --> 00:49:44,600
0,210 210,540
just gonna

1541
00:49:44,740 --> 00:49:46,040
0,480
{}

1542
00:49:49,900 --> 00:49:52,330
0,870 900,1260 1260,1500 1500,2160 2220,2430
set the {refcount -} for

1543
00:49:52,330 --> 00:49:55,320
0,210 210,1170 1530,2400
this page {}

1544
00:49:55,800 --> 00:49:56,700
0,210 210,270 270,600 600,720 720,900
to be 1.| So first
|所以，首先我要计算一下页码，

1545
00:49:56,700 --> 00:49:57,630
0,90 90,540 570,660 660,810 810,930
of all I'm just going

1546
00:49:57,630 --> 00:49:58,800
0,60 60,480 480,540 540,870 870,1170
to calculate the page number,|
|

1547
00:49:58,800 --> 00:50:00,200
0,240 240,450 450,750
which is the
它是页面的地址除以 4096 ，即页码。

1548
00:50:00,530 --> 00:50:02,690
0,600 600,660 660,750 750,1620 1950,2160
address of the page {}

1549
00:50:02,690 --> 00:50:05,810
0,420 420,840 840,2370 2370,2700 2700,3120
divided by 4096, the page

1550
00:50:05,810 --> 00:50:06,800
0,450
number.|
|

1551
00:50:08,690 --> 00:50:10,640
0,840 1140,1350 1350,1470 1470,1620 1620,1950
{} And then I'm going
然后我将设置

1552
00:50:10,640 --> 00:50:12,980
0,780 810,1530 1620,1740 1740,2070 2070,2340
to set| the reference count
|刚分配的页面的引用计数为 1 。

1553
00:50:12,980 --> 00:50:14,030
0,390 390,480 480,750 750,840 840,1050
for the page we just

1554
00:50:14,030 --> 00:50:15,880
0,720 780,900 900,1230
allocated to 1.|
|

1555
00:50:21,920 --> 00:50:23,240
0,210 210,510 510,720 720,870 870,1320
Any questions about this code?|
有关于这些代码的问题吗？|

1556
00:50:27,570 --> 00:50:30,000
0,510 870,1290 1290,1500 1500,1590 1590,2430
{} Just because I know
因为我知道引用计数会有 bug ，

1557
00:50:30,420 --> 00:50:31,080
0,270 270,330 330,450 450,510 510,660
that I'm going to have

1558
00:50:31,080 --> 00:50:33,690
0,420 420,570 570,900 900,1410 2040,2610
bugs with reference counting,| I'm
|我在这里做了一些合理性检查，

1559
00:50:33,690 --> 00:50:34,500
0,270 270,360 360,420 420,660 660,810
actually do a little bit

1560
00:50:34,500 --> 00:50:36,120
0,120 120,390 390,870 870,1170 1170,1620
of a sanity check here|
|

1561
00:50:36,120 --> 00:50:37,220
0,600
and
只是，引用计数应该是 0 ，

1562
00:50:39,200 --> 00:50:40,540
0,390 390,840
{} just,

1563
00:50:41,860 --> 00:50:42,580
0,180 180,270 270,330 330,420 420,720
the you know the reference

1564
00:50:42,580 --> 00:50:43,540
0,180 180,330 330,480 480,570 570,960
count really should be zero,|
|

1565
00:50:43,540 --> 00:50:44,410
0,120 120,210 210,600 600,720 720,870
if the pages we just
如果我们刚刚分配的页面是释放的，

1566
00:50:44,410 --> 00:50:45,790
0,420 420,450 450,750 750,960 960,1380
allocated a page was free,|
|

1567
00:50:45,940 --> 00:50:46,930
0,480 480,600 600,780 780,930 930,990
boy it better have a
最好它的引用计数为 0 。

1568
00:50:46,930 --> 00:50:48,560
0,330 330,510 510,570 570,1080
reference count of zero.|
|

1569
00:50:54,140 --> 00:50:55,550
0,300 300,630 630,810 810,960 960,1410
Any questions about this code?|
对这个代码，有什么问题吗？|

1570
00:51:00,490 --> 00:51:01,570
0,240 240,390 390,540 540,960 960,1080
Alright, so in general we
好的，通常我们希望增加引用计数

1571
00:51:01,570 --> 00:51:03,160
0,270 270,660 720,1140 1140,1230 1230,1590
want to increment the reference

1572
00:51:03,160 --> 00:51:05,080
0,360 360,1320
count| when
|我们增加，

1573
00:51:05,140 --> 00:51:06,500
0,270 270,780
we add,|
|

1574
00:51:06,720 --> 00:51:08,430
0,240 240,540 540,690 690,1140 1170,1710
when {copy-on-write - -} fork
当写入时复制 fork 添加指向现有页的页表条目时，

1575
00:51:08,610 --> 00:51:09,990
0,480 480,660 660,930 930,1170 1170,1380
adds a page table entry

1576
00:51:09,990 --> 00:51:10,950
0,120 120,420 420,510 510,600 600,960
that points to an existing

1577
00:51:10,950 --> 00:51:12,840
0,630 1050,1440 1440,1590 1590,1710 1710,1890
page| {} and we want
|我们想要，

1578
00:51:12,840 --> 00:51:13,820
0,270
to,|
|

1579
00:51:13,820 --> 00:51:15,440
0,330 330,570 570,720 720,780 780,1620
actually, we want to decrement
实际上，我们想要减少引用计数，

1580
00:51:15,740 --> 00:51:17,760
0,240 240,690 690,1290
the reference count,|
|

1581
00:51:17,760 --> 00:51:18,390
0,120 120,210 210,420 420,540 540,630
as it turns out in
事实证明，在很多地方，

1582
00:51:18,390 --> 00:51:20,220
0,300 300,1050 1200,1410 1410,1710 1710,1830
many places,| for example when
|例如，当进程退出时，

1583
00:51:20,220 --> 00:51:22,020
0,60 60,480 480,1350 1530,1650 1650,1800
a process exits,| we need
|我们需要递减其所有页的引用计数，

1584
00:51:22,020 --> 00:51:23,070
0,90 90,450 450,540 540,870 870,1050
to decrement the reference count

1585
00:51:23,070 --> 00:51:24,540
0,90 90,270 270,390 390,1020 1020,1470
of all its pages,| when
|当你调用 exec 时，

1586
00:51:24,540 --> 00:51:26,220
0,120 120,330 330,1140
you call exec,|
|

1587
00:51:26,620 --> 00:51:28,210
0,270 270,390 390,690 930,1470 1470,1590
{} and that frees all
它释放所有当前内存，

1588
00:51:28,210 --> 00:51:29,140
0,60 60,360 360,630 630,810 810,930
the current memory,| because it's
|因为它会取代它，

1589
00:51:29,140 --> 00:51:29,950
0,120 120,180 180,570 570,690 690,810
going to replace it,| we
|我们想要减少所有的引用计数，

1590
00:51:29,950 --> 00:51:30,940
0,150 150,210 210,660 660,750 750,990
want to decrement all those

1591
00:51:30,940 --> 00:51:32,500
0,300 300,540 540,690 690,930 1110,1560
reference counts,| when a {copy-on-write
|当发生写入时复制页面错误时，

1592
00:51:32,500 --> 00:51:33,760
0,90 90,300 300,600 600,810 810,1260
- -} page fault happens|
|

1593
00:51:33,760 --> 00:51:35,110
0,120 120,480 510,720 720,780 780,1350
and we make a copy,|
然后我们复制了一份，|

1594
00:51:35,350 --> 00:51:36,940
0,570 750,1020 1020,1110 1110,1530 1530,1590
we want to decrement {}
我们想要减少旧页面上的引用计数，

1595
00:51:36,940 --> 00:51:37,810
0,330 330,540 540,600 600,690 690,870
reference count on the old

1596
00:51:37,810 --> 00:51:39,100
0,450 600,810 810,1020 1020,1110 1110,1290
page,| it turns out these
|这些位置都是可以同时释放页面的，

1597
00:51:39,100 --> 00:51:40,450
0,90 90,210 210,300 300,630 630,1350
are all the same places

1598
00:51:40,480 --> 00:51:42,940
0,240 240,990 1020,1710 1710,1800 1800,2460
that concurrently free a page,|
|

1599
00:51:42,940 --> 00:51:44,440
0,240 240,330 330,660 660,930 930,1500
because the current {xv6 -},|
因为当前的 xv6 ，|

1600
00:51:44,800 --> 00:51:45,850
0,300 300,450 450,660 660,810 810,1050
think there's only ever one
考虑每个页面只有一个引用，

1601
00:51:45,850 --> 00:51:48,070
0,420 420,510 510,720 720,1380 1920,2220
reference to each page, {}|
|

1602
00:51:48,070 --> 00:51:48,610
0,180 180,240 240,420 420,480 480,540
so in most of the
所以在大多数我们想要减少的地方，

1603
00:51:48,610 --> 00:51:49,690
0,270 270,390 390,660 660,930 930,1080
places we care about where

1604
00:51:49,690 --> 00:51:50,680
0,120 120,270 270,330 330,810 810,990
we want to decrement,| there's
|并发调用 kfree ，

1605
00:51:50,680 --> 00:51:52,060
0,420 420,480 480,660 660,1020 1020,1380
concurrently a call {kfree -},|
|

1606
00:51:52,300 --> 00:51:53,440
0,240 240,480 480,540 540,720 720,1140
so what I'm gonna do
所以我要做的是

1607
00:51:53,440 --> 00:51:55,600
0,360 420,1380 1380,1710 1710,2040 2040,2160
is| modify {kfree -} to
|修改 kfree 使其具有稍微不同的语义，

1608
00:51:55,600 --> 00:51:57,610
0,300 510,750 750,1080 1080,1320 1320,2010
be have somewhat different semantics|
|

1609
00:51:57,610 --> 00:51:59,920
0,150 150,330 630,900 900,1200 1200,2310
and to have kfree be,|
使 kfree 成为，|

1610
00:52:00,250 --> 00:52:02,440
0,810 990,1350 1350,1500 1590,1800 1800,2190
{} sort of a function
某种可以减少引用计数的函数，

1611
00:52:02,440 --> 00:52:03,790
0,210 210,750 750,870 870,960 960,1350
that {decrements -} the reference

1612
00:52:03,790 --> 00:52:05,740
0,390 510,810 810,1410 1410,1500 1500,1950
count| and free the page
|并且仅当引用计数降至零时才释放页面。

1613
00:52:05,740 --> 00:52:06,910
0,360 360,510 510,600 600,900 900,1170
only if the reference count

1614
00:52:06,910 --> 00:52:08,240
0,90 90,420 420,480 480,930
has dropped to zero.|
|

1615
00:52:08,890 --> 00:52:10,360
0,180 180,300 300,450 450,600 600,1470
I mean, I'll just automatically
我的意思是，我会修复所有调用 kfree 的地方。

1616
00:52:10,360 --> 00:52:11,380
0,330 330,480 480,570 570,900 900,1020
fix all the places that

1617
00:52:11,380 --> 00:52:12,800
0,240 240,480 480,930
call {kfree -}.|
|

1618
00:52:13,340 --> 00:52:14,800
0,870

1619
00:52:15,400 --> 00:52:16,800
0,60

1620
00:52:16,830 --> 00:52:18,260
0,450 450,840
Alright so,
好的，我们需要检查，

1621
00:52:18,410 --> 00:52:19,220
0,210 210,300 300,450 450,540 540,810
{} we need to actually

1622
00:52:19,220 --> 00:52:20,720
0,120 120,240 240,930
do the check,|
|

1623
00:52:21,770 --> 00:52:23,630
0,1050 1080,1260 1260,1500 1500,1560 1560,1860
before we fill the page
在我们用垃圾数据填满页面之前。

1624
00:52:23,630 --> 00:52:25,080
0,180 180,840
with junk.|
|

1625
00:52:25,300 --> 00:52:27,040
0,480 570,780 780,960 960,1200 1200,1740
{} So, this makes a
所以，这让事情变得有点复杂，

1626
00:52:27,040 --> 00:52:28,570
0,180 180,270 270,390 390,1050 1050,1530
little bit more complicated,| because
|因为即使在 kfree 中已经有一个锁的临界区，

1627
00:52:28,840 --> 00:52:29,860
0,330 330,420 420,600 600,660 660,1020
even though there's a critical

1628
00:52:29,860 --> 00:52:31,060
0,360 360,480 480,900 900,990 990,1200
section with locks in {kfree

1629
00:52:31,060 --> 00:52:32,650
0,180 180,780 900,1140 1140,1380 1380,1590
-} already,| we can't use
|我们也不能使用它，

1630
00:52:32,650 --> 00:52:33,910
0,150 150,360 360,450 450,870 870,1260
it,| because it happens after
|因为它发生在我们将页面填满垃圾数据之后。

1631
00:52:33,910 --> 00:52:34,540
0,90 90,300 300,360 360,510 510,630
the point at which we

1632
00:52:34,540 --> 00:52:35,830
0,240 240,300 300,540 540,660 660,1290
filled the page with garbage.|
|

1633
00:52:37,680 --> 00:52:39,060
0,750
So,
所以，我们需要一个锁，

1634
00:52:39,750 --> 00:52:41,130
0,480 540,690 690,810 810,900 900,1380
{} we need a lock,|
|

1635
00:52:41,130 --> 00:52:42,460
0,810
because
因为我们可能释放同一页面，

1636
00:52:42,760 --> 00:52:43,540
0,120 120,300 300,450 450,720 720,780
we could be free| in
|在同一时间从多个不同的内核，

1637
00:52:43,540 --> 00:52:44,470
0,60 60,330 330,750 750,840 840,930
the same page at the

1638
00:52:44,470 --> 00:52:46,060
0,270 270,630 630,930 960,1350 1350,1590
same time from multiple different

1639
00:52:46,060 --> 00:52:49,100
0,750 1200,1710 1710,1860 1860,2490
cores,| again I'm gonna
|同样，我要找到页码，

1640
00:52:50,090 --> 00:52:52,160
0,360 360,690 720,1260 1260,1920 1920,2070
find the page number| by
|通过将物理地址除以 4096 。

1641
00:52:52,160 --> 00:52:53,660
0,510 510,840
dividing the

1642
00:52:54,180 --> 00:52:57,600
0,420 420,990 990,1380 1380,2850
physical address by 4096.|
|

1643
00:52:58,160 --> 00:53:00,920
0,810 1230,1440 1440,1530 1530,2160
I want to panic,
我想再一次 panic ，只是一次合理性检查，

1644
00:53:01,550 --> 00:53:03,800
0,630 660,990 990,1050 1050,1620 1620,2250
again, just a sanity check,|
|

1645
00:53:04,620 --> 00:53:05,610
0,420 420,540 540,690 690,840 840,990
gosh, you know if we're
如果我们要释放一页的话，

1646
00:53:05,610 --> 00:53:06,690
0,270 270,330 330,720 720,840 840,1080
freeing a page,| that better
|最好有超过零的引用计数。

1647
00:53:06,690 --> 00:53:07,980
0,300 300,630 630,750 750,1080 1080,1290
have more than zero {refcounts

1648
00:53:07,980 --> 00:53:09,240
0,720
-}.|
|

1649
00:53:15,210 --> 00:53:16,560
0,210 210,360 360,450 450,1110 1110,1350
We need to return if
如果页面有多个引用计数，我们需要返回。

1650
00:53:16,560 --> 00:53:18,300
0,390 780,1320 1320,1440 1440,1620 1620,1740
the page has more than

1651
00:53:18,300 --> 00:53:19,830
0,210 210,870 870,1140 1140,1320 1320,1530
one reference count to it.|
|

1652
00:53:20,820 --> 00:53:23,240
0,480 480,990 990,1350 1350,1830
{} Actually, let's {}
实际上，让我们减少引用计数，

1653
00:53:24,400 --> 00:53:26,140
0,390 390,480 480,780 780,1170
decrement the reference count,|
|

1654
00:53:26,470 --> 00:53:28,390
0,600 720,1050 1050,1170 1170,1230 1230,1920
{} we want to return
我们想在解锁后返回，

1655
00:53:28,390 --> 00:53:29,650
0,330 330,480 480,810 810,1170 1170,1260
after we release locks| and
|我们必须记住一个变量，

1656
00:53:29,650 --> 00:53:30,430
0,150 150,240 240,330 330,750 750,780
we have to remember a

1657
00:53:30,430 --> 00:53:32,620
0,570 570,690 690,1020 1350,1950 1950,2190
variable,| I'm gonna remember whether
|我将记住该页面是否有更多引用，

1658
00:53:32,620 --> 00:53:33,670
0,90 90,270 270,390 390,540 540,1050
the page has more references|
|

1659
00:53:33,670 --> 00:53:34,720
0,120 120,330 330,660 660,960 960,1050
and then release locks and
然后释放锁，然后返回，

1660
00:53:34,720 --> 00:53:36,430
0,150 150,630 900,1140 1140,1200 1200,1710
then return,| so I'm gonna
|所以我将创建一个临时变量，

1661
00:53:36,580 --> 00:53:38,320
0,300 300,360 360,810 810,1260 1260,1740
make a temporary variable| which
|该变量包含，然后释放，

1662
00:53:38,350 --> 00:53:40,500
0,270 270,600 1020,1680
has the {}

1663
00:53:43,200 --> 00:53:44,900
0,210 210,930
and release,|
|

1664
00:53:46,640 --> 00:53:48,950
0,450 450,780 780,1620 1620,2070 2100,2310
then say if {} there's
如果还有引用这个页面的话，

1665
00:53:48,950 --> 00:53:50,360
0,420 420,840 840,1050 1050,1290 1290,1410
still references this page,| let's
|我们就返回，不要释放它。

1666
00:53:50,360 --> 00:53:51,740
0,180 180,660 660,810 810,1140 1140,1380
just return and not free

1667
00:53:51,740 --> 00:53:52,600
0,330
it.|
|

1668
00:53:52,750 --> 00:53:54,340
0,390 390,630 630,900 900,1200 1230,1590
And only if the reference
只有当引用计数降到零时，我们才释放它。

1669
00:53:54,340 --> 00:53:55,540
0,180 180,360 360,870 870,990 990,1200
count drop {to,zero}, we free

1670
00:53:55,540 --> 00:53:56,280
0,150
it.|
|

1671
00:53:57,360 --> 00:53:59,310
0,210 210,870 1260,1470 1470,1530 1530,1950
Any questions?| Can you explain
有什么问题吗？|你能不能再解释一下，

1672
00:53:59,310 --> 00:54:00,360
0,330 330,690 690,810 810,930 930,1050
again,| why you have to
|为什么要在这个过程中取得 kmem->lock ？

1673
00:54:00,360 --> 00:54:03,480
0,570 570,750 750,1230 1230,1710 2460,3120
acquire the kmem lock {this,process}?|

1674
00:54:04,220 --> 00:54:06,230
0,300 300,450 450,900 1350,1860 1860,2010
Why have to acquire it
为什么整段都要获取它？

1675
00:54:06,230 --> 00:54:08,450
0,420 930,1650 1650,1890 1890,2010 2010,2220
all?| Yeah when you're doing
|是的，当你在做页码计算的时候。

1676
00:54:08,450 --> 00:54:10,280
0,120 150,420 420,630 630,1440 1470,1830
the page number calculations and.|
|

1677
00:54:10,730 --> 00:54:13,520
0,270 270,1050 1050,1800
It's this line,|
是这一行，|

1678
00:54:14,350 --> 00:54:16,780
0,870 1290,1740 1740,1890 1890,2070 2070,2430
{} really is this line,
这一行和下一行是问题的关键，

1679
00:54:16,780 --> 00:54:17,590
0,90 90,330 330,540 540,720 720,810
the next line of the

1680
00:54:17,590 --> 00:54:18,820
0,420 420,510 510,870 870,990 990,1230
problem,| the issue is that
|问题是，在这个页面上，

1681
00:54:19,030 --> 00:54:21,640
0,450 810,1230 1230,2100 2190,2340 2340,2610
on this page,| we now
|我们现在可能有多个对它的引用，

1682
00:54:21,640 --> 00:54:22,960
0,540 570,930 930,1080 1080,1230 1230,1320
is likely has more than

1683
00:54:22,960 --> 00:54:24,070
0,150 150,570 570,750 750,870 930,1110
one reference to it| and
|如果两个进程有相同的引用，

1684
00:54:24,070 --> 00:54:25,480
0,180 180,330 330,540 540,1290 1290,1410
so if two processes with

1685
00:54:25,480 --> 00:54:26,530
0,60 60,420 420,510 510,630 630,1050
a reference to the same|
|

1686
00:54:26,680 --> 00:54:27,910
0,150 150,270 420,720 720,960 960,1230
with the page table entry
有指向相同页面的页表条目，

1687
00:54:27,910 --> 00:54:28,960
0,240 240,360 360,420 420,630 630,1050
point at the same page,|
|

1688
00:54:29,200 --> 00:54:30,280
0,210 210,300 300,510 510,990 990,1080
if they both exit at
如果它们同时在不同的核心上退出，

1689
00:54:30,280 --> 00:54:31,300
0,120 120,360 360,660 660,750 750,1020
the same time on different

1690
00:54:31,300 --> 00:54:33,040
0,750 960,1170 1170,1350 1350,1500 1500,1740
cores,| they're both gonna call
|它们会同时对相同的页面调用 kfree 。

1691
00:54:33,040 --> 00:54:34,420
0,300 300,780 810,930 930,1020 1020,1380
{kfree -} for the same

1692
00:54:34,420 --> 00:54:35,890
0,420 420,540 540,630 630,900 900,1470
page at the same time.|
|

1693
00:54:38,740 --> 00:54:40,690
0,510 510,660 660,990 990,1470 1470,1950
Could you just create a
你可以为引用计数变量创建一个新的锁，

1694
00:54:40,690 --> 00:54:42,310
0,240 240,630 630,930 930,1260 1260,1620
new lock for the reference

1695
00:54:42,310 --> 00:54:44,170
0,270 270,870 870,1230 1350,1620 1620,1860
count variable| and use that
|然后使用它吗？

1696
00:54:44,170 --> 00:54:45,900
0,90 90,360
as well?|
|

1697
00:54:48,610 --> 00:54:49,700
0,540
Yes.|
是的。|

1698
00:54:51,340 --> 00:54:52,510
0,210 210,540 540,990 990,1080 1080,1170
Yeah, basically everybody,| you know
是的，基本上，|所有操纵这些计数的代码

1699
00:54:52,510 --> 00:54:54,040
0,210 210,630 630,810 810,1380 1380,1530
all code that manipulates these

1700
00:54:54,040 --> 00:54:54,850
0,330 330,480 480,600 600,720 720,810
counts| need to use the
|都需要使用相同的锁，

1701
00:54:54,850 --> 00:54:57,040
0,180 180,570 570,780 1290,1500 1920,2190
same lock,| but I don't
|但我觉得锁是什么并不重要。

1702
00:54:57,040 --> 00:54:57,940
0,150 150,240 240,510 510,660 660,900
think it matters what lock

1703
00:54:57,940 --> 00:54:58,960
0,510
is.|
|

1704
00:55:00,980 --> 00:55:02,090
0,360 360,570 570,750 750,990 990,1110
Okay, so this takes care
好的，这就解决了大部分我们关心的减少的问题，

1705
00:55:02,090 --> 00:55:03,200
0,120 120,540 540,840 840,900 900,1110
of decre-, most of the

1706
00:55:03,350 --> 00:55:04,730
0,630 630,750 750,930 930,1260 1260,1380
decrement we care about,| every
|每一次释放页面，

1707
00:55:04,730 --> 00:55:05,630
0,210 210,270 270,510 510,630 630,900
time the page is free,|
|

1708
00:55:05,630 --> 00:55:06,830
0,150 150,360 360,720 840,960 960,1200
we're really gonna you know
我们只有在引用计数为零的情况下才释放。

1709
00:55:06,830 --> 00:55:07,910
0,270 270,480 480,660 660,750 750,1080
only free if the reference

1710
00:55:07,910 --> 00:55:09,500
0,300 300,600 600,990 1110,1380 1380,1590
counts {fails,to} zero.| We also
|我们也需要增加引用计数，

1711
00:55:09,500 --> 00:55:11,780
0,270 270,600 600,1170 1560,2220 2220,2280
need to {} increment the

1712
00:55:11,780 --> 00:55:13,580
0,360 360,900 1200,1470 1470,1740 1740,1800
reference count,| {} where do
|我们需要在哪里增加引用计数。

1713
00:55:13,580 --> 00:55:14,330
0,90 90,270 270,330 330,660 660,750
we need to increment the

1714
00:55:14,330 --> 00:55:15,360
0,300 300,570
reference count.|
|

1715
00:55:22,240 --> 00:55:23,290
0,480 540,780 780,840 840,990 990,1050
Well, because I know we're
好的，因为我知道我们需要做好这件事，

1716
00:55:23,290 --> 00:55:23,890
0,120 120,180 180,390 390,450 450,600
going to need to do

1717
00:55:23,890 --> 00:55:25,840
0,240 840,1200 1200,1290 1290,1770 1770,1950
it right,| the function that
|任何人都可以调用的函数。

1718
00:55:26,740 --> 00:55:29,960
0,540 540,630 630,1200 1650,2580
anybody can call. {}|
|

1719
00:55:39,830 --> 00:55:41,220
0,810

1720
00:55:41,460 --> 00:55:42,720
0,540 540,600 600,750 750,810 810,1260
Again I want to panic
再一次，如果有什么不正常，我想引起 panic ，

1721
00:55:42,720 --> 00:55:43,740
0,120 120,390 390,540 540,900 900,1020
if something is weird,| so
|所以如果地址很奇怪，

1722
00:55:43,740 --> 00:55:45,820
0,150 150,600 600,720 720,1500
{if,the} address is wacky,|
|

1723
00:55:45,930 --> 00:55:47,220
0,270 270,570 570,690 690,840 840,1290
I'm certainly don't want to
我当然不想超出数组的末尾。

1724
00:55:48,140 --> 00:55:49,910
0,270 300,900 1170,1440 1440,1680 1680,1770
{ -} go beyond the

1725
00:55:49,910 --> 00:55:51,340
0,150 150,210 210,330 330,840
end of the array.|
|

1726
00:55:52,820 --> 00:55:54,110
0,810 840,1020 1020,1080 1080,1170 1170,1290
Or if we don't want
或者如果我们不想增加页面的引用计数，

1727
00:55:54,110 --> 00:55:55,460
0,60 60,390 390,780 810,1170 1170,1350
to increment the reference count

1728
00:55:55,460 --> 00:55:56,750
0,60 60,150 150,750 750,1050 1050,1290
of {} page,| reference counts
|引用计数为零，

1729
00:55:56,750 --> 00:55:58,300
0,330 330,1020
currently zero,|
|

1730
00:55:58,470 --> 00:56:00,270
0,570 810,1020 1020,1290 1290,1410 1410,1800
{} that's also an error,|
这也是一个错误，|

1731
00:56:04,440 --> 00:56:05,370
0,210 210,390 390,630 630,840 840,930
I'm just putting these in
我只是把这些放在这里，

1732
00:56:05,370 --> 00:56:06,240
0,120 120,330 330,390 390,720 720,870
there,| because I know from
|因为从我的代码经验中知道，

1733
00:56:06,240 --> 00:56:08,100
0,750 750,840 840,1020 1020,1500 1500,1860
experience with my code| that
|正是那种地方，我会有 bug 。

1734
00:56:08,220 --> 00:56:09,390
0,270 270,360 360,870 870,960 960,1170
this is exactly the kind

1735
00:56:09,390 --> 00:56:09,990
0,60 60,360 360,420 420,540 540,600
of place, I'm going to

1736
00:56:09,990 --> 00:56:11,260
0,180 180,240 240,510 510,750
have a bug in.|
|

1737
00:56:25,610 --> 00:56:26,660
0,210 210,540 660,870 870,990 990,1050
All right, where should I
好的，我应该从哪里调用增加。

1738
00:56:26,660 --> 00:56:28,280
0,240 240,570 570,1050
call increment from.|
|

1739
00:56:30,860 --> 00:56:32,900
0,570 570,1080 1080,1410 1410,1830 1830,2040
{You,have} {uvmcopy - -} when
你有 uvmcopy ，当你。

1740
00:56:32,900 --> 00:56:34,280
0,210
you.|
|

1741
00:56:35,060 --> 00:56:36,260
0,210 210,360 360,510 510,810 810,1200
I think {uvmcopy - -}
我认为 uvmcopy 是唯一另一个引用页面的地方。

1742
00:56:36,260 --> 00:56:37,280
0,60 60,120 120,330 330,780 780,1020
is the only place that

1743
00:56:37,280 --> 00:56:38,280
0,390
{}

1744
00:56:38,400 --> 00:56:40,200
0,240 240,960 960,1590 1590,1740 1740,1800
makes another reference to a

1745
00:56:40,200 --> 00:56:41,440
0,750
page.|
|

1746
00:56:46,600 --> 00:56:48,400
0,870 900,1320 1320,1380 1380,1560 1560,1800
Alright gosh, I'm going with
好的，我这么做了，

1747
00:56:48,400 --> 00:56:49,480
0,270 270,600 600,660 660,900 900,1080
this well,| it almost doesn't
|这几乎无关紧要。

1748
00:56:49,480 --> 00:56:51,900
0,270 900,1530
really matter.|
|

1749
00:56:52,400 --> 00:56:54,140
0,300 300,600 600,1140 1140,1650 1650,1740
We're making another reference to
我们创造了另一个对 pa 的引用，

1750
00:56:54,140 --> 00:56:55,430
0,390 390,870 900,1110 1110,1170 1170,1290
{pa -},| so I want
|所以我想使用 incref(pa) 。

1751
00:56:55,430 --> 00:56:57,260
0,60 60,180 180,390 390,1230
to say {incref(pa) -

1752
00:56:57,520 --> 00:56:58,960
0,300 300,1050
- -}.|
|

1753
00:57:00,310 --> 00:57:01,700
0,750

1754
00:57:01,850 --> 00:57:03,100
0,600
Or,
很可能会遇到来自编译器的问题，

1755
00:57:03,300 --> 00:57:05,340
0,750 750,1020 1320,1590 1590,1770 1770,2040
likely to run into trouble

1756
00:57:05,340 --> 00:57:06,360
0,120 120,210 210,810 810,960 960,1020
from the compiler,| if we
|如果我们不把它的定义放在 traps.h 中。

1757
00:57:06,360 --> 00:57:07,650
0,210 210,390 390,510 510,1020 1020,1290
don't put a definition for

1758
00:57:07,650 --> 00:57:08,780
0,120 120,480
it in

1759
00:57:09,210 --> 00:57:11,850
0,420 420,600 600,1590 1800,2100 2100,2640
{traps.h - -} {} whatever.|
|

1760
00:57:12,580 --> 00:57:13,740
0,630
Okay,|
好的,|

1761
00:57:18,450 --> 00:57:20,300
0,1080
{let's,see}.|
让我们看看。|

1762
00:57:39,230 --> 00:57:41,060
0,270 270,420 420,600 600,1260
That was pretty quick,|
那太快了，|

1763
00:57:41,950 --> 00:57:44,230
0,1260 1380,1650 1650,1830 1830,2040 2040,2280
{} that was {kfree -}
那是 kfree ref ，

1764
00:57:44,230 --> 00:57:47,260
0,570 1740,2100 2100,2310 2310,2520 2520,3030
ref,| {kfree -} is unhappy.|
|kfree 不高兴。|

1765
00:57:47,930 --> 00:57:49,380
0,690

1766
00:57:50,380 --> 00:57:51,940
0,330 330,570 570,990 990,1080 1080,1560
Okay, well here's the time
好的，这是在引导过程的早期，

1767
00:57:51,940 --> 00:57:53,020
0,120 120,330 330,600 600,810 810,1080
we don't know, is very

1768
00:57:53,020 --> 00:57:54,010
0,180 180,270 270,330 330,510 510,990
early in the boot process|
|

1769
00:57:54,010 --> 00:57:55,120
0,240 240,390 390,660 660,720 720,1110
which is maybe a hint
也许是出了什么问题的一个线索。

1770
00:57:55,120 --> 00:57:56,680
0,360 450,600 600,810 810,1050 1050,1560
it to what's going wrong.|
|

1771
00:57:57,310 --> 00:57:59,290
0,630 690,900 900,1260 1260,1440 1440,1980
{} If anybody has any
如果有人有任何猜测，我很乐意听听，

1772
00:58:01,210 --> 00:58:02,200
0,390 420,660 660,810 810,900 900,990
{} {guesses -}, I'd be

1773
00:58:02,200 --> 00:58:03,340
0,270 270,330 330,480 480,600 600,1140
happy to hear them,| meanwhile
|同时，启动调试器，尝试获取回溯信息。

1774
00:58:03,340 --> 00:58:04,330
0,210 210,450 450,540 540,630 630,990
just fire up the debugger

1775
00:58:04,330 --> 00:58:05,110
0,120 120,300 300,360 360,540 540,780
{} try to get {backtrace

1776
00:58:05,110 --> 00:58:06,360
0,720
-}.|
|

1777
00:58:06,660 --> 00:58:08,250
0,270 270,540 540,930 930,1380 1380,1590
It is during {kinit -},|
这是在 kinit 中，|

1778
00:58:08,250 --> 00:58:10,530
0,510 510,1080 1140,1620 1620,1860 1860,2280
because you're trying to put
因为你正在尝试将内容放入链表，

1779
00:58:10,530 --> 00:58:13,020
0,390 390,960 1050,1710 1740,2130 2130,2490
things into the linked list|
|

1780
00:58:13,020 --> 00:58:15,030
0,300 390,570 570,900 900,1500 1500,2010
and you haven't allocated yet.|
但是链表尚未分配。|

1781
00:58:16,360 --> 00:58:19,060
0,540 840,1260 1410,1860 1860,2280 2340,2700
So you {} in when
所以，当你尝试将所有内容加载到链表中时，

1782
00:58:19,060 --> 00:58:21,670
0,450 540,960 960,1440 1470,2130 2130,2610
you trying to load everything

1783
00:58:21,670 --> 00:58:23,320
0,210 210,240 240,660 660,1110 1470,1650
into a linked list,| you
|在那之前你没有调用 kalloc 。

1784
00:58:23,320 --> 00:58:25,750
0,600 630,1200 1200,1710 1710,2040 2040,2430
haven't called {kalloc -} before

1785
00:58:25,750 --> 00:58:27,790
0,420 750,1050 1050,1200 1200,1560 1560,2040
that.| Yeah that's exactly right,|
|是的，完全正确，|

1786
00:58:28,090 --> 00:58:29,680
0,420 420,870
{} so,
所以，请看这里的操作，

1787
00:58:29,820 --> 00:58:31,410
0,420 420,630 630,750 750,1140 1140,1590
see that in action here,|
|

1788
00:58:31,440 --> 00:58:32,940
0,180 180,300 300,540 540,990 1020,1500
okay I got the panic,|
好的，我得到 panic ，|

1789
00:58:32,940 --> 00:58:35,100
0,330 330,750 1230,1620 1620,1890 1890,2160
type where and it's in,|
输入 where ，它在，|

1790
00:58:35,100 --> 00:58:36,260
0,570

1791
00:58:36,290 --> 00:58:37,520
0,330 330,600 600,810 810,960 960,1230
here's {kfree -} being called
这里是 kfree 被调用，并引起 panic ，

1792
00:58:37,520 --> 00:58:38,360
0,90 90,510 510,600 600,720 720,840
and paniced| and it's being
|它一开始就是从 freerange 调用的，

1793
00:58:38,360 --> 00:58:39,470
0,240 240,360 360,630 630,960 960,1110
called from {freerange -} right

1794
00:58:39,470 --> 00:58:40,400
0,60 60,120 120,540 540,750 750,930
at the beginning,| when we're
|当我们在初始化空闲列表时，

1795
00:58:40,400 --> 00:58:42,650
0,840 1350,1620 1620,1740 1740,1920 1920,2250
initializing {} the free list

1796
00:58:42,650 --> 00:58:44,810
0,390 750,1140 1140,1410 1410,1740 1740,2160
indeed,| {} so there's something
|所以在 freerange 有一些需要修复的东西，

1797
00:58:44,810 --> 00:58:46,520
0,60 60,180 180,690 690,1170 1320,1710
to be fixed in {freerange

1798
00:58:46,520 --> 00:58:48,920
0,780 810,1290 1740,2100 2100,2340 2340,2400
-},| {} the problem is
|问题是我调用 kfree ，

1799
00:58:48,920 --> 00:58:50,480
0,90 90,360 720,990 990,1200 1200,1560
I'm calling {kfree -},| as,
|如你所说，我调用 kfree ，

1800
00:58:50,480 --> 00:58:51,260
0,180 180,270 270,450 450,540 540,780
as you said I'm calling

1801
00:58:51,260 --> 00:58:51,980
0,180 180,360 360,480 480,540 540,720
{kfree -},| but of course,
|但是当然，所有的引用计数都是零，

1802
00:58:51,980 --> 00:58:52,880
0,210 210,270 270,570 570,840 840,900
all the reference counts are

1803
00:58:52,880 --> 00:58:54,260
0,420 420,510 510,690 690,840 840,1380
zero| and {kfree -} panics
|当参考计数为 0 时， kfree 会出现 panic ，

1804
00:58:54,260 --> 00:58:55,010
0,90 90,180 180,480 480,690 690,750
at the reference count of

1805
00:58:55,010 --> 00:58:57,020
0,480 810,1200 1200,1350 1350,1470 1470,2010
zero,| {} so I'll just,
|所以我把这个改为。

1806
00:58:59,300 --> 00:59:02,780
0,540 540,1710 2610,3030 3030,3360 3360,3480
I'll just hack this to

1807
00:59:02,780 --> 00:59:04,080
0,720
be.|
|

1808
00:59:05,140 --> 00:59:06,400
0,600

1809
00:59:09,100 --> 00:59:10,740
0,960 960,1020

1810
00:59:11,100 --> 00:59:13,160
0,120 120,270 270,510
How about that.|
这个怎么样。|

1811
00:59:20,300 --> 00:59:21,470
0,240 240,660 690,780 780,1110 1110,1170
Oh okay, we managed to
好的，我们现在可以启动了，

1812
00:59:21,470 --> 00:59:23,860
0,210 210,630 960,1710
boot now, {}|

1813
00:59:24,380 --> 00:59:26,030
0,180 180,540 540,840 840,1200 1200,1650
by wonderful done,| let's see.|
干得不错，|让我们看看。|

1814
00:59:27,230 --> 00:59:28,600
0,570

1815
00:59:30,160 --> 00:59:31,300
0,330 330,510 510,840 840,1080 1080,1140
Okay, so let's run the
好的，让我们再运行一次 cowtest 。

1816
00:59:31,300 --> 00:59:33,080
0,210 210,510 510,1230
{cowtest -} again.|
|

1817
00:59:34,290 --> 00:59:36,150
0,630 1050,1320 1320,1530 1530,1620 1620,1860
Um, we pass this simple
嗯，我们通过了这个 simple 测试，

1818
00:59:36,150 --> 00:59:38,070
0,270 270,810 900,1110 1110,1260 1260,1920
test,| aha, so we passed
|我们通过了 simple 测试，这很棒。

1819
00:59:38,220 --> 00:59:39,180
0,120 120,390 390,750 750,870 870,960
the simple test, which is

1820
00:59:39,180 --> 00:59:41,240
0,420
great.|
|

1821
00:59:41,490 --> 00:59:44,070
0,180 180,270 270,600 600,1680 2220,2580
And we passed one time
我们通过了一次 three 测试，

1822
00:59:44,070 --> 00:59:46,050
0,210 210,300 300,600 600,1380 1440,1980
through the three test,| but
|但是我们没有通过，

1823
00:59:46,080 --> 00:59:48,040
0,90 90,510 510,1470
we didn't pass,|
|

1824
00:59:48,190 --> 00:59:48,760
0,120 120,210 210,390 390,450 450,570
we didn't make it through
我们没有通过第二次 three 测试，

1825
00:59:48,760 --> 00:59:49,900
0,60 60,570 570,840 840,960 960,1140
the second time to the

1826
00:59:49,960 --> 00:59:52,600
0,360 360,900 1740,2250 2250,2340 2340,2640
three test| and the three
|test 测试触发了我添加到 trap 的打印语句，

1827
00:59:52,600 --> 00:59:54,910
0,600 600,1380 1710,1950 1950,2040 2040,2310
test triggered {} the print

1828
00:59:54,910 --> 00:59:56,470
0,420 420,570 570,690 690,1020 1020,1560
statement that I added to

1829
00:59:56,800 --> 00:59:59,530
0,510 510,690 690,990 990,1740 1920,2730
trap| which said cow kalloc
|输出 cow kalloc failed ，

1830
00:59:59,530 --> 01:00:01,360
0,570 750,1380
failed,| which
|只有在我们内存不足的情况下才会打印出来。

1831
01:00:01,740 --> 01:00:02,610
0,300 300,480 480,690 690,780 780,870
only would print it if

1832
01:00:02,610 --> 01:00:04,140
0,120 120,300 300,360 360,960
we're out of memory.|
|

1833
01:00:05,030 --> 01:00:06,170
0,240 240,390 390,510 510,600 600,1140
So we're out of memory.|
所以我们内存不足了。|

1834
01:00:06,750 --> 01:00:08,260
0,720

1835
01:00:09,550 --> 01:00:10,090
0,210 210,300 300,390 390,480 480,540
Why are we out of
为什么我们内存不足了。

1836
01:00:10,090 --> 01:00:11,080
0,570
memory.|
|

1837
01:00:17,220 --> 01:00:19,260
0,270 270,540 540,1140 1140,1620 1620,2040
So we've updated reference counts
所以我们每次分配的时候都会更新引用计数，

1838
01:00:19,260 --> 01:00:21,750
0,300 300,690 690,1020 1020,1860 2340,2490
every time we've allocated,| but
|但是当我们释放的时候，没有减少计数。

1839
01:00:21,750 --> 01:00:24,720
0,120 120,720 720,1350 1380,1860 1980,2970
we haven't called {} decrement

1840
01:00:24,720 --> 01:00:26,190
0,390 390,690 690,990 990,1350 1350,1470
counts, whenever we've tried to

1841
01:00:26,190 --> 01:00:28,290
0,420 450,900 1260,1680 1680,1950 1950,2100
free right.| So where should
|那么我应该在哪里加上。

1842
01:00:28,290 --> 01:00:31,580
0,120 120,540 540,1020
I add the.|
|

1843
01:00:31,670 --> 01:00:33,260
0,360 360,540 540,780 780,1140 1140,1590
Well, with your current approach,|
嗯，按照你目前的方法，|

1844
01:00:33,260 --> 01:00:36,020
0,0 0,690 750,1200 1710,2190 2190,2760
I think {} {pa1 -}
我认为 pa1 的引用计数需要减少，

1845
01:00:36,050 --> 01:00:37,190
0,270 270,630 630,840 840,1050 1050,1140
that reference count needs to

1846
01:00:37,190 --> 01:00:38,450
0,210 210,900 900,1080 1080,1170 1170,1260
get decrement,| so we would
|所以我们需要 kfree 它。

1847
01:00:38,450 --> 01:00:39,620
0,180 180,270 270,510 510,690 690,1170
need to {kfree -} it.|
|

1848
01:00:39,980 --> 01:00:42,080
0,420 600,1320 1350,1560 1560,1890 1890,2100
Yeah exactly.| So, I think
是的，就是这样。|我想可能是有人在 45 分钟前提出了这个问题，

1849
01:00:42,080 --> 01:00:43,850
0,360 360,780 780,1290 1290,1530 1530,1770
somebody actually possibly brought this

1850
01:00:43,850 --> 01:00:45,680
0,390 600,1380
up, {}

1851
01:00:46,110 --> 01:00:48,480
0,390 390,840 840,1080 1080,1620 1800,2370
{} 45 minutes ago,| let's
|让我们看看，

1852
01:00:48,480 --> 01:00:50,010
0,420 450,630 630,1020 1020,1290 1290,1530
see,| {} let's free {pa1
|让我们释放 pa1 ，而不是 pa2 。

1853
01:00:50,010 --> 01:00:51,560
0,120 120,630
- -},

1854
01:00:51,650 --> 01:00:53,180
0,240 240,1050
not pa2.|
|

1855
01:00:53,320 --> 01:00:54,820
0,300 300,390 390,630 720,1080 1080,1500
Okay, and so now what
好的，现在 kfree 的意思是，

1856
01:00:55,340 --> 01:00:56,750
0,420 420,780 780,1140 1140,1290 1290,1410
{kfree -} means,| now is
|不是释放这个页面，

1857
01:00:56,750 --> 01:00:58,130
0,300 300,450 450,870 900,1170 1170,1380
don't is not free this

1858
01:00:58,130 --> 01:01:00,140
0,720 750,1440 1470,1650 1650,1860 1860,2010
page,| it's what {kfree -}
|kfree 的意思是减少这个页面上的引用计数，

1859
01:01:00,140 --> 01:01:01,250
0,240 240,390 390,780 780,870 870,1110
means is decrement the {refcount

1860
01:01:01,250 --> 01:01:02,600
0,300 300,420 420,600 600,1080 1110,1350
-} on this page| and
|如果是零的话，才释放它，

1861
01:01:02,600 --> 01:01:04,070
0,270 270,420 420,570 570,1050 1260,1470
free if it's zero| and
|以此类推，在只有一个 fork 的简单情况下，

1862
01:01:04,070 --> 01:01:04,820
0,120 120,300 300,360 360,420 420,750
so forth in a simple

1863
01:01:04,820 --> 01:01:05,990
0,540 540,660 660,750 750,930 930,1170
situation, where there was just

1864
01:01:05,990 --> 01:01:07,580
0,300 300,960 1140,1350 1350,1470 1470,1590
one fork| and so there
|所以有两个对页面的引用，

1865
01:01:07,580 --> 01:01:08,840
0,210 450,660 660,1050 1050,1140 1140,1260
were two references to the

1866
01:01:08,840 --> 01:01:11,600
0,660 990,1800 2130,2340 2340,2520 2520,2760
page,| {} and we've taken
|我们在复制中得到了写入错误，

1867
01:01:11,600 --> 01:01:12,530
0,90 90,330 330,660 660,750 750,930
a write fault to make

1868
01:01:12,530 --> 01:01:13,970
0,60 60,690 720,1020 1020,1260 1260,1440
a copy,| where now all
|现在 kfree 要做的就是将计数减为 1 ，

1869
01:01:13,970 --> 01:01:15,050
0,180 180,720 750,900 900,1020 1020,1080
{kfree -} is going to

1870
01:01:15,050 --> 01:01:16,010
0,90 90,240 240,630 630,690 690,960
do is decrement the count

1871
01:01:16,010 --> 01:01:16,880
0,60 60,150 150,570 570,690 690,870
to be one| and now
|现在另一个进程可以使用这个页面，

1872
01:01:16,880 --> 01:01:18,200
0,120 120,300 300,960 960,1140 1140,1320
the other process can use

1873
01:01:18,200 --> 01:01:20,120
0,90 90,750 930,1440 1440,1650 1650,1920
the page,| we're not actually
|我们并不是要释放它。

1874
01:01:20,120 --> 01:01:21,020
0,150 150,390 390,720
gonna free it.|
|

1875
01:01:23,020 --> 01:01:26,380
0,510 1170,1560 1560,1890 1890,2790
Okay so hopefully now,|
好的，希望现在，|

1876
01:01:27,340 --> 01:01:29,060
0,870
we'll,
我们不会在 cowtest 中内存不足。

1877
01:01:35,020 --> 01:01:35,920
0,270 270,540 540,720 720,840 840,900
{} not run out of

1878
01:01:35,920 --> 01:01:38,260
0,750 750,900 900,1050 1050,1890
memory in the cowtest.|
|

1879
01:01:41,830 --> 01:01:43,120
0,390 390,570 570,750 750,960 1050,1290
Um, I love it,| okay,
嗯，我喜欢它，|好的，我们通过了 three 测试，

1880
01:01:43,120 --> 01:01:44,170
0,150 150,300 300,390 390,930 930,1050
we made it through the

1881
01:01:44,170 --> 01:01:46,480
0,240 240,870 1560,1800 1800,2100 2100,2310
three test,| {} without running
|没有内存不足。

1882
01:01:46,480 --> 01:01:47,720
0,90 90,150 150,690
out of memory.|
|

1883
01:01:48,430 --> 01:01:49,920
0,60

1884
01:01:51,420 --> 01:01:52,520
0,510
Alright,|
好的，|

1885
01:01:54,140 --> 01:01:55,940
0,180 180,390 390,690 690,1200 1500,1800
we're not done, sadly, {}|
遗憾的是，我们还没有完成，|

1886
01:01:55,940 --> 01:01:59,060
0,150 150,270 270,480 480,1050 1050,3120
we have this interesting error
我们在 file 测试中有一个有趣的错误，

1887
01:02:01,060 --> 01:02:03,040
0,300 300,600 600,1230 1230,1830 1830,1980
in the file test,| so
|那么让我们来看一下 file 测试。

1888
01:02:03,040 --> 01:02:03,640
0,270 270,390 390,420 420,540 540,600
let's take a look at

1889
01:02:03,640 --> 01:02:05,300
0,90 90,390 390,1080
the file test.|
|

1890
01:02:09,380 --> 01:02:10,860
0,420

1891
01:02:11,820 --> 01:02:12,870
0,240 240,330 330,570 570,660 660,1050
Alright, so here's the {filetest
好的，这是 filetest ，

1892
01:02:12,870 --> 01:02:15,090
0,690 1020,1380 1380,1530 1530,1890 1890,2220
-}| and it says right
|它在测试的注释中说，

1893
01:02:15,090 --> 01:02:15,720
0,90 90,150 150,480 480,540 540,630
in the comments of the

1894
01:02:15,720 --> 01:02:17,730
0,330 330,450 450,870 870,1560 1560,2010
test,| that it's investigating {copyout
|它测试 copyout ，

1895
01:02:17,730 --> 01:02:19,180
0,360 360,840
-},| so,
|所以，是很好的线索，我们的问题在哪里，

1896
01:02:19,820 --> 01:02:21,770
0,330 330,660 660,1050 1200,1770 1770,1950
good hint of where our

1897
01:02:21,770 --> 01:02:22,910
0,420 420,540 540,660 660,750 750,1140
problem is going to be,|
|

1898
01:02:23,300 --> 01:02:25,520
0,420 450,750 750,960 960,1260 1260,2220
the thing that actually failed
实际上失败的事情是，

1899
01:02:25,550 --> 01:02:27,140
0,660 1080,1230 1230,1350 1350,1440 1440,1590
is,| I mean you have
|我的意思是你必须稍微发挥你的想象力，

1900
01:02:27,140 --> 01:02:28,640
0,330 570,780 780,900 900,1440 1440,1500
to use your imagination a

1901
01:02:28,640 --> 01:02:30,770
0,180 180,450 450,780 810,1350 1830,2130
little bit,| but, { -}
|但是，错误信息似乎是这个，

1902
01:02:30,770 --> 01:02:31,790
0,180 180,390 390,690 690,930 930,1020
the error message seems to

1903
01:02:31,790 --> 01:02:32,930
0,90 90,270 270,540 540,870 870,1140
be this one,| printed from
|同时从两个不同的进程打印。

1904
01:02:32,930 --> 01:02:34,580
0,240 240,480 480,1320 1350,1560 1560,1650
two different processes at the

1905
01:02:34,580 --> 01:02:35,760
0,240 240,750
same time.|
|

1906
01:02:36,010 --> 01:02:37,240
0,510

1907
01:02:37,440 --> 01:02:38,280
0,210 210,540 540,690 690,780 780,840
And indeed, this is a
事实上，这个测试是一个循环，

1908
01:02:38,280 --> 01:02:39,300
0,360 360,510 510,810 810,930 930,1020
loop, this test is a

1909
01:02:39,300 --> 01:02:42,840
0,690 1260,1740 1860,2070 2070,2430 2430,3540
loop,| that for four iterations,
|四次迭代，就是 fork ，

1910
01:02:42,930 --> 01:02:44,460
0,360 360,900 900,990 990,1170 1170,1530
just forks| and so it's
|因此它将产生四个并发进程，

1911
01:02:44,460 --> 01:02:46,170
0,150 150,210 210,690 690,1200 1200,1710
going to produce four concurrent

1912
01:02:46,320 --> 01:02:48,630
0,810 1020,1290 1290,1470 1470,2070 2070,2310
processes,| this error message will
|这个错误消息将被交错，

1913
01:02:48,630 --> 01:02:50,340
0,120 120,240 240,300 300,720 960,1710
be {interleaved - -}, {}|
|

1914
01:02:50,490 --> 01:02:51,180
0,300 300,390 390,510 510,600 600,690
so we need to know
所以我们需要知道读取失败的原因，

1915
01:02:51,180 --> 01:02:52,410
0,240 240,510 510,720 720,1140 1140,1230
why that read failed,| if
|如果我们想了解 bug 是什么，

1916
01:02:52,410 --> 01:02:53,190
0,90 90,210 210,270 270,690 690,780
we want to understand what

1917
01:02:53,190 --> 01:02:54,900
0,90 90,300 300,690 720,1140 1440,1710
the bug is,| we need
|我们需要知道读取失败的原因。

1918
01:02:54,900 --> 01:02:55,500
0,60 60,150 150,300 300,420 420,600
to know why the read

1919
01:02:55,500 --> 01:02:57,030
0,510 720,960 960,1230 1230,1440 1440,1530
failed.| The first step is
|第一步可能是找出读取返回了什么，

1920
01:02:57,030 --> 01:02:57,720
0,180 180,270 270,480 480,540 540,690
maybe to figure out what

1921
01:02:57,720 --> 01:02:58,920
0,120 120,300 300,630 630,1050 1050,1200
the read actually returned,| all
|我们所知道的是，

1922
01:02:58,920 --> 01:03:00,780
0,90 90,540 540,720 720,990
we know is that,|
|

1923
01:03:00,870 --> 01:03:02,320
0,900
it
它返回了除了 sizeof(i) 之外的其他东西，

1924
01:03:02,960 --> 01:03:04,100
0,210 210,480 480,720 720,960 960,1140
{} returned something other than

1925
01:03:04,100 --> 01:03:05,660
0,420 420,540 540,1110 1140,1470 1470,1560
{sizeof -} i,| but we
|但是我们不知道它返回了什么，

1926
01:03:05,660 --> 01:03:06,830
0,150 150,240 240,420 420,510 510,1170
don't know what it returns,|
|

1927
01:03:06,830 --> 01:03:09,140
0,240 240,300 300,720 720,1080 1470,2310
{so,I'm,going} to capture the return
所以我要捕获返回值，

1928
01:03:09,140 --> 01:03:10,440
0,690
value,|
|

1929
01:03:10,910 --> 01:03:12,540
0,750

1930
01:03:15,680 --> 01:03:16,580
0,450 450,510 510,630 630,690 690,900
and I'm going to print
我要打印返回值。

1931
01:03:16,580 --> 01:03:17,840
0,90 90,360 360,720
the return value,

1932
01:03:17,900 --> 01:03:19,420
0,450 450,930
{at,least} know.|
|

1933
01:03:21,930 --> 01:03:23,220
0,150 150,390 390,570 570,630 630,1290
Oh, I have a question,
哦，我有个问题，抱歉，

1934
01:03:23,220 --> 01:03:25,260
0,510 570,1050 1050,1260 1260,1620 1620,2040
sorry,| {} it seems like
|看起来有三个线程失败了，

1935
01:03:25,380 --> 01:03:27,660
0,660 660,870 870,1080 1080,1710 1740,2280
three of the threads failed,|
|

1936
01:03:27,660 --> 01:03:28,660
0,390
but,
但是，其中一个并没有结束，

1937
01:03:28,780 --> 01:03:30,520
0,330 330,450 450,660 660,1230 1260,1740
one of them didn't end,|
|

1938
01:03:31,150 --> 01:03:32,830
0,300 300,420 420,660 660,990 990,1680
it's {} like still running,|
它还在运行，|

1939
01:03:33,280 --> 01:03:34,630
0,270 270,390 390,540 540,780 780,1350
why is it not failing?|
为什么它没有失败？|

1940
01:03:35,490 --> 01:03:36,600
0,300 300,480 480,570 570,900 900,1110
Why did the third thread
为什么第三个线程没有失败？

1941
01:03:36,600 --> 01:03:40,350
0,210 210,570 2100,2970 2970,3510 3510,3750
not fail?| {The,fourth,,if} you, {if,you}
|第四个，如果你做 cowtest 然后 echo ，

1942
01:03:40,350 --> 01:03:41,550
0,120 120,360 360,810 810,930 930,1200
do {cowtest -} and then

1943
01:03:41,550 --> 01:03:42,760
0,690
echo,|
|

1944
01:03:42,760 --> 01:03:44,410
0,480 510,840 840,1050 1050,1200 1200,1650
that other one is still
另一个还会继续运行，

1945
01:03:44,410 --> 01:03:45,130
0,120 120,180 180,300 300,630 630,720
going to be running| and
|你会看到更多的输出。

1946
01:03:45,130 --> 01:03:46,840
0,150 150,360 360,780 810,1050 1050,1710
you're gonna see more output.|
|

1947
01:03:49,290 --> 01:03:50,160
0,270 270,420 420,660 660,810 810,870
Yes, three failed and one
是的，三个失败了，一个没有。

1948
01:03:50,160 --> 01:03:51,860
0,330 360,1080
didn't. {}|
|

1949
01:03:53,230 --> 01:03:56,080
0,1110 1470,1890 1890,2070 2070,2340 2340,2850
Um, let's just finish investigating
嗯，让我们先调查一下为什么它们中的任何一个都失败了，

1950
01:03:56,080 --> 01:03:57,640
0,210 210,450 450,540 540,690 690,1560
why any of them failed,|
|

1951
01:03:57,790 --> 01:03:58,960
0,180 180,600 780,930 930,1050 1050,1170
and then I can make
然后我可以猜一猜，

1952
01:03:58,960 --> 01:04:00,790
0,60 60,720 1080,1560 1560,1800 1800,1830
a guess| {} although I
|虽然不知道为什么其中一个没有失败。

1953
01:04:00,790 --> 01:04:02,410
0,150 150,360 360,540 540,1320 1380,1620
don't really know why one

1954
01:04:02,410 --> 01:04:03,920
0,90 90,210 210,540 540,1050
of them didn't fail.|
|

1955
01:04:05,110 --> 01:04:06,730
0,270 270,600 780,1050 1050,1260 1260,1620
Okay, so {}, what's happening
好的，这里发生的情况是， read 返回的是 -1 。

1956
01:04:06,730 --> 01:04:07,720
0,150 150,210 210,330 330,600 600,990
here is that read returning

1957
01:04:07,720 --> 01:04:09,200
0,330 330,780
{-1 -}.|
|

1958
01:04:09,740 --> 01:04:11,120
0,180 180,420 420,570 570,1110 1110,1380
So why is {read,returning} {-1
那么为什么 read 返回的是 -1 。

1959
01:04:11,120 --> 01:04:12,200
0,450
-}.|
|

1960
01:04:12,870 --> 01:04:14,640
0,240 240,360 360,570 570,1500 1500,1770
{} You might hypothesize| that
你可能会假设，|我们将这个 buf 传递给 read ，

1961
01:04:14,640 --> 01:04:15,900
0,300 300,390 390,570 570,1110 1110,1260
the you know we were

1962
01:04:15,900 --> 01:04:17,670
0,360 360,510 510,930 930,1170 1170,1770
passing this buffer into read,|
|

1963
01:04:18,060 --> 01:04:19,740
0,510 510,900 900,1050 1050,1470 1470,1680
{} you might imagine that
你可能会想象，

1964
01:04:19,740 --> 01:04:21,210
0,450 600,1050 1050,1140 1140,1260 1260,1470
the,| {} you know read,
|你知道 read 需要做一些事情，

1965
01:04:21,210 --> 01:04:22,260
0,180 180,660 660,840 840,930 930,1050
and read needs to do

1966
01:04:22,260 --> 01:04:24,060
0,390 390,900 1020,1170 1170,1560 1560,1800
something| namely called {copyout -}
|也就是调用 copyout 将文件数据复制到这个缓冲区中，

1967
01:04:24,390 --> 01:04:26,790
0,690 1020,1410 1410,1740 1740,2100 2100,2400
to copy file data into

1968
01:04:26,790 --> 01:04:29,000
0,360 480,720 720,900 900,1770
this into this buffer,|
|

1969
01:04:29,120 --> 01:04:29,870
0,180 180,300 300,390 390,690 690,750
{} that we passed to
我们传递给 read 的，

1970
01:04:29,870 --> 01:04:31,010
0,240 240,450 450,750 750,930 930,1140
read,| maybe something's going wrong
|也许它出了什么问题，

1971
01:04:31,010 --> 01:04:32,150
0,90 90,360 360,450 450,660 660,1140
with that| and its relationship
|它与写入是复制 fork 的关系。

1972
01:04:32,150 --> 01:04:33,890
0,90 90,630 630,1050 1290,1530 1530,1740
to copy-on-write fork.| So let's
|那么让我们来看看 read ，

1973
01:04:33,890 --> 01:04:34,880
0,180 180,210 210,360 360,450 450,990
take a look at read,|
|

1974
01:04:35,680 --> 01:04:36,820
0,570

1975
01:04:38,530 --> 01:04:39,580
0,420 420,630 630,780 780,930 930,1050
{} and see why it's
看看它为什么会失败。

1976
01:04:39,580 --> 01:04:40,640
0,570
failing.|
|

1977
01:04:40,730 --> 01:04:42,460
0,540 540,1320
Track down,
找出，为什么 read ，

1978
01:04:43,690 --> 01:04:45,580
0,270 270,750 780,1260 1440,1770 1770,1890
why read,| {} alright, so
|好的，那么让我们来捕捉，

1979
01:04:45,580 --> 01:04:47,080
0,120 120,600 600,870 900,1380 1380,1500
let's capture the,| read all
|read 所有 sys_read 调用 fileread ，

1980
01:04:47,080 --> 01:04:48,700
0,300 300,540 540,870 870,1350 1380,1620
{sys_read -} does this calls

1981
01:04:48,700 --> 01:04:50,980
0,330 330,690 690,1140 1470,1920 1920,2280
calls {fileread -}| after fetching
|在获取一组参数之后。

1982
01:04:50,980 --> 01:04:53,660
0,60 60,240 240,300 300,1020
a bunch of arguments.|
|

1983
01:04:55,010 --> 01:04:57,110
0,330 330,630 630,930 930,1260 1260,2100
So we'll fix this to,|
所以我们修复这个，|

1984
01:04:57,170 --> 01:04:58,480
0,750

1985
01:04:58,480 --> 01:04:59,560
0,240 240,330 330,480 480,750 750,1080
take {} one step closer
走进一步，来理解什么东西出错了。

1986
01:04:59,560 --> 01:05:00,850
0,90 90,660 660,1020 1020,1230 1230,1290
to understanding why things are

1987
01:05:00,850 --> 01:05:02,180
0,240 240,690
going wrong.|
|

1988
01:05:05,310 --> 01:05:06,840
0,150 150,300 300,990 990,1440 1440,1530
We are expecting cc to
我们希望 cc 会为 -1 。

1989
01:05:06,840 --> 01:05:08,780
0,570 780,1290
be {}

1990
01:05:09,020 --> 01:05:10,260
0,330 330,750
{-1 -}.|
|

1991
01:05:18,500 --> 01:05:22,010
0,420 420,1050 1050,1590 1890,2490 3210,3510
Um, that's interesting,| {} {we,never}
嗯，有意思，|我们没有看到 cc 等于 -1 。

1992
01:05:22,010 --> 01:05:23,750
0,210 210,660 660,1110 1110,1440 1440,1740
saw cc minus equals {-1

1993
01:05:23,750 --> 01:05:24,940
0,660
-}.|
|

1994
01:05:25,060 --> 01:05:27,010
0,180 180,420 420,510 510,960 960,1950
In fact, the failure occurred,|
事实上，失败发生了，|

1995
01:05:27,310 --> 01:05:30,010
0,690 1110,1500 1500,1800 1800,2100 2100,2700
a failure starts occurring here,|
失败从这里开始发生，|

1996
01:05:30,040 --> 01:05:32,590
0,900 900,1050 1050,1470 1470,1680 1680,2550
before we get any corresponding
在我们得到任何相应的 cc 打印语句之前，

1997
01:05:32,590 --> 01:05:34,160
0,1050
cc

1998
01:05:34,870 --> 01:05:36,700
0,300 300,1140 1140,1320 1320,1470 1470,1830
print statements| and it's not
|它根本不是 -1 ，

1999
01:05:36,790 --> 01:05:37,720
0,330 330,480 480,600 600,780 780,930
{-1 -} at all,| it's
|而是 4 ，这是一个非失败值。

2000
01:05:37,720 --> 01:05:38,980
0,270 270,540 540,720 720,870 900,1260
four, which is a non

2001
01:05:38,980 --> 01:05:40,780
0,330 330,810
failure value.|
|

2002
01:05:40,990 --> 01:05:42,560
0,960

2003
01:05:42,620 --> 01:05:43,520
0,150 150,270 270,420 420,690 690,900
So what that means is,|
所以这意味着，

2004
01:05:43,520 --> 01:05:44,990
0,240 240,600 600,1170 1170,1230 1230,1470
that something before the call
在调用 fileread 之前的一些事情，

2005
01:05:44,990 --> 01:05:47,120
0,120 120,570 570,1050 1530,1890 1890,2130
the {fileread -}| {} must
|一定触发了这次返回，

2006
01:05:47,120 --> 01:05:49,940
0,180 180,930 960,1260 1260,1650 2070,2820
have caused must have triggered

2007
01:05:49,940 --> 01:05:51,290
0,180 180,840 990,1170 1170,1290 1290,1350
this return,| so one of
|这里的其中一个函数，

2008
01:05:51,290 --> 01:05:52,900
0,210 210,660 660,1170
these functions here,|
|

2009
01:05:53,580 --> 01:05:55,350
0,540 660,1200 1200,1410 1410,1500 1500,1770
has caused read to return
导致 read 返回 -1 。

2010
01:05:55,350 --> 01:05:56,660
0,300 300,720
{-1 -}.|
|

2011
01:05:58,690 --> 01:05:59,740
0,300 300,570 570,840 840,990 990,1050
{} Please feel free to
请随意猜猜，在我输入时。

2012
01:05:59,740 --> 01:06:01,520
0,450 450,630 630,720 720,1200
guess while I'm typing.|
|

2013
01:06:03,980 --> 01:06:05,120
0,180 180,300 300,390 390,720 720,1140
This was a complete surprise
顺便说一下，这对我来说完全是个意外，

2014
01:06:05,120 --> 01:06:05,690
0,90 90,180 180,330 330,420 420,570
to me by the way,|
|

2015
01:06:05,690 --> 01:06:06,880
0,210 210,570
when I
当我追踪到它的时候。

2016
01:06:07,270 --> 01:06:08,560
0,330 330,420 420,780
tracked it down.|
|

2017
01:06:08,950 --> 01:06:10,330
0,420 420,570 570,870 870,1020 1020,1380
Oh, I think the {file,is}
哦，我想这个文件是描述符。

2018
01:06:10,330 --> 01:06:11,980
0,930
descriptor.|
|

2019
01:06:12,010 --> 01:06:13,900
0,360 360,480 480,720 720,1410 1620,1890
Yeah, the file descriptor, I
是的，文件描述符，我看到了，

2020
01:06:13,900 --> 01:06:15,160
0,360 360,570 570,660 660,1140 1140,1260
saw,| what I expected was
|我所期望的是 fileread 失败是由于某些原因，

2021
01:06:15,160 --> 01:06:17,230
0,120 120,570 570,1080 1080,1290 1290,2070
that {fileread -} was failing

2022
01:06:17,290 --> 01:06:19,480
0,660 660,780 780,1140 1140,1620 1710,2190
due to something| and {copyout
|而且 copyout 对写入时复制的页面做不正确的事情，

2023
01:06:19,480 --> 01:06:20,680
0,270 270,630
-} not

2024
01:06:20,680 --> 01:06:21,490
0,180 180,270 270,450 450,600 600,810
doing the right thing with

2025
01:06:21,490 --> 01:06:23,860
0,330 330,480 480,990 1020,1800
{copy-on-write - -} pages,|
|

2026
01:06:24,220 --> 01:06:24,940
0,210 210,360 360,420 420,630 630,720
but that is not at
但这不是失败的地方。

2027
01:06:24,940 --> 01:06:25,990
0,120 120,270 270,360 360,750 750,1050
all where the failure is.|
|

2028
01:06:26,290 --> 01:06:27,660
0,300 300,660
Okay, so,
好的，如果我们想找出，

2029
01:06:27,660 --> 01:06:28,320
0,150 150,360 360,450 450,600 600,660
{} if we want to

2030
01:06:28,320 --> 01:06:29,610
0,300 300,570 570,840 870,1050 1050,1290
find out,| like it's either
|它是 argfd 或者 argint 或者 argaddr 失败，

2031
01:06:29,610 --> 01:06:31,410
0,150 150,570 570,690 690,1170 1170,1800
{argfd -} or argint {or,argaddr},

2032
01:06:31,410 --> 01:06:32,790
0,90 90,330 330,780 870,1140 1140,1380
{} that's failing,| let's start
|让我们从 argfd 开始，

2033
01:06:32,790 --> 01:06:34,620
0,150 150,300 300,900 1260,1680 1680,1830
with {argfd -},| I'm just
|我要把打印语句放在这里，

2034
01:06:34,620 --> 01:06:35,850
0,180 180,450 450,660 660,1110 1110,1230
gonna stick print statements in

2035
01:06:35,850 --> 01:06:37,200
0,330 330,390 390,660 660,930 930,1350
here,| to help me {}
|帮助我找出，

2036
01:06:38,380 --> 01:06:39,820
0,840
{}

2037
01:06:40,220 --> 01:06:41,330
0,330 330,630 630,690 690,900 900,1110
{} figure out,| which one
|这些失败情况中的哪一个触发了，

2038
01:06:41,330 --> 01:06:42,680
0,60 60,300 300,630 630,1080 1080,1350
of these failure cases actually

2039
01:06:42,680 --> 01:06:44,420
0,510 540,1080 1170,1410 1410,1560 1560,1740
triggering triggering,| so like two
|有两个地方返回的是 -1 ，

2040
01:06:44,420 --> 01:06:45,890
0,330 330,420 420,720 720,990 990,1470
places it returns {-1 -},|
|

2041
01:06:46,280 --> 01:06:48,260
0,780 1140,1410 1410,1560 1560,1710 1710,1980
{} this one there's something
这个是 fd 本身出了问题，

2042
01:06:48,260 --> 01:06:49,760
0,180 180,300 300,390 390,750 750,1500
wrong with the fd itself,|
|

2043
01:06:52,580 --> 01:06:53,270
0,180 180,270 270,420 420,540 540,690
so we're gonna get these
所以我们在 argfd 返回 -1 的地方添加打印语句。

2044
01:06:53,270 --> 01:06:54,860
0,180 180,690 690,930 930,1260 1260,1590
print statements on cases where

2045
01:06:55,440 --> 01:06:56,700
0,210 210,420 420,810 810,1050 1050,1260
{argfd -} returns {-1 -}.|
|

2046
01:07:05,950 --> 01:07:06,970
0,150 150,630 630,750 750,840 840,1020
{} Yeah, what is this
是的，这是什么意思， fd 。

2047
01:07:06,970 --> 01:07:08,080
0,540
mean,

2048
01:07:09,010 --> 01:07:10,960
0,300 300,990 1050,1440 1440,1560 1560,1950
{fd -}.| Alright, so the
|好的，我们希望这些 fd 打印输出，发生在错误之前，

2049
01:07:11,820 --> 01:07:12,930
0,210 210,360 360,720 720,870 870,1110
that we expect these {fd

2050
01:07:12,930 --> 01:07:15,660
0,660 1050,1620 1620,1890 2100,2490 2490,2730
-} printouts to occur, just

2051
01:07:15,660 --> 01:07:17,100
0,360 360,510 510,900 1050,1320 1320,1440
before the error,| so we
|所以我们看到的是 fd 9 ，

2052
01:07:17,100 --> 01:07:18,600
0,210 210,390 390,630 630,810 810,1500
saw is {fd -} 9,|
|

2053
01:07:18,600 --> 01:07:20,340
0,90 90,390 390,630 630,870 870,1740
it was {fd -} 9,
它是 fd 9 ，这会导致错误，

2054
01:07:20,800 --> 01:07:22,450
0,360 360,540 540,900 900,1050 1050,1650
{} this causes the error,|
|

2055
01:07:22,810 --> 01:07:24,400
0,540 540,1140 1140,1290 1290,1380 1380,1590
{so,fd,9} failed one of these
所以 fd 9 没有通过这三个测试中的一个，

2056
01:07:24,400 --> 01:07:25,510
0,240 240,720 720,900 900,990 990,1110
three tests,| but we know
|但我们知道它不小于零，

2057
01:07:25,510 --> 01:07:27,040
0,120 120,300 300,480 480,810 960,1530
it's not less than zero,|
|

2058
01:07:27,370 --> 01:07:28,120
0,210 210,390 390,450 450,630 630,750
I happen to know it's
我碰巧知道它不大于等于 NOFILE ，即打开的文件数，

2059
01:07:28,120 --> 01:07:29,380
0,210 210,540 540,660 660,930 930,1260
not greater than equal to

2060
01:07:29,560 --> 01:07:31,180
0,300 300,570 570,1200 1260,1350 1350,1620
{NOFILE - -}, a number

2061
01:07:31,180 --> 01:07:32,620
0,90 90,330 330,1170 1170,1350 1350,1440
of open files,| and so
|这意味着 ofile 数组 9 ，

2062
01:07:32,620 --> 01:07:33,460
0,150 150,360 360,510 510,660 660,840
that means that the {ofile

2063
01:07:33,460 --> 01:07:36,670
0,780 930,1830 2100,2460 2460,2640 2640,3210
-} array {} for 9,|
|

2064
01:07:36,670 --> 01:07:37,690
0,240 240,540 540,780 780,930 930,1020
file descriptor 9 must have
文件描述符 9 必须为 0 ，

2065
01:07:37,690 --> 01:07:38,830
0,120 120,510 510,660 660,990 1020,1140
been 0,| that is in
|也就是说，在这个进程中，没有文件描述符 9 。

2066
01:07:38,830 --> 01:07:40,300
0,180 180,750 900,1140 1140,1320 1320,1470
this process, there is no

2067
01:07:40,300 --> 01:07:41,900
0,240 240,660 660,1110
file descriptor 9.|
|

2068
01:07:42,380 --> 01:07:43,520
0,570

2069
01:07:43,700 --> 01:07:45,640
0,300 300,1290
So somehow,
所以不知道什么原因，写入时复制测试，

2070
01:07:45,730 --> 01:07:48,160
0,510 510,720 720,1050 1050,1770
{copy-on-write - -} test,|
|

2071
01:07:48,320 --> 01:07:49,680
0,780

2072
01:07:49,680 --> 01:07:51,660
0,360 360,1110 1320,1590 1590,1890 1890,1980
this code and {copy-on-write -
这个代码和写入时复制测试传递了无效文件描述符来读取。

2073
01:07:51,660 --> 01:07:53,910
0,210 210,450 450,750 1140,1710 1800,2250
-} test is passing an

2074
01:07:53,940 --> 01:07:55,920
0,540 540,810 810,1230 1230,1380 1380,1980
invalid file descriptor to read.|
|

2075
01:07:56,580 --> 01:07:57,660
0,540
So,
所以，文件描述符来自 fds ，

2076
01:07:57,860 --> 01:07:59,450
0,450 450,930 930,1170 1230,1470 1470,1590
file descriptor in comes from

2077
01:07:59,450 --> 01:08:01,040
0,180 180,360 360,1110 1170,1440 1440,1590
{fds - -},| {fds -
|fds 来自对管道的调用。

2078
01:08:01,040 --> 01:08:02,760
0,210 210,510 510,1140
-} comes from

2079
01:08:02,760 --> 01:08:04,440
0,90 90,330 330,450 450,1170
a call to pipe.|
|

2080
01:08:06,710 --> 01:08:08,090
0,420 420,660 660,750 750,1080 1080,1380
How could I,| usually pipe,
怎么会，|通常 pipe 如果没有失败，

2081
01:08:08,090 --> 01:08:08,930
0,120 120,180 180,390 390,750 750,840
if it doesn't fail,| it
|它会将文件描述符留在数组中，

2082
01:08:08,930 --> 01:08:09,890
0,180 180,270 270,480 480,900 900,960
leaves the file descriptor in

2083
01:08:09,890 --> 01:08:10,730
0,90 90,390 390,540 540,690 690,840
the array,| so how could
|那么这怎么会出错呢。

2084
01:08:10,730 --> 01:08:12,300
0,120 120,270 270,690
this go wrong.|
|

2085
01:08:18,860 --> 01:08:19,880
0,390 390,540 540,690 690,900 900,1020
Oh, we all know the
哦，我们都知道答案一定是什么什么 copyout 。

2086
01:08:19,880 --> 01:08:21,380
0,270 270,540 540,630 630,1200 1230,1500
answer has to be blah

2087
01:08:21,380 --> 01:08:23,780
0,240 240,660 690,1140 1140,1890
blah blah {copyout -}.|
|

2088
01:08:25,880 --> 01:08:27,290
0,210 210,420 420,510 510,780 780,1410
So what's the missing piece.|
那么缺失的部分是什么。|

2089
01:08:38,060 --> 01:08:39,530
0,120 120,510 510,840 870,1170 1170,1470
I mean, I guess like
我是说，我想有一件事能帮我找到这件事，

2090
01:08:39,530 --> 01:08:40,840
0,270 270,480 480,720
one thing that

2091
01:08:40,840 --> 01:08:42,100
0,210 210,510 510,840 840,1020 1020,1260
help me track this down|
|

2092
01:08:42,100 --> 01:08:43,510
0,120 120,210 210,990 1050,1200 1200,1410
as I realized at least
因为我意识到首先 fd 不应该是 9 ，

2093
01:08:43,510 --> 01:08:45,920
0,300 300,420 420,810 1260,1830
first of all {}

2094
01:08:45,920 --> 01:08:47,450
0,360 360,540 540,780 780,900 900,1530
fd should not be 9,|
|

2095
01:08:47,480 --> 01:08:48,950
0,120 120,330 330,1020 1020,1320 1320,1470
on every iteration 9 is
在每一次迭代中， 9 都是你所期望的值，

2096
01:08:48,950 --> 01:08:49,910
0,210 210,270 270,360 360,720 720,960
kind of the value that

2097
01:08:50,090 --> 01:08:52,300
0,150 150,240 240,1020
you would expect,|
|

2098
01:08:52,470 --> 01:08:53,490
0,180 180,270 270,510 540,900 900,1020
kind of add on the
在上一次迭代的基础上增加一些，

2099
01:08:53,490 --> 01:08:54,690
0,270 270,750 750,930 930,1080 1080,1200
last iteration,| that's kind of
|这像是对管道的最高调用。

2100
01:08:54,690 --> 01:08:56,100
0,210 210,300 300,690 690,1140 1260,1410
like the highest call to

2101
01:08:56,100 --> 01:08:57,420
0,210 210,600 900,1080 1080,1200 1200,1320
pipe.| Yeah yeah, they all
|是的，它们都会得到 9 ，你说得对。

2102
01:08:57,420 --> 01:08:59,160
0,210 210,600 600,780 780,1140 1560,1740
got 9, you're right.| There's
|有什么东西使内存变得奇怪。

2103
01:08:59,160 --> 01:09:01,080
0,630 840,1020 1020,1230 1230,1440 1440,1920
something they're kind of touching

2104
01:09:01,080 --> 01:09:02,980
0,150 150,420 420,840 870,1470
each other's memory strange.|
|

2105
01:09:03,010 --> 01:09:05,380
0,270 270,480 480,1140 1140,1650 1800,2370
Yeah, that's exactly right.| So,
是的，完全正确。|所以， fds 管道，

2106
01:09:06,060 --> 01:09:07,380
0,120 120,210 210,360 360,810 810,1320
you know the {fds -}

2107
01:09:07,380 --> 01:09:08,790
0,570 570,690 690,840 840,1170 1170,1410
pipe,| the way pipe turns
|管道转换文件描述符的方式是它调用 copyout ，

2108
01:09:08,790 --> 01:09:09,900
0,60 60,330 330,900 900,1020 1020,1110
the file descriptors is that

2109
01:09:09,900 --> 01:09:11,960
0,60 60,390 390,960 960,1500
it calls {copyout -},|
|

2110
01:09:12,380 --> 01:09:14,180
0,150 150,720 720,840 840,1110 1110,1800
to copy the file descriptor
将分配的文件描述符号复制到调用方的地址空间。

2111
01:09:14,210 --> 01:09:15,650
0,480 480,600 600,720 720,1290 1290,1440
number that is allocated into

2112
01:09:15,650 --> 01:09:17,600
0,90 90,480 480,750 750,1230 1500,1950
the caller's address space.| Well,
|我们这里用的是写入时复制 fork ，

2113
01:09:17,690 --> 01:09:19,070
0,450 450,690 690,1050 1050,1170 1170,1380
we're using {copy-on-write - -}

2114
01:09:19,070 --> 01:09:20,690
0,360 360,630 630,1050 1410,1560 1560,1620
fork here,| so if we're
|所以如果我们不小心，

2115
01:09:20,690 --> 01:09:21,980
0,180 180,810 840,1020 1020,1110 1110,1290
not careful,| so at least
|至少最初只有一个页面，

2116
01:09:21,980 --> 01:09:24,530
0,750 1650,1830 1830,1980 1980,2190 2190,2550
initially there's just one page|
|

2117
01:09:24,530 --> 01:09:25,430
0,90 90,210 210,510 510,720 720,900
and it's shared among all
它在所有进程之间共享。

2118
01:09:25,430 --> 01:09:27,110
0,60 60,930 1140,1320 1320,1410 1410,1680
the processes.| So the first
|所以第一个调用管道的进程，

2119
01:09:27,110 --> 01:09:29,060
0,390 390,480 480,840 840,1530
process that calls pipe,|
|

2120
01:09:29,780 --> 01:09:31,400
0,150 150,360 360,570 570,1200 1440,1620
if something goes wrong,| the
如果出现问题，|管道系统调用可能会写入共享页面，

2121
01:09:31,400 --> 01:09:33,830
0,300 300,600 600,1200 1230,1530 1530,2430
pipe system call might conceivably

2122
01:09:34,220 --> 01:09:36,420
0,330 330,420 420,780 780,1620
write the shared page,|
|

2123
01:09:36,700 --> 01:09:38,470
0,450 630,930 930,1380 1380,1560 1560,1770
and that value that file
然后该文件描述符的值将被所有进程看到，

2124
01:09:38,470 --> 01:09:39,610
0,450 450,570 570,780 780,900 900,1140
descriptor will then be seen

2125
01:09:39,610 --> 01:09:41,200
0,240 270,510 510,600 600,1290 1290,1590
by all the processes,| instead
|而不仅仅是实际分配描述符的进程。

2126
01:09:41,200 --> 01:09:42,400
0,150 150,570 570,630 630,1080 1080,1200
of just the process that

2127
01:09:42,400 --> 01:09:44,640
0,360 390,1020 1020,1080 1080,1770
actually allocated the descriptor.|
|

2128
01:09:45,360 --> 01:09:46,540
0,600

2129
01:09:46,660 --> 01:09:47,770
0,210 210,390 390,720 720,930 930,1110
They really see this as
它们看到这个是一种假设风险。

2130
01:09:47,770 --> 01:09:49,120
0,150 150,360 360,540 990,1140 1140,1350
a kind of at least

2131
01:09:49,120 --> 01:09:51,000
0,660 660,1320
hypothetical risk.|
|

2132
01:09:54,030 --> 01:09:55,260
0,180 180,690 690,840 840,930 930,1230
So let's look at what,|
那么让我们来看看，|

2133
01:09:55,440 --> 01:09:57,000
0,180 180,270 270,840 900,1140 1140,1560
try to imagine,| so first
试着想象一下，|因此，首先让我们看看 sysfile ，

2134
01:09:57,240 --> 01:10:00,450
0,360 360,720 750,1470 1950,2460 2460,3210
let's look {} {sysfile -}|
|

2135
01:10:00,480 --> 01:10:01,900
0,150 150,930
to see
看看管道是如何复制出分配的文件描述符的，

2136
01:10:03,670 --> 01:10:05,320
0,360 360,1380
how pipe

2137
01:10:06,700 --> 01:10:07,820
0,540
{}

2138
01:10:08,220 --> 01:10:10,800
0,750 750,1110 1140,1590 1800,2160 2160,2580
copies out the file descriptors

2139
01:10:10,800 --> 01:10:13,440
0,90 90,660 1740,2010 2010,2400 2400,2640
that allocates| and indeed down
|事实上，在这里有两个调用 copyout ，

2140
01:10:13,440 --> 01:10:14,880
0,240 240,450 450,690 690,1230 1230,1440
here, these two calls to

2141
01:10:14,880 --> 01:10:15,860
0,450
{}

2142
01:10:15,920 --> 01:10:17,630
0,480 480,900 1080,1320 1320,1620 1620,1710
{copyout -}| to copy the
|复制管道数组中的两个元素，

2143
01:10:17,630 --> 01:10:18,830
0,240 240,660 660,720 720,900 900,1200
two elements of that pipe

2144
01:10:18,830 --> 01:10:20,750
0,120 120,450 1260,1530 1530,1680 1680,1920
array,| so pipe is using
|所以，管道使用 copyout

2145
01:10:20,750 --> 01:10:22,480
0,390 390,630 630,840 840,1170
{copyout -}| to {}
|将文件描述符复制到用户空间的数组中。

2146
01:10:22,620 --> 01:10:24,150
0,330 330,420 420,630 630,990 990,1530
copy the file descriptor numbers

2147
01:10:24,150 --> 01:10:25,230
0,180 180,300 300,720 720,840 840,1080
into the array in user

2148
01:10:25,230 --> 01:10:26,360
0,600
space.|
|

2149
01:10:26,420 --> 01:10:27,680
0,180 180,300 300,390 390,750 750,1260
So what is copyout do.|
那么， copyout 做了什么呢。|

2150
01:10:31,500 --> 01:10:33,090
0,330 330,540 600,1050 1050,1230 1230,1590
Well, it looks up the
嗯，它查找虚拟地址以找到物理地址。

2151
01:10:33,210 --> 01:10:34,440
0,480 480,870 870,990 990,1170 1170,1230
virtual address to find a

2152
01:10:34,440 --> 01:10:36,500
0,390 390,1080
physical address.|
|

2153
01:10:37,100 --> 01:10:38,720
0,270 270,1050
And then
然后它会写入复制该物理地址，仅此而已。

2154
01:10:40,760 --> 01:10:43,790
0,540 600,1350 1350,2220 2640,2850 2850,3030
its writes, copies over that

2155
01:10:43,790 --> 01:10:45,620
0,300 300,870 960,1140 1140,1410 1410,1830
physical address and that's it.|
|

2156
01:10:46,180 --> 01:10:47,080
0,240 240,390 390,540 540,630 630,900
So, one thing it is
因此，它没有做的一件事是

2157
01:10:47,110 --> 01:10:49,750
0,600 600,1200 1470,1920 1920,2430 2430,2640
not doing is| checking for
|检查写权限，没有查看 PTE_W 。

2158
01:10:49,750 --> 01:10:51,040
0,240 240,780 810,1050 1050,1200 1200,1290
write permission, doesn't look at

2159
01:10:51,040 --> 01:10:52,580
0,420 420,1050
{PTE_W -}.|
|

2160
01:10:53,590 --> 01:10:54,790
0,210 210,330 330,480 480,690 690,1200
And so with this page,|
因此，对于这个页面，|

2161
01:10:54,790 --> 01:10:56,140
0,90 90,210 210,570 570,1020 1020,1350
at this virtual address refers
在这个虚拟地址指向的写入时复制的共享页面，

2162
01:10:56,140 --> 01:10:57,160
0,150 150,240 240,600 600,750 750,1020
to a {copy-on-write - -}

2163
01:10:57,160 --> 01:10:59,440
0,480 480,1260 1440,1890 1890,2100 2100,2280
shared page,| {copyout -} just
|copyout 根本不知道，它会继续写下去。

2164
01:10:59,440 --> 01:11:01,000
0,480 510,720 720,1110 1110,1200 1200,1560
has no idea it just

2165
01:11:01,000 --> 01:11:01,840
0,180 180,330 330,450 450,720 720,840
goes ahead and writes it.|
|

2166
01:11:02,580 --> 01:11:04,890
0,240 240,300 300,720 750,1620 2010,2310
So I mean indeed, {}
所以我的意思是，当管道调用 copyout 时，

2167
01:11:04,890 --> 01:11:06,330
0,270 270,570 570,840 840,1200 1200,1440
when pipe calls {copyout -},|
|

2168
01:11:06,330 --> 01:11:07,350
0,180 180,330 330,390 390,540 540,1020
it's going to be writing
它会写一个共享页面，

2169
01:11:07,350 --> 01:11:09,060
0,150 150,630 630,1110 1110,1380 1380,1710
a shared page,| that all
|所有 fork 进程都可以看到这个修改，

2170
01:11:09,060 --> 01:11:10,650
0,90 90,210 210,600 600,1170 1170,1590
of the forked processes see

2171
01:11:10,650 --> 01:11:12,630
0,210 210,960 1260,1710 1710,1890 1890,1980
this modification,| not just the
|而不仅仅是调用管道的进程。

2172
01:11:12,630 --> 01:11:14,160
0,360 360,480 480,690 690,1140
process that called pipe.|
|

2173
01:11:15,270 --> 01:11:16,860
0,210 210,660 660,1020
Any questions about,
对于为什么会发生这个，有什么问题吗？

2174
01:11:16,890 --> 01:11:18,560
0,270 270,480 480,600 600,1110
why this is happening?|
|

2175
01:11:25,570 --> 01:11:26,780
0,570
Okay.|
好的。|

2176
01:11:27,100 --> 01:11:28,800
0,1170

2177
01:11:29,000 --> 01:11:30,080
0,390 390,690 690,840 840,960 960,1080
Alright, so as you all
好的，你们都知道我们需要修改 copyout ，

2178
01:11:30,080 --> 01:11:31,190
0,240 240,330 330,510 510,660 660,1110
know we need to modify

2179
01:11:31,190 --> 01:11:33,710
0,480 480,1050 1470,1890 1890,2160 2160,2520
{copyout -} to| since {copyout
|由于 copyout 是查找虚拟地址并将其转换为物理地址，

2180
01:11:33,710 --> 01:11:34,970
0,120 120,360 450,1080 1080,1200 1200,1260
-} is looking up a

2181
01:11:34,970 --> 01:11:36,650
0,330 330,720 720,930 1050,1530 1530,1680
virtual address and translating into

2182
01:11:36,650 --> 01:11:37,520
0,90 90,390 390,690 690,810 810,870
a physical address,| but it
|但是它没有使用 MMU ，

2183
01:11:37,520 --> 01:11:38,750
0,120 120,540 540,750 750,870 870,1230
is not using the {MMU

2184
01:11:38,750 --> 01:11:40,280
0,360 600,780 780,900 900,1290 1290,1530
-},| so the MMU doesn't
|所以 MMU 没有捕捉到写入错误，

2185
01:11:40,280 --> 01:11:41,900
0,480 480,600 600,870 870,1410 1440,1620
catch the write fault,| because
|因为 MMU 没有参与，

2186
01:11:41,900 --> 01:11:43,730
0,120 120,390 390,600 630,1020 1020,1830
the MMU is not involved,|
|

2187
01:11:45,290 --> 01:11:46,280
0,120 120,420 420,600 600,750 750,990
{} {walkaddr - -} looks
walkaddr 查看页表本身

2188
01:11:46,280 --> 01:11:47,390
0,60 60,120 120,390 390,630 630,1110
at the page table itself|
|

2189
01:11:47,390 --> 01:11:49,310
0,360 360,720 780,1320 1320,1590 1590,1920
instead of basically getting there
而不是让 MMU 为它查看页表。

2190
01:11:49,550 --> 01:11:50,570
0,570 570,720 720,810 810,960 960,1020
{MMU -} to look at

2191
01:11:50,570 --> 01:11:51,560
0,90 90,330 330,600 600,840 840,990
the page table for it.|
|

2192
01:11:54,040 --> 01:11:55,420
0,270 270,720 900,1140 1140,1260 1260,1380
Okay, so, {} we need
好的，那么，我们需要修改 copyout ，

2193
01:11:55,420 --> 01:11:57,220
0,90 90,1230
to modify

2194
01:11:57,340 --> 01:11:58,720
0,450 450,870 930,1110 1110,1260 1260,1380
{copyout -},| {} we don't
|我们不想调用 walkaddr ，

2195
01:11:58,720 --> 01:11:59,740
0,150 150,420 420,750 750,930 930,1020
wanna call {walkaddr - -},|
|

2196
01:11:59,740 --> 01:12:00,850
0,390 390,450 450,690 690,1050 1050,1110
{walkaddr -} just produces a
walkaddr 只产生一个物理地址，

2197
01:12:00,850 --> 01:12:02,470
0,390 390,840 870,1170 1170,1410 1410,1620
physical address,| we actually want
|我们实际上需要页表条目，

2198
01:12:02,470 --> 01:12:04,120
0,90 90,450 450,780 780,1260 1350,1650
the page table entry,| because
|因为我们想要查看权限位，

2199
01:12:04,120 --> 01:12:04,960
0,120 120,300 300,360 360,750 750,840
we want to look at

2200
01:12:04,960 --> 01:12:06,520
0,90 90,570 570,1080 1110,1380 1380,1560
the permission bits,| to see
|查看它是否是写入时复制受保护的页面，

2201
01:12:06,520 --> 01:12:08,380
0,150 150,570 600,1020 1080,1500 1500,1860
if it's a {copy-on-write -

2202
01:12:08,560 --> 01:12:10,510
0,330 330,780 780,1410 1650,1830 1830,1950
-} protected page,| {so,we're} going
|所以我们将调用 walk 。

2203
01:12:10,510 --> 01:12:12,160
0,210 210,510 510,1200
to {call,walk} instead.|
|

2204
01:12:13,720 --> 01:12:15,680
0,930

2205
01:12:20,770 --> 01:12:22,480
0,330 330,480 480,930 1290,1590 1590,1710
We need to check all
我们需要检查所有常见的错误，

2206
01:12:22,480 --> 01:12:24,200
0,60 60,360 360,1170
the usual errors,|
|

2207
01:12:24,510 --> 01:12:25,650
0,210 210,480 480,720 720,840 840,1140
so maybe there's no mapping
所以可能根本就没有映射，

2208
01:12:25,650 --> 01:12:26,840
0,120 120,630
at all,|
|

2209
01:12:29,260 --> 01:12:30,310
0,510 510,720 720,840 840,990 990,1050
{} maybe it's not a
也许不是有效的映射，

2210
01:12:30,310 --> 01:12:31,920
0,330 330,1020
valid mapping,|
|

2211
01:12:33,450 --> 01:12:35,280
0,540 540,810 810,1140 1140,1380 1380,1830
or maybe it's a mapping
或者可能是用户代码不允许使用的映射，

2212
01:12:35,280 --> 01:12:37,050
0,240 240,690 720,1290 1290,1650 1650,1770
that the user code is

2213
01:12:37,050 --> 01:12:38,700
0,240 240,570 570,660 660,1140 1380,1650
not allowed to use,| in
|在所有这些情况下，这都是个错误，

2214
01:12:38,700 --> 01:12:40,800
0,120 120,330 330,930 960,1530
all those cases, {}

2215
01:12:40,950 --> 01:12:41,790
0,240 240,330 330,600 600,720 720,840
it's an error,| but this
|但这一次，我们可以返回一个错误，

2216
01:12:41,790 --> 01:12:42,750
0,150 150,210 210,330 330,570 570,960
time we can actually return

2217
01:12:42,750 --> 01:12:44,460
0,90 90,630 810,1050 1050,1440 1440,1710
an error,| actually call read
|调用 read 返回 -1 ，而不是终止进程，

2218
01:12:44,460 --> 01:12:45,570
0,90 90,420 420,660 660,870 870,1110
to return {-1 -} instead

2219
01:12:45,570 --> 01:12:47,010
0,90 90,390 390,450 450,1080 1110,1440
of killing the process,| that's
|那就好了。

2220
01:12:47,010 --> 01:12:48,320
0,450
nice.|
|

2221
01:12:48,440 --> 01:12:49,700
0,630

2222
01:12:50,690 --> 01:12:51,440
0,330 330,420 420,600 600,660 660,750
Next we need to know
接下来，我们需要知道如何检查它是否是写入时复制页面。

2223
01:12:51,440 --> 01:12:52,340
0,120 120,210 210,570 570,780 780,900
how to check whether it's

2224
01:12:52,340 --> 01:12:53,810
0,60 60,420 420,540 540,750 750,1470
a {copy-on-write - -} page.|
|

2225
01:12:54,080 --> 01:12:55,480
0,810
Any,
有没有什么想法可以让我们

2226
01:12:55,910 --> 01:12:56,900
0,210 210,510 510,630 630,840 840,990
any ideas for how we

2227
01:12:56,900 --> 01:12:58,280
0,300 300,780
can {}|
|

2228
01:12:59,340 --> 01:13:00,630
0,450 450,660 660,780 780,930 930,1290
check whether we should apply
检查我们是否应该复制，

2229
01:13:00,630 --> 01:13:01,650
0,450 450,690 690,810 810,900 900,1020
copy| whether we should do
|我们是否应该在这一点上进行复制。

2230
01:13:01,650 --> 01:13:03,270
0,90 90,660 690,870 870,1080 1080,1620
a copy at this point.|
|

2231
01:13:11,130 --> 01:13:12,690
0,390 390,660 660,960 960,1260 1260,1560
What's different about between {copy-on-write
写入时复制页面

2232
01:13:12,690 --> 01:13:13,650
0,90 90,240 240,630 630,780 780,960
- -} pages| and just
|和普通的非共享页面有什么不同？

2233
01:13:13,650 --> 01:13:14,850
0,150 150,360 360,780 780,930 930,1200
sort of ordinary {unshared -}

2234
01:13:14,850 --> 01:13:15,980
0,510
pages?|
|

2235
01:13:18,170 --> 01:13:19,400
0,240 240,300 300,750 750,1080 1080,1230
Would the reference count {to,be}
引用的数量会更大吗？

2236
01:13:19,400 --> 01:13:20,620
0,630
large?|
|

2237
01:13:21,000 --> 01:13:22,200
0,450 450,690 690,750 750,900 900,1200
Um, that's a good point,|
嗯，这是很好的观点，|

2238
01:13:22,200 --> 01:13:23,820
0,90 90,210 210,570 570,990 990,1620
if the reference count was
如果引用计数大于 1 ，

2239
01:13:23,880 --> 01:13:25,420
0,900
{}

2240
01:13:26,830 --> 01:13:28,390
0,420 420,540 540,930 930,1170 1170,1560
greater than one,| that's certainly
|这当然是一个非常好的线索，

2241
01:13:28,390 --> 01:13:31,450
0,210 360,1200 1200,1710 1710,2280 2820,3060
a very strong hint, {}|
|

2242
01:13:31,450 --> 01:13:32,380
0,240 240,300 300,630 630,780 780,930
that's a {copy-on-write - -}
那是一个写入时复制页面。

2243
01:13:32,380 --> 01:13:33,660
0,780
page.|
|

2244
01:13:33,900 --> 01:13:35,370
0,660 690,840 840,930 930,1230 1230,1470
But if the reference count
但是，如果引用计数为 1 ，

2245
01:13:35,370 --> 01:13:36,750
0,60 60,720 990,1110 1110,1260 1260,1380
is one,| does that mean
|是否意味着它不是写入时复制页面。

2246
01:13:36,750 --> 01:13:38,700
0,180 180,690 690,780 780,1350 1350,1950
it's not a copy-on-write page.|
|

2247
01:13:45,900 --> 01:13:46,560
0,150 150,360 360,450 450,540 540,660
It turns out if you
如果你 fork 了，子进程出现写入时复制错误，

2248
01:13:46,560 --> 01:13:47,700
0,390 390,480 480,540 540,960 960,1140
fork and the child takes

2249
01:13:47,700 --> 01:13:48,930
0,60 60,390 390,510 510,720 720,1230
a {copy-on-write - -} fault|
|

2250
01:13:48,930 --> 01:13:50,580
0,120 120,330 330,390 390,1020 1200,1650
and makes a copy that
做了复制，将引用计数减少到 1 ，

2251
01:13:50,580 --> 01:13:52,440
0,540 540,840 1230,1590 1590,1800 1800,1860
reduces the reference count to

2252
01:13:52,440 --> 01:13:54,150
0,660 1080,1350 1350,1410 1410,1620 1620,1710
one,| but the page is
|但是该页在父进程中仍然是写保护的。

2253
01:13:54,150 --> 01:13:55,200
0,240 240,450 450,900 900,990 990,1050
still write protected in the

2254
01:13:55,200 --> 01:13:56,320
0,600
parent.|
|

2255
01:13:56,620 --> 01:13:57,820
0,600

2256
01:13:59,550 --> 01:14:01,620
0,270 270,540 540,1140
And actually probably
在这种情况下，我们也许可以不受影响地进行修改，

2257
01:14:01,910 --> 01:14:03,260
0,390 390,660 660,840 840,1170 1170,1350
we could get away with

2258
01:14:03,260 --> 01:14:04,700
0,540 540,630 630,810 810,1290 1320,1440
modifying in that case,| so
|所以我想我们可以检查一下引用数量，

2259
01:14:04,700 --> 01:14:05,540
0,30 30,180 180,270 270,510 510,840
I think we actually could

2260
01:14:05,540 --> 01:14:07,140
0,420 420,780
check the

2261
01:14:07,710 --> 01:14:09,100
0,450 450,840
reference count,|
|

2262
01:14:09,980 --> 01:14:11,660
0,270 270,780 780,1260 1260,1440 1440,1680
and only treated as a
并且仅被视为写入时复制页面，

2263
01:14:11,660 --> 01:14:13,100
0,360 390,960 960,1260 1260,1350 1350,1440
{} copy-on-write page,| if the
|如果引用计数大于零，

2264
01:14:13,100 --> 01:14:14,510
0,300 300,570 570,810 810,930 930,1410
reference count greater than zero,|
|

2265
01:14:14,690 --> 01:14:15,680
0,300 300,420 420,570 570,780 780,990
but what I'm gonna do
但是我要做的是不同的，甚至更容易的捷径，

2266
01:14:15,680 --> 01:14:18,110
0,120 120,210 210,750 750,1170 1920,2430
is {} different, {} even

2267
01:14:18,110 --> 01:14:20,840
0,270 270,900 1740,1950 1950,2370 2490,2730
easier shortcut| and say if
|如果页面是写保护的，

2268
01:14:20,840 --> 01:14:22,100
0,90 90,300 300,420 420,630 630,1260
the page is write protected,|
|

2269
01:14:22,310 --> 01:14:23,900
0,690 870,1110 1110,1320 1320,1500 1500,1590
{} the only way a
那么页面可以被写保护的唯一方式，

2270
01:14:23,900 --> 01:14:25,460
0,330 330,420 420,570 570,810 810,1560
page can be write protected|
|

2271
01:14:25,610 --> 01:14:27,020
0,420 420,570 570,690 690,1200 1200,1410
and have the {PTE_U -}
并且设置了 PTE_U 位，

2272
01:14:27,020 --> 01:14:28,220
0,270 270,780
bit set,|
|

2273
01:14:28,460 --> 01:14:30,080
0,720 810,1050 1050,1260 1260,1530 1530,1620
{} in this version of
在这个版本的 xv6 中，它是写入时复制页面。

2274
01:14:30,080 --> 01:14:31,160
0,180 180,330 330,810 840,990 990,1080
{xv6 - -} is {}

2275
01:14:31,160 --> 01:14:31,940
0,120 120,180 180,510 510,600 600,780
it's a {copy-on-write - -}

2276
01:14:31,940 --> 01:14:33,040
0,600
page.|
|

2277
01:14:33,750 --> 01:14:35,060
0,750

2278
01:14:35,170 --> 01:14:36,190
0,270 270,420 420,570 570,960 960,1020
So this has saved me
因此，与检查引用计数相比，这为我节省了一点打字时间，

2279
01:14:36,190 --> 01:14:36,940
0,60 60,210 210,330 330,390 390,750
a little bit of typing

2280
01:14:36,940 --> 01:14:38,110
0,360 360,420 420,720 720,810 810,1170
compared to checking the reference

2281
01:14:38,110 --> 01:14:39,700
0,360 690,990 990,1230 1230,1500 1500,1590
count,| we already wrote the
|我们已经在 trap.c 中编写了处理此问题的代码。

2282
01:14:39,700 --> 01:14:41,200
0,570 570,660 660,900 900,1050 1050,1500
code to deal with this

2283
01:14:41,200 --> 01:14:43,360
0,450 480,900 900,1170 1170,1590
in {trap.c - -}.|
|

2284
01:14:46,180 --> 01:14:47,230
0,300 300,450 450,570 570,720 720,1050
{} So I'm just gonna
所以我就从这里调用那个代码。

2285
01:14:47,840 --> 01:14:49,070
0,270 270,450 450,720 720,840 840,1230
call that code from here.|
|

2286
01:14:51,840 --> 01:14:52,920
0,120 120,540 540,660 660,780 780,1080
We still have to deal
我们仍然需要处理可能的错误返回，

2287
01:14:52,920 --> 01:14:54,900
0,150 150,810 960,1350 1350,1560 1560,1980
with the possible error return,|
|

2288
01:14:54,900 --> 01:14:56,040
0,90 90,270 270,630
if it's a,
如果是个疯狂的地址。

2289
01:14:56,130 --> 01:14:57,340
0,660
{}

2290
01:14:58,760 --> 01:15:00,700
0,240 240,570 570,1380
a crazy address.|
|

2291
01:15:00,700 --> 01:15:02,160
0,150 150,420 420,510 510,900
Oh, actually, we don't.|
哦，事实上，我们没有。|

2292
01:15:11,880 --> 01:15:13,140
0,750
Alright.|
好的。|

2293
01:15:15,000 --> 01:15:17,380
0,510 510,690 690,810 810,1710
Alright, so the pages
好的，所以页面不能写入，

2294
01:15:17,470 --> 01:15:18,370
0,330 330,480 480,600 600,810 810,900
not write at all,| we're
|我们会调用 cowfault ，

2295
01:15:18,370 --> 01:15:19,570
0,180 180,330 330,510 660,1110 1110,1200
just going to {copy-on-write -

2296
01:15:19,570 --> 01:15:21,250
0,180 180,510 660,870 870,1380 1380,1680
-} fault| and copy-on-write fault
|并且 cowfault 会复制并设置页面可写，

2297
01:15:21,250 --> 01:15:22,900
0,270 270,330 330,810 840,1560 1560,1650
does the copy and it

2298
01:15:22,900 --> 01:15:25,720
0,210 210,300 300,570 570,1080 2310,2820
makes the page writable,| so
|所以我想我们在这一点上就快做完了，

2299
01:15:25,810 --> 01:15:27,220
0,180 180,420 420,870
I think we're,

2300
01:15:27,480 --> 01:15:28,700
0,510
{}

2301
01:15:28,900 --> 01:15:29,710
0,150 150,420 420,540 540,630 630,810
we're almost done at this

2302
01:15:29,710 --> 01:15:32,950
0,390 630,1230 1260,2130 2670,2880 2880,3240
point,| {} however if copyin,|
|然而，如果 copyin ，|

2303
01:15:32,950 --> 01:15:34,630
0,180 180,570 570,840 840,1320 1320,1680
if {cowfault - -} did
如果 cowfault 没有产生一个。

2304
01:15:34,630 --> 01:15:36,760
0,360 360,1320
make a.|
|

2305
01:15:37,430 --> 01:15:39,340
0,1290

2306
01:15:42,310 --> 01:15:44,170
0,180 180,600 1110,1380 1380,1590 1590,1860
{We,gonna,get,rid,of} this.| If {cowfault -
我们删除这个。|如果 cowfault 制作了复制，

2307
01:15:44,170 --> 01:15:45,820
0,360 360,810 1050,1260 1260,1320 1320,1650
-} did make a copy,|
|

2308
01:15:45,820 --> 01:15:47,440
0,120 120,240 240,360 360,1290 1380,1620
it's going to modify the
它将修改页表条目中的物理地址，

2309
01:15:47,440 --> 01:15:48,610
0,360 360,720 720,810 810,870 870,1170
physical address in the page

2310
01:15:48,610 --> 01:15:49,780
0,330 330,720 870,1020 1020,1080 1080,1170
table entry,| so we have
|因此我们必须再次从页表条目中取出物理地址，

2311
01:15:49,780 --> 01:15:51,250
0,90 90,390 390,570 570,900 900,1470
to pull that physical address

2312
01:15:51,250 --> 01:15:52,090
0,150 150,210 210,300 300,570 570,840
out of the page table

2313
01:15:52,090 --> 01:15:53,050
0,240 240,600 600,690 690,870 870,960
entry again,| in case it
|防止它被修改，

2314
01:15:53,050 --> 01:15:54,610
0,150 150,720 930,1260 1260,1410 1410,1560
was changed,| I'm just gonna
|我正要这么做，

2315
01:15:54,610 --> 01:15:55,750
0,180 180,510 510,720 720,810 810,1140
do that,| since we have
|我们这里有页表条目。

2316
01:15:55,750 --> 01:15:56,780
0,240 240,510
the {}

2317
01:15:59,270 --> 01:16:00,770
0,330 330,570 570,780 780,990 990,1500
page table entry right here.|
|

2318
01:16:02,420 --> 01:16:05,210
0,810 1170,2190 2220,2520 2520,2700 2700,2790
And I think this is
我认为这或多或少已经足够了。

2319
01:16:05,210 --> 01:16:06,940
0,180 180,210 210,450 450,1110
more or less enough.|
|

2320
01:16:07,590 --> 01:16:09,330
0,240 240,600 600,750 750,1170 1170,1740
So, any any questions about
那么，关于 copyout 的修改，有什么问题吗？

2321
01:16:10,170 --> 01:16:12,630
0,120 120,960 960,1440 1440,1920 1920,2460
the modification to {copyout -}?|
|

2322
01:16:15,940 --> 01:16:16,960
0,240 240,300 300,480 480,660 660,1020
Alright I got to {}
好的，我要做一个 cowfault 的全局声明。

2323
01:16:18,070 --> 01:16:19,780
0,180 180,240 240,570 570,1290 1290,1710
make a global declaration for

2324
01:16:19,780 --> 01:16:21,700
0,360 360,630 630,1020
{cowfault - -}.|
|

2325
01:16:25,820 --> 01:16:27,760
0,1350

2326
01:16:37,190 --> 01:16:38,360
0,630
{Ah,beautiful}.|
漂亮。|

2327
01:16:43,870 --> 01:16:46,480
0,300 300,510 510,690 690,1290 2070,2610
Alright, that's looking great. {}|
好的，看起来不错。|

2328
01:16:46,510 --> 01:16:47,380
0,360 360,600 600,660 660,780 780,870
Anybody happen to know if
有没有人知道我们已经完成了。

2329
01:16:47,380 --> 01:16:49,460
0,90 90,540
we're done.|
|

2330
01:16:52,750 --> 01:16:53,900
0,720

2331
01:16:57,820 --> 01:16:58,960
0,120 120,270 270,630 630,840 840,1140
We may {or,not} be,| we
完成或没有，|我们还必须通过 usertests 。

2332
01:16:58,960 --> 01:17:00,040
0,270 270,360 360,480 480,810 810,1080
also have to pass {usertests

2333
01:17:00,040 --> 01:17:01,360
0,750
-}.|
|

2334
01:17:02,680 --> 01:17:03,700
0,360 420,720 720,810 810,870 870,1020
Oh, alright, let me get
哦，好的，让我删掉这些输出语句。

2335
01:17:03,700 --> 01:17:05,480
0,120 120,210 210,600
rid of this

2336
01:17:06,780 --> 01:17:08,580
0,390 390,1170
print statements.|
|

2337
01:17:25,540 --> 01:17:26,830
0,210 210,690 690,810 810,1170 1170,1290
I think the {execout -}
我认为 execout 测试故意分配了大量内存。

2338
01:17:26,830 --> 01:17:29,050
0,420 420,1410 1560,2010 2010,2070 2070,2220
test intentionally allocates a lot

2339
01:17:29,050 --> 01:17:30,140
0,60 60,540
of memory.|
|

2340
01:17:33,260 --> 01:17:34,640
0,330 330,480 480,900 900,1140 1140,1380
Alright, any questions, while we
好的，在我们等待用户测试结果的同时，有任何问题吗？

2341
01:17:34,640 --> 01:17:35,720
0,510
{}

2342
01:17:36,790 --> 01:17:38,170
0,330 330,570 570,690 690,990 1020,1380
{} wait for the verdict

2343
01:17:38,170 --> 01:17:39,700
0,150 150,420 420,960
from {usertests -}.|
|

2344
01:17:44,140 --> 01:17:45,340
0,270 270,480 480,690 690,780 780,1200
Oh, {usertests -} was unhappy,|
哦， usertests 不开心，|

2345
01:17:45,340 --> 01:17:45,940
0,60 60,240 240,390 390,510 510,600
I think this is a
我想这是一块熟悉的破损，

2346
01:17:45,940 --> 01:17:48,610
0,1140 1200,1470 1470,1560 1560,2190 2190,2670
familiar piece of damage| which
|有人已经提出来了，

2347
01:17:48,700 --> 01:17:50,260
0,600 600,810 810,930 930,1350 1350,1560
somebody's brought up already,| it's
|这是 walk 中的 panic ，

2348
01:17:50,260 --> 01:17:52,080
0,240 420,1200
{ -},

2349
01:17:55,160 --> 01:17:56,720
0,300 300,420 420,780 780,930 930,1560
it's the panic at walk|
|

2350
01:17:57,020 --> 01:17:58,070
0,300 300,420 420,660 660,1050 1050,1050
if the user process, {}|
如果用户进程，|

2351
01:17:58,070 --> 01:17:59,540
0,390 390,660 660,1050 1110,1230 1230,1470
{usertests -} actually I think
usertest 我认为是故意做的。

2352
01:17:59,540 --> 01:18:02,030
0,630 720,1920 2070,2280 2280,2460 2460,2490
does intentionally.| We'll take a
|我们看看 usertests 。

2353
01:18:02,030 --> 01:18:04,340
0,150 150,240 240,480 480,1050 1410,2310
look at {usertests -}. {}|
|

2354
01:18:09,540 --> 01:18:10,770
0,240 240,450 450,660 660,1080 1080,1230
And it's the {copyout -}
这是 copyout 测试，

2355
01:18:10,770 --> 01:18:12,120
0,780
test,|
|

2356
01:18:14,090 --> 01:18:15,620
0,780 840,1110 1110,1380 1380,1470 1470,1530
and even says in the
甚至在它的评论中说，

2357
01:18:15,620 --> 01:18:17,390
0,330 330,420 420,810 810,1350 1350,1770
comment,| it passes ridiculous pointers
|它将荒谬的指针传递给系统调用。

2358
01:18:17,390 --> 01:18:19,250
0,90 90,420 420,990 1290,1710 1710,1860
to system call.| Alright, so
|好的，那么我们面临的是 copyout ，

2359
01:18:19,250 --> 01:18:20,330
0,120 120,210 210,540 540,750 750,1080
what we're faced with is

2360
01:18:20,540 --> 01:18:23,560
0,570 570,1110 1470,2430
{copyout -}, {}|
|

2361
01:18:23,560 --> 01:18:24,640
0,150 150,450 450,540 540,630 630,1080
we pass in a ridiculous
我们传入一个荒谬的指针，

2362
01:18:24,640 --> 01:18:25,840
0,270 270,420 420,570 570,840 840,1200
{pointer -},| it's simply called
|使用那个荒谬的指针调用 walk ，

2363
01:18:25,840 --> 01:18:27,610
0,510 540,660 660,840 840,1260 1260,1770
walk with that ridiculous pointer|
|

2364
01:18:28,060 --> 01:18:30,910
0,420 420,990 1320,1920 2010,2730 2730,2850
{} and walk panics,| if
然后 walk panic 了，|如果你给它一个荒谬的指针。

2365
01:18:30,910 --> 01:18:31,660
0,90 90,210 210,300 300,360 360,750
you give it a ridiculous

2366
01:18:31,660 --> 01:18:33,300
0,240 240,390 450,1080
{pointer -}.| So,
|所以，就像有人提到的，

2367
01:18:33,300 --> 01:18:34,560
0,630
{}

2368
01:18:35,030 --> 01:18:37,310
0,330 330,600 600,1320 1650,2010 2010,2280
as somebody mentioned,| we need
|我们不能用荒谬的指针来调用 walk ，

2369
01:18:37,310 --> 01:18:40,130
0,780 810,1230 1230,1470 1470,2130 2280,2820
to not call walk with

2370
01:18:40,160 --> 01:18:41,700
0,390 390,1050
ridiculous pointers,|
|

2371
01:18:42,970 --> 01:18:43,810
0,180 180,270 270,330 330,660 660,840
what is it, {MAXVA -
是什么， MAXVA 还是什么。

2372
01:18:43,810 --> 01:18:45,200
0,210 210,270 270,720
-} or something.|
|

2373
01:18:46,440 --> 01:18:47,420
0,540
Alright.|
好的。|

2374
01:18:47,570 --> 01:18:49,550
0,150 150,480 480,690 930,1380 1380,1980
Of course, we're totally entitled
当然，我们完全有权返回错误

2375
01:18:49,550 --> 01:18:51,590
0,240 240,600 1110,1500 1500,1620 1620,2040
to {} return an error|
|

2376
01:18:51,590 --> 01:18:53,340
0,90 90,210 210,480 480,1260
if the user process
如果用户进程传递这个超出的指针。

2377
01:18:53,930 --> 01:18:55,700
0,360 390,720 720,960 960,960 1590,1770
{} pass this {outbound -

2378
01:18:55,700 --> 01:18:56,940
0,90 90,360 360,600
- -} pointer.|
|

2379
01:19:00,050 --> 01:19:01,730
0,330 330,630 750,1050 1050,1320 1320,1680
Alright, {} I'm just hoping
好的，我希望现在可以通过。

2380
01:19:01,730 --> 01:19:03,360
0,120 120,510 510,1170
it passes now.|
|

2381
01:19:05,090 --> 01:19:05,840
0,120 120,270 270,480 480,570 570,750
I'm not aware of any
我没有发现任何其他问题。

2382
01:19:05,840 --> 01:19:07,460
0,150 150,870
other problems.|
|

2383
01:19:09,600 --> 01:19:11,940
0,510
Okay,
好了，有什么问题。

2384
01:19:12,340 --> 01:19:13,680
0,810
questions.|
|

2385
01:19:16,490 --> 01:19:17,810
0,240 240,330 330,540 540,840 840,1320
{} I guess my question
我想我的问题更宽泛，

2386
01:19:17,810 --> 01:19:20,270
0,180 180,690 720,1380 1770,2310 2310,2460
is more broad,| like we
|当我们用小步走的时候，

2387
01:19:20,270 --> 01:19:22,160
0,360 360,720 1230,1590 1590,1740 1740,1890
saw when {} we were

2388
01:19:22,160 --> 01:19:23,870
0,300 300,480 480,690 690,1050 1050,1710
doing that with small steps,|
|

2389
01:19:23,960 --> 01:19:27,280
0,420 420,1080 1320,2100 2130,2940
we're getting random bugs
我们在这里得到了随机的其他的 bug ，

2390
01:19:27,280 --> 01:19:29,350
0,300 330,420 450,990 990,1230 1440,2070
at this point that others

2391
01:19:29,350 --> 01:19:30,940
0,360 420,780 780,1050 1050,1290 1290,1590
have,| and if we're doing
|如果我们从头开始做实验，

2392
01:19:30,940 --> 01:19:33,490
0,120 120,660 720,1080 1080,1830 1860,2550
the lab from scratch,| then
|那么有那么多奇怪的 bug 不会让人迷惑吗，

2393
01:19:34,170 --> 01:19:35,430
0,300 300,360 360,450 450,1140 1140,1260
wouldn't it be confusing to

2394
01:19:35,430 --> 01:19:37,050
0,180 180,330 330,420 420,930 1080,1620
get all of those weird

2395
01:19:37,050 --> 01:19:38,300
0,930
bugs,|
|

2396
01:19:38,720 --> 01:19:41,090
0,510 990,1320 1320,1920 2010,2250 2250,2370
and how would how would
你怎么，

2397
01:19:41,090 --> 01:19:42,000
0,360
you,|
|

2398
01:19:42,000 --> 01:19:43,290
0,150 150,240 240,420 420,780 780,1290
how do you know whether
你怎么知道是不是你写的东西有 bug ，

2399
01:19:43,290 --> 01:19:44,430
0,180 180,480 480,630 630,990 990,1140
it's bug with something you

2400
01:19:44,430 --> 01:19:46,440
0,420 450,990 1170,1500 1500,1800 1800,2010
wrote| or {a,bug} because you
|或者你没有，而是其余部分的 bug 。

2401
01:19:46,440 --> 01:19:47,610
0,270 270,660 660,750 750,1080 1080,1170
didn't write the rest of

2402
01:19:47,610 --> 01:19:48,480
0,330
it.|
|

2403
01:19:48,540 --> 01:19:49,740
0,330 330,570 570,630 630,990 990,1200
I'm afraid I cannot answer
我想我不能回答你的问题。

2404
01:19:49,740 --> 01:19:50,840
0,90 90,570
your question.|
|

2405
01:19:50,840 --> 01:19:51,980
0,510

2406
01:19:51,980 --> 01:19:53,390
0,270 270,480 480,600 600,1110 1110,1410
The {} the sad truth
关于 bug 的可悲事实，

2407
01:19:53,390 --> 01:19:55,550
0,270 270,720 720,1380 1380,1800 1800,2160
about bugs,| particularly bugs caused
|特别是对内核页面表做了一些有趣的事情而导致的错误，

2408
01:19:55,550 --> 01:19:56,690
0,90 90,360 360,690 690,1050 1050,1140
by doing funny things to

2409
01:19:56,690 --> 01:19:58,430
0,270 270,930 930,1200 1200,1290 1290,1740
page tables inside the kernel,|
|

2410
01:19:58,850 --> 01:20:00,440
0,300 300,450 450,570 570,810 810,1590
{} is that every bug,
就是每个 bug 都是不同的。

2411
01:20:02,110 --> 01:20:03,040
0,300 300,390 390,630 630,810 810,930
you know every bug is

2412
01:20:03,040 --> 01:20:04,280
0,660
different.|
|

2413
01:20:04,500 --> 01:20:05,730
0,180 180,360 360,750 810,990 990,1230
And how you know what
什么才是追踪漏洞的制胜策略，

2414
01:20:05,730 --> 01:20:06,810
0,390 390,690 690,780 780,960 960,1080
turns out to be the

2415
01:20:06,810 --> 01:20:08,520
0,360 360,1080 1080,1200 1200,1650 1650,1710
winning strategy for tracking a

2416
01:20:08,520 --> 01:20:10,120
0,240 240,900
bug down,|
|

2417
01:20:10,540 --> 01:20:12,070
0,150 150,360 360,960 960,1440 1440,1530
it just depends totally on
这完全取决于 bug 的本质。

2418
01:20:12,070 --> 01:20:13,180
0,90 90,420 420,480 480,570 570,1110
the nature of the bug.|
|

2419
01:20:14,030 --> 01:20:15,240
0,480

2420
01:20:15,330 --> 01:20:16,980
0,360 360,1200 1290,1470 1470,1560 1560,1650
My usual,| {} you know
通常，|我不是，

2421
01:20:16,980 --> 01:20:18,040
0,210 210,420
I'm not,|
|

2422
01:20:18,040 --> 01:20:20,020
0,120 120,300 300,570 570,1440 1830,1980
{} I have some,| I
我有一些，|我有一些策略，

2423
01:20:20,020 --> 01:20:21,610
0,120 120,420 420,810 810,900 900,1590
have a collection of strategies|
|

2424
01:20:21,610 --> 01:20:23,740
0,270 360,660 660,1110 1110,1770 1800,2130
that are sometimes helpful and
有时有用，有时没用，

2425
01:20:23,740 --> 01:20:25,160
0,450 450,840
sometimes not,|
|

2426
01:20:25,160 --> 01:20:26,360
0,150 150,330 330,540 540,900 900,1200
like I'm a huge believer,|
比如我坚信，|

2427
01:20:26,360 --> 01:20:27,620
0,90 90,330 330,570 570,1080 1080,1260
I'm putting print statements into
我将打印语句放入代码中，

2428
01:20:27,620 --> 01:20:28,580
0,90 90,540 540,630 630,870 870,960
the code| in order to
|以便收集信息或验证假设。

2429
01:20:28,580 --> 01:20:31,070
0,330 330,1170 1710,1860 1860,1920 1920,2490
gather information or to verify

2430
01:20:31,070 --> 01:20:32,760
0,1200
hypotheses.|
|

2431
01:20:32,760 --> 01:20:34,000
0,660

2432
01:20:34,720 --> 01:20:36,160
0,390 390,690 690,990 990,1230 1230,1440
I'll often spend time just
我经常会花时间看看代码，

2433
01:20:36,160 --> 01:20:37,690
0,210 210,300 300,360 360,1080 1200,1530
looking at the code,| just
|只是为了给自己来点头脑风暴，

2434
01:20:37,690 --> 01:20:39,550
0,90 90,210 210,570 570,720 720,1860
for the purpose of generating

2435
01:20:40,210 --> 01:20:41,650
0,180 180,240 240,960 960,1080 1080,1440
sort of brainstorming with myself,|
|

2436
01:20:41,650 --> 01:20:42,910
0,300 300,450 450,510 510,1170 1170,1260
just try to generate you
试着生成一些东西，

2437
01:20:42,910 --> 01:20:44,410
0,240 270,600 600,720 720,930 930,1500
know things| that could possibly
|在这一点上可能出错的东西，

2438
01:20:44,410 --> 01:20:45,370
0,120 120,390 390,660 660,750 750,960
be going wrong at this

2439
01:20:45,370 --> 01:20:47,080
0,480 960,1140 1140,1260 1260,1500 1500,1710
point,| and then put print
|然后将打印语句放到[] panic 或其他地方，

2440
01:20:47,080 --> 01:20:48,220
0,450 450,540 540,630 630,1080 1080,1140
statements in [] panics or

2441
01:20:48,220 --> 01:20:49,940
0,480 480,600 600,870 870,1200
something| to try to
|试图排除各种猜测问题可能是什么东西。

2442
01:20:50,200 --> 01:20:51,880
0,540 570,1080 1080,1260 1260,1380 1380,1680
{} rule in and rule

2443
01:20:51,880 --> 01:20:54,310
0,360 780,1260 1260,2160 2190,2310 2310,2430
out various guesses at what

2444
01:20:54,310 --> 01:20:55,800
0,60 60,360 360,600 600,960
the problem might be.|
|

2445
01:20:55,890 --> 01:20:57,480
0,240 240,510 510,1200 1200,1320 1320,1590
{} Another possibility is that|
另一种可能是，|

2446
01:20:57,810 --> 01:20:59,550
0,420 420,510 510,1050 1140,1440 1440,1740
you know you've made some
你做了一些，你的代码起作用了，

2447
01:20:59,550 --> 01:21:00,690
0,60 60,150 150,510 510,750 750,1140
you know your code worked|
|

2448
01:21:00,690 --> 01:21:01,860
0,60 60,360 360,660 660,840 840,1170
or didn't show this error
或者没有显示这个错误之类的，

2449
01:21:01,860 --> 01:21:03,600
0,90 90,720 990,1200 1200,1410 1470,1740
or something,| you know half
|你知道半小时前你做了一些改变，

2450
01:21:03,600 --> 01:21:04,380
0,90 90,270 270,570 570,690 690,780
an hour ago and you

2451
01:21:04,380 --> 01:21:05,280
0,180 180,300 300,720 720,810 810,900
made some changes,| and now
|现在你有了一些 bug ，

2452
01:21:05,280 --> 01:21:06,660
0,120 120,240 240,390 390,900 1080,1380
you have some bug,| another
|另一种可能性是，

2453
01:21:06,660 --> 01:21:08,100
0,690 690,900 900,1050 1050,1320 1320,1440
possibility is| to if you
|你可以返回到没有错误的代码版本，

2454
01:21:08,100 --> 01:21:09,440
0,720
can,

2455
01:21:09,440 --> 01:21:10,640
0,120 120,360 360,750 750,1080 1080,1200
you know back up to

2456
01:21:10,640 --> 01:21:11,390
0,90 90,360 360,420 420,510 510,750
a version of the code

2457
01:21:11,390 --> 01:21:12,230
0,90 90,300 300,420 420,510 510,840
that didn't have the bug|
|

2458
01:21:12,230 --> 01:21:13,100
0,120 120,300 300,450 450,750 750,870
and sort of add your
然后一点一点地添加更改，直到错误出现。

2459
01:21:13,100 --> 01:21:14,330
0,390 390,540 540,690 690,960 990,1230
changes bit by bit until

2460
01:21:14,330 --> 01:21:15,600
0,90 90,300 300,570 570,720
the bug shows up.|
|

2461
01:21:16,560 --> 01:21:17,820
0,240 240,600 600,1020 1050,1170 1170,1260
Now, these are,| I don't
现在，这些都是，|我不知道有什么策略总是奏效的，

2462
01:21:17,820 --> 01:21:19,200
0,180 180,780
know any

2463
01:21:19,350 --> 01:21:20,730
0,570 570,690 690,990 990,1290 1290,1380
strategy that always works| or
|或者甚至有超过一小部分的时间在工作。

2464
01:21:20,730 --> 01:21:21,450
0,180 180,390 390,540 540,660 660,720
even works more than a

2465
01:21:21,450 --> 01:21:22,820
0,330 330,390 390,450 450,780
fraction of the time.|
|

2466
01:21:25,260 --> 01:21:26,250
0,360 360,420 420,660 660,810 810,990
But the truth is part
但真相是你们在这堂课上学到的东西的一部分，

2467
01:21:26,250 --> 01:21:27,330
0,60 60,180 180,300 300,810 810,1080
of what you're learning in

2468
01:21:27,330 --> 01:21:28,680
0,150 150,930 960,1080 1080,1230 1230,1350
this class| as well as
|在学习操作系统的同时，

2469
01:21:28,680 --> 01:21:30,750
0,210 210,390 390,750 750,1380 1950,2070
learning about operating systems,| you
|你正在获得编写和调试代码的经验。

2470
01:21:30,750 --> 01:21:33,030
0,60 60,510 570,810 810,1800 1950,2280
know you're getting experience writing

2471
01:21:33,030 --> 01:21:34,520
0,90 90,480 480,930
and debugging code.|
|

2472
01:21:37,860 --> 01:21:38,640
0,330 330,480 480,570 570,660 660,780
Sorry, not to be more
抱歉，没有更多的帮助。

2473
01:21:38,640 --> 01:21:40,360
0,420
helpful.|
|

2474
01:21:40,440 --> 01:21:41,700
0,690

2475
01:21:42,950 --> 01:21:44,400
0,210 210,900
Other questions?|
还有其他问题吗？|

2476
01:21:52,650 --> 01:21:54,960
0,780 870,1530
Alright {},
好了，我们快下课了。

2477
01:21:54,960 --> 01:21:56,160
0,210 210,330 330,600 840,1110 1110,1200
we're at the end of

2478
01:21:56,160 --> 01:21:58,360
0,450 450,1470
class time.|
|

2479
01:21:58,840 --> 01:22:00,020
0,600

2480
01:22:00,580 --> 01:22:01,900
0,180 180,420 420,540 540,810 810,1320
I'm happy to talk more,|
我很乐意多说几句，|

2481
01:22:02,790 --> 01:22:04,680
0,660 780,1050 1110,1440 1470,1770 1770,1890
{} but we're done with
但是这节课的正式部分我们已经讲完了。

2482
01:22:04,680 --> 01:22:05,940
0,90 90,750 810,1050 1050,1110 1110,1260
the formal part of this

2483
01:22:05,940 --> 01:22:07,020
0,540
class.|
|

2484
01:22:10,930 --> 01:22:12,790
0,540 990,1110 1110,1230 1230,1710 1710,1860
Alright and to see you
好的，我们星期三见。

2485
01:22:12,790 --> 01:22:14,760
0,540 540,750 750,1530
all on Wednesday.|
|

2486
01:22:15,390 --> 01:22:16,290
0,210 210,420 420,480 480,780 780,900
Oh, sorry I actually have
哦，抱歉，我还有另一个问题，

2487
01:22:16,290 --> 01:22:18,120
0,300 300,870 900,1290 1290,1410 1410,1830
another question,| when we were
|当我们第一次看到写入错误时，

2488
01:22:18,150 --> 01:22:21,060
0,390 390,870 870,1440 1470,2250 2460,2910
{} seeing our first {}

2489
01:22:21,940 --> 01:22:25,240
0,480 960,1650 1680,2400 2520,2910 2910,3300
{} write fault,| we also
|之后我们也看到了对于 shell 非法指令的错误，

2490
01:22:25,240 --> 01:22:27,400
0,510 540,990 990,1260 1260,1770 1830,2160
saw after that for the

2491
01:22:27,400 --> 01:22:30,430
0,720 780,1470 1470,1950 1950,2520 2700,3030
shell illegal instruction fault| and
|然后是初始化过程的一些东西，

2492
01:22:30,430 --> 01:22:32,020
0,120 120,510 510,1050 1080,1290 1290,1590
then something for the init

2493
01:22:32,020 --> 01:22:33,260
0,840
process,|
|

2494
01:22:33,510 --> 01:22:34,920
0,210 210,390 390,810
what was that.|
那是什么。|

2495
01:22:37,430 --> 01:22:38,540
0,420

2496
01:22:39,620 --> 01:22:41,920
0,840 1140,1770
{} Well,
好的，我没有一个想法。

2497
01:22:45,000 --> 01:22:46,860
0,1230
{}

2498
01:22:47,430 --> 01:22:48,480
0,180 180,330 330,420 420,510 510,1050
I don't have a theory.|
|

2499
01:22:48,600 --> 01:22:50,560
0,390 390,1320
Init process,
初始化进程，我认为不会与任何东西共享页面。

2500
01:22:51,150 --> 01:22:52,500
0,210 210,480 480,750 750,930 930,1350
I don't think would share

2501
01:22:52,500 --> 01:22:54,300
0,420 420,540 540,1200
pages with anything.|
|

2502
01:22:55,090 --> 01:22:56,350
0,450 450,600 600,810 810,960 960,1260
I I just don't know,
我只是不知道，很抱歉。

2503
01:22:56,620 --> 01:22:58,040
0,450 450,840
I'm sorry.|
|

2504
01:22:58,070 --> 01:22:59,600
0,120 120,450 450,450
We could. {}|
我们可以。|

2505
01:22:59,910 --> 01:23:01,860
0,270 270,1290

2506
01:23:01,890 --> 01:23:02,580
0,120 120,210 210,300 300,420 420,690
I would have to back
我不得不后退一步，

2507
01:23:02,580 --> 01:23:04,050
0,210 210,630 630,960 960,1230 1230,1470
up,| this happened very early,|
|这发生得很早，|

2508
01:23:04,050 --> 01:23:04,620
0,120 120,180 180,300 300,480 480,570
when I was doing the
当我做实验的时候，

2509
01:23:04,620 --> 01:23:05,790
0,660 690,810 810,1020 1020,1110 1110,1170
lab,| we just had to
|我们只需要复制页表，其他什么都不用。

2510
01:23:05,790 --> 01:23:06,930
0,300 300,390 390,630 630,870 870,1140
copy the page table, nothing

2511
01:23:06,930 --> 01:23:08,440
0,480 480,990
else.| Yeah.|
|是的。|

2512
01:23:08,440 --> 01:23:10,150
0,180 180,390 390,510 510,960 1320,1710
I think it was, {}
我想它是，比如 scause f 对于 shell ，

2513
01:23:10,150 --> 01:23:12,280
0,360 390,600 600,1110 1110,1470 1470,2130
like {} scause f for

2514
01:23:12,370 --> 01:23:14,410
0,240 240,930 1050,1650 1650,1740 1740,2040
the shell| and I think
|我想可能是 scause c 对于 init 进程。

2515
01:23:14,440 --> 01:23:17,500
0,270 270,1470 1770,2520
scause c for

2516
01:23:17,740 --> 01:23:21,400
0,600 810,1230 1230,2310 2340,2910
the init process, maybe.|
|

2517
01:23:21,810 --> 01:23:23,190
0,390 390,540 540,720 720,1140 1140,1380
Alright, let me let's see,|
好的，让我看看，|

2518
01:23:23,190 --> 01:23:24,870
0,360 360,480 480,870 900,1230 1260,1680
if you really, let's let's
如果你是对的，让我们来看看，我们可以。

2519
01:23:25,110 --> 01:23:28,380
0,1440 1620,1890 1890,2250 2250,2250
{} we can {}.|
|

2520
01:23:32,270 --> 01:23:34,180
0,270 270,1380
Let's reconstruct
让我们从头开始重建实验，

2521
01:23:34,600 --> 01:23:35,920
0,870
{}

2522
01:23:40,180 --> 01:23:42,250
0,240 240,390 390,960 960,1170 1170,2070
{} the lab from scratch,|
|

2523
01:23:44,100 --> 01:23:45,920
0,1320
clone.|
克隆。|

2524
01:24:07,740 --> 01:24:09,210
0,420 420,630 630,960 960,1140 1140,1470
Okay, this point we've just
好的，我们刚才讲的这一点，

2525
01:24:09,210 --> 01:24:10,700
0,900
made,|
|

2526
01:24:11,260 --> 01:24:13,150
0,270 270,480 480,1050 1080,1530 1530,1890
I just made a change
我刚刚修改了 uvmcopy 。

2527
01:24:13,150 --> 01:24:14,880
0,120 120,540 540,1140
to uvmcopy right.|
|

2528
01:24:16,700 --> 01:24:18,680
0,480 480,660 660,1410
So we were,
所以我们在这里不能做什么，

2529
01:24:20,040 --> 01:24:20,940
0,240 240,300 300,420 420,630 630,900
what are we not doing

2530
01:24:20,940 --> 01:24:23,190
0,240 240,330 330,570 570,1530 2010,2250
here,| we're not allocating and
|我们没有分配，也没有 memmove 。

2531
01:24:23,190 --> 01:24:24,690
0,60 60,270 270,510 510,690 690,1500
we're not doing {memmove -}.|
|

2532
01:24:27,420 --> 01:24:30,180
0,780 870,1170 1170,1320 1320,2100
{} But we are,|
但我们会，|

2533
01:24:31,460 --> 01:24:32,800
0,750

2534
01:24:34,160 --> 01:24:35,840
0,270 270,360 360,510 510,1200
{} we're gonna pass
我们会把 pa 传给 mappages ，

2535
01:24:35,840 --> 01:24:37,500
0,300 300,1110
{pa -}

2536
01:24:38,020 --> 01:24:40,840
0,270 270,540 540,1320 1320,2220 2430,2820
to {mappages -}| and I
|我想在我第一次跑任何东西的时候。

2537
01:24:40,840 --> 01:24:41,770
0,180 180,240 240,450 450,840 840,930
think the very first the

2538
01:24:41,770 --> 01:24:42,640
0,180 180,420 420,570 570,630 630,870
very first time I ran

2539
01:24:42,640 --> 01:24:43,740
0,540
anything.|
|

2540
01:24:43,800 --> 01:24:44,520
0,120 120,270 270,420 420,600 600,720
I think this was the
我想这就是当时的状态。

2541
01:24:44,520 --> 01:24:46,020
0,300 300,360 360,930
state of play.|
|

2542
01:24:46,050 --> 01:24:47,490
0,180 180,360 360,870 870,1230 1230,1440
It was after we did
那是在我们做完 flag 之后，所以。

2543
01:24:47,490 --> 01:24:49,020
0,90 90,510 510,840 840,1170 1170,1530
the flag, so so.| Okay.|
|好的。|

2544
01:24:54,020 --> 01:24:55,460
0,720

2545
01:24:55,490 --> 01:24:57,700
0,270 270,390 390,570 570,1650
Alright, so let's clear.|
好的，让我们清楚。|

2546
01:25:02,010 --> 01:25:03,780
0,1110

2547
01:25:05,200 --> 01:25:06,280
0,510

2548
01:25:11,790 --> 01:25:13,600
0,420 420,960
{That,looks} good.|
看起来不错。|

2549
01:25:18,250 --> 01:25:19,300
0,360

2550
01:25:35,420 --> 01:25:36,480
0,570
Alright,
好的，我们有一个 c ，

2551
01:25:37,340 --> 01:25:38,570
0,180 180,300 330,870 870,1050 1050,1230
we got {a,c},| well let's
|让我们看看 c 指令页面错误，

2552
01:25:38,570 --> 01:25:41,450
0,720 720,1440 1830,2340 2340,2760 2760,2880
{see,c} instruction page fault, {}|
|

2553
01:25:41,450 --> 01:25:43,940
0,480 750,1020 1020,1290 1770,1890 1890,2490
so okay so {} {scause
好的，所以 scause 2 ，

2554
01:25:43,940 --> 01:25:45,440
0,270 270,960
-} 2,|
|

2555
01:25:46,390 --> 01:25:47,380
0,180 180,330 330,720 780,900 900,990
you know, as you know
我们认为一个共享的进程 id 2 ，

2556
01:25:47,380 --> 01:25:49,600
0,150 150,360 360,690 1020,1860 1860,2220
we think a shared process

2557
01:25:49,600 --> 01:25:51,730
0,270 270,750 750,1170 1170,1530 1830,2130
id 2,| {} man you're
|你说得对，是进程 id 1 。

2558
01:25:51,730 --> 01:25:53,380
0,180 180,300 300,690 690,900 900,1650
right, it's process id 1.|
|

2559
01:25:56,520 --> 01:25:57,840
0,630

2560
01:26:00,740 --> 01:26:01,550
0,210 210,510 510,660 660,750 750,810
I just don't have a
我没有一个想法来解释为什么进程 id 1。

2561
01:26:01,550 --> 01:26:02,750
0,330 330,450 450,630 630,990 990,1200
theory for why process id

2562
01:26:02,750 --> 01:26:03,760
0,420
1.|
|

2563
01:26:05,510 --> 01:26:07,100
0,330 330,420 420,570 570,1260
{Why -} it's {out,of,control}.|
为什么失控了。|

2564
01:26:07,490 --> 01:26:08,840
0,480 630,960 960,1170 1170,1290 1290,1350
Let's let's let's look at
让我们看看它是做什么的。

2565
01:26:08,840 --> 01:26:10,780
0,180 180,480 480,1230
what it does.|
|

2566
01:26:14,340 --> 01:26:15,640
0,180 180,360 360,510 510,720
I just see init.|
我看看 init 。|

2567
01:26:33,520 --> 01:26:34,960
0,240 240,360 360,810 810,930 930,1440
Okay, it exec this shell.|
好的，它执行这个 shell 。|

2568
01:26:39,580 --> 01:26:43,360
0,120 120,450 2100,2730 2820,3390 3390,3780
I don't know.| You know,
我不知道。|好的，我有个主意，

2569
01:26:43,360 --> 01:26:45,220
0,210 210,900 930,1290 1290,1350 1350,1860
okay, oh here's an idea,|
|

2570
01:26:45,310 --> 01:26:46,750
0,390 390,690 690,1050 1050,1200 1200,1440
process id 2 is taken
进程 id 2 出现错误并退出。

2571
01:26:46,750 --> 01:26:48,070
0,60 60,390 390,480 480,630 630,1320
a fault and it's exited.|
|

2572
01:26:48,850 --> 01:26:51,490
0,600 600,1800 2010,2340 2340,2490 2490,2640
{So,you,do,fork,later}.| Yeah, so that means
所以你之后做了 fork 。|是的，那就是这个等待 init ，

2573
01:26:51,490 --> 01:26:52,450
0,120 120,270 270,570 570,750 750,960
that this wait to init,|
|

2574
01:26:52,450 --> 01:26:54,460
0,450 540,840 840,1740
it has returned,
它返回了，

2575
01:26:55,240 --> 01:26:56,770
0,420 570,840 840,1080 1080,1320 1320,1530
right,| let's go back around
|让我们回到循环中，再次调用 fork ，

2576
01:26:56,770 --> 01:26:57,730
0,90 90,330 330,420 420,660 660,960
the loop and call fork

2577
01:26:57,730 --> 01:26:58,540
0,300 300,420 420,600 600,720 720,810
again| and so you know
|所以，在 fork 之后，

2578
01:26:58,540 --> 01:27:00,700
0,360 360,870 1020,1200 1200,1380 1380,2160
after fork,| we're now sharing
|我们现在共享，或者取决于所有这些损坏代码。

2579
01:27:01,700 --> 01:27:02,870
0,240 240,360 360,630 690,1110 1110,1170
or you know depending on

2580
01:27:02,870 --> 01:27:04,560
0,120 120,240 240,630 630,1110
all this damage code.|
|

2581
01:27:07,460 --> 01:27:09,240
0,360 360,660 660,780 780,1230
Oh, okay, I see.|
哦，好的，我明白了。|

2582
01:27:09,270 --> 01:27:10,530
0,210 210,480 480,780 780,1050 1050,1260
Oh, yeah, that's that's very
哦，是的，那是非常令人困惑的。

2583
01:27:10,530 --> 01:27:11,740
0,690
confusing.|
|

2584
01:27:11,740 --> 01:27:12,730
0,150 150,300 300,510 510,900 900,990
Oh, yeah, these errors are
哦，是的，这些错误完全是[]，

2585
01:27:12,730 --> 01:27:15,250
0,360 450,720 720,1200 1560,2310 2340,2520
just like complete [],| because
|因为我们违反了各种直觉，

2586
01:27:15,250 --> 01:27:16,810
0,90 90,690 690,810 810,1170 1170,1560
we violated all sorts of

2587
01:27:17,650 --> 01:27:19,120
0,810 810,1020 1020,1140 1140,1350 1350,1470
intuitions| about how things should
|关于事情是如何运作的。

2588
01:27:19,120 --> 01:27:19,900
0,360
work.|
|

2589
01:27:21,120 --> 01:27:22,980
0,750
Okay.
好的。
