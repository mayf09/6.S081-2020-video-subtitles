1
00:00:00,000 --> 00:00:02,010
0,240 240,450 450,900 900,1500 1530,2010
For {} folks already signed
对于已经登录的用户，

2
00:00:02,010 --> 00:00:03,100
0,420
in,|
|

3
00:00:03,100 --> 00:00:04,810
0,420 420,660 660,1320 1320,1530 1530,1710
{ -} curiosity how you
好奇你在 traps 实验的经历。

4
00:00:04,810 --> 00:00:06,580
0,420 420,690 690,900 900,1440 1470,1770
experience being with the traps

5
00:00:06,580 --> 00:00:08,080
0,600
lab.|
|

6
00:00:08,200 --> 00:00:09,700
0,210 210,360 360,930 930,1320 1320,1500
If you already started on
如果你已经开始了懒分配实验，进展如何。

7
00:00:09,700 --> 00:00:11,830
0,390 540,930 930,1410 1410,1680 1680,2130
the lazy allocation lab, how's

8
00:00:11,830 --> 00:00:13,720
0,210 210,660
that going.|
|

9
00:00:13,810 --> 00:00:16,240
0,630 630,900 900,1020 1020,1590 1920,2430
{[] -} that was was
[]是不是比页表实验轻松。

10
00:00:16,240 --> 00:00:17,980
0,330 330,810 810,1050 1050,1470 1500,1740
less painful than the page

11
00:00:17,980 --> 00:00:19,220
0,330 330,690
table lab.|
|

12
00:00:20,580 --> 00:00:22,380
0,390 690,1170 1170,1500 1530,1740 1740,1800
Andrew You, you want to
Andrew You ，你有什么想说的吗？

13
00:00:22,380 --> 00:00:23,980
0,150 150,360 360,540 540,1020
say something about that.|
|

14
00:00:32,000 --> 00:00:33,260
0,240 240,450 450,540 540,870 870,1260
I thought the traps lab
我认为 traps 实验没问题，

15
00:00:33,260 --> 00:00:34,660
0,180 180,780
was OK,|
|

16
00:00:35,030 --> 00:00:37,060
0,120 120,270 270,630
It was just
我只是想确认一下，

17
00:00:37,300 --> 00:00:39,700
0,390 390,780 780,1320 1680,1890 1890,2400
making sure that| I actually
|我使用 trampoline 页面有点烦人。

18
00:00:39,700 --> 00:00:41,380
0,240 240,300 300,810 810,1050 1050,1680
use the trampoline page properly

19
00:00:41,410 --> 00:00:44,170
0,750 840,990 990,1320 1320,1860 2310,2760
was a little annoying.| Yep.|
|是的。|

20
00:00:44,410 --> 00:00:45,400
0,180 180,360 360,450 450,750 750,990
But once I figured that
但是一旦我弄清楚了，然后它就可以工作了。

21
00:00:45,400 --> 00:00:46,720
0,240 240,600 630,870 870,960 960,1320
out, then then it just

22
00:00:46,720 --> 00:00:48,310
0,180 180,270 270,840 1050,1410 1410,1590
kind of worked.| Good good,
|好的，是的，实验的整个目标是，

23
00:00:48,340 --> 00:00:49,150
0,330 330,450 450,600 600,660 660,810
yeah, { -} the whole

24
00:00:49,150 --> 00:00:50,320
0,240 240,390 390,720 720,990 990,1170
goal was lab [],| you
|把 trap 处理入口和出口完全暴露给你。

25
00:00:50,320 --> 00:00:51,880
0,390 390,720 720,840 840,990 990,1560
really expose you to the

26
00:00:52,880 --> 00:00:56,690
0,810 990,1860 2070,2790 2820,3720 3720,3810
trap handling {} entry and

27
00:00:56,690 --> 00:00:57,800
0,450
exit.|
|

28
00:01:01,990 --> 00:01:03,640
0,180 180,660 660,750 750,1290 1500,1650
How about {Amir -}, how
Amir 呢，你在 traps 实验的经历如何。

29
00:01:03,640 --> 00:01:05,440
0,120 120,270 270,660 660,750 750,1800
was your experience with {the,traps,lab}.|
|

30
00:01:08,180 --> 00:01:10,670
0,1290 1380,1860 1860,2070 2070,2340 2340,2490
I thought that {traps -}
我觉得 traps 实验很好，比页表实验易于管理。

31
00:01:10,670 --> 00:01:13,190
0,360 390,960 1290,1740 1770,2040 2040,2520
lab was good, very much

32
00:01:13,220 --> 00:01:15,260
0,540 540,1140 1140,1410 1410,1740 1770,2040
more manageable than the page

33
00:01:15,260 --> 00:01:17,620
0,720 1320,1890
table lab.|
|

34
00:01:17,620 --> 00:01:19,300
0,330 360,960 960,1080 1080,1230 1230,1680
I noticed that there {were,like}
我注意到有机会更精巧地实现的某些方面，这很好，

35
00:01:19,330 --> 00:01:21,040
0,810 810,930 930,1080 1080,1440 1440,1710
opportunities to be clever about

36
00:01:21,040 --> 00:01:22,570
0,180 180,600 600,690 690,780 780,1530
some aspects of the implementation,

37
00:01:22,570 --> 00:01:25,810
0,150 150,300 300,840 1320,2190 2670,3240
which was nice| and lazy
这真是太好了|到目前为止，懒分配实验的调试情况还不错。

38
00:01:25,810 --> 00:01:27,460
0,240 240,720 750,1020 1020,1230 1230,1650
lab is good so far

39
00:01:27,610 --> 00:01:29,280
0,450 480,1140
{} debugging.|
|

40
00:01:29,560 --> 00:01:30,820
0,180 180,420 420,840 870,1050 1050,1260
But both better than the
但在我看来，两者都比页表要好。

41
00:01:30,820 --> 00:01:32,170
0,270 270,630 630,780 780,900 900,1350
page table in my opinion.|
|

42
00:01:32,410 --> 00:01:34,420
0,270 270,330 330,570 570,1800 1830,2010
Glad to hear that,| I'm
很高兴听到你这么说，|我相信你也很高兴听到这个，

43
00:01:34,420 --> 00:01:35,110
0,180 180,300 300,390 390,630 630,690
sure you were glad to

44
00:01:35,110 --> 00:01:36,490
0,180 180,360 360,540 570,900 1020,1380
hear that,| but I'm glad
|但我也很高兴听到你这么说。

45
00:01:36,490 --> 00:01:37,680
0,60 60,180 180,300 300,570
to hear it too.|
|

46
00:01:40,480 --> 00:01:41,800
0,240 240,510 510,630 630,1020 1080,1320
How about {Timmy -} {[]
Timmy 怎么样？

47
00:01:41,800 --> 00:01:42,820
0,420
-}?|
|

48
00:01:44,180 --> 00:01:47,540
0,900 1050,1380 1380,2040 2220,3120 3120,3360
Yeah, these two previous labs
是的，前两个实验比页表要好得多。

49
00:01:47,540 --> 00:01:48,320
0,150 150,270 270,300 300,510 510,780
have been a lot better

50
00:01:48,320 --> 00:01:51,920
0,210 210,630 750,1500 1500,2010
than the page table.|
|

51
00:01:51,950 --> 00:01:53,260
0,150 150,870
I guess,
我想，对于懒分配实验来说最难的是，

52
00:01:53,820 --> 00:01:55,230
0,120 120,540 540,840 840,1050 1050,1410
the hardest part for the

53
00:01:55,260 --> 00:01:57,480
0,390 390,630 630,1140 1200,1800 1800,2220
lazy lab, the lazy one|
|

54
00:01:57,480 --> 00:01:59,500
0,450 450,1260
was the
读写和所有的东西，

55
00:01:59,560 --> 00:02:01,150
0,240 240,390 390,870 900,1380 1440,1590
read and write and all

56
00:02:01,150 --> 00:02:02,860
0,210 210,660 750,1080 1080,1260 1260,1710
that stuff,| but it's not
|但在我看来并不是那么糟糕。

57
00:02:02,890 --> 00:02:04,240
0,210 210,420 420,660 660,1050 1230,1350
it's not that bad in

58
00:02:04,240 --> 00:02:05,400
0,150 150,630
my opinion.|
|

59
00:02:05,800 --> 00:02:06,800
0,480
Okay.|
好的。|

60
00:02:11,480 --> 00:02:13,700
0,180 180,360 360,900 1530,1800 1800,2220
How do Catherine,| was the
Catherine 怎么样，|对你来说， traps 实验或懒分配实验与页表实验相比较。

61
00:02:13,730 --> 00:02:15,320
0,420 420,660 660,840 840,1140 1170,1590
traps lab or the lazy

62
00:02:15,320 --> 00:02:17,060
0,240 240,450 450,840 1200,1290 1290,1740
lab for you in comparison

63
00:02:17,060 --> 00:02:18,340
0,150 150,540
to the

64
00:02:18,340 --> 00:02:19,680
0,300 300,330 330,840
page table lab.|
|

65
00:02:33,340 --> 00:02:34,870
0,150 150,210 210,420 420,930 1200,1530
Are you there, Katherine, Katherine
你在吗，Katherine ， Katherine Weeks 。

66
00:02:34,870 --> 00:02:35,940
0,510
Weeks.|
|

67
00:02:36,600 --> 00:02:38,130
0,570 570,720 720,900 900,1290 1320,1530
Hello, I'm doing well,| sorry
你好，我做得很好，|抱歉，我不知道你在跟哪个 Catherine 说话，

68
00:02:38,130 --> 00:02:39,540
0,30 30,210 210,540 810,1020 1020,1410
I didn't know which Catherine

69
00:02:39,540 --> 00:02:40,500
0,390 420,660 660,780 780,810 810,960
you're talking to,| I guess
|我想大概只有 20 个人，

70
00:02:40,500 --> 00:02:41,700
0,150 150,300 300,510 510,870 870,1200
there's only twenty people,| so
|所以你可能不太可能还有另一个。

71
00:02:41,910 --> 00:02:43,530
0,210 210,630 990,1290 1290,1530 1530,1620
you're probably not likely that

72
00:02:43,530 --> 00:02:45,720
0,180 180,390 390,630 1890,2040 2040,2190
there's another one.| I'm doing
|我做得很好。

73
00:02:45,720 --> 00:02:46,800
0,180 180,630
quite well.|
|

74
00:02:46,950 --> 00:02:49,080
0,540 690,990 990,1590
Good good, so
很好，所以这个实验比页表实验少了很多痛苦.

75
00:02:49,080 --> 00:02:50,010
0,180 180,360 360,480 480,630 630,930
this lab is less painful

76
00:02:50,010 --> 00:02:51,030
0,120 120,180 180,570 570,870 870,1020
than the pagetable lab or.|
|

77
00:02:51,030 --> 00:02:52,950
0,480 480,660 660,1110 1110,1380 1380,1920
Yeah, it's definitely less painful.|
是的，绝对不会那么痛苦。|

78
00:02:55,420 --> 00:02:57,000
0,210 210,540 840,1320
{Excellent -}.| Yeah.|
太棒了。|嗯。|

79
00:02:57,470 --> 00:02:58,960
0,840
Yeah.|
嗯。|

80
00:02:59,420 --> 00:03:01,880
0,660 660,780 780,1290 1320,2040 2130,2460
The the one the one
页表后面的那个 traps （实验），绝对简单的多。

81
00:03:01,880 --> 00:03:03,650
0,390 390,1170 1170,1440 1440,1560 1560,1770
after {page,tables}, what was that

82
00:03:03,650 --> 00:03:05,720
0,450 450,600 600,750 750,1380 1470,2070
traps, that was definitely much

83
00:03:06,020 --> 00:03:07,540
0,600
simpler.|
|

84
00:03:09,300 --> 00:03:11,130
0,570 600,990 1110,1530 1530,1770 1770,1830
OK great, we're glad to
好的，很高兴听到你们这么说，

85
00:03:11,130 --> 00:03:11,820
0,90 90,270 270,330 330,480 480,690
hear that,| I just wanted
|我只想做个非正式的民意测验，

86
00:03:11,820 --> 00:03:13,140
0,60 60,330 330,480 480,900 900,1320
to get an informal poll

87
00:03:13,140 --> 00:03:14,300
0,540
see,|
|

88
00:03:14,480 --> 00:03:15,350
0,390 390,510 510,600 600,720 720,870
{} you know the page
页表实验比我们预想的要难，

89
00:03:15,350 --> 00:03:16,340
0,270 270,480 480,600 600,840 840,990
table turned out harder than

90
00:03:16,340 --> 00:03:17,330
0,120 120,300 300,360 360,690 750,990
we thought it would,| and
|所以，这些更好。

91
00:03:17,330 --> 00:03:18,180
0,330
so,

92
00:03:18,920 --> 00:03:19,730
0,210 210,300 300,450 450,630 630,810
like you know these ones

93
00:03:19,730 --> 00:03:20,720
0,60 60,450
are better.|

94
00:03:20,810 --> 00:03:23,090
0,630 720,1200 1200,1950 1980,2130 2130,2280
{} OK, {} so what
好的，那么我们要做什么呢。

95
00:03:23,090 --> 00:03:24,440
0,60 60,180 180,330 330,690 690,1350
do we get going {}.|
|

96
00:03:24,800 --> 00:03:26,390
0,630 660,1020 1020,1170 1170,1380 1380,1590
And welcome to the next
不管你在哪里，欢迎收看 6.S081 的下一节课，

97
00:03:26,390 --> 00:03:28,910
0,360 360,660 690,1200 1200,1560 1980,2520
lecture in {6.S081 -} wherever

98
00:03:28,910 --> 00:03:31,250
0,150 150,570 780,1410 1770,2010 2010,2340
you are,| so the topic
|今天的主题是关于中断，

99
00:03:31,250 --> 00:03:32,630
0,150 150,390 390,510 510,780 780,1380
in today is about interrupts,|
|

100
00:03:32,690 --> 00:03:34,880
0,510 540,960 960,1440 1440,2010 2010,2190
{} before jumping into sort
在开始讨论中断之前，

101
00:03:34,880 --> 00:03:36,200
0,60 60,300 300,450 450,900 1080,1320
of talking about interrupts,| I
|我想分享一点东西，

102
00:03:36,200 --> 00:03:37,280
0,210 210,540 540,840 840,900 900,1080
wanted to share a little

103
00:03:37,280 --> 00:03:38,540
0,450 480,750 750,990 990,1140 1140,1260
bit {} one thing,| that
|我想说的是，

104
00:03:38,540 --> 00:03:39,740
0,60 60,300 300,420 420,750 750,1200
I wanted to talk about,|
|

105
00:03:39,740 --> 00:03:41,210
0,540 570,930 930,1200 1200,1410 1410,1470
{} last week which I
上个星期，我没能抽出时间来做这件事。

106
00:03:41,210 --> 00:03:42,350
0,210 210,300 300,600 600,870 870,1140
didn't get around {do,it} through.|
|

107
00:03:42,780 --> 00:03:43,920
0,540 540,660 660,780 780,1050 1050,1140
And you know what you
你可能会感兴趣的。

108
00:03:43,920 --> 00:03:45,340
0,180 180,390 390,810
might find interesting.|
|

109
00:03:45,490 --> 00:03:46,700
0,630

110
00:03:47,840 --> 00:03:48,440
0,210 210,300 300,480 480,570 570,600
Let me see, if I
让我看下，在这里找到我正确的屏幕，

111
00:03:48,440 --> 00:03:49,940
0,300 450,600 600,810 810,1080 1080,1500
can get my right screen

112
00:03:49,940 --> 00:03:51,680
0,300 300,660 930,1170 1170,1740 1740,1740
here up,| so here {},
|所以在这里，看我屏幕的左下角，

113
00:03:52,400 --> 00:03:53,090
0,150 150,300 300,450 450,570 570,690
you know you see my

114
00:03:53,090 --> 00:03:54,620
0,390 390,690 690,810 810,1230 1260,1530
screen here on the bottom

115
00:03:54,620 --> 00:03:56,480
0,480 750,1080 1080,1290 1290,1590 1590,1860
left,| I'm actually {logged -}
|我通过对话机登录到 Athena 。

116
00:03:56,480 --> 00:03:58,040
0,450 450,1170
into {}

117
00:03:58,070 --> 00:04:00,080
0,480 480,1020 1050,1320 1320,1530 1530,2010
{} Athena through the dialogue

118
00:04:00,080 --> 00:04:01,180
0,570
machines.|
|

119
00:04:01,180 --> 00:04:02,500
0,630 630,900 900,960 960,1140 1140,1320
And there's a couple things
我有几件事想谈谈，

120
00:04:02,500 --> 00:04:04,300
0,30 30,360 360,600 930,1260 1260,1800
I wanted to talk about,|
|

121
00:04:04,390 --> 00:04:06,010
0,750 750,810 870,1320 1320,1380 1380,1620
{} in terms of how
在真正的操作系统中，内存是如何使用的。

122
00:04:06,010 --> 00:04:07,780
0,330 330,390 390,600 600,1140 1170,1770
memory is being used by

123
00:04:07,780 --> 00:04:09,360
0,90 90,300 300,630 630,1050
a real operating system.|
|

124
00:04:09,540 --> 00:04:10,290
0,270 270,360 360,570 570,600 600,750
Since we talked a lot
因为我们上周谈了很多，特别是在课程的最后，

125
00:04:10,290 --> 00:04:11,490
0,210 210,360 360,660 660,840 840,1200
about that last week, particularly

126
00:04:11,490 --> 00:04:12,120
0,60 60,180 180,240 240,330 330,630
the end of the lecture,|
|

127
00:04:12,120 --> 00:04:13,170
0,90 90,240 240,300 300,660 660,1050
a lot of questions about,
很多问题关于逐出页面，寻找空闲内存之类的东西。

128
00:04:13,470 --> 00:04:15,510
0,240 240,480 510,870 870,1440 1470,2040
you know page out, {}

129
00:04:15,510 --> 00:04:16,530
0,270 270,450 450,810 810,900 900,1020
finding free memory and all

130
00:04:16,530 --> 00:04:17,720
0,120 120,270 270,330 330,720
that kind of stuff.|
|

131
00:04:17,990 --> 00:04:19,730
0,390 780,1110 1110,1290 1290,1560 1560,1740
{} So this is one
这是一台 Athena 机器，

132
00:04:19,730 --> 00:04:21,740
0,60 60,300 300,1020 1080,1800 1800,2010
of Athena machines,| {} you're
|你要注意的是，

133
00:04:21,740 --> 00:04:22,850
0,390 390,510 510,900 900,1020 1020,1110
wanting to note,| if you
|如果你看一下内存这一行，它告诉你有多少，

134
00:04:22,850 --> 00:04:24,440
0,210 210,330 330,600 600,1050 1050,1590
look at the memory line,

135
00:04:24,860 --> 00:04:26,630
0,750 750,900 900,1110 1110,1410 1410,1770
{} it actually tells you

136
00:04:26,630 --> 00:04:28,430
0,300 300,780 960,1140 1140,1590 1590,1800
how much,| the program running
|运行的程序是 top ，可能你们很多人都用过它，

137
00:04:28,430 --> 00:04:30,440
0,90 90,270 270,930 1560,1860 1860,2010
is called top, probably many

138
00:04:30,440 --> 00:04:31,190
0,90 90,180 180,270 270,540 540,750
of you have used it,|
|

139
00:04:31,550 --> 00:04:32,870
0,630 630,870 870,1020 1020,1140 1140,1320
{} you see how much
你可以看到一台机器里有多少内存，

140
00:04:32,870 --> 00:04:34,460
0,450 450,870 870,960 960,990 990,1590
machine memories in a machine|
|

141
00:04:34,460 --> 00:04:35,300
0,210 210,270 270,360 360,570 570,840
as you can see, there's
如你所见，这台机器里有很多内存。

142
00:04:35,300 --> 00:04:36,260
0,210 240,720 720,750 750,900 900,960
a quite a bit of

143
00:04:36,260 --> 00:04:37,550
0,420 420,570 570,960 960,1140 1140,1290
memory in {} in this

144
00:04:37,550 --> 00:04:38,520
0,570
machine.|
|

145
00:04:38,520 --> 00:04:40,680
0,600 1050,1770 1770,1860 1860,1980 1980,2160
{} And if you look
如果你仔细看一下，实际上大部分都是在使用的。

146
00:04:40,680 --> 00:04:42,180
0,120 120,300 300,420 420,990 990,1500
a little bit carefully, actually

147
00:04:42,180 --> 00:04:44,130
0,510 510,600 600,720 720,990 1020,1950
most of it is used,

148
00:04:45,410 --> 00:04:47,750
0,390 420,1290 1620,1770 1770,1920 1920,2340
right.| The you know, a
|很大一部分内存实际上并没有被应用程序使用，

149
00:04:47,750 --> 00:04:48,590
0,270 270,450 450,540 540,600 600,840
large part of the memory

150
00:04:48,590 --> 00:04:49,460
0,60 60,240 240,450 450,630 630,870
is actually not being used

151
00:04:49,460 --> 00:04:50,840
0,90 90,720 720,870 870,1140 1140,1380
by applications,| but actually used
|而是由缓冲器高速缓存使用。

152
00:04:50,840 --> 00:04:52,320
0,90 90,210 210,450 450,990
by the buffer cache.|
|

153
00:04:52,410 --> 00:04:53,490
0,180 180,330 330,480 480,570 570,1080
I said this is quite
这在操作系统中很常见，

154
00:04:53,490 --> 00:04:54,900
0,450 450,600 600,690 690,1050 1050,1410
common in an operating system,|
|

155
00:04:54,900 --> 00:04:55,740
0,120 120,330 330,570 570,750 750,840
you don't really want to
你不想让你的内存无所事事，

156
00:04:55,740 --> 00:04:57,720
0,300 300,870 930,1380 1380,1680 1680,1980
leave your physical memory, sitting

157
00:04:57,720 --> 00:04:59,430
0,420 420,600 600,750 750,1260 1470,1710
idle and do nothing,| you
|你可能把它用在有用的东西上，

158
00:04:59,430 --> 00:05:00,060
0,150 150,240 240,360 360,540 540,630
might as well use it

159
00:05:00,060 --> 00:05:01,560
0,90 90,330 330,780 960,1290 1290,1500
for something useful,| and so
|在这种情况下，它的很大一部分用于缓冲区缓存。

160
00:05:01,560 --> 00:05:02,190
0,90 90,210 210,510 510,630 630,630
in this case, use a

161
00:05:02,940 --> 00:05:03,930
0,390 390,660 660,750 750,900 900,990
good chunk of it is

162
00:05:03,930 --> 00:05:05,610
0,360 360,600 600,900 900,1380 1440,1680
actually used for a buffer

163
00:05:05,610 --> 00:05:06,460
0,450
cache.|
|

164
00:05:06,790 --> 00:05:08,260
0,480 540,960 960,1050 1050,1140 1140,1470
A little bit of memory,
一些内存是空闲的，不是很多，

165
00:05:08,260 --> 00:05:11,620
0,480 540,1290 1320,1680 1680,2130 2520,3360
free, {} not much,| {}
|在一台机器中总内存的一小部分，

166
00:05:11,650 --> 00:05:13,270
0,150 150,480 510,1080 1080,1380 1530,1620
you know fraction of the

167
00:05:13,270 --> 00:05:14,470
0,300 300,630 630,810 810,1080 1080,1200
total memory that actually in

168
00:05:14,470 --> 00:05:15,370
0,60 60,510 510,630 630,750 750,900
a machine| and so this
|这是一个非常常见的情况，像大多数操作系统一样。

169
00:05:15,370 --> 00:05:16,690
0,90 90,150 150,510 510,870 870,1320
is a very common case,

170
00:05:16,690 --> 00:05:18,580
0,180 180,420 420,810 810,1170 1200,1890
like most operating systems run.|
|

171
00:05:19,080 --> 00:05:20,580
0,480 480,660 660,1050 1050,1350 1350,1500
{} We basically almost no
我们在任何时刻都几乎没有可用的内存。

172
00:05:20,580 --> 00:05:21,780
0,360 360,540 540,630 630,840 840,1200
memory free at any particular

173
00:05:21,780 --> 00:05:23,140
0,330 330,420 420,810
instant in time.|
|

174
00:05:23,620 --> 00:05:25,030
0,540 540,750 750,900 900,1050 1050,1410
{} And so that means,
这意味着，如果应用程序或内核需要一些内存，

175
00:05:25,030 --> 00:05:26,800
0,120 120,510 510,900 900,990 990,1770
for example, if an application

176
00:05:26,800 --> 00:05:27,970
0,150 150,210 210,540 540,990 990,1170
or the kernel needs some

177
00:05:27,970 --> 00:05:29,410
0,510 630,870 870,990 990,1200 1200,1440
memory| and we'll have to
|我们得扔掉一些东西，

178
00:05:29,410 --> 00:05:31,120
0,270 270,420 420,840 960,1080 1080,1710
throw out something,| you know,
|也许这几页就足够了，

179
00:05:31,120 --> 00:05:32,470
0,300 300,480 480,720 720,840 840,1350
maybe that's enough for a

180
00:05:32,470 --> 00:05:34,300
0,180 180,600 600,810 810,1170 1380,1830
few pages where a handful

181
00:05:34,300 --> 00:05:35,020
0,60 60,360 360,510 510,570 570,720
of pages,| but at some
|但在某种情况下，它需要大量的空闲内存，

182
00:05:35,020 --> 00:05:35,800
0,240 240,420 420,570 570,630 630,780
point it needs a lot

183
00:05:35,800 --> 00:05:36,850
0,60 60,210 210,660 720,900 900,1050
of free memory,| it will
|它会要求从应用程序或缓冲器告诉缓存中中逐出某些内容。

184
00:05:36,850 --> 00:05:38,260
0,300 300,360 360,690 690,1140 1140,1410
ask to evict something either

185
00:05:38,260 --> 00:05:39,580
0,150 150,240 240,960 960,1170 1170,1320
from the applications or from

186
00:05:39,580 --> 00:05:40,740
0,60 60,300 300,780
the buffer cache.|
|

187
00:05:41,380 --> 00:05:42,400
0,180 180,450 450,600 600,690 690,1020
And so you know sort
所以这里的主要观点是，

188
00:05:42,400 --> 00:05:43,750
0,330 600,720 720,900 900,1170 1170,1350
of the main point here

189
00:05:43,750 --> 00:05:44,890
0,390 390,510 510,720 720,960 960,1140
basically is that here,| when
|当内核分配内存时，

190
00:05:44,890 --> 00:05:46,210
0,60 60,360 360,540 540,900 900,1320
the kernel makes allocate memory,|
|

191
00:05:46,210 --> 00:05:47,470
0,180 180,420 420,780 780,1110 1110,1260
it's actually not generally not
通常不是一个便宜的操作，

192
00:05:47,470 --> 00:05:48,910
0,90 90,360 360,900 900,1350 1350,1440
a cheap operation,| because the
|因为没有太多空闲内存可用。

193
00:05:48,910 --> 00:05:50,280
0,300 300,390 390,720
memory is not,

194
00:05:50,400 --> 00:05:51,030
0,180 180,360 360,420 420,570 570,630
there's not a ton of

195
00:05:51,030 --> 00:05:52,720
0,330 330,600 600,1140
memory free available.|
|

196
00:05:53,270 --> 00:05:53,960
0,210 210,330 330,450 450,570 570,690
The other thing that's sort
另一件有趣的事情是，

197
00:05:53,960 --> 00:05:54,830
0,60 60,360 360,450 450,660 660,870
of interesting to look at

198
00:05:54,830 --> 00:05:56,270
0,180 180,300 300,750 750,900 900,1440
is| I sorted the output
|我根据驻留内存量对 top 的输出进行排序。

199
00:05:56,300 --> 00:05:59,990
0,240 240,1500 1530,2130 2160,3330 3510,3690
of {} top by the

200
00:05:59,990 --> 00:06:01,660
0,270 270,330 330,720 720,1170
amount of resident memory.|
|

201
00:06:01,660 --> 00:06:03,160
0,390 390,840 990,1260 1260,1440 1440,1500
{} So you're looking at
所以你看的每一行，

202
00:06:03,160 --> 00:06:04,630
0,180 180,600 600,720 720,930 930,1470
every line,| for every process
|对于每个进程，这是地址空间的大小，

203
00:06:04,630 --> 00:06:06,550
0,300 300,510 510,720 720,1620 1650,1920
you see that, {} this

204
00:06:06,550 --> 00:06:08,620
0,540 540,900 900,1470 1740,1920 1920,2070
{is,size,of} address space| and then
|然后，下一行告诉你实际使用了多少内存，

205
00:06:08,620 --> 00:06:09,640
0,60 60,300 300,570 570,780 780,1020
the next line actually tells

206
00:06:09,640 --> 00:06:10,570
0,120 120,270 270,510 510,870 870,930
you how much memory is

207
00:06:10,570 --> 00:06:11,650
0,300 300,480 480,900 900,1020 1020,1080
actually being used| like the
|比如物理内存量，

208
00:06:11,650 --> 00:06:12,880
0,210 210,300 300,600 600,1110 1110,1230
amount of physical memory,| you
|地址空间的一小部分在物理内存中，

209
00:06:12,880 --> 00:06:14,240
0,210 480,900
know, how

210
00:06:14,240 --> 00:06:15,170
0,150 150,480 480,570 570,630 630,930
the fraction of the address

211
00:06:15,170 --> 00:06:16,490
0,210 210,570 570,810 810,990 990,1320
space actually is in physical

212
00:06:16,490 --> 00:06:17,660
0,360 750,930 930,990 990,1080 1080,1170
memory,| and as you can
|正如你看到的，它通常比地址空间小得多，

213
00:06:17,660 --> 00:06:18,950
0,120 120,210 210,540 540,810 810,1290
see it actually it's typically

214
00:06:18,950 --> 00:06:20,900
0,600 600,1050 1050,1230 1230,1530 1530,1950
way smaller than the address

215
00:06:20,900 --> 00:06:22,760
0,510 540,1020 1200,1410 1410,1530 1530,1860
space| and so the tricks
|所以我们最后谈到的虚拟内存提供的技巧，很酷的想法，

216
00:06:22,760 --> 00:06:23,930
0,150 150,240 240,540 540,840 840,1170
that we talked about last

217
00:06:23,930 --> 00:06:25,940
0,390 420,750 750,1200 1200,1560 1620,2010
word, cool ideas and virtual

218
00:06:25,940 --> 00:06:28,190
0,510 510,690 690,1320 1470,2040 2040,2250
memory {} provides| {} are
|在这里使用，比如按需调页，

219
00:06:28,190 --> 00:06:30,140
0,210 210,690 690,930 930,1260 1260,1950
being {used,here} like demand paging,|
|

220
00:06:30,380 --> 00:06:31,880
0,480 480,600 600,900 900,1200 1200,1500
{} the shared column is
共享列是共享页面，来自共享库中，

221
00:06:31,880 --> 00:06:33,890
0,600 870,1260 1260,1800 1800,1890 1890,2010
{} shared pages, you know

222
00:06:33,890 --> 00:06:35,930
0,300 300,450 450,690 690,1440 1710,2040
from the shared libraries| and
|你大体上可以看到，常驻内存比虚拟地址空间小得多。

223
00:06:35,930 --> 00:06:36,740
0,90 90,240 240,330 330,720 720,810
you see in general that

224
00:06:36,740 --> 00:06:38,800
0,630 840,1680
basically the

225
00:06:38,800 --> 00:06:39,820
0,270 270,330 330,690 690,930 930,1020
{} the resident memory is

226
00:06:39,820 --> 00:06:40,990
0,240 240,480 480,660 660,960 960,1170
much much much smaller than

227
00:06:40,990 --> 00:06:43,080
0,570 600,900 900,1110 1110,1590
the virtual address space.|
|

228
00:06:43,740 --> 00:06:44,910
0,330 330,420 420,660 660,840 840,1170
Maybe a couple other interesting
也许还有几件有趣的事需要注意，

229
00:06:44,910 --> 00:06:46,830
0,330 330,690 720,1260 1290,1650 1650,1920
things to note| are just
|看着这台机器，负载很低，

230
00:06:46,830 --> 00:06:48,480
0,420 420,510 510,660 660,1230 1440,1650
looking at this machine, the

231
00:06:48,480 --> 00:06:49,830
0,150 150,240 240,450 450,930 960,1350
load is very low,| even
|即使有 102 个用户登录。

232
00:06:49,830 --> 00:06:50,580
0,120 120,240 240,270 270,480 480,750
though they're a hundred twenty

233
00:06:50,580 --> 00:06:52,800
0,630 660,840 840,1620 1620,1950 1950,2220
users and 102 users logged

234
00:06:52,800 --> 00:06:53,620
0,300
in.|
|

235
00:06:53,620 --> 00:06:55,840
0,660 1110,1800 1800,1920 1920,2070 2070,2220
{} And you're gonna see
你会看到有很多进程， 950 左右，

236
00:06:55,840 --> 00:06:57,400
0,150 150,420 420,840 840,900 900,1560
there's a lot of processes,

237
00:06:57,400 --> 00:07:00,310
0,180 180,300 300,1680 1680,2160 2190,2910
you know 950 or roughly,|
|

238
00:07:00,550 --> 00:07:02,200
0,870 870,930 930,1170 1170,1500 1500,1650
[] {} note exactly how
注意机器已开机多长时间， 249 天，

239
00:07:02,200 --> 00:07:03,010
0,210 210,270 270,510 510,660 660,810
long the machine has been

240
00:07:03,010 --> 00:07:04,690
0,450 450,660 660,750 750,1170 1170,1680
up, like {249 -} days,|
|

241
00:07:05,080 --> 00:07:06,820
0,570 570,1020 1020,1260 1260,1470 1470,1740
{} your {xv6 -} kernel
你的 xv6 内核可能根本不会运行那么长时间。

242
00:07:06,820 --> 00:07:07,690
0,90 90,360 360,570 570,690 690,870
is probably not up that

243
00:07:07,690 --> 00:07:10,420
0,390 600,930 930,1260 1260,1650
long at all ever.|
|

244
00:07:10,450 --> 00:07:12,600
0,870 900,1530

245
00:07:12,780 --> 00:07:13,890
0,210 210,360 360,690 690,780 780,1110
Okay, so that's you know
好的，这就是，关于这个有什么问题吗，

246
00:07:13,890 --> 00:07:15,180
0,270 270,600 600,810 810,1110 1110,1290
any questions about this,| just
|主要的一点是，大多数内存正在使用，

247
00:07:15,180 --> 00:07:16,520
0,210 210,300 300,300
sort of {},

248
00:07:16,670 --> 00:07:17,420
0,120 120,240 240,330 330,510 510,750
you know the main point

249
00:07:17,420 --> 00:07:18,620
0,240 240,570 570,810 810,1080 1080,1200
being that most memories in

250
00:07:18,620 --> 00:07:20,300
0,480 480,780 780,1140 1140,1440 1440,1680
use| and the resident memory
|并且常驻内存通常比虚拟地址空间小得多。

251
00:07:20,300 --> 00:07:21,590
0,60 60,420 420,690 690,1050 1050,1290
is typically much smaller than

252
00:07:21,590 --> 00:07:23,480
0,60 210,720 720,930 930,1440
the virtual address space.|
|

253
00:07:27,420 --> 00:07:28,350
0,210 210,570 570,630 630,780 780,930
You're [going] to run this
你可以自己运行这个，如果你想看看是怎么发生的。

254
00:07:28,350 --> 00:07:29,640
0,540 540,630 630,720 720,930 930,1290
yourself, if you want to

255
00:07:29,880 --> 00:07:31,020
0,210 210,330 330,600 600,780 780,1140
see you actually what's up.|
|

256
00:07:33,360 --> 00:07:34,660
0,180 180,720
Any questions?|
有什么问题吗？|

257
00:07:35,750 --> 00:07:36,890
0,180 180,300 300,450 450,570 570,1140
You see some of the
您可以看到 6.S081 学生中的一些人登录，

258
00:07:37,100 --> 00:07:38,420
0,420 420,570 570,750 750,990 990,1320
{6.S081 - - -} students

259
00:07:38,420 --> 00:07:39,560
0,180 180,480 480,810 810,1050 1050,1140
being logged in| and if
|如果你看一下，会看到很多 QEMU 在运行。

260
00:07:39,560 --> 00:07:40,430
0,120 120,300 300,630 630,690 690,870
you look around you see

261
00:07:40,430 --> 00:07:41,030
0,30 30,150 150,330 330,390 390,600
a whole bunch of {QEMU

262
00:07:41,030 --> 00:07:42,400
0,270 270,600
-} running.|
|

263
00:07:43,410 --> 00:07:44,540
0,600
Okay,
好的，没有问题。

264
00:07:44,600 --> 00:07:46,610
0,690 750,990 990,1650 1680,1950 1950,2010
{} no questions.| Let me
|让我回到今天的话题，中断。

265
00:07:46,610 --> 00:07:48,260
0,120 120,390 390,1200 1230,1320 1320,1650
go back to the topic

266
00:07:48,260 --> 00:07:49,310
0,90 90,450 450,690 690,870 870,1050
for today, which is {}

267
00:07:49,310 --> 00:07:50,500
0,660
interrupts.|
|

268
00:07:50,880 --> 00:07:52,240
0,750

269
00:07:52,270 --> 00:07:54,550
0,690 1020,1140 1140,1890 1890,2040 2040,2280
And the basic, you know,
基本的想法是很直接的，

270
00:07:54,550 --> 00:07:56,020
0,420 450,810 810,960 960,1080 1080,1470
the basic idea is really

271
00:07:56,020 --> 00:07:57,760
0,780 810,1080 1080,1500 1500,1620 1620,1740
straightforward,| {} what we want
|我们想要实现的是，

272
00:07:57,760 --> 00:07:59,350
0,60 60,420 420,540 540,810 1080,1590
to enable is that {},|
|

273
00:07:59,970 --> 00:08:00,870
0,240 240,360 360,420 420,480 480,900
there's going to be cases
某种情况下，硬件需要关注。

274
00:08:00,870 --> 00:08:02,640
0,240 240,300 300,1080 1170,1290 1290,1770
where the hardware {} wants

275
00:08:02,640 --> 00:08:03,880
0,630
attention,

276
00:08:06,810 --> 00:08:08,500
0,300 300,360 360,660 660,1140
wants to attention now.|
|

277
00:08:10,800 --> 00:08:11,700
0,120 120,300 300,330 330,690 690,900
You know a packet comes
从网络传入数据包，

278
00:08:11,700 --> 00:08:13,020
0,180 180,390 390,450 450,990 1020,1320
in from the network| and
|互联网网卡产生中断，

279
00:08:13,020 --> 00:08:15,450
0,120 120,240 240,570 570,1500 1680,2430
so the network Internet network

280
00:08:15,450 --> 00:08:17,760
0,720 720,1080 1080,1140 1140,1680 1950,2310
card generates an interrupt {},|
|

281
00:08:17,760 --> 00:08:19,560
0,270 270,540 540,1290 1320,1710 1710,1800
user typed a key on
用户在键盘上键入一个键，键盘会产生中断。

282
00:08:19,560 --> 00:08:21,960
0,90 90,780 780,1800 1860,2040 2040,2400
the keyboard and the keyboard

283
00:08:21,960 --> 00:08:23,400
0,390 390,480 480,960
generates an interrupt.|
|

284
00:08:23,490 --> 00:08:25,080
0,690 690,930 930,1020 1020,1260 1260,1590
And you know what the
软件要做什么，

285
00:08:25,110 --> 00:08:26,820
0,330 330,540 540,600 600,1080 1410,1710
software has to do,| if
|如果软件必须保存它的工作，

286
00:08:26,820 --> 00:08:28,920
0,210 210,510 510,750 750,1170 1530,2100
the software has to save

287
00:08:28,920 --> 00:08:30,240
0,90 90,630 660,1110 1110,1170 1170,1320
its work,| whatever it was
|不管它现在在做什么，

288
00:08:30,240 --> 00:08:31,940
0,390 390,600 600,1170
doing right now,|
|

289
00:08:32,990 --> 00:08:34,220
0,240 240,390 390,540 540,600 600,1230
put it on the side,
把它放在一边，进程中断，

290
00:08:35,130 --> 00:08:36,570
0,120 120,270 270,690 690,840 840,1440
you know process {} interrupt,|
|

291
00:08:41,660 --> 00:08:43,700
0,150 150,300 300,990 1020,1320 1320,2040
and then resume or restore,
然后恢复到正在进行的工作中。

292
00:08:44,260 --> 00:08:45,070
0,180 180,270 270,480 480,630 630,810
into the work that is

293
00:08:45,070 --> 00:08:46,040
0,360
doing.|
|

294
00:08:51,020 --> 00:08:54,410
0,720 990,1560 1860,2430 2430,2580 2580,3390
And, {} basically that saving
保存和恢复与我们之前看到的机制非常相似，

295
00:08:54,530 --> 00:08:56,480
0,210 210,1140 1290,1440 1440,1710 1710,1950
and restoring is very very

296
00:08:56,480 --> 00:08:58,760
0,450 450,750 750,1260 1440,2160 2160,2280
similar to the mechanisms that

297
00:08:58,760 --> 00:08:59,990
0,60 60,270 270,390 390,750 750,1230
we already have seen before,|
|

298
00:08:59,990 --> 00:09:01,840
0,360 360,510 510,810 810,1410
namely for system calls,
即用于系统调用，还有 traps ，比如页面错误，

299
00:09:04,890 --> 00:09:06,360
0,210 210,930
and traps,

300
00:09:07,870 --> 00:09:09,820
0,270 270,510 510,1080 1170,1740 1800,1950
like page fault,| {} they
|它们都使用相同的机制。

301
00:09:09,820 --> 00:09:11,050
0,120 120,330 330,390 390,630 630,1230
all use the same mechanism.|
|

302
00:09:18,920 --> 00:09:19,760
0,150 150,240 240,420 420,750 750,840
So in that sense, you
所以在这个意义上，中断与 traps 或系统调用没有什么不同，

303
00:09:19,760 --> 00:09:20,810
0,90 90,540 540,600 600,750 750,1050
know interrupts are no different

304
00:09:20,810 --> 00:09:23,330
0,780 900,1500 1500,1890 1890,2130 2130,2520
whatever, {} compared to traps

305
00:09:23,330 --> 00:09:24,710
0,300 300,390 390,540 540,1080 1080,1380
or you know system calls,|
|

306
00:09:24,710 --> 00:09:26,300
0,150 150,300 330,1050
but a couple
但有几件事让它们有点不同，

307
00:09:26,300 --> 00:09:26,990
0,180 180,300 300,450 450,630 630,690
things that make them a

308
00:09:26,990 --> 00:09:27,980
0,180 180,300 300,630 630,750 750,990
little bit different| and why
|以及为什么我们要花一节课来讲解它们。

309
00:09:27,980 --> 00:09:29,420
0,120 120,330 330,630 630,1080 1080,1440
we're actually spending a lecture

310
00:09:29,420 --> 00:09:30,360
0,150 150,360
on them.|
|

311
00:09:30,360 --> 00:09:31,950
0,270 270,360 360,660 660,1050 1050,1590
So there three basically things
所以有三个东西组成中断，

312
00:09:32,100 --> 00:09:33,980
0,450 450,660 660,1350
that make interrupts,|
|

313
00:09:34,740 --> 00:09:36,750
0,540 540,750 750,1170 1170,1530 1530,2010
{ -} slightly different from
与系统调用和异常略有不同。

314
00:09:36,780 --> 00:09:38,850
0,270 270,600 600,1290 1290,1560 1560,2070
{} system calls and exceptions.|
|

315
00:09:38,850 --> 00:09:40,860
0,510 750,1260 1260,1590 1650,1800 1800,2010
One, {} with a better
第一，用一个更好的词来说，它们是异步的，

316
00:09:40,860 --> 00:09:41,760
0,240 240,360 360,510 510,690 690,900
word, I'm gonna call they're

317
00:09:41,760 --> 00:09:43,000
0,720
asynchronous,|
|

318
00:09:46,310 --> 00:09:47,540
0,240 240,450 450,630 630,660 660,1230
and with that I mean
我的意思是，系统调用，

319
00:09:47,660 --> 00:09:50,030
0,720 780,1230 1230,1710 1710,2070 2070,2370
that, {} the system call,|
|

320
00:09:50,030 --> 00:09:51,770
0,150 150,720 720,1350 1410,1680 1680,1740
the interrupt happens when the
当硬件生成中断时，中断处理程序运行，

321
00:09:51,770 --> 00:09:53,090
0,270 270,480 480,840 840,960 960,1320
hardware actually generate an interrupt

322
00:09:53,090 --> 00:09:54,740
0,360 360,480 480,810 810,1140 1140,1650
and the interrupt handler runs,|
|

323
00:09:54,980 --> 00:09:56,240
0,210 210,570 570,840 840,1050 1050,1260
the interrupt handler might actually
中断处理程序可能与 CPU 上当前运行的进程无关。

324
00:09:56,240 --> 00:09:57,350
0,150 150,540 540,660 660,900 900,1110
have nothing to do with

325
00:09:57,350 --> 00:09:59,120
0,120 120,510 510,780 780,1380 1410,1770
the current running process on

326
00:09:59,120 --> 00:10:00,360
0,240 240,780
the CPU.|
|

327
00:10:00,420 --> 00:10:01,860
0,180 180,780 780,900 900,1320 1320,1440
So, unlike for example where
所以，与进行系统调用的情况不同，

328
00:10:01,860 --> 00:10:02,790
0,90 90,180 180,240 240,570 570,930
you do a system call|
|

329
00:10:02,790 --> 00:10:03,600
0,180 180,300 300,390 390,660 660,810
or when the system call
当系统调用发生时，你跳入内核，

330
00:10:03,600 --> 00:10:04,740
0,540 540,660 660,810 810,900 900,1140
happens and then you jump

331
00:10:04,740 --> 00:10:06,510
0,180 180,270 270,870 1020,1620 1620,1770
into the kernel| then we're
|然后我们在调用进程的上下文中运行。

332
00:10:06,510 --> 00:10:07,560
0,240 240,330 330,390 390,960 960,1050
running in the context of

333
00:10:07,560 --> 00:10:09,160
0,90 90,480 480,1140
the calling process.|
|

334
00:10:09,220 --> 00:10:10,360
0,240 240,360 360,480 480,660 660,1140
And this is not true
而对于中断则不是这样，

335
00:10:10,360 --> 00:10:11,680
0,180 180,720 810,990 990,1110 1110,1320
with interrupt,| {} they might
|它们可能与你正在 CPU 中运行的进程完全无关，

336
00:10:11,680 --> 00:10:13,270
0,150 150,300 300,780 780,1320 1320,1590
have been completely unrelated to

337
00:10:13,270 --> 00:10:15,250
0,450 450,930 1170,1620 1620,1770 1770,1980
actually a process that you

338
00:10:15,250 --> 00:10:16,510
0,240 600,900 900,1140 1140,1200 1200,1260
know who's running in the

339
00:10:16,510 --> 00:10:17,830
0,450 450,690 690,930 930,1050 1050,1320
CPU| might actually have nothing
|可能与中断处理程序无关，甚至不是它调用的。

340
00:10:17,830 --> 00:10:18,580
0,60 60,180 180,270 270,420 420,750
to do with the interrupt

341
00:10:18,580 --> 00:10:19,570
0,300 300,450 450,660 660,840 840,990
handler, may not even it

342
00:10:19,570 --> 00:10:20,600
0,420
calls.|
|

343
00:10:21,000 --> 00:10:22,770
0,300 300,450 450,750 750,1260 1380,1770
{} So that's different.| Second
所以那是不同的。|第二，到目前为止，我们看到的并发性比以往任何时候都要多。

344
00:10:22,770 --> 00:10:23,820
0,90 90,540
of all,

345
00:10:23,980 --> 00:10:26,590
0,540 540,960 960,1560 1560,2220 2250,2610
{} there is a much

346
00:10:26,590 --> 00:10:28,180
0,150 150,780 1110,1350 1350,1470 1470,1590
more concurrency than we have

347
00:10:28,180 --> 00:10:29,320
0,210 210,330 330,660 660,720 720,1140
seen so far,| in fact,
|实际上，这是讨论并发性的开始，

348
00:10:31,290 --> 00:10:32,130
0,180 180,270 270,420 420,720 720,840
you know, so this is

349
00:10:32,130 --> 00:10:34,350
0,240 240,630 630,1530 1560,1920 1920,2220
a starting {} place where

350
00:10:34,350 --> 00:10:36,060
0,360 360,540 540,1290 1440,1620 1620,1710
talking about concurrency| and we'll
|我们将在周三的课程中详细讨论这个问题，

351
00:10:36,060 --> 00:10:37,410
0,210 210,480 480,690 750,990 990,1350
talk about it on Wednesday

352
00:10:37,410 --> 00:10:38,730
0,270 270,330 330,510 510,990 1140,1320
lecture a lot more {},|
|

353
00:10:38,730 --> 00:10:40,020
0,180 180,480 480,1020 1020,1140 1140,1290
the basic observation is that,
基本的观点是，CPU 和生成的设备是并行运行的，

354
00:10:40,020 --> 00:10:41,970
0,330 330,390 390,1320 1350,1800 1800,1950
basically the CPU and the

355
00:10:41,970 --> 00:10:43,500
0,570 570,720 720,1140 1140,1200 1200,1530
device that generated in, this

356
00:10:43,920 --> 00:10:45,300
0,480 480,540 540,1110 1140,1290 1290,1380
operate in parallel,| you know
|你知道有网卡的 UART ，

357
00:10:45,300 --> 00:10:46,800
0,180 180,870 960,1200 1200,1230 1230,1500
the UART with a network

358
00:10:46,800 --> 00:10:47,880
0,420 420,510 510,600 600,840 840,1080
card,| you know just doing
|只是做它的事情，从网络中挑选数据包，

359
00:10:47,880 --> 00:10:49,650
0,210 210,600 600,690 690,930 1260,1770
its thing you know picking

360
00:10:49,650 --> 00:10:51,240
0,330 330,570 570,630 630,1200 1410,1590
packets from the network,| and
|然后在某一时刻产生中断。

361
00:10:51,240 --> 00:10:52,260
0,90 90,180 180,330 330,600 600,1020
then at some point generating

362
00:10:52,260 --> 00:10:53,240
0,60 60,600
an interrupt.|
|

363
00:10:53,240 --> 00:10:54,050
0,180 180,300 300,360 360,600 600,810
And at the same time,
同时，CPU 也在运行，也在做自己的事情，

364
00:10:54,050 --> 00:10:55,070
0,60 60,420 420,480 480,780 780,1020
the CPU is running and

365
00:10:55,070 --> 00:10:55,880
0,240 240,300 300,510 510,630 630,810
also is doing its own

366
00:10:56,060 --> 00:10:57,410
0,270 300,480 480,600 600,930 960,1350
thing,| so we have true
|所以，在设备和 CPU 之间，我们有真正的并行性，

367
00:10:57,410 --> 00:10:59,270
0,780 810,1230 1230,1530 1530,1800 1800,1860
parallelism, going on between the

368
00:10:59,270 --> 00:11:00,830
0,690 690,810 810,870 870,1380 1380,1560
device and the CPU| and
|我们必须管理这种并行性，我们稍后会看到。

369
00:11:00,830 --> 00:11:02,270
0,540 540,660 660,720 720,1110 1110,1440
we have to manage that

370
00:11:02,480 --> 00:11:03,830
0,840 840,990 990,1110 1110,1260 1260,1350
parallelism as we'll see in

371
00:11:03,830 --> 00:11:04,700
0,30 30,360
a second.|
|

372
00:11:05,450 --> 00:11:07,940
0,240 240,870 990,1530 2010,2400 2400,2490
And finally, I'm going to
最后，我将主要关注外部设备，

373
00:11:07,940 --> 00:11:10,280
0,360 360,780 780,1320 1350,1890 1890,2340
focus mostly on external devices,|
|

374
00:11:10,280 --> 00:11:11,450
0,150 150,450 450,810 810,900 900,1170
like network cards and {UART
比如网卡和 UART ，这些必须被编程。

375
00:11:11,450 --> 00:11:12,650
0,420 570,810 810,990 990,1110 1110,1200
-} and those have to

376
00:11:12,650 --> 00:11:13,880
0,120 120,750
be programmed.|
|

377
00:11:19,220 --> 00:11:20,520
0,810

378
00:11:21,310 --> 00:11:23,530
0,180 180,780 780,1170 1170,1830 1860,2220
And basically every device has
每个设备都有自己的编程手册，

379
00:11:23,530 --> 00:11:24,850
0,120 120,240 240,420 420,840 840,1320
{} its own programming manual,|
|

380
00:11:24,850 --> 00:11:26,080
0,330 420,540 540,780 780,930 930,1230
in the same way that
以 RISC-V 同样的方式，包含指令和寄存器作用，

381
00:11:26,080 --> 00:11:27,460
0,120 120,360 360,690 690,870 870,1380
{} {RISC-V -} has manual
RISC-V有说明书和哪些寄存器做什么的手册，

382
00:11:27,460 --> 00:11:29,770
0,210 210,990 990,1500 1500,1830 1830,2310
with instructions and which registers

383
00:11:29,770 --> 00:11:32,110
0,150 150,630 990,1590 1590,1890 1890,2340
do what,| {} every device
|每个设备都有类似的手册，

384
00:11:32,110 --> 00:11:33,490
0,300 300,570 570,630 630,1110 1110,1380
actually has a similar []

385
00:11:33,490 --> 00:11:35,800
0,540 780,1200 1200,1860 1860,1950 1950,2310
manual,| {} with you know
|描述它有什么寄存器，你可以遵循哪些操作，

386
00:11:35,860 --> 00:11:37,960
0,810 810,960 960,1350 1350,1470 1470,2100
describing what register it has,

387
00:11:37,990 --> 00:11:39,100
0,210 210,450 450,900 900,1020 1020,1110
{} what operations you can

388
00:11:39,100 --> 00:11:41,140
0,840 870,1140 1140,1230 1230,1590 1590,2040
conform,| what the device does
|设备对于读取和写入控制寄存器的回应。

389
00:11:41,140 --> 00:11:42,220
0,120 120,210 210,690 690,810 810,1080
come in response to reading

390
00:11:42,220 --> 00:11:43,880
0,120 120,420 420,780 780,1380
and writing control registers.|
|

391
00:11:44,380 --> 00:11:47,770
0,450 570,1050 1050,1590 1890,2850 2970,3390
{} Unfortunately often {} the
不幸的是，设备手册通常不如 RISC-V 手册清楚，

392
00:11:47,800 --> 00:11:49,690
0,600 600,930 930,1230 1230,1710 1710,1890
manuals for the devices are

393
00:11:49,690 --> 00:11:51,070
0,240 240,720 720,930 930,1170 1170,1380
less clear than the {RISC-V

394
00:11:51,070 --> 00:11:53,200
0,270 270,780 960,1650 1650,1920 1920,2130
-} manual| and {} which
|这使得复杂的编程变得更加复杂。

395
00:11:53,200 --> 00:11:54,910
0,240 240,420 420,810 840,1470 1470,1710
makes a complex programming even

396
00:11:54,910 --> 00:11:56,120
0,210 210,870
more complicated.|
|

397
00:11:56,820 --> 00:11:57,960
0,180 180,570 600,930 930,990 990,1140
And so what I'm gonna
我在这节课上要做的其实很简单，

398
00:11:57,960 --> 00:11:58,830
0,180 180,270 270,450 450,780 780,870
do in this lecture is

399
00:11:58,830 --> 00:12:01,170
0,270 300,660 660,1470 1680,2190 2190,2340
actually pretty straightforward,| {} if
|讨论 shell 提示符（$）是如何出现的，

400
00:12:01,170 --> 00:12:03,300
0,90 90,240 240,300 300,870 1110,2130
you want to talk {}

401
00:12:03,300 --> 00:12:06,180
0,630 810,1320 1320,1590 1590,2190 2490,2880
about how the prompt shows

402
00:12:06,180 --> 00:12:07,830
0,420 600,810 810,1320 1320,1440 1440,1650
up, {} when you know

403
00:12:07,830 --> 00:12:10,500
0,210 210,780 810,2160 2160,2250 2250,2670
the shell prompt| and then
|然后如果你键入 ls ，

404
00:12:10,590 --> 00:12:12,360
0,210 210,390 390,660 660,1350 1650,1770
if you type ls,| you
|这些字符是怎么读入的，

405
00:12:12,360 --> 00:12:13,860
0,90 90,300 300,420 420,690 690,1500
know how do these characters

406
00:12:14,100 --> 00:12:16,230
0,840 870,1320 1320,1710 1710,1890 1890,2130
{} get read| and actually
|然后显示在控制台中，

407
00:12:16,230 --> 00:12:17,280
0,210 210,420 420,900 900,990 990,1050
then being displayed in the

408
00:12:17,280 --> 00:12:18,390
0,480 510,660 660,720 720,930 930,1110
console| and in fact, so
|实际上，基本上剩下的课程都是关于这三个字符的，

409
00:12:18,390 --> 00:12:19,470
0,390 390,690 690,870 870,930 930,1080
basically the rest of these

410
00:12:19,470 --> 00:12:21,000
0,390 390,570 570,720 720,900 900,1530
lectures about these three characters,|
|

411
00:12:21,880 --> 00:12:24,340
0,570 1020,1500 1650,1800 1800,1920 1950,2460
Um {} you know, but
以及实现这一目标所必需的的所有机制。

412
00:12:24,340 --> 00:12:25,780
0,150 150,210 210,690 690,870 870,1440
all the mechanism, that's necessary

413
00:12:25,780 --> 00:12:27,130
0,120 120,660 660,840 840,960 960,1350
to actually make that happen.|
|

414
00:12:28,550 --> 00:12:30,290
0,630 780,1080 1080,1350 1350,1440 1440,1740
{} Any questions so far,
到目前为止，在我继续深入讨论之前，有什么问题吗？

415
00:12:30,290 --> 00:12:31,940
0,360 360,390 390,1140 1140,1590 1590,1650
before I [extract] diving a

416
00:12:31,940 --> 00:12:33,200
0,240 240,690
little deeper.|
|

417
00:12:38,470 --> 00:12:40,780
0,630 1080,1740
Okay {}.|
好的。|

418
00:12:41,850 --> 00:12:44,100
0,1170 1440,1650 1650,1830 1830,2070 2070,2250
So the first question maybe
所以可能要问的第一个问题是，中断是从哪里来的。

419
00:12:44,100 --> 00:12:44,940
0,150 150,480 480,540 540,720 720,840
to ask is where did

420
00:12:44,940 --> 00:12:46,480
0,120 120,420 420,600 600,990
the interrupts come from.|

421
00:13:00,330 --> 00:13:01,580
0,750
And,
我们这节课将主要关注外部中断，

422
00:13:01,790 --> 00:13:02,690
0,270 270,540 540,660 660,780 780,900
{} so so we're going

423
00:13:02,690 --> 00:13:03,680
0,60 60,120 120,450 450,840 840,990
to be focusing mostly this

424
00:13:03,680 --> 00:13:05,240
0,270 270,390 390,870 870,1410 1410,1560
lecture on external interrupts,| {you,know}
|不是计时器中断或软件中断，

425
00:13:05,240 --> 00:13:06,980
0,360 360,690 690,1110 1110,1410 1410,1740
not timer interrupts or software

426
00:13:06,980 --> 00:13:09,170
0,510 780,1260 1260,1470 1470,1770 1770,2190
interrupts,| {} {you,know} the external
|外部中断来自电路板上的设备，

427
00:13:09,170 --> 00:13:10,790
0,600 600,810 810,960 960,1500 1500,1620
interrupts come from devices that

428
00:13:10,790 --> 00:13:11,720
0,90 90,300 300,360 360,450 450,930
are sitting on the board|
|

429
00:13:11,810 --> 00:13:14,630
0,630 720,1110 1110,1650 1650,2370 2370,2820
and here are a {SiFive
这是一块 SiFive 电路板，就是 QEMU 模拟的那个，

430
00:13:14,630 --> 00:13:17,270
0,240 240,660 660,1680 1980,2190 2190,2640
-} board, that QEMU more

431
00:13:17,270 --> 00:13:18,320
0,60 60,330 330,900 900,990 990,1050
or less animates,| you know
|这里有一些小的改动，

432
00:13:18,320 --> 00:13:20,900
0,180 180,360 360,720 720,1590 1950,2580
there's some small modifications {},|
|

433
00:13:21,140 --> 00:13:22,490
0,390 390,510 510,690 690,840 840,1350
and we see there's actually
我们看到，你在这块板上看到，

434
00:13:22,490 --> 00:13:23,750
0,270 270,480 480,840 840,1020 1020,1260
you look around from this

435
00:13:23,750 --> 00:13:25,580
0,630 690,1050 1050,1260 1260,1320 1320,1830
board,| {} there's a lot
|那里有很多不同的设备，

436
00:13:25,580 --> 00:13:27,080
0,90 90,360 360,630 630,1050 1050,1500
of actually different devices there,|
|

437
00:13:27,350 --> 00:13:28,550
0,120 120,210 210,630 630,1020 1020,1200
can be connected to this
可以连接到这块板上，

438
00:13:28,550 --> 00:13:29,930
0,300 480,720 720,840 840,1110 1110,1380
board,| here are {Ethernet -}
|这里是以太网连接器，

439
00:13:30,370 --> 00:13:33,640
0,270 270,990 1170,2220 2220,2790 2790,3270
{} connector,| {in,fact} here's {}
|这是 MicroUSB，在那里，

440
00:13:33,640 --> 00:13:35,860
0,390 390,1080 1110,1470 1470,1650 1650,2220
{MicroUSB -}, that's over there,|
|

441
00:13:36,100 --> 00:13:37,720
0,210 210,780 780,870 870,1230 1230,1620
{} there's a {MicroSD -}
这是 MicroSD 卡，

442
00:13:37,720 --> 00:13:40,750
0,600 900,1680 1680,1770 1770,2310 2580,3030
card,| {} you know reset
|这是重置按钮，

443
00:13:40,750 --> 00:13:41,890
0,540 540,780 780,930 930,1050 1050,1140
buttons| and so there are
|这是从这些设备到 CPU 的各种线路。

444
00:13:41,890 --> 00:13:43,090
0,90 90,300 300,690 690,1080 1080,1200
all kinds of lines that

445
00:13:43,090 --> 00:13:44,590
0,240 240,360 360,780 780,1200 1200,1500
must be running running from

446
00:13:44,590 --> 00:13:46,300
0,420 450,1110 1110,1230 1230,1590 1590,1710
those devices {} into the

447
00:13:46,300 --> 00:13:47,240
0,510
CPU.|
|

448
00:13:47,500 --> 00:13:48,490
0,300 300,540 540,600 600,750 750,990
And most of this lecture
这节课的大部分内容是，

449
00:13:48,490 --> 00:13:49,900
0,60 60,450 450,600 600,660 660,1410
is basically sort of| understanding,
|理解当设备发生中断时， CPU 上会发生什么，

450
00:13:49,900 --> 00:13:51,280
0,120 120,240 240,750 750,1260 1260,1380
you know what happens, you

451
00:13:51,280 --> 00:13:53,680
0,120 120,930 930,1020 1020,1770 1800,2400
know at the CPU when

452
00:13:53,680 --> 00:13:56,440
0,120 120,1110 1110,2250 2250,2340 2340,2760
a device generates an interrupt|
|

453
00:13:56,440 --> 00:13:57,130
0,90 90,240 240,360 360,540 540,690
and how to read and
以及如何从设备读取和写入信息。

454
00:13:57,130 --> 00:13:58,480
0,390 390,480 480,1080 1080,1260 1260,1350
write the information from the

455
00:13:58,480 --> 00:13:59,460
0,600
device.|
|

456
00:13:59,760 --> 00:14:01,440
0,540 540,660 660,1260 1260,1470 1470,1680
{} I believe like these
我相信下面的两个针脚，在这个扩展接头上，

457
00:14:01,440 --> 00:14:04,040
0,750 1020,1230 1230,1530 1530,2070
lower two pins here,

458
00:14:04,130 --> 00:14:06,050
0,330 330,720 720,870 870,1410 1410,1920
{} at this expansion connector,|
|

459
00:14:06,050 --> 00:14:07,580
0,0 0,870 870,1290 1290,1380 1380,1530
I think one of them
我想其中一个是用来传输的 UART Tx ，

460
00:14:07,580 --> 00:14:08,900
0,90 90,330 330,810
is {UART -},

461
00:14:08,960 --> 00:14:10,260
0,180 180,660
is the

462
00:14:10,260 --> 00:14:12,690
0,270 270,480 480,1110 1440,1590 1590,2430
{UART -} sent, for transmission|
|

463
00:14:12,720 --> 00:14:13,470
0,150 150,210 210,390 390,630 630,750
and the other one is
另一个是用来接收的 UART0 Re 。

464
00:14:13,470 --> 00:14:14,780
0,90 90,750
the {UART0

465
00:14:15,130 --> 00:14:16,800
0,360 360,1200
-} {}

466
00:14:18,680 --> 00:14:20,700
0,900 930,1500
receive Re.|
|

467
00:14:21,690 --> 00:14:22,500
0,390 390,510 510,570 570,690 690,810
{} And I think it's
<---我认为它实际上与两边都有联系，

468
00:14:22,500 --> 00:14:23,820
0,270 270,630 630,720 720,960 960,1320
actually connected to both sides,|
|

469
00:14:23,820 --> 00:14:24,990
0,90 90,390 390,780 780,930 930,1170
the micro usb as well
微型USB以及通过该延长线，

470
00:14:24,990 --> 00:14:26,040
0,120 120,240 240,390 390,840 840,1050
as to this extension cord,|
--->|

471
00:14:26,040 --> 00:14:26,970
0,90 90,150 150,390 390,570 570,930
and I think the UART
我认为 UART 芯片本身，你可能在那边的芯片里。

472
00:14:26,970 --> 00:14:28,860
0,240 240,930 1050,1320 1320,1650 1650,1890
chip itself, {you,know} might actually

473
00:14:28,860 --> 00:14:30,340
0,150 150,510 510,570 570,1020
be inside of this

474
00:14:30,940 --> 00:14:32,380
0,210 210,450 450,630 630,930
{} chip over there.|
|

475
00:14:37,720 --> 00:14:39,220
0,390 390,930
Okay so,
好的，所以电路板上有很多线到 CPU ，

476
00:14:39,370 --> 00:14:40,420
0,150 150,540 540,660 660,930 930,1050
so basically there are a

477
00:14:40,420 --> 00:14:42,520
0,210 210,300 300,660 660,1230 1620,2100
bunch of lines running on

478
00:14:42,520 --> 00:14:43,660
0,90 90,600 600,690 690,810 810,1140
the board, you know into

479
00:14:43,660 --> 00:14:45,670
0,90 90,660 960,1710 1710,1830 1830,2010
the CPU,| you know we
|我们放大一点，详细看看 CPU ，

480
00:14:45,670 --> 00:14:46,540
0,240 240,600 600,660 660,720 720,870
go zoom in a little

481
00:14:46,540 --> 00:14:47,410
0,120 120,330 330,420 420,810 810,870
bit more in detail in

482
00:14:47,410 --> 00:14:48,620
0,60 60,660
the CPU,|
|

483
00:14:48,620 --> 00:14:51,680
0,600 600,1110 1110,1830 1830,2250 2250,3060
{} {use,a} schema from the
电路板使用 SiFive 文档中的方案，

484
00:14:51,920 --> 00:14:54,240
0,810 840,1170 1170,1740
{} you know,

485
00:14:54,330 --> 00:14:56,640
0,570 570,1170 1170,1710 1710,1800 1800,2310
SiFive documentation for the board|
|

486
00:14:56,640 --> 00:14:57,540
0,270 270,360 360,780 780,840 840,900
or the processor of the
或者电路板的处理器使用 RISC-V 处理器，

487
00:14:57,540 --> 00:15:00,030
0,420 420,810 1560,1830 1830,2070 2070,2490
board were {RISC-V -} processor

488
00:15:00,030 --> 00:15:01,830
0,510 900,1290 1290,1530 1530,1710 1710,1800
using,| {} we looked at
|我们之前看过这个，

489
00:15:01,830 --> 00:15:02,940
0,150 150,210 210,360 360,480 480,1110
this a little bit before,|
|

490
00:15:03,210 --> 00:15:04,890
0,720 720,1080 1080,1260 1260,1470 1470,1680
{} you know see here
看这里，右边是设备，

491
00:15:04,890 --> 00:15:06,450
0,510 510,690 690,780 780,870 870,1560
basically, here are the devices

492
00:15:06,660 --> 00:15:08,580
0,240 240,450 900,1200 1200,1560 1560,1920
on the right side,| here
|这里是 UART0 ，

493
00:15:08,580 --> 00:15:10,590
0,150 150,270 270,960 1290,1890 1890,2010
{UART0 - -}| and we
|我们知道 UART0 内存映射到物理地址空间中的某个位置。

494
00:15:10,590 --> 00:15:11,970
0,450 450,600 600,1050 1050,1230 1230,1380
know that basically that {UART0

495
00:15:11,970 --> 00:15:13,740
0,120 120,600 600,1080 1080,1470 1500,1770
- -} memory maps {somewhere

496
00:15:13,740 --> 00:15:15,180
0,570 570,780 780,900 900,1200 1200,1440
-} in the physical address

497
00:15:15,180 --> 00:15:16,000
0,510
space,|
|

498
00:15:16,140 --> 00:15:18,030
0,300 300,450 450,690 690,1350 1830,1890
like all the DRAM on
这边的所有 DRAM ，

499
00:15:18,030 --> 00:15:19,110
0,210 210,690 690,810 810,960 960,1080
this side,| we know we
|我们知道 DRAM 位于 0x8000 之上，

500
00:15:19,110 --> 00:15:20,940
0,120 120,270 270,780 780,1230 1320,1830
know the DRAM sits above

501
00:15:21,000 --> 00:15:22,590
0,420 420,690 690,900 900,1410 1410,1590
{0x8000 - - -}| and
|而在 0x8000 之下，是不同的设备。

502
00:15:22,590 --> 00:15:24,030
0,540 540,720 720,1170 1170,1290 1290,1440
below {0x8000 -} {} they

503
00:15:24,270 --> 00:15:26,380
0,450 570,1020 1020,1710
are different devices.|
|

504
00:15:26,610 --> 00:15:28,080
0,540 540,750 750,960 960,1050 1050,1470
Basically with load and store
基本上对那些物理地址使用 load 和 store 指令，

505
00:15:28,080 --> 00:15:29,760
0,720 720,840 840,960 960,1110 1110,1680
instructions, you know to those

506
00:15:29,790 --> 00:15:31,580
0,1620
{},

507
00:15:32,070 --> 00:15:33,360
0,120 120,270 270,540 540,990 990,1290
to those physical addresses,| we
|我们实际上可以对 UART 进行编程，

508
00:15:33,360 --> 00:15:34,350
0,120 120,330 330,720 720,810 810,990
can actually program that {UART

509
00:15:34,350 --> 00:15:35,460
0,150 210,510 510,600 600,840 840,1110
-},| look at that in
|稍后会更详细地了解这一点。

510
00:15:35,490 --> 00:15:36,300
0,270 270,360 360,690 690,750 750,810
much more detail in a

511
00:15:36,300 --> 00:15:37,240
0,390
second.|
|

512
00:15:37,800 --> 00:15:39,390
0,360 360,450 450,1080 1080,1290 1290,1590
All the devices can basically
所有设备都可以到达处理器，

513
00:15:39,390 --> 00:15:41,550
0,360 360,450 450,570 570,1320 1440,2160
coming to the processor| and
|真正发生的是这个平台级别的中断间控制器，

514
00:15:41,610 --> 00:15:43,050
0,360 360,540 540,930 930,1020 1020,1440
really what happens is this

515
00:15:43,580 --> 00:15:46,070
0,540 540,900 900,1440 1470,2010 2010,2490
platform level inter- interrupt controller,|
|

516
00:15:46,070 --> 00:15:47,360
0,180 180,240 240,510 540,960 960,1290
which is called PLIC for
简称为 PLIC ，

517
00:15:47,360 --> 00:15:48,400
0,450
short,|
|

518
00:15:48,430 --> 00:15:49,510
0,270 270,480 480,540 540,900 900,1080
{} is the one that
是对外部设备中断的管理者。

519
00:15:49,510 --> 00:15:51,100
0,150 150,300 300,840 840,1380 1380,1590
sort of general managers, the

520
00:15:51,100 --> 00:15:52,810
0,480 480,780 780,1200 1380,1560 1560,1710
interrupts coming in, you know,

521
00:15:52,810 --> 00:15:55,400
0,630 660,1020 1020,1440 1440,2160
from {} external devices.|
|

522
00:15:55,670 --> 00:15:56,600
0,240 240,450 450,570 570,660 660,930
And so if we zoom
所以如果我们再放大一点，

523
00:15:56,600 --> 00:15:57,590
0,90 90,150 150,330 330,450 450,990
in a little bit more,|
|

524
00:15:57,980 --> 00:16:00,200
0,540 540,960 960,1230 1260,2010 2010,2220
{} here's a diagram of
这是片上设备 PLIC 的示意图，

525
00:16:00,200 --> 00:16:03,200
0,450 840,1230 1230,1470 1470,1980 2280,3000
the {} the PLIC {}

526
00:16:03,200 --> 00:16:04,760
0,390 390,630 630,750 750,1050 1050,1560
in {} {on-chip -} devices,|
|

527
00:16:04,760 --> 00:16:05,990
0,150 150,390 390,480 480,720 720,1230
so here we see there's
这里看到，有 53 条中断线路来自不同的设备。

528
00:16:05,990 --> 00:16:08,030
0,60 60,210 210,1020 1110,1650 1650,2040
you know 53 interrupt lines

529
00:16:08,030 --> 00:16:09,710
0,360 360,690 690,1110 1140,1380 1380,1680
coming in from {} different

530
00:16:09,710 --> 00:16:10,820
0,750
devices,|
|

531
00:16:10,980 --> 00:16:12,450
0,360 360,660 660,780 780,1260 1260,1470
{} probably, {} devices on
可能，中断线路上的设备，进入 PLIC ，

532
00:16:12,450 --> 00:16:13,680
0,360 360,690 690,810 810,1020 1020,1230
interrupt line, they come into

533
00:16:13,680 --> 00:16:15,660
0,120 120,570 900,1650 1650,1740 1740,1980
the PLIC| and the PLIC
|然后 PLIC 路由这些中断。

534
00:16:15,660 --> 00:16:17,420
0,180 180,600 600,1230
and route interrupts.|
|

535
00:16:24,410 --> 00:16:25,640
0,210 210,300 300,900 960,1140 1140,1230
So, for example you know
举个例子，这取决于，

536
00:16:25,640 --> 00:16:27,770
0,660 660,1410 1410,1560 1560,1830 1830,2130
depending {},| so here are
|所以这是我们的核心，

537
00:16:27,770 --> 00:16:29,540
0,180 180,570 570,1260
our particular cores,|
|

538
00:16:29,970 --> 00:16:31,380
0,300 300,450 450,840 870,1200 1200,1410
here in our way, we
在这里，我们运行的是三个内核，

539
00:16:31,380 --> 00:16:32,250
0,210 210,360 360,450 450,750 750,870
run it, we run {}

540
00:16:32,250 --> 00:16:36,480
0,180 180,780 1110,2130 2130,2850 2910,4230
three cores {}| and basically
|PLIC 是可以编程的，

541
00:16:36,480 --> 00:16:37,170
0,120 120,240 240,360 360,600 600,690
you know the PLIC can

542
00:16:37,170 --> 00:16:39,210
0,150 150,810 960,1290 1290,1950 1950,2040
be programmed,| so that the
|所以 PLIC 将中断交给这些核心中的一个或者第一个，

543
00:16:39,210 --> 00:16:40,560
0,210 210,330 330,690 690,1170 1170,1350
PLIC will raise interrupts to,

544
00:16:40,560 --> 00:16:41,850
0,210 210,450 450,540 540,720 720,1290
{you,know}, one of these cores

545
00:16:41,880 --> 00:16:43,080
0,270 270,360 360,450 450,750 750,1200
or to the first core,|
|

546
00:16:43,080 --> 00:16:44,310
0,210 210,330 330,570 570,630 630,1230
that can take an interrupt
它可以获得中断，

547
00:16:44,550 --> 00:16:46,260
0,780 780,990 990,1470 1470,1560 1560,1710
{} |and there's a bit
|而且有一些灵活性。

548
00:16:46,260 --> 00:16:47,460
0,60 60,780
of flexibility.|
|

549
00:16:47,760 --> 00:16:48,660
0,270 270,480 480,570 570,630 630,900
{And,if} none of the cores
如果此时没有一个核心可以接受中断，

550
00:16:48,660 --> 00:16:50,100
0,150 150,360 360,450 450,1140 1140,1440
can take an interrupted at

551
00:16:50,100 --> 00:16:51,000
0,150 150,450 450,510 510,810 810,900
this point,| for example they
|比如它们禁用了中断，

552
00:16:51,000 --> 00:16:52,560
0,150 150,600 600,1020 1020,1230 1230,1560
have disabled interrupts,| because their
|因为他们在处理另一个中断，

553
00:16:52,800 --> 00:16:54,690
0,720 720,990 990,1500 1590,1800 1800,1890
processing another interrupt| and the
|PLIC 将持有这个中断，

554
00:16:54,690 --> 00:16:56,670
0,240 240,390 390,540 540,1140 1530,1980
PLIC will just hold {}

555
00:16:56,670 --> 00:16:58,920
0,180 180,720 720,1410 1470,2190 2190,2250
that interrupt| until {you,know} a
|直到有处理器可以处理中断。

556
00:16:58,920 --> 00:17:00,300
0,270 270,330 330,930 930,1140 1140,1380
processor is available to take

557
00:17:00,300 --> 00:17:01,340
0,90 90,630
{} interrupt.|
|

558
00:17:02,130 --> 00:17:03,510
0,540 840,930 930,1140 1140,1260 1260,1380
So the PLIC has some
所以 PLIC 有一些内部状态来记录这些。

559
00:17:03,510 --> 00:17:05,400
0,390 390,900 900,990 990,1140 1140,1890
internal state, you know to

560
00:17:05,430 --> 00:17:06,900
0,270 270,510 510,570 570,900
keep track of that.|
|

561
00:17:06,930 --> 00:17:08,580
0,180 180,600 630,960 960,1140 1140,1650
If you saw the documentation
如果你看一下文档，

562
00:17:08,580 --> 00:17:09,270
0,30 30,180 180,420 420,600 600,690
a little bit,| in a
|PLIC 中真正发生的是，

563
00:17:09,270 --> 00:17:10,350
0,390 390,480 480,600 600,840 840,1080
way you know real things

564
00:17:10,350 --> 00:17:11,460
0,90 90,540 540,720 720,840 840,1110
are happening is the PLIC,|
|

565
00:17:11,460 --> 00:17:13,620
0,480 480,630 630,780 780,1260 1560,2160
indicates that {there,is} a interrupt,|
表示有一个中断，等待其中一个核心，声称拥有它，|

566
00:17:13,650 --> 00:17:15,510
0,810 1050,1410 1410,1650 1650,1770 1770,1860
pending {} one of the

567
00:17:15,510 --> 00:17:17,160
0,600 600,720 720,780 780,1200 1200,1650
cores, you know basically claims

568
00:17:17,160 --> 00:17:19,440
0,330 690,1440 1860,2010 2010,2160 2160,2280
it,| {} so that will
|所以这告诉 PLIC 不要给任何其他核心，

569
00:17:19,440 --> 00:17:20,430
0,180 180,300 300,540 540,750 750,990
tell the PLIC not to

570
00:17:20,430 --> 00:17:21,720
0,180 180,300 300,480 480,690 690,1290
give to any other core|
|

571
00:17:21,870 --> 00:17:23,070
0,450 450,720 720,870 870,1110 1110,1200
and once the core is
一旦核心完全完成，

572
00:17:23,070 --> 00:17:24,180
0,330 330,600 600,780 780,990 990,1110
completely done with it,| {it,will}
|它会说好的，我完成了这个中断，

573
00:17:24,180 --> 00:17:25,350
0,210 210,570 570,780 780,1020 1020,1170
say OK I'm done with

574
00:17:25,350 --> 00:17:26,940
0,120 120,480 480,1020 1020,1470 1470,1590
this particular interrupt| and you
|然后 PLIC 会，

575
00:17:26,940 --> 00:17:29,340
0,210 210,660 720,1050 1050,1680 1980,2400
know the PLIC will,| inform
|通知 PLIC 可以忘记这个中断。

576
00:17:29,340 --> 00:17:30,900
0,90 90,300 300,450 450,990 1230,1560
the PLIC that [] this

577
00:17:31,470 --> 00:17:33,000
0,450 480,750 750,960 960,1050 1050,1530
can forget about this interrupt.|
|

578
00:17:35,770 --> 00:17:37,520
0,240 240,600 600,810 810,1230
Any questions about this?|
有任何关于这个的问题吗？|

579
00:17:37,730 --> 00:17:39,230
0,240 240,390 390,480 480,810 840,1500
There's sort of the internal
这是 RISC-V 的内部中断结构。

580
00:17:39,230 --> 00:17:40,640
0,240 240,870
{RISC-V -}

581
00:17:41,140 --> 00:17:42,760
0,450 450,1080
interrupt structure.|
|

582
00:17:44,140 --> 00:17:46,090
0,270 270,600 600,840 840,1320 1320,1950
Yeah, so when each core
是的，所以当每个核心持有 PLIC 时，

583
00:17:46,600 --> 00:17:48,010
0,420 420,570 570,1020 1050,1290 1290,1410
holds the PLIC,| does the
|PLIC 是否有某种执行机制来确保公平。

584
00:17:48,010 --> 00:17:50,230
0,270 270,510 510,840 840,1500 1500,2220
PLIC have some enforcement mechanism

585
00:17:50,410 --> 00:17:52,160
0,270 270,630 630,1260
to ensure fairness.|
|

586
00:17:52,520 --> 00:17:54,380
0,690 690,1530 1530,1620 1620,1740 1740,1860
{} It is all up
这一切都取决于内核，

587
00:17:54,380 --> 00:17:55,640
0,90 90,180 180,600 660,840 840,1260
to the kernel| to program
|以任何它想要的方式对 PLIC 进行编程。

588
00:17:55,640 --> 00:17:58,040
0,1080 1140,1620 1650,1860 1860,2220 2220,2400
the PLIC in whatever way

589
00:17:58,040 --> 00:17:59,140
0,120 120,600
it wants.|
|

590
00:17:59,330 --> 00:18:01,490
0,690 690,810 1110,1470 1470,1680 1680,2160
{} {You,know} PLIC doesn't really,
PLIC 不是真的选择传送中断服务，[写入它们]，

591
00:18:01,670 --> 00:18:04,160
0,510 840,1260 1260,1680 1680,2070 2070,2490
{} choosing service of delivering

592
00:18:04,160 --> 00:18:05,360
0,480 480,750 750,960 960,1140 1140,1200
interrupted [writing them],| but it
|但是从内核程序获取[]，将中断传递到哪里，等等。

593
00:18:05,360 --> 00:18:06,860
0,210 210,300 300,750 750,1200 1200,1500
takes the kernel programs []

594
00:18:06,860 --> 00:18:08,810
0,630 780,1410 1410,1740 1740,1860 1860,1950
[] where interrupts should be

595
00:18:08,810 --> 00:18:10,460
0,510 540,1170
delivered, etc.|
|

596
00:18:10,460 --> 00:18:11,300
0,180 180,270 270,480 480,600 600,840
{} In fact, you know
实际上，有优先级的中断，

597
00:18:11,390 --> 00:18:13,640
0,360 360,480 480,1290 1350,2100 2100,2250
interrupts with priorities,| {the,kernel} could
|内核可以决定哪个中断比另一个中断更重要，

598
00:18:13,640 --> 00:18:14,870
0,360 360,570 570,930 930,1020 1020,1230
decide which interrupt is more

599
00:18:14,870 --> 00:18:16,700
0,420 420,540 540,840 840,1470 1530,1830
important than another interrupt {},|
|

600
00:18:16,700 --> 00:18:17,600
0,210 210,240 240,630 630,840 840,900
there's a huge amount of
这里有很大的灵活性。

601
00:18:17,600 --> 00:18:18,820
0,720
flexibility.|
|

602
00:18:26,370 --> 00:18:27,660
0,240 240,390 390,960 990,1200 1200,1290
Any other questions about the
关于硬件的任何其他问题？

603
00:18:27,660 --> 00:18:28,740
0,570
hardware?|
|

604
00:18:33,930 --> 00:18:35,120
0,630
Okay.|
好的。|

605
00:18:35,320 --> 00:18:36,540
0,690

606
00:18:37,640 --> 00:18:38,720
0,210 210,330 330,630 630,690 690,1080
Okay, so that's the hardware
好的，这就是它的硬件方面，

607
00:18:38,720 --> 00:18:40,130
0,270 270,390 390,660 750,1320 1320,1410
side of it,| {} {you,know}
|让我们从高层次上谈一下软件方面的问题。

608
00:18:40,130 --> 00:18:41,420
0,240 270,540 540,570 600,1080 1080,1290
let's talk a little bit

609
00:18:41,420 --> 00:18:42,290
0,240 240,330 330,390 390,570 570,870
{you,know}, at a high level

610
00:18:42,290 --> 00:18:43,900
0,210 210,270 270,600 600,1080
about the software side.|
|

611
00:18:44,360 --> 00:18:47,420
0,570 930,1650 1860,2340 2370,2820 2820,3060
{} So, {} typically the
通常情况下，管理设备的代码称为驱动程序。

612
00:18:47,420 --> 00:18:49,520
0,570 600,780 780,1380 1380,1920 1920,2100
code that manages devices called

613
00:18:49,520 --> 00:18:50,680
0,60 60,630
the driver.|
|

614
00:19:00,230 --> 00:19:01,610
0,510 510,810 810,900 900,960 960,1380
{} And you know basically
你知道，基本上就是代码，

615
00:19:02,780 --> 00:19:04,730
0,240 240,690 690,1320 1320,1530 1530,1950
these {} just just code,|
|

616
00:19:04,760 --> 00:19:06,470
0,540 540,630 630,930 960,1320 1320,1710
{} you know typically {in,kernels},
通常内核查看 C 代码，

617
00:19:06,470 --> 00:19:07,910
0,450 510,900 900,1050 1050,1170 1170,1440
the kernels will be looking

618
00:19:07,910 --> 00:19:10,460
0,330 480,720 720,1230 1350,2040 2040,2550
at C code| {} and
|在 xv6 中，所有的驱动程序都在内核内部，

619
00:19:10,460 --> 00:19:11,510
0,270 270,660 660,780 780,870 870,1050
{in,xv6 -}, you know all

620
00:19:11,510 --> 00:19:12,890
0,60 60,540 540,900 900,1320 1320,1380
the drivers are inside of

621
00:19:12,890 --> 00:19:16,020
0,90 90,690 930,1860 1890,2670
the kernel| and {
|这些用于管理的代码就是驱动程序，

622
00:19:16,320 --> 00:19:17,760
0,540 540,900 900,1020 1020,1350 1350,1440
- -} the code, you

623
00:19:17,760 --> 00:19:19,110
0,210 210,600 600,1080 1080,1260 1260,1350
know basically managing were the

624
00:19:19,110 --> 00:19:21,330
0,690 960,1680 1680,1860 1860,2160 2160,2220
drivers| are all inside of
|都在内核内部。

625
00:19:21,330 --> 00:19:22,340
0,60 60,480
the kernel.|
|

626
00:19:22,580 --> 00:19:23,660
0,360 360,570 570,690 690,810 810,1080
{} And so we got
所以我们今天来看一下，

627
00:19:24,050 --> 00:19:25,040
0,300 300,450 450,630 630,720 720,990
one we're gonna be looking

628
00:19:25,040 --> 00:19:25,970
0,90 90,270 270,390 390,840 840,930
a little bit today,| you
|你知道 uart.c 是 UART 芯片的驱动程序。

629
00:19:25,970 --> 00:19:27,680
0,240 510,780 780,1080 1080,1530 1530,1710
know {uart.c - -} is

630
00:19:27,680 --> 00:19:30,320
0,90 90,660 660,1260 1350,2190
the driver for {uart,chip}.|
|

631
00:19:30,860 --> 00:19:31,820
0,540 540,630 630,720 720,870 870,960
And if you look at
如果你看一下代码的内部结构，

632
00:19:31,820 --> 00:19:33,140
0,720
the

633
00:19:33,230 --> 00:19:35,870
0,870 1080,1470 1470,1980 1980,2100 2100,2640
structure, internal structure of the

634
00:19:36,170 --> 00:19:37,400
0,270 270,540 540,930 930,960 960,1230
{} that code,| you know
|大多数驱动都有一种结构。

635
00:19:37,400 --> 00:19:40,670
0,510 510,1020 1020,1620 1650,2310 2460,3270
most drivers have a structure.|
|

636
00:19:41,350 --> 00:19:42,640
0,300 300,420 420,600 600,870 870,1290
Yeah I'm gonna draw this,|
我来画一下，|

637
00:19:42,940 --> 00:19:44,140
0,450 450,540 540,630 630,900 900,1200
not as an address space,
不是作为地址空间，不是使用地址空间，

638
00:19:44,140 --> 00:19:44,890
0,30 30,240 240,570 570,660 660,750
are not intending to be

639
00:19:44,890 --> 00:19:46,150
0,210 210,540 540,780 780,930 930,1260
using address space,| but typically
|但通常情况下，当人们谈论驱动时，

640
00:19:46,150 --> 00:19:47,530
0,180 180,420 420,660 660,840 840,1380
when people talk about drivers,|
|

641
00:19:47,620 --> 00:19:49,360
0,300 300,360 360,690 690,1200
there's a bottom part
会有底部和顶部。

642
00:19:50,100 --> 00:19:51,600
0,150 150,240 240,510 510,930
and the top part.|
|

643
00:19:54,500 --> 00:19:56,450
0,540 660,1140 1140,1260 1260,1530 1530,1950
And basically the bottom part
一般底部是中断处理程序。

644
00:19:56,450 --> 00:19:58,100
0,90 90,270 270,630 630,1140
is the interrupt handler.|
|

645
00:20:03,080 --> 00:20:04,400
0,180 180,360 360,420 420,810 810,1320
So when an interrupt handler,
所以中断处理程序，当中断进入时，

646
00:20:04,400 --> 00:20:05,510
0,150 150,240 240,540 540,720 720,1110
when an interrupt comes in,|
|

647
00:20:05,540 --> 00:20:06,650
0,60 60,210 210,450 450,1020 1020,1110
you know the processor, the
如果处理器， CPU 启用了中断，中断将会触发，

648
00:20:06,650 --> 00:20:09,380
0,390 390,720 720,1170 1170,1800 2130,2730
CPU has interruption enabled {},

649
00:20:09,380 --> 00:20:11,120
0,510 540,960 960,1050 1050,1620 1620,1740
the interrupt will fire,| you
|处理器随后会看到，

650
00:20:11,120 --> 00:20:12,590
0,90 90,270 270,750 750,1110 1110,1470
know, the processor will {}

651
00:20:12,920 --> 00:20:14,480
0,270 270,330 330,690 690,900 900,1560
seeing {in,a} second,| will actually
|调用该设备的中断处理程序，

652
00:20:14,870 --> 00:20:16,310
0,390 390,540 540,870 870,1290 1290,1440
call the interrupt handler for

653
00:20:16,310 --> 00:20:18,320
0,150 150,930 1020,1500 1500,1830 1830,2010
that device| basically calls into
|就是调用这里的代码。

654
00:20:18,320 --> 00:20:19,460
0,120 120,390 390,750
the code here.|
|

655
00:20:19,910 --> 00:20:21,230
0,420 420,540 540,630 630,960 960,1320
{} And the interrupt handler
并且中断处理程序运行在，任何特定进程的任意上下文中，

656
00:20:21,230 --> 00:20:24,710
0,300 330,810 810,1380 1380,2340 2700,3480
just runs in, {} run

657
00:20:24,710 --> 00:20:26,030
0,120 120,450 510,1110 1110,1170 1170,1320
in any context of any

658
00:20:26,030 --> 00:20:27,740
0,480 480,1050 1050,1170 1170,1350 1350,1710
specific process,| you know just
|就是引发中断的进程。

659
00:20:27,770 --> 00:20:29,570
0,90 90,360 630,1350 1350,1530 1530,1800
you know process, just process

660
00:20:29,570 --> 00:20:31,500
0,90 90,390 390,960 990,1470
the { -} interrupt.|
|

661
00:20:32,240 --> 00:20:33,590
0,240 240,630 630,1080 1110,1230 1230,1350
The top part, if you
驱动程序的顶部是，

662
00:20:33,590 --> 00:20:35,690
0,300 300,390 390,1020 1320,1770 1770,2100
will the driver {} is|
|

663
00:20:35,690 --> 00:20:38,180
0,630 930,1290 1290,2010 2010,2400 2400,2490
where user processes or you
是用户进程或者其他内核要调用的，

664
00:20:38,180 --> 00:20:38,690
0,90 90,180 180,360 360,420 420,510
know the rest of the

665
00:20:38,690 --> 00:20:40,160
0,270 270,510 510,810 810,990 990,1470
kernel calls into| for example
|比如 console 的例子，

666
00:20:40,160 --> 00:20:41,240
0,90 90,150 150,510 510,840 840,1080
and the console case {correct

667
00:20:41,240 --> 00:20:42,780
0,330 330,540 540,690 690,990
-}| where {UART -},
|UART 有读写接口，

668
00:20:42,840 --> 00:20:44,980
0,270 270,570 570,870 870,1620
there's {read/write -} interface,|
|

669
00:20:46,320 --> 00:20:48,520
0,300 300,690 690,1260 1260,1620
{} that actually, {}
是更高级别的代码调用的，

670
00:20:48,730 --> 00:20:52,330
0,60 60,1620 2190,2970 2970,3210 3210,3600
the {} higher level code

671
00:20:52,330 --> 00:20:54,220
0,270 270,540 540,930 1350,1680 1680,1890
actually calls into| and so
|通常情况下，在驱动程序中经常会有一些队列，

672
00:20:54,220 --> 00:20:55,720
0,420 420,900 900,1200 1200,1380 1380,1500
typically cases actually there's some

673
00:20:55,720 --> 00:20:57,400
0,450 450,810 810,930 930,1020 1020,1680
queue often in the driver|
|

674
00:20:57,610 --> 00:20:59,380
0,660 660,810 810,1170
and you know
顶部代码调用，将字符放入队列中，

675
00:20:59,500 --> 00:21:01,000
0,450 450,660 660,1110 1110,1200 1200,1500
top level code, you know

676
00:21:01,060 --> 00:21:02,440
0,330 330,720 720,1170 1170,1260 1260,1380
calls in, sticks you know

677
00:21:02,440 --> 00:21:05,440
0,480 480,1500 2010,2550 2550,2820 2820,3000
characters into {} into this

678
00:21:05,440 --> 00:21:07,570
0,450 450,810 810,900 900,1290 1290,2130
queue| and the interrupt handler,
|而中断处理程序放入或，

679
00:21:07,570 --> 00:21:09,250
0,90 90,330 360,630 630,930 1320,1680
you know puts or,| depending
|根据发送或接收，

680
00:21:09,250 --> 00:21:10,540
0,90 90,420 420,480 480,1110 1110,1290
on sending or receiving,| but
|如果是接受，

681
00:21:10,540 --> 00:21:12,220
0,120 120,240 240,990 1020,1440 1440,1680
if it's a receiving,| maybe
|也许中断处理程序也会将字符放入队列中。

682
00:21:12,220 --> 00:21:13,540
0,450 450,630 630,840 840,960 960,1320
interrupt handler else will stick

683
00:21:14,970 --> 00:21:17,600
0,570 750,990 990,1410 1410,2130
actually a character's {into,queues}.|
|

684
00:21:17,850 --> 00:21:18,570
0,210 210,330 330,450 450,570 570,720
We'll see you have these
我们会看到，使用这些队列可以使顶部和底部解耦，

685
00:21:18,570 --> 00:21:20,040
0,420 420,600 600,1020 1020,1380 1380,1470
queues are basically used to

686
00:21:20,040 --> 00:21:21,120
0,480 480,570 570,900 900,1020 1020,1080
decouple the top and the

687
00:21:21,120 --> 00:21:22,410
0,240 240,510 510,660 660,840 840,1290
bottom part from each other|
|

688
00:21:22,770 --> 00:21:24,570
0,660 660,1140 1140,1260 1260,1710 1710,1800
and allowing the device to
并且允许设备与 CPU 上的其他代码并行运行。

689
00:21:24,570 --> 00:21:26,370
0,390 390,510 510,1110 1110,1680 1710,1800
run in parallel with the

690
00:21:26,370 --> 00:21:27,180
0,210 210,270 270,360 360,660 660,810
rest of the code on

691
00:21:27,180 --> 00:21:28,280
0,90 90,570
the CPU.|
|

692
00:21:28,800 --> 00:21:30,060
0,750

693
00:21:30,150 --> 00:21:32,370
0,540 990,1230 1230,1590 1590,1890 1890,2220
And the interrupt handler, typically
中断处理程序，通常对中断处理程序有一些限制，

694
00:21:32,370 --> 00:21:33,240
0,90 90,120 120,270 270,780 780,870
there are some restrictions on

695
00:21:33,240 --> 00:21:34,380
0,90 90,420 420,750 750,990 990,1140
the interrupt handler,| because those
|因为它们运行在任何上下文中，

696
00:21:34,380 --> 00:21:35,760
0,60 60,300 300,420 420,630 630,1380
are run in any context,|

697
00:21:35,760 --> 00:21:37,890
0,60 60,1080 1080,1320 1320,1680 1680,2130
you know any process context,
在你可以调用 copyin 或 copyout 的进程上下文中，

698
00:21:37,890 --> 00:21:39,570
0,330 330,420 420,870 870,1170 1170,1680
generally you can call copyin

699
00:21:39,570 --> 00:21:41,610
0,120 120,450 450,810 1020,1650 1650,2040
or {copyout -},| {} because
|因为当前页表，

700
00:21:41,610 --> 00:21:43,530
0,300 630,1050 1230,1410 1410,1710 1710,1920
you know the current page

701
00:21:43,530 --> 00:21:44,970
0,330 330,540 540,750 750,1020 1020,1440
table| might actually not be
|可能不是对应页表，

702
00:21:44,970 --> 00:21:47,370
0,540 540,840 840,1290 1650,1980 1980,2400
reflective of the page table|
|

703
00:21:47,370 --> 00:21:48,660
0,270 300,750 750,750 750,1200 1200,1290
{that's -} a process to
进程的字符应该[复制]。

704
00:21:48,660 --> 00:21:50,130
0,300 300,660 660,840 840,930 930,1470
which character should be copied.|
|

705
00:21:50,960 --> 00:21:52,070
0,150 150,240 240,390 390,540 540,1110
And so it's the upper
所以驱动程序的上部，通常与用户进程进行交互，

706
00:21:52,130 --> 00:21:54,080
0,390 390,480 480,570 570,1140 1170,1950
part of the driver generally

707
00:21:54,080 --> 00:21:55,280
0,210 210,330 330,840 840,960 960,1200
does the interaction with user

708
00:21:55,280 --> 00:21:57,020
0,210 210,810 810,960 960,1230 1230,1740
level processes| and maybe called
|可能调用 copyin 或 copyout 。

709
00:21:57,020 --> 00:21:58,720
0,480 480,570 570,930 930,1200
copyin the {copyout -}.|
|

710
00:22:01,280 --> 00:22:02,600
0,210 210,570 570,780 780,1170 1170,1320
Any questions about this high
对这张高级别（示例）图片有什么问题吗？

711
00:22:02,600 --> 00:22:03,840
0,690
level

712
00:22:04,160 --> 00:22:05,280
0,720
picture?|
|

713
00:22:07,630 --> 00:22:08,650
0,420 420,600 600,660 660,840 840,1020
We'll look at it in
我们会更详细地研究它，

714
00:22:08,650 --> 00:22:09,880
0,300 300,330 330,480 480,600 600,1230
quite a bit more detail,|
|

715
00:22:09,910 --> 00:22:10,870
0,390 390,690 690,750 750,900 900,960
but this is sort of
但这是典型驱动程序的主要组织方式，

716
00:22:10,870 --> 00:22:12,100
0,180 180,720
the main

717
00:22:13,160 --> 00:22:15,200
0,690 690,810 810,1290 1290,1530 1530,2040
organization of a typical driver,|
|

718
00:22:15,470 --> 00:22:16,730
0,270 270,390 390,660 660,750 750,1260
if you're going to realize,
如果你注意到，操作系统中有很多驱动程序，

719
00:22:16,730 --> 00:22:17,480
0,90 90,210 210,450 450,510 510,750
you know there are many

720
00:22:17,480 --> 00:22:18,860
0,540 540,630 630,720 720,1080 1080,1380
drivers in an operating system,|
|

721
00:22:18,860 --> 00:22:21,710
0,90 90,480 870,1650 1650,1950 2400,2850
in fact, {} it's quite
实际上，有些驱动程序代码比内核本身要大是很常见的。

722
00:22:21,710 --> 00:22:23,000
0,450 450,630 630,780 780,1020 1020,1290
common, that you know some

723
00:22:23,000 --> 00:22:24,020
0,150 150,240 240,600 600,930 930,1020
of the driver code is

724
00:22:24,020 --> 00:22:25,880
0,360 360,810 810,990 990,1560 1560,1860
quite bigger or larger than

725
00:22:25,880 --> 00:22:28,620
0,390 840,1380 1380,1770 1770,2340
the core kernel itself.|
|

726
00:22:29,060 --> 00:22:30,440
0,180 180,480 480,900 900,1050 1050,1380
And mostly because for every
最主要的原因是，对于每个设备，你需要一个驱动程序。

727
00:22:30,440 --> 00:22:31,850
0,510 510,630 630,960 960,1050 1050,1410
device, you need to drive-,

728
00:22:31,880 --> 00:22:32,900
0,330 330,390 390,540 540,570 570,1020
{} you need a driver.|
|

729
00:22:33,720 --> 00:22:34,950
0,450 450,750 750,1080 1080,1200 1200,1230
And most computers have a
而且大多数计算机都有很多设备。

730
00:22:34,950 --> 00:22:36,320
0,150 150,210 210,900
lot of devices.|
|

731
00:22:42,520 --> 00:22:44,050
0,390 420,990 1050,1350 1350,1470 1470,1530
Okay, so let's talk a
好的，让我们来谈谈对设备编程。

732
00:22:44,050 --> 00:22:45,670
0,210 210,330 330,510 510,990 990,1620
little bit about programming devices.|
|

733
00:22:55,280 --> 00:22:56,840
0,480 480,660 660,1020 1020,1470 1470,1560
And so typically programming is
通常，设备编程使用内存映射 IO 。

734
00:22:56,840 --> 00:22:58,700
0,510 630,1050 1050,1320 1320,1590 1590,1860
done {} using memory mapped

735
00:22:58,700 --> 00:22:59,900
0,570
IO.|
|

736
00:23:06,450 --> 00:23:07,890
0,360 360,600 600,840 840,1140 1140,1440
{} So as we've seen
正如我们在 RISC-V 或 SiFive 电路板上看到的，

737
00:23:07,890 --> 00:23:09,900
0,270 270,990 990,1380 1380,1590 1590,2010
in {} in {RISC-V -}

738
00:23:09,900 --> 00:23:11,190
0,300 300,390 390,540 540,900 900,1290
or in the SiFive board,|
|

739
00:23:11,190 --> 00:23:14,190
0,90 90,600 1050,1950 2070,2790 2790,3000
you know, {} devices show
设备出现在物理地址空间的特定地址，

740
00:23:14,190 --> 00:23:15,750
0,120 120,210 210,600 600,1260 1290,1560
up at particular addresses in

741
00:23:15,750 --> 00:23:19,020
0,1020 1860,2160 2160,2430 2430,2820 2820,3270
the physical address space,| this
|这是由设备电路板制造商决定。

742
00:23:19,020 --> 00:23:20,580
0,120 120,630 630,870 870,1170 1170,1560
is decided by the device

743
00:23:20,700 --> 00:23:22,620
0,630 630,1470
board manufacturer.|
|

744
00:23:22,770 --> 00:23:24,240
0,600 600,810 810,900 900,1170 1170,1470
And {you,know} {} operating system
操作系统需要知道，

745
00:23:24,240 --> 00:23:25,230
0,150 150,210 210,390 390,570 570,990
needs to know,| what those
|这些设备位于物理内存空间中的哪个位置，

746
00:23:25,710 --> 00:23:27,510
0,330 330,750 870,1230 1230,1320 1320,1800
were those devices are located

747
00:23:27,510 --> 00:23:29,130
0,60 60,150 150,540 540,1110 1260,1620
in the physical {} memory

748
00:23:29,130 --> 00:23:31,380
0,570 780,1050 1050,1290 1290,1710 1710,2250
space,| and then basically programs
|然后对它们进行编程，

749
00:23:31,380 --> 00:23:33,840
0,360 360,1110 1350,2070 2070,2370 2370,2460
them,| using ordinary load and
|对这些地址使用普通的加载存储指令。

750
00:23:33,840 --> 00:23:35,420
0,300 300,1140
store instructions

751
00:23:35,790 --> 00:23:38,250
0,690 900,1320 1320,1620 1620,1830 1830,2460
{} to {} those addresses.|
|

752
00:23:39,000 --> 00:23:40,770
0,690 720,1050 1050,1440 1440,1590 1590,1770
{} But basically what these
这些加载存储指令所做的是，

753
00:23:40,770 --> 00:23:42,960
0,240 240,450 450,930 930,1440 1500,2190
load store instructions do is|
|

754
00:23:43,020 --> 00:23:45,260
0,840 930,1710
they {}
它们读或写设备的控制寄存器。

755
00:23:45,430 --> 00:23:47,560
0,210 210,390 390,390 390,1050 1350,2130
they read or write {},

756
00:23:48,040 --> 00:23:49,600
0,330 330,450 450,1020
read or write

757
00:23:49,750 --> 00:23:51,580
0,510 510,1230
control registers

758
00:23:53,660 --> 00:23:55,140
0,210 210,300 300,870
of the device.|
|

759
00:24:00,200 --> 00:24:01,700
0,150 150,390 390,810 810,1080 1080,1500
And so typically when you
所以，当你在其中一个控制寄存器中存储某些内容时，

760
00:24:02,120 --> 00:24:03,500
0,390 390,900 900,1110 1110,1320 1320,1380
store something in one of

761
00:24:03,500 --> 00:24:05,330
0,60 60,390 390,1050 1170,1440 1440,1830
the control registers| that causes
|发送你的数据包，

762
00:24:05,330 --> 00:24:06,290
0,120 120,420 420,510 510,630 630,960
your packet to be sent,|
|

763
00:24:06,290 --> 00:24:07,430
0,210 210,510 510,660 660,900 900,1140
so instead of reading, writing
所以不是读或写内存，

764
00:24:07,430 --> 00:24:09,170
0,630 690,1110 1110,1320 1320,1530 1530,1740
memory,| {} these load store
|这些加载存储指令通常具有副作用，

765
00:24:09,170 --> 00:24:10,850
0,390 390,780 780,870 870,1140 1140,1680
instructions typically have side effects,|
|

766
00:24:10,880 --> 00:24:12,650
0,240 240,660 660,720 720,1290 1320,1770
the cause of the device
引起设备做某些事。

767
00:24:12,650 --> 00:24:13,740
0,90 90,210 210,630
to do something.|
|

768
00:24:15,080 --> 00:24:16,490
0,630 750,1050 1050,1140 1140,1260 1260,1410
{} And you know you
你必须查看设备文档，

769
00:24:16,490 --> 00:24:17,450
0,150 150,240 240,510 510,870 870,960
have to look basically the

770
00:24:17,450 --> 00:24:18,800
0,630 630,690 690,810 810,1260 1260,1350
documentation of the device| to
|才能弄清楚这个设备是做什么的。

771
00:24:18,800 --> 00:24:19,880
0,210 210,540 540,810 810,1020 1020,1080
actually figure out what the

772
00:24:19,880 --> 00:24:21,300
0,390 390,960
device does.|
|

773
00:24:21,360 --> 00:24:23,490
0,840 840,1290 1290,1380 1380,1590 1590,2130
{} And you know sometimes
有时候文档非常清楚，

774
00:24:23,490 --> 00:24:24,930
0,120 120,630 630,690 690,930 930,1440
this documentation is very clear,|
|

775
00:24:24,990 --> 00:24:26,490
0,450 450,570 570,1140 1140,1260 1260,1500
sometimes this documentation is less
有时候文档不太清楚。

776
00:24:26,490 --> 00:24:27,400
0,390
clear.|
|

777
00:24:27,430 --> 00:24:28,120
0,150 150,360 360,510 510,630 630,690
This should give you a
这里给你一个小的示例。

778
00:24:28,120 --> 00:24:29,050
0,210 210,360 360,450 450,510 510,930
little bit of a sample

779
00:24:29,050 --> 00:24:31,420
0,300 300,690 1200,1800
{}, the {}.|
|

780
00:24:32,630 --> 00:24:33,440
0,210 210,420 420,480 480,720 720,810
Two things I wanted to
在这里我想给你们看两样东西，

781
00:24:33,440 --> 00:24:35,060
0,270 270,450 450,1020 1110,1410 1410,1620
show you {in,here},| {} on
|在屏幕的右侧，

782
00:24:35,060 --> 00:24:37,400
0,300 600,990 990,1530 1890,2250 2250,2340
the right side of the

783
00:24:37,400 --> 00:24:40,010
0,540 780,1290 1290,1800 1800,1980 1980,2610
screen,| {} you see the
|你可以看到 SiFive 电路板的物理内存映射空间，

784
00:24:40,040 --> 00:24:42,320
0,360 360,870 930,1770 1770,2040 2040,2280
memory map, {} physical memory

785
00:24:42,320 --> 00:24:43,580
0,210 210,690 690,780 780,900 900,1260
map space, you know for

786
00:24:43,580 --> 00:24:46,610
0,300 300,1080 1110,1890 2250,2700 2700,3030
the SiFive board,| {} and
|你可以看到特定事物映射的地址是什么，

787
00:24:46,610 --> 00:24:47,660
0,120 120,330 330,540 540,630 630,1050
you see what the addresses

788
00:24:47,660 --> 00:24:48,710
0,180 180,390 390,810 810,1050 1050,1050
are where particular things are

789
00:24:48,710 --> 00:24:50,630
0,660 780,1230 1230,1380 1380,1680 1680,1920
mapped,| where they show up
|它们出现在物理地址空间中的位置，

790
00:24:50,630 --> 00:24:51,800
0,90 90,150 150,480 480,720 720,1170
in the physical address space

791
00:24:52,340 --> 00:24:53,330
0,210 210,420 420,480 480,660 660,990
to use the [] map|
|

792
00:24:53,330 --> 00:24:54,320
0,120 120,300 300,570 570,840 840,990
where they actually show up
它们实际出现在物理地址空间的位置。

793
00:24:54,320 --> 00:24:55,460
0,90 90,150 150,480 480,690 690,1140
in the physical address space.|
|

794
00:24:56,050 --> 00:24:57,160
0,360 360,510 510,570 570,960 960,1110
And so, for example {we,see,the}
比如， CLINT 在 0x0200 。

795
00:24:57,160 --> 00:24:58,960
0,720 720,810 810,1020 1020,1260 1260,1800
CLINT you know is there

796
00:24:59,260 --> 00:25:01,180
0,510 510,810 810,960 960,1230 1230,1920
at {0x0200 - - -}.|
|

797
00:25:01,540 --> 00:25:04,810
0,870 900,2430 2460,2910 2910,3060 3090,3270
{} We {} we pick
我们再挑一个。

798
00:25:04,810 --> 00:25:06,920
0,150 150,450 450,810 900,1620
out another one {}.|
|

799
00:25:07,400 --> 00:25:08,630
0,240 240,570 570,690 690,1020 1020,1230
The PLIC was somewhere there
PLIC 也在那里的某个地方，

800
00:25:08,630 --> 00:25:09,980
0,270 270,540 540,750 750,840 840,1350
too,| okay, here's the PLIC
|好的，这里是 PLIC ，在 0x0C00 ，

801
00:25:09,980 --> 00:25:11,690
0,180 180,750 780,1170 1170,1470 1470,1710
at {0x0C00 - - -

802
00:25:11,690 --> 00:25:14,450
0,510 510,750 750,1110 1110,1830 1830,2760
-},| that's the platform {}
|这是平台中断控制器，

803
00:25:14,600 --> 00:25:17,510
0,690 690,810 810,1140 1140,1920 2190,2910
platform the interrupt controller {},|
|

804
00:25:17,510 --> 00:25:18,880
0,840
and
我们看到 UART0 在这个特定地址，

805
00:25:18,970 --> 00:25:19,870
0,180 180,330 330,480 480,720 720,900
{you,know} we see actually {UART0

806
00:25:19,870 --> 00:25:21,070
0,120 120,600 600,960 960,1050 1050,1200
- -} here at this

807
00:25:21,070 --> 00:25:22,960
0,390 390,900 990,1380 1380,1620 1620,1890
particular address,| {} that turns
|实际上，在我们使用的 QEMU 上，

808
00:25:22,960 --> 00:25:25,600
0,120 120,420 450,1050 1410,2010 2040,2640
out that on the QEMU

809
00:25:25,600 --> 00:25:29,230
0,180 180,450 450,990 990,2160 2190,3630
that we're using| {} use
|UART 实际上在另一个位置。

810
00:25:29,230 --> 00:25:30,070
0,240 240,300 300,450 450,600 600,840
has to {UART -} actually

811
00:25:30,070 --> 00:25:31,780
0,120 120,360 360,660 660,1200
at a different location.|
|

812
00:25:31,960 --> 00:25:34,120
0,540 660,870 870,1050 1050,1680 1950,2160
{} {You,know}, that's because we
那是因为我们使用 QEMU ，

813
00:25:34,120 --> 00:25:35,890
0,210 210,540 540,1080 1080,1380 1380,1770
use {} QEMU| doesn't actually
|并不是完全模仿 SiFive 电路板，

814
00:25:35,890 --> 00:25:38,080
0,570 570,1260 1260,1380 1380,1860 1860,2190
literally emulate the SiFive board,|
|

815
00:25:38,080 --> 00:25:39,190
0,120 120,360 360,510 510,750 750,1110
but something that's very close
而是跟 SiFive 电路板很相似。

816
00:25:39,190 --> 00:25:40,400
0,60 60,180 180,570 570,930
to the SiFive board.|
|

817
00:25:41,610 --> 00:25:42,480
0,210 210,330 330,480 480,570 570,870
Okay, so that's the memory
好的，这就是内存映射，

818
00:25:42,480 --> 00:25:45,270
0,480 630,1620 1770,2160 2160,2640 2670,2790
map,| {} memory map, you
|从物理地址到设备的内存映射。

819
00:25:45,270 --> 00:25:47,040
0,210 210,540 540,990 990,1110 1110,1770
know physical addresses, you know

820
00:25:47,040 --> 00:25:50,100
0,420 420,1020 1050,1440 1440,1800 1980,3060
to {} to {} devices.|
|

821
00:25:51,550 --> 00:25:53,530
0,630 990,1140 1140,1530 1560,1800 1800,1980
{} And then, {} on
然后，在左边，

822
00:25:53,530 --> 00:25:56,290
0,420 510,840 840,1260 1290,1950 1950,2760
the left side,| is {}
|是 UART 文档的一部分。

823
00:25:56,290 --> 00:25:59,290
0,180 180,240 240,1050 1050,2010 2160,3000
piece of documentation {} for

824
00:25:59,320 --> 00:26:01,920
0,660 690,1020 1020,1470
{} {UART -}.|
|

825
00:26:01,950 --> 00:26:05,490
0,600 600,870 870,1020 1020,1650 1680,3540
{} This is the 1655-,
这是 16550 ，

826
00:26:06,010 --> 00:26:07,630
0,540 780,1020 1020,1230 1230,1380 1380,1620
{} {16550 - - -

827
00:26:07,630 --> 00:26:09,700
0,540 540,750 750,1260 1260,1560 1560,2070
-},| that's actually UART chip
|这是位于 QEMU 上模拟的 UART 芯片，

828
00:26:09,700 --> 00:26:12,160
0,270 420,750 750,990 990,2040 2070,2460
that sits on the QEMU

829
00:26:12,160 --> 00:26:14,080
0,480 480,720 720,900 900,1350
emulates,| that we're using
|我们用来与键盘和控制台交互，

830
00:26:14,110 --> 00:26:16,540
0,390 390,690 690,1110 1110,1830 1860,2430
{} to actually interact {}

831
00:26:16,540 --> 00:26:19,990
0,300 300,960 1080,1800 1830,2760 3120,3450
with {} keyboard and {}

832
00:26:19,990 --> 00:26:21,910
0,570 630,1440 1530,1680 1680,1740 1740,1920
console| and you know this
|这是一个很简单的芯片，

833
00:26:21,910 --> 00:26:23,080
0,120 120,180 180,510 510,810 810,1170
is a reasonable simple chip,|
|

834
00:26:23,080 --> 00:26:24,130
0,210 210,300 300,540 540,780 780,1050
there's not actually much going
这个设备并没有太多的功能，

835
00:26:24,130 --> 00:26:26,260
0,390 390,540 540,720 720,1350 1740,2130
on in this device {},|
|

836
00:26:26,290 --> 00:26:27,850
0,720 720,960 960,1230 1230,1380 1380,1560
there's even then they're sort
即便如此，它们还是有点复杂。

837
00:26:27,850 --> 00:26:30,460
0,150 150,1230 1410,2160 2160,2430 2430,2610
of complications.| {} Here on
|在这张表中，

838
00:26:30,460 --> 00:26:31,220
0,300
the

839
00:26:31,220 --> 00:26:32,860
0,120 120,480 480,1110
this table here,|
|

840
00:26:33,160 --> 00:26:35,710
0,120 120,600 600,1320 1440,2370 2370,2550
it shows the registers that
显示了芯片拥有的寄存器，控制器寄存器，

841
00:26:35,710 --> 00:26:37,510
0,150 150,360 360,930 1350,1680 1680,1800
the chip has, {} the

842
00:26:37,510 --> 00:26:39,370
0,330 330,930 930,1110 1110,1200 1200,1860
controller registers| as for example,
|比如，控制寄存器 0 0 0 ，

843
00:26:39,370 --> 00:26:40,450
0,90 90,150 150,480 480,840 840,1080
you know control register zero

844
00:26:40,450 --> 00:26:42,760
0,240 240,990 1290,1590 1590,2040 2040,2310
zero zero| {} in when
|当你执行加载指令时，

845
00:26:42,760 --> 00:26:44,260
0,180 180,420 420,510 510,810 810,1500
you're doing {} load instruction,|
|

846
00:26:44,350 --> 00:26:46,480
0,210 210,690 690,1320 1440,1770 1770,2130
it holds, {} it's will
它将持有数据，

847
00:26:46,480 --> 00:26:48,160
0,270 270,330 330,810 1170,1500 1500,1680
hold the data,| {} if
|如果执行存储指令，

848
00:26:48,160 --> 00:26:49,930
0,150 150,570 570,1260 1470,1680 1680,1770
you {do,store} instruction,| that's the
|寄存器会，数据会复制进来，

849
00:26:49,930 --> 00:26:51,550
0,420 420,840 840,1290 1290,1380 1380,1620
register, {that,will} basically, the data

850
00:26:51,550 --> 00:26:52,840
0,120 120,240 240,660 660,1140 1140,1290
will be copied into| to
|传输到线路之外，

851
00:26:52,840 --> 00:26:54,430
0,150 150,840 870,990 990,1140 1140,1590
be transmitted, you know, outside

852
00:26:54,430 --> 00:26:56,170
0,180 180,240 240,660 780,1230 1230,1740
of the wire,| {UART -}
|UART 是一种允许你通过串行线发送比特的设备，

853
00:26:56,900 --> 00:27:00,500
0,360 1080,1590 1770,2700 2700,2970
{ -} basically {}

854
00:27:00,500 --> 00:27:01,880
0,150 150,720 720,870 870,1230 1230,1380
a device that allows you

855
00:27:01,880 --> 00:27:03,230
0,150 150,480 480,900 900,1260 1260,1350
to send bits over a

856
00:27:03,230 --> 00:27:05,780
0,420 420,780 1080,1650 1650,1920 2190,2550
serial {line -},| {} sent
|发送是一条线路，接收是另一条线路，

857
00:27:05,780 --> 00:27:07,010
0,240 240,330 330,540 540,1050 1050,1230
line is one line and

858
00:27:07,010 --> 00:27:07,940
0,60 60,390 390,600 600,690 690,930
the received line is another

859
00:27:07,940 --> 00:27:11,180
0,390 1650,2310 2340,2910 2910,3090 3090,3240
line,| {} basically you take
|基本上，你取一个字节

860
00:27:11,180 --> 00:27:12,590
0,60 60,630 630,1080 1080,1230 1230,1410
a byte| and you know
|它们在这一条线上是多路复用或串行化的，

861
00:27:12,620 --> 00:27:15,260
0,510 510,870 1080,1950 1980,2370 2400,2640
basically they're multiplex or {}

862
00:27:15,260 --> 00:27:17,000
0,180 180,600 600,960 960,1410 1410,1740
{serialized -} on this single

863
00:27:17,000 --> 00:27:18,530
0,480 780,1110 1110,1320 1320,1440 1440,1530
line| sent over to the
|送到另一边，

864
00:27:18,530 --> 00:27:19,940
0,210 210,600 600,750 750,810 810,1410
other side,| there's {} UART
|有一个 UART 芯片在另一边，

865
00:27:19,940 --> 00:27:20,720
0,240 240,450 450,510 510,600 600,780
chip sitting on the other

866
00:27:20,720 --> 00:27:22,190
0,330 330,450 450,840 840,1380 1380,1470
side| and basically assembles the
|将比特组装回单个字节。

867
00:27:22,190 --> 00:27:23,860
0,240 240,630 630,1290
bit back into

868
00:27:23,860 --> 00:27:25,240
0,60 60,390 390,810
a single byte.|
|

869
00:27:25,780 --> 00:27:26,620
0,240 240,270 270,480 480,630 630,840
And a couple other things
你还可以在这个设备上，控制其他几件事情，

870
00:27:26,620 --> 00:27:28,120
0,90 90,210 210,330 330,1200 1200,1500
that you can control on

871
00:27:28,120 --> 00:27:30,520
0,570 570,1290 1470,2070 2070,2250 2250,2400
this device,| {} you can
|你可以一定程度上控制设备的波特率，

872
00:27:30,520 --> 00:27:32,950
0,510 510,780 780,1230 1230,1680 1710,2430
actually {} control the baud

873
00:27:32,950 --> 00:27:35,410
0,510 600,1470 1470,1590 1590,1800 1800,2460
rate {} of the device,

874
00:27:35,860 --> 00:27:38,680
0,180 180,510 510,1110 1320,2280 2280,2820
to some degree,| {} and
|对我们来说最重要的可能是寄存器 1 ，

875
00:27:38,680 --> 00:27:39,790
0,150 150,240 240,570 570,780 780,1110
you know probably most important

876
00:27:39,790 --> 00:27:42,970
0,150 150,570 810,1680 1680,2670 2670,3180
for us is register {

877
00:27:43,210 --> 00:27:44,460
0,840
-}

878
00:27:45,300 --> 00:27:47,550
0,720 720,1230 1290,1650 1650,1950 1950,2250
register one| which is here
|在这里，是中断启用寄存器，

879
00:27:47,550 --> 00:27:49,050
0,150 150,270 270,630 630,1200 1200,1500
which is the interrupt enable

880
00:27:49,050 --> 00:27:51,030
0,480 570,840 840,1230 1440,1860 1860,1980
register| and so we can
|我们可以对它编程，

881
00:27:51,030 --> 00:27:52,590
0,450 450,600 600,720 720,1410 1410,1560
program it| to actually {}
|使 UART 生成中断。

882
00:27:52,590 --> 00:27:54,570
0,630 630,870 870,1050 1050,1590 1590,1980
cause {UART -} to generate

883
00:27:54,570 --> 00:27:55,540
0,540
interrupts.|
|

884
00:27:57,640 --> 00:27:59,170
0,390 390,570 570,780 780,1290 1290,1530
{} So, in particular scroll
向下滚动，

885
00:27:59,170 --> 00:28:01,780
0,330 330,450 450,1170 1230,1950 2040,2610
down,| this document {} you'll
|在这份文档中，你会看到。

886
00:28:01,780 --> 00:28:03,340
0,300 300,570 570,930
see that the.|
|

887
00:28:03,900 --> 00:28:04,860
0,300 300,510 510,540 540,900 900,960
Scroll down a bit {},|
向下滚动一点，|

888
00:28:04,860 --> 00:28:07,080
0,660 690,1290 1290,1560 1560,1740 1740,2220
the document actually more detail
文档更详细地描述了每个寄存器中的每一位的含义，

889
00:28:07,080 --> 00:28:08,580
0,390 390,810 810,900 900,1200 1200,1500
basically describe what every bit

890
00:28:08,580 --> 00:28:10,980
0,150 150,330 330,750 750,1380 1800,2400
in every register means {},|
|

891
00:28:10,980 --> 00:28:13,770
0,300 330,840 840,1560 1980,2490 2520,2790
in {for,example} in the {}
比如，在中断启用寄存器 IER 中，

892
00:28:13,770 --> 00:28:15,900
0,300 300,690 690,1230 1230,1590 1590,2130
interrupt enable register {IER -}

893
00:28:15,990 --> 00:28:17,820
0,840 840,1020 1020,1110 1110,1530 1530,1830
register, which the {abbr,name} for

894
00:28:17,820 --> 00:28:19,290
0,240 540,660 660,840 840,1020 1020,1470
it,| you know that basically
|有接收行状态中断，

895
00:28:19,290 --> 00:28:20,550
0,270 270,510 510,720 720,1050 1050,1260
this is a receive line

896
00:28:20,550 --> 00:28:23,820
0,360 360,960 1020,2370 2400,2940 2940,3270
state interrupt| and transmit holding
|和传输保持状态中断。

897
00:28:23,820 --> 00:28:24,960
0,390 390,870
register interrupt.|
|

898
00:28:25,030 --> 00:28:26,410
0,390 390,720 720,1080 1080,1170 1170,1380
So that's what the bits
这是这些位的含义。

899
00:28:26,410 --> 00:28:27,440
0,480
mean.|
|

900
00:28:27,500 --> 00:28:29,030
0,600 600,1050 1050,1260 1260,1440 1440,1530
{} It goes on and
它还有很多，有更多的文档，

901
00:28:29,030 --> 00:28:30,050
0,390 420,720 720,780 780,900 900,1020
on, there's a lot more

902
00:28:30,050 --> 00:28:31,970
0,960 960,1110 1110,1200 1200,1470 1470,1920
documentation| and that tells you
|告诉你寄存器的更多细节，

903
00:28:32,360 --> 00:28:34,040
0,390 390,690 690,1080 1110,1350 1350,1680
{} what the more detailed

904
00:28:34,040 --> 00:28:35,330
0,60 60,510 510,960 960,1140 1140,1290
the registers are,| how you
|如何在轮询模式或中断模式下使用它，

905
00:28:35,330 --> 00:28:36,740
0,180 180,450 450,810 810,1110 1110,1410
can use it in polling

906
00:28:36,740 --> 00:28:37,790
0,270 270,330 330,660 660,960 960,1050
mode or interrupt mode,| we'll
|我们会多谈一点，

907
00:28:37,790 --> 00:28:38,750
0,180 180,360 360,450 450,690 690,960
talk about a little bit

908
00:28:38,750 --> 00:28:40,280
0,450 480,570 570,660 660,1140 1350,1530
more,| you know how, how
|如何对启用寄存器等进行编程，等等。

909
00:28:40,280 --> 00:28:41,480
0,120 120,270 270,360 360,810 810,1200
you have to program the

910
00:28:41,630 --> 00:28:43,880
0,750 750,1320 1320,1680 1680,2070 2100,2250
enable registers etc etc.| So
|这是真实文档的一个简短版本，

911
00:28:43,880 --> 00:28:45,230
0,300 660,990 990,1080 1080,1140 1140,1350
it turned out to be

912
00:28:45,230 --> 00:28:46,880
0,330 660,1080 1080,1440 1440,1560 1560,1650
a short version of the

913
00:28:46,880 --> 00:28:48,080
0,180 180,870 870,1020 1020,1080 1080,1200
real documents,| you know the
|真正芯片制造商的文档要多得多，

914
00:28:48,080 --> 00:28:49,640
0,180 180,750 750,990 990,1320 1320,1560
real documents where the chip

915
00:28:49,640 --> 00:28:51,240
0,510 510,900 900,1260
manufacturers much more,|
|

916
00:28:51,240 --> 00:28:52,740
0,630 780,1020 1020,1200 1200,1320 1320,1500
{} has much more stuff
有更多的内容和更多的细节，

917
00:28:52,740 --> 00:28:53,430
0,150 150,300 300,390 390,570 570,690
in it and much more

918
00:28:53,430 --> 00:28:55,440
0,660 900,1170 1170,1470 1470,1860 1860,2010
detail| and it's sufficient for
|这个对我们谈论 UART 编程足够了。

919
00:28:55,440 --> 00:28:56,640
0,210 210,330 330,690 690,1020 1020,1200
us to actually be able

920
00:28:56,640 --> 00:28:57,390
0,90 90,330 330,510 510,630 630,750
to talk about how the

921
00:28:57,390 --> 00:28:58,800
0,360 360,600 600,900
program {UART -}.|
|

922
00:28:59,100 --> 00:28:59,820
0,180 180,270 270,360 360,570 570,720
And you can see, this
你可以看到，这是最简单的设备之一，

923
00:28:59,820 --> 00:29:00,480
0,90 90,300 300,510 510,570 570,660
is like one of the

924
00:29:00,480 --> 00:29:01,800
0,210 210,450 450,960 960,1080 1080,1320
most simple devices| and even
|即使那份文档，它也相当复杂。

925
00:29:01,800 --> 00:29:03,480
0,180 180,750 1170,1470 1470,1560 1560,1680
that document you know it's

926
00:29:03,480 --> 00:29:04,380
0,210 210,270 270,450 450,630 630,900
quite a bit to it.|
|

927
00:29:10,050 --> 00:29:11,790
0,300 300,720 720,840 840,1080 1080,1740
{} Sorry, I was wondering,
抱歉，我想知道，如果你写入，

928
00:29:11,910 --> 00:29:13,920
0,480 480,810 810,1020 1020,1710 1740,2010
{} if you're writes,| so
|如果你将某些内容写入传输保持寄存器，

929
00:29:13,920 --> 00:29:15,100
0,210 210,630
if you

930
00:29:15,100 --> 00:29:17,110
0,600 660,990 990,1470 1470,1590 1590,2010
{} write something to the

931
00:29:17,230 --> 00:29:19,600
0,630 630,990 990,1770 2070,2250 2250,2370
transmit holding register| and then
|然后你再写一遍，在那之后，

932
00:29:19,600 --> 00:29:22,180
0,600 840,1410 1440,1800 1800,2160 2340,2580
you write again like write

933
00:29:22,180 --> 00:29:23,400
0,270 270,750
after that,|
|

934
00:29:23,400 --> 00:29:26,040
0,480 750,1140 1380,1830 1830,2280 2280,2640
{} it makes sure that
它是不是确保了之前的数字不会被覆盖。

935
00:29:26,370 --> 00:29:28,590
0,360 360,660 690,1230 1230,1830 1920,2220
like the previous number didn't

936
00:29:28,590 --> 00:29:29,720
0,240 240,600
just like

937
00:29:30,500 --> 00:29:31,940
0,300 300,540 540,660 660,900 930,1440
get over {written -}, right.|
|

938
00:29:32,120 --> 00:29:35,150
0,390 390,1740 1740,2010 2010,2460 2520,3030
{} Yes, or no, {}
是或不是，这是你来决定的，

939
00:29:35,150 --> 00:29:36,530
0,240 240,480 480,570 570,1020 1020,1380
it's part of you,| actually
|实际上这是我们要关注的一件事，

940
00:29:36,530 --> 00:29:37,190
0,150 150,270 270,450 450,570 570,660
this is {} one of

941
00:29:37,190 --> 00:29:38,270
0,90 90,330 330,900 900,960 960,1080
the things that we're going

942
00:29:38,270 --> 00:29:38,750
0,60 60,210 210,270 270,420 420,480
to pay a bit of

943
00:29:38,750 --> 00:29:41,780
0,330 330,630 990,1710 1800,2550 2790,3030
attention to,| {} the you
|你告诉，加载指令加载一些值，

944
00:29:41,780 --> 00:29:43,460
0,390 390,750 750,990 990,1440 1440,1680
tell, basically load instruction load

945
00:29:43,460 --> 00:29:44,540
0,90 90,450 450,570 570,810 810,1080
some value| or store instruction
|或存储指令将一些值加载到寄存器中，

946
00:29:44,540 --> 00:29:45,260
0,150 150,240 240,540 540,600 600,720
load some value in that

947
00:29:45,260 --> 00:29:48,440
0,600 840,1500 1500,1740 1740,2280 2370,3180
register| {} and then the,
|然后， UART 芯片继续，

948
00:29:48,590 --> 00:29:49,620
0,600
{}

949
00:29:49,830 --> 00:29:51,330
0,270 270,600 600,840 840,1200 1200,1500
the UART chip goes of|
|

950
00:29:51,330 --> 00:29:51,960
0,90 90,210 210,330 330,390 390,630
and it's going to send
它会把那个字节发送到串行线路上，

951
00:29:51,960 --> 00:29:54,000
0,420 420,720 870,1170 1170,1620 1620,2040
of that that byte onto

952
00:29:54,000 --> 00:29:54,960
0,120 120,420 420,510 510,570 570,960
the line, on the serial

953
00:29:54,960 --> 00:29:57,420
0,270 300,660 1080,1800 1860,2280 2280,2460
line right,| and when it's
|当它完成时，

954
00:29:57,420 --> 00:29:59,220
0,540 720,1050 1050,1230 1230,1440 1440,1800
done,| {} it will generate
|它将生成一个中断，告诉内核，

955
00:29:59,220 --> 00:30:00,360
0,90 90,480 480,930 930,1080 1080,1140
an interrupt saying to the

956
00:30:00,360 --> 00:30:01,440
0,390 390,540 540,720 720,960 960,1080
kernel,| okay, I'm done with
|好了，完成了那个字节，

957
00:30:01,440 --> 00:30:02,340
0,150 150,450 480,660 660,810 810,900
that byte,| now you can
|现在你可以给我下一个字节了。

958
00:30:02,340 --> 00:30:03,330
0,150 150,240 240,330 330,570 570,990
give me the next byte.|
|

959
00:30:04,300 --> 00:30:05,560
0,600 600,780 780,870 870,960 960,1260
{} And so the kernel
因此内核和设备必须遵循一个协议，

960
00:30:05,560 --> 00:30:06,460
0,90 90,150 150,480 480,630 630,900
and the device has to

961
00:30:06,460 --> 00:30:07,510
0,270 270,330 330,810 810,900 900,1050
follow a protocol| to make
|以确保一切都能顺利解决。

962
00:30:07,510 --> 00:30:08,830
0,240 240,390 390,720 720,1020 1020,1320
sure that actually everything works

963
00:30:08,830 --> 00:30:09,700
0,360
out.|
|

964
00:30:10,340 --> 00:30:12,080
0,360 360,1170 1170,1410 1410,1590 1590,1740
This particular, {UART -} you
这个我们使用的 UART ，

965
00:30:12,080 --> 00:30:13,400
0,210 210,360 360,780 780,1050 1050,1320
know that we're using| has,
|16550A 实际上内部有一个 FIFO ，

966
00:30:13,400 --> 00:30:17,630
0,780 1650,2220 2220,3030 3030,3660 3990,4230
{} {16550A - - -

967
00:30:17,630 --> 00:30:19,640
0,420 420,810 930,1290 1290,1710 1710,2010
- -} actually internally has

968
00:30:19,640 --> 00:30:20,750
0,60 60,390 390,690 720,960 960,1110
a {FIFO -}| and I
|我想它可以缓冲一些字符，

969
00:30:20,750 --> 00:30:22,250
0,180 180,450 450,630 630,1200 1200,1500
think it can buffer a

970
00:30:22,250 --> 00:30:23,420
0,210 210,270 270,810 810,1020 1020,1170
bunch of characters,| like I
|我想最多是 16 个字符。

971
00:30:23,420 --> 00:30:24,860
0,150 150,300 300,420 420,990
think up to sixteen.|
|

972
00:30:25,560 --> 00:30:26,610
0,330 330,570 570,690 690,900 900,1050
{} But you still have
但是你仍然要玩这个游戏，

973
00:30:26,610 --> 00:30:27,720
0,240 270,450 450,600 600,900 900,1110
to play this game of|
|

974
00:30:27,720 --> 00:30:28,920
0,210 210,330 330,540 540,840 900,1200
like you can't {} stick
你不能放入超过 16 个字符，

975
00:30:28,920 --> 00:30:30,570
0,420 420,600 600,900 900,1320 1320,1650
more than sixteen characters into

976
00:30:30,570 --> 00:30:32,130
0,150 150,570 570,690 690,1260 1260,1560
it| until the device actually
|在设备告诉你已经发送了一个字符之前。

977
00:30:32,220 --> 00:30:33,720
0,180 180,420 420,570 570,1020 1140,1500
has told you well, {}

978
00:30:33,720 --> 00:30:35,380
0,300 300,510 510,690 690,1170
I've sent one character.|
|

979
00:30:37,270 --> 00:30:38,700
0,270 270,390 390,510 510,840
Does that make sense?|
这能理解吗？|

980
00:30:39,130 --> 00:30:41,200
0,360 360,600 600,1020 1020,1470
Okay, yeah, thank you.|
是的，谢谢。|

981
00:30:41,780 --> 00:30:42,950
0,150 150,390 390,750 750,960 960,1170
So we'll talk a little
我们会再多说一点，

982
00:30:42,950 --> 00:30:44,420
0,150 150,660 690,1200 1200,1290 1290,1470
bit more,| before we do
|在看更多细节之前，

983
00:30:44,420 --> 00:30:47,450
0,510 510,750 750,750 1920,2850 2850,3030
{} look a little more

984
00:30:47,450 --> 00:30:50,090
0,570 720,1230 1260,1350 1350,1650 2010,2640
detail,| {} you know, {}
|我们要看的个例研究，

985
00:30:50,150 --> 00:30:51,350
0,120 120,270 270,540 540,780 780,1200
you know the case study,

986
00:30:51,350 --> 00:30:53,060
0,180 180,330 330,570 570,1020
you know that we

987
00:30:53,150 --> 00:30:54,380
0,270 270,390 390,450 450,630 630,1230
{} going to go through|
|

988
00:30:54,650 --> 00:30:57,020
0,690 1140,1530 1560,1770 1770,1830 1830,2370
for a sort of explaining
为了解释设备和中断是如何工作的，

989
00:30:57,020 --> 00:30:58,610
0,330 330,810 810,960 960,1290 1290,1590
how devices and interrupts work|
|

990
00:30:58,610 --> 00:30:59,930
0,240 240,450 450,840 840,1230 1230,1320
is here's $ ls,| you
是 $ ls，|你知道这里发生了什么。

991
00:30:59,930 --> 00:31:02,040
0,60 60,240 240,840 870,1590
know what happens {}

992
00:31:02,040 --> 00:31:04,280
0,360 360,960 1230,1710
{} when the.|
|

993
00:31:04,660 --> 00:31:05,890
0,120 120,180 180,570 570,990 990,1230
You know how actually how
实际上是如何打印的，

994
00:31:05,890 --> 00:31:07,510
0,450 480,960 1020,1200 1200,1320 1320,1620
you print| and so basically
|发生的事情是，

995
00:31:07,510 --> 00:31:09,190
0,150 150,720 870,1200 1200,1440 1440,1680
what happens is| that the
|就像我们刚才讨论的那样，

996
00:31:09,220 --> 00:31:11,710
0,810 840,990 990,1170 1170,1620 1980,2490
device as we actually discussed

997
00:31:11,710 --> 00:31:13,330
0,90 90,150 150,450 450,840 960,1620
in the second go,| basically
|在本例中，基本上就是把 $ 符放入 UART ，

998
00:31:13,330 --> 00:31:14,260
0,210 210,300 300,750 750,840 840,930
puts the character of the

999
00:31:14,260 --> 00:31:15,900
0,330 330,390 390,540 540,1140
$ in this case

1000
00:31:16,020 --> 00:31:17,490
0,150 150,240 240,1110 1110,1350 1350,1470
you know into the {UART

1001
00:31:17,490 --> 00:31:19,200
0,690 900,1050 1050,1320 1320,1410 1410,1710
-},| in fact in the
|实际上，是我们刚看过的寄存器中。

1002
00:31:19,230 --> 00:31:20,610
0,660 660,840 840,960 960,1170 1170,1380
register that we just looked

1003
00:31:20,610 --> 00:31:21,500
0,300
at.|
|

1004
00:31:21,560 --> 00:31:25,610
0,810 810,1500 1500,1620 1620,2340 2730,4050
And then the UART generates
然后 UART 产生中断，

1005
00:31:25,610 --> 00:31:27,590
0,600 930,1620 1620,1710 1710,1860 1860,1980
interrupt,| {} the way we
|我们可以设置，

1006
00:31:27,590 --> 00:31:29,120
0,180 180,390 390,600 600,1020 1080,1530
can set things up,| generates
|当发送字符时产生一个中断。

1007
00:31:29,120 --> 00:31:30,280
0,60 60,600
an interrupt,

1008
00:31:30,310 --> 00:31:32,410
0,750 1230,1530 1530,1590 1590,1980 1980,2100
{} when the {} when

1009
00:31:32,410 --> 00:31:33,700
0,60 60,450 450,630 630,780 780,1290
the character has been sent.|
|

1010
00:31:42,140 --> 00:31:43,580
0,420 420,750 750,1200 1200,1260 1260,1440
And then on the other
然后在另一边，

1011
00:31:43,580 --> 00:31:45,260
0,330 330,450 450,600 600,1320 1380,1680
side| and so basically, {}
|所以 QEMU 中的事情是这样设置的，

1012
00:31:45,260 --> 00:31:46,400
0,210 210,570 570,900 900,960 960,1140
the way things are set

1013
00:31:46,400 --> 00:31:47,510
0,90 90,180 180,540 540,690 690,1110
up in QEMU| and QEMU
|QEMU 在一个在发送线上，

1014
00:31:47,510 --> 00:31:48,680
0,90 90,600 600,810 810,900 900,1170
is {} on the sent

1015
00:31:48,680 --> 00:31:49,610
0,330 360,480 480,570 570,750 750,930
line,| on the other side
|在发送线路的另一边，

1016
00:31:49,610 --> 00:31:51,470
0,60 60,180 180,420 420,810 960,1860
of the sent line {},|
|

1017
00:31:51,470 --> 00:31:53,000
0,120 150,540 540,780 780,1110 1110,1530
it usually sits in another
通常是另一个 UART 芯片，

1018
00:31:53,000 --> 00:31:54,660
0,270 270,630 630,1080
UART chip| and
|它连接到控制台，

1019
00:31:54,890 --> 00:31:56,210
0,300 300,570 570,960 960,1110 1110,1320
that actually connects to the

1020
00:31:56,210 --> 00:31:57,860
0,540 540,660 660,900 900,1560 1560,1650
console| to the virtual you
|连接到一个虚拟控制台。

1021
00:31:57,860 --> 00:32:00,140
0,180 180,540 630,1230 1230,1710
knows a virtual console.|
|

1022
00:32:00,370 --> 00:32:01,990
0,630 870,1080 1080,1230 1230,1530 1530,1620
On the other side, you
另一方面，你知道 ls 会发生什么，

1023
00:32:01,990 --> 00:32:03,280
0,60 60,210 210,510 510,660 660,1290
know what happens in ls,|
|

1024
00:32:03,960 --> 00:32:05,490
0,420 420,900 900,1260 1260,1410 1410,1530
{} is we need to
我们需要使用输入，

1025
00:32:05,490 --> 00:32:07,110
0,180 180,720 750,900 900,1380 1440,1620
use input| and so the
|所以，键盘实际上连接到接收的线路，

1026
00:32:07,110 --> 00:32:09,060
0,690 720,1080 1080,1170 1170,1770 1800,1950
keyboard actually is connected to

1027
00:32:09,060 --> 00:32:10,640
0,120 120,570 570,1020
the receive line,|
|

1028
00:32:15,880 --> 00:32:17,320
0,450 450,660 660,840 840,930 930,1440
{} um, {receive -} line.|
接收线。|

1029
00:32:18,490 --> 00:32:21,190
0,780 780,1620 2070,2310 2310,2640 2640,2700
And, {} so basically the
基本上就是键盘，

1030
00:32:21,190 --> 00:32:22,150
0,510 510,570 570,690 690,810 810,960
keyboard,| you know you hit
|你按了键盘上的一个键，

1031
00:32:22,150 --> 00:32:23,560
0,30 30,330 330,450 450,510 510,1410
a key on the keyboard,|
|

1032
00:32:23,560 --> 00:32:25,840
0,750 900,1350 1350,1920 1980,2160 2160,2280
keyboard, virtual keyboard {} in
在本例中的虚拟键盘，

1033
00:32:25,840 --> 00:32:27,640
0,150 150,600 840,1050 1050,1320 1320,1800
this case,| you know, {}
|另一边的 UART 芯片，

1034
00:32:27,670 --> 00:32:29,020
0,300 300,540 540,630 630,810 810,1350
UART chip on that side,|
|

1035
00:32:29,020 --> 00:32:30,760
0,90 90,240 240,810 870,1650 1650,1740
you know will serialize you
会序列化字符 l ，

1036
00:32:30,760 --> 00:32:33,340
0,90 90,210 210,930 930,1470 1650,2580
know the character l {},|
|

1037
00:32:33,340 --> 00:32:34,240
0,360 360,450 450,750 750,840 840,900
{send,it} to UART, on the
把它发送给另一边的 UART ，

1038
00:32:34,240 --> 00:32:36,820
0,180 180,540 540,1770 1770,2070 2070,2580
other side,| the other side,
|另一边把位放在一起变成一个字节，

1039
00:32:36,820 --> 00:32:37,870
0,150 150,270 270,600 600,960 960,1050
you know put the you

1040
00:32:37,870 --> 00:32:38,710
0,120 120,270 270,630 630,750 750,840
know the bits, you know

1041
00:32:38,710 --> 00:32:40,180
0,330 330,570 570,780 780,990 990,1470
together again into one byte|
|

1042
00:32:40,450 --> 00:32:42,340
0,870 900,1230 1230,1410 1410,1800 1800,1890
and {} then generate an
然后产生中断，

1043
00:32:42,340 --> 00:32:43,360
0,570
interrupt,|
|

1044
00:32:45,080 --> 00:32:47,300
0,450 450,540 540,1140 1500,1770 1770,2220
generate an interrupt to tell
生成中断告知处理器，

1045
00:32:47,300 --> 00:32:48,410
0,120 120,660 660,900 900,1050 1050,1110
the processor,| hey there's a
|嘿，键盘上有一个字符可用。

1046
00:32:48,410 --> 00:32:50,620
0,420 420,960 960,1200 1200,1650
character available from the

1047
00:32:50,820 --> 00:32:52,060
0,690
keyboard.|
|

1048
00:32:53,320 --> 00:32:54,730
0,150 150,270 270,690 690,1020 1020,1410
In the interrupt handler, the
在中断处理程序中，收到 UART 的字节，

1049
00:32:54,760 --> 00:32:56,200
0,300 300,570 570,810 810,1110 1140,1440
interrupt handle reach the byte

1050
00:32:56,200 --> 00:32:57,460
0,240 240,480 480,960 990,1140 1140,1260
from the UART| as we'll
|正如我们稍后看到的，

1051
00:32:57,460 --> 00:32:58,630
0,210 210,270 270,330 330,660 1020,1170
see in a second,| so
|所以，这里有两个事情需要理解，

1052
00:32:58,630 --> 00:32:59,770
0,480 480,630 630,810 810,1020 1020,1140
those are two things that

1053
00:32:59,770 --> 00:33:01,180
0,120 120,270 270,660 660,1200 1200,1410
we want to understand| more
|更详细地了解它们是如何工作的。

1054
00:33:01,180 --> 00:33:03,520
0,600 840,1410 1410,1620 1620,1830 1830,2340
detail actually how they work.|
|

1055
00:33:05,910 --> 00:33:07,080
0,780
Okay?|
好的?|

1056
00:33:07,110 --> 00:33:08,780
0,210 210,600 600,810 810,1140
Any questions about this?|
这个有什么问题吗？|

1057
00:33:13,720 --> 00:33:16,080
0,360 360,900 1170,1800
Okay, so {},
好的， RISC-V 有一系列的支持，

1058
00:33:16,650 --> 00:33:18,630
0,450 450,660 660,1350 1500,1890 1890,1980
the {RISC-V -} has a

1059
00:33:18,630 --> 00:33:20,120
0,210 210,270 270,900
bunch of support,|
|

1060
00:33:23,600 --> 00:33:25,820
0,600 600,930 930,1020 1020,1530
{} support for interrupts.|
对中断的支持。|

1061
00:33:34,380 --> 00:33:37,740
0,660 690,1170 1170,1860 1950,3030 3030,3360
And {numbers,of} registers, {} {you,know}
我们会更详细地了解一些会使用的寄存器的细节，

1062
00:33:37,740 --> 00:33:39,330
0,210 210,600 600,870 870,1050 1050,1590
we'll see in more detail

1063
00:33:39,330 --> 00:33:40,170
0,240 240,330 330,480 480,720 720,840
as we could use,| but
|但是知道有哪些是有用的，

1064
00:33:40,170 --> 00:33:41,280
0,330 330,690 690,780 780,930 930,1110
it's useful to know which

1065
00:33:41,280 --> 00:33:43,110
0,210 210,360 360,750 870,1440 1440,1830
ones there are,| there's the
|这是 SIE ，管理程序中断启用寄存器，

1066
00:33:43,590 --> 00:33:48,000
0,990 990,1950 1980,2760 2790,3840 3870,4410
SIE, supervisor interrupt {} enable

1067
00:33:48,000 --> 00:33:49,590
0,630 810,1170 1170,1290 1290,1440 1440,1590
register| {} and that has
|它有一位，用于外部中断，

1068
00:33:49,590 --> 00:33:50,600
0,90 90,570
a bit,

1069
00:33:50,810 --> 00:33:52,340
0,180 180,480 480,930
{} one bit

1070
00:33:52,460 --> 00:33:53,940
0,900
for

1071
00:33:54,900 --> 00:33:57,180
0,330 330,840 840,1320 1500,1740 1740,2280
{} external interrupts,| from devices,
|来自设备，比如 UART ，

1072
00:33:57,180 --> 00:33:59,340
0,180 180,240 240,840 1140,1560 1560,2160
like the UART,| {} from
|来自软件中断，这一点我会讨论一下，

1073
00:33:59,460 --> 00:34:01,680
0,450 450,1050 1200,1740 1740,1920 1920,2220
software interrupts, {} which I'm

1074
00:34:01,680 --> 00:34:02,580
0,210 210,330 330,390 390,660 660,900
really going to talk about

1075
00:34:02,580 --> 00:34:03,810
0,210 210,540 540,660 660,780 780,1230
it,| but it is possible
|但这是可能的，从一个 RISC-V 核心

1076
00:34:03,810 --> 00:34:05,790
0,150 150,630 990,1650 1650,1800 1800,1980
from one CPU from one

1077
00:34:05,790 --> 00:34:07,500
0,240 240,630 630,1080 1080,1410 1410,1710
{RISC-V -} cores| to send
|向另一个 RISC-V 核心发送中断，

1078
00:34:07,500 --> 00:34:08,610
0,120 120,570 570,630 630,930 930,1110
an interrupt to another {RISC-V

1079
00:34:08,610 --> 00:34:09,920
0,300 300,870
-} core,|
|

1080
00:34:10,070 --> 00:34:12,560
0,540 540,1290 1320,1560 1560,1920 1920,2490
{} and {} timer interrupt.|
还有定时器中断。|

1081
00:34:13,580 --> 00:34:14,740
0,630

1082
00:34:14,740 --> 00:34:15,430
0,150 150,240 240,420 420,570 570,690
And I'm not really going
我不准备谈论管理者模式的软件中断或计时器中断，

1083
00:34:15,430 --> 00:34:16,840
0,60 60,270 270,690 720,1290 1290,1410
to talk about either you

1084
00:34:16,840 --> 00:34:19,210
0,150 150,840 960,1890 1890,2040 2040,2370
know the supervisor of the

1085
00:34:19,240 --> 00:34:20,590
0,360 360,840 840,960 960,1080 1080,1350
software interruption or the timer

1086
00:34:20,590 --> 00:34:21,490
0,360 360,420 420,540 540,600 600,900
interrupts,| are going to focus
|而是重点放在外部中断。

1087
00:34:21,490 --> 00:34:22,900
0,60 60,420 420,930
on external interrupts.|
|

1088
00:34:23,340 --> 00:34:25,470
0,570 600,990 990,1530 1560,2010 2010,2130
{} There's another register that
还有另一个我们见过的寄存器，

1089
00:34:25,470 --> 00:34:27,030
0,180 180,360 360,750 750,930 930,1560
we've seen before,| {} the
|管理者状态寄存器，

1090
00:34:27,060 --> 00:34:30,200
0,1050 1440,1860 1860,2190 2190,2550
supervisor status register {},|
|

1091
00:34:30,480 --> 00:34:31,950
0,300 300,570 570,960 960,1080 1080,1470
and that has a bit
它有一个位用来禁用和启用特定内核上的中断。

1092
00:34:31,950 --> 00:34:33,930
0,420 420,960 960,1080 1080,1440 1440,1980
to disable and enable interrupts

1093
00:34:38,420 --> 00:34:40,420
0,240 240,420 420,870 870,1320
on this particular core.|
|

1094
00:34:41,720 --> 00:34:43,430
0,510 510,690 690,990 990,1380 1380,1710
{} So every core has
所以，每个核心都有这些寄存器，

1095
00:34:43,430 --> 00:34:45,290
0,120 120,240 240,600 600,1170 1170,1860
you know these {} registers|
|

1096
00:34:45,320 --> 00:34:47,780
0,720 1110,1710 1710,1920 1920,2310 2340,2460
{} and there's, {} in
除了这三个位之外，

1097
00:34:47,780 --> 00:34:48,830
0,330 330,420 420,600 600,810 810,1050
addition to these three bits,|
|

1098
00:34:48,830 --> 00:34:50,240
0,150 150,690 690,1140 1140,1320 1320,1410
for individual control, when you
对于每个控制，你有外部中断、软件中断、计时器中断，

1099
00:34:50,240 --> 00:34:52,160
0,210 210,270 270,630 630,1500 1530,1920
want to have {} external

1100
00:34:52,160 --> 00:34:53,570
0,420 420,510 510,810 810,1140 1140,1410
interrupts, {} software interrupt, timer

1101
00:34:53,570 --> 00:34:55,790
0,450 660,1200 1200,1590 1590,1830 1830,2220
interrupt,| there's one bit that
|有一个位可以控制收到的中断，

1102
00:34:55,790 --> 00:34:56,810
0,420 420,570 570,690 690,750 750,1020
controls you're going to receive

1103
00:34:56,810 --> 00:34:58,100
0,330 330,420 420,840 990,1170 1170,1290
interrupts at all,| so you
|所以，你可以原子地从没有中断切换到可以中断，

1104
00:34:58,100 --> 00:35:00,080
0,120 120,600 600,720 720,1350 1590,1980
can {atomicly -} switch from

1105
00:35:00,080 --> 00:35:01,880
0,270 270,600 600,1170 1170,1380 1380,1800
not getting interrupts to having

1106
00:35:01,880 --> 00:35:03,320
0,570 570,660 660,810 810,960 960,1440
interrupted,| the other way around,|
|反之亦然，|

1107
00:35:03,380 --> 00:35:04,910
0,390 390,870 870,1020 1020,1260 1260,1530
just changing that one bit
只需要修改 SSTATUS 寄存器中的这一位。

1108
00:35:04,910 --> 00:35:06,240
0,240 240,570 570,900
in the {}

1109
00:35:06,240 --> 00:35:07,740
0,180 180,510 510,900
{SSTATUS -} register.|
|

1110
00:35:08,660 --> 00:35:10,320
0,240 240,480 480,720 720,990
And then there's a
然后是 SIP 寄存器，

1111
00:35:10,410 --> 00:35:12,480
0,720 720,1050 1260,1770 1800,2010 2010,2070
{SIP,register}| are the called the
|称为管理程序中断挂起寄存器，

1112
00:35:12,480 --> 00:35:15,330
0,870 1080,1320 1320,1830 1830,2190 2190,2850
supervisor {} interrupt pending register,|
|

1113
00:35:21,020 --> 00:35:22,220
0,390 390,690 690,810 810,1140 1140,1200
and basically the process you
基本上进程可以使用它，

1114
00:35:22,220 --> 00:35:23,840
0,120 120,300 300,750 810,1530 1530,1620
can use that| {} {you,know}
|当中断发生，

1115
00:35:23,840 --> 00:35:25,220
0,210 210,270 270,600 600,810 810,1380
want to interrupt it happened,|
|

1116
00:35:25,220 --> 00:35:26,150
0,330 330,510 510,630 630,780 780,930
{} look at the {SIP
查看 SIP ，看是什么中断。

1117
00:35:26,150 --> 00:35:28,040
0,270 270,360 360,510 510,1020 1320,1890
-} to see what, {}

1118
00:35:28,040 --> 00:35:29,540
0,330 330,780 780,1080 1080,1260 1260,1500
what interrupt actually has come

1119
00:35:29,540 --> 00:35:31,100
0,270 420,1110
in {}.|
|

1120
00:35:31,220 --> 00:35:33,110
0,360 360,450 450,1080 1200,1590 1590,1890
And in addition, {} there
另外，当中断发生时，

1121
00:35:33,110 --> 00:35:35,150
0,150 150,690 840,1110 1110,1470 1470,2040
will be even interrupt happens,|
|

1122
00:35:35,450 --> 00:35:36,500
0,300 300,390 390,630 630,960 960,1050
in the SCAUSE register, we
在 SCAUSE 寄存器，我们之前已经看过几次，

1123
00:35:36,500 --> 00:35:37,640
0,330 330,480 480,720 750,900 900,1140
should that we have seen

1124
00:35:37,640 --> 00:35:39,020
0,180 210,420 420,630 630,900 900,1380
a couple times before now,|
|

1125
00:35:40,160 --> 00:35:41,630
0,630 660,870 870,1140 1140,1380 1380,1470
{} there will be an
将会出现一个进入的中断的指示，我们随后会看到，

1126
00:35:41,630 --> 00:35:43,910
0,600 600,840 840,1110 1110,1740 1770,2280
indication of one interrupt actually

1127
00:35:43,910 --> 00:35:44,870
0,240 240,570 570,750 750,810 810,960
came in, we'll {} look

1128
00:35:44,870 --> 00:35:46,220
0,90 90,180 180,660 1170,1290 1290,1350
in the second| and of
|当然还有 STVEC 寄存器，

1129
00:35:46,220 --> 00:35:47,480
0,240 240,450 450,540 540,960 960,1260
course there's the {STVEC -}

1130
00:35:47,510 --> 00:35:50,630
0,840 1140,1650 1650,2640 2670,3030 3030,3120
register,| basically {} holds the
|保存程序，或处理器切换的地址，

1131
00:35:50,630 --> 00:35:52,250
0,660 660,900 900,1260 1260,1350 1350,1620
program or address to which

1132
00:35:52,250 --> 00:35:55,070
0,390 450,1110 1110,1770 1980,2310 2310,2820
the processors switch| {} once
|当 trap 系统调用，

1133
00:35:55,130 --> 00:35:57,830
0,300 300,540 540,1050 1080,1740 1740,2700
{} either trap or {}

1134
00:35:58,550 --> 00:36:00,140
0,360 360,390 390,720 720,1080 1080,1590
trap {} system call| or
|或发生页面错误，产生中断，

1135
00:36:00,380 --> 00:36:01,850
0,660 660,960 960,1230 1230,1410 1410,1470
page fault happens when an

1136
00:36:01,850 --> 00:36:03,890
0,330 330,810 840,1320 1320,1710 1710,2040
interrupt happens,| because basically uses
|因为这三种情况都使用相同的机制。

1137
00:36:03,890 --> 00:36:04,970
0,240 240,450 450,630 630,990 990,1080
for all three cases the

1138
00:36:04,970 --> 00:36:06,100
0,240 240,750
same mechanism.|
|

1139
00:36:06,160 --> 00:36:07,030
0,180 180,330 330,480 480,750 750,870
I'm not gonna talk too
我不会说太多关于 SCAUSE 和 STVEC ，

1140
00:36:07,030 --> 00:36:08,860
0,570 750,1200 1200,1350 1350,1740 1740,1830
much about {SCAUSE -} and

1141
00:36:08,860 --> 00:36:10,330
0,450 450,690 690,1080 1080,1260 1260,1470
STVEC,| because we've seen it
|因为我们之前已经详细看过了，

1142
00:36:10,330 --> 00:36:14,500
0,1410 1470,2010 2010,2640 3060,3540 3540,4170
in detail before,| {} and
|基本上以相同的方式运行，

1143
00:36:14,530 --> 00:36:16,810
0,900 900,1350 1350,2040 2040,2160 2160,2280
basically operates exactly in the

1144
00:36:16,810 --> 00:36:19,580
0,660 690,1560 1560,2250
same way| as
|与页面错误或其他异常的系统调用一样。

1145
00:36:19,580 --> 00:36:20,700
0,540
{

1146
00:36:21,460 --> 00:36:24,190
0,690 990,1230 1230,1980 2010,2340 2340,2730
-} as {} system calls

1147
00:36:24,190 --> 00:36:26,080
0,420 450,660 660,1020 1020,1530 1530,1890
in page faults or other

1148
00:36:26,080 --> 00:36:27,220
0,690
exceptions.|
|

1149
00:36:30,080 --> 00:36:32,870
0,210 210,360 360,780 960,1830 1860,2790
Okay, so let's see a
好的，让我们来看看，

1150
00:36:33,020 --> 00:36:34,280
0,360 360,480 480,540 540,600 600,1260
little bit of {} sense,|
|

1151
00:36:34,460 --> 00:36:35,960
0,330 330,720 720,1020 1020,1410 1410,1500
{} how this stuff is
这些东西是如何初始化的，

1152
00:36:35,960 --> 00:36:37,490
0,120 120,180 180,930 1110,1290 1290,1530
sort of initialized,| so we're
|我们不会谈论驱动的实际工作方式，

1153
00:36:37,490 --> 00:36:38,660
0,180 180,480 480,690 690,960 960,1170
not talking even about how

1154
00:36:38,660 --> 00:36:40,940
0,660 840,1590 1590,1830 1830,2160 2160,2280
the drivers actually work,| but
|而是看看 xv6 程序是如何对它编程，

1155
00:36:40,940 --> 00:36:42,380
0,330 330,600 600,900 900,1170 1170,1440
just see how {xv6 -}

1156
00:36:42,380 --> 00:36:45,680
0,510 510,840 1290,1890 1950,2460 2460,3300
programs this,| {} these registers
|设置这些寄存器，让我们处于中断的位置。

1157
00:36:45,680 --> 00:36:46,400
0,210 210,450 450,570 570,630 630,720
set we're going to be

1158
00:36:46,400 --> 00:36:47,930
0,180 180,240 240,750 810,1170 1170,1530
in a position to take

1159
00:36:47,960 --> 00:36:49,120
0,150 150,750
a interrupt.|
|

1160
00:36:50,030 --> 00:36:51,680
0,480 480,810 810,1020 1050,1500 1500,1650
{} These's a question from
聊天中有一个问题，确认一下。

1161
00:36:51,680 --> 00:36:53,300
0,90 90,480 660,1080 1080,1350 1350,1620
the chat, make sure that.|
|

1162
00:37:03,140 --> 00:37:04,620
0,540 630,1020
Alright, okay.|
好的，|

1163
00:37:04,970 --> 00:37:05,840
0,120 120,300 300,690 690,810 810,870
A little behind on the
聊天有点落后，

1164
00:37:05,840 --> 00:37:08,030
0,330 450,1260 1620,1770 1770,1950 1950,2190
chat,| {} so let's see
|那么让我们来看一下， xv6 如何对寄存器编程，

1165
00:37:08,030 --> 00:37:09,020
0,90 90,330 330,480 480,720 720,990
a little bit on the

1166
00:37:09,020 --> 00:37:10,440
0,810
what,

1167
00:37:10,760 --> 00:37:13,490
0,600 660,1110 1110,1440 1470,2070 2070,2730
{} {xv6 -} programs registers,|
|

1168
00:37:13,790 --> 00:37:15,530
0,690 690,1050 1230,1530 1530,1620 1620,1740
{} so pull up some
所以找出一些代码。

1169
00:37:15,530 --> 00:37:16,660
0,600
code.|
|

1170
00:37:16,920 --> 00:37:18,630
0,750 780,1050 1050,1350 1350,1560 1560,1710
{} Let me get rid
让我跳出这个这个窗口，

1171
00:37:18,630 --> 00:37:19,660
0,150 150,450
of the

1172
00:37:24,180 --> 00:37:25,650
0,360 360,750 750,1110 1110,1200 1200,1470
this window,| actually I don't
|其实我也不需要这个。

1173
00:37:25,650 --> 00:37:27,750
0,180 180,330 330,570 570,960 1290,2100
really need that either.| I'm
|我不打算使用 gdb 来遍历代码，

1174
00:37:27,840 --> 00:37:29,010
0,270 270,390 390,480 480,960 960,1170
not going to run use

1175
00:37:29,010 --> 00:37:30,420
0,450 450,600 600,870 870,1050 1050,1410
gdb to walk through things,|
|

1176
00:37:30,420 --> 00:37:31,080
0,120 120,240 240,360 360,450 450,660
I'm just going to look
我只想看看相关的特定函数。

1177
00:37:31,080 --> 00:37:32,820
0,390 390,870 870,870 870,1320 1320,1740
{at -} {you,know} particular functions

1178
00:37:32,820 --> 00:37:35,140
0,150 150,270 270,840 1170,1740
that are relevant {}.|
|

1179
00:37:35,140 --> 00:37:36,280
0,210 210,510 510,570 570,840 840,1140
So probably the first thing
所以，第一件事可能是在 start.c 中，

1180
00:37:36,280 --> 00:37:37,900
0,330 330,690 720,1020 1020,1380 1380,1620
is in {} {start.c -

1181
00:37:37,900 --> 00:37:39,850
0,450 480,660 660,930 930,1470 1560,1950
-}.| So when the machine
|当机器启动时，处理器启动时，

1182
00:37:39,850 --> 00:37:41,780
0,330 330,510 510,870 870,1440
boots, what processor boots,|
|

1183
00:37:41,780 --> 00:37:44,620
0,660 660,1260 1680,2310
{} the {}
start 函数被调用，

1184
00:37:45,190 --> 00:37:46,810
0,420 480,900 900,1170 1170,1260 1260,1620
the start function is called,|
|

1185
00:37:46,810 --> 00:37:47,920
0,210 210,510 510,720 720,930 930,1110
its runs in the M
它以 M 模式运行，

1186
00:37:47,920 --> 00:37:51,460
0,510 540,1140 1500,2460 2490,3330 3330,3540
mode,| {} and {} it
|它禁用了页表，

1187
00:37:51,580 --> 00:37:55,360
0,570 570,1170 1770,2610 2880,3300 3300,3780
disables paging,| so right away,
|因为很快，稍后，

1188
00:37:55,450 --> 00:37:56,740
0,540 540,630 630,870 990,1230 1230,1290
because you know sort of

1189
00:37:56,740 --> 00:37:57,580
0,300 300,450 450,510 510,750 750,840
later on,| the kernel can
|内核可以设置页表，

1190
00:37:57,580 --> 00:37:58,750
0,150 150,270 270,330 330,570 570,1170
set up the page tables|
|

1191
00:37:58,960 --> 00:38:00,130
0,480 480,600 600,780 780,1020 1020,1170
and we see here that|
我们在这里看到，|

1192
00:38:00,130 --> 00:38:02,230
0,390 390,990 990,1590 1590,2010 2010,2100
basically delegates all interrupts and
将所有中断和异常交给管理者模式，

1193
00:38:02,230 --> 00:38:04,450
0,450 450,540 540,1080 1080,1560 1590,2220
exceptions to supervisor mode {},|
|

1194
00:38:04,780 --> 00:38:07,780
0,870 870,1380 1380,1800 1830,2370 2370,3000
then {} it's programs the
然后，对管理者中断启用寄存器编程，

1195
00:38:08,200 --> 00:38:11,200
0,930 930,1620 1920,2280 2280,2550 2550,3000
supervisor enable interrupt enable register|
|

1196
00:38:11,200 --> 00:38:12,620
0,450 540,1080
to take
用来接受软件中断，定时器中断，以及外部中断。

1197
00:38:12,650 --> 00:38:15,380
0,570 600,960 960,1500 1770,2160 2160,2730
{} software interrupts, timer interrupts,

1198
00:38:15,770 --> 00:38:17,940
0,690 690,1080 1080,1620
and external interrupts.|
|

1199
00:38:18,500 --> 00:38:20,510
0,690 1080,1230 1230,1770 1770,1890 1890,2010
{} And then for good
然后为了更好的[衡量]，

1200
00:38:20,510 --> 00:38:23,180
0,570 570,1020 1380,2040 2040,2340 2340,2670
[measure],| {} timer interrupts actually
|定时器中断发生在 M 模式，

1201
00:38:23,180 --> 00:38:24,500
0,300 300,720 720,900 900,1230 1230,1320
happened to {} coming to

1202
00:38:24,500 --> 00:38:26,300
0,990 1110,1290 1290,1620 1620,1740 1740,1800
{} are handled in M

1203
00:38:26,300 --> 00:38:29,360
0,510 810,1650 1920,2520
mode,| {} the
|M 模式代码对定时器寄存器编程，

1204
00:38:29,600 --> 00:38:31,550
0,360 360,630 630,930 930,1470 1470,1950
M mode code, actually programs,

1205
00:38:31,550 --> 00:38:33,920
0,720 1080,1770
the {}

1206
00:38:33,920 --> 00:38:36,440
0,390 390,1080 1200,1800 1800,1980 1980,2520
timer registers| and so that
|然后产生计时器中断。

1207
00:38:36,440 --> 00:38:38,570
0,300 300,1080 1110,1380 1380,1740 1740,2130
timer {} timer interrupts are

1208
00:38:38,600 --> 00:38:39,840
0,630
generated.|
|

1209
00:38:40,080 --> 00:38:40,860
0,30 30,360 360,540 540,600 600,780
I don't want to talk
我不想讨论这个，

1210
00:38:40,860 --> 00:38:42,150
0,150 150,390 390,840 870,1140 1140,1290
about that actually,| so I'm
|所以，我要去看 main.c 。

1211
00:38:42,150 --> 00:38:43,080
0,150 150,330 330,420 420,720 720,930
gonna go to {main.c -

1212
00:38:43,080 --> 00:38:44,060
0,360
-}.|
|

1213
00:38:46,980 --> 00:38:49,080
0,690 690,1080 1080,1230 1230,1440 1440,2100
{} And so see how
看看外部设备是如何处理的，

1214
00:38:49,110 --> 00:38:50,820
0,480 480,870 870,960 960,1470 1500,1710
external devices are handled| and
|我们的第一个外部设备是可以打印的 console 。

1215
00:38:50,820 --> 00:38:52,500
0,180 180,330 330,600 600,1110 1110,1680
so our first external devices

1216
00:38:52,500 --> 00:38:54,540
0,120 120,840 1380,1620 1620,1770 1770,2040
{is,the} console where we print

1217
00:38:54,540 --> 00:38:55,440
0,330
to.|
|

1218
00:38:55,440 --> 00:38:56,880
0,390 390,990 990,1110 1110,1320 1320,1440
And we can see what
我们可以看看 consoleinit 做了什么。

1219
00:38:56,880 --> 00:38:58,440
0,390 390,540 540,1050
{consoleinit -} does.|
|

1220
00:38:59,520 --> 00:39:01,080
0,720 720,870 870,1080 1080,1410 1410,1560
{} So here's {consoleinit -
这是 consoleinit ，

1221
00:39:01,080 --> 00:39:03,960
0,360 480,1470 1590,2040 2040,2340 2340,2880
-},| {} {initialize -} lock,
|初始化锁，实际上我们不关心这个，

1222
00:39:03,960 --> 00:39:05,010
0,300 300,480 480,690 690,870 870,1050
we actually care not much

1223
00:39:05,010 --> 00:39:07,200
0,210 210,390 390,510 510,930 1080,2190
about that at all {},|
|

1224
00:39:07,200 --> 00:39:08,820
0,390 390,570 570,960 990,1140 1140,1620
it's not for this lecture,|
它不是这节课（的内容），|

1225
00:39:08,880 --> 00:39:10,860
0,570 570,900 900,1290 1290,1620 1620,1980
and it actually basically calls
它调用了 uartinit 。

1226
00:39:10,860 --> 00:39:12,090
0,90 90,300 300,660 690,900 900,1230
that {uartinit - - -}.|
|

1227
00:39:12,840 --> 00:39:15,180
0,810 1170,1590 1590,1770 1770,1920 1920,2340
And {uartinit - - -}
uartinit 在这里。

1228
00:39:15,660 --> 00:39:17,440
0,390 390,630 630,1230
is right here.|
|

1229
00:39:18,380 --> 00:39:20,210
0,630 900,1110 1110,1410 1410,1710 1710,1830
{} It actually sets up
它设置了 UART 芯片，

1230
00:39:20,210 --> 00:39:23,030
0,90 90,390 390,960 1350,2520 2520,2820
the uart chip { -},|
|

1231
00:39:23,030 --> 00:39:24,350
0,420 420,720 720,1020 1020,1140 1140,1320
configure uart chips that is
配置要使用的 UART 芯片。

1232
00:39:24,350 --> 00:39:25,740
0,240 240,390 390,960
ready for use.|
|

1233
00:39:25,740 --> 00:39:27,480
0,840 840,1020 1020,1140 1170,1470 1470,1740
{} You know first actually
首先是禁用中断，

1234
00:39:27,480 --> 00:39:29,190
0,510 510,1020 1020,1110 1110,1230 1230,1710
disables interrupts,| you know there's
|你知道有一个顺序，

1235
00:39:29,190 --> 00:39:29,970
0,60 60,480 480,600 600,720 720,780
the sequence,| you have to
|当你对它编程时，必须遵守，

1236
00:39:29,970 --> 00:39:31,260
0,210 210,660 660,690 690,840 840,1290
go through when you program

1237
00:39:31,260 --> 00:39:32,790
0,240 630,1200 1230,1380 1380,1440 1440,1530
it,| {} then you can
|然后，你可以设置波特率，

1238
00:39:32,790 --> 00:39:35,280
0,120 120,210 210,510 510,1050 1410,2490
set the baud rate {},|
|

1239
00:39:35,310 --> 00:39:37,410
0,480 480,1080 1110,1350 1350,1740 1740,2100
{then,you} set in six {}
然后设置 6 7 位，

1240
00:39:37,410 --> 00:39:38,730
0,240 240,570 570,1050 1050,1170 1170,1320
{you,know} seven bits,| you know
|7 位或 8 位[修复] UART 。

1241
00:39:38,730 --> 00:39:39,930
0,300 300,420 420,570 570,720 720,1200
seven or eight bit bits

1242
00:39:39,930 --> 00:39:41,640
0,240 240,690 690,810 810,1260
will [repaired] {uart -}.|
|

1243
00:39:41,670 --> 00:39:42,960
0,720

1244
00:39:43,080 --> 00:39:45,860
0,960 990,2070
And, {}
然后，重新设置 UART 的内部 FIFO ，

1245
00:39:46,260 --> 00:39:47,550
0,300 300,570 570,810 810,930 930,1290
{} you reset the internal

1246
00:39:47,550 --> 00:39:49,800
0,300 300,630 630,840 840,870 870,2250
{FIFO -} {that's -} {}

1247
00:39:50,430 --> 00:39:51,720
0,330 330,660 660,750 750,1140 1140,1290
uart has| to clear out
|清除那里可能存在的任何东西，

1248
00:39:51,720 --> 00:39:53,220
0,270 270,480 480,1020 1020,1320 1320,1500
anything that actually might be

1249
00:39:53,220 --> 00:39:54,960
0,150 150,630 780,1020 1020,1740 1740,1740
in there| and then, {}
|然后，接收到，

1250
00:39:54,960 --> 00:39:57,450
0,510 510,1170 1200,1950 1950,2220 2310,2490
will receive {},| it will
|它将启用传输中断和接收中断。

1251
00:39:57,450 --> 00:40:00,090
0,690 690,1410 1440,1890 1890,2040 2040,2640
enable {} interrupts for transmission

1252
00:40:00,090 --> 00:40:01,280
0,150 150,690
and {receive,interruption}.|
|

1253
00:40:02,890 --> 00:40:03,880
0,420 420,540 540,720 720,780 780,990
{} {Amir -}, I think
Amir ，我想你举手了。

1254
00:40:03,880 --> 00:40:05,640
0,330 330,540 540,660 660,1050
you raise your hand.|
|

1255
00:40:07,140 --> 00:40:08,250
0,180 180,360 360,690 690,900 900,1110
Yeah, I'm wondering what the
是的，我想知道波特率是什么。

1256
00:40:08,250 --> 00:40:10,380
0,300 300,540 540,750 750,1440 1740,2130
baud rate is exactly.| {Oh,the}
|哦，是线路运行的速度。

1257
00:40:10,380 --> 00:40:11,640
0,330 330,690 690,810 810,930 930,1260
speed which you know the

1258
00:40:11,670 --> 00:40:13,000
0,300 300,870
lines runs.|
|

1259
00:40:14,740 --> 00:40:16,980
0,150 150,300 300,720 1170,1620
{} I see, thanks.|
我知道了，谢谢。|

1260
00:40:18,940 --> 00:40:20,180
0,720

1261
00:40:20,510 --> 00:40:21,410
0,210 210,330 330,570 570,750 750,900
Okay, so that's {uartinit -
好的，那就是 uartinit 。

1262
00:40:21,410 --> 00:40:23,300
0,150 150,480 540,1260 1560,1800 1800,1890
- -}.| {} Now at
|现在，原则上 UART 可以生成中断，

1263
00:40:23,300 --> 00:40:24,560
0,150 150,630 630,720 720,900 900,1260
this point you know the

1264
00:40:24,560 --> 00:40:26,210
0,210 210,330 330,420 420,1110 1170,1650
{uart -} in principle {}

1265
00:40:26,210 --> 00:40:28,190
0,240 240,570 570,1200 1320,1710 1710,1980
can generate interrupts,| {} but
|但是当然我们还没有对中断启用寄存器编程，

1266
00:40:28,190 --> 00:40:28,940
0,60 60,270 270,450 450,480 480,750
of course we are we

1267
00:40:28,940 --> 00:40:30,560
0,210 210,540 540,1050 1050,1110 1110,1620
haven't actually programm the interrupt

1268
00:40:30,560 --> 00:40:32,930
0,480 480,780 780,1200 1200,1620 2040,2370
enabling stuff| on the on
|在 RISC-V 处理器上，

1269
00:40:32,930 --> 00:40:34,370
0,180 180,360 360,600 600,900 900,1440
the {RISC-V -} processor itself,|
|

1270
00:40:34,370 --> 00:40:35,540
0,270 270,480 480,810 810,900 900,1170
we haven't programmed to PLIC
我们还没有对 PLIC 编程，

1271
00:40:35,540 --> 00:40:37,640
0,330 480,870 870,1140 1140,1770
yet,| nothing really happens
|这个时候，什么都不会发生。

1272
00:40:37,990 --> 00:40:39,340
0,420 420,600 600,780 780,990 990,1350
{} at this point yet.|
|

1273
00:40:39,340 --> 00:40:40,210
0,120 120,240 240,360 360,600 600,870
And so the next thing,
所以下一件事，我们将回到 main.c ，

1274
00:40:40,210 --> 00:40:40,900
0,180 180,300 300,450 450,510 510,690
{} we're going to move

1275
00:40:40,900 --> 00:40:42,400
0,330 330,540 540,840 840,1080 1080,1500
back to {main.c - -},|
|

1276
00:40:42,820 --> 00:40:44,650
0,600 600,750 750,990 990,1590 1590,1830
{} {you,know} we'll see, a
我们会看到，向下滚动一点，

1277
00:40:44,650 --> 00:40:46,690
0,150 150,360 390,750 750,1380 1710,2040
little bit scroll down {},|
|

1278
00:40:46,690 --> 00:40:47,800
0,180 180,360 360,720 720,900 900,1110
we'll see actually that the
我们会看到 PLIC 初始化，

1279
00:40:47,800 --> 00:40:49,840
0,390 390,570 570,1290 1530,1740 1740,2040
PLIC is initialized,| so let's
|让我们来看看这个。

1280
00:40:49,840 --> 00:40:51,140
0,180 180,270 270,750
look at that.|
|

1281
00:40:52,540 --> 00:40:54,980
0,660 660,1050 1050,1860
{} And basically,
基本上， plicinit 代码，

1282
00:40:55,100 --> 00:40:55,940
0,150 150,360 390,600 600,720 720,840
you know, {plicinit - -}

1283
00:40:55,940 --> 00:40:57,650
0,540 720,1260 1260,1380 1380,1500 1500,1710
code,| {} if you look
|如果看一下我刚才给你的这张表格，

1284
00:40:57,650 --> 00:40:59,090
0,90 90,420 600,1200 1200,1380 1380,1440
at this table that I

1285
00:40:59,090 --> 00:41:00,170
0,300 300,510 510,660 660,840 840,1080
showed you a little while

1286
00:41:00,170 --> 00:41:02,660
0,420 420,630 630,1200 1260,1590 1590,2490
ago,| with the physical memory
|物理内存或内存布局，

1287
00:41:02,660 --> 00:41:04,010
0,150 150,270 270,690 690,1080 1080,1350
or the memory layout,| {you,know}
|你知道， PLIC 在某个特定的位置，

1288
00:41:04,010 --> 00:41:05,270
0,150 150,630 750,930 930,1050 1050,1260
the PLIC is in some

1289
00:41:05,270 --> 00:41:07,400
0,600 630,1620
particular location

1290
00:41:07,430 --> 00:41:08,840
0,300 300,810 810,930 930,1110 1110,1410
right,| location is in {kernel/memlayout.h
|位置在 kernel/memlayout.h 。

1291
00:41:08,840 --> 00:41:10,340
0,300 300,930
- -}.|
|

1292
00:41:10,340 --> 00:41:11,420
0,330 330,480 480,630 630,840 840,1080
{} We see the PLIC
我们看到 PLIC 是 0C000000 ，

1293
00:41:11,420 --> 00:41:13,010
0,420 420,720 720,1020 1020,1200 1200,1590
{0C000000 - - - -}

1294
00:41:13,010 --> 00:41:14,570
0,540 540,900 900,1260 1260,1410 1410,1560
correct,| literally copied from that
|字面上是从那份文档复制过来的。

1295
00:41:14,570 --> 00:41:15,740
0,630
document.|
|

1296
00:41:15,890 --> 00:41:17,360
0,660 660,750 750,990 990,1080 1080,1470
And you know the way
我们向 PLIC 写东西，

1297
00:41:17,360 --> 00:41:18,350
0,210 210,480 480,780 780,870 870,990
we write stuff to the

1298
00:41:18,350 --> 00:41:20,120
0,270 270,390 390,1050 1350,1530 1530,1770
PLIC| is basically you take
|使用 PLIC 的地址编号，

1299
00:41:20,120 --> 00:41:22,520
0,1170 1200,1800 1800,1950 1950,2040 2040,2400
the number the {} address

1300
00:41:22,520 --> 00:41:25,700
0,210 210,300 300,780 1080,1800 2220,3180
for the PLIC| {} cast
|强制转换为 32 整数指针，

1301
00:41:25,700 --> 00:41:27,080
0,150 150,480 480,690 690,960 960,1380
{} to {} a 32

1302
00:41:27,080 --> 00:41:28,730
0,300 300,630 660,900 900,1380 1380,1650
pointer { -} integer,| because
|因为 PLIC 寄存器是 32 位的。

1303
00:41:28,730 --> 00:41:30,200
0,270 300,600 600,1020 1020,1110 1110,1470
the PLIC registers are 32

1304
00:41:30,200 --> 00:41:31,160
0,390
bit.|
|

1305
00:41:31,160 --> 00:41:32,870
0,180 180,780 780,1080 1080,1380 1380,1710
And then basically write onto
然后写入，

1306
00:41:32,870 --> 00:41:34,010
0,270 300,480 480,660 660,1050 1050,1140
it,| so this cast is
|这个强制转换是将 1 写入寄存器 UART0_IRQ 。

1307
00:41:34,010 --> 00:41:35,450
0,420 420,510 510,1020 1020,1200 1200,1440
basically {} one to be

1308
00:41:35,450 --> 00:41:38,960
0,540 750,1590 1800,2220 2220,3030 3030,3510
written to the register {UART0_IRQ

1309
00:41:38,960 --> 00:41:40,720
0,570 570,840 840,1230
- - -}.|
|

1310
00:41:41,060 --> 00:41:42,320
0,360 360,660 660,750 750,900 900,1260
And basically what this does
这个说做的就是，

1311
00:41:42,320 --> 00:41:44,480
0,480 480,690 690,1290 1290,1710 1710,2160
is| it enables interrupt requests
|它启用来自 UART 的中断请求，

1312
00:41:44,480 --> 00:41:46,970
0,780 780,870 870,1440 1890,2100 2100,2490
from the uart,| so remember
|记得 PLIC 路由中断，

1313
00:41:46,970 --> 00:41:49,400
0,90 90,570 570,1020 1020,1650 1680,2430
the PLIC basically routes {}

1314
00:41:49,790 --> 00:41:51,320
0,360 360,930 930,1140 1140,1350 1350,1530
{} interrupts,| and so the
|所以中断可能从图片左侧进入 PLIC ，

1315
00:41:51,320 --> 00:41:52,490
0,480 480,660 660,810 810,990 990,1170
interrupt might come in from

1316
00:41:52,490 --> 00:41:53,270
0,60 60,270 270,540 540,660 660,780
the left side from that

1317
00:41:53,270 --> 00:41:54,860
0,450 450,840 840,1140 1170,1500 1500,1590
picture into the PLIC| and
|这个程序中， PLIC 可以接受这些中断。

1318
00:41:54,860 --> 00:41:56,810
0,90 90,570 570,1230 1260,1530 1530,1950
the PLIC, like this program

1319
00:41:56,810 --> 00:41:58,310
0,270 270,420 420,750 750,1290 1290,1500
PLIC to actually accept those

1320
00:41:58,310 --> 00:41:59,220
0,510
interrupts.|
|

1321
00:42:00,270 --> 00:42:01,890
0,600 600,900 900,1320 1320,1380 1380,1620
Similarly, actually programs the PLIC
类似地，对 PLIC 编程，从 IO 磁盘接收中断，

1322
00:42:01,890 --> 00:42:03,720
0,120 120,750 750,1050 1050,1320 1320,1830
to accepting interrupts from the

1323
00:42:03,930 --> 00:42:05,370
0,360 360,810 840,1230 1230,1320 1320,1440
IO disk,| which I'm not
|我不会讨论论这个。

1324
00:42:05,370 --> 00:42:06,030
0,120 120,180 180,330 330,540 540,660
going to talk about at

1325
00:42:06,030 --> 00:42:06,800
0,240
all.|
|

1326
00:42:08,510 --> 00:42:09,800
0,390 390,510 510,960 990,1200 1200,1290
Okay, and then, {} we
好的，然后，我们回到 main.c 。

1327
00:42:09,800 --> 00:42:11,420
0,120 120,690 720,870 870,1110 1110,1620
go back, you know to

1328
00:42:11,480 --> 00:42:13,860
0,270 270,510 510,1050 1110,1800
{main.c - -}.| And
|在 plicinit 之后，是 plicinithart ，

1329
00:42:14,200 --> 00:42:16,660
0,870 1140,1590 1620,1920 1920,2340 2340,2460
{} there right after the

1330
00:42:16,660 --> 00:42:17,740
0,240 240,330 330,540 540,870 870,1080
{plicinit -} {} is just

1331
00:42:17,740 --> 00:42:18,760
0,210 210,300 300,390 390,840 870,1020
{plicinithart - - -}| and
|针对每个核心，每个独立核心，

1332
00:42:18,760 --> 00:42:20,800
0,150 150,540 540,780 780,1320 1560,2040
then basically for every cores

1333
00:42:20,800 --> 00:42:22,120
0,780
specifically,

1334
00:42:22,370 --> 00:42:23,760
0,570 570,810
{ -}

1335
00:42:24,260 --> 00:42:25,940
0,270 270,510 510,1110 1110,1350 1350,1680
every core individually,| so only
|只有一个核心，第一个核心初始化该方面，

1336
00:42:25,940 --> 00:42:27,680
0,360 360,810 810,990 990,1410 1410,1740
one core, the first core

1337
00:42:27,680 --> 00:42:30,590
0,450 450,1140 1140,1590 1590,2250 2490,2910
actually initialize this [aspect],| basically
|我们接收这些设备的中断，

1338
00:42:30,590 --> 00:42:31,730
0,180 180,510 510,900 900,990 990,1140
we're taking interrupts on those

1339
00:42:31,730 --> 00:42:33,830
0,600 990,1200 1200,1350 1350,1590 1590,2100
devices| and then every core
|然后，每个核心都必须单独地说我也对这些设备感兴趣。

1340
00:42:33,830 --> 00:42:35,780
0,690 690,930 930,1020 1020,1590 1650,1950
individually has to say I'm

1341
00:42:35,780 --> 00:42:37,280
0,420 420,540 540,720 720,1170 1170,1500
interested in those devices too.|
|

1342
00:42:37,980 --> 00:42:39,270
0,360 360,600 600,810 810,900 900,1290
{} And so for example
比如，在这里，

1343
00:42:39,270 --> 00:42:42,150
0,690 840,2040 2130,2430 2430,2670 2670,2880
here,| {} every core actually
|每个核心都调用这些函数，

1344
00:42:42,150 --> 00:42:43,890
0,240 240,420 420,960 960,1230 1230,1740
calls these functions,| every cores,
|每个核心，都对来自 UART 的中断感兴趣，

1345
00:42:43,890 --> 00:42:45,570
0,240 240,630 630,1080 1110,1290 1290,1680
{} interested in {} interrupt

1346
00:42:45,570 --> 00:42:47,430
0,750 780,1380 1380,1590 1590,1650 1650,1860
from uart| and I'm interested
|也对 VIRTIO 的中断感兴趣。

1347
00:42:47,520 --> 00:42:49,800
0,510 510,1110 1110,1440 1440,1650 1740,2280
the interrupts from the virtio.|
|

1348
00:42:50,730 --> 00:42:51,630
0,180 180,270 270,390 390,540 540,900
You can see here basically
你在这里可以看到 UART0_IRQ ，

1349
00:42:51,630 --> 00:42:53,070
0,150 150,540 540,870 870,1080 1080,1440
the {UART0_IRQ - - -},|
|

1350
00:42:53,070 --> 00:42:55,320
0,720 750,1320 1650,1800 1800,1890 1890,2250
basically {} is a unique
是一个唯一的数字，

1351
00:42:55,320 --> 00:42:57,360
0,600 600,690 690,840 840,1590 1680,2040
number,| you know for, {}
|UART_IRQ 在 UART 中，

1352
00:42:57,360 --> 00:43:00,030
0,150 150,690 1260,1680 1680,2250 2250,2670
the {UART_IRQ,for - -} in

1353
00:43:00,150 --> 00:43:01,320
0,180 180,360 360,690 690,1020 1050,1170
what {uart -},| and I
|我想在 QEMU 上是编号 10 。

1354
00:43:01,320 --> 00:43:03,100
0,300 300,600 600,870 870,1230
think believes on the

1355
00:43:03,100 --> 00:43:05,200
0,390 390,960 960,1170 1170,1530
on QEMU number ten.|
|

1356
00:43:06,540 --> 00:43:09,180
0,420 420,570 570,1350 1500,1920 1920,2640
And we're basically ignore priority|
我们忽略 priority ，|

1357
00:43:09,180 --> 00:43:09,870
0,150 150,270 270,420 420,570 570,690
and so we just set
所以我们把它设为零。

1358
00:43:09,870 --> 00:43:11,060
0,90 90,180 180,660
it to zero.|
|

1359
00:43:11,880 --> 00:43:13,230
0,510 630,780 780,900 900,1050 1050,1350
Okay, and so does every
好的，每个 CPU 单独调用，

1360
00:43:13,230 --> 00:43:15,180
0,210 210,540 540,780 780,1110 1110,1950
CPU {} already called individually|
|

1361
00:43:15,180 --> 00:43:16,020
0,180 180,240 240,630 630,720 720,840
has to indicate to the
必须向 PLIC 表明，

1362
00:43:16,020 --> 00:43:17,370
0,270 270,420 420,720 720,810 810,1350
PLIC,| that actually is interested
|它对接收中断感兴趣。

1363
00:43:17,400 --> 00:43:20,680
0,480 570,1650 1710,2250 2250,2820
in receiving {} interrupts.|
|

1364
00:43:22,290 --> 00:43:23,160
0,180 180,270 270,420 420,780 780,870
{You,know}, at this point you
在这一点，你知道 PLIC ，

1365
00:43:23,160 --> 00:43:24,300
0,150 150,690 780,900 900,990 990,1140
know we're you know the

1366
00:43:24,300 --> 00:43:26,130
0,330 330,960 1080,1200 1200,1530 1530,1830
PLIC basically,| so we basically
|所以我们必须对设备进行编程以产生中断，

1367
00:43:26,130 --> 00:43:27,330
0,90 90,180 180,630 630,690 690,1200
have to program the device

1368
00:43:27,330 --> 00:43:28,470
0,90 90,450 450,900 900,1020 1020,1140
to generate interrupts,| we have
|我们对 PLIC 编程在各个 CPU 上传递中断，

1369
00:43:28,470 --> 00:43:29,790
0,360 360,480 480,930 960,1080 1080,1320
program to PLIC {you,know} to

1370
00:43:29,790 --> 00:43:32,550
0,420 420,870 870,1470 1560,1620 1620,2760
pass interrupts on the individual

1371
00:43:32,610 --> 00:43:34,170
0,480 480,690 870,1110 1110,1170 1170,1560
{CPUs -},| but the CPU
|但是 CPU 本身还没有接受中断，

1372
00:43:34,170 --> 00:43:35,670
0,510 510,750 750,1050 1050,1170 1170,1500
itself have actually are not

1373
00:43:35,670 --> 00:43:37,530
0,420 420,840 840,1230 1260,1740 1740,1860
accepting interrupt yet,| because we
|因为我们还没有设置 SSTATUS 寄存器中的位，

1374
00:43:37,530 --> 00:43:38,640
0,270 270,660
haven't set

1375
00:43:38,640 --> 00:43:39,600
0,210 210,450 450,630 630,780 780,960
the bit in the {SSTATUS

1376
00:43:39,600 --> 00:43:40,800
0,240 240,300 300,690 690,1050 1050,1200
-} register {} yet| and
|所以，让我们回到 main.c 。

1377
00:43:40,800 --> 00:43:43,200
0,420 600,1020 1020,1200 1200,1770 1800,2400
so let's go back to

1378
00:43:43,230 --> 00:43:45,180
0,270 270,630 630,870 870,1410
to {main.c - -}.|
|

1379
00:43:47,440 --> 00:43:49,300
0,450 450,1080 1110,1560 1560,1710 1710,1860
And whatever {main.c -} does
main.c 做了更多初始化，

1380
00:43:49,300 --> 00:43:51,160
0,60 60,240 240,330 330,1290 1440,1860
a bunch of {more,initialization} {},|
|

1381
00:43:51,160 --> 00:43:51,790
0,120 120,180 180,330 330,540 540,630
but in the end it
但是，最后它调用了 scheduler 。

1382
00:43:51,790 --> 00:43:53,480
0,210 210,450 450,510 510,1170
actually calls the scheduler.|
|

1383
00:43:53,940 --> 00:43:55,170
0,270 270,480 480,810 810,930 930,1230
So let's look at {proc.c
所以，我们来看一下 proc.c ，

1384
00:43:55,170 --> 00:43:56,480
0,240 240,750
- -},|
|

1385
00:43:56,960 --> 00:43:59,880
0,870 990,1320 1320,1380 1500,2370
and get {} scheduler.|
搜索 scheduler 。|

1386
00:44:04,940 --> 00:44:06,020
0,300 300,480 480,600 600,780 780,1080
And what we see here,|
我们在这里看到的是，|

1387
00:44:06,020 --> 00:44:07,400
0,90 90,210 210,420 420,990 1050,1380
is like when the around
整个机器的，

1388
00:44:07,400 --> 00:44:08,990
0,450 450,750 900,1140 1140,1500 1500,1590
basically the whole machine| is
|处理器已经设置，

1389
00:44:08,990 --> 00:44:09,950
0,180 180,240 240,330 330,810 810,960
sort of the processors has

1390
00:44:09,950 --> 00:44:12,020
0,150 150,780 960,1170 1170,1560 1560,2070
been setup| and scheduler schedules
|调度器调度虚拟进程运行，

1391
00:44:12,020 --> 00:44:15,650
0,930 1440,1920 1920,2250 2250,2670 2670,3630
{} virtual process run,| before
|在任何一个启用中断之前。

1392
00:44:15,920 --> 00:44:17,660
0,930 930,1080 1080,1410 1410,1650 1650,1740
{} you know any of

1393
00:44:17,660 --> 00:44:19,740
0,420 420,750 750,1140 1140,1710
that actually enables interrupts.|
|

1394
00:44:20,180 --> 00:44:21,110
0,180 180,390 390,600 600,780 780,930
And so we look at
所以，我们来看看 riscv.h 。

1395
00:44:21,110 --> 00:44:22,480
0,210 210,840
{riscv.h -}.|
|

1396
00:44:22,530 --> 00:44:23,910
0,300 300,450 450,690 690,990 990,1380
You'll see, there's {} basically
你们会看到，这是一个 C 函数。

1397
00:44:23,910 --> 00:44:25,000
0,180 180,300 300,630
this is a

1398
00:44:25,700 --> 00:44:27,740
0,330 360,690 690,1410
{} C function.|
|

1399
00:44:28,240 --> 00:44:30,040
0,450 450,840 840,1170 1170,1590 1590,1800
And basically enables interrupts| and
它启用中断|你不会感到惊讶，

1400
00:44:30,040 --> 00:44:31,660
0,120 120,570 570,840 840,1530 1530,1620
you can not surprising| you
|它唯一能做的就是，

1401
00:44:31,660 --> 00:44:32,500
0,90 90,420 420,480 480,720 720,840
know basically the only thing

1402
00:44:32,500 --> 00:44:34,180
0,90 90,570 690,1050 1050,1380 1380,1680
it does,| it {} sets
|设置 SSTATUS 寄存器中的中断启用位。

1403
00:44:34,180 --> 00:44:35,620
0,180 180,600 600,990 990,1230 1230,1440
the interrupt enable bit in

1404
00:44:35,620 --> 00:44:37,120
0,180 180,540 540,900
the sstatus register.|
|

1405
00:44:37,330 --> 00:44:38,560
0,300 300,390 390,570 570,870 870,1230
So at this particular point
在这个特殊的时刻，

1406
00:44:38,560 --> 00:44:41,290
0,510 870,1830 1830,2040 2040,2190 2190,2730
time,| right at this instance
|如果在 PLIC 处存在挂起的中断，

1407
00:44:41,290 --> 00:44:42,970
0,720 750,1020 1020,1230 1230,1290 1290,1680
if there were an interrupt

1408
00:44:42,970 --> 00:44:45,070
0,390 390,510 510,600 600,1080 1290,2100
pending at the PLIC,| then
|那么这个特殊的核心会被中断。

1409
00:44:45,070 --> 00:44:46,270
0,90 90,240 240,600 600,780 780,1200
you know the this particular

1410
00:44:46,270 --> 00:44:48,040
0,420 420,600 600,690 690,1320
core would be interrupted.|
|

1411
00:44:48,770 --> 00:44:50,150
0,120 120,270 270,870 870,1140 1140,1380
We {see,that} a second later,|
我们随后会看到，|

1412
00:44:50,150 --> 00:44:50,960
0,120 120,240 240,300 300,480 480,810
but this is this point
但是，此时启用了中断。

1413
00:44:50,960 --> 00:44:52,880
0,420 420,780 780,1410
interrupts are enabled.|
|

1414
00:44:53,840 --> 00:44:54,530
0,240 240,360 360,510 510,600 600,690
And so this is the
这就是基本设置。

1415
00:44:54,530 --> 00:44:55,900
0,330 330,870
basic setup.|
|

1416
00:44:56,050 --> 00:44:57,700
0,240 240,570 570,780 780,1110
Any questions about this?|
对于这个，有什么问题吗？|

1417
00:45:02,020 --> 00:45:03,550
0,300 300,780 810,1020 1020,1260 1260,1530
Oh, sorry,| oh, what core
不好意思，|在那个时刻，哪个核心会被打断呢？

1418
00:45:03,550 --> 00:45:06,460
0,420 420,840 1320,2340
would be interrupted

1419
00:45:06,460 --> 00:45:08,420
0,450 480,660 660,840 840,1350
when at that point?|
|

1420
00:45:08,420 --> 00:45:10,040
0,510 630,960 960,1320 1320,1560 1560,1620
So every core runs the
所以，每个核心都运行调度器循环。

1421
00:45:10,040 --> 00:45:11,680
0,360 360,600 600,1050
scheller loop, correct.|
|

1422
00:45:11,680 --> 00:45:14,140
0,660 960,1350 1350,1710 1710,1950 1950,2460
And whatever core calls interrupt
无论什么核心启用中断，

1423
00:45:14,140 --> 00:45:16,150
0,540 1110,1380 1380,1650 1650,1770 1770,2010
on,| all cores will call
|所有内核都会启用中断，

1424
00:45:16,150 --> 00:45:17,290
0,480 480,600 600,780 780,960 960,1140
{interrupt,on},| but let's say there's
|但是我们假设只有一个核心最先到达那里，比如核心 1 ，

1425
00:45:17,290 --> 00:45:18,790
0,420 420,930 930,1170 1170,1380 1380,1500
only one core gets there

1426
00:45:18,790 --> 00:45:19,800
0,510
first,

1427
00:45:19,830 --> 00:45:22,440
0,840 840,1050 1050,1560 1830,2430 2430,2610
like core one| and if
|如果核心 1 在这个时刻设置中断启用位，

1428
00:45:22,440 --> 00:45:24,120
0,180 180,480 480,780 780,1200 1200,1680
core one sets its interrupt

1429
00:45:24,120 --> 00:45:25,950
0,420 420,840 1110,1290 1290,1470 1470,1830
enable bit at that point,|
|

1430
00:45:25,950 --> 00:45:27,360
0,180 180,360 360,810 810,930 930,1410
it could receive an interrupt.|
它可能会收到中断。|

1431
00:45:29,480 --> 00:45:30,350
0,210 210,300 300,480 480,570 570,870
And we'll see in second
我们随后会看到，一次中断到底发生了什么。

1432
00:45:30,350 --> 00:45:31,370
0,180 180,480 480,840 840,930 930,1020
what happens exactly in an

1433
00:45:31,370 --> 00:45:32,380
0,450
interrupt.|
|

1434
00:45:33,230 --> 00:45:35,000
0,300 300,570 570,870 870,1200
Makes sense, thank you.|
理解了，谢谢。|

1435
00:45:36,520 --> 00:45:38,800
0,690 840,1590 1800,2040 2040,2160 2160,2280
Okay, {} okay, so what
好的，那么我想做的是，

1436
00:45:38,800 --> 00:45:39,790
0,90 90,240 240,390 390,450 450,990
do I want to do|
|

1437
00:45:39,820 --> 00:45:42,160
0,810 840,1380 1380,1740 1740,1860 1860,2340
is {} look at this,|
就是看看这个，|

1438
00:45:42,280 --> 00:45:44,140
0,1230 1260,1440 1440,1560 1560,1800 1800,1860
how, how to print the
如何打印 $ ，

1439
00:45:44,140 --> 00:45:46,090
0,510 570,1440 1440,1470 1470,1860 1860,1950
$| {you,know} the prompt at
|也就是 shell 提示符。

1440
00:45:46,090 --> 00:45:47,320
0,60 60,330 330,780
the shell prompt.|
|

1441
00:45:47,550 --> 00:45:49,920
0,360 360,900 1140,1890 1950,2250 2250,2370
And so for that we
所以，我们往回一点。

1442
00:45:49,920 --> 00:45:51,060
0,150 150,420 480,810 810,1110 1110,1140
want to go back a

1443
00:45:51,060 --> 00:45:52,240
0,240 240,600
little bit.|
|

1444
00:45:52,460 --> 00:45:53,450
0,390 390,630 630,810 810,930 930,990
And our first want to
我们首先再次查看 init 。

1445
00:45:53,450 --> 00:45:55,040
0,180 180,360 360,570 570,1020
look at init again.|
|

1446
00:45:55,040 --> 00:45:55,880
0,60 60,240 240,420 420,510 510,840
So this was the first
所以，这是第一个出现的进程，

1447
00:45:55,880 --> 00:45:57,530
0,390 390,540 540,840 840,1350 1440,1650
process that actually being,| there
|在 execinit 代码中，

1448
00:45:57,530 --> 00:45:59,180
0,150 150,240 240,810 900,1170 1170,1650
in the code {} {execinit

1449
00:45:59,180 --> 00:45:59,990
0,180 180,360 360,510 510,630 630,810
- -},| and so that's
|这是第一个运行的进程。

1450
00:45:59,990 --> 00:46:01,970
0,480 630,930 930,1170 1170,1500 1500,1980
basically {} first process running.|
|

1451
00:46:02,520 --> 00:46:03,900
0,570 570,1020 1020,1080 1080,1170 1170,1380
And one of the things
它所做的一件事是，

1452
00:46:03,900 --> 00:46:06,330
0,150 150,330 330,840 1140,2160 2160,2430
that it does,| it makes
|它建立了一个代表控制台的设备。

1453
00:46:06,330 --> 00:46:08,820
0,60 60,870 1050,1410 1410,1800 1800,2490
a device {} that represents

1454
00:46:08,820 --> 00:46:09,980
0,90 90,690
the console.|
|

1455
00:46:10,100 --> 00:46:12,020
0,690 690,870 870,1350 1350,1470 1470,1920
{} So here the device
这是创建的设备，

1456
00:46:12,020 --> 00:46:13,940
0,720 840,1350 1350,1620 1620,1680 1680,1920
created,| {} using the {mknod
|使用 mknod 操作，

1457
00:46:13,940 --> 00:46:16,790
0,300 300,1050 1410,1920 1920,2340 2370,2850
-} operation| {} and returns
|并且返回文件描述符，文件描述符零，

1458
00:46:16,790 --> 00:46:18,050
0,60 60,270 270,870 960,1080 1080,1260
a file descriptor, a file

1459
00:46:18,050 --> 00:46:19,190
0,330 330,630 630,930 930,1080 1080,1140
descriptor zero,| because it's the
|因为它是第一个打开的文件描述符，

1460
00:46:19,190 --> 00:46:20,390
0,240 240,390 390,750 750,1110 1110,1200
first file descriptor open| and
|然后分配给标准输出，

1461
00:46:20,390 --> 00:46:22,280
0,150 150,510 510,780 1080,1440 1440,1890
then adopt it {for,stdout -},|
|

1462
00:46:22,310 --> 00:46:23,540
0,150 150,360 360,510 510,870 870,1230
and then for {stderr -}
然后再分配给标准错误，

1463
00:46:23,540 --> 00:46:24,830
0,90 90,300 300,360 360,840 1140,1290
and adopt it again| and
|所以，这设置了文件描述符 0 、 1 和 2 ，

1464
00:46:24,830 --> 00:46:26,120
0,120 120,270 270,660 660,960 960,1290
so this basically sets up

1465
00:46:26,600 --> 00:46:28,190
0,300 300,660 660,1050 1050,1410 1410,1590
file descriptor zero one and

1466
00:46:28,190 --> 00:46:31,280
0,540 840,1590 1590,2430 2460,2970 2970,3090
two| to {} correspond to
|对应于 console 。

1467
00:46:31,280 --> 00:46:32,400
0,60 60,600
the console.|
|

1468
00:46:33,280 --> 00:46:37,240
0,510 750,1530 1530,2190 2700,3330 3660,3960
{} Now, {} so you
现在，对于 shell 。

1469
00:46:37,240 --> 00:46:38,710
0,300 330,600 600,750 750,840 840,1470
know then for the shell.|
|

1470
00:46:40,030 --> 00:46:41,140
0,270 270,450 450,780 780,990 990,1110
{} So let's look at
让我们来看一下 shell 。

1471
00:46:41,140 --> 00:46:42,660
0,300 300,390 390,420 420,960
shell for a second.|
|

1472
00:46:42,960 --> 00:46:44,250
0,210 210,300 300,570 570,1200 1200,1290
So the shell opens you
shell 打开使用文件描述符 1 2 3 ，

1473
00:46:44,250 --> 00:46:47,190
0,150 150,480 480,960 960,1530 1920,2940
know starts running with {}

1474
00:46:47,860 --> 00:46:48,910
0,90 90,390 450,570 570,900 930,1050
the file {descriptors -} {}

1475
00:46:48,910 --> 00:46:51,130
0,270 270,510 510,1140 1620,2040 2040,2220
one two three,| {sorry,zero} one
|不好意思， 0 1 2 open 只想 console ，

1476
00:46:51,130 --> 00:46:52,480
0,120 120,300 300,810 810,930 930,1350
and two open {} pointed

1477
00:46:52,480 --> 00:46:54,730
0,90 90,210 210,870 1140,1500 1500,2250
to the console| and then
|然后 shell 将打印 $ 和空格到文件描述符 2 。

1478
00:46:54,730 --> 00:46:56,800
0,660 690,1170 1170,1830 2010,2070 2070,2070
{} shell prints {} the

1479
00:46:57,580 --> 00:47:00,700
0,1020 1050,1620 1620,1770 1770,2430 2760,3120
character $ {and,the} space {}

1480
00:47:00,700 --> 00:47:03,490
0,840 870,1590 1890,2100 2100,2460 2460,2790
to {} file descriptor two.|
|

1481
00:47:04,200 --> 00:47:05,970
0,210 210,630 840,1350 1410,1530 1530,1770
And so, {} so even
因此，尽管 console 和 UART ，

1482
00:47:05,970 --> 00:47:07,170
0,120 120,270 270,390 390,810 810,1200
though the {console -} and

1483
00:47:07,170 --> 00:47:08,250
0,210 210,570 630,750 750,900 900,1080
{uart -},| you know sort
|这些都属于应用程序员，

1484
00:47:08,250 --> 00:47:09,480
0,60 60,450 480,630 630,1080 1080,1230
of all you know []

1485
00:47:09,480 --> 00:47:11,550
0,450 480,870 870,1020 1020,1560 1560,2070
this to the application programmer,|
|

1486
00:47:11,550 --> 00:47:12,720
0,90 90,240 240,300 300,990 1110,1170
and like the shell, of
比如 shell ，当然，我们需要 shell ，

1487
00:47:12,720 --> 00:47:13,380
0,90 90,360 360,420 420,570 570,660
{course -}, we want the

1488
00:47:13,380 --> 00:47:14,550
0,390 480,720 720,900 900,1050 1050,1170
shell,| it just looks like
|它看起来就像一个普通文件，

1489
00:47:14,550 --> 00:47:16,020
0,60 60,390 390,900 1200,1410 1410,1470
a regular file,| so in
|所以实际上， shell 本身，

1490
00:47:16,020 --> 00:47:18,360
0,360 630,840 870,1230 1230,1920 2100,2340
fact the shell itself,| since
|它写入文件描述符 2 ，

1491
00:47:18,360 --> 00:47:19,440
0,150 150,510 510,600 600,930 930,1080
its writes to {descriptor -}

1492
00:47:19,440 --> 00:47:20,580
0,270 300,420 420,630 630,990 990,1140
two| has no idea what
|实际上并不知道另一边是什么，

1493
00:47:20,580 --> 00:47:21,450
0,270 270,540 540,630 630,690 690,870
actually sits on the other

1494
00:47:21,450 --> 00:47:22,650
0,420 450,780 780,870 870,990 990,1200
side| and we have seen
|我们已经在 util 实验中看到，

1495
00:47:22,650 --> 00:47:23,580
0,90 90,420 420,450 450,780 780,930
in {util -} lab,| you
|你可以用它做各种很酷的事情。

1496
00:47:23,580 --> 00:47:24,120
0,120 120,240 240,330 330,480 480,540
can do all kinds of

1497
00:47:24,120 --> 00:47:25,460
0,210 210,480 480,660 660,870
cool stuff with it.|
|

1498
00:47:25,460 --> 00:47:26,600
0,210 210,360 360,570 570,630 630,1140
{} But here's an example|
这里有一个例子，|

1499
00:47:26,600 --> 00:47:28,760
0,360 390,930 930,1050 1050,1620 1620,2160
where basically the {device,in} Unix
Unix 中的设备表示为一个文件，

1500
00:47:28,850 --> 00:47:30,350
0,240 240,780 780,930 930,1080 1080,1500
is represented as a file,|
|

1501
00:47:30,380 --> 00:47:31,730
0,240 240,540 540,870 870,1020 1020,1350
that's not different than anything
这和其他东西没什么不同。

1502
00:47:31,730 --> 00:47:32,620
0,450
else.|
|

1503
00:47:33,650 --> 00:47:35,390
0,360 360,540 540,720 720,1320 1350,1740
Okay, so let's see how
好的，让我们看看这个 printf 是如何工作的。

1504
00:47:35,390 --> 00:47:36,800
0,180 180,480 480,780 780,960 960,1410
this actually {printf -} works.|
|

1505
00:47:37,340 --> 00:47:39,350
0,600 840,1380 1410,1680 1680,1770 1770,2010
{} So there's a {printf
所以， xv6 用户应用程序中有一个 printf ，

1506
00:47:39,350 --> 00:47:42,080
0,360 360,510 510,660 660,2400 2400,2730
-} is in {xv6 -}

1507
00:47:42,080 --> 00:47:43,520
0,270 270,690 690,780 780,1170 1170,1440
user application,| a tiny little
|一个很小的 C 库，包括 printf 代码。

1508
00:47:43,520 --> 00:47:45,140
0,240 240,720 720,960 960,1380 1380,1620
C library, which includes code

1509
00:47:45,140 --> 00:47:46,340
0,240 240,570
{printf -}.|
|

1510
00:47:46,340 --> 00:47:47,960
0,660 660,750 750,840 840,1530 1530,1620
And you know printf, you
printf ，像你在 traps 实验中看到的，

1511
00:47:47,960 --> 00:47:49,520
0,270 660,810 810,990 990,1200 1200,1560
know as you've seen in

1512
00:47:49,520 --> 00:47:52,500
0,270 420,1170 1170,1530 1650,2430
the {traps,lab},| you know,
|是某种[本能]函数，

1513
00:47:52,710 --> 00:47:54,030
0,240 240,300 300,360 360,660 660,1320
sort of an instinct function

1514
00:47:54,030 --> 00:47:55,650
0,480 480,630 630,780 780,1320 1440,1620
itself,| but in {the,end} it
|但是，最终它调用了 write 系统调用，

1515
00:47:55,650 --> 00:47:57,570
0,360 360,1050 1110,1350 1350,1590 1590,1920
basically calls the write system

1516
00:47:57,570 --> 00:47:59,310
0,600 870,1320 1320,1470 1470,1590 1590,1740
call,| {} and in our
|在我们的示例中， write 系统调用是文件描述符 2 ，

1517
00:47:59,310 --> 00:48:00,390
0,300 300,450 450,630 630,810 810,1080
case where the write system

1518
00:48:00,390 --> 00:48:01,320
0,210 210,360 360,690 690,810 810,930
call would be you know

1519
00:48:01,320 --> 00:48:03,540
0,210 210,570 570,1050 1050,1560 1560,2220
file descriptor two| and c
|而 c 包含 $ 符号，

1520
00:48:03,570 --> 00:48:05,790
0,210 210,570 570,1080 1440,2070 2070,2220
would be {} hold the

1521
00:48:05,790 --> 00:48:06,990
0,390 390,900 900,1020 1020,1110 1110,1200
character $| and so we
|因此我们传递包含 $ 的内存地址

1522
00:48:06,990 --> 00:48:08,640
0,330 330,570 570,1260
pass the address

1523
00:48:08,640 --> 00:48:10,410
0,210 210,780 810,1170 1170,1620 1620,1770
of the memory location that

1524
00:48:10,410 --> 00:48:12,570
0,360 360,510 510,960 960,1560 1590,2160
holds the $| to {}
|给文件描述符用来写入，

1525
00:48:12,570 --> 00:48:14,370
0,150 150,420 420,960 1050,1320 1320,1800
the file descriptor to write|
|

1526
00:48:14,640 --> 00:48:16,110
0,480 480,600 600,1110 1140,1290 1290,1470
and we ask {you,know} to
我们要求写入一个字符。

1527
00:48:16,110 --> 00:48:17,620
0,240 240,510 510,1050
write one character.|
|

1528
00:48:19,290 --> 00:48:20,640
0,180 180,510 510,720 720,1110 1110,1350
So basically every character written
所以 shell 写入的每个字符，

1529
00:48:20,640 --> 00:48:21,510
0,150 150,240 240,630 630,720 720,870
by the shell,| {} it
|它会引起系统调用。

1530
00:48:21,510 --> 00:48:22,740
0,300 300,390 390,420 420,720 720,1230
results in a system call.|
|

1531
00:48:23,340 --> 00:48:24,090
0,210 210,330 330,510 510,630 630,750
And so now we can
现在我们可以去。

1532
00:48:24,090 --> 00:48:25,260
0,750
go.|
|

1533
00:48:25,870 --> 00:48:27,430
0,300 300,450 450,570 570,840 840,1560
Let's see what actually happens.|
让我们看看实际会发生什么。|

1534
00:48:28,040 --> 00:48:29,840
0,720 720,1200 1230,1620 1620,1710 1710,1800
{} So we you know
你之前看见过系统调用，

1535
00:48:29,840 --> 00:48:30,950
0,210 210,390 390,480 480,750 750,1110
you've seen the system call

1536
00:48:30,950 --> 00:48:34,250
0,660 690,1140 1140,2010 2310,2640 2640,3300
before,| {} but {sysfile -}.|
|但是， sysfile.h 。|

1537
00:48:36,960 --> 00:48:39,520
0,810 810,1260 1260,1980
{} {sys_write -}.|
sys_write 。|

1538
00:48:40,190 --> 00:48:41,240
0,240 240,480 480,570 570,780 780,1050
So here's the write system
这是 write 系统调用和它的参数，

1539
00:48:41,240 --> 00:48:44,090
0,630 660,1290 1290,1410 1410,2100 2280,2850
call, [] its arguments {},|
|

1540
00:48:44,150 --> 00:48:46,460
0,270 270,1110 1350,1770 1770,1950 1950,2310
file descriptor, number bytes {to,be}
文件描述符，要写入的字节数，

1541
00:48:46,460 --> 00:48:47,570
0,450 450,540 540,630 630,960 960,1110
written| and the address with
|还有地址，

1542
00:48:47,570 --> 00:48:48,620
0,420
the,|
|

1543
00:48:49,100 --> 00:48:50,600
0,120 120,420 420,630 630,840 840,1500
the address that it contains
包含 $ 的地址，

1544
00:48:50,600 --> 00:48:51,890
0,90 90,210 210,300 300,690 690,1290
you know the character $,|
|

1545
00:48:51,920 --> 00:48:53,680
0,270 270,420 420,780 780,1170
call them {filewrite -}.|
调用 filewrite 。|

1546
00:48:58,080 --> 00:48:59,910
0,420 420,840 840,1050 1050,1200 1200,1830
Let's quickly look at {filewrite
让我们快速看一下 filewrite 。

1547
00:48:59,940 --> 00:49:01,280
0,810
-}.|
|

1548
00:49:01,860 --> 00:49:03,210
0,300 300,420 420,630 630,1050 1050,1350
Okay, we're getting close to
好的，我们离我们想要讨论的东西越来越近了。

1549
00:49:03,210 --> 00:49:04,560
0,330 330,870 900,1170 1170,1290 1290,1350
actually {} things that we

1550
00:49:04,560 --> 00:49:06,080
0,150 150,210 210,450 450,930
want to talk about.|
|

1551
00:49:06,140 --> 00:49:08,090
0,810 870,960 960,1080 1080,1740 1770,1950
And you know here is
在这里， filewrite 查看文件描述符类型，

1552
00:49:08,090 --> 00:49:09,020
0,210 210,480 480,600 600,810 810,930
{filewrite -} it looks for

1553
00:49:09,020 --> 00:49:10,070
0,90 90,480 480,630 630,840 840,1050
the type of the file

1554
00:49:10,070 --> 00:49:11,630
0,480 480,720 720,960 960,1020 1020,1560
descriptor is,| it's a pipe
|如果是管道，调用管道的函数，

1555
00:49:11,630 --> 00:49:13,280
0,330 330,390 390,660 660,1260 1440,1650
called the pipe functions,| and
|如果是设备，不起作用，

1556
00:49:13,280 --> 00:49:15,650
0,90 90,270 270,1080 1260,1890 1890,2370
if its device {} which

1557
00:49:15,650 --> 00:49:17,390
0,150 150,420 420,630 630,1050 1350,1740
{you,know} [make not does],| then
|然后，它对那个设备调用 write 函数。

1558
00:49:17,390 --> 00:49:19,070
0,90 90,240 240,960 1230,1530 1530,1680
it will call {} the

1559
00:49:19,070 --> 00:49:20,360
0,270 270,660 660,750 750,930 930,1290
write function for that particular

1560
00:49:20,360 --> 00:49:21,420
0,660
device.|
|

1561
00:49:21,910 --> 00:49:23,530
0,420 420,720 750,960 960,1170 1170,1620
And so we know that
所以，这实际上会调用 console 中的 write 函数。

1562
00:49:23,560 --> 00:49:24,430
0,90 90,210 210,420 420,750 750,870
you know that actually is

1563
00:49:24,430 --> 00:49:27,820
0,150 150,390 900,1320 1320,1830 3120,3390
going to call the write

1564
00:49:27,820 --> 00:49:29,540
0,360 360,450 450,510 510,1200
function in the console.|
|

1565
00:49:30,330 --> 00:49:31,260
0,300 300,450 450,630 630,810 810,930
And so let's see what
让我们看看那里会发生什么。

1566
00:49:31,260 --> 00:49:32,580
0,240 240,540 570,750 750,960 960,1320
happens there.| So here's {consolewrite
|这里是 consolewrite ，

1567
00:49:32,580 --> 00:49:33,600
0,450
-},|
|

1568
00:49:33,840 --> 00:49:35,580
0,720 720,1050 1050,1410 1410,1590 1590,1740
{} grab lock, we don't
获取锁，我们现在不关心这个，

1569
00:49:35,580 --> 00:49:36,930
0,180 180,420 420,660 660,810 810,1350
care about that right now,|
|

1570
00:49:37,080 --> 00:49:39,120
0,750 750,990 990,1380 1380,1740 1770,2040
{} it copies in the
它使用 either_copyin 复制进一个字符，

1571
00:49:39,120 --> 00:49:41,040
0,300 300,930 960,1290 1290,1500 1500,1920
one character use {either_copyin -

1572
00:49:41,040 --> 00:49:41,860
0,300
-},|
|

1573
00:49:41,890 --> 00:49:43,270
0,480 480,690 690,990 990,1200 1200,1380
and {then -}, calls {uartputc
然后，调用 uartputc 。

1574
00:49:43,270 --> 00:49:44,620
0,240 240,810
- -}.|

1575
00:49:45,530 --> 00:49:47,270
0,540 570,1050 1050,1170 1170,1470 1470,1740
So that basically calls into
它调用进入 UART ，

1576
00:49:47,270 --> 00:49:49,040
0,360 630,900 900,1380 1410,1620 1620,1770
the {uart -},| and so
|你可以这样考虑，

1577
00:49:49,040 --> 00:49:49,940
0,120 120,210 210,360 360,600 600,900
you can think about {to,it},|
|

1578
00:49:49,940 --> 00:49:51,530
0,90 90,570 570,780 780,870 870,1590
the {console,is} being the driver,|
console 是驱动程序，|

1579
00:49:51,620 --> 00:49:53,270
0,630 630,900 900,1230 1230,1320 1320,1650
we're looking at the top
我们现在看的是驱动程序的顶端，

1580
00:49:53,270 --> 00:49:55,370
0,120 120,210 210,330 330,1110 1380,2100
end of the driver| and
|现在调用 uart.c 中的东西，

1581
00:49:55,370 --> 00:49:57,590
0,1050 1050,1260 1260,1320 1320,1590 1590,2220
now make some call {in,uart.c

1582
00:49:57,590 --> 00:49:59,750
0,180 180,690 960,1140 1140,1710 1710,2160
- -}| to actually a
|来打印一个字符。

1583
00:49:59,960 --> 00:50:01,180
0,240 240,300 300,780
print a character.|
|

1584
00:50:02,060 --> 00:50:04,280
0,480 480,990 1050,1590 1590,1890 1890,2220
And so here {uart.c -},
这是 uart.c ，这会有点有趣，

1585
00:50:04,310 --> 00:50:04,910
0,120 120,300 300,390 390,540 540,600
so this is going to

1586
00:50:04,910 --> 00:50:05,960
0,90 90,150 150,300 300,420 420,1050
be a little bit interesting,|
|

1587
00:50:06,290 --> 00:50:07,660
0,720

1588
00:50:07,780 --> 00:50:10,150
0,330 330,900 900,1260 1260,2130 2160,2370
{} basically the internally the
基本上，UART 内部保持一个缓冲区，

1589
00:50:10,150 --> 00:50:11,680
0,600 630,840 840,1050 1050,1110 1110,1530
uart {} keeps a buffer,|
|

1590
00:50:12,040 --> 00:50:13,660
0,630 630,810 810,960 960,1140 1140,1620
{} so let's go back
让我们回退一点。

1591
00:50:13,660 --> 00:50:14,500
0,210 210,330 330,360 360,540 540,840
back up a little bit.|
|

1592
00:50:15,080 --> 00:50:16,250
0,330 330,450 450,510 510,1050 1080,1170
{} At the top, in
在顶部，有一个用于传输的缓冲区，

1593
00:50:16,250 --> 00:50:17,570
0,240 240,480 480,720 720,1140 1140,1320
fact there's a buffer for

1594
00:50:17,570 --> 00:50:19,790
0,720 1050,1590 1590,1860 1860,2130 2130,2220
transmission| and buffer size is
|缓冲区大小是 32 个字符。

1595
00:50:19,790 --> 00:50:21,680
0,720 720,1410
32 characters.|
|

1596
00:50:21,770 --> 00:50:23,120
0,300 300,480 480,540 540,1170 1200,1350
And there's a pointer the
这里有一个指针，写指针和读指针，

1597
00:50:23,120 --> 00:50:24,080
0,240 240,540 540,630 630,720 720,960
write pointer and the read

1598
00:50:24,080 --> 00:50:27,050
0,270 270,510 990,1920 2010,2610 2610,2970
pointer| {} that being used
|用来将该字符放入循环缓冲区中，

1599
00:50:27,050 --> 00:50:29,240
0,480 630,1080 1080,1440 1590,2010 2010,2190
to put this character into

1600
00:50:29,240 --> 00:50:31,250
0,120 120,900 900,1380 1710,1980 1980,2010
a circular buffer,| talk a
|更详细地讨论一下这个，

1601
00:50:31,250 --> 00:50:32,030
0,210 210,330 330,540 540,660 660,780
little bit about that in

1602
00:50:32,030 --> 00:50:34,430
0,150 150,570 570,780 1140,1890 2070,2400
more detail,| but {} there's
|但是，有一个指向生产者的指针和一个指向消费者的指针。

1603
00:50:34,430 --> 00:50:36,590
0,120 120,780 1050,1320 1320,1590 1620,2160
a pointer for the producer

1604
00:50:36,590 --> 00:50:37,250
0,120 120,210 210,270 270,540 540,660
and as a pointer for

1605
00:50:37,250 --> 00:50:38,380
0,60 60,720
the consumer.|
|

1606
00:50:38,620 --> 00:50:39,760
0,360 360,420 420,570 570,1020 1020,1140
And in this case, you
在这种情况下， shell 是生产者，

1607
00:50:39,760 --> 00:50:41,500
0,90 90,600 1020,1560 1560,1650 1650,1740
know the shell, if you

1608
00:50:41,500 --> 00:50:43,990
0,210 210,360 360,750 780,1650 1710,2490
will, as the producer| and
|它检查，

1609
00:50:44,020 --> 00:50:45,850
0,660 660,1170 1170,1410 1410,1740 1740,1830
{} it actually checks,| the
|它做的第一件事是

1610
00:50:45,850 --> 00:50:46,690
0,240 240,360 360,420 420,750 750,840
first thing it does is|
|

1611
00:50:46,690 --> 00:50:47,980
0,210 210,510 510,750 750,900 900,1290
actually check whether this circular
检查这个循环缓冲区是否已满。

1612
00:50:47,980 --> 00:50:49,180
0,270 270,360 360,750
buffer is full.|
|

1613
00:50:49,370 --> 00:50:50,630
0,450 510,840 840,900 900,1110 1110,1260
So and the way the
检查循环缓冲区是否已满的方法，

1614
00:50:50,630 --> 00:50:51,710
0,240 240,330 330,420 420,750 750,1080
checks with the circular {buffer,is}

1615
00:50:51,710 --> 00:50:53,270
0,300 300,690 780,960 960,1260 1260,1560
full,| so it starts out
|它的初始状态是写指针和读指针都是零，

1616
00:50:53,270 --> 00:50:54,260
0,90 90,150 150,540 540,840 840,990
in the original state is

1617
00:50:54,260 --> 00:50:55,850
0,480 480,660 660,960 960,1410 1410,1590
both the write pointer and

1618
00:50:55,850 --> 00:50:57,350
0,210 210,600 600,690 690,1110 1110,1500
the {read,pointer} is zero, correct,|
|

1619
00:50:57,350 --> 00:50:58,910
0,330 330,690 690,870 870,960 960,1560
zero index into the buffer,|
缓冲区的零索引，|

1620
00:50:59,240 --> 00:51:00,320
0,180 180,270 270,780 780,900 900,1080
if the equal you know
如果它们相等，则缓冲器是空的，

1621
00:51:00,320 --> 00:51:03,710
0,180 180,1350 1590,2250 2640,3300 3300,3390
that there {} buffer is

1622
00:51:03,710 --> 00:51:05,420
0,540 720,1380 1380,1470 1470,1560 1560,1710
empty,| but if you add
|但是如果在写指针上加一，

1623
00:51:05,420 --> 00:51:06,410
0,240 240,330 330,420 420,660 660,990
one to the write pointer,|
|

1624
00:51:06,410 --> 00:51:07,100
0,180 180,240 240,510 510,600 600,690
it's the same as the
与接收指针相同，

1625
00:51:07,100 --> 00:51:08,690
0,360 360,900 930,1110 1110,1200 1200,1590
receive pointer,| so for example
|比如，如果你填入 0 1 2 3 4 5 6 7 8 9 到 31 ，

1626
00:51:08,690 --> 00:51:10,430
0,330 570,1140 1140,1290 1290,1530 1530,1740
if you you fill in

1627
00:51:10,430 --> 00:51:11,330
0,150 150,420 420,600 600,720 720,900
a zero one two three

1628
00:51:11,330 --> 00:51:12,170
0,150 150,360 360,510 510,750 750,840
four five six seven eight

1629
00:51:12,170 --> 00:51:13,640
0,330 330,540 540,990 1230,1350 1350,1470
{nine,to} thirty one| and then
|然后你要绕回来，

1630
00:51:13,640 --> 00:51:15,260
0,120 120,510 510,690 690,1350 1380,1620
you're about to {} wrap

1631
00:51:15,260 --> 00:51:17,330
0,510 780,1080 1080,1260 1260,1740 1860,2070
around,| {you,know} add one if
|加上一，它仍然等于接收索引或读索引，

1632
00:51:17,330 --> 00:51:20,000
0,480 480,480 480,2160 2190,2400 2400,2670
then {} and it's still

1633
00:51:20,000 --> 00:51:21,860
0,240 240,360 360,480 480,1110 1170,1860
equal to the receive index

1634
00:51:22,140 --> 00:51:22,980
0,150 150,210 210,540 540,750 750,840
or the {read,index}| that you
|你知道缓冲区已满。

1635
00:51:22,980 --> 00:51:23,640
0,150 150,270 270,330 330,570 570,660
know that the buffer is

1636
00:51:23,640 --> 00:51:24,500
0,330
full.|
|

1637
00:51:24,820 --> 00:51:26,140
0,180 180,300 300,480 480,810 810,1320
And so there's no point
所以，这一点上你不能写任何东西，

1638
00:51:26,170 --> 00:51:26,890
0,120 120,210 210,330 330,540 540,720
you know you can't write

1639
00:51:26,890 --> 00:51:28,600
0,360 360,450 450,600 600,990 1350,1710
anything at that point {},|
|

1640
00:51:28,600 --> 00:51:30,640
0,270 270,870 870,1290 1290,1530 1530,2040
because apparently UART still busy,|
因为很明显 UART 正忙，|

1641
00:51:30,640 --> 00:51:31,870
0,180 180,510 510,630 630,810 810,1230
{you,know} working its way through,|
以它的方式工作，|

1642
00:51:31,870 --> 00:51:34,630
0,1320 1440,1800 1800,2070 2070,2370 2370,2760
{} trying to send off
试着发送之前的 31 个或 30 个字符。

1643
00:51:34,630 --> 00:51:36,370
0,150 150,900 900,1020 1020,1110 1110,1740
the [] you know 31

1644
00:51:36,370 --> 00:51:38,300
0,510 510,660 660,900 900,1500
characters or 30 characters.|
|

1645
00:51:38,390 --> 00:51:39,890
0,150 150,300 300,840 840,1110 1110,1500
In this case, the buffer
在这种缓冲已满的情况下，

1646
00:51:39,890 --> 00:51:43,970
0,540 660,1500 1980,2610 2640,3960 3960,4080
full,| the shell basically were
|shell 会休眠，在旁边等待，

1647
00:51:43,970 --> 00:51:45,590
0,300 300,390 390,900 1230,1470 1470,1620
put to sleep and put

1648
00:51:45,590 --> 00:51:47,090
0,90 90,150 150,690 690,1290 1290,1500
on the side| and the
|内核将运行其他程序，

1649
00:51:47,090 --> 00:51:48,080
0,270 270,390 390,660 660,780 780,990
kernel will run some other

1650
00:51:48,080 --> 00:51:51,890
0,510 810,1200 1200,1920 1950,2700 3300,3810
program| {} until {} shell
|直到 shell 唤醒，已经准备好发送，

1651
00:51:51,890 --> 00:51:52,940
0,270 270,480 480,660 660,840 840,1050
woken up and it's actually

1652
00:51:52,940 --> 00:51:54,160
0,270 270,360 360,780
ready to send,|
|

1653
00:51:55,180 --> 00:51:56,170
0,270 270,510 510,600 600,750 750,990
or {the,uart -} just ready
或者 UART 准备好发送更多数据。

1654
00:51:56,170 --> 00:51:58,000
0,360 390,660 660,840 840,1260
to send more data.|
|

1655
00:51:58,090 --> 00:51:59,230
0,660 660,780 780,960 960,1020 1020,1140
{You,know}, of course in this
当然这种情况下不是这样的，

1656
00:51:59,230 --> 00:52:00,160
0,210 210,360 360,540 540,600 600,930
case it's not the case

1657
00:52:00,160 --> 00:52:01,300
0,180 180,390 390,780 780,840 840,1140
right,| because there's the first
|因为有几个字符正在打印，

1658
00:52:01,300 --> 00:52:02,410
0,210 210,660 660,780 780,900 900,1110
few characters that are being

1659
00:52:02,410 --> 00:52:04,060
0,390 810,1140 1140,1290 1290,1590 1590,1650
printed,| so there's space in
|所以缓冲里有空间，

1660
00:52:04,060 --> 00:52:05,830
0,60 60,600 840,1050 1050,1350 1350,1770
the buffer| and so basically
|所以驱动程序将一个字符放入缓冲区，

1661
00:52:05,830 --> 00:52:08,380
0,240 240,930 960,1500 1500,1980 2010,2550
the driver puts {} character

1662
00:52:08,380 --> 00:52:10,510
0,210 210,270 270,840 1230,1650 1650,2130
into the buffer,| {} updates
|更新写指针到下一个插槽，

1663
00:52:10,510 --> 00:52:11,710
0,270 270,570 570,840 840,960 960,1200
the write pointer to go

1664
00:52:11,710 --> 00:52:13,090
0,90 90,210 210,420 420,930 1080,1380
to the next slot| and
|然后调用 uartstart 。

1665
00:52:13,090 --> 00:52:14,620
0,150 150,330 330,510 510,1140
then calls {uartstart -}.|
|

1666
00:52:15,960 --> 00:52:17,550
0,390 390,690 690,960 960,1380 1380,1590
And basically {uartstart -} {is,nothing}
基本上 uartstart 不做别的事，

1667
00:52:17,550 --> 00:52:18,630
0,360 360,510 510,570 570,960 960,1080
else,| sort of kicking the
|通知设备，去帮我做点事吧。

1668
00:52:18,630 --> 00:52:20,100
0,570 570,660 660,900 900,1110 1110,1470
device and saying like hey

1669
00:52:20,100 --> 00:52:21,480
0,240 240,390 390,540 540,990 1140,1380
go do some work for

1670
00:52:21,480 --> 00:52:22,300
0,300
me.|
|

1671
00:52:23,620 --> 00:52:25,740
0,780 810,1560
And, um.|
还有，嗯。|

1672
00:52:25,800 --> 00:52:28,080
0,210 210,1020 1050,1710
And basically, {}
基本上，首先检查设备是否正忙，

1673
00:52:28,830 --> 00:52:31,260
0,300 300,600 600,1110 1140,1350 1350,2430
{} first checks if the

1674
00:52:31,710 --> 00:52:33,180
0,540 540,600 600,780 780,1170 1170,1470
device is still busy,| sending
|发送当前字符，

1675
00:52:33,180 --> 00:52:36,000
0,90 90,360 360,1050 1080,2160 2160,2820
the current character [] recently,|
|

1676
00:52:36,300 --> 00:52:38,160
0,570 570,1170 1200,1560 1560,1770 1770,1860
{} if {} if the
如果设备正忙，

1677
00:52:38,160 --> 00:52:39,630
0,390 390,690 720,1230 1230,1320 1320,1470
device is busy,| you know
|我们只要回去，可能会睡眠，

1678
00:52:39,630 --> 00:52:40,410
0,120 120,270 270,360 360,690 690,780
we just go back and

1679
00:52:40,410 --> 00:52:41,250
0,60 60,210 210,330 330,450 450,840
{} we'll go to sleep

1680
00:52:41,250 --> 00:52:42,320
0,600
probably,|
|

1681
00:52:42,320 --> 00:52:44,210
0,540 540,1020 1020,1110 1110,1500 1740,1890
{} {we'll,go} to sleep| and
我们会睡眠，|否则我们从缓冲区读取字符，

1682
00:52:44,210 --> 00:52:45,710
0,570 570,870 870,1020 1020,1080 1080,1500
otherwise we'll read the character

1683
00:52:45,710 --> 00:52:48,440
0,120 120,270 270,870 1110,1890 1890,2730
out the buffer| {} and
|并将其放入传输寄存器中，

1684
00:52:48,650 --> 00:52:50,320
0,240 240,330 330,510 510,1110
put it in the

1685
00:52:50,350 --> 00:52:52,300
0,570 570,1140 1290,1710 1710,1800 1800,1950
transmission register,| that we saw
|就像我们之前看到的。

1686
00:52:52,300 --> 00:52:53,400
0,570
earlier.|
|

1687
00:52:54,480 --> 00:52:56,670
0,300 300,450 450,780 1170,1740 1740,2190
And so the transmission register
所以传输寄存器就像之前这样，

1688
00:52:56,670 --> 00:52:58,710
0,300 300,480 480,630 630,1380 1500,2040
just like this before {},|
|

1689
00:52:58,710 --> 00:52:59,490
0,240 240,390 390,480 480,690 690,780
let's look at that for
稍后我们看一下。

1690
00:52:59,490 --> 00:53:01,420
0,30 30,540 990,1680
a second {}.|
|

1691
00:53:02,410 --> 00:53:04,450
0,150 150,300 300,810 810,1830 1860,2040
You know {WriteReg -} you
WriteReg 把指定的寄存器转换成 Reg 类型，

1692
00:53:04,450 --> 00:53:05,820
0,120 120,870
know cast

1693
00:53:05,990 --> 00:53:08,330
0,300 300,750 1140,1620 1620,2010 2010,2340
{} the particular register to

1694
00:53:08,330 --> 00:53:08,960
0,90 90,240 240,330 330,420 420,630
the one of {} Reg

1695
00:53:08,960 --> 00:53:10,460
0,480 480,570 570,930 930,1230 1230,1500
type,| and then writes the
|然后，将值写入其中。

1696
00:53:10,460 --> 00:53:11,860
0,330 330,600 600,840
value into it.|
|

1697
00:53:12,360 --> 00:53:13,890
0,450 450,570 570,840 870,1230 1230,1530
And you know {THR -}
传输保持寄存器 THR 是

1698
00:53:13,890 --> 00:53:15,510
0,90 90,450 450,690 690,1170 1170,1620
the transmitter holding register is|
|

1699
00:53:15,570 --> 00:53:16,950
0,270 270,810 810,990 990,1110 1110,1380
register zero which we saw
我们之前在文档中看到的寄存器 0 。

1700
00:53:16,950 --> 00:53:18,800
0,390 390,510 510,570 570,1290
before from the documentation.|
|

1701
00:53:20,390 --> 00:53:23,150
0,300 300,780 780,1440 1860,2010 2010,2760
Okay, so {}, so basically
好的，所以，你知道，

1702
00:53:23,150 --> 00:53:25,800
0,180 180,330 330,960 1290,2100
you know the {},|
|

1703
00:53:26,570 --> 00:53:27,800
0,270 270,570 570,720 720,930 930,1230
{} where am I {}
我从哪里开始。

1704
00:53:27,800 --> 00:53:28,920
0,570
start.|
|

1705
00:53:28,920 --> 00:53:30,510
0,660 720,840 840,990 990,1260 1260,1590
{} You should start basically
你应该首先从通知设备，

1706
00:53:30,510 --> 00:53:31,740
0,300 300,390 390,870 870,960 960,1230
kicks the device| and saying
|然后说，我有一个寄存器，

1707
00:53:31,740 --> 00:53:33,420
0,150 150,600 600,720 720,930 930,1680
like hey I gotta register,|
|

1708
00:53:33,420 --> 00:53:34,290
0,120 120,270 270,360 360,720 720,870
I got a byte for
我有一个字节可以发送。

1709
00:53:34,290 --> 00:53:36,180
0,240 240,750 750,1050 1050,1260 1260,1890
you available to {} {send,off}.|
|

1710
00:53:36,790 --> 00:53:39,850
0,780 1050,1290 1290,1650 1650,2310 2340,3060
And that's basically all {}
这就是所有的。

1711
00:53:39,880 --> 00:53:41,220
0,690
the.|
|

1712
00:53:42,430 --> 00:53:44,290
0,270 270,900 900,1350 1350,1650 1740,1860
And that basically the if
这就是， shell ，

1713
00:53:44,290 --> 00:53:45,370
0,120 120,330 330,420 420,930 960,1080
you will, the shell,| you
|系统调用 shell 所做的，

1714
00:53:45,370 --> 00:53:46,690
0,210 210,360 360,690 690,1110 1110,1320
know the system call, the

1715
00:53:47,140 --> 00:53:49,450
0,330 330,810 810,930 930,1380 1650,2310
shell call will do| and
|如果通知设备，会回到用户空间，

1716
00:53:49,450 --> 00:53:50,950
0,210 210,510 510,870 1050,1350 1350,1500
{} once actually kick the

1717
00:53:50,950 --> 00:53:52,570
0,780 780,960 960,1260 1260,1350 1350,1620
devices will return to user

1718
00:53:52,570 --> 00:53:53,560
0,390 390,510 510,570 570,870 870,990
space| and the shell can
|shell 可以继续运行，做它想做的任何事情，

1719
00:53:53,560 --> 00:53:54,760
0,150 150,510 510,720 720,840 840,1200
go on and do whatever

1720
00:53:54,760 --> 00:53:56,140
0,60 60,300 300,360 360,720 1080,1380
it wants to do| and
|shell 要做的下一件事就是调用 read 系统调用，

1721
00:53:56,140 --> 00:53:56,980
0,360 360,450 450,660 660,780 780,840
presumably the next thing the

1722
00:53:56,980 --> 00:53:57,790
0,240 240,360 360,510 510,600 600,810
shell will do is called

1723
00:53:57,790 --> 00:53:58,720
0,90 90,270 270,570 570,810 810,930
the read system call| to
|真正读取来自键盘的输入。

1724
00:53:58,720 --> 00:53:59,800
0,270 270,540 540,900 900,1020 1020,1080
actually read input from the

1725
00:53:59,800 --> 00:54:00,740
0,540
keyboard.|
|

1726
00:54:00,740 --> 00:54:01,730
0,330 330,480 480,570 570,870 870,990
{} So the shell will
所以 shell 将返回用户空间，

1727
00:54:01,730 --> 00:54:03,050
0,300 300,360 360,630 630,1020 1020,1320
return to user space,| using
|使用我们看过的机制，比如 userret ，

1728
00:54:03,050 --> 00:54:04,880
0,150 150,630 630,1080 1080,1260 1260,1830
the standard mechanism, that we

1729
00:54:05,150 --> 00:54:06,290
0,150 150,360 360,750 750,900 900,1140
have seen before, like {userret

1730
00:54:06,290 --> 00:54:07,640
0,330 660,870 870,990 990,1170 1170,1350
-},| it just goes off
|它继续，并做着自己的事，

1731
00:54:07,640 --> 00:54:08,810
0,90 90,240 240,420 420,810 990,1170
and does its thing| and
|同时，那个设备没有被通知，

1732
00:54:08,810 --> 00:54:10,370
0,90 90,150 150,1080 1080,1200 1200,1560
in the meantime, the device

1733
00:54:10,370 --> 00:54:11,450
0,120 120,270 270,450 450,630 630,1080
has not got any kick|
|

1734
00:54:11,660 --> 00:54:13,040
0,300 300,690 690,990 990,1230 1230,1380
to actually, {} send some
来真正发送一些字节。

1735
00:54:13,040 --> 00:54:14,120
0,300 300,660
bytes off.|
|

1736
00:54:14,490 --> 00:54:15,820
0,810

1737
00:54:16,240 --> 00:54:18,540
0,480 480,1020 1080,1710
And so {}.|
所以。|

1738
00:54:19,400 --> 00:54:20,840
0,150 150,270 270,450 450,930 1110,1440
So, at some point we're
所以，在某个时候我们会被中断，

1739
00:54:20,840 --> 00:54:22,260
0,120 120,180 180,300 300,840
going to get interrupted,|
|

1740
00:54:22,720 --> 00:54:23,980
0,270 270,720 720,810 810,960 960,1260
{} hopefully you know because
希望，因为我们进入产生中断的硬件，

1741
00:54:23,980 --> 00:54:25,990
0,120 120,390 390,930 930,1500 1530,2010
we broke into the hardware

1742
00:54:25,990 --> 00:54:27,790
0,90 90,270 270,630 630,1140 1380,1800
to actually generate interrupts,| let's
|我们往回一点，

1743
00:54:27,790 --> 00:54:28,720
0,120 120,150 150,330 330,450 450,930
go a little bit back|

1744
00:54:28,720 --> 00:54:29,440
0,150 150,360 360,390 390,570 570,720
and talk a little bit
讨论一下，当中断发生时发生了什么。

1745
00:54:29,440 --> 00:54:31,300
0,420 420,660 660,1290 1410,1770 1770,1860
about what happens when the

1746
00:54:31,300 --> 00:54:32,600
0,360 360,900
interrupt happens.|
|

1747
00:54:37,130 --> 00:54:39,380
0,270 270,990 1080,1710
Okay, so {},
好的，那么硬件做了什么。

1748
00:54:40,020 --> 00:54:41,640
0,420 690,1050 1050,1170 1170,1260 1260,1620
so what does the hardware

1749
00:54:41,640 --> 00:54:42,900
0,630
do.|
|

1750
00:54:44,320 --> 00:54:45,310
0,180 180,330 330,690 690,930 930,990
In this particular case, the
在这种情况下， RISC-V 实际发生中断，

1751
00:54:45,310 --> 00:54:46,620
0,210 210,810
{RISC-V -},

1752
00:54:46,740 --> 00:54:47,850
0,210 210,690 690,840 840,1020 1020,1110
{} do {} what {}

1753
00:54:47,850 --> 00:54:49,740
0,450 450,900 900,1290 1290,1470 1470,1890
interrupt actually happens,| so we
|所以，我们设置 SSTATUS 寄存器中的中断启用位，

1754
00:54:49,740 --> 00:54:51,390
0,240 240,480 480,900 900,1560 1560,1650
set this interrupt enable {}

1755
00:54:51,390 --> 00:54:52,530
0,420 420,600 600,690 690,1050 1050,1140
bit in the {SSTATUS -}

1756
00:54:52,530 --> 00:54:54,480
0,630 750,1050 1050,1350 1380,1740 1740,1950
register,| so the process can
|所以，这个进程可以被中断，

1757
00:54:54,480 --> 00:54:56,520
0,90 90,720 960,1470 1470,1800 1800,2040
be interrupted,| let's say the
|比如，键盘发起中断到 PLIC ，

1758
00:54:56,520 --> 00:54:58,650
0,720 720,1140 1140,1260 1260,1650 1650,2130
keyboard raises the interrupt line

1759
00:54:59,040 --> 00:55:00,600
0,270 270,390 390,480 480,1020 1200,1560
goes through the PLIC,| PLIC
|PLIC 将中断路由到特定的内核，

1760
00:55:00,630 --> 00:55:02,730
0,420 420,510 510,930 930,1230 1230,2100
routes the interrupt to {}

1761
00:55:02,760 --> 00:55:04,650
0,330 330,900 1140,1260 1260,1440 1440,1890
particular core| and that core
|那个核心设置了 SIE 位，

1762
00:55:04,650 --> 00:55:07,290
0,120 120,300 300,990 1200,1890 1890,2640
you know, {} has the

1763
00:55:07,560 --> 00:55:09,260
0,420 420,720 720,900 900,1350
{SIE -} bit set,|
|

1764
00:55:09,810 --> 00:55:11,160
0,420 450,570 570,840 840,1200 1200,1350
so {interrupt -} enable bit
所以，设置中断启用位，

1765
00:55:11,160 --> 00:55:12,080
0,360
set,|
|

1766
00:55:13,260 --> 00:55:15,990
0,150 150,1110 1140,1950 1950,2400 2520,2730
the supervisor {interrupt,enable,bit} set,| so
设置管理者中断启用位，|所以，如果设置了该位，

1767
00:55:15,990 --> 00:55:17,160
0,210 210,330 330,540 540,630 630,1170
if the bit is set,|
|

1768
00:55:17,750 --> 00:55:19,340
0,150 150,390 390,600 600,1020
the following things happen.|
会发生以下情况。|

1769
00:55:19,370 --> 00:55:20,300
0,240 240,360 360,540 540,660 660,930
And this will look very
这个跟我们之前看到的很像，

1770
00:55:20,300 --> 00:55:21,800
0,540 570,900 1020,1230 1230,1350 1350,1500
similar to what we've seen

1771
00:55:21,800 --> 00:55:23,600
0,600 630,1050 1050,1140 1140,1350 1350,1800
before,| but the first thing
|硬件要做的第一件事就是清除 SIE 位。

1772
00:55:23,810 --> 00:55:25,880
0,390 390,510 510,1110 1110,1260 1260,2070
{} the {hardware,does} is clear

1773
00:55:26,460 --> 00:55:28,220
0,210 210,660 660,660 660,1170
the {SIE -} bit.|
|

1774
00:55:29,330 --> 00:55:30,770
0,210 210,690 690,810 810,1080 1080,1440
This stops {you,know} any further
这会阻止任何进来的中断，

1775
00:55:30,770 --> 00:55:32,570
0,360 360,600 600,960 1350,1680 1680,1800
interrupts coming in {},| so
|这样我们就可以先处理这些中断，

1776
00:55:32,570 --> 00:55:33,350
0,120 120,210 210,360 360,540 540,780
that we can just deal

1777
00:55:33,350 --> 00:55:34,460
0,120 120,270 270,630 630,990 990,1110
with these interrupt first| and
|如果我们想要更多的中断，

1778
00:55:34,460 --> 00:55:35,240
0,210 210,330 330,420 420,600 600,780
then if we want more

1779
00:55:35,240 --> 00:55:36,200
0,450 450,540 540,630 630,780 780,960
interrupts,| you know we have
|我们必须重新启用那个位，

1780
00:55:36,200 --> 00:55:37,730
0,330 360,570 570,960 1080,1320 1320,1530
to {re-enable -} that bit,|
|

1781
00:55:37,730 --> 00:55:38,620
0,120 120,270
you know
你知道这些阻止更多的中断，

1782
00:55:38,620 --> 00:55:40,000
0,90 90,300 300,390 390,930 1110,1380
{} these to stops further

1783
00:55:40,000 --> 00:55:41,710
0,480 480,570 570,900 900,1290 1290,1710
interrupts| were basically interrupt interrupt
|中断，中断，中断，

1784
00:55:41,710 --> 00:55:42,920
0,630
interrupt,|
|

1785
00:55:43,440 --> 00:55:45,900
0,570 1140,1590 1590,1740 1740,1980 1980,2460
{} then it sets the
然后，设置异常程序计数器 SEPC 为当前 PC 。

1786
00:55:46,730 --> 00:55:49,850
0,240 240,1230 1260,1860 2160,2670 2700,3120
{SEPC -} to the exception

1787
00:55:49,850 --> 00:55:51,200
0,300 300,600 600,900 900,990 990,1350
program counter to the current

1788
00:55:51,200 --> 00:55:52,500
0,600
PC.|
|

1789
00:55:52,840 --> 00:55:53,980
0,270 270,660 660,780 780,900 900,1140
For example, if we were
比如，如果中断，

1790
00:55:53,980 --> 00:55:55,180
0,510 510,750 750,930 930,1140 1140,1200
interrupted {},| let's say the
|比如 shell 返回用户空间，

1791
00:55:55,180 --> 00:55:56,710
0,360 360,660 660,750 750,1050 1050,1530
shell return to user space|
|

1792
00:55:56,710 --> 00:55:58,210
0,180 180,540 540,810 810,1080 1080,1500
what's happening {run,in} user space
在用户空间运行时发生中断，

1793
00:55:58,210 --> 00:55:59,560
0,120 120,570 570,780 780,1080 1080,1350
and interrupt comes in,| because
|因为发送了一个字符，

1794
00:55:59,560 --> 00:56:00,460
0,60 60,210 210,390 390,810 810,900
of that one character is

1795
00:56:00,460 --> 00:56:02,320
0,390 690,1050 1050,1110 1110,1650 1650,1860
sent,| then the {program,counter} can
|然后，程序计数器收到，在用户空间中的程序计数器，

1796
00:56:02,320 --> 00:56:03,580
0,60 60,450 450,570 570,960 960,1260
{receive -} is whatever program

1797
00:56:03,580 --> 00:56:04,960
0,300 300,450 450,570 570,810 810,1380
counter was in user space,|
|

1798
00:56:05,410 --> 00:56:07,620
0,540 540,780 780,1140 1140,1590
{} it saves the
它保存当前模式。

1799
00:56:07,800 --> 00:56:10,860
0,570 1230,1680 1680,2010 2040,2310 2310,3060
{} save the current mode.|
|

1800
00:56:12,880 --> 00:56:13,840
0,240 240,360 360,510 510,750 750,960
So in this case would
比如，在这种情况下，

1801
00:56:13,840 --> 00:56:15,520
0,330 330,540 540,960 960,1110 1110,1680
be an example would be|
|

1802
00:56:15,520 --> 00:56:16,600
0,90 90,240 240,540 540,690 690,1080
we would save that {xv6
我们将保存 xv6 的用户模式，

1803
00:56:16,600 --> 00:56:18,820
0,510 510,1020 1020,1380 1380,1530 1530,2220
-} supervisor mode, the user

1804
00:56:18,820 --> 00:56:20,140
0,450 600,900 900,1020 1020,1230 1230,1320
mode,| then it's sets the
|然后，它设置为管理者模式。

1805
00:56:20,140 --> 00:56:22,460
0,450 810,1770
mode supervisor.|
|

1806
00:56:26,360 --> 00:56:28,040
0,690 690,960 960,1350 1350,1590 1590,1680
And, {} basically sets the
将程序计数器设置为 stvec 的值，

1807
00:56:28,040 --> 00:56:30,710
0,330 330,960 1290,1860 1860,2220 2220,2670
program counter to {stvec -},|
|

1808
00:56:31,300 --> 00:56:32,500
0,330 330,720 720,810 810,930 930,1200
whatever value is in {stvec
不管 stvec 的值是什么，

1809
00:56:32,500 --> 00:56:33,700
0,390 570,840 840,960 960,1080 1080,1200
-}, right,| then it's going
|然后，继续 usertrap ，或 uservec ，或 kernelvec ，

1810
00:56:33,700 --> 00:56:35,800
0,60 60,150 150,690 690,1770 1830,2100
to be either {} {usertrap

1811
00:56:35,800 --> 00:56:36,880
0,570
-}

1812
00:56:37,090 --> 00:56:38,170
0,270 270,480 480,510 510,990 990,1080
or {uservec - -} or

1813
00:56:38,170 --> 00:56:39,520
0,330 330,720
{kernelvec -},|
|

1814
00:56:39,670 --> 00:56:41,080
0,150 150,510 510,870 870,1020 1020,1410
{} depending whether the interrupt
取决于中断发生在什么地方，

1815
00:56:41,080 --> 00:56:42,610
0,450 450,570 570,630 630,1200 1230,1530
happens,| you know whether we're
|我们是在内核空间还是在用户模式，

1816
00:56:42,610 --> 00:56:43,690
0,60 60,270 270,540 540,870 870,1080
in [] kernel space or

1817
00:56:43,690 --> 00:56:44,650
0,330 330,540 540,690 690,810 810,960
user mode,| but in our
|在我们的例子中，shell 可能会返回用户空间。

1818
00:56:44,650 --> 00:56:46,600
0,480 480,750 750,1290 1320,1680 1680,1950
example, where maybe shell return

1819
00:56:46,600 --> 00:56:47,980
0,90 90,360 360,840
to user space,|
|

1820
00:56:47,980 --> 00:56:49,450
0,510 510,720 720,930 930,1260 1260,1470
{} {you,know} {stvec -} will
stvec 会包含用户[]地址，

1821
00:56:49,450 --> 00:56:53,260
0,450 450,1260 1620,2400 2670,3150 3150,3810
contain the user [] address|
|

1822
00:56:53,290 --> 00:56:55,750
0,450 450,870 870,1320 1590,2040 2040,2460
and basically the hart will
核心将恢复内核，

1823
00:56:55,780 --> 00:56:58,270
0,540 540,600 600,1290 1560,2310 2310,2490
resume the kernel,| {} at
|到位于 stvec 中的指令，

1824
00:56:58,270 --> 00:57:00,550
0,90 90,750 1140,1890 1890,2160 2160,2280
the instruction {} that is

1825
00:57:00,550 --> 00:57:02,660
0,420 420,690 690,1080 1110,1650
located {stvec -}| and
|我们还记得上一节课，

1826
00:57:02,660 --> 00:57:03,620
0,120 120,240 240,570 570,690 690,960
{you,know} we remember from previous

1827
00:57:03,620 --> 00:57:05,000
0,480 480,540 540,600 600,1050 1050,1380
lecture,| you know basically {stvec
|stvec 继续并调用 usertrap 。

1828
00:57:05,000 --> 00:57:07,880
0,510 510,750 750,1260 1260,1800 2130,2880
-} goes off and {}

1829
00:57:07,910 --> 00:57:09,380
0,270 270,480 480,540 540,990
calls {usertrap - -}.|
|

1830
00:57:09,900 --> 00:57:10,920
0,420 420,570 570,630 630,780 780,1020
Okay, so in the end,
好的，最后我们会在 usertrap 中。

1831
00:57:10,920 --> 00:57:11,790
0,120 120,510 510,630 630,780 780,870
we'll basically end up in

1832
00:57:11,790 --> 00:57:13,200
0,270 270,840
{usertrap -}.|
|

1833
00:57:15,320 --> 00:57:16,190
0,150 150,300 300,600 600,690 690,870
And that's where we sort
这就是我们讲的故事，

1834
00:57:16,190 --> 00:57:16,970
0,60 60,210 210,330 330,390 390,780
of pick up the [story],|
|

1835
00:57:16,970 --> 00:57:18,110
0,270 270,570 570,840 840,990 990,1140
because like I don't really
我不想谈论太多关于保存和恢复的事情，

1836
00:57:18,110 --> 00:57:18,860
0,150 150,210 210,450 450,570 570,750
want to talk too much

1837
00:57:18,860 --> 00:57:20,660
0,240 240,630 810,1230 1230,1320 1320,1800
about the saving and restoring

1838
00:57:20,660 --> 00:57:22,580
0,450 450,840 1110,1440 1440,1800 1800,1920
anymore,| because {} one we
|因为，第一我们在之前的课中详细解释过，

1839
00:57:22,580 --> 00:57:23,720
0,330 330,420 420,510 510,1050 1050,1140
explained it in detail in

1840
00:57:23,720 --> 00:57:24,800
0,120 120,360 360,720 720,960 960,1080
the previous lecture,| two, you
|第二，你已经看见过，在之前的的 traps 实验中，

1841
00:57:24,800 --> 00:57:26,060
0,450 450,720 720,840 840,930 930,1260
already played with and also

1842
00:57:26,060 --> 00:57:28,970
0,660 1050,1380 1380,1710 1710,2190 2220,2910
in this last traps []

1843
00:57:29,000 --> 00:57:30,770
0,720 750,900 900,1050 1050,1560 1590,1770
lab,| so you know you
|所以，你很清楚发生了什么。

1844
00:57:30,770 --> 00:57:31,910
0,270 270,570 570,690 690,900 900,1140
know exactly what's going on.|
|

1845
00:57:36,860 --> 00:57:38,260
0,180 180,690
And questions?|
有什么问题呢？|

1846
00:57:43,150 --> 00:57:45,500
0,330 330,840 1170,1800
Okay, so {}.|
好的，那么。|

1847
00:57:46,410 --> 00:57:47,370
0,150 150,480 480,720 720,780 780,960
So here {we,back} in {usertrap
所以，这里我们回到 usertrap ，

1848
00:57:47,370 --> 00:57:48,990
0,60 60,600 750,930 930,1290 1290,1620
- -},| you know function
|它是你在 traps 实验里详细研究过的函数。

1849
00:57:48,990 --> 00:57:50,130
0,180 180,360 360,480 480,960 960,1140
you've looked in detail at

1850
00:57:50,130 --> 00:57:51,540
0,150 150,330 330,750 750,900 900,1410
in the traps {} lab.|
|

1851
00:57:51,720 --> 00:57:55,140
0,870 1170,2070 2070,2430 2430,2820 2850,3420
And {you,know} {we,dealt} with {a,case,of}
我们处理了一个系统调用的案例。

1852
00:57:55,140 --> 00:57:56,520
0,300 300,990
system calls.|
|

1853
00:57:56,520 --> 00:57:58,830
0,960 960,1650 1650,2010 2010,2160 2160,2310
{} And what we're gonna
我们要做的，我们要做的一件事是，

1854
00:57:58,830 --> 00:58:00,210
0,150 150,270 270,930 1050,1200 1200,1380
do, is basically the only

1855
00:58:00,210 --> 00:58:00,810
0,90 90,240 240,360 360,480 480,600
thing we're gonna do is|
|

1856
00:58:00,810 --> 00:58:02,140
0,120 120,210 210,360 360,900
look at this case,
看看这个例子，设备中断。

1857
00:58:02,590 --> 00:58:04,150
0,300 300,540 540,690 690,1200 1230,1560
{} which is the device

1858
00:58:04,150 --> 00:58:05,200
0,540
interrupt.|
|

1859
00:58:05,260 --> 00:58:07,570
0,210 210,870 990,1830 2010,2190 2190,2310
Okay, so {} so we're
好的，所以我们要。

1860
00:58:07,570 --> 00:58:08,740
0,630
gonna.|
|

1861
00:58:09,150 --> 00:58:11,190
0,300 300,300 300,540 540,660 660,2040
That's a little bit lower
这在文件的稍低一点的地方。

1862
00:58:11,190 --> 00:58:12,620
0,210 210,300 300,390 390,930
here in the file.|
|

1863
00:58:16,140 --> 00:58:17,790
0,150 150,450 450,600 600,990 990,1650
So here's the device's interrupt|
这是设备的中断，|

1864
00:58:17,820 --> 00:58:20,250
0,960 1200,1380 1380,1860 1860,2040 2040,2430
{} and it looks basically
它查看 scause 寄存器，

1865
00:58:20,250 --> 00:58:22,620
0,120 120,330 330,930 960,1860
the {scause -} {}

1866
00:58:22,620 --> 00:58:24,750
0,660 660,1290 1320,1830 1830,1950 1950,2130
register| and sees if this
|查看这是否是外部中断，

1867
00:58:24,750 --> 00:58:26,730
0,120 120,210 210,600 600,1140 1470,1980
is an external interrupt,| and
|如果是外部中断，

1868
00:58:26,760 --> 00:58:28,080
0,150 150,240 240,360 360,810 810,1320
if it's an external interrupt,|
|

1869
00:58:28,350 --> 00:58:29,430
0,210 210,480 480,540 540,960 960,1080
that calls a function the
它调用函数 plic_claim ，

1870
00:58:29,430 --> 00:58:30,840
0,330 330,900
{plic_claim -},|
|

1871
00:58:30,960 --> 00:58:32,850
0,420 420,570 570,1200 1200,1680 1680,1890
{} to basically claim that
声称那个特定的中断。

1872
00:58:32,850 --> 00:58:34,950
0,780 840,1200 1200,1440 1440,1740 1950,2100
particular claim {interrupt -}.| So
|让我们回到 plic ，

1873
00:58:34,950 --> 00:58:36,180
0,150 150,300 300,570 570,780 780,1230
let's go back to plic,|
|

1874
00:58:39,080 --> 00:58:40,520
0,330 330,510 510,660 660,810 810,1440
and look at the plic_claim|
查看 plic_claim ，|

1875
00:58:41,000 --> 00:58:42,020
0,240 240,510 510,660 660,720 720,1020
and basically what it boils
归结起来就是，这个，

1876
00:58:42,020 --> 00:58:44,150
0,270 270,450 450,780 780,1290 1320,2130
down to is that the,

1877
00:58:44,240 --> 00:58:46,730
0,300 480,1140 1290,1890 1950,2160 2160,2490
in the,| {} this particular
|特定的 CPU 会告诉 PLIC ，

1878
00:58:46,730 --> 00:58:48,200
0,480 480,630 630,960 960,1050 1050,1470
CPU will tell the plic,|
|

1879
00:58:48,260 --> 00:58:50,090
0,540 540,750 750,1410 1410,1530 1530,1830
hey I'm claiming you know
嘿，我在请求说 CPU 0 或 CPU 1 ，

1880
00:58:50,090 --> 00:58:51,620
0,480 480,900 900,1290 1290,1380 1380,1530
it's CPU zero or {CPU

1881
00:58:51,620 --> 00:58:53,030
0,150 150,630 690,900 900,1110 1110,1410
-} one,| it will tell
|它会告诉 PLIC CPU 1 正在请求这个特定的中断，

1882
00:58:53,030 --> 00:58:55,460
0,330 330,1200 1200,1410 1410,1800 1800,2430
the plic that CPU one

1883
00:58:55,700 --> 00:58:58,160
0,210 210,720 720,900 900,1800 1800,2460
is claiming this particular interrupt|
|

1884
00:58:58,160 --> 00:59:00,350
0,660 720,1020 1020,1380 1380,1920 1920,2190
and once claim interrupt and
一旦收到中断请求， PLIC 返回它得到的中断，

1885
00:59:00,350 --> 00:59:01,670
0,330 330,690 690,870 870,1260 1260,1320
plic returns which interrupts it

1886
00:59:01,670 --> 00:59:02,420
0,450
gets,|
|

1887
00:59:02,640 --> 00:59:03,960
0,270 270,450 450,600 600,1080 1110,1320
{} {irq - -} for
实际传入的中断的 irq ，

1888
00:59:03,960 --> 00:59:05,100
0,120 120,510 510,660 660,900 900,1140
the interrupt that actually came

1889
00:59:05,100 --> 00:59:05,850
0,240 240,450 450,540 540,630 630,750
in| and so in this
|在这种情况下，这是一个中断 UART0_IRQ 10 。

1890
00:59:05,850 --> 00:59:07,350
0,270 270,420 420,570 570,900 900,1500
case that will be an

1891
00:59:07,470 --> 00:59:09,000
0,570 570,840 840,1140 1140,1410 1410,1530
interrupt {UART0_IRQ - - -

1892
00:59:09,000 --> 00:59:10,280
0,360 360,750
-} ten.|
|

1893
00:59:10,280 --> 00:59:11,990
0,180 180,900 900,1170 1170,1290 1290,1710
So {plic_claim -} will basically
所以 plic_claim 会返回 10 。

1894
00:59:11,990 --> 00:59:13,420
0,360 360,840
return ten.|
|

1895
00:59:13,660 --> 00:59:15,130
0,750 750,960 960,1140 1140,1380 1380,1470
{} And then here in
然后在这段代码中，

1896
00:59:15,130 --> 00:59:17,020
0,120 120,690 930,1200 1200,1800 1800,1890
this code,| {you,know} look you
|嘿，这是中断 10 ，

1897
00:59:17,020 --> 00:59:18,700
0,150 150,540 540,660 660,930 930,1680
say hey is this a

1898
00:59:18,700 --> 00:59:20,560
0,480 480,990 990,1380 1380,1680 1680,1860
{interrupt,ten},| if interrupt ten that
|如果是中断 10 一定是 UART 中断，

1899
00:59:20,560 --> 00:59:21,850
0,270 270,360 360,480 480,780 780,1290
must be a uart interrupt|
|

1900
00:59:22,150 --> 00:59:23,980
0,510 510,630 630,990 990,1350 1350,1830
and we basically called {uartintr
然后我们调用 uartintr 函数。

1901
00:59:24,010 --> 00:59:26,140
0,660 780,1620
-} function.|
|

1902
00:59:26,370 --> 00:59:28,950
0,1080 1110,1410 1410,1470 1470,1830 1830,2580
And {uartintr - -} function,|
而 uartintr 函数，|

1903
00:59:29,340 --> 00:59:30,680
0,780

1904
00:59:31,690 --> 00:59:33,730
0,1020 1020,1320 1320,1710 1710,1950 1950,2040
runs and basically gets the
从 UART 把字符拿出来，

1905
00:59:33,730 --> 00:59:35,410
0,540 540,1110 1140,1260 1260,1440 1440,1680
character off you know the

1906
00:59:35,410 --> 00:59:37,180
0,600 840,1200 1200,1440 1440,1560 1560,1770
uart| and {the,way} it gets
|它从 uart 获取字符的方式是，

1907
00:59:37,180 --> 00:59:38,230
0,90 90,420 420,510 510,690 690,1050
the character of {uart -}

1908
00:59:38,230 --> 00:59:40,690
0,120 120,600 600,870 870,1470 1830,2460
is| basically looks in {}
|在第一个寄存器中查找，接收寄存器，

1909
00:59:40,720 --> 00:59:43,360
0,330 330,960 990,1320 1530,1980 1980,2640
first register, the receive register|

1910
00:59:43,660 --> 00:59:45,490
0,900 930,1230 1230,1290 1290,1710 1710,1830
and gets the character out
从那里拿出字符。

1911
00:59:45,490 --> 00:59:46,280
0,90 90,360
of there.|
|

1912
00:59:47,240 --> 00:59:49,490
0,810 870,1380 1380,1680 1680,1800 1800,2250
And, {} that is an
这是一个整数，然后它调用 consoleintr ，

1913
00:59:49,490 --> 00:59:51,350
0,630 630,750 750,1200 1200,1290 1290,1860
integer and then it calls

1914
00:59:51,380 --> 00:59:53,120
0,300 300,660 660,1230
{} {consoleintr -},|
|

1915
00:59:53,120 --> 00:59:54,920
0,870 1200,1440 1440,1560 1560,1740 1740,1800
to do the rest of
来做剩下的工作。

1916
00:59:54,920 --> 00:59:55,860
0,90 90,420
the work.|
|

1917
00:59:58,510 --> 00:59:59,660
0,690
Okay?|
好的?|

1918
01:00:01,570 --> 01:00:03,460
0,390 390,1050 1080,1200 1200,1560 1560,1890
Actually sorry, I just did
不好意思，我说错了，

1919
01:00:03,460 --> 01:00:04,510
0,90 90,300 300,540 540,900 900,1050
the wrong thing,| we were
|我们在谈论传输。

1920
01:00:04,510 --> 01:00:07,640
0,270 270,420 420,1110 1590,2550
talking about transmission {}.|
|

1921
01:00:10,940 --> 01:00:12,260
0,330 540,930 930,1140 1140,1230 1230,1320
{} So if there was
所以，如果在读取端有一个字符，

1922
01:00:12,260 --> 01:00:14,060
0,60 60,780 1080,1470 1470,1710 1710,1800
a character {} on the

1923
01:00:14,060 --> 01:00:16,400
0,270 270,900 930,1440 1440,2100 2100,2340
read side| and then we'll
|然后我们会调用 consoleintr ，

1924
01:00:16,400 --> 01:00:18,170
0,270 270,810 810,930 930,1170 1500,1770
call {consoleintr -} { -},|
|

1925
01:00:18,170 --> 01:00:19,130
0,150 150,270 270,390 390,510 510,960
but there is no character
但是在读取端没有字符，

1926
01:00:19,130 --> 01:00:20,180
0,300 300,480 480,570 570,780 780,1050
correct, on the read side,|
|

1927
01:00:20,180 --> 01:00:21,590
0,450 450,750 750,930 930,1140 1140,1410
because we haven't read any,
因为我们没有读取，键盘还没有做任何事情，

1928
01:00:21,590 --> 01:00:23,270
0,390 390,840 840,1050 1050,1380 1380,1680
keyboard hasn't done anything yet,|
|

1929
01:00:23,480 --> 01:00:25,370
0,450 450,720 720,1200 1200,1320 1320,1890
we're just transmitting a character,|
我们只是在传输一个字符，|

1930
01:00:25,640 --> 01:00:26,780
0,180 180,600 690,900 900,960 960,1140
{} so {this,like - -}
那么这个会返回 -1 ，

1931
01:00:26,780 --> 01:00:29,000
0,330 330,630 630,1110 1320,1620 1620,2220
return minus one fall through|
|

1932
01:00:29,150 --> 01:00:30,440
0,210 210,420 420,1020 1020,1080 1080,1290
and then basically the only
然后唯一能做的就是，

1933
01:00:30,440 --> 01:00:31,340
0,90 90,180 180,330 330,720 750,900
thing that will do| is
|将调用 uartstart ，

1934
01:00:31,340 --> 01:00:32,930
0,330 330,720 720,900 900,1170 1170,1590
called {} it will {}

1935
01:00:34,700 --> 01:00:35,960
0,240 240,420 420,480 480,750 750,1260
{} call {uartstart - -}|
|

1936
01:00:36,020 --> 01:00:37,250
0,270 270,390 390,690 690,930 930,1230
{} to basically send any
发送在缓冲器中的任何其他字符，

1937
01:00:37,400 --> 01:00:38,990
0,270 270,810 810,1200 1200,1350 1350,1590
any other characters that might

1938
01:00:38,990 --> 01:00:40,430
0,150 150,240 240,300 300,810 840,1440
be in the buffer,| the
|可能是 shell 放在这里的，

1939
01:00:40,430 --> 01:00:41,570
0,330 360,750 750,840 840,1020 1020,1140
{} shell, it might be

1940
01:00:41,570 --> 01:00:43,460
0,240 240,390 390,840 1140,1530 1530,1890
stuck in there| and resume
|有另一个字符的时候恢复，

1941
01:00:43,460 --> 01:00:44,600
0,210 210,420 420,840 840,930 930,1140
there's another character in there,|
|

1942
01:00:44,600 --> 01:00:45,680
0,240 240,510 510,600 600,960 960,1080
because after the $ is
因为 $ 之后是空格，

1943
01:00:45,680 --> 01:00:48,470
0,90 90,780 1080,2010 2460,2580 2580,2790
the space| and the write
|并且 write 系统调用可能，

1944
01:00:48,470 --> 01:00:50,120
0,240 240,540 540,870 1170,1500 1500,1650
system call might,| write this
|写空格可能跟设备发送同时发生，

1945
01:00:50,120 --> 01:00:52,130
0,360 360,570 570,660 660,1500 1530,2010
space might have happened concurrently

1946
01:00:52,130 --> 01:00:53,270
0,210 210,330 330,750 750,870 870,1140
while the device was sending

1947
01:00:53,270 --> 01:00:54,710
0,360 690,870 870,990 990,1320 1320,1440
off| and so when we
|所以，当传输中断完成时，

1948
01:00:54,710 --> 01:00:57,160
0,570 600,1140 1140,1530 1530,2070
interrupt transmit interrupt complete,|
|

1949
01:00:57,190 --> 01:00:58,690
0,600 600,750 750,1020 1020,1410 1410,1500
{} it's goes off you
它继续在缓冲器中找另一个字符，

1950
01:00:58,690 --> 01:00:59,800
0,120 120,510 540,720 720,1020 1020,1110
know the, will find in

1951
01:00:59,800 --> 01:01:01,330
0,90 90,510 510,780 780,1050 1050,1530
the buffer yet another character,|
|

1952
01:01:01,330 --> 01:01:02,290
0,90 90,390 390,750 750,840 840,960
the space character and will
空格字符，然后把空格字符送出。

1953
01:01:02,290 --> 01:01:03,970
0,360 390,750 750,1020 1020,1410 1410,1680
send {} space character off.|
|

1954
01:01:06,980 --> 01:01:08,740
0,510 570,690 690,840 840,1170
Okay, that makes sense?|
好的，这能理解吗？|

1955
01:01:10,320 --> 01:01:11,730
0,330 330,570 570,840 870,1140 1140,1410
I have a high level
我有一个高层次的问题。

1956
01:01:11,730 --> 01:01:13,480
0,90 90,540 540,1170
of question actually.|
|

1957
01:01:13,510 --> 01:01:16,810
0,600 630,930 930,1650 1650,2310 2970,3300
So I understand the uart
我知道 UART 很有用，

1958
01:01:16,810 --> 01:01:18,250
0,240 240,450 450,690 690,1260 1260,1440
[] is like useful,| if
|比如使用键盘，

1959
01:01:18,250 --> 01:01:20,050
0,300 300,570 570,840 840,990 990,1800
{} like using the keyboard|
|

1960
01:01:20,410 --> 01:01:22,510
0,660 810,1260 1350,1860 1860,2040 2040,2100
and like characters from the
键盘上的字符通过 UART ，

1961
01:01:22,510 --> 01:01:24,730
0,660 660,900 900,1230 1230,1470 1470,2220
keyboard go through the uart|
|

1962
01:01:24,880 --> 01:01:26,080
0,180 180,360 360,570 570,630 630,1200
and then through the CPU|
然后通过 CPU ，|

1963
01:01:26,080 --> 01:01:27,130
0,180 180,330 330,390 390,720 720,1050
and then the kernel code
然后是我们编写的内核代码，

1964
01:01:27,130 --> 01:01:28,510
0,120 120,240 240,690 990,1230 1230,1380
that we wrote,| but I
|但是我不理解的是，

1965
01:01:28,510 --> 01:01:29,740
0,180 180,420 420,570 570,630 630,1230
am not sure I understand

1966
01:01:29,740 --> 01:01:30,580
0,210 210,300 300,600 600,750 750,840
what| the point of the
|当 UART 打印字符时，

1967
01:01:30,580 --> 01:01:32,350
0,450 450,660 660,1260 1260,1410 1410,1770
uart is when the shell

1968
01:01:32,350 --> 01:01:34,150
0,180 180,600 600,1380 1560,1740 1740,1800
is printing characters,| like the
|比如没有键盘交互。

1969
01:01:34,150 --> 01:01:36,130
0,480 480,900 900,1110 1110,1710 1710,1980
keyboard isn't being interacted with.|
|

1970
01:01:36,520 --> 01:01:37,480
0,270 270,330 330,420 420,690 690,960
{You,know}, it is correct,| but
这是正确的，|但是显示器是，

1971
01:01:37,480 --> 01:01:39,580
0,150 150,690 690,1080 1320,1650 1650,2100
the display is,| actually there's
|实际上有两个设备，

1972
01:01:39,580 --> 01:01:41,170
0,360 360,870 870,1140 1140,1440 1440,1590
two devices here,| one is
|一个是键盘，一个是 console 上的显示器。

1973
01:01:41,170 --> 01:01:42,100
0,150 150,570 570,660 660,840 840,930
the keyboard and one is

1974
01:01:42,100 --> 01:01:43,390
0,90 90,570 570,660 660,720 720,1290
the display on the console.|
|

1975
01:01:43,940 --> 01:01:46,700
0,1620 1620,1980 1980,2100 2100,2580 2580,2760
{} And the way {you,know}
QEMU 与 console 交互是通过 UART ，

1976
01:01:46,700 --> 01:01:47,750
0,300 300,480 480,900 900,990 990,1050
{QEMU -} interact with the

1977
01:01:47,750 --> 01:01:49,760
0,510 510,750 750,1410 1440,1530 1530,2010
console is by {uart -},|
|

1978
01:01:49,790 --> 01:01:52,190
0,630 720,960 960,1590 1710,1890 1890,2400
{} by sending a character
通过发送字符到控制台，

1979
01:01:52,190 --> 01:01:53,840
0,150 150,270 270,840 1320,1470 1470,1650
to the console| and then
|然后 console 的工作是

1980
01:01:53,840 --> 01:01:54,770
0,90 90,420 420,480 480,840 840,930
the {console's -} job is|
|

1981
01:01:54,770 --> 01:01:56,630
0,450 450,570 570,1140 1140,1350 1350,1860
basically to draw that character
在显示器上绘制该字符。

1982
01:01:56,630 --> 01:01:58,340
0,390 390,690 720,1230
on the display.|
|

1983
01:01:59,030 --> 01:02:00,710
0,210 210,210 210,810 840,1140 1140,1680
Oh I see, okay, thanks.|
哦，我明白了，好的，谢谢。|

1984
01:02:02,920 --> 01:02:04,060
0,210 210,330 330,540 540,900 930,1140
It might take time| and
这可能需要时间，|它需要画出这些东西。

1985
01:02:04,060 --> 01:02:04,930
0,120 120,420 420,600 600,690 690,870
that's why you know this

1986
01:02:04,930 --> 01:02:05,860
0,360 390,600 600,750 750,810 810,930
thing {you,know} sort of being

1987
01:02:05,860 --> 01:02:07,020
0,600
drawing.|
|

1988
01:02:08,040 --> 01:02:09,920
0,570 690,1320
Okay, um.|
好的。|

1989
01:02:10,100 --> 01:02:11,540
0,270 270,480 510,750 750,990 990,1440
So a couple things now,|
所以现在有几件事，|

1990
01:02:11,540 --> 01:02:12,470
0,210 210,420 420,480 480,660 660,930
{you,know} {I,want} to step back
我想退回去一点，

1991
01:02:12,470 --> 01:02:14,420
0,30 30,240 240,630 630,1170 1170,1950
a little bit| and {}
|从更高层次上考虑这件事，

1992
01:02:14,450 --> 01:02:16,040
0,420 450,840 840,1110 1110,1290 1290,1590
think a little bit higher

1993
01:02:16,040 --> 01:02:17,420
0,270 270,900 900,1080 1080,1230 1230,1380
level what's going on,| so
|所以我们应该遍历代码，

1994
01:02:17,420 --> 01:02:18,170
0,150 150,360 360,600 600,690 690,750
we should walk through the

1995
01:02:18,170 --> 01:02:19,070
0,420 420,510 510,630 630,810 810,900
code,| we get sort of
|我们对这里的情况有一些理解，

1996
01:02:19,070 --> 01:02:19,910
0,210 210,480 480,600 600,690 690,840
a feeling for the lay

1997
01:02:19,910 --> 01:02:21,830
0,90 90,150 150,570 1050,1560 1560,1920
of the land,| {} and
|比如细节怎样，

1998
01:02:21,830 --> 01:02:23,800
0,180 180,420 420,840
like how the

1999
01:02:25,670 --> 01:02:27,950
0,840 960,1200 1200,1380 1380,1770 1770,2280
details,| {} it's worthwhile to
|它值得退回一点，

2000
01:02:27,980 --> 01:02:29,180
0,270 270,540 540,570 570,930 930,1200
step back a second| and
|想一想这一切意味着什么。

2001
01:02:29,180 --> 01:02:30,230
0,180 180,210 210,420 420,600 600,1050
think a little bit about

2002
01:02:30,260 --> 01:02:30,920
0,150 150,210 210,420 420,540 540,660
you know what it all

2003
01:02:30,920 --> 01:02:32,000
0,510
means.|
|

2004
01:02:32,470 --> 01:02:34,570
0,330 330,990 1050,1320 1320,1410 1410,2100
In particular, what is interesting
特别是，有趣的是并发中断，

2005
01:02:34,690 --> 01:02:36,610
0,690 690,1200 1200,1680 1680,1830 1830,1920
is interrupting concurrency,| sort of
|从并发的角度考虑中断。

2006
01:02:36,610 --> 01:02:38,290
0,240 240,450 450,900 900,1080 1140,1680
think about interrupting the perspective

2007
01:02:38,290 --> 01:02:39,520
0,630
concurrency.|
|

2008
01:02:42,440 --> 01:02:43,790
0,510 510,750 840,1050 1050,1140 1140,1350
{} And this is one
这是使中断变得棘手或难以编程的一件事，

2009
01:02:43,790 --> 01:02:44,840
0,120 120,360 360,630 630,870 870,1050
of the things actually makes

2010
01:02:44,840 --> 01:02:47,540
0,600 600,1410 1440,1860 1860,2310 2340,2700
interrupts {} tricky or difficult

2011
01:02:47,540 --> 01:02:48,980
0,60 60,570 840,1140 1140,1380 1380,1440
to program,| so first of
|首先是我们之前提到过，

2012
01:02:48,980 --> 01:02:50,420
0,420 510,1080 1080,1230 1230,1320 1320,1440
all, {} you know we

2013
01:02:50,420 --> 01:02:52,820
0,270 270,1140 1200,1530 1530,2310 2310,2400
mentioned earlier,| the device you
|在我们的例子中的 UART 设备，

2014
01:02:52,820 --> 01:02:53,510
0,90 90,360 360,510 510,600 600,690
know {uart -} in our

2015
01:02:53,510 --> 01:02:55,070
0,570 810,990 990,1410 1410,1500 1500,1560
case,| the device and the
|设备和 CPU 并行运行。

2016
01:02:55,070 --> 01:02:56,240
0,780
CPU

2017
01:02:56,660 --> 01:02:58,220
0,390 390,960
{run,in} parallel.|
|

2018
01:03:03,140 --> 01:03:04,400
0,210 210,390 390,840 840,990 990,1260
So, one example is {in,our}
所以，比如，在我们讨论的场景中，

2019
01:03:04,430 --> 01:03:05,540
0,150 150,510 510,930 930,1050 1050,1110
you know scenario, what {you,know}

2020
01:03:05,540 --> 01:03:08,360
0,270 270,690 840,1050 1050,1560 2220,2820
talk about,| you know {uart
|UART 发送一个字符给 console ，

2021
01:03:08,360 --> 01:03:09,770
0,300 300,630 630,1080 1080,1170 1170,1410
-} sending off you know

2022
01:03:09,770 --> 01:03:11,870
0,480 540,1380 1380,1590 1590,1860 1860,2100
a character to the {console

2023
01:03:11,870 --> 01:03:13,940
0,420 510,780 780,1230 1230,1410 1410,2070
-},| and while that's happening,
|在这个发生的同时， CPU 仍在继续它的工作，

2024
01:03:14,000 --> 01:03:15,860
0,240 240,480 480,990 990,1500 1530,1860
the CPU still {you,know} go

2025
01:03:15,860 --> 01:03:17,360
0,300 300,450 450,1020 1020,1380 1380,1500
about its business| and in
|在这种情况下，返回到 shell ，

2026
01:03:17,360 --> 01:03:18,590
0,120 120,420 420,990 990,1140 1140,1230
this case, returning to the

2027
01:03:18,590 --> 01:03:20,300
0,660 780,1080 1080,1350 1350,1500 1500,1710
shell,| the shell may make
|shell 可以调用其他的系统调用写入空格字符，

2028
01:03:20,300 --> 01:03:21,680
0,240 240,570 570,990 990,1290 1290,1380
another system call attempt to

2029
01:03:21,680 --> 01:03:25,220
0,240 240,1080 1110,1830 1980,3120 3390,3540
write {} space character| and
|所有这些都是并行进行的，

2030
01:03:25,220 --> 01:03:26,900
0,210 210,570 570,630 630,1110 1290,1680
all happens in parallel| and
|所以我们需要管理这种并行性，

2031
01:03:26,900 --> 01:03:28,130
0,150 150,330 330,510 510,690 690,1230
so we need to manage

2032
01:03:28,130 --> 01:03:29,540
0,180 180,690 690,780 780,1140 1140,1410
that parallelism a bit| and
|我们已经看过一点，

2033
01:03:29,540 --> 01:03:30,500
0,240 240,480 480,660 660,750 750,960
we already saw a little

2034
01:03:30,500 --> 01:03:31,160
0,210 210,330 330,390 390,510 510,660
bit,| but I'm gonna talk
|但我会更详细地讨论一下。

2035
01:03:31,160 --> 01:03:31,760
0,30 30,180 180,360 360,540 540,600
a little bit more in

2036
01:03:31,760 --> 01:03:32,620
0,570
detail.|
|

2037
01:03:32,620 --> 01:03:33,790
0,120 120,210 210,450 450,540 540,1170
And the type of parallelism
这里显示的并行性，

2038
01:03:33,790 --> 01:03:35,080
0,150 150,420 420,660 660,840 840,1290
that actually shows up here|
|

2039
01:03:35,110 --> 01:03:37,030
0,210 210,570 570,870 870,1440 1440,1920
is typically called producer consumer
通常称为生产者-消费者并行性。

2040
01:03:37,030 --> 01:03:38,180
0,540
parallelism.|
|

2041
01:03:45,800 --> 01:03:49,010
0,420 420,1260 1350,1950 1950,2670 2760,3210

2042
01:03:49,040 --> 01:03:50,030
0,210 210,420 420,660 660,900 900,990
Let me talk about in
我稍后讲一下，

2043
01:03:50,030 --> 01:03:51,140
0,60 60,300 300,480 480,870 870,1110
a second,| so now we're
|所以现在我们更详细地讨论一下。

2044
01:03:51,140 --> 01:03:51,830
0,150 150,270 270,480 480,570 570,690
gonna talk about it a

2045
01:03:51,830 --> 01:03:53,480
0,180 180,360 360,840 1020,1260 1260,1650
little more detail.| The second
|第二个是，

2046
01:03:53,480 --> 01:03:54,340
0,360
is,|
|

2047
01:03:54,680 --> 01:03:58,550
0,750 750,1350 1590,2520 2760,2970 2970,3870
{} that the {} interrupt
中断停止了当前正在运行的程序，

2048
01:04:02,080 --> 01:04:03,790
0,480 480,570 570,900 900,1110 1110,1710
stops the current running program,|
|

2049
01:04:08,450 --> 01:04:09,500
0,180 180,270 270,630 630,930 930,1050
or the current program is
或者正在运行的当前程序。

2050
01:04:09,500 --> 01:04:10,480
0,360
running.|
|

2051
01:04:12,740 --> 01:04:13,580
0,300 300,480 480,570 570,780 780,840
So in the case of
所以在 shell 的情况下，

2052
01:04:13,580 --> 01:04:15,440
0,60 60,570 780,1230 1230,1440 1440,1860
the shell,| shell might be
|shell 程序可能正在执行类似 212 的指令，

2053
01:04:15,440 --> 01:04:18,950
0,630 630,1260 1260,1920 2250,2910 2910,3510
executing instruction like {212 -}|
|

2054
01:04:19,250 --> 01:04:20,630
0,300 300,600 600,960 960,1140 1140,1380
and boom interrupt comes in|
然后突然出现了中断，|

2055
01:04:20,630 --> 01:04:22,100
0,150 150,960 960,1200 1200,1320 1320,1470
and immediate {that,point} is just
直接在这一点停下来。

2056
01:04:22,100 --> 01:04:23,000
0,480
stopped.|
|

2057
01:04:23,340 --> 01:04:25,110
0,630 630,810 810,1200 1200,1650 1650,1770
{} And that's something, you
对用户空间的代码来说，这没什么大不了的，

2058
01:04:25,110 --> 01:04:26,070
0,90 90,270 270,510 510,780 780,960
know for user space code,

2059
01:04:26,070 --> 01:04:27,030
0,180 180,360 360,420 420,780 780,960
that's not a particularly big

2060
01:04:27,030 --> 01:04:29,160
0,510 690,1170 1170,1710 1710,1980 1980,2130
deal,| {} because when we
|因为当我们从中断返回，

2061
01:04:29,160 --> 01:04:30,390
0,360 360,480 480,600 600,1020 1020,1230
return from the interrupt,| when
|我们会恢复用户级别程序的所有状态，

2062
01:04:30,390 --> 01:04:31,980
0,180 180,780 780,900 900,1020 1020,1590
we restore all the state

2063
01:04:32,130 --> 01:04:33,690
0,390 390,510 510,750 750,990 990,1560
of the user level program|
|

2064
01:04:33,870 --> 01:04:35,250
0,360 360,450 450,630 630,1260 1290,1380
and it will resume you
它会恢复出现中断的地址，

2065
01:04:35,250 --> 01:04:36,600
0,150 150,570 600,780 780,960 960,1350
know at you know address

2066
01:04:36,600 --> 01:04:38,520
0,510 510,870 870,1440 1500,1710 1710,1920
which got interrupted| and so
|我们已经在 traps 和页面错误中看到了，

2067
01:04:38,520 --> 01:04:40,000
0,210 210,390 390,780 780,1080
we've seen that with

2068
01:04:40,090 --> 01:04:41,410
0,480 480,570 570,780 780,1140 1140,1320
traps and page faults,| and
|实际上是相当不错的，

2069
01:04:41,410 --> 01:04:43,480
0,270 270,420 420,720 720,1320 1650,2070
so you know, {} actually

2070
01:04:43,480 --> 01:04:44,950
0,210 210,360 360,660 660,1110 1140,1470
works out reasonable well,| but
|不过，这里有个棘手的情况，

2071
01:04:44,950 --> 01:04:45,550
0,180 180,240 240,420 420,510 510,600
there's a little bit of

2072
01:04:45,550 --> 01:04:47,200
0,60 60,420 420,900 900,1530 1560,1650
{} tricky case,| when the
|当内核本身中断时，

2073
01:04:47,200 --> 01:04:49,120
0,330 330,810 810,1500 1530,1800 1800,1920
kernel itself interrupted,| so you're
|所以如果是在内核模式下运行，

2074
01:04:49,120 --> 01:04:50,470
0,240 240,330 330,600 600,990 1140,1350
running in kernel mode| and
|而且内核被中断，

2075
01:04:50,470 --> 01:04:52,020
0,60 60,300 300,480 480,1080
the kernel gets interrupted,|
|

2076
01:04:52,020 --> 01:04:54,030
0,180 180,570 570,930 990,1770 1770,2010
that means that, {} and
这意味着，再说得更详细一点，

2077
01:04:54,180 --> 01:04:55,080
0,330 330,360 360,510 510,690 690,900
talk a little bit more

2078
01:04:55,080 --> 01:04:56,970
0,570 600,1260 1260,1470 1470,1530 1530,1890
detail,| that even the kernel
|即使是内核也不是直接按顺序执行的，

2079
01:04:56,970 --> 01:04:58,470
0,300 300,660 660,840 840,900 900,1500
doesn't really sort of executed

2080
01:04:58,470 --> 01:05:00,090
0,300 300,930 1110,1230 1230,1380 1380,1620
straight sequentially,| if you see
|如果你看到一条内核指令后跟另一条内核指令，

2081
01:05:00,090 --> 01:05:01,440
0,300 300,540 540,960 960,1230 1230,1350
one kernel instruction followed by

2082
01:05:01,440 --> 01:05:04,020
0,270 270,600 600,1200 1590,2310 2310,2580
another kernel instruction,| {} {in,the}
|在这些指令之间，中断可能发生，

2083
01:05:04,020 --> 01:05:06,180
0,420 420,690 690,1530 1620,1800 1800,2160
between those instructions and interrupt

2084
01:05:06,180 --> 01:05:07,240
0,180 180,630
might happen,|
|

2085
01:05:07,590 --> 01:05:10,200
0,900 900,1110 1110,1830 1830,2280 2280,2610
{ -} depending whether interrupts
取决于是否启用中断。

2086
01:05:10,200 --> 01:05:11,600
0,90 90,420 420,480 480,870
are enabled or not.|
|

2087
01:05:11,820 --> 01:05:13,680
0,510 660,840 840,1350 1350,1680 1680,1860
In so whether, and some
在一些代码中，

2088
01:05:13,680 --> 01:05:14,700
0,150 150,240 240,660 660,810 810,1020
piece of code| and it's
|在中间可以中断是不好的，

2089
01:05:14,700 --> 01:05:15,480
0,210 210,420 420,510 510,690 690,780
not good to have an

2090
01:05:15,480 --> 01:05:17,340
0,450 450,600 600,1230 1320,1740 1740,1860
interrupt in between,| {} and
|在下一个示例中，

2091
01:05:17,340 --> 01:05:18,120
0,60 60,240 240,570 570,690 690,780
in next case,| you know
|内核可能必须禁用或启用中断，

2092
01:05:18,120 --> 01:05:19,170
0,120 120,360 360,600 600,870 870,1050
the kernel might actually have

2093
01:05:19,170 --> 01:05:20,880
0,90 90,600 600,690 690,1230 1230,1710
to disable or enable interrupts|
|

2094
01:05:20,880 --> 01:05:22,710
0,90 90,360 360,810 810,1080 1080,1830
to make basically code sequences
使代码序列是原子的。

2095
01:05:22,800 --> 01:05:24,180
0,900
atomic.|
|

2096
01:05:24,930 --> 01:05:26,920
0,360 360,720 720,1440
{} So interrupt
中断启用和禁用。

2097
01:05:29,320 --> 01:05:31,760
0,690 690,960 960,1560
enable and disable.|
|

2098
01:05:35,230 --> 01:05:35,890
0,120 120,270 270,480 480,630 630,660
I'll talk about in a
稍后我会更详细地谈到，

2099
01:05:35,890 --> 01:05:37,630
0,300 300,480 480,750 750,1290 1380,1740
second in more detail| and
|第三关于并发的问题，

2100
01:05:37,630 --> 01:05:38,980
0,150 150,240 240,360 360,960 990,1350
sort of the third {}

2101
01:05:38,980 --> 01:05:41,290
0,180 180,240 240,1110 1140,1800 1830,2310
sort of concurrency {} problem|
|

2102
01:05:41,290 --> 01:05:43,780
0,120 120,360 360,750 870,1800 1950,2490
that shows up in the,
出现在中断处理程序中。

2103
01:05:44,630 --> 01:05:46,340
0,330 330,450 450,1140
in interrupt handler.|
|

2104
01:05:47,490 --> 01:05:48,390
0,150 150,360 360,600 600,810 810,900
Let me say, let me
让我换个说法，

2105
01:05:48,390 --> 01:05:50,550
0,300 300,930 1140,1410 1410,1950 1980,2160
say differently,| the top of
|驱动的顶部和底部可以并行运行。

2106
01:05:50,550 --> 01:05:51,940
0,60 60,780
the driver

2107
01:05:55,080 --> 01:05:55,770
0,120 120,210 210,510 510,630 630,690
and the bottom of the

2108
01:05:55,770 --> 01:05:57,160
0,660
driver

2109
01:05:57,530 --> 01:05:59,800
0,270 270,780 930,1050 1050,1650
may run in parallel.|
|

2110
01:06:08,660 --> 01:06:09,770
0,180 180,270 270,840 840,990 990,1110
So, for example in our
比如，在我们的例子中，

2111
01:06:09,770 --> 01:06:11,780
0,720 870,1410
example, {}|
|

2112
01:06:12,370 --> 01:06:14,170
0,210 210,900 1020,1530 1530,1680 1680,1800
the shell {} is going
shell 会再次调用 write 系统调用，

2113
01:06:14,170 --> 01:06:15,790
0,60 60,150 150,540 540,1320 1350,1620
to be called the write

2114
01:06:15,790 --> 01:06:17,380
0,300 300,630 630,1080 1080,1200 1200,1590
system call again,| {you,know} {to,print}
|在打印 $ 之后打印空格，

2115
01:06:17,380 --> 01:06:18,640
0,150 150,450 450,780 780,1140 1140,1260
the white space after it

2116
01:06:18,640 --> 01:06:21,370
0,300 300,540 570,1200 1410,1860 1860,2730
printed the $| and while
|如果你回到驱动的顶部，

2117
01:06:21,370 --> 01:06:22,480
0,90 90,360 360,570 570,870 870,1110
you may go back into

2118
01:06:22,480 --> 01:06:23,230
0,120 120,390 390,570 570,660 660,750
the top level of the

2119
01:06:23,230 --> 01:06:24,880
0,690 780,1110 1110,1260 1260,1500 1500,1650
driver,| {} it might want
|它可能想，

2120
01:06:24,880 --> 01:06:26,080
0,180 210,510 630,960 960,1140 1140,1200
to and may want to|
|

2121
01:06:26,080 --> 01:06:27,310
0,480 510,600 600,720 720,930 930,1230
add you know, this white
添加这个空格到 UART 的队列中，

2122
01:06:27,310 --> 01:06:29,020
0,360 360,450 450,630 630,1140 1140,1710
space to that queue the

2123
01:06:29,020 --> 01:06:31,120
0,90 90,900 900,1260 1260,1650 1800,2100
the uart actually has,| but
|但同时在另一个 CPU 上，

2124
01:06:31,120 --> 01:06:32,200
0,120 120,210 210,540 540,930 930,1080
at the same time on

2125
01:06:32,200 --> 01:06:34,030
0,330 330,1080 1170,1350 1350,1560 1560,1830
another CPU,| it might actually
|它可能在处理来自 UART 的中断，

2126
01:06:34,030 --> 01:06:36,700
0,510 540,1200 1200,1950 1980,2190 2190,2670
take {} interrupt {you,know} for

2127
01:06:36,700 --> 01:06:39,820
0,570 690,1350 1500,2100 2100,2490 2490,3120
the uart| and basically also
|这也是并行运行的，

2128
01:06:39,820 --> 01:06:41,830
0,720 750,1200 1200,1320 1320,1920 1920,2010
{} running in parallel| and
|这是相同的代码，查看相同的队列。

2129
01:06:41,830 --> 01:06:42,820
0,150 150,360 360,480 510,900 900,990
that's sort of roughly the

2130
01:06:42,820 --> 01:06:43,900
0,240 240,570 570,690 690,960 960,1080
same code and looking at

2131
01:06:43,900 --> 01:06:44,960
0,60 60,360 360,780
the same queue.|
|

2132
01:06:45,300 --> 01:06:46,380
0,240 240,330 330,480 480,660 660,1080
And so it's really true|
所以这是真的，|

2133
01:06:46,380 --> 01:06:47,700
0,150 150,510 510,600 600,960 960,1320
that basically the interrupt handler
中断处理程序可以并行运行，

2134
01:06:47,700 --> 01:06:48,930
0,150 150,360 360,450 450,1170 1170,1230
can run in parallel| at
|设备驱动的底部，

2135
01:06:48,930 --> 01:06:49,740
0,90 90,360 360,660 660,720 720,810
the bottom half of the

2136
01:06:49,740 --> 01:06:50,940
0,330 330,660 660,870 870,1110 1110,1200
device driver| may run in
|可能并行运行在不同的 CPU 上，

2137
01:06:50,940 --> 01:06:52,530
0,450 450,570 570,870 870,1350 1350,1590
parallel on different {CPUs -},|
|

2138
01:06:53,000 --> 01:06:54,350
0,300 300,360 360,570 570,1020 1050,1350
on the different CPU with
与驱动程序的顶部位于不同的 CPU 上。

2139
01:06:54,350 --> 01:06:56,180
0,90 90,480 480,870 870,1740 1740,1830
the top half of the

2140
01:06:56,180 --> 01:06:57,180
0,480
driver.|
|

2141
01:06:57,270 --> 01:06:58,080
0,210 210,330 330,480 480,540 540,810
So we have to manage
所以我们必须处理好这个，

2142
01:06:58,080 --> 01:06:59,670
0,210 210,240 240,570 870,1350 1350,1590
that a bit,| {} and
|而我们管理的方式就是使用锁。

2143
01:06:59,670 --> 01:07:00,960
0,120 120,660 810,1050 1050,1230 1230,1290
the way we're going to

2144
01:07:00,960 --> 01:07:02,460
0,300 300,570 570,690 690,930 930,1500
manage that is using locks.|
|

2145
01:07:06,060 --> 01:07:07,140
0,420 420,570 570,630 630,870 870,1080
Because there's a shared data
因为这里有一个共享的数据结构，

2146
01:07:07,140 --> 01:07:08,130
0,360 360,600 600,690 690,870 870,990
structure here| and then we
|我们需要一个缓冲区，

2147
01:07:08,130 --> 01:07:10,620
0,150 150,570 600,1230 1350,2040 2220,2490
need a buffer| and we're
|我们要确保缓冲区正确更新，

2148
01:07:10,620 --> 01:07:11,370
0,120 120,180 180,300 300,510 510,750
going to make sure that

2149
01:07:11,370 --> 01:07:12,450
0,120 120,240 240,600 630,1020 1020,1080
you know the buffer is

2150
01:07:12,450 --> 01:07:14,910
0,720 720,1350 1590,2190 2190,2370 2370,2460
updated correctly,| and you need
|需要确保一次只有一个 CPU

2151
01:07:14,910 --> 01:07:16,770
0,120 120,360 360,600 600,840 840,1860
to make sure that {}

2152
01:07:17,070 --> 01:07:19,500
0,270 270,840 870,1740 1830,2340 2340,2430
only one {} CPU at

2153
01:07:19,500 --> 01:07:21,000
0,30 30,360 360,750 750,1260 1260,1500
a time,| basically manipulates that
|操纵这个特定的缓冲区，

2154
01:07:21,000 --> 01:07:21,990
0,450 450,750 750,810 810,930 930,990
particular buffer,| we're going to
|我们需要使用锁。

2155
01:07:21,990 --> 01:07:23,040
0,180 180,630
use locks.|

2156
01:07:23,100 --> 01:07:23,880
0,210 210,510 510,600 600,720 720,780
And locks is going to
锁将是周三课程的主题，

2157
01:07:23,880 --> 01:07:25,140
0,150 150,420 420,750 750,840 840,1260
be the topic of Wednesday's

2158
01:07:25,140 --> 01:07:26,190
0,360 420,600 600,720 720,840 840,1050
lecture,| I'm not gonna talk
|我不会讨论太多，

2159
01:07:26,190 --> 01:07:27,180
0,150 150,390 390,510 510,570 570,990
much about it at all,|
|

2160
01:07:27,210 --> 01:07:28,230
0,450 450,600 600,780 780,840 840,1020
but {it,will} show a big
但是在周三会有很多讨论。

2161
01:07:28,230 --> 01:07:29,680
0,240 240,390 390,960
time on Wednesday.|
|

2162
01:07:30,810 --> 01:07:31,350
0,120 120,300 300,360 360,480 480,540
The thing I want to
我想关注的是生产者-消费者平行性，

2163
01:07:31,350 --> 01:07:32,280
0,300 300,480 480,570 570,810 810,930
focus on is actually to

2164
01:07:32,280 --> 01:07:35,940
0,360 360,1020 1050,2460 2760,3420
producer consumer { -

2165
01:07:37,070 --> 01:07:39,110
0,330 330,1020 1170,1470 1470,1920 1920,2040
-} parallelism,| and this is
|这是一种在驱动程序出现的典型模式，

2166
01:07:39,110 --> 01:07:40,190
0,180 180,570 570,750 750,840 840,1080
a typical thing that shows

2167
01:07:40,190 --> 01:07:41,690
0,180 180,360 360,510 510,1110 1110,1500
up in {} drivers| and
|这是非常常见的。

2168
01:07:41,690 --> 01:07:44,870
0,390 420,990 990,1590 1650,2910 2940,3180
it's extremely common to see

2169
01:07:44,870 --> 01:07:48,260
0,120 120,540 960,1440 1680,2550 2580,3390
that.| So {} producer consumer.|
|生产者和消费者。|

2170
01:07:53,150 --> 01:07:55,520
0,420 420,690 690,900 900,1740 1740,2370
And it's pretty straightforward {},|
这也很简单，|

2171
01:07:55,550 --> 01:07:56,960
0,300 300,570 570,660 660,1290 1290,1410
so when you see, you
当你看到，驱动程序中有一个缓冲区，

2172
01:07:56,960 --> 01:07:58,520
0,120 120,300 300,1020
know there's basically

2173
01:07:58,550 --> 01:08:00,020
0,150 150,540 540,660 660,750 750,1470
a buffer in the driver,|
|

2174
01:08:01,750 --> 01:08:02,560
0,150 150,270 270,390 390,480 480,810
you know in our case,
在我们的示例中，我想有 32 个条目，

2175
01:08:02,560 --> 01:08:03,430
0,120 120,270 270,360 360,480 480,870
I think there were 32

2176
01:08:03,430 --> 01:08:05,470
0,360 360,510 510,810 1200,1590 1620,2040
entries in it,| so zero
|从 0 到 31 ，

2177
01:08:05,470 --> 01:08:08,860
0,120 120,630 1110,1740 1950,2970 2970,3390
to three one| and {}
|并且有两个指针，

2178
01:08:08,860 --> 01:08:10,700
0,450 450,600 600,1380
there's two pointers,|
|

2179
01:08:10,700 --> 01:08:11,810
0,240 240,450 450,540 540,750 750,1110
{} there's a read pointer
有一个读指针和一个写指针。

2180
01:08:11,810 --> 01:08:13,440
0,90 90,180 180,420 420,1080
and the write pointer.|
|

2181
01:08:13,870 --> 01:08:16,330
0,630 1230,1500 1500,1620 1620,1860 1860,2460
You know, the write pointer
写指针，读指针，

2182
01:08:16,360 --> 01:08:18,370
0,240 240,930 960,990 990,990 1740,2010
read pointer| { -} if
|如果它们相等，缓冲区就是空的，

2183
01:08:18,370 --> 01:08:19,330
0,60 60,90 90,750 780,870 870,960
they are equal, you know

2184
01:08:19,330 --> 01:08:20,920
0,120 120,360 360,450 450,1050 1230,1590
the buffer is empty| and
|当 shell 写入时，比如使用 putc ，

2185
01:08:20,920 --> 01:08:21,970
0,180 180,720 720,810 810,930 930,1050
so when you know the

2186
01:08:21,970 --> 01:08:24,250
0,660 960,1290 1290,1500 1500,1740 1770,2280
shell, we do a write,

2187
01:08:24,280 --> 01:08:25,920
0,120 120,300 300,480
you know putc,|
|

2188
01:08:26,800 --> 01:08:28,450
0,330 360,930 930,1110 1110,1200 1200,1650
that basically puts the character
就是把像 $ 这样的字符放到这里，

2189
01:08:28,450 --> 01:08:30,070
0,180 180,270 270,690 690,1260 1410,1620
like the $ here| and
|并将写指针指向下一条目。

2190
01:08:30,070 --> 01:08:31,780
0,360 360,660 660,960 960,1230 1230,1710
bumps up the write pointer

2191
01:08:31,780 --> 01:08:33,300
0,180 180,270 270,540 540,960
to the next entry.|
|

2192
01:08:34,440 --> 01:08:35,100
0,180 180,330 330,510 510,570 570,660
So that's sort of the
这就是生产者的部分，

2193
01:08:35,100 --> 01:08:36,900
0,450 450,930 1140,1350 1350,1410 1410,1800
producer part| and the producer
|生产者可以继续，

2194
01:08:36,900 --> 01:08:37,920
0,150 150,360 360,840 840,900 900,1020
can keep going,| you know
|填满所有这些字符，

2195
01:08:37,920 --> 01:08:39,150
0,300 300,690 690,750 750,960 960,1230
filling up you know all

2196
01:08:39,150 --> 01:08:41,190
0,360 360,960 990,1410 1410,1560 1560,2040
this {} characters| {until -}
|直到到达，

2197
01:08:41,190 --> 01:08:43,240
0,90 90,300 300,840 840,1470
you know it {},

2198
01:08:43,240 --> 01:08:44,710
0,540 600,900 900,1290 1290,1380 1380,1470
{} until hits you know

2199
01:08:44,710 --> 01:08:46,270
0,240 240,900 900,1170 1170,1320 1320,1560
the {},| until you know
|直到如果下一个将达到读指针，

2200
01:08:46,300 --> 01:08:47,410
0,240 240,330 330,540 540,1020 1020,1110
if the next increment would

2201
01:08:47,410 --> 01:08:48,280
0,150 150,210 210,450 450,780 780,870
hit the read pointer,| we
|我们知道这个循环缓冲区已满，

2202
01:08:48,280 --> 01:08:50,320
0,180 180,600 600,1200 1320,1740 1740,2040
know that this circle buffer

2203
01:08:50,320 --> 01:08:51,520
0,120 120,660 780,1020 1020,1080 1080,1200
is full| and at that
|在这时，生产者必须停止，

2204
01:08:51,520 --> 01:08:52,600
0,330 330,420 420,540 540,750 750,1080
point you know the producer

2205
01:08:52,600 --> 01:08:53,860
0,270 270,570 600,810 810,1110 1110,1260
must stop| and we saw
|我们之前在代码中看到了，

2206
01:08:53,860 --> 01:08:55,240
0,150 150,630 630,840 840,1320 1320,1380
that happening in the, in

2207
01:08:55,240 --> 01:08:56,650
0,90 90,540 660,930 930,1140 1140,1410
the code a second ago,|
|

2208
01:08:56,650 --> 01:08:58,330
0,600 630,870 870,1200 1200,1560 1560,1680
where the uart, basically the
UART 调用 sleep ，

2209
01:08:58,330 --> 01:09:00,340
0,360 360,540 540,1110 1140,1650 1740,2010
uart called sleep| and will
|把 shell 放在边上，

2210
01:09:00,340 --> 01:09:01,220
0,150 150,540
put this

2211
01:09:01,250 --> 01:09:02,580
0,750
the

2212
01:09:02,870 --> 01:09:04,760
0,720 720,780 780,1230 1230,1290 1290,1890
shell {} on the side|
|

2213
01:09:04,760 --> 01:09:06,410
0,390 390,630 630,870 870,1140 1140,1650
and start running another process.|
并运行另一个进程。|

2214
01:09:07,940 --> 01:09:09,410
0,180 180,300 300,600 600,1260 1260,1470
So the interrupt handler, {uartinit
所以中断处理程序 uartinit 或 intr ，

2215
01:09:09,410 --> 01:09:10,940
0,150 150,300 300,600 750,1050 1050,1530
- - -} or intr,|
|

2216
01:09:12,870 --> 01:09:13,830
0,180 180,360 360,720 720,900 900,960
in this case at the
这种情况下，在消费者这边，

2217
01:09:13,830 --> 01:09:16,800
0,810 900,1440 1440,1650 1650,2250 2280,2970
consumer,| immediately every time {}
|每次都是 uartstart ，

2218
01:09:16,800 --> 01:09:19,380
0,870 870,1080 1080,1920 2100,2160 2190,2580
when it's a {uartstart -

2219
01:09:19,380 --> 01:09:22,110
0,510 540,1200 1440,2310 2310,2520 2520,2730
-} basically,| when you're in
|当你在中断中，它查看读指针，

2220
01:09:22,110 --> 01:09:23,940
0,630 630,1260 1260,1440 1440,1590 1590,1830
{} interrupts, it will look

2221
01:09:23,940 --> 01:09:25,320
0,210 210,300 300,480 480,720 720,1380
at you know the {read,pointer},|
|

2222
01:09:25,470 --> 01:09:26,970
0,480 480,690 690,870 870,1350 1350,1500
{} if the {read,pointer} is
如果读指针在写指针之后，

2223
01:09:26,970 --> 01:09:28,380
0,450 450,690 690,930 930,1350 1350,1410
behind the write pointer,| so
|写指针已经走远，

2224
01:09:28,380 --> 01:09:29,730
0,90 90,300 300,750 750,930 930,1350
the write pointer already further,|
|

2225
01:09:29,730 --> 01:09:30,990
0,210 210,420 420,930 930,1110 1110,1260
let's say spaces here too,
假设这里是空格，

2226
01:09:30,990 --> 01:09:32,100
0,420 420,630 630,750 750,870 900,1110
now,| I {don't,know} {actually -}
|我不知道怎么画空格，但这有一个空格。

2227
01:09:32,100 --> 01:09:32,880
0,150 150,240 240,390 390,480 480,780
how to draw a space,

2228
01:09:32,880 --> 01:09:34,240
0,150 150,420 420,480 480,1020
but here's a space.|
|

2229
01:09:34,500 --> 01:09:35,670
0,570 570,720 720,840 840,960 960,1170
{} And so the write
所以写指针现在可能在这里。

2230
01:09:35,670 --> 01:09:37,110
0,330 330,510 510,690 690,840 840,1440
pointer might now be here.|
|

2231
01:09:37,680 --> 01:09:39,090
0,180 180,630 630,750 750,1230 1230,1410
So after the [] being
所以在[]发出之后，

2232
01:09:39,090 --> 01:09:41,070
0,480 480,570 570,780 780,1320 1410,1980
sent,| you know the uart
|UART 看到，在写指针后面，

2233
01:09:41,070 --> 01:09:42,150
0,180 180,510 540,660 660,900 900,1080
sees, {} you know I'm

2234
01:09:42,150 --> 01:09:43,140
0,360 360,420 420,660 660,870 870,990
behind the write pointer,| and
|这意味着得发送下一个。

2235
01:09:43,140 --> 01:09:44,250
0,90 90,420 420,900 900,1050 1050,1110
that means I got to

2236
01:09:44,250 --> 01:09:45,580
0,210 210,300 300,510 510,750
send the next one.|

2237
01:09:46,280 --> 01:09:47,510
0,180 180,630 630,960 960,1050 1050,1230
And so you can think
所以你可以把它看作是，

2238
01:09:47,510 --> 01:09:48,290
0,240 240,420 420,510 510,690 690,780
about this as sort of|
|

2239
01:09:48,290 --> 01:09:50,000
0,390 390,900 930,1050 1050,1140 1140,1710
the write you know pointer,
写指针，读指针在改变写指针，

2240
01:09:50,000 --> 01:09:51,470
0,210 210,570 570,690 690,1170 1170,1470
the {read,pointer} is changing the

2241
01:09:51,470 --> 01:09:54,170
0,120 120,360 360,960 1170,1950 1950,2700
the write pointer| {} and
|这就是正在发生的事情，

2242
01:09:54,200 --> 01:09:56,390
0,750 990,1560 1560,1710 1710,1920 1920,2190
{} that's what's going on,|
|

2243
01:09:56,390 --> 01:09:56,990
0,120 120,270 270,420 420,510 510,600
now it could be the
现在可能出现，

2244
01:09:56,990 --> 01:09:58,100
0,300 300,450 450,510 510,690 690,1110
case,| that at some point,
|在某个时候， UART 与写指针保持同步，

2245
01:09:58,460 --> 01:10:01,040
0,330 330,750 990,1620 1770,2280 2310,2580
{} the uart {} keeps

2246
01:10:01,040 --> 01:10:02,330
0,300 300,420 420,510 510,720 720,1290
up with the write pointer|
|

2247
01:10:02,330 --> 01:10:03,740
0,330 330,570 570,720 720,1230 1230,1410
and when they're equal and
当它们相等时，它知道缓冲区是空的，

2248
01:10:03,740 --> 01:10:04,430
0,180 180,240 240,480 480,600 600,690
then it knows that the

2249
01:10:04,430 --> 01:10:05,360
0,270 270,390 390,720 720,810 810,930
buffer is empty| and there's
|没什么事情可做。

2250
01:10:05,360 --> 01:10:06,380
0,240 240,330 330,540
nothing to do.|
|

2251
01:10:09,220 --> 01:10:10,480
0,90 90,180 180,300 300,690
Does that make sense?|
这能理解吗？|

2252
01:10:12,190 --> 01:10:14,290
0,480 510,720 720,1200 1230,1680 1680,2100
Sorry, so this data structure
不好意思，这个数据结构对所有核心都是相同的吗？

2253
01:10:14,290 --> 01:10:16,030
0,420 420,570 570,900 900,1350 1410,1740
is the same for all

2254
01:10:16,030 --> 01:10:17,400
0,870
cores?|
|

2255
01:10:17,400 --> 01:10:19,140
0,630 750,1170 1170,1320 1320,1410 1410,1740
{} Okay, so let me
好的，让我回到代码上来，

2256
01:10:19,140 --> 01:10:20,130
0,120 120,330 330,420 420,510 510,990
go back to the code

2257
01:10:20,160 --> 01:10:23,010
0,360 390,1020 1020,1560 1860,2340 2340,2850
right,| then a high-level picture.|
|然后是高层级的图片。|

2258
01:10:23,560 --> 01:10:24,580
0,420 420,570 570,690 690,930 930,1020
And let's go back to
让我们回到 UART ，

2259
01:10:24,580 --> 01:10:25,660
0,60 60,510 510,660 660,810 810,1080
{uart -},| so this data
|所以这个数据结构，

2260
01:10:25,660 --> 01:10:26,820
0,600
structure,|
|

2261
01:10:26,820 --> 01:10:27,870
0,360 360,540 540,660 660,840 840,1050
{} that we just talked
刚才谈到的就是这个缓冲区。

2262
01:10:27,870 --> 01:10:29,460
0,300 300,420 420,600 600,1050
about is this buffer.|
|

2263
01:10:32,600 --> 01:10:34,100
0,390 390,510 510,660 660,1290 1350,1500
And the two pointers {you,know}
这两个指针，写指针和读指针，

2264
01:10:34,100 --> 01:10:34,880
0,120 120,420 420,510 510,570 570,780
the write and the read

2265
01:10:34,880 --> 01:10:36,050
0,360 360,450 450,660 660,840 840,1170
pointer,| are these two {}
|是两个索引用来[]。

2266
01:10:36,050 --> 01:10:37,380
0,810
indexes

2267
01:10:37,620 --> 01:10:38,980
0,210 210,810
use {in,[]}.|
|

2268
01:10:39,330 --> 01:10:40,520
0,660
Okay?|
好的?|

2269
01:10:41,080 --> 01:10:43,570
0,750 870,1500 1530,1920 1920,2190 2190,2490
And this data structure {is,in}
并且这个数据结构在内存中，

2270
01:10:43,570 --> 01:10:44,660
0,540
memory,|
|

2271
01:10:45,010 --> 01:10:46,150
0,450 450,600 600,750 750,930 930,1140
{} and there's only one
这里只有一个 RAM ，

2272
01:10:46,150 --> 01:10:47,680
0,480 690,1050 1050,1170 1170,1350 1350,1530
RAM right| and so all
|所以，所有核心都可能与这个数据结构并行交互。

2273
01:10:47,680 --> 01:10:49,780
0,60 60,750 900,1650 1680,1980 1980,2100
the cores {} might be

2274
01:10:49,780 --> 01:10:51,130
0,480 480,600 600,750 750,990 990,1350
interacting with this data structure

2275
01:10:51,130 --> 01:10:52,300
0,90 90,660
in parallel.|
|

2276
01:10:53,220 --> 01:10:54,510
0,210 210,420 420,570 570,720 720,1290
That's why we need locks.|
这就是为什么我们需要锁。|

2277
01:10:57,350 --> 01:10:58,820
0,450 450,630 630,990 1020,1290 1290,1470
Okay I see.| {} And
好的，我知道了。|还有一个关于 sleep 的问题，

2278
01:10:58,820 --> 01:11:00,380
0,270 270,360 360,750 750,1170 1200,1560
rather the question was for

2279
01:11:00,380 --> 01:11:03,650
0,780 1800,2310 2310,2550 2550,2640 2640,3270
sleep,| how does it know
|它怎么知道让 shell 睡觉，

2280
01:11:03,830 --> 01:11:05,020
0,660
to

2281
01:11:05,020 --> 01:11:07,630
0,450 480,1140 1170,1410 1410,2010 2040,2610
{} make the shell sleep,|
|

2282
01:11:07,690 --> 01:11:09,640
0,660 810,1080 1080,1200 1200,1440 1440,1950
like what is written there
比如，那里写入的只有地址。

2283
01:11:09,940 --> 01:11:11,770
0,270 270,510 510,600 600,1380 1500,1830
is just the address of.|
|

2284
01:11:11,770 --> 01:11:17,560
0,1170 1200,2160 2190,3570 3570,4440 4980,5790
{} {Let,me}, basically the sleep
基本上， sleep 让当前运行的进程进入睡眠状态，

2285
01:11:17,590 --> 01:11:19,810
0,750 750,870 870,1290 1290,1680 1680,2220
puts the current process running

2286
01:11:20,300 --> 01:11:22,190
0,630 630,1290 1290,1470 1470,1560 1560,1890
{on,the} sleep, in a sleep

2287
01:11:22,190 --> 01:11:23,750
0,450 840,1080 1080,1260 1260,1470 1470,1560
state,| we'll talk about it
|我们下周会讨论它的很多细节。

2288
01:11:23,750 --> 01:11:25,250
0,540 810,1170 1170,1410 1410,1440 1440,1500
in next week or the

2289
01:11:25,250 --> 01:11:26,360
0,180 180,510 510,750 750,930 930,1110
week after a great amount

2290
01:11:26,360 --> 01:11:27,520
0,90 90,600
of detail.|
|

2291
01:11:27,520 --> 01:11:29,680
0,570 750,1320 1320,1470 1470,1830 1830,2160
{} And it passes in
它传入的是，正在等待的东西。

2292
01:11:29,680 --> 01:11:30,670
0,90 90,240 240,420 420,540 540,990
the thing that is waiting

2293
01:11:30,670 --> 01:11:31,660
0,450
for.|
|

2294
01:11:31,690 --> 01:11:33,040
0,510 510,780 780,840 840,990 990,1350
{} And in this case,|
在这种情况下，|

2295
01:11:33,040 --> 01:11:35,080
0,360 360,510 510,1020 1140,1950 1950,2040
that is the address, you
这个地址有一个 channel id ，

2296
01:11:35,080 --> 01:11:36,130
0,90 90,420 420,600 600,690 690,1050
know basically has a channel

2297
01:11:36,130 --> 01:11:37,450
0,450 450,720 720,1020 1020,1230 1230,1320
id| or a way of
|或者一种与睡眠程序交互的方式。

2298
01:11:37,450 --> 01:11:39,250
0,600 600,750 750,1050 1050,1350 1350,1800
communicating from what actually sleeping

2299
01:11:39,250 --> 01:11:40,080
0,270
on.|
|

2300
01:11:40,260 --> 01:11:41,370
0,300 300,480 480,660 660,840 840,1110
And so in this case,
在本例中，[] 是 uart_tx_r 的地址。

2301
01:11:41,370 --> 01:11:43,230
0,120 120,1050 1050,1290 1290,1440 1440,1860
the [] is the address

2302
01:11:43,230 --> 01:11:45,660
0,270 270,690 690,1230 1320,1890
of {uart_tx_r - -}.|
|

2303
01:11:45,750 --> 01:11:49,710
0,750 930,1680 2100,2430 2430,3000 3300,3960
And, { -} and the
并且 start 函数，

2304
01:11:50,160 --> 01:11:52,230
0,510 510,1230 1440,1740 1740,1830 1830,2070
start function,| {} it wants
|它需要缓冲区中的空间，

2305
01:11:52,230 --> 01:11:53,880
0,120 120,600 600,960 960,1260 1260,1650
their space again in the

2306
01:11:53,910 --> 01:11:56,100
0,570 720,1500 1500,1710 1710,1920 1920,2190
buffer,| {} it will {wakeup
|它会唤醒，

2307
01:11:56,100 --> 01:11:57,080
0,420
-},|
|

2308
01:11:57,380 --> 01:11:58,670
0,120 120,330 330,390 390,960 960,1290
{} call the corresponding call
使用对应的 wakeup 以及 urat_tx_r ，

2309
01:11:58,670 --> 01:11:59,930
0,240 240,390 390,540 540,630 630,1260
{wakeup -} with the {uart_tx_r

2310
01:11:59,930 --> 01:12:01,430
0,570 570,690 690,1110 1110,1320 1320,1500
-}| to indicate that any
|表示睡眠在这个地址的任何进程都应该唤醒。

2311
01:12:01,430 --> 01:12:02,840
0,420 420,600 600,870 870,1290 1290,1410
process that actually sleeping on

2312
01:12:02,840 --> 01:12:04,340
0,150 150,750 780,1080 1080,1170 1170,1500
this address should be woken

2313
01:12:04,340 --> 01:12:05,140
0,300
up.|
|

2314
01:12:07,190 --> 01:12:08,690
0,270 270,420 420,630 630,1020 1020,1500
And how does exactly implemented
具体是如何实现的，我们稍后会看到。

2315
01:12:08,690 --> 01:12:09,830
0,90 90,330 330,480 480,630 630,1140
is something that we'll see

2316
01:12:09,830 --> 01:12:11,200
0,120 120,300 300,390 390,810
a little bit later.|
|

2317
01:12:13,680 --> 01:12:14,940
0,150 150,210 210,360 360,630 1110,1260
So, it makes sense.| So
这能理解吗。|所以，这两个调用是相互的， sleep 和 wakeup ，

2318
01:12:14,940 --> 01:12:16,410
0,630 630,780 780,1050 1050,1170 1170,1470
these two calls go together,

2319
01:12:16,410 --> 01:12:17,900
0,270 270,360 360,570 570,870
sleep and {wakeup -},|
|

2320
01:12:21,470 --> 01:12:24,060
0,510 510,750 750,1200 1200,2040
sometimes called conditional synchronization.|
有时称为条件同步。|

2321
01:12:27,440 --> 01:12:28,960
0,240 240,390 390,930
Any other questions?|
还有其他问题吗？|

2322
01:12:35,990 --> 01:12:37,080
0,570
Okay.|
好的。|

2323
01:12:37,590 --> 01:12:39,160
0,330 360,990
Good. {}|
很好。|

2324
01:12:39,530 --> 01:12:42,140
0,330 330,1140 1200,1590 1590,2010 2010,2610
Let's {}, let's see {}.|
让我们看看。|

2325
01:12:43,100 --> 01:12:45,440
0,630 750,1050 1050,1230 1230,1980 2220,2340
{} {So,that} there's basically the
所以，这就是打印 $ 的全部故事，

2326
01:12:45,440 --> 01:12:47,930
0,240 240,960 960,960 960,2100 2130,2490
whole story {} for printing

2327
01:12:47,930 --> 01:12:48,950
0,540 540,720 720,840 840,930 930,1020
$| and as you can
|正如你所看到的，它涉及到很多部分，

2328
01:12:48,950 --> 01:12:50,690
0,180 180,360 360,600 600,1110 1110,1740
see it's actually quite involved

2329
01:12:50,750 --> 01:12:53,690
0,570 900,1380 1380,1590 1620,2280 2280,2940
a lot of pieces| that
|（这些部分）一起将 $ 发送到 console 。

2330
01:12:53,750 --> 01:12:54,950
0,240 240,510 510,810 810,930 930,1200
{you,know} working together to actually

2331
01:12:54,950 --> 01:12:56,120
0,180 180,300 300,660 660,1020 1020,1170
get this $ out to

2332
01:12:56,120 --> 01:12:57,320
0,240 240,750
the console.|
|

2333
01:12:57,710 --> 01:12:59,090
0,330 330,450 450,720 720,1050 1050,1380
{} And something similar basically
类似的事情也发生在读取端，

2334
01:12:59,090 --> 01:13:02,450
0,390 390,1080 1470,2190 2640,3090 3090,3360
happens on the read side,|
|

2335
01:13:02,450 --> 01:13:03,440
0,180 180,270 270,420 420,690 690,990
so at some point shell
在某个时候， shell 打印 $ 和空格，

2336
01:13:03,440 --> 01:13:06,530
0,150 150,660 780,1770 1800,2460 2490,3090
has printed the both the

2337
01:13:06,560 --> 01:13:08,690
0,480 480,780 780,1380 1410,1650 1650,2130
$ and the white space,|
|

2338
01:13:08,690 --> 01:13:10,940
0,120 120,360 360,900 1230,1740 1740,2250
and then will {} {call,read}
然后调用 read 读取来自键盘的输入，

2339
01:13:10,940 --> 01:13:12,680
0,150 150,480 480,750 750,1410 1440,1740
to basically read input from

2340
01:13:12,680 --> 01:13:14,060
0,90 90,600 900,1080 1080,1260 1260,1380
the keyboard,| so now we
|所以现在我们看看发生了什么，

2341
01:13:14,060 --> 01:13:16,010
0,210 210,300 300,870 1080,1380 1380,1950
wanted to see what happens,|
|

2342
01:13:16,070 --> 01:13:18,890
0,360 360,930 960,1440 1560,2100 2370,2820
{} when {} that happening,|
当它发生时，|

2343
01:13:18,890 --> 01:13:20,090
0,240 240,450 450,750 750,1110 1110,1200
so that starts basically in
这也是从 file 开始的。

2344
01:13:20,090 --> 01:13:21,920
0,120 120,450 480,870 930,1410 1410,1830
the {} with file again.|
|

2345
01:13:22,470 --> 01:13:23,610
0,150 150,300 300,630 630,1050 1050,1140
{} So now there's a
所以现在有一个读系统调用，

2346
01:13:23,610 --> 01:13:25,710
0,180 180,480 480,1020 1350,1830 1830,2100
read system call,| {} if
|如果从 console 上读，

2347
01:13:25,710 --> 01:13:26,970
0,330 330,420 420,690 720,1110 1110,1260
it's you know reading from

2348
01:13:26,970 --> 01:13:28,320
0,90 90,660 660,780 780,930 930,1350
the console,| it will calls,
|它会调用 fileread ，

2349
01:13:28,320 --> 01:13:30,140
0,450 450,930 960,1230
it will actually

2350
01:13:30,140 --> 01:13:31,280
0,120 120,390 390,660 660,780 780,1140
of course {fileread - -},|
|

2351
01:13:31,310 --> 01:13:33,420
0,450 870,1140 1140,1530
sorry not write.|
抱歉，不是 write 。|

2352
01:13:34,500 --> 01:13:36,660
0,750 750,1110 1110,1320 1320,1710 1740,2160
{} If it's the device
如果它是设备，在本例中是 console ，

2353
01:13:36,660 --> 01:13:37,410
0,210 210,270 270,420 420,690 690,750
which in this case, the

2354
01:13:37,410 --> 01:13:38,850
0,480 480,600 600,690 690,1200 1200,1440
case is a console,| then
|然后，我们调用该设备的读方法，

2355
01:13:38,850 --> 01:13:40,770
0,120 120,390 390,510 510,990 1140,1920
we call the read method

2356
01:13:40,800 --> 01:13:42,320
0,210 210,390 390,1110
for that device,|
|

2357
01:13:42,320 --> 01:13:43,670
0,210 210,510 510,720 720,960 960,1350
and that is in {console.c
这在 console.c 中，

2358
01:13:43,670 --> 01:13:45,110
0,270 270,840 840,1110 1110,1320 1320,1440
- -}| and so we're
|所以，我们调用 consoleread 。

2359
01:13:45,110 --> 01:13:46,790
0,480 480,630 630,1020 1020,1470 1500,1680
going to, {consoleread -} is

2360
01:13:46,790 --> 01:13:48,060
0,180 180,690
being called.|
|

2361
01:13:48,060 --> 01:13:49,180
0,660

2362
01:13:49,330 --> 01:13:50,110
0,150 150,480 480,570 570,720 720,780
And basically it has the
基本上它与 UART 有相同的结构，

2363
01:13:50,110 --> 01:13:52,150
0,210 210,720 720,1230 1260,1860 1860,2040
same structure as {uart -},|
|

2364
01:13:52,150 --> 01:13:53,110
0,210 210,330 330,540 540,570 570,960
you know there's a circular
在顶部有一个环形缓冲区。

2365
01:13:53,110 --> 01:13:54,180
0,570
buffer

2366
01:13:54,630 --> 01:13:56,000
0,270 270,330 330,840
on the top.|
|

2367
01:13:56,700 --> 01:13:58,650
0,540 990,1260 1260,1350 1350,1740 1770,1950
{} Here it is, it's
这就是它， INPUT_BUF ，有 128 个字符，

2368
01:13:58,650 --> 01:13:59,760
0,90 90,360 360,900 900,1050 1050,1110
{} {INPUT_BUF -} [] the

2369
01:13:59,760 --> 01:14:01,890
0,390 390,960 990,1230 1230,1500 1740,2130
128 characters in it| and
|基本上是相同的游戏，

2370
01:14:01,890 --> 01:14:02,910
0,300 300,390 390,450 450,660 660,1020
basically it's the same game,|
|

2371
01:14:02,940 --> 01:14:05,220
0,330 330,660 660,1140 1140,1830 2010,2280
its producer consumer parallelism,| but
是生产者-消费者并行性，|但是，在这种情况下， shell 是消费者，

2372
01:14:05,220 --> 01:14:06,330
0,60 60,240 240,690 690,810 810,1110
in this case, the shell

2373
01:14:06,330 --> 01:14:07,920
0,120 120,390 390,930 930,1230 1230,1590
is the consumer, right,| it
|它从缓冲区中读取字符。

2374
01:14:07,920 --> 01:14:09,300
0,330 330,390 390,990 990,1140 1140,1380
actually is reading you know

2375
01:14:09,300 --> 01:14:11,550
0,270 270,660 660,1080 1080,1740 1740,2250
{} characters off the buffer.|
|

2376
01:14:12,040 --> 01:14:13,420
0,600 600,720 720,1170 1170,1290 1290,1380
And the keyboard is the
键盘是生产者，

2377
01:14:13,420 --> 01:14:14,800
0,510 510,720 720,930 930,990 990,1380
producer,| it takes the characters
|它将字符放入缓冲区。

2378
01:14:14,800 --> 01:14:17,100
0,420 420,1260 1290,1740
into the buffer.|
|

2379
01:14:17,250 --> 01:14:18,840
0,330 330,900 1200,1320 1320,1410 1410,1590
And so you know, let's
所以，让我们回到 consoleread ，

2380
01:14:18,840 --> 01:14:20,280
0,150 150,390 390,480 480,870 870,1440
go back to {consoleread -},|
|

2381
01:14:20,310 --> 01:14:22,740
0,840 1290,1560 1560,1740 1740,2190 2190,2430
{} if there's nothing,| if
如果什么都没有，|如果读指针，读索引和写索引相同，

2382
01:14:22,740 --> 01:14:24,570
0,450 630,990 990,1560 1590,1770 1770,1830
the read pointer where to

2383
01:14:24,570 --> 01:14:26,040
0,210 210,660 660,870 870,1080 1080,1470
read index and write index

2384
01:14:26,040 --> 01:14:27,060
0,180 180,270 270,810 810,900 900,1020
are the same,| you know
|缓冲区是空的，

2385
01:14:27,060 --> 01:14:29,130
0,390 390,660 660,780 780,1380 1590,2070
the buffer is empty| and
|它又回到睡眠状态。

2386
01:14:29,130 --> 01:14:30,090
0,120 120,360 360,660 660,750 750,960
it goes back to sleep

2387
01:14:30,090 --> 01:14:30,900
0,330
again.|
|

2388
01:14:31,320 --> 01:14:33,480
0,270 270,780 810,1470 1500,1800 1800,2160
And so, {} so after
所以，在打印 $ 之后，

2389
01:14:33,480 --> 01:14:35,340
0,150 150,480 480,1170 1170,1350 1350,1860
it's printed dollar {[] -},|
|

2390
01:14:35,520 --> 01:14:37,680
0,720 720,1290 1320,1650 1650,1950 1950,2160
the shell is go to
shell 会去睡眠，

2391
01:14:37,680 --> 01:14:40,650
0,510 840,1620 1620,2010 2370,2820 2820,2970
sleep,| { -} kernel put
|内核将 shell 置于睡眠状态，直到字符进入。

2392
01:14:40,650 --> 01:14:43,560
0,90 90,390 390,900 1080,2610 2730,2910
the shell sleep until {}

2393
01:14:43,560 --> 01:14:44,860
0,330 330,540 540,780
character comes in.|
|

2394
01:14:45,440 --> 01:14:46,520
0,180 180,360 360,450 450,600 600,1080
And so at some point,
在某一时刻，用户输入 l ，

2395
01:14:46,670 --> 01:14:48,590
0,510 510,780 780,1320 1320,1620 1620,1920
let's say {} user types

2396
01:14:48,590 --> 01:14:50,180
0,150 150,690 1080,1290 1290,1440 1440,1590
in l,| you know the
|ls 的第一个字符，

2397
01:14:50,180 --> 01:14:51,620
0,240 240,540 540,660 660,1140 1140,1440
first character from ls on

2398
01:14:51,620 --> 01:14:53,660
0,60 60,750 1080,1560 1560,1890 1890,2040
the keyboard,| {} that will
|这将导致 l 发送到电路板上的 UART 芯片，

2399
01:14:53,660 --> 01:14:55,700
0,660 660,750 750,1530 1620,1800 1800,2040
calls, you know, the l

2400
01:14:55,700 --> 01:14:56,990
0,120 120,240 240,690 720,1140 1140,1290
to be sent into the

2401
01:14:56,990 --> 01:15:00,110
0,600 1380,1740 1740,2100 2100,2370 2370,3120
uart chip on the {on,the,board},|
|

2402
01:15:00,530 --> 01:15:02,360
0,300 300,900 900,1320 1320,1470 1470,1830
{} that will be round
它将通过 PLIC 到某个核心，

2403
01:15:02,360 --> 01:15:03,680
0,180 180,300 300,780 870,1080 1080,1320
through the plic to some

2404
01:15:03,680 --> 01:15:04,790
0,420 420,600 600,810 810,930 930,1110
core,| that core will take
|核心将接受中断，到 devintr ，

2405
01:15:04,790 --> 01:15:06,080
0,120 120,660 780,1050 1050,1140 1140,1290
the interrupt that will go

2406
01:15:06,080 --> 01:15:07,310
0,300 300,630 630,780 780,1140 1140,1230
to {devintr - -},| the
|devintr ，我们会看到 UART 中断是如何进行的，

2407
01:15:07,310 --> 01:15:08,300
0,210 210,360 360,660 660,810 810,990
{devintr - -} we'll see

2408
01:15:08,300 --> 01:15:09,140
0,180 180,330 330,480 480,630 630,840
how that goes {uart -}

2409
01:15:09,140 --> 01:15:10,970
0,510 810,990 990,1080 1080,1200 1200,1830
interrupt| and it will call
|它将调用我们刚才看到的函数。

2410
01:15:11,210 --> 01:15:13,610
0,750 990,1410 1410,1530 1530,1890 2100,2400
the function that we looked

2411
01:15:13,610 --> 01:15:14,900
0,90 90,150 150,420 420,1020
at a second ago.|

2412
01:15:15,020 --> 01:15:15,980
0,360 360,510 510,690 690,870 870,960
{} It goes back to
它会回到底部，

2413
01:15:15,980 --> 01:15:17,570
0,270 270,840 870,1170 1170,1260 1260,1590
the bottom,| where I got
|我自己迷惑了一下的地方，

2414
01:15:17,570 --> 01:15:19,190
0,390 390,1050 1050,1170 1170,1230 1230,1620
confused myself for a second,|
|

2415
01:15:19,700 --> 01:15:21,410
0,660 720,900 900,1050 1050,1560 1560,1710
so in this case, you
所以在这种情况下，它会写，

2416
01:15:21,410 --> 01:15:22,940
0,240 240,420 420,690 690,1140 1200,1530
know it will write,| {it,will}
|它会从 UART 设备获取字符，

2417
01:15:22,940 --> 01:15:23,900
0,180 180,240 240,630 630,870 870,960
get a character from the

2418
01:15:23,900 --> 01:15:25,460
0,480 480,750 750,960 960,1350 1350,1560
device from uart device| that
|获得字符 l ，

2419
01:15:25,460 --> 01:15:26,630
0,90 90,240 240,300 300,690 690,1170
will get the character l|
|

2420
01:15:26,870 --> 01:15:28,310
0,150 150,270 270,630 630,870 870,1440
and will call the {consoleintr
使用字符 l 调用 consoleintr 函数，

2421
01:15:28,310 --> 01:15:30,770
0,600 600,1170 1380,1890 1890,2100 2100,2460
-} function using the character

2422
01:15:30,770 --> 01:15:31,880
0,480 600,780 780,900 900,990 990,1110
l,| so we can go
|这样我们就可以回到 console 。

2423
01:15:31,880 --> 01:15:33,640
0,390 390,720 720,1350
back to console.|
|

2424
01:15:36,100 --> 01:15:38,470
0,450 450,750 750,900 900,1500 1500,2370
And {consoleintr - -} does
consoleintr 得到那个字符，

2425
01:15:38,530 --> 01:15:40,150
0,390 390,480 480,960 960,1320 1350,1620
gets the character,| so now
|所以现在我们有一个 l ，

2426
01:15:40,150 --> 01:15:42,070
0,90 90,180 180,270 270,810 1140,1920
we have an l {},|
|

2427
01:15:42,070 --> 01:15:43,660
0,210 210,270 270,690 690,1260 1470,1590
it's a control P, you
它是控制 P ，打印进程列表，

2428
01:15:43,660 --> 01:15:45,340
0,180 180,480 480,900 900,1410 1500,1680
know actually printing list, in

2429
01:15:45,340 --> 01:15:47,440
0,90 90,480 480,990 1440,1650 1650,2100
the process list,| {} implements
|实现控制 H 和 控制 U ，

2430
01:15:47,440 --> 01:15:49,240
0,390 390,660 660,780 780,1350 1350,1800
control H and control U,|
|

2431
01:15:49,300 --> 01:15:50,590
0,210 210,390 390,570 570,780 780,1290
{} to do {backspace -}
用来回退和控制别的东西。

2432
01:15:50,590 --> 01:15:52,320
0,240 240,720 720,1290
and control whatever.|
|

2433
01:15:52,320 --> 01:15:53,250
0,270 270,450 450,540 540,720 720,930
{} But in all other
但是，在所有其他情况下，

2434
01:15:53,250 --> 01:15:55,170
0,600 630,1140 1140,1290 1290,1380 1380,1920
cases,| basically what it does,|
|基本上所做的是，|

2435
01:15:55,440 --> 01:15:57,270
0,240 240,630 630,1050 1080,1440 1440,1830
it echoes the character back
通过将字符打印到 console 将其回显给用户。

2436
01:15:57,270 --> 01:15:58,740
0,120 120,240 240,690 690,1200 1200,1470
to the user by printing

2437
01:15:58,740 --> 01:16:00,180
0,120 120,240 240,300 300,930
it to the console.|
|

2438
01:16:00,300 --> 01:16:01,920
0,570 570,750 750,1140 1140,1320 1320,1620
{} And then it basically
然后它将字符放入缓冲区，

2439
01:16:01,920 --> 01:16:03,450
0,330 330,660 660,1080 1080,1410 1410,1530
sticks the character into the

2440
01:16:03,450 --> 01:16:05,610
0,540 810,1080 1080,1230 1230,1500 1500,2160
buffer,| {} so that {}
|并唤醒等待缓冲区的进程，

2441
01:16:05,610 --> 01:16:07,170
0,360 390,840 840,1200 1290,1440 1440,1560
and {wakeup -} you know

2442
01:16:07,170 --> 01:16:08,700
0,120 120,540 540,750 750,1380 1380,1530
the process that's waiting for

2443
01:16:08,700 --> 01:16:09,810
0,120 120,630 690,900 900,1050 1050,1110
the buffer,| if there's a
|如果有进程在等待。

2444
01:16:09,810 --> 01:16:11,100
0,330 330,780
process waiting.|
|

2445
01:16:11,190 --> 01:16:12,540
0,330 660,810 810,930 930,1140 1140,1350
{} If it has hit
如果它达到换行，并且有进程等待，

2446
01:16:12,540 --> 01:16:13,980
0,180 180,780 1020,1230 1230,1380 1380,1440
{newline -} and there's a

2447
01:16:13,980 --> 01:16:15,300
0,330 330,780 780,960 960,1080 1080,1320
process waiting,| it will wake
|它会唤醒等待进程，

2448
01:16:15,300 --> 01:16:17,460
0,180 180,630 660,1050 1050,1710 1980,2160
up the waiting process,| and
|然后等待进程将从缓冲区中读取字符。

2449
01:16:17,460 --> 01:16:18,540
0,150 150,240 240,540 540,870 870,1080
then the waiting process will

2450
01:16:18,540 --> 01:16:19,680
0,390 390,450 450,570 570,690 690,1140
read you know the characters

2451
01:16:19,680 --> 01:16:20,820
0,150 150,240 240,330 330,690
out of the buffer.|
|

2452
01:16:22,520 --> 01:16:23,660
0,330 330,480 480,720 720,1050 1050,1140
Okay, so here again we
这里我们又看到了这种解耦，

2453
01:16:23,660 --> 01:16:25,100
0,150 150,330 330,600 600,690 690,1440
see this sort of decoupling|
|

2454
01:16:25,100 --> 01:16:27,140
0,420 420,930 990,1620 1620,1980 1980,2040
using a buffer between the
在生产者和消费者之间使用缓冲区，

2455
01:16:27,140 --> 01:16:28,460
0,510 510,630 630,720 720,1170 1170,1320
consumer and the producer,| so
|以便生产者消费者可以并行运行，

2456
01:16:28,460 --> 01:16:29,630
0,150 150,270 270,720 720,1050 1050,1170
that the producer consumer can

2457
01:16:29,690 --> 01:16:31,140
0,270 270,360 360,930
run in parallel,|
|

2458
01:16:31,140 --> 01:16:32,550
0,270 270,960 960,1170 1170,1260 1260,1410
{} independent each on their
以各自的速度独立运行，

2459
01:16:32,550 --> 01:16:33,900
0,150 150,660 990,1110 1110,1170 1170,1350
own speed,| and if one
|如果一个跑得很快，

2460
01:16:33,900 --> 01:16:35,250
0,180 180,390 390,1050 1110,1230 1230,1350
goes very fast,| you know
|无论缓冲区是空，还是满，

2461
01:16:35,250 --> 01:16:36,600
0,570 570,840 840,960 960,1110 1110,1350
either buffer will be empty

2462
01:16:36,600 --> 01:16:38,130
0,90 90,570 570,660 660,930 930,1530
or full,| and then block
|就阻塞并等待对方追赶上来。

2463
01:16:38,190 --> 01:16:39,450
0,540 540,810 810,900 900,1050 1050,1260
wait until the other guy

2464
01:16:39,450 --> 01:16:40,460
0,210 210,540
catch up.|
|

2465
01:16:43,380 --> 01:16:45,060
0,180 180,510 510,720 720,1050
Any questions about this?|
这个，有什么问题吗？|

2466
01:16:55,150 --> 01:16:56,340
0,150 150,660
Okay {}.|
好的。|

2467
01:16:57,370 --> 01:16:58,560
0,690

2468
01:16:58,750 --> 01:17:00,580
0,300 300,930 960,1230 1230,1590 1590,1830
Okay, {I,wanna} talk basically about
好的，我想再谈一件事。

2469
01:17:00,580 --> 01:17:02,180
0,270 270,480 480,990
one more thing.|
|

2470
01:17:02,730 --> 01:17:04,180
0,900

2471
01:17:04,760 --> 01:17:06,300
0,210 210,1050
In {that,is}.|
那就是。|

2472
01:17:06,650 --> 01:17:08,100
0,900

2473
01:17:09,440 --> 01:17:10,490
0,150 150,270 270,390 390,780 780,1050
You know I'm mostly talking
我主要谈论中断的发展，

2474
01:17:10,490 --> 01:17:12,200
0,900 930,1290 1290,1410 1410,1590 1590,1710
a little bit about sort

2475
01:17:12,200 --> 01:17:14,060
0,60 60,720 750,1410 1440,1680 1680,1860
of interrupt evolution,| like what
|比如，过去几十年发生的事情。

2476
01:17:14,060 --> 01:17:15,230
0,240 240,570 570,750 750,840 840,1170
has happened over the last

2477
01:17:15,230 --> 01:17:16,700
0,630
decades.|
|

2478
01:17:23,610 --> 01:17:25,020
0,720

2479
01:17:25,230 --> 01:17:27,570
0,420 420,1170 1650,1800 1800,2280 2280,2340
So {} the {interrupts,used} to
所以，对于处理器来说，中断曾经是相当快的，

2480
01:17:27,570 --> 01:17:29,100
0,210 210,930 930,1110 1110,1200 1200,1530
be relative to {} processor

2481
01:17:29,100 --> 01:17:30,660
0,390 390,990
reasonable fast,|
|

2482
01:17:31,420 --> 01:17:33,220
0,180 180,780 780,900 900,1200
in particular {in,the},| {used,to,be}
特别是在，|曾经很快。

2483
01:17:36,390 --> 01:17:37,940
0,960
fast.|
|

2484
01:17:38,120 --> 01:17:39,590
0,210 210,540 600,960 960,1050 1050,1470
So in times the original
所以，在最初的 Unix 被开发的时候，

2485
01:17:39,590 --> 01:17:41,690
0,240 240,330 330,990 1440,1980 1980,2100
Unix was developed,| {} you
|就是这种情况，

2486
01:17:41,690 --> 01:17:42,710
0,90 90,240 240,390 390,450 450,1020
know that was the case|
|

2487
01:17:42,980 --> 01:17:44,240
0,300 300,420 420,720 720,1170 1170,1260
and that basically meant that
意味着硬件非常简单。

2488
01:17:44,240 --> 01:17:45,380
0,60 60,360 360,420 420,660 660,1140
the hardware is very simple.|
|

2489
01:17:46,310 --> 01:17:48,620
0,510 510,840 840,1530 1860,2070 2070,2310
{} Because {you,know} if any
因为，如果有什么重要的工作要做，

2490
01:17:48,620 --> 01:17:49,820
0,330 330,750 750,1020 1020,1140 1140,1200
really serious work needs to

2491
01:17:49,820 --> 01:17:50,990
0,120 120,540 660,990 990,1050 1050,1170
be done,| [] we could
|我们可以直接中断处理器，

2492
01:17:50,990 --> 01:17:53,150
0,150 150,480 480,570 570,1170 1440,2160
just interrupt the processor| and
|处理器会做这些工作，

2493
01:17:53,150 --> 01:17:53,840
0,90 90,390 390,480 480,600 600,690
the processor would do it

2494
01:17:53,840 --> 01:17:55,580
0,120 120,210 210,660 660,1290 1290,1740
on the work| and so
|所以硬件本身是非常直接的。

2495
01:17:55,580 --> 01:17:57,560
0,540 720,1320 1320,1710 1710,1830 1830,1980
{} hardware itself could be

2496
01:17:57,560 --> 01:17:59,240
0,540 540,810 810,1200
reasonable straight forward.|
|

2497
01:17:59,850 --> 01:18:03,120
0,930 960,1560 1560,1950 1950,2760
Now, interrupts are slow
现在，与处理器相比，中断比较慢，

2498
01:18:03,370 --> 01:18:05,680
0,480 480,570 570,660 660,1230 1590,2310
compared to the processor,| you
|你可以看到，

2499
01:18:05,680 --> 01:18:06,580
0,120 120,270 270,570 570,690 690,900
can see that right,| because
|因为中断处理程序需要保存寄存器，

2500
01:18:06,580 --> 01:18:08,320
0,120 120,390 390,1140 1200,1650 1650,1740
the interrupt handler, {} it

2501
01:18:08,320 --> 01:18:09,160
0,180 180,240 240,540 540,690 690,840
needs to save {} to

2502
01:18:09,160 --> 01:18:10,840
0,600 600,900 930,1410 1410,1530 1530,1680
{registers -},| {} it needs
|它需要接受中断，

2503
01:18:10,840 --> 01:18:11,680
0,90 90,270 270,360 360,750 750,840
to take the interrupt,| so
|有几个预算指令，

2504
01:18:11,680 --> 01:18:12,940
0,150 150,210 210,600 600,660 660,1260
there's a couple you know

2505
01:18:15,160 --> 01:18:16,540
0,180 180,420 420,750 750,1260 1260,1380
a small budget instructions| that
|它们只用来服务于中断。

2506
01:18:16,540 --> 01:18:17,710
0,60 60,300 300,600 600,1020 1020,1170
are just being used to

2507
01:18:17,710 --> 01:18:19,260
0,270 270,570 570,660 660,1170
actually serve the interrupt.|
|

2508
01:18:19,460 --> 01:18:22,310
0,390 390,840 900,1470 1470,2160 2160,2850
And so {} if device
因此如果设备产生高速中断，

2509
01:18:22,310 --> 01:18:23,900
0,390 390,750 750,840 840,1470 1470,1590
generates interrupts the {high,speed},| you
|处理器很难跟上。

2510
01:18:23,900 --> 01:18:25,220
0,150 150,450 450,720 750,1200 1200,1320
know then the processor going

2511
01:18:25,220 --> 01:18:26,030
0,120 120,300 300,360 360,600 600,810
to have a tough time

2512
01:18:26,030 --> 01:18:27,140
0,270 270,600
keeping up.|
|

2513
01:18:27,500 --> 01:18:29,300
0,570 750,1290 1290,1560 1560,1710 1710,1800
And so you look at
所以，你看今天的设备，

2514
01:18:29,300 --> 01:18:31,550
0,480 480,1230 1260,1710 1710,1830 1830,2250
today's devices,| basically the hardware
|硬件或设备有更多的工作要做，

2515
01:18:31,550 --> 01:18:32,810
0,120 120,210 210,930 1050,1230 1230,1260
or the device there's a

2516
01:18:32,810 --> 01:18:34,180
0,180 180,330 330,810
lot more work,|
|

2517
01:18:39,400 --> 01:18:41,050
0,570 570,930 930,1050 1050,1380 1380,1650
{} and so basically there's
设备本身有很多工作要做，

2518
01:18:41,050 --> 01:18:42,130
0,150 150,420 420,570 570,840 840,1080
a bunch of work actually

2519
01:18:42,130 --> 01:18:43,870
0,210 210,300 300,660 660,1170 1170,1740
on the device itself,| before
|在实际生成中断之前。

2520
01:18:43,870 --> 01:18:45,640
0,240 240,690 690,780 780,1260
actually generating an interrupt.|
|

2521
01:18:45,940 --> 01:18:47,800
0,300 300,690 810,1410 1410,1650 1650,1860
And so, {} and just
所以，为了避免过多地中断处理器，

2522
01:18:47,800 --> 01:18:49,930
0,270 270,780 780,1410 1410,1710 1740,2130
to avoid interrupting the processor

2523
01:18:49,930 --> 01:18:51,060
0,150 150,660
too much,|
|

2524
01:18:51,350 --> 01:18:53,090
0,600 600,870 870,1110 1110,1560 1560,1740
now, if you really have
现在，如果你有一个高性能设备，

2525
01:18:53,090 --> 01:18:54,920
0,90 90,270 270,930 960,1230 1230,1830
a high performance {} device,|
|

2526
01:18:54,920 --> 01:18:56,030
0,180 180,360 360,450 450,570 570,1110
like say you have gigabytes
比如，你有千兆以太网，

2527
01:18:56,150 --> 01:18:57,460
0,630
gigabits

2528
01:18:58,530 --> 01:18:59,840
0,300 300,600
{Ethernet -},|
|

2529
01:19:01,000 --> 01:19:02,770
0,540 540,630 630,810 810,1260 1290,1770
and you know that card
这块网卡使用很多小包，

2530
01:19:02,770 --> 01:19:04,000
0,150 150,450 450,510 510,960 960,1230
is use a lot of

2531
01:19:04,000 --> 01:19:06,520
0,270 270,990 1020,1560 1830,2430 2430,2520
small packages packets,| then you
|那么网卡可以产生，

2532
01:19:06,520 --> 01:19:08,890
0,120 120,270 270,450 450,1290 1530,2370
know you can actually generate

2533
01:19:08,890 --> 01:19:10,480
0,270 270,510 510,1050 1050,1170 1170,1590
or Ethernet itself could generate|
|

2534
01:19:10,480 --> 01:19:11,710
0,210 210,510 510,960 990,1050 1050,1230
about one five or {1.5
大约每秒 150 万个包，

2535
01:19:11,710 --> 01:19:13,180
0,180 180,390 390,900 960,1350 1350,1470
- -} million packets per

2536
01:19:13,180 --> 01:19:14,140
0,420
second,|
|

2537
01:19:16,290 --> 01:19:17,340
0,420 420,540 540,810 810,900 900,1050
{} for minimum of like
对于最小的 64 字节以太网包，

2538
01:19:17,340 --> 01:19:19,110
0,450 450,1080 1080,1290 1290,1380 1380,1770
64 byte {Ethernet -} package,|
|

2539
01:19:19,110 --> 01:19:20,790
0,330 330,510 510,630 630,1320 1320,1680
you do a math roughly
你粗略计算一下，

2540
01:19:20,790 --> 01:19:22,320
0,270 270,540 540,960 960,1080 1080,1530
out to,| basically you generated
|每秒生成 150 万个包，你可以接收。

2541
01:19:22,320 --> 01:19:23,460
0,180 180,390 390,630 630,870 870,1140
{1.5 - -} million packets

2542
01:19:23,460 --> 01:19:24,360
0,60 60,570 570,630 630,780 780,900
per second you could {receive

2543
01:19:24,360 --> 01:19:25,320
0,450
-}.|
|

2544
01:19:25,440 --> 01:19:26,910
0,180 180,300 300,450 450,840 840,1470
And so that basically means
所以，这意味着如果你对每个包中断，

2545
01:19:26,940 --> 01:19:28,540
0,120 120,210 210,420 420,1170
you know one interrupt,

2546
01:19:30,280 --> 01:19:30,850
0,150 150,240 240,360 360,450 450,570
if you did it for

2547
01:19:30,850 --> 01:19:32,280
0,210 210,720
every packet,|
|

2548
01:19:32,280 --> 01:19:34,120
0,510 510,1200
per microsecond.|
那就是一微秒一个中断|

2549
01:19:37,330 --> 01:19:38,530
0,120 120,330 330,360 360,630 630,1200
In fact, a little more
事实上，略高于，

2550
01:19:38,560 --> 01:19:40,960
0,570 570,1830
than {},|
|

2551
01:19:40,960 --> 01:19:43,180
0,570 960,1410 1410,1710 1710,2010 2010,2220
a little less than,| a
略低于，|略高于，

2552
01:19:43,180 --> 01:19:44,290
0,240 240,360 360,570 570,780 780,1110
little bit more than {},|
|

2553
01:19:44,320 --> 01:19:46,120
0,240 240,690 690,960 1260,1710 1710,1800
so basically one way to
所以，考虑如果一微秒一个中断，

2554
01:19:46,120 --> 01:19:47,920
0,120 120,360 360,570 570,780 780,1800
think about if one interrupt

2555
01:19:47,920 --> 01:19:49,840
0,480 480,780 780,1170 1170,1260 1260,1920
microsecond,| there's basically the operations
|内核中的操作，

2556
01:19:49,840 --> 01:19:51,160
0,60 60,150 150,660 720,1200 1200,1320
in a kernel,| basically has
|有一微秒的预算指令来处理这个包，

2557
01:19:51,160 --> 01:19:52,600
0,120 120,540 540,780 780,930 930,1440
a budget of like one

2558
01:19:52,600 --> 01:19:54,520
0,600 600,1230 1230,1320 1320,1560 1560,1920
microsecond instructions to actually process

2559
01:19:54,520 --> 01:19:55,510
0,120 120,480 480,630 630,870 870,990
that packet,| in fact it's
|实际上是 150 万，

2560
01:19:55,510 --> 01:19:56,590
0,180 180,360 360,540 540,870 870,1080
{1.5 - -} million,| such
|这比一微秒的预算要少一点。

2561
01:19:56,590 --> 01:19:57,700
0,30 30,180 180,270 270,750 780,1110
a little bit less than

2562
01:19:57,700 --> 01:20:01,690
0,600 720,1200 1200,1650 2070,3060 3120,3990
a budget of a microsecond.|
|

2563
01:20:02,540 --> 01:20:03,560
0,210 210,390 390,480 480,870 870,1020
And you can compute how
你可以计算出有多少条指令，

2564
01:20:03,560 --> 01:20:05,300
0,240 240,720 720,870 870,1200 1380,1740
many instructions that is,| there's
|不会有那么多，

2565
01:20:05,300 --> 01:20:06,290
0,150 150,270 270,360 360,540 540,990
not gonna be that much|
|

2566
01:20:06,650 --> 01:20:08,810
0,240 240,1410 1470,1560 1560,1740 1740,2160
and so in that case,|
所以在这种情况下，|

2567
01:20:08,810 --> 01:20:10,430
0,1080 1110,1380 1380,1440 1440,1590 1590,1620
{you,know} {we,need} to have a
我们需要有一个不同的计划，

2568
01:20:10,430 --> 01:20:11,420
0,270 270,570 570,780 780,930 930,990
different plan,| so what do
|那么你怎么处理这些中断包，

2569
01:20:11,420 --> 01:20:12,710
0,120 120,420 420,840 840,960 960,1290
you do with the packets

2570
01:20:12,710 --> 01:20:14,210
0,120 120,210 210,540 540,930 1200,1500
or {} interrupt {you,know} packets|
|

2571
01:20:14,210 --> 01:20:15,350
0,30 30,240 240,330 330,600 600,1140
are coming in so fast
以超过处理器速度进来的包。

2572
01:20:15,560 --> 01:20:18,350
0,660 900,1680 1860,2370 2370,2550 2550,2790
that {} processor really can't

2573
01:20:18,350 --> 01:20:19,260
0,150 150,450
keep up.|
|

2574
01:20:19,550 --> 01:20:22,040
0,600 690,780 780,1140 1140,1620 1950,2490
And the solution to that
对于快速设备的解决方案是，

2575
01:20:22,040 --> 01:20:24,620
0,960 960,1080 1080,1710 1710,2040 2130,2580
is to {with -} fast

2576
01:20:24,620 --> 01:20:27,170
0,690 780,1350 1350,1740 1740,2340 2340,2550
{devices,is}| actually sometimes uses called
|有时称为轮询。

2577
01:20:27,170 --> 01:20:28,140
0,450
polling.|
|

2578
01:20:32,960 --> 01:20:35,990
0,720 750,1470 1860,2250 2250,2520 2520,3030
And {}, instead of writing
不是写入中断，

2579
01:20:35,990 --> 01:20:37,910
0,570 570,660 660,750 750,1170 1170,1920
interrupts,| you know what the
|CPU 也可以，

2580
01:20:37,940 --> 01:20:39,140
0,480 480,720 720,840 840,1020 1020,1200
CPU also could do is|
|

2581
01:20:39,140 --> 01:20:41,120
0,270 270,630 660,1380 1380,1590 1590,1980
just keep reading that control
只是读取控制寄存器，

2582
01:20:41,120 --> 01:20:42,380
0,630 660,840 840,930 930,1140 1140,1260
register| and to see if
|查看那里是否有一个字节，

2583
01:20:42,380 --> 01:20:43,340
0,150 150,240 240,480 480,780 780,960
there's a byte there,| like
|比如在 UART 寄存器中，

2584
01:20:43,340 --> 01:20:44,690
0,270 270,570 570,720 720,1140 1140,1350
in {uart -} register,| we
|我们只是不停读取 LHR 寄存器，

2585
01:20:44,690 --> 01:20:46,460
0,210 210,480 480,780 780,1080 1380,1770
just keep reading that {LHR

2586
01:20:46,460 --> 01:20:48,500
0,570 570,1200 1290,1530 1530,1710 1710,2040
-} register| and just check
|只是检查那里是否有一个字节。

2587
01:20:48,500 --> 01:20:49,580
0,150 150,360 360,390 390,660 660,1080
if there's a byte there.|
|

2588
01:20:50,150 --> 01:20:52,400
0,1110 1110,1290 1290,1530 1530,1710 1710,2250
{} In {} basically, would
说到底，这是 CPU 旋转，

2589
01:20:52,910 --> 01:20:54,020
0,180 180,270 270,420 420,570 570,1110
you know what this boils

2590
01:20:54,020 --> 01:20:54,830
0,240 240,330 330,420 420,720 720,810
down to is that the

2591
01:20:54,830 --> 01:20:56,800
0,540 540,690 690,1500
CPU {you,know} spins,|
|

2592
01:20:58,640 --> 01:21:00,200
0,990 990,1200 1200,1410 1410,1500 1500,1560
{} it spins on the
它在设备上旋转，

2593
01:21:00,200 --> 01:21:01,460
0,750
device,|
|

2594
01:21:01,490 --> 01:21:03,980
0,180 180,420 450,1080 1080,1920 2190,2490
you know until device has
直到设备有输入，有数据。

2595
01:21:03,980 --> 01:21:05,120
0,540
input,

2596
01:21:06,370 --> 01:21:07,620
0,270 270,660
has data.|
|

2597
01:21:08,940 --> 01:21:10,440
0,960

2598
01:21:10,590 --> 01:21:12,030
0,540 540,660 660,720 720,900 900,1440
And you know this waste
这会浪费 CPU 周期，

2599
01:21:12,060 --> 01:21:14,360
0,420 420,930 930,1170 1170,1710
CPU cycles right,| because
|因为我们一遍又一遍地检查那个寄存器，

2600
01:21:16,980 --> 01:21:19,260
0,630 630,1110 1200,1710 1710,1860 1860,2280
while we're checking that register

2601
01:21:19,260 --> 01:21:20,310
0,300 300,390 390,660 660,780 780,1050
over and over and over

2602
01:21:20,310 --> 01:21:21,510
0,450 570,780 780,930 930,1050 1050,1200
again| to see if they're
|看它是否是数据，

2603
01:21:21,510 --> 01:21:22,920
0,570 570,810 810,900 900,1110 1110,1410
actually any {data - -},|
|

2604
01:21:23,070 --> 01:21:24,780
0,630 630,840 840,1260 1260,1470 1470,1710
you know we're not using
我们没有使用这些周期来运行另一个应用程序，

2605
01:21:24,780 --> 01:21:25,890
0,180 180,540 540,630 630,810 810,1110
those cycles to run another

2606
01:21:25,890 --> 01:21:27,750
0,600 840,1140 1140,1440 1440,1560 1560,1860
application right| and you know
|我们之前看到的，

2607
01:21:28,200 --> 01:21:29,310
0,450 450,630 630,720 720,990 990,1110
before what you're seeing is

2608
01:21:29,310 --> 01:21:30,810
0,270 270,720 720,870 870,1080 1080,1500
that| if there's nothing there,
|如果没有任何东西，内核会让 shell 睡眠，

2609
01:21:30,900 --> 01:21:32,280
0,600 600,750 750,1050 1050,1260 1260,1380
basically the kernel push the

2610
01:21:32,280 --> 01:21:33,480
0,240 240,330 330,840 870,1110 1110,1200
shell to sleep,| so that
|以便另一个应用程序可以运行。

2611
01:21:33,480 --> 01:21:35,080
0,270 270,720 720,870 870,1200
another application could run.|
|

2612
01:21:35,080 --> 01:21:36,190
0,150 150,240 240,330 330,480 480,1110
But if we do polling,
但是如果我们做轮询，那就不会发生了，

2613
01:21:36,310 --> 01:21:39,250
0,1020 1140,1320 1320,1590 1590,1890 2310,2940
then that wouldn't happen {},|
|

2614
01:21:39,430 --> 01:21:41,080
0,480 480,630 630,660 660,930 930,1650
now for a slow device,|
现在，对于速度慢的设备，|

2615
01:21:41,170 --> 01:21:42,880
0,210 210,630 630,1170 1170,1320 1320,1710
you clearly want {you,know} not
你当然希望不是永远旋转，

2616
01:21:42,880 --> 01:21:45,100
0,300 300,870 870,1230 1530,1560 1560,2220
spin forever| until device finally
|直到设备来做它的工作，

2617
01:21:45,100 --> 01:21:46,210
0,180 180,600 600,690 690,900 900,1110
gets around to actually doing

2618
01:21:46,210 --> 01:21:48,160
0,150 150,600 960,1500 1500,1680 1680,1950
its work,| {} we really
|我们想从 shell 切换出去，

2619
01:21:48,160 --> 01:21:50,950
0,330 330,660 660,1350 1920,2430 2430,2790
like to {} basically switch

2620
01:21:50,950 --> 01:21:52,030
0,210 210,540 540,630 630,960 960,1080
out {} the shell| and
|并运行其他东西。

2621
01:21:52,030 --> 01:21:52,570
0,90 90,180 180,270 270,360 360,540
so that we can run

2622
01:21:52,570 --> 01:21:53,710
0,240 240,630 690,960 960,1050 1050,1140
something else.| But if the
|但如果设备速度非常快，

2623
01:21:53,710 --> 01:21:55,800
0,480 480,540 540,1170 1170,1710
device is extremely fast,|
|

2624
01:21:55,800 --> 01:21:57,300
0,450 450,780 780,870 870,1350 1350,1500
{} then the overhead of
则中断的开销很高，

2625
01:21:57,300 --> 01:21:59,070
0,480 540,900 900,1140 1140,1470 1470,1770
the interrupt features high| and
|我们最好还是轮询设备，

2626
01:21:59,070 --> 01:22:00,000
0,120 120,240 240,420 420,690 690,930
you know we're better off

2627
01:22:00,000 --> 01:22:01,890
0,360 360,810 810,1440 1470,1800 1800,1890
actually waiting basically polling the

2628
01:22:01,890 --> 01:22:03,600
0,420 420,690 690,960 960,1530 1530,1710
device,| because very quickly we're
|因为我们很快就会成功。

2629
01:22:03,600 --> 01:22:05,000
0,120 120,180 180,300 300,960
going to get success.|
|

2630
01:22:06,840 --> 01:22:08,250
0,330 330,600 600,1170 1170,1350 1350,1410
And so if, but so
但是，如果设备比较慢，又浪费 CPU 。

2631
01:22:08,250 --> 01:22:09,540
0,150 150,510 540,870 870,960 960,1290
if {} waste CPU, if

2632
01:22:09,540 --> 01:22:11,220
0,420 420,1050
device slow.|
|

2633
01:22:16,410 --> 01:22:18,660
0,330 330,810 1080,1290 1290,1620
{} But you know,
但是如果设备速度很快，

2634
01:22:23,260 --> 01:22:25,540
0,390 390,600 600,1020 1020,1620
but if devices fast,|
|

2635
01:22:29,990 --> 01:22:32,420
0,240 240,420 420,1050 1080,2010 2040,2430
{} it saves {} save
它节省了保存时间，

2636
01:22:32,420 --> 01:22:34,220
0,420 420,540 540,1020
saving or storing,|
|

2637
01:22:36,740 --> 01:22:38,330
0,210 210,420 420,480 480,720 720,1590
which saves the all entry
节省了 entry 和 exit 成本。

2638
01:22:38,330 --> 01:22:40,460
0,270 270,360 360,900 930,1620
entry and exit costs.|
|

2639
01:22:45,610 --> 01:22:46,690
0,390 390,510 510,690 690,780 780,1080
{} And so for example,
所以，比如高性能网卡，

2640
01:22:46,690 --> 01:22:48,640
0,150 150,1050 1050,1410 1410,1860 1860,1950
high performing network card,| you
|如果有一连串包进来，

2641
01:22:48,640 --> 01:22:50,710
0,150 150,630 630,780 780,1710 1740,2070
know, will you know if

2642
01:22:50,710 --> 01:22:51,670
0,120 120,240 240,540 540,600 600,960
it's a stream of packets

2643
01:22:51,670 --> 01:22:52,900
0,240 240,480 480,660 660,1020 1020,1230
coming in| and actually will
|将使用轮询。

2644
01:22:52,900 --> 01:22:54,180
0,180 180,750
use polling.|
|

2645
01:22:54,180 --> 01:22:55,650
0,540 540,660 660,810 810,1380 1380,1470
And you know more and
更多的复杂驱动，

2646
01:22:55,650 --> 01:22:57,750
0,60 60,240 240,750 750,1380 1560,2100
the most sophisticated drivers| basically
|它们会动态切换地在轮询和中断之间切换。

2647
01:22:57,750 --> 01:22:59,780
0,180 180,780 780,1410
they dynamically switch,

2648
01:23:02,730 --> 01:23:04,470
0,360 360,720 720,1080 1080,1200 1200,1740
switch between polling and interrupts.|
|

2649
01:23:14,520 --> 01:23:16,060
0,690

2650
01:23:18,170 --> 01:23:20,260
0,600 660,1500
Okay. {}|
好的。|

2651
01:23:20,930 --> 01:23:22,380
0,270 270,900
Any questions?|
有什么问题吗？|

2652
01:23:24,300 --> 01:23:26,250
0,330 330,420 420,1470 1500,1650 1650,1950
Close to my, my time
我的安排时间快到了。

2653
01:23:26,250 --> 01:23:27,540
0,330 330,420 420,780
budget is up.|
|

2654
01:23:29,180 --> 01:23:30,980
0,180 180,270 270,570 570,1260
Any your remaining questions?|
有什么剩下的问题吗？|

2655
01:23:35,170 --> 01:23:36,850
0,270 270,570 690,1140 1140,1530 1530,1680
Okay, good, {} then I'll
好的，那我们周三见，

2656
01:23:36,850 --> 01:23:37,720
0,120 120,210 210,270 270,750 750,870
see you on Wednesday| and
|在周三，我们将继续并发并行的故事，

2657
01:23:37,720 --> 01:23:38,770
0,360 360,720 720,870 870,990 990,1050
basically Wednesday, we're going to

2658
01:23:38,770 --> 01:23:40,870
0,390 390,540 540,1050 1050,1440 1440,2100
continue the story of concurrency

2659
01:23:41,560 --> 01:23:42,850
0,690 690,780 780,930 930,1110 1110,1290
parallelism,| we're gonna see some
|我们将看到一些机制管理并行，

2660
01:23:42,850 --> 01:23:44,680
0,840 840,1050 1050,1290 1290,1740 1740,1830
mechanisms to actually manage the

2661
01:23:44,680 --> 01:23:46,450
0,690 810,1050 1050,1230 1230,1590 1590,1770
parallelism| to make sure that
|确保共享数据结构正确获取它们的数据。

2662
01:23:46,450 --> 01:23:47,620
0,240 240,450 450,870 870,1050 1050,1170
shared data structures, get them

2663
01:23:47,620 --> 01:23:49,080
0,510 540,1020
data correctly.|

2664
01:23:49,380 --> 01:23:50,430
0,210 210,630 630,780 780,960 960,1050
{} So, {} see you
那么，周三见。

2665
01:23:50,430 --> 01:23:51,580
0,90 90,570
on Wednesday.|
|

2666
01:23:54,660 --> 01:23:56,220
0,300 300,750 750,1050 1050,1170 1170,1560
Oh, I'm sorry, I just
抱歉，我想找出我的问题在哪里，

2667
01:23:56,520 --> 01:23:57,480
0,150 150,270 270,510 510,630 630,960
I was trying to find

2668
01:23:57,480 --> 01:23:59,340
0,210 210,330 330,990 990,1530 1530,1860
where my question was,| because
|因为我把它弄丢了，

2669
01:23:59,340 --> 01:24:01,350
0,90 90,510 510,780 870,1500 1500,2010
I lost it,| my question
|我的问题是，

2670
01:24:01,350 --> 01:24:04,050
0,450 810,1080 1080,1650 1950,2340 2370,2700
was in the {},| so
|所以我看到 uartinit 只被调用了一次，

2671
01:24:04,050 --> 01:24:05,250
0,180 180,450 450,690 720,930 930,1200
I saw it, {uartinit -

2672
01:24:05,250 --> 01:24:06,630
0,120 120,390 390,570 570,930 930,1380
- -} is just being

2673
01:24:06,690 --> 01:24:09,330
0,660 780,1410 1410,1620 1620,1950 1950,2640
called once,| is that why
|这是为什么只有一个缓冲区供所有核心共享的原因吗？

2674
01:24:09,360 --> 01:24:12,690
0,420 420,870 960,1590 1620,2700 2760,3330
there's just one buffer for

2675
01:24:12,690 --> 01:24:14,000
0,450 450,900
all the

2676
01:24:14,030 --> 01:24:16,580
0,300 300,780 780,930 930,1560 1740,2550
{cores -} to share together.|
|

2677
01:24:18,970 --> 01:24:19,930
0,240 240,420 420,600 600,690 690,960
Well, there's always the only
好的，这里只有一个 UART 设备。

2678
01:24:19,930 --> 01:24:21,640
0,240 240,390 390,510 510,1230
one {uart -} device.|
|

2679
01:24:24,460 --> 01:24:26,770
0,270 270,930 930,2040 2040,2160 2160,2310
Buffer {} corresponds you know
缓冲区对应于 UART 设备，

2680
01:24:26,770 --> 01:24:28,690
0,270 270,750 750,1110 1110,1410 1410,1920
to the one uart device|
|

2681
01:24:28,690 --> 01:24:30,010
0,420 420,510 510,720 720,1050 1050,1320
actually is being shared between
实际上是由多个核心共享的。

2682
01:24:30,010 --> 01:24:31,300
0,210 210,750
{all,the} cores.|
|

2683
01:24:31,300 --> 01:24:32,620
0,750 750,870 870,990 990,1200 1200,1320
{} You know like it
它可能是在不同核心上运行的多个进程，

2684
01:24:32,620 --> 01:24:34,630
0,180 180,570 570,960 960,1530 1530,2010
might be {} multiple processes

2685
01:24:34,630 --> 01:24:35,740
0,300 300,390 390,660 660,930 930,1110
running on different cores,| all
|都在试图打印到控制台。

2686
01:24:35,740 --> 01:24:36,490
0,240 240,360 360,600 600,690 690,750
trying to print to the

2687
01:24:36,490 --> 01:24:37,540
0,570
console.|
|

2688
01:24:38,460 --> 01:24:40,440
0,690 720,960 960,1470 1500,1650 1650,1980
Okay I see,| oh yeah,
好的，我明白了，|是的，有道理。

2689
01:24:40,440 --> 01:24:42,640
0,240 240,750 960,1260 1260,1680
makes sense makes sense.|
|

2690
01:24:42,820 --> 01:24:44,770
0,540 540,840 870,1110 1110,1350 1350,1950
{} So like only one
所以，只有一个队列会使用 UART 执行任务。

2691
01:24:45,520 --> 01:24:47,950
0,480 480,870 1110,1410 1410,1980 1980,2430
queue will do stuff with

2692
01:24:47,950 --> 01:24:49,620
0,300 300,420 420,510 510,1140
uart to the time.|
|

2693
01:24:49,620 --> 01:24:51,270
0,810 810,1320 1320,1410 1410,1470 1470,1650
Yeah, well you know it's
是的，这有点复杂，

2694
01:24:51,270 --> 01:24:53,340
0,300 300,930 930,1590 1590,1770 1770,2070
slightly complicated,| but let's look,
|但是假设有多个人在写，

2695
01:24:53,340 --> 01:24:54,600
0,420 510,720 720,900 900,1050 1050,1260
like, so let's say there's

2696
01:24:54,600 --> 01:24:56,240
0,270 270,570 570,1080
multiple guys writing,|
|

2697
01:24:56,240 --> 01:24:57,800
0,180 180,570 570,1020 1020,1200 1200,1560
just afford {} as one
只需做一次实验就行了。

2698
01:24:57,800 --> 01:25:00,640
0,570 1320,2280
[experiment], correct.|
|

2699
01:25:01,460 --> 01:25:04,040
0,990 1260,2010
And {}
我们看到有多个，

2700
01:25:04,230 --> 01:25:05,670
0,240 240,600 600,750 750,1260 1260,1440
and what we see there

2701
01:25:05,670 --> 01:25:07,650
0,30 30,900 990,1200 1200,1350 1350,1980
are multiple,| let me actually.|
|让我。|

2702
01:25:08,290 --> 01:25:09,560
0,690

2703
01:25:11,630 --> 01:25:13,160
0,180 180,690 690,870 870,1170 1170,1530
So here {uartputc -} {},|
这里是 uartputc ，|

2704
01:25:13,160 --> 01:25:14,000
0,60 60,330 330,450 450,600 600,840
the first thing you see
你看到的第一件事是它需要一个锁。

2705
01:25:14,000 --> 01:25:15,260
0,90 90,480 480,630 630,900 900,1260
is actually it actually requires

2706
01:25:15,260 --> 01:25:16,340
0,60 60,600
a lock.|
|

2707
01:25:16,790 --> 01:25:19,040
0,240 240,420 420,780 780,1350 1830,2250
So the multiple cores are
多个核心正在将一个字符放入缓冲区，

2708
01:25:19,040 --> 01:25:20,240
0,330 330,570 570,720 720,750 750,1200
trying to put a character

2709
01:25:20,240 --> 01:25:22,010
0,330 330,600 600,1140 1410,1590 1590,1770
into the buffer| and one
|它们中的一个获得锁，

2710
01:25:22,010 --> 01:25:22,520
0,90 90,210 210,300 300,420 420,510
of them is going to

2711
01:25:22,520 --> 01:25:23,570
0,210 210,300 300,720 750,870 870,1050
get the lock| and none
|其他都不会获得锁，

2712
01:25:23,570 --> 01:25:24,290
0,60 60,150 150,390 390,480 480,720
of the others are going

2713
01:25:24,290 --> 01:25:25,760
0,90 90,540 900,1080 1080,1230 1230,1470
to lock,| so that one
|所以那个获得锁的 CPU ，

2714
01:25:25,760 --> 01:25:26,810
0,450 450,630 630,780 780,840 840,1050
guy you know the one

2715
01:25:26,810 --> 01:25:27,830
0,360 360,510 510,750 750,960 960,1020
CPU that actually got the

2716
01:25:27,830 --> 01:25:29,420
0,240 240,600 600,660 660,840 840,1590
lock, required to lock successfully,|
|

2717
01:25:29,660 --> 01:25:31,640
0,240 240,510 510,870 870,1410 1440,1980
{} is able to go
可以查看写指针，

2718
01:25:31,640 --> 01:25:33,080
0,360 630,1020 1020,1110 1110,1200 1200,1440
and look at the write

2719
01:25:33,080 --> 01:25:35,330
0,300 300,660 960,1530 1530,1830 1830,2250
pointer| and {} stick character
|把字符放入其中，

2720
01:25:35,330 --> 01:25:37,550
0,150 150,750 750,1470 1470,1830 1830,2220
in it possible| and otherwise
|否则去睡眠。

2721
01:25:37,550 --> 01:25:38,520
0,90 90,210 210,630
go to sleep.|
|

2722
01:25:38,850 --> 01:25:40,410
0,690 720,840 840,960 960,1290 1290,1560
And you know and then
如果它完成了，就可以解锁，

2723
01:25:40,410 --> 01:25:41,640
0,240 240,390 390,810 810,960 960,1230
if it's done, you know

2724
01:25:41,640 --> 01:25:44,370
0,510 510,1050 1080,1590 2010,2550 2550,2730
releases the lock,| {} and
|然后下一个核心可以进入，

2725
01:25:44,370 --> 01:25:45,510
0,210 210,300 300,810 840,990 990,1140
then the next you know

2726
01:25:45,510 --> 01:25:46,560
0,390 390,540 540,750 750,930 930,1050
core can go in| and
|获取锁并做它的工作。

2727
01:25:46,560 --> 01:25:47,880
0,630 660,810 810,1110 1110,1230 1230,1320
acquire the lock and do

2728
01:25:47,880 --> 01:25:48,880
0,210 210,570
its work.|
|

2729
01:25:48,910 --> 01:25:50,890
0,150 150,630 630,960 960,1110 1110,1980
So this lock will serialize
所以，这个锁会序列化对 UART 的并发访问。

2730
01:25:51,160 --> 01:25:54,340
0,930 960,1380 1380,2100 2820,3060 3060,3180
the concurrent accesses to the

2731
01:25:54,340 --> 01:25:55,340
0,480
uart.|
|

2732
01:25:58,400 --> 01:26:00,080
0,180 180,420 420,930 960,1320 1320,1680
That makes sense, yeah, thank
理解了，是的，谢谢。

2733
01:26:00,080 --> 01:26:01,100
0,480
you.|
|

2734
01:26:02,000 --> 01:26:03,620
0,660 660,870 870,1200 1200,1320 1320,1620
Well, on Wednesday, we'll talk
好的，星期三我们将详细讨论锁的问题。

2735
01:26:03,620 --> 01:26:05,200
0,150 150,450 450,630 630,1080
in detail about locks.|
|

2736
01:26:07,210 --> 01:26:08,680
0,450 450,900
Thank you.|
谢谢。|

2737
01:26:10,160 --> 01:26:11,780
0,240 240,480 480,1260
Any further questions?|
还有什么问题吗？|

2738
01:26:12,750 --> 01:26:15,270
0,270 270,390 390,450 450,1110 1980,2520
I have a question.| So,
我有个问题。|我知道我们要在中断使用锁，

2739
01:26:15,270 --> 01:26:16,580
0,780
{}

2740
01:26:16,760 --> 01:26:17,630
0,180 180,510 510,690 690,810 810,870
{} as far as I

2741
01:26:17,630 --> 01:26:19,220
0,570 570,870 870,1080 1080,1380 1380,1590
understand why we need the

2742
01:26:19,220 --> 01:26:21,080
0,360 360,720 720,810 810,1470 1470,1860
lock inside the interrupted,| because
|因为只有一个控制台，

2743
01:26:21,080 --> 01:26:22,910
0,480 510,870 870,1050 1050,1320 1320,1830
we there's only one console|
|

2744
01:26:22,910 --> 01:26:24,500
0,120 120,240 240,540 540,1080 1080,1590
and they could multiple cores,
而有多个核心。

2745
01:26:24,500 --> 01:26:25,540
0,420
right.|
|

2746
01:26:27,000 --> 01:26:28,290
0,210 210,540 540,750 750,1050 1050,1290
{} You mean the where
你是说哪里的锁。

2747
01:26:28,290 --> 01:26:29,940
0,180 180,510 510,900 1260,1650 1650,1650
{is,the} lock, where.| {} I
|我想是这样的，

2748
01:26:29,940 --> 01:26:32,370
0,690 690,1050 1050,1440 1470,1890 1890,2430
think so right,| because usually
|因为通常我们不想在中断内部使用锁。

2749
01:26:32,370 --> 01:26:33,180
0,90 90,210 210,390 390,480 480,810
we don't want to lock

2750
01:26:33,180 --> 01:26:36,000
0,300 300,660 660,1170 1170,1590 1620,2820
things inside interrupts right.| Yeah
|是的，你通过电子邮件问了这个问题。

2751
01:26:36,000 --> 01:26:36,810
0,180 180,330 330,450 450,690 690,810
you asked this question by

2752
01:26:36,810 --> 01:26:40,320
0,990 1020,2070 2370,2850 2850,3390 3390,3510
email.| Yeah.| Yes, well the
|是的。|是的，问题是，

2753
01:26:40,320 --> 01:26:41,760
0,420 420,690 690,960 960,1260 1320,1440
issue is,| that the as
|正如前面提到的，

2754
01:26:41,760 --> 01:26:44,010
0,300 300,990 1020,1350 1350,1710 1710,2250
mentioned earlier,| the bottom half
|底部的中断处理可以和顶部的并行运行。

2755
01:26:44,130 --> 01:26:45,270
0,390 390,630 630,870 870,1020 1020,1140
interrupt handler could run in

2756
01:26:45,270 --> 01:26:48,930
0,900 1140,1980 1980,2880 2910,3240 3240,3660
parallel with the top half.|
|

2757
01:26:49,480 --> 01:26:51,490
0,240 240,810 900,1290 1290,1590 1590,2010
And so {} one core
所以，一个核心可能正在执行 uartputc ，

2758
01:26:51,490 --> 01:26:52,780
0,390 390,510 510,750 750,960 960,1290
could be doing {uartputc -

2759
01:26:52,780 --> 01:26:54,610
0,720 930,1170 1170,1440 1440,1710 1710,1830
-}| and another core could
|而另一个核心可能正在运行 uartintr ，

2760
01:26:54,610 --> 01:26:55,840
0,210 210,720 720,900 900,1050 1050,1230
be running {uartintr - -

2761
01:26:55,840 --> 01:26:58,480
0,300 690,2130 2160,2460 2460,2520 2520,2640
-},| we got to make
|我们要确保它们在某种程度上，

2762
01:26:58,480 --> 01:26:59,440
0,210 210,360 360,510 510,690 690,960
sure that they sort of,|
|

2763
01:26:59,440 --> 01:27:00,910
0,570 600,810 810,1020 1020,1350 1350,1470
{} don't get tangled up
不会纠缠在一起，

2764
01:27:00,910 --> 01:27:02,140
0,480 510,630 630,750 750,960 960,1230
together,| that they {serialized -}
|让它们串行，

2765
01:27:02,140 --> 01:27:03,460
0,450 450,600 600,690 690,1020 1020,1320
correctly| and the lock basically
|锁确保了它们被序列化。

2766
01:27:03,460 --> 01:27:04,870
0,420 420,540 540,630 630,780 780,1410
ensures that they get serialized.|
|

2767
01:27:05,480 --> 01:27:07,700
0,450 480,870 870,1080 1080,1470 1470,2220
Okay, that makes sense,| but
好的，有道理，|但是否意味着有时候

2768
01:27:07,790 --> 01:27:09,800
0,240 240,720 1170,1590 1590,1830 1830,2010
{} that does mean that

2769
01:27:09,800 --> 01:27:11,780
0,630 630,960 990,1260 1260,1770 1770,1980
sometimes| like all cores could
|所有的核心都可能在等待

2770
01:27:11,780 --> 01:27:13,400
0,600 600,780 780,1200 1200,1380 1380,1620
potentially be waiting for| one
|其中的一个处理这件事。

2771
01:27:13,400 --> 01:27:14,750
0,120 120,330 330,480 480,840 840,1350
of them to be handling

2772
01:27:14,750 --> 01:27:16,460
0,270 270,660 840,1230
this, right.| Yeah.|
|是的。|

2773
01:27:17,150 --> 01:27:19,190
0,540 570,1200 1200,1350 1350,1860 1860,2040
Yeah, because the interrupt has
是，因为中断必须等待，

2774
01:27:19,190 --> 01:27:20,210
0,150 150,450 450,570 570,720 720,1020
to wait| and then nothing
|没有什么事情可以调度了。

2775
01:27:20,210 --> 01:27:22,880
0,240 240,660 660,900 900,1560 2010,2670
else can get scheduled. {}|
|

2776
01:27:22,880 --> 01:27:24,620
0,720 720,1110 1110,1260 1260,1440 1440,1740
Well, presumably some other process
一些其他进程可能在运行，

2777
01:27:24,620 --> 01:27:26,930
0,270 270,540 540,690 690,1530 1770,2310
maybe running,| it's unlikely, {}
|它不是，这不是死锁，

2778
01:27:26,960 --> 01:27:28,730
0,240 240,390 390,1110 1140,1590 1620,1770
there's no deadlock,| okay, there
|好的，有死锁的风险，但不是这个，

2779
01:27:28,730 --> 01:27:29,810
0,150 150,210 210,420 420,510 510,1080
is a risk of deadlock,

2780
01:27:29,810 --> 01:27:32,330
0,690 690,1230 1230,1380 1380,1740 1950,2520
but not this one,| that
|那个我们将在周三谈论。

2781
01:27:32,330 --> 01:27:33,530
0,120 120,300 300,510 510,600 600,1200
we'll talk about on Wednesday.|
|

2782
01:27:33,530 --> 01:27:34,520
0,570

2783
01:27:34,670 --> 01:27:37,580
0,750 1140,2340
But {}
但是，它的大概意思是，

2784
01:27:38,140 --> 01:27:39,490
0,240 240,600 630,990 990,1200 1200,1350
in the, presumably, what this

2785
01:27:39,490 --> 01:27:40,540
0,270 270,420 420,540 540,690 690,1050
means| like if there's multiple
|如果有多个调用 uartputc ，

2786
01:27:40,540 --> 01:27:43,680
0,480 1320,1860 1860,2610
guys called uartputc,|
|

2787
01:27:43,770 --> 01:27:45,540
0,150 150,240 240,570 570,1050 1410,1770
in the buffer full,| then
缓冲区已满，|然后在某个时刻，这个中断会释放锁。

2788
01:27:45,540 --> 01:27:46,950
0,180 180,360 360,480 480,1230 1230,1410
some point, this interrupt they

2789
01:27:46,950 --> 01:27:49,290
0,210 210,360 360,1140 1500,1860 1860,2340
actually will release the lock.|
|

2790
01:27:50,060 --> 01:27:52,040
0,690 720,960 960,1080 1080,1770 1770,1980
{} So, for example let's
让我们回到 uartputc ，

2791
01:27:52,040 --> 01:27:53,330
0,120 120,390 390,480 480,720 720,1290
go back to {uartputc -},|
|

2792
01:27:53,330 --> 01:27:54,590
0,270 270,450 450,630 630,990 990,1260
what actually what happened correct
实际上发生的事情是，

2793
01:27:54,590 --> 01:27:57,260
0,300 300,690 1080,1830 2250,2520 2520,2670
is that,| {} they will
|它们会调用 sleep ，

2794
01:27:57,260 --> 01:27:58,560
0,180 180,810
call sleep,|
|

2795
01:27:58,760 --> 01:27:59,750
0,180 180,480 480,690 690,930 930,990
and sleep actually takes the
而 sleep 使用那个锁作为参数，

2796
01:27:59,750 --> 01:28:01,310
0,360 360,450 450,1230 1260,1470 1470,1560
locks in argument| and we'll
|我们后面会知道为什么，

2797
01:28:01,310 --> 01:28:03,740
0,180 180,480 480,1020 1230,1740 1740,2430
see later why,| but internally
|但是在内部，在 sleep 将进程睡眠之前，

2798
01:28:03,740 --> 01:28:05,600
0,780 780,1140 1140,1530 1530,1770 1770,1860
before sleep actually puts the

2799
01:28:05,600 --> 01:28:06,830
0,360 360,720 720,810 810,1110 1110,1230
process definitely to sleep| and
|它会释放锁。

2800
01:28:06,830 --> 01:28:08,400
0,150 150,570 570,660 660,1080
will release the lock.|
|

2801
01:28:08,920 --> 01:28:10,360
0,450 450,540 540,750 750,930 930,1440
Oh, I see,| so basically
哦，我明白了，|所以是调用 sleep 带上锁参数，

2802
01:28:10,360 --> 01:28:11,440
0,120 120,360 360,780 780,930 930,1080
you call sleep with the

2803
01:28:11,440 --> 01:28:12,850
0,390 390,540 540,780 780,1080 1080,1410
lock| and then that means
|然后意味着可以在睡眠的时候释放锁，

2804
01:28:12,850 --> 01:28:14,050
0,270 270,660 660,750 750,1020 1020,1200
okay release the lock while

2805
01:28:14,050 --> 01:28:15,310
0,90 90,450 450,720 720,1050 1050,1260
you sleep,| so someone else
|让其他进程去做。

2806
01:28:15,310 --> 01:28:16,540
0,240 240,510
does it.|
|

2807
01:28:16,570 --> 01:28:18,580
0,630 660,1440
Okay interesting.|
好的，有意思。|

2808
01:28:18,810 --> 01:28:19,710
0,270 270,450 450,600 600,720 720,900
Yeah.| And then when you
是的。|然后，当从 sleep 返回，

2809
01:28:19,710 --> 01:28:21,240
0,480 480,720 720,1110 1110,1230 1230,1530
return from sleep,| you just
|再次获取，好的。

2810
01:28:21,270 --> 01:28:24,150
0,1050 1080,1650 1890,2100 2100,2340 2340,2880
reacquire, okay.| To {get,lock} back.|
|重新获得锁。|

2811
01:28:24,510 --> 01:28:27,630
0,720 750,1350 1410,2340 2340,2610 2610,3120
Right, right, yeah that {make,sence}.|
对，是的，有道理。|

2812
01:28:28,200 --> 01:28:29,010
0,240 240,330 330,570 570,750 750,810
And the sleep has a
sleep 也有单独的故事，

2813
01:28:29,010 --> 01:28:30,060
0,270 270,630 630,750 750,840 840,1050
seperate story,| that we'll talk
|我们将在一周或两周后讨论这个。

2814
01:28:30,060 --> 01:28:30,720
0,240 240,300 300,390 390,600 600,660
about in a week or

2815
01:28:30,720 --> 01:28:31,620
0,120 120,450
two weeks.|
|

2816
01:28:32,100 --> 01:28:33,240
0,150 150,330 330,600 600,810 810,1140
That makes sense, yeah yeah,|
有道理，是的，是的，|

2817
01:28:33,270 --> 01:28:36,390
0,840 1140,1650 1650,1890 1890,2400 2400,3120
{} so I guess, {}|
所以我想，|

2818
01:28:37,540 --> 01:28:39,040
0,450 450,780 780,990 990,1170 1170,1500
so I guess that wasn't
所以我想这对我来说不是很清楚，

2819
01:28:39,040 --> 01:28:40,240
0,270 270,540 540,600 600,960 960,1200
that clear to me {}|
|

2820
01:28:40,240 --> 01:28:42,790
0,300 300,810 960,1590 1590,1890 1890,2550
do all CPUs get interrupted,|
是不是所有的 CPU 都会被中断，|

2821
01:28:42,790 --> 01:28:44,470
0,240 240,750 750,1050 1050,1320 1320,1680
when somebody like send something
当有人通过 UART 发送东西的时候。

2822
01:28:44,470 --> 01:28:45,720
0,210 210,390 390,750
through {uart -}.|
|

2823
01:28:45,870 --> 01:28:48,570
0,720 720,1170 1170,1380 1380,2040 2100,2700
No, {} well depends,| it
不，要看情况，|这取决于你怎么对 PLIC 编程，

2824
01:28:48,570 --> 01:28:49,500
0,330 330,390 390,450 450,600 600,930
depends on how you program

2825
01:28:49,500 --> 01:28:52,620
0,90 90,570 960,2070 2100,2850 2850,3120
the plic,| the way {xv6
|xv6 对 PLIC 的编程方式是只有一个 CPU ，

2826
01:28:52,620 --> 01:28:53,640
0,270 270,600 600,690 690,900 900,1020
-} program the plic is

2827
01:28:53,640 --> 01:28:55,530
0,150 150,360 360,600 600,1380 1590,1890
that only one CPU,| all
|所有的 CPU 都可能被中断，但是。

2828
01:28:55,530 --> 01:28:57,620
0,390 390,600 600,720 720,1320
CPU might get interrupted,

2829
01:28:57,880 --> 01:28:59,350
0,360 360,750 750,1140 1170,1380 1380,1470
{} but.| Okay.| One is
|好的。|只有一个去处理中断。

2830
01:28:59,350 --> 01:29:01,090
0,120 120,180 180,960 1080,1230 1230,1740
going to clean the interrupt.|
|

2831
01:29:03,230 --> 01:29:04,320
0,630
Okay.|
好的。|

2832
01:29:04,540 --> 01:29:05,350
0,180 180,360 360,480 480,720 720,810
If you go back to
如果你回到 PLIC ，

2833
01:29:05,350 --> 01:29:06,130
0,90 90,420 420,510 510,600 600,780
the plic,| you know when
|当你获得中断，会调用 plic_claim ，

2834
01:29:06,130 --> 01:29:07,600
0,390 390,570 570,1170 1170,1290 1290,1470
you get interrupted, you call

2835
01:29:07,600 --> 01:29:10,000
0,180 180,420 420,1020 1050,1680 1920,2400
this {plic_claim -}| and {}
|那个 CPU 会得到，

2836
01:29:10,000 --> 01:29:12,070
0,630 630,1110 1110,1350 1350,1650 1650,2070
that CPU that particular core

2837
01:29:12,070 --> 01:29:13,820
0,150 150,330 330,630 630,1230
gonna get the {},|
|

2838
01:29:13,820 --> 01:29:14,960
0,630 630,750 750,870 870,960 960,1140
{} it's going to get
它会得到 IRQ ，

2839
01:29:14,960 --> 01:29:17,720
0,570 780,1020 1020,1740 2070,2430 2430,2760
the the IRQ| and then
|然后 PLIC 会记住，

2840
01:29:17,720 --> 01:29:19,820
0,390 390,510 510,900 900,1080 1080,2100
basically the plic will remember,|
|

2841
01:29:19,820 --> 01:29:20,870
0,210 210,600 600,660 660,840 840,1050
that IRQ is now being
那个 IRQ 正在处理，

2842
01:29:20,870 --> 01:29:21,860
0,390 390,480 480,750 750,900 900,990
served| and won't give it
|不会把它给其他任何人。

2843
01:29:21,860 --> 01:29:23,100
0,90 90,390 390,810
to anybody else.|
|

2844
01:29:24,720 --> 01:29:26,160
0,150 150,540 570,840 840,1200 1200,1440
I see, okay,| so just
我明白了，好的，|所以，它们中的一个会获得它，随机的还是别的。

2845
01:29:26,160 --> 01:29:27,180
0,180 180,270 270,450 450,780 780,1020
one of them will get

2846
01:29:27,180 --> 01:29:29,940
0,300 1020,1650 1650,1740 1740,2220
it randomly or no.|
|

2847
01:29:31,260 --> 01:29:32,790
0,270 270,810 810,1110 1110,1170 1170,1530
You can program to plic,|
你可以编程 PLIC ，|

2848
01:29:32,790 --> 01:29:34,860
0,210 210,450 450,1140 1170,1740 1740,2070
{you,know} say {} maybe program
比如编程到一个 CPU 。

2849
01:29:34,860 --> 01:29:37,980
0,930 930,1560 2190,2430 2430,2850 2850,3120
{to,one,CPU}.| {Oh,I,see}.| Plic.| {I,see}, {I,see},|
|我明白了。|PLIC。|我明白了，|

2850
01:29:37,980 --> 01:29:40,020
0,150 150,480 480,780 1050,1650 1650,2040
so inside the, yeah inside
所以在 PLIC 里面是相关的代码，

2851
01:29:40,020 --> 01:29:40,950
0,120 120,390 390,540 540,630 630,930
the plic is the code|
|

2852
01:29:40,950 --> 01:29:42,660
0,120 120,480 480,1020 1020,1140 1140,1710
that actually decides on who
来决定打扰谁。

2853
01:29:42,660 --> 01:29:43,880
0,90 90,750
to bother.|
|

2854
01:29:44,630 --> 01:29:46,130
0,360 390,510 510,570 570,990 1170,1500
Yeah, {the,plic} a [],| there's
是的， PLIC 是一个[]，|我想 PLIC 里面没有代码。

2855
01:29:46,130 --> 01:29:46,940
0,120 120,450 450,510 510,630 630,810
no code in the plic,

2856
01:29:46,940 --> 01:29:49,190
0,90 90,390 390,1530 1530,1770 1770,2250
I think.| Yeah right, okay,
|是啊，好的。

2857
01:29:49,370 --> 01:29:51,620
0,360 360,480 480,840 1290,1800 1800,2250
okay I was.| CPU program.|
|CPU 编程。|

2858
01:29:51,890 --> 01:29:53,040
0,120 120,540
I was,
我是，是的，好的。

2859
01:29:53,910 --> 01:29:56,320
0,570 780,1110 1110,1980
yeah great, okay.|
|

2860
01:29:57,360 --> 01:29:58,230
0,270 270,390 390,510 510,690 690,870
Yeah, I was just gonna
是的，我想说 PLIC 代码在哪里运行，

2861
01:29:58,230 --> 01:29:59,220
0,210 210,510 510,690 690,810 810,990
say where does the plic

2862
01:29:59,220 --> 01:30:00,450
0,300 300,630 630,840 840,1050 1050,1230
code run,| but yeah it's
|但是，是的，它不是代码，而是硬件，

2863
01:30:00,450 --> 01:30:01,710
0,210 210,480 480,660 660,990 990,1260
not code, it's hardware.| Okay
|好的，理解了。

2864
01:30:01,710 --> 01:30:03,750
0,120 120,300 300,750 1230,1590 1590,2040
that makes sense.| Alright, thanks,
|谢谢，星期三见。

2865
01:30:03,750 --> 01:30:05,130
0,570 570,690 690,750 750,840 840,1380
I'll see you on Wednesday.|
|

2866
01:30:06,290 --> 01:30:07,440
0,210 210,270 270,450
{Yeah - -}.|
好的。|

2867
01:30:07,440 --> 01:30:08,310
0,390 390,570 570,690 690,810 810,870
{} So I got a
我有个问题，

2868
01:30:08,310 --> 01:30:09,660
0,570 600,750 750,810 810,1140 1140,1350
question,| kind of related to
|与同时运行多个核心的想法有关。

2869
01:30:09,660 --> 01:30:12,270
0,690 810,1140 1140,1620 2040,2370 2370,2610
the thinking about multiple cores

2870
01:30:12,270 --> 01:30:14,430
0,180 180,270 270,330 330,900 1500,2160
running at the same time.|
|

2871
01:30:15,050 --> 01:30:16,550
0,360 360,540 540,750 750,1050 1050,1500
So I think I recalling
我想起其中一个实验，

2872
01:30:16,550 --> 01:30:17,990
0,240 240,330 330,630 630,1140 1140,1440
one of the labs| with
|在 prime 问题中，

2873
01:30:18,050 --> 01:30:19,220
0,240 240,360 360,660 660,1050 1050,1170
say the prime question| we
|我们看到实际上是交错输出，

2874
01:30:19,220 --> 01:30:20,960
0,150 150,630 630,1020 1200,1560 1560,1740
saw that print actually like

2875
01:30:20,960 --> 01:30:23,660
0,840 840,1380 1410,2010 2100,2340 2340,2700
interleaves output [],| is that
|是不是因为锁只是在 putc ，

2876
01:30:23,660 --> 01:30:27,080
0,810 1200,1680 2070,2940 2970,3210 3210,3420
because the locks are only

2877
01:30:27,080 --> 01:30:29,960
0,360 360,600 600,720 1770,2250 2580,2880
around like {the,putc},| but the
|但是来自多个核心的 putc 调用可以交错，

2878
01:30:29,960 --> 01:30:31,790
0,180 570,930 930,1080 1080,1530 1530,1830
putc calls from multiple cores

2879
01:30:31,790 --> 01:30:33,170
0,150 150,720 720,990 990,1200 1200,1380
could interleave,| meaning that a
|意味着单个 print[] 不能保证是原子的。

2880
01:30:33,170 --> 01:30:34,730
0,300 300,570 570,1020 1140,1320 1320,1560
single print [] is not

2881
01:30:34,730 --> 01:30:36,200
0,360 360,420 420,540 540,960 1290,1470
guaranteed to be atomic {}.|
|

2882
01:30:36,200 --> 01:30:37,100
0,120 120,300 300,540
You {got,it} {}.|
你是对的。|

2883
01:30:37,160 --> 01:30:39,480
0,450 600,780 780,930 930,1350
Okay, that makes sense.|
好的，理解了。|

2884
01:30:39,480 --> 01:30:41,070
0,330 330,570 570,840 1080,1230 1230,1590
Alright, thank you.| You're welcome.|
好的，谢谢。|不用谢。|

2885
01:30:42,200 --> 01:30:43,160
0,120 120,240 240,270 270,480 480,960
I have a quick question,|
我有一个简短的问题，|

2886
01:30:43,820 --> 01:30:46,280
0,390 390,990 1080,1350 1350,1920 1950,2460
{} so I remember reading
我记得阅读材料里有，

2887
01:30:46,280 --> 01:30:47,570
0,120 120,330 360,930 930,1050 1050,1290
in the like,| the reading
|阅读材料表示计时器中断是在机器模式下处理的，

2888
01:30:47,570 --> 01:30:48,830
0,240 240,510 510,720 720,810 810,1260
said something about the timer

2889
01:30:48,830 --> 01:30:50,660
0,510 510,720 720,1170 1170,1440 1440,1830
interrupts being handled in machine

2890
01:30:50,660 --> 01:30:52,910
0,390 1020,1350 1350,1560 1560,1710 1710,2250
mode| and I was wondering
|我想知道是在哪里处理的，

2891
01:30:52,970 --> 01:30:55,610
0,600 600,900 900,1650 1770,2430 2430,2640
where that was handled| when
|当我们做 traps 实验时，

2892
01:30:55,610 --> 01:30:56,660
0,120 120,210 210,510 510,630 630,1050
we were doing the traps

2893
01:30:56,660 --> 01:30:57,460
0,330
lab,|
|

2894
01:30:57,880 --> 01:30:59,560
0,330 330,510 510,1110 1110,1290 1290,1680
{} like where the switch
比如，在 traps 实验中，在哪里切换到机器模式，

2895
01:30:59,560 --> 01:31:01,000
0,120 120,450 450,660 660,810 810,1440
to machine mode was happening

2896
01:31:01,060 --> 01:31:02,470
0,420 420,480 480,810 810,1200 1200,1410
during the traps lab| and
|然后我们在做什么。

2897
01:31:02,470 --> 01:31:04,330
0,360 660,1170 1170,1320 1320,1440 1440,1860
then what we were doing.|
|

2898
01:31:04,880 --> 01:31:06,650
0,300 300,780 780,1020 1020,1440 1470,1770
Yeah, okay great question {},|
好的，好问题，|

2899
01:31:06,650 --> 01:31:09,020
0,150 150,360 360,720 990,1830 1890,2370
so you know the {}.|
你知道。|

2900
01:31:09,870 --> 01:31:11,460
0,420 420,840 840,1200 1200,1500 1500,1590
So I I'm pulling up
所以我调出代码，

2901
01:31:11,460 --> 01:31:13,050
0,90 90,540 810,1380 1380,1530 1530,1590
the code,| {} so if
|所以如果你查看 start ，

2902
01:31:13,050 --> 01:31:14,040
0,120 120,270 270,330 330,480 480,990
you look at your start

2903
01:31:14,040 --> 01:31:15,240
0,360 360,570 570,720 720,990 990,1200
correctly,| there's a start runs
|有一个 start 运行在 M 模式，

2904
01:31:15,240 --> 01:31:15,870
0,90 90,270 270,450 450,570 570,630
in M mode| at the
|当机器启动时的开始时间，

2905
01:31:15,870 --> 01:31:17,100
0,540 540,690 690,1050 1050,1170 1170,1230
beginning of time when the

2906
01:31:17,100 --> 01:31:18,320
0,270 270,690
machine boots,|
|

2907
01:31:18,320 --> 01:31:21,050
0,660 660,990 1020,2340 2340,2400 2400,2730
and it programs the timer
并且它对计时器检查进行编程，

2908
01:31:21,050 --> 01:31:21,900
0,300
check,|
|

2909
01:31:22,140 --> 01:31:24,180
0,330 330,840 990,1260 1260,1590 1590,2040
and so here's {timerinit -}|
这是 timerinit |

2910
01:31:24,660 --> 01:31:28,230
0,480 510,930 930,1140 1140,2130 2160,3570
and {timerinit -} basically programs
而 timerinit 对 CLINT 进行编程，

2911
01:31:28,230 --> 01:31:29,460
0,120 120,420 420,510 510,660 660,1230
the plic {} the clint,|
|

2912
01:31:29,490 --> 01:31:31,080
0,210 210,300 300,570 570,1050 1050,1590
which is the local interrupt,|
这是本地中断，|

2913
01:31:31,080 --> 01:31:31,780
0,240
{}
在时钟中断发生时生成中断，

2914
01:31:31,780 --> 01:31:35,020
0,180 180,660 660,1320 1350,2250 2280,3240
to generate interrupts when {}

2915
01:31:35,620 --> 01:31:38,830
0,750 750,990 990,1350 1350,1980 2310,3210
the clock interrupt happens| and
|这可能是这里最重要的函数，

2916
01:31:38,950 --> 01:31:42,490
0,720 1050,2340 2490,2940 2940,3270 3270,3540
{} basically here's probably the

2917
01:31:42,520 --> 01:31:45,310
0,600 600,930 930,1260 1260,1740 1950,2790
most important function here {},|
|

2918
01:31:45,490 --> 01:31:48,280
0,420 420,750 750,1920 1980,2580 2580,2790
it sets the machine mode
它将机器模式的 trap 处理函数设置为这个 timervec 函数，

2919
01:31:48,280 --> 01:31:49,420
0,270 270,570 570,690 690,840 840,1140
trap handler to this function
这个名为timervec的函数，

2920
01:31:49,420 --> 01:31:51,160
0,180 180,480 480,900 1020,1470 1470,1740
called {timervec -},| that's written
|那是由汇编编写的。

2921
01:31:51,160 --> 01:31:52,300
0,690
assembly.|
|

2922
01:31:52,450 --> 01:31:54,700
0,780 990,1530 1530,1620 1620,1920 1920,2250
And when the timer interrupt
当计时器中断发生时，

2923
01:31:54,700 --> 01:31:55,990
0,420 420,660 660,990 990,1110 1110,1290
happens,| that function is being
|这个函数会被调用。

2924
01:31:55,990 --> 01:31:57,000
0,480
called.|
|

2925
01:31:57,210 --> 01:31:59,160
0,540 540,810 810,1140 1140,1560 1560,1950
And so when your kernel
所以，当内核在用户模式或管理模式下运行时，

2926
01:31:59,160 --> 01:32:00,600
0,240 240,510 510,840 840,1230 1230,1440
running user mode or in

2927
01:32:00,600 --> 01:32:03,640
0,540 540,1020 1350,2430
supervisor mode| and
|CLINT 生成一个中断到达这一行，

2928
01:32:03,640 --> 01:32:05,710
0,480 510,1020 1020,1110 1110,1710 1710,2070
clint generates an interrupt [reach]

2929
01:32:05,710 --> 01:32:08,530
0,120 120,690 1080,1890 1920,2490 2490,2820
the line| and {} it
|它将切换到机器模式，

2930
01:32:08,530 --> 01:32:10,480
0,510 510,1050 1050,1200 1200,1530 1530,1950
will switch to machine mode|
|

2931
01:32:10,480 --> 01:32:11,470
0,120 120,330 330,480 480,750 750,990
and call this function {timervec
并且调用这个函数 timervec ，

2932
01:32:11,470 --> 01:32:13,750
0,450 780,930 930,1440 1440,1740 1740,2280
-},| in same way basically
|基本上与管理模式和用户模式中看到的相同。

2933
01:32:13,750 --> 01:32:16,210
0,1110 1140,1710 1710,2160 2160,2220 2220,2460
as almost equivalent to what

2934
01:32:16,210 --> 01:32:17,590
0,180 180,480 480,600 600,1140 1140,1380
we've seen for supervisor mode

2935
01:32:17,590 --> 01:32:18,560
0,90 90,300 300,570
and user mode.|
|

2936
01:32:18,560 --> 01:32:20,960
0,450 600,1260 1560,1770 1770,2250 2250,2400
Okay?| Sure.| And then if
好的？|是的。|然后，如果你看一下 kernelvec.S 。

2937
01:32:20,960 --> 01:32:23,510
0,150 150,360 360,1020 1380,2160 2190,2550
you look in {} {kernelvec.S

2938
01:32:23,510 --> 01:32:25,180
0,450 450,720 720,1200
- - -}.|
|

2939
01:32:25,360 --> 01:32:26,560
0,480 480,690 690,870 870,960 960,1200
{} We looked at {kernelvec
我们看了很多次 kernelvec ，

2940
01:32:26,560 --> 01:32:27,580
0,210 210,270 270,630 660,990 990,1020
-} a lot right,| I
|我的意思是那个函数，

2941
01:32:27,580 --> 01:32:28,360
0,120 120,210 210,420 420,720 720,780
mean that stuff function| to
|看看它是否保存了很多东西。

2942
01:32:28,360 --> 01:32:29,110
0,180 180,270 270,390 390,690 690,750
see if it stores a

2943
01:32:29,110 --> 01:32:31,180
0,420 690,1020 1020,1380 1380,1710 1710,2070
lot.| And here's {timervec -},|
|这是 timervec ，|

2944
01:32:31,870 --> 01:32:33,280
0,210 210,810 810,900 900,1230 1230,1410
it's basically the same sort
它基本上是类似的想法，

2945
01:32:33,280 --> 01:32:34,690
0,60 60,330 330,420 420,990 1110,1410
of type of idea,| let's
|我们看看它是一些寄存器，

2946
01:32:34,690 --> 01:32:35,740
0,120 120,210 210,270 270,540 540,1050
see it's a couple registers,|
|

2947
01:32:35,740 --> 01:32:36,310
0,120 120,240 240,360 360,450 450,570
so that it can do
让它可以完成工作，

2948
01:32:36,310 --> 01:32:38,020
0,120 120,690 1080,1290 1290,1350 1350,1710
its job| and the only
|它做的就是在这里编写六行代码，

2949
01:32:38,020 --> 01:32:39,310
0,300 300,360 360,780 780,1080 1080,1290
job it does actually these

2950
01:32:39,310 --> 01:32:40,120
0,210 210,270 270,540 540,750 750,810
sort of six lines of

2951
01:32:40,120 --> 01:32:41,360
0,270 270,690
code here,|
|

2952
01:32:41,360 --> 01:32:44,030
0,720 720,900 900,1500 2040,2430 2430,2670
{} or whatever five seven
或者五行，七行代码，

2953
01:32:44,030 --> 01:32:45,440
0,210 210,270 270,660 930,1320 1320,1410
lines of code| {}  and
|它所做的就是对 CLINT 重新编程，

2954
01:32:45,440 --> 01:32:46,490
0,270 270,360 360,420 420,780 780,1050
basically what it does you

2955
01:32:46,490 --> 01:32:48,350
0,180 180,840 840,1230 1260,1650 1650,1860
know re-programs the clint| to
|以生成未来的中断，

2956
01:32:48,350 --> 01:32:50,270
0,450 450,780 780,1320 1470,1740 1740,1920
generate future interrupts| and then
|然后向管理程序发出软件中断，

2957
01:32:50,270 --> 01:32:52,310
0,420 420,900 900,990 990,1470 1470,2040
basically raises a software interrupt

2958
01:32:52,700 --> 01:32:54,540
0,480 540,690 690,1440
to the supervisor,|
|

2959
01:32:54,540 --> 01:32:55,710
0,480 480,660 660,870 870,1080 1080,1170
{} so that goes to
所以，它将进入管理者模式。

2960
01:32:55,710 --> 01:32:57,200
0,540 540,960
supervisor mode.|
|

2961
01:32:57,410 --> 01:32:59,300
0,450 450,930 1050,1650 1650,1800 1800,1890
Okay.| So then at the
好吧。|然后，在 mret 的时候，

2962
01:32:59,300 --> 01:33:02,720
0,720 1080,1440 1440,1950 2490,3210 3210,3420
point at mret,| mret, let's
|mret ，比如内核使用计时器中断，

2963
01:33:02,720 --> 01:33:03,920
0,120 120,210 210,480 480,600 600,1200
say the kernel was interrupted

2964
01:33:03,950 --> 01:33:05,300
0,540 540,630 630,870 870,930 930,1350
during a timer {} chip

2965
01:33:05,360 --> 01:33:06,410
0,300 300,330 330,630 630,900 900,1050
with a timer chip,| so
|它进入机器模式，

2966
01:33:06,410 --> 01:33:07,430
0,90 90,240 240,300 300,600 600,1020
it went to machine mode,|
|

2967
01:33:07,760 --> 01:33:08,900
0,240 240,480 480,630 630,1020 1020,1140
{} mret then returned from
然后 mret 从机器模式返回到管理者模式，

2968
01:33:08,900 --> 01:33:10,460
0,300 300,570 570,900 900,990 990,1560
machine mode back to supervisor

2969
01:33:10,460 --> 01:33:13,250
0,360 390,750 1500,1950 2010,2610 2640,2790
mode, right,| and if the
|如果中断启用了管理者模式，

2970
01:33:13,250 --> 01:33:15,320
0,360 360,450 450,1110 1110,1680 1680,2070
interrupt {} enabled supervisor mode,|
|

2971
01:33:15,350 --> 01:33:16,700
0,240 240,420 420,750 750,1140 1140,1350
at that point, maybe the
这个时刻，可能产生管理者软件中断。

2972
01:33:16,730 --> 01:33:18,620
0,690 690,870 900,1080 1080,1590 1590,1890
supervisor, in the supervisor software

2973
01:33:18,620 --> 01:33:20,600
0,360 360,480 480,870 900,1620
interrupt will be generated.|
|

2974
01:33:20,990 --> 01:33:23,630
0,510 510,1080 1170,1470 1470,1950 1950,2640
Oh, okay.| And now basically
哦，好的。|现在，内核也会做同样的事情，

2975
01:33:23,690 --> 01:33:24,320
0,120 120,390 390,480 480,540 540,630
the kernel will do the

2976
01:33:24,320 --> 01:33:25,640
0,180 180,390 390,1020 1020,1140 1140,1320
same thing,| basically will go
|转到 kernelvec ，

2977
01:33:25,640 --> 01:33:27,110
0,120 120,420 420,900 1140,1350 1350,1470
to {kernelvec -},| you know
|保存恢复所有寄存器，

2978
01:33:27,110 --> 01:33:28,730
0,270 270,630 630,720 720,810 810,1620
save restore all the registers|
|

2979
01:33:28,970 --> 01:33:31,490
0,840 840,1560 1560,2190 2190,2310 2310,2520
{} and {} and then
然后转到内核 trap ，

2980
01:33:31,490 --> 01:33:33,440
0,210 210,660 660,1080 1110,1440 1440,1950
go to a kernel trap|
|

2981
01:33:33,740 --> 01:33:34,700
0,300 300,390 390,630 630,870 870,960
and the kernel trap will
内核 trap 会看到那是计时器中断。

2982
01:33:34,700 --> 01:33:35,840
0,210 210,810 810,990 990,1080 1080,1140
see aha, that was the

2983
01:33:35,840 --> 01:33:36,980
0,210 210,300 300,720
{timer -} interrupt.|
|

2984
01:33:37,360 --> 01:33:38,770
0,150 150,480 660,1020 1020,1230 1230,1410
I see,| and so what
我明白了，|那么切换到机器模式是在哪一点，

2985
01:33:38,770 --> 01:33:39,940
0,150 150,270 270,660 660,750 750,1170
was the point of switching

2986
01:33:39,940 --> 01:33:40,810
0,120 120,450 450,660 660,750 750,870
to machine mode in the

2987
01:33:40,810 --> 01:33:42,460
0,300 300,690 720,990 990,1230 1320,1650
first place| at like what
|它到底做了什么。

2988
01:33:42,490 --> 01:33:45,430
0,450 450,600 600,720 720,1020 1950,2940
exactly does it do.| I
|我不知道在哪一点，

2989
01:33:45,460 --> 01:33:46,360
0,300 300,420 420,540 540,600 600,900
don't know what the {point,is},|
|

2990
01:33:46,360 --> 01:33:50,530
0,1230 1230,1560 1560,1920 2310,3570 3600,4170
{this,is} hardware works.| Okay, gotcha.|
这是硬件工作。|好的，知道了。|

2991
01:33:50,980 --> 01:33:53,470
0,660 840,1230 1230,1710 1710,1980 2010,2490
{} Actually do a little
实际上做得更多一点，

2992
01:33:53,470 --> 01:33:56,260
0,150 150,360 360,720 870,1680 1680,2790
bit more,| yeah yeah yeah,
|是的，这里有一些原因，

2993
01:33:56,260 --> 01:33:57,100
0,150 150,270 270,450 450,780 780,840
there are some reasons| I
|我想为什么在机器模式使用计时器，

2994
01:33:57,100 --> 01:33:59,080
0,150 150,480 480,690 690,1530 1620,1980
think why use a timer

2995
01:33:59,080 --> 01:34:01,000
0,150 150,540 540,1290 1350,1650 1650,1920
chip exposed to machine mode,|

2996
01:34:01,000 --> 01:34:03,040
0,300 600,1020 1020,1200 1200,1350 1350,2040
but {} from our perspective,|
但从我们的角度来看，|

2997
01:34:03,480 --> 01:34:04,440
0,120 120,270 270,450 450,660 660,960
you know would be great,|
这很好，|

2998
01:34:04,440 --> 01:34:05,730
0,120 120,240 240,600 600,690 690,1290
if we could have delegated
如果我们能把定时器中断交给管理者模式，

2999
01:34:05,730 --> 01:34:07,260
0,210 210,600 600,990 990,1230 1230,1530
the timer interrupt {[] -}

3000
01:34:07,260 --> 01:34:08,400
0,90 90,600 600,840 840,930 930,1140
to supervisor mode| and never
|而不用处理定时器模式，

3001
01:34:08,400 --> 01:34:09,690
0,150 150,210 210,480 480,810 810,1290
had to deal with {}

3002
01:34:09,690 --> 01:34:11,130
0,270 270,660 690,930 960,1080 1080,1440
timer mode,| but you know
|但是，对这个特殊的芯片是不起作用的。

3003
01:34:11,310 --> 01:34:13,530
0,510 510,780 780,1110 1740,1980 1980,2220
that doesn't work for this

3004
01:34:13,530 --> 01:34:14,760
0,480 480,780
particular chip.|
|

3005
01:34:14,930 --> 01:34:16,370
0,570 630,750 750,930 930,1230 1230,1440
Okay, that makes sense, thank
好的，有道理，非常感谢。

3006
01:34:16,370 --> 01:34:17,510
0,90 90,180 180,630 930,1050 1050,1140
you so much.| {You're -}
|不用谢。

3007
01:34:17,510 --> 01:34:18,480
0,420
welcome.|
|

3008
01:34:19,300 --> 01:34:20,200
0,180 180,360 360,630 630,780 780,900
Oh, I actually have a
哦，我有一个关于这部分的跟进问题。

3009
01:34:20,200 --> 01:34:23,140
0,600 600,1440 1470,2220 2460,2850 2850,2940
follow-up on this part of.|
|

3010
01:34:23,710 --> 01:34:26,140
0,720 720,1260 1350,1650 1650,1770 1800,2430
{} So keep {ask,your} questions.|
请继续你的问题。|

3011
01:34:26,140 --> 01:34:28,760
0,150 660,1320 1350,2190
{} Yeah. {}|
好的。|

3012
01:34:28,760 --> 01:34:30,650
0,210 210,480 480,810 810,1140 1140,1890
I saw that it allocates
我看到它分配了 32 个 uint64 ，

3013
01:34:30,650 --> 01:34:34,700
0,1560 1740,2100 2700,3060 3060,3420 3420,4050
32 {} {uint64 - -

3014
01:34:34,700 --> 01:34:36,110
0,480 480,690 690,840 840,1200 1200,1410
-},| but it only seems
|但是它似乎只用了四个或三个，

3015
01:34:36,110 --> 01:34:37,400
0,60 60,150 150,780
to be using

3016
01:34:37,400 --> 01:34:39,530
0,750 960,1230 1230,1500 1500,1620 1620,2130
four, no three of them,

3017
01:34:40,490 --> 01:34:43,070
0,480 510,660 660,1500 1500,2280 2280,2580
right.| Um.| {} {In,start.c -
|嗯。|在 start.c 中。

3018
01:34:43,070 --> 01:34:44,880
0,570 780,1260
-}, it.|
|

3019
01:34:44,940 --> 01:34:46,470
0,240 240,960 960,1140 1140,1320 1320,1530
At scratch,| yeah I guess
在 scratch ，|是的，我想它分配的比需要的多，

3020
01:34:46,470 --> 01:34:48,150
0,330 330,960 960,1380 1380,1560 1560,1680
it allocates more than is

3021
01:34:48,150 --> 01:34:52,770
0,810 810,2100 2280,2880 2880,3870 3870,4620
necessary,| {} scratches thirty-two {}
|32 个暂存区域，

3022
01:34:52,770 --> 01:34:55,200
0,300 300,900 930,1410 1500,2010 2010,2430
scratch area,| {} the reason,|
|原因是，|

3023
01:34:55,200 --> 01:34:58,800
0,960 1350,1890 2130,3000
{} so {},
对于每一个 CPU ，

3024
01:34:59,520 --> 01:35:01,230
0,540 540,720 720,900 900,1200 1200,1710
{} so for every CPU

3025
01:35:01,230 --> 01:35:02,790
0,570 690,1110 1110,1320 1320,1470 1470,1560
correct,| {} there has to
|必须有一些暂存空间，

3026
01:35:02,790 --> 01:35:04,800
0,90 90,240 240,780 810,1560 1590,2010
be some scratch space| and
|我想那里有三个或类似的 CPU ，

3027
01:35:04,800 --> 01:35:06,600
0,660 960,1110 1110,1260 1260,1470 1470,1800
there I guess we have

3028
01:35:06,720 --> 01:35:08,040
0,480 480,570 570,870 870,1020 1020,1320
three or something like that

3029
01:35:08,070 --> 01:35:09,780
0,540 540,960 960,1320 1320,1650 1650,1710
CPUs,| so basically allocates a
|所以多分配一点，

3030
01:35:09,780 --> 01:35:11,080
0,150 150,270 270,390 390,870
little bit too much,|
|

3031
01:35:17,970 --> 01:35:19,410
0,390 390,570 570,750 750,930 930,1440
{} but there's no []
但不会[]分配太多。

3032
01:35:20,040 --> 01:35:21,720
0,540 540,660 660,1080
allocating too much.|
|

3033
01:35:22,260 --> 01:35:23,940
0,660 870,1170 1170,1260 1260,1500 1500,1680
Okay, okay, it's like it
好的，比如，它只用 scratch[0] scratch[1] scratch[1] ，

3034
01:35:23,940 --> 01:35:26,130
0,210 210,840 870,1350 1350,1800 1800,2190
only uses scratch zero scratch

3035
01:35:26,130 --> 01:35:28,860
0,330 330,630 630,1170 1170,1290 1290,2730
one scratch two.| No, you
|不，我想是使用 3 ，

3036
01:35:28,890 --> 01:35:30,300
0,450 450,720 720,1140 1140,1260 1260,1410
know [uses] three, I guess,|
|

3037
01:35:30,300 --> 01:35:32,130
0,510 510,1050 1050,1260 1260,1620 1620,1830
so as {zero,to} three, that's
从 0 到 3 ，是四个，

3038
01:35:32,130 --> 01:35:34,170
0,630 840,1230 1230,1320 1320,1770 1770,2040
four,| four or five current
|4 和 5 是六个，

3039
01:35:34,170 --> 01:35:35,360
0,810
six,|
|

3040
01:35:35,360 --> 01:35:37,670
0,930 930,1080 1080,1470 1470,1680 1680,2310
{} so it's six integers|
所以是六个整数，|

3041
01:35:38,030 --> 01:35:41,150
0,840 840,1980 2190,2790 2790,2940 2940,3120
{} and {} I guess,
我想，我们可以运行四个 CPU ，

3042
01:35:41,150 --> 01:35:42,440
0,180 180,480 480,660 660,1170 1170,1290
we have we're running we

3043
01:35:42,440 --> 01:35:43,670
0,150 150,330 330,480 480,690 690,1230
could run with four CPUs,|
|

3044
01:35:43,670 --> 01:35:44,690
0,180 180,270 270,510 510,690 690,1020
but we're running with three,|
但我们运行了三个，|

3045
01:35:44,690 --> 01:35:45,920
0,210 210,300 300,480 480,630 630,1230
but we could run four.|
但我们可以运行四个。|

3046
01:35:47,840 --> 01:35:48,980
0,300 300,510 510,720 720,900 900,1140
So six times four twenty
所以 6 乘以 24 ，

3047
01:35:48,980 --> 01:35:50,420
0,360 360,540 540,600 600,1020 1020,1440
four,| I guess {you,know} the,
|我想肯定分配了太多内存。

3048
01:35:50,960 --> 01:35:52,310
0,150 150,450 450,1020 1020,1140 1140,1350
we definitely allocating too much

3049
01:35:52,310 --> 01:35:53,280
0,420
memory.|
|

3050
01:35:54,090 --> 01:35:55,080
0,120 120,270 270,570 570,690 690,990
I don't remember I thought
我不记得，不久前我想过这件事，

3051
01:35:55,080 --> 01:35:55,920
0,180 180,300 300,360 360,630 630,840
about this a while back

3052
01:35:55,920 --> 01:35:57,300
0,240 240,600 630,690 690,1200 1230,1380
ago| and {} I don't
|我也记不清 32 是从哪里来的了。

3053
01:35:57,300 --> 01:36:00,800
0,300 300,810 810,1620 2070,2910
remember exactly where {}

3054
01:36:02,390 --> 01:36:04,780
0,840 840,1320 1320,1830
32 came from.|
|

3055
01:36:05,290 --> 01:36:07,540
0,180 180,330 330,1080 1080,1350 1350,2250
So we need double check.|
所以，我们需要再检查一遍。|

3056
01:36:08,660 --> 01:36:09,980
0,180 180,360 360,510 510,1110 1110,1320
So you can reconstruct it.|
你可以重建它。|

3057
01:36:12,590 --> 01:36:13,840
0,780

3058
01:36:23,720 --> 01:36:24,940
0,570

3059
01:36:30,440 --> 01:36:31,740
0,960

3060
01:36:41,430 --> 01:36:43,980
0,210 210,360 360,720 720,1230 1230,2550
Oh yeah, save restore, they
哦，是的，保存恢复，都是 8 字节的。

3061
01:36:44,160 --> 01:36:48,000
0,1050 1680,2850 2850,3270 3270,3390 3390,3840
all they all eight bytes,

3062
01:36:48,000 --> 01:36:48,880
0,360
right.|
|

3063
01:36:49,520 --> 01:36:50,820
0,750
Yeah.|
是的。|

3064
01:36:53,190 --> 01:36:55,840
0,1110 1140,1950
And it.|
还有，它。|

3065
01:37:03,830 --> 01:37:04,790
0,300 300,600 600,660 660,810 810,960
Okay, let me get back
好的，我晚点给你说，

3066
01:37:04,790 --> 01:37:06,950
0,510 510,960 960,1380 1380,1740 1740,2160
to you,| I can't recall
|我现在想不起来了，

3067
01:37:06,950 --> 01:37:07,610
0,210 210,300 300,360 360,570 570,660
right at the top my

3068
01:37:07,610 --> 01:37:08,570
0,390 390,480 480,570 570,840 840,960
head| you know why it
|为什么是这样的。

3069
01:37:08,570 --> 01:37:09,380
0,150 150,240 240,390 390,480 480,810
is the way it is.|
|

3070
01:37:10,450 --> 01:37:13,000
0,570 630,960 960,1500 1530,2130 2280,2550
Okay, makes sense, {} thank
好的，有道理，非常感谢。

3071
01:37:13,000 --> 01:37:14,590
0,90 90,300 300,900 1050,1230 1230,1590
you so much.| You're welcome,
|不客气，问得好。

3072
01:37:14,590 --> 01:37:17,300
0,150 150,630 990,1650 1650,2160
good questions.| Thank you.
|谢谢。
