1
00:00:00,450 --> 00:00:03,000
0,480 480,660 660,1260 1650,2400 2400,2550
Okay, good afternoon, wherever you
好的，下午好，无论你在哪里。

2
00:00:03,000 --> 00:00:03,920
0,390
are.|
|

3
00:00:04,070 --> 00:00:05,690
0,480 480,720 720,1080 1080,1230 1230,1620
Um, can everybody hear me,|
嗯，大家都能听到我说话吗，|

4
00:00:05,780 --> 00:00:07,840
0,420 450,780 780,1200 1230,1800
quick sound check, {make,sure}.|
快速测试一下语音。|

5
00:00:09,580 --> 00:00:11,200
0,210 240,420 420,810 960,1410 1410,1620
Yeah you're fine.| Good, thank
是的，是好的。|好的，谢谢。

6
00:00:11,200 --> 00:00:13,990
0,240 690,1260 1290,1770 1770,2130 2130,2790
you.| {} So today we're
|那么今天我们就来谈一谈，

7
00:00:14,200 --> 00:00:15,670
0,510 510,570 570,840 840,1440 1440,1470
going to talk about,| I
|我没有具体的日程安排，

8
00:00:15,670 --> 00:00:16,900
0,240 240,450 450,720 720,750 750,1230
don't really have a specific

9
00:00:16,900 --> 00:00:18,820
0,600 600,750 750,1500 1500,1620 1620,1920
agenda| but basically the plan
|但基本上我们的计划是回答问题，

10
00:00:18,820 --> 00:00:20,590
0,180 180,690 930,1320 1320,1410 1410,1770
is to try to answer

11
00:00:20,590 --> 00:00:23,140
0,660 720,1890 1890,2010 2010,2220 2220,2550
questions| that you might have
|你可能对上一个实验或之前的实验有什么问题。

12
00:00:23,140 --> 00:00:24,760
0,420 420,630 630,1320 1320,1560 1560,1620
about these last lab or

13
00:00:24,760 --> 00:00:25,800
0,90 90,450 450,930
the previous labs.|
|

14
00:00:26,330 --> 00:00:27,920
0,510 780,1080 1080,1170 1170,1470 1470,1590
Um, so the approach I'm
所以我要采取的方法是，

15
00:00:27,920 --> 00:00:30,080
0,120 120,180 180,660 990,1500 1500,2160
going to take,| {} today,
|今天，我要介绍一下我们的解决方案。

16
00:00:30,420 --> 00:00:32,250
0,600 600,720 720,1020 1020,1590 1590,1830
is, I'm gonna walk through

17
00:00:32,250 --> 00:00:33,880
0,390 390,720 720,1470
the staff solutions.|
|

18
00:00:34,620 --> 00:00:37,260
0,720 1050,1650 1650,1830 1830,1980 1980,2640
In particularly my own solutions,|
尤其是我自己的解决方案，|

19
00:00:37,710 --> 00:00:39,900
0,630 750,1470 1470,1560 1560,1920 1920,2190
I'm going to discuss them|
我会讨论一下它们，|

20
00:00:40,050 --> 00:00:41,610
0,360 360,900 900,1110 1110,1380 1380,1560
and hopefully as we go
希望在我们讨论解决方案时，

21
00:00:41,610 --> 00:00:43,120
0,120 120,210 210,480 480,1170
through the staff solutions,|
|

22
00:00:43,180 --> 00:00:45,400
0,720 720,1350 1350,1710 1740,2010 2010,2220
um, you can jump in|
你可以打断，|

23
00:00:45,400 --> 00:00:46,390
0,210 210,450 450,690 690,930 930,990
if I don't answer a
如果我没有回答某个问题，

24
00:00:46,390 --> 00:00:49,750
0,330 330,900 1140,2190 2190,2880 2910,3360
particular question,| um or {},
|或者稍等一下，

25
00:00:49,780 --> 00:00:50,830
0,270 270,330 330,510 510,660 660,1050
wait a little bit,| because
|因为我把你们问的所有问题，

26
00:00:50,830 --> 00:00:52,210
0,360 390,540 540,720 720,840 840,1380
I put all the questions

27
00:00:52,210 --> 00:00:53,830
0,360 360,540 540,1020 1170,1470 1470,1620
that you've asked| at least
|至少在今天上午 11 点之前的，

28
00:00:53,830 --> 00:00:55,630
0,450 480,810 810,1110 1110,1260 1260,1800
before eleven am this morning,|
|

29
00:00:55,750 --> 00:00:57,520
0,810 810,1080 1080,1230 1230,1530 1530,1770
{} in the lecture notes
在最后的课堂讲稿中，

30
00:00:57,520 --> 00:00:59,230
0,60 60,120 120,540 570,1050 1290,1710
at the bottom| and we'll
|我们会试着去全部过一遍。

31
00:00:59,260 --> 00:01:00,070
0,210 210,300 300,420 420,570 570,810
try to go through that.|
|

32
00:01:03,240 --> 00:01:05,190
0,120 120,240 240,930 990,1620 1620,1950
I'm gonna start {} with
我将从页表（pagetable）实验开始，

33
00:01:05,190 --> 00:01:07,480
0,420 960,1260 1260,1650 1650,2100
the {pagetable -} lab,|
|

34
00:01:07,750 --> 00:01:09,220
0,270 270,600 600,990 990,1230 1230,1470
because most questions were about
因为大多数问题都是关于页表的实验，

35
00:01:09,220 --> 00:01:11,350
0,60 60,300 300,570 570,1140 1530,2130
the {pagetable -} lab {},|
|

36
00:01:11,800 --> 00:01:13,480
0,390 390,870 870,1140 1140,1500 1500,1680
and partly because [] was
部分原因是因为[]是最难的实验。

37
00:01:13,480 --> 00:01:14,780
0,300 300,660 660,1110
the hardest labs.|
|

38
00:01:15,450 --> 00:01:17,430
0,630 1080,1320 1320,1470 1470,1860 1860,1980
Um, and so maybe a
所以也许首先有几点解释，

39
00:01:17,430 --> 00:01:19,830
0,270 270,360 360,900 900,1860 1890,2400
couple of comments| before diving
|在深入到技术部分之前，

40
00:01:19,830 --> 00:01:21,840
0,420 450,570 570,1650 1680,1920 1920,2010
into the technical part of

41
00:01:21,840 --> 00:01:23,460
0,390 720,1200 1230,1470 1470,1590 1590,1620
this,| {} let's talk a
|我们来大体上谈一下页表实验。

42
00:01:23,460 --> 00:01:25,110
0,210 210,330 330,870 1170,1530 1530,1650
little bit about {} the

43
00:01:25,110 --> 00:01:26,520
0,300 300,420 420,690 690,780 780,1410
{pagetable -} lab in general.|
|

44
00:01:27,940 --> 00:01:28,780
0,540

45
00:01:30,380 --> 00:01:32,120
0,660 1110,1260 1260,1500 1500,1620 1620,1740
And you know as you
正如你可能观察到的，

46
00:01:32,120 --> 00:01:33,650
0,300 300,930 930,1020 1020,1290 1290,1530
probably observed,| you know it's
|它实际上只有几行代码，

47
00:01:33,650 --> 00:01:34,520
0,210 210,270 270,540 540,810 810,870
actually a few lines of

48
00:01:34,520 --> 00:01:35,320
0,570
code,|
|

49
00:01:39,920 --> 00:01:41,660
0,720 1260,1350 1350,1590 1590,1650 1650,1740
{} in terms of the
在解决方案上，

50
00:01:41,660 --> 00:01:44,360
0,690 780,1230 1230,1740 1920,2460 2460,2700
solution,| {} but, {} it
|但是，不幸的是，必须调试问题。

51
00:01:44,360 --> 00:01:46,280
0,600 600,1170 1170,1290 1290,1530 1530,1920
unfortunately has, you know, {had,to}

52
00:01:46,280 --> 00:01:46,980
0,480
debug

53
00:01:51,330 --> 00:01:52,180
0,660
problems.|
|

54
00:01:55,160 --> 00:01:58,730
0,660 810,930 930,1020 1020,1560 3210,3570
And, you know, there's one
而且，有一个原因是，

55
00:01:58,730 --> 00:02:00,860
0,510 510,930 930,1260 1260,1770 1770,2130
reason is that| when actually
|当 bug 真的出现时，

56
00:02:00,860 --> 00:02:02,540
0,270 270,510 510,870 990,1560 1560,1680
bug shows up,| {} you
|结果是相当极端的，

57
00:02:02,540 --> 00:02:04,580
0,60 60,240 240,750 750,1290 1470,2040
know the outcomes are pretty

58
00:02:04,580 --> 00:02:05,900
0,570 630,900 900,990 990,1050 1050,1320
extreme| like in the worst
|就像在最坏的情况下，

59
00:02:05,900 --> 00:02:07,670
0,660 900,1350 1350,1530 1530,1650 1650,1770
case,| probably some of you
|可能你们中的一些人观察到了最坏的情况，

60
00:02:07,670 --> 00:02:09,500
0,540 540,930 1020,1260 1260,1440 1440,1830
observed that the worst case,|
|

61
00:02:09,710 --> 00:02:10,700
0,690

62
00:02:10,790 --> 00:02:12,920
0,600 600,1260 1260,1530 1530,1770 1770,2130
QEMU stops or {xv6 -}
QEMU 停止或 xv6 停止，

63
00:02:12,920 --> 00:02:14,450
0,570 570,810 810,990 990,1320 1320,1530
stops,| there's no output being
|不再打印输出，就是这样，

64
00:02:14,450 --> 00:02:16,820
0,300 300,930 1050,1830 1830,2160 2160,2370
printed anymore, {} and that's

65
00:02:16,820 --> 00:02:18,620
0,270 570,630 630,1440 1440,1620 1620,1800
it,| you know it's your
|你的工作就是找出到底哪里出了问题，

66
00:02:18,620 --> 00:02:20,150
0,360 360,720 720,1020 1020,1230 1230,1530
job to figure out actually

67
00:02:20,150 --> 00:02:21,860
0,180 180,390 390,780 1320,1470 1500,1710
what went wrong,| {} {}
|在最好的情况下，你会遇到某种内核错误（kernel panic），

68
00:02:21,860 --> 00:02:23,360
0,150 150,210 210,450 450,1020 1020,1500
in the best case you

69
00:02:23,360 --> 00:02:24,620
0,150 150,300 300,360 360,750 750,1260
get sort of kernel panic,|
|

70
00:02:25,020 --> 00:02:27,060
0,720 750,1260 1260,1470 1470,1650 1650,2040
{} depending you know maybe
取决于，也许这只是一个起点，

71
00:02:27,060 --> 00:02:28,470
0,210 210,240 240,690 690,1200 1200,1410
just a starting point| or
|或者追查问题的真正根源是错误本身，

72
00:02:28,470 --> 00:02:29,760
0,150 150,570 570,960 960,1140 1140,1290
for tracking down what the

73
00:02:29,760 --> 00:02:31,200
0,570 570,900 900,960 960,1050 1050,1440
actual source of the problem

74
00:02:31,200 --> 00:02:32,860
0,240 420,720 720,1320
is panic itself,|
|

75
00:02:32,960 --> 00:02:34,130
0,150 150,540 540,840 840,900 900,1170
it's probably related to something
可能与其他什么有关，

76
00:02:34,130 --> 00:02:35,330
0,390 390,480 480,570 570,1020 1020,1200
else,| something the invariant that
|内核的一些常量被破坏，

77
00:02:35,330 --> 00:02:37,250
0,90 90,360 360,510 510,1080 1170,1920
the kernel got broken,| but
|但你知道早些时候在外面的某个地方，

78
00:02:37,250 --> 00:02:38,600
0,120 120,210 210,570 570,780 780,1350
you know somewhere out earlier,|
|

79
00:02:38,600 --> 00:02:39,380
0,270 270,420 420,540 540,660 660,780
probably when you set up
可能在设置页表时，

80
00:02:39,380 --> 00:02:40,460
0,60 60,330 330,810 810,990 990,1080
the {pagetables -},| you did
|你做错了什么最后引起错误，

81
00:02:40,460 --> 00:02:41,810
0,360 360,750 750,840 840,1110 1110,1350
something wrong at the end

82
00:02:41,810 --> 00:02:43,580
0,420 570,1080 1080,1170 1170,1350 1350,1770
causes panic to go off,|
|

83
00:02:43,730 --> 00:02:45,050
0,270 270,360 360,480 480,750 750,1320
you have to track down
你得追踪到底是怎么回事。

84
00:02:45,230 --> 00:02:46,360
0,390 390,630 630,900
what's going on.|
|

85
00:02:46,840 --> 00:02:48,820
0,510 750,1350 1380,1710 1710,1920 1920,1980
{} So fewer lines of
所以代码行数更少，很难调试问题，

86
00:02:48,820 --> 00:02:50,710
0,510 540,780 780,840 840,1110 1110,1890
code, hard to debug problems,|
|

87
00:02:50,890 --> 00:02:52,690
0,450 450,990 1110,1470 1470,1530 1530,1800
{} in produce a harsh
在生产环境，恶劣的环境中去调试。

88
00:02:52,690 --> 00:02:55,980
0,750 1230,1980 2070,2490 2490,3030
environment, {} to debug.|
|

89
00:02:56,360 --> 00:02:57,470
0,390 390,630 630,720 720,870 870,1110
{} If you do in
如果你做内核调试或内核编程，

90
00:02:57,470 --> 00:02:59,420
0,60 60,420 420,990 990,1440 1680,1950
the kernel debugging or kernel

91
00:02:59,420 --> 00:03:01,760
0,600 600,1110 1110,1530 1530,2070 2070,2340
programming,| {you,know} programming environment, debugging
|你知道，编程环境，调试环境，

92
00:03:01,760 --> 00:03:03,890
0,720 840,1440 1440,1590 1590,1950 1980,2130
environment,| {} is more, you
|更是，你知道的，恶劣的，

93
00:03:03,890 --> 00:03:06,170
0,300 300,810 1560,1680 1680,2010 2010,2280
know unforgiven,| as Robert mentioned
|正如 Robert 在第一节课中提到的，

94
00:03:06,170 --> 00:03:07,550
0,90 90,180 180,600 780,1170 1170,1380
in the first lecture,| is
|是做内核编程的难点之一。

95
00:03:07,550 --> 00:03:08,660
0,210 210,270 270,360 360,600 600,1110
one of the hard parts

96
00:03:08,890 --> 00:03:10,780
0,480 480,870 870,1050 1050,1350 1350,1890
about basically doing kernel programming.|
|

97
00:03:11,680 --> 00:03:12,520
0,540

98
00:03:12,900 --> 00:03:15,750
0,390 720,1020 1020,1410 1410,1830 2580,2850
And that's you know just
为了让你感觉好点，

99
00:03:15,750 --> 00:03:16,920
0,60 60,360 360,570 570,720 720,1170
to make you feel better,|
|

100
00:03:16,920 --> 00:03:17,760
0,180 180,240 240,450 450,630 630,840
this is not just hard
这不仅对你来说很难，

101
00:03:17,760 --> 00:03:18,810
0,60 60,360 360,480 480,630 630,1050
for you,| you know actually
|你知道对我们来说也很难。

102
00:03:18,810 --> 00:03:20,000
0,300 300,390 390,480 480,1020
hard for your staff.|
|

103
00:03:24,600 --> 00:03:25,800
0,540 540,600 600,840 840,900 900,1200
Both in terms of helping
无论是在帮助你方面，

104
00:03:25,800 --> 00:03:27,420
0,420 420,990 990,1410 1410,1500 1500,1620
you| and actually you know
|实际上我们做这些实验，

105
00:03:27,420 --> 00:03:28,530
0,270 270,390 390,570 570,930 930,1110
we do these labs| and
|我们也会遇到类似的问题，

106
00:03:28,530 --> 00:03:29,910
0,120 120,270 270,600 600,1140 1320,1380
we make similar problems,| you
|我们可能有更多的经验追踪 bug ，

107
00:03:29,910 --> 00:03:30,990
0,210 210,480 510,810 810,900 900,1080
know we probably have more

108
00:03:30,990 --> 00:03:32,520
0,480 480,570 570,870 870,1140 1140,1530
experience at tracking bugs down,|
|

109
00:03:32,760 --> 00:03:34,260
0,330 330,480 480,660 660,1320 1320,1500
but you know {they,just}, they
但是你知道它们确实需要时间。

110
00:03:34,260 --> 00:03:35,180
0,120 120,360 360,660
do take time.|
|

111
00:03:35,400 --> 00:03:36,960
0,600 660,870 870,990 990,1260 1260,1560
Um, so we're helping you,|
所以我们在帮你的时候，|

112
00:03:36,960 --> 00:03:39,180
0,150 150,330 330,840 1170,1950
you know the {},
往往也很难，

113
00:03:40,340 --> 00:03:41,210
0,270 270,330 330,420 420,630 630,870
tends to be hard too,|
|

114
00:03:41,210 --> 00:03:43,130
0,330 330,780 780,1110 1110,1560 1560,1920
because there's some small fragment
因为有一些很小的代码片段，

115
00:03:43,130 --> 00:03:44,420
0,60 60,390 390,570 570,900 900,1290
of code,| there's one detail
|有一个细节可能有问题，

116
00:03:44,420 --> 00:03:46,370
0,360 360,720 720,1230 1290,1770 1770,1950
something probably wrong| and they're
|他们要弄清楚到底什么是小细节，

117
00:03:46,370 --> 00:03:47,600
0,300 300,450 450,690 690,990 990,1230
figuring out actually what little

118
00:03:47,600 --> 00:03:49,490
0,540 540,930 960,1230 1230,1560 1560,1890
detail is,| {} it's not
|这并不容易。

119
00:03:49,490 --> 00:03:49,980
0,270
easy.|
|

120
00:03:50,040 --> 00:03:51,300
0,360 360,450 450,930 930,1110 1110,1260
{} Of course some of
当然有一些问题，

121
00:03:51,300 --> 00:03:52,560
0,180 180,510 510,690 690,870 870,1260
the problems,| we've seen before
|我们以前见过，我们也认识到，

122
00:03:52,560 --> 00:03:54,060
0,150 150,270 270,990 990,1110 1110,1500
and we're recognizing,| for example
|例如，我们自己没有犯同样的错误，

123
00:03:54,060 --> 00:03:54,840
0,120 120,330 330,480 480,570 570,780
we didn't make the same

124
00:03:54,840 --> 00:03:57,480
0,330 330,900 990,1770 1890,2310 2310,2640
mistake ourselves,| but other ones
|但是你们发现的其他一些，

125
00:03:57,480 --> 00:03:58,830
0,330 330,780 780,900 900,1080 1080,1350
you discovered| all kinds of
|各种不同的破坏内核的方式，

126
00:03:58,830 --> 00:04:00,330
0,300 300,630 630,990 990,1440 1440,1500
different ways of breaking the

127
00:04:00,330 --> 00:04:02,370
0,540 600,1110 1110,1710 1710,1830 1830,2040
kernel,| {} that we hadn't
|我们以前没见过的。

128
00:04:02,370 --> 00:04:03,860
0,180 180,630
seen before.|
|

129
00:04:03,940 --> 00:04:04,960
0,180 180,510 570,780 780,870 870,1020
{} So this is just
所以这很难，

130
00:04:04,960 --> 00:04:06,940
0,510 840,1350 1470,1650 1650,1830 1830,1980
hard,| {} I think this
|根据我们的经验，

131
00:04:06,940 --> 00:04:09,850
0,120 120,840 870,1350 1350,2070 2220,2910
is, in our experience {},|
|

132
00:04:11,350 --> 00:04:13,360
0,570 570,900 900,1440 1440,1710 1710,2010
this is historically always hard
对于虚拟内存，这在以往也总是很难，

133
00:04:13,360 --> 00:04:14,660
0,240 240,630 630,1020
with virtual memory,|
|

134
00:04:19,470 --> 00:04:21,660
0,210 210,450 450,1110 1530,1740 1740,2190
so every time the first
所以每次第一个虚拟内存实验出现的时候，

135
00:04:21,660 --> 00:04:23,580
0,330 330,630 630,1080 1080,1560 1560,1920
virtual memory lab comes around,|
|

136
00:04:23,580 --> 00:04:25,050
0,360 360,570 570,810 810,1170 1170,1470
either in {6.S081 -} or
不论在 6.S081 中或它的前身 6.828 中，

137
00:04:25,050 --> 00:04:27,630
0,150 150,690 690,780 780,1560 1920,2580
its predecessor in 6.828,| {}
|事实就是这样

138
00:04:27,690 --> 00:04:28,710
0,330 330,480 480,630 630,690 690,1020
it has been the case|
|

139
00:04:28,710 --> 00:04:29,580
0,240 240,330 330,450 450,630 630,870
that you know that tends
你知道那往往是最难的实验，

140
00:04:29,580 --> 00:04:30,720
0,60 60,210 210,330 330,660 660,1140
to be the hardest lab,|
|

141
00:04:31,020 --> 00:04:33,450
0,720 960,1530 1890,2130 2130,2340 2340,2430
{} {} of all the
在所有实验室中，

142
00:04:33,450 --> 00:04:34,740
0,480 480,810 870,1050 1050,1170 1170,1290
labs| and {you,know} for a
|你知道的，原因有很多，

143
00:04:34,740 --> 00:04:35,910
0,210 210,270 270,660 660,1050 1050,1170
number of reasons,| one you
|一种是恶劣环境，

144
00:04:35,910 --> 00:04:37,200
0,120 120,240 240,510 510,1170 1170,1290
know the harsh environment,| you
|这些 bug 很特殊，

145
00:04:37,200 --> 00:04:38,910
0,180 180,570 960,1320 1320,1440 1440,1710
know the {} the bugs

146
00:04:38,910 --> 00:04:42,450
0,180 180,960 1200,2070 2100,2940 3210,3540
are spectacular| and {} partly
|还有部分原因是你还没有

147
00:04:42,450 --> 00:04:43,620
0,540 540,630 630,840 840,990 990,1170
because you haven't done| that
|很丰富的内核编程经验，

148
00:04:43,620 --> 00:04:45,300
0,180 180,480 480,900 900,1320 1320,1680
much kernel programming experience yet,|
|

149
00:04:45,300 --> 00:04:46,110
0,180 180,390 390,570 570,630 630,810
and so this is sort
所以这可以说是第一个实验，

150
00:04:46,110 --> 00:04:46,980
0,60 60,120 120,420 420,750 750,870
of the first lab| with
|所有这些都结合在一起了。

151
00:04:46,980 --> 00:04:48,060
0,180 180,330 330,540 540,660 660,1080
all those things come together.|
|

152
00:04:48,740 --> 00:04:49,580
0,180 180,390 390,540 540,630 630,840
{} This year, we tried
今年，我们试着让实验变得更简单，

153
00:04:49,580 --> 00:04:51,200
0,60 60,300 300,660 690,1350 1410,1620
to make lab simpler {},|
|

154
00:04:51,200 --> 00:04:52,010
0,240 240,390 390,510 510,570 570,810
{in,fact}, this is a new
事实上，这是一个新的实验，

155
00:04:52,010 --> 00:04:53,720
0,450 480,840 840,1140 1140,1560 1560,1710
lab,| a lab we did
|一个我们之前没有的实验。

156
00:04:53,720 --> 00:04:55,000
0,240 240,420 420,570 570,960
not have that lab.|
|

157
00:04:54,980 --> 00:04:56,390
0,690 690,870 870,960 960,1320 1320,1410
{} In the hopes that
希望实际上，

158
00:04:56,390 --> 00:04:58,130
0,330 330,600 600,780 780,1470 1470,1740
actually| make this introduction or
|使引入或转换到虚拟内存变得更容易，

159
00:04:58,130 --> 00:04:59,660
0,120 120,600 600,1080 1080,1230 1260,1530
the transition into a virtual

160
00:04:59,660 --> 00:05:02,000
0,270 270,810 1140,1620 1620,2040 2100,2340
memory easier,| {} in some
|在某些方面我认为是成功的，

161
00:05:02,000 --> 00:05:02,630
0,210 210,240 240,420 420,540 540,630
ways I think it was

162
00:05:02,630 --> 00:05:03,920
0,540 540,630 630,780 780,1200 1200,1290
successful,| in other ways, you
|在其他方面，这仍然很难，

163
00:05:03,920 --> 00:05:05,540
0,120 120,240 240,420 420,810 1470,1620
know it's still hard,| so
|所以我们不太清楚，

164
00:05:05,540 --> 00:05:06,470
0,120 120,300 300,480 480,720 720,930
we don't really know,| maybe
|什么是最简单的方法，

165
00:05:06,470 --> 00:05:07,760
0,180 180,510 510,930 930,1170 1170,1290
about the easiest way| of
|引入虚拟内存编程。

166
00:05:07,760 --> 00:05:10,310
0,540 750,1500 1500,1830 1830,2100 2100,2550
actually introducing virtual memory programming

167
00:05:10,310 --> 00:05:10,980
0,360
is.|
|

168
00:05:11,170 --> 00:05:14,740
0,390 420,930 930,1560 1590,2250 2490,3570
{} Lab {}, the lab
下周的惰性分配实验，

169
00:05:14,740 --> 00:05:16,480
0,390 390,720 720,960 960,1290 1290,1740
next week, the lazy lab|
|

170
00:05:16,510 --> 00:05:17,470
0,150 150,420 420,480 480,780 780,960
is actually a lab that
实际上曾经是第一个虚拟内存实验。

171
00:05:17,470 --> 00:05:18,460
0,210 210,270 270,390 390,510 510,990
used to be the first

172
00:05:18,490 --> 00:05:19,900
0,570 570,840 840,1260
virtual memory lab.|
|

173
00:05:20,180 --> 00:05:21,800
0,540 570,900 900,1350 1350,1470 1470,1620
And my suspicion is that
我猜你们今年会发现，

174
00:05:21,800 --> 00:05:23,540
0,150 150,570 1020,1260 1260,1560 1560,1740
you'll find this year {},|
|

175
00:05:23,540 --> 00:05:25,250
0,420 630,1170 1170,1350 1350,1410 1410,1710
lab easier than the students
实验比去年的要容易，

176
00:05:25,250 --> 00:05:26,960
0,270 270,390 390,720 720,1050 1170,1710
found it last year,| because
|因为你现在在虚拟内存方面有了更多的背景知识。

177
00:05:26,960 --> 00:05:27,860
0,150 150,330 330,510 510,690 690,900
you now have much more

178
00:05:27,860 --> 00:05:30,340
0,600 600,1260 1470,1950 1950,2250
background in virtual memory.|
|

179
00:05:33,100 --> 00:05:35,590
0,210 210,360 360,660 660,1410 2130,2490
Okay, so that's {}, there
好的，所以这是一个很好的停止点，

180
00:05:35,590 --> 00:05:36,100
0,90 90,150 150,270 270,450 450,510
is a good point to

181
00:05:36,100 --> 00:05:37,420
0,330 330,450 450,960 960,1080 1080,1320
stop,| this was a couple
|这里我想提出的几个高层次的观点，

182
00:05:37,420 --> 00:05:38,440
0,150 150,390 390,660 660,750 750,1020
high level points I wanted

183
00:05:38,440 --> 00:05:40,540
0,60 60,330 330,960 960,1440 1440,2100
to make,| before jumping into
|在跳到更具技术性和更多细节之前，

184
00:05:40,540 --> 00:05:42,100
0,270 300,540 540,1260 1260,1380 1380,1560
{} more technical with more

185
00:05:42,100 --> 00:05:43,270
0,600 630,840 840,960 960,1050 1050,1170
details,| so if you have
|所以，如果你有任何问题，现在就是提问题的好时机。

186
00:05:43,270 --> 00:05:44,410
0,150 150,570 570,660 660,750 750,1140
any questions, is a great

187
00:05:44,440 --> 00:05:46,040
0,390 390,600 600,960 960,1500
time to ask questions.|
|

188
00:05:51,450 --> 00:05:54,820
0,570 750,1470 1830,2310 2310,3030
Okay {}.| Let's {},
好的。|让我们，快点，你知道，你们中的一些人问到这个，

189
00:05:55,000 --> 00:05:56,860
0,960 990,1530 1530,1590 1590,1680 1680,1860
quickly, {} you know some

190
00:05:56,860 --> 00:05:57,730
0,90 90,210 210,450 450,540 540,870
of you asked for this,|
|

191
00:05:57,760 --> 00:05:59,620
0,270 270,600 600,870 870,1380 1380,1860
{} very quick review exactly
非常快速地回顾一下具体设置是什么，

192
00:05:59,620 --> 00:06:01,630
0,540 540,630 630,1560 1590,1770 1770,2010
what you were what the

193
00:06:02,200 --> 00:06:05,140
0,420 420,780 1170,1710 2010,2400 2400,2940
setting is,| {} and so,
|所以，基本上，设置页表，

194
00:06:05,720 --> 00:06:07,820
0,600 600,660 660,1050 1050,1350 1350,2100
basically, the settings {pagetables -},|
|

195
00:06:11,270 --> 00:06:13,730
0,570 570,990 990,1470 1470,1860 1860,2460
and we have physical memory
我们在右边画出物理内存，

196
00:06:14,090 --> 00:06:15,460
0,450 450,570 570,1080
draw here {},

197
00:06:15,570 --> 00:06:17,700
0,300 300,870 1230,1800 1800,1950 1950,2130
right side,| {} you know
|你知道物理内存，包含部分设备，

198
00:06:17,700 --> 00:06:20,220
0,180 180,750 750,1380 1410,2040 2070,2520
the physical memory, {} consist

199
00:06:20,220 --> 00:06:22,400
0,330 330,720 720,1200 1200,2040
of partly about devices,|
|

200
00:06:23,920 --> 00:06:26,920
0,180 180,540 540,1140 1200,2730 2730,3000
and they live above this
它们在这个 0x00 以及更多的零之上，

201
00:06:26,920 --> 00:06:27,840
0,150 150,780
{0x -}

202
00:06:28,800 --> 00:06:31,080
0,270 270,540 540,1410 1500,1860 1860,2280
zero zero {} and many

203
00:06:31,080 --> 00:06:32,180
0,210 210,930
more zeros,|
|

204
00:06:32,460 --> 00:06:34,110
0,150 150,420 420,720 720,1140 1140,1650
and then here basically dram
然后这里是 DRAM 芯片。

205
00:06:34,110 --> 00:06:34,840
0,600
chips.|
|

206
00:06:37,780 --> 00:06:39,370
0,510 510,780 780,990 990,1260 1260,1590
And we know that {}|
我们知道，|

207
00:06:39,370 --> 00:06:40,930
0,390 390,690 690,900 900,960 960,1560
QEMU actually puts the kernel,
QEMU 将内核文本数据放在这里，

208
00:06:40,930 --> 00:06:42,820
0,90 90,330 330,660 660,1170 1200,1890
the kernel text data, right

209
00:06:43,270 --> 00:06:44,920
0,1380
here,|
|

210
00:06:45,730 --> 00:06:47,770
0,450 450,840 840,1230 1230,1590 1590,2040
{at,the} above 0x zero zero
在 0x00 之上，

211
00:06:47,770 --> 00:06:48,790
0,420 510,720 720,840 840,960 960,1020
zero,| so that's where the
|这就是内核所在的地方，

212
00:06:48,790 --> 00:06:50,800
0,330 330,750 870,1530 1530,1890 1890,2010
kernel lives,| and one way
|其中一种可能是，

213
00:06:50,800 --> 00:06:52,270
0,90 90,210 210,420 930,1290 1290,1470
it may be,| earse this
|擦掉这个来使用内核。

214
00:06:52,270 --> 00:06:53,440
0,60 60,240 240,540 780,930 930,1170
a little bit to use

215
00:06:53,440 --> 00:06:54,340
0,60 60,690
the kernel.|
|

216
00:06:54,600 --> 00:06:55,830
0,330 330,420 420,480 480,870 870,1230
And you know basically literally
你知道从字面上它是什么意思，

217
00:06:55,830 --> 00:06:56,610
0,120 120,270 270,600 600,690 690,780
what it means,| you know
|你知道这是什么，内核就是用户指令，

218
00:06:56,610 --> 00:06:57,300
0,300 300,390 390,510 510,630 630,690
what this is what the

219
00:06:57,300 --> 00:06:59,140
0,480 480,630 630,960 960,1710
kernel is user instructions,|
|

220
00:07:01,850 --> 00:07:03,590
0,540 540,1020 1020,1140 1140,1260 1260,1740
binary versions of the assembling
是你已经看到的汇编指令的二进制版本，

221
00:07:03,590 --> 00:07:05,300
0,510 510,750 750,960 960,1140 1140,1710
instructions {} that you've seen,|
|

222
00:07:05,480 --> 00:07:07,160
0,540 600,840 840,1080 1080,1230 1230,1680
and there's also some data
还有一些数据结构位于这些地址。

223
00:07:07,570 --> 00:07:09,970
0,600 600,1290 1410,1710 1710,1920 1920,2400
structures located {} at these

224
00:07:10,150 --> 00:07:11,180
0,810
addresses.|
|

225
00:07:12,760 --> 00:07:14,230
0,210 210,390 390,660 660,1050 1080,1470
Okay, so that's the memory
好的，这就是内存的部分，

226
00:07:14,230 --> 00:07:15,310
0,210 210,270 270,570 600,900 900,1080
part of it| and then
|然后在另一边，我们有 CPU ，

227
00:07:15,310 --> 00:07:16,690
0,120 120,210 210,360 360,900 1050,1380
on the other side {}

228
00:07:16,690 --> 00:07:18,460
0,420 420,570 570,690 690,1440
we got our CPU,|
|

229
00:07:19,040 --> 00:07:21,890
0,210 210,630 630,1350 1920,2370 2370,2850
that executes instructions.| CPU has
它执行指令。|CPU 有很多内部指令，

230
00:07:21,890 --> 00:07:23,460
0,360 360,870 870,1350
{a,bunch,of} internal state,|
|

231
00:07:24,140 --> 00:07:26,030
0,480 480,900 900,1050 1050,1140 1140,1890
{} and has some registers,|
并且有一些寄存器，|

232
00:07:26,030 --> 00:07:28,070
0,90 90,210 210,750 1290,1530 1530,2040
you know whatever {x0 -}
你知道 x0 或 r0 等，

233
00:07:28,070 --> 00:07:29,900
0,300 420,690 690,1350 1350,1650 1650,1830
or {r0 -} blah blah

234
00:07:29,900 --> 00:07:31,970
0,600 780,1470 1470,1590 1590,1710 1710,2070
blah,| and you know maybe
|还有程序计数器。

235
00:07:31,970 --> 00:07:33,280
0,120 120,480 480,990
the program counter.|
|

236
00:07:33,790 --> 00:07:35,050
0,570 570,690 690,780 780,990 990,1260
And you know when {xv6
你知道在 xv6 启动的时候，

237
00:07:35,050 --> 00:07:36,970
0,480 480,1050 1050,1200 1200,1350 1350,1920
-} starts,| you know the
|程序计数器包含值 Ox8000 。

238
00:07:37,580 --> 00:07:39,110
0,150 150,570 570,930 930,1350 1350,1530
{} program counter contains this

239
00:07:39,110 --> 00:07:40,580
0,450 450,690 690,870 870,1200 1200,1470
value {Ox8000 - - -

240
00:07:40,580 --> 00:07:41,700
0,270 270,900
- -}.|
|

241
00:07:41,900 --> 00:07:44,260
0,630 630,1320 1500,2070

242
00:07:44,920 --> 00:07:46,630
0,570 570,840 840,1200 1200,1290 1290,1710
{} And that's the way
这就是它的方式，

243
00:07:46,630 --> 00:07:47,770
0,120 120,210 210,330 330,750 750,1140
you know,| the CPU knows
|CPU 查看这个地址，

244
00:07:47,770 --> 00:07:49,240
0,150 150,660 750,1140 1140,1230 1230,1470
that basically look at that

245
00:07:49,240 --> 00:07:50,290
0,330 330,450 450,780 780,930 930,1050
address| to find you know
|找出第一条指令，

246
00:07:50,290 --> 00:07:51,550
0,120 120,390 390,990 990,1110 1110,1260
the first instruction,| it looks
|它查看第一个指令并解码指令，

247
00:07:51,550 --> 00:07:52,900
0,90 90,180 180,390 390,900 900,1350
at the first instruction decode

248
00:07:52,900 --> 00:07:55,480
0,720 930,1470 1530,1950 1950,2280 2280,2580
instruction| and updates whatever CPU
|然后更新需要更新的 CPU 状态。

249
00:07:55,480 --> 00:07:56,290
0,270 270,390 390,570 570,630 630,810
state that needs to be

250
00:07:56,290 --> 00:07:56,980
0,360
updated.|
|

251
00:07:58,280 --> 00:08:00,200
0,510 540,990 990,1440 1440,1680 1680,1920
{You,know} {pagetables -} and {sort,of}
页表和其他一些组件，

252
00:08:00,200 --> 00:08:01,910
0,480 480,600 600,960 1050,1620 1620,1710
component to it| that you
|这个地址包含，

253
00:08:01,910 --> 00:08:02,990
0,120 120,300 300,840 840,960 960,1080
know the addresses you know|

254
00:08:02,990 --> 00:08:05,280
0,240 240,960 1230,2040
the CPU {}
CPU 命令或指令，

255
00:08:05,640 --> 00:08:08,040
0,690 990,1500 1500,1710 1710,1800 1800,2400
{} orders or the instructions

256
00:08:08,040 --> 00:08:09,360
0,0 0,330 330,390 390,510 510,1320
are part of the instructions,|
|

257
00:08:09,420 --> 00:08:10,440
0,300 300,360 360,540 540,900 900,1020
like you know jump to
比如，跳到某个特定的地址，

258
00:08:10,440 --> 00:08:12,180
0,180 180,510 510,1020 1320,1470 1470,1740
some particular address| and those
|并且这些地址通常是虚拟地址。

259
00:08:12,180 --> 00:08:13,080
0,690
addresses

260
00:08:13,210 --> 00:08:15,310
0,420 420,1020 1020,1230 1230,1590 1590,2100
are typically or most commonly

261
00:08:15,310 --> 00:08:17,320
0,300 300,660 660,960 990,1410 1410,2010
or will be virtual addresses.|
|

262
00:08:17,860 --> 00:08:19,990
0,570 870,1080 1080,1230 1230,1560 1560,2130
And now there's virtual addresses,
这是虚拟地址，

263
00:08:20,020 --> 00:08:22,420
0,270 270,390 390,720 720,1200 2280,2400
go to that [] is
由 MMU 管理。

264
00:08:22,420 --> 00:08:23,660
0,210 210,270 270,570 570,990
called the {MMU -}.|
|

265
00:08:24,160 --> 00:08:25,540
0,360 360,600 600,750 750,1230 1230,1380
And then you translate into
然后转换成物理地址，

266
00:08:25,540 --> 00:08:26,780
0,390 390,990
physical addresss,|
|

267
00:08:27,840 --> 00:08:30,090
0,630 630,1380 1410,1680 1680,2100 2100,2250
um, and {} that is
并且索引到

268
00:08:30,090 --> 00:08:32,370
0,270 270,510 510,960 960,1770 1920,2280
allowing [] index into| either
|内存的 IO 部分，

269
00:08:32,370 --> 00:08:33,840
0,270 270,930 930,1260 1260,1350 1350,1470
the IO part of the

270
00:08:33,840 --> 00:08:35,580
0,420 420,810 810,960 960,1440 1440,1740
memory| or the DRAM part
|或者内存的 DRAM 部分。

271
00:08:35,580 --> 00:08:36,240
0,90 90,420
the memory.|
|

272
00:08:37,040 --> 00:08:39,680
0,540 630,1350 1860,2400

273
00:08:40,040 --> 00:08:41,750
0,150 150,810 810,1020 1020,1200 1200,1710
To control how this translation
为了控制这个转换发生，

274
00:08:41,750 --> 00:08:43,190
0,540 540,630 630,750 750,1020 1020,1440
happens,| you know there's this
|你知道这里有 satp 寄存器，

275
00:08:43,190 --> 00:08:44,660
0,540 540,1200
satp register,|
|

276
00:08:46,570 --> 00:08:49,750
0,330 330,1110 1140,1770 1770,2400 2670,3180
which contains {} the root
它包含页表的根地址，

277
00:08:49,750 --> 00:08:51,790
0,210 210,720 960,1440 1440,1800 1830,2040
of the {pagetable -}| of
|即当前运行的页表。

278
00:08:51,790 --> 00:08:53,170
0,90 90,480 480,750 750,990 990,1380
the current running page table.|
|

279
00:08:53,470 --> 00:08:54,840
0,150 150,270 270,450 450,1080
And if there's zero,|
如果是零，

280
00:08:55,410 --> 00:08:57,240
0,390 390,600 600,1080 1080,1320 1320,1830
then there's basically no translation
那么就不会进行转换，

281
00:08:57,240 --> 00:08:59,400
0,270 270,750 930,1680 1710,1980 1980,2160
going on| and {} the
|并且虚拟地址直接指向物理地址，

282
00:08:59,400 --> 00:09:01,020
0,300 300,540 540,660 660,1170 1170,1620
virtual address is literally directly

283
00:09:01,020 --> 00:09:02,130
0,60 60,360 360,750 780,930 930,1110
{} physical address,| so when
|因此，当处理器启动时，

284
00:09:02,130 --> 00:09:03,600
0,60 60,540 540,780 780,1080 1080,1470
the processor actually starts up,|
|

285
00:09:03,870 --> 00:09:04,980
0,300 300,540 540,660 660,1020 1020,1110
{} there's no value in
satp 中没有值，

286
00:09:04,980 --> 00:09:06,150
0,150 150,780 780,870 870,1110 1110,1170
{satp -}| and when the
|当程序计数器是 0x... 时，

287
00:09:06,150 --> 00:09:08,580
0,360 360,870 960,1440 1440,1590 1590,2430
program counter as an 0x...,|
|

288
00:09:08,580 --> 00:09:10,230
0,270 420,1020 1020,1110 1110,1410 1410,1650
{you,know} basically the physical address
物理地址也是[]，

289
00:09:10,230 --> 00:09:11,700
0,120 120,570 570,780 780,1200 1290,1470
is also {} []| and
|CPU 从该特定位置获取指令。

290
00:09:11,700 --> 00:09:14,010
0,420 420,810 810,930 930,1620 1890,2310
basically [] the CPU fetches

291
00:09:14,010 --> 00:09:15,750
0,60 60,780 870,1200 1200,1380 1380,1740
the instruction from that particular

292
00:09:15,750 --> 00:09:16,500
0,450
location.|
|

293
00:09:17,260 --> 00:09:18,220
0,150 150,540 540,720 720,840 840,960
As soon as you know
一旦，

294
00:09:18,220 --> 00:09:18,920
0,450
the,|
|

295
00:09:19,720 --> 00:09:21,400
0,600 660,990 990,1080 1080,1320 1320,1680
as soon as the satp
一旦 satp 包含非零值，

296
00:09:21,400 --> 00:09:22,870
0,270 270,810 810,930 930,1170 1170,1470
actually contains a non zero

297
00:09:22,870 --> 00:09:23,680
0,600
value,|
|

298
00:09:23,880 --> 00:09:25,890
0,810 900,1650 1650,1800 1800,1890 1890,2010
then, {} you know, for
那么，例如，可能，在这里的某个地方，

299
00:09:25,890 --> 00:09:28,440
0,450 450,1020 1230,1770 1920,2160 2160,2550
example maybe {} so somewhere

300
00:09:28,440 --> 00:09:29,640
0,210 210,480 480,780 780,1080 1080,1200
in here| to draw them
|把图片延伸一些，

301
00:09:29,640 --> 00:09:30,810
0,150 150,390 390,840 840,1110 1110,1170
make something extended pictures a

302
00:09:30,810 --> 00:09:33,150
0,120 120,600 930,1590 1800,2010 2010,2340
bit further,| {} we know
|我们知道内核实际上最多有 128 兆字节。

303
00:09:33,150 --> 00:09:34,680
0,330 330,720 750,990 990,1290 1290,1530
that the kernel actually has

304
00:09:34,680 --> 00:09:35,860
0,60 60,750
a maximum

305
00:09:36,270 --> 00:09:37,920
0,720 720,1470
128 megabytes.|
|

306
00:09:38,350 --> 00:09:39,280
0,180 180,300 300,630 630,840 840,930
And so basically this is
所以基本上这些都是空闲内存，

307
00:09:39,280 --> 00:09:41,230
0,510 510,750 750,1200 1200,1380 1380,1950
all free memory,| from here
|从这里到这里是空闲内存，

308
00:09:42,070 --> 00:09:45,070
0,780 930,1200 1200,1380 1380,2010 2490,3000
{to,there} is free memory| and
|空闲内存放在 kalloc.c 中的列表中，

309
00:09:45,070 --> 00:09:46,780
0,180 180,630 630,930 960,1320 1320,1710
free memory is {} put

310
00:09:46,780 --> 00:09:48,490
0,210 210,510 540,960 960,1530 1530,1710
on the list in {}

311
00:09:48,490 --> 00:09:49,540
0,360 360,570 570,810 810,930 930,1050
{kalloc.c - -}| as you've
|像你之前看到的那样。

312
00:09:49,540 --> 00:09:50,400
0,180 180,660
seen before.|
|

313
00:09:50,940 --> 00:09:52,620
0,630 630,750 750,990 990,1500 1500,1680
And, {} so somewhere in
并且，这里的某个地方也是根页表，

314
00:09:52,620 --> 00:09:54,270
0,570 720,900 900,1260 1260,1410 1410,1650
here is also the root

315
00:09:54,270 --> 00:09:56,340
0,240 240,660 690,1290 1350,1800 1800,2070
{pagetable -}| for {you,know,a} kernel
|你知道的，内核页表，

316
00:09:56,340 --> 00:09:57,720
0,240 240,570 600,870 900,1170 1170,1380
{pagetable -},| so maybe here's
|可能这里有一些页面，

317
00:09:57,720 --> 00:09:58,580
0,120 120,720
some page,|
|

318
00:09:58,860 --> 00:10:00,060
0,150 150,300 300,510 510,600 600,1200
and that it's the root
是根页表目录。

319
00:10:01,760 --> 00:10:03,760
0,360 390,930 1020,1650
{} {pagetable -}

320
00:10:04,330 --> 00:10:07,540
0,840 1950,2700 2700,2940 2940,3120 3120,3210
directory.| {} As soon as
|一旦我们加载该值，

321
00:10:07,540 --> 00:10:08,950
0,120 120,480 480,690 690,1230 1260,1410
we load that value| the
|该值对应的物理地址，

322
00:10:08,950 --> 00:10:10,750
0,810 840,1050 1050,1140 1140,1470 1470,1800
address of the physical address

323
00:10:10,750 --> 00:10:11,920
0,60 60,240 240,660 660,1050 1050,1170
of that value| into the
|进入 satp 地址和寄存器，

324
00:10:11,920 --> 00:10:14,290
0,390 390,870 900,1410 1410,1950 2130,2370
satp address and register {},|
|

325
00:10:14,290 --> 00:10:15,730
0,180 180,450 450,900 930,1260 1260,1440
let's say this maybe this
假设这个地址是 0x7ff... ，

326
00:10:15,730 --> 00:10:16,660
0,690
addresses

327
00:10:16,780 --> 00:10:17,960
0,360 360,1020
{0x -}

328
00:10:18,680 --> 00:10:20,360
0,660 720,870 870,1020 1020,1290 1290,1680
seven, you know f f

329
00:10:20,390 --> 00:10:22,340
0,390 390,870 870,1350 1350,1680 1680,1950
blah blah,| something just below
|一个低于 120 兆字节的地址，

330
00:10:22,340 --> 00:10:23,630
0,120 120,180 180,420 420,1140 1140,1290
one hundred twenty megabytes,| so
|所以在内存空闲空间中，

331
00:10:23,630 --> 00:10:24,710
0,120 120,330 330,540 540,990 990,1080
in that free space of

332
00:10:24,710 --> 00:10:26,930
0,540 840,1140 1140,1380 1380,1740 1740,2220
memory| below that address in
|在 satp 中地址，

333
00:10:27,110 --> 00:10:28,400
0,240 240,1080
{satp -},|
|

334
00:10:28,630 --> 00:10:29,600
0,720
then,
然后，在这时，处理器或 MMU

335
00:10:31,370 --> 00:10:32,360
0,150 150,330 330,750 750,840 840,990
at that point you know

336
00:10:32,360 --> 00:10:34,010
0,300 330,750 750,1080 1080,1350 1350,1650
the processor or {} {MMU

337
00:10:34,010 --> 00:10:36,080
0,480 630,960 960,1680 1680,1980 1980,2070
-}| {} will use the
|将使用根页表执行

338
00:10:36,080 --> 00:10:37,280
0,180 180,450 450,870 870,990 990,1200
root {pagetables -} to actually|
|

339
00:10:37,280 --> 00:10:39,260
0,120 120,210 210,1110 1410,1560 1560,1980
do the translation from virtual
从虚拟地址到物理地址的转换。

340
00:10:39,260 --> 00:10:40,320
0,90 90,390 390,870
to physical address.|
|

341
00:10:41,670 --> 00:10:42,720
0,600 600,690 690,810 810,960 960,1050
And you can think of
你可以把这整个东西，

342
00:10:42,720 --> 00:10:44,880
0,330 330,780 780,1320 1320,1650 1650,2160
this, this particular whole thing,|
|

343
00:10:45,090 --> 00:10:46,470
0,240 240,360 360,630 630,720 720,1380
sort of being a single
像是一个盒子，

344
00:10:46,470 --> 00:10:47,520
0,240 240,360 360,840 840,930 930,1050
sort of box,| you know
|你知道，将它们整合在一起。

345
00:10:47,520 --> 00:10:49,890
0,810 840,960 960,1290 1560,1830 1830,2370
integrated you know, {} together.|
|

346
00:10:51,860 --> 00:10:52,850
0,180 180,360 360,480 480,810 810,990
And you have questions about
你对这张高层次图片有问题吗，

347
00:10:52,850 --> 00:10:55,130
0,90 90,510 510,870 870,1500 1710,2280
this high-level picture,| before {}
|在继续之前，

348
00:10:56,700 --> 00:10:57,780
0,180 180,300 300,570 720,900 900,1080
keep them going,| so one
|所以这里要记住的一个关键点是，

349
00:10:57,780 --> 00:10:58,860
0,90 90,180 180,390 390,690 690,1080
of the key points to

350
00:10:58,890 --> 00:11:00,000
0,390 390,630 630,720 720,870 870,1110
remember here is| that the
|页面状态本身也驻留在内存中。

351
00:11:00,150 --> 00:11:02,130
0,330 330,750 750,1410 1440,1800 1800,1980
page statements themselves also live

352
00:11:02,130 --> 00:11:02,820
0,90 90,480
in memory.|
|

353
00:11:08,500 --> 00:11:09,300
0,570
Okay.|
好吧。|

354
00:11:11,090 --> 00:11:12,500
0,240 240,360 360,570 570,1170 1170,1410
Okay, so let's jump down
好的，那我们跳到，

355
00:11:12,500 --> 00:11:13,860
0,420 420,1110
to {},|
|

356
00:11:14,520 --> 00:11:16,680
0,690 720,870 870,1140 1140,1530 1560,2160
{} the first part of
页表实验的第一部分，

357
00:11:16,710 --> 00:11:17,790
0,180 180,300 300,510 510,810 810,1080
{} the {pagetable -} lab,|
|

358
00:11:17,790 --> 00:11:19,340
0,600 630,1260
namely {}
也就是第一部分，

359
00:11:19,400 --> 00:11:21,140
0,480 480,810 810,1230 1230,1500 1500,1740
part one where you have

360
00:11:21,140 --> 00:11:23,900
0,210 210,810 900,1650 1920,2520
to| print {} the
|为 init 程序打印页表，

361
00:11:24,410 --> 00:11:26,600
0,510 540,750 750,1140 1140,1530 1530,2190
{} {pagetable -} for the

362
00:11:27,140 --> 00:11:30,530
0,210 210,480 510,1410 1590,2610 2640,3390
{init -} program,| and um,
|你知道的，解释基本上都在图 3.4 ，

363
00:11:31,140 --> 00:11:33,030
0,510 540,1080 1080,1230 1230,1380 1410,1890
and {} you know explain

364
00:11:33,030 --> 00:11:34,110
0,90 90,480 480,570 570,960 960,1080
it basically in terms of

365
00:11:34,110 --> 00:11:36,480
0,360 390,990 990,1530 1530,1860 1890,2370
this figure {three,four}| and figure
|图 3.4 就在这里。

366
00:11:36,480 --> 00:11:37,980
0,240 240,300 300,780 780,1230
{three,four} is right here.|
|

367
00:11:39,980 --> 00:11:42,200
0,300 300,480 480,990 1140,1890 1890,2220
Figure three four {},| and
图 3.4 ，|这是图 3.4 ，显示用户地址空间，

368
00:11:42,200 --> 00:11:43,580
0,300 300,390 390,780 780,1020 1020,1380
this is figure {three,four} shows

369
00:11:43,580 --> 00:11:45,170
0,90 90,300 300,570 570,1050 1200,1590
the user address space,| just
|让我们看看的用户地址空间，

370
00:11:45,170 --> 00:11:46,100
0,270 270,540 540,630 630,720 720,930
let's look at the user

371
00:11:46,100 --> 00:11:47,330
0,210 210,420 420,540 540,840 840,1230
address space for {a,second},| {before,we}
|在进入细节之前，

372
00:11:47,420 --> 00:11:49,160
0,300 300,540 540,630 630,1200 1410,1740
are going to detail {},|
|

373
00:11:49,160 --> 00:11:50,090
0,150 150,270 270,510 510,600 600,930
so we have the text
我们在底部有文本，

374
00:11:50,090 --> 00:11:51,020
0,90 90,150 150,510 510,660 660,930
at the bottom,| so this
|这就是程序的指令，

375
00:11:51,020 --> 00:11:52,820
0,90 90,210 210,1050 1110,1680 1680,1800
is the instructions of the

376
00:11:52,820 --> 00:11:55,550
0,660 750,1230 1230,1560 1560,2190 2430,2730
program,| starting address zero {}|
|从地址 0 开始，|

377
00:11:55,550 --> 00:11:58,010
0,330 330,510 510,1260 1290,1770 1800,2460
above the instructions are data,
上方是数据、全局变量，驻留在那里，

378
00:11:58,040 --> 00:12:00,590
0,420 420,1110 1140,1650 1650,2100 2340,2550
global variables, live there {},|
|

379
00:12:00,590 --> 00:12:01,580
0,210 210,420 420,690 690,930 930,990
then there's something called the
然后我们会讨论守护页，

380
00:12:01,580 --> 00:12:03,170
0,330 330,630 630,870 870,1110 1110,1590
guard page we'll talk about,|
|

381
00:12:03,170 --> 00:12:04,880
0,90 90,270 270,450 450,720 1020,1710
and then it's the stack
然后是用户程序的堆栈，

382
00:12:04,910 --> 00:12:06,530
0,180 180,750 750,990 990,1410 1410,1620
of the user program,| so
|内核有自己的堆栈，

383
00:12:06,590 --> 00:12:07,700
0,90 90,390 390,630 630,930 930,1110
the kernel has its own

384
00:12:07,700 --> 00:12:09,860
0,390 420,1110 1110,1380 1380,1710 1710,2160
stack {},| {} multiple stack|
|多个堆栈，|

385
00:12:10,190 --> 00:12:11,450
0,330 330,720 720,990 990,1140 1140,1260
{} user program has its
用户程序有自己的堆栈，

386
00:12:11,450 --> 00:12:13,010
0,150 150,570 780,1020 1020,1320 1320,1560
own stack| and buff again
|缓冲区，也就是所谓堆内存，空闲内存，

387
00:12:13,010 --> 00:12:14,150
0,90 90,510 510,690 690,930 930,1140
is basically what's called heap

388
00:12:14,150 --> 00:12:16,310
0,780 870,1140 1140,1650 1770,1950 1950,2160
memory, free memory,| you know
|我们可以使用 sbrk 获得更多内存，

389
00:12:16,310 --> 00:12:18,260
0,120 120,480 630,1080 1080,1740
we can get more

390
00:12:18,290 --> 00:12:20,450
0,240 240,840 1020,1260 1260,1530 1530,2160
{} memory {} using sbrk,|
|

391
00:12:20,450 --> 00:12:22,490
0,210 210,690 690,1170 1170,1620 1620,2040
so sbrk basically points to
sbrk 基本上指向用户地址空间的顶部，

392
00:12:22,990 --> 00:12:24,670
0,150 150,690 720,900 900,1230 1260,1680
the top of the user

393
00:12:24,670 --> 00:12:25,660
0,240 240,540 540,780 780,930 930,990
address space,| we want to
|我们想要增加它，

394
00:12:25,660 --> 00:12:27,010
0,300 300,540 630,900 900,1170 1170,1350
grow it,| we called {sbrk
|我们调用 sbrk 系统调用

395
00:12:27,010 --> 00:12:29,740
0,240 240,510 510,990 1230,1710 1710,2730
-} system call to grow|
|

396
00:12:29,770 --> 00:12:31,330
0,630 630,810 840,1140 1140,1230 1230,1560
grow the top of the,
来增加底部部分，

397
00:12:32,410 --> 00:12:33,430
0,120 120,300 300,390 390,660 660,1020
to grow the bottom part,|
|

398
00:12:33,430 --> 00:12:34,960
0,90 90,210 210,750 1230,1470 1470,1530
you know up into the
你知道增加到堆里去，

399
00:12:34,960 --> 00:12:36,850
0,390 870,1230 1230,1440 1440,1620 1620,1890
heap,| we also know that
|我们还从上一节课中知道，顶端，

400
00:12:36,850 --> 00:12:37,540
0,330
the

401
00:12:37,630 --> 00:12:39,160
0,570 600,930 930,1140 1140,1260 1260,1530
top, there from the last

402
00:12:39,160 --> 00:12:40,000
0,300 300,450 450,540 540,600 600,840
lecture,| that there are two
|有两个页面，

403
00:12:40,000 --> 00:12:42,460
0,600 600,750 750,1140 1140,1710 2040,2460
pages,| two special pages the
|两个特别的页面， trampoline 和 trapframe 页面。

404
00:12:42,460 --> 00:12:44,950
0,540 540,720 720,1470 1500,2040 2040,2490
trampoline and the trapframe page.|
|

405
00:12:45,260 --> 00:12:46,520
0,210 210,270 270,750 750,1110 1110,1260
And the trampoline page, {you,know}
trampoline 页包含了命令，

406
00:12:46,520 --> 00:12:47,840
0,390 390,480 480,1170 1170,1230 1230,1320
contains the instructions to the

407
00:12:47,840 --> 00:12:49,040
0,330 330,840 840,960 960,1050 1050,1200
basically,| transition in and out
|进出内核的转换的命令，

408
00:12:49,040 --> 00:12:50,480
0,60 60,120 120,690 990,1170 1170,1440
of the kernel,| the {trapframe
|trapframe 是一个很方便的地方，

409
00:12:50,480 --> 00:12:54,140
0,360 360,600 600,1620 2910,3300 3300,3660
-} is a convenient place,|
|

410
00:12:54,140 --> 00:12:55,280
0,180 180,540 540,900
{you,know} to {}
存储一些状态，当我们跳入内核时，

411
00:12:55,460 --> 00:12:56,960
0,390 390,510 510,1140 1140,1290 1290,1500
stores from state and when

412
00:12:56,960 --> 00:12:59,330
0,120 120,330 330,1080 1500,1920 1950,2370
we jump into the kernel,|
|

413
00:12:59,330 --> 00:13:00,290
0,270 270,420 420,660 660,720 720,960
because we need the kernel
因为我们就需要内核，一旦使用寄存器，

414
00:13:00,290 --> 00:13:01,730
0,240 240,570 570,1110 1110,1230 1230,1440
once use registers,| we can
|我们可以使用寄存器，

415
00:13:01,730 --> 00:13:02,780
0,180 180,270 270,690 690,930 930,1050
use the registers,| because the
|因为用户空间程序还有一些在使用。

416
00:13:02,780 --> 00:13:04,070
0,270 270,510 510,870 870,1110 1110,1290
user space program still has

417
00:13:04,070 --> 00:13:05,360
0,210 600,1140
some {in,use}.|
|

418
00:13:06,140 --> 00:13:06,890
0,150 150,300 300,420 420,600 600,750
I'm not gonna talk much
我不会太多谈论 tramframe 和 trampoline ，

419
00:13:06,890 --> 00:13:08,270
0,240 240,720 720,1080 1080,1230 1230,1380
about tramframe and trampoline {at,all},|
|

420
00:13:08,270 --> 00:13:09,440
0,90 90,360 360,510 510,690 690,1170
you know they are there.|
你知道的，它们在这里。|

421
00:13:10,340 --> 00:13:12,620
0,570 690,1050 1050,1170 1170,1890 1890,2280
{} OK, so here this
好的，在这张图片的下面一点，

422
00:13:12,620 --> 00:13:14,300
0,300 300,330 330,510 510,1290 1290,1680
picture a little below {},|
|

423
00:13:14,300 --> 00:13:15,740
0,150 150,270 270,600 600,990 990,1440
you know is actually there,
你知道就在那里，是打印出来的，

424
00:13:16,120 --> 00:13:18,910
0,510 810,1290 1380,1890 1890,2250 2250,2790
{} {} printout from {},|
|

425
00:13:18,910 --> 00:13:20,680
0,420 420,570 570,750 750,1050 1380,1770
when I run it, {}
当我运行它时，从 init 打印出来的。

426
00:13:20,680 --> 00:13:21,880
0,300 300,480 480,960
from {init -}.|
|

427
00:13:22,420 --> 00:13:24,880
0,180 180,300 300,960 1170,2010 2010,2460
This the first successful call
这是 exec 的第一次成功调用，

428
00:13:24,880 --> 00:13:26,950
0,540 660,1230 1260,1500 1500,1680 1680,2070
of exec right,| so we
|我们知道 init 代码中有一些 exec 系统调用，

429
00:13:26,950 --> 00:13:27,850
0,150 150,300 300,420 420,510 510,900
know that {init -} code

430
00:13:27,850 --> 00:13:29,170
0,210 210,360 360,630 630,840 840,1320
makes some system call exec,|
|

431
00:13:29,410 --> 00:13:30,790
0,420 420,540 540,930 930,1080 1080,1380
for the program {init -}
对于程序 init ，正好在 exec 的末尾，

432
00:13:30,790 --> 00:13:32,260
0,420 510,1050 1050,1170 1170,1290 1290,1470
and just at the end

433
00:13:32,260 --> 00:13:33,820
0,90 90,180 180,1080 1080,1290 1290,1560
of the exec,| we're printing
|我们打印出那个页表。

434
00:13:33,820 --> 00:13:34,860
0,240 240,480 480,810
out that pagetable.|
|

435
00:13:35,460 --> 00:13:36,240
0,210 210,300 300,390 390,600 600,780
And so a couple things
有几个我们可以观察到的东西，

436
00:13:36,240 --> 00:13:37,680
0,120 120,780 810,1200 1200,1380 1380,1440
that we, many things we

437
00:13:37,680 --> 00:13:39,840
0,120 120,660 870,1170 1170,1410 1410,2160
can observe,| about this particular
|关于这个特殊的页表，

438
00:13:39,840 --> 00:13:42,090
0,210 210,690 930,1620 1770,2160 2160,2250
{pagetable -},| so first of
|首先，

439
00:13:42,090 --> 00:13:44,220
0,480 480,630 630,750 750,1410 1950,2130
all you know,| we in
|除了打印出物理 pte ，

440
00:13:44,220 --> 00:13:45,690
0,360 360,870 870,1050 1050,1350 1350,1470
addition to {} printing out

441
00:13:45,690 --> 00:13:46,950
0,90 90,450 450,1110 1110,1200 1200,1260
the physical ptes| and the
|物理地址也打印出了标志。

442
00:13:46,950 --> 00:13:48,390
0,240 240,540 540,780 840,1230 1230,1440
physical address is also printing

443
00:13:48,390 --> 00:13:49,300
0,90 90,180 180,810
out the flags.|
|

444
00:13:50,040 --> 00:13:51,210
0,450 450,690 690,960 960,1050 1050,1170
{} And you can see
你可以看到，这里的标志是 1 ，

445
00:13:51,210 --> 00:13:52,530
0,150 150,450 450,690 690,1140 1140,1320
here that here flag is

446
00:13:52,530 --> 00:13:54,390
0,540 750,960 960,1290 1290,1680 1680,1860
one,| and basically says this
|基本上就是这个转换，

447
00:13:54,390 --> 00:13:56,520
0,720 720,900 900,1230 1320,1650 1650,2130
translation,| or this, {} intermediate
|或者这个中间页像这个一样，

448
00:13:56,520 --> 00:14:00,060
0,450 1290,1830 1830,2310 2520,3000 3000,3540
page is that similar here,|
|

449
00:14:00,210 --> 00:14:01,770
0,270 270,540 540,1260 1260,1470 1470,1560
{you,know} is valid {independent -
是有效的独立页，

450
00:14:01,770 --> 00:14:02,940
0,180 180,480 480,630 630,780 780,1170
-} page,| and this basically
|这对应于二级页面，

451
00:14:02,940 --> 00:14:05,340
0,720 1290,1440 1440,1740 1890,2220 2220,2400
corresponds to the level two

452
00:14:05,340 --> 00:14:06,660
0,600 630,810 810,960 960,1020 1020,1320
page| and then the second
|然后第二个对应于……。

453
00:14:06,660 --> 00:14:08,370
0,240 240,1140 1140,1230 1230,1320 1320,1710
one corresponds to the level....|
|

454
00:14:12,110 --> 00:14:13,280
0,210 210,570 600,720 720,960 960,1170
I'm sorry I just threw
我很抱歉我刚才画错了箭头，

455
00:14:13,280 --> 00:14:14,540
0,150 150,540 540,870 870,1020 1020,1260
the arrows wrong,| so that's
|所以我暂停一下。

456
00:14:14,540 --> 00:14:15,590
0,270 270,450 480,870 870,990 990,1050
why a pause for a

457
00:14:15,590 --> 00:14:16,360
0,420
second.|
|

458
00:14:17,210 --> 00:14:18,650
0,90 90,150 150,720 1110,1290 1290,1440
At the top, this is
在顶端，这是顶层页表，

459
00:14:18,650 --> 00:14:20,030
0,150 150,390 390,570 570,840 840,1380
the top level {pagetable -},|
|

460
00:14:20,580 --> 00:14:22,470
0,570 870,1410 1410,1530 1530,1650 1650,1890
{} this, you know points
这个，指向这个特定的页表，

461
00:14:22,470 --> 00:14:24,210
0,330 330,540 540,900 900,1170 1170,1740
to this particular {pagetable -},|
|

462
00:14:24,650 --> 00:14:27,410
0,900 930,1500 1650,2040 2040,2400 2430,2760
and this points to that
这个，指向那个特定的页表。

463
00:14:27,410 --> 00:14:28,440
0,270 270,480 480,840
particular {pagetable -}.|
|

464
00:14:29,180 --> 00:14:30,380
0,240 240,450 450,570 570,990 990,1200
Or that's the address, we're
或者这就是地址，我们使用一种速记，用来表示，

465
00:14:30,380 --> 00:14:31,640
0,300 300,570 570,960 960,1140 1140,1260
pointing to a sort of

466
00:14:31,640 --> 00:14:33,980
0,660 660,780 780,1260 1500,2010 2010,2340
shorthand for saying,| {} that
|这是特定页面的基础地址。

467
00:14:33,980 --> 00:14:35,660
0,120 120,480 540,1080 1080,1500 1500,1680
is the base address for

468
00:14:35,660 --> 00:14:36,960
0,150 150,600 600,1170
that particular page.|
|

469
00:14:37,310 --> 00:14:38,420
0,330 330,420 420,660 660,870 870,1110
And you know {} these
你知道，这些页面有 4096 字节，

470
00:14:38,420 --> 00:14:42,590
0,720 960,1920 1950,3000 3330,4020 4020,4170
pages 4096 bytes,| {} it's
|大小是页的大小，

471
00:14:42,590 --> 00:14:44,300
0,330 330,420 420,1140 1200,1560 1560,1710
size of {page,size},| and so
|除以 64 会得到 512 个条目。

472
00:14:44,300 --> 00:14:46,490
0,390 390,540 540,1560 1770,2040 2040,2190
divided by 64 its going

473
00:14:46,490 --> 00:14:48,160
0,150 150,330 330,1050 1050,1560
to get 512 entries.|
|

474
00:14:49,200 --> 00:14:51,000
0,510 690,1020 1020,1230 1230,1470 1470,1800
{} Okay so we'll see
好的，我们看这个地址空间的底部部分。

475
00:14:51,000 --> 00:14:52,950
0,150 150,780 810,1410 1410,1800 1830,1950
is the bottom part of

476
00:14:52,950 --> 00:14:54,820
0,450 720,1050 1050,1680
this address space.|
|

477
00:14:55,020 --> 00:14:56,280
0,270 270,480 480,600 600,810 810,1260
{You,know}, for {init -} basically
对于 init ，实际上只有有三个页面，

478
00:14:56,280 --> 00:14:58,280
0,690 720,1110 1110,1320 1320,1890
has actually all this,

479
00:14:58,930 --> 00:15:00,160
0,240 240,420 420,960
has three pages,

480
00:15:00,580 --> 00:15:02,980
0,360 360,540 540,1140 1500,2040 2040,2400
only three pages,| {} and
|我们做几件事，

481
00:15:02,980 --> 00:15:03,730
0,210 210,300 300,360 360,570 570,750
we do a couple things|
|

482
00:15:03,730 --> 00:15:05,530
0,90 90,150 150,630 780,1260 1260,1800
that we can {} discern
可以把这三页区分出来。

483
00:15:05,530 --> 00:15:06,700
0,150 150,240 240,390 390,1020
from the three pages.|
|

484
00:15:06,840 --> 00:15:08,160
0,300 300,420 420,570 570,720 720,1320
{} We know that the
我们知道，底部页面对应虚拟地址零，

485
00:15:08,400 --> 00:15:11,010
0,690 690,1350 1530,1890 1890,2220 2220,2610
bottom page which basically corresponds

486
00:15:11,010 --> 00:15:12,300
0,60 60,120 120,420 420,660 660,1290
to the virtual address zero,|
|

487
00:15:12,450 --> 00:15:14,220
0,420 420,870 870,1230 1230,1680 1680,1770
{} this physical address, you
这个物理地址， 87f640 。

488
00:15:14,220 --> 00:15:15,990
0,120 120,360 360,600 600,1080 1560,1770
know eight seven six four

489
00:15:15,990 --> 00:15:16,740
0,540
zero.|
|

490
00:15:17,080 --> 00:15:18,880
0,390 390,840 840,960 960,1350 1350,1800
{} And you know from
你可以从我们之前的图片中知道，

491
00:15:18,910 --> 00:15:21,220
0,300 300,600 600,990 990,1560 1650,2310
our previous picture,| {that,is} somewhere
|那就在空闲内存中的某个地方，

492
00:15:21,220 --> 00:15:23,680
0,210 210,630 900,1260 1290,1740 1740,2460
in that {} free memory,|
|

493
00:15:23,860 --> 00:15:25,300
0,210 210,420 420,480 480,1170 1170,1440
{} that the kernel has
内核可以从中分配页面。

494
00:15:25,300 --> 00:15:26,980
0,480 480,600 600,990 990,1320 1320,1680
available to allocate pages from.|
|

495
00:15:28,330 --> 00:15:30,070
0,750 750,900 900,1290 1290,1620 1620,1740
And the final things you
最后你看到的是标志，

496
00:15:30,070 --> 00:15:31,600
0,150 150,240 240,900 1110,1320 1320,1530
see the flags,| we see
|我们看到标志 1f ，

497
00:15:31,600 --> 00:15:33,190
0,90 90,450 450,810 810,1230 1440,1590
the flags one f,| so
|所以它意味着读取位设置，

498
00:15:33,190 --> 00:15:38,410
0,120 120,450 450,660 660,4890 4890,5220
it means that {read,bit,set},| {valid,bit,set\,,read,bit,set\,,w,bit,set},
|有效位设置，读取位设置，写位设置，执行位设置，用户位设置，

499
00:15:38,440 --> 00:15:40,540
0,480 480,1020 1020,1200 1200,1830
execute {bit,set} and {u,bit,set},|
|

500
00:15:41,500 --> 00:15:42,790
0,210 210,360 360,600 600,930 930,1290
{} so this page can
所以这个页面可以同时包含数据和文本，

501
00:15:42,790 --> 00:15:45,280
0,840 840,1320 1350,1800 1800,1950 1950,2490
contain both data and text,|
|

502
00:15:45,570 --> 00:15:48,450
0,450 450,780 780,1710 1890,2670 2670,2880
and these permissions allow the
这些权限允许用户程序

503
00:15:48,450 --> 00:15:51,060
0,210 210,840 870,1380 1380,2010 2010,2610
user program| {} to execute
|在对应的内存执行指令，

504
00:15:51,060 --> 00:15:52,230
0,450 450,690 690,870 870,960 960,1170
instructions from or to the

505
00:15:52,230 --> 00:15:54,060
0,240 240,900 1110,1470 1470,1710 1710,1830
right memory,| {} and do
|并从用户空间执行。

506
00:15:54,060 --> 00:15:55,160
0,120 120,270 270,480 480,990
it from user space.|
|

507
00:15:56,700 --> 00:15:57,720
0,240 240,390 390,690 690,960 960,1020
Okay, so then maybe the
好的，那么也许最有趣的问题是，

508
00:15:57,720 --> 00:15:58,740
0,180 180,450 450,750 750,900 900,1020
most interesting question is| like
|第一页有什么问题。

509
00:15:58,740 --> 00:15:59,910
0,270 270,420 420,570 570,780 780,1170
what's up with page one.|
|

510
00:16:00,660 --> 00:16:01,800
0,660 690,810 810,900 900,1080 1080,1140
And you know as a
作为一个提示，

511
00:16:01,800 --> 00:16:02,820
0,420 420,540 540,690 690,900 900,1020
hint,| you know see that
|你知道，第一页只有 f ，

512
00:16:02,820 --> 00:16:05,070
0,210 210,690 960,1530 1530,1830 1830,2250
page one only has f|
|

513
00:16:05,070 --> 00:16:05,940
0,120 120,390 390,480 480,690 690,870
and not the u bit
而没有设置 u 标志位。

514
00:16:05,940 --> 00:16:06,520
0,420
set.|
|

515
00:16:06,850 --> 00:16:08,440
0,690 720,1170 1170,1290 1290,1350 1350,1590
So, {} you know what
所以，你知道第一页是什么吗。

516
00:16:08,440 --> 00:16:10,340
0,150 150,330 330,540 540,1020
is the page one.|
|

517
00:16:11,880 --> 00:16:12,780
0,660
Anybody.|
有人知道吗。|

518
00:16:15,370 --> 00:16:18,970
0,210 210,480 480,1320 1530,2610 2970,3600
Is it {the,guard,page}.| Yeah, {it's,the,guard,page,right}.|
是不是守护页。|是的，是守护页。|

519
00:16:19,360 --> 00:16:20,740
0,240 240,390 390,480 480,960 960,1380
{} So the {guard,page} {}
守护页映射到，

520
00:16:20,740 --> 00:16:22,810
0,270 270,780 840,1290 1290,1440 1440,2070
is mapped,| because {it,has,a} {v,in}
|因为它包含 v 标志，

521
00:16:22,810 --> 00:16:24,190
0,240 240,510 510,690 690,1050 1050,1380
it,| but it has not
|而没有设置 u 标志，

522
00:16:24,190 --> 00:16:26,050
0,210 210,390 390,660 660,1110 1350,1860
u bit set,| so any
|所以任何用户指令试图，

523
00:16:26,050 --> 00:16:27,670
0,270 270,780 780,930 930,1260 1260,1620
user instruction that tries to,|
|

524
00:16:27,700 --> 00:16:29,140
0,180 180,420 420,630 630,870 870,1440
so if a user program
因此，如果用户程序运行超过它的堆栈，

525
00:16:29,170 --> 00:16:30,730
0,510 510,660 660,780 780,1260 1260,1560
runs off its stack,| so
|堆栈从顶部向下增长，

526
00:16:30,760 --> 00:16:31,810
0,150 150,390 390,660 660,810 810,1050
the stack grows from the

527
00:16:32,300 --> 00:16:33,830
0,870 870,1170 1170,1380 1380,1440 1440,1530
{top,down},| so even if it
|所以即使它真的有更多，

528
00:16:33,830 --> 00:16:35,930
0,300 300,480 480,1080 1710,2010 2010,2100
actually has more,| stack is
|堆栈足够大，可以容纳 4096 ，

529
00:16:35,930 --> 00:16:36,980
0,150 150,330 330,540 540,1020 1020,1050
big enough for 4096 are

530
00:16:36,980 --> 00:16:39,680
0,390 390,900 1050,1290 1290,1800 2010,2700
completely full,| and then {}
|然后用户程序，你知道的，把东西放到到堆栈上，

531
00:16:39,710 --> 00:16:41,090
0,360 360,840 840,900 900,1050 1050,1380
user program, you know puts

532
00:16:41,090 --> 00:16:42,080
0,0 0,420 420,510 510,570 570,990
{} something on the stack,|
|

533
00:16:42,080 --> 00:16:43,310
0,330 330,510 510,690 690,1140 1140,1230
stack on the [], it
堆栈在[]上，它将增长到守护页。

534
00:16:43,310 --> 00:16:44,330
0,120 120,360 360,630 630,720 720,1020
will grow into the guard

535
00:16:44,330 --> 00:16:45,000
0,510
page.|
|

536
00:16:45,140 --> 00:16:46,250
0,360 360,570 570,630 630,900 900,1110
And because the {u,bit} is
并且因为没有设置 u 标志位，

537
00:16:46,250 --> 00:16:48,080
0,240 240,630 870,1410 1410,1620 1620,1830
not set,| {} we gotta
|我们会在内核中得到页面错误或陷阱，

538
00:16:48,080 --> 00:16:49,460
0,150 150,180 180,420 420,870 990,1380
get a page fault or

539
00:16:49,460 --> 00:16:50,720
0,60 60,390 390,630 630,720 720,1260
a trap into the kernel,|
|

540
00:16:51,020 --> 00:16:53,990
0,780 810,1230 1230,2040 2310,2820 2820,2970
{} because the {MMU -}
因为 MMU 不能转换地址到，

541
00:16:53,990 --> 00:16:56,300
0,360 360,810 810,900 900,1500 1500,2310
cannot translate to address {}

542
00:16:56,450 --> 00:16:59,180
0,450 480,840 840,1230 1470,2070 2070,2730
to,| cannot address cannot translate
|不能将守护页上的地址转换为物理地址，

543
00:16:59,180 --> 00:17:00,500
0,150 150,540 540,690 690,870 960,1320
any addresses on the guard

544
00:17:00,500 --> 00:17:02,960
0,450 510,780 780,1110 1110,1620 1860,2460
page to physical address,| because
|因为没有设置 u 标志位，

545
00:17:02,960 --> 00:17:04,820
0,240 240,660 960,1560 1560,1770 1770,1860
the [] not having a

546
00:17:04,820 --> 00:17:06,500
0,330 330,660 660,960 960,1050 1050,1680
{u,bit}| basically forbids the translation.|
|这会禁止转换。|

547
00:17:08,560 --> 00:17:09,610
0,270 270,480 480,540 540,810 810,1050
Okay, what is that page
好的，第二页是什么。

548
00:17:09,610 --> 00:17:10,300
0,450
two.|
|

549
00:17:15,740 --> 00:17:16,620
0,90 90,630
Any,
有人知道吗？

550
00:17:18,450 --> 00:17:19,360
0,630
Anybody.|
|

551
00:17:19,710 --> 00:17:21,540
0,780 840,1260 1260,1470 1470,1560 1560,1830
Stack?| Yup, that's the stack
堆栈？|是的，这是堆栈页，

552
00:17:21,540 --> 00:17:23,070
0,450 930,1170 1170,1230 1230,1440 1440,1530
page| and so again the
|堆栈页有 4096 字节，

553
00:17:23,070 --> 00:17:24,990
0,240 240,510 510,1350 1350,1770 1770,1920
stack page for forty four

554
00:17:24,990 --> 00:17:26,820
0,330 330,480 480,660 660,1170 1440,1830
thousand ninety six bytes| and
|你会看到，对于权限，这是精心设计的。

555
00:17:26,820 --> 00:17:28,080
0,390 390,600 600,840 840,1140 1140,1260
you'll see that's completely {elaborate

556
00:17:28,080 --> 00:17:29,760
0,480 480,600 600,870 870,960 960,1680
-} in terms of permissions.|
|

557
00:17:30,290 --> 00:17:31,700
0,630 630,840 840,1200 1200,1260 1260,1410
{} And {it,has} you know
它包含所有权限，

558
00:17:31,700 --> 00:17:33,650
0,510 930,1320 1320,1590 1590,1860 1860,1950
everything,| could we set it
|我们能不能把它的权限调得更严格一些。

559
00:17:33,650 --> 00:17:35,000
0,150 150,750 780,990 990,1050 1050,1350
up tighter if we wanted

560
00:17:35,000 --> 00:17:35,640
0,390
to.|
|

561
00:17:38,230 --> 00:17:39,580
0,300 300,480 480,750 750,960 960,1350
Yeah I think you could
是的，我想可以禁用执行位。

562
00:17:39,580 --> 00:17:42,100
0,630 630,870 870,1950 1950,2130 2130,2520
disable the executive {} bit.|
|

563
00:17:42,390 --> 00:17:44,070
0,510 510,720 720,990 990,1200 1200,1680
Yeah, you probably could execute
是的，你可以，对 x 位来说，

564
00:17:44,070 --> 00:17:47,700
0,1350 1350,1890 2160,2820 2910,3210 3210,3630
the {x,bit},}| that would forbid
|这将禁止运行堆栈上任何程序代码。

565
00:17:47,700 --> 00:17:49,290
0,420 420,630 630,1020 1020,1380 1380,1590
run any program code on

566
00:17:49,290 --> 00:17:50,100
0,60 60,630
the stack.|
|

567
00:17:50,750 --> 00:17:52,190
0,180 180,300 300,660 690,1200 1200,1440
So if you generate code
所以，如果你在运行时生成代码并将其放入堆栈，

568
00:17:52,190 --> 00:17:53,090
0,90 90,180 180,630 630,750 750,900
on the fly and put

569
00:17:53,090 --> 00:17:53,930
0,90 90,150 150,210 210,600 600,840
it on the stack,| you
|你就不能去执行，

570
00:17:53,930 --> 00:17:54,470
0,150 150,210 210,300 300,480 480,540
wouldn't to be able to

571
00:17:54,470 --> 00:17:56,180
0,540 840,990 990,1110 1110,1410 1410,1710
execute,| you know that maybe
|你知道这可能是件好事。

572
00:17:56,180 --> 00:17:57,160
0,300 300,360 360,510 510,720
probably a good thing.|
|

573
00:17:57,710 --> 00:17:59,270
0,570 900,1050 1050,1170 1170,1260 1260,1560
{} And so we could
所以我们可以把权限设置更严格一些。

574
00:17:59,270 --> 00:17:59,960
0,180 180,330 330,420 420,570 570,690
have been a little bit

575
00:17:59,960 --> 00:18:00,620
0,420
tighter.|
|

576
00:18:01,350 --> 00:18:03,160
0,600 930,1590
Okay, um.|
好的。|

577
00:18:03,820 --> 00:18:05,290
0,150 150,420 420,1110 1110,1200 1200,1470
So that's basically the bottom
所以这是这个的最下面的部分，

578
00:18:05,290 --> 00:18:07,270
0,240 240,330 330,780 840,1170 1170,1980
part of this, {} {}|

579
00:18:07,990 --> 00:18:09,490
0,660 660,750 780,1050 1050,1410 1410,1500
{} the {pagetable -},| so
页表，|现在让我们来看看剩下的条目，

580
00:18:09,490 --> 00:18:10,720
0,180 180,420 420,600 600,690 690,1230
now let's look at the

581
00:18:10,870 --> 00:18:12,850
0,480 480,1050 1200,1380 1380,1740 1740,1980
remaining entries,| so basically only
|只剩下两个条目了。

582
00:18:12,850 --> 00:18:14,340
0,300 300,690 690,1320
two remaining entries.|
|

583
00:18:14,560 --> 00:18:17,170
0,660 750,1560 1740,2130 2130,2250 2250,2610
{} And maybe the flag
也许标志位是最能说明问题的部分。

584
00:18:17,170 --> 00:18:18,070
0,210 210,270 270,360 360,600 600,900
bits are the most telling

585
00:18:18,070 --> 00:18:19,000
0,240 240,330 330,780
part of this.|
|

586
00:18:19,150 --> 00:18:21,140
0,510 510,1020 1050,1770
{} So seven,
这里的 7 ，表示可读，可写，可用。

587
00:18:21,770 --> 00:18:22,940
0,420 420,540 540,630 630,960 960,1170
{} you know means {you,know}

588
00:18:22,940 --> 00:18:24,700
0,630 780,1590
read write

589
00:18:26,670 --> 00:18:28,140
0,390 390,780 780,1260
and valid work.|
|

590
00:18:29,340 --> 00:18:31,290
0,720 720,1080 1080,1350 1350,1890 1890,1950
{} And so what do
那么这个是什么，

591
00:18:31,290 --> 00:18:32,100
0,120 120,600
we think,

592
00:18:33,010 --> 00:18:34,180
0,300 300,510 510,780 780,900 900,1170
that one is| and maybe
|也许我先分析另一个页的权限，

593
00:18:34,180 --> 00:18:34,930
0,210 210,330 330,450 450,600 600,750
I'll do the other one

594
00:18:34,930 --> 00:18:37,570
0,510 930,1260 1260,1830 1860,2370 2370,2640
too,| {} so b is
|b 是 1001 （误：应该是 1011），

595
00:18:37,570 --> 00:18:38,530
0,90 90,270 270,480 480,690 690,960
I think one zero zero

596
00:18:38,530 --> 00:18:40,600
0,420 420,720 720,1080 1080,1380 1380,2070
one,| so presumably x {and,valid},|
|设置了 x 和可用位，|

597
00:18:41,680 --> 00:18:42,430
0,270 270,420 420,540 540,600 600,750
{} so what do we
那么 511 是什么呢？

598
00:18:42,430 --> 00:18:44,180
0,540 570,840 840,1140 1140,1560
think five eleven is.|
|

599
00:18:48,890 --> 00:18:49,780
0,660
Anybody.|
有人知道吗。|

600
00:18:54,070 --> 00:18:56,560
0,600 690,1440 1440,1590 1590,1920 1920,2490
The trampoline and trap page?|
trampoline 和 trap 页面？|

601
00:18:57,520 --> 00:19:00,220
0,1950 1950,2130 2130,2430 2430,2640 2640,2700
{Yeah,so,the}, and probably {five -}
对，那么， 511 可能是 trampoline ，

602
00:19:00,220 --> 00:19:02,410
0,240 240,330 330,690 690,1230 1230,2190
eleven is definitely trampoline correct,|
|

603
00:19:02,410 --> 00:19:03,700
0,210 210,300 300,510 510,780 870,1290
because it has the {x,bit}
因为它设置了 x 位，

604
00:19:03,700 --> 00:19:05,020
0,390 660,870 870,1020 1020,1230 1230,1320
set,| so we must be
|所以我们可以执行，

605
00:19:05,020 --> 00:19:06,820
0,450 450,690 690,840 840,1350 1350,1800
executed| or we're allowing instructions
|或者我们允许从该页面执行指令。

606
00:19:06,820 --> 00:19:07,780
0,60 60,150 150,570 570,690 690,960
to be executed from that

607
00:19:08,020 --> 00:19:08,880
0,660
page.|
|

608
00:19:08,910 --> 00:19:09,600
0,150 150,330 330,360 360,570 570,690
So that {} must be
所以这一定是 trampoline ，

609
00:19:09,600 --> 00:19:11,940
0,60 60,750 1050,1380 1380,1710 1710,2340
a trampoline| and we're allowing
|我们允许对那个页面进行读写，

610
00:19:11,940 --> 00:19:13,380
0,480 510,630 630,780 780,1020 1020,1440
{read,write} you know to the

611
00:19:13,880 --> 00:19:15,500
0,870 900,1020 1020,1230 1230,1500 1500,1620
{} to that page,| so
|所以这可能就是 trapframe 页面，

612
00:19:15,500 --> 00:19:16,820
0,210 210,480 480,570 570,1020 1020,1320
that's probably the trapframe page,|
|

613
00:19:16,820 --> 00:19:17,570
0,180 180,390 390,450 450,630 630,750
because that's the one we
因为这是我们用来恢复和保存寄存器的那个页。

614
00:19:17,570 --> 00:19:19,540
0,300 300,420 420,1140 1140,1650
used to restore and

615
00:19:19,620 --> 00:19:21,420
0,210 210,690 720,1350 1350,1620
{} save registers in.|
|

616
00:19:22,230 --> 00:19:24,330
0,480 600,1320 1320,1440 1440,1950 1950,2100
Okay, one of the things,
好的，需要注意的一件重要的事是，

617
00:19:24,330 --> 00:19:26,220
0,90 90,600 960,1710 1710,1830 1830,1890
{} a important thing to

618
00:19:26,220 --> 00:19:27,330
0,270 270,570 570,780 780,930 930,1110
note is| there's no u
|这里没有设置 u 标志位，

619
00:19:27,330 --> 00:19:27,920
0,360
bit

620
00:19:29,190 --> 00:19:30,150
0,270 270,390 390,510 510,660 660,960
right then,| so {} what
|那么这意味着什么呢，

621
00:19:30,150 --> 00:19:31,110
0,90 90,300 300,600 600,750 750,960
does that mean,| that means
|这意味着用户程序不能执行指令，

622
00:19:31,110 --> 00:19:32,130
0,120 120,210 210,450 450,870 870,1020
that the user program can

623
00:19:32,130 --> 00:19:34,230
0,360 360,780 780,1170 1170,1230 1230,2100
actually not execute the instructions,|
|

624
00:19:34,500 --> 00:19:35,580
0,210 210,420 420,630 630,930 930,1080
{} that are actually at
页 510 作为 trampoline 页面，

625
00:19:35,580 --> 00:19:37,470
0,240 240,750 840,1290 1290,1350 1350,1890
five ten {} as a

626
00:19:37,500 --> 00:19:38,540
0,450 450,900
trampoline page,|
|

627
00:19:38,900 --> 00:19:40,130
0,300 300,720 720,810 810,930 930,1230
and can't be the write
也不能对该页的写入。

628
00:19:40,130 --> 00:19:41,870
0,60 60,270 270,660 1170,1470 1470,1740
to that page.| So only
|因此，只有内核可以从那里执行指令，

629
00:19:41,870 --> 00:19:43,520
0,60 60,630 720,870 870,1200 1200,1650
the kernel can execute instructions

630
00:19:43,520 --> 00:19:44,690
0,150 150,570 570,900 900,1050 1050,1170
from there| and it can
|而且它只能读写。

631
00:19:44,690 --> 00:19:45,660
0,210 210,360 360,450 450,780
only read and write.|
|

632
00:19:47,510 --> 00:19:49,160
0,180 180,690 690,1050 1050,1170 1170,1650
So basically like the kernel's
所以内核要做这件事，

633
00:19:49,160 --> 00:19:51,020
0,210 210,360 360,660 660,930 930,1860
gonna be doing this before

634
00:19:51,110 --> 00:19:52,820
0,360 570,990 990,1260 1260,1590 1590,1710
the,| while still using the
|当用户页表还在使用时，

635
00:19:52,820 --> 00:19:54,290
0,360 360,600 600,990 990,1290 1290,1470
user {pagetable -},| right, that's
|是不是这个意思。

636
00:19:54,290 --> 00:19:55,970
0,180 180,240 240,300 300,630 900,1680
kind of the point.| {Exactly,as,you,know},
|使得，正如你所知道的， Robert 在上节课中讲解的，

637
00:19:56,690 --> 00:19:58,610
0,480 480,840 840,1110 1110,1620 1680,1920
Robert explained last lecture,| this
|这就是从用户到内核的过渡，

638
00:19:58,610 --> 00:19:59,480
0,150 150,360 360,630 630,750 750,870
is like just for the

639
00:19:59,480 --> 00:20:01,100
0,600 600,840 840,1050 1050,1140 1140,1620
transition from user to kernel,|
|

640
00:20:01,100 --> 00:20:02,090
0,120 120,390 390,540 540,780 780,990
and before we jump to,|
在我们跳到之前，|

641
00:20:02,330 --> 00:20:03,260
0,330 330,660
before we
在我们将内核页表加载到 satp 寄存器之前，

642
00:20:03,320 --> 00:20:04,940
0,810 810,870 870,1110 1110,1320 1320,1620
load the kernel {pagetable -}

643
00:20:04,940 --> 00:20:06,620
0,150 150,690 690,1260 1290,1530 1530,1680
in satp register,| we need
|我们需要，

644
00:20:06,620 --> 00:20:07,460
0,60 60,300 300,480 480,690 720,840
a little bit of,| you
|内核需要一些内存来完成它的工作。

645
00:20:07,460 --> 00:20:08,690
0,240 570,810 810,1020 1020,1170 1170,1230
know the kernel needs a

646
00:20:08,690 --> 00:20:09,470
0,180 180,300 300,390 390,660 660,780
little bit of memory to

647
00:20:09,470 --> 00:20:10,420
0,210 210,300 300,420 420,780
actually do his job.|
|

648
00:20:11,990 --> 00:20:12,740
0,570
Okay.|
好的。|

649
00:20:13,200 --> 00:20:13,830
0,150 150,210 210,270 270,480 480,630
So in a couple of
所以在一些事情上，

650
00:20:13,830 --> 00:20:15,120
0,150 150,480 510,720 720,990 990,1290
things,| then {} maybe interesting
|这张图片有意思的地方。

651
00:20:15,120 --> 00:20:16,920
0,90 90,240 240,840 930,1560
of this picture {}.|
|

652
00:20:17,040 --> 00:20:18,060
0,270 270,450 450,570 570,840 840,1020
Yeah, so we all in
是的，所有的地址都是 87f630 ，

653
00:20:18,060 --> 00:20:19,440
0,210 210,390 390,870 870,1140 1140,1380
all these addresses go eight

654
00:20:19,440 --> 00:20:20,820
0,240 240,450 450,630 630,1200 1200,1380
seven six three zero,| eight
|87f620 ， 87f640 ， 87f610 ，

655
00:20:20,820 --> 00:20:22,050
0,210 210,480 480,870 870,1050 1050,1230
six two, four, seven one

656
00:20:22,050 --> 00:20:23,880
0,240 270,540 540,690 690,1200 1380,1830
of,| these are all pages
|这些页面或内存

657
00:20:23,880 --> 00:20:25,830
0,90 90,750 870,1080 1080,1320 1320,1950
or memory| in that range
|在内核内存范围内，

658
00:20:25,860 --> 00:20:28,710
0,960 1140,1860 1890,2610 2610,2760 2760,2850
of kernel memory| that is
|它们是空闲的。

659
00:20:28,710 --> 00:20:29,760
0,390 390,480 480,600 600,720 720,1050
{} you know it's basically

660
00:20:29,760 --> 00:20:30,960
0,420 600,960
free, right.|
|

661
00:20:31,260 --> 00:20:33,780
0,570 780,1530 1650,1890 1890,2070 2070,2520
{} And are these addresses
那么这些地址在物理内存中是连续的吗？

662
00:20:33,780 --> 00:20:34,920
0,270 270,930
are contiguous

663
00:20:41,920 --> 00:20:43,180
0,240 240,540 540,1020
in physical memory.|
|

664
00:20:47,040 --> 00:20:47,920
0,660
Anybody.|
有人知道吗。|

665
00:20:49,270 --> 00:20:50,320
0,300 300,480 480,630 630,870 870,1050
{} No they don't have
不是，它们不一定连续。

666
00:20:50,320 --> 00:20:52,180
0,150 150,360 1110,1560 1560,1680 1680,1860
to be.| No, they don't
|不，它们不一定连续，是的，

667
00:20:52,180 --> 00:20:52,720
0,150 150,210 210,330 330,420 420,540
have to be in the

668
00:20:52,720 --> 00:20:53,920
0,360 360,720 720,810 810,960 960,1200
are, correct,| you know look
|你知道吗，看这个， 87f6400 ，

669
00:20:53,920 --> 00:20:55,120
0,60 60,420 420,510 510,840 870,1200
at this, you know seven

670
00:20:55,120 --> 00:20:56,530
0,240 240,480 480,660 660,1200 1200,1410
six four zero zero,| if
|如果是连续的，

671
00:20:56,530 --> 00:20:57,850
0,120 120,690 690,870 870,1050 1050,1320
it contiguous,| the next address
|下一个地址应该是 87f6500 ，

672
00:20:57,850 --> 00:20:59,050
0,150 150,240 240,510 510,810 840,1200
would have been eight seven

673
00:20:59,050 --> 00:21:00,910
0,510 510,600 600,930 1080,1530 1530,1860
six you know six five

674
00:21:00,910 --> 00:21:02,080
0,360 360,660 660,780 780,900 900,1170
zero,| and it isn't it.|
|但事实并非如此。|

675
00:21:02,680 --> 00:21:04,360
0,420 420,840 870,1110 1110,1350 1350,1680
{} So there's {you,know} one
所以关于页表的一个很酷的事情是，

676
00:21:04,360 --> 00:21:05,650
0,90 90,480 510,780 780,1050 1050,1290
of the cool things about

677
00:21:05,650 --> 00:21:07,360
0,240 240,630 630,960 1080,1470 1470,1710
{pagetables -} is| that even
|尽管你使用的虚拟地址空间是连续的，

678
00:21:07,360 --> 00:21:08,680
0,300 300,600 600,720 720,930 930,1320
though maybe you do virtual

679
00:21:08,680 --> 00:21:10,480
0,240 240,780 840,1020 1020,1140 1140,1800
address space {} is contiguous,|
|

680
00:21:10,510 --> 00:21:12,280
0,240 240,630 630,870 870,1380 1410,1770
the physical address space| or
物理地址空间，|或与连续虚拟地址对应的物理页面，

681
00:21:12,280 --> 00:21:13,300
0,90 90,390 390,720 720,870 870,1020
the physical pages that go

682
00:21:13,300 --> 00:21:15,250
0,450 450,900 930,1170 1170,1590 1590,1950
along with a continuous virtual

683
00:21:15,250 --> 00:21:16,870
0,450 510,780 780,1140 1170,1440 1440,1620
addresses| are not don't have
|不一定是连续的。

684
00:21:16,870 --> 00:21:17,820
0,60 60,150 150,750
to be continuous.|
|

685
00:21:17,880 --> 00:21:18,720
0,210 210,360 360,570 570,630 630,840
So this gives the kernel
因此，这给了内核很大的灵活性，

686
00:21:18,720 --> 00:21:20,280
0,60 60,210 210,270 270,1170 1260,1560
a lot of flexibility| in
|在分配和释放页面方面。

687
00:21:20,280 --> 00:21:23,460
0,300 300,780 780,1560 1560,2730 2850,3180
terms of allocation and freeing

688
00:21:23,460 --> 00:21:24,100
0,540
pages.|
|

689
00:21:25,050 --> 00:21:25,820
0,570
Okay.|
好的。|

690
00:21:26,910 --> 00:21:29,220
0,270 270,660 660,960 960,1950
Any questions about {this,part,one}.|
关于第一部分，有什么问题吗。|

691
00:21:29,980 --> 00:21:31,270
0,210 210,360 360,390 390,870 990,1290
I had a question.| Yeah.|
我有一个问题。|嗯。|

692
00:21:31,270 --> 00:21:32,100
0,570

693
00:21:32,470 --> 00:21:33,760
0,210 210,330 330,750 750,1050 1050,1290
Could you explain the {sbrk
你能稍微解释一下 sbrk 吗，

694
00:21:33,760 --> 00:21:34,900
0,180 180,360 360,600 600,690 690,1140
- - -} a little,|
|

695
00:21:35,020 --> 00:21:36,700
0,630 750,1050 1050,1320 1320,1530 1530,1680
{} also if we are
如果我们要在未来的讲座中介绍，

696
00:21:36,700 --> 00:21:37,540
0,120 120,210 210,630 630,750 750,840
going to cover in a

697
00:21:37,540 --> 00:21:39,130
0,390 390,900 900,1080 1080,1470 1470,1590
future lecture,| then maybe we
|那么也许我们可以先讲一点。

698
00:21:39,130 --> 00:21:40,840
0,360 390,570 570,840 840,900 900,1710
can like just a small.|
|

699
00:21:40,870 --> 00:21:42,400
0,510 510,810 810,1140 1140,1290 1290,1530
Yeah actually we, {} let
对，其实我们，

700
00:21:42,400 --> 00:21:43,060
0,180 180,300 300,420 420,480 480,660
me,| I'm going to talk
|我将在星期三谈论它。

701
00:21:43,060 --> 00:21:44,260
0,180 180,270 270,360 360,960
about it on Wednesday.|
|

702
00:21:44,340 --> 00:21:45,360
0,180 180,300 300,600 600,900 900,1020
And it actually will be
这实际上是惰性分配实验的话题。

703
00:21:45,360 --> 00:21:46,290
0,90 90,450 450,540 540,630 630,930
the topic of the lazy

704
00:21:46,290 --> 00:21:46,900
0,420
lab.|
|

705
00:21:47,320 --> 00:21:49,210
0,750 1050,1260 1260,1440 1440,1620 1620,1890
{} So let me maybe
那么我可能在星期三回答这个问题，

706
00:21:49,210 --> 00:21:51,760
0,330 330,930 930,1440 1440,2100 2100,2550
{responed,the,question} to Wednesday,| and then
|如果到时候还不太清楚，请再问一遍。

707
00:21:51,760 --> 00:21:53,200
0,240 240,450 450,630 630,1140 1140,1440
that's not clear enough, please

708
00:21:53,200 --> 00:21:54,080
0,240 240,330 330,630
ask it again.|
|

709
00:21:54,470 --> 00:21:55,760
0,330 330,600 600,840 840,1050
Sounds good, thank you.|
好的，谢谢。|

710
00:21:57,530 --> 00:21:59,840
0,720 720,1200 1200,1470 1470,1560 1560,2310
{} So had a question.|
有一个问题。|

711
00:22:00,170 --> 00:22:02,460
0,600 1080,1530 1530,2040
{} So, {}
所以，我记得书上说，

712
00:22:02,950 --> 00:22:05,230
0,240 240,1230 1260,1740 1800,2010 2010,2280
I remember that the book

713
00:22:05,230 --> 00:22:06,850
0,420 420,1110 1110,1260 1260,1320 1320,1620
said| trampoline and the {trapframe
| trampoline 和 trapframe 位于地址空间的顶部。

714
00:22:06,850 --> 00:22:08,290
0,390 390,810 810,1050 1050,1140 1140,1440
-} were at the top

715
00:22:08,290 --> 00:22:10,640
0,180 180,330 330,660 660,1320
of the address space.|
|

716
00:22:11,140 --> 00:22:13,960
0,570 600,840 840,1740 1890,2070 2070,2820
{} Right here, it stops
而在这里，它位于第一个根页面，

717
00:22:13,960 --> 00:22:15,970
0,750 900,1350 1350,1500 1500,1920 1920,2010
at like the first the

718
00:22:15,970 --> 00:22:17,530
0,210 210,450 450,750 750,1410 1410,1560
root {pagetable -}| indexes at
|索引是 255 而不是 511 。

719
00:22:17,530 --> 00:22:19,210
0,180 180,510 510,900 900,1170 1230,1680
two five five not five

720
00:22:19,210 --> 00:22:21,070
0,210 210,660 840,1050 1050,1470 1470,1860
one one.| Yeah brilliant question,
|好问题，很好，很高兴你问我。

721
00:22:21,070 --> 00:22:22,000
0,210 210,420 450,600 600,840 840,930
very good, I'm glad you

722
00:22:22,000 --> 00:22:24,220
0,510 510,960 960,1200 1200,2070 2100,2220
asked.| I saw in the
|我在 Q&A 问题中看到了，我打算讨论一下，

723
00:22:24,220 --> 00:22:25,270
0,180 180,270 270,450 450,930 930,1050
{Q&A - -} questions and

724
00:22:25,270 --> 00:22:25,990
0,60 60,180 180,420 420,540 540,720
I was planning to talk

725
00:22:25,990 --> 00:22:26,740
0,210 210,300 300,450 450,660 660,750
about it,| {but,of} course I've
|但是，我忘了。

726
00:22:26,740 --> 00:22:27,380
0,330
forgot.|
|

727
00:22:27,540 --> 00:22:28,950
0,480 630,870 870,1050 1050,1230 1230,1410
So yeah what's going on
所以，是的，这里发生了什么，

728
00:22:28,950 --> 00:22:30,510
0,330 360,900 900,1140 1140,1320 1320,1560
here,| why is two five
|为什么是 255 而不是 511 。

729
00:22:30,510 --> 00:22:31,820
0,300 300,420 420,660 660,1050
five not five eleven.|
|

730
00:22:33,180 --> 00:22:35,220
0,240 240,990 1200,1350 1350,1680 1680,2040
Yeah, {we - - -}
我们总说 trampoline 位于地址空间的顶端，

731
00:22:35,220 --> 00:22:36,360
0,210 210,420 420,510 510,960 960,1140
always say the trampoline lives

732
00:22:36,360 --> 00:22:36,930
0,60 60,120 120,390 390,450 450,570
at the top of the

733
00:22:36,930 --> 00:22:38,610
0,270 270,660 660,1140 1230,1500 1500,1680
address space,| while the top
|它所在的地址空间的顶部，

734
00:22:38,610 --> 00:22:39,600
0,90 90,210 210,510 510,840 840,990
of the address space where

735
00:22:39,600 --> 00:22:41,760
0,240 510,1200 1230,1500 1500,1950 1950,2160
it is,| {you,know} point is
|你知道的，指向顶级目录的 511 条目，

736
00:22:41,760 --> 00:22:43,620
0,300 300,630 630,840 840,1260 1530,1860
actually entry five eleven of

737
00:22:43,620 --> 00:22:45,240
0,480 480,750 750,930 930,1410
the top level directory,|
|

738
00:22:45,690 --> 00:22:46,530
0,270 270,390 390,480 480,690 690,840
and it is only two
而现在只是 255 。

739
00:22:46,530 --> 00:22:47,380
0,180 180,660
five five.|
|

740
00:22:49,400 --> 00:22:51,620
0,750 960,1290 1290,1650 1650,2010 2010,2220
Anybody any ideas why this
有人知道为什么是这样吗？

741
00:22:51,620 --> 00:22:53,120
0,150 150,240 240,630 990,1200 1200,1500
is the case.| We said
|我们说过有一位，

742
00:22:53,120 --> 00:22:54,830
0,210 210,570 570,990 1200,1560 1560,1710
that one bit| that we
|我们要用但其实没有使用的，

743
00:22:54,830 --> 00:22:56,000
0,330 330,480 480,630 630,870 870,1170
said we were gonna use

744
00:22:56,000 --> 00:22:57,590
0,150 150,510 510,840 840,1260 1260,1590
we actually aren't using,| because
|因为符号扩展问题，也是为了让它变得更容易，

745
00:22:57,590 --> 00:22:59,360
0,120 120,420 420,990 990,1620 1620,1770
of sign extension problems is

746
00:22:59,360 --> 00:23:00,350
0,240 240,480 480,600 600,900 900,990
just makes it easier| and
|并且我们不需要那么多内存。

747
00:23:00,350 --> 00:23:01,400
0,210 210,540 540,750 750,900 900,1050
we also don't need that

748
00:23:01,400 --> 00:23:02,180
0,510
memory.|
|

749
00:23:02,480 --> 00:23:04,340
0,1020 1020,1170 1170,1410 1410,1770 1770,1860
Yeah, so that's exactly the
是的，这就是正确的答案，

750
00:23:04,340 --> 00:23:05,450
0,210 210,480 480,600 600,750 750,1110
right answer,| so this is
|所以这是愚蠢的技术细节，

751
00:23:05,450 --> 00:23:09,350
0,420 420,1110 1110,2550 2760,3300 3330,3900
basically stupid technicality,| {} so
|所以虚拟地址原则上，

752
00:23:09,350 --> 00:23:10,970
0,120 120,420 420,990 1170,1530 1530,1620
the virtual addresses are in

753
00:23:10,970 --> 00:23:13,160
0,900 960,1020 1020,1560 1590,1740 1740,2190
principle,| {} I think 39
|我觉得是 39 位，

754
00:23:13,160 --> 00:23:14,240
0,360 480,900
bits, right,|
|

755
00:23:14,760 --> 00:23:17,100
0,810 930,1470 1470,1710 1710,1860 1860,2340
{} and but we actually
但是实际上在 xv6 中，只有 38 个，

756
00:23:17,100 --> 00:23:18,990
0,420 420,900 900,1290 1290,1800 1800,1890
in xv6, only 38 of

757
00:23:18,990 --> 00:23:19,540
0,270
them,|
|

758
00:23:20,260 --> 00:23:21,670
0,450 450,750 750,870 870,930 930,1410
{} and as a result,
因此，顶端的 MAXVA ，

759
00:23:21,670 --> 00:23:22,900
0,60 60,240 240,660 720,1080 1080,1230
you know the top of

760
00:23:22,900 --> 00:23:24,730
0,150 150,450 450,1050 1050,1650 1680,1830
the {MAXVA -} {for,us},| it
|它是 255 条目。

761
00:23:24,730 --> 00:23:26,770
0,210 210,840 870,1020 1200,1680 1680,2040
is basically the {255 -}

762
00:23:26,770 --> 00:23:27,380
0,390
entry.|
|

763
00:23:28,080 --> 00:23:28,890
0,150 150,210 210,480 480,600 600,810
And the reason we don't
我们不使用 39 位的原因是，

764
00:23:28,890 --> 00:23:30,570
0,120 120,210 210,660 660,960 960,1680
use the 39 bits,| is
|没有特别好的理由，

765
00:23:30,720 --> 00:23:32,460
0,210 210,480 480,1170 1170,1500 1500,1740
for no particular {} good

766
00:23:32,460 --> 00:23:34,620
0,480 690,960 960,1350 1350,1650 1650,2160
reason,| and then that basically
|基本上，如果你设置了第 39 位，

767
00:23:34,620 --> 00:23:35,640
0,300 300,420 420,690 690,750 750,1020
if you have the thirty

768
00:23:35,640 --> 00:23:36,840
0,300 300,480 480,1020
ninth bit set,|
|

769
00:23:37,190 --> 00:23:39,200
0,360 360,600 600,720 720,1530 1710,2010
then all the remaining {}
则 64 位地址中的所有剩余位必须为 1 。

770
00:23:39,200 --> 00:23:40,580
0,360 360,600 600,720 720,1230 1230,1380
bits in the 64 bit

771
00:23:40,580 --> 00:23:42,140
0,360 360,660 660,750 750,930 930,1560
address have to be ones.|
|

772
00:23:42,840 --> 00:23:43,740
0,330 330,450 450,540 540,720 720,900
And so we just didn't
我们不想处理这个问题，

773
00:23:43,740 --> 00:23:44,520
0,150 150,210 210,510 510,630 630,780
want to deal with this

774
00:23:44,520 --> 00:23:45,540
0,390 390,570 570,690 690,810 810,1020
problem| that if we ever
|如果我们设置了 39 ，

775
00:23:45,540 --> 00:23:46,770
0,270 270,750 750,930 930,1020 1020,1230
set 39,| {} we also
|我们也要设置 40 41 42 43 等，

776
00:23:46,770 --> 00:23:47,880
0,120 120,210 210,420 420,480 480,1110
have to set the {forty,forty}

777
00:23:47,880 --> 00:23:49,350
0,330 330,540 540,960 960,1170 1170,1470
first, forty second, forty third

778
00:23:49,350 --> 00:23:50,730
0,450 480,690 690,780 780,1050 1050,1380
etc| until the sixty fourth.|
|直到 64 。|

779
00:23:52,300 --> 00:23:52,960
0,420

780
00:23:55,050 --> 00:23:56,700
0,270 270,480 480,570 570,1140 1410,1650
So that's an explanation, that
所以这是解释，能理解吗。

781
00:23:56,700 --> 00:23:57,540
0,150 150,510
makes sense.|
|

782
00:23:58,370 --> 00:23:58,980
0,390
Yeah.|
嗯。|

783
00:24:00,010 --> 00:24:02,140
0,240 240,1050 1140,1560 1560,1710 1710,2130
That's a very good observation
这是一个非常好的观察。

784
00:24:02,140 --> 00:24:02,700
0,330
though.|
|

785
00:24:04,600 --> 00:24:05,680
0,180 180,300 300,540 540,660 660,1080
So I also had a
我也有一个问题，为什么文本和数据在同一页上。

786
00:24:05,680 --> 00:24:07,150
0,390 390,810 810,1170 1170,1350 1350,1470
question about why is the

787
00:24:07,150 --> 00:24:08,380
0,420 420,660 660,900 900,1170 1170,1230
text and data on the

788
00:24:08,380 --> 00:24:09,500
0,300 300,990
same page.|
|

789
00:24:09,720 --> 00:24:11,280
0,360 360,600 600,720 720,1080 1080,1560
{} Very good question, also.|
也是一个很好的问题。|

790
00:24:11,370 --> 00:24:12,660
0,360 360,540 540,720 720,1050 1080,1290
{} That seems stupid right,|
这看起来很愚蠢，|

791
00:24:12,660 --> 00:24:13,830
0,30 30,360 390,810 810,1080 1080,1170
I mean why not put
我的意思是为什么不把它们放在单独的页面上，

792
00:24:13,830 --> 00:24:14,820
0,90 90,180 180,510 510,870 870,990
them on separate pages,| so
|这样你才能更仔细地设置权限。

793
00:24:14,820 --> 00:24:15,570
0,120 120,240 240,360 360,570 570,750
that you can actually set

794
00:24:15,570 --> 00:24:16,860
0,60 60,420 420,780 810,1110 1110,1290
the permission, that's {} more

795
00:24:16,860 --> 00:24:17,600
0,480
carefully.|
|

796
00:24:18,140 --> 00:24:19,790
0,390 390,630 720,930 930,1380 1380,1650
{} And the {main -}
主要原因是，

797
00:24:19,790 --> 00:24:21,140
0,450 450,840 870,960 960,1170 1170,1350
reason,| {} we're {} doing
|我们这样做是为了简单。

798
00:24:21,140 --> 00:24:23,040
0,330 330,660 660,1020 1020,1680
that is for simplicity.|
|

799
00:24:23,150 --> 00:24:24,620
0,300 300,570 570,780 780,1290 1290,1470
{} Usually make exec more
通常 exec 更复杂，

800
00:24:24,620 --> 00:24:26,030
0,720 750,930 930,1050 1050,1320 1320,1410
complicated| and we wanted the
|我们想 exec 尽可能简单。

801
00:24:26,030 --> 00:24:27,620
0,510 510,840 840,1350
simplest exec possible.|
|

802
00:24:29,210 --> 00:24:30,350
0,240 240,330 330,510 510,840 840,1140
So a real operating system
真正的操作系统不会在同一页中包含数据和文本，

803
00:24:30,350 --> 00:24:31,850
0,450 450,780 780,990 990,1320 1320,1500
would not have data and

804
00:24:31,850 --> 00:24:33,240
0,330 330,420 420,510 510,1170
text in the same

805
00:24:33,400 --> 00:24:35,950
0,1020 1050,1650 1740,1890 1890,2400 2400,2550
{} page,| in fact we
|事实上，我们必须指定，

806
00:24:35,950 --> 00:24:37,210
0,180 180,270 270,1020 1020,1170 1170,1260
have to specify| that if
|如果你查看 makefile 中加载器标志，

807
00:24:37,210 --> 00:24:38,200
0,90 90,270 270,360 360,540 540,990
you look at the loader

808
00:24:38,200 --> 00:24:39,080
0,90 90,660
{} flag

809
00:24:39,250 --> 00:24:40,240
0,240 240,420 420,510 510,690 690,990
{} in the {makefile -}|
|

810
00:24:40,240 --> 00:24:41,050
0,150 150,360 360,510 510,600 600,810
you'll see that it has
你会看到，它有 -N 选项，

811
00:24:41,050 --> 00:24:43,060
0,90 90,390 390,870 1290,1890 1890,2010
the {-N -} option| and
|它强制数据和文本，

812
00:24:43,060 --> 00:24:44,290
0,180 180,420 420,660 660,930 930,1230
that force is actually data

813
00:24:44,290 --> 00:24:45,160
0,180 180,420 420,480 480,690 690,870
and text| to be in
|在一个连续的，而不是在单独的页面中。

814
00:24:45,160 --> 00:24:47,680
0,240 240,930 1680,2010 2010,2190 2190,2520
a contiguous not in separate

815
00:24:47,680 --> 00:24:48,340
0,480
pages.|
|

816
00:24:53,530 --> 00:24:54,730
0,210 210,330 330,690 690,870 870,1200
Any more questions about this.|
关于这个，还有什么问题吗。|

817
00:24:55,480 --> 00:24:57,130
0,210 210,390 390,510 510,1110 1110,1650
I had a {follow,up} question,|
我有一个后续问题，|

818
00:24:57,130 --> 00:24:58,840
0,540 540,810 810,1140 1140,1350 1350,1710
regarding the number of bits,
关于我们使用的位数。

819
00:24:58,840 --> 00:24:59,800
0,210 210,750
we're using.|
|

820
00:24:59,950 --> 00:25:01,420
0,480 510,720 720,840 840,1230 1260,1470
{} So you said we're
你说我们只用了 38 位，

821
00:25:01,420 --> 00:25:03,610
0,300 300,510 510,990 990,1440 2010,2190
using just 38 bits,| is
|硬件仍然提供给我们使用 39 位，

822
00:25:03,610 --> 00:25:05,260
0,270 270,570 750,1170 1170,1290 1290,1650
it is like the hardware

823
00:25:05,260 --> 00:25:06,910
0,420 420,1140 1170,1350 1350,1530 1530,1650
still provides for us to

824
00:25:06,910 --> 00:25:08,920
0,600 600,1320 1320,1560 1560,1860 1860,2010
use 39 bits,| but we
|但是我们设计操作系统使用 38 位。

825
00:25:08,920 --> 00:25:10,930
0,330 360,930 930,1110 1110,1530 1530,2010
are designing our operating system

826
00:25:11,680 --> 00:25:13,020
0,180 180,360 360,630 630,1050
that we're using 38.|
|

827
00:25:13,100 --> 00:25:13,720
0,420
Yeah.|
嗯。|

828
00:25:14,160 --> 00:25:15,480
0,210 210,330 330,810 810,1200 1200,1320
So we're basically| if the
所以我们，|如果机器有超过 2 的 38 次方的内存，

829
00:25:15,480 --> 00:25:17,860
0,390 390,570 570,1260 1290,2130
machine had more {}

830
00:25:17,880 --> 00:25:19,680
0,600 600,900 900,1080 1080,1380 1380,1800
ram two to thirty eight,|
|

831
00:25:20,160 --> 00:25:21,360
0,390 390,660 660,930 930,1020 1020,1200
we would not be able
我们就不能用那些内存了。

832
00:25:21,360 --> 00:25:22,400
0,90 90,240 240,450 450,810
to use that ram.|
|

833
00:25:22,710 --> 00:25:25,050
0,540 750,1200 1200,1500 1500,1950 1950,2340
Now we're running we're assuming|
现在我们运行的，我们假设的，|

834
00:25:25,050 --> 00:25:27,330
0,450 450,1020 1020,1380 1380,1860 1890,2280
basically much less memory than
内存远少于 2 的 38 次方，

835
00:25:27,330 --> 00:25:28,530
0,240 240,510 510,870 870,1050 1050,1200
two to thirty eight,| so
|所以这对我们来说没什么影响。

836
00:25:28,530 --> 00:25:29,250
0,150 150,270 270,360 360,510 510,720
it's not a big deal

837
00:25:29,250 --> 00:25:29,800
0,180 180,450
for us.|
|

838
00:25:30,290 --> 00:25:31,610
0,330 330,510 510,660 660,1050 1050,1320
{} But the real operating
但是如果是真正的操作系统，我们会做得更好。

839
00:25:31,610 --> 00:25:32,630
0,240 240,570 600,780 780,870 870,1020
system, we would have done

840
00:25:32,630 --> 00:25:33,200
0,330
better.|
|

841
00:25:36,350 --> 00:25:37,800
0,180 180,300 300,600 600,1230
So just {pure,for} simplicity.|
所以，只是为了简单。|

842
00:25:38,930 --> 00:25:39,500
0,150 150,300 300,360 360,480 480,570
We want to make it
我们想让你尽可能轻松，

843
00:25:39,500 --> 00:25:40,820
0,150 150,810 870,1080 1080,1200 1200,1320
as easy for you as

844
00:25:40,820 --> 00:25:42,260
0,390 390,780 810,1140 1140,1200 1200,1440
possible,| by reading a few
|尽可能少阅读代码。

845
00:25:42,260 --> 00:25:43,540
0,240 240,300 300,510 510,1080
lines of code possible.|
|

846
00:25:46,890 --> 00:25:47,720
0,600
Okay.|
好的。|

847
00:25:48,450 --> 00:25:49,840
0,600 630,810 810,1200
Yeah, makes sense.|
是的，理解了。|

848
00:25:50,750 --> 00:25:52,670
0,270 270,420 420,810 810,1500 1530,1920
Okay, so now, {} let's
好的，那么现在，让我们切换到第二部分。

849
00:25:52,670 --> 00:25:54,650
0,540 540,930 930,1350 1350,1590 1590,1980
switch to {} part two.|
|

850
00:25:55,610 --> 00:25:57,380
0,540 900,1080 1080,1200 1200,1470 1470,1770
{} And so let's bring
让我们来看一张图片，

851
00:25:57,380 --> 00:25:58,970
0,180 180,840 840,1140 1140,1260 1260,1590
up, a picture,| you probably
|你可能看了很多次。

852
00:25:58,970 --> 00:25:59,990
0,210 210,390 390,510 510,570 570,1020
have looked at a lot.|
|

853
00:26:00,380 --> 00:26:02,600
0,510 510,1260 1290,1620 1620,1830 1830,2220
{} The kernel address space
内核地址空间，|

854
00:26:02,600 --> 00:26:03,680
0,210 210,360 360,450 450,840 870,1080
right,| on the left is
|左边是虚拟地址空间，

855
00:26:03,680 --> 00:26:05,390
0,750 780,1110 1110,1290 1290,1620 1620,1710
{} virtual address space,| on
|右边是物理内存，

856
00:26:05,390 --> 00:26:06,950
0,60 60,450 450,720 720,1050 1050,1560
the right is physical memory,|
|

857
00:26:07,440 --> 00:26:09,720
0,540 540,1170 1170,1470 1500,1980 1980,2280
{} {you,know} {} {here,are} IO
你知道这里是 IO 设备，

858
00:26:09,720 --> 00:26:10,740
0,900
devices,|
|

859
00:26:11,080 --> 00:26:12,700
0,360 360,720 720,900 900,1170 1170,1620
and then from here on
从这里开始是 DRAM ，

860
00:26:12,730 --> 00:26:14,360
0,450 450,570 570,660 660,1380
is you know DRAM,|
|

861
00:26:16,090 --> 00:26:17,950
0,720 720,840 840,1170 1170,1530 1530,1860
and you know and basically
直到 128 兆字节。

862
00:26:17,950 --> 00:26:19,570
0,270 270,540 540,870 870,1320 1320,1620
running into what actually {}

863
00:26:19,570 --> 00:26:21,550
0,270 270,780 780,990 990,1380 1380,1980
one twenty {} 28 megabytes

864
00:26:22,330 --> 00:26:23,260
0,690

865
00:26:24,390 --> 00:26:25,530
0,240 240,570 600,870 870,990 990,1140
for us.| Because we just
|因为我们假设，

866
00:26:25,530 --> 00:26:26,490
0,360 360,480 480,600 600,750 750,960
assume that| there's no more
|内存不超过 250（误） 128 兆字节。

867
00:26:26,490 --> 00:26:28,290
0,240 420,1140 1140,1350 1350,1500 1500,1800
than {250 -} and {}

868
00:26:28,290 --> 00:26:29,370
0,270 270,510 510,660 660,1020 1020,1080
one twenty eight megabytes of

869
00:26:29,370 --> 00:26:29,960
0,360
memory.|
|

870
00:26:30,140 --> 00:26:31,070
0,240 240,360 360,630 630,870 870,930
And so this part of
所以这部分物理内存就是空闲内存。

871
00:26:31,070 --> 00:26:31,910
0,60 60,330 330,630 630,720 720,840
the physical memory is the

872
00:26:31,910 --> 00:26:32,880
0,150 150,720
free memory.|
|

873
00:26:33,840 --> 00:26:35,040
0,330 330,600 600,720 720,1020 1020,1200
And then from that, this
从那里开始，这是内核，

874
00:26:35,040 --> 00:26:37,560
0,270 270,900 1230,1950 1980,2340 2400,2520
was kernel,| {} oops, I
|哎呀，我画错了。

875
00:26:37,560 --> 00:26:38,790
0,330 330,420 420,600 600,750 750,1230
drew a little bit wrong.|
|

876
00:26:39,510 --> 00:26:41,040
0,210 210,780 780,840 840,990 990,1530
Let me be more careful,|
让我更小心一点，|

877
00:26:41,430 --> 00:26:42,920
0,570 810,1260
{} so,
这里我们有内核文本和数据。

878
00:26:43,910 --> 00:26:45,590
0,480 480,660 660,1020 1020,1440 1470,1680
here we basically have {}

879
00:26:45,590 --> 00:26:47,780
0,570 600,1170 1170,1350 1350,1890
kernel text and data.|
|

880
00:26:48,160 --> 00:26:49,120
0,150 150,480 510,630 630,750 750,960
And then you know this
然后上面的内存，就是内核分配器拥有的内存，

881
00:26:49,120 --> 00:26:51,640
0,390 390,1110 1110,1620 1680,2340 2340,2520
memory above, basically memory that

882
00:26:51,640 --> 00:26:53,560
0,360 360,600 600,1110 1110,1590 1710,1920
the kernel allocator has| and
|从那里我们为用户程序分配内存，

883
00:26:53,560 --> 00:26:55,030
0,120 120,570 570,780 780,1200 1200,1470
from there we allocate memory

884
00:26:55,030 --> 00:26:56,500
0,120 120,360 360,1020 1020,1110 1110,1470
for user programs,| we allocate
|我们为页表等分配内存。

885
00:26:56,500 --> 00:26:58,240
0,210 210,330 330,600 600,1200 1200,1740
memory for {pagetables -}, etc.|
|

886
00:26:58,330 --> 00:26:59,620
0,300 300,660 660,960 960,1080 1080,1290
Kernel allocates everything for them,|
内核为它们分配所有，|

887
00:27:00,680 --> 00:27:01,490
0,330 330,420 420,630 630,720 720,810
until it runs out of
直到内存耗尽，

888
00:27:01,490 --> 00:27:02,510
0,420 420,600 600,690 690,900 900,1020
memory,| when it runs out
|当它用完时，它会达到 128 兆字节，

889
00:27:02,510 --> 00:27:03,380
0,120 120,330 330,420 420,600 600,870
it gets to one twenty

890
00:27:03,380 --> 00:27:05,390
0,390 600,1380 1380,1800 1800,1950 1950,2010
eight megabyte| and then it
|然后它开始返回错误或系统调用。

891
00:27:05,390 --> 00:27:06,950
0,240 240,570 570,1050 1080,1290 1290,1560
starts returning errors or system

892
00:27:06,950 --> 00:27:07,480
0,450
calls.|
|

893
00:27:08,680 --> 00:27:09,440
0,540
Okay.|
好的。|

894
00:27:10,490 --> 00:27:12,050
0,420 480,810 810,960 960,1170 1170,1560
Good, {} so let me
好的，那么让我把第一部分做好，

895
00:27:12,050 --> 00:27:14,000
0,30 30,570 570,720 720,1200 1320,1950
{} pull off my {}

896
00:27:15,260 --> 00:27:16,670
0,480 480,810 810,1080 1080,1230 1230,1410
first part correct,| in some
|从某种意义上说，这是任务的第二部分，

897
00:27:16,670 --> 00:27:18,020
0,270 270,360 360,540 540,1080 1080,1350
sense of this assignment it

898
00:27:18,020 --> 00:27:19,820
0,510 720,1110 1110,1200 1200,1290 1290,1800
was {part,two} of the assignment,|
|

899
00:27:19,850 --> 00:27:23,780
0,540 540,1020 1020,1560 1830,2640 2820,3930
was just to {} run
就是运行或者复制内核页表，

900
00:27:23,810 --> 00:27:26,150
0,780 810,1230 1500,1800 1830,2280 2280,2340
with or {} copy the

901
00:27:26,150 --> 00:27:27,590
0,300 300,540 540,930 930,1110 1110,1440
kernel {pagetables -},| and every
|而且每个进程都有自己的内核页表。

902
00:27:27,590 --> 00:27:31,310
0,720 1140,2160 2160,2310 2310,2940 3150,3720
process has its own kernel

903
00:27:31,310 --> 00:27:32,260
0,240 240,840
{pagetables -}.|
|

904
00:27:33,060 --> 00:27:35,880
0,540 960,1350 1350,1860 1890,2580 2580,2820
{} That was basically that's
这就是这里的任务，

905
00:27:35,880 --> 00:27:37,410
0,420 420,1050 1050,1290 1290,1410 1410,1530
the assignment here,| so let
|所以让我进入代码，

906
00:27:37,410 --> 00:27:38,550
0,360 390,630 630,870 870,1080 1080,1140
me for jumping into the

907
00:27:38,550 --> 00:27:39,480
0,300 300,390 390,540 540,750 750,930
code,| let me actually see
|让我实际看几件事，

908
00:27:39,480 --> 00:27:40,480
0,60 60,300 300,720
a couple things,|
|

909
00:27:40,580 --> 00:27:42,080
0,510 510,720 720,1020 1020,1230 1230,1500
{} more general things about
关于它的，更一般的事情。

910
00:27:42,080 --> 00:27:42,520
0,240
it.|
|

911
00:27:43,800 --> 00:27:45,400
0,390 390,630 630,900 900,1380
{} So part two.|
所以第二部分。|

912
00:27:51,160 --> 00:27:53,590
0,660 1320,1980 1980,2160 2160,2250 2250,2430
{} And maybe the first
也许你头脑中的第一个问题是，

913
00:27:53,590 --> 00:27:55,000
0,240 240,450 450,990 1020,1350 1350,1410
question really to sort of

914
00:27:55,030 --> 00:27:56,260
0,540 540,630 630,780 780,1110 1110,1230
get your head around is|
|

915
00:27:56,260 --> 00:27:57,100
0,180 180,270 270,570 570,630 630,840
like you know in some
在某些方面你做了一些微不足道的事，

916
00:27:57,100 --> 00:27:58,300
0,240 240,330 330,510 510,720 720,1200
ways you do something [trivial]

917
00:27:58,300 --> 00:27:59,170
0,300 300,390 390,660 660,810 810,870
right,| we already have the
|我们已经有了内核页表，

918
00:27:59,170 --> 00:28:00,490
0,240 240,480 480,930 960,1140 1140,1320
kernel {pagetable -},| we just
|我们只需复制[]个副本，

919
00:28:00,490 --> 00:28:01,600
0,180 180,240 240,510 510,720 720,1110
have to make [] copies

920
00:28:01,600 --> 00:28:03,010
0,120 120,300 570,720 720,1020 1020,1410
of it,| for one copy
|每个进程一个副本。

921
00:28:03,010 --> 00:28:04,620
0,120 120,240 240,600 600,1140
for each particular process.|
|

922
00:28:04,690 --> 00:28:06,460
0,690 840,1320 1320,1440 1440,1620 1620,1770
{} You, you might say
你可能会说，这能有多难，

923
00:28:06,460 --> 00:28:07,390
0,300 300,420 420,540 540,750 750,930
well you know how hard

924
00:28:07,390 --> 00:28:08,500
0,150 150,240 240,600 660,930 930,1110
can it be,| {} it
|因为几个原因，这是有些难度的。

925
00:28:08,500 --> 00:28:09,220
0,240 240,390 390,540 540,660 660,720
turns out it was a

926
00:28:09,220 --> 00:28:10,090
0,150 150,240 240,630 630,780 780,870
little bit harder for a

927
00:28:10,090 --> 00:28:11,120
0,240 240,900
couple reasons.|
|

928
00:28:11,400 --> 00:28:13,020
0,360 360,540 540,1050 1080,1410 1410,1620
Some good ones, some less
一些好的原因，一些不太好的原因，

929
00:28:13,020 --> 00:28:13,740
0,180 180,600
good ones,|
|

930
00:28:14,440 --> 00:28:16,120
0,540 540,810 810,930 930,990 990,1680
{} harder than it seems.|
它比看起来要难。|

931
00:28:20,500 --> 00:28:22,600
0,450 450,900 900,1230 1230,1650 1650,2100
And one reason is that|
一个原因是，

932
00:28:22,630 --> 00:28:24,820
0,660 690,930 930,1320 1320,1560 1560,2190
{} {you,know} {xv6 -} code
xv6 代码很特别，

933
00:28:26,430 --> 00:28:29,190
0,540 540,900 900,1860 2160,2460 2460,2760
{} it's specialized,| for one
|针对一个内核页表。

934
00:28:29,190 --> 00:28:30,380
0,270 270,510 510,930
kernel {pagetable -}.|
|

935
00:28:39,080 --> 00:28:40,280
0,240 240,360 360,480 480,840 840,1200
You know, you {saw,that} in
你在 kvminit 中看到的。

936
00:28:40,280 --> 00:28:43,010
0,480 480,750 750,930 930,1470 1860,2730
{} {kvminit - -} {}.|
|

937
00:28:43,500 --> 00:28:44,640
0,510 510,720 720,810 810,930 930,1140
Yeah, and so that makes
是的，所以这就有点一概而论，

938
00:28:44,640 --> 00:28:46,320
0,270 270,600 600,810 810,1080 1080,1680
it a little bit {}

939
00:28:47,340 --> 00:28:48,810
0,900 900,990 990,1080 1080,1380 1380,1470
[generalizing],| you know it's a
|你知道这需要一些工作，

940
00:28:48,810 --> 00:28:49,800
0,270 270,390 390,450 450,780 780,990
little bit of work,| because
|因为你必须修改 xv6 代码。

941
00:28:49,800 --> 00:28:50,790
0,90 90,210 210,510 510,900 900,990
you have to modify the

942
00:28:50,790 --> 00:28:51,860
0,480 480,870
xv6 code.|
|

943
00:28:52,500 --> 00:28:53,400
0,660

944
00:28:54,580 --> 00:28:55,930
0,390 390,480 480,990 990,1140 1140,1350
{kvminit - -} as you
如你所见， kvminit 不是完全，

945
00:28:55,930 --> 00:28:56,800
0,210 210,480 480,630 630,810 810,870
also saw is not the

946
00:28:56,800 --> 00:28:57,840
0,240 240,750
full {},|
|

947
00:28:58,360 --> 00:29:00,010
0,150 150,270 270,540 540,1050 1050,1650
{} {} for building {}
为内核构建页表。

948
00:29:00,040 --> 00:29:02,080
0,510 510,1320 1320,1440 1440,1500 1500,2040
{pagetable -} for the kernel.|
|

949
00:29:02,230 --> 00:29:03,910
0,420 420,660 660,1080 1080,1380 1440,1680
There's also stuff in {procinit
也有一些在 procinit 中，

950
00:29:03,910 --> 00:29:04,620
0,150 150,480
- -},|
|

951
00:29:04,710 --> 00:29:06,330
0,240 240,570 570,1050 1050,1470 1470,1620
that actually adds {mappings -}
它添加映射到内核页表。

952
00:29:06,330 --> 00:29:07,620
0,150 150,240 240,540 540,780 780,1290
to the kernel {pagetable -}.|
|

953
00:29:08,010 --> 00:29:09,360
0,300 300,540 540,750 750,1080 1080,1350
And there's even something in
甚至有一些在 virtio_disk 。

954
00:29:09,390 --> 00:29:11,000
0,450 450,930 930,1440
{virtio_disk - -},|
|

955
00:29:12,040 --> 00:29:13,450
0,210 210,450 450,1170 1170,1320 1320,1410
the actually interacts, you know
真正与内核页表进行交互。

956
00:29:13,450 --> 00:29:14,780
0,180 180,450 450,690 690,1110
the kernel {pagetable -}.|
|

957
00:29:16,000 --> 00:29:17,170
0,240 240,450 450,840 840,1020 1020,1170
{} So basically there's no
所以内核中没有唯一的地方，

958
00:29:17,170 --> 00:29:18,490
0,420 420,840 840,1170 1170,1260 1260,1320
one single place in the

959
00:29:18,490 --> 00:29:20,080
0,360 360,720 720,1080 1080,1290 1290,1590
kernel,| where actually the kernel
|用于构建内核页表。

960
00:29:20,080 --> 00:29:21,430
0,210 210,450 450,750 750,900 900,1350
{pagetable -} actually is built.|
|

961
00:29:22,450 --> 00:29:24,130
0,420 450,690 690,900 990,1380 1380,1680
{} Then the third reason,
第三个原因，为什么这有些复杂，

962
00:29:24,130 --> 00:29:25,030
0,390 390,510 510,630 630,840 840,900
why you know this is

963
00:29:25,030 --> 00:29:26,560
0,300 300,960 960,1170 1170,1290 1290,1530
slightly complicated,| because you also
|因为你还得做清理工作。

964
00:29:26,560 --> 00:29:27,640
0,150 150,240 240,420 420,540 540,1080
have to deal with cleanup.|
|

965
00:29:29,200 --> 00:29:31,360
0,360 360,870 1200,1740 1740,1830 1830,2160
{} So there's the [aspect]
因为有一个创建这些副本的[方面]，

966
00:29:31,360 --> 00:29:32,920
0,90 90,360 360,720 720,870 870,1560
of actually creating these copies,|
|

967
00:29:32,980 --> 00:29:34,180
0,360 360,510 510,690 690,1110 1110,1200
but when every time {}
所以每次用户进程退出时，

968
00:29:34,180 --> 00:29:36,130
0,240 240,570 570,1080 1380,1800 1800,1950
user process exit,| {} we
|我们还要清理那些使用过的页表，

969
00:29:36,130 --> 00:29:37,330
0,240 240,390 390,480 480,780 780,1200
also have to clean up

970
00:29:37,480 --> 00:29:39,340
0,390 420,1290 1290,1560 1560,1680 1680,1860
those {pagetables -} that were

971
00:29:39,340 --> 00:29:41,020
0,90 90,540 660,1200 1200,1500 1500,1680
in use,| because we want
|因为我们希望将它们放回到空闲内存池中，

972
00:29:41,020 --> 00:29:42,250
0,120 120,450 450,570 570,840 840,1230
to return them to the

973
00:29:42,280 --> 00:29:43,480
0,390 390,540 540,720 720,1110 1110,1200
pool of free memory,| so
|好让我们以后可以使用它们，

974
00:29:43,480 --> 00:29:44,170
0,150 150,240 240,390 390,540 540,690
that we can use them

975
00:29:44,170 --> 00:29:45,490
0,480 630,990 990,1110 1110,1230 1230,1320
later,| {} so that we
|以便我们可以继续运行进程。

976
00:29:45,490 --> 00:29:46,870
0,120 120,300 300,480 480,690 690,1380
can keep on running processes.|
|

977
00:29:48,340 --> 00:29:49,700
0,180 180,270 270,600 600,1170
That's what happens there.|
这就是那里发生的事情。|

978
00:29:51,240 --> 00:29:51,900
0,150 150,240 240,480 480,630 630,660
And that makes things a
这让事情变得有些复杂，

979
00:29:51,900 --> 00:29:53,370
0,150 150,240 240,840 840,1140 1140,1470
little bit complicated,| because we've
|因为我们必须要小心，

980
00:29:53,370 --> 00:29:54,600
0,120 120,180 180,390 390,690 690,1230
got to be little careful,|
|

981
00:29:54,600 --> 00:29:56,400
0,270 270,840 870,1080 1080,1500 1500,1800
in actually {} freeing the
在释放内核页表

982
00:29:56,400 --> 00:29:57,930
0,270 270,510 510,960 990,1230 1230,1530
kernel {pagetable -}| or copy
|或内核页表的副本时，

983
00:29:57,930 --> 00:29:59,040
0,90 90,180 180,420 420,660 660,1110
of the kernel {pagetable -},|
|

984
00:29:59,220 --> 00:30:00,210
0,240 240,360 360,660 660,840 840,990
but we certainly don't want
我们当然不想

985
00:30:00,210 --> 00:30:01,830
0,180 180,300 300,420 420,930 1170,1620
to,| you know, free {}
|释放仍在使用中的内存，

986
00:30:01,830 --> 00:30:03,450
0,390 390,570 570,870 870,1260 1260,1620
memory that actually {still,in} use,|
|

987
00:30:03,450 --> 00:30:04,890
0,390 390,720 720,1080 1080,1170 1170,1440
{or,page} table entries are still
或别的页表仍在使用的页表条目。

988
00:30:04,890 --> 00:30:06,270
0,240 240,330 330,600 600,840 840,1380
used by other {pagetables -}.|
|

989
00:30:06,920 --> 00:30:07,760
0,240 240,330 330,480 480,540 540,840
So we gotta be careful
所以我们得小心，

990
00:30:07,760 --> 00:30:10,310
0,390 960,1200 1200,1710 1800,2430 2430,2550
there,| and then, {} you
|然后，你知道，很容易出现错误。

991
00:30:10,310 --> 00:30:11,780
0,60 60,510 810,1020 1020,1230 1230,1470
know basically, {} it's easy

992
00:30:11,780 --> 00:30:12,860
0,90 90,270 270,330 330,630 630,1080
to make a small error.|
|

993
00:30:14,320 --> 00:30:15,460
0,270 270,510 510,840 840,1050 1050,1140
{You,know} {pagetable -}, when your
当你复制那些页表时。

994
00:30:15,460 --> 00:30:17,020
0,330 330,540 540,750 750,1380
copy those {pagetables -}.|
|

995
00:30:17,370 --> 00:30:18,090
0,360 360,420 420,480 480,600 600,720
{} You know if you
如果你[拿到]一点东西，

996
00:30:18,090 --> 00:30:19,800
0,150 150,240 240,540 540,1080 1260,1710
get a little thing {},|
|

997
00:30:19,800 --> 00:30:20,700
0,90 90,180 180,600 600,750 750,900
you know basically you get
你会得到一个很难的 bug 。

998
00:30:20,700 --> 00:30:22,100
0,90 90,510 510,840 840,1230
a hard hard bug.|
|

999
00:30:24,300 --> 00:30:26,010
0,480 900,1200 1200,1260 1260,1350 1350,1710
And one of the problems
这里的一个问题是，我之前说过，

1000
00:30:26,010 --> 00:30:27,450
0,240 240,450 450,510 510,750 750,1440
here is I said earlier

1001
00:30:27,450 --> 00:30:28,920
0,300 510,840 840,1020 1020,1230 1230,1470
is,| {} the hard bug
|困难的 bug 出现的时间要晚得多。

1002
00:30:28,920 --> 00:30:30,690
0,270 270,630 630,900 900,1320 1320,1770
shows up much much later.|
|

1003
00:30:30,940 --> 00:30:32,050
0,330 330,540 540,600 600,840 840,1110
You've built the kernel {pagetable
你已经构建了内核页表，

1004
00:30:32,050 --> 00:30:33,130
0,420 420,540 540,720 720,780 780,1080
-},| are built {} copy
|构建了内核页表的副本，

1005
00:30:33,130 --> 00:30:34,540
0,60 60,120 120,510 510,930 930,1410
of the kernel {pagetable -},|
|

1006
00:30:34,940 --> 00:30:36,590
0,330 330,450 450,1020 1230,1440 1440,1650
all looks fine, you load
一切看起来都很好，你装入 satp 寄存器，

1007
00:30:36,620 --> 00:30:38,320
0,480 480,600 600,750 750,1470
loaded in satp,|
|

1008
00:30:38,390 --> 00:30:39,620
0,240 240,420 420,900 900,1170 1170,1230
they may even maybe the
甚至内核会运行一小段时间，然后才死机。

1009
00:30:39,620 --> 00:30:40,460
0,240 240,480 480,570 570,630 630,840
kernel runs for a little

1010
00:30:40,460 --> 00:30:41,960
0,360 360,450 450,750 750,1350
while, and then panics.|
|

1011
00:30:42,480 --> 00:30:43,590
0,390 390,510 510,720 720,1020 1020,1110
And it turns out you
结果发现死机的原因，

1012
00:30:43,590 --> 00:30:44,640
0,150 150,240 240,480 480,600 600,1050
know the reason that panics,|
|

1013
00:30:44,640 --> 00:30:46,080
0,450 450,600 600,810 810,1110 1110,1440
because you made some small
因为你在页表中犯了个小错误，

1014
00:30:46,080 --> 00:30:48,120
0,450 450,810 810,1260 1290,1560 1560,2040
mistake in the {pagetable -},|
|

1015
00:30:48,150 --> 00:30:49,560
0,240 240,720 720,900 900,1110 1110,1410
{} long, long time ago.|
在很久很久以前。|

1016
00:30:49,990 --> 00:30:50,980
0,300 300,390 390,600 600,690 690,990
And so this is one
所以这就是为什么

1017
00:30:50,980 --> 00:30:52,030
0,240 240,390 390,480 480,930 930,1050
reason why| it makes you
|它会让内核编程很困难。

1018
00:30:52,030 --> 00:30:54,520
0,630 630,870 870,1320 1350,1980 2010,2490
know makes life difficult for

1019
00:30:54,550 --> 00:30:55,560
0,300 300,750
kernel programming.|
|

1020
00:30:56,950 --> 00:30:58,450
0,480 480,600 600,870 870,1050 1050,1500
And you know and basically
你知道，这些困难的 bug ，

1021
00:30:58,450 --> 00:30:59,770
0,330 330,510 510,840 840,1200 1200,1320
these hard bugs,| basically are
|基本上都很费时间去追踪。

1022
00:30:59,770 --> 00:31:00,940
0,210 210,420 420,810
just time consuming

1023
00:31:01,330 --> 00:31:02,320
0,150 150,390 390,780
to track down.|
|

1024
00:31:11,630 --> 00:31:12,590
0,270 270,330 330,390 390,660 660,960
Because of the point that
因为发生的时候，

1025
00:31:12,590 --> 00:31:14,450
0,270 270,930 1020,1380 1380,1650 1650,1860
{you,know} happens,| {} that's actually
|其实不是 bug 的真正原因，

1026
00:31:14,450 --> 00:31:15,920
0,180 180,300 300,570 570,1230 1350,1470
not the real cause of

1027
00:31:15,950 --> 00:31:16,940
0,360 360,540 540,600 600,870 870,990
{} of the bug,| but
|但是真正的原因，

1028
00:31:16,940 --> 00:31:17,990
0,330 330,420 420,540 540,870 870,1050
about you know the real

1029
00:31:17,990 --> 00:31:19,220
0,360 360,510 510,630 630,930 930,1230
cause,| you know somewhere [who's]
|是你之前设置页表时的某个地方。

1030
00:31:19,220 --> 00:31:20,450
0,330 330,720 720,930 930,1020 1020,1230
way earlier when you set

1031
00:31:20,450 --> 00:31:21,680
0,120 120,360 420,690 690,1140
up the {pagetables -}.|
|

1032
00:31:23,840 --> 00:31:25,500
0,630 720,1410
Okay, um.|
好的。|

1033
00:31:26,310 --> 00:31:28,320
0,360 360,480 480,720 720,1140 1200,2010
So it turns out {},|
所以结果是，|

1034
00:31:28,500 --> 00:31:29,670
0,180 180,420 420,630 630,1080 1080,1170
there are two approaches to
有两种方法解决这个问题，

1035
00:31:29,670 --> 00:31:31,080
0,150 150,450 450,690 900,1230 1230,1410
go about it,| {you,know} to
|你知道，这个实验可以采用两种解决方案。

1036
00:31:31,080 --> 00:31:32,640
0,90 90,600 600,1110 1110,1320 1320,1560
this lab which sort of

1037
00:31:33,350 --> 00:31:35,680
0,690 840,1020 1020,1410 1410,2130
{} two solution approaches.|
|

1038
00:31:38,850 --> 00:31:39,750
0,180 180,540 540,690 690,810 810,900
In fact, some of you
事实上，你们中的一些人可能混合使用它们，

1039
00:31:39,750 --> 00:31:40,740
0,90 90,390 390,600 600,660 660,990
have probably used a mixture

1040
00:31:40,740 --> 00:31:42,750
0,60 60,510 870,1350 1350,1500 1500,2010
of them,| {} the one
|第一个方法是 copy 方法。

1041
00:31:42,750 --> 00:31:44,100
0,180 180,510 510,660 660,750 750,1350
{you,know} approach what {} call

1042
00:31:44,400 --> 00:31:46,000
0,300 300,720 720,1350
{} copy approach.|
|

1043
00:31:47,550 --> 00:31:48,960
0,360 360,420 420,720 720,990 990,1410
And the copy approach basically
copy 方法从字面上复制内核页表，

1044
00:31:48,960 --> 00:31:50,160
0,420 420,720 720,780 780,1080 1080,1200
literally makes a copy to

1045
00:31:50,160 --> 00:31:52,260
0,300 300,570 570,840 840,1170 1680,2100
the kernel {pagetable -},| so
|所以每次你都需要一个新的内核页表，

1046
00:31:52,440 --> 00:31:55,050
0,240 240,690 690,1410 1710,2550 2550,2610
every time you need a

1047
00:31:55,050 --> 00:31:56,940
0,330 330,600 600,810 810,1350 1470,1890
new kernel {pagetable -},| you
|你为页表分配页面，

1048
00:31:56,940 --> 00:31:58,230
0,420 420,750 750,960 960,1080 1080,1290
allocate pages for the {pagetable

1049
00:31:58,230 --> 00:31:59,910
0,570 570,780 810,1080 1080,1230 1230,1680
-},| you fill them in
|你为它们填充数据，等等。

1050
00:32:00,180 --> 00:32:02,300
0,1470 1470,1950
etc, etc.|
|

1051
00:32:02,920 --> 00:32:05,530
0,360 360,900 900,1260 2190,2370 2370,2610
And there's {}, that's one
还有一种方法，第二种方法是，

1052
00:32:05,530 --> 00:32:07,060
0,360 360,480 480,690 690,1380
approach, the second approach

1053
00:32:07,200 --> 00:32:10,830
0,630 990,1950 1980,2700 2970,3510 3510,3630
{} is| {} basically to
|共享内核页表，

1054
00:32:10,830 --> 00:32:11,760
0,690
share

1055
00:32:14,060 --> 00:32:15,890
0,570 840,1020 1020,1260 1260,1470 1470,1830
{} the kernel {pagetable -},|
|

1056
00:32:15,890 --> 00:32:17,480
0,420 570,750 750,960 960,1350 1350,1590
and in this case, what
在这种情况下，你要做的是

1057
00:32:17,480 --> 00:32:18,860
0,120 120,480 480,720 720,1260 1260,1380
you do is| instead of
|不是创建一个内核页表的干净副本，

1058
00:32:18,860 --> 00:32:20,120
0,270 270,420 420,660 660,750 750,1260
trying to make a literally

1059
00:32:20,120 --> 00:32:21,530
0,510 540,990 990,1290 1290,1350 1350,1410
nice clean copy of the

1060
00:32:21,530 --> 00:32:23,270
0,210 210,420 420,930 1170,1440 1440,1740
kernel {pagetables -},| you share
|而是共享不会修改的所有条目。

1061
00:32:23,270 --> 00:32:24,230
0,150 150,300 300,720 720,870 870,960
all the entries that are

1062
00:32:24,230 --> 00:32:25,850
0,630 630,1200 1200,1470 1470,1530 1530,1620
basically are going to be

1063
00:32:25,850 --> 00:32:27,000
0,780
unmodified.|
|

1064
00:32:27,300 --> 00:32:28,380
0,360 360,660 660,810 810,990 990,1080
{} You know from the
你从任务中知道，

1065
00:32:28,380 --> 00:32:30,630
0,630 630,780 780,1230 1230,1620 1620,2250
assignment,| that basically anything above
|基本上从 CLINT 到 PLIC 地址以上的任何内容，

1066
00:32:30,690 --> 00:32:32,190
0,690 720,1080 1080,1170 1170,1290 1290,1500
{} CLINT to {} PLIC

1067
00:32:32,190 --> 00:32:33,330
0,420 420,540 540,930 930,1050 1050,1140
address,| is actually going to
|实际上是不变的，

1068
00:32:33,330 --> 00:32:35,970
0,390 420,1260 1260,1950 1980,2370 2370,2640
be unchanged, unmodified,| there's nothing
|那里没有你要加载的东西。

1069
00:32:35,970 --> 00:32:36,960
0,120 120,240 240,330 330,660 660,990
you have to load there.|
|

1070
00:32:37,290 --> 00:32:38,910
0,480 480,810 810,990 1020,1260 1260,1620
{} In the part three,|
在第三部分，|

1071
00:32:39,060 --> 00:32:39,630
0,210 210,330 330,390 390,510 510,570
so you know what are
你知道，基本上，

1072
00:32:39,630 --> 00:32:41,580
0,660 810,1020 1020,1170 1170,1620 1620,1950
basically,| all the entries from
|从零开始的所有条目可能是相同的，

1073
00:32:41,580 --> 00:32:43,980
0,390 390,840 840,990 990,1740 1740,2400
above zero are probably identical,|
|

1074
00:32:44,130 --> 00:32:45,150
0,150 150,300 300,420 420,810 810,1020
so you could share those
所以你可以分享这些条目。

1075
00:32:45,150 --> 00:32:46,220
0,300 300,390 390,540 540,840
entries, if you will.|
|

1076
00:32:47,020 --> 00:32:49,360
0,480 810,1080 1080,1230 1230,1710 1710,2340
{} So that both approaches
这两种方法都很好。

1077
00:32:49,360 --> 00:32:51,020
0,240 240,450 450,870 870,1410
are actually perfectly fine.|
|

1078
00:32:51,080 --> 00:32:53,660
0,600 600,810 810,1200 1710,2190 2190,2580
{} It's not abundantly clear,
没有明确的，哪一个更好。

1079
00:32:53,660 --> 00:32:54,500
0,210 210,450 450,570 570,630 630,840
which one is the better

1080
00:32:54,500 --> 00:32:56,600
0,450 600,1050 1050,1260 1260,1740 1740,2100
one.| {} My solution, take
|我的解决方案，采取这种方法（共享方法）。

1081
00:32:56,600 --> 00:32:58,040
0,480 510,1290
this approach.|
|

1082
00:32:58,240 --> 00:33:01,120
0,540 540,1350 1650,2340 2580,2700 2700,2880
{} And {} I don't
我没有很好的理由，

1083
00:33:01,120 --> 00:33:02,530
0,180 180,330 330,570 570,1200 1200,1410
really have great justification for

1084
00:33:02,530 --> 00:33:04,510
0,240 270,510 510,690 690,1230 1260,1980
it| other than maybe {}
|除了可能部分原因是可以偷懒。

1085
00:33:05,530 --> 00:33:07,160
0,1080 1080,1440
partially laziness.|
|

1086
00:33:07,210 --> 00:33:07,840
0,180 180,270 270,420 420,540 540,630
{} I didn't want to
我不想想太多，

1087
00:33:07,840 --> 00:33:08,980
0,150 150,240 240,720 750,870 870,1140
think too hard,| {} what's
|内核页表中有什么，

1088
00:33:08,980 --> 00:33:10,210
0,180 180,240 240,510 510,750 750,1230
in the kernel {pagetable -},|
|

1089
00:33:10,210 --> 00:33:11,230
0,330 330,450 450,540 540,900 900,1020
and so I figured out
所以我想出所有东西保持不变，

1090
00:33:11,230 --> 00:33:11,920
0,120 120,180 180,390 390,570 570,690
all the things that are

1091
00:33:11,920 --> 00:33:13,000
0,120 120,270 270,480 480,570 570,1080
going to stay the same,|
|

1092
00:33:13,210 --> 00:33:15,040
0,510 510,900 900,1020 1020,1500 1500,1830
{why,do,you} copy them over| or
为什么复制它们，|或者复制 pte ，

1093
00:33:15,680 --> 00:33:18,020
0,300 450,1230 1230,1350 1350,1860 2010,2340
{you,know} copy {the,ptes} over| and
|然后我不得不认真考虑，

1094
00:33:18,020 --> 00:33:18,740
0,150 150,240 240,390 390,540 540,720
then I have to think

1095
00:33:18,740 --> 00:33:19,730
0,90 90,360 360,540 540,840 840,990
too hard about| actually isn't
|这实际上不是内核地址空间的一部分。

1096
00:33:19,730 --> 00:33:20,750
0,240 240,510 510,630 630,720 720,1020
that part of the kernel

1097
00:33:20,750 --> 00:33:21,580
0,210 210,720
address space.|
|

1098
00:33:22,480 --> 00:33:24,850
0,570 930,1530 1530,1650 1650,1800 2040,2370
{} And you know leads
这会导致更少代码，

1099
00:33:24,850 --> 00:33:25,870
0,90 90,360 360,720 720,870 870,1020
to short code,| but you
|但是我不确定，

1100
00:33:25,870 --> 00:33:26,800
0,90 90,150 150,330 330,570 570,930
know I'm not sure actually|
|

1101
00:33:26,800 --> 00:33:28,180
0,510 510,900 900,990 990,1290 1290,1380
shorter than, for example, the
比复制解决方案更少。

1102
00:33:28,180 --> 00:33:29,160
0,270 270,720
copy solution.|
|

1103
00:33:29,510 --> 00:33:30,680
0,270 270,360 360,690 690,750 750,1170
But it's important to realize
但重要的是要认识到，

1104
00:33:30,680 --> 00:33:31,760
0,90 90,450 450,570 570,630 630,1080
that basically| there are two
|有两种不同的方法来解决这个特定问题。

1105
00:33:31,850 --> 00:33:33,260
0,450 450,780 780,840 840,1080 1080,1410
different ways of going about

1106
00:33:33,260 --> 00:33:35,640
0,150 150,780 900,1560 1650,2130
this particular {} problem.|
|

1107
00:33:35,990 --> 00:33:38,630
0,180 180,480 480,1140 1560,2400 2460,2640
In either case, {} you
在这两种情况下，无论你用什么方法，

1108
00:33:38,630 --> 00:33:40,340
0,120 120,900 900,1230 1230,1290 1290,1710
know whatever approach you use,|
|

1109
00:33:40,340 --> 00:33:40,880
0,90 90,150 150,360 360,480 480,540
you know there's sort of
都有某种实施策略。

1110
00:33:40,880 --> 00:33:42,380
0,90 90,600 600,1080 1080,1260 1260,1500
an implementation strategy to it.|
|

1111
00:33:42,850 --> 00:33:44,260
0,600 630,750 750,870 870,960 960,1410
And you know the implementation
你知道我使用的实施策略，

1112
00:33:44,260 --> 00:33:45,340
0,390 390,510 510,630 630,870 870,1080
strategy that I use| for
|对于几乎任何内核程序，

1113
00:33:45,340 --> 00:33:47,740
0,330 330,600 600,1380 1380,1860 1860,2400
almost any kernel program| is
|都是按部就班地做所有事情。

1114
00:33:48,010 --> 00:33:49,540
0,300 300,570 570,1140 1140,1260 1260,1530
to do everything in baby

1115
00:33:49,540 --> 00:33:50,320
0,600
steps.|
|

1116
00:33:51,640 --> 00:33:52,600
0,750

1117
00:33:53,120 --> 00:33:54,920
0,450 840,990 990,1230 1230,1500 1500,1800
So I might have, for
所以我可能，在我的脑海里有一个总的计划，

1118
00:33:54,920 --> 00:33:55,880
0,330 330,540 540,630 630,720 720,960
general plan in my head|
|

1119
00:33:55,880 --> 00:33:56,870
0,270 270,420 420,540 540,750 750,990
about how I go over
关于我是如何从头走到尾的，

1120
00:33:56,870 --> 00:33:58,460
0,60 60,570 570,1410 1440,1500 1500,1590
the whole,| {} you know
|我要做的所有改变，

1121
00:33:58,460 --> 00:33:59,270
0,150 150,240 240,540 540,630 630,810
all the changes I want

1122
00:33:59,270 --> 00:34:00,680
0,60 60,390 600,1110 1110,1320 1320,1410
to make,| but once I
|但是一旦我开始做这些改变，

1123
00:34:00,680 --> 00:34:02,240
0,270 270,540 540,690 690,1200 1230,1560
start making these changes,| I
|我先做一两个，

1124
00:34:02,240 --> 00:34:03,770
0,360 360,540 540,870 870,960 960,1530
do like one or two,|
|

1125
00:34:03,950 --> 00:34:05,090
0,450 450,600 600,780 780,1020 1020,1140
and then make sure that
然后确保它们起作用，

1126
00:34:05,090 --> 00:34:07,070
0,300 300,840 840,1260 1260,1380 1380,1980
those work first| and then
|然后继续往前走，

1127
00:34:07,360 --> 00:34:08,650
0,510 510,570 570,720 720,960 960,1290
{} you know, keep going,|
|

1128
00:34:09,160 --> 00:34:10,750
0,360 360,1020 1080,1290 1290,1440 1440,1590
{} and the other thing
我做的另一件事是，

1129
00:34:10,750 --> 00:34:11,980
0,90 90,330 330,450 450,990 990,1230
I do| is mostly used
|主要是保留现有代码，

1130
00:34:11,980 --> 00:34:13,120
0,120 120,180 180,780 780,840 840,1140
as a strategy to keep

1131
00:34:13,120 --> 00:34:14,360
0,60 60,480 480,990
the existing code,|
|

1132
00:34:17,750 --> 00:34:20,360
0,570 690,1170 1170,1410 1410,2130 2250,2610
{} don't really modify certainly
不是修改最初的代码，

1133
00:34:20,360 --> 00:34:22,130
0,240 240,810 1020,1350 1350,1530 1530,1770
not initially,| I just add
|我是添加代码，并切换到新代码，

1134
00:34:22,130 --> 00:34:24,140
0,540 690,1410 1440,1740 1740,1860 1860,2010
code and switch to this

1135
00:34:24,140 --> 00:34:26,060
0,180 180,720 900,1440 1440,1650 1650,1920
new code| and then the
|然后[按部就班]，

1136
00:34:26,060 --> 00:34:26,930
0,180 180,420 420,720 720,810 810,870
little baby steps| and the
|我这么做的原因是，

1137
00:34:26,930 --> 00:34:27,770
0,240 240,330 330,510 510,750 750,840
reason I'm doing that is|
|

1138
00:34:27,770 --> 00:34:29,030
0,120 120,180 180,300 300,600 600,1260
that I can easily compare
我可以很容易地比较新旧代码，

1139
00:34:29,060 --> 00:34:31,070
0,540 540,720 720,1230 1560,1860 1860,2010
old new code,| {} and
|我总是有一个有效的旧解决方案，

1140
00:34:31,070 --> 00:34:32,570
0,90 90,360 360,540 540,990 1020,1500
I always have a working

1141
00:34:32,570 --> 00:34:33,590
0,300 300,690 690,810 810,900 900,1020
old solution,| that I can
|我可以直接回到过去，

1142
00:34:33,590 --> 00:34:35,300
0,210 240,570 570,870 870,1200 1410,1710
just roll back to,| so
|如果发生了一些奇怪的错误，

1143
00:34:35,300 --> 00:34:36,980
0,450 450,600 600,930 930,1230 1230,1680
{in,case} some strange bugs happens,|
|

1144
00:34:36,980 --> 00:34:37,760
0,210 210,270 270,390 390,570 570,780
then I can go back
然后我可以后退一步，然后再试一次，

1145
00:34:37,760 --> 00:34:40,250
0,210 210,420 420,870 1170,1830 2130,2490
maybe one step and then

1146
00:34:40,250 --> 00:34:41,600
0,210 210,600 600,960 960,1020 1020,1350
try again,| so you figure
|所以就像我说的，那样知道我的推理是错的。

1147
00:34:41,600 --> 00:34:42,500
0,180 180,360 360,480 480,690 690,900
out like I said were

1148
00:34:42,500 --> 00:34:43,780
0,120 120,510 510,630 630,1080
my [reason] was wrong.|
|

1149
00:34:44,540 --> 00:34:46,850
0,450 780,1650 1650,1800 1800,2010 2040,2310
{} Basically you know baby
小步走，部分原因是，

1150
00:34:46,850 --> 00:34:48,590
0,540 570,870 870,1200 1200,1530 1530,1740
steps {} what partly| because
|这些 bug 太难追踪了。

1151
00:34:48,590 --> 00:34:49,340
0,150 150,390 390,420 420,540 540,750
these bugs are so hard

1152
00:34:49,340 --> 00:34:50,160
0,60 60,270 270,600
to track down.|
|

1153
00:34:52,960 --> 00:34:55,570
0,600 840,1260 1290,1500 1500,1860 1890,2610
Okay, {} let me switch
好的，让我切换到代码，

1154
00:34:55,600 --> 00:34:56,480
0,270 270,660
{} to

1155
00:34:56,950 --> 00:35:00,550
0,450 450,1200 1350,1950 2490,3210 3240,3600
{} code,| {} so maybe
|从 vm.c 开始。

1156
00:35:00,550 --> 00:35:02,380
0,540 540,900 900,1230 1230,1440 1440,1830
starting {vm.c - -} {}.|
|

1157
00:35:02,470 --> 00:35:03,660
0,510 510,930
{} So,
这是现有的 kvminit ，

1158
00:35:03,780 --> 00:35:04,640
0,600
the,

1159
00:35:05,080 --> 00:35:07,870
0,300 300,960 1380,1830 1830,2280 2280,2790
here's the existing {kvminit -},|
|

1160
00:35:08,290 --> 00:35:10,750
0,540 540,690 690,1380 1410,1770 2040,2460
{} and actually can everybody
每个人都可以看到代码吗？

1161
00:35:10,750 --> 00:35:11,600
0,120 120,210 210,660
see the code?|
|

1162
00:35:14,650 --> 00:35:17,640
0,360 480,1170 1440,2130 2130,2730
Okay, {} and {},
好的，任务要求我们对它（内核页表）做一个副本，

1163
00:35:18,770 --> 00:35:20,360
0,540 570,1050 1050,1200 1200,1320 1320,1590
the assignment we are asked

1164
00:35:20,360 --> 00:35:21,920
0,330 330,720 720,900 900,1230 1230,1560
for [] is to make

1165
00:35:21,920 --> 00:35:23,930
0,90 90,390 390,480 480,780 1050,2010
a copy of it| and
|我做的方式是，

1166
00:35:24,020 --> 00:35:25,430
0,180 180,300 300,900 900,1260 1260,1410
{} the way I do

1167
00:35:25,430 --> 00:35:27,020
0,360 360,990 990,1140 1140,1320 1320,1590
that is,| let me see
|让我看看在哪里。

1168
00:35:27,020 --> 00:35:28,240
0,330 330,570 570,1020
where that is.|
|

1169
00:35:39,820 --> 00:35:41,020
0,270 270,480 480,750 750,1050 1050,1200
So here's my {uvmcreate -
这是我的 uvmcreate ，

1170
00:35:41,020 --> 00:35:42,970
0,630 660,870 870,1170 1170,1440 1470,1950
-},| {} that's just boring
|那只是无聊的部分，

1171
00:35:42,970 --> 00:35:44,980
0,360 360,510 510,870 870,1320 1320,2010
part,| that's basically creating {},
|基本上就是创建分配顶级页目录，

1172
00:35:45,010 --> 00:35:46,660
0,630 630,840 840,1200 1200,1440 1440,1650
allocating the top level page

1173
00:35:46,660 --> 00:35:48,610
0,450 450,540 540,630 630,1290 1560,1950
directory,| also the l2 page
|还有 l2 页目录。

1174
00:35:48,610 --> 00:35:49,460
0,630
directory.|
|

1175
00:35:49,760 --> 00:35:52,490
0,150 150,780 780,1530 1800,2130 2130,2730
And then {} here's {my,kvm},|
然后这里是我的 kvm- ，|

1176
00:35:52,490 --> 00:35:54,620
0,510 540,960 1050,1620 1620,1680 1680,2130
{} the equivalent of {kvminit
相当于 kvminit 。

1177
00:35:54,620 --> 00:35:55,380
0,120 120,450
- -}.|
|

1178
00:35:55,520 --> 00:35:56,720
0,630 660,810 810,900 900,1050 1050,1200
{} So I get the
我在这里获得了顶部的页目录，

1179
00:35:56,750 --> 00:35:57,890
0,300 300,390 390,480 480,690 690,1140
top of the page directory

1180
00:35:57,890 --> 00:36:00,410
0,480 1020,1680 1680,1860 1860,2040 2040,2520
here,| {} in this [].|
|在这个[]。|

1181
00:36:00,710 --> 00:36:03,590
0,510 510,900 900,1050 1050,1860 2220,2880
Then, basically I copy the
然后，我会复制从内核页表前 511 个条目，

1182
00:36:04,250 --> 00:36:06,500
0,360 360,780 780,1050 1050,1620 1740,2250
top {511 -} entries from

1183
00:36:06,500 --> 00:36:07,820
0,270 300,600 600,810 810,1140 1140,1320
the kernel {pagetable -}| that
|它已经由 kvminit 设置好，

1184
00:36:07,820 --> 00:36:09,320
0,150 150,420 420,630 630,930 930,1500
was already set up by

1185
00:36:09,650 --> 00:36:11,630
0,270 270,360 360,450 450,900 1440,1980
{kvminit - - -} {},|
|

1186
00:36:11,630 --> 00:36:12,560
0,240 240,330 330,510 510,750 750,930
and so that gives me
这给了我大部分的内核页表。

1187
00:36:12,560 --> 00:36:14,780
0,750 840,1110 1110,1650 1680,1980 1980,2220
most of the kernel {pagetable

1188
00:36:14,780 --> 00:36:15,600
0,540
-}.|
|

1189
00:36:15,630 --> 00:36:16,980
0,150 150,570 570,570 570,1110 1110,1350
And then, {} I just
然后，我需要映射所有设备，

1190
00:36:16,980 --> 00:36:18,750
0,240 240,330 330,660 660,1080 1470,1770
have to map in all

1191
00:36:18,750 --> 00:36:21,540
0,120 120,900 900,1200 1200,1710 1830,2790
the devices| that live {}
|它们在这里 0 号条目。

1192
00:36:22,240 --> 00:36:25,270
0,1200 1200,1380 1380,1770 1800,2340 2340,3030
{} in the zero entry,|
|

1193
00:36:25,300 --> 00:36:26,800
0,660 660,900 900,1200 1200,1260 1260,1500
because zero entry, the entry
因为 0 号条目，我们稍后要修改它，

1194
00:36:26,800 --> 00:36:27,520
0,120 120,180 180,330 330,390 390,720
that we're going to modify

1195
00:36:27,520 --> 00:36:28,300
0,60 60,420 420,570 570,660 660,780
it later| or we're going
|或者我们会将用户页面映射到底部。

1196
00:36:28,300 --> 00:36:29,740
0,120 150,630 630,840 840,1170 1170,1440
to map user pages into

1197
00:36:29,740 --> 00:36:30,600
0,90 90,510
the bottom.|
|

1198
00:36:30,760 --> 00:36:32,170
0,480 750,1020 1020,1170 1170,1200 1200,1410
{} And there's a couple
有几个设备在 0 号条目中，

1199
00:36:32,170 --> 00:36:33,370
0,420 420,600 600,750 750,810 810,1200
devices that live in that

1200
00:36:33,370 --> 00:36:35,020
0,270 270,600 600,960 960,1470 1470,1650
in zero entry,| those {you,know}
|那些的设备需要添加到，

1201
00:36:35,020 --> 00:36:36,250
0,390 390,570 570,630 630,750 750,1230
device needs to be added

1202
00:36:36,490 --> 00:36:37,540
0,270 270,540
to the

1203
00:36:37,720 --> 00:36:40,270
0,630 750,930 930,1320 1320,1710 2190,2550
{} to this,| {} per
|每个进程的内核页表。

1204
00:36:40,270 --> 00:36:42,400
0,630 660,1230 1230,1590 1620,1920 1920,2130
process {pagetable -}, kernel page

1205
00:36:42,400 --> 00:36:42,980
0,360
table.|
|

1206
00:36:44,140 --> 00:36:45,460
0,150 150,360 360,900 900,1140 1140,1320
And so maybe I go
所以我回到前面的这张图片上。

1207
00:36:45,460 --> 00:36:47,560
0,480 510,840 840,1110 1110,1500 1500,2100
back to this picture earlier.|
|

1208
00:36:47,990 --> 00:36:49,360
0,1140

1209
00:36:51,260 --> 00:36:52,820
0,270 270,450 450,930 1020,1410 1410,1560
So let me put up
让我再次设置内核页表，

1210
00:36:52,820 --> 00:36:54,920
0,270 300,600 600,870 870,1350 1380,2100
the kernel {pagetable -} again,|
|

1211
00:36:56,790 --> 00:36:59,550
0,1500 1860,2310 2310,2430 2430,2700 2700,2760
{} maybe this picture as
可能这张图片跟任何都一样，

1212
00:36:59,550 --> 00:37:01,590
0,180 180,810 810,1260 1500,1890 1890,2040
good as any {},| so
|所以如果你考虑我的解决方案，

1213
00:37:01,590 --> 00:37:02,730
0,90 90,510 510,690 690,960 960,1140
if you think about my

1214
00:37:02,730 --> 00:37:06,570
0,720 870,1500 1590,2430 2580,3210 3210,3840
solution,| {} basically these entries
|基本上这些条目我只是与现有内核页表共享，

1215
00:37:07,050 --> 00:37:09,510
0,150 150,360 360,1050 1170,1920 2010,2460
I just share with {}

1216
00:37:09,510 --> 00:37:11,400
0,510 510,780 780,1020 1020,1440 1740,1890
existing kernel {pagetable -},| so
|所以我不需要分配任何 l1 或 l2 或 l0 级别，

1217
00:37:11,400 --> 00:37:12,360
0,60 60,270 270,420 420,510 510,960
I don't have to allocate

1218
00:37:12,360 --> 00:37:14,100
0,240 240,390 390,960 990,1170 1170,1740
any {l1 -} or l2

1219
00:37:14,100 --> 00:37:16,350
0,180 180,360 360,660 660,1260 1440,2250
or {l0 -} levels,| they
|它们已经存在了，

1220
00:37:16,350 --> 00:37:18,060
0,270 270,780 780,1290 1350,1500 1500,1710
already exists| and the only
|我唯一做的就是字面意思上的复制 pte 条目。

1221
00:37:18,060 --> 00:37:18,990
0,150 150,240 240,450 450,540 540,930
thing I do is basically

1222
00:37:18,990 --> 00:37:21,400
0,630 720,1320 1320,1740 1740,2190
literally copy pte entry.|
|

1223
00:37:22,160 --> 00:37:24,050
0,270 270,840 840,1050 1050,1410 1410,1890
So only the bottom part
所以只有底部部分或底部条目，

1224
00:37:24,080 --> 00:37:25,940
0,270 270,510 780,1620
or the bottom

1225
00:37:25,970 --> 00:37:27,500
0,660 690,1050 1050,1170 1170,1290 1290,1530
entry that is the piece,|
|

1226
00:37:27,500 --> 00:37:29,720
0,60 60,270 270,720 720,1200 1290,2220
I need to actually rebuild
我需要真正重建或复制，而不只是复制 pte 。

1227
00:37:29,720 --> 00:37:31,370
0,270 270,750 750,1350 1350,1590 1590,1650
or copy explicitly instead of

1228
00:37:31,370 --> 00:37:32,680
0,390 390,1110
copying ptes.|
|

1229
00:37:32,850 --> 00:37:34,050
0,180 180,420 420,990 990,1110 1110,1200
And that covers you know
这就覆盖了底部的[千兆]字节的地址空间。

1230
00:37:34,050 --> 00:37:35,160
0,240 240,870
the bottom

1231
00:37:35,530 --> 00:37:38,200
0,300 300,990 1230,1770 1770,2190 2190,2670
one {[gigabyte] -} address space.|
|

1232
00:37:39,000 --> 00:37:41,460
0,210 210,540 540,1050 1470,2040 2250,2460
In one page covers {4096
在一页中包含 4096 。

1233
00:37:41,460 --> 00:37:42,460
0,870
-}.|
|

1234
00:37:45,930 --> 00:37:47,730
0,660 660,960 960,1140 1140,1680 1680,1800
{} And so this you
所以这个条目包含 512 。

1235
00:37:47,730 --> 00:37:49,950
0,450 660,900 900,1560 1560,1890 1890,2220
know this entry covers five

1236
00:37:49,950 --> 00:37:50,940
0,750
twelve.|
|

1237
00:37:51,060 --> 00:37:52,650
0,390 840,1080 1080,1200 1200,1380 1380,1590
But this has been two
这（最右边的）是 2 兆字节了。

1238
00:37:52,650 --> 00:37:53,620
0,720
megabyte.|
|

1239
00:37:54,360 --> 00:37:55,770
0,150 150,300 300,390 390,690 690,1410
And this is one gigabyte|
而这（中间的）是一千兆字节，|

1240
00:37:56,280 --> 00:37:57,720
0,330 330,750 750,990 990,1350 1350,1440
and basically only one of
所以只有一个条目，我需要填充它。

1241
00:37:57,720 --> 00:37:58,530
0,210 210,540 540,570 570,750 750,810
these entries, I need to

1242
00:37:58,530 --> 00:37:59,180
0,240 240,420
fill it.|
|

1243
00:38:01,810 --> 00:38:02,760
0,210 210,360 360,720
That makes sense?|
能理解吗?|

1244
00:38:05,370 --> 00:38:07,080
0,360 390,810 810,1110 1110,1290 1290,1710
So returning to my code
回到我的代码，基本上，

1245
00:38:07,080 --> 00:38:08,980
0,180 180,840 1080,1680
and basically {},|
|

1246
00:38:09,180 --> 00:38:10,680
0,240 240,390 390,480 480,840 870,1500
that's all I do, {kvmcreate
这就是我所做的一切， kvmcreate 。

1247
00:38:10,680 --> 00:38:11,460
0,540
-}.|
|

1248
00:38:12,090 --> 00:38:14,250
0,660 1110,1560 1560,1740 1740,2010 2010,2160
{} And in kv- my
在我的 kvmfree 中是清理方案，

1249
00:38:14,250 --> 00:38:15,930
0,450 450,990 1020,1260 1260,1440 1440,1680
{kvmfree -} {} is maybe

1250
00:38:15,930 --> 00:38:17,880
0,270 270,1170 1290,1650 1650,1890 1890,1950
{} not, maybe clean {}

1251
00:38:17,880 --> 00:38:19,590
0,630 840,1170 1170,1200 1200,1440 1440,1710
solution,| but I take full
|但我充分利用了这些[知识]，

1252
00:38:19,590 --> 00:38:21,180
0,600 630,690 690,810 810,1230 1230,1590
advantage of the [knowledge]| that
|我不需要对条目 1 到 511 做任何事情，

1253
00:38:21,480 --> 00:38:22,620
0,690 690,780 780,930 930,1050 1050,1140
{} I don't have to

1254
00:38:22,620 --> 00:38:23,760
0,150 150,540 540,660 660,750 750,1140
do anything from the entries

1255
00:38:23,760 --> 00:38:25,080
0,300 300,510 510,960 960,1230 1230,1320
one to {511 -}| in
|在顶级[]目录中。

1256
00:38:25,080 --> 00:38:26,400
0,60 60,360 360,540 540,720 720,1320
the top [] level directory.|
|

1257
00:38:26,730 --> 00:38:27,840
0,180 180,480 480,870 870,960 960,1110
The only entry to do
唯一要处理的条目是

1258
00:38:27,840 --> 00:38:30,750
0,360 360,840 840,1080 1080,1440 2490,2910
anything about is| the bottom
|内核顶级目录的底部条目。

1259
00:38:30,750 --> 00:38:32,010
0,300 300,420 420,510 510,1080 1110,1260
entry of the kernel of

1260
00:38:32,010 --> 00:38:33,660
0,330 390,660 660,840 840,1440
the top level directory.|
|

1261
00:38:33,790 --> 00:38:35,290
0,390 390,750 750,840 840,1320 1320,1500
That points to one {l1
它指向一个 l1 条目，

1262
00:38:35,290 --> 00:38:37,210
0,510 690,1050 1050,1440 1440,1650 1650,1920
-} {} entry| and that
|那个 l1 条目，我只需要遍历，

1263
00:38:37,210 --> 00:38:38,500
0,330 330,570 570,750 750,990 990,1290
one {l1 - -} entry,

1264
00:38:38,500 --> 00:38:39,190
0,150 150,360 360,480 480,540 540,690
I just need to go

1265
00:38:39,190 --> 00:38:40,960
0,540 750,1530
through| and
|释放旧的 l2 或 l0 条目。

1266
00:38:40,990 --> 00:38:43,540
0,240 240,1140 1170,1980 2010,2340 2340,2550
{} {free,old} l2 or {l0

1267
00:38:43,540 --> 00:38:44,620
0,360 360,930
-} entries.|
|

1268
00:38:45,010 --> 00:38:45,910
0,180 180,330 330,450 450,810 810,900
And then the ends you
然后，释放 l1 ，

1269
00:38:45,910 --> 00:38:46,990
0,210 210,480 480,600 600,960 960,1080
know free {l1 -}| and
|然后是内核页表。

1270
00:38:46,990 --> 00:38:47,950
0,90 90,150 150,390 390,600 600,960
then the kernel {pagetable -}.|
|

1271
00:38:49,420 --> 00:38:51,010
0,330 330,450 450,690 690,840 840,1590
And so that's my k-
这就是我的 kvmfree 和 kvmcreate 。

1272
00:38:51,040 --> 00:38:52,180
0,480 480,780 780,900 900,1050 1050,1140
{kvmfree -} and my {kvmcreate

1273
00:38:52,180 --> 00:38:53,460
0,570 570,1110
- -}.|
|

1274
00:38:54,050 --> 00:38:55,010
0,180 180,390 450,750 750,870 870,960
So that allows me to
这样我就可以创建内核页表进程，

1275
00:38:55,010 --> 00:38:56,540
0,300 300,450 450,840 840,1230 1230,1530
create a kernel {pagetable -}

1276
00:38:56,540 --> 00:38:58,200
0,690 690,930 930,1410
process| and then
|然后在使用完成后释放。

1277
00:38:58,270 --> 00:39:00,640
0,960 990,1350 1350,1650 1650,2010 2040,2370
{} free once is when

1278
00:39:00,640 --> 00:39:01,300
0,90 90,390
we're done.|
|

1279
00:39:02,360 --> 00:39:04,340
0,360 360,540 540,1110 1350,1710 1710,1980
Sorry, quick question.| Could you
抱歉，提个小问题。|您能再解释一下，

1280
00:39:04,340 --> 00:39:06,500
0,480 480,840 840,930 930,1440 1440,2160
explain again,| the reasoning for
|为什么只使用 1 到 512 而不使用 0 ？

1281
00:39:06,830 --> 00:39:08,150
0,330 330,660 660,960 960,1170 1170,1320
{} only using one to

1282
00:39:08,150 --> 00:39:09,470
0,270 270,630 630,750 750,930 930,1320
five twelve and not zero?|
|

1283
00:39:10,360 --> 00:39:14,110
0,540 570,1380 1620,2040 2040,2640 3060,3750
Yes.| {} Okay, so, {}|
是。|好的，那么，|

1284
00:39:14,110 --> 00:39:15,010
0,270 270,330 330,660 660,840 840,900
maybe the easy thing to
也许最容易的是，让我回到这里的图片。

1285
00:39:15,010 --> 00:39:16,060
0,270 270,600 600,750 750,900 900,1050
do actually let me go

1286
00:39:16,060 --> 00:39:17,470
0,240 240,360 360,510 510,900 900,1410
back through the picture here.|
|

1287
00:39:19,860 --> 00:39:21,150
0,660 690,870 870,1020 1020,1200 1200,1290
{} So we have a
所以我们有一个内核地址空间。

1288
00:39:21,150 --> 00:39:22,700
0,270 270,510 510,870 870,1320
kernel address space, correct.|
|

1289
00:39:26,240 --> 00:39:28,250
0,810 960,1500 1500,1590 1590,1680 1680,2010
{} And you know this
这个 Ox8000 等等，

1290
00:39:28,250 --> 00:39:29,990
0,90 90,600 600,1110 1140,1440 1440,1740
O x eight zero zero

1291
00:39:29,990 --> 00:39:32,160
0,330 330,1020 1290,1980
zero zero {blah,blah,blah},|
|

1292
00:39:32,220 --> 00:39:33,400
0,360 360,960
in, um.|
在，嗯。|

1293
00:39:34,270 --> 00:39:35,560
0,300 300,600 600,780 780,1020 1020,1290
What entry does O x
在顶层页面目录中， Ox0 属于哪个条目。

1294
00:39:35,560 --> 00:39:37,090
0,330 330,600 600,1050 1050,1320 1320,1530
zero fall into in the

1295
00:39:37,090 --> 00:39:38,050
0,120 120,180 180,420 420,750 750,960
for the top level page

1296
00:39:38,050 --> 00:39:38,820
0,510
directory.|
|

1297
00:39:46,150 --> 00:39:47,440
0,510 510,1050
{It's,like}, the.|
比如。|

1298
00:39:49,340 --> 00:39:51,440
0,420 420,900 1200,1770 1770,1980 1980,2100
Zeroth entry?| No, not to
0 号条目？|不，不是 0 号条目。

1299
00:39:51,440 --> 00:39:52,660
0,270 270,600 600,960
zeroth entry, right.|
|

1300
00:39:53,440 --> 00:39:54,880
0,270 270,780 780,900 900,1110 1110,1440
So whatever you know what
所以你知道 0 号条目，

1301
00:39:54,880 --> 00:39:56,680
0,660 660,1200 1230,1380 1380,1560 1560,1800
zero entry like this entry,|
|

1302
00:39:56,680 --> 00:39:57,940
0,120 120,330 330,510 510,570 570,1260
how much does it cover
这个条目包含多少？

1303
00:39:57,970 --> 00:39:58,800
0,180 180,600
this entry.|
|

1304
00:40:02,450 --> 00:40:03,470
0,150 150,330 330,630 630,870 870,1020
How much address space,| does
多少地址空间，|顶层页面目录的底部条目即 0 号条目包含多少。

1305
00:40:03,470 --> 00:40:05,360
0,360 360,1110 1170,1620 1620,1800 1800,1890
this bottom entry of the

1306
00:40:05,360 --> 00:40:06,410
0,300 300,570 570,720 720,780 780,1050
zero entry of the top

1307
00:40:06,410 --> 00:40:07,740
0,150 150,360 360,690 690,1080
level page directory cover.|
|

1308
00:40:10,140 --> 00:40:12,690
0,240 240,720 720,1470 1530,1980 2010,2550
I think CLINT is {},|
我认为 CLINT 是|

1309
00:40:12,690 --> 00:40:14,820
0,300 300,570 570,1140 1140,1770 1770,2130
it's free between zero and
在 0 到 0x2000 之间。

1310
00:40:14,820 --> 00:40:16,320
0,300 300,600 600,1080 1080,1290 1290,1500
{0x2000 - - - -

1311
00:40:16,320 --> 00:40:17,000
0,420
-}.|
|

1312
00:40:17,730 --> 00:40:18,780
0,300 300,450 450,600 600,750 750,1050
Yeah, so okay so maybe
是的，也许我会这么做，

1313
00:40:18,780 --> 00:40:19,920
0,60 60,300 300,420 420,750 840,1140
I'm going to,| I think
|我认为你的方向是正确的，

1314
00:40:19,920 --> 00:40:21,300
0,150 150,480 480,690 690,990 990,1380
you're absolutely right direction,| so
|所以最下面的条目复制了一千兆字节。

1315
00:40:21,360 --> 00:40:22,890
0,510 540,870 870,1080 1080,1320 1320,1530
the bottom entry copy one

1316
00:40:22,890 --> 00:40:24,020
0,510 540,900
gigabyte, right.|
|

1317
00:40:24,750 --> 00:40:27,240
0,720 720,1020 1020,1680 1740,2160 2160,2490
And we know like maybe
我们知道，也许我可以。

1318
00:40:27,240 --> 00:40:27,920
0,90 90,390
I can.|
|

1319
00:40:29,630 --> 00:40:31,460
0,750 900,1380 1380,1500 1500,1590 1590,1830
{} We saw the bottom
我们看到最下面的条目是一千兆字节，

1320
00:40:31,460 --> 00:40:34,400
0,240 240,420 420,1080 1440,2100 2100,2940
entry one gigabyte {} which,|
|

1321
00:40:35,050 --> 00:40:36,280
0,960

1322
00:40:36,860 --> 00:40:38,060
0,240 240,300 300,540 540,990 990,1200
in that one gigabyte just
在那一千兆字节有 CLINT 和 PLIC ，

1323
00:40:38,060 --> 00:40:39,960
0,600 600,690 690,1140 1170,1560
CLINT the PLIC, right,|
|

1324
00:40:40,380 --> 00:40:43,530
0,810 840,1800 2160,2670 2670,3060 3060,3150
UART and {VIRTIO_disk -}, I
我相信还有 UART 和 VIRTIO_disk 。

1325
00:40:43,530 --> 00:40:44,280
0,510
believe.|
|

1326
00:40:44,500 --> 00:40:47,020
0,810 1200,1380 1380,1920 1950,2250 2250,2520
{} And then {KERNBASE -}
然后 KERNBASE 位于一个更高的条目上。

1327
00:40:47,020 --> 00:40:48,340
0,270 270,600 600,840 840,1080 1080,1320
actually already sits up in

1328
00:40:48,340 --> 00:40:51,340
0,60 60,720 1710,2220 2250,2580 2850,3000
a higher entry, right. {}|
|

1329
00:40:51,340 --> 00:40:52,270
0,90 90,210 210,540 540,870 870,930
We can compute if we
我们可以计算一下，

1330
00:40:52,270 --> 00:40:53,110
0,270 270,390 390,540 540,660 660,840
wanted to,| we could take
|我们可以取 0x80- ，

1331
00:40:53,110 --> 00:40:55,240
0,450 450,900 900,1410 1410,1590 1590,2130
0x eight zero correct,| shifted
|移位 12 ，移位 9 ，移位 9 ，

1332
00:40:55,670 --> 00:40:57,500
0,300 300,990 1140,1440 1440,1500 1500,1830
{} twelve, shift {} nine,

1333
00:40:57,500 --> 00:40:59,990
0,270 270,900 1140,1890 1890,2010 2010,2490
shift nine,| and I I
|我想，我不记得顶部是什么了。

1334
00:41:00,020 --> 00:41:01,520
0,660 780,900 900,1050 1050,1410 1410,1500
think I don't remember the

1335
00:41:01,520 --> 00:41:02,660
0,210 210,300 300,480 480,720 720,1140
top we have what is

1336
00:41:02,690 --> 00:41:04,080
0,510
{}.|
|

1337
00:41:04,420 --> 00:41:05,230
0,180 180,300 300,510 510,600 600,810
Try to figure it out,
试着弄清楚，也许我们来试一试。

1338
00:41:05,230 --> 00:41:06,130
0,90 90,150 150,360 360,540 540,900
if you want to actually

1339
00:41:06,130 --> 00:41:07,160
0,240 240,360 360,810
maybe we'll try.|
|

1340
00:41:08,270 --> 00:41:09,350
0,210 210,270 270,570 570,780 780,1080
This is always very [risky]
在演讲中这样做总是有[风险]的，

1341
00:41:09,350 --> 00:41:10,670
0,90 90,210 210,570 600,1080 1080,1320
to do in lecture,| but,
|所以， gdb 。

1342
00:41:12,070 --> 00:41:15,040
0,510 510,630 630,900 900,1470 2010,2970
{} so, {gdb - -

1343
00:41:15,160 --> 00:41:16,200
0,450 450,810
- -}.|
|

1344
00:41:16,240 --> 00:41:17,660
0,210 210,420 420,630 630,990
So let's go to
我们来看看 memlayout.h ，这是 KERNBASE ，

1345
00:41:19,310 --> 00:41:22,800
0,1050 1350,1920 1920,2250 2250,2880
layout, here's {KERNBASE -},|
|

1346
00:41:29,240 --> 00:41:31,760
0,600 600,870 870,1260 1260,1590 1620,2520
{} so we could print.|
所以我们可以打印。|

1347
00:41:32,800 --> 00:41:34,760
0,360 360,690 690,840 840,1620
So shift is twelve,
移位是 12 ，这给了我们，偏移量。

1348
00:41:36,340 --> 00:41:38,060
0,300 300,690 690,1320
that gives us,

1349
00:41:38,470 --> 00:41:40,340
0,450 450,660 660,960 960,1530
that {offset -}.| Oops.|
|哎呀。|

1350
00:41:46,280 --> 00:41:48,110
0,300 300,510 510,1110 1140,1530 1530,1830
Good as that, so then
好的，然后我们移位这个值。

1351
00:41:48,110 --> 00:41:49,180
0,630
we'll

1352
00:41:50,350 --> 00:41:51,660
0,300 300,930
{shift,that} guy.|
|

1353
00:41:51,980 --> 00:41:52,670
0,150 150,300 300,420 420,540 540,690
I think you could see
我想你可以看到这个。

1354
00:41:52,670 --> 00:41:54,000
0,570
this.|
|

1355
00:41:54,600 --> 00:41:55,720
0,870
Nine.|
九。|

1356
00:41:56,740 --> 00:41:57,910
0,270 270,480 480,630 630,870 900,1170
Right now is the next
现在再做一次，

1357
00:41:57,910 --> 00:42:00,200
0,630 930,1380 1380,1980
entry one more,|
|

1358
00:42:01,480 --> 00:42:02,700
0,150 150,270 270,510 510,960
so this entry two.|
所以这是条目 2 。|

1359
00:42:03,880 --> 00:42:04,840
0,120 120,180 180,330 330,690
Does it make sense.|
能理解吗。|

1360
00:42:06,270 --> 00:42:07,680
0,270 270,390 390,510 510,900 900,1410
So we go back to
所以我们回到这里来看图片。

1361
00:42:07,710 --> 00:42:09,040
0,180 180,510 510,1050
our picture here.|
|

1362
00:42:11,260 --> 00:42:14,680
0,900 1170,1560 1560,2340 2340,2730 2730,3420
Basically KERNBASE is entry two,|
KERNBASE 是条目 2 ，|

1363
00:42:15,400 --> 00:42:16,990
0,360 360,720 720,1080 1110,1350 1350,1590
{} in the top of
在顶级页目录中。

1364
00:42:16,990 --> 00:42:17,820
0,60 60,570
page directory,

1365
00:42:18,450 --> 00:42:20,460
0,330 330,600 600,1080 1380,1770 1770,2010
right.| So and {} we
|我们从作业的第三部分了解到，

1366
00:42:20,460 --> 00:42:21,930
0,270 270,570 570,1020 1080,1320 1320,1470
know from the third part

1367
00:42:21,930 --> 00:42:23,220
0,60 60,150 150,750 750,1170 1170,1290
of the assignment,| basically we
|我们不需要考虑 PLIC 上面的任何东西。

1368
00:42:23,220 --> 00:42:24,240
0,150 150,360 360,570 570,660 660,1020
don't really have to worry

1369
00:42:24,240 --> 00:42:25,540
0,390 390,990
about anything

1370
00:42:25,640 --> 00:42:27,180
0,450 450,870 870,1350
{} above PLIC.|
|

1371
00:42:28,480 --> 00:42:30,910
0,750 750,1080 1080,1260 1260,2130 2130,2430
And all that stuff falls
所有这些东西上都在条目 0 。

1372
00:42:30,910 --> 00:42:32,460
0,570 570,870 870,1350
actually entry zero.|
|

1373
00:42:34,390 --> 00:42:35,200
0,600
Okay?|
好的?|

1374
00:42:36,560 --> 00:42:37,550
0,210 210,450 450,570 570,660 660,990
So that answer the earlier
所以这回答了之前的问题。

1375
00:42:37,550 --> 00:42:38,300
0,510
question.|
|

1376
00:42:39,620 --> 00:42:40,960
0,420 420,690 690,900
Yes, thank you.|
好的，谢谢。|

1377
00:42:42,860 --> 00:42:43,790
0,210 210,330 330,600 600,840 840,930
Okay, so now we the
好的，现在我们要做的还剩下的就是，

1378
00:42:43,790 --> 00:42:45,320
0,180 180,360 360,540 540,780 780,1530
only thing we have left

1379
00:42:45,320 --> 00:42:46,490
0,60 60,390 390,810 810,900 900,1170
to do is,| you know,
|再次检查调用函数 kvmcreate 的地方，

1380
00:42:46,490 --> 00:42:48,350
0,360 390,750 750,1050 1050,1440 1440,1860
{} double check where we

1381
00:42:48,350 --> 00:42:50,450
0,180 180,270 270,840 870,1410 1410,2100
got to call this function

1382
00:42:50,450 --> 00:42:51,300
0,570
{}

1383
00:42:51,540 --> 00:42:54,270
0,210 210,600 600,750 750,1320 1800,2730
{} {kvmcreate - -},| and
|这将是 allocproc 。

1384
00:42:54,270 --> 00:42:55,080
0,570

1385
00:42:56,940 --> 00:42:57,990
0,390 450,600 600,690 690,930 930,1050
and you know that's going

1386
00:42:57,990 --> 00:42:59,910
0,60 60,450 450,660 660,1320 1410,1920
to be {} {allocproc -}.|
|

1387
00:43:01,270 --> 00:43:02,620
0,510 510,1110
{} So,
所以，并且。

1388
00:43:02,970 --> 00:43:04,020
0,750
and.|
|

1389
00:43:04,630 --> 00:43:05,760
0,120 120,450 450,900

1390
00:43:06,820 --> 00:43:07,460
0,420
Oops.|
哎呀。|

1391
00:43:12,460 --> 00:43:13,450
0,300 300,570 570,660 660,750 750,990
Here where is the new
这里是新进程初始化的地方，

1392
00:43:13,450 --> 00:43:15,400
0,360 360,1020 1020,1290 1290,1380 1380,1950
process initialized,| then you know
|我相信你们都是一样的，

1393
00:43:15,610 --> 00:43:16,390
0,150 150,420 420,570 570,660 660,780
I'm sure all of you

1394
00:43:16,390 --> 00:43:17,740
0,270 270,630 630,690 690,870 870,1350
is exactly the same way,|
|

1395
00:43:17,740 --> 00:43:19,750
0,240 240,900 900,1110 1110,1650 1740,2010
you entry, you allocate when
当你在 proc 结构中声明字段时，

1396
00:43:19,750 --> 00:43:20,650
0,60 60,390 390,450 450,750 750,900
you declare {} field in

1397
00:43:20,650 --> 00:43:22,810
0,300 330,570 570,1170 1470,1800 1800,2160
the proc structure| and basically
|它的结果，我们放在内核页表中。

1398
00:43:22,810 --> 00:43:23,530
0,120 120,390 390,480 480,570 570,720
the result of it is

1399
00:43:23,530 --> 00:43:24,370
0,270 270,420 420,540 540,750 750,840
actually what we stick in

1400
00:43:24,370 --> 00:43:25,440
0,60 60,270 270,510 510,840
the kernel {pagetable -}.|
|

1401
00:43:27,080 --> 00:43:27,950
0,210 210,570 570,690 690,780 780,870
Okay, then we only the
好的，我们需要考虑的另一件事是，

1402
00:43:27,950 --> 00:43:28,520
0,150 150,270 270,330 330,450 450,570
thing that we have to

1403
00:43:28,520 --> 00:43:29,390
0,240 240,510 510,570 570,780 780,870
worry about,| of course we
|当然我们需要使用页表，

1404
00:43:29,390 --> 00:43:30,290
0,180 180,240 240,570 570,630 630,900
need to use the {pagetable

1405
00:43:30,290 --> 00:43:31,000
0,480
-},|
|

1406
00:43:31,150 --> 00:43:32,770
0,600 600,960 960,1260 1260,1440 1440,1620
{} and so we need
所以，我们需要查看调度器。

1407
00:43:32,770 --> 00:43:34,180
0,60 60,240 240,360 360,660 690,1410
to look at the scheduler.|
|

1408
00:43:34,600 --> 00:43:36,220
0,570 570,660 660,1380 1380,1590 1590,1620
Basically, the assignment more or
基本上，任务多少会告诉你做什么，

1409
00:43:36,220 --> 00:43:36,850
0,150 150,360 360,420 420,540 540,630
less told you what to

1410
00:43:36,850 --> 00:43:38,560
0,450 810,1080 1080,1350 1350,1590 1590,1710
do| {} which is you
|在切换到用户进程之前，

1411
00:43:38,560 --> 00:43:40,600
0,300 300,720 720,810 810,1470 1620,2040
know before you switch to

1412
00:43:40,600 --> 00:43:41,860
0,240 240,450 450,930 930,1110 1110,1260
that user process,| you need
|你需要切换内核页表，

1413
00:43:41,860 --> 00:43:42,760
0,60 60,330 330,420 420,660 660,900
to switch the kernel {pagetables

1414
00:43:42,760 --> 00:43:43,540
0,600
-},|
|

1415
00:43:43,720 --> 00:43:45,430
0,210 210,540 540,870 870,1530 1560,1710
which basically means loading, you
意味着加载进程内核页表到 satp 。

1416
00:43:45,430 --> 00:43:47,200
0,120 120,630 780,1230 1230,1500 1500,1770
know, this process kernel {pagetable

1417
00:43:47,200 --> 00:43:48,880
0,330 330,480 480,630 630,1410
-} {in -} satp.|
|

1418
00:43:49,020 --> 00:43:50,970
0,150 150,270 270,420 420,1020 1350,1950
And then when you're done
然后当你完成切换来运行另一个进程，

1419
00:43:50,970 --> 00:43:53,430
0,690 930,1800 1800,2010 2010,2370 2370,2460
switching {} in running the

1420
00:43:53,430 --> 00:43:54,600
0,180 180,630 630,750 750,840 840,1170
other process,| you come back
|你从另一个进程返回，

1421
00:43:54,600 --> 00:43:55,770
0,120 120,360 360,420 420,630 630,1170
from running the other process|
|

1422
00:43:55,770 --> 00:43:56,670
0,240 240,360 360,510 510,660 660,900
and you're gonna go back
然后你回到并运行调度程序，

1423
00:43:56,670 --> 00:43:58,110
0,210 210,270 270,870 1080,1260 1260,1440
{and,run} the scheduler,| you gotta
|你必须切换回主内核页表，

1424
00:43:58,110 --> 00:43:59,490
0,300 300,690 690,840 840,990 990,1380
switch back to the main

1425
00:43:59,490 --> 00:44:00,740
0,300 300,540 540,990
kernel {pagetable -},|
|

1426
00:44:00,980 --> 00:44:02,930
0,600 660,1140 1140,1440 1440,1650 1650,1950
the [] kernel {pagetable -},|
[]内核页表，|

1427
00:44:02,930 --> 00:44:03,800
0,210 210,480 480,540 540,750 750,870
because that's the one that
因为这才是调度器实际使用的。

1428
00:44:03,800 --> 00:44:05,200
0,240 240,510 510,630 630,1140
actually used by scheduler.|
|

1429
00:44:07,260 --> 00:44:07,860
0,120 120,270 270,360 360,450 450,600
And why do we need
为什么我们做这个切换，

1430
00:44:07,860 --> 00:44:09,240
0,60 60,210 210,390 390,930 1170,1380
to do this switch,| why
|为什么这很重要。

1431
00:44:09,240 --> 00:44:10,300
0,90 90,240 240,840
is this important.|
|

1432
00:44:16,820 --> 00:44:17,740
0,660
Anybody?|
有人知道吗？|

1433
00:44:19,820 --> 00:44:20,870
0,270 270,390 390,660 660,810 810,1050
So it picks the right
因为它选择了正确的内核页表，

1434
00:44:20,870 --> 00:44:23,240
0,360 360,630 630,1080 1590,2280 2280,2370
kernel {pagetable -},| because the
|因为 satp ，当你转到页表条目时，

1435
00:44:23,240 --> 00:44:24,380
0,330 330,630 660,840 840,990 990,1140
{satp -}, when you go

1436
00:44:24,380 --> 00:44:26,030
0,90 90,360 390,660 660,960 960,1650
to the {pagetable -} entries,|
|

1437
00:44:26,060 --> 00:44:27,160
0,120 120,390 390,510 510,870
it picks the right,|
它选择了，|

1438
00:44:27,700 --> 00:44:28,810
0,120 120,360 360,450 450,810 810,1110
it picks the right {pagetable
它选择了正确的页表。

1439
00:44:28,810 --> 00:44:30,220
0,420 450,600 600,900 900,1170
-} to pick from.|
|

1440
00:44:30,770 --> 00:44:31,740
0,690
Yeah,
嗯，稍等一下。

1441
00:44:33,420 --> 00:44:35,250
0,720 720,930 1020,1410 1410,1710 1710,1830
{hold,on} or something more than

1442
00:44:35,250 --> 00:44:37,120
0,90 90,570 1110,1620
a second {}.|
|

1443
00:44:40,210 --> 00:44:42,850
0,660 660,1140 1380,1680 1680,2160 2250,2640
Yeah, so okay, so when
是的，所以好的，当我们停下来的时候。

1444
00:44:42,850 --> 00:44:44,000
0,210 210,930
we stop.|
|

1445
00:44:44,210 --> 00:44:45,050
0,240 240,480 480,540 540,750 750,840
Okay, let me another way
好的，让我换一种方式问这个问题，

1446
00:44:45,050 --> 00:44:47,060
0,180 180,420 420,510 510,1080 1470,2010
to ask this question,| when
|这个内核页表是什么时候释放的。

1447
00:44:47,060 --> 00:44:48,020
0,120 120,240 240,510 510,690 690,960
is this kernel {pagetable -}

1448
00:44:48,020 --> 00:44:48,740
0,450
freed.|
|

1449
00:44:52,000 --> 00:44:53,260
0,210 210,300 300,600 600,1110 1110,1260
When the user process is
当用户进程完成时，

1450
00:44:53,260 --> 00:44:54,580
0,330 330,720 720,930 930,1050 1050,1320
done,| so if we didn't
|所以如果我们不交换（页表），

1451
00:44:54,580 --> 00:44:55,990
0,420 420,630 630,780 780,1080 1080,1410
switch,| that would mean that
|那就意味着，

1452
00:44:55,990 --> 00:44:57,490
0,390 780,1020 1020,1170 1170,1380 1380,1500
that,| {} we could be
|我们可以使用一个被释放进程的页表，

1453
00:44:57,490 --> 00:44:58,630
0,270 270,330 330,600 600,1020 1020,1140
using a {pagetable -} of

1454
00:44:58,630 --> 00:44:59,950
0,120 120,510 510,810 840,1080 1080,1320
a process that was being

1455
00:44:59,950 --> 00:45:01,600
0,480 480,690 690,840 1200,1440 1440,1650
freed,| so the {pagetable -}
|页表被释放了，

1456
00:45:01,600 --> 00:45:02,890
0,210 210,660 870,1080 1080,1170 1170,1290
was freed,| so we don't
|所以，我们不想依赖于当前未运行的进程。

1457
00:45:02,890 --> 00:45:03,700
0,120 120,180 180,270 270,720 720,810
want to be dependent on

1458
00:45:03,700 --> 00:45:04,930
0,60 60,480 480,600 600,870 900,1230
the process were not running

1459
00:45:04,930 --> 00:45:06,850
0,180 180,540 780,1080 1080,1500 1500,1920
right now.| Yeah, exactly, we
|没错，我们永远不能释放当前正在运行的进程的页表。

1460
00:45:06,850 --> 00:45:07,870
0,90 90,390 390,690 690,780 780,1020
can never free the page

1461
00:45:07,870 --> 00:45:08,620
0,60 60,270 270,330 330,450 450,750
table of the process {}

1462
00:45:08,620 --> 00:45:09,800
0,150 150,510 510,900
that's currently running.|
|

1463
00:45:10,400 --> 00:45:11,510
0,660 660,810 810,930 930,1050 1050,1110
{} So we have to
所以我们要有一个计划，

1464
00:45:11,510 --> 00:45:12,680
0,120 120,330 330,900 930,1080 1080,1170
have some plan,| you know
|在进程不再运行时释放它们。

1465
00:45:12,680 --> 00:45:14,720
0,240 240,570 570,840 840,1530 1530,2040
to actually free process at

1466
00:45:14,720 --> 00:45:15,560
0,90 90,360 360,450 450,600 600,840
the point that they're not

1467
00:45:15,560 --> 00:45:16,460
0,210 210,690
running anymore.|
|

1468
00:45:16,860 --> 00:45:18,060
0,330 330,540 540,660 660,900 900,1200
And you know the wait
wait 系统调用是我们的退出方式，

1469
00:45:18,060 --> 00:45:19,200
0,300 300,660 660,780 780,900 900,1140
system call is our way

1470
00:45:19,200 --> 00:45:21,270
0,300 300,810 840,1350 1350,1920 1920,2070
out,| basically wait calls look
|wait 系统调用查看有没有子进程，

1471
00:45:21,270 --> 00:45:22,410
0,180 180,330 330,540 540,990 990,1140
if there's any children| that
|决定是不是可以清理。

1472
00:45:22,410 --> 00:45:23,940
0,630 630,720 720,1260 1260,1350 1350,1530
are are not you know

1473
00:45:24,000 --> 00:45:25,020
0,210 210,330 330,420 420,690 690,1020
that can be cleaned up.|
|

1474
00:45:25,350 --> 00:45:26,190
0,180 180,300 300,390 390,660 660,840
And then they cleans them
然后把它们清理掉。

1475
00:45:26,190 --> 00:45:26,700
0,330
up.|
|

1476
00:45:27,190 --> 00:45:29,080
0,720 930,1200 1200,1410 1410,1770 1770,1890
{} And that means that
也就是说，

1477
00:45:29,080 --> 00:45:32,080
0,750 870,1440 1440,1950 1950,2400 2580,3000
basically,| {} when the parent
|当父进程切换进程时，

1478
00:45:32,080 --> 00:45:33,400
0,540 540,750 750,960 960,1260 1260,1320
process switch over process,| we're
|我们必须保证，

1479
00:45:33,400 --> 00:45:34,510
0,120 120,180 180,390 390,780 780,1110
going to make absolutely sure

1480
00:45:34,510 --> 00:45:36,460
0,180 180,300 300,390 390,690 1050,1950
that you know that {},|
|

1481
00:45:36,860 --> 00:45:38,030
0,150 150,390 390,870 870,1080 1080,1170
the {pagetable -} that is
satp 寄存器中加载的页表，

1482
00:45:38,030 --> 00:45:39,830
0,300 300,390 390,480 480,1230 1230,1800
loaded in the satp register,|
|

1483
00:45:40,040 --> 00:45:41,240
0,270 270,510 510,990 990,1080 1080,1200
{} is not you know
不是，

1484
00:45:41,240 --> 00:45:42,890
0,330 330,450 450,1110 1290,1470 1470,1650
one of the,| is not
|不是那个将要释放的进程页表。

1485
00:45:42,890 --> 00:45:43,480
0,300
that

1486
00:45:43,510 --> 00:45:45,280
0,600 600,720 720,1170 1170,1350 1350,1770
process {you,know} pagetable will actually

1487
00:45:45,280 --> 00:45:46,340
0,90 90,420 420,810
currently free {}.|
|

1488
00:45:47,030 --> 00:45:47,690
0,300 300,390 390,510 510,600 600,660
{You,know} it could be the
也可能根本没有进程在运行，

1489
00:45:47,690 --> 00:45:48,920
0,240 240,480 480,690 690,1050 1050,1230
case there's no process running

1490
00:45:48,920 --> 00:45:50,480
0,120 120,420 450,780 1230,1440 1440,1560
at all right| and so
|所以调度器有它自己的页表，

1491
00:45:50,480 --> 00:45:51,560
0,90 90,510 510,840 840,990 990,1080
the scheduler basically has its

1492
00:45:51,560 --> 00:45:53,300
0,210 210,450 450,960 1230,1530 1530,1740
own {pagetable -},| {} sort
|所以，所有进程都可以被清理。

1493
00:45:53,300 --> 00:45:54,650
0,270 270,540 540,960 960,1110 1110,1350
of all processes can actually

1494
00:45:54,650 --> 00:45:55,500
0,90 90,360 360,600
be cleaned up.|
|

1495
00:45:59,410 --> 00:46:00,320
0,180 180,330 330,660
That makes sense?|
能理解吗？|

1496
00:46:05,860 --> 00:46:06,700
0,180 180,510 510,600 600,780 780,840
I'm sorry, I had a
抱歉，我有个问题，

1497
00:46:06,700 --> 00:46:09,430
0,750 780,1500 1530,1770 1770,2070 2400,2730
question,| {} is it that
|你是不是把 CLINT 映射到

1498
00:46:09,430 --> 00:46:11,680
0,480 510,1200 1200,1470 1470,1830 1830,2250
you're mapping the C L

1499
00:46:11,680 --> 00:46:12,700
0,150 150,270 270,810
I N T|
|

1500
00:46:12,970 --> 00:46:15,340
0,390 390,720 810,1290 1290,2040 2040,2370
into the new process kernel
新的进程内核页表中了？

1501
00:46:15,340 --> 00:46:17,100
0,270 270,930
{pagetables -}?|
|

1502
00:46:18,030 --> 00:46:20,910
0,720 810,1590 2070,2550 2550,2730 2730,2880
Why?| {} Because I think
为什么？|因为任务说的我只需要，

1503
00:46:20,910 --> 00:46:21,870
0,60 60,450 450,690 690,900 900,960
the assignment says like I

1504
00:46:21,870 --> 00:46:23,900
0,300 300,510 510,930 930,1740
only have to {},|
|

1505
00:46:24,000 --> 00:46:25,350
0,510 510,810 810,900 900,1110 1110,1350
user process, you will not
用户进程不会比 CLINT 更大，好像是的。

1506
00:46:25,350 --> 00:46:28,080
0,90 90,510 510,1320 1860,2280 2280,2730
be bigger than {} CLINT

1507
00:46:28,200 --> 00:46:28,980
0,120 120,300 300,510
is that it.|
|

1508
00:46:29,460 --> 00:46:30,990
0,150 150,930 930,1260 1260,1470 1470,1530
When I map both the
当我映射 PLIC 和 CLINT 时，

1509
00:46:30,990 --> 00:46:32,160
0,330 330,420 420,480 480,900
PLIC and the CLINT,

1510
00:46:32,750 --> 00:46:33,980
0,360 360,570 570,990 990,1170 1170,1230
right,| and so but I
|我认为任务告诉我们，

1511
00:46:33,980 --> 00:46:35,090
0,180 180,270 270,660 660,930 930,1110
think the assignment told us

1512
00:46:35,090 --> 00:46:36,620
0,450 930,1080 1080,1290 1290,1410 1410,1530
that,| so what is the
|什么是最低的那个。

1513
00:46:36,620 --> 00:46:38,210
0,360 360,810 840,930 930,1170 1170,1590
lowest one.| I think there
|我想 PLIC 是最低的那个，

1514
00:46:40,170 --> 00:46:41,700
0,300 300,450 450,750 780,1080 1080,1530
PLIC is the lowest one,|

1515
00:46:41,700 --> 00:46:42,840
0,90 90,420 420,720 720,1020 1020,1140
and this [] told us,|
这告诉我们，|

1516
00:46:42,840 --> 00:46:43,890
0,210 210,300 300,570 570,900 900,1050
that the user process will
用户进程不会大于 PLIC 地址。

1517
00:46:43,890 --> 00:46:44,880
0,210 210,300 300,660 660,900 900,990
not be bigger than the

1518
00:46:44,880 --> 00:46:45,480
0,360
PLIC

1519
00:46:47,110 --> 00:46:48,380
0,480 480,1080
address.| Okay.|
|好的。|

1520
00:46:49,340 --> 00:46:50,160
0,570

1521
00:46:50,940 --> 00:46:51,900
0,300 300,360 360,510 510,600 600,960
Just to make it easy,|
只是为了简单，|

1522
00:46:51,960 --> 00:46:53,790
0,300 300,540 540,840 840,840 1530,1830
we could then {},| want
我们可以，|想让它对你来说尽可能简单，

1523
00:46:53,790 --> 00:46:54,390
0,60 60,240 240,300 300,450 450,600
to make it as easy

1524
00:46:54,390 --> 00:46:55,530
0,90 90,480 480,600 600,840 840,1140
as possible for you| clear
|当然，你愿意的话，可以做得更好。

1525
00:46:55,530 --> 00:46:56,730
0,150 150,270 270,360 360,600 600,1200
you could have done a

1526
00:46:56,760 --> 00:46:57,810
0,240 240,330 330,450 450,690 690,1050
better if you wanted to.|
|

1527
00:46:58,110 --> 00:46:59,020
0,690

1528
00:46:59,260 --> 00:47:01,270
0,1050 1080,1380 1440,1590 1590,1680 1680,2010
{} But you know that
但是，你知道这是最简单的事情。

1529
00:47:01,270 --> 00:47:02,200
0,150 150,330 330,720 720,870 870,930
was the simplest thing to

1530
00:47:02,200 --> 00:47:02,720
0,270
do.|
|

1531
00:47:03,500 --> 00:47:04,190
0,150 150,300 300,420 420,510 510,690
So you have to make
所以，你需要做一些修改才能让它正常工作。

1532
00:47:04,190 --> 00:47:05,330
0,300 300,840 840,930 930,1050 1050,1140
{a,few} modifications to get it

1533
00:47:05,330 --> 00:47:05,980
0,90 90,420
to work.|
|

1534
00:47:11,640 --> 00:47:12,840
0,180 180,360 360,1020
Any further questions?|
还有什么问题吗？|

1535
00:47:13,700 --> 00:47:14,660
0,270 270,360 360,480 480,540 540,960
{} I have a question,|
我有一个问题，|

1536
00:47:15,740 --> 00:47:17,480
0,180 180,300 300,1170 1320,1560 1560,1740
is it possible that you
能不能复制 0 到 512 ，

1537
00:47:17,480 --> 00:47:20,060
0,570 600,1560 1590,2130 2130,2280 2280,2580
can copy zero to five

1538
00:47:20,060 --> 00:47:21,620
0,510 540,660 660,960 960,1230 1230,1560
twelve| and then every time
|然后每次切换时，

1539
00:47:21,620 --> 00:47:22,910
0,150 150,570 570,750 750,990 990,1290
you switch,| so you're still
|仍在使用，比如全局根页表，

1540
00:47:22,910 --> 00:47:24,950
0,390 390,630 630,780 780,1410 1650,2040
using like the global root

1541
00:47:24,950 --> 00:47:26,210
0,240 240,630 660,930 930,1080 1080,1260
{pagetable -}| except you only
|除了复制第一个根页表，

1542
00:47:26,210 --> 00:47:28,400
0,360 360,990 1140,1740 1740,1950 1950,2190
copy the first root page

1543
00:47:28,400 --> 00:47:30,650
0,420 1080,1560 1590,1860 1860,2130 2130,2250
table,| and every time you
|每次切换进程时，

1544
00:47:30,650 --> 00:47:32,450
0,390 390,510 510,1170 1170,1320 1320,1800
switch a process,| you copy
|都复制用户地址到。

1545
00:47:32,450 --> 00:47:35,540
0,510 510,1230 1260,2040 2070,2700 2700,3090
over the user's addresses over

1546
00:47:35,570 --> 00:47:37,820
0,390 720,1410 1410,1620 1620,1800 1800,2250
to.| Yeah.| Is that possible
|是的。|能不能这么做。

1547
00:47:37,820 --> 00:47:38,540
0,90 90,450
to do.|
|

1548
00:47:39,040 --> 00:47:39,880
0,120 120,480 480,570 570,750 750,840
In principle I think you
理论上，我认为你可以这样做，

1549
00:47:39,880 --> 00:47:40,720
0,120 120,210 210,480 480,630 630,840
could do something like that,|
|

1550
00:47:40,720 --> 00:47:42,430
0,120 120,510 510,660 660,1290 1350,1710
so instead of basically doing
所以，不是分配一个进程，再释放它，

1551
00:47:42,430 --> 00:47:43,540
0,210 210,330 330,690 690,750 750,1110
when you allocate a process

1552
00:47:43,540 --> 00:47:44,590
0,120 120,510 510,630 630,780 780,1050
and {free,it},| you could do
|你可以在调度程序切换期间动态执行。

1553
00:47:44,590 --> 00:47:46,570
0,240 240,1170 1200,1560 1560,1680 1680,1980
to dynamically during this scheduler

1554
00:47:46,570 --> 00:47:47,240
0,540
switch.|
|

1555
00:47:47,920 --> 00:47:52,450
0,750 1170,1800 1920,2550 2610,3540 3570,4530
Um, {} seems complicated {}.|
嗯，看起来很复杂。|

1556
00:47:53,270 --> 00:47:54,590
0,690 720,930 930,1080 1080,1170 1170,1320
{} That might be more
那可能花费更多，

1557
00:47:54,590 --> 00:47:55,910
0,510 510,750 750,900 900,1140 1140,1320
costly,| because that means that
|因为，这意味着每次在两个进程之间切换时，

1558
00:47:55,910 --> 00:47:57,040
0,270 270,900
every time

1559
00:47:57,140 --> 00:47:58,910
0,300 300,630 630,960 960,1080 1080,1770
you switch between two processes,|
|

1560
00:47:58,910 --> 00:47:59,810
0,210 210,450 450,630 630,720 720,900
you may have to make
你可能必须复制内核页表的一部分。

1561
00:47:59,810 --> 00:48:00,680
0,60 60,360 360,450 450,690 690,870
a copy of parts of

1562
00:48:00,710 --> 00:48:02,480
0,600 600,840 840,1080 1080,1530
the kernel {pagetable -}.|
|

1563
00:48:02,870 --> 00:48:04,460
0,840 840,1080 1080,1230 1230,1410 1410,1590
{} And so that might
所以这可能对性能有影响，

1564
00:48:04,460 --> 00:48:06,170
0,420 450,1020 1050,1260 1260,1350 1350,1710
be {} [] to perform,|
|

1565
00:48:06,170 --> 00:48:07,250
0,90 90,270 270,360 360,750 750,1080
it's not an ideal thing.|
不是一件理想的事情。|

1566
00:48:07,640 --> 00:48:09,020
0,330 330,480 480,930 930,1170 1170,1380
{} The assignment didn't really
任务没有说任何关于它的事，

1567
00:48:09,020 --> 00:48:11,150
0,240 240,510 510,780 780,1020 1440,2130
say anything about it {},|
|

1568
00:48:11,180 --> 00:48:12,350
0,210 210,450 450,570 570,900 900,1170
you might have timed out
如果你这样做了，它可能在 usertests 中超时。

1569
00:48:12,350 --> 00:48:13,550
0,180 180,420 420,900 930,1080 1080,1200
in {usertests -}, if you

1570
00:48:13,550 --> 00:48:14,320
0,150 150,540
did that.|
|

1571
00:48:18,070 --> 00:48:19,240
0,360 360,510 510,660 660,840 840,1170
Yeah I was just wondering,|
是的，我只是想知道，|

1572
00:48:19,240 --> 00:48:20,350
0,180 180,270 270,570 570,750 750,1110
because I tried that approach,|
因为我试过那个方法，|

1573
00:48:20,350 --> 00:48:21,820
0,270 270,360 360,900 1020,1200 1200,1470
and it was a bad
这是一次糟糕的经历，

1574
00:48:21,820 --> 00:48:23,260
0,630 660,750 750,990 990,1290 1290,1440
experience,| I was wondering if
|我想知道这是否可行。

1575
00:48:23,260 --> 00:48:24,160
0,90 90,240 240,630 630,780 780,900
that was possible.| I can
|我可以想象的到，但是我认为理论上是可行的，

1576
00:48:24,160 --> 00:48:26,350
0,450 450,1170 1230,1710 1710,1890 1890,2190
imagine, but I I think

1577
00:48:26,350 --> 00:48:27,670
0,120 120,210 210,540 540,1170 1170,1320
it's in principle possible,| you
|你可以每次分配新的页表并切换，

1578
00:48:27,670 --> 00:48:28,780
0,300 300,630 630,690 690,870 870,1110
could allocate a new page

1579
00:48:28,780 --> 00:48:30,460
0,240 240,570 570,660 660,1410 1410,1680
table correctly and switch every

1580
00:48:30,460 --> 00:48:31,140
0,390
time,|
|

1581
00:48:31,980 --> 00:48:33,060
0,180 180,600 600,750 750,840 840,1080
and {free,it} when you switch
并在切换出来的时候释放它。

1582
00:48:33,060 --> 00:48:33,640
0,330
out.|
|

1583
00:48:38,820 --> 00:48:39,720
0,90 90,300 300,420 420,570 570,900
I don't think it's simple,|
我不认为这很简单，|

1584
00:48:39,720 --> 00:48:41,130
0,300 300,390 390,780 780,1320 1320,1410
but you know {in,principle} it's
但是，你知道，我认为理论上是可行的。

1585
00:48:41,130 --> 00:48:42,100
0,360 360,450 450,720
possible I think.|
|

1586
00:48:43,410 --> 00:48:44,790
0,480 480,600 600,750 750,1290 1290,1380
Perhaps some other modifications to
可能对 xv6 做一些其他修改。

1587
00:48:44,790 --> 00:48:45,960
0,240 240,600 600,780 810,930 930,1170
{xv6 - - - -}.|
|

1588
00:48:48,760 --> 00:48:49,880
0,180 180,330 330,870
Any other questions?|
还有其他问题吗？|

1589
00:48:56,660 --> 00:48:57,770
0,150 150,300 300,540 540,810 810,1110
{Of,course} the {} other change
当然另一个改变是，

1590
00:48:57,770 --> 00:48:58,370
0,150 150,210 210,390 390,510 510,600
that,| of course have to
|必须要改的是 usertrapret ，

1591
00:48:58,370 --> 00:48:59,330
0,210 210,300 300,600 600,660 660,960
make is {usertrapret - -

1592
00:48:59,330 --> 00:49:00,470
0,390 480,750 750,930 930,990 990,1140
-},| you got to make
|你必须确保，

1593
00:49:00,470 --> 00:49:02,300
0,240 240,420 420,960 960,1230 1230,1830
sure that| actually you run
|你使用进程内核页表运行。

1594
00:49:02,300 --> 00:49:03,260
0,300 300,720
with the

1595
00:49:03,540 --> 00:49:04,950
0,210 210,420 420,930 930,1200 1200,1410
{} the processes kernel page
{}进程内核页表。

1596
00:49:04,950 --> 00:49:05,560
0,360
table.|
|

1597
00:49:07,390 --> 00:49:08,200
0,570
Okay?|
好的？|

1598
00:49:09,390 --> 00:49:10,440
0,210 210,330 330,480 480,810 810,1050
Okay, so let's switch them
好的，那我们切换到，

1599
00:49:10,440 --> 00:49:12,030
0,540 540,600 600,600 1200,1290 1290,1590
to,| {} I guess part
|第三部分。

1600
00:49:12,030 --> 00:49:12,740
0,480
three.|
|

1601
00:49:13,290 --> 00:49:14,400
0,870

1602
00:49:15,420 --> 00:49:17,550
0,600 750,1080 1080,1410 1410,1590 1590,2130
To switch back to actually
切换回这里。

1603
00:49:19,850 --> 00:49:22,060
0,690 1050,1950
here {}.|
|

1604
00:49:24,470 --> 00:49:26,750
0,330 330,870 870,1470 1500,1890 1890,2280
Okay, so,| {} actually that's
好的，那么，|这可能不是一张有帮助的图片。

1605
00:49:26,750 --> 00:49:28,160
0,270 270,450 450,510 510,810 810,1410
maybe not a helpful picture.|
|

1606
00:49:30,620 --> 00:49:34,500
0,750 750,990
Okay, {part,three}.|
好的，第三部分。|

1607
00:49:36,820 --> 00:49:39,130
0,930 960,1680 1680,1890 1890,2010 2010,2310
So basically what our plan
所以基本上我们的计划是，

1608
00:49:39,130 --> 00:49:40,690
0,330 330,900 900,1140 1140,1290 1290,1560
is,| we have our kernel
|我们有像之前一样的内核页表，

1609
00:49:40,690 --> 00:49:41,760
0,270 270,810
{pagetable -}

1610
00:49:42,410 --> 00:49:45,110
0,210 210,840 1380,2370 2430,2580 2580,2700
as before,| and you know
|我们有 PLIC 条目在某个地方。

1611
00:49:45,110 --> 00:49:46,490
0,180 180,510 510,780 810,1050 1050,1380
we have the PLIC entry

1612
00:49:46,490 --> 00:49:47,740
0,360 360,990
sitting somewhere.|
|

1613
00:49:48,420 --> 00:49:49,500
0,330 330,510 510,600 600,750 750,1080
And what we're gonna do
我们要做的是，

1614
00:49:49,500 --> 00:49:51,630
0,330 330,630 630,1110 1410,2040 2040,2130
is,| we're gonna use {you,know}
|我们将使用 PLIC 下面的所有东西，

1615
00:49:51,630 --> 00:49:53,600
0,720 720,1260 1290,1770
everything below PLIC,|
|

1616
00:49:53,690 --> 00:49:55,160
0,150 150,390 390,720 720,810 810,1470
to actually store the user
来保存用户页表，

1617
00:49:57,720 --> 00:49:58,860
0,270 270,600 660,930 930,1080 1080,1140
{pagetable -},| we're going to
|我们将把用户页表映射到所有的用户程序中，

1618
00:49:58,860 --> 00:50:00,150
0,360 360,420 420,660 660,900 900,1290
map the user {pagetable -}

1619
00:50:00,150 --> 00:50:01,740
0,570 570,750 750,840 840,1110 1110,1590
into all the user program,|
|

1620
00:50:01,740 --> 00:50:02,970
0,90 90,360 360,750 750,1050 1050,1230
the user program actually in
用户程序实际上在内核页表中，

1621
00:50:02,970 --> 00:50:04,240
0,120 120,420 420,690 690,1020
the kernel {pagetable -},|
|

1622
00:50:05,180 --> 00:50:06,120
0,210 210,270 270,690
in the bottom.|
在底部。|

1623
00:50:09,240 --> 00:50:10,560
0,330 330,480 480,660 660,750 750,1320
{} And that's the goal,|
这就是我们的目标，|

1624
00:50:10,590 --> 00:50:12,060
0,480 480,780 780,870 870,1200 1200,1470
and what's the first question
第一个要问的问题是，

1625
00:50:12,060 --> 00:50:13,680
0,60 60,540 540,690 690,1260 1440,1620
to ask,| you know why
|为什么[]要这么做。

1626
00:50:13,680 --> 00:50:15,360
0,120 120,300 300,420 420,720 960,1680
the [] do that {}.|
|

1627
00:50:16,180 --> 00:50:17,260
0,120 120,300 300,720 720,840 840,1080
Is there any you know
这样有什么好处吗，

1628
00:50:17,260 --> 00:50:18,820
0,240 240,630 630,780 780,1080 1080,1560
any advantage of it| and
|我觉得可能，

1629
00:50:19,150 --> 00:50:20,170
0,540 540,690 690,780 780,810 810,1020
{} you know I think

1630
00:50:20,170 --> 00:50:21,250
0,240 240,330 330,660 690,960 960,1080
maybe the {},| it may
|这可能是一种简单的方式

1631
00:50:21,250 --> 00:50:23,200
0,210 210,660 720,990 990,1260 1260,1950
be a easy way| to
|来理解为什么它很有趣，

1632
00:50:24,050 --> 00:50:25,310
0,390 390,720 720,930 930,1140 1140,1260
see why it might be

1633
00:50:25,310 --> 00:50:27,200
0,660 840,1050 1050,1140 1140,1530 1530,1890
interesting| is to [] compare
|是[]与 copyin 比较。

1634
00:50:27,200 --> 00:50:28,380
0,60 60,540 540,1020
to {copyin -}.|
|

1635
00:50:28,930 --> 00:50:30,160
0,390 390,540 540,720 720,1170 1170,1230
{} The new copy [of]
旧副本的新副本。

1636
00:50:30,160 --> 00:50:31,260
0,90 90,300 300,840
the old copy.|
|

1637
00:50:32,790 --> 00:50:34,200
0,510 540,1110
So, {}
所以，如果， copyin 发生了什么，

1638
00:50:34,780 --> 00:50:36,520
0,660 960,1080 1080,1200 1200,1440 1440,1740
if you know what happens

1639
00:50:36,520 --> 00:50:37,750
0,240 240,360 360,750 750,900 900,1230
in the copyin,| it correctly,
|copyin 将数据从用户空间复制到内核地址空间。

1640
00:50:37,750 --> 00:50:40,360
0,720 780,1590 1740,2340 2340,2550 2550,2610
copyin copies data from the

1641
00:50:40,360 --> 00:50:41,950
0,330 330,780 780,1110 1110,1200 1200,1590
user space into the kernel

1642
00:50:41,950 --> 00:50:42,880
0,270 270,810
address space.|
|

1643
00:50:43,590 --> 00:50:47,220
0,690 1140,1980 2070,2700 2820,3390 3480,3630
Um, and {} but you
但是如果内核没有用户地址映射。

1644
00:50:47,220 --> 00:50:48,720
0,450 660,840 840,930 930,1260 1260,1500
know if the kernel has

1645
00:50:48,720 --> 00:50:50,130
0,240 240,570 570,990 990,1110 1110,1410
does not have the user

1646
00:50:50,130 --> 00:50:51,460
0,570 570,1110
address map,|
|

1647
00:50:51,760 --> 00:50:53,680
0,660 750,1320 1320,1440 1440,1740 1740,1920
{} basically the kernel has
内核必须在这时分配这个页，

1648
00:50:53,680 --> 00:50:55,600
0,90 90,330 330,720 720,1320 1560,1920
to do this {} page

1649
00:50:55,600 --> 00:50:56,440
0,90 90,150 150,570
{} the time,

1650
00:50:57,080 --> 00:50:58,340
0,390 390,630 630,720 720,1140 1140,1260
correct,| because the pages in
|因为虚拟地址空间中的页面可以是连续的，

1651
00:50:58,340 --> 00:50:59,780
0,330 330,900 900,1170 1170,1320 1320,1440
virtual address space may be

1652
00:50:59,780 --> 00:51:01,190
0,570 570,720 720,810 810,1140 1140,1410
continuous| with the physical address
|尽管对于物理地址空间，它们不是连续的。

1653
00:51:01,190 --> 00:51:02,660
0,240 240,420 420,630 630,1260
space, they're not continuous.|
|

1654
00:51:02,990 --> 00:51:03,890
0,180 180,420 420,510 510,600 600,900
And basically with the kernel
内核在 copyin 上所做的，

1655
00:51:03,890 --> 00:51:06,410
0,330 330,1020 1020,1140 1140,1680 1800,2520
{does,in} copyin,| it basically translates
|将虚拟用户地址转换为物理地址。

1656
00:51:06,410 --> 00:51:08,160
0,120 120,660 660,930 930,1560
the virtual user address

1657
00:51:08,370 --> 00:51:10,740
0,840 840,1230 1230,1620 1620,2220
into {} physical address.|
|

1658
00:51:11,490 --> 00:51:12,750
0,300 300,390 390,750 750,1050 1050,1260
Since the kernel has all
由于内核具有所有物理内存映射，

1659
00:51:12,750 --> 00:51:15,510
0,480 480,1470 1470,2100 2100,2310 2310,2760
physical memory mapped with identity

1660
00:51:15,510 --> 00:51:17,280
0,600 810,1080 1080,1410 1410,1650 1650,1770
mapping,| the physical address [is
|物理地址[也是]有效的内核虚拟地址，

1661
00:51:17,280 --> 00:51:20,130
0,510 510,600 600,1200 1290,2010 2040,2850
also] a valid kernel {}

1662
00:51:20,160 --> 00:51:21,660
0,420 420,870 1110,1290 1290,1440 1440,1500
virtual address| and then it
|然后它移动那一页的部分，

1663
00:51:21,660 --> 00:51:22,920
0,420 420,1110
basically moves

1664
00:51:23,030 --> 00:51:24,260
0,420 420,630 630,690 690,870 870,1230
whatever part of that page,|
|

1665
00:51:24,260 --> 00:51:25,280
0,330 330,600 600,840 840,900 900,1020
physical page needs to be
那些需要复制的物理页。

1666
00:51:25,280 --> 00:51:26,690
0,420 420,600 600,870 870,1230 1230,1410
copied that actually copies it.|
|

1667
00:51:27,960 --> 00:51:29,100
0,300 300,510 510,810 810,870 870,1140
And so if {} data
如果某个数据结构，

1668
00:51:29,100 --> 00:51:30,900
0,360 360,420 420,960 960,1710 1710,1800
structure,| for example spans, you
|跨越两个个页面边界，

1669
00:51:30,900 --> 00:51:33,150
0,120 120,990 1140,1440 1440,1710 1710,2250
know, two {} page boundary,|
|

1670
00:51:33,150 --> 00:51:34,950
0,240 240,750 750,1050 1050,1380 1380,1800
like {for,example}, the sysinfo struct
比如，在实验 2 中使用的 sysinfo 结构，

1671
00:51:35,040 --> 00:51:36,000
0,120 120,300 300,570 570,840 840,960
may be used in {}

1672
00:51:36,000 --> 00:51:37,720
0,270 270,390 390,750 750,1470
lab two,| maybe spans
|可能跨越页表边界，

1673
00:51:37,770 --> 00:51:39,450
0,150 150,420 420,720 720,1290 1530,1680
a {pagetable -} boundary,| it
|它会复制，比如可能是，

1674
00:51:39,450 --> 00:51:40,920
0,180 180,660 660,810 810,1350 1350,1470
will copy like maybe you

1675
00:51:40,920 --> 00:51:42,270
0,90 90,390 390,720 720,1050 1050,1350
know| some bytes from the
|第一个物理页的一些字节，

1676
00:51:42,300 --> 00:51:43,950
0,450 450,750 750,1230 1320,1530 1530,1650
first physical page| and then
|然后是第二物理页的一些字节。

1677
00:51:43,950 --> 00:51:45,510
0,210 210,510 510,660 660,1290 1290,1560
some bytes from the second

1678
00:51:45,510 --> 00:51:46,420
0,300 300,780
physical page.|
|

1679
00:51:48,160 --> 00:51:49,040
0,120 120,180 180,300 300,660
Does it make sense.|
这个能理解吗。|

1680
00:51:52,180 --> 00:51:53,500
0,330 330,510 510,600 600,870 870,1320
That's what the kernel copyin
这就是内核 copyin 所做的，

1681
00:51:53,500 --> 00:51:54,730
0,450 510,660 660,720 720,1080 1080,1230
does,| and the goal was
|目标是让它们使用新的 copyin ，

1682
00:51:54,730 --> 00:51:55,630
0,390 390,450 450,600 600,720 720,900
basically to get them into

1683
00:51:55,630 --> 00:51:57,000
0,60 60,300 300,960
a new copyin,|
|

1684
00:51:57,850 --> 00:51:58,960
0,270 270,330 330,600 600,930 930,1110
where the kernel program didn't
使内核程序不必担心物理布局，

1685
00:51:58,960 --> 00:52:00,460
0,210 210,510 510,630 630,960 960,1500
really have to worry about

1686
00:52:03,330 --> 00:52:05,700
0,330 330,720 720,1320 1320,1800 1800,2370
the physical layout,| basically [off]
|不占用用户地址空间。

1687
00:52:05,730 --> 00:52:07,160
0,120 120,420 420,750 750,1260
the user address space.|
|

1688
00:52:07,430 --> 00:52:09,350
0,330 330,630 630,870 870,1200 1200,1920
{} And this new copyin,|
这个新 copyin ，|

1689
00:52:09,350 --> 00:52:09,980
0,120 120,210 210,300 300,510 510,630
you know we see we
我们可以看到基本上什么都不做，

1690
00:52:09,980 --> 00:52:11,540
0,360 360,510 510,870 870,1290 1290,1560
basically do nothing,| literally nothing
|没有其他东西，只是复制，

1691
00:52:11,540 --> 00:52:13,300
0,360 360,750 780,1500
else, just copy,|
|

1692
00:52:13,360 --> 00:52:15,400
0,690 1020,1260 1260,1590 1620,1800 1800,2040
{} do, you know, from
从用户地址直接到内核。

1693
00:52:15,400 --> 00:52:17,020
0,60 60,390 390,900 900,1440 1440,1620
the user addresses straight into

1694
00:52:17,020 --> 00:52:17,860
0,90 90,600
the kernel.|
|

1695
00:52:18,020 --> 00:52:19,250
0,480 480,750 750,840 840,990 990,1230
{} And we don't really
而且我们也不再需要调用 walk 了，

1696
00:52:19,250 --> 00:52:20,720
0,210 210,300 300,450 450,840 840,1470
have to call walk anymore,|
|

1697
00:52:20,930 --> 00:52:22,430
0,480 480,600 600,780 780,1230 1230,1500
because we can rely on
因为我们可以依赖，

1698
00:52:22,430 --> 00:52:23,180
0,300 300,390 390,570 570,660 660,750
the,| we {set,up} that the
|我们正确设置页表，

1699
00:52:23,180 --> 00:52:24,620
0,240 240,570 570,990 990,1260 1260,1440
{pagetables -} correctly,| now the
|现在，页表硬件将为我们做 walk 。

1700
00:52:24,620 --> 00:52:25,670
0,210 210,420 420,840 840,930 930,1050
{pagetable -} hardware will do

1701
00:52:25,670 --> 00:52:26,820
0,120 120,390 390,690 690,1020
the walk for us.|
|

1702
00:52:27,330 --> 00:52:27,880
0,360
Right.|
是的。|

1703
00:52:28,710 --> 00:52:29,670
0,210 210,300 300,450 450,570 570,960
And so that was the
这就是我们的目标，

1704
00:52:29,700 --> 00:52:32,940
0,750 1260,2010 2460,2910 2910,3150 3150,3240
goal,| {} {} and so
|所以这让内核程序员的生活更轻松一点，

1705
00:52:32,940 --> 00:52:33,780
0,120 120,300 300,540 540,600 600,840
that makes life of kernel

1706
00:52:33,780 --> 00:52:34,560
0,450 450,480 480,510 510,660 660,780
programmers are a little bit

1707
00:52:34,560 --> 00:52:36,660
0,630 660,930 930,1170 1170,1380 1380,2100
easier,| on any other advantages
|这种方法还有没有别的优点。

1708
00:52:36,900 --> 00:52:37,900
0,60 60,210 210,840
to this approach.|
|

1709
00:52:45,120 --> 00:52:46,170
0,150 150,330 330,630 630,900 900,1050
Is it also more {performance
是不是性能也更好，

1710
00:52:46,170 --> 00:52:48,120
0,600 600,990 990,1320 1320,1740 1740,1950
-},| because the hardware is
|因为硬件来做 walk 而不是软件。

1711
00:52:48,120 --> 00:52:49,440
0,300 300,720 720,870 870,1230 1230,1320
gonna do the walking and

1712
00:52:49,440 --> 00:52:50,840
0,270 270,840
not software.|
|

1713
00:52:51,090 --> 00:52:52,740
0,390 390,750 750,870 870,1530 1530,1650
Yeah, one way to,| I
是啊，一个方法，|我认为肯定有性能的提高，

1714
00:52:52,740 --> 00:52:54,090
0,180 180,300 300,690 690,1260 1260,1350
think their performance implications for

1715
00:52:54,090 --> 00:52:55,680
0,510 690,1110 1110,1380 1380,1500 1500,1590
sure,| {} one way to
|考虑这个的一种方式是，

1716
00:52:55,680 --> 00:52:56,850
0,180 180,450 450,630 630,780 780,1170
think about this is that|
|

1717
00:52:57,210 --> 00:52:59,100
0,300 300,780 780,1320 1320,1680 1680,1890
in copyin correct, if the
在 copyin 中，如果内核数据结构

1718
00:52:59,130 --> 00:53:01,140
0,300 300,540 540,1200 1200,1440 1440,2010
kernel data structure| or data
|或者我们从用户空间复制到内核空间的数据比较大，

1719
00:53:01,170 --> 00:53:02,250
0,420 420,540 540,660 660,960 960,1080
data that we copied from

1720
00:53:02,250 --> 00:53:03,800
0,240 240,720 720,1290
user space to

1721
00:53:03,880 --> 00:53:06,340
0,540 570,810 810,1170 1170,1710 1920,2460
{} kernel spaces big {},|
|

1722
00:53:06,340 --> 00:53:07,420
0,390 390,570 570,660 660,810 810,1080
we have to do that
我们必须这样做，一次一页，

1723
00:53:07,420 --> 00:53:08,020
0,90 90,210 210,450 450,570 570,600
you know page at a

1724
00:53:08,020 --> 00:53:08,700
0,420
time,

1725
00:53:09,030 --> 00:53:10,140
0,240 240,390 390,630 630,930 930,1110
right,| in every page, we
|在每个页面中，我们都必须调用函数 walkaddr ，

1726
00:53:10,140 --> 00:53:11,250
0,120 120,210 210,450 450,660 660,1110
have to call this function

1727
00:53:11,250 --> 00:53:12,600
0,360 360,510 510,660 660,780 780,1350
{walkaddr - -},| and then
|然后是内部的 walk 。

1728
00:53:12,600 --> 00:53:13,940
0,180 180,300 300,630 630,1080
there's the internal walking.|
|

1729
00:53:14,250 --> 00:53:16,620
0,360 360,570 570,990 1140,1830 2130,2370
{} And so, {} this
所以，这可能是一个昂贵的花费。

1730
00:53:16,620 --> 00:53:17,460
0,180 180,390 390,480 480,540 540,840
might actually be a reasonable

1731
00:53:17,460 --> 00:53:19,000
0,660 690,1350
expenses expensive.|
|

1732
00:53:19,650 --> 00:53:21,390
0,210 210,1020 1050,1170 1170,1290 1290,1740
What examples are there examples
有什么例子，

1733
00:53:21,390 --> 00:53:23,130
0,60 60,750 960,1110 1110,1410 1410,1740
of| where the kernel copies
|是内核从用户空间复制大量数据。

1734
00:53:23,130 --> 00:53:24,540
0,60 60,330 330,420 420,870 900,1410
a lot of data from

1735
00:53:24,570 --> 00:53:25,960
0,480 480,720 720,1230
{} user space.|
|

1736
00:53:33,340 --> 00:53:35,260
0,270 270,570 570,990 990,1350 1350,1920
Which system call might copy
哪个系统调用可能会从用户空间复制大量数据。

1737
00:53:35,290 --> 00:53:36,040
0,30 30,270 270,360 360,630 630,750
a ton of data from

1738
00:53:36,040 --> 00:53:36,920
0,240 240,690
user space.|
|

1739
00:53:38,550 --> 00:53:40,860
0,630 1050,1320 1320,1710 1740,2100 2100,2310
Write?| Yeah write, write, you're
write?|是的， write ，你说得对，

1740
00:53:40,860 --> 00:53:41,520
0,210 210,330 330,420 420,570 570,660
right,| you can give an
|你可以给出任意大小的任意缓冲区。

1741
00:53:41,520 --> 00:53:43,580
0,630 630,1740
arbitrary {},

1742
00:53:43,750 --> 00:53:46,390
0,150 150,960 1140,1380 1380,1980 2340,2640
an arbitrary {} buffer of

1743
00:53:46,390 --> 00:53:47,660
0,450 450,1080
arbitrary size.|
|

1744
00:53:47,760 --> 00:53:48,990
0,660 660,780 780,870 870,960 960,1230
And you know the kernel
内核可能将其复制到，

1745
00:53:48,990 --> 00:53:50,010
0,240 240,480 480,630 630,720 720,1020
[] may have to copy

1746
00:53:50,010 --> 00:53:51,720
0,330 480,1230 1230,1350 1350,1620 1620,1710
this into,| for example, the
|文件系统或管道中。

1747
00:53:51,720 --> 00:53:52,600
0,240 240,660
file system

1748
00:53:53,100 --> 00:53:54,320
0,240 240,450 450,540 540,1020
or into a pipe.|
或者放进管子里。|

1749
00:53:54,810 --> 00:53:56,100
0,390 390,720 720,840 840,960 960,1290
{} And that could be
这是很昂贵的。

1750
00:53:56,130 --> 00:53:57,240
0,120 120,390 390,870
a reasonable expensive.|
|

1751
00:54:00,180 --> 00:54:01,170
0,150 150,300 300,660 660,900 900,990
You gotta think what is
你想想还有什么好处，

1752
00:54:01,170 --> 00:54:03,390
0,270 270,780 780,1440 1470,1560 1560,2220
another advantage,| if the user,|
|如果用户，|

1753
00:54:03,660 --> 00:54:05,580
0,270 270,960 960,1260 1290,1710 1710,1920
{} we didn't explore that
我们在任务中没有研究这个，

1754
00:54:05,580 --> 00:54:07,110
0,60 60,210 210,870 870,1260 1290,1530
in this assignment,| we should
|应该还有别的优点。

1755
00:54:07,110 --> 00:54:08,000
0,90 90,270 270,630
we could have

1756
00:54:08,170 --> 00:54:09,880
0,240 240,600 600,810 810,1560
{} one another advantage.|
|

1757
00:54:13,060 --> 00:54:14,620
0,300 390,540 540,780 780,1080 1080,1560
So if you think about,|
所以如果你想一想，|

1758
00:54:14,740 --> 00:54:15,730
0,150 150,270 270,480 480,780 810,990
some of these, {} this
这里的其中一些代码，

1759
00:54:15,730 --> 00:54:17,020
0,270 270,450 450,720 720,870 870,1290
code here correct,| when it
|当它把结构移出用户空间，

1760
00:54:17,020 --> 00:54:18,040
0,240 240,300 300,780 780,930 930,1020
takes a structure out of

1761
00:54:18,040 --> 00:54:19,080
0,240 240,810
user space,|
|

1762
00:54:19,160 --> 00:54:20,420
0,150 150,450 450,540 540,690 690,1260
it copies the whole structure
它将整个结构复制到内核空间。

1763
00:54:20,870 --> 00:54:22,160
0,330 330,600 600,1140
into kernel space.|
|

1764
00:54:22,880 --> 00:54:24,530
0,570 600,930 930,1200 1200,1290 1290,1650
If user space is mapped
如果用户空间被映射到内核页表，

1765
00:54:24,530 --> 00:54:25,610
0,240 240,330 330,570 570,780 780,1080
into the kernel {pagetable -},|
|

1766
00:54:25,610 --> 00:54:26,180
0,90 90,240 240,360 360,450 450,570
do we have to do
我们也一定要这么做吗。

1767
00:54:26,180 --> 00:54:26,800
0,390
that.|
|

1768
00:54:31,630 --> 00:54:32,470
0,120 120,480 480,570 570,690 690,840
For example, if we have
比如，如果我们需要更新结构体中的一个字段。

1769
00:54:32,470 --> 00:54:33,490
0,120 120,390 390,630 630,930 930,1020
to update one field of

1770
00:54:33,490 --> 00:54:34,480
0,120 120,720
the structure.|
|

1771
00:54:46,830 --> 00:54:48,060
0,210 210,900
So if
如果数据结构只是映射到内核地址空间，

1772
00:54:48,440 --> 00:54:50,000
0,540 540,870 870,930 930,1170 1170,1560
data structure is just mapped

1773
00:54:50,000 --> 00:54:51,230
0,180 180,300 300,600 600,870 870,1230
into the kernel address space

1774
00:54:51,230 --> 00:54:52,790
0,210 210,660 690,870 870,990 990,1560
right,| then we can usually
|那么我们可以读写，

1775
00:54:52,880 --> 00:54:54,530
0,690 690,780 780,960 960,1290 1290,1650
{read,and,write},| you know with []
|通过特定的数据结构，

1776
00:54:54,530 --> 00:54:55,760
0,390 390,510 510,660 660,1020 1020,1230
structures through that particular data

1777
00:54:55,760 --> 00:54:56,990
0,420 420,570 570,690 690,870 870,1230
structure,| we can use update
|我们可以更新一个字段。

1778
00:54:56,990 --> 00:54:57,860
0,210 210,630
one field.|
|

1779
00:54:58,320 --> 00:54:59,670
0,570 570,630 630,870 870,1080 1080,1350
Unlike the kernel now does,|
与现在内核做的不同，|

1780
00:54:59,670 --> 00:55:01,920
0,510 510,660 660,1140 1140,1470 1740,2250
basically it copies the structure
它将结构体从内核空间复制到用户空间，

1781
00:55:01,920 --> 00:55:02,520
0,360
from

1782
00:55:02,850 --> 00:55:04,170
0,330 330,630 630,720 720,990 990,1320
kernel space to user space,|
|

1783
00:55:04,170 --> 00:55:05,460
0,120 120,210 210,630 630,930 930,1290
and then maybe back out
然后可能再使用 copyout 退出。

1784
00:55:05,460 --> 00:55:06,560
0,210 210,600 600,930
using {copyout -}.|
|

1785
00:55:07,110 --> 00:55:08,580
0,180 180,480 480,780 840,1380 1380,1470
And so we map the
因此，我们将用户空间映射到，

1786
00:55:08,580 --> 00:55:10,080
0,240 240,660 660,1200 1200,1290 1290,1500
user space into,| the user
|将用户程序映射到内核地址空间，

1787
00:55:10,080 --> 00:55:11,190
0,360 360,600 600,660 660,900 900,1110
program into the kernel address

1788
00:55:11,190 --> 00:55:12,630
0,420 450,600 600,720 720,900 900,1440
space,| we can just manipulate
|我们可以更自由地操纵它，

1789
00:55:12,630 --> 00:55:14,820
0,120 120,330 330,660 990,1620 1650,2190
it much more freely| than
|而不是我们现在的做法。

1790
00:55:14,880 --> 00:55:15,750
0,390 390,510 510,660 660,750 750,870
{} the way we do

1791
00:55:15,750 --> 00:55:16,380
0,120 120,420
it now.|
|

1792
00:55:18,620 --> 00:55:19,520
0,240 240,330 330,480 480,750 750,900
Does that make sense,| in
这能理解吗？|就动机而言，为什么许多内核都有这种特殊的结构，

1793
00:55:19,520 --> 00:55:21,680
0,210 210,270 270,990 1410,1890 1890,2160
terms of motivation, why many

1794
00:55:21,680 --> 00:55:23,540
0,360 360,1020 1020,1350 1350,1500 1500,1860
kernels actually have this particular

1795
00:55:23,540 --> 00:55:24,830
0,390 390,540 540,660 660,1050 1050,1290
structure| where they map {}
|映射底部是用户，

1796
00:55:27,170 --> 00:55:28,610
0,390 390,630 630,690 690,780 780,1440
bottom part of the user,|
|

1797
00:55:28,790 --> 00:55:30,530
0,720 720,840 840,1380 1380,1440 1440,1740
were to map the user
将用户程序映射到内核地址空间的底部。

1798
00:55:30,530 --> 00:55:31,550
0,360 360,540 540,600 600,840 840,1020
program into the bottom part

1799
00:55:31,550 --> 00:55:32,600
0,60 60,150 150,390 390,600 600,1050
of the kernel address space.|
|

1800
00:55:39,260 --> 00:55:40,040
0,570
Okay?|
好的？|

1801
00:55:41,880 --> 00:55:42,940
0,840

1802
00:55:44,750 --> 00:55:46,280
0,330 330,810 810,1230 1230,1350 1350,1530
Okay, so {} so let's
好的，让我们看我的代码，

1803
00:55:46,280 --> 00:55:47,630
0,480 480,540 540,1170 1170,1230 1230,1350
see, {} look at my

1804
00:55:47,630 --> 00:55:49,910
0,660 690,1350 1740,2010 2010,2160 2160,2280
code| and and so you
|好让你明白实际是什么。

1805
00:55:49,910 --> 00:55:52,040
0,570 570,870 870,1470 1470,1890
understand what actually {}.|
|

1806
00:55:52,980 --> 00:55:54,510
0,60 60,60 960,1200 1200,1410 1410,1530
{} I I guess so
我想有一个函数是关键，

1807
00:55:54,510 --> 00:55:56,340
0,180 180,570 570,1110 1170,1680 1680,1830
there's basically one function, that

1808
00:55:56,340 --> 00:55:58,440
0,120 120,180 180,750 930,990 990,2100
is the key,| you know
|假设我们正在建立有效的用户页表 ，

1809
00:55:58,470 --> 00:55:59,640
0,270 270,390 390,510 510,780 780,1170
assume we were building somewhere

1810
00:55:59,640 --> 00:56:00,420
0,510
valid

1811
00:56:00,570 --> 00:56:01,740
0,180 180,450 450,660 660,1050 1050,1170
{} user {pagetable -},| and
|然后我们需要将

1812
00:56:01,740 --> 00:56:02,400
0,120 120,210 210,360 360,570 570,660
then we just have to|
|

1813
00:56:02,400 --> 00:56:05,040
0,480 930,1710 1740,2250 2250,2520 2520,2640
map {} entries from the
条目从用户页表映射到内核页表，

1814
00:56:05,040 --> 00:56:06,480
0,270 270,510 510,990 1020,1350 1350,1440
user {pagetable -} into the

1815
00:56:06,480 --> 00:56:07,740
0,270 270,510 510,1020
kernel {pagetable -},|
|

1816
00:56:07,960 --> 00:56:10,330
0,780 780,1050 1050,1830 1860,2160 2160,2370
{} the processes kernel {pagetables
进程内核页表，

1817
00:56:10,330 --> 00:56:11,950
0,390 390,570 570,900 900,1350 1350,1620
-},| that function {kvmmapuser -
|函数 kvmmapuser 就是这样做的。

1818
00:56:11,950 --> 00:56:13,580
0,450 450,810 810,1020 1020,1440
-} exactly does this.|
|

1819
00:56:13,930 --> 00:56:16,090
0,630 870,1140 1140,1440 1440,1650 1650,2160
{} And it's pretty boring,|
这挺枯燥的，|

1820
00:56:16,090 --> 00:56:17,890
0,840 960,1170 1170,1380 1380,1560 1560,1800
{} {} the main couple
工作中主要的几个点是，

1821
00:56:17,890 --> 00:56:19,090
0,270 270,540 540,630 630,840 840,1200
interesting points to point out

1822
00:56:19,540 --> 00:56:21,640
0,300 300,480 480,900 900,1260 1440,2100
{} in work,| yeah yeah
|是的，那是与 uvmalloc 同样类型的接口，

1823
00:56:21,910 --> 00:56:23,050
0,300 300,390 390,750 750,960 960,1140
that's the same sort of

1824
00:56:23,050 --> 00:56:24,020
0,0

1825
00:56:24,500 --> 00:56:27,680
0,630 630,1410 1770,2460 2460,2790 2790,3180
interfaces to {} {uvmalloc -

1826
00:56:27,680 --> 00:56:29,600
0,150 150,870 930,1080 1080,1680 1680,1920
-} whatever| or basically if
|或者如果，

1827
00:56:29,840 --> 00:56:30,560
0,180 180,270 270,420 420,600 600,720
you know| you go from
|你从旧尺寸页面转到新尺寸页面。

1828
00:56:30,560 --> 00:56:31,550
0,90 90,300 300,750 750,900 900,990
the old size up to

1829
00:56:31,550 --> 00:56:32,720
0,120 120,300 300,810 810,1050 1050,1170
the new size page at

1830
00:56:32,720 --> 00:56:33,620
0,30 30,600
a time.|
|

1831
00:56:33,980 --> 00:56:34,860
0,630
Yeah.|
嗯。|

1832
00:56:35,190 --> 00:56:37,340
0,240 240,600 600,1230 1260,1890
You find the {}
你找到 upte ，

1833
00:56:38,250 --> 00:56:41,700
0,600 600,1020 1050,1260 1260,1740 2790,3450
{upte -},| {you,know} the pointer
|指向特定虚拟地址的 pte 的指针，

1834
00:56:41,940 --> 00:56:43,140
0,180 180,930
to the

1835
00:56:43,210 --> 00:56:45,400
0,870 900,1320 1320,1470 1470,1890 1890,2190
pte for that particular virtual

1836
00:56:45,400 --> 00:56:46,570
0,360 360,540 540,660 660,930 930,1170
address| in the user page
|在用户页表中。

1837
00:56:46,570 --> 00:56:47,340
0,510
table.|
|

1838
00:56:48,000 --> 00:56:49,170
0,240 240,390 390,810 810,1020 1020,1170
And so we look at
所以我们来看一下，

1839
00:56:49,170 --> 00:56:50,840
0,330 810,1440
the {},|
|

1840
00:56:51,200 --> 00:56:52,700
0,810 840,930 930,1110 1110,1200 1200,1500
if you look at the
如果你看这张图片，

1841
00:56:52,730 --> 00:56:53,930
0,420 420,720 750,960 960,1140 1140,1200
picture| that we had a
|我们有一段时间了，

1842
00:56:53,930 --> 00:56:55,130
0,180 180,390 390,750 750,990 990,1200
little while back,| {you,know} look
|看这张图片。

1843
00:56:55,130 --> 00:56:57,060
0,570 720,1170 1170,1710
at this picture.|
|

1844
00:56:57,410 --> 00:56:58,550
0,690 690,810 810,960 960,1020 1020,1140
Basically, what this is going
这将返回的是，

1845
00:56:58,550 --> 00:57:00,170
0,90 90,540 540,780 780,1200 1410,1620
to return correct is,| we're
|我们遍历用户页表，

1846
00:57:00,170 --> 00:57:00,920
0,120 120,180 180,450 450,540 540,750
going to walk the user

1847
00:57:00,920 --> 00:57:02,450
0,240 240,720 720,960 960,1110 1110,1530
{pagetable -}| and we'll find
|我们找到 upte ，

1848
00:57:02,450 --> 00:57:05,000
0,120 120,630 630,930 960,2160 2370,2550
for example the upte| that
|它映射到特定虚拟地址，

1849
00:57:05,000 --> 00:57:06,650
0,420 420,600 600,960 960,1350 1350,1650
maps in that particular virtual

1850
00:57:06,650 --> 00:57:08,480
0,360 360,540 540,870 900,1230 1230,1830
address| where we basically pointer
|那个地址指向页表中的那个条目。

1851
00:57:08,480 --> 00:57:09,620
0,120 120,420 420,840 840,1050 1050,1140
to that entry into the

1852
00:57:09,620 --> 00:57:10,460
0,390
pagetable,|
|

1853
00:57:11,220 --> 00:57:11,780
0,420

1854
00:57:14,740 --> 00:57:16,810
0,150 150,360 360,840 840,1320 1860,2070
and that's {what,walk} does.| And
这就是 walk 所做的。|如果这个东西映射了，它不是零，

1855
00:57:16,810 --> 00:57:18,970
0,360 360,1290 1320,1800 1800,2040 2040,2160
so if {} thing {is,mapped},

1856
00:57:18,970 --> 00:57:21,970
0,480 480,2040 2040,2190 2190,2520 2520,3000
{it's,not zero}| that must mean
|那一定意味着，至少答案是，

1857
00:57:21,970 --> 00:57:22,810
0,120 120,300 300,390 390,660 660,840
at least the answer is|
|

1858
00:57:22,810 --> 00:57:24,610
0,210 210,420 600,1110 1110,1650 1650,1800
just to check, {double,check} that
检查映射是否在那里。

1859
00:57:24,610 --> 00:57:25,840
0,300 300,390 390,660 660,840 840,1230
actually the map is there.|
|

1860
00:57:26,520 --> 00:57:28,530
0,660 720,990 990,1260 1260,1410 1410,2010
{} We check this valid,|
我们检查这是有效的，|

1861
00:57:28,920 --> 00:57:30,930
0,690 690,1110 1110,1710 1710,1800 1800,2010
there's debugging help in some
这在某种意义上有帮助调试，

1862
00:57:30,930 --> 00:57:32,160
0,390 390,480 480,660 660,900 960,1230
sense,| you know we should
|你知道我们应该在有效的情况下。

1863
00:57:32,160 --> 00:57:32,970
0,120 120,210 210,480 480,690 690,810
be the case that is

1864
00:57:32,970 --> 00:57:33,660
0,450
valid.|
|

1865
00:57:34,070 --> 00:57:34,880
0,390 390,480 480,630 630,690 690,810
{} And then I do
然后我在内核页表中做同样的事情，

1866
00:57:34,880 --> 00:57:35,660
0,120 120,390 390,600 600,690 690,780
the same thing in the

1867
00:57:35,660 --> 00:57:37,460
0,240 240,480 480,870 1350,1500 1500,1800
kernel {pagetable -},| I look
|我还查看进程内核页表中的虚拟地址，

1868
00:57:37,460 --> 00:57:38,780
0,120 120,330 330,690 690,1050 1050,1320
up that virtual address also

1869
00:57:38,780 --> 00:57:40,280
0,180 180,510 540,1050 1050,1170 1170,1500
in the process of kernel

1870
00:57:40,280 --> 00:57:41,720
0,210 210,750 810,990 990,1050 1050,1440
{pagetable -},| but I call
|但这一次我调用 walk 带上 1 ，

1871
00:57:41,720 --> 00:57:43,400
0,180 180,690 720,1230 1230,1560 1560,1680
this time {} walk with

1872
00:57:43,400 --> 00:57:45,260
0,540 630,840 840,1080 1080,1380 1380,1860
one,| so it actually allocates
|因此，如果需要，它会分配中间页。

1873
00:57:45,260 --> 00:57:47,160
0,570 570,900 900,1020 1020,1650
intermediate pages if necessary.|
|

1874
00:57:48,460 --> 00:57:50,140
0,540 750,1110 1110,1320 1320,1470 1470,1680
{} Then once I got
然后，我得到指向内核 pte 的指针，

1875
00:57:50,140 --> 00:57:51,580
0,420 450,810 810,930 930,1020 1020,1440
the pointer to the kernel

1876
00:57:51,580 --> 00:57:53,560
0,870 1050,1170 1170,1350 1350,1860 1860,1980
pte,| I just copy the
|我只是将用户 pte 复制到内核 pte 。

1877
00:57:53,560 --> 00:57:54,970
0,300 300,810 810,1050 1050,1140 1140,1410
user pte into the kernel

1878
00:57:54,970 --> 00:57:55,700
0,480
pte.|
|

1879
00:57:56,730 --> 00:57:58,170
0,660 750,930 930,1230 1230,1290 1290,1440
{} So probably a lot
可能你们中的很多人调用了 mappages 。

1880
00:57:58,170 --> 00:57:59,670
0,90 90,330 330,870 870,1230 1230,1500
of you called {} {mappages

1881
00:57:59,670 --> 00:58:00,540
0,690
-}.|
|

1882
00:58:00,620 --> 00:58:02,210
0,780 810,930 930,1020 1020,1260 1260,1590
{} But I just copied
但我是直接将 pte 复制到内核 pte 中，

1883
00:58:02,210 --> 00:58:04,070
0,480 480,990 1020,1560 1560,1770 1770,1860
directly the pte into the

1884
00:58:04,070 --> 00:58:05,660
0,270 270,840 1080,1230 1230,1290 1290,1590
kernel pte| and of course
|当然，我要禁用一些位，

1885
00:58:05,660 --> 00:58:07,040
0,120 120,330 330,780 780,1140 1140,1380
I gotta disable some {}

1886
00:58:07,040 --> 00:58:08,030
0,300 300,510 510,630 630,780 780,990
bits| which we'll talk about
|稍后我们会讲到，

1887
00:58:08,030 --> 00:58:09,890
0,90 90,150 150,600 900,1500 1530,1860
in a second {},| but,
|但是，它的实质是，

1888
00:58:10,160 --> 00:58:12,380
0,750 1050,1470 1500,1800 1800,2100 2100,2220
{} {} the essence of

1889
00:58:12,380 --> 00:58:13,550
0,120 120,300 300,420 420,870 870,1170
it is,| I just copy
|我只是复制内核页面 pte 条目。

1890
00:58:13,550 --> 00:58:15,380
0,60 60,330 330,930 930,1290 1290,1830
the kernel page pte entries.|
|

1891
00:58:16,730 --> 00:58:17,780
0,180 180,270 270,360 360,630 630,1050
And so that means that,|
这意味着，|

1892
00:58:17,780 --> 00:58:20,180
0,480 480,1020 1200,1590 1590,2040 2040,2400
{for,example} the physical memory for
用户程序的物理内存是共享的，

1893
00:58:20,180 --> 00:58:21,920
0,150 150,420 420,870 870,1110 1110,1740
the user program is shared,|
|

1894
00:58:22,100 --> 00:58:24,020
0,450 450,690 690,1170 1170,1560 1560,1920
between kernel space and {}
在内核空间和用户空间之间。

1895
00:58:24,400 --> 00:58:25,300
0,270 270,720
user space.|
|

1896
00:58:28,140 --> 00:58:30,030
0,600 1080,1200 1200,1290 1290,1470 1470,1890
Okay, does that make sense.|
好的，能理解吗。|

1897
00:58:32,940 --> 00:58:34,860
0,570 1110,1380 1380,1530 1530,1650 1650,1920
{} Okay, so in terms
好的，切换一些位，

1898
00:58:34,860 --> 00:58:36,090
0,60 60,510 510,600 600,720 720,1230
of switching up some bits|
|

1899
00:58:36,150 --> 00:58:39,150
0,600 660,1080 1080,1440 1560,2550 2610,3000
a little bit {} more
比需要的多一点，

1900
00:58:39,150 --> 00:58:40,470
0,90 90,630 630,780 780,1080 1080,1320
than necessary,| but I switch
|我关闭了执行位，

1901
00:58:40,470 --> 00:58:41,580
0,150 150,240 240,630 630,1020 1020,1110
off the execute bit,| I
|我关闭了写入位，

1902
00:58:41,580 --> 00:58:43,080
0,690 780,1080 1080,1170 1170,1260 1260,1500
I switch off the write

1903
00:58:43,080 --> 00:58:43,640
0,330
bit,|
|

1904
00:58:43,780 --> 00:58:45,310
0,150 150,660 660,1140 1170,1410 1410,1530
is [copyin] only needs to
因为 copyin 只需要读取，不需要写入，

1905
00:58:45,310 --> 00:58:47,530
0,420 840,1380 1380,1740 1740,1890 1890,2220
read never writes to it|
|

1906
00:58:47,530 --> 00:58:48,670
0,180 180,510 510,660 660,840 840,1140
or {copyout -} does that.|
copyout 也是这样。|

1907
00:58:49,170 --> 00:58:51,150
0,150 150,600 600,600 1530,1830 1830,1980
And then, {} you have
然后，你也必须切换 u 标志位。

1908
00:58:51,150 --> 00:58:52,260
0,90 90,330 330,540 540,720 720,1110
to switch up u bit.|
|

1909
00:58:52,780 --> 00:58:55,930
0,630 720,1200 1200,2010 2250,2880 2910,3150
And that is a sort
这是一种 RISC-V 特定的东西，

1910
00:58:55,930 --> 00:58:57,580
0,90 90,360 360,570 570,1080 1080,1650
of {RISC-V -} specific thing,|
|

1911
00:58:57,580 --> 00:58:58,600
0,330 330,450 450,600 600,900 900,1020
that if you're running in
如果你在内核模式下运行，

1912
00:58:58,600 --> 00:58:59,720
0,420 420,930
kernel mode,|
|

1913
00:58:59,880 --> 00:59:02,010
0,480 480,1530 1590,1800 1800,2010 2010,2130
{} and you've been {u,bit}
并且你在 pte 条目中设置了 u 标志位，

1914
00:59:02,010 --> 00:59:03,600
0,360 360,450 450,540 540,1080 1080,1590
{is,set} in the pte entry,|
|

1915
00:59:03,630 --> 00:59:05,790
0,210 210,510 510,990 990,1530 1560,2160
the kernel {can,actually} not access
内核就不能访问那个特定页面。

1916
00:59:05,790 --> 00:59:06,880
0,150 150,480 480,960
that particular page.|
|

1917
00:59:08,140 --> 00:59:10,630
0,630 960,1170 1170,1800 1800,2010 2010,2490
{} In fact you can,|
事实上，你可以，|

1918
00:59:10,660 --> 00:59:12,310
0,840 870,1110 1110,1320 1320,1590 1590,1650
{} this is almost a
这是一个选择，

1919
00:59:12,310 --> 00:59:13,750
0,660 690,870 870,990 990,1230 1230,1440
choice,| you can also actually
|你还可以对 RISC-V 硬件进行编程，

1920
00:59:13,750 --> 00:59:15,430
0,420 420,480 480,720 720,930 930,1680
program the {RISC-V -} hardware,|
|

1921
00:59:15,550 --> 00:59:17,140
0,180 180,660 660,870 870,1140 1140,1590
that basically in kernel mode
这处于内核模式，并忽略 u 标志位。

1922
00:59:17,200 --> 00:59:18,820
0,210 210,960 960,1080 1080,1260 1260,1620
and ignores the u bit.|
|

1923
00:59:19,720 --> 00:59:22,780
0,660 1110,1740 1740,1920 1920,2280 2310,3060
{} And um, but xv6
但是 xv6 没有做这一点，

1924
00:59:22,780 --> 00:59:24,910
0,690 690,930 930,1050 1050,1500 1530,2130
{} doesn't do that {},|
|

1925
00:59:25,150 --> 00:59:26,020
0,240 240,360 360,540 540,630 630,870
so you have to switch
所以你必须切换 u 标志位。

1926
00:59:26,020 --> 00:59:26,900
0,120 120,180 180,660
up the {u,bit}.|
|

1927
00:59:30,880 --> 00:59:31,990
0,210 210,540 540,690 690,780 780,1110
Any questions about the {u,bit},|
有关于 u 标志位的问题吗，|

1928
00:59:31,990 --> 00:59:33,070
0,180 180,300 300,660 660,960 960,1080
because the required number of
因为有很多人人问到了它。

1929
00:59:33,070 --> 00:59:34,380
0,270 270,600 600,870 870,1050
you asked about it.|
|

1930
00:59:40,510 --> 00:59:41,830
0,270 270,450 450,600 600,990 990,1320
So is this done just
那么这么做只是为了确保，

1931
00:59:41,830 --> 00:59:43,870
0,420 570,990 990,1350 1350,1710 1890,2040
to make sure| that the
|内核不会对用户内存做什么坏事。

1932
00:59:43,870 --> 00:59:45,910
0,300 300,810 1080,1290 1290,1650 1650,2040
kernel doesn't do anything bad

1933
00:59:45,970 --> 00:59:47,000
0,210 210,840
to user

1934
00:59:47,080 --> 00:59:48,880
0,570 1080,1380 1380,1530 1530,1710 1710,1800
memory.| Yeah, so why is
|是的，那么为什么会这样？

1935
00:59:48,880 --> 00:59:50,170
0,150 150,240 240,570 570,750 750,1290
this the case why is

1936
00:59:50,170 --> 00:59:51,130
0,300 300,420 420,750 750,870 870,960
this,| you know, so the
|所以问题是，这是出于调试的原因，

1937
00:59:51,130 --> 00:59:52,000
0,300 300,420 420,570 570,690 690,870
question is like is this

1938
00:59:52,000 --> 00:59:53,230
0,180 180,570 570,960 960,1110 1110,1230
for debugging reasons,| or is
|还是有某种隔离的原因这样做。

1939
00:59:53,230 --> 00:59:54,610
0,120 120,270 270,480 480,1080 1080,1380
there sort of isolation reasons

1940
00:59:54,610 --> 00:59:55,420
0,60 60,180 180,570
to do so.|
|

1941
00:59:55,860 --> 00:59:57,660
0,750 840,1350 1350,1500 1500,1680 1680,1800
And, {} I think this
我想这主要是出于调试的原因。

1942
00:59:57,660 --> 00:59:59,070
0,60 60,360 360,450 450,870 870,1410
is mostly for debugging reasons.|
|

1943
00:59:59,450 --> 01:00:00,680
0,450 450,690 690,750 750,1140 1140,1230
{} Because the kernel is
因为内核反正是完全控制的，

1944
01:00:00,680 --> 01:00:02,150
0,90 90,270 270,600 600,1080 1110,1470
in full control anyway, right,|
|

1945
01:00:02,510 --> 01:00:04,580
0,360 360,720 870,1290 1290,1500 1500,2070
kernel can change the satp
内核可以修改 satp 寄存器，

1946
01:00:04,580 --> 01:00:05,630
0,360 360,480 480,840 840,930 930,1050
register,| as well it can
|它页可以禁用分页，

1947
01:00:05,630 --> 01:00:07,040
0,540 540,900 900,1020 1020,1110 1110,1410
disable paging as it wants

1948
01:00:07,040 --> 01:00:08,900
0,360 600,1140 1140,1350 1350,1590 1590,1860
to {},| so it's not
|所以不是，保护用户空间不受内核影响，

1949
01:00:08,900 --> 01:00:09,770
0,240 240,330 330,450 450,630 630,870
like you know the user

1950
01:00:09,770 --> 01:00:11,270
0,270 270,360 360,1050 1200,1440 1440,1500
space is protected from the

1951
01:00:11,270 --> 01:00:12,770
0,570 750,870 870,990 990,1080 1080,1500
kernel,| I think it's mostly
|我认为主要是为了帮助内核开发，

1952
01:00:12,770 --> 01:00:15,170
0,270 270,930 1140,1680 1680,1950 1950,2400
to basically help kernel development,|
|

1953
01:00:15,170 --> 01:00:16,700
0,240 240,660 660,930 930,1200 1200,1530
for example {xv6 -} case
从 xv6 来说，

1954
01:00:16,700 --> 01:00:18,890
0,240 270,990 1020,1320 1320,1710 1860,2190
correct,| unmodified {xv6 -} should
|未修改的 xv6 不应该引用用户页面。

1955
01:00:18,890 --> 01:00:20,750
0,660 690,900 900,1320 1320,1650 1650,1860
never be reference user page

1956
01:00:20,750 --> 01:00:21,520
0,570
period.|
|

1957
01:00:22,130 --> 01:00:24,710
0,600 600,1200 1440,1920 1920,2430 2430,2580
Um, and um, and so
还有，你知道，

1958
01:00:24,710 --> 01:00:25,640
0,360 360,480 480,690
that you know,|
|

1959
01:00:26,200 --> 01:00:28,330
0,240 390,870 870,1320 1320,1770 1770,2130
and basically this just helps
如果你这样做，会有所帮助，

1960
01:00:28,330 --> 01:00:29,890
0,270 270,1020 1050,1350 1350,1440 1440,1560
if you happen to do|
|

1961
01:00:29,890 --> 01:00:31,600
0,210 210,360 360,750 750,1290 1440,1710
that by accident anyway you
出现意外，你会立即得到页面错误，

1962
01:00:31,600 --> 01:00:32,890
0,120 120,270 270,660 660,900 900,1290
would get immediately page fault|
|

1963
01:00:32,890 --> 01:00:34,210
0,480 540,660 660,990 990,1050 1050,1320
and you know a kernel
内核错误，

1964
01:00:34,210 --> 01:00:35,410
0,420 420,510 510,780 780,930 930,1200
panic| and it will help
|这将有助于内核调试，

1965
01:00:35,410 --> 01:00:36,540
0,90 90,330 330,630 630,900
the kernel debug {},|
|

1966
01:00:36,620 --> 01:00:38,000
0,120 120,570 570,690 690,990 990,1380
{} developer to debug the
开发人员调试内核。

1967
01:00:38,060 --> 01:00:38,760
0,420
kernel.|
|

1968
01:00:41,420 --> 01:00:42,340
0,180 180,360 360,660
{Does,that} makes sense.|
能理解吗。|

1969
01:00:44,970 --> 01:00:46,260
0,300 300,630 630,1020
Yeah, thank you.|
是的，谢谢。|

1970
01:00:47,950 --> 01:00:48,940
0,150 150,300 300,480 480,600 600,990
{} I have a {follow,up}
我有一个后续的问题，

1971
01:00:48,940 --> 01:00:51,340
0,360 360,480 480,900 2070,2400 2400,2400
question to that,| {} I
|我理解了关于用户位的部分，

1972
01:00:51,340 --> 01:00:52,570
0,420 420,600 600,840 840,1140 1140,1230
think the part about the

1973
01:00:52,570 --> 01:00:54,310
0,360 360,570 570,810 810,1380 1410,1740
user bit makes sense,| but
|但是关于写入和执行位是怎样的？

1974
01:00:54,310 --> 01:00:56,020
0,150 150,600 600,1080 1110,1590 1590,1710
what about the write and

1975
01:00:56,020 --> 01:00:57,200
0,480 480,1020
execute bits.|
|

1976
01:00:57,400 --> 01:00:58,200
0,630
Yeah.|
是的。|

1977
01:00:59,070 --> 01:01:00,900
0,720 870,1050 1050,1200 1200,1290 1290,1830
{} So does the {execute,bit}
执行位必须打开吗？

1978
01:01:00,900 --> 01:01:01,940
0,180 180,270 270,420 420,780
have to be on?|
|

1979
01:01:07,090 --> 01:01:07,870
0,180 180,270 270,330 330,600 600,780
What does the kernel do
内核用这个页面做什么？

1980
01:01:07,870 --> 01:01:08,880
0,150 150,330 330,810
with this page?|
|

1981
01:01:12,060 --> 01:01:13,320
0,120 120,300 300,600 600,900 960,1260
The only read from, right,|
它只是读，|

1982
01:01:13,320 --> 01:01:14,250
0,60 60,360 360,570 570,630 630,930
the only thing the only
唯一的事情，唯一的指令，

1983
01:01:14,250 --> 01:01:16,410
0,420 420,510 510,1290 1350,1860 1860,2160
instruction| that basically grabs data
|是从这个页面获取数据，

1984
01:01:16,410 --> 01:01:18,060
0,150 150,300 300,780 780,1200 1200,1650
from this pages,| memmove instruction
|memmove 指令和 copyin 。

1985
01:01:18,060 --> 01:01:19,040
0,90 90,480 480,630
and {copyin -}.|
|

1986
01:01:20,660 --> 01:01:21,830
0,180 180,270 270,690 690,930 930,1170
So it only it does
所以它只执行加载指令，

1987
01:01:21,830 --> 01:01:23,390
0,360 360,570 570,1080 1080,1320 1320,1560
execute load instructions from it,|
|

1988
01:01:23,960 --> 01:01:24,520
0,360
or
或者从特定页面加载值，

1989
01:01:24,550 --> 01:01:26,920
0,330 330,1020 1500,1860 1860,2040 2040,2370
loads values from that particular

1990
01:01:26,920 --> 01:01:28,690
0,510 930,1260 1260,1320 1320,1590 1590,1770
page| and the page should
|并且页面应该只包含数据。

1991
01:01:28,690 --> 01:01:29,880
0,180 180,510 510,960
only contain data.|
|

1992
01:01:30,180 --> 01:01:31,350
0,150 150,270 270,420 420,600 600,1170
And so there's no reason
所以内核没有理由写入该页，

1993
01:01:31,350 --> 01:01:32,400
0,240 240,540 570,810 810,930 930,1050
that the kernel should be

1994
01:01:32,400 --> 01:01:33,690
0,270 270,360 360,540 540,1050 1080,1290
writing to that page| and
|所以出于保守考虑，

1995
01:01:33,690 --> 01:01:34,950
0,450 720,810 810,930 930,1020 1020,1260
so it has to be

1996
01:01:34,950 --> 01:01:36,900
0,960 990,1200 1200,1620 1620,1710 1710,1950
conservative,| I disabled the write
|我禁用了写入位。

1997
01:01:36,900 --> 01:01:37,380
0,240
bit.|
|

1998
01:01:37,760 --> 01:01:38,960
0,180 180,270 270,450 450,810 810,1200
And there should be confirmed
并且不应该从该页面执行指令，

1999
01:01:38,960 --> 01:01:40,250
0,210 210,630 630,960 960,1110 1110,1290
never executed instruction from that

2000
01:01:40,250 --> 01:01:42,200
0,420 660,1050 1050,1260 1260,1560 1560,1950
page,| {so,I} disable the execute
|所以我也禁用了执行位。

2001
01:01:42,200 --> 01:01:42,880
0,90 90,450
bit too.|
|

2002
01:01:43,410 --> 01:01:45,060
0,540 540,690 690,750 750,1440 1440,1650
Again, this is mostly I
再说一次，我认为这主要是出于调试的原因，

2003
01:01:45,060 --> 01:01:47,730
0,210 210,300 300,690 690,1320 1590,2670
think for debugging reasons,| not
|而不是因为隔离的原因。

2004
01:01:47,760 --> 01:01:49,160
0,150 150,720 720,1260
for isolation reasons.|
|

2005
01:01:52,190 --> 01:01:53,880
0,300 330,540 540,870 870,1350
OK, makes sense, thanks.|
好的，理解了，谢谢。|

2006
01:01:57,300 --> 01:01:58,480
0,960

2007
01:02:00,760 --> 01:02:02,830
0,390 390,1110 1380,1590 1590,1950 1950,2070
Okay, {} so now the
好的，那么现在我们唯一需要做的是，

2008
01:02:02,830 --> 01:02:03,460
0,180 180,330 330,420 420,570 570,630
only thing we need to

2009
01:02:03,460 --> 01:02:04,210
0,90 90,210 210,600 600,720 720,750
do,| is basically there's a
|基本上有一些位置，

2010
01:02:04,210 --> 01:02:05,500
0,150 150,240 240,510 510,840 1140,1290
bunch of places| where this
|这个代码，这个调用函数在什么位置。

2011
01:02:05,500 --> 01:02:06,640
0,240 240,330 330,750 780,1020 1020,1140
code is being where this

2012
01:02:06,640 --> 01:02:07,980
0,300 300,390 390,570 570,1080
function is being called.|
|

2013
01:02:08,360 --> 01:02:09,320
0,270 270,360 360,510 510,600 600,960
And we need to look
我们看看这些调用的位置，

2014
01:02:09,320 --> 01:02:11,030
0,120 120,540 540,990 990,1410 1410,1710
at these {} places where

2015
01:02:11,060 --> 01:02:12,710
0,540 540,840 840,1080 1080,1530 1530,1650
{} call| to understand what's
|了解发生了什么，

2016
01:02:12,710 --> 01:02:13,560
0,210 210,570
going on,|
|

2017
01:02:13,830 --> 01:02:15,150
0,270 270,450 450,600 600,750 750,1320
{} or how to use,|
或者怎么使用，|

2018
01:02:15,150 --> 01:02:16,170
0,120 120,180 180,330 330,810 810,1020
and I think maybe one
我想其中一个有趣的是，

2019
01:02:16,170 --> 01:02:17,310
0,90 90,240 240,660 660,960 960,1140
of the interesting ones| that
|你们中很少人问到，

2020
01:02:17,310 --> 01:02:18,120
0,150 150,270 300,600 600,690 690,810
you know numbers of you

2021
01:02:18,120 --> 01:02:19,060
0,270 270,720
asked about|
|

2022
01:02:19,330 --> 01:02:20,920
0,510 510,840 840,1440
{} is fork.|
就是 fork 。|

2023
01:02:22,400 --> 01:02:23,600
0,180 180,600 600,840 840,1020 1020,1200
And exactly we talk about
确切地说，我们讨论他们两个。

2024
01:02:23,600 --> 01:02:24,480
0,240 240,300 300,630
both of them.|
|

2025
01:02:27,170 --> 01:02:29,480
0,300 300,480 480,780 780,1410 1440,2310
{} The first fork {},|
第一个 fork ，|

2026
01:02:34,140 --> 01:02:37,170
0,540 540,780 780,1590 1620,2400 2490,3030
{} so here's {} call
这里是对 fork 的调用，

2027
01:02:37,170 --> 01:02:38,940
0,90 90,690 1140,1380 1380,1470 1470,1770
to fork| or to call
|或者调用 fork 中的 kvmmapuser 。

2028
01:02:38,940 --> 01:02:40,920
0,210 210,930 930,1230 1230,1500 1500,1980
to {kvmmapuser - - -}

2029
01:02:40,920 --> 01:02:41,900
0,180 180,690
in fork.|
|

2030
01:02:42,120 --> 01:02:44,310
0,570 570,1170 1560,1800 1800,2040 2040,2190
{} And it takes the
它接受 n- ，|

2031
01:02:44,310 --> 01:02:46,410
0,360 600,780 780,870 870,1800 1800,2100
n-,| so the main question
|我想大部分人问的主要问题是，

2032
01:02:46,410 --> 01:02:47,250
0,60 60,210 210,330 330,660 660,840
I think the {most,of} you

2033
01:02:47,250 --> 01:02:47,920
0,480
ask

2034
01:02:48,000 --> 01:02:50,040
0,630 780,1470 1470,1710 1710,1830 1830,2040
is,| why does it have
|为什么一定要是新的进程内核页表，

2035
01:02:50,040 --> 01:02:51,480
0,120 120,300 300,420 420,810 810,1440
to be the new process

2036
01:02:51,480 --> 01:02:52,920
0,330 330,600 600,1170
kernel {pagetable -},|
|

2037
01:02:53,030 --> 01:02:53,810
0,240 240,420 420,510 510,660 660,780
why does it have to
为什么必须从新进程复制页表，

2038
01:02:53,810 --> 01:02:55,700
0,330 330,450 450,540 540,1260 1290,1890
copy from the new process

2039
01:02:56,090 --> 01:02:57,920
0,570 570,930 930,1260 1260,1560
{pagetable -}| instead of
|而不是当前进程页表，

2040
01:02:57,920 --> 01:02:59,220
0,330 330,720 720,1020
from maybe the

2041
01:02:59,540 --> 01:03:01,160
0,420 420,780 780,990 990,1350 1350,1620
current process {pagetable -},| because
|因为不管怎样，之后都是一样的，

2042
01:03:01,160 --> 01:03:03,170
0,120 120,780 870,1020 1020,1650 1680,2010
it's anyway an identical going

2043
01:03:03,170 --> 01:03:05,390
0,540 540,870 870,1320 1320,1890 1890,2220
forward,| basically {does,it,just} replicates the,|
|基本上，它就是复制了，|

2044
01:03:06,910 --> 01:03:08,170
0,360 360,390 390,600 600,660 660,1260
user {} part of the
页表中的用户部分，

2045
01:03:08,200 --> 01:03:09,250
0,210 210,570 570,690 690,780 780,1050
{pagetable -}| and so why
|那么为什么不使用当前页表来做这件事呢。

2046
01:03:09,250 --> 01:03:10,690
0,210 210,330 330,570 570,840 870,1440
can't we use the current

2047
01:03:10,930 --> 01:03:11,980
0,840

2048
01:03:12,050 --> 01:03:13,250
0,270 270,600 600,690 690,900 900,1200
{pagetable -} for doing that.|
|

2049
01:03:16,520 --> 01:03:18,080
0,720 810,1170 1170,1380 1380,1470 1470,1560
Why actually turns out the
为什么会出现这种情况，

2050
01:03:18,080 --> 01:03:19,280
0,300 300,420 420,780 780,1080 1080,1200
case,| you actually have to
|你必须用新的，

2051
01:03:19,280 --> 01:03:20,660
0,240 240,540 570,1110
use the new,|
|

2052
01:03:20,950 --> 01:03:22,750
0,150 150,300 300,450 450,1200 1470,1800
you know the child's user
子进程的的用户页表。

2053
01:03:22,750 --> 01:03:24,610
0,180 180,240 240,1200 1230,1680 1680,1860
part of the child {user

2054
01:03:24,610 --> 01:03:25,880
0,60 60,480 480,1020
-} {pagetable -}.|
|

2055
01:03:26,060 --> 01:03:27,050
0,240 240,360 360,450 450,540 540,990
Why is that the case.|
为什么会这样呢？|

2056
01:03:36,380 --> 01:03:38,270
0,360 360,810 840,1170 1170,1830 1830,1890
Move you note what bug
想一下你得到了什么 bug 。

2057
01:03:38,270 --> 01:03:39,060
0,120 120,510
you get.|
|

2058
01:03:44,270 --> 01:03:44,960
0,210 210,300 300,420 420,540 540,690
When you get a {remap
当你得到 remap 错误时。

2059
01:03:44,960 --> 01:03:48,140
0,270 270,660 1590,1920 1950,2850 2850,3180
-} error.| You go, maybe
|也许不是 remap 错误，可能是那个，

2060
01:03:48,140 --> 01:03:51,440
0,240 240,420 420,660 660,1140 1230,3300
not remap {} {error,maybe,that,too},| but
|但我想的不是 remap 的那个。

2061
01:03:51,440 --> 01:03:52,310
0,120 120,390 390,540 540,660 660,870
I'm thinking of is not

2062
01:03:52,310 --> 01:03:53,300
0,90 90,390 390,720
the remap one.|
|

2063
01:03:56,210 --> 01:03:57,050
0,270 270,360 360,480 480,720 720,840
Number of you tried it
你们中的一些人试过，|

2064
01:03:57,050 --> 01:03:58,580
0,420 690,990 990,1110 1110,1230 1230,1530
out,| what was your personal
|你们感觉怎么样？

2065
01:03:58,580 --> 01:03:59,500
0,720
experience.|
|

2066
01:04:06,770 --> 01:04:08,210
0,390 390,480 480,540 540,930 930,1440
Anybody on the call who
线上有人试过吗？

2067
01:04:08,750 --> 01:04:09,820
0,300 300,420 420,780
tried this out?|
|

2068
01:04:10,630 --> 01:04:11,830
0,120 120,510 510,720 720,870 870,1200
I remember what they {}
我记得它们[导致的经历]，

2069
01:04:12,610 --> 01:04:14,220
0,480 480,1350
resulting experiences,|
|

2070
01:04:16,430 --> 01:04:17,450
0,120 120,270 270,330 330,930 930,1020
I think the resulting {}
我觉得这个经历，我没有这个 bug ，

2071
01:04:17,450 --> 01:04:19,010
0,840 990,1080 1080,1260 1260,1410 1410,1560
and I did not have

2072
01:04:19,010 --> 01:04:20,030
0,90 90,270 270,720 720,780 780,1020
the bug with,| I think
|我认为体验是在 usertest 中的某个地方。

2073
01:04:20,030 --> 01:04:21,380
0,60 60,480 480,930 930,1110 1110,1350
the resulting experience is that

2074
01:04:21,380 --> 01:04:22,700
0,330 330,420 420,690 690,1140
somewhere in {usertest -}.|
|

2075
01:04:22,990 --> 01:04:24,220
0,240 240,660 660,930 930,1140 1140,1230
A particular {usertest -} and
一个特定的 usertest ，执行大量 fork 和执行，

2076
01:04:24,220 --> 01:04:25,210
0,120 120,150 150,330 330,420 420,990
do a lot of forking

2077
01:04:25,210 --> 01:04:26,530
0,150 150,780 960,1140 1140,1260 1260,1320
and executing,| you're going to
|你会得到一个问题，

2078
01:04:26,530 --> 01:04:27,440
0,150 150,180 180,660
get a problem,|
|

2079
01:04:27,750 --> 01:04:29,850
0,660 660,900 900,1020 1020,1170 1170,2100
{} and you get an
你会得到一个错误，

2080
01:04:31,080 --> 01:04:31,940
0,600
error,|
|

2081
01:04:32,010 --> 01:04:34,290
0,450 450,840 870,990 990,1710 1950,2280
{} in the error, the
在错误中，出错的是，

2082
01:04:34,290 --> 01:04:35,940
0,150 150,270 270,450 450,990 1290,1650
thing that goes wrong is

2083
01:04:35,940 --> 01:04:36,740
0,540
that,|
|

2084
01:04:36,820 --> 01:04:38,770
0,660 1080,1290 1290,1410 1410,1800 1800,1950
{} if you copy from
如果从父进程复制，

2085
01:04:38,770 --> 01:04:40,020
0,90 90,390 390,1080
the parent process,|
|

2086
01:04:40,440 --> 01:04:42,180
0,180 180,270 270,660 660,990 1020,1740
if the parent process exits
如果父进程在子进程之前退出，

2087
01:04:42,210 --> 01:04:43,830
0,360 360,480 480,840 840,1170 1170,1620
before the child process does,|
|

2088
01:04:44,450 --> 01:04:47,120
0,630 810,1320 1650,2040 2040,2430 2430,2670
then the parent process page
那么父进程页表会被彻底清理掉，

2089
01:04:47,120 --> 01:04:49,070
0,330 330,480 480,570 570,1290 1320,1950
table will be completely {}

2090
01:04:49,730 --> 01:04:50,810
0,300 300,570 600,840 840,990 990,1080
clean up, right,| as we
|正如我们之前看到的，

2091
01:04:50,810 --> 01:04:53,300
0,180 180,720 1140,1680 1800,2370 2370,2490
saw before,| and then the
|然后，子进程仍然具有指向父进程页表的指针，

2092
01:04:53,300 --> 01:04:55,240
0,390 390,660 660,930 930,1740
child still has pointers

2093
01:04:55,410 --> 01:04:57,570
0,210 210,570 570,1140 1170,1500 1500,2160
{} to the parent process

2094
01:04:57,960 --> 01:04:59,280
0,870

2095
01:04:59,500 --> 01:05:01,780
0,420 450,690 690,1050 1410,1800 1800,2280
{} {pagetable -}| and so
|所以基本上你会，

2096
01:05:01,810 --> 01:05:03,320
0,570 570,750 750,1290
basically you're gonna,|
|

2097
01:05:03,400 --> 01:05:06,580
0,1080 1470,2070 2070,2670 2670,3000 3000,3180
basically pages {} in {}
基本上子进程中的页表已经处理过，

2098
01:05:06,580 --> 01:05:08,200
0,360 390,780 780,1470
this child process

2099
01:05:08,200 --> 01:05:10,420
0,270 270,900 1140,1500 1500,1650 1650,2220
{pagetable -} have been [treat]|
|

2100
01:05:10,450 --> 01:05:11,920
0,450 450,600 600,870 870,1350 1350,1470
and they're still used,| as
而且仍在使用，|其结果就是各种不良行为，

2101
01:05:11,920 --> 01:05:12,850
0,210 210,540 540,630 630,750 750,930
a result in all kinds

2102
01:05:12,850 --> 01:05:14,280
0,60 60,300 300,750 750,1170
of bad behavior,| because
|因为内核释放页面，

2103
01:05:14,370 --> 01:05:16,650
0,540 720,1200 1200,1470 1470,1800 1800,2280
the kernel wanted free {the,page}|
|

2104
01:05:16,650 --> 01:05:17,910
0,240 240,510 510,900 900,1050 1050,1260
actually writes ones in it
实际上在里面写入 1 ，

2105
01:05:17,940 --> 01:05:18,740
0,600
everywhere,|
|

2106
01:05:19,080 --> 01:05:20,940
0,240 240,780 780,1320 1590,1740 1740,1860
{} {for,debugging} reasons| and so
为了调试的原因，|所以现在你有，

2107
01:05:20,940 --> 01:05:22,740
0,300 300,660 660,780 780,1140 1140,1800
now basically you have| invalid
|

2108
01:05:22,740 --> 01:05:24,360
0,60 60,180 180,600 600,1020 1170,1620
you know {ptes -} sitting
无效的 pte 在你的内核页表中。

2109
01:05:24,360 --> 01:05:26,250
0,180 180,720 1020,1320 1320,1530 1530,1890
in your kernel {pagetable -}.|
|

2110
01:05:29,090 --> 01:05:30,120
0,180 180,300 300,450 450,750
Does that make sense.|
这个能理解吗。|

2111
01:05:37,950 --> 01:05:39,940
0,270 270,480 480,1080 1110,1680
Okay, one more {}.|
好的，下一个。|

2112
01:05:40,700 --> 01:05:41,780
0,60 60,210 210,570 570,870 870,1080
You can do to look
你可以查看 exec.c 。

2113
01:05:41,780 --> 01:05:43,360
0,300 300,660 660,840 840,1320
at {exec.c - -}.|
|

2114
01:05:43,900 --> 01:05:45,700
0,510 510,660 660,780 780,1620
{} In my solutions,
在我的解决方案中，是很直截的，

2115
01:05:47,840 --> 01:05:49,340
0,180 180,390 390,960 960,1260 1260,1500
are pretty straightforward,| always made
|没有修改 exec 。

2116
01:05:49,340 --> 01:05:51,300
0,210 210,990 990,1200 1200,1740
no modifications to exec.|
|

2117
01:05:51,410 --> 01:05:53,660
0,270 270,420 420,1020 1020,1710 1710,2250
{} The only modification away,|
唯一的修改是，|

2118
01:05:53,660 --> 01:05:54,440
0,120 120,480 480,570 570,660 660,780
of course you know the
当然，你知道第一部分的第一个，

2119
01:05:54,440 --> 01:05:56,030
0,270 270,510 510,1020 1050,1230 1230,1590
first thing for, {you,know}, part

2120
01:05:56,030 --> 01:05:56,760
0,450
one,|
|

2121
01:05:56,880 --> 01:05:57,690
0,120 120,300 300,480 480,570 570,810
and then here for part
接下来是第三部分，

2122
01:05:57,690 --> 01:06:00,060
0,480 690,870 870,960 960,1650 1830,2370
three,| which is basically mapping
|将新用户页表映射到内核页表。

2123
01:06:00,060 --> 01:06:00,960
0,690
the

2124
01:06:01,210 --> 01:06:03,460
0,660 690,990 990,1230 1230,1830 1920,2250
new user {pagetable -} into

2125
01:06:03,460 --> 01:06:04,640
0,60 60,360 360,600 600,960
the kernel {pagetable -}.|
|

2126
01:06:04,720 --> 01:06:07,120
0,480 480,840 840,1440 1440,2040 2070,2400
Exec basically does,| we built
exec 基本上是这样做的，|我们构建了一个新的用户地址空间，

2127
01:06:07,120 --> 01:06:08,260
0,60 60,390 390,870
a new user

2128
01:06:08,380 --> 01:06:10,390
0,570 570,1110 1350,1830 1830,1920 1920,2010
address space| and you know
|这一行复制新用户地址空间到内核页表。

2129
01:06:10,390 --> 01:06:11,530
0,150 150,330 330,630 630,1020 1020,1140
there's one line copies of

2130
01:06:11,530 --> 01:06:12,790
0,210 210,450 450,690 690,1020 1020,1260
new user address space into

2131
01:06:12,790 --> 01:06:13,860
0,60 60,300 300,510 510,810
the kernel {pagetable -}.|
|

2132
01:06:15,540 --> 01:06:16,420
0,150 150,360 360,630
And that's it.|
就是这样。|

2133
01:06:21,300 --> 01:06:22,340
0,210 210,810
Any questions.|
有什么问题吗。|

2134
01:06:27,110 --> 01:06:28,640
0,210 210,540 540,660 660,750 750,1530
So, hope in the meantime,|
所以，希望在此期间，|

2135
01:06:28,970 --> 01:06:30,200
0,630 630,900 900,1080 1080,1140 1140,1230
I've answered many of the
我已经回答了你们提交的很多问题，

2136
01:06:30,200 --> 01:06:32,340
0,330 330,840 840,1290 1290,1950
questions that you {}

2137
01:06:32,520 --> 01:06:35,040
0,600 630,1200 1230,1770 2070,2340 2340,2520
{} submitted,| {} we can
|我们可以看看有哪些，

2138
01:06:35,040 --> 01:06:36,990
0,600 600,750 750,1170 1170,1410 1410,1950
look and see which ones,|
|

2139
01:06:37,050 --> 01:06:37,860
0,300 300,420 420,510 510,570 570,810
{} there were a couple
还有几个问题，

2140
01:06:37,860 --> 01:06:39,060
0,300 300,690 690,840 840,990 990,1200
more questions| that I haven't
|我还没讨论过。

2141
01:06:39,060 --> 01:06:40,080
0,210 210,450 450,750
talked about yet.|
|

2142
01:06:40,430 --> 01:06:41,600
0,300 300,540 540,870 870,960 960,1170
{} So maybe we can
所以也许我们可以看看那些，

2143
01:06:41,600 --> 01:06:42,860
0,180 180,240 240,690 690,960 960,1260
look at those| or unless
|或者你有问题要问。

2144
01:06:42,860 --> 01:06:44,600
0,180 180,630 720,1140 1140,1290 1290,1740
you have questions right away.|
|

2145
01:06:46,990 --> 01:06:48,440
0,330 330,720 720,1140
Um, don't we
嗯，我们也要修改 growproc 吗？

2146
01:06:48,810 --> 01:06:51,180
0,1290 1320,1530 1530,1920 1920,2220 2220,2370
modify the {growproc -} as

2147
01:06:51,180 --> 01:06:52,860
0,420 600,1140 1380,1620 1620,1650 1650,1680
well?| Yes, there are a
|是的，还有几处需要修改，

2148
01:06:52,860 --> 01:06:54,420
0,180 180,450 450,780 780,870 870,1560
couple more changes are necessary,|
|

2149
01:06:54,720 --> 01:06:55,580
0,630

2150
01:06:55,970 --> 01:06:58,100
0,480 480,660 660,1260 1290,1680 1680,2130
{} {you,know} in {sbrk -}
在 sbrk 或 growproc 中。

2151
01:06:58,130 --> 01:06:59,340
0,180 180,510 510,960
or {growproc -}.|
|

2152
01:06:59,950 --> 01:07:01,000
0,240 240,810
There's a,
有一个，我这里有一行，

2153
01:07:02,310 --> 01:07:03,870
0,450 450,660 660,840 840,990 990,1560
{} I had a line

2154
01:07:04,470 --> 01:07:06,780
0,300 300,810 1110,1320 1320,1680 1680,2310
right here,| {} similar style
|类似的方式，也有类似的修改。

2155
01:07:07,140 --> 01:07:08,970
0,690 690,960 960,1380 1380,1470 1470,1830
and there's presumably a similar

2156
01:07:08,970 --> 01:07:10,580
0,510 510,1380
change in.|
|

2157
01:07:11,830 --> 01:07:12,640
0,270 270,330 330,510 510,600 600,810
Again I might be it
再说一次，[可能在这里]，

2158
01:07:12,640 --> 01:07:13,660
0,390 390,720 720,810 810,930 930,1020
actually,| usually in it of
|[经常在这里]，

2159
01:07:13,660 --> 01:07:15,340
0,510 840,960 960,1290 1290,1530 1530,1680
course,| it probably has to
|它可能不得不改变。

2160
01:07:15,340 --> 01:07:16,060
0,570
change.|
|

2161
01:07:17,650 --> 01:07:18,970
0,270 270,600 630,870 870,960 960,1320
Because you have to map
因为你必须将初始化代码中的一页映射到，

2162
01:07:18,970 --> 01:07:20,200
0,180 180,390 390,750 750,1050 1050,1230
that one page from the

2163
01:07:20,200 --> 01:07:21,700
0,270 270,600 600,1260
init code into

2164
01:07:22,000 --> 01:07:23,530
0,450 600,930 930,1230 1230,1320 1320,1530
the {} {},| the kernel
|进程中的内核页表。

2165
01:07:23,530 --> 01:07:24,310
0,210 210,450 450,570 570,720 720,780
{pagetable -} for you in

2166
01:07:24,310 --> 01:07:25,180
0,180 180,720
that process.|
|

2167
01:07:26,730 --> 01:07:27,660
0,240 240,300 300,510 510,840 840,930
Because the first process is
因为第一个进程很特别。

2168
01:07:27,660 --> 01:07:28,380
0,450
special.|
|

2169
01:07:35,560 --> 01:07:37,510
0,300 300,720 720,1590 1590,1740 1740,1950
Okay so I'm gonna walk
好的，现在我要浏览一下这里的一些问题，

2170
01:07:37,510 --> 01:07:38,230
0,90 90,210 210,270 270,360 360,720
through some of the questions

2171
01:07:38,230 --> 01:07:39,220
0,300 300,420 420,690 690,870 870,990
here| and I put them
|我把它们放到屏幕上，

2172
01:07:39,220 --> 01:07:40,480
0,240 240,630 660,1050 1050,1170 1170,1260
on the screen,| so you
|所以你们可以看到它们。

2173
01:07:40,480 --> 01:07:41,380
0,120 120,270 270,360 360,570 570,900
can {helpful -} see them.|
|

2174
01:07:41,800 --> 01:07:42,610
0,300 300,360 360,600 600,720 720,810
Actually I don't have to
其实我不一定要把它们全部读出来。

2175
01:07:42,610 --> 01:07:44,500
0,480 480,1140 1320,1560 1560,1680 1680,1890
[through] {} read them out

2176
01:07:44,500 --> 01:07:45,420
0,630
completely.|
|

2177
01:07:45,470 --> 01:07:46,190
0,210 210,330 330,450 450,510 510,720
{} I think the first
第一个问题是，

2178
01:07:46,190 --> 01:07:47,270
0,330 330,480 480,540 540,840 840,1080
question is a question| that
|关于 pte_u 标志位的，

2179
01:07:47,270 --> 01:07:48,380
0,330 330,420 420,750 750,780 780,1110
came up quite a bit

2180
01:07:48,410 --> 01:07:50,220
0,570 570,630 630,1200 1200,1590
about the pte_u bit

2181
01:07:50,480 --> 01:07:52,370
0,810 900,990 990,1350 1380,1560 1560,1890
flag,| {} I think we've
|我想我们已经讨论过了，

2182
01:07:52,370 --> 01:07:55,190
0,270 270,720 1200,1860 2280,2610 2610,2820
covered this,| we also cover
|我们还讨论了，

2183
01:07:55,190 --> 01:07:55,940
0,90 90,300 300,420 420,540 540,750
the fact| that it's not
|它不是防止恶意行为的，

2184
01:07:55,940 --> 01:07:57,260
0,540 540,840 840,960 960,1230 1230,1320
malicious,| but it's mostly for
|而是主要出于调试的原因。

2185
01:07:57,260 --> 01:07:58,340
0,360 360,930
debugging reasons.|
|

2186
01:08:00,850 --> 01:08:03,340
0,510 510,840 840,1170 1170,1620 1980,2490
Similar question about like,| well
类似的问题，比如，|如果你在管理者模式，你能做任何事情吗，

2187
01:08:03,340 --> 01:08:04,360
0,120 120,270 270,300 300,780 780,1020
if you're {} supervisor mode,

2188
01:08:04,360 --> 01:08:06,070
0,210 210,300 300,420 420,1080 1170,1710
can you do anything,| because
|因为你可以切换 satp ，

2189
01:08:06,070 --> 01:08:07,270
0,90 90,180 180,480 480,600 600,1200
you can switch the {satp

2190
01:08:07,270 --> 01:08:09,320
0,720 720,840 840,1110 1110,1830
-},| you can, um.|
|你可以，嗯。|

2191
01:08:09,450 --> 01:08:10,350
0,240 240,450 450,630 630,840 840,900
{} And the answer is
答案是肯定的，

2192
01:08:10,350 --> 01:08:12,840
0,450 570,1050 1050,1680 2190,2340 2340,2490
yes,| also possible and so
|也有可能，所以它是，

2193
01:08:12,840 --> 01:08:13,800
0,270 270,600 600,690 690,810 810,960
it really| you know this
|这个 u 标志位不是关于

2194
01:08:13,800 --> 01:08:15,240
0,210 210,450 450,720 720,1230
{u,bit} is not about|
|

2195
01:08:15,540 --> 01:08:17,550
0,330 330,930 960,1350 1350,1560 1560,2010
the user program being protected
保护用户程序不受内核影响，

2196
01:08:17,550 --> 01:08:18,900
0,150 150,210 210,630 630,810 810,1350
from the kernel,| was really
|实际上是作为标志位帮助内核开发人员，

2197
01:08:19,080 --> 01:08:21,120
0,480 480,930 1110,1620 1620,1710 1710,2040
as a flag to help

2198
01:08:21,120 --> 01:08:22,320
0,60 60,330 330,870 870,990 990,1200
the kernel developer| and build
|用于构建内核。

2199
01:08:22,320 --> 01:08:23,060
0,60 60,510
the kernel.|
|

2200
01:08:24,500 --> 01:08:26,510
0,360 360,780 780,990 990,1590 1620,2010
{} One other specific {RISC-V
另一个特殊的 RISC-V 问题，

2201
01:08:26,510 --> 01:08:28,250
0,270 270,870 990,1320 1320,1380 1380,1740
-} question,| which is why
|为什么在 proc.h 的 trapframe 中，

2202
01:08:28,250 --> 01:08:30,590
0,240 240,570 570,1350 1380,1830 1830,2340
are they {in,trapframe} {proc.h -},|
|

2203
01:08:30,590 --> 01:08:31,550
0,90 90,540 540,720 720,810 810,960
the register should have been
寄存器是这种奇怪的顺序。

2204
01:08:31,550 --> 01:08:32,120
0,330
a

2205
01:08:32,330 --> 01:08:33,980
0,480 480,630 630,720 720,1080 1080,1650
{} in the strange order.|
|

2206
01:08:34,370 --> 01:08:36,350
0,630 630,1050 1050,1200 1200,1560 1560,1980
{} And the reason that
原因是，

2207
01:08:36,350 --> 01:08:37,100
0,570
is,|
|

2208
01:08:37,190 --> 01:08:38,930
0,30 30,30 990,1350 1350,1440 1440,1740
{} I think we mentioned
我们之前提到过，

2209
01:08:38,930 --> 01:08:39,680
0,90 90,150 150,330 330,540 540,750
this a little while ago,|
|

2210
01:08:39,680 --> 01:08:41,690
0,90 90,180 180,450 450,960 1380,2010
in the previous lecture {},|
在上一节课中，|

2211
01:08:41,720 --> 01:08:43,790
0,1080 1260,1440 1440,1680 1680,1830 1830,2070
basically there's something that's called
有一种叫做 RISC-V 压缩指令集的东西，

2212
01:08:43,790 --> 01:08:45,620
0,90 90,360 360,630 630,1290 1320,1830
the {RISC-V -} compressed instruction

2213
01:08:45,620 --> 01:08:46,940
0,390 660,900 900,1050 1050,1110 1110,1320
set,| that has a set
|它使用一组较少的寄存器。

2214
01:08:46,940 --> 01:08:48,280
0,90 90,450 450,1140
of fewer registers.|
|

2215
01:08:48,400 --> 01:08:50,050
0,840 870,1200 1200,1320 1320,1530 1530,1650
And, {} so you have
所以你必须对指令进行更紧凑的编码。

2216
01:08:50,050 --> 01:08:52,180
0,480 480,990 1080,1350 1350,1710 1710,2130
to {} have more compact

2217
01:08:52,180 --> 01:08:53,740
0,450 450,600 600,1350
encoding of instructions.|
|

2218
01:08:53,990 --> 01:08:56,570
0,420 420,930 1140,1710 1740,2280 2280,2580
{} And um, this strange
那么这个奇怪的顺序反映了一个事实，

2219
01:08:56,570 --> 01:08:57,860
0,360 360,810 810,900 900,1170 1170,1290
ordering reflects the fact| that
|它们是压缩版本，

2220
01:08:57,860 --> 01:08:59,480
0,90 90,540 540,1170 1290,1530 1530,1620
they're basically to there's the

2221
01:08:59,480 --> 01:09:01,100
0,630 660,1350
compressed version,|
|

2222
01:09:01,130 --> 01:09:01,760
0,210 210,300 300,450 450,570 570,630
which is some set of
是某组寄存器，

2223
01:09:01,760 --> 01:09:03,140
0,570 570,690 690,930 930,1170 1170,1380
registers,| and then sort of
|是一种压缩版本，

2224
01:09:03,200 --> 01:09:04,190
0,180 180,510 510,780 780,930 930,990
a compressed version,| which is
|我们正在使用的，

2225
01:09:04,190 --> 01:09:05,510
0,240 240,420 420,900 990,1140 1140,1320
what we're using,| it has
|它有一套完整的寄存器。

2226
01:09:05,510 --> 01:09:06,740
0,60 60,390 390,540 540,630 630,1230
a complete set of registers.|
|

2227
01:09:07,440 --> 01:09:09,000
0,150 150,210 210,630 630,930 930,1560
And the compression {} {}
而压缩版本，包含 s1 和 s0 ，

2228
01:09:09,030 --> 01:09:10,700
0,360 360,420 420,900 900,1440
version, for example has

2229
01:09:10,800 --> 01:09:13,380
0,330 330,750 750,1050 1050,1830 2130,2580
{s1 -} and s0,| {s0
|s0 和 s1 ，

2230
01:09:13,380 --> 01:09:14,550
0,270 270,450 450,750 750,870 870,1170
-} and one,| but not
|但没有 s2 到 s11 。

2231
01:09:14,550 --> 01:09:15,630
0,150 150,330 330,570 570,690 690,1080
{s2 -} to {s11}.|
|

2232
01:09:17,380 --> 01:09:18,520
0,180 180,360 360,480 480,750 750,1140
So that's the main reason.|
所以这是主要原因。|

2233
01:09:26,880 --> 01:09:27,960
0,180 180,480 480,540 540,870 870,1080
I think I went through
我想我已经回答了大部分问题，

2234
01:09:27,960 --> 01:09:29,280
0,420 420,510 510,660 660,1140 1140,1320
most of these questions,| but
|但是如果你看到一个问题，

2235
01:09:29,280 --> 01:09:30,210
0,150 150,330 330,450 450,510 510,930
if you see a question,|
|

2236
01:09:30,210 --> 01:09:31,290
0,300 300,480 480,630 630,720 720,1080
that I should have covered
我应该讲却没有讲的问题，

2237
01:09:31,290 --> 01:09:33,420
0,120 120,240 240,630 840,1470 1680,2130
and it didn't,| please interrupt
|请打断我，

2238
01:09:33,420 --> 01:09:34,290
0,180 180,390 390,480 480,600 600,870
me| or if you ask
|或者你可以问我还没有讲到的问题，

2239
01:09:34,290 --> 01:09:35,370
0,30 30,390 390,570 570,810 810,1080
a question I haven't covered

2240
01:09:35,370 --> 01:09:35,920
0,300
yet,|
|

2241
01:09:38,050 --> 01:09:41,020
0,690 870,1410 1410,2160 2610,2670 2670,2970
{} please ask me.| These
请问我。|这些问题基本上是按照提交的顺序，

2242
01:09:41,020 --> 01:09:42,970
0,330 330,750 750,1350 1350,1740 1740,1950
questions {are,basically} {in,order,that} submitted them,|
|

2243
01:09:43,000 --> 01:09:44,280
0,210 210,480 480,1020
so these were.|
所以这些是。|

2244
01:09:48,270 --> 01:09:50,480
0,300 300,480 480,1230 1260,1950
Okay, here maybe {}.|
好的，这里可能是。|

2245
01:09:50,960 --> 01:09:51,770
0,150 150,360 360,450 450,750 750,810
So here's a question,| do
这有一个问题，|对于使用分层页表的操作系统来说，

2246
01:09:51,770 --> 01:09:53,420
0,330 330,630 630,960 960,1410 1410,1650
operating system using hierarchical {pagetables

2247
01:09:53,420 --> 01:09:54,260
0,300 300,480 480,570 570,750 750,840
-}| ever to set up
|是否设置过页表页面，

2248
01:09:54,260 --> 01:09:55,250
0,60 60,300 300,540 540,840 840,990
the {pagetable -} pages,| so
|让层次结构的较低部分是共享的。

2249
01:09:55,250 --> 01:09:56,150
0,150 150,240 240,600 600,840 840,900
that the lower parts of

2250
01:09:56,150 --> 01:09:57,590
0,120 120,600 600,750 750,1110 1110,1440
the hierarchy, are these part

2251
01:09:57,590 --> 01:09:58,480
0,420
shared.|
|

2252
01:09:58,560 --> 01:10:00,300
0,600 630,1050 1050,1350 1350,1590 1590,1740
And, {} you clearly saw
你看到我的解决方案，

2253
01:10:00,300 --> 01:10:01,740
0,180 180,630 630,930 930,990 990,1440
my solution correct,| I share
|我分享条目 1 到 511 ，

2254
01:10:02,170 --> 01:10:03,550
0,360 360,510 510,870 870,1200 1200,1380
{} the entries one to

2255
01:10:03,550 --> 01:10:05,080
0,240 240,660 1080,1260 1260,1350 1350,1530
five eleven| and so this
|这是一个标准的技巧，

2256
01:10:05,080 --> 01:10:06,280
0,90 90,180 180,540 540,990
is a standard trick,|
|

2257
01:10:06,360 --> 01:10:07,650
0,330 330,570 570,630 630,960 960,1290
and lots of operating systems
很多操作系统都是这么做的。

2258
01:10:07,650 --> 01:10:08,300
0,120 120,420
do that.|
|

2259
01:10:17,830 --> 01:10:18,520
0,150 150,360 360,420 420,630 630,690
I think we talked a
我想我们讨论了一下这个特别的问题，

2260
01:10:18,520 --> 01:10:19,870
0,180 180,330 330,600 600,1020 1020,1350
little bit about this particular

2261
01:10:19,870 --> 01:10:20,920
0,300 300,420 420,510 510,960 960,1050
issue| that is important that
|切换到主内核页表是很重要的，

2262
01:10:20,920 --> 01:10:22,510
0,60 60,600 870,1080 1080,1290 1290,1590
you switch to this main

2263
01:10:22,510 --> 01:10:24,120
0,300 300,540 540,930 930,1410
kernel {pagetable -},| because
|因为调度程序，

2264
01:10:24,190 --> 01:10:26,860
0,960 1230,2070 2130,2370 2370,2550 2550,2670
scheduler,| {} there might be
|可能根本没有要运行的用户进程，

2265
01:10:26,860 --> 01:10:28,120
0,240 240,510 510,930 930,1050 1050,1260
no user processes to run

2266
01:10:28,120 --> 01:10:29,260
0,90 90,270 270,930
at all anymore,|
|

2267
01:10:29,310 --> 01:10:30,300
0,330 330,510 510,570 570,930 930,990
{} in the scheduler of
|在调度器中，当然还需要一个页表，

2268
01:10:30,300 --> 01:10:31,290
0,360 360,540 540,690 690,750 750,990
course still needs a {pagetable

2269
01:10:31,290 --> 01:10:32,700
0,330 600,810 810,1050 1050,1260 1260,1410
-},| so it runs with
|因此，它与主内核页表一起运行。

2270
01:10:32,700 --> 01:10:33,900
0,120 120,390 390,660 660,900 900,1200
the main kernel {pagetable -}.|
|

2271
01:10:36,590 --> 01:10:38,270
0,360 360,420 420,510 510,960 1260,1680
Question in the chat.| Yeah
聊天中的问题。|好的，继续。

2272
01:10:38,570 --> 01:10:39,920
0,240 240,690 720,960 960,1080 1080,1350
go ahead.| What is there
|聊天中的内容是什么。

2273
01:10:39,920 --> 01:10:40,880
0,210 210,300 300,780 780,870 870,960
when you pull up the

2274
01:10:40,880 --> 01:10:42,040
0,390
chat.|
|

2275
01:10:44,120 --> 01:10:45,120
0,750

2276
01:10:55,110 --> 01:10:56,220
0,180 180,330 330,510 510,750 930,1110
I can read it.| Yeah
我可以读出来。|是的，我看到了。

2277
01:10:56,220 --> 01:10:57,180
0,360 360,570 570,660 660,870 870,960
I got it.| So I
|所以我想问题是，

2278
01:10:57,180 --> 01:10:58,530
0,210 210,330 330,1110 1110,1260 1260,1350
think you know okay so

2279
01:10:58,530 --> 01:10:59,400
0,90 90,390 390,510 510,780 780,870
the question is,| note the
|注意到 RISC 特权标准说到，

2280
01:10:59,400 --> 01:11:00,690
0,360 390,600 600,810 810,870 870,1290
RISC {privilege - -} specs

2281
01:11:00,690 --> 01:11:01,500
0,270 270,480 480,690 690,750 750,810
saying| that part of the
|隔离的那部分是为了防止 bug ，

2282
01:11:01,500 --> 01:11:02,760
0,540 540,600 600,690 690,1020 1020,1260
separation is to prevent bugs|
|

2283
01:11:02,760 --> 01:11:03,990
0,120 120,390 390,720 720,1140 1140,1230
that allow user program to
允许用户程序使内核跳转到用户空间中的任意代码。

2284
01:11:03,990 --> 01:11:04,980
0,180 180,270 270,600 600,900 900,990
make the kernel jump to

2285
01:11:04,980 --> 01:11:06,630
0,570 570,840 840,930 930,1140 1140,1650
arbitrary code in user space.|
|

2286
01:11:07,200 --> 01:11:08,610
0,300 300,870 900,1140 1140,1350 1350,1410
{} Yes, {} that's a
对，一个很好的观点，

2287
01:11:08,610 --> 01:11:12,270
0,180 180,630 930,1680 2040,2820 3360,3660
good point,| {} yeah, so
|所以你可以在这里辩论，

2288
01:11:12,270 --> 01:11:13,350
0,150 150,480 510,660 660,750 750,1080
you know you can debate

2289
01:11:13,350 --> 01:11:14,070
0,180 180,360 360,450 450,630 630,720
here,| one of these is
|是隔离属性或内核调试属性。

2290
01:11:14,070 --> 01:11:15,720
0,90 90,600 600,990 990,1350 1350,1650
an isolation property or kernel

2291
01:11:15,720 --> 01:11:16,980
0,420 420,960
debugging property.|
|

2292
01:11:16,970 --> 01:11:18,350
0,600 600,690 690,960 960,1110 1110,1380
Clearly, the kernel should never|
显然，内核永远不应该|

2293
01:11:18,350 --> 01:11:19,970
0,390 420,750 750,1140 1170,1530 1530,1620
jump into any part of
直接跳入用户地址空间的任何地址，

2294
01:11:19,970 --> 01:11:21,320
0,120 120,450 450,840 840,1110 1110,1350
the address, the user address

2295
01:11:21,320 --> 01:11:21,980
0,510
space

2296
01:11:22,070 --> 01:11:25,880
0,390 390,1020 1380,1860 1890,2730 2940,3810
{} directly,| {} until {}
|除非我把它视为一种工具，

2297
01:11:26,210 --> 01:11:27,500
0,180 180,450 690,870 870,1110 1110,1290
you know I view this

2298
01:11:27,500 --> 01:11:28,820
0,120 120,540 570,900 900,990 990,1320
as a tool| to help
|来帮助内核调试或捕获这些类型的 bug 。

2299
01:11:28,820 --> 01:11:30,410
0,90 90,390 390,780 780,1140 1170,1590
the kernel debug or catch

2300
01:11:30,410 --> 01:11:31,540
0,210 210,450 450,510 510,990
those kinds of bugs.|
|

2301
01:11:33,080 --> 01:11:34,460
0,240 240,420 420,750 750,1050 1050,1380
And some reasons why {xv6
以及为什么对于 xv6 我们禁用或设置 u 标志位。

2302
01:11:34,460 --> 01:11:37,460
0,300 300,480 480,960 960,1500 2070,3000
-} we also {} disable

2303
01:11:37,490 --> 01:11:39,340
0,330 360,1020 1020,1170 1170,1560
or {set,the} u bit.|
|

2304
01:11:39,400 --> 01:11:40,900
0,330 330,780 780,1020 1020,1080 1080,1500
And don't allow the kernel
并且不允许内核引用任何（用户）页面，

2305
01:11:40,900 --> 01:11:42,460
0,270 270,570 570,660 660,900 900,1560
to refer to any pages,|
|

2306
01:11:43,050 --> 01:11:45,510
0,570 1140,1440 1440,1800 1800,2370 2370,2460
{} that protects us, you
这防止我们，引用用户地址，

2307
01:11:45,510 --> 01:11:47,580
0,180 180,690 720,1200 1200,1560 1560,2070
know you did reference ever

2308
01:11:47,700 --> 01:11:48,820
0,360 360,930
user address,|
|

2309
01:11:49,070 --> 01:11:50,210
0,390 390,630 630,690 690,930 930,1140
{} that the kernel would
实际上内核会出错。

2310
01:11:50,210 --> 01:11:51,200
0,330 330,810
actually fault.|
|

2311
01:12:02,480 --> 01:12:03,410
0,210 210,390 390,600 600,870 870,930
I think I've covered the
我想我也讨论了调度器。

2312
01:12:03,410 --> 01:12:06,520
0,1170 1200,1680 1770,2130 2130,2790
scheduler point, {} too.|
|

2313
01:12:12,520 --> 01:12:14,170
0,780 990,1170 1170,1320 1320,1380 1380,1650
{} So here's a question,|
这里有一个问题，|

2314
01:12:14,170 --> 01:12:15,490
0,90 90,300 300,540 540,990 990,1320
how are pipes implemented {in
xv6 中的管道是如何实现的，

2315
01:12:15,490 --> 01:12:16,630
0,330 330,510 510,750 750,1050 1050,1140
xv6}| and choose change to
|而且在 pgtlb 实验中修改页表，

2316
01:12:16,630 --> 01:12:18,280
0,300 300,900 900,990 990,1410 1410,1650
pagetable implemented the pgtlb lab|
|

2317
01:12:18,280 --> 01:12:19,660
0,360 360,1110
{effect,this} implementation.|
怎样影响这个实现。|

2318
01:12:19,940 --> 01:12:21,860
0,540 990,1410 1410,1560 1560,1830 1830,1920
Um, {} so pipes are
嗯，管道基本上是内核中的一个缓冲内存。

2319
01:12:21,860 --> 01:12:23,600
0,510 510,660 660,1050 1050,1590 1590,1740
basically a buffering memory in

2320
01:12:23,600 --> 01:12:24,420
0,60 60,600
the kernel.|
|

2321
01:12:24,630 --> 01:12:26,520
0,660 690,1260 1290,1650 1650,1800 1800,1890
And {} write, when you
还有写，当你写管道的时候，

2322
01:12:26,520 --> 01:12:27,810
0,210 210,360 360,690 690,1050 1050,1290
write your pipe,| basically calls
|就是调用 copyin ，

2323
01:12:27,810 --> 01:12:28,800
0,480 480,750
{copyin -},|
|

2324
01:12:28,880 --> 01:12:30,290
0,300 300,900 900,1020 1020,1350 1350,1410
and copyin {} copy the
copyin 将字节从用户空间复制到管道中，

2325
01:12:30,290 --> 01:12:31,940
0,360 360,840 840,1050 1050,1410 1410,1650
bytes from user space into

2326
01:12:31,940 --> 01:12:32,600
0,60 60,480
the pipe,|
|

2327
01:12:32,960 --> 01:12:33,980
0,330 330,420 420,600 600,900 900,1020
and in some ways you
在某些方面，页表实验的全部内容，

2328
01:12:33,980 --> 01:12:34,970
0,120 120,210 210,690 720,930 930,990
know the whole part of

2329
01:12:34,970 --> 01:12:37,370
0,90 90,540 540,1080 1080,1770 1800,2400
the pgtbl lab,| basically streamline
|简化了代码。

2330
01:12:37,370 --> 01:12:38,760
0,180 180,630 690,1140
that code {}.|
|

2331
01:12:39,220 --> 01:12:40,630
0,480 660,870 870,1020 1020,1200 1200,1410
{} So you don't have
所以你不用调用很多 walk ，

2332
01:12:40,630 --> 01:12:42,430
0,90 90,330 330,660 660,1320 1560,1800
to do many walks {},|
|

2333
01:12:42,430 --> 01:12:43,390
0,240 240,300 300,540 540,690 690,960
when you actually you're write
当你从用户空间写入管道时。

2334
01:12:43,390 --> 01:12:44,830
0,150 150,360 360,660 660,1020 1020,1440
from user space into the

2335
01:12:45,110 --> 01:12:45,760
0,420
pipe.|
|

2336
01:12:49,150 --> 01:12:50,110
0,180 180,360 360,600 600,660 660,960
{} This is a question
这个问题我想很多人都在问，

2337
01:12:50,110 --> 01:12:50,530
0,60 60,180 180,240 240,360 360,420
I think a lot of

2338
01:12:50,530 --> 01:12:51,610
0,240 240,510 510,690 690,840 840,1080
people ask,| {you,know} like, why
|为什么 uvmfree 和 freewalk ，

2339
01:12:51,610 --> 01:12:52,540
0,150 150,390 390,540 540,780 780,930
did {uvmfree - -} and

2340
01:12:52,540 --> 01:12:53,620
0,180 180,450 450,630 630,810 810,1080
{freewalk -},| {originally -} panic
|会在叶节点引发错误。

2341
01:12:53,620 --> 01:12:54,460
0,90 90,180 180,630
at a leaf.|
|

2342
01:12:54,760 --> 01:12:57,310
0,870 1380,1890 1920,2070 2070,2370 2370,2550
{} And the reason is
原因是，

2343
01:12:57,310 --> 01:12:58,960
0,390 420,570 570,1350 1380,1500 1500,1650
that,| you know we put
|我们把它放到那里，

2344
01:12:58,960 --> 01:12:59,980
0,360 360,510 510,720 720,960 960,1020
that in there,| because it
|因为它坏了，这是一个迹象，

2345
01:12:59,980 --> 01:13:01,690
0,540 570,1080 1290,1500 1500,1620 1620,1710
broke, {} that was an

2346
01:13:01,690 --> 01:13:02,920
0,510 510,630 630,870 870,1170 1170,1230
[indication]| that an area in
|xv6 中的一个区域将被破坏。

2347
01:13:02,920 --> 01:13:03,790
0,90 90,390 390,600 600,750 750,870
the {xv6 -} would be

2348
01:13:03,790 --> 01:13:04,480
0,420
broken,|
|

2349
01:13:04,750 --> 01:13:05,800
0,330 330,420 420,750 750,960 960,1050
that's the [invariant] for {}
这是未修改的 xv6 的不变量，

2350
01:13:05,800 --> 01:13:07,360
0,510 510,750 750,870 870,1170 1170,1560
unmodified {xv6 - - -},|
|

2351
01:13:07,750 --> 01:13:09,070
0,210 210,300 300,450 450,780 780,1320
{} in this particular case,|
在这种情况下，|

2352
01:13:09,070 --> 01:13:09,920
0,630

2353
01:13:10,380 --> 01:13:11,550
0,240 240,330 330,510 510,960 960,1170
that is not true,| and
这不是真的，|因此，你必须从根本上避免错误。

2354
01:13:11,550 --> 01:13:12,870
0,480 690,960 960,1110 1110,1230 1230,1320
so, {} you have to

2355
01:13:12,870 --> 01:13:13,590
0,300 300,420 420,540 540,630 630,720
basically get rid of the

2356
01:13:13,590 --> 01:13:14,180
0,420
panic.|
|

2357
01:13:14,360 --> 01:13:15,230
0,150 150,570 570,660 660,750 750,870
And [realized] that it was
意识到这个错误并不重要，

2358
01:13:15,230 --> 01:13:17,120
0,330 600,1110 1110,1230 1230,1470 1470,1890
not important to panic,| therefore,
|你不应该到达那里。

2359
01:13:17,150 --> 01:13:18,380
0,180 180,330 330,540 540,930
you should not {get,it,there}.|
|

2360
01:13:21,770 --> 01:13:22,760
0,210 210,330 330,570 570,750 750,990
{} I think we talked
我觉得我们讨论了不少，

2361
01:13:22,760 --> 01:13:24,050
0,180 180,240 240,390 390,810 810,1290
quite a bit about,| why
|为什么 vm 复制新的，

2362
01:13:24,050 --> 01:13:26,090
0,420 420,780 780,990 990,1410 1530,2040
vm copy new's,| {} why
|为什么新的 vm 副本是好的。

2363
01:13:26,090 --> 01:13:27,050
0,150 150,360 360,630 630,870 870,960
the new vm copy is

2364
01:13:27,050 --> 01:13:27,900
0,60 60,210 210,570
{} good one.|
|

2365
01:13:34,300 --> 01:13:36,310
0,270 270,420 420,690 690,1350 1380,2010
Okay, here's another question {},|
好的，还有一个问题，|

2366
01:13:36,520 --> 01:13:37,990
0,360 360,870 900,1170 1170,1380 1380,1470
let's see this may be
我们看一下，可能是一个有趣的，

2367
01:13:37,990 --> 01:13:40,690
0,60 60,510 510,1710 1980,2400 2400,2700
an interesting {},| one question
|一个问题问到了更多的设计问题。

2368
01:13:40,690 --> 01:13:42,040
0,120 120,570 570,720 720,960 960,1350
was asked for more design

2369
01:13:42,040 --> 01:13:42,880
0,570
question.|
|

2370
01:13:43,010 --> 01:13:44,390
0,510 510,630 630,930 930,1200 1200,1380
{} I need help have
我需要这张图片。

2371
01:13:44,390 --> 01:13:46,320
0,60 60,570 930,1650
that picture {}.|
|

2372
01:13:46,590 --> 01:13:47,520
0,240 240,450 450,540 540,630 630,930
We look at the kernel
我们看一下内核地址空间，

2373
01:13:47,520 --> 01:13:49,680
0,240 240,810 930,1140 1140,1530 1530,2160
address space where we limited,|
|

2374
01:13:51,130 --> 01:13:53,470
0,270 270,660 1140,1380 1380,1860 1860,2340
{} {},| we limited {}
{} {}，|我们限制，用户地址用户程序可以更大，

2375
01:13:53,500 --> 01:13:55,210
0,270 270,690 690,1050 1050,1440 1440,1710
user address user programs can

2376
01:13:55,210 --> 01:13:57,130
0,180 180,660 990,1470 1470,1830 1830,1920
be bigger| user programs can
|用户程序最多可以增长到 CLIENT 地址。

2377
01:13:57,130 --> 01:13:58,150
0,270 270,390 390,450 450,720 720,1020
grow through the CLINT address,

2378
01:13:58,150 --> 01:13:58,960
0,180 180,540
no further.|
|

2379
01:14:00,000 --> 01:14:01,800
0,570 690,1140 1140,1410 1410,1590 1590,1800
{} Let's say we actually
假设我们实际上想要一路增长到这里。

2380
01:14:01,800 --> 01:14:03,030
0,300 300,390 390,900 900,1140 1140,1230
wanted to grow all the

2381
01:14:03,030 --> 01:14:04,000
0,150 150,270 270,720
way to here.|
|

2382
01:14:04,680 --> 01:14:05,580
0,180 180,360 360,450 450,570 570,900
How could we do that,|
我们怎么能做到这一点，|

2383
01:14:05,640 --> 01:14:07,260
0,420 420,750 1080,1320 1320,1500 1500,1620
what what,| how should we
怎么，|我们应该如何改变设计来允许这个。

2384
01:14:07,260 --> 01:14:08,970
0,420 420,510 510,1440 1440,1590 1590,1710
change the design that would

2385
01:14:08,970 --> 01:14:09,780
0,240 240,600
allow that.|
|

2386
01:14:18,250 --> 01:14:19,200
0,720
Anybody.|
有人知道吗。|

2387
01:14:23,390 --> 01:14:24,890
0,240 240,540 540,810 810,990 990,1500
{} Could we {remap -}
我们是否可以重新映射这些东西，

2388
01:14:24,890 --> 01:14:27,830
0,600 630,1350 1530,1860 1860,2160 2160,2940
the stuff,| {} like CLINT
|比如 CLINT PLIC 和 UART ？

2389
01:14:27,830 --> 01:14:29,180
0,300 300,390 390,810 810,1140 1140,1350
{PLIC - -} and {UART

2390
01:14:29,180 --> 01:14:29,840
0,360
-}.|
|

2391
01:14:31,310 --> 01:14:32,180
0,270 270,450 450,600 600,660 660,870
Yeah, where would you map
是的，你会在哪里映射，

2392
01:14:32,180 --> 01:14:33,500
0,270 390,600 600,1050 1050,1200 1200,1320
that,| so where if you
|你想在哪里，

2393
01:14:33,500 --> 01:14:35,000
0,180 180,240 240,720 1080,1350 1350,1500
want to do,| free up
|来释放地址空间的那部分，

2394
01:14:35,000 --> 01:14:35,930
0,360 360,540 540,720 720,780 780,930
basically that part of the

2395
01:14:35,930 --> 01:14:37,280
0,270 270,540 540,780 780,1230 1230,1350
address space,| where what could
|你能在哪里做（映射）。

2396
01:14:37,280 --> 01:14:37,900
0,90 90,360
you do.|
|

2397
01:14:38,940 --> 01:14:41,010
0,330 330,660 660,960 960,1230 1230,2070
{} Map into {like,a} custom
映射到一个地方，

2398
01:14:41,430 --> 01:14:43,350
0,540 540,1080 1080,1440 1440,1800 1800,1920
thing,| before {KERNBASE -} and
|在 KERNBASE 之前和，

2399
01:14:43,350 --> 01:14:45,930
0,570 600,870 870,1380 1410,2160 2160,2580
after,| like before {PHYSTOP -},
|在 PHYSTOP 之前和 KERNBASE 之后。

2400
01:14:45,930 --> 01:14:47,600
0,360 360,750 750,1050 1050,1560
and after {KERNBASE -}.|
|

2401
01:14:48,050 --> 01:14:49,850
0,390 390,930 960,1290 1290,1470 1470,1800
Yeah, or maybe it's better
是啊，或者更好的是在 PHYSTOP 之后，

2402
01:14:49,850 --> 01:14:51,560
0,210 210,570 570,720 720,1080 1260,1710
to after {PHYSTOP -},| here's
|这里有大量的自由空间。

2403
01:14:51,560 --> 01:14:52,370
0,90 90,360 360,600 600,660 660,810
a huge amount of free

2404
01:14:52,370 --> 01:14:53,140
0,570
space.|
|

2405
01:14:53,360 --> 01:14:54,770
0,270 270,540 540,780 780,1020 1020,1410
Like address space isn't used
比如地址空间没有使用，

2406
01:14:54,770 --> 01:14:55,550
0,150 150,360 360,510 510,720 720,780
like this,| from here to
|从这里到那里都是用于物理内存。

2407
01:14:55,550 --> 01:14:56,420
0,240 240,330 330,630 630,780 780,870
there is basically used for

2408
01:14:56,420 --> 01:14:57,440
0,270 270,690
physical memory.|
|

2409
01:14:57,620 --> 01:14:58,580
0,120 120,240 240,570 570,690 690,960
And we basically could setup
我们可以在这里设置映射，

2410
01:14:58,580 --> 01:15:00,080
0,450 450,780 780,900 900,1410 1410,1500
mappings here,| for example we
|例如，我们可以把 UART 放在这里，

2411
01:15:00,080 --> 01:15:01,160
0,120 120,240 240,330 330,870
could put the UART

2412
01:15:01,210 --> 01:15:02,000
0,600
here,|
|

2413
01:15:03,720 --> 01:15:04,590
0,150 150,270 270,690 690,780 780,870
{UART0 - -},| we can
UART0 ，|我们放在 PHYSTOP 旁边，

2414
01:15:04,590 --> 01:15:06,030
0,390 390,630 630,870 870,1080 1080,1440
put just about PHYSTOP page,|
|

2415
01:15:06,030 --> 01:15:06,720
0,120 120,390 390,570 570,660 660,690
and basically set up a
建立一个映射，

2416
01:15:06,720 --> 01:15:07,740
0,420 420,720
mapping| that
|映射到那个特定的物理地址，

2417
01:15:08,370 --> 01:15:09,690
0,420 420,480 480,690 690,1020 1020,1320
maps in that particular physical

2418
01:15:09,690 --> 01:15:10,400
0,510
address,

2419
01:15:11,010 --> 01:15:12,120
0,240 240,600 600,810 810,930 930,1110
right,| then now will free
|那么现在将释放这些映射，

2420
01:15:12,120 --> 01:15:14,040
0,150 150,630 780,1440 1680,1860 1860,1920
up this mapping| and we
|我们可以把它用作用户空间，

2421
01:15:14,040 --> 01:15:15,030
0,120 120,330 330,450 450,720 720,990
could use it for user

2422
01:15:15,030 --> 01:15:16,590
0,540 690,930 930,1350 1350,1470 1470,1560
space,| so similarly we could
|同样，我们也可以对 UART0 执行此操作，

2423
01:15:16,590 --> 01:15:17,250
0,60 60,270 270,390 390,570 570,660
do that for {UART0 -

2424
01:15:17,250 --> 01:15:18,960
0,510 510,660 660,960 960,1230 1230,1710
-}| or {VIRTIO_disk - -},
|或 VIRTIO_disk ， PLIC 和 CLINT 。

2425
01:15:19,050 --> 01:15:20,220
0,180 180,480 480,600 600,990
for PLIC and CLINT.|
|

2426
01:15:21,420 --> 01:15:22,470
0,150 150,300 300,630 630,750 750,1050
And real kernels do that.|
真正的内核是这样做的。|

2427
01:15:24,730 --> 01:15:25,680
0,120 120,240 240,360 360,690
Does that make sense.|
这个能理解吗。|

2428
01:15:37,000 --> 01:15:38,650
0,240 240,480 480,720 720,960 960,1650
Is it isn't that problematic
这没有问题吗，

2429
01:15:38,650 --> 01:15:40,600
0,240 240,690 690,1140 1140,1380 1470,1950
though,| cause we would want
|因为我们会想要同样的映射，

2430
01:15:40,600 --> 01:15:42,790
0,90 90,600 630,1050 1050,1680 1680,2190
the same same mapping| as
|像原来的内核页表一样。

2431
01:15:42,790 --> 01:15:44,140
0,150 150,1080
the original

2432
01:15:44,290 --> 01:15:46,540
0,390 390,780 780,1050 1050,1620 1650,2250
{} kernel {pagetable -} has.|
|

2433
01:15:48,200 --> 01:15:50,000
0,870 1200,1500 1500,1620 1620,1710 1710,1800
Well, we have to do
好的，我们需要对每个内核页表做这个，

2434
01:15:50,000 --> 01:15:51,200
0,120 120,210 210,510 510,840 900,1200
it in every {} every

2435
01:15:51,200 --> 01:15:52,490
0,210 210,420 420,750 750,1170 1170,1290
kernel {pagetable -},| we have
|我们要复制，

2436
01:15:52,490 --> 01:15:53,510
0,480 480,600 600,720 720,810 810,1020
copies,| we have to map
|我们必须把在特定的位置把它映射到任何地方。

2437
01:15:53,510 --> 01:15:54,830
0,120 120,780 780,870 870,1020 1020,1320
it everywhere at that particular

2438
01:15:54,830 --> 01:15:55,580
0,480
location.|
|

2439
01:16:00,400 --> 01:16:01,210
0,180 180,330 330,480 480,660 660,810
I'm not sure that is,|
我不确定是不是，|

2440
01:16:01,210 --> 01:16:02,530
0,390 450,660 660,870 870,930 930,1320
{} not sure I answered
不确定是否回答了你的问题，

2441
01:16:02,530 --> 01:16:03,700
0,90 90,510 510,840
your question,| but
|但是我不认为这是一个问题。

2442
01:16:03,860 --> 01:16:04,550
0,180 180,300 300,420 420,540 540,690
{} I don't think that's

2443
01:16:04,550 --> 01:16:05,320
0,60 60,480
a problem.|
|

2444
01:16:05,800 --> 01:16:07,030
0,210 210,360 360,510 510,1050 1050,1230
I see, so you do
我明白了，所以你也在原来的（页表）中做这个映射。

2445
01:16:07,030 --> 01:16:08,650
0,210 210,810 900,1320 1320,1440 1440,1620
that mapping also in the

2446
01:16:08,680 --> 01:16:10,990
0,900 1050,1860 1860,2070 2070,2250 2250,2310
original.| Yeah we have to
|是的，我们也得在原来的做这些。

2447
01:16:10,990 --> 01:16:11,860
0,120 120,330 330,420 420,510 510,870
do those in the original

2448
01:16:11,860 --> 01:16:12,320
0,210
one.|
|

2449
01:16:15,760 --> 01:16:17,200
0,120 120,510 510,1110 1140,1320 1320,1440
It does easier if the
这很简单，让整个内核统一，

2450
01:16:17,200 --> 01:16:19,150
0,240 240,540 540,1230 1230,1470 1470,1950
whole kernel uniformly| thinks about
|让 UART0 位于顶端。

2451
01:16:19,360 --> 01:16:20,980
0,300 300,420 420,1230 1230,1500 1500,1620
{UART0 - -} sitting at

2452
01:16:20,980 --> 01:16:21,640
0,60 60,480
the top.|
|

2453
01:16:28,850 --> 01:16:30,560
0,180 180,750 750,990 990,1350 1350,1710
{You,know}, {a,number,of} people ask| why
很多人问到，|为什么我们要将内核堆栈映射到高位置。

2454
01:16:30,560 --> 01:16:31,640
0,90 90,240 240,480 480,540 540,1080
do we map the kernel

2455
01:16:31,640 --> 01:16:32,940
0,450 450,690 690,1050
stacks high up.|
|

2456
01:16:36,330 --> 01:16:36,840
0,450

2457
01:16:37,190 --> 01:16:37,880
0,210 210,270 270,360 360,630 630,690
What is the reason for
那是什么原因呢？

2458
01:16:37,880 --> 01:16:39,800
0,330 420,780 780,1140 1140,1290 1290,1920
that.| Like in procinit, we
|在 procinit 中，我们将这些内核堆栈映射到高处，

2459
01:16:40,530 --> 01:16:42,780
0,540 570,930 930,1470 1680,2010 2010,2250
{} map these kernel stacks

2460
01:16:42,780 --> 01:16:43,800
0,210 210,540 570,840 840,900 900,1020
high up| and if you
|如果你采用复制的方法，

2461
01:16:43,800 --> 01:16:45,180
0,120 120,210 210,540 540,1050 1050,1380
did the copy approach,| you
|你实际上需要修改 procinit ，

2462
01:16:45,180 --> 01:16:46,260
0,270 270,480 480,540 540,960 960,1080
actually have to modify {}

2463
01:16:46,260 --> 01:16:46,840
0,390

2464
01:16:46,930 --> 01:16:48,280
0,540 540,1140
procinit,| actually
|复制这个映射。

2465
01:16:48,990 --> 01:16:50,400
0,330 330,540 540,690 690,1140
copy over that mapping.|
|

2466
01:16:51,550 --> 01:16:53,260
0,540 570,1020 1020,1380 1380,1470 1470,1710
And why sitting in up
为什么要在虚拟地址空间高位置？

2467
01:16:53,260 --> 01:16:54,780
0,240 240,690 690,870 870,1350
high virtual address space?|
|

2468
01:16:59,940 --> 01:17:00,860
0,660
Anybody?|
有人知道吗？|

2469
01:17:09,300 --> 01:17:11,370
0,180 180,390 420,990 990,1590 1590,2070
Is it specifically because the
是不是因为 RISC-V 中的堆栈向下增长，

2470
01:17:11,490 --> 01:17:12,630
0,270 270,420 420,810 810,930 930,1140
{} the stacks in {RISC-V

2471
01:17:12,630 --> 01:17:14,220
0,330 330,600 600,1350 1350,1440 1440,1590
-} grow downwards,| so you
|所以你把它放在地址空间的高处，

2472
01:17:14,220 --> 01:17:14,880
0,210 210,300 300,480 480,570 570,660
place it high in the

2473
01:17:14,880 --> 01:17:16,200
0,330 330,630 630,810 810,930 930,1320
address space,| that it has
|让它有向下增长的空间。

2474
01:17:16,200 --> 01:17:17,500
0,330 330,450 450,600 600,1110
space to grow downwards.|
|

2475
01:17:17,780 --> 01:17:19,460
0,180 180,270 270,510 510,1020 1020,1680
Yeah, how much this direction
是的，这个方向，要向下增长多少页呢？

2476
01:17:19,460 --> 01:17:20,210
0,150 150,330 330,540 540,660 660,750
how much page does it

2477
01:17:20,210 --> 01:17:21,440
0,210 210,300 300,450 450,990
have to grow downwards?|
|

2478
01:17:25,650 --> 01:17:26,850
0,390 390,630 630,900 900,1080 1080,1200
That shouldn't matter, because it's
那应该没关系，因为它只有一页，对吧。

2479
01:17:26,850 --> 01:17:28,350
0,270 270,450 450,780 780,1140 1290,1500
just one page, right.| Yeah
|是的，只有一页，

2480
01:17:28,350 --> 01:17:29,190
0,120 120,270 270,480 480,750 750,840
it's only one page,| so
|那么如果你增长超过一页会发生什么呢？

2481
01:17:29,190 --> 01:17:30,330
0,150 150,420 420,510 510,600 600,1140
what happens if you grow

2482
01:17:30,330 --> 01:17:31,900
0,330 540,900 900,1380
on one page?|
|

2483
01:17:37,200 --> 01:17:39,390
0,180 180,360 360,570 570,960 1620,2190
You run into the {guard,page},
你到了守护页，对吧。

2484
01:17:39,390 --> 01:17:40,080
0,390
correct.|
|

2485
01:17:40,600 --> 01:17:41,710
0,270 270,330 330,570 570,900 900,1110
And the guard page not
而守护页没有映射，

2486
01:17:41,710 --> 01:17:43,570
0,450 870,1110 1110,1380 1380,1590 1590,1860
mapped| and so the kernel
|因此内核将会错误，

2487
01:17:43,570 --> 01:17:44,380
0,120 120,600
will panic,|
|

2488
01:17:44,540 --> 01:17:45,650
0,150 150,270 270,570 570,750 750,1110
which is better than actually
这比覆盖数据结构要好。

2489
01:17:45,650 --> 01:17:47,210
0,360 360,600 600,720 720,960 960,1560
writing over its data structures.|
|

2490
01:17:48,950 --> 01:17:49,820
0,180 180,270 270,540 540,690 690,870
So the reason it's high
所以它在高处的原因是，

2491
01:17:49,820 --> 01:17:51,320
0,240 240,420 450,1110 1110,1320 1320,1500
up is| because we put
|因为我们在它下面放了一个守护页。

2492
01:17:51,320 --> 01:17:52,370
0,60 60,330 330,510 510,840 840,1050
a guard page below it.|
|

2493
01:17:52,460 --> 01:17:53,480
0,180 180,300 300,510 510,660 660,1020
Is there actually any physical
实际上是否有任何与保护页相关联的物理内存。井。

2494
01:17:53,480 --> 01:17:55,070
0,480 480,1080 1080,1230 1230,1320 1320,1590
memory associated with a guard

2495
01:17:55,070 --> 01:17:55,620
0,420
page.

2496
01:17:59,400 --> 01:18:01,200
0,480 780,1200 1230,1410 1410,1560 1560,1800
Well.| No, there's no physical
|不，没有与保护页相关的物理内存，

2497
01:18:01,200 --> 01:18:02,280
0,240 240,660 660,750 750,840 840,1080
memory associated with the guard

2498
01:18:02,280 --> 01:18:03,330
0,360 450,600 600,780 780,960 960,1050
page,| so that's one of
|所以这是把它放得很高的一件很酷的事情

2499
01:18:03,330 --> 01:18:04,470
0,180 180,450 450,690 690,960 960,1140
the cool things about putting

2500
01:18:04,470 --> 01:18:05,940
0,90 90,600 1020,1260 1260,1410 1410,1470
it high| is that we
|就是我们可以放一个保护页面{下面，它}

2501
01:18:05,940 --> 01:18:06,630
0,120 120,240 240,270 270,540 540,690
can put a guard page

2502
01:18:06,630 --> 01:18:08,460
0,510 630,1020 1020,1230 1230,1500 1500,1830
{below,it}| that actually doesn't really
|这实际上不会消耗任何物理内存。

2503
01:18:08,460 --> 01:18:09,800
0,360 360,510 510,780 780,1110
consume any physical memory.|
|

2504
01:18:12,690 --> 01:18:13,520
0,570
Okay.|
好吧。|

2505
01:18:13,930 --> 01:18:14,860
0,150 150,240 240,360 360,690
Does that make sense.|
这有意义吗。|

2506
01:18:17,080 --> 01:18:19,780
0,480 480,1230 1830,2040 2040,2370 2370,2700
Also, basically the stack staff
此外，基本上堆栈人员页面将在某个地方是物理的，

2507
01:18:19,780 --> 01:18:20,980
0,240 240,450 450,900
page will be

2508
01:18:21,570 --> 01:18:23,430
0,780 810,1320 1320,1530 1530,1620 1620,1860
physical somewhere,| but the guard
|但警卫专页不会。

2509
01:18:23,430 --> 01:18:25,200
0,240 240,570 930,1530
page won't.| Exactly.|
|一点儿没错。|

2510
01:18:26,780 --> 01:18:27,710
0,330 330,540 540,600 600,690 690,930
Again, one of the cool
再说一次，使用虚拟内存可以做的很酷的事情之一。

2511
01:18:27,710 --> 01:18:28,400
0,180 180,270 270,390 390,510 510,690
things you can do with

2512
01:18:28,400 --> 01:18:29,300
0,270 270,660
virtual memory.|
|

2513
01:18:30,090 --> 01:18:31,620
0,240 240,360 360,780 780,930 930,1530
Is it possible to overshoot
有没有可能超过警卫页。

2514
01:18:31,620 --> 01:18:33,600
0,120 120,480 480,1170 1200,1920 1920,1980
the guard page.| That's a
|这是个很好的问题

2515
01:18:33,600 --> 01:18:35,370
0,180 180,630 870,1050 1050,1470 1530,1770
great question,| you know one
|你知道吗，举个例子，其中之一就是

2516
01:18:35,370 --> 01:18:36,360
0,120 120,330 330,390 390,780 780,990
of one for example is|
|

2517
01:18:36,360 --> 01:18:37,230
0,120 120,240 240,360 360,780 780,870
you know, you allocated the
你知道，你在堆栈上分配了GUAR-，一个缓冲区

2518
01:18:37,230 --> 01:18:39,150
0,570 570,1260 1350,1740 1740,1830 1830,1920
guar-, a buffer on the

2519
01:18:39,150 --> 01:18:41,820
0,300 300,450 450,1050 1320,2250 2250,2670
stack| that actually {} is
|实际上{}比警卫页大很多，对吧，

2520
01:18:42,120 --> 01:18:43,500
0,690 690,930 930,1050 1050,1110 1110,1380
way bigger than the guard

2521
01:18:43,500 --> 01:18:44,460
0,240 240,510 510,600 600,780 780,960
page, correct,| and sort of
|然后进入下一个内核堆栈页面。

2522
01:18:44,520 --> 01:18:46,500
0,360 360,990 1260,1440 1440,1680 1680,1980
goes into the next kernel

2523
01:18:46,500 --> 01:18:47,460
0,270 270,810
stack page.|
|

2524
01:18:48,070 --> 01:18:49,120
0,330 330,510 510,750 750,930 930,1050
{} And yeah you would
{}是的，你会有一个严重的错误。

2525
01:18:49,120 --> 01:18:50,160
0,90 90,150 150,420 420,780
have a serious bug.|
|

2526
01:18:50,510 --> 01:18:51,830
0,450 480,780 780,1080 1080,1200 1200,1320
{} Most likely you will
{}无论如何你都很有可能会遇到这样的情况，

2527
01:18:51,830 --> 01:18:53,300
0,210 210,390 390,570 570,1050 1080,1470
run into that anyway,| because
|因为您将使用缓冲的第一个条目，

2528
01:18:53,300 --> 01:18:54,470
0,120 120,600 600,780 780,870 870,1170
you would use the first

2529
01:18:54,470 --> 01:18:56,060
0,630 630,810 810,1320
entries that buffer,|
|

2530
01:18:56,120 --> 01:18:56,990
0,240 240,450 450,570 570,660 660,870
and then you will get
然后您就会得到页面错误。

2531
01:18:56,990 --> 01:18:58,460
0,660 690,930 930,1290
the page fault.|
|

2532
01:19:00,640 --> 01:19:01,920
0,150 150,270 270,630 630,1050
When you get lucky.|
当你走运的时候。|

2533
01:19:02,600 --> 01:19:03,980
0,240 240,390 390,570 570,1140 1140,1380
{} So this is not
{}所以这不是一种防弹的内核调试技术，

2534
01:19:03,980 --> 01:19:06,620
0,300 360,1260 1260,1590 1590,2100 2100,2640
a bulletproof kernel debugging technique,|
|

2535
01:19:06,830 --> 01:19:08,030
0,450 450,600 630,870 870,1140 1140,1200
but it has proved to
但事实证明它非常有效。

2536
01:19:08,030 --> 01:19:10,360
0,540 570,1290 1290,1680 1680,2160
be {} extremely effective.|
|

2537
01:19:13,070 --> 01:19:14,000
0,240 240,690
Great question.|
问得好。|

2538
01:19:18,980 --> 01:19:20,060
0,180 180,360 360,870
Any more questions.|
还有什么问题吗。|

2539
01:19:20,500 --> 01:19:21,610
0,240 240,360 360,630 630,780 780,1110
We'll go back to the
我们再回到名单上。

2540
01:19:21,910 --> 01:19:22,580
0,480
list.|
|

2541
01:19:23,600 --> 01:19:24,290
0,240 240,360 360,450 450,480 480,690
See, we have a couple
你看，我们还有几分钟

2542
01:19:24,290 --> 01:19:25,550
0,120 120,480 480,600 600,900 960,1260
more minutes| and then actually
|实际上我们还有一分钟的时间。

2543
01:19:25,550 --> 01:19:26,360
0,60 60,150 150,270 270,450 450,810
we have one more minute.|
|

2544
01:19:27,160 --> 01:19:28,600
0,300 300,450 450,660 660,750 750,1440
{} I have a question,|
{}我有个问题，|

2545
01:19:29,170 --> 01:19:31,600
0,570 900,1290 1290,1410 1410,1860 1890,2430
so once we have our
因此，一旦我们有了进程的内核{pagetable-}，

2546
01:19:31,600 --> 01:19:33,070
0,600 600,870 870,1170 1170,1350 1350,1470
kernel {pagetable -} for the

2547
01:19:33,070 --> 01:19:35,200
0,840 900,1380 1380,1530 1530,1800 1800,2130
processes,| does that mean that
|这是否意味着在{}陷阱代码中，

2548
01:19:35,440 --> 01:19:36,420
0,240 240,750
in the

2549
01:19:36,480 --> 01:19:38,060
0,570 750,1350
{} trap

2550
01:19:39,110 --> 01:19:40,340
0,480 480,570 570,720 720,990 990,1230
code,| we don't need to
|我们不需要切换{Pagetables-}。

2551
01:19:40,340 --> 01:19:42,640
0,990 1020,1350 1350,2100
switch {pagetables -}.|
|

2552
01:19:42,880 --> 01:19:45,280
0,330 330,660 660,750 1710,2070 2070,2400
I think the great question,
我认为最好的问题，一个好的设计问题{}，

2553
01:19:45,280 --> 01:19:46,960
0,60 60,180 180,510 510,1050 1260,1680
a good design question {},|
|

2554
01:19:46,960 --> 01:19:47,860
0,180 180,270 270,450 450,510 510,900
and the answer is yes,
答案是肯定的，你不需要它，对吗？

2555
01:19:47,860 --> 01:19:48,910
0,90 90,240 240,390 390,660 780,1050
you don't need it right,|
|

2556
01:19:48,910 --> 01:19:49,660
0,570
because,
因为，{}主要原因是内核或者蹦床代码，

2557
01:19:49,760 --> 01:19:52,820
0,1110 1530,2040 2070,2550 2550,2940 2940,3060
{} the main reason that

2558
01:19:52,820 --> 01:19:54,200
0,90 90,600 630,990 990,1080 1110,1380
the kernel or in trampoline

2559
01:19:54,200 --> 01:19:55,100
0,420 420,540 540,660 660,810 810,900
code,| we go through all
|我们经历所有这些麻烦是因为我们必须复制用户，

2560
01:19:55,100 --> 01:19:56,060
0,120 120,510 510,630 630,840 840,960
this trouble is because we

2561
01:19:56,060 --> 01:19:57,410
0,210 210,360 360,750 750,870 870,1350
have to copy the user,|
|

2562
01:19:57,870 --> 01:19:59,160
0,330 330,510 510,630 630,780 780,1290
{} we have to switch
{}我们必须从内核{pagetable-}切换到用户{pagetable-}，

2563
01:19:59,160 --> 01:20:00,090
0,150 150,210 210,450 450,660 660,930
from the kernel {pagetable -}

2564
01:20:00,090 --> 01:20:01,110
0,120 120,210 210,450 450,690 690,1020
to the user {pagetable -},|
|

2565
01:20:01,110 --> 01:20:02,700
0,90 90,300 300,540 540,1020 1230,1590
the user {pagetable -} or
用户{pagetable-}或{pagetable-}没有内核映射的睡觉。

2566
01:20:02,760 --> 01:20:03,900
0,180 180,390 390,600 600,840 840,1140
a {pagetable -} doesn't have

2567
01:20:03,900 --> 01:20:04,590
0,60 60,300 300,360 360,420 420,690
the rest of the kernel

2568
01:20:04,590 --> 01:20:05,240
0,450
map.|
|

2569
01:20:05,710 --> 01:20:09,460
0,480 480,780 780,1320 1440,2340 2430,3750
Um, and so, {}  downside.|
嗯，所以，{}个不利因素。|

2570
01:20:09,580 --> 01:20:11,500
0,480 480,690 1110,1440 1440,1650 1650,1920
Wait, I'm not sure that's
等等，我不确定这是不是真的，

2571
01:20:11,500 --> 01:20:13,330
0,270 270,870 870,1020 1020,1470 1470,1830
true,| because the kernel needs
|因为内核需要有用户挡路，

2572
01:20:13,330 --> 01:20:14,710
0,150 150,420 420,540 540,840 840,1380
to have the user block,|
|

2573
01:20:14,890 --> 01:20:16,660
0,330 330,690 690,990 990,1200 1200,1770
{} user flag on set.|
集上的{}用户标志。|

2574
01:20:17,450 --> 01:20:18,230
0,360 360,510 510,630 630,750 750,780
Yeah, okay so there's a
是的，好的，我有几点想说，

2575
01:20:18,230 --> 01:20:18,980
0,240 240,300 300,510 510,570 570,750
couple of points I wanted

2576
01:20:18,980 --> 01:20:21,290
0,60 60,900 1260,1710 1770,2160 2160,2310
to make,| {} so in
|{}所以原则上，{}你可以简化查找，

2577
01:20:21,290 --> 01:20:23,840
0,750 780,1080 1080,1320 1320,1440 1440,2550
principle, {} you could simplify

2578
01:20:24,020 --> 01:20:25,340
0,840 840,1020 1020,1110 1110,1260 1260,1320
find,| let me put it
|我这么说吧，

2579
01:20:25,340 --> 01:20:26,630
0,120 120,360 540,750 750,840 840,1290
this way,| you can simplify
|你可以简化进出，

2580
01:20:26,630 --> 01:20:28,370
0,240 240,330 330,840 1020,1440 1440,1740
entry and exit,| {} if
|{}如果您有一个在内核中映射用户的单页表

2581
01:20:28,370 --> 01:20:29,240
0,150 150,330 330,390 390,630 630,870
you have a single page

2582
01:20:29,240 --> 01:20:30,470
0,300 300,450 450,750 750,810 810,1230
table that maps the user

2583
01:20:30,470 --> 01:20:31,370
0,90 90,150 150,660 660,840 840,900
in the kernel| in a
|在单个{PageTable-}中，

2584
01:20:31,370 --> 01:20:32,480
0,270 270,480 480,780 780,990 990,1110
single {pagetable -},| because then
|因为那样你就不用换了，

2585
01:20:32,480 --> 01:20:33,770
0,90 90,330 330,630 630,720 720,1290
you don't have to switch,|
|

2586
01:20:33,980 --> 01:20:34,790
0,210 210,390 390,600 600,660 660,810
you will have to make
您需要对{xv6-}进行更多修改

2587
01:20:34,790 --> 01:20:36,350
0,60 60,300 300,750 750,1470 1470,1560
a couple more modifications to

2588
01:20:36,350 --> 01:20:37,160
0,210 210,450 450,510 510,690 690,810
{xv6 -}| to make that
|才能做到这一点。

2589
01:20:37,160 --> 01:20:37,800
0,390
happen.|
|

2590
01:20:38,260 --> 01:20:39,310
0,330 330,510 510,600 600,930 930,1050
{But -} in principle you
{但是-}原则上你可以

2591
01:20:39,310 --> 01:20:40,720
0,300 300,390 390,450 450,810 1080,1410
could| and in fact {}
|事实上，直到最近才开始使用的Linux，

2592
01:20:40,720 --> 01:20:43,600
0,690 720,1020 1020,1260 1260,1920 2160,2880
Linux until very recently used,|
|

2593
01:20:43,630 --> 01:20:44,650
0,120 120,240 240,450 450,870 870,1020
you know this sort of
你知道这种策略

2594
01:20:44,650 --> 01:20:47,380
0,660 660,960 960,1620 1710,2070 2070,2730
strategy| of where the kernel
|内核和用户代码位于单个页表中的位置，

2595
01:20:47,380 --> 01:20:50,320
0,600 600,1080 1440,2280 2460,2850 2850,2940
and the user code are

2596
01:20:50,320 --> 01:20:51,490
0,240 240,360 360,450 450,870 870,1170
sitting in a single page

2597
01:20:51,490 --> 01:20:52,220
0,540
table,|
|

2598
01:20:52,400 --> 01:20:54,200
0,450 450,690 690,1110 1110,1320 1320,1800
{} in relying on basically
{}基本上是靠{u，bit}，

2599
01:20:54,200 --> 01:20:55,280
0,210 540,720 720,780 780,900 900,1080
{u,bit},| you know to make
|你知道要确保

2600
01:20:55,280 --> 01:20:56,420
0,240 240,480 480,840
sure that the,|
|

2601
01:20:56,510 --> 01:21:00,500
0,1110 1110,1860 2130,2640 3180,3660 3660,3990
{} {} the user program
{}{}用户程序实际上无法修改任何内核页面。

2602
01:21:00,500 --> 01:21:01,910
0,270 270,600 600,1020 1020,1170 1170,1410
couldn't actually modify any kernel

2603
01:21:01,910 --> 01:21:02,580
0,510
pages.|
|

2604
01:21:02,880 --> 01:21:04,350
0,510 510,720 720,990 990,1260 1260,1470
And the entry exit code
在这种情况下，进入出口代码稍微简单一些，

2605
01:21:04,350 --> 01:21:05,310
0,60 60,210 210,450 450,600 600,960
in that case is slightly

2606
01:21:05,310 --> 01:21:06,570
0,510 540,900 900,990 990,1170 1170,1260
simpler,| because you don't have
|因为您不必切换页表

2607
01:21:06,570 --> 01:21:07,920
0,90 90,450 450,1050 1050,1230 1230,1350
to switch pagetables| when you
|当您进入或离开内核时。

2608
01:21:07,920 --> 01:21:09,060
0,270 270,480 480,660 660,750 750,1140
enter or leave the kernel.|
|

2609
01:21:10,040 --> 01:21:12,560
0,630 900,1740 1770,2070 2070,2190 2190,2520
{} One thing that happened
{}发生了一件事，那就是

2610
01:21:12,560 --> 01:21:14,090
0,210 210,630 630,750 750,1230 1230,1530
with| {for,example} the meltdown attack,|
|{例如}熔毁攻击，|

2611
01:21:14,090 --> 01:21:14,960
0,90 90,210 210,420 420,660
if you might have
如果您可能受到[]侧通道攻击，

2612
01:21:15,170 --> 01:21:18,650
0,600 840,1680 2100,2700 2700,2940 2940,3480
a [] side channel attack,|
|

2613
01:21:18,930 --> 01:21:20,640
0,510 510,960 960,1440 1440,1560 1560,1710
{} in response to the
{}针对实际侧通道攻击，

2614
01:21:20,640 --> 01:21:23,040
0,330 330,600 600,840 840,1290 1560,2400
actually side channel attack,| Linux
|Linux交换机或作为另一种运行模式，

2615
01:21:23,040 --> 01:21:24,660
0,420 420,540 540,780 780,1230 1230,1620
switch or as another mode

2616
01:21:24,660 --> 01:21:25,410
0,120 120,420 420,540 540,600 600,750
of running,| there are two
|有两种运行模式，称为kpti模式。

2617
01:21:25,410 --> 01:21:26,490
0,210 210,300 300,600 600,810 810,1080
modes of running ones called

2618
01:21:26,490 --> 01:21:27,800
0,660 660,1110
kpti mode.|
|

2619
01:21:28,190 --> 01:21:29,630
0,180 180,240 240,480 480,840 840,1440
And in that mode, basically
在该模式下，基本上反映了{xv6-}所做的事情。

2620
01:21:29,660 --> 01:21:31,010
0,240 240,660 660,960 960,1110 1110,1350
that reflects basically what {xv6

2621
01:21:31,010 --> 01:21:31,880
0,270 270,720
-} does.|
|

2622
01:21:32,080 --> 01:21:33,610
0,240 240,510 510,600 600,1170 1170,1530
We're having a separate pagetable,|
我们有一个单独的页面表，|

2623
01:21:33,610 --> 01:21:34,540
0,270 270,330 330,780 780,900 900,930
before the kernel and a
在内核之前使用单独的分页表，在用户空间之前使用单独的分页表。

2624
01:21:34,540 --> 01:21:36,730
0,570 630,1260 1260,1470 1470,1710 1710,2190
separate pagetable before user space.|
|

2625
01:21:40,800 --> 01:21:42,270
0,390 390,570 570,780 780,960 960,1470
But I still don't understand
但我还是不明白这为什么管用，

2626
01:21:42,270 --> 01:21:43,560
0,150 150,480 480,810 810,1110 1110,1290
why that's that works,| so
|因此，假设每个用户进程和内核{}使用相同的{pagetable-}

2627
01:21:43,560 --> 01:21:44,640
0,210 210,360 360,510 510,750 750,1080
let's say the per user

2628
01:21:44,640 --> 01:21:47,040
0,390 390,540 540,750 780,1500 1800,2400
process and the kernel {}

2629
01:21:47,040 --> 01:21:48,810
0,420 420,540 540,930 930,1260 1260,1770
use the same {pagetable -}|
|

2630
01:21:49,080 --> 01:21:51,240
0,510 540,780 780,1170 1170,1800 1830,2160
if the user memory has
如果用户存储器必须设置用户位，

2631
01:21:51,240 --> 01:21:52,140
0,90 90,270 270,360 360,690 690,900
to have the user bit

2632
01:21:52,140 --> 01:21:53,940
0,540 780,900 900,1380 1380,1560 1560,1800
set,| the kernel will not
|内核将无法访问该用户内存权限。

2633
01:21:53,940 --> 01:21:54,960
0,90 90,300 300,420 420,780 780,1020
be able to access that

2634
01:21:54,960 --> 01:21:58,200
0,240 240,660 660,1020 1050,2190 2250,3240
user memory right.| OK, the
|好的，{}

2635
01:21:58,800 --> 01:22:01,560
0,1710 1710,2490
{}.| Okay,
|好吧，在英特尔处理器上这不是规则，

2636
01:22:01,710 --> 01:22:03,090
0,330 330,600 600,1140 1140,1290 1290,1380
on Intel processors that is

2637
01:22:03,090 --> 01:22:04,890
0,150 150,240 240,690 1200,1410 1410,1800
not the rule,| so {for,example},
|因此{例如}，英特尔处理器，如果设置了u位，

2638
01:22:04,890 --> 01:22:06,240
0,270 270,780 780,990 990,1140 1140,1350
Intel processors, if u bit

2639
01:22:06,240 --> 01:22:07,200
0,240 240,300 300,540 540,630 630,960
set,| the kernel could still
|内核仍然可以写入和读取该页。

2640
01:22:07,200 --> 01:22:08,520
0,210 210,330 330,630 660,810 810,1320
write and read that page.|
|

2641
01:22:08,960 --> 01:22:10,070
0,300 300,510 510,750 750,810 810,1110
Oh, that's just a {RISC-V
哦，那只是一个{RISC-V-}的事情。

2642
01:22:10,070 --> 01:22:11,660
0,300 300,750 840,1170 1170,1350 1350,1590
-} thing.| {} And even
|{}甚至在{RISC-V-}上都可以更改，

2643
01:22:11,660 --> 01:22:12,410
0,90 90,150 150,360 360,660 660,750
on the {RISC-V -}, you

2644
01:22:12,410 --> 01:22:13,340
0,90 90,420 420,720
can change it,|
|

2645
01:22:13,510 --> 01:22:14,590
0,390 390,630 630,690 690,930 930,1080
{} there's a bit in
{}状态寄存器中有一位，

2646
01:22:14,590 --> 01:22:16,300
0,180 180,570 570,1140 1290,1620 1620,1710
the status register,| you can
|您可以将其设置为某个位

2647
01:22:16,300 --> 01:22:18,070
0,450 480,960 960,1080 1080,1410 1410,1770
set that to some bit|
|

2648
01:22:18,310 --> 01:22:19,090
0,180 180,240 240,390 390,570 570,780
and if you set that|
如果你把它设置成|

2649
01:22:19,090 --> 01:22:21,040
0,150 150,870 930,1110 1110,1440 1440,1950
then basically in kernel mode,|
然后基本上处于内核模式，|

2650
01:22:21,160 --> 01:22:22,840
0,420 450,810 810,900 900,1440
the {u,bit} is ignored.|
忽略{u，位}。|

2651
01:22:23,250 --> 01:22:24,450
0,330 330,540 540,750 750,1080 1080,1200
Okay so you're telling me
好的，那么你是说这个[]处理器里只有一位

2652
01:22:24,450 --> 01:22:25,560
0,240 240,420 420,630 630,870 870,1110
that there's just one bit

2653
01:22:25,560 --> 01:22:27,750
0,150 150,540 990,1440 1440,1980 1980,2190
in this [] processor| that
|这让我晚了四个小时才睡着。

2654
01:22:27,750 --> 01:22:28,620
0,210 210,330 330,510 510,690 690,870
made me stay up four

2655
01:22:28,620 --> 01:22:31,890
0,300 300,780 840,1290 2610,3030 3030,3270
hours later.| Yes, I'm very
|是的，我对此非常抱歉，

2656
01:22:31,890 --> 01:22:32,880
0,270 270,510 510,720 720,810 810,990
sorry about that,| I should
|我早该知道的，

2657
01:22:32,880 --> 01:22:36,810
0,180 990,1590 1590,1680 1680,1890 1890,3930
have known that,| it was
|这是一份报告，

2658
01:22:36,810 --> 01:22:39,480
0,60 420,1290 1290,2070 2070,2430 2430,2670
a report,| it reminded me
|它让我想起了一个窃听器，

2659
01:22:39,480 --> 01:22:40,440
0,390 390,450 450,630 630,780 780,960
of a bug,| that I
|我在夏天实际吃过的东西，

2660
01:22:40,440 --> 01:22:41,520
0,300 300,510 510,720 720,780 780,1080
actually had during the summer,|
|

2661
01:22:41,520 --> 01:22:42,510
0,120 120,210 210,540 540,690 690,990
it was exactly that bug,|
就是那个窃听器，|

2662
01:22:43,510 --> 01:22:44,920
0,390 510,720 720,990 990,1230 1230,1410
but I forgot about it.|
但是我忘了这件事。|

2663
01:22:46,910 --> 01:22:49,040
0,180 180,360 360,960 1380,1950 1950,2130
So my {apology,for,that}.| No, it's
所以我对此{道歉}。|不，没关系，这是一个，肯定是很有趣的事情，

2664
01:22:49,040 --> 01:22:50,090
0,330 330,450 450,720 720,900 900,1050
okay, it was a, it

2665
01:22:50,090 --> 01:22:51,320
0,210 210,480 480,870 870,1020 1020,1230
was fun figuring it out

2666
01:22:51,320 --> 01:22:52,670
0,120 120,450 450,750 780,960 960,1350
for sure,| but I at
|但是我在某个时候我就像是

2667
01:22:52,670 --> 01:22:53,390
0,180 180,390 390,450 450,540 540,720
some point I was just

2668
01:22:53,390 --> 01:22:54,950
0,120 120,420 420,750 990,1410 1410,1560
like| okay like either I'm
|好吧，要么是我疯了，要么是完全错了，

2669
01:22:54,950 --> 01:22:56,900
0,510 510,690 690,1080 1080,1590 1590,1950
crazy or something completely wrong,|
|

2670
01:22:56,900 --> 01:22:57,530
0,120 120,210 210,360 360,540 540,630
so I'm just gonna go
所以我要去睡觉了

2671
01:22:57,530 --> 01:22:58,550
0,90 90,420 420,570 570,840 840,1020
to sleep| and submit this
|然后提交这份理应是

2672
01:22:58,550 --> 01:22:59,780
0,240 240,660 660,750 750,1080 1080,1230
got supposed| and hopefully when
|希望当我醒来的时候，有人会回答，

2673
01:22:59,780 --> 01:23:00,740
0,90 90,330 330,480 480,780 780,960
I wake up, someone will

2674
01:23:00,740 --> 01:23:02,630
0,540 840,1440 1440,1620 1620,1800 1800,1890
answer,| fortunately that was the
|幸运的是，情况就是这样。

2675
01:23:02,630 --> 01:23:03,620
0,420 420,540 540,630 630,780 780,990
case,| so I was able
|所以我可以继续核销，当我核销的时候，当我这样做的时候，我可以继续核销。

2676
01:23:03,620 --> 01:23:04,940
0,150 150,480 480,870 870,1110 1110,1320
to just continue write off

2677
01:23:04,940 --> 01:23:06,170
0,240 240,510 540,750 750,810 810,1230
when I when I did.|
|

2678
01:23:08,260 --> 01:23:09,610
0,270 270,540 540,630 630,870 870,1350
Okay so I think we
好的，我想我们有点超时了，

2679
01:23:09,700 --> 01:23:10,990
0,270 270,720 720,780 780,960 960,1290
ran overtime a little bit,|
|

2680
01:23:11,020 --> 01:23:13,090
0,690 810,1440 1440,1770 1770,1950 1950,2070
{} hopefully {} this was
{}希望{}这对我们有帮助

2681
01:23:13,090 --> 01:23:15,910
0,570 600,1020 1050,1980 2100,2730 2730,2820
helpful| and reaffirm things with
|并重申使用虚拟内存的东西。

2682
01:23:15,910 --> 01:23:16,900
0,270 270,750
virtual memory.|
|

2683
01:23:17,010 --> 01:23:17,940
0,120 120,300 300,480 480,570 570,930
{} I think it's important
{}我觉得做这件事很重要，

2684
01:23:17,940 --> 01:23:18,690
0,60 60,300 300,510 510,630 630,750
to do,| because we're going
|因为我们还会有三个涉及虚拟内存的实验室。

2685
01:23:18,690 --> 01:23:20,370
0,60 60,390 510,840 840,1080 1080,1680
to get three more labs

2686
01:23:20,370 --> 01:23:21,720
0,420 420,720 720,1110
involving virtual memory.|
|

2687
01:23:22,010 --> 01:23:23,510
0,300 300,600 600,750 750,1170 1200,1500
{} And my hope is
{}我的希望是，

2688
01:23:23,510 --> 01:23:24,680
0,270 270,540 540,660 660,1080 1080,1170
that,| after this one you
|在这一次之后，你知道会有比这次更容易的经历。

2689
01:23:24,680 --> 01:23:25,520
0,120 120,300 300,420 420,480 480,840
know there's going to be

2690
01:23:25,550 --> 01:23:27,900
0,540 540,1230 1290,1530 1530,2220
easier than this experience.|
|

2691
01:23:29,420 --> 01:23:30,560
0,240 240,330 330,600 600,930 930,1140
Can I ask something very
我能问个很快的问题吗。

2692
01:23:30,560 --> 01:23:33,380
0,300 390,1740 1830,2070 2070,2640 2670,2820
quick.| Yeah yeah I'm I'm
|是的，是的，我是，我要留下来，

2693
01:23:33,380 --> 01:23:34,730
0,300 300,510 510,810 810,1170 1170,1350
staying on,| so everybody wants
|所以每个人都想留下来问更多问题，

2694
01:23:34,730 --> 01:23:35,480
0,60 60,210 210,420 420,540 540,750
to stay on and ask

2695
01:23:35,480 --> 01:23:36,890
0,90 90,540 540,990 990,1230 1230,1410
more questions,| please feel free
|请随意做，

2696
01:23:36,890 --> 01:23:37,670
0,120 120,270 270,600 600,690 690,780
to do,| so if you
|所以如果你需要上下一节课，请走吧。

2697
01:23:37,670 --> 01:23:38,270
0,150 150,210 210,420 420,540 540,600
need to go to the

2698
01:23:38,270 --> 01:23:39,600
0,210 210,510 510,720 720,1050
next class, please go.|
|

2699
01:23:40,620 --> 01:23:42,960
0,240 240,960 1320,1800 1800,2130 2130,2340
So basically, {} in all
所以基本上，{}在所有的实验室里，

2700
01:23:42,960 --> 01:23:43,800
0,90 90,450 450,570 570,780 780,840
the labs,| like there's a
|好像有很多人提到，

2701
01:23:43,800 --> 01:23:44,850
0,180 180,240 240,600 600,720 720,1050
lot of mention of,| like
|就像哦我们，这在未来的实验室里可能会有用，

2702
01:23:44,850 --> 01:23:46,020
0,240 240,510 510,870 870,1080 1080,1170
oh we, this might be

2703
01:23:46,020 --> 01:23:47,490
0,360 360,480 480,870 870,1260 1260,1470
useful in future labs,| but
|但是我们实际上从来没有用过我们写的任何代码，

2704
01:23:47,490 --> 01:23:48,690
0,120 120,300 300,690 690,990 990,1200
we never actually use any

2705
01:23:48,690 --> 01:23:49,800
0,90 90,210 210,600 600,750 750,1110
of the code that we

2706
01:23:49,890 --> 01:23:51,160
0,540 570,990
write,| like
|比如那上面有什么计划，

2707
01:23:51,250 --> 01:23:52,960
0,600 840,1110 1110,1230 1230,1560 1560,1710
what's what's the plan on

2708
01:23:52,960 --> 01:23:54,100
0,390 390,600 600,780 780,900 900,1140
that,| like should we just
|例如，我们是否应该只从以前的实验室导入代码

2709
01:23:54,100 --> 01:23:55,270
0,450 450,570 570,930 930,1080 1080,1170
import our code from a

2710
01:23:55,270 --> 01:23:56,710
0,420 420,780 780,1050 1170,1350 1350,1440
previous lab| or like I
|或者就像我不想那样因为如果是窃听器，

2711
01:23:56,710 --> 01:23:57,700
0,90 90,240 240,330 330,630 630,990
don't want to because what

2712
01:23:57,700 --> 01:23:58,510
0,120 120,300 300,600 600,690 690,810
if it's bug,| I don't
|我不想让你知道影响下一个实验室。

2713
01:23:58,510 --> 01:23:59,620
0,270 270,420 420,540 540,1020 1020,1110
wanna you know impact the

2714
01:23:59,620 --> 01:24:00,460
0,270 270,600
next lab.|
|

2715
01:24:00,660 --> 01:24:01,650
0,180 180,390 390,600 600,870 870,990
Yeah, so, one reason we
是的，所以，我们不这么做的一个原因是，

2716
01:24:01,650 --> 01:24:02,430
0,180 180,330 330,600 600,690 690,780
don't do it,| you know
|你知道为什么，为什么建造实验室不是建立在彼此的基础上，

2717
01:24:02,430 --> 01:24:03,720
0,180 180,420 420,510 510,900 900,1290
why, why the build labs

2718
01:24:03,720 --> 01:24:04,620
0,210 210,450 450,570 570,690 690,900
don't build on each other,|
|

2719
01:24:04,620 --> 01:24:06,090
0,210 210,360 360,510 510,900 1140,1470
even though they could {},|
即使他们可以{}，|

2720
01:24:06,090 --> 01:24:07,770
0,180 180,330 330,660 660,1020 1020,1680
used to avoid basic dependencies,|
用于避免基本依赖关系，|

2721
01:24:07,770 --> 01:24:08,310
0,150 150,270 270,360 360,480 480,540
like if you had a
就像如果你在实验室里有个窃听器，

2722
01:24:08,310 --> 01:24:09,780
0,240 240,330 330,630 630,1050 1050,1470
bug in a lab,| that
|用户测试没有公开的

2723
01:24:09,780 --> 01:24:10,950
0,120 120,300 300,750 750,870 870,1170
was not exposed by user

2724
01:24:10,950 --> 01:24:12,210
0,510 630,930 930,1080 1080,1170 1170,1260
tests| or any of other
|或任何其他测试，

2725
01:24:12,210 --> 01:24:13,740
0,510 690,1080 1080,1350 1350,1440 1440,1530
tests,| {} but will be
|{}但是会暴露在那个新的实验室里，

2726
01:24:13,740 --> 01:24:14,820
0,360 360,420 420,570 570,750 750,1080
exposed to that new lab,|
|

2727
01:24:14,820 --> 01:24:16,140
0,240 240,360 360,540 540,780 780,1320
then you know be painful.|
那你就知道会很痛苦。|

2728
01:24:16,680 --> 01:24:19,710
0,600 1020,1770 1860,2490 2490,2610 2610,3030
{} The reason I'm mentioning
{}我提到的原因是

2729
01:24:19,710 --> 01:24:21,390
0,270 270,450 450,600 600,1290 1440,1680
that is| that basically the
|这基本上是真实的事情发生了什么，

2730
01:24:21,390 --> 01:24:22,410
0,240 240,390 390,570 570,780 780,1020
real thing what's going on,|
|

2731
01:24:22,410 --> 01:24:23,250
0,120 120,240 240,420 420,510 510,840
is we're going to do
我们要用{Pageables-}做更多的事情。

2732
01:24:23,250 --> 01:24:25,050
0,480 480,840 840,930 930,1170 1170,1800
more stuff with {pagetables -}.|
|

2733
01:24:25,570 --> 01:24:27,430
0,600 870,1050 1050,1350 1350,1500 1500,1860
{} For example, this lab
{}例如，本实验着眼于简化{copy in-}，

2734
01:24:27,430 --> 01:24:29,440
0,630 630,720 720,1230 1230,1740 1740,2010
looks at simplifying {copyin -},|
|

2735
01:24:29,560 --> 01:24:31,810
0,690 690,1110 1110,1290 1290,1500 1500,2250
later labs, we look at
在后面的实验中，我们将看到对{sbrk-}的更改，

2736
01:24:32,260 --> 01:24:34,090
0,420 420,570 570,780 780,1230 1290,1830
change to {sbrk -},| basically
|基本上，我们将为他的实验室{}您对内核所做的更改。

2737
01:24:34,090 --> 01:24:35,890
0,150 150,450 450,840 840,1500 1650,1800
we're far gonna to {}

2738
01:24:35,890 --> 01:24:36,730
0,150 150,450 450,600 600,780 780,840
the changes you made to

2739
01:24:36,730 --> 01:24:38,260
0,90 90,540 750,870 870,1050 1050,1530
the kernel for his lab.|
|

2740
01:24:38,860 --> 01:24:40,420
0,450 480,660 660,810 810,1230 1260,1560
But you know the fact
但你知道你一直在想的事实是

2741
01:24:40,420 --> 01:24:41,260
0,90 90,240 240,330 330,630 630,840
that you've been thinking about|
|

2742
01:24:41,260 --> 01:24:42,490
0,210 210,450 450,750 750,960 960,1230
kernel {pagetable -} user page
内核{PAGETABLE-}这么多用户页表，会对您有帮助的。

2743
01:24:42,490 --> 01:24:44,080
0,390 390,540 540,930 1110,1320 1320,1590
tables so much, will help

2744
01:24:44,080 --> 01:24:44,500
0,210
you.|
|

2745
01:24:45,060 --> 01:24:47,160
0,450 900,1140 1140,1440 1440,1710 1710,2100
Plus, it really helps you
另外，它真的可以帮助您体验调试这类问题，

2746
01:24:47,160 --> 01:24:48,660
0,630 630,1080 1080,1260 1260,1440 1440,1500
experience debugging these kinds of

2747
01:24:48,660 --> 01:24:50,850
0,630 1080,1260 1260,1500 1500,1980 1980,2190
problems,| due to incorrect page
|由于页表不正确。

2748
01:24:50,850 --> 01:24:51,480
0,510
tables.|
|

2749
01:24:52,800 --> 01:24:53,550
0,270 270,330 330,510 510,690 690,750
Okay I just want to
好的，我只是想确认一下。

2750
01:24:53,550 --> 01:24:54,690
0,180 180,540 570,750 750,930 930,1140
make sure| that it's not
|我不会错过的，

2751
01:24:54,690 --> 01:24:55,860
0,240 240,390 390,750 750,960 960,1170
like I'm missing out,| because
|因为我没有从一号实验室或其他地方复制我的{xargs-}代码。

2752
01:24:55,860 --> 01:24:57,120
0,90 90,390 390,750 750,1020 1020,1260
I didn't copy over my

2753
01:24:57,120 --> 01:24:58,560
0,360 360,720 720,990 990,1200 1200,1440
{xargs -} code from lab

2754
01:24:58,560 --> 01:25:00,360
0,330 480,660 660,1140 1200,1710 1710,1800
one or something.| Decided to
|决定让两个实验室互不依赖。

2755
01:25:00,360 --> 01:25:01,320
0,360 360,480 480,570 570,870 870,960
purpose that the labs were

2756
01:25:01,320 --> 01:25:02,460
0,240 240,600 600,690 690,840 840,1140
not dependent on each other.|
|

2757
01:25:04,570 --> 01:25:05,800
0,300 300,780 900,1110 1110,1170 1170,1230
Okay, thanks, see you on
好的，谢谢，周三见。

2758
01:25:05,800 --> 01:25:07,340
0,420 750,1290
wednesday.| Wednesday.|
|星期三。|

2759
01:25:12,470 --> 01:25:13,730
0,210 210,360 360,570 570,660 660,1260
{} I had a {follow,up}
{}我关于{}映射的问题有一个{跟踪，跟进}，

2760
01:25:13,730 --> 01:25:15,800
0,420 420,660 660,1110 1110,1530 1800,2070
on my question about {}

2761
01:25:15,800 --> 01:25:18,500
0,630 630,870 990,1770 1800,2130 2130,2700
mapping,| {} mapping {} using
|{}使用可分页实验室中的修改映射{}，

2762
01:25:18,530 --> 01:25:20,330
0,450 450,1110 1110,1320 1320,1410 1410,1800
the modification from the pagetable

2763
01:25:20,330 --> 01:25:22,130
0,510 630,1140 1140,1380 1380,1560 1560,1800
lab,| {} would it be
|{}那么是否需要有蹦床地图{}

2764
01:25:22,130 --> 01:25:24,740
0,480 600,1260 1260,1650 1740,2490 2490,2610
then needed to have the

2765
01:25:24,740 --> 01:25:25,840
0,900
trampoline

2766
01:25:26,050 --> 01:25:27,320
0,360 360,1110
{} maps|
|

2767
01:25:27,930 --> 01:25:29,910
0,240 240,660 660,1050 1050,1290 1290,1980
in the user {pagetables -}.|
在用户{Pagetables-}中。|

2768
01:25:30,760 --> 01:25:31,930
0,660 660,840 840,960 960,990 990,1170
{} Okay so I haven't
{}好的，所以我还没有真正想清楚{}。

2769
01:25:31,930 --> 01:25:34,510
0,180 180,390 390,540 540,1080 1260,2580
really thought this through {}.|
|

2770
01:25:34,810 --> 01:25:36,430
0,510 510,690 690,1110 1110,1470 1470,1620
So if you've kernels, let's
所以如果你有内核，假设内核存在，

2771
01:25:36,430 --> 01:25:37,330
0,90 90,180 180,450 450,780 780,900
say the kernel exits,| so
|因此，假设我们已经联接了一个{PageTable-}

2772
01:25:37,330 --> 01:25:38,440
0,330 330,450 450,600 600,720 720,1110
let's say we have join

2773
01:25:38,440 --> 01:25:39,580
0,210 210,510 510,720 720,1020 1020,1140
one single {pagetable -}| as
|就像这里显示的{}一样，正确。

2774
01:25:39,580 --> 01:25:41,260
0,240 240,600 600,960 960,1350 1350,1680
{} one here shown, correct.|
|

2775
01:25:41,760 --> 01:25:43,680
0,780 990,1200 1200,1410 1410,1770 1770,1920
And, {} we're jumping out
并且，{}我们通过{userret-}跳出内核{}。

2776
01:25:43,680 --> 01:25:45,510
0,60 60,150 150,840 1110,1560 1560,1830
of the kernel {} through

2777
01:25:45,510 --> 01:25:46,400
0,330 330,690
{userret -}.|
|

2778
01:25:46,630 --> 01:25:48,460
0,720 720,1110 1110,1260 1260,1590 1590,1830
{} In our goal is
{}我们的目标是{}我们还在内核模式下运行，

2779
01:25:48,460 --> 01:25:50,650
0,900 1290,1530 1530,1710 1710,1920 1920,2190
to {} we're still running

2780
01:25:50,650 --> 01:25:51,580
0,60 60,360 360,630 630,750 750,930
in kernel mode,| so this
|所以这个页面很快就可以访问了，正确的，

2781
01:25:51,580 --> 01:25:53,710
0,330 330,810 810,1440 1440,1770 1770,2130
page shortly accessible, correct,| in
|在由内核保护的页面中。

2782
01:25:53,710 --> 01:25:54,760
0,180 180,240 240,510 510,780 780,1050
by the kernel the guard

2783
01:25:54,760 --> 01:25:55,700
0,540
page.|
|

2784
01:25:55,800 --> 01:25:56,610
0,120 120,390 390,450 450,600 630,810
I'll show you do not
我会让你看不到警卫页，

2785
01:25:56,610 --> 01:25:57,330
0,60 60,300 300,510 510,630 630,720
the guard page,| when I'm
|当我说那张蹦床的时候。

2786
01:25:57,330 --> 01:25:59,190
0,390 540,690 690,1200 1200,1530 1530,1860
saying the trampoline pages there.|
|

2787
01:26:01,040 --> 01:26:05,180
0,630 630,1590 1920,2460 2460,3450 3510,4140
And presumably {} somewhere {},|
想必是{}在某处{}，|

2788
01:26:05,180 --> 01:26:07,610
0,270 270,600 600,660 660,1260 1290,2430
we need to map maybe
我们也许需要绘制一下地图。

2789
01:26:08,210 --> 01:26:09,380
0,900
the.|
|

2790
01:26:11,670 --> 01:26:14,340
0,870 1050,1260 1260,1350 1350,2100 2250,2670
{} Well, the user {trapframe
{}那么用户{trapframe-}

2791
01:26:14,340 --> 01:26:16,350
0,330 330,420 420,570 570,930 1740,2010
-},| we don't really have
|不管怎么说，我们并不能真正接触到，

2792
01:26:16,350 --> 01:26:17,970
0,300 300,420 420,1020 1080,1530 1530,1620
access to anyway,| because we're
|因为我们运行的是内核模式，

2793
01:26:17,970 --> 01:26:19,020
0,300 300,540 540,810 810,930 930,1050
running kernel mode,| we know
|我们知道它在PROC结构中的位置，

2794
01:26:19,020 --> 01:26:19,920
0,240 240,330 330,570 570,690 690,900
where it sits in the

2795
01:26:19,920 --> 01:26:21,420
0,270 270,780 780,1020 1020,1170 1170,1500
proc structure,| or we can
|或者我们可以拿到它。

2796
01:26:21,450 --> 01:26:22,220
0,240 240,480
get it.|
|

2797
01:26:22,580 --> 01:26:23,480
0,450 450,600 600,660 660,840 840,900
{} So I think we
{}所以我想我们可以退出了。

2798
01:26:23,480 --> 01:26:24,640
0,150 150,360 360,960
can just exit.|
|

2799
01:26:25,820 --> 01:26:27,740
0,480 480,750 750,810 810,1710
And when you return,|
当你回来的时候，|

2800
01:26:28,410 --> 01:26:30,030
0,990 990,1200 1200,1380 1380,1470 1470,1620
the user code can just
用户代码可以直接运行，

2801
01:26:30,030 --> 01:26:31,170
0,510 540,690 690,840 840,1020 1020,1140
run,| you know we of
|你知道我们当然{the，u，bit}是有点。

2802
01:26:31,170 --> 01:26:32,250
0,270 270,570 570,810 810,900 900,1080
course {the,u,bit} is a bit.|
|

2803
01:26:32,250 --> 01:26:33,080
0,150 150,570

2804
01:26:36,640 --> 01:26:37,810
0,240 240,450 450,600 600,870 870,1170
But {u,bit} is always set
但是{u，bit}总是设置页面

2805
01:26:37,810 --> 01:26:39,190
0,420 420,570 570,810 810,1110 1110,1380
pages| that actually sit in
|它们实际上位于用户空间中，

2806
01:26:39,190 --> 01:26:40,300
0,240 240,510 510,810 810,900 900,1110
the user space,| so that's
|所以这也很好，

2807
01:26:40,300 --> 01:26:41,860
0,240 240,690 990,1140 1140,1380 1380,1560
fine too,| so when we
|因此，当我们重新进入内核时，

2808
01:26:41,860 --> 01:26:43,420
0,210 210,300 300,840 840,1140 1140,1560
enter the kernel back in,|
|

2809
01:26:43,450 --> 01:26:44,680
0,270 270,630 630,810 810,990 990,1230
we're still with this page
我们仍然使用这个页表，

2810
01:26:44,680 --> 01:26:45,970
0,300 300,480 480,720 720,990 990,1290
table,| that {pagetable -} already
|该{pagetable-}现在已经映射了所有内核。

2811
01:26:45,970 --> 01:26:47,770
0,630 960,1260 1260,1350 1350,1620 1620,1800
has all the kernel now

2812
01:26:47,770 --> 01:26:48,480
0,510
mapped.|
|

2813
01:26:48,540 --> 01:26:49,290
0,240 240,330 330,450 450,660 660,750
And we can just you
我们可以，你知道的，拷贝，

2814
01:26:49,290 --> 01:26:50,460
0,150 150,870 870,990 990,1080 1080,1170
know copy,| you know the
|您知道我们需要直接保存到proc结构中的寄存器。

2815
01:26:50,460 --> 01:26:51,450
0,510 510,660 660,750 750,900 900,990
registers that we need to

2816
01:26:51,450 --> 01:26:52,800
0,330 330,660 660,780 780,1020 1020,1350
save into the proc structure

2817
01:26:52,800 --> 01:26:53,520
0,480
directly.|
|

2818
01:26:54,320 --> 01:26:55,190
0,300 300,360 360,630 630,690 690,870
Instead of having to go
而不必翻阅{}个单独的页面

2819
01:26:55,190 --> 01:26:58,400
0,690 1200,2100 2430,2760 2760,3030 3030,3210
through {} separate page| with
|里面有{proc，structure}。

2820
01:26:58,400 --> 01:26:59,520
0,90 90,570 570,690 690,900
the {proc,structure} in it.|
|

2821
01:27:00,410 --> 01:27:01,340
0,150 150,270 270,600 600,690 690,930
So I believe the change
所以我相信改变会相当简单。

2822
01:27:01,340 --> 01:27:03,620
0,90 90,660 1140,1380 1380,2040
will be pretty straightforward.|
|

2823
01:27:05,070 --> 01:27:07,710
0,570 600,750 750,1290 1680,2070 2070,2640
Okay I see, thank you.|
好的，我明白了，谢谢。|

2824
01:27:07,800 --> 01:27:09,480
0,120 120,360 360,840 1380,1530 1530,1680
{} Of course, I could
{}当然，我可能是错的。

2825
01:27:09,480 --> 01:27:12,480
0,90 90,480 1560,2100 2100,2670 2820,3000
be wrong.| Yeah I'm {}
|是的，我现在{}要试一下。

2826
01:27:12,480 --> 01:27:14,190
0,150 150,630 660,1110 1110,1290 1290,1710
now gonna try it now.
