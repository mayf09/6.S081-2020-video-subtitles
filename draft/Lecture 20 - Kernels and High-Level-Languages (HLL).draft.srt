1
00:00:02,110 --> 00:00:03,220
0,240 240,690 690,900 900,1020 1020,1110
{Alright -}, I want we
好的，我想我们开始了，

2
00:00:03,220 --> 00:00:04,810
0,150 150,660 750,1320 1320,1440 1440,1590
get started,| {} you know
|人们想再次打开摄像机，

3
00:00:05,410 --> 00:00:06,550
0,330 330,510 510,720 750,990 990,1140
people want to turn on

4
00:00:06,550 --> 00:00:08,200
0,120 120,450 450,780 780,1050 1050,1650
the camera again| or well
|它可以很好地创造班级氛围，

5
00:00:08,200 --> 00:00:09,580
0,300 300,390 390,780 780,1020 1020,1380
it be great used to

6
00:00:09,850 --> 00:00:11,830
0,480 480,690 690,810 840,1320 1320,1980
create sort of class atmosphere,|
|

7
00:00:12,430 --> 00:00:13,660
0,600 600,750 750,810 810,1110 1110,1230
{} it's the best we
这是我们能做的最好的。

8
00:00:13,660 --> 00:00:14,620
0,480
can.|
|

9
00:00:14,620 --> 00:00:16,750
0,210 210,330 330,510 510,720 750,2130
Okay, so this is {},|
好的，这是，|

10
00:00:17,440 --> 00:00:18,160
0,60 60,180 180,240 240,390 390,720
we're going to talk today
今天我们要讨论这篇论文，

11
00:00:18,160 --> 00:00:19,270
0,240 240,360 360,930 960,1020 1020,1110
about this paper,| you know
|使用用高级语言编写 UNIX 内核的好处和成本，

12
00:00:19,270 --> 00:00:20,200
0,120 120,480 480,570 570,840 840,930
the benefits and cost of

13
00:00:20,200 --> 00:00:21,640
0,270 270,360 360,660 660,1170 1200,1440
writing a UNIX kernel in

14
00:00:21,640 --> 00:00:23,980
0,210 210,420 420,1110
a high-level language,|
|

15
00:00:24,070 --> 00:00:25,390
0,630 630,750 750,840 840,1050 1050,1320
{} you know, this is
这篇论文编写部分原因是因为 6.S081 或 6.828 ，

16
00:00:25,600 --> 00:00:26,890
0,510 510,750 750,840 840,990 990,1290
basically paper that was partly

17
00:00:26,890 --> 00:00:28,990
0,240 240,570 570,930 990,1770 1770,2100
written because of {} {6.S081

18
00:00:28,990 --> 00:00:29,920
0,120 120,510 510,720 720,810 810,930
- -} or {6.828 -

19
00:00:29,920 --> 00:00:30,840
0,360
-},|
|

20
00:00:30,840 --> 00:00:33,150
0,690 690,1650 1680,2010 2010,2070 2070,2310
{} and there's the paper
这篇论文是由我们编写的，

21
00:00:33,150 --> 00:00:34,170
0,180 180,330 330,450 450,660 660,1020
that you know we've written,|
|

22
00:00:34,260 --> 00:00:35,460
0,600 600,660 660,750 750,1080 1080,1200
{} you know Robert and
Robert 和我，

23
00:00:35,460 --> 00:00:36,540
0,210 210,390 390,690 690,750 750,1080
I,| and that the main
|但主要人物是 Cody Cutler ，

24
00:00:36,540 --> 00:00:38,580
0,330 330,540 540,1080 1140,1680 1680,2040
person was a main lead

25
00:00:38,580 --> 00:00:39,570
0,120 120,360 360,720 720,840 840,990
was Cody Cutler,| who was
|他在这门课上当过很多次助教。

26
00:00:39,570 --> 00:00:42,210
0,420 750,990 990,1230 1230,2310 2460,2640
a {TA -} {this,class} many

27
00:00:42,210 --> 00:00:43,420
0,210 210,750
many times.|
|

28
00:00:43,600 --> 00:00:44,950
0,510 570,960 960,1140 1140,1200 1200,1350
{} It's always a little
这总是有一点，

29
00:00:44,950 --> 00:00:45,940
0,390 390,480 480,630 660,840 840,990
bit,| you know I don't
|我不是特别喜欢

30
00:00:45,940 --> 00:00:47,320
0,240 240,540 540,750 750,1110 1110,1380
really enjoy| actually particularly talking
|谈论我们自己编写的论文，

31
00:00:47,320 --> 00:00:48,640
0,450 480,840 840,960 960,1050 1050,1320
about papers that we worked

32
00:00:48,640 --> 00:00:49,480
0,120 120,210 210,540 540,750 750,840
on {ourselves -},| but you
|但是这篇论文基本上来自 6.S081 或 6.828 ，

33
00:00:49,480 --> 00:00:51,220
0,510 510,840 840,1080 1080,1320 1320,1740
know this paper came about

34
00:00:51,220 --> 00:00:53,230
0,480 870,1050 1050,1200 1200,1650 1800,2010
basically {6.S081 - -} or

35
00:00:53,230 --> 00:00:54,520
0,120 120,270 270,660 660,870 870,1290
{6.828 - -},| and so
|所以这次我要用一些幻灯片，

36
00:00:54,610 --> 00:00:55,780
0,210 210,330 330,450 450,600 600,1170
I'm gonna use some slides

37
00:00:55,900 --> 00:00:57,310
0,270 270,480 480,840 840,1140 1140,1410
{} this time| instead of
|而不是在白板上书写。

38
00:00:57,340 --> 00:00:59,440
0,420 420,900 900,1140 1140,1350 1380,2100
actually writing on a whiteboard.|
|

39
00:01:00,850 --> 00:01:02,440
0,300 300,630 660,1170 1170,1320 1320,1590
And so really the source
所以这篇论文的真正来源就是这个问题，

40
00:01:02,440 --> 00:01:04,090
0,60 60,360 360,780 780,1350 1530,1650
of this paper is this

41
00:01:04,090 --> 00:01:06,220
0,630 630,780 780,1290 1290,1890 1890,2130
question| in what language should
|应该用什么语言编写内核。

42
00:01:06,220 --> 00:01:08,420
0,150 150,750 780,1230 1230,1740
you write a kernel.|
|

43
00:01:08,520 --> 00:01:09,360
0,480 480,630 630,750 750,810 810,840
{} And this is a
这是你们很多人都问过的问题，

44
00:01:09,360 --> 00:01:11,400
0,330 330,540 540,1350 1380,1800 1830,2040
question that many, {} many

45
00:01:11,400 --> 00:01:13,470
0,90 90,450 480,1140 1170,1800 1800,2070
of you asked| {} where
|在过去的 6.828 毕业生中问了很多次，

46
00:01:13,470 --> 00:01:15,240
0,270 840,1260 1260,1320 1320,1380 1380,1770
{you,know} students in the past

47
00:01:15,240 --> 00:01:17,820
0,690 720,870 870,1050 1050,1710 2130,2580
{6.828 - -} graduate {}

48
00:01:17,820 --> 00:01:19,350
0,390 390,600 600,780 780,1020 1020,1530
asked many many many times,|
|

49
00:01:19,380 --> 00:01:20,550
0,240 240,750 750,810 810,900 900,1170
{} apparently you know because
因为你的操作系统或内核中有 bug ，

50
00:01:20,550 --> 00:01:21,270
0,90 90,210 210,330 330,420 420,720
you know you have bugs

51
00:01:21,270 --> 00:01:22,740
0,60 60,180 180,510 510,1350 1350,1470
in the operating system or

52
00:01:22,740 --> 00:01:24,060
0,270 270,750 750,930 930,1110 1110,1320
your kernel| and you're like
|你会说，如果我使用另一种语言编写，

53
00:01:24,060 --> 00:01:25,080
0,300 300,450 450,600 600,720 720,1020
well, if I had written

54
00:01:25,080 --> 00:01:26,490
0,300 300,510 510,900 900,1320 1320,1410
this other language,| then you
|也许我就不会有那些 bug 了。

55
00:01:26,490 --> 00:01:27,420
0,150 150,390 390,480 480,690 690,930
know maybe I would not

56
00:01:27,420 --> 00:01:28,700
0,270 270,510 510,990
have those bugs.|
|

57
00:01:29,140 --> 00:01:31,210
0,570 1050,1290 1290,1470 1470,1650 1650,2070
{} So this is a
所以这是一个经常出现的问题，

58
00:01:31,210 --> 00:01:32,560
0,330 330,420 420,630 630,810 810,1350
question that often comes about|
|

59
00:01:32,560 --> 00:01:34,120
0,540 720,930 930,1170 1170,1440 1440,1560
and it turns out you
事实上，在整个操作系统社区中，

60
00:01:34,120 --> 00:01:35,920
0,300 300,480 480,990 1020,1530 1530,1800
know in the operating system

61
00:01:35,920 --> 00:01:37,090
0,420 420,540 540,930 930,1050 1050,1170
community at large,| you know
|这是一个争论不休的问题，

62
00:01:37,090 --> 00:01:38,860
0,180 180,360 360,750 960,1380 1380,1770
this is a hotly debated

63
00:01:38,860 --> 00:01:40,540
0,570 660,1020 1020,1200 1200,1470 1470,1680
question,| {} but not that
|但事实并不多，你可以进行任何知情的讨论。

64
00:01:40,540 --> 00:01:41,890
0,240 240,870 870,960 960,1110 1110,1350
many facts, you could actually

65
00:01:41,890 --> 00:01:43,390
0,240 240,450 450,690 690,1050 1080,1500
make a sort of any

66
00:01:43,390 --> 00:01:44,740
0,360 360,870
informed discussion.|
|

67
00:01:45,200 --> 00:01:46,100
0,240 240,510 510,600 600,780 780,900
And what we'll see at
我们将在这节课结束时看到，

68
00:01:46,100 --> 00:01:46,880
0,360 360,510 510,600 600,720 720,780
this at the end of

69
00:01:46,880 --> 00:01:48,170
0,150 150,510 510,780 780,900 900,1290
this lecture,| during this lecture
|在课程中或你读论文时，

70
00:01:48,170 --> 00:01:48,920
0,210 210,360 360,510 510,570 570,750
or you as you read

71
00:01:48,920 --> 00:01:50,420
0,90 90,660 780,1200 1200,1380 1380,1500
the paper,| I know we
|我知道我们对这个问题没有明确的答案，

72
00:01:50,420 --> 00:01:52,730
0,150 150,540 540,780 780,1170 1200,2310
don't really have a crisp

73
00:01:53,300 --> 00:01:55,940
0,450 450,600 600,930 960,1710 1860,2640
answer to this question,| but
|但是我们这篇论文贡献了很多数据，

74
00:01:55,940 --> 00:01:57,500
0,150 150,360 360,1080 1080,1260 1260,1560
we have {sort,of} this paper

75
00:01:57,500 --> 00:01:58,700
0,720 720,840 840,930 930,990 990,1200
contributes you know a bunch

76
00:01:58,700 --> 00:01:59,690
0,60 60,450 450,720 720,840 840,990
of data,| that you know
|可以让你有更深入的讨论，

77
00:01:59,690 --> 00:02:01,010
0,330 330,480 480,690 690,960 960,1320
allows you to have a

78
00:02:01,010 --> 00:02:01,760
0,150 150,300 300,540 540,630 630,750
little bit more of an

79
00:02:01,760 --> 00:02:04,820
0,480 480,1110 1380,2220 2670,2940 2940,3060
in-depth discussion| about what is
|关于什么是内核的好的编程语言。

80
00:02:04,820 --> 00:02:06,770
0,690 780,1200 1200,1560 1560,1860 1860,1950
a good programming language for

81
00:02:06,770 --> 00:02:07,520
0,60 60,480
the kernel.|
|

82
00:02:08,130 --> 00:02:09,450
0,150 150,330 330,450 450,1020 1050,1320
So that was really {}
这就是这篇论文的原创之处，

83
00:02:09,450 --> 00:02:11,220
0,300 300,1050 1050,1110 1110,1290 1290,1770
the original of this paper,|
|

84
00:02:11,220 --> 00:02:14,070
0,360 780,1440 1440,1920 2220,2370 2370,2850
and {} and so we're,
基本上这篇论文的来源就是你们。

85
00:02:15,240 --> 00:02:18,210
0,1080 1080,1200 1200,2190 2190,2850 2850,2970
{} and the source you

86
00:02:18,210 --> 00:02:19,590
0,540 660,810 810,1050 1050,1290 1290,1380
know of this paper is

87
00:02:19,590 --> 00:02:21,800
0,420 420,540 540,1050 1260,1710
basically you guys {}.|
|

88
00:02:21,860 --> 00:02:24,740
0,540 720,1530 1830,2100 2100,2520 2550,2880
So, {} try to answer
那么，为了回答这个问题，

89
00:02:24,740 --> 00:02:28,160
0,90 90,690 870,1890 1890,2670 2730,3420
the question,| {} we wrote
|我们编写了一个新的内核，

90
00:02:28,160 --> 00:02:30,500
0,30 30,150 150,720 1110,1800 1890,2340
a new kernel,| {} and
|并且我们用具有自动内存管理的语言，

91
00:02:30,500 --> 00:02:31,220
0,300 300,450 450,540 540,630 630,720
we did it in the

92
00:02:31,220 --> 00:02:33,740
0,600 630,990 990,1230 1230,1950 2220,2520
language {} with automatic memory

93
00:02:33,740 --> 00:02:35,090
0,540 540,690 690,960 960,1050 1050,1350
management| that means with {garbage
|这意味着有垃圾收集器，

94
00:02:35,090 --> 00:02:36,170
0,90 90,480 480,780 780,930 930,1080
-} collector,| so you don't
|所以你不需要调用 free ，

95
00:02:36,170 --> 00:02:37,760
0,360 360,510 510,600 600,1050 1080,1590
actually have to call free,|
|

96
00:02:37,760 --> 00:02:39,350
0,150 150,450 450,840 960,1500 1500,1590
you know and avoid a
可以避免一类 bug ，

97
00:02:39,350 --> 00:02:40,700
0,330 330,690 690,930 930,1170 1170,1350
class bugs,| so that's one
|这是高级语言通常具有的属性之一，

98
00:02:40,700 --> 00:02:41,750
0,90 90,210 210,750 750,900 900,1050
of the properties at a

99
00:02:41,750 --> 00:02:43,310
0,180 180,450 450,690 690,1080 1080,1560
high level language typically has,|
|

100
00:02:43,550 --> 00:02:44,360
0,240 240,390 390,510 510,750 750,810
and so we wanted to
所以，我们希望选择一种具有这种特性的语言，

101
00:02:44,360 --> 00:02:45,680
0,600 630,930 930,990 990,1230 1230,1320
have picked a language that

102
00:02:45,680 --> 00:02:47,420
0,240 240,540 780,1020 1020,1290 1290,1740
has that,| and we followed
|我们基本上遵循了传统的 Unix 结构，

103
00:02:47,420 --> 00:02:50,720
0,390 390,1200 1230,2160 2190,2640 2640,3300
basically traditional monolithic Unix organization,|
|

104
00:02:50,720 --> 00:02:51,770
0,150 150,270 270,450 450,750 750,1050
we could do a fair
我们可以做一个公平的比较。

105
00:02:51,770 --> 00:02:52,560
0,510
comparison.|
|

106
00:02:52,910 --> 00:02:54,050
0,510 510,720 720,780 780,990 990,1140
{} And in fact some
在某种程度上，你可以认为我们构建的是类似于 xv6 的东西，

107
00:02:54,050 --> 00:02:55,160
0,330 330,600 600,720 720,900 900,1110
way you could think about

108
00:02:55,160 --> 00:02:57,650
0,180 180,300 300,690 690,1410 2130,2490
what we built is something

109
00:02:57,650 --> 00:02:59,240
0,150 150,480 480,990 990,1380 1410,1590
like {xv6 -},| {} much
|功能更多，性能更高。

110
00:02:59,240 --> 00:03:02,120
0,330 330,1020 1410,1680 1680,2280 2280,2880
much more, more features and

111
00:03:02,150 --> 00:03:04,480
0,600 630,930 930,1200 1200,1920
{} more high performance.|
|

112
00:03:05,140 --> 00:03:05,980
0,150 150,330 330,420 420,570 570,840
I mean, as you know,|
我的意思是，正如你知道的，|

113
00:03:05,980 --> 00:03:07,060
0,270 270,480 480,660 660,810 810,1080
{xv6 -} has all kinds
xv6 有各种慢性算法或线性搜索、类型算法，

114
00:03:07,060 --> 00:03:10,480
0,330 780,1950 2070,2580 2580,3150 3150,3420
of {} chronic algorithms or

115
00:03:10,480 --> 00:03:12,790
0,360 360,990 1020,1410 1410,1950 1950,2310
linear search, type algorithms,| and
|当然，如果你想实现高性能，

116
00:03:12,790 --> 00:03:13,750
0,180 180,450 450,720 720,810 810,960
of course if you want

117
00:03:13,750 --> 00:03:15,010
0,270 300,600 600,750 750,1170 1170,1260
to achieve high performance,| you
|你不能有这些。

118
00:03:15,010 --> 00:03:16,240
0,210 210,390 390,780
can't have those.|
|

119
00:03:17,360 --> 00:03:18,350
0,180 180,300 300,450 450,630 630,990
And so that was the
所以，这就是论文的来源，

120
00:03:18,380 --> 00:03:20,510
0,660 840,1110 1110,1560 1590,2040 2040,2130
original, { -} {this,paper} in

121
00:03:20,510 --> 00:03:21,710
0,120 120,390 390,630 630,750 750,1200
the original,| why we built
|为什么我们构建了 Biscuit 试图回答这个问题，

122
00:03:21,740 --> 00:03:23,240
0,210 210,750 780,1170 1170,1260 1260,1500
{} Biscuit trying to answer

123
00:03:23,240 --> 00:03:24,380
0,180 180,690 690,870 870,990 990,1140
that question| or at least
|或者至少给我们一些启示。

124
00:03:24,380 --> 00:03:25,620
0,210 210,360 360,720
shed some light.|
|

125
00:03:25,650 --> 00:03:26,280
0,120 120,300 300,420 420,480 480,630
{} First, {I'm,going} to talk
首先，我要讨论一下更一般的背景，

126
00:03:26,280 --> 00:03:27,030
0,0 0,210 210,360 360,630 630,750
a little bit about sort

127
00:03:27,030 --> 00:03:28,440
0,90 90,240 240,540 540,1260 1320,1410
of more general background {},|
|

128
00:03:28,440 --> 00:03:30,090
0,0 840,960 960,1380 1410,1590 1590,1650
I got a lot of
我通过电子邮件得到很多问题，

129
00:03:30,090 --> 00:03:33,030
0,690 690,1260 1260,1680 1680,2220 2670,2940
questions over email,| we're trying
|我们正试图获得更多的背景信息，

130
00:03:33,030 --> 00:03:33,780
0,300 300,450 450,480 480,630 630,750
to get a little bit

131
00:03:33,780 --> 00:03:35,340
0,120 120,750 1050,1260 1260,1440 1440,1560
more context,| and then I
|然后我会更详细地讨论 Biscuit ，

132
00:03:35,340 --> 00:03:37,110
0,270 270,540 540,1020 1020,1410 1440,1770
will dive into {} Biscuit

133
00:03:37,110 --> 00:03:38,970
0,150 150,480 600,840 840,1290 1500,1860
in more more detail,| feel
|任何时间都可以随意提出问题，

134
00:03:38,970 --> 00:03:40,590
0,270 270,750 750,1050 1050,1470 1470,1620
free to jump in with

135
00:03:40,590 --> 00:03:41,760
0,360 360,510 510,660 660,1020 1020,1170
questions in any particular point

136
00:03:41,760 --> 00:03:43,890
0,60 60,570 780,1230 1230,1680 1680,2130
of time,| {} here as
|正如你所知道的，这篇论文的动机是你们提出的问题，

137
00:03:43,950 --> 00:03:44,980
0,120 120,240 240,600
you know this

138
00:03:44,980 --> 00:03:46,930
0,270 270,420 420,1110 1140,1590 1590,1950
paper was motivated by questions

139
00:03:46,930 --> 00:03:47,980
0,210 210,540 540,690 690,930 930,1050
you asked,| and so you
|所以，请继续问问题。

140
00:03:47,980 --> 00:03:49,660
0,240 420,720 720,1020 1020,1440 1470,1680
know please please ask keep

141
00:03:49,660 --> 00:03:50,860
0,240 240,720
asking questions.|
|

142
00:03:51,400 --> 00:03:52,780
0,630

143
00:03:52,980 --> 00:03:55,500
0,570 570,1290 1350,1500 1500,2160 2250,2520
So, {} as you can
所以，正如你可以做的那样，

144
00:03:55,500 --> 00:03:56,910
0,150 150,660 870,1110 1110,1200 1230,1410
just do,| sort of the
|这篇论文的设置是很多内核都是用 C 语言写的，

145
00:03:56,910 --> 00:03:58,110
0,330 330,420 420,570 570,960 960,1200
setting of this paper is

146
00:03:58,110 --> 00:03:59,580
0,480 480,720 720,900 900,1380 1380,1470
a lot of kernels are

147
00:03:59,580 --> 00:04:00,810
0,270 270,390 390,900 900,1140 1140,1230
written in C,| and you
|xv6 是用 C 语言写的，你使用 C 语言编写程序，

148
00:04:00,810 --> 00:04:01,740
0,120 120,360 360,600 600,690 690,930
know {xv6 -} is written

149
00:04:01,740 --> 00:04:02,790
0,90 90,360 360,510 510,960 960,1050
in C, you're programming in

150
00:04:02,790 --> 00:04:05,070
0,480 630,1170 1170,1380 1380,1830 1830,2280
C,| but most popular kernels
|你在桌面或手机上看到的大多数流行内核都是用 C 语言编写的，

151
00:04:05,070 --> 00:04:05,790
0,150 150,330 330,510 510,600 600,720
that you see on your

152
00:04:05,790 --> 00:04:08,280
0,540 540,810 810,1410 1410,1920 2010,2490
desktop or your phone are

153
00:04:08,280 --> 00:04:10,200
0,270 270,480 480,900 900,1410 1410,1920
written in C,| Windows Linux
|Windows Linux 以及所有各种形式的 BSD 。

154
00:04:10,200 --> 00:04:11,910
0,330 360,720 720,840 840,1020 1020,1710
{} Linux to all the

155
00:04:11,940 --> 00:04:14,460
0,540 600,1110 1110,1470 1470,2190
various forms of BSDs.|
|

156
00:04:14,850 --> 00:04:16,620
0,480 540,960 960,1110 1110,1200 1200,1770
And, {} and the reason
用 C 语言编写的原因是，

157
00:04:16,950 --> 00:04:19,650
0,720 870,1230 1230,1770 1800,2430 2430,2700
{} the written or written

158
00:04:19,650 --> 00:04:21,420
0,120 120,390 390,540 540,1050 1050,1770
in C is that {},|
|

159
00:04:21,990 --> 00:04:23,010
0,360 360,720 720,750 750,960 960,1020
C provides a lot of
C 提供了很多控制，正如你在实验中看到的，

160
00:04:23,010 --> 00:04:24,780
0,660 690,1080 1080,1320 1320,1590 1590,1770
control as you've seen in

161
00:04:24,780 --> 00:04:26,790
0,270 300,900 990,1230 1230,1680 1680,2010
the labs,| {} yeah, complete
|完全控制内存分配和释放，

162
00:04:26,790 --> 00:04:28,170
0,420 420,510 510,750 750,1260 1260,1380
control for memory allocation and

163
00:04:28,170 --> 00:04:30,390
0,540 810,1500 1500,1680 1680,2010 2010,2220
freeing,| {} there's almost no
|几乎没有隐式代码，

164
00:04:30,390 --> 00:04:31,680
0,420 420,900 900,990 990,1110 1110,1290
implicit code,| you know you
|你几乎可以想象，当你阅读 C 代码的时候，

165
00:04:31,680 --> 00:04:33,090
0,120 120,420 420,1050 1050,1260 1260,1410
can almost imagine when you're

166
00:04:33,090 --> 00:04:34,350
0,300 300,420 420,600 600,1050 1050,1260
reading the C code,| what
|对应的 RISC-V 指令是什么，

167
00:04:34,350 --> 00:04:36,120
0,60 60,780 780,990 990,1260 1260,1770
the corresponding {RISC-V -} instructions

168
00:04:36,120 --> 00:04:36,940
0,420
are,|
|

169
00:04:37,000 --> 00:04:38,740
0,510 510,600 600,960 960,1230 1230,1740
you have {direct,access,to -} memory,|
你可以直接访问内存，|

170
00:04:38,740 --> 00:04:39,730
0,270 270,390 390,570 570,660 660,990
you can read or write
你可以读写 PTE 位或者设备寄存器，

171
00:04:39,730 --> 00:04:40,930
0,60 60,180 180,420 420,750 750,1200
you know the PTE bits
您知道您知道的PTE位或设备的寄存器，

172
00:04:40,930 --> 00:04:42,580
0,90 90,390 390,720 720,1020 1020,1650
you know or the register

173
00:04:42,580 --> 00:04:45,460
0,240 240,780 810,1560 1830,2310 2310,2880
of a devices,| {} and
|而且 C 语言本身有很少的依赖，

174
00:04:45,460 --> 00:04:46,750
0,150 150,270 270,450 450,810 810,1290
you know C itself []

175
00:04:46,750 --> 00:04:48,880
0,390 390,930 1080,1890 1890,1980 1980,2130
very few dependencies,| you know
|你并不需要很大的运行时，

176
00:04:48,880 --> 00:04:50,170
0,210 210,360 360,660 660,1140 1140,1290
there's no large runtime that

177
00:04:50,170 --> 00:04:51,280
0,90 90,270 270,510 510,600 600,1110
you actually have to have,|
|

178
00:04:51,400 --> 00:04:52,120
0,90 90,210 210,420 420,540 540,720
to be able to run
为了能够运行 C 程序，

179
00:04:52,120 --> 00:04:52,900
0,60 60,270 270,630 630,690 690,780
a C program,| you can
|你几乎可以直接在裸硬件上运行。

180
00:04:52,900 --> 00:04:54,400
0,270 270,720 720,990 990,1380 1380,1500
almost run almost immediately on

181
00:04:54,400 --> 00:04:56,260
0,330 330,1110 1110,1470
bare {hareware -}.|
|

182
00:04:56,260 --> 00:04:57,610
0,180 180,420 420,570 570,930 930,1350
And you've seen that once
你已经看到一旦 xv6 启动，

183
00:04:57,610 --> 00:04:58,750
0,270 270,510 510,930 930,1020 1020,1140
{xv6 -} boots,| you know
|先是几行汇编代码，

184
00:04:58,750 --> 00:04:59,650
0,120 120,450 450,480 480,690 690,900
it's basically a few lines

185
00:04:59,650 --> 00:05:00,940
0,90 90,660 660,750 750,900 900,1290
of assembly| and then basically
|然后你就是在运行 C 代码。

186
00:05:00,940 --> 00:05:02,340
0,120 120,390 390,570 570,960
you're running C code.|
|

187
00:05:02,780 --> 00:05:04,400
0,510 810,1140 1140,1290 1290,1470 1470,1620
{} But there are all
但是这些都是 C 语言优点，

188
00:05:04,400 --> 00:05:06,860
0,540 570,780 780,1440 1470,1770 1800,2460
the good virtues of C|
|

189
00:05:06,860 --> 00:05:07,850
0,300 300,480 480,750 750,840 840,990
and one reason that we
也是我们非常喜欢 C 的一个原因。

190
00:05:07,850 --> 00:05:08,660
0,180 180,240 240,360 360,420 420,810
like {} C a lot.|
|

191
00:05:09,230 --> 00:05:10,910
0,630 630,840 840,1200 1200,1560 1560,1680
{} But C also has
但是 C 也有一些缺点，

192
00:05:10,910 --> 00:05:13,430
0,120 120,900 1170,1860 2070,2340 2340,2520
some downsides,| you know it
|在过去的几十年里已经被证明了，

193
00:05:13,430 --> 00:05:14,600
0,270 270,480 480,840 840,1080 1080,1170
has been proven over the

194
00:05:14,600 --> 00:05:17,030
0,510 720,810 810,1590 1740,2160 2160,2430
last few decades,| that writing
|写安全的 C 代码很难，

195
00:05:17,030 --> 00:05:19,340
0,540 540,810 810,900 900,1560 1650,2310
{security,C} code is difficult {},|
|

196
00:05:19,340 --> 00:05:20,000
0,120 120,210 210,360 360,390 390,660
you know there are types
有几种类型的 bug ，经常会被利用，

197
00:05:20,000 --> 00:05:22,820
0,120 120,660 810,1410 1410,2430 2460,2820
of bugs that can, you

198
00:05:23,270 --> 00:05:26,030
0,720 870,1380 1380,1500 1500,2190 2220,2760
can often be exploited {}|
|

199
00:05:26,030 --> 00:05:27,470
0,300 300,390 390,540 540,900 900,1440
whether it is buffer overruns,|
无论是缓冲区溢出，|

200
00:05:27,470 --> 00:05:28,340
0,240 240,330 330,600 600,660 660,870
which are probably the most
这可能是在过去最广为人知的问题，

201
00:05:28,340 --> 00:05:30,140
0,390 390,630 630,1020 1020,1350 1350,1800
well-known one you're writing behind

202
00:05:30,140 --> 00:05:31,280
0,210 210,810
the past,|
|

203
00:05:31,450 --> 00:05:33,430
0,570 570,720 720,1140 1140,1590 1590,1980
{} an array bound or
一个数组绑定，或者你正在堆下面写，

204
00:05:33,430 --> 00:05:35,020
0,180 180,660 660,780 780,930 930,1590
you're writing you know below

205
00:05:35,020 --> 00:05:37,570
0,390 390,960 1320,1980 2070,2310 2310,2550
your stack,| {} {use-after-free -
|use-after-free bug ，你释放了内存，但是它仍在使用，

206
00:05:37,570 --> 00:05:39,010
0,210 210,720 720,840 840,1320 1320,1440
-} bugs, {you,know} where you

207
00:05:39,010 --> 00:05:40,840
0,180 180,660 870,1110 1110,1200 1200,1830
know the free of memory,

208
00:05:40,870 --> 00:05:42,640
0,690 690,810 810,1020 1020,1140 1140,1770
but it's still in use,|
|

209
00:05:43,140 --> 00:05:44,190
0,330 330,510 510,630 630,780 780,1050
{} and so when somebody
所以当有人在上面乱写的时候，

210
00:05:44,190 --> 00:05:46,140
0,390 390,570 570,870 870,1380 1380,1950
scribbles on it| and {you,know}
|在上面乱写一些不好的东西，

211
00:05:46,170 --> 00:05:47,460
0,420 420,630 630,930 930,1080 1080,1290
scribble something bad on it,|
|

212
00:05:47,580 --> 00:05:49,800
0,1110 1110,1560 1560,2010 2010,2100 2100,2220
{} and generally you know
通常情况下，线程共享内存时，

213
00:05:49,800 --> 00:05:51,840
0,540 600,1350 1380,1650 1650,1710 1710,2040
when {} threads are sharing

214
00:05:51,840 --> 00:05:53,520
0,600 600,870 870,1230 1230,1620 1620,1680
memory| is typically difficult to
|很难决定哪些内存可以释放。

215
00:05:53,520 --> 00:05:54,810
0,570 570,660 660,750 750,1020 1020,1290
decide you know what actually

216
00:05:54,810 --> 00:05:56,260
0,270 270,390 390,540 540,960
memory can be freed.|
|

217
00:05:56,940 --> 00:05:58,050
0,300 300,360 360,540 540,1020 1020,1110
Some of these bugs, {you,know}
有些 bug ，并不会真的出现在那里，

218
00:05:58,050 --> 00:05:59,670
0,390 390,720 720,990 990,1140 1140,1620
don't really show up that,|
|

219
00:05:59,940 --> 00:06:01,020
0,600 600,720 720,810 810,990 990,1080
{} you know some of
一些 bug 明确地体现在 xv6 中，一些较少，

220
00:06:01,020 --> 00:06:02,970
0,90 90,360 360,840 840,1350 1350,1950
the bug manifest itself explicitly

221
00:06:02,970 --> 00:06:04,560
0,210 210,690 690,990 990,1230 1230,1590
{xv6 -}, some less,| so
|xv6 的动态内存分配非常少，

222
00:06:04,560 --> 00:06:06,330
0,120 120,420 690,1350 1350,1440 1440,1770
you know, {} you know

223
00:06:06,390 --> 00:06:08,190
0,210 210,600 600,840 840,1140 1140,1800
{xv6 -} very little dynamic

224
00:06:08,220 --> 00:06:10,080
0,480 480,1140 1140,1350 1350,1650 1650,1860
memory allocation,| you're almost after
|你几乎是已经预先分配好了，

225
00:06:10,080 --> 00:06:11,220
0,210 210,390 390,450 450,630 630,1140
being sort of pre allocated

226
00:06:11,220 --> 00:06:12,260
0,150 150,270 270,600
[right up front],|
|

227
00:06:12,260 --> 00:06:13,970
0,390 390,870 870,1320 1320,1620 1620,1710
a buffer overruns usually have
缓冲区溢出通常会出现释放 bug 。

228
00:06:13,970 --> 00:06:16,340
0,270 270,570 570,1200 1860,2100 2100,2370
free bugs {} do show

229
00:06:16,340 --> 00:06:17,120
0,240
up.|
|

230
00:06:17,440 --> 00:06:19,600
0,540 870,1500 1590,1770 1770,1950 1950,2160
{} So, {} in fact
事实上，如果你看一看 CVEs ，

231
00:06:19,600 --> 00:06:20,590
0,180 180,270 270,390 390,600 600,990
{you,know} if you look at

232
00:06:20,620 --> 00:06:23,110
0,750 1110,1920 2010,2130 2130,2280 2280,2490
{} CVEs,| you know these
|有一个网站，

233
00:06:23,110 --> 00:06:24,760
0,210 210,1230 1230,1290 1290,1440 1440,1650
are {} you know there's

234
00:06:24,760 --> 00:06:25,840
0,60 60,600 600,840 840,1020 1020,1080
a website| where there's an
|有一个组织保持控制，

235
00:06:25,840 --> 00:06:28,000
0,630 630,1020 1020,1410 1410,1950 1950,2160
organization that keeps control,| that
|检查和记录所有安全漏洞，

236
00:06:28,000 --> 00:06:30,130
0,420 420,990 1380,1680 1680,1770 1770,2130
checks and keeps a record

237
00:06:30,130 --> 00:06:31,420
0,150 150,420 480,660 660,840 840,1290
of all of the security

238
00:06:31,420 --> 00:06:34,210
0,690 930,1410 1410,2070 2070,2340 2340,2790
exploits,| and investigate that you'll
|调查一下，你会发现，在 2017 年我们做这篇论文的时候，

239
00:06:34,210 --> 00:06:35,920
0,210 210,330 330,420 420,1560 1560,1710
find that in {2017,when} we

240
00:06:35,920 --> 00:06:37,030
0,90 90,270 270,420 420,810 810,1110
were doing this paper,| that
|有 40 个 Linux 内核 bug ，

241
00:06:37,210 --> 00:06:39,190
0,420 420,570 570,960 960,1680 1680,1980
{} there were 40 Linux

242
00:06:39,190 --> 00:06:42,040
0,750 1050,2190 2190,2340 2340,2460 2460,2850
kernel bugs,| that can actually
|会导致攻击者完全控制机器。

243
00:06:42,040 --> 00:06:45,130
0,390 390,1050 1050,2040 2040,2490 2490,3090
lead to an attacker running

244
00:06:45,130 --> 00:06:47,470
0,900 1140,1530 1530,1860 1860,2220 2220,2340
{} take complete control over

245
00:06:47,470 --> 00:06:48,260
0,60 60,480
the machine.|
|

246
00:06:48,570 --> 00:06:49,620
0,540 540,630 630,750 750,990 990,1050
Clearly, you know those are
显然，那些是严重的 bug ，

247
00:06:49,620 --> 00:06:51,180
0,300 300,600 600,720 720,1290 1290,1560
serious bugs| and those bugs
|这些 bug 来自于缓冲区溢出，

248
00:06:51,180 --> 00:06:52,740
0,300 300,450 450,540 540,840 840,1560
came out of buffer overruns|
|

249
00:06:52,890 --> 00:06:54,960
0,690 690,1170 1170,1410 1410,1650 1650,2070
and other types of memory
以及其他类型的内存安全 bug 。

250
00:06:54,960 --> 00:06:56,360
0,420 420,900
safety bugs.|
|

251
00:06:56,720 --> 00:06:59,240
0,480 810,1320 1590,1770 1770,2280 2370,2520
{} So you know it's
所以这太糟糕了，

252
00:06:59,240 --> 00:07:00,110
0,120 120,210 210,330 330,750 780,870
sort of too bad,| you
|如果你用 C 语言写代码，

253
00:07:00,110 --> 00:07:01,190
0,150 150,480 480,750 750,870 870,1080
know that if you write

254
00:07:01,190 --> 00:07:02,090
0,240 240,330 330,660 660,750 750,900
code in C,| you know
|很难做到，

255
00:07:02,090 --> 00:07:03,530
0,180 180,480 480,540 540,960 960,1440
that actually is hard,| even
|即使是专业人士也很难做到这一点。

256
00:07:03,620 --> 00:07:04,730
0,150 150,420 420,570 570,960 960,1110
for people that do that

257
00:07:04,730 --> 00:07:07,010
0,690 690,1740 1770,1920 1920,2130 2130,2280
professionally and to actually get

258
00:07:07,010 --> 00:07:08,580
0,270 270,1050
this right.|
|

259
00:07:08,730 --> 00:07:09,840
0,390 390,720 720,810 810,1020 1020,1110
{} And of course you
当然，我相信你在实验里见过这个，

260
00:07:09,840 --> 00:07:10,890
0,420 450,600 600,780 780,900 900,1050
know, I'm sure you've seen

261
00:07:10,890 --> 00:07:11,640
0,120 120,210 210,270 270,690 690,750
this in the lab,| you
|也许，我记得在 Piazza 上的一些问题，

262
00:07:11,640 --> 00:07:14,670
0,450 480,870 1980,2340 2340,2700 2700,3030
know probably certainly I remember

263
00:07:14,670 --> 00:07:15,810
0,270 270,450 450,540 540,990 990,1140
from some of the the

264
00:07:15,810 --> 00:07:17,040
0,330 330,780 780,870 870,990 990,1230
Piazza questions,| you know the
|你们遇到 use-after-free bug 的次数，

265
00:07:17,040 --> 00:07:17,940
0,180 180,300 300,480 480,690 690,900
number if you run into

266
00:07:17,940 --> 00:07:19,320
0,420 420,660 660,870 870,1260 1260,1380
{use-after-free - -} bugs,| you
|特别是在写入时复制实验里，

267
00:07:19,320 --> 00:07:20,550
0,300 300,390 390,900 900,1020 1020,1230
know in particular in the

268
00:07:20,550 --> 00:07:22,770
0,690 690,1140 1380,1830 1830,1920 1920,2220
copy-on-write lab,| {} they showed
|它们出现了很多次。

269
00:07:22,770 --> 00:07:23,760
0,120 120,150 150,390 390,450 450,990
up a bunch of times.|
|

270
00:07:25,530 --> 00:07:27,270
0,510 840,1140 1140,1290 1290,1500 1500,1740
So yeah so, one reason
所以，高级语言吸引人的一个原因是，

271
00:07:27,270 --> 00:07:28,350
0,120 120,180 180,540 540,930 930,1080
that a high-level language would

272
00:07:28,350 --> 00:07:30,660
0,90 90,900 990,1290 1290,1890 1890,2310
be attractive {} is that,|
|

273
00:07:30,690 --> 00:07:32,370
0,300 300,660 660,990 990,1140 1140,1680
a high-level language that provides
高级语言提供了内存安全，

274
00:07:32,370 --> 00:07:34,740
0,270 270,870 990,1440 1440,2070 2160,2370
memory safety,| {} and so
|所以，所有 CVE 披露的 bug ，

275
00:07:34,740 --> 00:07:35,940
0,270 270,540 540,900 900,990 990,1200
all these bugs that {CVE

276
00:07:35,940 --> 00:07:37,890
0,690 690,1230 1230,1590 1590,1620 1620,1950
-} exploits| that I mentioned
|我在上一张幻灯片中提到的，

277
00:07:37,890 --> 00:07:39,330
0,90 90,150 150,420 420,780 900,1440
on the previous slide| would
|将会是不可能的，

278
00:07:39,330 --> 00:07:40,830
0,270 270,870 870,1200 1200,1380 1380,1500
not be would not be

279
00:07:40,830 --> 00:07:42,390
0,660 690,810 810,1110 1110,1470 1470,1560
possible,| {you,know} could use you
|如果它们发生了，

280
00:07:42,390 --> 00:07:43,740
0,90 90,510 540,720 720,840 840,1350
know they if they happen,|
|

281
00:07:43,830 --> 00:07:45,090
0,330 330,660 660,870 870,1200 1200,1260
they either would result in
它们要么会导致 panic ，

282
00:07:45,090 --> 00:07:46,500
0,60 60,570 600,810 810,930 930,1410
a panic,| you know, because
|因为运行时会说，

283
00:07:46,500 --> 00:07:47,670
0,90 90,210 210,420 420,870 870,1170
you know the runtime which

284
00:07:48,080 --> 00:07:48,890
0,120 120,330 330,510 510,690 690,810
would say,| like, oh you're
|你要写的东西已经不在了，你不能那样做，

285
00:07:48,890 --> 00:07:49,940
0,240 240,570 570,750 750,870 870,1050
writing passed away, you can't

286
00:07:49,940 --> 00:07:51,770
0,120 120,510 720,1290 1290,1710 1710,1830
do that,| {} or you
|或者根本不能表现出来，

287
00:07:51,770 --> 00:07:54,140
0,210 210,450 450,900 1380,1920 1920,2370
know you just couldn't manifest

288
00:07:54,140 --> 00:07:55,910
0,390 390,480 480,960 990,1680 1680,1770
itself at all,| because the
|因为语言不会允许你编写这样的代码。

289
00:07:55,910 --> 00:07:57,020
0,330 330,540 540,900 900,1020 1020,1110
language wouldn't allow you to

290
00:07:57,020 --> 00:07:58,010
0,180 180,330 330,480 480,540 540,990
write that kind of code.|
|

291
00:08:00,800 --> 00:08:01,340
0,180 180,300 300,330 330,390 390,540
So there are of course
高级语言当然还有其他好处，

292
00:08:01,340 --> 00:08:02,960
0,210 210,840 870,1170 1170,1260 1260,1620
other benefits to a high-level

293
00:08:02,960 --> 00:08:04,550
0,600 690,1170 1170,1260 1260,1350 1350,1590
language,| {} you know which
|这门课上的学生也经常提到，

294
00:08:04,550 --> 00:08:05,900
0,300 300,420 420,660 660,1080 1080,1350
often is also mentioned you

295
00:08:05,900 --> 00:08:09,020
0,270 270,1260 1290,1410 1410,1950 2760,3120
know by you know students

296
00:08:09,020 --> 00:08:10,280
0,60 60,180 180,690 720,1170 1170,1260
in this class,| when they're
|当他们在做实验时，

297
00:08:10,280 --> 00:08:11,780
0,210 210,750 750,990 990,1260 1260,1500
doing labs,| in {addition,to} type
|除了类型安全，

298
00:08:11,780 --> 00:08:13,220
0,570 570,660 660,780 780,1020 1020,1440
safety,| you know there's automatic
|还有具有垃圾收集器的自动内存管理，

299
00:08:13,220 --> 00:08:14,990
0,270 270,660 660,780 780,1170 1170,1770
memory management with garbage collector,|
|

300
00:08:15,320 --> 00:08:16,850
0,330 330,570 570,900 900,1080 1080,1530
{} so freeing is easy,|
所以释放是很简单的，|

301
00:08:16,850 --> 00:08:17,450
0,120 120,210 210,420 420,540 540,600
{} you don't have to
你不用考虑它，

302
00:08:17,450 --> 00:08:18,440
0,180 180,450 450,630 630,690 690,990
think about it,| the garbage
|垃圾收集器会帮你做所有的工作，

303
00:08:18,440 --> 00:08:19,280
0,240 240,420 420,570 570,630 630,840
collector does all the work

304
00:08:19,280 --> 00:08:21,350
0,240 240,570 690,1650 1650,1890 1890,2070
for you,| {} it's good
|它对并发性有好处，

305
00:08:21,350 --> 00:08:22,760
0,120 120,780 780,1080 1080,1260 1260,1410
for concurrency,| {you,know,it} has good
|它有很好的抽象性，

306
00:08:22,760 --> 00:08:24,740
0,930 960,1140 1140,1380 1380,1650 1650,1980
abstractions,| you know it's like
|比如 Go 它的接口或其他一些类或其他形式的，

307
00:08:24,740 --> 00:08:26,810
0,330 330,900 900,1680 1680,1920 1920,2070
Go its interfaces or some

308
00:08:26,810 --> 00:08:28,460
0,540 540,1110 1110,1260 1260,1410 1410,1650
other classes or some other

309
00:08:28,460 --> 00:08:31,160
0,360 360,630 810,1080 1080,1500 2280,2700
form of,| you know forces
|这会鼓励你编写模块化代码。

310
00:08:31,160 --> 00:08:32,300
0,210 210,390 390,780 780,960 960,1140
you or encourage you to

311
00:08:32,300 --> 00:08:33,940
0,300 300,540 540,990 990,1410
actually write modular code.|
|

312
00:08:34,770 --> 00:08:35,960
0,630

313
00:08:36,620 --> 00:08:38,090
0,120 120,990 1020,1200 1200,1350 1350,1470
The downsides and you might
不好的一面，你可能会想，

314
00:08:38,090 --> 00:08:39,230
0,90 90,450 450,630 630,630 630,1140
be wondering like,| oh if
|如果高级语言有这么多好处，

315
00:08:39,230 --> 00:08:40,310
0,330 330,420 420,600 600,990 990,1080
there's so many upsides to

316
00:08:40,310 --> 00:08:42,470
0,390 390,1050 1050,1200 1200,1500 1830,2160
high-level languages,| you know why
|为什么不，

317
00:08:42,470 --> 00:08:43,640
0,510 510,600 600,720 720,1020 1020,1170
not,| you know why is
|为什么 xv6 不是用 Java Go Python 或其他什么来写，

318
00:08:43,640 --> 00:08:45,110
0,300 300,570 570,780 780,1080 1080,1470
{xv6 -} not written in

319
00:08:45,110 --> 00:08:46,910
0,90 90,240 240,870 870,1320 1320,1800
you know Java Go Python

320
00:08:46,910 --> 00:08:48,530
0,90 90,630 990,1380 1380,1560 1560,1620
or whatever,| {} and the
|原因是， Linux ，

321
00:08:48,530 --> 00:08:50,120
0,300 300,750 750,840 840,1050 1050,1590
reason is you know the

322
00:08:50,150 --> 00:08:51,350
0,150 150,660 660,750 750,930 930,1200
or Linux,| you know the
|原因是它的性能很差，

323
00:08:51,350 --> 00:08:53,000
0,270 270,390 390,750 750,1020 1020,1650
reason is there's poor performance,|
|

324
00:08:53,000 --> 00:08:54,650
0,120 120,270 270,870 870,900 900,1650
you know there's a cost
高级语言是要付出代价的，

325
00:08:54,650 --> 00:08:56,600
0,330 330,780 780,1080 1080,1530 1530,1950
to actually a high-level language,|
|

326
00:08:56,600 --> 00:08:57,740
0,420 420,570 570,660 660,990 990,1140
sometimes this is referred to
有时这被称为高级语言税。

327
00:08:57,740 --> 00:08:59,780
0,150 150,360 450,1020 1020,1410 1410,2040
as the high-level language tax.|
|

328
00:09:00,240 --> 00:09:01,650
0,540 540,930 930,1110 1110,1200 1200,1410
{} And you know these
这些是，如果你做一个数组界限，数组索引，

329
00:09:01,650 --> 00:09:03,090
0,180 180,630 630,780 780,1140 1320,1440
are basically you know if

330
00:09:03,090 --> 00:09:04,350
0,90 90,270 270,360 360,690 690,1260
you do an array bounds,

331
00:09:04,440 --> 00:09:05,850
0,480 480,1020 1020,1080 1080,1230 1230,1410
array index,| you know you
|你必须检查边界，

332
00:09:05,850 --> 00:09:07,230
0,150 150,480 480,720 720,810 810,1380
have to check the bounds,|
|

333
00:09:07,230 --> 00:09:08,010
0,120 120,420 420,510 510,660 660,780
you know you have to
你必须检查空指针，

334
00:09:08,010 --> 00:09:10,060
0,240 240,420 420,1050
check {nil-pointers -},|
|

335
00:09:10,060 --> 00:09:12,670
0,930 930,1890 1890,2160 2160,2250 2250,2610
{ -} and they have
它们有更昂贵的转换，

336
00:09:12,670 --> 00:09:15,370
0,360 360,720 720,1350 1590,2340 2340,2700
more expensive cast,| {} and
|垃圾收集也不是免费的，

337
00:09:15,370 --> 00:09:16,510
0,90 90,210 210,480 480,780 780,1140
you know garbage collection itself

338
00:09:16,510 --> 00:09:17,350
0,60 60,270 270,480 480,750 780,840
is also not free,| you
|要花几个周期来追踪，

339
00:09:17,350 --> 00:09:18,250
0,180 180,390 390,540 540,630 630,900
know there's gonna be some

340
00:09:18,250 --> 00:09:20,530
0,510 510,1050 1110,1680 1680,2010 2010,2280
cycles spent tracking down| which
|哪些对象是空闲的，哪些是分配的，这是也是损失。

341
00:09:20,530 --> 00:09:21,730
0,450 450,570 570,840 840,1110 1110,1200
objects are free, which are

342
00:09:21,730 --> 00:09:23,200
0,540 540,840 840,900 900,1050 1050,1470
allocated, then you know that's

343
00:09:23,200 --> 00:09:24,140
0,60 60,540
a cost.|
|

344
00:09:26,640 --> 00:09:27,600
0,90 90,450 450,570 570,690 690,960
So that's you know from
所以这是从性能方面，

345
00:09:27,600 --> 00:09:29,070
0,60 60,570 570,1020 1050,1320 1440,1470
the performance side| and a
|很多论文都集中在这一点。

346
00:09:29,070 --> 00:09:30,270
0,300 300,390 390,450 450,750 750,1200
lot of the paper focuses

347
00:09:30,270 --> 00:09:31,440
0,180 180,570 660,900 900,1020 1020,1170
on this.| {} And then
|然后原则上，我的意思是，

348
00:09:31,440 --> 00:09:33,000
0,90 90,780 780,840 840,960 960,1560
in principle you know often

349
00:09:33,000 --> 00:09:34,740
0,60 60,870 900,1110 1110,1620 1620,1740
I mean| it's perceived as
|它被认为是与 Linux 内核编程的不兼容，

350
00:09:34,740 --> 00:09:36,240
0,60 60,300 300,360 360,1260 1260,1500
a sort of incompatibility with

351
00:09:36,240 --> 00:09:38,240
0,450 660,990 990,1500
Linux kernel programming,|
|

352
00:09:38,360 --> 00:09:40,160
0,540 540,900 900,1230 1230,1500 1500,1800
{} {you,know} no direct memory
没有直接的内存访问，

353
00:09:40,160 --> 00:09:41,300
0,570 570,660 660,780 780,1020 1020,1140
access,| you know, because the
|因为原则可能知道违反了类型安全，

354
00:09:41,390 --> 00:09:43,940
0,420 420,630 630,1140 1140,1800 1800,2550
principal could know a violate

355
00:09:43,970 --> 00:09:47,090
0,330 330,960 1410,2040 2040,2490 2490,3120
type safety,| no hand-written assembly|
|没有手写汇编语言，|

356
00:09:47,090 --> 00:09:48,290
0,210 210,300 300,450 450,780 780,1200
and you need some hand-written
你需要在内核中使用一些手写汇编语言，

357
00:09:48,290 --> 00:09:49,970
0,450 450,540 540,600 600,1140 1140,1680
assembly in the kernel,| whereas
|在两个线程之间的上下文切换，

358
00:09:49,970 --> 00:09:51,350
0,180 180,600 600,840 840,1230 1230,1380
the context switch between two

359
00:09:51,350 --> 00:09:52,970
0,570 570,1050 1170,1320 1320,1470 1470,1620
threads| or to get off
|或者在机器启动时顺利开始，

360
00:09:52,970 --> 00:09:54,140
0,90 90,540 540,750 750,840 840,1170
the ground when the machine

361
00:09:54,140 --> 00:09:55,060
0,510
boots,|
|

362
00:09:55,320 --> 00:09:58,140
0,630 630,1350 1530,2280
{} in {
通常情况下，

363
00:09:58,690 --> 00:10:00,790
0,630 630,780 780,870 870,1260 1260,2100
-} you know often, {}|
|

364
00:10:00,880 --> 00:10:02,500
0,120 120,300 300,600 840,1410 1410,1620
you know the language may
语言可能有一个特定的并发或并行的计划，

365
00:10:02,500 --> 00:10:04,630
0,300 300,360 360,870 870,1410 1410,2130
have a particular plan for

366
00:10:04,720 --> 00:10:06,580
0,240 240,990 990,1170 1170,1740 1740,1860
{concurrency -} or parallelism| that
|可能与内核需要的并发并行不一致，

367
00:10:06,580 --> 00:10:08,080
0,150 150,330 330,630 630,960 990,1500
might not line up with

368
00:10:08,080 --> 00:10:10,120
0,540 570,990 990,1260 1290,1620 1680,2040
the plan that the kernel

369
00:10:10,120 --> 00:10:12,160
0,300 300,840 840,1080 1080,1650 1650,2040
needs work concurrency parallelism,| we've
|我们已经看到，比如在调度课程中，

370
00:10:12,160 --> 00:10:14,500
0,240 240,300 300,720 720,1140 1590,2340
seen for example and a

371
00:10:14,500 --> 00:10:17,800
0,480 480,1230 1230,1350 1350,1680 2850,3300
scheduling lecture,| you know one
|一个线程将锁传递给另一个线程，

372
00:10:17,800 --> 00:10:18,940
0,270 270,660 660,720 720,1020 1020,1140
thread passes a lock to

373
00:10:18,940 --> 00:10:20,230
0,270 270,630 630,1080 1080,1170 1170,1290
another thread,| where you know
|有几种并发管理的模式，

374
00:10:20,230 --> 00:10:21,550
0,270 270,570 570,1110 1110,1200 1200,1320
there's a couple you know

375
00:10:21,550 --> 00:10:23,350
0,180 180,720 720,900 900,1380 1380,1800
there's patterns of concurrency management|
|

376
00:10:23,350 --> 00:10:24,460
0,120 120,180 180,360 360,450 450,1110
that are sort of unusual
这些都是不普通或普通的程序，

377
00:10:24,460 --> 00:10:25,480
0,120 120,360 360,810 810,930 930,1020
and usual programs,| but they
|但它们确实出现在内核中。

378
00:10:25,480 --> 00:10:26,700
0,150 150,390 390,570 570,840
do show up in,

379
00:10:26,730 --> 00:10:28,200
0,270 270,420 420,960
{} in kernels.|
|

380
00:10:28,580 --> 00:10:31,720
0,540 1140,1860 1980,2580
{} So, {}
所以，这个论文的目标是，

381
00:10:32,200 --> 00:10:33,550
0,210 210,330 330,840 840,1260 1260,1350
so the goal basically of

382
00:10:33,550 --> 00:10:35,440
0,390 390,480 480,900 900,1260 1290,1890
this you know {} paper

383
00:10:35,440 --> 00:10:36,460
0,240 240,360 360,510 510,570 570,1020
was| to sort of measure
|衡量高级语言的权衡，

384
00:10:36,460 --> 00:10:39,130
0,210 210,750 840,1530 1530,2100 2250,2670
the high-level language trade-offs,| explore
|探索使用高级语言代替 C 语言的总体效果，

385
00:10:39,130 --> 00:10:40,120
0,60 60,390 390,660 660,750 750,990
the total effects of using

386
00:10:40,120 --> 00:10:41,440
0,360 360,600 600,870 870,960 960,1320
high-level language instead of C,|
|

387
00:10:41,470 --> 00:10:42,250
0,60 60,150 150,450 450,510 510,780
you know both in terms
不仅是在安全编程能力方面，

388
00:10:42,250 --> 00:10:44,920
0,240 690,1170 1170,1710 1710,2040 2040,2670
of a safety program ability,|
|

389
00:10:44,950 --> 00:10:46,870
0,570 570,810 810,960 960,1380 1380,1920
but also for performance cost.|
而且在性能成本方面。|

390
00:10:47,200 --> 00:10:47,860
0,120 120,180 180,450 450,540 540,660
And of course if you'd
当然，如果你想做这个实验，

391
00:10:47,860 --> 00:10:49,000
0,150 150,240 240,450 450,810 810,1140
like to do this, this

392
00:10:49,000 --> 00:10:50,080
0,150 150,270 270,870 870,990 990,1080
kind of experiment,| you know
|你需要做那种生产级的内核，

393
00:10:50,080 --> 00:10:50,980
0,330 330,510 510,570 570,690 690,900
you need to do that

394
00:10:50,980 --> 00:10:52,030
0,120 120,180 180,360 360,780 780,1050
sort of a production grade

395
00:10:52,030 --> 00:10:52,960
0,360 360,450 450,660 660,780 780,930
kernel,| you can't do that
|你不能在 xv6 上做到这一点，

396
00:10:52,960 --> 00:10:54,340
0,120 120,780 780,1020 1020,1170 1170,1380
on xv6,| because it's so
|因为它太慢了，你可能什么都学不到，

397
00:10:54,340 --> 00:10:55,570
0,330 330,510 510,840 840,930 930,1230
slow that basically you probably

398
00:10:55,570 --> 00:10:56,920
0,180 180,450 450,870 900,1050 1050,1350
won't learn anything,| you know
|这是一个用 C 语言写得很慢的程序，

399
00:10:57,400 --> 00:10:58,300
0,150 150,240 240,600 600,690 690,900
it's a program that was

400
00:10:58,300 --> 00:10:59,830
0,270 270,570 570,660 660,1020 1020,1530
written slow in C,| you're
|你用 Go 也写得很慢，

401
00:10:59,830 --> 00:11:01,900
0,150 150,810 1020,1590 1590,1950 1950,2070
written slow in Go,| you
|这并不能告诉你很多关于 C 对 Go 的问题，

402
00:11:01,900 --> 00:11:02,740
0,120 120,330 330,510 510,750 750,840
know doesn't really tell you

403
00:11:02,740 --> 00:11:04,150
0,390 420,840 840,960 960,1200 1200,1410
much about you know the

404
00:11:04,150 --> 00:11:05,470
0,480 480,690 690,1080 1080,1140 1140,1320
{C,versus} Go question,| it just
|它只是说 xv6 很慢。

405
00:11:05,470 --> 00:11:06,610
0,270 270,420 420,660 660,870 870,1140
says like well {xv6 -}

406
00:11:06,610 --> 00:11:07,360
0,330
slow.|
|

407
00:11:07,560 --> 00:11:08,760
0,270 270,480 480,660 660,1140 1140,1200
And so you want to
所以你想要在一个更高性能的内核，

408
00:11:08,760 --> 00:11:09,930
0,150 150,390 390,480 480,600 600,1170
do that in a more

409
00:11:10,260 --> 00:11:12,150
0,240 240,990 990,1080 1080,1350 1350,1890
high performance you know oriented

410
00:11:12,150 --> 00:11:13,680
0,420 540,750 750,1050 1050,1350 1350,1530
kernel| or the kernel was
|或者内核是为高性能而设计的。

411
00:11:13,680 --> 00:11:15,500
0,390 390,570 570,720 720,1380
designed for high performance.|
|

412
00:11:17,600 --> 00:11:18,620
0,180 180,300 300,870 870,960 960,1020
And so you're you know
所以你知道有一件事是令人惊讶的，

413
00:11:18,620 --> 00:11:19,160
0,150 150,240 240,300 300,450 450,540
one of the things that

414
00:11:19,160 --> 00:11:20,360
0,30 30,540 540,840 840,1020 1020,1200
are surprising,| because like many
|因为你们中的许多人问到这个，

415
00:11:20,360 --> 00:11:22,850
0,90 90,540 570,990 990,1350 1350,2490
of you ask this {}

416
00:11:23,060 --> 00:11:25,550
0,570 570,870 870,1200 1200,1830 1830,2490
[] ask this| and I
|我想这个问题一定会在文献中得到回答，

417
00:11:26,720 --> 00:11:27,950
0,210 210,540 540,690 690,900 900,1230
would imagine well this question

418
00:11:27,950 --> 00:11:28,760
0,180 180,300 300,630 630,720 720,810
must be answered in the

419
00:11:28,760 --> 00:11:30,350
0,540 720,1170 1170,1290 1290,1410 1410,1590
literature,| and you know it
|事实证明这并不是，

420
00:11:30,350 --> 00:11:31,430
0,210 210,330 330,450 450,750 750,1080
turns out that actually isn't,|
|

421
00:11:31,490 --> 00:11:33,410
0,510 510,750 750,1260 1290,1530 1530,1920
{} it is there's quite
有很多的研究这个问题，

422
00:11:33,410 --> 00:11:34,490
0,30 30,240 240,330 330,840 840,1080
a number of studies that

423
00:11:34,610 --> 00:11:36,770
0,390 390,1320 1380,1590 1590,1980 1980,2160
look into the question| of
|关于高级语言在用户程序中的权衡的问题，

424
00:11:36,770 --> 00:11:38,690
0,390 390,840 840,1140 1140,1710 1710,1920
{} high-level language trade-offs in

425
00:11:38,690 --> 00:11:40,040
0,60 60,420 420,510 510,720 720,1350
the context of user programs,|
|

426
00:11:40,510 --> 00:11:43,000
0,720 720,1260 1620,2100 2100,2370 2370,2490
{} and, {} but you
但是内核和用户程序有很大的不同，

427
00:11:43,000 --> 00:11:43,690
0,180 180,270 270,390 390,600 600,690
know as you know the

428
00:11:43,690 --> 00:11:44,950
0,270 270,390 420,990 990,1020 1020,1260
kernel is quite a bit

429
00:11:44,950 --> 00:11:47,110
0,510 510,660 660,900 900,1560 2040,2160
different from user programs,| for
|比如仔细的内存管理是非常重要的，

430
00:11:47,110 --> 00:11:49,000
0,330 330,630 630,1110 1110,1380 1380,1890
example memory management, careful {memory,management}

431
00:11:49,000 --> 00:11:50,860
0,90 90,330 330,990 1440,1590 1590,1860
is really important,| this different
|这种不同类型的并发性可能略有不同，

432
00:11:50,860 --> 00:11:51,940
0,210 210,270 270,870 870,1020 1020,1080
types of concurrency may be

433
00:11:51,940 --> 00:11:53,680
0,330 330,780 930,1170 1170,1440 1440,1740
slightly different,| so we want
|所以我们想在内核中做这件事。

434
00:11:53,680 --> 00:11:54,520
0,390 390,600 600,690 690,780 780,840
to do it in the

435
00:11:54,520 --> 00:11:56,000
0,450 450,540 540,600 600,1050
context of a kernel.|
|

436
00:11:56,310 --> 00:11:57,750
0,330 330,720 720,870 870,1170 1170,1440
And we don't actually really
我们没有找到任何论文真正回答这个问题，

437
00:11:57,750 --> 00:11:58,890
0,240 240,540 540,720 720,780 780,1140
find any sort of papers

438
00:11:58,890 --> 00:12:00,880
0,270 270,750 750,870 870,1410
really answer this question,|
|

439
00:12:00,880 --> 00:12:01,750
0,180 180,300 300,660 660,750 750,870
{} the closer you could
你能接近的是，

440
00:12:01,750 --> 00:12:03,130
0,270 270,570 570,870 870,1230 1230,1380
come to is,| there you
|有很多内核是用高级语言编写的，

441
00:12:03,130 --> 00:12:05,440
0,420 450,870 870,1200 1200,1590 1590,2310
know there are many kernels

442
00:12:05,770 --> 00:12:07,660
0,690 750,960 960,1350 1350,1770 1770,1890
written in high-level language,| you
|这样做已经有很长的历史了，

443
00:12:07,660 --> 00:12:08,920
0,90 90,270 270,330 330,720 720,1260
know there's a long history

444
00:12:08,980 --> 00:12:10,180
0,210 210,420 420,660 660,840 840,1200
of doing that,| they're dating
|甚至可以追溯到早期的机器，

445
00:12:10,180 --> 00:12:11,260
0,330 330,570 570,780 780,960 960,1080
back even to sort of

446
00:12:11,260 --> 00:12:13,840
0,210 210,660 660,930 930,1500 1950,2580
the early [] machines {},|
|

447
00:12:14,080 --> 00:12:16,000
0,510 510,660 660,1260 1350,1650 1650,1920
and you know but many
但是很多这些内核的最新版本，

448
00:12:16,000 --> 00:12:17,320
0,120 120,240 240,420 420,690 690,1320
of the sort of {}

449
00:12:17,350 --> 00:12:19,450
0,360 360,780 780,900 900,1260 1440,2100
recent versions of these kernels|
|

450
00:12:19,810 --> 00:12:22,300
0,690 840,1350 1350,1680 1680,2190 2190,2490
are not really written with
并不是根据评估高级语言税问题的想法来做的，

451
00:12:22,300 --> 00:12:23,920
0,240 240,690 690,840 840,1470 1470,1620
the idea of evaluating this

452
00:12:23,920 --> 00:12:27,000
0,510 510,1110 1230,1890 1920,2730
high-level language tax question,|
|

453
00:12:27,000 --> 00:12:28,140
0,120 120,300 300,570 570,690 690,1140
{} but really to explore
而是真正探索新的操作系统设计和新的操作系统架构，

454
00:12:28,140 --> 00:12:31,080
0,240 240,570 570,1320 1380,2280 2280,2940
new OS designs {} and

455
00:12:31,260 --> 00:12:34,410
0,360 360,660 660,1530 1830,2520 2580,3150
new OS architectures,| and so
|所以它们没有一个是直接评估，

456
00:12:34,440 --> 00:12:36,090
0,360 360,480 480,720 720,1200 1200,1650
none of them really measured

457
00:12:36,090 --> 00:12:37,530
0,810 810,900 900,1050 1050,1260 1260,1440
directly,| you know sort of
|比如面对面的比较，

458
00:12:37,530 --> 00:12:39,450
0,750 750,930 930,990 990,1200 1200,1920
{} head to head comparison,|
|

459
00:12:39,660 --> 00:12:41,400
0,780 780,1020 1020,1230 1230,1290 1290,1740
{} and keep the structure
保持结构不变，

460
00:12:41,400 --> 00:12:43,050
0,90 90,570 810,1290 1290,1440 1440,1650
the same,| {} so you
|所以你可以真正专注于语言的问题，

461
00:12:43,050 --> 00:12:44,040
0,120 120,390 390,810 810,900 900,990
can really focus on this

462
00:12:44,040 --> 00:12:45,330
0,420 420,510 510,690 690,1170 1170,1290
issue of the language| as
|而不是其他问题。

463
00:12:45,330 --> 00:12:47,490
0,390 390,750 990,1170 1170,1530 1560,2160
opposed to some other issues.|
|

464
00:12:49,220 --> 00:12:50,840
0,600 780,1200 1200,1290 1290,1530 1530,1620
In fact we used to
事实上，我们过去读过一些论文。

465
00:12:50,840 --> 00:12:52,010
0,510 570,720 720,930 930,1080 1080,1170
read you know some of

466
00:12:52,010 --> 00:12:53,420
0,150 150,570 570,1260 1260,1350 1350,1410
these papers actually in the

467
00:12:53,420 --> 00:12:54,460
0,540
past.|
|

468
00:12:55,180 --> 00:12:56,520
0,810

469
00:12:59,350 --> 00:13:01,150
0,540 990,1410 1410,1470 1470,1590 1590,1800
So, {} you know there's
所以，有一个原因可能是，

470
00:13:01,150 --> 00:13:02,320
0,450 450,750 750,900 900,1020 1020,1170
one reason may be that,|
|

471
00:13:02,320 --> 00:13:03,610
0,510 510,660 660,750 750,1080 1080,1290
there's not a lot of
没有太多的工作回答，

472
00:13:03,610 --> 00:13:05,290
0,450 540,780 780,1050 1050,1260 1260,1680
work {} that actually answers,|
|

473
00:13:05,290 --> 00:13:06,100
0,120 120,300 300,360 360,630 630,810
a ton of papers not
很多论文没有回答这个问题，

474
00:13:06,100 --> 00:13:07,840
0,210 210,360 360,720 720,990 1170,1740
answer this question is, {}|
|

475
00:13:07,840 --> 00:13:09,010
0,150 150,540 570,930 930,1020 1020,1170
it's actually tricky to do
做这件事是很困难的，

476
00:13:09,010 --> 00:13:11,740
0,330 450,1170 1680,2460 2460,2610 2610,2730
it,| {} basically if you
|如果你真的想做它，

477
00:13:11,740 --> 00:13:12,760
0,240 240,360 360,480 480,840 870,1020
really do it right,| you
|想和一个 C 编写的生产级别的内核进行比较，

478
00:13:12,760 --> 00:13:13,540
0,90 90,210 210,390 390,450 450,780
know you want to compare

479
00:13:13,540 --> 00:13:14,650
0,150 150,180 180,570 570,900 900,1110
with a production grade C

480
00:13:14,650 --> 00:13:16,630
0,450 510,750 750,1350 1530,1800 1800,1980
kernel,| that means something like
|比如 Linux 或 Windows 之类的东西，

481
00:13:16,630 --> 00:13:18,970
0,540 810,1530 1530,1770 1770,1890 1890,2340
Linux or something that Windows

482
00:13:18,970 --> 00:13:21,100
0,540 780,1440 1500,1770 1770,2010 2010,2130
whatever,| {} but then you
|然后你必须构建一个产品级别的内核，

483
00:13:21,100 --> 00:13:22,330
0,120 120,210 210,600 600,840 840,1230
have to build a production

484
00:13:22,330 --> 00:13:23,860
0,390 420,600 600,1020 1020,1380 1380,1530
grade {} kernel| and you
|当然，对于一个小团队来说，这是很难做到的，

485
00:13:23,860 --> 00:13:25,450
0,90 90,720 720,1140 1140,1230 1230,1590
know clearly for a small

486
00:13:25,450 --> 00:13:26,980
0,510 510,870 870,960 960,1260 1260,1530
team that is very hard

487
00:13:26,980 --> 00:13:28,840
0,90 90,480 480,990 1170,1590
to do { -},|
|

488
00:13:28,870 --> 00:13:29,860
0,150 150,240 240,540 570,930 930,990
you know there's lots of
你知道有很多 Linux 内核开发者，

489
00:13:29,860 --> 00:13:30,760
0,180 180,240 240,420 420,630 630,900
lots of {Linux -} kernel

490
00:13:30,760 --> 00:13:33,460
0,810 810,1680 1680,2160 2190,2430 2430,2700
developers,| { -} make many
|做了很多修改，一周又一周，一天又一天，

491
00:13:33,460 --> 00:13:35,260
0,270 270,840 840,930 930,1530 1560,1800
many changes you know week

492
00:13:35,260 --> 00:13:36,580
0,180 180,510 510,690 690,900 900,1320
by week day by day|
|

493
00:13:36,580 --> 00:13:37,570
0,330 330,570 570,810 810,930 930,990
and so it's going to
所以很难做到，

494
00:13:37,570 --> 00:13:39,850
0,90 90,630 900,1530 1530,1920 2160,2280
be hard to| {} you
|做同样的事情，

495
00:13:39,850 --> 00:13:40,570
0,90 90,270 270,420 420,510 510,720
know to do the same

496
00:13:40,570 --> 00:13:42,460
0,360 360,900 900,1140 1140,1230 1230,1890
thing| and build an equivalent
|构建一个同类型的东西，

497
00:13:42,490 --> 00:13:43,450
0,90 90,420 450,720 720,780 780,960
you know type of thing,|
|

498
00:13:43,450 --> 00:13:44,920
0,450 570,930 930,1080 1080,1170 1170,1470
so you have to settle
所以你只能满足于稍微低于。

499
00:13:44,920 --> 00:13:47,320
0,120 120,360 360,1020 1050,1860 1920,2400
for something slightly less {}

500
00:13:47,320 --> 00:13:48,860
0,630 660,1140
than {}.|
|

501
00:13:49,200 --> 00:13:51,660
0,480 480,1140 1350,1920

502
00:13:51,660 --> 00:13:52,980
0,420 690,840 840,1110 1110,1200 1200,1320
So the best we could
所以，我们能做的最好的是，

503
00:13:52,980 --> 00:13:53,790
0,240 240,420 420,510 510,720 720,810
do or the best we

504
00:13:53,790 --> 00:13:54,690
0,150 150,300 300,570 570,660 660,900
could come up to do

505
00:13:54,690 --> 00:13:56,580
0,360 480,810 810,840 840,1350 1650,1890
is| build a high-level build
|构建一个高级语言的内核，

506
00:13:56,580 --> 00:13:57,840
0,240 240,300 300,360 360,720 720,1260
{a,kernel} on the high-level language,|
|

507
00:13:57,870 --> 00:13:58,650
0,150 150,390 390,660 660,720 720,780
{you,know} keep most of the
保持大部分重要方面与 Linux 相同，

508
00:13:58,650 --> 00:13:59,820
0,390 390,750 750,810 810,1050 1050,1170
important aspects of same as

509
00:13:59,820 --> 00:14:00,840
0,540
Linux,|
|

510
00:14:00,840 --> 00:14:04,200
0,690 840,1410 1410,2040 2040,2730 2730,3360
{} optimized performance,| roughly optimized
优化性能，|优化性能，直到与 Linux 大致相似，

511
00:14:04,200 --> 00:14:05,760
0,450 450,720 720,870 870,1200 1200,1560
performance until it's roughly similar

512
00:14:05,760 --> 00:14:06,630
0,90 90,540 540,600 600,690 690,870
to Linux,| you know even
|即使它可能不是完全相同的特性，

513
00:14:06,630 --> 00:14:08,010
0,180 180,450 450,570 570,780 780,1380
though maybe it's not identically

514
00:14:08,010 --> 00:14:09,540
0,480 480,900 900,1200 1200,1350 1350,1530
exactly identical features,| but it
|但它进入了同样的范围内，

515
00:14:09,540 --> 00:14:10,950
0,210 210,420 420,480 480,720 720,1410
gets into the same ballpark|
|

516
00:14:11,310 --> 00:14:13,050
0,150 150,750 750,1050 1050,1470 1470,1740
and then measured high-level language
然后评估高级语言的权衡。

517
00:14:13,050 --> 00:14:14,100
0,660
trade-offs.|
|

518
00:14:14,520 --> 00:14:16,410
0,600 1110,1440 1440,1530 1530,1800 1800,1890
{} And of course you
当然，这种方法的风险是，

519
00:14:16,410 --> 00:14:17,310
0,90 90,210 210,600 630,750 750,900
know the risk you know

520
00:14:17,310 --> 00:14:18,390
0,150 150,540 540,660 660,990 990,1080
this approach is that| you
|我们构建的内核实际上与 Linux 略有不同，

521
00:14:18,390 --> 00:14:19,380
0,150 150,390 420,720 720,840 840,990
know the kernel that we

522
00:14:19,380 --> 00:14:20,790
0,420 420,510 510,750 750,1260 1260,1410
built you know actually is

523
00:14:20,790 --> 00:14:22,080
0,390 390,660 660,780 780,1200 1200,1290
slightly different than Linux,| you
|它不会和 Linux 完全一样，

524
00:14:22,080 --> 00:14:22,860
0,90 90,240 240,450 450,660 660,780
know it's not gonna be

525
00:14:22,860 --> 00:14:24,240
0,450 450,690 690,1020 1020,1140 1140,1380
exactly like Linux| and so
|所以当你得出任何结论时，必须非常小心。

526
00:14:24,240 --> 00:14:26,760
0,360 360,750 1620,1890 1890,2130 2130,2520
you've gotta be very careful

527
00:14:26,760 --> 00:14:28,840
0,360 390,780 780,990 990,1680
when drawing any conclusions.|
|

528
00:14:28,900 --> 00:14:31,120
0,750 780,900 900,1380 1830,2010 2010,2220
And you know and this
这是一个原因，

529
00:14:31,120 --> 00:14:31,930
0,60 60,270 270,540 540,690 690,810
is one reason| why you
|为什么我们仍然可以得到一个相当清晰的答案，

530
00:14:31,930 --> 00:14:33,040
0,270 270,540 540,690 690,810 810,1110
can still get a really

531
00:14:33,040 --> 00:14:34,840
0,360 360,1260 1260,1530 1530,1680 1680,1800
crystal clear answer,| that is
|这就是这篇论文提出的问题，

532
00:14:34,840 --> 00:14:35,830
0,60 60,390 390,510 510,840 840,990
the question that basically this

533
00:14:35,830 --> 00:14:37,600
0,180 180,810 990,1320 1320,1530 1530,1770
paper proposes,| {} but we
|但我们希望能获得更深层次的洞察力，

534
00:14:37,600 --> 00:14:38,650
0,120 120,570 570,810 810,840 840,1050
can hopefully get a little

535
00:14:38,650 --> 00:14:40,180
0,120 120,390 390,720 720,1260 1260,1530
bit more deeper insight| than
|而不是基本上什么都不说。

536
00:14:40,180 --> 00:14:41,950
0,570 690,990 990,1260 1260,1500 1500,1770
basically saying almost nothing about

537
00:14:41,950 --> 00:14:42,560
0,120
it.|
|

538
00:14:44,560 --> 00:14:46,630
0,270 270,450 450,930 1350,1590 1590,2070
{Is,this} makes sense, so far,
这能理解吗，到目前为止，有什么问题吗？

539
00:14:46,660 --> 00:14:48,480
0,480 480,1200
any questions?|
|

540
00:14:48,690 --> 00:14:50,010
0,240 240,390 390,480 480,570 570,1320
That's sort of the context
这就是这篇论文的背景，

541
00:14:50,070 --> 00:14:51,600
0,270 270,420 420,960 960,1410 1410,1530
of this paper,| and you
|以及为什么我们这么做。

542
00:14:51,600 --> 00:14:53,700
0,570 1050,1350 1350,1770 1770,1890 1890,2100
know why we gone to

543
00:14:53,700 --> 00:14:54,680
0,180 180,420
do it.|
|

544
00:14:55,990 --> 00:14:57,500
0,390 420,1020
Okay so,
好的，如果没有问题，

545
00:14:57,500 --> 00:14:58,700
0,270 270,390 390,510 510,630 630,1200
{} if there's no questions,|
|

546
00:14:58,700 --> 00:14:59,570
0,120 120,240 240,540 630,840 840,870
I'd like to talk a
我想多谈一点关于方法论的问题。

547
00:14:59,570 --> 00:15:00,440
0,150 150,300 300,600 600,810 810,870
little bit more about the

548
00:15:00,440 --> 00:15:03,000
0,930 1140,2070
methodology {}.|
|

549
00:15:03,290 --> 00:15:05,720
0,570 570,1050 1260,1830 1830,1980 1980,2430
{} So, {} so basically
所以，基本的设置是，

550
00:15:05,720 --> 00:15:06,650
0,120 120,240 240,660 690,870 870,930
you know the sort of

551
00:15:06,650 --> 00:15:07,790
0,330 330,570 570,780 780,1080 1080,1140
setup is| {} here on
|在左边，有我们的 Biscuit ，

552
00:15:07,790 --> 00:15:08,870
0,90 90,360 360,840 840,930 930,1080
the left side, you know

553
00:15:08,870 --> 00:15:11,060
0,240 240,570 570,1050 1320,2040 2040,2190
we have our is gonna

554
00:15:11,060 --> 00:15:12,700
0,270 300,1110
be Biscuit,|
|

555
00:15:12,860 --> 00:15:15,280
0,1230 1230,1440 1440,1830
{you,know}, we're gonna,
我们要，在我们的情况中，

556
00:15:16,400 --> 00:15:17,840
0,480 480,570 570,870 870,1200 1200,1440
in our particular case,| we
|我们为这篇论文使用 Go 编写的内核，

557
00:15:17,840 --> 00:15:19,010
0,450 450,540 540,660 660,930 930,1170
wrote for this paper the

558
00:15:19,010 --> 00:15:21,590
0,450 450,600 600,1110 1110,1680 1860,2580
kernel in {} Go {},|
|

559
00:15:21,590 --> 00:15:23,960
0,210 210,660 720,1500 1500,1620 1620,2370
it provides roughly a similar
它提供了与 Linux 的系统调用大致相同的子集，

560
00:15:23,960 --> 00:15:25,760
0,0 780,1320 1320,1410 1410,1500 1500,1800
{} subset of the system

561
00:15:25,760 --> 00:15:27,170
0,300 300,630 630,1140 1140,1290 1290,1410
calls Linux provides,| but you
|你知道它们的方式，

562
00:15:27,170 --> 00:15:28,370
0,180 180,420 420,600 600,870 870,1200
know the way to {},|
|

563
00:15:28,370 --> 00:15:30,050
0,210 210,420 420,780 780,1110 1110,1680
but they have same arguments,|
它们有相同的参数，|

564
00:15:30,050 --> 00:15:31,400
0,120 120,270 270,420 420,900 1050,1350
you know the {} same
相同的的调用接口。

565
00:15:31,400 --> 00:15:32,580
0,270 270,750
calling interfaces.|
|

566
00:15:32,850 --> 00:15:34,200
0,480 510,690 690,900 900,1230 1230,1350
And we run basically the
我们在接口上运行相同的应用程序，

567
00:15:34,200 --> 00:15:35,580
0,390 390,1020 1020,1080 1080,1290 1290,1380
same applications on top of

568
00:15:35,580 --> 00:15:37,350
0,150 150,780 1050,1560 1560,1680 1680,1770
that interface,| so you know
|其中一个应用程序是网络服务器 Nginx ，

569
00:15:37,350 --> 00:15:38,670
0,180 180,270 270,360 360,1110 1110,1320
one of the applications and

570
00:15:38,670 --> 00:15:39,660
0,360 360,570 570,690 690,780 780,990
Nginx which is a web

571
00:15:39,660 --> 00:15:41,240
0,1020
server,|
|

572
00:15:41,390 --> 00:15:43,310
0,570 1080,1290 1290,1410 1410,1530 1530,1920
{} and so the idea
所以我们的想法是，

573
00:15:43,310 --> 00:15:44,090
0,120 120,330 330,450 450,570 570,780
is that| you know we're
|我们在 Biscuit 和 Linux 上使用相同的应用程序，

574
00:15:44,090 --> 00:15:45,740
0,90 90,180 180,1110
on the same

575
00:15:46,060 --> 00:15:48,190
0,420 420,960 960,1440 1440,1920 1950,2130
{} application both on {}

576
00:15:48,190 --> 00:15:49,570
0,360 360,480 480,1050 1080,1170 1170,1380
Biscuit and Linux,| you know
|应用程序使用完全相同的参数生成相同的系统调用[跟踪]，

577
00:15:49,570 --> 00:15:51,190
0,510 540,1080 1080,1170 1170,1530 1530,1620
the application will generate the

578
00:15:51,190 --> 00:15:52,810
0,420 420,750 750,960 960,1440 1440,1620
same system call trace with

579
00:15:52,810 --> 00:15:55,810
0,690 690,780 780,1230 1230,1920 2220,3000
exactly the same arguments| and
|Biscuit 和 Linux 执行所有必须的操作，

580
00:15:56,020 --> 00:15:57,790
0,690 690,1050 1050,1140 1140,1590 1590,1770
both Biscuit and Linux {you,know}

581
00:15:57,790 --> 00:16:00,100
0,840 870,1200 1200,1320 1320,1800 1800,2310
perform all the necessary operations|
|

582
00:16:00,100 --> 00:16:01,570
0,480 480,750 750,1110 1110,1230 1230,1470
that are invoked by those
由这些系统调用引起的，

583
00:16:01,570 --> 00:16:03,550
0,270 270,780 1020,1620 1620,1890 1890,1980
system calls,| and then we
|然后我们可以看一下

584
00:16:03,550 --> 00:16:04,960
0,90 90,270 270,450 570,1110 1110,1410
can sort of look at

585
00:16:04,960 --> 00:16:05,800
0,120 120,240 240,390 390,720 720,840
you know| the difference is
|高级语言内核和 Linux 之间的区别，

586
00:16:05,800 --> 00:16:07,420
0,390 390,990 1170,1290 1290,1440 1440,1620
basically between you know the

587
00:16:07,420 --> 00:16:09,070
0,480 480,780 780,1140 1140,1290 1290,1650
high-level language kernel and Linux,|
|

588
00:16:09,070 --> 00:16:10,180
0,180 180,360 360,480 480,780 780,1110
and sort of talk about
并讨论一下什么是权衡。

589
00:16:10,180 --> 00:16:11,400
0,330 450,570 570,870
like you know

590
00:16:11,890 --> 00:16:13,460
0,210 210,360 360,420 420,1050
what are the trade-offs.|
|

591
00:16:13,670 --> 00:16:15,860
0,300 300,660 780,1260 1260,1650 1680,2190
And so after the core
所以在方法论之后，

592
00:16:15,860 --> 00:16:17,360
0,120 120,210 210,900 900,990 990,1500
of the methodology| and again
|因为 Linux 和 Biscuit 不会完全相同，

593
00:16:17,540 --> 00:16:19,130
0,480 480,1020 1020,1200 1200,1470 1470,1590
because Linux and Biscuit are

594
00:16:19,130 --> 00:16:19,970
0,120 120,240 240,300 300,390 390,840
not going to be exactly

595
00:16:19,970 --> 00:16:21,950
0,780 1020,1560 1560,1650 1650,1770 1770,1980
identical,| {} you know there's
|这里会有一些不同，

596
00:16:21,950 --> 00:16:24,110
0,150 150,600 630,1260 1290,1920 1920,2160
gonna be some differences,| but
|但是我们在这里花了很多时间，

597
00:16:24,110 --> 00:16:26,000
0,90 90,210 210,960 1530,1860 1860,1890
you know we spend a

598
00:16:26,000 --> 00:16:27,470
0,180 180,240 240,780 870,1320 1320,1470
lot of time {} in

599
00:16:27,470 --> 00:16:28,460
0,300 300,570 570,780 780,870 870,990
this| trying to you know
|尽可能地进行比较，

600
00:16:28,460 --> 00:16:30,580
0,360 360,840 840,1200 1200,1680
make comparison {as,far,as} possible,|
|

601
00:16:32,970 --> 00:16:34,470
0,630 630,990 990,1170 1170,1290 1290,1500
wherever possible we could think
尽可能想办法做成它。

602
00:16:34,470 --> 00:16:36,200
0,270 630,960 960,1200
of making it.|
|

603
00:16:37,090 --> 00:16:38,680
0,540 570,690 690,900 900,1170 1170,1590
So a lot of you
你们中的很多人都会问这个问题，

604
00:16:38,680 --> 00:16:40,240
0,270 270,390 390,780 780,1170 1170,1560
ask this question| which high-level
|使用哪种高级语言，

605
00:16:40,240 --> 00:16:41,500
0,270 270,450 450,960 990,1140 1140,1260
language {} use,| you know
|对于这种工作，

606
00:16:41,500 --> 00:16:42,640
0,120 120,240 240,420 420,570 570,1140
for this kind of {}

607
00:16:42,640 --> 00:16:44,320
0,360 390,990 1320,1440 1440,1530 1530,1680
work| and you know we
|我们选择 Go ，出于几个原因，

608
00:16:44,320 --> 00:16:46,480
0,240 240,1530 1650,1980 1980,2100 2100,2160
pick Go and for a

609
00:16:46,480 --> 00:16:48,640
0,180 180,240 240,810 840,1710 1800,2160
couple of reasons,| {} it
|它是一种静态编译语言，

610
00:16:48,640 --> 00:16:50,260
0,150 150,300 300,780 780,1260 1260,1620
is a statically compiled language,|
|

611
00:16:50,260 --> 00:16:52,840
0,480 480,870 870,1590 1830,2400 2400,2580
so unlike Python, {} there's
所以与 Python 不同，这里没有解释器，

612
00:16:52,840 --> 00:16:55,270
0,150 150,840 960,1650 1650,2370 2370,2430
no interpreter,| {} and the
|这是我们喜欢静态编译的原因，

613
00:16:55,270 --> 00:16:56,800
0,360 360,540 540,630 630,1080 1110,1530
reason that we like static

614
00:16:56,800 --> 00:16:58,390
0,480 480,690 690,840 840,1200 1200,1590
compiled,| because we've basically compiles
|因为我们可以编译高性能的代码，

615
00:16:58,390 --> 00:16:59,980
0,240 240,450 450,900 900,1320 1380,1590
actually high performance code,| in
|实际上， Go 编译器是相当不错的。

616
00:16:59,980 --> 00:17:01,180
0,180 180,240 240,570 570,780 780,1200
fact the particular Go compiler

617
00:17:01,180 --> 00:17:02,140
0,90 90,330 330,630
is pretty good.|
|

618
00:17:02,740 --> 00:17:04,780
0,630 1080,1290 1290,1770 1770,1860 1860,2040
{} So basically you know
所以它是一种高性能的语言，

619
00:17:04,780 --> 00:17:06,430
0,420 420,480 480,720 720,1140 1140,1650
sort of high performance language,|
|

620
00:17:06,460 --> 00:17:08,620
0,570 570,1020 1020,1410 1410,1560 1560,2160
furthermore, Go design is actually
此外， Go 的设计是为系统编程的，

621
00:17:08,680 --> 00:17:11,140
0,690 690,780 780,1170 1170,1710 1830,2460
intended for system programming| {you,know}
|内核或系统编程，

622
00:17:11,140 --> 00:17:12,730
0,390 390,450 450,690 690,1020 1020,1590
kernels or for system programming,|
|

623
00:17:12,730 --> 00:17:13,810
0,360 360,690 690,840 840,870 870,1080
so that {could,be} a good
所以它是一个很好的选择。

624
00:17:13,810 --> 00:17:14,780
0,420
match.|
|

625
00:17:14,780 --> 00:17:16,130
0,210 210,270 360,1110 1110,1170 1170,1350
As an example, you know
举个例子，为什么它是一个好的系统编程语言，

626
00:17:16,130 --> 00:17:18,380
0,510 510,720 1740,2010 2010,2130 2130,2250
aspect of why it's a

627
00:17:18,380 --> 00:17:19,790
0,180 180,510 510,1020 1020,1200 1200,1410
good system programming,| it's actually
|它很容易调用汇编或其他外来代码，

628
00:17:19,790 --> 00:17:21,290
0,180 180,270 270,780 810,1320 1320,1500
easy to call assembly or

629
00:17:21,290 --> 00:17:22,980
0,300 300,630 630,1170
other foreign code,|
|

630
00:17:23,010 --> 00:17:24,150
0,300 300,390 390,570 570,750 750,1140
{} it has good support
它对并发有很好的支持，非常方便。

631
00:17:24,150 --> 00:17:26,250
0,120 120,210 210,1050 1080,1440 1440,2100
for {} concurrency, quite flexible.|
|

632
00:17:26,550 --> 00:17:28,260
0,960 960,1140 1140,1260 1260,1530 1530,1710
{} And then another reason
然后另一个我们想要使用它的原因，

633
00:17:28,260 --> 00:17:28,980
0,90 90,180 180,450 450,510 510,720
that we wanted to use

634
00:17:28,980 --> 00:17:29,610
0,210 210,420 420,480 480,600 600,630
it,| because it has a
|因为它有一个垃圾收集器，

635
00:17:29,610 --> 00:17:32,070
0,300 300,750 1650,1860 1860,2250 2250,2460
garbage collector,| { -} one
|关于高级语言需要考虑的一件事，

636
00:17:32,070 --> 00:17:32,610
0,60 60,150 150,360 360,450 450,540
of the things that you

637
00:17:32,610 --> 00:17:33,660
0,150 150,330 330,360 360,750 750,1050
think about a high-level language,|
|

638
00:17:33,660 --> 00:17:34,500
0,120 120,270 270,330 330,420 420,840
and one of the virtues
高级语言的优点之一，

639
00:17:34,500 --> 00:17:35,610
0,90 90,150 150,540 540,960 960,1110
of a high-level languages| that
|你不需要进行内存管理，

640
00:17:35,610 --> 00:17:36,240
0,90 90,300 300,420 420,510 510,630
you don't have to do

641
00:17:36,240 --> 00:17:38,520
0,270 270,870 1140,1590 1590,1890 1890,2280
memory management,| and garbage collectors
|垃圾收集器通常是关键角色，

642
00:17:38,520 --> 00:17:40,170
0,510 510,630 630,750 750,1170 1170,1650
typically in a central role

643
00:17:40,170 --> 00:17:41,280
0,270 270,690
in the,|
|

644
00:17:42,910 --> 00:17:44,890
0,750 1170,1470 1470,1500 1500,1740 1740,1980
yeah, provides a central role
在内存管理中提供关键角色。

645
00:17:44,890 --> 00:17:45,520
0,90 90,180 180,330 330,390 390,630
in a sort of memory

646
00:17:45,520 --> 00:17:46,940
0,420 420,900
management story.|
|

647
00:17:47,210 --> 00:17:48,340
0,540

648
00:17:48,830 --> 00:17:50,450
0,450 450,570 570,1140 1140,1260 1260,1620
By the time we started
当我们开始写这篇论文的时候，

649
00:17:50,450 --> 00:17:52,130
0,150 150,960 960,1200 1200,1410 1410,1680
this paper,| or we started
|或者我们开始这个项目的时候，

650
00:17:52,130 --> 00:17:54,470
0,90 90,690 900,1650 1680,2190 2190,2340
this project,| {} Rust was
|Rust 不是很流行，

651
00:17:54,470 --> 00:17:56,390
0,210 210,840 870,1320 1320,1560 1590,1920
not very popular| or Rust
|或者 Rust 还不是很稳定和成熟，

652
00:17:56,390 --> 00:17:57,530
0,270 270,450 450,630 630,1050 1050,1140
was not very stable and

653
00:17:57,530 --> 00:17:58,460
0,330 330,390 390,540 540,840 840,930
mature at that point,| and
|它可以写一个真正的内核，

654
00:17:58,460 --> 00:17:59,180
0,90 90,270 270,450 450,660 660,720
the actually could write a

655
00:17:59,180 --> 00:18:02,240
0,450 480,810 810,1080 1500,2040 2250,3060
real kernel,| in a retrospect
|现在回想一下，

656
00:18:02,240 --> 00:18:04,220
0,870 870,1320 1320,1440 1440,1530 1530,1980
now,| you do it again,|
|如果你再做一次，|

657
00:18:04,220 --> 00:18:05,510
0,60 60,210 210,330 330,540 540,1290
you know you may write
你可以使用 Rust 来写，

658
00:18:05,510 --> 00:18:07,070
0,120 120,270 270,690 720,1350 1350,1560
it in Rust,| because {it,also}
|因为它也是为系统编程设计的，

659
00:18:07,070 --> 00:18:10,160
0,390 390,1020 1050,1950 2010,2850 2850,3090
designs {for,system} programming,| {} it
|它有一个很小的运行时，可以产生好的代码，

660
00:18:10,160 --> 00:18:13,040
0,210 210,630 660,990 990,1830 2340,2880
has a small runtime, produces

661
00:18:13,040 --> 00:18:16,910
0,180 180,720 900,1620 2520,2970 2970,3870
good code,| {} although one
|尽管有一件事，

662
00:18:16,940 --> 00:18:18,560
0,270 270,450 450,930 930,1410 1410,1620
thing that| actually might still
|可能仍然会让人[本能地]去尝试的是，

663
00:18:18,560 --> 00:18:19,430
0,150 150,270 270,540 540,810 810,870
make it very [instinct] to

664
00:18:19,430 --> 00:18:20,660
0,180 180,450 450,720 720,900 900,1230
go for Go is that,|
|

665
00:18:20,720 --> 00:18:23,210
0,960 960,1260 1260,1380 1380,1860 1860,2490
Rust takes the starting assumption|
Rust 首先假设，

666
00:18:23,210 --> 00:18:24,740
0,390 420,1170
that {
如果你想要高性能系统程序，

667
00:18:24,890 --> 00:18:26,030
0,300 300,720 720,930 930,1020 1020,1140
-} that if you want

668
00:18:26,030 --> 00:18:28,580
0,180 180,600 600,1290 1320,2010 2010,2550
high performance systems programs,| then
|那么你不能使用垃圾收集器。

669
00:18:28,580 --> 00:18:29,420
0,240 240,450 450,540 540,690 690,840
you can't do that with

670
00:18:29,420 --> 00:18:30,680
0,30 30,330 330,750
a garbage collector.|
|

671
00:18:30,680 --> 00:18:32,600
0,720 720,930 930,1170 1170,1410 1410,1920
And in fact a {}
事实上， Rust 类型系统以一种非常聪明的方式，

672
00:18:33,100 --> 00:18:34,270
0,300 300,570 570,870 870,960 960,1170
Rust type system is set

673
00:18:34,270 --> 00:18:35,230
0,120 120,240 240,360 360,600 600,960
up in a very clever

674
00:18:35,230 --> 00:18:36,430
0,360 360,480 480,570 570,840 840,1200
way| and a very interesting
|和一种非常有趣的方式设置的，

675
00:18:36,430 --> 00:18:38,020
0,450 630,990 990,1140 1140,1410 1410,1590
way,| so that actually the
|所以垃圾收集器是不必要的。

676
00:18:38,020 --> 00:18:39,490
0,300 300,570 570,660 660,810 810,1470
garbage collector is not necessary.|
|

677
00:18:40,080 --> 00:18:41,250
0,330 330,630 630,810 810,1050 1050,1170
And in some ways, we
在某些方面，我们对回答这个问题很感兴趣，

678
00:18:41,250 --> 00:18:42,990
0,570 570,930 930,1110 1230,1620 1620,1740
were interested in answering this

679
00:18:42,990 --> 00:18:44,190
0,450 450,690 690,780 780,840 840,1200
question,| what is the cost
|在高级语言中进行垃圾收集的成本是多少，

680
00:18:44,190 --> 00:18:45,210
0,60 60,390 390,840 840,960 960,1020
of garbage collection in a

681
00:18:45,210 --> 00:18:46,650
0,450 450,900 900,1020 1020,1170 1170,1440
high-level language,| you know on
|关于内核编程，

682
00:18:46,650 --> 00:18:48,930
0,360 360,960 1140,1770 1980,2130 2130,2280
kernel programming| and it is
|它的成本是多少，

683
00:18:48,930 --> 00:18:50,940
0,360 360,870 870,990 990,1230 1230,2010
really impossible to use or

684
00:18:51,360 --> 00:18:52,890
0,330 330,420 420,630 630,1080 1350,1530
what does that cost,| in
|在某些方面， Rust 绕过了这个问题，

685
00:18:52,890 --> 00:18:53,970
0,150 150,480 480,570 570,690 690,1080
some ways, you know Rust

686
00:18:53,970 --> 00:18:55,290
0,450 450,570 570,1020 1020,1110 1110,1320
sidestep that question| and just
|使用一种没有垃圾回收的语言，

687
00:18:55,290 --> 00:18:56,640
0,150 150,510 750,1020 1020,1080 1080,1350
like {you,know} use a language

688
00:18:56,640 --> 00:18:57,660
0,240 240,480 480,810 810,930 930,1020
without garbage collection,| you haven't
|你不必须考虑这个成本。

689
00:18:57,660 --> 00:18:58,920
0,270 270,450 450,660 660,840 840,1260
to think about this particular

690
00:18:58,920 --> 00:18:59,660
0,420
cost.|
|

691
00:19:01,860 --> 00:19:02,850
0,180 180,480 480,660 660,900 900,990
Any questions about this,| in
关于这个有什么问题吗，|关于我们决定使用的编程语言方面。

692
00:19:02,850 --> 00:19:05,160
0,210 210,300 300,810 990,1500 1500,2310
terms of the programming language

693
00:19:05,930 --> 00:19:07,660
0,210 210,570 570,660 660,1140
we decided to use.|
|

694
00:19:11,050 --> 00:19:12,550
0,360 360,450 450,720 720,1110 1110,1500
Lots of email questions related
许多邮件里的问题与这个主题有关。

695
00:19:12,550 --> 00:19:14,760
0,90 90,270 270,780
to this topic.|
|

696
00:19:14,850 --> 00:19:16,620
0,360 360,510 510,720 720,1320 1320,1770
This is a theoretical question,|
这是一个理论问题，|

697
00:19:16,620 --> 00:19:18,360
0,150 150,600 630,1170 1380,1650 1650,1740
that maybe doesn't have an
可能没有直接的答案，

698
00:19:18,360 --> 00:19:20,190
0,450 450,1020 1080,1260 1260,1500 1500,1830
immediate answer,| but if the
|但是如果编写 Linux 内核使用 Rust 而不是 Go ，

699
00:19:20,190 --> 00:19:22,050
0,480 510,1230 1230,1530 1530,1680 1680,1860
Linux kernel were to be

700
00:19:22,050 --> 00:19:24,930
0,420 420,870 990,1860 1920,2340 2340,2880
written on Rust not Go,|
|

701
00:19:25,260 --> 00:19:26,910
0,300 300,600 630,1470 1470,1560 1560,1650
and like optimized in the
在相同的能力下进行优化，

702
00:19:26,910 --> 00:19:28,620
0,540 540,1290 1320,1500 1500,1590 1590,1710
same capacity,| would it be
|它是否能够实现更高的性能？

703
00:19:28,620 --> 00:19:31,230
0,270 270,390 390,1290 1320,1770 1770,2610
able to achieve higher performance?|
|

704
00:19:32,490 --> 00:19:33,700
0,720
Than,
比 Go 的并发吗？

705
00:19:34,530 --> 00:19:36,780
0,360 360,450 450,960 960,1350 1920,2250
than the Go concurrency?| Than
|比 C ，比如 C 编写的 Linux 内核。

706
00:19:36,780 --> 00:19:39,210
0,450 720,1170 1170,1530 1530,1920 1920,2430
C, like a Linux {C,kernel}.|
|

707
00:19:39,630 --> 00:19:41,520
0,900 1080,1440 1440,1530 1530,1680 1680,1890
I doubt it will be,|
我怀疑它会，|

708
00:19:41,520 --> 00:19:43,020
0,510 510,750 750,1080 1110,1410 1410,1500
{} okay, {} hard to
好的，很难知道，只是猜测，

709
00:19:43,020 --> 00:19:44,550
0,300 300,480 480,1080 1080,1320 1320,1530
know, just speculation, correct,| because
|因为我们做有过这个实验，

710
00:19:44,550 --> 00:19:45,750
0,90 90,240 240,420 420,540 540,1200
we haven't done this experiment,|
|

711
00:19:46,050 --> 00:19:47,970
0,660 660,930 930,1260 1260,1770 1770,1920
{} in my senses, you
在我看来，不会比 C 有更高的性能，

712
00:19:47,970 --> 00:19:49,020
0,150 150,330 330,480 480,690 690,1050
know would be not higher

713
00:19:49,020 --> 00:19:51,300
0,570 570,870 870,1470 1560,2040 2040,2280
performance than C,| {} but
|但可能大致相同。

714
00:19:51,300 --> 00:19:52,740
0,120 120,750 750,1050 1050,1380 1380,1440
you know probably roughly the

715
00:19:52,740 --> 00:19:53,940
0,210 210,840
same ballpark.|
|

716
00:19:54,580 --> 00:19:56,380
0,420 420,750 1170,1320 1320,1620 1620,1800
{} Because {} C so
因为 C 是低级语言，

717
00:19:56,380 --> 00:19:57,970
0,540 540,690 690,930 990,1200 1200,1590
low-level,| you can assume whatever
|你可以假设你在 Rust 里所做的，

718
00:19:57,970 --> 00:19:58,780
0,150 150,360 360,450 450,690 690,810
you do in Rust,| you
|你也可以用 C 来做。

719
00:19:58,780 --> 00:19:59,770
0,120 120,300 300,420 420,660 660,990
could also have {done,in} C.|
|

720
00:20:00,540 --> 00:20:02,300
0,810

721
00:20:04,810 --> 00:20:06,140
0,150 150,240 240,390 390,690
Does that make sense?|
这能理解吗？|

722
00:20:07,060 --> 00:20:08,580
0,450 450,690 690,960
Yes, thank you.|
好的，谢谢。|

723
00:20:11,010 --> 00:20:12,940
0,570 600,1380
Okay {}.|
好的。|

724
00:20:13,270 --> 00:20:14,560
0,240 240,390 390,630 660,1170 1170,1290
Okay, so let's move on
好的，我们开始吧，

725
00:20:14,560 --> 00:20:15,520
0,420
them,|
|

726
00:20:15,610 --> 00:20:16,570
0,330 330,630 630,750 750,810 810,960
{} unless there are any
除非对于这个还有任何其他问题，

727
00:20:16,570 --> 00:20:17,800
0,210 210,420 420,750 750,930 930,1230
other further questions about this,|
|

728
00:20:17,860 --> 00:20:19,150
0,180 180,720 720,1020 1020,1200 1200,1290
and again feel free to
再说一次，请随意打断，

729
00:20:19,150 --> 00:20:20,590
0,480 480,780 780,870 870,1200 1200,1440
interrupt| and you know there's
|这里一节基于讨论的课程，

730
00:20:20,590 --> 00:20:21,430
0,90 90,300 300,360 360,450 450,840
a bit of a discussion

731
00:20:21,430 --> 00:20:24,790
0,270 270,750 1470,1830 1830,2190 3090,3360
based lecture,| and so it
|它的目的是激发智力和兴趣，

732
00:20:24,970 --> 00:20:27,220
0,120 120,480 480,870 900,1800 1800,2250
was intended to stimulate intellectual

733
00:20:27,220 --> 00:20:29,170
0,600 600,780 780,1110 1290,1800 1800,1950
interests,| so you jump in
|所以，如果你对这个话题有什么想说的，可以加入进来。

734
00:20:29,170 --> 00:20:30,100
0,90 90,180 180,300 300,630 630,930
if you have anything to

735
00:20:30,220 --> 00:20:31,620
0,210 210,390 390,540 540,960
think about this topic.|
|

736
00:20:34,900 --> 00:20:36,250
0,420 450,690 690,1140 1140,1260 1260,1350
So actually before you know
所以在我想问的问题之前，

737
00:20:36,250 --> 00:20:37,390
0,360 360,570 570,930 930,960 960,1140
maybe the question I want

738
00:20:37,390 --> 00:20:38,980
0,60 60,750 780,1200 1200,1470 1470,1590
to ask,| {} maybe I'll
|也许我会在课程结束时回来看，

739
00:20:38,980 --> 00:20:39,730
0,150 150,390 390,480 480,660 660,750
come back to that at

740
00:20:39,730 --> 00:20:40,420
0,120 120,240 240,330 330,420 420,690
the end of the lecture,|
|

741
00:20:40,420 --> 00:20:41,140
0,300 300,390 390,510 510,630 630,720
closer to the end of
课程快结束的时候。

742
00:20:41,140 --> 00:20:42,220
0,60 60,540
the lecture.|
|

743
00:20:42,280 --> 00:20:44,950
0,600 1620,2220 2220,2280 2280,2400 2400,2670
{} Partly you know the
在一定程度上，我们使用高级语言

744
00:20:44,950 --> 00:20:46,780
0,750 1050,1500 1500,1620 1620,1740 1740,1830
whole reason we ought to

745
00:20:46,780 --> 00:20:48,010
0,150 150,510 510,900 900,990 990,1230
use high-level languages| to avoid
|来避免某种类型的 bug ，

746
00:20:48,010 --> 00:20:49,510
0,210 210,270 270,660 660,1170 1290,1500
sort of {class,of} bugs| and
|你应该问自己一个问题，

747
00:20:49,510 --> 00:20:50,620
0,270 270,630 630,750 750,870 870,1110
one question you should ask

748
00:20:50,620 --> 00:20:53,320
0,630 690,1410 1410,2040 2070,2190 2190,2700
yourself,| where bugs you know
|你在实验中出现的哪种 bug 是可以避免的，

749
00:20:53,320 --> 00:20:54,400
0,180 180,300 300,720 720,870 870,1080
in the labs that you

750
00:20:54,400 --> 00:20:55,660
0,540 570,750 750,900 900,1080 1080,1260
had that would have been

751
00:20:55,660 --> 00:20:56,710
0,570 600,720 720,840 840,990 990,1050
avoided,| if you had a
|如果你使用高级语言。

752
00:20:56,710 --> 00:20:58,100
0,150 150,420 420,1020
high level language.|
|

753
00:20:58,460 --> 00:20:59,990
0,780 780,930 930,1020 1020,1380 1380,1530
{} You know, so you
所以回想一下，

754
00:20:59,990 --> 00:21:01,250
0,120 120,330 330,840 840,990 990,1260
know think back,| you know
|我相信你能想出一些 bug ，

755
00:21:01,250 --> 00:21:02,060
0,240 240,450 450,570 570,690 690,810
I'm sure you can come

756
00:21:02,060 --> 00:21:03,620
0,150 150,270 270,660 810,1350 1350,1560
up with some bugs,| that
|花了你很多时间和痛苦，

757
00:21:03,620 --> 00:21:04,520
0,360 360,660 660,750 750,780 780,900
you cost you a lot

758
00:21:04,520 --> 00:21:05,510
0,60 60,600 660,780 780,810 810,990
of time and a lot

759
00:21:05,510 --> 00:21:07,550
0,60 60,570 720,1470 1470,1950 1950,2040
of pain,| {} and you
|你可以问自己这些 bug ，

760
00:21:07,550 --> 00:21:08,660
0,120 120,360 360,750 750,960 960,1110
could ask yourself those kind

761
00:21:08,660 --> 00:21:10,250
0,60 60,480 480,540 540,960 960,1590
of bugs,| you know if
|如果我们在实验中的 xv6 ，

762
00:21:10,280 --> 00:21:12,770
0,540 540,810 810,1410 1770,2130 2130,2490
we if the {xv6 -}

763
00:21:12,770 --> 00:21:14,180
0,360 360,630 630,900 900,1050 1050,1410
where we run into labs|
|

764
00:21:14,180 --> 00:21:15,440
0,180 180,270 270,510 510,660 660,1260
would be done in another
用另一种高级编程语言来完成，

765
00:21:15,470 --> 00:21:17,060
0,420 420,840 840,1230 1260,1470 1470,1590
high-level programming language,| would have
|会让生活变得容易很多，

766
00:21:17,060 --> 00:21:18,500
0,390 390,720 720,780 780,1230 1230,1440
life would be a lot

767
00:21:18,500 --> 00:21:19,610
0,420 450,600 600,750 750,900 900,1110
easier,| would you have a
|让你有更多的空闲时间做其他事情。

768
00:21:19,610 --> 00:21:20,660
0,210 210,330 330,600 600,930 930,1050
lot more spare time to

769
00:21:20,660 --> 00:21:21,680
0,90 90,270 270,690
do other things.|
|

770
00:21:22,470 --> 00:21:23,610
0,270 270,420 420,690 690,900 900,1140
{} So let's keep that
所以我们带着这个问题，

771
00:21:23,610 --> 00:21:24,960
0,360 360,450 450,570 570,960 960,1350
question in your head| and
|在课程结束时回到这个问题上来。

772
00:21:25,140 --> 00:21:26,850
0,150 150,480 570,1380 1380,1620 1620,1710
you know hopefully return to

773
00:21:26,850 --> 00:21:27,510
0,180 180,300 300,420 420,570 570,660
that at the end of

774
00:21:27,510 --> 00:21:28,480
0,60 60,420
the lecture.|
|

775
00:21:28,820 --> 00:21:29,810
0,300 300,420 420,540 540,660 660,990
But if you have opinions
但是如果你现在有想法，也没问题。

776
00:21:29,810 --> 00:21:30,920
0,180 180,450 450,690 690,900 900,1110
right away, that's fine too.|
|

777
00:21:32,350 --> 00:21:33,970
0,510 750,1140 1140,1410 1410,1560 1560,1620
Okay, {} so let me
好的，让我说一下 Biscuit ，

778
00:21:33,970 --> 00:21:34,660
0,120 120,180 180,360 360,480 480,690
talk a little bit about

779
00:21:34,660 --> 00:21:37,420
0,480 630,1350 1350,2100 2130,2670 2670,2760
Biscuit,| {} and {} you
|其中的工作，

780
00:21:37,420 --> 00:21:39,640
0,300 300,540 540,780 840,1500 1890,2220
know sort of works {}|
|

781
00:21:39,640 --> 00:21:41,020
0,210 210,390 390,540 540,1140 1140,1380
in sort of surprises where
一些惊讶的事情，

782
00:21:41,020 --> 00:21:41,740
0,90 90,300 300,420 420,540 540,720
the things,| that we ran
|我们在构建 Biscuit 过程中的东西，

783
00:21:41,740 --> 00:21:43,720
0,450 450,840 840,1140 1140,1530 1590,1980
into while building Biscuit things,|
|

784
00:21:43,720 --> 00:21:45,010
0,180 180,390 390,1050 1050,1140 1140,1290
that we anticipated in some
我们遇到一些没有预料到的东西。

785
00:21:45,010 --> 00:21:45,640
0,150 150,240 240,300 300,510 510,630
things that we actually did

786
00:21:45,640 --> 00:21:46,920
0,210 210,810
not anticipate.|
|

787
00:21:48,360 --> 00:21:50,220
0,540 630,900 900,1170 1170,1530 1530,1860
So the user programs,| there's
所以用户程序，|这里有一个传统内核，

788
00:21:50,220 --> 00:21:52,500
0,60 60,660 690,1470 1530,1770 1770,2280
a classic kernel,| a monolithic
|一个与 Linux 或 xv6 相同的宏内核，

789
00:21:52,500 --> 00:21:53,430
0,390 390,450 450,510 510,750 750,930
kernel in the same way

790
00:21:53,430 --> 00:21:55,170
0,270 300,660 660,780 780,960 960,1740
to Linux or {xv6's -},|
|

791
00:21:55,320 --> 00:21:56,580
0,180 180,300 300,480 480,750 750,1260
and so there's user space
所以这里有用户空间和内核空间，

792
00:21:56,580 --> 00:21:58,860
0,240 300,570 570,1170 1380,2010 2010,2280
and kernel space,| {} user
|用户空间程序是，

793
00:21:58,860 --> 00:22:00,900
0,300 300,810 810,1290 1320,1920 1920,2040
space programs are| {} you
|比如你的编译器 GCC ，

794
00:22:00,900 --> 00:22:03,210
0,60 60,480 750,960 960,1530 1530,2310
know whatever your compiler GCC|
|

795
00:22:03,210 --> 00:22:04,350
0,240 240,330 330,600 630,1020 1020,1140
or in our speaking of
或者在我们的论文中，它是一个网络服务器，

796
00:22:04,350 --> 00:22:05,730
0,450 450,570 570,690 690,1140 1140,1380
paper {} it's mostly a

797
00:22:05,730 --> 00:22:08,130
0,210 210,930 930,1380 1590,1860 1860,2400
web server,| and some other
|以及其他一些基准。

798
00:22:08,130 --> 00:22:09,220
0,720
benchmarks.|
|

799
00:22:09,250 --> 00:22:10,930
0,420 420,870 870,1140 1140,1350 1350,1680
{} And the user programs
用户程序都是用 C 语言编写的，

800
00:22:10,930 --> 00:22:12,310
0,150 150,780 780,1020 1020,1260 1260,1380
are actually all written in

801
00:22:12,310 --> 00:22:13,450
0,510 510,780 780,870 870,1020 1020,1140
C,| although it could be
|尽管它可以是任何语言编写的，

802
00:22:13,450 --> 00:22:14,770
0,390 390,480 480,690 690,1200 1200,1320
principal in any language,| you
|因为它们只是一个基准，

803
00:22:14,770 --> 00:22:15,790
0,270 270,540 540,750 750,960 960,1020
know since they're just a

804
00:22:15,790 --> 00:22:18,550
0,810 1410,1800 1800,1950 1950,2130 2130,2760
benchmark,| we took C versions,|
|我们采用 C 语言版本，|

805
00:22:18,940 --> 00:22:20,410
0,570 570,870 870,930 930,1050 1050,1470
and most of the programs
并且多数程序都是多线程的，

806
00:22:20,410 --> 00:22:22,390
0,270 270,540 540,900 900,1350 1380,1980
are {multi-thread -},| so unlike
|所以，与 xv6 中每个用户程序只有一个线程不同，

807
00:22:22,390 --> 00:22:24,280
0,690 720,990 990,1290 1290,1530 1530,1890
in {xv6 -} where basically

808
00:22:24,280 --> 00:22:25,510
0,180 180,420 420,780 780,1020 1020,1230
there's one thread per user

809
00:22:25,510 --> 00:22:28,180
0,630 690,1650 1650,1950 1950,2280 2280,2670
program,| {} in Biscuit, actually
|在 Biscuit 中，支持多个用户线程。

810
00:22:28,180 --> 00:22:30,850
0,390 390,1080 1230,1710 1710,2190 2190,2670
support multiple {} {user,level} threads.|
|

811
00:22:31,780 --> 00:22:33,550
0,450 630,960 960,1350 1350,1500 1500,1770
{} And basically for every
对于每个用户线程，

812
00:22:33,550 --> 00:22:35,170
0,270 270,540 540,990 1200,1560 1560,1620
user level thread,| there's {}
|在内核中都有相应的内核线程，

813
00:22:35,170 --> 00:22:38,380
0,810 810,1200 1200,1680 1710,2370 2370,3210
corresponding kernel thread in {}

814
00:22:38,410 --> 00:22:40,900
0,630 810,1530 1530,1980 1980,2280 2280,2490
kernel,| and this kernel threads
|这些内核线程是由 Go 实现的，

815
00:22:40,900 --> 00:22:42,640
0,90 90,360 360,900 900,1440 1470,1740
are actually implemented by Go

816
00:22:42,640 --> 00:22:44,170
0,600 600,900 900,1080 1080,1380 1380,1530
itself| and Go calls these
|Go 调用 Go 例程，

817
00:22:44,170 --> 00:22:45,480
0,210 210,900
Go routines,|
|

818
00:22:47,970 --> 00:22:48,750
0,180 180,270 270,420 420,600 600,780
you can think about Go
你可以把 Go 例程看作普通线程，

819
00:22:48,750 --> 00:22:50,730
0,480 480,750 750,960 960,1500 1500,1980
routines just as ordinary threads|
|

820
00:22:50,760 --> 00:22:51,870
0,270 270,330 330,630 630,930 930,1110
in the same way that
与 xv6 相同的方式，内核具有线程，

821
00:22:51,870 --> 00:22:52,830
0,240 240,600 600,780 780,870 870,960
{xv6 -} has and the

822
00:22:52,830 --> 00:22:56,280
0,540 540,780 780,1350 1470,2940 2940,3450
kernel has threads { -},|
|

823
00:22:57,540 --> 00:22:59,070
0,240 240,420 420,720 720,990 990,1530
the Go routines are similar,|
Go 协程是类似的，|

824
00:22:59,190 --> 00:23:00,660
0,240 240,510 510,870 870,1080 1080,1470
the main difference it correctly
主要的区别是，

825
00:23:00,660 --> 00:23:02,100
0,120 120,480 480,810 810,1020 1020,1440
is that,| in {xv6 -}
|在 xv6 中，线程是由内核实现的，

826
00:23:02,100 --> 00:23:03,210
0,210 210,360 360,600 600,690 690,1110
{you,know} the threads are implemented

827
00:23:03,210 --> 00:23:04,770
0,90 90,180 180,540 540,1170 1320,1560
by the kernel itself,| and
|在这种情况下，是由 Go 运行时提供的，

828
00:23:04,770 --> 00:23:06,060
0,90 90,240 240,630 630,1020 1020,1290
in this case {you,know} Go

829
00:23:06,060 --> 00:23:08,250
0,540 540,870 870,1290 1290,1380 1860,2190
runtime basically provides,| the Go
|Go 运行时调度它们，

830
00:23:08,250 --> 00:23:10,230
0,390 390,840 840,1260 1470,1800 1800,1980
runtime {schedules,them},| {} Go {runtime
|Go 运行时支持睡眠唤醒或条件变量，

831
00:23:10,230 --> 00:23:11,820
0,210 210,390 390,840 840,1290 1320,1590
-} has support for things

832
00:23:11,820 --> 00:23:13,200
0,150 150,450 450,930 930,1020 1020,1380
like sleep wakeup or condition

833
00:23:13,200 --> 00:23:14,490
0,570 570,780 780,930 930,1020 1020,1290
variables,| there's lots of different
|有不同的睡眠唤醒，

834
00:23:14,490 --> 00:23:15,540
0,270 270,510 510,690 690,840 840,1050
sleep {wakeup -},| but there's
|但有一些条件变量同步机制，

835
00:23:15,540 --> 00:23:17,310
0,150 150,510 510,1140 1350,1560 1560,1770
some condition variable {synchronization -

836
00:23:17,310 --> 00:23:19,140
0,180 180,300 300,1110 1410,1680 1680,1830
- -} mechanism,| and there's
|还有很多原语，

837
00:23:19,140 --> 00:23:19,890
0,30 30,150 150,300 300,360 360,750
a whole bunch of other

838
00:23:19,890 --> 00:23:20,880
0,60 60,210 210,450 450,840 840,990
you know things primitive,| and
|Go 运行时 Go 语言本身提供，

839
00:23:20,880 --> 00:23:22,320
0,180 180,360 360,630 630,840 840,1440
Go {runtime -} just provided

840
00:23:22,320 --> 00:23:23,790
0,210 210,330 330,510 510,840 840,1470
by the Go language itself,|
|

841
00:23:23,790 --> 00:23:24,690
0,240 240,330 330,510 510,750 750,900
and you have not been
不是由 Biscuit 本身实现的，

842
00:23:24,690 --> 00:23:26,370
0,540 570,960 960,1290 1290,1590 1590,1680
implemented by Biscuit itself,| we
|我们只是从 Go 运行时获得它们。

843
00:23:26,370 --> 00:23:27,210
0,180 180,390 390,540 540,750 750,840
just get them from the

844
00:23:27,210 --> 00:23:28,100
0,180 180,630
Go runtime.|
|

845
00:23:29,440 --> 00:23:30,620
0,600
The
GO 运行时本身直接在裸硬件上运行。

846
00:23:30,620 --> 00:23:32,120
0,240 240,420 420,600 600,1080 1110,1500
Go {runtime -} itself runs

847
00:23:32,120 --> 00:23:33,470
0,420 420,510 510,570 570,840 840,1350
directly on the bare hardware.|
|

848
00:23:36,400 --> 00:23:37,240
0,210 210,450 450,630 630,660 660,840
And, I'll talk a little
我会在课程中更多地谈到这一点，

849
00:23:37,240 --> 00:23:39,430
0,150 150,420 420,750 810,1530 1560,2190
bit about that {} more

850
00:23:39,460 --> 00:23:41,350
0,210 210,300 300,930 1050,1620 1620,1890
in the lecture,| {} but
|但你可以认为这是机器启动，

851
00:23:41,350 --> 00:23:42,160
0,150 150,300 300,420 420,600 600,810
like so you think about

852
00:23:42,160 --> 00:23:43,180
0,180 180,270 270,360 360,660 660,1020
this is the machine boots,|
|

853
00:23:43,180 --> 00:23:43,870
0,90 90,240 240,330 330,570 570,690
you know the first thing
第一件事就是启动到 Go 运行时，

854
00:23:43,870 --> 00:23:44,830
0,90 90,330 330,630 630,750 750,960
it actually boots to Go

855
00:23:44,830 --> 00:23:47,110
0,480 1170,1710 1710,1890 1890,2190 2190,2280
runtime,| does it cause a
|这带来了很多复杂情况，

856
00:23:47,110 --> 00:23:48,610
0,120 120,210 210,870 870,1290 1290,1500
lot of complications,| because Go
|因为通常 Go 运行时作为用户程序运行在用户空间，

857
00:23:48,610 --> 00:23:49,840
0,180 180,330 330,750 750,1080 1080,1230
runtime that normally runs in

858
00:23:49,840 --> 00:23:51,280
0,240 240,750 870,930 930,1200 1200,1440
user space as user level

859
00:23:51,280 --> 00:23:52,720
0,570 570,840 840,1230 1230,1350 1350,1440
program| and assumes that the
|假设有一个内核，

860
00:23:52,720 --> 00:23:54,130
0,450 450,600 600,690 690,960 960,1410
kernel there's a kernel there,|
|

861
00:23:54,130 --> 00:23:55,390
0,210 210,360 360,600 600,690 690,1260
we can ask some services,|
我们可以请求一些服务，|

862
00:23:55,390 --> 00:23:56,530
0,180 180,510 510,720 720,780 780,1140
for example, needs to allocate
比如，需要为其堆分配内存。

863
00:23:56,530 --> 00:23:57,660
0,390 390,720
memory to,

864
00:23:57,660 --> 00:23:59,680
0,660 690,960 960,1110 1110,1530
{} for its heap.|
|

865
00:23:59,710 --> 00:24:00,550
0,360 360,540 540,660 660,780 780,840
{} And so there's a
所以这里有一些，

866
00:24:00,550 --> 00:24:01,810
0,180 180,330 330,480 480,1080 1080,1260
little bit of, {} all

867
00:24:01,810 --> 00:24:02,590
0,150 150,210 210,390 390,540 540,780
talk a little bit about,|
|

868
00:24:02,590 --> 00:24:03,190
0,150 150,270 270,330 330,480 480,600
that there's a little bit
有一些垫片代码，

869
00:24:03,190 --> 00:24:05,530
0,90 90,480 480,1050 1080,2340 2340,2340
of shim {code -},| the
|Biscuit 用来欺骗 Go 进行时，

870
00:24:05,770 --> 00:24:08,260
0,450 450,900 990,1230 1230,1830 1860,2490
Biscuit has to basically trick

871
00:24:08,290 --> 00:24:09,730
0,90 90,600 600,780 780,1050 1050,1440
you know Go runtime| into
|使其相信它运行在操作系统之上，

872
00:24:09,730 --> 00:24:10,690
0,450 450,570 570,690 690,870 870,960
believing that it runs on

873
00:24:10,690 --> 00:24:11,920
0,210 210,300 300,450 450,930 930,1230
top of the operating system,|
|

874
00:24:11,920 --> 00:24:12,700
0,210 210,330 330,420 420,660 660,780
even though it's running on
即使它是在裸硬件上运行，

875
00:24:12,700 --> 00:24:13,800
0,210 210,630
bare hardware,|
|

876
00:24:14,050 --> 00:24:15,340
0,180 180,540 540,780 780,870 870,1290
and basically get the boot.|
获得启动。|

877
00:24:16,360 --> 00:24:17,320
0,390 390,540 540,630 630,720 720,960
{} And then the kernel
然后内核本身跟 xv6 非常相似，

878
00:24:17,320 --> 00:24:19,120
0,630 630,720 720,930 930,1290 1320,1800
itself, you know it's very

879
00:24:19,120 --> 00:24:20,830
0,420 420,540 540,810 810,1140 1140,1710
similar, you think {xv6 -},|
|

880
00:24:20,890 --> 00:24:22,600
0,300 300,480 480,990 990,1350 1350,1710
think there's a model,| except
想象有一种模型，|不过它更复杂，性能更高，

881
00:24:22,600 --> 00:24:23,710
0,180 180,240 240,390 390,540 540,1110
it's a little bit more

882
00:24:23,740 --> 00:24:25,690
0,750 750,990 990,1290 1290,1440 1440,1950
elaborate and more high performance,|
|

883
00:24:25,690 --> 00:24:26,650
0,210 210,300 300,390 390,660 660,960
it has some virtual memory
它有虚拟内存系统，

884
00:24:26,650 --> 00:24:27,610
0,540 540,630 630,750 750,900 900,960
system,| you know that for
|比如，你这周要做的 mmap 实验，

885
00:24:27,610 --> 00:24:29,740
0,330 330,720 720,870 870,1350
example implements {mmap -}

886
00:24:29,740 --> 00:24:31,030
0,420 420,540 540,750 750,900 900,1290
lab you're doing this week,|
|

887
00:24:31,060 --> 00:24:32,290
0,240 240,420 420,480 480,780 780,1230
it has a file system,|
它有一个文件系统，|

888
00:24:32,290 --> 00:24:33,580
0,300 300,450 450,720 720,900 900,1290
like there's more high performance
有更高性能的文件系统，

889
00:24:33,580 --> 00:24:35,320
0,270 270,900 1290,1500 1500,1680 1680,1740
file system,| it has a
|它有一些驱动，

890
00:24:35,320 --> 00:24:36,460
0,240 240,300 300,930 930,1050 1050,1140
couple of drivers,| you know
|它有磁盘驱动，

891
00:24:36,460 --> 00:24:37,450
0,120 120,270 270,330 330,630 630,990
it has a disk drive|
|

892
00:24:37,450 --> 00:24:38,860
0,240 240,450 450,810 810,1320 1320,1410
and {it,has,a} network driver, it
它有网络驱动，有网络堆栈，

893
00:24:38,860 --> 00:24:40,630
0,150 150,360 360,690 690,1230 1260,1770
has a network stack {},|
|

894
00:24:41,180 --> 00:24:42,200
0,330 330,630 690,840 840,930 930,1020
{} so it will be
所以它会更完整，

895
00:24:42,200 --> 00:24:43,310
0,120 120,510 510,840 840,1020 1020,1110
more complete,| and when you
|你可以看到，它有大概 58 个系统调用，

896
00:24:43,310 --> 00:24:45,230
0,150 150,360 360,750 750,1140 1410,1920
can see that is, {it,has}

897
00:24:45,230 --> 00:24:46,760
0,180 180,600 600,870 870,1440 1440,1530
like 58 system calls,| you
|我记不清 xv6 有多少了，

898
00:24:46,760 --> 00:24:48,500
0,270 270,840 990,1020 1230,1470 1470,1740
know like I can't remember

899
00:24:48,500 --> 00:24:49,610
0,90 90,300 300,570 570,960 960,1110
how much {xv6,has -},| but
|但应该是 18 或 19 个左右。

900
00:24:49,610 --> 00:24:51,530
0,450 450,540 540,870 870,990 990,1920
[startling] the order of {18,19,or}

901
00:24:51,530 --> 00:24:52,860
0,240 240,390 390,720
something like that.|
|

902
00:24:52,860 --> 00:24:54,150
0,390 390,660 660,750 750,1020 1020,1290
{} And the total number
启动代码的总数是 28000 个，

903
00:24:54,150 --> 00:24:56,250
0,360 360,630 630,1170 1200,1650 1650,2100
of launch code {is,28000},| {you,know,xv6
|xv6 我想是在 10000 以下，

904
00:24:56,250 --> 00:24:58,560
0,1260 1260,1530 1530,1740 1740,2010 2010,2310
- -} is like not

905
00:24:58,560 --> 00:25:00,030
0,180 180,420 780,900 900,1140 1140,1470
in, {} {I,think} below 10000,|
|

906
00:25:00,030 --> 00:25:01,740
0,990 1110,1260 1260,1380 1380,1530 1530,1710
so you know there's more
所以这里有更多功能。

907
00:25:01,740 --> 00:25:02,780
0,540
features.|
|

908
00:25:04,580 --> 00:25:05,960
0,180 180,480 480,690 690,960 960,1380
Any questions about {sort,of,this} high-level
关于这个高级别的概述，有什么问题吗？

909
00:25:05,960 --> 00:25:07,180
0,690
overview?|
|

910
00:25:08,470 --> 00:25:09,640
0,300 300,660 660,780 780,1050 1050,1170
Oh, sorry I wanted to
哦，抱歉，我想问一下接口的事，

911
00:25:09,640 --> 00:25:11,590
0,210 210,450 450,780 810,1170 1170,1950
ask about the the interface,|
|

912
00:25:11,620 --> 00:25:13,330
0,420 450,720 720,1200 1200,1470 1470,1710
so the interface is just
所以接口像 xv6 一样，是吗，

913
00:25:13,330 --> 00:25:15,400
0,330 360,870 870,1140 1140,1560 1560,2070
like {xv6 -}, right,| so
|进程必须把一些东西放在某些寄存器上，

914
00:25:15,580 --> 00:25:18,070
0,510 930,1680 1680,2010 2040,2340 2340,2490
the processes they have to

915
00:25:18,070 --> 00:25:20,650
0,360 360,960 1230,1530 1530,1800 1800,2580
put something in some register

916
00:25:20,680 --> 00:25:22,060
0,360 360,540 540,960
{}| and then
|然后它们调用 ecall ，或者不管它是什么。

917
00:25:22,060 --> 00:25:24,250
0,450 510,930 930,1290 1290,1830 1860,2190
they call the ecall or

918
00:25:24,400 --> 00:25:25,690
0,330 330,450 450,660 660,1140 1140,1290
whatever it is.| Yeah, yeah
|是的，我会再多说一点，

919
00:25:25,690 --> 00:25:26,470
0,240 240,420 420,480 480,630 630,780
I'll talk a little bit

920
00:25:26,470 --> 00:25:27,190
0,180 180,390 390,510 510,630 630,720
more about this,| but it's
|但它是完全一样的，没有什么不同。

921
00:25:27,190 --> 00:25:28,510
0,360 360,420 420,840 900,1200 1200,1320
exactly the same, there's no

922
00:25:28,510 --> 00:25:29,500
0,510
difference.|
|

923
00:25:29,530 --> 00:25:30,970
0,300 300,420 420,720 750,1020 1020,1440
Okay I see, thank you.|
好的，我明白了，谢谢。|

924
00:25:32,860 --> 00:25:33,880
0,330 330,660 660,840 840,960 960,1020
{} So some of the
你知道的一些功能已经提过了，

925
00:25:33,880 --> 00:25:35,380
0,570 570,690 690,1020 1020,1320 1320,1500
features {you,know} already mentioned them

926
00:25:35,380 --> 00:25:36,850
0,90 90,270 270,690 690,1080 1080,1470
a little bit,| maybe worth
|或许值得一谈的是它的多核，

927
00:25:36,850 --> 00:25:38,920
0,0 0,1140 1140,1470 1590,1800 1800,2070
a talking about its multi

928
00:25:38,920 --> 00:25:40,750
0,480 840,1140 1140,1260 1260,1410 1410,1830
core,| Go with good support
|带上对并发的良好支持，这样您就知道了饼干的多核

929
00:25:40,750 --> 00:25:42,640
0,630 660,780 780,1380 1380,1620 1620,1890
for {concurrency -} and so

930
00:25:42,640 --> 00:25:44,140
0,120 120,300 480,870 870,1110 1110,1500
you know Biscuit's {multi-core -}|
|

931
00:25:44,260 --> 00:25:45,310
0,210 210,300 300,540 540,750 750,1050
in the same way that
以同样方式，xv6对多核的支持也是有限的，

932
00:25:45,310 --> 00:25:46,960
0,810 810,1140 1140,1380 1380,1590 1590,1650
{} {xv6 -} sort of

933
00:25:46,960 --> 00:25:48,790
0,480 600,1170 1170,1500 1500,1590 1590,1830
has limited support for {multi-core

934
00:25:48,790 --> 00:25:50,470
0,390 480,990 990,1230 1230,1440 1440,1680
-},| {} in this we
|在这方面，我们实际上比xv6拥有更细粒度的同步或协调。

935
00:25:50,470 --> 00:25:51,430
0,90 90,180 180,330 330,480 480,960
have a little bit more

936
00:25:51,430 --> 00:25:53,740
0,480 480,1230 1230,1470 1470,2130 2130,2310
fine-grained synchronization or coordination than

937
00:25:53,740 --> 00:25:55,440
0,420 420,570 570,1290
actually in xv6.|
|

938
00:25:55,500 --> 00:25:56,670
0,180 180,390 390,540 540,1020 1020,1170
{} It has threads you
它有你知道的用户级线程，由内核线程备份，

939
00:25:56,670 --> 00:25:59,670
0,300 300,810 810,1320 1380,2070 2370,3000
know {user,level} threads, {} backed

940
00:25:59,670 --> 00:26:01,920
0,210 210,780 810,1170 1170,1680 1980,2250
up by kernel threads {},|
|

941
00:26:01,920 --> 00:26:04,260
0,300 300,900 900,1200 1200,1650 1980,2340
which xv6 doesn't have,| there's
这是xv6没有的|日志文件系统的性能要高得多，

942
00:26:04,260 --> 00:26:05,370
0,300 300,540 540,840 840,930 930,1110
journal file system a much

943
00:26:05,370 --> 00:26:06,810
0,270 270,780 780,960 960,1350 1350,1440
higher performance,| you think you
|你以为你知道你被称为ext3报纸吗？

944
00:26:06,810 --> 00:26:08,430
0,150 150,810 810,1110 1110,1290 1290,1620
know you're called the {ext3

945
00:26:08,430 --> 00:26:10,050
0,240 240,810 1020,1320 1320,1500 1500,1620
-} paper| {} sort of
|有点像您所知道的ext3，它通常是一个文件系统。

946
00:26:10,050 --> 00:26:11,010
0,300 300,390 390,510 510,630 630,960
like you know the {ext3

947
00:26:11,010 --> 00:26:12,840
0,540 600,1020 1020,1380 1380,1560 1560,1830
-} a {generally -} file

948
00:26:12,840 --> 00:26:13,600
0,390
system.|
|

949
00:26:14,000 --> 00:26:15,350
0,540 540,690 690,1110 1110,1200 1200,1350
{} It has, you know
它有，你知道，相当合理，复杂的存储系统，使用DMA，

950
00:26:15,380 --> 00:26:17,930
0,330 360,930 930,1590 1590,1950 1950,2550
quite reasonable, sophisticated memory system,

951
00:26:17,960 --> 00:26:20,900
0,570 570,1440 1530,2010 2010,2760 2760,2940
using DMAs,| {} and you
|你知道我可以支持mmap之类的东西。

952
00:26:20,900 --> 00:26:21,740
0,90 90,210 210,330 330,720 720,840
know I could support {mmap

953
00:26:21,740 --> 00:26:22,760
0,240 240,330 330,450 450,630 630,1020
-} and all that stuff.|
|

954
00:26:23,270 --> 00:26:24,710
0,150 150,420 420,750 750,1050 1050,1440
It has a complete {TCP/IP
它有一个完整的TCP/IP协议栈，

955
00:26:24,710 --> 00:26:25,670
0,90 90,450 450,540 540,780 780,960
-} stack,| you know good
|您知道的足够清楚，可以通过Internet与其他网络服务器进行实际通信

956
00:26:25,670 --> 00:26:26,960
0,240 240,360 360,870 900,1200 1200,1290
enough to actually talk to

957
00:26:26,960 --> 00:26:28,880
0,480 510,1230 1230,1560 1560,1830 1830,1920
other network servers across the

958
00:26:28,880 --> 00:26:30,920
0,450 600,870 870,990 990,1350 1350,2040
Internet| and it has two
|它有两个高性能的驱动器，

959
00:26:31,130 --> 00:26:33,230
0,720 720,930 930,1200 1200,1590 1590,2100
drivers with high performance drivers,|
|

960
00:26:33,230 --> 00:26:34,280
0,210 210,390 390,450 450,690 690,1050
so like a ten gigabit
因此，就像一个万兆网卡，

961
00:26:34,280 --> 00:26:36,140
0,450 720,1320 1320,1470 1470,1590 1620,1860
NIC,| {} in the next
|在接下来的一圈里，你实际上可以为一个非常非常简单的网卡实现一个很小的驱动程序，

962
00:26:36,140 --> 00:26:37,250
0,240 240,330 330,450 450,780 780,1110
lap, you can actually implement

963
00:26:37,250 --> 00:26:38,360
0,30 30,270 270,750 750,1020 1020,1110
a little driver for a

964
00:26:38,360 --> 00:26:40,460
0,420 420,690 690,1410 1410,1770 1770,2100
very very simple NIC,| this
|这是一个更高性能和更复杂的驱动程序。

965
00:26:40,460 --> 00:26:41,240
0,60 60,150 150,390 390,600 600,780
is a much more high

966
00:26:41,240 --> 00:26:43,740
0,660 660,870 900,1590 1590,2100
performance and sophisticated driver.|
|

967
00:26:43,770 --> 00:26:44,850
0,210 210,270 270,360 360,540 540,1080
And in a pretty sophisticated
在一个相当复杂的驱动程序中，它比VIRTIO_DISK驱动程序更复杂，

968
00:26:44,850 --> 00:26:47,070
0,180 180,960 1020,1200 1200,1590 1590,2220
this driver, {} more sophisticated

969
00:26:47,070 --> 00:26:48,840
0,180 180,240 240,780 780,990 1230,1770
than the {VIRTIO_disk - -

970
00:26:48,840 --> 00:26:51,030
0,150 150,660 840,1410 1410,1620 1620,2190
-} driver,| {} that you've
|你可能在实验室里见过或者看过的东西。

971
00:26:51,060 --> 00:26:52,620
0,210 210,270 270,570 570,960 1380,1560
sort of seen or you

972
00:26:52,620 --> 00:26:54,540
0,150 150,810 870,1170 1170,1440
might have looked at

973
00:26:55,000 --> 00:26:56,660
0,450 480,630 630,720 720,1140
{} in the labs.|
|

974
00:26:58,110 --> 00:26:59,360
0,630

975
00:27:00,670 --> 00:27:01,980
0,390 390,750

976
00:27:06,680 --> 00:27:09,080
0,630 900,1320 1320,1770 1770,2040 2040,2400
{} So in terms of,
那么就我前面提到的一个用户程序来讲，

977
00:27:09,080 --> 00:27:10,670
0,600 660,960 960,1440 1440,1560 1560,1590
a user programs as I

978
00:27:10,670 --> 00:27:12,200
0,300 300,690 690,900 900,1140 1140,1530
mentioned before,| every user program
|每个用户程序运行其自己的页表、由硬件隔离的用户内核存储器

979
00:27:12,200 --> 00:27:13,700
0,240 240,480 480,630 630,900 900,1500
runs its own page table,

980
00:27:14,000 --> 00:27:16,310
0,720 720,990 990,1230 1230,1650 1650,2310
{} user kernel memory isolated

981
00:27:16,310 --> 00:27:18,290
0,150 150,660 660,1020 1020,1770 1770,1980
by hardware,| so you use
|所以基本上你使用的是内核位，

982
00:27:18,290 --> 00:27:20,720
0,60 60,360 360,600 600,1290
a kernel bit basically,|
|

983
00:27:20,780 --> 00:27:22,340
0,660 660,930 930,1170 1170,1380 1380,1560
and every user thread has
并且每个用户线程都有对应的内核线程，

984
00:27:22,340 --> 00:27:25,250
0,30 30,870 870,2220 2250,2610 2610,2910
a corresponding {} kernel thread,|
|

985
00:27:25,250 --> 00:27:26,120
0,210 210,330 330,660 660,810 810,870
so for example when a
例如，当用户线程进行系统调用时，它将继续在相应的内核线程上运行，

986
00:27:26,120 --> 00:27:27,110
0,210 210,450 450,630 630,690 690,990
user thread makes a system

987
00:27:27,110 --> 00:27:28,940
0,600 720,900 900,990 990,1380 1380,1830
call, it will continue running

988
00:27:28,940 --> 00:27:31,460
0,360 360,1140 1170,1740 1740,2100 2100,2520
on the corresponding kernel thread,|
|

989
00:27:31,640 --> 00:27:32,600
0,330 330,450 450,510 510,780 780,960
and if the system call
如果系统调用阻塞，

990
00:27:32,600 --> 00:27:34,070
0,480 480,660 660,990 990,1170 1170,1470
blocks,| then another user thread
|则相同地址空间和用户地址空间中的另一个用户线程实际上可能由内核调度。

991
00:27:34,070 --> 00:27:35,120
0,90 90,180 180,420 420,690 690,1050
in the same address space

992
00:27:35,120 --> 00:27:36,140
0,150 150,390 390,630 630,810 810,1020
and the user address space

993
00:27:36,140 --> 00:27:37,460
0,210 210,600 600,750 750,1200 1200,1320
might actually be scheduled by

994
00:27:37,460 --> 00:27:38,300
0,60 60,450
the kernel.|
|

995
00:27:38,990 --> 00:27:40,520
0,480 480,630 630,750 750,1020 1020,1530
{} And as mentioned early
如前所述，早期内核线程是由Go运行时提供的，因此它们只是Go例程。

996
00:27:40,550 --> 00:27:43,040
0,570 570,1110 1200,1950 1950,2370 2370,2490
{kernel,threads} are provided by the

997
00:27:43,040 --> 00:27:44,360
0,240 240,810 840,1050 1050,1170 1170,1320
Go runtime and so they

998
00:27:44,360 --> 00:27:45,820
0,210 210,390 390,990
just Go routines.|
|

999
00:27:46,070 --> 00:27:47,870
0,180 180,360 360,570 570,1080 1410,1800
So you're right ever {}
因此，如果您曾经在Go中编写过用户级别的应用程序，那么您就是永远的用户级别

1000
00:27:47,870 --> 00:27:48,890
0,300 300,420 420,540 540,810 810,1020
{user,level}, if you ever written

1001
00:27:48,890 --> 00:27:50,690
0,120 120,600 600,1140 1140,1440 1440,1800
a {user,level} application in {}

1002
00:27:50,720 --> 00:27:52,820
0,450 450,840 840,1260 1260,1590 1590,2100
Go| and using Go and
|并使用GO和用于GO调用来创建线程，

1003
00:27:52,820 --> 00:27:54,170
0,330 330,420 420,810 840,1230 1230,1350
used to Go call to

1004
00:27:54,170 --> 00:27:55,850
0,360 360,840 840,1320 1470,1590 1590,1680
create a thread,| you know
|你知道，那些围棋程序实际上是饼干内核使用的程序。

1005
00:27:55,850 --> 00:27:57,500
0,270 270,780 810,1140 1140,1290 1290,1650
that those those Go routines

1006
00:27:57,500 --> 00:27:58,100
0,90 90,180 180,390 390,480 480,600
are the ones that were

1007
00:27:58,100 --> 00:27:58,910
0,180 180,360 360,600 600,720 720,810
actually being used by the

1008
00:27:58,910 --> 00:28:00,000
0,210 210,720
Biscuit kernel.|
|

1009
00:28:02,410 --> 00:28:03,790
0,270 270,480 480,630 630,900 900,1380
So talking about system calls,|
所以说到系统调用，|

1010
00:28:03,790 --> 00:28:04,690
0,120 120,270 270,420 420,780 780,900
you know this question is
你知道这个问题是刚刚被问到的，

1011
00:28:04,690 --> 00:28:08,050
0,750 1080,1440 1440,2670 2970,3180 3180,3360
{} just asked,| so it
|因此，它的工作原理与在xv6中大致相同。

1012
00:28:08,050 --> 00:28:10,060
0,210 210,690 690,1050 1080,1890 1890,2010
works exactly as roughly you

1013
00:28:10,060 --> 00:28:11,740
0,120 120,510 510,780 780,1320 1320,1680
know as in {} {xv6

1014
00:28:11,740 --> 00:28:13,000
0,450 450,570 570,780 780,900 900,1260
-}| you know the user
|您知道使用小库的寄存器中的用户[输入]参数，

1015
00:28:13,000 --> 00:28:15,370
0,330 330,720 720,870 870,1590 1980,2370
[input] arguments in registers {}

1016
00:28:15,370 --> 00:28:17,470
0,270 270,360 360,750 750,1380 1380,2100
using a little {} library,|
|

1017
00:28:17,470 --> 00:28:19,270
0,150 150,300 300,510 510,960 960,1800
you know that provides {}
您知道，它提供了系统调用接口，

1018
00:28:19,780 --> 00:28:21,400
0,210 210,480 480,630 630,1200 1200,1620
{} system call interface {},|
|

1019
00:28:21,400 --> 00:28:23,140
0,300 300,630 630,870 870,1200 1200,1740
then the user threads executed
然后用户线程执行SYSENTER调用，

1020
00:28:23,140 --> 00:28:24,280
0,210 210,450 450,900 900,1020 1020,1140
{SYSENTER -} call,| you know
|您知道这款饼干在x86处理器上运行，而不是在RISC-V处理器上运行，

1021
00:28:24,280 --> 00:28:25,300
0,450
this

1022
00:28:25,300 --> 00:28:26,950
0,360 390,780 780,930 930,1050 1050,1650
Biscuit runs on an x86

1023
00:28:26,950 --> 00:28:28,510
0,540 540,930 930,1230 1230,1320 1320,1560
processor not on the RISC-V

1024
00:28:28,510 --> 00:28:30,220
0,540 540,630 630,750 750,1140 1140,1710
processor,| so the assembly instructions
|因此，实际损坏其系统内核的汇编指令与RISC-V上的RISC-V略有不同。

1025
00:28:30,220 --> 00:28:31,750
0,360 360,690 690,1050 1050,1170 1170,1530
for actually injuring their system

1026
00:28:31,750 --> 00:28:33,580
0,600 600,690 690,1080 1080,1590 1590,1830
kernel are slightly different than

1027
00:28:33,580 --> 00:28:34,720
0,180 180,270 270,510 510,870 870,1140
on the {RISC-V -} on

1028
00:28:34,720 --> 00:28:36,020
0,180 180,360 360,750
the {RISC-V -}.|
|

1029
00:28:36,280 --> 00:28:37,750
0,570 570,840 840,960 960,1050 1050,1470
Yeah, but you know roughly
是的，但是你知道大致类似于RISC-V

1030
00:28:37,750 --> 00:28:39,670
0,390 390,960 1050,1290 1290,1650 1650,1920
similar similar {} to {}

1031
00:28:39,790 --> 00:28:41,290
0,480 480,570 570,780 780,1140 1140,1500
RISC-V| and then control passes
|然后将控制权传递给运行该用户线程的内核线程

1032
00:28:41,290 --> 00:28:43,620
0,270 270,600 780,1320 1320,1770
to the kernel thread,

1033
00:28:43,650 --> 00:28:45,270
0,210 210,600 660,1170 1170,1470 1470,1620
{} that was running that

1034
00:28:45,270 --> 00:28:46,830
0,210 210,240 240,660 1080,1260 1260,1560
{user -} thread| and then
|然后内核线程执行系统调用，

1035
00:28:46,830 --> 00:28:48,090
0,60 60,570 570,810 810,1200 1200,1260
the kernel thread executes a

1036
00:28:48,090 --> 00:28:49,440
0,270 270,630 630,750 750,870 870,1350
system call,| and then returns
|然后回到SYSEXIT这里。

1037
00:28:49,440 --> 00:28:51,080
0,300 300,420 420,690 690,1140
here in {SYSEXIT -}.|
|

1038
00:28:51,180 --> 00:28:52,590
0,300 300,660 660,990 990,1350 1350,1410
So roughly similar frame, you
所以大致相似的框架，你知道它是一个正在建造的陷井框架，诸如此类的东西。

1039
00:28:52,590 --> 00:28:53,490
0,120 120,270 270,330 330,660 660,900
know it's a {trapframe -}

1040
00:28:53,490 --> 00:28:54,480
0,180 180,360 360,780 780,870 870,990
that's being built and all

1041
00:28:54,480 --> 00:28:55,720
0,120 120,270 270,330 330,690
that kind of stuff.|
|

1042
00:28:57,910 --> 00:28:59,160
0,720
Okay.|
好吧。|

1043
00:29:01,040 --> 00:29:02,860
0,210 210,600 600,930 930,1350
Any questions so far,|
到目前为止有什么问题吗，|

1044
00:29:02,950 --> 00:29:04,090
0,390 390,450 450,750 750,960 960,1140
before I dive into sort
在我深入讨论更多的事情之前

1045
00:29:04,090 --> 00:29:05,200
0,90 90,390 390,690 690,900 900,1110
of a more sort of

1046
00:29:05,350 --> 00:29:07,040
0,510 510,660 660,1170
things| that were
|这是意想不到的，也是意料之中的，但我们比我认为的xv6更具挑战性。

1047
00:29:07,040 --> 00:29:08,600
0,630 630,720 720,1230 1230,1440 1440,1560
unexpected or expected, but we're

1048
00:29:08,600 --> 00:29:09,560
0,60 60,210 210,330 330,480 480,960
a little bit more challenging

1049
00:29:09,560 --> 00:29:10,850
0,300 300,510 510,870 870,1020 1020,1290
than were different than I

1050
00:29:10,850 --> 00:29:12,020
0,180 180,240 240,390 390,600 600,1170
think it would go {}

1051
00:29:12,140 --> 00:29:13,700
0,240 240,540 540,660 660,1110
the {xv6 - -}.|
|

1052
00:29:13,920 --> 00:29:14,790
0,90 90,270 270,390 390,450 450,870
{} I have a question,|
我有个问题，|

1053
00:29:14,790 --> 00:29:16,940
0,480 630,1740
I guess.
我想是的。我认为,

1054
00:29:16,970 --> 00:29:18,180
0,150 150,660
I think,|
|

1055
00:29:18,270 --> 00:29:20,520
0,1050 1050,1320 1320,1500 1500,1590 1590,2250
Go wants you to use
围棋希望你更多地使用渠道而不是互锁，

1056
00:29:20,580 --> 00:29:23,140
0,660 660,900 900,1320 1350,2010
channels more than {}

1057
00:29:23,370 --> 00:29:25,680
0,750 780,1260 1260,1350 1350,1950 1980,2310
mutual locks,| I guess, so
|我想，那你想不想有

1058
00:29:25,680 --> 00:29:27,420
0,210 210,420 420,1020 1230,1560 1560,1740
would you like would there

1059
00:29:27,420 --> 00:29:28,920
0,210 210,810
be| like,
|例如，随着xv6中某些东西的设计

1060
00:29:29,040 --> 00:29:30,420
0,150 150,240 240,690 690,870 870,1380
with the design of somethings

1061
00:29:30,420 --> 00:29:31,380
0,120 120,300 300,420 420,750 750,960
in {xv6 - -} be|
|

1062
00:29:31,380 --> 00:29:33,390
0,300 300,420 420,690 690,1320 1350,2010
like you'd use as channels
就像你会用来做频道，而不是用来锁东西。

1063
00:29:33,390 --> 00:29:34,590
0,360 360,540 540,840 840,930 930,1200
instead of holding a lock

1064
00:29:34,590 --> 00:29:36,120
0,90 90,540 960,1230 1230,1350 1350,1530
for something.| Yeah, { -
|是的，这是一个很好的问题，

1065
00:29:36,120 --> 00:29:37,440
0,90 90,690 690,750 750,1050 1050,1320
-}, there's a great a

1066
00:29:37,440 --> 00:29:39,120
0,180 180,630 630,780 780,1020 1020,1680
great question,| so we I'll
|所以我们我会在最后稍微回到这个问题上，

1067
00:29:39,120 --> 00:29:39,720
0,120 120,300 300,450 450,540 540,600
come back to it a

1068
00:29:39,720 --> 00:29:40,590
0,150 150,270 270,360 360,480 480,870
little bit at the end,|
|

1069
00:29:40,680 --> 00:29:42,720
0,360 360,570 570,900 900,1050 1050,2040
{} further down and {}
再往下看，我们有几张幻灯片，介绍了我们在饼干中使用了围棋的哪些功能，

1070
00:29:42,750 --> 00:29:43,680
0,150 150,240 240,360 360,630 630,930
we have some slides about

1071
00:29:43,680 --> 00:29:44,730
0,270 270,600 600,690 690,900 900,1050
what features of Go did

1072
00:29:44,730 --> 00:29:45,810
0,150 150,540 540,690 690,900 900,1080
we use in {Biscuit -

1073
00:29:46,260 --> 00:29:48,120
0,660 660,900 900,1050 1050,1320 1320,1860
-},| but you know the
|但你知道，我们没有任何频道使用率很高的索引，

1074
00:29:48,570 --> 00:29:49,710
0,300 300,570 570,720 720,930 930,1140
the index we didn't have

1075
00:29:49,710 --> 00:29:50,610
0,150 150,270 270,480 480,780 780,900
any of using channels that

1076
00:29:50,610 --> 00:29:52,320
0,420 450,780 780,930 930,1290 1290,1710
much,| {} we mostly use
|我们主要使用锁和条件变量。

1077
00:29:52,320 --> 00:29:54,040
0,330 330,420 420,780 780,1440
locks and condition variables.|
|

1078
00:29:54,250 --> 00:29:55,330
0,180 180,270 270,450 450,690 690,1080
So in some sense closer
因此，在某种意义上，xv6看起来更接近于xv6。

1079
00:29:55,330 --> 00:29:56,560
0,240 240,420 450,690 690,960 960,1230
to or {a,way} {xv6 -}

1080
00:29:56,560 --> 00:29:58,510
0,390 390,690 690,1260 1260,1470 1470,1950
looks| than actually a one
|而不是一个你会做的，然后你会用频道做的，

1081
00:29:58,510 --> 00:29:59,770
0,120 120,240 240,660 990,1170 1170,1260
you would do then you

1082
00:29:59,770 --> 00:30:01,030
0,120 120,210 210,420 420,870 960,1260
would do with channels,| we
|我们实际上进行了文件系统设计的实验，这些设计对通道的占用要大得多，

1083
00:30:01,030 --> 00:30:02,860
0,210 210,810 810,1080 1080,1260 1260,1830
did experiment actually with designs

1084
00:30:02,860 --> 00:30:03,850
0,90 90,180 180,450 450,840 840,990
of the file system that

1085
00:30:03,850 --> 00:30:05,710
0,120 120,360 360,870 1110,1500 1500,1860
were much more {} channel

1086
00:30:05,710 --> 00:30:08,260
0,510 750,1380 1380,2130 2190,2370 2370,2550
heavy,| {} and it didn't
|结果不是很好，是的，我们得到了表演，

1087
00:30:08,260 --> 00:30:09,550
0,210 210,480 480,870 960,1170 1170,1290
work out great, yeah we

1088
00:30:09,550 --> 00:30:11,290
0,150 150,300 300,960 1170,1560 1590,1740
got that performance,| so yeah
|所以，是的，我们又换回了一种更简单的同步方式，就像xv6或Linux使用的那样。

1089
00:30:11,290 --> 00:30:12,520
0,180 180,630 630,930 930,1050 1050,1230
we switched back to sort

1090
00:30:12,520 --> 00:30:14,170
0,60 60,420 420,1110 1290,1590 1590,1650
of more a sort of

1091
00:30:14,170 --> 00:30:15,550
0,270 270,570 570,660 660,1260 1260,1380
simple style of synchronization is

1092
00:30:15,550 --> 00:30:16,680
0,240 240,450 450,810
{xv6 -} does

1093
00:30:16,900 --> 00:30:18,380
0,210 210,510 510,870
or Linux uses.|
|

1094
00:30:20,450 --> 00:30:21,680
0,720

1095
00:30:21,740 --> 00:30:22,850
0,270 270,750 750,900 900,1050 1050,1110
Okay, so you know a
好的，你知道在我们经历的过程中有几个小难题或实施挑战，

1096
00:30:22,850 --> 00:30:24,050
0,240 240,420 420,600 630,960 960,1200
couple sort of a little

1097
00:30:24,050 --> 00:30:27,140
0,690 720,1170 1200,1740 1740,2430 2430,3090
puzzles or implementation challenges as

1098
00:30:27,140 --> 00:30:28,820
0,120 120,300 300,690 930,1140 1140,1680
we went through,| {} one
|必须到达运行时才能在裸机上工作

1099
00:30:28,850 --> 00:30:30,500
0,720 840,1230 1230,1350 1350,1440 1440,1650
{} gotta get to {runtime

1100
00:30:30,500 --> 00:30:31,190
0,150 150,270 270,480 480,600 600,690
-} to work on the

1101
00:30:31,190 --> 00:30:32,690
0,240 240,630 750,1230 1230,1380 1380,1500
{bare-metal -}| and you know
|你知道，你知道，你当然想要对运行时进行零修改，尽可能少地修改，

1102
00:30:32,690 --> 00:30:34,400
0,390 480,1260 1260,1350 1350,1410 1410,1710
that required you know wanted

1103
00:30:34,400 --> 00:30:35,150
0,60 60,270 270,330 330,600 600,750
to make of course like

1104
00:30:35,150 --> 00:30:36,800
0,330 330,930 930,1050 1050,1140 1140,1650
zero modifications to the runtime

1105
00:30:36,800 --> 00:30:38,060
0,180 180,300 300,630 630,750 750,1260
where as little as possible,|
|

1106
00:30:38,060 --> 00:30:39,200
0,120 120,330 330,480 480,690 750,1140
so that you know Go
这样您就知道发布新版本运行时了，

1107
00:30:39,200 --> 00:30:39,980
0,210 210,480 480,600 600,660 660,780
come out with a new

1108
00:30:39,980 --> 00:30:40,880
0,300 300,360 360,450 450,840 840,900
version of the runtime,| we
|我们可以直接用它。

1109
00:30:40,880 --> 00:30:42,060
0,150 150,330 330,540 540,750
could just use it.|
|

1110
00:30:42,180 --> 00:30:44,640
0,300 300,660 660,780 780,1410 1740,2460
In fact, {you,know} through {}
事实上，你知道，多年来，你知道我们在做这件事，代码也在做这件事，

1111
00:30:44,700 --> 00:30:46,170
0,630 630,720 720,840 840,990 990,1470
years, you know that we

1112
00:30:46,200 --> 00:30:47,070
0,330 330,450 450,660 660,810 810,870
worked on this where the

1113
00:30:47,070 --> 00:30:48,540
0,270 270,510 510,570 570,960 1200,1470
code worked on this {},|
|

1114
00:30:48,540 --> 00:30:49,980
0,180 180,600 600,690 690,1080 1080,1440
we upgraded the runtime many
我们升级了运行库很多次，你知道很多次。

1115
00:30:49,980 --> 00:30:51,600
0,90 90,360 390,990 990,1050 1050,1620
you know number of times.|
|

1116
00:30:52,210 --> 00:30:53,290
0,480 480,600 600,660 660,870 870,1080
{} And that was turned
事实证明，这是一件好事，

1117
00:30:53,290 --> 00:30:53,680
0,60 60,120 120,210 210,270 270,390
out to be a good

1118
00:30:53,680 --> 00:30:54,520
0,270 270,450 450,540 540,720 720,840
thing,| and it turned out,
|事实证明，他们并不是很难真正在裸机上工作。

1119
00:30:54,520 --> 00:30:55,330
0,90 90,360 360,630 630,690 690,810
they were not to be

1120
00:30:55,330 --> 00:30:56,410
0,150 150,480 480,540 540,840 840,1080
too difficult to actually to

1121
00:30:56,410 --> 00:30:57,100
0,240 240,330 330,540 540,630 630,690
get to work on the

1122
00:30:57,100 --> 00:30:58,140
0,210 210,540
{bare-metal -}.|
|

1123
00:30:58,170 --> 00:30:59,760
0,600 600,750 750,1080 1080,1200 1200,1590
{} {You,know} Go in general
你知道，围棋一般都是精心设计的，基本上是操作系统不可知的，

1124
00:30:59,760 --> 00:31:02,220
0,150 150,930 1110,1740 1740,1950 1950,2460
is designed {} pretty carefully

1125
00:31:02,220 --> 00:31:03,420
0,300 300,480 480,570 570,780 780,1200
to sort of be mostly

1126
00:31:03,420 --> 00:31:05,340
0,660 780,1470 1470,1680 1680,1740 1740,1920
OS agnostic,| because they want
|因为他们希望能够运行多个操作系统，

1127
00:31:05,340 --> 00:31:05,940
0,60 60,150 150,330 330,420 420,600
to be able to run

1128
00:31:05,940 --> 00:31:07,200
0,150 150,390 390,750 750,1110 1110,1260
into many operating system,| so
|因此，它不依赖于大量的操作系统功能。

1129
00:31:07,200 --> 00:31:08,040
0,60 60,300 300,690 690,780 780,840
it doesn't rely on a

1130
00:31:08,040 --> 00:31:09,680
0,210 210,330 330,630 630,1170
ton of OS features.|
|

1131
00:31:09,970 --> 00:31:11,530
0,420 420,540 540,930 930,1440 1440,1560
And we're basically emulated the
我们基本上是在模仿实际需要的功能

1132
00:31:11,530 --> 00:31:13,570
0,330 330,510 510,990 990,1320 1350,2040
features that actually {} needed|
|

1133
00:31:13,750 --> 00:31:15,220
0,240 240,960 960,1320 1320,1380 1380,1470
and mostly those are the
大多数情况下，这些功能实际上是刚从Go运行时开始使用的功能

1134
00:31:15,220 --> 00:31:16,240
0,300 300,450 450,690 690,870 870,1020
features that actually just get

1135
00:31:16,240 --> 00:31:17,800
0,180 180,540 570,1260 1260,1440 1440,1560
off the Go {runtime -}

1136
00:31:17,800 --> 00:31:19,150
0,90 90,210 210,690 1050,1200 1200,1350
to get started| and once
|一旦启动，它就会快乐地运行。

1137
00:31:19,150 --> 00:31:20,290
0,90 90,480 480,630 630,960 960,1140
it started it runs just

1138
00:31:20,290 --> 00:31:21,140
0,360
happily.|
|

1139
00:31:24,470 --> 00:31:26,360
0,810 1230,1440 1440,1620 1620,1830 1830,1890
{} We have sort of
我们有一些运行不同应用程序例行公事范围，

1140
00:31:26,360 --> 00:31:27,650
0,390 390,510 510,690 690,1110 1110,1290
range that Go routine run

1141
00:31:27,650 --> 00:31:31,400
0,300 300,1020 1050,1980 1980,3360 3390,3750
different applications,| normally in Go
|通常在围棋程序中是正确的，你知道一个单一的应用程序，

1142
00:31:31,400 --> 00:31:33,440
0,420 420,780 780,1320 1320,1620 1620,2040
program correct, {you,know} one single

1143
00:31:33,440 --> 00:31:35,510
0,780 1050,1380 1380,1710 1710,1920 1920,2070
application,| and here now we're
|现在，我们在不同的用户、不同的用户应用程序之间直接使用GO例程。

1144
00:31:35,510 --> 00:31:36,860
0,240 240,540 540,750 750,1050 1050,1350
using Go routine directly around

1145
00:31:36,860 --> 00:31:39,500
0,360 360,840 840,1650 1770,2400 2400,2640
different user, {} different user

1146
00:31:39,500 --> 00:31:40,640
0,720
applications.|
|

1147
00:31:40,670 --> 00:31:42,800
0,420 420,810 1050,1380 1380,1650 1650,2130
{} And {} but the
而且用户应用程序要与不同的页表一起运行。

1148
00:31:42,800 --> 00:31:43,910
0,270 270,750 750,840 840,990 990,1110
user applications to run with

1149
00:31:43,910 --> 00:31:45,400
0,210 210,420 420,990
different page tables.|
|

1150
00:31:45,490 --> 00:31:48,010
0,750 930,1170 1170,1590 1590,2430 2430,2520
{} And the little you
你知道的很少(皱纹)是这样的

1151
00:31:48,010 --> 00:31:49,240
0,210 210,510 510,810 810,930 930,1230
know [wrinkle] here is that|
|

1152
00:31:49,240 --> 00:31:50,350
0,120 120,270 270,720 780,900 900,1110
you know the we don't
你知道我们不能控制或者饼干不能控制日程安排，

1153
00:31:50,350 --> 00:31:52,390
0,660 780,1050 1080,1380 1380,1590 1590,2040
control or Biscuit doesn't control

1154
00:31:52,390 --> 00:31:53,980
0,300 300,840 870,1110 1110,1320 1320,1590
the scheduler,| because we're using
|因为我们使用的是原封不动的Go运行时，

1155
00:31:53,980 --> 00:31:55,750
0,90 90,600 600,1020 1020,1650 1650,1770
the Go runtime unmodified,| so
|所以我们使用的是Go运行时调度程序，

1156
00:31:55,750 --> 00:31:56,860
0,150 150,510 510,570 570,780 780,1110
we're using the Go runtime

1157
00:31:56,860 --> 00:31:58,540
0,510 660,1020 1020,1200 1200,1350 1350,1680
scheduler,| and so {in,the} scheduler,
|因此在调度程序中，我们不能切换页表。

1158
00:31:58,540 --> 00:32:00,010
0,120 120,360 360,660 660,930 930,1470
we can't switch page tables.|
|

1159
00:32:00,460 --> 00:32:02,320
0,690 870,1020 1020,1260 1260,1560 1560,1860
{} So what {} {xv6
基本上，xv6在饼干中的作用非常简单

1160
00:32:02,320 --> 00:32:03,910
0,540 540,810 810,1110 1110,1320 1320,1590
-} in basically what {}

1161
00:32:03,910 --> 00:32:04,990
0,240 240,510 510,630 630,810 810,1080
Biscuit does is very simple|
|

1162
00:32:04,990 --> 00:32:06,310
0,120 120,360 360,720 720,1110 1110,1320
to {xv6 -} it actually
对于xv6，它实际上在从当前用户空间更改时切换页表，或者相反。

1163
00:32:06,310 --> 00:32:08,290
0,390 390,660 660,1140 1140,1800 1800,1980
switches page tables when it

1164
00:32:08,290 --> 00:32:09,940
0,420 420,570 570,900 900,1200 1200,1650
changes from current user space

1165
00:32:10,180 --> 00:32:11,050
0,150 150,210 210,360 360,510 510,870
or the other way around.|
|

1166
00:32:12,030 --> 00:32:14,190
0,510 840,1020 1020,1290 1290,2070 2070,2160
{} So when entry and
所以当进入和退出内核切换页表时。

1167
00:32:14,190 --> 00:32:16,050
0,450 480,600 600,870 870,1380 1380,1860
exit of the kernel switch

1168
00:32:16,050 --> 00:32:17,360
0,240 240,810
page tables.|
|

1169
00:32:17,360 --> 00:32:18,620
0,90 90,210 210,660 660,1050 1050,1260
And that means like in
这意味着在xv6中，当您需要将数据从用户空间复制到内核空间或从内核空间复制数据时，

1170
00:32:18,620 --> 00:32:19,760
0,330 330,690 690,780 780,900 900,1140
{xv6 -} and then when

1171
00:32:19,760 --> 00:32:21,590
0,60 60,210 210,300 300,1020 1320,1830
you need to copy data

1172
00:32:21,590 --> 00:32:22,790
0,180 180,450 450,840 840,930 930,1200
from user space to kernel

1173
00:32:22,790 --> 00:32:23,480
0,270 270,330 330,390 390,540 540,690
space or the other way

1174
00:32:23,480 --> 00:32:24,860
0,570 660,960 960,1140 1140,1230 1230,1380
around,| you have to do
|你必须使用那些复制和复制功能来做这件事，

1175
00:32:24,860 --> 00:32:25,880
0,180 180,360 360,480 480,780 780,1020
that sort of using those

1176
00:32:25,880 --> 00:32:27,050
0,480 480,570 570,660 660,990 990,1170
{copyin -} and {copyout -}

1177
00:32:27,050 --> 00:32:28,100
0,450 450,570 570,690 690,900 900,1050
functions,| that we also have
|我们也有xv6，基本上你可以做页表漫游软件。

1178
00:32:28,100 --> 00:32:29,330
0,90 90,330 330,660 660,1110 1110,1230
an {xv6 -} basically you

1179
00:32:29,330 --> 00:32:30,410
0,150 150,270 270,480 480,750 750,1080
do the page table walking

1180
00:32:30,410 --> 00:32:31,360
0,480
software.|
|

1181
00:32:31,810 --> 00:32:33,000
0,690

1182
00:32:33,550 --> 00:32:35,480
0,420 420,780 780,1020 1020,1380
{} Another issue of
挑战的另一个问题是几乎没有挑战的是设备中断，

1183
00:32:35,480 --> 00:32:37,190
0,540 540,690 690,960 960,1320 1320,1710
challenge where little challenge was

1184
00:32:37,190 --> 00:32:39,140
0,420 420,960 1410,1710 1710,1860 1860,1950
device interrupts,| {} and {}
|并在用户模式下正常运行，

1185
00:32:39,140 --> 00:32:40,580
0,300 300,570 570,1140 1140,1350 1350,1440
Go running normally runs in

1186
00:32:40,580 --> 00:32:42,320
0,390 390,780 840,1230 1230,1470 1470,1740
user mode,| it doesn't really
|它实际上不会收到来自硬件的中断，

1187
00:32:42,320 --> 00:32:44,810
0,210 210,810 1170,1650 1890,2010 2010,2490
get interrupts from the hardware,|
|

1188
00:32:45,200 --> 00:32:46,490
0,510 510,720 720,990 990,1140 1140,1290
but we're using it on
但是我们在裸机上使用它

1189
00:32:46,490 --> 00:32:47,930
0,60 60,390 390,960 960,1140 1140,1440
the {bare-metal -}| and so
|所以我们会受到干扰，

1190
00:32:47,930 --> 00:32:48,980
0,240 240,360 360,420 420,540 540,1050
we're going to get interruption,|
|

1191
00:32:49,040 --> 00:32:51,080
0,240 240,540 540,1170 1560,1920 1920,2040
time clock interrupts, interrupts from
时钟中断、来自网络驱动器的中断、中断磁盘驱动器等，

1192
00:32:51,080 --> 00:32:52,310
0,90 90,390 390,750 750,1170 1170,1230
the network driver, interrupted the

1193
00:32:52,310 --> 00:32:54,440
0,270 270,750 780,1530 1740,1980 1980,2130
disk driver etc,| you know
|你知道，从UART。

1194
00:32:54,440 --> 00:32:56,260
0,210 210,660 720,1410
from the UART.|
|

1195
00:32:56,290 --> 00:32:57,340
0,510 510,690 690,810 810,900 900,1050
{} And so we need
所以我们需要解决这个问题

1196
00:32:57,340 --> 00:32:58,510
0,180 180,390 390,480 480,810 810,1170
to deal with that| and
|而且在围棋中，你知道，也没有在持有锁的同时关闭中断的概念，

1197
00:32:58,540 --> 00:33:00,910
0,630 1140,1440 1440,1980 1980,2190 2190,2370
{} and there's also no

1198
00:33:00,910 --> 00:33:02,590
0,630 630,990 990,1080 1080,1200 1200,1680
notion {in,Go} you know for

1199
00:33:02,980 --> 00:33:04,930
0,450 450,630 630,1110 1110,1620 1620,1950
switching off interrupts while holding

1200
00:33:04,930 --> 00:33:07,240
0,90 90,570 960,1590 1590,1830 1890,2310
a lock,| because just show
|因为只要显示用户应用程序

1201
00:33:07,240 --> 00:33:09,130
0,240 240,510 510,1260 1560,1800 1800,1890
up user applications| and so
|因此，我们需要稍微小心一下如何实际写入设备中断

1202
00:33:09,130 --> 00:33:09,880
0,120 120,210 210,480 480,630 630,750
we have a little bit

1203
00:33:09,880 --> 00:33:11,590
0,690 690,870 870,1020 1020,1290 1290,1710
careful how to actually write

1204
00:33:11,590 --> 00:33:14,290
0,330 330,1110 1170,1650 1650,2190 2250,2700
a device {} interrupt {}|
|

1205
00:33:14,290 --> 00:33:15,730
0,270 300,1020 1020,1140 1140,1290 1290,1440
and basically the way we
基本上我们的做法是，我们在设备中断时几乎什么都不做，

1206
00:33:15,730 --> 00:33:16,660
0,180 180,300 300,600 600,810 810,930
did it is, we do

1207
00:33:16,660 --> 00:33:18,040
0,270 270,840 840,960 960,1050 1050,1380
almost nothing in the device

1208
00:33:18,040 --> 00:33:19,450
0,480 660,900 900,1080 1080,1230 1230,1410
interrupt,| we don't take any
|我们不会锁定，基本上不会分配任何内存，

1209
00:33:19,450 --> 00:33:21,490
0,360 360,690 720,1350 1350,1830 1830,2040
locks out, basically we don't

1210
00:33:21,490 --> 00:33:23,320
0,360 360,480 480,960 1260,1650 1650,1830
allocate any memory,| {} the
|我们唯一要做的就是把旗帜送到某个地方

1211
00:33:23,320 --> 00:33:23,980
0,180 180,300 300,420 420,540 540,660
only thing we do is

1212
00:33:23,980 --> 00:33:26,050
0,600 600,930 930,1020 1020,1500 1500,2070
basically sending a flag somewhere|
|

1213
00:33:26,050 --> 00:33:27,520
0,240 240,300 300,630 630,1140 1320,1470
that {} [wasn't] interrupted and
这(没有)被中断，然后唤醒一个真正有效的围棋例程来实际处理中断。

1214
00:33:27,520 --> 00:33:29,410
0,90 90,360 360,720 990,1380 1440,1890
then wake up a really

1215
00:33:29,410 --> 00:33:30,910
0,540 540,750 750,1110 1110,1230 1230,1500
functional Go routine to actually

1216
00:33:30,910 --> 00:33:32,160
0,270 270,420 420,510 510,990
deal with the interrupt.|
|

1217
00:33:33,810 --> 00:33:35,000
0,720

1218
00:33:35,000 --> 00:33:35,930
0,150 150,420 420,570 570,870 870,930
And that Go routine, of
而围棋程序，当然你可以使用它想要的所有围棋功能。

1219
00:33:35,930 --> 00:33:36,950
0,300 300,480 480,630 630,810 810,1020
course you can use all

1220
00:33:36,950 --> 00:33:37,820
0,60 60,270 270,600 600,750 750,870
the Go features that it

1221
00:33:37,820 --> 00:33:38,760
0,420
wants.|
|

1222
00:33:39,160 --> 00:33:40,150
0,330 330,390 390,540 540,870 870,990
Because it does run in
因为它确实在中断处理程序的上下文中运行，

1223
00:33:40,150 --> 00:33:41,260
0,210 210,570 570,660 660,750 750,1110
the context of an interrupt

1224
00:33:41,260 --> 00:33:42,430
0,360 360,660 660,930 930,1110 1110,1170
handler,| {just,it} runs in the
|它只是在正常的围棋程序中运行。

1225
00:33:42,430 --> 00:33:44,080
0,360 360,450 450,840 840,1140 1140,1650
context of normal normal {Go,routine}.|
|

1226
00:33:45,410 --> 00:33:47,120
0,300 300,900 900,1050 1050,1140 1140,1710
Then one thing that surprises,
然后有一件令人惊讶的事，那就是有点意外，

1227
00:33:47,150 --> 00:33:48,830
0,390 390,810 810,960 960,1050 1050,1680
{} it was {a,bit,of} surprise,|
|

1228
00:33:48,860 --> 00:33:49,910
0,150 150,270 270,570 570,900 900,1050
you know the first three
你知道前三件事是完全预料到的

1229
00:33:49,910 --> 00:33:51,500
0,330 330,570 600,960 960,1470 1470,1590
things were completely anticipated that|
|

1230
00:33:51,500 --> 00:33:52,400
0,240 240,420 420,600 600,690 690,900
we would have to deal
我们要处理的是当一栋楼里有饼干的时候，

1231
00:33:52,400 --> 00:33:54,350
0,270 270,720 720,1200 1230,1530 1530,1950
with when a building Biscuit,|
|

1232
00:33:54,350 --> 00:33:55,520
0,210 210,450 450,600 600,750 750,1170
the hardest one that actually
最难的一次实际上让我们大吃一惊，

1233
00:33:55,520 --> 00:33:58,910
0,1110 1200,1560 1560,1920 2250,2850 3030,3390
had suprised us,| {} and
|我们学到了很多，这就是堆耗尽之谜。

1234
00:33:58,910 --> 00:33:59,930
0,150 150,360 360,390 390,600 600,1020
we learned a lot about

1235
00:33:59,930 --> 00:34:01,250
0,360 360,540 540,720 720,1170 1170,1320
it, was this puzzle of

1236
00:34:01,250 --> 00:34:02,580
0,300 300,870
heap exhaustion.|
|

1237
00:34:02,760 --> 00:34:03,360
0,180 180,330 330,390 390,510 510,600
{} So I'm going to
因此，我将主要讨论堆耗尽问题

1238
00:34:03,360 --> 00:34:04,440
0,240 240,720 720,840 840,900 900,1080
talk mostly for a little

1239
00:34:04,440 --> 00:34:05,880
0,180 180,390 390,540 540,1170 1170,1440
while about heap exhaustion| and
|你知道这是怎么回事，你知道它是怎么来的，我们是怎么解决它的，

1240
00:34:05,880 --> 00:34:06,720
0,90 90,180 180,360 360,450 450,840
you know what it is

1241
00:34:06,720 --> 00:34:07,320
0,120 120,210 210,330 330,420 420,600
you know how it comes

1242
00:34:07,320 --> 00:34:08,880
0,450 450,960 960,1140 1140,1230 1230,1560
about and how we solved

1243
00:34:08,880 --> 00:34:10,110
0,150 150,390 390,660 660,930 930,1230
it,| but maybe before diving
|但也许在深入讨论这一问题之前，到目前为止还没有任何问题.

1244
00:34:10,110 --> 00:34:12,210
0,240 240,630 930,1590 1590,1740 1740,2100
into that any any questions

1245
00:34:12,210 --> 00:34:13,180
0,150 150,540
so far.|
|

1246
00:34:18,810 --> 00:34:20,880
0,240 240,690 780,1080 1080,1650
{} So crystal clear.|
如此清晰。|

1247
00:34:24,540 --> 00:34:25,560
0,300 300,450 450,630 630,990 990,1020
Okay, so let's talk a
好的，那么让我们来谈谈堆耗尽的问题，

1248
00:34:25,560 --> 00:34:26,700
0,180 180,300 300,480 480,660 660,1140
little bit about heap exhaustion,|
|

1249
00:34:26,700 --> 00:34:27,270
0,180 180,300 300,420 420,480 480,570
I'm not going to go
我不打算全面深入地报道报纸上的内容，

1250
00:34:27,270 --> 00:34:28,230
0,150 150,420 420,750 750,870 870,960
with full depth was in

1251
00:34:28,230 --> 00:34:29,250
0,90 90,420 420,630 630,870 870,1020
the paper,| but at least
|但至少它能让你对问题出在哪里有所了解。

1252
00:34:29,250 --> 00:34:30,060
0,60 60,210 210,270 270,330 330,810
it gives you a flavor

1253
00:34:30,060 --> 00:34:31,650
0,120 120,450 450,840 870,1260 1260,1590
of what the problem is.|
|

1254
00:34:32,810 --> 00:34:33,940
0,660
Um.|
恩。|

1255
00:34:34,230 --> 00:34:35,660
0,960
Yeah.|
嗯。|

1256
00:34:40,940 --> 00:34:42,560
0,510 510,690 690,750 750,930 930,1620
So in the heap exhaustion
所以在堆耗尽的情况下，让我们假设这里的蓝框又是内核。

1257
00:34:42,590 --> 00:34:43,790
0,540 540,630 630,720 720,1020 1020,1200
{} you know let's say

1258
00:34:43,790 --> 00:34:45,590
0,510 540,1170 1170,1470 1470,1740 1740,1800
the blue box {here,is} the

1259
00:34:45,590 --> 00:34:46,960
0,300 300,840
kernel again.|
|

1260
00:34:49,450 --> 00:34:50,590
0,510 510,660 660,750 750,840 840,1140
And you know the kernel
你知道内核有一个堆，

1261
00:34:50,590 --> 00:34:52,210
0,150 150,210 210,720 750,1440 1440,1620
has a heap,| {} from
|从中动态分配存储器，

1262
00:34:52,210 --> 00:34:54,610
0,210 210,780 780,1290 1290,1800 1920,2400
which delegates dynamically memory {},|
|

1263
00:34:54,610 --> 00:34:55,810
0,120 120,630 630,720 720,990 990,1200
in xv6, we don't have
在xv6中，我们没有这样的堆，因为我们在内核中没有内存分配器，所有东西都是静态分配的，

1264
00:34:55,810 --> 00:34:56,710
0,210 210,270 270,540 540,810 810,900
such a heap, because we

1265
00:34:56,710 --> 00:34:58,000
0,210 210,480 480,540 540,840 840,1290
don't have a memory allocator

1266
00:34:58,000 --> 00:34:59,140
0,60 60,120 120,450 450,720 720,1140
in the kernel, everything statically

1267
00:34:59,140 --> 00:35:00,910
0,480 510,720 750,1110 1110,1290 1290,1770
allocated,| but any other kernel
|但是任何其他内核都会有一个堆，所以你可以调用malloc，你在内核中有空闲的空间。

1268
00:35:01,030 --> 00:35:02,110
0,300 300,540 540,600 600,930 930,1080
will have a heap, so

1269
00:35:02,110 --> 00:35:04,280
0,510 510,600 600,960 1020,1650
you can call malloc,

1270
00:35:04,570 --> 00:35:05,800
0,180 180,450 450,990 1020,1140 1140,1230
you have free in the

1271
00:35:05,800 --> 00:35:06,780
0,450
kernel.|
|

1272
00:35:08,120 --> 00:35:09,080
0,420 420,510 510,630 630,720 720,960
And you know the things
你知道在堆上实际分配的东西，

1273
00:35:09,080 --> 00:35:10,310
0,120 120,360 360,510 510,1050 1050,1230
that actually get allocated on

1274
00:35:10,310 --> 00:35:12,470
0,60 60,330 330,540 540,1530 1560,2160
the heap,| for example {}
|例如，您知道套接字对象、文件描述符对象或进程对象

1275
00:35:12,470 --> 00:35:14,630
0,180 180,600 600,1230 1230,1920 1920,2160
{you,know} socket objects or file

1276
00:35:14,630 --> 00:35:17,600
0,450 450,1050 1050,1590 1590,2130 2130,2970
descriptor objects or process objects|
|

1277
00:35:17,900 --> 00:35:20,060
0,360 360,810 840,1470 1470,1920 1920,2160
struct proc {you,know,struct} fd all
你知道struct fd所有我们在xv6中静态分配的结构，

1278
00:35:20,060 --> 00:35:21,080
0,90 90,450 450,600 600,690 690,1020
the structures that we basically

1279
00:35:21,080 --> 00:35:23,600
0,540 540,1050 1050,1680 1680,2070 2070,2520
statically allocated in {xv6 -},|
|

1280
00:35:23,720 --> 00:35:25,700
0,420 420,750 750,900 900,1590 1590,1980
normal kernels, they dynamically allocate
普通内核，它们会动态分配它们，

1281
00:35:25,700 --> 00:35:27,110
0,180 660,810 810,960 960,1080 1080,1410
them,| so when you open
|因此，当您打开新的文件描述符时，堆中将分配一个文件描述符对象。

1282
00:35:27,110 --> 00:35:28,340
0,120 120,270 270,510 510,930 930,1230
the new file descriptor there

1283
00:35:28,340 --> 00:35:29,240
0,150 150,270 270,330 330,510 510,900
will be a file descriptor

1284
00:35:29,240 --> 00:35:30,830
0,510 510,1080 1080,1200 1200,1260 1260,1590
object allocated in the heap.|
|

1285
00:35:32,230 --> 00:35:33,520
0,420 450,660 660,960 960,1020 1020,1290
And so, then the problem
因此，问题是，如果您正在运行多个应用程序，

1286
00:35:33,520 --> 00:35:34,840
0,180 180,390 420,840 840,1080 1080,1320
is if you're running many

1287
00:35:34,840 --> 00:35:36,100
0,720 720,810 810,930 930,1050 1050,1260
applications,| you know they might
|你知道他们可能会打开很多文件描述符，你可能有很多套接字

1288
00:35:36,100 --> 00:35:37,540
0,270 270,480 480,690 690,1260 1260,1440
open many file descriptors, may

1289
00:35:37,540 --> 00:35:38,950
0,120 120,300 300,540 540,1140 1230,1410
you have many sockets| and
|它们基本上开始缓慢地填满堆

1290
00:35:38,950 --> 00:35:40,000
0,90 90,270 270,330 330,660 660,1050
they sort of start filling

1291
00:35:40,000 --> 00:35:41,830
0,90 90,390 390,810 810,1380 1530,1830
the heap basically slowly| and
|所以问题是，在某些时候，比如堆满了，

1292
00:35:41,830 --> 00:35:43,870
0,420 810,1230 1230,1740 1740,1890 1890,2040
so the issue is that

1293
00:35:43,870 --> 00:35:44,800
0,120 120,270 270,660 660,840 840,930
at some points like the

1294
00:35:44,800 --> 00:35:47,290
0,240 240,690 1080,1320 1320,1980 2010,2490
heap full,| there's no space
|不再有空间可用于分配新对象

1295
00:35:47,290 --> 00:35:48,730
0,570 570,750 750,1200 1200,1260 1260,1440
anymore for allocating a new

1296
00:35:48,730 --> 00:35:51,250
0,690 690,720 720,1140 1140,1410 1770,2520
object| or when an application
|或者当应用程序请求例如打开新的文件描述符时

1297
00:35:51,250 --> 00:35:52,300
0,270 270,330 330,750 750,1020 1020,1050
asks for example opens a

1298
00:35:52,300 --> 00:35:53,500
0,150 150,360 360,780 780,960 960,1200
new file descriptor| and there's
|就像没有新的流程，就像没有新的叉子一样

1299
00:35:53,500 --> 00:35:55,420
0,150 150,690 750,1140 1140,1620 1620,1920
like no new process like

1300
00:35:55,420 --> 00:35:56,920
0,210 210,420 420,870 1020,1410 1410,1500
there's new fork| and the
|并且内核想要分配一个结构进程

1301
00:35:56,920 --> 00:35:57,940
0,240 240,420 420,570 570,960 960,1020
kernel wants to allocate a

1302
00:35:57,940 --> 00:35:59,770
0,300 300,750 750,870 870,1260 1410,1830
struct proc| and heap usually
|堆通常已经没有空间了。

1303
00:35:59,770 --> 00:36:01,020
0,180 180,300 300,600 600,1020
there's no space anymore.|
|

1304
00:36:01,660 --> 00:36:03,160
0,570 930,1170 1170,1320 1320,1410 1410,1500
{} And what did you
你做了什么，

1305
00:36:03,160 --> 00:36:04,210
0,120 120,420 600,750 750,840 840,1050
do that,| you know what
|你知道什么你知道你怎么处理那个特殊的案子，

1306
00:36:04,210 --> 00:36:06,700
0,180 180,1500 1530,1620 1620,2070 2130,2490
is {} you know how

1307
00:36:06,700 --> 00:36:07,360
0,90 90,210 210,450 450,540 540,660
do you deal with that

1308
00:36:07,360 --> 00:36:09,190
0,540 540,1110 1410,1620 1620,1740 1740,1830
particular case,| and this is
|这是通常的情况，你知道这可能是经常出现的情况，

1309
00:36:09,190 --> 00:36:10,240
0,540 540,600 600,690 690,870 870,1050
typically you know this is

1310
00:36:10,600 --> 00:36:12,340
0,420 420,630 630,960 960,1500 1500,1740
maybe in common cases show

1311
00:36:12,340 --> 00:36:14,260
0,210 210,420 420,870 960,1680 1680,1920
up that often,| {} but
|但如果你用力推机器，

1312
00:36:14,260 --> 00:36:15,310
0,180 180,330 330,450 450,750 750,1050
like if you're pushing machine

1313
00:36:15,310 --> 00:36:16,930
0,510 510,750 750,930 930,1350 1350,1620
hard,| you have a couple
|您有几个繁重的使用者进程在运行用户级进程，

1314
00:36:16,930 --> 00:36:18,580
0,270 270,690 690,1170 1170,1470 1470,1650
heavy consumer processes running user

1315
00:36:18,580 --> 00:36:20,050
0,210 210,840 870,1080 1080,1290 1290,1470
level processes,| you might end
|在这种情况下，您可能会结束，因为基本上所有可用内存都在使用中

1316
00:36:20,050 --> 00:36:21,490
0,120 120,240 240,750 750,900 900,1440
in this situation where basically

1317
00:36:21,760 --> 00:36:23,080
0,210 210,450 450,510 510,900 900,1320
in all the available memory

1318
00:36:23,080 --> 00:36:25,180
0,360 390,630 630,1170 1230,1800 1830,2100
is in use| and {}
|而且你的堆刚刚满。

1319
00:36:25,180 --> 00:36:26,320
0,180 180,450 450,630 630,810 810,1140
your heap is just full.|
|

1320
00:36:27,120 --> 00:36:29,280
0,570 570,840 840,1350 1350,1650 1650,2160
And no processes calling {}
而且还没有空闲的进程调用，

1321
00:36:29,280 --> 00:36:30,330
0,270 270,600 600,720 720,810 810,1050
free yet,| you know because
|你知道，因为他们都在运行，并试图为他们的特定工作分配更多的资源。

1322
00:36:30,330 --> 00:36:31,470
0,180 180,480 480,840 840,930 930,1140
they're all running and trying

1323
00:36:31,470 --> 00:36:33,360
0,60 60,420 420,900 930,1710 1710,1890
to allocate more resources for

1324
00:36:33,360 --> 00:36:34,920
0,240 240,390 390,660 660,1050 1050,1560
their for their particular jobs.|
|

1325
00:36:39,790 --> 00:36:41,620
0,570 690,960 960,1170 1170,1650 1650,1830
{} So all kernel face
所以当C内核或饼干或任何东西出现时，所有内核都会面临这个问题

1326
00:36:41,620 --> 00:36:42,580
0,120 120,450 450,630 630,750 750,960
this problem when its like

1327
00:36:42,580 --> 00:36:44,650
0,210 210,630 630,930 930,1260 1260,2070
C kernel {or,Biscuit -} or

1328
00:36:44,650 --> 00:36:46,180
0,420 420,690 690,870 870,1140 1140,1530
anything| and any kernel mostly
|而任何内核基本上都能解决这个特定的问题。

1329
00:36:46,180 --> 00:36:47,980
0,360 360,510 510,870 870,1290
solve this particular problem.|
|

1330
00:36:48,290 --> 00:36:49,580
0,180 180,390 390,840 840,1050 1050,1290
{} The reason they they
他们之所以出现在我们面前，是因为他们在“饼干”中作为一个严重的问题出现在我们面前

1331
00:36:49,580 --> 00:36:50,420
0,210 210,300 300,570 570,720 720,840
sort of showed up for

1332
00:36:50,420 --> 00:36:51,980
0,210 210,390 390,750 750,1140 1140,1560
us as a serious issue

1333
00:36:51,980 --> 00:36:55,280
0,570 990,1830 1860,2430 2430,2760 2760,3300
in {} Biscuit| was because
|是因为在许多内核中，您可以在malloc上返回错误，

1334
00:36:55,580 --> 00:36:59,000
0,600 600,840 840,1260 1260,2160 2370,3420
{} in many kernels the,

1335
00:37:01,270 --> 00:37:02,440
0,210 210,330 330,600 600,690 690,1170
you can return an error

1336
00:37:02,470 --> 00:37:04,270
0,570 600,1140 1200,1440 1440,1680 1680,1800
on malloc,| in fact the
|事实上，xv6偶尔会正确地做到这一点，

1337
00:37:04,270 --> 00:37:05,470
0,240 240,450 450,720 720,840 840,1200
{xv6 -} does that, correctly,

1338
00:37:05,470 --> 00:37:06,340
0,180 180,240 240,300 300,570 570,870
once in a while,| but
|但是您知道，在Go运行时，当您调用new来分配Go对象时，

1339
00:37:06,340 --> 00:37:07,510
0,120 120,210 210,540 540,900 900,1170
you know in a Go

1340
00:37:07,510 --> 00:37:08,920
0,420 420,540 540,630 630,870 870,1410
runtime, when you call new

1341
00:37:09,190 --> 00:37:10,870
0,300 300,750 750,780 780,1110 1110,1680
to allocate a Go object,|
|

1342
00:37:11,080 --> 00:37:12,550
0,270 270,480 480,750 750,990 990,1470
now there's no error condition,
现在没有错误条件，新的成功了。

1343
00:37:12,580 --> 00:37:14,400
0,750 750,1410
new succeeds.|
|

1344
00:37:14,400 --> 00:37:15,540
0,510 510,750 750,840 840,1020 1020,1140
{} And so there's no
所以不可能不及格。

1345
00:37:15,540 --> 00:37:16,740
0,120 120,210 210,480 480,660
way to fail it.|
|

1346
00:37:16,740 --> 00:37:18,180
0,510 720,1110 1110,1230 1230,1260 1260,1440
So let's talk a little
那么让我们稍微谈谈解决这个问题的可能方法。

1347
00:37:18,180 --> 00:37:19,950
0,150 150,630 630,1050 1050,1380 1380,1770
bit about possible ways to

1348
00:37:19,950 --> 00:37:22,560
0,390 390,540 540,1140 1410,2100
solve this problem {}.|
|

1349
00:37:22,770 --> 00:37:25,200
0,840 930,1050 1050,1500 1890,2220 2220,2430
The you know we've seen
你知道，我们偶尔会在xv6上看到它

1350
00:37:25,200 --> 00:37:26,250
0,90 90,360 360,600 600,840 840,1050
it actually {xv6 -} once

1351
00:37:26,250 --> 00:37:27,330
0,60 60,540 540,750 750,900 900,1080
in {a,while}| like if you
|比如如果你还记得bcache，

1352
00:37:27,330 --> 00:37:29,850
0,660 660,750 750,900 900,1500 1560,2520
remember the {bcache -} {},|
|

1353
00:37:29,850 --> 00:37:31,950
0,780 810,1080 1080,1290 1290,1560 1560,2100
if {xv6 -} can't find
如果xv6找不到新的挡路，您知道可以使用免费的挡路来存储磁盘挡路，

1354
00:37:32,310 --> 00:37:34,500
0,750 750,900 900,1380 1380,2010 2010,2190
{} a new block {you,know}

1355
00:37:34,500 --> 00:37:35,640
0,420 420,540 540,720 720,1050 1050,1140
to a free block to

1356
00:37:35,640 --> 00:37:37,380
0,570 570,780 780,1200 1200,1500 1500,1740
use for storage a disk

1357
00:37:37,380 --> 00:37:39,030
0,270 270,570 660,1080 1080,1500 1500,1650
block in,| actually sometimes just
|实际上有时候只是惊慌失措。

1358
00:37:39,030 --> 00:37:40,000
0,600
panics.|
|

1359
00:37:40,060 --> 00:37:41,680
0,420 420,630 630,1200 1200,1320 1320,1620
{You,know} this clearly is a
你知道这显然是一个完全不受欢迎的解决方案，也不是一个真正的解决方案，

1360
00:37:41,710 --> 00:37:45,130
0,660 690,1740 1740,2430 2460,3180 3180,3420
completely undesirable a solution and

1361
00:37:45,130 --> 00:37:46,180
0,90 90,270 270,360 360,600 600,1050
it's not a real solution,|
|

1362
00:37:46,180 --> 00:37:47,380
0,390 450,810 810,930 930,1110 1110,1200
so why we call it
所以我们称之为稻草人解决方案。

1363
00:37:47,380 --> 00:37:48,780
0,30 30,420 420,900
a strawman solution.|
|

1364
00:37:49,010 --> 00:37:51,290
0,480 720,900 900,1290 1290,1770 1770,2280
{} The other strawman solution
另一种稻草人解决方案是，当您调用时，比方说您分配了一块新的内存，

1365
00:37:51,290 --> 00:37:53,120
0,330 330,930 960,1530 1530,1740 1740,1830
is to, {} when you

1366
00:37:53,120 --> 00:37:54,740
0,540 540,720 720,930 930,1230 1230,1620
call let's say you allocate

1367
00:37:54,740 --> 00:37:55,730
0,30 30,210 210,390 390,450 450,990
a new piece of memory,|
|

1368
00:37:55,730 --> 00:37:56,810
0,90 90,210 210,360 360,840 840,1080
you know you go to
你知道你会打电话给Alalloc，这是一个新的实际分配方式，

1369
00:37:56,810 --> 00:37:58,730
0,330 330,780 990,1560 1560,1710 1710,1920
call alloc, new to actually

1370
00:37:58,730 --> 00:38:00,650
0,390 390,570 870,1230 1230,1350 1350,1920
allocate it,| you could actually
|你可以，实际上，你知道，等待内存分配器。

1371
00:38:00,650 --> 00:38:01,580
0,60 60,180 180,450 450,540 540,930
you know wait for memory

1372
00:38:01,580 --> 00:38:02,580
0,540
allocator.|
|

1373
00:38:02,820 --> 00:38:03,660
0,150 150,270 270,510 510,630 630,840
I'm going to be one
我要做一个提议，结果不是一个好提议

1374
00:38:03,660 --> 00:38:05,130
0,480 480,570 570,750 810,1140 1140,1470
proposal to do, turns out

1375
00:38:05,130 --> 00:38:06,150
0,60 60,180 180,240 240,420 420,1020
{not,to} be a good proposal|
|

1376
00:38:06,570 --> 00:38:08,430
0,750 750,1230 1230,1320 1320,1620 1620,1860
{} and the reason it's
这不是一个好提议的原因是你可能会陷入僵局，

1377
00:38:08,430 --> 00:38:09,450
0,150 150,180 180,360 360,840 840,1020
not a good proposal is

1378
00:38:09,450 --> 00:38:10,620
0,180 180,300 300,480 480,1050 1080,1170
that you may deadlock,| you
|你知道，假设下面的场景，你持有一些，比方说内核有一个很大的内核锁，

1379
00:38:10,620 --> 00:38:11,500
0,390
know,

1380
00:38:11,500 --> 00:38:12,940
0,300 300,360 360,660 660,1200 1200,1440
assume the following scenario, yo're

1381
00:38:12,940 --> 00:38:13,990
0,330 330,630 630,840 840,960 960,1050
holding some, let's say the

1382
00:38:13,990 --> 00:38:15,130
0,270 270,390 390,600 600,840 840,1140
kernel has one big kernel

1383
00:38:15,130 --> 00:38:17,260
0,420 690,1320 1320,1800 1800,1920 1920,2130
lock,| {} and you call
|然后调用malloc，等待进入内存分配器，

1384
00:38:17,260 --> 00:38:19,570
0,810 810,960 960,1230 1230,1620 1620,2310
malloc you wait into the

1385
00:38:19,600 --> 00:38:21,640
0,300 300,870 1170,1560 1560,1890 1890,2040
memory allocator,| then basically no
|那么基本上没有其他进程可以运行。

1386
00:38:21,640 --> 00:38:23,320
0,420 420,720 720,840 840,1200
other process can run.|
|

1387
00:38:23,530 --> 00:38:24,580
0,330 330,540 540,630 630,780 780,1050
{} And you would have
并且在您的下一个进程中会有一个死锁类型，

1388
00:38:24,580 --> 00:38:25,930
0,330 330,750 750,1020 1020,1230 1230,1350
a deadlock type in your

1389
00:38:25,930 --> 00:38:27,070
0,240 240,540 540,660 660,810 810,1140
next process,| that would actually
|它实际上会尝试运行，例如，以释放一些内存，

1390
00:38:27,070 --> 00:38:28,210
0,210 210,330 330,750 750,840 840,1140
try to run for example

1391
00:38:28,210 --> 00:38:29,980
0,90 90,330 330,480 480,960 1230,1770
to free some memory {},|
|

1392
00:38:29,980 --> 00:38:31,720
0,210 210,510 510,870 870,1170 1170,1740
{you,know} couldn't run actually deadlock.|
你知道不能真的死锁了。|

1393
00:38:32,490 --> 00:38:33,300
0,150 150,420 420,570 570,690 690,810
Of course, this is if
当然，这是如果你有一个很大的内核锁，就会有一个明显的问题，

1394
00:38:33,300 --> 00:38:34,650
0,90 90,180 180,930 930,1140 1140,1350
you have a big kernel

1395
00:38:34,650 --> 00:38:36,090
0,270 270,480 480,570 570,930 930,1440
lock, there's an obvious problem,|
|

1396
00:38:36,090 --> 00:38:36,870
0,120 120,300 300,450 450,690 690,780
you know, but even if
你知道，但是即使你有一个非常小的，细粒度的锁，

1397
00:38:36,870 --> 00:38:38,460
0,120 120,330 330,390 390,870 960,1590
you have a very small,

1398
00:38:38,880 --> 00:38:40,950
0,570 600,1170 1170,1710 1770,1950 1950,2070
a fine-grained locking,| it is
|它很容易在这样一种情况下运行，即基本上在分配器中等待的人员或进程持有某种锁，

1399
00:38:40,950 --> 00:38:41,670
0,240 240,330 330,540 540,660 660,720
easy to run in a

1400
00:38:41,670 --> 00:38:43,950
0,540 540,690 690,1320 1380,1920 1950,2280
situation where basically the person

1401
00:38:43,950 --> 00:38:45,180
0,120 120,210 210,540 540,690 690,1230
or the process, that's waiting

1402
00:38:45,180 --> 00:38:47,400
0,450 450,870 900,1620 1740,1890 1890,2220
in the allocator is holding

1403
00:38:47,400 --> 00:38:48,750
0,210 210,630 630,780 780,1080 1080,1350
some lock,| that somebody else
|其他人需要实际释放内存。

1404
00:38:48,750 --> 00:38:49,830
0,360 360,450 450,720 720,990 990,1080
needs to actually free the

1405
00:38:49,830 --> 00:38:50,640
0,390
memory.|
|

1406
00:38:50,840 --> 00:38:51,710
0,330 330,420 420,570 570,690 690,870
{} And that can get
这基本上会让你陷入僵局。

1407
00:38:51,710 --> 00:38:53,420
0,210 210,570 570,750 750,1140 1140,1710
you basically this deadlock situation.|
|

1408
00:38:54,710 --> 00:38:56,330
0,510 990,1140 1140,1320 1320,1440 1440,1620
{} And so we're going
所以我们没有稻草人就是基本上失败了，或者当你不再有记忆的时候，

1409
00:38:56,330 --> 00:38:58,580
0,270 270,390 390,840 870,1890 1890,2250
{strawman -} free {} is

1410
00:38:58,580 --> 00:39:01,190
0,660 690,1110 1110,1710 1890,2310 2310,2610
to basically fail, {} or

1411
00:39:01,190 --> 00:39:02,720
0,300 300,570 570,570 1260,1440 1440,1530
when you {} there's no

1412
00:39:02,720 --> 00:39:04,490
0,270 270,720 720,1110 1110,1590 1590,1770
memory anymore,| alloc returns like
|Alalloc返回时没有指针，您检查时没有指针，

1413
00:39:04,490 --> 00:39:05,780
0,180 180,750 750,900 900,1140 1140,1290
no pointer, you check with

1414
00:39:05,780 --> 00:39:07,220
0,210 210,810 810,1050 1050,1230 1230,1440
no pointer,| it's no point
|你不使用(救助)是没有意义的。

1415
00:39:07,220 --> 00:39:09,200
0,180 180,720 870,1200 1200,1290 1290,1980
you fail use a [bailout].|
|

1416
00:39:09,840 --> 00:39:11,520
0,600 690,900 900,1290 1290,1560 1560,1680
{} But bailing out is
但是跳伞实际上并不是那么简单，

1417
00:39:11,520 --> 00:39:14,070
0,270 270,600 600,780 780,1890 1950,2550
actually not that straightforward {},|
|

1418
00:39:14,070 --> 00:39:15,300
0,210 210,420 420,660 660,1020 1020,1230
you know the process might
您知道，进程可能实际上已经分配了内存，

1419
00:39:15,300 --> 00:39:17,790
0,300 300,450 450,900 900,1740 1740,2490
actually have allocated memory already,|
|

1420
00:39:17,820 --> 00:39:18,660
0,360 360,480 480,570 570,720 720,840
you need to get rid
你得把它扔掉，

1421
00:39:18,660 --> 00:39:19,980
0,90 90,450 570,1020 1020,1200 1200,1320
of that,| {} you may
|您可能已经执行了一些部分磁盘操作，

1422
00:39:19,980 --> 00:39:21,330
0,150 150,360 360,660 660,1080 1080,1350
have done some partial disk

1423
00:39:21,330 --> 00:39:22,590
0,570 570,780 780,840 840,1200 1200,1260
operations,| like for example if
|例如，如果您执行多个步骤，您知道部分操作可能完成了部分操作，但不是全部，

1424
00:39:22,590 --> 00:39:23,550
0,60 60,180 180,240 240,510 510,960
you do a multi steps

1425
00:39:23,610 --> 00:39:24,870
0,390 390,510 510,900 900,1140 1140,1260
{you,know} partial operation maybe have

1426
00:39:24,870 --> 00:39:25,680
0,150 150,360 360,480 480,660 660,810
done some of it, but

1427
00:39:25,680 --> 00:39:26,400
0,150 150,330 330,420 420,660 660,720
not all of it,| you
|你必须跳出困境。

1428
00:39:26,400 --> 00:39:27,000
0,120 120,210 210,390 390,540 540,600
have to bail out of

1429
00:39:27,000 --> 00:39:27,880
0,420
that.|
|

1430
00:39:27,880 --> 00:39:29,350
0,300 300,420 420,690 870,1380 1380,1470
{} And so, {} it
因此，事实证明，要做对是非常非常困难的。

1431
00:39:29,350 --> 00:39:30,100
0,180 180,240 240,330 330,600 600,750
turns out to actually get

1432
00:39:30,100 --> 00:39:31,240
0,360 420,750 750,900 900,960 960,1140
very very hard to get

1433
00:39:31,240 --> 00:39:32,100
0,330
right.|
|

1434
00:39:32,340 --> 00:39:34,560
0,600 990,1590 1770,1980 1980,2160 2160,2220
{} In, {} sort of
有趣的是，你知道当你深入研究这件事的时候

1435
00:39:34,560 --> 00:39:36,240
0,480 480,1260 1290,1380 1380,1440 1440,1680
interesting, {} you know when

1436
00:39:36,240 --> 00:39:38,250
0,270 270,450 450,930 1020,1770 1770,2010
digging into this| {} and
|并试图思考如何解决这个问题，

1437
00:39:38,250 --> 00:39:39,090
0,180 180,240 240,390 390,720 720,840
trying to think about how

1438
00:39:39,090 --> 00:39:40,770
0,90 90,300 300,390 390,930 1050,1680
to solve this problem,| Linux
|Linux使用这两种解决方案。

1439
00:39:40,800 --> 00:39:43,020
0,750 810,1260 1260,1320 1320,1500 1500,2220
uses both of these solutions.|
|

1440
00:39:43,500 --> 00:39:45,240
0,630 630,1260 1260,1380 1380,1470 1470,1740
{} And you know both
你知道两者实际上都有麻烦或问题，

1441
00:39:45,240 --> 00:39:47,550
0,270 270,750 780,1350 1380,1650 1650,2310
actually have trouble or problems,|
|

1442
00:39:47,730 --> 00:39:50,460
0,630 630,1770 1770,2130 2130,2520 2520,2730
and indeed kernel developers actually
事实上，内核开发人员实际上很难真正弄清楚这一切，

1443
00:39:50,460 --> 00:39:51,810
0,210 210,720 720,870 870,1170 1170,1350
have difficulty to actually get

1444
00:39:51,810 --> 00:39:52,800
0,120 120,240 240,720 750,870 870,990
this all straight,| if you're
|如果你对这个很感兴趣，我们想看一些有趣的讨论，

1445
00:39:52,800 --> 00:39:54,450
0,450 720,1170 1170,1230 1230,1530 1530,1650
very interested in this and

1446
00:39:54,450 --> 00:39:55,200
0,240 240,420 420,480 480,630 630,750
we want to see some

1447
00:39:55,200 --> 00:39:56,880
0,270 270,660 660,870 870,1170
interesting discussion about this,|
|

1448
00:39:56,880 --> 00:39:58,140
0,540 540,750 750,870 870,1170 1170,1260
google for "too small to
在谷歌上搜索“太小而不能倒”，有一篇小文章谈到了其中的一些复杂情况，

1449
00:39:58,140 --> 00:40:00,090
0,570 750,1260 1260,1530 1590,1890 1890,1950
fail" {} and there's a

1450
00:40:00,090 --> 00:40:01,440
0,240 240,600 600,930 930,1140 1140,1350
little article that talks about

1451
00:40:01,440 --> 00:40:02,820
0,180 180,270 270,390 390,1290 1290,1380
some of these complications,| you
|您知道有空闲的内存或在分配器中等待，

1452
00:40:02,820 --> 00:40:05,070
0,360 360,1020 1140,1440 1440,2040 2040,2250
know a free memory or

1453
00:40:05,070 --> 00:40:06,990
0,270 270,330 330,420 420,1080 1410,1920
waiting in the allocator {},|
|

1454
00:40:06,990 --> 00:40:09,030
0,450 450,1140 1290,1620 1620,1860 1860,2040
and {} the problem that
以及可能导致的问题。

1455
00:40:09,030 --> 00:40:10,060
0,120 120,630
can cause.|
|

1456
00:40:10,650 --> 00:40:12,330
0,270 270,330 330,570 570,930 1230,1680
Now it turns out, {}
现在事实证明，对我们来说，“稻草人2”就是解决之道

1457
00:40:12,360 --> 00:40:13,500
0,180 180,570 570,690 690,900 900,1140
for us, you know so

1458
00:40:13,530 --> 00:40:15,210
0,390 390,660 660,780 780,1230 1230,1680
strawman 2 be the solution|
|

1459
00:40:15,210 --> 00:40:16,140
0,90 90,180 180,270 270,630 630,930
that you could imagine doing,
这是你可以想象到的，但是对于我们来说，就像前面提到的，

1460
00:40:16,140 --> 00:40:17,010
0,150 150,360 360,480 480,660 660,870
but then for us just

1461
00:40:17,010 --> 00:40:18,870
0,150 150,480 480,810 1410,1620 1620,1860
as mentioned earlier,| this was
|这是不可能的，因为新的不能返回，不能失败，

1462
00:40:18,870 --> 00:40:21,030
0,210 210,750 750,1020 1020,1680 1890,2160
not possible because new just

1463
00:40:21,030 --> 00:40:23,280
0,420 420,1020 1290,1650 1650,2040 2070,2250
cannot return cannot fail,| it
|它总是成功的，所以我们在某种程度上有一个不会发生这种情况的范围。

1464
00:40:23,280 --> 00:40:24,780
0,240 240,630 630,1200 1260,1410 1410,1500
just always succeeds, so we've

1465
00:40:24,780 --> 00:40:25,650
0,180 180,300 300,600 600,660 660,870
got a range in some

1466
00:40:25,650 --> 00:40:27,300
0,180 180,360 360,870 870,1260 1260,1650
way that this cannot happen.|
|

1467
00:40:28,590 --> 00:40:30,180
0,480 510,960 960,1350 1350,1410 1410,1590
{} Plus neither of these
另外，这两种解决方案实际上都不是特别理想，

1468
00:40:30,180 --> 00:40:31,710
0,120 120,480 480,690 690,1080 1080,1530
two solutions actually particular ideal,|
|

1469
00:40:31,710 --> 00:40:32,550
0,240 240,390 390,630 630,690 690,840
so we wanted to come
所以我们想要想出一些潜在的更好的东西。

1470
00:40:32,550 --> 00:40:33,780
0,90 90,210 210,540 540,960 960,1230
up with something that was

1471
00:40:33,960 --> 00:40:35,700
0,780 780,1200
potentially better.|
|

1472
00:40:36,780 --> 00:40:37,950
0,180 180,480 480,630 630,960 960,1170
Any questions so far about
到目前为止，关于堆耗尽的设置有任何问题，

1473
00:40:37,950 --> 00:40:40,260
0,60 60,690 780,1590 1590,1800 1800,2310
the setup around heap exhaustion,|
|

1474
00:40:40,260 --> 00:40:41,490
0,330 330,330 330,660 660,870 870,1230
before I talk about like
在我谈论饼干是怎么做的之前。

1475
00:40:41,490 --> 00:40:42,510
0,240 240,330 330,510 510,810 810,1020
how the way Biscuit does

1476
00:40:42,510 --> 00:40:43,260
0,210
it.|
|

1477
00:40:48,420 --> 00:40:50,020
0,270 270,540 540,690 690,1080
This problem makes sense?|
这个问题有意义吗？|

1478
00:40:58,960 --> 00:41:00,460
0,390 390,810 810,900 900,1380 1380,1500
I'll interpret the signings as
我会把签约解释为“是”然后继续，

1479
00:41:00,460 --> 00:41:02,500
0,510 690,1170 1200,1440 1440,1710 1710,2040
yes then keep going,| but
|但我想随时都会打断你。

1480
00:41:02,500 --> 00:41:04,500
0,360 360,450 450,990 990,1410
figure to interrupt anytime.|
|

1481
00:41:06,800 --> 00:41:07,820
0,300 300,570 570,840 840,930 930,1020
Okay, so what is the
好的，那么饼干的解决方案是什么，

1482
00:41:07,820 --> 00:41:10,850
0,330 330,990 1020,1740 1950,2400 2400,3030
Biscuit solution,| {} yeah as
|是的，作为一种高水平的饼干溶液，几乎是直截了当的。

1483
00:41:10,850 --> 00:41:11,600
0,60 60,240 240,570 570,660 660,750
a high level of the

1484
00:41:11,600 --> 00:41:12,950
0,300 300,630 630,810 810,1050 1050,1350
Biscuit solution is like almost

1485
00:41:12,950 --> 00:41:14,300
0,270 270,840
straight forward.|
|

1486
00:41:14,420 --> 00:41:16,100
0,660 660,870 870,1140 1140,1470 1470,1680
{} What basically does like
当您执行系统调用(比如读取fork)时，

1487
00:41:16,100 --> 00:41:17,090
0,150 150,270 270,660 660,690 690,990
when you execute a system

1488
00:41:17,090 --> 00:41:18,380
0,270 270,420 420,570 570,720 720,1290
call like say you read

1489
00:41:19,010 --> 00:41:20,180
0,660
fork,|
|

1490
00:41:20,420 --> 00:41:22,880
0,540 690,1230 1230,1650 1650,1980 1980,2460
{} before jumping actually into
在就在分叉系统调用的开始处实际跳转到分叉系统调用之前，

1491
00:41:22,880 --> 00:41:24,230
0,90 90,390 390,660 660,1020 1050,1350
the fork system call right

1492
00:41:24,230 --> 00:41:25,100
0,60 60,120 120,540 540,660 660,870
at the beginning of the

1493
00:41:25,100 --> 00:41:26,090
0,240 240,540 540,810 810,900 900,990
fork system call,| if you
|如果您觉得在名为Dispatcher系统中有xv6的索引，

1494
00:41:26,090 --> 00:41:26,870
0,180 180,330 330,420 420,480 480,780
feel like in a system

1495
00:41:26,870 --> 00:41:28,640
0,180 180,930 1020,1290 1290,1650 1650,1770
called dispatcher a index to

1496
00:41:28,640 --> 00:41:30,050
0,330 330,690 810,1200 1200,1290 1290,1410
xv6,| then first thing it
|然后它做的第一件事就是所谓的保留。

1497
00:41:30,050 --> 00:41:31,980
0,240 240,540 540,870 870,1470
does actually calls reserve.|
|

1498
00:41:32,630 --> 00:41:34,880
0,450 450,930 930,1320 1320,1590 1590,2250
And {it,basically} reserves enough memory,
它基本上保留了足够的内存，以便能够执行系统调用。

1499
00:41:35,120 --> 00:41:36,620
0,600 600,1140 1140,1260 1260,1440 1440,1500
{} to be able to

1500
00:41:36,620 --> 00:41:38,200
0,360 360,420 420,690 690,1080
execute the system call.|
|

1501
00:41:38,380 --> 00:41:39,790
0,330 330,510 510,930 930,1140 1140,1410
{} So there's a free
所以有足够的空闲内存

1502
00:41:39,790 --> 00:41:42,880
0,630 750,1350 1350,1860 2160,2640 2640,3090
memory {} in enough| that
|实际上，无论系统调用实际需要的内存是什么，

1503
00:41:42,880 --> 00:41:44,440
0,270 270,900 900,1080 1080,1380 1380,1560
actually whatever on memory that

1504
00:41:44,440 --> 00:41:45,730
0,270 270,360 360,630 630,840 840,1290
actually the system call needs,|
|

1505
00:41:45,910 --> 00:41:47,440
0,420 420,570 570,1230 1230,1380 1380,1530
{} the reservation will be
预订将会足够大，实际上也会成功。

1506
00:41:47,440 --> 00:41:48,910
0,180 180,510 510,690 690,1230 1230,1470
big enough that actually and

1507
00:41:48,910 --> 00:41:50,040
0,150 150,660
will succeed.|
|

1508
00:41:50,430 --> 00:41:51,750
0,510 540,750 750,990 990,1050 1050,1320
So, so once the system
所以，一旦系统调用开始，并且实际上成功地保留了内存，

1509
00:41:51,750 --> 00:41:53,610
0,450 480,840 840,1260 1260,1590 1590,1860
call goes off and actually

1510
00:41:53,610 --> 00:41:55,560
0,480 480,570 570,930 930,1440 1530,1950
successful in reserving memory {},|
|

1511
00:41:55,560 --> 00:41:56,610
0,150 150,480 480,690 690,930 930,1050
it will actually run all
它实际上会一直运行到

1512
00:41:56,610 --> 00:41:57,720
0,90 90,240 240,780 810,1020 1020,1110
the way through| and we
|而且我们从来没有遇到过内存不足或堆耗尽的问题。

1513
00:41:57,720 --> 00:41:59,100
0,90 90,480 480,720 720,990 1020,1380
were never with the problems

1514
00:41:59,100 --> 00:42:00,120
0,90 90,180 180,420 420,540 540,1020
that there won't be enough

1515
00:42:00,150 --> 00:42:02,440
0,690 690,1080 1080,1320 1320,1800
memory or heap exhaustion.|
|

1516
00:42:03,340 --> 00:42:04,900
0,330 390,780 780,1020 1020,1320 1320,1560
And if there's not enough
如果您要预订的时间点没有足够的内存，

1517
00:42:04,900 --> 00:42:05,680
0,300 300,390 390,450 450,690 690,780
memory at the point you

1518
00:42:05,680 --> 00:42:06,790
0,120 120,180 180,330 330,420 420,1110
want to do the reservation,|
|

1519
00:42:06,820 --> 00:42:08,290
0,180 180,600 600,870 870,1110 1110,1470
then basically just wait here.|
那基本上就在这里等着吧。|

1520
00:42:09,940 --> 00:42:11,110
0,270 270,480 480,630 630,720 720,1170
{} But at the beginning
但是在系统调用开始时，系统调用不持有任何锁，

1521
00:42:11,110 --> 00:42:11,980
0,120 120,210 210,510 510,810 810,870
of the system call, the

1522
00:42:11,980 --> 00:42:13,150
0,240 240,450 450,660 660,990 990,1170
system call doesn't hold any

1523
00:42:13,150 --> 00:42:14,830
0,510 510,750 750,990 990,1200 1200,1680
locks,| doesn't hold any resources
|目前还没有任何资源，

1524
00:42:14,830 --> 00:42:15,550
0,210 210,330 330,480 480,660 660,720
yet,| so it actually is
|所以它实际上是非常好的，你知道，等等，没有死锁的风险。

1525
00:42:15,550 --> 00:42:16,990
0,390 390,930 930,1020 1020,1200 1200,1440
perfectly fine, you know wait

1526
00:42:16,990 --> 00:42:20,200
0,510 510,1440 1500,2040 2040,2520 2520,3210
there's no risk of {}

1527
00:42:20,260 --> 00:42:21,640
0,930
deadlock.|
|

1528
00:42:22,160 --> 00:42:23,870
0,240 240,840 840,930 930,1500 1530,1710
And while it's waiting you
当它在等待的时候，你知道它当然可以这样做，它可以打电话，

1529
00:42:23,870 --> 00:42:24,710
0,180 180,330 330,450 450,540 540,840
know it can of course

1530
00:42:24,710 --> 00:42:26,540
0,210 210,750 750,1350 1350,1440 1440,1830
be doing it can call,|
|

1531
00:42:26,540 --> 00:42:29,150
0,540 570,870 870,990 990,1530 1830,2610
{} kernel can actually evict
内核实际上可以驱逐缓存，您知道尝试减少基本上释放的堆空间，

1532
00:42:29,150 --> 00:42:30,680
0,540 540,720 720,1140 1170,1380 1380,1530
cache, you know try to

1533
00:42:30,680 --> 00:42:32,390
0,330 330,900 930,1260 1260,1530 1530,1710
reduce the basically make free

1534
00:42:32,390 --> 00:42:35,420
0,450 450,630 630,1230 1410,2040 2040,3030
up heap space,| maybe as
|也许就像你看到的，也许会杀死一个进程，

1535
00:42:36,350 --> 00:42:37,760
0,150 150,570 570,810 810,1350 1350,1410
you've seen maybe kill a

1536
00:42:37,760 --> 00:42:39,500
0,630 630,930 930,1050 1050,1650 1650,1740
process,| that to force you
|强迫你知道记忆实际上是被释放的。

1537
00:42:39,500 --> 00:42:41,000
0,120 120,510 510,840 840,1050 1050,1500
know memories actually be freed.|
|

1538
00:42:41,590 --> 00:42:43,090
0,600 600,750 750,1050 1050,1410 1410,1500
{} And then once you
然后一旦你知道内存是可用的

1539
00:42:43,090 --> 00:42:44,080
0,90 90,330 330,390 390,900 900,990
know memory is available| and
|内核决定的很好，你知道我可以满足预订，

1540
00:42:44,080 --> 00:42:45,100
0,60 60,270 270,630 630,930 930,1020
the kernel decides well you

1541
00:42:45,100 --> 00:42:46,270
0,120 120,240 240,420 720,1110 1110,1170
know I can meet a

1542
00:42:46,270 --> 00:42:48,040
0,750 750,990 990,1140 1140,1500 1500,1770
reservation,| then it will let
|然后它会让系统调用基本上停止并运行

1543
00:42:48,040 --> 00:42:49,330
0,300 300,600 600,780 780,1080 1080,1290
the system call basically goes

1544
00:42:49,330 --> 00:42:50,680
0,180 180,300 300,690 840,1050 1050,1350
off and runs| and basically
|基本上执行它需要做的任何事情

1545
00:42:50,680 --> 00:42:52,120
0,540 540,1140 1140,1200 1200,1350 1350,1440
executes whatever it needs to

1546
00:42:52,120 --> 00:42:53,290
0,60 60,450 780,930 930,1080 1080,1170
be done| and then at
|然后在最后，当系统崩溃的时候，

1547
00:42:53,290 --> 00:42:54,340
0,60 60,330 330,690 720,990 990,1050
the very end when the

1548
00:42:54,340 --> 00:42:55,420
0,270 270,480 480,720 720,930 930,1080
system goes down,| it's like
|就像好了，我做完了，所有保留的内存基本上都回到了池中，

1549
00:42:55,420 --> 00:42:56,710
0,150 150,330 330,750 930,1110 1110,1290
okay I'm done and all

1550
00:42:56,710 --> 00:42:57,850
0,90 90,420 420,540 540,660 660,1140
the memory that was reserve

1551
00:42:57,850 --> 00:42:58,840
0,300 300,480 480,810 810,900 900,990
basically comes back to the

1552
00:42:58,840 --> 00:43:01,330
0,570 780,1170 1170,1740 1740,1980 1980,2490
pool,| {} available for subsequent
|可用于后续系统调用。

1553
00:43:01,330 --> 00:43:02,720
0,570 570,1050
system calls.|
|

1554
00:43:03,770 --> 00:43:04,580
0,180 180,360 360,390 390,660 660,810
And there's a couple of
这些特殊的解决方案有几个很好的特性，

1555
00:43:04,580 --> 00:43:06,560
0,360 360,1050 1200,1500 1500,1620 1620,1980
nice properties about these particular

1556
00:43:06,560 --> 00:43:08,990
0,750 750,1380 1380,1590 1590,1950 1950,2430
solutions,| there's no checks necessary
|内核本身不需要检查，

1557
00:43:08,990 --> 00:43:10,430
0,60 60,120 120,390 390,990 1020,1440
in the kernel itself,| like
|就像您永远不需要检查内存分配是否会失败一样，

1558
00:43:10,430 --> 00:43:11,570
0,120 120,390 390,540 540,660 660,1140
you never have to check

1559
00:43:11,600 --> 00:43:13,760
0,480 480,990 990,1380 1410,1770 1770,2160
whether memory {} memory allocation

1560
00:43:13,760 --> 00:43:15,440
0,150 150,630 810,1020 1020,1140 1140,1680
can fail,| which is particularly
|这在我们的情况下特别好，

1561
00:43:15,440 --> 00:43:16,610
0,120 120,300 300,570 570,750 750,1170
in our case good,| because
|因为你知道去，他们不会失败的。

1562
00:43:16,610 --> 00:43:17,600
0,90 90,330 330,540 540,690 690,990
you know go, they can't

1563
00:43:17,600 --> 00:43:18,560
0,510
fail.|
|

1564
00:43:18,620 --> 00:43:19,910
0,240 240,420 420,660 660,1020 1020,1290
There's no error handling code
没有错误处理代码，完全没有必要，

1565
00:43:19,910 --> 00:43:21,260
0,90 90,540 540,630 630,1050 1170,1350
and necessary at all,| and
|而且没有死锁的风险，因为您在一开始就避免了没有实际持有锁的情况。

1566
00:43:21,260 --> 00:43:22,400
0,150 150,300 300,570 570,660 660,1140
there's no risk for deadlock,

1567
00:43:22,400 --> 00:43:23,630
0,210 210,570 570,1080 1080,1170 1170,1230
because you're avoiding in the

1568
00:43:23,630 --> 00:43:25,220
0,240 240,870 870,1230 1230,1470 1470,1590
very beginning without when you

1569
00:43:25,220 --> 00:43:26,780
0,240 240,450 450,600 600,1080
actually hold no locks.|
|

1570
00:43:27,010 --> 00:43:28,660
0,150 150,510 1050,1200 1200,1380 1410,1650
Of course, you know there's
当然，你知道有很多很棒的井，

1571
00:43:28,660 --> 00:43:30,490
0,150 150,600 600,1170 1320,1620 1620,1830
all wonderful well,| the only
|唯一的问题是有什么挑战，当然，你是如何预订的，

1572
00:43:30,490 --> 00:43:31,810
0,150 150,300 300,480 480,690 690,1320
thing is like how there's

1573
00:43:31,810 --> 00:43:32,740
0,120 120,480 480,540 540,780 780,930
a challenge, of course, how

1574
00:43:32,740 --> 00:43:34,060
0,90 90,210 210,300 300,900 1140,1320
you do the reservation,| how
|你怎么计算，你知道，一个系统调用可能需要多少内存来执行它。

1575
00:43:34,060 --> 00:43:35,440
0,90 90,210 210,870 900,1020 1020,1380
do you compute you know,

1576
00:43:35,940 --> 00:43:37,710
0,180 180,630 720,1410 1410,1470 1470,1770
how much memory a system

1577
00:43:37,710 --> 00:43:41,220
0,600 630,1230 1230,1830 2070,2610 2610,3510
call might need to {}

1578
00:43:41,720 --> 00:43:43,260
0,450 450,810 810,990
to execute it.|
|

1579
00:43:43,590 --> 00:43:44,370
0,180 180,300 300,480 480,690 690,780
And so now we have
所以现在我们有了一个谜题。

1580
00:43:44,370 --> 00:43:46,160
0,420 420,930
a puzzle.|
|

1581
00:43:47,780 --> 00:43:49,520
0,630 660,750 750,900 900,1260 1260,1740
In you know it's important
你知道你保留的坐骑是很重要的，

1582
00:43:49,520 --> 00:43:52,460
0,450 720,1620 1650,2010 2010,2400 2400,2940
that the mount you reserve,|
|

1583
00:43:52,460 --> 00:43:53,540
0,360 360,750 750,870 870,960 960,1080
one one you could do
你可以做的一件事是，你可以保留一半的记忆或类似的东西，

1584
00:43:53,540 --> 00:43:54,830
0,120 120,420 420,540 540,990 990,1290
is you can reserve half

1585
00:43:54,830 --> 00:43:55,940
0,330 330,390 390,630 630,780 780,1110
memory or something like that,|
|

1586
00:43:55,940 --> 00:43:57,410
0,150 150,690 690,930 930,990 990,1470
some ridiculous amount of memory
每一次系统调用都有一些荒谬的内存量，

1587
00:43:57,560 --> 00:43:58,820
0,300 300,480 480,750 750,1080 1110,1260
for every system call,| but
|但这意味着您限制了可以并发执行的系统调用的数量，

1588
00:43:58,820 --> 00:43:59,840
0,120 120,450 450,690 690,930 930,1020
that means you limit the

1589
00:43:59,840 --> 00:44:00,740
0,240 240,300 300,570 570,810 810,900
number of system calls you

1590
00:44:00,740 --> 00:44:02,090
0,120 120,540 540,1110 1110,1260 1260,1350
can execute concurrently,| so you
|所以你想在某种程度上把工作做得很好

1591
00:44:02,090 --> 00:44:03,050
0,180 180,360 360,540 540,630 630,960
want to sort of do

1592
00:44:03,050 --> 00:44:04,220
0,90 90,300 300,420 420,900 930,1170
a pretty good job| and
|实际上，计算系统调用可能需要的内存量非常多。

1593
00:44:04,220 --> 00:44:06,500
0,600 600,870 960,1470 1470,2100 2130,2280
actually {} computing abound of

1594
00:44:06,500 --> 00:44:07,430
0,90 90,330 330,390 390,720 720,930
the amount of memory that

1595
00:44:07,430 --> 00:44:09,100
0,210 210,510 510,1200
the system call

1596
00:44:09,100 --> 00:44:10,540
0,210 210,480 480,870
{} might need.|
|

1597
00:44:11,050 --> 00:44:13,900
0,450 780,1320 1650,1890 1890,2130 2130,2850
{} So, {} the way,
所以，我们最终做这件事的方式结果就像是高级语言帮助了我们，

1598
00:44:13,900 --> 00:44:16,990
0,900 1770,2340 2340,2820 2820,2910 2910,3090
{} we ended up doing

1599
00:44:16,990 --> 00:44:18,610
0,300 300,1110 1110,1230 1230,1470 1470,1620
this gonna end turned out

1600
00:44:18,610 --> 00:44:20,110
0,150 150,360 360,420 420,870 870,1500
like sort of high-level language

1601
00:44:20,140 --> 00:44:23,020
0,660 1200,1560 1560,1710 1710,2100 2250,2880
{} helped us here,| turned
|事实证明，围棋实际上很容易在静电上进行分析，

1602
00:44:23,020 --> 00:44:23,710
0,90 90,240 240,390 390,510 510,690
out like Go is actually

1603
00:44:23,710 --> 00:44:25,450
0,240 240,450 450,570 570,1230 1230,1740
pretty easy to static analyze,|
|

1604
00:44:25,450 --> 00:44:28,480
0,90 90,390 840,1590 1590,2460 2490,3030
in fact Go {} runtime
事实上，Go Runtime和Go基础架构生态系统

1605
00:44:28,480 --> 00:44:30,490
0,390 390,540 540,1020 1020,1560 1560,2010
and Go infrastructure ecosystem| comes
|附带了一大堆用于分析Go代码的软件包。

1606
00:44:30,490 --> 00:44:31,270
0,270 270,390 390,450 450,630 630,780
comes with a whole bunch

1607
00:44:31,270 --> 00:44:33,160
0,60 60,750 990,1200 1200,1710 1710,1890
of packages to analyze Go

1608
00:44:33,160 --> 00:44:33,960
0,420
code.|
|

1609
00:44:34,100 --> 00:44:36,050
0,600 600,750 750,900 900,1200 1200,1950
And we use those packages
我们主要使用这些软件包来计算系统称为nead的内存量，

1610
00:44:36,050 --> 00:44:39,170
0,450 450,570 570,1350 1650,2310 2310,3120
basically to compute {} the

1611
00:44:39,560 --> 00:44:41,990
0,570 570,870 870,1350 1350,1680 1680,2430
amount of memory, that the

1612
00:44:42,020 --> 00:44:43,280
0,270 270,480 480,900 930,1110 1110,1260
system call nead,| so you
|所以你可以考虑一下，比方说你必须阅读系统调用，对吧，

1613
00:44:43,280 --> 00:44:44,270
0,90 90,240 240,480 480,780 780,990
can think about the, let's

1614
00:44:44,270 --> 00:44:45,410
0,420 420,780 780,870 870,930 930,1140
say you have to read

1615
00:44:45,410 --> 00:44:46,660
0,300 300,810
system call,

1616
00:44:46,940 --> 00:44:48,620
0,300 300,390 390,1320 1380,1590 1590,1680
right,| you know you know
|您知道，我们可以查看系统调用的调用图

1617
00:44:48,620 --> 00:44:49,130
0,90 90,210 210,360 360,450 450,510
we could look at the

1618
00:44:49,130 --> 00:44:50,420
0,360 360,720 720,810 810,960 960,1290
call graph of the system

1619
00:44:50,420 --> 00:44:51,530
0,390 390,480 480,720 720,810 810,1110
call| or calls the function
|或者调用函数f，调用函数g，调用函数h，

1620
00:44:51,530 --> 00:44:52,820
0,330 330,540 540,600 600,930 930,1290
f calls the function g

1621
00:44:52,820 --> 00:44:53,870
0,210 210,270 270,600 600,810 810,1050
calls the function h {blah,blah,blah

1622
00:44:53,870 --> 00:44:55,340
0,570 570,720 720,1170 1170,1350 1350,1470
-},| might continue a whole
|可能会继续一整串，您知道在系统调用结束时，它会再次绑定到堆栈

1623
00:44:55,340 --> 00:44:57,110
0,450 570,900 900,1230 1230,1500 1530,1770
bunch and you know at

1624
00:44:57,110 --> 00:44:58,130
0,90 90,210 210,270 270,510 510,1020
the end of system {call,it}

1625
00:44:58,130 --> 00:44:59,330
0,360 360,450 450,690 690,930 930,1200
binds to stack again| and
|然后返回到用户空间。

1626
00:44:59,330 --> 00:45:01,160
0,240 240,420 420,630 630,1170 1380,1830
then goes back to return

1627
00:45:01,160 --> 00:45:02,280
0,90 90,240 240,720
to user space.|
|

1628
00:45:02,520 --> 00:45:03,960
0,390 600,1080 1080,1260 1260,1320 1320,1440
And basically what we can
基本上我们能做的就是你知道，分配，你知道，或者计算出最大深度，

1629
00:45:03,960 --> 00:45:04,560
0,90 90,240 240,390 390,450 450,600
do is like you know

1630
00:45:04,560 --> 00:45:06,000
0,660 660,750 750,960 960,1140 1140,1440
allocate you know or figure

1631
00:45:06,000 --> 00:45:08,370
0,390 390,570 570,900 1110,1770 1770,2370
out what the maximum depth,|
|

1632
00:45:08,940 --> 00:45:10,470
0,150 150,510 510,810 810,1110 1110,1530
you know of this this
你知道这张调用图，在任何特定的时间，

1633
00:45:12,510 --> 00:45:14,300
0,360 360,720 720,1260
call graph is,

1634
00:45:14,330 --> 00:45:16,100
0,480 480,720 720,930 930,1290 1290,1770
{} at any particular time,|
|

1635
00:45:16,130 --> 00:45:17,150
0,150 150,390 390,720 720,840 840,1020
and then basically for that
然后基本上对于这个最大深度，

1636
00:45:17,150 --> 00:45:18,680
0,390 390,780 780,870 870,960 960,1530
maximum depth,| you know compute
|你知道计算你知道多少实时内存，这些函数中的每一个都需要，

1637
00:45:18,680 --> 00:45:19,790
0,270 270,570 570,660 660,810 810,1110
how much you know live

1638
00:45:19,790 --> 00:45:21,470
0,420 420,570 570,660 660,1080 1080,1680
memory, each of these functions

1639
00:45:21,470 --> 00:45:22,670
0,300 300,510 510,780 780,930 930,1200
need,| so if this function
|因此，如果此函数调用new，您知道[]会分配内存，

1640
00:45:22,670 --> 00:45:23,960
0,210 210,330 330,780
calls {new -},

1641
00:45:23,960 --> 00:45:25,130
0,90 90,240 240,450 450,750 750,1170
you know that [] allocates

1642
00:45:25,130 --> 00:45:26,180
0,510 540,630 630,780 780,930 930,1050
memory,| you know we know
|你知道我们知道有什么样的物体，有一种高级语言，

1643
00:45:26,180 --> 00:45:27,500
0,330 330,540 540,630 630,1080 1080,1320
what kind of objects, there

1644
00:45:27,500 --> 00:45:28,460
0,330 360,540 540,570 570,720 720,960
are, there's a high level

1645
00:45:28,460 --> 00:45:29,660
0,450 450,600 600,690 690,810 810,1200
language,| so we can compute
|所以我们可以计算出这个物体的大小，

1646
00:45:29,660 --> 00:45:30,620
0,90 90,390 390,450 450,570 570,960
the size of that object

1647
00:45:30,620 --> 00:45:31,430
0,150 150,450 450,540 540,660 660,810
is,| we can just add
|我们可以把它们加起来，它会给我们一些数字s，

1648
00:45:31,430 --> 00:45:32,630
0,90 90,480 780,930 930,1020 1020,1200
them up and it gives

1649
00:45:32,630 --> 00:45:33,800
0,90 90,270 270,540 540,960 990,1170
us some number s,| that
|也就是说，就像内存总量或最大内存量一样，

1650
00:45:33,800 --> 00:45:34,820
0,240 240,420 420,480 480,810 810,1020
says like the total amount

1651
00:45:34,820 --> 00:45:36,110
0,60 60,450 450,570 570,720 750,1290
of memory or the maximum

1652
00:45:36,110 --> 00:45:37,130
0,150 150,210 210,540 540,840 840,1020
amount of memory,| that can
|它可以在调用图的任何特定时间点处于活动状态。

1653
00:45:37,130 --> 00:45:38,450
0,210 210,510 510,690 690,900 900,1320
be live at any particular

1654
00:45:38,450 --> 00:45:41,390
0,180 180,270 270,810 840,1830 2040,2940
point of time for a

1655
00:45:41,570 --> 00:45:42,660
0,300 300,720
call graph.|
|

1656
00:45:43,290 --> 00:45:44,070
0,240 240,300 300,570 570,690 690,780
And the reason is you
原因是你知道这有点棘手，

1657
00:45:44,070 --> 00:45:45,660
0,90 90,360 360,840 840,1350 1350,1590
know it's slightly tricky,| it's
|事情不是这么简单的，

1658
00:45:45,660 --> 00:45:46,590
0,150 150,240 240,480 480,600 600,930
not as simple as this,|
|

1659
00:45:46,590 --> 00:45:47,820
0,300 300,390 390,840 840,930 930,1230
because for example a function
因为例如，函数h可能分配一些内存，然后传递回g

1660
00:45:47,820 --> 00:45:50,280
0,570 780,1260 1260,1650 1650,1770 1770,2460
h might allocate some memory,

1661
00:45:50,800 --> 00:45:53,020
0,210 210,510 510,960 960,1560 1830,2220
and then pass back to

1662
00:45:53,020 --> 00:45:54,190
0,450 510,690 690,960 960,1050 1050,1170
g| and so you know
|所以你知道h结束了，但是你知道g实际上得到了h分配的内存

1663
00:45:54,190 --> 00:45:57,010
0,240 240,900 1320,1770 1770,2490 2490,2820
h finishes {} and {}

1664
00:45:57,010 --> 00:45:58,120
0,240 240,360 360,450 450,750 750,1110
but you know g actually

1665
00:45:58,120 --> 00:45:59,650
0,90 90,210 210,600 600,1110 1140,1530
you know gets the memory

1666
00:45:59,650 --> 00:46:01,720
0,150 150,420 420,510 510,1170 1470,2070
that h is allocated| and
|这就是所谓的逃逸，记忆从h逃逸到g

1667
00:46:01,720 --> 00:46:03,520
0,510 510,600 600,930 930,1710 1710,1800
this is called escaping, the

1668
00:46:03,520 --> 00:46:05,360
0,210 210,390 390,900 900,1410
{memory -} escapes from

1669
00:46:05,360 --> 00:46:06,320
0,540
{you,know}

1670
00:46:06,380 --> 00:46:08,390
0,300 300,450 450,690 690,1350 1440,2010
{} from h {to,g} {}|
|

1671
00:46:08,390 --> 00:46:09,680
0,210 210,300 300,510 510,960 960,1290
it {turns -} out, there
结果是，有一些标准算法在做这种逃逸分析

1672
00:46:09,680 --> 00:46:11,450
0,90 90,780 810,1410 1410,1500 1500,1770
are standard algorithms were doing

1673
00:46:11,450 --> 00:46:12,770
0,180 180,240 240,390 390,720 720,1320
sort of this escape analysis|
|

1674
00:46:12,770 --> 00:46:14,450
0,180 180,540 540,960 960,1170 1170,1680
to see determine which variables
查看以确定哪些变量转义到调用方

1675
00:46:14,450 --> 00:46:16,550
0,390 390,480 480,570 570,1110 1560,2100
escape to the callers| and
|在这种情况下，你基本上知道，无论h分配的是什么内存，它仍然是活的，

1676
00:46:16,550 --> 00:46:17,660
0,360 360,540 540,690 690,1020 1020,1110
{} in that case, {you,know}

1677
00:46:17,660 --> 00:46:19,220
0,360 360,660 660,960 960,1110 1110,1560
basically whatever memory was allocated

1678
00:46:19,220 --> 00:46:20,180
0,150 150,420 420,510 510,690 690,960
by h and that's still

1679
00:46:20,180 --> 00:46:21,050
0,120 120,510 510,600 600,750 750,870
{alive -},| we have to
|不管g是什么，我们都要加上。

1680
00:46:21,050 --> 00:46:22,880
0,630 690,810 810,1200 1200,1470 1470,1830
add to whatever g is.|
|

1681
00:46:23,760 --> 00:46:24,690
0,210 210,570 600,720 720,810 810,930
{} So you know we
所以你知道我们必须加到s中。

1682
00:46:24,690 --> 00:46:25,500
0,120 120,210 210,270 270,570 570,810
have to be added into

1683
00:46:25,500 --> 00:46:26,420
0,390
s.|
|

1684
00:46:27,040 --> 00:46:28,510
0,240 240,480 480,810 810,1050 1050,1470
A quick question about this,|
关于这一点，我有一个简短的问题，|

1685
00:46:29,440 --> 00:46:31,390
0,750 780,1260 1260,1590 1590,1800 1800,1950
so let's assume more in
所以让我们在一些函数中做更多假设，

1686
00:46:31,390 --> 00:46:34,120
0,360 360,1080 1410,2010 2010,2220 2220,2730
some function,| depending on different
|根据该功能预期具有的不同工作负荷，

1687
00:46:34,120 --> 00:46:35,440
0,600 600,780 780,900 900,1200 1200,1320
workloads that the function is

1688
00:46:35,440 --> 00:46:37,090
0,570 570,660 660,1050 1350,1500 1500,1650
expected to have,| there might
|可能分配了不同的存储器存储器量，

1689
00:46:37,090 --> 00:46:39,520
0,180 180,840 840,1710 1800,2130 2130,2430
be different memories memory amounts

1690
00:46:39,520 --> 00:46:41,590
0,630 840,1230 1230,1560 1740,1920 1920,2070
allocated,| so what is there
|那么最坏的情况是什么，什么是内存分配过程。

1691
00:46:41,590 --> 00:46:43,240
0,180 180,330 330,1050 1050,1320 1320,1650
like a worst-case, what memory

1692
00:46:43,240 --> 00:46:45,460
0,630 630,1350 1380,1680 1680,1860 1860,2220
allocation process.| Yeah that's basically
|是的，基本上这是一种保守的方案，是正确的。

1693
00:46:45,460 --> 00:46:46,720
0,240 240,390 390,450 450,930 930,1260
it's sort of conservative scheme

1694
00:46:46,720 --> 00:46:49,090
0,450 450,660 660,900 900,1350 1800,2370
correctly| and {} we {}
|我们，我们，这个工具计算，基本上是最坏的函数调用深度。

1695
00:46:49,090 --> 00:46:51,430
0,360 360,1590 1590,1680 1680,2040 2040,2340
we computed, the tool computes,

1696
00:46:51,430 --> 00:46:54,610
0,660 960,1380 1380,1860 1860,2760 2790,3180
basically a worst possible {}

1697
00:46:54,610 --> 00:46:56,420
0,570 570,630 630,1020 1020,1590
depth of function calls.|
|

1698
00:46:56,830 --> 00:46:58,660
0,690 690,1410 1410,1500 1500,1710 1710,1830
{} And you know for
你知道，从最坏的情况来看，

1699
00:46:58,660 --> 00:47:00,970
0,480 510,780 780,1380 1380,2160 2160,2310
that the worst-case analysis,| how
|到达系统调用可能需要多少内存，

1700
00:47:00,970 --> 00:47:02,290
0,180 180,600 600,900 900,1230 1230,1320
much memory that reaches system

1701
00:47:02,290 --> 00:47:04,630
0,450 750,1230 1230,1650 1680,1920 1920,2340
call might need,| in practice,
|在实践中，它可能需要，系统调用可能需要少得多，

1702
00:47:04,630 --> 00:47:05,620
0,120 120,330 330,450 450,600 600,990
it might need, there {system,call}

1703
00:47:05,620 --> 00:47:06,760
0,210 210,390 390,450 450,690 690,1140
might need a lot less,|
|

1704
00:47:06,940 --> 00:47:08,470
0,570 570,840 840,990 990,1110 1110,1530
{} but you know for
但是你知道如果你知道要保守的话，

1705
00:47:08,470 --> 00:47:09,610
0,420 450,630 630,750 750,990 990,1140
{} you know to be

1706
00:47:09,610 --> 00:47:11,560
0,600 600,1050 1050,1260 1260,1590 1590,1950
conservative,| we have to allocate
|我们必须为最坏的情况分配我们计划的工作。

1707
00:47:11,560 --> 00:47:12,520
0,90 90,390 390,570 570,900 900,960
the work we plan for

1708
00:47:12,520 --> 00:47:13,620
0,90 90,300 300,720
the worst case.|
|

1709
00:47:14,000 --> 00:47:15,590
0,300 630,1050 1140,1260 1260,1410 1410,1590
And so we've come to
所以我们在这里谈到了几个重要的问题，

1710
00:47:15,590 --> 00:47:17,810
0,360 360,780 780,1230 1560,1980 1980,2220
a couple of important points

1711
00:47:17,810 --> 00:47:19,190
0,240 240,600 930,1200 1200,1290 1290,1380
here,| because, {} you know
|因为，您知道一些系统调用，例如循环的执行，

1712
00:47:19,190 --> 00:47:20,930
0,570 720,1110 1110,1380 1380,1440 1440,1740
some system calls for example

1713
00:47:20,930 --> 00:47:22,520
0,420 420,660 660,900 900,1080 1080,1590
executive for loop,| that's depended
|这取决于系统调用的参数，对吧，

1714
00:47:22,520 --> 00:47:23,600
0,120 120,630 630,720 720,810 810,1080
on argument to the system

1715
00:47:23,600 --> 00:47:24,440
0,390
call,

1716
00:47:24,660 --> 00:47:25,740
0,360 360,480 480,630 630,870 870,1080
right,| so you can't actually
|所以你实际上不能静态地计算出界限是什么

1717
00:47:25,740 --> 00:47:26,910
0,510 510,840 840,960 960,1080 1080,1170
statically figure out what the

1718
00:47:26,910 --> 00:47:28,380
0,300 300,690 1080,1290 1290,1440 1440,1470
bound is| and so a
|因此，在很多情况下，我们对代码进行了注释

1719
00:47:28,380 --> 00:47:30,780
0,270 270,330 330,930 930,1830 1890,2400
number of cases we annotated

1720
00:47:30,780 --> 00:47:31,950
0,60 60,480 480,570 570,810 810,1170
the code| to say well
|可以说，这就是这个循环的最大界限

1721
00:47:31,950 --> 00:47:33,240
0,150 150,270 270,360 360,900 900,1290
this is the maximum bounds

1722
00:47:33,240 --> 00:47:34,980
0,60 60,270 270,660 960,1620 1620,1740
of this loop| and you
|你可以假设这不会超过这一点

1723
00:47:34,980 --> 00:47:35,760
0,90 90,330 330,450 450,570 570,780
can assume it's no more

1724
00:47:35,760 --> 00:47:37,200
0,90 90,450 450,810 810,1140 1140,1440
than that| and use that
|并用它来实际计算这个数字s。

1725
00:47:37,200 --> 00:47:38,310
0,90 90,330 330,690 690,810 810,1110
to actually compute this number

1726
00:47:38,310 --> 00:47:39,080
0,390
s.|
|

1727
00:47:39,990 --> 00:47:41,610
0,540 540,1050 1050,1170 1170,1350 1350,1620
{} Similarly you know, for
同样，你知道，例如，如果你有一个递归函数，

1728
00:47:41,610 --> 00:47:42,720
0,630 630,840 840,930 930,1050 1050,1110
example if you have a

1729
00:47:42,720 --> 00:47:44,460
0,360 360,900 1260,1410 1410,1530 1530,1740
recursive function,| you know who
|你知道谁知道递归有多深吗？

1730
00:47:44,460 --> 00:47:45,420
0,270 270,390 390,600 600,690 690,960
knows how deep the {recursion

1731
00:47:45,420 --> 00:47:46,740
0,180 180,450 480,870 1050,1200 1200,1320
-} is, right| and that
|这也可能依赖于动态变量或系统调用的参数。

1732
00:47:46,740 --> 00:47:48,210
0,210 210,450 450,840 840,960 960,1470
might also be a dependent

1733
00:47:48,210 --> 00:47:49,500
0,180 180,240 240,780 780,1170 1170,1290
on a dynamic variable or

1734
00:47:49,500 --> 00:47:50,370
0,60 60,450 450,510 510,570 570,870
an argument to a system

1735
00:47:50,370 --> 00:47:51,160
0,360
call.|
|

1736
00:47:51,220 --> 00:47:52,930
0,210 210,450 450,960 1140,1380 1380,1710
In fact, you know we
事实上，你知道，我们在某些地方处理饼干时，基本上避免了递归函数传递，

1737
00:47:53,170 --> 00:47:54,460
0,90 90,210 210,480 570,930 930,1290
you know we treat Biscuit

1738
00:47:54,460 --> 00:47:56,080
0,60 60,210 210,690 690,1200 1200,1620
in some places basically avoid

1739
00:47:56,080 --> 00:47:58,420
0,390 390,930 930,1410 1740,2040 2040,2340
recursive function pass,| {} so
|所以实际上做这个，你知道做这种分析是可能的。

1740
00:47:58,420 --> 00:47:59,470
0,270 270,330 330,480 480,960 960,1050
actually it was possible to

1741
00:47:59,470 --> 00:48:01,060
0,180 180,540 540,870 900,1440 1440,1590
do this, {you,know} do this

1742
00:48:01,060 --> 00:48:02,440
0,210 210,270 270,930
kind of analysis.|
|

1743
00:48:02,770 --> 00:48:03,910
0,210 210,390 390,690 690,750 750,1140
So this kind of analysis,
所以这种分析，不是免费的，

1744
00:48:03,910 --> 00:48:04,780
0,180 180,300 300,600 600,720 720,870
not for free,| it's not
|它不是完全自动的，

1745
00:48:04,780 --> 00:48:06,700
0,300 300,840 1020,1320 1320,1500 1500,1920
completely automatic,| it takes a
|你知道，这个案子需要几天的工作，

1746
00:48:06,700 --> 00:48:07,750
0,240 240,420 420,510 510,930 930,1050
couple days of work you

1747
00:48:07,750 --> 00:48:09,130
0,120 120,480 540,840 840,1230 1230,1380
know for this case,| you
|你知道科迪要经历的，看看这些循环，然后注释。

1748
00:48:09,130 --> 00:48:10,540
0,120 120,600 600,720 720,840 840,1410
know cody to go through

1749
00:48:10,870 --> 00:48:12,310
0,450 450,570 570,690 690,900 900,1440
look at all these loops,

1750
00:48:12,400 --> 00:48:16,240
0,840 840,1560 1590,2100 2100,3210 3210,3840
{} and {} and annotate.|
|

1751
00:48:16,840 --> 00:48:17,770
0,570 570,690 690,780 780,900 900,930
{} You know there are
你知道还有几个具体的问题你必须处理

1752
00:48:17,770 --> 00:48:19,240
0,30 30,210 210,810 810,990 990,1470
a couple others Go specific

1753
00:48:19,240 --> 00:48:20,020
0,300 300,450 450,570 570,690 690,780
issues that you have to

1754
00:48:20,020 --> 00:48:21,610
0,270 270,540 540,1320 1320,1440 1440,1590
deal with| {like,slices}, you know
|就像切片一样，你知道它们的大小可能会翻倍，

1755
00:48:21,610 --> 00:48:22,960
0,150 150,420 450,840 840,960 960,1350
they might double in size,|
|

1756
00:48:22,960 --> 00:48:24,430
0,90 90,480 480,1020 1020,1110 1110,1470
if you add an element
如果您在切片中添加一个元素，那么我们可以模仿最大容量的切片，

1757
00:48:24,430 --> 00:48:26,530
0,90 90,720 1140,1710 1710,1890 1890,2100
to slice {} and so

1758
00:48:26,530 --> 00:48:28,300
0,690 690,1020 1020,1080 1080,1530 1530,1770
we imitate the slices which

1759
00:48:28,300 --> 00:48:30,670
0,480 480,1200 1500,2040 2070,2280 2280,2370
maximum capacity,| {} but I
|但是我在几天的工作中会用到各种可行的方法。

1760
00:48:30,670 --> 00:48:31,720
0,210 210,450 450,600 600,660 660,1050
use all sort of [doable],

1761
00:48:31,720 --> 00:48:32,830
0,120 120,180 180,390 390,600 600,1110
for a couple days work|
|

1762
00:48:32,860 --> 00:48:34,720
0,720 750,1290 1290,1410 1410,1560 1560,1860
and {} you know using
你知道，使用这个工具，你可以得到一个合理的数字。

1763
00:48:34,720 --> 00:48:35,770
0,150 150,420 420,690 690,810 810,1050
this tool, then you can

1764
00:48:35,770 --> 00:48:36,730
0,180 180,240 240,600 600,810 810,960
get a number out there

1765
00:48:36,730 --> 00:48:38,080
0,120 120,540 540,930
is reasonable good.|
|

1766
00:48:38,080 --> 00:48:40,300
0,180 180,510 510,750 750,1680 1740,2220
In terms of computing {}
在计算和特定系统调用所需的最大内存量方面。

1767
00:48:40,300 --> 00:48:42,970
0,600 900,1170 1200,2130 2220,2610 2610,2670
and a maximum amount of

1768
00:48:42,970 --> 00:48:44,200
0,420 420,600 600,660 660,960 960,1230
memory that a particular system

1769
00:48:44,200 --> 00:48:45,320
0,210 210,630
call needs.|
|

1770
00:48:46,150 --> 00:48:47,080
0,300 300,390 390,540 540,600 600,930
And so this is basically
所以这基本上就是你知道我们饼干基本上解决了这个特殊问题的方式。

1771
00:48:47,080 --> 00:48:49,030
0,600 630,720 720,900 900,1410 1440,1950
how you know we basically

1772
00:48:49,030 --> 00:48:50,890
0,390 390,750 750,900 900,1380 1380,1860
Biscuit solves this particular problem.|
|

1773
00:48:54,100 --> 00:48:55,810
0,270 270,660 660,1050 1050,1530 1530,1710
Oh sorry, what else are
哦，对不起，人们还用这个工具做什么，

1774
00:48:55,810 --> 00:48:57,910
0,360 360,720 720,1140 1140,1530 1530,2100
people using this tool for,|
|

1775
00:48:58,000 --> 00:48:59,350
0,240 240,480 480,810 870,1110 1110,1350
like they're not they're not
好像他们不是，他们不是在构建内核，他们用它做什么。

1776
00:48:59,350 --> 00:49:00,610
0,420 420,510 510,900 900,1170 1170,1260
building a kernel, what are

1777
00:49:00,610 --> 00:49:01,870
0,150 150,420 420,570 570,960 990,1260
they using it for.| Over
|通过静电分析包。

1778
00:49:01,870 --> 00:49:05,140
0,330 330,780 780,1410 2040,2430 2460,3270
static analysis package.| Yeah.| Go
|嗯。|围棋编译器杂志使用它进行各种优化，

1779
00:49:05,140 --> 00:49:06,490
0,420 420,810 810,1080 1080,1200 1200,1350
compiler journal uses it for

1780
00:49:06,490 --> 00:49:08,380
0,120 120,360 360,540 540,1770 1770,1890
all kinds of optimizations,| you
|你知道做静电分析，

1781
00:49:08,380 --> 00:49:10,060
0,150 150,420 420,1230
know to {

1782
00:49:10,060 --> 00:49:12,490
0,840 840,1440 1440,1740 1740,2010 2010,2430
-} and do static analysis,|
|

1783
00:49:12,760 --> 00:49:15,100
0,900 930,1440 1440,1740 1740,2040 2040,2340
{} {Go,go} to figure out
去找出最好的方法来编译它。

1784
00:49:15,100 --> 00:49:16,390
0,60 60,300 300,450 810,1140 1140,1290
the best way to for

1785
00:49:16,390 --> 00:49:17,170
0,60 60,240 240,330 330,420 420,780
the best way to compile

1786
00:49:17,170 --> 00:49:17,900
0,210
it.|
|

1787
00:49:18,270 --> 00:49:19,590
0,180 180,540 540,630 630,900 900,1320
I see, I see, okay,
我明白了，我明白了，好的，谢谢。

1788
00:49:19,830 --> 00:49:21,570
0,270 270,660 1050,1380 1380,1620 1620,1740
thank you.| {} So this
|所以这是一个包裹最酷的地方之一，

1789
00:49:21,570 --> 00:49:22,260
0,60 60,180 180,270 270,330 330,690
is one of the cool

1790
00:49:22,260 --> 00:49:23,640
0,270 270,600 600,870 870,930 930,1380
things about just a package,|
|

1791
00:49:23,640 --> 00:49:24,690
0,60 60,180 180,360 360,720 720,1050
you know the compiler happens
你知道编译器发生在你身上，你知道我们可以做什么。

1792
00:49:24,690 --> 00:49:25,470
0,90 90,330 330,510 510,630 630,780
to you, you know what

1793
00:49:25,470 --> 00:49:26,800
0,120 120,210 210,780
we could do.|
|

1794
00:49:27,500 --> 00:49:29,300
0,480 690,1110 1110,1230 1230,1530 1530,1800
{} We'll see later on
我们稍后会看到，我们还会将其用于其他几个功能。

1795
00:49:29,300 --> 00:49:30,110
0,180 180,420 420,600 600,660 660,810
we also use it for

1796
00:49:30,110 --> 00:49:31,790
0,60 60,300 300,480 480,990 1020,1680
a couple other features {}.|
|

1797
00:49:32,710 --> 00:49:34,570
0,600 690,1080 1080,1410 1410,1470 1470,1860
{} {It's,very} convenient to have.|
这是非常方便的。|

1798
00:49:37,640 --> 00:49:39,700
0,720 750,1380
Okay {}.|
好吧。|

1799
00:49:40,580 --> 00:49:42,110
0,300 300,540 540,600 600,720 720,1530
Okay, terms of the implementation,
好的，就实现而言，您知道基本上与其他内核非常相似，或者就像您知道的xv6一样，除了更高的性能。

1800
00:49:42,200 --> 00:49:44,060
0,810 810,1050 1050,1140 1140,1560 1560,1860
{} you know basically basically

1801
00:49:44,060 --> 00:49:46,190
0,180 180,450 450,570 570,1020 1020,2130
very similar to other {}

1802
00:49:46,220 --> 00:49:47,270
0,420 420,540 540,630 630,900 900,1050
kernels {or -} like you

1803
00:49:47,270 --> 00:49:49,820
0,360 360,930 930,1380 1380,2070 2100,2550
know xv6 except more high

1804
00:49:49,820 --> 00:49:51,040
0,780
performance.|
|

1805
00:49:51,070 --> 00:49:53,470
0,840 1350,1470 1470,1560 1560,1890 1920,2400
{} You know what we
您知道我们采用了Linux内核拥有的许多授权或智慧，

1806
00:49:53,470 --> 00:49:55,360
0,600 600,870 870,990 990,1140 1140,1890
adopted many of the authorizations

1807
00:49:55,360 --> 00:49:56,740
0,120 120,660 660,1050 1050,1140 1140,1380
or cleverness that the Linux

1808
00:49:56,740 --> 00:49:58,540
0,900 900,1350 1350,1500 1500,1740 1740,1800
kernel has,| at least the
|至少我们试图实现的系统调用，

1809
00:49:58,540 --> 00:49:59,500
0,300 300,570 570,690 690,810 810,960
system calls that we were

1810
00:49:59,500 --> 00:50:00,920
0,240 240,330 330,900
trying to implement,|
|

1811
00:50:00,920 --> 00:50:02,540
0,330 330,510 510,870 870,1140 1140,1620
{} {you,know} use large pages
您知道，内核文本使用大页面，以避免TLB开销，

1812
00:50:02,540 --> 00:50:04,550
0,300 300,570 570,1230 1230,1440 1440,2010
for kernel text, to avoid

1813
00:50:04,550 --> 00:50:06,320
0,420 420,660 660,1290
{TLB -} cost,|
|

1814
00:50:06,350 --> 00:50:08,210
0,540 540,720 720,840 840,1290 1290,1860
{} we have per-CPU NIC
我们有每个CPU的网卡传输队列，以避免端口之间的同步，

1815
00:50:08,210 --> 00:50:11,210
0,480 480,1140 1440,1680 1680,2010 2010,3000
transmit queues to avoid synchronization

1816
00:50:11,210 --> 00:50:14,330
0,1020 1230,1680 1680,2250 2580,2910 2910,3120
{} between port,| {} we
|我们有RCU，我会更多地谈谈目录缓存，

1817
00:50:14,330 --> 00:50:16,190
0,270 270,390 390,570 570,1650 1680,1860
have {RCU -}, I will

1818
00:50:16,190 --> 00:50:16,820
0,150 150,180 180,330 330,450 450,630
talk a little bit more

1819
00:50:16,820 --> 00:50:18,350
0,240 240,360 360,750 750,1170 1170,1530
about, the directory cache,| which
|其基本上是无锁或无读锁的目录高速缓存，

1820
00:50:18,350 --> 00:50:20,270
0,240 270,1020 1020,1410 1410,1710 1710,1920
is basically lock free or

1821
00:50:20,270 --> 00:50:22,550
0,240 240,570 570,990 1110,1770 1770,2280
read lock free directory cache,|
|

1822
00:50:22,550 --> 00:50:23,240
0,270 270,420 420,540 540,630 630,690
at the end of the
在学期末，我们将更详细地讨论RCU，

1823
00:50:23,240 --> 00:50:24,350
0,480 480,600 600,780 780,990 990,1110
semester, we'll talk about {RCU

1824
00:50:24,350 --> 00:50:25,280
0,120 120,210 210,300 300,450 450,930
- -} in more detail,|
|

1825
00:50:25,280 --> 00:50:26,450
0,150 150,300 300,660 750,990 990,1170
but you know, {} this
但你知道，这可能会有一些，你知道，一种常见的优化类型，实际上你需要获得高性能。

1826
00:50:26,450 --> 00:50:27,680
0,150 150,300 300,390 390,810
could have some to,

1827
00:50:29,720 --> 00:50:31,580
0,210 210,540 540,1140 1530,1800 1800,1860
you know a sort of

1828
00:50:31,580 --> 00:50:33,230
0,90 90,570 570,840 840,900 900,1650
the usual type of optimization

1829
00:50:33,230 --> 00:50:35,150
0,270 270,540 540,630 630,780 780,1920
that actually you need to

1830
00:50:35,180 --> 00:50:36,720
0,210 210,360 360,1020
get high performance.|
|

1831
00:50:36,720 --> 00:50:38,460
0,210 210,390 390,1290 1290,1650 1650,1740
And the main lesson I
我想我们学到的主要教训是

1832
00:50:38,460 --> 00:50:40,020
0,240 240,360 360,810 810,1110 1110,1560
think we learned is that|
|

1833
00:50:40,320 --> 00:50:41,490
0,420 420,540 540,750 750,1080 1080,1170
Go was not standing in
围棋并没有阻碍这些优化的实施，

1834
00:50:41,490 --> 00:50:42,630
0,120 120,420 420,510 510,960 960,1140
the way of implementing these

1835
00:50:42,630 --> 00:50:46,890
0,780 1530,2250 2700,3150 3150,3810 3810,4260
optimizations,| so there's opposition community
|所以有一些反对派社区是用C和Linux实现的，

1836
00:50:46,890 --> 00:50:48,120
0,210 210,390 390,840 840,930 930,1230
that were implemented in C

1837
00:50:48,120 --> 00:50:49,200
0,90 90,480 480,540 540,690 690,1080
and Linux,| you know we've
|您知道，我们基本上实现了相同的优化，但在Go中实现过

1838
00:50:49,200 --> 00:50:51,510
0,360 360,810 810,1320 1320,2190 2190,2310
basically implemented same optimization, but

1839
00:50:51,510 --> 00:50:53,070
0,210 210,690 690,840 840,1170 1380,1560
ever implemented in Go| and
|所以语言本身不是障碍，也不是问题，

1840
00:50:53,070 --> 00:50:53,910
0,90 90,180 180,420 420,750 750,840
so the language itself is

1841
00:50:53,910 --> 00:50:55,660
0,210 210,270 270,840 840,1350
not a hurdle or

1842
00:50:55,840 --> 00:50:57,850
0,90 90,570 720,1050 1050,1680 1680,2010
a problem,| in fact completely
|实际上完全有利于实际实施这些优化。

1843
00:50:57,850 --> 00:50:59,350
0,540 540,720 720,960 960,1350 1350,1500
conducive to actually implementing these

1844
00:50:59,350 --> 00:51:00,660
0,690
optimizations.|
|

1845
00:51:01,460 --> 00:51:02,330
0,240 240,300 300,420 420,480 480,870
There's a lot of work
要实现这些优化需要做很多工作，但与语言无关。

1846
00:51:02,330 --> 00:51:04,340
0,90 90,420 420,540 540,1260 1260,2010
to implement these optimizations, but

1847
00:51:04,370 --> 00:51:06,200
0,600 600,690 690,780 780,1350
irrespective of the language.|
|

1848
00:51:09,810 --> 00:51:10,680
0,240 240,330 330,450 450,690 690,870
OK, so that brings me
好的，这给我带来了某种程度上的估值，这就是整篇论文的真正动机，

1849
00:51:10,680 --> 00:51:12,390
0,180 180,300 300,870 1080,1560 1560,1710
sort of to {} the

1850
00:51:12,390 --> 00:51:13,530
0,510 510,660 660,750 750,960 960,1140
valuation which is really what

1851
00:51:13,530 --> 00:51:14,580
0,450
the,

1852
00:51:14,610 --> 00:51:15,390
0,60 60,510 510,570 570,630 630,780
the motivation of the whole

1853
00:51:15,390 --> 00:51:16,560
0,240 240,600 600,810 810,1020 1020,1170
paper was,| which is like
|这就像试图处理高级语言的好处和成本一样，

1854
00:51:16,560 --> 00:51:18,870
0,240 240,1170 1200,1500 1500,2040 2070,2310
trying to handle on {}

1855
00:51:18,870 --> 00:51:20,580
0,150 150,660 660,990 990,1200 1200,1710
the benefits and the costs

1856
00:51:20,580 --> 00:51:22,200
0,120 120,540 540,840 840,1050 1050,1620
of high-level language,| so basically,
|所以基本上，海拔可以分成两部分，

1857
00:51:22,720 --> 00:51:24,160
0,90 90,720 720,1050 1050,1140 1140,1440
the elevation sort of split

1858
00:51:24,160 --> 00:51:25,210
0,180 180,510 510,690 690,930 930,1050
{in,two} parts,| first talking about
|先谈效益，再谈成本。

1859
00:51:25,210 --> 00:51:26,380
0,60 60,600 600,690 690,900 900,1170
the benefits and then talking

1860
00:51:26,380 --> 00:51:27,580
0,150 150,210 210,690
about the costs.|
|

1861
00:51:29,370 --> 00:51:31,320
0,540 570,1020 1020,1200 1200,1350 1350,1950
So, {} so three questions,|
那么，那么有三个问题，|

1862
00:51:31,320 --> 00:51:32,760
0,90 90,450 750,1020 1020,1080 1080,1440
you know first of all,
你知道，首先，你知道有一个问题，比如没有作弊，

1863
00:51:32,760 --> 00:51:34,020
0,150 150,510 690,900 900,930 930,1260
you know there's a question

1864
00:51:34,020 --> 00:51:35,370
0,180 180,600 600,810 810,1260 1260,1350
like didn't do cheat,| you
|你知道，也许我们避开了Go提供的所有昂贵的高级语言功能。

1865
00:51:35,370 --> 00:51:36,780
0,300 360,690 690,840 840,1230 1230,1410
know maybe we avoided all

1866
00:51:36,780 --> 00:51:38,400
0,60 60,450 450,840 840,1140 1140,1620
the expensive high-level language features,

1867
00:51:38,940 --> 00:51:40,890
0,420 420,600 600,780 780,1260 1290,1950
{} that Go offers {}.|
|

1868
00:51:40,950 --> 00:51:43,410
0,390 390,1500 1500,1980 1980,2340 2340,2460
Does the, {second,question} {of,course} {does,the}
第二个问题当然是高层简化饼干代码。

1869
00:51:43,410 --> 00:51:45,180
0,480 480,900 900,960 960,1230 1230,1770
high-level simplify the Biscuit code.|
|

1870
00:51:45,180 --> 00:51:46,860
0,510 600,900 900,1050 1050,1470 1470,1680
And would to prevent some
并且会阻止我在课程前面提到的一些利用漏洞的行为。

1871
00:51:46,860 --> 00:51:48,030
0,60 60,240 240,780 780,1050 1050,1170
of these exploits that you

1872
00:51:48,030 --> 00:51:49,230
0,120 120,180 180,540 540,840 840,1200
know I mentioned early on

1873
00:51:49,230 --> 00:51:50,880
0,480 570,780 780,1170
in the lecture.|
|

1874
00:51:51,300 --> 00:51:52,950
0,300 300,660 870,1170 1170,1500 1500,1650
So first, this method use
因此，首先，该方法使用高级语言功能，

1875
00:51:52,950 --> 00:51:55,410
0,330 330,870 900,1800 2040,2310 2310,2460
high-level language features,| we just
|我们只是想看看我们在其他围棋大项目上，在语言功能方面是否相似，

1876
00:51:55,410 --> 00:51:56,550
0,210 210,300 300,630 630,960 960,1140
wanted to see whether we

1877
00:51:56,550 --> 00:51:58,230
0,510 630,1230 1230,1350 1350,1620 1620,1680
were similar in terms of

1878
00:51:58,230 --> 00:51:59,520
0,210 210,390 390,630 630,1140 1140,1290
other big Go projects, in

1879
00:51:59,520 --> 00:52:00,630
0,240 240,300 300,600 600,1020 1020,1110
terms of language features,| so
|所以我们可以说，就像所有的内核一样，似乎在以相似的方式做相同功能的大致相同的优点。

1880
00:52:00,630 --> 00:52:01,620
0,390 390,480 480,600 600,780 780,990
that we could say, like

1881
00:52:01,620 --> 00:52:02,490
0,150 150,210 210,570 570,810 810,870
all the kernel seems to

1882
00:52:02,490 --> 00:52:04,590
0,150 150,600 930,1590 1590,1680 1680,2100
be doing roughly the same

1883
00:52:04,590 --> 00:52:05,760
0,360 480,870 870,930 930,990 990,1170
{advantage -} of the same

1884
00:52:05,760 --> 00:52:07,800
0,480 600,960 960,1230 1230,1650
features in similar ways.|
|

1885
00:52:07,860 --> 00:52:08,910
0,300 300,510 510,660 660,960 960,1050
So we use actually the
所以我们实际上使用相同的静电分析工具或包

1886
00:52:08,910 --> 00:52:10,530
0,300 300,660 660,1140 1140,1470 1470,1620
same static analysis tool or

1887
00:52:10,530 --> 00:52:12,540
0,450 450,630 630,990 990,1590 1590,2010
package| to basically analyze a
|从根本上分析GitHub上的一大堆围棋软件，

1888
00:52:12,540 --> 00:52:15,450
0,180 180,690 1110,2130 2190,2550 2550,2910
whole bunch of two big

1889
00:52:15,450 --> 00:52:16,530
0,390 390,450 450,660 660,900 900,1080
pieces of Go {software -}

1890
00:52:16,530 --> 00:52:17,760
0,300 300,450 450,900 960,1110 1110,1230
that on github,| you know
|你知道有数百万行代码，

1891
00:52:17,760 --> 00:52:18,720
0,240 240,300 300,600 600,900 900,960
there are millions lines of

1892
00:52:18,720 --> 00:52:19,770
0,390 390,660 660,870 870,960 960,1050
code,| one is you know
|一种是自己运行它们和它的所有包

1893
00:52:19,770 --> 00:52:20,880
0,300 300,480 480,660 660,1020 1020,1110
Go run them itself and

1894
00:52:20,880 --> 00:52:22,740
0,150 150,240 240,810 1080,1470 1470,1860
all its packages| and the
|这个系统叫做白鲸。

1895
00:52:22,770 --> 00:52:24,240
0,390 390,570 570,1020
system called Moby.|
|

1896
00:52:24,550 --> 00:52:26,050
0,390 390,750 750,930 930,1080 1080,1500
And then we just basically
然后，我们基本上只为众多高级语言功能提供产品，

1897
00:52:26,050 --> 00:52:28,690
0,510 510,1140 1470,2010 2010,2370 2370,2640
product for numerous high-level language

1898
00:52:28,690 --> 00:52:29,860
0,420 420,600 600,840 840,1080 1080,1170
features,| how many times they
|千行用了多少次，

1899
00:52:29,860 --> 00:52:31,270
0,150 150,450 450,630 630,960 960,1410
were used for thousand lines,|
|

1900
00:52:31,360 --> 00:52:32,740
0,120 120,330 330,810 810,1050 1050,1380
so this graph shows that
所以这张图显示通常在附近，

1901
00:52:32,740 --> 00:52:34,320
0,90 90,480 480,810
are usually around,|
|

1902
00:52:34,410 --> 00:52:35,820
0,270 270,570 570,780 780,1110 1140,1410
{x-axis -} are the language
X轴是语言功能，基本上分配与调用new相对应

1903
00:52:35,820 --> 00:52:38,250
0,540 570,1290 1290,1860 1860,2340 2340,2430
features basically allocations correspond to

1904
00:52:38,250 --> 00:52:40,500
0,450 480,1290 1320,1560 1560,1800 2040,2250
calling new| and so this
|因此，这对应于垃圾收集器将动态分配的内存，

1905
00:52:40,500 --> 00:52:41,580
0,510 510,570 570,630 630,900 900,1080
corresponds to the memory that

1906
00:52:41,580 --> 00:52:43,410
0,60 60,270 270,630 690,1380 1380,1830
it will be dynamically allocated

1907
00:52:43,410 --> 00:52:45,720
0,150 150,240 240,540 540,1140 1500,2310
by the garbage collector,| maps
|映射类似于哈希表、切片或动态数组，

1908
00:52:45,720 --> 00:52:47,940
0,210 210,420 420,720 720,1560 1560,2220
are like hash tables, slices

1909
00:52:47,940 --> 00:52:49,230
0,150 150,510 510,1140 1140,1200 1200,1290
or dynamic arrays,| you know,
|你知道，这是频道同步，正如你所看到的，我们使用它们非常字面上的意思，

1910
00:52:49,230 --> 00:52:51,180
0,360 360,450 450,1080 1080,1800 1800,1950
here's the channels synchronization as

1911
00:52:51,180 --> 00:52:52,200
0,60 60,150 150,420 420,750 780,1020
you can see, we use

1912
00:52:52,200 --> 00:52:53,610
0,150 150,600 600,1080 1080,1230 1230,1410
them very literally,| but so
|但“白鲸”中的Go运行时也是如此。

1913
00:52:53,610 --> 00:52:54,840
0,240 240,300 300,600 600,1110 1110,1230
does the Go runtime in

1914
00:52:54,840 --> 00:52:55,780
0,60 60,570
the Moby.|
|

1915
00:52:56,160 --> 00:52:58,050
0,600 1020,1380 1380,1440 1440,1740 1740,1890
{} Clearly the feature that
显然，我们最喜欢的功能是多功能返回，能够返回多个值。

1916
00:52:58,050 --> 00:52:59,430
0,150 150,360 360,900 960,1230 1230,1380
we like most, it was

1917
00:52:59,430 --> 00:53:02,220
0,300 300,660 660,1350 1380,2010 2070,2790
multi function return, {} being

1918
00:53:02,220 --> 00:53:04,260
0,210 210,750 780,1050 1050,1380 1380,2040
able to return multiple values.|
|

1919
00:53:04,800 --> 00:53:05,880
0,600 600,690 690,810 810,900 900,1080
{} You know we use
你知道我们使用闭包，我们没有使用终结器，

1920
00:53:05,880 --> 00:53:07,770
0,870 930,1500 1500,1620 1620,1770 1770,1890
closures, {} we didn't use

1921
00:53:07,770 --> 00:53:10,110
0,780 810,1470 1530,1980 1980,2220 2220,2340
finalizer,| {} use defer a
|使用稍微延迟一点，

1922
00:53:10,110 --> 00:53:11,310
0,210 210,600 600,690 690,870 870,1200
little bit,| you know there's
|你知道我们确实创造了一堆围棋套路，

1923
00:53:11,310 --> 00:53:12,630
0,30 30,240 240,420 690,1200 1200,1320
a bunch of {Go,routines} that

1924
00:53:12,630 --> 00:53:13,740
0,90 90,240 240,780 780,930 930,1110
we do create,| we use
|我们使用接口。您知道要从一种类型转换为另一种类型的类型断言，使用类型[状态方式]，

1925
00:53:13,740 --> 00:53:15,040
0,810
interfaces.

1926
00:53:15,040 --> 00:53:16,690
0,690 690,840 840,930 930,1170 1170,1650
{} you know type assertions

1927
00:53:16,690 --> 00:53:18,070
0,120 120,510 510,810 870,1110 1110,1380
to convert from one type

1928
00:53:18,070 --> 00:53:20,830
0,120 120,690 1110,1800 1800,2520 2520,2760
to another, {} in the

1929
00:53:20,890 --> 00:53:23,500
0,240 240,450 450,870 1080,1800 1800,2610
type [state manner],| {} importing
|导入多个套餐，

1930
00:53:23,500 --> 00:53:25,720
0,240 240,810 840,1470 1530,1860 1860,2220
many packages,| so kernel selves
|因此，从任何软件包构建的内核本身并不像一个大的单一程序。

1931
00:53:25,720 --> 00:53:27,220
0,360 360,510 510,630 630,990 990,1500
build out of any packages

1932
00:53:27,220 --> 00:53:28,510
0,90 90,420 420,750 750,1080 1080,1290
are not like one big

1933
00:53:28,510 --> 00:53:29,660
0,270 270,720
single program.|
|

1934
00:53:29,880 --> 00:53:30,390
0,150 150,210 210,300 300,450 450,510
So if you look at
所以，如果你看看这个，你知道饼干的一些功能可以比Golang和Moby使用得更少

1935
00:53:30,390 --> 00:53:32,040
0,210 210,330 330,600 720,1110 1110,1650
this, you know some features

1936
00:53:32,040 --> 00:53:33,300
0,90 90,630 630,780 780,930 930,1260
you know Biscuit could use

1937
00:53:33,300 --> 00:53:34,470
0,390 390,690 690,870 870,1110 1110,1170
less than {Golang -} and

1938
00:53:34,470 --> 00:53:36,150
0,360 360,450 450,1050 1050,1140 1140,1680
Moby| and sometimes you know
|有时你知道这可能会在(院子里)更多或更大致地失去一些功能，

1939
00:53:36,150 --> 00:53:37,110
0,180 180,300 300,510 510,660 660,960
this could lose some features

1940
00:53:37,110 --> 00:53:38,550
0,450 450,660 660,1140 1140,1260 1260,1440
more or roughly in the

1941
00:53:38,550 --> 00:53:39,520
0,210
[yard],|
|

1942
00:53:39,970 --> 00:53:41,320
0,450 480,810 810,930 930,1170 1170,1350
not not in any sort
不是以任何明显不同的方式。

1943
00:53:41,320 --> 00:53:44,060
0,210 270,1260 1260,1860 1860,2160
of distinctly different way.|
|

1944
00:53:44,090 --> 00:53:45,770
0,480 510,720 720,1080 1080,1350 1350,1680
{} So the main conclusion
由此得出的主要结论是，您知道基本上使用高级功能实际上提供了

1945
00:53:45,770 --> 00:53:46,670
0,120 120,300 300,420 420,540 540,900
from this is you know

1946
00:53:46,790 --> 00:53:48,980
0,480 480,900 900,1110 1110,1770 1770,2190
basically uses the high-level features

1947
00:53:48,980 --> 00:53:50,060
0,210 210,390 390,750 750,870 870,1080
actually Go offer| and doesn't
|基本上不会为了获得好的形式而回避它们。

1948
00:53:50,060 --> 00:53:51,960
0,570 570,840 840,1020 1020,1410
sidestep them { -}

1949
00:53:54,020 --> 00:53:55,190
0,210 210,360 360,540 540,720 720,1170
to basically get good forms.|
|

1950
00:53:56,950 --> 00:53:58,820
0,570 660,1320
Okay {}.|
好吧。|

1951
00:53:58,850 --> 00:54:00,500
0,120 120,360 360,510 510,600 600,1650
{} I have a question,|
我有个问题，|

1952
00:54:01,430 --> 00:54:03,590
0,210 210,450 450,1200 1350,1680 1680,2160
how did you, {} how
你怎么，你怎么能数得清这一切，

1953
00:54:03,590 --> 00:54:04,670
0,120 120,240 240,540 540,660 660,1080
are you able to count

1954
00:54:04,670 --> 00:54:06,080
0,210 210,780 780,990 990,1110 1110,1410
all this,| did you use
|你有没有用过静电分析工具。

1955
00:54:06,080 --> 00:54:09,920
0,300 300,900 900,1620 1620,2070 2880,3840
the static analysis tool.| {Yeah,basically,use}
|是的基本上用的是静电套餐，静电分析套餐

1956
00:54:09,920 --> 00:54:12,140
0,300 300,1320 1320,1590 1590,1920 1920,2220
static package, static analysis package|
|

1957
00:54:12,140 --> 00:54:12,980
0,90 90,270 270,510 510,540 540,840
and then wrote a little
然后写了一个使用静电分析包的小程序

1958
00:54:12,980 --> 00:54:14,450
0,360 360,510 510,780 780,1080 1080,1470
program that uses static analysis

1959
00:54:14,450 --> 00:54:15,590
0,360 360,420 420,660 660,930 930,1140
packages| to go over every
|检查这些程序中的每一条语句，看看是哪种类型的语句。

1960
00:54:15,590 --> 00:54:16,910
0,420 420,480 480,630 630,1140 1140,1320
statement in these programs and

1961
00:54:16,910 --> 00:54:17,570
0,150 150,240 240,450 450,600 600,660
look at what kind of

1962
00:54:17,570 --> 00:54:19,060
0,210 210,270 270,750 750,1110
type of statement is.|
|

1963
00:54:19,800 --> 00:54:21,810
0,450 450,1110 1110,1110 1530,1830 1830,2010
And then, {} you get
然后，您可以获取参数以查看参数是如何使用的

1964
00:54:21,810 --> 00:54:22,740
0,90 90,480 480,600 600,780 780,930
the argument to see how

1965
00:54:22,740 --> 00:54:23,970
0,90 90,510 510,690 690,870 870,1230
the arguments are being used|
|

1966
00:54:23,970 --> 00:54:24,840
0,90 90,270 270,450 450,720 720,870
and that gives you a
这让你有了一种感觉，

1967
00:54:24,840 --> 00:54:26,680
0,270 270,570 570,930 930,1260
sense about how {},|
|

1968
00:54:27,080 --> 00:54:28,550
0,600 720,1110 1110,1170 1170,1230 1230,1470
{} allows you to count
允许您对这些功能进行计数。

1969
00:54:28,550 --> 00:54:29,700
0,120 120,570
these features.|
|

1970
00:54:31,250 --> 00:54:32,260
0,510

1971
00:54:35,880 --> 00:54:36,980
0,660

1972
00:54:37,600 --> 00:54:40,090
0,240 240,750 750,1530 1710,1920 1920,2490
Okay, so {} the next
好的，接下来的事情有点主观，

1973
00:54:40,090 --> 00:54:41,290
0,150 150,210 210,210 210,450 450,1200
thing is a little subjective,|
|

1974
00:54:41,380 --> 00:54:43,810
0,720 720,1260 1260,1710 1710,1980 1980,2430
{} the high-level language simplified
高级语言简化了饼干代码。

1975
00:54:43,810 --> 00:54:46,460
0,180 180,780 1200,2130
Biscuit code {}.|
|

1976
00:54:46,730 --> 00:54:47,780
0,270 270,420 420,600 600,660 660,1050
Yeah, I think it generally
是的，我认为大体上是这样的，一旦你明确地举了一两个例子进行辩论，

1977
00:54:47,780 --> 00:54:50,060
0,360 390,1110 1110,1350 1350,1680 1680,2280
did {} and once you

1978
00:54:50,060 --> 00:54:50,900
0,420 420,510 510,690 690,750 750,840
argued with one or two

1979
00:54:50,900 --> 00:54:53,210
0,450 450,1050 1050,1320 1590,2160 2160,2310
examples explicitly,| but {} you're
|但是你现在有GC分配实际上是非常好的

1980
00:54:53,210 --> 00:54:55,130
0,270 270,900 900,1110 1110,1350 1350,1920
now having {GC -} allocation

1981
00:54:55,130 --> 00:54:56,270
0,120 120,360 360,600 600,1050 1050,1140
is actually very nice| and
|如果你想到xv6，也许我可以说明这一点。

1982
00:54:56,270 --> 00:54:57,020
0,360 360,420 420,540 540,660 660,750
maybe I can make the

1983
00:54:57,020 --> 00:54:57,950
0,360 360,570 570,660 660,780 780,930
point if you think of

1984
00:54:57,950 --> 00:54:59,060
0,270 270,600 600,870 870,990 990,1110
{xv6 -}| or you do
|或者您执行EXEC，在EXEC点上，有很多数据结构需要释放

1985
00:54:59,060 --> 00:55:00,140
0,90 90,570
an exec,

1986
00:55:00,170 --> 00:55:01,160
0,300 300,390 390,630 630,690 690,990
on {} point of exec,

1987
00:55:01,160 --> 00:55:01,940
0,150 150,210 210,450 450,540 540,780
there's a lot of data

1988
00:55:01,940 --> 00:55:02,780
0,360 360,480 480,630 630,720 720,840
structures that need to be

1989
00:55:02,780 --> 00:55:04,340
0,390 390,810 870,1380 1380,1470 1470,1560
freed| or return to the
|或者返回到内核，以便以后的进程可以使用，

1990
00:55:04,340 --> 00:55:07,460
0,480 1590,2340 2370,2850 2850,3000 3000,3120
kernel and {} so that

1991
00:55:07,460 --> 00:55:09,290
0,240 240,600 600,780 780,1140 1410,1830
later process can use {},|
|

1992
00:55:09,290 --> 00:55:10,490
0,240 240,540 540,840 840,960 960,1200
using garbage collector is really
使用垃圾收集器真的很容易，

1993
00:55:10,490 --> 00:55:11,480
0,330 330,420 420,540 540,720 720,990
easy,| you know the garbage
|你知道垃圾收集器会处理所有的事情，

1994
00:55:11,480 --> 00:55:12,380
0,210 210,390 390,600 600,690 690,900
collector takes care of all

1995
00:55:12,380 --> 00:55:13,040
0,60 60,270 300,450 450,540 540,660
of it,| you know you
|你知道你真的不需要做太多。

1996
00:55:13,040 --> 00:55:13,820
0,150 150,390 390,540 540,630 630,780
don't really have to do

1997
00:55:13,820 --> 00:55:14,700
0,480
much.|
|

1998
00:55:14,700 --> 00:55:15,660
0,150 150,240 240,360 360,870 870,960
So if you allocate you
因此，如果您将您知道的分配给一个地址页面，

1999
00:55:15,660 --> 00:55:16,800
0,150 150,330 330,420 420,750 750,1140
know for an address page,|
|

2000
00:55:16,800 --> 00:55:18,870
0,720 720,1050 1050,1680 1680,1770 1770,2070
{you,know} {the,VMA} correspondent in address
您知道，地址空间中的VMA通信者也将被垃圾收集器自动释放。

2001
00:55:18,870 --> 00:55:20,280
0,300 300,480 480,600 600,1170 1170,1410
space will be automatically freed

2002
00:55:20,280 --> 00:55:21,390
0,120 120,210 210,540 540,840 840,1110
by the garbage collector too.|
|

2003
00:55:22,420 --> 00:55:23,440
0,210 210,450 450,570 570,690 690,1020
Yeah, so you know just
是的，所以你知道这很简单，

2004
00:55:23,440 --> 00:55:25,600
0,270 270,360 360,960 1260,1740 1920,2160
that as simple,| as we
|正如我们前面提到的，多个返回值在编程风格方面非常好，

2005
00:55:25,600 --> 00:55:26,920
0,300 300,660 660,750 750,1020 1020,1320
mentioned earlier, the multi return

2006
00:55:26,920 --> 00:55:28,390
0,450 450,630 630,900 900,1320 1320,1470
values were really nice in

2007
00:55:28,390 --> 00:55:30,520
0,210 210,270 270,660 660,1290 1500,2130
terms of programming style,| closures
|关闭很不错，

2008
00:55:30,520 --> 00:55:31,870
0,120 120,480 480,810 810,930 930,1350
were nice,| maps were great,
|地图很棒，你知道，你不需要去很多地方xv6，

2009
00:55:31,870 --> 00:55:33,310
0,90 90,360 360,1050 1110,1260 1260,1440
you know, {} you don't

2010
00:55:33,310 --> 00:55:35,800
0,120 120,600 780,1410 1410,1920 2100,2490
have to many [tape] places

2011
00:55:35,800 --> 00:55:37,480
0,270 270,450 450,570 570,1140 1500,1680
{xv6 -},| for example you
|例如，你以线性方式查找某些东西，

2012
00:55:37,480 --> 00:55:38,920
0,300 300,450 450,810 810,930 930,1440
look up something in a

2013
00:55:38,950 --> 00:55:40,840
0,390 390,1020 1020,1680 1680,1770 1770,1890
linear fashion,| but if you
|但是如果您将哈希表或映射作为第一类对象或抽象，

2014
00:55:40,840 --> 00:55:42,070
0,150 150,420 420,840 840,900 900,1230
have hash tables or maps

2015
00:55:42,070 --> 00:55:43,270
0,90 90,180 180,390 390,750 750,1200
as a first class object

2016
00:55:43,270 --> 00:55:44,650
0,150 150,660 660,720 720,1290 1290,1380
or abstraction,| the programmer, you
|程序员，你不会那么做的。

2017
00:55:44,650 --> 00:55:46,920
0,120 120,270 270,390 390,600
would never do that.|
|

2018
00:55:47,450 --> 00:55:48,830
0,510 510,750 750,1050 1050,1230 1230,1380
You use map and the
您使用map，运行时将负责高效地执行所有操作。

2019
00:55:48,860 --> 00:55:49,940
0,360 360,450 450,600 600,870 870,1080
runtime will take care of

2020
00:55:49,940 --> 00:55:51,680
0,390 390,690 690,1170
doing everything efficiently.|
|

2021
00:55:51,960 --> 00:55:53,220
0,300 300,420 420,930 930,1200 1200,1260
So, in in fact I
所以，实际上我认为从质量上来说，它感觉你得到了更简单的代码。

2022
00:55:53,220 --> 00:55:55,560
0,330 330,1140 1140,1440 1440,1920 2070,2340
think qualitatively, it feels you

2023
00:55:55,560 --> 00:55:56,940
0,120 120,450 450,840
get simpler code.|
|

2024
00:55:57,450 --> 00:55:59,250
0,240 240,450 450,840 840,1620 1620,1800
But as clearly qualitatively, you
但是定性的很清楚，你只是举了一个更具体的例子，我真的，

2025
00:55:59,250 --> 00:56:00,030
0,270 270,390 390,450 450,660 660,780
just give a little bit

2026
00:56:00,030 --> 00:56:01,170
0,180 180,270 270,330 330,630 630,1140
more of a concrete example

2027
00:56:01,170 --> 00:56:02,970
0,360 360,480 480,1110 1200,1500 1500,1800
where I really,| {} where
|在某种高级语言中，特定的垃圾收集器大放异彩的地方是

2028
00:56:02,970 --> 00:56:04,290
0,150 150,210 210,660 660,930 930,1320
sort of high-level language, particular

2029
00:56:04,290 --> 00:56:06,930
0,330 330,660 660,1350 1680,2340 2340,2640
garbage collector shines is| when
|当两者之间存在大量并发时，

2030
00:56:06,930 --> 00:56:07,830
0,120 120,180 180,300 300,360 360,900
there's a lot of concurrency

2031
00:56:07,830 --> 00:56:10,200
0,870 1290,1470 1470,1620 1620,2100 2100,2370
between,| when there's concurrency threads
|当存在并发时，线程和线程实际上共享特定的共享数据项。

2032
00:56:10,200 --> 00:56:11,580
0,120 120,390 390,600 600,1200 1230,1380
and threads actually share a

2033
00:56:11,580 --> 00:56:13,120
0,360 360,570 570,780 780,1080
particular shared data item.|
|

2034
00:56:13,330 --> 00:56:15,340
0,630 630,810 810,1020 1020,1290 1290,2010
{} And {so,for} example, {}
举个例子，这是一个简单的例子，你知道，或者你可以把这个问题归结为，

2035
00:56:15,700 --> 00:56:17,320
0,420 420,750 750,1080 1080,1530 1530,1620
here's a simple case, you

2036
00:56:17,320 --> 00:56:18,700
0,420 420,900 900,990 990,1080 1080,1380
know or you can boil

2037
00:56:18,700 --> 00:56:19,780
0,240 240,360 360,660 660,900 900,1080
down this question to,| let's
|假设以某种方式动态分配一个对象(如缓冲区)，

2038
00:56:19,780 --> 00:56:22,450
0,210 210,690 690,1770 1800,2580 2580,2670
say allocate somehow dynamically an

2039
00:56:22,450 --> 00:56:25,150
0,600 900,1080 1080,1140 1140,1710 2010,2700
object like a buffer {},|
|

2040
00:56:25,210 --> 00:56:27,190
0,900 900,1470 1470,1560 1560,1860 1860,1980
{you,fork} {a,thread} you know and
你分叉一条你知道的线程，然后这个过程就会缓冲

2041
00:56:27,190 --> 00:56:28,510
0,180 180,540 540,690 690,1110 1110,1320
that process that buffer| and
|还有另一个线程也处理缓冲区，并对此缓冲区执行一些操作。

2042
00:56:28,510 --> 00:56:29,920
0,240 240,570 570,1020 1020,1140 1140,1410
there's another thread that also

2043
00:56:29,920 --> 00:56:31,150
0,480 480,750 750,870 870,960 960,1230
process buffer and do something

2044
00:56:31,150 --> 00:56:32,160
0,60 60,240 240,630
of this buffer.|
|

2045
00:56:32,330 --> 00:56:33,200
0,240 240,360 360,570 570,810 810,870
Now when both threads are
现在，当两个线程都完成时，您知道缓冲区需要释放，

2046
00:56:33,200 --> 00:56:34,100
0,390 390,480 480,570 570,690 690,900
done, you know the buffer

2047
00:56:34,100 --> 00:56:34,970
0,150 150,240 240,360 360,690 780,870
needs to be free,| so
|因此，它们可以用于以后的内核操作。

2048
00:56:34,970 --> 00:56:36,050
0,300 300,420 420,510 510,810 810,1080
they can be used for

2049
00:56:36,050 --> 00:56:38,840
0,210 210,600 600,1680 1830,2310 2310,2790
a later {} later kernel

2050
00:56:38,840 --> 00:56:39,980
0,690
operations.|
|

2051
00:56:40,200 --> 00:56:40,860
0,150 150,210 210,450 450,540 540,660
And the question is like
问题是谁应该做这件事，谁负责，

2052
00:56:40,860 --> 00:56:42,510
0,480 480,600 600,750 750,1080 1410,1650
who should do this, who's

2053
00:56:42,510 --> 00:56:43,740
0,90 90,690
in charge,|
|

2054
00:56:43,770 --> 00:56:45,240
0,630 630,900 900,1290 1290,1320 1320,1470
{} and there's a little
用C来协调有点困难，

2055
00:56:45,240 --> 00:56:48,120
0,90 90,690 960,1440 1440,2190 2220,2880
bit difficult to coordinate {}

2056
00:56:48,120 --> 00:56:50,580
0,570 960,1530 1530,1860 1860,2340 2340,2460
in {} C,| because you
|因为您必须有某种方法来确定缓冲区实际上并未被使用，

2057
00:56:50,580 --> 00:56:51,480
0,120 120,210 210,450 450,690 690,900
have to have some way

2058
00:56:51,480 --> 00:56:52,590
0,90 90,570 570,750 750,1020 1020,1110
of deciding that actually the

2059
00:56:52,590 --> 00:56:53,550
0,270 270,330 330,540 540,780 780,960
buffer is actually not being

2060
00:56:53,550 --> 00:56:54,600
0,450 540,780 780,870 870,1020 1020,1050
used,| if you use a
|如果你使用垃圾收集器，没有什么需要决定的，

2061
00:56:54,600 --> 00:56:55,890
0,300 300,690 750,930 930,1200 1200,1290
garbage collector, there's nothing to

2062
00:56:55,890 --> 00:56:57,780
0,570 600,1140 1140,1380 1380,1590 1590,1890
decide,| basically both threads run
|基本上，两个线程都在缓冲区结束时运行，没有线程再指向该缓冲区，

2063
00:56:57,780 --> 00:56:59,220
0,240 240,330 330,540 540,660 660,1440
when the done of the

2064
00:56:59,250 --> 00:57:01,410
0,510 720,1500 1500,1770 1770,1860 1860,2160
buffer, no thread is pointing

2065
00:57:01,410 --> 00:57:02,400
0,90 90,240 240,540 540,900 900,990
to that buffer anymore,| the
|垃圾收集器，您知道将从线程堆栈开始跟踪

2066
00:57:02,400 --> 00:57:04,140
0,330 330,840 840,930 930,1110 1110,1740
garbage collector, you will trace

2067
00:57:04,140 --> 00:57:05,610
0,180 180,510 510,930 930,1140 1140,1470
{you,know} starting from the threads

2068
00:57:05,610 --> 00:57:07,260
0,480 720,960 960,1080 1080,1530 1530,1650
stacks| and will never you
|并且您永远不会知道也不会考虑缓冲任何线程堆栈

2069
00:57:07,260 --> 00:57:08,520
0,270 270,630 630,780 780,960 960,1260
know and will not account

2070
00:57:08,520 --> 00:57:09,540
0,450 450,630 630,720 720,810 810,1020
buffer any of the thread

2071
00:57:09,540 --> 00:57:11,310
0,330 330,450 450,750 750,1260 1260,1770
stacks| and therefore {the,garbage} collector
|因此垃圾收集器在稍后的某个时刻释放内存。

2072
00:57:11,310 --> 00:57:12,900
0,480 780,1110 1110,1200 1200,1320 1320,1590
free {the,memory} at some point

2073
00:57:12,900 --> 00:57:13,540
0,330
later.|
|

2074
00:57:13,720 --> 00:57:15,460
0,270 270,630 810,1290 1320,1440 1440,1740
And so in a garbage
因此，在垃圾收集语言中，您根本不必考虑这个问题。

2075
00:57:15,460 --> 00:57:16,540
0,240 240,480 480,660 660,960 960,1080
collected language, you don't have

2076
00:57:16,540 --> 00:57:17,380
0,90 90,240 240,420 420,540 540,840
to think about this problem

2077
00:57:17,380 --> 00:57:18,360
0,90 90,420
at all.|
|

2078
00:57:19,990 --> 00:57:21,220
0,420 540,630 630,690 690,930 930,1230
So you know one way
所以你知道有一种方法你可以试着解决这个问题，在像C这样的[]中，

2079
00:57:21,220 --> 00:57:22,330
0,120 120,360 360,480 480,630 690,1110
you could try to solve

2080
00:57:22,330 --> 00:57:24,640
0,330 360,990 990,1320 1320,1740 2070,2310
this problem, in the []

2081
00:57:24,640 --> 00:57:26,110
0,420 420,720 720,900 900,1200 1200,1470
like C,| so you maybe
|所以你可以把引用计数放在物体上，引用计数，

2082
00:57:26,110 --> 00:57:27,760
0,690 690,1020 1020,1350 1350,1560 1560,1650
put reference counts on the

2083
00:57:27,760 --> 00:57:29,050
0,510 510,780 780,1020 1020,1230 1230,1290
objects, the reference count,| of
|当然要用锁来保护，也许是一些原子操作

2084
00:57:29,050 --> 00:57:30,160
0,180 180,330 330,420 420,570 570,1110
course have to be {}

2085
00:57:30,190 --> 00:57:32,320
0,510 600,1020 1020,1410 1410,1800 1800,2130
protected by locks, perhaps were

2086
00:57:32,350 --> 00:57:34,240
0,180 180,510 510,1200 1500,1740 1740,1890
some atomic operations| and then
|然后，当引用的计数达到零时，您可以取消引用它。

2087
00:57:34,240 --> 00:57:35,050
0,240 240,330 330,540 540,600 600,810
when the {ref's -} count

2088
00:57:35,050 --> 00:57:36,820
0,330 330,780 780,1080 1080,1410 1410,1770
reaches zero, then you can

2089
00:57:37,810 --> 00:57:38,840
0,450 450,660
dereference it.|
|

2090
00:57:39,450 --> 00:57:40,580
0,540

2091
00:57:40,640 --> 00:57:41,420
0,150 150,210 210,420 420,570 570,780
And it turns out like
事实证明，引用计数中的锁实际上有点贵，

2092
00:57:41,420 --> 00:57:42,620
0,60 60,180 180,510 510,930 930,1200
you know locks in reference

2093
00:57:42,620 --> 00:57:43,970
0,210 210,240 240,420 420,750 750,1350
counts are actually slightly expensive,|
|

2094
00:57:44,000 --> 00:57:46,010
0,210 210,300 300,1050 1050,1710 1740,2010
if you wanna {} high
如果您想要高性能，您可以了解并发性，并将其扩展到内核的[]

2095
00:57:46,010 --> 00:57:48,680
0,810 810,960 960,1200 1590,2370 2370,2670
performance, you know concurrency and

2096
00:57:48,680 --> 00:57:49,550
0,240 240,360 360,420 420,480 480,870
scale up to the []

2097
00:57:49,550 --> 00:57:50,840
0,60 60,510 510,660 660,930 930,1290
of cores| and then actually
|然后实际上可能会成为一个瓶颈，

2098
00:57:50,840 --> 00:57:52,430
0,330 360,600 600,660 660,1140 1170,1590
can be a bottleneck,| then
|几周后我们会看到，我们读了一份报纸

2099
00:57:52,430 --> 00:57:53,660
0,120 120,270 270,390 390,840 840,1230
we'll see that later in

2100
00:57:53,690 --> 00:57:54,650
0,210 210,450 450,660 660,780 780,960
a couple weeks we read

2101
00:57:54,650 --> 00:57:56,180
0,60 60,420 420,600 600,1050 1140,1530
a paper| that actually talks
|实际上非常明确地谈到了这一点。

2102
00:57:56,180 --> 00:57:57,640
0,210 210,330 330,480 480,990
about this very explicitly.|
|

2103
00:57:57,890 --> 00:57:59,510
0,180 180,540 630,960 960,1170 1170,1620
And so people tend to,
所以人们倾向于，想要做高性能，获得良好的并行性，人们倾向于避免它们。

2104
00:57:59,540 --> 00:58:00,680
0,210 210,270 270,330 330,480 480,1140
want to do high performance

2105
00:58:00,680 --> 00:58:02,510
0,300 330,960 960,1110 1110,1590 1590,1830
{}, get good parallelism {},

2106
00:58:02,510 --> 00:58:03,470
0,240 240,390 390,480 480,750 750,960
people tend to avoid them.|
|

2107
00:58:04,020 --> 00:58:04,980
0,390 390,660 660,720 720,900 900,960
{} And in fact, in
事实上，在特定情况下，我们试图避免它们就像进入读取锁定，

2108
00:58:04,980 --> 00:58:07,080
0,630 930,1710 1710,1890 1890,2040 2040,2100
particular scenario, we try to

2109
00:58:07,080 --> 00:58:08,220
0,300 300,450 450,630 630,840 840,1140
avoid them is like a

2110
00:58:08,220 --> 00:58:09,510
0,210 210,390 390,900 960,1140 1140,1290
in read lock,| {} you
|您希望至少在读取过程中释放一些锁，

2111
00:58:09,510 --> 00:58:10,200
0,90 90,270 270,330 330,540 540,690
would like to make at

2112
00:58:10,200 --> 00:58:11,760
0,210 210,810 960,1230 1230,1290 1290,1560
least reading sort of lock

2113
00:58:11,760 --> 00:58:12,660
0,360 390,540 540,630 630,780 780,900
free,| so you don't have
|这样你就不用付费用了。

2114
00:58:12,660 --> 00:58:13,960
0,90 90,210 210,300 300,870
to pay the cost.|
|

2115
00:58:14,080 --> 00:58:14,920
0,210 210,330 330,390 390,660 660,840
And so, for example, here's
举个例子，这是一个代码片段，我们这样做，

2116
00:58:14,920 --> 00:58:16,360
0,120 120,360 360,780 780,1350 1350,1440
a code fragment, that we

2117
00:58:16,360 --> 00:58:17,500
0,120 120,660 660,960 960,1050 1050,1140
do that,| here we have
|这里我们有一个GET函数，基本上您可以到达队列的头部

2118
00:58:17,500 --> 00:58:19,720
0,60 60,270 270,870 1320,2040 2040,2220
a get function, basically you

2119
00:58:19,720 --> 00:58:20,890
0,300 300,390 390,630 630,810 810,1170
reach the head of a

2120
00:58:20,890 --> 00:58:23,590
0,600 900,1440 1440,1890 1890,2190 2190,2700
queue| and returns the whatever
|并返回队列前面的任何内容，

2121
00:58:23,590 --> 00:58:24,160
0,150 150,210 210,300 300,480 480,570
is at the head of

2122
00:58:24,160 --> 00:58:25,160
0,60 60,510
the queue,|
|

2123
00:58:25,310 --> 00:58:26,930
0,480 480,630 630,1170 1170,1320 1320,1620
does it basically in a
它基本上是以一种无锁的方式运行的吗，

2124
00:58:26,930 --> 00:58:28,910
0,270 270,420 420,990 990,1380 1380,1980
lock free manner,| use {atomic_load
|使用ATOM_LOAD来实际读取磁头，但是它实际上并不需要走出去，

2125
00:58:29,150 --> 00:58:30,980
0,540 720,990 990,1200 1200,1440 1440,1830
-} to actually read the

2126
00:58:31,010 --> 00:58:32,240
0,390 390,570 570,660 660,960 960,1230
head, but it doesn't actually

2127
00:58:32,240 --> 00:58:33,480
0,150 150,210 210,480 480,750
take a walk out,|
|

2128
00:58:33,510 --> 00:58:35,520
0,240 240,330 330,870 990,1560 1560,2010
then, the writer does blocks
然后，作者做了区块划分。

2129
00:58:35,520 --> 00:58:36,720
0,210 210,390 390,570 570,720 720,1200
out.| So this is like
|所以这就像是锁释放，写入器不是锁释放。

2130
00:58:37,050 --> 00:58:38,480
0,330 330,840
lock free,

2131
00:58:38,510 --> 00:58:40,310
0,90 90,480 480,900 1110,1470 1470,1800
the writers not lock free.|
|

2132
00:58:41,280 --> 00:58:42,270
0,270 270,390 390,450 450,630 660,990
And this is a very
这是Linux内核中非常常见的风格，

2133
00:58:42,270 --> 00:58:43,530
0,330 330,810 810,870 870,990 990,1260
common style in the Linux

2134
00:58:43,530 --> 00:58:44,970
0,450 450,600 600,720 720,1140 1140,1440
kernel,| and so the writer
|所以作者实际上拿到了锁，

2135
00:58:44,970 --> 00:58:46,290
0,300 300,510 510,690 690,780 780,1320
actually they takes the lock,|
|

2136
00:58:46,320 --> 00:58:47,670
0,120 120,510 750,1080 1080,1260 1260,1350
you know whatever looks at
你知道，任何看起来像头部的东西，也许就是POP功能

2137
00:58:47,670 --> 00:58:49,620
0,90 90,450 450,1020 1020,1500 1770,1950
the head, maybe {} is

2138
00:58:49,620 --> 00:58:50,970
0,120 120,390 390,900 900,1110 1110,1350
the pop function| and pops
|并从队列中弹出头部，

2139
00:58:50,970 --> 00:58:51,990
0,90 90,180 180,510 510,780 780,1020
of the head from the

2140
00:58:51,990 --> 00:58:53,850
0,510 960,1290 1290,1590 1590,1680 1680,1860
queue,| and then you know
|然后你知道原则，你可以重复使用它，

2141
00:58:53,850 --> 00:58:55,290
0,390 390,510 510,750 750,1170 1170,1440
principle, you could reuse it,|
|

2142
00:58:55,850 --> 00:58:57,340
0,210 210,360 360,990
and then unlocks,
然后解锁，你什么时候把头解开。

2143
00:58:57,370 --> 00:58:58,420
0,270 270,270 270,510 510,750 750,1050
when are you free {the,head}.|
|

2144
00:58:58,720 --> 00:59:01,440
0,300 300,810 810,1410 1440,2130
Now again in {
现在再来一次，你看，这有一点困难，

2145
00:59:02,200 --> 00:59:03,370
0,480 540,810 810,1020 1020,1140 1140,1170
-}, you see, there's a

2146
00:59:03,370 --> 00:59:04,720
0,150 150,300 300,870 900,1260 1260,1350
little bit difficult,| when do
|你什么时候才能真正释放头部，

2147
00:59:04,720 --> 00:59:05,860
0,150 150,420 420,720 720,840 840,1140
you actually free the head,|
|

2148
00:59:05,980 --> 00:59:06,970
0,240 240,570 570,690 690,900 900,990
{} because it could be
因为可能会有一些其他的并发线程，就在你做这个ATOM_STORE之前，

2149
00:59:06,970 --> 00:59:08,020
0,120 120,540 540,690 690,810 810,1050
the case that some other

2150
00:59:08,020 --> 00:59:09,460
0,390 390,630 630,780 780,1170 1170,1440
concurrent thread that just, you

2151
00:59:09,490 --> 00:59:10,810
0,300 300,840 840,990 990,1170 1170,1320
just before you did this

2152
00:59:10,810 --> 00:59:12,430
0,390 390,870 1170,1290 1290,1380 1380,1620
{atomic_store -},| you know this
|你知道吗，这个家伙真的过来了，我基本上得到了一个指向那个特定物体的指针，

2153
00:59:12,430 --> 00:59:14,110
0,270 270,540 540,720 720,1260 1260,1680
guy actually came through and

2154
00:59:14,110 --> 00:59:15,190
0,120 120,480 480,630 630,690 690,1080
I basically got a pointer

2155
00:59:15,190 --> 00:59:16,630
0,90 90,270 270,600 600,1020 1020,1440
to that particular object,| so
|所以一旦你完成了这个原子存储，

2156
00:59:16,750 --> 00:59:17,740
0,390 390,540 540,750 750,840 840,990
once you're done with this

2157
00:59:17,740 --> 00:59:19,390
0,390 390,780 870,1080 1080,1380 1380,1650
{atomic_store -},| you can't actually
|您实际上不能释放指针，因为可能有另一个线程实际上有指向它的指针，

2158
00:59:19,390 --> 00:59:21,070
0,150 150,510 510,900 900,1560 1590,1680
free the pointer, because there

2159
00:59:21,520 --> 00:59:22,600
0,180 180,300 300,570 570,810 810,1080
could be another thread actually

2160
00:59:22,600 --> 00:59:23,500
0,150 150,210 210,480 480,630 630,900
has a pointer to it,|
|

2161
00:59:23,530 --> 00:59:24,340
0,270 270,360 360,510 510,690 690,810
and if you freeze it
如果你把它冻结在这里，你实际上可能会有一个免费后使用的bug。

2162
00:59:24,340 --> 00:59:25,570
0,180 180,540 540,690 690,810 810,1230
right here, you could actually

2163
00:59:25,570 --> 00:59:26,530
0,150 150,240 240,480 480,720 720,960
have a {use-after-free - -}

2164
00:59:26,530 --> 00:59:27,200
0,330
bug.|
|

2165
00:59:27,900 --> 00:59:29,460
0,210 210,360 360,1050 1080,1230 1230,1560
And so, { -} and
所以，你们知道我们会在几节课中看到，

2166
00:59:29,460 --> 00:59:31,110
0,300 360,510 510,870 870,1140 1140,1650
so you know we'll see

2167
00:59:31,140 --> 00:59:32,490
0,300 300,480 480,540 540,780 780,1350
{} in a couple lectures,|
|

2168
00:59:33,050 --> 00:59:34,940
0,570 840,1110 1110,1380 1380,1470 1470,1890
{ -} there is currently
目前有一种非常聪明的解决方案，称为读拷贝更新(Read Copy Update，简称RCU)

2169
00:59:34,940 --> 00:59:36,020
0,30 30,270 270,570 570,930 930,1080
a very clever solution for

2170
00:59:36,020 --> 00:59:37,580
0,360 750,1080 1080,1170 1170,1380 1380,1560
this which is called read

2171
00:59:37,580 --> 00:59:39,020
0,240 240,630 630,750 750,900 900,1440
copy update or {RCU -}|
|

2172
00:59:39,320 --> 00:59:40,790
0,780 780,930 930,990 990,1320 1320,1470
amazingly what it does is
令人惊讶的是，它所做的是一种不同的内存释放，直到真正知道它是安全的。

2173
00:59:40,790 --> 00:59:42,830
0,540 540,1140 1140,1470 1470,1590 1590,2040
a differs freeing of memory

2174
00:59:42,830 --> 00:59:44,420
0,420 420,690 690,990 990,1110 1110,1590
until really knows it's safe.|
|

2175
00:59:45,050 --> 00:59:45,830
0,390 390,540 540,630 630,750 750,780
{} And it has a
它有一个非常聪明的方案来决定什么时候它是安全的，

2176
00:59:45,830 --> 00:59:46,940
0,240 240,480 480,810 810,930 930,1110
very clever scheme to actually

2177
00:59:46,940 --> 00:59:48,500
0,420 420,600 600,900 900,1050 1050,1560
decide how when it's safe,|
|

2178
00:59:48,650 --> 00:59:49,700
0,330 330,420 420,660 660,900 900,1050
but that scheme does come
但是这个计划确实有各种各样的限制

2179
00:59:49,700 --> 00:59:50,600
0,120 120,240 240,450 450,630 630,900
with all kinds of comes

2180
00:59:50,600 --> 00:59:52,400
0,150 150,870 870,1050 1050,1560 1560,1800
with restrictions| and programmers actually
|程序员实际上必须遵守一些规则，

2181
00:59:52,400 --> 00:59:53,420
0,150 150,240 240,660 660,840 840,1020
have to obey some set

2182
00:59:53,420 --> 00:59:56,240
0,90 90,720 1080,2010 2490,2640 2640,2820
of rules,| that you must
|你必须遵循他们所谓的RCU关键部分。

2183
00:59:56,240 --> 00:59:57,680
0,360 360,630 630,780 780,840 840,1440
follow for sort of RCU

2184
00:59:57,680 --> 00:59:59,180
0,330 330,750 750,870 870,1050 1050,1500
critical sections as they're called.|
|

2185
00:59:59,700 --> 01:00:00,780
0,390 390,480 480,750 750,840 840,1080
{} For example, you can't
例如，你不能只打你不能打的电话，

2186
01:00:00,780 --> 01:00:02,520
0,540 570,1050 1050,1350 1350,1500 1500,1740
call {} just you can't

2187
01:00:02,520 --> 01:00:03,600
0,390 390,600 600,870 870,990 990,1080
call,| you can't go to
|你不能在RCU的临界区或时间表上睡觉。

2188
01:00:03,600 --> 01:00:04,860
0,390 390,540 540,600 600,870 870,1260
sleep in an {RCU -}

2189
01:00:04,890 --> 01:00:06,760
0,420 420,780 780,870 870,1350
critical section or schedule.|
|

2190
01:00:06,930 --> 01:00:08,070
0,240 240,330 330,510 510,1050 1050,1140
And so turns out, you
因此，你知道，尽管Linux内核使用非常成功，

2191
01:00:08,070 --> 01:00:10,020
0,330 330,480 480,720 1320,1710 1710,1950
know, alrough the Linux kernel

2192
01:00:10,020 --> 01:00:11,610
0,390 390,780 780,1410 1410,1500 1500,1590
uses extremely successful,| you know
|您知道有一点容易出错，需要仔细的程序才能正确。

2193
01:00:11,610 --> 01:00:13,800
0,360 360,540 540,840 840,1170 1170,2190
a bit error prone and

2194
01:00:14,250 --> 01:00:15,630
0,570 570,840 840,1140 1140,1230 1230,1380
requires careful program to get

2195
01:00:15,630 --> 01:00:16,560
0,150 150,420
it right.|
|

2196
01:00:16,860 --> 01:00:18,210
0,570 840,1020 1020,1080 1080,1260 1260,1350
And in the case of
在垃圾收集器语言的情况下，就像你知道的那样，

2197
01:00:18,210 --> 01:00:19,800
0,60 60,360 360,810 810,1320 1320,1590
the garbage collector language, like

2198
01:00:19,800 --> 01:00:21,450
0,90 90,390 390,570 570,720 720,1650
{you,know} Go,| this is a
|这不是问题，因为垃圾收集器实际上会确定某个东西何时不再使用，然后才会将其释放。

2199
01:00:21,450 --> 01:00:23,460
0,270 270,720 780,1350 1350,1710 1710,2010
non issue, because the garbage

2200
01:00:23,460 --> 01:00:24,930
0,330 330,540 540,720 720,1230 1230,1470
collector will actually determine when

2201
01:00:24,930 --> 01:00:25,740
0,210 210,450 450,540 540,750 750,810
actually something is not in

2202
01:00:25,740 --> 01:00:26,910
0,210 210,630 630,750 750,900 900,1170
use anymore and then only

2203
01:00:26,910 --> 01:00:28,060
0,270 270,540
then {free,it}.|
|

2204
01:00:28,210 --> 01:00:29,200
0,150 150,270 270,390 390,660 660,990
And so there's nothing really,
所以没有什么真的，你知道对程序员没有限制，

2205
01:00:29,200 --> 01:00:30,280
0,90 90,270 270,480 480,630 630,1080
you know there's no restrictions

2206
01:00:30,280 --> 01:00:32,230
0,90 90,150 150,870 930,1560 1560,1950
on the programmer,| {} just
|刚刚由垃圾收集器处理。

2207
01:00:32,320 --> 01:00:33,340
0,300 300,600 600,720 720,930 930,1020
taken care of by the

2208
01:00:33,340 --> 01:00:34,360
0,300 300,570
garbage collector.|
|

2209
01:00:36,020 --> 01:00:36,560
0,120 120,270 270,390 390,450 450,540
So that's sort of an
所以这是一个例子，你知道，我们在某种程度上可能更定性或更明确，

2210
01:00:36,560 --> 01:00:37,760
0,480 480,720 720,840 840,990 990,1200
example of you know we're

2211
01:00:37,760 --> 01:00:38,720
0,180 180,360
sort of

2212
01:00:38,720 --> 01:00:40,760
0,480 480,630 630,1050 1080,1890 1890,2040
more may be qualitatively or

2213
01:00:40,760 --> 01:00:43,280
0,810 1140,2040 2040,2160 2160,2250 2250,2520
more explicit,| you can see
|您可以看穿垃圾收集语言的优势。

2214
01:00:43,280 --> 01:00:44,000
0,210 210,270 270,600 600,690 690,720
through the advantage of a

2215
01:00:44,000 --> 01:00:45,600
0,300 300,600 600,1110
garbage collected language.|
|

2216
01:00:45,920 --> 01:00:47,330
0,330 330,600 600,660 660,750 750,1410
Okay, terms of the CVEs
好的，你知道的关于CVE的条款我已经提到过了，

2217
01:00:47,330 --> 01:00:47,870
0,120 120,210 210,300 300,480 480,540
you know I sort of

2218
01:00:47,870 --> 01:00:49,520
0,270 270,390 390,930 1230,1470 1470,1650
mentioned this already,| {} we
|我们检查了所有的CVE并进行了人工检查，

2219
01:00:49,520 --> 01:00:50,900
0,210 210,420 420,540 540,630 630,1380
went through all the CVEs

2220
01:00:50,900 --> 01:00:53,570
0,600 930,1440 1440,1560 1560,2220 2520,2670
and inspected them manually,| and
|然后试着决定是否真的去解决这个问题。

2221
01:00:53,570 --> 01:00:54,830
0,180 180,360 360,480 480,1020 1020,1260
then try to decide whether

2222
01:00:54,830 --> 01:00:55,970
0,90 90,360 360,630 630,930 930,1140
to actually Go and fix

2223
01:00:55,970 --> 01:00:56,980
0,60 60,510
the problem.|
|

2224
01:00:56,980 --> 01:00:58,120
0,90 90,210 210,510 510,1080 1080,1140
There for 11, them we
在那里待了11个人，我们不知道他们是谁，

2225
01:00:58,120 --> 01:00:59,470
0,180 180,450 450,900 990,1110 1110,1350
couldn't figure out,| you know
|你知道，我们看了解决这个问题的补丁，

2226
01:00:59,470 --> 01:01:00,850
0,480 480,660 660,750 750,840 840,1380
we looked at the fix,

2227
01:01:00,910 --> 01:01:03,130
0,780 840,1260 1260,1440 1440,1830 1830,2220
the patch that addresses this,|
|

2228
01:01:03,130 --> 01:01:05,230
0,930 1050,1380 1380,1560 1560,1830 1830,2100
we couldn't really figure out
我们真的不知道围棋的结果会是什么

2229
01:01:05,230 --> 01:01:06,310
0,180 180,270 270,630 630,900 900,1080
what the outcome {in,Go} would

2230
01:01:06,310 --> 01:01:07,900
0,300 300,450 450,630 630,930 930,1590
like| or how would {manifest,or}
|或者我们将如何表现，或者我们将如何改变，

2231
01:01:07,900 --> 01:01:09,970
0,180 180,420 450,780 1500,1800 1830,2070
how we change,| we could
|我们可以看看如何实现它来修复，

2232
01:01:09,970 --> 01:01:10,810
0,120 120,270 270,390 390,690 690,840
see how the implement it

2233
01:01:10,810 --> 01:01:11,800
0,60 60,270 270,450 450,660 660,990
to fix,| but couldn't decide
|但不能决定它是否真的会避免这个问题。

2234
01:01:11,800 --> 01:01:12,670
0,180 180,270 270,510 510,690 690,870
whether it actually Go would

2235
01:01:12,670 --> 01:01:13,870
0,450 450,510 510,810 810,900 900,1200
avoided the problem or not.|
|

2236
01:01:14,650 --> 01:01:16,540
0,510 600,1050 1050,1110 1110,1440 1440,1890
A number of logic bugs
CVE中的多个逻辑错误

2237
01:01:16,570 --> 01:01:18,100
0,180 180,270 270,990 990,1230 1230,1530
in the CVEs| and so
|因此，很可能在C++中会出现相同的逻辑错误

2238
01:01:18,100 --> 01:01:19,450
0,510 510,960 960,1050 1050,1170 1170,1350
presumably Go you would make

2239
01:01:19,450 --> 01:01:20,500
0,60 60,330 330,630 630,930 930,1050
the same logic bugs in

2240
01:01:20,500 --> 01:01:22,240
0,360 360,570 570,660 660,960 1530,1740
C| and you know the
|你知道结果会是一样的。

2241
01:01:22,240 --> 01:01:23,350
0,330 330,480 480,570 570,690 690,1110
outcome would be the same.|
|

2242
01:01:23,880 --> 01:01:25,050
0,90 90,390 390,750 750,900 900,1170
But then there were about
但是那时大约有40个内存安全漏洞，

2243
01:01:25,050 --> 01:01:27,540
0,660 690,1050 1050,1590 1590,2070 2100,2490
forty memory safety bugs,| {use-after-free
|免费后使用、双重免费或越界使用

2244
01:01:27,540 --> 01:01:28,770
0,240 240,510 510,630 630,900 900,1230
- -} or {double-free -}

2245
01:01:28,770 --> 01:01:30,660
0,120 120,270 270,330 330,810 1200,1890
or {out-of-bounds - -}| and
|其中八个消失了，因为垃圾收集器负责处理它们

2246
01:01:30,840 --> 01:01:32,910
0,660 660,870 870,960 960,1410 1410,2070
in eight of these disappear,

2247
01:01:32,910 --> 01:01:34,230
0,270 270,360 360,600 600,840 840,1320
because the garbage collector takes

2248
01:01:34,230 --> 01:01:36,150
0,300 300,540 540,870 1350,1860 1860,1920
{care,of} them| as described in
|正如最后几张幻灯片中所描述的那样。

2249
01:01:36,150 --> 01:01:37,500
0,60 60,300 300,480 480,930
the last couple slides.|
|

2250
01:01:37,500 --> 01:01:39,300
0,210 210,360 360,780 780,1230 1230,1800
nd in 42 cases, we
在42个案例中，我们去会引起恐慌，

2251
01:01:39,360 --> 01:01:40,800
0,300 300,420 420,600 600,1020 1020,1440
Go would have generated panic,|
|

2252
01:01:40,800 --> 01:01:42,090
0,300 300,450 450,780 780,960 960,1290
because for example would Go
因为例如会超出数组界限，

2253
01:01:42,090 --> 01:01:43,440
0,540 540,600 600,690 690,930 930,1350
outside of an array bound,|
|

2254
01:01:44,090 --> 01:01:45,980
0,570 720,1200 1290,1440 1440,1650 1650,1890
{} and of course panic
当然，恐慌是不好的，你知道内核崩溃了，

2255
01:01:45,980 --> 01:01:46,910
0,90 90,240 240,570 600,750 750,930
is not good, you know

2256
01:01:46,910 --> 01:01:48,410
0,90 90,300 300,900 1080,1410 1410,1500
the kernel crashes,| but it's
|但这可能比安全漏洞更好。

2257
01:01:48,410 --> 01:01:49,550
0,300 300,540 540,660 660,720 720,1140
probably better than a security

2258
01:01:49,550 --> 01:01:50,600
0,540
exploit.|
|

2259
01:01:50,880 --> 01:01:52,260
0,330 330,690 690,930 930,1170 1170,1380
And so yeah, so 40
所以，是的，40个案例，你知道，基本上高级语言帮助了我们。

2260
01:01:52,260 --> 01:01:53,490
0,360 360,510 510,690 690,780 780,1230
cases, you {know -} basically

2261
01:01:53,490 --> 01:01:54,900
0,180 180,570 570,870 870,1140 1140,1410
the high-level language helped us.|
|

2262
01:01:59,920 --> 01:02:01,600
0,240 240,570 570,840 840,990 990,1680
Okay, so that's the quality
好的，这就是福利的质量，

2263
01:02:01,690 --> 01:02:03,640
0,120 120,540 570,1380 1410,1650 1650,1950
of the benefits,| so now
|所以现在我想谈谈高级语言[文本]的性能代价。

2264
01:02:03,640 --> 01:02:04,030
0,60 60,210 210,270 270,390 390,390
I want to talk a

2265
01:02:04,030 --> 01:02:04,780
0,240 240,390 390,690 690,750 750,750
little bit about the {}

2266
01:02:06,850 --> 01:02:09,430
0,510 510,840 840,1500 2190,2370 2370,2580
performance cost the {high-level -}

2267
01:02:09,430 --> 01:02:10,700
0,270 270,810
language [text].|
|

2268
01:02:10,820 --> 01:02:12,200
0,540 540,720 720,930 930,1050 1050,1380
Before doing that, let me
在做那之前，让我问一下是否还有其他问题。

2269
01:02:12,200 --> 01:02:13,130
0,330 330,390 390,570 570,750 750,930
ask if there's any more

2270
01:02:13,130 --> 01:02:14,260
0,630
questions.|
|

2271
01:02:20,990 --> 01:02:23,030
0,540 720,1440 1470,1830 1830,1890 1890,2040
Okay, I'm going to go
好的，我要检查一下，我不确定我们能不能全部通过六个，

2272
01:02:23,030 --> 01:02:23,990
0,210 210,450 450,540 540,690 690,960
through them, I'm not sure

2273
01:02:23,990 --> 01:02:25,400
0,870 870,1050 1050,1140 1140,1290 1290,1410
we'll make it through all

2274
01:02:25,400 --> 01:02:27,500
0,480 510,1380 1380,1590 1590,2010 2040,2100
six,| because we reserve a
|因为我们至少在最后预留了几分钟，

2275
01:02:27,500 --> 01:02:28,280
0,210 210,450 450,540 540,690 690,780
couple minutes at least at

2276
01:02:28,280 --> 01:02:28,970
0,90 90,240 240,360 360,570 570,690
the end,| it's going to
|我们将回到课程的起点，今天的问题。

2277
01:02:28,970 --> 01:02:31,040
0,120 120,390 390,810 810,1290 1680,2070
come back to the starting

2278
01:02:31,040 --> 01:02:32,150
0,210 210,270 270,360 360,690 690,1110
point of the lecture, today's

2279
01:02:32,150 --> 01:02:33,100
0,450
question.|
|

2280
01:02:35,900 --> 01:02:37,130
0,420 420,600 600,690 690,870 870,1230
{} So to set up
所以要建立在实验的基础上，

2281
01:02:37,190 --> 01:02:39,320
0,180 180,960 990,1830 1830,2010 2010,2130
{in,terms,of} experiments,| {} you know
|你知道基本的运行在原始硬件上，

2282
01:02:39,320 --> 01:02:41,750
0,360 1470,1860 1860,2040 2040,2220 2220,2430
the basic runs on raw

2283
01:02:41,750 --> 01:02:44,030
0,510 1020,1170 1170,1440 1440,1980 1980,2280
hardware,| so these experiments are
|所以这些实验是在很小的物理机器上进行的，而不是在QEMU上，

2284
01:02:44,030 --> 01:02:45,380
0,150 150,390 390,720 720,1140 1140,1350
on little physical machines, not

2285
01:02:45,380 --> 01:02:47,630
0,120 120,330 330,390 390,1020 1440,2250
on top of QEMU,| {}
|是4核、2.8 GHz英特尔处理器、16 GB RAM，但禁用了超线程，

2286
01:02:47,630 --> 01:02:48,740
0,60 60,240 240,450 450,990 990,1110
is a 4 core, {2.8Ghz

2287
01:02:48,740 --> 01:02:50,540
0,240 240,420 420,600 600,930 930,1800
- - - -} {}

2288
01:02:50,840 --> 01:02:53,360
0,390 390,1110 1110,1590 1590,2250 2310,2520
Intel processor, 16 {GB,RAM}, {}

2289
01:02:53,360 --> 01:02:54,740
0,90 90,240 240,570 570,1200 1230,1380
but {Hyperthreads -} disabled,| we
|我们使用三个应用程序，一个Web服务器、一个键/值存储和一个邮件服务器基准测试。

2290
01:02:54,740 --> 01:02:56,480
0,120 120,330 330,1080 1110,1350 1350,1740
use three applications, {a,webserver -},

2291
01:02:56,480 --> 01:02:57,800
0,90 90,270 270,570 570,1050 1140,1320
a {key/value -} store and

2292
01:02:57,800 --> 01:02:59,220
0,30 30,210 210,480 480,1050
a {mail-server -} benchmark.|
|

2293
01:02:59,220 --> 01:03:00,810
0,240 240,330 330,450 450,990 990,1590
None of these applications stress
这些应用程序都没有给内核带来强烈的压力

2294
01:03:01,200 --> 01:03:03,240
0,480 480,630 630,1020 1020,1770 1830,2040
{} the kernel intensively| and
|因此，它们运行执行系统调用，内核必须做大量工作。

2295
01:03:03,240 --> 01:03:05,400
0,120 120,570 600,1350 1380,1890 1890,2160
so they run execute system

2296
01:03:05,400 --> 01:03:07,290
0,420 420,1020 1020,1080 1080,1530 1530,1890
calls and the kernel {must

2297
01:03:07,320 --> 01:03:07,980
0,270 270,360 360,450 450,570 570,660
-} do a lot of

2298
01:03:07,980 --> 01:03:08,780
0,300
work.|
|

2299
01:03:09,050 --> 01:03:09,800
0,270 270,360 360,450 450,570 570,750
And you can see that,
您可以看到这一点，因为这些应用程序中的大部分时间都花在内核中。

2300
01:03:09,800 --> 01:03:10,850
0,360 360,660 660,720 720,810 810,1050
because most of the time

2301
01:03:10,850 --> 01:03:12,170
0,360 360,840 840,990 990,1260 1260,1320
{in,these} applications is spent in

2302
01:03:12,170 --> 01:03:13,140
0,60 60,420
the kernel.|
|

2303
01:03:15,060 --> 01:03:16,260
0,330 330,570 570,840 840,1020 1020,1200
So first question is like
所以第一个问题是，Linux是不是甚至是饼干，甚至是产品质量的“邻居”，是内核还是工业质量的内核，

2304
01:03:16,260 --> 01:03:17,340
0,210 210,510 510,810 810,990 990,1080
is Linux even or is

2305
01:03:17,340 --> 01:03:19,110
0,360 360,570 570,690 690,1170 1200,1770
Biscuit even in the [neighborhood]

2306
01:03:19,110 --> 01:03:22,320
0,300 660,1530 1590,2070 2070,2670 2700,3210
of production quality the kernel

2307
01:03:22,350 --> 01:03:25,020
0,150 150,570 570,1230 1230,1980 2310,2670
or industrial quality kernel,| and
|所以我们所做的是，我们通过饼干和Linux来比较绝对值，

2308
01:03:25,020 --> 01:03:25,740
0,90 90,300 300,390 390,630 630,720
so what we did, we

2309
01:03:25,740 --> 01:03:27,180
0,330 330,420 420,960 960,1110 1110,1440
compare the absolute through Biscuit

2310
01:03:27,180 --> 01:03:30,390
0,90 90,690 720,2220 2250,2940 2970,3210
and Linux,| for Linux, we
|对于Linux，我们使用的是4.9 Linux，现在有点过时了，

2311
01:03:30,390 --> 01:03:31,800
0,450 450,600 600,750 750,1110 1110,1410
used {4.9 - -} Linux,

2312
01:03:31,800 --> 01:03:32,370
0,150 150,300 300,390 390,510 510,570
a little bit out of

2313
01:03:32,370 --> 01:03:33,690
0,240 240,480 480,810 840,1260 1260,1320
date now,| because papers of
|因为论文当然又有几年的历史了。

2314
01:03:33,690 --> 01:03:35,070
0,240 240,660 720,930 930,1200 1200,1380
course are a couple years

2315
01:03:35,070 --> 01:03:36,140
0,180 180,510
old again.|
|

2316
01:03:36,140 --> 01:03:37,100
0,300 300,480 480,540 540,780 780,960
{} But of course when
当然，当我们使用Linux时，我们必须禁用所有功能

2317
01:03:37,100 --> 01:03:37,790
0,150 150,480 480,540 540,630 630,690
we Linux we have to

2318
01:03:37,790 --> 01:03:39,230
0,450 450,690 690,900 900,960 960,1440
disable all kinds of features|
|

2319
01:03:39,230 --> 01:03:41,720
0,390 690,1050 1050,1410 1410,1980 2310,2490
that {} Biscuit [uses] or
饼干[使用]或不提供我的意思是，

2320
01:03:41,720 --> 01:03:42,920
0,270 270,720 720,780 780,1050 1050,1200
doesn't provide I mean,| so
|所以像页表隔离，轮询，你知道各种各样的，

2321
01:03:42,920 --> 01:03:45,410
0,450 450,840 840,1560 1560,2340 2340,2490
like page-table isolation, retpoline, you

2322
01:03:45,410 --> 01:03:46,220
0,120 120,330 330,540 540,720 720,810
know all kinds of,| you
|您知道一长串的功能，这些功能实际上并不是饼干所提供的，也不是xv6所提供的

2323
01:03:46,220 --> 01:03:47,240
0,120 120,270 330,780 780,960 960,1020
know a long list of

2324
01:03:47,240 --> 01:03:48,920
0,450 450,660 690,1140 1140,1440 1440,1680
features that actually Biscuit doesn't

2325
01:03:48,920 --> 01:03:50,270
0,660 660,840 840,1050 1050,1170 1170,1350
provide nor {xv6 - -}

2326
01:03:50,270 --> 01:03:52,100
0,480 900,1110 1110,1200 1200,1620 1620,1830
provides| and we disable them
|我们禁用了他们的Linux，以使比较尽可能公平。

2327
01:03:52,100 --> 01:03:53,270
0,360 360,480 480,630 630,690 690,1170
Linux to make the comparison

2328
01:03:53,270 --> 01:03:54,640
0,150 150,300 300,420 420,960
as fair as possible.|
|

2329
01:03:54,880 --> 01:03:55,630
0,150 150,240 240,480 480,570 570,750
And of course you know
当然，你也知道有些功能很难禁用，

2330
01:03:55,630 --> 01:03:56,470
0,150 150,450 450,570 570,780 780,840
some features are hard to

2331
01:03:56,470 --> 01:03:58,450
0,870 870,990 990,1230 1410,1620 1740,1980
disable,| you know we were
|你知道我们不能致残，

2332
01:03:58,450 --> 01:04:00,100
0,240 240,420 420,870 900,1350 1470,1650
not able to disabled,| but
|但你知道我们试着尽可能靠近。

2333
01:04:00,100 --> 01:04:00,820
0,120 120,210 210,300 300,510 510,720
you know we tried to

2334
01:04:00,820 --> 01:04:02,110
0,180 180,300 300,600 600,690 690,1290
get as close as possible.|
|

2335
01:04:02,820 --> 01:04:04,440
0,270 270,810 810,990 990,1290 1290,1620
And then we measured basically
然后我们基本上测量了吞吐量。

2336
01:04:04,440 --> 01:04:05,740
0,90 90,690
the throughput.|
|

2337
01:04:05,740 --> 01:04:07,210
0,750 750,840 840,930 930,1020 1020,1470
And as you can see
如你所见，饼干几乎总是比较慢，

2338
01:04:07,210 --> 01:04:10,090
0,630 690,1320 1350,1770 1920,2250 2250,2880
the Biscuit is almost always

2339
01:04:10,120 --> 01:04:12,190
0,870 990,1290 1290,1500 1500,1800 1800,2070
slower,| {} which always slower
|它总是比Linux慢，

2340
01:04:12,190 --> 01:04:13,300
0,120 120,630
than Linux,|
|

2341
01:04:13,330 --> 01:04:15,640
0,810 1500,1770 1770,2160 2160,2250 2250,2310
{} {CMailbench -}, you know
CMailbench，你知道它会得到10%的佣金，

2342
01:04:15,640 --> 01:04:16,630
0,120 120,450 450,510 510,630 630,990
it's about to get whatever

2343
01:04:16,630 --> 01:04:18,550
0,750 750,1200 1200,1440 1440,1770 1770,1920
10%,| on {NGINX -} a
|在Nginx上再多一点，

2344
01:04:18,550 --> 01:04:19,900
0,180 180,300 300,780 900,1200 1200,1350
little bit more,| Redis is
|Redis的支持率略高于1050%。

2345
01:04:19,900 --> 01:04:21,280
0,60 60,240 240,360 360,450 450,1380
a little bit of {10,50,percent}.|
|

2346
01:04:21,820 --> 01:04:22,750
0,210 210,330 330,450 450,660 660,930
{} But you should use
但是你应该把这些数字用得很(粮盐)，对，

2347
01:04:22,750 --> 01:04:24,370
0,180 180,450 450,840 840,1140 1140,1620
these numbers very [grain salt],

2348
01:04:24,400 --> 01:04:26,170
0,300 300,750 1080,1590 1590,1680 1680,1770
right,| because, {} you know
|因为，你知道它们不一样，这不是苹果对苹果的比较，

2349
01:04:26,170 --> 01:04:28,690
0,180 180,390 390,1080 1290,2280 2280,2520
they're not identical, {} and

2350
01:04:28,690 --> 01:04:29,860
0,210 210,540 540,840 840,900 900,1170
it's not apples to apples

2351
01:04:29,860 --> 01:04:31,660
0,750 840,1350 1350,1440 1440,1650 1650,1800
comparison,| but they like to
|但他们喜欢头等菜，你知道，他们至少是大致相同的，

2352
01:04:31,660 --> 01:04:33,190
0,180 180,240 240,480 480,1140 1410,1530
sort of first order you

2353
01:04:33,190 --> 01:04:34,660
0,510 540,840 840,1200 1200,1260 1260,1470
know they're roughly the same

2354
01:04:34,660 --> 01:04:35,740
0,480 480,570 570,900 900,990 990,1080
ballpark at least,| you know
|你知道他们不是2倍、3倍、4倍或10倍的折扣

2355
01:04:35,740 --> 01:04:36,820
0,150 150,450 450,660 660,840 840,1080
they're not like {2x -}

2356
01:04:36,820 --> 01:04:37,660
0,150 150,360 360,630 630,780 780,840
{3x -} {4x -} or

2357
01:04:37,660 --> 01:04:39,040
0,270 270,450 450,840 1020,1140 1140,1380
{10x -} off| and so
|所以你知道，也许真正能够做到这一点是值得的，

2358
01:04:39,040 --> 01:04:41,470
0,120 120,570 630,1380 1440,1650 1860,2430
you know maybe it's worthwhile

2359
01:04:41,470 --> 01:04:42,580
0,120 120,540 540,810 810,1020 1020,1110
to actually be able to

2360
01:04:42,580 --> 01:04:43,860
0,240 240,870
do actually,|
|

2361
01:04:43,860 --> 01:04:44,730
0,120 120,210 210,330 330,690 690,870
you know to draw some
你知道要从中得出一些结论。

2362
01:04:44,730 --> 01:04:46,140
0,450 450,570 570,660 660,870
conclusions out of it.|
|

2363
01:04:48,680 --> 01:04:50,640
0,630 750,1440

2364
01:04:51,820 --> 01:04:52,600
0,150 150,390 390,510 510,690 690,780
So then we sort of
所以我们看了一下，

2365
01:04:52,600 --> 01:04:53,710
0,240 240,450 450,660 660,720 720,1110
looked at,| like you know
|就像你知道的，我们基本上是分析代码并尝试存储桶，你知道代码所花费的周期

2366
01:04:53,710 --> 01:04:55,120
0,270 270,510 510,870 870,1350 1350,1410
we look basically profile the

2367
01:04:55,120 --> 01:04:56,650
0,420 420,540 540,720 720,990 990,1530
code and try to bucket

2368
01:04:56,650 --> 01:04:58,450
0,90 90,210 210,540 540,1290 1440,1800
you know the cycles {}

2369
01:04:58,450 --> 01:04:59,410
0,270 270,450 450,750 750,900 900,960
that were spent by the

2370
01:04:59,410 --> 01:05:01,360
0,390 390,720 840,1500 1500,1620 1620,1950
code| and particularly we're looking
|特别是我们现在关注的是垃圾收集器中实际有哪些循环，

2371
01:05:01,360 --> 01:05:02,770
0,360 360,450 450,690 690,1020 1020,1410
at now which cycles were

2372
01:05:02,770 --> 01:05:03,970
0,300 300,360 360,420 420,720 720,1200
actually in the garbage collector,|
|

2373
01:05:03,970 --> 01:05:05,470
0,270 270,630 630,810 810,1290 1290,1500
which cycles were actually in
哪些周期实际上在序言函数调用中

2374
01:05:05,500 --> 01:05:07,570
0,120 120,690 780,1200 1200,1590 1590,2070
the prologue {} function calls|
|

2375
01:05:07,570 --> 01:05:10,240
0,210 210,1170 1170,1560 1560,2100 2400,2670
and {prologues -} in Go
围棋的开场白做了很多工作，

2376
01:05:10,240 --> 01:05:11,110
0,150 150,180 180,360 360,480 480,870
does a bunch of work,|
|

2377
01:05:11,110 --> 01:05:12,340
0,120 120,240 240,900 990,1170 1170,1230
{you,know} to ensure that the
您知道要确保堆栈足够大，所以您知道堆栈的运行情况。

2378
01:05:12,340 --> 01:05:13,540
0,330 330,420 420,660 660,1050 1050,1200
stack is large enough, {so,you,know}

2379
01:05:13,570 --> 01:05:15,100
0,420 420,540 540,630 630,1140
run of the stack.|
|

2380
01:05:15,130 --> 01:05:17,290
0,720 810,1170 1170,1470 1470,1950 1950,2160
{} Write barrier cycles, this
写屏障循环，这其实是垃圾收集器模式的时候，

2381
01:05:17,290 --> 01:05:19,780
0,150 150,630 630,990 990,1500 1950,2490
is actually {} when garbage

2382
01:05:19,780 --> 01:05:21,640
0,330 330,780 780,870 870,1020 1020,1860
collector mode,| you know the
|您知道，垃圾收集器打开写障碍，基本上跟踪不同空间之间的指针。

2383
01:05:21,790 --> 01:05:23,020
0,300 300,570 570,780 780,1050 1050,1230
garbage collector turns on write

2384
01:05:23,020 --> 01:05:25,080
0,300 300,1530
{barriers -},

2385
01:05:25,080 --> 01:05:27,270
0,330 330,690 690,1020 1020,1500 1500,2190
to basically track pointers between

2386
01:05:27,270 --> 01:05:30,390
0,600 600,900 900,1590 2040,2610 2610,3120
{} different spaces.| {} And
|而安全周期，也就是安全周期，就是在阵列边界检查上花费的周期，诸如此类的事情，没有检查点。

2387
01:05:30,390 --> 01:05:31,980
0,120 120,420 420,1080 1260,1500 1500,1590
the safety cycles, which are

2388
01:05:31,980 --> 01:05:33,600
0,330 330,690 690,1170 1200,1290 1290,1620
safety cycles are the cycles

2389
01:05:33,600 --> 01:05:36,160
0,330 330,900 1170,2160
spent on {

2390
01:05:36,550 --> 01:05:38,950
0,450 480,1230 1230,1830 1830,2220 2220,2400
-} {array,bound} checks and things

2391
01:05:38,950 --> 01:05:39,880
0,120 120,480 480,660 660,870 870,930
like that, no point of

2392
01:05:39,880 --> 01:05:40,840
0,450
checks.|
|

2393
01:05:42,500 --> 01:05:43,280
0,360 360,480 480,540 540,630 630,780
And so if you look
所以如果你看这些申请，你知道这里的数字，

2394
01:05:43,280 --> 01:05:45,410
0,60 60,390 390,1830 1830,1980 1980,2130
at these applications, you know

2395
01:05:45,410 --> 01:05:47,510
0,300 300,390 390,870 990,1710 1710,2100
here the numbers,| {} so
|因此，3%的执行时间实际上花在了GC周期上，

2396
01:05:47,600 --> 01:05:48,770
0,300 300,570 570,660 660,720 720,1170
3% of the execution time

2397
01:05:48,770 --> 01:05:49,910
0,270 270,420 420,630 630,990 990,1140
was actually spent in sort

2398
01:05:49,910 --> 01:05:51,620
0,180 180,360 360,750 750,1350 1350,1710
of GC cycles,| we and
|我们会稍微谈一谈为什么这个价格很低，

2399
01:05:51,620 --> 01:05:52,520
0,360 360,480 480,660 660,690 690,900
I'll talk a little bit

2400
01:05:52,520 --> 01:05:55,700
0,150 150,660 690,1680 1680,2190 2520,3180
about {why,that's} low,| {} but
|但您知道，在这种情况下，垃圾收集器在运行这些应用程序的同时，

2401
01:05:55,880 --> 01:05:57,410
0,660 660,780 780,900 900,1440 1440,1530
you know {in,this,case} that the

2402
01:05:57,410 --> 01:05:59,000
0,60 60,300 300,690 690,990 990,1590
garbage collector running, while running

2403
01:05:59,030 --> 01:06:00,470
0,390 390,630 630,1230 1230,1320 1320,1440
these applications,| so it's not
|所以这不是我们测量应用程序的情况，

2404
01:06:00,470 --> 01:06:01,370
0,150 150,210 210,450 450,630 630,900
the case that we measured

2405
01:06:01,400 --> 01:06:02,870
0,330 330,390 390,1050 1050,1290 1290,1470
the applications,| we give so
|我们提供了如此多的内存，您知道在运行垃圾收集器之后只需在没有内存的情况下运行，

2406
01:06:02,870 --> 01:06:03,860
0,120 120,300 300,630 630,840 840,990
much memory that you know

2407
01:06:03,860 --> 01:06:05,330
0,150 150,390 390,810 810,1110 1110,1470
just run without after running

2408
01:06:05,420 --> 01:06:06,440
0,360
{}

2409
01:06:06,660 --> 01:06:09,480
0,510 540,840 840,1380 1800,2250 2280,2820
the garbage collector,| {} surprisingly
|令人惊讶的是，实际上序曲周期是最高的，

2410
01:06:09,480 --> 01:06:10,950
0,240 240,510 510,930 930,1260 1260,1470
actually the prologue cycles turned

2411
01:06:10,950 --> 01:06:11,910
0,90 90,150 150,240 240,330 330,960
out to be the highest,|
|

2412
01:06:12,030 --> 01:06:13,260
0,390 390,480 480,660 660,750 750,1230
{} and this is basically
这基本上就是你知道的计划的方式

2413
01:06:13,260 --> 01:06:14,310
0,120 120,270 270,390 390,630 630,1050
you know the way the

2414
01:06:14,310 --> 01:06:15,660
0,330 330,480 480,930 930,1200 1200,1350
scheme| that we're using that
|我们正在使用该时间检查内核堆栈或线程堆栈是否需要增长或GO例程，

2415
01:06:15,660 --> 01:06:17,250
0,270 270,720 720,900 900,1260 1260,1590
time for a checking whether

2416
01:06:17,250 --> 01:06:18,540
0,300 480,780 780,1080 1080,1200 1200,1290
the kernel stack or the

2417
01:06:18,540 --> 01:06:19,530
0,270 270,390 390,480 480,720 720,990
stack of a thread needed

2418
01:06:19,530 --> 01:06:20,520
0,180 180,330 330,540 540,780 780,990
to or Go routine needed

2419
01:06:20,520 --> 01:06:21,390
0,60 60,180 180,450 450,510 510,870
to be grown or not,|
|

2420
01:06:21,970 --> 01:06:22,780
0,150 150,270 270,360 360,630 630,810
and this is something that
而这实际上是围棋设计中的一种[思想]，

2421
01:06:22,780 --> 01:06:24,850
0,360 360,570 570,1110 1530,2010 2010,2070
actually the Go design that

2422
01:06:24,850 --> 01:06:25,660
0,180 180,390 390,510 510,570 570,810
{} point in a [thought],|
|

2423
01:06:25,660 --> 01:06:26,710
0,120 120,360 360,660 660,960 960,1050
that it's probably easier to
它可能更容易降低，

2424
01:06:26,710 --> 01:06:28,660
0,120 120,630 1080,1500 1530,1800 1800,1950
get lower,| {} very little
|时间很短，实际上在安全循环中你知道的各种情况有2-3%。

2425
01:06:28,660 --> 01:06:30,070
0,240 240,480 480,540 540,1110 1110,1410
time, actually the various you

2426
01:06:30,070 --> 01:06:31,300
0,210 210,390 390,540 540,720 720,1230
know {2-3% - - -}

2427
01:06:31,300 --> 01:06:34,120
0,90 90,210 210,960 1350,1830 1830,2400
you know {in,the} safety cycles.|
|

2428
01:06:34,570 --> 01:06:36,340
0,480 900,1140 1140,1200 1200,1380 1380,1770
And so in some sense,
所以在某种意义上，你知道有个好消息，你不在，你知道税收并不巨大，

2429
01:06:36,340 --> 01:06:37,990
0,120 120,270 270,1050 1050,1230 1230,1650
you know there's good news,

2430
01:06:37,990 --> 01:06:39,070
0,90 90,450 450,720 750,990 990,1080
you not at, you know

2431
01:06:39,070 --> 01:06:42,280
0,420 420,540 540,1380 1410,2430 2730,3210
tax is not gigantic {},|
|

2432
01:06:42,280 --> 01:06:43,150
0,60 60,330 330,510 510,720 720,870
of course this number could
当然，这个数字可能要高得多，

2433
01:06:43,150 --> 01:06:44,530
0,90 90,300 300,810 840,1260 1260,1380
be much higher,| because this
|因为这完全取决于您知道堆的数量和大小

2434
01:06:44,530 --> 01:06:46,330
0,60 60,480 480,1140 1440,1620 1620,1800
is completely dependent on how

2435
01:06:46,330 --> 01:06:48,430
0,810 900,1380 1380,1620 1620,1980 2010,2100
many, {} how big you

2436
01:06:48,430 --> 01:06:50,050
0,150 150,540 540,990 990,1230 1230,1620
know the {heap,is}| or live
|或者活着，活着的物体的活着的数量是，

2437
01:06:50,440 --> 01:06:51,640
0,360 360,660 660,870 870,960 960,1200
the live number of, live

2438
01:06:51,640 --> 01:06:52,810
0,390 390,570 570,840 840,900 900,1170
objects is,| because the garbage
|因为垃圾收集器将不得不跟踪所有活动对象以实际确定哪些对象不是活动对象。

2439
01:06:52,810 --> 01:06:53,980
0,300 300,420 420,570 570,660 660,1170
collector will have to trace

2440
01:06:53,980 --> 01:06:55,150
0,210 210,330 330,660 660,1080 1080,1170
all the live objects to

2441
01:06:55,150 --> 01:06:56,350
0,180 180,600 600,840 840,1110 1110,1200
actually determine which objects are

2442
01:06:56,350 --> 01:06:57,240
0,240 240,510
not live.|
|

2443
01:06:57,520 --> 01:06:59,560
0,930 960,1200 1200,1650 1680,2010 2010,2040
And so if there's a
因此，如果有很多活的对象，你知道垃圾收集器将不得不跟踪更多的对象，

2444
01:06:59,560 --> 01:07:00,550
0,180 180,240 240,480 480,900 900,990
lot of live objects, you

2445
01:07:00,550 --> 01:07:01,450
0,120 120,210 210,510 510,780 780,900
know the garbage collector will

2446
01:07:01,450 --> 01:07:02,680
0,90 90,180 180,450 450,750 750,1230
have to trace more objects,|
|

2447
01:07:02,740 --> 01:07:03,790
0,210 210,330 330,480 480,900 900,1050
and so this completely sort
所以这与活物体的数量完全成线性关系。

2448
01:07:03,790 --> 01:07:05,830
0,90 90,600 600,810 810,1230 1440,2040
of linear with the number

2449
01:07:05,830 --> 01:07:07,160
0,90 90,330 330,870
of live objects.|
|

2450
01:07:07,290 --> 01:07:08,070
0,300 300,360 360,480 480,600 600,780
So we did some other
所以我们做了一些其他的实验。

2451
01:07:08,070 --> 01:07:09,380
0,720
experiments.|
|

2452
01:07:09,380 --> 01:07:10,490
0,210 210,330 330,660 660,840 840,1110
Let me zoom out a
让我稍微缩小一点，我们基本上分配了大量的实时数据，200万个虚拟节点，

2453
01:07:10,490 --> 01:07:12,110
0,210 210,480 690,990 990,1110 1110,1620
little bit, where we basically

2454
01:07:12,140 --> 01:07:13,550
0,480 480,630 630,1080 1080,1200 1200,1410
allocate a ton of live

2455
01:07:13,550 --> 01:07:15,230
0,420 750,930 930,1290 1290,1530 1530,1680
data, 2 million {} {vnodes

2456
01:07:15,230 --> 01:07:16,460
0,390 390,780 780,960 960,1110 1110,1230
-},| think about this as
|可以将其视为200万个inode

2457
01:07:16,460 --> 01:07:18,020
0,120 120,420 420,630 630,990 1380,1560
2 million {inodes -}| and
|和一个空闲的堆RAM大小

2458
01:07:18,020 --> 01:07:19,430
0,120 120,480 480,660 660,960 960,1410
a free the amount of

2459
01:07:19,760 --> 01:07:21,710
0,840 870,1230 1320,1710 1710,1770 1770,1950
{heap,RAM}| or change the amount
|或者更改垃圾收集器拥有的堆RAM的大小，您知道，对于空闲内存，

2460
01:07:21,710 --> 01:07:23,510
0,60 60,780 780,1140 1140,1500 1500,1800
of {heap,RAM} the garbage collector

2461
01:07:23,510 --> 01:07:24,680
0,420 420,510 510,660 660,990 990,1170
has, you know for free

2462
01:07:24,680 --> 01:07:26,930
0,450 660,960 960,1410 1440,2130 2130,2250
memory,| and then impact and
|然后影响，然后测量成本。

2463
01:07:26,930 --> 01:07:28,940
0,330 330,600 600,1080 1110,1650
then measure the cost.|
|

2464
01:07:29,140 --> 01:07:30,220
0,270 270,600 600,690 690,780 780,1080
So this is the table
这就是这张桌子，

2465
01:07:30,220 --> 01:07:31,720
0,450 660,870 870,990 990,1200 1200,1500
here,| we have like {640
|我们有大约640兆字节的数据

2466
01:07:31,720 --> 01:07:32,770
0,60 60,360 360,780 780,870 870,1050
- -} megabytes is like

2467
01:07:32,770 --> 01:07:35,080
0,510 840,990 990,1500 1530,2010 2010,2310
data| and there's running with
|运行时使用不同的内存大小

2468
01:07:35,080 --> 01:07:37,360
0,330 330,630 630,1290 1560,1980 1980,2280
different memory sizes| and one
|在一种大小的情况下，有320兆字节的数据，

2469
01:07:37,360 --> 01:07:39,100
0,540 540,870 870,990 990,1050 1050,1740
sizes case, there are 320

2470
01:07:39,100 --> 01:07:40,330
0,570 570,660 660,990 990,1110 1110,1230
megabytes of data,| so the
|所以活着的人和第二阶段的人的比率，

2471
01:07:40,330 --> 01:07:41,380
0,360 360,480 480,720 720,780 780,1050
ratio of live to phase

2472
01:07:41,380 --> 01:07:43,090
0,480 810,1080 1080,1350 1350,1650 1650,1710
two,| you see that in
|你可以看到，在这种情况下，GO确实很好地模仿了垃圾收集器的开销，

2473
01:07:43,090 --> 01:07:45,970
0,210 210,720 990,1830 1890,2280 2280,2880
that case {} Go does

2474
01:07:45,970 --> 01:07:47,080
0,60 60,210 210,450 450,990 990,1110
do a great imitation of

2475
01:07:47,080 --> 01:07:48,580
0,360 360,750 750,840 840,1140 1140,1500
[shears] overhead for garbage collector,|
|

2476
01:07:48,580 --> 01:07:49,870
0,330 330,540 540,810 810,1080 1080,1290
because the garbage collector needs
因为垃圾收集器需要运行很多次，

2477
01:07:49,870 --> 01:07:51,070
0,90 90,300 300,360 360,750 780,1200
to run a lot,| because
|因为它没有太多堆RAM。

2478
01:07:51,070 --> 01:07:52,150
0,60 60,270 270,450 450,630 630,1080
it doesn't have much {heap,RAM}.|
|

2479
01:07:52,900 --> 01:07:54,100
0,450 450,540 540,630 630,750 750,1200
But you know if you're
但是你知道，如果你基本上有两次空闲的记忆，

2480
01:07:54,250 --> 01:07:56,080
0,630 630,1050 1080,1320 1320,1620 1620,1830
basically if free memories about

2481
01:07:56,080 --> 01:07:57,070
0,510 510,570 570,660 660,840 840,990
twice,| you know you could
|你知道你可以买到足够的内存，这是免费内存的两倍，

2482
01:07:57,070 --> 01:07:58,450
0,180 180,480 480,870 870,1020 1020,1380
buy enough memory, that {free,memory}

2483
01:07:58,450 --> 01:07:59,440
0,420 420,480 480,570 570,870 870,990
twice you know that the

2484
01:07:59,440 --> 01:08:01,150
0,240 240,720 840,1320 1320,1410 1410,1710
live memory,| then the garbage
|那么垃圾收集开销实际上不是在9%范围内产生的。

2485
01:08:01,150 --> 01:08:02,920
0,330 330,1080 1080,1170 1170,1410 1410,1770
collection overhead is not actually

2486
01:08:02,920 --> 01:08:04,150
0,180 180,540 780,900 900,960 960,1230
that creates in the {9%

2487
01:08:04,150 --> 01:08:05,660
0,450 480,1080
-} range.|
|

2488
01:08:05,890 --> 01:08:07,060
0,390 450,840 840,930 930,1080 1080,1170
So basically to keep the
因此，基本上要将GC开销控制在10%以下，就像粗略布局[]，

2489
01:08:07,060 --> 01:08:08,560
0,420 420,870 870,1170 1170,1200 1200,1500
GC overhead, like a rough

2490
01:08:08,560 --> 01:08:11,020
0,270 270,690 720,1410 1410,1740 1740,2460
layout [], around below 10%,|
|

2491
01:08:11,140 --> 01:08:12,580
0,240 240,390 390,870 870,1050 1050,1440
you need about three times
就物理内存而言，您需要大约三倍的堆大小。

2492
01:08:12,580 --> 01:08:13,840
0,90 90,300 300,810
the heap size

2493
01:08:13,960 --> 01:08:15,370
0,660 660,840 840,1050 1050,1110 1110,1410
{} in terms of physical

2494
01:08:15,370 --> 01:08:16,240
0,300
memory.|
|

2495
01:08:19,920 --> 01:08:21,500
0,210 210,510 510,720 720,1050
Any questions about this?|
对此有什么问题吗？|

2496
01:08:23,500 --> 01:08:25,180
0,210 210,510 510,660 660,990 1020,1680
{} I had a question
我有一个关于写障碍的问题，

2497
01:08:25,180 --> 01:08:28,030
0,420 420,1080 1230,1650 1650,2340 2340,2850
about the write barriers,| what
|那些是什么，你是不是像你说的权限。

2498
01:08:28,030 --> 01:08:30,220
0,480 540,1020 1020,1110 1110,1890 1950,2190
are those, do you, is

2499
01:08:30,220 --> 01:08:32,440
0,150 150,420 420,1170 1200,1590 1590,2220
it like you said some

2500
01:08:32,500 --> 01:08:36,310
0,1290 1770,2610 2640,2970 2970,3150 3150,3810
permissions.| You know, so if
|你知道，如果你记得刚才讲课的话，那种[上诉人]论文，我们在那里谈到了[两个空间]和[来自]空间。

2501
01:08:36,310 --> 01:08:38,020
0,150 150,480 480,1230 1260,1590 1590,1710
you remember to lecture for

2502
01:08:38,020 --> 01:08:38,890
0,30 30,240 240,480 480,720 720,870
a little while ago, the

2503
01:08:38,890 --> 01:08:41,740
0,420 630,1230 1260,2370 2400,2670 2670,2850
kind [appellant] paper paper where

2504
01:08:41,740 --> 01:08:43,150
0,90 90,360 360,780 1110,1200 1200,1410
we talked about the [two

2505
01:08:43,150 --> 01:08:44,580
0,150 150,360 360,1050
and from] spaces.|
|

2506
01:08:44,700 --> 01:08:47,790
0,1170 1200,2010 2010,2310 2310,2670 2670,3090
And garbage collector runs, then
并且垃圾收集器运行，则必须检查[FROM]空间中的指针是否正确，

2507
01:08:47,820 --> 01:08:49,140
0,600 600,780 780,870 870,990 990,1320
{} you have to check

2508
01:08:49,140 --> 01:08:50,070
0,240 240,330 330,750 750,870 870,930
whether the pointers in the

2509
01:08:50,070 --> 01:08:51,270
0,240 240,660 660,870 870,1080 1080,1200
[from] space right,| because it's
|因为它在[发件人]空间里，你必须复制它。

2510
01:08:51,270 --> 01:08:51,990
0,90 90,180 180,390 390,660 660,720
in the [from] space you

2511
01:08:51,990 --> 01:08:53,300
0,120 120,210 210,540 540,780
have to copy it.|
|

2512
01:08:53,420 --> 01:08:55,340
0,420 420,690 690,1110 1110,1650 1650,1920
{} And basically that the
基本上，写屏障的人非常相似，

2513
01:08:55,340 --> 01:08:56,870
0,210 210,600 600,630 630,1050 1050,1530
write barrier are very similar,|
|

2514
01:08:57,830 --> 01:08:58,640
0,240 240,330 330,450 450,660 660,810
and it's the same sort
这是同一种类型的想法，

2515
01:08:58,640 --> 01:08:59,840
0,60 60,300 300,630 630,960 960,1200
of type idea,| where you
|你需要检查每个指针，才能看到你实际上指向的空间，实际上你需要一个垃圾收集器。

2516
01:08:59,840 --> 01:09:01,580
0,240 240,360 360,630 630,1080 1110,1740
need to check every pointer

2517
01:09:01,580 --> 01:09:02,960
0,90 90,270 270,390 390,810 810,1380
to see you actually actually

2518
01:09:02,960 --> 01:09:04,730
0,270 390,960 960,1110 1110,1590 1590,1770
{} point in space that

2519
01:09:04,730 --> 01:09:05,870
0,570 570,690 690,840 840,870 870,1140
actually you need a garbage

2520
01:09:05,870 --> 01:09:06,660
0,330
collector.|
|

2521
01:09:07,300 --> 01:09:08,470
0,240 240,420 420,540 540,690 690,1170
Okay.| That's {} write barrier.|
好吧。|那是写屏障。|

2522
01:09:11,730 --> 01:09:14,190
0,330 330,780 960,1590 1590,1800 1800,2460
Sorry, so like the free
抱歉，就像免费内存一样，

2523
01:09:14,430 --> 01:09:15,990
0,780 780,990 990,1260 1260,1470 1470,1560
memory,| what is what is
|它到底是什么？它是怎么工作的？

2524
01:09:15,990 --> 01:09:17,130
0,90 90,600 600,810 810,960 960,1140
it exactly like how does

2525
01:09:17,130 --> 01:09:18,300
0,90 90,360 360,660 720,870 870,1170
it work| that the live
|现场直播不仅仅是免费的。

2526
01:09:18,300 --> 01:09:20,070
0,150 150,330 330,570 570,1020 1440,1770
is more than free.| Oh
|是啊，是啊，好吧，你买了一些内存，

2527
01:09:20,070 --> 01:09:22,020
0,660 660,870 870,1080 1080,1410 1410,1950
yeah, yeah, okay so you

2528
01:09:22,020 --> 01:09:23,340
0,270 270,480 480,720 720,780 780,1320
buy some amount of memory,|
|

2529
01:09:23,780 --> 01:09:25,250
0,540 570,870 870,1140 1140,1230 1230,1470
and live memory is actually
而实时内存实际上是这些vnode使用的内存，

2530
01:09:25,250 --> 01:09:26,030
0,210 210,300 300,420 420,660 660,780
memory that was used by

2531
01:09:26,030 --> 01:09:27,440
0,180 180,360 360,870 1170,1290 1290,1410
these {vnodes -},| and then
|然后又有320兆字节是免费的。

2532
01:09:27,440 --> 01:09:29,030
0,90 90,240 240,540 540,1140 1140,1590
there was another 320 megabyte

2533
01:09:29,030 --> 01:09:30,280
0,150 150,360 360,720
was just free.|
|

2534
01:09:30,540 --> 01:09:32,010
0,270 270,630 630,870 870,1020 1020,1470
And so when this application
因此，当此应用程序分配更多vnode时，

2535
01:09:32,010 --> 01:09:34,020
0,420 420,960 990,1560 1560,1830 1830,2010
allocated more {vnodes -},| the
|第一个来自空闲内存，直到空闲内存已满[]，然后垃圾收集器同时运行。

2536
01:09:34,020 --> 01:09:35,010
0,300 300,480 480,630 630,750 750,990
first came out of the

2537
01:09:35,010 --> 01:09:36,090
0,180 180,600 600,870 870,960 960,1080
free memory, until the free

2538
01:09:36,090 --> 01:09:38,100
0,330 330,660 660,870 870,1500 1500,2010
memory full [] then concurrently

2539
01:09:38,100 --> 01:09:39,210
0,60 60,360 360,660 660,780 780,1110
the garbage collector is running.|
|

2540
01:09:40,350 --> 01:09:42,420
0,750 990,1590
And, {}
所以我们的运行方式是三种配置，

2541
01:09:42,420 --> 01:09:43,320
0,120 120,240 240,330 330,720 720,900
and so we're running like

2542
01:09:43,320 --> 01:09:45,120
0,150 150,810 810,990 990,1230 1230,1800
three configuration,| in one configuration,
|在一种配置中，基本上空闲内存量是活动内存的两倍，

2543
01:09:45,120 --> 01:09:45,960
0,390 390,450 450,660 660,720 720,840
basically the amount of free

2544
01:09:45,960 --> 01:09:48,780
0,330 330,990 990,1680 1710,2010 2040,2820
memory twice as the live

2545
01:09:48,780 --> 01:09:49,740
0,480
memory,|
|

2546
01:09:49,920 --> 01:09:50,700
0,300 300,390 390,540 540,690 690,780
and so that means that
这意味着垃圾收集器有很多堆RAM

2547
01:09:50,700 --> 01:09:51,540
0,60 60,330 330,540 540,780 780,840
the garbage collector has a

2548
01:09:51,540 --> 01:09:53,460
0,180 180,450 450,1080 1470,1650 1650,1920
lot of {heap,RAM}| to do
|在与应用程序一起运行的同时执行某种操作。

2549
01:09:53,460 --> 01:09:55,290
0,180 180,1110 1140,1470 1470,1680 1680,1830
{sort,of} concurrently while running with

2550
01:09:55,290 --> 01:09:56,580
0,120 120,780
the application.|
|

2551
01:09:56,730 --> 01:09:57,390
0,180 180,300 300,450 450,510 510,660
And if there's a lot
如果有很多堆RAM，在这种情况下，我们是空闲的内存，

2552
01:09:57,390 --> 01:09:59,160
0,60 60,690 840,1470 1470,1620 1620,1770
of {heap,RAM}, {} in this

2553
01:09:59,160 --> 01:10:00,330
0,210 210,330 330,480 480,810 810,1170
case, we're free memory,| then
|那么你就知道垃圾收集的管理费用并没有那么高，

2554
01:10:00,330 --> 01:10:01,170
0,90 90,210 210,300 300,570 570,840
you know the garbage collection

2555
01:10:01,170 --> 01:10:02,220
0,360 360,420 420,540 540,690 690,1050
overheads are not that high,|
|

2556
01:10:03,310 --> 01:10:05,170
0,420 480,690 690,1080 1080,1560 1560,1860
over there around 10% instead
那边是10%左右，而不是34%。

2557
01:10:05,170 --> 01:10:06,700
0,90 90,570 570,960
of {34% -}.|
|

2558
01:10:07,520 --> 01:10:08,480
0,300 300,420 420,630 630,720 720,960
Okay I see I see,
好的，我知道了，我知道了，谢谢。

2559
01:10:08,480 --> 01:10:09,890
0,240 240,600 780,1050 1050,1290 1290,1410
thank you.| Think about it
|想想看，垃圾收集器有一点[松弛]来做它的工作。

2560
01:10:09,890 --> 01:10:10,490
0,180 180,300 300,330 330,480 480,600
like there's a little bit

2561
01:10:10,490 --> 01:10:11,810
0,60 60,660 690,780 780,930 930,1320
of [slack] you know for

2562
01:10:11,810 --> 01:10:12,680
0,60 60,360 360,630 630,750 750,870
the garbage collector to do

2563
01:10:12,680 --> 01:10:13,800
0,150 150,600
its work.|
|

2564
01:10:14,460 --> 01:10:15,480
0,330 330,480 480,630 630,840 840,1020
Right, I I thought that
对，我以为一共是三百二十，那就糊涂了。

2565
01:10:15,480 --> 01:10:17,730
0,180 180,510 540,1200 1230,2130 2130,2250
it's like total 320, that

2566
01:10:17,730 --> 01:10:18,840
0,120 120,510 540,780 780,960 960,1110
was confused.| No no, the
|不，不，总数是320加640

2567
01:10:18,840 --> 01:10:20,610
0,240 240,330 330,870 870,1230 1230,1770
total is 320 plus {640

2568
01:10:20,610 --> 01:10:22,440
0,360 570,840 840,1140 1170,1530 1530,1830
-}| and my last line
|我的最后一行是640加1280。

2569
01:10:22,440 --> 01:10:24,420
0,120 120,690 690,900 900,1500
is 640 plus 1280.|
|

2570
01:10:24,650 --> 01:10:26,820
0,600 960,1230 1230,1650
Okay, thank you.|
好的谢谢。|

2571
01:10:29,930 --> 01:10:32,540
0,660 690,990 990,1230 1230,1680 1770,2610
I'm gonna skip this,| {
我就跳过这个，|实际上，让我说几句停顿的话，

2572
01:10:32,840 --> 01:10:34,910
0,690 750,1650 1680,1890 1890,2010 2010,2070
-} actually, {} let me

2573
01:10:34,910 --> 01:10:35,600
0,150 150,210 210,390 390,540 540,690
talk a little bit of

2574
01:10:35,600 --> 01:10:36,680
0,360 360,690 690,810 810,900 900,1080
{pauses -},| you know this
|您知道，GO垃圾收集器是一个并发垃圾收集器

2575
01:10:36,680 --> 01:10:37,860
0,150 150,600
is, {}

2576
01:10:37,860 --> 01:10:39,030
0,180 180,390 390,660 660,1020 1020,1170
the Go garbage collector is

2577
01:10:39,030 --> 01:10:40,560
0,120 120,450 450,690 690,1170 1170,1530
a concurrent garbage collector| and
|短暂的停顿，让世界停下来很短的一段时间，

2578
01:10:40,590 --> 01:10:42,600
0,480 480,960 1050,1470 1470,1680 1680,2010
short pauses, {} you stop

2579
01:10:42,600 --> 01:10:44,640
0,90 90,510 510,630 630,1410 1740,2040
the world for a very

2580
01:10:44,640 --> 01:10:45,810
0,180 180,450 450,540 540,870 870,1170
short period of time,| basically
|基本上是为了启用写入障碍

2581
01:10:45,810 --> 01:10:46,980
0,90 90,450 450,630 630,1050 1050,1170
to enable write barriers| and
|然后，在垃圾收集器不工作的情况下，应用程序基本上会继续运行

2582
01:10:46,980 --> 01:10:48,720
0,120 120,750 870,1080 1080,1500 1500,1740
then basically the application keep

2583
01:10:48,720 --> 01:10:50,550
0,180 180,630 930,1440 1440,1500 1500,1830
on running while the garbage

2584
01:10:50,550 --> 01:10:52,200
0,270 270,630 630,1020 1140,1530 1530,1650
collector doesn't work| and it's
|它是渐进式的，就像我们几周前讨论的那样

2585
01:10:52,200 --> 01:10:54,450
0,810 810,1650 1680,1980 1980,2040 2040,2250
incremental as like the one

2586
01:10:54,450 --> 01:10:55,440
0,270 270,360 360,720 720,780 780,990
that we discussed a couple

2587
01:10:55,440 --> 01:10:56,880
0,180 180,420 420,810 840,1170 1170,1440
weeks ago| where basically every
|基本上，每个对new的调用都会执行一些垃圾收集工作。

2588
01:10:56,880 --> 01:10:58,560
0,360 360,900 930,1440 1440,1620 1620,1680
call to new does a

2589
01:10:58,560 --> 01:10:59,580
0,180 180,270 270,360 360,660 660,1020
little bit of garbage collection

2590
01:10:59,580 --> 01:11:00,260
0,360
work.|
|

2591
01:11:00,800 --> 01:11:01,730
0,180 180,300 300,510 510,750 750,930
And so every time you
所以每次你做一点垃圾收集工作，

2592
01:11:01,730 --> 01:11:02,150
0,90 90,120 120,270 270,360 360,420
do a little bit of

2593
01:11:02,150 --> 01:11:03,470
0,240 240,510 510,870 870,1080 1080,1320
garbage collection working,| there's some
|有一些延误是有代价的，对吧。

2594
01:11:03,470 --> 01:11:05,120
0,180 180,630 660,1050 1050,1200 1200,1650
some delay that's been cost,

2595
01:11:05,120 --> 01:11:05,960
0,270
right.|
|

2596
01:11:06,110 --> 01:11:07,790
0,330 330,450 450,570 570,1170 1560,1680
And so we measured you
所以我们测量了你知道的，

2597
01:11:07,790 --> 01:11:09,980
0,120 120,630 990,1770 1770,1950 1980,2190
know the {},| it took
|它使用了一个应用程序并查看了最大停顿时间，

2598
01:11:09,980 --> 01:11:11,180
0,180 180,750 750,870 870,1080 1080,1200
one application and looked at

2599
01:11:11,180 --> 01:11:13,580
0,390 390,990 990,1350 1350,1740 1890,2400
the maximum pause time,| {}
|所以应用程序可以停止的最长时间，当然垃圾收集器需要做一些工作。

2600
01:11:13,580 --> 01:11:14,570
0,210 210,330 330,690 690,870 870,990
so the maximum time an

2601
01:11:14,570 --> 01:11:16,040
0,480 480,600 600,720 720,1350 1350,1470
application can be stopped and

2602
01:11:16,040 --> 01:11:17,150
0,90 90,240 240,360 360,840 840,1110
of course the garbage collector

2603
01:11:17,150 --> 01:11:18,050
0,180 180,270 270,390 390,570 570,900
needs to do some work.|
|

2604
01:11:19,140 --> 01:11:20,520
0,510 720,960 960,1170 1170,1320 1320,1380
And it turned out to
结果是最大单次停顿150微秒，

2605
01:11:20,520 --> 01:11:23,220
0,600 630,1080 1110,1560 1650,2160 2160,2700
be the max single pause

2606
01:11:23,250 --> 01:11:25,860
0,750 750,1050 1050,1590 1950,2370 2370,2610
150 {microseconds -},| {} that's
|这是使用TCP堆栈的Web服务器的情况

2607
01:11:25,860 --> 01:11:26,760
0,60 60,150 150,360 360,450 450,900
in the case of the

2608
01:11:26,760 --> 01:11:27,810
0,180 180,600 600,720 720,840 840,1050
{webserver -} that was using

2609
01:11:27,810 --> 01:11:29,550
0,90 90,510 510,990 990,1140 1140,1740
the TCP stack| and basically,
|基本上，TCP连接表的很大一部分需要标记，

2610
01:11:29,790 --> 01:11:31,050
0,570 570,690 690,960 960,1170 1170,1260
{} a large part of

2611
01:11:31,050 --> 01:11:32,400
0,150 150,480 480,810 810,1080 1080,1350
the TCP connection table needed

2612
01:11:32,400 --> 01:11:33,960
0,90 90,210 210,720 750,1440 1440,1560
to be marked,| before you
|在你知道继续之前，这花了115微秒。

2613
01:11:33,960 --> 01:11:35,850
0,180 180,960 1200,1500 1500,1560 1560,1890
know continuing, that took {115

2614
01:11:35,850 --> 01:11:37,280
0,240 240,540 540,1080
-} {microseconds -}.|
|

2615
01:11:37,660 --> 01:11:39,580
0,390 390,870 870,1200 1200,1590 1590,1920
{} The maximum total pause
单个nginx one http请求的最大总暂停时间是单个暂停次数的总和。

2616
01:11:39,580 --> 01:11:41,320
0,240 240,390 390,510 510,1200
time for a single

2617
01:11:41,410 --> 01:11:42,490
0,360 360,540 540,690 690,930 930,1080
{} {Nginx - -} one

2618
01:11:42,490 --> 01:11:44,650
0,630 630,1230 1440,1650 1650,1740 1740,2160
http request is the sum

2619
01:11:44,650 --> 01:11:45,940
0,180 180,240 240,660 660,840 840,1290
of the number of single

2620
01:11:45,940 --> 01:11:47,650
0,480 480,660 660,750 750,1410 1410,1710
pauses| and the maximum pause
|并且单个请求的总最大暂停时间是582微秒，

2621
01:11:47,650 --> 01:11:48,490
0,120 120,180 180,630 630,810 810,840
time in total for a

2622
01:11:48,490 --> 01:11:51,160
0,510 510,1050 1260,1530 1800,2340 2340,2670
single request was 582 {microseconds

2623
01:11:51,160 --> 01:11:53,050
0,510 750,1050 1050,1350 1350,1560 1560,1890
-},| so easily when the
|所以当请求进入机器时很容易，

2624
01:11:53,050 --> 01:11:54,430
0,390 390,540 540,720 720,810 810,1380
request comes into the machine,|
|

2625
01:11:54,490 --> 01:11:57,280
0,600 600,1140 1140,1230 1230,1650 2040,2790
{} during you know there
在您知道总共有582微秒延迟期间，执行该请求。

2626
01:11:57,280 --> 01:11:58,930
0,150 150,450 450,810 810,900 1110,1650
was total delay of 582

2627
01:11:58,930 --> 01:12:00,850
0,300 300,600 600,1260 1260,1440 1440,1920
{microseconds -} execute that request.|
|

2628
01:12:03,100 --> 01:12:05,110
0,480 480,1080 1110,1500 1500,1650 1650,2010
And {} it just happened
而且这种情况发生得非常、非常罕见，

2629
01:12:05,110 --> 01:12:06,460
0,330 330,600 600,990 1080,1230 1230,1350
very, very seldom,| you know
|你知道，只有3%的请求时间实际延迟超过100微秒。

2630
01:12:06,460 --> 01:12:07,720
0,510 510,600 600,780 780,1140 1140,1260
only you know point {3%

2631
01:12:07,720 --> 01:12:09,190
0,270 270,630 630,930 930,1200 1200,1470
-} requested times actually had

2632
01:12:09,190 --> 01:12:10,690
0,570 570,900 900,1050 1050,1410 1410,1500
a delay of more than

2633
01:12:10,690 --> 01:12:12,100
0,210 210,420 420,930
100 {microseconds -}.|
|

2634
01:12:12,380 --> 01:12:14,030
0,630 630,780 780,1170 1200,1350 1350,1650
{} And so you know
所以你知道这并不好，如果你想要像SLA一样实现

2635
01:12:14,060 --> 01:12:15,110
0,270 270,480 480,780 780,900 900,1050
that's not good, if you're

2636
01:12:15,110 --> 01:12:16,970
0,240 240,330 330,810 810,1380 1410,1860
trying to achieve like an

2637
01:12:16,970 --> 01:12:19,120
0,720 720,1620
SLA| or
|或者说，我们基本上是最长的一段时间，你知道，这段时间很小，

2638
01:12:19,120 --> 01:12:21,070
0,300 300,540 1050,1470 1470,1830 1830,1950
{} yeah we're basically the

2639
01:12:21,070 --> 01:12:22,150
0,450 450,720 720,780 780,990 990,1080
longest period of time and

2640
01:12:22,150 --> 01:12:23,740
0,330 330,1050 1080,1380 1380,1470 1470,1590
request {} takes you know

2641
01:12:23,740 --> 01:12:25,360
0,210 210,1110
it's small,|
|

2642
01:12:25,360 --> 01:12:26,830
0,480 480,690 690,810 810,990 990,1470
{} but you know the
但是你知道，你看，你知道，谷歌的论文就像尾巴一样大小，

2643
01:12:26,920 --> 01:12:27,880
0,150 150,300 300,480 480,630 630,960
you look at you know,

2644
01:12:27,910 --> 01:12:29,590
0,450 450,780 780,1050 1050,1260 1260,1680
google papers about like {tail,at}

2645
01:12:29,590 --> 01:12:31,120
0,390 390,660 660,900 900,1230 1230,1530
scale,| like how long the
|比如最长的请求需要多长时间，

2646
01:12:31,150 --> 01:12:33,280
0,360 360,510 510,840 840,1320 1560,2130
{longest -} request takes {},|
|

2647
01:12:33,280 --> 01:12:34,210
0,150 150,210 210,390 390,690 690,930
you know they're talking about
你知道他们谈论的是几十毫秒、毫秒或10毫秒的量级，

2648
01:12:34,210 --> 01:12:35,470
0,210 210,570 570,720 720,1170 1170,1260
the order of tens of

2649
01:12:35,470 --> 01:12:37,480
0,510 510,1080 1080,1110 1110,1290 1290,2010
milliseconds milliseconds or 10 milliseconds,|
|

2650
01:12:37,690 --> 01:12:40,540
0,540 540,1020 1230,2310 2310,2400 2400,2850
and so probably the programs
因此很可能这些特定的程序实际上具有最大生命周期的暂停时间为582微秒，

2651
01:12:40,540 --> 01:12:42,760
0,420 1110,1500 1500,1770 1770,2070 2070,2220
that these particular programs that

2652
01:12:42,760 --> 01:12:43,990
0,240 240,510 510,690 690,1110 1110,1230
actually have a pause with

2653
01:12:43,990 --> 01:12:45,280
0,420 420,720 720,810 810,1170 1200,1290
maximum life to pause for

2654
01:12:45,280 --> 01:12:47,050
0,210 210,480 480,630 630,1140 1170,1770
{582 - -} {} microseconds,|
|

2655
01:12:47,050 --> 01:12:48,250
0,270 270,360 360,630 630,690 690,1200
sort of within the budget.|
有点在预算之内。|

2656
01:12:48,860 --> 01:12:49,970
0,240 240,420 420,540 540,720 720,1110
You know it's not ideal,
你知道这不理想，但也不疯狂

2657
01:12:49,970 --> 01:12:51,650
0,210 210,510 510,870 870,1320 1410,1680
but it's not crazy| and
|所以基本上说，实际上，

2658
01:12:51,650 --> 01:12:53,480
0,240 270,900 900,1230 1230,1560 1560,1830
so basically says that actually

2659
01:12:53,480 --> 01:12:54,400
0,330
the,|
|

2660
01:12:55,110 --> 01:12:56,460
0,270 270,360 360,510 510,1140 1140,1350
really, what this basically says
实际上，这基本上说明围棋设计者在实际实施垃圾收集器方面做得非常好，

2661
01:12:56,460 --> 01:12:57,990
0,150 150,450 480,720 720,1440 1440,1530
that the Go designers, you

2662
01:12:57,990 --> 01:12:59,160
0,120 120,300 300,600 600,1020 1020,1170
know did actually terribly good

2663
01:12:59,160 --> 01:13:00,450
0,390 390,480 480,780 780,1170 1170,1290
job of actually implementing their

2664
01:13:00,450 --> 01:13:01,720
0,300 300,720
garbage collector,|
|

2665
01:13:02,070 --> 01:13:03,940
0,420 420,810 810,960 960,1350
or impressively good job.|
或者干得好得令人印象深刻。|

2666
01:13:04,160 --> 01:13:04,730
0,180 180,270 270,330 330,480 480,570
And this is one of
这是我们在做这个项目时注意到的一件事，

2667
01:13:04,730 --> 01:13:05,990
0,180 180,390 390,510 510,660 660,1260
those things, that we've noticed

2668
01:13:05,990 --> 01:13:07,400
0,300 300,480 480,630 630,1260 1260,1410
while doing this project,| every
|每次我们升级围棋运行时，

2669
01:13:07,400 --> 01:13:08,570
0,210 210,330 330,810 810,960 960,1170
time we upgraded the Go

2670
01:13:08,570 --> 01:13:10,310
0,630 750,990 990,1230 1230,1530 1530,1740
runtime,| {} the next round
|下一轮，它带来了更好的垃圾收集器

2671
01:13:10,310 --> 01:13:11,000
0,210 210,330 330,510 510,660 660,690
time, it came with a

2672
01:13:11,000 --> 01:13:12,200
0,210 210,540 540,870 870,960 960,1200
better garbage collector| and actually
|实际上，这些数字变得越来越好。

2673
01:13:12,200 --> 01:13:13,100
0,180 180,450 450,600 600,810 810,900
these numbers got better and

2674
01:13:13,100 --> 01:13:13,960
0,390
better.|
|

2675
01:13:15,870 --> 01:13:16,960
0,570

2676
01:13:17,910 --> 01:13:19,590
0,210 210,540 540,900 900,1290 1290,1680
Okay, one more through technical
好的，我想再过一遍技术细节，

2677
01:13:19,590 --> 01:13:21,000
0,360 360,510 510,570 570,780 780,1410
detail that I want to

2678
01:13:21,300 --> 01:13:23,730
0,270 270,750 750,1350 1620,1890 1890,2430
go over,| {} so far
|到目前为止，您知道Linux和饼干之间的第一个比较，

2679
01:13:23,760 --> 01:13:24,630
0,120 120,210 210,540 540,660 660,870
you know like the first

2680
01:13:24,630 --> 01:13:26,730
0,540 540,870 870,1260 1260,1740 1740,2100
comparison between Linux and Biscuit,|
|

2681
01:13:26,730 --> 01:13:27,570
0,120 120,270 270,360 360,600 600,840
you know it's not really
你知道这真的不公平，

2682
01:13:27,570 --> 01:13:29,790
0,360 360,600 600,960 960,1260 1260,2220
fair,| because Biscuit and {}
|因为饼干和Linux实现的未来略有不同，

2683
01:13:30,540 --> 01:13:32,490
0,480 480,930 930,1230 1230,1470 1470,1950
Linux implement slightly different futures,|
|

2684
01:13:32,760 --> 01:13:33,630
0,240 240,330 330,450 450,660 660,870
so we did one more
所以我们又做了一个实验，我们基本上尝试编写两个完全相同的内核路径，

2685
01:13:33,630 --> 01:13:35,160
0,600 600,750 750,960 960,1320 1320,1530
experiment where we basically tried

2686
01:13:35,160 --> 01:13:36,690
0,60 60,330 330,570 570,1170 1170,1530
to code up two kernel

2687
01:13:36,690 --> 01:13:40,260
0,480 720,1230 1230,1860 2040,3120 3120,3570
paths completely identical,| evolving in
|在Linux和类似的C和Go中发展

2688
01:13:40,290 --> 01:13:42,510
0,480 480,810 810,1560 1590,2070 2070,2220
Linux and in like in

2689
01:13:42,510 --> 01:13:44,250
0,390 390,600 600,1140 1260,1590 1590,1740
C and Go| and so
|因此，我们查看了代码路径，并对其进行了验证，

2690
01:13:44,250 --> 01:13:45,480
0,120 120,360 360,480 480,810
we looked at the

2691
01:13:45,480 --> 01:13:47,850
0,690 720,990 990,1560 1710,2220 2220,2370
{} code path and to

2692
01:13:47,850 --> 01:13:49,380
0,570 570,810 810,1230 1230,1350 1350,1530
verify it,| basically you know
|基本上，您知道它实现的是完全相同的东西

2693
01:13:49,380 --> 01:13:50,970
0,480 480,840 840,1230 1230,1320 1320,1590
it implements exactly the same

2694
01:13:50,970 --> 01:13:51,630
0,210 210,330 330,390 390,570 570,660
thing| and we look at
|我们看一下组装结构，你知道要真正了解它们的不同之处，

2695
01:13:51,630 --> 01:13:53,100
0,60 60,540 540,1080 1080,1170 1170,1470
the assembling structures, you know

2696
01:13:53,100 --> 01:13:54,600
0,300 300,600 600,810 810,1080 1080,1500
to really see what what

2697
01:13:54,600 --> 01:13:55,980
0,90 90,510 510,810 900,1230 1230,1380
the differences are,| there gonna
|会有一些不同，因为GO要支付安全检查，

2698
01:13:55,980 --> 01:13:57,870
0,60 60,270 270,780 780,1320 1470,1890
be some differences, because {Go,is,going}

2699
01:13:57,870 --> 01:13:59,070
0,60 60,210 210,330 330,720 720,1200
to pay the safety checks,|
|

2700
01:13:59,340 --> 01:14:01,140
0,900 900,1110 1110,1290 1290,1560 1560,1800
but just in terms of
但就基本操作而言，

2701
01:14:01,140 --> 01:14:02,910
0,600 630,1020 1020,1500 1500,1650 1650,1770
{} basic operation,| that at
|至少两个代码路径在功能方面是相同的。

2702
01:14:02,910 --> 01:14:04,200
0,210 210,390 390,600 600,930 930,1290
least two code paths are

2703
01:14:04,200 --> 01:14:05,790
0,570 570,660 660,870 870,930 930,1590
identical in terms of functionality.|
|

2704
01:14:07,380 --> 01:14:08,520
0,630 660,840 840,930 930,1050 1050,1140
And we did that for
我们对两条代码路径都这样做了，

2705
01:14:08,520 --> 01:14:10,200
0,480 480,1020 1020,1440 1440,1560 1560,1680
two code paths,| you know
|你知道这很难做到，因为辛苦的工作，

2706
01:14:10,200 --> 01:14:11,340
0,270 270,630 630,690 690,870 870,1140
it's difficult to do, because

2707
01:14:11,340 --> 01:14:13,650
0,60 60,870 870,1410 1410,1890 1920,2310
{} painstaking {} job {},|
|

2708
01:14:13,650 --> 01:14:15,150
0,180 180,330 330,450 450,810 1050,1500
we did for two, {or,[coded]}
我们做了两个人的，或者实际上是两个人的(编码)。

2709
01:14:15,150 --> 01:14:16,380
0,300 300,420 420,690
actually for two.|
|

2710
01:14:16,410 --> 01:14:17,490
0,150 150,300 300,390 390,720 720,1080
And then we compare them,|
然后我们对它们进行比较，|

2711
01:14:18,040 --> 01:14:19,690
0,570 570,720 720,900 900,1320 1320,1650
{} and so here's results
这是其中之一的结果，这是烟斗乒乓球，

2712
01:14:19,690 --> 01:14:20,500
0,120 120,330 330,420 420,660 660,810
from one of them, this

2713
01:14:20,500 --> 01:14:21,970
0,120 120,360 390,780 780,990 990,1470
is {} pipe {ping-pong -},|
|

2714
01:14:22,000 --> 01:14:22,840
0,120 120,240 240,390 390,450 450,840
you know sort of test,
你知道一种测试，你知道你的乒乓球，你在管道上字节跳动

2715
01:14:22,840 --> 01:14:23,830
0,60 60,210 210,360 360,840 840,990
you know your ping-pong, you

2716
01:14:23,830 --> 01:14:25,510
0,270 270,600 600,660 660,1140 1350,1680
byte across a pipe| and
|我们刚刚查看了通过内核的代码路径

2717
01:14:25,510 --> 01:14:26,290
0,120 120,360 360,570 570,690 690,780
we just looked at the

2718
01:14:26,290 --> 01:14:27,430
0,270 270,540 540,660 660,750 750,1140
code path through the kernel|
|

2719
01:14:27,430 --> 01:14:28,750
0,180 180,420 420,630 630,720 720,1320
to actually get a byte
从管道的一端到管道的另一端实际获取一个字节。

2720
01:14:28,750 --> 01:14:29,620
0,120 120,420 420,660 660,780 780,870
from one end to the

2721
01:14:29,620 --> 01:14:30,370
0,240 240,330 330,450 450,600 600,750
pipe to the other end

2722
01:14:30,370 --> 01:14:31,280
0,60 60,120 120,510
of the pipe.|
|

2723
01:14:31,790 --> 01:14:34,370
0,780 960,1710 1740,2340 2340,2460 2460,2580
{ - -} You know,
你知道，围棋中的短金额代码就像这个1.2k行的代码

2724
01:14:34,370 --> 01:14:35,740
0,240 240,660
short amount

2725
01:14:35,830 --> 01:14:37,390
0,450 450,780 780,1200 1200,1350 1350,1560
code in {Go,is} like this

2726
01:14:37,390 --> 01:14:38,620
0,210 210,510 510,630 630,990 990,1230
{1.2k - - -} lines

2727
01:14:38,620 --> 01:14:40,000
0,480 480,810 810,1050 1050,1200 1200,1380
code| and C it's {1.8k
|C是1.8k行代码，

2728
01:14:40,000 --> 01:14:41,680
0,240 240,510 510,1440 1440,1620 1620,1680
- - -} lines of

2729
01:14:41,680 --> 01:14:43,540
0,390 720,990 990,1110 1110,1320 1320,1860
code,| and there's no allocation,
|而且没有分配，没有GC，

2730
01:14:43,540 --> 01:14:44,710
0,150 150,600 600,720 720,960 960,1170
no GC,| so those things
|所以这些东西只是不同之处，

2731
01:14:44,710 --> 01:14:47,050
0,90 90,480 840,1350 1350,1950 2010,2340
are just a differ,| we
|我们还研究了运行时，比如在两个代码路径中花费的时间最多的地方，

2732
01:14:47,050 --> 01:14:48,610
0,210 210,510 510,870 900,1260 1260,1560
also looked at run time,

2733
01:14:48,610 --> 01:14:49,630
0,150 150,480 480,540 540,780 780,1020
like where's the most time

2734
01:14:49,630 --> 01:14:51,400
0,510 540,900 900,1110 1110,1410 1410,1770
spent, in both code paths,|
|

2735
01:14:51,400 --> 01:14:52,360
0,90 90,240 240,480
you know that,
你知道，同样的前十大指示出现了，

2736
01:14:52,560 --> 01:14:54,150
0,480 480,750 750,870 870,1380 1380,1590
same {top-10 -} instructions showed

2737
01:14:54,150 --> 01:14:55,260
0,210 210,480 480,750 780,870 870,1110
up,| so we have some
|所以我们有信心，代码路径真的更近，更近了，你可以得到，

2738
01:14:55,260 --> 01:14:56,550
0,480 480,630 630,810 810,1080 1080,1290
confidence that the code paths

2739
01:14:56,550 --> 01:14:58,530
0,360 360,600 600,1380 1530,1890 1890,1980
really are closer, closer, you

2740
01:14:58,530 --> 01:14:59,560
0,120 120,510
can get,|
|

2741
01:14:59,620 --> 01:15:01,360
0,270 270,480 480,600 600,1230
to make them similar.|
让它们变得相似。|

2742
01:15:01,390 --> 01:15:02,410
0,150 150,690 690,780 780,960 960,1020
And then we looked at
然后我们看了一下基本上每秒可以完成的操作量

2743
01:15:02,410 --> 01:15:03,700
0,420 420,510 510,750 750,810 810,1290
basically the amount of operations

2744
01:15:03,700 --> 01:15:04,570
0,60 60,150 150,270 270,390 390,870
you can do per second|
|

2745
01:15:04,630 --> 01:15:06,490
0,390 690,930 930,1020 1020,1230 1230,1860
and as you see here,
正如您在这里看到的，基本上您知道比C实现慢一点

2746
01:15:06,580 --> 01:15:08,410
0,900 900,990 990,1170 1170,1680 1680,1830
basically you know Go a

2747
01:15:08,410 --> 01:15:10,810
0,210 210,840 840,1140 1140,1560 2130,2400
little slower than the C

2748
01:15:10,810 --> 01:15:13,060
0,840 1200,1800 1800,1920 1920,2070 2070,2250
implementation| and you know the
|你知道，这个比率大约慢了1.15%。

2749
01:15:13,060 --> 01:15:14,200
0,330 330,390 390,660 660,870 870,1140
ratio is about {1.15% -

2750
01:15:14,200 --> 01:15:16,020
0,300 300,570 570,870 870,1410
- - -} slower.|
|

2751
01:15:16,260 --> 01:15:19,170
0,540 840,1500 1830,2220 2220,2550 2670,2910
And, {} that's you know
而且，你知道你看了开场白/安全检查，

2752
01:15:19,170 --> 01:15:20,520
0,120 120,300 300,420 420,810 840,1350
you look at the {prologue/safety-checks

2753
01:15:20,520 --> 01:15:21,540
0,300 300,660 660,750 750,840 840,1020
- -},| you know these
|你知道，这些都是C代码不需要执行的指令，

2754
01:15:21,540 --> 01:15:22,380
0,90 90,210 210,300 300,720 720,840
are all the instructions that

2755
01:15:22,380 --> 01:15:23,430
0,180 180,450 450,630 630,870 870,1050
C code does not have

2756
01:15:23,430 --> 01:15:24,870
0,90 90,720 840,1170 1170,1350 1350,1440
to execute,| it turned out
|结果是汇编指令多了16%

2757
01:15:24,870 --> 01:15:26,460
0,60 60,180 180,390 390,1050 1050,1590
to be {} 16% more

2758
01:15:26,640 --> 01:15:29,880
0,1590 1590,2040 2040,2670 2730,3030 3030,3240
a assembly instructions| and so
|所以这大概是有道理的。

2759
01:15:29,880 --> 01:15:31,440
0,150 150,330 330,420 420,960 1140,1560
that's sort of roughly sort

2760
01:15:31,440 --> 01:15:32,640
0,180 180,390 390,840
of makes sense.|
|

2761
01:15:32,830 --> 01:15:33,790
0,330 330,630 630,780 780,900 900,960
{} So you know the
所以你知道主要结论会更慢，

2762
01:15:33,790 --> 01:15:35,200
0,180 180,780 780,960 960,1200 1230,1410
main conclusion is gonna Go

2763
01:15:35,200 --> 01:15:37,420
0,150 150,870 1080,1470 1470,1680 1680,2220
is slower,| but pretty competitive,
|但是漂亮的好胜，你知道不是慢得离谱。

2764
01:15:37,450 --> 01:15:39,160
0,150 150,240 240,960 960,1170 1170,1710
you know not not ridiculously

2765
01:15:39,160 --> 01:15:40,080
0,450
slower.|
|

2766
01:15:40,570 --> 01:15:41,500
0,210 210,330 330,540 540,630 630,930
And that seems in line
这似乎与我们直接将Linux与饼干进行比较的早期结果是一致的。

2767
01:15:41,500 --> 01:15:42,790
0,120 120,390 390,720 720,1140 1140,1290
with the early results of

2768
01:15:42,790 --> 01:15:44,140
0,210 210,330 330,480 480,750 750,1350
where we did these Linux

2769
01:15:44,140 --> 01:15:45,610
0,180 180,390 390,540 540,990 990,1470
to {Biscuit -} comparison directly.|
|

2770
01:15:47,790 --> 01:15:49,040
0,300 300,810
Okay, so
好的，让我再放大一点，

2771
01:15:49,270 --> 01:15:50,230
0,300 300,570 570,780 780,810 810,960
let me zoom a little

2772
01:15:50,230 --> 01:15:52,000
0,120 120,690 720,1380 1410,1590 1590,1770
bit further,| {} let me
|让我跳过这个

2773
01:15:52,000 --> 01:15:53,170
0,300 300,720 750,990 990,1020 1020,1170
skip this,| because I want
|因为我想稍微谈一下，

2774
01:15:53,170 --> 01:15:53,830
0,60 60,240 240,300 300,510 510,660
to talk a little bit

2775
01:15:53,830 --> 01:15:55,540
0,540 630,1170 1170,1410 1410,1590 1590,1710
about,| {} this sort of
|我们一开始问的这类问题，

2776
01:15:55,540 --> 01:15:56,680
0,210 210,600 600,720 720,840 840,1140
the question that we asked

2777
01:15:56,680 --> 01:15:57,910
0,60 60,120 120,540 540,1050 1050,1230
in the beginning,| where should
|对于新内核，应该在哪里使用高级语言。

2778
01:15:57,910 --> 01:15:59,140
0,270 270,450 450,870 870,1110 1110,1230
one use high-level language for

2779
01:15:59,140 --> 01:16:00,240
0,30 30,180 180,600
a new kernel.|
|

2780
01:16:00,830 --> 01:16:02,960
0,390 930,1470 1500,1860 1860,1950 1950,2130
And, {} maybe you're like
也许你和我一样，在这张幻灯片里，我没有回答我对此的一些想法，

2781
01:16:02,960 --> 01:16:04,010
0,300 300,570 570,630 630,990 990,1050
me, instead of answering I

2782
01:16:04,010 --> 01:16:04,940
0,120 120,270 270,570 570,780 780,930
have some thoughts about this

2783
01:16:04,940 --> 01:16:05,840
0,150 150,240 240,420 420,810 810,900
here in this slide,| you
|你知道我们得出了一些结论

2784
01:16:05,840 --> 01:16:06,830
0,120 120,270 270,450 450,630 630,990
know there were some conclusion

2785
01:16:06,830 --> 01:16:07,640
0,90 90,240 240,540 540,690 690,810
that we draw| and you
|你知道这不是一个明确的结论，一些考虑，

2786
01:16:07,640 --> 01:16:08,390
0,90 90,210 210,390 390,450 450,750
know it's not a crisp

2787
01:16:08,390 --> 01:16:11,180
0,630 960,1200 1200,2010 2370,2580 2580,2790
conclusion, some considerations,| so maybe
|所以也许我们应该退后一步问问自己这个问题，

2788
01:16:11,180 --> 01:16:11,930
0,120 120,300 300,330 330,540 540,750
to take a step back

2789
01:16:11,930 --> 01:16:13,490
0,390 390,600 600,1110 1110,1170 1170,1560
and ask yourself the question,|
|

2790
01:16:13,490 --> 01:16:14,300
0,300
like
比如你想要什么，

2791
01:16:14,830 --> 01:16:15,940
0,210 210,330 330,420 420,570 570,1110
what would you have preferred,|
|

2792
01:16:15,940 --> 01:16:16,690
0,120 120,300 330,570 570,660 660,750
you know, would you have
你知道，你是更喜欢用C语言编写xv6和实验室，还是更喜欢使用高级语言，比如围棋。

2793
01:16:16,690 --> 01:16:17,830
0,420 420,540 540,930 930,1020 1020,1140
preferred to write you know

2794
01:16:17,830 --> 01:16:18,910
0,330 330,600 600,690 690,750 750,1080
{xv6 -} and the labs

2795
01:16:18,910 --> 01:16:20,140
0,120 120,600 600,930 930,1080 1080,1230
in C or would you

2796
01:16:20,140 --> 01:16:21,340
0,420 420,510 510,720 720,750 750,1200
prefer to use a high-level

2797
01:16:21,340 --> 01:16:23,020
0,420 420,510 510,810 810,990 1020,1680
language for example like Go.|
|

2798
01:16:23,660 --> 01:16:25,940
0,540 630,1440 1440,1710 1710,1830 1830,2280
And particularly answer this question,
特别要回答这个问题，你会避免什么样的错误

2799
01:16:25,940 --> 01:16:27,080
0,270 270,690 690,810 810,900 900,1140
what what kind of bugs

2800
01:16:27,080 --> 01:16:29,030
0,180 180,300 300,450 450,1110 1140,1950
would you have avoided| and
|也许你在这堂课中有一些时间来思考一下你有什么毛病，

2801
01:16:29,330 --> 01:16:30,890
0,630 630,840 840,990 990,1080 1080,1560
maybe you have some time

2802
01:16:30,890 --> 01:16:31,760
0,270 270,390 390,630 630,720 720,870
during this lecture to think

2803
01:16:31,760 --> 01:16:32,840
0,300 300,480 480,720 720,960 960,1080
about like what bugs you

2804
01:16:32,840 --> 01:16:34,310
0,480 930,1110 1110,1170 1170,1320 1320,1470
had,| and I would love
|我很想听你知道你的经历，

2805
01:16:34,310 --> 01:16:36,080
0,90 90,630 630,750 750,1170 1530,1770
to hear you know what

2806
01:16:36,080 --> 01:16:37,640
0,120 120,780
your experience,|
|

2807
01:16:38,160 --> 01:16:40,350
0,240 240,330 330,540 540,1110 1410,2190
how do you think {}
您认为切换到高级语言会如何改变您的体验。

2808
01:16:40,350 --> 01:16:41,310
0,450 450,540 540,600 600,720 720,960
switching to a high level

2809
01:16:41,310 --> 01:16:42,330
0,300 300,480 480,600 600,900 900,1020
language would have changed your

2810
01:16:42,330 --> 01:16:43,540
0,720
experience.|
|

2811
01:16:45,090 --> 01:16:45,960
0,330 330,450 450,540 540,720 720,870
Or if you have any
或者你是否对这个问题有任何想法。

2812
01:16:45,960 --> 01:16:47,100
0,300 300,420 420,600 600,1020 1020,1140
thoughts on this question at

2813
01:16:47,100 --> 01:16:47,980
0,360
all.|
|

2814
01:16:51,460 --> 01:16:52,440
0,60 60,450
Let me,
让我，[老板]你一会儿，

2815
01:16:53,990 --> 01:16:54,860
0,360 360,510 510,630 630,690 690,870
[boss] you for a little

2816
01:16:54,860 --> 01:16:56,090
0,150 150,300 300,360 360,660 990,1230
bit,| so you can think
|所以你可以考虑一下，或许可以加入进来。

2817
01:16:56,090 --> 01:16:57,260
0,210 210,420 420,660 660,900 900,1170
about this and maybe chime

2818
01:16:57,260 --> 01:16:58,120
0,300
in.|
|

2819
01:16:59,120 --> 01:17:00,200
0,180 180,420 420,690 690,750 750,1080
I have had a couple
我有过几次这样做的经历，

2820
01:17:00,200 --> 01:17:01,130
0,90 90,450 450,570 570,690 690,930
of times when I did,|
|

2821
01:17:01,130 --> 01:17:02,990
0,420 690,1050 1050,1500 1500,1530 1530,1860
the thing where I create
在函数中创建对象，然后返回指向该对象的指针

2822
01:17:02,990 --> 01:17:04,250
0,90 90,480 480,540 540,600 600,1260
an object in a function

2823
01:17:04,460 --> 01:17:06,530
0,270 270,420 420,1110 1500,1680 1680,2070
and then return a pointer

2824
01:17:06,530 --> 01:17:07,280
0,150 150,450 450,540 540,630 630,750
to it| and then I
|然后我用指针做一些事情

2825
01:17:07,280 --> 01:17:08,540
0,150 150,450 450,570 570,600 600,1260
do stuff with a pointer|
|

2826
01:17:08,840 --> 01:17:09,860
0,180 180,300 300,360 360,780 780,1020
and then I realized that
然后我意识到这个物体不见了。

2827
01:17:09,890 --> 01:17:11,630
0,240 240,690 690,810 810,1230 1560,1740
the object is gone.| Yeah,
|是的，所以这是一个典型的免费后使用的例子，对吧。

2828
01:17:11,630 --> 01:17:12,590
0,150 150,300 300,540 540,630 630,960
so this is a classic

2829
01:17:12,590 --> 01:17:13,970
0,360 360,450 450,810 840,1140 1140,1380
example of {sort,of} {use-after-free -

2830
01:17:13,970 --> 01:17:14,920
0,510
-}

2831
01:17:14,920 --> 01:17:16,240
0,240 240,330 330,750
{case -}, correct.|
|

2832
01:17:17,810 --> 01:17:20,180
0,1020 1200,1680 1680,1920 1920,2250 2250,2370
Yeah, the second time I
是的，第二次我比第一次更快地意识到了这一点。

2833
01:17:20,180 --> 01:17:21,170
0,330 330,450 450,780 780,900 900,990
realize it faster than the

2834
01:17:21,170 --> 01:17:22,440
0,240 240,840
first time.|
|

2835
01:17:22,440 --> 01:17:23,790
0,180 180,420 420,750 750,1050 1050,1350
Yeah, it's definitely true,| when
是的，这绝对是真的，|当你在那些虫子里看到几次的时候，

2836
01:17:23,790 --> 01:17:24,600
0,120 120,330 330,480 480,750 750,810
you see a couple of

2837
01:17:24,600 --> 01:17:25,530
0,240 240,300 300,480 480,720 720,930
times in those bugs,| here
|在这里你可以做得更好。

2838
01:17:25,530 --> 01:17:26,340
0,90 90,180 180,420 420,510 510,810
you get better at them.|
|

2839
01:17:26,990 --> 01:17:28,280
0,210 210,750
Any other
对此有任何其他想法，

2840
01:17:28,340 --> 01:17:29,600
0,390 390,480 480,840 840,960 960,1260
thoughts on this,| you know
|你知道人们有过什么样的经历。

2841
01:17:29,660 --> 01:17:30,680
0,210 210,270 270,660 660,780 780,1020
what the experience that people

2842
01:17:30,680 --> 01:17:31,940
0,240 240,660
have had.|
|

2843
01:17:33,110 --> 01:17:34,490
0,330 330,510 510,630 630,900 900,1380
Think about your worst bugs,
想一想你最坏的虫子，花了最多时间的虫子。

2844
01:17:35,590 --> 01:17:37,090
0,600 600,690 690,840 840,1080 1080,1500
bugs that took most time.|
|

2845
01:17:38,820 --> 01:17:39,900
0,240 240,420 420,630 630,720 720,1080
Would {high-level - -} language
高级语言会有帮助吗？

2846
01:17:39,900 --> 01:17:41,380
0,210 210,450 450,930
would have help.|
|

2847
01:17:43,320 --> 01:17:44,730
0,120 120,240 240,420 420,1110 1110,1410
I think it definitely like
我觉得有些虫子确实很难对付，

2848
01:17:44,760 --> 01:17:45,660
0,300 300,480 480,540 540,630 630,900
like some of the bugs

2849
01:17:45,660 --> 01:17:47,340
0,210 210,840 840,1320 1320,1440 1440,1680
were absolutely terrible to deal

2850
01:17:47,340 --> 01:17:48,480
0,300 360,660 660,750 750,840 840,1140
with,| but at the same
|但同时，就像在这个上下文中一样，我非常感谢能够使用如此低级的C语言，

2851
01:17:48,480 --> 01:17:50,220
0,420 420,780 810,1140 1140,1470 1470,1740
time like in in this

2852
01:17:50,220 --> 01:17:52,770
0,780 780,1110 1140,1530 1530,2190 2190,2550
context, I definitely appreciated having

2853
01:17:52,770 --> 01:17:53,700
0,210 210,480 480,630 630,840 840,930
to work with such a

2854
01:17:53,700 --> 01:17:55,680
0,270 270,510 510,990 990,1470 1560,1980
{low-level -} language C,| because
|因为它帮助我对操作系统内部的实际情况有了非常深刻的了解，

2855
01:17:55,680 --> 01:17:57,090
0,150 150,480 480,600 600,960 960,1410
it helped me to really

2856
01:17:57,090 --> 01:17:58,890
0,330 330,450 450,1230 1320,1530 1530,1800
gain a very, {} a

2857
01:17:58,890 --> 01:18:00,720
0,240 240,930 930,1050 1050,1410 1410,1830
deep understanding of what's actually

2858
01:18:00,720 --> 01:18:02,310
0,330 330,720 720,1110 1110,1260 1260,1590
going on inside the operating

2859
01:18:02,310 --> 01:18:03,750
0,360 360,600 630,1020 1020,1140 1140,1440
system,| like how it's working
|比如它是如何处理记忆的，

2860
01:18:03,750 --> 01:18:05,220
0,180 180,510 510,780 780,1020 1110,1470
with memory,| like it it
|喜欢它，不喜欢把所有的东西都抽象化，这绝对是一件令人耳目一新的事情

2861
01:18:05,220 --> 01:18:07,260
0,360 360,780 780,1410 1410,1740 1830,2040
it's definitely refreshing to to

2862
01:18:07,260 --> 01:18:08,610
0,330 330,780 780,1050 1050,1260 1260,1350
like not have all of

2863
01:18:08,610 --> 01:18:09,840
0,240 240,750 750,1020 1020,1140 1140,1230
that abstracted away| and to
|才能真正看到到底发生了什么。

2864
01:18:09,840 --> 01:18:11,880
0,540 540,1110 1140,1590 1590,1740 1740,2040
actually see exactly what's going

2865
01:18:11,880 --> 01:18:12,900
0,660
on.|
|

2866
01:18:15,560 --> 01:18:16,430
0,150 150,270 270,450 450,660 660,870
Yeah, it makes {a,lot,of} sense,|
是啊，这很有道理，|

2867
01:18:16,430 --> 01:18:17,640
0,210 210,720
any other,
任何其他任何人对此都有意见。

2868
01:18:17,700 --> 01:18:18,810
0,240 240,360 360,600 600,720 720,1110
any other people have opinions

2869
01:18:18,810 --> 01:18:19,740
0,90 90,360
on this.|
|

2870
01:18:20,070 --> 01:18:22,180
0,390 390,690 690,960 960,1620
{} I think also
我想我在字符串末尾或类似的地方写东西的时候也出现了很多错误，

2871
01:18:22,440 --> 01:18:24,300
0,750 870,1050 1050,1260 1260,1410 1410,1860
made a lot of bugs

2872
01:18:24,300 --> 01:18:28,040
0,180 180,810 810,810 810,1770
in which I was

2873
01:18:28,580 --> 01:18:30,830
0,990 1080,1710 1710,1890 1890,2130 2130,2250
writing after the end of

2874
01:18:30,830 --> 01:18:32,150
0,90 90,570 570,720 720,1110 1110,1320
{} string or something like

2875
01:18:32,150 --> 01:18:34,130
0,510 570,900 900,1350 1410,1620 1620,1980
that,| but then I wasn't
|但是我没有得到任何有用的反馈

2876
01:18:34,130 --> 01:18:36,500
0,420 420,930 930,1560 1560,2040 2040,2370
getting any useful feedback about

2877
01:18:36,500 --> 01:18:37,910
0,150 150,330 330,600 600,900 900,1410
it| and then very strange
|然后非常奇怪的事情发生了，我无法解释，

2878
01:18:37,910 --> 01:18:39,560
0,480 480,1050 1050,1170 1170,1260 1260,1650
things happened, that I couldn't

2879
01:18:39,560 --> 01:18:42,890
0,1050 1590,2190 2370,2580 2580,2940 2940,3330
explain,| {} so yeah, I.|
|所以，是的，我。|

2880
01:18:42,920 --> 01:18:44,480
0,930 930,1170 1170,1260 1260,1380 1380,1560
Better show up in lab
最好出现在一号实验室，

2881
01:18:44,480 --> 01:18:45,380
0,420
one,|
|

2882
01:18:46,130 --> 01:18:47,030
0,330 330,540 540,600 600,810 810,900
where there's a bunch of
那里有一堆奇怪的手术

2883
01:18:47,030 --> 01:18:48,650
0,390 390,870 870,1050 1050,1440 1440,1620
strange operations| like when you
|就像当你解析目录之类的东西的时候。

2884
01:18:48,650 --> 01:18:49,910
0,330 330,840 840,960 960,1140 1140,1260
parsing directories and things like

2885
01:18:49,910 --> 01:18:50,760
0,300
that.|
|

2886
01:18:51,410 --> 01:18:52,730
0,210 210,480 480,600 600,750 750,1320
It showed up in multiple
它出现在多个应用程序中。

2887
01:18:52,730 --> 01:18:55,730
0,270 660,2430 2460,2520 2520,2850 2850,3000
apps.| Okay, so I'm not
|好的，所以我并不惊讶。

2888
01:18:55,730 --> 01:18:57,410
0,450 840,1260 1260,1440 1440,1470 1470,1680
surprised.| Okay, that's a great
|好的，这是一个很好的例子，就像你知道，拥有真正的字符串对象是非常好的。

2889
01:18:57,410 --> 01:18:58,820
0,420 420,600 600,660 660,900 900,1410
example, like you know that

2890
01:18:59,090 --> 01:19:00,080
0,180 180,360 360,660 660,750 750,990
it's very nice to actually

2891
01:19:00,080 --> 01:19:01,760
0,180 180,360 360,630 630,1200
have real string objects.|
|

2892
01:19:03,870 --> 01:19:04,890
0,390 390,540 540,720 720,900 900,1020
Something on my end is
我想说的是

2893
01:19:04,890 --> 01:19:07,110
0,150 150,330 330,1110 1140,1710 1710,2220
that| I I found myself
|当我需要地图之类的东西时，我发现自己很缺，

2894
01:19:07,110 --> 01:19:08,610
0,360 360,720 720,810 810,1080 1080,1500
lacking whenever I needed something

2895
01:19:08,610 --> 01:19:09,960
0,180 180,270 270,780 1080,1260 1260,1350
like a map,| and I
|而我只是我，我，[退缩]，每次我需要做的循环某事，然后找到。

2896
01:19:09,960 --> 01:19:11,550
0,330 330,570 570,780 810,1320 1320,1590
just I I [cringed] every

2897
01:19:11,550 --> 01:19:12,390
0,270 270,330 330,600 600,690 690,840
time I needed to do

2898
01:19:12,390 --> 01:19:13,920
0,120 120,360 360,660 660,1140 1140,1530
{} for loop over something

2899
01:19:13,920 --> 01:19:15,160
0,90 90,240 240,720
and then find.|
|

2900
01:19:15,160 --> 01:19:16,960
0,540 540,1080 1080,1230 1230,1410 1410,1800
Yeah.| However I will say
嗯。|不过，我要说的是，就像来自高级编程背景一样，

2901
01:19:16,960 --> 01:19:18,760
0,360 360,750 750,990 990,1140 1140,1800
like coming from a high-level

2902
01:19:18,760 --> 01:19:21,100
0,600 600,1260 1740,2010 2010,2190 2190,2340
programming background,| {} this was
|这是我第一次真正接触到像C这样的东西，

2903
01:19:21,100 --> 01:19:22,660
0,150 150,540 540,810 810,1440 1440,1560
my first real exposure to

2904
01:19:22,660 --> 01:19:24,190
0,360 360,600 600,990 1050,1260 1260,1530
something like C,| so going
|所以偏离诺亚的观点，

2905
01:19:24,190 --> 01:19:25,420
0,180 180,330 330,690 690,1020 1020,1230
off of Noah's point,| it
|这在某种程度上帮助我理解了这意味着什么，我正在编写的代码实际上是在CPU上运行的

2906
01:19:25,420 --> 01:19:26,290
0,210 210,330 330,690 690,750 750,870
kind of helped me to

2907
01:19:26,290 --> 01:19:28,090
0,720 780,1170 1170,1350 1350,1470 1470,1800
understand really what it means

2908
01:19:28,090 --> 01:19:30,010
0,300 1050,1380 1380,1680 1680,1800 1800,1920
that this code that I'm

2909
01:19:30,010 --> 01:19:31,270
0,240 240,330 330,780 780,1080 1080,1260
writing is actually running on

2910
01:19:31,270 --> 01:19:32,470
0,60 60,570 570,690 690,1050 1050,1200
the CPU| and everything is
|而且一切都是从CPU的角度出发的。

2911
01:19:32,470 --> 01:19:33,430
0,210 210,300 300,780 780,870 870,960
from the perspective of the

2912
01:19:33,430 --> 01:19:35,660
0,570 930,1320 1530,1860
CPU.| {} Yep,
|是的，还有其他想法吗。

2913
01:19:36,720 --> 01:19:38,040
0,240 240,870
any other

2914
01:19:41,920 --> 01:19:42,980
0,540
thoughts.|
|

2915
01:19:46,580 --> 01:19:47,840
0,180 180,300 300,720 720,1170 1170,1260
Oh, I actually remember it
哦，其实我记得具体是，安全串拷贝和只串拷贝的区别，

2916
01:19:47,840 --> 01:19:50,630
0,180 180,930 930,1320 1350,1890 1890,2790
was specifically, the difference between

2917
01:19:50,690 --> 01:19:53,030
0,570 600,1110 1110,1590 1590,2130 2130,2340
{} safe string copy or

2918
01:19:53,030 --> 01:19:55,190
0,300 300,690 690,1560 1800,2040 2040,2160
just string copy,| one of
|其中一个是放，是用空终止符，

2919
01:19:55,190 --> 01:19:57,290
0,240 240,450 450,930 930,1590 1890,2100
them was putting, {} was

2920
01:19:57,290 --> 01:19:59,300
0,300 300,420 420,690 690,1560 1560,2010
using the null terminator,| and
|那就是。

2921
01:19:59,720 --> 01:20:00,920
0,300 300,480 480,810
that was.| Yeah,
|是啊，一个常见的C漏洞，

2922
01:20:03,310 --> 01:20:04,930
0,330 330,570 570,960 1080,1380 1380,1620
{a,common} C bug,| well so
|好吧，你知道的第一件事，谢谢你的投入，

2923
01:20:04,930 --> 01:20:05,620
0,120 120,210 210,450 450,600 600,690
you know first thing you

2924
01:20:05,620 --> 01:20:07,390
0,150 150,1020 1230,1620 1620,1710 1710,1770
know, {} thanks for the

2925
01:20:07,390 --> 01:20:08,860
0,330 480,870 870,960 960,1350 1350,1470
input,| {} of course we're
|当然，我们不会将xv6更改为GO或任何高级语言，

2926
01:20:08,860 --> 01:20:10,120
0,120 120,240 240,300 300,840 870,1260
not going to change {}

2927
01:20:10,120 --> 01:20:12,100
0,270 270,540 540,960 960,1650 1680,1980
{xv6 -} to {} Go

2928
01:20:12,100 --> 01:20:12,940
0,120 120,240 240,390 390,660 660,840
or any {high-level -} language

2929
01:20:12,940 --> 01:20:13,990
0,360 360,450 450,510 510,870 870,1050
exactly,| for the reasons that
|因为你们有很多像诺亚，阿米尔提到的原因，

2930
01:20:13,990 --> 01:20:14,860
0,150 150,420 420,600 600,810 810,870
you have a number of

2931
01:20:14,860 --> 01:20:16,270
0,360 390,660 660,990 1020,1260 1260,1410
you like {Noah - -},

2932
01:20:16,270 --> 01:20:17,960
0,210 210,720
Amir mentioned,|
|

2933
01:20:18,140 --> 01:20:19,670
0,600 630,930 930,1140 1140,1410 1410,1530
{} Go still hides too
围棋还是藏得太深了

2934
01:20:19,670 --> 01:20:21,110
0,510 540,960 960,1200 1200,1260 1260,1440
much| and they're in this
|他们在这个特殊的班级里，整个目的就是

2935
01:20:21,110 --> 01:20:22,460
0,300 300,600 600,780 780,1200 1200,1350
particular class whole purpose is|
|

2936
01:20:22,460 --> 01:20:24,350
0,240 240,450 450,540 540,1590 1590,1890
really trying to understand everything
我真的试图理解CPU和系统调用接口之间的一切

2937
01:20:24,350 --> 01:20:26,420
0,450 450,540 540,1140 1140,1380 1650,2070
between the CPU and the

2938
01:20:26,420 --> 01:20:28,430
0,270 270,450 450,1050 1140,1890 1890,2010
system call interface| {} and
|举个例子，围棋当然会隐藏线索，

2939
01:20:28,430 --> 01:20:29,600
0,150 150,570 570,720 720,1080 1080,1170
for example {} Go of

2940
01:20:29,600 --> 01:20:31,490
0,480 480,750 750,1290 1440,1800 1800,1890
course hides threads,| and you
|你知道我的意思是我们不想隐瞒，

2941
01:20:31,490 --> 01:20:32,900
0,120 120,150 150,720 900,1230 1230,1410
know I mean we don't

2942
01:20:32,900 --> 01:20:33,530
0,120 120,180 180,330 330,510 510,630
want to hide that,| we
|我们想实际向您解释线程是如何实现的

2943
01:20:33,530 --> 01:20:34,310
0,150 150,210 210,540 540,630 630,780
want to explain to you

2944
01:20:34,310 --> 01:20:35,660
0,270 270,420 420,660 660,750 750,1350
actually how threads are implemented|
|

2945
01:20:35,900 --> 01:20:38,060
0,570 570,990 1200,1620 1620,2010 2010,2160
and so, {} we would
所以，我们不想对你隐瞒这件事。

2946
01:20:38,060 --> 01:20:39,320
0,210 210,360 360,690 720,1110 1110,1260
not want to hide this

2947
01:20:39,320 --> 01:20:40,060
0,210 210,390
from you.|
|

2948
01:20:40,190 --> 01:20:41,750
0,300 300,720 720,1020 1020,1470 1470,1560
So certainly future years, you
所以可以肯定的是，未来几年，你知道xv6或类将继续使用C，

2949
01:20:41,750 --> 01:20:43,280
0,180 180,480 480,840 840,1170 1170,1530
know of {xv6 -} or

2950
01:20:43,280 --> 01:20:44,780
0,360 450,780 780,1110 1200,1410 1410,1500
{} class will keep on

2951
01:20:44,780 --> 01:20:46,610
0,240 240,660 990,1440 1440,1740 1740,1830
using C,| but if you
|但是如果你实现了一个新的内核，你的目标不是教育学生关于内核的知识，

2952
01:20:46,610 --> 01:20:47,990
0,330 330,360 360,570 570,1140 1140,1380
implement a new kernel and

2953
01:20:47,990 --> 01:20:50,030
0,840 900,1290 1290,1680 1680,1770 1770,2040
{} {goal,is} not you know

2954
01:20:50,360 --> 01:20:51,000
0,390
{}

2955
01:20:51,120 --> 01:20:53,700
0,840 840,1170 1170,1440 1440,2040 2130,2580
educating students about kernels {},|
|

2956
01:20:53,700 --> 01:20:55,200
0,450 450,750 750,900 900,1020 1020,1500
but goals are I'd like
但目标是我想说是安全的，你知道高性能内核，

2957
01:20:55,230 --> 01:20:57,090
0,90 150,600 600,1170 1170,1500 1560,1860
to say safe, {you,know} high

2958
01:20:57,090 --> 01:20:58,560
0,330 330,810 960,1170 1170,1290 1290,1470
performance kernel,| you know there's
|你知道，从这项研究中你可以得出一些结论，他们做了什么，我们做对了什么。

2959
01:20:58,560 --> 01:20:59,640
0,210 210,420 450,570 570,720 720,1080
sort of you know somethings

2960
01:20:59,640 --> 01:21:00,990
0,120 120,570 570,780 780,1110 1110,1350
you conclude from this study

2961
01:21:00,990 --> 01:21:02,010
0,150 150,570 570,750 750,870 870,1020
they've done and what we've

2962
01:21:02,010 --> 01:21:03,500
0,300 330,690 690,990
done right {}.|
|

2963
01:21:03,500 --> 01:21:05,750
0,450 450,810 990,1500 1500,1680 1680,2250
Yeah, {} memory or performance
是的，记忆力或性能确实是最重要的，

2964
01:21:05,750 --> 01:21:07,070
0,120 120,450 450,1080 1110,1230 1230,1320
is really paramount,| you know
|你知道你不能牺牲15%，那么你也许应该用C，

2965
01:21:07,070 --> 01:21:09,590
0,150 150,630 630,1140 1140,1890 2190,2520
you can't sacrifice 15%, then

2966
01:21:09,590 --> 01:21:11,000
0,90 90,330 330,690 690,1140 1230,1410
you should probably {use,C},| if
|如果您想最大限度地减少内存使用，也可以使用C语言。

2967
01:21:11,000 --> 01:21:12,230
0,240 240,420 420,480 480,930 930,1230
you want to minimize memory

2968
01:21:12,230 --> 01:21:13,790
0,450 450,600 600,990 990,1260 1260,1560
use, you probably {} use

2969
01:21:13,790 --> 01:21:14,880
0,240 240,600
C too.|
|

2970
01:21:15,180 --> 01:21:16,290
0,180 180,510 510,570 570,990 990,1110
If safety is important or
如果安全很重要或者安全很重要

2971
01:21:16,290 --> 01:21:17,520
0,390 390,450 450,840 840,930 930,1230
security is important| and probably
|也许高级语言就是我们要走的路。

2972
01:21:17,520 --> 01:21:18,300
0,60 60,390 390,630 630,690 690,780
the high-level language is the

2973
01:21:18,300 --> 01:21:19,420
0,150 150,210 210,600
way to go.|
|

2974
01:21:19,600 --> 01:21:21,100
0,420 480,870 870,960 960,1170 1170,1500
And probably in many cases
也许在许多情况下，表演仅仅是重要的，而不是绝对的至高无上的。

2975
01:21:21,100 --> 01:21:22,690
0,450 450,810 810,1170 1170,1290 1290,1590
performances merely important as opposed

2976
01:21:22,690 --> 01:21:25,150
0,150 150,1170 1170,1860 2130,2370 2370,2460
to absolute paramount| and in
|在很多情况下，我认为我使用高级语言为内核做了非常合理的事情。

2977
01:21:25,150 --> 01:21:26,200
0,210 210,450 450,510 510,750 750,1050
many case I think I

2978
01:21:26,200 --> 01:21:27,520
0,150 150,360 360,750 750,1200 1200,1320
am using high-level languages {}

2979
01:21:27,520 --> 01:21:28,660
0,450 450,720 720,900 900,990 990,1140
perfectly reasonable thing to do

2980
01:21:28,660 --> 01:21:29,580
0,120 120,480
for kernel.|
|

2981
01:21:30,220 --> 01:21:31,720
0,300 300,660 660,840 840,990 990,1500
Probably one thing I've learned,
也许我学到了一件事，也许你知道(科迪·罗宾)和我从整个项目中学到了

2982
01:21:31,720 --> 01:21:33,940
0,390 390,480 480,870 1590,1920 1920,2220
probably you know [cody Robin]

2983
01:21:33,940 --> 01:21:34,660
0,120 120,180 180,450 450,570 570,720
and I learned from this

2984
01:21:34,660 --> 01:21:36,400
0,210 210,600 600,840 840,1080 1140,1740
whole project is| like whatever
|就像任何编程语言是编程语言一样，

2985
01:21:36,460 --> 01:21:37,660
0,450 450,690 690,780 780,840 840,1200
programming language is a programming

2986
01:21:37,660 --> 01:21:38,590
0,390 390,570 570,660 660,780 780,930
language,| and you can use
|你可以用它来构建内核，你可以构建用户应用程序，

2987
01:21:38,590 --> 01:21:39,940
0,60 60,420 450,840 840,1290 1290,1350
it to build kernels, you

2988
01:21:39,940 --> 01:21:41,770
0,180 180,450 450,720 720,1440 1560,1830
can build user applications,| there's
|在某种程度上，这并不是什么真正的阻碍。

2989
01:21:41,770 --> 01:21:43,450
0,360 360,690 690,1080 1080,1440 1440,1680
not really standing anything in

2990
01:21:43,450 --> 01:21:44,530
0,240 270,630 630,720 720,810 810,1080
{} really in a way.|
|

2991
01:21:50,800 --> 01:21:52,000
0,480 480,900 930,1020 1020,1110 1110,1200
Okay, {} you know I
好的，你知道我觉得该收工了，

2992
01:21:52,000 --> 01:21:52,960
0,150 150,270 270,480 480,750 750,960
think it's time to wrap

2993
01:21:52,960 --> 01:21:54,760
0,210 210,1260 1290,1560 1560,1680 1680,1800
up,| {} you know if
|你知道如果你还有什么问题，

2994
01:21:54,760 --> 01:21:56,320
0,360 360,690 690,840 840,1050 1050,1560
you have any more questions,|
|

2995
01:21:56,320 --> 01:21:57,490
0,90 90,240 240,720 720,960 960,1170
you know free to hang
你知道，你可以自由地四处闲逛，问他们，

2996
01:21:57,490 --> 01:22:00,010
0,480 570,1530 1560,1860 1860,2130 2130,2520
around and ask them,| if
|如果你要去别的地方，

2997
01:22:00,010 --> 01:22:00,700
0,90 90,210 210,300 300,420 420,690
you have to go somewhere

2998
01:22:00,700 --> 01:22:03,250
0,450 810,1350 1620,2040 2040,2340 2340,2550
else,| {} good luck with
|祝你顺利完成mmap实验室。

2999
01:22:03,250 --> 01:22:04,900
0,420 420,540 540,900 900,1290 1290,1650
finishing the mmap lab| and
|对于那些当我们要离开校园过感恩节的人来说，

3000
01:22:04,900 --> 01:22:05,710
0,90 90,300 300,390 390,540 540,810
for those of you when

3001
01:22:05,710 --> 01:22:06,640
0,120 120,270 270,540 540,690 690,930
we have to are leaving

3002
01:22:06,640 --> 01:22:09,310
0,420 420,810 810,1470 1680,2010 2010,2670
campus for Thanksgiving,| safe travels
|一路顺风，希望感恩节过后能在周一的感恩节演讲中见到你。

3003
01:22:09,370 --> 01:22:10,930
0,510 750,1200 1200,1290 1290,1410 1410,1560
and hope to see you

3004
01:22:10,930 --> 01:22:12,970
0,480 480,990 990,1440 1470,1770 1770,2040
after Thanksgiving in Monday's lecture

3005
01:22:12,970 --> 01:22:14,040
0,180 180,660
after Thanksgiving.|
|

3006
01:22:17,650 --> 01:22:18,720
0,270 270,480
Thank you.|
谢谢。|

3007
01:22:20,250 --> 01:22:21,660
0,270 270,540 540,1050 1050,1260 1260,1410
I was curious, how did
我很好奇，你是怎么实现的，

3008
01:22:21,660 --> 01:22:23,250
0,300 300,870 870,1140 1170,1290 1290,1590
you implement it,| it said
|上面说你在做这个，就在硬件上，

3009
01:22:23,250 --> 01:22:24,510
0,120 120,240 240,510 510,810 840,1260
you are doing that, just

3010
01:22:24,510 --> 01:22:25,980
0,90 90,180 180,870 930,1200 1200,1470
on the hardware,| so like
|所以当你开始的时候，你是怎么开始的。

3011
01:22:26,010 --> 01:22:27,640
0,300 300,420 420,720 720,1080
when you start out,

3012
01:22:27,900 --> 01:22:29,100
0,240 240,330 330,450 450,690 690,1200
how do you start out.|
|

3013
01:22:30,010 --> 01:22:31,120
0,390 390,510 510,600 600,780 780,1110
{} You know there's basically
你知道基本上只有很少的填充码，

3014
01:22:31,120 --> 01:22:33,130
0,240 240,570 570,1170 1260,1470 1470,2010
little shim code,| {} that
|这样就可以安装足够的硬件，

3015
01:22:33,130 --> 01:22:34,180
0,300 300,450 450,840 840,990 990,1050
sets up enough of the

3016
01:22:34,180 --> 01:22:36,220
0,660 660,870 870,1170 1170,1590 1590,2040
hardware,| so that when Biscuit
|这样当你知道的饼干要的时候

3017
01:22:36,220 --> 01:22:37,720
0,150 150,270 270,750 750,1170 1170,1500
you know asks for,| when
|当Go运行时请求堆的内存时，我们实际上可以响应。

3018
01:22:37,720 --> 01:22:40,480
0,1470 1800,2040 2040,2370 2370,2640 2640,2760
the Go runtime ask for

3019
01:22:40,480 --> 01:22:41,500
0,330 330,450 450,540 540,840 840,1020
memory for the heap, that

3020
01:22:41,500 --> 01:22:43,400
0,60 60,180 180,690 690,1440
we can actually respond.|
|

3021
01:22:44,240 --> 01:22:45,530
0,150 150,810 840,1050 1050,1200 1200,1290
{} That was one of
这是Go Runtime实际上所依赖的主要内容之一。

3022
01:22:45,530 --> 01:22:46,740
0,60 60,720
the main

3023
01:22:47,000 --> 01:22:48,980
0,450 450,690 690,1170 1170,1710 1710,1980
things that actually {} Go

3024
01:22:48,980 --> 01:22:50,820
0,420 420,660 660,1020 1020,1290
runtime actually relies on.|
|

3025
01:22:51,460 --> 01:22:52,450
0,450 450,570 570,780 780,840 840,990
Right, I guess I was
是的，我想我就像你说的那样，你没有使用虚拟机，所以。

3026
01:22:52,450 --> 01:22:53,710
0,270 270,390 390,600 600,750 750,1260
like you said that you

3027
01:22:53,800 --> 01:22:56,440
0,690 720,1380 1380,1590 1590,2130 2130,2640
didn't use a virtual machine

3028
01:22:56,440 --> 01:22:57,970
0,150 150,570 600,1050 1050,1320 1320,1530
for that, so.| We did,
|我们做了，当然我们在QEMU上开发了大部分开发

3029
01:22:57,970 --> 01:22:59,680
0,120 120,450 450,720 720,1320 1350,1710
of course we developed most

3030
01:22:59,680 --> 01:23:00,820
0,60 60,540 540,630 630,900 900,1140
of development on {QEMU -

3031
01:23:02,710 --> 01:23:04,150
0,120 120,420 810,930 930,1140 1140,1440
-}| and of course again
|当然，我们还必须让它在硬件上运行，

3032
01:23:04,150 --> 01:23:05,020
0,120 120,510 510,630 630,720 720,870
we actually have to get

3033
01:23:05,020 --> 01:23:06,280
0,180 180,390 390,480 480,570 570,1260
it running on the hardware,|
|

3034
01:23:06,370 --> 01:23:07,330
0,270 270,510 510,780 780,900 900,960
that also costs there's a
这也要付出代价有一堆问题，

3035
01:23:07,330 --> 01:23:08,470
0,180 180,240 240,810 810,1080 1080,1140
bunch of problems,| because the
|因为引导加载程序不同，所以您实际上需要编写一系列引导代码，

3036
01:23:08,470 --> 01:23:09,820
0,180 180,480 480,540 540,1110 1110,1350
boot loaders are different there's

3037
01:23:09,820 --> 01:23:10,420
0,30 30,180 180,240 240,390 390,600
a bunch of boot code

3038
01:23:10,420 --> 01:23:11,050
0,90 90,180 180,390 390,540 540,630
that you actually need to

3039
01:23:11,050 --> 01:23:11,890
0,330 330,450 450,600 600,720 720,840
write,| you don't have to
|如果你在QEMU上运行就不用写了，诸如此类的东西，

3040
01:23:11,890 --> 01:23:12,580
0,210 210,300 300,420 420,570 570,690
write if you run it

3041
01:23:12,580 --> 01:23:13,600
0,90 90,630
on QEMU,

3042
01:23:13,600 --> 01:23:14,980
0,960 960,1080 1080,1200 1200,1320 1320,1380
{} and that kind of

3043
01:23:14,980 --> 01:23:16,390
0,240 240,480 660,1260 1260,1350 1350,1410
stuff,| but most of the
|但是大部分的开发都是在QEMU上完成的，

3044
01:23:16,390 --> 01:23:17,290
0,450 450,510 510,630 630,810 810,900
development is all done on

3045
01:23:17,290 --> 01:23:18,640
0,390 390,450 450,780 930,1260 1260,1350
QEMU,| in fact if you
|事实上，如果您想实际展示在QEMU上运行饼干

3046
01:23:18,640 --> 01:23:19,600
0,150 150,240 240,420 420,810 810,960
want to actually show you

3047
01:23:19,600 --> 01:23:21,850
0,420 420,720 720,1440 1440,1860 2040,2250
running Biscuit on QEMU| and
|而且对于xv6来说，它看起来非常简单。

3048
01:23:21,850 --> 01:23:22,720
0,120 120,300 300,540 540,750 750,870
it looks very simple to

3049
01:23:22,720 --> 01:23:23,680
0,210 210,540 540,630 630,810 840,960
{xv6 -}| you know the
|你知道它唯一喜欢的就是显示提示符，没有窗口系统，什么都没有。

3050
01:23:23,680 --> 01:23:24,610
0,150 150,270 270,330 330,600 600,930
only thing it does like

3051
01:23:24,640 --> 01:23:26,080
0,330 330,870 870,990 990,1140 1140,1440
show prompt, there's no window

3052
01:23:26,080 --> 01:23:28,600
0,540 1110,1560 1560,1740 1740,2040
system, nothing like that.|
|

3053
01:23:29,800 --> 01:23:31,330
0,360 360,510 510,960 1200,1410 1410,1530
Okay I see,| so like
好的，我明白了，|例如，如果您在引导代码中犯了错误，会发生什么情况。

3054
01:23:31,330 --> 01:23:32,560
0,150 150,600 600,720 720,1080 1080,1230
what happens if you if

3055
01:23:32,560 --> 01:23:33,430
0,120 120,300 300,360 360,750 750,870
you make a mistake in

3056
01:23:33,430 --> 01:23:35,200
0,270 360,720 720,1290
the boot code.|
|

3057
01:23:35,660 --> 01:23:36,860
0,270 270,450 450,840 870,1050 1050,1200
It doesn't boot,| you know
它不能启动，|你知道基本上什么都没发生，你知道这完全没什么。

3058
01:23:36,860 --> 01:23:38,390
0,300 300,570 570,1050 1050,1230 1230,1530
basically nothing happens, you know

3059
01:23:38,450 --> 01:23:41,210
0,330 330,780 780,1170 1920,2340 2340,2760
it's completely nothing.| How do
|你怎么知道。

3060
01:23:41,210 --> 01:23:42,280
0,120 120,510
you know.|
|

3061
01:23:42,460 --> 01:23:44,650
0,360 360,960 960,1500 1830,2040 2040,2190
{} You, you, you will
你，你，你会知道的，因为你知道会发生什么，因为你看不到打印的报表，

3062
01:23:44,650 --> 01:23:46,750
0,270 270,840 840,930 930,1770 1770,2100
know, because you know okay

3063
01:23:46,870 --> 01:23:48,040
0,420 420,540 540,780 780,900 900,1170
what will happen is because

3064
01:23:48,040 --> 01:23:49,060
0,120 120,270 270,450 450,660 660,1020
you don't see print statement,|
|

3065
01:23:49,060 --> 01:23:50,080
0,180 180,480 480,780 780,930 930,1020
like {xv6 -} for the
比如xv6，我们打印的第一件事就是，你知道xv6 hello之类的，或者xv6引导，

3066
01:23:50,080 --> 01:23:51,160
0,240 240,390 390,750 750,990 990,1080
first thing we print is

3067
01:23:51,160 --> 01:23:52,660
0,270 270,510 510,840 840,1110 1110,1500
like {you,know} {xv6 -} hello

3068
01:23:52,660 --> 01:23:54,340
0,90 90,450 450,870 1080,1380 1380,1680
or something or {xv6 -}

3069
01:23:54,340 --> 01:23:55,990
0,480 840,1200 1200,1350 1350,1500 1500,1650
booting,| {} you won't see
|你不会看到这样的东西，所以你什么也看不到，

3070
01:23:55,990 --> 01:23:58,240
0,330 330,510 510,810 1260,1860 1860,2250
anything like that, and so

3071
01:23:58,240 --> 01:24:00,340
0,180 180,300 300,690 840,1530 1530,2100
you'll see nothing,| and then
|然后你必须追踪并猜测问题可能出在哪里。

3072
01:24:00,370 --> 01:24:01,990
0,480 480,600 600,870 870,1110 1110,1620
you'll have to track down

3073
01:24:02,110 --> 01:24:03,520
0,360 360,750 750,1050 1050,1140 1140,1410
and guess what the problem

3074
01:24:03,520 --> 01:24:04,400
0,180 180,480
might be.|
|

3075
01:24:05,640 --> 01:24:06,960
0,300 300,420 420,720 780,990 990,1320
Okay, so you do it
好的，那你就看着办吧。

3076
01:24:07,230 --> 01:24:08,660
0,330 330,900
by looking.|
|

3077
01:24:08,660 --> 01:24:10,280
0,480 480,720 720,1080 1080,1350 1350,1620
{} Okay, little bit, you
好的，稍微有点，你可以向UART同步写一个，

3078
01:24:10,280 --> 01:24:11,780
0,150 150,510 540,780 780,1350 1350,1500
can write a synchronously to

3079
01:24:11,780 --> 01:24:12,950
0,60 60,630 660,780 780,1020 1020,1170
the UART,| you know you
|你知道你可以喜欢，你知道你看到的字符把它们放在代码中的随机位置

3080
01:24:12,950 --> 01:24:15,650
0,270 270,780 990,1470 1650,2160 2160,2700
could like, you know characters

3081
01:24:15,650 --> 01:24:16,730
0,210 210,630 660,810 810,960 960,1080
you see put them in

3082
01:24:16,730 --> 01:24:17,750
0,240 240,600 600,660 660,720 720,1020
random places in the code|
|

3083
01:24:17,750 --> 01:24:18,410
0,90 90,300 300,420 420,540 540,660
and hope that you see
希望你能看到一些东西。

3084
01:24:18,410 --> 01:24:19,360
0,420
something.|
|

3085
01:24:21,440 --> 01:24:23,660
0,210 210,870 870,1200 1200,1650 1980,2220
{This,is} interesting, thank you.| {You,know}.|
这很有趣，谢谢。|你知道。|

3086
01:24:23,660 --> 01:24:25,610
0,660 660,930 930,990 990,1440 1440,1950
I wanted to ask {},|
我想问一下，|

3087
01:24:26,000 --> 01:24:27,950
0,390 390,1050 1080,1530 1530,1650 1650,1950
when you so I know
当你，我知道，当你开始行动的时候，

3088
01:24:27,950 --> 01:24:30,050
0,330 330,600 600,1290 1320,1560 1560,2100
like you implemented the Go,|
|

3089
01:24:30,050 --> 01:24:31,670
0,210 210,510 540,750 750,1350 1350,1620
some of the calls that
Go Runtime会执行一些您无法执行的调用，

3090
01:24:31,670 --> 01:24:32,960
0,150 150,390 390,600 600,810 810,1290
Go {runtime -} would make,

3091
01:24:32,990 --> 01:24:34,730
0,540 540,930 930,1110 1110,1470 1470,1740
{} that you cannot make,|
|

3092
01:24:34,730 --> 01:24:36,260
0,210 210,600 600,1110 1110,1200 1200,1530
because you're implementing the kernel
因为您正在实现内核本身，

3093
01:24:36,260 --> 01:24:38,480
0,420 870,1440 1560,1710 1710,1860 1860,2220
itself,| {} is there any
|有没有类似的东西？你是不是刚刚在汇编中实现了所有这些功能？

3094
01:24:38,480 --> 01:24:39,980
0,300 300,450 450,570 570,990 1020,1500
like did you just implement

3095
01:24:39,980 --> 01:24:40,820
0,240 240,420 420,510 510,720 720,840
just all of that in

3096
01:24:40,820 --> 01:24:43,130
0,660 690,930 930,1140 1140,1740 1890,2310
assembly| or did you say
|或者你是说好的，就像我们在围棋里还可以做的那样，

3097
01:24:43,130 --> 01:24:44,150
0,240 240,480 480,690 690,810 810,1020
okay like some of this

3098
01:24:44,150 --> 01:24:45,200
0,120 120,240 240,480 480,780 780,1050
we can still {do,in} Go,|
|

3099
01:24:45,200 --> 01:24:46,580
0,240 240,330 330,660 660,1140 1140,1380
like we can bring Go
就像我们可以把走得更近一点，然后只做必要的组装，

3100
01:24:46,580 --> 01:24:47,780
0,90 90,360 360,900 900,1050 1050,1200
a bit closer, and then

3101
01:24:47,780 --> 01:24:49,520
0,150 150,600 600,810 810,1050 1050,1740
do assembly only what's necessary,|
|

3102
01:24:49,640 --> 01:24:50,810
0,270 270,420 420,570 570,870 870,1170
what did you say like
一旦Go运行时像汇编一样结束，你会说什么？

3103
01:24:50,810 --> 01:24:52,370
0,240 240,360 360,810 810,1230 1230,1560
once the Go runtime ends

3104
01:24:52,370 --> 01:24:54,020
0,420 570,840 840,1350
like that's assembly.|
|

3105
01:24:54,230 --> 01:24:56,060
0,570 570,840 840,1140 1140,1650 1650,1830
{} You the {} that's
你们这就是一千五百条装配线的来源地，在一块饼干里，

3106
01:24:56,060 --> 01:24:57,050
0,180 180,270 270,570 570,780 780,990
where the fifteen hundred lines

3107
01:24:57,050 --> 01:24:58,620
0,60 60,450 450,630 630,1020
of assembly came from,

3108
01:24:58,650 --> 01:25:00,990
0,960 1050,1470 1470,1770 1770,1920 1920,2340
{} in a in Biscuit,|
|

3109
01:25:01,170 --> 01:25:02,250
0,150 150,300 300,570 570,690 690,1080
you know that is basically
您知道，这基本上就是为实际运行Go运行时做好一切准备的代码。

3110
01:25:02,250 --> 01:25:03,450
0,150 150,510 510,720 720,930 930,1200
the code to sort of

3111
01:25:03,480 --> 01:25:04,890
0,420 420,780 780,1050 1050,1260 1260,1410
get everything ready to be

3112
01:25:04,890 --> 01:25:05,790
0,330 330,540 540,660 660,840 840,900
actually able to run the

3113
01:25:05,790 --> 01:25:06,960
0,210 210,630
Go runtime.|
|

3114
01:25:08,450 --> 01:25:09,260
0,210 210,390 390,480 480,630 630,810
Now some of that would
其中一些可能会实现C语言，但我们不想这样做，

3115
01:25:09,260 --> 01:25:10,460
0,90 90,540 540,780 780,960 960,1200
have implemented C, but we

3116
01:25:10,460 --> 01:25:11,030
0,150 150,300 300,360 360,450 450,570
didn't want to do that,|
|

3117
01:25:11,030 --> 01:25:11,660
0,210 210,300 300,450 450,570 570,630
because we didn't want to
因为我们不想使用任何C语言，所以我们在汇编中。

3118
01:25:11,660 --> 01:25:12,650
0,150 150,330 330,600 600,750 750,990
use any C, so we're

3119
01:25:12,650 --> 01:25:13,780
0,90 90,510
in assembly.|
|

3120
01:25:13,900 --> 01:25:15,130
0,300 300,660 660,780 780,900 900,1230
And many of it actually
其中许多实际上需要组装，因为它在引导部分。

3121
01:25:15,130 --> 01:25:16,390
0,420 420,810 810,1050 1050,1170 1170,1260
required assembly, because it's in

3122
01:25:16,390 --> 01:25:17,660
0,90 90,360 360,720
the booting part.|
|

3123
01:25:18,250 --> 01:25:19,300
0,480 480,600 600,690 690,870 870,1050
Right, but I guess some
对，但我想有些部分，那不是靴子，

3124
01:25:19,300 --> 01:25:20,320
0,120 120,240 240,480 480,690 690,1020
of the part, that's not

3125
01:25:20,350 --> 01:25:21,940
0,300 300,630 630,840 840,1260 1260,1590
the boot,| so I I
|所以我我你知道我知道有些只是你不能避免一些引导代码和汇编，

3126
01:25:22,000 --> 01:25:22,810
0,180 180,330 330,420 420,600 600,810
you know I know that

3127
01:25:22,810 --> 01:25:24,730
0,450 480,900 900,1050 1050,1350 1350,1920
some just you cannot avoid

3128
01:25:24,760 --> 01:25:26,410
0,510 540,930 930,1140 1140,1230 1230,1650
some boot code and assembly,|
|

3129
01:25:26,410 --> 01:25:28,180
0,270 420,690 690,1110 1140,1560 1590,1770
but could you, {} could
但是你能不能，你能不能把集会上的一些东西改造一下，

3130
01:25:28,180 --> 01:25:29,440
0,120 120,390 390,960 960,1170 1170,1260
you have transformed some of

3131
01:25:29,440 --> 01:25:30,520
0,90 90,540 540,660 660,960 960,1080
the assembly to Go,| or
|还是你去了(绝对)。

3132
01:25:30,520 --> 01:25:31,180
0,150 150,270 270,420 420,570 570,660
did you go to the

3133
01:25:31,180 --> 01:25:33,910
0,990 990,1200 1200,1590 1590,2550 2550,2730
[absolutely].| We did a bunch
|我们下了一大堆围棋，基本上是在很早的时候就开始了，

3134
01:25:33,910 --> 01:25:35,440
0,60 60,330 330,510 510,870 870,1530
of Go, that basically runs

3135
01:25:35,470 --> 01:25:38,480
0,1470 1470,1770 1770,2070 2070,2580
{} very early on,|
|

3136
01:25:38,480 --> 01:25:39,890
0,600 600,780 780,1230 1230,1350 1350,1410
{} you know some of
你知道有些围棋走得非常小心，

3137
01:25:39,890 --> 01:25:41,060
0,90 90,390 390,450 450,720 720,1170
the {Go,goes -} quite careful,|
|

3138
01:25:41,120 --> 01:25:42,140
0,210 210,420 420,540 540,750 750,1020
it doesn't do any memory
它不进行任何内存分配，

3139
01:25:42,140 --> 01:25:43,360
0,720
allocations,|
|

3140
01:25:46,820 --> 01:25:48,410
0,330 780,1050 1050,1260 1260,1410 1410,1590
and we tried to write
我们试着尽可能多地写作，你知道，

3141
01:25:48,410 --> 01:25:49,490
0,120 120,270 270,330 330,720 780,1080
as much as possible {you,know},|
|

3142
01:25:49,520 --> 01:25:50,630
0,180 180,480 480,810 810,990 990,1110
I I can like I
我我想我必须看清楚你知道的代码才能回答你的问题，

3143
01:25:50,630 --> 01:25:51,200
0,120 120,180 180,450 450,510 510,570
have to look at the

3144
01:25:51,200 --> 01:25:52,460
0,210 210,810 810,930 930,1050 1050,1260
code exactly you know to

3145
01:25:52,460 --> 01:25:53,750
0,120 120,270 270,450 450,750 750,1290
be able to answer your

3146
01:25:53,780 --> 01:25:55,340
0,540 540,1200 1200,1320 1320,1410 1410,1560
question,| specifically you can look
|具体地说，你可以看看git回购，

3147
01:25:55,340 --> 01:25:57,050
0,60 60,150 150,330 330,810 1260,1710
at the git repo {},|
|

3148
01:25:57,050 --> 01:25:58,300
0,780
but,
但是，是的，我们试着在围棋里写下所有的东西。

3149
01:25:58,480 --> 01:25:59,890
0,450 480,960 960,1110 1110,1320 1320,1410
{} yeah, we tried to

3150
01:25:59,890 --> 01:26:01,320
0,180 180,450 450,570 570,900
write everything in Go.|
|

3151
01:26:03,580 --> 01:26:04,690
0,120 120,240 240,570 570,840 840,1110
And then one like kind
然后我有一个不相干的小问题，

3152
01:26:04,690 --> 01:26:06,160
0,120 120,720 720,960 960,1350 1350,1470
of unrelated small question I

3153
01:26:06,160 --> 01:26:08,680
0,360 720,1260 1680,2010 2010,2280 2280,2520
had,| {} what does Go
|围棋程序是怎么做的，使得它有可能运行数十万个围棋程序，

3154
01:26:08,680 --> 01:26:09,970
0,210 210,390 390,570 570,870 870,1290
do with its Go routines

3155
01:26:09,970 --> 01:26:11,350
0,300 300,630 630,720 720,1200 1200,1380
that makes it possible to

3156
01:26:11,350 --> 01:26:12,820
0,210 210,450 450,840 840,1380 1380,1470
run like hundred thousands of

3157
01:26:12,820 --> 01:26:13,680
0,360
them,|
|

3158
01:26:14,040 --> 01:26:15,480
0,330 330,510 510,870 870,1140 1140,1440
because you cannot just spin
因为你不能只把十万条线团正确地旋转起来。

3159
01:26:15,480 --> 01:26:16,890
0,240 240,360 360,750 750,1110 1110,1410
up a hundred thousand {pthreads

3160
01:26:16,890 --> 01:26:18,120
0,270 270,630
-} right.|
|

3161
01:26:18,210 --> 01:26:20,910
0,390 390,780 780,930 930,1470 1500,2700
{} Yeah, it depends, a
是的，这要看情况，时间要长得多，所以主要的问题是你需要分配堆栈，

3162
01:26:22,560 --> 01:26:24,090
0,330 330,780 780,960 960,1140 1140,1530
lot longer and so the

3163
01:26:24,090 --> 01:26:25,590
0,330 330,600 600,750 750,900 900,1500
main issue is that you

3164
01:26:25,590 --> 01:26:27,260
0,300 300,360 360,690 690,1170
need to allocate stack,|
|

3165
01:26:27,320 --> 01:26:29,570
0,780 780,1470 1500,1830 1830,2040 2040,2250
and the Go {runtime -}
而且Go运行时实际上会递增地分配堆栈

3166
01:26:29,570 --> 01:26:31,700
0,300 300,690 690,1020 1020,1710 1920,2130
actually allocates stack incrementally| and
|因此，当你运行围棋程序时，它们会动态增长，

3167
01:26:31,700 --> 01:26:33,470
0,120 120,540 540,720 720,1410 1440,1770
so grows them dynamically as

3168
01:26:33,470 --> 01:26:36,350
0,450 450,1140 1140,1410 1410,2250 2250,2880
you run your {Go,Go} routine,|
|

3169
01:26:36,500 --> 01:26:38,330
0,480 480,840 840,1200 1200,1530 1530,1830
{} this where's prologue code
这是开场白密码的地方，

3170
01:26:38,330 --> 01:26:39,470
0,120 120,540 630,930 930,990 990,1140
is for,| when you make
|当您进行函数调用时，您会查看是否有足够的空间来实际进行函数调用，

3171
01:26:39,470 --> 01:26:40,580
0,60 60,330 330,690 690,870 870,1110
a function call, you see

3172
01:26:40,580 --> 01:26:41,690
0,210 210,360 360,600 600,990 990,1110
if there's enough space to

3173
01:26:41,690 --> 01:26:43,670
0,570 570,1410 1440,1650 1650,1710 1710,1980
actually {} make the function

3174
01:26:43,670 --> 01:26:44,840
0,330 330,510 510,720 720,1050 1050,1170
call,| and if not, it
|如果没有，它将为您动态增长。

3175
01:26:44,840 --> 01:26:46,520
0,150 150,360 360,1230 1230,1500 1500,1680
will grow dynamically for you.|
|

3176
01:26:47,390 --> 01:26:50,390
0,600 600,1080 1080,1650 1680,2070 2070,3000
And often in [effect] implementations,|
并且通常在[效果]实现中，|

3177
01:26:50,570 --> 01:26:54,590
0,690 690,1920 2130,3450 3630,3900 3900,4020
{} {allocating,threads} a little bit
分配更多重量级的线程，

3178
01:26:54,590 --> 01:26:57,710
0,180 180,780 780,1200 1200,2040 2460,3120
more heavyweight,| because { -}
|因为实际上例如Linux基本上对应对应的内核线程实际被分配到，

3179
01:26:57,980 --> 01:27:00,500
0,660 660,960 960,1500 1500,1920 1920,2520
actually {for,example} Linux basically corresponds

3180
01:27:00,500 --> 01:27:01,940
0,510 510,840 840,1080 1080,1170 1170,1440
corresponding kernel threads is actually

3181
01:27:01,940 --> 01:27:03,240
0,510 510,870
allocated to,|
|

3182
01:27:03,680 --> 01:27:04,910
0,600 600,810 810,990 990,1140 1140,1230
and, {} they tend to
而且，他们往往比。

3183
01:27:04,910 --> 01:27:06,480
0,90 90,300 300,780 780,1020
be more heavyweight than.|
|

3184
01:27:08,790 --> 01:27:09,940
0,180 180,600
I see,|
我明白了,|

3185
01:27:10,090 --> 01:27:11,290
0,240 240,360 360,870 900,1110 1110,1200
is the {} is the
所有围棋例程的调度是否完全在用户空间中完成，

3186
01:27:11,290 --> 01:27:12,640
0,570 570,810 810,1080 1080,1200 1200,1350
scheduling of all the Go

3187
01:27:12,640 --> 01:27:14,290
0,480 480,720 720,1260 1260,1350 1350,1650
routines done completely in user

3188
01:27:14,290 --> 01:27:16,000
0,540 570,840 840,1020 1020,1350 1380,1710
space,| or does it help
|或者它可以帮助自己使用一些内核[]。

3189
01:27:16,000 --> 01:27:17,500
0,480 480,750 750,1050 1050,1140 1140,1500
itself with some of kernel

3190
01:27:17,500 --> 01:27:18,400
0,360
[].|
|

3191
01:27:18,400 --> 01:27:20,260
0,150 150,570 570,690 690,1680 1680,1860
{} It is mostly done
它主要是在用户空间中完成的。

3192
01:27:20,260 --> 01:27:21,480
0,90 90,270 270,690
in user space.|
|

3193
01:27:25,930 --> 01:27:27,280
0,240 240,360 360,750 750,990 990,1350
So the Go runtime allocates
所以Go运行时分配了一堆内核线程，你知道他们把它们叫做mThreats

3194
01:27:27,280 --> 01:27:28,900
0,60 60,330 330,600 600,1080 1080,1620
a bunch of kernel threads,

3195
01:27:29,520 --> 01:27:31,500
0,840 840,1080 1080,1620 1620,1620 1620,1980
{} {you,know} {they,call,them} I think

3196
01:27:31,500 --> 01:27:34,290
0,480 570,1290 1290,2250 2280,2460 2460,2790
{mthreats -}| and on top
|最重要的是，它实现了围棋程序。

3197
01:27:34,290 --> 01:27:35,280
0,90 90,390 390,510 510,900 900,990
of that it implements the

3198
01:27:35,280 --> 01:27:36,500
0,180 180,720
Go routines.|
|

3199
01:27:37,370 --> 01:27:38,750
0,420 420,690 690,960 960,1080 1080,1380
So it's so it has,
所以它有，就像几个内核线程，它共享给所有的围棋例程，基于运行的例程。

3200
01:27:38,750 --> 01:27:40,460
0,270 270,450 450,1020 1020,1410 1410,1710
like a couple kernel threads

3201
01:27:40,460 --> 01:27:41,630
0,180 180,330 330,780 780,930 930,1170
that it shares to all

3202
01:27:41,630 --> 01:27:42,920
0,120 120,660 660,990 990,1110 1110,1290
Go routines based on which

3203
01:27:42,920 --> 01:27:44,480
0,210 210,600 960,1350
ones running.| Yes.|
|是。|

3204
01:27:44,920 --> 01:27:46,240
0,180 180,300 300,600 600,960 960,1320
Oh, that makes sense, yeah.|
哦，这就说得通了，是的。|

3205
01:27:47,580 --> 01:27:49,530
0,180 180,480 480,1050 1080,1380 1380,1950
Is there a like any
有没有类似的C+C+等价物

3206
01:27:49,530 --> 01:27:51,960
0,840 840,1080 1080,1290 1290,2070 2220,2430
{C,C} plus plus equivalent| like,
|比如说，你能不能做点这样的事来节省一下内存。

3207
01:27:51,960 --> 01:27:53,460
0,180 180,570 1080,1290 1290,1380 1380,1500
could you could you do

3208
01:27:53,460 --> 01:27:54,990
0,330 330,480 480,780 780,900 900,1530
something like that to save

3209
01:27:55,080 --> 01:27:56,520
0,150 150,420 420,570 570,1050 1260,1440
to save some memory.| Yeah
|是的，人们已经做到了，你可以管理得很好，

3210
01:27:56,520 --> 01:27:57,600
0,210 210,330 330,660 660,840 840,1080
people have done, you able

3211
01:27:57,600 --> 01:27:59,130
0,300 300,540 540,690 690,1410 1410,1530
manage like high performance,| you
|你知道，C库是线程库，

3212
01:27:59,130 --> 01:28:01,290
0,120 120,630 840,1380 1380,1890 1890,2160
know so C libraries are

3213
01:28:01,290 --> 01:28:02,580
0,330 360,570 570,1020 1020,1170 1170,1290
{} thread libraries,| that way
|这样你就可以为数以百万计的线程创建数以千计的线程，

3214
01:28:02,580 --> 01:28:03,960
0,90 90,240 240,810 810,1290 1290,1380
you can create thousands of

3215
01:28:03,960 --> 01:28:04,890
0,120 120,240 240,510 510,840 840,930
{you,know - -} threads for

3216
01:28:04,890 --> 01:28:05,940
0,330 330,420 420,840 840,930 930,1050
millions of threads,| you know
|你知道的是相似的款式。

3217
01:28:05,940 --> 01:28:08,420
0,390 390,930 1260,1650 1650,2130
to a similar style.|
|

3218
01:28:14,160 --> 01:28:15,270
0,420 450,720 720,810 810,1020 1020,1110
Okay, {} you guys have
好了，你们好好休息，我得走了。

3219
01:28:15,270 --> 01:28:17,730
0,90 90,240 240,690 1050,1830 1860,2460
a good break, {I,must,head,out}.| {You,too}.|
|你也是。|

3220
01:28:18,060 --> 01:28:19,410
0,180 180,240 240,450 450,780 1050,1350
See you next week or
下周或两周见。

3221
01:28:19,410 --> 01:28:24,460
0,90 90,480 3990,4590
two weeks {}.|
|

3222
01:28:24,490 --> 01:28:26,320
0,720 900,1260
Yeah, oh.|
是啊，哦。|

3223
01:28:26,660 --> 01:28:28,000
0,180 180,330 330,750
Oh, go ahead.|
哦，去吧。|

3224
01:28:29,220 --> 01:28:31,800
0,600 780,1620 1890,2310 2310,2460 2460,2580
I'm sorry, {} so I
抱歉，我有一个关于垫片的基本问题

3225
01:28:31,800 --> 01:28:33,450
0,120 120,450 480,810 810,1170 1170,1650
have a maybe basic question

3226
01:28:33,450 --> 01:28:35,070
0,330 330,450 450,960 960,1170 1170,1620
about the {shims -}| and
|我想我可能还不太熟悉运行库是什么样子的

3227
01:28:35,070 --> 01:28:36,540
0,120 120,540 570,1020 1020,1170 1170,1470
I guess I think also

3228
01:28:36,540 --> 01:28:37,920
0,360 360,480 480,660 660,840 840,1380
maybe I'm just not familiar

3229
01:28:37,920 --> 01:28:39,810
0,210 480,750 750,930 990,1590 1590,1890
with kind of specifically what

3230
01:28:39,840 --> 01:28:41,580
0,240 240,600 600,750 750,1290 1290,1740
like {} a runtime is|
|

3231
01:28:41,790 --> 01:28:43,080
0,570 570,720 720,1020 1020,1230 1230,1290
and I guess like my
我猜我的念力来自于这样一个事实，就像是来自于xv6和c语言如何工作的心理模型，

3232
01:28:43,080 --> 01:28:44,370
0,510 510,750 750,930 930,1020 1020,1290
confusion comes from the fact

3233
01:28:44,370 --> 01:28:45,480
0,90 90,390 540,750 750,840 840,1110
that like from a mental

3234
01:28:45,480 --> 01:28:47,370
0,420 420,690 690,1350 1380,1770 1770,1890
model of how {xv6 -

3235
01:28:47,370 --> 01:28:48,690
0,330 330,510 510,780 780,1140 1140,1320
-} and C works,| is
|C编译C是一种编译语言

3236
01:28:48,690 --> 01:28:50,490
0,360 360,630 630,1470 1500,1680 1680,1800
that C compiles C is

3237
01:28:50,490 --> 01:28:52,200
0,60 60,420 420,1050 1350,1560 1560,1710
a compiled language| and so
|因此它直接进入汇编或机器代码，

3238
01:28:52,200 --> 01:28:53,580
0,120 120,300 300,720 720,840 840,1380
it goes directly to assembly

3239
01:28:53,580 --> 01:28:55,830
0,90 90,480 480,1110 1350,1950 2100,2250
or machine code,| {} and
|所以它有点像是在CPU上运行

3240
01:28:55,830 --> 01:28:56,760
0,390 390,510 510,630 630,690 690,930
so it kind of just

3241
01:28:56,760 --> 01:28:58,650
0,390 390,510 510,570 570,1350 1470,1890
runs on the CPU| and
|所以我猜，就像xv6操作系统不需要填隙程序一样，

3242
01:28:58,650 --> 01:29:00,570
0,240 240,450 450,870 900,1380 1590,1920
so I guess, {} like

3243
01:29:00,690 --> 01:29:01,620
0,150 150,300 300,450 450,780 780,930
there is no need for

3244
01:29:01,620 --> 01:29:03,180
0,90 90,660 780,1140 1140,1440 1440,1560
a shim for {like,xv6 -

3245
01:29:03,180 --> 01:29:05,760
0,480 540,1140 1560,2100 2250,2400 2400,2580
-} OS,| {} but I
|但我想我的理解是围棋也是一种编译语言，

3246
01:29:05,760 --> 01:29:07,260
0,210 210,630 630,810 810,1110 1110,1500
guess {my,understanding} is {Go,is} also

3247
01:29:07,260 --> 01:29:08,430
0,90 90,570 570,960 960,1080 1080,1170
a compiled language,| so it
|所以它也会被送到集会上，

3248
01:29:08,430 --> 01:29:10,050
0,330 330,660 660,780 780,900 900,1620
also goes to the assembly,|
|

3249
01:29:10,170 --> 01:29:11,010
0,240 240,510 510,630 630,810 810,840
so why is there a
那么为什么在这种情况下需要像垫片一样，

3250
01:29:11,010 --> 01:29:12,990
0,750 750,1260 1290,1500 1500,1860 1860,1980
need for {like,a} shim in

3251
01:29:12,990 --> 01:29:14,520
0,180 180,420 420,780 780,1140 1320,1530
this case,| why, why is
|为什么，为什么会有像xv6这样的垫片，

3252
01:29:14,520 --> 01:29:15,510
0,150 150,390 390,600 600,750 750,990
there maybe is a shim

3253
01:29:15,510 --> 01:29:17,220
0,240 240,510 600,1290 1290,1620 1620,1710
for like xv6,| or you
|或者你知道吗，这里有什么不同

3254
01:29:17,220 --> 01:29:18,240
0,60 60,270 270,450 450,600 600,1020
know what, what is different

3255
01:29:18,240 --> 01:29:19,860
0,180 180,480 630,1140 1140,1230 1230,1620
here| and why are there
|为什么有些事情不能只在CPU上做。

3256
01:29:19,950 --> 01:29:21,360
0,390 390,480 480,750 750,1110 1110,1410
why are there things that

3257
01:29:21,360 --> 01:29:22,320
0,270 270,480 480,570 570,780 780,960
can't just be done on

3258
01:29:22,320 --> 01:29:24,240
0,270 750,1080 1080,1230 1230,1680 1680,1920
{the,CPU}.| Yeah yeah, a great
|是的，是的，一个很好的问题，

3259
01:29:24,240 --> 01:29:25,800
0,390 420,1080 1110,1320 1320,1410 1410,1560
question,| {} so I think
|所以我想你问题的答案是

3260
01:29:25,800 --> 01:29:26,850
0,330 330,510 510,630 630,720 720,1050
the answer to your question

3261
01:29:26,850 --> 01:29:28,740
0,120 120,420 420,720 750,1110 1110,1890
is that| the Go runtime
|Go运行时提供了所有类型的功能

3262
01:29:29,070 --> 01:29:30,570
0,450 450,750 750,960 960,1020 1020,1500
provides all kinds of features|
|

3263
01:29:30,570 --> 01:29:31,860
0,420 420,690 690,780 780,1050 1050,1290
that like you know you
就像你知道你没有权利，当你在xv6中运行C语言的时候，

3264
01:29:31,860 --> 01:29:33,900
0,210 210,660 690,990 990,1650 1680,2040
don't have right, in running

3265
01:29:33,900 --> 01:29:35,400
0,360 360,480 480,810 810,1110 1110,1500
when you're running C {in,xv6

3266
01:29:35,400 --> 01:29:38,100
0,510 810,1380 1380,1740 1740,2130 2130,2700
-},| {so,Go} runtime provides threads,
|所以GO运行时提供线程，GO运行时提供调度程序，GO运行时提供哈希表，

3267
01:29:38,250 --> 01:29:40,350
0,270 270,630 630,960 960,1560 1590,2100
Go runtime provides scheduler, {}

3268
01:29:40,350 --> 01:29:43,380
0,240 240,1110 1140,1950 1950,2580 2580,3030
Go runtime provides hash tables,|
|

3269
01:29:43,380 --> 01:29:44,370
0,90 90,270 270,660 660,960 960,990
{} Go runtime provides {}
Go Runtime提供了垃圾收集器，实际上需要在运行时运行对吧，

3270
01:29:44,370 --> 01:29:46,080
0,330 330,780 1050,1230 1230,1470 1470,1710
garbage collector, that actually needs

3271
01:29:46,080 --> 01:29:47,130
0,90 90,270 270,480 480,810 840,1050
to run at runtime right,|
|

3272
01:29:47,130 --> 01:29:48,570
0,180 180,510 510,840 840,1140 1140,1440
then there's no garbage collector
那么在xv6中就没有垃圾收集器。

3273
01:29:48,570 --> 01:29:49,860
0,120 120,840
in xv6.|
|

3274
01:29:49,860 --> 01:29:51,300
0,270 270,600 600,960 960,1350 1350,1440
{} And we implement the
我们实现了线程

3275
01:29:51,300 --> 01:29:54,090
0,480 900,1740 1770,2250 2250,2700 2700,2790
threads| and {} {for,example} to
|例如，为了支持垃圾收集器，它需要一个堆，如果我们要从

3276
01:29:54,090 --> 01:29:55,110
0,270 270,330 330,630 630,930 930,1020
support the garbage collector, it

3277
01:29:55,110 --> 01:29:56,400
0,300 300,360 360,750 780,1050 1050,1290
needs a heap, if we're

3278
01:29:56,400 --> 01:29:57,600
0,120 120,480 480,750 750,1020 1050,1200
to allocate memory from| and
|所以我问了操作系统底层的操作系统，所以请给我一些内存，你知道的，我可以把它当作堆使用。

3279
01:29:57,600 --> 01:29:58,980
0,300 300,570 570,960 960,1020 1020,1380
so I ask the operating

3280
01:29:58,980 --> 01:30:00,390
0,330 330,690 690,990 990,1290 1290,1410
system underlying operating system, so

3281
01:30:00,390 --> 01:30:01,470
0,330 330,480 480,900 900,960 960,1080
please give me you know

3282
01:30:01,470 --> 01:30:02,250
0,120 120,510 510,600 600,660 660,780
some memories that I can

3283
01:30:02,250 --> 01:30:02,940
0,150 150,210 210,300 300,360 360,690
use it as a heap.|
|

3284
01:30:03,610 --> 01:30:05,710
0,420 420,840 840,1140 1140,1500 1500,2100
And basically the shim layer
基本上填充层精确地实现了，

3285
01:30:05,920 --> 01:30:07,660
0,570 570,1170 1170,1320 1320,1560 1560,1740
implements exactly,| so that kind
|因此Go运行时在运行时执行作业所需功能。

3286
01:30:07,660 --> 01:30:09,730
0,60 60,690 690,930 930,1650 1740,2070
of functionality that the Go

3287
01:30:09,730 --> 01:30:11,020
0,450 450,780 780,870 870,1080 1080,1290
runtime needs to do a

3288
01:30:11,020 --> 01:30:13,780
0,630 1020,1380 1380,1650 1650,2310
job {} at runtime.|
|

3289
01:30:13,840 --> 01:30:17,420
0,1080 1080,3000

3290
01:30:23,120 --> 01:30:25,140
0,960 960,1260 1260,1470
{} I see.|
我明白了。|

3291
01:30:25,200 --> 01:30:28,440
0,660 660,840 840,1020 1020,2220 2520,3240
Yeah, you have a slightly
是的，你说得有点道理，实际上我还有一个后续问题，

3292
01:30:28,440 --> 01:30:29,520
0,180 180,420 420,750 750,990 990,1080
makes sense, I actually a

3293
01:30:29,520 --> 01:30:31,420
0,270 270,690 690,1410
follow-up question is,|
|

3294
01:30:32,550 --> 01:30:33,660
0,540 540,870 870,1020 1020,1080 1080,1110
{} maybe this is a
也许这是一个愚蠢的问题，但就像我们能不能像这样，我们只编译到运行时，直到机器代码，或者。

3295
01:30:33,660 --> 01:30:35,400
0,150 150,480 480,630 630,1260 1350,1740
dumb question, but like {}

3296
01:30:36,650 --> 01:30:38,450
0,480 630,930 930,1020 1020,1260 1260,1800
like can we just compile

3297
01:30:38,450 --> 01:30:40,120
0,120 120,540 540,1110
to runtime down

3298
01:30:40,120 --> 01:30:42,550
0,150 150,1050 1050,1650 1680,2130 2130,2430
to machine code, or.| {Runtime
|运行时被编译为运行。

3299
01:30:42,550 --> 01:30:43,750
0,210 210,480 480,900 900,990 990,1200
-} is compile to run

3300
01:30:43,750 --> 01:30:45,610
0,540 540,990 1110,1290 1290,1560 1560,1860
{}.| Okay.| It goes like
|好吧。|就像您知道运行库本身也是编译的一样，

3301
01:30:45,610 --> 01:30:46,630
0,90 90,240 240,390 390,690 690,1020
you know the runtime itself

3302
01:30:46,630 --> 01:30:47,620
0,90 90,300 300,720 720,870 870,990
is also compiled,| but it's
|但这就像是您是程序的一部分，需要始终运行Run Go代码。

3303
01:30:47,620 --> 01:30:48,340
0,180 180,360 360,570 570,630 630,720
like you're part of the

3304
01:30:48,340 --> 01:30:49,540
0,360 360,480 480,750 750,840 840,1200
program that needs to run

3305
01:30:49,540 --> 01:30:51,460
0,690 690,1020 1020,1290 1290,1500 1500,1920
always running run Go code.|
|

3306
01:30:52,190 --> 01:30:53,090
0,180 180,420 420,480 480,630 630,900
It has to be there,
它必须在那里，就像C语言有一个很小的运行时一样，

3307
01:30:53,180 --> 01:30:54,470
0,300 330,660 660,870 870,1110 1110,1290
like even like C has

3308
01:30:54,470 --> 01:30:55,520
0,60 60,300 300,720 720,960 960,1050
a small runtime,| if you
|如果您想一想，您知道我们有像printf是应该实时运行到C运行时的一部分，

3309
01:30:55,520 --> 01:30:56,630
0,150 150,630 630,720 720,960 960,1110
think about you know we

3310
01:30:56,630 --> 01:30:57,740
0,330 330,540 540,750 750,990 990,1110
have like {printf -} is

3311
01:30:57,740 --> 01:30:58,550
0,210 210,360 360,570 570,720 720,810
part of should live to

3312
01:30:58,550 --> 01:31:00,650
0,180 180,660 1050,1440 1440,2010 2010,2100
C runtime,| string operations are
|字符串操作是C运行时权限的一部分，

3313
01:31:00,650 --> 01:31:01,700
0,210 210,270 270,360 360,570 570,1050
part of the C runtime

3314
01:31:01,850 --> 01:31:03,830
0,330 630,1140 1140,1500 1500,1800 1800,1980
right,| there compile too,| but
|在那里也进行编译，|但是C运行时有一些很少的函数，

3315
01:31:03,830 --> 01:31:05,150
0,450 450,510 510,720 720,1020 1020,1320
there's a bunch of small

3316
01:31:05,150 --> 01:31:06,230
0,180 180,240 240,690 690,870 870,1080
number of functions that the

3317
01:31:06,230 --> 01:31:08,060
0,210 210,630 630,1050 1200,1680 1680,1830
C runtime has,| but their
|但与Go运行时相比，它们的运行时太小了，

3318
01:31:08,060 --> 01:31:09,620
0,210 210,300 300,600 600,1170 1170,1560
runtime is so small compared

3319
01:31:09,620 --> 01:31:10,940
0,330 330,420 420,690 690,1140 1140,1320
to the Go runtime,| that
|你必须支持更多的功能，

3320
01:31:10,940 --> 01:31:12,230
0,240 240,450 450,570 570,840 840,1290
you have to support many

3321
01:31:12,230 --> 01:31:13,940
0,180 180,660 930,1440 1440,1620 1620,1710
more features,| because of the
|因为你去的程序，程序依赖于它们。

3322
01:31:13,940 --> 01:31:15,680
0,660 660,840 840,1050 1050,1470 1470,1740
programs you Go programs rely

3323
01:31:15,680 --> 01:31:16,360
0,60 60,330
on them.|
|

3324
01:31:17,320 --> 01:31:18,850
0,390 390,690 690,810 810,1200 1260,1530
I see I see {},|
我明白了，我明白了，|

3325
01:31:18,850 --> 01:31:19,630
0,120 120,180 180,300 300,510 510,780
and I guess the last
我想最后一个问题可能是这样的，

3326
01:31:19,630 --> 01:31:20,800
0,270 270,390 390,630 630,900 900,1170
question would maybe be like,|
|

3327
01:31:20,800 --> 01:31:22,090
0,270 270,540 690,990 990,1230 1230,1290
is it it kind of
在这种情况下是不是听起来有点像，

3328
01:31:22,090 --> 01:31:23,200
0,330 330,540 540,810 810,900 900,1110
sounds like that in this

3329
01:31:23,200 --> 01:31:25,330
0,330 330,480 480,840 840,1650 1980,2130
case,| the Go runtime or
|GO运行时或像这种情况下的实际填隙程序几乎不正常地承担了一些功能，

3330
01:31:25,330 --> 01:31:26,530
0,120 120,270 270,630 630,720 720,1200
like the actually the shim

3331
01:31:26,530 --> 01:31:27,820
0,120 120,270 270,480 480,600 600,1290
in this case is almost

3332
01:31:28,240 --> 01:31:29,020
0,360 360,510 510,630 630,690 690,780
taking on some of the

3333
01:31:29,020 --> 01:31:31,600
0,660 660,1590 1800,1950 1950,2220 2220,2580
functionality abnormally,| like it's almost
|就像它几乎就像一辆迷你车，

3334
01:31:31,600 --> 01:31:32,860
0,150 150,330 330,480 480,570 570,1260
like it's like a mini,|
|

3335
01:31:33,640 --> 01:31:34,390
0,120 120,420 420,540 540,600 600,750
it's almost kind of like,
它几乎就像，它就像一个迷你操作系统层，

3336
01:31:34,390 --> 01:31:36,460
0,240 480,690 690,1350 1350,1620 1620,2070
it's like a mini OS

3337
01:31:36,460 --> 01:31:37,780
0,420 450,750 750,900 900,1200 1200,1320
layer,| like in terms that
|就像它就像执行一些低级系统功能的另一层一样，比如合理的。

3338
01:31:37,780 --> 01:31:39,070
0,120 120,330 330,480 510,960 960,1290
it's just like another layer

3339
01:31:39,070 --> 01:31:41,440
0,390 420,870 870,1140 1140,1680 1680,2370
that's performing some low-level system

3340
01:31:41,470 --> 01:31:45,970
0,630 660,1050 1050,1560 2790,3960 3990,4500
functionality, like reasonable.| {Yeah,you,can}, maybe
|是的，也许可以用一种方式来考虑[xv6]它也有一个非常非常小的垫片，

3341
01:31:45,970 --> 01:31:46,960
0,360 360,510 510,600 600,720 720,990
one way to think about

3342
01:31:46,960 --> 01:31:48,040
0,480 480,660 660,900 900,1020 1020,1080
[xv6] it also has a

3343
01:31:48,040 --> 01:31:49,810
0,420 420,690 690,1080 1080,1500 1620,1770
very very minimal shim,| you
|你知道，也许当靴子正确的时候，

3344
01:31:49,810 --> 01:31:50,860
0,120 120,660 660,780 780,960 960,1050
know maybe like when the

3345
01:31:50,860 --> 01:31:51,880
0,300 300,600 600,660 660,900 900,1020
boots correct,| the first thing
|它实际做的第一件事就是分配一些堆栈，

3346
01:31:51,880 --> 01:31:53,140
0,90 90,390 390,690 690,1140 1140,1260
it does actually allocates some

3347
01:31:53,140 --> 01:31:54,040
0,450 450,570 570,690 690,780 780,900
stacks,| so that you can
|这样你就可以实际调用C Main函数了。

3348
01:31:54,040 --> 01:31:55,840
0,240 240,600 600,1020 1020,1410 1410,1800
actually call the C main

3349
01:31:55,840 --> 01:31:56,780
0,510
function.|
|

3350
01:31:57,240 --> 01:31:58,110
0,180 180,270 270,360 360,540 540,870
And you can think about
你可以考虑一下这段代码，它只有几个语句，

3351
01:31:58,110 --> 01:31:59,640
0,510 510,780 780,1140 1140,1200 1200,1530
that little fragment of code

3352
01:31:59,640 --> 01:32:00,330
0,90 90,180 180,390 390,420 420,690
which is only a couple

3353
01:32:00,330 --> 01:32:01,920
0,630 630,720 720,990 990,1350 1350,1590
statements,| the shim layer for
|xv6的填充层。

3354
01:32:01,920 --> 01:32:03,160
0,750
xv6.|
|

3355
01:32:03,710 --> 01:32:04,910
0,360 360,600 600,930 930,1050 1050,1200
{} And once you know
一旦你知道你已经通过了几个指令，

3356
01:32:04,910 --> 01:32:05,870
0,270 270,510 510,600 600,870 870,960
you're through a couple of

3357
01:32:05,870 --> 01:32:07,340
0,540 540,720 720,990 990,1230 1230,1470
instructions,| you're actually C code
|您实际上是C代码，一切都很好。

3358
01:32:07,340 --> 01:32:08,700
0,90 90,330 330,420 420,780
and everything is fine.|
|

3359
01:32:08,790 --> 01:32:10,860
0,630 630,750 750,900 900,1560 1800,2070
And you know the shim
您知道填充层To Go运行时稍微大一些，

3360
01:32:10,860 --> 01:32:12,000
0,450 450,540 540,810 810,1020 1020,1140
layer to Go {runtime -}

3361
01:32:12,000 --> 01:32:12,930
0,210 210,300 300,420 420,690 690,930
is {slightly -} bigger,| because
|因为还有更多的功能需要设置，

3362
01:32:12,930 --> 01:32:13,590
0,180 180,210 210,390 390,450 450,660
there's a bunch of more

3363
01:32:13,590 --> 01:32:14,340
0,330 330,450 450,570 570,660 660,750
features that need to be

3364
01:32:14,340 --> 01:32:15,300
0,210 210,450 450,720 720,810 810,960
set up,| before they Go
|在它们运行之前，运行时实际上是愉快地执行的。

3365
01:32:15,300 --> 01:32:16,950
0,270 270,420 420,810 810,1110 1110,1650
{runtime -} actually happily execute.|
|

3366
01:32:18,700 --> 01:32:20,650
0,420 420,810 810,1080 1080,1710 1710,1950
{} Okay, yeah that's helpful
好的，是的，这很有帮助，很有道理，酷。

3367
01:32:20,650 --> 01:32:22,420
0,120 120,330 330,810 1110,1500
that makes sense, cool.|
|

3368
01:32:23,150 --> 01:32:25,060
0,210 210,390 810,990 990,1440
Thank you.| You're welcome.|
谢谢。|不用谢。|

3369
01:32:25,460 --> 01:32:27,050
0,240 240,720 960,1170 1170,1290 1290,1590
Happy Thanksgiving.| Yeah, you too.|
感恩节快乐。|好的，你也是。|

3370
01:32:28,240 --> 01:32:29,380
0,330 330,450 450,660 660,810 810,1140
Oh, I had a question
哦，我有个关于乒乓球项目的问题忘了问，

3371
01:32:29,380 --> 01:32:31,510
0,240 240,450 510,780 780,1260 1710,2130
about the ping pong program

3372
01:32:31,510 --> 01:32:32,650
0,150 150,270 270,660 660,780 780,1140
that I forgot to ask,|
|

3373
01:32:32,680 --> 01:32:34,150
0,330 330,540 540,840 840,1110 1110,1470
so I remember we also
所以我记得我们还在其中一个实验室做了一个乒乓球项目。

3374
01:32:34,150 --> 01:32:35,560
0,150 150,330 330,600 600,900 900,1410
did a ping pong {program,in}

3375
01:32:35,560 --> 01:32:37,980
0,360 360,450 450,570 570,1230
one of the labs.|
|

3376
01:32:38,070 --> 01:32:39,930
0,210 210,750 840,1140 1140,1260 1260,1860
It was not a hundred,
那不是一百，那一千行代码，为什么是。

3377
01:32:39,960 --> 01:32:41,550
0,330 330,570 570,1080 1080,1470 1470,1590
those a thousand lines of

3378
01:32:41,550 --> 01:32:44,420
0,540 840,1890 1920,2400
code, why is.|
|

3379
01:32:44,420 --> 01:32:46,490
0,510 510,660 660,1500 1710,1830 1830,2070
Because like one, I think
因为就像一个实验室一样，我想你指的是一个实验室，在那里你用一个字节在管道上打乒乓球。

3380
01:32:46,490 --> 01:32:47,600
0,450 450,810 810,870 870,900 900,1110
you're referring to a lab

3381
01:32:47,600 --> 01:32:48,860
0,450 450,570 570,720 720,1020 1050,1260
where you do the ping

3382
01:32:48,860 --> 01:32:49,700
0,180 180,300 300,360 360,600 600,840
pong with a byte across

3383
01:32:49,700 --> 01:32:50,740
0,60 60,510
the pipe.|
|

3384
01:32:50,860 --> 01:32:52,300
0,540 750,960 960,1080 1080,1350 1350,1440
Yeah, okay so that's the
是的，好的，这就是基准的用户端，

3385
01:32:52,300 --> 01:32:54,580
0,300 300,570 570,630 630,1200 1260,2280
user side of the benchmark,|
|

3386
01:32:54,610 --> 01:32:56,140
0,330 330,690 690,990 990,1380 1380,1530
the kernel side correctly is
内核方面正确地说是它的另一面

3387
01:32:56,140 --> 01:32:57,550
0,510 570,840 840,1110 1110,1230 1230,1410
the other side of it|
|

3388
01:32:57,550 --> 01:32:59,140
0,300 300,870 870,960 960,1170 1170,1590
and basically you know that
基本上，您知道我们所做的是实现以相同方式传递的内核。

3389
01:32:59,260 --> 01:33:00,640
0,210 210,330 330,570 570,870 870,1380
what we did is implement

3390
01:33:00,640 --> 01:33:01,840
0,60 60,330 330,660 660,750 750,1200
the kernel passed in identical

3391
01:33:01,840 --> 01:33:02,620
0,330
manner.|
|

3392
01:33:04,530 --> 01:33:06,060
0,600 660,900 900,1230 1230,1350 1350,1530
Okay.| So like you know
好吧。|所以就像你知道你在执行启动，系统调用，

3393
01:33:06,060 --> 01:33:07,590
0,270 270,1050 1050,1140 1140,1440 1440,1530
you executing the startup, the

3394
01:33:07,590 --> 01:33:09,660
0,300 300,960 960,1440 1440,1950 1950,2070
system call,| using variables in
|使用堆栈帧中的变量，

3395
01:33:09,660 --> 01:33:11,160
0,360 360,660 660,1230 1230,1290 1290,1500
the stack frame,| you know
|你知道打电话去查管道，

3396
01:33:11,160 --> 01:33:12,660
0,390 390,960 960,1290 1290,1410 1410,1500
calling into looking up the

3397
01:33:12,660 --> 01:33:14,500
0,540 540,660 660,900 900,1380
pipe,| you know then
|你知道，然后可能会运行调度程序来唤醒，

3398
01:33:14,530 --> 01:33:16,030
0,630 630,870 870,930 930,1380 1380,1500
running maybe the scheduler to

3399
01:33:16,030 --> 01:33:17,020
0,240 240,480 480,570 570,690 690,990
wake up,| you know the
|你知道接收器和整个代码路径，

3400
01:33:17,020 --> 01:33:19,210
0,780 990,1440 1440,1650 1650,2010 2010,2190
receiver {} and that whole

3401
01:33:19,210 --> 01:33:20,560
0,330 330,810 810,960 960,1110 1110,1350
code path,| you know on
|您知道，在内核方面，我们试图实现它，在C和GO中是一样的。

3402
01:33:20,560 --> 01:33:22,900
0,60 60,390 390,840 1140,1890 1890,2340
the kernel side {} we

3403
01:33:22,930 --> 01:33:24,160
0,210 210,270 270,600 600,690 690,1230
tried to implement it, identically

3404
01:33:24,160 --> 01:33:25,700
0,90 90,660 660,1080
in {C,and,in} Go.|
|

3405
01:33:25,700 --> 01:33:27,440
0,990 1020,1170 1170,1230 1230,1680 1680,1740
Okay.| But the benchmark is
好吧。|但基准与您在实验一中实际实施的基准基本相同，

3406
01:33:27,440 --> 01:33:28,460
0,360 360,420 420,720 720,810 810,1020
basically the same as your

3407
01:33:28,460 --> 01:33:30,290
0,450 450,570 570,690 690,1230 1230,1830
benchmark that you implemented actually

3408
01:33:30,290 --> 01:33:31,820
0,180 180,390 390,720 810,1050 1050,1530
in lab one,| the {user,level}
|它的用户级别方面。

3409
01:33:31,820 --> 01:33:32,840
0,240 240,330 330,510
side of it.|
|

3410
01:33:33,250 --> 01:33:34,630
0,420 450,750 780,1050 1050,1170 1170,1380
Right, right, okay that makes
好的，好的，这就说得通了，

3411
01:33:34,630 --> 01:33:36,100
0,390 420,900
sense,| so,
|所以，那是不是意味着，

3412
01:33:36,440 --> 01:33:37,430
0,180 180,270 270,390 390,630 630,990
so does that mean like,|
|

3413
01:33:38,140 --> 01:33:39,100
0,150 150,390 390,540 540,720 720,960
I mean I think that
我的意思是，我认为如果在xv6中这样做，将大大少于1000行代码，

3414
01:33:39,100 --> 01:33:39,850
0,120 120,240 240,330 330,510 510,750
if you do that in

3415
01:33:39,850 --> 01:33:41,500
0,300 300,540 540,690 690,1080
{xv6 -} would be

3416
01:33:41,560 --> 01:33:43,510
0,960 1020,1350 1350,1530 1530,1620 1620,1950
significantly less than a thousand

3417
01:33:43,510 --> 01:33:44,320
0,270 270,330 330,570 570,720 720,810
lines of code,| if you
|如果您愿意，请使用所有内核代码。

3418
01:33:44,320 --> 01:33:48,220
0,240 270,1020 1230,3240 3240,3570 3570,3900
like take {all,the,kernel,code}.| There's thousand
|有上千行的汇编指令是正确的，

3419
01:33:48,220 --> 01:33:50,110
0,270 270,480 480,810 810,1320 1320,1890
thousand lines for assembly instructions

3420
01:33:50,110 --> 01:33:52,360
0,360 510,1260 1260,1560 1560,1740 1740,2250
correct,| {} so you know
|所以你知道我我不知道我会看的，

3421
01:33:52,660 --> 01:33:53,590
0,210 210,510 510,630 630,840 840,930
I I don't know I

3422
01:33:53,590 --> 01:33:54,370
0,150 150,240 240,330 330,570 570,780
will have to look at,|
|

3423
01:33:54,370 --> 01:33:55,810
0,240 240,360 360,600 600,750 750,1440
but you know you're gonna
但你知道你会用到陷阱代码，

3424
01:33:55,810 --> 01:33:57,340
0,330 330,450 450,720 720,930 930,1530
use the {trapframe -} code,|
|

3425
01:33:57,340 --> 01:33:59,140
0,90 90,480 480,660 660,1410
you {syscall -} dispatch,
您的系统调用调度，转到FD层，正确，文件描述符，

3426
01:33:59,140 --> 01:34:02,410
0,450 450,660 660,1230 1380,2490 2580,3270
going to the the {fd

3427
01:34:02,410 --> 01:34:03,610
0,210 210,600 600,960 960,1050 1050,1200
-} layer, correct, the file

3428
01:34:03,610 --> 01:34:06,700
0,630 900,1650 1680,2730 2730,3000 3000,3090
descriptors,| then a little bit
|然后是一小段管道代码，

3429
01:34:06,700 --> 01:34:09,850
0,120 120,390 390,900 1020,2340 2730,3150
of pipe code,| then copyin
|然后复制和复制，

3430
01:34:09,850 --> 01:34:11,830
0,150 150,480 480,960 1170,1830 1830,1980
and {copyout -},| then the
|然后是调度程序，然后基本上都是[]，然后再次[跳出]或返回。

3431
01:34:11,830 --> 01:34:13,810
0,810 1110,1260 1260,1500 1500,1770 1770,1980
scheduler and then basically all

3432
01:34:13,810 --> 01:34:15,700
0,420 420,1140 1140,1410 1410,1740 1740,1890
[] and then [bailing] out

3433
01:34:15,700 --> 01:34:17,200
0,270 270,510 540,1080
again or returning.|
|

3434
01:34:17,750 --> 01:34:19,200
0,360 360,900
Yeah, okay,
是啊，好吧，这就说得通了。

3435
01:34:19,290 --> 01:34:22,050
0,1230 1530,2100 2400,2520 2520,2700 2700,2760
{that,make,sence -}.| I don't know
|我不知道怎么理解我的客户什么是代码，但是你知道。

3436
01:34:22,050 --> 01:34:22,800
0,120 120,240 240,390 390,510 510,750
how to top my head

3437
01:34:22,800 --> 01:34:23,730
0,90 90,210 210,510 510,570 570,930
on my client what code

3438
01:34:23,760 --> 01:34:27,400
0,2850 2850,2880
is, {but,you,know}.
