1
00:00:05,360 --> 00:00:07,500
0,1560
Alright.|
好的。|

2
00:00:07,840 --> 00:00:10,720
0,810 1620,2040 2040,2550 2550,2820 2820,2880
{} The {} sort of
今天的基本主题是，

3
00:00:10,720 --> 00:00:12,700
0,480 480,1200 1200,1440 1440,1800 1800,1980
underlying topic for today is|
|

4
00:00:12,700 --> 00:00:15,580
0,570 1140,2100 2100,2370 2370,2670 2670,2880
really getting {multi-core -}, getting
获得良好的多核性能，

5
00:00:15,580 --> 00:00:18,080
0,510 510,780 780,990 990,2070
good {multi-core -} performance,|
|

6
00:00:18,200 --> 00:00:19,310
0,210 210,420 420,540 540,990 990,1110
{} getting good performance on
在多核硬件上获得良好的性能，

7
00:00:19,310 --> 00:00:23,000
0,270 270,480 480,1080 1560,2190 2970,3690
{multi-core -} hardware,| {} and
|这是一个非常有趣和令人着迷的话题，

8
00:00:23,030 --> 00:00:24,560
0,390 390,960
that's actually

9
00:00:24,590 --> 00:00:28,130
0,150 150,660 660,1470 1470,1980 2700,3540
{} very interesting and deep

10
00:00:28,250 --> 00:00:31,580
0,480 660,1320 1320,2010 2310,2640 2640,3330
{} fascinating topic,| with many
|有很多不同的有趣的方面。

11
00:00:31,580 --> 00:00:35,180
0,300 300,630 630,990 990,1620 3030,3600
many different interesting aspects {}.|
|

12
00:00:35,210 --> 00:00:37,040
0,660 660,1350 1350,1500 1500,1650 1650,1830
Today, {} we're just gonna
今天，我们会讨论一小部分，

13
00:00:37,040 --> 00:00:38,210
0,240 240,480 480,600 600,900 900,1170
bite off a fairly small

14
00:00:38,210 --> 00:00:40,010
0,660 690,1230 1290,1440 1440,1650 1650,1800
piece,| {} and that's how
|这就是如何在内核中获得良好的共享数据性能，

15
00:00:40,010 --> 00:00:43,100
0,120 120,900 1020,1680 1710,1980 1980,3090
to get a good performance

16
00:00:43,280 --> 00:00:45,350
0,870 870,1500 1500,1830 1830,1980 1980,2070
for shared data in the

17
00:00:45,350 --> 00:00:48,140
0,660 690,1230 1290,1710 1710,2280 2490,2790
kernel,| {} that's read much
|读的次数比写的次数多得多。

18
00:00:48,140 --> 00:00:49,340
0,210 210,510 510,630 630,840 840,1200
more often than it's written.|
|

19
00:00:49,750 --> 00:00:50,950
0,420 420,750 750,840 840,1080 1080,1200
{} And it turns out
有很多种具体的案例，

20
00:00:50,950 --> 00:00:51,970
0,150 150,360 360,510 510,570 570,1020
there's many kinds of specific

21
00:00:51,970 --> 00:00:55,900
0,810 1170,1710 1980,2130 2130,2880 3600,3930
cases,| {} in which different
|获得良好的多核性能的不同想法是有用的。

22
00:00:55,900 --> 00:00:57,460
0,600 600,720 720,1020 1020,1290 1290,1560
ideas for getting good {multi-core

23
00:00:57,460 --> 00:01:00,840
0,180 180,900 900,1020 1020,1650
-} performance are useful.|
|

24
00:01:02,070 --> 00:01:03,570
0,450 840,1050 1050,1170 1170,1380 1380,1500
{} We're gonna look at
我们今天要看的是 Linux 的 RCU ，

25
00:01:03,570 --> 00:01:04,500
0,240 240,390 390,690 690,780 780,930
today is {Linux's -} {RCU

26
00:01:04,500 --> 00:01:05,790
0,390 390,570 570,810 810,1020 1020,1290
-},| which has been very
|它是非常成功的，

27
00:01:05,790 --> 00:01:07,410
0,570 570,900 1050,1290 1290,1380 1380,1620
successful,| for sort of read
|对于读取繁重的内核数据。

28
00:01:07,410 --> 00:01:08,850
0,300 300,690 720,930 930,1140 1140,1440
heavy data, read heavy kernel

29
00:01:08,850 --> 00:01:09,800
0,360
data.|
|

30
00:01:10,880 --> 00:01:14,900
0,1350 1770,2850 2880,3210 3210,3420
The general sort of
这里的一般背景是，

31
00:01:14,900 --> 00:01:16,550
0,240 240,810 810,1140 1140,1350 1350,1650
{} background here is that,|
|

32
00:01:16,820 --> 00:01:18,620
0,210 210,300 300,720 750,1260 1260,1800
if you have modern machines|
如果你有现代机器，|

33
00:01:18,620 --> 00:01:20,390
0,360 360,840 840,990 990,1050 1050,1770
with four eight or sixteen
有 4 8 16 或 64 核或任意多核，

34
00:01:20,390 --> 00:01:22,430
0,150 150,1080 1080,1170 1170,1470 1470,2040
or 64 or however many

35
00:01:22,790 --> 00:01:24,230
0,540 540,750 750,840 840,1290 1290,1440
cores,| running in parallel and
|并行运行并共享内存，

36
00:01:24,230 --> 00:01:27,520
0,330 330,840 960,1650 1890,2790
sharing memory,| {} the
|内核实际上是一个并行进程，

37
00:01:27,970 --> 00:01:29,530
0,420 450,990 990,1200 1200,1500 1500,1560
the kernel is really a

38
00:01:29,530 --> 00:01:31,690
0,420 420,1320 1590,1920 1920,2130 2130,2160
parallel process, {} it's a

39
00:01:31,690 --> 00:01:34,180
0,420 420,960 1140,1500 1500,2010 2130,2490
parallel program,| {} and if
|如果你想要有好的性能，

40
00:01:34,180 --> 00:01:34,720
0,90 90,210 210,270 270,420 420,540
you're going to get good

41
00:01:34,720 --> 00:01:35,800
0,540 540,630 630,840 840,900 900,1080
performance,| you need to make
|你需要确保内核可以运行大量工作，

42
00:01:35,800 --> 00:01:36,670
0,150 150,300 300,390 390,720 720,870
sure that the kernel can

43
00:01:36,670 --> 00:01:37,660
0,390 390,510 510,720 720,810 810,990
run a lot of its

44
00:01:37,660 --> 00:01:38,980
0,330 330,480 480,630 630,780 780,1320
work| as much as possible
|在不同的内核上尽可能多地并行运行，

45
00:01:38,980 --> 00:01:40,630
0,90 90,630 630,780 780,1050 1050,1650
in parallel on different cores,|
|

46
00:01:40,630 --> 00:01:41,890
0,120 120,360 360,450 450,750 870,1260
in order to get that
为了得到更多，

47
00:01:41,890 --> 00:01:43,180
0,270 270,780 810,1080 1080,1170 1170,1290
much more,| if you can
|如果你在八个内核上并行运行内核，

48
00:01:43,180 --> 00:01:45,760
0,150 150,240 240,840 1260,1680 1800,2580
run the kernel {} parallel

49
00:01:45,760 --> 00:01:47,170
0,270 270,510 510,1140 1140,1320 1320,1410
on eight cores,| all of
|它们都在做有用的工作，

50
00:01:47,170 --> 00:01:48,220
0,240 240,450 450,750 750,960 960,1050
them doing useful work,| you
|你可以获得 8 倍的性能，

51
00:01:48,220 --> 00:01:49,810
0,90 90,360 540,930 930,1470 1470,1590
can get eight times the

52
00:01:49,810 --> 00:01:51,180
0,930
performance,|
|

53
00:01:51,180 --> 00:01:52,860
0,780 780,990 990,1260 1260,1530 1530,1680
than if the kernel could
与内核只运行一个内核相比。

54
00:01:52,860 --> 00:01:54,120
0,180 180,420 420,540 540,900 900,1260
only run a single core.|
|

55
00:01:54,810 --> 00:01:57,300
0,270 1290,1800 1800,2190 2190,2250 2250,2490
And, {} at a high
在高级别上，这显然是可能的，

56
00:01:57,300 --> 00:01:59,460
0,720 720,930 930,1590 1590,2040 2040,2160
level, this should clearly be

57
00:01:59,460 --> 00:02:01,650
0,660 1380,1800 1800,1860 1860,1980 1980,2190
possible,| if you have lots
|如果你的计算机上运行许多进程，

58
00:02:01,650 --> 00:02:02,880
0,90 90,240 240,300 300,900 900,1230
and lots of processes running

59
00:02:02,880 --> 00:02:05,010
0,120 120,270 270,870 1050,1470 1620,2130
on your computer,| the {},
|首先，进程在内核中运行，

60
00:02:05,040 --> 00:02:06,030
0,330 330,390 390,480 480,600 600,990
first of all, the processes

61
00:02:06,030 --> 00:02:07,380
0,180 210,480 480,660 780,1260 1260,1350
are running and executing in

62
00:02:07,380 --> 00:02:09,840
0,60 60,600 660,1230 1500,2280 2340,2460
the kernel,| {} then we
|我们就没什么好担心的了，

63
00:02:09,840 --> 00:02:10,710
0,120 120,300 300,540 540,630 630,870
have very little to worry

64
00:02:10,710 --> 00:02:11,820
0,360 390,570 570,840 840,930 930,1110
about,| they're likely to run
|它们很可能是并行运行的，

65
00:02:11,820 --> 00:02:13,470
0,120 120,720 810,1050 1050,1290 1290,1650
in parallel| {} without any
|而不需要内核做任何事情，

66
00:02:13,530 --> 00:02:15,090
0,390 390,630 630,900 930,1080 1080,1560
kernel having to do anything,|
|

67
00:02:15,600 --> 00:02:17,100
0,270 270,360 360,1080 1080,1440 1440,1500
if the processes if you
如果你正在运行多个应用程序，

68
00:02:17,100 --> 00:02:18,570
0,90 90,330 330,930 930,1290 1290,1470
have many applications running,| and
|而且它们很多时候都在进行系统调用，

69
00:02:18,570 --> 00:02:20,130
0,240 240,360 360,600 600,960 960,1560
they're all making system calls

70
00:02:20,160 --> 00:02:21,840
0,630 630,930 930,990 990,1080 1080,1680
a lot of the time,|
|

71
00:02:22,020 --> 00:02:24,090
0,930 930,1350 1350,1770 1770,1920 1920,2070
different system calls made by
不同进程进行的不同系统调用

72
00:02:24,090 --> 00:02:25,980
0,330 330,1170 1200,1470 1470,1710 1710,1890
different processes| just seem like
|似乎应该是独立的，

73
00:02:25,980 --> 00:02:27,180
0,120 120,240 240,300 300,420 420,1200
they ought to be independent,|
|

74
00:02:27,180 --> 00:02:27,870
0,180 180,360 360,420 420,600 600,690
and should be able to
而且应该能够在许多情况下继续进行，

75
00:02:27,870 --> 00:02:30,150
0,840 1110,1440 1440,1710 1710,2130 2130,2280
proceed in many cases,| though
|尽管不是所有情况，

76
00:02:30,150 --> 00:02:31,500
0,270 270,480 480,750 750,990 1050,1350
certainly not all,| but should
|但应该能够完全不受干扰地进行，

77
00:02:31,500 --> 00:02:32,820
0,60 60,270 270,360 360,690 690,1320
be able to proceed completely

78
00:02:32,820 --> 00:02:34,590
0,330 330,1140 1230,1500 1500,1620 1620,1770
without interference,| like if two
|比如，如果两个进程是 fork 的，

79
00:02:34,590 --> 00:02:36,200
0,540 540,660 660,1260
processes are forking,|
|

80
00:02:36,290 --> 00:02:38,330
0,690 870,1020 1020,1200 1200,1740 1740,2040
{} or two processes are
或者两个进程正在读取不同的管道，

81
00:02:38,360 --> 00:02:41,000
0,690 690,1110 1110,1740 1740,2130 2340,2640
reading different pipes| or you
|或者读或写不同的文件，

82
00:02:41,000 --> 00:02:42,440
0,210 210,510 510,630 630,1080 1080,1440
know reading or writing different

83
00:02:42,440 --> 00:02:45,050
0,960 990,1380 1410,1650 1650,2070 2070,2610
files,| {} there's no obvious
|它们没有明显的理由要相互干扰，

84
00:02:45,050 --> 00:02:46,520
0,330 330,630 630,810 810,1020 1020,1470
reason why they should interfere

85
00:02:46,520 --> 00:02:48,740
0,120 120,270 270,660 960,1650
with each other {},|
|

86
00:02:48,770 --> 00:02:49,670
0,330 330,480 480,720 720,780 780,900
why they shouldn't be able
为什么它们不能以总吞吐量的 n 倍并行执行。

87
00:02:49,670 --> 00:02:50,780
0,60 60,420 420,480 480,990 990,1110
to execute in parallel at

88
00:02:50,780 --> 00:02:52,490
0,300 300,810 810,900 900,1170 1170,1710
n times the total throughput.|
|

89
00:02:53,300 --> 00:02:54,200
0,120 120,210 210,690 690,810 810,900
But the problem is the
但是问题是，内核有很多共享资源，

90
00:02:54,200 --> 00:02:55,400
0,330 330,480 480,570 570,1050 1050,1200
kernel has a lot of

91
00:02:55,400 --> 00:02:58,500
0,720 720,2010
shared resources,|
|

92
00:02:58,850 --> 00:03:00,710
0,150 150,390 390,660 1260,1740 1740,1860
in order to, {} you
为了，出于其他好的原因，

93
00:03:00,710 --> 00:03:01,880
0,90 90,420 420,630 630,810 810,1170
know for other good reasons,|
|

94
00:03:01,880 --> 00:03:02,720
0,90 90,360 360,630 630,690 690,840
the kernel shares a lot
内核共享了大量资源，

95
00:03:02,720 --> 00:03:04,640
0,90 90,570 570,750 750,1560 1560,1920
of resources,| like memory and
|比如内存、 CPU 、磁盘缓存和 inode 缓存，

96
00:03:04,670 --> 00:03:06,860
0,1080 1080,1260 1320,1680 1680,2100 2100,2190
CPU and disk cache and

97
00:03:06,860 --> 00:03:08,390
0,360 360,570 570,1050 1170,1440 1440,1530
{inode -} cache,| and all
|所有这些在不同进程之间共享的内容，

98
00:03:08,390 --> 00:03:09,470
0,150 150,300 300,510 510,690 690,1080
this other stuff that's actually

99
00:03:09,530 --> 00:03:11,360
0,300 300,390 390,900 930,1500 1500,1830
under the hood shared between

100
00:03:11,360 --> 00:03:14,660
0,300 300,1200 2010,2460 2700,3060 3060,3300
different processes,| and that means
|这意味着即使两个处理器进行系统调用，

101
00:03:14,660 --> 00:03:16,190
0,180 180,420 420,600 600,780 780,1530
that even if two processors

102
00:03:16,220 --> 00:03:18,050
0,150 150,660 720,1170 1170,1680 1680,1830
are doing system calls,| two
|两个完全没有听说过对方的进程，

103
00:03:18,050 --> 00:03:19,220
0,450 450,540 540,630 630,960 960,1170
processes that have totally never

104
00:03:19,220 --> 00:03:20,000
0,210 210,300 300,450 450,690 690,780
heard of each other| and
|并且不会交互进行系统调用，

105
00:03:20,000 --> 00:03:21,140
0,150 150,360 360,420 420,960 960,1140
aren't trying to interact make

106
00:03:21,140 --> 00:03:22,700
0,300 300,780 870,1140 1140,1320 1320,1560
system calls,| if those system
|如果那些系统调用碰巧分配内存或使用磁盘缓存，

107
00:03:22,700 --> 00:03:24,380
0,210 210,690 690,780 780,1230 1230,1680
calls happen to allocate memory

108
00:03:24,380 --> 00:03:27,260
0,120 120,900 900,1200 1200,1860 2160,2880
or use disk cache,| more
|更多涉及调度决策，

109
00:03:27,260 --> 00:03:29,330
0,210 210,690 690,1470 1560,1860 1860,2070
involve scheduling decisions,| they may
|它们很可能最终都使用内核中的数据结构，

110
00:03:29,330 --> 00:03:31,970
0,330 360,750 750,1290 1350,1950 1950,2640
well end up both using

111
00:03:32,000 --> 00:03:32,900
0,570
{}

112
00:03:33,080 --> 00:03:34,580
0,480 480,930 930,990 990,1080 1080,1500
data structures in the kernel,|
|

113
00:03:34,580 --> 00:03:35,720
0,150 150,600 600,750 750,960 960,1140
and therefore we need some
因此，我们需要一些故事

114
00:03:35,720 --> 00:03:37,190
0,660 780,1020 1020,1170 1170,1260 1260,1470
story| for how they're both
|来说明它们应该如何使用相同的数据，

115
00:03:37,190 --> 00:03:38,000
0,300 300,360 360,510 510,570 570,810
supposed to use the same

116
00:03:38,000 --> 00:03:40,060
0,300 300,990 1020,1440
data| without {}
|不会相互干扰，

117
00:03:40,310 --> 00:03:42,110
0,300 300,840 870,1140 1140,1620 1620,1800
getting underfoot, without interfering with

118
00:03:42,110 --> 00:03:43,220
0,150 150,480 630,840 840,960 960,1110
each other,| and there's been
|多年来，我们付出了巨大的努力，

119
00:03:43,220 --> 00:03:44,750
0,480 480,840 840,990 990,1080 1080,1530
enormous effort over the years,|
|

120
00:03:44,750 --> 00:03:46,820
0,120 120,450 450,1350 1410,1890 1890,2070
and making kernels, making all
让所有这些案例和内核都运行得很快。

121
00:03:46,820 --> 00:03:48,050
0,180 180,540 540,630 630,1020 1020,1230
these cases and kernels run

122
00:03:48,050 --> 00:03:50,240
0,660 930,1680
fast {}.|
|

123
00:03:51,030 --> 00:03:52,530
0,330 330,570 570,780 780,870 870,1500
We've seen one of course
我们已经看到了一个以正确为导向的，也就是自旋锁，

124
00:03:52,530 --> 00:03:54,720
0,420 510,1050 1050,1320 1320,1920 1920,2190
that's oriented towards correctness namely

125
00:03:54,720 --> 00:03:57,360
0,300 300,900 1920,2190 2190,2430 2430,2640
spin locks,| spin locks are
|自旋锁是直截了当的，

126
00:03:57,600 --> 00:04:00,330
0,1080 1500,1980 1980,2220 2220,2490 2490,2730
straightforward,| as such things go
|因为这样的事情很容易推理，

127
00:04:00,330 --> 00:04:01,530
0,210 210,450 450,540 540,840 840,1200
and easy to reason about,|
|

128
00:04:01,530 --> 00:04:02,790
0,300 600,810 810,900 900,1230 1230,1260
but you know what {}
但你知道旋转锁的作用是阻止执行，

129
00:04:02,790 --> 00:04:04,800
0,270 270,510 510,900 900,1380 1410,2010
spin lock does is prevent

130
00:04:04,800 --> 00:04:06,780
0,660 660,840 840,1320 1320,1500 1500,1980
execution,| it prevents, its job
|它的作用是阻止并行性，

131
00:04:06,780 --> 00:04:09,540
0,120 120,240 240,720 720,1710 2610,2760
is to prevent parallelism,| in
|在两个进程之间可能存在问题的情况下，

132
00:04:09,540 --> 00:04:10,620
0,390 390,570 570,720 720,960 960,1080
cases where there might be

133
00:04:10,620 --> 00:04:12,240
0,60 60,450 450,780 780,930 930,1620
a problem between two processes,|
|

134
00:04:12,270 --> 00:04:13,260
0,150 150,420 420,630 630,690 690,990
so spin locks are just
所以自旋锁直接会降低性能，

135
00:04:13,260 --> 00:04:15,930
0,510 510,990 1050,1350 1350,1950 1950,2670
directly away to decrease performance,|
|

136
00:04:15,930 --> 00:04:17,190
0,180 180,360 360,480 480,780 1080,1260
that's all they do.| Of
这就是它们所做的。|当然，它们使得推理正确变得很容易，

137
00:04:17,190 --> 00:04:18,040
0,510
course,

138
00:04:18,080 --> 00:04:18,980
0,360 360,510 510,600 600,810 810,900
they make it easy to

139
00:04:18,980 --> 00:04:20,210
0,210 210,420 420,900 900,1020 1020,1230
reason about correctness,| but they
|但它们绝对会阻止并行执行，

140
00:04:20,420 --> 00:04:24,110
0,960 990,1350 1350,1800 1800,2400 2730,3690
absolutely prevent parallel execution,| and
|这并不总是那么可取的。

141
00:04:24,320 --> 00:04:25,640
0,90 90,240 240,750 930,1140 1140,1320
you know that's not always

142
00:04:25,640 --> 00:04:26,940
0,150 150,780
that desirable.|
|

143
00:04:29,010 --> 00:04:29,850
0,240 240,390 390,630 630,720 720,840
Okay, so again we're going
好的，我们把重点放在读取为主的数据上，

144
00:04:29,850 --> 00:04:33,420
0,90 90,840 2190,2940 2940,3210 3210,3570
to focus on read heavy

145
00:04:33,420 --> 00:04:34,440
0,240 240,390 390,480 480,930 930,1020
data,| on the case in
|在这种情况下，

146
00:04:34,440 --> 00:04:35,610
0,480 570,660 660,750 750,960 960,1170
which| {your -} data that's
|你的数据主要是读取的，而写入相对较少。

147
00:04:35,610 --> 00:04:37,800
0,330 330,840 840,1110 1140,1620 1620,2190
mostly read and relatively rarely

148
00:04:37,830 --> 00:04:39,510
0,450 750,990 990,1080 1080,1290 1290,1680
written.| And the main example
|主要使用的例子是链表，单链表，

149
00:04:39,510 --> 00:04:40,500
0,180 180,240 240,690 690,900 900,990
in {} use is a

150
00:04:40,500 --> 00:04:42,180
0,300 300,510 510,1020 1020,1290 1290,1680
linked list, {a,singly} linked list,|
|

151
00:04:42,360 --> 00:04:43,920
0,600 900,1200 1200,1320 1320,1440 1440,1560
{} and so you can
所以你可以想出一个标准的链表，

152
00:04:43,920 --> 00:04:45,450
0,270 270,600 600,990 1020,1410 1410,1530
think of {} just a

153
00:04:45,450 --> 00:04:47,610
0,510 510,960 960,1170 1380,1680 1680,2160
standard link to,| this diagram,|
|这张图，|

154
00:04:47,610 --> 00:04:49,290
0,300 600,900 900,1080 1080,1260 1290,1680
there's some sort of maybe
有某个全局变量，它是头指针，

155
00:04:49,710 --> 00:04:52,320
0,930 930,1620 1620,1830 1830,1890 1890,2610
global variable, that's a pointer,

156
00:04:52,590 --> 00:04:55,050
0,510 510,1080 1320,2100 2130,2400 2400,2460
head pointer,| {} just a
|有一个指针，有一堆列表元素，

157
00:04:55,050 --> 00:04:57,180
0,510 510,750 1050,1920 1920,1950 1950,2130
pointer and there's a bunch

158
00:04:57,180 --> 00:04:58,920
0,90 90,390 390,1260
of list elements,|
|

159
00:04:59,230 --> 00:05:00,880
0,360 360,630 690,990 990,1260 1260,1650
{} and each list element
每个列表元素都有一些数据，

160
00:05:00,880 --> 00:05:02,530
0,240 240,630 720,990 990,1320 1320,1650
has {} some data| and
|假设它是一个字符串，

161
00:05:02,530 --> 00:05:03,190
0,120 120,270 270,420 420,570 570,660
I'll just say it's a

162
00:05:03,190 --> 00:05:05,380
0,480 480,870 990,1290 1290,1620
string,| like you know
|比如， hello 这种数据在这个元素中，

163
00:05:06,040 --> 00:05:07,480
0,630 630,870 870,990 990,1170 1170,1440
"hello" is this sort of

164
00:05:07,510 --> 00:05:09,460
0,420 420,540 540,720 720,1260 1470,1950
data in this element {},|
|

165
00:05:09,520 --> 00:05:10,570
0,150 150,300 300,660 660,900 900,1050
and each element also has
并且每个元素还有下一个指针，

166
00:05:10,570 --> 00:05:12,100
0,60 60,450 450,1020
a next pointer,|
|

167
00:05:12,250 --> 00:05:13,820
0,600
that
指向下一个列表元素，

168
00:05:14,020 --> 00:05:16,180
0,690 720,870 870,1140 1140,1500
points the next {list,element},|
|

169
00:05:16,740 --> 00:05:18,180
0,840

170
00:05:19,270 --> 00:05:20,650
0,180 180,390 390,780 780,1080 1080,1380
and then finally there's a
最后有一个指向零的指针来标记结束，

171
00:05:21,010 --> 00:05:23,620
0,390 390,570 570,930 930,1440 2310,2610
pointer that points to zero

172
00:05:23,620 --> 00:05:25,520
0,60 60,300 300,420 420,930
to mark the end,|
|

173
00:05:25,580 --> 00:05:27,720
0,510 540,930 930,1560
{} very straightforward.|
非常直截了当。|

174
00:05:28,550 --> 00:05:29,630
0,330 330,600 600,720 720,840 840,1080
And again we're gonna assume
我们再次假设，

175
00:05:29,630 --> 00:05:30,980
0,120 120,600 600,1020 1020,1110 1110,1350
that,| most uses of this
|我们感兴趣的这个列表的大部分只是读取，

176
00:05:30,980 --> 00:05:31,910
0,240 240,330 330,390 390,780 780,930
list that we're interested in

177
00:05:31,910 --> 00:05:33,710
0,210 210,420 420,1500 1560,1710 1710,1800
are just reads,| you know
|内核线程或其他什么东西使用这个列表，

178
00:05:33,710 --> 00:05:34,620
0,330
the

179
00:05:34,680 --> 00:05:36,330
0,480 570,1020 1020,1350 1350,1380 1380,1650
the kernel thread or whatever

180
00:05:36,330 --> 00:05:37,230
0,90 90,210 210,420 420,720 720,900
it is that's using this

181
00:05:37,230 --> 00:05:38,340
0,240 300,510 510,660 660,1020 1020,1110
list,| is just scanning the
|只是在扫描列表，寻找一些东西，

182
00:05:38,340 --> 00:05:39,420
0,240 240,480 480,570 570,840 840,1080
list looking for something,| not
|而不是试着修改列表。

183
00:05:39,420 --> 00:05:40,680
0,180 180,240 240,660 660,780 780,1260
trying to modify the list.|
|

184
00:05:41,380 --> 00:05:44,050
0,420 450,1200 1200,1740 1740,2160 2520,2670
And occasional writers though,| you
偶尔也会有写者，|如果没有写者的话，

185
00:05:44,050 --> 00:05:45,790
0,210 330,810 1320,1500 1500,1650 1650,1740
know all if there were

186
00:05:45,790 --> 00:05:48,160
0,420 420,1140 1140,1620 1890,2160 2160,2370
zero writers ever,| we wouldn't
|我们完全不需要担心这件事，

187
00:05:48,160 --> 00:05:48,970
0,120 120,300 330,540 540,630 630,810
need to have to worry

188
00:05:48,970 --> 00:05:49,930
0,180 180,330 330,420 420,720 720,960
about this at all,| because
|因为那将是一个完全静态的永远不会改变的列表，

189
00:05:49,930 --> 00:05:51,700
0,120 120,270 270,510 900,1320 1320,1770
it'll be a completely static

190
00:05:51,700 --> 00:05:53,140
0,300 300,480 480,1200 1200,1290 1290,1440
list, never changes,| we can
|我们可以自由读取，

191
00:05:53,140 --> 00:05:54,580
0,150 150,270 270,720 960,1350 1350,1440
read it freely,| but we're
|但是我们会想象一下，

192
00:05:54,580 --> 00:05:55,600
0,120 120,180 180,630 630,780 780,1020
going to imagine that,| every
|每隔一段时间，

193
00:05:55,600 --> 00:05:56,410
0,210 210,270 270,330 330,570 570,810
once in a while,| somebody
|有人想要写入列表。

194
00:05:56,410 --> 00:05:57,250
0,210 210,450 450,540 540,720 720,840
comes along and wants to

195
00:05:57,250 --> 00:05:58,150
0,240 240,330 330,630 630,720 720,900
write the list.| So that
|这可能意味着，

196
00:05:58,150 --> 00:05:59,860
0,150 150,390 390,570 1230,1470 1470,1710
may mean that,| some other
|某个其他线程想要修改保存在列表元素中的数据，

197
00:05:59,860 --> 00:06:02,380
0,360 360,630 630,750 750,1800 2310,2520
thread wants to change the

198
00:06:02,380 --> 00:06:03,280
0,270 270,540 540,600 600,660 660,900
data stored in a list

199
00:06:03,280 --> 00:06:04,990
0,450 450,510 510,930 990,1590 1590,1710
element,| or maybe delete an
|或者可能删除一个元素，

200
00:06:04,990 --> 00:06:07,120
0,570 600,900 900,1110 1110,2040 2040,2130
element,| or maybe insert a
|或者可能在某个地方插入一个新元素。

201
00:06:07,120 --> 00:06:08,580
0,210 210,540 540,1050
new element somewhere.|
|

202
00:06:09,030 --> 00:06:10,290
0,210 210,420 420,600 600,930 930,1260
So even though, it's we're
所以即使这样，我们的目标是读取为主，

203
00:06:10,470 --> 00:06:13,110
0,330 330,480 810,1050 1050,1770 2040,2640
aiming at a mostly reads,|
|

204
00:06:13,110 --> 00:06:13,740
0,90 90,210 210,330 330,450 450,630
we do have to worry
我们也要担心写入的问题，

205
00:06:13,740 --> 00:06:14,850
0,240 240,810 810,900 900,1050 1050,1110
about writes,| we need to
|我们需要在面对写入时确保读取的安全。

206
00:06:14,850 --> 00:06:15,900
0,150 150,240 240,510 510,960 960,1050
make the reads safe in

207
00:06:15,900 --> 00:06:17,460
0,90 90,330 330,390 390,1020
the face of writes.|
|

208
00:06:18,080 --> 00:06:19,970
0,540 1200,1410 1410,1620 1620,1710 1710,1890
{} Of course, in {xv6
当然，在 xv6 中，

209
00:06:19,970 --> 00:06:20,750
0,90 90,360 360,480 480,660 660,780
- -},| we just have
|我们只有一个锁来保护这个列表。

210
00:06:20,750 --> 00:06:22,760
0,60 60,630 930,1350 1350,1560 1560,2010
a lock protecting this list,|
|

211
00:06:22,790 --> 00:06:23,960
0,90 90,240 240,840 870,1050 1050,1170
and a reader, that {you,know}
读者，不仅是写者，

212
00:06:23,960 --> 00:06:25,130
0,210 210,420 420,600 600,1050 1050,1170
not only would writers,| in
|在 xv6 中，不仅写者必须获取锁，

213
00:06:25,130 --> 00:06:25,970
0,150 150,270 270,540 540,690 690,840
{xv6 - -}, not only

214
00:06:25,970 --> 00:06:27,080
0,150 150,510 510,660 660,780 780,1110
would writers have to acquire

215
00:06:27,080 --> 00:06:28,340
0,120 120,420 450,780 780,1170 1170,1260
the lock,| but readers would
|而且写者也必须获取锁，

216
00:06:28,340 --> 00:06:29,330
0,180 180,270 270,600 600,720 720,990
have to acquire the lock

217
00:06:29,330 --> 00:06:30,920
0,360 600,1200 1230,1410 1410,1530 1530,1590
too,| because we're going to
|因为我们要排除这种情况，

218
00:06:30,920 --> 00:06:32,150
0,270 270,450 450,540 540,1170 1170,1230
rule out the situation,| in
|在我们读取时，有人在修改列表，

219
00:06:32,150 --> 00:06:34,430
0,390 420,930 930,1110 1110,1680 1830,2280
which while we're reading somebody's

220
00:06:34,430 --> 00:06:35,750
0,270 270,780 780,870 870,1170 1170,1320
actually modifying the list,| because
|因为这可能会使读者看到部分更新的值，

221
00:06:35,750 --> 00:06:37,040
0,150 150,270 270,960
that could cause

222
00:06:37,130 --> 00:06:39,590
0,480 510,750 750,930 1740,2160 2160,2460
{} sort of the reader

223
00:06:39,590 --> 00:06:41,270
0,120 120,570 570,690 690,1170 1170,1680
to see {} half updated

224
00:06:41,270 --> 00:06:43,100
0,540 540,720 720,1140 1140,1350 1350,1830
value| or follow an invalid
|或者跟随无效的指针或其他什么。

225
00:06:43,100 --> 00:06:44,630
0,360 360,420 420,810 1020,1230 1230,1530
pointer or something.| So {in,xv6
|所以，在 xv6 中，我们有锁，

226
00:06:44,630 --> 00:06:46,940
0,330 330,1020 1200,1770
-} {we,have,locks} {},|
|

227
00:06:48,500 --> 00:06:49,940
0,480 810,1050 1050,1200 1200,1380 1380,1440
but, {} that has a
但是，这有一个缺陷，

228
00:06:49,940 --> 00:06:51,350
0,420 420,720 750,930 930,1020 1020,1410
defect,| that if the common
|如果常见的情况下没有写者，

229
00:06:51,350 --> 00:06:53,240
0,450 450,630 630,780 780,1470 1470,1890
cases there's no writers,| it
|这意味着每次有人来读取时，

230
00:06:53,240 --> 00:06:55,550
0,360 360,660 1530,1890 1890,2070 2070,2310
means that every time somebody

231
00:06:55,550 --> 00:06:58,040
0,210 210,420 420,540 540,1320 2250,2490
comes along and reads,| in
|在 xv6 中，它们抢占独占的， xv6 自旋锁是独占的，

232
00:06:58,040 --> 00:06:58,880
0,150 150,270 270,480 480,600 600,840
{xv6 - -}, they grab

233
00:06:58,880 --> 00:07:00,860
0,60 60,1290 1320,1560 1560,1800 1800,1980
an exclusive, like {xv6 -}

234
00:07:00,860 --> 00:07:02,960
0,210 210,420 420,510 510,1320 1500,2100
spin locks are exclusive,| even
|即使你有两个读者，

235
00:07:03,020 --> 00:07:03,950
0,210 210,330 330,420 420,690 690,930
if you have just two

236
00:07:03,950 --> 00:07:05,390
0,660 660,900 900,1170 1170,1260 1260,1440
readers,| only one of them
|一次也只有一个可以继续，

237
00:07:05,390 --> 00:07:06,620
0,180 180,540 540,660 660,720 720,1230
can proceed at a time,|
|

238
00:07:07,130 --> 00:07:09,620
0,300 300,660 660,930 930,1740 1800,2490
so what we'd like, {}|
所以我们想要的，

239
00:07:10,130 --> 00:07:10,970
0,270 270,330 330,600 600,750 750,840
sort of one way to
某种程度上是改善这种情况的一种方式，

240
00:07:10,970 --> 00:07:12,890
0,390 390,540 540,1290 1380,1770 1770,1920
improve this situation,| would be
|就是有一种新的锁，

241
00:07:12,890 --> 00:07:14,120
0,90 90,360 360,750 750,930 930,1230
to have a new kind

242
00:07:14,120 --> 00:07:16,610
0,120 120,570 600,870 930,1920 1920,2490
of lock,| that allows multiple
|允许多个读者，但只允许一个写者。

243
00:07:16,610 --> 00:07:18,380
0,690 690,840 840,1050 1050,1350 1350,1770
readers, but only one writer.|
|

244
00:07:19,470 --> 00:07:21,090
0,360 570,810 810,930 930,1410 1410,1620
{} So I explore those
所以我接下来要探索这些，

245
00:07:21,090 --> 00:07:23,640
0,450 1020,1590 2010,2220 2220,2400 2400,2550
next,| actually both because they're
|因为它们都很有趣，

246
00:07:23,640 --> 00:07:26,460
0,630 840,1440 1500,2190 2190,2610 2640,2820
interesting,| {} because they they
|因为它们帮助激发了对 RCU 的需求，

247
00:07:26,460 --> 00:07:28,800
0,240 240,990 1230,1710 1740,2160 2160,2340
help motivate the need for

248
00:07:28,800 --> 00:07:30,270
0,150 150,720 840,1050 1050,1260 1260,1470
{RCU -},| we'll talk about
|我们一会儿再谈。

249
00:07:30,270 --> 00:07:31,760
0,270 300,450 450,630 630,1020
in a little while.|
|

250
00:07:32,030 --> 00:07:33,590
0,330 720,960 960,1140 1140,1290 1290,1560
{} So there's, this notion
所以这个概念叫做读写锁，

251
00:07:33,590 --> 00:07:35,600
0,240 240,450 450,690 690,1530
called read write locks,|
|

252
00:07:36,920 --> 00:07:39,260
0,510 900,1350 1650,1770 1770,2070 2070,2340
{} and the interface is
它的接口比我们使用的自旋锁的要复杂一些，

253
00:07:39,260 --> 00:07:40,520
0,60 60,210 210,390 390,1080 1080,1260
a little more complicated than

254
00:07:40,520 --> 00:07:41,690
0,120 120,480 480,750 750,870 870,1170
the spin locks we're used

255
00:07:41,690 --> 00:07:42,950
0,270 450,570 570,690 690,750 750,1260
to,| we're going to imagine
|我们假设有一组调用，

256
00:07:42,950 --> 00:07:43,970
0,300 330,570 570,780 780,960 960,1020
that there's one set of

257
00:07:43,970 --> 00:07:45,350
0,360 360,720 900,1050 1050,1290 1290,1380
call,| that you call if
|如果你只想读取什么，

258
00:07:45,350 --> 00:07:46,220
0,150 150,390 390,540 540,600 600,870
you just want to read

259
00:07:46,220 --> 00:07:48,050
0,600 660,930 930,990 990,1170 1170,1830
something,| so we're gonna imagine
|所以我们将想象有一个 r_lock 调用，并传递一个锁，

260
00:07:48,050 --> 00:07:49,840
0,360 360,720 720,1290
{r_lock -} call

261
00:07:50,210 --> 00:07:51,960
0,420 420,810 810,1080
and pass {}

262
00:07:51,960 --> 00:07:54,090
0,150 150,900 1140,1710 1770,1920 1920,2130
a lock| {} and then
|然后还有一个 r_unlock 调用，

263
00:07:54,090 --> 00:07:55,650
0,270 270,360 360,690 690,1080 1080,1560
also an {r_unlock -} call,|
|

264
00:07:57,320 --> 00:07:58,620
0,600

265
00:07:59,300 --> 00:08:00,440
0,240 240,510 510,720 720,1050 1050,1140
and readers call these.| And
读者调用这些。|然后有一个 w_lock 调用和 w_unlock 调用，

266
00:08:00,440 --> 00:08:02,000
0,150 150,330 330,420 420,840 1140,1560
then there's a {w_lock -}

267
00:08:02,000 --> 00:08:04,250
0,570 570,900 900,1170 1170,1590 1590,2250
call {and,a} {w_unlock -} call,|
|

268
00:08:04,640 --> 00:08:07,400
0,600 810,1170 1170,1740 1740,2220
and the semantics are
它的语义是，

269
00:08:07,900 --> 00:08:10,150
0,600 840,1140 1140,1320 1320,1470 1500,2250
that| {} you can either
|你可以让多个读者获取用于读取的锁，

270
00:08:10,480 --> 00:08:14,020
0,330 330,1290 1290,2460 2760,3420 3420,3540
have multiple readers acquire the

271
00:08:14,020 --> 00:08:16,030
0,330 330,480 480,1080 1470,1920 1920,2010
lock for reading,| so we
|这样我们就会得到并行性，

272
00:08:16,030 --> 00:08:17,920
0,300 360,630 630,870 870,1050 1050,1890
do then would get parallelism,|
|

273
00:08:17,950 --> 00:08:20,320
0,900 1050,1380 1380,1500 1500,1740 1740,2370
or you can have exactly
或者你可以有一个写者获取锁，

274
00:08:20,320 --> 00:08:21,800
0,360 360,1080
one writer

275
00:08:21,860 --> 00:08:23,540
0,360 360,600 600,1050 1050,1170 1170,1680
{} have acquired the lock,|
|

276
00:08:23,870 --> 00:08:24,590
0,240 240,330 330,420 420,600 600,720
but you can never have
但你永远不能混在一起，

277
00:08:24,590 --> 00:08:25,670
0,90 90,570 570,690 690,780 780,1080
a mix,| you can never
|你永远不能，

278
00:08:25,670 --> 00:08:28,010
0,660 660,960 1260,1830 1830,2160 2160,2340
{have,be,in},| the locks rule out
|锁排除了这种可能，

279
00:08:28,010 --> 00:08:29,480
0,90 90,480 510,870 900,1260 1260,1470
the possible,| read, read write
|读写锁排除了这种可能，

280
00:08:29,480 --> 00:08:31,100
0,420 450,810 810,930 930,1020 1020,1620
locks rule out the possibility|
|

281
00:08:31,100 --> 00:08:32,720
0,180 480,840 840,1140 1140,1530 1530,1620
of somebody having locked the
有人锁定写入锁并同时进行读取，

282
00:08:32,720 --> 00:08:34,070
0,240 240,390 390,930 930,1080 1080,1350
lock for writing and also

283
00:08:34,070 --> 00:08:35,000
0,270 270,360 360,420 420,660 660,930
reading at the same time,|
|

284
00:08:35,180 --> 00:08:36,890
0,210 210,420 420,660 660,1140 1440,1710
you're either one writer or
要么是一个写者，要么是多个读者，没有别的情况。

285
00:08:36,890 --> 00:08:38,630
0,240 240,360 360,1140 1380,1500 1500,1740
lots of readers, but nothing

286
00:08:38,630 --> 00:08:40,440
0,450
else.|
|

287
00:08:41,030 --> 00:08:42,620
0,270 270,510 510,930
So that's the.|
所以这就是。|

288
00:08:42,620 --> 00:08:44,600
0,180 180,750 870,1500
A question.| Yes.|
有一个问题。|好的。|

289
00:08:44,820 --> 00:08:46,260
0,240 240,480 480,660 660,1080 1080,1440
{} This may be an
这可能是关于实现细节，

290
00:08:46,260 --> 00:08:48,720
0,810 810,1440 1710,1950 1950,2190 2190,2460
implementation detail,| but what kind
|但是这个锁方案设置了什么样的机制，

291
00:08:48,720 --> 00:08:50,760
0,120 120,900 900,1140 1140,1590 1620,2040
of mechanisms does this locking

292
00:08:50,760 --> 00:08:52,110
0,360 360,540 540,720 720,1200 1200,1350
scheme put in place| to
|来防止当它们持有读锁时，有人写入。

293
00:08:52,110 --> 00:08:53,400
0,750
prevent

294
00:08:53,550 --> 00:08:55,800
0,540 570,1140 1140,1770 1770,2070 2070,2250
{} someone writing, while they

295
00:08:55,800 --> 00:08:57,600
0,390 390,540 540,780 780,1320 1350,1800
hold a read lock.| Nothing,
|没什么，就像 xv6 锁一样。

296
00:08:57,600 --> 00:08:58,650
0,240 240,360 360,600 600,750 750,1050
nothing, it's just like {xv6

297
00:08:58,650 --> 00:09:01,380
0,240 240,810 870,2220
-} locks, completely.|
|

298
00:09:01,380 --> 00:09:02,520
0,180 180,330 330,510 510,810 810,1140
We're talking about kernel code
我们谈论内核代码是由值得信赖的负责任的开发人员编写的，

299
00:09:02,520 --> 00:09:04,340
0,180 180,360 360,1260
written by trusted

300
00:09:04,370 --> 00:09:06,560
0,570 570,1380 1380,1530 1530,1770 1770,2190
responsible developers| and so just
|所以，就像 xv6 中的自旋锁一样，

301
00:09:06,560 --> 00:09:07,520
0,180 180,420 420,690 690,780 780,960
like spin locks in {xv6

302
00:09:07,520 --> 00:09:09,080
0,150 150,570 840,1110 1110,1200 1200,1560
- -},| if the code
|如果代码使用锁不正确，那么它就是不正确的，没有。

303
00:09:09,080 --> 00:09:11,280
0,120 120,390 390,690 690,1650
is using locks incorrect,

304
00:09:11,370 --> 00:09:13,620
0,180 180,840 1260,1470 1470,1770 1770,2250
it's incorrect, there's no.| Okay.|
|好的。|

305
00:09:15,450 --> 00:09:16,500
0,180 180,330 330,450 450,570 570,1050
And this is the way
这就是典型内核的编写方式，

306
00:09:16,650 --> 00:09:17,730
0,150 150,240 240,630 630,1020 1020,1080
you know typical kernels are

307
00:09:17,730 --> 00:09:18,640
0,360
written,|
|

308
00:09:18,840 --> 00:09:19,980
0,360 600,720 720,900 900,1050 1050,1140
{} you just have to
你需要假设，

309
00:09:19,980 --> 00:09:21,220
0,450 450,630
assume that,|
|

310
00:09:22,210 --> 00:09:23,290
0,270 270,630 630,690 690,960 960,1080
people developing the kernel are
开发内核的人遵循他们自己的规则。

311
00:09:23,290 --> 00:09:25,040
0,360 360,480 480,630 630,1230
following their own rules.|
|

312
00:09:26,190 --> 00:09:27,510
0,450 600,870 870,1020 1020,1200 1200,1320
Okay.| Okay, and again the
好的。|好的，再说一遍我们关心的原因是，

313
00:09:27,510 --> 00:09:28,620
0,210 210,300 300,420 420,960 960,1110
reason why we care is

314
00:09:28,620 --> 00:09:30,090
0,330 930,1140 1140,1230 1230,1380 1380,1470
that,| if we have a
|如果我们有一个读取为主的数据结构，

315
00:09:30,090 --> 00:09:32,790
0,600 600,930 930,1740 1800,2250 2250,2700
mostly read mostly data structure,|
|

316
00:09:32,790 --> 00:09:34,740
0,180 180,390 390,480 480,810 1440,1950
we'd love to have multiple
我们希望有多个读者能够同时使用它，

317
00:09:34,740 --> 00:09:35,640
0,360 360,480 480,630 630,720 720,900
readers be able to use

318
00:09:35,640 --> 00:09:36,840
0,120 120,210 210,300 300,750 750,1200
it at the same time|
|

319
00:09:36,840 --> 00:09:37,800
0,180 180,480
to get
通过拥有多个内核获得真正的加速。

320
00:09:37,800 --> 00:09:41,460
0,870 900,1770 1770,2100 2100,2670 3000,3660
genuine speedup from having multiple

321
00:09:41,460 --> 00:09:42,760
0,780
cores.|
|

322
00:09:44,230 --> 00:09:46,740
0,420 450,870 1320,1920
Alright, so, {}
好的，如果这里没有问题，

323
00:09:46,740 --> 00:09:47,580
0,180 180,300 300,360 360,480 480,840
if there were no problem

324
00:09:47,580 --> 00:09:48,330
0,270 270,420 420,540 540,690 690,750
here,| this would just be
|这就是答案，

325
00:09:48,330 --> 00:09:49,440
0,150 150,480 480,630 630,990 990,1110
the answer,| we wouldn't have
|我们不需要读今天的论文，

326
00:09:49,440 --> 00:09:51,180
0,420 420,540 540,810 810,1200 1200,1740
needed to read today's paper,|
|

327
00:09:51,900 --> 00:09:53,370
0,390 420,630 630,930 930,1200 1200,1470
but it turns out that,|
但事实证明，|

328
00:09:53,430 --> 00:09:54,180
0,210 210,330 330,480 480,660 660,750
if you dig into the
如果深入查看发生的细节，

329
00:09:54,180 --> 00:09:55,980
0,360 360,420 420,540 540,810 810,1800
details of what actually happens,|
|

330
00:09:56,640 --> 00:09:57,750
0,360 360,450 450,690 690,900 900,1110
when you use read write
当你使用读写锁时，

331
00:09:57,750 --> 00:09:59,940
0,780 810,1410 1470,1740
locks,| especially for
|特别是对于大量读取的数据，

332
00:09:59,940 --> 00:10:01,020
0,270 270,480 480,750 750,990 990,1080
data that's actually read a

333
00:10:01,020 --> 00:10:03,390
0,510 690,1290 1320,1500 1500,1590 1590,2370
lot,| {} there's some problems.|
|这里有一些问题。|

334
00:10:03,600 --> 00:10:05,490
0,420 450,600 600,840 840,1290 1650,1890
And in order to see
为了看看发生了什么，

335
00:10:05,490 --> 00:10:06,330
0,150 150,360 360,510 510,600 600,840
what's going on,| we actually
|我们必须看一下实现。

336
00:10:06,330 --> 00:10:06,810
0,90 90,150 150,300 300,360 360,480
have to look at the

337
00:10:06,810 --> 00:10:08,540
0,750
implementation.|
|

338
00:10:08,660 --> 00:10:11,120
0,390 630,1200 1200,1620 1620,2100 2100,2460
{} Linux indeed has a
Linux 有一个读写锁实现，

339
00:10:11,960 --> 00:10:13,580
0,270 270,510 510,1050
{read/write -} lock

340
00:10:13,580 --> 00:10:16,340
0,690 1410,2280 2280,2400 2400,2580 2580,2760
{} implementation in it,| and
|这是 Linux 代码的一种简化版本。

341
00:10:16,340 --> 00:10:19,400
0,210 210,630 1200,2010 2160,2700 2700,3060
this is a kind of

342
00:10:19,910 --> 00:10:22,700
0,870 870,1380 1380,1500 1500,1890 2100,2790
simplified version of the Linux

343
00:10:22,700 --> 00:10:23,760
0,570
code.|
|

344
00:10:23,910 --> 00:10:24,810
0,120 120,480 480,630 630,780 780,900
The idea is that we
这里的想法是有一个 rwlock 结构体，

345
00:10:24,810 --> 00:10:26,010
0,120 120,180 180,720 720,870 870,1200
have a struct {rwlock -

346
00:10:26,010 --> 00:10:27,840
0,510 690,1020 1020,1140 1140,1440 1470,1830
-},| which is like struct
|就像 xv6 中的 lock 结构体，

347
00:10:27,840 --> 00:10:29,160
0,270 270,570 600,810 810,930 930,1320
lock in {xv6 - -},|
|

348
00:10:29,160 --> 00:10:30,210
0,300 300,360 360,450 450,930 930,1050
and it has {a,count} in
而且它里面有一个计数，

349
00:10:30,210 --> 00:10:30,920
0,150
it,|
|

350
00:10:31,420 --> 00:10:32,950
0,660 720,1080 1080,1140 1140,1440 1440,1530
{} if the count is
如果计数为 0 ，

351
00:10:32,950 --> 00:10:34,420
0,600 660,1020 1020,1230 1230,1350 1350,1470
0,| that means that the
|这意味着锁没有被任何人以任何形式持有，

352
00:10:34,420 --> 00:10:35,380
0,270 270,450 450,630 630,810 810,960
lock is not held by

353
00:10:35,380 --> 00:10:37,090
0,600 600,780 780,960 960,1440 1530,1710
anybody in any form,| if
|如果计数为 -1 ，

354
00:10:37,090 --> 00:10:38,050
0,60 60,330 330,420 420,720 720,960
the count is {-1 -},|
|

355
00:10:38,050 --> 00:10:39,310
0,180 180,750 750,870 870,960 960,1260
that means that a writer
则表示写入者已加锁，

356
00:10:39,310 --> 00:10:41,500
0,210 210,300 300,840 1710,2100 2100,2190
has it locked,| and if
|如果计数大于 0 ，

357
00:10:41,500 --> 00:10:42,280
0,60 60,270 270,360 360,660 660,780
the count is greater than

358
00:10:42,280 --> 00:10:43,930
0,300 300,480 480,750 750,990 1020,1650
0,| that means that n
|这意味着 n 个读取者已加锁，

359
00:10:44,140 --> 00:10:45,910
0,960 960,1140 1140,1230 1230,1680 1680,1770
readers have it locked,| and
|我们需要跟踪它们，

360
00:10:45,910 --> 00:10:46,720
0,60 60,210 210,270 270,480 480,810
we need to keep track

361
00:10:46,720 --> 00:10:47,860
0,60 60,180 180,570 750,1020 1020,1140
of them,| because we can
|因为我们只能让一个写入者进来，

362
00:10:47,860 --> 00:10:48,790
0,210 210,330 330,420 420,780 780,930
only let a writer in,|
|

363
00:10:48,790 --> 00:10:49,810
0,120 120,240 240,450 450,540 540,1020
if the number of readers
如果读取者数量降到 0 的话。

364
00:10:49,810 --> 00:10:51,240
0,510 510,600 600,1050
descends to 0.|
|

365
00:10:51,920 --> 00:10:53,340
0,570

366
00:10:53,440 --> 00:10:54,500
0,600

367
00:10:58,870 --> 00:10:59,980
0,270 270,390 390,690 690,870 870,1110
Okay, so somebody asked about
好的，有人问了关于添加的问题。

368
00:10:59,980 --> 00:11:01,420
0,360 360,960
{addings -}.|
|

369
00:11:02,910 --> 00:11:04,020
0,570
No,
不，我不确定聊天里有问题，

370
00:11:04,500 --> 00:11:05,130
0,180 180,330 330,450 450,510 510,630
I'm not sure if there's

371
00:11:05,130 --> 00:11:06,120
0,60 60,390 390,450 450,540 540,990
a question in the chat,|
|

372
00:11:06,660 --> 00:11:09,420
0,360 360,510 510,840 1440,2160
interrupt me {if,there,is} {}.|
如果有的话，请打断我。|

373
00:11:12,020 --> 00:11:15,320
0,240 240,1290 1320,2010 2250,2550 2550,3300
The read lock {} function,
读锁定函数，它处于循环中，

374
00:11:18,480 --> 00:11:19,410
0,270 270,450 450,570 570,630 630,930
that's sit in a loop,|
|

375
00:11:19,410 --> 00:11:20,700
0,570 600,720 720,900 900,960 960,1290
because if there's a writer,|
因为如果有写者，|

376
00:11:20,700 --> 00:11:21,240
0,90 90,180 180,270 270,450 450,540
we have to wait for
我们必须等待写者，

377
00:11:21,240 --> 00:11:23,180
0,60 60,480
the writer,|
|

378
00:11:23,900 --> 00:11:25,320
0,210

379
00:11:25,660 --> 00:11:31,680
0,210 210,780
it looks,|
它看起来，|

380
00:11:31,680 --> 00:11:32,520
0,120 120,390 390,450 450,780 780,840
it grabs a copy of
它获得了当前 n 的值的副本，

381
00:11:32,520 --> 00:11:34,420
0,60 60,390 390,630 630,1290
the current n value,|
|

382
00:11:34,610 --> 00:11:35,900
0,450 510,660 660,840 840,1080 1080,1290
{} if this {less,than} 0,
如果该值小于 0 ，则表示有一个写者，

383
00:11:35,900 --> 00:11:36,920
0,120 120,270 270,450 450,510 510,1020
that means there's a writer,|
|

384
00:11:36,920 --> 00:11:37,700
0,150 150,240 240,570 570,690 690,780
and we just need to
我们只需要继续我们的循环，继续旋转，

385
00:11:37,700 --> 00:11:38,720
0,360 360,450 450,690 690,840 840,1020
continue our loop, {} gonna

386
00:11:38,720 --> 00:11:40,130
0,630 630,960 960,1050 1050,1140 1140,1410
spin,| waiting for the writer
|等着写者离开，

387
00:11:40,130 --> 00:11:42,230
0,60 60,210 210,750 1470,2010 2010,2100
to go away,| otherwise we
|否则，我们想要增加这个值，

388
00:11:42,230 --> 00:11:43,740
0,150 150,210 210,930
want to increment

389
00:11:43,740 --> 00:11:45,020
0,690
{}

390
00:11:45,020 --> 00:11:47,690
0,240 240,810 1740,2160 2190,2460 2460,2670
that value,| but we only
|但是我们只想增加它，

391
00:11:47,690 --> 00:11:48,920
0,150 150,210 210,720 720,990 1020,1230
want to increment it,| if
|如果它仍然大于或等于 0 ，

392
00:11:48,920 --> 00:11:50,660
0,300 300,1170 1170,1530 1530,1650 1650,1740
it's still greater than or

393
00:11:50,660 --> 00:11:51,740
0,240 240,330 330,810 810,990 990,1080
equal to 0,| so we
|所以我们不能，有很多事情我们不能做，

394
00:11:51,740 --> 00:11:53,540
0,630 1020,1290 1290,1470 1470,1680 1680,1800
can't, there's many things we

395
00:11:53,540 --> 00:11:54,440
0,300 300,480 480,570 570,810 810,900
can't do,| we can't, for
|我们不能简单地加 1 ，

396
00:11:54,440 --> 00:11:55,880
0,360 360,630 630,930 930,1320 1320,1440
example, just add one,| with
|使用标准的 n 等于 n 加 1 ，

397
00:11:55,880 --> 00:11:57,380
0,720
standard

398
00:11:57,380 --> 00:11:58,790
0,240 240,510 510,690 690,930 930,1410
n equals n plus one,|
|

399
00:11:59,360 --> 00:12:00,800
0,540 540,630 630,720 720,1020 1020,1440
because if a writer sneaks
因为如果写入者偷偷进入，

400
00:12:00,800 --> 00:12:02,180
0,480 510,840 840,960 960,1080 1080,1380
in,| between when we check
|在我们检查 n 的值和尝试增加它之间，

401
00:12:02,180 --> 00:12:03,050
0,90 90,390 390,510 510,750 750,870
the value of n and

402
00:12:03,050 --> 00:12:03,770
0,120 120,240 240,480 480,630 630,720
when we actually try to

403
00:12:03,770 --> 00:12:05,960
0,420 420,690 990,1530 1710,2010 2010,2190
increment it,| {} then we
|那么我们可能继续，并增加它，

404
00:12:05,960 --> 00:12:06,860
0,180 180,510 510,600 600,810 810,900
may actually go ahead and

405
00:12:06,860 --> 00:12:07,820
0,450 450,600 600,660 660,750 750,960
increment it,| at the same
|而同时，某个写者把它设为 -1 ，

406
00:12:07,820 --> 00:12:08,900
0,210 210,360 360,570 570,960 960,1080
time, that some writer is

407
00:12:08,900 --> 00:12:09,950
0,300 300,420 420,480 480,780 780,1050
setting it to {-1 -},|
|

408
00:12:10,100 --> 00:12:11,240
0,270 270,390 390,720 780,1020 1020,1140
which is wrong.| So we
这是不对的。|所以，我们需要增加它，

409
00:12:11,240 --> 00:12:12,770
0,180 180,270 270,660 660,840 1020,1530
need to increment it,| only
|只有它在我们检查之后没有修改过值，

410
00:12:12,770 --> 00:12:14,390
0,180 180,270 270,630 630,1050 1050,1620
if it hasn't changed value

411
00:12:14,450 --> 00:12:15,980
0,300 300,420 420,810 810,1080 1260,1530
since we checked it| and
|并验证其大于或等于 0 ，

412
00:12:15,980 --> 00:12:17,330
0,570 570,720 720,840 840,1140 1140,1350
verified that is greater than

413
00:12:17,330 --> 00:12:19,520
0,90 90,300 300,360 360,930 1620,2190
or equal to 0,| and
|人们这样做的方式是，

414
00:12:19,700 --> 00:12:20,700
0,630
{}

415
00:12:21,110 --> 00:12:21,980
0,150 150,300 300,510 510,660 660,870
the way people do that

416
00:12:21,980 --> 00:12:23,240
0,90 90,210 210,390 390,810 810,1260
is,| they take advantage of
|他们利用特殊的原子指令，

417
00:12:23,270 --> 00:12:25,880
0,570 570,1170 1170,1170 1170,1770 1770,2610
special atomic or interlocked instructions,|
|

418
00:12:25,910 --> 00:12:27,350
0,240 240,360 360,720 720,1260 1260,1440
which you saw before,| for
这是你在前面看到的，|用于在 xv6 中实现自旋锁。

419
00:12:27,350 --> 00:12:28,560
0,600
the,

420
00:12:28,560 --> 00:12:30,690
0,420 450,1200 1200,1590 1590,1860 1860,2130
for implementation of spin locks

421
00:12:30,690 --> 00:12:32,670
0,210 210,360 360,780 1230,1770 1770,1980
{in,xv6 - -}.| {} And
|而原子性指令，

422
00:12:32,670 --> 00:12:34,560
0,60 60,390 390,930 930,1560 1590,1890
the interlocked instruction,| that's one
|这是一种特别方便的被称为比较和交换的指令，

423
00:12:34,560 --> 00:12:36,000
0,180 180,660 660,1080 1080,1170 1170,1440
that's particularly convenient to use

424
00:12:36,000 --> 00:12:37,230
0,90 90,390 390,690 690,1110 1110,1230
as something called compare and

425
00:12:37,230 --> 00:12:39,060
0,600 1020,1260 1260,1530 1530,1590 1590,1830
swap,| the {idea,is} the compare
|这个想法是比较和交换有三个参数，

426
00:12:39,060 --> 00:12:40,620
0,120 120,360 360,630 630,840 840,1560
and swap takes three arguments,|
|

427
00:12:40,980 --> 00:12:43,530
0,480 840,1410 1410,1530 1530,2070 2100,2550
the address of some location
我们要执行操作的某个内存位置的地址，

428
00:12:43,530 --> 00:12:44,340
0,60 60,480 480,600 600,690 690,810
of memory that we want

429
00:12:44,340 --> 00:12:47,010
0,180 180,600 600,1020 1980,2190 2190,2670
to act on,| the value
|我们认为它拥有的值，

430
00:12:47,010 --> 00:12:49,230
0,420 420,720 720,1050 1050,1140 1140,2220
that we think it holds|
|

431
00:12:49,260 --> 00:12:50,160
0,180 180,270 270,630 630,750 750,900
and the value that we'd
以及我们希望它拥有的值。

432
00:12:50,160 --> 00:12:51,580
0,330 330,450 450,510 510,870
like it to hold.|
|

433
00:12:51,990 --> 00:12:53,130
0,150 150,240 240,750 750,810 810,1140
And the semantics of compare
比较和交换的语义是，

434
00:12:53,130 --> 00:12:53,910
0,90 90,450 450,540 540,690 690,780
and swap are that,| the
|硬件检查，

435
00:12:53,910 --> 00:12:56,280
0,420 420,1350 1470,1620 1620,1920 1920,2370
hardware checks,| the hardware first
|硬件首先设置内部锁，

436
00:12:56,520 --> 00:12:57,600
0,270 270,420
sort of

437
00:12:57,660 --> 00:12:59,370
0,360 390,810 810,1050 1050,1110 1110,1710
{} basically sets an internal

438
00:12:59,370 --> 00:13:01,500
0,330 330,630 930,1380 1410,1710 1710,2130
lock,| that makes only one
|使得在给定内存位置上一次只执行一次比较和交换，

439
00:13:01,500 --> 00:13:02,880
0,360 360,480 480,780 780,1320 1320,1380
compare and swap executed a

440
00:13:02,880 --> 00:13:04,410
0,390 390,480 480,540 540,900 1170,1530
time on a given memory

441
00:13:04,410 --> 00:13:06,480
0,630 930,1200 1200,1290 1290,1590 1590,2070
location,| then the hardware checks
|然后硬件检查这个位置的当前值仍然是 x ，

442
00:13:06,480 --> 00:13:08,010
0,270 450,870 870,1200 1200,1470 1470,1530
that the current value of

443
00:13:08,010 --> 00:13:09,990
0,180 180,810 900,1110 1110,1590 1590,1980
that location is indeed still

444
00:13:09,990 --> 00:13:11,550
0,570 570,780 810,1020 1020,1140 1140,1560
x,| and if it still
|如果它仍然是 x ，

445
00:13:11,550 --> 00:13:12,600
0,660
x,|
|

446
00:13:12,850 --> 00:13:14,140
0,540 540,690 690,780 780,990 990,1290
sets it to this third
将它设置为第三个参数，它将是 x 加 1 ，

447
00:13:14,140 --> 00:13:15,280
0,390 390,840 870,960 960,1080 1080,1140
argument, which is going to

448
00:13:15,280 --> 00:13:17,140
0,90 90,330 330,510 510,930 1440,1860
be x plus one,| and
|然后指令产生 1 ，它的值，

449
00:13:17,140 --> 00:13:18,820
0,120 120,210 210,660 660,990 990,1680
then the instruction yields one,

450
00:13:19,150 --> 00:13:22,090
0,330 330,870 1680,2190 2310,2550 2550,2940
its value,| {} if {compare,and}
|如果比较和交换观察到当前值不是 x ，

451
00:13:22,090 --> 00:13:23,170
0,300 300,690 690,780 780,870 870,1080
swap observes that the current

452
00:13:23,170 --> 00:13:26,050
0,270 270,570 570,1380 1800,2370 2490,2880
value isn't x,| {} then
|那么它不会改变那个内存位置的值，

453
00:13:26,110 --> 00:13:27,280
0,210 210,480 480,780 780,870 870,1170
it doesn't change the value

454
00:13:27,780 --> 00:13:29,100
0,90 90,330 330,750 750,930 930,1320
the memory location,| {and,it} returns
|并返回 0 。

455
00:13:29,100 --> 00:13:30,020
0,360
0.|
|

456
00:13:30,130 --> 00:13:31,690
0,270 270,450 450,810 960,1470 1470,1560
So this is basically an
所以这是一个原子性的，

457
00:13:31,690 --> 00:13:33,340
0,990
atomic,|
|

458
00:13:33,980 --> 00:13:35,180
0,240 240,330 330,780 780,900 900,1200
if the location is x,
如果位置是 x ，则设置为 x 加 1 。

459
00:13:35,180 --> 00:13:36,290
0,240 240,360 360,570 570,780 780,1110
set to x plus one.|
|

460
00:13:37,380 --> 00:13:38,280
0,180 180,330 330,390 390,480 480,900
It has to be atomic,|
它必须是原子的，|

461
00:13:38,280 --> 00:13:39,390
0,240 240,420 420,600 600,900 900,1110
{because,there's} really two things going
因为有两件事在发生，

462
00:13:39,390 --> 00:13:41,130
0,330 390,510 510,870 870,1170 1200,1740
on,| the hardware is checking
|硬件检查当前值，并将其设置为新值。

463
00:13:41,130 --> 00:13:42,780
0,90 90,420 420,840 1080,1320 1320,1650
the current value and setting

464
00:13:42,780 --> 00:13:43,560
0,120 120,270 270,300 300,480 480,780
it to a new value.|
|

465
00:13:45,720 --> 00:13:46,830
0,210 210,510 510,720 720,1020 1020,1110
Any questions about compare and
关于比较和交换，有什么问题吗？

466
00:13:46,830 --> 00:13:47,800
0,540
swap?|
|

467
00:13:49,650 --> 00:13:50,970
0,270 270,480 480,630 630,720 720,1320
{} I have a question,|
我有个问题，|

468
00:13:50,970 --> 00:13:52,710
0,690 960,1230 1230,1440 1440,1620 1620,1740
if {} there would be
如果有一个读者和 r_lock 需要继续，

469
00:13:52,710 --> 00:13:55,110
0,150 150,660 660,1410 1410,2010 2040,2400
a reader and {} {r_lock

470
00:13:55,110 --> 00:13:58,590
0,570 600,990 990,1590 1710,2610 2730,3480
-} needs to continue,| would
|那么 w_unlock 是否会将值重置回 x 。

471
00:13:59,010 --> 00:14:01,230
0,660 660,930 930,1380 1380,2040 2040,2220
{w_unlock - -} reset the

472
00:14:01,230 --> 00:14:04,110
0,510 510,870 870,1080 1080,1800 1920,2880
value back to x.| Um,
|w_unlock ，如果有一个写者，

473
00:14:04,170 --> 00:14:07,180
0,570 840,1710 1710,2550
{} {w_unlock -},

474
00:14:07,820 --> 00:14:09,480
0,120 120,300 300,390 390,1080
if there's a writer,|
|

475
00:14:09,510 --> 00:14:11,520
0,480 480,1050 1050,1530 1560,1680 1680,2010
{w_unlock -}, which I'm afraid
w_unlock，它会设置 n 为 0 ，

476
00:14:11,520 --> 00:14:12,870
0,120 120,420 420,720 720,1230 1230,1350
it shows set n to

477
00:14:12,870 --> 00:14:14,080
0,630
0,|
|

478
00:14:14,550 --> 00:14:15,300
0,180 180,330 330,450 450,630 630,750
because there can only be
因为只能有一个写者。

479
00:14:15,300 --> 00:14:16,820
0,300 300,930
one writer.|
|

480
00:14:17,830 --> 00:14:19,660
0,180 180,660 690,900 930,1350 1350,1830
If there's what {r_unlock -}
而 r_unlock 所做的是，

481
00:14:19,660 --> 00:14:22,360
0,960 1290,1500 1500,1860 1860,2310 2310,2700
does is| use another compare
|使用另一个比较并交还来减少 n 。

482
00:14:22,360 --> 00:14:23,600
0,90 90,720
and swap

483
00:14:24,340 --> 00:14:26,340
0,120 120,900 900,1350
to decrement n.|
|

484
00:14:27,330 --> 00:14:29,360
0,780 840,1380
Okay, because,
好的，这会发生什么，

485
00:14:30,010 --> 00:14:31,960
0,300 300,810 810,1380
what happens,| if
|如果写者锁处于 x 正在计算。

486
00:14:31,960 --> 00:14:33,240
0,690
{}

487
00:14:33,240 --> 00:14:36,720
0,180 180,930 960,2040 2100,2730 2760,3480
{} writer locks {} lock

488
00:14:36,750 --> 00:14:39,030
0,840 840,1440 1440,1800 1800,1980 1980,2280
between when x is being

489
00:14:39,030 --> 00:14:41,840
0,870 1320,2310
computed and.|
|

490
00:14:41,930 --> 00:14:43,480
0,240 240,450 450,1020
So, right here?|
在这里吗？|

491
00:14:44,560 --> 00:14:46,450
0,360 390,630 630,1200 1200,1380 1380,1890
{} No, between the if
不，在 if 和 x 之间。

492
00:14:46,450 --> 00:14:49,420
0,660 1380,2130
and x

493
00:14:49,990 --> 00:14:51,140
0,720
somehow.|
|

494
00:14:51,140 --> 00:14:52,880
0,360 510,1080 1080,1320 1320,1620 1620,1740
Okay, okay, it's, I'm not
好的，我不太明白你问的是什么时间，

495
00:14:52,880 --> 00:14:55,280
0,150 150,210 210,540 540,1320 1590,2400
sure I understand exactly what

496
00:14:55,340 --> 00:14:56,870
0,750 750,900 900,1140 1140,1260 1260,1530
time you're asking,| but it's
|但这绝对是个好问题，

497
00:14:56,870 --> 00:14:58,700
0,480 480,630 630,990 990,1230 1230,1830
absolutely good question,| what happens
|如果在这个序列中的某个地方调用了 w_lock ，会发生什么。

498
00:14:58,760 --> 00:15:01,160
0,390 390,810 810,1320 1470,1740 1740,2400
if {w_lock -} is called

499
00:15:01,250 --> 00:15:03,680
0,690 690,930 930,1080 1080,1980
somewhere during this sequence.|
|

500
00:15:03,800 --> 00:15:05,150
0,390 570,780 780,990 990,1110 1110,1350
And for me the most
对我来说，调用 w_lock 最危险的时间是，

501
00:15:05,150 --> 00:15:06,620
0,390 390,690 690,810 810,1170 1170,1470
dangerous time for {w_lock -}

502
00:15:06,620 --> 00:15:08,900
0,90 90,210 210,720 750,1170 1800,2280
to be called is| after
|在检查之后，但在比较和交换之前。

503
00:15:08,900 --> 00:15:10,520
0,270 270,870 1020,1170 1170,1530 1530,1620
this check, but before the

504
00:15:10,520 --> 00:15:13,130
0,390 390,480 480,1170 1980,2340 2370,2610
compare and swap.| So, let's
|那么，我们假设读锁已经完成，

505
00:15:13,130 --> 00:15:15,440
0,660 1050,1500 1620,1950 1950,2190 2190,2310
imagine that read lock has

506
00:15:15,440 --> 00:15:16,490
0,210 210,360 360,570 570,690 690,1050
done,| as far as seeing
|已经看到 x 或 l->n 是 0 。

507
00:15:16,490 --> 00:15:18,020
0,120 120,510 510,780 1020,1410 1410,1530
that x, that x {}

508
00:15:18,020 --> 00:15:19,400
0,390 390,600 600,780 780,930 930,1380
or {l->n - - -}

509
00:15:19,430 --> 00:15:20,660
0,150 150,780
is 0.|
|

510
00:15:21,030 --> 00:15:22,290
0,300 300,420 420,660 660,780 780,1260
Okay, so maybe we're right,
好的，也许我们在这里，

511
00:15:22,290 --> 00:15:23,860
0,150 150,330 330,990
we're right here,|
|

512
00:15:24,820 --> 00:15:26,140
0,480 480,750 750,930 930,1200 1200,1320
and x is equal to
并且 x 等于 0 。

513
00:15:26,140 --> 00:15:27,280
0,630
0.|
|

514
00:15:28,760 --> 00:15:30,660
0,570

515
00:15:30,900 --> 00:15:32,670
0,660 780,990 990,1200 1200,1350 1350,1770
{ -} We've already checked,
我们已经检查过了，检查已经完成了，

516
00:15:33,030 --> 00:15:34,140
0,210 210,450 450,570 570,1020 1020,1110
the check is finished,| and
|然后就在这个时候，在另一个核心上，

517
00:15:34,140 --> 00:15:35,250
0,330 360,600 600,690 690,870 870,1110
then right at this time

518
00:15:35,250 --> 00:15:36,690
0,90 90,390 390,870 990,1260 1260,1440
on another core,| some other
|一些其他线程调用了 w_lock ，

519
00:15:36,690 --> 00:15:39,020
0,360 360,720 720,1050 1050,1650
thread calls {w_lock -},|
|

520
00:15:39,020 --> 00:15:40,340
0,360 360,600 600,750 750,1050 1050,1320
{} and it actually gets
它首先进行比较和交换。

521
00:15:40,340 --> 00:15:41,630
0,270 270,630 630,720 720,1080 1080,1290
its compare and swap in

522
00:15:41,630 --> 00:15:43,220
0,690
first.|
|

523
00:15:43,340 --> 00:15:44,300
0,360 360,540 540,660 660,780 780,960
{} So on the other
所以，另一个核心正在尝试获取写锁，

524
00:15:44,300 --> 00:15:45,530
0,600 630,780 780,960 960,1020 1020,1230
core is trying to grab

525
00:15:45,530 --> 00:15:47,810
0,90 90,330 330,750 1770,2190 2190,2280
the write lock,| compare and
|比较和交换将查看 l->n 是否为 0 ，

526
00:15:47,810 --> 00:15:48,620
0,270 270,390 390,540 540,630 630,810
swap is going to see

527
00:15:48,620 --> 00:15:49,760
0,120 120,600 600,720 720,840 840,1140
if {l->n -} is 0,|
|

528
00:15:49,760 --> 00:15:50,810
0,180 180,600 600,780 780,930 930,1050
let's assume that n is
我们假设 n 是 0 ，那么这个测试是真的，

529
00:15:50,810 --> 00:15:53,060
0,570 600,990 1470,1860 1860,2160 2160,2250
0, so this test is

530
00:15:53,060 --> 00:15:54,470
0,570 630,960 960,1020 1020,1320 1320,1410
true,| and the compare and
|并且在另一个核心上的比较和交换

531
00:15:54,470 --> 00:15:55,620
0,330 330,720
swap is

532
00:15:55,620 --> 00:15:56,340
0,90 90,240 240,420 420,630 630,720
on that other core| is
|将设置 n 为 -1 ，

533
00:15:56,340 --> 00:15:57,510
0,150 150,210 210,660 690,1080 1080,1170
going to set n to

534
00:15:57,510 --> 00:15:58,770
0,360 360,780 780,900 900,960 960,1260
{-1 -},| now the locks
|现在锁加锁了，

535
00:15:58,770 --> 00:16:01,440
0,600 1380,1800 1800,1920 1920,2250 2250,2670
locked,| but we still think
|但是我们在这个代码中仍然认为 n 是 0 ，

536
00:16:01,440 --> 00:16:03,180
0,240 420,840 840,1020 1020,1560 1560,1740
that n is 0 in

537
00:16:03,180 --> 00:16:04,520
0,180 180,750
this code,|
|

538
00:16:04,520 --> 00:16:05,870
0,210 210,420 420,510 510,870 870,1350
{} even the locks locked.|
即使锁已经锁定了。|

539
00:16:06,380 --> 00:16:07,640
0,180 180,270 270,360 360,510 510,1260
And now we're gonna execute,|
现在我们要执行，|

540
00:16:07,640 --> 00:16:09,020
0,330 330,420 420,540 540,900 900,1380
back on the reading core,|
回到读取核心，|

541
00:16:09,650 --> 00:16:10,790
0,360 360,480 480,540 540,810 810,1140
We're going to execute compare
我们要执行比较和交换，

542
00:16:10,790 --> 00:16:12,080
0,90 90,630 840,1050 1050,1170 1170,1290
and swap,| but we're going
|但是我们要在这里传递 0 ，

543
00:16:12,080 --> 00:16:13,880
0,60 60,390 390,1020 1020,1560 1590,1800
to pass 0 here right,|
|

544
00:16:13,880 --> 00:16:14,720
0,150 150,240 240,330 330,720 720,840
this is the value we
这是我们要传递的值，

545
00:16:14,720 --> 00:16:15,710
0,390 390,570 570,630 630,900 900,990
actually,| {we're,going} to pass in
|我们要传递我们看到的值，

546
00:16:15,710 --> 00:16:17,090
0,60 60,360 360,510 510,870 870,1380
the value we actually looked

547
00:16:17,090 --> 00:16:18,590
0,420 480,780 780,840 840,1170 1170,1500
at,| not the current value
|而不是 n 的当前值。

548
00:16:18,590 --> 00:16:19,560
0,120 120,390
of n.|
|

549
00:16:19,590 --> 00:16:20,430
0,210 210,330 330,480 480,720 720,840
And when we looked at
当我们查看它时，它是 0 ，

550
00:16:20,430 --> 00:16:21,330
0,180 180,300 300,690 690,840 840,900
{it,,it} was zero,| so we're
|所以我们要在这里传递 0 ，

551
00:16:21,330 --> 00:16:22,620
0,120 120,180 180,480 480,840 840,1290
going to pass 0 here,|
|

552
00:16:22,920 --> 00:16:23,850
0,210 210,270 270,510 510,840 840,930
and we'll telling compare and
我们会告诉比较和交换，

553
00:16:23,850 --> 00:16:25,950
0,300 300,570 600,1500 1530,1860 1860,2100
swap,| look only add one
|对它加一，

554
00:16:25,950 --> 00:16:27,450
0,240 240,750 990,1350 1350,1440 1440,1500
to,| only set it to
|只有在当前值为 0 时，将它设置为 1 。

555
00:16:27,450 --> 00:16:29,190
0,630 690,990 990,1110 1110,1410 1410,1740
1, if its current value

556
00:16:29,190 --> 00:16:30,280
0,90 90,600
is 0.|
|

557
00:16:30,550 --> 00:16:31,330
0,120 120,270 270,420 420,690 690,780
But it's not 0, at
但在这一点上，它不是 0 ，而是 -1 ，

558
00:16:31,330 --> 00:16:32,650
0,180 180,450 450,570 570,900 900,1320
this point, it's {-1 -},|
|

559
00:16:32,800 --> 00:16:33,880
0,240 240,330 330,480 480,900 900,1080
and so this {compare,and} swap
所以这个比较和交换会失败，

560
00:16:33,880 --> 00:16:36,580
0,750 780,990 990,1380 1380,2100 2130,2700
fails,| does not modify n,
|不会修改 n ，并返回 0 ，

561
00:16:37,190 --> 00:16:39,110
0,480 480,1230 1380,1650 1650,1800 1800,1920
returns 0,| and so that
|这意味着我们将回到这个循环的顶部，然后重试，

562
00:16:39,110 --> 00:16:39,770
0,150 150,240 240,330 330,570 570,660
means we'll go back to

563
00:16:39,770 --> 00:16:40,550
0,90 90,360 360,420 420,480 480,780
the top of {this,loop -}

564
00:16:40,550 --> 00:16:41,840
0,90 90,240 240,720 990,1080 1080,1290
and try again,| of course
|当然现在 n 是 -1 。

565
00:16:41,840 --> 00:16:43,370
0,330 660,870 870,1020 1020,1290 1290,1530
now n is {-1 -}.|
|

566
00:16:45,370 --> 00:16:46,810
0,510 510,750 750,870 870,1050 1050,1440
{} This may be related
这可能和前面的问题有点关系，

567
00:16:46,810 --> 00:16:47,800
0,120 120,270 270,570 570,870 870,990
to the previous question a

568
00:16:47,800 --> 00:16:49,540
0,210 210,600 630,1110 1410,1590 1590,1740
bit,| but, {} is it
|但是，是否会发生中断，

569
00:16:49,540 --> 00:16:51,520
0,630 630,1020 1020,1170 1170,1860 1860,1980
possible for an interrupt to

570
00:16:51,520 --> 00:16:52,720
0,660
occur,|
|

571
00:16:52,720 --> 00:16:54,250
0,330 330,720 720,1050 1050,1260 1260,1530
{} when that x plus
当在 CAS 参数中计算 x 加 1 时？

572
00:16:54,250 --> 00:16:55,780
0,390 390,630 630,810 810,1410 1410,1530
1 is being computed in

573
00:16:55,780 --> 00:16:58,030
0,90 90,660 660,1320 1350,1860 1860,2250
the CAS parameter {or,CAS -}

574
00:16:58,150 --> 00:17:00,010
0,810 990,1140 1140,1290 1290,1710 1710,1860
parameter?| You mean before we
|你的意思是在我们执行 CAS 之前，

575
00:17:00,010 --> 00:17:01,600
0,330 330,840 840,1170 1170,1470 1470,1590
actually execute {CAS -},| but
|但是在我们计算它的参数时？

576
00:17:01,600 --> 00:17:03,250
0,180 180,300 300,690 690,840 840,1650
while we're computing its arguments?|
|

577
00:17:03,310 --> 00:17:05,080
0,480 480,690 690,900 900,1080 1080,1770
Right, so like you compute,|
是的，比如你计算，|

578
00:17:05,080 --> 00:17:06,490
0,90 90,420 420,660 660,840 840,1410
you pass in the x
你传入 x 参数，这没问题，

579
00:17:06,520 --> 00:17:08,500
0,1050 1050,1140 1140,1350 1350,1740 1740,1980
argument and that's okay,| but
|但是在你计算 x+1 之前，

580
00:17:08,500 --> 00:17:10,210
0,450 780,1140 1140,1260 1260,1620 1620,1710
you before you compute the

581
00:17:10,210 --> 00:17:11,320
0,210 210,390 390,690 690,780 780,1110
x plus 1| or while
|或者当你在计算 x+1 的时候，

582
00:17:11,320 --> 00:17:12,790
0,120 120,540 540,900 900,1320 1350,1470
you're computing {x,plus} 1,| an
|中断发生了。

583
00:17:12,790 --> 00:17:14,020
0,390 390,900
interrupt occurs.|
|

584
00:17:14,050 --> 00:17:15,610
0,630 690,900 900,990 990,1350 1350,1560
Okay.| And the {x,plus} 1
好的。|x+1 是错误的。

585
00:17:15,610 --> 00:17:17,140
0,120 120,510 540,960
is wrong.| So,
|所以，如果在我们计算 x+1 时发生中断，

586
00:17:17,170 --> 00:17:18,460
0,270 270,330 330,720 720,1050 1050,1290
if an interrupt occurs while

587
00:17:18,460 --> 00:17:19,480
0,90 90,480 480,660 660,840 840,1020
we're computing x plus 1,|
|

588
00:17:19,480 --> 00:17:20,890
0,120 120,270 270,390 390,720 900,1410
that means we haven't,| {CAS
这意味着我们没有，|CAS 实际上是一条指令，

589
00:17:20,890 --> 00:17:22,300
0,150 150,240 240,510 510,1260 1260,1410
-} is {actually,an} instruction,| it's
|它是一条单一的机器指令，

590
00:17:22,300 --> 00:17:24,260
0,60 60,390 390,720 720,1290
a single machine instruction,|
|

591
00:17:24,260 --> 00:17:25,490
0,330 330,480 480,840 840,1050 1050,1230
so for {computing,x -} plus
所以对于计算 x+1 ，

592
00:17:25,490 --> 00:17:26,210
0,150 150,240 240,360 360,450 450,720
1,| that means we {haven't
|这意味着我们还没有调用 CAS 。

593
00:17:26,210 --> 00:17:27,920
0,240 240,570 570,810 810,1050
-} called CAS yet.|
|

594
00:17:27,980 --> 00:17:30,380
0,270 270,360 360,750 750,1770 2250,2400
If the interrupt happens and
如果中断发生，各种事情都可能发生，

595
00:17:30,380 --> 00:17:31,220
0,180 180,360 360,450 450,720 720,840
all kinds of things may

596
00:17:31,220 --> 00:17:32,380
0,600
happen,|
|

597
00:17:32,920 --> 00:17:33,460
0,150 150,270 270,330 330,450 450,540
we're going to get the
我们会得到相同的，

598
00:17:33,460 --> 00:17:35,260
0,480 480,900 900,1020 1020,1560 1560,1800
same,| if we originally read
|如果我们最初在这里读到 0 ，

599
00:17:35,260 --> 00:17:36,900
0,450 450,1020
zero here,

600
00:17:37,970 --> 00:17:40,250
0,510 510,810 840,1290 1290,1530 1530,2280
right,| then interrupt {or,no} interrupt,|
|然后中断或没有中断，|

601
00:17:40,800 --> 00:17:42,510
0,180 180,360 360,780 780,1500 1500,1710
we're gonna pass 1 as
我们会传递 1 作为第三个参数，

602
00:17:42,510 --> 00:17:44,040
0,180 180,420 420,1050
this third argument,|
|

603
00:17:44,040 --> 00:17:44,820
0,150 150,420 420,600 600,720 720,780
because interrupts not going to
因为中断不会改变，

604
00:17:44,820 --> 00:17:45,960
0,240 240,420 420,510 510,1020 1020,1140
[reach out] and change,| this
|这个 x 是这段代码的局部变量，

605
00:17:45,960 --> 00:17:46,920
0,60 60,150 150,510 510,690 690,960
is a local, this x

606
00:17:46,920 --> 00:17:48,600
0,90 90,180 180,450 450,1080
is a local variable

607
00:17:48,920 --> 00:17:51,620
0,300 300,630 750,1470 1470,2310 2310,2700
{for,this} code,| so interrupt context
|中断上下文，任何事情都不会改变 x 。

608
00:17:51,620 --> 00:17:52,520
0,150 150,480 480,600 600,750 750,900
which anything is not gonna

609
00:17:52,520 --> 00:17:54,140
0,390 390,1140
change x.|
|

610
00:17:54,230 --> 00:17:54,860
0,210 210,300 300,450 450,510 510,630
So that means we're going
所以这意味着我们将传递 0 和 1 ，

611
00:17:54,860 --> 00:17:56,060
0,60 60,660
to pass

612
00:17:56,160 --> 00:17:57,630
0,540 540,630 630,930 930,1260 1260,1470
0 and 1 here,| and
|如果 n 仍然是 0 ，

613
00:17:57,750 --> 00:17:58,860
0,360 360,570
you know

614
00:17:59,840 --> 00:18:01,160
0,300 330,600 600,720 720,930 930,1320
if n is still 0,|
|

615
00:18:01,160 --> 00:18:01,670
0,120 120,240 240,390 390,450 450,510
then we'll set it to
那么我们就把它设为 1 ，

616
00:18:01,670 --> 00:18:02,660
0,240 240,360 360,720 720,900 900,990
one,| and that's that's what
|这就是我们想要的，

617
00:18:02,660 --> 00:18:03,410
0,60 60,330 330,420 420,570 570,750
we want,| if it's not
|如果它不是 0 ，

618
00:18:03,410 --> 00:18:04,790
0,210 210,510 510,870 930,1290 1290,1380
still 0,| then compare and
|那么比较并交换不会修改它。

619
00:18:04,790 --> 00:18:06,440
0,210 210,630 660,990 990,1110
swap won't change it.|
|

620
00:18:06,530 --> 00:18:07,250
0,300 300,360 360,570 570,630 630,720
Right, I guess you would
好的，我想你会有问题，

621
00:18:07,250 --> 00:18:08,300
0,150 150,540 540,660 660,780 780,1050
have problems,| if you didn't
|如果你不设置那个局部变量。

622
00:18:08,300 --> 00:18:09,710
0,210 210,390 390,660 660,1080 1080,1410
set that local variable {}.|
|

623
00:18:11,630 --> 00:18:13,220
0,420 420,540 540,780 780,1260 1260,1590
If you used {} l
如果你在这里用 l->n ， l->n+1 ，

624
00:18:13,220 --> 00:18:15,140
0,150 150,300 300,720 720,1560 1770,1920
{l->n - -} here, {l->n

625
00:18:15,140 --> 00:18:16,430
0,450 450,600 600,840 840,1110 1110,1290
- -} plus 1,| you
|你肯定会有大麻烦，

626
00:18:16,430 --> 00:18:17,510
0,240 240,600 600,840 840,960 960,1080
would almost certainly be in

627
00:18:17,510 --> 00:18:19,190
0,180 180,510 510,750 750,1110 1290,1680
big trouble,| because then n
|因为那样的话， n 随时都可能改变，

628
00:18:19,190 --> 00:18:20,810
0,150 150,450 450,1140 1200,1440 1440,1620
could change underfoot at any

629
00:18:20,810 --> 00:18:22,670
0,390 690,900 900,990 990,1170 1380,1860
time,| that's why we actually
|这就是为什么我们在这里获得一个 n 的拷贝，

630
00:18:22,670 --> 00:18:24,890
0,510 510,570 570,990 990,1170 1500,2220
grab a copy n,| grab
|获取一个拷贝，以固定一个特定值。

631
00:18:24,890 --> 00:18:25,970
0,60 60,420 420,720 720,810 810,1080
a copy here in order

632
00:18:25,970 --> 00:18:28,370
0,420 840,1350 1350,1410 1410,1890 1890,2400
to fix a specific value.|
|

633
00:18:28,920 --> 00:18:30,640
0,870
Yes.|
好的。|

634
00:18:32,090 --> 00:18:33,260
0,540
Okay.|
好的。|

635
00:18:35,930 --> 00:18:38,090
0,630 690,1080 1080,1380 1380,1980 1980,2160
{} If two readers,| okay,
如果有两个读者，|好的，我说一下这种情况，

636
00:18:38,090 --> 00:18:38,840
0,150 150,210 210,480 480,540 540,750
so I covered the case|
|

637
00:18:38,840 --> 00:18:40,190
0,90 90,270 270,660 660,930 930,1350
of {} whatever writer {}
不论写者同时调用，

638
00:18:40,950 --> 00:18:42,750
0,480 480,570 570,1020 1260,1590 1590,1800
calls the same,| {w_lock -}
|w_lock 与 r_lock 同时调用，

639
00:18:42,750 --> 00:18:43,590
0,90 90,330 330,390 390,660 660,840
is called the same time

640
00:18:43,590 --> 00:18:46,080
0,120 120,300 300,990 1020,1440 2010,2490
as {r_lock -},| {} it's
|同样有趣的是，

641
00:18:46,080 --> 00:18:47,130
0,210 210,540 540,630 630,840 840,1050
also interesting to wonder| what
|如果同时调用 r_lock 会怎么样。

642
00:18:47,130 --> 00:18:48,030
0,120 120,300 300,540 540,660 660,900
if {r_lock -} is called

643
00:18:48,030 --> 00:18:50,190
0,60 60,120 120,330 330,630 1470,2160
at the same time.| So
|所以假设 n 从 0 开始，

644
00:18:50,190 --> 00:18:51,750
0,720 810,990 990,1140 1140,1440 1440,1560
supposing the n starts at

645
00:18:51,750 --> 00:18:52,980
0,450 450,570 570,780 780,930 930,1230
0,| we know if two
|如果同时调用两个 r_lock ，

646
00:18:52,980 --> 00:18:54,840
0,180 180,1080 1320,1500 1500,1770 1770,1860
{r_locks -} are called at

647
00:18:54,840 --> 00:18:56,010
0,90 90,300 300,720 750,1020 1020,1170
the same time,| what we
|我们想要的是 n 最终的值是 2 ，

648
00:18:56,010 --> 00:18:57,300
0,540 540,750 750,960 960,1200 1200,1290
want is for n to

649
00:18:57,300 --> 00:18:58,920
0,210 210,360 360,480 480,870 870,1620
end up with value 2,|
|

650
00:18:59,130 --> 00:19:00,690
0,360 360,510 510,960 960,1170 1170,1560
and for both {r_locks -}
两个 r_lock 都返回，

651
00:19:00,690 --> 00:19:01,980
0,150 150,870 900,1080 1080,1170 1170,1290
to return,| that's what we
|这就是我们想要的，

652
00:19:01,980 --> 00:19:03,570
0,600 870,1080 1080,1140 1140,1380 1380,1590
want,| because we want two
|因为我们希望两个读者能够并行执行，

653
00:19:03,570 --> 00:19:04,500
0,360 360,540
readers to,

654
00:19:04,500 --> 00:19:05,130
0,60 60,180 180,240 240,570 570,630
be able to execute in

655
00:19:05,130 --> 00:19:06,480
0,540 570,720 720,960 960,1080 1080,1350
parallel,| to use the data
|能够并行使用数据。

656
00:19:06,480 --> 00:19:09,990
0,120 120,750 1110,1770 2700,3150 3150,3510
in parallel.| {} Okay, so,
|好的，那么在这一点上，它们都会看到 0 。

657
00:19:11,250 --> 00:19:12,420
0,420 420,570 570,780 780,960 960,1170
{} they're both gonna see

658
00:19:12,420 --> 00:19:13,740
0,750
{0}

659
00:19:13,930 --> 00:19:15,370
0,150 150,360 360,750 750,1080 1230,1440
at this point.| So, at
|所以，在这一点上，它们的 x 都等于 0 ，

660
00:19:15,370 --> 00:19:16,180
0,180 180,420 420,570 570,690 690,810
this point, both of them

661
00:19:16,180 --> 00:19:16,750
0,30 30,150 150,210 210,330 330,570
are going to have x

662
00:19:16,750 --> 00:19:18,310
0,180 180,300 300,900 1050,1320 1320,1560
equal to 0,| they're both
|它们都会使用 0 和 1 调用比较并交换。

663
00:19:18,310 --> 00:19:20,110
0,210 210,600 720,1170 1170,1320 1320,1800
gonna call compare and swap

664
00:19:20,110 --> 00:19:22,560
0,390 480,1080 1080,1230 1230,1860
with 0 and 1.|
|

665
00:19:23,010 --> 00:19:24,400
0,780

666
00:19:25,680 --> 00:19:26,730
0,330 330,570 570,660 660,870 870,1050
Only one of those two
这两个比较和交换中只有一个，

667
00:19:26,730 --> 00:19:29,100
0,450 450,570 570,1020 1020,1530 1710,2370
compare and swap hopefully,| exactly
|恰好有一个比较和交换会成功，

668
00:19:29,100 --> 00:19:30,120
0,180 180,270 270,480 480,630 630,1020
one of those to compare

669
00:19:30,120 --> 00:19:32,190
0,120 120,540 540,630 630,1500 1650,2070
and swaps will succeed,| whichever
|无论哪一个，

670
00:19:32,190 --> 00:19:33,990
0,600 780,930 930,1440 1440,1530 1530,1800
one,| {you,know} compare and swap
|比较和交换是原子指令，

671
00:19:34,260 --> 00:19:36,560
0,630 630,1290 1530,1890
{it's,an,atomic} instruction,| the
|在同一内存位置，它们中只有一个可以发生，

672
00:19:36,800 --> 00:19:37,970
0,300 300,570 570,630 630,750 750,1170
only one of them happens

673
00:19:37,970 --> 00:19:39,470
0,120 120,180 180,810 1170,1410 1410,1500
at a time on a

674
00:19:39,470 --> 00:19:41,300
0,270 270,570 570,1080 1290,1500 1500,1830
given memory location,| so whichever
|所以无论哪个比较并交换我们先看到，

675
00:19:41,300 --> 00:19:42,420
0,120 120,600
will compare

676
00:19:43,010 --> 00:19:44,690
0,330 330,480 480,930 930,1050 1050,1680
{and,swap} is first we'll see,|
|

677
00:19:44,960 --> 00:19:46,340
0,390 390,930 930,1080 1080,1200 1200,1380
{} that n is equal
n 等于 0 ，并将它设置为 1 ，

678
00:19:46,340 --> 00:19:47,210
0,90 90,510 510,540 540,660 660,870
to 0, and will set

679
00:19:47,210 --> 00:19:48,890
0,90 90,150 150,630 1020,1380 1380,1680
it to 1,| the other
|其他核心同时调用 r_lock ，

680
00:19:48,890 --> 00:19:50,960
0,750 780,1530 1530,1770 1770,1860 1860,2070
cores simultaneous call to {r_lock

681
00:19:50,960 --> 00:19:52,580
0,360 510,930 930,1260 1260,1500 1500,1620
-},| it's {compare,and} swap will
|它的比较和交换然后执行，

682
00:19:52,580 --> 00:19:54,890
0,240 240,960 1320,1830 1950,2130 2130,2310
then execute| {} and it'll
|在这里它仍然传递 0 和 1 ，

683
00:19:54,890 --> 00:19:56,090
0,240 240,540 540,900 900,990 990,1200
still pass zero and one

684
00:19:56,090 --> 00:19:57,040
0,450
here,|
|

685
00:19:57,510 --> 00:19:59,550
0,480 510,1110 1290,1650 1650,1800 1800,2040
{} but n will now
但 n 现在将等于 1 ，

686
00:19:59,550 --> 00:20:00,630
0,120 120,330 330,390 390,930 930,1080
be equal to 1,| and
|所以第二个核心的比较并交换会失败，并返回 0 ，

687
00:20:00,630 --> 00:20:02,250
0,90 90,150 150,720 720,870 870,1620
so the {compare,and,swap} will fail

688
00:20:02,930 --> 00:20:04,850
0,120 120,210 210,570 570,990 1530,1920
for the second core {}

689
00:20:04,850 --> 00:20:07,820
0,150 150,480 480,1140 2160,2700 2700,2970
and return 0,| the second
|第二个核心将回到这个循环的顶部，

690
00:20:07,820 --> 00:20:08,450
0,180 180,270 270,360 360,540 540,630
core will go back to

691
00:20:08,450 --> 00:20:09,410
0,60 60,330 330,390 390,570 570,960
the top of this loop,|
|

692
00:20:09,440 --> 00:20:10,160
0,210 210,360 360,540 540,630 630,720
at this point it will
在这一点上，它将是 1 ，

693
00:20:10,160 --> 00:20:11,600
0,180 180,900
be 1,|
|

694
00:20:11,600 --> 00:20:13,400
0,690 990,1260 1260,1500 1500,1710 1710,1800
{} that's not less than
那不小于 0 ，

695
00:20:13,400 --> 00:20:14,740
0,330 330,660
zero,| so
|所以我们将继续比较和交换，

696
00:20:14,860 --> 00:20:15,760
0,210 210,330 330,450 450,600 600,900
we'll go on to compare

697
00:20:15,760 --> 00:20:16,540
0,120 120,390 390,480 480,630 630,780
and swap,| and now it'll
|现在它将传递 1 和 2 ，

698
00:20:16,540 --> 00:20:18,070
0,210 210,480 480,660 660,1170 1230,1530
pass 1 and 2,| and
|现在第二个读锁将会成功，

699
00:20:18,070 --> 00:20:19,960
0,270 270,450 450,1230 1380,1650 1650,1890
now the second read lock

700
00:20:19,960 --> 00:20:21,520
0,90 90,780 900,1380 1380,1440 1440,1560
will succeed,| both of them
|他们两个都会有锁。

701
00:20:21,520 --> 00:20:23,170
0,90 90,240 240,360 360,840 1290,1650
will have the lock {}.|
|

702
00:20:23,470 --> 00:20:24,520
0,180 180,240 240,480 480,570 570,1050
So the first one succeeded,
所以第一个在第一次尝试时成功了，

703
00:20:24,520 --> 00:20:25,480
0,60 60,330 330,570 570,690 690,960
the first try,| the second
|第二个返回到循环，然后重试。

704
00:20:25,480 --> 00:20:26,470
0,90 90,360 360,480 480,780 780,990
one actually go back to

705
00:20:26,470 --> 00:20:28,030
0,270 300,810 810,900 900,1110 1110,1560
the loop and try again.|
|

706
00:20:31,500 --> 00:20:33,060
0,210 210,840
Any questions?|
有什么问题吗？|

707
00:20:36,510 --> 00:20:37,770
0,300 300,630 630,810 810,900 900,1260
Oh, sorry, so it is
哦，抱歉，所以有没有可能，

708
00:20:37,800 --> 00:20:40,680
0,510 510,1020 1020,1380 1830,2430 2730,2880
somehow possible that,| so a
|所以来了一大堆读取，

709
00:20:40,680 --> 00:20:42,990
0,240 240,330 330,960 1020,1710 1920,2310
bunch of reads come,| and
|它们在读取它们的东西，

710
00:20:42,990 --> 00:20:45,030
0,660 720,1320 1350,1590 1590,1830 1830,2040
they {they're -} reading their

711
00:20:45,030 --> 00:20:46,340
0,360 360,450 450,870
stuff,| and then
|然后写入也来了，它也想写，

712
00:20:46,460 --> 00:20:48,200
0,510 510,780 780,1290 1290,1560 1560,1740
{a,write} also comes and it

713
00:20:48,200 --> 00:20:50,270
0,240 240,510 510,990 1140,1650 1890,2070
also wants to write,| but
|但是随后一些其他读取，也在写入之后来了，

714
00:20:50,270 --> 00:20:51,830
0,150 150,300 300,570 570,1110 1140,1560
then some other reads also

715
00:20:51,830 --> 00:20:53,620
0,180 180,450 450,570 570,1050
come after the write,|
|

716
00:20:53,620 --> 00:20:55,870
0,180 180,390 390,1020 1110,1560 1560,2250
but then somehow the reads
但是因为某种原因读取超过了写入，

717
00:20:57,070 --> 00:20:59,830
0,900 930,1140 1140,1710 2070,2340 2340,2760
outrun the write,| and the
|然后写入还要继续等待。

718
00:21:00,560 --> 00:21:02,480
0,540 540,810 810,1200 1200,1380 1380,1920
write still has to wait

719
00:21:02,480 --> 00:21:04,610
0,330 540,1110 1110,1440 1590,2010 2010,2130
somehow.| Yes, so so if
|是的，所以如果序列是这样的，

720
00:21:04,610 --> 00:21:06,170
0,90 90,540 540,690 690,1050 1230,1560
the sequence is that,| a
|一个读者设法获得了锁，

721
00:21:06,170 --> 00:21:08,210
0,810 990,1440 1440,1530 1530,1920 1920,2040
reader managed to acquire the

722
00:21:08,210 --> 00:21:09,410
0,510 510,690 690,750 750,930 930,1200
lock,| one or more readers
|一个或多个读者持有锁，

723
00:21:09,410 --> 00:21:10,970
0,120 120,210 210,540 540,870 870,1560
have the locks,| now n,
|现在 n ，它们中的每一个都调用了比较和交换，

724
00:21:11,500 --> 00:21:12,400
0,210 210,300 300,480 480,540 540,900
you know each of them

725
00:21:12,610 --> 00:21:13,720
0,330 330,660 660,780 780,1020 1020,1110
is called a compare and

726
00:21:13,720 --> 00:21:15,010
0,480 510,630 630,720 720,930 930,1290
swap,| you know adds one
|对于每个读者，加 1 到 n ，

727
00:21:15,010 --> 00:21:16,120
0,90 90,450 450,570 570,780 780,1110
to n for each reader,|
|

728
00:21:16,120 --> 00:21:17,110
0,210 210,360 360,570 570,690 690,990
so now n is greater
所以现在 n 大于 0 ，

729
00:21:17,110 --> 00:21:19,060
0,150 150,660 690,960 960,1530
than 0,| because there's
|因为有多个读者，

730
00:21:19,090 --> 00:21:20,770
0,330 330,810 1080,1290 1290,1380 1380,1680
multiple readers,| if a writer
|如果在这一点上，写入者想要获取锁，

731
00:21:20,770 --> 00:21:21,700
0,270 270,360 360,630 630,690 690,930
tries to acquire the lock

732
00:21:21,700 --> 00:21:23,040
0,60 60,270 270,750
at this point,|
|

733
00:21:23,040 --> 00:21:25,530
0,600 840,1350 1350,1950 1950,2370 2370,2490
{} the writer's compare and
写入者的比较和交换，比较值是 0 ，

734
00:21:25,530 --> 00:21:27,660
0,810 900,1140 1140,1680 1680,2040 2040,2130
swap, the compare value is

735
00:21:27,660 --> 00:21:29,040
0,480 510,720 720,1020 1020,1110 1110,1380
0,| so compare and swap
|所以，比较和交换会将 n 更改为 -1 ，

736
00:21:29,040 --> 00:21:30,570
0,150 300,840 840,1260 1260,1440 1440,1530
will only change n to

737
00:21:30,570 --> 00:21:32,790
0,390 390,1080 1290,1770 1770,1890 1890,2220
{-1 -},| if its current
|只有它的当前值是 0 。

738
00:21:32,790 --> 00:21:34,260
0,330 330,450 450,960
value is 0.|
|

739
00:21:34,350 --> 00:21:35,190
0,150 150,240 240,390 390,510 510,840
But we know the current,|
但是我们知道当前值，|

740
00:21:35,190 --> 00:21:37,680
0,210 210,570 630,1080 1080,1980 2310,2490
because there's multiple readers,| the
因为有多个读者，|所以 n 的当前值不是 0 ，

741
00:21:37,680 --> 00:21:38,490
0,210 210,450 450,510 510,690 690,810
current value of n is

742
00:21:38,490 --> 00:21:39,540
0,180 180,750 750,870 870,960 960,1050
not 0,| and so the
|所以比较并交换会失败，并返回 0 ，

743
00:21:39,540 --> 00:21:41,460
0,540 540,690 690,1380
{compare,and,swap} will fail

744
00:21:41,460 --> 00:21:42,750
0,240 240,540 540,870 870,1050 1050,1290
and returns zero,| then the
|然后写者在这个循环中，

745
00:21:43,170 --> 00:21:45,060
0,660 810,1260 1290,1650 1650,1800 1800,1890
writer will sit here in

746
00:21:45,060 --> 00:21:46,360
0,180 180,780
this loop,|
|

747
00:21:46,360 --> 00:21:47,950
0,570 570,930 930,1260 1260,1410 1410,1590
basically waiting until n is
等待 n 等于 0 ，

748
00:21:47,950 --> 00:21:49,460
0,150 150,270 270,900
equal to 0,|
|

749
00:21:49,620 --> 00:21:50,790
0,300 300,690 690,810 810,1080 1080,1170
{} before it's compare and
在比较和交换成功之前，

750
00:21:50,790 --> 00:21:52,860
0,270 270,390 390,1170 1380,1530 1530,2070
swap will succeed,| and return
|然后返回并将锁交给写入者。

751
00:21:52,860 --> 00:21:53,940
0,210 420,660 660,750 750,990 990,1080
and give the lock to

752
00:21:53,940 --> 00:21:55,060
0,60 60,510
the writer.|
|

753
00:21:55,370 --> 00:21:56,360
0,300 300,510 510,780 780,930 930,990
So this certainly means the
所以这当然意味着写者可能会饥饿，

754
00:21:56,360 --> 00:21:58,180
0,210 210,330 330,420 420,1140
writer can be starved,|
|

755
00:21:58,460 --> 00:21:59,750
0,240 240,300 300,600 600,690 690,1290
there's a lot of readers
有很多读者，可能永远不会是 0 ，

756
00:21:59,750 --> 00:22:00,890
0,210 210,360 360,600 600,690 690,1140
and may never be 0|
|

757
00:22:00,890 --> 00:22:01,700
0,240 240,420 420,480 480,720 720,810
and so the write may
因此写者可能永远不会成功，

758
00:22:01,700 --> 00:22:02,630
0,240 240,600 600,720 720,870 870,930
never succeed,| so that's a
|所以这是这个锁方案的一个缺陷。

759
00:22:02,630 --> 00:22:04,010
0,510 510,570 570,720 720,1050 1050,1380
defect in this locking scheme.|
|

760
00:22:06,270 --> 00:22:08,940
0,450 450,900 1710,2220 2220,2520 2520,2670
Thank you.| I also have
谢谢。|我也有一个问题，

761
00:22:08,940 --> 00:22:10,710
0,240 240,780 780,1140 1140,1620 1650,1770
a question| about the the
|关于我刚才提到的两个读者的场景，

762
00:22:10,710 --> 00:22:12,570
0,330 330,750 750,1230 1230,1560 1560,1860
two readers scenario that I

763
00:22:12,570 --> 00:22:14,000
0,240 240,780
just mentioned,|
|

764
00:22:14,650 --> 00:22:16,240
0,300 330,1170 1170,1320 1320,1440 1440,1590
it appears that in the
似乎在最坏的情况下，

765
00:22:16,240 --> 00:22:19,030
0,540 540,1500 1590,2070 2100,2610 2610,2790
worst case,| the reader that
|第二个到达的读者必须经历循环的另一次迭代

766
00:22:19,030 --> 00:22:20,410
0,420 420,900 900,1110 1110,1200 1200,1380
arrives second has to go

767
00:22:20,410 --> 00:22:22,210
0,300 300,870 1110,1590 1590,1710 1710,1800
through another iteration of the

768
00:22:22,210 --> 00:22:26,230
0,660 1230,2130 2160,2700 2700,3540 3810,4020
loop,| sounds somewhat wasteful,| I
|听起来有点浪费，|我想知道这是否适用于 n 个写者。

769
00:22:26,230 --> 00:22:27,880
0,330 330,450 450,660 660,1440 1440,1650
wonder if this generalizes to

770
00:22:27,880 --> 00:22:30,400
0,510 510,1290 1320,1470 1470,1980 1980,2520
n writers.| It's {certainly,does}.| They
|当然可以。|它们都丢失，并重新开始。

771
00:22:30,400 --> 00:22:31,570
0,180 180,360 360,480 480,660 660,1170
all have to get lost

772
00:22:31,570 --> 00:22:32,920
0,180 180,270 270,510 510,930 1140,1350
and {} start again.| You
|你指出了为什么人们不喜欢这个方案，

773
00:22:32,920 --> 00:22:34,870
0,270 270,390 390,960 1470,1770 1770,1950
put your finger on why

774
00:22:34,870 --> 00:22:37,450
0,570 780,1470 1470,1710 1710,1860 1860,2580
people don't like this scheme,|
|

775
00:22:38,050 --> 00:22:40,030
0,660 660,1470 1500,1680 1680,1770 1770,1980
{} if there's a lot
如果有很多同步的读者，

776
00:22:40,030 --> 00:22:42,490
0,90 90,930 930,1320 1620,2100 2280,2460
of simultaneous reader,| {} and
|所以出于你刚才提到的原因，

777
00:22:42,490 --> 00:22:44,410
0,150 150,660 990,1470 1470,1560 1560,1920
so for for the reason

778
00:22:44,410 --> 00:22:45,640
0,120 120,360 360,870
you just mentioned,|
|

779
00:22:47,460 --> 00:22:49,170
0,300 300,750 1050,1380 1380,1530 1530,1710
{r_lock -}, even if there's
r_lock ，即使根本没有写者，

780
00:22:49,170 --> 00:22:50,460
0,150 150,510 510,600 600,1080 1110,1290
no writers at all,| if
|如果有很多读者，在很多核心的读者，

781
00:22:50,460 --> 00:22:52,170
0,150 150,390 390,510 510,1440 1440,1710
there's lots of readers, readers

782
00:22:52,170 --> 00:22:54,390
0,120 120,360 360,1110 1230,1680 1680,2220
on many cores,| {r_lock -}
|r_lock 可能非常非常昂贵，

783
00:22:54,420 --> 00:22:56,790
0,150 150,300 300,870 870,1350 1350,2370
can be very very expensive,|
|

784
00:22:57,180 --> 00:23:00,060
0,540 720,1380 1860,2400 2400,2700 2700,2880
{} and {} one thing
关于 r_lock 方案，有一件事你需要知道，

785
00:23:00,060 --> 00:23:01,290
0,90 90,210 210,270 270,480 480,1230
you need to know about

786
00:23:01,290 --> 00:23:02,580
0,150 150,360 360,660 660,990 1020,1290
{r_lock -} scheme,| which I
|我想我们已经在课堂上提到过，

787
00:23:02,580 --> 00:23:04,260
0,240 450,1080 1080,1260 1260,1620 1620,1680
think we've already mentioned in

788
00:23:04,260 --> 00:23:07,580
0,630 630,930 2100,2760
{class,is} that {},|
|

789
00:23:07,760 --> 00:23:09,110
0,150 150,180 180,420 420,600 600,1350
on a {multi-core -} system,
在多核系统上，每个核都有关联的缓存，

790
00:23:09,140 --> 00:23:11,120
0,450 450,1380
every core

791
00:23:11,180 --> 00:23:13,190
0,270 270,480 480,570 570,1140 1140,2010
{} has an associated cache,|
|

792
00:23:14,260 --> 00:23:15,550
0,210 210,570 570,720 720,960 960,1290
we'll say {L1 -} cache,|
我们假设 L1 缓存，|

793
00:23:15,550 --> 00:23:16,480
0,150 150,330 330,600 600,780 780,930
so each core has a
因此每个内核都有一些缓存内存，

794
00:23:16,480 --> 00:23:18,490
0,120 120,180 180,570 570,1140 1530,2010
bit of cache memory {},|
|

795
00:23:18,760 --> 00:23:19,960
0,300 300,630 630,870 870,960 960,1200
and whatever reads or writes
不管读或写什么，

796
00:23:19,960 --> 00:23:22,200
0,690 1080,1650
something {},|
|

797
00:23:22,820 --> 00:23:24,080
0,510 510,570 570,660 660,1080 1080,1260
it's in the cache,| so
它在缓存中，|所以可能有许多核心，

798
00:23:24,080 --> 00:23:24,770
0,120 120,240 240,330 330,600 600,690
there may be lots and

799
00:23:24,770 --> 00:23:26,120
0,180 180,270 270,990 990,1170 1170,1350
lots of cores,| and there's
|这里有一种互连网络，

800
00:23:26,120 --> 00:23:28,820
0,270 270,570 570,930 1500,2100 2100,2700
some kind of interconnect network,|
|

801
00:23:28,880 --> 00:23:29,870
0,270 270,570 570,630 630,900 900,990
that allows the cores to
允许核心互相交互，

802
00:23:29,870 --> 00:23:31,970
0,270 270,390 390,510 510,900 1260,2100
talk to each other,| because
|因为如果很多核心缓存了一些数据，

803
00:23:31,970 --> 00:23:34,160
0,90 90,690 960,1560 1800,2130 2130,2190
of course if lots of

804
00:23:34,160 --> 00:23:36,230
0,240 240,360 360,510 510,1080 1260,2070
cores have some data cached,|
|

805
00:23:36,290 --> 00:23:37,070
0,240 240,390 390,450 450,510 510,780
and one of the cores
其中一个核心写入那个数据，

806
00:23:37,070 --> 00:23:38,930
0,390 390,630 630,1080 1320,1560 1560,1860
writes that data,| the writing
|写入核心必须告诉其他核心，

807
00:23:38,930 --> 00:23:40,040
0,180 180,540 540,660 660,960 960,1110
core has to tell the

808
00:23:40,040 --> 00:23:41,270
0,210 210,690 690,810 810,960 960,1230
other cores,| that they're not
|它们不允许再缓存那个数据，

809
00:23:41,270 --> 00:23:42,260
0,240 240,300 300,600 600,720 720,990
allowed to cache the data

810
00:23:42,260 --> 00:23:44,390
0,540 660,750 750,870 870,1230 1260,2130
anymore,| it is called invalidation.|
|这叫做无效化。|

811
00:23:45,220 --> 00:23:46,440
0,630

812
00:23:46,710 --> 00:23:49,290
0,540 1650,1830 1830,2070 2070,2460 2460,2580
So what actually happens if
那么，如果你有 n 个读者，会发生什么，

813
00:23:49,290 --> 00:23:51,040
0,150 150,330 360,990
you have n

814
00:23:51,240 --> 00:23:53,610
0,990 1290,1560 1560,1830 1830,2160 2160,2370
readers,| and people calling {r_lock
|人们几乎同时在 n 个内核上调用 r_lock 。

815
00:23:53,610 --> 00:23:54,960
0,540 630,810 810,1020 1020,1110 1110,1350
-} at about the same

816
00:23:54,960 --> 00:23:58,500
0,330 330,480 480,720 720,1530
time on n cores.|
|

817
00:23:58,780 --> 00:24:01,150
0,210 210,420 420,720 720,1500 1620,2370
They're all gonna read n,
它们都将读取 n ，抱歉，这个 l->n 值，

818
00:24:01,450 --> 00:24:03,340
0,300 300,600 600,1140 1140,1410 1410,1890
sorry this {l->n -} value,|
|

819
00:24:03,700 --> 00:24:06,100
0,450 450,1260 1470,1680 1680,1980 1980,2400
and load this memory location
并将这个内存位置加载到它们的缓存中。

820
00:24:06,100 --> 00:24:07,840
0,210 210,360 360,1260
into their caches.|
|

821
00:24:07,840 --> 00:24:09,000
0,630

822
00:24:10,110 --> 00:24:11,220
0,180 180,270 270,450 450,690 690,1110
They're all gonna call compare
它们都会调用比较并交换，

823
00:24:11,220 --> 00:24:12,640
0,120 120,900
and swap,|
|

824
00:24:13,900 --> 00:24:14,890
0,360 360,510 510,780 780,870 870,990
what the first one to
第一个调用比较并交换的将修改数据，

825
00:24:15,100 --> 00:24:16,660
0,450 450,660 660,990 990,1080 1080,1560
actually call compare and swap

826
00:24:16,810 --> 00:24:18,040
0,180 180,300 300,360 360,1080 1080,1230
is going to modify the

827
00:24:18,040 --> 00:24:19,330
0,420 450,630 630,810 810,1110 1110,1290
data,| but in order to
|但为了修改数据，

828
00:24:19,330 --> 00:24:20,380
0,420 420,510 510,750 750,960 960,1050
modify the data| has to
|必须使所有其他副本无效，

829
00:24:20,380 --> 00:24:22,360
0,690 690,780 780,990 990,1170 1170,1980
invalidate all these other copies,|
|

830
00:24:22,540 --> 00:24:24,310
0,210 210,510 780,1080 1080,1560 1560,1770
and so the {compare,and} swap
所以，比较并交换指令，

831
00:24:24,310 --> 00:24:25,660
0,420 420,570 570,990 990,1230 1230,1350
instruction that,| one has to
|第一，必须通过这个小网络发送无效化消息，

832
00:24:25,660 --> 00:24:27,370
0,300 300,480 480,600 600,1350 1350,1710
send out an invalidate message

833
00:24:27,370 --> 00:24:28,930
0,180 180,360 360,540 540,1140 1290,1560
over this little network| to
|到其他 n 个核心的每一个，

834
00:24:28,930 --> 00:24:29,770
0,210 210,270 270,390 390,600 600,840
each of the other n

835
00:24:29,770 --> 00:24:32,320
0,1020 1650,2070 2130,2340 2340,2460 2460,2550
cores, right,| and then it
|然后它返回所有其他核心， n 减去 1 个核心，

836
00:24:32,320 --> 00:24:33,760
0,660 660,810 810,960 960,1110 1110,1440
returns all the other cores,

837
00:24:33,760 --> 00:24:34,960
0,120 120,270 270,540 540,810 810,1200
the n minus 1 cores,|
|

838
00:24:34,960 --> 00:24:35,820
0,120 120,390
they have,
他们的比较并交换必须重新读取，

839
00:24:35,820 --> 00:24:37,200
0,330 330,510 510,840 840,1230 1230,1380
{} their {compare,and} swaps now

840
00:24:37,200 --> 00:24:39,520
0,270 270,360 360,510 510,1650
actually have {re-read -}|
|

841
00:24:39,520 --> 00:24:41,020
0,330 330,840 840,1260 1260,1410 1410,1500
again requiring traffic over the
再次通过网络获取流量，

842
00:24:41,020 --> 00:24:44,020
0,390 420,1320
network,| re-read
|重新读取这个内存位置的数据，

843
00:24:44,140 --> 00:24:46,150
0,330 330,870 900,1110 1110,1380 1380,2010
this data, this memory location,|
|

844
00:24:46,570 --> 00:24:48,130
0,480 510,930 930,1050 1050,1410 1410,1560
{} compared with {x,they} have
与 x 相比，他们失败了，

845
00:24:48,130 --> 00:24:49,360
0,480 480,690 690,810 810,960 960,1230
failed,| because they all call
|因为他们都使用 0 调用 x ，

846
00:24:49,360 --> 00:24:51,250
0,180 180,300 300,720 1290,1800 1800,1890
x with 0,| then the
|然后剩余的 n 减去 1 的读者返回到循环的顶部，

847
00:24:51,250 --> 00:24:52,840
0,450 450,660 660,960 960,1230 1230,1590
remaining n minus 1 readers

848
00:24:52,840 --> 00:24:53,590
0,120 120,330 330,420 420,480 480,750
go back to the top

849
00:24:53,590 --> 00:24:54,490
0,60 60,360 360,450 450,750 750,900
of loop,| and all n
|所有的 n 减去 1 再次读取数据，

850
00:24:54,490 --> 00:24:55,600
0,330 330,480 480,570 570,720 720,1110
minus 1 of them again

851
00:24:55,600 --> 00:24:57,280
0,240 240,300 300,780 1050,1440 1440,1680
read the data,x| and again
|再次它们中的一个写入，

852
00:24:57,280 --> 00:24:58,480
0,240 240,330 330,480 480,870 870,1200
one of them writes it,

853
00:24:59,610 --> 00:25:01,560
0,210 210,450 450,780 960,1650 1770,1950
right,| so on each, so
|所以，这里有 n 次循环，

854
00:25:01,560 --> 00:25:02,370
0,120 120,240 240,300 300,480 480,810
there's going to be n

855
00:25:02,370 --> 00:25:03,810
0,510 510,690 690,810 810,1200 1200,1440
times through the loop,| once
|每个核心试着获取锁，

856
00:25:03,810 --> 00:25:05,040
0,150 150,720
for each

857
00:25:05,040 --> 00:25:06,180
0,390 390,630 630,690 690,1020 1020,1140
core trying to acquire the

858
00:25:06,180 --> 00:25:08,220
0,570 1080,1380 1380,1470 1470,1650 1650,2040
lock,| each of those [trips]
|这个循环中的每一次

859
00:25:08,220 --> 00:25:09,660
0,180 180,300 300,930
through the loop|
|

860
00:25:10,060 --> 00:25:12,670
0,750 930,1290 1290,1710 1710,2130 2130,2610
involves {} order n messages
都涉及网络上的 n 个消息，

861
00:25:12,670 --> 00:25:13,720
0,120 120,210 210,570 570,900 900,1050
on the network,| because at
|因为至少 l->n 缓存的每个副本都必须无效。

862
00:25:13,720 --> 00:25:15,190
0,510 540,900 900,1290 1290,1380 1380,1470
least every copy of the

863
00:25:15,190 --> 00:25:16,780
0,660 720,1020 1020,1230 1230,1350 1350,1590
cached {l->n - - -}

864
00:25:16,780 --> 00:25:18,640
0,210 210,300 300,390 390,1290
has to be invalidated.|
|

865
00:25:18,640 --> 00:25:19,740
0,480

866
00:25:20,320 --> 00:25:21,550
0,330 330,480 480,720 720,900 900,1230
And that means that the
这意味着 n 个核心获取锁的总成本，

867
00:25:21,880 --> 00:25:24,430
0,420 420,1230 1260,1530 1530,1950 1950,2550
total cost for n cores

868
00:25:24,430 --> 00:25:27,040
0,150 150,990 1140,1500 1500,1950 1950,2610
to acquire a particular lock,|
|

869
00:25:27,880 --> 00:25:29,860
0,360 360,600 600,1140 1260,1620 1620,1980
even for reading is order
即使对于读取来说，也是 n 阶的，

870
00:25:29,860 --> 00:25:30,840
0,360
n,|
|

871
00:25:31,510 --> 00:25:33,070
0,570 930,1200 1200,1380 1380,1470 1470,1560
{} that means as you
这意味着当你增加流行数据的核心数量时，

872
00:25:33,070 --> 00:25:34,420
0,300 300,360 360,570 570,660 660,1350
increase the number of cores

873
00:25:34,420 --> 00:25:35,620
0,270 270,420 510,900 900,1110 1110,1200
for a popular piece of

874
00:25:35,620 --> 00:25:39,370
0,450 720,1470 1710,2460 2550,2910 2910,3750
data,| the cost for everybody
|每个只锁一次的费用上升，

875
00:25:39,370 --> 00:25:42,320
0,420 420,840 840,1560 1680,2370
{lock,it} just once {}

876
00:25:42,770 --> 00:25:44,660
0,300 300,540 540,900 900,1260 1260,1890
goes up,| sorry, {order,n} squared,|
|抱歉，阶数 n 的平方，|

877
00:25:46,560 --> 00:25:48,810
0,240 240,600 600,1290 1350,1560 1560,2250
the total cost and time
总成本或时间，或通过这个互连发送的是 n 的平方。

878
00:25:49,440 --> 00:25:51,150
0,570 570,720 720,1230 1230,1500 1500,1710
{} or messages sent over

879
00:25:51,150 --> 00:25:52,800
0,270 270,750 750,870 870,1020 1020,1650
this interconnect is n squared.|
|

880
00:25:54,280 --> 00:25:54,910
0,150 150,270 270,330 330,390 390,630
And this is a very
这是一笔非常糟糕的决定，

881
00:25:54,910 --> 00:25:57,040
0,300 300,780 1440,1770 1800,2010 2010,2130
bad deal, right,| you would
|你希望，

882
00:25:57,040 --> 00:25:58,000
0,330 330,540 540,630 630,750 750,960
hope that,| if you needed
|如果你需要做一件事十次，

883
00:25:58,000 --> 00:25:59,710
0,90 90,210 210,570 570,840 840,1710
to do something ten times,|
|

884
00:25:59,710 --> 00:26:00,580
0,90 90,180 180,420 420,660 660,870
you know ten different cores
十个不同的核心需要做一些事情，

885
00:26:00,580 --> 00:26:02,650
0,210 210,270 270,420 420,1020 1170,2070
needed to do something,| especially
|特别是它们只是在读取列表，

886
00:26:03,070 --> 00:26:04,570
0,420 420,540 540,720 720,1110 1110,1500
given that they're just reading

887
00:26:04,570 --> 00:26:06,010
0,120 120,570 570,660 660,870 870,1440
the list,| they're not modifying
|它们没有修改，

888
00:26:06,010 --> 00:26:06,910
0,150 270,510 510,690 690,810 810,900
it,| you'd hope that they
|你希望它们真的能并行运行，

889
00:26:06,910 --> 00:26:08,230
0,150 150,390 390,570 570,660 660,1320
could really run in parallel,|
|

890
00:26:08,260 --> 00:26:09,340
0,180 180,330 330,450 450,840 840,1080
that is the total []
这是 16 个核心读取数据的总时间，

891
00:26:09,340 --> 00:26:11,950
0,330 330,690 690,1020 1050,1860 1860,2610
clock time for 16 cores

892
00:26:12,010 --> 00:26:13,990
0,180 180,480 480,1170 1500,1830 1830,1980
to read something,| {} should
|应该与一个核心读取某件东西的总时间相同，

893
00:26:13,990 --> 00:26:14,650
0,90 90,180 180,480 480,570 570,660
be the same as the

894
00:26:14,650 --> 00:26:15,790
0,270 270,480 480,750 750,1020 1020,1140
total [] clock time for

895
00:26:15,790 --> 00:26:17,410
0,240 240,540 540,720 720,1050 1050,1620
one core read something,| because
|因为这是并行性的意思，

896
00:26:17,560 --> 00:26:19,660
0,300 300,540 540,1260 1260,1980 1980,2100
that's getting parallelism means is

897
00:26:19,660 --> 00:26:20,950
0,270 570,780 780,870 870,1020 1020,1290
that,| you can do things
|你可以同时做一些事情。

898
00:26:20,950 --> 00:26:22,200
0,60 60,150 150,420 420,870
at the same time.|
|

899
00:26:22,260 --> 00:26:24,300
0,630 750,1110 1110,1620 1650,1800 1800,2040
{} But here the more
但在这里，更多的内核读取这个，

900
00:26:24,300 --> 00:26:25,140
0,270 270,330 330,480 480,600 600,840
cores are try to read

901
00:26:25,140 --> 00:26:26,670
0,270 270,360 360,540 540,1260 1380,1530
this,| the more expensive the
|获取锁的成本就越高，

902
00:26:26,670 --> 00:26:28,740
0,300 300,870 870,1320 1500,1770 1770,2070
lock acquisition is,| and so
|所以现在的情况是，

903
00:26:29,670 --> 00:26:30,870
0,270 270,510 510,840 840,990 990,1200
what's going on is that,|
|

904
00:26:31,290 --> 00:26:33,570
0,330 330,930 930,1050 1050,1860 2010,2280
this style of locks has
这种类型的锁已转换为对数据的只读访问，

905
00:26:33,570 --> 00:26:35,700
0,570 570,810 810,1110 1110,2010 2040,2130
converted read only access to

906
00:26:35,700 --> 00:26:36,750
0,390 420,540 540,600 600,750 750,1050
data,| you know the list
|这个列表可能已经在缓存里了，

907
00:26:36,750 --> 00:26:38,040
0,120 120,810 810,1140 1140,1230 1230,1290
is probably sitting in the

908
00:26:38,040 --> 00:26:39,870
0,510 510,810 810,1020 1020,1350 1350,1830
cache already,| because nobody's modifying
|因为没有人修改列表。

909
00:26:39,870 --> 00:26:41,670
0,120 120,660 750,1260 1470,1680 1680,1800
the list, right.| So the
|所以对列表的访问可能只需要几十个周期，

910
00:26:41,670 --> 00:26:43,920
0,360 360,1230 1260,1530 1530,1710 1710,2250
actual access to the list

911
00:26:43,920 --> 00:26:44,760
0,210 210,390 390,570 570,630 630,840
might only take a few

912
00:26:44,760 --> 00:26:46,920
0,360 360,1260 1410,1980 1980,2070 2070,2160
dozen cycles,| but if the
|但是如果数据很受欢迎，

913
00:26:46,920 --> 00:26:48,330
0,180 180,330 330,960 990,1260 1260,1410
data is popular,| getting the
|获取锁可能需要数百或数千个周期，

914
00:26:48,330 --> 00:26:50,010
0,660 690,840 840,1050 1050,1620 1620,1680
lock can take hundreds or

915
00:26:50,010 --> 00:26:51,660
0,690 690,780 780,1320 1320,1590 1590,1650
thousands of cycles,| because of
|因为这个 n 平方效应。

916
00:26:51,660 --> 00:26:53,300
0,180 180,360 360,780 780,1380
this n squared effect.|
|

917
00:26:53,390 --> 00:26:54,410
0,180 180,270 270,540 540,690 690,1020
And the fact that instead
并且它不是缓存 x ，

918
00:26:54,410 --> 00:26:55,910
0,120 120,240 240,420 420,810 810,1500
of it being cache x,|
|

919
00:26:56,090 --> 00:26:57,770
0,540 540,900 900,1380 1380,1530 1530,1680
it's these accesses that have
这些访问必须通过总线，这个互连，

920
00:26:57,770 --> 00:26:58,970
0,90 90,210 210,420 420,540 540,1200
to go over the bus,

921
00:26:59,460 --> 00:27:00,990
0,390 390,570 570,1140 1140,1260 1260,1530
{} this interconnect,| in order
|以便无效化，做缓存一致性操作。

922
00:27:00,990 --> 00:27:03,300
0,360 660,1410 1410,1620 1890,2130 2130,2310
to invalidate and do these

923
00:27:03,300 --> 00:27:06,750
0,570 570,1200 1200,2130 2670,3000 3030,3450
cache coherence operations.| So this
|所以这些锁对数据的只读访问变得非常便宜，

924
00:27:06,750 --> 00:27:09,700
0,330 330,840 840,960 960,1590
these locks have turned

925
00:27:09,790 --> 00:27:11,170
0,300 300,540 540,900 930,1170 1170,1380
{} very cheap read only

926
00:27:11,170 --> 00:27:12,250
0,390 390,510 510,780 780,990 990,1080
access to data,| into an
|转换为对这个数据的极其昂贵的读写访问。

927
00:27:12,250 --> 00:27:15,460
0,510 510,1410 1620,2130 2130,2460 2460,3210
extremely expensive read write access

928
00:27:15,460 --> 00:27:17,560
0,480 510,870 870,1560
to this data.|
|

929
00:27:18,360 --> 00:27:19,770
0,270 270,420 420,510 510,900 900,1410
{} And will probably completely
并且可能会完全破坏任何可能的并行性能，

930
00:27:19,770 --> 00:27:22,680
0,600 600,870 870,1290 1290,1920 1950,2910
destroy any possible parallel performance,|
|

931
00:27:23,400 --> 00:27:24,480
0,180 180,360 360,480 480,630 630,1080
if what you were doing,|
如果你在做什么，|

932
00:27:24,480 --> 00:27:26,520
0,450 1110,1350 1350,1590 1590,1890 1890,2040
if the actual data was
如果实际数据很容易读取，

933
00:27:26,520 --> 00:27:28,350
0,300 300,630 630,720 720,1230 1530,1830
fairly simple to read {},|
|

934
00:27:28,470 --> 00:27:30,060
0,360 360,480 480,960 960,1050 1050,1590
lock will dominate and destroy
锁将主导并破坏并行性能。

935
00:27:30,060 --> 00:27:31,700
0,360 360,1230
parallel performance.|
|

936
00:27:33,480 --> 00:27:34,920
0,180 180,330 330,690 690,930 930,1440
So any questions about this
关于这个性能故事，有什么问题吗？

937
00:27:35,190 --> 00:27:38,420
0,1140 1140,1650
performance story?|
|

938
00:27:43,390 --> 00:27:44,410
0,180 180,300 300,360 360,900 900,1020
{} In a sense you
从某种意义上说，读写锁的糟糕性能，

939
00:27:44,410 --> 00:27:46,390
0,270 450,660 660,1170 1170,1830 1830,1980
know the bad performance of

940
00:27:46,390 --> 00:27:49,060
0,240 240,480 480,1200 1470,2100 2280,2670
read write locks| is the
|是 RCU 存在的原因，

941
00:27:49,060 --> 00:27:50,320
0,390 390,510 510,600 600,1170 1170,1260
reason for the existence of

942
00:27:50,320 --> 00:27:53,320
0,150 150,810 1740,2040 2040,2370 2370,3000
{RCU -},| because if this
|因为如果这是有效的，

943
00:27:53,350 --> 00:27:54,860
0,180 180,870
was efficient,|
|

944
00:27:54,860 --> 00:27:57,800
0,570 660,1500 2640,2760 2760,2850 2850,2940
{} then there would be
那么就没有必要比那个做得更好了，

945
00:27:57,800 --> 00:27:59,120
0,120 120,810 840,960 960,1080 1080,1320
no need to do better

946
00:27:59,120 --> 00:28:00,920
0,150 150,480 1110,1410 1410,1680 1680,1800
than that right,| but it's
|但是它的效率非常低。

947
00:28:00,920 --> 00:28:04,730
0,360 360,840 1650,2130 2250,3480 3600,3810
terribly inefficient.| And it's there's
|有两件事正在发生，

948
00:28:04,730 --> 00:28:05,660
0,180 180,390 390,630 630,780 780,930
two things going on,| one
|一个是这个的细节，

949
00:28:05,660 --> 00:28:06,800
0,90 90,210 210,840 840,960 960,1140
is the details of this,|
|

950
00:28:06,800 --> 00:28:07,610
0,240 240,420 420,660 660,720 720,810
so there needs to be
在这个循环中总共需要 n 平方的行程，

951
00:28:07,610 --> 00:28:08,600
0,60 60,450 450,510 510,660 660,990
a total of n squared

952
00:28:08,600 --> 00:28:09,770
0,300 300,450 450,660 660,960 960,1170
trips through this loop,| if
|如果我们有 n 个核心，

953
00:28:09,890 --> 00:28:11,420
0,210 210,330 330,480 480,1290 1320,1530
we have n cores,| sort
|这是一种看待它的方式。

954
00:28:11,420 --> 00:28:12,080
0,60 60,210 210,330 330,420 420,660
of one way of looking

955
00:28:12,080 --> 00:28:13,010
0,150 150,300 510,690 690,840 840,930
at it.| The other way
|另一种看待它的方式是，

956
00:28:13,010 --> 00:28:13,760
0,90 90,360 360,510 510,630 630,750
of looking at it is

957
00:28:13,760 --> 00:28:15,720
0,180 240,720 720,1500
that,| we're writing,|
|我们写入，|

958
00:28:15,780 --> 00:28:17,040
0,360 360,450 450,1080 1080,1170 1170,1260
you know regardless of the
不管这里发生了什么事的细节，

959
00:28:17,040 --> 00:28:18,270
0,510 510,570 570,750 750,1020 1020,1230
details of what's going on

960
00:28:18,270 --> 00:28:20,010
0,420 690,1050 1050,1350 1350,1470 1470,1740
here,| these locks have turned
|这些锁变为只读访问，

961
00:28:20,010 --> 00:28:21,840
0,150 150,420 420,780 780,1680 1710,1830
a read only access,| which
|这可能会缓存，并且速度极快，

962
00:28:21,840 --> 00:28:23,040
0,120 120,240 240,600 600,690 690,1200
could be cached and extremely

963
00:28:23,040 --> 00:28:25,440
0,600 960,1650 1650,1860 1860,2280 2280,2400
fast| into an access that
|进入这样或那样[涉及]写入，

964
00:28:25,440 --> 00:28:27,180
0,330 330,510 510,540 540,1080 1290,1740
one way or another involves

965
00:28:27,180 --> 00:28:28,320
0,150 150,660 690,840 840,900 900,1140
a write,| one or more
|一个或多个写入，

966
00:28:28,320 --> 00:28:30,090
0,720 870,1170 1170,1470 1470,1530 1530,1770
writes,| and writes are just
|而写入比读取要昂贵得多，

967
00:28:30,090 --> 00:28:32,280
0,390 390,540 540,1110 1110,1290 1290,2190
much more expensive than reads,|
|

968
00:28:32,340 --> 00:28:33,420
0,210 210,360 360,720 720,960 960,1080
if we're writing data that
如果我们写入可能与其他内核共享的数据。

969
00:28:33,420 --> 00:28:34,720
0,180 180,270 270,840
might be shared

970
00:28:34,870 --> 00:28:37,630
0,540 780,960 960,1170 1170,2070 2280,2760
{} with other cores.| Because
|因为读取没有修改数据，

971
00:28:37,660 --> 00:28:39,820
0,690 690,1470 1620,1770 1770,1980 1980,2160
a read for data that's

972
00:28:39,820 --> 00:28:40,690
0,150 150,570 570,660 660,780 780,870
not modify,| it can be
|它可以在几个周期内从你的缓存中得到，

973
00:28:40,690 --> 00:28:42,160
0,600 600,720 720,780 780,1020 1020,1470
satisfied in a couple cycles

974
00:28:42,160 --> 00:28:43,180
0,90 90,150 150,330 330,420 420,1020
out of your own cache,|
|

975
00:28:43,480 --> 00:28:44,890
0,240 240,570 630,960 960,1290 1290,1410
a write, any write to
对其他核心缓存的数据的任何写入，

976
00:28:44,890 --> 00:28:46,690
0,480 960,1140 1140,1260 1260,1380 1380,1800
data that may be cached

977
00:28:46,690 --> 00:28:47,740
0,90 90,300 300,750 750,960 960,1050
by other cores,| has to
|必须涉及内核之间的通信以使其他副本无效。

978
00:28:47,740 --> 00:28:50,470
0,630 660,1290 1290,1590 1590,2370 2550,2730
involve communication between cores to

979
00:28:50,470 --> 00:28:52,150
0,630 630,780 780,1350 1380,1620 1620,1680
invalidate other copies.| So no
|所以不管你怎么切分它，

980
00:28:52,150 --> 00:28:53,590
0,390 390,630 630,810 810,1170 1170,1440
matter how you slice it,|
|

981
00:28:54,240 --> 00:28:55,560
0,510 510,600 600,930 930,1020 1020,1320
anything that involves a write
任何涉及写入共享数据的行为都会对性能造成灾难，

982
00:28:55,560 --> 00:28:56,400
0,90 90,360 360,630 630,780 780,840
to share data is a

983
00:28:56,400 --> 00:28:59,580
0,570 570,720 720,1680 2310,2940 2940,3180
disaster for performance,| if you
|否则，你可能只是只读的。

984
00:28:59,580 --> 00:29:00,570
0,420 420,540 540,630 630,750 750,990
otherwise could have been read

985
00:29:00,570 --> 00:29:01,460
0,390
only.|
|

986
00:29:01,550 --> 00:29:02,870
0,150 150,240 240,780 780,930 930,1320
So the details of this
所以这个循环的细节，

987
00:29:02,870 --> 00:29:04,240
0,600
loop,|
|

988
00:29:04,270 --> 00:29:05,560
0,450 450,630 630,690 690,870 870,1290
are sort of less important
没有比写入共享数据那么重要。

989
00:29:05,560 --> 00:29:06,370
0,120 120,180 180,450 450,570 570,810
than the fact that it

990
00:29:06,550 --> 00:29:08,860
0,210 210,330 330,840 1920,2070 2070,2310
did a write to share

991
00:29:08,860 --> 00:29:09,800
0,330
data.|
|

992
00:29:10,100 --> 00:29:11,060
0,270 270,420 420,510 510,780 780,960
So what we're looking for
所以我们要找的是一种方法，

993
00:29:11,060 --> 00:29:12,290
0,120 120,180 180,540 720,1140 1140,1230
is a way| to be
|不需要写入就能读取数据的方法，

994
00:29:12,290 --> 00:29:15,170
0,150 150,330 330,840 840,1410 1980,2880
able to read data without

995
00:29:15,170 --> 00:29:16,460
0,660
writes,

996
00:29:16,940 --> 00:29:17,630
0,360 360,450 450,570 570,630 630,690
right,| we want to be
|我们希望能够在不执行任何写入的情况下扫描列表，

997
00:29:17,630 --> 00:29:19,100
0,120 120,180 180,540 540,750 750,1470
able to scan that list

998
00:29:19,430 --> 00:29:20,720
0,690
{}

999
00:29:20,720 --> 00:29:22,100
0,270 270,420 420,600 600,840 840,1380
without doing any writes,| {what,so,ever},
|不包括任何写入，

1000
00:29:22,100 --> 00:29:23,930
0,540 570,840 840,1530 1530,1680 1680,1830
including any writes,| that might
|可能需要执行某种锁，

1001
00:29:23,930 --> 00:29:24,890
0,120 120,600 600,660 660,810 810,960
be required to do some

1002
00:29:24,890 --> 00:29:26,390
0,180 180,240 240,660 660,960 1380,1500
kind of locking thing,| they
|它们寻找对数据的真正的只读访问。

1003
00:29:26,390 --> 00:29:27,650
0,60 60,240 240,390 390,690 690,1260
were looking for really really

1004
00:29:27,920 --> 00:29:29,270
0,270 270,540 540,930 930,1050 1050,1350
read only access to data.|
|

1005
00:29:32,190 --> 00:29:34,300
0,600 810,1500
Okay {}.|
好的。|

1006
00:29:35,660 --> 00:29:39,710
0,630 960,1170 1170,1410 1410,2310 3420,4050
So {} one possibility, that's
所以有一种可能，

1007
00:29:39,710 --> 00:29:40,820
0,120 120,720 720,840 840,960 960,1110
a possibility,| but it's sort
|但这是一种思维实验，

1008
00:29:40,820 --> 00:29:42,020
0,60 60,120 120,390 390,990 990,1200
of a thought experiment is|
|

1009
00:29:42,530 --> 00:29:43,310
0,150 150,360 360,450 450,510 510,780
we just have the readers
我们只是让读者不用关心加锁，

1010
00:29:43,310 --> 00:29:45,040
0,180 180,450 450,930
not bother locking,|
|

1011
00:29:45,250 --> 00:29:46,540
0,270 270,330 330,990 990,1110 1110,1290
you know occasionally you get
偶尔你很幸运，

1012
00:29:46,540 --> 00:29:47,380
0,300 300,390 390,480 480,750 750,840
lucky| and it turns out
|发现读者可以读到一些东西，

1013
00:29:47,380 --> 00:29:48,820
0,150 150,480 480,600 600,810 810,1440
that readers can read stuff,|
|

1014
00:29:49,780 --> 00:29:50,830
0,180 180,300 300,540 540,930 930,1050
and that only writers need
只有写者才需要加锁。

1015
00:29:50,830 --> 00:29:51,700
0,90 90,390 390,570 570,690 690,870
to lock.| So we'll just
|所以我们做个快速实验看看，

1016
00:29:51,700 --> 00:29:52,690
0,90 90,150 150,390 390,930 930,990
do a quick experiment to

1017
00:29:52,690 --> 00:29:55,630
0,210 210,750 1950,2160 2160,2280 2280,2940
see,| whether we could have
|我们是否可以有一个锁，

1018
00:29:56,280 --> 00:29:58,440
0,180 180,870 900,1350 1500,1860 1860,2160
a lock,| just have readers
|让读者读取列表而不加锁。

1019
00:29:58,440 --> 00:29:59,820
0,150 150,420 420,540 540,960 960,1380
just read the list without

1020
00:30:00,520 --> 00:30:01,920
0,270 270,630 630,810
{} locking it.|
|

1021
00:30:02,100 --> 00:30:03,150
0,300 300,630 630,750 750,870 870,1050
I suppose we have this
我想我们有这个列表，它有一些字符串。

1022
00:30:03,150 --> 00:30:04,260
0,330 330,420 420,540 540,750 750,1110
list and it has some

1023
00:30:04,590 --> 00:30:07,780
0,300 300,1380 1800,2640
{you,know} strings {}.|
|

1024
00:30:11,980 --> 00:30:13,660
0,1080
And,
而且，我们要读取它，

1025
00:30:16,850 --> 00:30:17,900
0,210 210,360 360,540 540,690 750,1050
we're gonna read it,| okay,
|如果没有正确的写入者，就不会出问题，

1026
00:30:17,900 --> 00:30:19,310
0,330 540,1020 1020,1200 1200,1350 1350,1410
so nothing goes wrong if

1027
00:30:19,310 --> 00:30:20,240
0,150 150,270 270,510 510,630 630,930
there's no {writer -}, right,|
|

1028
00:30:20,510 --> 00:30:21,680
0,270 270,450 450,870 870,1080 1080,1170
just read list, it's not
只需要读取列表，不会有问题。

1029
00:30:21,680 --> 00:30:22,730
0,60 60,480 540,840 840,960 960,1050
a problem.| So we have
|所以我们想象有一个写者，

1030
00:30:22,730 --> 00:30:23,810
0,60 60,420 420,600 600,660 660,1080
to imagine there's a writer,|
|

1031
00:30:24,170 --> 00:30:25,880
0,420 420,810 840,1080 1080,1440 1440,1710
{} and there's probably three
可能有三种情况，

1032
00:30:25,880 --> 00:30:27,980
0,990 1020,1470 1500,1770 1770,2010 2010,2100
cases,| if you read a
|如果你读取一个列表，在一些其他内核正在修改列表时，

1033
00:30:27,980 --> 00:30:30,380
0,600 840,1560 1560,1770 1770,1950 1950,2400
list while some other cores

1034
00:30:30,560 --> 00:30:33,300
0,480 630,1230 1230,1440
{} modifying it,|
|

1035
00:30:33,390 --> 00:30:35,100
0,330 330,600 600,1290 1350,1620 1620,1710
so one case is that,|
所以，一种情况是，|

1036
00:30:35,100 --> 00:30:36,300
0,120 120,390 390,510 510,780 780,1200
the writer is just changing
写者只是在改变内容，

1037
00:30:36,300 --> 00:30:37,800
0,90 90,900
the content,|
|

1038
00:30:37,800 --> 00:30:40,560
0,540 750,990 990,1260 1530,2520 2520,2760
{} that is not adding
就是不增加或者删除任何元素，

1039
00:30:40,560 --> 00:30:41,880
0,60 60,360 360,600 600,720 720,1320
or deleting anyone is necessarily,|
|

1040
00:30:41,880 --> 00:30:43,140
0,270 270,540 540,780 780,1170 1170,1260
a writer is changing the
写者将字符串更改为其他字符串。

1041
00:30:43,140 --> 00:30:44,130
0,420 420,480 480,630 630,810 810,990
string to be some other

1042
00:30:44,130 --> 00:30:45,140
0,570
string.|
|

1043
00:30:45,140 --> 00:30:46,370
0,240 240,420 420,600 600,810 810,1230
{} So, one is the
所以，一是，写者改变了内容，

1044
00:30:46,880 --> 00:30:49,130
0,390 390,690 690,750 750,1410 1740,2250
writers changing the content,| two
|二是，写者插入新的列表元素，

1045
00:30:49,130 --> 00:30:50,900
0,210 210,330 330,780 780,1140 1140,1770
is the writer is inserting

1046
00:30:50,900 --> 00:30:52,380
0,60 60,180 180,480 480,900
a new list element,|
|

1047
00:30:53,470 --> 00:30:55,690
0,330 330,420 420,660 660,1260 1920,2220
and the third case is
第三种情况是，写者删除列表元素。

1048
00:30:55,690 --> 00:30:56,710
0,150 150,270 270,540 540,630 630,1020
if the writer is deleting

1049
00:30:56,710 --> 00:30:58,180
0,240 270,540 540,870
a list element.|
|

1050
00:30:58,550 --> 00:30:59,420
0,210 210,270 270,420 420,480 480,870
And I want to examine
我想检查一下这些，

1051
00:30:59,420 --> 00:31:01,560
0,270 270,960 990,1440
these,| because {
|因为我们需要每个 RCU 有一个[故事]，

1052
00:31:02,130 --> 00:31:03,480
0,540 690,810 810,960 960,1020 1020,1350
-} we need a [story]

1053
00:31:03,480 --> 00:31:04,560
0,150 150,480 480,540 540,690 690,1080
for each of {RCU -}|
|

1054
00:31:04,590 --> 00:31:05,370
0,330 330,510 510,570 570,720 720,780
actually kind of has a
每个 RCU 都有一个[故事]。

1055
00:31:05,370 --> 00:31:07,280
0,300 300,450 450,750 750,1020
[story] for each.| So,
|所以，危险，

1056
00:31:07,510 --> 00:31:09,310
0,300 300,1140 1320,1530 1530,1650 1650,1800
the danger,| so I'm just
|所以我只是在说会出什么问题，

1057
00:31:09,310 --> 00:31:10,150
0,150 150,270 270,450 450,630 630,840
talking about what goes wrong,|
|

1058
00:31:10,150 --> 00:31:11,380
0,90 90,420 420,720 720,810 810,1230
if somebody's reading a list
如果有人在读取列表，而另一个核心在写入它，

1059
00:31:11,380 --> 00:31:12,460
0,180 180,390 390,600 600,900 900,1080
while another cores writing it,|
|

1060
00:31:12,820 --> 00:31:14,560
0,450 510,690 690,1170 1170,1560 1560,1740
if the writer wants to
如果写者只想更改这个字符串，

1061
00:31:14,650 --> 00:31:16,900
0,450 450,720 720,1020 1020,1620 2010,2250
just change this string,| then
|那么危险在于读者将读取这个字符串的字节，

1062
00:31:16,900 --> 00:31:17,860
0,90 90,510 510,630 630,780 780,960
the danger is that the

1063
00:31:17,860 --> 00:31:19,630
0,450 450,630 630,720 720,1140 1170,1770
reader will be actually reading

1064
00:31:19,630 --> 00:31:20,890
0,120 120,480 480,570 570,780 780,1260
the bytes of this string|
|

1065
00:31:20,890 --> 00:31:22,240
0,90 90,570 570,930 930,1230 1230,1350
or whatever else is in
或者列表元素中的任何其他内容，

1066
00:31:22,240 --> 00:31:23,680
0,60 60,300 300,660 690,1320 1320,1440
the list element,| while the
|而写者正在修改相同的字节。

1067
00:31:23,680 --> 00:31:25,840
0,540 840,1050 1050,1710 1710,1800 1800,2160
writer is modifying the same

1068
00:31:25,840 --> 00:31:27,310
0,780 960,1170 1170,1320 1320,1380 1380,1470
bytes.| And so if we
|所以如果我们不做些特别的事，

1069
00:31:27,310 --> 00:31:28,630
0,120 120,210 210,420 420,990 1080,1320
don't do anything special,| the
|读者将看到旧字节和新字节的某种混合，

1070
00:31:28,630 --> 00:31:30,190
0,330 330,450 450,630 630,1020 1020,1560
reader will see some mixture

1071
00:31:30,190 --> 00:31:31,630
0,150 150,300 300,600 600,1320 1320,1440
of the old bytes and

1072
00:31:31,630 --> 00:31:32,920
0,90 90,240 240,900
the new bytes,|
|

1073
00:31:32,920 --> 00:31:34,600
0,480 660,990 990,1140 1140,1620 1620,1680
{} and that's probably a
这可能是一场灾难，

1074
00:31:34,600 --> 00:31:35,800
0,720
disaster,|
|

1075
00:31:36,410 --> 00:31:37,160
0,240 240,360 360,570 570,660 660,750
that's one case we have
这是我们要担心的一种情况。

1076
00:31:37,160 --> 00:31:39,350
0,90 90,300 300,630 1110,1560 1560,2190
to worry about.| Another possibility
|另一种可能性是写者插入新元素，

1077
00:31:39,350 --> 00:31:40,130
0,120 120,210 210,300 300,570 570,780
is that the writer is

1078
00:31:40,130 --> 00:31:42,350
0,750 750,900 900,1170 1170,1710 1950,2220
inserting a new element,| of
|当然，这意味着，

1079
00:31:42,350 --> 00:31:43,760
0,330 360,600 600,780 780,1260 1260,1410
course what that means is

1080
00:31:43,760 --> 00:31:45,380
0,360 480,840 840,930 930,990 990,1620
that,| {} you know supposing
|假设写者想要在头部插入新元素，

1081
00:31:46,010 --> 00:31:47,210
0,180 180,450 450,690 690,840 840,1200
the writer wants to insert

1082
00:31:47,210 --> 00:31:47,900
0,90 90,210 210,540 540,600 600,690
the new element at the

1083
00:31:47,900 --> 00:31:48,950
0,420 420,510 510,810 810,930 930,1050
head,| the writers going to
|写者将编造一些新的元素，

1084
00:31:48,950 --> 00:31:50,480
0,240 240,420 570,840 840,990 990,1530
cook up some new element|
|

1085
00:31:50,480 --> 00:31:51,260
0,120 120,210 210,480 480,570 570,780
going to change the head
并改变头指针指向它，

1086
00:31:51,260 --> 00:31:52,250
0,300 300,390 390,660 660,780 780,990
pointer to point to it,|
|

1087
00:31:52,550 --> 00:31:54,350
0,270 270,390 390,480 480,1200 1200,1800
I'm going to change the
我要将新元素更改为指向旧的第一个元素，

1088
00:31:54,500 --> 00:31:55,940
0,450 450,960 960,1050 1050,1350 1350,1440
new element to point at

1089
00:31:55,940 --> 00:31:57,760
0,150 150,660 660,1080 1080,1620
the old first element,

1090
00:31:57,950 --> 00:32:00,460
0,570 1260,1950
right {},|
|

1091
00:32:01,360 --> 00:32:03,300
0,180 180,270 270,630 630,1320
so the danger here,|
所以这里的危险是，|

1092
00:32:03,300 --> 00:32:05,010
0,210 210,360 360,780 780,1440 1440,1710
if a reader reads, reading
如果读者读取列表，当写者在插入，

1093
00:32:05,010 --> 00:32:07,530
0,600 990,1260 1260,1620 1620,2220 2280,2520
list while writers inserting,| is
|也许如果我们真的搞砸了，

1094
00:32:07,530 --> 00:32:10,440
0,210 210,1380 1740,2520 2610,2790 2790,2910
that maybe {} you know

1095
00:32:10,440 --> 00:32:11,460
0,120 120,210 210,420 420,780 780,1020
if we really blow it,|
|

1096
00:32:11,990 --> 00:32:13,400
0,390 390,390
the {}
写者可以将头指针设置为指向新元素，

1097
00:32:15,360 --> 00:32:17,340
0,210 210,900 1110,1410 1410,1860 1860,1980
the writer may set the

1098
00:32:17,340 --> 00:32:18,270
0,300 300,600 600,660 660,870 870,930
head pointer to point to

1099
00:32:18,270 --> 00:32:20,040
0,120 120,270 270,780 960,1680 1680,1770
the new element,| before the
|在新元素初始化之前，

1100
00:32:20,040 --> 00:32:22,200
0,150 150,570 570,1740 1920,2100 2100,2160
new elements initialized,| that is
|这就是为什么它可能包含字符串的垃圾，

1101
00:32:22,200 --> 00:32:23,070
0,210 210,270 270,390 390,450 450,870
why it may be contains

1102
00:32:23,070 --> 00:32:24,750
0,540 540,630 630,720 720,1350 1380,1680
garbage for the string| or
|或一些非法指针作为下一个元素。

1103
00:32:24,750 --> 00:32:27,210
0,330 360,870 870,1590 1950,2280 2280,2460
some illegal pointer {} as

1104
00:32:27,210 --> 00:32:28,800
0,120 120,660 690,1350
the next element.|
|

1105
00:32:29,440 --> 00:32:30,640
0,420 540,690 690,930 930,1050 1050,1200
{} So that's the thing
这就是写者插入时可能出错的地方。

1106
00:32:30,640 --> 00:32:31,750
0,120 120,360 360,510 510,930 930,1110
that could go wrong for

1107
00:32:31,750 --> 00:32:33,320
0,330 330,960
writer's inserting.|
|

1108
00:32:33,980 --> 00:32:35,180
0,150 150,720
So let's,
所以让我们，写者删除，

1109
00:32:36,960 --> 00:32:39,300
0,780 960,1170 1170,1230 1230,1560 1560,2340
{} and the writer's deleting,|
|

1110
00:32:40,750 --> 00:32:42,760
0,600 1200,1650 1650,1770 1770,1830 1830,2010
then, {} you know what
那么，删除元素意味着，

1111
00:32:42,760 --> 00:32:43,510
0,90 90,240 240,330 330,660 660,750
it means to delete an

1112
00:32:43,510 --> 00:32:45,460
0,390 390,540 540,1020 1050,1230 1230,1950
element| is first to change
|比如说删除第一个元素，

1113
00:32:45,460 --> 00:32:46,540
0,120 120,420 420,720 720,780 780,1080
{} {let's,say} deleting the first

1114
00:32:46,540 --> 00:32:47,440
0,270 270,360 360,600 600,660 660,900
element,| we change the head
|我们将头指针更改为指向第二个元素，

1115
00:32:47,440 --> 00:32:48,550
0,390 390,510 510,840 840,930 930,1110
pointer to point to the

1116
00:32:48,550 --> 00:32:50,230
0,390 390,870 930,1230 1230,1380 1380,1680
second element,| and then call
|然后在第一个元素上调用释放，

1117
00:32:50,230 --> 00:32:51,670
0,600 600,690 690,780 780,1080 1080,1440
free on the first element|
|

1118
00:32:51,670 --> 00:32:52,480
0,120 120,450 450,600 600,690 690,810
to return this to the
将其返回到空闲列表，

1119
00:32:52,480 --> 00:32:53,740
0,210 210,780
free list,|
|

1120
00:32:53,800 --> 00:32:56,230
0,480 630,1230 1290,1440 1440,1830 1830,2430
{} and the danger here,|
这里的危险是，|

1121
00:32:56,530 --> 00:32:57,490
0,150 150,210 210,330 330,570 600,960
you know if the reader
如果读者看到新的头指针，那很好，

1122
00:32:57,490 --> 00:32:58,690
0,300 300,360 360,510 510,720 720,1200
sees the new head pointer,

1123
00:32:59,140 --> 00:33:00,220
0,240 240,540 540,630 630,840 840,1080
that's fine,| they're just gonna
|他们只会继续第二个元素，

1124
00:33:00,250 --> 00:33:01,600
0,210 210,390 390,480 480,750 1020,1350
go on to the second

1125
00:33:01,600 --> 00:33:03,520
0,360 360,480 480,600 600,1110 1560,1920
element,| so the first if
|所以，如果读者正在查找第一个元素，

1126
00:33:03,520 --> 00:33:04,960
0,120 120,510 510,810 810,960 960,1440
the reader actually was looking

1127
00:33:04,960 --> 00:33:06,370
0,120 120,210 210,570 570,1110 1170,1410
at the first element| and
|然后写者释放了它，

1128
00:33:06,370 --> 00:33:07,930
0,150 150,270 270,690 690,1230 1230,1560
then the writer freed it,|
|

1129
00:33:08,080 --> 00:33:09,070
0,270 270,330 330,660 660,780 780,990
then the problem we have
那么我们遇到的问题是，

1130
00:33:09,070 --> 00:33:10,090
0,120 120,270 270,420 420,840 840,1020
is| now the readers looking
|现在读者查看空闲列表中的元素，

1131
00:33:10,090 --> 00:33:11,380
0,150 150,630 660,960 960,1200 1200,1290
at element that's on the

1132
00:33:11,380 --> 00:33:13,030
0,300 300,1020 1110,1350 1350,1500 1500,1650
free list,| and could be
|可以被分配用于一些其他用途，

1133
00:33:13,030 --> 00:33:14,530
0,660 660,840 840,1050 1050,1260 1260,1500
allocated for some other use|
|

1134
00:33:14,530 --> 00:33:16,210
0,120 120,810 840,990 990,1200 1200,1680
and overwritten for some completely
并且被重写用于一些完全其他的用途，

1135
00:33:16,210 --> 00:33:17,770
0,240 240,630 660,1110 1110,1230 1230,1560
other use,| while the readers
|当读者还在查看这个元素的时候。

1136
00:33:17,770 --> 00:33:19,030
0,210 210,480 480,570 570,780 780,1260
still looking at this element.|
|

1137
00:33:19,360 --> 00:33:20,260
0,240 240,390 390,450 450,660 660,900
So from the reader point
所以从读者的角度来看，

1138
00:33:20,260 --> 00:33:20,860
0,60 60,180 180,360 360,540 540,600
of view,| now all of
|现在所有的元素突然充满了垃圾，

1139
00:33:20,860 --> 00:33:21,820
0,60 60,270 270,660 660,840 840,960
a sudden elements filled with

1140
00:33:21,820 --> 00:33:23,530
0,630 930,1320 1320,1470 1470,1530 1530,1710
garbage| and said it was
|并说它正在期待，

1141
00:33:23,530 --> 00:33:24,600
0,510
[expecting],|
|

1142
00:33:24,690 --> 00:33:25,860
0,270 270,420 420,510 510,840 840,1170
so that's the third case,
所以这是第三种情况，我们必须。

1143
00:33:25,860 --> 00:33:27,240
0,120 120,300 300,540 540,870
we have to {}.|
|

1144
00:33:27,610 --> 00:33:28,270
0,300 300,360 360,480 480,540 540,660
If we want to have
如果我们想加锁，

1145
00:33:28,270 --> 00:33:30,130
0,570 690,870 870,1020 1020,1230 1230,1860
lock,| we want have absolutely
|我们想要的是对读者绝对没有锁，

1146
00:33:30,130 --> 00:33:32,140
0,210 210,540 540,660 660,1290 1620,2010
no locks for readers,| we
|我们要担心这三种情况。

1147
00:33:32,140 --> 00:33:33,070
0,120 120,240 240,450 450,690 690,930
have to worry about these

1148
00:33:33,070 --> 00:33:36,340
0,240 240,1230 1500,2040 2790,3120 3120,3270
three situations.| {} I'm not
|我不是在说写者和写者之间的问题，

1149
00:33:36,340 --> 00:33:38,530
0,240 240,510 510,1110 1110,1560 1560,2190
talking about writer versus writer

1150
00:33:38,770 --> 00:33:40,210
0,450 450,630 630,840 840,1020 1020,1440
problems here,| because I'm just
|我假设在整节课中，

1151
00:33:40,270 --> 00:33:42,310
0,510 510,600 600,780 780,1470 1470,2040
assuming for this entire lecture,|
|

1152
00:33:42,460 --> 00:33:44,290
0,300 300,690 690,930 930,1170 1170,1830
that writers still use locks,|
写者仍在使用锁，|

1153
00:33:44,320 --> 00:33:46,090
0,420 420,660 660,1080 1080,1590 1590,1770
there's still some ordinary like
这里还有一些普通的像 xv6 的自旋锁，

1154
00:33:46,090 --> 00:33:47,290
0,180 180,330 330,570 570,840 840,1200
{xv6 - -} style spin

1155
00:33:47,290 --> 00:33:49,840
0,300 300,720 750,1050 1050,1950 2040,2550
lock here,| and writers acquire
|写者在做任何事情之前就获得这个锁，

1156
00:33:49,840 --> 00:33:51,340
0,180 180,420 420,720 720,960 960,1500
this lock before doing anything,|
|

1157
00:33:51,430 --> 00:33:53,290
0,360 360,1200 1230,1380 1380,1680 1680,1860
but readers don't require any
但是读者无论如何都不需要任何锁。

1158
00:33:53,290 --> 00:33:54,420
0,210 210,840
locks, whatsoever.|
|

1159
00:33:55,950 --> 00:33:58,000
0,420 420,570 570,720 720,1410
Questions about these dangers?|
关于这些危险，有什么问题？|

1160
00:34:01,940 --> 00:34:03,080
0,480
Okay.|
好的。|

1161
00:34:04,960 --> 00:34:06,040
0,120 120,300 300,390 390,720 750,1080
The point is we can't
关键是我们不能简单地让读者不加锁地读取，

1162
00:34:06,040 --> 00:34:07,420
0,210 210,660 660,900 900,1200 1200,1380
just simply have readers read

1163
00:34:07,420 --> 00:34:09,640
0,120 120,240 240,1020 2010,2130 2130,2220
with no locks,| but it
|但是我们可以解决这个问题，

1164
00:34:09,640 --> 00:34:10,900
0,210 210,270 270,360 360,750
turns out we can

1165
00:34:11,660 --> 00:34:13,730
0,240 240,750 750,990 990,1530 1530,2070
and fix the specific problems,|
|

1166
00:34:13,730 --> 00:34:14,960
0,120 120,270 270,510 510,690 690,1230
and that takes us to
这把我们带到了 RCU 。

1167
00:34:16,370 --> 00:34:17,820
0,240 240,630
{RCU -}.|
|

1168
00:34:19,100 --> 00:34:19,910
0,300 300,390 390,390 390,720 720,810
RCU has a couple of
RCU 有几个想法，

1169
00:34:19,910 --> 00:34:21,110
0,330 330,450 450,570 570,810 810,1200
ideas in it that {},|
|

1170
00:34:21,290 --> 00:34:22,940
0,330 330,450 450,690 690,1110 1500,1650
{RCU - -} is, by
顺便说一句， RCU 是一种并发控制的方法，

1171
00:34:22,940 --> 00:34:24,680
0,90 90,510 840,1170 1170,1320 1320,1740
the way, it's as much

1172
00:34:24,680 --> 00:34:26,000
0,90 90,330 330,450 450,1200 1200,1320
a kind of approach to

1173
00:34:26,000 --> 00:34:28,910
0,660 660,1080 1770,2280 2280,2760 2760,2910
concurrency, {concurrency -} control| as
|因为它是一种特定的算法，

1174
00:34:28,910 --> 00:34:30,680
0,120 120,330 330,570 600,1200 1200,1770
it is a particular algorithm,|
|

1175
00:34:31,340 --> 00:34:32,840
0,210 210,330 330,570 570,660 660,1500
it's a way of structuring
这是一种构建读者和写者的方式。

1176
00:34:33,440 --> 00:34:36,050
0,690 690,1770 1770,2100 2100,2190 2190,2610
approach structuring readers and writers.|
|

1177
00:34:36,050 --> 00:34:37,730
0,150 150,420 990,1440 1440,1560 1560,1680
So that they can get
这样它们可以与读者相处，而不用加锁。

1178
00:34:37,730 --> 00:34:39,860
0,750 1260,1500 1500,1620 1620,1950 1950,2130
along with the readers not

1179
00:34:39,860 --> 00:34:41,500
0,240 240,330 330,540 540,1290
having to take locks.|
|

1180
00:34:42,600 --> 00:34:45,270
0,390 1200,1830 1830,2070 2070,2220 2220,2670
The general game with {read,copy}
读取复制更新的一般游戏是，

1181
00:34:45,270 --> 00:34:45,960
0,300 300,420 420,510 510,630 630,690
update is| we're going to
|我们将修复这三种情况，

1182
00:34:45,960 --> 00:34:47,790
0,390 390,630 630,840 840,1740 1740,1830
fix those three situations,| in
|如果同时有写者的话，读者可能会遇到麻烦，

1183
00:34:47,790 --> 00:34:48,780
0,180 180,480 480,660 660,810 810,990
which readers might get into

1184
00:34:48,780 --> 00:34:51,030
0,510 720,900 900,1200 1290,1770 1800,2250
trouble if there's a concurrent

1185
00:34:51,030 --> 00:34:52,050
0,510 510,690 690,810 810,930 930,1020
writers,| and we're going to
|我们将通过让写者变得更复杂一点来做到这一点。

1186
00:34:52,050 --> 00:34:53,490
0,300 300,510 630,1050 1050,1320 1320,1440
do it by making the

1187
00:34:53,490 --> 00:34:54,330
0,330 330,390 390,570 570,690 690,840
writers a little bit more

1188
00:34:54,330 --> 00:34:57,210
0,870 1200,1800 2280,2460 2460,2760 2760,2880
complicated.| So the writers going
|所以写者会稍微慢一点，

1189
00:34:57,210 --> 00:34:58,410
0,60 60,210 210,330 330,600 600,1200
to end up somewhat slower,|
|

1190
00:34:59,340 --> 00:35:00,330
0,270 270,510 510,630 630,720 720,990
they still need to lock
它们仍然需要加锁并遵守一些额外的规则，

1191
00:35:00,330 --> 00:35:01,800
0,240 240,510 510,690 690,960 960,1470
plus follow some extra rules,|
|

1192
00:35:01,980 --> 00:35:03,180
0,390 390,570 570,690 690,1110 1110,1200
{} but the reward will
但回报是读者的速度将会大大提高，

1193
00:35:03,180 --> 00:35:04,020
0,90 90,210 210,630 630,750 750,840
be the readers will be

1194
00:35:04,020 --> 00:35:06,090
0,540 540,1020 1320,1860 1860,1980 1980,2070
dramatically faster,| because they can
|因为它们可以在没有锁的情况下操作，

1195
00:35:06,090 --> 00:35:07,950
0,360 360,660 660,1230 1230,1350 1350,1860
operate without locks| and without
|也不需要写入内存。

1196
00:35:07,950 --> 00:35:09,440
0,210 210,510 510,990
ever writing memory.|
|

1197
00:35:09,850 --> 00:35:11,240
0,510

1198
00:35:11,770 --> 00:35:13,160
0,390 390,900
Okay, so
好的， RCU 的第一个想法是，

1199
00:35:13,550 --> 00:35:15,170
0,360 360,450 450,750 750,960 960,1620
{} the first big idea

1200
00:35:15,200 --> 00:35:17,880
0,510 900,1140 1140,1380 1380,1740
in {RCU - -}

1201
00:35:18,280 --> 00:35:19,420
0,390
{}

1202
00:35:21,220 --> 00:35:23,300
0,240 240,630
is that,|
|

1203
00:35:23,520 --> 00:35:25,050
0,180 180,360 360,870 930,1170 1170,1530
in that first {} trouble
在我们之前讨论的第一个麻烦的情况下，

1204
00:35:25,050 --> 00:35:26,490
0,570 570,630 630,900 900,1110 1110,1440
situation, we talked about before,|
|

1205
00:35:26,490 --> 00:35:28,020
0,180 180,300 300,660 660,900 930,1530
where the writer is updating
写者更新列表元素，列表元素的内容，

1206
00:35:28,020 --> 00:35:29,760
0,90 90,420 420,1050 1050,1260 1260,1740
a list element, the content

1207
00:35:29,760 --> 00:35:31,680
0,90 90,150 150,420 420,930 1380,1920
of a list element,| we're
|我们要[取消]它，

1208
00:35:32,400 --> 00:35:34,080
0,240 240,360 360,930 930,1410 1410,1680
going to actually outlaw that,|
|

1209
00:35:34,110 --> 00:35:35,040
0,90 90,210 210,270 270,420 420,930
we're going to say writers
我们说写者不允许修改列表元素的内容，

1210
00:35:35,070 --> 00:35:36,900
0,270 270,480 480,1110 1200,1320 1320,1830
are not allowed to modify

1211
00:35:36,900 --> 00:35:39,750
0,150 150,1140 1170,1740 1890,2340 2370,2850
the contents of a list

1212
00:35:39,750 --> 00:35:41,520
0,510 510,1260
elements,| instead
|相反，如果我们有一个这样的链表，有几个元素。

1213
00:35:41,920 --> 00:35:43,090
0,270 270,450 450,570 570,750 750,1170
{} if we have a

1214
00:35:43,930 --> 00:35:45,430
0,600 600,870 870,1050 1050,1380 1380,1500
linked list like this, with

1215
00:35:45,430 --> 00:35:47,160
0,60 60,300 300,390 390,1200
a couple of elements.|
|

1216
00:35:49,170 --> 00:35:50,540
0,780

1217
00:35:51,900 --> 00:35:53,250
0,510 510,630 630,960 960,1260 1260,1350
If a writer wanted to
如果写者想要更新元素 2 的内容，

1218
00:35:53,250 --> 00:35:55,080
0,570 570,660 660,1290 1290,1410 1410,1830
update the content of element

1219
00:35:55,080 --> 00:35:56,280
0,630
2,|
|

1220
00:35:57,240 --> 00:35:58,380
0,540 540,600 600,990 990,1050 1050,1140
instead of changing it in
不是原地修改它，我们不这么做，

1221
00:35:58,380 --> 00:36:00,180
0,570 570,780 780,1110 1110,1500 1590,1800
place, which wouldn't do,| it
|它会调用分配器来分配一个新的元素，

1222
00:36:00,180 --> 00:36:01,470
0,90 90,480 480,840 840,1110 1140,1290
would actually cook up, it

1223
00:36:01,470 --> 00:36:03,120
0,210 210,480 480,570 570,1320 1440,1650
would call the allocator to

1224
00:36:03,120 --> 00:36:06,340
0,420 420,480 480,1350 1770,2670
allocate a new element,|
|

1225
00:36:07,350 --> 00:36:09,810
0,600 810,1140 1140,1440 1560,2340 2340,2460
{} it would initialize the
它将完全初始化元素，

1226
00:36:09,810 --> 00:36:12,330
0,390 390,960 960,1320 1350,1830 1830,2520
element completely,| so whatever new
|所以不管我们想在这里放什么新内容，

1227
00:36:12,330 --> 00:36:14,960
0,990 1320,1560 1560,2160
content you know

1228
00:36:15,180 --> 00:36:16,410
0,120 120,390 390,480 480,660 660,1230
we wanted to put here,|
|

1229
00:36:16,440 --> 00:36:18,210
0,300 300,390 390,630 630,1230 1470,1770
instead the old content,| the
不是老的内容，|写者将在新元素上设置下一个指针，

1230
00:36:18,210 --> 00:36:20,580
0,390 390,810 1170,1770
writer would {}

1231
00:36:20,700 --> 00:36:22,680
0,420 420,510 510,810 810,1440 1740,1980
set the next pointer on

1232
00:36:22,680 --> 00:36:23,820
0,180 180,360 360,810 810,960 960,1140
this new element,| so that
|所以这个新元素现在看起来完全正确了，

1233
00:36:23,820 --> 00:36:24,750
0,180 180,270 270,600 600,780 780,930
this new element is now

1234
00:36:24,750 --> 00:36:27,840
0,900 1080,1530 1530,1950 2400,2640 2640,3090
completely correct looking,| and then
|然后在对 E1 的下一个指针的单次写入，

1235
00:36:27,990 --> 00:36:30,030
0,210 210,240 240,870 870,1410 1800,2040
in a single write to

1236
00:36:30,030 --> 00:36:31,740
0,300 300,390 390,690 690,1230 1560,1710
{E1's -} next pointer,| the
|写者将切换 E1 指向，

1237
00:36:31,740 --> 00:36:33,600
0,330 330,540 570,1500 1500,1560 1560,1860
writer would switch {E1 -}

1238
00:36:33,600 --> 00:36:35,100
0,150 150,510 510,630 630,900 1050,1500
from pointing to the,| from
|从指向 E2 的旧版本，

1239
00:36:35,560 --> 00:36:37,150
0,300 300,720 720,840 840,930 930,1590
{} pointing to the old

1240
00:36:37,180 --> 00:36:38,770
0,330 330,450 450,1080 1140,1350 1350,1590
version of E2,| to pointing
|指向 E2 的新版本。

1241
00:36:38,770 --> 00:36:39,700
0,120 120,210 210,480 480,840 840,930
to the new version of

1242
00:36:39,700 --> 00:36:40,740
0,420
E2.|
|

1243
00:36:40,830 --> 00:36:41,670
0,240 240,300 300,510 510,630 630,840
So the game is instead
所以这个游戏是不原地更新内容，

1244
00:36:41,670 --> 00:36:42,990
0,60 60,480 480,960 960,1020 1020,1320
of updating things in place,|
|

1245
00:36:42,990 --> 00:36:43,860
0,60 60,180 180,240 240,720 720,870
we're going to replace them
我们用相同数据的新版本替换它们。

1246
00:36:43,860 --> 00:36:46,980
0,150 150,330 330,1230 1530,2100 2940,3120
with new versions of the

1247
00:36:46,980 --> 00:36:49,200
0,240 240,660 720,840 840,1200 1530,2220
same data.| And so {}
|所以现在一个读者得到了 E1 ，

1248
00:36:50,390 --> 00:36:52,040
0,300 300,450 450,600 600,1170 1410,1650
so now a reader, you

1249
00:36:52,040 --> 00:36:53,180
0,90 90,540 540,780 780,930 930,1140
know readers got as far

1250
00:36:53,180 --> 00:36:54,470
0,180 180,270 270,660 660,930 930,1290
as {E1 -}| is just
|只是查看 E1 的下一个指针，

1251
00:36:54,470 --> 00:36:55,190
0,210 210,360 360,450 450,600 600,720
looking at {E1's - -}

1252
00:36:55,190 --> 00:36:56,750
0,270 270,690 960,1170 1170,1440 1440,1560
next pointer,| the reader's going
|读者将看到指向 E2 的旧的下一个指针，

1253
00:36:56,750 --> 00:36:57,710
0,60 60,420 420,600 600,720 720,960
to either see the old

1254
00:36:57,710 --> 00:36:58,910
0,270 270,600 600,810 810,1110 1110,1200
next pointer which points to

1255
00:36:58,910 --> 00:37:00,440
0,450 450,540 540,720 720,1080 1080,1530
E2| and that's fine,| because
|这很好，|因为没有人改变 E2 ，

1256
00:37:00,560 --> 00:37:02,360
0,270 270,390 390,720 720,1230 1410,1800
nobody was changing E2,| or
|或者读者会看到新的下一个指针，

1257
00:37:02,360 --> 00:37:03,140
0,90 90,420 420,540 540,600 600,780
the reader's going to see

1258
00:37:03,140 --> 00:37:04,640
0,90 90,1020
the new

1259
00:37:04,640 --> 00:37:06,260
0,360 360,930 1020,1350 1350,1530 1530,1620
next pointer| and look at
|然后看到新的列表元素。

1260
00:37:06,260 --> 00:37:08,600
0,90 90,870 1140,1860
the new {}

1261
00:37:09,570 --> 00:37:12,000
0,510 510,1020 1530,1980 2010,2190 2190,2430
list element.| {} And either
|无论哪种方式，因为写者完全初始化了这个列表元素，

1262
00:37:12,000 --> 00:37:15,030
0,300 300,690 690,1140 1170,2130 2460,3030
way since the writer initial

1263
00:37:15,030 --> 00:37:17,340
0,360 360,960 960,1380 1410,1740 1740,2310
fully initialized this list element,|
|

1264
00:37:17,640 --> 00:37:19,170
0,390 390,660 660,1020 1020,1260 1260,1530
before setting E1's next pointer,|
在设置 E1 的下一个指针之前，|

1265
00:37:19,170 --> 00:37:20,190
0,270 270,450 450,570 570,900 900,1020
either way, the readers going
无论哪种方式，读者都会看到正确的下一个指针，指向 E3 的指针。

1266
00:37:20,190 --> 00:37:21,960
0,90 90,510 510,1080 1080,1530 1530,1770
to see a correct next

1267
00:37:21,960 --> 00:37:23,310
0,450 480,600 600,840 840,930 930,1350
pointer, that points to E3.|
|

1268
00:37:27,450 --> 00:37:28,830
0,510 690,930 930,990 990,1230 1230,1380
{} So the point is
所以重点是读者永远看不到字符串，

1269
00:37:28,830 --> 00:37:29,910
0,120 120,390 390,510 510,720 720,1080
the reader will never see

1270
00:37:29,910 --> 00:37:31,080
0,240 270,690 690,930 930,1110 1110,1170
a string,| that's in the
|在内容被修改的过程中（的字符串）。

1271
00:37:31,080 --> 00:37:32,910
0,450 450,510 510,960 1110,1290 1380,1830
process of being a content

1272
00:37:32,910 --> 00:37:33,660
0,150 150,240 240,300 300,690 690,750
that's in the process of

1273
00:37:33,660 --> 00:37:34,880
0,180 180,780
being modified.|
|

1274
00:37:36,060 --> 00:37:38,900
0,450 720,1350 1350,1770 1770,2280
There's any questions about
对这个特别的想法，有什么问题吗？

1275
00:37:38,930 --> 00:37:41,500
0,510 780,990 990,1500 1500,2040
{} this particular idea?|
|

1276
00:37:45,760 --> 00:37:48,220
0,360 360,630 630,1290 1320,1830
What about the, sorry.|
那这个，抱歉。|

1277
00:37:49,410 --> 00:37:51,180
0,450 450,540 540,810 810,990 990,1770
Okay, I can go ahead,|
好的，我可以先说，|

1278
00:37:51,210 --> 00:37:53,040
0,690 690,1260
will the
E2 和 E3 之间的连接是否会被删除，

1279
00:37:53,040 --> 00:37:54,360
0,90 90,390 390,780 780,1170 1170,1320
the link between E2 and

1280
00:37:54,360 --> 00:37:56,820
0,840 960,1470 1470,1980 1980,2250 2250,2460
E3 be deleted,| or will
|或者它会留在那里，

1281
00:37:56,820 --> 00:37:58,050
0,180 180,300 300,720 720,960 960,1230
it be left there| in
|以防它们以某种方式到达 E2 。

1282
00:37:58,140 --> 00:38:00,540
0,390 390,600 600,750 750,1230 1920,2400
case that are either somehow

1283
00:38:00,540 --> 00:38:02,970
0,450 480,1560 1590,1980 1980,2220 2220,2430
{reached,E2}.| Now, we're just gonna
|现在，我们就不管它了，

1284
00:38:02,970 --> 00:38:05,250
0,270 270,660 1380,1650 1650,2160 2160,2280
leave it,| {well -} I'll
|好的，我会回到这个很棒的问题，

1285
00:38:05,250 --> 00:38:06,360
0,150 150,240 240,600 600,810 810,1110
come to this, this {}

1286
00:38:06,390 --> 00:38:09,300
0,390 390,960 1350,2100 2520,2730 2730,2910
excellent question,| {} and it's
|这实际上是 RCU 最复杂的部分，

1287
00:38:09,300 --> 00:38:10,920
0,300 300,360 360,1170 1200,1560 1560,1620
actually the main piece of

1288
00:38:10,920 --> 00:38:13,110
0,720 720,840 840,990 990,1440 1800,2190
complexity in {RCU -} {},|
|

1289
00:38:13,110 --> 00:38:13,890
0,180 180,270 270,480 480,600 600,780
but for now we're just
但现在我们想象一下 E2 暂时不会出现。

1290
00:38:13,890 --> 00:38:14,940
0,120 120,270 270,690 690,810 810,1050
going to imagine that E2

1291
00:38:14,940 --> 00:38:15,900
0,120 120,390 390,750 750,870 870,960
is left alone for the

1292
00:38:15,900 --> 00:38:16,660
0,510
moment.|
|

1293
00:38:19,400 --> 00:38:21,290
0,180 180,540 540,720 720,1680 1680,1890
The link from {E2,to} E3
从 E2 到 E3 的连接，我们不用担心，对吧，

1294
00:38:21,290 --> 00:38:21,980
0,120 120,270 270,420 420,510 510,690
we don't need to worry

1295
00:38:21,980 --> 00:38:23,150
0,240 240,390 390,750 750,990 990,1170
about it anyway right,| because
|因为这是 E2 的一部分，

1296
00:38:23,150 --> 00:38:24,230
0,210 210,270 270,480 480,570 570,1080
that's a part of E2,|
|

1297
00:38:24,230 --> 00:38:26,660
0,120 120,390 390,870 900,1470 1470,2430
and like in normal implementations,|
就像在正常的实现中，|

1298
00:38:26,660 --> 00:38:28,040
0,120 120,390 390,660 660,930 930,1380
we just free that anyway,|
我们无论如何都要释放它，|

1299
00:38:28,220 --> 00:38:29,600
0,210 210,420 420,690 690,840 840,1380
like with no {RCU -}
比如不涉及 RCU 时，

1300
00:38:29,690 --> 00:38:30,920
0,540 540,630 630,840 840,1020 1020,1230
involved,| we don't ever need
|我们永远不需要担心那个连接，对吧。

1301
00:38:30,920 --> 00:38:32,060
0,120 120,330 330,570 570,810 810,1140
to worry about that link,

1302
00:38:32,060 --> 00:38:33,890
0,360 690,1170 1170,1290 1290,1710 1710,1830
right.| But the danger is
|但危险在于，

1303
00:38:33,890 --> 00:38:35,450
0,390 390,600 600,1020 1020,1440 1440,1560
that,| that just before we
|在我们改变下一个指针之前，

1304
00:38:35,450 --> 00:38:38,120
0,960 1170,1470 1470,1800 1800,2340 2460,2670
changed this next pointer,| that
|一些读者跟随下一个指向 E2 的指针。

1305
00:38:38,120 --> 00:38:39,410
0,240 240,660 660,840 840,1230 1230,1290
some reader had followed the

1306
00:38:39,410 --> 00:38:41,060
0,240 240,510 510,780 780,1230
next pointer to E2.|
|

1307
00:38:41,890 --> 00:38:42,970
0,210 210,510 510,690 690,840 840,1080
So overall what we're worried
总体而言，我们在这里担心的是，

1308
00:38:42,970 --> 00:38:43,930
0,210 210,360 360,450 450,660 660,960
about here is that,| some
|一些核心上的读者现在正在读取 E2 ，

1309
00:38:43,960 --> 00:38:44,890
0,240 240,420 420,540 540,690 690,930
some reader on some cores

1310
00:38:44,890 --> 00:38:46,510
0,300 330,540 540,720 720,1050 1050,1620
actually right now reading E2,|
|

1311
00:38:46,990 --> 00:38:48,640
0,450 810,1050 1050,1200 1200,1380 1380,1650
so we'd better not free
所以我们最好不要释放它。

1312
00:38:48,640 --> 00:38:49,360
0,180
it.|
|

1313
00:38:49,960 --> 00:38:52,120
0,780 810,1260 1740,1980 1980,2100 2100,2160
Right right.| That's what I
好的，好的。|我想这就是我们要说的，

1314
00:38:52,120 --> 00:38:52,990
0,150 150,360 360,510 510,570 570,870
think that's all we're saying

1315
00:38:52,990 --> 00:38:53,890
0,120 120,210 210,360 360,570 570,900
is| you better not free
|你最好不要马上释放 E2 ，

1316
00:38:53,890 --> 00:38:55,480
0,180 180,360 360,810 1200,1470 1470,1590
E2 right away,| just leave
|只是别管它了。

1317
00:38:55,480 --> 00:38:56,480
0,60 60,390
it alone.|
|

1318
00:39:00,020 --> 00:39:01,010
0,450 480,660 660,690 690,870 870,990
{} As a piece of
作为一个术语，

1319
00:39:01,010 --> 00:39:04,700
0,780 1440,2520 2730,3150 3150,3570 3570,3690
jargon,| {} the write,| the
|这个写入，|E1 的下一个指针从旧的 E2 到新的 E2 的交换，

1320
00:39:04,700 --> 00:39:07,310
0,780 780,1260 1380,1620 1620,2220 2220,2610
swap of e {E1's -}

1321
00:39:07,370 --> 00:39:09,260
0,450 450,780 780,1140 1260,1440 1440,1890
next pointer from the {old,E2}

1322
00:39:09,260 --> 00:39:11,270
0,300 300,390 390,570 570,1260 1290,2010
to the new E2 {},|
|

1323
00:39:11,330 --> 00:39:12,620
0,360 360,750 750,870 870,1170 1170,1290
I in my head I
在我的脑海里把这叫做提交写入，

1324
00:39:12,620 --> 00:39:14,120
0,180 180,360 360,450 450,960 960,1500
call this a committing write,|
|

1325
00:39:14,390 --> 00:39:15,420
0,390 390,540
there's a,|
这有一个，|

1326
00:39:15,580 --> 00:39:17,380
0,390 420,630 780,1140 1140,1530 1560,1800
{} this is then part
这个可以工作的部分原因是，

1327
00:39:17,380 --> 00:39:18,010
0,60 60,120 120,330 330,450 450,630
of the reason why this

1328
00:39:18,010 --> 00:39:18,880
0,240 240,330 330,540 570,840 840,870
works is that,| with a
|使用单个提交写入，这是原子的，

1329
00:39:18,880 --> 00:39:20,470
0,540 540,990 990,1200 1200,1350 1350,1590
single committing write, which is

1330
00:39:20,470 --> 00:39:22,810
0,750 810,1170 1170,1260 1260,1890 2040,2340
atomic,| writes to pointers on
|在我们使用的机器上的指针的写入是原子的，

1331
00:39:22,810 --> 00:39:23,860
0,60 60,390 390,540 540,750 750,1050
the machines we use are

1332
00:39:24,380 --> 00:39:25,460
0,480 480,540 540,630 630,900 900,1080
atomic,| in the sense that
|写入指针发生或不发生，

1333
00:39:25,880 --> 00:39:26,810
0,300 300,420 420,720 720,840 840,930
either the write to the

1334
00:39:26,810 --> 00:39:27,800
0,270 270,330 330,690 690,720 720,990
{pointer -} happen or didn't

1335
00:39:27,800 --> 00:39:29,150
0,450 570,720 720,780 780,1200 1200,1350
happen,| from the perspective of
|从读者的角度看，

1336
00:39:29,150 --> 00:39:31,400
0,540 750,1050 1050,1170 1170,1800 1860,2250
readers,| because they're atomic,| basically
|因为它们是原子的，|是一个指令，

1337
00:39:31,400 --> 00:39:33,260
0,270 270,480 480,1320
with one instruction,|
|

1338
00:39:33,260 --> 00:39:34,640
0,300 300,450 450,540 540,780 780,1380
{} with the one atomic
只有一个原子的保存，

1339
00:39:34,670 --> 00:39:36,440
0,600 600,720 720,990 990,1260 1500,1770
store we can,| {} it's
|这是一个普通的保存，

1340
00:39:36,440 --> 00:39:38,160
0,90 90,480 480,810 810,990
an ordinary store,| but
|但它是不可分割的，

1341
00:39:38,540 --> 00:39:41,390
0,510 750,960 960,1620 2130,2520 2520,2850
{} it's indivisible,| {} we
|我们把 E1 切换为指向旧的，

1342
00:39:41,390 --> 00:39:42,470
0,420 420,540 540,690 690,840 840,1080
switch {E1 -} from point

1343
00:39:42,470 --> 00:39:43,840
0,150 150,780
to old,|
|

1344
00:39:44,050 --> 00:39:45,040
0,150 150,360 360,630 630,750 750,990
the next point from pointing
下一个指向旧的那个，

1345
00:39:45,040 --> 00:39:46,000
0,60 60,120 120,360 360,780 840,960
to the old one,| the
|写入的新的版本提交到，

1346
00:39:46,000 --> 00:39:47,050
0,120 120,300 300,600 630,930 930,1050
new one that write is

1347
00:39:47,050 --> 00:39:48,190
0,180 210,420 420,480 480,900 900,1140
what sort of commits us

1348
00:39:48,190 --> 00:39:49,220
0,300
to,|
|

1349
00:39:49,420 --> 00:39:52,030
0,510 630,1020 1020,1080 1080,1740 2220,2610
now using the second version.|
现在使用第二个版本。|

1350
00:39:54,770 --> 00:39:56,630
0,390 750,1290 1290,1440 1440,1590 1590,1860
{} This is a very
这是一种非常基本的技术，

1351
00:39:56,630 --> 00:39:58,730
0,330 330,1050 1050,1350 1350,1980 2010,2100
basic technique,| { -} a
|是 RCU 的一项非常重要的技术，

1352
00:39:58,730 --> 00:40:00,050
0,240 240,660 660,1080 1080,1200 1200,1320
very important technique for {RCU

1353
00:40:00,050 --> 00:40:02,540
0,480 810,1230 1560,2070 2160,2400 2400,2490
-},| and {} what it
|这意味着，

1354
00:40:02,540 --> 00:40:04,070
0,300 300,510 510,840 900,1320 1320,1530
means is that,| {RCU -
|RCU 主要适用于数据结构，

1355
00:40:04,070 --> 00:40:06,740
0,390 390,720 720,1590 1620,2130 2130,2670
-} is really mostly applicable

1356
00:40:06,740 --> 00:40:08,300
0,150 150,450 450,1140 1140,1290 1290,1560
to data structures,| for which
|你可以对它进行单次提交写入。

1357
00:40:08,300 --> 00:40:10,400
0,150 150,270 270,1080 1110,1620 1620,2100
you can have single committing

1358
00:40:10,400 --> 00:40:11,620
0,810
writes.|
|

1359
00:40:11,680 --> 00:40:12,790
0,420 480,690 690,810 810,960 960,1110
So that means there's some
这意味着方案中有一些数据结构相当笨拙，

1360
00:40:12,790 --> 00:40:13,900
0,210 210,600 600,720 720,810 810,1110
data structures which are quite

1361
00:40:13,930 --> 00:40:15,070
0,420 420,510 510,570 570,960 960,1140
awkward in the scheme,| like
|比如双向链表，

1362
00:40:15,070 --> 00:40:17,460
0,180 240,690 690,1050 1050,1740
a doubly linked list,|
|

1363
00:40:17,520 --> 00:40:19,950
0,600 630,960 960,1560 1800,2310 2310,2430
{} where every element is
其中每个元素都从两个不同的指针指向，

1364
00:40:19,950 --> 00:40:21,420
0,360 360,540 540,750 750,1110 1110,1470
pointed to from two different

1365
00:40:21,420 --> 00:40:23,640
0,660 990,1440 1440,1560 1560,1950 1950,2220
pointers,| now we can't get
|现在我们不能通过一次提交写入来删除列表元素，

1366
00:40:23,640 --> 00:40:25,530
0,270 270,420 420,810 1050,1470 1470,1890
rid of a list elements

1367
00:40:25,530 --> 00:40:27,000
0,150 150,210 210,600 600,990 990,1470
with a single committing write,|
|

1368
00:40:27,030 --> 00:40:28,110
0,180 180,330 330,510 510,930 930,1080
because there's two pointers to
因为这里有两个指向它的指针，

1369
00:40:28,110 --> 00:40:29,880
0,150 420,630 630,1140 1350,1530 1530,1770
it,| we can't, on most
|在大多数机器上，我们不能原子地

1370
00:40:29,880 --> 00:40:31,140
0,300 300,390 390,600 600,1140 1140,1260
machines we can't {atomically -}|
|

1371
00:40:31,140 --> 00:40:33,360
0,630 660,930 930,1320 1320,1560 1560,2220
change two different memory locations
同时修改两个不同的内存位置，

1372
00:40:33,360 --> 00:40:34,580
0,60 60,150 150,390 390,780
at the same time,|
|

1373
00:40:34,640 --> 00:40:36,530
0,420 660,990 1080,1560 1560,1800 1800,1890
{} so doubly lists are
所以，双链表对 RCU 并不是那么好。

1374
00:40:36,530 --> 00:40:37,340
0,210 210,330 330,540 540,720 720,810
not so good for {RCU

1375
00:40:37,340 --> 00:40:39,440
0,510 1080,1380 1380,1620 1620,1950 1950,2100
-}.| A data structure that
|好的数据结构是像树一样的，

1376
00:40:39,440 --> 00:40:40,700
0,180 180,420 420,540 540,600 600,1260
is good as a tree,|
|

1377
00:40:40,790 --> 00:40:41,840
0,390 390,510 510,570 570,690 690,1050
and if you have {}
如果你有一个树，

1378
00:40:42,600 --> 00:40:45,120
0,360 390,630 630,1350 1740,1860 1860,2520
{} a tree of {},|
|

1379
00:40:49,430 --> 00:40:50,360
0,210 210,390 390,450 450,750 750,930
a tree of nodes like
像这样的节点树，

1380
00:40:50,360 --> 00:40:51,950
0,480 510,1050 1080,1350 1350,1470 1470,1590
this,| then we can do,|
|然后我们可以做，|

1381
00:40:51,950 --> 00:40:52,940
0,300 300,540 540,750 750,930 930,990
{} suppose we want to
假设我们想要改变，

1382
00:40:52,940 --> 00:40:55,220
0,870 1020,1590 1590,1650 1650,2100 2100,2280
change,| want to modify this
|想要修改这里的值，

1383
00:40:55,220 --> 00:40:56,880
0,390 390,660 660,1140
value down here,|
|

1384
00:40:56,880 --> 00:40:58,620
0,300 300,390 390,510 510,1140
what we can do,|
我们能做的是，|

1385
00:41:00,450 --> 00:41:02,070
0,540 630,840 840,960 960,1470 1500,1620
{} there's some head to
这里有一个指向树的头，

1386
00:41:02,070 --> 00:41:03,420
0,90 90,510 540,1170 1170,1260 1260,1350
the tree,| what we can
|我们能做的是

1387
00:41:03,420 --> 00:41:05,460
0,210 210,360 360,750 750,1350 1680,2040
do is| cook up a
|在这棵树的这部分做一个新的版本，

1388
00:41:05,490 --> 00:41:06,860
0,720
new

1389
00:41:07,270 --> 00:41:08,530
0,210 210,390 390,780 780,1050 1050,1260
a new version of this

1390
00:41:08,530 --> 00:41:09,910
0,240 240,300 300,360 360,630 630,1380
part of the tree here,|
|

1391
00:41:11,010 --> 00:41:12,300
0,300 300,450 450,510 510,810 810,1290
and with a single committing
并且利用对头指针的单个提交写入，

1392
00:41:12,300 --> 00:41:13,860
0,360 360,480 480,630 630,900 900,1560
write to the head pointer,|
|

1393
00:41:13,980 --> 00:41:15,510
0,750 750,870 870,990 990,1170 1170,1530
switch to the new version
切换到树的新版本，

1394
00:41:15,510 --> 00:41:16,380
0,60 60,120 120,510 510,630 630,870
of the tree,| and so
|所以这棵树的新版本，

1395
00:41:16,440 --> 00:41:17,250
0,270 270,420 420,660 660,720 720,810
the new version of the

1396
00:41:17,250 --> 00:41:19,050
0,540 690,1140 1140,1410 1410,1500 1500,1800
tree,| which will you know
|写者将分配，创建，

1397
00:41:19,170 --> 00:41:21,480
0,210 210,510 510,720 930,1800
the writer will allocate,

1398
00:41:21,880 --> 00:41:24,000
0,420 450,690 690,750 750,1620
{} sort of create,|
|

1399
00:41:24,790 --> 00:41:26,060
0,690

1400
00:41:27,260 --> 00:41:29,870
0,390 390,690 690,1410 1410,1830 2130,2610
can actually share for, convenience
可以方便地共享数据结构，

1401
00:41:29,870 --> 00:41:31,670
0,120 120,450 450,1110 1110,1200 1200,1800
{} share structure,| the unmodified
|老的树的未修改的部分，

1402
00:41:31,670 --> 00:41:32,660
0,210 210,300 300,390 390,600 600,990
part with the old tree,|
|

1403
00:41:32,810 --> 00:41:34,010
0,300 300,570 570,720 720,780 780,1200
and then with a single
然后利用单个提交写入，

1404
00:41:34,010 --> 00:41:34,940
0,360 360,630 630,720 720,840 840,930
committing write,| we're going to
|我们将把头指针更改为

1405
00:41:34,940 --> 00:41:36,380
0,390 390,510 510,750 750,1200 1200,1440
change the head pointer to|
|

1406
00:41:36,380 --> 00:41:37,790
0,330 420,750 750,930 930,1290 1290,1410
a tree head pointer to
树的头指针指向新版本。

1407
00:41:37,790 --> 00:41:38,720
0,180 180,270 270,330 330,450 450,930
point to the new version.|
|

1408
00:41:39,660 --> 00:41:40,700
0,540

1409
00:41:42,250 --> 00:41:43,600
0,390 390,510 510,660 660,840 840,1350
But for other data structures,|
但是对于其他数据结构，|

1410
00:41:43,600 --> 00:41:44,320
0,90 90,300 300,480 480,630 630,720
that don't look like the
它们不像树一样，

1411
00:41:44,320 --> 00:41:45,940
0,540 540,960 990,1230 1230,1380 1380,1620
trees,| it's not so easy
|使用 RCU 并不容易。

1412
00:41:45,940 --> 00:41:46,840
0,60 60,390 390,480 480,690 690,900
to use {RCU - -}.|
|

1413
00:41:51,550 --> 00:41:52,740
0,600
Okay,
好的，这是第一个想法。

1414
00:41:53,130 --> 00:41:54,900
0,720 810,1080 1080,1170 1170,1410 1410,1770
{} that's the first idea.|
|

1415
00:41:55,830 --> 00:41:57,540
0,180 180,420 420,1140
Any other questions?|
还有其他问题吗？|

1416
00:42:00,090 --> 00:42:01,320
0,570

1417
00:42:04,020 --> 00:42:05,700
0,150 150,600 600,1110
The second idea.|
第二个想法。|

1418
00:42:12,180 --> 00:42:14,420
0,660

1419
00:42:14,420 --> 00:42:15,950
0,330 330,390 390,480 480,1260 1260,1530
One of the problems with,
这个计划的一个问题，一个潜在的问题就是我。描述，

1420
00:42:15,950 --> 00:42:17,540
0,480 810,960 960,1020 1020,1080 1080,1590
{} one of the potential

1421
00:42:17,540 --> 00:42:20,680
0,870 930,1590 1890,2520
problems with {

1422
00:42:22,340 --> 00:42:23,580
0,570
-}

1423
00:42:24,190 --> 00:42:25,700
0,240 240,540 540,630 630,1080
this scheme I just.

1424
00:42:25,700 --> 00:42:27,040
0,750
described,|
|

1425
00:42:28,380 --> 00:42:29,250
0,300 300,390 390,540 540,750 750,870
and we're gonna cook up
我们要炮制一个新的E2[质数]

1426
00:42:29,250 --> 00:42:30,960
0,30 30,210 210,1170
a new E2

1427
00:42:31,300 --> 00:42:32,770
0,480 480,600 600,1020 1020,1080 1080,1470
[prime]| and what I said
|我说的是，哦，好吧，我们将初始化E2[素数]的内容

1428
00:42:32,770 --> 00:42:34,420
0,210 210,450 450,660 660,930 1020,1650
was oh well we'll initialize

1429
00:42:34,420 --> 00:42:35,530
0,60 60,630 630,780 780,990 990,1110
the content for {E2 -}

1430
00:42:35,530 --> 00:42:37,150
0,570 570,720 720,1050 1290,1500 1500,1620
[prime]| and we'll you know
|我们会知道正确设置它的下一个指针

1431
00:42:37,150 --> 00:42:39,190
0,330 330,480 480,750 750,1050 1050,2040
set its next pointer correctly|
|

1432
00:42:39,250 --> 00:42:41,700
0,450 510,1140 1140,1920
and after that
然后我们将E1的下一个指针设置为指向E2，

1433
00:42:42,300 --> 00:42:43,200
0,150 150,480 480,600 600,780 780,900
we'll set {E1's - -}

1434
00:42:43,200 --> 00:42:44,340
0,300 300,660 660,780 780,1020 1020,1140
next pointer to point to

1435
00:42:44,340 --> 00:42:45,440
0,540
E2,|
|

1436
00:42:45,500 --> 00:42:47,600
0,600 960,1230 1230,1380 1380,1560 1560,2100
{} as you may recall
您可能还记得在讨论xv6时，

1437
00:42:47,600 --> 00:42:49,520
0,570 840,1200 1200,1680 1680,1740 1740,1920
from a discussions of {xv6

1438
00:42:49,520 --> 00:42:51,200
0,120 120,540 780,1080 1080,1500 1500,1680
- -},| by default, there's
|默认情况下，在这些机器上没有该选项。

1439
00:42:51,200 --> 00:42:52,520
0,180 180,510 510,960 960,1080 1080,1320
no after that on these

1440
00:42:52,520 --> 00:42:55,250
0,690 1740,1950 1950,2550 2550,2670 2670,2730
machines.| The compiler and the
|编译器和硬件基本上都是编译器和许多微处理器对内存操作重新排序。

1441
00:42:55,250 --> 00:42:58,340
0,750 1050,1740 1740,1890 1890,2670 2670,3090
hardware, basically all compilers and

1442
00:42:58,490 --> 00:43:03,020
0,450 450,1500 1740,2910 2910,3330 3330,4530
many microprocessors reorder memory operations.|
|

1443
00:43:03,360 --> 00:43:04,580
0,390
So,
所以，如果你简单地说我们分配了一个新元素，

1444
00:43:04,580 --> 00:43:05,840
0,120 120,240 240,960 960,1080 1080,1260
if you simply you know

1445
00:43:05,840 --> 00:43:08,270
0,810 840,1050 1050,1500 1500,1590 1590,2430
say we allocate a new

1446
00:43:09,170 --> 00:43:10,960
0,1200
element,|
|

1447
00:43:11,450 --> 00:43:12,830
0,480 510,690 690,840 840,1200 1200,1380
and we just wrote this
我们刚刚写了这段C代码，你们知道，e->Next等于E3

1448
00:43:12,830 --> 00:43:16,000
0,780 780,960 960,1560 1560,2580
{C,code} {you,know} {e->next -}

1449
00:43:16,480 --> 00:43:19,900
0,1530 1590,1710 1710,1860 1860,2610 3090,3420
equals you know E3| and
|然后e1->Next等于e，

1450
00:43:19,900 --> 00:43:23,230
0,510 960,1110 1110,1920 2070,2430 2430,3330
then {E1->next - - -}

1451
00:43:25,250 --> 00:43:27,290
0,390 420,990 1230,1800 1800,1860 1860,2040
equals e,| this is not
|这不会有好结果的，

1452
00:43:27,290 --> 00:43:28,640
0,120 120,210 210,450 450,1020 1170,1350
going to work well,| it's
|它不会可靠地工作，

1453
00:43:28,640 --> 00:43:29,780
0,120 120,270 270,480 480,990 990,1140
not gonna work reliably,| it's
|当你测试它的时候它会工作的很好，

1454
00:43:29,780 --> 00:43:30,560
0,150 150,300 300,570 570,660 660,780
gonna work fine when you

1455
00:43:30,560 --> 00:43:32,660
0,360 360,660 870,1620 1710,2040 2040,2100
test it,| {} but it
|但它在现实生活中并不总是有效的，

1456
00:43:32,660 --> 00:43:33,770
0,180 180,390 390,480 480,660 660,1110
won't work in real life

1457
00:43:33,770 --> 00:43:35,030
0,180 180,270 270,720 780,1200 1200,1260
all the time,| occasionally it
|偶尔也会出问题。

1458
00:43:35,030 --> 00:43:36,260
0,90 90,240 240,660 660,930 990,1230
will go wrong.| And the
|原因是编译器可能最终重新排序这些写入

1459
00:43:36,260 --> 00:43:38,510
0,330 330,480 480,720 870,1290 1350,2250
reason is that the compiler

1460
00:43:39,460 --> 00:43:40,960
0,270 270,450 450,540 570,1260 1260,1500
may end up reordering these

1461
00:43:40,960 --> 00:43:42,760
0,780 930,1200 1200,1290 1290,1650 1650,1800
writes| or the machine may
|否则，机器可能最终会重新排序这些写入

1462
00:43:42,760 --> 00:43:44,050
0,180 180,300 300,720 720,930 930,1290
end up reordering these writes|
|

1463
00:43:44,050 --> 00:43:45,730
0,360 360,570 570,1020 1020,1470 1470,1680
or the reading code which
或者读取这些不同内容的读取代码。

1464
00:43:45,730 --> 00:43:47,680
0,300 300,510 510,930 930,1650 1740,1950
reads these various things.| The
|编译器或机器，微处理器可能最终重新排序读取器的读取

1465
00:43:47,680 --> 00:43:49,360
0,630 630,780 780,870 870,1560 1590,1680
compiler or the machine, the

1466
00:43:49,360 --> 00:43:51,640
0,750 750,870 870,1050 1050,1260 1290,2280
microprocessor may end up reordering

1467
00:43:51,880 --> 00:43:53,560
0,210 210,660 660,1320 1410,1620 1620,1680
the reader's reads| and of
|当然，如果我们在初始化内容E2之前将E1->设置在点E2的旁边，

1468
00:43:53,560 --> 00:43:55,870
0,540 1290,1650 1650,1740 1740,2100 2130,2310
course if we set {E1->next

1469
00:43:55,870 --> 00:43:57,730
0,240 240,480 480,1290 1500,1620 1620,1860
- - -} to point

1470
00:43:57,730 --> 00:43:59,640
0,210 210,450 450,1500
{E2 -} before

1471
00:43:59,730 --> 00:44:01,140
0,180 180,660 660,720 720,1200 1200,1410
we initialize the content {E2

1472
00:44:01,140 --> 00:44:03,180
0,450 630,900 900,1050 1050,1560 1590,2040
-},| so that it's string
|所以它的字符串包含它的下一个指针，指向空格，

1473
00:44:03,180 --> 00:44:05,360
0,480 480,660 660,930 930,1620
holds its next pointer,

1474
00:44:05,390 --> 00:44:06,920
0,390 420,660 660,810 810,930 930,1530
{} point off into space,|
|

1475
00:44:06,980 --> 00:44:08,180
0,510 510,720 720,1020 1020,1140 1140,1200
then some readers going to
然后一些读者会看到这个指针，紧随其后的是读取垃圾和崩溃。

1476
00:44:08,180 --> 00:44:09,200
0,150 150,300 300,600 600,870 870,1020
see this pointer, follow with

1477
00:44:09,200 --> 00:44:11,320
0,240 240,810 810,930 930,1620
read garbage and crash.|
|

1478
00:44:11,670 --> 00:44:13,410
0,300 360,570 570,810 930,1380 1380,1740
{} So the second idea
所以第二个想法是读者和作者都必须使用记忆屏障，

1479
00:44:13,410 --> 00:44:14,850
0,120 120,300 300,600 600,1050 1050,1440
is that both readers and

1480
00:44:14,850 --> 00:44:16,080
0,420 420,600 600,690 690,840 840,1230
writers have to use memory

1481
00:44:16,080 --> 00:44:17,970
0,840 1200,1530 1530,1740 1740,1830 1830,1890
barriers,| now even though we're
|现在，即使我们没有锁定，或者真的因为我们没有锁定，

1482
00:44:17,970 --> 00:44:20,070
0,150 150,690 1290,1470 1470,1710 1710,2100
not locking or really because

1483
00:44:20,070 --> 00:44:21,520
0,120 120,270 270,870
we're not locking,|
|

1484
00:44:21,520 --> 00:44:22,640
0,510

1485
00:44:22,640 --> 00:44:24,230
0,390 390,510 510,1050 1050,1440 1440,1590
read, the writers and the
读，作者和读者都要用屏障

1486
00:44:24,230 --> 00:44:25,220
0,450 450,660 660,780 780,930 930,990
readers have to use a

1487
00:44:25,220 --> 00:44:27,200
0,570 660,1050 1260,1530 1530,1920 1920,1980
barrier| and for writers the
|而对于作家来说，屏障必须去的地方是在承诺写作之前。

1488
00:44:27,200 --> 00:44:28,220
0,300 300,390 390,720 720,930 930,1020
place the barrier has to

1489
00:44:28,220 --> 00:44:29,720
0,180 180,360 360,900 900,990 990,1500
go is before the committing

1490
00:44:29,720 --> 00:44:30,840
0,540
write.|
|

1491
00:44:30,840 --> 00:44:31,860
0,210 210,300 300,420 420,480 480,1020
So we need a barrier
所以我们这里需要一个屏障，

1492
00:44:31,860 --> 00:44:32,980
0,540
here,|
|

1493
00:44:36,500 --> 00:44:38,570
0,420 420,510 510,1290 1530,1980 1980,2070
tells the hardware and the
告诉硬件和编译器查看此屏障之前的所有写入，

1494
00:44:38,570 --> 00:44:40,760
0,480 480,840 870,1410 1410,1530 1530,2190
compiler look all the writes

1495
00:44:40,790 --> 00:44:43,340
0,570 570,750 750,1470 1590,2040 2040,2550
before this barrier,| please finish
|屏障之后，请先写完，然后再写。

1496
00:44:43,340 --> 00:44:45,290
0,360 540,1050 1140,1410 1410,1620 1620,1950
them before doing any writes

1497
00:44:45,290 --> 00:44:47,060
0,390 390,480 480,1080 1320,1560 1560,1770
after the barrier.| So that
|因此，在我们将E1设置为指向E2之前，E2已完全初始化。

1498
00:44:47,090 --> 00:44:49,250
0,390 390,510 510,840 840,1590 1590,2160
E2 is fully initialized, before

1499
00:44:49,250 --> 00:44:50,360
0,150 150,510 510,750 750,840 840,1110
we set E1 to point

1500
00:44:50,360 --> 00:44:51,560
0,120 120,270 720,960 960,1080 1080,1200
to it.| And on the
|在读取端，读取器需要将E1->NEXT加载到某个临时位置或寄存器中，

1501
00:44:51,560 --> 00:44:52,980
0,270 270,960
read side,

1502
00:44:54,070 --> 00:44:56,080
0,600 720,1140 1140,1470 1470,1800 1800,2010
{} the reader needs to

1503
00:44:56,080 --> 00:44:57,400
0,750
load

1504
00:44:57,490 --> 00:44:59,080
0,210 210,420 420,480 480,780 780,1590
{E1->next - - - -}

1505
00:44:59,140 --> 00:45:01,600
0,300 300,900 1320,1920 1920,2400 2400,2460
into some temporary location or

1506
00:45:01,600 --> 00:45:03,400
0,660 810,1020 1020,1140 1140,1320 1320,1800
register,| so we'll just say
|所以我们就说寄存器1等于E1->下一步，

1507
00:45:03,640 --> 00:45:06,620
0,780 780,1470 1500,2550
register one equals

1508
00:45:06,960 --> 00:45:08,980
0,330 330,570 570,750 750,1440
{E1->next - - -},|
|

1509
00:45:11,280 --> 00:45:12,840
0,450 630,840 840,960 960,1290 1290,1560
{} then the reader needs
那么读者需要一杯屏障，

1510
00:45:12,840 --> 00:45:14,260
0,60 60,870
a barrier,|
|

1511
00:45:16,480 --> 00:45:17,470
0,210 210,390 390,480 480,840 840,990
and then the reader is
然后读者会看到r1->x，它是r1->Next中的内容。

1512
00:45:17,470 --> 00:45:18,580
0,120 120,210 210,480 480,810 840,1110
going to look at {r1->x

1513
00:45:18,580 --> 00:45:19,880
0,720
-

1514
00:45:20,420 --> 00:45:22,820
0,990 1230,1380 1380,2100 2100,2160 2160,2400
-}, it's content in {r1->next

1515
00:45:22,820 --> 00:45:24,620
0,330 330,630 630,1320
- - -}.|
|

1516
00:45:24,790 --> 00:45:25,900
0,180 180,300 300,510 510,960 960,1110
And with this barrier, the
读者说，有了这个屏障，

1517
00:45:25,900 --> 00:45:28,320
0,270 270,690 690,1290
reader says is,|
|

1518
00:45:28,320 --> 00:45:29,790
0,390 420,810 810,1110 1110,1200 1200,1470
don't issue any of these
在我们完成装货之前，不要发出任何这些装货。

1519
00:45:29,790 --> 00:45:31,380
0,1080
loads

1520
00:45:31,380 --> 00:45:33,510
0,240 240,780 810,1470 1470,1650 1650,2130
{} until after we've completed

1521
00:45:33,510 --> 00:45:35,160
0,240 240,810 960,1140 1140,1230 1230,1650
this load.| So the reader's
|所以读者接下来要看E1->

1522
00:45:35,160 --> 00:45:37,160
0,480 810,1560
gonna {}

1523
00:45:37,220 --> 00:45:38,360
0,390 390,510 510,720 720,870 870,1140
look at {E1->next - -}|
|

1524
00:45:38,360 --> 00:45:39,890
0,90 90,480 750,990 990,1080 1080,1530
and either get the {old,E2
要么买旧的E2，要么买新的E2，

1525
00:45:39,890 --> 00:45:40,820
0,300 300,420 420,540 540,780 780,930
-} or the new {E2

1526
00:45:40,820 --> 00:45:43,370
0,570 810,1500 1920,2160 2160,2460 2460,2550
-},| {} and then the
|然后屏障说，只有到那时我们才会开始看，

1527
00:45:43,370 --> 00:45:45,410
0,360 360,750 750,1020 1410,1830 1830,2040
barrier says, that only then

1528
00:45:45,410 --> 00:45:46,040
0,90 90,180 180,300 300,360 360,630
are we going to start

1529
00:45:46,040 --> 00:45:47,960
0,390 390,930 1260,1500 1500,1770 1770,1920
looking at,| only after we've
|只有在我们拿到这个之后。

1530
00:45:47,960 --> 00:45:50,140
0,420 420,930 1140,1680
grabbed this {}.|
|

1531
00:45:51,200 --> 00:45:52,370
0,450 450,690 690,960 960,1080 1080,1170
All these reads have to
所有这些读取都必须在此读取之后执行，

1532
00:45:52,370 --> 00:45:56,270
0,750 780,1440 1440,1710 1710,2760 3600,3900
execute after this read {},|
|

1533
00:45:56,270 --> 00:45:57,560
0,180 180,390 390,510 510,810 810,1290
and since the writer guaranteed
并且由于写入器保证在提交指向新E2的指针之前初始化内容，

1534
00:45:57,560 --> 00:45:59,540
0,90 90,540 540,600 600,1290 1590,1980
to initialize the content {}

1535
00:45:59,540 --> 00:46:00,780
0,690
before

1536
00:46:01,260 --> 00:46:02,460
0,420 420,510 510,840 840,960 960,1200
committing the pointer to {}

1537
00:46:02,460 --> 00:46:03,900
0,120 120,330 330,480 480,990 1170,1440
the new {E2 -} {},|
|

1538
00:46:03,900 --> 00:46:05,400
0,270 270,420 420,630 630,1320 1350,1500
that means these reads, if
这意味着这些读取，如果这个指针指向新的E2，

1539
00:46:05,400 --> 00:46:06,720
0,360 600,900 900,1140 1140,1200 1200,1320
this pointer points to the

1540
00:46:06,720 --> 00:46:08,130
0,150 150,540 600,960 990,1230 1230,1410
new {E2 -},| that means
|这意味着这些读取保证可以看到初始化的内容。

1541
00:46:08,130 --> 00:46:09,150
0,210 210,390 390,450 450,930 930,1020
these reads are guaranteed to

1542
00:46:09,150 --> 00:46:10,920
0,330 330,480 480,930 930,1290
see the initialized content.|
|

1543
00:46:14,950 --> 00:46:16,360
0,1050
Okay,
好的，我们看到了一点。

1544
00:46:17,100 --> 00:46:18,120
0,450 480,690 690,870 870,1020 1020,1020
{} so we saw a

1545
00:46:18,120 --> 00:46:21,240
0,300 300,450 450,2220
little bit.| {How,can,you},
|你怎么能，哦，是的，我只是，我对读者感到困惑，

1546
00:46:21,330 --> 00:46:22,410
0,240 240,450 450,540 540,690 690,1080
oh yeah I was just,

1547
00:46:22,920 --> 00:46:23,760
0,90 90,270 270,570 570,750 750,840
I was confused about the

1548
00:46:23,760 --> 00:46:25,560
0,540 570,1020 1050,1380 1380,1620 1620,1800
reader,| so how, how can
|那么，在你读R1之前，你怎么能像读任何东西一样读r1，r1呢？

1549
00:46:25,560 --> 00:46:28,140
0,390 420,990 1290,2070
you read r1,

1550
00:46:28,380 --> 00:46:30,300
0,270 270,360 360,930 960,1380
{r1 - -} like

1551
00:46:30,300 --> 00:46:32,580
0,540 540,1080 1080,1530 1620,2130 2130,2280
anything before you read {r1

1552
00:46:32,580 --> 00:46:33,640
0,510
-}.|
|

1553
00:46:34,100 --> 00:46:36,920
0,300 300,1050 1380,2490 2490,2670 2670,2820
I guess how how would
我猜他们会怎么，

1554
00:46:36,920 --> 00:46:39,260
0,420 600,1260 1350,1830
they,| so {}
|所以，是的，我想即使它能带来回报，

1555
00:46:39,690 --> 00:46:41,280
0,270 270,360 360,600 600,900 1290,1590
yeah I guess like if

1556
00:46:41,280 --> 00:46:43,230
0,360 360,510 510,780 1020,1680 1680,1950
even if it rewarded that,|
|

1557
00:46:43,230 --> 00:46:44,880
0,660 690,930 930,1170 1170,1410 1410,1650
how, how did be able
如何，如何能够在下一次读取R1之前读取R1 x。

1558
00:46:44,880 --> 00:46:47,520
0,210 210,630 660,1380 1380,1920 2130,2640
to read r1 x before

1559
00:46:47,520 --> 00:46:49,740
0,270 270,750 1140,1290 1290,1770 1770,2220
it read {r1 -} next.|
|

1560
00:46:54,280 --> 00:46:56,230
0,810 810,810 810,1410 1410,1530 1530,1950
You, I think you've stumped
你，我想你把我难倒了。

1561
00:46:56,230 --> 00:46:58,020
0,330 450,1170
me {}.|
|

1562
00:46:59,570 --> 00:47:00,590
0,390 390,480 480,720 720,900 900,1020
Yeah, I mean what were
是的，我是说你刚才指出的是，

1563
00:47:00,590 --> 00:47:01,340
0,90 90,360 360,540 540,630 630,750
you pointing out is that,|
|

1564
00:47:01,340 --> 00:47:02,090
0,240 240,360 360,540 540,630 630,750
before you even know what
在您甚至不知道指针是什么之前，您不可能实际发出读取，

1565
00:47:02,090 --> 00:47:04,100
0,60 60,510 510,1230 1440,1890 1890,2010
the pointer is {} you

1566
00:47:04,100 --> 00:47:05,240
0,210 210,570 570,840 840,1050 1050,1140
can't possibly actually issue the

1567
00:47:05,240 --> 00:47:07,740
0,540 660,1140 1320,1890
reads, the {},|
|

1568
00:47:09,280 --> 00:47:11,140
0,420 420,1290
a possibility
一种可能性是，无论这个指针指向什么，

1569
00:47:11,170 --> 00:47:12,940
0,240 240,690 930,1350 1350,1500 1500,1770
is that whatever this pointer

1570
00:47:12,940 --> 00:47:14,350
0,300 300,420 420,660 660,840 840,1410
points to,| maybe it's already
|也许它已经缓存在这个核心上了，

1571
00:47:14,350 --> 00:47:16,270
0,540 540,660 660,810 810,1470 1650,1920
cached on this core,| due
|因为一些可能这段记忆你知道一分钟前被用来做其他的，完全不同的事情，

1572
00:47:16,270 --> 00:47:17,920
0,90 90,330 330,750 750,1080 1080,1650
to some maybe this memory

1573
00:47:17,920 --> 00:47:19,700
0,120 120,690 780,930 930,1230
had been you know

1574
00:47:19,700 --> 00:47:20,510
0,60 60,270 270,480 480,720 720,810
a minute ago used for

1575
00:47:20,510 --> 00:47:22,160
0,300 300,540 540,750 750,1170 1170,1650
something else, something totally else,|
|

1576
00:47:22,340 --> 00:47:24,020
0,420 420,600 600,990 1140,1380 1380,1680
and we have an old
我们有一个旧版本的高速缓存我们的核心，

1577
00:47:24,020 --> 00:47:25,310
0,330 330,420 420,600 600,900 900,1290
version of this cache our

1578
00:47:25,310 --> 00:47:28,610
0,450 840,1800 1800,2550 2550,2670 2670,3300
core,| {} at the address
|在该地址处的地址，但是对于存储器的某些先前使用，

1579
00:47:28,610 --> 00:47:30,050
0,180 180,360 360,870 870,1110 1230,1440
at this address, but for

1580
00:47:30,050 --> 00:47:30,890
0,150 150,540 540,720 720,780 780,840
some previous use of the

1581
00:47:30,890 --> 00:47:33,800
0,600 660,1320 1470,2040 2070,2490 2490,2910
memory,| {} if this read
|如果该读取要使用旧的高速缓存值，

1582
00:47:33,800 --> 00:47:35,720
0,210 210,330 330,960 960,1380 1440,1920
was to use the old

1583
00:47:35,720 --> 00:47:37,380
0,480 480,1260
cache value,|
|

1584
00:47:37,670 --> 00:47:38,390
0,180 180,300 300,450 450,600 600,720
I'm not sure this can
我不确定这会不会发生，

1585
00:47:38,390 --> 00:47:39,320
0,390
happen,|
|

1586
00:47:39,320 --> 00:47:40,250
0,270 270,480 480,630 630,750 750,930
just making this up for
这只是为你编造的。

1587
00:47:40,250 --> 00:47:41,240
0,210 270,600 600,660 660,840 840,990
you.| But if this really
|但是如果这真的可以使用旧的缓存值，那么我们就有大麻烦了。

1588
00:47:41,240 --> 00:47:42,170
0,180 180,330 330,420 420,630 630,930
could use the old cache

1589
00:47:42,170 --> 00:47:42,980
0,330 330,450 450,600 600,720 720,810
value, then we'd be in

1590
00:47:42,980 --> 00:47:44,060
0,180 180,510
big trouble.|
|

1591
00:47:44,550 --> 00:47:45,740
0,600

1592
00:47:45,890 --> 00:47:46,820
0,300 360,600 600,750 750,840 840,930
And I don't know if
我不知道这台机器是否真的能做到这一点，或者是否能做到这一点。

1593
00:47:46,820 --> 00:47:47,810
0,90 90,420 420,540 540,810 810,990
the machine would actually do

1594
00:47:47,810 --> 00:47:50,540
0,450 630,900 900,1410 1500,2130
that or whether {}.|
|

1595
00:47:53,920 --> 00:47:55,660
0,330 330,990 990,1140 1140,1350 1350,1740
Another possibility is that the
另一种可能性是编译器，

1596
00:47:56,380 --> 00:48:00,760
0,990 990,1080 1080,1380
compiler,| you know,
|你知道，真正的答案是我不知道，

1597
00:48:02,650 --> 00:48:03,400
0,180 180,360 360,570 570,660 660,750
the real answer is I

1598
00:48:03,400 --> 00:48:04,930
0,150 150,420 1080,1320 1320,1440 1440,1530
don't know,| I should go
|我应该走了，想一想具体的例子是什么。

1599
00:48:04,930 --> 00:48:06,190
0,180 180,270 270,450 450,1080 1080,1260
off and think about what

1600
00:48:06,190 --> 00:48:07,480
0,60 60,510 510,900 900,1050 1050,1290
a specific example would be.|
|

1601
00:48:08,320 --> 00:48:09,430
0,450 510,750 750,840 840,1020 1020,1110
Okay, Okay, I see, the
好的，好的，我明白了，高速缓存版本，有道理，是的。

1602
00:48:09,430 --> 00:48:11,980
0,540 570,1200 1290,1560 1560,1770 1770,2550
cache version, makes sense, yeah.|
|

1603
00:48:11,980 --> 00:48:13,630
0,150 150,360 360,750 750,1350 1350,1650
I'm not actually completely sure
实际上，我并不完全确定这是否会在现实生活中发生。

1604
00:48:13,630 --> 00:48:15,220
0,90 90,330 360,600 600,1200 1410,1590
it could could happen in

1605
00:48:15,220 --> 00:48:17,060
0,180 180,810
real life.|
|

1606
00:48:19,030 --> 00:48:20,360
0,210 210,270 270,390 390,750
That's a good question.|
这是个好问题。|

1607
00:48:20,450 --> 00:48:21,340
0,60

1608
00:48:22,880 --> 00:48:23,980
0,510
Okay,
好的，这是第二个想法。

1609
00:48:24,140 --> 00:48:26,420
0,690 1140,1410 1410,1470 1470,1830 1830,2280
{} that's the second idea.|
|

1610
00:48:26,540 --> 00:48:27,890
0,210 210,720 720,1020 1020,1110 1110,1350
The third problem we have
第三个问题是，之前有人提出了哪些问题

1611
00:48:27,890 --> 00:48:29,810
0,180 180,750 780,1140 1140,1470 1470,1920
which something somebody raised before|
|

1612
00:48:29,810 --> 00:48:31,980
0,150 150,480 570,990 990,1650
is that the writer
写入器将交换E1指针以指向新的E2，

1613
00:48:32,360 --> 00:48:33,650
0,360 360,540 540,660 660,720 720,1290
{} is going to swap

1614
00:48:33,650 --> 00:48:34,760
0,450
the

1615
00:48:34,790 --> 00:48:35,750
0,330 330,600 600,690 690,900 900,960
E1 pointer to point to

1616
00:48:35,750 --> 00:48:36,860
0,90 90,270 270,600 600,840 900,1110
the new E2,| but there
|但可能会有读者，你知道是谁开始关注这个指针的，

1617
00:48:36,860 --> 00:48:39,230
0,180 180,330 330,1350 1380,2010 2220,2370
could be readers, {} you

1618
00:48:39,230 --> 00:48:40,220
0,60 60,240 240,600 600,810 810,990
know who started looking at

1619
00:48:40,310 --> 00:48:41,480
0,330 330,480 480,750 750,930 930,1170
follow this pointer,| just before
|就在我们换作家之前，

1620
00:48:41,480 --> 00:48:42,680
0,120 120,390 390,510 510,750 750,1200
we change the writer changed,|
|

1621
00:48:42,710 --> 00:48:43,790
0,360 360,450 450,690 690,930 930,1080
who are still looking at
他们仍在关注E2。

1622
00:48:43,790 --> 00:48:46,370
0,540 810,1500 1920,2280 2280,2490 2490,2580
E2.| {} We need to
|总有一天我们需要释放这个列表元素，

1623
00:48:46,370 --> 00:48:48,020
0,300 300,510 510,720 720,1050 1050,1650
free this list element someday,|
|

1624
00:48:49,220 --> 00:48:50,240
0,330 330,450 450,630 630,810 810,1020
{} but we'd better not
但是我们最好不要在一些读者还在使用的时候把它免费，

1625
00:48:50,240 --> 00:48:51,200
0,180 180,300 300,480 480,690 690,960
free it while some readers

1626
00:48:51,200 --> 00:48:52,070
0,180 180,480 480,570 600,780 780,870
still using it,| so we
|因此，我们需要以某种方式等待，直到最后一个阅读器使用完E2，然后才能释放它。

1627
00:48:52,070 --> 00:48:53,060
0,150 150,240 240,600 600,810 810,990
need to somehow wait until

1628
00:48:53,060 --> 00:48:54,440
0,90 90,450 450,750 750,990 990,1380
the last reader has finished

1629
00:48:54,440 --> 00:48:55,760
0,270 270,750 750,1050 1050,1170 1170,1320
using E2, before we can

1630
00:48:55,760 --> 00:48:56,920
0,210 210,1080
free it.|
|

1631
00:48:58,520 --> 00:48:59,930
0,180 180,450 450,630 630,1290 1290,1410
And that's the third and
这是RCU解决的第三个也是最后一个主要问题，

1632
00:48:59,930 --> 00:49:02,030
0,270 270,510 510,1050 1320,1950 1950,2100
final main problem that {RCU

1633
00:49:02,030 --> 00:49:03,920
0,270 270,1200 1230,1530 1530,1710 1710,1890
-} solves,| how long should
|写入器应该等待多长时间才能释放E2。

1634
00:49:03,920 --> 00:49:05,300
0,30 30,270 270,750 870,1230 1230,1380
a writer wait before it

1635
00:49:05,480 --> 00:49:08,420
0,690 690,1260
frees E2.|
|

1636
00:49:08,780 --> 00:49:10,130
0,570 570,720 720,840 840,1290 1290,1350
There's you could imagine a
你可以想象有很多方法可以做到这一点，

1637
00:49:10,130 --> 00:49:10,880
0,240 240,300 300,480 480,540 540,750
number of ways of doing

1638
00:49:10,880 --> 00:49:13,100
0,450 450,780 1170,1440 1440,2010 2040,2220
this,| {} for example we
|例如，我们可以在每个列表元素中添加一些引用计数，并让读者递增它

1639
00:49:13,100 --> 00:49:13,880
0,120 120,210 210,240 240,420 420,780
could put a little reference

1640
00:49:13,880 --> 00:49:15,260
0,300 300,390 390,570 570,840 840,1380
count in every list element

1641
00:49:15,410 --> 00:49:16,760
0,150 150,300 300,630 630,1080 1080,1350
and have readers increment it|
|

1642
00:49:16,850 --> 00:49:18,470
0,180 180,300 300,690 690,1230 1350,1620
and have readers wait, {}
并让读者等待，读者在开始使用列表元素时递增，

1643
00:49:18,470 --> 00:49:19,700
0,270 270,690 690,810 810,900 900,1230
reader's increment when they start

1644
00:49:19,700 --> 00:49:21,950
0,240 240,480 480,900 1230,1890 2010,2250
using list element,| decrement it,
|使用列表元素完成后，将其递减

1645
00:49:21,950 --> 00:49:22,850
0,210 210,330 330,570 570,810 810,900
when they're done using the

1646
00:49:22,850 --> 00:49:23,840
0,240 240,660 660,750 750,840 840,990
list element| and have the
|并让写入器等待该元素上的引用计数变为零，

1647
00:49:23,840 --> 00:49:24,890
0,210 210,330 330,630 630,780 780,1050
{writer -} wait for the

1648
00:49:25,560 --> 00:49:26,850
0,390 390,660 660,720 720,900 900,1290
reference count on this element

1649
00:49:26,850 --> 00:49:28,350
0,90 90,210 210,690 1020,1320 1350,1500
go to zero,| {} we
|我们会立刻后悔的，

1650
00:49:28,350 --> 00:49:29,970
0,210 210,480 480,660 660,1140 1140,1620
would regret that instantly,| because
|因为RCU的全部意义在于允许读而不写。

1651
00:49:30,270 --> 00:49:32,220
0,120 120,810 870,1770 1770,1830 1830,1950
the whole point of {RCU

1652
00:49:32,220 --> 00:49:33,720
0,420 420,540 540,630 630,870 870,1500
-} is to allow reading

1653
00:49:33,750 --> 00:49:35,580
0,780 780,1230
without writing.|
|

1654
00:49:35,610 --> 00:49:36,810
0,420 420,510 510,690 690,870 870,1200
Because we know that if
因为我们知道，如果很多读者改变这个引用计数

1655
00:49:36,900 --> 00:49:38,980
0,390 390,720 720,1200 1200,1500
lots of readers are

1656
00:49:39,040 --> 00:49:40,780
0,450 660,1080 1080,1230 1230,1500 1500,1740
{} changing this reference count|
|

1657
00:49:40,780 --> 00:49:41,440
0,60 60,180 180,240 240,300 300,660
is going to be terribly
进行维护引用计数所涉及的写入将非常昂贵，

1658
00:49:41,440 --> 00:49:43,540
0,660 870,1290 1290,1380 1380,1530 1530,2100
expensive to do the writes

1659
00:49:43,540 --> 00:49:44,800
0,450 450,540 540,930 930,960 960,1260
involved in maintaining a reference

1660
00:49:44,800 --> 00:49:45,970
0,240 240,450 450,600 600,1020 1020,1170
count,| so we absolutely don't
|所以我们绝对不想要引用计数。

1661
00:49:45,970 --> 00:49:47,800
0,150 150,480 480,1020 1230,1560 1560,1830
want reference counts.| {} Another
|另一种可能性是使用垃圾收集语言，

1662
00:49:47,800 --> 00:49:48,910
0,600 600,780 780,870 870,930 930,1110
possibility would be to use

1663
00:49:48,910 --> 00:49:52,260
0,60 60,450 450,900 900,1590
a garbage collected language,|
|

1664
00:49:52,530 --> 00:49:53,460
0,180 180,270 270,330 330,600 600,930
and in a garbage collected
用垃圾收集的语言来说，

1665
00:49:53,460 --> 00:49:55,410
0,480 690,1080 1080,1350 1350,1560 1560,1950
language,| you {don't,ever} free anything
|你从来没有明确释放过任何东西，

1666
00:49:55,410 --> 00:49:57,720
0,630 630,1200 1200,1320 1320,1680 1680,2310
explicitly,| instead the garbage collector
|取而代之的是，垃圾收集器负责所需的记账工作

1667
00:49:57,750 --> 00:49:59,940
0,210 210,300 300,840 840,1530 1620,2190
does the bookkeeping required| to
|以确定是否有任何线程或任何数据结构仍具有对此元素的引用

1668
00:50:00,030 --> 00:50:01,980
0,450 450,570 600,1110 1110,1800 1800,1950
decide if any thread for

1669
00:50:01,980 --> 00:50:03,690
0,450 450,600 600,810 810,1140 1140,1710
example or any data structure

1670
00:50:03,720 --> 00:50:05,250
0,540 570,870 870,990 990,1110 1110,1530
has still has a reference

1671
00:50:05,250 --> 00:50:06,870
0,90 90,660 690,1230 1290,1560 1560,1620
to this element| and the
|垃圾收集器一旦证明这个元素不可能再被使用，

1672
00:50:06,870 --> 00:50:08,820
0,330 330,690 690,900 900,1050 1050,1950
garbage collector once it proves

1673
00:50:08,880 --> 00:50:10,500
0,300 300,660 660,930 930,1440 1440,1620
this element can't possibly be

1674
00:50:10,500 --> 00:50:12,270
0,240 240,510 510,1020 1080,1530 1530,1770
ever used again,| only then
|只有到那时垃圾收集器才会将其释放，

1675
00:50:12,270 --> 00:50:13,410
0,120 120,180 180,540 540,930 930,1140
will the garbage collector free

1676
00:50:13,410 --> 00:50:15,420
0,510 630,840 840,1110 1110,1590
this,| so that's another
|因此，这是决定何时释放此列表元素的另一种非常合理的方案。

1677
00:50:15,600 --> 00:50:18,570
0,390 420,690 690,1410 1530,2370 2460,2970
{} quite possibly reasonable {}

1678
00:50:18,930 --> 00:50:20,190
0,540 540,630 630,1020 1020,1170 1170,1260
scheme for deciding, when to

1679
00:50:20,190 --> 00:50:22,170
0,270 270,480 480,690 690,1080 1620,1980
free this list element.| You
|您知道使用RCU的Linux，它不是用垃圾收集语言编写的，所以。

1680
00:50:22,170 --> 00:50:23,700
0,210 330,990 990,1170 1170,1410 1410,1530
know Linux which uses {RCU

1681
00:50:23,700 --> 00:50:25,200
0,570 810,1050 1050,1260 1260,1410 1410,1500
-}, it's not written in

1682
00:50:25,200 --> 00:50:26,730
0,60 60,360 360,660 660,1140 1140,1530
a garbage collected language, so.|
|

1683
00:50:27,620 --> 00:50:28,910
0,390 570,810 810,990 990,1110 1110,1290
And we're not even sure
我们甚至不确定垃圾收集是否会提高性能，

1684
00:50:28,910 --> 00:50:30,440
0,90 90,360 360,840 960,1170 1170,1530
that garbage collection would be

1685
00:50:30,440 --> 00:50:33,590
0,150 150,570 570,1470 1710,2310 2790,3150
would improve performance,| {} so
|所以我们不能在这里使用标准的垃圾收集器。

1686
00:50:33,590 --> 00:50:34,670
0,120 120,390 390,600 600,750 750,1080
we can't use a standard

1687
00:50:34,670 --> 00:50:36,960
0,330 330,660 660,990 1020,1770
garbage collector here instead.|
|

1688
00:50:37,680 --> 00:50:39,810
0,510 720,960 960,1140 1140,1500 1500,2130
{} {RCU -} uses another
RCU使用了另一种伎俩，

1689
00:50:40,550 --> 00:50:42,830
0,570 990,1530 1530,1590 1590,1680 1680,2280
{} sort of a trick,|
|

1690
00:50:43,130 --> 00:50:43,850
0,150 150,360 360,570 570,630 630,720
that works well in the
这在内核中可以很好地延迟冻结。

1691
00:50:43,850 --> 00:50:48,400
0,540 660,1140 1200,1920 1920,2850
kernel for delaying freeze.|
|

1692
00:50:52,990 --> 00:50:54,760
0,300 300,450 450,1200
And so that
所以这个想法就是

1693
00:50:56,460 --> 00:50:58,500
0,930 1110,1320 1320,1500 1500,1740 1740,2040
idea is that| the readers
|读者和作者都必须遵守一条规则，

1694
00:50:58,500 --> 00:51:00,660
0,120 120,420 420,600 600,1410 1920,2160
and writers have to each

1695
00:51:00,660 --> 00:51:02,220
0,330 330,480 480,1050 1110,1470 1470,1560
follow a rule,| that will
|这将允许编剧推迟冻结，

1696
00:51:02,220 --> 00:51:04,050
0,240 240,630 630,840 870,1680 1710,1830
allow writers to delay the

1697
00:51:04,050 --> 00:51:08,400
0,750 1020,1590 1920,2910 3870,4050 4050,4350
freeze,| {} readers are not
|不允许读取器在上下文切换期间持有指向RCU保护数据的指针。

1698
00:51:08,400 --> 00:51:09,660
0,300 300,360 360,660 660,720 720,1260
allowed to hold a pointer

1699
00:51:09,660 --> 00:51:10,860
0,150 150,330 330,540 540,660 660,1200
to {RCU - -} protected

1700
00:51:10,860 --> 00:51:12,660
0,360 390,810 810,870 870,1350 1350,1800
data across a context switch.|
|

1701
00:51:12,690 --> 00:51:13,830
0,270 270,420 420,750 750,870 870,1140
So a reader is not
因此不允许读取器持有指针，

1702
00:51:13,830 --> 00:51:15,330
0,210 210,270 270,780 780,870 870,1500
allowed to hold a pointer,|
|

1703
00:51:17,220 --> 00:51:18,720
0,210 210,270 270,810 810,1110 1110,1500
one of those list elements
跨上下文切换的那些列表元素之一。

1704
00:51:18,720 --> 00:51:21,720
0,690 1050,1410 1410,1920 1920,2460 2850,3000
across a context switch.| So
|因此，读取器不能在RCU临界区中让出CPU。

1705
00:51:21,720 --> 00:51:24,320
0,120 120,960
the readers,

1706
00:51:26,490 --> 00:51:28,080
0,150 150,600 600,810 810,900 900,1590
they cannot yield the CPU,

1707
00:51:31,100 --> 00:51:32,390
0,210 210,420 420,600 600,870 870,1290
in a {RCU -} critical

1708
00:51:32,390 --> 00:51:33,540
0,630
section.|
|

1709
00:51:35,620 --> 00:51:36,960
0,660

1710
00:51:37,730 --> 00:51:38,600
0,150 150,240 240,360 360,450 450,870
And then what the writers
然后编剧们要做的是，

1711
00:51:38,600 --> 00:51:41,450
0,360 390,930 1200,1710 2040,2760 2760,2850
do is,| they delay the
|它们将空闲延迟到每个核心至少切换一次上下文。

1712
00:51:41,450 --> 00:51:42,800
0,780
free

1713
00:51:46,970 --> 00:51:48,960
0,360 390,720 720,1380
until every core

1714
00:51:51,050 --> 00:51:52,730
0,270 270,720 720,1140 1170,1380 1380,1680
as context switches at least

1715
00:51:52,730 --> 00:51:53,940
0,690
once.|
|

1716
00:52:00,590 --> 00:52:01,880
0,210 210,360 360,480 480,690 690,1290
So this is easy enough,|
所以这很简单，|

1717
00:52:01,940 --> 00:52:02,930
0,210 210,330 330,630 630,900 900,990
this is actually also a
这实际上也是自旋锁的一条规则，

1718
00:52:02,930 --> 00:52:04,100
0,270 270,360 360,660 660,1080 1080,1170
rule for spin locks,| in
|在自旋锁定临界区，你不能让出CPU，

1719
00:52:04,100 --> 00:52:05,240
0,60 60,300 300,480 480,810 810,1140
a spin lock critical section,

1720
00:52:05,240 --> 00:52:06,620
0,90 90,330 330,630 630,720 720,1380
you can't yield the CPU,|
|

1721
00:52:07,820 --> 00:52:09,320
0,300 300,930 930,1320 1320,1410 1410,1500
but nevertheless you have to
但不管怎样，你还是要小心一点。

1722
00:52:09,320 --> 00:52:10,520
0,90 90,150 150,270 270,720
be a bit careful.|
|

1723
00:52:10,840 --> 00:52:12,010
0,450 540,810 810,900 900,990 990,1170
{} This is a little
这有点牵涉其中，

1724
00:52:12,010 --> 00:52:14,560
0,150 150,900 1230,1980 2130,2430 2430,2550
more involved,| {} but it's
|但是，当每个内核都知道这种上下文切换时，情况就相对清楚了

1725
00:52:14,560 --> 00:52:16,720
0,900 1020,1410 1410,1650 1650,1980 1980,2160
relatively clear, when each each

1726
00:52:16,720 --> 00:52:18,580
0,600 600,840 840,990 990,1410 1410,1860
cores knows this context switching|
|

1727
00:52:18,790 --> 00:52:19,660
0,390 390,570 570,690 690,810 810,870
{} and so this is
因此，这是作家必须等待的一个非常明确的观点。

1728
00:52:19,660 --> 00:52:21,370
0,60 60,270 270,480 480,1110 1110,1710
a pretty well defined point

1729
00:52:21,400 --> 00:52:22,480
0,180 180,330 360,870 870,930 930,1080
for the writer to have

1730
00:52:22,480 --> 00:52:24,640
0,120 120,360 360,690
to wait for.|
|

1731
00:52:25,190 --> 00:52:27,020
0,180 180,390 480,960 960,1110 1110,1830
And just requires some implementation,|
只需要一些实现，|

1732
00:52:27,020 --> 00:52:28,280
0,120 120,420 420,900 900,1080 1080,1260
this also requires this may
这也要求这可能是一个很大的延迟

1733
00:52:28,280 --> 00:52:29,360
0,150 150,210 210,690 690,990 990,1080
be a significant delay| and
|可能是一毫秒或一毫秒的重要部分

1734
00:52:29,360 --> 00:52:30,980
0,360 360,900 900,1470 1470,1530 1530,1620
maybe a millisecond or a

1735
00:52:30,980 --> 00:52:32,480
0,480 480,780 780,840 840,930 930,1500
significant fraction of a millisecond|
|

1736
00:52:32,480 --> 00:52:33,170
0,90 90,180 180,420 420,570 570,690
that the writer has to
写入器在被允许释放该列表元素之前必须等待，

1737
00:52:33,170 --> 00:52:34,790
0,480 870,1200 1200,1290 1290,1530 1530,1620
wait before it's allowed to

1738
00:52:34,790 --> 00:52:36,420
0,330 330,510 510,750 750,1080
free that list element,|
|

1739
00:52:36,420 --> 00:52:37,200
0,120 120,210 210,420 420,570 570,780
to be sure that no
以确保没有读者可能还在使用它。

1740
00:52:37,200 --> 00:52:38,400
0,270 270,420 420,840 840,1080 1080,1200
reader could possibly still be

1741
00:52:38,400 --> 00:52:40,880
0,270 270,420
using it.|
|

1742
00:52:41,270 --> 00:52:42,440
0,390 390,480 480,600 600,750 750,1170
People have come up with
人们已经想出了一系列技术来实际实现这种等待，

1743
00:52:42,830 --> 00:52:44,320
0,600
a

1744
00:52:44,440 --> 00:52:46,570
0,360 360,630 630,1320 1320,1560 1560,2130
bunch of techniques for actually

1745
00:52:46,630 --> 00:52:49,810
0,660 660,870 870,1440 2460,2760 2760,3180
implementing this wait,| though most
|虽然这篇论文谈到的最直截了当的一点是

1746
00:52:49,810 --> 00:52:51,220
0,540 540,720 720,810 810,1080 1080,1410
straightforward one the paper talks

1747
00:52:51,220 --> 00:52:52,630
0,390 540,750 750,900 900,1080 1080,1410
about is that| the writing
|写入线程简单地与调度器一起安排，以使写入线程在系统中的每个核心上短暂地执行。

1748
00:52:52,630 --> 00:52:55,300
0,450 630,1350 1350,2220 2220,2400 2400,2670
thread simply arranges with the

1749
00:52:55,330 --> 00:52:57,310
0,1050 1110,1320 1320,1470 1470,1620 1620,1980
scheduler to have the writing

1750
00:52:57,310 --> 00:53:00,040
0,480 540,840 840,1440 1440,2160 2190,2730
thread be executed briefly on

1751
00:53:00,130 --> 00:53:01,270
0,270 270,480 480,570 570,660 660,1140
every one of the cores

1752
00:53:01,270 --> 00:53:02,360
0,60 60,150 150,690
in the system.|
|

1753
00:53:02,390 --> 00:53:03,230
0,150 150,240 240,390 390,570 570,840
And what that means is
这意味着，在此过程中，每个内核都必须进行上下文切换

1754
00:53:03,470 --> 00:53:05,220
0,330 420,1140
that {}

1755
00:53:05,420 --> 00:53:06,290
0,270 270,450 450,510 510,570 570,870
every one of the cores

1756
00:53:06,290 --> 00:53:07,550
0,330 330,450 450,630 630,690 690,1260
must have done a context

1757
00:53:07,550 --> 00:53:10,340
0,720 750,1050 1050,1200 1200,1980 2310,2790
switch during this process| and
|而且由于读者不能跨上下文切换持有内容，

1758
00:53:10,400 --> 00:53:11,780
0,360 360,690 690,930 930,1170 1170,1380
since readers can't hold stuff

1759
00:53:11,780 --> 00:53:13,190
0,270 270,720 720,1050 1050,1200 1200,1410
across context switches,| that means
|这意味着作家现在已经等得够久了。

1760
00:53:13,190 --> 00:53:13,970
0,120 120,180 180,450 450,570 570,780
that the writer is now

1761
00:53:13,970 --> 00:53:15,440
0,270 270,480 480,990
waited long enough.|
|

1762
00:53:17,100 --> 00:53:18,440
0,630

1763
00:53:20,000 --> 00:53:21,290
0,540 750,900 900,1020 1020,1140 1140,1290
{} And so the way
因此，实际的编写器代码看起来是这样的

1764
00:53:21,290 --> 00:53:23,390
0,330 330,780 780,1260 1260,1770 1770,2100
the actual writer code looks

1765
00:53:23,390 --> 00:53:25,370
0,270 270,510 960,1380 1440,1800 1800,1980
like is| {} writing code
|编写代码可以对数据进行任何修改

1766
00:53:25,370 --> 00:53:26,870
0,150 150,570 570,1260 1260,1380 1380,1500
does whatever modifications it's going

1767
00:53:26,870 --> 00:53:27,800
0,60 60,240 240,330 330,450 450,930
to do to the data|
|

1768
00:53:27,980 --> 00:53:29,390
0,240 240,360 360,420 420,870 870,1410
and then it calls this
然后它调用这个同步_rcu调用，

1769
00:53:30,650 --> 00:53:32,270
0,570 570,720 720,900 900,1050 1050,1620
{synchronize_rcu - - -} call,|
|

1770
00:53:35,630 --> 00:53:37,980
0,450 480,810 810,1290 1290,1710
which actually implements too.|
它实际上也实现了。|

1771
00:53:41,370 --> 00:53:43,590
0,540 600,810 810,1500 1500,1650 1650,2220
{} And then the writer
然后作者冻结了旧元素是什么。

1772
00:53:44,100 --> 00:53:45,780
0,480 480,960 960,1260 1260,1380 1380,1680
{} freeze whatever the old

1773
00:53:45,780 --> 00:53:47,420
0,420 420,1110
element was.|
|

1774
00:53:47,510 --> 00:53:48,470
0,240 240,330 330,480 480,720 720,960
And so that means that
所以这意味着编剧在做它正在做的事情，

1775
00:53:48,620 --> 00:53:49,790
0,270 270,570 570,690 690,900 900,1170
the writer is doing whatever

1776
00:53:49,790 --> 00:53:50,900
0,120 120,450 450,660 660,750 750,1110
it's doing,| you know at
|您知道，在这一点上，假设它正在执行E1->NEXT等于新的List元素。

1777
00:53:50,900 --> 00:53:51,950
0,210 210,600 600,750 750,870 870,1050
this point, let's say it's

1778
00:53:51,950 --> 00:53:53,870
0,330 330,630 780,1080 1080,1350 1770,1920
doing the you know the

1779
00:53:53,870 --> 00:53:57,200
0,1020 1380,1770 1770,2730
{E1->next - -}

1780
00:53:58,110 --> 00:53:59,260
0,660
{}

1781
00:54:00,500 --> 00:54:01,400
0,240 240,420 420,540 540,690 690,900
is equal to the new

1782
00:54:01,400 --> 00:54:04,140
0,270 270,810 1350,2130
list element {}.|
|

1783
00:54:04,650 --> 00:54:06,060
0,180 180,360 360,510 510,840
And so you know
因此您知道这个同步_RCU会在每个核心上强制执行上下文切换，

1784
00:54:11,070 --> 00:54:12,240
0,240 240,450 450,900 900,1020 1020,1170
{} this {synchronize_rcu - -

1785
00:54:12,240 --> 00:54:13,410
0,180 180,630 630,810 810,1050 1050,1170
-} causes {} force a

1786
00:54:13,410 --> 00:54:15,160
0,510 510,780 780,1140
context switch on

1787
00:54:15,620 --> 00:54:17,660
0,330 330,1020 1200,1530 1530,1770 1770,2040
every core,| {} so any
|所以任何可以读取的核心，

1788
00:54:17,660 --> 00:54:20,000
0,360 360,540 540,720 720,1020 1170,2340
core that could have read,|
|

1789
00:54:20,000 --> 00:54:20,690
0,120 120,300 300,390 390,540 540,690
any core that could have
任何可以读取旧值的内核，在这一点上一定已经读取了它，

1790
00:54:20,690 --> 00:54:23,870
0,510 780,1050 1080,1860 1860,2670 2790,3180
read the old value, must

1791
00:54:23,870 --> 00:54:24,590
0,150 150,330 330,420 420,510 510,720
have read it at this

1792
00:54:24,590 --> 00:54:25,920
0,750
point,|
|

1793
00:54:28,440 --> 00:54:28,980
0,180 180,270 270,390 390,450 450,540
must have read it at
一定是在这个时间点上看过了，

1794
00:54:28,980 --> 00:54:30,270
0,150 150,360 360,420 420,990 1020,1290
this point in time,| if
|如果在该时间点之后，我们已经在每个内核上进行了上下文切换，

1795
00:54:30,300 --> 00:54:31,320
0,360 360,540 540,750 750,810 810,1020
after that point in time,

1796
00:54:31,320 --> 00:54:32,400
0,120 120,240 240,300 300,810 810,1080
we've done a context switch

1797
00:54:32,400 --> 00:54:33,480
0,90 90,300 300,690 690,870 870,1080
on every core,| that means
|这意味着，由于规则一，此时读取旧值的内核都不能具有指向该值的指针

1798
00:54:33,480 --> 00:54:34,860
0,150 150,360 360,750 750,1080 1080,1380
that no core that read

1799
00:54:34,860 --> 00:54:37,080
0,120 120,390 390,990 1200,1560 1560,2220
the old value could still

1800
00:54:37,080 --> 00:54:38,070
0,240 240,300 300,720 720,810 810,990
have a pointer to that

1801
00:54:38,070 --> 00:54:39,720
0,630 870,1080 1080,1320 1320,1590 1590,1650
value at this point in

1802
00:54:39,720 --> 00:54:41,610
0,510 720,1050 1050,1170 1170,1380 1380,1890
time due to rule one|
|

1803
00:54:41,700 --> 00:54:42,480
0,300 300,420 420,600 600,690 690,780
and that means they were
这意味着他们被允许释放旧价值。

1804
00:54:42,480 --> 00:54:43,410
0,270 270,360 360,630 630,750 750,930
allowed to free the old

1805
00:54:43,410 --> 00:54:44,220
0,360
value.|
|

1806
00:54:47,450 --> 00:54:49,000
0,240 240,870
Any questions?|
有什么问题吗？|

1807
00:54:55,670 --> 00:54:57,110
0,330 330,420 420,900 900,1020 1020,1440
You may object that this
您可能会反对此同步_rcu将花费相当大的(可能是零点几毫秒)时间，

1808
00:54:57,140 --> 00:54:58,640
0,570 570,720 720,1110 1110,1260 1260,1500
{synchronize_rcu - -} will take

1809
00:54:58,640 --> 00:55:00,860
0,300 360,1200 1200,1620 1620,2100 2100,2220
a significant perhaps fraction of

1810
00:55:00,860 --> 00:55:03,200
0,390 690,1440 1440,1650 1650,1890 1890,2340
a millisecond,| that's quite true.|
|这是非常正确的。|

1811
00:55:04,890 --> 00:55:06,870
0,240 240,510 570,1080 1470,1830 1830,1980
Is that, {} so that's
是这样的，所以这太糟糕了，

1812
00:55:06,870 --> 00:55:09,360
0,120 120,600 690,1260 1650,1860 1860,2490
too bad,| { -} one
|其中一个理由是写入RCU保护的数据，

1813
00:55:09,360 --> 00:55:10,590
0,60 60,120 120,870 870,990 990,1230
of the justifications is that

1814
00:55:10,590 --> 00:55:12,300
0,600 870,1050 1050,1140 1140,1380 1380,1710
writing for {RCU -} protected

1815
00:55:12,300 --> 00:55:13,110
0,270 270,540 540,630 630,750 750,810
data,| writing is going to
|写作将会变得相对罕见，

1816
00:55:13,110 --> 00:55:14,730
0,90 90,810 810,1350 1350,1500 1500,1620
be relatively rare,| so the
|因此，写入时间较长的事实可能不会对整体性能产生太大影响，

1817
00:55:14,730 --> 00:55:15,630
0,240 240,330 330,390 390,690 690,900
fact that the writes take

1818
00:55:15,630 --> 00:55:17,790
0,450 450,570 570,870 1230,1590 1710,2160
longer may not will probably

1819
00:55:17,790 --> 00:55:20,220
0,300 390,1200 1200,1710 1710,2220 2220,2430
not affect overall performance very

1820
00:55:20,220 --> 00:55:22,230
0,450 1110,1290 1290,1350 1350,1950 1950,2010
much,| for the situations in
|对于作者真的不想等待的情况，

1821
00:55:22,230 --> 00:55:23,490
0,330 360,570 570,840 840,990 990,1260
which the writer really doesn't

1822
00:55:23,490 --> 00:55:24,750
0,120 120,180 180,570 660,960 960,1260
want to wait,| there's another
|还有另一个调用，即使是等待调用call_rcu也不同。

1823
00:55:24,750 --> 00:55:25,860
0,690
call,

1824
00:55:26,380 --> 00:55:29,020
0,540 540,720 1200,1620 1620,2400 2400,2640
{} that that differs even

1825
00:55:29,020 --> 00:55:31,540
0,540 780,1320 1440,2190 2190,2310 2310,2520
{a,wait} {} call {call_rcu -

1826
00:55:31,540 --> 00:55:32,580
0,480
-}.|
|

1827
00:55:35,070 --> 00:55:35,850
0,210 210,300 300,570 570,660 660,780
And the idea is you
我们的想法是，在通常的用例中，将它传递给

1828
00:55:35,850 --> 00:55:38,490
0,330 330,480 480,840 1290,2040 2340,2640
pass it the, { -}

1829
00:55:38,490 --> 00:55:40,260
0,270 270,360 360,1020 1020,1260 1260,1770
in the usual use case,|
|

1830
00:55:40,830 --> 00:55:41,700
0,120 120,360 360,450 450,480 480,870
you pass it a pointer
您可以向它传递一个指向要释放的对象的指针

1831
00:55:41,700 --> 00:55:42,720
0,120 120,330 330,810 810,900 900,1020
to the object you want

1832
00:55:42,720 --> 00:55:44,580
0,60 60,600 660,1020 1020,1560 1590,1860
to free| and then a
|然后是一个回调函数，该函数只调用此指针上的FREE

1833
00:55:44,580 --> 00:55:46,560
0,630 630,1230 1230,1500 1500,1680 1680,1980
callback function that just calls

1834
00:55:46,560 --> 00:55:47,660
0,540
free

1835
00:55:47,750 --> 00:55:49,310
0,450 630,870 870,1020 1020,1320 1320,1560
{} on this {pointer -}|
|

1836
00:55:49,310 --> 00:55:50,360
0,420 420,510 510,690 690,930 930,1050
and the {rcu - -}
而RCU系统，基本上没有藏身之处，

1837
00:55:50,360 --> 00:55:52,370
0,360 360,720 720,1170 1170,1290 1290,2010
system, basically stash is away,|
|

1838
00:55:52,400 --> 00:55:53,570
0,120 120,480 480,600 600,810 810,1170
the call {rcu - -}
呼叫RCU存储在列表上远离这两个值

1839
00:55:53,660 --> 00:55:55,700
0,600 600,720 720,1230 1500,1740 1740,2040
stash is away {} these

1840
00:55:55,700 --> 00:55:57,080
0,150 150,540 540,630 630,690 690,1380
two values on a list|
|

1841
00:55:57,110 --> 00:55:59,540
0,270 270,390 390,900 900,1770 2070,2430
and then immediately returns {}
然后立即返回，然后做一些簿记，

1842
00:55:59,540 --> 00:56:01,160
0,180 180,390 390,570 570,750 750,1620
and then does some bookkeeping,|
|

1843
00:56:02,010 --> 00:56:04,770
0,330 330,750 750,1170 1170,1890 1920,2760
{} typically involving basically looking
通常涉及基本上查看每个核心上已经发生了多少上下文的计数，

1844
00:56:04,770 --> 00:56:05,880
0,150 150,510
at the

1845
00:56:05,970 --> 00:56:07,560
0,660 660,750 750,900 900,1080 1080,1590
counts of how many contexts

1846
00:56:07,560 --> 00:56:08,610
0,150 150,390 390,720 720,870 870,1050
which have occurred on each

1847
00:56:08,610 --> 00:56:11,880
0,510 840,1320 1740,2370 2760,3210 3210,3270
core,| {} system sort of
|系统在调用SEE返回后在后台做一些记账等待，直到所有核心上下文切换，

1848
00:56:11,880 --> 00:56:13,350
0,120 120,180 180,720 720,1110 1110,1470
in the background after call

1849
00:56:13,350 --> 00:56:15,330
0,300 300,1050 1140,1410 1410,1560 1560,1980
see returns does some bookkeeping

1850
00:56:15,330 --> 00:56:17,370
0,240 240,540 540,1020 1260,1530 1530,2040
to wait until all cores

1851
00:56:17,370 --> 00:56:18,570
0,60 60,510 510,870 870,990 990,1200
{} context switch,| and then
|然后使用此参数调用此回调函数，

1852
00:56:18,570 --> 00:56:20,610
0,420 420,570 570,1050 1050,1560 1740,2040
calls this callback function with

1853
00:56:20,610 --> 00:56:21,990
0,180 180,720 900,1110 1110,1200 1200,1380
this argument,| and so this
|所以这是避免等待的一种方式，

1854
00:56:21,990 --> 00:56:23,010
0,90 90,180 180,450 450,570 570,1020
is a way of avoiding

1855
00:56:23,010 --> 00:56:24,540
0,90 90,600 870,1320
the wait,| because
|因为这个电话马上就会打回来。

1856
00:56:25,230 --> 00:56:27,500
0,150 150,480 720,1200 1200,1740
this call returns instantly.|
|

1857
00:56:28,250 --> 00:56:29,340
0,450

1858
00:56:30,520 --> 00:56:31,390
0,330 330,420 420,570 570,720 720,870
On the other hand you're
另一方面，你会被劝阻不要使用它，

1859
00:56:31,390 --> 00:56:32,920
0,480 480,630 630,930 930,1080 1080,1530
discouraged from using it,| because
|因为现在这个列表，如果内核大量调用call_rcu，

1860
00:56:33,340 --> 00:56:36,100
0,420 450,960 960,1290 1290,2070 2190,2760
{} now this list that,

1861
00:56:36,250 --> 00:56:38,830
0,540 810,1920 1950,2190 2190,2310 2310,2580
{} if if the kernel

1862
00:56:38,830 --> 00:56:39,850
0,300 300,660 660,840 840,960 960,1020
calls {call_rcu - -} a

1863
00:56:39,850 --> 00:56:41,920
0,450 750,1380 1410,1590 1590,1950 1950,2070
lot,| then the list that
|那么保存这些值的列表可能会变得非常长，

1864
00:56:41,920 --> 00:56:44,650
0,840 840,1260 2070,2490 2490,2580 2580,2730
holds these values can get

1865
00:56:44,650 --> 00:56:47,020
0,210 210,870 960,1680 1860,2130 2130,2370
very long,| and it means
|这意味着可能会有大量的内存，这些内存并不是整天都在被释放，

1866
00:56:47,020 --> 00:56:48,160
0,240 480,870 870,990 990,1080 1080,1140
that there may be a

1867
00:56:48,160 --> 00:56:49,150
0,180 180,240 240,570 570,750 750,990
lot of memory, that's not

1868
00:56:49,150 --> 00:56:50,710
0,180 180,870 960,1260 1260,1380 1380,1560
being freed all the day

1869
00:56:50,710 --> 00:56:51,800
0,630
other,|
|

1870
00:56:51,890 --> 00:56:53,450
0,270 270,480 480,1200 1200,1380 1380,1560
{} this, this list grows
这个，这个名单变得很长，

1871
00:56:53,450 --> 00:56:55,190
0,180 180,570 720,960 960,1230 1230,1740
very long,| each list element
|IS的每个列表元素中都有一个应该是空闲的指针

1872
00:56:55,430 --> 00:56:57,720
0,270 270,540 900,1170 1170,1770
of a is {}

1873
00:56:57,930 --> 00:56:58,980
0,330 330,390 390,840 840,930 930,1050
has a pointer in it

1874
00:56:58,980 --> 00:56:59,970
0,180 180,390 390,510 510,870 870,990
that should be free| to
|指向应该释放的对象。

1875
00:56:59,970 --> 00:57:00,870
0,240 240,330 330,450 450,780 780,900
point to an object that

1876
00:57:00,870 --> 00:57:03,030
0,180 180,300 300,750 1290,1830 1830,2160
should be freed.| {So,under} extreme
|所以在极端情况下，你可以运行一个系统，

1877
00:57:03,030 --> 00:57:04,230
0,750 750,870 870,990 990,1140 1140,1200
circumstances, you can run a

1878
00:57:04,230 --> 00:57:05,610
0,570 600,720 720,840 840,990 990,1380
system,| if you're not careful
|如果您不注意RCU CALL_RCU的大量调用，

1879
00:57:05,610 --> 00:57:06,570
0,120 270,570 570,630 630,900 900,960
a lot of calls to

1880
00:57:06,570 --> 00:57:07,740
0,120 120,570 600,900 900,990 990,1170
{rcu -} {call_rcu - -},|
|

1881
00:57:07,740 --> 00:57:08,850
0,150 150,480 570,750 750,810 810,1110
you can run a system
您可以运行内存不足的系统，

1882
00:57:08,850 --> 00:57:09,630
0,90 90,150 150,450 450,630 630,780
out of memory,| because all
|因为所有的内存最终都会出现在这个延迟冻结的列表上。

1883
00:57:09,630 --> 00:57:10,500
0,90 90,390 390,600 600,750 750,870
the memory ends up on

1884
00:57:10,500 --> 00:57:12,510
0,180 180,510 510,720 810,1350 1350,2010
this list of deferred freeze.|
|

1885
00:57:14,220 --> 00:57:15,210
0,390 390,510 510,720 720,870 870,990
{} So people don't like
所以人们不喜欢用这个，他们没必要用。

1886
00:57:15,210 --> 00:57:16,620
0,120 120,300 300,960 1080,1260 1260,1410
to use this, they don't

1887
00:57:16,620 --> 00:57:17,560
0,150 150,330
have to.|
|

1888
00:57:21,560 --> 00:57:23,400
0,480 600,1140
Okay, {}
好的，致，

1889
00:57:24,010 --> 00:57:28,120
0,1140 1530,2370
to {},|
|

1890
00:57:28,240 --> 00:57:30,760
0,360 360,570 570,1110 1110,1890
please ask questions {so,far},
如果你有问题，请到目前为止提问题。

1891
00:57:32,770 --> 00:57:34,210
0,150 150,270 270,480 480,1230 1230,1440
if you have questions.| So,
|所以，这不会，这会阻止我们自由，阻止我们释放别人仍在使用的东西，

1892
00:57:34,210 --> 00:57:36,820
0,240 240,690 720,1320 1530,1950 1980,2610
this doesn't, {} this prevents

1893
00:57:36,820 --> 00:57:38,830
0,390 390,1080 1200,1530 1530,1890 1890,2010
us free, that prevents us

1894
00:57:38,830 --> 00:57:40,810
0,210 210,630 630,1140 1140,1560 1560,1980
from freeing something that somebody's

1895
00:57:40,810 --> 00:57:42,850
0,240 240,720 1020,1320 1320,1620 1620,2040
still using,| it doesn't prevent
|这并不妨碍我们修改，就像让读者看到某个东西的半生不熟的版本一样，

1896
00:57:42,850 --> 00:57:45,910
0,540 810,1380 1380,2130 2130,2430 2460,3060
us from modified like having

1897
00:57:45,910 --> 00:57:48,310
0,180 180,660 660,1050 1050,1470 1470,2400
the readers see a half-baked

1898
00:57:48,310 --> 00:57:49,810
0,360 360,480 480,990 990,1320 1320,1500
version of something,| because it's
|因为它被正确地修改了。

1899
00:57:49,810 --> 00:57:52,120
0,240 240,930 930,1350 1500,1950 1950,2310
being modified right.| Idea one
|想法一阻止了那是的。

1900
00:57:52,120 --> 00:57:53,640
0,420 420,690 690,1050
prevented that yeah.|
|

1901
00:57:54,920 --> 00:57:56,480
0,450 570,780 780,930 930,1260 1260,1560
Okay.| So they they get
好吧。|所以他们他们得到了这个想法，在这个想法背后的第一个想法是，

1902
00:57:56,480 --> 00:57:57,530
0,120 120,510 510,750 750,810 810,1050
the idea, behind the idea

1903
00:57:57,530 --> 00:57:59,060
0,300 300,450 450,690 930,1440 1440,1530
one is that,| instead of
|与其就地更新列表元素，这绝对会导致您提到的问题，

1904
00:57:59,060 --> 00:58:00,140
0,420 420,480 480,720 720,1020 1020,1080
updating a list element in

1905
00:58:00,140 --> 00:58:02,510
0,780 780,960 960,1170 1200,2100 2130,2370
place which would absolutely cause

1906
00:58:02,510 --> 00:58:04,220
0,90 90,480 480,570 570,1020 1080,1710
the problem you mentioned,| when
|当不允许写入器就地更新RCU保护的数据时，

1907
00:58:04,220 --> 00:58:05,390
0,90 90,390 390,450 450,660 660,1170
the writers are not allowed

1908
00:58:05,810 --> 00:58:07,100
0,150 150,570 570,690 690,930 930,1290
to update {RCU -} protected

1909
00:58:07,100 --> 00:58:09,170
0,240 240,360 360,1050 1170,1830 1830,2070
data in place,| instead they
|取而代之的是，他们编造了一个新的数据元素

1910
00:58:09,380 --> 00:58:10,980
0,210 210,300 300,360 360,1170
cook up a new

1911
00:58:11,070 --> 00:58:12,870
0,270 270,870 1350,1590 1590,1740 1740,1800
data element| and sort of
|只需一次提交写入即可将其交换到数据结构中。

1912
00:58:12,870 --> 00:58:13,920
0,420 420,540 540,720 720,810 810,1050
swap it into the data

1913
00:58:13,920 --> 00:58:15,690
0,510 510,660 660,930 990,1410 1410,1770
structure with a single committing

1914
00:58:15,690 --> 00:58:16,620
0,390
write.|
|

1915
00:58:17,020 --> 00:58:18,550
0,600 600,750 750,810 810,1380 1380,1530
Oh, and the swapping will
哦，而且交换是原子的，所以没问题。

1916
00:58:18,550 --> 00:58:19,780
0,150 150,660 660,840 840,1080 1080,1230
be atomic, so there's no

1917
00:58:19,780 --> 00:58:21,880
0,480 480,900 1470,1800 1800,2040 2040,2100
problem.| Right, because that's a
|对，因为这是一个向右的单指针，它是原子的，

1918
00:58:21,880 --> 00:58:23,350
0,540 540,930 930,1140 1140,1350 1350,1470
single pointer right, which is

1919
00:58:23,350 --> 00:58:25,360
0,450 450,1020 1050,1530 1530,1590 1590,2010
atomic,| whereas overwriting a string
|而重写字符串完全不是原子的。

1920
00:58:25,360 --> 00:58:27,480
0,540 570,960 960,1140 1140,1680
is completely not atomic.|
|

1921
00:58:28,300 --> 00:58:29,500
0,150 150,330 330,660
That makes sense.|
这事儿可以理解。|

1922
00:58:31,030 --> 00:58:32,540
0,240 240,960
Other questions?|
还有其他问题吗？|

1923
00:58:33,410 --> 00:58:36,110
0,510 630,1020 1020,1440 1440,2010 2040,2700
{} Does condition one in
想法三中的条件一是否意味着我们需要注意我们在这些受保护部分中投入了多少工作？

1924
00:58:36,170 --> 00:58:37,540
0,780
{}

1925
00:58:37,750 --> 00:58:38,830
0,390 390,660 660,870 870,960 960,1080
idea three mean we need

1926
00:58:38,830 --> 00:58:40,420
0,90 90,270 270,780 780,1260 1290,1590
to be careful about how

1927
00:58:40,420 --> 00:58:41,920
0,300 300,570 570,720 720,1080 1080,1500
much work we put inside

1928
00:58:41,920 --> 00:58:43,690
0,210 210,690 690,1230 1230,1620 1620,1770
those protected sections| since it
|因为它占据了整个区域的核心。

1929
00:58:43,690 --> 00:58:45,610
0,180 180,240 240,750 750,1170 1350,1920
kind of hogs the core

1930
00:58:45,610 --> 00:58:47,980
0,450 570,720 720,1050 1050,1470
for that entire section.|
|

1931
00:58:48,130 --> 00:58:50,020
0,570 570,870 870,1440 1440,1680 1680,1890
Yes, yes, so this is,
是的，是的，所以这就是，没错，

1932
00:58:50,020 --> 00:58:52,540
0,450 1080,1320 1320,1500 1500,1770 1890,2520
{} that's right,| so, {
|所以，RCU关键部分的读者在查看受保护的数据时，

1933
00:58:52,540 --> 00:58:54,280
0,450 450,960 960,1080 1080,1200 1200,1740
-} readers in the rcu

1934
00:58:54,280 --> 00:58:55,660
0,360 360,750 750,960 960,1080 1080,1380
critical section, while they're looking

1935
00:58:55,660 --> 00:58:57,070
0,150 150,360 360,840 840,1170 1230,1410
at the protected data,| they
|他们不能满足于交换

1936
00:58:57,070 --> 00:58:58,660
0,210 210,630 630,1110 1170,1470 1470,1590
can't content switch| and so
|所以你，你，你现在想把这些关键部分缩短，

1937
00:58:58,660 --> 00:59:00,760
0,330 570,870 870,1560
you're { -},

1938
00:59:01,750 --> 00:59:02,920
0,360 360,780 780,930 930,990 990,1170
you, you want to keep

1939
00:59:02,920 --> 00:59:05,410
0,180 180,480 480,840 840,1590 1860,2490
those critical sections short, now,|
|

1940
00:59:06,980 --> 00:59:09,740
0,330 330,510 510,570 570,1170 2370,2760
and that's a consideration.| The
这是一个考虑因素。|不过，它的结果是，

1941
00:59:09,860 --> 00:59:11,420
0,240 240,360 360,780 780,1050 1050,1560
way it plays out though

1942
00:59:11,720 --> 00:59:12,650
0,240 240,540 540,630 630,810 810,930
is that,| the way {RCU
|RCU的部署方式通常是在Linux中有一些代码，

1943
00:59:12,650 --> 00:59:14,360
0,180 180,330 330,480 480,1350 1380,1710
-} has been deployed is

1944
00:59:14,360 --> 00:59:15,440
0,420 420,570 570,720 720,840 840,1080
typically there will be some

1945
00:59:15,440 --> 00:59:16,790
0,270 270,330 330,660 660,780 780,1350
piece of code in Linux,|
|

1946
00:59:16,910 --> 00:59:18,260
0,240 240,360 360,780 780,900 900,1350
that was protected with ordinary
使用普通锁或读写锁进行保护

1947
00:59:18,260 --> 00:59:20,090
0,540 540,720 720,960 960,1200 1200,1830
locks or read write locks|
|

1948
00:59:20,360 --> 00:59:21,770
0,330 330,1020 1020,1110 1110,1290 1290,1410
and somebody you know for
还有一个你认识的人来承担一些工作量，

1949
00:59:21,770 --> 00:59:24,530
0,240 240,1080 1140,1680 2040,2580 2580,2760
some workloads,| {} {we'll,see} that
|我们将看到锁是一个可怕的性能问题

1950
00:59:24,530 --> 00:59:26,220
0,300 300,420 420,570 570,1200
lock is a terrible

1951
00:59:26,220 --> 00:59:27,960
0,390 600,1080 1080,1470 1470,1650 1650,1740
{} performance problem| and they're
|他们将取代RCU临界区内的锁定临界区，

1952
00:59:27,960 --> 00:59:30,090
0,150 150,330 480,1500 1500,1680 1680,2130
going to replace the locking

1953
00:59:30,090 --> 00:59:32,310
0,420 420,1080 1290,1650 1650,1830 1830,2220
critical section within {RCU -}

1954
00:59:32,310 --> 00:59:33,720
0,390 390,870
critical section,|
|

1955
00:59:33,980 --> 00:59:35,270
0,300 300,600 600,1020 1020,1140 1140,1290
{} although sometimes it's more
尽管有时它比那更复杂。

1956
00:59:35,270 --> 00:59:36,520
0,330 330,450 450,690
involved than that.|
|

1957
00:59:36,740 --> 00:59:38,450
0,360 360,570 570,1020 1020,1380 1380,1710
And since locking critical sections
而且既然已经锁定了临界区，把它们缩短是极其重要的，

1958
00:59:38,450 --> 00:59:40,340
0,210 210,1140 1140,1200 1200,1350 1350,1890
were already, it was extremely

1959
00:59:40,340 --> 00:59:41,570
0,420 420,480 480,660 660,780 780,1230
important to make them short,|
|

1960
00:59:41,810 --> 00:59:42,590
0,270 270,420 420,540 540,720 720,780
because while you hold a
因为当您持有锁时，可能会有很多其他内核在等待该锁，

1961
00:59:42,590 --> 00:59:43,880
0,480 690,900 900,990 990,1080 1080,1290
lock, there may be lots

1962
00:59:43,880 --> 00:59:44,750
0,60 60,210 210,450 450,750 750,870
of other cores waiting for

1963
00:59:44,750 --> 00:59:45,620
0,180 180,510 510,630 630,810 810,870
that lock,| so there's a
|所以保持普通船闸临界区域短的压力很大，

1964
00:59:45,620 --> 00:59:46,700
0,240 240,300 300,600 600,690 690,1080
lot of pressure to keep

1965
00:59:46,850 --> 00:59:48,890
0,600 600,840 840,1170 1170,1560 1560,2040
ordinary lock critical sections short,|
|

1966
00:59:49,730 --> 00:59:51,170
0,300 300,420 420,780 780,1110 1110,1440
because {RCU -} critical sections
因为RCU的临界区通常是修改过的锁临界区，以前就像临界区的东西，

1967
00:59:51,170 --> 00:59:53,420
0,120 120,720 900,1170 1170,1320 1320,2250
are often sort of revised

1968
00:59:53,570 --> 00:59:55,040
0,480 480,840 840,1170 1170,1380 1380,1470
lock critical sec-, things that

1969
00:59:55,040 --> 00:59:55,970
0,210 210,270 270,360 360,570 570,930
used to be like critical

1970
00:59:55,970 --> 00:59:57,260
0,510 630,810 810,1140 1140,1200 1200,1290
sections,| they tend to be
|他们往往也很矮。

1971
00:59:57,260 --> 00:59:58,460
0,330 330,720
short also.|
|

1972
00:59:59,620 --> 01:00:00,970
0,390 660,840 840,900 900,1080 1080,1350
And you know that means
你知道这意味着，你知道并不总是，

1973
01:00:00,970 --> 01:00:01,780
0,210
that,

1974
01:00:03,160 --> 01:00:04,390
0,270 270,330 330,540 540,960 960,1230
you know not always,| but
|但是通常不会有一个，不会直接担心保持RCU关键部分短。

1975
01:00:04,630 --> 01:00:06,850
0,900 1140,1440 1440,1800 1830,2040 2040,2220
usually {} there there's not

1976
01:00:06,850 --> 01:00:07,720
0,270
a,

1977
01:00:09,040 --> 01:00:10,240
0,180 180,240 240,630 630,960 960,1200
not a direct worry about

1978
01:00:10,240 --> 01:00:11,590
0,270 270,450 450,870 870,990 990,1350
keeping {RCU -} critical sections

1979
01:00:11,590 --> 01:00:12,480
0,300
short.|
|

1980
01:00:13,520 --> 01:00:14,750
0,270 270,330 330,450 450,540 540,1230
Although it is a constraint,|
虽然这是一个限制，|

1981
01:00:15,520 --> 01:00:16,720
0,300 300,450 450,780 780,1050 1050,1200
the real constraint actually you're
真正的约束实际上不允许您使用完整的指针来克服上下文切换中指向RCU数据的指针。

1982
01:00:16,720 --> 01:00:17,800
0,120 120,360 360,420 420,600 600,1080
not allowed to whole pointers

1983
01:00:17,800 --> 01:00:18,820
0,450
overcome

1984
01:00:18,820 --> 01:00:20,200
0,390 390,510 510,660 660,960 960,1380
pointers to {RCU -} data

1985
01:00:20,320 --> 01:00:22,320
0,330 330,810 810,1500
over context switches.|
|

1986
01:00:22,320 --> 01:00:23,380
0,480

1987
01:00:23,640 --> 01:00:25,050
0,180 180,390 390,660 660,1020 1020,1410
And that's actually {} you
那实际上你不能，比方说，你不能读取磁盘，然后等待磁盘完成，

1988
01:00:25,050 --> 01:00:26,040
0,270 270,330 330,690 690,930 930,990
can't, for example read the

1989
01:00:26,040 --> 01:00:27,300
0,450 450,690 840,1080 1080,1170 1170,1260
disks and wait for the

1990
01:00:27,300 --> 01:00:28,950
0,240 240,420 420,480 480,930 1050,1650
disk wait to complete,| well
|同时将指针保持在指向RCU保护数据的指针上。

1991
01:00:29,040 --> 01:00:30,480
0,240 240,630 630,780 780,840 840,1440
while holding on a pointer

1992
01:00:30,510 --> 01:00:31,860
0,420 420,480 480,840 840,1110 1140,1350
onto a pointer to {RCU

1993
01:00:31,860 --> 01:00:33,460
0,270 270,690 690,1050
-} protected data.|
|

1994
01:00:33,940 --> 01:00:35,470
0,420 600,870 870,960 960,1170 1170,1530
{} So it's not quite
所以不是很多，

1995
01:00:35,470 --> 01:00:37,210
0,150 150,510 510,840 1290,1590 1590,1740
so much,| the the thing
|通常出现的问题不是临界区的长度，

1996
01:00:37,210 --> 01:00:38,050
0,90 90,360 360,570 570,720 720,840
that usually comes up is

1997
01:00:38,050 --> 01:00:38,800
0,210 210,360 360,600 600,660 660,750
not the length of the

1998
01:00:38,800 --> 01:00:40,360
0,330 330,690 690,870 870,1110 1110,1560
critical section,| so much as
|就像禁止生产CPU一样。

1999
01:00:40,480 --> 01:00:43,450
0,420 720,1470 1470,1830 1830,2310 2310,2970
the prohibition against yielding CPU.|
|

2000
01:00:48,720 --> 01:00:50,160
0,930
Okay.|
好吧。|

2001
01:00:50,590 --> 01:00:51,800
0,630

2002
01:00:53,500 --> 01:00:54,910
0,210 210,330 330,600 690,1260 1260,1410
Let's see, so just kind
让我想想，所以就像是一种坚定的行动，

2003
01:00:54,910 --> 01:00:56,410
0,270 390,600 600,1050 1050,1350 1350,1500
of a firm up,| but
|但是我，我刚才说的所有的事情，

2004
01:00:56,410 --> 01:00:57,730
0,420 720,960 960,1020 1020,1230 1230,1320
I, all the stuff I

2005
01:00:57,730 --> 01:00:59,680
0,180 180,420 420,750 960,1380 1410,1950
just talked about,| {} here's
|以下是您将在RCU的简单使用中看到的内容。

2006
01:00:59,680 --> 01:01:01,280
0,870
the

2007
01:01:01,280 --> 01:01:02,060
0,300 300,360 360,510 510,630 630,780
kind of what you would

2008
01:01:02,060 --> 01:01:04,190
0,540 540,660 660,750 750,1380 1470,2130
see in a simple use

2009
01:01:04,190 --> 01:01:05,320
0,510
of

2010
01:01:05,350 --> 01:01:06,430
0,210 210,690 690,840 840,990 990,1080
{RCU -}.| So this is
|这就是代码，

2011
01:01:06,430 --> 01:01:08,320
0,720 930,1230 1230,1410 1410,1680 1680,1890
code,| you might see for
|您可能会看到用于读取列表和RCU保护列表

2012
01:01:08,320 --> 01:01:11,160
0,270 270,330 330,960 1620,2280
reading a list {},

2013
01:01:11,910 --> 01:01:12,930
0,120 120,330 330,720 720,930 930,1020
{and,rcu -} protected lists| and
|这是代码，你可能会在写字端看到，

2014
01:01:12,930 --> 01:01:13,410
0,90 90,150 150,210 210,390 390,480
this is the code, you

2015
01:01:13,410 --> 01:01:14,430
0,180 180,510 510,690 690,780 780,1020
might see on the write

2016
01:01:14,430 --> 01:01:16,050
0,630 690,930 930,1140 1140,1260 1260,1620
side,| for code that just
|对于只想要替换第一列表元素的特定情况的代码，

2017
01:01:16,050 --> 01:01:18,600
0,240 240,540 1230,1590 1860,2310 2310,2550
wants to a particular case

2018
01:01:18,600 --> 01:01:20,100
0,90 90,540 540,630 630,1170 1200,1500
of replacing the first list

2019
01:01:20,100 --> 01:01:21,840
0,420 690,900 900,990 990,1200 1200,1740
element,| so the read side,
|所以在读取端，实际上有这个，这些读锁定和读解锁调用，

2020
01:01:21,870 --> 01:01:23,580
0,420 420,600 600,780 780,1140 1140,1710
{} there is actually this,

2021
01:01:23,640 --> 01:01:25,410
0,420 630,1050 1080,1380 1380,1650 1650,1770
{} these read lock and

2022
01:01:25,410 --> 01:01:28,410
0,210 210,840 870,1650 1890,2670 2670,3000
read unlock calls,| those do
|它们几乎什么都不做几乎什么都不做，

2023
01:01:28,410 --> 01:01:31,290
0,630 630,1020 1170,1650 1650,2040 2220,2880
almost nothing almost nothing {},|
|

2024
01:01:32,200 --> 01:01:33,910
0,210 210,810 840,1080 1080,1410 1410,1710
the only the only little
他们唯一做的一件小事就是竖起一面旗帜，上面写着

2025
01:01:33,910 --> 01:01:35,080
0,240 240,420 420,720 720,840 840,1170
thing they do is set

2026
01:01:35,080 --> 01:01:36,940
0,90 90,900 900,1110 1110,1680 1680,1860
a flag that says| or
|或者RCU_READ_LOCK设置一个标志，该标志表示如果发生定时器中断，请不要进行上下文切换，

2027
01:01:36,940 --> 01:01:38,140
0,90 90,450 450,930 930,1140 1140,1200
{rcu_read_lock - -} sets a

2028
01:01:38,140 --> 01:01:39,850
0,330 330,450 450,810 1290,1650 1650,1710
flag that says if a

2029
01:01:39,850 --> 01:01:41,770
0,360 360,720 720,1230 1260,1710 1710,1920
timer interrupt happens, please don't

2030
01:01:41,770 --> 01:01:43,240
0,450 450,1020 1050,1260 1260,1410 1410,1470
context switch,| because I'm in
|因为我在RCU临界区中间。

2031
01:01:43,240 --> 01:01:44,600
0,60 60,390 390,510 510,870
the middle of {}

2032
01:01:44,750 --> 01:01:46,220
0,210 210,480 480,870 870,1290 1320,1470
{rcu -} critical section.| So
|所以这就是真正设置了禁止定时器中断上下文切换的标志，

2033
01:01:46,220 --> 01:01:47,300
0,150 150,360 360,570 570,870 870,1080
that's all really does set

2034
01:01:47,300 --> 01:01:49,550
0,30 30,420 420,600 960,1830 1860,2250
a flag that prohibits timer

2035
01:01:49,550 --> 01:01:51,350
0,390 390,810 810,1320 1350,1710 1710,1800
interrupt context switches,| interrupts may
|中断可能仍会发生，但不会切换上下文

2036
01:01:51,350 --> 01:01:52,220
0,210 210,450 450,600 600,660 660,870
still happen, but it wont

2037
01:01:52,220 --> 01:01:53,930
0,420 420,840 1140,1410 1410,1530 1530,1710
context switch| and then read
|然后读取解锁解锁标志，

2038
01:01:53,930 --> 01:01:56,570
0,660 990,1710 1710,2130 2160,2460 2460,2640
unlock unset flag,| really it's
|实际上，它是嵌套的RCU临界区的计数器。

2039
01:01:56,570 --> 01:01:57,220
0,150
{}

2040
01:01:57,220 --> 01:01:59,470
0,510 510,630 630,1350 1740,1980 1980,2250
counter of nested {RCU -}

2041
01:01:59,470 --> 01:02:01,000
0,330 330,870 1080,1260 1260,1410 1410,1530
critical sections.| So these two
|所以这两个函数非常快，几乎什么也不做。

2042
01:02:01,000 --> 01:02:02,260
0,300 300,360 360,840 840,1140 1140,1260
functions are extremely fast and

2043
01:02:02,260 --> 01:02:03,480
0,90 90,420 420,660
do almost nothing.|
|

2044
01:02:03,570 --> 01:02:04,660
0,510

2045
01:02:04,750 --> 01:02:05,800
0,150 150,300 300,510 510,810 810,1050
And then this loop would
然后这个循环会向下扫描Our列表，

2046
01:02:05,800 --> 01:02:07,180
0,180 180,240 240,690 690,1110 1110,1380
sort of scan down the

2047
01:02:07,180 --> 01:02:08,100
0,300
{

2048
01:02:09,090 --> 01:02:11,880
0,810 1110,1410 1410,2070 2100,2670 2670,2790
-} our list,| this is
|这就是插入记忆屏障的电话，

2049
01:02:11,880 --> 01:02:14,790
0,90 90,900 1170,1620 1620,2070 2400,2910
the call that {} insert

2050
01:02:14,790 --> 01:02:16,410
0,90 90,540 540,1170 1260,1470 1470,1620
the memory barrier,| so what
|所以RCU，这真的可以归结为几条指令，

2051
01:02:16,410 --> 01:02:17,960
0,150 150,780
{RCU -},

2052
01:02:17,960 --> 01:02:18,890
0,180 180,390 390,660 660,840 840,930
this really boils down to

2053
01:02:18,890 --> 01:02:20,930
0,180 180,240 240,750 1170,1350 1350,2040
just a couple of instructions,|
|

2054
01:02:21,020 --> 01:02:23,740
0,240 240,480 510,1530 1560,2220
it just reads, {}
它只是读取，它会抓取这个指针的副本来存储，

2055
01:02:24,660 --> 01:02:25,980
0,210 210,810 810,900 900,1260 1260,1320
it grabs a copy of

2056
01:02:25,980 --> 01:02:27,870
0,150 150,480 480,600 600,1230 1290,1890
this pointer for memory,| issues
|发出内存屏障，然后返回该指针。

2057
01:02:27,870 --> 01:02:29,790
0,60 60,420 420,1080 1260,1590 1590,1920
a memory barrier and then

2058
01:02:29,820 --> 01:02:31,580
0,450 450,630 630,1200
returns that pointer.|
|

2059
01:02:31,690 --> 01:02:32,900
0,510

2060
01:02:37,260 --> 01:02:37,920
0,150 150,240 240,330 330,450 450,660
And then we can look
然后我们可以查看内容并继续下一个列表元素。

2061
01:02:37,920 --> 01:02:39,510
0,60 60,150 150,960 1110,1500 1500,1590
at the content and go

2062
01:02:39,510 --> 01:02:40,290
0,120 120,210 210,270 270,570 570,780
on to the next list

2063
01:02:40,290 --> 01:02:41,260
0,480
element.|
|

2064
01:02:41,710 --> 01:02:43,240
0,360 360,420 420,1020
So the readers
所以读者很简单。

2065
01:02:43,690 --> 01:02:44,640
0,480
{}

2066
01:02:44,640 --> 01:02:45,990
0,150 150,570 630,1020 1020,1290 1290,1350
quite simple.| The writers a
|编剧们更多地参与其中，

2067
01:02:45,990 --> 01:02:48,540
0,150 150,330 330,960 1110,1560 1560,2550
little more involved,| writers still,
|编剧们仍然，你知道RCU并不能帮助编剧们避免互相干扰，

2068
01:02:49,020 --> 01:02:50,460
0,630 780,900 900,990 990,1140 1140,1440
{} you know the RCU

2069
01:02:50,460 --> 01:02:52,410
0,210 210,600 630,1230 1230,1530 1530,1950
doesn't help writers avoid interfering

2070
01:02:52,410 --> 01:02:53,400
0,150 150,300 300,510 510,690 690,990
with each other,| so writers
|因此，编写者仍然必须有某种方法来确保一次只有一个编写者修改列表。

2071
01:02:53,400 --> 01:02:54,120
0,180 180,330 330,420 420,540 540,720
still have to have some

2072
01:02:54,120 --> 01:02:55,440
0,240 240,330 540,870 870,1080 1080,1320
way of making sure only

2073
01:02:55,440 --> 01:02:56,790
0,240 240,540 540,1080 1080,1140 1140,1350
one writer modifies the list

2074
01:02:56,790 --> 01:02:57,990
0,90 90,150 150,600 840,1050 1050,1200
at a time.| In this
|在这种情况下，我只是想象我们将使用普通的自旋锁，

2075
01:02:57,990 --> 01:02:59,550
0,300 480,810 810,960 960,1380 1380,1560
case, I'm just imagining we're

2076
01:02:59,550 --> 01:03:00,460
0,120 120,180 180,540
going to use

2077
01:03:00,460 --> 01:03:02,500
0,390 720,1050 1050,1350 1350,1890 1890,2040
{} ordinary spin locks,| so
|所以写入者需要锁。

2078
01:03:02,500 --> 01:03:03,820
0,60 60,240 240,660 660,780 780,1320
the writer requires the lock.|
|

2079
01:03:04,720 --> 01:03:06,040
0,180 180,300 300,900 900,990 990,1320
If we're replacing the first
如果我们要替换第一个列表元素，

2080
01:03:06,040 --> 01:03:07,380
0,270 270,720
list element,|
|

2081
01:03:07,620 --> 01:03:08,370
0,240 240,420 420,510 510,690 690,750
we need to save a
我们需要在一开始保存一份副本，

2082
01:03:08,370 --> 01:03:10,680
0,600 750,990 990,1050 1050,1680 1950,2310
copy at the beginning,| because
|因为我们最终需要释放它，

2083
01:03:10,680 --> 01:03:11,160
0,90 90,210 210,270 270,420 420,480
we're going to need to

2084
01:03:11,160 --> 01:03:12,600
0,420 420,720 720,1020 1200,1350 1350,1440
eventually free it,| so we
|所以我们保存这个最古老元素的副本，

2085
01:03:12,600 --> 01:03:13,410
0,210 210,330 330,660 660,720 720,810
save this copy of the

2086
01:03:13,410 --> 01:03:15,390
0,390 390,750 1020,1380 1380,1710 1800,1980
oldest element,| now we're this
|现在我们是这个代码在玩我刚才说过的那个把戏，

2087
01:03:15,390 --> 01:03:16,350
0,240 240,480 480,660 660,930 930,960
code plays that trick I

2088
01:03:16,350 --> 01:03:18,240
0,330 330,630 630,990 1050,1800 1800,1890
talked again about,| allocating a
|分配一个完整的新列表元素来保存此更新的内容。

2089
01:03:18,240 --> 01:03:19,530
0,300 300,480 480,750 750,1230 1230,1290
complete new list element to

2090
01:03:19,530 --> 01:03:22,740
0,270 270,570 600,1500 1890,2400 2430,3210
hold this updated a content.|
|

2091
01:03:23,470 --> 01:03:24,460
0,120 120,270 270,660 660,690 690,990
We're gonna allocate a new
我们将分配一个新的列表元素，我们将设置其内容，

2092
01:03:24,460 --> 01:03:25,960
0,270 270,630 630,720 720,990 1110,1500
list element, we're gonna set

2093
01:03:25,960 --> 01:03:27,520
0,120 120,750 750,810 810,1080 1110,1560
its content,| we're gonna set
|当我们替换旧的第一个列表元素时，我们将把下一个指针设置为旧的第一个列表元素中的下一个指针

2094
01:03:27,520 --> 01:03:30,310
0,120 120,420 420,900 1500,2100 2580,2790
the next pointer to the

2095
01:03:30,310 --> 01:03:31,570
0,210 210,510 510,570 570,660 660,1260
next pointer in the old

2096
01:03:31,720 --> 01:03:33,340
0,390 390,630 630,1050 1290,1470 1470,1620
first list element as we're

2097
01:03:33,340 --> 01:03:34,960
0,420 420,600 1020,1260 1260,1410 1410,1620
replacing it| and then this
|然后该RCU赋值指针发出内存屏障，

2098
01:03:34,960 --> 01:03:37,120
0,180 180,480 480,960 960,1740
{RCU -} assign pointer

2099
01:03:37,180 --> 01:03:39,760
0,510 750,1290 1290,1350 1350,1830 1830,2580
{} issues a memory barrier,|
|

2100
01:03:39,940 --> 01:03:41,740
0,420 420,570 570,780 780,1260 1290,1800
so that all these these
所以所有这些写入都发生了，

2101
01:03:41,740 --> 01:03:43,220
0,240 240,840
writes happened,|
|

2102
01:03:43,500 --> 01:03:46,470
0,600 900,1170 1170,1470 1470,2340 2730,2970
{} and then sets a
然后将该第一个参数所指向的指针设置为等于，

2103
01:03:46,470 --> 01:03:47,640
0,360 360,720 720,870 870,990 990,1170
pointer pointed to by this

2104
01:03:47,640 --> 01:03:48,690
0,270 270,660 660,750 750,840 840,1050
first argument to be equal

2105
01:03:48,690 --> 01:03:50,010
0,60 60,300 300,450 450,900 1110,1320
to that,| so basically this
|基本上，这只是发出一个内存屏障，然后将head设置为e。

2106
01:03:50,010 --> 01:03:51,600
0,330 360,630 630,690 690,1020 1020,1590
just issues a memory barrier

2107
01:03:51,660 --> 01:03:52,860
0,210 210,360 360,690 690,960 960,1200
and then sets head equal

2108
01:03:52,860 --> 01:03:54,100
0,240 300,720
to e.|
|

2109
01:03:54,690 --> 01:03:55,530
0,270 270,360 360,480 480,750 750,840
Now we can release the
现在我们可以打开锁了，

2110
01:03:55,530 --> 01:03:56,850
0,390 720,1020 1020,1170 1170,1260 1260,1320
lock,| we still have a
|我们仍然有一个指向旧的第一个列表元素的指针，

2111
01:03:56,850 --> 01:03:58,500
0,450 450,540 540,660 660,1320 1320,1650
pointer to the old first

2112
01:03:58,500 --> 01:03:59,780
0,240 240,660
list element,|
|

2113
01:03:59,870 --> 01:04:01,100
0,210 210,780 780,900 900,1170 1170,1230
call {synchronize_rcu - -} to
调用同步_rcu以确保每个本可以抓取指向最旧元素的指针的cpu，

2114
01:04:01,100 --> 01:04:02,720
0,150 150,300 300,1080
make sure every

2115
01:04:02,750 --> 01:04:04,060
0,750
{}

2116
01:04:04,150 --> 01:04:05,890
0,540 540,660 660,840 840,930 930,1740
CPU that could have grabbed

2117
01:04:05,890 --> 01:04:07,100
0,150 150,660
a {}

2118
01:04:07,360 --> 01:04:08,770
0,450 450,510 510,630 630,1050 1050,1410
pointer to the oldest element,|
|

2119
01:04:08,770 --> 01:04:10,360
0,630 630,780 780,990 990,1110 1110,1590
before we did the committing
在我们执行此操作之前，提交写入已产生CPU

2120
01:04:10,360 --> 01:04:12,430
0,570 780,990 990,1320 1320,1380 1380,2070
write has yielded the CPU|
|

2121
01:04:12,910 --> 01:04:14,260
0,150 150,420 420,660 660,840 840,1350
and therefore given up its
因此放弃其指针RCU保护数据

2122
01:04:14,560 --> 01:04:16,540
0,300 300,720 720,1140 1140,1470 1710,1980
pointer RCU protected data| and
|现在我们可以释放旧的列表元素了。

2123
01:04:16,540 --> 01:04:17,470
0,210 210,300 300,480 480,810 810,930
now we could free the

2124
01:04:17,470 --> 01:04:18,560
0,540
old

2125
01:04:18,870 --> 01:04:20,040
0,240 240,630
list element.|
|

2126
01:04:23,440 --> 01:04:24,960
0,240 240,960
Any questions?|
有什么问题吗？|

2127
01:04:35,680 --> 01:04:38,240
0,960 1230,1860
Alright {}.|
好的。|

2128
01:04:43,130 --> 01:04:44,880
0,1110

2129
01:04:45,270 --> 01:04:46,800
0,270 270,840 960,1320 1320,1470 1470,1530
{There,RCU -} one thing to
RCU关于这件事需要注意的一件事是

2130
01:04:46,800 --> 01:04:47,820
0,240 240,450 450,660 660,780 780,1020
note about this is that|
|

2131
01:04:48,000 --> 01:04:49,950
0,990 990,1110 1110,1260 1260,1680 1680,1950
while in the reader, while
在阅读器中，虽然我们可以在这里查看循环内的列表元素，

2132
01:04:49,950 --> 01:04:51,120
0,120 120,360 360,450 450,1050 1050,1170
we're allowed to look at

2133
01:04:51,120 --> 01:04:52,440
0,210 210,450 450,840 840,1230 1230,1320
this list element inside the

2134
01:04:52,440 --> 01:04:54,210
0,270 270,720 750,1560 1560,1680 1680,1770
loop here,| one thing we're
|我们不允许做的一件事是返回列表元素，

2135
01:04:54,210 --> 01:04:55,680
0,390 390,720 720,780 780,1230 1260,1470
not allowed to do is

2136
01:04:55,680 --> 01:04:57,810
0,480 480,600 600,870 870,1530 1770,2130
return the list element,| so
|例如，我们使用RCU，

2137
01:04:57,870 --> 01:04:59,400
0,330 330,780 810,1080 1080,1410 1410,1530
for example we using {RCU

2138
01:04:59,400 --> 01:05:01,200
0,330 330,450 450,1050 1080,1620 1620,1800
-},| we couldn't write a
|我们无法编写查找列表查找函数，

2139
01:05:01,200 --> 01:05:03,330
0,570 570,720 720,1050 1050,1440 1440,2130
lookup a list lookup function,|
|

2140
01:05:03,880 --> 01:05:05,620
0,150 150,1080
that returned
它返回列表元素或指向保存在列表元素中的数据的指针，

2141
01:05:05,620 --> 01:05:07,990
0,300 300,420 420,750 750,1470 1740,2370
either the list element or

2142
01:05:08,020 --> 01:05:11,410
0,330 330,960 960,1950 2070,2970 2970,3390
a pointer into data held

2143
01:05:11,410 --> 01:05:12,550
0,210 210,330 330,600 600,990 990,1140
in the list element,| like
|就像嵌入在列表元素中的字符串一样。

2144
01:05:12,550 --> 01:05:13,630
0,60 60,450 450,540 540,660 660,1080
a string that was embedded

2145
01:05:13,630 --> 01:05:16,220
0,60 60,150 150,420 420,930
in the list element.|
|

2146
01:05:18,490 --> 01:05:19,750
0,510 510,750 750,870 870,990 990,1260
Because then we'd be in,
因为那样我们就进去了，我们就不再控制了，

2147
01:05:19,780 --> 01:05:20,770
0,240 240,360 360,450 450,630 630,990
then we would no longer

2148
01:05:20,770 --> 01:05:21,760
0,150 150,240 240,660 660,750 750,990
be in control,| you know
|你知道，我们不会把受RCU保护的数据放在外面，

2149
01:05:21,970 --> 01:05:22,780
0,360 360,570 570,630 630,720 720,810
it has to be the

2150
01:05:22,780 --> 01:05:24,070
0,300 300,630 720,900 900,1080 1080,1290
case that we don't look

2151
01:05:24,070 --> 01:05:25,090
0,90 90,210 210,390 390,750 750,1020
at {RCU -} protected data

2152
01:05:25,090 --> 01:05:26,740
0,1080
outside,|
|

2153
01:05:26,890 --> 01:05:28,900
0,600 630,810 810,1170 1170,1560 1560,2010
{} this RCU critical section
这个RCU临界区或者我们不进行上下文切换，

2154
01:05:28,900 --> 01:05:29,620
0,150 150,300 330,540 540,660 660,720
or we don't do a

2155
01:05:29,620 --> 01:05:30,910
0,450 450,630 630,1020 1020,1110 1110,1290
context switch,| if we just
|如果我们只编写一个返回列表元素的泛型函数，

2156
01:05:30,910 --> 01:05:32,020
0,270 270,360 360,780 780,1020 1020,1110
write a generic function that

2157
01:05:32,020 --> 01:05:33,550
0,330 330,390 390,630 630,990 1230,1530
returns a list element,| then
|那么就我们所了解的来电者而言，

2158
01:05:33,550 --> 01:05:34,240
0,150 150,300 300,420 420,570 570,690
for all we know the

2159
01:05:34,240 --> 01:05:35,700
0,630
caller,|
|

2160
01:05:36,110 --> 01:05:36,890
0,240 240,330 330,420 420,720 720,780
maybe we can persuade the
也许我们也可以说服打电话的人遵守一些规则，

2161
01:05:36,890 --> 01:05:37,850
0,270 270,360 360,600 600,750 750,960
caller to follow some rules

2162
01:05:37,850 --> 01:05:39,760
0,180 180,420
too,| but
|但据我们所知，呼叫者会进行上下文切换

2163
01:05:39,910 --> 01:05:41,740
0,360 360,510 510,630 630,1170
for all we know,

2164
01:05:41,870 --> 01:05:43,370
0,480 480,600 600,900 900,1020 1020,1500
{} the caller make context

2165
01:05:43,370 --> 01:05:45,400
0,570 600,1290
switch| or
|或者我们在返回列表元素之前调用RCU_READ_UNLOCK就会遇到麻烦，

2166
01:05:45,550 --> 01:05:47,500
0,750 1050,1290 1290,1500 1500,1680 1680,1950
{} we run into trouble

2167
01:05:47,500 --> 01:05:48,700
0,210 210,330 330,600 600,720 720,1200
either we call {rcu_read_unlock -

2168
01:05:48,700 --> 01:05:50,440
0,510 510,840 840,1380 1380,1500 1500,1740
-} before returning the list

2169
01:05:50,440 --> 01:05:51,600
0,570
element,|
|

2170
01:05:51,600 --> 01:05:52,590
0,120 120,210 210,600 600,840 840,990
which is illegal, because now
这是非法的，因为现在定时器中断可能会强制切换

2171
01:05:52,590 --> 01:05:53,760
0,90 90,480 480,780 780,930 930,1170
a timer interrupt could force

2172
01:05:53,760 --> 01:05:55,410
0,90 90,720 1020,1350 1350,1440 1440,1650
a switch| or we don't
|否则我们不调用rcu_read_unlock。

2173
01:05:55,410 --> 01:05:56,880
0,240 240,360 360,870 870,1200 1200,1470
call {rcu_read_unlock - -}.| So
|因此，RCU的观点确实给读者带来了一些额外的约束，这在以前是不存在的。

2174
01:05:57,090 --> 01:05:58,230
0,420 420,510 510,630 630,930 930,1140
views of {RCU -} sort

2175
01:05:58,230 --> 01:06:00,020
0,210 630,1230
of {}

2176
01:06:00,780 --> 01:06:02,310
0,360 360,540 540,660 660,1020 1020,1530
does put some additional constraints

2177
01:06:02,310 --> 01:06:03,680
0,150 150,690
on readers,

2178
01:06:03,740 --> 01:06:05,120
0,180 210,450 450,540 540,930 930,1380
that wouldn't have existed before.|
|

2179
01:06:06,400 --> 01:06:08,320
0,210 210,570 570,840 840,1140 1500,1920
A question about that.| Yes.|
关于这一点的一个问题。|是。|

2180
01:06:08,350 --> 01:06:09,280
0,300 300,420 420,570 570,810 810,930
So, are you saying in
那么，您是说如果我们在索引I方法中有某种形式LIKE READ元素，

2181
01:06:09,280 --> 01:06:11,620
0,630 630,960 1290,1650 1650,1800 1800,2340
particular, that if we had

2182
01:06:11,830 --> 01:06:14,650
0,480 480,840 840,1140 1170,1860 2130,2820
some form of like read

2183
01:06:14,650 --> 01:06:17,860
0,540 540,780 780,1620 1770,2310 2610,3210
element at index i method,|
|

2184
01:06:18,490 --> 01:06:19,960
0,360 390,780 780,1080 1080,1320 1320,1470
that there's no way to
没有办法来组织这件事，

2185
01:06:19,960 --> 01:06:21,520
0,570 570,810 810,1080 1080,1410 1410,1560
structure this,| so that it
|这样它就可以返回mode元素i持有的值。

2186
01:06:21,520 --> 01:06:23,410
0,240 240,720 720,900 900,1440 1440,1890
could return the value held

2187
01:06:23,410 --> 01:06:25,180
0,180 180,420 450,930 930,1350 1350,1770
by the mode element i.|
|

2188
01:06:25,300 --> 01:06:27,580
0,240 240,480 480,510 510,1110
{It,could} return a copy.|
它可以退回一份副本。|

2189
01:06:27,970 --> 01:06:29,200
0,180 180,390 390,570 570,1080 1080,1230
So what would work, you
那么，如果e->x是一个字符串，

2190
01:06:29,200 --> 01:06:30,070
0,90 90,210 210,600 600,780 780,870
know if {e->x -} is

2191
01:06:30,070 --> 01:06:31,120
0,90 90,480 480,600 600,780 780,1050
a string,| we could return
|我们可以退回一份这个字符串的副本，这很好，

2192
01:06:31,120 --> 01:06:32,080
0,30 30,390 390,450 450,600 600,960
a copy of this string,

2193
01:06:32,080 --> 01:06:34,540
0,90 90,270 270,960 1860,2280 2280,2460
and that's fine,| what would
|什么会违反RCU的规定，

2194
01:06:34,540 --> 01:06:35,860
0,180 180,390 390,1020 1020,1140 1140,1320
be a violation of {RCU

2195
01:06:35,860 --> 01:06:37,420
0,300 300,780 780,960 960,1200 1200,1560
-} rules,| if we return
|如果我们返回一个指针，指向位于内部的这个字符串，

2196
01:06:37,420 --> 01:06:39,490
0,210 210,1200 1230,1380 1380,1680 1680,2070
a pointer to this very

2197
01:06:39,490 --> 01:06:42,540
0,510 510,840 840,1500
string sitting inside,|
|

2198
01:06:42,960 --> 01:06:44,600
0,120 120,570 570,720 720,1260
a pointer { -}
指针，将指针返回到某种程度上是错误的。

2199
01:06:44,960 --> 01:06:45,680
0,90 90,180 180,270 270,330 330,720
it would be a mistake

2200
01:06:45,680 --> 01:06:47,180
0,90 90,420 420,510 510,990 990,1500
to return a pointer into

2201
01:06:47,180 --> 01:06:49,560
0,210 510,900 900,1260 1260,1710
{} somewhat into e.|
|

2202
01:06:50,920 --> 01:06:51,970
0,210 210,300 300,600 600,690 690,1050
If the string is stored
如果字符串存储在列表元素内，

2203
01:06:51,970 --> 01:06:53,260
0,510 510,600 600,840 840,1200 1200,1290
inside the list element,| we
|我们最好不要把这个指针返回那个字符串，

2204
01:06:53,260 --> 01:06:54,460
0,180 180,360 360,660 660,780 780,1200
better not return this pointer

2205
01:06:54,460 --> 01:06:55,780
0,180 180,570
that string,|
|

2206
01:06:55,900 --> 01:06:58,640
0,450 990,1470 1470,1890 1890,1890
{} because then, {}
因为这样，您就不需要上下文，我们将指针指向RCU保护的数据

2207
01:06:58,820 --> 01:07:01,500
0,420 1530,1770 1770,1860
that will be,

2208
01:07:03,210 --> 01:07:04,170
0,90 90,180 180,270 270,510 510,960
you have to not context

2209
01:07:04,170 --> 01:07:05,250
0,210 210,390 390,630 630,690 690,1080
swhich we're holding a pointer

2210
01:07:05,790 --> 01:07:07,440
0,630 630,780 780,990 990,1350 1350,1650
into {RCU -} protected data|
|

2211
01:07:07,830 --> 01:07:09,150
0,420 420,990 1020,1110 1110,1200 1200,1320
and the you know the
而你知道的惯例是你知道你只需要在这个关键部分中使用这些数据。

2212
01:07:09,150 --> 01:07:11,280
0,660 660,1590 1740,1890 1890,2010 2010,2130
convention is you know you

2213
01:07:11,280 --> 01:07:12,390
0,240 240,360 360,540 540,840 840,1110
just use that data within

2214
01:07:12,390 --> 01:07:13,820
0,120 120,480 480,870
this critical section.|
|

2215
01:07:14,410 --> 01:07:15,100
0,150 150,240 240,300 300,420 420,690
And so it would almost
因此，几乎可以肯定的是，这将打破惯例

2216
01:07:15,100 --> 01:07:16,360
0,270 270,390 390,720 720,810 810,1260
certainly be breaking the convention|
|

2217
01:07:16,360 --> 01:07:17,500
0,120 120,600 630,960 960,1050 1050,1140
or this setup would have
否则这个设置会复杂得多，

2218
01:07:17,500 --> 01:07:18,580
0,60 60,120 120,300 300,420 420,1080
to be much more complicated,|
|

2219
01:07:18,760 --> 01:07:19,870
0,270 270,360 360,510 510,630 630,1110
if we ended up returning
如果我们最终返回指向受保护数据的指针。

2220
01:07:19,870 --> 01:07:22,240
0,720 750,1320 1620,1710 1710,2070 2070,2370
pointers into the protected data.|
|

2221
01:07:24,050 --> 01:07:25,440
0,390 390,990
Thank you.|
谢谢。|

2222
01:07:26,780 --> 01:07:28,220
0,690

2223
01:07:29,180 --> 01:07:31,670
0,720 930,1410 1410,1560 1560,1710 1710,2490
The I just want to
我只想简单地回到表演故事上来。

2224
01:07:31,730 --> 01:07:33,140
0,390 390,720 720,780 780,870 870,1410
return briefly to the performance

2225
01:07:33,140 --> 01:07:35,380
0,600
story.|
|

2226
01:07:35,850 --> 01:07:38,040
0,360 360,1260 1260,1800 1890,2040 2040,2190
{} It's {} it's hard
很难描述这是一场什么样的表演，

2227
01:07:38,040 --> 01:07:40,160
0,60 60,900 900,1080 1080,1500
to characterize sort of

2228
01:07:40,450 --> 01:07:41,920
0,210 210,300 300,1230 1230,1260 1260,1470
what the {performance,is},| I mean
|我的意思是，在某种意义上，

2229
01:07:42,010 --> 01:07:44,260
0,180 180,240 240,780 1020,1620
in a sense {},|
|

2230
01:07:45,280 --> 01:07:46,840
0,390 510,870 870,990 990,1320 1410,1560
the, let's see the the
让我们看看整体性能的故事是，如果你使用RCU，

2231
01:07:46,840 --> 01:07:48,010
0,270 270,630 630,870 870,990 990,1170
overall performance story is that

2232
01:07:48,100 --> 01:07:49,300
0,210 210,300 300,450 450,600 600,1200
if you use {RCU -},|
|

2233
01:07:49,450 --> 01:07:50,710
0,390 390,450 450,870 870,1200 1200,1260
reads are extremely fast,| they
读取速度极快，|他们只是在没有超出查看数据的普通开销的开销的情况下继续工作，

2234
01:07:50,710 --> 01:07:53,200
0,210 210,960 960,1290 1290,2160 2250,2490
just proceed at whatever they've

2235
01:07:53,200 --> 01:07:55,690
0,240 240,420 420,1140 1170,2070 2190,2490
served no overhead above the

2236
01:07:55,690 --> 01:07:57,310
0,690 690,1110 1110,1230 1230,1500 1500,1620
ordinary overhead of looking at

2237
01:07:57,310 --> 01:07:58,450
0,240 240,630 690,840 840,960 960,1140
that data,| so if your
|所以如果你的列表有十亿个元素长，

2238
01:07:58,450 --> 01:08:00,520
0,420 420,750 780,1170 1170,1650 1650,2070
list is a billion elements

2239
01:08:00,520 --> 01:08:02,140
0,300 300,780 930,1230 1230,1530 1530,1620
long,| yeah reading list will
|是啊，阅读清单需要很长时间，

2240
01:08:02,140 --> 01:08:03,040
0,180 180,240 240,390 390,720 720,900
take a long time,| but
|但这并不是因为同步，只是因为你为读者做了很多工作。

2241
01:08:03,040 --> 01:08:03,940
0,180 180,510
it's not

2242
01:08:04,060 --> 01:08:05,590
0,360 360,1020 1020,1140 1140,1290 1290,1530
because synchronization, is just because

2243
01:08:05,590 --> 01:08:06,130
0,90 90,270 270,330 330,450 450,540
you're doing a lot of

2244
01:08:06,130 --> 01:08:09,260
0,390 630,1350 1560,1920 1920,2640
work {} for readers.|
|

2245
01:08:09,350 --> 01:08:11,660
0,480 660,960 960,1200 1200,1650 1650,2310
So you can almost view
因此您几乎可以看到RCU对读取器的开销为零

2246
01:08:12,300 --> 01:08:13,680
0,240 240,600 600,720 720,960 960,1380
{RCU -} is having zero

2247
01:08:13,680 --> 01:08:16,470
0,450 450,600 600,1170 1170,1680 2190,2790
overhead for readers| and {}
|例外情况很小，

2248
01:08:17,680 --> 01:08:19,750
0,720 720,780 780,1410 1530,1830 1830,2070
exceptions are minor,| {rcu_read_lock -
|RCU_READ_LOCK，您知道只需要很少的工作就可以设置这个标志，说明没有上下文切换

2249
01:08:19,750 --> 01:08:20,920
0,600
-},

2250
01:08:21,010 --> 01:08:21,700
0,270 270,360 360,450 450,630 630,690
{} you know just a

2251
01:08:21,700 --> 01:08:22,690
0,390 390,600 600,690 690,900 900,990
tiny amount of work to

2252
01:08:22,690 --> 01:08:24,040
0,180 180,360 360,690 690,1050 1050,1350
set this flag saying no

2253
01:08:24,040 --> 01:08:26,440
0,480 480,990 1260,1590 1590,1740 1740,2400
context switches| and {rcu_dereference -
|并且rcu_dereference发出一个内存屏障，它实际上可能会使你减慢几十，几十个周期，

2254
01:08:26,440 --> 01:08:28,030
0,510 510,780 780,840 840,1140 1140,1590
-} issues a memory barrier

2255
01:08:28,030 --> 01:08:31,150
0,450 660,1320 1530,2670 2670,2880 2880,3120
which {} actually might slow

2256
01:08:31,150 --> 01:08:33,010
0,120 120,450 450,870 900,1710 1740,1860
you down by dozens, {}

2257
01:08:33,010 --> 01:08:35,200
0,150 150,420 420,1200
few dozen cycles,|
|

2258
01:08:35,930 --> 01:08:37,370
0,360 360,450 450,720 720,1080 1080,1440
but it's much cheaper than
但是它比锁便宜多了。

2259
01:08:39,280 --> 01:08:40,460
0,150 150,600
a lock.|
|

2260
01:08:41,030 --> 01:08:42,290
0,300 300,420 420,870 870,1110 1110,1260
{} The performance story for
编剧的表演故事要悲哀得多，

2261
01:08:42,290 --> 01:08:44,120
0,450 450,600 600,780 780,1470 1620,1830
writers is much sadder,| you
|你必须做所有的事情，你总是要用锁，

2262
01:08:44,120 --> 01:08:44,690
0,90 90,150 150,300 300,480 480,570
have to do all the

2263
01:08:44,690 --> 01:08:45,650
0,270 270,420 420,720 720,900 900,960
stuff, you always had to

2264
01:08:45,650 --> 01:08:47,150
0,180 180,480 480,960 960,1050 1050,1500
do using locks,| in fact
|实际上，您必须获取并释放编写器中的锁

2265
01:08:47,150 --> 01:08:47,960
0,90 90,180 180,330 330,720 720,810
you have to acquire and

2266
01:08:47,960 --> 01:08:49,880
0,270 270,810 1080,1320 1320,1410 1410,1920
release locks in the writer|
|

2267
01:08:50,630 --> 01:08:52,550
0,630 630,720 720,840 840,1410 1440,1920
and you have this potentially
您有一个可能非常昂贵或耗时的名称为同步_rcu。

2268
01:08:52,550 --> 01:08:55,070
0,420 420,840 840,1290 1350,1590 1620,2520
extremely expensive called or time-consuming

2269
01:08:55,070 --> 01:08:56,810
0,300 300,870 870,1020 1020,1380 1590,1740
called {synchronize_rcu - -}.| In
|其实你可以放弃，你知道同步内部的<foreign language=“English”>RCU</foreign>放弃了这个中央处理器，

2270
01:08:56,810 --> 01:08:57,620
0,210 210,300 300,390 390,570 570,810
fact you can give up,

2271
01:08:57,650 --> 01:08:59,060
0,120 120,270 270,810 810,1290 1290,1410
you know internally {synchronize_rcu -

2272
01:08:59,060 --> 01:09:01,010
0,480 720,1110 1110,1230 1230,1320 1320,1950
-} gives up the CPU,|
|

2273
01:09:01,010 --> 01:09:02,360
0,180 180,240 240,450 480,780 780,1350
so you don't doesn't spend
所以你不一定要花。

2274
01:09:02,600 --> 01:09:04,820
0,900 1080,1830
necessarily {}.|
|

2275
01:09:05,410 --> 01:09:06,760
0,300 300,660 660,1020 1020,1290 1290,1350
But it may require a
但是等待每个其他核心进行上下文切换可能需要大量经过的时间。

2276
01:09:06,760 --> 01:09:08,320
0,150 150,210 210,720 720,1290 1290,1560
lot of elapsed time waiting

2277
01:09:08,320 --> 01:09:09,520
0,150 150,390 390,570 570,930 960,1200
for every other core to

2278
01:09:09,670 --> 01:09:11,080
0,480 480,960
context switch.|
|

2279
01:09:12,550 --> 01:09:13,930
0,390 480,930 930,1020 1020,1080 1080,1380
So depending on the mix
所以根据不同的原因写下

2280
01:09:13,930 --> 01:09:16,810
0,120 120,450 450,1200 1590,2190 2580,2880
of reason writes| {} and
|以及在读取临界区内正在做多少工作，

2281
01:09:16,810 --> 01:09:17,830
0,150 150,300 300,630 630,780 780,1020
how much work was being

2282
01:09:17,830 --> 01:09:19,960
0,600 960,1440 1440,1530 1530,1800 1800,2130
done inside the read critical

2283
01:09:19,960 --> 01:09:23,770
0,630 930,1830 2070,2610 2610,3420 3420,3810
section,| the performance increase varies
|性能提升大不相同，从速度快得多的

2284
01:09:23,770 --> 01:09:26,770
0,720 720,1290 2010,2400 2430,2790 2790,3000
tremendously from a much much

2285
01:09:26,770 --> 01:09:29,050
0,930 1080,1380 1380,1560 1560,1890 1890,2280
faster,| if these critical sections
|如果这些关键部分很短，写入也很少，

2286
01:09:29,050 --> 01:09:30,370
0,60 60,510 780,990 990,1140 1140,1320
were short and there's few

2287
01:09:30,370 --> 01:09:33,040
0,570 570,1110 1170,1770 1770,1980 1980,2670
writes too,| perhaps even slower,
|如果写入非常普遍，可能会更慢。

2288
01:09:34,240 --> 01:09:35,470
0,270 270,570 570,630 630,870 870,1230
if writes are very common.|
|

2289
01:09:37,590 --> 01:09:38,700
0,150 150,300 300,540 540,810 810,1110
And so when people apply
因此，当人们将RCU应用于内核时，

2290
01:09:38,700 --> 01:09:41,220
0,150 150,1260 1440,1710 1710,1980 1980,2520
{RCU,to -} kernel stuff,| actually
|实际上，您绝对需要针对大量工作负载进行性能测试

2291
01:09:42,090 --> 01:09:43,800
0,330 330,780 780,1050 1050,1350 1530,1710
you absolutely have to do

2292
01:09:43,800 --> 01:09:45,720
0,480 480,1140 1230,1710 1710,1740 1740,1920
performance tests against a bunch

2293
01:09:45,720 --> 01:09:46,500
0,60 60,480 480,540 540,720 720,780
of workloads| in order to
|为了弄清楚使用RCU对你来说是不是一场胜利，

2294
01:09:46,500 --> 01:09:48,360
0,300 300,480 480,1020 1380,1740 1740,1860
figure out whether using {RCU

2295
01:09:48,360 --> 01:09:49,260
0,300 300,420 420,480 480,690 690,900
-} is a win for

2296
01:09:49,260 --> 01:09:50,680
0,210 330,900
you,| because,
|因为，所以取决于工作量。

2297
01:09:50,710 --> 01:09:52,060
0,300 300,690 690,780 780,840 840,1350
so depending on the workload.|
|

2298
01:09:55,420 --> 01:09:56,890
0,360 360,480 480,690 690,1110 1170,1470
{} I have a maybe
我有一个也许是离题的问题，

2299
01:09:56,890 --> 01:10:00,020
0,60 60,690 690,1380 1470,2190
a tangential question,| but
|但我们已经看到了这一点，我想当使用多个内核时，

2300
01:10:01,020 --> 01:10:02,130
0,240 240,510 510,660 660,750 750,1110
we've seen that, I guess

2301
01:10:02,130 --> 01:10:03,840
0,240 240,540 540,1050 1050,1440 1440,1710
when there's multiple cores being

2302
01:10:03,840 --> 01:10:06,330
0,390 390,900 930,1260 1260,1650 1650,2490
used,| there's some added complexity
|在我们通常的实现中增加了一些复杂性

2303
01:10:06,330 --> 01:10:09,450
0,240 240,600 990,1710 1710,2730 2970,3120
to our usual implementations| and
|通常是这些原子指令在某种程度上起到了拯救作用

2304
01:10:09,450 --> 01:10:11,610
0,120 120,570 570,1020 1050,1410 1410,2160
it's often the these atomic

2305
01:10:11,610 --> 01:10:13,890
0,1110 1470,1680 1680,1770 1770,2100 2100,2280
instructions kind of come to

2306
01:10:13,890 --> 01:10:16,020
0,150 150,870 1260,1620 1620,1770 1770,2130
the rescue| and that's assuming
|这是假设有一个共享的存储系统，

2307
01:10:16,020 --> 01:10:18,060
0,210 210,630 630,1110 1110,1470 1470,2040
there's one shared memory system,|
|

2308
01:10:18,210 --> 01:10:20,700
0,330 330,390 390,1260 1500,1890 2310,2490
but I wonder like what
但我想知道，如果一台机器试图维护多个RAM系统，会发生什么情况，

2309
01:10:20,700 --> 01:10:22,230
0,360 360,540 540,1140 1140,1440 1440,1530
happens if a machine is

2310
01:10:22,230 --> 01:10:24,840
0,300 300,420 420,1020 1020,1260 1260,2610
trying to maintain like multiple

2311
01:10:25,080 --> 01:10:26,880
0,600 600,1200 1200,1380 1380,1530 1530,1800
RAM systems,| how does it
|它是如何将这些统一起来的。

2312
01:10:27,180 --> 01:10:28,740
0,540 540,1230
unify those.|
|

2313
01:10:30,920 --> 01:10:34,320
0,810 1530,1800 1800,2850
{} The ordinary,|
平凡的，|

2314
01:10:34,450 --> 01:10:36,280
0,990

2315
01:10:36,610 --> 01:10:38,020
0,360
well,
嗯，在我们所说的水平上，在一个，在一个水平上，

2316
01:10:40,460 --> 01:10:42,470
0,210 210,390 390,660 660,1470 1710,2010
at a, at a at

2317
01:10:42,470 --> 01:10:43,760
0,90 90,330 330,450 450,840 840,1290
the level we're talking about,|
|

2318
01:10:43,790 --> 01:10:44,930
0,210 210,540 540,630 630,870 870,1140
the machine has one RAM
这台机器有一个RAM系统。

2319
01:10:44,930 --> 01:10:46,820
0,480
system.|
|

2320
01:10:47,160 --> 01:10:49,230
0,450 450,750 1110,1440 1440,1590 1590,2070
Okay, that's a you know,|
好的，这是你知道的，|

2321
01:10:50,010 --> 01:10:51,160
0,540

2322
01:10:51,190 --> 01:10:54,010
0,420 420,1650 1650,2130 2220,2640 2640,2820
yeah, it's, {} {for,all,those} sort
是的，对于所有那些普通的电脑来说，

2323
01:10:54,010 --> 01:10:55,030
0,60 60,420 420,840 840,930 930,1020
of ordinary computers,| you would
|你会买多个内核，

2324
01:10:55,030 --> 01:10:57,640
0,210 210,480 480,1170 1200,2010 2250,2610
buy that multiple cores,| you
|您几乎可以编写程序，就好像所有内核之间只共享一个RAM系统一样，

2325
01:10:57,640 --> 01:10:59,680
0,390 570,1050 1050,1260 1260,1860 1860,2040
can pretty much program as

2326
01:10:59,680 --> 01:11:00,340
0,90 90,210 210,300 300,450 450,660
if there were just one

2327
01:11:00,340 --> 01:11:01,930
0,240 240,840 840,1230 1230,1470 1470,1590
RAM system shared among all

2328
01:11:01,930 --> 01:11:03,610
0,90 90,660 660,840 840,1080 1110,1680
the cores,| that's the logical
|这就是逻辑模型，硬件提供给你，

2329
01:11:03,610 --> 01:11:05,350
0,420 420,510 570,1110 1110,1590 1590,1740
model, the hardware provides you,|
|

2330
01:11:05,650 --> 01:11:07,240
0,360 450,900 900,1230 1230,1380 1380,1590
at physical levels not like
在身体层面上，并不经常是这样的。

2331
01:11:07,240 --> 01:11:09,100
0,240 780,1440
that often.|
|

2332
01:11:09,250 --> 01:11:10,810
0,480 630,900 900,1110 1110,1170 1170,1560
{} There's plenty of machines
有很多机器都有这种物理布局，

2333
01:11:10,810 --> 01:11:12,370
0,150 150,390 390,570 570,1140 1170,1560
out there that have this

2334
01:11:12,370 --> 01:11:14,740
0,720 720,1440 1500,1770 1770,2010 2160,2370
physical arrangement,| we have a
|我们有一个CPU芯片，

2335
01:11:14,740 --> 01:11:16,640
0,690 690,1350
CPU chip,|
|

2336
01:11:16,640 --> 01:11:18,080
0,120 120,300 300,570 570,1050 1050,1440
so here's one CPU chip
这是一个CPU芯片，可能上面有很多内核，对吧。

2337
01:11:18,080 --> 01:11:19,480
0,270 270,1320
maybe with

2338
01:11:19,850 --> 01:11:20,960
0,300 300,390 390,750 750,930 930,1110
lots of cores on it

2339
01:11:21,200 --> 01:11:22,440
0,660
right.|
|

2340
01:11:22,440 --> 01:11:24,270
0,450 660,930 930,1200 1200,1440 1470,1830
And {} you get CPU
你得到的CPU芯片，现在我不知道有多少核，比如说32个核，

2341
01:11:24,270 --> 01:11:24,960
0,300 300,480 480,540 540,630 630,690
chips with I don't know

2342
01:11:24,960 --> 01:11:25,950
0,120 120,300 300,570 570,720 720,990
how many cores these days,

2343
01:11:25,950 --> 01:11:27,240
0,420 420,840 840,1050 1050,1200 1200,1290
{say,32} cores,| let's say you
|假设您想要构建一台64核计算机，

2344
01:11:27,240 --> 01:11:28,170
0,120 120,180 180,390 390,420 420,930
want to build a 64

2345
01:11:28,170 --> 01:11:29,100
0,210 210,600 600,690 690,780 780,930
core machine,| you can only
|你只能买32个核心芯片，

2346
01:11:29,100 --> 01:11:31,470
0,180 180,870 1050,1320 1320,1830 1980,2370
buy 32 core chips,| well
|你可以做一块有两个芯片插座的电路板，

2347
01:11:31,470 --> 01:11:33,090
0,120 120,360 600,780 780,840 840,1620
you can make a board

2348
01:11:33,540 --> 01:11:34,860
0,240 240,450 450,630 630,1200 1200,1320
that has two sockets for

2349
01:11:34,860 --> 01:11:35,580
0,300 300,450 450,510 510,630 630,720
chips on it,| so now
|所以现在我们有两个芯片，

2350
01:11:35,580 --> 01:11:37,100
0,90 90,180 180,390 390,1110
we have two chips,|
|

2351
01:11:37,830 --> 01:11:39,390
0,510 720,930 930,1320 1320,1470 1470,1560
{} the fastest way to
获得存储器的最快方式是使存储器或多或少尽可能直接连接到CPU芯片，

2352
01:11:39,390 --> 01:11:40,650
0,150 150,300 300,870 960,1170 1170,1260
get at memory is to

2353
01:11:40,650 --> 01:11:41,640
0,180 180,270 270,600 600,930 930,990
have the memory more or

2354
01:11:41,640 --> 01:11:43,290
0,270 270,420 420,930 930,1560 1560,1650
less as directly attached to

2355
01:11:43,290 --> 01:11:44,940
0,90 90,510 510,780 780,1020 1020,1650
the CPU chip as possible,|
|

2356
01:11:45,120 --> 01:11:45,810
0,210 210,360 360,450 450,540 540,690
so what you would do
所以你要做的就是在这里放一组非常粗的电线，

2357
01:11:45,810 --> 01:11:47,220
0,150 150,240 240,420 420,720 1200,1410
is you'd have like a

2358
01:11:47,220 --> 01:11:49,350
0,270 270,1050 1200,1530 1530,1590 1590,2130
very fat set of wires

2359
01:11:49,350 --> 01:11:50,420
0,570
here,|
|

2360
01:11:50,420 --> 01:11:51,380
0,240 240,480 480,750 750,810 810,960
to write next to the
在芯片旁边写一堆RAM。

2361
01:11:51,380 --> 01:11:52,500
0,540
chip

2362
01:11:52,590 --> 01:11:54,420
0,270 270,570 570,660 660,1290
a bunch of RAM.|
|

2363
01:11:55,320 --> 01:11:56,610
0,210 210,300 300,600 600,960 960,1290
So it has direct access
所以它可以直接访问，当然这个芯片也需要自己的RAM，对吧。

2364
01:11:56,610 --> 01:11:57,450
0,90 90,150 150,330 330,510 510,840
and of course this chip's

2365
01:11:57,450 --> 01:11:58,080
0,120 120,180 180,330 330,480 480,630
going to want its own

2366
01:11:58,080 --> 01:11:59,520
0,360 360,870
RAM also,

2367
01:11:59,580 --> 01:12:01,440
0,450 540,960 1110,1350 1350,1710 1710,1860
right.| So so this is,
|所以这就是，我只是画了一幅

2368
01:12:01,440 --> 01:12:02,160
0,120 120,270 270,480 480,540 540,720
I'm just drawing a picture

2369
01:12:02,160 --> 01:12:02,790
0,60 60,180 180,270 270,360 360,630
of| what you would see
|如果你打开一台在RAM中有两个处理器芯片的PC，你会看到什么？

2370
01:12:02,790 --> 01:12:03,720
0,90 90,210 210,450 450,630 630,930
if you opened up a

2371
01:12:03,750 --> 01:12:05,300
0,720 720,1020
PC with

2372
01:12:05,300 --> 01:12:07,310
0,120 120,570 570,870 870,1080 1230,2010
two processor chips in RAM.|
|

2373
01:12:09,280 --> 01:12:10,480
0,600

2374
01:12:10,570 --> 01:12:11,560
0,270 270,510 510,660 660,900 900,990
But now we're faced with
但现在我们面临一个问题，

2375
01:12:11,560 --> 01:12:12,460
0,30 30,270 270,450 450,780 780,900
a problem,| what happens if
|如果这个芯片上的一个软件，

2376
01:12:12,460 --> 01:12:13,870
0,390 420,900 900,1110 1110,1200 1200,1410
a software over on this

2377
01:12:13,870 --> 01:12:15,610
0,540 570,960 960,1020 1020,1320 1320,1740
chip,| uses a memory location
|使用实际存储在此RAM中的内存位置。

2378
01:12:15,610 --> 01:12:16,690
0,150 150,450 450,810 810,900 900,1080
it's actually stored in this

2379
01:12:16,690 --> 01:12:18,700
0,480 1200,1530 1530,1590 1590,1860 1860,2010
RAM.| So in fact there's
|因此，实际上这两个芯片之间也存在互连，

2380
01:12:18,700 --> 01:12:21,440
0,330 330,1020 1110,2190
also a interconnect

2381
01:12:21,560 --> 01:12:23,750
0,390 390,570 570,750 750,1590 1800,2190
between these two chips {},|
|

2382
01:12:23,780 --> 01:12:25,940
0,420 420,510 510,1080 1080,1470 1470,2160
generally an extremely fast interconnect,
通常是极快的互连，例如每秒千兆字节，

2383
01:12:25,940 --> 01:12:29,030
0,300 630,1530 1530,1620 1620,2100 2430,3090
like gigabytes per second {},|
|

2384
01:12:29,180 --> 01:12:30,170
0,270 270,360 360,630 630,690 690,990
and the chips are smart
而且芯片足够智能，可以知道某些物理内存位置在这组RAM中

2385
01:12:30,170 --> 01:12:31,040
0,210 210,300 300,420 420,570 570,870
enough to know that certain

2386
01:12:31,040 --> 01:12:32,390
0,360 360,630 630,1170 1170,1260 1260,1350
physical memory locations are in

2387
01:12:32,390 --> 01:12:33,830
0,210 210,510 510,600 600,1140 1230,1440
this bank of RAM| and
|和其他物理位置，物理存储器地址在这里的这一组软件RAM中，

2388
01:12:33,830 --> 01:12:35,810
0,270 270,600 600,1350 1350,1680 1680,1980
other physical locations, physical memory

2389
01:12:35,810 --> 01:12:36,770
0,390 390,480 480,540 540,720 720,960
addresses are in this bank

2390
01:12:36,770 --> 01:12:38,210
0,90 90,390 390,540 540,900 900,1440
of RAM of software here,|
|

2391
01:12:38,600 --> 01:12:40,970
0,780 1080,1530 1530,1680 1680,2010 2010,2370
{} uses a physical address
使用物理地址在此之上的芯片聪明到基本上可以发送消息的小网络，

2392
01:12:40,970 --> 01:12:41,810
0,120 120,330 330,510 510,690 690,840
is over this one the

2393
01:12:41,900 --> 01:12:42,950
0,300 300,420 420,750 750,960 960,1050
chip is clever enough to

2394
01:12:42,950 --> 01:12:44,600
0,270 270,330 330,1110 1110,1440 1440,1650
send a message basically little

2395
01:12:44,600 --> 01:12:46,400
0,630 750,1020 1020,1110 1110,1620 1620,1800
network,| send a message over
|通过这个芯片发送消息，看，我需要读取一些RAM，请这样做，

2396
01:12:46,400 --> 01:12:47,660
0,240 240,780 780,1020 1020,1080 1080,1260
this chip, look I need

2397
01:12:47,660 --> 01:12:48,710
0,120 120,300 300,450 450,780 780,1050
to read some RAM, please

2398
01:12:48,710 --> 01:12:50,180
0,180 180,450 780,1140 1140,1320 1320,1470
do it,| go read its
|去读取它的RAM并将结果发回。

2399
01:12:50,180 --> 01:12:51,020
0,210 210,300 300,480 480,540 540,840
RAM and send the result

2400
01:12:51,020 --> 01:12:51,700
0,360
back.|
|

2401
01:12:52,010 --> 01:12:53,300
0,360 360,450 450,600 600,960 960,1290
You can buy four chip
像这样复杂的互连，你可以用同样的东西买到四个芯片排列，

2402
01:12:53,300 --> 01:12:54,710
0,630 630,750 750,840 840,1080 1080,1410
arrangements with the same thing

2403
01:12:54,710 --> 01:12:56,780
0,180 180,390 600,1410 1410,1920 1920,2070
with a complex interconnect like

2404
01:12:56,780 --> 01:12:58,760
0,450 750,1050 1050,1110 1110,1650 1650,1980
this,| there's a huge amount
|为了映射简单的共享RAM模型，需要进行大量的工程

2405
01:12:58,760 --> 01:13:00,590
0,210 510,1140 1140,1440 1440,1710 1710,1830
of engineering going on in

2406
01:13:00,590 --> 01:13:03,170
0,270 270,660 990,1590 1590,1740 1740,2580
order to map the straightforward

2407
01:13:03,170 --> 01:13:05,210
0,450 450,750 750,1320 1500,1860 1860,2040
shared RAM model| onto what
|在现实生活中建立什么样的高性能是可行的

2408
01:13:05,210 --> 01:13:06,200
0,150 150,210 210,690 690,780 780,990
sort of feasible to build

2409
01:13:06,200 --> 01:13:08,720
0,120 120,300 300,1320 2160,2370 2370,2520
with high performance in real

2410
01:13:08,720 --> 01:13:10,260
0,300 300,420 420,780 780,1080
life| and fit in
|并适合于二维或三维空间，

2411
01:13:10,350 --> 01:13:13,260
0,240 240,330 330,510 510,1200
two or three dimensions,|
|

2412
01:13:15,010 --> 01:13:16,330
0,120 120,330 330,420 420,750 750,1320
to answer your question.| Yeah,
来回答你的问题。|是啊，是啊，这提供了很多背景信息，谢谢。

2413
01:13:16,570 --> 01:13:18,040
0,480 480,660 660,1260 1260,1350 1350,1470
yeah, that provides a lot

2414
01:13:18,040 --> 01:13:19,860
0,90 90,570 570,810 810,1110
of context, thank you.|
|

2415
01:13:21,860 --> 01:13:23,060
0,570
Okay.|
好吧。|

2416
01:13:26,350 --> 01:13:28,160
0,30 60,1230

2417
01:13:32,210 --> 01:13:33,650
0,390 390,900 900,1260 1260,1380 1380,1440
Yeah, any questions on the
是啊，对实际技术有什么问题吗？

2418
01:13:33,650 --> 01:13:36,060
0,300 300,1050 1140,1830
actual technique {}?|
|

2419
01:13:40,010 --> 01:13:41,300
0,330 330,660
Alright so,
好的，那么，我相信你已经意识到RCU并不是普遍适用的，

2420
01:13:41,940 --> 01:13:43,620
0,720 750,1020 1020,1410 1410,1590 1590,1680
{} as, I'm sure you've

2421
01:13:43,620 --> 01:13:45,270
0,150 150,210 210,720 1110,1470 1470,1650
got the sense of {RCU

2422
01:13:45,270 --> 01:13:47,340
0,300 300,390 390,780 810,1470 1470,2070
-} is not universally applicable,|
|

2423
01:13:47,550 --> 01:13:48,690
0,210 210,480 480,600 600,780 780,1140
there's not, you can't just
没有，你不能把每一种使用自旋锁并获得糟糕并行性能的情况

2424
01:13:48,840 --> 01:13:50,250
0,480 480,660 660,1170 1170,1230 1230,1410
take every situation in which

2425
01:13:50,250 --> 01:13:51,540
0,270 270,570 570,900 900,990 990,1290
using spin locks and getting

2426
01:13:51,540 --> 01:13:53,610
0,480 480,930 930,1620 1620,1770 1770,2070
bad parallel performance| and convert
|并将其转换为RCU并获得更好的性能，

2427
01:13:53,610 --> 01:13:54,720
0,90 90,180 180,330 330,810 810,1110
it to {RCU -} and

2428
01:13:54,720 --> 01:13:56,740
0,210 210,420 420,1080 1140,1560
get better performance,| because,
|因为，它完全无助于写作的主要原因是速度变慢了。

2429
01:13:56,930 --> 01:13:58,220
0,210 210,510 510,750 750,900 900,1290
the main reason it completely

2430
01:13:58,220 --> 01:13:59,750
0,240 240,450 450,990 1140,1440 1440,1530
doesn't help writes makes them

2431
01:13:59,750 --> 01:14:02,420
0,540 840,1500 1500,1740 1740,2010 2280,2670
slower.| {You,know} really only helps
|您知道，只有在读取数量大大超过写入数量的情况下，才能真正提高性能。

2432
01:14:02,420 --> 01:14:04,280
0,510 510,840 1110,1320 1320,1410 1410,1860
performance, if if the reads

2433
01:14:04,280 --> 01:14:06,500
0,390 390,480 480,990 990,1740
outnumber the writes considerably.|
|

2434
01:14:07,920 --> 01:14:09,570
0,570 570,840 840,1080 1080,1560 1560,1650
It has this restriction that
它有这样的限制，即您不能在休眠期间持有指针来保护数据，

2435
01:14:09,570 --> 01:14:11,520
0,120 120,330 330,1020 1020,1620 1620,1950
you can't hold pointers to

2436
01:14:11,550 --> 01:14:13,110
0,360 360,450 450,660 660,1020 1020,1560
protect the data across sleep,|
|

2437
01:14:13,110 --> 01:14:14,430
0,240 240,630 660,930 930,1110 1110,1320
which just makes some kind
这只会让某种代码变得相当笨拙，

2438
01:14:14,430 --> 01:14:16,050
0,60 60,330 330,660 660,1170 1410,1620
of code quite awkward,| if
|如果你真的需要睡觉，那么你可能需要重新查找它是什么。

2439
01:14:16,050 --> 01:14:17,160
0,120 120,330 330,540 540,630 630,1110
you actually need to sleep,

2440
01:14:17,370 --> 01:14:18,420
0,330 330,510 510,720 720,900 900,1050
you may then need to

2441
01:14:18,420 --> 01:14:19,680
0,240 240,540 540,870 870,1200 1200,1260
{re-lookup - -} whatever it

2442
01:14:19,680 --> 01:14:20,860
0,780
is.|
|

2443
01:14:20,920 --> 01:14:21,700
0,150 150,450 450,540 540,660 660,780
So you know to do
所以你知道在睡眠结束后再做一次RCU临界区，

2444
01:14:21,700 --> 01:14:23,200
0,390 390,540 540,780 780,1140 1140,1500
another {RCU -} critical section

2445
01:14:23,200 --> 01:14:25,180
0,240 240,330 330,630 630,1320 1440,1980
after the sleep completes,| {in,order}
|为了再找，找您原来看的这个数据，

2446
01:14:25,180 --> 01:14:27,340
0,120 120,330 330,960 960,1500 1800,2160
to look again for, {}

2447
01:14:28,110 --> 01:14:28,980
0,270 270,360 360,600 600,720 720,870
for the data that you

2448
01:14:28,980 --> 01:14:30,630
0,480 480,600 600,870 870,1290 1320,1650
originally were looking at,| assuming
|假设它还存在，

2449
01:14:30,630 --> 01:14:32,190
0,90 90,330 330,510 510,1200 1410,1560
it's still even exists,| so
|所以这只会让代码变得更复杂。

2450
01:14:32,190 --> 01:14:32,940
0,90 90,270 270,420 420,720 720,750
it just makes code a

2451
01:14:32,940 --> 01:14:35,800
0,150 150,270 270,990
bit more complicated.|
|

2452
01:14:36,090 --> 01:14:38,430
0,300 300,600 600,1230 1230,1590 2010,2340
The data structures, the most
数据结构，应用它的最直接方式是

2453
01:14:38,430 --> 01:14:39,600
0,450 450,570 570,660 660,1020 1020,1170
straightforward way to apply it

2454
01:14:39,600 --> 01:14:41,010
0,180 180,330 330,600 600,1170 1170,1410
is| the data structures that
|数据结构具有服从于用于更新的单次提交写入的结构，

2455
01:14:41,580 --> 01:14:43,770
0,240 240,330 330,1230 1230,1650 1650,2190
have a structure that's amenable

2456
01:14:43,770 --> 01:14:45,390
0,120 120,540 540,990 990,1440 1440,1620
to single committing writes for

2457
01:14:45,390 --> 01:14:47,460
0,870 930,1290 1290,1470 1470,1830 1830,2070
updates,| you can't modify things
|你不能在原地修改东西，所以你必须更换东西，

2458
01:14:47,460 --> 01:14:48,240
0,90 90,420 420,540 540,630 630,780
in place, so you have

2459
01:14:48,240 --> 01:14:51,960
0,240 480,1080 1080,1650 1890,2730 3480,3720
to replace stuff,| {} so
|所以您知道列表和树，但不知道更复杂数据结构，

2460
01:14:51,960 --> 01:14:53,910
0,600 600,750 750,1140 1140,1680 1680,1950
you know {list,and} trees, but

2461
01:14:54,240 --> 01:14:56,160
0,510 510,660 660,1140 1140,1380 1380,1920
not more complex data structures,|
|

2462
01:14:56,160 --> 01:14:58,020
0,150 150,540 540,930 930,1410
the paper mentioned some
论文提到了一些更复杂的方式，比如顺序锁，

2463
01:14:58,840 --> 01:15:00,220
0,210 210,420 420,1020 1020,1230 1230,1380
{} more complicated ways like

2464
01:15:00,220 --> 01:15:02,110
0,390 390,990 1230,1560 1560,1680 1680,1890
sequence locks,| to be able
|为了能够在适当的位置更新东西，

2465
01:15:02,110 --> 01:15:04,210
0,450 720,1290 1410,1770 1770,2010 2010,2100
to {} update stuff in

2466
01:15:04,210 --> 01:15:07,030
0,660 750,1680 2070,2520 2520,2640 2640,2820
place,| despite readers that aren't
|尽管读者没有使用锁，

2467
01:15:07,030 --> 01:15:08,200
0,270 270,780 780,960 960,1020 1020,1170
using locks,| but they are
|但它们正变得越来越复杂，它们实际提高性能的情况受到更多限制。

2468
01:15:08,200 --> 01:15:10,240
0,270 270,390 390,1080 1080,1530 1770,2040
getting more complicated and the

2469
01:15:10,240 --> 01:15:12,160
0,690 690,840 840,1050 1050,1380
situations under which they

2470
01:15:12,250 --> 01:15:13,990
0,510 510,780 780,1320 1320,1440 1440,1740
actually improve performance are more

2471
01:15:13,990 --> 01:15:18,900
0,720 1440,1920 2730,3390 3570,4320
restricted.| {} Another subtle
|另一个微妙的问题是读者可以看到陈旧的数据，

2472
01:15:19,360 --> 01:15:20,470
0,420 420,540 540,720 720,1020 1020,1110
problem is that readers can

2473
01:15:20,470 --> 01:15:22,900
0,210 210,690 690,1320
see stale data,|
|

2474
01:15:22,930 --> 01:15:25,750
0,750 1170,1710 1710,1920 1920,2370 2370,2820
{} without any obvious bound
对于他们可以查看销售数据的时间没有任何明显的限制，

2475
01:15:25,750 --> 01:15:26,740
0,180 180,420 420,750 750,870 870,990
on how long they can

2476
01:15:26,740 --> 01:15:28,300
0,210 210,630 630,960 960,1290 1290,1560
see sale data for,| because
|因为如果某个读取器获得指向RCU保护对象的指针，

2477
01:15:28,300 --> 01:15:30,460
0,90 90,390 390,1050 1500,2100 2100,2160
if some reader gets a

2478
01:15:30,460 --> 01:15:31,840
0,570 570,810 810,960 960,1140 1140,1380
pointer to a {RCU -}

2479
01:15:31,840 --> 01:15:34,330
0,450 450,1080 1590,1890 1890,2100 2100,2490
protected object,| {} just before
|就在作家替换它之前，

2480
01:15:34,330 --> 01:15:35,640
0,120 120,810
a writer

2481
01:15:35,640 --> 01:15:37,160
0,660 660,990
replaces it,|
|

2482
01:15:37,570 --> 01:15:39,160
0,300 300,450 450,720 720,1350 1350,1590
{} the reader may still
读者可能会在相当长的一段时间内仍然持有该数据，

2483
01:15:39,160 --> 01:15:41,020
0,270 270,480 480,690 690,1530 1560,1860
hold {on,to} that data for

2484
01:15:41,020 --> 01:15:41,800
0,210 210,270 270,420 420,720 720,780
quite a long time,| at
|至少在现代计算机指令的规模上，

2485
01:15:41,800 --> 01:15:43,090
0,180 180,270 270,330 330,900 900,1290
least on the scale of

2486
01:15:43,450 --> 01:15:47,350
0,780 780,1140 1140,1980 2400,2910 3450,3900
modern computer instructions,| {} and
|很多时候，这被证明是无关紧要的，

2487
01:15:47,350 --> 01:15:48,370
0,180 180,300 300,360 360,450 450,1020
a lot of the time,

2488
01:15:48,640 --> 01:15:49,420
0,180 180,390 390,540 540,720 720,780
this turns out not to

2489
01:15:49,420 --> 01:15:50,680
0,240 240,810
matter much,|
|

2490
01:15:51,000 --> 01:15:52,230
0,330 360,480 480,570 570,810 810,1230
{} but the paper mentioned
但是论文提到了一些我实际上不太理解的情况

2491
01:15:52,230 --> 01:15:53,760
0,300 300,900 900,1170 1170,1290 1290,1530
some situations which I actually

2492
01:15:53,760 --> 01:15:56,280
0,150 150,330 330,1050 1320,1740 1740,2520
don't really understand| in which
|在这种情况下，人们期望写入在写入完成后实际生效

2493
01:15:57,090 --> 01:16:00,270
0,420 420,1440 1920,2700 2700,2790 2790,3180
people expect writes to actually

2494
01:16:00,270 --> 01:16:02,250
0,240 240,870 1170,1620 1620,1710 1710,1980
take effect after the write

2495
01:16:02,250 --> 01:16:05,160
0,750 870,1350 1350,1620 1620,2280 2310,2910
completes| and therefore, which readers
|因此，读者看到哪些陈旧的数据有点令人惊讶。

2496
01:16:05,160 --> 01:16:06,420
0,360 360,660 660,900 900,1140 1140,1260
see stale data is a

2497
01:16:06,420 --> 01:16:08,180
0,150 150,210 210,270 270,1050
bit of a surprise.|
|

2498
01:16:13,290 --> 01:16:15,220
0,930

2499
01:16:15,820 --> 01:16:17,110
0,240 240,390 390,870 870,1050 1050,1290
You may also, as a
作为一个单独的主题，您可能还会想知道如果写入大量数据会发生什么情况，

2500
01:16:17,170 --> 01:16:19,480
0,510 510,990 990,1350 1350,1950 1950,2310
separate topic wonder what happens

2501
01:16:19,480 --> 01:16:20,920
0,120 120,270 270,870 900,1140 1140,1440
if you have write heavy

2502
01:16:20,920 --> 01:16:22,060
0,330 390,660 660,900 900,990 990,1140
data,| like RCU is all
|就像RCU完全是关于读取大量数据一样，

2503
01:16:22,060 --> 01:16:23,020
0,210 210,360 360,600 600,840 840,960
about {read,heavy -} data,| but
|但这只是您可能关心的许多情况之一，忘记并行性能，

2504
01:16:23,020 --> 01:16:24,670
0,180 180,330 330,990 990,1110 1110,1650
that's just one of many

2505
01:16:24,670 --> 01:16:26,410
0,870 870,960 960,1140 1140,1380 1380,1740
situations you might care about,

2506
01:16:26,620 --> 01:16:30,100
0,570 570,1080 1110,1980 2220,2850 3150,3480
forgetting parallel performance,| they also
|他们还关心写入大量数据。

2507
01:16:30,100 --> 01:16:31,330
0,150 150,420 420,600 600,810 810,1230
care about write heavy data.|
|

2508
01:16:31,870 --> 01:16:33,460
0,420 420,510 510,990
Actually, in the
实际上，在极端情况下，在一些写入大量数据的极端情况下，

2509
01:16:33,460 --> 01:16:35,650
0,840 840,1020 1020,1380 1380,1830 1830,2190
extremes, in some extreme cases

2510
01:16:35,650 --> 01:16:36,610
0,90 90,270 270,510 510,780 780,960
of write heavy data,| you
|你可以做得很好，

2511
01:16:36,610 --> 01:16:37,750
0,120 120,270 270,630 630,930 930,1140
can do quite well,| there's
|据我所知，没有一种技术可以写入大量数据，

2512
01:16:37,750 --> 01:16:39,880
0,420 1170,1620 1620,1680 1680,2010 2010,2130
no technique I know of

2513
01:16:39,880 --> 01:16:41,020
0,180 180,390 390,630 630,870 870,1140
for write heavy data,| that's
|这和RCU一样普遍适用，

2514
01:16:41,020 --> 01:16:43,390
0,600 600,1080 1110,1740 1740,2220 2220,2370
quite as universally applicable as

2515
01:16:43,390 --> 01:16:45,790
0,180 180,720 1230,1710 2010,2280 2280,2400
{RCU -},| {} but there
|但仍然有一些想法可以处理大部分是写入的数据。

2516
01:16:45,790 --> 01:16:47,710
0,90 90,420 420,1020 1020,1350 1410,1920
are still ideas for coping

2517
01:16:47,710 --> 01:16:49,600
0,510 600,1050 1050,1230 1230,1530 1530,1890
with data that's mostly written.|
|

2518
01:16:49,840 --> 01:16:51,190
0,180 180,330 330,750 750,1170 1170,1350
The most powerful idea is
最强大的想法是重组你的数据，

2519
01:16:51,190 --> 01:16:53,180
0,150 150,840 840,960 960,1440
to restructure your data,|
|

2520
01:16:53,210 --> 01:16:54,980
0,570 570,660 660,930 930,1500 1530,1770
restructure the data structure, so
重组数据结构，使其不共享

2521
01:16:54,980 --> 01:16:56,870
0,120 120,360 360,1020 1350,1470 1470,1890
it's not shared| and sometimes
|有时候你可以做到，有时候分享是完全无端的

2522
01:16:56,870 --> 01:16:57,740
0,90 90,180 180,300 300,480 480,870
you can do, that sometimes

2523
01:16:57,740 --> 01:16:59,030
0,90 90,450 450,570 570,750 750,1290
the sharing is just completely

2524
01:16:59,030 --> 01:17:01,280
0,960 1470,1620 1620,1740 1740,2010 2010,2250
gratuitous| and you can get
|一旦你意识到这是个问题，你就可以把它处理掉。

2525
01:17:01,280 --> 01:17:01,940
0,150 150,240 240,360 360,570 570,660
rid of it once you

2526
01:17:01,940 --> 01:17:03,540
0,420 420,540 540,600 600,1080
realize it's a problem.|
|

2527
01:17:03,930 --> 01:17:05,310
0,330 450,720 720,1020 1020,1320 1320,1380
But it's also often the
但通常情况也是如此，虽然有时确实需要共享数据，

2528
01:17:05,310 --> 01:17:06,960
0,330 330,540 540,780 930,1200 1230,1650
case, that the that while

2529
01:17:06,960 --> 01:17:08,220
0,120 120,270 270,990 990,1170 1170,1260
you do sometimes need to

2530
01:17:08,220 --> 01:17:10,290
0,240 240,690 690,1140 1350,1800 1950,2070
have shared data,| that the
|通常情况下不需要不同的内核写入相同的数据，

2531
01:17:10,290 --> 01:17:12,690
0,480 480,1140 1140,1470 1470,1860 1860,2400
common case doesn't require different

2532
01:17:12,690 --> 01:17:14,370
0,900 930,1050 1050,1290 1290,1350 1350,1680
cores to write the same

2533
01:17:14,370 --> 01:17:15,630
0,510 540,810 810,960 960,1080 1080,1260
data,| even though they need
|即使他们需要大量写入一些数据。

2534
01:17:15,630 --> 01:17:16,800
0,90 90,630
to write

2535
01:17:16,920 --> 01:17:17,700
0,300 300,360 360,420 420,660 660,780
some of the data a

2536
01:17:17,700 --> 01:17:19,080
0,390 390,660 660,840 840,1080 1080,1380
lot.| And you've actually seen
|你实际上已经在实验室里看到了这一点，

2537
01:17:19,080 --> 01:17:20,580
0,180 180,240 240,360 360,1020 1140,1500
that in the labs,| in
|在锁定实验室里，在实验室的卷心菜部分，

2538
01:17:20,580 --> 01:17:23,850
0,150 150,570 570,1170 1200,2130 3030,3270
the locking lab, {} in

2539
01:17:23,850 --> 01:17:25,470
0,240 270,690 690,840 840,1350 1380,1620
the {kalloc - -} part

2540
01:17:25,470 --> 01:17:27,150
0,60 60,180 180,630 660,930 930,1680
of the lab,| you restructured
|您重新构建了空闲列表，以便每个内核都有一个专用的空闲列表，

2541
01:17:27,150 --> 01:17:28,020
0,90 90,330 330,660 660,780 780,870
the free list so that

2542
01:17:28,020 --> 01:17:29,280
0,210 210,480 480,630 630,690 690,1260
each core has a dedicated

2543
01:17:29,280 --> 01:17:31,140
0,210 210,720 870,1170 1170,1680 1680,1860
free list,| thus converting a
|从而将写入繁重的数据结构空闲列表转换为每个核的半私有数据结构，

2544
01:17:31,140 --> 01:17:32,610
0,240 240,570 570,810 810,1350 1350,1470
write heavy data structure the

2545
01:17:32,610 --> 01:17:34,890
0,210 210,720 1260,1530 1530,2070 2070,2280
free list into one that

2546
01:17:34,890 --> 01:17:37,620
0,390 870,1410 1410,1920 1920,2460 2460,2730
was a semi private per

2547
01:17:37,620 --> 01:17:38,700
0,390 390,540 540,930 930,990 990,1080
core,| so most of the
|所以大多数时候核心只需要，

2548
01:17:38,700 --> 01:17:40,230
0,390 390,810 810,1020 1020,1200 1200,1530
times cores just have to,|
|

2549
01:17:40,910 --> 01:17:42,080
0,90 90,480 480,870 870,990 990,1170
they don't conflict with other
它们不会与其他内核冲突，

2550
01:17:42,080 --> 01:17:43,310
0,510 510,780 780,870 870,1020 1020,1230
cores,| because they have their
|因为他们有自己的私人免费名单

2551
01:17:43,310 --> 01:17:44,690
0,120 120,720 750,990 990,1290 1290,1380
own private free list| and
|你唯一需要查看其他免费列表的时间是，

2552
01:17:44,690 --> 01:17:45,590
0,90 90,390 390,720 720,780 780,900
the only time you have

2553
01:17:45,590 --> 01:17:46,220
0,90 90,210 210,270 270,420 420,630
to look at other free

2554
01:17:46,220 --> 01:17:47,630
0,330 330,660 870,1080 1080,1230 1230,1410
lists is,| if your free
|如果您的免费列表用完了。

2555
01:17:47,630 --> 01:17:49,040
0,270 270,510 510,720 1050,1290 1290,1410
list runs out.| There are
|实际上，在内核中处理大量写入数据的这种方法有很多示例。

2556
01:17:49,040 --> 01:17:50,900
0,210 210,630 630,1140 1140,1230 1230,1860
actually many examples of this

2557
01:17:50,930 --> 01:17:52,370
0,240 240,330 600,990 990,1200 1200,1440
way of dealing with write

2558
01:17:52,370 --> 01:17:53,380
0,540
heavy

2559
01:17:53,470 --> 01:17:55,700
0,480 870,1050 1050,1140 1140,1620
data in the kernel.|
|

2560
01:17:55,850 --> 01:17:57,380
0,210 210,450 450,630 630,1200 1200,1530
{} thinking the allocator Linux
考虑到分配器Linux是这样的，Linux正在调度列表。

2561
01:17:57,380 --> 01:17:58,820
0,90 90,300 300,660 720,1320 1320,1440
is like this, Linux is

2562
01:17:58,820 --> 01:18:02,160
0,810 810,1590 2070,2760
scheduling lists {}.|
|

2563
01:18:02,230 --> 01:18:04,000
0,420 420,720 720,1410 1410,1680 1680,1770
There's a separate set of
每个内核都有一组单独的线程

2564
01:18:04,000 --> 01:18:05,650
0,750 750,930 930,1140 1140,1530 1530,1650
threads for each core| that
|调度程序大部分时间都在查看

2565
01:18:05,650 --> 01:18:06,910
0,90 90,600 600,840 840,960 960,1260
the scheduler looks at most

2566
01:18:06,910 --> 01:18:08,140
0,60 60,120 120,570 690,930 930,1230
of the time| and cores
|并且内核只需查看彼此的调度列表，

2567
01:18:08,140 --> 01:18:09,850
0,240 240,450 450,720 1170,1620 1620,1710
only have to look at

2568
01:18:09,850 --> 01:18:11,440
0,150 150,1140
each others

2569
01:18:11,560 --> 01:18:12,910
0,210 210,690 690,1020 1020,1170 1170,1350
{} scheduling list,| they run
|他们没有工作可做了。

2570
01:18:12,910 --> 01:18:13,780
0,120 120,240 240,480 480,570 570,870
out of work to do.|
|

2571
01:18:14,370 --> 01:18:16,560
0,540 540,900 900,990 990,1680 1680,2190
Another example of statistics counters,
另一个统计计数器的例子是，如果你在计算什么

2572
01:18:16,560 --> 01:18:18,660
0,120 120,240 240,690 690,1260 1770,2100
if you're counting something| and
|计数变化很大，但很少有人看，

2573
01:18:18,660 --> 01:18:20,100
0,60 60,450 450,900 930,1380 1380,1440
the counts go change a

2574
01:18:20,100 --> 01:18:22,230
0,450 450,780 840,1080 1080,1530 1530,2130
lot, but they're rarely read,|
|

2575
01:18:22,590 --> 01:18:24,180
0,180 180,270 270,360 360,780 810,1590
that is the {counts,are} truly
即计数真正由写而不是读主导，

2576
01:18:24,330 --> 01:18:26,100
0,540 540,630 630,1020 1020,1260 1260,1770
dominated by writes not reads,|
|

2577
01:18:26,850 --> 01:18:28,080
0,300 300,480 480,600 600,1110 1110,1230
{} you can restructure your
您可以重组计数器，使每个内核都有单独的计数器，

2578
01:18:28,080 --> 01:18:29,820
0,390 390,570 570,690 720,1050 1050,1740
counter so that each core

2579
01:18:30,720 --> 01:18:32,220
0,300 300,360 360,960
has a separate

2580
01:18:32,420 --> 01:18:35,150
0,690 1110,1860 2250,2460 2460,2580 2580,2730
counter,| {} and so each
|因此，当每个内核需要更改计数时，只需修改它自己的计数器，

2581
01:18:35,150 --> 01:18:36,260
0,240 240,420 420,840 840,960 960,1110
core just modifies its own

2582
01:18:36,260 --> 01:18:37,520
0,300 300,480 480,570 570,810 810,1260
counter, when it needs to

2583
01:18:37,760 --> 01:18:39,260
0,390 390,450 450,960 1200,1440 1440,1500
change the count,| and if
|如果你想读点什么，

2584
01:18:39,260 --> 01:18:40,580
0,120 120,270 270,420 420,810 810,1320
you want to read something,|
|

2585
01:18:40,580 --> 01:18:41,960
0,660 690,960 960,1110 1110,1200 1200,1380
then you have to go
然后您必须出去锁定并读取每个内核的所有计数器，

2586
01:18:41,960 --> 01:18:43,340
0,270 270,420 420,840 840,1020 1020,1380
out and lock and read

2587
01:18:43,340 --> 01:18:45,230
0,240 240,360 360,810 810,960 960,1890
all the per core counters,|
|

2588
01:18:45,560 --> 01:18:46,580
0,180 180,330 330,390 390,870 870,1020
so that's a technique to
所以这是一种写得非常快的技术。

2589
01:18:46,580 --> 01:18:48,440
0,270 270,540 540,750 750,1470
make writes very fast.|
|

2590
01:18:48,440 --> 01:18:49,580
0,180 180,270 270,570 570,720 720,1140
Because the writers just modify
因为写入器只修改本地核心计数器，

2591
01:18:49,580 --> 01:18:51,980
0,180 180,600 600,1050 1050,1500 1890,2400
the local core counter {},|
|

2592
01:18:52,010 --> 01:18:52,700
0,120 120,210 210,450 450,510 510,690
but the reads are now
但现在的读数非常慢

2593
01:18:52,700 --> 01:18:54,620
0,240 240,780 1230,1590 1590,1830 1830,1920
very slow| and you know,
|而且你知道，但是如果你的计数器像通常那样写得很重。

2594
01:18:54,620 --> 01:18:56,480
0,270 510,720 720,1050 1290,1770 1770,1860
but if your counters are

2595
01:18:56,480 --> 01:18:58,370
0,210 210,570 570,780 780,1140 1140,1890
write heavy as {just,the} counters

2596
01:18:58,370 --> 01:18:59,500
0,270 270,630
often are.|
|

2597
01:18:59,500 --> 01:19:00,580
0,510 660,840 840,930 930,1020 1020,1080
{} That could be a
这可能是一个巨大的胜利，现在将工作转移到阅读器上。

2598
01:19:00,580 --> 01:19:01,870
0,210 210,570 630,1020 1020,1080 1080,1290
big win shifting the work

2599
01:19:01,870 --> 01:19:03,340
0,150 150,270 270,360 360,960
now to the reads.|
|

2600
01:19:04,760 --> 01:19:05,540
0,240 240,330 330,540 540,630 630,780
So the point is there
所以关键是有一些技巧，尽管我们没有谈论太多，

2601
01:19:05,540 --> 01:19:06,530
0,120 120,690 690,810 810,900 900,990
are techniques, even though we

2602
01:19:06,530 --> 01:19:07,400
0,150 150,360 360,570 570,660 660,870
didn't talk about that much,|
|

2603
01:19:07,400 --> 01:19:09,140
0,150 150,240 240,780 990,1200 1200,1740
there are also {} sometimes
有时也有一些技术可以帮助编写密集型工作负载。

2604
01:19:09,140 --> 01:19:10,600
0,510 510,600 600,1020
techniques that help

2605
01:19:10,660 --> 01:19:12,610
0,360 390,600 600,810 810,1230 1230,1950
{} for write intensive workloads.|
|

2606
01:19:15,200 --> 01:19:18,230
0,660 840,1200 1200,1560 1560,2160 2670,3030
{} {To,wrap} up the {RCU
要结束RCU，请执行以下操作

2607
01:19:18,230 --> 01:19:19,250
0,150 150,420 450,780 780,870 870,1020
-}| the stuff we read
|我们在报纸上读到的东西实际上是Linux的一个巨大的成功故事，

2608
01:19:19,250 --> 01:19:20,420
0,180 180,240 240,330 330,870 1020,1170
about in the paper is

2609
01:19:20,420 --> 01:19:21,950
0,210 210,300 300,720 720,1170 1170,1530
actually a giant success story

2610
01:19:21,950 --> 01:19:24,200
0,180 180,930 1470,1620 1620,1890 1920,2250
for Linux,| is used all
|在Linux上到处都用来获取各种不同的数据，

2611
01:19:24,200 --> 01:19:25,880
0,210 210,960 1140,1290 1290,1470 1470,1680
over Linux to get at

2612
01:19:26,060 --> 01:19:27,230
0,300 300,570 570,630 630,930 930,1170
all kinds of different data,|
|

2613
01:19:27,230 --> 01:19:28,640
0,210 210,300 300,540 540,990 990,1410
because it just turns out
因为事实证明，读取和读取大部分数据都是读取密集型数据，这是非常常见的，

2614
01:19:29,000 --> 01:19:29,500
0,300
that

2615
01:19:29,530 --> 01:19:31,630
0,390 390,690 840,1350 1350,1740 1740,2100
read and read mostly data

2616
01:19:31,630 --> 01:19:33,190
0,210 210,630 630,930 930,1110 1110,1560
read intensive data, it's extremely

2617
01:19:33,190 --> 01:19:36,040
0,330 330,1410 1470,2190 2190,2520 2520,2850
common,| like cached file blocks,
|例如，与高速缓存的文件块一样，大多是读取的，

2618
01:19:36,040 --> 01:19:37,330
0,90 90,450 450,480 480,810 810,1290
for example are mostly read,|
|

2619
01:19:38,530 --> 01:19:40,150
0,270 270,270 270,810 810,1020 1230,1620
so a technique that speeds
因此，一种只加快读取速度的技术是一种非常广泛的应用。

2620
01:19:40,150 --> 01:19:41,770
0,90 90,270 270,660 660,1140 1230,1620
up only reads is a

2621
01:19:42,010 --> 01:19:44,480
0,630 810,1110 1110,1440 1440,1950
really very widely applicable.|
|

2622
01:19:45,920 --> 01:19:48,320
0,330 330,600 600,1230 1230,1860 1980,2400
{And,RCU} is particularly magic,| there's
而RCU特别有魔力，|还有很多其他有趣的并发技术、同步技术、

2623
01:19:48,590 --> 01:19:51,290
0,330 330,390 390,930 1410,1980 2010,2700
lots of other interesting concurrency

2624
01:19:51,290 --> 01:19:53,930
0,690 1200,1410 1410,2070 2070,2520 2520,2640
techniques, {} synchronization techniques,| {RCU
|RCU是神奇的，因为它完全消除了对读取器的锁定和写入，

2625
01:19:53,930 --> 01:19:55,580
0,300 300,420 420,990 1170,1530 1530,1650
-} is magic because it

2626
01:19:55,580 --> 01:19:58,550
0,630 630,1620 1680,2340 2340,2490 2490,2970
completely eliminates locking and writing

2627
01:19:58,580 --> 01:20:00,080
0,120 120,240 240,930 1170,1380 1380,1500
for the readers,| so it's
|所以与读写锁相比，这是一个很大的突破，

2628
01:20:00,080 --> 01:20:01,560
0,180 180,390 390,960
just a big

2629
01:20:01,650 --> 01:20:03,300
0,690 690,1080 1080,1170 1170,1440 1440,1650
breakthrough compared to things like

2630
01:20:03,300 --> 01:20:04,560
0,180 180,450 450,840 840,990 990,1260
read write locks,| which were
|这些都是以前最先进的。

2631
01:20:05,130 --> 01:20:07,470
0,180 180,990 1770,2160 2160,2220 2220,2340
the previous state of the

2632
01:20:07,470 --> 01:20:09,810
0,360 810,1230 1650,1860 1860,2100 2100,2340
art.| And the key idea
|而真正让它发挥作用的关键思想是，

2633
01:20:09,810 --> 01:20:10,950
0,210 210,420 420,630 630,690 690,1140
that really makes it work

2634
01:20:11,220 --> 01:20:12,920
0,420 420,660 660,1080
is the {},|
|

2635
01:20:13,220 --> 01:20:14,960
0,210 210,300 300,720 720,1290 1290,1740
sort of garbage collection like
垃圾收集，比如推迟冻结他们所谓的宽限期，

2636
01:20:14,960 --> 01:20:17,660
0,930 1200,1410 1410,2040 2040,2340 2430,2700
deferring a freeze for what

2637
01:20:17,660 --> 01:20:19,010
0,120 120,300 300,390 390,810 810,1350
they call the grace period,|
|

2638
01:20:19,340 --> 01:20:20,510
0,270 270,450 450,570 570,1020 1020,1170
until all the readers are
在保证所有读取器都完成使用数据之前，

2639
01:20:20,540 --> 01:20:21,890
0,480 480,540 540,630 630,1080 1080,1350
guaranteed to be finished using

2640
01:20:22,160 --> 01:20:23,780
0,120 120,420 1050,1200 1200,1290 1290,1620
the data,| so you can
|所以你们可以像同步技术一样，

2641
01:20:24,050 --> 01:20:24,890
0,300 300,450 450,630 630,780 780,840
all as well as the

2642
01:20:24,890 --> 01:20:26,720
0,600 600,1080 1110,1320 1320,1560 1560,1830
synchronization technique,| it's actually fair
|实际上，把它看作是一个非常，

2643
01:20:26,720 --> 01:20:28,160
0,60 60,300 300,480 480,870 930,1440
to view it as a

2644
01:20:28,280 --> 01:20:29,510
0,420 420,690 690,930 930,1140 1140,1230
very much,| so as a
|所以作为一种专门的垃圾收集技术。

2645
01:20:29,510 --> 01:20:31,490
0,210 210,330 660,960 990,1680 1680,1980
kind of a specialized garbage

2646
01:20:31,490 --> 01:20:32,680
0,330 330,810
collection technique.|
|

2647
01:20:35,390 --> 01:20:36,170
0,210 210,480 480,600 600,720 720,780
And that is all I
我要说的就是这些，

2648
01:20:36,170 --> 01:20:38,150
0,90 90,210 210,690 720,1170 1650,1980
have to say,| so I'm
|所以我很乐意回答大家的问题。

2649
01:20:38,150 --> 01:20:40,020
0,270 270,330 330,540 540,1290
happy to take questions.|
|

2650
01:20:43,530 --> 01:20:45,300
0,270 270,600 600,750 750,870 870,1770
Oh, sorry, can you explain
哦，对不起，你能给读者解释一下陈旧的数据吗，

2651
01:20:45,570 --> 01:20:47,680
0,540 570,1590
the stale

2652
01:20:47,830 --> 01:20:49,810
0,420 420,630 630,1320 1620,1860 1860,1980
data for readers,| so I
|所以我不明白为什么会发生这种事，

2653
01:20:49,810 --> 01:20:52,600
0,150 150,960 1170,1890 2010,2460 2460,2790
don't understand why how that

2654
01:20:52,600 --> 01:20:54,970
0,150 150,510 510,1080 1410,1980 2130,2370
can happen,| because you you're
|因为你你在读你的关键章节，

2655
01:20:54,970 --> 01:20:58,180
0,330 330,900 1050,1920 1920,2760
reading your critical section,|
|

2656
01:20:58,300 --> 01:21:00,120
0,600 720,1290
and, {}
而且，你只需要得到当时的任何数据，

2657
01:21:00,240 --> 01:21:01,800
0,240 240,480 480,660 660,1290 1320,1560
you just get whatever data

2658
01:21:01,800 --> 01:21:03,330
0,180 180,690 690,750 750,930 930,1530
is there at that point,|
|

2659
01:21:04,130 --> 01:21:05,460
0,120 120,240 240,360 360,870
and then you just.|
然后你就会。|

2660
01:21:06,000 --> 01:21:10,080
0,540 2970,3420 3420,3810 3810,3900 3900,4080
{} {It,actually} usually is not
实际上这通常不是问题，

2661
01:21:10,080 --> 01:21:12,840
0,60 60,450 1200,1890 2010,2400 2400,2760
a problem,| but the {}
|但是为什么会出现这样的情况呢？通常情况下，你知道如果你有代码说x等于1，

2662
01:21:13,080 --> 01:21:14,700
0,480 480,630 630,870 870,1380 1380,1620
reason why ever might come

2663
01:21:14,700 --> 01:21:17,660
0,420 1080,1380 1470,2430
up, well ordinarily,

2664
01:21:18,380 --> 01:21:19,160
0,300 300,420 420,540 540,660 660,780
you know if you have

2665
01:21:19,160 --> 01:21:21,650
0,660 660,1200 1560,1920 1920,2190 2190,2490
code that says x equals

2666
01:21:21,650 --> 01:21:22,920
0,660
one,|
|

2667
01:21:22,980 --> 01:21:25,470
0,300 300,480 480,1050 1410,1650 1650,2490
and then you know print
然后你就知道打印完成了，

2668
01:21:26,880 --> 01:21:28,200
0,660
done,|
|

2669
01:21:29,130 --> 01:21:31,440
0,390 390,570 570,960 960,1920 1950,2310
gosh, it's pretty surprising, if
天哪，如果在这一点之后，有人阅读数据，在您将其设置为1之前看到该值，这是相当令人惊讶的。

2670
01:21:31,530 --> 01:21:33,560
0,510 510,810 810,1560
after this point,

2671
01:21:33,560 --> 01:21:35,870
0,360 360,690 690,810 810,1380 1680,2310
someone reading the data, sees

2672
01:21:35,870 --> 01:21:37,250
0,300 300,690 690,1050 1050,1200 1200,1380
that value before you set

2673
01:21:37,250 --> 01:21:38,460
0,90 90,180 180,600
it to one.|
|

2674
01:21:39,520 --> 01:21:40,870
0,210 210,420 420,630 840,1260 1260,1350
Right, that's a maybe a
对，这可能有点意外，对吧。

2675
01:21:40,870 --> 01:21:42,460
0,210 210,270 270,330 330,1200 1200,1590
bit of a surprise, right.|
|

2676
01:21:43,100 --> 01:21:44,450
0,480 600,900 900,960 960,1260 1260,1350
Well, there's a sense in
嗯，有一种感觉是RCU允许这样的事情发生，

2677
01:21:44,450 --> 01:21:45,650
0,210 210,360 360,660 660,1020 1020,1200
which {RCU -} allows that

2678
01:21:45,650 --> 01:21:47,180
0,60 60,510 870,1170 1170,1320 1320,1530
to happen right,| if this
|如果这真的是我们要讨论的问题，

2679
01:21:47,180 --> 01:21:49,130
0,180 180,810 1290,1620 1620,1740 1740,1950
is really what we're really

2680
01:21:49,130 --> 01:21:52,250
0,450 450,900 900,1800 2010,2700 2790,3120
talking about is,| {} you
|你知道，名单上的任何东西都可以替换掉，

2681
01:21:52,250 --> 01:21:54,460
0,390 420,1770
know list

2682
01:21:55,030 --> 01:21:57,300
0,1740
replace

2683
01:21:57,330 --> 01:21:58,530
0,630 630,720 720,840 840,1110 1110,1200
whatever,| you know find the
|你知道，找到有一个的元素，然后把它改成两个，

2684
01:21:58,530 --> 01:21:59,910
0,360 360,450 450,540 540,900 900,1380
element that has one and

2685
01:21:59,910 --> 01:22:02,070
0,270 270,480 480,1230 1290,1680 1680,2160
change it {to,two},| with, using
|用，用<English>RCU</English>，对，

2686
01:22:02,070 --> 01:22:03,520
0,180 180,870
{RCU -},

2687
01:22:03,730 --> 01:22:05,920
0,450 1050,1440 1440,1620 1620,2010 2010,2190
right,| after that finishes, we
|在那之后，我们打印哦，是的，我们做完了，

2688
01:22:05,920 --> 01:22:07,030
0,210 210,360 360,510 510,630 630,1110
print oh yeah we're done,|
|

2689
01:22:07,960 --> 01:22:09,920
0,180 180,390 390,750 750,1410
if there's some reader
如果有读者看对了名单，

2690
01:22:10,490 --> 01:22:11,540
0,300 300,480 480,630 630,930 930,1050
{} that was looking at

2691
01:22:11,540 --> 01:22:13,490
0,120 120,660 690,960 990,1380 1380,1950
the list right,| they may
|您可能知道，他们刚刚访问了包含一个的列表元素，我们被替换为两个

2692
01:22:13,490 --> 01:22:14,960
0,210 210,360 360,540 540,1110 1110,1470
have you know just gotten

2693
01:22:14,960 --> 01:22:16,070
0,120 120,210 210,510 510,960 960,1110
to the list element that

2694
01:22:16,070 --> 01:22:17,240
0,270 270,720 720,870 870,960 960,1170
held one, that we were

2695
01:22:17,240 --> 01:22:18,320
0,300 300,390 390,840 840,960 960,1080
replaced with two| and then
|然后很长一段时间，你知道，然后他们实际读取列表元素，

2696
01:22:18,320 --> 01:22:19,460
0,90 90,270 270,510 510,1050 1050,1140
a good deal longer, you

2697
01:22:19,460 --> 01:22:20,540
0,210 300,480 480,810 810,930 930,1080
know, and then they do

2698
01:22:20,540 --> 01:22:22,300
0,120 120,480 480,1140
the actual read

2699
01:22:22,420 --> 01:22:24,670
0,480 1050,1230 1230,1530 1530,2040 2100,2250
of the list element,| you
|您知道，在我们完成此操作后，他们会查看列表元素中的任何内容，

2700
01:22:24,670 --> 01:22:25,980
0,60 60,210 210,480 480,630
know they look at

2701
01:22:27,240 --> 01:22:28,350
0,360 360,420 420,900 900,1050 1050,1110
whatever the content is in

2702
01:22:28,350 --> 01:22:29,430
0,60 60,270 270,570 570,870 870,1080
the list element after we've

2703
01:22:29,430 --> 01:22:31,200
0,270 270,630 900,1200 1200,1260 1260,1770
done this,| you know they're
|您知道他们正在读取列表元素，只是在稍后的这一点上

2704
01:22:31,200 --> 01:22:33,000
0,450 450,570 570,900 900,1470 1500,1800
reading the list element, only

2705
01:22:33,000 --> 01:22:34,020
0,90 90,300 300,630 630,900 900,1020
at this point later in

2706
01:22:34,020 --> 01:22:35,100
0,420 420,540 540,660 660,960 960,1080
time| and they see the
|他们看到了旧的价值。

2707
01:22:35,100 --> 01:22:36,640
0,360 360,930
old value.|
|

2708
01:22:39,660 --> 01:22:40,800
0,240 240,330 330,450 450,630 630,1140
So if you're not prepared
所以如果你没有做好准备，

2709
01:22:40,800 --> 01:22:41,730
0,120 120,450 450,660 660,720 720,930
for this,| this is a
|现在这有点奇怪了。

2710
01:22:41,730 --> 01:22:43,460
0,240 240,390 390,750 750,1170
little bit odd now.|
|

2711
01:22:44,170 --> 01:22:45,300
0,510

2712
01:22:45,970 --> 01:22:47,440
0,150 150,240 240,900
I mean they,
我的意思是他们，他们甚至可能把记忆屏障做对了，

2713
01:22:47,440 --> 01:22:48,160
0,240 240,360 360,540 540,660 660,720
they may even do a

2714
01:22:48,160 --> 01:22:49,450
0,360 360,780 780,1110 1110,1140 1140,1290
memory barrier right,| I mean
|我是说这不是记忆问题屏障就像。

2715
01:22:49,450 --> 01:22:50,470
0,120 120,270 270,330 330,660 660,1020
it's not a memory barrier

2716
01:22:50,470 --> 01:22:52,100
0,270 270,390 390,630 630,990
issue, is just like.|
|

2717
01:22:53,980 --> 01:22:55,360
0,420 660,1050 1050,1260 1260,1320 1320,1380
And indeed, most of the
事实上，在大多数情况下，这都无关紧要。

2718
01:22:55,360 --> 01:22:57,780
0,180 180,270 270,540 540,1020
time it doesn't matter.|
|

2719
01:22:58,240 --> 01:22:59,080
0,240 240,480 480,570 570,720 720,840
I see, so this is
我明白了，所以这就是替代方案非常接近的时候，

2720
01:22:59,080 --> 01:23:02,520
0,540 810,1530 1560,2970
when this {replace,is}

2721
01:23:02,520 --> 01:23:04,600
0,660 720,1650
very close,|
|

2722
01:23:04,630 --> 01:23:06,670
0,210 210,510 540,1050 1050,1560 1680,2040
so like they read somehow
所以他们读起来好像在更换前就开始了，

2723
01:23:06,670 --> 01:23:08,950
0,180 180,780 780,1530 1620,1800 1800,2280
like starts before the replace,|
|

2724
01:23:08,950 --> 01:23:09,940
0,390
but
但这需要一段时间，而且。

2725
01:23:10,140 --> 01:23:11,200
0,180 180,480
it is

2726
01:23:11,200 --> 01:23:13,780
0,390 390,1020 1020,1320 1320,2070 2190,2580
takes {a,while}, and.| Yes, yeah,
|是的，是的，如果读者比作家慢，那就是读者。

2727
01:23:13,780 --> 01:23:14,800
0,60 60,330 390,600 600,690 690,1020
the reader if the reader

2728
01:23:14,800 --> 01:23:16,240
0,120 120,750 750,900 900,1020 1020,1440
is slower than the writer

2729
01:23:16,240 --> 01:23:18,480
0,90 90,600 810,1290
or something.| Now,
|现在，你知道，我觉得这基本上不重要，

2730
01:23:18,510 --> 01:23:19,960
0,150 150,240 240,750
you know, {}

2731
01:23:20,580 --> 01:23:21,780
0,270 270,510 510,690 690,960 960,1200
I think this mostly doesn't

2732
01:23:21,780 --> 01:23:24,930
0,420 1080,1650 1860,2340 2340,2760 2850,3150
matter,| because after all, the
|因为毕竟，读者和作者是同时行动的

2733
01:23:24,930 --> 01:23:25,860
0,300 300,390 390,480 480,750 750,930
reader and the writer were

2734
01:23:25,860 --> 01:23:28,020
0,390 420,1140 1140,1530
acting concurrently| and
|你知道有两件事同时发生，

2735
01:23:28,110 --> 01:23:29,010
0,120 120,270 270,450 450,630 630,900
you know two things happen

2736
01:23:29,010 --> 01:23:31,560
0,570 570,900 900,1410 1410,1710
concurrently,| {} usually you,
|通常你，你怎么也想不到，你会得到很多关于确切订单的保证，

2737
01:23:32,250 --> 01:23:33,810
0,390 390,540 540,870 870,990 990,1560
you would never have imagined

2738
01:23:33,810 --> 01:23:34,530
0,120 120,240 240,360 360,450 450,720
that you could have been

2739
01:23:34,530 --> 01:23:36,560
0,540 540,840 840,1590
guaranteed much about

2740
01:23:36,560 --> 01:23:38,450
0,180 180,600 600,1200 1530,1740 1740,1890
the exact order,| if the
|如果同时调用这两个操作。

2741
01:23:38,450 --> 01:23:40,250
0,210 210,840 840,930 930,1350 1350,1800
two operations were invoked concurrently.|
|

2742
01:23:42,000 --> 01:23:44,480
0,450 450,870 870,1950
The paper claims,
这篇论文声称，我是说，这篇论文是他们说这很重要的一个例子，

2743
01:23:44,960 --> 01:23:45,620
0,90 90,240 240,300 300,540 540,660
I mean, the paper as

2744
01:23:45,620 --> 01:23:46,430
0,60 60,480 480,540 540,690 690,810
an example in which they

2745
01:23:46,430 --> 01:23:48,050
0,180 180,270 270,1080 1260,1380 1380,1620
said it matters,| it turned
|结果造成了一个真正的问题，

2746
01:23:48,050 --> 01:23:49,250
0,480 570,690 690,930 930,1020 1020,1200
out to cause a real

2747
01:23:49,250 --> 01:23:50,600
0,420 510,750 750,840 840,1140 1140,1350
problem,| although I don't really
|虽然我真的不明白为什么会这样。

2748
01:23:50,600 --> 01:23:51,900
0,810
understand

2749
01:23:53,610 --> 01:23:55,240
0,240 240,450 450,1020
why that was.|
|

2750
01:23:55,690 --> 01:23:57,010
0,150 150,420 420,630 630,870 870,1320
I see, this makes sense,|
我明白了，这说得通，|

2751
01:23:57,070 --> 01:23:58,720
0,330 330,450 450,810 810,1230 1230,1650
and my other question was
我的另一个问题是，它之所以被称为RCU，是因为想法一，对吗？

2752
01:23:59,050 --> 01:24:00,550
0,300 300,660 660,720 720,1140 1140,1500
it's called a RCU because

2753
01:24:00,550 --> 01:24:02,410
0,240 270,720 720,1230 1320,1650 1650,1860
of idea one, is that

2754
01:24:02,410 --> 01:24:05,770
0,420 480,930 930,1350 1350,2070 2100,3360
right.| Read copy update, yes,|
|阅读副本更新，是的，|

2755
01:24:06,010 --> 01:24:07,180
0,210 210,600 600,780 780,1050 1050,1170
I believe it's because of
我相信是因为想法一，

2756
01:24:07,180 --> 01:24:08,440
0,330 330,600 600,780 780,1020 1020,1260
idea one,| that is that
|也就是说，不是在适当的地方修改东西，

2757
01:24:09,110 --> 01:24:10,760
0,360 360,450 450,1050 1050,1560 1560,1650
instead of modifying things in

2758
01:24:10,760 --> 01:24:13,460
0,930 1020,1650 1950,2190 2190,2250 2250,2700
place,| you make a copy
|你复制了一份，你有点复制了，而不是那是真的。

2759
01:24:13,460 --> 01:24:16,280
0,120 120,240 1170,1890
and you {sort,of}

2760
01:24:16,460 --> 01:24:19,220
0,1050 1080,1350 1350,1890 2490,2700 2700,2760
copy not the that's the

2761
01:24:19,220 --> 01:24:20,520
0,210 210,570
real thing.|
|

2762
01:24:20,670 --> 01:24:21,990
0,330 330,510 510,720 720,1080 1080,1320
Right, this makes sense, thank
好的，这就说得通了，非常感谢。

2763
01:24:21,990 --> 01:24:23,360
0,90 90,270 270,810
you so much.|
|

2764
01:24:24,520 --> 01:24:25,700
0,510
Yes.|
是。|

2765
01:24:26,310 --> 01:24:27,240
0,240 240,360 360,420 420,810 810,930
So at the beginning of
所以在课程开始的时候

2766
01:24:27,240 --> 01:24:28,590
0,450 450,660 690,960 960,1020 1020,1350
lecture| or towards the beginning
|或者接近开始时我们讨论了高速缓存一致性协议的n平方运行时，

2767
01:24:28,590 --> 01:24:29,880
0,120 120,390 390,660 660,960 960,1290
we talked about the of

2768
01:24:29,880 --> 01:24:31,950
0,180 180,630 630,1200 1200,1740 1980,2070
n squared runtime for the

2769
01:24:31,950 --> 01:24:35,610
0,390 390,870 870,1530 2670,3270 3270,3660
cache coherence protocols,| for updating
|为了更新读写锁定，

2770
01:24:35,610 --> 01:24:37,380
0,90 90,210 210,450 450,930 1350,1770
the {read,write -} locks {},|
|

2771
01:24:37,560 --> 01:24:39,030
0,330 330,510 510,990 990,1080 1080,1470
isn't this also a problem
这不也是旋转锁的问题吗。

2772
01:24:39,030 --> 01:24:41,560
0,150 150,450 450,1080 1080,1950
with spin locks, where.|
|

2773
01:24:42,600 --> 01:24:45,240
0,360 420,750 780,1170 1170,1830 2160,2640
Yeah, okay so so what
是的，好的，那么原因是什么，为什么我们没有讨论这一方面。

2774
01:24:45,270 --> 01:24:46,680
0,180 180,540 600,1050 1050,1290 1290,1410
is the reason, why we

2775
01:24:46,680 --> 01:24:49,100
0,210 210,600 600,1170 1170,1890
didn't discuss that aspect.|
|

2776
01:24:49,320 --> 01:24:51,780
0,390 390,600 600,1050 1500,1920 1920,2460
Why we didn't.| Yeah or
为什么我们没有。|是啊，或者类似的，有没有理由说它仍然存在？

2777
01:24:51,780 --> 01:24:52,980
0,330 360,540 540,750 750,870 870,1200
like, is there a reason

2778
01:24:52,980 --> 01:24:54,690
0,360 390,840 840,1020 1020,1470 1470,1710
that that still exists| or
|或者就像旋转锁是怎么解决这个问题的。

2779
01:24:54,690 --> 01:24:55,590
0,150 150,330 330,570 570,690 690,900
are like what do spin

2780
01:24:55,590 --> 01:24:56,790
0,300 300,420 420,540 540,900 900,1200
locks do to address that.|
|

2781
01:24:58,050 --> 01:25:00,600
0,780 810,1200 1200,1260 1260,1740 1740,2550
Okay.| Locks are hideously expensive,|
好吧。|锁贵得吓人，|

2782
01:25:00,630 --> 01:25:02,760
0,210 210,840 1320,1560 1560,1950 1950,2130
if there are standard spin
如果有标准的自旋锁，就像xv6那样，

2783
01:25:02,760 --> 01:25:04,290
0,240 240,360 360,630 630,1230 1230,1530
locks, like {xv6,has -},| are
|如果锁不是特别争用并且非常慢的话是非常快的，

2784
01:25:04,470 --> 01:25:06,930
0,690 690,1380 1530,1980 1980,2220 2220,2460
extremely fast if the lock

2785
01:25:06,930 --> 01:25:09,280
0,120 120,600 600,1080 1080,1710
is not particularly contended

2786
01:25:09,310 --> 01:25:12,160
0,600 720,1380 1380,1950 1980,2520 2550,2850
and terribly slow,| if lots
|如果多个内核试图同时获得相同的锁。

2787
01:25:12,160 --> 01:25:12,910
0,90 90,420 420,570 570,660 660,750
of cores try to get

2788
01:25:12,910 --> 01:25:13,450
0,60 60,240 240,420 420,480 480,540
the same lock at the

2789
01:25:13,450 --> 01:25:14,520
0,210 210,480
same time.|
|

2790
01:25:14,720 --> 01:25:16,340
0,390 570,1110 1200,1380 1380,1440 1440,1620
Okay, yeah, this is one
好吧，是的，这是让生活变得有趣的一件事

2791
01:25:16,340 --> 01:25:16,850
0,60 60,120 120,270 270,360 360,510
of the things that makes

2792
01:25:16,850 --> 01:25:17,690
0,210 210,570 570,690 690,750 750,840
life interesting| and you know
|你知道，是的，我的意思是，有一些锁，它的伸缩性更好，

2793
01:25:17,690 --> 01:25:19,240
0,630
there's,

2794
01:25:19,520 --> 01:25:22,880
0,120 120,360 360,720 1740,2790 3060,3360
yeah I mean there's there's

2795
01:25:22,880 --> 01:25:24,560
0,450 450,630 630,960
locks that are

2796
01:25:25,060 --> 01:25:27,910
0,180 180,450 450,1380 1620,1920 1920,2850
a better scaling,| but worse,
|但更糟糕的是，它们具有较好的高负载性能，但较差的慢负载性能。

2797
01:25:28,870 --> 01:25:30,460
0,540 630,930 930,1080 1080,1320 1320,1590
{} they have better high

2798
01:25:30,460 --> 01:25:31,780
0,240 240,720 720,840 840,990 990,1320
load performance, but worse slow

2799
01:25:31,780 --> 01:25:33,460
0,300 300,1170
load performance.|
|

2800
01:25:33,460 --> 01:25:35,280
0,810
Yeah.|
嗯。|

2801
01:25:35,280 --> 01:25:36,060
0,210 210,360 360,510 510,720 720,780
But I'm not aware of
但我不知道有没有锁，

2802
01:25:36,060 --> 01:25:38,100
0,60 60,420 420,570 570,1080 1650,2040
a lock that is,| anyway,
|不管怎么说，这件事很难做对，

2803
01:25:38,250 --> 01:25:39,300
0,390 390,660 660,780 780,960 960,1050
it's hard it's hard to

2804
01:25:39,300 --> 01:25:40,260
0,150 150,300 300,540 540,750 810,960
get this stuff right,| it's
|在这些机器上很难获得好的性能。

2805
01:25:40,260 --> 01:25:42,660
0,210 210,330 1650,1860 1860,2010 2010,2400
hard to get good performance

2806
01:25:42,660 --> 01:25:44,400
0,60 60,240 240,1230
on these machines.|
|

2807
01:25:51,070 --> 01:25:52,740
0,180 180,1020
Other questions?|
还有其他问题吗？|

2808
01:25:55,440 --> 01:25:57,060
0,150 150,330 330,450 450,1080 1080,1620
This might be unrelated, but
这可能是无关的，但在多个不同的系统之间会有一系列的游戏吗，

2809
01:25:57,840 --> 01:25:58,740
0,210 210,390 390,600 600,690 690,900
can there ever be a

2810
01:25:58,740 --> 01:26:00,300
0,300 330,450 450,720 720,1110 1110,1560
lock of games between multiple

2811
01:26:00,300 --> 01:26:04,740
0,390 390,720 720,1590 1740,3600 3870,4440
{} different systems,| like like
|就像不仅仅局限于一个系统，

2812
01:26:05,710 --> 01:26:07,030
0,240 240,450 450,900 900,1020 1020,1320
not just contained to one

2813
01:26:07,030 --> 01:26:09,160
0,390 390,690 690,1020 1290,1710 1710,2130
system,| maybe like multiple servers
|也许像多台服务器一样。

2814
01:26:09,160 --> 01:26:10,700
0,780
perhaps.|
|

2815
01:26:10,890 --> 01:26:13,140
0,390 390,660 660,1140 1140,1710 1710,2250
There are absolutely distributed systems,|
有绝对的分布式系统，|

2816
01:26:13,140 --> 01:26:15,000
0,120 120,810 1050,1500 1500,1680 1680,1860
in which there's a sort
其中有一种锁定，

2817
01:26:15,000 --> 01:26:18,660
0,150 150,1110
of locking,|
|

2818
01:26:18,910 --> 01:26:19,780
0,240 240,450 450,630 630,810 810,870
in which the sort of
其中的万能锁跨越多台机器，

2819
01:26:19,780 --> 01:26:22,690
0,510 510,930 930,1350 1350,1860 1860,2910
universal locks spans multiple machines,|
|

2820
01:26:23,410 --> 01:26:24,700
0,390 390,690 690,930 930,1080 1080,1290
when places comes up in
当分布式数据库中出现位置时

2821
01:26:24,700 --> 01:26:27,190
0,510 510,1110 1110,1320 1320,1680 1710,2490
distributed databases| where the data
|您遇到的数据会在多个服务器上显示您的数据，

2822
01:26:27,610 --> 01:26:29,200
0,450 450,1020 1020,1200 1200,1500 1500,1590
you've met you display your

2823
01:26:29,200 --> 01:26:30,520
0,270 270,420 420,780 780,1230 1230,1320
data over multiple servers,| but
|但是如果你有一个使用数据的事务，你知道不同服务器上的不同数据，

2824
01:26:30,520 --> 01:26:31,840
0,90 90,180 180,390 390,420 420,1320
if you have a transaction,

2825
01:26:32,110 --> 01:26:34,090
0,390 390,840 840,1110 1110,1650 1860,1980
that uses data this you

2826
01:26:34,090 --> 01:26:35,140
0,210 210,480 480,750 750,810 810,1050
know different pieces of data

2827
01:26:35,140 --> 01:26:36,460
0,120 120,360 360,900 930,1200 1200,1320
on different servers,| you need
|你需要收集锁。

2828
01:26:36,460 --> 01:26:38,140
0,180 180,360 360,450 450,870 870,1680
gonna need to collect locks.|
|

2829
01:26:38,510 --> 01:26:40,220
0,180 180,450 480,780 780,1050
They were {} in,
他们在里面，你基本上需要从多个服务器上收集锁，

2830
01:26:40,560 --> 01:26:42,030
0,240 240,360 360,510 720,1140 1140,1470
you need to basically collect

2831
01:26:42,030 --> 01:26:44,310
0,240 240,390 390,750 750,1560 1860,2280
locks from multiple servers {},|
|

2832
01:26:44,490 --> 01:26:45,960
0,420 420,660 660,840 840,1080 1080,1470
another place that comes up.|
另一个出现的地方。|

2833
01:26:46,840 --> 01:26:50,530
0,540 540,1320 2580,3450 3450,3630 3630,3690
{} Although there's been a
虽然已经有很多系统试图在独立的机器上模拟共享内存。

2834
01:26:50,530 --> 01:26:51,610
0,270 270,330 330,750 750,870 870,1080
number of systems that are

2835
01:26:51,610 --> 01:26:54,220
0,480 480,960 960,1260 1260,1950 2010,2610
essentially tried to mimic shared

2836
01:26:54,220 --> 01:26:57,420
0,450 450,1170 1170,1710 1710,2760
memory across independent machines.|
|

2837
01:26:57,570 --> 01:26:59,100
0,450 510,660 660,720 720,1320 1320,1530
{} With the machines, if
对于机器，如果我使用你机器中的一些内存，

2838
01:26:59,100 --> 01:27:00,330
0,120 120,360 360,480 480,810 810,1230
I use some memory that's

2839
01:27:00,330 --> 01:27:02,190
0,120 120,270 270,750 750,1050 1320,1860
in your machine,| then there's
|还有一些基础设施问题会导致我的计算机与您的计算机对话

2840
01:27:02,190 --> 01:27:03,870
0,180 180,720 720,990 990,1140 1140,1680
some infrastructure stuff that causes

2841
01:27:03,870 --> 01:27:04,650
0,150 150,450 450,540 540,720 720,780
my machine to talk to

2842
01:27:04,650 --> 01:27:05,460
0,120 120,390 390,480 480,690 690,810
your machine| and ask for
|向我索要记忆

2843
01:27:05,460 --> 01:27:08,080
0,60 60,540 990,1380 1590,2070
the memory| and {}
|你知道，游戏通常是在一群工作站上运行现有的并行程序

2844
01:27:09,070 --> 01:27:10,930
0,450 450,780 780,1020 1140,1800 1800,1860
{} you know then the

2845
01:27:10,930 --> 01:27:11,980
0,240 240,360 360,630 630,720 720,1050
game is usually to run

2846
01:27:12,010 --> 01:27:14,230
0,480 480,840 840,1890 1920,2130 2130,2220
existing parallel programs on a

2847
01:27:14,230 --> 01:27:15,910
0,420 420,480 480,1260 1260,1590 1590,1680
cluster of workstations| instead of
|而不是在一台大型的多核机器上，

2848
01:27:15,910 --> 01:27:18,010
0,660 1140,1320 1320,1650 1650,1890 1890,2100
on a big {multi-core -}

2849
01:27:18,010 --> 01:27:19,020
0,480
machine,|
|

2850
01:27:19,020 --> 01:27:19,740
0,330 330,450 450,540 540,660 660,720
hoping this is going to
希望这会便宜一点

2851
01:27:19,740 --> 01:27:21,090
0,90 90,540 720,1170 1170,1260 1260,1350
be cheaper| and you know
|你知道需要对那里的自旋锁做些什么

2852
01:27:21,090 --> 01:27:21,870
0,270 270,450 450,510 510,600 600,780
something needs to be done

2853
01:27:21,870 --> 01:27:23,040
0,210 210,450 450,720 720,1050 1050,1170
about spin locks there| or
|或者你要用的任何锁。

2854
01:27:23,040 --> 01:27:24,090
0,390 390,750 750,840 840,990 990,1050
whatever locking you're going to

2855
01:27:24,090 --> 01:27:24,900
0,270 270,360 360,450 450,720 720,810
use.| And so people have
|因此，人们发明了各种方法来使锁在这种情况下工作得很好。

2856
01:27:24,900 --> 01:27:26,880
0,390 390,750 750,1140 1140,1290 1830,1980
invented various ways to make

2857
01:27:26,880 --> 01:27:27,990
0,90 90,420 420,630 630,840 840,1110
the locking work out well

2858
01:27:28,170 --> 01:27:29,380
0,120 120,240 240,480 480,630
in that case too.|
|

2859
01:27:30,780 --> 01:27:33,000
0,240 240,750 1500,2070 2070,2160 2160,2220
You using techniques that are
你使用的技术通常和这个不太一样，

2860
01:27:33,000 --> 01:27:34,170
0,480 480,750 750,930 930,1080 1080,1170
not often not quite the

2861
01:27:34,170 --> 01:27:36,360
0,180 180,300 300,660 1470,2070 2070,2190
same as this,| although the
|虽然避免的压力，避免成本的压力在那块更高。

2862
01:27:36,360 --> 01:27:38,400
0,360 360,510 510,1470
pressure to avoid,

2863
01:27:39,070 --> 01:27:40,990
0,360 810,1140 1140,1200 1200,1470 1470,1920
the pressure to avoid costs

2864
01:27:40,990 --> 01:27:41,890
0,150 150,330 330,690 690,780 780,900
is even higher in that

2865
01:27:41,890 --> 01:27:43,000
0,570
piece.|
|

2866
01:27:54,980 --> 01:27:56,900
0,300 300,960
Anything else?|
还要别的吗？|

2867
01:28:01,220 --> 01:28:02,400
0,300 300,630
Thank you.|
谢谢。|

2868
01:28:03,020 --> 01:28:06,180
0,210 210,570
You're welcome.
不用谢。
