1
00:00:00,950 --> 00:00:02,740
0,990
Alright,
好的，有人听到我说话吗？

2
00:00:02,740 --> 00:00:06,800
0,270 270,480 480,840 1470,3240
anyone hear me?| Good.|
|好的。|

3
00:00:07,480 --> 00:00:08,890
0,240 240,450 450,540 540,690 690,1410
Alright today we got meltdown,|
好的，今天我们要讲 meltdown ，|

4
00:00:09,370 --> 00:00:11,380
0,660 1170,1620 1620,1830 1830,1920 1920,2010
{} the reason why I'm
我读这篇论文是因为，

5
00:00:11,380 --> 00:00:13,210
0,330 330,510 510,1110 1260,1530 1530,1830
reading this paper is that,|
|

6
00:00:13,690 --> 00:00:16,300
0,1080 1080,1680 1680,1890 1890,1950 1950,2610
security has kind of been
安全一直是一个话题，

7
00:00:17,140 --> 00:00:18,940
0,120 120,570 570,690 690,1260 1260,1800
a topic all along| and
|在内核的设计中出现了很多问题，

8
00:00:19,510 --> 00:00:20,410
0,300 300,420 420,480 480,810 810,900
comes up a lot in

9
00:00:20,410 --> 00:00:21,880
0,90 90,540 540,630 630,720 720,1470
the design of the kernels,|
|

10
00:00:21,940 --> 00:00:22,810
0,270 270,390 390,660 660,810 810,870
that we talked about in
我们在课程中谈到的，

11
00:00:22,810 --> 00:00:24,730
0,60 60,720 1590,1740 1740,1830 1830,1920
the class| and as we
|我们所知的主要策略，我们已经讨论过，

12
00:00:24,730 --> 00:00:26,710
0,150 150,570 990,1380 1380,1860 1860,1980
know the main strategy, we've

13
00:00:26,710 --> 00:00:28,870
0,300 300,690 690,1110 1620,1860 1860,2160
talked about for,| {} what
|内核主要提供安全的是隔离，

14
00:00:28,870 --> 00:00:29,710
0,60 60,300 300,450 450,510 510,840
it main for a kernel

15
00:00:29,710 --> 00:00:32,320
0,360 540,1140 1140,1680 1680,1830 1830,2610
to provide security is isolation,|
|

16
00:00:33,460 --> 00:00:34,750
0,120 120,180 180,480 480,660 660,1290
in the sense that user
用户程序可以从内核读取数据，

17
00:00:34,750 --> 00:00:35,860
0,330 330,540 540,750 750,960 960,1110
programs can read data from

18
00:00:35,860 --> 00:00:37,030
0,60 60,420 420,570 570,780 780,1170
the kernel| and user programs
|但是用户程序不能读取其他用户的数据，

19
00:00:37,030 --> 00:00:39,160
0,300 300,660 690,930 930,1650 1710,2130
can't read other user's data

20
00:00:39,160 --> 00:00:41,680
0,330 360,630 630,900 900,1620 2340,2520
from other user programs,| and
|我们看到的特别技术，

21
00:00:41,680 --> 00:00:44,410
0,330 480,1260 1260,1740 1740,2010 2160,2730
the specific techniques that {}

22
00:00:45,050 --> 00:00:46,850
0,180 180,390 390,540 540,900 900,1800
{you,know} we've seen,| operating systems
|操作系统为了实现隔离，

23
00:00:47,240 --> 00:00:48,110
0,300 300,390 390,600 600,690 690,870
used in order to get

24
00:00:48,110 --> 00:00:49,640
0,630 630,720 720,960 960,1170 1290,1530
isolation| or things like the
|或者硬件中的用户管理者模式之类的东西，

25
00:00:49,640 --> 00:00:50,990
0,300 300,870 870,1200 1200,1290 1290,1350
user supervisor mode in the

26
00:00:50,990 --> 00:00:53,150
0,630 780,1230 1230,1350 1350,1740 1740,2160
hardware| and the page tables
|以及硬件中的页表，

27
00:00:53,150 --> 00:00:55,250
0,90 90,150 150,720 1500,1830 1830,2100
in the hardware| as well
|以及一些设计精良的内核软件，

28
00:00:55,250 --> 00:00:56,450
0,360 390,720 720,900 900,1080 1080,1200
as {} just sort of

29
00:00:57,020 --> 00:00:59,090
0,210 210,450 450,1080 1110,1560 1560,2070
{} well designed kernel software,|
|

30
00:00:59,090 --> 00:01:00,020
0,150 150,240 240,540 540,810 810,930
like the system calls are
比如系统调用是防御性的，

31
00:01:00,020 --> 00:01:01,520
0,120 120,720 720,990 990,1110 1110,1500
all defensive| about how they
|对于如何使用用户提供的指针。

32
00:01:02,450 --> 00:01:05,720
0,390 390,660 660,1350 1380,2160 2490,3270
use user supplied pointers {}.|
|

33
00:01:07,460 --> 00:01:09,680
0,390 390,540 540,1200 1230,1740 1740,2220
But it's worth thinking about,|
但是值得思考的是，|

34
00:01:09,770 --> 00:01:11,780
0,330 330,450 450,1110 1110,1590 1710,2010
looking at examples of how
看看这类事情是如何出错的，

35
00:01:11,780 --> 00:01:12,680
0,180 180,360 360,420 420,660 660,900
this kind of stuff goes

36
00:01:12,680 --> 00:01:14,000
0,540 570,630 630,780 780,930 930,1320
wrong,| I mean in fact,
|我的意思是，内核努力提供隔离和安全，

37
00:01:14,240 --> 00:01:15,350
0,240 240,330 330,690 690,870 870,1110
you know kernels try hard

38
00:01:15,350 --> 00:01:16,910
0,60 60,390 390,900 900,990 990,1560
to provide isolation and security,|
|

39
00:01:16,910 --> 00:01:19,010
0,390 810,1350 1410,1590 1590,2010 2010,2100
but there are problems that
但是出现了一些问题。

40
00:01:19,010 --> 00:01:21,500
0,150 150,390 540,1080 1800,2340 2340,2490
come up.| {} And this
|这篇论文是最有趣的问题之一，

41
00:01:21,500 --> 00:01:22,940
0,420 420,990 1020,1200 1200,1380 1380,1440
paper is a one of

42
00:01:22,940 --> 00:01:24,980
0,60 60,240 240,900 900,1770 1860,2040
the most interesting problems {},|
|

43
00:01:24,980 --> 00:01:25,970
0,210 210,390 390,510 510,630 630,990
that's come up with operating
这是最近出现的操作系统安全问题。

44
00:01:25,970 --> 00:01:28,160
0,300 300,960 960,1200 1200,1530 1530,2190
system security in recent times.|
|

45
00:01:28,520 --> 00:01:30,260
0,180 180,720 720,1200
{} Meltdown is
Meltdown 出现了，

46
00:01:30,260 --> 00:01:32,420
0,270 270,480 480,600 1530,1740 1740,2160
came out,| it was published
|它在 2018 年初发布的，不久之前，

47
00:01:32,420 --> 00:01:34,160
0,60 60,120 120,450 450,540 540,1740
at the beginning of {2018,,so}

48
00:01:34,190 --> 00:01:35,960
0,210 210,300 300,540 540,900 1620,1770
not too long ago,| and
|很多人像我一样都觉得很惊讶，

49
00:01:35,960 --> 00:01:36,890
0,90 90,270 270,330 330,750 750,930
a lot of people like

50
00:01:36,890 --> 00:01:38,690
0,300 300,540 540,720 720,1500 1500,1800
me found it surprising| and
|而且非常令人不安，

51
00:01:38,690 --> 00:01:40,600
0,330 330,570 570,1380
actually pretty disturbing,|
|

52
00:01:40,600 --> 00:01:42,520
0,150 150,630 630,1170 1170,1530 1560,1920
pretty disturbing attack on user
非常令人不安地对于用户内核隔离。

53
00:01:42,520 --> 00:01:45,240
0,360 360,1050
kernel isolation.|
|

54
00:01:46,020 --> 00:01:48,960
0,300 300,1290 1560,2520 2550,2730 2730,2940
{It,really} undermined faith or sort
这破坏了信仰或者说某种非常基本的假设，

55
00:01:48,960 --> 00:01:50,910
0,270 420,870 870,1110 1110,1470 1470,1950
of this very basic assumption,|
|

56
00:01:50,910 --> 00:01:53,220
0,180 180,480 600,1200 1200,2130 2160,2310
that the page tables that
硬件提供的页表会让你隔离，

57
00:01:53,220 --> 00:01:54,990
0,90 90,390 390,1050 1050,1440 1470,1770
the hardware supplies just get

58
00:01:54,990 --> 00:01:56,370
0,120 120,720 720,1020 1020,1290 1290,1380
you isolation| and that's the
|这就是故事的结束，

59
00:01:56,370 --> 00:01:57,660
0,120 120,180 180,240 240,780 1020,1290
end of the story| and
|而这次攻击完全不支持这种观点，

60
00:01:57,660 --> 00:01:58,880
0,120 120,780
this attack

61
00:01:59,490 --> 00:02:00,960
0,210 210,480 480,990 990,1200 1200,1470
does not support that view

62
00:02:00,960 --> 00:02:02,820
0,90 90,420 870,1260 1350,1800 1800,1860
at all,| {} further it
|此外，它是一个例子，

63
00:02:02,820 --> 00:02:05,100
0,150 150,240 240,870 870,1350 2070,2280
was an example of, {}|
|

64
00:02:05,100 --> 00:02:05,820
0,180 180,270 270,300 300,630 630,720
one of a number of
最近几个称为微架构攻击的例子之一，

65
00:02:05,820 --> 00:02:07,080
0,300 300,810 810,870 870,1080 1080,1260
recent examples of what's called

66
00:02:07,080 --> 00:02:08,910
0,60 60,390 390,1080 1080,1650 1680,1830
a {microarchitectural -} attack,| an
|涉及利用 CPU 内部隐藏的实现细节的攻击，

67
00:02:08,910 --> 00:02:14,010
0,420 420,570 570,1500 3570,4950 4950,5100
attack that involves exploitation of

68
00:02:14,040 --> 00:02:16,770
0,720 720,1440 1440,2010 2010,2640 2640,2730
hidden implementation details inside the

69
00:02:16,770 --> 00:02:19,050
0,780 810,930 930,1020 1020,1440 1530,2280
CPU,| that are often not
|甚至不知道 CPU 是如何工作的，

70
00:02:19,050 --> 00:02:21,720
0,330 690,1620 1620,2100 2100,2370 2370,2670
even known how this how

71
00:02:21,720 --> 00:02:23,520
0,480 480,600 600,1050 1140,1470 1470,1800
{CPU's -} work,| but people
|但是人们猜测，

72
00:02:23,520 --> 00:02:25,140
0,780 840,1140 1140,1290 1290,1500 1500,1620
guess| and they're able to
|而且他们基于正确猜测实现攻击，

73
00:02:25,140 --> 00:02:27,150
0,480 630,1230 1230,1650 1650,1890 1890,2010
make successful attacks based on

74
00:02:27,150 --> 00:02:30,240
0,480 480,1080 1500,2040 2100,2760
correct guesses| about hidden
|关于 CPU 实现隐藏细节（的猜测）。

75
00:02:30,300 --> 00:02:32,460
0,420 420,960 960,1050 1050,1440 1440,2160
{} details of CPU implementation.|
|

76
00:02:34,060 --> 00:02:34,900
0,390 390,600 600,690 690,750 750,840
Meltdown turns out to be
Meltdown 是可以修复的，

77
00:02:34,900 --> 00:02:37,750
0,630 720,1410 1530,1950 2400,2790 2790,2850
fixable| and {} seems to
|而且似乎完全修复了，

78
00:02:37,750 --> 00:02:40,270
0,300 360,570 570,1020 1020,1500 1890,2520
be pretty completely fixed,| but
|但尽管如此，这还是让人们感到恐惧，

79
00:02:40,270 --> 00:02:41,860
0,480 480,900 900,1050 1080,1380 1380,1590
nevertheless people it sort of

80
00:02:41,890 --> 00:02:43,450
0,300 300,630 630,750 750,840 840,1560
set people up to fear,|
|

81
00:02:43,630 --> 00:02:44,440
0,180 180,330 330,510 510,690 690,810
that there might be an
可能会有穷的类似的微架构攻击。

82
00:02:44,440 --> 00:02:47,290
0,510 510,1050 1050,1560 1860,2190 2220,2850
open-ended supply of {} similar

83
00:02:47,290 --> 00:02:49,860
0,390 390,1290 1320,2160
{microarchitectural -} attacks.|
|

84
00:02:49,920 --> 00:02:52,110
0,450 600,960 960,1380 1590,2010 2010,2190
{} So it's {} a
所以这是最近发生的一件非常重要，值得我们了解的事情。

85
00:02:52,200 --> 00:02:55,110
0,480 480,1260 1290,2010 2040,2670 2670,2910
pretty important recent event worth

86
00:02:55,110 --> 00:02:56,520
0,630
understanding.|
|

87
00:02:56,520 --> 00:02:58,590
0,630 750,1050 1050,1110 1110,1620 1620,2070
{} Let me start by
让我先从攻击的核心开始，

88
00:02:59,070 --> 00:03:02,240
0,360 390,1050 2040,2640
{} just {}

89
00:03:02,270 --> 00:03:05,540
0,630 630,1080 1110,1590 1860,2760 2820,3270
laying out the basic core

90
00:03:05,540 --> 00:03:06,830
0,90 90,180 180,780 870,1200 1200,1290
of the attack,| and we'll
|我们会谈谈这里发生的事情，

91
00:03:06,830 --> 00:03:08,300
0,240 240,570 870,1080 1080,1290 1290,1470
talk about what's going on

92
00:03:08,300 --> 00:03:09,020
0,150 150,270 270,450 450,540 540,720
here,| but this is {}
|但这是代码的简化版本，

93
00:03:09,110 --> 00:03:11,140
0,330 330,810 810,1350
somewhat simplified version

94
00:03:11,200 --> 00:03:12,490
0,450 510,750 750,1110 1110,1200 1200,1290
of the code| in the
|论文中关于攻击如何运作的，

95
00:03:12,490 --> 00:03:13,540
0,300 300,420 420,540 540,690 690,1050
paper for how the attack

96
00:03:13,540 --> 00:03:15,550
0,570 870,1260 1260,1560 1560,1860 1860,2010
works,| the basic idea is
|基本想法是你是一个攻击者，

97
00:03:15,550 --> 00:03:17,320
0,240 270,510 510,570 570,1290 1440,1770
that you're an attacker,| and
|出于某种原因，你可以在某些计算机上运行软件，

98
00:03:17,680 --> 00:03:18,730
0,210 210,420 420,690 690,780 780,1050
for one reason or another

99
00:03:18,730 --> 00:03:20,410
0,150 150,360 360,480 480,1260 1290,1680
you're able to run {}

100
00:03:20,440 --> 00:03:22,810
0,750 750,1350 1470,1740 1740,2250 2250,2370
software on some computer,| that
|有一些你想偷的秘密，

101
00:03:22,810 --> 00:03:24,070
0,150 150,270 270,1020 1020,1140 1140,1260
has some secrets that you'd

102
00:03:24,070 --> 00:03:25,390
0,150 150,270 270,840 870,1170 1170,1320
like to steal,| you're not
|你不能直接获得秘密，

103
00:03:25,390 --> 00:03:26,440
0,210 210,360 390,780 780,930 930,1050
allowed to directly get up

104
00:03:26,440 --> 00:03:27,310
0,90 90,510 510,630 630,780 780,870
the secrets,| but they're in
|但它们在内存中，可能是内核内存或其他进程内存，

105
00:03:27,310 --> 00:03:28,900
0,510 510,750 750,1110 1110,1500 1500,1590
memory, maybe kernel memory or

106
00:03:28,900 --> 00:03:31,360
0,240 240,810 810,1170 1230,1830 2310,2460
another processes memory,| but you've
|但是你已经能够运行一个进程，

107
00:03:31,360 --> 00:03:31,990
0,150 150,330 330,420 420,570 570,630
been able to run a

108
00:03:31,990 --> 00:03:33,970
0,420 420,540 540,840 840,1170 1200,1980
process,| maybe because you logged
|可能是因为你登录了 Athena 那样的分时机，

109
00:03:33,970 --> 00:03:35,290
0,360 360,450 450,720 720,990 990,1320
into a time sharing machine

110
00:03:35,290 --> 00:03:36,670
0,150 150,570 570,1020 1020,1110 1110,1380
like Athena machine,| or maybe
|或者是因为你在一些托管服务上购买了时间。

111
00:03:36,670 --> 00:03:38,860
0,390 390,1050 1110,1650 1650,2010 2010,2190
because you bought time on

112
00:03:38,860 --> 00:03:40,780
0,150 150,600 600,1350
some hosting service.|
|

113
00:03:40,900 --> 00:03:43,570
0,420 1530,1770 1770,2070 2070,2160 2160,2670
{} So what the attack
所以，攻击允许你运行一个程序，

114
00:03:43,600 --> 00:03:44,770
0,450 450,540 540,630 630,990 990,1170
allows you to do is

115
00:03:44,770 --> 00:03:46,030
0,180 180,240 240,660 660,750 750,1260
run a program| in which
|你在自己的内存中声明一个缓冲区，

116
00:03:46,570 --> 00:03:48,490
0,240 240,1020 1020,1200 1200,1590 1590,1920
you declare a buffer in

117
00:03:48,520 --> 00:03:49,810
0,240 240,360 360,810 810,1050 1050,1290
your own memory,| so this
|所以这个 buf 是一个普通的用户可以访问的内存，

118
00:03:49,810 --> 00:03:52,630
0,720 870,1530 1560,1920 1950,2250 2460,2820
buf is a just ordinary

119
00:03:52,630 --> 00:03:54,940
0,210 210,510 510,660 660,1290 2040,2310
user memory that's accessible,| you
|你有想窃取的东西的内核的虚拟地址。

120
00:03:54,940 --> 00:03:56,680
0,210 210,540 570,1170 1170,1620 1620,1740
have the virtual address in

121
00:03:56,680 --> 00:03:58,540
0,120 180,1020 1110,1320 1320,1770 1770,1860
the kernel of something that

122
00:03:58,540 --> 00:04:00,240
0,180 180,570 570,660 660,1200
you're interested in stealing.|
|

123
00:04:00,580 --> 00:04:01,860
0,690

124
00:04:02,590 --> 00:04:04,540
0,570 720,1020 1020,1620 1650,1800 1800,1950
And you issue,| {what -}
你说，|我在这里写的是

125
00:04:04,540 --> 00:04:05,410
0,120 120,390 390,570 570,750 750,870
I'm writing out here is

126
00:04:05,410 --> 00:04:07,150
0,180 180,270 270,510 1470,1650 1650,1740
sort of| {} you know
|C 和汇编语言的混合体，

127
00:04:07,150 --> 00:04:08,800
0,240 270,990 990,1200 1200,1530 1530,1650
{} mix of C and

128
00:04:08,800 --> 00:04:10,180
0,510 510,720 750,1140 1140,1170 1170,1380
assembler,| but what I mean
|但我在第 3 行的意思是，

129
00:04:10,180 --> 00:04:11,170
0,90 90,330 330,600 600,780 780,990
in line 3 is that,|
|

130
00:04:11,290 --> 00:04:12,700
0,270 270,540 540,660 660,1260 1260,1410
you have the address of
你有要窃取的数据的内核虚拟地址，

131
00:04:12,700 --> 00:04:14,500
0,330 630,1050 1050,1350 1350,1740 1740,1800
the kernel virtual address of

132
00:04:14,500 --> 00:04:15,160
0,90 90,330 330,450 450,600 600,660
the data| you want to
|你想窃取的地址在 r1 中，

133
00:04:15,160 --> 00:04:16,480
0,390 390,510 510,900 900,1200 1200,1320
steal at register one or

134
00:04:16,480 --> 00:04:18,790
0,570 780,1050 1050,1410 1410,1680 1680,2310
r1| and line 3 were,
|在第 3 行，这是间接引用 r1 的指令，

135
00:04:19,270 --> 00:04:20,380
0,240 240,450 450,810 810,930 930,1110
or just imagine that this
或者仅仅假设这是取消引用寄存器1并将其结果加载到寄存器2中的指令，

136
00:04:20,380 --> 00:04:22,420
0,150 150,810 810,900 900,1170 1170,2040
is instructions to {dereference -}

137
00:04:23,050 --> 00:04:25,510
0,420 1320,1770 1770,2130 2130,2250 2250,2460
{} register one| and load
|并将它的结果放入 r2 中，

138
00:04:25,510 --> 00:04:27,310
0,240 240,630 630,780 780,1290 1290,1800
its results into register two,|
|

139
00:04:27,760 --> 00:04:29,020
0,240 240,330 330,930 930,1140 1140,1260
that's the instruction that we're
这就是我们要运行的指令，

140
00:04:29,020 --> 00:04:30,400
0,120 120,180 180,660 1080,1260 1260,1380
going to run,| and then
|然后有一条指令，

141
00:04:30,400 --> 00:04:31,810
0,180 180,270 270,780 780,1050 1050,1410
there's an instruction that {},|
|

142
00:04:32,590 --> 00:04:34,930
0,450 1050,1680 1680,1890 1890,2040 2040,2340
{} just gets the low
获取 r2 的低位，

143
00:04:34,930 --> 00:04:37,480
0,420 420,870 1230,1890 1890,2190 2190,2550
bit of register two,| so
|所以这个攻击，这个特定版本的攻击只读取了一个位，

144
00:04:37,540 --> 00:04:39,820
0,570 570,1170 1380,1560 1560,2010 2010,2280
this attack, this particular version

145
00:04:39,820 --> 00:04:41,350
0,60 60,180 180,690 870,1350 1350,1530
of this attack reads just

146
00:04:41,350 --> 00:04:43,180
0,210 210,630 630,990 990,1470 1500,1830
a single bit,| just one
|只有内核的一个内存位置的一个低位，

147
00:04:43,180 --> 00:04:45,130
0,330 330,810 840,1350 1440,1650 1650,1950
low bit of a one

148
00:04:45,130 --> 00:04:46,600
0,330 330,780 780,930 930,990 990,1470
memory location from the kernel,|
|

149
00:04:47,200 --> 00:04:48,820
0,510 510,720 720,900 900,1290 1350,1620
multiply that four thousand {4096
用它乘以 4096 ，

150
00:04:48,820 --> 00:04:50,020
0,360 360,630 630,900 900,990 990,1200
- - -}| and since
|因为它要么是 0 ，要么是 1 ，

151
00:04:50,020 --> 00:04:51,130
0,120 120,360 360,690 690,750 750,1110
it's either zero or one,|
|

152
00:04:51,130 --> 00:04:52,540
0,120 120,390 390,630 750,1200 1200,1410
that means that {r2 -}
这意味着 r2 最终是 0 或 4096 ，

153
00:04:52,540 --> 00:04:53,500
0,120 120,300 300,390 390,570 570,960
will end up being {zero,or}

154
00:04:53,500 --> 00:04:54,700
0,180 180,540 540,780 780,1080 1080,1200
{4096 - - -}| and
|然后我们简单地读取 buf 的内容，

155
00:04:54,700 --> 00:04:56,260
0,120 120,210 210,540 540,1170 1320,1560
then we simply read the

156
00:04:56,260 --> 00:04:57,940
0,450 450,510 510,750 750,1350 1530,1680
contents of our buf,| which
|这是一个用户内存缓冲，

157
00:04:57,940 --> 00:04:58,580
0,240
is

158
00:04:58,730 --> 00:05:00,140
0,120 120,390 390,630 630,1080 1140,1410
a buffer {of,user} memory,| we
|我们简单地读取缓冲器 0 或缓冲器 4096 ，

159
00:05:00,140 --> 00:05:02,540
0,300 300,810 810,1260 1290,1830 1830,2400
simply read either buffer 0

160
00:05:02,540 --> 00:05:05,040
0,210 210,600 600,1950
or buffer 4096,|
|

161
00:05:06,200 --> 00:05:07,430
0,120 120,300 300,360 360,630 630,1230
and that's the basic attack.|
这就是基本的攻击。|

162
00:05:08,890 --> 00:05:10,180
0,660

163
00:05:11,640 --> 00:05:13,620
0,180 180,330 330,750 750,1290
So, one question is,|
所以，有一个问题是，|

164
00:05:13,860 --> 00:05:15,060
0,180 180,420 420,570 570,780 780,1200
why doesn't this just directly
为什么这不能直接起作用，

165
00:05:15,060 --> 00:05:17,670
0,450 540,1170 1170,1710 2130,2460 2460,2610
work,| line 3 reading this
|第三行读取这个内核地址，

166
00:05:17,670 --> 00:05:19,180
0,300 300,990
kernel address,|
|

167
00:05:19,540 --> 00:05:20,950
0,180 180,270 270,450 450,930 960,1410
can we just read addresses
我们能不能只从内核读取地址。

168
00:05:20,950 --> 00:05:22,360
0,150 150,210 210,570
from the kernel.|
|

169
00:05:25,620 --> 00:05:26,820
0,390 420,780 810,990 990,1080 1080,1200
No, no, we all have
不，我们都相信答案不可能是肯定的，

170
00:05:26,820 --> 00:05:28,110
0,510 510,630 630,750 750,1050 1050,1290
faith that the answer can't

171
00:05:28,110 --> 00:05:29,850
0,480 480,1110 1110,1200 1200,1410 1410,1740
possibly {be,yes},| we can't possibly
|我们不可能在用户空间直接从内核中读取，

172
00:05:29,850 --> 00:05:30,840
0,90 90,240 240,300 300,480 480,990
be able to just directly

173
00:05:30,840 --> 00:05:32,010
0,270 270,420 420,480 480,930 960,1170
read from the kernel for

174
00:05:32,010 --> 00:05:33,870
0,120 120,390 390,960 1140,1530 1560,1860
in user space,| and the
|CPU 的机制，有时这个不能工作，

175
00:05:33,870 --> 00:05:35,970
0,660 660,810 810,1170 1380,1980 1980,2100
machinery that we know the

176
00:05:35,970 --> 00:05:37,950
0,480 480,1080 1080,1230 1230,1860 1860,1980
CPU somehow is invoking to

177
00:05:37,950 --> 00:05:39,510
0,240 240,540 540,840 840,1080 1080,1560
make this not work out,|
|

178
00:05:39,630 --> 00:05:41,760
0,360 360,690 1200,1770 1770,1950 1950,2130
is that when we use
当我们使用内核虚拟地址时，

179
00:05:41,760 --> 00:05:43,650
0,60 60,360 360,690 690,1320 1350,1890
{} kernel virtual address,| that
|这意味着在页表中查找，

180
00:05:43,650 --> 00:05:45,840
0,750 750,810 810,1230 1230,1590 1590,2190
implies a lookup in the

181
00:05:46,020 --> 00:05:47,240
0,330 330,810
page table,|
|

182
00:05:47,240 --> 00:05:48,230
0,120 120,270 270,690 690,900 900,990
and there's permission bits in
在页表中有权限位，

183
00:05:48,230 --> 00:05:49,370
0,60 60,330 330,780 870,1050 1050,1140
the page table| and we're
|并且我们假设操作系统

184
00:05:49,370 --> 00:05:50,540
0,180 180,510 510,630 630,780 780,1170
just assuming that the operating

185
00:05:50,540 --> 00:05:53,480
0,1170 1590,1950 1950,2400 2400,2850 2850,2940
system| has not set the
|没有对内核虚拟地址的页表条目设置标志，

186
00:05:53,480 --> 00:05:55,190
0,810 840,990 990,1080 1080,1410 1410,1710
flag in the page table

187
00:05:55,190 --> 00:05:56,690
0,330 330,450 450,780 780,1080 1080,1500
entries for kernel virtual addresses,|
|

188
00:05:56,690 --> 00:05:57,890
0,180 180,450 450,630 630,870 870,1200
has not set that flag
没有设置允许用户使用这些地址的标志，

189
00:05:57,890 --> 00:05:59,260
0,120 120,990
that allows

190
00:05:59,410 --> 00:06:01,750
0,1020 1020,1320 1380,1680 1680,1890 1890,2340
users to use those addresses,|
|

191
00:06:01,750 --> 00:06:03,490
0,180 180,270 270,840 840,1020 1020,1740
that's the {PTE_U -} flag
那是 RISC-V 上的 PTE_U 标志，

192
00:06:03,670 --> 00:06:05,200
0,120 120,210 210,450 450,900 1200,1530
on the {RISC-V -}| and
|所以，这个指令必须失败，一定会导致页面错误。

193
00:06:05,200 --> 00:06:06,760
0,150 150,600 600,810 810,1290 1290,1560
that therefore this instruction must

194
00:06:06,760 --> 00:06:08,080
0,480 510,720 720,900 900,960 960,1320
fail, must cause a page

195
00:06:08,080 --> 00:06:08,940
0,510
fault.|
|

196
00:06:09,220 --> 00:06:10,270
0,300 300,630 630,720 720,810 810,1050
And indeed, if we ran
事实上，如果我们运行这段代码，

197
00:06:10,270 --> 00:06:11,410
0,120 120,510 510,690 690,1050 1050,1140
this code,| this instruction would
|这条指令会导致页面错误，

198
00:06:11,410 --> 00:06:13,270
0,180 180,240 240,480 480,960 1140,1860
cause a page fault,| and
|如果我们在这之后加一个代码，

199
00:06:13,480 --> 00:06:14,440
0,180 180,270 270,690 690,780 780,960
if we tried to, if

200
00:06:14,440 --> 00:06:16,630
0,270 510,1080 1080,1380 1560,1950 1950,2190
we added a code after

201
00:06:16,630 --> 00:06:18,080
0,240 240,330 330,510 510,870
this,| to say print
|比如打印寄存器 3 中的值，

202
00:06:18,080 --> 00:06:19,460
0,60 60,360 360,450 450,870 870,1380
the value in register 3,|
|

203
00:06:20,090 --> 00:06:20,960
0,150 150,240 240,300 300,540 540,870
we get a page fault
我们在第 3 行得到一个页面错误，

204
00:06:20,960 --> 00:06:22,160
0,270 270,540 540,990 990,1110 1110,1200
on line three,| and we
|我们永远不会得到 print 语句，

205
00:06:22,160 --> 00:06:22,820
0,210 210,330 330,390 390,480 480,660
never get to the print

206
00:06:22,820 --> 00:06:24,440
0,660 900,1170 1170,1290 1290,1500 1500,1620
statement,| and we find we
|我们发现不能直接从内核窃取数据。

207
00:06:24,440 --> 00:06:26,420
0,540 870,1260 1260,1560 1560,1830 1830,1980
couldn't directly steal data out

208
00:06:26,420 --> 00:06:27,400
0,60 60,120 120,450
of the kernel.|
|

209
00:06:28,070 --> 00:06:29,420
0,480

210
00:06:30,920 --> 00:06:32,450
0,630 630,720 720,1140 1140,1380 1380,1530
Nevertheless, the sequence turned out
然而，正如论文所示的那样，这个序列被证明是有用的。

211
00:06:32,450 --> 00:06:33,230
0,60 60,180 180,570 570,720 720,780
to be useful as the

212
00:06:33,230 --> 00:06:35,580
0,270 270,930 1200,1590
paper shows {}.|
|

213
00:06:36,380 --> 00:06:38,320
0,180 180,510 510,750 750,1320
One thing that, {
这篇论文假设的一件事，

214
00:06:39,240 --> 00:06:41,130
0,780 1020,1200 1200,1380 1380,1710 1710,1890
-} one thing that the

215
00:06:41,130 --> 00:06:43,200
0,390 390,1560 1680,1830 1830,1920 1920,2070
paper assumes| which is no
|在很大程度上不再是真的，

216
00:06:43,200 --> 00:06:44,250
0,240 240,480 540,870 870,990 990,1050
longer really true for the

217
00:06:44,250 --> 00:06:46,050
0,240 240,570 660,1050 1050,1410 1500,1800
most part is that,| the
|内核映射到每个用户进程地址空间，

218
00:06:46,050 --> 00:06:48,960
0,450 450,600 600,1200 1200,2010 2190,2910
kernel is mapped into every

219
00:06:49,410 --> 00:06:52,240
0,390 390,1260 1290,1650 1650,2430
user processes address space,|
|

220
00:06:52,240 --> 00:06:54,010
0,120 120,390 390,570 570,1200 1200,1770
{} that is {} user
在页表中，用户代码运行全套内核 PTE ，

221
00:06:54,010 --> 00:06:56,350
0,390 390,690 690,1200 1620,1890 1920,2340
user codes running a full

222
00:06:56,350 --> 00:06:58,870
0,270 270,360 360,1290 1560,1740 1740,2520
set of kernel {} PTE

223
00:06:58,870 --> 00:06:59,890
0,180 180,570 570,630 630,720 720,1020
is present in the page

224
00:06:59,890 --> 00:07:00,850
0,360 390,630 630,720 720,870 870,960
table,| but they have the
|但它们把 PTE_U 清除了，

225
00:07:00,850 --> 00:07:03,580
0,660 660,960 960,1290 1290,2040 2280,2730
{PTE_U -} bit clear,| so
|所以，用户代码会得到错误，

226
00:07:03,730 --> 00:07:05,860
0,540 930,1590 1590,1860 1860,2010 2010,2130
{} user code will get

227
00:07:05,860 --> 00:07:06,850
0,60 60,510 510,600 600,690 690,990
a fault,| if it tries
|如果它试图使用内核虚拟地址，

228
00:07:06,850 --> 00:07:08,980
0,90 90,390 390,690 690,1350 1440,2130
to use a kernel virtual

229
00:07:08,980 --> 00:07:10,630
0,720 960,1140 1140,1200 1200,1350 1350,1650
address,| so all those mappings
|所以所有这些映射，

230
00:07:10,630 --> 00:07:11,950
0,690 690,840 840,900 900,1140 1140,1320
in,| at the time this
|在写这篇论文的时候，

231
00:07:11,950 --> 00:07:13,630
0,300 300,450 450,870 1170,1500 1500,1680
paper was written,| all those
|所有这些映射都在那里，当在用户空间执行时，

232
00:07:13,630 --> 00:07:15,130
0,420 420,540 540,810 810,1020 1020,1500
mappings were there, when executing

233
00:07:15,130 --> 00:07:17,170
0,120 120,360 360,1170 1320,1800 1920,2040
in user space,| {} they
|它们只是不能被用户代码使用，

234
00:07:17,170 --> 00:07:18,700
0,210 210,450 450,570 570,1020 1020,1530
just couldn't be used by

235
00:07:19,080 --> 00:07:20,280
0,270 270,540 540,990 1020,1110 1110,1200
{} user code| or they
|或者被用户代码使用时导致错误，

236
00:07:20,280 --> 00:07:21,240
0,240 240,270 270,750 780,870 870,960
cause a fault, they were

237
00:07:21,240 --> 00:07:22,560
0,180 180,270 270,540 540,840 1080,1320
used by user code {},|
|

238
00:07:22,560 --> 00:07:23,880
0,180 180,270 270,600 600,840 840,1320
and the reason why people
操作系统设计人员

239
00:07:23,910 --> 00:07:26,700
0,270 270,600 600,990 990,1680 1890,2790
by operating system designers| mapped
|在运行用户代码时，同时映射内核和用户地址的原因是，

240
00:07:26,700 --> 00:07:28,470
0,210 210,600 600,720 720,960 960,1770
both kernel and user addresses

241
00:07:29,520 --> 00:07:31,200
0,480 510,780 780,1050 1050,1410 1470,1680
when running user code is|
|

242
00:07:31,200 --> 00:07:32,910
0,150 150,330 330,660 660,1260 1290,1710
that made system calls quite
这使得系统调用速度相当快，

243
00:07:32,910 --> 00:07:34,410
0,30 30,150 150,780 1020,1320 1320,1500
a bit faster,| because that
|因为这意味着在发生系统调用时，

244
00:07:34,410 --> 00:07:35,550
0,180 180,330 330,510 510,870 870,1140
meant that on a system

245
00:07:35,550 --> 00:07:36,690
0,150 150,600 690,900 900,1050 1050,1140
call happened,| you don't have
|你不必切换页表，

246
00:07:36,690 --> 00:07:38,160
0,120 120,390 390,720 720,1350 1350,1470
to switch page tables,| and
|切换页表本身就需要时间，

247
00:07:38,160 --> 00:07:40,050
0,300 300,570 570,990 990,1260 1440,1890
switching page tables just usually

248
00:07:40,230 --> 00:07:42,030
0,270 270,510 510,1080 1260,1500 1500,1800
takes time itself| and also
|并且通常还会导致 CPU 缓存刷新，

249
00:07:42,030 --> 00:07:44,040
0,360 360,870 870,1470 1470,1950 1950,2010
typically causes CPU caches to

250
00:07:44,040 --> 00:07:45,810
0,150 150,720 780,1140 1140,1350 1350,1770
be flushed,| which makes subsequent
|使得后续代码变慢。

251
00:07:45,810 --> 00:07:47,000
0,330 330,840
codes slower.|
|

252
00:07:47,180 --> 00:07:48,100
0,420

253
00:07:48,160 --> 00:07:49,420
0,240 240,510 510,690 690,720 720,1260
So people got a boost,|
所以，人们得到了速度提升，|

254
00:07:49,420 --> 00:07:50,530
0,210 210,570 570,810 810,1020 1020,1110
by mapping both user and
通过始终在用户空间中映射用户和内核映射。

255
00:07:50,530 --> 00:07:52,180
0,450 450,870 870,990 990,1560 1560,1650
kernel {mappings -} always in

256
00:07:52,180 --> 00:07:54,520
0,240 240,840
user space.|
|

257
00:07:55,370 --> 00:07:56,900
0,360 360,630 630,960 960,1380 1380,1530
But this attack actually, and
但这个攻击正依赖于这种习惯。

258
00:07:56,900 --> 00:07:58,100
0,120 120,390 390,900 900,1050 1050,1200
this attack relies on that

259
00:07:58,100 --> 00:07:59,200
0,360
habit.|
|

260
00:08:00,040 --> 00:08:03,670
0,660 1020,1650 2040,2400 2400,2580 2580,3630
Okay, I'm going to explain
好的，我来解释一下这里发生了什么，

261
00:08:03,700 --> 00:08:04,480
0,210 210,390 390,570 570,690 690,780
what's going on here,| that
|使得这段代码有用，

262
00:08:04,480 --> 00:08:05,710
0,180 180,300 300,570 570,960 960,1230
makes this code useful,| but
|但是在我开始之前，

263
00:08:05,920 --> 00:08:07,180
0,510 510,570 570,720 720,990 990,1260
before I do that,| any
|关于这个代码片段，有没有什么问题？

264
00:08:07,180 --> 00:08:09,440
0,150 150,600 600,960 1140,1710
any questions about, {}

265
00:08:10,200 --> 00:08:11,790
0,480 480,810 810,1020 1020,1410 1410,1590
any questions about this, this

266
00:08:11,790 --> 00:08:13,120
0,240 240,810
code fragment?|
|

267
00:08:15,280 --> 00:08:16,300
0,30 120,270 270,600 600,930 930,1020
I was actually wondering if
我想知道你是否可以重复，

268
00:08:16,300 --> 00:08:17,770
0,120 120,300 300,900 1170,1350 1350,1470
you could repeat,| what you
|你刚才所说的内核到用户的映射，

269
00:08:17,770 --> 00:08:19,630
0,210 210,390 390,750 750,1500 1500,1860
just said about kernel to

270
00:08:19,630 --> 00:08:20,980
0,300 300,810
user mapping,|
|

271
00:08:20,980 --> 00:08:23,230
0,180 180,390 390,750 750,1350 1650,2250
and don't [really] register.| Okay,
并且不需要寄存器。|好的，我们看一下，

272
00:08:23,440 --> 00:08:25,360
0,660 660,930
let's see,|
|

273
00:08:25,970 --> 00:08:27,300
0,660

274
00:08:28,560 --> 00:08:29,160
0,120 120,180 180,330 330,420 420,600
you know how in {xv6
你知道在 xv6 中，

275
00:08:29,160 --> 00:08:31,050
0,120 120,990 1020,1200 1200,1350 1350,1890
- -},| when you're executing
|当进程在用户空间中执行时，

276
00:08:31,050 --> 00:08:32,370
0,270 270,360 360,750 750,870 870,1320
when the process is executing

277
00:08:32,370 --> 00:08:33,900
0,120 120,390 390,1110 1170,1410 1410,1530
in user space,| if you
|如果你查看页表，

278
00:08:33,900 --> 00:08:35,280
0,120 120,180 180,300 300,810 810,1380
look at the page table,|
|

279
00:08:35,760 --> 00:08:37,080
0,270 270,540 540,750 750,930 930,1320
that page table has mapping
页表有用户地址映射，

280
00:08:37,080 --> 00:08:39,300
0,150 150,240 240,600 600,1500 1890,2220
for the user addresses,| {and,for}
|比如 trampoline 页面，

281
00:08:39,300 --> 00:08:41,040
0,180 180,270 270,900 900,1380 1380,1740
like the trampoline page| and
|trampoline 页面，没有其他的了，

282
00:08:41,560 --> 00:08:42,550
0,90 90,420 420,600 600,870 870,990
the {trapframe -} page and

283
00:08:42,550 --> 00:08:43,980
0,240 240,930
nothing else,|
|

284
00:08:44,160 --> 00:08:45,630
0,180 180,330 330,420 420,990 990,1470
so that's how xv6 works.|
这就是 xv6 的工作。|

285
00:08:46,110 --> 00:08:48,510
0,450 450,780 780,1380 1740,2100 2100,2400
The page table that this
这篇论文假设的页表跟那个不同，

286
00:08:48,510 --> 00:08:51,330
0,420 420,1380 1890,2040 2040,2640 2640,2820
paper assumes where different from

287
00:08:51,330 --> 00:08:52,380
0,480
that,|
|

288
00:08:52,380 --> 00:08:54,090
0,510 660,900 900,1170 1200,1560 1560,1710
this, in the time this
在写这篇论文的时候，

289
00:08:54,090 --> 00:08:56,310
0,300 300,480 480,930 1110,1680 1680,2220
paper was written,| most operating
|大多数操作系统都有，

290
00:08:56,310 --> 00:08:57,720
0,870
systems

291
00:08:58,000 --> 00:09:00,400
0,600 690,1140 1590,1860 1860,1950 1950,2400
{} would have| a set
|在页表中有一套完整的内核映射，

292
00:09:00,400 --> 00:09:03,130
0,600 600,1230 1260,1440 1440,2040 2040,2730
complete set of kernel {mappings

293
00:09:03,130 --> 00:09:05,200
0,330 540,840 840,930 930,1380 1380,2070
-} in the page table,|
|

294
00:09:06,100 --> 00:09:07,690
0,360 390,810 810,1140 1140,1440 1440,1590
{} while user code was
当用户代码运行时，

295
00:09:07,690 --> 00:09:08,740
0,450
running,|
|

296
00:09:09,930 --> 00:09:13,110
0,630 1020,1620 1860,2820 2820,3000 3000,3180
{} and so all those
所以，所有那些页表条目都会在那里，

297
00:09:13,110 --> 00:09:14,070
0,210 210,420 420,750 750,870 870,960
page table entries would be

298
00:09:14,070 --> 00:09:15,420
0,510 510,660 660,750 750,1110 1110,1350
there,| all the kernel page
|当用户代码运行时，所有内核页表条目都会在那里，

299
00:09:15,420 --> 00:09:16,590
0,240 240,630 630,900 900,1020 1020,1170
table entries would be there

300
00:09:16,590 --> 00:09:17,910
0,180 180,600 630,990 990,1110 1110,1320
when user code is running,|
|

301
00:09:17,910 --> 00:09:19,350
0,210 210,480 480,570 570,1200 1200,1440
but since the {PTE_U -}
但是由于每一个那些页表条目中的 PTE_U 位被清除，

302
00:09:19,350 --> 00:09:21,330
0,510 720,1290 1290,1740 1740,1860 1860,1980
bit was clear on each

303
00:09:21,330 --> 00:09:22,320
0,90 90,270 270,480 480,690 690,990
of those page table entries,|
|

304
00:09:22,320 --> 00:09:23,460
0,240 240,450 450,660 660,990 990,1140
user code wouldn't actually be
用户代码不能使用内核虚拟地址，

305
00:09:23,460 --> 00:09:24,540
0,300 300,390 390,750 750,810 810,1080
able to use a kernel

306
00:09:24,540 --> 00:09:26,490
0,330 330,990 1170,1560 1560,1650 1650,1950
virtual address,| but the {mappings
|但是映射就在那里，

307
00:09:26,490 --> 00:09:27,600
0,210 210,300 300,660 810,1020 1020,1110
-} were there,| and the
|原因是，当你进行系统调用时，

308
00:09:27,600 --> 00:09:28,530
0,240 240,360 360,600 600,750 750,930
reason for that is that

309
00:09:28,530 --> 00:09:29,280
0,120 120,210 210,300 300,360 360,750
when you do a system

310
00:09:29,280 --> 00:09:31,170
0,480 600,1050 1260,1560 1560,1800 1800,1890
call,| you didn't have to
|你不必切换页表，

311
00:09:31,170 --> 00:09:33,060
0,360 360,690 690,1590
switch page tables,|
|

312
00:09:33,060 --> 00:09:34,800
0,510 540,810
because you
因为进行系统调用进入内核，

313
00:09:34,800 --> 00:09:35,490
0,120 120,120 120,390 390,540 540,690
do a system call into

314
00:09:35,490 --> 00:09:36,570
0,60 60,360 360,480 480,900 900,1080
the kernel| and boom you're
|当你使用相同的页表时，

315
00:09:36,570 --> 00:09:37,620
0,210 210,300 300,510 510,750 750,1050
using the same page table,|
|

316
00:09:37,620 --> 00:09:38,700
0,90 90,660 660,780 780,900 900,1080
but now you can use
现在你可以使用所有这些内核 PTE ，

317
00:09:38,700 --> 00:09:41,040
0,150 150,720 1140,1590 1590,1830 1830,2340
all those kernel {PTEs -},|
|

318
00:09:41,040 --> 00:09:42,150
0,150 150,270 270,330 330,870 870,1110
because you're in supervisor mode,|
因为你处于管理者模式，|

319
00:09:42,180 --> 00:09:43,110
0,210 210,330 330,720 720,750 750,930
and that saved a bunch
这节省了很多时间，

320
00:09:43,110 --> 00:09:44,880
0,90 90,750 960,1350 1350,1650 1650,1770
of time| getting into and
|在系统调用时进出内核。

321
00:09:44,880 --> 00:09:45,690
0,150 150,210 210,300 300,600 600,810
out of the kernel during

322
00:09:45,690 --> 00:09:47,080
0,300 300,750
system calls.|
|

323
00:09:47,230 --> 00:09:49,360
0,540 840,1260 1260,1440 1440,1650 1650,2130
Everybody, everybody used that technique,|
每个人都用这个技巧，|

324
00:09:49,390 --> 00:09:51,430
0,210 210,480 480,870 1050,1710 1710,2040
and that was almost certainly
这几乎可以肯定是英特尔的想法，

325
00:09:51,430 --> 00:09:52,630
0,150 150,450 450,630 630,720 720,1200
what Intel had in mind,|
|

326
00:09:52,630 --> 00:09:53,540
0,360
for
关于你应该如何编写操作系统。

327
00:09:53,570 --> 00:09:54,560
0,210 210,390 390,570 570,660 660,990
{how,you} should write an operating

328
00:09:54,560 --> 00:09:55,420
0,360
system.|
|

329
00:09:55,840 --> 00:09:56,950
0,330 330,480 480,690 750,1050 1050,1110
Okay, so that for the
好的，所以在整篇论文中，

330
00:09:56,950 --> 00:09:59,620
0,180 180,600 600,1050 1500,2130 2130,2670
whole paper,| that structure is
|假设攻击的结构是这样的，

331
00:09:59,710 --> 00:10:01,600
0,750 780,1020 1020,1110 1110,1590 1770,1890
assumed for the attack,| of
|当然避免它，

332
00:10:01,600 --> 00:10:02,530
0,240 240,540 540,720 720,780 780,930
course getting rid of it|
|

333
00:10:02,530 --> 00:10:05,080
0,390 660,900 900,1200 1710,2160 2160,2550
is what's the most immediate
是解决这个问题最直接的办法，

334
00:10:05,080 --> 00:10:07,330
0,420 420,510 510,660 660,1050 2070,2250
solution to this problem,| but
|但是，在编写这篇论文时，

335
00:10:07,330 --> 00:10:08,080
0,60 60,300 300,390 390,600 600,750
the time, the paper was

336
00:10:08,080 --> 00:10:09,700
0,360 630,810 810,990 990,1260 1260,1620
written| all those kernel mappings
|所有内核映射都存在于用户空间中。

337
00:10:09,700 --> 00:10:11,110
0,120 120,720 780,1020 1020,1200 1200,1410
were present {} in user

338
00:10:11,110 --> 00:10:12,280
0,510
space.|
|

339
00:10:13,760 --> 00:10:15,140
0,210 210,870
Other questions?|
还有其他问题吗？|

340
00:10:16,860 --> 00:10:17,970
0,270 270,450 450,690 690,810 810,1110
So you need to know
所以你需要知道你想得到的地址。

341
00:10:17,970 --> 00:10:19,410
0,420 450,960 960,1080 1080,1200 1200,1440
the address and you want

342
00:10:19,410 --> 00:10:22,020
0,450 750,1440 1680,2040
to get.| Yeah,
|是的，没错，就是这样。

343
00:10:22,050 --> 00:10:23,910
0,240 240,630 720,1110 1110,1380 1380,1860
that's right, it is {}

344
00:10:25,230 --> 00:10:26,660
0,750
and.|
|

345
00:10:27,180 --> 00:10:28,680
0,930

346
00:10:28,790 --> 00:10:29,540
0,210 210,330 330,420 420,690 690,750
So you know that's a
这是一个很好的观点，

347
00:10:29,540 --> 00:10:30,380
0,150 150,540 540,630 630,780 780,840
good point,| you need to
|你需要知道内核虚拟地址，

348
00:10:30,380 --> 00:10:32,030
0,90 90,210 210,660 660,1020 1020,1650
know the kernel virtual address|
|

349
00:10:32,030 --> 00:10:33,770
0,180 180,420 420,1170 1260,1500 1500,1740
and that's actually {} maybe
这可能不是开玩笑的。

350
00:10:33,770 --> 00:10:36,300
0,150 150,1050
no joke.|
|

351
00:10:37,560 --> 00:10:39,180
0,420 420,900 900,1200 1200,1470 1470,1620
Yeah, you might think that
你可能认为这会让攻击变得更难。

352
00:10:39,180 --> 00:10:41,370
0,150 150,720 1050,1200 1200,1530 1530,2190
would make the attack harder.|
|

353
00:10:42,870 --> 00:10:44,280
0,780

354
00:10:44,600 --> 00:10:45,830
0,570 570,780 780,840 840,990 990,1230
But first of all point
但是首先从安全的哲学观点来看，

355
00:10:45,830 --> 00:10:47,740
0,60 60,990
of philosophy

356
00:10:47,770 --> 00:10:49,510
0,120 120,750 750,1230 1230,1320 1320,1740
{} in security,| you just
|你需要假设攻击者有无限的时间和耐心。

357
00:10:49,750 --> 00:10:50,770
0,300 300,420 420,810 810,900 900,1020
have to assume that the

358
00:10:50,770 --> 00:10:52,150
0,360 360,540 540,960 960,1260 1260,1380
attacker has infinite time and

359
00:10:52,150 --> 00:10:53,480
0,870
patience.|
|

360
00:10:53,510 --> 00:10:54,800
0,120 120,240 240,690 690,900 900,1290
And if {there,are} some valuable
如果在一些有价值的秘密，

361
00:10:54,800 --> 00:10:56,480
0,420 720,990 990,1140 1140,1470 1470,1680
secrets,| they are probably willing
|他们可能愿意花几个月的时间试图窃取这个秘密，

362
00:10:56,480 --> 00:10:57,680
0,90 90,510 510,780 780,1110 1110,1200
to spend a couple of

363
00:10:57,680 --> 00:10:59,420
0,810 960,1200 1200,1260 1260,1530 1530,1740
months trying to steal that

364
00:10:59,420 --> 00:11:00,440
0,570
secret,|
|

365
00:11:00,590 --> 00:11:03,080
0,420 420,630 630,1170 1500,1890 2280,2490
{} or longer, right,| because
或者更长时间，|因为这可能是某人的密码，

366
00:11:03,080 --> 00:11:03,620
0,90 90,180 180,300 300,450 450,540
you know it's gonna be

367
00:11:03,620 --> 00:11:05,450
0,390 390,1020 1020,1380 1380,1740 1740,1830
somebody's password,| that protects all
|它保护各种有价值的东西，

368
00:11:05,450 --> 00:11:06,530
0,210 210,270 270,600 600,870 870,1080
kinds of valuable stuff,| maybe
|可能是钱或秘密电子邮件。

369
00:11:06,530 --> 00:11:09,520
0,510 510,810 1470,1950 1950,2460
money or secret email.|
|

370
00:11:09,640 --> 00:11:11,350
0,390 570,990 1020,1380 1380,1590 1590,1710
{} So that means for
所以，这意味着攻击者可能有时间

371
00:11:11,350 --> 00:11:12,730
0,420 420,540 540,930 930,1200 1200,1380
example the attacker probably has

372
00:11:12,730 --> 00:11:14,440
0,240 240,300 300,810 840,1350 1350,1710
time| to try every single
|尝试每一个内核地址，

373
00:11:14,440 --> 00:11:16,340
0,390 390,1050
kernel address,

374
00:11:16,400 --> 00:11:18,320
0,420 450,870 870,1110 1110,1530 1530,1920
right,| looking for whatever precious
|在那里寻找任何珍贵的数据，

375
00:11:18,320 --> 00:11:20,660
0,330 330,1230 1320,1560 1560,1560 1560,2340
data {there,after},| maybe a password,|
|可能是密码，|

376
00:11:20,870 --> 00:11:22,400
0,450 480,750 750,1110 1110,1230 1230,1530
or the attacker may have
或者攻击者可能有时间学习查看内核代码，

377
00:11:22,400 --> 00:11:24,020
0,300 300,510 540,1140 1140,1230 1230,1620
time to study to look

378
00:11:24,020 --> 00:11:25,100
0,120 120,210 210,570 570,930 930,1080
through the kernel code| and
|查看典型的编译内核并查找地址，

379
00:11:25,100 --> 00:11:27,230
0,210 210,690 720,1110 1110,1590 1590,2130
look through typical compiled kernels

380
00:11:27,230 --> 00:11:28,970
0,210 360,810 810,1410 1410,1500 1500,1740
and find addresses| and maybe
|可以在他们的内核中放打印语句，

381
00:11:28,970 --> 00:11:30,170
0,240 240,450 450,900 900,990 990,1200
put print statements in their

382
00:11:30,170 --> 00:11:32,630
0,750 750,1050 1260,1920 1920,2010 2010,2460
kernel| to examine the structure
|检查内核内存中的数据结构，

383
00:11:32,630 --> 00:11:33,770
0,90 90,360 360,510 510,780 780,1140
of data in kernel memory,|
|

384
00:11:33,770 --> 00:11:35,090
0,210 210,330 330,1110 1110,1200 1200,1320
until they understand how the
直到他们了解内核是如何工作的，

385
00:11:35,090 --> 00:11:37,790
0,270 270,780 1440,1770 1770,2280 2280,2700
kernel works,| well enough to
|才能在这里找到这里的地址。

386
00:11:38,300 --> 00:11:39,260
0,480 480,660 660,750 750,870 870,960
be able to get an

387
00:11:39,260 --> 00:11:41,040
0,360 360,690 840,1350
address here.| Now,
|因为这个游戏一直在进行，

388
00:11:41,260 --> 00:11:43,180
0,540 750,1170 1170,1380 1380,1800 1800,1920
actually, because this game has

389
00:11:43,180 --> 00:11:44,710
0,150 150,420 420,720 750,1170 1170,1530
been going on,| other versions
|这个游戏的其他版本，

390
00:11:44,710 --> 00:11:46,540
0,90 90,270 270,900 1290,1440 1440,1830
of this game,| the security
|安全游戏已经进行了很长一段时间了，

391
00:11:46,540 --> 00:11:47,320
0,210 210,330 330,450 450,690 690,780
game had been going out

392
00:11:47,320 --> 00:11:48,580
0,60 60,120 120,330 330,750 810,1260
for a long time,| kernels
|内核会防御这些攻击，

393
00:11:48,580 --> 00:11:52,260
0,240 240,630 630,1500 2070,3210
actually defend themselves against

394
00:11:52,380 --> 00:11:54,960
0,630 630,780 780,1740 1770,2220 2220,2580
attacks| that involve guessing kernel
|涉及猜测内核地址的攻击，

395
00:11:54,960 --> 00:11:57,420
0,840 960,1440 1740,2310 2310,2370 2370,2460
addresses,| and one of the
|这篇论文实际上提到的一件事是，

396
00:11:57,420 --> 00:11:58,860
0,540 570,750 750,870 870,1080 1080,1440
things that was actually mentioned

397
00:11:58,860 --> 00:12:00,060
0,180 180,540 540,630 630,810 810,1200
this paper is| this called
|这称为内核地址空间布局随机化，

398
00:12:00,060 --> 00:12:03,390
0,180 180,720 1200,1560 1680,2730 2730,3330
thing called {} kernel address

399
00:12:03,390 --> 00:12:06,810
0,1260 1290,2040 2070,2970 2970,3120 3120,3420
space layout randomization,| so modern
|所以现代内核加载内核到随机地址，

400
00:12:06,810 --> 00:12:08,670
0,390 390,840 930,1470 1470,1560 1560,1860
kernels actually load the kernel

401
00:12:08,670 --> 00:12:10,470
0,90 90,150 150,450 450,1050 1470,1800
at a random address,| in
|为了使猜测内核虚拟地址变得更加困难，

402
00:12:10,470 --> 00:12:11,670
0,180 180,270 270,450 450,540 540,1200
order to make it harder

403
00:12:11,820 --> 00:12:13,000
0,120 120,810
to guess

404
00:12:14,440 --> 00:12:16,150
0,780 780,1080 1080,1530 1530,1620 1620,1710
kernel virtual addresses,| and they
|早在这篇论文发表之前，他们就这样做了，

405
00:12:16,150 --> 00:12:17,650
0,150 150,300 300,690 690,1170 1260,1500
did this before this, long

406
00:12:17,650 --> 00:12:19,150
0,270 270,660 690,990 990,1230 1230,1500
before this paper came out,|
|

407
00:12:19,420 --> 00:12:20,800
0,420 420,510 510,630 630,1110 1110,1380
because it was helpful in
因为它有助于防止其他攻击。

408
00:12:20,830 --> 00:12:22,700
0,420 420,630 630,1350
defeating other attacks.|
|

409
00:12:22,700 --> 00:12:24,380
0,240 270,510 510,960 1110,1590 1590,1680
{} So, so this is
所以，这就是游戏，

410
00:12:24,380 --> 00:12:25,700
0,60 60,510 510,750
the game,| but
|但是我们必须假设攻击者，

411
00:12:26,370 --> 00:12:27,560
0,390
{}

412
00:12:27,560 --> 00:12:28,430
0,180 180,300 300,390 390,690 690,870
we have to assume that

413
00:12:28,430 --> 00:12:30,470
0,510 600,1380 1410,1770 1770,1890 1890,2040
the attacker,| in the end,
|最终，攻击者可能会赢得这个游戏。

414
00:12:30,470 --> 00:12:32,000
0,90 90,570 570,780
the attacker will

415
00:12:32,000 --> 00:12:33,940
0,420 420,600 600,780 780,1260
probably win this game.|
|

416
00:12:34,640 --> 00:12:35,990
0,420 480,660 660,780 780,930 930,1350
Okay, so let's just assume
好吧，我们假设攻击者知道一个内核虚拟地址，

417
00:12:35,990 --> 00:12:38,360
0,90 90,780 1320,1770 1770,2010 2010,2370
the attacker {} either knows

418
00:12:38,360 --> 00:12:39,680
0,90 90,510 510,810 810,1080 1080,1320
a [] kernel virtual address

419
00:12:39,680 --> 00:12:40,670
0,90 90,330 330,660 660,810 810,990
to look at| or can
|或者猜到一个，或者愿意穷尽每一个地址。

420
00:12:40,670 --> 00:12:41,900
0,240 240,630 630,810 810,930 930,1230
guess one or is willing

421
00:12:41,900 --> 00:12:43,130
0,120 120,660 660,750 750,990 990,1230
to {exhaustively -} try every

422
00:12:43,130 --> 00:12:44,280
0,720
address.|
|

423
00:12:44,280 --> 00:12:45,660
0,420 420,510 510,750 750,1260 1260,1380
And the paper suggests that
这篇论文认为这是一个看似合理的策略，

424
00:12:45,660 --> 00:12:48,600
0,240 240,450 600,1290 1500,2310 2580,2940
that's a plausible strategy,| once
|一旦有了 meltdown 。

425
00:12:48,600 --> 00:12:49,860
0,90 90,180 180,690
you have meltdown.|
|

426
00:12:51,810 --> 00:12:52,900
0,660
Okay.|
好的。|

427
00:12:53,930 --> 00:12:55,340
0,300 300,450 450,630 630,780 780,1410
Okay, so what's gonna happen,|
好的，接下来会发生什么，|

428
00:12:55,460 --> 00:12:57,100
0,360
well,
所以我们想知道这段代码怎么会，

429
00:12:57,100 --> 00:12:57,970
0,180 180,300 300,600 600,750 750,870
so we're wondering how can

430
00:12:57,970 --> 00:12:59,650
0,120 120,360 360,570 750,1200 1230,1680
this code be,| {} possibly
|可能被攻击者利用，

431
00:12:59,650 --> 00:13:01,300
0,270 270,780 780,930 930,1020 1020,1650
be useful to an attacker,|
|

432
00:13:01,360 --> 00:13:02,890
0,360 390,870 870,1170 1170,1440 1440,1530
and the answer has to
答案是，

433
00:13:02,890 --> 00:13:04,750
0,450 540,1020 1080,1560 1560,1680 1680,1860
do,| like if the way
|如果 CPU 的工作方式和你在 CPU 手册上看到的一样，

434
00:13:04,750 --> 00:13:06,160
0,480 480,570 570,870 870,1110 1110,1410
{CPU's -} work was just

435
00:13:06,160 --> 00:13:07,660
0,150 150,300 300,900 1200,1410 1410,1500
what you read in the

436
00:13:07,660 --> 00:13:09,790
0,450 450,1080 1170,1410 1410,1740 1740,2130
CPU manual,| this attack clearly
|这个攻击当然是没有意义的，

437
00:13:09,790 --> 00:13:11,740
0,120 120,990 1020,1290 1290,1440 1440,1950
is nonsense,| like it'll fault
|比如它会在指令 3 失败，

438
00:13:11,830 --> 00:13:13,870
0,300 450,1020 1020,1560 1590,1860 1860,2040
at instruction 3| and that'll
|并且结束，

439
00:13:13,870 --> 00:13:14,440
0,90 90,210 210,360 360,450 450,570
be the end of it,|
|

440
00:13:14,590 --> 00:13:15,700
0,180 180,240 240,480 480,570 570,1110
but it turns out {CPU's
但事实证明， CPU 的工作方式比手册中的复杂得多，

441
00:13:15,700 --> 00:13:16,500
0,270
-}

442
00:13:16,980 --> 00:13:18,990
0,540 540,810 810,960 960,1470 1470,2010
{work,in} far more complex ways

443
00:13:18,990 --> 00:13:20,340
0,150 150,540 540,660 660,750 750,1350
than is in the manual,|
|

444
00:13:20,490 --> 00:13:23,790
0,630 1200,1890 2280,2760 2940,3120 3120,3300
{} and {} the way
这个攻击方式成功的原因是，

445
00:13:23,790 --> 00:13:24,870
0,90 90,360 360,450 450,780 780,1080
the reason the attack works

446
00:13:24,870 --> 00:13:26,490
0,90 90,480 480,600 600,990 990,1620
is| because of some CPU
|因为一些 CPU 的实现细节。

447
00:13:26,700 --> 00:13:30,260
0,1110 1170,2100
implementation details.|
|

448
00:13:30,350 --> 00:13:32,060
0,210 210,750 750,1020 1200,1410 1410,1710
And there's actually two main
实际上，攻击依赖于两个主要的东西，

449
00:13:32,060 --> 00:13:33,260
0,330 330,450 450,540 540,870 870,1200
things that the attack relies

450
00:13:33,260 --> 00:13:35,540
0,150 150,420 420,840 870,1410 1470,2280
on,| one is {} implementation
|一种是 CPU 称为预测执行的实现技巧，

451
00:13:35,540 --> 00:13:36,650
0,210 210,300 300,720 720,840 840,1110
trick of {CPU's -} called

452
00:13:36,650 --> 00:13:38,750
0,540 540,1260 1530,1860 1860,1920 1920,2100
speculative execution,| which I'll talk
|我将首先谈到这一点，

453
00:13:38,750 --> 00:13:40,820
0,240 240,690 870,1380 1380,1530 1530,2070
about first,| and the other
|另一个攻击所依赖的实现技巧是 CPU 进行缓存的方式。

454
00:13:41,030 --> 00:13:43,760
0,900 900,1350 1350,1650 2040,2370 2370,2730
implementation trick the attack relies

455
00:13:43,760 --> 00:13:44,840
0,210 210,360 360,450 450,690 690,1080
on is {the -} way

456
00:13:44,840 --> 00:13:46,140
0,60 60,210 210,780
CPU's do caching.|
|

457
00:13:46,170 --> 00:13:48,300
0,420

458
00:13:48,330 --> 00:13:49,500
0,720
Okay.|
好的。|

459
00:13:49,620 --> 00:13:52,920
0,300 300,570 570,990 990,1680
So first speculative execution,|
所以首先是预测执行，|

460
00:13:52,920 --> 00:13:55,350
0,450 450,720 720,1170 1530,2340 2340,2430
let me, I have a
我也有一个代码示例，

461
00:13:55,350 --> 00:13:56,700
0,240 240,600 600,720 720,930 930,1350
code example for that also,|
|

462
00:13:57,120 --> 00:13:58,710
0,480 810,990 990,1260 1260,1350 1350,1590
{} and for the moment
现在我说的不是安全问题，

463
00:13:58,710 --> 00:13:59,820
0,90 90,240 240,480 480,630 630,1110
I'm not talking about security

464
00:13:59,820 --> 00:14:00,960
0,90 90,570
at all,|
|

465
00:14:01,220 --> 00:14:02,660
0,120 120,570 570,1020 1020,1140 1140,1440
the speculative execution this stuff
预测执行只是一种提高 CPU 性能的技术，

466
00:14:02,660 --> 00:14:04,700
0,240 660,1320 1320,1410 1410,1950 1950,2040
is just a technique to

467
00:14:04,700 --> 00:14:06,530
0,360 360,450 450,1050 1050,1350 1500,1830
improve the performance of {}

468
00:14:06,530 --> 00:14:09,560
0,540 540,990 1770,1980 1980,2730 2730,3030
{CPUs -},| some optimization trick
|一种 CPU 使用的优化技巧，

469
00:14:09,560 --> 00:14:11,600
0,150 150,540 540,660 660,1110 1650,2040
that {CPUs -} use,| so
|想象一下，我们正在运行这段代码，

470
00:14:12,410 --> 00:14:14,840
0,450 450,1200 1500,1800 1800,2100 2100,2430
imagine that we're just, we

471
00:14:14,840 --> 00:14:15,640
0,390
have,

472
00:14:15,820 --> 00:14:17,050
0,150 150,210 210,480 480,600 600,1230
which is running this code,|
|

473
00:14:17,320 --> 00:14:18,970
0,660 690,900 900,1020 1020,1260 1260,1650
{} this is somewhat contrived
这是一个有点人为的例子，

474
00:14:18,970 --> 00:14:20,290
0,390 390,510 510,870 900,1140 1140,1320
example,| but it's sort of
|但在某种程度上说明了预测执行的意义，

475
00:14:20,410 --> 00:14:23,320
0,930 1290,1650 1650,2190 2190,2760 2760,2910
illustrates what speculative execution is

476
00:14:23,320 --> 00:14:27,130
0,150 150,600 1800,2130 2130,2460 2460,3810
all about,| supposing {I,have} address
|假设我在寄存器 0 中有个地址，

477
00:14:27,130 --> 00:14:29,200
0,120 120,570 720,1110 1110,1530 1530,2070
in some say register zero,|
|

478
00:14:29,320 --> 00:14:30,880
0,510 540,810 810,1050 1050,1200 1200,1560
and just because the logic
因为我程序的逻辑，

479
00:14:30,880 --> 00:14:32,470
0,120 120,630 630,750 750,1410 1410,1590
my program,| the address is
|地址要么有效要么无效，

480
00:14:32,470 --> 00:14:33,640
0,240 240,600 600,660 660,870 870,1170
either valid or not valid,|
|

481
00:14:33,640 --> 00:14:35,350
0,180 180,270 270,690 690,1290 1290,1710
maybe it contains zero if
在某些情况下，它可能包含 0 ，

482
00:14:35,350 --> 00:14:36,640
0,180 180,360 360,1080 1080,1200 1200,1290
under some circumstances,| like we
|比如我们还没有初始化我的数据。

483
00:14:36,640 --> 00:14:38,960
0,240 240,1290
haven't initialize

484
00:14:39,050 --> 00:14:40,640
0,390 390,660 660,870 900,1110 1110,1590
my data yet.| So this
|所以这假设在内存中的某个地方有一个 valid 变量，

485
00:14:40,670 --> 00:14:42,290
0,300 300,570 570,780 780,1110 1110,1620
will assume there's a valid

486
00:14:42,290 --> 00:14:43,580
0,420 420,600 600,870 870,960 960,1290
variable that's sitting in memory

487
00:14:43,580 --> 00:14:46,550
0,600 1080,1590 1680,1950 1950,2370 2370,2970
somewhere,| {} so before using
|所以在使用这个地址之前，

488
00:14:46,550 --> 00:14:48,140
0,150 150,510 510,1080
the address here,|
|

489
00:14:48,230 --> 00:14:49,850
0,180 180,390 390,720 720,1020 1230,1620
so this address in register
在第 4 行中的寄存器 0 中的地址，

490
00:14:49,850 --> 00:14:50,780
0,270 270,450 450,540 540,720 720,930
zero here on line 4,|
|

491
00:14:50,780 --> 00:14:51,770
0,60 60,180 180,240 240,810 840,990
we're going to test,| we're
我们要测试，|我们要从内存中加载 valid ，

492
00:14:51,770 --> 00:14:53,090
0,120 120,420 420,780 780,900 900,1320
gonna load valid from memory,|
|

493
00:14:53,090 --> 00:14:54,020
0,180 270,570 570,720 720,870 870,930
and we're only going to
如果 valid 为 1 ，我们将使用这个地址，

494
00:14:54,020 --> 00:14:56,300
0,450 450,660 660,1200 1200,1590 1650,2280
use the address if valid

495
00:14:56,300 --> 00:14:57,650
0,90 90,330 330,390 390,780 1200,1350
is set to 1,| then
|如果 valid 为 0 ，我们将看不到地址，

496
00:14:57,650 --> 00:14:58,310
0,30 30,330 330,420 420,600 600,660
if valid is set to

497
00:14:58,310 --> 00:14:59,570
0,360 360,540 540,840 930,1140 1140,1260
0, we are not going

498
00:14:59,570 --> 00:15:00,170
0,60 60,210 210,270 270,510 510,600
to see {address -} at

499
00:15:00,170 --> 00:15:01,460
0,240 450,840 840,960 960,1230 1230,1290
all,| and if valid is
|如果 valid 为 1 ，那么我们将间接引用这个地址，

500
00:15:01,460 --> 00:15:02,060
0,150 150,210 210,420 420,510 510,600
set to one, then we're

501
00:15:02,060 --> 00:15:03,020
0,120 120,210 210,420 420,840 840,960
going to {dereference -} the

502
00:15:03,020 --> 00:15:04,910
0,810 870,1110 1110,1470 1470,1560 1560,1890
address,| {you,know} load the data
|把它指向的数据加载到寄存器 2 ，

503
00:15:04,910 --> 00:15:06,380
0,360 360,540 540,660 660,1080 1080,1470
{it,points} to at register 2,|
|

504
00:15:06,530 --> 00:15:07,580
0,270 270,450 450,660 660,810 810,1050
and add one to it
然后加一，这没什么关系，

505
00:15:07,580 --> 00:15:08,570
0,120 120,210 210,420 420,600 600,990
and it doesn't really matter,|
|

506
00:15:08,600 --> 00:15:09,440
0,120 120,240 240,300 300,450 450,840
we're going to do something
我们要用加载的数据做点什么，

507
00:15:09,440 --> 00:15:10,460
0,120 120,270 270,480 480,600 600,1020
with that data we loaded,|
|

508
00:15:10,610 --> 00:15:11,750
0,180 180,480 480,750 750,960 960,1140
in this case, add one
在这种情况下，对它加 1 ，

509
00:15:11,750 --> 00:15:14,120
0,150 150,270 270,480 1350,1740 1800,2370
to it| and set register
|并将寄存器 3 设置为那个数据加 1 。

510
00:15:14,120 --> 00:15:15,540
0,270 270,540 540,690 690,960
3 equal to the

511
00:15:15,630 --> 00:15:17,440
0,300 360,750 750,930 930,1170
{} data plus one.|
|

512
00:15:17,800 --> 00:15:20,340
0,360 360,630 1380,1890
Alright, well, {}
好的，在一个简单的 CPU 实现中，

513
00:15:20,550 --> 00:15:23,010
0,210 210,480 480,1110 1110,1620 1620,2460
in a simple CPU implementation,|
|

514
00:15:24,370 --> 00:15:26,320
0,300 300,600 600,840 840,1320
at line 2 here,
在第 2 行中，你可以加载，

515
00:15:26,460 --> 00:15:28,380
0,360 360,570 570,690 690,1320
{} you can load,|
|

516
00:15:28,380 --> 00:15:29,940
0,240 240,690 690,810 810,1260 1260,1560
the {valid,is} a variable sitting
valid 是一个位于内存中的变量，

517
00:15:29,940 --> 00:15:32,820
0,90 90,450 450,540 540,1050 2130,2880
in memory in RAM,| and
|你必须发布一些，

518
00:15:32,820 --> 00:15:33,900
0,240 360,570 570,660 660,900 900,1080
you have to issue some

519
00:15:33,900 --> 00:15:34,470
0,180 180,240 240,360 360,450 450,570
kind of,| this is going
|这个会，

520
00:15:34,470 --> 00:15:35,130
0,60 60,270 270,450 450,570 570,660
to be,| line 2 is
|第 2 行会使用 load 指令从内存中读取 valid ，

521
00:15:35,130 --> 00:15:35,670
0,120 120,180 180,270 270,390 390,540
going to be some sort

522
00:15:35,670 --> 00:15:37,380
0,90 90,360 360,900 900,1080 1080,1710
of load instruction that reads

523
00:15:37,410 --> 00:15:39,540
0,420 420,540 540,600 600,1140 1920,2130
valid out of RAM,| or
|或者相等，如果我们必须从内存中加载它，

524
00:15:39,540 --> 00:15:40,530
0,210 210,360 360,690 690,870 870,990
else being equal if we

525
00:15:40,530 --> 00:15:41,220
0,210 210,300 300,420 420,600 600,690
actually have to load it

526
00:15:41,220 --> 00:15:42,440
0,150 150,570
from RAM,|
|

527
00:15:42,500 --> 00:15:44,810
0,270 270,630 660,1290 1290,1380 1380,2310
that'll take hundreds of cycles
那需要数百次循环，在我们的 2GHz 机器上，

528
00:15:44,960 --> 00:15:46,640
0,240 240,540 540,810 810,1410 1410,1680
on our say two {GHz

529
00:15:46,640 --> 00:15:48,160
0,300 300,1020
-} machine,|
|

530
00:15:48,370 --> 00:15:50,110
0,690 720,990 990,1290 1290,1470 1470,1740
like any load that actually
任何从内存加载需要数百次循环，

531
00:15:50,110 --> 00:15:51,040
0,270 270,360 360,450 450,570 570,930
has to go to RAM

532
00:15:51,040 --> 00:15:52,240
0,90 90,270 270,570 570,630 630,1200
will take hundreds of cycles,|
|

533
00:15:52,300 --> 00:15:53,980
0,180 180,750 810,1230 1230,1620 1620,1680
the machine can execute an
机器可以执行一条指令，

534
00:15:53,980 --> 00:15:55,420
0,870
instruction,|
|

535
00:15:55,420 --> 00:15:56,650
0,240 240,510 510,690 690,780 780,1230
{} up to an instruction
每个周期最多执行一条指令，

536
00:15:56,650 --> 00:15:58,210
0,180 180,600 600,930 1110,1440 1440,1560
every cycle,| so if we
|所以如果我们要在这里等待几百个周期，

537
00:15:58,210 --> 00:15:58,960
0,240 240,360 360,480 480,720 720,750
actually had to wait a

538
00:15:58,960 --> 00:16:01,240
0,270 270,360 360,720 1410,1950 1950,2280
couple of hundred cycles here,|
|

539
00:16:01,480 --> 00:16:02,500
0,330 330,480 480,630 630,930 930,1020
we'd be the machine to
机器会在这里闲置数百个周期，

540
00:16:02,500 --> 00:16:03,760
0,90 90,330 330,600 600,1140 1140,1260
be sitting there idling for

541
00:16:03,760 --> 00:16:05,920
0,840 870,1350 1350,1410 1410,2040 2040,2160
hundreds hundreds of cycles,| {sort,of}
|浪费时间。

542
00:16:05,920 --> 00:16:07,320
0,360 360,480 480,900
wasting its time.|
|

543
00:16:07,440 --> 00:16:09,390
0,420 810,1350 1350,1680 1680,1890 1890,1950
{} And because that's a
因为这是一个显著的减速，

544
00:16:09,390 --> 00:16:12,240
0,780 780,1290 1290,2070 2160,2490 2670,2850
significant significant slowdown, right,| if
|如果一切顺利，

545
00:16:12,240 --> 00:16:13,290
0,480 480,630 630,840 840,990 990,1050
everything went well,| we'd be
|我们能够在每个周期执行一条指令，

546
00:16:13,290 --> 00:16:15,150
0,150 150,540 960,1350 1350,1410 1410,1860
able to execute an instruction

547
00:16:15,150 --> 00:16:16,290
0,180 180,600 600,840 840,930 930,1140
every cycle,| instead of every
|而不是每几百个周期执行一次。

548
00:16:16,290 --> 00:16:19,560
0,240 240,540 540,1140
couple hundred cycles.|
|

549
00:16:20,000 --> 00:16:21,740
0,330 330,570 570,1020 1020,1230 1230,1740
{} All modern, all serious
所有现代的 CPU 都使用一种叫做分支预测的东西，

550
00:16:21,740 --> 00:16:23,300
0,330 330,690 690,1050 1050,1350 1350,1560
modern {CPUs -} do use

551
00:16:23,300 --> 00:16:24,980
0,210 210,390 390,690 690,1230 1320,1680
something called branch prediction,| so
|这个 if 语句是一个分支，

552
00:16:25,010 --> 00:16:26,000
0,270 270,420 420,840 840,900 900,990
this if statement is a

553
00:16:26,000 --> 00:16:28,400
0,780 1530,1740 1740,1890 1890,2160 2160,2400
branch,| if we actually turned
|如果我们把它变成机器指令，

554
00:16:28,400 --> 00:16:29,810
0,120 120,390 390,750 750,1290 1290,1410
it into machine instructions,| we
|我们看到这里是一个分支，

555
00:16:29,810 --> 00:16:30,710
0,210 210,330 330,450 450,510 510,900
see there was a branch

556
00:16:30,710 --> 00:16:32,180
0,390 570,810 810,930 930,990 990,1470
here,| and it's a conditional
|这是一个条件分支，

557
00:16:32,180 --> 00:16:34,010
0,510 510,840 840,1140 1140,1350 1350,1830
branch,| branch based on this
|分支基于这个寄存器 1 是否等于 1 的测试，

558
00:16:34,220 --> 00:16:36,230
0,840 840,1230 1230,1650 1650,1860 1860,2010
test whether register 1 is

559
00:16:36,230 --> 00:16:37,610
0,210 210,270 270,690 990,1230 1230,1380
equal to 1,| and what
|而 CPU 所做的是，

560
00:16:37,610 --> 00:16:38,840
0,420 420,510 510,780 780,1110 1110,1230
{CPUs -} do is,| they
|它们使用叫做分支预测的东西，

561
00:16:38,840 --> 00:16:39,620
0,240
use

562
00:16:39,620 --> 00:16:41,240
0,120 120,270 270,630 630,1050 1050,1620
what's called branch branch prediction,|
|

563
00:16:41,660 --> 00:16:43,280
0,240 240,360 360,660 660,870 870,1620
that is for every branch,|
也就是说，对于每个分支，|

564
00:16:43,310 --> 00:16:45,410
0,480 810,1380 1380,1440 1440,1860 1860,2100
{} more or less the
CPU 都会记住信息的缓存，

565
00:16:45,650 --> 00:16:47,810
0,870 900,1350 1350,1710 1710,1770 1770,2160
CPU essentially remembers a cache

566
00:16:47,810 --> 00:16:49,010
0,120 120,690 690,990 990,1140 1140,1200
of information| about each of
|关于程序中的每个分支，

567
00:16:49,010 --> 00:16:51,290
0,90 90,930 1110,1350 1350,1620 1650,2280
the branches in your program,|
|

568
00:16:51,350 --> 00:16:52,640
0,210 210,420 420,690 690,930 930,1290
or at least each recently
或者至少每个最近执行的分支，

569
00:16:52,640 --> 00:16:54,710
0,480 480,960 1170,1530 1530,1950 1950,2070
executed branch,| then remembers oh
|然后记起，那个分支是[拿了]还是没拿，

570
00:16:54,710 --> 00:16:56,090
0,150 150,330 330,1110 1110,1260 1260,1380
did that branch was the

571
00:16:56,090 --> 00:16:57,380
0,270 270,600 600,660 660,900 900,1290
branch taken or not taken,|
|

572
00:16:58,010 --> 00:16:59,990
0,480 540,870 870,1050 1050,1530 1650,1980
and if the CPU doesn't
如果 CPU 没有足够的信息来预测，

573
00:16:59,990 --> 00:17:01,500
0,120 120,330 330,1170
have enough information

574
00:17:01,920 --> 00:17:04,230
0,660 870,1020 1020,1740 1800,2100 2100,2310
{} to predict,| so that's
|这基于你上次执行分支的预测，

575
00:17:04,230 --> 00:17:05,250
0,420 420,660 660,720 720,780 780,1020
prediction based on the last

576
00:17:05,250 --> 00:17:06,390
0,120 120,240 240,660 660,720 720,1140
time you executed the branch,|
|

577
00:17:06,600 --> 00:17:08,520
0,480 480,600 600,870 1140,1530 1530,1920
even if the CPU doesn't
即使 CPU 没有预测，

578
00:17:08,520 --> 00:17:09,780
0,150 150,210 210,750 870,1110 1110,1260
have a prediction,| it may
|它仍然可以继续执行指令，

579
00:17:09,780 --> 00:17:11,340
0,420 450,780 840,1140 1140,1380 1380,1560
still just go ahead and

580
00:17:11,340 --> 00:17:12,500
0,750
execute

581
00:17:12,500 --> 00:17:15,200
0,90 90,1140 2130,2460 2460,2640 2640,2700
the instructions,| either that the
|无论是你去的分支，

582
00:17:15,200 --> 00:17:16,430
0,330 330,630 630,780 780,1080 1080,1230
branch takes you to| or
|或没有去的指令，假设分支没有选择，

583
00:17:16,430 --> 00:17:18,620
0,120 120,810 810,990 990,1800 1830,2190
the fail to instructions, assuming

584
00:17:18,620 --> 00:17:19,790
0,60 60,330 330,600 600,900 960,1170
the branch wasn't taken,| that
|甚至在 CPU 知道条件是否为真之前，

585
00:17:19,790 --> 00:17:21,240
0,510
is,

586
00:17:21,240 --> 00:17:23,580
0,330 330,690 690,780 780,1290 1290,2340
even before the CPU knows

587
00:17:23,610 --> 00:17:25,530
0,480 480,660 660,1200 1200,1320 1320,1920
whether this conditional is true,|
|

588
00:17:25,890 --> 00:17:27,630
0,600 600,1140 1140,1440 1440,1620 1620,1740
it'll choose one way or
它会选择一种或另一种方式，并开始沿着这条路径执行，

589
00:17:27,630 --> 00:17:29,160
0,150 150,480 480,600 600,990 990,1530
the other and start executing

590
00:17:29,160 --> 00:17:30,900
0,240 240,450 450,1140 1320,1620 1620,1740
down that path,| even though
|尽管这可能是条错误的路径，还不知道。

591
00:17:30,900 --> 00:17:31,650
0,90 90,270 270,360 360,480 480,750
it might be the wrong

592
00:17:31,650 --> 00:17:32,840
0,780
path,

593
00:17:32,840 --> 00:17:34,140
0,240 240,420 420,840
doesn't know yet.|
|

594
00:17:34,320 --> 00:17:35,400
0,210 210,330 330,390 390,570 570,1080
And so in this case,|
所以在这种情况下，|

595
00:17:35,580 --> 00:17:37,380
0,360 360,810 810,1020 1020,1290 1290,1800
maybe before this load completes,|
也许在这个加载完成之前，|

596
00:17:37,380 --> 00:17:38,790
0,90 90,450 450,780 870,1110 1110,1410
and before {} the value
在知道 valid 的值之前，

597
00:17:38,790 --> 00:17:40,230
0,90 90,450 450,570 570,990 1230,1440
of valid is known,| the
|CPU 已经开始执行指令 4 ，

598
00:17:40,230 --> 00:17:43,170
0,420 420,600 600,1080 1110,2010 2370,2940
CPU may start executing instruction

599
00:17:43,170 --> 00:17:45,150
0,630 1080,1260 1260,1380 1380,1500 1500,1980
4| and do the load
|并加载 r0 中的值，

600
00:17:45,150 --> 00:17:46,920
0,120 120,870 1020,1440 1440,1530 1530,1770
with whatever value is sitting

601
00:17:46,920 --> 00:17:48,390
0,120 120,270 270,870 960,1320 1320,1470
in {r0 -},| which may
|它可能是也可能不是有效的指针，

602
00:17:48,390 --> 00:17:48,930
0,90 90,180 180,390 390,480 480,540
or may not be a

603
00:17:48,930 --> 00:17:51,150
0,300 300,750 1170,1650 1770,2010 2010,2220
valid pointer| {} and once
|一旦加载产生了一些结果，

604
00:17:51,150 --> 00:17:53,070
0,210 210,450 450,750 750,1350 1500,1920
that load yields something,| maybe
|甚至可以加 1 ，

605
00:17:53,070 --> 00:17:54,180
0,360 360,570 570,780 780,960 960,1110
even add one to it|
|

606
00:17:54,180 --> 00:17:55,590
0,120 120,390 420,870 870,1170 1170,1410
and set register 3 equal
并将寄存器 3 设置为那个值。

607
00:17:55,590 --> 00:17:56,640
0,60 60,270 270,630
to that value.|
|

608
00:17:56,840 --> 00:17:58,430
0,240 240,600 960,1260 1260,1320 1320,1590
And then maybe a long
也许在很久之后，

609
00:17:58,430 --> 00:17:59,990
0,240 240,600 600,960 960,1170 1170,1560
time later,| when this load
|当第 2 行的加载最终完成时，

610
00:18:00,170 --> 00:18:02,360
0,180 180,420 420,600 600,1140 1140,2190
at line 2 finally completes,|
|

611
00:18:02,750 --> 00:18:04,400
0,480 630,1050 1050,1140 1140,1440 1440,1650
{} now we know what
现在我们知道 valid 的值是什么，

612
00:18:04,400 --> 00:18:06,320
0,300 540,930 930,1050 1050,1500 1500,1920
the value of valid is,|
|

613
00:18:06,590 --> 00:18:08,570
0,240 240,720 720,930 930,1260 1650,1980
the CPU will then, this
CPU 会，这个真的，

614
00:18:08,570 --> 00:18:10,010
0,420 450,600 600,840 960,1140 1140,1440
real,| you know you know
|它跟踪了这样一个事实，

615
00:18:10,010 --> 00:18:10,910
0,150 150,450 450,750 750,810 810,900
it kept track of the

616
00:18:10,910 --> 00:18:13,310
0,270 270,390 390,570 780,1620 1920,2400
fact,| that it executed lines
|它执行第 4 行和第 5 行，

617
00:18:13,310 --> 00:18:14,750
0,240 240,360 360,630 630,1080 1080,1440
4 and 5| without really
|但并不知道这样做是否合适，

618
00:18:14,750 --> 00:18:16,310
0,390 390,630 630,780 780,960 960,1560
knowing whether that was proper,|
|

619
00:18:17,060 --> 00:18:18,800
0,390 390,720 720,870 870,1380 1470,1740
if valid is 1, then
如果 valid 是 1 ，那没问题，继续运行，

620
00:18:18,800 --> 00:18:19,850
0,210 210,510 510,630 630,810 810,1050
that's fine, it just keeps

621
00:18:19,850 --> 00:18:21,740
0,420 450,840 840,1140 1140,1260 1260,1890
going,| if valid is 0,
|如果 valid 为 0 ， CPU 足够聪明

622
00:18:21,890 --> 00:18:23,330
0,270 270,330 330,990 990,1200 1200,1440
then the CPU has enough

623
00:18:23,330 --> 00:18:25,700
0,480 480,600 600,1320 1320,1440 1440,2370
cleverness| to cancel the effects
|来取消它执行第 4 行和第 5 行的结果，

624
00:18:26,480 --> 00:18:27,680
0,150 150,270 270,810 810,900 900,1200
of its execution of line

625
00:18:27,680 --> 00:18:29,630
0,240 240,390 390,1020 1080,1380 1380,1950
4 and 5,| and restart
|并在第 7 行的分支之后的适当位置重新开始执行。

626
00:18:29,630 --> 00:18:31,340
0,810 810,930 930,1020 1020,1410 1410,1710
execution in the proper place

627
00:18:31,340 --> 00:18:32,780
0,270 270,360 360,870 930,1170 1170,1440
after the branch at line

628
00:18:32,780 --> 00:18:33,780
0,360
7.|
|

629
00:18:34,260 --> 00:18:35,820
0,240 240,510 510,1110 1110,1200 1200,1560
And this execution of code
这种在你知道之前执行代码，

630
00:18:35,820 --> 00:18:37,110
0,480 480,630 630,870 870,1140 1140,1290
before you know| whether you
|你是否应该执行代码之前，被称为推测，

631
00:18:37,110 --> 00:18:38,580
0,300 300,600 600,720 720,1290 1290,1470
really should be executing it

632
00:18:39,060 --> 00:18:41,040
0,300 300,600 600,1380
is called speculation,|
|

633
00:18:46,700 --> 00:18:48,200
0,570 720,1080 1080,1170 1170,1410 1410,1500
and again, the point is
再说一次，重点是性能，

634
00:18:48,200 --> 00:18:49,880
0,720 720,810 810,900 900,1290 1290,1680
performance,| if the CPU {guess,is}
|如果 CPU 猜测是正确的，

635
00:18:49,880 --> 00:18:51,180
0,630
right,|
|

636
00:18:51,180 --> 00:18:51,930
0,330 330,420 420,540 540,570 570,750
then it got a big
那么它在开始执行这些指令时就有了很大的优势，

637
00:18:51,930 --> 00:18:54,540
0,240 240,870 1260,1860 1860,2040 2040,2610
head start executing these instructions,|
|

638
00:18:54,540 --> 00:18:55,680
0,180 180,450 450,690 690,810 810,1140
and didn't have to wait
而不必等待昂贵的内存加载。

639
00:18:55,680 --> 00:18:57,960
0,540 630,900 930,1500 1500,1800 1800,2280
for the expensive memory load.|
|

640
00:19:00,660 --> 00:19:01,650
0,180 180,540 540,690 690,840 840,990
Any questions about what this
对于这意味着什么，有什么问题吗？

641
00:19:01,650 --> 00:19:03,260
0,570
means?|
|

642
00:19:08,940 --> 00:19:10,040
0,540
Okay,
好的，这个机器，硬件， CPU 里的晶体管都是非常复杂的，

643
00:19:10,130 --> 00:19:13,160
0,420 1050,1410 1410,2370 2400,2490 2490,3030
{} this machinery, the hardware,

644
00:19:13,160 --> 00:19:14,600
0,60 60,750 750,810 810,900 900,1440
the transistors in the CPU

645
00:19:14,600 --> 00:19:19,250
0,150 150,1050 2280,2430 2430,3510 3510,4650
for speculation are extremely complex,|
|

646
00:19:19,610 --> 00:19:21,230
0,240 240,330 330,1050 1050,1350 1350,1620
there's a huge amount going
在 CPU 中有大量的工作来完成这项工作，

647
00:19:21,230 --> 00:19:22,130
0,300 300,360 360,450 450,810 810,900
on in the CPU to

648
00:19:22,130 --> 00:19:23,440
0,180 180,420 420,840
make this work,|
|

649
00:19:23,440 --> 00:19:25,000
0,210 210,270 270,540 540,660 660,1560
none of which is published,
没有一个是公开的，

650
00:19:25,540 --> 00:19:27,440
0,360 360,510 510,600 600,1350
right,| it's a whole
|整个都是英特尔内部的东西，

651
00:19:27,650 --> 00:19:30,560
0,690 690,1170 1170,1860 1920,2310 2310,2910
Intel internal stuff,| not in,
|不在机器手册里。

652
00:19:30,560 --> 00:19:31,970
0,240 240,360 360,540 540,960 960,1410
not in the machine manual.|
|

653
00:19:32,550 --> 00:19:36,270
0,450 780,1380 1860,2670 2670,3420 3420,3720
{} So surrounding meltdown and
所以围绕 meltdown 和攻击，

654
00:19:36,270 --> 00:19:37,260
0,450 450,630 630,750 750,930 930,990
attacks| like it is a
|是一个很大的猜测，

655
00:19:37,260 --> 00:19:38,880
0,270 270,480 480,540 540,1260 1260,1620
huge amount of speculation| about
|关于 CPU 内部可能发生的事，

656
00:19:39,210 --> 00:19:40,890
0,480 480,900 900,1170 1170,1380 1380,1680
what's probably going on inside

657
00:19:40,890 --> 00:19:41,700
0,60 60,510 510,600 600,750 750,810
the CPU| in order to
|使这种攻击工作或不工作。

658
00:19:41,700 --> 00:19:43,560
0,300 330,1110 1110,1440 1440,1770 1770,1860
make such attack work or

659
00:19:43,560 --> 00:19:46,000
0,240 240,660 1530,1950
not work.| Okay,
|好了，还是回到预测。

660
00:19:46,270 --> 00:19:49,680
0,390 390,480 480,1050 1050,2190
back to speculation though.|
|

661
00:19:50,710 --> 00:19:52,540
0,1140

662
00:19:52,930 --> 00:19:54,220
0,720

663
00:19:55,210 --> 00:19:56,470
0,570 630,810 810,900 900,1020 1020,1260
{} One thing that's going
有一件事是，

664
00:19:56,470 --> 00:19:58,480
0,240 240,390 390,690 930,1440 1650,2010
on is that,| {} in
|为了取消推测预测失败的执行，

665
00:19:58,480 --> 00:20:00,660
0,210 210,360 360,1560
order to undo

666
00:20:00,990 --> 00:20:03,690
0,750 750,1320 1320,1890 1890,2250 2250,2700
speculative failed speculative {mispredicted -

667
00:20:03,690 --> 00:20:06,150
0,480 480,1020 1020,1770 1980,2310 2310,2460
-} speculative execution,| {} the
|机器保留了寄存器的影子版本，

668
00:20:06,150 --> 00:20:08,520
0,330 330,630 660,1260 1260,1890 1890,2370
machine had keeps shadow versions

669
00:20:08,520 --> 00:20:10,950
0,120 120,690 690,1380 1680,2100 2100,2430
of registers essentially,| {you,know,it} assigned
|它被分配给寄存器 2 ，寄存器 3 ，

670
00:20:10,950 --> 00:20:12,690
0,60 60,600 600,900 900,1320 1320,1740
to registers 2, register 3,|
|

671
00:20:12,690 --> 00:20:14,130
0,270 450,1020 1020,1110 1110,1320 1320,1440
but it's {assigning - -}
它分配一个临时的寄存器，

672
00:20:14,130 --> 00:20:15,900
0,150 150,210 210,300 300,810 810,1770
kind of a temporary registers,|
|

673
00:20:16,560 --> 00:20:20,400
0,510 660,1620 1830,2790 2970,3600 3600,3840
if speculation succeeds,| then those
如果预测成功，|那些影子寄存器会变为真实寄存器，

674
00:20:20,400 --> 00:20:22,050
0,600 600,750 750,1020 1020,1440 1440,1650
registers those shadow registers become

675
00:20:22,050 --> 00:20:23,280
0,120 120,330 330,960 990,1140 1140,1230
the real registers,| if it
|如果失败，

676
00:20:23,280 --> 00:20:25,740
0,780 840,1380 1380,1620 1620,1890 1890,2460
fails,| then those shadow registers
|CPU 会丢弃那些影子寄存器。

677
00:20:25,770 --> 00:20:27,360
0,660 660,810 810,1080 1080,1530 1530,1590
discarded the CPU discards the

678
00:20:27,360 --> 00:20:29,660
0,270 270,1020 1350,1560 1560,2070
shadow registers.| So these
|所以这两个任务 r2 和 r3 就像从来没有发生过。

679
00:20:29,660 --> 00:20:30,800
0,120 120,570 570,960 960,1050 1050,1140
two assignments r2 and {r3

680
00:20:30,800 --> 00:20:31,790
0,210 210,300 300,750 750,870 870,990
-} would just be as

681
00:20:31,790 --> 00:20:33,180
0,120 120,210 210,420 420,870
if they never happened.|
|

682
00:20:37,310 --> 00:20:39,860
0,210 210,330 330,660 690,2040 2280,2550
So in this code, {}|
所以，在这段代码中，|

683
00:20:39,860 --> 00:20:41,210
0,330 330,510 510,600 600,780 780,1350
we need to think about
我们需要考虑如果寄存器 0 是有效指针会发生什么，

684
00:20:41,270 --> 00:20:44,750
0,540 540,1440 1440,1860 1980,2790 2790,3480
what happens if register 0

685
00:20:44,750 --> 00:20:46,070
0,180 180,240 240,660 660,1170 1170,1320
is a valid pointer| and
|还有如果它不是一个有效的指针呢？

686
00:20:46,070 --> 00:20:47,300
0,150 150,540 540,690 690,870 870,1230
what happens if it's not

687
00:20:47,300 --> 00:20:48,820
0,90 90,480 480,1170
a valid pointer,

688
00:20:48,850 --> 00:20:51,580
0,420 450,720 720,810 810,1890 1890,2730
right.| If we're speculatively executing
|如果我们预测执行第 4 行，

689
00:20:51,610 --> 00:20:55,720
0,420 420,1080 1530,2070 3330,3930 3930,4110
line 4,| {} {and,register} 2
|并且寄存器 2 是有效指针，

690
00:20:55,720 --> 00:20:57,580
0,90 90,420 420,840 840,1410 1470,1860
{is,a} valid pointer,| then it
|然后 CPU 会执行加载，

691
00:20:57,580 --> 00:20:58,660
0,330 330,450 450,540 540,930 930,1080
turns out the CPU will

692
00:20:58,660 --> 00:21:00,500
0,330 330,480 480,630 630,1350
actually do the load,|
|

693
00:21:00,700 --> 00:21:02,770
0,510 1080,1440 1440,1770 1770,1980 1980,2070
{} and loaded into at
至少加载到寄存器 2 的临时版本中，

694
00:21:02,770 --> 00:21:04,240
0,240 240,330 330,960 960,1350 1350,1470
least the transient version of

695
00:21:04,240 --> 00:21:05,470
0,450 450,660 660,840 840,990 990,1230
register 2,| so we'll actually
|所以我们会出去，

696
00:21:05,470 --> 00:21:07,570
0,180 180,510 510,810 900,1260 1710,2100
go out| and and {}
|尝试获取 r0 所指向的内容，

697
00:21:08,340 --> 00:21:09,690
0,210 210,330 330,900 900,1170 1170,1350
try to fetch what {r0

698
00:21:09,690 --> 00:21:11,310
0,300 300,720 720,960 960,1200 1410,1620
-} points to| and {}
|那么这肯定会工作，

699
00:21:11,310 --> 00:21:14,220
0,330 330,450 450,1050 1050,1350 1350,2910
that will certainly work| if
|如果 r0 指向的数据在缓存中，

700
00:21:14,250 --> 00:21:15,480
0,120 120,390 390,570 570,960 960,1230
the data {r0 -} is

701
00:21:15,480 --> 00:21:16,350
0,360 360,450 450,540 540,810 810,870
pointed to is sitting in

702
00:21:16,350 --> 00:21:19,170
0,90 90,690 780,1350 1770,2070 2250,2820
the cache,| and I don't
|我不知道 CPU 是否会加载，

703
00:21:19,170 --> 00:21:21,030
0,450 450,750 1170,1350 1350,1470 1470,1860
know if if the CPU

704
00:21:21,030 --> 00:21:22,410
0,180 180,360 360,480 480,1020 1050,1380
will do the load,| if
|如果它在缓存中未命中，

705
00:21:22,410 --> 00:21:23,370
0,120 120,480 480,570 570,630 630,960
it misses in the cache|
|

706
00:21:23,370 --> 00:21:24,090
0,90 90,270 270,390 390,570 570,720
and has to load from
它可能必须从内存中加载。

707
00:21:24,090 --> 00:21:25,660
0,330 510,720 720,1140
RAM, it might.|
|

708
00:21:27,880 --> 00:21:28,780
0,150 150,360 360,420 420,600 600,900
But, maybe the more interesting
但是，也许对我们来说更有趣的问题是，

709
00:21:28,780 --> 00:21:30,010
0,330 330,510 510,900 900,1050 1050,1230
question for us,| for this
|对于这个攻击，如果寄存器 0 不是有效的指针，

710
00:21:30,010 --> 00:21:30,910
0,330 330,420 420,570 570,810 810,900
attack is what happens if

711
00:21:30,910 --> 00:21:31,960
0,450 450,600 600,720 720,990 990,1050
register 0 is not a

712
00:21:31,960 --> 00:21:34,740
0,360 360,960
valid pointer,|
|

713
00:21:36,140 --> 00:21:37,760
0,150 150,390 390,1080
in that case,
在这种情况下，如果我们在这里预测执行，

714
00:21:37,760 --> 00:21:40,010
0,150 150,240 240,1050 1050,1710 1710,2250
if we're speculatively executing here,|
|

715
00:21:40,980 --> 00:21:44,760
0,570 1230,1650 1650,2010 2010,2580 3300,3780
{} {the,machine} can't fault at
机器在这里不会出错，

716
00:21:44,760 --> 00:21:46,200
0,180 180,450 450,690 690,780 780,1440
this point,| because we're speculatively
|因为我们预测执行，

717
00:21:46,200 --> 00:21:48,270
0,510 510,930 960,1350 1350,1800 1830,2070
executing,| machine doesn't know, it
|机器不知道，它可以知道 r0 是无效的，

718
00:21:48,270 --> 00:21:49,470
0,180 180,510 510,690 690,840 840,1200
may know that {r0 -}

719
00:21:49,470 --> 00:21:51,360
0,150 150,240 240,960 1410,1740 1740,1890
was an invalid,| that this
|这个预测执行指令试图使用无效指针，无效地址，

720
00:21:51,360 --> 00:21:54,030
0,660 660,780 780,1350 1350,1950 2160,2670
{speculatively -} executed instruction tried

721
00:21:54,030 --> 00:21:55,530
0,90 90,360 360,450 450,960 960,1500
to use an invalid pointer,

722
00:21:55,530 --> 00:21:56,910
0,180 180,540 540,960 960,1290 1290,1380
an invalid address,| but it
|但它不会产生页面错误，

723
00:21:56,910 --> 00:21:58,710
0,360 360,660 660,1110 1200,1620 1620,1800
can't page fault,| because it's
|因为它不能这个执行

724
00:21:58,710 --> 00:22:01,050
0,360 360,810 810,1170 1170,1530 1530,2340
not sure whether this execution|
|

725
00:22:01,080 --> 00:22:02,460
0,180 180,510 540,1080
is valid is
valid 是正确预测执行还是错误预测，

726
00:22:02,610 --> 00:22:05,400
0,240 240,900 1200,1950 1950,2460 2460,2790
{} correct speculative execution or

727
00:22:05,400 --> 00:22:07,860
0,720 720,1050 1050,1830 1830,2340 2340,2460
{misspeculation - -},| and so
|所以它只是，

728
00:22:07,860 --> 00:22:10,640
0,180 270,960 1260,1650 1680,2100
it's only,| so, so
|所以，它不会在第 4 行产生错误，

729
00:22:11,170 --> 00:22:12,520
0,360 360,750 750,1020 1020,1260 1260,1350
it can't actually raise a

730
00:22:12,520 --> 00:22:14,020
0,360 360,480 480,750 750,1200 1200,1500
fault on line 4| until
|直到 valid 的值是知道的，

731
00:22:14,050 --> 00:22:17,140
0,840 1110,2160 2190,2610 2610,2700 2700,3090
after valid value of valid

732
00:22:17,140 --> 00:22:19,900
0,150 150,540 540,780 840,1740 1860,2760
is known,| and after this
|在这个预测分支之后，

733
00:22:19,930 --> 00:22:23,770
0,750 780,1260 2130,2730 2730,3150 3150,3840
branch, this speculative predicted branch,|
|

734
00:22:23,800 --> 00:22:26,290
0,720 1200,1560 1560,1680 1680,2070 2070,2490
{} after we know after
在机器知道情况之后，

735
00:22:26,290 --> 00:22:27,280
0,60 60,540 540,780 780,900 900,990
the machine knows what the

736
00:22:27,280 --> 00:22:29,320
0,450 450,840 1230,1470 1470,1560 1560,2040
condition is,| if the machine
|如果机器看到第 4 寄存器 0 是有效地址，

737
00:22:29,320 --> 00:22:31,390
0,390 600,900 900,990 990,1560 1680,2070
see if the machine's {that,line}

738
00:22:31,390 --> 00:22:32,890
0,240 240,690 690,1110 1110,1380 1380,1500
4 {sees,oh} register {0,is} an

739
00:22:32,890 --> 00:22:35,220
0,810 1020,2010
valid address,|
|

740
00:22:35,580 --> 00:22:37,320
0,210 210,570 600,1350 1350,1620 1620,1740
and then valid turns out
然后 valid 是 1 ，

741
00:22:37,320 --> 00:22:39,840
0,90 90,180 180,780 1050,2160 2190,2520
to be 1,| then, and
|然后，只有这样，机器才会真正产生页面错误，

742
00:22:39,840 --> 00:22:41,010
0,300 300,600 600,750 750,840 840,1170
only then does the machine

743
00:22:41,010 --> 00:22:42,300
0,270 270,630 630,690 690,1020 1020,1290
actually generate the page fault,|
|

744
00:22:42,570 --> 00:22:43,650
0,300 300,480 480,840 840,960 960,1080
if {r0 -} is an
如果 r0 是无效地址，则有效地址是 0 ，

745
00:22:43,650 --> 00:22:45,900
0,510 510,1260 1500,1710 1710,2040 2040,2250
invalid address, then valid turns

746
00:22:45,900 --> 00:22:46,860
0,120 120,180 180,330 330,840 870,960
out to be 0,| the
|机器不会产生页面错误。

747
00:22:46,860 --> 00:22:48,680
0,360 360,600 600,1320
machine does not

748
00:22:48,680 --> 00:22:50,520
0,480 480,540 540,840 840,1350
generate a page fault.|
|

749
00:22:50,960 --> 00:22:52,430
0,330 330,450 450,810 810,960 960,1470
So the {}, the decision
所以，关于是否出错的决定

750
00:22:52,430 --> 00:22:53,780
0,180 180,420 420,510 510,1050 1110,1350
about whether to fault| is
|可能会推迟数百个周期，

751
00:22:53,780 --> 00:22:56,150
0,570 570,1020 1020,1170 1170,2160 2190,2370
deferred possibly for hundreds of

752
00:22:56,150 --> 00:22:58,130
0,870 960,1230 1230,1290 1290,1710 1710,1980
cycles| until the value of
|直到 valid 的值是知道的，

753
00:22:58,220 --> 00:22:59,840
0,390 390,540 540,930 1200,1530 1530,1620
valid is known,| then the
|这里的专业术语，

754
00:22:59,840 --> 00:23:01,310
0,450 450,840 840,960 960,1050 1050,1470
technical term for the point

755
00:23:01,310 --> 00:23:03,110
0,90 90,570 870,1080 1080,1350 1350,1800
at which {}| we know
|指令是否被正确预测执行，

756
00:23:03,110 --> 00:23:06,260
0,420 420,480 480,1440 1890,2460 2670,3150
whether an instruction {} was

757
00:23:06,530 --> 00:23:10,100
0,570 570,1290 1290,2040 2340,3450 3450,3570
correctly speculatively executed| rather than
|而不是被丢弃，叫做 retirement 。

758
00:23:10,100 --> 00:23:12,230
0,180 180,450 450,900 1170,1530 1560,2130
being thrown away is called

759
00:23:12,230 --> 00:23:13,440
0,810
retirement.|
|

760
00:23:15,600 --> 00:23:16,770
0,240 240,330 330,540 540,630 630,1170
So we say an instruction
所以我们说一条指令是预测的，

761
00:23:16,770 --> 00:23:17,820
0,480
is

762
00:23:18,110 --> 00:23:20,210
0,420 450,1320 1320,1680 1740,1860 1860,2100
{} speculative| and at some
|在某个时刻退出了，

763
00:23:20,210 --> 00:23:21,290
0,210 210,330 330,810 810,900 900,1080
point {it's} retired,| and that's
|那么我们知道它要么会被扔掉，

764
00:23:21,290 --> 00:23:23,320
0,90 90,210 210,840 960,1380
when we know {}

765
00:23:23,320 --> 00:23:23,920
0,120 120,300 300,420 420,480 480,600
it's either going to be

766
00:23:23,920 --> 00:23:25,450
0,270 270,570 570,690 690,1260 1260,1530
thrown away| or what's real
|要么是真实的，并应该提交到机器的可见状态，

767
00:23:25,450 --> 00:23:26,740
0,150 150,300 300,570 690,990 990,1290
and should be its effect

768
00:23:26,740 --> 00:23:27,820
0,120 120,210 210,750 750,840 840,1080
should be committed to the

769
00:23:28,090 --> 00:23:29,530
0,480 480,750 750,810 810,870 870,1440
visible state of the machine|
|

770
00:23:29,800 --> 00:23:31,090
0,330 330,450 450,840 840,1020 1020,1290
and the rule is that,|
这个规则是，|

771
00:23:31,510 --> 00:23:32,520
0,390

772
00:23:33,220 --> 00:23:34,750
0,540 570,1110 1110,1230 1230,1410 1410,1530
{} instruction can only be
指令能退出，

773
00:23:34,750 --> 00:23:36,850
0,810 960,1380 1380,1680 1680,1770 1770,2100
retired,| if first of all
|如果首先完成了内存加载的执行，比如加 1 操作，

774
00:23:36,880 --> 00:23:39,760
0,270 270,660 660,1410 1830,2370 2370,2880
is finished executing loading memory,

775
00:23:39,760 --> 00:23:40,990
0,270 270,510 510,720 720,810 810,1230
you're adding one to something,|
|

776
00:23:40,990 --> 00:23:43,570
0,630 660,1110 1110,1740 1740,2340 2340,2580
and every instruction before it,|
以及它之前的每条指令，|

777
00:23:43,570 --> 00:23:44,680
0,150 150,540 540,870 870,930 930,1110
was executed before it has
在它还没有退出之前就执行了，

778
00:23:44,680 --> 00:23:47,680
0,330 330,990 1410,1800 2070,2640 2700,3000
also retired,| so this line
|所以，第 4 行不能退出，

779
00:23:47,680 --> 00:23:49,180
0,210 210,480 480,570 570,1050 1050,1500
4 can't be retired| until
|直到 valid 的加载完成，状态是可评估的，

780
00:23:49,180 --> 00:23:51,070
0,330 480,870 870,960 960,1320 1320,1890
the load of valid completes

781
00:23:51,070 --> 00:23:53,120
0,150 150,330 360,1350
and the conditions

782
00:23:53,990 --> 00:23:55,460
0,120 120,900 900,1140 1140,1350 1350,1470
is evaluated,| only then can
|只有这样才能退出，

783
00:23:55,460 --> 00:23:56,780
0,150 150,540 810,1050 1050,1200 1200,1320
be retired,| so it's going
|所以它可能会出错，

784
00:23:56,780 --> 00:23:57,590
0,60 60,420 420,510 510,660 660,810
to fault, it may it's

785
00:23:57,590 --> 00:23:59,060
0,180 180,540 690,1080 1080,1380 1380,1470
gonna fault,| possibly hundreds of
|可能在内存加载后数百条指令之后，

786
00:23:59,060 --> 00:24:01,280
0,750 1020,1710
instructions after

787
00:24:01,400 --> 00:24:02,750
0,540 600,810 810,870 870,960 960,1350
{} it is the memory

788
00:24:02,750 --> 00:24:03,720
0,510
load,|
|

789
00:24:05,370 --> 00:24:06,180
0,180 180,510 510,600 600,720 720,810
or attempted to do the
或者想要加载内存。

790
00:24:06,180 --> 00:24:07,520
0,330 330,810
memory load.|
|

791
00:24:11,630 --> 00:24:13,220
0,300 300,480 480,720 750,1170 1170,1590
And as a critical detail
作为这个攻击的关键细节，

792
00:24:13,220 --> 00:24:16,080
0,90 90,270 270,1020
for this attack,|
|

793
00:24:16,690 --> 00:24:19,060
0,510 510,630 660,930 930,1860 1890,2370
there's an even more {}.|
还有更多的。|

794
00:24:19,870 --> 00:24:22,620
0,450 720,1230 1230,1500 1500,2160
If lets its {},|
如果让它，|

795
00:24:23,210 --> 00:24:23,990
0,240 240,330 330,600 600,690 690,780
if the address in {r0
如果 r0 中的地址是无效的，

796
00:24:23,990 --> 00:24:25,520
0,300 300,570 570,1230 1230,1350 1350,1530
-} is invalid| and has
|并且在页表中根本没有映射，

797
00:24:25,520 --> 00:24:26,480
0,180 180,510 510,600 600,690 690,960
no mapping in the page

798
00:24:26,480 --> 00:24:28,850
0,240 240,330 330,870 1050,1920 2280,2370
table at all,| then {}
|然后不知道会发生什么。

799
00:24:28,850 --> 00:24:30,230
0,240 240,390 390,480 480,630 630,1380
actually don't know what happens.|
|

800
00:24:32,850 --> 00:24:35,340
0,360 360,930 1320,2130 2130,2280 2280,2490
If the address in {r0
如果 r0 中的地址具有页表映射，

801
00:24:35,340 --> 00:24:36,840
0,360 360,810 810,840 840,1200 1200,1500
-} has a page table

802
00:24:36,840 --> 00:24:38,550
0,540 570,690 690,870 870,1020 1020,1710
mapping,| but there's no permission
|但是没有权限，

803
00:24:38,550 --> 00:24:39,660
0,330 330,660 690,870 870,990 990,1110
for it,| that is the
|也就是 PTE_U 标志没有设置，

804
00:24:39,660 --> 00:24:41,370
0,360 360,630 630,1290 1320,1470 1470,1710
{PTE_U -} flag is not

805
00:24:41,370 --> 00:24:43,980
0,570 750,1290 1320,1830 1830,2190 2190,2610
set,| then what Intel machines
|那么英特尔机器做的是，

806
00:24:43,980 --> 00:24:46,650
0,480 480,870 870,1380 1410,2340 2340,2670
actually do is,| load that
|加载数据并将其分配到临时寄存器 2 中，

807
00:24:46,650 --> 00:24:48,180
0,390 390,720 750,1170 1170,1320 1320,1530
data and assign it into

808
00:24:48,180 --> 00:24:51,000
0,240 390,1350 1350,1860 1860,2460
the transient register 2,|
|

809
00:24:51,840 --> 00:24:54,300
0,750 1200,1830 2010,2250 2250,2340 2340,2460
{} and where it can
它可以被第 5 行的预测执行使用，

810
00:24:54,300 --> 00:24:55,800
0,150 150,720 720,840 840,960 960,1500
be used by the speculative

811
00:24:55,800 --> 00:24:57,570
0,510 510,600 600,840 840,1380 1530,1770
execution of line 5,| so
|所以即使 r0 是一个我们没有权限的地址，

812
00:24:57,570 --> 00:24:58,710
0,300 300,390 390,540 540,840 840,1140
even if {r0 -} was

813
00:24:58,920 --> 00:25:00,300
0,240 240,450 660,1050 1050,1170 1170,1380
was an address for which

814
00:25:00,300 --> 00:25:01,560
0,120 120,390 390,510 510,1020 1020,1260
we don't have permission,| because
|因为它是内核地址，

815
00:25:01,560 --> 00:25:03,480
0,150 150,210 210,510 510,1050 1260,1920
it's a kernel address,| we'll
|我们仍然会看到它的值加载到 r3 中，它的值加 1 ，

816
00:25:03,480 --> 00:25:04,740
0,390 390,540 540,660 660,990 990,1260
still see it's value loaded

817
00:25:04,740 --> 00:25:06,180
0,180 180,810 810,1020 1020,1170 1170,1440
into r3 and its value

818
00:25:06,180 --> 00:25:07,560
0,240 240,750 810,1020 1020,1170 1170,1380
plus 1,| sorry, we won't
|抱歉，我们看不到它，但它会加载到 r2 中，

819
00:25:07,560 --> 00:25:08,400
0,210 210,360 360,480 480,570 570,840
see it, but it will

820
00:25:08,400 --> 00:25:10,320
0,210 210,570 570,1020 1170,1380 1380,1920
be loaded into {r2 -}|
|

821
00:25:10,680 --> 00:25:11,850
0,210 210,420 420,630 630,960 960,1170
and that plus one at
再加上 1 到 r3 ，

822
00:25:11,850 --> 00:25:14,400
0,780 930,1320 1320,1860
r3| and then
|然后当这个加载退出后，

823
00:25:14,400 --> 00:25:16,050
0,150 150,390 390,630 630,780 780,1650
when this load is retired,|
|

824
00:25:16,290 --> 00:25:17,370
0,120 120,390 390,510 510,990 990,1080
the machine will realize {aha
机器会意识到那是一个无效的加载，

825
00:25:17,370 --> 00:25:19,260
0,510 810,1350 1470,1710 1710,1830 1830,1890
-}, {} that was an

826
00:25:19,260 --> 00:25:21,360
0,570 570,1080 1110,1410 1410,1620 1800,2100
invalid load,| because the page
|因为页表条目不允许它，

827
00:25:21,360 --> 00:25:22,620
0,240 240,480 480,720 720,1050 1050,1260
table entry didn't allow it,|
|

828
00:25:23,040 --> 00:25:23,850
0,420 420,540 540,600 600,720 720,810
and so we're going to
所以我们会生成一个错误，

829
00:25:23,850 --> 00:25:25,890
0,270 270,330 330,840 840,1080 1080,2040
raise a fault,| and cancel
|并取消后续指令的执行，

830
00:25:26,400 --> 00:25:27,990
0,210 210,840 840,960 960,1080 1080,1590
the execution of the subsequent

831
00:25:27,990 --> 00:25:30,240
0,660 660,750 750,1230 1230,1560 1590,2250
instructions,| and cancel the effects
|并取消这个指令的结果，

832
00:25:30,630 --> 00:25:32,730
0,330 450,720 720,1200 1260,1590 1590,2100
of this instruction,| {undo -}
|回退对 r2 和 r3 的修改。

833
00:25:33,220 --> 00:25:34,480
0,240 240,780 780,870 870,1050 1050,1260
the modification to {r2 -}

834
00:25:34,480 --> 00:25:36,430
0,120 120,690 900,1260 1290,1710 1710,1950
and r3.| So in this
|所以在这个例子中，有两种预测在进行，

835
00:25:36,430 --> 00:25:37,680
0,690
example,

836
00:25:37,710 --> 00:25:41,460
0,600 870,1740 2070,3030 3030,3330 3330,3750
there's two speculations going on,|
|

837
00:25:41,490 --> 00:25:43,860
0,600 600,1050 1080,1380 1380,2100 2100,2370
one is we're speculating about
一个是我们在预测这个分支，

838
00:25:43,860 --> 00:25:45,570
0,300 300,480 480,780 780,1230 1230,1710
where this branch,| machines speculating
|机器预测这个分支的去向，

839
00:25:45,570 --> 00:25:46,950
0,180 180,300 300,480 480,840 840,1380
about where this branch went|
|

840
00:25:47,400 --> 00:25:48,510
0,210 210,450 450,720 720,1020 1050,1110
and just saying oh it
只是说，不管它去哪条路，

841
00:25:48,510 --> 00:25:49,260
0,300 300,480 480,570 570,660 660,750
went one way or the

842
00:25:49,260 --> 00:25:50,070
0,300 300,390 390,540 540,690 690,810
other,| {} just gonna give
|我只是想试试看，

843
00:25:50,070 --> 00:25:52,170
0,120 120,180 180,540 540,1320 1920,2100
that a shot speculatively,| in
|另外，每次加载后都会有预测执行，

844
00:25:52,170 --> 00:25:54,780
0,720 900,1260 1260,1800 1800,2340 2340,2610
addition there's speculative execution after

845
00:25:54,780 --> 00:25:56,580
0,270 270,600 600,690 690,1020 1020,1800
each load,| we're essentially speculating
|我们预测，

846
00:25:56,580 --> 00:25:58,830
0,420 420,870 870,1440 1590,2160 2160,2250
about| whether the machine is
|机器预测那个加载是否成功，

847
00:25:58,830 --> 00:26:00,140
0,750
speculating

848
00:26:00,170 --> 00:26:02,180
0,300 300,780 780,1110 1110,1740 1770,2010
about whether that load {}
关于加载是否成功完成。

849
00:26:02,180 --> 00:26:05,120
0,600 600,1380 1740,2190 2610,2880 2880,2940
complete successfully.| And in the
|在加载的情况下，英特尔机器总是继续运行，

850
00:26:05,120 --> 00:26:06,230
0,180 180,270 270,330 330,750 750,1110
case of a load, Intel

851
00:26:06,230 --> 00:26:07,910
0,360 360,720 720,930 930,1080 1080,1680
machines always just go on,|
|

852
00:26:08,150 --> 00:26:09,260
0,180 180,390 390,720 720,990 990,1110
{you,know} if data could be
如果可以提供数据，

853
00:26:09,260 --> 00:26:10,540
0,750
provided,|
|

854
00:26:11,110 --> 00:26:12,130
0,240 240,360 360,450 450,540 540,1020
because it's in the cache,|
因为它在缓存中，|

855
00:26:12,130 --> 00:26:13,030
0,330 330,450 450,630 630,690 690,900
and at least the page
或者至少页表条目存在，权限不存在，

856
00:26:13,030 --> 00:26:14,530
0,210 210,480 480,930 930,1440 1440,1500
table entry exists, permissions are

857
00:26:14,530 --> 00:26:16,750
0,390 690,900 900,1200 1200,1290 1290,2220
not,| the machine will speculatively
|机器将预测继续执行，

858
00:26:16,750 --> 00:26:19,480
0,480 480,570 570,1410 1770,2190 2460,2730
continue to execute| {} and
|只有在退出时，

859
00:26:19,480 --> 00:26:21,460
0,330 330,510 510,1170 1170,1290 1290,1980
only on retirement,| the load
|加载才会产生故障，

860
00:26:21,880 --> 00:26:23,350
0,360 360,720 720,990 990,1380 1380,1470
{} will actually generate the

861
00:26:23,350 --> 00:26:24,880
0,600 690,840 840,960 960,1080 1080,1530
fault,| and that will cause
|这将导致预测被取消。

862
00:26:24,880 --> 00:26:26,140
0,90 90,630 630,690 690,780 780,1260
the speculation to be cancelled.|
|

863
00:26:28,660 --> 00:26:31,750
0,390 2220,2430 2430,2790 2790,2940 2940,3090
Alright, any questions about this
好的，关于这个东西，有什么问题吗？

864
00:26:31,750 --> 00:26:32,840
0,540
stuff?|
|

865
00:26:39,870 --> 00:26:41,220
0,150 150,180 180,450 450,990 990,1350
I'm a little confused about,
我有点困惑第二种猜测，

866
00:26:41,250 --> 00:26:43,440
0,480 510,930 930,1230 1230,1980 1980,2190
{} the second speculation| which
|它将 r0 加载到 r2 中，

867
00:26:43,440 --> 00:26:45,000
0,270 270,900 900,1110 1110,1380 1380,1560
is loading {r0 -} into

868
00:26:45,000 --> 00:26:47,910
0,150 150,630 1290,1800 1830,2280 2730,2910
{r2 -},| so, {} does
|那么，这是否意味着将 r0 的值加载到 r2 中，

869
00:26:47,910 --> 00:26:49,950
0,180 180,420 420,1020 1230,1620 1800,2040
that mean that like the

870
00:26:49,950 --> 00:26:51,210
0,360 360,480 480,780 780,1110 1110,1260
value of {r0 -} is

871
00:26:51,210 --> 00:26:52,230
0,300 300,480 480,630 630,930 930,1020
loaded into {r2 -}| and
|并在稍后检查标志？

872
00:26:52,230 --> 00:26:53,610
0,120 120,510 510,630 630,930 930,1380
the flags are checked later?|
|

873
00:26:55,370 --> 00:26:56,780
0,810

874
00:26:56,900 --> 00:26:58,140
0,690
Yes,
是的，发生了什么，是的，完全正确，

875
00:26:58,420 --> 00:27:00,100
0,480 480,780 810,1020 1020,1170 1170,1680
yes, {} so what happens,

876
00:27:00,100 --> 00:27:01,450
0,240 240,420 420,810 810,1080 1170,1350
yes, that's exactly, right,| so
|所以实际发生的情况是，

877
00:27:01,450 --> 00:27:03,100
0,120 120,510 510,1170 1350,1560 1560,1650
what actually happens is that|
|

878
00:27:03,100 --> 00:27:06,280
0,210 210,270 270,810 810,1530
during the speculative phase,|
在预测阶段，|

879
00:27:07,190 --> 00:27:08,000
0,390 390,480 480,570 570,690 690,810
whatever it is that {r0
不管 r0 指向的是什么，

880
00:27:08,000 --> 00:27:10,310
0,210 210,540 540,930 1080,1950 2100,2310
-} points to,| if there's
|如果它指向什么东西，

881
00:27:10,310 --> 00:27:11,810
0,150 150,450 930,1140 1140,1230 1230,1500
sort of if it points

882
00:27:11,810 --> 00:27:13,130
0,90 90,780 810,990 990,1110 1110,1320
to anything,| if {r0 -}
|如果 r0 指向任何东西，

883
00:27:13,130 --> 00:27:15,920
0,270 270,330 330,930 990,1650 1920,2790
points to anything,| then the
|那么内存位置的数据将被加载到 r2 中，

884
00:27:16,130 --> 00:27:17,750
0,420 420,720 720,990 990,1440 1440,1620
data that memory location will

885
00:27:17,750 --> 00:27:18,770
0,120 120,390 390,540 540,750 750,1020
be loaded into {r2 -},|
|

886
00:27:19,740 --> 00:27:21,600
0,870 1170,1350 1350,1530 1530,1740 1740,1860
later, when this load is
稍后，当这个加载退出时，

887
00:27:21,600 --> 00:27:23,160
0,990
retired,|
|

888
00:27:24,280 --> 00:27:26,020
0,420 510,720 720,1170 1170,1650 1650,1740
and it turned, then the
然后会检查权限，

889
00:27:26,020 --> 00:27:27,940
0,450 450,570 570,660 660,1260
permissions will be checked,|
|

890
00:27:28,560 --> 00:27:29,460
0,330 330,510 510,570 570,780 780,900
and if we didn't have
如果我们没有加载的权限，

891
00:27:29,460 --> 00:27:30,930
0,390 390,480 480,630 630,840 840,1470
permission to do that load,|
|

892
00:27:31,610 --> 00:27:34,340
0,510 540,1080 1350,1800 1800,2250 2250,2730
then {} all subsequent instructions
那么所有后续指令结果会被取消，

893
00:27:34,340 --> 00:27:35,690
0,300 300,390 390,510 510,1170 1170,1350
effects will be cancelled,| like
|所有这些寄存器的修改都会被撤销，

894
00:27:35,690 --> 00:27:37,220
0,120 120,360 360,990 990,1440 1440,1530
all these modifications registere will

895
00:27:37,220 --> 00:27:38,920
0,180 180,1050
be undone,|
|

896
00:27:39,180 --> 00:27:41,010
0,630 900,1260 1260,1560 1560,1680 1680,1830
{} and fault will be
错误会出现，

897
00:27:41,010 --> 00:27:43,200
0,870 1170,1620 1620,1710 1710,2100 2100,2190
raised,| with the state of
|就像指令 4 之前的机器核寄存器一样。

898
00:27:43,200 --> 00:27:44,700
0,90 90,540 540,660 660,1170 1170,1500
the machines and registers as

899
00:27:44,700 --> 00:27:46,500
0,150 150,510 510,750 750,1050 1050,1800
they were just before instruction

900
00:27:46,620 --> 00:27:48,360
0,510 630,1140
4.| Okay,
|好的，这很有趣。

901
00:27:48,360 --> 00:27:49,660
0,210 210,720
that's interesting.|
|

902
00:27:49,780 --> 00:27:51,360
0,570
Yes.|
是的。|

903
00:27:52,700 --> 00:27:53,570
0,270 270,390 390,660 660,780 780,870
Yes, I also have a
是的，我还有一个问题，

904
00:27:53,570 --> 00:27:56,750
0,540 780,960 960,1440 2100,2490 2490,3180
question,| is there no possible
|是否有限制 CPU 的方法，

905
00:27:56,750 --> 00:27:58,610
0,180 180,390 390,960 960,1050 1050,1860
way to restrict the CPU|
|

906
00:27:58,640 --> 00:28:00,800
0,360 360,750 750,1350 1350,1710 1710,2160
from checking permissions before doing
在预测加载之前限制 CPU 检查权限。

907
00:28:00,800 --> 00:28:02,980
0,360 360,1110 1110,1530
a speculative load.|
|

908
00:28:06,380 --> 00:28:07,610
0,600 660,810 810,930 930,1080 1080,1230
{} You mean, is there
你的意思是，有没有办法让机器在加载之前做检查？

909
00:28:07,610 --> 00:28:09,380
0,120 120,390 390,600 600,1590 1650,1770
a way to cause the

910
00:28:09,380 --> 00:28:11,150
0,570 570,690 690,930 930,1050 1050,1770
machine to do the check

911
00:28:11,150 --> 00:28:12,840
0,420 420,510 510,990
before the load?|
|

912
00:28:13,370 --> 00:28:14,900
0,330 330,420 420,630 630,840 840,1530
Yes, I guess more concrete,|
是的，我想更具体一点，|

913
00:28:14,900 --> 00:28:15,950
0,180 180,300 300,570 570,900 900,1050
like the only reason this
这是这个问题的唯一原因，

914
00:28:15,950 --> 00:28:17,660
0,120 120,240 240,870 1140,1410 1410,1710
is a problem or,| but
|但是其中一种方法是我们只加载一个页面，

915
00:28:17,870 --> 00:28:19,370
0,450 450,570 570,690 690,1110 1200,1500
one of the ways is

916
00:28:19,370 --> 00:28:21,320
0,420 600,990 990,1350 1350,1830 1830,1950
that we're just loading a

917
00:28:21,320 --> 00:28:23,080
0,660 660,1020
page that,|
|

918
00:28:23,170 --> 00:28:24,580
0,300 300,480 480,720 720,870 870,1410
if we can be aware
如果我们意识到它的权限会变坏，

919
00:28:24,580 --> 00:28:26,350
0,120 120,270 270,720 720,1470 1470,1770
that it has permissions that

920
00:28:26,950 --> 00:28:28,360
0,180 180,330 330,810 840,1110 1110,1410
are going to be bad

921
00:28:28,360 --> 00:28:30,700
0,660 750,1470 1470,1950 1950,2010 2010,2340
somehow,| we're accessing a page
|我们访问一个我们不应该能够访问的页面，

922
00:28:30,700 --> 00:28:31,900
0,120 120,210 210,510 840,990 990,1200
that we don't we shouldn't

923
00:28:31,900 --> 00:28:33,910
0,120 120,300 300,420 420,1080 1410,2010
be able to access,| the
|预测执行能否取消，

924
00:28:34,210 --> 00:28:36,160
0,420 420,510 510,1080 1080,1800 1800,1950
can the speculative execution be

925
00:28:36,160 --> 00:28:37,540
0,660 660,990 990,1110 1110,1230 1230,1380
cancelled,| given that we can
|假设我们可以读取这些权限。

926
00:28:37,540 --> 00:28:39,980
0,210 210,360 360,1170
read these permissions.|
|

927
00:28:40,500 --> 00:28:42,810
0,450 450,630 630,750 750,1590 1860,2310
Yes, in a, yes that's,|
是的，就是，|

928
00:28:42,810 --> 00:28:45,810
0,480 690,1530 2010,2580 2610,2850 2850,3000
{} yeah, well, there's two
好的，有两个答案，

929
00:28:45,810 --> 00:28:47,190
0,300 300,510 510,870 930,1230 1230,1380
answers,| one is that's not
|一个是，这不是英特尔 CPU 的实际工作方式，

930
00:28:47,190 --> 00:28:48,270
0,90 90,240 240,330 330,660 660,1080
the way the Intel chips

931
00:28:48,270 --> 00:28:50,180
0,510 510,570 570,870 870,1410
{CPUs -} actually worked,|
|

932
00:28:50,700 --> 00:28:51,840
0,450 450,630 630,840 840,1050 1050,1140
and the other answer is
另一个答案是是的，

933
00:28:51,840 --> 00:28:53,400
0,720 750,900 900,1020 1020,1110 1110,1560
yes, it would have been,|
|

934
00:28:54,300 --> 00:28:55,470
0,180 180,360 360,930 930,1050 1050,1170
I I believe it would
我相信，那会更简单，

935
00:28:55,470 --> 00:28:56,610
0,90 90,180 210,630 630,750 750,1140
have been easy for them|
|

936
00:28:56,610 --> 00:28:58,740
0,210 210,690 810,1470 1470,1620 1620,2130
to have done and enforce
对预测加载做强制检查，

937
00:28:58,740 --> 00:29:00,360
0,150 150,600 630,930 930,1050 1050,1620
that check even for speculative

938
00:29:00,360 --> 00:29:01,920
0,330 330,480 480,840 1110,1470 1470,1560
loads,| so that even in
|即使在预测寄存器 2 中，也永远不会被写入。

939
00:29:01,920 --> 00:29:03,930
0,840 840,1320 1320,1560 1560,1740 1740,2010
speculation register 2 would never

940
00:29:03,930 --> 00:29:05,080
0,90 90,270 270,600
have been written.|
|

941
00:29:05,980 --> 00:29:08,100
0,810 1200,1560
So maybe.|
所以，也许。|

942
00:29:08,920 --> 00:29:10,660
0,480 480,870 870,1020 1020,1380 1380,1740
And indeed, it turns out
事实上，

943
00:29:10,660 --> 00:29:11,800
0,420 420,660 660,750 750,900 900,1140
that,| you may know, I've
|我注意到论文中提到，

944
00:29:11,800 --> 00:29:12,940
0,270 270,360 360,630 630,1020 1020,1140
noticed the paper mentioned that,|
|

945
00:29:12,940 --> 00:29:15,220
0,210 240,1020 1410,1920 1920,2190 2190,2280
the meltdown seems not to
meltdown 似乎不适用于 AMD CPU ，

946
00:29:15,220 --> 00:29:17,290
0,210 210,390 390,1080 1080,1620 1620,2070
work on AMD {CPUs -},|
|

947
00:29:17,440 --> 00:29:18,910
0,210 210,330 330,690 690,1110 1110,1470
even though AMD {CPUs -},
即使 AMD CPU 的使用手册与 Intel CPU 相同，

948
00:29:19,380 --> 00:29:22,380
0,660 930,1860 1860,2580 2700,2880 2880,3000
the instruction manual is the

949
00:29:22,380 --> 00:29:23,940
0,420 420,570 570,720 720,1050 1050,1560
same as for Intel {CPUs

950
00:29:23,940 --> 00:29:25,470
0,90 90,750 1110,1230 1230,1320 1320,1530
-},| essentially on the same
|是相同的指令集，也就是相同的东西，

951
00:29:25,470 --> 00:29:26,730
0,420 420,660 660,750 750,810 810,1260
instruction set and the instructions

952
00:29:26,730 --> 00:29:28,050
0,210 210,270 270,540 540,1050 1110,1320
mean the same things,| the
|这个攻击在 AMD CPU 上不起作用，

953
00:29:28,050 --> 00:29:30,000
0,240 240,480 480,930 1080,1530 1530,1950
attack doesn't work {on -}

954
00:29:30,000 --> 00:29:32,010
0,570 570,810 1140,1320 1320,1560 1560,2010
AMD CPUs| and it's widely
|人们普遍认为原因是 AMD CPU ，

955
00:29:32,010 --> 00:29:33,390
0,330 330,420 420,540 540,960 960,1380
believed that the reason is

956
00:29:33,390 --> 00:29:35,900
0,330 330,720 720,1470 1470,1800
that AMD {CPUs -},|
|

957
00:29:36,080 --> 00:29:38,240
0,150 150,450 450,660 660,1320 1320,2160
{} even when speculatively executing,|
即使是预测执行时，|如果你没有权限读取这个地址，

958
00:29:39,520 --> 00:29:41,320
0,450 480,750 750,870 870,990 990,1800
if you don't have permission

959
00:29:41,920 --> 00:29:43,900
0,390 390,810 840,1230 1230,1380 1380,1980
to {} read this address,|
|

960
00:29:43,930 --> 00:29:46,990
0,510 510,780 780,2010 2040,2700 2700,3060
won't even speculatively loads the
甚至不会预测加载值到 r2 中，

961
00:29:46,990 --> 00:29:48,760
0,360 360,450 450,1170
value to r2,|
|

962
00:29:49,470 --> 00:29:50,280
0,180 180,390 390,570 570,690 690,810
{} and that's why the
这就是为什么攻击在 AMD CPU 上不起作用的原因，

963
00:29:50,280 --> 00:29:51,510
0,270 270,480 480,720 720,840 840,1230
attack didn't work on AMD

964
00:29:51,510 --> 00:29:53,940
0,390 390,690 900,1260 1260,1890 2010,2430
{CPUs -}| and {recent -}
|最近的英特尔 CPU 显然已经采用了这种方法，

965
00:29:53,940 --> 00:29:57,180
0,630 630,1050 1080,1980 2340,2550 2550,3240
Intel CPUs apparently have adopted

966
00:29:57,180 --> 00:29:58,980
0,210 210,660 660,750 750,1260
that approach,| and actually
|不会预测加载，如果它们没有权限。

967
00:29:59,480 --> 00:30:00,800
0,780
won't

968
00:30:00,800 --> 00:30:02,840
0,300 300,990 990,1530
won't speculatively load,

969
00:30:04,010 --> 00:30:05,330
0,150 150,270 270,420 420,510 510,1320
if they don't have permissions.|
|

970
00:30:06,500 --> 00:30:07,070
0,150 150,240 240,390 390,510 510,570
And as far as I
据我所知，

971
00:30:07,070 --> 00:30:08,500
0,150 150,330 330,840
know,| there's no
|这里没有明显的性能损失，

972
00:30:08,950 --> 00:30:11,410
0,420 420,1200 1200,1380 1380,2340 2370,2460
particular sacrifice at performance,| I
|我想信息都在那里了，

973
00:30:11,410 --> 00:30:12,520
0,180 180,270 270,780 780,960 960,1110
think the information was all

974
00:30:12,520 --> 00:30:15,760
0,390 1020,1260 1530,2070 2970,3180 3180,3240
there,| but for just I
|但我不知道，可能只是几个[]，

975
00:30:15,760 --> 00:30:17,230
0,120 120,360 360,930 930,1200 1200,1470
don't know, just say maybe

976
00:30:17,230 --> 00:30:19,120
0,60 60,630 780,1320 1320,1440 1440,1890
a few [],| they decided
|他们决定只在退出时使用。

977
00:30:19,120 --> 00:30:20,380
0,210 210,300 300,660 660,930 1050,1260
only to apply it on

978
00:30:20,380 --> 00:30:21,500
0,660
retirement.|
|

979
00:30:23,620 --> 00:30:24,610
0,210 210,330 330,690 690,780 780,990
Because they seem to.| That's
因为他们似乎就是这样。|那非常有趣。

980
00:30:24,610 --> 00:30:26,100
0,210 210,900
very interesting.|
|

981
00:30:28,400 --> 00:30:29,960
0,390 690,1200 1200,1350 1350,1470 1470,1560
Yeah, I mean, let me
是的，我的意思是，我提醒你这里有很多猜测，

982
00:30:29,960 --> 00:30:30,710
0,150 150,360 360,450 450,570 570,750
just warn you this there's

983
00:30:30,710 --> 00:30:31,940
0,90 90,360 360,420 420,900 900,1230
a lot of guesswork here,|
|

984
00:30:33,050 --> 00:30:34,670
0,480 930,1170 1170,1440 1440,1530 1530,1620
and I believe what I'm
我相信我说的是真的，

985
00:30:34,670 --> 00:30:37,760
0,270 270,390 390,690 690,930 2880,3090
saying is true,| but in
|但是英特尔和 AMD 并没有披露发生的事情。

986
00:30:37,760 --> 00:30:38,780
0,300 300,390 390,720 720,840 840,1020
Intel and AMD have not

987
00:30:38,780 --> 00:30:40,520
0,120 120,360 360,870 870,1170 1410,1740
been very revealing about what's

988
00:30:40,520 --> 00:30:41,460
0,210 210,420
going on.|
|

989
00:30:43,190 --> 00:30:47,750
0,660 1170,2640 2850,3210 3390,3840 3840,4560
Okay, thers's {} some terminology
好的，这里有一些很重要的术语，

990
00:30:47,750 --> 00:30:50,090
0,270 270,840 840,1380 1500,2010 2040,2340
here that's important,| the when
|当你在 CPU 手册中读到，

991
00:30:50,090 --> 00:30:52,310
0,210 210,690 690,930 930,1440 1650,2220
you read in the manual

992
00:30:52,310 --> 00:30:53,450
0,150 150,240 240,780 780,900 900,1140
for the CPU,| that says
|它说，加法指令使用两个寄存器，

993
00:30:53,450 --> 00:30:54,170
0,150 150,240 240,360 360,450 450,720
oh you know an add

994
00:30:54,170 --> 00:30:55,550
0,480 480,720 720,810 810,1260 1260,1380
instruction takes two registers| and
|对它们相加，然后放到第三个寄存器中，

995
00:30:55,550 --> 00:30:56,360
0,270 270,450 450,570 570,720 720,810
adds them and puts them

996
00:30:56,360 --> 00:30:57,710
0,60 60,120 120,540 570,870 870,1350
in a third,| that stuff,
|这种设计方面的东西叫做架构，

997
00:30:57,860 --> 00:30:59,160
0,810
{}

998
00:30:59,160 --> 00:31:00,510
0,390 390,810 810,870 870,960 960,1350
that aspect of the design

999
00:31:00,510 --> 00:31:02,360
0,120 120,360 360,1170
is called architectural,|
|

1000
00:31:03,130 --> 00:31:06,280
0,600 750,1080 1080,1140 1140,2640
{} sort of []
一种[]行为，

1001
00:31:06,430 --> 00:31:09,600
0,480 510,1380 1440,2400
{} behavior {},|
|

1002
00:31:10,350 --> 00:31:11,700
0,240 240,780 780,1170 1170,1230 1230,1350
the [] behavior of the
机器的[]行为，

1003
00:31:11,700 --> 00:31:14,070
0,600 990,1740 1740,1830 1830,1950 1950,2370
machine,| and so the []
|所以，机器的[]行为是，

1004
00:31:14,070 --> 00:31:14,940
0,300 300,390 390,660 660,750 750,870
behavior of machine is that,|
|

1005
00:31:14,940 --> 00:31:15,510
0,60 60,180 180,360 360,510 510,570
if your load from an
如果你从某个地址加载时，产生页面错误，

1006
00:31:15,510 --> 00:31:16,620
0,300 300,390 390,540 540,930 930,1110
address you know permissions for

1007
00:31:16,620 --> 00:31:17,280
0,60 60,150 150,180 180,450 450,660
you get a page fault

1008
00:31:17,280 --> 00:31:18,330
0,390 390,600 600,750 750,960 960,1050
[],| you're not allowed to
|则不允许加载，

1009
00:31:18,330 --> 00:31:21,420
0,420 1380,1740 1740,1860 1860,2520 2520,3090
load,| that's in distinction to
|这与机器实际所做的不同，

1010
00:31:21,810 --> 00:31:23,340
0,360 360,420 420,720 720,1140 1140,1530
what the machines actually doing,|
|

1011
00:31:23,340 --> 00:31:25,260
0,270 270,330 330,630 630,1440
which is called {Micro-Architectural
就是所谓的微体系结构。

1012
00:31:26,370 --> 00:31:27,800
0,900
-}.|
|

1013
00:31:29,540 --> 00:31:31,070
0,390 390,630 630,1110 1110,1200 1200,1530
That is actually the machine
这是机器有预测执行，

1014
00:31:31,070 --> 00:31:32,660
0,180 180,630 630,1260 1260,1500 1500,1590
has speculating executions| doing all
|做这些疯狂的事情，没有告诉你的，

1015
00:31:32,660 --> 00:31:34,460
0,150 150,480 480,1080 1110,1470 1470,1800
these crazy things without telling

1016
00:31:34,460 --> 00:31:37,280
0,210 360,870 930,1230 1230,2190 2640,2820
you,| and the intent of
|CPU 设计者的目的，

1017
00:31:37,280 --> 00:31:38,840
0,90 90,600 600,1140 1140,1320 1320,1560
the CPU designers,| when they
|在设计所有这些复杂的微体系架构优化时，

1018
00:31:39,200 --> 00:31:40,730
0,540 540,600 600,780 780,1170 1170,1530
design all these complex {micro-architectural

1019
00:31:40,760 --> 00:31:42,410
0,660 660,1380 1380,1470 1470,1560 1560,1650
-} optimizations| is that they
|它们是透明的，

1020
00:31:42,410 --> 00:31:44,360
0,120 120,1080 1350,1560 1560,1830 1830,1950
be transparent,| that {yeah -},
|是的，它在内部做所有这些事情，

1021
00:31:44,360 --> 00:31:45,170
0,180 180,390 390,480 480,630 630,810
it's doing all this stuff

1022
00:31:45,170 --> 00:31:47,300
0,540 540,870 990,1230 1230,2040 2040,2130
internally,| but it looks the
|但是看起来你从程序中得到的结果

1023
00:31:47,300 --> 00:31:48,950
0,510 510,600 600,810 810,960 960,1650
results you get from programs|
|

1024
00:31:48,980 --> 00:31:50,150
0,210 210,270 270,570 570,1020 1020,1170
are the same results you
和一台更简单的机器上得到的结果是一样的，

1025
00:31:50,150 --> 00:31:51,710
0,300 300,450 450,570 570,990 990,1560
get from a simpler machine,|
|

1026
00:31:51,710 --> 00:31:53,480
0,180 510,900 900,1050 1050,1140 1140,1770
that just did the straightforward
做了手册中简单的事情。

1027
00:31:53,480 --> 00:31:54,170
0,240 240,360 360,540 540,630 630,690
thing that was in the

1028
00:31:54,170 --> 00:31:55,100
0,540
manual.|
|

1029
00:31:55,500 --> 00:31:56,400
0,210 210,240 240,750 750,810 810,900
They are intended to be
它们应该是透明的。

1030
00:31:56,400 --> 00:31:58,140
0,810 840,1020 1020,1350 1500,1650 1650,1740
transparent| and so you know,
|所以，比如，在某种程度上，

1031
00:31:58,140 --> 00:31:59,500
0,120 120,630
for example,

1032
00:31:59,800 --> 00:32:01,360
0,330 330,600 600,930 930,1200 1200,1560
at some level,| what Intel
|Intel 在这里做的事情是透明的，

1033
00:32:01,360 --> 00:32:03,370
0,420 420,720 720,1200 1260,1440 1440,2010
is doing here is transparent,|
|

1034
00:32:03,370 --> 00:32:04,420
0,120 120,360 360,450 450,660 660,1050
yeah, maybe they don't check
是的，也许在你加载内存的时候，他们没有检查权限，

1035
00:32:04,420 --> 00:32:05,800
0,180 180,750 750,930 930,1140 1230,1380
for permissions when you when

1036
00:32:05,800 --> 00:32:06,970
0,120 120,270 270,360 360,660 660,1170
you do the memory load,|
|

1037
00:32:07,180 --> 00:32:08,350
0,570 600,870 870,960 960,1080 1080,1170
but if there was a
但是如果退出有问题的话，

1038
00:32:08,350 --> 00:32:10,240
0,570 660,990 990,1590 1590,1710 1710,1890
problem on retirement,| it's gonna
|它会取消所有这些影响，

1039
00:32:10,240 --> 00:32:11,650
0,480 480,630 630,840 840,1320 1320,1410
undo all these effects| and
|所以你永远不会看到那些内存，

1040
00:32:11,650 --> 00:32:13,060
0,240 240,390 390,570 570,1140 1140,1410
so you'll never see that

1041
00:32:13,060 --> 00:32:14,020
0,300 300,420 420,600 600,870 870,960
memory,| you weren't supposed to
|你不应该看到，

1042
00:32:14,020 --> 00:32:16,390
0,390 390,1050 1230,1710 1710,1860 1860,2370
see,| so gosh that looks
|所以，看起来和手册上说的一样，

1043
00:32:16,510 --> 00:32:17,470
0,270 270,420 420,540 540,600 600,960
just like what the manual

1044
00:32:17,470 --> 00:32:18,640
0,420 510,660 660,810 810,1080 1080,1170
said,| you're not allowed to
|你不允许加载没有权限的东西。

1045
00:32:18,640 --> 00:32:19,480
0,240 240,540 540,630 630,720 720,840
load stuff you don't have

1046
00:32:19,480 --> 00:32:20,520
0,390 390,630
permission for.|
|

1047
00:32:20,830 --> 00:32:21,880
0,450

1048
00:32:22,040 --> 00:32:24,340
0,300 300,690 690,1290 1290,1650
So this distinction is,|
所以这个区别是，|

1049
00:32:26,050 --> 00:32:26,950
0,300 300,510 510,570 570,720 720,900
a lot of what this
这个攻击的很多内容，

1050
00:32:26,950 --> 00:32:28,330
0,330 330,420 420,780 780,1080 1230,1380
attack is playing,| on that
|在这里，它知道所有攻击的东西，

1051
00:32:28,330 --> 00:32:30,190
0,570 750,1110 1110,1290 1320,1440 1440,1860
it knows all the attack,|
|

1052
00:32:30,190 --> 00:32:31,360
0,210 210,270 270,450 450,960 990,1170
knows a lot about what's
知道很多内部发生了什么。

1053
00:32:31,360 --> 00:32:32,820
0,240 240,360 360,1020
going on inside.|
|

1054
00:32:35,840 --> 00:32:37,120
0,630
Okay,
好的，关于预测执行，还有其他问题吗？

1055
00:32:37,120 --> 00:32:39,670
0,270 270,660 660,1050 1200,1740 1770,2550
other questions about {} speculative

1056
00:32:39,670 --> 00:32:40,840
0,570
execution?|
|

1057
00:32:47,840 --> 00:32:48,940
0,510
Okay,
好的，我暂时把它放在一边，

1058
00:32:49,000 --> 00:32:49,870
0,240 240,330 330,600 600,750 750,870
{} I'm gonna put that

1059
00:32:49,870 --> 00:32:50,740
0,300 300,390 390,420 420,720 720,870
aside for a moment| and
|讨论一下微架构的另一部分，

1060
00:32:50,740 --> 00:32:52,420
0,210 210,420 420,1140 1260,1530 1530,1680
talk about another piece of

1061
00:32:52,420 --> 00:32:54,000
0,360 360,1020
{micro-architecture -},|
|

1062
00:32:59,240 --> 00:33:05,260
0,750 1380,2400 2520,3120 3240,4170
{} that's {} caches.|
那就是缓存。|

1063
00:33:06,420 --> 00:33:07,980
0,120 120,300 300,960 990,1350 1350,1560
And these again, everybody knows
每个人都知道有缓存，

1064
00:33:07,980 --> 00:33:09,030
0,420 420,510 510,750 750,960 960,1050
caches are there,| but you
|但是它们或多或少是透明的。

1065
00:33:09,030 --> 00:33:09,660
0,60 60,210 210,450 450,540 540,630
know they're supposed to be

1066
00:33:09,660 --> 00:33:10,980
0,210 210,270 270,1110 1140,1290 1290,1320
more or less more or

1067
00:33:10,980 --> 00:33:13,880
0,240 240,1110
less transparent.|
|

1068
00:33:16,130 --> 00:33:16,910
0,390 390,510 510,570 570,720 720,780
And let me draw a
让我画一张缓存的图，

1069
00:33:16,910 --> 00:33:17,780
0,270 270,330 330,420 420,810 810,870
picture of the caches,| I
|我认为这与缓存结构有关，

1070
00:33:17,780 --> 00:33:18,770
0,180 180,300 300,780 780,900 900,990
think are relevant to the

1071
00:33:18,770 --> 00:33:19,940
0,240 240,720 720,840 840,990 990,1170
cache structure,| I think is
|我认为这与 meltdown 相关。

1072
00:33:20,030 --> 00:33:22,040
0,420 420,840 840,1020 1020,1560 1620,2010
most relevant to meltdown.| So
|所以首先你有，

1073
00:33:22,220 --> 00:33:23,090
0,480 480,570 570,660 660,750 750,870
first of all, you have

1074
00:33:23,090 --> 00:33:23,960
0,270
the,|
|

1075
00:33:24,500 --> 00:33:25,670
0,150 150,240 240,360 360,930 930,1170
we have the core which
我们有核心，是机器的一部分，

1076
00:33:25,670 --> 00:33:26,780
0,180 180,510
is the

1077
00:33:27,510 --> 00:33:28,200
0,150 150,330 360,570 570,630 630,690
you know part of the

1078
00:33:28,200 --> 00:33:30,480
0,600 600,900 990,1470 1470,2190 2190,2280
machine,| that parses instructions and
|它解析指令并具有寄存器，

1079
00:33:30,480 --> 00:33:32,430
0,210 210,1170 1170,1440 1470,1800 1800,1950
has registers| and has an
|并且有加法单元和除法单元，

1080
00:33:32,460 --> 00:33:34,470
0,510 510,900 900,1110 1110,1500 1500,2010
addition unit and division unit,|
|

1081
00:33:34,470 --> 00:33:37,170
0,330 870,990 990,1290 1380,2040 2490,2700
and you know whatever the
不管机器的什么执行部分，

1082
00:33:37,260 --> 00:33:39,300
0,810 810,1260 1290,1500 1500,1590 1590,2040
execution part of the machine,|
|

1083
00:33:39,300 --> 00:33:40,500
0,180 180,690
and then,
然后，当它需要进行加载或保存时，

1084
00:33:41,520 --> 00:33:42,840
0,570 570,630 630,870 870,960 960,1320
whenever it needs to do

1085
00:33:42,840 --> 00:33:44,130
0,60 60,360 360,480 480,480 480,1290
a load or {} store,|
|

1086
00:33:45,710 --> 00:33:48,860
0,540 870,1320 1650,1980 2010,2520 2520,3150
{} it {} talks to
它与内存系统交互，

1087
00:33:48,860 --> 00:33:52,100
0,360 480,870 870,1410 2520,3000 3120,3240
the memory system,| and the
|内存系统具有高速缓存，

1088
00:33:52,100 --> 00:33:52,910
0,240 240,480 480,600 600,660 660,810
memory system has a bunch

1089
00:33:52,910 --> 00:33:54,560
0,60 60,450 450,870 990,1230 1230,1650
of caches,| so in particular
|在我们所说的机器中，

1090
00:33:54,560 --> 00:33:55,430
0,60 60,150 150,480 480,540 540,870
in the machines, we're talking

1091
00:33:55,430 --> 00:33:57,420
0,270 270,870 930,1410
about,| there's {
|有一种缓存叫做 L1 缓存，

1092
00:33:57,860 --> 00:34:00,200
0,570 840,1020 1020,1320 1320,1980 1980,2340
-} a data cache called

1093
00:34:00,200 --> 00:34:01,880
0,330 330,1080
{L1 -}

1094
00:34:01,880 --> 00:34:04,550
0,270 270,540 540,1260 1740,2220 2430,2670
{} data cache,| that is
|可能是 64 千字节的大小或不是很大，

1095
00:34:04,550 --> 00:34:05,860
0,660
maybe

1096
00:34:06,540 --> 00:34:09,390
0,570 570,750 750,900 900,2280 2280,2850
{} you know 64 kilobytes

1097
00:34:09,390 --> 00:34:10,260
0,60 60,420 420,480 480,690 690,870
in size or something not

1098
00:34:10,260 --> 00:34:11,310
0,150 150,330 330,450 450,660 660,1050
very big,| but it's extremely
|但它的速度非常快，

1099
00:34:11,310 --> 00:34:13,980
0,630 840,1290 1770,2400 2400,2580 2580,2670
fast,| {} if you, if
|如果你需要的数据在 L1 缓存中，

1100
00:34:13,980 --> 00:34:14,760
0,60 60,330 330,480 480,690 690,780
the data you need is

1101
00:34:14,760 --> 00:34:15,630
0,60 60,150 150,270 270,450 450,870
in the {L1 -} cache,|
|

1102
00:34:15,630 --> 00:34:17,070
0,270 690,900 900,1170 1170,1380 1380,1440
that you get back to
你会在几个周期内得到回复，

1103
00:34:17,070 --> 00:34:17,610
0,60 60,150 150,210 210,450 450,540
you in a couple of

1104
00:34:17,610 --> 00:34:19,230
0,750 780,1140 1140,1200 1200,1560 1560,1620
cycles,| and the structure of
|而 L1 缓存的结构，

1105
00:34:19,230 --> 00:34:20,010
0,60 60,180 180,300 300,660 660,780
the {L1 -} cache,| it
|它有一些行，

1106
00:34:20,010 --> 00:34:21,150
0,120 120,180 180,360 360,450 450,1140
has a bunch of lines

1107
00:34:21,150 --> 00:34:23,340
0,120 120,390 390,1050 1770,2100 2100,2190
are called lines,| each of
|每个可能保存 64 字节的数据，

1108
00:34:23,340 --> 00:34:25,290
0,180 180,900 960,1230 1230,1680 1680,1950
which holds probably 64 bytes

1109
00:34:25,290 --> 00:34:26,460
0,90 90,480 570,810 810,1080 1080,1170
of data,| the lines are
|这些行是缓存表的索引，

1110
00:34:26,460 --> 00:34:28,890
0,900 990,1140 1140,1230 1230,1860 2100,2430
indexed {the -} table really

1111
00:34:28,890 --> 00:34:30,480
0,90 90,630 780,1230 1230,1500 1500,1590
the cache,| the lines are
|这些行通过虚拟地址进行索引，

1112
00:34:30,480 --> 00:34:32,910
0,300 300,450 450,840 840,1560 1680,2430
indexed by virtual address {},|
|

1113
00:34:33,600 --> 00:34:35,400
0,300 300,540 540,930 1080,1410 1410,1800
{} if the virtual addresses
如果虚拟地址在缓存中，

1114
00:34:35,400 --> 00:34:37,500
0,120 120,180 180,750 750,1260 1740,2100
in the cache,| then, {}
|然后，缓存保存具有该虚拟地址的数据，

1115
00:34:37,500 --> 00:34:38,850
0,120 120,420 420,720 720,840 840,1350
the cache holds the data

1116
00:34:40,110 --> 00:34:41,820
0,270 270,570 570,1110 1260,1560 1560,1710
{with,that} virtual address| and in
|事实证明，

1117
00:34:41,820 --> 00:34:43,080
0,360 360,540 540,600 600,900 900,1260
addition as it turns out,

1118
00:34:43,350 --> 00:34:44,820
0,870
{}

1119
00:34:45,480 --> 00:34:46,960
0,210 210,930
it's believed,|
|

1120
00:34:47,520 --> 00:34:49,200
0,240 240,480 480,720 720,1110 1110,1680
the {L1 -} cache entry
L1 缓存条目包含权限的复制，

1121
00:34:49,320 --> 00:34:50,430
0,450 450,510 510,900 900,990 990,1110
contains a copy of the

1122
00:34:50,430 --> 00:34:52,530
0,480 480,840 840,1080 1080,1350 1650,2100
permissions| taken from the page
|从对应于这个虚拟地址的页表条目获得的（权限）。

1123
00:34:52,530 --> 00:34:53,910
0,330 330,600 600,750 750,1320 1320,1380
table entry that corresponds to

1124
00:34:53,910 --> 00:34:55,400
0,150 150,450 450,960
this virtual address.|
|

1125
00:34:55,460 --> 00:34:57,000
0,450 510,990
{} So,
所以，这里有一张表，

1126
00:34:57,030 --> 00:34:58,140
0,240 240,300 300,780 780,960 960,1110
there's a whole, this is

1127
00:34:58,140 --> 00:34:58,940
0,180
it

1128
00:34:59,640 --> 00:35:00,800
0,150 150,570
a table,|
|

1129
00:35:01,270 --> 00:35:02,080
0,180 180,270 270,360 360,600 600,810
{when -} the core {is,used}
当内核使用加载指令时，

1130
00:35:02,080 --> 00:35:04,030
0,60 60,330 330,1020 1380,1860 1860,1950
{} load instruction,| {} the
|发生的第一件事是，

1131
00:35:04,030 --> 00:35:05,050
0,210 210,300 300,390 390,840 840,1020
first thing that happens is

1132
00:35:05,050 --> 00:35:06,730
0,240 240,660 960,1350 1350,1590 1590,1680
that,| the hardware looks in
|硬件在 L1 缓存中查找，

1133
00:35:06,730 --> 00:35:07,600
0,60 60,300 300,600 600,690 690,870
the L1 cache| and see
|查看是否存在一个缓存条目，

1134
00:35:07,600 --> 00:35:09,670
0,90 90,330 330,510 1170,1620 1620,2070
if there's a cache entry|
|

1135
00:35:09,670 --> 00:35:12,160
0,330 330,660 660,1410 1440,2190 2190,2490
whose virtual address matches the
它的虚拟地址与所请求的匹配，

1136
00:35:12,370 --> 00:35:14,820
0,750 1470,1980
requested {},|
|

1137
00:35:15,610 --> 00:35:16,360
0,180 180,480 480,540 540,690 690,750
the address we're trying to
我们想要加载的地址，

1138
00:35:16,360 --> 00:35:17,110
0,210 210,360 360,510 510,660 660,750
load from it,| and if
|如果这样，我们可以让机器从缓存中返回这些数据，

1139
00:35:17,110 --> 00:35:18,250
0,300 300,630 630,750 750,840 840,1140
so, that we can just

1140
00:35:18,250 --> 00:35:19,780
0,180 210,930 930,1110 1110,1440 1440,1530
the machine just returns this

1141
00:35:19,780 --> 00:35:21,220
0,240 240,360 360,420 420,900 1200,1440
data from the cache,| were
|完成地非常快，

1142
00:35:21,220 --> 00:35:22,780
0,210 210,360 360,810 1080,1440 1440,1560
done very quickly,| if they
|如果它们不在 L1 缓存中，

1143
00:35:22,780 --> 00:35:23,500
0,150 150,240 240,450 450,540 540,720
did is not in {L1

1144
00:35:23,500 --> 00:35:25,090
0,210 210,690 690,1080 1110,1380 1380,1590
-} cache,| then the next
|那么下一步是，

1145
00:35:25,090 --> 00:35:26,100
0,480
step

1146
00:35:26,510 --> 00:35:27,680
0,150 150,270 270,630 660,1020 1050,1170
is that we,| {} the
|内存系统的其他部分是用物理地址寻址，

1147
00:35:27,680 --> 00:35:29,000
0,300 300,420 420,570 570,960 960,1320
rest of the memory system

1148
00:35:29,000 --> 00:35:30,980
0,420 690,1080 1080,1350 1380,1530 1530,1980
is is in is addressed

1149
00:35:30,980 --> 00:35:32,240
0,150 150,510 510,930 930,1050 1050,1260
with physical addresses,| so we
|所以在这里，我们需要一个物理地址，

1150
00:35:32,240 --> 00:35:32,870
0,90 90,240 240,450 450,510 510,630
at this point, we're going

1151
00:35:32,870 --> 00:35:33,980
0,60 60,240 240,300 300,630 630,1110
to need a physical address,|
|

1152
00:35:33,980 --> 00:35:35,360
0,120 120,210 210,750 990,1260 1260,1380
if we missed the {L1
如果我们没有在 L1 缓存中命中，

1153
00:35:35,360 --> 00:35:37,370
0,180 180,660 990,1320 1320,1860 1860,2010
-} cache,| this translation {look-aside
|这个转换后备缓冲器是页表项的缓存，

1154
00:35:37,370 --> 00:35:38,540
0,300 300,570 570,660 660,720 720,1170
-} buffer is a cache

1155
00:35:38,540 --> 00:35:41,090
0,90 90,390 390,660 660,1260 2010,2550
of page table entries {},|
|

1156
00:35:41,240 --> 00:35:42,290
0,300 300,360 360,570 570,780 780,1050
{it's,going} to look up the
它将查找虚拟地址，

1157
00:35:42,410 --> 00:35:44,080
0,330 330,690 690,870 870,1200
virtual address,| that the
|程序在转换后备缓冲器中发出的虚拟地址，

1158
00:35:44,080 --> 00:35:45,940
0,450 450,810 810,930 930,1230 1350,1860
program issued in the translation

1159
00:35:45,940 --> 00:35:47,680
0,150 150,420 420,810 1530,1650 1650,1740
look aside buffer,| it may
|它可能不在那里，

1160
00:35:47,680 --> 00:35:48,370
0,150 150,240 240,480 480,540 540,690
not be there,| in which
|在这种情况下，我们现在有很多工作要做，

1161
00:35:48,370 --> 00:35:49,180
0,270 270,570 570,660 660,780 780,810
case, now we got a

1162
00:35:49,180 --> 00:35:49,810
0,150 150,210 210,360 360,450 450,630
lot of work to do,|
|

1163
00:35:49,810 --> 00:35:50,650
0,180 180,270 270,360 360,420 420,840
because we've got to load
因为我们必须为内存加载相关的页表条目。

1164
00:35:50,650 --> 00:35:52,090
0,210 240,600 600,870 870,1140 1140,1440
the relevant page table entry

1165
00:35:52,090 --> 00:35:54,260
0,150 150,690 1080,1650
for memory {}.|
|

1166
00:35:54,290 --> 00:35:55,400
0,270 270,420 420,660 660,750 750,1110
But let's assume we hittin
但是我们假设我们命中了转换后备缓冲器，

1167
00:35:55,400 --> 00:35:56,780
0,60 60,570 570,720 720,990 990,1380
the translation {look-aside -} buffer,|
|

1168
00:35:56,900 --> 00:35:59,510
0,240 240,330 330,780 1530,2460 2460,2610
we can now get the
我们现在可以获得所需的物理地址，

1169
00:35:59,510 --> 00:36:01,610
0,300 300,690 690,1200 1380,1920 1920,2100
needed physical address,| typically there's
|通常会有另一个更大的缓存，

1170
00:36:01,610 --> 00:36:03,380
0,480 480,1020 1020,1260 1260,1470 1470,1770
another cache, another much bigger

1171
00:36:03,380 --> 00:36:04,640
0,750
cache,|
|

1172
00:36:04,830 --> 00:36:07,770
0,270 270,990 1470,2340 2430,2820 2820,2940
that's physically indexed index with
这是物理地址的索引。

1173
00:36:07,770 --> 00:36:09,520
0,90 90,480 480,1230
the physical address.|
|

1174
00:36:10,880 --> 00:36:11,840
0,180 180,270 270,360 360,720 750,960
And so we might, now
现在我们有了物理地址，

1175
00:36:11,840 --> 00:36:12,440
0,90 90,150 150,240 240,300 300,600
that we have a physical

1176
00:36:12,440 --> 00:36:13,160
0,300 300,420 420,510 510,660 660,720
address,| we can look at
|我们可以查看这个缓存，

1177
00:36:13,160 --> 00:36:16,010
0,180 180,840 1530,2070 2490,2730 2730,2850
this cache,| and if we
|如果我们在这里没有命中，

1178
00:36:16,010 --> 00:36:17,660
0,270 270,600 600,1050 1350,1500 1500,1650
miss there,| then we have
|那么我们发送物理地址到内存系统，

1179
00:36:17,660 --> 00:36:18,680
0,120 120,330 330,420 420,750 750,1020
to send the physical address

1180
00:36:18,680 --> 00:36:20,390
0,240 240,300 300,600 600,1230 1470,1710
after the RAM system,| takes
|需要很长时间，

1181
00:36:20,390 --> 00:36:21,140
0,60 60,210 210,510 510,630 630,750
a long time,| but when
|但是当我们最终拿回数据时，

1182
00:36:21,140 --> 00:36:22,100
0,90 90,360 360,480 480,690 690,960
we finally get data back,|
|

1183
00:36:22,100 --> 00:36:23,060
0,120 120,210 210,330 330,870 870,960
then we can populate the
我们可以填充 L2 缓存，

1184
00:36:23,060 --> 00:36:25,250
0,240 240,390 390,960 1590,1980 1980,2190
{L2 -} cache,| {} and
|并用我们从内存中取回的内容填充 L1 缓存，

1185
00:36:25,250 --> 00:36:26,690
0,420 420,600 600,810 810,1050 1050,1440
populate the {L1 -} cache

1186
00:36:26,690 --> 00:36:27,380
0,120 120,180 180,450 450,510 510,690
with the stuff we got

1187
00:36:27,380 --> 00:36:29,420
0,240 240,390 390,840 1020,1560 1560,2040
back from RAM| and return
|并将数据返回给内核。

1188
00:36:29,420 --> 00:36:30,420
0,330
the

1189
00:36:30,670 --> 00:36:31,510
0,180 180,450 450,660 660,750 750,840
the data back to the

1190
00:36:31,510 --> 00:36:32,920
0,360
core.|
|

1191
00:36:34,600 --> 00:36:36,100
0,870

1192
00:36:36,730 --> 00:36:38,360
0,420 420,960
{So,this,is} caching.|
这就是缓存。|

1193
00:36:40,900 --> 00:36:42,260
0,660

1194
00:36:43,060 --> 00:36:44,500
0,300 300,930
{} Just,
只是，通过隐藏的 L1 缓存需要几个周期，

1195
00:36:45,270 --> 00:36:46,740
0,300 300,510 510,600 600,960 960,1470
{} by the, by the

1196
00:36:46,740 --> 00:36:48,420
0,390 390,510 510,690 690,1200 1200,1680
hidden {L1 -} cache practice

1197
00:36:48,420 --> 00:36:49,500
0,60 60,210 210,720 720,1020 1020,1080
a few cycles,| hidden the
|隐藏的 L2 缓存可能需要十几个周期，

1198
00:36:49,500 --> 00:36:51,240
0,360 360,930 1050,1410 1410,1620 1620,1740
L2 cache probably takes a

1199
00:36:51,240 --> 00:36:52,860
0,270 270,360 360,510 510,1230 1380,1620
dozen or two cycles,| and
|而错过那些，可能需要几百个循环，

1200
00:36:52,860 --> 00:36:54,030
0,450 450,720 720,1020 1020,1110 1110,1170
miss that, requires you to

1201
00:36:54,030 --> 00:36:54,900
0,90 90,360 360,570 570,810 810,870
go around probably takes you

1202
00:36:54,900 --> 00:36:56,560
0,60 60,270 270,540 540,1170
a couple hundred cycles,|
|

1203
00:36:56,800 --> 00:36:58,280
0,270 270,660 660,900
these cycles are,
这些周期，

1204
00:36:59,100 --> 00:37:01,290
0,120 120,300 810,1320 1530,1830 1830,2190
you know,| let's say half
|比如，在 2GHz 的机器上是半秒。

1205
00:37:01,290 --> 00:37:02,700
0,300 300,840 840,990 990,1200 1230,1410
a second on a 2

1206
00:37:02,700 --> 00:37:04,160
0,180 180,450 450,840
{GHz -} machine.|
|

1207
00:37:05,130 --> 00:37:06,870
0,270 270,420 420,540 540,1080 1080,1740
{} So it's extremely advantageous
所以，有高速缓存是非常有利的，

1208
00:37:06,870 --> 00:37:08,100
0,60 60,210 210,690 780,990 990,1230
to have caching you would,|
|

1209
00:37:08,100 --> 00:37:09,000
0,90 90,180 180,420 420,600 600,900
if you didn't have cache|
如果没有缓存，|

1210
00:37:09,000 --> 00:37:10,140
0,120 120,180 180,270 270,360 360,1140
and you would be sacrificing
你将损失几百倍的性能，

1211
00:37:10,260 --> 00:37:11,340
0,270 270,630 630,720 720,810 810,1080
a factor of a couple

1212
00:37:11,340 --> 00:37:13,080
0,60 60,420 420,540 540,1290 1410,1740
of hundred in performance,| these
|这些缓存对于良好的性能是非常关键的。

1213
00:37:13,080 --> 00:37:15,330
0,30 30,210 210,1110 1140,1800 2040,2250
are just absolutely critical to

1214
00:37:15,330 --> 00:37:17,560
0,330 330,900 900,1050 1050,1620
decent performance, these caches.|
|

1215
00:37:18,470 --> 00:37:19,660
0,600

1216
00:37:20,000 --> 00:37:21,300
0,780
Now,
现在，这个缓存是 L1 缓存，

1217
00:37:22,720 --> 00:37:25,390
0,510 840,1290 1290,2130 2130,2550 2550,2670
{} this caches is the

1218
00:37:25,390 --> 00:37:27,080
0,150 150,420 420,1200
{L1 -} cache,|
|

1219
00:37:27,140 --> 00:37:28,580
0,450 540,690 690,1080 1080,1320 1320,1440
{} well, both turns out
两个缓存都可以包含，

1220
00:37:28,580 --> 00:37:30,020
0,510 510,720 720,870 870,1260 1260,1440
both both these caches can

1221
00:37:30,020 --> 00:37:31,850
0,720 990,1200 1200,1350 1350,1740 1740,1830
contain,| if we're running in
|如果我们在用户空间运行，

1222
00:37:31,850 --> 00:37:33,560
0,240 240,510 510,690 690,960 1230,1710
user space,| both these caches
|这两个缓存，在操作系统中都是 meltdown 针对的，

1223
00:37:33,560 --> 00:37:35,480
0,120 120,360 480,900 900,1560 1590,1920
in the operating system's meltdown

1224
00:37:35,480 --> 00:37:36,710
0,150 150,360 360,630 840,1170 1170,1230
was aimed at,| both of
|这两个缓存都可以包含用户数据和内核数据，

1225
00:37:36,710 --> 00:37:38,150
0,150 150,570 570,780 780,1170 1170,1440
these caches can contain both

1226
00:37:38,150 --> 00:37:39,920
0,360 360,690 690,1050 1050,1410 1410,1770
user data and kernel data,|
|

1227
00:37:40,700 --> 00:37:42,200
0,180 180,450 450,780 780,900 900,1500
the L2 cache can contain
L2 缓存可以包含内核数据，

1228
00:37:42,200 --> 00:37:44,120
0,240 240,480 480,930 960,1380
kernel data,| because {
|因为它是物理地址的，所以不会有问题。

1229
00:37:45,790 --> 00:37:48,520
0,360 360,750 750,1140 1140,1770
-} it's physically addressed,

1230
00:37:48,550 --> 00:37:51,040
0,300 300,390 390,870 990,1470 2250,2490
there's no problem.| {} The
|L1 缓存要稍微复杂一些，

1231
00:37:51,040 --> 00:37:51,700
0,120 120,330 330,570 570,630 630,660
{L1 -} cache is a

1232
00:37:51,700 --> 00:37:52,870
0,150 150,270 270,660 660,780 780,1170
little bit trickier,| it's virtual
|它是虚拟地址，

1233
00:37:52,870 --> 00:37:54,430
0,330 330,420 420,540 540,1080 1080,1560
addresses,| when we change page
|当我们切换页表时，

1234
00:37:54,430 --> 00:37:56,170
0,750 960,1170 1170,1590 1590,1650 1650,1740
tables,| the contents of the
|L1 缓存的内容不再有效，

1235
00:37:56,170 --> 00:37:57,010
0,120 120,240 240,660 660,720 720,840
{L1 -} cache are no

1236
00:37:57,010 --> 00:37:58,750
0,240 240,660 660,1230 1350,1530 1530,1740
longer valid,| because we change
|因为我们切换了页表，

1237
00:37:58,750 --> 00:37:59,980
0,270 270,600 600,750 750,1020 1020,1230
page tables,| that means that
|这意味着虚拟地址的含义改变了，

1238
00:38:00,130 --> 00:38:01,690
0,210 210,690 690,780 780,1080 1080,1560
the meaning of virtual addresses

1239
00:38:01,690 --> 00:38:02,410
0,300 300,420 420,540 540,630 630,720
changed,| so you'd have to
|所以当切换页表时，你必须刷新 L1 缓存，

1240
00:38:02,410 --> 00:38:03,610
0,330 330,450 450,570 570,780 780,1200
flush the {L1 -} cache,

1241
00:38:03,610 --> 00:38:05,350
0,120 120,390 390,690 690,1140 1350,1740
when change page tables,| although
|尽管有更复杂的技巧可以让你避免这种情况，

1242
00:38:05,350 --> 00:38:06,940
0,480 1140,1440
there's {}

1243
00:38:07,190 --> 00:38:08,990
0,240 240,630 630,990 990,1140 1470,1800
more complex tricks that allow

1244
00:38:08,990 --> 00:38:10,520
0,60 60,120 120,420 420,720 900,1530
you to avoid that {},|
|

1245
00:38:10,850 --> 00:38:12,290
0,480 510,900 960,1080 1080,1170 1170,1440
and so but the fact
但是，在这篇论文的时代的操作系统，

1246
00:38:12,290 --> 00:38:14,000
0,90 90,270 270,690 690,1410 1560,1710
that these operating systems in

1247
00:38:14,000 --> 00:38:15,140
0,210 210,360 360,450 450,600 600,1140
the days of this paper,|
|

1248
00:38:15,260 --> 00:38:17,090
0,330 330,690 690,1050 1050,1620 1620,1830
didn't change page tables, when
在用户空间和内核空间之间切换时，不会切换页表，

1249
00:38:17,090 --> 00:38:18,350
0,330 330,660 660,900 900,1170 1170,1260
changing between user space and

1250
00:38:18,350 --> 00:38:19,580
0,270 270,720 720,900 900,1140 1140,1230
kernel space,| because both were
|因为两者都是映射的，

1251
00:38:19,580 --> 00:38:22,220
0,420 570,990 990,1230 1710,2100
mapped,| meant that, {}
|这意味着，我们不必刷新 L1 缓存中的数据，

1252
00:38:22,220 --> 00:38:23,240
0,300 330,540 540,720 720,900 900,1020
data we didn't have to

1253
00:38:23,240 --> 00:38:24,470
0,270 270,360 360,480 480,660 660,1230
flush the {L1 -} cache,|
|

1254
00:38:24,710 --> 00:38:25,700
0,270 270,450 450,630 630,810 810,990
and that mean the {L1
这意味着 L1 缓存中同时包含用户数据和内核数据，

1255
00:38:25,700 --> 00:38:26,840
0,150 150,450 450,690 690,930 930,1140
-} cache would have both

1256
00:38:26,840 --> 00:38:27,830
0,240 240,330 330,600 600,840 840,990
user and kernel data in

1257
00:38:27,830 --> 00:38:28,580
0,180 180,270 270,420 420,510 510,750
it,| and that it made
|它使得系统调用变得更快，

1258
00:38:28,580 --> 00:38:30,440
0,210 210,420 420,630 630,1170 1620,1860
system calls even faster,| if
|如果你调用一个系统调用，

1259
00:38:30,440 --> 00:38:31,670
0,240 330,540 540,600 600,900 900,1230
you call a system call,|
|

1260
00:38:31,670 --> 00:38:32,690
0,60 60,330 330,510 510,900 900,1020
the system call returns,| there's
系统调用返回，|缓存中可能仍然有有用的用户数据，

1261
00:38:32,690 --> 00:38:34,180
0,240 240,450 450,960
still gonna be

1262
00:38:34,180 --> 00:38:35,830
0,570 660,1140 1140,1410 1410,1500 1500,1650
{} likely still to be

1263
00:38:35,830 --> 00:38:37,270
0,630 660,990 990,1230 1230,1350 1350,1440
useful user data in the

1264
00:38:37,270 --> 00:38:38,780
0,480 480,990
caches,| because
|因为我们没有改变，

1265
00:38:38,810 --> 00:38:40,520
0,120 120,510 540,1230 1230,1410 1410,1710
we never changed,| we never
|我们没有改变页表或这些地址的含义。

1266
00:38:40,520 --> 00:38:41,780
0,390 390,600 600,900 900,960 960,1260
changed page tables or changed

1267
00:38:41,780 --> 00:38:42,980
0,60 60,360 360,420 420,600 600,1200
the meanings of these addresses.|
|

1268
00:38:45,620 --> 00:38:46,850
0,330 330,510 510,810 810,1140 1140,1230
Anyway, so there's likely to
不管怎样，这里可能有内核数据，

1269
00:38:46,850 --> 00:38:48,380
0,120 120,450 450,900 1260,1470 1470,1530
be kernel data,| even if
|即使你正在用户空间运行，

1270
00:38:48,380 --> 00:38:49,340
0,150 150,390 390,450 450,690 690,960
you're running a user space,|
|

1271
00:38:49,340 --> 00:38:50,210
0,90 90,360 360,420 420,510 510,870
is likely to be kernel
L1 缓存中也很可能有内核数据，

1272
00:38:50,210 --> 00:38:51,240
0,450
data

1273
00:38:51,240 --> 00:38:52,710
0,360 390,540 540,690 690,840 840,1470
in the {L1 -} cache,|
|

1274
00:38:53,070 --> 00:38:54,360
0,210 210,330 330,540 540,1140 1140,1290
and it's these permissions which
这些权限是从 TLB 复制出来的，

1275
00:38:54,360 --> 00:38:55,170
0,120 120,540 540,630 630,690 690,810
are copied out of the

1276
00:38:55,170 --> 00:38:56,250
0,300 300,600 600,900 900,1020 1020,1080
{TLB -},| copied out of
|从页表条目复制来的，

1277
00:38:56,250 --> 00:38:58,050
0,270 270,540 540,1080 1260,1500 1500,1800
page table entries,| that tells
|告诉机器，即使数据在缓存中，

1278
00:38:58,050 --> 00:38:59,910
0,90 90,810 840,1200 1530,1650 1650,1860
the machine that oh even

1279
00:38:59,910 --> 00:39:00,480
0,120 120,210 210,420 420,510 510,570
though the data is in

1280
00:39:00,480 --> 00:39:02,040
0,90 90,810 840,1140 1140,1320 1320,1560
the cache,| you're not allowed
|你不能查看它，

1281
00:39:02,040 --> 00:39:03,040
0,60 60,270 270,450
to see it,|
|

1282
00:39:03,130 --> 00:39:04,690
0,540 600,990 1050,1230 1230,1290 1290,1560
{and,raise} {} raise a page
并引发页面错误。

1283
00:39:04,690 --> 00:39:05,560
0,360
fault.|
|

1284
00:39:10,030 --> 00:39:11,340
0,600

1285
00:39:11,870 --> 00:39:12,470
0,300 300,390 390,450 450,480 480,600
So this is a good
所以现在是提这件事的好时机，

1286
00:39:12,470 --> 00:39:14,560
0,180 180,240 240,840 1080,1470
time to mention that,|
|

1287
00:39:15,220 --> 00:39:17,830
0,390 390,1080 1170,1380 1380,2130 2130,2610
even though the intent of
即使微结构优化的目的是它们是完全透明的，

1288
00:39:17,860 --> 00:39:20,500
0,660 660,1410 1410,2310 2310,2430 2430,2640
{micro-architectural -} {optimizations -} is

1289
00:39:20,500 --> 00:39:22,980
0,150 150,330 330,900 900,1890
they be completely transparent,|
|

1290
00:39:22,980 --> 00:39:24,200
0,630

1291
00:39:24,910 --> 00:39:26,650
0,240 240,570 570,1050 1050,1170 1170,1740
that can't possibly be true,|
那不可能是真的，|

1292
00:39:26,740 --> 00:39:28,300
0,270 270,360 360,660 660,1320 1410,1560
because the whole point of
因为这些微架构优化的全部目的

1293
00:39:28,300 --> 00:39:30,730
0,450 480,930 930,1650 1650,2340 2340,2430
these {micro-architectural -} {optimizations -}|
|

1294
00:39:30,730 --> 00:39:32,170
0,120 120,510 540,990 990,1080 1080,1440
is almost always to improve
几乎就是为了提高性能，

1295
00:39:32,170 --> 00:39:34,090
0,870 990,1260 1260,1410 1410,1560 1560,1920
performance,| and so they will
|所以，它们至少在性能方面是可见的，

1296
00:39:34,150 --> 00:39:36,550
0,60 330,1500 1710,1950 1950,2130 2130,2400
be guaranteed to be at

1297
00:39:36,550 --> 00:39:38,230
0,360 360,1050 1140,1320 1320,1590 1590,1680
least visible in terms of

1298
00:39:38,230 --> 00:39:40,120
0,1020 1080,1320 1320,1440 1440,1560 1560,1890
performance,| as you could tell
|你可以判断你的机器是否有缓存，

1299
00:39:40,120 --> 00:39:40,810
0,90 90,210 210,540 540,660 660,690
if your machine has a

1300
00:39:40,810 --> 00:39:42,250
0,360 360,450 450,870 900,1380 1380,1440
cache or not,| because if
|因为如果它没有缓存，

1301
00:39:42,250 --> 00:39:43,360
0,90 90,330 330,450 450,540 540,1110
it doesn't have a cache,|
|

1302
00:39:43,390 --> 00:39:44,350
0,270 270,390 390,420 420,690 690,960
it'll run a couple hundred
它的运行速度会慢几百倍，

1303
00:39:44,350 --> 00:39:45,660
0,240 240,900
times slower,

1304
00:39:46,180 --> 00:39:48,790
0,420 840,1380 1500,1650 1650,2250 2310,2610
right,| {} in addition you
|另外，你还可以判断要获取的数据在哪里，

1305
00:39:48,790 --> 00:39:49,810
0,120 120,390 390,660 660,780 780,1020
can tell where the data

1306
00:39:49,810 --> 00:39:51,250
0,150 150,360 360,450 450,1170 1200,1440
you're trying to fetch,| if
|如果你能足够精确地测量时间，

1307
00:39:51,250 --> 00:39:52,540
0,120 120,540 540,600 600,960 960,1290
you're capable of measuring time

1308
00:39:52,540 --> 00:39:54,070
0,450 450,810 1050,1320 1320,1410 1410,1530
accurately enough,| and you do
|你做加载，你就能看出来，

1309
00:39:54,070 --> 00:39:55,600
0,60 60,660 690,870 870,990 990,1530
a load, you can tell,|
|

1310
00:39:55,900 --> 00:39:56,800
0,150 150,270 270,510 510,810 810,900
if the load returned in
如果加载在几个周期内返回，数据一定已被缓存，

1311
00:39:56,800 --> 00:39:58,480
0,60 60,300 300,1140 1320,1440 1440,1680
a couple cycles, the data

1312
00:39:58,480 --> 00:39:59,530
0,150 150,240 240,330 330,960 960,1050
must have been cached,| if
|如果加载在百倍周期之后返回，

1313
00:39:59,530 --> 00:40:01,240
0,90 90,300 300,630 630,1200 1350,1710
the load returned after a

1314
00:40:01,240 --> 00:40:03,180
0,330 330,750 750,1140
hundred times that,|
|

1315
00:40:03,360 --> 00:40:04,860
0,480 600,1140 1140,1350 1350,1410 1410,1500
they probably had to be
它们可能是从内存加载的，

1316
00:40:04,860 --> 00:40:06,450
0,270 270,450 450,960 1350,1500 1500,1590
loaded from RAM,| and so
|所以差异是明显的，

1317
00:40:06,450 --> 00:40:07,770
0,90 90,540 540,630 630,1200 1200,1320
the differences are profound,| and
|如果你能测量出几纳秒甚至几十纳秒的时间，

1318
00:40:07,770 --> 00:40:08,670
0,90 90,240 240,330 330,600 600,900
if you can measure time

1319
00:40:08,670 --> 00:40:10,170
0,150 150,300 810,1080 1080,1140 1140,1500
to {} you know a

1320
00:40:10,170 --> 00:40:11,760
0,330 330,1110 1110,1200 1200,1320 1320,1590
few nanoseconds or even tens

1321
00:40:11,760 --> 00:40:13,320
0,90 90,840 1020,1260 1260,1350 1350,1560
of nanoseconds,| you can tell
|你可以分辨出不同之处，

1322
00:40:13,320 --> 00:40:15,000
0,90 90,750 900,1080 1080,1170 1170,1680
the difference,| {so,in} the performance
|所以在性能层面上，

1323
00:40:15,000 --> 00:40:16,680
0,420 510,630 630,930 930,1440 1440,1680
level,| is {micro-architecture -} is
|微架构绝对不透明的。

1324
00:40:16,710 --> 00:40:18,880
0,720 720,930 930,1680
absolutely not transparent.|
|

1325
00:40:19,120 --> 00:40:19,870
0,180 180,360 360,480 480,690 690,750
And all the things we
我们谈论的所有东西，分支预测，缓存或其他，

1326
00:40:19,870 --> 00:40:21,970
0,300 300,810 810,1140 1140,1620 1620,2100
talk about, branch prediction caches

1327
00:40:21,970 --> 00:40:23,080
0,60 60,360 360,510 510,690 690,1110
or whatever,| all that stuff
|所有这些东西至少在时间上是间接可见的。

1328
00:40:23,080 --> 00:40:26,680
0,420 1050,1500 1710,2460 2670,3180 3180,3600
is at least indirectly visible

1329
00:40:27,460 --> 00:40:28,840
0,300 300,840
to timing.|
|

1330
00:40:29,290 --> 00:40:30,720
0,420

1331
00:40:30,990 --> 00:40:31,890
0,180 180,300 300,360 360,600 600,900
And so, of course many
所以，当然很多人，

1332
00:40:31,890 --> 00:40:34,860
0,300 300,510 510,750 750,1110 2160,2970
people,| even though the {micro-architectural
|即使微架构设计在任何细节层面上都是保密的，

1333
00:40:34,860 --> 00:40:38,280
0,900 1350,2160 2160,2550 2820,3240 3240,3420
-} design is sort of

1334
00:40:38,580 --> 00:40:40,020
0,210 210,390 390,750 750,960 960,1440
in any detailed level secret,|
|

1335
00:40:40,440 --> 00:40:41,730
0,240 240,660 660,840 840,990 990,1290
to Intel, it's their private
对于 Intel 来说，如何实现是他们的私有业务，

1336
00:40:41,730 --> 00:40:42,990
0,330 330,450 450,540 540,930 930,1260
business how they implement this,|
|

1337
00:40:43,020 --> 00:40:44,400
0,180 180,570 630,900 900,1020 1020,1380
in fact it's all along
事实上，它一直以来都是很多人非常感兴趣的，

1338
00:40:44,400 --> 00:40:46,770
0,180 180,330 330,1140 1140,1680 1680,2370
been of extremely intense interest

1339
00:40:47,100 --> 00:40:48,630
0,540 690,870 870,1110 1110,1200 1200,1530
to a lot of people,|
|

1340
00:40:48,630 --> 00:40:49,950
0,240 240,300 300,750 750,1260 1260,1320
because it affects performance a
因为它对性能影响很大。

1341
00:40:49,950 --> 00:40:52,440
0,360 570,1110 1320,1500 1500,2100 2100,2490
lot.| So a compiler writers
|所以，编译器编写者对微体系结构了解很多，

1342
00:40:52,440 --> 00:40:53,880
0,90 90,600 630,930 930,1020 1020,1440
for example know a lot

1343
00:40:53,880 --> 00:40:56,100
0,330 360,720 720,1350 1350,1890
about {micro-architecture -},| because,
|因为，许多编译器优化

1344
00:40:56,100 --> 00:40:57,570
0,180 180,570 570,810 810,1020 1020,1470
the most many many compiler

1345
00:40:57,570 --> 00:41:01,500
0,780 780,1260 1290,2040 2040,3000 3090,3930
optimizations| are implicitly exploiting people's
|都在隐式地利用人们对机器内部的良好猜测。

1346
00:41:01,530 --> 00:41:02,940
0,480 480,960 960,1170 1170,1320 1320,1410
good guesses about what the

1347
00:41:02,940 --> 00:41:05,440
0,390 390,810 810,1170 1170,1950
machines actually doing inside.|
|

1348
00:41:05,500 --> 00:41:07,690
0,390 420,600 600,1020 1110,1740 1740,2190
{} And indeed the CPU
并且实际上 CPU 制造商发布了优化指南，

1349
00:41:08,350 --> 00:41:11,800
0,510 540,1260 1260,1950 1980,2670 2670,3450
{} manufacturers publish optimization guides,|
|

1350
00:41:11,830 --> 00:41:13,390
0,240 240,660 660,1290 1290,1440 1440,1560
that reveal some of the
揭示了一些微架构的技巧，

1351
00:41:13,390 --> 00:41:15,460
0,360 360,1050 1050,1620 1710,1950 1950,2070
{micro-architectural -} tricks,| but they
|但它们很少涉及太多细节，

1352
00:41:15,460 --> 00:41:16,840
0,270 270,420 420,600 600,810 810,1380
rarely go into much detail,|
|

1353
00:41:17,410 --> 00:41:19,210
0,480 630,1050 1050,1230 1230,1470 1470,1800
{} certainly not enough detail
当然没有足够的细节来真正理解为什么 meltdown 会起作用。

1354
00:41:19,210 --> 00:41:22,180
0,120 120,390 390,1260 1710,2280 2280,2970
to really understand exactly why

1355
00:41:22,210 --> 00:41:23,960
0,210 210,720 720,1350
{} meltdown works.|
|

1356
00:41:24,180 --> 00:41:26,100
0,450 960,1200 1200,1290 1290,1530 1530,1920
{} So the {micro-architecture -}
所以微架构的东西处于

1357
00:41:26,100 --> 00:41:26,880
0,210 210,300 300,480 480,540 540,780
stuff is sort of sits

1358
00:41:26,880 --> 00:41:28,380
0,360 360,870 870,1230 1230,1320 1320,1500
somewhere| between supposed to be
|在透明、可见和隐藏之间，

1359
00:41:28,380 --> 00:41:30,180
0,750 750,900 900,1230 1230,1350 1350,1800
transparent and visible and hidden

1360
00:41:30,180 --> 00:41:32,700
0,690 930,1260 1260,1710
and sort of

1361
00:41:33,730 --> 00:41:35,530
0,810 900,1050 1050,1350 1560,1680 1680,1800
partially,| { -} you know
|当然有很多人感兴趣，

1362
00:41:35,560 --> 00:41:38,920
0,570 1500,1980 2670,3060 3060,3120 3120,3360
certainly a lot of people

1363
00:41:38,920 --> 00:41:39,760
0,120 120,540 540,630 630,690 690,840
are interested| and a lot
|很多人知道关于它的各种随机的事情。

1364
00:41:39,760 --> 00:41:40,750
0,60 60,270 270,600 600,750 750,990
of people know all kinds

1365
00:41:40,750 --> 00:41:41,800
0,150 150,450 450,720 720,960 960,1050
of random things about it.|
|

1366
00:41:43,800 --> 00:41:45,580
0,540
Okay,
好的，所以为什么这些缓存的东西对于 meltdown 是感兴趣的，

1367
00:41:45,800 --> 00:41:46,760
0,330 330,510 510,720 720,810 810,960
so the reason why this

1368
00:41:46,760 --> 00:41:49,550
0,330 330,1110 1230,1950 2010,2220 2220,2790
cache stuff {} is interesting

1369
00:41:49,550 --> 00:41:52,160
0,150 150,870 990,1320 1320,1920 1950,2610
for meltdown,| {first,of,all}, any questions
|首先，关于缓存，有什么问题吗？

1370
00:41:52,160 --> 00:41:53,920
0,510 540,780 780,1230
about about caching?|
|

1371
00:41:58,660 --> 00:41:59,740
0,510
Okay,
好的，那么让我来谈谈，

1372
00:42:00,220 --> 00:42:02,530
0,510 750,1230 1230,1320 1320,1710 1710,2310
{} let me talk them,|
|

1373
00:42:03,720 --> 00:42:06,750
0,1020 1260,1650 1650,1920 1920,2310 2730,3030
{} about sort of {}
关于论文使用缓存的主要方式，

1374
00:42:06,750 --> 00:42:08,220
0,360 360,510 510,660 660,780 780,1470
main way that the paper

1375
00:42:08,460 --> 00:42:09,810
0,420 420,840 840,900 900,1110 1110,1350
uses caching,| the paper talks
|论文讨论了这种技术，刷新并重新加载。

1376
00:42:09,810 --> 00:42:12,180
0,270 270,810 960,1380 1380,1620 1620,2370
about this technique called flush,

1377
00:42:12,210 --> 00:42:14,480
0,570 570,810 810,1590
flush and reload.|
|

1378
00:42:17,160 --> 00:42:18,340
0,330

1379
00:42:18,740 --> 00:42:19,840
0,570
And,
刷新和重新加载的目的是什么，

1380
00:42:20,170 --> 00:42:21,340
0,210 210,660 660,750 750,1080 1080,1170
what flush and reload is

1381
00:42:21,340 --> 00:42:22,390
0,210 210,420 420,600 600,810 840,1050
up to,| is that it's
|它回答的问题是，

1382
00:42:22,390 --> 00:42:25,330
0,450 450,510 510,1320 2460,2850 2850,2940
answering the question| did a
|是否有一段特定的代码使用了位于特定地址的内存。

1383
00:42:25,330 --> 00:42:27,700
0,570 570,870 870,990 990,1830
particular piece of code

1384
00:42:28,010 --> 00:42:31,910
0,870 2070,3090 3090,3450 3450,3810 3810,3900
{} use the memory at

1385
00:42:31,910 --> 00:42:33,840
0,60 60,510 510,1440
a particular address.|
|

1386
00:42:33,840 --> 00:42:36,990
0,450 1290,1590 1590,2430 2430,3090 3090,3150
And it's not directly a
这不是直接的安全漏洞，

1387
00:42:36,990 --> 00:42:40,020
0,1200 1440,2130 2130,2580 2610,2820 2820,3030
security exploit,| because it only
|因为它只对你能得到的内存起作用。

1388
00:42:40,020 --> 00:42:41,040
0,330 330,450 450,750 750,870 870,1020
works for memory that you

1389
00:42:41,040 --> 00:42:42,660
0,150 150,360 360,780 1170,1440 1440,1620
can get at.| So if
|所以如果你的用户代码，

1390
00:42:42,660 --> 00:42:43,650
0,210 210,450 450,720 720,900 900,990
your user code| and you
|你有一些内存，那就是你的内存，

1391
00:42:43,650 --> 00:42:44,610
0,150 150,300 300,630 630,810 810,960
have some memory, that's your

1392
00:42:44,610 --> 00:42:45,540
0,450 450,540 540,630 630,870 870,930
memory| and you're allowed to
|你可以使用它，

1393
00:42:45,540 --> 00:42:47,130
0,210 210,420 600,1050 1050,1260 1350,1590
use it,| you can and
|你可以调用自己的一个函数，

1394
00:42:47,130 --> 00:42:47,880
0,120 120,360 360,510 510,600 600,750
you call one of your

1395
00:42:47,880 --> 00:42:51,060
0,150 150,720 720,900 1770,2340 2460,3180
own functions| or then you'll
|然后你就可以区分，

1396
00:42:51,060 --> 00:42:52,230
0,150 150,330 330,450 450,1050 1050,1170
be able to tell,| you
|你可以用刷新和重新加载来区分，

1397
00:42:52,230 --> 00:42:53,670
0,120 120,300 300,630 630,750 750,1440
can use flush and reload

1398
00:42:53,700 --> 00:42:55,230
0,150 150,420 420,870 870,990 990,1530
to tell,| whether the function
|你刚才执行的函数是否使用了内存，

1399
00:42:55,230 --> 00:42:57,000
0,240 240,600 600,780 780,990 990,1770
your function, you just executed

1400
00:42:57,210 --> 00:42:59,140
0,690 720,1020 1020,1590
used your memory,|
|

1401
00:42:59,320 --> 00:43:00,970
0,480 780,960 960,1110 1110,1470 1470,1650
{} you can't directly use
你不能直接使用这个攻击或者它不是攻击，

1402
00:43:00,970 --> 00:43:02,140
0,180 180,720 750,870 870,1020 1020,1170
this attack or it's not

1403
00:43:02,140 --> 00:43:03,220
0,60 60,600 630,750 750,930 930,1080
an attack,| you can use
|你可以使用这个技术来确定

1404
00:43:03,220 --> 00:43:04,990
0,150 150,810 1050,1260 1260,1560 1560,1770
this technique to figure out,|
|

1405
00:43:04,990 --> 00:43:07,450
0,450 510,780 780,1020 1020,1950 1950,2460
if some other process use
其他进程使用的是否是私有内存，

1406
00:43:07,450 --> 00:43:09,010
0,210 210,630 630,750 750,1110 1110,1560
that process is private memory,|
|

1407
00:43:09,510 --> 00:43:10,500
0,420

1408
00:43:11,110 --> 00:43:13,750
0,510 1050,1560 1560,2040 2040,2370 2370,2640
although, because processes sometimes share
不过，因为进程有时会共享内存，是的，

1409
00:43:13,750 --> 00:43:15,180
0,420 420,840
memory, yeah,|
|

1410
00:43:16,180 --> 00:43:17,200
0,210 210,330 330,480 480,900 900,1020
{} you may still be
你也许还能做到，

1411
00:43:17,200 --> 00:43:19,340
0,210 210,480 840,1020 1020,1350
able to do,| well,
|正确的说法是，

1412
00:43:19,460 --> 00:43:20,000
0,120 120,240 240,330 330,390 390,540
the right way to put

1413
00:43:20,000 --> 00:43:20,630
0,120 120,210 210,330 330,420 420,630
it is| you can only
|你只能找到被允许访问的内存。

1414
00:43:20,630 --> 00:43:21,800
0,270 270,360 360,540 540,990 990,1170
find out about memory you're

1415
00:43:21,800 --> 00:43:23,480
0,240 240,330 330,960
allowed to access.|
|

1416
00:43:23,540 --> 00:43:24,980
0,240 240,510 510,750 750,810 810,1440
Okay, so answering the question,|
好的，那么回答这个问题，|

1417
00:43:25,780 --> 00:43:27,400
0,570 630,990 990,1140 1140,1170 1170,1620
{} did did a particular
有没有一个特定的函数使用这个内存。

1418
00:43:27,400 --> 00:43:29,620
0,690 990,1350 1350,1560 1560,1740 1740,2220
function {} use this memory.|
|

1419
00:43:29,650 --> 00:43:31,660
0,330 450,870 870,1410
So, step one,
所以，第一步，我们要刷新，

1420
00:43:33,320 --> 00:43:35,960
0,600 810,1440 1470,1680 1680,2010 2040,2640
{} is we're gonna flush,|
|

1421
00:43:35,960 --> 00:43:37,790
0,360 360,480 480,1410 1410,1770 1770,1830
supposing we were interested in
假设我们对地址 x 感兴趣，

1422
00:43:37,790 --> 00:43:39,500
0,480 480,1260
address x,|
|

1423
00:43:41,240 --> 00:43:42,440
0,180 180,360 360,420 420,1080 1080,1200
we want to flush the
我们要刷新缓存，

1424
00:43:42,440 --> 00:43:43,610
0,690 690,870 870,930 930,1050 1050,1170
cache,| {we,want} to make sure
|我们希望确保缓存不包含内存位置 x ，

1425
00:43:43,610 --> 00:43:46,040
0,60 60,600 660,1110 1110,2070 2100,2430
the cache doesn't contain the

1426
00:43:46,040 --> 00:43:48,140
0,480 480,990 990,1560 1560,1920 1950,2100
memory location x,| and it
|为了我们的方便，

1427
00:43:48,140 --> 00:43:49,070
0,330 330,510 510,690 690,840 840,930
turns out that for our

1428
00:43:49,070 --> 00:43:52,310
0,780 1200,1710 1740,2400 2400,2490 2490,3240
convenience,| Intel supplies an instruction,
|Intel 提供了一个名为 clFlash 的指令，

1429
00:43:53,590 --> 00:43:56,080
0,510 510,810 810,1260 1260,2010
{} called {clFlash -},|
|

1430
00:43:56,680 --> 00:43:57,370
0,210 210,330 330,510 510,570 570,690
and you give it an
你给它一个地址，

1431
00:43:57,370 --> 00:44:00,640
0,840 1350,1680 1680,1890 1890,2310 2520,3270
address| and it will {}
|并且它将删除，

1432
00:44:00,670 --> 00:44:01,960
0,420 420,600 600,990 990,1080 1080,1290
get rid of,| it will
|它将确保那个位置不会缓存，

1433
00:44:01,990 --> 00:44:04,060
0,600 600,930 1050,1410 1410,1680 1680,2070
ensure that {} that location

1434
00:44:04,060 --> 00:44:05,920
0,330 360,960 990,1560 1560,1800 1800,1860
is not cached any of

1435
00:44:05,920 --> 00:44:07,540
0,90 90,810 1200,1320 1320,1440 1440,1620
the caches,| and so that's
|所以这是非常方便的。

1436
00:44:07,540 --> 00:44:11,200
0,270 270,900 2820,3330 3330,3480 3480,3660
super convenient.| Even if the
|即使机器没有提供这条指令，

1437
00:44:11,200 --> 00:44:12,790
0,420 420,690 690,990 990,1170 1170,1590
machine didn't provide this instruction,|
|

1438
00:44:12,790 --> 00:44:13,660
0,120 120,210 210,510 510,690 690,870
that it turns out, there's
有很多方法可以从缓存中清除东西，

1439
00:44:13,660 --> 00:44:14,770
0,360 360,420 420,690 690,900 900,1110
ways of getting rid of

1440
00:44:14,770 --> 00:44:15,970
0,330 330,480 480,570 570,990 990,1200
stuff from the cache,| like
|比如，如果你知道缓存中保存 64 千字节，

1441
00:44:15,970 --> 00:44:16,990
0,90 90,570 600,810 810,930 930,1020
for example if you know

1442
00:44:16,990 --> 00:44:19,810
0,90 90,510 510,1140 1140,1920 1920,2820
the cache holds 64 kilobytes,|
|

1443
00:44:19,840 --> 00:44:22,330
0,660 960,1590 1740,2280 2280,2370 2370,2490
then it's likely to be
那么很可能的情况是，

1444
00:44:22,330 --> 00:44:23,170
0,90 90,480 480,630 630,720 720,840
the case,| that if you
|如果你加载 64 千字节的随机内存，

1445
00:44:23,170 --> 00:44:25,720
0,270 270,990 990,1530 1530,1710 1980,2550
load 64 kilobytes of random

1446
00:44:25,720 --> 00:44:26,760
0,690
memory,|
|

1447
00:44:26,760 --> 00:44:28,710
0,120 120,360 360,660 660,1590 1590,1950
{you,know} just load instructions that,|
只是加载指令，|

1448
00:44:29,010 --> 00:44:30,990
0,630 870,1410 1410,1500 1500,1620 1620,1980
{} those will be loaded
这些将被加载到缓存中，

1449
00:44:30,990 --> 00:44:32,940
0,180 180,270 270,1050 1260,1710 1710,1950
into the cache,| and after
|在将 64 千字节的新数据加载到缓存后，

1450
00:44:32,940 --> 00:44:34,350
0,150 150,390 390,840 840,1080 1080,1410
you've loaded 64 {kilobytes -}

1451
00:44:34,350 --> 00:44:35,160
0,90 90,270 270,510 510,720 720,810
of new data into the

1452
00:44:35,160 --> 00:44:37,050
0,600 1200,1560 1560,1650 1650,1830 1830,1890
cache,| everything that used to
|之前放在里面的东西肯定都不见了，

1453
00:44:37,050 --> 00:44:37,650
0,90 90,240 240,330 330,510 510,600
be in it must be

1454
00:44:37,650 --> 00:44:38,820
0,450 480,690 690,780 780,1050 1050,1170
gone,| because the cache can
|因为缓存只能容纳 64 千字节的大小。

1455
00:44:38,820 --> 00:44:40,380
0,180 180,540 540,960 960,1470 1470,1560
only hold 64 kilobytes or

1456
00:44:40,380 --> 00:44:41,970
0,300 300,360 360,480 480,750 1200,1590
whatever it may be.| So,
|所以即使没有这个指令，

1457
00:44:42,650 --> 00:44:44,540
0,270 270,570 570,900 900,1200 1200,1890
even without this [] instruction,|
|

1458
00:44:44,600 --> 00:44:46,310
0,270 270,360 360,810 930,1350 1350,1710
you can still flush everything
你仍然可以刷新缓存中的所有内容。

1459
00:44:46,310 --> 00:44:48,140
0,90 90,150 150,780 1350,1530 1530,1830
in the cache.| Then step
|那么第二步是，

1460
00:44:48,140 --> 00:44:50,150
0,300 300,900 1110,1440 1440,1770 1770,2010
two is,| you're interested in
|你感兴趣的是某段特定的代码是否使用了数据 x ，

1461
00:44:50,360 --> 00:44:51,470
0,240 240,360 360,810 810,1020 1020,1110
whether some particular piece of

1462
00:44:51,470 --> 00:44:54,770
0,690 870,1740 1770,2190 2460,2970 2970,3300
code uses {} data x,|
|

1463
00:44:54,770 --> 00:44:56,000
0,90 90,270 270,480 480,660 660,1230
you just call that code
你只需要调用那个代码，

1464
00:44:56,150 --> 00:44:57,540
0,360 360,420 420,990
whatever it is,|
|

1465
00:44:57,920 --> 00:44:59,180
0,780 780,870 870,1080 1080,1170 1170,1260
and it does what it
它所做的事情，可能使用 x ，也可能不使用，

1466
00:44:59,180 --> 00:45:01,040
0,540 540,780 780,1170 1170,1650 1650,1860
does maybe uses x, maybe

1467
00:45:01,040 --> 00:45:02,140
0,540
doesn't,|
|

1468
00:45:02,590 --> 00:45:05,170
0,720 1560,1890 1890,2010 2010,2190 2190,2580
{} now you wanna tell
现在你想要确认 x 是否在缓存中，

1469
00:45:05,170 --> 00:45:06,100
0,390 390,480 480,780 780,840 840,930
{if,x} is actually in the

1470
00:45:06,100 --> 00:45:07,570
0,570 570,750 750,840 840,930 930,1470
cache,| because if it is
|因为是，你刷新缓存，

1471
00:45:07,600 --> 00:45:08,380
0,180 180,270 270,570 570,720 720,780
if you flushed from the

1472
00:45:08,380 --> 00:45:09,400
0,600 630,750 750,870 870,960 960,1020
cache,| if it's in the
|如果它现在在缓存里，

1473
00:45:09,400 --> 00:45:10,540
0,300 300,570 570,660 660,870 870,1140
cache now,| it must be
|一定是 f 导致加载，

1474
00:45:10,540 --> 00:45:11,620
0,210 300,600 600,900 900,990 990,1080
that f causes to be

1475
00:45:11,620 --> 00:45:12,640
0,510
loaded,|
|

1476
00:45:12,670 --> 00:45:13,660
0,240 240,450 450,660 660,750 750,990
unless something else is going
除非有其他事情发生。

1477
00:45:13,660 --> 00:45:15,940
0,240 480,1170 1350,1800 1830,2070 2070,2280
on.| {} So you need
|所以你需要加载，

1478
00:45:15,940 --> 00:45:16,540
0,120 120,270 270,420 420,480 480,600
to, you want to do

1479
00:45:16,540 --> 00:45:17,500
0,90 90,630 630,750 750,840 840,960
a load,| but you wanna
|但是你想知道加载需要多长时间，

1480
00:45:17,500 --> 00:45:18,460
0,90 90,330 330,600 600,690 690,960
know how long the load

1481
00:45:18,460 --> 00:45:20,860
0,660 990,1380 1650,1920 1920,2070 2070,2400
takes,| so we're only talking
|所以我们说的是纳秒，

1482
00:45:20,860 --> 00:45:22,810
0,180 180,840 840,1050 1050,1350 1350,1950
about nanoseconds,| like five nanoseconds
|比如 5 纳秒对比 100 纳秒，

1483
00:45:22,810 --> 00:45:24,640
0,330 330,660 660,1230 1230,1500 1500,1830
versus hundred nanoseconds here,| how
|我们怎样才能如此精确地测量时间，

1484
00:45:24,640 --> 00:45:25,570
0,120 120,240 240,510 510,780 780,930
can we measure time that

1485
00:45:25,570 --> 00:45:29,170
0,630 810,1320 1320,1590 2880,3090 3090,3600
accurately,| that's a tough assignment,|
|这是一项艰巨的任务，|

1486
00:45:29,170 --> 00:45:31,840
0,420 420,990 1440,1920 2130,2610 2610,2670
however again the {CPUs -}
然而， CPU 再次来到 [ra] ，

1487
00:45:31,840 --> 00:45:32,740
0,180 180,270 270,330 330,720 720,900
come {to -} {} [ra],|
|

1488
00:45:32,740 --> 00:45:34,660
0,90 90,540 540,930 930,1680 1710,1920
in fact provide instruction which
提供了获取周期粒度时间的指令，

1489
00:45:34,660 --> 00:45:37,360
0,210 210,510 690,1350 1350,2130 2130,2700
gives you cycle granularity time,|
|

1490
00:45:38,260 --> 00:45:39,440
0,510

1491
00:45:39,620 --> 00:45:40,520
0,210 210,300 300,570 570,720 720,900
and it's called {rdtsc -
它叫做 rdtsc ，

1492
00:45:40,520 --> 00:45:41,980
0,240 240,360 360,840
- - -},|
|

1493
00:45:42,010 --> 00:45:43,580
0,180 180,270 270,450 450,990
so we're just gonna
所以我们只需要执行 rdtsc 指令，

1494
00:45:44,980 --> 00:45:46,480
0,480 480,570 570,780 780,1260 1260,1500
execute the {rdtsc - -}

1495
00:45:46,480 --> 00:45:48,370
0,660 690,900 900,1140 1140,1410 1440,1890
instruction,| which tells us essentially
|它告诉我们已经过去的周期数，

1496
00:45:48,370 --> 00:45:49,360
0,120 120,360 360,450 450,900 900,990
the number of cycles that

1497
00:45:49,360 --> 00:45:51,580
0,90 90,780 780,1320 1320,1830 1860,2220
have elapsed,| since the machine
|从机器启动以来已经过去的机器周期。

1498
00:45:51,580 --> 00:45:52,780
0,420 420,570 570,930 930,1110 1110,1200
cycles have elapsed since the

1499
00:45:52,780 --> 00:45:54,160
0,300 300,840
machine started.|
|

1500
00:45:54,330 --> 00:45:55,290
0,150 150,360 360,480 480,840 840,960
And since it's probably {}
如果它是 2GHz 的机器，

1501
00:45:55,290 --> 00:45:56,790
0,330 330,600 600,840 840,1290 1290,1500
2 {GHz -} machine,| that
|这意味着，我们这里的精确度是 0.5 纳秒，

1502
00:45:56,790 --> 00:45:58,320
0,240 240,360 360,480 960,1440 1440,1530
means that the precision we

1503
00:45:58,320 --> 00:45:59,520
0,180 180,420 420,600 660,1170 1170,1200
have here is half a

1504
00:45:59,520 --> 00:46:00,660
0,600
nanosecond,|
|

1505
00:46:00,830 --> 00:46:02,300
0,330 330,990
its {pretty,small}.|
它相当小。|

1506
00:46:02,360 --> 00:46:04,850
0,720 990,1440 1440,1560 1560,1710 1710,2490
{} Now we're gonna load,|
现在我们要加载，|

1507
00:46:06,500 --> 00:46:07,940
0,840
{}
比如 junk = *x ，

1508
00:46:07,940 --> 00:46:10,610
0,150 150,360 360,510 510,1230 1620,2670
we're just gonna say junk

1509
00:46:10,850 --> 00:46:13,240
0,750 750,1860
equals star

1510
00:46:13,240 --> 00:46:14,800
0,600 630,870 870,990 990,1050 1050,1560
x,| we're going to load
|我们要加载位置 x 的数据，

1511
00:46:14,800 --> 00:46:17,860
0,240 1170,1680 1680,1890 1890,2310 2310,3060
the data of location x,|
|

1512
00:46:18,250 --> 00:46:19,690
0,360 360,510 510,570 570,780 780,1440
I get the time again,|
我再获取一下时间，|

1513
00:46:23,300 --> 00:46:24,470
0,180 180,330 330,390 390,450 450,1170
and look at the difference
看一下 b 减去 a 的差值，

1514
00:46:24,800 --> 00:46:27,400
0,660 870,1140 1140,1530 1530,1950
right, b minus a,|
|

1515
00:46:29,450 --> 00:46:30,560
0,210 210,390 390,720 720,930 930,1110
if b minus a is
如果 b 减去 a 等于 5 、 6 、 7 或其他，

1516
00:46:30,560 --> 00:46:31,880
0,90 90,210 210,690 690,720 720,1320
you know 5 or 6

1517
00:46:31,880 --> 00:46:33,620
0,90 90,450 450,540 540,1170 1410,1740
or 7 or something {},|
|

1518
00:46:33,620 --> 00:46:35,660
0,210 210,570 570,1230 1260,1710 1740,2040
that means that this load
这意味着这个加载命中了缓存，

1519
00:46:35,660 --> 00:46:36,650
0,180 180,240 240,330 330,870 870,990
hit in the cache,| and
|这意味着这个函数使用了数据，

1520
00:46:36,650 --> 00:46:37,940
0,150 150,390 390,570 750,930 930,1290
that means that this function

1521
00:46:37,940 --> 00:46:39,260
0,210 210,270 270,660 930,1170 1170,1320
used the data,| if b
|如果 b 减去 a 是 150 ，

1522
00:46:39,260 --> 00:46:41,680
0,330 330,570 570,990 990,1920
minus a is 150,|
|

1523
00:46:41,930 --> 00:46:43,940
0,660 720,930 930,1140 1140,1440 1440,2010
then {} that means that
则意味着 x 不在缓存中，

1524
00:46:43,970 --> 00:46:45,530
0,330 330,630 630,720 720,780 780,1560
x wasn't in the cache,|
|

1525
00:46:45,980 --> 00:46:47,320
0,720
and
这可能意味着 f ，

1526
00:46:47,800 --> 00:46:49,480
0,270 270,390 390,720 750,1080 1170,1680
yeah you know that may

1527
00:46:49,480 --> 00:46:50,710
0,360 360,570 570,720 720,930 930,1230
probably means that f,| that
|这可能意味着 f 从未使用过 x ，

1528
00:46:50,710 --> 00:46:51,910
0,180 180,480 480,720 720,900 900,1200
may mean that did never

1529
00:46:51,910 --> 00:46:53,800
0,270 270,750 780,1230 1230,1410 1560,1890
used x,| that's not quite
|这并不完全是一成不变的，

1530
00:46:53,800 --> 00:46:54,940
0,210 210,390 390,480 480,720 720,1140
that cut and dry,| because
|因为 f 可能使用了 x ，然后使用了其他东西，

1531
00:46:55,000 --> 00:46:56,350
0,300 300,480 480,570 570,870 870,1350
f might have used x

1532
00:46:56,350 --> 00:46:57,970
0,120 120,270 270,450 450,870 870,1620
and then use something else,|
|

1533
00:46:58,330 --> 00:47:00,460
0,570 900,1200 1200,1710 1710,1890 1890,2130
{} that conflicted with x
与缓存中的 x 冲突，

1534
00:47:00,460 --> 00:47:01,300
0,60 60,120 120,480 480,570 570,840
in the cache| and caused
|并且使 x 被踢出缓存。

1535
00:47:01,300 --> 00:47:02,650
0,270 270,390 390,780 930,1230 1230,1350
x to be kicked out

1536
00:47:02,650 --> 00:47:04,210
0,60 60,150 150,420 420,810 930,1560
of the cache again.| But,
|但是，对于简单的情况，

1537
00:47:04,210 --> 00:47:06,820
0,120 120,360 360,1260
for simple situations,|
|

1538
00:47:06,910 --> 00:47:08,380
0,300 300,480 480,960 960,1410 1410,1470
a very large value of
b 减去 a 的值非常大，意味着 f 没有使用它，

1539
00:47:08,380 --> 00:47:10,360
0,120 120,420 420,510 510,1320 1500,1980
b minus a, means f

1540
00:47:10,540 --> 00:47:11,680
0,360 360,540 540,720 720,900 900,1140
didn't use it,| in a
|在 b 减去 a 的较小值中，表示 f 使用了那个数据。

1541
00:47:11,710 --> 00:47:14,020
0,870 1260,1800 1800,1860 1860,1980 1980,2310
small value of b minus

1542
00:47:14,020 --> 00:47:15,040
0,120 120,360 360,480 480,810 810,1020
a, means that f did

1543
00:47:15,040 --> 00:47:16,280
0,150 150,330 330,630
use that data.|
|

1544
00:47:18,070 --> 00:47:19,330
0,330 330,570 570,660 660,1200 1200,1260
So this is not an
所以这还不是攻击，

1545
00:47:19,330 --> 00:47:21,430
0,390 390,570 570,870 870,1440 1800,2100
attack yet,| because again {}
|因为我们必须能够访问这个内存，

1546
00:47:21,430 --> 00:47:22,240
0,150 150,300 300,420 420,540 540,810
we have to be able

1547
00:47:22,240 --> 00:47:24,760
0,420 420,930 1350,1860 1860,2040 2040,2520
to {} access this memory,|
|

1548
00:47:24,760 --> 00:47:26,230
0,360 540,690 690,780 780,930 930,1470
so this is our memory.|
这是我们的内存。|

1549
00:47:28,290 --> 00:47:30,780
0,270 270,630 630,1020 1020,1920 2130,2490
Any questions about flush plus
关于刷新并重新加载，有什么问题吗？

1550
00:47:30,780 --> 00:47:32,320
0,780
reload?|
|

1551
00:47:40,340 --> 00:47:41,560
0,660
Alright,
好的，我想这是所有的准备工作，

1552
00:47:42,010 --> 00:47:43,120
0,570 570,630 630,780 780,930 930,1110
{} I think that's all

1553
00:47:43,120 --> 00:47:45,550
0,90 90,1020 1350,1950 2010,2340 2340,2430
the preliminaries,| {} let's go
|让我们回到 meltdown 。

1554
00:47:45,550 --> 00:47:47,480
0,180 180,270 270,810
back to meltdown.|
|

1555
00:47:48,910 --> 00:47:49,930
0,360 360,600 600,720 720,750 750,1020
So this is a more
所以这是一个更完整的版本，

1556
00:47:49,930 --> 00:47:51,880
0,720 750,1110 1110,1410 1410,1560 1560,1950
full version,| {I,showed} you {}
|我在开始时向你们展示的 meltdown 的关键，

1557
00:47:52,000 --> 00:47:53,260
0,330 330,390 390,750 750,1170 1170,1260
sort of core meltdown at

1558
00:47:53,260 --> 00:47:54,430
0,90 90,540 660,990 990,1110 1110,1170
the beginning,| this is a
|这是一个更完整的 meltdown 。

1559
00:47:54,430 --> 00:47:56,680
0,540 690,990 990,1710
more {} complete

1560
00:47:56,680 --> 00:47:57,880
0,600
meltdown.|
|

1561
00:47:57,880 --> 00:47:59,140
0,690

1562
00:47:59,690 --> 00:48:00,980
0,150 150,420 450,690 690,900 900,1290
And so we actually now
所以现在我增加了刷新并重新加载的部分。

1563
00:48:00,980 --> 00:48:02,000
0,210 210,360 360,660 660,750 750,1020
have I added the {flush,and}

1564
00:48:02,000 --> 00:48:04,320
0,420 420,960
reload part.|
|

1565
00:48:04,380 --> 00:48:05,430
0,360 360,420 420,540 540,690 690,1050
Again, we're going to declare
同样，我们再次声明这个 buf ，

1566
00:48:05,430 --> 00:48:08,070
0,180 180,720 780,1320 1560,2070 2490,2640
this buffer,| and {} the
|我们的想法是，

1567
00:48:08,070 --> 00:48:10,170
0,300 300,420 420,870 1020,1800 1800,2100
idea is that,| depending on
|我们只从内核中取出一位，

1568
00:48:10,200 --> 00:48:11,340
0,150 150,330 330,660 660,870 870,1140
we're gonna be just fetching

1569
00:48:11,340 --> 00:48:13,050
0,630 630,930 930,1110 1110,1170 1170,1710
one bit from the kernel,|
|

1570
00:48:13,200 --> 00:48:15,840
0,810 1410,1980 1980,2040 2040,2460 2460,2640
{} {we're,going} to multiply that
我们要把这一位乘以 4096 ，

1571
00:48:15,840 --> 00:48:17,520
0,210 210,360 360,480 480,1530 1530,1680
one bit by 4096,| so
|所以我们希望使用刷新并重新加载，

1572
00:48:17,520 --> 00:48:18,570
0,90 90,480 480,540 540,780 780,1050
we're hoping to use flush

1573
00:48:18,570 --> 00:48:19,830
0,270 270,870 870,990 990,1140 1140,1260
plus reload| to see that
|来查看 buf 0 在缓存中，

1574
00:48:19,830 --> 00:48:21,570
0,270 270,510 510,630 630,1320 1590,1740
either buf of 0 is

1575
00:48:21,570 --> 00:48:22,560
0,90 90,150 150,540 540,750 750,990
in the cache| or buffer
|或 buf 4096 在缓存中，

1576
00:48:22,560 --> 00:48:24,090
0,90 90,1290 1290,1410 1410,1470 1470,1530
of 4096 is in the

1577
00:48:24,090 --> 00:48:26,160
0,450 600,840 840,900 900,1380 1740,2070
cache,| and the reason for
|之所以会有很大的分离，

1578
00:48:26,160 --> 00:48:29,130
0,180 210,750 750,1500 1500,1950 2370,2970
the large separation there {}|
|

1579
00:48:30,280 --> 00:48:31,870
0,150 150,270 270,660 660,780 780,1590
is that apparently the pref-,
是因为这个硬件有一个预取器，

1580
00:48:32,050 --> 00:48:33,550
0,240 240,510 510,780 810,930 930,1500
this hardware has a prefetcher

1581
00:48:33,550 --> 00:48:34,030
0,90 90,150 150,270 270,360 360,480
in it,| so if you
|所以，如果你从内存加载一个内容，

1582
00:48:34,030 --> 00:48:35,560
0,210 210,450 450,840 840,1020 1020,1530
load one thing from memory,|
|

1583
00:48:35,770 --> 00:48:36,910
0,210 210,570 570,870 870,930 930,1140
it will load the next
它也会从内存加载下一部分内容，

1584
00:48:36,910 --> 00:48:37,960
0,210 210,390 390,510 510,660 660,1050
couple things up from memory

1585
00:48:37,960 --> 00:48:38,800
0,330 360,420 420,600 600,780 780,840
too,| the next couple of
|下一部分缓存行，

1586
00:48:38,800 --> 00:48:40,180
0,300 300,780 960,1170 1170,1290 1290,1380
cache lines,| and so we
|所以我们不能有两个不同的缓存行，

1587
00:48:40,180 --> 00:48:41,710
0,330 330,480 480,570 570,930 930,1530
can't have the two different

1588
00:48:41,710 --> 00:48:43,390
0,390 390,1080 1110,1410 1410,1560 1560,1680
cache lines,| that we're going
|我们在特别近的地方进行刷新和重新加载，

1589
00:48:43,390 --> 00:48:44,500
0,60 60,300 300,660 660,780 780,1110
to apply flush and reload

1590
00:48:44,500 --> 00:48:45,490
0,90 90,330 330,420 420,570 570,990
to be to be particularly

1591
00:48:45,490 --> 00:48:46,560
0,660
close,|
|

1592
00:48:46,560 --> 00:48:47,310
0,150 150,270 270,360 360,600 600,750
need to be far enough
需要距离足够远，

1593
00:48:47,310 --> 00:48:49,350
0,420 420,600 750,1050 1050,1560 1620,2040
apart,| that even prefetch, hardware
|即使是硬件预加载也不会造成困惑。

1594
00:48:49,350 --> 00:48:52,320
0,180 180,540 540,870 2070,2430 2430,2970
{prefetching -} won't cause confusion.|
|

1595
00:48:53,030 --> 00:48:53,780
0,330 330,390 390,570 570,630 630,750
So we put the whole
所以我们把整个论文分开，

1596
00:48:53,780 --> 00:48:55,220
0,240 240,750
page apart,|
|

1597
00:48:55,760 --> 00:48:56,930
0,120 120,390 390,660 660,990 1020,1170
the flash part now,| we
现在是刷新部分，|我们只是调用这个 clflush 指令

1598
00:48:56,930 --> 00:48:58,070
0,180 180,330 330,480 480,840 840,1140
just call this {clflush -}

1599
00:48:58,070 --> 00:49:00,290
0,780 990,1200 1380,1770 1770,2010 2010,2220
instruction| to make sure that
|确保 buf 的相关部分没有被缓存。

1600
00:49:00,980 --> 00:49:02,930
0,270 270,630 960,1380 1380,1740 1740,1950
{} the relevant parts of

1601
00:49:02,990 --> 00:49:04,460
0,270 270,870
our buf

1602
00:49:04,980 --> 00:49:06,520
0,150 150,330 330,990
are not catched.|
|

1603
00:49:06,700 --> 00:49:09,060
0,840
Now,
现在，我们利用，

1604
00:49:12,330 --> 00:49:13,740
0,720
{}

1605
00:49:18,300 --> 00:49:20,250
0,210 210,1170 1200,1410 1410,1620 1620,1950
we're exploiting,| this line 7
|第 7 行可能不是必要的，

1606
00:49:20,250 --> 00:49:21,870
0,150 150,450 480,1170 1290,1560 1560,1620
is not maybe may or

1607
00:49:21,870 --> 00:49:23,070
0,90 90,270 270,360 360,930 930,1200
may not be necessary,| but
|但这里发生的事情是，我们正在利用，

1608
00:49:23,100 --> 00:49:25,590
0,1020 1230,1980 1980,2160 2160,2310 2310,2490
what what's going on here

1609
00:49:25,590 --> 00:49:26,700
0,120 120,300 300,810 810,930 930,1110
is we're exploiting this sort

1610
00:49:26,700 --> 00:49:29,430
0,150 660,1140 1380,2190 2310,2670 2670,2730
of,| {} I'm going to
|我将利用这段时间的空隙，

1611
00:49:29,430 --> 00:49:31,320
0,90 90,960 1020,1290 1290,1710 1710,1890
be exploiting the gap in

1612
00:49:31,320 --> 00:49:32,740
0,930
time

1613
00:49:33,620 --> 00:49:35,600
0,330 330,1380
{} between,|
|

1614
00:49:36,030 --> 00:49:37,800
0,150 150,660 690,1170
{you,know}, we {}
我们做这个第 10 行的加载内核地址，

1615
00:49:38,000 --> 00:49:40,430
0,240 240,390 390,1110 1470,1800 1800,2430
{we're,doing} this load line 10

1616
00:49:40,460 --> 00:49:41,780
0,120 120,510 510,570 570,930 930,1320
to load a kernel address,|
|

1617
00:49:41,780 --> 00:49:43,970
0,120 120,300 300,510 510,1080 1920,2190
so it's gonna fault,| but
但是它会出错，|但是我们希望能够预测执行其他指令，

1618
00:49:43,970 --> 00:49:44,840
0,120 120,570 570,630 630,720 720,870
we're hoping to be able

1619
00:49:44,840 --> 00:49:46,100
0,60 60,450 450,690 690,1170 1170,1260
to execute another couple of

1620
00:49:46,100 --> 00:49:50,090
0,990 990,1890 1980,2640 3330,3600 3600,3990
instructions speculatively,| before this instruction
|在这条指令退出之前，

1621
00:49:50,090 --> 00:49:51,830
0,150 150,1050 1140,1350 1350,1620 1620,1740
is retired,| and before it
|在它引发故障并取消这些指令之前，

1622
00:49:51,860 --> 00:49:53,300
0,510 510,900 900,1020 1020,1320 1320,1440
actually raises the fault and

1623
00:49:53,300 --> 00:49:55,880
0,930 1050,1380 1380,2040 2040,2220 2310,2580
cancels these instructions, right,| if
|如果这个负载退出，

1624
00:49:55,880 --> 00:49:57,710
0,120 120,810 870,1200 1290,1560 1560,1830
the fault if this load

1625
00:49:57,710 --> 00:49:59,240
0,210 210,420 420,1170 1170,1410 1410,1530
would be retired,| say at
|比如在这一点上，

1626
00:49:59,240 --> 00:50:00,700
0,330 330,1050
this point,|
|

1627
00:50:00,700 --> 00:50:01,780
0,240 240,330 330,420 420,720 720,1080
that would be too early
那对我们来说太早了，

1628
00:50:01,780 --> 00:50:03,190
0,300 300,660 840,1170 1170,1290 1290,1410
for us,| because it's going
|因为我们需要预测执行第 13 行，

1629
00:50:03,190 --> 00:50:03,940
0,60 60,300 300,420 420,510 510,750
to turn out we actually

1630
00:50:03,940 --> 00:50:05,590
0,600 600,870 870,1440 1440,1530 1530,1650
need line 13 to be

1631
00:50:05,590 --> 00:50:07,990
0,900 900,1650 1920,2100 2100,2310 2310,2400
speculatively executed| in order to
|才能完成攻击，

1632
00:50:07,990 --> 00:50:09,880
0,360 360,450 450,990 1170,1590 1650,1890
complete the attack,| so we
|所以，我们希望确保

1633
00:50:09,880 --> 00:50:10,780
0,150 150,210 210,420 420,750 750,900
want to make sure that|
|

1634
00:50:10,780 --> 00:50:13,300
0,210 210,660 660,960 990,2190 2220,2520
this load isn't retired for
这个加载不会退出，时间越长越好，

1635
00:50:13,300 --> 00:50:14,940
0,150 150,420 420,570 570,1170
as long as possible,|
|

1636
00:50:15,150 --> 00:50:16,650
0,150 150,420 420,600 990,1380 1380,1500
in order to delay the
以延迟故障和延迟预测取消。

1637
00:50:16,650 --> 00:50:18,440
0,390 390,480 480,900 900,1170
fault and delay the

1638
00:50:18,530 --> 00:50:20,840
0,240 240,780 780,1590 1950,2190 2190,2310
{} speculative cancellation.| Now we
|我们知道指令不会在所有之前的指令都退出之前退出，

1639
00:50:20,840 --> 00:50:22,640
0,300 300,780 780,930 930,1530 1530,1800
know instructions aren't retired until

1640
00:50:22,640 --> 00:50:24,920
0,270 270,900 900,1410 1410,1530 1530,2280
all previous instructions have retired,|
|

1641
00:50:25,400 --> 00:50:26,480
0,120 120,240 240,300 300,390 390,1080
it's one of the rules.|
这是规则之一。|

1642
00:50:27,090 --> 00:50:28,860
0,360 480,690 690,900 900,1470 1530,1770
So at line 7,| I'm
所以在第 7 行，|我们将使用一些昂贵的指令，

1643
00:50:28,860 --> 00:50:30,450
0,720 840,1290 1290,1410 1410,1530 1530,1590
imagining that we're going to

1644
00:50:30,450 --> 00:50:32,100
0,270 270,600 600,1110 1110,1560 1560,1650
launch some expensive instruction,| that
|这些指令很长一段时间内都不会完成，

1645
00:50:32,100 --> 00:50:33,120
0,240 240,600 600,720 720,750 750,1020
doesn't complete for a long

1646
00:50:33,120 --> 00:50:34,800
0,480 720,1080 1080,1170 1170,1410 1410,1680
time,| maybe it loads something
|也许它加载其他已知必须来自内存的内容，

1647
00:50:34,800 --> 00:50:36,270
0,360 360,540 540,900 900,1230 1260,1470
else that's known to have

1648
00:50:36,270 --> 00:50:37,230
0,120 120,300 300,450 450,840 840,960
to come from RAM,| so
|所以这需要几百个周期，

1649
00:50:37,230 --> 00:50:38,130
0,120 120,330 330,480 480,630 630,900
it'll take a few hundred

1650
00:50:38,130 --> 00:50:39,480
0,450 450,600 810,1140 1140,1200 1200,1350
cycles,| or maybe it does
|或者它做除法或平方根之类的，

1651
00:50:39,480 --> 00:50:41,280
0,60 60,960 960,1020 1020,1470 1470,1800
a {divide,or} a square root

1652
00:50:41,280 --> 00:50:42,330
0,60 60,480 480,600 600,780 780,1050
or something,| who knows what
|无论什么需要很长时间的事情，

1653
00:50:42,510 --> 00:50:43,500
0,390 390,510 510,690 690,750 750,990
something that takes a long

1654
00:50:43,500 --> 00:50:45,390
0,480 570,750 750,990 990,1140 1140,1890
time,| it won't be retired
|它在很长一段时间内都不会退出，

1655
00:50:45,390 --> 00:50:46,830
0,150 150,210 210,480 480,930 1140,1440
for a long time,| and
|因此导致这个负载在很长一段时间内不会退出，

1656
00:50:46,830 --> 00:50:48,180
0,300 300,450 450,750 750,960 960,1350
therefore will cause this load

1657
00:50:48,210 --> 00:50:49,530
0,390 390,480 480,630 630,1200 1200,1320
not to be retired for

1658
00:50:49,530 --> 00:50:51,240
0,30 30,270 270,810 1020,1440 1440,1710
a long time,| giving these
|让这些指令有时间预测执行。

1659
00:50:51,240 --> 00:50:53,940
0,750 870,1170 1170,1260 1260,1740 1740,2700
instructions time to execute speculatively.|
|

1660
00:50:57,420 --> 00:50:59,010
0,210 210,630 900,1020 1020,1350 1350,1590
Right, now we're assuming again,|
好的，现在我们再次假设，|

1661
00:50:59,010 --> 00:51:01,050
0,90 90,540 720,1140 1140,1470 1470,2040
we have a virtual address
我们在内核中有一个虚拟地址，

1662
00:51:01,050 --> 00:51:03,920
0,150 150,210 210,780
in the kernel,|
|

1663
00:51:04,680 --> 00:51:06,960
0,450 840,1050 1050,1440 1440,1680 1680,2280
{} gonna execute line 10,|
执行第 10 行，|

1664
00:51:07,140 --> 00:51:08,190
0,450 450,660 660,810 810,990 990,1050
line ten won't raise a
第 10 行不会出现错误，

1665
00:51:08,190 --> 00:51:09,660
0,390 390,720 720,960 960,1290 1320,1470
fault, until that,| {} we
|我们知道它会出现错误，

1666
00:51:09,660 --> 00:51:10,350
0,150 150,300 300,420 420,480 480,690
know it's going to raise

1667
00:51:10,350 --> 00:51:11,010
0,60 60,240 240,450 450,600 600,660
a fault,| won't raise a
|但是退出前不会出现错误，

1668
00:51:11,010 --> 00:51:13,440
0,240 240,510 510,1110 1110,1350 1530,2430
fault until retires,| but we're
|但是我们已经设置好了，

1669
00:51:13,470 --> 00:51:15,000
0,510 510,720 900,1230 1230,1380 1380,1530
intending, we believe we've set

1670
00:51:15,000 --> 00:51:15,990
0,210 210,300 300,420 420,570 570,990
things up,| so won't retire
|所以暂时不会退出，因为它还没有退出，

1671
00:51:15,990 --> 00:51:17,010
0,120 120,510 540,750 750,840 840,1020
for {a,while}, since it hasn't

1672
00:51:17,010 --> 00:51:19,380
0,630 1380,1620 1620,1890 1890,2040 2040,2370
retired,| and because on Intel
|而且因为在 Intel CPU 上，

1673
00:51:19,380 --> 00:51:20,970
0,630 630,810 930,1230 1230,1470 1470,1590
{CPUs -},| the data is
|即使你不被允许查看，数据也会返回，

1674
00:51:20,970 --> 00:51:22,830
0,750 1110,1410 1410,1560 1560,1650 1650,1860
returned, even if you weren't

1675
00:51:22,830 --> 00:51:24,060
0,270 270,330 330,600 600,960 1110,1230
allowed to see it,| the
|数据返回用于预测执行，

1676
00:51:24,060 --> 00:51:24,900
0,360
data

1677
00:51:25,150 --> 00:51:27,100
0,450 450,540 540,1110 1110,1680 1680,1950
return for speculative execution,| even
|即使你没有权限，

1678
00:51:27,100 --> 00:51:28,270
0,120 120,210 210,330 330,510 510,1170
if you did not permission,|
|

1679
00:51:28,840 --> 00:51:30,400
0,450 450,660 660,870 1080,1440 1440,1560
that means that we can
这意味着我们可以预测执行，

1680
00:51:30,400 --> 00:51:32,860
0,870 870,1650 1920,2010 2010,2340 2340,2460
speculatively execute,| the machine will
|机器将预测执行第 11 行，

1681
00:51:32,860 --> 00:51:34,510
0,630 630,1020 1020,1200 1200,1560 1560,1650
speculatively execute line 11| and
|并获得内核数据的低位，

1682
00:51:34,510 --> 00:51:35,560
0,120 120,210 210,480 480,750 750,1050
get the low bit of

1683
00:51:36,450 --> 00:51:38,730
0,360 360,690 690,1110 1590,2160 2160,2280
kernel data now,| multiplied by
|乘以 4096 ，

1684
00:51:38,730 --> 00:51:41,910
0,1410 1620,2220 2220,2640 2640,2760 2760,3180
4096,| line 13 is itself
|第 13 行是另一个加载，

1685
00:51:41,910 --> 00:51:43,770
0,60 60,630 630,750 750,1140 1140,1860
a load, it's another load,|
|

1686
00:51:44,570 --> 00:51:46,850
0,510 810,1260 1260,1380 1380,1920 1920,2280
{} using an address basically
使用 buf 的地址加上 r2 的内容的地址，

1687
00:51:46,850 --> 00:51:48,700
0,150 150,480 480,630 630,1290
the address of buf

1688
00:51:48,850 --> 00:51:50,320
0,720 720,810 810,1200 1200,1290 1290,1470
plus the contents of {r2

1689
00:51:50,320 --> 00:51:51,420
0,480
-},|
|

1690
00:51:51,570 --> 00:51:52,980
0,450 660,930 930,1140 1140,1290 1290,1410
{} we know it's going
我们知道它会被取消，

1691
00:51:52,980 --> 00:51:54,980
0,60 60,300 540,1530
to get cancelled,|
|

1692
00:51:55,160 --> 00:51:56,390
0,270 270,780 810,960 960,1080 1080,1230
{} because we know this
因为我们知道这个会产生错误，

1693
00:51:56,390 --> 00:51:57,950
0,120 120,780 930,1230 1230,1350 1350,1560
will fault, right,| we know
|我们知道对 r3 的写入会被取消，

1694
00:51:57,950 --> 00:51:59,720
0,180 180,810 810,1290 1290,1380 1380,1770
the actual write to r3

1695
00:51:59,720 --> 00:52:00,980
0,150 150,240 240,720 750,1050 1050,1260
will be cancelled,| but line
|但是第 13 行将导致来自 buf 的一些数据加载到缓存中，

1696
00:52:00,980 --> 00:52:04,180
0,780 810,1170 1170,2280
13 will cause

1697
00:52:04,450 --> 00:52:05,820
0,750
{}

1698
00:52:06,280 --> 00:52:07,540
0,450 450,750 750,900 900,1200 1200,1260
some data from buf to

1699
00:52:07,540 --> 00:52:09,250
0,120 120,510 510,660 660,780 780,1710
be loaded into the cache,|
|

1700
00:52:09,520 --> 00:52:10,630
0,270 270,360 360,450 450,840 840,1110
even if it doesn't end
即使它最终不会影响到寄存器 3 ，

1701
00:52:10,630 --> 00:52:12,850
0,180 180,780 810,1290 1290,1770 1860,2220
up affecting register 3,| so
|所以，第 13 行将导致某些内容被加载到缓存中，

1702
00:52:13,060 --> 00:52:14,740
0,600 900,1140 1140,1470 1470,1560 1560,1680
r3, line 13 is going

1703
00:52:14,740 --> 00:52:16,750
0,120 120,1440 1470,1830 1830,1920 1920,2010
to cause something to be

1704
00:52:16,750 --> 00:52:18,340
0,270 270,420 420,510 510,1110 1350,1590
loaded into the cache,| and
|这取决于低位是否为 0 或 1 ，

1705
00:52:18,340 --> 00:52:19,750
0,120 120,480 480,870 870,990 990,1410
this case depending on whether

1706
00:52:19,750 --> 00:52:20,740
0,180 180,360 360,510 510,630 630,990
the low bit is 0

1707
00:52:20,740 --> 00:52:23,680
0,510 1140,1650 1740,2310 2310,2760 2760,2940
{or,1},| {} line 13 will
|第 13 行将导致缓存包含 buf 0 或 buf 4096 ，

1708
00:52:23,770 --> 00:52:25,150
0,420 420,540 540,870 870,1290 1290,1380
cause the actual cache to

1709
00:52:25,150 --> 00:52:26,830
0,330 330,690 690,1020 1020,1410 1410,1680
contain either buf 0 or

1710
00:52:26,830 --> 00:52:29,000
0,330 330,1830
buf 4096,|
|

1711
00:52:30,010 --> 00:52:31,300
0,690
then,
然后，

1712
00:52:31,960 --> 00:52:33,880
0,240 240,630 870,1290 1500,1740 1740,1920
right, then that,| even though
|即使 r2 和 r3 已经取消，

1713
00:52:33,880 --> 00:52:34,870
0,150 150,330 330,420 420,780 780,990
{r2 -} and r3 are

1714
00:52:34,870 --> 00:52:37,540
0,570 630,1200 1890,2520 2520,2610 2610,2670
cancelled,| the change in the
|变化会在缓存中，

1715
00:52:37,540 --> 00:52:39,130
0,660 690,1170 1170,1260 1260,1530 1530,1590
cache,| because it's supposed to
|因为假设它是隐藏的微架构状态，

1716
00:52:39,130 --> 00:52:40,600
0,90 90,360 360,660 660,1170 1170,1470
be hidden {micro-architectural -} state,|
|

1717
00:52:40,600 --> 00:52:42,100
0,150 150,420 420,840 840,1260 1350,1500
that will actually be the
实际上，缓存会被修改。

1718
00:52:42,100 --> 00:52:44,060
0,450 450,570 570,690 690,1320
cache will be changed.|
|

1719
00:52:44,680 --> 00:52:45,760
0,510 510,600 600,780 780,1020 1020,1080
Finally, at some point, the
最后，在某个时刻，错误将会发生，

1720
00:52:45,760 --> 00:52:47,890
0,270 270,360 360,840 1230,1740 1920,2130
fault will happen,| {} and
|我们需要在错误后进行恢复，

1721
00:52:47,890 --> 00:52:49,360
0,90 90,330 330,870 900,1410 1410,1470
we need to sort of

1722
00:52:49,360 --> 00:52:51,160
0,510 510,780 780,900 900,1380 1380,1800
recover after the fault,| but
|但这只是一个页面错误，

1723
00:52:51,460 --> 00:52:52,510
0,210 210,390 390,450 450,750 750,1050
it's just a page fault,|
|

1724
00:52:52,510 --> 00:52:54,550
0,120 120,180 180,450 450,750 1710,2040
and it turns out you
你可以或者用户进程可以注册一个页面错误处理程序，

1725
00:52:54,550 --> 00:52:55,570
0,180 180,300 300,540 540,870 870,1020
can or user process can

1726
00:52:55,570 --> 00:52:57,160
0,420 420,510 510,750 750,1020 1020,1590
register a page fault handler|
|

1727
00:52:57,340 --> 00:52:58,600
0,150 150,360 360,750 750,1020 1020,1260
and get control back after
并在页面错误后重新获得控制权，

1728
00:52:58,600 --> 00:52:59,650
0,60 60,300 300,600 600,780 840,1050
a page fault,| and the
|论文还提到了几种在故障发生后可以继续的方法。

1729
00:52:59,650 --> 00:53:00,520
0,210 210,540 540,570 570,810 810,870
paper mentions a couple of

1730
00:53:00,520 --> 00:53:02,350
0,180 180,480 480,690 1110,1650 1650,1830
other ways of being able

1731
00:53:02,350 --> 00:53:03,730
0,120 120,540 540,780 780,840 840,1380
to continue after the fault.|
|

1732
00:53:04,200 --> 00:53:05,320
0,570

1733
00:53:05,470 --> 00:53:06,250
0,300 300,450 450,600 600,690 690,780
And now all we have
现在我们要做的就是找出

1734
00:53:06,250 --> 00:53:06,940
0,90 90,210 210,360 360,630 630,690
to do is figure out|
|

1735
00:53:06,940 --> 00:53:08,140
0,240 240,300 300,450 450,750 750,1200
whether it was buf 0
加载到缓存中的是 buf 0 还是 buf 4096 ，

1736
00:53:08,140 --> 00:53:10,480
0,120 120,420 420,1890 1950,2220 2220,2340
or buf 4096, that was

1737
00:53:10,480 --> 00:53:11,830
0,240 240,420 420,480 480,960 1140,1350
loaded into the cache,| and
|现在我们可以做刷新并重新加载的重新加载部分，

1738
00:53:11,830 --> 00:53:12,400
0,150 150,240 240,330 330,450 450,570
now we can do the

1739
00:53:12,400 --> 00:53:13,450
0,390 390,600 600,660 660,960 960,1050
reload part of flush and

1740
00:53:13,450 --> 00:53:16,000
0,480 600,990 1020,1650 1650,2040
reload,| we read the
|我们读出准确的时间，

1741
00:53:16,030 --> 00:53:17,860
0,510 510,1260
accurate time,|
|

1742
00:53:18,120 --> 00:53:19,860
0,420 450,780 780,1050 1050,1620 1620,1740
{} load buf 0, read
加载 buf 0 ，再读一遍时间，

1743
00:53:19,860 --> 00:53:20,850
0,60 60,270 270,600 600,810 810,990
the time again,| load buf
|加载 buf 1 ，再读一次时间，

1744
00:53:20,850 --> 00:53:22,800
0,660 930,1230 1230,1290 1290,1500 1500,1950
1, read the time again,|
|

1745
00:53:22,800 --> 00:53:24,300
0,150 150,630 630,720 720,990 990,1500
and compare the two differences
比较这两个时间上的差异，

1746
00:53:24,300 --> 00:53:25,620
0,60 60,480 630,840 840,1140 1140,1320
in time,| and whichever one
|无论哪一个花费的时间较短，

1747
00:53:25,620 --> 00:53:26,760
0,60 60,420 420,810 810,840 840,1140
of these took a shorter

1748
00:53:26,760 --> 00:53:28,080
0,180 180,240 240,810
amount of time,|
|

1749
00:53:28,140 --> 00:53:30,080
0,360 360,630 630,1320
{} is likely
可能指示内核数据的低位是 0 还是 1 。

1750
00:53:30,080 --> 00:53:31,700
0,420 510,690 690,1230 1230,1470 1470,1620
{} to indicate whether the

1751
00:53:31,700 --> 00:53:32,750
0,210 210,540 540,660 660,750 750,1050
low bit {of -} the

1752
00:53:33,080 --> 00:53:34,160
0,330 330,570 570,720 720,1020 1020,1080
kernel data was 0 or

1753
00:53:34,160 --> 00:53:35,100
0,360
1.|
|

1754
00:53:39,350 --> 00:53:40,580
0,150 150,300 300,570 570,930 930,1230
And then we report that
然后我们将其重复几十亿次，

1755
00:53:40,610 --> 00:53:42,410
0,480 480,810 960,1260 1260,1590 1590,1800
repeat that a couple of

1756
00:53:42,410 --> 00:53:44,990
0,390 390,1080 1860,2130 2130,2250 2250,2580
billion times,| we can scan
|我们可以扫描所有内核内存。

1757
00:53:44,990 --> 00:53:46,360
0,120 120,180 180,390 390,780
all of kernel memory.|
|

1758
00:53:47,100 --> 00:53:49,080
0,330 330,570 570,720 720,870 870,1980
{} But in this example,|
但是在这个例子中，|

1759
00:53:49,230 --> 00:53:51,540
0,480 510,900 900,1410 1410,1740 1740,2310
if b minus a smaller
如果 b 减去 a 小于 c 减去 b ，

1760
00:53:51,540 --> 00:53:52,920
0,180 180,390 390,810 810,1020 1020,1380
than c minus b,| doesn't
|这是否意味着 buf 0 被缓存了。

1761
00:53:52,920 --> 00:53:54,750
0,180 180,450 450,900 1170,1650 1650,1830
that mean that buf of

1762
00:53:54,750 --> 00:53:56,640
0,450 450,720 720,1650
0 was cached.|
|

1763
00:53:57,060 --> 00:53:59,670
0,750 1110,2010 2010,2280 2280,2520 2520,2610
{} Let's see if I
让我看看是不是搞错了，

1764
00:53:59,670 --> 00:54:00,840
0,150 150,330 330,750 780,960 960,1170
got this wrong,| b minus
|b 减去 a 意味着 buf 0 是缓存的，

1765
00:54:00,840 --> 00:54:02,940
0,720 1110,1380 1380,1620 1620,1740 1740,2100
a yeah means the buf

1766
00:54:02,940 --> 00:54:04,380
0,150 150,300 300,690 690,930 930,1440
0 was cache,| oh yeah
|是的，你说得对。

1767
00:54:04,380 --> 00:54:07,300
0,330 540,870 1770,2220
yeah yeah {you're,right}.|
|

1768
00:54:10,790 --> 00:54:13,180
0,150 150,270 270,570
Now we're [],
现在我们[]，做得好。

1769
00:54:14,280 --> 00:54:16,240
0,420 420,900
good catch.|
|

1770
00:54:17,540 --> 00:54:19,010
0,300 300,660 660,780 780,990 990,1470
Oh, sorry, do you need
哦，抱歉，你是否需要，

1771
00:54:19,040 --> 00:54:21,770
0,630 780,1770 1770,1920 1920,2430 2520,2730
for,| before we had an
|在第 9 行之前是否有一个 if ，

1772
00:54:21,770 --> 00:54:25,010
0,570 720,1500 1530,1950 1950,2640 2640,3240
if before like {9 -},|
|

1773
00:54:25,700 --> 00:54:27,290
0,180 180,270 270,750 780,1140 1140,1590
do we need if now
我们是否需要 if ，还是仍然会这样。

1774
00:54:27,290 --> 00:54:29,090
0,390 420,570 570,840 930,1230 1230,1800
or is it is still

1775
00:54:29,420 --> 00:54:30,620
0,630
{at,all}.|
|

1776
00:54:30,680 --> 00:54:31,980
0,420 420,810

1777
00:54:31,980 --> 00:54:33,330
0,210 210,570 570,930 930,1200 1200,1350
The efforts to help me
为了帮助我阐明预测执行的正当理由，

1778
00:54:33,330 --> 00:54:36,840
0,690 780,1290 1800,2550 2550,3120 3120,3510
illustrate the legitimate reasons for

1779
00:54:37,200 --> 00:54:40,770
0,540 540,1080 1620,2880 2880,3360 3360,3570
speculative execution,| keep computing even
|即使我们不知道分支是否被选择，也要继续计算，

1780
00:54:40,770 --> 00:54:41,670
0,180 180,300 300,450 450,570 570,900
though we don't know whether

1781
00:54:41,670 --> 00:54:43,410
0,270 330,990 1200,1470 1470,1530 1530,1740
the branch took or not,|
|

1782
00:54:43,410 --> 00:54:46,260
0,210 300,1410 1470,1800 1800,2310 2400,2850
but here the real core
但是这里真正的猜测核心是，

1783
00:54:46,260 --> 00:54:47,610
0,60 60,150 150,990 990,1140 1140,1350
of the speculation is that,|
|

1784
00:54:47,670 --> 00:54:49,050
0,450 540,870 870,1080 1080,1200 1200,1380
we don't know if this
我们不知道这个加载载会出现错误，

1785
00:54:49,050 --> 00:54:50,620
0,270 270,390 390,1110
load will fault,

1786
00:54:51,410 --> 00:54:52,760
0,330 330,450 450,600 600,870 1170,1350
right,| and so we're the
|所以机器预测执行通过加载，

1787
00:54:52,760 --> 00:54:55,490
0,540 540,1560 1560,2130 2130,2610 2610,2730
machines speculatively executing past the

1788
00:54:55,490 --> 00:54:57,260
0,660 840,1170 1170,1260 1260,1650 1650,1770
load,| on the theory that
|理论上，很可能不会出现错误，

1789
00:54:57,260 --> 00:54:59,720
0,390 480,1020 1020,1530 1530,1800 1800,2460
it's probably most don't fault,

1790
00:55:00,500 --> 00:55:01,280
0,330 330,510 510,570 570,690 690,780
right,| even though they may
|即使它们可能需要很长时间，

1791
00:55:01,280 --> 00:55:02,240
0,210 210,240 240,450 450,810 810,960
take a long time,| like
|比如一次加载可能需要数百个循环，

1792
00:55:02,240 --> 00:55:03,530
0,30 30,330 330,450 450,660 870,1290
a load could take hundreds

1793
00:55:03,530 --> 00:55:05,540
0,60 60,810 1440,1710 1710,1890 1890,2010
of cycles,| and so we'd
|所以我们希望能够，

1794
00:55:05,540 --> 00:55:06,440
0,180 180,300 300,390 390,540 540,900
love to be able to,|
|

1795
00:55:06,470 --> 00:55:08,000
0,180 180,240 240,540 540,780 780,1530
so the machine will speculatively
这样机器就会预测执行通过加载，

1796
00:55:08,000 --> 00:55:10,040
0,450 450,780 780,900 900,1530
execute pass the load,|
|

1797
00:55:10,040 --> 00:55:11,560
0,300 300,480 480,570 570,930
even though it doesn't,
即使它不知道会不会出错，

1798
00:55:11,800 --> 00:55:13,510
0,840 840,1200 1200,1500 1500,1590 1590,1710
not knowing whether it's going

1799
00:55:13,510 --> 00:55:14,290
0,60 60,360 360,390 390,630 630,780
to fault or not,| and
|如果加载出现错误，

1800
00:55:14,290 --> 00:55:16,390
0,120 120,420 600,1470 1470,2010 2010,2100
if the {load,did} fault,| it
|然后它会取消所有这些预测执行，

1801
00:55:16,390 --> 00:55:17,470
0,120 120,360 360,840 840,960 960,1080
will then undo all this

1802
00:55:17,470 --> 00:55:19,480
0,450 450,990 1260,1500 1500,1560 1560,2010
speculative execution,| there's a speculative
|这里会出现预测执行，

1803
00:55:19,480 --> 00:55:21,460
0,810 840,1140 1140,1500
execution comes up,|
|

1804
00:55:21,670 --> 00:55:25,140
0,450 450,1230 1890,2280 2280,2880
any time you have
任何时刻，你有一条长时间运行的指令可能会或不会成功，

1805
00:55:25,300 --> 00:55:26,770
0,150 150,480 480,690 690,1320 1320,1470
a long running instruction that

1806
00:55:26,770 --> 00:55:27,970
0,180 180,270 270,360 360,570 570,1200
may or may not succeed,|
|

1807
00:55:28,000 --> 00:55:29,350
0,150 150,330 330,1080 1110,1260 1260,1350
so like divide,| so we
比如除法，|我们不知道它是否被零除，

1808
00:55:29,350 --> 00:55:30,040
0,150 150,390 390,510 510,630 630,690
know whether it's going to

1809
00:55:30,040 --> 00:55:30,760
0,60 60,360 360,480 480,660 660,720
be divided by zero or

1810
00:55:30,760 --> 00:55:32,830
0,270 270,540 570,900 1290,1770 1770,2070
not,| {you,know} so instructions after
|所以除法器后的指令也在猜测。

1811
00:55:32,830 --> 00:55:34,700
0,390 390,630 630,1110
divider also speculated.|
|

1812
00:55:35,980 --> 00:55:37,720
0,300 300,390 390,1140 1230,1380 1380,1740
Anyway, the speculation, the real
不管怎样，真正的预测执行从这里开始，

1813
00:55:37,720 --> 00:55:39,220
0,330 330,870 870,1200 1200,1350 1350,1500
critical speculation starts here,| now,
|实际上我们试着，

1814
00:55:39,220 --> 00:55:41,530
0,60 60,360 360,420 420,900 2040,2310
in fact we tried,| in
|为了让攻击更有可能成功，

1815
00:55:41,530 --> 00:55:43,000
0,270 270,510 540,780 780,1080 1140,1470
order to make the attack

1816
00:55:43,000 --> 00:55:44,560
0,360 360,510 510,930 930,1050 1050,1560
likely more successful,| we sort
|我们确保预测从这里开始，

1817
00:55:44,560 --> 00:55:46,300
0,120 390,780 780,900 900,1440 1440,1740
of ensure that speculation starts

1818
00:55:46,300 --> 00:55:47,530
0,270 270,600 750,1020 1020,1140 1140,1230
here,| but this is the
|所以这才是我们真正关心的预测。

1819
00:55:47,530 --> 00:55:48,790
0,150 150,720 720,810 810,990 990,1260
real speculation we care about.|
|

1820
00:56:01,640 --> 00:56:03,560
0,300 300,1050
Other questions?|
还有其他问题吗？|

1821
00:56:06,100 --> 00:56:07,640
0,1020
For
对于这个例子我们只读了一位，

1822
00:56:07,640 --> 00:56:09,590
0,270 270,840 840,1020 1020,1320 1320,1950
this example we've only read

1823
00:56:09,800 --> 00:56:12,340
0,360 360,930
one bit,|
|

1824
00:56:13,050 --> 00:56:14,670
0,480 480,690 690,930 930,1200 1200,1620
is is there some likes
是否可以做一些简单的修改，

1825
00:56:14,670 --> 00:56:16,710
0,300 300,870 900,1260 1260,1920 1920,2040
really small, simple modification,| that
|我们可以读取完整的寄存器大小的位。

1826
00:56:16,710 --> 00:56:17,730
0,90 90,270 270,600 600,750 750,1020
we could make to read

1827
00:56:17,730 --> 00:56:19,260
0,150 150,240 240,570 570,1080 1080,1530
like a full register size

1828
00:56:19,260 --> 00:56:20,850
0,150 150,630 840,1170 1170,1380 1380,1590
of bits.| Yeah, run this
|是的，运行 64 次，每个位一次。

1829
00:56:20,850 --> 00:56:22,380
0,630 630,1080 1080,1260 1260,1380 1380,1530
64 times, one for each

1830
00:56:22,380 --> 00:56:23,140
0,210
bit.|
|

1831
00:56:24,810 --> 00:56:26,460
0,510 510,660 660,780 780,1050 1050,1650
Why is it not possible
为什么不能一次读取 64 位呢？

1832
00:56:26,460 --> 00:56:29,070
0,210 210,480 480,1230 1290,2280 2310,2610
to just read 64 bits

1833
00:56:29,070 --> 00:56:30,300
0,120 120,150 150,690
at a time?|
|

1834
00:56:30,790 --> 00:56:32,340
0,180 180,1050
A sixty,
六十，你需要这个 buf ，

1835
00:56:32,340 --> 00:56:33,570
0,360 390,690 720,960 960,1140 1140,1230
sixty, well you need the

1836
00:56:33,570 --> 00:56:35,040
0,720 750,1020 1020,1290 1290,1350 1350,1470
buf,| the size of this
|这个 buf 的大小必须是，

1837
00:56:35,040 --> 00:56:36,660
0,240 240,420 420,510 510,990 1470,1620
buffer has to be {}|
|

1838
00:56:36,660 --> 00:56:38,820
0,660 660,1050 1050,1050
to the {}
达到 2 的位数次方的 4096 倍，

1839
00:56:39,240 --> 00:56:39,780
0,90 90,180 180,390 390,480 480,540
you know two to the

1840
00:56:39,780 --> 00:56:41,220
0,240 240,300 300,540 540,690 690,1440
number of bits, you're reading

1841
00:56:41,220 --> 00:56:44,910
0,1620 1680,2730 2730,2820 2820,3210 3450,3690
times 4096 or something,| so
|所以 64 位太大了，

1842
00:56:44,910 --> 00:56:46,050
0,420 420,630 630,720 720,840 840,1140
64 bits is too big,|
|

1843
00:56:46,050 --> 00:56:46,980
0,90 90,240 240,330 330,480 480,930
we don't have enough memory
我们没有足够的内存来制作那么大的 buf ，

1844
00:56:46,980 --> 00:56:48,210
0,270 270,720 750,960 960,990 990,1230
to a make a buffer

1845
00:56:48,210 --> 00:56:49,320
0,150 150,600
that big,|
|

1846
00:56:50,810 --> 00:56:52,070
0,150 150,300 300,630 810,1050 1050,1260
we need this, {the,way} this
我们需要这个设置的方式。

1847
00:56:52,070 --> 00:56:53,260
0,120 120,330 330,630
is set up.|
|

1848
00:56:54,810 --> 00:56:56,300
0,180 180,330 330,510 510,870
But {anyway - -},
但不管怎样， 64 位太多了，

1849
00:56:59,200 --> 00:57:00,310
0,270 270,660 660,840 840,960 960,1110
{} 64 bits too much,|
|

1850
00:57:00,310 --> 00:57:01,210
0,240 240,330 330,600 600,750 750,900
you could certainly 8 {}
你可以一次读取 8 位，

1851
00:57:01,210 --> 00:57:02,680
0,240 240,390 390,870 1110,1350 1350,1470
bit of time,| and have
|让缓冲器大小为 256 乘以 4096 。

1852
00:57:02,680 --> 00:57:04,560
0,210 210,450 450,870 870,1290
this buf size be

1853
00:57:05,150 --> 00:57:07,320
0,840 840,1650
256 times

1854
00:57:07,850 --> 00:57:09,880
0,1500
4096.|
|

1855
00:57:11,620 --> 00:57:12,820
0,150 150,390 390,630 630,1080 1080,1200
The paper actually argues {the
这篇论文讨论了，

1856
00:57:12,820 --> 00:57:14,380
0,240
-},|
|

1857
00:57:14,860 --> 00:57:17,040
0,330 330,720 720,1680
the paper observes,|
论文观察到，|

1858
00:57:18,150 --> 00:57:19,980
0,330 330,690 690,1200
that since the
由于大部分时间都在刷新并重新加载，

1859
00:57:20,770 --> 00:57:21,670
0,300 300,390 390,450 450,780 780,900
most of the time is

1860
00:57:21,670 --> 00:57:23,500
0,240 240,330 330,420 420,1020 1020,1830
here in the flush reload,|
|

1861
00:57:25,380 --> 00:57:26,640
0,450 720,990 990,1110 1110,1260 1260,1260
{} if you read a
如果你一次读取一个字节，

1862
00:57:26,640 --> 00:57:28,980
0,300 300,390 390,420 420,1080 1980,2340
byte at a time,| then
|则计算出字节的那些位需要 256 次刷新和重新加载，

1863
00:57:28,980 --> 00:57:30,150
0,510 510,660 660,840 840,930 930,1170
figuring out what the bits

1864
00:57:30,150 --> 00:57:32,160
0,60 60,240 240,540 540,1020 1320,2010
of that byte are takes

1865
00:57:32,370 --> 00:57:34,080
0,1290
{256}

1866
00:57:35,310 --> 00:57:37,260
0,450 450,1440
{flush,and} reloads,|
|

1867
00:57:38,310 --> 00:57:40,140
0,360 360,540 540,1050 1050,1470 1470,1830
one for each possible value.|
每个可能值对应一个。|

1868
00:57:40,800 --> 00:57:41,880
0,180 180,300 300,540 540,660 660,1080
If you load a bit
如果一次加载一个位，

1869
00:57:41,880 --> 00:57:43,710
0,150 150,210 210,900 1260,1590 1590,1830
at a time,| then each
|那么每个位只需要一次刷新和重新加载，

1870
00:57:43,710 --> 00:57:45,580
0,630 750,1380
bit takes

1871
00:57:45,820 --> 00:57:47,470
0,330 330,600 600,930 930,1170 1170,1650
just one flush plus reload,|
|

1872
00:57:47,470 --> 00:57:49,390
0,150 360,690 690,780 780,1350 1710,1920
are sort of two two
可以是两个刷新并重新加载，

1873
00:57:49,390 --> 00:57:50,800
0,480 480,600 600,870 870,1140 1140,1410
{} are two flush plus

1874
00:57:50,800 --> 00:57:51,940
0,420 420,660 810,990 990,1050 1050,1140
{reloads -},| so if you
|所以如果你一次需要一个位，

1875
00:57:51,940 --> 00:57:52,930
0,120 120,150 150,300 300,420 420,990
need a bit of time,|
|

1876
00:57:53,140 --> 00:57:54,010
0,300 300,420 420,540 540,690 690,870
then you end up only
那么你只需要 16 次刷新并重新加载，

1877
00:57:54,010 --> 00:57:56,050
0,240 240,1050 1050,1320 1320,1590 1590,2040
doing 16 flush plus {reloads

1878
00:57:56,050 --> 00:57:56,530
0,120 120,240 240,330 330,450 450,480
-},| if you read a
|如果你一次读取一个字节，

1879
00:57:56,530 --> 00:57:57,250
0,180 180,300 300,360 360,630 630,720
byte at a time,| you
|则需要执行 256 次刷新和重新加载，

1880
00:57:57,250 --> 00:57:59,020
0,120 120,210 210,570 780,1440 1440,1770
end up doing 256 flush

1881
00:57:59,020 --> 00:58:00,790
0,300 300,780 1140,1290 1290,1530 1530,1770
plus reloads,| the paper says
|这篇论文说，

1882
00:58:00,790 --> 00:58:02,260
0,120 120,510 780,1200 1200,1320 1320,1470
that,| it's faster to do
|一次做一位比一次做一个字节要快。

1883
00:58:02,260 --> 00:58:02,710
0,120 120,150 150,300 300,420 420,450
it a bit at a

1884
00:58:02,710 --> 00:58:03,790
0,450 510,690 690,750 750,960 960,1080
time than a byte at

1885
00:58:03,790 --> 00:58:04,500
0,30 30,210
a time.|
|

1886
00:58:05,890 --> 00:58:07,810
0,450 750,1020 1020,1050 1050,1200 1200,1920
Which seems a little counterintuitive,
这看起来有点违反直觉，但似乎是真的。

1887
00:58:09,810 --> 00:58:11,140
0,210 210,300 300,390 390,690
seems to be true.|
|

1888
00:58:18,960 --> 00:58:20,640
0,300 300,1050
Other questions?|
还有其他问题吗？|

1889
00:58:28,760 --> 00:58:30,980
0,300 750,990 990,1200 1200,1470 1470,2220
So where would this {user,program},
那么这个用户程序，这个程序要从哪里运行，

1890
00:58:30,980 --> 00:58:32,210
0,300 300,510 510,960 960,1140 1140,1230
will this program have to

1891
00:58:32,210 --> 00:58:34,850
0,240 240,600 1680,1890 1890,2370 2370,2640
be {run,from},| is there any
|机器上有没有什么特别的位置，

1892
00:58:34,850 --> 00:58:37,400
0,480 480,1080 1290,1500 1500,1860 1980,2550
particular location on the machine,|
|

1893
00:58:37,400 --> 00:58:38,690
0,150 210,600 600,750 750,870 870,1290
that doesn't have to be,|
不一定是，|

1894
00:58:39,480 --> 00:58:40,650
0,480 480,600 600,780 780,1020 1020,1170
where would you write it
我想说你把它写在哪里？

1895
00:58:40,770 --> 00:58:43,560
0,90 90,450
I guess?|
|

1896
00:58:43,650 --> 00:58:44,880
0,240 240,390 390,570 570,1020 1020,1230
Where would this program be
这个程序是从哪里运行的，可以是一个用户程序吗？

1897
00:58:44,880 --> 00:58:46,560
0,300 300,750 840,1320 1320,1440 1440,1680
run from, can be a

1898
00:58:46,560 --> 00:58:50,190
0,780 1320,1620 1620,2250 2610,3030 3030,3630
{user,program}?| Well yeah, that depends
|是的，那取决于你有什么样的权限使用这台机器，

1899
00:58:50,190 --> 00:58:51,930
0,660 720,1140 1140,1290 1290,1380 1380,1740
on what kind of access,

1900
00:58:51,930 --> 00:58:53,250
0,120 120,360 360,480 480,540 540,1320
you have to the machine,|
|

1901
00:58:53,250 --> 00:58:54,720
0,450 450,780 780,870 870,1140 1140,1470
and where the data is
以及你想要窃取的数据在哪里，

1902
00:58:54,720 --> 00:58:55,740
0,90 90,180 180,330 330,390 390,1020
that you want to steal,|
|

1903
00:58:56,070 --> 00:58:57,600
0,150 150,270 270,360 360,630
and then you know
谁知道呢。

1904
00:58:58,670 --> 00:58:59,660
0,120 120,270 270,480 480,690 690,990
who {knows -}, right.| But
|比如，假设，

1905
00:58:59,660 --> 00:59:02,740
0,480 480,1290 1320,1650 1680,2490
for example is supposing,|
|

1906
00:59:03,000 --> 00:59:04,560
0,180 180,450 450,660 660,1200 1200,1560
you're logged into Athena {[]
你登录到 Athena 机器，

1907
00:59:04,560 --> 00:59:06,690
0,360 390,1050 1470,1770 1770,1920 1920,2130
-} machine,| it was a
|这里有另外几百个用户，

1908
00:59:06,750 --> 00:59:08,490
0,240 240,540 540,690 690,1410 1500,1740
couple hundred other users,| and
|你想窃取某人的密码，

1909
00:59:08,490 --> 00:59:09,420
0,90 90,240 240,300 300,540 540,930
you want to steal somebody's

1910
00:59:09,420 --> 00:59:10,600
0,750
password,|
|

1911
00:59:11,470 --> 00:59:12,860
0,180 180,270 270,870
and you're patient,|
而且你很有耐心，|

1912
00:59:13,030 --> 00:59:14,860
0,240 240,420 420,960 960,1380 1380,1830
you can use and let's
你可以使用，让我们假设，

1913
00:59:14,860 --> 00:59:16,270
0,300 300,420 420,810 810,1140 1230,1410
assume,| that {Athena -} is
|Athena 在几年前，

1914
00:59:16,270 --> 00:59:17,320
0,180 180,420 420,660 660,870 870,1050
{you,know} a couple years ago|
|

1915
00:59:17,320 --> 00:59:18,190
0,90 90,420 420,570 570,810 810,870
and Athena was running a
Athena 运行的 Linux 版本

1916
00:59:18,190 --> 00:59:19,540
0,300 300,390 390,810 810,930 930,1350
version of Linux| that mapped
|将内核映射到每个进程地址空间，

1917
00:59:19,540 --> 00:59:21,100
0,60 60,480 480,660 660,930 930,1560
the kernel into every user's

1918
00:59:21,100 --> 00:59:23,410
0,180 180,900 900,1230 1230,1740 2040,2310
every processes address space,| then
|然后你就可以用 meltdown 得到一个个位，

1919
00:59:23,410 --> 00:59:24,670
0,120 120,240 240,420 420,1080 1110,1260
you can use meltdown to

1920
00:59:24,670 --> 00:59:26,080
0,180 180,450 480,930 930,1080 1080,1410
get out bit by bit,|
|

1921
00:59:26,560 --> 00:59:27,790
0,450 450,540 540,600 600,870 870,1230
everything in the kernel,| including
内核中的所有内容，|包括 IO 缓冲区和网络缓冲区等，

1922
00:59:27,790 --> 00:59:29,830
0,600 600,1290 1290,1410 1410,1500 1500,2040
{[],IO} buffers and the network

1923
00:59:29,830 --> 00:59:31,210
0,450 450,540 540,990 1080,1290 1290,1380
buffers and stuff,| and if
|如果有人在输入密码，

1924
00:59:31,210 --> 00:59:32,740
0,330 330,660 660,780 780,1380 1410,1530
somebody's typing their password,| if
|如果你够幸运或有耐心，

1925
00:59:32,740 --> 00:59:34,780
0,90 90,630 840,990 990,1650
you're lucky or patient,|
|

1926
00:59:35,340 --> 00:59:36,570
0,150 150,450 450,690 690,780 780,1230
and somebody's typing {you,know} password,|
有人在输入密码，|

1927
00:59:36,570 --> 00:59:37,230
0,90 90,240 240,450 450,570 570,660
and you load all of
你加载所有内核内存，

1928
00:59:37,230 --> 00:59:38,250
0,240 240,600 630,840 840,960 960,1020
kernel memory,| you're going to
|你将在内核内存中看到那个密码。

1929
00:59:38,250 --> 00:59:39,510
0,210 210,390 390,870 870,930 930,1260
see that password in kernel

1930
00:59:39,510 --> 00:59:40,380
0,300
memory,

1931
00:59:41,340 --> 00:59:42,520
0,420
right.|
|

1932
00:59:42,580 --> 00:59:43,330
0,120 120,360 360,450 450,690 690,750
And because in fact the
并且内核可能映射，

1933
00:59:43,330 --> 00:59:45,340
0,420 420,720 720,1590 1620,1830 1830,2010
kernel probably maps| like {xv6
|比如 xv6 映射所有物理内存，

1934
00:59:45,340 --> 00:59:46,690
0,120 120,420 420,1020 1050,1260 1260,1350
- -} maps all of

1935
00:59:46,690 --> 00:59:48,310
0,360 360,900 1140,1380 1380,1530 1530,1620
physical memory,| that means you
|这意味着你可能可以读取所有物理内存，

1936
00:59:48,310 --> 00:59:49,390
0,90 90,360 360,540 540,690 690,1080
can probably read all physical

1937
00:59:49,390 --> 00:59:51,130
0,300 300,480 480,690 690,1320 1350,1740
memory,| that is all of
|即所有其他进程内存，

1938
00:59:51,130 --> 00:59:53,770
0,330 330,570 570,1470 1470,2070 2190,2640
all other processes memory,| using
|在分时机器上使用这项技术。

1939
00:59:53,770 --> 00:59:55,060
0,150 150,600 600,780 810,1020 1020,1290
this technique on a time

1940
00:59:55,060 --> 00:59:56,180
0,240 240,630
sharing machine.|
|

1941
00:59:56,640 --> 00:59:58,140
0,510 810,1140 1140,1200 1200,1290 1290,1500
{} So I can see
所以，我可以看到每个人的文本编辑器内容或我喜欢的任何内容。

1942
00:59:58,140 --> 01:00:00,120
0,570 600,1080 1080,1260 1290,1620 1620,1980
what's everybody's in text editor

1943
01:00:00,120 --> 01:00:01,500
0,480 480,540 540,810 810,870 870,1380
contents or whatever I like.|
|

1944
01:00:02,500 --> 01:00:04,880
0,420 1230,1470 1470,1620 1620,1830
Now you have to,|
现在你必须，|

1945
01:00:05,460 --> 01:00:06,390
0,540 540,600 600,720 720,810 810,930
that's a way you could
这是一种你可以使用它的方式，

1946
01:00:06,390 --> 01:00:07,140
0,150 150,240 240,330 330,570 570,750
use it,| if you're using
|如果你使用的是分时机器，

1947
01:00:07,140 --> 01:00:08,250
0,60 60,270 270,870 870,990 990,1110
a time machine,| for other
|对于其他情况，情况会有所不同。

1948
01:00:08,250 --> 01:00:09,860
0,1080
situations,

1949
01:00:10,520 --> 01:00:11,600
0,300 420,480 480,600 600,690 690,1080
{you,know} it would be different.|
|

1950
01:00:12,270 --> 01:00:13,800
0,480 480,900
Make sense.|
了解了。|

1951
01:00:13,920 --> 01:00:14,880
0,240 240,480 480,690 690,750 750,960
In time sharing is not
分时技术不再那么普及了，

1952
01:00:14,880 --> 01:00:17,940
0,300 720,1290 1290,1860 2100,2700 2730,3060
that pervasive anymore,| {} but
|但最致命的场景

1953
01:00:17,940 --> 01:00:20,130
0,180 180,360 360,630 720,1470 1470,2190
the sort of killer scenario|
|

1954
01:00:20,130 --> 01:00:20,910
0,210 210,390 390,570 570,720 720,780
would be some kind of
将是某种云计算，

1955
01:00:20,910 --> 01:00:23,250
0,330 330,780 780,1080 1080,1650 1800,2340
cloud computing thing,| where you're
|你使用像亚马逊这样的云提供商，

1956
01:00:23,250 --> 01:00:24,450
0,210 210,270 270,600 600,990 990,1200
using a cloud provider like

1957
01:00:24,450 --> 01:00:26,700
0,810 1200,1710 1770,1980 1980,2040 2040,2250
Amazon,| and you know which
|而且在同一台机器上运行多个客户机。

1958
01:00:26,700 --> 01:00:27,750
0,210 210,420 420,900 900,990 990,1050
runs many customers on the

1959
01:00:27,750 --> 01:00:29,080
0,210 210,870
same machine.|
|

1960
01:00:29,280 --> 01:00:30,480
0,210 210,660 660,720 720,810 810,1200
And depending on the details
取决于他们如何设置虚拟机监视器的细节，

1961
01:00:30,480 --> 01:00:31,260
0,90 90,330 330,450 450,690 690,780
of how they set up

1962
01:00:31,260 --> 01:00:33,840
0,150 150,930 1080,1500 1500,2220 2220,2580
their virtual machine monitor| or
|或者容器系统之类的。

1963
01:00:34,110 --> 01:00:35,460
0,540 540,930 930,990 990,1290 1290,1350
container system or whatever it

1964
01:00:35,460 --> 01:00:38,430
0,180 180,630 990,1470 1470,1950 2070,2970
may be.| If you buy
|如果你从亚马逊购买时间，

1965
01:00:39,140 --> 01:00:41,240
0,480 480,660 660,1500
time from Amazon,|
|

1966
01:00:41,330 --> 01:00:42,560
0,450 480,720 720,900 900,1020 1020,1230
then you may be able
然后，也许你可以窥探其他客户机软件的内存，

1967
01:00:42,560 --> 01:00:43,850
0,120 120,600 600,750 750,870 870,1290
to peer into the memory

1968
01:00:43,850 --> 01:00:46,060
0,120 120,450 450,1620
of other customer's

1969
01:00:46,060 --> 01:00:47,440
0,660 660,900 900,990 990,1080 1080,1380
software| running on the same
|运行在同一台亚马逊机器上的。

1970
01:00:47,440 --> 01:00:49,220
0,420 420,780 780,1140
Amazon machine maybe.|
|

1971
01:00:50,730 --> 01:00:51,900
0,180 180,270 270,420 420,660 660,1170
So I think that's really,|
所以我认为这是真的，|

1972
01:00:53,230 --> 01:00:54,430
0,210 210,540 540,660 660,960 960,1200
yeah, that's how people actually
这可能就是人们实际使用它的方式。

1973
01:00:54,430 --> 01:00:56,110
0,150 150,270 270,690 870,1290 1290,1680
use this probably.| Actually another
|另一个可能有用的是你的浏览器，

1974
01:00:56,110 --> 01:00:57,550
0,300 300,510 510,840 840,930 930,1440
time that might be useful

1975
01:00:57,820 --> 01:00:59,410
0,690 690,900 900,1350 1350,1470 1470,1590
is your browser,| when you're
|当你在浏览时，

1976
01:00:59,410 --> 01:01:00,730
0,390 390,480 480,810 810,1080 1080,1320
browsing,| the web browser actually
|Web 浏览器会在其中运行许多不受信任的代码，

1977
01:01:00,730 --> 01:01:01,540
0,180 180,240 240,390 390,450 450,810
runs a lot of code

1978
01:01:01,540 --> 01:01:02,620
0,90 90,270 270,480 660,870 870,1080
in it that is not

1979
01:01:02,620 --> 01:01:03,820
0,450 450,600 600,660 660,1080 1080,1200
trusted,| that is supplied by
|是由你随机访问的网站提供的，

1980
01:01:03,820 --> 01:01:05,350
0,120 120,450 450,1020 1020,1170 1170,1530
the random websites you visit,|
|

1981
01:01:06,180 --> 01:01:07,300
0,510

1982
01:01:07,330 --> 01:01:07,990
0,240 240,300 300,390 390,600 600,660
maybe in the form of
也许是以插件的形式，

1983
01:01:07,990 --> 01:01:09,520
0,870 1080,1320 1320,1380 1380,1440 1440,1530
plugins,| may be in the
|也许是 Javascript 的形式加载到您的浏览器中，

1984
01:01:09,520 --> 01:01:11,500
0,180 180,270 270,1050 1050,1500 1530,1980
form of Javascript, that's loaded

1985
01:01:11,500 --> 01:01:13,500
0,90 90,240 240,870 870,1350
in your browser,| and
|由浏览器编译并执行，

1986
01:01:13,500 --> 01:01:15,060
0,360 390,960 960,1080 1080,1170 1170,1560
{} compiled by the browser

1987
01:01:15,060 --> 01:01:16,440
0,120 120,570 570,780 930,1230 1230,1380
and execute it,| and it
|这是可能的，实施这个攻击，

1988
01:01:16,440 --> 01:01:18,480
0,150 150,900 1080,1530 1530,1740 1740,2040
is possible, that this attack

1989
01:01:18,480 --> 01:01:20,130
0,90 90,210 210,570 570,1020 1290,1650
could be carried out| by
|通过你浏览网页时，在浏览器中运行的代码。

1990
01:01:20,130 --> 01:01:21,200
0,480
{}

1991
01:01:21,890 --> 01:01:23,630
0,240 240,570 570,690 690,1290 1500,1740
{} code that you {run,in}

1992
01:01:23,630 --> 01:01:24,890
0,90 90,450 450,630 630,960 990,1260
your browser when you browse

1993
01:01:24,890 --> 01:01:25,820
0,60 60,450
the web.|
|

1994
01:01:26,190 --> 01:01:27,460
0,150 150,270 270,330 330,780
That you may not,|
你可能不会，|

1995
01:01:28,060 --> 01:01:29,230
0,330 330,450 450,570 570,840 840,1170
even though it's running their
即使它从网站上运行他们的加载，

1996
01:01:29,320 --> 01:01:30,430
0,330 330,450 450,900 900,990 990,1110
load from websites| and they
|他们也会窃取你笔记本电脑中的任何东西。

1997
01:01:30,430 --> 01:01:31,570
0,150 150,480 480,780 780,1050 1050,1140
would steal whatever stuff is

1998
01:01:31,570 --> 01:01:33,940
0,210 210,270 270,390 390,1050 2220,2370
sitting in your laptop.| I
|我不知道这件事的细节是不是真的行得通。

1999
01:01:33,940 --> 01:01:35,110
0,120 120,300 300,630 630,750 750,1170
don't know if the details

2000
01:01:35,110 --> 01:01:36,040
0,60 60,210 210,420 420,600 600,930
of that quite work out.|
|

2001
01:01:37,180 --> 01:01:39,550
0,240 240,570 570,1380 1470,1890 1890,2370
Has anyone demonstrated an attack
有没有人演示过通过 Javascript 或 WebAssembly 的攻击？

2002
01:01:39,550 --> 01:01:41,350
0,360 360,720 720,1440 1440,1560 1560,1800
through either Javascript or like

2003
01:01:41,350 --> 01:01:42,820
0,210 210,840 900,1050 1050,1260 1260,1470
{WebAssembly -}?| I don't know,
|我不知道，

2004
01:01:42,850 --> 01:01:43,960
0,120 120,300 300,480 480,660 660,1110
I don't,| I I feel
|我觉得人们肯定会担心 WebAssembly 。

2005
01:01:44,140 --> 01:01:45,670
0,510 510,780 780,1170 1170,1350 1350,1530
certainly people worried about {WebAssembly

2006
01:01:45,670 --> 01:01:46,860
0,630
-}.|
|

2007
01:01:46,920 --> 01:01:47,730
0,240 240,390 390,480 480,690 690,810
I don't know whether the
我不知道攻击是否真的有可能，

2008
01:01:47,730 --> 01:01:50,430
0,210 210,330 330,840 840,1500 2280,2700
attack was literally possible,| for
|对于 Javascript ，我知道，

2009
01:01:50,820 --> 01:01:53,280
0,690 690,750 750,990 990,1290 1860,2460
Javascript I know that, {}|
|

2010
01:01:53,900 --> 01:01:54,920
0,210 210,300 300,660 660,900 900,1020
maybe the sticking point was
也许症结在于准确的时间。

2011
01:01:54,920 --> 01:01:56,500
0,120 120,510 510,1050
the accurate time,

2012
01:01:57,400 --> 01:01:58,960
0,120 120,360
I mean.|
|

2013
01:01:59,370 --> 01:02:00,540
0,210 210,390 390,690 690,930 930,1170
You couldn't quite get this
你不能得到这个纳秒的时间，

2014
01:02:00,540 --> 01:02:02,160
0,510 510,1080 1140,1350 1350,1410 1410,1620
nanosecond timing,| so you couldn't
|所以你现在不能执行刷新并重新加载，

2015
01:02:02,160 --> 01:02:03,870
0,330 330,900 1110,1530 1530,1590 1590,1710
quite execute flush and {reload

2016
01:02:03,870 --> 01:02:06,360
0,480 570,900 900,1380 1380,2100 2250,2490
-} now,| whether somebody with
|除非一些更聪明的人

2017
01:02:06,360 --> 01:02:07,530
0,30 30,150 150,240 240,840 840,1170
a bit more cleverness| could
|可以想出一个办法来做这件事，

2018
01:02:07,650 --> 01:02:08,220
0,240 240,330 330,360 360,480 480,570
figure out a way to

2019
01:02:08,220 --> 01:02:08,910
0,120 120,210 210,270 270,420 420,690
do it,| I don't know
|我不知道 WebAssembly 更接近运行机器代码，

2020
01:02:09,000 --> 01:02:09,990
0,210 210,330 330,690 690,810 810,990
{WebAssembly - -} is much

2021
01:02:09,990 --> 01:02:12,440
0,330 330,510 540,1020 1440,1860
closer to running {}

2022
01:02:12,440 --> 01:02:14,280
0,330 330,810 810,1350
machine code,| and
|我不知道细节是怎么回事，

2023
01:02:14,600 --> 01:02:15,230
0,180 180,240 240,390 390,510 510,630
you know I I don't

2024
01:02:15,230 --> 01:02:16,280
0,180 180,540 540,630 630,720 720,1050
know exactly how the details

2025
01:02:16,280 --> 01:02:17,810
0,240 240,330 330,570 990,1110 1110,1530
worked out,| but, oh boy
|但是，很多人很快就想到了。

2026
01:02:17,810 --> 01:02:18,820
0,390
was,

2027
01:02:19,150 --> 01:02:20,920
0,180 180,360 360,870 1110,1560 1560,1770
so many people rapidly thought

2028
01:02:20,920 --> 01:02:21,740
0,240
about.|
|

2029
01:02:25,250 --> 01:02:27,500
0,540 1020,1560 1650,1920 1920,2160 2160,2250
Okay, {} it turns out
好的，事实是攻击并不总是有效的，

2030
01:02:27,500 --> 01:02:29,180
0,120 120,390 390,600 600,930 930,1680
the attack doesn't always work,|
|

2031
01:02:29,420 --> 01:02:30,740
0,330 330,570 570,720 720,1110 1110,1320
like and for reasons that,|
原因是，|

2032
01:02:30,830 --> 01:02:32,000
0,150 150,330 330,690 720,870 870,1170
I don't think,| the author
我不认为，|作者从未解释过或只是猜测过，

2033
01:02:32,000 --> 01:02:34,820
0,570 870,1740 1770,1980 1980,2190 2190,2820
never explained or only speculated

2034
01:02:34,820 --> 01:02:36,290
0,300 300,420 420,510 510,660 660,1470
about,| and you can see,
|你可以看到，我不知道你是否能看到这个，

2035
01:02:36,860 --> 01:02:37,460
0,240 240,360 360,420 420,510 510,600
I don't know if you

2036
01:02:37,460 --> 01:02:38,420
0,90 90,270 270,540 540,780 780,960
can see this,| well, maybe
|也许你看不到这个，

2037
01:02:38,420 --> 01:02:39,740
0,60 60,240 240,390 390,720 750,1320
you can't see this,| but
|但如果你翻到他们论文的最后一页，

2038
01:02:39,770 --> 01:02:40,850
0,210 210,330 330,570 570,690 690,1080
if you turn the last

2039
01:02:40,850 --> 01:02:42,500
0,420 420,480 480,600 600,1140 1410,1650
page of their paper,| you'll
|你会看到它实际的输出，

2040
01:02:42,500 --> 01:02:44,060
0,180 180,330 330,600 600,720 720,1560
see the output it's actually,|
|

2041
01:02:44,150 --> 01:02:44,980
0,150 150,390
you know,
他们在自己的机器上发动了攻击，

2042
01:02:45,140 --> 01:02:46,610
0,420 480,1020 1020,1110 1110,1410 1410,1470
they mounted the attack on

2043
01:02:46,610 --> 01:02:47,690
0,120 120,210 210,540 540,630 630,1080
their own machines| and extracted
|并从自己的机器上的内核中提取了一系列数据。

2044
01:02:47,690 --> 01:02:49,160
0,30 30,270 270,630 810,1290 1290,1470
a bunch of data from

2045
01:02:49,160 --> 01:02:50,240
0,210 210,540 570,720 720,990 990,1080
their own, the kernel on

2046
01:02:50,240 --> 01:02:52,800
0,180 180,300 300,840 1290,1680
their own machine.| And,
|如果你仔细看，

2047
01:02:52,920 --> 01:02:53,820
0,210 210,300 300,420 420,750 750,900
if you look closer,| you'll
|你会发现这些很多行，

2048
01:02:53,820 --> 01:02:55,020
0,150 150,330 330,360 360,990 990,1200
see there's a huge all

2049
01:02:55,020 --> 01:02:57,570
0,300 300,1020 1350,1710 1830,2130 2130,2550
these lines| are just xx
|都是 xx xxx ， x 以及点，

2050
01:02:57,570 --> 01:03:00,000
0,690 690,1530 1530,1650 1650,1830 1830,2430
xxx xxx, all these lines

2051
01:03:00,150 --> 01:03:01,890
0,300 300,660 660,810 810,1260 1410,1740
x x with dots,| these
|在这些地方，他们没有提取到任何东西，

2052
01:03:01,890 --> 01:03:03,030
0,60 60,390 390,540 540,720 720,1140
are places where they didn't

2053
01:03:03,030 --> 01:03:04,830
0,450 450,600 600,1110 1110,1590 1620,1800
manage to extract anything,| where
|meltdown 失效了，

2054
01:03:04,830 --> 01:03:07,140
0,450 450,1290 1710,2070 2070,2160 2160,2310
meltdown failed,| even though they
|尽管他们重复了很多次。

2055
01:03:07,140 --> 01:03:09,280
0,450 450,540 540,780 780,1740
repeated it many times.|
|

2056
01:03:09,340 --> 01:03:10,900
0,570 840,1110 1110,1200 1200,1290 1290,1560
{} And you can tell
你可以看出他们一定是，

2057
01:03:10,900 --> 01:03:11,800
0,90 90,300 300,390 390,630 750,900
they must have been,| you
|这个论文的攻击版本重试了很多次，

2058
01:03:11,800 --> 01:03:13,690
0,60 60,210 210,600 630,1170 1230,1890
know they were the papers

2059
01:03:13,690 --> 01:03:15,160
0,360 360,450 450,600 600,1110 1170,1470
version of this attack was

2060
01:03:15,160 --> 01:03:16,480
0,150 150,510 510,720 720,930 930,1320
{re-trying -} many many times,|
|

2061
01:03:16,480 --> 01:03:17,890
0,210 210,360 360,690 690,1110 1110,1410
because for {example - -}
因为第 6.2 节谈到了性能，

2062
01:03:17,890 --> 01:03:19,570
0,240 240,510 510,780 780,990 990,1680
section 6.2 talks about performance,|
|

2063
01:03:19,870 --> 01:03:21,340
0,420 420,570 570,690 690,900 900,1470
says that in some cases,|
表示在某些情况下，|

2064
01:03:21,490 --> 01:03:22,870
0,480 570,990 990,1080 1080,1260 1260,1380
the rate at which they
它们可以提取数据的速率仅为每秒 10 字节，

2065
01:03:22,870 --> 01:03:23,860
0,120 120,480 480,690 690,840 840,990
could extract data was only

2066
01:03:23,860 --> 01:03:25,750
0,270 270,540 540,630 630,1050 1590,1890
ten bytes per second,| which
|这意味着他们在那里一次又一次地尝试，

2067
01:03:25,750 --> 01:03:26,380
0,120 120,180 180,270 270,510 510,630
means they were sitting there

2068
01:03:26,380 --> 01:03:27,400
0,270 270,510 510,630 630,900 900,1020
trying again and again and

2069
01:03:27,400 --> 01:03:28,510
0,240 240,330 330,630 630,1020 1020,1110
again,| and after thousands of
|在几千次之后，他们终于设法获得了一些数据，

2070
01:03:28,510 --> 01:03:31,090
0,390 390,510 510,1290 1830,2520 2520,2580
times they finally managed to

2071
01:03:31,090 --> 01:03:32,020
0,120 120,270 270,570 570,780 780,930
get some data,| that is
|也就是，

2072
01:03:32,020 --> 01:03:32,640
0,210
that,|
|

2073
01:03:32,730 --> 01:03:35,460
0,570 660,1380 1380,1680 1680,2160 2160,2730
{} flush plus reload indicated
刷新并重新加载表示两个缓存行有不同的加载时间。

2074
01:03:35,460 --> 01:03:36,600
0,240 240,450 450,600 600,900 900,1140
that the two cache lines

2075
01:03:36,600 --> 01:03:39,240
0,90 90,330 330,540 540,1260
at different load times.|
|

2076
01:03:39,270 --> 01:03:40,560
0,150 150,270 270,540 540,1050 1050,1290
So there's something unexplained going
所以有一些无法解释的事情，

2077
01:03:40,560 --> 01:03:41,700
0,150 150,360 360,600 600,780 780,1140
on| about why it's quite
|关于为什么 meltdown 失败的频率很高，

2078
01:03:41,700 --> 01:03:45,180
0,630 960,1830 1890,2550 2550,2850 2850,3480
frequent for meltdown actually fail,|
|

2079
01:03:45,210 --> 01:03:46,620
0,150 150,300 300,570 570,1020 1140,1410
{} get some data actually
获取一些数据，获取真实的数据，

2080
01:03:46,620 --> 01:03:48,140
0,150 150,330 330,540 540,960
got real data here,|
|

2081
01:03:48,140 --> 01:03:48,860
0,210 210,420 420,450 450,630 630,720
there's also a bunch of
还有一堆他们没有得到的数据，

2082
01:03:48,860 --> 01:03:49,970
0,240 240,360 360,480 480,720 720,1110
data that they didn't get,|
|

2083
01:03:50,420 --> 01:03:51,680
0,480
and
我不知道人们，

2084
01:03:51,940 --> 01:03:53,180
0,630
{}

2085
01:03:53,380 --> 01:03:54,370
0,150 150,360 360,510 510,600 600,990
I don't know if people,|
|

2086
01:03:54,370 --> 01:03:55,060
0,180 180,360 360,480 480,540 540,690
as far as I know,
据我所知，人们并不确定，

2087
01:03:55,060 --> 01:03:56,410
0,300 300,360 360,660 660,960 960,1350
people are not really sure,|
|

2088
01:03:56,410 --> 01:03:58,060
0,390 390,570 570,690 690,1200 1200,1650
what all the conditions are
它成功或不成功的时候的条件是什么，

2089
01:03:58,510 --> 01:03:59,920
0,360 360,630 630,720 720,1200 1200,1410
about when it succeeds when

2090
01:03:59,920 --> 01:04:00,850
0,60 60,420 570,750 750,810 810,930
it doesn't,| you know the
|你知道最直接的可能性是，

2091
01:04:00,850 --> 01:04:03,130
0,240 240,960 960,1680 1920,2130 2130,2280
most straightforward possibility is that,|
|

2092
01:04:03,130 --> 01:04:04,210
0,120 120,180 180,480 480,780 780,1080
if the kernel data is
如果内核数据在 L1 缓存中，则 meltdown 成功，

2093
01:04:04,240 --> 01:04:05,890
0,270 270,390 390,540 540,780 780,1650
in the {L1 -} cache,

2094
01:04:06,160 --> 01:04:07,660
0,150 150,540 540,1260 1260,1410 1410,1500
the meltdown succeeds,| and the
|如果内核数据不在 L1 缓存中，则不会成功。

2095
01:04:07,660 --> 01:04:08,710
0,270 270,480 480,660 660,960 960,1050
kernel data is not in

2096
01:04:08,710 --> 01:04:10,000
0,120 120,240 240,450 450,990 1020,1290
the {L1 -} cache, doesn't

2097
01:04:10,000 --> 01:04:11,650
0,540 600,840 840,1350 1350,1590 1590,1650
succeed.| That's very easy to
|这很容易让人相信就是正在发生的事情，

2098
01:04:11,650 --> 01:04:12,760
0,270 270,390 390,660 660,990 990,1110
believe that that could be

2099
01:04:12,760 --> 01:04:15,420
0,270 270,540 540,960 1590,2250
what's going on {},|
|

2100
01:04:15,760 --> 01:04:16,510
0,390 390,450 450,540 540,690 690,750
because if it's not in
因为如果它不在 L1 缓存中，

2101
01:04:16,510 --> 01:04:17,860
0,90 90,210 210,390 390,990 1110,1350
the {L1 -} cache,| then
|会有一大堆更多的机制参与到预测加载中，

2102
01:04:17,860 --> 01:04:19,090
0,150 150,180 180,660 660,990 990,1230
there's a whole bunch more

2103
01:04:19,090 --> 01:04:20,920
0,540 540,990 990,1050 1050,1110 1110,1830
machinery involved in {} speculative

2104
01:04:20,920 --> 01:04:22,420
0,570 810,1050 1050,1170 1170,1410 1410,1500
load| and it's easy to
|很容易想象 CPU 对于预测加载，

2105
01:04:22,420 --> 01:04:25,330
0,480 480,720 990,1500 1500,2340 2700,2910
imagine that the CPU for

2106
01:04:25,330 --> 01:04:27,700
0,60 60,750 750,1410 1440,1860 1920,2370
{} speculative load,| that's maybe
|可能还不知道是否需要，

2107
01:04:27,700 --> 01:04:28,510
0,210 210,390 390,450 450,600 600,810
not known if it's even

2108
01:04:28,510 --> 01:04:31,750
0,480 1080,1410 1410,1740 1740,2430 2700,3240
needed,| would not bother doing
|不会费心去从内存加载东西。

2109
01:04:31,750 --> 01:04:33,460
0,330 330,450 450,780 780,1470 1470,1710
all the work required to

2110
01:04:33,460 --> 01:04:35,220
0,480 480,720 720,900 900,1380
load stuff from RAM.|
|

2111
01:04:36,440 --> 01:04:37,520
0,540
But,
但是，事情并没有那么简单，

2112
01:04:37,900 --> 01:04:39,280
0,150 150,300 300,540 540,720 720,1380
it's not quite that simple,|
|

2113
01:04:40,150 --> 01:04:40,840
0,240 240,330 330,480 480,570 570,690
you can tell it's not
你可以看出事情没有那么简单，

2114
01:04:40,840 --> 01:04:42,220
0,210 210,390 390,660 660,1020 1170,1380
quite that simple,| because the
|因为论文中说到有时当他们尝试，

2115
01:04:42,220 --> 01:04:43,540
0,270 270,540 540,660 660,1170 1170,1320
paper says that sometimes when

2116
01:04:43,540 --> 01:04:45,250
0,210 210,750 840,990 990,1440 1440,1710
they tried,| {retried -} many
|重试了很多次，最后奏效了，

2117
01:04:45,250 --> 01:04:47,650
0,750 1110,1380 1380,1470 1470,1860 1860,2400
times and it finally worked,|
|

2118
01:04:47,710 --> 01:04:49,320
0,210 210,360 360,1170
so there's some
所以有一些更复杂的情况，

2119
01:04:49,590 --> 01:04:51,330
0,210 210,720 720,1380 1410,1620 1620,1740
more complex condition,| maybe a
|也许是在 CPU 内部的竞争，

2120
01:04:51,330 --> 01:04:53,730
0,810 1140,1620 1620,2070 2070,2340 2340,2400
race effectively race inside the

2121
01:04:53,730 --> 01:04:56,490
0,630 1020,1290 1290,1500 1500,1650 1890,2760
CPU| under which it occasionally
|它偶尔可以工作，

2122
01:04:56,490 --> 01:04:57,800
0,540
works,|
|

2123
01:04:57,800 --> 01:04:58,910
0,240 240,360 360,570 570,780 780,1110
even for data that's not
即使对于不在缓存中的数据。

2124
01:04:58,940 --> 01:05:00,520
0,270 270,330 330,420 420,1050
not in the cache.|
|

2125
01:05:01,270 --> 01:05:02,360
0,510

2126
01:05:06,670 --> 01:05:07,600
0,300 330,630 630,810 810,870 870,930
{} The end of the
论文的结尾也是，

2127
01:05:07,600 --> 01:05:08,800
0,180 180,240 240,570 570,1050 1050,1200
paper is actually also,| if
|如果你还没读到，它值得一读，

2128
01:05:08,800 --> 01:05:09,850
0,120 120,300 300,450 450,600 600,1050
you didn't get that for

2129
01:05:09,880 --> 01:05:11,440
0,300 300,540 540,810 810,1230 1230,1560
worth reading,| because it does
|因为它解释了一种更真实的世界，

2130
01:05:11,440 --> 01:05:12,790
0,750 750,840 840,1020 1020,1080 1080,1350
explain a sort of more

2131
01:05:12,790 --> 01:05:14,140
0,330 330,780 780,1020 1020,1140 1140,1350
real world,| like we wanted
|我们想找出这件事，

2132
01:05:14,140 --> 01:05:15,220
0,90 90,360 360,480 480,630 630,1080
to find out this particular

2133
01:05:15,220 --> 01:05:16,720
0,480 480,600 600,660 660,1110 1320,1500
thing,| you know this, we
|我们知道火狐的密码管理器里有密码，

2134
01:05:16,720 --> 01:05:18,400
0,180 180,540 570,1200 1200,1620 1620,1680
know there's passwords stored in

2135
01:05:18,400 --> 01:05:20,410
0,180 180,510 510,990 990,1380 1380,2010
our {Firefox's -} password manager,|
|

2136
01:05:20,440 --> 01:05:21,130
0,120 120,360 360,420 420,570 570,690
we wanted to get them
我们想把它们弄出来，

2137
01:05:21,130 --> 01:05:22,960
0,300 690,900 900,1380 1380,1590 1590,1830
out| and steal them using
|然后用 meltdown 偷走他们，

2138
01:05:22,960 --> 01:05:24,400
0,720 900,1110 1110,1170 1170,1350 1350,1440
meltdown,| you know what are
|你怎么找出地址，

2139
01:05:24,400 --> 01:05:25,660
0,270 840,900 900,1110 1110,1170 1170,1260
all the, how do you

2140
01:05:25,660 --> 01:05:26,680
0,180 180,240 240,360 360,420 420,1020
find out what the addresses,|
|

2141
01:05:26,680 --> 01:05:28,180
0,120 120,600 900,1140 1140,1320 1320,1500
for example, {} they sort
比如，他们策划了一场完整的攻击，

2142
01:05:28,180 --> 01:05:29,560
0,60 60,270 270,540 540,1080 1080,1380
of lay out a complete

2143
01:05:29,560 --> 01:05:31,040
0,540 780,930 930,1110
attack,| I mean,
|我的意思是，完全由学者进行的攻击不是真正的袭击者，

2144
01:05:31,950 --> 01:05:32,880
0,90 90,390 390,660 660,810 810,930
a complete attack done by

2145
01:05:32,880 --> 01:05:34,440
0,630 630,780 780,930 930,1410 1410,1560
academics not real attackers,| but
|但尽管如此，并填补了许多[务实]的细节。

2146
01:05:34,440 --> 01:05:36,030
0,630 870,1020 1020,1290 1290,1530 1530,1590
nevertheless and filling many of

2147
01:05:36,030 --> 01:05:37,800
0,120 120,660 660,1260
the [pragmatic] details.|
|

2148
01:05:40,630 --> 01:05:41,290
0,150 150,360 360,480 480,540 540,660
The only thing I want
我唯一想谈的就是他的修复，

2149
01:05:41,290 --> 01:05:42,370
0,60 60,240 240,480 480,870 900,1080
to talk about is his

2150
01:05:42,370 --> 01:05:44,860
0,360 360,870 1290,1920
{fixes -} {},|
|

2151
01:05:45,090 --> 01:05:45,930
0,210 210,420 420,690 690,780 780,840
you've already touched on a
你已经了解了一点。

2152
01:05:45,930 --> 01:05:47,000
0,180 180,450
little bit.|
|

2153
01:05:47,230 --> 01:05:48,820
0,360 360,540 540,810 810,1080 1080,1590
When this paper came out,
这篇论文发表后，引起了很大的关注。

2154
01:05:51,240 --> 01:05:51,990
0,270 270,420 420,480 480,690 690,750
it got a lot of

2155
01:05:51,990 --> 01:05:53,160
0,570 570,690 690,780 780,900 900,1170
attention,| and there was actually
|实际上，还有另一篇论文，

2156
01:05:53,160 --> 01:05:54,960
0,390 390,690 690,1020 1020,1230 1230,1800
another second paper| by overlapping
|由同样的人撰写的关于不同攻击的论文，

2157
01:05:54,960 --> 01:05:55,890
0,210 210,300 300,600 600,810 810,930
set of people about a

2158
01:05:55,890 --> 01:05:58,920
0,660 1560,2070 2070,2190 2190,2460 2460,3030
different attack,| that also used
|也在 CPU 内部使用了不同类型的预测，称为 spectre 。

2159
01:05:58,920 --> 01:05:59,840
0,360
different,

2160
01:05:59,930 --> 01:06:02,180
0,420 420,660 660,960 1230,1950 1950,2250
different kind of speculation inside

2161
01:06:02,180 --> 01:06:03,500
0,330 330,450 450,660 660,1140 1170,1320
{CPUs -}, called spectre.| So
|所以，这两份文件同时出来了，

2162
01:06:03,500 --> 01:06:05,420
0,90 90,270 270,390 390,960 1350,1920
the pair of papers came

2163
01:06:05,420 --> 01:06:06,650
0,120 120,390 390,450 450,690 690,1230
out at the same time|
|

2164
01:06:06,680 --> 01:06:10,370
0,180 180,570 2280,2700 2700,3240 3480,3690
and was very exciting.| And
非常令人兴奋。|所以人们争先恐后地，

2165
01:06:10,370 --> 01:06:11,840
0,120 120,330 330,780 780,1050 1050,1470
so people hustled,| people realize
|人们意识到这是极具破坏性的，

2166
01:06:11,840 --> 01:06:13,340
0,180 180,570 870,1020 1020,1080 1080,1500
that boy, this is extremely

2167
01:06:13,340 --> 01:06:14,450
0,360 360,510 510,690 690,810 810,1110
damaging,| because now we're talking
|因为我们现在谈论的是，

2168
01:06:14,450 --> 01:06:15,350
0,240 240,360 360,540 660,810 810,900
about is that| you know
|隔离性被打破了。

2169
01:06:15,350 --> 01:06:17,510
0,540 540,630 630,750 750,1230 1470,2160
isolation has been broken, right.|
|

2170
01:06:17,940 --> 01:06:19,830
0,150 150,510 510,1020 1110,1470 1470,1890
You're gonna hardly, so basically
所以基本上不用再想它了，

2171
01:06:19,830 --> 01:06:20,670
0,270 270,420 420,600 600,780 780,840
hardly even think about it

2172
01:06:20,670 --> 01:06:22,800
0,390 390,600 630,780 780,1110 1560,2130
anymore,| but you know this
|但是这是一种打破页表保护的技术，

2173
01:06:22,800 --> 01:06:23,970
0,360 360,570 570,690 690,780 780,1170
thing, this is a technique

2174
01:06:23,970 --> 01:06:26,430
0,120 120,750 900,1290 1290,1620 1620,2460
for breaking page table protections,|
|

2175
01:06:26,460 --> 01:06:27,540
0,300 300,630
which is
这就是我们如何实施用户和内核之间的隔离，

2176
01:06:27,990 --> 01:06:29,040
0,120 120,210 210,450 450,720 720,1050
you know how we enforce

2177
01:06:29,040 --> 01:06:30,390
0,450 450,750 750,930 930,1020 1020,1350
isolation between user and kernel,|
|

2178
01:06:30,390 --> 01:06:33,840
0,270 270,570 750,1560 1590,2460 2700,3450
it's like deeply fundamental attack,|
这就是根本性的攻击，|

2179
01:06:34,350 --> 01:06:35,340
0,240 240,420 420,480 480,660 660,990
{} or {anyway - -}
或者以任何方式破坏一项极其重要的安全措施，

2180
01:06:35,370 --> 01:06:38,430
0,690 690,840 1770,2430 2430,2880 2880,3060
undermines an extremely important piece

2181
01:06:38,430 --> 01:06:39,580
0,90 90,630
of security,|
|

2182
01:06:40,160 --> 01:06:41,030
0,150 150,180 180,390 390,660 660,870
in a very general way
从一个非常普遍的角度来看，

2183
01:06:41,030 --> 01:06:41,840
0,300 300,510 510,630 630,690 690,810
right,| seems like you could
|看起来你能看到任何东西。

2184
01:06:41,840 --> 01:06:44,420
0,180 180,570 1950,2190 2190,2280 2280,2580
read anything.| And so people
|所以人们非常争先恐后地部署修复方案，

2185
01:06:44,420 --> 01:06:46,370
0,300 300,540 540,1230 1350,1620 1620,1950
really really hustled, to a

2186
01:06:46,400 --> 01:06:47,810
0,420 420,810 810,930 930,1200 1200,1410
deploy fixes for this,| in
|很多操作系统出了立即修复，

2187
01:06:47,810 --> 01:06:49,490
0,150 180,690 690,1080 1080,1260 1260,1680
the immediate fix that a

2188
01:06:49,490 --> 01:06:51,590
0,240 240,300 300,690 690,1470 1650,2100
lot of operating systems {}

2189
01:06:51,920 --> 01:06:53,750
0,570 570,810 810,1260 1260,1470 1470,1830
installed| within weeks of {}
|在这篇论文发表后的几周内，

2190
01:06:55,620 --> 01:06:56,820
0,180 180,450 450,690 690,1110 1110,1200
this paper coming out| and
|有时已经安装了这个叫做 KASLR 的东西，

2191
01:06:56,820 --> 01:06:58,440
0,420 420,600 600,960 960,1290 1290,1620
sometimes had already installed this

2192
01:06:58,440 --> 01:07:00,570
0,120 120,330 330,960 1740,2040 2040,2130
thing called KASLR,| which is
|现在在 Linux 中称为 kpti ，

2193
01:07:00,570 --> 01:07:02,940
0,180 180,630 780,1110 1110,2190 2220,2370
now called {kpti -} in

2194
01:07:02,940 --> 01:07:05,130
0,570 600,840 870,1230 1440,1920 1920,2190
Linux,| and it's a pretty
|这是一个相当直截了当的想法，

2195
01:07:05,130 --> 01:07:06,960
0,480 480,930 1200,1500 1500,1740 1740,1830
straightforward idea,| the idea is
|这个想法就是不将内核映射放在用户页表中，

2196
01:07:06,960 --> 01:07:08,400
0,210 210,390 420,930 930,1020 1020,1440
just like not to put

2197
01:07:08,400 --> 01:07:09,450
0,60 60,360 360,780 780,930 930,1050
the kernel {mappings -} in

2198
01:07:09,450 --> 01:07:10,980
0,90 90,360 360,660 660,1020
the user page table,|
|

2199
01:07:11,010 --> 01:07:13,950
0,600 840,1170 1170,1830 2430,2670 2670,2940
{} and instead {} as
并且如 xv6 中的那样，

2200
01:07:13,950 --> 01:07:16,740
0,90 90,240 240,360 360,1080 1950,2790
in {xv6 - -},| switch
|在系统调用期间切换页表，

2201
01:07:16,740 --> 01:07:18,540
0,300 300,840 840,1110 1110,1470 1470,1800
page tables during system calls,|
|

2202
01:07:18,540 --> 01:07:19,770
0,150 150,390 390,750 750,900 900,1230
so user space just user
所以用户空间只有用户映射发起系统调用，

2203
01:07:19,770 --> 01:07:21,390
0,480 480,750 960,1290 1290,1320 1320,1620
{mappings -} make a system

2204
01:07:21,390 --> 01:07:22,560
0,600 630,810 810,960 960,1110 1110,1170
call,| there's some kind of
|有类似 xv6 中的 trampoline 的安排，

2205
01:07:22,560 --> 01:07:24,300
0,480 480,990 990,1170 1170,1500 1530,1740
trampoline arrangement like in {xv6

2206
01:07:24,300 --> 01:07:25,500
0,120 120,570 570,720 720,840 840,1200
- -},| and you switch
|你将页表切换到具有内核映射的页表，

2207
01:07:25,500 --> 01:07:27,630
0,270 270,810 810,1080 1080,1890 1890,2130
page tables to a page

2208
01:07:27,630 --> 01:07:28,530
0,240 240,360 360,570 570,630 630,900
table that has {the -}

2209
01:07:28,530 --> 01:07:29,460
0,390 390,660 660,750 750,870 870,930
kernel mappings| in order to
|为了执行内核。

2210
01:07:29,460 --> 01:07:30,660
0,360 360,420 420,780
execute the kernel.|
|

2211
01:07:32,080 --> 01:07:34,120
0,180 180,300 300,780 780,1500 1650,2040
And that causes attack cannot
这会导致攻击无法工作，

2212
01:07:34,120 --> 01:07:37,760
0,660 870,2160 2190,3000
work,| because {}
|因为在那里你切换了页表，

2213
01:07:38,060 --> 01:07:39,710
0,840 900,1080 1080,1320 1320,1530 1530,1650
the, in that because you

2214
01:07:39,710 --> 01:07:43,550
0,330 330,720 720,1500 2130,2730 2970,3840
switch page tables,| {} this
|在 r1 中的这个虚拟地址，

2215
01:07:43,760 --> 01:07:46,260
0,600 600,960 960,1020 1020,1710
virtual address in r1,|
|

2216
01:07:47,400 --> 01:07:48,660
0,300 300,540 540,750 750,990 990,1260
it's not only no longer
不仅不再有效，而且不再有意义，

2217
01:07:48,660 --> 01:07:51,780
0,540 1230,1890 1890,2040 2040,2250 2250,3120
valid, it's no longer meaningful,|
|

2218
01:07:51,990 --> 01:07:54,000
0,360 360,570 570,840 840,1710 1710,2010
because there's no translation for
因为没有给它的转换，

2219
01:07:54,000 --> 01:07:54,820
0,300
it,|
|

2220
01:07:55,080 --> 01:07:56,970
0,570 720,960 960,1020 1020,1470 1500,1890
{} so the CPU doesn't
所以 CPU 不知道如何处理它，

2221
01:07:56,970 --> 01:07:57,690
0,90 90,270 270,360 360,540 540,720
know what to do with

2222
01:07:57,690 --> 01:07:58,700
0,450
it,|
|

2223
01:07:58,790 --> 01:07:59,930
0,150 150,300 300,600 600,870 870,1140
like this virtual address won't
这个虚拟地址不会被缓存，

2224
01:07:59,930 --> 01:08:02,030
0,90 90,1020 1320,1590 1590,1860 1860,2100
be cached,| it's not even
|它甚至不在 TLB 中，

2225
01:08:02,030 --> 01:08:04,130
0,120 120,300 510,1440 1800,1980 1980,2100
in the TLB,| so there's
|所以内核没有方法

2226
01:08:04,130 --> 01:08:05,210
0,150 150,450 450,840 840,990 990,1080
just no way for the

2227
01:08:05,210 --> 01:08:07,010
0,390 390,750 780,1170 1170,1410 1410,1800
kernel| to decide what memory
|决定哪个内存对应于这个虚拟地址。

2228
01:08:07,010 --> 01:08:08,930
0,570 570,660 660,810 810,1110 1110,1920
corresponds to this virtual address.|
|

2229
01:08:10,600 --> 01:08:11,320
0,90 90,150 150,300 300,420 420,720
You know when this attack
当这种攻击在用户空间中执行时，

2230
01:08:11,320 --> 01:08:12,670
0,120 120,510 510,570 570,810 810,1350
is executed in user space,|
|

2231
01:08:12,880 --> 01:08:14,140
0,270 270,420 420,780 780,960 960,1260
because this virtual, this kernel
因为这个内核的虚拟地址不再有任何意义，

2232
01:08:14,140 --> 01:08:15,250
0,270 270,480 480,600 600,840 840,1110
virtual address no longer means

2233
01:08:15,250 --> 01:08:16,400
0,420
anything,|
|

2234
01:08:16,520 --> 01:08:18,200
0,480 720,870 870,1140 1380,1530 1530,1680
{} it's not, it's not
不是非法的，只是没有意义，

2235
01:08:18,200 --> 01:08:20,480
0,360 360,480 480,660 660,1320 2100,2280
illegal, it's just meaningless,| and
|所以这会导致攻击不起作用。

2236
01:08:20,480 --> 01:08:21,200
0,120 120,300 300,390 390,630 630,720
so that would cause the

2237
01:08:21,200 --> 01:08:23,120
0,510 660,870 870,960 960,1350
attack not to work.|
|

2238
01:08:23,420 --> 01:08:25,910
0,120 120,810 810,930 930,1440 1740,2490
The downside of this KASLR
这个 KASLR 修复的缺点是，

2239
01:08:26,120 --> 01:08:27,740
0,750 750,930 930,1080 1080,1380 1380,1620
fixes,| that now system calls
|现在系统调用更昂贵了，因为要切换页表。

2240
01:08:27,740 --> 01:08:29,180
0,60 60,150 150,540 540,900 960,1440
are more expensive, because switching

2241
01:08:29,180 --> 01:08:30,600
0,240 240,930
page tables.|
|

2242
01:08:32,610 --> 01:08:33,540
0,480 510,630 630,720 720,840 840,930
{} If you don't do
如果你不执行任何操作，

2243
01:08:33,540 --> 01:08:36,420
0,540 570,990 990,1260 1260,1980 2400,2880
anything,| switching page tables causes
|切换页表会导致 TLB 刷新，

2244
01:08:36,420 --> 01:08:37,860
0,120 120,720 720,840 840,1260 1260,1440
{the,TLB - -} flushed,| because
|因为现在所有那些虚拟地址和 TLB 都是错误的虚拟地址，

2245
01:08:37,860 --> 01:08:39,270
0,150 150,240 240,600 660,1020 1020,1410
now all those virtual addresses

2246
01:08:39,270 --> 01:08:40,710
0,90 90,570 570,810 900,1020 1020,1440
and TLB are the wrong

2247
01:08:40,710 --> 01:08:42,030
0,300 300,720 720,810 810,930 930,1320
virtual addresses,| that don't correspond
|不再与这个页表对应，

2248
01:08:42,030 --> 01:08:43,200
0,60 60,210 210,480 480,750 750,1170
to this page table anymore,|
|

2249
01:08:43,350 --> 01:08:44,490
0,300 300,390 390,690 690,810 810,1140
and it causes the L1
它会导致 L1 缓存被刷新，

2250
01:08:44,490 --> 01:08:45,720
0,300 300,420 420,540 540,1020 1020,1230
cache to be flushed,| because
|因为它是虚拟地址，

2251
01:08:45,720 --> 01:08:47,730
0,150 150,510 510,1110 1620,1800 1800,2010
it's virtually address| and so
|所以，在某些机器上，

2252
01:08:47,730 --> 01:08:48,600
0,390
on

2253
01:08:49,230 --> 01:08:50,730
0,210 210,450 450,1080 1080,1200 1200,1500
on some machines,| the switching
|切换页表会使系统调用变得相当慢。

2254
01:08:50,730 --> 01:08:52,120
0,240 240,570 570,840
page tables made

2255
01:08:52,120 --> 01:08:56,060
0,420 420,600 600,1110 1110,2040
system calls considerably slower.|
|

2256
01:08:56,820 --> 01:08:58,260
0,270 270,390 480,930 930,1200 1200,1440
In an recent machines actually
在最近的机器中，有一种叫做 PCID 的技巧，

2257
01:08:58,260 --> 01:08:59,310
0,120 120,270 270,480 480,720 720,1050
have this trick called {PCID

2258
01:08:59,310 --> 01:09:01,110
0,510 510,1080 1350,1500 1500,1620 1620,1800
-},| which you can look
|你可以查到，

2259
01:09:01,110 --> 01:09:02,160
0,270 270,420 420,750 750,990 990,1050
up,| but basically makes it,|
|但基本上是，|

2260
01:09:02,160 --> 01:09:03,960
0,150 150,300 300,510 510,1200 1230,1800
so you can avoid flushing
你可以避免切换页表时刷新这些缓存，

2261
01:09:03,960 --> 01:09:04,950
0,150 150,570 570,660 660,720 720,990
these caches on a page

2262
01:09:04,950 --> 01:09:06,180
0,240 240,660 690,900 900,960 960,1230
table switch,| although it still
|虽然还需要一些时间。

2263
01:09:06,180 --> 01:09:08,250
0,210 210,330 330,750 1740,2010 2010,2070
takes some time.| And if
|如果你在网络上随便看看，

2264
01:09:08,250 --> 01:09:09,390
0,210 210,510 510,750 750,840 840,1140
you poke around the web

2265
01:09:09,390 --> 01:09:10,620
0,210 210,360 360,870 870,990 990,1230
looking for people,| there was
|当时有很多人担心，

2266
01:09:10,620 --> 01:09:11,520
0,90 90,330 330,420 420,780 780,900
a lot of worry at

2267
01:09:11,520 --> 01:09:12,930
0,90 90,540 540,750 750,900 900,1410
the time,| that this split,
|这种拆分，这种两页表的想法会非常慢，

2268
01:09:13,020 --> 01:09:14,400
0,240 240,570 570,780 780,1080 1080,1380
that this two page table

2269
01:09:14,400 --> 01:09:17,310
0,300 300,570 990,1260 1260,2190 2190,2910
idea would be unacceptably slow,|
|

2270
01:09:17,640 --> 01:09:19,080
0,270 270,450 450,1110
now in fact,
事实上，这并不是一个严重的问题，

2271
01:09:19,200 --> 01:09:20,250
0,240 240,510 510,750 750,960 960,1050
that didn't really turn out

2272
01:09:20,250 --> 01:09:21,390
0,90 90,180 180,210 210,600 600,1140
to be a serious problem,|
|

2273
01:09:21,420 --> 01:09:22,320
0,150 150,210 210,330 330,570 570,900
and if you poke around,|
如果你四处看看，|

2274
01:09:22,320 --> 01:09:24,210
0,90 90,270 270,480 810,1290 1290,1890
you'll see that people's guesses
你会发现人们对典型工作量的猜测，

2275
01:09:24,210 --> 01:09:26,700
0,390 390,810 810,1920 2250,2430 2430,2490
about typical workloads,| you know
|它对典型工作量的整体性能有多大影响，

2276
01:09:26,700 --> 01:09:28,320
0,150 150,390 390,480 480,1050 1050,1620
how much it impacts overall

2277
01:09:28,320 --> 01:09:30,090
0,510 510,600 600,930 930,1560 1560,1770
performance of typical workloads,| which
|毕竟不会把所有的时间都花在进入和退出内核上，大概是 5% ，

2278
01:09:30,090 --> 01:09:31,110
0,240 240,360 360,540 540,840 840,1020
after all, don't spend all

2279
01:09:31,110 --> 01:09:32,790
0,150 150,720 810,1200 1200,1500 1500,1680
their time entering and exiting

2280
01:09:32,790 --> 01:09:34,950
0,450 660,930 930,1200 1260,1560 1560,2160
kernel, is like {5% -},|
|

2281
01:09:35,970 --> 01:09:37,260
0,450 660,870 870,1080 1080,1230 1230,1290
so it wasn't such a
所以这并不是一个很糟糕的决定。

2282
01:09:37,260 --> 01:09:38,220
0,180 180,510
bad deal.|
|

2283
01:09:40,200 --> 01:09:41,480
0,660

2284
01:09:41,690 --> 01:09:43,600
0,240 240,600 600,840 840,1350
Any questions about this
关于 KASLR 修复，有什么问题吗？

2285
01:09:43,690 --> 01:09:45,280
0,1110
KASLR

2286
01:09:45,280 --> 01:09:46,500
0,660
fix?|
|

2287
01:09:51,480 --> 01:09:52,620
0,570

2288
01:09:52,620 --> 01:09:54,330
0,120 120,630 690,1110 1110,1500 1530,1710
So people adopted this pretty
所以人们很快就接受了这项技术，

2289
01:09:54,330 --> 01:09:55,770
0,600 930,1050 1050,1230 1230,1320 1320,1440
rapidly,| in fact there had
|事实上，已经有内核采用了它，

2290
01:09:55,770 --> 01:09:57,210
0,270 300,660 660,750 750,870 870,1440
been kernels that had already

2291
01:09:57,210 --> 01:09:58,500
0,420 420,540 540,810 810,930 930,1290
adopted it,| because it defended
|因为它防御了一些其他的攻击。

2292
01:09:58,500 --> 01:10:00,300
0,210 210,330 330,510 510,1110
against some other attacks.|
|

2293
01:10:00,730 --> 01:10:02,000
0,660

2294
01:10:02,200 --> 01:10:04,030
0,180 180,480 480,990 990,1380 1380,1830
There's also a reasonable hardware
还有一个合理的硬件修复方案，

2295
01:10:04,030 --> 01:10:06,070
0,420 420,630 1110,1290 1290,1770 1770,2040
fix,| that I believe Intel
|我相信 Intel 是在最近的处理器中制造的，

2296
01:10:06,070 --> 01:10:07,390
0,120 120,390 390,660 660,960 1020,1320
it's actually made in recent

2297
01:10:07,390 --> 01:10:09,250
0,840 840,990 990,1320 1350,1740 1740,1860
processors| and that AMD had
|而 AMD 已经制造了，

2298
01:10:09,250 --> 01:10:10,390
0,270 270,480 480,570 570,750 750,1140
already made,| and that's basically
|这是因为权限，

2299
01:10:10,390 --> 01:10:14,140
0,330 780,2220 2220,2940
to because the,

2300
01:10:14,350 --> 01:10:16,320
0,180 180,780 780,1260
in fact, the

2301
01:10:16,730 --> 01:10:18,710
0,810 1170,1410 1410,1470 1470,1650 1650,1980
permission,| you know this is
|这是缓存的结构，

2302
01:10:19,310 --> 01:10:20,480
0,330 330,690 690,750 750,810 810,1170
the structure of the cache,|
|

2303
01:10:20,480 --> 01:10:23,060
0,450 1230,1380 1380,1950 1950,2250 2250,2580
when an instruction loads something
当指令从 L1 缓存中加载某些东西时，

2304
01:10:23,060 --> 01:10:24,110
0,120 120,180 180,330 330,540 540,1050
from the {L1 -} cache,|
|

2305
01:10:24,110 --> 01:10:25,310
0,270 270,450 450,780 780,1110 1110,1200
like this kernel data, we're
比如我们试图攻击的内核数据，

2306
01:10:25,310 --> 01:10:28,310
0,240 240,300 300,990 1740,2130 2130,3000
trying to attack,| the permissions
|人们相信权限就在缓存条目中，

2307
01:10:28,880 --> 01:10:30,320
0,420 420,600 600,900 900,1260 1260,1440
{} or people believe that

2308
01:10:30,320 --> 01:10:31,520
0,90 90,480 480,570 570,930 930,1200
the permissions are sitting right

2309
01:10:31,520 --> 01:10:32,810
0,240 240,330 330,390 390,750 750,1290
there in the cache entry,|
|

2310
01:10:33,050 --> 01:10:34,040
0,210 210,330 330,480 480,600 600,990
and so there's no trouble
所以， CPU 在该点检查权限不会有任何问题，

2311
01:10:34,040 --> 01:10:35,060
0,120 120,210 210,600 600,930 930,1020
with the CPU checking the

2312
01:10:35,060 --> 01:10:36,560
0,450 450,510 510,690 690,1140 1230,1500
permissions at that point,| and
|实际上， AMD CPU 和现代的 Intel CPU ，

2313
01:10:36,560 --> 01:10:38,860
0,540 630,960 960,1770
indeed, {} AMD

2314
01:10:38,860 --> 01:10:40,660
0,510 510,630 630,810 810,1230 1230,1800
{CPUs -} and perhaps {modern

2315
01:10:40,750 --> 01:10:42,490
0,330 330,870 870,1110 1320,1530 1530,1740
-} Intel CPUs| will actually
|会很早就进行权限检查，

2316
01:10:42,490 --> 01:10:43,570
0,120 120,210 210,570 570,780 780,1080
do the permission check very

2317
01:10:43,570 --> 01:10:45,370
0,360 360,660 660,1020 1050,1590 1590,1800
early| and won't return this
|不会返回这个数据，

2318
01:10:45,370 --> 01:10:47,050
0,510 750,900 900,1080 1080,1290 1290,1680
data,| they won't even return
|它们甚至不会把它返回给核心，

2319
01:10:47,050 --> 01:10:48,340
0,120 120,210 210,300 300,870 990,1290
it to the core,| if
|如果权限检查不起作用。

2320
01:10:48,340 --> 01:10:49,780
0,90 90,480 480,780 780,930 930,1440
the permission checks don't workout.|
|

2321
01:10:49,930 --> 01:10:51,400
0,210 210,390 390,600 600,720 720,1470
So there's none of this
所以这些预测指令不能看到被禁止的数据。

2322
01:10:51,430 --> 01:10:53,020
0,570 570,1170 1170,1260 1260,1470 1470,1590
speculative instructions are able to

2323
01:10:53,020 --> 01:10:56,760
0,720 1350,1860 2310,2790
see forbidden data.|
|

2324
01:10:57,120 --> 01:10:58,140
0,450 450,690 690,810 810,930 930,1020
So I I don't know
我不知道你是否知道这个问题的答案，

2325
01:10:58,140 --> 01:10:59,010
0,120 120,240 240,420 420,540 540,870
if you know the answer

2326
01:10:59,010 --> 01:11:00,540
0,60 60,360 360,990 990,1170 1170,1530
to this question| is probably
|可能只是推测，但并不是有意的，

2327
01:11:00,540 --> 01:11:04,020
0,570 570,1770 1770,2040 2070,2580 2760,3480
just speculative, but {} no

2328
01:11:04,020 --> 01:11:05,760
0,210 210,780 810,1200 1200,1500 1500,1740
[] intended,| {} but why,
|但是为什么你认为 Intel 会这么做，

2329
01:11:05,760 --> 01:11:06,960
0,330 330,390 390,540 540,810 810,1200
why do you think Intel

2330
01:11:06,960 --> 01:11:08,190
0,180 180,330 330,750 780,1050 1050,1230
would do this,| like this
|这看起来像是。

2331
01:11:08,190 --> 01:11:10,440
0,300 300,630 930,1530 1740,2160 2160,2250
seems like.| Okay.| Because to
|好的。|因为在我看来，这似乎是一场讨论，

2332
01:11:10,440 --> 01:11:11,370
0,210 210,300 300,570 570,810 810,930
me, it seems like it

2333
01:11:11,370 --> 01:11:12,570
0,180 180,240 240,840 840,1050 1050,1200
was a discussion,| shall we
|我们应该检查临时指令的权限吗，

2334
01:11:12,570 --> 01:11:15,030
0,240 240,900 900,1260 1260,1800 1800,2460
check permissions on transient instructions|
|

2335
01:11:15,030 --> 01:11:15,810
0,240 240,300 300,420 420,600 600,780
and they were just like
他们只是想，为什么麻烦只需要一个简单的检查。

2336
01:11:15,810 --> 01:11:17,760
0,210 210,540 540,840 840,1440 1740,1950
know why, why bother will

2337
01:11:17,760 --> 01:11:18,990
0,180 180,390 390,450 450,840 840,1230
need just a simple check.|
|

2338
01:11:19,740 --> 01:11:22,200
0,330 330,870 1050,1620 1620,1860 1860,2460
Why bother,| indeed stuff transparent
为什么，|用户无法以任何一种方式查看数据，

2339
01:11:22,200 --> 01:11:23,130
0,270 270,360 360,660 660,780 780,930
and the users not be

2340
01:11:23,130 --> 01:11:23,730
0,120 120,180 180,300 300,360 360,600
able to see the data

2341
01:11:23,730 --> 01:11:25,620
0,210 210,690 930,1500 1500,1590 1590,1890
either way,| during the check
|通过早期检查。

2342
01:11:25,620 --> 01:11:26,540
0,600
early.|
|

2343
01:11:26,540 --> 01:11:27,590
0,120 120,240 240,480 480,810 810,1050
You know that's like some
这就像是一条非常关键的路径上的门，

2344
01:11:27,590 --> 01:11:29,390
0,690 690,1140 1140,1260 1260,1470 1470,1800
gates on a pretty critical

2345
01:11:29,390 --> 01:11:31,190
0,660 690,900 900,1110 1200,1590 1680,1800
path, right,| the the you
|L1 数据缓存的核心，

2346
01:11:31,190 --> 01:11:31,940
0,150
know

2347
01:11:32,070 --> 01:11:33,690
0,150 150,600 600,750 750,1080 1080,1620
the core of L1 data

2348
01:11:33,900 --> 01:11:35,340
0,930
cache,|
|

2349
01:11:35,340 --> 01:11:37,770
0,450 450,660 660,1440 1440,1890 1890,2430
path is extremely performance critical,|
路径对性能极为关键，|

2350
01:11:38,010 --> 01:11:38,850
0,210 210,360 360,570 570,720 720,840
you know if you can
如果你能减少几个晶体管，

2351
01:11:38,850 --> 01:11:40,530
0,510 510,570 570,750 750,1410 1410,1680
shave a few transistors off

2352
01:11:40,530 --> 01:11:41,560
0,360
the,|
|

2353
01:11:42,200 --> 01:11:43,520
0,150 150,300 300,510 510,870 960,1320
you know off the critical
从关键路径上减少，

2354
01:11:43,520 --> 01:11:45,620
0,270 270,390 390,1050 1320,1650 1650,2100
path here,| between issuing instruction
|在发出指令和取回数据之间，

2355
01:11:45,620 --> 01:11:46,640
0,90 90,270 270,360 360,600 600,1020
and getting the data back,|
|

2356
01:11:46,880 --> 01:11:47,990
0,180 180,390 390,660 660,840 840,1110
you know that may may
这可能会让你拥有稍微快一点的周期时间，

2357
01:11:47,990 --> 01:11:48,830
0,450 450,540 540,630 630,780 780,840
allow you to have a

2358
01:11:48,830 --> 01:11:50,480
0,420 420,780 780,1110 1110,1440 1440,1650
slightly faster cycle time| and
|并更快地运行程序。

2359
01:11:50,660 --> 01:11:52,200
0,240 240,690 690,1110
run programs faster.|
|

2360
01:11:52,640 --> 01:11:53,760
0,570

2361
01:11:53,820 --> 01:11:54,450
0,180 180,270 270,360 360,570 570,630
And so it's got to
所以一定是这样的，

2362
01:11:54,450 --> 01:11:55,740
0,90 90,180 180,630 630,870 1050,1290
be the case,| that I
|我不知道一定是这样的，

2363
01:11:55,740 --> 01:11:56,280
0,120 120,210 210,360 360,420 420,540
don't know got to be

2364
01:11:56,280 --> 01:11:57,570
0,60 60,360 360,570 690,990 990,1290
the case,| but it's easy
|但不难想象，

2365
01:11:57,570 --> 01:11:59,280
0,150 150,900 1020,1350 1350,1590 1590,1710
to imagine that,| it would
|会花费几个晶体管，

2366
01:11:59,280 --> 01:12:00,000
0,90 90,390 390,510 510,570 570,720
have cost them a few

2367
01:12:00,000 --> 01:12:03,120
0,1110 1380,1680 1710,2220 2220,2880 2880,3120
transistors| to actually enforce the
|来提前检查权限，

2368
01:12:03,150 --> 01:12:05,190
0,660 660,1170 1500,1680 1680,1920 1920,2040
permissions early,| because after all
|因为退出后，他们仍然需要所有的东西，

2369
01:12:05,190 --> 01:12:07,050
0,120 120,600 600,1320 1350,1770 1770,1860
they still need all of

2370
01:12:07,050 --> 01:12:08,670
0,60 60,300 300,420 420,1260 1440,1620
the stuff at retirement,| it's
|这并不是说早做就能省去他们以后的一些工作，

2371
01:12:08,670 --> 01:12:09,990
0,120 120,270 270,510 510,630 630,1320
not like doing it early

2372
01:12:10,050 --> 01:12:11,250
0,330 330,630 630,780 780,960 960,1200
would save them some work

2373
01:12:11,250 --> 01:12:13,170
0,300 300,630 780,1440 1530,1830 1830,1920
later on,| they still have
|他们仍然必须将错误推迟到退出。

2374
01:12:13,170 --> 01:12:14,400
0,90 90,600 600,690 690,1020 1020,1230
to defer the fault until

2375
01:12:14,400 --> 01:12:15,540
0,810
retirement.|
|

2376
01:12:15,710 --> 01:12:16,880
0,450

2377
01:12:17,400 --> 01:12:18,330
0,210 210,300 300,450 450,690 690,930
So all that stuff, still
所以所有的东西，还在那里，

2378
01:12:18,330 --> 01:12:19,280
0,420
there,|
|

2379
01:12:19,750 --> 01:12:21,040
0,360 360,540 540,930 930,1080 1080,1290
I'm just guessing that it
我只是猜测，这看起来不会有什么好处，

2380
01:12:22,000 --> 01:12:22,810
0,330 330,510 510,630 630,690 690,810
didn't seem like it would

2381
01:12:22,810 --> 01:12:24,820
0,150 150,300 300,1050 1050,1380 1740,2010
have any advantages| and would
|而且会有一点额外的工作。

2382
01:12:24,820 --> 01:12:25,750
0,90 90,240 240,540 540,780 780,930
have been a little bit

2383
01:12:25,750 --> 01:12:27,140
0,60 60,360 360,870
of extra work.|
|

2384
01:12:28,600 --> 01:12:29,820
0,690

2385
01:12:30,000 --> 01:12:31,590
0,420 510,720 720,1110 1110,1350 1350,1590
{} And into either way
以及进入任何一种完全不可见的方式，

2386
01:12:31,590 --> 01:12:34,500
0,360 360,870 1440,2130 2130,2700 2700,2910
completely invisible,| theoretically invisible too,
|在架构层面上，理论上也是不可见的。

2387
01:12:34,500 --> 01:12:36,360
0,270 270,330 330,930 930,1290
at the architectural level.|
|

2388
01:12:36,390 --> 01:12:38,040
0,270 270,510 510,1020 1020,1500 1500,1650
Did any kernel decide to
是否有内核决定恢复 KASLR 修复程序，

2389
01:12:38,040 --> 01:12:40,170
0,360 360,1050 1050,1170 1170,1650 1650,2130
like revert this {KASLR -}

2390
01:12:40,200 --> 01:12:42,450
0,540 570,1500 1500,1740 1740,2040 2040,2250
{} fix,| now that be
|现在 Intel 已经修复了 CPU ，

2391
01:12:42,450 --> 01:12:44,100
0,360 390,870 870,1170 1170,1530 1530,1650
like Intel has fixed the

2392
01:12:44,100 --> 01:12:45,930
0,720 810,1020 1020,1290 1290,1560 1590,1830
CPU,| { - -} do
|来再次提高性能。

2393
01:12:45,930 --> 01:12:47,700
0,390 390,930 930,1320 1500,1650 1650,1770
improve performance again.| I know
|我知道很多内核都是可选的，

2394
01:12:47,700 --> 01:12:48,570
0,120 120,510 510,630 630,690 690,870
it's optional on a lot

2395
01:12:48,570 --> 01:12:50,850
0,60 60,630 720,960 960,1740 1770,2280
of kernels,| {I'm -} not
|我不太清楚 Intel 的修复是怎么回事，

2396
01:12:50,850 --> 01:12:52,160
0,480 480,870
totally sure

2397
01:12:53,890 --> 01:12:54,850
0,300 300,570 570,750 750,840 840,960
what's going on with the

2398
01:12:54,850 --> 01:12:56,740
0,240 240,900 1020,1260 1260,1620 1620,1890
Intel fix,| I'm fairly sure
|我肯定他们已经有了解决办法，

2399
01:12:56,740 --> 01:12:57,550
0,120 120,210 210,390 390,570 570,810
that they have this fix

2400
01:12:57,550 --> 01:13:00,120
0,180 180,420 420,720 750,1950
out there,| but exactly
|但确切地说，我不知道发生了什么。

2401
01:13:00,590 --> 01:13:01,820
0,150 150,210 210,510 510,840 1020,1230
you know I I I

2402
01:13:01,820 --> 01:13:02,570
0,120 120,270 270,360 360,510 510,750
don't really know what's going

2403
01:13:02,570 --> 01:13:04,220
0,180 570,870 870,990 990,1230 1230,1650
on.| {I,think,in} the Linux kernel,|
|我认为在 Linux 内核中，|

2404
01:13:04,220 --> 01:13:05,600
0,120 120,210 210,360 360,780 780,1380
you can just ask which
你可以直接问哪些硬件实现了修复，

2405
01:13:05,630 --> 01:13:07,370
0,570 570,810 810,990 990,1110 1110,1740
hardware fixes have been implemented,|
|

2406
01:13:07,370 --> 01:13:09,020
0,210 210,690 690,780 780,1080 1080,1650
and Linux you know changes
Linux 会修改启用[缓解]，

2407
01:13:09,020 --> 01:13:10,040
0,480
the

2408
01:13:10,040 --> 01:13:11,780
0,150 150,660 660,840 840,1320 1320,1740
{} [mitigation] that enables| depending
|根据硬件告诉它的。

2409
01:13:11,780 --> 01:13:12,800
0,150 150,330 330,660 660,750 750,1020
on what actually the hardware

2410
01:13:12,800 --> 01:13:13,820
0,270 270,480
tells it.|
|

2411
01:13:14,840 --> 01:13:16,700
0,300 300,570 570,1230 1410,1740 1740,1860
So might.| {Oh,so}, so you
也有可能。|所以你可以这么做，

2412
01:13:16,700 --> 01:13:17,930
0,360 390,600 600,690 690,1050 1050,1230
can, you can actually do

2413
01:13:17,930 --> 01:13:19,280
0,210 210,390 390,480 480,780 780,1350
that,| like you can read
|你可以读取足够的关于处理器的信息，

2414
01:13:19,310 --> 01:13:21,170
0,420 420,720 720,960 960,1020 1020,1860
enough info about the processor|
|

2415
01:13:21,260 --> 01:13:22,640
0,330 330,420 420,870 870,1050 1050,1380
as the kernel to know
内核知道如何去做。

2416
01:13:22,640 --> 01:13:24,230
0,390 390,660 660,750 750,1110 1350,1590
whether what to do.| You
|你可以运行你的笔记本电脑，

2417
01:13:24,230 --> 01:13:25,490
0,150 150,450 450,690 690,1080 1080,1260
can run your run your

2418
01:13:25,490 --> 01:13:26,750
0,450 450,600 600,660 660,930 930,1260
laptop,| there's a Linux command,|
|有一个 Linux 命令，|

2419
01:13:26,750 --> 01:13:28,430
0,150 150,300 300,600 600,1350 1350,1680
that is actually yeah on
它会告诉你，

2420
01:13:28,430 --> 01:13:29,260
0,360
like

2421
01:13:30,310 --> 01:13:31,330
0,240 240,330 330,510 510,780 780,1020
which is why it tells

2422
01:13:31,330 --> 01:13:32,710
0,90 90,690 690,960 960,1230 1230,1380
you,| exactly what fixes have
|在硬件中实施了哪些修复，

2423
01:13:32,710 --> 01:13:33,820
0,90 90,570 570,750 750,1020 1020,1110
been implemented where things are

2424
01:13:33,820 --> 01:13:35,500
0,570 570,630 630,1170
mitigated in hardware,|
|

2425
01:13:36,040 --> 01:13:37,270
0,240 240,330 330,450 450,780 780,1230
this is a wide range
这是范围很广的各自的应用程序攻击。

2426
01:13:37,270 --> 01:13:39,550
0,150 150,570 600,1170 1170,1740 1740,2280
of these respective applications attacks.|
|

2427
01:13:40,380 --> 01:13:41,460
0,210 210,480 480,660 660,810 810,1080
Are you saying that Linux
你是说 Linux 会使用组合页表，

2428
01:13:41,460 --> 01:13:42,450
0,90 90,300 300,480 480,540 540,990
will actually use the combined

2429
01:13:42,450 --> 01:13:44,220
0,300 300,720 720,930 930,1080 1080,1770
page table,| if the CPU.|
|如果 CPU 。|

2430
01:13:45,360 --> 01:13:46,440
0,540
Cool.|
好的。|

2431
01:13:51,020 --> 01:13:52,640
0,120 120,360 360,630 1050,1440 1440,1620
{I,think} {it,was}, for {99% -
我想， 99% 确认，

2432
01:13:52,640 --> 01:13:53,900
0,300 300,360 360,570 570,840 840,1260
-},| I haven't checked it
|我最近没有检查过，

2433
01:13:53,900 --> 01:13:55,700
0,300 330,1080 1110,1410 1410,1590 1590,1800
recently,| I believe that's still
|我相信情况仍是如此。

2434
01:13:55,700 --> 01:13:57,340
0,60 60,750
the case.|
|

2435
01:14:04,040 --> 01:14:05,390
0,510 510,660 660,840 840,990 990,1350
Sorry, so what were people
抱歉，那么人们是怎么做的，

2436
01:14:05,390 --> 01:14:07,310
0,690 720,1170 1350,1560 1560,1770 1770,1920
doing,| like like how did
|比如他们是怎么找到这个的，

2437
01:14:07,310 --> 01:14:09,260
0,150 150,720 750,1050 1050,1530 1680,1950
they find find this,| what
|他们想要做什么。

2438
01:14:09,260 --> 01:14:10,820
0,60 60,480 720,990 990,1140 1140,1560
are they trying to do.|
|

2439
01:14:11,180 --> 01:14:12,560
0,390 390,540 540,930 930,990 990,1380
{What,are} they trying to do,|
他们想做什么，|

2440
01:14:12,860 --> 01:14:14,480
0,420 420,480 480,720 720,840 840,1620
trying to break into computers.|
试图闯入计算机。|

2441
01:14:14,900 --> 01:14:16,760
0,840 900,1380
{} Well,
谁知道他们实际想做什么，

2442
01:14:17,220 --> 01:14:19,100
0,1020
the,

2443
01:14:19,540 --> 01:14:20,440
0,210 210,420 420,510 510,690 690,900
who knows what they're really

2444
01:14:20,440 --> 01:14:21,430
0,180 180,240 240,540 600,660 660,990
trying to do,| I mean
|我的意思是这些论文是由不同的学者撰写的，

2445
01:14:21,430 --> 01:14:23,500
0,90 90,930 930,1440 1440,1620 1620,2070
the papers are written by

2446
01:14:24,010 --> 01:14:26,820
0,870 870,1560 1560,2100
various academics,| maybe
|也许他们的研究发现了安全问题。

2447
01:14:26,850 --> 01:14:29,370
0,120 120,330 330,900 1230,1830 1830,2520
you know their research is

2448
01:14:29,400 --> 01:14:30,760
0,960
finding

2449
01:14:30,980 --> 01:14:33,050
0,450 450,1320 1410,1650 1650,1860 1860,2070
security problems.| I think more
|我认为更多的是，

2450
01:14:33,050 --> 01:14:34,490
0,240 240,480 480,690 690,930 1140,1440
that guys find,| that one
|人们很长时间以来的动机是，

2451
01:14:34,490 --> 01:14:35,360
0,120 120,210 210,690 690,810 810,870
thing the motive for a

2452
01:14:35,360 --> 01:14:36,440
0,180 180,480 480,660 660,840 840,1080
long time is,| they wanted
|他们想要打破地址空间的随机化。

2453
01:14:36,440 --> 01:14:38,990
0,60 60,420 420,1590 1590,1830 1830,2550
to break address space randomization.|
|

2454
01:14:40,020 --> 01:14:41,670
0,330 330,480 480,630 630,1140 1140,1650
And they had earlier papers,|
他们有更早的论文，|

2455
01:14:41,670 --> 01:14:42,840
0,120 120,210 210,330 330,630 630,1170
you know the different schemes
使用不同的方案试图打破地址随机化，

2456
01:14:42,840 --> 01:14:44,010
0,270 270,360 360,660 690,930 930,1170
trying to break {address -}

2457
01:14:44,010 --> 01:14:45,360
0,360 360,510 510,990 990,1170 1170,1350
{randomization - -},| so only
|所以，有一组的研究人员

2458
01:14:45,360 --> 01:14:47,130
0,270 270,450 450,780 900,1260 1260,1770
one group of one stream

2459
01:14:47,130 --> 01:14:48,060
0,120 120,570 570,690 690,810 810,930
of researchers| that were in
|在这个领域，有这方面的背景。

2460
01:14:48,060 --> 01:14:49,680
0,150 150,660 1020,1350 1350,1530 1530,1620
this area had that as

2461
01:14:49,680 --> 01:14:50,860
0,60 60,600
a background.|
|

2462
01:14:50,860 --> 01:14:52,480
0,60 60,660 690,960 960,1320 1320,1620
{} I think project zero
我认为 project zero 是从一个完全不同的角度来的。

2463
01:14:52,480 --> 01:14:53,710
0,330 330,540 540,720 720,840 840,1230
people came from a completely

2464
01:14:53,710 --> 01:14:54,980
0,270 270,690
different angle.|
|

2465
01:15:00,170 --> 01:15:01,940
0,300 300,570 810,1290 1290,1410 1410,1770
This is people have seen
这是，像 Robert 之前说过的，

2466
01:15:01,940 --> 01:15:03,170
0,360 360,480 480,900 900,1140 1140,1230
Robert said before,| people have
|人们在这个领域已经工作了几十年，

2467
01:15:03,170 --> 01:15:04,040
0,90 90,360 360,420 420,510 510,870
been working in this area

2468
01:15:04,040 --> 01:15:05,810
0,150 150,810 810,900 900,1020 1020,1770
for decades,| you know trying
|试着找出漏洞，他们可以利用并理解。

2469
01:15:06,980 --> 01:15:09,200
0,690 690,1170 1170,1560 1560,1710 1710,2220
find bugs they can exploit

2470
01:15:10,200 --> 01:15:12,240
0,390 600,1410
and understand.|
|

2471
01:15:17,160 --> 01:15:19,290
0,630 660,780 780,1140 1170,1440 1530,2130
So, I guess this, how
所以，我想这是一个很难回答的问题，

2472
01:15:19,560 --> 01:15:20,430
0,270 270,330 330,390 390,570 570,870
this is a hard question

2473
01:15:20,430 --> 01:15:22,110
0,60 60,300 300,450 450,780 810,1680
to answer,| but like how
|但有多大可能会发生另一起类似的 meltdown 事件，

2474
01:15:22,110 --> 01:15:23,700
0,600 600,750 750,870 870,1170 1350,1590
likely is it that there's

2475
01:15:23,700 --> 01:15:25,020
0,780
another

2476
01:15:25,270 --> 01:15:27,280
0,390 570,1290 1290,1590 1590,1830 1830,2010
like meltdown out there,| because
|因为看起来。

2477
01:15:27,280 --> 01:15:30,160
0,120 120,510 510,1440 1440,2100 2280,2880
it seems.| Extremely likely.| Okay,|
|极有可能。|好的，|

2478
01:15:30,790 --> 01:15:32,980
0,450 450,930 1200,1470 1470,2010 2010,2190
like micro, the fundamentally {like,thing}
从根本上讲，微架构露变化。

2479
01:15:32,980 --> 01:15:34,810
0,120 120,510 540,1080 1080,1230 1230,1830
with {micro-architecture -} like exposing

2480
01:15:34,810 --> 01:15:37,040
0,720
changes.|
|

2481
01:15:37,040 --> 01:15:38,510
0,330 330,690 690,960 960,1080 1080,1470
That's right, I I think
是的，我想事情是这样的，

2482
01:15:38,660 --> 01:15:39,920
0,510 510,750 750,960 960,1080 1080,1260
what's going on is that,|
|

2483
01:15:39,920 --> 01:15:42,830
0,240 270,660 660,1470 1530,2310 2760,2910
the CPU manufacturers have for
CPU 厂商几十年来一直是，

2484
01:15:42,830 --> 01:15:44,840
0,540 540,690 690,1260 1260,1410 1410,2010
decades and decades have been,|
|

2485
01:15:45,490 --> 01:15:48,160
0,960 1170,1620 1620,1860 1860,2310 2310,2670
{} you know often adding
会加上越来越多的[乐观的]，

2486
01:15:48,160 --> 01:15:49,090
0,270 270,360 360,570 570,660 660,930
more and more and more

2487
01:15:49,090 --> 01:15:51,100
0,510 510,780 780,1110 1110,1470 1470,2010
[optimistic],| there's many many many
|有许多很酷的小技巧，

2488
01:15:51,130 --> 01:15:52,750
0,300 300,420 420,930 930,1140 1140,1620
sort of cool little tricks|
|

2489
01:15:52,750 --> 01:15:54,490
0,390 390,480 480,780 780,1410 1410,1740
inside the {micro-architecture -} for
在微架构中，让事情进行得更快，

2490
01:15:54,730 --> 01:15:57,100
0,360 360,600 600,750 750,1320 1560,2370
making things go faster,| and
|人们并不太担心，

2491
01:15:57,900 --> 01:15:59,190
0,120 120,180 180,570 570,780 780,1290
you know now and end

2492
01:16:00,580 --> 01:16:02,050
0,300 300,480 480,690 690,900 900,1470
people didn't worry that much|
|

2493
01:16:02,050 --> 01:16:03,010
0,240 270,480 480,660 660,900 900,960
or it just wasn't on
或者只是没有引起注意，

2494
01:16:03,010 --> 01:16:04,300
0,90 90,570 570,780 780,990 990,1290
the radar,| that this could
|这可能是一个严重的安全问题，

2495
01:16:04,300 --> 01:16:06,880
0,720 840,1110 1110,1590 1590,2100 2100,2580
be a serious security problem,|
|

2496
01:16:07,330 --> 01:16:09,070
0,330 330,420 420,1080 1290,1620 1620,1740
and so now people now
所以现在人们非常意识到，

2497
01:16:09,070 --> 01:16:10,150
0,210 210,630 630,750 750,870 870,1080
very aware that,| this stuff
|这可能是一个严重的安全问题，

2498
01:16:10,150 --> 01:16:11,260
0,120 120,270 270,390 390,720 720,1110
could be a serious security

2499
01:16:11,260 --> 01:16:12,790
0,450 480,930 1080,1290 1290,1440 1440,1530
problem,| but we're now in
|但我们现在所处的位置是，

2500
01:16:12,790 --> 01:16:13,840
0,60 60,390 390,540 540,660 660,1050
a position where we're living|
|

2501
01:16:13,840 --> 01:16:15,610
0,390 390,480 480,630 630,1230 1230,1770
with you know thirty years
在 CPU 内部 30 年来的聪明想法中。

2502
01:16:15,610 --> 01:16:17,350
0,210 210,690 690,1350 1350,1650 1650,1740
of clever ideas inside the

2503
01:16:17,350 --> 01:16:18,640
0,510 510,930
{CPUs -}.|
|

2504
01:16:18,640 --> 01:16:20,260
0,90 90,390 630,1080 1080,1200 1200,1620
And so, indeed a bunch
所以，很多，

2505
01:16:20,260 --> 01:16:22,300
0,510 780,1470 1470,1620 1620,1860 1860,2040
of,| since this paper came
|自从这篇论文发表以来，

2506
01:16:22,300 --> 01:16:23,200
0,150 150,240 240,450 450,720 720,900
out,| and indeed before this
|在这篇论文发表之前，

2507
01:16:23,200 --> 01:16:24,640
0,330 330,540 540,750 900,1140 1140,1440
paper came out,| a bunch
|一大堆，

2508
01:16:24,640 --> 01:16:26,260
0,150 150,390 390,660 870,1290 1290,1620
of kind of,| a bunch
|这种类型的攻击已经曝光，

2509
01:16:26,260 --> 01:16:28,330
0,390 420,660 660,1290 1290,1380 1380,2070
of this style of attacks

2510
01:16:28,330 --> 01:16:30,310
0,420 420,630 630,750 750,1110 1110,1980
have come to light exploiting|
|

2511
01:16:30,490 --> 01:16:32,340
0,480 480,1080
various different
各种不同的微结构 CPU ，

2512
01:16:33,630 --> 01:16:36,080
0,390 390,1440
{micro-architectural -}

2513
01:16:36,460 --> 01:16:38,800
0,750 750,900 900,1380 1380,1650 1770,2340
these and {CPUs -},| so
|所以我认为一段时间，

2514
01:16:38,800 --> 01:16:39,820
0,450 450,600 600,750 750,870 870,1020
I think this is gonna

2515
01:16:39,820 --> 01:16:41,470
0,120 120,180 180,510 510,1110 1260,1650
be a while,| before this
|在[稳定]之前。

2516
01:16:41,470 --> 01:16:43,120
0,150 150,300 300,450 450,1020 1290,1650
all laid to rest.| We've
|在过去的两年里，我们看过安全会议，

2517
01:16:43,120 --> 01:16:44,500
0,210 210,300 330,720 720,1260 1260,1380
looked at security conferences in

2518
01:16:44,500 --> 01:16:45,580
0,60 60,420 420,600 600,720 720,1080
the last {you,know} two years,|
|

2519
01:16:45,580 --> 01:16:47,950
0,480 480,990 990,1650 1710,1950 1950,2370
basically every year every conference
基本上每年的会议

2520
01:16:47,950 --> 01:16:50,650
0,360 360,780 780,1050 1050,1770 1920,2700
basically session| on like exploiting
|都是关于利用预测执行属性，

2521
01:16:50,650 --> 01:16:52,360
0,450 450,1260
speculative execution

2522
01:16:52,620 --> 01:16:54,480
0,750 840,1380 1410,1650 1650,1770 1770,1860
properties,| and see if they
|看看他们是否会发动攻击。

2523
01:16:54,480 --> 01:16:56,220
0,150 150,600 630,990 990,1320 1320,1740
can make {attacks -} work.|
|

2524
01:16:57,210 --> 01:16:58,620
0,330 330,630 630,690 690,960 960,1410
And maybe a larger question
也许一个更大的问题是，

2525
01:16:58,620 --> 01:17:00,060
0,120 120,840
is whether,|
|

2526
01:17:00,240 --> 01:17:01,530
0,150 150,210 210,660 660,750 750,1290
you know whether the situation
情况是不是，

2527
01:17:01,530 --> 01:17:03,030
0,270 300,810 810,900 900,1110 1110,1500
is,| well, you know there's
|有 15 、 20 或 30 件事情，

2528
01:17:03,780 --> 01:17:05,130
0,210 210,510 540,990 990,1050 1050,1350
you know 15 or 20

2529
01:17:05,130 --> 01:17:07,470
0,60 60,390 390,1260 1260,1890 1920,2340
or 30 things,| that sort
|需要解决，

2530
01:17:07,470 --> 01:17:08,310
0,60 60,240 240,360 360,480 480,840
of have to be worked

2531
01:17:08,310 --> 01:17:09,750
0,390 390,510 510,1200 1230,1350 1350,1440
out,| and then we'll be
|然后我们完成了，

2532
01:17:09,750 --> 01:17:11,020
0,630
done,|
|

2533
01:17:11,470 --> 01:17:13,220
0,360 360,1200
or whether
或者有更高层次的方法出了问题，

2534
01:17:13,570 --> 01:17:16,180
0,270 270,990 1020,1350 1350,1740 1740,2610
there's some much higher levels

2535
01:17:17,120 --> 01:17:20,540
0,510 540,1680 1770,2340 2340,3210 3240,3420
{} approach gone wrong,| you
|你知道我们所有，

2536
01:17:20,540 --> 01:17:22,200
0,120 120,300 300,450 450,1050
know that we all,|
|

2537
01:17:22,260 --> 01:17:23,280
0,240 240,360 360,690 690,870 870,1020
this is probably way too
这可能太悲观了，

2538
01:17:23,280 --> 01:17:25,260
0,690 690,900 1380,1830 1830,1950 1950,1980
pessimistic,| but people have a
|但人们对隔离作为一种想法很有信心，

2539
01:17:25,260 --> 01:17:26,640
0,240 240,300 300,570 570,660 660,1380
lot of faith in isolation

2540
01:17:26,880 --> 01:17:28,170
0,210 210,300 300,630 630,810 810,1290
as an idea,| that there's
|有一件完全合理的事情要做，

2541
01:17:28,170 --> 01:17:29,190
0,30 30,420 420,720 720,930 930,1020
a totally reasonable thing to

2542
01:17:29,190 --> 01:17:30,020
0,270
do,|
|

2543
01:17:30,900 --> 01:17:32,550
0,360 360,750 750,1230 1230,1560 1560,1650
assume that isolation works and
假设隔离起作用，并将设计一些东西，

2544
01:17:32,550 --> 01:17:33,930
0,120 120,570 570,900 900,1050 1050,1380
will design stuff,| like cloud
|比如云计算和在浏览器中运行 Javascript ，

2545
01:17:33,930 --> 01:17:36,870
0,690 690,1140 1770,2340 2340,2880 2880,2940
computing and running Javascript in

2546
01:17:36,870 --> 01:17:37,860
0,60 60,660 660,750 750,840 840,990
the browser| and all this
|以及所有这些假设下的东西，

2547
01:17:37,860 --> 01:17:39,540
0,270 270,420 420,540 540,1110 1140,1680
stuff under the assumption,| which
|这可能不是真的，

2548
01:17:39,570 --> 01:17:40,560
0,120 120,300 300,600 600,870 870,990
is not actually true,| but
|但它被认为是足够接近真实的，

2549
01:17:40,560 --> 01:17:41,820
0,60 60,210 210,510 510,810 870,1260
it was close enough believed

2550
01:17:41,820 --> 01:17:42,540
0,60 60,150 150,390 390,630 630,720
to be close enough to

2551
01:17:42,540 --> 01:17:44,550
0,480 720,990 990,1530 1530,1650 1650,2010
true,| that isolation will just
|这种隔离导致它们不会成为严重的安全问题，

2552
01:17:44,550 --> 01:17:45,420
0,90 90,390
you know

2553
01:17:45,420 --> 01:17:46,110
0,240 240,330 330,510 510,600 600,690
cause they're not to be

2554
01:17:46,110 --> 01:17:48,300
0,330 330,720 720,1410 1740,1950 1950,2190
serious security problems,| and that's
|这实际上可能还是可行的，

2555
01:17:48,420 --> 01:17:50,180
0,360 360,690 690,1140
actually probably still

2556
01:17:50,180 --> 01:17:52,000
0,510 720,1230
doable,| but
|但可以肯定的是，这个微架构攻击

2557
01:17:52,030 --> 01:17:53,980
0,570 570,840 840,1230 1230,1590 1620,1950
this whole [] of {micro-architectural

2558
01:17:53,980 --> 01:17:56,040
0,570 570,1560
-} attacks|
|

2559
01:17:56,390 --> 01:17:57,950
0,480 480,690 690,870 870,1290 1290,1560
not made that story seem
并没有让这个故事看起来更有说服力。

2560
01:17:57,950 --> 01:17:59,750
0,180 180,810 1170,1380 1380,1470 1470,1800
more convincing, that's for sure.|
|

2561
01:18:02,400 --> 01:18:03,570
0,480 480,630 630,870 870,1050 1050,1170
Just to add on to
更进一步的，

2562
01:18:03,570 --> 01:18:05,880
0,450 840,1140 1140,1470 1470,1740 1740,2310
that,| {} I'm not sure
|我不确定 [] CPU 设计，

2563
01:18:05,910 --> 01:18:08,310
0,510 600,1080 1080,1380 1380,2130 2130,2400
a [] levels expertise would

2564
01:18:08,310 --> 01:18:10,320
0,330 360,810 810,1320 1320,1590 1710,2010
like CPU design,| but to
|但是，能不能直接扩展 CPU ，在没有微体系结构的情况下，

2565
01:18:10,320 --> 01:18:13,890
0,210 210,870 870,1680 1950,2700 2700,3570
what extent can CPU design

2566
01:18:13,950 --> 01:18:16,770
0,330 330,840 840,2070 2070,2670 2700,2820
be made straightforwardly without a

2567
01:18:16,770 --> 01:18:20,190
0,480 480,1440 1620,2010 2010,2580 2700,3420
{micro-architecture -},| while still preserving
|仍然保持它的高性能。

2568
01:18:20,190 --> 01:18:23,280
0,570 600,870 870,1620 1800,2850 2970,3090
its high performance.| Performance, I
|性能，我是说，人们相信这些东西。

2569
01:18:23,280 --> 01:18:24,100
0,450
mean,

2570
01:18:24,130 --> 01:18:25,990
0,270 270,510 510,630 630,1110 1350,1860
people believe this stuff.| Nicely
|安全也不错，不过是的。

2571
01:18:25,990 --> 01:18:28,270
0,570 570,1110 1140,1530 1560,1980 2070,2280
security too, but yeah.| Well,
|有些事情很明显是可以修复的，

2572
01:18:28,270 --> 01:18:29,230
0,210 210,300 300,450 450,840 840,960
some of this clearly can

2573
01:18:29,230 --> 01:18:30,400
0,120 120,390 390,540 540,720 720,1170
be fixed,| like this meltdown
|比如这个 meltdown 事件，

2574
01:18:30,400 --> 01:18:31,240
0,270 270,330 330,450 450,690 690,840
thing,| I mean there is
|我的意思是有一个修复，你可以检查权限，

2575
01:18:31,240 --> 01:18:33,520
0,60 60,840 870,1230 1650,1860 1860,2280
a fix this you actually

2576
01:18:33,520 --> 01:18:36,670
0,330 330,480 480,1260 1710,2490 2610,3150
check the permissions,| {} that
|可能不会损失任何性能，

2577
01:18:36,700 --> 01:18:39,010
0,600 600,840 840,1380 1380,1530 1530,2310
probably doesn't sacrifice any performance,|
|

2578
01:18:39,220 --> 01:18:39,970
0,240 240,390 390,450 450,570 570,750
for some of the other
对于已经出现的其他一些攻击，

2579
01:18:39,970 --> 01:18:40,870
0,330 330,420 420,510 510,660 660,900
attacks that have come up,|
|

2580
01:18:41,690 --> 01:18:42,840
0,600

2581
01:18:43,590 --> 01:18:44,850
0,210 210,360 360,780 780,990 1110,1260
it's not clear that you
还不清楚你可以在不损失性能的情况下修复它们，

2582
01:18:44,850 --> 01:18:46,110
0,120 120,360 360,480 480,720 720,1260
could fix them without sacrificing

2583
01:18:46,110 --> 01:18:47,100
0,600 660,690 690,780 780,930 930,990
performance,| I mean some of
|我是说一些非常深的东西，

2584
01:18:47,100 --> 01:18:48,330
0,150 150,450 450,690 690,990 990,1230
this very very deep,| like
|就像我们分享的事实，

2585
01:18:48,390 --> 01:18:49,860
0,240 240,480 480,570 570,690 690,1470
the fact that we're sharing|
|

2586
01:18:50,130 --> 01:18:52,200
0,480 480,750
you know,
这里有很多分享，

2587
01:18:52,400 --> 01:18:53,480
0,570 570,720 720,780 780,1020 1020,1080
this there's a lot of

2588
01:18:53,480 --> 01:18:54,920
0,390 390,570 570,720 720,1020 1020,1440
sharing,| like a time sharing
|比如云环境中的时间共享，

2589
01:18:54,920 --> 01:18:56,180
0,120 120,450 450,930 930,1110 1110,1260
a cloud environment,| there's just
|有很多共享，

2590
01:18:56,180 --> 01:18:57,860
0,60 60,300 300,360 360,870 1110,1680
a lot of sharing,| and
|比如，假设你的云服务器上有一个磁盘驱动器或网络，

2591
01:18:58,910 --> 01:19:00,860
0,690 720,990 990,1110 1110,1620 1650,1950
{} so, for example suppose

2592
01:19:00,860 --> 01:19:02,000
0,180 180,300 300,570 570,990 990,1140
there's a disk drive or

2593
01:19:02,000 --> 01:19:05,390
0,90 90,990 1470,1800 1800,2520 2700,3390
a network on your cloud

2594
01:19:05,390 --> 01:19:08,300
0,780 1020,1500 2010,2490 2520,2700 2700,2910
server, right,| gosh, you might
|你也许能得到云服务器上其他人的信息，

2595
01:19:08,300 --> 01:19:09,230
0,90 90,240 240,300 300,420 420,930
be able to get information

2596
01:19:09,230 --> 01:19:10,160
0,180 180,300 300,510 510,780 780,930
about the other people on

2597
01:19:10,160 --> 01:19:12,350
0,180 180,570 570,1080 1290,1980 1980,2190
that cloud server,| simply by
|只需观察它们的流量，

2598
01:19:12,350 --> 01:19:14,360
0,450 450,750 750,1050 1050,1530 1530,2010
watching how their traffic| interferes
|

2599
01:19:14,360 --> 01:19:15,860
0,90 90,240 240,720 720,1350 1350,1500
with your traffic {disk,traffic} or
干扰你的磁盘流量、网络流量或内存流量等。

2600
01:19:15,860 --> 01:19:17,600
0,330 330,810 810,900 900,1290 1290,1740
network traffic or memory traffic

2601
01:19:17,600 --> 01:19:18,890
0,150 150,540 690,870 870,1020 1020,1290
or something.| So there's some
|所以有一种，

2602
01:19:18,950 --> 01:19:19,960
0,240 240,510
sort of,|
|

2603
01:19:20,240 --> 01:19:20,840
0,210 210,300 300,390 390,450 450,600
I, you know I don't
我不知道，

2604
01:19:20,840 --> 01:19:21,980
0,150 150,330 330,510 510,930 930,1140
know,| but that's practical,| maybe
|但这是实际的，|也许很多事情，

2605
01:19:21,980 --> 01:19:23,480
0,150 150,360 360,810 1140,1350 1350,1500
it's not although you know

2606
01:19:23,480 --> 01:19:24,950
0,180 180,510 510,780 780,1410 1410,1470
for many many things| in
|人们在这些事情中说，

2607
01:19:24,950 --> 01:19:25,940
0,180 180,390 390,630 630,870 870,990
which people said point that|
|

2608
01:19:25,940 --> 01:19:26,840
0,300 300,480 480,660 660,840 840,900
attack just doesn't seem to
攻击可能是不实际的，

2609
01:19:26,840 --> 01:19:28,860
0,90 90,750 1080,1170 1170,1440
be practical,| you know
|事实证明它很实用。

2610
01:19:28,950 --> 01:19:29,550
0,90 90,330 330,450 450,510 510,600
it turned out to be

2611
01:19:29,550 --> 01:19:31,940
0,420 420,990
practical enough.|
|

2612
01:19:32,170 --> 01:19:34,000
0,420 420,810 810,1290
And I think.|
我认为。|

2613
01:19:34,690 --> 01:19:35,500
0,270 270,480 480,570 570,750 750,810
And so a lot of
所以很多这种微架构的东西，

2614
01:19:35,500 --> 01:19:37,030
0,240 240,510 510,1050 1050,1290 1290,1530
this {micro-architectural -} stuff,| maybe
|也许可以在不降低性能的情况下进行清理，

2615
01:19:37,030 --> 01:19:38,110
0,150 150,240 240,540 540,780 780,1080
could be cleaned up without

2616
01:19:38,110 --> 01:19:39,460
0,480 480,750 750,810 810,1050 1050,1350
performance loss,| or maybe can't
|或者可能无法在不损失性能的情况下进行清理，

2617
01:19:39,460 --> 01:19:40,630
0,90 90,360 360,480 480,720 720,1170
be cleaned up without performance

2618
01:19:40,630 --> 01:19:42,730
0,420 720,1080 1080,1500 1500,1710 1710,2100
loss,| but I think it's,|
|但我认为，|

2619
01:19:43,750 --> 01:19:44,710
0,540 570,720 720,840 840,930 930,960
{} I think it's a
我认为这是一个比我们实施修复更严重的问题，

2620
01:19:44,710 --> 01:19:45,880
0,180 180,300 300,660 660,1050 1050,1170
much more serious problem than

2621
01:19:45,880 --> 01:19:47,200
0,210 210,300 300,780
just we're gonna

2622
01:19:47,460 --> 01:19:49,100
0,360 360,990
applies fixes,|
|

2623
01:19:50,260 --> 01:19:51,660
0,360 360,870
{they'll,go} away.|
他们会消失的。|

2624
01:19:52,650 --> 01:19:53,640
0,180 180,330 330,540 540,630 630,990
And the place is the
而最尖锐的地方是密码学，

2625
01:19:53,670 --> 01:19:56,280
0,570 600,1080 1080,1200 1200,2040 2280,2610
most acute is cryptography,| there's
|已经有很多年，

2626
01:19:56,280 --> 01:19:58,350
0,270 300,840 840,1110 1110,1680 1680,2070
been many many years of|
|

2627
01:19:58,880 --> 01:20:00,140
0,300 300,600 600,810 810,1080 1080,1260
people looking into these kind
人们在研究这种聪明，

2628
01:20:00,140 --> 01:20:03,260
0,60 60,1080 2070,2430 2430,2730 2730,3120
of clever,| often cache timing
|通常缓存基于分时的密钥位，

2629
01:20:03,260 --> 01:20:07,080
0,660 1020,1770 1770,1860 1860,3240
based ways of sensing

2630
01:20:09,000 --> 01:20:10,680
0,360 360,630 630,750 750,1440 1440,1680
bit set of keys| and
|和其他人的密码，

2631
01:20:10,680 --> 01:20:13,650
0,300 300,1020 1020,1830 2250,2700 2700,2970
other people's cryptographic,| people running
|人们在同一台机器上运行密码学加密，

2632
01:20:13,650 --> 01:20:15,570
0,210 210,450 450,630 630,1440 1440,1920
{} running at cryptographic encryption

2633
01:20:15,570 --> 01:20:16,740
0,60 60,150 150,420 420,990 990,1170
on the same machine as

2634
01:20:16,740 --> 01:20:19,290
0,360 840,1410 1410,1650 1650,2160 2160,2550
you,| can you guess anything
|你能猜出我的密钥吗，

2635
01:20:19,290 --> 01:20:22,480
0,270 270,960 960,1470 1620,2610
about {my,key}| by watching,
|通过观察，通过进行缓存计时，

2636
01:20:22,930 --> 01:20:24,910
0,150 150,330 330,720 720,1200 1560,1980
by doing cache timing,| {answer,is}
|答案是绝对的。

2637
01:20:24,910 --> 01:20:27,430
0,900 1620,1890 1890,2010 2010,2250 2250,2520
absolutely.| And it's not a
|而且它不是微架构的 bug ，

2638
01:20:27,430 --> 01:20:29,680
0,300 300,840 840,1710
{micro-architectural -} bugs,|
|

2639
01:20:32,010 --> 01:20:33,540
0,300 300,510 510,690 810,1440 1440,1530
it's just a consequence of
它是经常分享的结果。

2640
01:20:33,540 --> 01:20:34,620
0,450
sharing

2641
01:20:34,620 --> 01:20:35,560
0,330
often.|
|

2642
01:20:35,620 --> 01:20:36,340
0,300 300,360 360,480 480,540 540,720
Anyway I don't know how
不管怎么说，我不知道这件事会怎样发展，

2643
01:20:36,340 --> 01:20:37,210
0,210 210,300 300,480 480,690 690,870
this is gonna play out,|
|

2644
01:20:37,210 --> 01:20:38,200
0,120 120,270 270,690 720,870 870,990
but it's not it's not
这不是直截了当的。

2645
01:20:38,200 --> 01:20:39,360
0,600
straightforward.|
|

2646
01:20:40,610 --> 01:20:42,140
0,210 210,600 630,900 900,1260 1260,1530
I mean this curious part
我好奇的是，

2647
01:20:42,140 --> 01:20:43,580
0,90 90,270 270,600 600,870 870,1440
is,| when people made progress
|当人们取得进展的时候，

2648
01:20:43,580 --> 01:20:47,090
0,900 1230,1890 2100,2490 2490,3000 3000,3510
on,| {} just measuring the
|只需测量 CPU 的电磁辐射，

2649
01:20:47,120 --> 01:20:49,250
0,540 630,840 840,1200 1200,1950 1950,2130
like {EM -} radiation from

2650
01:20:49,250 --> 01:20:50,660
0,90 90,630 630,810 810,1260 1260,1410
a CPU| and figuring out
|并找出正在运行的指令和其中包含的数据，

2651
01:20:50,660 --> 01:20:52,010
0,180 180,900 900,990 990,1230 1230,1350
what instructions are run and

2652
01:20:52,010 --> 01:20:53,000
0,240 240,480 480,630 630,780 780,990
what data is in it,|
|

2653
01:20:53,270 --> 01:20:54,890
0,180 180,510 510,1020 1050,1320 1320,1620
with machine learning with like
使用机器学习有一定的精确度，

2654
01:20:54,890 --> 01:20:56,390
0,300 300,1020 1020,1170 1170,1290 1290,1500
some accuracy,| you know not
|不是百分之百，不是很近，

2655
01:20:56,390 --> 01:20:58,100
0,30 30,300 300,810 900,1320 1320,1710
a hundred percent, not nearly,|
|

2656
01:20:58,100 --> 01:21:00,440
0,360 390,840 1530,1710 1710,2100 2100,2340
but like a scary amount
但精确度高得吓人，

2657
01:21:00,440 --> 01:21:01,880
0,90 90,660 660,870 870,1200 1200,1440
of accuracy,| because anything over
|因为任何超过零的东西都是可怕的。

2658
01:21:01,880 --> 01:21:03,720
0,300 300,420 420,990
zero is scary.|
|

2659
01:21:07,840 --> 01:21:08,920
0,300 300,450 450,600 600,840 840,1080
Yeah, we all live in
是的，我们知道，

2660
01:21:08,920 --> 01:21:11,940
0,150 150,240 240,420 420,1020
you know that's all,|
|

2661
01:21:12,180 --> 01:21:13,950
0,330 750,1020 1020,1080 1080,1470 1470,1770
well, there's a boundary between
好的，攻击有界限的，

2662
01:21:13,950 --> 01:21:18,120
0,570 570,720 720,1020 3480,4020 4020,4170
attacks that are,| there's some
|在可能的攻击之间有一定的门槛，

2663
01:21:18,120 --> 01:21:19,320
0,450 450,660 660,720 720,1080 1080,1200
threshold between the attacks that

2664
01:21:19,320 --> 01:21:21,060
0,300 450,1200 1200,1500 1500,1590 1590,1740
are possible,| but you know
|但是，这看起来太贵了，

2665
01:21:21,060 --> 01:21:22,860
0,660 660,900 900,1200 1200,1650 1680,1800
gosh just seems like that

2666
01:21:22,860 --> 01:21:23,850
0,90 90,210 210,360 360,900 900,990
would be too expensive| or
|或者太痛苦，不管什么复杂的东西都不能实施。

2667
01:21:23,850 --> 01:21:26,340
0,540 540,1020 1020,1860 1890,2400 2400,2490
awkward painful whatever complex to

2668
01:21:26,340 --> 01:21:27,580
0,330 330,810
carry out.|
|

2669
01:21:28,270 --> 01:21:29,840
0,540
And,
而且，攻击真的可能会发生，

2670
01:21:29,930 --> 01:21:30,740
0,90 90,390 390,570 570,720 720,810
{attacks -} really could be

2671
01:21:30,740 --> 01:21:31,610
0,330 330,480 480,540 540,750 750,870
carried out,| of course we
|当然我们应该只防御第二类，

2672
01:21:31,610 --> 01:21:32,600
0,180 180,330 330,660 660,930 930,990
only should defend against the

2673
01:21:32,600 --> 01:21:34,010
0,270 270,660 660,840 840,930 930,1410
second class,| because the first
|因为第一类通常太贵了，无法防御，

2674
01:21:34,040 --> 01:21:35,270
0,300 300,360 360,600 600,690 690,1230
class is often too expensive

2675
01:21:35,270 --> 01:21:37,490
0,90 90,450 450,960 1350,1710 1710,2220
to defend against,| but as
|但随着包含计算机的东西的价值变得越来越大，

2676
01:21:37,490 --> 01:21:39,110
0,120 120,480 480,570 570,1200 1200,1620
the value of stuff containing

2677
01:21:39,110 --> 01:21:41,900
0,450 450,600 600,1320 1320,1740 2280,2790
computers gets larger,| and attackers
|攻击者变得更聪明，更接近共享环境，

2678
01:21:41,900 --> 01:21:43,550
0,120 120,240 240,1020 1050,1290 1290,1650
get more clever get more

2679
01:21:43,700 --> 01:21:46,220
0,390 390,960 960,1140 1230,1740 1740,2520
closer access to shared environments,|
|

2680
01:21:47,000 --> 01:21:48,290
0,300 300,360 360,930 930,1020 1020,1290
kind of threshold by which
攻击足够可行以防御变化的一种阈值。

2681
01:21:48,290 --> 01:21:49,780
0,510 510,960
attacks are

2682
01:21:51,370 --> 01:21:53,020
0,630 630,810 810,900 900,1230 1230,1650
feasible enough to defend against

2683
01:21:53,020 --> 01:21:54,280
0,570
changes.|
|

2684
01:21:58,610 --> 01:21:59,800
0,720
Alright,
好了，我的课讲完了，

2685
01:22:00,020 --> 01:22:03,200
0,180 180,570 1080,1560 2550,3060 3060,3180
I'm done with {the,lecture},| I'm
|如果有问题的话，我很乐意回答更多的问题。

2686
01:22:03,200 --> 01:22:04,520
0,270 270,480 480,720 720,840 840,1320
happy to take more questions,

2687
01:22:04,520 --> 01:22:06,680
0,450 900,1320 1320,1590
if people have.|
|

2688
01:22:09,210 --> 01:22:10,660
0,270 270,720
Thank you.|
谢谢。|

2689
01:22:11,280 --> 01:22:13,830
0,330 330,600 1470,1920 1950,2160 2160,2550
Thank you.| Thanks, I actually
谢谢。|谢谢，我有个关于缓存的问题，

2690
01:22:13,830 --> 01:22:14,610
0,90 90,180 180,450 450,690 690,780
had a question about the

2691
01:22:14,610 --> 01:22:17,130
0,750 990,1320 1320,1800 1980,2310 2310,2520
cache,| {} so the {L1
|L1 缓存是每个 CPU 的。

2692
01:22:17,130 --> 01:22:19,680
0,360 420,1110 1470,2040 2070,2310 2310,2550
-} cache is its per

2693
01:22:19,680 --> 01:22:24,150
0,840 870,1410 2250,2850 3750,4230 4230,4470
CPU, right.| Yes.| And L2
|是的。|而 L2 不是共享的。

2694
01:22:24,150 --> 01:22:27,630
0,240 240,930 1110,2040 2910,3150 3150,3480
isn't shared.| Well, so this
|那么这张图对于每个 CPU 来说是不一样的，

2695
01:22:27,630 --> 01:22:28,500
0,270 270,360 360,630 630,750 750,870
picture is different for each

2696
01:22:28,500 --> 01:22:30,690
0,480 480,720 720,1260 1440,2100 2100,2190
CPU,| for different models of
|对于不同型号的 CPU 是不一样的，

2697
01:22:30,690 --> 01:22:33,000
0,420 420,990 1050,1470 1500,1740 1740,2310
CPU, etc,| the the habit
|今天的习惯是，

2698
01:22:33,030 --> 01:22:34,240
0,810
today

2699
01:22:34,700 --> 01:22:38,600
0,1170 1200,1560 1560,1950 1950,2670 3120,3900
is| looks it's a little
|看起来比这个要复杂一点，

2700
01:22:38,600 --> 01:22:40,040
0,120 120,270 270,780 780,930 930,1440
bit more complex than this,|
|

2701
01:22:40,160 --> 01:22:42,620
0,510 510,570 570,960 960,1920
typically a multiple cores,|
通常是多核，|

2702
01:22:43,170 --> 01:22:45,000
0,450 600,930 930,1020 1020,1470 1470,1830
{} 2 {} 4 8
2 4 8 或 64 等，

2703
01:22:45,000 --> 01:22:47,730
0,240 240,810 810,1230 1980,2220 2220,2730
or 64 something,| each one
|每一个都有一个 L1 缓存，

2704
01:22:47,730 --> 01:22:48,990
0,270 270,390 390,570 570,840 840,1260
has a {L1 -} cache,|
|

2705
01:22:48,990 --> 01:22:50,130
0,210 210,570 570,930 930,1020 1020,1140
that's quite close to the
它离 CPU 很近，

2706
01:22:50,130 --> 01:22:52,230
0,570 570,690 690,840 840,1560 1710,2100
CPU,| but it's small fast
|但它又快又小，

2707
01:22:52,230 --> 01:22:53,910
0,90 90,600 900,1170 1170,1380 1380,1680
and small,| each core typically
|每个核心通常还有更大的 L2 缓存，

2708
01:22:53,910 --> 01:22:55,230
0,330 330,480 480,570 570,930 930,1320
also has a bigger L2

2709
01:22:55,230 --> 01:22:56,820
0,390 390,1140
cache,| this
|它是专为那个 CPU 设计的。

2710
01:22:57,720 --> 01:22:58,590
0,180 180,270 270,600 600,780 780,870
you know it's sort of

2711
01:22:58,590 --> 01:23:00,200
0,630 630,720 720,1020
dedicated to that

2712
01:23:00,350 --> 01:23:01,860
0,960
CPU.|
|

2713
01:23:02,160 --> 01:23:03,680
0,840

2714
01:23:04,150 --> 01:23:06,920
0,240 240,990 1440,2160
And then, {}
然后，通常会有一个共享的 L3 缓存，

2715
01:23:07,590 --> 01:23:10,020
0,420 450,1020 1050,1620 1620,1920 1920,2430
and then there's often a

2716
01:23:10,020 --> 01:23:13,530
0,1110 1560,1830 1830,2100 2100,2910 3150,3510
shared {L3 -} cache,| often
|通常但不总是，

2717
01:23:13,530 --> 01:23:15,270
0,90 90,270 270,1050 1230,1410 1410,1740
but not always,| and another
|另一种方法是使 L2 缓存的总和

2718
01:23:15,270 --> 01:23:16,350
0,420 420,540 540,660 660,900 900,1080
approach is to make the

2719
01:23:16,910 --> 01:23:18,710
0,750 750,840 840,960 960,1410 1410,1800
summation of the L2 cache|
|

2720
01:23:18,710 --> 01:23:21,260
0,660 990,1350 1350,1470 1650,2340 2340,2550
is sort of convenient for
在某种程度上方便所有 CPU 使用，

2721
01:23:21,260 --> 01:23:22,190
0,180 180,270 270,720 720,810 810,930
all the {CPUs -} to

2722
01:23:22,190 --> 01:23:22,850
0,240 240,330 330,450 450,540 540,660
use,| so that I have
|这样我可以超高速访问 L2 缓存，

2723
01:23:22,880 --> 01:23:24,470
0,330 330,750 780,1200 1200,1530 1530,1590
super high speed access to

2724
01:23:24,470 --> 01:23:26,060
0,180 180,450 450,810 810,1020 1290,1590
my L2 cache,| but I
|但是我可以得到其他人稍微重一点的[处罚]，

2725
01:23:26,060 --> 01:23:27,230
0,210 210,420 420,600 600,780 780,1170
can get at other people

2726
01:23:27,230 --> 01:23:28,850
0,180 180,450 480,840 840,1050 1050,1620
said a slightly bigger [penalties],|
|

2727
01:23:28,850 --> 01:23:30,650
0,150 150,840 840,1110 1110,1410 1410,1800
the effective cache size larger,|
有效缓存大小越大，|

2728
01:23:30,740 --> 01:23:32,510
0,210 210,450 450,660 660,1140 1470,1770
so often three see either
所以，通常可以看到三级缓存，

2729
01:23:32,510 --> 01:23:34,220
0,210 210,420 420,930 930,1230
three level caches| or
|或者是一种连接到二级缓存的缓存。

2730
01:23:34,580 --> 01:23:36,350
0,300 300,300 1050,1380 1380,1440 1440,1770
or a sort of joint

2731
01:23:36,350 --> 01:23:38,380
0,240 330,660 660,870 870,1500
to second level caches.|
|

2732
01:23:39,210 --> 01:23:40,380
0,570

2733
01:23:41,000 --> 01:23:42,470
0,210 210,540 540,750 1050,1380 1380,1470
And typically the L2 and
通常 L2 和 L3 是物理寻址的， L1 是虚拟的。

2734
01:23:42,470 --> 01:23:43,880
0,90 90,330 330,420 420,780 780,1410
{L3 -} are physically addressed,

2735
01:23:44,500 --> 01:23:45,640
0,660
{L1,is,virtual}.|
|

2736
01:23:47,980 --> 01:23:49,150
0,300 300,390 390,600 600,750 750,1170
Sorry, so what's the point
抱歉，有实际地址有什么意义。

2737
01:23:49,150 --> 01:23:51,740
0,90 90,390 390,1230 1260,2100
of having physically address,

2738
01:23:51,830 --> 01:23:55,400
0,780 960,1890 2730,3000 3000,3330 3360,3570
yeah, yeah it's.| Yeah, it's
|是的，这很简单， L1 缓存中的东西是虚拟地址缓存。

2739
01:23:55,400 --> 01:23:58,220
0,630 630,990 1020,1740 1950,2520 2520,2820
easy, the {} {stuff,in,L1 -}

2740
01:23:58,220 --> 01:23:59,810
0,210 210,270 270,600 600,900 900,1590
cache, a virtual address cache.|
|

2741
01:24:00,740 --> 01:24:02,100
0,750

2742
01:24:02,220 --> 01:24:04,650
0,720 720,810 810,1170 1170,1890 2160,2430
If the same data is
如果相同的数据使用不同的虚拟地址，

2743
01:24:04,650 --> 01:24:05,850
0,210 210,300 300,540 540,780 780,1200
used with different virtual addresses,|
|

2744
01:24:05,850 --> 01:24:07,110
0,120 120,450 450,540 540,630 630,1260
you can't you know the
虚拟地址缓存不会帮你找到它，

2745
01:24:07,260 --> 01:24:08,700
0,420 420,660 660,900 900,1200 1200,1440
virtual address cache doesn't help

2746
01:24:08,700 --> 01:24:10,060
0,120 120,450 450,810
you find it,|
|

2747
01:24:10,060 --> 01:24:10,930
0,300 300,420 420,480 480,600 600,870
{} if it was cache
如果这些 L2 缓存在不同地址下，

2748
01:24:10,930 --> 01:24:11,950
0,180 180,210 210,480 480,840 840,1020
under a different address where

2749
01:24:11,950 --> 01:24:13,960
0,300 570,1110 1110,1710 1710,1830 1830,2010
these L2 caches,| the data
|则数据是独立的，

2750
01:24:13,960 --> 01:24:16,000
0,90 90,960 1170,1530 1590,1950 1950,2040
is independent,| is usable no
|无论你的地址是什么虚拟地址。

2751
01:24:16,000 --> 01:24:18,070
0,150 150,390 390,690 690,1410 1440,2070
matter what virtual address you

2752
01:24:18,070 --> 01:24:19,360
0,360 360,450 450,630 630,810
address it and {}.|
|

2753
01:24:19,960 --> 01:24:21,660
0,1230

2754
01:24:22,380 --> 01:24:24,330
0,690 690,960 960,1200 1200,1590 1590,1950
Where does the MMU use,|
MMU 在哪里使用，|

2755
01:24:24,330 --> 01:24:26,040
0,210 510,1230 1230,1380 1380,1500 1500,1710
it relative to all these
它相对于 TLB 中的所有这些缓存。

2756
01:24:26,040 --> 01:24:28,140
0,510 510,600 600,690 690,1140 1170,2100
caches in the TLB.| Oh,
|哦，它不是，它是分布的，

2757
01:24:28,200 --> 01:24:30,180
0,270 270,600 600,960 960,1710 1710,1980
it's not it's distributed really,|
|

2758
01:24:30,180 --> 01:24:32,010
0,270 270,510 510,930 1320,1680 1680,1830
because the {} I mean
我的意思是，最明显的，

2759
01:24:32,010 --> 01:24:33,960
0,180 240,810 810,1560
the most obvious,|
|

2760
01:24:34,530 --> 01:24:36,480
0,390 1080,1290 1290,1500 1500,1740 1740,1950
I mean I think in
我认为在现实生活中，

2761
01:24:36,480 --> 01:24:38,080
0,330 330,1020
real life,|
|

2762
01:24:38,930 --> 01:24:40,730
0,480 480,630 630,1410 1500,1590 1590,1800
{the,TLB - -} the most
TLB 最关键的是，

2763
01:24:40,730 --> 01:24:42,050
0,390 390,510 510,630 630,780 780,1320
critical thing is that TLB,|
|

2764
01:24:42,050 --> 01:24:43,100
0,120 120,180 180,450 450,600 600,1050
and I believe it's indexed
我认为它通常与 L1 缓存并行索引。

2765
01:24:43,100 --> 01:24:44,090
0,90 90,660 660,750 750,870 870,990
in parallel with the {L1

2766
01:24:44,090 --> 01:24:45,760
0,210 210,540 540,1110
-} cache typically.|
|

2767
01:24:46,300 --> 01:24:46,930
0,180 180,270 270,360 360,570 570,630
So if you hit in
所以如果你命中缓存，

2768
01:24:46,930 --> 01:24:48,520
0,90 90,780 990,1170 1170,1350 1350,1590
the cache,| the L1 cache
|L1 缓存，尽管可能会有。

2769
01:24:48,520 --> 01:24:50,110
0,540 720,1050 1050,1200 1200,1380 1380,1590
great, although there may be

2770
01:24:50,110 --> 01:24:50,920
0,240
a.|
|

2771
01:24:52,740 --> 01:24:53,490
0,330 330,420 420,510 510,600 600,750
Anyway, and if you miss
不管怎样，如果你错过了 L1 缓存，

2772
01:24:53,490 --> 01:24:55,470
0,180 180,420 420,810 810,1350 1620,1980
the L1 cache,| then now
|那么现在你有物理的，

2773
01:24:55,470 --> 01:24:56,370
0,90 90,210 210,330 330,750 750,900
you have the physical,| you
|你同时在 TLB 中查找，

2774
01:24:56,370 --> 01:24:57,210
0,120 120,510 510,630 630,690 690,840
were looking up in that

2775
01:24:57,210 --> 01:24:57,810
0,120 120,210 210,270 270,360 360,600
{TLB -} at the same

2776
01:24:57,810 --> 01:24:59,070
0,180 180,420 420,630 630,960 960,1260
time,| now your physical can
|现在物理可以寻址了，

2777
01:24:59,250 --> 01:25:00,680
0,750
addressed,|
|

2778
01:25:01,550 --> 01:25:02,630
0,180 180,540 540,660 660,810 810,1080
the MMU that was not
MMU 不只是一个放在某个地方的盒子，

2779
01:25:02,630 --> 01:25:04,200
0,240 240,300 300,900
just a single

2780
01:25:04,460 --> 01:25:05,930
0,600 600,720 720,930 930,1230 1230,1470
box that sits somewhere,| it's
|它有点[牵涉其中]。

2781
01:25:05,930 --> 01:25:07,360
0,360 360,600 600,780
actually kind of

2782
01:25:07,630 --> 01:25:08,840
0,720
involved.|
|

2783
01:25:09,890 --> 01:25:11,540
0,420 480,690 690,930 930,1050 1050,1650
Okay, but isn't it hardware,
好的，但这不是硬件吗，所以。

2784
01:25:11,600 --> 01:25:13,010
0,480 630,810 810,1080 1080,1230 1230,1410
so.| Oh, everything is yours
|哦，一切都是硬件，是的。

2785
01:25:13,010 --> 01:25:14,300
0,300 300,720
hardware, yeah.|
|

2786
01:25:15,530 --> 01:25:17,030
0,480 480,810 810,1350 1350,1440 1440,1500
But remember these you know
但请记住，这些芯片上有数十亿个晶体管，

2787
01:25:17,030 --> 01:25:19,400
0,600 630,1020 1020,1260 1290,2280 2280,2370
these chips have billions of

2788
01:25:19,400 --> 01:25:21,770
0,660 660,840 840,1080 1230,1860 2160,2370
transistors on them,| so yeah,
|所以，是的，也许是硬件问题，

2789
01:25:21,770 --> 01:25:23,300
0,210 210,330 330,840 840,1170 1200,1530
maybe it's hardware,| but we're
|但我们谈论的是非常复杂的硬件，

2790
01:25:23,300 --> 01:25:24,500
0,270 270,690
talking about

2791
01:25:24,950 --> 01:25:28,370
0,750 750,1260 1260,1950 2190,2820 2820,3420
massively complex hardware,| that's designed
|它是使用非常复杂的软件设计，

2792
01:25:28,370 --> 01:25:30,500
0,240 240,540 540,1290 1290,1860 1860,2130
using very sophisticated software like

2793
01:25:30,500 --> 01:25:32,270
0,390 390,1200 1230,1410 1410,1590 1590,1770
design techniques,| so that it
|所以它可以做非常复杂的事情，

2794
01:25:32,270 --> 01:25:33,600
0,120 120,750
can do

2795
01:25:33,720 --> 01:25:35,490
0,420 420,660 660,1110 1110,1200 1200,1770
very very complex and sophisticated

2796
01:25:35,490 --> 01:25:37,410
0,660 1020,1230 1230,1410 1410,1530 1530,1920
things,| so yeah, it's hardware,|
|所以，它是硬件，|

2797
01:25:37,410 --> 01:25:38,120
0,210
but,
但是，它一点也不简单。

2798
01:25:38,720 --> 01:25:40,550
0,1050 1050,1140 1140,1320 1320,1380 1380,1830
yeah, it's not at all

2799
01:25:40,550 --> 01:25:42,540
0,120 120,330 330,1110
at all straightforward.|
|

2800
01:25:43,320 --> 01:25:45,780
0,840 900,1350 1350,1740 1740,2280 2280,2460
So do table mapping like
表映射是否像页表映射一样最终会出现在缓存中，

2801
01:25:45,780 --> 01:25:47,520
0,480 480,930 930,1290 1290,1500 1500,1740
{page,table} mappings ever end up

2802
01:25:47,520 --> 01:25:49,800
0,270 270,570 1140,1740 1740,1950 1950,2280
in the caches at all,|
|

2803
01:25:49,800 --> 01:25:51,090
0,360 360,510 510,600 600,1050 1050,1290
or are they always just
或者它们总是通过 TLB 路由，

2804
01:25:51,090 --> 01:25:52,260
0,360 360,510 510,690 690,870 870,1170
routed through that {TLB -},|
|

2805
01:25:52,290 --> 01:25:53,400
0,330 330,510 510,630 630,900 900,1110
because if you miss it,|
因为如果你错过了，|

2806
01:25:53,400 --> 01:25:54,210
0,210 210,420 420,540 540,660 660,810
that {TLB -} you have
TLB 你必须去内存检索。

2807
01:25:54,210 --> 01:25:55,890
0,90 90,210 210,330 330,750 1140,1680
to go to memory retrieve.|
|

2808
01:25:55,890 --> 01:25:57,450
0,210 210,510 630,870 870,1200 1200,1560
That right, so they're certainly
对，所以它们肯定是 L2 缓存可以保存的，

2809
01:25:57,450 --> 01:25:59,640
0,120 120,630 630,1290 1440,1590 1590,2190
the L2 cache will hold,|
|

2810
01:25:59,640 --> 01:26:00,580
0,480

2811
01:26:00,790 --> 01:26:01,750
0,330 390,630 630,690 690,900 900,960
{} from the point of
从 L2 缓存的角度来看，

2812
01:26:01,750 --> 01:26:03,580
0,120 120,210 210,540 540,1020 1440,1830
view the L2 cache,| TLB
|TLB 未命中、 TLB 重新加载只是内存访问，

2813
01:26:03,580 --> 01:26:05,560
0,540 540,930 930,1350 1350,1440 1440,1980
misses, TLB reloads are just

2814
01:26:06,140 --> 01:26:07,670
0,450 450,930 930,1080 1080,1200 1200,1530
memory accesses,| so that TLB
|所以 TLB 需要加载一堆页表垃圾文件，

2815
01:26:07,670 --> 01:26:08,630
0,360 360,540 540,750 750,780 780,960
needs to load a bunch

2816
01:26:08,630 --> 01:26:10,160
0,60 60,300 300,540 540,930 1230,1530
of page table junk,| it's
|这只是一个内存加载，

2817
01:26:10,160 --> 01:26:11,510
0,180 180,240 240,600 600,1080 1080,1350
just a memory load,| and
|可以很容易地将内容缓存到 L2 中。

2818
01:26:11,630 --> 01:26:12,650
0,150 150,270 270,630 630,870 870,1020
it could use, stuff could

2819
01:26:12,650 --> 01:26:13,640
0,330 330,450 450,840 840,900 900,990
easily be cached in the

2820
01:26:13,640 --> 01:26:14,480
0,330 330,450 450,540 540,750 750,840
L2.| But it has to
|但它必须跳到 L1 ，

2821
01:26:14,480 --> 01:26:15,980
0,420 420,660 660,1110 1110,1290 1290,1500
{skip,to,L1 -},| because {L1 -}
|因为 L1 有虚拟地址，但是。

2822
01:26:15,980 --> 01:26:17,330
0,270 270,660 660,1080 1080,1200 1200,1350
has virtual addresses, but.| I
|我不认为 TLB 会查询 L1 。

2823
01:26:17,330 --> 01:26:19,610
0,390 420,810 810,1440 1560,1860 1860,2280
don't {} think that TLB

2824
01:26:19,610 --> 01:26:20,750
0,150 150,510 510,630 630,780 780,1140
would consult the {L1 -}

2825
01:26:20,810 --> 01:26:22,220
0,210 210,390 390,750
for its.| Okay.|
|好的。|

2826
01:26:22,510 --> 01:26:24,700
0,360 360,660 690,1380 1380,1740 1740,2190
Because it's virtual {addresses -}.|
因为它是虚拟地址。|

2827
01:26:25,980 --> 01:26:27,300
0,180 180,390 390,930 930,1050 1050,1320
And then one thing about
然后是一件关于 spectre 攻击的事。

2828
01:26:27,300 --> 01:26:29,700
0,90 90,600 600,1110 1140,1770
the spectre attack {}.|
|

2829
01:26:30,110 --> 01:26:32,090
0,480 480,720 720,930 930,1500 1770,1980
{} How would you, {}
你怎么会，

2830
01:26:32,090 --> 01:26:33,290
0,420 450,780 780,930 930,1050 1050,1200
I,| so so the thing
|我至少听说过十几次 meltdown 检查，

2831
01:26:33,290 --> 01:26:34,310
0,120 120,300 300,480 480,660 660,1020
is like I've heard about

2832
01:26:34,310 --> 01:26:36,320
0,420 420,960 960,1290 1440,1770 1770,2010
meltdown inspector like at least

2833
01:26:36,320 --> 01:26:37,580
0,30 30,390 390,870 870,1080 1080,1260
a dozen times,| and every
|每次我看的时候都不明白，

2834
01:26:37,580 --> 01:26:38,450
0,240 240,300 300,570 570,690 690,870
time I looked it up

2835
01:26:38,450 --> 01:26:39,710
0,90 90,330 330,540 540,1110 1110,1260
I would not understand it,|
|

2836
01:26:39,710 --> 01:26:40,490
0,120 120,270 270,390 390,540 540,780
so this is the first
所以这是我第一次真正明白发生了什么，

2837
01:26:40,490 --> 01:26:41,600
0,150 150,210 210,450 450,900 900,1110
time I actually understand what's

2838
01:26:41,600 --> 01:26:43,310
0,240 240,630 810,1260 1260,1590 1590,1710
going on,| {} but for
|但是对于 spectre ，

2839
01:26:43,310 --> 01:26:45,600
0,720 840,1080 1080,1290 1290,1830
spectre,| is there, {}
|它与 meltdown 有多么相似？

2840
01:26:45,600 --> 01:26:47,250
0,150 150,600 630,1200 1200,1380 1380,1650
like how similar is it

2841
01:26:47,250 --> 01:26:49,410
0,90 90,720 720,870 870,1350 1590,2160
to meltdown?| It's not.| It's
|不是。|不是，好的。

2842
01:26:49,410 --> 01:26:53,550
0,420 450,1020 2820,3240 3870,4050 4050,4140
not, okay.| Or, that they
|或者，他们会，

2843
01:26:53,550 --> 01:26:54,480
0,420
will,|
|

2844
01:26:55,560 --> 01:26:56,970
0,240 240,540 540,990 990,1080 1080,1410
{} my understanding the spectre
我对 spectre 攻击的理解是，通过训练分支预测器，

2845
01:26:56,970 --> 01:26:58,590
0,330 330,450 450,600 600,1350 1350,1620
attack is by training the

2846
01:26:58,590 --> 01:27:01,260
0,390 390,1110 1140,1350 1890,2430 2430,2670
branch predictor,| that you know
|另一个你想要攻击的代码。

2847
01:27:02,250 --> 01:27:03,810
0,390 390,630 630,1110 1110,1200 1200,1560
the other code that you're

2848
01:27:04,050 --> 01:27:05,190
0,570 570,660 660,780 780,840 840,1140
trying to get {attack -}

2849
01:27:05,190 --> 01:27:06,750
0,240 240,690 720,990 990,1350 1350,1560
stuff from.| Let's suppose it's
|让我们假设另一个进程，你和它共享一些内存。

2850
01:27:06,750 --> 01:27:09,090
0,660 1020,1410 1410,1800 1800,2010 2010,2340
{} another process you share

2851
01:27:09,090 --> 01:27:10,700
0,180 180,600 600,750 750,1170
some memory with it,

2852
01:27:10,820 --> 01:27:12,590
0,240 240,390 390,570 570,900 1320,1770
right.| Yeah, because you're it's
|因为它和你运行一样的程序，

2853
01:27:12,590 --> 01:27:13,850
0,270 270,450 450,750 750,1140 1140,1260
really the same program as

2854
01:27:13,850 --> 01:27:15,200
0,330 330,510 510,720 720,1050 1050,1350
you,| but it's some other
|但运行该程序的是其他用户。

2855
01:27:15,200 --> 01:27:17,090
0,600 870,1110 1110,1200 1200,1590 1590,1890
user running the program, right.|
|

2856
01:27:18,040 --> 01:27:20,300
0,600 660,1080 1080,1620
{} You can,
分支预测器使用的表共享在不同的，

2857
01:27:20,600 --> 01:27:22,820
0,360 360,840 840,1020 1020,1620 1740,2220
the branch, the branch, the

2858
01:27:22,850 --> 01:27:25,070
0,540 540,690 690,960 960,1440 1440,2220
tables the branch predictor uses

2859
01:27:25,100 --> 01:27:26,780
0,270 270,1170
are shared

2860
01:27:27,090 --> 01:27:29,200
0,420 450,1500
{} between

2861
01:27:29,290 --> 01:27:30,640
0,630 630,900 900,900 900,1230 1230,1350
different,| if I run a
|如果我运行 CPU ，

2862
01:27:30,640 --> 01:27:31,930
0,360 360,780 780,870 870,1020 1020,1290
CPU [],| that you run
|可能在同一 CPU 的不同超线程上运行，

2863
01:27:31,930 --> 01:27:32,980
0,60 60,330 330,690 690,810 810,1050
or maybe run on different

2864
01:27:32,980 --> 01:27:33,970
0,330 330,630 630,690 690,780 780,990
hyper threads of the same

2865
01:27:33,970 --> 01:27:35,230
0,420 420,750 750,990 990,1050 1050,1260
CPU,| everybody sees the same
|每个人都看到相同的分支预测器，

2866
01:27:35,230 --> 01:27:37,240
0,360 750,1050 1050,1110 1110,1440
branch sees the same

2867
01:27:37,240 --> 01:27:38,470
0,300 300,750 780,1020 1020,1110 1110,1230
branch predictor,| so I can
|所以我可以训练分支预测器以某种方式预测分支，

2868
01:27:38,470 --> 01:27:39,700
0,330 330,420 420,690 690,1110 1110,1230
train the branch predictor to

2869
01:27:39,700 --> 01:27:40,960
0,390 390,810 810,900 900,930 930,1260
predict branches in a certain

2870
01:27:40,960 --> 01:27:42,250
0,390 630,870 870,990 990,1140 1140,1290
way,| and then I'll let
|然后我会让你运行，

2871
01:27:42,250 --> 01:27:43,560
0,180 180,720
you run,|
|

2872
01:27:44,230 --> 01:27:46,030
0,360 360,720 720,930 960,1440 1470,1800
you're running with my branch
你在运行我训练的分支预测器。

2873
01:27:46,030 --> 01:27:48,250
0,420 420,900 1380,1860 1860,2010 2010,2220
predictor training, right,| and so
|这意味着我可以欺骗你的程序，

2874
01:27:48,280 --> 01:27:49,450
0,300 300,480 480,570 570,720 720,1170
that means I can essentially

2875
01:27:49,450 --> 01:27:51,340
0,330 330,600 600,1020 1020,1200 1200,1890
trick your program| into {speculatively
|让它预测执行我选择的指令。

2876
01:27:51,340 --> 01:27:53,020
0,120 120,780 780,1290 1290,1380 1380,1680
-} executing instructions of my

2877
01:27:53,020 --> 01:27:54,380
0,960
choice.|
|

2878
01:27:54,790 --> 01:27:55,840
0,180 180,240 240,330 330,480 480,1050
Right, now it's only speculative,|
对，现在只是推测，|

2879
01:27:55,840 --> 01:27:56,410
0,120 120,210 210,360 360,450 450,570
so of course they'll be
所以它们当然会被撤销，

2880
01:27:56,410 --> 01:27:58,510
0,420 420,960 1200,1590 1590,1860 1860,2100
undone,| but they they will
|但是它们会导致缓存加载，

2881
01:27:58,510 --> 01:28:00,880
0,480 480,1050 1050,1860
cause cache loads,|
|

2882
01:28:00,880 --> 01:28:02,620
0,630 870,1230 1230,1320 1320,1500 1500,1740
{} that to some extent
在某种程度上我可以控制。

2883
01:28:02,620 --> 01:28:04,180
0,90 90,240 240,960
I can control.|
|

2884
01:28:04,180 --> 01:28:05,110
0,150 150,330 420,750 750,840 840,930
Because I control how you
因为我控制着预测执行，

2885
01:28:05,110 --> 01:28:06,340
0,450 450,810 810,900 900,1110 1110,1230
speculatively execute,| and then if
|如果我们共享内存，

2886
01:28:06,340 --> 01:28:07,270
0,90 90,360 360,660 660,750 750,930
we share memory,| I can
|我可以使用刷新并重新加载来检测

2887
01:28:07,270 --> 01:28:08,590
0,390 390,660 660,750 750,1230 1230,1320
use flush and reload to

2888
01:28:08,590 --> 01:28:09,840
0,750
sense|
|

2889
01:28:09,930 --> 01:28:11,580
0,300 300,690 690,990 990,1290 1290,1650
what cache lines your program
你的程序加载了预测执行的哪个缓存行。

2890
01:28:11,580 --> 01:28:14,480
0,540 540,1080 1110,1620 1620,2310
loaded this speculative execution.|
|

2891
01:28:15,390 --> 01:28:16,890
0,510 540,720 720,810 810,1020 1020,1500
Oh, so in that case,|
哦，那样的话，|

2892
01:28:16,890 --> 01:28:18,630
0,570 570,720 720,960 960,1230 1230,1740
you don't need to {},
你不需要，

2893
01:28:19,380 --> 01:28:20,430
0,330 330,450 450,630 630,750 750,1050
you don't need to,| like
|比如直接寻址一块内存，

2894
01:28:20,430 --> 01:28:22,830
0,300 300,630 630,1230 1230,1950 1980,2400
know like directly address address

2895
01:28:22,830 --> 01:28:24,930
0,930 930,1320 1320,1530 1530,1920 1920,2100
a piece of memory,| you
|你只需要确保程序被预测执行，

2896
01:28:24,930 --> 01:28:25,860
0,210 210,390 390,480 480,750 750,930
just need to make sure

2897
01:28:25,860 --> 01:28:28,590
0,300 570,1170 1170,1320 1320,2040 2040,2730
that program will specularly executed,|
|

2898
01:28:28,740 --> 01:28:30,030
0,240 240,360 360,900 900,1080 1080,1290
like in meltdown, we did
而在 meltdown 中，我们自己做的，

2899
01:28:30,030 --> 01:28:32,190
0,240 240,990 990,1170 1170,1740 1740,2160
it ourselves,| but {in,spectre} just
|但在 spectre 中，直接到那里，

2900
01:28:32,640 --> 01:28:34,980
0,1200 1200,1560 1950,2130 2130,2280 2280,2340
directed there,| that's kind of
|这有点酷，

2901
01:28:34,980 --> 01:28:35,910
0,360 390,570 570,660 660,780 780,930
cool,| because you can just
|因为你可以，

2902
01:28:35,910 --> 01:28:36,960
0,180 180,480 480,600 600,810 810,1050
say,| oh you know just
|只要通过训练分支预测器来加载这个秘密，

2903
01:28:36,960 --> 01:28:38,220
0,150 150,270 270,480 480,690 690,1260
go and load that secret

2904
01:28:38,610 --> 01:28:40,080
0,240 240,660 660,750 750,1050 1050,1470
by training the branch predictor,|
|

2905
01:28:40,080 --> 01:28:41,280
0,330 330,630 630,750 750,840 840,1200
without knowing where the secret
而不需要知道秘密在哪里，

2906
01:28:41,280 --> 01:28:43,230
0,330 1020,1380 1380,1470 1470,1680 1680,1950
is,| like you gotta know
|你知道某些，

2907
01:28:43,230 --> 01:28:44,880
0,420 510,900 900,1350 1350,1590 1590,1650
someone,| yeah you kind of
|你一定要知道。

2908
01:28:44,880 --> 01:28:46,080
0,180 180,300 300,630 630,900 900,1200
have to know.| You {need,to}
|你需要知道非常详细的情况。

2909
01:28:46,080 --> 01:28:47,160
0,90 90,330 330,630 630,780 780,1080
know great [] and {great,detail}.|
|

2910
01:28:47,160 --> 01:28:49,860
0,1620 1620,1710 1710,2010 2190,2580 2580,2700
{Yeah,sorry}, {you,have,to} know.| But you
是的，抱歉，你得知道。|但是你必须自己。

2911
01:28:49,860 --> 01:28:51,570
0,180 180,690 690,1170 1200,1530 1530,1710
have to yourself.| Yes.| That's
|是的。|这不是秘密，

2912
01:28:51,570 --> 01:28:52,800
0,120 120,630 630,780 780,1020 1020,1230
not secret,| you're probably running
|你可能在运行一个程序，

2913
01:28:52,800 --> 01:28:54,000
0,60 60,540 540,780
a program that,|
|

2914
01:28:54,000 --> 01:28:54,870
0,150 150,270 270,420 420,750 750,870
I know what program you're
我知道你在运行什么程序。

2915
01:28:54,870 --> 01:28:57,080
0,270 270,1230
running.| Yeah,
|好的，理解了，谢谢。

2916
01:28:57,820 --> 01:28:59,110
0,420 450,540 540,720 720,1050 1050,1290
okay, that makes sense, thank

2917
01:28:59,110 --> 01:28:59,980
0,270
you.|
|

2918
01:29:01,700 --> 01:29:02,990
0,240 240,390 390,600 600,810 810,1290
Yeah, I was just wondering,|
是的，我只是在想，|

2919
01:29:02,990 --> 01:29:04,370
0,120 120,450 450,810 810,1230 1230,1380
it seems like when you
当像这样的一篇研究论文发表的时候，

2920
01:29:04,370 --> 01:29:06,050
0,240 240,600 780,1230 1230,1530 1530,1680
when a research paper, like

2921
01:29:06,050 --> 01:29:07,280
0,240 240,450 450,780 780,1080 1080,1230
this gets released,| it's out
|给到人们，

2922
01:29:07,280 --> 01:29:09,860
0,210 210,690 690,1110 1410,1920 1920,2580
there for like people,| Linux
|Linux 和 Windows 以及 Intel 的人

2923
01:29:09,860 --> 01:29:11,570
0,90 90,630 630,810 810,1080 1080,1710
and Windows and like Intel

2924
01:29:11,810 --> 01:29:12,680
0,210 210,390 390,510 510,690 690,870
for them| to try to
|都在争先恐后地修补这个漏洞，

2925
01:29:12,680 --> 01:29:14,450
0,240 240,600 930,1410 1410,1500 1500,1770
go and scramble to patch

2926
01:29:14,450 --> 01:29:15,260
0,120 120,300 300,450 450,540 540,810
the bug,| but it's also
|但是黑客也可以从这篇论文中学到东西，

2927
01:29:15,260 --> 01:29:16,670
0,150 150,360 360,630 630,1080 1080,1410
out there for hackers can

2928
01:29:16,670 --> 01:29:17,600
0,270 270,360 360,720 720,840 840,930
start to learn from the

2929
01:29:17,600 --> 01:29:18,500
0,300 300,540 540,540 540,840 840,900
paper,| like oh this is
|哦，这是一种我们可以使用的方法，

2930
01:29:18,500 --> 01:29:19,640
0,90 90,390 390,480 480,690 690,1140
a method we could use,|
|

2931
01:29:20,190 --> 01:29:22,740
0,660 840,1350 1500,1950 1950,2100 2100,2550
{} and I'm I'm wondering,|
我在想，|

2932
01:29:22,740 --> 01:29:24,240
0,270 270,690 720,990 990,1050 1050,1500
like it as a researcher
作为一名研究人员，有没有一种普遍的做法，

2933
01:29:24,240 --> 01:29:25,470
0,90 90,300 300,420 420,750 750,1230
is there a general practice|
|

2934
01:29:25,470 --> 01:29:26,970
0,240 240,450 450,750 750,1050 1050,1500
of like as we're working
我们正在写的论文

2935
01:29:26,970 --> 01:29:28,020
0,120 120,210 210,540 540,840 840,1050
on the paper| will sort
|会先给好人，

2936
01:29:28,020 --> 01:29:30,360
0,120 120,780 780,1230 1710,2040 2040,2340
of tipoff the quote unquote

2937
01:29:30,360 --> 01:29:31,410
0,180 180,540 540,810 810,900 900,1050
good guys first,| so that
|这样他们就可以。

2938
01:29:31,410 --> 01:29:32,880
0,90 90,480 480,630 630,1140 1140,1470
they can have.| Yeah, authors
|是的，作者先通知每一个 CPU 制造商和操作系统制造商。

2939
01:29:32,880 --> 01:29:35,190
0,810 810,1680 1680,1830 1830,1950 1950,2310
informed every you know the

2940
01:29:35,370 --> 01:29:37,380
0,360 360,990 990,1080 1080,1350 1350,2010
CPU manufacturers and OS manufacturers|
|

2941
01:29:37,380 --> 01:29:38,550
0,270 270,360 360,690 690,750 750,1170
before they publish the paper.|
在发表论文之前。|

2942
01:29:39,030 --> 01:29:39,960
0,360 360,390 390,720 750,900 900,930
There's a whole, there's a
有一个完整的协议，

2943
01:29:39,960 --> 01:29:42,780
0,150 150,870 1500,2490 2490,2670 2670,2820
whole protocol,| {you,know} these kind
|这类事情会被接受，

2944
01:29:42,780 --> 01:29:43,680
0,60 60,240 240,420 420,750 750,900
of things would even be

2945
01:29:43,680 --> 01:29:45,450
0,420 420,840 840,1230 1230,1500 1500,1770
accepted anymore,| unless you follow
|除非你遵守协议。

2946
01:29:45,450 --> 01:29:47,130
0,60 60,570 1200,1350 1350,1530 1530,1680
the protocol.| That doesn't mean
|这并不意味着袭击者没有使用它，

2947
01:29:47,130 --> 01:29:48,270
0,60 60,450 450,630 630,840 840,1140
the attackers weren't already using

2948
01:29:48,270 --> 01:29:49,830
0,90 120,390 390,870 900,960 1260,1560
it, right,| because you probably
|因为可能攻击者在 20 年前发现了这个，但是。

2949
01:29:49,830 --> 01:29:51,270
0,90 90,210 210,660 660,1050 1050,1440
know the attackers discovered this

2950
01:29:51,300 --> 01:29:52,920
0,240 240,450 450,780 930,1350
twenty years ago, but.|
|

2951
01:29:53,070 --> 01:29:57,000
0,540 2160,3120 3120,3360
Great, thank you.|
好的，谢谢。|

2952
01:29:57,480 --> 01:29:59,850
0,510 960,1800 1890,1920 1950,2280 2280,2370
{It's,not} straightforward,| I think in
这不是直截了当的，|我认为在这个特殊的情况下，

2953
01:29:59,850 --> 01:30:01,170
0,300 300,660 660,960 960,960 960,1320
this particular case,| I think
|我想 Intel 不太感兴趣，

2954
01:30:01,170 --> 01:30:02,400
0,60 60,330 330,540 540,840 840,1230
you know what some {}

2955
01:30:02,490 --> 01:30:03,900
0,420 420,600 600,810 810,960 960,1410
Intel was not too excited

2956
01:30:03,900 --> 01:30:04,840
0,390
about,|
|

2957
01:30:05,020 --> 01:30:06,130
0,90 90,570 570,750 750,840 840,1110
the collaboration between the Linux
Linux 社区和 Intel 之间的合作并不完全顺利。

2958
01:30:06,130 --> 01:30:07,270
0,420 420,540 540,840 840,990 990,1140
community and Intel was not

2959
01:30:07,270 --> 01:30:09,440
0,390 390,810 840,900 900,1260
completely smooth, I think.|
|

2960
01:30:10,940 --> 01:30:12,950
0,330 330,450 450,930 1590,1830 1830,2010
When this happened,| I think
当这种情况发生时，|我认为他们在做一些工作，但是。

2961
01:30:12,950 --> 01:30:13,670
0,60 60,390 390,480 480,630 630,720
they worked at some of

2962
01:30:13,670 --> 01:30:15,240
0,90 90,600 600,1020
the case, but.|
|

2963
01:30:18,670 --> 01:30:19,510
0,150 150,420 420,510 510,660 660,840
I think it was kind
我觉得有点吓人，

2964
01:30:19,510 --> 01:30:21,130
0,90 90,480 480,1020 1020,1380 1440,1620
of scary,| because I I
|因为我在维基百科上看到，

2965
01:30:21,130 --> 01:30:23,890
0,480 540,870 870,1470 1470,1770 2100,2760
read on Wikipedia,| that the
|Ubuntu 补丁是在论文发表后发布的，

2966
01:30:24,070 --> 01:30:27,100
0,840 870,1230 1230,1500 1500,2280 2310,3030
Ubuntu fix was published after

2967
01:30:27,100 --> 01:30:29,350
0,300 360,720 720,900 900,1470 1500,2250
the paper was published,| which
|我觉得很可怕，但是。

2968
01:30:29,530 --> 01:30:31,520
0,150 150,390 390,990 1170,1500
I found scary, but.|
|

2969
01:30:38,120 --> 01:30:40,490
0,360 360,450 450,630 630,1020 1740,2370
Thank you so much {}.|
非常感谢。|

2970
01:30:42,240 --> 01:30:44,340
0,270 270,720 930,1590 1590,1740 1740,2100
Thank you.| Thank you, well
谢谢。|谢谢，我们下周见。

2971
01:30:44,490 --> 01:30:46,800
0,450 450,510 510,720 720,1170
see you next week.
