1
00:00:00,030 --> 00:00:01,020
0,150 150,390 390,810 810,930 930,990
The lab compares to {}
这个实验对比锁实验。

2
00:00:01,020 --> 00:00:02,620
0,300 300,660 660,1020
the locking lab.|
|

3
00:00:07,180 --> 00:00:07,720
0,90 90,180 180,210 210,360 360,540
It was a bit more
它更直截一点。

4
00:00:07,720 --> 00:00:09,020
0,720
straightforward.|
|

5
00:00:09,230 --> 00:00:11,090
0,600 690,1050 1050,1140 1140,1290 1290,1860
Good, {} are you completely,|
好的，你完成了吗，|

6
00:00:11,090 --> 00:00:12,650
0,180 180,390 390,720 720,1230 1230,1560
have you finished the lab,
你完成实验了吗，还是。

7
00:00:12,650 --> 00:00:13,880
0,210 210,300 300,600
or you are.|
|

8
00:00:15,320 --> 00:00:17,270
0,600 750,990 990,1230 1230,1650 1650,1950
I just started yesterday and
我昨天刚开始，一半了，所以。

9
00:00:17,270 --> 00:00:19,460
0,150 150,630 630,960 1080,1950 1950,2190
a halfway, so.| Okay, good,
|好的，我想这对刚开始的人来说是个好消息，

10
00:00:19,460 --> 00:00:20,180
0,90 90,240 240,420 420,570 570,720
I guess that's good news

11
00:00:20,180 --> 00:00:21,230
0,180 180,480 480,570 570,600 600,1050
for people who are starting,|
|

12
00:00:21,620 --> 00:00:23,600
0,690 690,960 960,1020 1020,1380
anybody finished it yet?|
有人完成了吗？|

13
00:00:24,960 --> 00:00:26,640
0,180 180,660 900,1020 1020,1530 1530,1680
I have, I finished it.|
我完成了。|

14
00:00:27,250 --> 00:00:29,470
0,330 330,810 840,1230 1260,1650 1650,2220
And any any nasty surprises
有令人不快的意外或者得到很好的解决？

15
00:00:29,470 --> 00:00:30,880
0,330 330,600 600,720 720,1050 1050,1410
or worked out reasonably well?|
|

16
00:00:31,390 --> 00:00:33,070
0,540 930,1230 1230,1290 1290,1560 1560,1680
I think it worked out
我想它成功了，是的。

17
00:00:33,070 --> 00:00:34,220
0,540
okay,

18
00:00:34,220 --> 00:00:36,000
0,1260
yeah.|
|

19
00:00:37,870 --> 00:00:38,860
0,210 210,540 540,660 660,750 750,990
Much easier than the lock
比锁实验容易多了？

20
00:00:38,860 --> 00:00:39,860
0,450
lab?|
|

21
00:00:40,200 --> 00:00:41,220
0,150 150,360 360,540 540,660 660,1020
I think so, at least.|
至少我是这么认为的。|

22
00:00:42,120 --> 00:00:43,560
0,330 360,990 990,1110 1110,1260 1260,1440
Well, hopefully will be the
好的，希望其他人也是如此。

23
00:00:43,560 --> 00:00:44,760
0,210 210,300 300,600 600,840 840,1200
case for everybody else too.|
|

24
00:00:45,510 --> 00:00:49,080
0,660 690,2430 2550,3120 3120,3270 3270,3570
Yeah {} yeah, let me
好的，让我开始吧，

25
00:00:49,080 --> 00:00:51,330
0,150 150,630 930,1080 1080,1800 1800,2250
get started| and { -}
|我今天要讨论的话题是用户应用程序的虚拟内存，

26
00:00:51,450 --> 00:00:53,040
0,150 150,540 540,570 570,720 720,1590
the topic I want to

27
00:00:53,070 --> 00:00:54,630
0,240 240,450 450,930 930,1200 1200,1560
talk about today is {}

28
00:00:54,660 --> 00:00:56,490
0,420 420,750 750,900 900,1140 1140,1830
virtual memory for user applications,|
|

29
00:00:56,490 --> 00:00:57,980
0,60 60,300 300,690 690,960
you know on {}
在 1991 年这篇由 Appel 和 Li 编写的论文的指导下。

30
00:00:59,530 --> 00:01:01,270
0,270 300,510 510,690 960,1620 1620,1740
{} sort of guided by

31
00:01:01,270 --> 00:01:04,390
0,180 180,1260 1290,1620 1620,2580 2640,3120
this paper from 1991, by

32
00:01:04,390 --> 00:01:06,080
0,600 630,1170
{Appel,and} Li.|
|

33
00:01:06,490 --> 00:01:08,410
0,450 720,1140 1140,1260 1260,1590 1590,1920
{} So the starting point
所以我们的出发点是，

34
00:01:08,410 --> 00:01:10,270
0,720 720,930 930,1230 1230,1680 1680,1860
basically is that,| {} as
|如你们所知，

35
00:01:10,270 --> 00:01:11,830
0,120 120,330 330,810 810,1140 1320,1560
you well know,| that the
|操作系统内核以创造性的方式使用虚拟内存页表。

36
00:01:11,830 --> 00:01:13,500
0,630 630,840 840,1140
OS {kernel -}

37
00:01:15,610 --> 00:01:18,520
0,840 960,1500 1500,1830 1830,2100 2100,2910
use virtual memory page tables

38
00:01:19,100 --> 00:01:21,600
0,630 630,1020 1020,1350 1350,1800
{} in creative ways.|
|

39
00:01:25,340 --> 00:01:26,680
0,540 540,600

40
00:01:26,680 --> 00:01:27,430
0,180 180,360 360,540 540,660 660,750
You've seen that we have
你已经看到我们有一个懒分配实验，写时复制实验，

41
00:01:27,430 --> 00:01:30,340
0,540 540,810 810,1320 1320,1860 2160,2910
a lazy allocation lab, copy-on-write

42
00:01:30,340 --> 00:01:33,430
0,1470 1500,2040 2040,2400 2610,2970 2970,3090
{} lab,| as well as
|以及许多其他类型的特性，

43
00:01:33,430 --> 00:01:34,660
0,390 390,570 570,750 750,810 810,1230
many other sort of features,|
|

44
00:01:34,660 --> 00:01:37,000
0,270 270,390 390,780 780,1380 1710,2340
that you know {} implementation
在 xv6 中实现的各个方面，

45
00:01:37,000 --> 00:01:39,040
0,240 240,540 1440,1890 1890,1980 1980,2040
to or aspects of the

46
00:01:39,040 --> 00:01:40,750
0,540 540,660 660,840 840,1440 1440,1710
implementation in the xv6, so.|
|

47
00:01:41,230 --> 00:01:42,080
0,390

48
00:01:42,140 --> 00:01:43,250
0,180 180,570 570,660 660,1020 1020,1110
And basically the argument that
这篇论文的论点，

49
00:01:43,250 --> 00:01:46,200
0,120 120,420 420,870 1290,2100
the paper makes, {}

50
00:01:46,290 --> 00:01:48,120
0,60 90,510 510,1200
the paper argues,|
|

51
00:01:48,950 --> 00:01:50,270
0,420 420,600 600,720 720,1050 1050,1320
{} you know the user
用户应用程序应该受益于

52
00:01:50,270 --> 00:01:52,130
0,540 540,750 750,1290 1290,1650 1650,1860
application should actually benefit to|
|

53
00:01:52,130 --> 00:01:52,970
0,180 180,360 360,510 510,600 600,840
or should have the same
或应该具有相同的能力，

54
00:01:52,970 --> 00:01:54,640
0,570 600,720 720,1080
powers,| you know,
|用户应用程序也可以使用虚拟内存。

55
00:01:54,640 --> 00:01:57,460
0,480 480,1260 1620,2190
{} user apps

56
00:01:58,580 --> 00:02:00,320
0,180 180,480 480,660 660,1050
{} can {use -}

57
00:02:00,970 --> 00:02:02,660
0,600 600,930
VM too.|
|

58
00:02:03,320 --> 00:02:04,730
0,450 450,540 540,1140 1140,1320 1320,1410
{A,little,bit}, I mean when I
我的意思是，

59
00:02:04,730 --> 00:02:06,560
0,270 270,960 1050,1380 1380,1620 1620,1830
mean again,| of course, your
|当然，你的应用程序使用虚拟内存，

60
00:02:06,560 --> 00:02:08,060
0,480 480,750 750,900 900,1230 1230,1500
application running with virtual memory,|
|

61
00:02:08,060 --> 00:02:09,290
0,150 150,270 270,630 630,930 930,1230
but I really mean with
但我对 VM 真正的意思是，

62
00:02:09,320 --> 00:02:11,060
0,300 300,660 660,810 810,1050 1380,1740
{} VM is that| they
|它们希望有与内核相同的机制，

63
00:02:11,060 --> 00:02:11,840
0,210 210,390 390,480 480,690 690,780
would like to have the

64
00:02:11,840 --> 00:02:14,240
0,390 390,1050 1050,1470 1620,1980 1980,2400
same mechanisms that kernel has|
|

65
00:02:14,240 --> 00:02:16,370
0,120 120,330 330,900 1080,1530 1530,2130
to its access user application
在用户模式访问用户应用程序，

66
00:02:16,370 --> 00:02:17,660
0,300 300,570 570,870 870,1200 1200,1290
{where,in} user mode,| application will
|应用程序能够接受页面错误，

67
00:02:17,660 --> 00:02:19,100
0,180 180,420 420,780 930,1230 1230,1440
be able to take page

68
00:02:19,100 --> 00:02:20,840
0,390 390,660 660,1020 1020,1320 1320,1740
faults,| and then {you,know} respond
|然后可以响应这些页面错误，

69
00:02:20,840 --> 00:02:21,800
0,60 60,270 270,480 480,870 870,960
to those page faults,| you
|可以修改保护位，

70
00:02:21,800 --> 00:02:23,000
0,120 120,270 270,480 480,720 720,1200
know be able to change

71
00:02:23,000 --> 00:02:24,520
0,240 270,690 690,1170
the protection bits,|
|

72
00:02:24,610 --> 00:02:26,020
0,360 360,570 570,720 720,1170 1170,1410
or {} the privilege level
或修改页表中的特权级别。

73
00:02:26,020 --> 00:02:27,850
0,180 180,720 720,1260 1290,1710 1710,1830
to levels in {} the

74
00:02:27,850 --> 00:02:28,980
0,240 240,540
page table.|
|

75
00:02:30,420 --> 00:02:32,880
0,510 510,690 690,1080 1110,1740 1740,2460
{} And so, {} in
所以，在这篇论文中讨论这种情况，

76
00:02:32,910 --> 00:02:34,380
0,90 90,390 390,720 720,870 870,1470
the paper argues this case|
|

77
00:02:34,650 --> 00:02:35,940
0,630 630,930 930,1050 1050,1080 1080,1290
by looking at a bunch
通过观察一系列不同的应用程序，

78
00:02:35,940 --> 00:02:38,560
0,60 60,330 330,1080
of different applications,|
|

79
00:02:38,650 --> 00:02:39,850
0,120 120,540 570,930 930,1140 1140,1200
{ -} like six or
比如六、七种不同类型的应用程序，

80
00:02:39,850 --> 00:02:41,170
0,240 240,510 510,660 660,720 720,1320
seven different types of applications|
|

81
00:02:41,170 --> 00:02:41,920
0,90 90,270 270,360 360,510 510,750
and maybe I will ask
也许我会问你，什么是你最喜欢的应用程序，

82
00:02:41,920 --> 00:02:43,030
0,180 180,390 390,720 720,840 840,1110
you like what was your

83
00:02:43,120 --> 00:02:44,880
0,480 480,1140
favorite application,|
|

84
00:02:44,880 --> 00:02:46,380
0,660 660,930
you {}
你在论文中遇到的。

85
00:02:47,020 --> 00:02:48,600
0,480 480,570 570,630 630,1050
encountered in the paper.|
|

86
00:02:50,770 --> 00:02:52,720
0,450 450,840 870,1260 1260,1620 1740,1950
Anybody wanna [chime] in and
有没有人想说一下？

87
00:02:52,720 --> 00:02:53,900
0,240 240,600
talk the?|
|

88
00:02:56,880 --> 00:02:57,940
0,540

89
00:03:00,260 --> 00:03:03,140
0,720 720,1080 1110,1830 2190,2460 2460,2880
They can allow the user
它们可以允许用户应用程序决定，

90
00:03:03,140 --> 00:03:04,970
0,600 600,1080 1110,1620 1620,1740 1740,1830
application to decide that| a
|一个页面可以，

91
00:03:04,970 --> 00:03:07,670
0,660 1440,1650 1650,2010 2010,2190 2190,2700
page is going to be,|
|

92
00:03:08,310 --> 00:03:10,140
0,210 210,540 540,780 780,1260 1260,1830
I guess they change the
我猜他们更改了某个特定页面的访问位。

93
00:03:10,320 --> 00:03:12,570
0,570 570,990 990,1410 1440,1710 1710,2250
access bits for some particular

94
00:03:12,570 --> 00:03:13,660
0,630
page.|
|

95
00:03:13,780 --> 00:03:14,650
0,420 420,570 570,720 720,780 780,870
Yeah, that's one of the
是的，这是其中一种机制，

96
00:03:14,650 --> 00:03:16,390
0,540 540,780 780,960 960,1470 1470,1740
mechanisms,| I'm just curious which
|我只是好奇有哪些应用程序，

97
00:03:16,390 --> 00:03:17,620
0,690 690,780 780,870 870,1050 1050,1230
applications,| you know they make
|你知道，他们用很多不同的应用程序来证明这一点，

98
00:03:17,620 --> 00:03:18,370
0,90 90,330 330,480 480,570 570,750
the case with a bunch

99
00:03:18,370 --> 00:03:19,990
0,60 60,270 270,870 900,1560 1560,1620
of different applications,| like the
|比如垃圾收集器或并发垃圾收集器，

100
00:03:19,990 --> 00:03:21,500
0,330 330,870
garbage collector

101
00:03:23,600 --> 00:03:26,000
0,450 480,810 810,1110 1110,1770
or concurrent garbage collector,|
|

102
00:03:26,210 --> 00:03:27,470
0,420 420,690 690,840 840,1080 1080,1260
{} and a couple other
还有其他几个，

103
00:03:27,470 --> 00:03:28,580
0,360 360,450 450,660 660,810 810,1110
ones,| you know just wondering
|只是想知道你觉得哪几个最有趣。

104
00:03:28,580 --> 00:03:29,960
0,510 510,720 720,840 840,1170 1170,1380
which ones you thought were

105
00:03:29,960 --> 00:03:31,300
0,270 270,690
most interesting.|
|

106
00:03:40,160 --> 00:03:41,300
0,240 240,420 420,870 870,960 960,1140
What other applications do they
他们还使用哪些其他应用程序来证明自己的观点。

107
00:03:41,300 --> 00:03:43,790
0,360 360,630 810,2220 2220,2430 2430,2490
use or the used to

108
00:03:43,790 --> 00:03:45,080
0,150 150,240 240,690
make their case.|
|

109
00:03:47,660 --> 00:03:49,280
0,180 180,450 450,720 720,1020 1020,1620
I thought the data compression
我认为数据压缩应用程序非常酷。

110
00:03:49,280 --> 00:03:53,160
0,540 540,660 660,870 870,1170
application was pretty cool.|
|

111
00:03:53,930 --> 00:03:54,650
0,120 120,210 210,450 450,540 540,720
And the other {[] -}
另一种[]是，

112
00:03:54,650 --> 00:03:55,780
0,390
were,|
|

113
00:03:58,500 --> 00:04:00,480
0,360 360,570 570,960 960,1320
people were [] by.|
人们[]。|

114
00:04:04,780 --> 00:04:06,100
0,210 210,480 480,900 960,1230 1230,1320
I thought the sort of
我认为在多个不同系统之间共享虚拟内存非常酷，

115
00:04:06,100 --> 00:04:07,840
0,360 360,660 660,990 990,1380 1380,1740
shared virtual memory between multiple

116
00:04:07,840 --> 00:04:09,010
0,270 270,690 690,810 810,960 960,1170
different systems that was pretty

117
00:04:09,010 --> 00:04:10,150
0,390 390,450 450,750 840,1020 1020,1140
cool,| I didn't, I don't
|我想我没有完全理解它是怎么运作的，

118
00:04:10,150 --> 00:04:11,560
0,120 120,180 180,540 540,990 990,1410
think I fully understood how

119
00:04:11,560 --> 00:04:13,120
0,630 630,1110 1110,1230 1230,1320 1320,1560
it worked,| but the general
|但是使用保护位的总体思路是

120
00:04:13,120 --> 00:04:14,140
0,210 210,300 300,510 510,570 570,1020
idea of using the protection

121
00:04:14,140 --> 00:04:15,010
0,270 270,360 360,540 540,750 750,870
bits| to make sure that
|确保不同机器以正确方式使用共享内存，

122
00:04:15,010 --> 00:04:17,020
0,300 300,960 1170,1470 1470,1650 1650,2010
different machines are are using

123
00:04:17,020 --> 00:04:17,860
0,180 180,390 390,690 690,750 750,840
that shared memory in the

124
00:04:17,860 --> 00:04:19,570
0,240 240,510 510,630 630,1050 1050,1710
right way| and protecting invariance
|保护不变量是有意义的。

125
00:04:19,600 --> 00:04:20,600
0,240 240,600
makes sense.|
|

126
00:04:21,250 --> 00:04:23,260
0,270 270,480 480,1050
So, that's it,|
所以，就是这样，|

127
00:04:23,290 --> 00:04:24,490
0,90 90,330 330,750 750,990 990,1200
you know basically it turns
基本上整个领域发展使用这种方法，

128
00:04:24,490 --> 00:04:26,320
0,150 150,600 600,810 810,1320 1320,1830
out that whole area developed

129
00:04:26,320 --> 00:04:28,210
0,150 150,1050 1110,1170 1170,1350 1350,1890
in {} way that one,|
|

130
00:04:28,270 --> 00:04:31,090
0,540 570,1710 1710,2070 2070,2160 2160,2820
paper originally described the SVM,|
论文最初描述了 SVM （共享虚拟内存），|

131
00:04:32,320 --> 00:04:34,000
0,660 660,690 690,930 930,1260 1260,1680
developing a whole research area,|
发展一个完整的研究领域，|

132
00:04:34,560 --> 00:04:35,820
0,390 390,840 840,930 930,990 990,1260
{} where you know people
人们用各种聪明的技巧

133
00:04:35,820 --> 00:04:37,050
0,390 390,570 570,630 630,900 900,1230
all kinds of clever tricks|
|

134
00:04:37,050 --> 00:04:37,800
0,180 180,360 360,480 480,600 600,750
to try to make that
试着实现这种方案。

135
00:04:37,800 --> 00:04:39,210
0,300 300,660 660,810 810,1260 1260,1410
actually {} that scheme to

136
00:04:39,210 --> 00:04:40,220
0,450
fly.|
|

137
00:04:40,620 --> 00:04:41,860
0,240 240,600
Any others?|
还有其他的吗？|

138
00:04:50,450 --> 00:04:51,320
0,180 180,330 330,480 480,720 720,870
Because they go off and
因为他们会去做一些其他的应用程序，

139
00:04:51,320 --> 00:04:52,220
0,120 120,180 180,390 390,600 600,900
do a couple other paper

140
00:04:52,220 --> 00:04:54,560
0,930 930,1230 1230,1560 1560,1980 1980,2340
applications| and they basically argue
|他们基本上认为，

141
00:04:54,560 --> 00:04:55,430
0,270 270,360 360,570 570,720 720,870
that| you know if you
|如果你观察所有这些完全不同的应用程序，

142
00:04:55,430 --> 00:04:56,390
0,150 150,240 240,360 360,510 510,960
look at all these different

143
00:04:56,510 --> 00:04:58,310
0,360 360,600 600,1200 1200,1470 1500,1800
quite different applications| like shared
|比如共享虚拟内存，数据压缩或垃圾收集器，

144
00:04:58,310 --> 00:04:59,990
0,300 300,780 810,1200 1200,1590 1590,1680
virtual memory data compression or

145
00:04:59,990 --> 00:05:01,130
0,300 300,690 690,750 750,840 840,1140
garbage collector,| you know very
|本质上有很大的不同，

146
00:05:01,130 --> 00:05:02,720
0,240 240,330 330,810 1110,1500 1500,1590
different in nature,| but it
|但事实证明，

147
00:05:02,720 --> 00:05:03,890
0,210 210,480 480,900 900,1110 1110,1170
turns out that,| all of
|它们都依赖于

148
00:05:03,890 --> 00:05:05,240
0,210 210,540 540,960 960,1200 1200,1350
them actually rely on| a
|少量的虚拟内存原语使其真正工作。

149
00:05:05,240 --> 00:05:06,710
0,420 420,750 750,870 870,1200 1200,1470
small number of virtual memory

150
00:05:06,710 --> 00:05:08,150
0,450 450,570 570,1110 1110,1290 1290,1440
primitives to actually make it

151
00:05:08,150 --> 00:05:09,000
0,540
work.|
|

152
00:05:09,300 --> 00:05:10,680
0,240 240,510 720,900 900,1110 1110,1380
And so the first question
所以论文[]的第一个问题是，

153
00:05:10,680 --> 00:05:12,510
0,210 210,330 330,600 600,1650 1650,1830
to the paper {[],is}| like
|比如，需要的原语应该是什么样子，

154
00:05:12,630 --> 00:05:13,800
0,240 240,420 420,720 720,1050 1050,1170
okay what what what should

155
00:05:13,800 --> 00:05:15,540
0,60 60,480 480,660 660,1290 1320,1740
the primitives look,| like the
|比如用户应用程序需要的，

156
00:05:15,570 --> 00:05:18,200
0,330 330,1080
user application

157
00:05:18,200 --> 00:05:19,100
0,420 420,540 540,660 660,840 840,900
needs,| if they want to
|如果它们想要实现其中一个应用程序。

158
00:05:19,100 --> 00:05:20,870
0,390 390,570 570,690 690,960 960,1770
implement one of those applications.|
|

159
00:05:22,260 --> 00:05:23,430
0,180 180,330 330,570 570,930 960,1170
And so let me talk
所以让我稍微讨论一下这个，

160
00:05:23,430 --> 00:05:24,180
0,30 30,210 210,330 330,540 540,750
a little bit about that,|
|

161
00:05:24,180 --> 00:05:25,080
0,330 330,390 390,480 480,720 720,900
first you know what primitives
首先，什么是原语。

162
00:05:25,080 --> 00:05:26,060
0,390
is.|
|

163
00:05:33,080 --> 00:05:36,440
0,420 750,990 990,1080 1080,3120 3330,3360
{} And so they are,|
所以它们是，|

164
00:05:36,770 --> 00:05:37,970
0,90 90,300 300,660 660,900 900,1200
the ones they the obvious
它们是显而易见的，

165
00:05:37,970 --> 00:05:38,840
0,120 120,210 210,540 540,690 690,870
one,| of course you need
|当然你需要一些原语，

166
00:05:38,840 --> 00:05:40,910
0,510 510,1140 1290,1350 1350,1890 1890,2070
something of a primitive,| let's
|让我们看 Trap ，

167
00:05:40,910 --> 00:05:42,050
0,120 120,330 330,420 420,600 600,1140
go what I call Trap,|
|

168
00:05:42,350 --> 00:05:45,230
0,870 870,1020 1020,1710 2400,2520 2520,2880
basically to allow a page
允许内核内部发生的页面错误，

169
00:05:45,230 --> 00:05:46,520
0,510 510,660 660,990 990,1200 1200,1290
fault that happens sort of

170
00:05:46,520 --> 00:05:47,540
0,360 360,450 450,780 780,900 900,1020
inside the kernel| to be
|传播到用户空间。

171
00:05:47,540 --> 00:05:49,190
0,600 600,780 780,870 870,1110 1110,1650
propagated up to user space.|
|

172
00:05:50,120 --> 00:05:51,830
0,570 930,1110 1110,1380 1380,1560 1560,1710
{} And then in user
然后在用户空间中，

173
00:05:51,830 --> 00:05:53,930
0,420 420,510 510,1110 1110,1410 1410,2100
space,| you know the handler
|处理程序可以处理它的页面错误，

174
00:05:53,930 --> 00:05:55,520
0,120 120,330 330,600 600,1200 1230,1590
can then deal with its

175
00:05:55,520 --> 00:05:56,720
0,240 240,690 720,930 930,1110 1110,1200
page fault| and then of
|然后以通常的方式返回内核，

176
00:05:56,720 --> 00:05:57,920
0,210 210,630 630,720 720,840 840,1200
course return in the usual

177
00:05:57,920 --> 00:05:59,390
0,360 540,870 870,960 960,1050 1050,1470
way back to the kernel,|
|

178
00:05:59,390 --> 00:06:00,980
0,90 90,660 660,960 960,1080 1080,1590
and then resume the instruction.|
然后恢复指令。|

179
00:06:01,710 --> 00:06:03,060
0,240 240,630 630,870 870,1230 1230,1350
So clearly the primitive like
所以很明显这样的原语是必要的，

180
00:06:03,060 --> 00:06:04,320
0,180 180,240 240,720 720,900 900,1260
that is necessary,| because otherwise
|否则你无法对页面错误做出任何响应。

181
00:06:04,320 --> 00:06:05,430
0,90 90,300 300,450 450,870 870,1110
you couldn't do anything in

182
00:06:05,430 --> 00:06:07,200
0,420 420,780 930,1200 1200,1440 1440,1770
response to a page fault.|
|

183
00:06:08,120 --> 00:06:10,310
0,120 120,540 540,840 840,1650 2040,2190
The other {} primitive you
另一个要讨论的原语是 Prot1 ，

184
00:06:10,310 --> 00:06:11,360
0,120 120,270 270,510 510,720 720,1050
know they talk about this

185
00:06:11,390 --> 00:06:14,960
0,420 420,930 1200,1950 1980,2730 2880,3570
{Prot1 -},| {} which {
|这降低了页面的可访问性，

186
00:06:15,780 --> 00:06:18,810
0,750 750,1560 1590,1770 1770,2790 2820,3030
-} decreases the accessibility of

187
00:06:18,810 --> 00:06:20,310
0,510 630,1050 1050,1170 1170,1410 1410,1500
{page -},| they talk a
|他们谈论了很多关于可访问性的问题，

188
00:06:20,310 --> 00:06:22,560
0,240 240,570 570,1350 1350,1680
lot about accessibility,| or
|或者你知道可访问性是什么意思？

189
00:06:23,420 --> 00:06:24,980
0,240 240,480 480,930 930,1080 1080,1560
and what do you mean

190
00:06:24,980 --> 00:06:26,680
0,330 330,1140
with accessibility?|
|

191
00:06:30,660 --> 00:06:31,800
0,570
Anybody?|
有人知道吗？|

192
00:06:33,920 --> 00:06:36,400
0,630 630,960 960,1320 1320,1920
Whether is read, write.|
是否可读写。|

193
00:06:36,530 --> 00:06:40,280
0,1680 2250,2520 2520,2670 2670,3450 3450,3750
Yeah, yeah, so there's different
是的，有不同的方式

194
00:06:40,280 --> 00:06:40,940
0,210 210,300 300,450 450,570 570,660
ways| in which you can
|来降低它们的可访问性，

195
00:06:40,940 --> 00:06:43,100
0,450 450,1110 1110,1830 1830,1980 1980,2160
decrease their accessibility,| you go
|你从一个页面读写到只读，

196
00:06:43,100 --> 00:06:44,180
0,330 330,480 480,750 750,840 840,1080
from a page that maybe

197
00:06:44,180 --> 00:06:45,980
0,240 240,450 450,990 1290,1530 1530,1800
has read write go to

198
00:06:45,980 --> 00:06:47,840
0,210 210,420 420,840 1260,1590 1590,1860
just read only,| or maybe
|或者你从只读到根本没有访问权限。

199
00:06:47,840 --> 00:06:49,040
0,90 90,270 270,750 750,1050 1050,1200
you go from { -}

200
00:06:49,040 --> 00:06:50,180
0,120 120,390 390,690 690,990 990,1140
read only to actually have

201
00:06:50,180 --> 00:06:51,540
0,180 180,510 510,600 600,930
no access at all.|
|

202
00:06:55,670 --> 00:06:57,140
0,480 570,840 840,1020 1020,1380 1380,1470
{} They also proposed that,|
他们还提出，|

203
00:06:57,140 --> 00:06:58,580
0,390 390,570 570,750 750,990 990,1440
basically there should be one
每个页面都应该有一个 Prot1 ，

204
00:06:58,580 --> 00:07:00,080
0,270 270,450 450,960 960,1290 1290,1500
for each individual page, that's

205
00:07:00,080 --> 00:07:01,460
0,240 240,690 780,1170 1170,1290 1290,1380
{Prot1 -},| there should be
|也应该有一个，

206
00:07:01,460 --> 00:07:02,480
0,240 240,390 390,780 780,930 930,1020
one| that actually you can
|你可以对应用程序的页面集合进行调用，

207
00:07:02,480 --> 00:07:04,250
0,240 240,690 720,960 960,1530 1530,1770
do for the application call

208
00:07:04,250 --> 00:07:05,510
0,120 120,180 180,600 600,690 690,1260
for a collection of pages,|
|

209
00:07:06,400 --> 00:07:08,920
0,570 1140,1470 1470,1740 1740,2250 2250,2520
{} and so basically {ProtN
所以 ProtN 原则上归结为

210
00:07:08,920 --> 00:07:10,120
0,210 210,480 480,660 660,750 750,1200
-} boils down in principle|
|

211
00:07:10,120 --> 00:07:12,220
0,390 420,1050 1050,1380 1380,1860 1860,2100
to calling {Prot1 -} N
调用 Prot1 N 次，

212
00:07:12,220 --> 00:07:14,860
0,630 720,1110 1110,1410 1410,2250 2280,2640
times,| but why, why do
|但是，他们讨论为什么，

213
00:07:14,860 --> 00:07:15,730
0,150 150,480 480,630 630,750 750,870
they argue that| we should
|我们也应该有这个 ProtN 原语。

214
00:07:15,730 --> 00:07:17,500
0,360 360,780 780,1050 1050,1350 1350,1770
have actually a {ProtN -}

215
00:07:17,830 --> 00:07:19,360
0,240 240,660 660,750 750,1050 1050,1530
{} version of this {}

216
00:07:19,390 --> 00:07:20,500
0,360 360,660
primitive too.|
|

217
00:07:23,070 --> 00:07:25,530
0,540 570,780 780,900 900,1710 1740,2460
{} Is it because {}
是不是因为它更有效率，

218
00:07:25,980 --> 00:07:28,620
0,840 840,1080 1080,1440 1440,1980 1980,2640
actually it's more efficient,| because
|因为保护 N 个页面的开销

219
00:07:28,620 --> 00:07:31,050
0,150 150,900 900,1500 1530,2250 2250,2430
the overhead of protecting the

220
00:07:31,050 --> 00:07:32,940
0,510 510,1170 1170,1410 1410,1620 1620,1890
N pages| is not much
|并不比保护一个页面多多少，

221
00:07:32,940 --> 00:07:35,310
0,180 180,360 360,870 870,1410 1410,2370
more than protecting one,| because,
|因为，他们谈到了一些比如摊销的东西。

222
00:07:36,190 --> 00:07:37,990
0,720 750,1020 1020,1260 1260,1560 1560,1800
they talked about something like

223
00:07:37,990 --> 00:07:39,940
0,720 720,840 840,1440
amortizing the work

224
00:07:39,970 --> 00:07:41,180
0,630
of.|
|

225
00:07:41,180 --> 00:07:42,240
0,450

226
00:07:42,670 --> 00:07:44,710
0,210 210,420 420,840 840,1200 1260,2040
Yeah yeah, absolutely right {},|
是的，完全正确，|

227
00:07:44,770 --> 00:07:45,610
0,180 180,540 540,600 600,690 690,840
so basically if you do
所以如果你做一个 Prot1 ，

228
00:07:45,610 --> 00:07:47,320
0,60 60,300 300,930 960,1620 1620,1710
a {Prot1 -},| basically you
|你必须更改页表位，并做一些工作，

229
00:07:47,320 --> 00:07:48,070
0,120 120,180 180,450 450,510 510,750
have to change the page

230
00:07:48,070 --> 00:07:49,180
0,240 240,630
table bits,

231
00:07:49,410 --> 00:07:51,210
0,690 720,870 870,1020 1020,1380 1560,1800
and do some work,| and
|然后在 Prot1 的后面，

232
00:07:51,210 --> 00:07:51,810
0,120 120,210 210,300 300,540 540,600
then at the end of

233
00:07:51,810 --> 00:07:53,520
0,210 210,810 810,930 930,1380 1380,1710
that Prot1,| {you,know} typically want
|通常需要刷新 TLB ，

234
00:07:53,520 --> 00:07:54,210
0,60 60,210 210,330 330,570 570,690
to have to flush the

235
00:07:54,210 --> 00:07:56,160
0,540 930,1170 1170,1500 1500,1680 1680,1950
{TLB -},| remember this from
|这是在 xv6 中实现的，

236
00:07:56,160 --> 00:07:58,480
0,780 780,1050 1050,1770
{xv6 -} implementation,|
|

237
00:07:58,510 --> 00:08:00,130
0,240 240,420 420,930 930,1260 1260,1620
{} and {} flushing TLB
而刷新 TLB 很昂贵，

238
00:08:00,130 --> 00:08:01,630
0,90 90,840 1110,1290 1290,1410 1410,1500
is expensive| and it would
|如果能摊销，那就更好了，

239
00:08:01,630 --> 00:08:02,440
0,90 90,360 360,450 450,540 540,810
be nice if you could

240
00:08:02,440 --> 00:08:05,140
0,570 570,1020 1020,1380 1380,1950 1950,2700
amortize| basically flushing TLB overall
|在整个页表变化时，刷新 TLB 。

241
00:08:05,170 --> 00:08:05,980
0,120 120,210 210,330 330,540 540,810
you know the page table

242
00:08:05,980 --> 00:08:07,100
0,600
changes.|
|

243
00:08:07,130 --> 00:08:08,870
0,210 210,540 540,840 840,1410 1410,1740
So basically {ProtN -} boils
所以， ProtN 可以归结为 N 次，

244
00:08:08,870 --> 00:08:11,630
0,210 210,750 750,1020 1020,1470 2550,2760
down to N times| N
|N 次更改页表位加上一次 TLB 刷新。

245
00:08:11,630 --> 00:08:13,460
0,540 540,1020 1020,1260 1260,1500 1500,1830
times changing page table bits

246
00:08:13,460 --> 00:08:14,540
0,360 360,630 630,810 810,870 870,1080
plus one {TLB - -}

247
00:08:14,540 --> 00:08:15,520
0,510
flush.|
|

248
00:08:15,640 --> 00:08:16,330
0,150 150,210 210,300 300,510 510,690
And if you did N
如果你做 N 次 Prot1 ，

249
00:08:16,330 --> 00:08:17,890
0,360 360,870 870,990 990,1110 1110,1560
times Prot1,| you would have
|你将有一个页表切换，

250
00:08:18,220 --> 00:08:19,810
0,360 360,660 660,870 870,1170 1170,1590
a one page table switch|
|

251
00:08:19,810 --> 00:08:21,550
0,630 630,990 990,1230 1230,1440 1440,1740
plus one page {} table
加上一个页表修改，

252
00:08:21,550 --> 00:08:22,930
0,570 570,930 930,1140 1140,1320 1320,1380
modification| plus one {TLB -
|以及每页的一个 TLB 刷新，

253
00:08:22,930 --> 00:08:24,280
0,210 210,540 540,660 660,870 870,1350
-} flush from each page,|
|

254
00:08:24,640 --> 00:08:25,810
0,270 270,330 330,420 420,780 780,1170
so you can save the
这样你可以节省 TLB 刷新。

255
00:08:25,840 --> 00:08:27,240
0,210 210,360 360,840
{TLB -} flush.|
|

256
00:08:27,630 --> 00:08:29,020
0,270 270,330 330,480 480,810
Does that make sense?|
这能理解吗？|

257
00:08:37,450 --> 00:08:40,030
0,690 1080,1770 1830,2310 2340,2460 2460,2580
Okay, {} then you know
好的，然后原语的 Unprot ，

258
00:08:40,030 --> 00:08:41,200
0,360
the

259
00:08:41,200 --> 00:08:42,580
0,720
primitive

260
00:08:43,130 --> 00:08:46,790
0,810 810,1260 1260,2010 2010,2970 3480,3660
Unprot,| this increases accessibility as
|这增加了可访问性，

261
00:08:46,790 --> 00:08:48,120
0,120 120,420 420,630
they call it,|
|

262
00:08:49,940 --> 00:08:51,440
0,450 450,960 960,1080 1080,1230 1230,1500
basically meaning you know,| if
基本上就是说，|比如，如果页面现在有只读访问，

263
00:08:51,470 --> 00:08:52,730
0,390 390,450 450,930 930,1080 1080,1260
page for example {} have

264
00:08:52,730 --> 00:08:53,900
0,180 180,270 270,450 450,720 720,1170
what had read only access

265
00:08:53,900 --> 00:08:54,650
0,270 270,420 420,570 570,690 690,750
now,| we're just going to
|我们将其提升为具有读写访问权限。

266
00:08:54,650 --> 00:08:55,580
0,330 330,420 420,510 510,780 780,930
promote it to actually have

267
00:08:55,580 --> 00:08:57,260
0,210 210,420 420,660 660,1200
read and write access.|
|

268
00:08:57,480 --> 00:08:58,830
0,210 210,270 270,420 420,930 930,1350
There are two other primitives
这里还提到了另外两个原语，

269
00:08:58,830 --> 00:09:01,020
0,570 570,930 930,1140 1140,1380 1800,2190
are mentioning,| one is primitive
|一个原语是找出脏页面，

270
00:09:01,020 --> 00:09:02,010
0,120 120,390 390,630 630,780 780,990
to actually find out which

271
00:09:02,010 --> 00:09:03,090
0,300 300,630 630,750 750,990 990,1080
page which {} page is

272
00:09:03,090 --> 00:09:04,080
0,450
dirty,|
|

273
00:09:04,080 --> 00:09:06,150
0,600 600,1080 1080,1320 1320,1500 1590,2070
and another {primitive -} {Map2
以及另一个原语 Map2 ，

274
00:09:06,150 --> 00:09:08,280
0,510 660,870 870,1620
-},| which allows,
|允许一个应用程序

275
00:09:08,280 --> 00:09:09,900
0,390 390,1230 1230,1440 1440,1560 1560,1620
{} to {allows -} an

276
00:09:09,900 --> 00:09:12,030
0,450 450,540 540,1050 1350,1770 1770,2130
application| to map a particular
|在同一个地址空间映射两次，

277
00:09:12,030 --> 00:09:14,580
0,630 690,1350 1350,1620 1620,2220 2250,2550
range twice in the same

278
00:09:14,580 --> 00:09:16,590
0,330 330,870 870,1140 1140,1470 1470,2010
address page,| the same address
|同一个地址空间，

279
00:09:16,590 --> 00:09:20,040
0,540 540,1140 1320,1680 1680,2880 3240,3450
{} space,| but with a
|但具有不同程度的可访问性。

280
00:09:20,040 --> 00:09:22,240
0,630 630,900 900,960 960,1710
different degrees of accessibility.|
|

281
00:09:22,540 --> 00:09:23,920
0,270 270,420 420,930 930,1200 1200,1380
We'll see that showing up
我们一会儿就能看到这一点。

282
00:09:23,920 --> 00:09:25,060
0,90 90,150 150,570
in a second.|
|

283
00:09:25,320 --> 00:09:27,330
0,510 1140,1590 1620,1800 1800,1950 1950,2010
{} So you look at
所以你看看这些原语，

284
00:09:27,330 --> 00:09:28,770
0,120 120,750 780,1020 1020,1170 1170,1440
these primitives,| you know {xv6
|xv6 支持其中的任何一个，

285
00:09:28,770 --> 00:09:30,600
0,510 690,1140 1140,1290 1290,1350 1350,1830
-} support any of these,|
|

286
00:09:32,490 --> 00:09:34,580
0,210 210,330 330,810 810,1530
{you,know} for {user,level} applications.|
对于用户级应用程序。|

287
00:09:46,810 --> 00:09:48,250
0,630 630,750 750,870 870,1020 1020,1440
Not out of the box,|
不是开箱即用，|

288
00:09:48,250 --> 00:09:50,260
0,180 180,450 450,990 1020,1440 1440,2010
but maybe the alarm handler
但是也许我们实现的警报处理程序感觉很接近。

289
00:09:50,260 --> 00:09:52,120
0,120 120,240 240,840 870,1290 1290,1860
that we implemented feels close.|
|

290
00:09:52,270 --> 00:09:54,370
0,1200 1200,1440 1440,1710 1710,1800 1800,2100
{Good,yeah}, they keep the alarm
好的，他们把警报处理程序记在脑海里，

291
00:09:54,370 --> 00:09:55,540
0,180 180,540 540,630 630,810 810,1170
{handler -} in their mind,|
|

292
00:09:55,540 --> 00:09:56,950
0,150 150,510 510,930 930,1170 1170,1410
that certainly feels very close
当然与 Trap 的感觉非常接近，

293
00:09:56,950 --> 00:09:58,030
0,330 330,600 600,690 690,990 990,1080
correctly that is related to

294
00:09:58,030 --> 00:09:59,340
0,90 90,360 360,750
the Trap one,|
|

295
00:10:02,480 --> 00:10:03,830
0,570 600,750 750,960 960,1080 1080,1350
{} but other than that,|
但除此之外，|

296
00:10:03,830 --> 00:10:05,330
0,150 150,210 210,450 450,690 690,1500
there are {xv6 -} {support,none,of,this},
xv6 不支持任何一个，

297
00:10:05,330 --> 00:10:06,800
0,390 480,900 900,1290 1290,1440 1440,1470
right,| {} actually it's a
|实际上它是一个非常小的 Unix 接口，

298
00:10:06,800 --> 00:10:09,320
0,360 360,690 690,930 930,1980 2040,2520
very minimal Unix interface,| doesn't
|不支持任何更高级的虚拟内存原语，

299
00:10:09,320 --> 00:10:11,300
0,540 840,1380 1380,1470 1470,1740 1740,1980
support any of the more

300
00:10:11,300 --> 00:10:14,720
0,660 690,1530 1650,2490 2490,3030 3120,3420
advanced {} {virtual,memory} primitives,| even
|即使在内部内核本身确实具有所有可用的机制，

301
00:10:14,720 --> 00:10:16,520
0,330 330,1020 1020,1080 1080,1350 1350,1800
though internally the kernel itself

302
00:10:16,520 --> 00:10:18,620
0,270 270,720 720,900 900,1230 1260,2100
does have all the mechanism

303
00:10:18,650 --> 00:10:21,110
0,720 870,1290 1290,1560 1560,1800 1800,2460
available,| but you're not exposed
|但是你不会将系统调用暴露到用户空间。

304
00:10:21,110 --> 00:10:22,610
0,240 240,510 510,840 840,1050 1050,1500
to user space into a

305
00:10:22,610 --> 00:10:24,060
0,300 300,420 420,720 720,1140
form of system calls.|
|

306
00:10:24,180 --> 00:10:24,960
0,120 120,180 180,420 420,510 510,780
As a result, the papers
所以，论文认为，

307
00:10:24,960 --> 00:10:26,850
0,450 450,750 1050,1590 1590,1740 1740,1890
arguing that| any sort of
|任何一种好的操作系统都应该提供

308
00:10:26,850 --> 00:10:28,620
0,480 480,780 780,1140 1140,1260 1260,1770
good operating systems should provide|
|

309
00:10:28,620 --> 00:10:30,000
0,90 90,210 210,690 840,1320 1320,1380
you know these primitives or
这些原语或系统调用，

310
00:10:30,000 --> 00:10:31,230
0,300 300,600 600,660 660,750 750,1230
system calls,| so the application
|以便应用程序可以使用它们。

311
00:10:31,230 --> 00:10:32,260
0,150 150,300 300,510
can use them.|
|

312
00:10:32,530 --> 00:10:33,730
0,150 150,300 300,810 810,1080 1080,1200
So that naturally relates to
所以自然与这个问题有关，

313
00:10:33,730 --> 00:10:34,930
0,60 60,360 360,660 660,930 930,1200
the question,| like what what's
|比如，我们今天的 Unix 有多大的范围可用，

314
00:10:34,930 --> 00:10:35,980
0,90 90,540 570,660 660,780 780,1050
the scope you know we've

315
00:10:36,010 --> 00:10:41,650
0,360 360,930 1260,1860 4950,5370 5400,5640
Unix today are available,| it
|事实证明，任何，

316
00:10:41,650 --> 00:10:43,030
0,210 210,510 510,1170 1170,1260 1260,1380
turns out, basically you know

317
00:10:43,030 --> 00:10:45,220
0,510 510,630 1050,1260 1260,1380 1380,2190
any,| {} look at modern
|看看现代的 Unix ，比如 Linux ，

318
00:10:45,220 --> 00:10:47,560
0,300 300,600 660,1170 1440,2220 2220,2340
Unix like Linux,| {} you
|你知道这些原语就在那里，

319
00:10:47,560 --> 00:10:48,820
0,60 60,270 270,720 720,840 840,1260
know these primitives are there,|
|

320
00:10:49,220 --> 00:10:50,720
0,300 300,630 630,810 810,1410 1410,1500
{} maybe not exactly the
也许与论文中讨论的不完全一样，

321
00:10:50,720 --> 00:10:53,540
0,540 540,1440 1440,2040 2370,2760 2760,2820
same flavor as argued in

322
00:10:53,540 --> 00:10:54,290
0,60 60,360 360,510 510,600 600,750
the paper,| but they are
|但它们确实存在。

323
00:10:54,290 --> 00:10:55,120
0,300
there.|
|

324
00:10:55,350 --> 00:10:56,190
0,330 330,510 510,660 660,780 780,840
You even saw it in
你甚至在论文中看到了，

325
00:10:56,190 --> 00:10:57,390
0,60 60,330 330,630 630,870 960,1200
the paper, correct| or some
|或者某些操作系统确实具有它们子集的某个版本，

326
00:10:57,390 --> 00:10:58,380
0,90 90,210 210,510 510,810 810,990
of the operating system did

327
00:10:58,380 --> 00:10:59,730
0,450 450,660 660,1230 1230,1290 1290,1350
have some version of a

328
00:10:59,730 --> 00:11:02,010
0,450 450,540 540,960 1200,1710 1830,2280
subset of them,| {} but
|但今天它们基本上广泛支持。

329
00:11:02,010 --> 00:11:04,380
0,390 390,480 480,990 1230,1740 1740,2370
today they basically widely supported.|
|

330
00:11:04,820 --> 00:11:05,390
0,150 150,240 240,390 390,450 450,570
If you look at Unix
如果你看看今天的 Unix ，

331
00:11:05,390 --> 00:11:06,820
0,240 240,810
{today -},|
|

332
00:11:07,080 --> 00:11:08,490
0,450 450,690 690,900 900,1080 1080,1410
let's see how it actually
让我们看看它是如何实现它的。

333
00:11:08,490 --> 00:11:10,420
0,330 330,1050 1050,1380
there instantiate it.|
|

334
00:11:12,410 --> 00:11:13,460
0,150 150,300 300,660 660,750 750,1050
And so one of the
所以第一个，

335
00:11:13,460 --> 00:11:14,420
0,240 240,450 450,630 630,900 900,960
first ones| is probably the
|可能是最重要的一个，

336
00:11:14,420 --> 00:11:15,860
0,180 180,540 540,930 1050,1170 1170,1440
most important one| is something
|就是所谓的 mmap ，

337
00:11:15,860 --> 00:11:17,480
0,270 270,480 480,990 990,1140 1140,1620
that's just called {mmap -},|
|

338
00:11:18,210 --> 00:11:19,800
0,570 900,1170 1170,1350 1350,1500 1500,1590
{} and that can be
它可以用来获取某个对象，

339
00:11:19,800 --> 00:11:22,380
0,390 390,930 1110,1590 1590,1950 1950,2580
used to take some object|
|

340
00:11:22,380 --> 00:11:23,490
0,300 300,570 570,690 690,1020 1020,1110
and map it into the
并将其映射到调用者的地址空间中，

341
00:11:23,490 --> 00:11:25,020
0,300 300,750 750,960 960,1080 1080,1530
address space of the caller,|
|

342
00:11:25,540 --> 00:11:26,590
0,360 360,510 510,600 600,960 960,1050
{} sort of example if
比如你想要映射一个文件，

343
00:11:26,590 --> 00:11:27,220
0,90 90,240 240,300 300,540 540,630
you want to map a

344
00:11:27,220 --> 00:11:28,380
0,630
file,|
|

345
00:11:30,160 --> 00:11:31,240
0,270 270,720 750,900 900,990 990,1080
{you,know}, then you know the
然后系统调用有以下的形式，

346
00:11:31,240 --> 00:11:32,530
0,330 330,600 600,930 930,1200 1200,1290
system calls {} something of

347
00:11:32,530 --> 00:11:34,270
0,90 90,480 480,1050 1080,1410 1410,1740
the following form,| {you,know} call
|调用 mmap ，

348
00:11:34,270 --> 00:11:35,400
0,600
mmap,|
|

349
00:11:35,840 --> 00:11:38,750
0,750 1320,1800 1800,2100 2100,2370 2370,2910
{} mmap actually has quite
mmap 有相当多的参数，

350
00:11:38,750 --> 00:11:40,130
0,30 30,120 120,180 180,930 930,1380
a bit of a building

351
00:11:40,130 --> 00:11:42,230
0,390 390,570 570,1350 1740,1980 1980,2100
number of arguments,| {} the
|第一个是，

352
00:11:42,230 --> 00:11:43,610
0,240 240,570 570,840 840,1020 1020,1380
first basically says like what

353
00:11:43,610 --> 00:11:45,500
0,330 330,1020 1140,1350 1350,1440 1440,1890
you,| {} you can specify
|你可以指定一个想要映射的地址，

354
00:11:45,500 --> 00:11:46,460
0,0 0,450 450,720 720,840 840,960
a particular address {} you

355
00:11:46,460 --> 00:11:47,270
0,180 180,450 450,540 540,630 630,810
would like it to be

356
00:11:47,270 --> 00:11:49,130
0,360 360,720 780,1230 1230,1680 1680,1860
mapped to| {} or you
|或者你可以让内核决定选择地址，

357
00:11:49,130 --> 00:11:50,360
0,150 150,390 390,480 480,780 780,1230
can let the kernel decides

358
00:11:50,360 --> 00:11:53,390
0,1320 1350,1740 1740,1860 1860,2370 2670,3030
to choose the address {},|
|

359
00:11:53,390 --> 00:11:55,400
0,540 810,1380 1380,1530 1530,1710 1710,2010
and {} in that case,
在这种情况下，你指定 null ，

360
00:11:55,400 --> 00:11:57,350
0,150 150,660 660,840 840,1350 1350,1950
you specified just null| and
|然后内核选择对象要映射的地址，

361
00:11:57,560 --> 00:11:58,820
0,360 360,540 540,660 660,990 990,1260
kernel pick an address where

362
00:11:58,820 --> 00:11:59,840
0,90 90,540 570,690 690,810 810,1020
to map you know the

363
00:11:59,840 --> 00:12:00,740
0,540
object,|
|

364
00:12:00,770 --> 00:12:02,460
0,510 510,600 600,1230
specify the length,|
指定长度，|

365
00:12:02,460 --> 00:12:04,290
0,360 360,420 420,1110 1110,1440 1440,1830
{} you specify the protection
指定保护位，

366
00:12:04,290 --> 00:12:05,700
0,480 480,660 660,750 750,840 840,1410
bits,| you know, for example
|比如读/写，

367
00:12:05,970 --> 00:12:07,020
0,480
read

368
00:12:07,700 --> 00:12:10,460
0,330 330,900 1290,2070 2070,2400 2400,2760
slash write,| {} and then
|然后一些我们要讨论的参数，

369
00:12:10,490 --> 00:12:11,660
0,90 90,240 240,390 390,960 960,1170
you know some argument, we

370
00:12:11,660 --> 00:12:12,440
0,150 150,210 210,390 390,660 660,780
want to talk about,| and
|还有一个叫做 MAP_PRIVATE 的东西，

371
00:12:12,440 --> 00:12:14,180
0,150 150,420 420,660 870,1140 1140,1740
there's something called {MAP_PRIVATE -},|
|

372
00:12:14,210 --> 00:12:15,440
0,660 660,840 840,990 990,1080 1080,1230
basically you have to say
你必须说一些事情，

373
00:12:15,440 --> 00:12:17,020
0,330 330,600 600,1050
something about how,|
|

374
00:12:17,760 --> 00:12:18,960
0,570

375
00:12:21,380 --> 00:12:22,580
0,450 450,810 810,900 900,990 990,1200
what happens if you actually
如果写那个特定的对象，会发生什么，

376
00:12:22,580 --> 00:12:24,380
0,480 510,660 660,870 870,1230 1230,1800
write to that particular object,|
|

377
00:12:26,640 --> 00:12:29,070
0,600 690,1050 1050,1170 1170,1800 1860,2430
let's skip that mostly,| then
我们跳过大多数，|然后你可以，

378
00:12:29,070 --> 00:12:30,180
0,120 120,240 240,810 810,930 930,1110
you can for,| we can
|我们可以传入文件描述符和偏移量，

379
00:12:30,180 --> 00:12:31,440
0,450 450,810 810,900 900,1020 1020,1260
actually pass in the file

380
00:12:31,440 --> 00:12:33,040
0,420 420,540 540,1140
descriptor and offset,|
|

381
00:12:34,000 --> 00:12:34,960
0,120 120,420 420,540 540,660 660,960
and basically what this says
这就是说，

382
00:12:34,960 --> 00:12:36,220
0,180 180,570 900,1020 1020,1110 1110,1260
is that| you know you
|你应该映射文件对象的内容，

383
00:12:36,220 --> 00:12:38,320
0,240 240,540 540,780 780,1350 1350,2100
should map the content of

384
00:12:38,380 --> 00:12:40,600
0,150 150,540 540,1200 1230,1860 1890,2220
the file object,| {} pointed
|由文件描述符指向，

385
00:12:40,600 --> 00:12:42,040
0,120 120,390 390,540 540,720 720,1440
to by the file descriptor|
|

386
00:12:42,310 --> 00:12:43,360
0,390 390,630 630,810 810,960 960,1050
{} and you take the
然后你从偏移量获取对象的文件内容，

387
00:12:43,360 --> 00:12:44,950
0,210 210,360 360,570 570,900 900,1590
file content to the object

388
00:12:44,950 --> 00:12:46,810
0,180 180,390 390,960 1080,1530 1530,1860
{you,know} at offset,| map that
|使用长度映射那个特定地址。

389
00:12:46,810 --> 00:12:49,090
0,660 660,870 870,1170 1170,1620 1620,2280
basically {} that particular {}

390
00:12:49,090 --> 00:12:50,320
0,300 300,630 630,780 780,1050 1050,1230
particular address {you,know} with that

391
00:12:50,320 --> 00:12:51,100
0,390
length.|
|

392
00:12:51,510 --> 00:12:52,590
0,180 180,270 270,420 420,810 810,1080
And so this basically allows
所以，这允许你提供

393
00:12:52,590 --> 00:12:53,610
0,150 150,240 240,570 630,960 960,1020
you to serve| what is
|所谓的内存映射文件，

394
00:12:53,610 --> 00:12:55,140
0,180 180,480 480,780 780,1230 1410,1530
called memory map file,| so
|你可以将文件内容放入你的地址空间，

395
00:12:55,140 --> 00:12:56,610
0,120 120,570 570,780 780,870 870,1470
you can bring the contents

396
00:12:56,610 --> 00:12:58,020
0,120 120,240 240,750 810,1170 1170,1410
of the file into your

397
00:12:58,020 --> 00:12:59,910
0,270 270,720 750,1020 1020,1620 1620,1890
address space,| would actually having
|实际上调用读取或写入系统调用。

398
00:12:59,910 --> 00:13:01,050
0,90 90,390 390,570 570,690 690,1140
to call read or write

399
00:13:01,140 --> 00:13:03,400
0,720 990,1320 1320,1770
{} system calls.|
|

400
00:13:03,400 --> 00:13:04,540
0,180 180,330 330,390 390,870 870,1140
It's sort of convenient, correct,|
这在某种程度上是很方便的，|

401
00:13:04,540 --> 00:13:05,620
0,210 210,360 360,480 480,600 600,1080
because then you can manipulate
因为这样你可以只用普通的指针来操作文件，

402
00:13:05,620 --> 00:13:08,080
0,330 360,750 750,1110 1410,1890 1890,2460
the file just ordinary pointers,|
|

403
00:13:08,080 --> 00:13:09,130
0,120 120,360 360,630 630,720 720,1050
you can write at particular
你可以在特定位置写入，

404
00:13:09,130 --> 00:13:10,720
0,750 750,870 870,1260 1260,1410 1410,1590
locations| and then at some
|然后在某个点上，你可以写回到磁盘，

405
00:13:10,720 --> 00:13:11,470
0,240 240,330 330,450 450,660 660,750
point you can write to

406
00:13:11,470 --> 00:13:13,160
0,150 150,600 600,780
come back to

407
00:13:13,160 --> 00:13:14,630
0,690 810,960 960,1020 1020,1350 1350,1470
{} to the disk| and
|所以它是操作数据结构的方便的接口，

408
00:13:14,630 --> 00:13:15,410
0,90 90,150 150,270 270,360 360,780
so it is a convenient

409
00:13:15,410 --> 00:13:17,720
0,450 450,720 720,1470 1500,2070 2070,2310
interface to a manipulate data

410
00:13:17,720 --> 00:13:19,160
0,390 390,510 510,810 810,1050 1050,1440
structures,| that might be stored
|可能存储在文件中。

411
00:13:19,160 --> 00:13:20,390
0,420 570,870 870,930 930,1170 1170,1230
into might be stored in

412
00:13:20,390 --> 00:13:21,340
0,90 90,450
the file.|
|

413
00:13:21,700 --> 00:13:24,220
0,360 540,780 780,1110 1440,2100 2310,2520
And in fact, {} you
实际上，你将实现这个特定版本的 mmap ，

414
00:13:24,220 --> 00:13:26,860
0,210 210,330 330,1140 1140,1890 2040,2640
will be implementing {} {this,specific}

415
00:13:26,860 --> 00:13:27,730
0,330 330,450 450,630 630,810 810,870
version of {mmap -}| or
|或者基于文件的 mmap 的某个版本，

416
00:13:27,730 --> 00:13:29,020
0,180 180,720 840,900 900,990 990,1290
some version of the file

417
00:13:29,020 --> 00:13:30,820
0,510 720,1320 1320,1590 1590,1710 1710,1800
based mmap| actually in the
|在下一个实验中。

418
00:13:30,820 --> 00:13:31,980
0,270 270,720
next lab.|
|

419
00:13:33,950 --> 00:13:35,390
0,240 240,420 420,780 780,1350 1350,1440
So this basically integrates you
这集成了 xv6 的文件系统部分，

420
00:13:35,390 --> 00:13:36,710
0,90 90,210 210,480 480,750 750,1320
know the file system part

421
00:13:36,710 --> 00:13:38,300
0,90 90,420 420,810 810,1260 1260,1590
of {xv6 -},| {you,know} virtual
|xv6 的虚拟内存部分，

422
00:13:38,300 --> 00:13:39,560
0,270 270,480 480,570 570,1140 1140,1260
memory part of xv6| and
|你可以将它们联系起来，

423
00:13:39,560 --> 00:13:40,850
0,360 360,600 600,750 750,990 990,1290
{you,can,sort,of} hook them up| and
|通过实现 mmap ，

424
00:13:40,850 --> 00:13:42,590
0,270 270,840 840,1050 1050,1290 1290,1740
by supplying by actually implementing

425
00:13:42,590 --> 00:13:43,400
0,360
mmap,|
|

426
00:13:43,980 --> 00:13:44,880
0,150 150,390 390,480 480,750 750,900
{mmap -} can also be
mmap 还可以以其他方式使用，

427
00:13:44,880 --> 00:13:46,620
0,240 240,570 630,900 900,1350 1380,1740
used in other ways {},|
|

428
00:13:46,620 --> 00:13:47,790
0,240 450,780 780,900 900,1080 1080,1170
so you can use the
你可以使用映射文件，

429
00:13:47,790 --> 00:13:48,990
0,300 300,630 630,750 750,840 840,1200
map file,| you can also
|你也可以用它来映射匿名内存，

430
00:13:48,990 --> 00:13:51,270
0,480 480,540 540,630 630,1110 1470,2280
use it to map anonymous

431
00:13:51,270 --> 00:13:52,440
0,510
memory,|
|

432
00:13:54,580 --> 00:13:55,510
0,150 150,330 330,720 720,870 870,930
and that's basically sort of
这是对 sbrk 的一种替代，

433
00:13:55,510 --> 00:13:56,830
0,60 60,600 600,720 720,870 870,1320
an alternative to {sbrk -}|
|

434
00:13:56,830 --> 00:13:58,000
0,480 480,780 780,900 900,1080 1080,1170
where you can sort of
你可以要求内核，

435
00:13:58,000 --> 00:13:59,320
0,570 570,630 630,900 900,1230 1230,1320
ask the kernel,| please you
|请给我一些内存，

436
00:13:59,320 --> 00:14:00,100
0,120 120,330 330,480 480,540 540,780
know give me a bunch

437
00:14:00,100 --> 00:14:02,470
0,180 180,930 1200,1800 1800,2280 2280,2370
of memory,| {} and you
|并且映射在这个特定的地址。

438
00:14:02,470 --> 00:14:04,330
0,90 90,450 450,900 900,1050 1050,1860
know map at this particular

439
00:14:04,330 --> 00:14:05,500
0,750
address.|
|

440
00:14:06,120 --> 00:14:07,280
0,600

441
00:14:07,480 --> 00:14:09,070
0,270 270,960 960,1410 1410,1500 1500,1590
So {that,is} one of the
所以这是核心系统调用之一，

442
00:14:09,070 --> 00:14:11,950
0,780 840,1500 1530,1860 1860,2370 2550,2880
core {} system calls| and
|并与第二个原语[相关]。

443
00:14:11,950 --> 00:14:13,180
0,390 390,660 660,750 750,840 840,1230
[related] back to the primitives

444
00:14:13,180 --> 00:14:14,380
0,90 90,150 150,660
in the second.|
|

445
00:14:16,570 --> 00:14:17,800
0,210 210,390 390,420 420,660 660,1230
Okay, there's a couple more
好的，还有几个调用是必要的，

446
00:14:18,550 --> 00:14:21,010
0,360 360,510 510,840 870,1860 2040,2460
calls that are necessary| to
|以支持论文所主张的原语，

447
00:14:21,010 --> 00:14:23,080
0,480 480,840 840,900 900,1470 1470,2070
actually support the primitives at

448
00:14:23,080 --> 00:14:24,790
0,60 60,330 330,600 600,960 1350,1710
the paper argued for {}|
|

449
00:14:24,790 --> 00:14:26,680
0,360 360,630 630,1170 1380,1650 1650,1890
and Unix has has them,|
Unix 拥有它们，|

450
00:14:26,680 --> 00:14:28,480
0,180 180,660 660,930 930,1260 1260,1800
so there's more Unix today,|
所以更多的关于今天的 Unix，|

451
00:14:30,200 --> 00:14:32,780
0,510 540,900 900,1230 1590,2310 2310,2580
{} there's an mprotect system
这里有一个 mprotect 系统调用，

452
00:14:32,780 --> 00:14:34,160
0,510
call,|
|

453
00:14:34,800 --> 00:14:36,180
0,210 210,510 510,690 690,1080 1080,1380
so once you have something
一旦你将某些内容映射到地址空间，

454
00:14:36,180 --> 00:14:37,950
0,300 300,840 840,960 960,1260 1260,1770
mapped into the address space,|
|

455
00:14:38,370 --> 00:14:39,660
0,420 420,570 570,1080 1080,1170 1170,1290
you can actually you know
你可以更改权限，

456
00:14:39,660 --> 00:14:41,060
0,780
change

457
00:14:41,560 --> 00:14:42,840
0,750
the

458
00:14:43,620 --> 00:14:45,600
0,480 480,1140 1290,1500 1500,1860 1860,1980
the permissions,| so whatever you
|所以无论什么，

459
00:14:45,600 --> 00:14:47,010
0,90 90,240 240,420 420,810 1140,1410
can make| it just {you,know}
|mprotect 映射某些东西到地址空间，

460
00:14:47,010 --> 00:14:49,110
0,210 210,480 480,540 540,1470 1710,2100
{mprotect -} the particular map

461
00:14:49,110 --> 00:14:50,070
0,270 270,420 420,480 480,690 690,960
something into the address space,|
|

462
00:14:50,070 --> 00:14:50,850
0,90 90,180 180,300 300,450 450,780
then you know {mprotect -}
然后 mprotect ，比如它的一部分或全部的子集，

463
00:14:50,850 --> 00:14:52,020
0,240 240,600 600,750 750,780 780,1170
for example for a subset

464
00:14:52,020 --> 00:14:53,040
0,60 60,360 390,720 720,840 840,1020
of that part or all

465
00:14:53,040 --> 00:14:54,060
0,90 90,300 540,750 750,960 960,1020
of it| and map it
|并将其映射到特定的保护级别，

466
00:14:54,060 --> 00:14:56,250
0,150 150,900 930,1290 1290,1620 2010,2190
to particular protection level,| so
|比如，如果你做了这个，

467
00:14:56,250 --> 00:14:56,970
0,60 60,420 420,480 480,570 570,720
for example if you did

468
00:14:56,970 --> 00:14:58,770
0,300 300,1110 1110,1530 1530,1680 1680,1800
this,| basically loads could be
|可以执行加载，

469
00:14:58,770 --> 00:15:01,110
0,660 990,1440 1440,1920 1920,2100 2100,2340
executed,| but stores would {you,know}
|但是保存会变成一个页面错误，

470
00:15:01,110 --> 00:15:02,560
0,330 330,690 690,1020
change into {

471
00:15:02,560 --> 00:15:05,410
0,450 1230,1590 1590,1980 1980,2280 2280,2850
-} change into a {page,fault}|
|

472
00:15:05,800 --> 00:15:06,580
0,180 180,480 480,540 540,660 660,780
and similarly if you want
同样，如果你想确保

473
00:15:06,580 --> 00:15:08,140
0,60 60,210 210,420 420,1110 1140,1560
to make sure| that range
|地址空间中的范围完全不可访问，

474
00:15:08,140 --> 00:15:09,220
0,120 120,360 360,570 570,660 660,1080
in address space is completely

475
00:15:09,220 --> 00:15:10,920
0,600 600,750 750,900 900,1140
inaccessible,| then you can,
|你可以，对 mprotect 使用 NONE ，

476
00:15:12,290 --> 00:15:14,480
0,180 180,600 600,750 750,1290 1530,2190
{mprotect -} with NONE| and
|然后它们，

477
00:15:14,480 --> 00:15:15,650
0,90 90,180 180,570 570,750 750,1170
you know basically then both,|
|

478
00:15:15,650 --> 00:15:18,440
0,0 1320,1770 1770,1950 1950,2550 2550,2790
{} {everything -} basically, every
任何对这个页面或这个地址范围的访问，

479
00:15:18,440 --> 00:15:20,240
0,570 750,870 870,1080 1080,1440 1440,1800
access to that particular page

480
00:15:20,240 --> 00:15:22,160
0,90 90,360 360,840 870,1350 1350,1920
or to that address range|
|

481
00:15:22,310 --> 00:15:23,960
0,330 330,480 480,870 900,990 990,1650
starting from address to address
从地址到地址加上长度，

482
00:15:23,960 --> 00:15:26,150
0,240 240,720 780,1320 1320,1860 1860,2190
plus length,| will result in
|将导致页面错误。

483
00:15:26,570 --> 00:15:27,720
0,90 90,690
a {page,fault}.|
|

484
00:15:28,830 --> 00:15:30,450
0,330 330,540 540,600 600,1110 1110,1620
{} There's a similar version,|
还有一个类似的版本，|

485
00:15:31,620 --> 00:15:32,880
0,240 240,270 270,840 840,1110 1110,1260
there's a corresponding call to
对 mmap 有一个相应的调用，叫做 unmap ，

486
00:15:32,880 --> 00:15:34,890
0,180 180,540 540,930 930,1470 1710,2010
{mmap -} called unmap,| that
|这允许你删除映射或删除地址范围。

487
00:15:34,890 --> 00:15:36,150
0,330 330,480 480,630 630,990 990,1260
allows you to basically remove

488
00:15:36,150 --> 00:15:37,830
0,90 90,690 810,1080 1110,1500 1500,1680
a mapping or remove an

489
00:15:37,860 --> 00:15:39,280
0,360 360,900
address range.|
|

490
00:15:43,620 --> 00:15:44,850
0,150 150,510 510,630 630,750 750,1230
And actually, if you curious
如果你好奇这些调用是怎么工作的，

491
00:15:45,000 --> 00:15:45,990
0,150 150,210 210,690 690,810 810,990
you know exactly how these

492
00:15:45,990 --> 00:15:47,070
0,300 300,630 630,720 720,840 840,1080
calls work,| you know you
|你可以查看这些系统调用的手册页。

493
00:15:47,070 --> 00:15:48,030
0,360 360,540 540,630 630,720 720,960
should look up the man

494
00:15:48,030 --> 00:15:51,660
0,510 1080,1470 1470,2880 2880,3120 3120,3630
page of these system calls.|
|

495
00:15:52,580 --> 00:15:54,470
0,480 990,1110 1110,1290 1290,1770 1770,1890
{} And then finally you
最后，我们真正需要的是系统调用 sigaction ，

496
00:15:54,470 --> 00:15:55,490
0,180 180,450 450,750 750,870 870,1020
know the one that we

497
00:15:55,490 --> 00:15:58,850
0,660 660,1140 1470,2910 2910,3060 3060,3360
really need {} is {}

498
00:15:58,850 --> 00:16:01,040
0,240 240,660 660,960 960,1620
system call {sigaction -},|
|

499
00:16:04,530 --> 00:16:05,430
0,270 270,570 570,720 720,810 810,900
and basically this is a
这是一个信号处理程序，

500
00:16:05,430 --> 00:16:07,000
0,330 330,900
signal handler,|
|

501
00:16:11,210 --> 00:16:12,590
0,450 450,780 780,870 870,1290 1290,1380
and allows the application| to
并允许应用程序，|比如，如果某个特定信号发生，

502
00:16:12,590 --> 00:16:13,970
0,300 300,600 600,690 690,960 1020,1380
say like you know if

503
00:16:13,970 --> 00:16:16,250
0,60 60,420 420,780 780,1410 1800,2280
a particular signal happens {},|
|

504
00:16:16,250 --> 00:16:17,630
0,540 540,600 600,750 750,1200 1200,1380
then you know call this
然后调用这个特殊的函数，

505
00:16:17,630 --> 00:16:19,000
0,360 360,810
particular function,|
|

506
00:16:19,530 --> 00:16:21,120
0,240 270,660 990,1080 1080,1230 1230,1590
so maybe you can install
所以也许你可以安装函数 f

507
00:16:21,120 --> 00:16:22,650
0,420 420,750 750,1020 1020,1290 1290,1530
basically function f| as a
|作为特定信号的信号处理程序，

508
00:16:22,650 --> 00:16:24,450
0,360 360,1140 1170,1350 1350,1410 1410,1800
signal handler for a particular

509
00:16:24,450 --> 00:16:25,480
0,480
signal,|
|

510
00:16:25,510 --> 00:16:26,650
0,390 390,510 510,600 600,900 900,1140
and in the case of
在页面错误的情况下，

511
00:16:26,650 --> 00:16:27,700
0,150 150,390 390,840 840,930 930,1050
{you,know} page faults,| you know
|产生的信号叫做 segfault ，

512
00:16:27,700 --> 00:16:30,460
0,480 480,1080 1590,1980 1980,2340 2340,2760
the signal {} that is

513
00:16:30,700 --> 00:16:32,410
0,750 750,1080 1080,1380 1380,1500 1500,1710
generated yeah something was called

514
00:16:32,410 --> 00:16:33,700
0,270 270,720
{segfault -},|
|

515
00:16:36,740 --> 00:16:37,760
0,480 480,570 570,720 720,810 810,1020
typically, you might have seen
你可能以前在用户代码中看到过 segfault ，

516
00:16:37,760 --> 00:16:39,680
0,240 240,600 600,1380 1380,1740 1740,1920
{segfault -} in user code

517
00:16:39,680 --> 00:16:41,630
0,480 480,600 600,1260 1440,1770 1770,1950
before,| you know typically what
|通常在 segfault 中发生的情况是

518
00:16:41,630 --> 00:16:42,500
0,300 300,360 360,420 420,660 660,870
happens in the {segfault -}

519
00:16:42,500 --> 00:16:44,030
0,120 120,480 480,930 930,1410 1410,1530
is| basically application stops and
|应用程序停止和崩溃，

520
00:16:44,030 --> 00:16:45,920
0,570 840,1050 1050,1320 1320,1410 1410,1890
crashes,| but if the application
|但是如果应用程序安装了处理程序，

521
00:16:45,920 --> 00:16:48,520
0,270 270,990 1020,1650 1650,2100
had installed a handler|
|

522
00:16:48,550 --> 00:16:50,260
0,330 330,750 750,960 960,1260 1260,1710
for {you,know} {segfault -} event
对于 segfault 事件或 segfault 信号，

523
00:16:50,410 --> 00:16:53,020
0,270 270,660 990,1560 1590,2250 2310,2610
or segfault signal,| then instead
|那么不是停止应用程序，

524
00:16:53,020 --> 00:16:54,790
0,60 60,120 120,600 600,1080 1200,1770
of the application being stopped,|
|

525
00:16:54,880 --> 00:16:55,960
0,300 300,720 720,840 840,930 930,1080
the handler would have been
而是处理程序被内核调用，

526
00:16:55,960 --> 00:16:57,700
0,660 840,1020 1020,1110 1110,1620 1620,1740
called by the kernel,| and
|然后应用程序可能会响应该特定的 segfault ，

527
00:16:57,700 --> 00:16:58,780
0,120 120,210 210,720 720,810 810,1080
then the application can maybe

528
00:16:58,780 --> 00:17:01,000
0,600 810,930 930,1080 1080,1770 1800,2220
respond to that particular segfault,|
|

529
00:17:01,000 --> 00:17:01,930
0,150 150,240 240,570 570,810 810,930
in the same way in
以内核响应页面错误的同样的方式，

530
00:17:01,930 --> 00:17:03,100
0,180 180,480 480,690 690,780 780,1170
some sense that the kernel

531
00:17:03,100 --> 00:17:04,870
0,510 510,840 1020,1170 1170,1440 1440,1770
responds to a page fault|
|

532
00:17:04,870 --> 00:17:06,430
0,180 180,780 810,1200 1200,1350 1350,1560
and maybe fixes up the
可能还会修复页表，

533
00:17:06,430 --> 00:17:07,940
0,240 240,570 570,720 720,1140
page table,| so that
|这样可以继续执行，

534
00:17:07,940 --> 00:17:09,890
0,600 600,690 690,840 840,1230 1290,1950
{} you know the execution

535
00:17:09,890 --> 00:17:10,820
0,120 120,570 570,750 750,810 810,930
can continue| and in this
|在这种情况下，也许处理程序会调用 mprotect ，

536
00:17:10,820 --> 00:17:12,020
0,300 300,570 570,660 660,1050 1050,1200
case, maybe the handler will

537
00:17:12,020 --> 00:17:14,180
0,420 420,900 1110,1350 1350,1800 1800,2160
actually call {mprotect -}| or
|或修改权限，

538
00:17:14,270 --> 00:17:15,800
0,150 150,540 810,1200 1200,1470 1470,1530
{ - -} change the

539
00:17:15,800 --> 00:17:17,450
0,660 690,900 900,1080 1080,1440 1440,1650
permissions,| so that actually the
|这样指令就可以恢复并继续。

540
00:17:17,450 --> 00:17:19,220
0,540 540,720 720,1230 1230,1350 1350,1770
instruction can resumed and continue.|
|

541
00:17:21,010 --> 00:17:23,040
0,330 330,720 750,1260
{} And, {}
在这件事上，

542
00:17:23,880 --> 00:17:24,930
0,270 270,360 360,570 570,660 660,1050
so in this in fact,|
|

543
00:17:24,930 --> 00:17:25,860
0,60 60,210 210,420 420,570 570,930
you know you are the
我们最熟悉的版本，

544
00:17:26,130 --> 00:17:28,440
0,390 390,1260 1470,1950 1950,2100 2100,2310
most familiar version that we

545
00:17:28,440 --> 00:17:29,370
0,180 180,450 450,600 600,720 720,930
were,| the things that we've
|我们所看到的 sigaction ，比如 sigalarm ，

546
00:17:29,370 --> 00:17:31,140
0,540 540,900 900,1080 1080,1320 1320,1770
seen like a {sigaction -}

547
00:17:31,140 --> 00:17:32,340
0,210 210,390 390,570 570,690 690,1200
much like {sigalarm - -},|
|

548
00:17:32,870 --> 00:17:34,100
0,210 210,300 300,660 660,840 840,1230
as {Amir -} {} mentioned
就像 Amir 之前提到的，

549
00:17:34,100 --> 00:17:35,600
0,60 60,210 210,300 300,930 1230,1500
a little bit earlier {},|
|

550
00:17:35,600 --> 00:17:37,520
0,240 240,480 480,810 810,1230 1260,1920
in this {sigalarm -} lab,|
在 sigalarm 实验中，|

551
00:17:37,520 --> 00:17:39,590
0,360 600,1200 1200,1350 1350,1470 1470,2070
where {} you could install
你可以安装 alarm 程序，

552
00:17:39,650 --> 00:17:43,010
0,510 1320,1860 1950,2460 2460,2790 2790,3360
the alarm program,| basically installed
|安装一个处理程序，

553
00:17:43,220 --> 00:17:44,450
0,360 360,810 810,960 960,1080 1080,1230
a handler,| that will have
|它在每个时钟周期调用，

554
00:17:44,450 --> 00:17:45,470
0,90 90,180 180,690 690,780 780,1020
to be called at every

555
00:17:45,470 --> 00:17:46,940
0,330 330,600 630,900 900,1320 1320,1470
clock tick| or every you
|或每个时间段调用，

556
00:17:46,940 --> 00:17:49,070
0,210 480,840 840,900 900,1440 1650,2130
know period of time {},|
|

557
00:17:49,430 --> 00:17:50,570
0,390 390,540 540,630 630,960 960,1140
and you know basically {sigaction
基本上， sigaction 在某种程度上等同于，

558
00:17:50,570 --> 00:17:51,980
0,420 420,510 510,660 660,720 720,1410
-} is sort of the

559
00:17:51,980 --> 00:17:53,720
0,450 450,750 750,1020 1020,1380 1380,1740
equivalent that,| the general version
|可以对不同类型的信号做出反应。

560
00:17:53,720 --> 00:17:55,160
0,120 120,450 450,750 750,1140 1140,1440
of it where basically can

561
00:17:55,540 --> 00:17:57,190
0,600 600,660 660,930 930,1440 1470,1650
respond to different types of

562
00:17:57,190 --> 00:17:58,260
0,570
signals.|
|

563
00:17:59,170 --> 00:18:00,840
0,240 240,540 540,720 720,1050
Any questions about this?|
关于这个，有什么问题吗？|

564
00:18:02,780 --> 00:18:04,400
0,390 420,570 570,930 930,1260 1410,1620
{} It seems like {mprotect
这里像是 mprotect 实现了，

565
00:18:04,400 --> 00:18:06,410
0,510 510,1230 1230,1470 1470,1620 1620,2010
-} implies that| you can
|你可以在各个地址上添加不同的权限级别，

566
00:18:06,410 --> 00:18:08,090
0,390 390,810 810,1170 1170,1500 1500,1680
add different permission levels on

567
00:18:08,090 --> 00:18:11,120
0,600 600,1380 1410,2010 2040,2460 2460,3030
individual addresses| whereas in {like,xv6}
|而在我们一直在使用的 xv6 中，

568
00:18:11,120 --> 00:18:12,080
0,120 120,240 240,330 330,660 660,960
that we've been working with,|
|

569
00:18:12,110 --> 00:18:13,100
0,300 300,390 390,540 540,750 750,990
{} you can only apply
你只能在整页上应用权限，

570
00:18:13,100 --> 00:18:14,810
0,450 450,720 720,1080 1080,1560 1560,1710
permissions on full pages,| is
|那是不同的， mprotect 。

571
00:18:14,810 --> 00:18:16,130
0,300 300,690 690,900 900,1050 1050,1320
that {} is that a

572
00:18:16,160 --> 00:18:17,860
0,480 480,780 780,990 990,1200
difference, that's {mprotect -}.|
|

573
00:18:17,860 --> 00:18:19,150
0,300 300,390 390,570 570,750 750,1290
No, it's not real difference,|
不，这不是真正的不同，|

574
00:18:19,150 --> 00:18:21,460
0,690 720,1560 1560,1830 1830,1920 1920,2310
{} {you,know,it} works at a
它是在页面级别的粒度上工作的，

575
00:18:21,460 --> 00:18:23,300
0,300 300,570 570,1290
page level granularity,|
|

576
00:18:24,400 --> 00:18:26,440
0,390 960,1170 1170,1440 1440,1950 1950,2040
and it doesn't expose,| you
而且它不会暴露，|有一个单独的调用来找出页面的大小，

577
00:18:26,440 --> 00:18:27,400
0,150 150,390 390,420 420,720 720,960
know there's a separate call

578
00:18:27,400 --> 00:18:28,030
0,90 90,330 330,420 420,540 540,630
to find out what the

579
00:18:28,030 --> 00:18:30,310
0,390 420,900 900,1530 1590,1860 1860,2280
page page sizes,| if you
|如果你好奇的话。

580
00:18:30,310 --> 00:18:31,840
0,270 270,570 570,810 810,960
actually curious about it.|
|

581
00:18:33,630 --> 00:18:34,680
0,210 210,570
Thank you.|
谢谢。|

582
00:18:35,440 --> 00:18:36,550
0,570 660,810 810,870 870,930 930,1110
Um, so if you think
所以如果你想一想论文中的原语，

583
00:18:36,550 --> 00:18:38,500
0,270 270,1290 1290,1650 1650,1770 1770,1950
about the primitives that were

584
00:18:38,500 --> 00:18:39,250
0,60 60,120 120,570 570,660 660,750
in the paper,| you know
|我们可以把它们映射起来，

585
00:18:39,250 --> 00:18:40,600
0,90 90,360 360,630 630,810 810,1350
we can map them correctly,|
|

586
00:18:40,600 --> 00:18:42,040
0,210 210,420 420,780 780,1200 1200,1440
like what currently Unix or
比如现代 Unix 或Unix 通常提供的。

587
00:18:42,040 --> 00:18:43,980
0,240 240,570 570,990 990,1410
Unix typically provide.| So,
|那么， Trap 对应的是什么，

588
00:18:43,980 --> 00:18:46,050
0,300 510,1170 1170,1350 1350,1440 1440,2070
what equivalent correct to Trap,|
|

589
00:18:46,080 --> 00:18:47,310
0,150 150,240 240,390 390,1020 1020,1230
you know that we're {}
在 Unix 中会提供的

590
00:18:47,310 --> 00:18:48,780
0,270 270,480 480,720 720,1200 1200,1470
{in,Unix} would be provided| something
|就是 sigaction 调用。

591
00:18:48,780 --> 00:18:50,190
0,360 360,630 630,840 840,1050 1050,1410
called the {} {sigaction -}

592
00:18:50,190 --> 00:18:52,000
0,270 270,750 750,1140
{sigaction -} call.|
|

593
00:18:53,850 --> 00:18:54,930
0,240 240,540 540,690 690,780 780,1080
And about you know {ProtN
关于 ProtN 和 Prot1 ，

594
00:18:54,930 --> 00:18:59,040
0,390 390,570 570,780 780,1140 3870,4110
-} and {Prot1 -},| what
|它们相当于什么？

595
00:18:59,040 --> 00:19:00,180
0,60 60,210 210,630 630,720 720,1140
is the equivalent to that?|
|

596
00:19:01,310 --> 00:19:02,280
0,60

597
00:19:06,680 --> 00:19:07,820
0,210 210,420 420,750 750,960 960,1140
Okay, so basically all three
好的，这三个都可以使用 mprotect 来实现，

598
00:19:07,820 --> 00:19:09,740
0,90 90,270 270,630 750,1800 1800,1920
of them correctly can be

599
00:19:09,740 --> 00:19:11,880
0,420 420,660 660,810 810,1560
implemented using {mprotect -},|
|

600
00:19:14,550 --> 00:19:16,260
0,510 510,990 990,1080 1080,1320 1320,1710
and mprotect you know is
而且 mprotect 非常灵活，

601
00:19:16,260 --> 00:19:17,310
0,480 480,720 720,840 840,960 960,1050
flexible enough,| that you could
|你可以在一页上使用它，

602
00:19:17,310 --> 00:19:18,300
0,90 90,180 180,540 570,720 720,990
do it by a single

603
00:19:18,300 --> 00:19:20,880
0,510 540,1020 1020,1350 1680,2190 2190,2580
page| or actually just ask
|或者你可以提供由多个页面组成的内容，

604
00:19:21,060 --> 00:19:22,500
0,420 420,510 510,600 600,960 960,1440
or you can actually provide

605
00:19:22,500 --> 00:19:24,090
0,240 240,540 540,780 780,1170 1170,1590
something consists of multiple pages|
|

606
00:19:24,090 --> 00:19:24,840
0,120 120,270 270,360 360,480 480,750
and then you could do,
然后你可以得到刷新一次 TLB 的好处，

607
00:19:24,840 --> 00:19:25,740
0,270 300,480 480,600 600,690 690,900
{} you get the same

608
00:19:25,740 --> 00:19:27,690
0,420 420,480 480,930 930,1380 1380,1950
benefit of one TLB flush,|
|

609
00:19:27,780 --> 00:19:30,210
0,840 990,1410 1410,1830 1830,2340 2340,2430
for {} changing permissions on
用于更改一系列页面上的权限。

610
00:19:30,210 --> 00:19:32,580
0,60 60,1320 1440,1830 1830,1890 1890,2370
a whole series of pages.|
|

611
00:19:34,300 --> 00:19:36,020
0,1230
Okay?|
好吧？|

612
00:19:36,140 --> 00:19:37,640
0,240 240,510 510,660 660,1170 1170,1500
These calls are almost directly
这些调用可以直接映射到一些原语中，

613
00:19:37,640 --> 00:19:38,420
0,270 270,480 480,630 630,690 690,780
map into some of the

614
00:19:38,420 --> 00:19:41,090
0,660 990,1530 1890,2220 2220,2400 2400,2670
primitives,| {} turns out that
|Dirty 有点难做到，

615
00:19:41,090 --> 00:19:42,500
0,150 150,420 450,1080 1080,1380 1380,1410
you know dirty, actually a

616
00:19:42,500 --> 00:19:43,490
0,150 150,270 270,510 510,600 600,990
little bit harder to do,|
|

617
00:19:43,580 --> 00:19:44,720
0,630 630,690 690,750 750,900 900,1140
{} you know there's not
没有直接对应的原语或系统调用，

618
00:19:44,720 --> 00:19:46,520
0,60 60,690 690,1080 1080,1560 1620,1800
a direct primitive for or

619
00:19:46,520 --> 00:19:47,960
0,300 300,510 510,900 960,1290 1290,1440
system call for,| although you
|尽管你可以用一些技巧来完成它。

620
00:19:47,960 --> 00:19:49,580
0,90 90,270 270,480 480,1170 1290,1620
can sort of {} more

621
00:19:49,580 --> 00:19:50,270
0,60 60,210 210,330 330,420 420,690
or less get it done

622
00:19:50,270 --> 00:19:51,830
0,180 180,360 360,840 1020,1440 1440,1560
with some tricks.| And I'll
|稍后我会稍微谈一下 Map2 ，

623
00:19:51,830 --> 00:19:52,610
0,180 180,240 240,420 420,540 540,780
talk a little bit later

624
00:19:52,610 --> 00:19:54,000
0,240 240,480 480,960
about {Map2 -},|
|

625
00:19:54,190 --> 00:19:56,560
0,300 300,510 510,690 690,1230 1620,2370
{} there's also {} a
也有办法做到这个，

626
00:19:56,620 --> 00:19:57,490
0,330 330,420 420,570 570,720 720,870
way to do it,| but
|但是并不完全是

627
00:19:57,490 --> 00:19:58,690
0,120 120,450 450,960 960,1050 1050,1200
it's not completely| you know
|一种直接对应 Map2 的系统调用，

628
00:19:58,690 --> 00:19:59,710
0,180 180,270 270,450 450,750 750,1020
sort of a system call

629
00:19:59,710 --> 00:20:01,180
0,180 180,600 600,930 930,1230 1230,1470
just directly maps onto {Map2

630
00:20:01,180 --> 00:20:02,590
0,270 540,750 750,1020 1020,1230 1230,1410
-},| it turns out that
|如果你有多个 mmap ，

631
00:20:02,590 --> 00:20:05,470
0,150 150,510 660,1440 1470,1980 1980,2880
if you with multiple mmaps,|
|

632
00:20:08,760 --> 00:20:10,700
0,180 180,300 300,540 540,1320
you can actually achieve
你也可以实现这个特定功能。

633
00:20:11,180 --> 00:20:14,210
0,360 360,600 600,1800 2010,2760 2760,3030
{} this particular functionality too.|
|

634
00:20:16,080 --> 00:20:18,120
0,570 900,1380 1560,1860 1860,1950 1950,2040
Okay?| So one way to
好吧？|所以，思考这篇论文的一种方式是，

635
00:20:18,120 --> 00:20:18,960
0,120 120,270 270,390 390,750 750,840
think about this paper is|
|

636
00:20:18,960 --> 00:20:21,420
0,570 600,870 870,1650 1740,2340 2340,2460
the kernel developers you know
内核开发人员可能并不完全受这篇文章的驱动，

637
00:20:21,420 --> 00:20:22,980
0,240 240,510 810,1140 1140,1410 1410,1560
maybe not totally driven by

638
00:20:22,980 --> 00:20:25,950
0,450 450,570 570,840 840,1380 1530,2970
{this,paper},| but kernel developers, {}
|但是内核开发人员已经扩展了这些，

639
00:20:25,950 --> 00:20:27,840
0,90 90,360 570,1170 1170,1800 1800,1890
you know have extended you

640
00:20:27,840 --> 00:20:30,030
0,150 150,780 840,1620 1620,1920 1920,2190
know these,| {} where have
|已经提供了这些原语，

641
00:20:30,030 --> 00:20:31,800
0,390 390,540 540,1020 1020,1350 1350,1770
provided these primitives| actually to
|对今天的用户应用程序。

642
00:20:31,800 --> 00:20:33,510
0,450 690,840 840,900 900,1350 1350,1710
{} you know today's {}

643
00:20:33,510 --> 00:20:34,780
0,240 240,930
user applications.|
|

644
00:20:37,420 --> 00:20:38,500
0,270 270,300 300,480 480,540 540,1080
Okay, I want to say
好的，我想说一下关于实现的事情，

645
00:20:38,530 --> 00:20:40,180
0,180 180,480 480,990 990,1440 1440,1650
a few words about the

646
00:20:40,180 --> 00:20:42,460
0,840 840,1080 1080,1530 1560,2070 2070,2280
implementation,| just a much more
|只是更多的概述，

647
00:20:42,490 --> 00:20:45,670
0,870 870,1350 1680,2370 2370,2700 2700,3180
sketch level,| {} and then
|然后讨论一下应用程序本身，

648
00:20:45,700 --> 00:20:46,990
0,570 570,600 600,810 810,960 960,1290
talk a little bit about

649
00:20:46,990 --> 00:20:49,330
0,120 120,240 240,810 840,1740 1950,2340
you know the applications {}

650
00:20:49,330 --> 00:20:51,040
0,720 720,1080 1110,1380 1380,1560 1560,1710
themselves| and see how they
|看看他们是如何使用这些原语的。

651
00:20:51,040 --> 00:20:52,740
0,270 270,450 450,780 780,1320
use these particular primitives.|
|

652
00:21:00,700 --> 00:21:03,070
0,390 390,960 1110,1740 2040,2190 2190,2370
Okay, so {}, let's talk
好的，让我们来谈谈两个有趣的方面。

653
00:21:03,070 --> 00:21:04,510
0,180 180,570 570,810 810,1320 1320,1440
about there's two aspects that

654
00:21:04,510 --> 00:21:05,440
0,60 60,210 210,270 270,630 630,930
are sort of interesting.| One
|一个是发生了什么，

655
00:21:05,440 --> 00:21:06,970
0,90 90,300 300,600 600,900 900,1530
is actually what actually happens|
|

656
00:21:07,000 --> 00:21:08,560
0,570 570,630 630,930 930,1200 1200,1560
inside the virtual memory system
在虚拟内存系统中，来支持这一点。

657
00:21:08,560 --> 00:21:10,220
0,120 120,390 390,840 840,1170
to actually support this.|
|

658
00:21:14,620 --> 00:21:15,460
0,180 180,330 330,450 450,510 510,840
I'm just going to sketch
我只想把它概述出来，

659
00:21:15,460 --> 00:21:16,630
0,180 180,480 480,600 600,750 750,1170
this out,| like what the
|比如最重要的部分是什么，

660
00:21:16,660 --> 00:21:18,400
0,300 300,600 600,930 930,1350 1500,1740
most important pieces are,| and
|事实上，

661
00:21:18,400 --> 00:21:19,750
0,60 60,360 360,450 450,750 1080,1350
in fact you know| this
|这与即将到来的 mmap 实验有点相关，

662
00:21:19,750 --> 00:21:20,440
0,120 120,330 330,420 420,480 480,690
is sort of a little

663
00:21:20,440 --> 00:21:23,410
0,120 120,540 540,930 930,2190 2250,2970
bit relevant to {} {mmap,lab}

664
00:21:23,410 --> 00:21:24,850
0,240 240,330 330,600 600,930 960,1440
that is coming up,| because
|因为你要做类似的事情。

665
00:21:24,850 --> 00:21:25,600
0,90 90,210 210,270 270,390 390,750
you're going to do something

666
00:21:25,600 --> 00:21:28,870
0,360 390,840 840,1170 1470,2040 2790,3270
{} similar.| So {} address
|所以今天的 Unix 的地址空间，

667
00:21:28,870 --> 00:21:30,640
0,360 360,1020 1020,1110 1140,1470 1470,1770
space typically in {} Unix

668
00:21:30,640 --> 00:21:32,110
0,330 330,450 450,1020 1020,1350 1350,1470
today| is represented by you
|是由硬件页表来表示的，

669
00:21:32,110 --> 00:21:33,340
0,150 570,690 690,870 870,930 930,1230
know of course the hardware

670
00:21:33,340 --> 00:21:34,500
0,270 270,750
page table,|
|

671
00:21:34,770 --> 00:21:37,060
0,180 180,570 570,840 840,1740
which contains the translations,|
其中包含转换，|

672
00:21:37,160 --> 00:21:39,320
0,390 390,600 600,960 960,1470 1470,2160
{} but typically it's {}
但通常它是用一组操作系统数据结构扩充的，

673
00:21:39,350 --> 00:21:41,180
0,750 870,1170 1170,1200 1200,1440 1440,1830
augmented with a set of

674
00:21:41,210 --> 00:21:43,370
0,450 450,690 690,1380 1380,1830 1830,2160
OS data structure,| not related
|与任何特定的硬件设计无关，

675
00:21:43,370 --> 00:21:45,380
0,150 150,360 360,1020 1020,1440 1440,2010
to any specific hardware design,|
|

676
00:21:45,740 --> 00:21:47,960
0,300 300,780 780,870 870,1350 1650,2220
{} these are called {}
这些称为虚拟内存区，

677
00:21:48,050 --> 00:21:49,360
0,780
virtual,

678
00:21:49,360 --> 00:21:51,020
0,420 420,1050
virtual memory

679
00:21:54,140 --> 00:21:55,460
0,720
areas,|
|

680
00:21:57,900 --> 00:22:00,100
0,270 270,780 780,1020 1020,1650
in short {VMAs -}.|
简称为 VMA 。|

681
00:22:02,740 --> 00:22:04,690
0,420 420,570 570,900 930,1410 1410,1950
Basically, what {} VMA, what
基本上， VMA 代表的是

682
00:22:04,690 --> 00:22:08,050
0,330 330,1290 1860,2610 2610,2940 2940,3360
{VMA -} represents is| {you,know}
|记录一些关于连续地址范围的信息。

683
00:22:08,050 --> 00:22:10,720
0,570 570,1260 1290,2040 2130,2610 2610,2670
record some information about the

684
00:22:10,720 --> 00:22:12,980
0,540 540,960 960,1140 1140,1830
contiguous range of addresses.|
|

685
00:22:20,470 --> 00:22:21,490
0,240 240,330 330,570 570,780 780,1020
So if you think about
所以如果你考虑地址空间，

686
00:22:21,490 --> 00:22:22,980
0,60 60,360 360,930
an address space,|
|

687
00:22:22,980 --> 00:22:24,330
0,180 180,450 480,720 720,1110 1140,1350
{} it might have a
可能在地址空间中具有多个区段，

688
00:22:24,330 --> 00:22:25,590
0,300 300,390 390,1050 1050,1170 1170,1260
number of sections in the

689
00:22:25,590 --> 00:22:26,640
0,330 330,720 720,780 780,870 870,1050
address space,| you know each
|每个连续的范围，

690
00:22:26,640 --> 00:22:28,650
0,390 570,990 990,1500 1500,1860 1860,2010
one contiguous range,| basically for
|每个部分都是 VMA 。

691
00:22:28,650 --> 00:22:30,240
0,180 180,780 840,1080 1080,1260 1260,1590
each section that would be

692
00:22:30,240 --> 00:22:31,640
0,300 300,540 540,870
{} {VMA -}.|
|

693
00:22:31,760 --> 00:22:33,920
0,390 390,810 810,1170 1170,1560 1560,2160
And the VMA you know
VMA 可能具有所有相同的权限，

694
00:22:34,760 --> 00:22:36,200
0,330 330,480 480,720 720,960 960,1440
{} may also has all

695
00:22:36,530 --> 00:22:38,150
0,150 150,420 420,990 1050,1410 1410,1620
the same permissions| through all
|那个范围的所有页面有相同的权限，

696
00:22:38,150 --> 00:22:39,830
0,90 90,510 510,600 600,870 900,1680
the pages in that range

697
00:22:39,890 --> 00:22:41,540
0,240 240,300 300,510 510,1200
at the same permissions,|
|

698
00:22:43,540 --> 00:22:45,250
0,150 150,330 330,930 960,1590 1590,1710
and they're backed by the
它们背后都是同一个对象。

699
00:22:45,250 --> 00:22:46,900
0,450 450,1110
same object.|
|

700
00:22:55,010 --> 00:22:56,810
0,150 150,690 690,1500 1500,1650 1650,1800
For example, if you have
比如，如果你有 mmap 文件

701
00:22:56,810 --> 00:22:59,360
0,60 60,660 780,1260 1260,2220 2400,2550
a mmap map map, {mmap

702
00:22:59,360 --> 00:23:02,210
0,270 270,840 960,1710 1710,1710 1710,2850
-} file,| then, {} the
|然后，文件的 VMA 描述该文件的任何权限，

703
00:23:02,900 --> 00:23:04,370
0,540 540,780 780,930 930,1080 1080,1470
{be,VMA -} for that file

704
00:23:04,370 --> 00:23:07,880
0,120 120,750 750,1200 2040,2580 2580,3510
that describes whatever permissions for

705
00:23:07,910 --> 00:23:09,950
0,240 240,750 870,1140 1140,1590 1590,2040
the file| as well as
|同文件本身的信息一样，

706
00:23:09,950 --> 00:23:11,570
0,120 120,270 270,540 540,1110 1110,1620
you know the information about

707
00:23:11,570 --> 00:23:12,680
0,90 90,270 270,720 720,900 900,1110
the file itself,| the file
|比如，与 VMA 在一起的文件描述符，

708
00:23:12,680 --> 00:23:14,300
0,420 420,480 480,1020 1080,1380 1380,1620
descriptor, for example, {} that

709
00:23:14,300 --> 00:23:15,530
0,180 180,570 570,720 720,840 840,1230
goes along with that particular

710
00:23:15,530 --> 00:23:18,110
0,210 210,630 930,2280 2310,2490 2490,2580
{VMA -}| and you know
|而且文件中的偏移量也是 VMA 对应的。

711
00:23:18,110 --> 00:23:19,220
0,90 90,570 570,660 660,750 750,1110
the offset in the file

712
00:23:19,220 --> 00:23:20,660
0,630 660,1080
were {}

713
00:23:20,660 --> 00:23:22,640
0,450 450,660 660,1290 1320,1830 1830,1980
that {VMA -} corresponds to.|
|

714
00:23:24,220 --> 00:23:25,360
0,450 480,690 690,900 900,990 990,1140
{} In fact you know
事实上，即将到来的实验里，

715
00:23:25,360 --> 00:23:27,220
0,270 270,720 750,1140 1140,1530 1530,1860
in the lab upcoming lab,|
|

716
00:23:27,220 --> 00:23:28,630
0,90 90,210 210,360 360,780 780,1410
you know you will implement
你将实现一个非常简单的 VMA 版本，

717
00:23:28,630 --> 00:23:30,550
0,30 30,270 270,570 570,1200 1380,1920
a very simple version {}

718
00:23:30,550 --> 00:23:32,680
0,510 810,1350 1350,1530 1530,1740 1740,2130
of VMA| and use that
|并使用它来实现对于文件的 mmap 系统调用，

719
00:23:32,680 --> 00:23:35,080
0,180 180,480 480,1140 1170,1860
to actually implement {}

720
00:23:36,550 --> 00:23:38,110
0,120 120,570 600,720 720,990 990,1560
{mmap -} {} system call

721
00:23:38,110 --> 00:23:39,190
0,150 150,510 510,660 660,990 990,1080
for files,| where basically you
|你可以在 VMA 中记录，

722
00:23:39,190 --> 00:23:40,330
0,210 210,570 570,720 720,870 870,1140
can record in the {VMA

723
00:23:40,330 --> 00:23:41,440
0,210 210,390 390,510 510,1020 1020,1110
-},| you are literally the
|文件描述符和偏移量，

724
00:23:41,440 --> 00:23:42,850
0,210 210,720 720,810 810,900 900,1410
file descriptor and the offset|
|

725
00:23:43,240 --> 00:23:44,290
0,150 150,360 360,840 840,900 900,1050
{} that corresponds to that
对应特定的 mmap 调用，已经映射的范围。

726
00:23:44,290 --> 00:23:45,670
0,390 390,510 510,780 780,1110 1290,1380
particular {mmap -} call, the

727
00:23:45,670 --> 00:23:48,120
0,450 510,690 690,870 870,1230
range have been mapped.|
|

728
00:23:49,460 --> 00:23:51,040
0,180 180,510 510,690 690,1020
Any questions about this?|
对于这个，有什么问题吗？|

729
00:23:56,900 --> 00:23:58,160
0,270 270,420 420,570 570,780 780,1260
Okay, so then the second
好的，那么第二个重要的部分，

730
00:23:58,160 --> 00:23:59,450
0,420 420,510 510,810 990,1230 1230,1290
piece you know sort of

731
00:23:59,450 --> 00:24:00,890
0,720 720,930 930,1230 1230,1350 1350,1440
important| and then we have
|我们有一点经验，

732
00:24:00,890 --> 00:24:01,940
0,60 60,240 240,330 330,510 540,1050
a little bit of experience

733
00:24:01,940 --> 00:24:03,620
0,210 210,510 510,930 960,1560 1560,1680
with,| it's probably worthwhile you
|这可能是值得的经历的是，

734
00:24:03,620 --> 00:24:05,810
0,660 870,1110 1110,1380 1380,1680 1830,2190
know going through is| actually
|Trap 或 sigaction 处理程序是如何，

735
00:24:05,810 --> 00:24:07,850
0,540 570,1140 1140,1260 1260,1470 1470,2040
how trap or {sigaction -}

736
00:24:10,680 --> 00:24:12,340
0,390 390,480 480,1170
actually the handler,|
|

737
00:24:12,780 --> 00:24:13,770
0,270 270,360 360,600 600,870 870,990
how an actual Trap will
实际的 Trap 是如何工作的。

738
00:24:13,770 --> 00:24:14,740
0,480
work.|
|

739
00:24:16,900 --> 00:24:18,760
0,540 720,1080 1080,1200 1200,1350 1350,1860
Actually, you'll be more careful.|
实际上，你需要更小心。|

740
00:24:21,190 --> 00:24:21,940
0,210 210,300 300,420 420,480 480,750
So we have a user
所以我们实现了一个用户级别的 trap ，

741
00:24:21,940 --> 00:24:23,520
0,240 240,810
level traps

742
00:24:23,850 --> 00:24:25,440
0,210 210,900
are implemented,|
|

743
00:24:27,320 --> 00:24:29,300
0,180 180,510 510,1350 1350,1770 1770,1980
and this follows very, it
这是非常符合，

744
00:24:29,300 --> 00:24:30,650
0,300 300,600 600,990 990,1170 1170,1350
follows very much| you know
|与 sigalarm 系统调用的大纲是一样的，

745
00:24:30,650 --> 00:24:34,580
0,780 1200,2220 2220,3180 3180,3570 3570,3930
the same outline as actually

746
00:24:34,580 --> 00:24:36,140
0,330 330,510 510,870 870,1170 1170,1560
the {sigalarm -} system call|
|

747
00:24:36,140 --> 00:24:37,880
0,180 180,600 690,1020 1020,1230 1230,1740
and then the up call
然后，当时钟周期到达时，

748
00:24:38,150 --> 00:24:39,200
0,150 150,390 390,750 750,990 990,1050
{} that happened when a

749
00:24:39,200 --> 00:24:40,580
0,360 360,570 570,1140 1140,1380 1380,1380
clock tick,| actually { -}
|已经[超过]了时间限制。

750
00:24:42,550 --> 00:24:44,240
0,390 390,510 510,780 780,1140
[passed] the time limit.|
|

751
00:24:44,360 --> 00:24:45,380
0,180 180,480 600,810 810,960 960,1020
And so the sort of
所以这里的设置是

752
00:24:45,380 --> 00:24:46,820
0,270 270,570 570,870 870,1110 1110,1440
setting here is| not not
|不是时钟周期，而是页表，

753
00:24:46,820 --> 00:24:47,900
0,90 90,210 210,480 480,750 750,1080
you know clock ticks but

754
00:24:47,900 --> 00:24:49,160
0,240 240,630 630,810 810,990 990,1260
page tables,| so let's assume
|所以让我们假设有一些 PTE ，

755
00:24:49,160 --> 00:24:50,690
0,240 240,420 420,750 750,1140 1170,1530
there's some { -} {PTE

756
00:24:50,690 --> 00:24:53,420
0,390 870,1290 1290,1470 1470,2220 2220,2730
-} {}| that {has,that} marked
|标记为无效的，

757
00:24:55,500 --> 00:24:57,340
0,120 120,240 240,480 480,1260
you know in invalid|
|

758
00:24:58,420 --> 00:24:59,590
0,150 150,480 480,660 660,960 960,1170
or maybe it's {} read
或者它可能是只读的，

759
00:24:59,590 --> 00:25:01,180
0,570 570,780 780,990 990,1200 1200,1590
only| and you're actually stored
|而你在保存到其中，

760
00:25:01,180 --> 00:25:02,320
0,120 120,360 390,540 540,900 930,1140
to it| and so what
|那么，当应用程序访问这个 PTE 时，会发生什么，

761
00:25:02,320 --> 00:25:05,260
0,510 510,810 810,900 900,1590 2400,2940
happens when the application accesses

762
00:25:05,260 --> 00:25:07,120
0,210 210,810 810,1140 1140,1710 1710,1860
that PTE,| that actually is
|实际上是无效的，

763
00:25:07,120 --> 00:25:09,010
0,360 360,900 900,990 990,1530 1530,1890
basically invalid| or doesn't result
|或者没有产生有效的转换。

764
00:25:09,010 --> 00:25:11,290
0,90 90,510 540,840 840,1560 1650,2280
in a valid translation.| Well
|正如我们所知，

765
00:25:12,100 --> 00:25:13,180
0,210 210,360 360,720 720,990 990,1080
as we know,| then the
|CPU 跳转到内核模式，

766
00:25:13,180 --> 00:25:14,340
0,660
CPU

767
00:25:14,520 --> 00:25:16,050
0,120 120,540 540,720 720,990 990,1530
{} jumps into kernel mode,|
|

768
00:25:20,290 --> 00:25:21,910
0,330 330,480 480,540 540,1170 1380,1620
jumps into the kernel {}
跳入内核的固定地址，

769
00:25:21,910 --> 00:25:22,960
0,180 180,240 240,480 480,960 960,1050
at a fixed address,| you
|想想 trampoline 代码，

770
00:25:22,960 --> 00:25:24,610
0,300 300,780 810,1140 1140,1200 1200,1650
know {you,know} look at the

771
00:25:24,880 --> 00:25:26,740
0,300 300,390 390,870 870,1350 1500,1860
think the trampoline code {},|
|

772
00:25:26,740 --> 00:25:29,260
0,120 120,780 1020,1320 1320,1920
the kernel save state,|
内核保存状态，|

773
00:25:30,430 --> 00:25:32,230
0,150 150,240 240,630 630,990 990,1800
so, for example {save,to} trapframe,|
比如保存到 trapframe ，|

774
00:25:35,350 --> 00:25:37,900
0,660 720,990 990,1350 1350,2040
{} then basically asks
然后访问虚拟内存系统，

775
00:25:37,900 --> 00:25:39,190
0,90 90,210 210,300 300,660 660,1290
you know the VM system,|
|

776
00:25:40,820 --> 00:25:42,200
0,150 150,300 300,780
and what now,
现在做什么。

777
00:25:44,450 --> 00:25:45,700
0,240 240,300 300,660
what to do.|
|

778
00:25:47,430 --> 00:25:48,870
0,420 420,510 510,780 780,1230 1230,1440
And the VM system might
虚拟内存系统可能会温和地执行某些操作，

779
00:25:48,870 --> 00:25:50,070
0,90 90,390 390,570 570,1080 1080,1200
do something so gently| and
|如果这种情况发生在懒分配实验，

780
00:25:50,070 --> 00:25:51,360
0,120 120,420 420,600 600,930 930,1290
in case if this happened

781
00:25:51,360 --> 00:25:53,400
0,150 150,600 960,1500 1500,1860 1860,2040
in the lazy lab| and
|以及写入时复制实验，

782
00:25:53,400 --> 00:25:54,600
0,180 180,450 450,810 810,930 930,1200
in the {copy-on-write - -}

783
00:25:54,600 --> 00:25:56,610
0,450 510,1230 1230,1350 1350,1470 1470,2010
lab,| where you know your
|你的 trap 处理程序代码，

784
00:25:56,940 --> 00:25:58,530
0,390 390,690 690,1020 1020,1170 1170,1590
trap handler code,| you know
|查看页表数据结构，

785
00:25:58,530 --> 00:25:59,580
0,180 180,300 300,480 480,570 570,1050
sort of looks at the

786
00:25:59,610 --> 00:26:00,900
0,390 390,630 630,990 990,1140 1140,1290
{page,table} data structures,| in this
|在这种情况下，将查看 VMA ，

787
00:26:00,900 --> 00:26:01,890
0,210 210,570 570,720 720,900 900,990
case, resume will look at

788
00:26:01,890 --> 00:26:03,120
0,60 60,780
the VMAs,|
|

789
00:26:03,120 --> 00:26:05,010
0,570 780,960 960,1590 1590,1830 1830,1890
and {you,know} see what the
查看范围是什么，

790
00:26:05,010 --> 00:26:06,450
0,300 300,450 450,690 690,1020 1020,1440
scope is| just to address
|进程[折叠]的地址，

791
00:26:06,450 --> 00:26:09,720
0,180 180,1050 2490,2730 2730,2820 2820,3270
that were where the process

792
00:26:09,720 --> 00:26:11,820
0,360 360,690 840,1560 1560,1920 1920,2100
[folded] on| and {} see
|看看需要做些什么，

793
00:26:11,820 --> 00:26:12,720
0,150 150,360 360,450 450,510 510,900
what needs to be done,|
|

794
00:26:12,720 --> 00:26:13,590
0,210 210,300 300,360 360,750 750,870
and so for example if
比如，如果它是 segfault ，

795
00:26:13,590 --> 00:26:14,760
0,300 300,390 390,480 480,720 720,1170
it is a {segfault -}|
|

796
00:26:14,760 --> 00:26:15,900
0,540
and
并且应用程序已经安装了处理程序来处理它，

797
00:26:16,230 --> 00:26:18,330
0,600 600,750 750,1320 1320,1650 1650,2100
application has installed {} handler

798
00:26:18,330 --> 00:26:19,350
0,150 150,420 420,540 540,690 690,1020
to deal with it,| then
|那么向上调用，

799
00:26:19,410 --> 00:26:21,630
0,600 600,930 960,1320 1320,1770 1800,2220
basically that up call| or
|或事件处理程序将传播到用户空间。

800
00:26:21,810 --> 00:26:23,640
0,330 330,780 780,900 900,1440 1440,1830
a handler of the event

801
00:26:23,640 --> 00:26:24,720
0,120 120,240 240,750 750,840 840,1080
would be propagated to user

802
00:26:24,720 --> 00:26:25,640
0,450
space.|
|

803
00:26:25,760 --> 00:26:27,230
0,150 150,300 300,930 960,1290 1290,1470
And so basically let's say
所以，我们假设安装了一个处理程序，

804
00:26:27,230 --> 00:26:28,700
0,180 180,450 450,750 750,1020 1020,1470
there was a handler installed,|
|

805
00:26:28,700 --> 00:26:29,960
0,270 270,630 630,750 750,930 930,1260
then basically we're gonna get
然后我们就可以向上调用进入用户空间，

806
00:26:29,960 --> 00:26:32,210
0,180 180,660 1110,1500 1500,1950 1950,2250
up call {} to into

807
00:26:32,210 --> 00:26:33,560
0,270 270,870
user space,|
|

808
00:26:35,880 --> 00:26:36,900
0,180 180,240 240,570 570,810 810,1020
in the same way as
像 sigalarm 实验的方法一样，

809
00:26:36,900 --> 00:26:39,390
0,180 180,510 1410,1740 1740,1950 1950,2490
in the {sigalarm -} lab,|
|

810
00:26:39,540 --> 00:26:40,800
0,660 660,780 780,870 870,1080 1080,1260
{} you know that will
它将在用户空间中运行处理程序，

811
00:26:40,800 --> 00:26:43,300
0,600 840,1080 1080,1230 1230,1860
run {you,know} the handler

812
00:26:43,740 --> 00:26:45,270
0,180 180,420 420,900 900,1020 1020,1530
in user space,| the handler
|这个处理程序可能会调用 mprotect 来改变保护位。

813
00:26:45,270 --> 00:26:46,770
0,150 150,480 480,1050 1080,1140 1140,1500
{you,know} might call you know

814
00:26:46,770 --> 00:26:47,910
0,240 240,840 840,930 930,1050 1050,1140
{mprotect -} you know to

815
00:26:47,910 --> 00:26:49,980
0,390 390,780 810,1500
change the protections.|
|

816
00:26:52,540 --> 00:26:54,430
0,690 990,1230 1230,1470 1470,1560 1560,1890
And, {} then the handler
然后处理程序返回，

817
00:26:54,430 --> 00:26:56,080
0,360 360,420 420,990 990,1320 1320,1650
returns to,| user handler returns
|用户处理程序返回内核代码，

818
00:26:56,080 --> 00:26:57,520
0,90 90,390 390,870
to kernel code,|
|

819
00:27:00,290 --> 00:27:01,820
0,240 240,300 300,990
{to -} kernel,|
到达内核，|

820
00:27:03,920 --> 00:27:04,910
0,150 150,270 270,360 360,630 630,990
and then the kernel basically
然后内核恢复被打断的程序。

821
00:27:04,910 --> 00:27:06,300
0,780
resumes

822
00:27:07,660 --> 00:27:08,710
0,120 120,210 210,360 360,750 750,1050
you know the {interrupted -}

823
00:27:09,790 --> 00:27:10,920
0,540
process.|
|

824
00:27:15,180 --> 00:27:16,830
0,570 840,1110 1110,1200 1200,1500 1500,1650
Okay, and you have to,|
好的，而且你必须，|

825
00:27:16,830 --> 00:27:18,660
0,450 450,1080 1170,1440 1440,1500 1500,1830
if the, when the kernel
如果，当内核恢复中断进程时，

826
00:27:18,660 --> 00:27:20,160
0,450 450,570 570,900 900,960 960,1500
resumes that interrupt the process,|
|

827
00:27:20,160 --> 00:27:21,930
0,90 90,360 360,840 870,1590 1650,1770
you know if {for,example} the
比如，如果处理程序修复了用户程序的地址空间，

828
00:27:21,930 --> 00:27:23,070
0,360 360,690 690,870 870,1050 1050,1140
handler fixed up sort of

829
00:27:23,070 --> 00:27:24,750
0,90 90,750 750,1050 1050,1230 1230,1680
the address space of the

830
00:27:25,020 --> 00:27:26,700
0,360 360,870 900,1230 1230,1380 1380,1680
user program,| then they might
|那么指令可能会正确地执行，

831
00:27:26,700 --> 00:27:28,170
0,300 300,720 720,870 870,990 990,1470
actually instruction might use execute

832
00:27:28,170 --> 00:27:30,480
0,600 630,1230 1230,1860 1890,2190 2190,2310
correctly| or if something is
|或者如果出现问题，

833
00:27:30,480 --> 00:27:32,400
0,360 360,1050 1230,1530 1530,1770 1770,1920
wrong,| maybe trap back into
|可能会立即重新进入内核，

834
00:27:32,400 --> 00:27:33,510
0,90 90,360 360,540 540,720 720,1110
the kernel right away again,|
|

835
00:27:33,510 --> 00:27:34,800
0,240 270,420 420,540 540,840
if you know the,|
如果，|

836
00:27:34,800 --> 00:27:36,820
0,540 570,1470

837
00:27:36,820 --> 00:27:39,220
0,120 120,540 930,1500 1710,2190 2190,2400
if the the hardware still
如果硬件仍然无法转换那个特定虚拟地址。

838
00:27:39,220 --> 00:27:40,660
0,240 240,690 690,810 810,1140 1140,1440
can't translate that particular virtual

839
00:27:40,660 --> 00:27:41,580
0,390
address.|
|

840
00:27:42,920 --> 00:27:44,380
0,210 210,360 360,480 480,810
Does this make sense?|
这能理解吗？|

841
00:27:45,890 --> 00:27:47,320
0,270 270,450 450,960
Maybe there's, {}
再说一遍， sigalarm 实验，

842
00:27:48,190 --> 00:27:49,630
0,390 390,660 660,900 990,1290 1290,1440
remember again, the {sigalarm -}

843
00:27:49,630 --> 00:27:50,950
0,540 540,720 720,1020 1020,1200 1200,1320
lab| and then this would
|然后这个就很熟悉了。

844
00:27:50,950 --> 00:27:52,620
0,150 150,420 420,1080
be quite familiar.|
|

845
00:27:53,660 --> 00:27:55,160
0,330 330,660 660,840 840,900 900,1500
Yeah, I have a question.|
是的，我有个问题。|

846
00:27:57,140 --> 00:28:00,020
0,300 300,570 570,1050 1110,2280 2730,2880
What kind of,| {} I
那一种，|我想，当我们允许用户运行

847
00:28:00,020 --> 00:28:01,580
0,360 360,660 660,960 960,1470 1470,1560
think when we're allowing the

848
00:28:01,580 --> 00:28:03,770
0,480 480,630 630,1230 1230,1830 1950,2190
user to actually run| a
|在页面错误上的处理程序，

849
00:28:03,770 --> 00:28:05,660
0,540 540,1140 1170,1410 1410,1500 1500,1890
handler code on a page

850
00:28:05,750 --> 00:28:08,480
0,510 630,1020 1020,1320 1320,2160 2160,2730
fault,| aren't there additional security
|难道没有额外的安全漏洞，

851
00:28:08,480 --> 00:28:10,160
0,930 930,1080 1080,1260 1260,1590 1590,1680
vulnerabilities,| that could result as
|可能会导致这一点，

852
00:28:10,160 --> 00:28:10,760
0,60 60,240 240,300 300,510 510,600
a part of this,| so
|所以我想知道能不能谈谈这件事。

853
00:28:10,760 --> 00:28:11,390
0,30 30,120 120,360 360,480 480,630
I was wondering if it

854
00:28:11,390 --> 00:28:13,040
0,270 300,690 690,810 810,1170 1170,1650
could speak to that.| Yeah,
|是的，这是个好问题，

855
00:28:13,040 --> 00:28:14,360
0,120 120,180 180,360 360,930
it's a great question,|
|

856
00:28:14,360 --> 00:28:16,340
0,360 870,1470 1470,1620 1620,1770 1770,1980
{} {by,the,way},| {can,you} like maybe
顺便说一句，|能不能每个人都把摄像头打开，

857
00:28:16,340 --> 00:28:18,410
0,420 420,660 660,1230 1380,1530 1530,2070
everybody turn on their cameras

858
00:28:18,410 --> 00:28:19,540
0,120 120,570
too, {}|
|

859
00:28:20,770 --> 00:28:22,450
0,360 360,900 930,1080 1080,1290 1290,1680
if possible,| if you're comfortable
如果可能的话，|如果你愿意这么做，

860
00:28:22,450 --> 00:28:23,890
0,210 210,510 510,600 600,870 990,1440
doing that,| I really appreciate
|我会很感激。

861
00:28:23,890 --> 00:28:25,060
0,270 270,300 300,630
it.| I think
|我想班上很多同学也会感激的。

862
00:28:25,270 --> 00:28:26,350
0,420 450,750 750,810 810,870 870,1080
many students in the class

863
00:28:26,350 --> 00:28:27,760
0,120 120,420 420,540 540,750
will appreciate it too.|
|

864
00:28:27,760 --> 00:28:29,440
0,480 840,1020 1020,1260 1260,1440 1440,1680
{} Yeah, so {} there's
是的，所以有一个安全问题，

865
00:28:29,440 --> 00:28:30,820
0,90 90,450 450,870
a security issue,|
|

866
00:28:31,680 --> 00:28:35,370
0,990 1050,1500 1500,2280 2940,3300 3300,3690
{ -} the first {},
第一，人们怎么看，

867
00:28:35,730 --> 00:28:37,520
0,540 540,630 630,870 870,1170
what do people think,|
|

868
00:28:38,230 --> 00:28:39,940
0,270 270,420 420,960 990,1320 1320,1710
does this break user kernel|
这是否破坏了用户内核（隔离），|

869
00:28:39,940 --> 00:28:41,770
0,690 720,810 810,990 990,1290 1290,1830
or you know the isolation
或者不同进程之间的隔离。

870
00:28:41,770 --> 00:28:43,640
0,300 300,600 600,1290
between different processes.|
|

871
00:28:49,340 --> 00:28:50,690
0,390 390,720 720,810 810,1170 1170,1350
{Another,way} asking the question did
另一种问法是， sigalarm 是否破破坏了隔离。

872
00:28:50,690 --> 00:28:52,010
0,180 180,300 300,660 660,1170 1200,1320
{sigalarm - -} break you

873
00:28:52,010 --> 00:28:53,580
0,240 240,960
know isolation.|
|

874
00:29:00,080 --> 00:29:01,730
0,450 480,810 810,990 990,1230 1230,1650
{} Would it be okay,|
它是没问题的，|

875
00:29:01,730 --> 00:29:03,440
0,600 600,1110
because the,
因为处理程序的代码

876
00:29:03,590 --> 00:29:05,720
0,300 300,690 1110,1440 1440,1830 1830,2130
{} that that code that

877
00:29:05,720 --> 00:29:07,550
0,120 120,870 1050,1290 1290,1560 1560,1830
the handler| would still have
|仍然可以访问相同的虚拟内存，

878
00:29:07,550 --> 00:29:09,860
0,540 540,960 1020,1200 1200,1800
access to the same

879
00:29:09,860 --> 00:29:11,400
0,990
virtual

880
00:29:11,520 --> 00:29:12,750
0,300 300,510 510,840 870,1110 1110,1230
memory,| I mean, if there
|我的意思是，如果有不同的虚拟内存用于进程

881
00:29:12,750 --> 00:29:13,920
0,60 60,390 390,660 660,1050 1050,1170
are different virtual memories for

882
00:29:13,920 --> 00:29:15,480
0,90 90,570 570,750 750,1260 1320,1560
the process| and for like
|对于每个进程，

883
00:29:15,480 --> 00:29:16,560
0,210 240,420 420,510 510,600 600,1080
for each of the processes,|
|

884
00:29:16,560 --> 00:29:18,480
0,360 450,870 870,1470 1500,1800 1800,1920
then that handler shouldn't be
那么处理程序不能查看其他进程的内存，

885
00:29:18,480 --> 00:29:20,160
0,210 210,720 780,1050 1050,1410 1410,1680
able to look into other

886
00:29:20,160 --> 00:29:24,360
0,570 570,1140 2250,3030 3270,4020 4050,4200
process's memory,| {that,would,be,okay}.| Yeah, sure,|
|这样就可以了。|是的，当然，|

887
00:29:24,360 --> 00:29:25,050
0,210 210,300 300,420 420,540 540,690
when we do the {upcall
当我们向上调用时，

888
00:29:25,050 --> 00:29:26,160
0,240 240,570 570,720 720,900 900,1110
-} correct,| we're up, make
|我们向上调用安装了处理程序的特定用户空间，

889
00:29:26,160 --> 00:29:27,540
0,120 120,270 270,540 540,720 720,1380
the {upcall -} that specific

890
00:29:27,540 --> 00:29:28,830
0,270 270,630 630,750 750,960 960,1290
user space that actually installed

891
00:29:28,830 --> 00:29:29,780
0,90 90,540
the handler,|
|

892
00:29:30,300 --> 00:29:31,440
0,150 150,270 270,570 570,900 900,1140
so the handler basically runs
所以处理程序在相同的上下文中运行，

893
00:29:31,440 --> 00:29:33,300
0,90 90,180 180,450 450,1110 1110,1860
in the same context,| as
|运行相同的页表，

894
00:29:33,330 --> 00:29:34,350
0,390 390,480 480,570 570,750 750,1020
runs with the same page

895
00:29:34,350 --> 00:29:36,480
0,450 450,630 630,1470 1500,1680 1680,2130
table| as {} the application
|与应用程序安装处理程序一样，

896
00:29:36,480 --> 00:29:38,220
0,150 150,510 510,570 570,1020 1440,1740
that installed the handler| and
|所以它唯一能做的就是影响应用程序，

897
00:29:38,220 --> 00:29:38,910
0,180 180,270 270,450 450,570 570,690
so the only thing it

898
00:29:38,910 --> 00:29:39,960
0,150 150,270 270,630 630,930 930,1050
really can do is {you,know}

899
00:29:39,960 --> 00:29:41,640
0,420 420,600 600,1260 1260,1560 1560,1680
affect that application,| but you
|但是那是应用程序的问题，

900
00:29:41,640 --> 00:29:43,650
0,240 450,840 840,960 960,1620 1620,2010
know that's the application problem,|
|

901
00:29:43,740 --> 00:29:45,330
0,270 270,480 480,750 750,1080 1080,1590
can't really affect anybody any
不会影响到任何其他的应用程序，

902
00:29:45,330 --> 00:29:46,920
0,210 210,690 690,870 870,1380 1380,1590
other application,| because it doesn't
|因为它不能访问其他应用程序页表，

903
00:29:46,920 --> 00:29:48,540
0,150 150,330 330,690 690,1260 1500,1620
have any access to the

904
00:29:48,540 --> 00:29:51,030
0,180 180,660 660,1680 1710,2040 2040,2490
other applications {} page tables,|
|

905
00:29:52,450 --> 00:29:53,620
0,180 180,420 420,690 690,900 900,1170
{or,can} force switch into them.|
或者可以强制切换到它们。|

906
00:29:55,190 --> 00:29:55,940
0,150 150,420 420,600 600,690 690,750
So this turns out to
所以这是好的，

907
00:29:55,940 --> 00:29:56,960
0,90 90,570 630,750 750,960 960,1020
be fine,| of course if
|当然，如果处理程序没有返回或者做了什么坏事，

908
00:29:56,960 --> 00:29:58,220
0,90 90,330 330,600 600,1140 1140,1260
the handler doesn't return or

909
00:29:58,220 --> 00:29:59,360
0,150 150,360 360,750 750,1050 1050,1140
does something bad,| in the
|最终，内核可以杀死那个进程，

910
00:29:59,360 --> 00:30:00,380
0,180 180,240 240,630 630,780 780,1020
end, the kernel just kill,

911
00:30:00,380 --> 00:30:01,670
0,120 120,360 360,600 600,660 660,1290
can always kill the process,|
|

912
00:30:02,330 --> 00:30:05,120
0,450 600,1110 1110,1620 1620,1710 1710,2790
so nothing really,| you know
所以没有什么，|唯一可能变坏的是

913
00:30:05,510 --> 00:30:06,530
0,90 90,630 630,780 780,870 870,1020
the only thing that can

914
00:30:06,530 --> 00:30:07,340
0,120 120,480 480,630 630,720 720,810
go bad is| you know
|这个过程会伤害到自己，

915
00:30:07,340 --> 00:30:08,630
0,120 120,390 390,510 510,720 720,1290
the process can hurt itself,|
|

916
00:30:08,750 --> 00:30:09,800
0,300 300,390 390,630 630,870 870,1050
but it can't hurt any
但它不会伤害任何其他进程。

917
00:30:09,800 --> 00:30:11,040
0,180 180,840
other processes.|
|

918
00:30:13,080 --> 00:30:13,830
0,90 90,420 420,540 540,630 630,750
{Amir -}, does that make
Amir ，这能理解吗？

919
00:30:13,830 --> 00:30:14,820
0,300
sense?|
|

920
00:30:16,390 --> 00:30:18,300
0,450 450,720 720,1530
Yes, thank you.|
好的，谢谢。|

921
00:30:18,940 --> 00:30:20,020
0,480 570,720 720,840 840,930 930,1080
Okay, so now I want
好的，现在我想举几个例子，

922
00:30:20,020 --> 00:30:21,580
0,180 180,750 750,930 930,1020 1020,1560
to go through a couple

923
00:30:21,610 --> 00:30:23,100
0,960
{}

924
00:30:23,360 --> 00:30:24,620
0,720
examples,|
|

925
00:30:24,770 --> 00:30:25,670
0,270 270,390 390,480 480,720 720,900
and so to see how
看看你可以如何使用它。

926
00:30:25,670 --> 00:30:26,720
0,90 90,210 210,390 390,660 690,1050
you could use it.| And
|我将从一个非常简单的例子开始，

927
00:30:26,720 --> 00:30:28,190
0,630 630,930 930,1050 1050,1170 1170,1470
I'll start out with very

928
00:30:28,190 --> 00:30:30,260
0,270 270,870 900,1440 1470,1710 1710,2070
simple example| to get ourselves
|让我们自己进入其中，

929
00:30:30,260 --> 00:30:31,730
0,300 300,450 450,570 570,1050 1050,1470
into it| and then we'll
|然后我们会转移到垃圾收集器，

930
00:30:31,760 --> 00:30:32,990
0,240 240,330 330,390 390,750 750,1230
move to the garbage collector,|
|

931
00:30:33,230 --> 00:30:34,370
0,420 420,630 630,690 690,930 930,1140
because lots of people ask
因为很多人问关于垃圾收集器的问题，

932
00:30:34,370 --> 00:30:35,540
0,300 300,450 450,510 510,780 780,1170
questions about the garbage collector,|
|

933
00:30:35,540 --> 00:30:36,440
0,210 210,330 330,540 540,690 690,900
so that seems like a
所以，这是一个很好的用来深入研究。

934
00:30:36,650 --> 00:30:37,730
0,240 240,420 420,480 480,750 750,1080
good one to dive into.|
|

935
00:30:38,550 --> 00:30:39,620
0,570

936
00:30:40,000 --> 00:30:41,530
0,360 360,480 480,690 690,1290 1440,1530
Okay, the first example I
好的，我想说的第一个例子是琐碎的想法，

937
00:30:41,530 --> 00:30:43,060
0,150 150,210 210,540 540,1200 1200,1530
want to talk about {}

938
00:30:43,090 --> 00:30:45,820
0,630 630,1380 1410,1590 1590,1710 1710,2730
trivial idea,| but you know
|实际上论文中甚至没有提到，

939
00:30:46,180 --> 00:30:46,990
0,180 180,390 390,510 510,660 660,810
in fact there's not even

940
00:30:46,990 --> 00:30:48,540
0,300 300,390 390,450 450,930
mentioned in the paper,|
|

941
00:30:48,540 --> 00:30:51,060
0,450 900,1440 1440,1530 1530,2040 2070,2520
{} but it is a
但这是一种很酷的方式

942
00:30:51,090 --> 00:30:52,110
0,180 180,240 240,270 270,750 750,1020
sort of a cool way|
|

943
00:30:52,110 --> 00:30:53,520
0,90 90,930 930,1050 1050,1260 1260,1410
of illustrating you know the
来说明应用程序获得的能力，

944
00:30:53,520 --> 00:30:55,680
0,870 870,1050 1050,1650 1650,1890 1890,2160
power that applications get,| if
|如果它们有这些原语可用的话。

945
00:30:55,680 --> 00:30:57,240
0,300 300,750 750,1050 1050,1200 1200,1560
they actually have these primitives

946
00:30:57,240 --> 00:30:58,520
0,450 450,540 540,810
available to them.|
|

947
00:30:58,720 --> 00:30:59,770
0,390 390,450 450,690 690,960 960,1050
And the basic idea is
基本的想法是建立一个巨大的记忆表，

948
00:30:59,770 --> 00:31:01,450
0,120 120,510 510,870 870,960 960,1680
to actually build a huge

949
00:31:02,790 --> 00:31:05,740
0,750 990,2250
{you,know} memorization

950
00:31:07,370 --> 00:31:08,520
0,600
table,|
|

951
00:31:11,040 --> 00:31:12,150
0,330 330,450 450,510 510,930 930,1110
{} and the memorization table
而记忆表所做的，

952
00:31:12,150 --> 00:31:13,290
0,90 90,420 420,750 750,840 840,1140
is basically what it does,|
|

953
00:31:13,290 --> 00:31:14,700
0,120 120,360 390,1110 1110,1230 1230,1410
it just remember you know
它记住一些计算的结果。

954
00:31:14,700 --> 00:31:16,350
0,180 180,690 690,780 780,960 960,1650
the result of some computation.|
|

955
00:31:16,980 --> 00:31:17,640
0,150 150,270 270,330 330,600 600,660
And so, for example you
所以，比如你可以用下面的方式来思考，

956
00:31:17,640 --> 00:31:18,240
0,90 90,240 240,450 450,540 540,600
can think about in the

957
00:31:18,240 --> 00:31:19,470
0,300 300,540 540,720 720,900 900,1230
following way,| let's say we're
|假设我们在这里有一张表，

958
00:31:19,470 --> 00:31:20,880
0,210 210,300 300,870
here's our table,|
|

959
00:31:21,260 --> 00:31:23,030
0,510 690,900 900,1230 1230,1710 1710,1770
and {you,know} table start to
表从 0 开始到 n ，

960
00:31:23,030 --> 00:31:24,350
0,150 150,420 420,960 990,1110 1110,1320
get whatever zero to some

961
00:31:24,350 --> 00:31:26,630
0,510 870,1170 1170,1410 1410,1830 1950,2280
n| and what the table
|表存储的是运行一些昂贵函数的结果，

962
00:31:26,630 --> 00:31:29,780
0,630 930,1680 2340,2580 2580,2730 2730,3150
stores is {} the result

963
00:31:29,780 --> 00:31:31,730
0,300 300,660 660,900 900,1320 1320,1950
of running some expensive function,|
|

964
00:31:33,600 --> 00:31:35,730
0,360 360,750 750,1350 1350,1830 1830,2130
{} {for,that} argument 0 or
对于参数 0 ，或者其他什么 f(n) 。

965
00:31:35,730 --> 00:31:37,720
0,300 300,810 810,1320
for whatever f(n).|
|

966
00:31:38,370 --> 00:31:39,540
0,240 240,330 330,480 480,750 750,1170
So if you wanted to,|
所以如果你愿意，|

967
00:31:39,720 --> 00:31:40,980
0,210 210,690 690,870 870,1170 1170,1260
{you,know} if this table were
如果这张表是预计算的，

968
00:31:40,980 --> 00:31:42,300
0,180 180,270 270,450 450,1080 1110,1320
sort of pre computed,| it
|它想要在时间的开始，

969
00:31:42,300 --> 00:31:43,320
0,510 510,660 660,720 720,960 960,1020
wants in the beginning of

970
00:31:43,320 --> 00:31:45,030
0,510 840,1020 1020,1380 1380,1500 1500,1710
time| and then you wanted
|然后你想查找，

971
00:31:45,030 --> 00:31:46,110
0,60 60,300 300,570 570,960 960,1080
to look up,| like you
|比如你想知道 f(i) 的值是多少，

972
00:31:46,110 --> 00:31:48,090
0,180 180,240 240,450 450,1050 1440,1980
wanted to know what value

973
00:31:48,090 --> 00:31:49,320
0,90 90,300 300,300 300,990 1020,1230
for {f(i) -} was,| well
|你要做的就是在表中查找，

974
00:31:49,320 --> 00:31:50,490
0,150 150,270 270,870 900,1080 1080,1170
what you do is you

975
00:31:50,490 --> 00:31:51,760
0,210 210,420 420,810
just look up

976
00:31:52,090 --> 00:31:53,460
0,120 120,210 210,810
in the table,|
|

977
00:31:53,700 --> 00:31:54,900
0,120 120,270 270,510 510,780 780,1200
you know in the slot
在插槽 i 里，

978
00:31:54,900 --> 00:31:56,340
0,420 540,720 720,1050 1050,1200 1200,1440
i| and basically you get
|你得到将要计算的 f(i) 的值。

979
00:31:56,340 --> 00:31:58,290
0,360 660,990 990,1320 1320,1740 1740,1950
the {} the value that

980
00:31:58,290 --> 00:32:00,780
0,240 240,1320 1350,1830 1830,1950 1950,2490
{f(i) -} would have computed.|
|

981
00:32:01,470 --> 00:32:03,030
0,210 210,540 540,780 780,1020 1020,1560
And so this would return
所以这可能会返回一个昂贵的计算，

982
00:32:03,030 --> 00:32:05,310
0,420 420,510 510,990 990,1800 1830,2280
maybe an expensive computation,| maybe
|也许 f 是非常昂贵的，

983
00:32:05,310 --> 00:32:07,710
0,180 180,270 270,480 480,1080 1350,2400
f is very expensive,| into
|转变为一个表查找，

984
00:32:07,830 --> 00:32:09,800
0,450 450,840 840,1140 1140,1530
a basically table lookup,|
|

985
00:32:10,050 --> 00:32:10,740
0,180 180,330 330,390 390,450 450,690
{} sort of a cool
这是一个很酷的技巧，

986
00:32:10,740 --> 00:32:13,530
0,420 450,600 600,780 780,1410 1710,2790
trick,| {you,know} to basically {}
|存储预计算的结果，

987
00:32:14,340 --> 00:32:15,960
0,390 390,480 480,1020 1020,1440 1440,1620
store the results for pre

988
00:32:15,960 --> 00:32:17,490
0,540 540,750 750,990 990,1080 1080,1530
computes| and store the results
|并存储昂贵计算的结果，

989
00:32:17,490 --> 00:32:19,470
0,180 180,360 360,930 930,1620 1770,1980
of an expensive computation,| and
|如果相同的计算很多很多次，

990
00:32:19,470 --> 00:32:20,670
0,120 120,330 330,510 510,690 690,1200
if that's the same computation

991
00:32:20,670 --> 00:32:22,110
0,90 90,420 420,660 660,870 870,1440
is actually many many times,|
|

992
00:32:22,260 --> 00:32:23,700
0,480 480,570 570,870 900,1110 1110,1440
then you know pre compute
然后提前计算每个，

993
00:32:23,700 --> 00:32:24,870
0,150 150,570 570,660 660,990 990,1170
good ones,| you might be
|你可能会有好处，只要需做一点事情。

994
00:32:24,870 --> 00:32:27,930
0,90 90,570 600,660 660,660 2700,3060
an advantage to {} small

995
00:32:27,930 --> 00:32:28,800
0,120 120,180 180,450
thing to do.|
|

996
00:32:30,620 --> 00:32:32,000
0,420 420,630 630,870 870,1050 1050,1380
Does that setup makes sense?|
这样的设置，能理解吗？|

997
00:32:33,740 --> 00:32:35,450
0,210 210,330 330,780 810,960 960,1710
Okay, so then the issue,|
好的，那么问题是，|

998
00:32:35,900 --> 00:32:37,010
0,480 480,630 630,840 840,900 900,1110
{} yeah you of course
是的，当然是那个表或挑战，

999
00:32:37,010 --> 00:32:38,630
0,270 270,390 390,510 510,1140 1320,1620
is that the table or

1000
00:32:38,630 --> 00:32:40,220
0,330 330,990
the challenge,|
|

1001
00:32:43,040 --> 00:32:43,820
0,150 150,240 240,540 540,720 720,780
{} the table might be
那个表可能很大，

1002
00:32:43,820 --> 00:32:44,920
0,420
big,|
|

1003
00:32:48,730 --> 00:32:49,690
0,270 270,420 420,660 660,720 720,960
might be actually in fact
可能实际上很大，

1004
00:32:49,690 --> 00:32:50,470
0,270 270,450 450,540 540,690 690,780
very big,| it might be
|它甚至可能比你的物理内存更大，

1005
00:32:50,470 --> 00:32:51,760
0,390 390,540 540,870 870,990 990,1290
bigger than maybe your physical

1006
00:32:51,760 --> 00:32:52,800
0,390
memory,|
|

1007
00:32:56,060 --> 00:32:57,050
0,330 330,450 450,630 630,900 900,990
but it's still nice to
但是拥有它还是很好的。

1008
00:32:57,050 --> 00:32:58,120
0,240 240,450
have it.|
|

1009
00:32:58,210 --> 00:33:00,070
0,240 240,330 330,990 990,1260 1260,1860
So the solution,| one solution
所以解决方案，|你可以用来解决这个问题的一个解决方案是，

1010
00:33:00,100 --> 00:33:01,120
0,120 120,360 360,540 540,690 690,1020
you know that you could

1011
00:33:01,120 --> 00:33:02,340
0,0
{}

1012
00:33:03,830 --> 00:33:05,240
0,480 480,600 600,840 840,960 960,1410
used to solve this problem

1013
00:33:05,240 --> 00:33:06,470
0,330 330,420 420,810 810,1080 1080,1230
is| to basically use the
|使用论文中描述的虚拟内存原语。

1014
00:33:06,470 --> 00:33:08,140
0,270 270,570 570,1200
virtual memory primitives

1015
00:33:09,520 --> 00:33:10,930
0,270 270,660 660,720 720,780 780,1410
as described in the paper.|
|

1016
00:33:12,550 --> 00:33:14,260
0,510 510,1170
{Primitives -}.|
原语。|

1017
00:33:15,420 --> 00:33:16,720
0,780

1018
00:33:16,810 --> 00:33:18,130
0,420 420,690 690,780 780,990 990,1320
And what you do is|
你要做的是，|

1019
00:33:18,130 --> 00:33:18,820
0,120 120,240 240,480 480,540 540,690
you know first of all
首先你分配一个很大的范围，

1020
00:33:18,820 --> 00:33:20,230
0,90 90,480 480,510 510,810 810,1410
you allocate a huge range,|
|

1021
00:33:26,200 --> 00:33:27,700
0,120 120,390 390,660 660,1260 1290,1500
but don't really map,| {you,know}
但是不要真正映射，|不要分配与该范围相对应的任何物理内存，

1022
00:33:27,700 --> 00:33:29,200
0,270 270,630 630,990 990,1140 1140,1500
don't actually allocate any physical

1023
00:33:29,200 --> 00:33:30,940
0,420 420,960 960,1050 1050,1230 1230,1740
memory corresponding to that range|
|

1024
00:33:30,940 --> 00:33:32,050
0,450 450,660 660,900 900,990 990,1110
[] use part of your
[]使用部分地址空间，

1025
00:33:32,050 --> 00:33:33,760
0,240 240,750 1020,1200 1200,1410 1410,1710
address space,| then say I'm
|然后假设我要使用地址空间的这一部分，

1026
00:33:33,760 --> 00:33:34,570
0,150 150,210 210,420 420,660 660,810
going to use that part

1027
00:33:34,570 --> 00:33:35,440
0,90 90,210 210,480 480,780 780,870
of my address space,| you've
|必须存储那张表。

1028
00:33:35,440 --> 00:33:36,370
0,150 150,240 240,450 450,510 510,930
got to store the table.|
|

1029
00:33:37,520 --> 00:33:39,740
0,120 120,600 990,1620
And then, {}
然后，在一个页面上，

1030
00:33:39,890 --> 00:33:43,100
0,300 300,750 1290,1980 1980,2640 2640,3210
on a page,| the, there's
|在表中没有内容，

1031
00:33:43,100 --> 00:33:44,270
0,180 180,630 630,720 720,780 780,1170
no content in the table,|
|

1032
00:33:44,270 --> 00:33:45,740
0,90 90,360 360,660 660,960 960,1470
there is address ranges exist,|
有个地址范围，|

1033
00:33:45,980 --> 00:33:46,820
0,240 240,330 330,420 420,630 630,840
so if you do a
所以如果你做一个表查找，

1034
00:33:46,820 --> 00:33:49,200
0,300 300,660 960,1350 1350,1830
table lookup,| {like,table} i,|
|比如 tb[i] ，|

1035
00:33:49,600 --> 00:33:50,590
0,150 150,210 210,390 390,570 570,990
you know that will result
那会导致页面错误。

1036
00:33:50,590 --> 00:33:52,500
0,420 420,630 630,900 900,1320
into a page fault.|
|

1037
00:33:56,000 --> 00:33:57,200
0,120 120,270 270,600 600,1080 1080,1200
And so this plan is
所以这个方案出现在页面错误上，

1038
00:33:57,200 --> 00:33:58,190
0,120 120,210 210,450 450,840 840,990
on the page fault,| {you,know},
|你计算所有的条目，

1039
00:33:58,190 --> 00:33:59,930
0,180 180,840 930,1260 1260,1380 1380,1740
you compute all the entries|
|

1040
00:33:59,930 --> 00:34:01,460
0,180 180,270 270,900 900,1170 1170,1530
or you know all the
或者所有的页面都覆盖了表中的条目，

1041
00:34:01,760 --> 00:34:03,470
0,420 420,780 780,1110 1110,1290 1290,1710
page basically covers a bunch

1042
00:34:03,470 --> 00:34:04,580
0,90 90,420 420,510 510,570 570,1110
of entries in the table,|
|

1043
00:34:04,760 --> 00:34:05,390
0,210 210,270 270,360 360,540 540,630
if we reach one of
如果我们到达其中之一，

1044
00:34:05,390 --> 00:34:07,310
0,300 510,660 660,1380 1410,1740 1740,1920
them,| you're basically {} you
|你计算函数 f(i) ，

1045
00:34:07,310 --> 00:34:08,460
0,600
compute

1046
00:34:08,460 --> 00:34:10,290
0,330 330,510 510,510 1170,1710 1710,1830
function {f(i) -},| store it
|把它保存在插槽 tb[i] 中，

1047
00:34:10,290 --> 00:34:12,030
0,360 360,480 480,960 960,1110 1110,1740
in the slot table i,|
|

1048
00:34:13,000 --> 00:34:14,650
0,150 150,330 330,780 780,1500 1530,1650
and then basically resume you
然后恢复应用程序，

1049
00:34:14,650 --> 00:34:16,510
0,90 90,210 210,900 1170,1410 1410,1860
know the application right now,|
|

1050
00:34:16,510 --> 00:34:18,540
0,810 870,1500
the {},|
那个，|

1051
00:34:18,900 --> 00:34:20,880
0,900 900,1050 1050,1260 1260,1590 1590,1980
{} of course the map
当然映射到物理页面，

1052
00:34:20,880 --> 00:34:22,110
0,90 90,360 360,780 780,990 990,1230
the physical page,| {you,know} so
|所以会有页面错误，

1053
00:34:22,140 --> 00:34:23,400
0,390 390,510 510,600 600,810 810,1260
basically take the page fault,|
|

1054
00:34:23,670 --> 00:34:25,340
0,120 120,540 540,1140
you allocate page,|
你分配页面，|

1055
00:34:28,520 --> 00:34:30,470
0,180 180,360 360,1140 1560,1740 1740,1950
and may store in that
并在那个页中保存，

1056
00:34:30,470 --> 00:34:32,270
0,510 540,600 600,600 1050,1560 1560,1800
page,| as a result of
|作为 f(i) 的结果，对于页面中所有插槽。

1057
00:34:32,270 --> 00:34:33,440
0,420 420,420 420,900 900,1080 1080,1170
{f(i) -} for all the

1058
00:34:33,440 --> 00:34:35,340
0,420 420,510 510,870 1050,1410
slots in the page.|
|

1059
00:34:35,600 --> 00:34:36,760
0,570

1060
00:34:36,760 --> 00:34:37,810
0,210 210,390 390,810 810,930 930,1050
And the advantage of it
它的优势是，

1061
00:34:37,810 --> 00:34:38,890
0,120 120,390 390,480 480,570 570,1080
is, correct,| if you know
|有几个优势，

1062
00:34:38,980 --> 00:34:40,750
0,450 690,1080 1080,1140 1140,1440 1440,1770
a couple of advantages,| if
|如果你重新计算 f(i) ，

1063
00:34:40,750 --> 00:34:42,190
0,120 120,240 240,360 360,900 1080,1440
you have to ever compute

1064
00:34:42,190 --> 00:34:43,510
0,210 210,210 210,900 1110,1230 1230,1320
{f(i) -} again,| you know
|你要做的就是表查找，

1065
00:34:43,510 --> 00:34:44,740
0,300 300,420 420,510 510,1020 1020,1230
you're going to actually do

1066
00:34:44,740 --> 00:34:45,970
0,180 180,510 510,960 960,1140 1140,1230
the table lookup| and you
|你不需要做任何昂贵的计算，

1067
00:34:45,970 --> 00:34:46,660
0,150 150,420 420,510 510,600 600,690
don't actually have to do

1068
00:34:46,660 --> 00:34:48,430
0,240 240,630 630,1170 1170,1380 1380,1770
any expensive computation,| just {table,lookup},|
|只需要表查找，|

1069
00:34:48,700 --> 00:34:50,020
0,180 180,510 690,900 900,1050 1050,1320
in fact, you know even
事实上，即使你查找表 i 加 1，

1070
00:34:50,020 --> 00:34:50,650
0,90 90,180 180,270 270,330 330,630
if you do a table

1071
00:34:50,650 --> 00:34:52,360
0,180 180,420 420,750 750,1260 1290,1710
i plus 1,| like there's
|在那个特定的页面上会有一堆条目，

1072
00:34:52,360 --> 00:34:53,350
0,180 180,300 300,360 360,780 810,990
gonna be a bunch of

1073
00:34:53,350 --> 00:34:54,640
0,420 420,630 630,930 930,1110 1110,1290
entries in the in that

1074
00:34:54,640 --> 00:34:56,110
0,270 270,660 750,1020 1020,1110 1110,1470
particular page,| they're all basically
|它们基本上都可以免费了，

1075
00:34:56,110 --> 00:34:57,160
0,150 150,360 360,540 540,930 960,1050
can now be free,| you
|只是做表查找。

1076
00:34:57,160 --> 00:34:58,660
0,120 120,420 450,720 720,1200
know just table lookups.|
|

1077
00:34:59,220 --> 00:35:00,600
0,120 120,540 720,1020 1020,1170 1170,1380
Of course, you keep doing
当然，你一直这样做，

1078
00:35:00,600 --> 00:35:01,680
0,450 570,810 810,900 900,1020 1020,1080
this,| then you're going to
|然后你将会消耗掉所有物理内存，

1079
00:35:01,680 --> 00:35:03,660
0,390 390,540 540,840 840,1350 1590,1980
consume all physical memory {},|
|

1080
00:35:03,660 --> 00:35:04,620
0,180 180,570 570,660 660,840 840,960
and so you know the
所以页面错误处理程序还必须抛出一些页面，

1081
00:35:04,620 --> 00:35:06,480
0,180 180,330 330,660 660,1260 1470,1860
page fault handler also has

1082
00:35:06,480 --> 00:35:07,740
0,90 90,360 360,630 630,750 750,1260
to throw out some pages,|
|

1083
00:35:07,740 --> 00:35:09,060
0,360 360,840 840,1110 1110,1260 1260,1320
if you're running out of
如果内存快用完了，

1084
00:35:09,060 --> 00:35:10,560
0,360 360,660 750,1140 1140,1260 1260,1500
memory,| so you know if
|所以如果有太多的内存在使用，

1085
00:35:11,200 --> 00:35:13,120
0,270 270,660 660,780 780,1320
much memories in use,

1086
00:35:16,830 --> 00:35:18,340
0,870
use,|
|

1087
00:35:18,510 --> 00:35:19,620
0,210 210,420 420,510 510,840 900,1110
free some of them, free
释放其中一些页面。

1088
00:35:19,620 --> 00:35:20,860
0,180 180,630
some pages.|
|

1089
00:35:23,500 --> 00:35:24,310
0,120 120,180 180,390 390,660 660,810
And of course then you
当然，然后你必须改变保护级别，

1090
00:35:24,310 --> 00:35:25,570
0,240 240,330 330,630 630,960 960,1260
have to change, change the

1091
00:35:25,570 --> 00:35:27,610
0,420 420,810 1260,1350 1350,1710 1710,2040
protection level| to make sure
|确保将来会出现这些条目的页面错误。

1092
00:35:27,610 --> 00:35:28,450
0,180 180,480 480,600 600,660 660,840
that you're going to get

1093
00:35:28,450 --> 00:35:29,320
0,90 90,180 180,510 510,630 630,870
in the future {} page

1094
00:35:29,320 --> 00:35:30,940
0,300 300,390 390,600 600,1140
fault for those entries.|
|

1095
00:35:31,060 --> 00:35:32,260
0,180 180,300 300,420 420,720 750,1200
So you have to {presumably
所以你可能要调用 Prot1 或 ProtN ，

1096
00:35:32,260 --> 00:35:33,660
0,270 270,870
-} call

1097
00:35:33,720 --> 00:35:35,260
0,180 180,330 390,990
{you,know -} {Prot1

1098
00:35:35,260 --> 00:35:37,660
0,360 360,480 480,870 870,1290 1860,2400
-} or {ProtN -}| to
|以减少页面的可访问性，

1099
00:35:38,400 --> 00:35:39,750
0,360 360,450 450,1170 1170,1260 1260,1350
reduce the accessibility of the

1100
00:35:39,750 --> 00:35:40,830
0,330 330,450 450,510 510,1020 1020,1080
page| and the terminology of
|这是论文中的术语。

1101
00:35:40,830 --> 00:35:41,820
0,90 90,450
the paper.|
|

1102
00:35:42,530 --> 00:35:43,580
0,150 150,300 300,450 450,840 900,1050
Does this make sense, that's
这能理解吗，这是一种方案。

1103
00:35:43,580 --> 00:35:45,240
0,150 150,240 240,600 600,1110
sort of a plan.|
|

1104
00:35:49,330 --> 00:35:51,180
0,1290
Okay.|
好的。|

1105
00:35:51,180 --> 00:35:52,650
0,600 690,750 750,900 900,1140 1140,1470
Yeah, you would need to
是的，你需要映射它，

1106
00:35:52,680 --> 00:35:54,270
0,390 390,720 780,1020 1020,1260 1260,1590
map it,| would need to
|需要从操作系统请求

1107
00:35:54,300 --> 00:35:56,790
0,630 630,1110 1710,1860 1860,2220 2220,2490
request from the operating system|
|

1108
00:35:56,790 --> 00:35:57,450
0,120 120,360 360,450 450,570 570,660
to map it to a
将其映射到特定地址，对吧，

1109
00:35:57,450 --> 00:36:00,000
0,690 690,1440 1470,1890 2160,2460 2460,2550
particular address, right,| because it
|因为它可以去任何地方。

1110
00:36:00,000 --> 00:36:02,280
0,240 270,330 510,1260 1350,1800 1920,2280
can go anywhere, okay.| {Yeah,we're}
|是的，我们会去任何地方，

1111
00:36:02,280 --> 00:36:03,150
0,180 180,240 240,390 390,750 750,870
going to be anywhere,| as
|需要操作系统告诉它在哪里。

1112
00:36:03,150 --> 00:36:03,840
0,150 150,270 270,420 420,510 510,690
long as you know the

1113
00:36:03,840 --> 00:36:05,340
0,420 420,690 690,1080 1080,1170 1170,1500
{operation,system} tell where it actually

1114
00:36:05,340 --> 00:36:06,120
0,330
is.|
|

1115
00:36:07,570 --> 00:36:09,430
0,660 1170,1590 1590,1680 1680,1800 1800,1860
Okay.| Maybe to make a
好的。|或许说得更具体一点，

1116
00:36:09,430 --> 00:36:10,660
0,150 150,270 270,360 360,870 870,1230
little bit more concrete,| actually
|实际上，我实现了这个方案。

1117
00:36:10,660 --> 00:36:11,710
0,60 60,150 150,210 210,450 450,1050
I have a little implementation

1118
00:36:11,710 --> 00:36:13,040
0,60 60,300 300,780
of this plan.|
|

1119
00:36:13,070 --> 00:36:14,150
0,480 480,690 690,780 780,960 960,1080
And we can just look
我们可以看一下，

1120
00:36:14,150 --> 00:36:17,120
0,120 120,390 420,1290 1290,2010 2400,2970
at it| and see {}
|看看是什么，

1121
00:36:17,120 --> 00:36:18,140
0,270 270,600 630,810 810,960 960,1020
what are,| {you,know}, how do
|你如何使用现有的 Unix 原语来做到这个。

1122
00:36:18,140 --> 00:36:19,490
0,390 390,660 660,840 840,1020 1020,1350
you actually do that using

1123
00:36:19,490 --> 00:36:21,110
0,60 60,660 660,750 750,1290 1290,1620
the existing you know Unix

1124
00:36:21,110 --> 00:36:22,340
0,750
primitives.|
|

1125
00:36:24,190 --> 00:36:25,280
0,360 360,660
Let me.|
让我。|

1126
00:36:32,190 --> 00:36:33,400
0,780
Okay.|
好的。|

1127
00:36:36,500 --> 00:36:38,930
0,240 240,720 720,1140 1200,1740 1740,2430
Can everybody {} see the
大家能看到 Emacs 的缓冲区吗，

1128
00:36:39,080 --> 00:36:40,400
0,360 360,870
Emacs buffer,|
|

1129
00:36:41,430 --> 00:36:43,220
0,360 360,570 570,840 840,1260
{is,the} font large enough?|
字体够大吗？|

1130
00:36:47,040 --> 00:36:48,000
0,120 120,450 450,630 630,750 750,960
I assume that as a
我想这就是答应了。

1131
00:36:48,030 --> 00:36:49,080
0,510
yes.|
|

1132
00:36:49,200 --> 00:36:51,780
0,180 180,480 480,660 660,1740 1770,2580
So here's the application {},|
所以这是应用程序，|

1133
00:36:52,140 --> 00:36:53,130
0,480 480,600 600,780 780,900 900,990
let me go to the
让我到最下面。

1134
00:36:53,130 --> 00:36:54,220
0,570
bottom.|
|

1135
00:36:54,220 --> 00:36:56,500
0,180 180,330 330,570 570,1200 1290,2280
{} So here's main, {}|
所以这是 main ，|

1136
00:36:56,530 --> 00:36:57,760
0,240 240,690 690,960 960,1140 1140,1230
main basically {setup_sqrt_region - -
main 基本上是 setup_sqrt_region ，

1137
00:36:57,760 --> 00:37:00,280
0,600 600,1170 1200,1680 1680,2220 2220,2520
- -},| basically allocates address
|基本上是分配地址空间，

1138
00:37:00,280 --> 00:37:01,360
0,570
space,|
|

1139
00:37:01,360 --> 00:37:03,970
0,270 270,420 420,690 690,1230 1260,2610
{} but doesn't really allocate
但并不真正分配属于它的物理页。

1140
00:37:03,970 --> 00:37:05,380
0,90 90,420 420,780 780,1260 1260,1410
the physical pages belonging to

1141
00:37:05,380 --> 00:37:06,220
0,270
it.|
|

1142
00:37:06,390 --> 00:37:07,170
0,240 240,390 390,510 510,570 570,780
{} And then it calls
然后它调用函数 test_sqrt_region ，

1143
00:37:07,170 --> 00:37:08,460
0,120 120,420 420,720 720,1050 1050,1290
this function {test_sqrt_region - -

1144
00:37:08,460 --> 00:37:09,900
0,300 300,420 420,870 870,1110 1110,1440
-}| to basically go through
|以随机顺序遍历该表，

1145
00:37:09,900 --> 00:37:11,370
0,120 120,690 720,870 960,1140 1140,1470
that table in a random

1146
00:37:11,370 --> 00:37:12,440
0,540
order,|
|

1147
00:37:12,470 --> 00:37:14,750
0,810 870,1290 1290,1470 1470,1920 1920,2280
and you know basically checks
检查表中该位置的平方根条目，

1148
00:37:14,750 --> 00:37:16,850
0,450 450,660 660,1020 1020,1500 1680,2100
whether the square root entry

1149
00:37:16,850 --> 00:37:17,750
0,90 90,180 180,570 570,720 720,900
in the table for that

1150
00:37:17,750 --> 00:37:19,970
0,690 810,1020 1020,1590 1590,1680 1680,2220
position| is indeed the correct
|是正确的平方根值，

1151
00:37:20,060 --> 00:37:21,500
0,360 360,540 540,990 990,1260 1260,1440
square root value| by just
|只需在之前逐字计算。

1152
00:37:21,500 --> 00:37:23,480
0,360 360,480 480,1020 1290,1770 1770,1980
computing it literally before that.|
|

1153
00:37:24,010 --> 00:37:25,060
0,630
Okay?|
好的？|

1154
00:37:25,270 --> 00:37:26,770
0,240 240,630 630,900 900,1110 1110,1500
So basically {test_sqrt_region - -}
所以 test_sqrt_region 将运行，

1155
00:37:26,770 --> 00:37:28,030
0,90 90,210 210,270 270,750 810,1260
is going to run {}|
|

1156
00:37:28,030 --> 00:37:28,990
0,300 300,390 390,510 510,660 660,960
and it's going to presumably
它可能会产生页面错误，

1157
00:37:28,990 --> 00:37:30,430
0,390 390,630 630,930 930,1200 1200,1440
generate page fault,| because none
|因为到目前为止还没有真正填满表。

1158
00:37:30,430 --> 00:37:32,110
0,150 150,630 810,1170 1170,1410 1410,1680
of the tables actually filled

1159
00:37:32,110 --> 00:37:33,280
0,120 120,330 330,660
in so far.|
|

1160
00:37:33,960 --> 00:37:35,160
0,270 270,450 450,660 660,870 870,1200
{} So how does it,|
那么它是怎么，|

1161
00:37:35,190 --> 00:37:36,210
0,270 270,360 360,480 480,690 690,1020
how do we get those
我们怎么才能得到那些页面错误，

1162
00:37:36,210 --> 00:37:38,340
0,180 180,510 510,1080 1110,1530 1530,2130
page faults,| well here's the
|好的，这是一段代码，

1163
00:37:38,640 --> 00:37:40,290
0,300 300,600 720,1200 1200,1320 1320,1650
{sort,of} the fragment of code,|
|

1164
00:37:40,290 --> 00:37:41,280
0,150 150,270 270,540 540,660 660,990
that you need to basically
你需要安装一个处理程序，

1165
00:37:41,280 --> 00:37:43,680
0,540 540,1470 1470,2010 2010,2070 2070,2400
install a handler| a signal
|一个特定事件的信号处理程序，

1166
00:37:43,680 --> 00:37:45,120
0,420 420,600 600,660 660,990 990,1440
handler for a particular event,|
|

1167
00:37:45,420 --> 00:37:46,980
0,240 240,300 300,690 690,960 960,1560
we were basically setting here,|
我们在这里设置，|

1168
00:37:47,100 --> 00:37:50,070
0,450 450,1260 1260,1950 1980,2370 2370,2970
{} install for a SIG-,
安装 SIGSEGV 事件，处理程序 SIGSEGV ，

1169
00:37:50,100 --> 00:37:50,910
0,60 60,210 210,330 330,570 570,810
you know the {SIGSEGV -

1170
00:37:50,910 --> 00:37:53,040
0,450 480,1080 1200,1440 1440,1830 1830,2130
-} event, the handler {SIGSEGV

1171
00:37:53,040 --> 00:37:54,180
0,240 240,720
- -},|
|

1172
00:37:54,180 --> 00:37:56,640
0,840 870,1020 1020,1380 1590,1950 1950,2460
and so when a segfault
所以，当 segfault 发生时，

1173
00:37:56,640 --> 00:37:57,600
0,330 330,450 450,510 510,750 750,960
happens,| when a page fault
|当页面故障发生时，

1174
00:37:57,600 --> 00:37:59,550
0,510 600,1200 1200,1320 1320,1800 1800,1950
happens,| basically the function, the
|内核将调用 handle_sigsegv ，

1175
00:37:59,550 --> 00:38:01,800
0,450 450,600 600,990 990,1830 1860,2250
kernel will call sig {handle_sigsegv

1176
00:38:01,800 --> 00:38:04,050
0,210 210,420 420,840 1230,1860 1860,2250
- - -}| and basically
|你可以提取出故障地址，

1177
00:38:04,050 --> 00:38:05,880
0,120 120,240 240,840 840,1380 1410,1830
you can extract the faulting

1178
00:38:05,880 --> 00:38:06,930
0,510 510,600 600,690 690,870 870,1050
address,| you know this looks
|这看起来和你的陷阱代码很像，

1179
00:38:06,930 --> 00:38:08,490
0,270 270,630 630,750 750,1050 1110,1560
very similar to your trap

1180
00:38:08,490 --> 00:38:09,630
0,360 360,540 540,720 720,930 930,1140
code,| you've seen many many
|你们以前见过很多次。

1181
00:38:09,630 --> 00:38:11,060
0,270 270,870
times before.|
|

1182
00:38:11,060 --> 00:38:12,830
0,450 450,900 900,1380 1410,1650 1650,1770
And basically the plan is
基本上，这个方案是非常直截的，

1183
00:38:12,830 --> 00:38:15,410
0,210 210,990 1380,1770 1770,1980 1980,2580
very straightforward,| {} we map
|我们将页面映射到特定地址，

1184
00:38:16,010 --> 00:38:17,360
0,90 90,510 510,750 750,900 900,1350
a page at that particular

1185
00:38:17,360 --> 00:38:19,970
0,570 630,780 780,1230 1530,2100 2370,2610
address,| you know because that's
|因为那是我们想填入的地址，

1186
00:38:19,970 --> 00:38:20,870
0,120 120,510 510,600 600,720 720,900
the address that we want

1187
00:38:20,870 --> 00:38:22,490
0,60 60,300 300,660 1020,1470 1470,1620
to fill in,| {} we
|我们必须，

1188
00:38:22,490 --> 00:38:24,410
0,120 120,840 900,1200 1260,1470 1470,1920
have to,| so my expensive
|所以我这里的昂贵函数

1189
00:38:24,410 --> 00:38:26,000
0,330 330,660 660,1020
function here,| {or,the},
|或者是昂贵函数的替换，

1190
00:38:26,890 --> 00:38:28,120
0,120 120,630 630,750 750,810 810,1230
the replacement for the expensive

1191
00:38:28,120 --> 00:38:29,350
0,360 360,510 510,840 840,1140 1140,1230
function| or the role of
|或者昂贵函数是平方根函数，

1192
00:38:29,350 --> 00:38:30,490
0,390 390,690 690,810 810,870 870,1140
expensive function is the square

1193
00:38:30,490 --> 00:38:31,720
0,180 180,660 840,1020 1020,1140 1140,1230
root function,| and so we
|所以我们要填入平方根的值，

1194
00:38:31,720 --> 00:38:32,710
0,180 180,240 240,510 510,750 750,990
want to basically fill in

1195
00:38:32,710 --> 00:38:34,630
0,120 120,270 270,1080 1290,1680 1680,1920
you know the square root

1196
00:38:34,630 --> 00:38:37,120
0,60 60,660 930,1740 1740,2280 2280,2490
of whatever value,| it has
|它必须在表中的那个特定位置。

1197
00:38:37,120 --> 00:38:37,840
0,90 90,240 240,480 480,600 600,720
to be there at that

1198
00:38:37,840 --> 00:38:39,190
0,360 360,810 810,900 900,960 960,1350
particular location in the table.|
|

1199
00:38:39,730 --> 00:38:41,020
0,300 300,420 420,750 750,780 780,1290
So we allocate a page
所以，我们分配一个页面并将其映射到那里，

1200
00:38:41,260 --> 00:38:42,640
0,420 420,960 960,1110 1110,1290 1290,1380
{} and and map it

1201
00:38:42,640 --> 00:38:45,010
0,510 810,1020 1020,1740 1740,1860 1860,2370
there| and then we calculate
|然后我们计算该页的所有平方根条目，

1202
00:38:45,010 --> 00:38:46,630
0,330 330,600 600,990 990,1200 1200,1620
for that page all the

1203
00:38:46,660 --> 00:38:48,280
0,300 300,480 480,1140
square root entries,|
|

1204
00:38:48,280 --> 00:38:50,050
0,330 330,750 750,900 900,1200 1440,1770
and then we're done| and
然后我们就完成了，|这个应用程序有点极端，

1205
00:38:50,050 --> 00:38:51,310
0,480 480,690 690,1170 1170,1230 1230,1260
this this application is a

1206
00:38:51,310 --> 00:38:52,810
0,150 150,240 240,840 1080,1320 1320,1500
little bit extreme,| {} what
|我所做的是，

1207
00:38:52,810 --> 00:38:54,100
0,60 60,240 240,330 330,990 1050,1290
I did is| basically I
|我在只分配一个物理页面的情况下运行这个表，

1208
00:38:54,100 --> 00:38:55,270
0,210 210,390 390,720 720,900 900,1170
run this table with only

1209
00:38:55,270 --> 00:38:57,490
0,630 660,1050 1050,1320 1320,1830 1830,2220
one physical page allocated,| so
|所以不管最后一页是什么，

1210
00:38:57,550 --> 00:38:59,110
0,450 450,510 510,810 810,1020 1020,1560
whatever the last page was,|
|

1211
00:38:59,140 --> 00:39:00,730
0,300 300,450 450,810 810,930 930,1590
would just release it by
会通过 munmap 来释放它。

1212
00:39:00,760 --> 00:39:02,780
0,930 930,1320 1320,1590
{munmap -} it.|
|

1213
00:39:03,050 --> 00:39:03,800
0,150 150,450 480,600 600,690 690,750
And so we have a
所以我们有一张巨大的表，

1214
00:39:03,800 --> 00:39:06,200
0,540 540,1110 1200,1470 1470,1770 1770,2400
gigantic table,| that's basically represented
|用一个物理页面来表示它。

1215
00:39:06,200 --> 00:39:08,450
0,270 450,750 750,1380 1380,1740 1740,2250
it by one physical page.|
|

1216
00:39:09,470 --> 00:39:10,490
0,540 540,690 690,780 780,870 870,1020
{} And we can just
我们可以直接运行，

1217
00:39:10,490 --> 00:39:11,540
0,450 450,540 540,690 690,840 840,1050
run,| you know we wanted
|我们想要，

1218
00:39:11,540 --> 00:39:12,140
0,90 90,180 180,330 330,450 450,600
to,| we could run this
|我们可以运行这个应用程序，

1219
00:39:12,140 --> 00:39:13,340
0,570 570,720 720,870 870,990 990,1200
application,| it's {} gonna be
|会很激动人心，

1220
00:39:13,340 --> 00:39:17,020
0,330 330,810 1200,1860 2220,2850
that particular exciting, {}|
|

1221
00:39:17,330 --> 00:39:18,760
0,420 420,900
why not.|
为什么不呢。|

1222
00:39:19,520 --> 00:39:21,080
0,450 450,990
{} So,
所以，编译它，

1223
00:39:22,410 --> 00:39:23,640
0,510 510,840 840,930 930,1110 1110,1230
compile it,| you know and
|在一个表中随机地跳来跳去，

1224
00:39:23,640 --> 00:39:25,530
0,330 330,480 480,1110 1110,1380 1380,1890
basically go through and randomly

1225
00:39:25,530 --> 00:39:26,910
0,390 390,720 720,840 840,930 930,1380
bounces around in a table,|
|

1226
00:39:26,910 --> 00:39:28,470
0,690 900,1290 1290,1350 1350,1500 1500,1560
presumably causing a lot of
可能造成许多不同的页面错误，

1227
00:39:28,470 --> 00:39:30,090
0,270 270,480 480,960 1200,1470 1470,1620
different page faults,| in all
|在所有条目中，

1228
00:39:30,090 --> 00:39:31,140
0,150 150,540 540,630 630,780 780,1050
the entries you know actually

1229
00:39:31,140 --> 00:39:32,640
0,240 240,540 600,780 780,1050 1170,1500
work out| and so even
|所以即使非常巨大，

1230
00:39:32,640 --> 00:39:34,290
0,150 150,570 570,1410 1410,1530 1530,1650
though there's gigantic,| it {}
|这个虚拟平方跟表，

1231
00:39:34,290 --> 00:39:36,330
0,270 270,420 420,660 660,1320 1410,2040
square root page table, table,

1232
00:39:36,360 --> 00:39:38,700
0,720 810,1140 1140,1260 1260,1710 1950,2340
virtual square root table {},|
|

1233
00:39:38,700 --> 00:39:40,470
0,180 180,630 630,840 840,1140 1140,1770
the actually {} physical representation
实际上，表的物理表示只由一个页面组成。

1234
00:39:40,470 --> 00:39:41,460
0,90 90,210 210,510 510,690 690,990
of that table just consist

1235
00:39:41,460 --> 00:39:42,640
0,90 90,150 150,420 420,840
of a single page.|
|

1236
00:39:43,180 --> 00:39:44,680
0,120 120,210 210,330 330,570 930,1500
And this sort of example
这是一个非常简单的例子，

1237
00:39:44,680 --> 00:39:46,030
0,210 210,420 420,540 540,840 870,1350
of one of the very

1238
00:39:46,030 --> 00:39:46,930
0,270 270,630 630,690 690,840 840,900
simple example,| of one of
|你可以做一件很酷的事情，

1239
00:39:46,930 --> 00:39:48,010
0,240 270,540 540,870 870,990 990,1080
the cool things you can

1240
00:39:48,010 --> 00:39:51,070
0,420 570,1620 1800,2220 2220,2760 2760,3060
do,| {} if these virtual
|如果这些虚拟内存原语对用户应用程序可用。

1241
00:39:51,070 --> 00:39:52,720
0,330 330,690 690,1230 1230,1380 1380,1650
memory primitives available to user

1242
00:39:52,720 --> 00:39:53,900
0,750
applications.|
|

1243
00:39:56,430 --> 00:39:58,280
0,450 450,810 810,990 990,1320
Any questions about this?|
对于这个，有什么问题吗？|

1244
00:39:58,790 --> 00:40:00,170
0,240 240,570 570,870 870,1200 1200,1380
Could you just quickly go
您能不能快速地复习一下最后一点，

1245
00:40:00,170 --> 00:40:02,630
0,600 630,870 870,1320 1710,2010 2010,2460
over that {} last point,|
|

1246
00:40:02,930 --> 00:40:04,040
0,150 150,510 510,750 750,900 900,1110
on why there's only one
为什么只有一个物理页，

1247
00:40:04,040 --> 00:40:05,120
0,300 300,570 570,690 690,780 780,1080
physical page,| {} I guess
|我想我当时在想，

1248
00:40:05,120 --> 00:40:06,320
0,330 330,480 480,870 870,1080 1080,1200
I was thinking during it,|
|

1249
00:40:06,320 --> 00:40:07,820
0,180 180,450 660,840 840,1170 1170,1500
like oh this sounds similar
这听起来有点像懒分配，

1250
00:40:07,820 --> 00:40:10,010
0,390 420,960 960,1500 1500,1980 2010,2190
to lazy allocation,| why, why
|为什么会不同，

1251
00:40:10,010 --> 00:40:10,910
0,120 120,210 210,540 540,660 660,900
is it different| and I
|我想那回答了我的问题，

1252
00:40:10,910 --> 00:40:11,990
0,180 180,480 480,750 750,810 810,1080
think that answered my question,|
|

1253
00:40:11,990 --> 00:40:12,830
0,90 90,360 360,450 450,630 630,840
but I I didn't quite
但是我不太明白，

1254
00:40:12,830 --> 00:40:14,540
0,480 840,1170 1170,1290 1290,1500 1500,1710
follow,| why we ended up.|
|为什么我们最终。|

1255
00:40:15,240 --> 00:40:16,590
0,420 420,720 720,1020 1020,1200 1200,1350
Okay, the reason,| okay, so
好的，原因是，|好的，所以当我们开始设置的时候，

1256
00:40:16,590 --> 00:40:17,700
0,210 210,540 540,840 840,1020 1020,1110
when we start when we

1257
00:40:17,700 --> 00:40:19,800
0,180 180,420 420,870 870,1830 1860,2100
set it up,| we have
|我们没有页面，

1258
00:40:19,800 --> 00:40:22,020
0,180 180,750 1410,1890 1890,1980 1980,2220
no pages,| {setup_sqrt_region - -
|setup_sqrt_region 分配地址空间，

1259
00:40:22,020 --> 00:40:24,720
0,180 180,540 540,1080 1410,2250 2310,2700
- -} actually allocates address

1260
00:40:24,720 --> 00:40:26,640
0,600 630,840 840,1410 1410,1740 1740,1920
space,| but then unmap all
|但是立即 unmap 地址关联的所有物理内存。

1261
00:40:26,640 --> 00:40:28,800
0,90 90,720 720,1200 1200,1830 1830,2160
the physical memory associated with

1262
00:40:28,830 --> 00:40:30,720
0,420 420,780 780,1440
that address immediately.|
|

1263
00:40:30,940 --> 00:40:32,380
0,390 390,510 510,750 750,870 870,1440
So the point of startup,|
所以，在启动点，|

1264
00:40:32,410 --> 00:40:34,030
0,270 270,510 510,870 870,1170 1170,1620
there's no physical pages allocated
没有物理页分配给这个特定的表。

1265
00:40:34,030 --> 00:40:35,540
0,90 90,240 240,540 540,960
to this particular table.|
|

1266
00:40:35,690 --> 00:40:36,960
0,150 150,270 270,390 390,720
Does that make sense?|
这能理解吗？|

1267
00:40:39,160 --> 00:40:40,750
0,450 870,1140 1140,1320 1320,1410 1410,1590
Yeah.| Okay, then we get,
是的。|好的，然后我们遇到页面错误时，

1268
00:40:40,750 --> 00:40:41,530
0,210 210,300 300,420 420,480 480,780
when we get a page

1269
00:40:41,530 --> 00:40:42,600
0,480
fault,|
|

1270
00:40:42,600 --> 00:40:43,590
0,120 120,330 330,570 570,720 720,990
that means there's like one
这意味着整个表中有一页，

1271
00:40:43,590 --> 00:40:44,310
0,270 270,390 390,450 450,510 510,720
page out of the whole

1272
00:40:44,310 --> 00:40:45,750
0,420 420,960 960,1080 1080,1230 1230,1440
table,| that we have not
|我们没有映射，

1273
00:40:45,750 --> 00:40:46,860
0,270 270,540 540,660 660,930 930,1110
map,| we have map no
|我们没有映射页面，

1274
00:40:46,860 --> 00:40:48,510
0,540 690,1200 1200,1290 1290,1440 1440,1650
pages,| but we're gonna page
|但我们遇到页面错误，

1275
00:40:48,510 --> 00:40:49,440
0,240 240,390 390,480 480,630 630,930
fault,| now we're gonna map
|现在我们映射一个页面，

1276
00:40:49,440 --> 00:40:50,680
0,240 240,750
one page,|
|

1277
00:40:50,920 --> 00:40:52,210
0,540 540,720 720,870 870,1050 1050,1290
and in that one page,|
在这一页里，|

1278
00:40:52,210 --> 00:40:52,870
0,90 90,210 210,300 300,540 540,660
we're going to fill in|
我们要填上，|

1279
00:40:52,870 --> 00:40:54,130
0,510 510,600 600,780 780,900 900,1260
whatever you know the square
平方根 i ， i 加 1 ，或 i 加其他值，

1280
00:40:54,130 --> 00:40:55,360
0,240 240,570 570,690 690,1050 1050,1230
root of i, i plus

1281
00:40:55,360 --> 00:40:56,800
0,300 300,480 480,720 720,1110 1110,1440
one, i plus whatever,| just
|只提供那一页。

1282
00:40:56,800 --> 00:40:58,180
0,120 120,390 390,570 570,930 930,1380
gonna afford that particular page.|
|

1283
00:40:59,960 --> 00:41:01,400
0,450 450,840 840,1050 1050,1200 1200,1440
And then, if we had
然后，如果我们有一个页面映射，

1284
00:41:01,400 --> 00:41:02,600
0,30 30,300 300,780 900,1140 1140,1200
a page map,| which in
|在这种情况下，第一次，我们没有，

1285
00:41:02,600 --> 00:41:03,470
0,150 150,390 390,480 480,690 690,870
this case, the first time

1286
00:41:03,470 --> 00:41:05,300
0,240 240,330 330,810 1200,1620 1620,1830
around, we didn't,| {} there's
|就没什么可做的。

1287
00:41:05,300 --> 00:41:06,500
0,180 180,270 270,330 330,630
nothing to be done.|
|

1288
00:41:06,880 --> 00:41:08,860
0,150 150,660 660,990 990,1410 1410,1980
So now the application runs,|
所以，现在应用程序运行，|

1289
00:41:08,860 --> 00:41:09,910
0,120 120,300 300,660 660,930 930,1050
you know and look up
在平方根表中查找更多条目页面，

1290
00:41:09,910 --> 00:41:11,470
0,120 120,330 330,810 810,1140 1140,1560
some more entries page in

1291
00:41:11,470 --> 00:41:12,970
0,360 390,750 750,900 900,1290 1350,1500
the square root table| and
|可能会得到另一个页面错误，

1292
00:41:12,970 --> 00:41:14,320
0,90 90,240 240,510 510,780 780,1350
may get another page table

1293
00:41:14,320 --> 00:41:15,910
0,270 270,600 600,810 810,1170 1260,1590
for another page fault,| because
|因为它查找的平方根条目，

1294
00:41:15,910 --> 00:41:16,510
0,60 60,150 150,390 390,570 570,600
it was looking up a

1295
00:41:16,510 --> 00:41:17,860
0,360 360,570 570,900 900,1080 1080,1350
square root entry,| that actually
|实际上不在分配的页面上。

1296
00:41:17,860 --> 00:41:19,120
0,60 60,600 600,690 690,780 780,1260
is not on the allocated

1297
00:41:19,120 --> 00:41:19,960
0,450
page.|
|

1298
00:41:20,080 --> 00:41:21,100
0,510
Okay?|
好的？|

1299
00:41:21,100 --> 00:41:21,850
0,120 120,300 300,510 510,600 600,750
So that point, we get
所以在这一点上，我们得到了另一个页面错误，

1300
00:41:21,850 --> 00:41:23,360
0,270 270,510 510,960
another page fault,|
|

1301
00:41:23,420 --> 00:41:24,920
0,390 390,960 960,1080 1080,1440 1440,1500
and then we allocate a
然后我们分配第二个页面，

1302
00:41:24,920 --> 00:41:27,620
0,270 270,810 990,1680 1680,2070 2070,2700
second page,| {} we calculate
|我们对特定的页面计算平方根，

1303
00:41:27,620 --> 00:41:28,670
0,150 150,480 480,870 870,960 960,1050
the square roots you know

1304
00:41:28,670 --> 00:41:30,170
0,90 90,270 270,630 630,1110 1320,1500
for that particular page,| and
|然后我们 unmap 最后一页。

1305
00:41:30,170 --> 00:41:31,250
0,360 360,540 540,750 750,990 990,1080
then we {unmap -} the

1306
00:41:31,250 --> 00:41:32,500
0,330 330,750
last page.|
|

1307
00:41:33,500 --> 00:41:34,610
0,180 180,480 480,690 690,1020 1020,1110
These {is,of,course} like practice you
当然，在实践中，你永远不会这样做，

1308
00:41:34,610 --> 00:41:35,810
0,90 90,270 270,420 420,780 960,1200
would never do this,| in
|在实践中，你可能会保留一组工作页面或类似的内容，

1309
00:41:35,810 --> 00:41:36,710
0,360 360,480 480,600 600,780 780,900
practice you would try to

1310
00:41:36,710 --> 00:41:37,970
0,240 240,480 480,870 870,1140 1140,1260
keep a working set of

1311
00:41:37,970 --> 00:41:38,930
0,240 240,300 300,660 660,720 720,960
set of pages or something

1312
00:41:38,930 --> 00:41:40,220
0,150 150,420 720,990 990,1170 1170,1290
like that,| but just to
|但为了表明你可以走得相当极端，

1313
00:41:40,220 --> 00:41:41,690
0,690 720,990 990,1110 1110,1260 1260,1470
show that you can go

1314
00:41:41,690 --> 00:41:42,950
0,240 240,780 780,930 930,1050 1050,1260
pretty extreme,| that you can
|你可以用一页内存来表示很大的表，

1315
00:41:42,950 --> 00:41:44,930
0,600 600,810 810,1110 1110,1680 1740,1980
represent like huge page, {}

1316
00:41:44,960 --> 00:41:46,280
0,450 450,840 840,990 990,1050 1050,1320
huge table with a single

1317
00:41:46,280 --> 00:41:47,900
0,300 300,390 390,840 900,1350 1350,1620
page of memory,| {} this
|这个特定代码片段 unmap 最后一个页面，

1318
00:41:47,900 --> 00:41:49,340
0,420 420,750 750,810 810,1170 1170,1440
particular fragment of code {unmaps

1319
00:41:49,340 --> 00:41:50,930
0,390 390,570 570,1050 1110,1440 1440,1590
-} that last one but

1320
00:41:50,930 --> 00:41:52,040
0,270 270,750
last page,|
|

1321
00:41:52,900 --> 00:41:54,370
0,120 120,270 270,450 450,750 1080,1470
then it keeps running.| So,
然后它继续运行。|所以，在任何时间点，

1322
00:41:54,370 --> 00:41:56,470
0,420 420,960 960,1530 1530,1890 1890,2100
any point instance, at any

1323
00:41:56,470 --> 00:41:57,760
0,240 240,300 300,870 900,1080 1080,1290
point of time,| there's only
|只有一个物理页面在使用。

1324
00:41:57,760 --> 00:41:59,560
0,510 510,870 870,1140 1140,1320 1320,1800
one physical page being used.|
|

1325
00:42:02,880 --> 00:42:04,710
0,150 150,300 300,660 660,1110 1290,1830
Does that answer your question?|
这回答了你的问题吗？|

1326
00:42:06,800 --> 00:42:07,730
0,150 150,270 270,420 420,600 600,930
Yeah, I think so, thank
是的，我想是的，谢谢。

1327
00:42:07,730 --> 00:42:09,540
0,120 570,1290
you.| {Okay,good}.|
|好的。|

1328
00:42:09,810 --> 00:42:11,400
0,270 270,450 450,810 990,1260 1260,1590
It's just like, it's more
它就像，

1329
00:42:11,400 --> 00:42:13,320
0,420 1200,1440 1440,1500 1500,1770 1770,1920
like,| this is clearly not
|这显然不是你在实践中会做的事情，

1330
00:42:13,320 --> 00:42:13,890
0,210 210,300 300,390 390,480 480,570
something you would do in

1331
00:42:13,890 --> 00:42:15,330
0,390 390,570 570,720 720,930 930,1440
practice,| maybe there's more to
|也许更多是可以让你知道原语的力量，

1332
00:42:15,330 --> 00:42:17,130
0,630 660,810 810,1320 1350,1470 1470,1800
show you know the power

1333
00:42:17,130 --> 00:42:18,000
0,90 90,180 180,690 690,780 780,870
of the primitives,| you know
|你可以使用一个物理页面表示这个巨大的表。

1334
00:42:18,000 --> 00:42:19,050
0,180 180,270 270,390 390,870 870,1050
that you can represent the

1335
00:42:19,080 --> 00:42:20,820
0,690 690,1050 1050,1260 1260,1470 1470,1740
gigantic table using one single

1336
00:42:20,820 --> 00:42:21,920
0,270 270,690
physical page.|
|

1337
00:42:24,690 --> 00:42:26,100
0,240 240,390 390,900
Any other questions?|
还有其他问题吗？|

1338
00:42:30,130 --> 00:42:31,740
0,510 540,1140
Okay, {}
好的，接下来我想做的是，

1339
00:42:32,300 --> 00:42:33,170
0,300 300,390 390,660 660,810 810,870
what I would like to

1340
00:42:33,170 --> 00:42:34,460
0,180 180,480 480,690 690,1050 1050,1290
do next then is| talk
|讨论一下另一个例子，

1341
00:42:34,460 --> 00:42:36,230
0,210 210,450 450,1110 1320,1710 1710,1770
about another example,| and in
|特别我想讨论一下垃圾收集器，

1342
00:42:36,230 --> 00:42:36,950
0,330 330,360 360,510 510,570 570,720
particular I want to talk

1343
00:42:36,950 --> 00:42:39,380
0,240 240,840 1140,1920
about the {}

1344
00:42:39,410 --> 00:42:40,700
0,330 330,780
garbage collector,|
|

1345
00:42:40,960 --> 00:42:41,710
0,300 300,390 390,480 480,690 690,750
{} you know since a
因为很多问题都是关于垃圾收集器的。

1346
00:42:41,710 --> 00:42:42,700
0,120 120,180 180,540 540,780 780,990
lot of questions were about

1347
00:42:42,700 --> 00:42:44,020
0,90 90,360 360,840
the garbage collector.|
|

1348
00:42:58,990 --> 00:43:00,790
0,150 150,270 270,780 780,1020 1260,1800
And so you know yeah,
所以，垃圾收集器是一种方式，

1349
00:43:00,790 --> 00:43:03,130
0,120 120,600 810,1110 1110,1500 1500,2340
so the garbage collectors are

1350
00:43:03,130 --> 00:43:04,720
0,120 150,570 570,660 660,1230 1230,1590
a way of| basically {}
|对于编程语言，

1351
00:43:04,870 --> 00:43:07,240
0,900 960,1380 1410,1800 1800,2250 2250,2370
for {} programming languages| or
|或者做内存分配和清除的语言，

1352
00:43:07,240 --> 00:43:09,250
0,390 390,510 510,1110 1110,1680 1710,2010
languages that basically {} do

1353
00:43:09,250 --> 00:43:11,950
0,330 330,1170 1170,1470 1470,1980 2190,2700
memory allocation and freeing| on
|对于程序员的行为，

1354
00:43:11,950 --> 00:43:13,120
0,360 360,420 420,510 510,990 990,1170
behalf of the programmer,| so
|所以程序员不需要调用，

1355
00:43:13,120 --> 00:43:14,110
0,120 120,510 510,720 720,900 900,990
the programmer doesn't have to

1356
00:43:14,110 --> 00:43:15,910
0,420 690,1170 1170,1620 1620,1710 1710,1800
call,| like C {correct -}
|必须 C 必须调用 malloc ，

1357
00:43:15,910 --> 00:43:16,870
0,360 360,690 690,780 780,870 870,960
{you,have,to,call} malloc| and then you
|然后必须显式调用 free 来释放内存，

1358
00:43:16,870 --> 00:43:17,980
0,90 90,150 150,300 300,570 570,1110
have to call free explicitly

1359
00:43:17,980 --> 00:43:20,440
0,120 120,390 390,840 1140,1680 1800,2460
to {free,the} memory,| {} languages
|使用垃圾收集器的语言，

1360
00:43:20,440 --> 00:43:22,210
0,120 120,330 330,600 600,1140 1200,1770
that use garbage collectors,| basically
|应用程序只需要调用 malloc ，

1361
00:43:22,210 --> 00:43:25,090
0,120 120,660 660,990 990,2310 2550,2880
the application only has, only

1362
00:43:25,510 --> 00:43:27,340
0,420 420,1260 1320,1590 1590,1740 1740,1830
basically {call,malloc},| never has to
|再也不用担心释放内存的问题，

1363
00:43:27,340 --> 00:43:28,330
0,300 300,450 450,690 690,930 930,990
worry about actually freeing the

1364
00:43:28,330 --> 00:43:29,980
0,420 510,930 930,1020 1020,1350 1350,1650
memory,| basically the garbage collector
|垃圾收集器将做这个工作，

1365
00:43:29,980 --> 00:43:30,700
0,120 120,240 240,360 360,660 660,720
will do the work| to
|确定内存是否仍在使用，

1366
00:43:30,700 --> 00:43:31,930
0,510 510,630 630,720 720,1020 1020,1230
determine if the memory still

1367
00:43:31,930 --> 00:43:32,680
0,120 120,240 240,540 540,660 660,750
is in use,| and if
|如果内存没有使用，

1368
00:43:32,680 --> 00:43:33,310
0,90 90,300 300,360 360,540 540,630
the memory is not in

1369
00:43:33,310 --> 00:43:35,170
0,390 480,960 960,1080 1080,1650 1650,1860
use,| then it's actually a
|那么它释放它。

1370
00:43:35,170 --> 00:43:35,940
0,210 210,480
free it.|
|

1371
00:43:36,360 --> 00:43:37,920
0,180 180,240 240,420 420,900 900,1560
And so it's nice, {}|
所以这很好，|

1372
00:43:37,920 --> 00:43:39,210
0,120 120,630 750,1080 1080,1110 1110,1290
you know what are some
你知道哪些编程语言带有垃圾收集器？

1373
00:43:39,210 --> 00:43:40,770
0,330 330,720 720,1170 1170,1350 1350,1560
example programming languages that have

1374
00:43:40,770 --> 00:43:42,160
0,270 270,840
garbage collectors?|
|

1375
00:43:43,590 --> 00:43:46,860
0,600 960,1890 1920,2670 2670,2790 2790,3270
Java.| {Yeah,,java} python, you know,
Java 。|是的， java python Go 它们中的许多都是，

1376
00:43:47,790 --> 00:43:49,380
0,810 810,1050 1050,1110 1110,1260 1260,1590
Go, many of them actually

1377
00:43:49,380 --> 00:43:51,240
0,360 420,930 1200,1500 1500,1650
correct,| almost you know
|几乎除了 C 和 Rust ，

1378
00:43:51,240 --> 00:43:52,680
0,240 240,360 360,630 630,930 930,1440
other than maybe C Rust,|
|

1379
00:43:52,740 --> 00:43:54,240
0,390 420,1050 1110,1320 1320,1410 1410,1500
{} there {} {every -}
其他每种编程语言都有一个垃圾收集器，

1380
00:43:54,240 --> 00:43:55,350
0,60 60,150 150,540 540,780 780,1110
{other -} programming language basically

1381
00:43:55,350 --> 00:43:57,120
0,240 240,300 300,570 570,960 1290,1770
has a garbage collector.| Okay?|
|好的？|

1382
00:43:57,240 --> 00:43:58,650
0,270 270,420 420,780 780,870 870,1410
So as you can imagine,|
所以正如你可以想象的，|

1383
00:43:58,680 --> 00:44:01,080
0,240 240,420 420,870 870,1590 1650,2400
there's a huge literature and
垃圾收集器有非常多的文献和设计空间，

1384
00:44:01,110 --> 00:44:03,000
0,510 510,930 930,1440 1440,1590 1590,1890
a design space for garbage

1385
00:44:03,000 --> 00:44:04,830
0,510 750,1110 1110,1500 1500,1620 1620,1830
collectors| {} and the point
|这篇论文的重点不是

1386
00:44:04,830 --> 00:44:05,670
0,60 60,180 180,450 450,510 510,840
of this paper is not|
|

1387
00:44:05,670 --> 00:44:06,840
0,210 210,750 750,900 900,960 960,1170
like to use the best
尽可能使用最好的垃圾收集器，

1388
00:44:06,840 --> 00:44:08,070
0,300 300,570 570,1050 1050,1170 1170,1230
garbage collector possible,| but {}
|但这里说明了，

1389
00:44:08,070 --> 00:44:10,260
0,480 480,780 780,1140 1140,1770 1920,2190
here {you,know} basically illustrate| if
|如果垃圾收集器可以利用

1390
00:44:10,260 --> 00:44:11,670
0,300 300,600 600,780 780,960 960,1410
garbage collectors could take advantage

1391
00:44:11,670 --> 00:44:12,870
0,540 570,660 660,780 780,960 960,1200
of| you know these user
|这些用户级别的内存原语。

1392
00:44:12,870 --> 00:44:14,310
0,270 270,330 330,540 540,870 870,1440
level of the memory primitives.|
|

1393
00:44:15,690 --> 00:44:17,400
0,300 300,420 420,510 510,1410 1410,1710
And so the particular garbage
所以，论文中讨论的特殊垃圾收集器是复制垃圾收集器。

1394
00:44:17,400 --> 00:44:19,350
0,240 240,330 330,570 570,1230 1410,1950
colloctor the paper discusses is

1395
00:44:19,350 --> 00:44:21,440
0,180 180,630 630,960 960,1470
{} copying garbage collector.|
|

1396
00:44:31,690 --> 00:44:33,160
0,450 450,510 510,900 900,1350 1350,1470
And the basical plan is
基本方案是，

1397
00:44:33,160 --> 00:44:34,240
0,210 210,360 360,540 540,630 630,1080
sort of| you know the
|顶层大纲如下所示，

1398
00:44:34,270 --> 00:44:35,980
0,300 300,510 510,1140 1170,1590 1590,1710
top level outline {} is

1399
00:44:35,980 --> 00:44:37,870
0,90 90,660 870,1260 1260,1560 1560,1890
as follows| {} {you,know} basically
|有一个内存，

1400
00:44:37,870 --> 00:44:39,580
0,420 450,570 570,1230
have a memory,|
|

1401
00:44:39,700 --> 00:44:41,380
0,120 120,600 960,1140 1140,1410 1410,1680
a heap from which {you,know}
一个从内存中分配的堆，

1402
00:44:41,380 --> 00:44:43,150
0,330 330,390 390,1020 1170,1410 1410,1770
memory is allocated,| you divide
|你将堆中的内存分成两部分，

1403
00:44:43,150 --> 00:44:44,650
0,420 450,990 990,1140 1140,1260 1260,1500
the memory {} the heap

1404
00:44:44,650 --> 00:44:46,780
0,360 360,990 1410,1680 1680,2010 2010,2130
{in,two} pieces,| {} one is
|一种是 from 部分，

1405
00:44:46,780 --> 00:44:48,120
0,90 90,360 360,930
the from piece,|
|

1406
00:44:48,490 --> 00:44:49,330
0,270 270,330 330,540 540,750 750,840
what the paper calls the
也就是论文中所说的 from 空间，

1407
00:44:49,330 --> 00:44:51,130
0,540 540,1080 1230,1440 1440,1500 1500,1800
from space| and the other
|另一个是 to 空间。

1408
00:44:51,130 --> 00:44:52,620
0,150 150,270 270,450 450,960
is the to space.|
|

1409
00:44:53,490 --> 00:44:55,650
0,720 870,1440 1470,1740 1740,1950 1950,2160
And, {} let's say we're
假设我们开始使用应用程序，

1410
00:44:55,650 --> 00:44:57,360
0,210 210,870 870,1110 1140,1650 1650,1710
having started with applications to

1411
00:44:57,360 --> 00:44:58,830
0,570 600,900 900,1080 1080,1260 1260,1470
start| {} and so all
|所有的内存都是空闲的，

1412
00:44:58,830 --> 00:45:00,570
0,330 330,420 420,840 960,1440 1440,1740
memory is free,| basically start
|开始在 from 空间中分配内存，

1413
00:45:00,570 --> 00:45:02,220
0,390 390,900 900,1140 1140,1410 1410,1650
allocating memory in the from

1414
00:45:02,220 --> 00:45:03,780
0,510 570,810 810,1020 1020,1260 1260,1560
space,| so let's say we
|假设我们分配了树状数据结构，

1415
00:45:03,780 --> 00:45:05,080
0,750
allocated

1416
00:45:05,080 --> 00:45:07,180
0,630 840,1050 1050,1260 1260,1470 1470,2100
maybe tree like data structure,|
|

1417
00:45:07,450 --> 00:45:08,920
0,150 150,420 420,900 900,1260 1260,1470
you know that here's the
你知道这是 root ，

1418
00:45:08,950 --> 00:45:10,120
0,630
root,|
|

1419
00:45:11,260 --> 00:45:12,190
0,150 150,240 240,600 600,780 780,930
so the tree and that
树可能有一个指向其他对象的指针，

1420
00:45:12,190 --> 00:45:14,200
0,300 300,570 570,630 630,1320 1590,2010
maybe has a pointer to

1421
00:45:14,200 --> 00:45:16,270
0,360 360,1020 1350,1710 1710,1890 1890,2070
another object,| and that {maybe
|它可能有一个指向其他对象的指针，

1422
00:45:16,270 --> 00:45:17,380
0,210 210,420 420,450 450,900 900,1110
-} has a pointer to

1423
00:45:17,380 --> 00:45:18,550
0,390 390,810 810,930 930,1080 1080,1170
another object,| and that is
|root 也指向它，

1424
00:45:18,550 --> 00:45:19,510
0,210 210,540 540,660 660,840 840,960
also pointed to by the

1425
00:45:19,510 --> 00:45:21,160
0,360 600,1140
root,| {sort,of}
|像是带着一堆东西的环。

1426
00:45:22,080 --> 00:45:23,800
0,210 210,330 330,360 360,1140
just for a {little,cicle}

1427
00:45:23,890 --> 00:45:25,740
0,240 240,750 750,1290
with of objects.|
|

1428
00:45:25,740 --> 00:45:27,660
0,720 870,1230 1230,1320 1320,1800 1800,1920
And maybe the application we
也许我们引入的应用程序也有很多其他的内存，

1429
00:45:27,660 --> 00:45:28,830
0,570 600,690 690,900 900,960 960,1170
introduced a lot of other

1430
00:45:28,830 --> 00:45:30,450
0,330 330,870 960,1290 1290,1440 1440,1620
memory too,| {} but there's
|但已经没有任何东西指向它了，

1431
00:45:30,450 --> 00:45:31,950
0,540 540,840 840,1230 1230,1380 1380,1500
{nothing -} pointing to it

1432
00:45:31,950 --> 00:45:33,450
0,480 840,990 990,1080 1080,1440 1440,1500
anymore| and so basically the
|所以，唯一活的对象是这些，

1433
00:45:33,450 --> 00:45:35,760
0,360 360,930 960,1830 1830,2220 2220,2310
only objects live objects are

1434
00:45:35,760 --> 00:45:36,600
0,60 60,330 330,420 420,720 720,840
the ones,| that actually are
|可以从 root 访问。

1435
00:45:36,600 --> 00:45:38,130
0,360 360,930 930,1110 1110,1170 1170,1530
basically accessible from the root.|
|

1436
00:45:38,840 --> 00:45:40,820
0,270 270,360 360,540 540,990 1440,1980
So at some point,| like
所以在某种程度上，|比如我可能已经分配了很多内存，

1437
00:45:40,820 --> 00:45:41,960
0,300 300,450 450,870 870,1080 1080,1140
maybe I've allocated lots of

1438
00:45:41,960 --> 00:45:44,630
0,390 390,1020 1230,2100 2220,2340 2340,2670
memory before| and we allocate
|我们再分配一个对象，

1439
00:45:44,630 --> 00:45:46,100
0,150 150,450 450,990 990,1350 1350,1470
one more object,| and it
|结果就没有空间了，

1440
00:45:46,100 --> 00:45:47,150
0,240 240,390 390,600 600,690 690,1050
turns out there's no space

1441
00:45:47,150 --> 00:45:48,830
0,480 780,1290 1290,1350 1350,1590 1590,1680
anymore,| application {} ask for
|应用程序要求再添加一个对象，

1442
00:45:48,830 --> 00:45:50,270
0,180 180,540 570,1140 1140,1260 1260,1440
one more object,| it turns
|结果发现已经没有空间了，

1443
00:45:50,270 --> 00:45:51,350
0,120 120,300 300,420 420,720 720,1080
out there's no space anymore

1444
00:45:51,350 --> 00:45:52,280
0,210 210,270 270,540 540,630 630,930
for it,| because the whole
|因为整个 from 空间都被使用了。

1445
00:45:52,280 --> 00:45:53,990
0,270 270,780 780,1170 1200,1470 1470,1710
from space basically has been

1446
00:45:53,990 --> 00:45:54,840
0,480
used.|
|

1447
00:45:55,580 --> 00:45:56,810
0,240 240,450 450,540 540,780 780,1230
So then the basic idea
所以基本的想法是复制垃圾收集器，

1448
00:45:56,810 --> 00:45:57,980
0,120 120,240 240,510 510,780 780,1170
is in this a copying

1449
00:45:57,980 --> 00:45:59,870
0,420 420,780 780,930 930,1290 1440,1890
garbage collector| is to take
|获取对象，

1450
00:45:59,870 --> 00:46:01,580
0,120 120,780 960,1110 1110,1500 1500,1710
the objects| and copy them
|并将其复制到用户的 to 空间，

1451
00:46:01,580 --> 00:46:04,550
0,510 510,1620 1740,2160 2160,2460 2460,2970
over {} to the user

1452
00:46:04,580 --> 00:46:06,020
0,150 150,390 420,570 570,1110 1140,1440
to the to space| and
|你这样做的方式是，

1453
00:46:06,020 --> 00:46:06,920
0,120 120,390 390,630 630,720 720,900
the way you do it

1454
00:46:06,920 --> 00:46:07,820
0,120 120,270 270,600 600,810 810,900
is| you start from the
|你从 root 开始，

1455
00:46:07,820 --> 00:46:10,580
0,420 420,840 1740,1980 1980,2550 2550,2760
root,| because every application where
|因为每个应用程序有一组寄存器，

1456
00:46:10,580 --> 00:46:11,810
0,420 420,930 930,990 990,1170 1170,1230
every has a set of

1457
00:46:11,810 --> 00:46:14,090
0,660 660,1080 1080,1440 1440,1800 2040,2280
registers,| where basically this top
|顶层指针保存的位置，

1458
00:46:14,090 --> 00:46:15,680
0,210 210,570 570,630 630,1140
level pointers are stored,|
|

1459
00:46:15,680 --> 00:46:17,480
0,210 210,480 480,870 870,1230 1230,1800
{} or maybe there's a
或者可能堆栈上有局部变量，

1460
00:46:17,600 --> 00:46:19,250
0,570 570,1020 1020,1110 1110,1200 1200,1650
local variables on the stack,|
|

1461
00:46:19,490 --> 00:46:20,840
0,600 600,900 900,1050 1050,1140 1140,1350
{} basically there's a set
基本上有一组 root ，

1462
00:46:20,840 --> 00:46:22,070
0,90 90,570 780,960 960,1080 1080,1230
of root| and there for
|为了简单起见，我假设只有一个 root ，

1463
00:46:22,070 --> 00:46:23,000
0,510 510,630 630,750 750,870 870,930
simplicity, I'm just going to

1464
00:46:23,000 --> 00:46:24,290
0,210 210,360 360,570 570,960 1140,1290
assume there's one root| and
|你从顶层开始追踪。

1465
00:46:24,290 --> 00:46:25,670
0,60 60,390 390,900 900,1260 1260,1380
you start tracing basically from

1466
00:46:25,670 --> 00:46:27,230
0,60 60,330 330,660 1020,1440 1440,1560
the top level.| So you
|所以你把 root 对象复制到 to 空间，

1467
00:46:27,230 --> 00:46:28,730
0,450 480,720 810,1170 1170,1290 1290,1500
know you copy the root

1468
00:46:28,730 --> 00:46:30,800
0,540 540,1290 1290,1350 1350,1530 1530,2070
object {over,to} the to space,|
|

1469
00:46:32,460 --> 00:46:34,170
0,660 840,960 960,1260 1260,1470 1470,1710
and you know { -}
这是你在这一点上唯一要做的事，

1470
00:46:34,170 --> 00:46:35,280
0,360 360,720 720,810 810,990 990,1110
and that's the only thing

1471
00:46:35,280 --> 00:46:36,120
0,90 90,210 210,270 270,420 420,840
you do at that point|
|

1472
00:46:36,150 --> 00:46:37,140
0,240 240,660 690,780 780,900 900,990
and then you know of
然后，当然，叶子指针，

1473
00:46:37,140 --> 00:46:38,160
0,210 210,360 360,720 720,900 900,1020
course that leaves {you,know} the

1474
00:46:38,160 --> 00:46:39,360
0,690
pointers|
|

1475
00:46:39,760 --> 00:46:41,200
0,180 180,450 450,870 870,1050 1050,1440
{you,know} still pointing to whatever
仍然指向它们以前的物体。

1476
00:46:41,200 --> 00:46:43,390
0,480 480,900 900,1260 1260,1530 1530,2190
objects they were there before.|
|

1477
00:46:46,440 --> 00:46:47,250
0,150 150,420 420,510 510,660 660,810
And then you're gonna want
然后你想要把物体复制过来，

1478
00:46:47,250 --> 00:46:48,270
0,90 90,360 360,480 480,780 780,1020
to copy the object over,|
|

1479
00:46:48,270 --> 00:46:49,770
0,120 120,540 540,720 720,1290 1290,1500
you go and inspect, we
你检查，我们扫描物体，

1480
00:46:49,770 --> 00:46:51,600
0,390 390,480 480,1080 1230,1710 1710,1830
scan the object,| then of
|当然，语言运行时确切地知道

1481
00:46:51,600 --> 00:46:52,770
0,270 270,360 360,690 690,990 990,1170
course the language runtime knows

1482
00:46:52,770 --> 00:46:54,360
0,630 630,930 930,1170 1170,1260 1260,1590
exactly| what type the object
|对象是什么类型，

1483
00:46:54,360 --> 00:46:55,050
0,180 180,300 300,480 480,630 630,690
is| and knows where the
|并且知道指向哪里，

1484
00:46:55,050 --> 00:46:56,730
0,330 330,690 1050,1200 1200,1410 1410,1680
points are| and just look
|查看那些指针，

1485
00:46:56,730 --> 00:46:57,720
0,60 60,240 240,630 630,720 720,990
at these pointers| and says
|然后说，也许我应该多复制一些指针过来，

1486
00:46:57,720 --> 00:46:59,310
0,240 240,870 870,1050 1050,1260 1260,1590
okay, maybe I should copy

1487
00:46:59,310 --> 00:47:00,400
0,120 120,630
some more

1488
00:47:00,780 --> 00:47:03,150
0,330 330,540 570,930 930,1440 1800,2370
{ -} pointers over {},|
|

1489
00:47:03,150 --> 00:47:04,440
0,300 300,540 540,810 810,960 960,1290
{} because those are actually
因为这些是线索，

1490
00:47:04,440 --> 00:47:05,700
0,300 300,750 750,900 900,990 990,1260
a clue,| you know part
|是活动数据结构的一部分。

1491
00:47:05,700 --> 00:47:06,810
0,60 60,150 150,420 420,630 630,1110
of the live data structure.|
|

1492
00:47:07,300 --> 00:47:08,470
0,120 120,270 270,810 810,1050 1050,1170
And so basically maybe we'll
所以我们可以选择顶层指针，

1493
00:47:08,470 --> 00:47:09,700
0,150 150,240 240,450 450,660 660,1230
take the top level pointer,|
|

1494
00:47:10,410 --> 00:47:11,550
0,360 360,420 420,540 540,1020 1020,1140
look at that object,| you
查看那个对象，|复制那个对象到 to 空间，

1495
00:47:11,550 --> 00:47:13,140
0,360 360,510 510,870 870,1410 1440,1590
copy that object over you

1496
00:47:13,140 --> 00:47:14,280
0,120 120,540
know to

1497
00:47:16,590 --> 00:47:18,750
0,330 330,510 510,660 660,1290 1530,2160
{} the to space,| updates
|更新这里的指针，

1498
00:47:18,750 --> 00:47:20,220
0,90 90,180 180,300 300,780 780,1470
you know the pointer here,|
|

1499
00:47:20,250 --> 00:47:21,240
0,150 150,270 270,420 420,690 690,990
you know to actually indicate
用来表示它在这里，

1500
00:47:21,240 --> 00:47:22,770
0,150 150,660 660,990 990,1170 1170,1530
that actually it has here|
|

1501
00:47:22,770 --> 00:47:24,510
0,270 570,1050 1050,1170 1170,1290 1290,1740
and pointing it to {you,know}
并将其指向对象的复制的版本。

1502
00:47:24,510 --> 00:47:25,890
0,420 420,720 720,810 810,900 900,1380
copied version of the object.|
|

1503
00:47:26,550 --> 00:47:28,440
0,210 210,510 510,570 570,960 1470,1890
And then of course,| later
然后，当然，|稍后我们需要记住，

1504
00:47:28,440 --> 00:47:29,490
0,240 240,360 360,510 510,600 600,1050
on we need to remember,|
|

1505
00:47:29,490 --> 00:47:31,140
0,120 120,240 240,420 420,600 630,1650
that we're actually this object
这个对象被复制了，

1506
00:47:31,140 --> 00:47:32,730
0,240 240,360 360,810 1110,1380 1380,1590
has been copied,| so you
|所以你看到一些额外的信息，

1507
00:47:32,730 --> 00:47:33,480
0,300 300,360 360,570 570,660 660,750
saw a little bit of

1508
00:47:33,480 --> 00:47:36,090
0,420 420,1080 1290,1770 1860,2460 2460,2610
extra information| and remember that
|记住这些对象现在仍然在那里工作，

1509
00:47:36,090 --> 00:47:37,110
0,150 150,600 600,690 690,810 810,1020
these objects are {} now

1510
00:47:37,110 --> 00:47:38,220
0,210 210,330 330,660
still work there,|
|

1511
00:47:39,620 --> 00:47:41,030
0,240 240,390 390,570 570,1260 1290,1410
{} in this process,| you
在这个过程中，|将对象从 from 空间移动到 to 空间，

1512
00:47:41,030 --> 00:47:42,830
0,150 150,480 480,690 690,960 1170,1800
know a sort of moving

1513
00:47:42,830 --> 00:47:44,960
0,90 90,510 510,780 780,1320 1830,2130
an object from the from

1514
00:47:44,960 --> 00:47:46,400
0,330 330,660 660,1050 1050,1170 1170,1440
space {to,the,to} space| and leaving
|并且在 from 空间中留下转发指针，称为转发。

1515
00:47:46,400 --> 00:47:48,080
0,90 90,510 510,1080 1290,1560 1560,1680
a forwarding pointer in the

1516
00:47:48,080 --> 00:47:49,700
0,240 240,810 990,1170 1170,1350 1350,1620
from space, {} is called

1517
00:47:49,700 --> 00:47:50,760
0,570
forwarding.|
|

1518
00:47:58,980 --> 00:48:00,580
0,300 300,450 450,540 540,1080
Okay, so we now,|
好的，所以我们现在，|

1519
00:48:00,580 --> 00:48:02,080
0,90 90,450 450,600 600,1020 1140,1500
so we did this,| we
所以我们做了这个，|我们修好这个指针，

1520
00:48:02,080 --> 00:48:03,380
0,270 270,750
did {}

1521
00:48:03,590 --> 00:48:04,940
0,390 390,570 570,1020 1020,1140 1140,1350
fix this pointer,| we fix
|我们修好那个指针，

1522
00:48:04,940 --> 00:48:06,620
0,210 210,780 930,1230 1230,1440 1440,1680
that pointer,| there's one more
|还剩下一个，

1523
00:48:06,620 --> 00:48:08,540
0,480 870,1260 1260,1560 1560,1740 1740,1920
left,| {} so we'll look
|所以我们看看那个对象，

1524
00:48:08,540 --> 00:48:11,180
0,210 210,390 390,1080 1110,1890 2310,2640
at that object| {} and
|然后像以前一样把它复制过来，

1525
00:48:11,180 --> 00:48:12,470
0,150 150,480 480,600 600,1080 1110,1290
we copy it over like

1526
00:48:12,470 --> 00:48:13,740
0,720
before,|
|

1527
00:48:13,800 --> 00:48:15,660
0,720 840,1140 1140,1380 1380,1620 1620,1860
{} and it still has
它仍然有一个指向这个对象的指针，

1528
00:48:15,660 --> 00:48:16,980
0,60 60,390 390,720 720,1050 1080,1320
a pointer pointing to this

1529
00:48:16,980 --> 00:48:18,240
0,570 600,750 750,990 990,1110 1110,1260
object,| so now we look
|所以现在我们看一下这个特定的指针，

1530
00:48:18,240 --> 00:48:19,770
0,90 90,270 270,930 930,1230 1230,1530
at that particular {pointer -},|
|

1531
00:48:19,800 --> 00:48:21,330
0,330 330,510 510,720 720,780 780,1530
look at pointer, say ah,
查看指针，它已经被复制了，

1532
00:48:21,330 --> 00:48:22,590
0,270 270,540 540,750 750,1050 1050,1260
that actually has already been

1533
00:48:22,590 --> 00:48:24,120
0,570 990,1140 1140,1200 1200,1440 1440,1530
copied| and in fact we
|事实上，我们知道新的位置在哪里，

1534
00:48:24,120 --> 00:48:25,260
0,180 180,390 390,480 480,630 630,1140
know what the new location

1535
00:48:25,260 --> 00:48:26,460
0,360 540,750 750,870 870,960 960,1200
is,| so we can just
|所以，我们可以直接更新指向正确的位置。

1536
00:48:26,460 --> 00:48:27,990
0,330 330,840 1050,1170 1170,1440 1440,1530
straight updated to point to

1537
00:48:27,990 --> 00:48:29,140
0,90 90,300 300,750
the right place.|
|

1538
00:48:30,720 --> 00:48:31,590
0,330 330,480 480,630 630,720 720,870
Okay, and so at this
好的，在这一点上，

1539
00:48:31,590 --> 00:48:33,060
0,510 540,660 660,780 780,960 960,1470
point,| you know all the
|所有的指针都被正确地更新了，

1540
00:48:33,090 --> 00:48:35,010
0,390 390,990 990,1080 1080,1290 1290,1920
pointers {have,been} you know {correctly

1541
00:48:35,010 --> 00:48:35,850
0,90 90,420 420,660 660,750 750,840
-} {updated -},| you know
|整个结构，整个环，

1542
00:48:35,850 --> 00:48:37,950
0,60 60,570 990,1770 1800,1950 1950,2100
the whole structure, you know

1543
00:48:37,950 --> 00:48:39,210
0,120 120,300 300,690 690,1140 1140,1260
the whole cycle,| basically of
|对象从 from 空间移动到 to 空间，

1544
00:48:39,210 --> 00:48:40,410
0,390 390,540 540,660 660,990 990,1200
objects as we move from

1545
00:48:40,410 --> 00:48:42,180
0,270 660,930 930,1140 1140,1440 1440,1770
the {} from space {to,to}

1546
00:48:42,180 --> 00:48:43,470
0,540 780,960 960,1080 1080,1140 1140,1290
space| and so at this
|所以，在这一点上，我们完成了。

1547
00:48:43,470 --> 00:48:44,620
0,240 240,330 330,630
point, we're done.|
|

1548
00:48:44,620 --> 00:48:46,520
0,1230

1549
00:48:46,760 --> 00:48:47,880
0,630

1550
00:48:53,930 --> 00:48:54,920
0,150 150,240 240,480 480,570 570,990
At this point, we're done,|
在这一点上，我们做完了，|

1551
00:48:54,980 --> 00:48:57,080
0,510 510,690 690,1200 1200,1380 1380,2100
{} we forwarded all the
我们转发了所有的对象，

1552
00:48:57,110 --> 00:48:59,750
0,690 930,1590 1800,2130 2130,2520 2520,2640
objects| and {} basically the
|基本上 from 空间，

1553
00:48:59,750 --> 00:49:01,160
0,240 240,630 630,930 930,1080 1080,1410
from space| now you know
|所有在 from 空间的对象都被丢弃了，

1554
00:49:01,160 --> 00:49:01,850
0,180 180,270 270,540 540,600 600,690
all the objects in the

1555
00:49:01,850 --> 00:49:03,290
0,180 180,450 450,570 570,750 750,1440
from space are being discarded,|
|

1556
00:49:07,520 --> 00:49:08,630
0,150 150,270 270,450 450,630 630,1110
and it's now free space.|
现在是空闲空间了。|

1557
00:49:17,070 --> 00:49:18,420
0,210 210,300 300,450 450,810
Does that make sense?|
这能理解吗？|

1558
00:49:19,360 --> 00:49:20,590
0,270 270,360 360,780 780,1080 1080,1230
That's the basic plan in
这是复制垃圾收集器的基本方案。

1559
00:49:20,590 --> 00:49:22,440
0,180 180,570 570,870 870,1350
a copying garbage collector.|
|

1560
00:49:23,540 --> 00:49:25,520
0,300 300,540 540,960 1260,1800 1800,1980
Okay, now the scheme that
好的，现在论文中使用的方案，

1561
00:49:25,520 --> 00:49:26,960
0,390 390,690 690,780 780,870 870,1440
is used in the paper,|
|

1562
00:49:27,320 --> 00:49:30,500
0,870 1410,1650 1650,2400 2400,2670
{} {there's,a,couple,of} {sophistications -},|
这里有几个复杂的东西，|

1563
00:49:30,760 --> 00:49:31,780
0,330 360,570 570,630 630,810 810,1020
I want to talk about
我想谈谈它们。

1564
00:49:31,780 --> 00:49:32,720
0,390
them.|
|

1565
00:49:34,680 --> 00:49:37,020
0,870 870,1800
First sophistication,|
第一个复杂的东西，|

1566
00:49:37,220 --> 00:49:38,960
0,120 120,600 900,1320 1320,1620 1620,1740
you know is that you
一种它们称为，

1567
00:49:38,960 --> 00:49:39,980
0,120 120,240 240,570 570,720 720,1020
know they actually they're called|
|

1568
00:49:39,980 --> 00:49:41,840
0,120 120,210 210,480 480,1080
this is called Baker's
被称为 Baker's 算法，

1569
00:49:42,150 --> 00:49:44,480
0,900 900,1140 1140,1770
algorithm,| {it's,an,old} algorithm,|
|这是一种老的算法，|

1570
00:49:44,770 --> 00:49:46,240
0,180 180,390 390,480 480,840
and one of the
其中一个很好的特性是，

1571
00:49:46,410 --> 00:49:49,350
0,600 600,720 720,1200 1200,1710 2100,2940
nice {you,know} features has {}|
|

1572
00:49:49,350 --> 00:49:52,410
0,300 300,840 1020,1740 2280,2580 2610,3060
is| that sometimes it's originally
|有时，它最初被称为实时的，

1573
00:49:52,410 --> 00:49:53,670
0,330 330,510 510,960 960,1110 1110,1260
called {real-time -},| real what
|real 的意思是它是一个增量垃圾收集器。

1574
00:49:53,670 --> 00:49:55,110
0,30 30,360 360,660 660,1350 1350,1440
I meant is it's an

1575
00:49:55,110 --> 00:49:56,460
0,840
incremental

1576
00:49:56,700 --> 00:49:58,280
0,480 480,990
garbage collector.|
|

1577
00:50:02,730 --> 00:50:05,010
0,630 660,1230 1530,1800 1800,2010 2010,2280
So, {} and the main
所以，主要的想法是，

1578
00:50:05,010 --> 00:50:07,800
0,540 540,660 660,1110 1620,2160
idea is that {},|
|

1579
00:50:11,350 --> 00:50:12,880
0,510 510,630 630,780 780,1020 1020,1530
here if we have our
这里我们有两个 from 空间和 to 空间，

1580
00:50:14,250 --> 00:50:15,840
0,630 660,930 930,1290 1290,1410 1410,1590
two from space and to

1581
00:50:15,840 --> 00:50:17,040
0,570
space,|
|

1582
00:50:19,340 --> 00:50:21,650
0,630 840,1350 1350,1800 1800,1920 1920,2310
{} main idea is that
主要的想法是我们有 root ，

1583
00:50:21,650 --> 00:50:22,970
0,150 150,420 420,600 600,840 840,1320
you know we have our

1584
00:50:23,210 --> 00:50:25,200
0,840 840,1380
root again,|
|

1585
00:50:25,400 --> 00:50:27,440
0,450 450,1140 1170,1560 1560,1800 1800,2040
here's root, {} it had
这是 root ，它有两个指针，

1586
00:50:27,440 --> 00:50:28,960
0,150 150,960
two pointers,|
|

1587
00:50:30,540 --> 00:50:32,580
0,240 240,450 450,840 870,1470
and it's pointing back.|
它指回来。|

1588
00:50:34,520 --> 00:50:35,510
0,270 270,390 390,600 600,900 900,990
{} The main idea is
主要的想法是，

1589
00:50:35,510 --> 00:50:37,670
0,270 270,960 960,1230 1230,1410 1410,2160
that,| it's not really necessary
|它不需要停止整个世界，复制所有内容，

1590
00:50:37,670 --> 00:50:40,010
0,420 420,840 840,900 900,1410 1590,2340
to stop the world {}

1591
00:50:40,010 --> 00:50:42,200
0,360 360,810 810,1200 1200,1740 2010,2190
and copy everything over| and
|然后基本上恢复[比赛]，

1592
00:50:42,200 --> 00:50:44,200
0,180 180,480 480,840 840,1500
then basically resume [competition],|
|

1593
00:50:44,400 --> 00:50:46,410
0,120 120,270 270,450 450,660 660,2010
the only thing really necessary
唯一需要的是通过 root 进行复制，

1594
00:50:46,930 --> 00:50:48,250
0,240 240,360 360,630 630,990 990,1320
is to actually move copy

1595
00:50:48,250 --> 00:50:49,640
0,150 150,270 270,900
over the root,|
|

1596
00:50:51,670 --> 00:50:53,110
0,150 150,510 510,630 630,930 930,1440
and basically do nothing else,|
基本上什么也不做，|

1597
00:50:53,380 --> 00:50:54,310
0,180 180,300 300,750 750,840 840,930
and so basically you know
在这一点上， root 已经被复制了，

1598
00:50:54,310 --> 00:50:55,270
0,90 90,270 270,750 750,840 840,960
at this point you know

1599
00:50:55,270 --> 00:50:57,610
0,420 810,1440 1440,1590 1590,1740 1740,2340
the root has been copied,|
|

1600
00:50:57,670 --> 00:50:59,380
0,480 480,600 600,720 720,1170
but you know it's
但是它的指针还指向这里，

1601
00:50:59,630 --> 00:51:01,640
0,690 690,750 750,1410
pointers are still

1602
00:51:01,960 --> 00:51:03,040
0,450 450,540 540,660 660,780 780,1080
pointing you know the here,|
|

1603
00:51:03,040 --> 00:51:04,180
0,270 270,450 450,780 780,930 930,1140
because that object has not
因为对象尚未被扫描，

1604
00:51:04,180 --> 00:51:05,890
0,150 150,750 840,1050 1050,1350 1350,1710
been scanned,| it hasn't been,
|它的指针还没有更新。

1605
00:51:05,890 --> 00:51:07,180
0,270 270,540 540,750 750,930 930,1290
it's pointer haven't been updated

1606
00:51:07,180 --> 00:51:08,040
0,330
yet.|
|

1607
00:51:08,250 --> 00:51:10,110
0,600 750,1380 1380,1530 1530,1590 1590,1860
{} And and the basic
它的基本思想是，

1608
00:51:10,110 --> 00:51:11,910
0,240 240,300 300,720 930,1260 1260,1800
idea is| then {} whenever
|每当应用程序调用 new 时，

1609
00:51:11,910 --> 00:51:15,300
0,150 150,1020 1320,2340 2340,2850
the application calls new,|
|

1610
00:51:19,480 --> 00:51:21,610
0,210 210,660 660,840 840,1410 1620,2130
{you,know} whenever new call, {}|
每次调用 new ，|

1611
00:51:21,610 --> 00:51:22,990
0,420 420,810 810,870 870,1110 1110,1380
you scan a few more
你扫描几个对象，

1612
00:51:22,990 --> 00:51:24,160
0,420 420,600 600,720 720,1110 1110,1170
objects,| or you forward a
|或者你多[转发]几个对象。

1613
00:51:24,160 --> 00:51:25,780
0,270 270,570 570,1110
couple more objects.|
|

1614
00:51:34,920 --> 00:51:36,000
0,210 210,540 540,660 660,750 750,1080
And that's sort of nice,
这是很好的，

1615
00:51:36,000 --> 00:51:37,800
0,240 240,540 540,930 930,1080 1080,1800
correct,| because basically you spread|
|因为你分摊了|

1616
00:51:37,830 --> 00:51:39,210
0,300 300,840 840,930 930,1320 1320,1380
the cost of actually you
复制整个活动堆的花费，

1617
00:51:39,210 --> 00:51:40,980
0,120 120,510 510,1080 1110,1650 1650,1770
know copying the complete you

1618
00:51:40,980 --> 00:51:43,170
0,870 900,1320 1320,1440 1440,1740 1740,2190
know active or live heap|
|

1619
00:51:43,380 --> 00:51:45,570
0,360 360,450 450,1020 1020,1770 1770,2190
from the application incremental steps,|
从应用程序增量步骤中，|

1620
00:51:45,600 --> 00:51:47,550
0,330 330,930 930,1140 1140,1500 1500,1950
every new every call allocates
每个 new 调用分配一点，

1621
00:51:48,240 --> 00:51:49,260
0,330 330,330 330,630 630,930 930,1020
contributes a little bit,| you
|来完成一个完整的复制操作。

1622
00:51:49,260 --> 00:51:49,980
0,90 90,270 270,540 540,630 630,720
know to actually do a

1623
00:51:49,980 --> 00:51:51,700
0,360 360,660 660,1200
complete copy operation.|
|

1624
00:51:52,670 --> 00:51:54,110
0,390 390,480 480,690 690,750 750,1440
And of course the application
当然，应用程序也可能使用其中的一些指针，

1625
00:51:54,290 --> 00:51:55,790
0,420 450,750 750,900 900,1050 1050,1500
{} might also be using

1626
00:51:55,790 --> 00:51:56,450
0,150 150,270 270,420 420,510 510,660
you know some of these

1627
00:51:56,450 --> 00:51:57,980
0,420 420,570 570,1110 1110,1380 1380,1530
pointers,| for example if {you,know}
|比如，如果 root 取消引用第二个红色指针，

1628
00:51:57,980 --> 00:52:00,380
0,660 990,1500 1500,1710 1710,1920 1920,2400
root {} will be {dereferencing

1629
00:52:00,380 --> 00:52:02,540
0,300 300,720 720,990 990,1470 1740,2160
-} actually this, this second

1630
00:52:02,540 --> 00:52:04,070
0,240 240,750 810,1050 1050,1320 1320,1530
red pointer,| it's still actually
|它还指向 from 空间，

1631
00:52:04,070 --> 00:52:05,450
0,330 330,510 510,600 600,870 870,1380
pointing into the from space,|
|

1632
00:52:05,480 --> 00:52:06,080
0,90 90,150 150,360 360,510 510,600
and of course that is
当然，这是危险的，

1633
00:52:06,080 --> 00:52:07,700
0,600 600,930 930,1320 1320,1530 1530,1620
dangerous,| because we shouldn't be
|因为我们不应该跟踪 from 空间的指针。

1634
00:52:07,700 --> 00:52:08,840
0,420 420,750 750,840 840,900 900,1140
tracking pointers in the from

1635
00:52:08,840 --> 00:52:09,740
0,480
space.|
|

1636
00:52:09,740 --> 00:52:11,300
0,540 660,870 870,1020 1020,1380 1380,1560
{} And so basically this
这意味着每次取消引用时，

1637
00:52:11,300 --> 00:52:12,440
0,270 270,600 600,780 780,1020 1020,1140
means that every time you

1638
00:52:12,440 --> 00:52:13,780
0,60 60,210 210,840
do {dereference -},|
|

1639
00:52:16,440 --> 00:52:17,970
0,390 390,510 510,780 780,870 870,1530
do {dereference -} a pointer,|
取消引用一个指针，|

1640
00:52:20,410 --> 00:52:21,920
0,180 180,330 330,420 420,960
you need to check,|
你需要检查，|

1641
00:52:23,610 --> 00:52:24,540
0,270 270,390 390,540 540,690 690,930
check if it's in the
检查它是不是在 from 空间，

1642
00:52:24,540 --> 00:52:27,060
0,240 240,780 900,1620 1650,1950 1950,2520
from space, {if,in} from space,|
|

1643
00:52:29,020 --> 00:52:30,820
0,210 210,390 390,960 1260,1470 1470,1800
and if so, {you,know} do
如果是这样的话，要做转发。

1644
00:52:30,820 --> 00:52:33,040
0,510 960,1590
the forwarding.|
|

1645
00:52:36,880 --> 00:52:37,750
0,150 150,270 270,390 390,780 780,870
And so the application is
所以应用程序允许使用指针，

1646
00:52:37,750 --> 00:52:38,980
0,300 300,360 360,570 570,810 810,1230
allowed to use the pointers,|
|

1647
00:52:38,980 --> 00:52:40,480
0,120 120,480 480,630 630,960 960,1500
but basically to run,| the
但必须运行，|编译器必须对应用程序进行检测，

1648
00:52:40,810 --> 00:52:42,340
0,570 570,840 840,930 930,1410 1410,1530
compiler has to instrument the

1649
00:52:42,340 --> 00:52:43,810
0,510 510,600 600,870 870,1110 1110,1470
application| that basically every pointer
|检查每个指针访问，

1650
00:52:43,810 --> 00:52:45,790
0,630 630,1260 1260,1380 1380,1560 1560,1980
accesses surrounded by that check,|
|

1651
00:52:46,120 --> 00:52:47,560
0,330 330,540 540,900 900,1080 1080,1440
{} so that you know,
所以，我们保持了不变量，

1652
00:52:47,560 --> 00:52:48,940
0,390 390,540 540,900 900,1290 1290,1380
{} we basically maintain the

1653
00:52:48,940 --> 00:52:52,120
0,570 570,810 810,1290 1620,2850 2850,3180
invariant that all,| {} at
|在 to 空间中的任何指针处，

1654
00:52:52,120 --> 00:52:53,410
0,180 180,480 480,570 570,870 870,1290
any {pointer -} {in,the,to} space,|
|

1655
00:52:53,410 --> 00:52:54,670
0,90 90,390 390,510 510,930 930,1260
{you,know} points to objects {in,to}
指向 to 空间中的对象。

1656
00:52:54,670 --> 00:52:55,560
0,510
space.|
|

1657
00:52:56,040 --> 00:52:57,150
0,240 240,360 360,540 540,780 780,1110
And we need to ensure
我们需要确保，

1658
00:52:57,150 --> 00:52:58,440
0,210 210,510 510,690 690,1170 1170,1290
that, correct,| because when in
|因为当我们最后完成时，

1659
00:52:58,440 --> 00:52:59,610
0,90 90,240 240,360 360,780 960,1170
the end we're done,| you
|我们想把删除 from 空间，

1660
00:52:59,610 --> 00:53:01,440
0,150 150,660 810,1260 1260,1530 1530,1830
know we {} want to

1661
00:53:01,470 --> 00:53:03,690
0,600 600,720 720,930 930,1380 1380,2220
remove the from space| and
|这样我们就可以丢弃它，将其作为自由空间重新使用。

1662
00:53:03,750 --> 00:53:05,280
0,360 1050,1230 1230,1350 1350,1440 1440,1530
have, so that we can

1663
00:53:05,280 --> 00:53:06,780
0,420 420,570 570,960 960,1140 1140,1500
discard it and {} reuse

1664
00:53:06,780 --> 00:53:08,080
0,120 120,240 240,390 390,900
it as free space.|
|

1665
00:53:09,810 --> 00:53:11,310
0,420 420,600 600,930 930,1140 1140,1500
Okay, any questions about this,
好的，有什么问题吗，这是基本的设置。

1666
00:53:11,340 --> 00:53:11,970
0,270 270,360 360,510 510,570 570,630
this is sort of the

1667
00:53:11,970 --> 00:53:13,340
0,330 330,840
basic setup.|
|

1668
00:53:20,710 --> 00:53:22,000
0,270 270,750
Okay, so,
好的，所以，如果没有问题，

1669
00:53:22,000 --> 00:53:22,690
0,300 300,450 450,540 540,570 570,690
{} if there are no

1670
00:53:22,690 --> 00:53:23,770
0,390 390,510 510,660 660,900 900,1080
questions,| in the paper makes
|关于这个方案，论文中提到了两点，

1671
00:53:23,770 --> 00:53:25,060
0,240 240,810 810,960 960,1050 1050,1290
two points you know about

1672
00:53:25,060 --> 00:53:28,720
0,150 150,660 780,2070 2070,2550 3330,3660
this scheme| {} and one
|第一个，这很烦人，或者不好，

1673
00:53:28,720 --> 00:53:30,790
0,390 390,510 510,870 1140,1500 1560,2070
is you know it's annoying

1674
00:53:30,790 --> 00:53:31,870
0,180 180,330 330,720 720,840 840,1080
or too bad| you actually
|你每次都要取消引用，

1675
00:53:31,870 --> 00:53:32,860
0,150 150,240 240,360 360,570 570,990
have to do this dereference

1676
00:53:32,860 --> 00:53:34,040
0,150 150,360 360,720
at every time,|
|

1677
00:53:34,130 --> 00:53:35,450
0,150 150,420 420,810 810,990 990,1320
{} so basically this means
所以这意味着加载或存储指令，

1678
00:53:35,450 --> 00:53:37,520
0,390 480,1050 1050,1140 1140,1410 1410,2070
{} load or store instruction,|
|

1679
00:53:37,610 --> 00:53:39,230
0,360 360,420 420,600 600,900 900,1620
instead of being single instruction
不是单个指令，而是一串指令，

1680
00:53:39,350 --> 00:53:40,100
0,330 330,420 420,480 480,690 690,750
actually has a bunch of

1681
00:53:40,100 --> 00:53:42,800
0,570 570,990 990,1650 1890,2400 2400,2700
instructions,| namely branch instruction| and
|也就是分支指令，|可能调用一个函数来执行它，

1682
00:53:42,800 --> 00:53:43,850
0,360 360,480 480,630 630,960 960,1050
perhaps you know calling a

1683
00:53:43,850 --> 00:53:44,840
0,360 360,480 480,750 750,840 840,990
function to actually do it

1684
00:53:44,840 --> 00:53:45,760
0,450
forward,|
|

1685
00:53:46,030 --> 00:53:47,350
0,450 450,600 600,810 810,1140 1140,1320
{} and so you know
所以这会增加应用程序的成本。

1686
00:53:47,350 --> 00:53:49,240
0,360 480,960 960,1050 1050,1620 1650,1890
that increase the cost of

1687
00:53:49,240 --> 00:53:51,160
0,570 600,1320
the application.|
|

1688
00:53:51,380 --> 00:53:52,910
0,510 720,960 960,1170 1170,1350 1350,1530
{} The second thing that
第二件指出的事情是，

1689
00:53:52,910 --> 00:53:54,500
0,420 420,750 750,1020 1020,1260 1260,1590
actually points out is that|
|

1690
00:53:54,770 --> 00:53:56,270
0,570 570,690 690,930 930,1200 1200,1500
it is not that easy
让垃圾收集器并行并不是那么容易，

1691
00:53:56,270 --> 00:54:01,040
0,540 570,1470 1500,2520 2520,2550 2940,4770
to parallelize { - -}

1692
00:54:01,040 --> 00:54:02,810
0,0 0,420 420,900 1020,1440 1440,1770
the garbage collector,| because maybe
|因为也许在一个很好的配置下，

1693
00:54:02,810 --> 00:54:03,590
0,60 60,120 120,360 360,660 660,780
in a nice setting,| it's
|比如，你在一台多核机器上运行，

1694
00:54:03,590 --> 00:54:04,370
0,120 120,300 300,450 450,690 690,780
like if you're running in

1695
00:54:04,370 --> 00:54:05,810
0,30 30,270 270,480 480,1170 1170,1440
a {multi-core -} machine,| where
|那里有很多空闲的 CPU ，

1696
00:54:05,810 --> 00:54:06,560
0,150 150,330 330,420 420,600 600,750
{you,know} have a lot of

1697
00:54:06,860 --> 00:54:08,690
0,300 300,720 720,810 810,1410 1530,1830
free {CPUs -},| basically I
|我把收集器放在后台，

1698
00:54:08,690 --> 00:54:09,680
0,390 390,450 450,540 540,630 630,990
[realize] that {the -} {collector

1699
00:54:09,680 --> 00:54:10,940
0,300 450,630 630,900 900,1080 1080,1260
-} {you,know} just put in

1700
00:54:10,940 --> 00:54:14,000
0,150 150,930 930,1080 1080,2070 2130,3060
the {backgrounds -},| {you,know} traverse
|遍历对象图，

1701
00:54:14,000 --> 00:54:16,020
0,0 0,1080 1080,1680
the object graph,|
|

1702
00:54:16,020 --> 00:54:17,820
0,480 480,600 600,1020 1020,1260 1260,1800
and {you,know} copy things incrementally
在它执行的过程中，递量地复制东西。

1703
00:54:17,820 --> 00:54:20,640
0,1110 1110,1560 1560,1650 1650,2310
over as it continues.|
|

1704
00:54:20,640 --> 00:54:21,960
0,420 420,600 600,690 690,1230 1230,1320
But if the application at
但是如果应用程序同时正在使用这个图，

1705
00:54:21,960 --> 00:54:23,460
0,60 60,330 330,780 1260,1410 1410,1500
the same time you know

1706
00:54:23,460 --> 00:54:25,080
0,180 180,600 600,720 720,1230 1320,1620
is using the graph {},|
|

1707
00:54:25,080 --> 00:54:26,100
0,210 210,330 330,780 810,900 900,1020
there's a risk you know
这个应用程序有风险，

1708
00:54:26,100 --> 00:54:27,270
0,240 240,660 660,990 990,1080 1080,1170
the application maybe,| you know,
|这里有一个引用检查，

1709
00:54:27,270 --> 00:54:28,590
0,390 390,600 600,720 720,870 870,1320
there's one of the reference

1710
00:54:28,590 --> 00:54:30,870
0,390 390,1140 1140,1560 1620,1950 1950,2280
check,| {one,of,these} checks starts copying
|其中一个检查开始复制对象，

1711
00:54:30,870 --> 00:54:31,830
0,90 90,570 660,840 840,900 900,960
an object,| while at the
|同时，收集器也在复制对象，

1712
00:54:31,830 --> 00:54:32,970
0,240 240,420 420,510 510,900 900,1140
same time, the collectors also

1713
00:54:32,970 --> 00:54:34,290
0,270 270,360 360,720 720,1170 1170,1320
copying the object| and {if,we're}
|如果我们不小心，

1714
00:54:34,290 --> 00:54:35,730
0,150 150,360 360,930 990,1260 1260,1440
not very carefully,| we may
|最终可能会把对象复制两次，

1715
00:54:35,730 --> 00:54:37,470
0,240 240,450 450,630 1110,1380 1380,1740
end up with the object

1716
00:54:37,470 --> 00:54:38,790
0,300 300,870 870,1020 1020,1080 1080,1320
copied twice| and that pointer
|而指针没有指向正确的位置，

1717
00:54:38,790 --> 00:54:40,110
0,180 180,600 630,990 990,1260 1260,1320
you know not pointing in

1718
00:54:40,110 --> 00:54:41,340
0,120 120,300 300,810 840,1110 1110,1230
the right places,| you can
|你可以很容易地看到这里有一个竞态条件，

1719
00:54:41,340 --> 00:54:42,720
0,300 300,570 570,930 930,1290 1290,1380
easily see correct there's a

1720
00:54:42,720 --> 00:54:44,730
0,210 210,690 810,1500 1530,1650 1650,2010
race condition,| possible of a
|可能的竞态条件。

1721
00:54:44,730 --> 00:54:46,380
0,600 600,690 690,930 930,1320
possibility of race conditions.|
|

1722
00:54:48,260 --> 00:54:49,960
0,390 390,1110
So the
所以论文描述了一个方案，

1723
00:54:50,020 --> 00:54:51,790
0,300 690,1080 1080,1320 1320,1710 1710,1770
{} paper basically describes a

1724
00:54:51,790 --> 00:54:53,140
0,570 600,900 900,1020 1020,1170 1170,1350
scheme,| it's like {} if
|如果你有用户级别的原语，

1725
00:54:53,140 --> 00:54:54,160
0,150 150,660 660,720 720,840 840,1020
you had you know the

1726
00:54:54,160 --> 00:54:56,620
0,660 660,870 870,1500 1740,2040 2040,2460
user level primitives,| then actually
|那么你可以做一些不同的事情，

1727
00:54:56,620 --> 00:54:57,580
0,120 120,210 210,300 300,540 540,960
you could do something different,|
|

1728
00:54:57,580 --> 00:54:58,780
0,60 60,180 180,390 390,960 990,1200
you could do a cool
你可以使用一个很酷的技巧，

1729
00:54:58,780 --> 00:55:00,340
0,450 690,1050 1050,1170 1170,1260 1260,1560
trick| and you can actually
|你可以使用虚拟内存，

1730
00:55:00,340 --> 00:55:01,620
0,210 210,780
use VM,

1731
00:55:02,860 --> 00:55:03,730
0,150 150,240 240,360 360,480 480,870
you know {virtual -} memory|
|

1732
00:55:03,730 --> 00:55:06,460
0,540 840,1860 1860,2190 2190,2280 2280,2730
to basically reduce the cost
来降低检查成本，

1733
00:55:06,460 --> 00:55:09,340
0,150 150,540 570,1110 1320,2010 2040,2880
of the check,| in {}
|几乎可以免费获得并发性。

1734
00:55:09,400 --> 00:55:11,110
0,390 390,810 810,1260 1260,1380 1380,1710
almost get concurrency for free.|
|

1735
00:55:12,180 --> 00:55:14,190
0,570 990,1140 1140,1260 1260,1740 1740,2010
{} And so the basic
所以基本的想法如下，

1736
00:55:14,190 --> 00:55:16,050
0,330 330,450 450,1020 1410,1770 1770,1860
{idea,is} as follows,| {} {you,know}
|我们有相同的设置，

1737
00:55:16,050 --> 00:55:17,500
0,210 210,450 450,960
we have our

1738
00:55:20,710 --> 00:55:22,270
0,630 660,900 900,1350 1350,1410 1410,1560
same {} setup,| you know
|我们的 from 和 to 。

1739
00:55:22,270 --> 00:55:23,760
0,240 240,840
our from

1740
00:55:24,400 --> 00:55:26,180
0,150 150,360 360,480 480,1050
and here's our to.|
|

1741
00:55:26,270 --> 00:55:27,950
0,720 960,1230 1230,1320 1320,1440 1440,1680
And what we're gonna do
我们要做的是，

1742
00:55:27,950 --> 00:55:29,450
0,180 180,420 420,570 570,780 780,1500
is| like we're gonna have
|我们有区域，

1743
00:55:29,480 --> 00:55:31,940
0,270 270,600 600,1020 2010,2220 2220,2460
we're gonna have we're gonna

1744
00:55:31,940 --> 00:55:33,680
0,570 600,990 990,1230 1230,1680 1680,1740
region,| we actually divide the
|我们把 to 空间虚拟地分开，

1745
00:55:33,680 --> 00:55:34,980
0,180 180,780
to space

1746
00:55:35,250 --> 00:55:38,070
0,780 780,1140 1680,2340 2340,2550 2550,2820
virtually| or literally we divide
|或者我们把 to 空间划分一个未扫描区域，

1747
00:55:38,070 --> 00:55:38,790
0,60 60,210 210,510 510,630 630,720
the to space in an

1748
00:55:38,790 --> 00:55:40,380
0,300 300,450 450,750 1080,1410 1410,1590
area that is a {unscanned

1749
00:55:40,380 --> 00:55:41,560
0,600
-}.|
|

1750
00:55:45,110 --> 00:55:45,890
0,90 90,390 390,540 540,630 630,780
{Let,me - -} a little
让我说得更清楚一点，

1751
00:55:45,890 --> 00:55:47,180
0,90 90,270 270,720
bit more clear,|
|

1752
00:55:48,760 --> 00:55:51,020
0,360 360,450 450,810 810,1260
{we,have} an area basically,
我们有一个区域，这里是扫描的，

1753
00:55:51,020 --> 00:55:52,940
0,510 510,690 690,1290
here is scanned,|
|

1754
00:55:54,440 --> 00:55:56,150
0,210 210,390 390,960 990,1530 1530,1710
and {} an area {unsacnned
还有一个区域是未被扫描的。

1755
00:55:56,150 --> 00:55:57,320
0,600
-}.|
|

1756
00:55:59,000 --> 00:56:00,440
0,210 210,660 660,1140 1140,1260 1260,1440
And initially basically you know
最初整个区域都是未扫描的，

1757
00:56:00,440 --> 00:56:02,960
0,210 210,870 1080,1560 1560,1950 1950,2520
the whole area {is,unscanned -},|
|

1758
00:56:03,440 --> 00:56:05,030
0,720 720,960 960,1230 1230,1320 1320,1590
you know when {you,know} start
当开始的时候，

1759
00:56:05,030 --> 00:56:06,350
0,360 360,480 480,660 660,1170 1170,1320
out,| you know you make
|你做了从 from 到 to 的翻转，

1760
00:56:06,350 --> 00:56:07,460
0,90 90,480 480,720 720,810 810,1110
the flip from the from

1761
00:56:07,460 --> 00:56:09,320
0,90 90,180 180,360 360,900 1050,1860
to the to space,| nothing
|还没有扫描过任何东西，

1762
00:56:09,320 --> 00:56:11,120
0,150 150,270 270,600 600,990 1320,1800
has been scanned yet,| because
|因为现在还没有任何对象，

1763
00:56:11,120 --> 00:56:11,930
0,150 150,240 240,630 630,750 750,810
there's no objects at the

1764
00:56:11,930 --> 00:56:13,280
0,360 360,570 570,720 720,990 990,1350
yet,| and so but basically
|但是方案是以相同的方式开始的，

1765
00:56:13,280 --> 00:56:14,390
0,510 510,750 750,840 840,900 900,1110
scheme starts in the same

1766
00:56:14,390 --> 00:56:16,460
0,450 480,840 840,1230 1230,1710 1710,2070
way,| we copy over the
|我们复制 root 对象，

1767
00:56:17,200 --> 00:56:18,740
0,420 420,1050
root object,|
|

1768
00:56:20,310 --> 00:56:21,600
0,240 240,540 540,600 600,720 720,1290
it used to be there,|
它曾经在这里，|

1769
00:56:21,690 --> 00:56:23,070
0,90 180,510 510,600 600,1200 1230,1380
and copy it over,| {you,know}
然后把它复制过来，|有一些指针，

1770
00:56:23,070 --> 00:56:24,390
0,180 180,330 330,990 990,1110 1110,1320
have some pointers,| you know
|这些指针仍然指向原来的，

1771
00:56:24,390 --> 00:56:25,980
0,420 420,720 720,1080 1080,1410 1410,1590
basically these pointers point still

1772
00:56:25,980 --> 00:56:27,640
0,420 420,810 810,1080
back into the,|
|

1773
00:56:32,910 --> 00:56:35,220
0,630 750,1560 1560,1710 1710,1980 1980,2310
oops,| yeah, and these pointers
糟糕，|是的，这些指针会指向老的 from 空间，

1774
00:56:35,220 --> 00:56:36,570
0,180 180,390 390,720 720,1140 1140,1350
will point back into the

1775
00:56:36,570 --> 00:56:38,910
0,240 240,450 450,930 1290,1800 2070,2340
old from space| {} and
|就是这样，

1776
00:56:38,910 --> 00:56:39,870
0,120 120,330 330,570 570,660 660,960
so that's it,| and now
|现在我们要做的是，

1777
00:56:39,870 --> 00:56:42,060
0,120 120,450 450,990 990,1770 1920,2190
we're basically saying, {} and

1778
00:56:42,060 --> 00:56:43,260
0,210 210,330 330,480 480,750 750,1200
what we're gonna do is|
|

1779
00:56:43,380 --> 00:56:45,090
0,330 330,510 510,720 720,1110 1110,1710
for the {unscanned -} area,
对于未扫描的区域，也就是这一点，

1780
00:56:45,780 --> 00:56:47,220
0,270 270,420 420,600 600,870 870,1440
which is this point [],|
|

1781
00:56:47,730 --> 00:56:49,020
0,300 300,420 420,540 540,960 960,1290
we're going to basically map
我们在没有权限的情况下映射它们，

1782
00:56:49,020 --> 00:56:50,730
0,330 420,750 750,1080 1350,1530 1530,1710
and map them with no

1783
00:56:50,730 --> 00:56:52,080
0,750
permission,|
|

1784
00:56:52,200 --> 00:56:53,760
0,420 420,930
map none.|
映射 None 。|

1785
00:56:56,380 --> 00:56:57,340
0,120 120,270 270,570 570,780 780,960
And so what does that
那么这意味着什么，

1786
00:56:57,340 --> 00:56:58,630
0,330 330,570 570,690 690,930 930,1290
mean,| well, that means that,|
|这意味着，|

1787
00:56:58,630 --> 00:56:59,620
0,60 60,300 300,480 480,780 780,990
the first time run the
在第一次运行应用程序时，

1788
00:56:59,620 --> 00:57:01,240
0,780 1020,1140 1140,1200 1200,1530 1530,1620
application,| you know after we
|在我们翻转之后，

1789
00:57:01,240 --> 00:57:02,590
0,120 120,180 180,630 900,1230 1230,1350
did the flip,| {} the
|垃圾收集器翻转之后，

1790
00:57:02,590 --> 00:57:03,610
0,270 270,540 540,630 630,690 690,1020
garbage collector it to flip,|
|

1791
00:57:03,610 --> 00:57:04,540
0,90 90,270 270,420 420,510 510,930
the first time the application
应用程序第一次使用 root 指针，

1792
00:57:04,540 --> 00:57:06,100
0,60 60,270 270,360 360,840 930,1560
is use the root {}

1793
00:57:06,100 --> 00:57:08,230
0,630 900,1380 1380,1590 1590,1980 1980,2130
pointer,| {} it will get
|它会出现页面错误，

1794
00:57:08,230 --> 00:57:09,700
0,60 60,270 270,600 630,1380 1380,1470
a page fault,| because you
|因为这一部分地址范围是未映射的。

1795
00:57:09,700 --> 00:57:11,980
0,480 870,1440 1560,1920 1980,2220 2220,2280
know {} that part of

1796
00:57:11,980 --> 00:57:13,090
0,90 90,390 390,690 690,780 780,1110
the address range has actually

1797
00:57:13,090 --> 00:57:13,920
0,450
unmapped.|
|

1798
00:57:14,010 --> 00:57:15,420
0,210 210,570 570,810 810,900 900,1410
So basically then the {idea,is}
所以想法是，

1799
00:57:15,420 --> 00:57:16,920
0,90 90,180 180,480 480,1050
in the fault handler,|
在错误处理程序中，|

1800
00:57:22,350 --> 00:57:24,930
0,840 1140,1650 1650,1890 1890,1980 1980,2580
scan one page of objects,|
扫描一页对象，|

1801
00:57:31,960 --> 00:57:33,010
0,300 300,690 690,750 750,960 960,1050
and forward to what that
并转发需要转发的。

1802
00:57:33,010 --> 00:57:34,580
0,120 120,180 180,300 300,960
need to be forwarded.|
|

1803
00:57:37,850 --> 00:57:39,200
0,240 240,690 690,780 780,960 960,1350
So basically you know we
所以我们在这个特殊的设置中，

1804
00:57:39,200 --> 00:57:40,190
0,60 60,180 180,480 480,750 750,990
in this particular setting,| where
|到目前为止，我们只复制了 root ，

1805
00:57:40,190 --> 00:57:41,360
0,90 90,300 300,660 660,900 900,1170
we're only copied over just

1806
00:57:41,360 --> 00:57:42,920
0,90 90,480 510,720 720,1230 1440,1560
the root so far,| you
|我们要通过 root 复制，

1807
00:57:42,920 --> 00:57:44,870
0,120 120,1320 1590,1620 1620,1830 1830,1950
know we are going to

1808
00:57:44,870 --> 00:57:47,210
0,300 300,840 990,1830 1860,2280 2280,2340
copy over {} root,| we
|我们可以扫描 root 指向的对象中的指针，

1809
00:57:47,210 --> 00:57:48,470
0,150 150,720 750,900 900,1020 1020,1260
can scan you know the

1810
00:57:48,500 --> 00:57:51,080
0,630 660,1020 1020,1800 1950,2490 2490,2580
pointers in the object to

1811
00:57:51,080 --> 00:57:52,340
0,240 240,360 360,570 570,630 630,1260
which the root is pointing,|
|

1812
00:57:52,430 --> 00:57:53,060
0,180 180,270 270,480 480,570 570,630
in this case there are
在这种情况下，只有两个，

1813
00:57:53,060 --> 00:57:54,260
0,180 180,330 330,450 450,840 870,1200
only two of them,| we
|我们把这两个对象复制到未扫描的空间，

1814
00:57:54,260 --> 00:57:55,250
0,180 180,240 240,570 570,720 720,990
kind of copy over those

1815
00:57:55,250 --> 00:57:56,450
0,150 150,660 660,750 750,840 840,1200
two objects you know into

1816
00:57:56,450 --> 00:57:57,240
0,330
the

1817
00:57:57,240 --> 00:57:58,680
0,300 300,450 450,750 750,1290 1290,1440
{} {unscanned -} space,| or
|或者让我在这里稍微画的不同一点，

1818
00:57:58,680 --> 00:58:00,000
0,270 270,480 480,570 570,990 990,1320
maybe let me drawing slightly

1819
00:58:00,000 --> 00:58:01,280
0,330 330,720
different here,|
|

1820
00:58:01,700 --> 00:58:02,870
0,270 270,420 420,480 480,720 720,1170
just make it look like
让它看起来像我们已经复制了这两个指向的对象，

1821
00:58:03,450 --> 00:58:04,650
0,180 180,420 420,720 720,930 930,1200
we've got copy over those

1822
00:58:04,650 --> 00:58:06,510
0,390 390,1020 1020,1320 1320,1500 1500,1860
two objects that were pointing

1823
00:58:06,510 --> 00:58:08,910
0,480 990,1500 1500,1830 1830,1950 1950,2400
to| and basically we update
|我们更新，

1824
00:58:08,910 --> 00:58:10,080
0,90 90,210 210,780 900,990 990,1170
you know the,| you know
|我们将这条扫描线从这里移动到那里，

1825
00:58:10,080 --> 00:58:11,580
0,390 390,810
{we,move} this

1826
00:58:11,730 --> 00:58:13,080
0,390 390,810 840,930 930,1080 1080,1350
scan line you know from

1827
00:58:13,080 --> 00:58:14,180
0,540
here

1828
00:58:14,740 --> 00:58:15,960
0,660
{to,there},|
|

1829
00:58:16,080 --> 00:58:17,250
0,270 270,450 450,540 540,690 690,1170
so this is {you,know} scanned.|
所以这是扫描过的。|

1830
00:58:20,230 --> 00:58:21,340
0,150 150,270 270,600 600,780 780,1110
And so after we scan
所以在我们扫描完这一页之后，

1831
00:58:21,340 --> 00:58:22,930
0,90 90,480 480,870 870,990 990,1590
the page,| we can actually
|我们可以增加保护，

1832
00:58:23,020 --> 00:58:25,180
0,630 810,1350 1350,1440 1440,1680 1950,2160
{} increase you know {basically

1833
00:58:25,180 --> 00:58:26,060
0,330
-}

1834
00:58:26,510 --> 00:58:28,340
0,600 600,750 750,1080 1080,1230 1230,1830
protect| or basically {unprotect -},|
|或者你可以取消保护扫描页，|

1835
00:58:30,880 --> 00:58:32,110
0,210 210,480 480,750 750,810 810,1230
you can unprotect the page,
您可以取消对页面的保护，取消对扫描页面的保护。

1836
00:58:33,480 --> 00:58:35,380
0,240 240,600 600,900 900,1410
{unprotect,the -} scan page.|
|

1837
00:58:42,510 --> 00:58:43,640
0,660
Okay?|
好的?|

1838
00:58:44,120 --> 00:58:45,500
0,360 360,480 480,600 600,1110 1230,1380
And you know the,| and
然后，|然后应用程序只能访问特定的对象，

1839
00:58:45,500 --> 00:58:46,730
0,150 150,240 240,780 780,990 990,1230
then the application {you,know} can

1840
00:58:46,730 --> 00:58:47,870
0,300 300,420 420,630 630,1020 1020,1140
just you know access the

1841
00:58:47,870 --> 00:58:49,760
0,300 300,660 660,960 960,1380 1380,1890
particular object,| because we {translated
|因为我们转换了对象内部的指针，

1842
00:58:49,760 --> 00:58:50,600
0,150 150,420 420,510 510,720 720,840
-} {you,know} the pointer that's

1843
00:58:50,600 --> 00:58:51,590
0,330 330,420 420,480 480,840 840,990
inside of the objects,| it's
|它对应用程序公开是安全的，

1844
00:58:51,590 --> 00:58:52,610
0,330 330,390 390,840 840,900 900,1020
safe to expose it to

1845
00:58:52,610 --> 00:58:54,410
0,120 120,870 1080,1290 1290,1680 1680,1800
the application,| the application can
|应用程序可以遍历这些指针，

1846
00:58:54,410 --> 00:58:56,150
0,360 360,600 600,1140 1260,1440 1440,1740
traverse those pointers,| of course
|当然，这些指针仍然指向已扫描的对象，

1847
00:58:56,150 --> 00:58:57,350
0,240 240,600 600,690 690,900 900,1200
those pointers are still pointing

1848
00:58:57,350 --> 00:58:58,700
0,120 120,600 600,840 840,1080 1080,1350
to objects that are having

1849
00:58:58,700 --> 00:59:01,370
0,420 600,1170 1170,1560 1650,2100 2100,2670
been scanned in,| then we'll,
|我们会再次出现页面错误，

1850
00:59:01,400 --> 00:59:02,420
0,420 450,630 630,780 780,810 810,1020
{} we'll get a page

1851
00:59:02,420 --> 00:59:03,560
0,210 210,510 510,600 600,1020 1020,1140
fault again| and then we
|然后我们再多扫描一点。

1852
00:59:03,560 --> 00:59:04,460
0,240 240,330 330,480 480,600 600,900
scan a little bit more.|
|

1853
00:59:04,920 --> 00:59:05,700
0,180 180,270 270,570 570,720 720,780
So it basically has the
所以它的好处仍然是递增的，

1854
00:59:05,700 --> 00:59:08,000
0,810 810,1020 1020,1710
benefits still incremental,|
|

1855
00:59:11,350 --> 00:59:12,220
0,240 240,360 360,630 630,810 810,870
you can still do a
你仍然可以做一些工作，

1856
00:59:12,220 --> 00:59:13,210
0,240 240,360 360,420 420,900 900,990
little bit of work,| you
|每次，

1857
00:59:13,210 --> 00:59:14,050
0,60 60,270 270,630 630,720 720,840
know every time,| we can
|我们每次执行 new 时，

1858
00:59:14,050 --> 00:59:14,920
0,210 210,300 300,420 420,630 630,870
also do it every time

1859
00:59:14,920 --> 00:59:15,970
0,90 90,480 480,720 720,870 870,1050
{} new,| we can actually
|我们可以分配一些，做一些工作，

1860
00:59:15,970 --> 00:59:17,140
0,420 420,540 540,660 660,900 900,1170
allocate you know some do

1861
00:59:17,140 --> 00:59:18,550
0,120 120,480 480,1140 1140,1230 1230,1410
some work,| but it has
|但它还有额外的好处，

1862
00:59:18,550 --> 00:59:20,170
0,60 60,420 420,1020 1230,1440 1440,1620
the additional benefit,| there's no
|不再需要指针检查了，

1863
00:59:20,170 --> 00:59:22,120
0,300 300,630 630,960 960,1470
no pointer check anymore,|
|

1864
00:59:25,060 --> 00:59:26,470
0,390 390,570 570,660 660,870 870,1410
{the,pointer} check is still there,|
指针检查仍在那里，|

1865
00:59:26,950 --> 00:59:28,090
0,240 240,330 330,540 540,600 600,1140
but it's done in hardware,|
但它是在硬件中完成的，|

1866
00:59:28,600 --> 00:59:29,590
0,180 180,240 240,540 540,660 660,990
with the page, the VM
虚拟内存硬件我们完成了这项工作。

1867
00:59:29,590 --> 00:59:30,790
0,360 360,540 540,630 630,930 930,1200
hardware does it for us.|
|

1868
00:59:39,280 --> 00:59:40,700
0,150 150,240 240,420 420,810
Does that make sense?|
这能理解吗？|

1869
00:59:41,950 --> 00:59:43,720
0,240 240,570 570,780 780,1140 1530,1770
Any questions about this, about
有任何关于方案，有什么问题吗？

1870
00:59:43,720 --> 00:59:44,860
0,150 150,600
this plan?|
|

1871
00:59:45,680 --> 00:59:48,230
0,240 240,390 390,480 480,1320 2010,2550
I have a question {},|
我有个问题，|

1872
00:59:48,260 --> 00:59:49,800
0,990
so,
在处理程序中，你说扫描一页对象，

1873
00:59:50,100 --> 00:59:51,990
0,720 750,960 960,1080 1080,1680 1680,1890
in, in the handler you're

1874
00:59:51,990 --> 00:59:53,670
0,300 300,480 480,570 570,1230 1260,1680
saying that you scan one

1875
00:59:53,670 --> 00:59:55,410
0,270 270,450 450,1200 1200,1440 1440,1740
page of objects,| but how
|但你如何知道，

1876
00:59:55,410 --> 00:59:57,200
0,180 180,330 330,630 630,1230
do you know that,|

1877
00:59:57,200 --> 00:59:59,300
0,390 390,1290 1290,1680 1680,1800 1800,2100
the objects that the root
root 引用的对象将指向相同的，

1878
00:59:59,300 --> 01:00:02,180
0,450 450,1290 1290,1800 1830,2220 2220,2880
has references to will be

1879
01:00:02,750 --> 01:00:04,220
0,360 360,630 630,870 870,1020 1020,1470
will fall into the same,|
|

1880
01:00:04,250 --> 01:00:05,270
0,330 330,630 630,720 720,810 810,1020
like how do you know
比如你如何知道真正需要转发的对象，

1881
01:00:05,270 --> 01:00:06,530
0,210 210,300 300,690 690,960 960,1260
that the objects that really

1882
01:00:06,530 --> 01:00:09,140
0,270 270,420 420,990 1080,2070 2370,2610
need to be forwarded,| in
|为了不违反放在同一页中的不变量。

1883
01:00:09,140 --> 01:00:11,180
0,240 240,390 390,990 1020,1950 1950,2040
order to not violate the

1884
01:00:11,180 --> 01:00:12,470
0,630 630,870 870,1020 1020,1140 1140,1290
invariant will be in the

1885
01:00:12,470 --> 01:00:13,980
0,390 390,1050
same page.|
|

1886
01:00:14,200 --> 01:00:16,570
0,240 240,360 360,750 750,1590 2160,2370
{} You'll be,| okay, there's
你会，|好的，页面中有一些对象，

1887
01:00:16,570 --> 01:00:17,350
0,150 150,330 330,390 390,720 720,780
some set of objects in

1888
01:00:17,350 --> 01:00:20,200
0,60 60,510 510,1500 2070,2520 2520,2850
the page,| the starting,| okay
|一开始，|好的，但是我们假设，

1889
01:00:20,350 --> 01:00:21,430
0,270 270,450 450,870 870,1020 1020,1080
but let's say you know

1890
01:00:21,430 --> 01:00:22,580
0,180 180,600
what the,|
|

1891
01:00:23,930 --> 01:00:25,560
0,510 600,1110
okay, {}
好的，在我们开始翻转这些空间的时候，

1892
01:00:27,310 --> 01:00:28,690
0,180 180,330 330,900 930,1260 1260,1380
at the beginning when we

1893
01:00:28,690 --> 01:00:30,010
0,180 180,330 330,840 840,1050 1050,1320
flip this spaces,| there's nothing
|to 空间里什么都没有，

1894
01:00:30,010 --> 01:00:31,360
0,270 270,840
{in,the,to} space,|
|

1895
01:00:32,780 --> 01:00:33,680
0,240 240,330 330,420 420,690 690,900
what we could do is,|
我们能做的是，|

1896
01:00:33,680 --> 01:00:34,340
0,180 180,300 300,390 390,540 540,660
like what the right thing
我们能做的正确的事是，

1897
01:00:34,340 --> 01:00:35,390
0,90 90,210 210,300 300,600 630,1050
to do is| just copy
|我只是试着复制一页，

1898
01:00:35,390 --> 01:00:36,200
0,300 300,450 450,630 630,690 690,810
I just tried to just

1899
01:00:36,200 --> 01:00:37,490
0,240 240,450 450,720 720,840 840,1290
copy one page,| but basically
|复制或转发一页，

1900
01:00:37,490 --> 01:00:40,100
0,390 390,960 1080,1260 1260,1830 2160,2610
copy over or forward {}

1901
01:00:40,100 --> 01:00:42,860
0,420 420,1080 1080,1560 1860,2460 2490,2760
one page,| basically copy n
|复制 n 个对象，

1902
01:00:42,860 --> 01:00:43,940
0,390 390,720 720,840 840,990 990,1080
objects over,| so that they
|这样它们就填满了完整的一页。

1903
01:00:43,940 --> 01:00:45,480
0,240 240,270 270,630 630,1110
fill a complete page.|
|

1904
01:00:46,040 --> 01:00:48,170
0,480 720,1110 1110,1230 1230,1680 1800,2130
Right.| Now we have n
好的。|现在，我们有 n 个对象位于这一页上，都是未扫描的，

1905
01:00:48,170 --> 01:00:49,310
0,420 420,630 630,750 750,900 900,1140
objects sitting on that one

1906
01:00:49,310 --> 01:00:51,260
0,360 360,690 690,870 870,1410
page, all {unscanned -},|
|

1907
01:00:51,820 --> 01:00:52,420
0,180 180,240 240,390 390,570 570,600
then, at some point a
然后，在某个时刻，页面错误处理程序发生，

1908
01:00:52,420 --> 01:00:54,460
0,360 360,510 510,1080 1080,1410 1410,2040
{page,fault} {handler -} {} happen|
|

1909
01:00:54,610 --> 01:00:55,780
0,120 120,540 540,600 600,750 750,1170
and then you know the
然后垃圾收集器，

1910
01:00:55,840 --> 01:00:56,800
0,330 330,780 780,900 900,960 960,960
garbage collector,| you know {}
|收集器检查这一页上的每个对象，

1911
01:00:56,800 --> 01:00:58,690
0,420 420,990 990,1140 1140,1680 1680,1890
collector {} go through each

1912
01:00:58,690 --> 01:01:00,580
0,600 600,810 810,1050 1050,1320 1320,1890
object on that one page|
|

1913
01:01:00,640 --> 01:01:02,680
0,270 270,720 960,1230 1230,1410 1410,2040
and looks for its pointers,|
并查看它的指针，|

1914
01:01:03,260 --> 01:01:04,520
0,240 240,420 420,570 570,840 840,1260
and for each pointer,| it
对于每个指针，|它会复制这些对象

1915
01:01:04,520 --> 01:01:08,210
0,330 330,720 720,1590 1800,3030 3030,3690
will copies {over,those} {you,know} objects|
|

1916
01:01:08,240 --> 01:01:11,570
0,630 630,1260 1590,2880 2880,3210 3210,3330
into the, {} into the
到 to 空间的未扫描部分。

1917
01:01:11,570 --> 01:01:13,040
0,180 180,540 540,990 1020,1230 1230,1470
{unscan -} part of the

1918
01:01:13,040 --> 01:01:14,240
0,180 180,750
to space.|
|

1919
01:01:14,240 --> 01:01:15,260
0,120 120,240 240,450 450,900 930,1020
And so that if you
所以，如果任何人或者应用程序使用其中之一，

1920
01:01:15,260 --> 01:01:16,280
0,150 150,690 690,870 870,960 960,1020
know anybody or if the

1921
01:01:16,280 --> 01:01:17,570
0,540 540,720 720,1020 1020,1200 1200,1290
application would use one of

1922
01:01:17,570 --> 01:01:18,740
0,180 180,540 540,870 870,1020 1020,1170
those,| what objects will get
|对象将得到一个页面错误，

1923
01:01:18,740 --> 01:01:19,460
0,30 30,270 270,540 540,630 630,720
a page fault| and they
|并且它们可以扫描那些，依此类推。

1924
01:01:19,460 --> 01:01:21,380
0,150 150,390 390,900 1050,1440 1440,1920
can scan those etc etc.|
|

1925
01:01:23,690 --> 01:01:24,740
0,120 120,270 270,480 480,540 540,1050
Does that answer the question?|
这回答了你的问题吗？|

1926
01:01:25,100 --> 01:01:26,020
0,450
Yeah.|
是的。|

1927
01:01:27,000 --> 01:01:28,240
0,690
Okay.|
好的。|

1928
01:01:28,900 --> 01:01:30,100
0,330 330,690 690,810 810,1050 1050,1200
Oh, sorry, I also had
哦，抱歉，我也有个问题。

1929
01:01:30,100 --> 01:01:32,920
0,30 30,780 990,1860 2070,2490 2490,2820
a question.| Yeah, so after
|是的，所以在你将 to 翻转为 from 之后。

1930
01:01:32,920 --> 01:01:34,330
0,150 150,300 300,570 570,810 810,1410
you do this do flip

1931
01:01:34,330 --> 01:01:35,770
0,360 390,630 630,720 720,900 900,1440
the to in the from.|
|

1932
01:01:36,280 --> 01:01:39,880
0,480 1050,1680 2190,2880 2970,3330 3330,3600
Okay.| Okay, you, you start
好的。|好的，你从 from 空间开始，

1933
01:01:39,880 --> 01:01:40,870
0,150 150,240 240,330 330,570 570,990
out in the from space,|
|

1934
01:01:40,870 --> 01:01:41,680
0,120 120,330 330,420 420,690 690,810
you flip it up, you
把它翻转过来，

1935
01:01:41,680 --> 01:01:43,540
0,270 270,960 990,1170 1170,1680 1680,1860
flip to,| you copied over
|复制为 to 空间，

1936
01:01:43,540 --> 01:01:44,560
0,120 120,210 210,450 450,930 930,1020
to the to space| and
|然后你调用 from ，

1937
01:01:44,560 --> 01:01:46,150
0,120 120,240 240,540 540,810 1200,1590
then you call the from,|
|

1938
01:01:46,150 --> 01:01:47,020
0,240 240,360 360,630 630,780 780,870
once you're done with the
一旦你完成了扫描，

1939
01:01:47,020 --> 01:01:48,600
0,300 300,510 510,1050
complete with scanning,|
|

1940
01:01:48,740 --> 01:01:50,300
0,420 420,660 660,840 840,1080 1080,1560
{} and you're done with
你已经做好了 from 空间完全清空，

1941
01:01:50,360 --> 01:01:51,440
0,150 150,360 360,630 630,690 690,1080
the from space is completely

1942
01:01:51,440 --> 01:01:52,790
0,510 510,840 840,1020 1020,1260 1260,1350
clear,| just you flip the
|你只要把名字翻过来，

1943
01:01:52,790 --> 01:01:54,470
0,510 600,1020 1020,1140 1140,1380 1380,1680
names,| and you start using
|并且开始使用 to 空间来进行分配，

1944
01:01:54,470 --> 01:01:55,730
0,330 360,510 510,840 840,930 930,1260
the to space to actually

1945
01:01:55,730 --> 01:01:57,140
0,120 120,210 210,1020 1020,1320 1320,1410
do the allocations| until it's
|直到它装满，然后你再翻转一次。

1946
01:01:57,140 --> 01:01:58,370
0,540 540,660 660,900 900,1020 1020,1230
full and then you flip

1947
01:01:58,370 --> 01:01:59,160
0,270
again.|
|

1948
01:02:02,820 --> 01:02:04,280
0,330 330,930
Thank you.|
谢谢。|

1949
01:02:08,070 --> 01:02:09,260
0,690
Any
还有什么问题吗？

1950
01:02:10,020 --> 01:02:11,400
0,270 270,780
further questions?|
|

1951
01:02:12,990 --> 01:02:14,040
0,180 180,330 330,480 480,840 840,1050
So one of the, one
所以，这篇论文还提出的一个论点是，

1952
01:02:14,040 --> 01:02:15,810
0,90 90,540 840,1200 1200,1380 1380,1770
of the things that one

1953
01:02:15,810 --> 01:02:16,740
0,60 60,210 210,570 570,630 630,930
of the arguments the paper

1954
01:02:16,740 --> 01:02:17,670
0,210 210,540 540,690 690,810 810,930
also makes,| that you know
|虚拟内存系统或使用虚拟内存的另一件事，

1955
01:02:17,670 --> 01:02:19,260
0,750 870,1080 1080,1290 1290,1470 1470,1590
the one other thing that

1956
01:02:19,260 --> 01:02:20,970
0,60 60,450 450,1110 1110,1320 1320,1710
the VM system or using

1957
01:02:20,970 --> 01:02:23,400
0,390 390,840 840,1620 1800,2250 2250,2430
VM,| {} simplifies {} is
|简化了并发性，

1958
01:02:23,400 --> 01:02:25,000
0,390 390,1020
basically concurrency,|
|

1959
01:02:25,560 --> 01:02:27,780
0,570 930,1140 1140,1530 1530,1770 1770,2220
{} the argument is that,|
它的论点是，|

1960
01:02:28,600 --> 01:02:30,730
0,720 780,1260 1260,1380 1380,1920 1950,2130
{} basically the collector you
收集器只能浏览未扫描的页面，

1961
01:02:30,730 --> 01:02:32,350
0,240 240,420 420,630 630,1350 1380,1620
can just go through the

1962
01:02:32,350 --> 01:02:33,640
0,180 180,480 480,900 900,1050 1050,1290
{unscanned -} pages,| so we
|所以我们有浏览和扫描页面，

1963
01:02:33,640 --> 01:02:35,620
0,360 360,1050 1290,1620 1620,1770 1770,1980
have {} go through and

1964
01:02:35,620 --> 01:02:37,240
0,240 240,600 600,690 690,1230 1260,1620
scan pages| and basically scan
|每次扫描一个页面，

1965
01:02:37,240 --> 01:02:39,010
0,330 330,900 930,1200 1200,1230 1230,1770
one page at a time,|
|

1966
01:02:39,370 --> 01:02:41,860
0,510 510,1050 1320,1500 1500,1650 1650,2490
and if it is guaranteed
它保证应用程序没有指针，

1967
01:02:41,860 --> 01:02:43,300
0,270 270,420 420,900 900,1080 1080,1440
that the application has no

1968
01:02:43,300 --> 01:02:45,940
0,720 720,1200 1350,1920 1920,2370 2370,2640
pointers| or cannot access in
|或者不能在同一时间内访问那个页面，

1969
01:02:45,940 --> 01:02:47,350
0,90 90,390 390,810 810,1050 1050,1410
the same time that page,|
|

1970
01:02:47,350 --> 01:02:48,740
0,300 300,450 450,570 570,1020
because its {unmap -}.|
因为它是未映射的。|

1971
01:02:49,280 --> 01:02:51,320
0,240 240,690 840,1560 1770,1920 1920,2040
And so, {} you know
所以，只需要，

1972
01:02:51,320 --> 01:02:53,360
0,240 240,510 510,630 630,1170 1860,2040
as long as the,| so
|所以，页面硬件引入了

1973
01:02:53,360 --> 01:02:55,910
0,930 1170,1710 1710,2040 2040,2370 2370,2550
the paging hardware basically sort

1974
01:02:55,910 --> 01:02:58,970
0,120 120,900 930,1830 1830,2580 2580,3060
of introduces| explicit synchronization or
|显式同步或竞态保护，

1975
01:02:59,000 --> 01:03:01,460
0,720 720,1050 1050,1590 1680,2220 2220,2460
protection against races,| because only
|因为只有收集器在 from 能访问那个页面，

1976
01:03:01,460 --> 01:03:03,140
0,120 120,720 840,1200 1200,1530 1530,1680
the collector can access that

1977
01:03:03,140 --> 01:03:04,580
0,270 270,390 390,480 480,960 1050,1440
page at the from| and
|应用程序实际上不能访问那个页面。

1978
01:03:04,580 --> 01:03:06,140
0,390 420,930 930,1050 1050,1290 1290,1560
the application can actually not

1979
01:03:06,140 --> 01:03:07,320
0,300 300,390 390,810
access the page.|
|

1980
01:03:07,650 --> 01:03:08,940
0,330 330,630 690,870 870,1260 1260,1290
{} So it gives a
所以它提供了一个很好的自动并行性，

1981
01:03:08,940 --> 01:03:11,910
0,660 660,1500 1680,2400 2400,2790 2820,2970
nice automatic parallelism,| where the
|应用程序可以运行并执行它的工作，

1982
01:03:11,910 --> 01:03:12,870
0,420 420,510 510,780 780,870 870,960
application can run and do

1983
01:03:12,870 --> 01:03:14,190
0,150 150,690 720,870 870,1200 1200,1320
its business,| the collector can
|收集器可以做它的工作，

1984
01:03:14,190 --> 01:03:16,230
0,150 150,300 300,900 1020,1560 1560,2040
do its business,| {} and
|并且它们永远不会踩到对方的脚趾，

1985
01:03:16,380 --> 01:03:17,490
0,150 150,420 420,720 720,990 990,1110
they will never step on

1986
01:03:17,490 --> 01:03:19,440
0,120 120,360 360,960 1020,1740 1740,1950
each other's toes,| because if
|因为如果应用程序遇到未扫描的页面，

1987
01:03:19,440 --> 01:03:21,720
0,510 540,1290 1320,1590 1590,1770 1770,2280
the application ever will touch

1988
01:03:21,960 --> 01:03:23,640
0,150 150,450 450,750 750,1290 1470,1680
{} {an,unscanned -} page| and
|将获得一个页面错误，

1989
01:03:23,640 --> 01:03:24,600
0,150 150,240 240,270 270,540 540,960
it get a page fault,|
|

1990
01:03:24,870 --> 01:03:28,350
0,750 750,1410 1410,2130 2520,2910 2910,3480
{} and {}, and the
而且收集器从来不碰扫描过的页面，

1991
01:03:28,560 --> 01:03:31,050
0,510 540,870 870,1440 1620,2100 2100,2490
{} collector never touches scanned

1992
01:03:31,050 --> 01:03:32,730
0,600 720,1050 1050,1260 1260,1440 1440,1680
pages,| and so will never
|所以永远不会干扰应用程序。

1993
01:03:32,730 --> 01:03:34,160
0,360 360,480 480,540 540,1080
interfere with the application.|
|

1994
01:03:35,430 --> 01:03:36,810
0,240 240,540 540,750 750,960 960,1380
{} So you get {sort,of}
所以你可以免费得到并行，

1995
01:03:36,990 --> 01:03:39,750
0,660 1020,1680 1920,2370 2370,2520 2520,2760
{ -} concurrency for free,|
|

1996
01:03:39,750 --> 01:03:40,440
0,150 150,240 240,510 510,630 630,690
but it actually has a
但它实际上有一个棘手的问题。

1997
01:03:40,440 --> 01:03:41,680
0,300 300,750
tricky issue.|
|

1998
01:03:48,420 --> 01:03:49,860
0,450 450,600 600,870 870,990 990,1440
Although it's almost for free,|
虽然几乎是免费的，|

1999
01:03:49,860 --> 01:03:50,850
0,90 90,210 210,450 450,720 720,990
you know there's actually one
实际上有一件事你必须安排，

2000
01:03:50,850 --> 01:03:51,660
0,210 210,330 330,600 600,720 720,810
thing you actually have to

2001
01:03:51,660 --> 01:03:55,140
0,840 1200,1470 1470,1860 2160,2940 2970,3480
arrange,| which is {} the
|就是区域，

2002
01:03:55,560 --> 01:03:57,420
0,720 720,1020 1020,1170 1170,1620 1650,1860
area, correct,| in the {unscanned
|在未扫描区域，是未映射的，

2003
01:03:57,420 --> 01:03:59,100
0,330 330,600 600,750 750,1140 1140,1680
-} area, which actually unmapped,|
|

2004
01:03:59,130 --> 01:04:00,120
0,270 270,390 390,570 570,660 660,990
so we look at our
所以我们看一下前面的图片，

2005
01:04:00,450 --> 01:04:03,630
0,720 750,1350 1350,1740 1740,2430 2700,3180
{} picture from before {},|
|

2006
01:04:03,630 --> 01:04:05,540
0,300 300,630 870,1440
here are two,|
这里有两个，|

2007
01:04:05,760 --> 01:04:07,400
0,150 150,450 450,1050
where {here's,our} from,
这里是 from ，这里是 to ，

2008
01:04:07,490 --> 01:04:09,110
0,300 300,420 420,1110 1200,1530 1530,1620
here's our to,| and you
|我们把它分成了未扫描的和已扫描的区域，

2009
01:04:09,110 --> 01:04:10,760
0,150 150,270 270,810 870,1260 1260,1650
know we have {} split

2010
01:04:10,760 --> 01:04:11,930
0,180 180,300 300,510 510,600 600,1170
in the {unscanned - -},

2011
01:04:13,120 --> 01:04:14,860
0,480 480,540 540,1140
scanned the area,|
|

2012
01:04:14,860 --> 01:04:15,730
0,240 240,390 390,540 540,780 780,870
and {unscanned -} {} it
并且未扫描的，它的保护位是 None 。

2013
01:04:15,730 --> 01:04:17,440
0,300 300,600 600,1050 1050,1320 1320,1710
has no, {} none, protect

2014
01:04:17,440 --> 01:04:18,580
0,360
none.|
|

2015
01:04:19,110 --> 01:04:20,340
0,180 180,270 270,570 570,660 660,1230
So that raises the question,|
所以这就提出了一个问题，|

2016
01:04:21,100 --> 01:04:22,000
0,120 120,240 240,360 360,540 540,900
you know how this actually
收集器是如何通过，

2017
01:04:22,000 --> 01:04:24,100
0,180 180,900 990,1470 1470,1830 1830,2100
do collector go through,| because
|因为我们不能访问这些页面，

2018
01:04:24,100 --> 01:04:25,720
0,120 120,390 390,960 990,1410 1410,1620
we can't actually access those

2019
01:04:25,720 --> 01:04:27,160
0,510 510,900 900,1020 1020,1170 1170,1440
pages,| because you know they're
|因为它们是未映射的，是无法访问的。

2020
01:04:27,160 --> 01:04:30,280
0,120 120,510 510,1140 1560,2490 2760,3120
{unmap -}, correct, {} they're

2021
01:04:30,280 --> 01:04:31,520
0,720
inaccessible.|
|

2022
01:04:31,610 --> 01:04:32,360
0,120 120,270 270,450 450,540 540,750
And so and the trick
所以，技巧是这样的，

2023
01:04:32,360 --> 01:04:34,430
0,180 180,510 510,1200 1440,1890 1890,2070
is basically {as,follows},| {} and
|这就是 map2 的作用，

2024
01:04:34,430 --> 01:04:35,930
0,150 150,210 210,750 810,1320 1320,1500
this is where {map2 -}

2025
01:04:35,930 --> 01:04:37,080
0,240 240,600
comes in,|
|

2026
01:04:38,260 --> 01:04:39,010
0,210 210,300 300,450 450,660 660,750
what we're gonna do is
我们要做的是映射相同的物理内存，

2027
01:04:39,010 --> 01:04:39,880
0,240 240,420 420,480 480,720 720,870
actually going to map that

2028
01:04:39,880 --> 01:04:42,060
0,660 690,1020 1020,1560
same physical memory,|
|

2029
01:04:42,060 --> 01:04:43,320
0,180 180,420 420,510 510,960 960,1260
we mapped at once, correct,|
我们映射一次，|

2030
01:04:43,320 --> 01:04:44,160
0,90 90,300 300,390 390,690 690,840
we mapped at once in
我们这样映射一次，

2031
01:04:44,160 --> 01:04:45,400
0,180 180,660
this way,|
|

2032
01:04:45,490 --> 01:04:46,540
0,180 180,300 300,540 540,720 720,1050
and gonna map the second
然后以收集器的角度再映射一次，

2033
01:04:46,540 --> 01:04:48,900
0,600 1050,1380 1380,1830
time in the

2034
01:04:49,080 --> 01:04:50,640
0,600 630,1140 1140,1380 1380,1470 1470,1560
collector's view,| sort of the
|收集器视角的 to 空间。

2035
01:04:50,640 --> 01:04:52,360
0,420 420,630 630,750 750,1080
collector's view of the

2036
01:04:52,480 --> 01:04:53,880
0,150 150,690
to space.|
|

2037
01:04:54,490 --> 01:04:55,750
0,150 150,450 450,840 840,1020 1020,1260
So here's collector's view, here's
所以，这里是收集器的角度，这里是应用的角度，

2038
01:04:55,750 --> 01:04:57,520
0,90 90,390 390,930 1530,1680 1680,1770
the app view| and in
|从收集器的角度来看，

2039
01:04:57,520 --> 01:04:59,230
0,90 90,510 510,990 1020,1650 1650,1710
the collector's view,| where I
|仍然有和以前一样 to 和 from 。

2040
01:04:59,230 --> 01:05:00,340
0,240 240,390 390,600 600,750 750,1110
still have to and from

2041
01:05:00,340 --> 01:05:02,680
0,420 420,600 600,1230
exactly like before.|
|

2042
01:05:02,680 --> 01:05:04,340
0,390 390,540 540,600 600,1050
Oops, let me try.|
哎呀，让我试试。|

2043
01:05:04,750 --> 01:05:06,300
0,240 240,390 390,960
We have to
我们有 to 和 from 。

2044
01:05:06,360 --> 01:05:07,980
0,360 360,990
and from.|
|

2045
01:05:09,100 --> 01:05:10,390
0,510 540,810 810,1020 1020,1080 1080,1290
And {} what we're doing
我们实际上在做的是，

2046
01:05:10,390 --> 01:05:11,530
0,330 330,420 420,540 540,720 720,1140
actually| you know here's our
|这是我们的未扫描区域，

2047
01:05:11,530 --> 01:05:13,080
0,300 300,360 360,900
{unscanned -} area,|
|

2048
01:05:16,380 --> 01:05:18,090
0,180 180,330 330,750 780,1350 1380,1710
but in the collector, we
但在收集器看来，我们映射那些未扫描区域为可读写，

2049
01:05:18,090 --> 01:05:19,350
0,300 300,570 570,780 780,1050 1050,1260
map actually those unscanned {area

2050
01:05:19,350 --> 01:05:20,880
0,210 210,480 480,870
-} {read,and} write,|
|

2051
01:05:21,350 --> 01:05:22,580
0,390 390,630 630,750 750,900 900,1230
{} and so that the
这样收集器才能通过，

2052
01:05:22,700 --> 01:05:23,900
0,390 390,570 570,690 690,870 870,1200
collector actually can go through,|
|

2053
01:05:23,900 --> 01:05:25,040
0,210 210,300 300,720 750,1050 1050,1140
look at the, scan the
扫描对象转发指针是必要的。

2054
01:05:25,040 --> 01:05:26,540
0,630 630,720 720,930 930,1200 1200,1500
objects you know and forward

2055
01:05:26,540 --> 01:05:28,220
0,240 240,480 480,1020
pointer is necessary.|
|

2056
01:05:28,530 --> 01:05:29,340
0,150 150,270 270,390 390,630 630,810
And so the here's look
所以这是需要 map2 调用的地方，

2057
01:05:29,340 --> 01:05:30,510
0,60 60,150 150,540 540,960 960,1170
at the place where this

2058
01:05:30,510 --> 01:05:31,980
0,270 270,750 960,1140 1140,1350 1350,1470
{map2 -} {} call is

2059
01:05:31,980 --> 01:05:34,830
0,570 570,960 1260,1650 1650,2070 2100,2850
necessary,| where { -} arrange
|排列物理内存映射两次，

2060
01:05:34,920 --> 01:05:37,110
0,300 300,960 1440,1800 1800,2130 2130,2190
{ -} physical piece of

2061
01:05:37,110 --> 01:05:38,220
0,270 270,540 540,630 630,840 840,1110
physical memory is actually mapped

2062
01:05:38,220 --> 01:05:39,450
0,510 510,600 600,720 720,960 960,1230
twice| in the address space
|在应用程序的地址空间中，

2063
01:05:39,450 --> 01:05:40,920
0,90 90,180 180,1020 1020,1320 1320,1470
of an application,| at two
|以两种不同的保护级别，

2064
01:05:40,920 --> 01:05:42,500
0,270 270,480 480,540 540,990
different levels of protection,|
|

2065
01:05:42,590 --> 01:05:43,850
0,180 180,330 330,660 660,1170 1170,1260
{} to basically make things,
让这样的场景是可行的。

2066
01:05:43,850 --> 01:05:45,560
0,390 390,510 510,690 690,1080
scenario like this work.|
|

2067
01:05:46,850 --> 01:05:48,660
0,210 210,540 540,750 750,1050
Any questions about this?|
对于这个，有什么问题吗？|

2068
01:05:57,670 --> 01:05:59,230
0,570 600,750 750,930 930,990 990,1560
{} I have a question,|
我有个问题，|

2069
01:05:59,230 --> 01:06:00,480
0,270 270,780
do you,
你会给应用程序中的每个收集器

2070
01:06:01,270 --> 01:06:03,430
0,180 180,420 420,690 690,1200 1290,2160
do you kind of give

2071
01:06:03,460 --> 01:06:05,500
0,660 810,1080 1080,1680 1680,1860 1860,2040
each {} collector in the

2072
01:06:05,500 --> 01:06:06,700
0,660
app,|
|

2073
01:06:06,700 --> 01:06:07,940
0,690

2074
01:06:08,160 --> 01:06:09,690
0,390 390,900 900,1020 1020,1170 1170,1530
different versions of the page
不同版本的页表，还是。

2075
01:06:09,690 --> 01:06:12,090
0,720 720,1500 1710,2100 2100,2220 2220,2400
table, or.| No, they have
|不，它们有相同的页表，

2076
01:06:12,090 --> 01:06:13,830
0,60 60,720 750,1050 1050,1410 1410,1740
the same page table, correct,|
|

2077
01:06:13,830 --> 01:06:15,630
0,150 150,270 270,600 600,1230 1290,1800
but they have the memory
但是它们把内存映射到两个地方，

2078
01:06:15,630 --> 01:06:17,610
0,480 480,1140 1140,1560 1560,1650 1650,1980
mapped {in,two} place,| the physical
|物理内存映射在地址空间中的两个不同位置，

2079
01:06:17,610 --> 01:06:19,290
0,300 300,600 600,900 900,1260 1260,1680
memory map {in,two} different places

2080
01:06:19,290 --> 01:06:20,340
0,90 90,180 180,420 420,780 780,1050
in the address space,| {in,two}
|在页表中的两个不同位置。

2081
01:06:20,340 --> 01:06:21,840
0,300 300,720 720,1110 1110,1230 1230,1500
different places places in {}

2082
01:06:21,840 --> 01:06:22,860
0,240 240,600
page table.|
|

2083
01:06:23,560 --> 01:06:25,540
0,480 540,990 990,1200 1200,1470 1470,1980
And, {} in one place
而且，在一个地方，映射是无效的，

2084
01:06:25,540 --> 01:06:28,270
0,690 720,1590 1680,2340 2340,2430 2430,2730
you {} basically the mapping

2085
01:06:28,270 --> 01:06:29,920
0,60 60,720 1170,1380 1380,1500 1500,1650
is invalid,| and in the
|在另一个地址范围中，映射是可读写的。

2086
01:06:29,920 --> 01:06:31,630
0,600 630,1020 1020,1350 1350,1500 1500,1710
other address range, you make

2087
01:06:31,630 --> 01:06:33,600
0,60 60,720 750,1470
the mapping {read,write}.|
|

2088
01:06:35,940 --> 01:06:36,940
0,480
Okay.|
好的。|

2089
01:06:39,440 --> 01:06:40,220
0,150 150,240 240,420 420,600 600,780
Let me make, {} make
我把这个说得更清楚一点，

2090
01:06:40,220 --> 01:06:41,450
0,570 600,900 900,1020 1020,1080 1080,1230
a make this a little

2091
01:06:41,450 --> 01:06:43,580
0,120 120,270 270,750 780,1410
bit more clear {},|
|

2092
01:06:44,150 --> 01:06:44,810
0,240 240,330 330,390 390,540 540,660
since there were so many
因为很多关于它的问题。

2093
01:06:44,810 --> 01:06:46,680
0,330 330,570 570,780
questions about it.|
|

2094
01:06:46,680 --> 01:06:47,640
0,480

2095
01:06:47,790 --> 01:06:48,750
0,150 150,300 300,420 420,540 540,960
I actually have a trivial
我有一个对这个想法的的简单实现，

2096
01:06:48,750 --> 01:06:51,660
0,780 780,1200 1200,1770 1770,2250
implementation of actually {

2097
01:06:51,690 --> 01:06:54,900
0,690 1110,1800 1800,2190 2190,2820 2910,3210
-} this basic idea,| the
|论文中描述的想法，

2098
01:06:54,900 --> 01:06:55,800
0,270 270,360 360,480 480,840 840,900
idea that was described in

2099
01:06:55,800 --> 01:06:57,030
0,60 60,570 780,1020 1020,1110 1110,1230
the paper,| that you could
|你可以了解得更具体一点。

2100
01:06:57,030 --> 01:06:57,510
0,150 150,210 210,240 240,390 390,480
make it a little bit

2101
01:06:57,510 --> 01:06:59,980
0,180 180,720
more concrete.|
|

2102
01:07:00,250 --> 01:07:02,110
0,240 240,720 960,1140 1140,1740 1740,1860
And so, {} let me
所以，让我来介绍一下，

2103
01:07:02,110 --> 01:07:03,940
0,270 270,420 420,810 810,1230 1230,1830
walk through this| and ask
|请随意问问题，

2104
01:07:04,780 --> 01:07:05,950
0,210 210,420 420,630 630,870 870,1170
feel free to jump in,|
|

2105
01:07:06,520 --> 01:07:08,140
0,450 450,750 750,1350 1350,1410 1410,1620
basically toy implementation of what's
基本上实现了论文中所描述的内容，

2106
01:07:08,140 --> 01:07:09,730
0,360 360,420 420,480 480,1020 1200,1590
described in the paper| and
|我敢肯定它有漏洞，

2107
01:07:09,730 --> 01:07:10,600
0,90 90,270 270,360 360,510 510,870
I'm sure it has bugs,|
|

2108
01:07:10,600 --> 01:07:12,580
0,180 180,480 750,870 870,1260 1680,1980
I mean, {} I haven't
我的意思是，我没有认真地测试过它，

2109
01:07:12,580 --> 01:07:13,690
0,300 300,630 630,750 750,900 900,1110
really tested this in any

2110
01:07:13,690 --> 01:07:15,760
0,150 150,780 900,1320 1320,1740 1740,2070
way seriously,| but it's mostly
|但它主要描述了，

2111
01:07:15,760 --> 01:07:17,290
0,450 450,1200 1200,1290 1290,1440 1440,1530
there's illustrates| you know to
|让一切变得更具体。

2112
01:07:17,290 --> 01:07:18,760
0,150 150,480 480,840 840,1020 1020,1470
make everything slightly more concrete.|
|

2113
01:07:19,330 --> 01:07:21,190
0,420 450,690 690,780 780,1530 1590,1860
{} So the collector,| the
所以，收集器，|应用程序使用的 API 是，

2114
01:07:21,190 --> 01:07:22,390
0,510 510,600 600,720 720,1080 1080,1200
API if you will that

2115
01:07:22,390 --> 01:07:25,030
0,120 120,720 720,1770 1980,2160 2160,2640
the application {uses,is},| a new
|一个 new 和 readptr ，

2116
01:07:25,030 --> 01:07:26,590
0,180 180,330 330,840 840,1170 1170,1560
and {readptr -},| {and,readptr -}
|readptr 检查指针是否在 from 空间中，

2117
01:07:26,590 --> 01:07:28,630
0,180 180,330 330,930 1290,1920 1920,2040
is that basically does the

2118
01:07:28,630 --> 01:07:31,960
0,510 600,1440 1440,1980 2820,3180 3180,3330
check whether {} pointers in

2119
01:07:31,960 --> 01:07:33,040
0,210 210,630 630,810 810,1020 1020,1080
from space,| and if it
|如果它在 from 空间中，则需要复制，

2120
01:07:33,040 --> 01:07:33,940
0,120 120,240 240,300 300,570 570,900
is in the from space,

2121
01:07:33,940 --> 01:07:34,990
0,240 240,420 420,480 480,570 570,1050
that needs to be copied|
|

2122
01:07:35,230 --> 01:07:36,100
0,180 180,240 240,510 510,750 750,870
and of course when we're
当然，当我们使用虚拟内存技巧时，

2123
01:07:36,100 --> 01:07:38,560
0,270 270,960 1230,1860 1860,2100 2100,2460
using VM tricks,| then basically
|那么 readptr 将会非常轻，

2124
01:07:38,560 --> 01:07:39,340
0,150 150,360 360,600 600,660 660,780
this {readptr -} is going

2125
01:07:39,340 --> 01:07:40,390
0,60 60,150 150,360 360,660 660,1050
to be very cheap,| we
|我们只返回参数。

2126
01:07:40,390 --> 01:07:42,580
0,300 300,630 630,690 690,1080 1800,2190
basically return the [] {return,the}

2127
01:07:42,580 --> 01:07:43,380
0,480
argument.|
|

2128
01:07:44,590 --> 01:07:45,940
0,570 660,960 960,1050 1050,1230 1230,1350
{} If we're just for
如果我们只针对这个简单的应用程序，

2129
01:07:45,940 --> 01:07:47,440
0,120 120,360 360,1020 1020,1230 1230,1500
this simple application,| I have
|我有一个链表，它有两个 root ，

2130
01:07:47,440 --> 01:07:49,510
0,210 210,540 540,1020 1320,1890 1890,2070
a linked list and it

2131
01:07:49,510 --> 01:07:50,560
0,180 180,330 330,870 870,960 960,1050
has two roots,| you know
|指向，

2132
01:07:50,560 --> 01:07:52,030
0,300 300,510 510,660 660,990 1140,1470
pointing,| one to the head
|一个指向链表的头部，一个指向链表的最后一个节点，

2133
01:07:52,030 --> 01:07:52,990
0,90 90,270 270,390 390,480 480,960
and one to the last

2134
01:07:52,990 --> 01:07:53,980
0,240 240,330 330,420 420,690 690,990
node of the linked list,|
|

2135
01:07:53,980 --> 01:07:55,570
0,420 420,480 480,960 960,1200 1200,1590
it's a circular linked list,|
这是一个循环链表，|

2136
01:07:56,040 --> 01:07:57,780
0,240 240,600 600,1050 1110,1230 1230,1740
and nothing really too exciting
没有什么真正令人兴奋的事情发生，

2137
01:07:57,780 --> 01:07:59,070
0,300 300,570 570,990 990,1200 1200,1290
going on,| basically what the
|基本上应用程序所做的是，

2138
01:07:59,070 --> 01:08:00,960
0,720 780,990 990,1110 1110,1470 1470,1890
application {[] -} does is,|
|

2139
01:08:01,380 --> 01:08:02,820
0,480 480,570 570,630 630,960 960,1440
you know {} thousand times
上千次创建列表，

2140
01:08:02,820 --> 01:08:05,280
0,330 330,660 660,1170 1560,2100 2160,2460
makes the list| and {make_clist
|make_clist 和 check_clist ，

2141
01:08:05,280 --> 01:08:06,780
0,60 60,570 660,1110 1140,1440 1440,1500
- -} and {check_clist -

2142
01:08:06,780 --> 01:08:08,160
0,480 510,780 780,900 900,990 990,1380
-},| and so it generates
|所以它会产生很多垃圾，

2143
01:08:08,160 --> 01:08:09,060
0,30 30,180 180,240 240,720 720,900
a lot of garbage,| like
|比如每次 make_clist 完成，

2144
01:08:09,060 --> 01:08:10,320
0,450 450,750 750,810 810,1050 1050,1260
everytime after to {make_clist -}

2145
01:08:10,320 --> 01:08:11,490
0,90 90,450 810,990 990,1110 1110,1170
is done,| it's going to
|它会产生一个新的，

2146
01:08:11,490 --> 01:08:12,180
0,90 90,120 120,270 270,570 570,690
make a new one| and
|所以上一个列表成了垃圾。

2147
01:08:12,180 --> 01:08:13,050
0,120 120,210 210,510 510,750 750,870
so the last list is

2148
01:08:13,050 --> 01:08:14,300
0,330 330,870
basically garbage.|
|

2149
01:08:14,760 --> 01:08:15,750
0,240 240,330 330,450 450,750 750,990
And so the collector actually
所以收集器有事情要做，

2150
01:08:15,750 --> 01:08:17,160
0,300 330,630 630,720 720,1080 1080,1410
has something to do| and
|make_clist 就是一些难看的代码，

2151
01:08:17,160 --> 01:08:18,240
0,300 300,360 360,870 870,930 930,1080
{make_clist - -} you know

2152
01:08:18,240 --> 01:08:19,350
0,360 360,720 720,750 750,930 930,1110
is basically a little bit

2153
01:08:19,350 --> 01:08:22,080
0,150 150,600 600,1110 1350,2370 2370,2730
of ugly code,| mostly because
|主要是因为每个指针都包裹在 readptr 中，

2154
01:08:22,080 --> 01:08:23,370
0,90 90,270 270,570 570,1020 1020,1290
you know every pointer needs

2155
01:08:23,370 --> 01:08:24,330
0,90 90,300 300,660 660,750 750,960
to be wrapped in this

2156
01:08:24,330 --> 01:08:25,800
0,150 150,480 480,540 540,960
{readptr - -} check,|
|

2157
01:08:26,130 --> 01:08:27,630
0,720 720,810 810,1110 1110,1230 1230,1500
normally, of course would be
通常情况下，当然会由编译器生成，

2158
01:08:27,630 --> 01:08:29,280
0,450 450,600 600,690 690,1290 1350,1650
generated by a compiler| and
|我没有针对垃圾收集语言的编译器，

2159
01:08:29,280 --> 01:08:29,880
0,60 60,210 210,390 390,540 540,600
I don't really have a

2160
01:08:29,880 --> 01:08:31,350
0,540 540,810 810,870 870,1170 1170,1470
compiler for a garbage collected

2161
01:08:31,350 --> 01:08:32,310
0,390 390,540 540,630 630,780 780,960
language| and so I'm just
|所以我只是在模拟可能由编译器生成的。

2162
01:08:32,310 --> 01:08:34,590
0,720 1140,1410 1410,1770 1770,1920 1920,2280
simulating {} what may be

2163
01:08:34,590 --> 01:08:36,360
0,960 960,1230 1230,1410 1410,1560 1560,1770
a {compiler -} that might

2164
01:08:36,360 --> 01:08:37,580
0,120 120,780
have generated.|
|

2165
01:08:39,080 --> 01:08:40,880
0,420 420,870 870,960 960,1170 1170,1800
And basically you want you
基本上，代码所做的是，

2166
01:08:40,970 --> 01:08:42,470
0,300 450,600 810,1080 1080,1410 1410,1500
know the code does is,|
|

2167
01:08:42,470 --> 01:08:44,660
0,330 330,600 600,1020 1020,1620 1710,2190
it goes through the built
它构建的至少具有 LISTSZ 的列表，

2168
01:08:44,660 --> 01:08:45,560
0,30 30,360 360,480 480,600 600,900
a list of at least

2169
01:08:45,560 --> 01:08:47,210
0,210 210,750 870,1410 1410,1470 1470,1650
{LISTSZ -},| allocates a new
|分配一个新元素，

2170
01:08:47,210 --> 01:08:51,110
0,630 960,1950 1950,2640 3000,3600 3600,3900
element| {} and {} stick
|放到列表的开头，

2171
01:08:51,110 --> 01:08:52,160
0,90 90,360 390,840 840,990 990,1050
to the prepend at the

2172
01:08:52,160 --> 01:08:53,090
0,300 300,390 390,510 510,840 840,930
beginning of the list,| and
|然后更新最后一个指针指向列表的开头，

2173
01:08:53,090 --> 01:08:54,680
0,180 180,660 660,870 870,1230 1230,1590
then updates the last pointer

2174
01:08:54,680 --> 01:08:55,730
0,90 90,420 420,810 810,960 960,1050
to point basically to the

2175
01:08:55,730 --> 01:08:56,960
0,270 270,390 390,480 480,810 1020,1230
beginning of the list,| so
|所以这是环形的。

2176
01:08:56,960 --> 01:08:58,060
0,180 180,660
that's circular.|
|

2177
01:08:59,920 --> 01:09:01,450
0,150 150,480 480,660 660,1110 1260,1530
Any questions about this little
关于这一小段代码，有什么问题吗？

2178
01:09:01,450 --> 01:09:03,220
0,330 330,390 390,1290
fragment of code?|
|

2179
01:09:06,400 --> 01:09:07,570
0,150 150,210 210,360 360,630 630,1170
So the most interesting {question,is},|
所以最有趣的问题是，|

2180
01:09:07,570 --> 01:09:08,590
0,120 120,270 270,450 450,630 630,1020
like what goes on exactly
收集器到底是怎么做的，

2181
01:09:08,590 --> 01:09:10,330
0,60 60,660 780,1230 1230,1590 1590,1740
the collector,| let's first look
|让我们首先看看没有虚拟内存的情况，

2182
01:09:10,330 --> 01:09:11,260
0,60 60,150 150,450 450,720 720,930
at the case where there's

2183
01:09:11,260 --> 01:09:13,300
0,390 420,750 750,1170 1380,1950 1950,2040
no virtual memory,| where we're
|我们不会使用这些技巧。

2184
01:09:13,300 --> 01:09:14,940
0,210 210,450 450,600 600,1050
not using these tricks.|
|

2185
01:09:15,120 --> 01:09:15,930
0,300 300,450 450,570 570,690 690,810
{} And so we just
所以我们只需要看看两个 API ，

2186
01:09:15,930 --> 01:09:16,860
0,120 120,210 210,330 330,450 450,930
have to look at two

2187
01:09:16,860 --> 01:09:18,600
0,510 510,780 1110,1260 1260,1620 1620,1740
{APIs -},| {} one is
|一种是 new 和 readptr 。

2188
01:09:18,600 --> 01:09:21,240
0,450 450,1140 1170,1470 1470,2040
{new -} and readptr.|
|

2189
01:09:21,240 --> 01:09:24,480
0,120 120,780 810,1560 1980,2670 2880,3240
So {here's -} new,| forget
所以，这里是 new ，|忽略这个 mutex ，它是针对虚拟内存解决方案的，

2190
01:09:24,480 --> 01:09:25,500
0,120 120,210 210,720 720,900 900,1020
the {mutex -}, that is

2191
01:09:25,500 --> 01:09:27,000
0,150 150,240 240,570 570,930 930,1500
for the VM based solution,|
|

2192
01:09:27,800 --> 01:09:30,260
0,540 840,1440 1440,1470 1470,1470 2190,2460
{} basically, {} I []
基本上，

2193
01:09:30,260 --> 01:09:31,460
0,120 120,480 660,1020 1020,1110 1110,1200
that,| we're assuming that we're
|我们假设我们有一段时间没有扫描，没有收集，

2194
01:09:31,460 --> 01:09:32,660
0,270 270,510 510,870 870,990 990,1200
actually not scanning, we're not

2195
01:09:32,660 --> 01:09:34,250
0,360 360,480 480,630 630,1110 1320,1590
collecting for a while,| were
|我们会检查是否还有足够的空间在空闲空间中，

2196
01:09:34,250 --> 01:09:36,300
0,690 720,1470
basically, {}

2197
01:09:36,300 --> 01:09:37,770
0,180 180,510 510,690 690,870 870,1470
we check if there's enough

2198
01:09:38,640 --> 01:09:40,140
0,480 480,960
space left

2199
01:09:40,170 --> 01:09:42,240
0,570 570,1020 1020,1560 1590,1740 1740,2070
{} in the free space,|
|

2200
01:09:42,240 --> 01:09:43,620
0,180 180,360 360,750 870,1080 1080,1380
if there's enough free space
如果有足够的自由空间，

2201
01:09:43,620 --> 01:09:44,550
0,300 300,630 630,690 690,810 810,930
{} left,| you know we
|我们只是向上一点，

2202
01:09:44,550 --> 01:09:45,720
0,120 120,360 360,480 480,930 960,1170
just bump up to point

2203
01:09:45,720 --> 01:09:46,560
0,90 90,270 270,660 660,750 750,840
a little bit,| you know
|分配对象并将其返回。

2204
01:09:46,560 --> 01:09:48,300
0,120 120,510 510,1110 1110,1380 1380,1740
to allocate object and return

2205
01:09:48,300 --> 01:09:49,080
0,210
it.|
|

2206
01:09:49,310 --> 01:09:51,500
0,510 540,720 720,900 900,1440 1710,2190
And if there's not enough
如果没有足够的空间，

2207
01:09:51,500 --> 01:09:53,390
0,300 300,720 750,1500 1500,1740 1740,1890
space less left,| then we
|那么我们必须翻转，

2208
01:09:53,390 --> 01:09:54,590
0,330 330,450 450,540 540,960 960,1200
basically have to flip,| we
|我们必须运行垃圾收集器。

2209
01:09:54,590 --> 01:09:55,610
0,120 120,210 210,330 330,690 690,1020
have to do {the,garbage} collector

2210
01:09:55,610 --> 01:09:56,440
0,270
run.|
|

2211
01:09:56,710 --> 01:09:58,150
0,300 300,690 690,930 960,1320 1320,1440
And so we look at
所以我们看看 flip ，

2212
01:09:58,150 --> 01:09:59,220
0,540
flip,|
|

2213
01:09:59,920 --> 01:10:02,080
0,870 900,1110 1110,1410 1410,1740 1740,2160
{} {you,know} flip basically switches
flip 是切换 to 和 from 指针，

2214
01:10:02,080 --> 01:10:03,580
0,90 90,390 390,600 600,930 930,1500
the to from pointers around,|
|

2215
01:10:04,030 --> 01:10:08,020
0,840 1230,2100 2220,3300 3300,3600 3600,3990
{} and basically forward which
转发应用程序包含的两个 root ，

2216
01:10:08,020 --> 01:10:09,130
0,120 120,270 270,420 420,660 660,1110
you know the two roots

2217
01:10:09,130 --> 01:10:11,020
0,270 270,420 420,990 990,1470 1770,1890
that this application has,| you
|从 from 空间到 to 空间，

2218
01:10:11,020 --> 01:10:13,420
0,180 180,720 720,1230 1260,1710 2040,2400
know to {} the {}

2219
01:10:13,420 --> 01:10:15,160
0,270 270,600 720,1050 1050,1380 1380,1740
from the from space to

2220
01:10:15,160 --> 01:10:16,360
0,480 510,690 690,900 900,1080 1080,1200
space,| so let's look at
|所以让我们看看 forward 。

2221
01:10:16,360 --> 01:10:17,360
0,540
forward.|
|

2222
01:10:25,000 --> 01:10:27,310
0,240 240,390 390,1080 1560,2130 2130,2310
So here's forward,| {} it
所以这是 forward ，|forward 查看 o 指向的对象，

2223
01:10:27,310 --> 01:10:29,220
0,450 450,750 750,1290
looks if the

2224
01:10:29,400 --> 01:10:31,680
0,390 390,390 1500,2040 2040,2190 2190,2280
forward {} object that is

2225
01:10:31,680 --> 01:10:32,970
0,240 240,330 330,840 840,930 930,1290
pointed to {by,o},| it looks
|它看起来总是在 from 空间中，

2226
01:10:32,970 --> 01:10:34,020
0,330 330,630 630,720 720,810 810,1050
always actually in the from

2227
01:10:34,020 --> 01:10:34,950
0,390 390,630 630,720 720,840 840,930
space,| if it is in
|如果它在 from 空间中，

2228
01:10:34,950 --> 01:10:36,540
0,90 90,360 360,930 1350,1500 1500,1590
the from space| and it
|并且之前没有被复制过，

2229
01:10:36,540 --> 01:10:38,190
0,240 240,510 510,630 630,1020 1020,1650
has not been copied before,|
|

2230
01:10:38,810 --> 01:10:40,880
0,600 630,1200 1200,1500 1500,1710 1710,2070
then {} we're gonna copy
然后我们要复制它，

2231
01:10:40,880 --> 01:10:43,790
0,330 780,1650 1680,2430 2460,2730 2730,2910
it| and {} now we're
|现在我们就完成了。

2232
01:10:43,790 --> 01:10:44,930
0,240 240,450 450,570 570,1020 1020,1140
done.| So we moved the
|所以我们把对象从 from 空间移到 to 空间，

2233
01:10:44,930 --> 01:10:46,760
0,360 360,540 540,1320 1350,1560 1560,1830
object from the from space

2234
01:10:46,760 --> 01:10:48,830
0,210 210,720 1170,1650 1650,1830 1830,2070
{to,to} space,| if we already
|如果我们已经复制了它，

2235
01:10:48,830 --> 01:10:50,030
0,390 390,630 630,810 810,1080 1080,1200
copied it,| then basically we
|那么我们可以替换指针，

2236
01:10:50,030 --> 01:10:51,620
0,150 150,570 570,690 690,1350 1440,1590
can replace the pointer,| you
|我们有新的指针是，

2237
01:10:51,620 --> 01:10:52,960
0,150 150,240 240,360 360,840
know we have the

2238
01:10:52,990 --> 01:10:54,640
0,570 600,900 900,1140 1140,1260 1260,1650
{} new pointer is| actually
|指向已经移动的对象的指针，

2239
01:10:54,640 --> 01:10:56,740
0,390 420,990 990,1260 1260,1680 1860,2100
the pointer to the {}

2240
01:10:56,740 --> 01:10:58,570
0,420 420,720 720,1230 1350,1530 1530,1830
already moved object| and return
|并返回该指针。

2241
01:10:58,570 --> 01:10:59,460
0,330
that.|
|

2242
01:10:59,990 --> 01:11:01,280
0,750
Okay?|
好的?|

2243
01:11:01,630 --> 01:11:03,200
0,150 150,330 330,1020
So that's forwarding.|
所以这就是转发。|

2244
01:11:04,060 --> 01:11:06,190
0,690 780,990 990,1200 1200,1290 1290,2130
And so, then the readptr
所以，然后 readptr ，

2245
01:11:06,400 --> 01:11:07,780
0,90 90,270 270,510 510,780 780,1380
you know we actually ever,|
|

2246
01:11:09,730 --> 01:11:10,750
0,180 180,420 420,480 480,840 840,1020
{readptr -} to basically go
readptr 通过，

2247
01:11:10,750 --> 01:11:12,000
0,720
through,|
|

2248
01:11:17,770 --> 01:11:18,820
0,210 210,360 360,480 480,870 900,1050
let's see what the {readptr
让我们看看 readptr 和垃圾收集器，

2249
01:11:18,820 --> 01:11:20,020
0,450 450,600 600,660 660,930 930,1200
-} with the garbage collecter,|
|

2250
01:11:20,020 --> 01:11:22,000
0,180 180,450 450,1110 1290,1740 1740,1980
just {readptr -} {} it's
readptr 在这里，

2251
01:11:22,000 --> 01:11:23,440
0,180 180,390 390,930
like right here,|
|

2252
01:11:24,360 --> 01:11:25,680
0,120 120,210 210,420 420,990 1050,1320
if we're not using {}
如果我们不使用虚拟内存，

2253
01:11:25,680 --> 01:11:27,150
0,120 120,450 450,690 690,870 870,1470
if we're not using VM,|
|

2254
01:11:27,390 --> 01:11:28,890
0,450 450,780 780,930 930,1020 1020,1500
{} basically what it does,|
它说做的，|

2255
01:11:28,980 --> 01:11:30,810
0,360 360,720 720,960 960,1320 1320,1830
{} it {does,a} forward operation,|
它做的是 forward 操作，|

2256
01:11:30,810 --> 01:11:32,100
0,60 60,150 150,420 420,930 930,1290
in the forward operation is
在 forward 操作中检查是否在 from 空间中，

2257
01:11:32,100 --> 01:11:33,510
0,360 360,630 630,720 720,960 960,1410
checking if the from space,|
|

2258
01:11:33,510 --> 01:11:34,380
0,240 240,450 450,540 540,630 630,870
if not in the from
如果不在 from 空间中，那就什么都不做，

2259
01:11:34,380 --> 01:11:36,420
0,480 480,1020 1050,1530
space, then, {

2260
01:11:36,420 --> 01:11:37,770
0,450 450,630 630,1020 1020,1260 1260,1350
-} do nothing,| if it
|如果它在 from 空间中，则重新执行复制。

2261
01:11:37,770 --> 01:11:38,700
0,180 180,270 270,360 360,630 630,930
is in the from space,

2262
01:11:38,700 --> 01:11:40,020
0,240 240,450 450,600 600,990 990,1320
then do this copy again.|
|

2263
01:11:40,590 --> 01:11:41,400
0,180 180,420 420,540 540,660 660,810
So here we see this
所以我们在这里看到这是昂贵的检查，

2264
01:11:41,400 --> 01:11:42,750
0,270 270,360 360,540 540,990 990,1350
sort of the expensive check,|
|

2265
01:11:42,750 --> 01:11:43,950
0,150 150,660 660,990 990,1110 1110,1200
is really checking if the
检查对象是否真的在 from 空间中。

2266
01:11:43,950 --> 01:11:44,940
0,360 360,600 600,810 810,900 900,990
object actually sits in the

2267
01:11:44,940 --> 01:11:46,080
0,210 210,690
from space.|
|

2268
01:11:48,520 --> 01:11:49,780
0,180 180,750
Any questions,|
有什么问题吗，|

2269
01:11:51,170 --> 01:11:52,370
0,390 390,480 480,720 720,1020 1020,1200
before I jump into sort
在我跳到使用虚拟内存技巧的版本之前。

2270
01:11:52,370 --> 01:11:53,540
0,90 90,300 300,660 660,780 780,1170
of the version that actually

2271
01:11:53,540 --> 01:11:55,000
0,240 240,330 330,840
use the VM

2272
01:11:56,240 --> 01:11:57,400
0,510
tricks.|
|

2273
01:11:58,480 --> 01:12:00,190
0,390 660,960 960,1140 1140,1320 1320,1710
Okay, let's look at actually
好的，让我们来看看虚拟内存的技巧，

2274
01:12:00,190 --> 01:12:02,480
0,360 360,750 780,1080 1080,1620
what the VM tricks,|
|

2275
01:12:02,480 --> 01:12:04,130
0,600 630,810 810,900 900,1260 1260,1650
{} so the setup is
所以设置在这里，

2276
01:12:04,160 --> 01:12:06,950
0,840 870,1410 1410,1710 1710,2190 2190,2790
a little bit, is here,|
|

2277
01:12:07,220 --> 01:12:09,350
0,720 990,1710 1710,1800 1800,1950 1950,2130
{} basically you know there's
这里有一个名为 shm_open 的调用，

2278
01:12:09,350 --> 01:12:11,450
0,60 60,540 540,1020 1230,1590 1590,2100
a call called {shm_open -

2279
01:12:11,450 --> 01:12:12,410
0,240 240,450 450,780 780,870 870,960
-}| that allows you to
|它允许你创建一个共享内存对象，

2280
01:12:12,410 --> 01:12:14,330
0,510 510,780 780,1020 1020,1290 1290,1920
create a shared memory object,|
|

2281
01:12:14,360 --> 01:12:15,560
0,270 270,420 420,570 600,900 900,1200
{} it's a Linux call
这是一个 Linux 调用或 Unix 调用，

2282
01:12:15,560 --> 01:12:16,980
0,150 150,210 210,480 480,900
or {} Unix call,|
|

2283
01:12:17,010 --> 01:12:18,390
0,240 240,540 540,720 720,1050 1050,1380
{} and it almost behaves
它的行为几乎就像一个文件，但它不是，

2284
01:12:18,390 --> 01:12:19,290
0,180 180,240 240,660 660,780 780,900
like a file, but it's

2285
01:12:19,290 --> 01:12:21,690
0,450 1320,1650 1860,2190 2190,2340 2340,2400
not,| it behaves like a
|它的行为类似于文件，但它不是文件，

2286
01:12:21,690 --> 01:12:22,560
0,300 300,420 420,540 540,690 690,870
file, but it is not

2287
01:12:22,560 --> 01:12:23,490
0,60 60,330 330,390 390,720 720,930
a file,| it just sits
|它只是驻留在内存中，

2288
01:12:23,490 --> 01:12:24,480
0,90 90,390 390,600 600,750 750,990
in memory,| there's no disk
|没有与之相关的磁盘空间或任何东西，

2289
01:12:24,480 --> 01:12:25,800
0,300 300,870 870,1020 1020,1170 1170,1320
space associated with it or

2290
01:12:25,800 --> 01:12:26,940
0,300 300,450 450,630 630,690 690,1140
anything,| it's like an in-memory
|它就像内存中的文件系统。

2291
01:12:26,940 --> 01:12:27,960
0,270 270,540 540,660 660,750 750,1020
file system, if you will.|
|

2292
01:12:28,820 --> 01:12:31,040
0,720 960,1350 1350,2010 2010,2130 2130,2220
And, {} basically you know
基本上我们在做的是，

2293
01:12:31,040 --> 01:12:32,300
0,210 210,330 330,630 630,960 960,1260
what we're doing is| we
|我们分配一个共享存储器对象，

2294
01:12:32,300 --> 01:12:33,440
0,510 510,690 690,780 780,870 870,1140
allocate one of the shared

2295
01:12:33,440 --> 01:12:35,870
0,270 270,870 1170,1590 1620,2310 2310,2430
memory objects,| we truncate the
|我们将共享存储器对象截断为

2296
01:12:35,870 --> 01:12:37,190
0,210 210,450 450,840 840,1050 1050,1320
shared memory object to be|
|

2297
01:12:37,190 --> 01:12:39,110
0,120 120,570 570,720 720,1470 1560,1920
the size of the sum
to 和 from 空间的大小之和，

2298
01:12:39,110 --> 01:12:39,890
0,120 120,240 240,480 480,570 570,780
of the to and the

2299
01:12:39,890 --> 01:12:41,360
0,240 240,630 630,840 840,960 960,1470
from space,| so we have
|所以我们有一个空间，

2300
01:12:41,390 --> 01:12:42,880
0,300 420,1050
a space,|
|

2301
01:12:42,940 --> 01:12:44,860
0,570 930,1110 1110,1530 1530,1710 1710,1920
{} and then we {map,it}
然后我们对于 mutator 映射一次，

2302
01:12:44,860 --> 01:12:47,380
0,660 1080,1950
once {}

2303
01:12:47,380 --> 01:12:49,060
0,300 300,870 900,1170 1170,1290 1290,1680
in the for {mutator -},|
|

2304
01:12:49,060 --> 01:12:50,110
0,150 150,270 270,450 450,540 540,1050
and we map it once
并且对于收集器映射一次。

2305
01:12:50,110 --> 01:12:51,070
0,120 120,240 240,390 390,480 480,960
you know for the collector.|
|

2306
01:12:52,150 --> 01:12:54,190
0,510 750,1020 1020,1200 1200,1350 1350,2040
{} So this is basically
所以这就是这里的操作顺序，

2307
01:12:54,280 --> 01:12:54,880
0,120 120,180 180,330 330,540 540,600
you know the sort of

2308
01:12:54,880 --> 01:12:56,470
0,390 390,480 480,1020 1020,1500 1500,1590
sequence of operations here,| you
|shm_open ftruncate 和两个 mmap ，

2309
01:12:56,470 --> 01:12:57,580
0,90 90,240 240,480 480,870 870,1110
know the {shm_open - -},

2310
01:12:57,580 --> 01:12:58,600
0,90 90,690 690,780 780,840 840,1020
the ftruncate and the two

2311
01:12:58,600 --> 01:13:00,100
0,180 180,540 810,960 960,1320 1320,1500
{mmaps -}| are basically sort
|基本上等同于 map2 调用。

2312
01:13:00,100 --> 01:13:01,660
0,120 120,720 720,840 840,1140 1170,1560
of equivalent of the {map2

2313
01:13:01,660 --> 01:13:02,940
0,270 270,840
-} calls.|
|

2314
01:13:04,580 --> 01:13:05,600
0,90 90,270 270,420 420,660 660,1020
And so we look at
所以我们看看，

2315
01:13:05,630 --> 01:13:07,500
0,180 180,450 570,1320
you know {},|
|

2316
01:13:07,620 --> 01:13:09,450
0,390 420,810 810,1320 1350,1650 1650,1830
let's go back up to
让我们回到我们的实现上来，

2317
01:13:09,450 --> 01:13:13,920
0,660 690,1830 2190,2850 3120,3810 4200,4470
our implementation,| {} the {readptr
|在虚拟内存情况下的 readptr 什么也不做，

2318
01:13:13,920 --> 01:13:15,150
0,450 450,570 570,630 630,960 960,1230
-} in the VM case

2319
01:13:15,150 --> 01:13:16,200
0,210 210,630 630,720 720,840 840,1050
does nothing,| you know there's
|这里不会检查，直接返回指针。

2320
01:13:16,200 --> 01:13:17,880
0,180 180,450 450,1080 1080,1410 1410,1680
no check whatsoever would return

2321
01:13:17,880 --> 01:13:19,280
0,60 60,390 390,900
a pointer straight.|
|

2322
01:13:19,480 --> 01:13:21,280
0,630 1020,1230 1230,1590 1590,1740 1740,1800
{} And then you know
然后我们使用[]指针，

2323
01:13:21,280 --> 01:13:22,480
0,60 60,270 270,420 420,690 690,1200
of course we used {[],pointer},|
|

2324
01:13:22,480 --> 01:13:23,230
0,150 150,300 300,420 420,480 480,750
we're gonna get a page
我们会收到一个页面错误，

2325
01:13:23,230 --> 01:13:24,700
0,420 450,750 750,870 870,1290 1290,1470
fault,| like as before in
|就像前面在平方根表应用程序中那样，

2326
01:13:24,700 --> 01:13:27,700
0,510 570,1080 1080,1620 1620,2310 2700,3000
the {square,roots} table application,| maybe
|也许这里是页面错误处理程序，

2327
01:13:27,700 --> 01:13:29,320
0,270 270,360 360,600 600,990 990,1620
here's the page fault handler,|
|

2328
01:13:30,090 --> 01:13:31,530
0,600 600,780 780,1020 1020,1170 1170,1440
{} so it is, {}
如果是一个页面在，

2329
01:13:32,650 --> 01:13:33,850
0,210 210,330 330,630 630,960 960,1200
if it's a page on|
|

2330
01:13:33,850 --> 01:13:35,680
0,270 390,660 660,810 810,1140 1530,1830
and actually let me run
让我在这里想一下，

2331
01:13:35,680 --> 01:13:37,400
0,60 60,210 210,480 480,1110
a little bit here,|
|

2332
01:13:39,450 --> 01:13:40,560
0,330 330,540 540,660 660,750 750,1110
if you know the object
如果对象已经被移到了某个地方，并且位于未扫描的区域，

2333
01:13:40,560 --> 01:13:42,810
0,420 480,1020 1020,1350 1350,2010 2010,2250
was moved somewhere earlier and

2334
01:13:42,810 --> 01:13:44,280
0,300 300,390 390,630 630,960 990,1470
sitting in the unscanned area,|
|

2335
01:13:44,280 --> 01:13:45,420
0,120 120,360 360,480 480,750 750,1140
we're getting a page fault|
我们得到一个页面错误，|

2336
01:13:45,420 --> 01:13:46,860
0,90 90,450 450,630 630,960 960,1440
and basically the scan page
那么扫描页面函数会运行。

2337
01:13:46,860 --> 01:13:48,760
0,390 420,930 930,1470
{you,know} function runs.|
|

2338
01:13:49,010 --> 01:13:51,980
0,690 1170,1620 1950,2550 2580,2760 2760,2970
{} and but you know
但是扫描页面函数运行在，

2339
01:13:51,980 --> 01:13:53,300
0,330 330,450 450,690 690,930 930,1320
the the scan page function

2340
01:13:53,300 --> 01:13:54,890
0,330 330,660 660,1320 1350,1500 1500,1590
runs| actually with you know
|使用收集器的地址范围，

2341
01:13:54,890 --> 01:13:56,330
0,150 150,510 510,990 990,1230 1230,1440
the address ranges of the

2342
01:13:56,330 --> 01:13:57,890
0,600 960,1110 1110,1230 1230,1320 1320,1560
collector| and so it actually
|所以它是可以工作的，

2343
01:13:57,890 --> 01:13:59,930
0,150 150,540 540,750 750,1200 1200,2040
can work,| because otherwise a
|因为 mutator ，应用程序不能触及这些页面，

2344
01:13:59,960 --> 01:14:01,940
0,510 510,600 600,1020 1260,1380 1380,1980
{mutator -} correct, the application

2345
01:14:01,940 --> 01:14:03,920
0,540 600,1170 1170,1410 1410,1740 1740,1980
cannot touch those pages,| because
|因为这样我们就会得到页面错误。

2346
01:14:03,920 --> 01:14:05,030
0,150 150,240 240,450 450,810 810,1110
then we take a result

2347
01:14:05,030 --> 01:14:06,360
0,60 60,240 240,600 600,930
in a page fault.|
|

2348
01:14:07,880 --> 01:14:09,320
0,150 150,720 750,870 870,990 990,1440
And once you know we
一旦我们扫描了所有的页面，

2349
01:14:09,710 --> 01:14:10,550
0,300 300,420 420,510 510,690 690,840
can, you know once we've

2350
01:14:10,550 --> 01:14:12,470
0,360 360,450 450,570 570,1110 1200,1920
scanned all the pages,| then
|那么你知道，

2351
01:14:12,710 --> 01:14:15,110
0,150 150,270 270,750 780,1590 1860,2400
you know the {},| the
|收集器使用户应用程序可以访问页面，

2352
01:14:16,170 --> 01:14:18,420
0,420 420,900 900,1620 1650,2130 2130,2250
collector actually {} makes the

2353
01:14:18,420 --> 01:14:19,620
0,270 270,510 510,990 990,1110 1110,1200
page actually accessible to the

2354
01:14:19,620 --> 01:14:21,080
0,240 240,840
user application,|
|

2355
01:14:24,740 --> 01:14:25,490
0,120 120,240 240,360 360,690 690,750
It may be helpful to
再看一遍 flip 可能会有帮助，

2356
01:14:25,490 --> 01:14:27,020
0,210 210,300 300,540 540,1080 1290,1530
look at flip again,| just
|只是为了看看 flip 发生了什么，

2357
01:14:27,020 --> 01:14:29,690
0,90 90,690 1170,1350 1350,1950 2220,2670
to see what happens, actually

2358
01:14:29,690 --> 01:14:31,790
0,270 270,390 390,1020 1380,1860 1860,2100
flip what happens,| {} we
|我们切换， from 空间已经满了，

2359
01:14:31,790 --> 01:14:33,500
0,330 330,570 570,900 1140,1410 1410,1710
switch from the from space

2360
01:14:33,500 --> 01:14:35,720
0,150 150,870 1050,1590 1590,1980 1980,2220
is full,| {} we make
|我们将整个 to 空间标记为应用程序不可访问，

2361
01:14:35,720 --> 01:14:36,830
0,330 330,630 630,690 690,960 960,1110
basically mark the whole to

2362
01:14:36,830 --> 01:14:39,020
0,480 480,690 690,960 960,1650 1830,2190
space as not accessible to

2363
01:14:39,020 --> 01:14:40,460
0,120 120,960
the application,|
|

2364
01:14:40,460 --> 01:14:41,420
0,90 90,390 390,510 510,870 870,960
and then we move to,|
然后我们移动，|

2365
01:14:41,420 --> 01:14:43,280
0,360 360,810 810,1230 1230,1560 1590,1860
collector moves actually the root
收集器将 root 头和 root 尾移动到 to 空间，

2366
01:14:43,280 --> 01:14:44,360
0,270 270,390 390,450 450,660 660,1080
head and the root last

2367
01:14:44,360 --> 01:14:45,660
0,60 60,150 150,330 330,690
you know to the

2368
01:14:45,660 --> 01:14:47,550
0,150 150,660 660,990 990,1410 1410,1890
to space,| that {} the
|应用程序不能访问或至少不能直接访问，

2369
01:14:47,550 --> 01:14:50,010
0,540 540,870 870,1410 1740,2370 2370,2460
application cannot access or at

2370
01:14:50,010 --> 01:14:51,330
0,150 150,300 300,810 810,1170 1170,1320
least not directly,| and you
|将会导致，

2371
01:14:51,330 --> 01:14:52,410
0,210 210,390 390,720 720,1020 1020,1080
know will result,| whenever the
|当应用程序访问 root 头和 root 尾，

2372
01:14:52,410 --> 01:14:54,540
0,600 690,1170 1170,1380 1380,1590 1590,2130
application accesses root head, root

2373
01:14:54,540 --> 01:14:56,640
0,480 600,780 780,960 960,1380 1500,2100
last,| it will actually result
|它会导致页面错误，

2374
01:14:56,640 --> 01:14:58,290
0,120 120,420 450,750 750,1140 1410,1650
in a page fault,| and
|然后收集器可以复制东西，

2375
01:14:58,290 --> 01:14:59,550
0,150 150,240 240,570 570,720 720,1260
then the collector can copy

2376
01:14:59,550 --> 01:15:00,930
0,240 240,660 660,750 750,1080 1080,1380
things over| and then protect
|然后保护这个页面。

2377
01:15:00,930 --> 01:15:02,060
0,60 60,270 270,720
the one page.|
|

2378
01:15:03,750 --> 01:15:05,100
0,150 150,240 240,420 420,780
Does that make sense?|
这能理解吗？|

2379
01:15:17,240 --> 01:15:19,880
0,540 540,930 1410,1920 1920,2220 2220,2640
{Okay,note,in} the handler correct,| it's
好的，注意在处理程序中，|首先扫描页面是至关重要的，

2380
01:15:19,880 --> 01:15:21,080
0,240 240,690 690,840 840,1110 1110,1200
actually crucial that first the

2381
01:15:21,080 --> 01:15:23,600
0,360 360,810 810,1740 1800,2070 2070,2520
pages scanned,| before you make
|在应用程序可以访问的页面之前，

2382
01:15:23,600 --> 01:15:25,700
0,90 90,390 390,900 960,1350 1380,2100
you know the page accessible

2383
01:15:25,700 --> 01:15:27,500
0,90 90,180 180,690 690,1110 1500,1800
to the application,| because if
|因为如果你在扫描之前让它可以访问，

2384
01:15:27,500 --> 01:15:28,640
0,150 150,690
you were

2385
01:15:28,670 --> 01:15:31,220
0,540 540,1410 1440,1650 1650,1980 1980,2550
to {} make it accessible

2386
01:15:31,220 --> 01:15:33,470
0,660 660,810 810,1110 1110,1410 1740,2250
before you scan that {},|
|

2387
01:15:33,470 --> 01:15:34,340
0,120 120,360 360,630 630,750 750,870
you know, and if there
如果有多个应用程序线程，

2388
01:15:34,340 --> 01:15:36,500
0,120 120,510 510,990 990,1560 1650,2160
were multiple application threads,| then
|那么那些应用程序可能会查看未扫描区域中的对象，

2389
01:15:36,500 --> 01:15:38,180
0,240 240,840 840,1170 1170,1290 1290,1680
those applications might be looking

2390
01:15:38,180 --> 01:15:40,640
0,480 480,1140 1140,1440 1440,1860 2010,2460
at objects on the {in,the}

2391
01:15:40,640 --> 01:15:42,020
0,330 330,750 870,1080 1080,1290 1290,1380
unscanned area,| of course that
|当然，我们需要禁止这样做，

2392
01:15:42,020 --> 01:15:43,010
0,90 90,270 270,330 330,630 630,990
we need to forbid that,|
|

2393
01:15:43,160 --> 01:15:44,930
0,300 300,540 780,1050 1050,1380 1380,1770
that's over {this,code -} basically
这就是用来扫描的代码，

2394
01:15:44,930 --> 01:15:47,120
0,270 270,840 900,1050 1050,1530 1620,2190
for scans| and then {}
|然后提高保护级别，

2395
01:15:47,520 --> 01:15:49,440
0,570 570,1020 1050,1410 1410,1710 1710,1920
raises the protection level,| so
|以便应用程序可以访问这些页面。

2396
01:15:49,440 --> 01:15:50,880
0,330 330,930 930,1050 1050,1350 1350,1440
the application can access the

2397
01:15:50,880 --> 01:15:51,920
0,510
pages.|
|

2398
01:15:56,150 --> 01:15:57,620
0,240 240,630 630,840 840,990 990,1470
Any questions about the collector
关于收集器和使用虚拟内存的技巧，有什么问题吗？

2399
01:15:57,620 --> 01:16:00,300
0,420 870,1350 1350,1500 1500,2100
and tricks to use

2400
01:16:00,860 --> 01:16:02,240
0,360 360,870
virtual memory?|
|

2401
01:16:07,210 --> 01:16:08,520
0,780
Okay.|
好的。|

2402
01:16:09,080 --> 01:16:10,100
0,180 180,300 300,480 480,810 810,1020
In that case I want
在这种情况下，我想总结几点，

2403
01:16:10,100 --> 01:16:11,120
0,150 180,420 420,630 630,750 750,1020
to wrap up a couple

2404
01:16:11,120 --> 01:16:13,730
0,390 390,810 840,1260 1290,1980 2280,2610
points,| I wanna make one
|在结束之前，我想说明一点。

2405
01:16:13,730 --> 01:16:16,340
0,270 270,900
point basically

2406
01:16:17,000 --> 01:16:19,100
0,630 660,1170 1170,1440
before wrapping up.|
|

2407
01:16:22,430 --> 01:16:23,360
0,150 150,300 300,540 540,840 840,930
You know, one question to
一个问题是，

2408
01:16:23,360 --> 01:16:24,440
0,270 270,420 420,690 690,780 780,1080
ask,| {} should you use
|在这里你应该使用虚拟内存吗，

2409
01:16:24,440 --> 01:16:26,080
0,90 90,390 390,600 600,930
the VM for this,|
|

2410
01:16:30,760 --> 01:16:31,960
0,210 210,540 540,720 720,870 870,1200
it really is it {does,those}
它做了那些技巧的回报，

2411
01:16:31,960 --> 01:16:35,140
0,630 630,1260 1410,2070 2370,2880 2880,3180
tricks payoff| and {} because
|因为很多，

2412
01:16:35,140 --> 01:16:37,180
0,360 360,450 450,1200 1230,1740 1740,2040
many of the,| {for,example} garbage
|比如许多其他的垃圾收集器，

2413
01:16:37,180 --> 01:16:38,620
0,360 360,510 510,720 720,1050 1050,1440
collectors and many garbage collectors

2414
01:16:38,620 --> 01:16:39,520
0,150 150,300 300,420 420,630 630,900
out there,| that actually don't
|根本没有虚拟内存，

2415
01:16:39,520 --> 01:16:41,620
0,300 300,780 780,1230 1230,1680 1920,2100
use virtual memory {} at

2416
01:16:41,620 --> 01:16:43,150
0,420 450,750 750,960 960,1200 1200,1530
all,| {} but use basic
|而是使用基本的设施，

2417
01:16:43,150 --> 01:16:44,470
0,600 600,690 690,810 810,900 900,1320
instrument,| you know the compiler
|编译器实际上是

2418
01:16:44,470 --> 01:16:46,450
0,120 120,420 420,690 690,1230 1230,1980
is actually| very aware of
|非常清楚生成的代码的设备，

2419
01:16:46,630 --> 01:16:48,010
0,90 90,270 270,780 780,900 900,1380
the code generated an instrument

2420
01:16:48,010 --> 01:16:49,120
0,90 90,180 180,300 300,540 540,1110
you know the code correctly,|
|

2421
01:16:49,540 --> 01:16:50,470
0,450 450,600 600,720 720,870 870,930
and as all kinds of
采用各种其他技巧会降低性能。

2422
01:16:50,470 --> 01:16:51,940
0,150 150,450 450,630 630,1050 1050,1470
other tricks to reduce the

2423
01:16:51,970 --> 01:16:53,360
0,330 330,510 510,780
performance {overhead -}.|
|

2424
01:16:53,450 --> 01:16:54,950
0,390 540,810 810,1230 1230,1320 1320,1500
So the observation is that
所以观察结果是，在大多数情况下，

2425
01:16:54,950 --> 01:16:56,460
0,60 60,330 330,930
in most cases,|
|

2426
01:16:56,460 --> 01:16:58,320
0,420 480,660 660,960 960,1290
{} it can be,|
这是可以的，|

2427
01:16:58,510 --> 01:17:00,160
0,660 660,960 1020,1290 1290,1470 1470,1650
{} and most cases could
而且大多数情况下都可以通过额外的指令来实现。

2428
01:17:00,160 --> 01:17:01,390
0,90 90,270 270,810 810,960 960,1230
have been implemented with extra

2429
01:17:01,390 --> 01:17:02,560
0,630
instructions.|
|

2430
01:17:14,240 --> 01:17:16,160
0,570 570,690 690,1170
And that is,|
也就是说，|

2431
01:17:16,550 --> 01:17:17,270
0,150 150,240 240,390 390,540 540,720
you know if you were
如果你是一个编译器或运行库，或者是一种编程语言，

2432
01:17:17,270 --> 01:17:19,400
0,390 390,750 750,1170 1170,1410 1410,2130
basically a compiler or runtime,

2433
01:17:19,400 --> 01:17:20,420
0,120 120,270 270,330 330,720 720,1020
or for a programming language,|
|

2434
01:17:20,420 --> 01:17:21,830
0,360 360,600 600,780 780,1080 1290,1410
then maybe that's not so
或许那也不是那么糟糕，

2435
01:17:21,830 --> 01:17:22,820
0,450
bad,|
|

2436
01:17:22,910 --> 01:17:23,960
0,420 420,480 480,840 840,930 930,1050
because the compiler can do
因为编译器可以实现，

2437
01:17:23,960 --> 01:17:25,940
0,90 90,840 1200,1590 1590,1770 1770,1980
the implementation,| {} but if
|但是如果你不是运行时应用程序，

2438
01:17:25,940 --> 01:17:26,780
0,120 120,270 270,510 510,750 750,840
you know there's not a

2439
01:17:26,780 --> 01:17:28,970
0,420 420,1020 1020,1230 1230,1680 1680,2190
runtime applications| not compiler application
|不是编译器应用程序或编程语言设置，

2440
01:17:28,970 --> 01:17:30,770
0,300 300,450 450,840 840,1260 1260,1800
or a programming language settings,|
|

2441
01:17:30,980 --> 01:17:32,510
0,630 630,630 630,1050 1050,1200 1200,1530
then {} that might be
那么可能会很痛苦。

2442
01:17:32,510 --> 01:17:34,550
0,510 870,1290 1380,1710 1710,1920 1920,2040
painful.| So it turns out
|所以事实证明，对于这些应用程序，

2443
01:17:34,550 --> 01:17:35,540
0,210 210,630 630,780 780,870 870,990
that for some of these

2444
01:17:35,540 --> 01:17:37,850
0,750 750,1170 1170,1710 1710,1830 1830,2310
applications| where there's no compiler
|根本不涉及编译器，

2445
01:17:37,850 --> 01:17:38,990
0,360 360,420 420,720 720,810 810,1140
involved at all,| for example
|比如，像检查点

2446
01:17:38,990 --> 01:17:40,740
0,300 330,600 600,1200
like check pointing|
|

2447
01:17:40,890 --> 01:17:43,320
0,570 870,990 990,1170 1170,1770
or you know do
或共享虚拟内存，

2448
01:17:43,660 --> 01:17:46,420
0,540 540,660 660,1260 1530,2100 2280,2760
shared virtual memory,| {} those
|那些确实需要这种原语。

2449
01:17:46,420 --> 01:17:48,760
0,450 450,540 540,660 660,1110 1110,2340
actually you know really needs

2450
01:17:48,760 --> 01:17:50,320
0,240 240,420 420,510 510,1110
these kind of primitives.|
|

2451
01:17:50,350 --> 01:17:51,880
0,360 360,750 900,1020 1020,1410 1410,1530
And so in practice,| you
所以在实践中，|是这种情况，

2452
01:17:51,880 --> 01:17:52,720
0,180 180,270 270,450 450,510 510,840
know it is the case

2453
01:17:52,720 --> 01:17:54,070
0,150 150,270 270,360 360,900 900,1350
that| you know not application
|对于应用程序员，这些原始语不是值得的，

2454
01:17:54,070 --> 01:17:55,390
0,450 450,540 540,810 810,960 960,1320
programmers I find these primitive

2455
01:17:55,390 --> 01:17:57,100
0,510 510,630 630,990 990,1320 1320,1710
worthwhile,| but basically today's operating
|但今天的操作系统支持它们。

2456
01:17:57,100 --> 01:17:58,640
0,420 420,840 840,1020
systems support them.|
|

2457
01:18:05,610 --> 01:18:06,780
0,630
Okay?|
好的?|

2458
01:18:08,880 --> 01:18:09,990
0,240 240,510 510,840 840,930 930,1110
Some people ask, a lot
有人问，其实很多人都在问，

2459
01:18:09,990 --> 01:18:11,490
0,60 60,270 270,540 540,900 900,1500
of people actually asking,| what
|发生了什么变化，

2460
01:18:11,490 --> 01:18:13,840
0,180 180,960 1170,1800
has changed since,|
|

2461
01:18:16,510 --> 01:18:17,890
0,210 210,330 330,600 600,750 750,1380
what has changed since 91.|
自 91 年以来发生了什么变化。|

2462
01:18:22,110 --> 01:18:23,490
0,180 180,720 720,930 930,1170 1170,1380
{You,know}, one thing that has
有一件事已经改变了，

2463
01:18:23,490 --> 01:18:24,720
0,330 330,390 390,630 630,930 930,1230
changed,| of course, like most
|当然，大多数 Unix 现在支持原语，

2464
01:18:24,720 --> 01:18:26,130
0,420 420,570 570,900 900,960 960,1410
Unix do support the primitives

2465
01:18:26,130 --> 01:18:27,060
0,360
now,|
|

2466
01:18:27,210 --> 01:18:27,930
0,300 300,360 360,600 600,690 690,720
and in fact there are
实际上从 91 年开始有很多变化，

2467
01:18:27,930 --> 01:18:30,630
0,420 420,990 1170,1470 1470,1980 1980,2700
many changes since 91,| yeah
|是的，也许很难想象，

2468
01:18:30,630 --> 01:18:32,460
0,240 240,780 780,1170 1380,1770 1770,1830
yeah, maybe {} hard to

2469
01:18:32,460 --> 01:18:33,960
0,300 300,450 450,900 900,1410 1410,1500
imagine,| but basically there's a
|但基本上虚拟内存系统在不断发展，

2470
01:18:33,960 --> 01:18:35,760
0,690 690,1230 1230,1410 1410,1470 1470,1800
continuous development in the VM

2471
01:18:35,760 --> 01:18:36,750
0,390 480,630 630,720 720,810 810,990
system,| so if you look
|所以如果你看 Linux 的 git 日志，

2472
01:18:36,750 --> 01:18:38,340
0,150 150,990
at like

2473
01:18:38,910 --> 01:18:40,710
0,660 660,750 750,990 990,1260 1260,1800
Linux you know git log,|
|

2474
01:18:40,830 --> 01:18:42,090
0,510 510,720 720,1020 1020,1140 1140,1260
{} you'll see, you know
你会发现它继续开发，

2475
01:18:42,090 --> 01:18:45,540
0,540 540,1230 2190,2550 2700,3090 3090,3450
there's a there's continued developing|
|

2476
01:18:45,540 --> 01:18:46,470
0,60 60,420 420,780 780,870 870,930
the all aspects of the
内核的各个方面，

2477
01:18:46,470 --> 01:18:49,110
0,450 570,990 990,1740 1740,2190 2190,2640
kernel,| and including a continuous
|也包括虚拟内存系统的不断发展。

2478
01:18:49,110 --> 01:18:50,760
0,450 450,570 570,900 930,1230 1230,1650
development of the VM system.|
|

2479
01:18:51,520 --> 01:18:53,080
0,540 840,1170 1170,1260 1260,1380 1380,1560
{} And you know some
你知道一些更大的变化，

2480
01:18:53,080 --> 01:18:54,370
0,90 90,150 150,360 360,990 990,1290
of the bigger changes,| what
|在过去的十年里有什么大的变化，

2481
01:18:54,370 --> 01:18:55,330
0,90 90,240 240,420 420,810 810,960
are some big changes in

2482
01:18:55,330 --> 01:18:56,680
0,90 90,630 630,690 690,810 810,1350
the last you know whatever

2483
01:18:56,710 --> 01:18:57,880
0,180 180,720
ten years,|
|

2484
01:18:59,600 --> 01:19:01,430
0,600 990,1230 1230,1410 1590,1710 1710,1830
there there's {} you know
现在有五级页表，

2485
01:19:01,430 --> 01:19:02,810
0,210 210,420 420,810 810,1110 1110,1380
there's now five level page

2486
01:19:02,810 --> 01:19:04,520
0,540 840,960 960,1200 1200,1380 1380,1710
table| to deal with really
|来处理非常大的的地址，

2487
01:19:04,520 --> 01:19:09,380
0,600 630,1410 2820,3270 3270,3870 4230,4860
large a bigger addresses {},|
|

2488
01:19:09,380 --> 01:19:12,860
0,720 720,1620 1620,2370 2370,2940 3090,3480
there's {address,space} identifiers to deal
有地址空间标识符来处理 TLB 刷新的成本。

2489
01:19:12,860 --> 01:19:13,780
0,450
with

2490
01:19:13,780 --> 01:19:15,130
0,450 450,810 810,960 960,1110 1110,1350
{} {TLB -} the cost

2491
01:19:15,130 --> 01:19:18,100
0,90 90,480 480,1140 1650,2400
of TLB flushes {}.|
|

2492
01:19:18,410 --> 01:19:19,820
0,390 390,870 870,990 990,1170 1170,1410
More recently a year ago
最近，大约在一年前，

2493
01:19:19,820 --> 01:19:20,630
0,60 60,270 270,450 450,600 600,810
or something like that| something
|称为 KPTI 内核页表隔离被引入，

2494
01:19:20,630 --> 01:19:21,950
0,90 90,330 330,540 540,1110 1110,1320
is called was introduced called

2495
01:19:21,950 --> 01:19:24,830
0,990 1050,1470 1470,1770 1770,2100 2100,2880
KPTI kernel page table isolation,|
|

2496
01:19:25,130 --> 01:19:27,740
0,510 1620,1920 1920,2340 2340,2490 2490,2610
{ -} which you know
这是因为 meltdown 攻击，

2497
01:19:27,740 --> 01:19:29,540
0,930 930,1140 1140,1350 1350,1500 1500,1800
is there because of the

2498
01:19:29,540 --> 01:19:31,280
0,480 480,870 870,1080 1080,1500 1500,1740
meltdown attacks| and we'll talk
|我们将在本学期晚些时候讨论。

2499
01:19:31,280 --> 01:19:32,450
0,210 210,510 510,600 600,660 660,1170
about later in the semester.|
|

2500
01:19:33,020 --> 01:19:35,840
0,450 660,1110 1440,1920 2190,2700 2700,2820
{} So, {} you know
所以，虚拟内存系统绝对不是静态系统，

2501
01:19:35,840 --> 01:19:37,250
0,480 480,810 810,1050 1050,1290 1290,1410
the virtual memory system is

2502
01:19:37,250 --> 01:19:39,200
0,480 480,720 720,780 780,1410 1590,1950
absolutely not a static system,|
|

2503
01:19:39,200 --> 01:19:40,520
0,300 300,510 510,870 870,1230 1230,1320
almost after no aspect of
几乎在任何内核的所有方面之后都不是静态的，

2504
01:19:40,520 --> 01:19:42,650
0,180 180,660 1230,1590 1590,1710 1710,2130
any kernel kernel is static,|
|

2505
01:19:42,740 --> 01:19:44,060
0,270 270,510 510,570 570,1080 1080,1320
{} there's a traumatic amount
几乎每隔几个月就会有大的变化，

2506
01:19:44,060 --> 01:19:45,890
0,60 60,690 750,1230 1230,1590 1590,1830
of changes almost every couple

2507
01:19:45,890 --> 01:19:46,700
0,420
months,|
|

2508
01:19:46,760 --> 01:19:47,930
0,300 300,510 510,750 750,1110 1110,1170
{} in different aspects of
在内核的不同方面，

2509
01:19:47,930 --> 01:19:49,790
0,60 60,390 1080,1530 1530,1740 1740,1860
the kernel,| and so in
|所以，在系统中，有时会完全重写，

2510
01:19:49,790 --> 01:19:51,230
0,390 390,780 780,990 990,1050 1050,1440
systems, {} once in {a,while}

2511
01:19:51,230 --> 01:19:53,040
0,270 270,690 690,1290
actually completely rewritten,|
|

2512
01:19:53,040 --> 01:19:55,290
0,300 300,1350 1830,1950 1950,2160 2160,2250
{} so it's always in
所以它总是在不断变化。

2513
01:19:55,290 --> 01:19:56,300
0,420
flux.|
|

2514
01:19:57,000 --> 01:19:58,200
0,240 240,570 570,900 900,1110 1110,1200
Okay, let me stop with
好了，我说到这里就到此为止，

2515
01:19:58,200 --> 01:20:00,030
0,360 390,990 1050,1140 1140,1260 1260,1830
that| and you know anybody
|任何人还有更多的问题，

2516
01:20:00,030 --> 01:20:02,040
0,180 180,390 390,870 870,960 1620,2010
has more questions,| {you,know} please
|请随时向提问，

2517
01:20:02,040 --> 01:20:03,210
0,420 420,600 600,690 690,930 930,1170
feel free to ask them|
|

2518
01:20:03,210 --> 01:20:03,990
0,210 210,510 510,600 600,720 720,780
or if you have to
如果你要走，那就走吧。

2519
01:20:03,990 --> 01:20:05,070
0,300 330,600 600,720 720,810 810,1080
go, feel free to go.|
|

2520
01:20:11,430 --> 01:20:13,230
0,450 630,900 900,1050 1050,1500 1500,1800
{} Could I ask about
我能问一下第一批幻灯片中的一张吗，

2521
01:20:13,230 --> 01:20:14,970
0,150 150,300 300,510 510,1020 1020,1740
one of the first slides,|
|

2522
01:20:15,000 --> 01:20:17,200
0,900 930,1470
where of,
抱歉，我正在看，

2523
01:20:17,260 --> 01:20:18,220
0,330 330,390 390,600 600,720 720,960
sorry, I'm trying to see

2524
01:20:18,220 --> 01:20:20,950
0,270 480,960 960,1470 1470,2460 2460,2730
it,| it's VM implementation like
|它是虚拟内存实现，这张幻灯片之后的两张幻灯片。

2525
01:20:20,950 --> 01:20:22,660
0,150 150,540 540,1050 1050,1230 1230,1710
two slides after this one.|
|

2526
01:20:23,500 --> 01:20:26,110
0,510 870,1230 1230,1410 1410,1740 1830,2610
{} Yes, that one {}.|
是的，就是那个。|

2527
01:20:26,530 --> 01:20:27,940
0,330 330,420 420,600 600,840 840,1410
What do you mean exactly
你所说的地址连续范围是什么意思？

2528
01:20:27,940 --> 01:20:30,880
0,420 450,1410 1410,1890 1890,2040 2040,2940
by continuous range for addresses?|
|

2529
01:20:31,060 --> 01:20:33,640
0,240 240,750 930,1980 1980,2340 2340,2580
Oh, {} yeah continuous range
哦，连续的虚拟地址范围，

2530
01:20:33,640 --> 01:20:35,040
0,60 60,360 360,870
of virtual addresses,|
|

2531
01:20:35,340 --> 01:20:36,960
0,540 540,660 660,870 870,1140 1140,1620
so you know the may
VMA 复制 1000 到 2000 之间的范围，

2532
01:20:36,960 --> 01:20:38,700
0,120 120,390 420,990 990,1320 1320,1740
you know VMA copies range

2533
01:20:38,700 --> 01:20:40,920
0,180 180,960 960,1140 1140,1680
{} {1000,to} {2000 -},|
|

2534
01:20:41,540 --> 01:20:42,800
0,330 360,630 630,780 780,930 930,1260
and if you had another
如果你有另一个地址范围，比如 2100 ，

2535
01:20:42,800 --> 01:20:45,170
0,330 330,900 1050,1500 1830,2220 2220,2370
address range like {2100 -

2536
01:20:45,170 --> 01:20:46,130
0,330 330,390 390,600 600,750 750,960
-} or something like that,|
|

2537
01:20:46,130 --> 01:20:47,000
0,120 120,240 240,480 480,690 690,870
that would be has its
那就有自己的 VMA ，

2538
01:20:47,000 --> 01:20:48,480
0,390 390,690 690,930
own {VMA -},|
|

2539
01:20:51,460 --> 01:20:53,200
0,300 300,540 540,1020 1020,1470 1500,1740
so every VMA covers a
所以每个 VMA 覆盖连续的地址范围，

2540
01:20:53,200 --> 01:20:55,060
0,450 450,660 660,720 720,1290 1680,1860
continuous range of addresses,| there
|上面没有洞。

2541
01:20:55,060 --> 01:20:56,110
0,90 90,360 360,720 720,840 840,1050
are no holes in it.|
|

2542
01:20:57,440 --> 01:20:58,580
0,600
Okay.|
好的。|

2543
01:20:58,670 --> 01:20:59,750
0,300 300,450 450,630 630,720 720,1080
{} That makes it easier,|
这让事情变得容易了，|

2544
01:20:59,750 --> 01:21:00,560
0,150 150,270 270,420 420,690 690,810
as you will see in
正如你会在 mmap 实验室中看到的，

2545
01:21:00,560 --> 01:21:03,380
0,570 1020,1920 2340,2610 2610,2700 2700,2820
the {}, as you will

2546
01:21:03,380 --> 01:21:04,520
0,120 120,390 390,930 930,1050 1050,1140
see {} {mmap,lab},| that will
|这使我们更容易对事情进行处理，

2547
01:21:04,520 --> 01:21:05,270
0,150 150,240 240,390 390,630 630,750
make it much easier to

2548
01:21:05,270 --> 01:21:06,600
0,240 240,450 450,840
reason about things,|
|

2549
01:21:09,040 --> 01:21:11,020
0,840 840,1170 1170,1470 1470,1740 1740,1980
addresses {in,the,range,of} VMA {} has
VMA 范围内的地址没有空洞。

2550
01:21:11,020 --> 01:21:12,620
0,270 270,660 660,780 780,1020
no hole in it.|
|

2551
01:21:14,460 --> 01:21:16,500
0,630 1050,1410 1410,1590 1590,1830 1830,2040
Okay, okay, so those are
好的，那么这些是为了，

2552
01:21:16,500 --> 01:21:20,280
0,600 960,1500 1740,2010 2010,2880 3120,3780
for,| {} this particular {}
|这个特殊的情况， mmap 。

2553
01:21:20,880 --> 01:21:22,340
0,330 330,960
use case,

2554
01:21:22,340 --> 01:21:25,880
0,510 510,750 750,1230 1830,2490
for {mmap -}, right.|
|

2555
01:21:26,560 --> 01:21:29,500
0,870 1080,1500 1500,1980 2400,2520 2520,2940
Yeah.| {Okay,,I,see,,thank} you.| So basically
是的。|好的，我明白了，谢谢。|所以可以认为每次 mmap 调用，

2556
01:21:29,500 --> 01:21:30,250
0,120 120,210 210,330 330,570 570,750
you can think about it

2557
01:21:30,250 --> 01:21:31,300
0,120 120,390 390,540 540,780 780,1050
for every {mmap -} call,|
|

2558
01:21:31,300 --> 01:21:33,010
0,150 150,300 300,930 960,1140 1140,1710
there's one VMA, if mmaps
就有一个 VMA ，如果 mmap 不重叠。

2559
01:21:33,010 --> 01:21:34,340
0,240 240,840
don't overlap.|
|

2560
01:21:35,910 --> 01:21:37,950
0,450 450,1020 1260,1710 1710,1830 1830,2040
Oh, okay, okay I think
哦，好的，我想我明白了，谢谢。

2561
01:21:37,950 --> 01:21:39,450
0,300 300,450 450,480 480,1080 1110,1500
I think I understand, thank

2562
01:21:39,450 --> 01:21:41,180
0,420
you.|
|

2563
01:21:43,850 --> 01:21:45,680
0,210 210,600 630,1200 1200,1470 1470,1830
To ask, {} so for
问一下对于高，

2564
01:21:45,680 --> 01:21:48,380
0,570 1170,2130
{ -}

2565
01:21:48,440 --> 01:21:50,360
0,360 360,900 990,1620 1620,1740 1740,1920
for the high,| on the
|垃圾收集器的 to 和 from ，

2566
01:21:50,360 --> 01:21:51,890
0,210 210,420 420,780 780,1110 1110,1530
to and from like {}

2567
01:21:51,920 --> 01:21:53,600
0,450 450,1050 1050,1380 1380,1440 1440,1680
garbage collection,| when do you
|什么时候停下来并重新开始，

2568
01:21:53,600 --> 01:21:56,360
0,780 990,1500 1500,1890 1890,2370 2430,2760
stop and start again,| like
|我猜收集器可以一直运行，如果它是并发的。

2569
01:21:56,360 --> 01:21:58,100
0,330 360,750 750,1230 1230,1560 1560,1740
I guess collector runs can

2570
01:21:58,100 --> 01:21:59,240
0,180 180,390 390,480 480,930 960,1140
run all the time, if

2571
01:21:59,240 --> 01:22:01,250
0,180 180,750 930,1380 1380,1620 1620,2010
its concurrent.| Yeah, that's one
|是的，这就是虚拟内存解决方案最酷的地方之一，

2572
01:22:01,250 --> 01:22:02,120
0,60 60,180 180,450 450,630 630,870
of the cool things about

2573
01:22:02,120 --> 01:22:03,680
0,150 150,720 720,1170 1170,1260 1260,1560
this VM solution,| the collector
|收集器可以一直运行，

2574
01:22:03,680 --> 01:22:04,760
0,120 120,510 510,660 660,720 720,1080
can run all the time,|
|

2575
01:22:05,420 --> 01:22:06,980
0,450 450,600 600,720 720,1170 1170,1560
and it can stop once
一旦没有未扫描的物体，它就可以停止。

2576
01:22:06,980 --> 01:22:08,990
0,360 360,480 480,1530 1560,1800 1800,2010
basically it has there's no

2577
01:22:08,990 --> 01:22:10,980
0,450 450,870 870,1440
more unscanned objects.|
|

2578
01:22:11,900 --> 01:22:13,160
0,300 300,510 510,780 780,1080 1080,1260
Okay, so you have, but
好的，所以你必须通过，

2579
01:22:13,160 --> 01:22:14,360
0,150 150,360 360,480 480,630 630,1200
you have to go through,|
|

2580
01:22:14,390 --> 01:22:15,860
0,210 210,390 390,960
that means you,|
也就是说，|

2581
01:22:16,320 --> 01:22:17,790
0,510 540,750 750,1050 1050,1230 1230,1470
so so you'll go through
所以你浏览所有内容，

2582
01:22:17,790 --> 01:22:19,260
0,240 240,360 360,690 690,1140 1170,1470
all of the stuff| like
|比如 from 部分中的所有对象，

2583
01:22:19,290 --> 01:22:20,310
0,270 270,360 360,480 480,900 900,1020
all of the objects in

2584
01:22:20,310 --> 01:22:21,630
0,120 120,450 450,930 930,1110 1110,1320
the from section| and all
|你要做的就是把它们收集起来或者复制过来，

2585
01:22:21,630 --> 01:22:23,670
0,510 510,1050 1050,1410 1440,1860 1860,2040
you're either gonna collect them

2586
01:22:23,670 --> 01:22:25,020
0,120 120,480 480,600 600,1080 1140,1350
or copy them over| how
|你怎么知道你通过了所有的。

2587
01:22:25,020 --> 01:22:25,740
0,60 60,180 180,330 330,510 510,720
do you know you've gone

2588
01:22:25,740 --> 01:22:26,900
0,150 150,270 270,360 360,630
through all of them.|
|

2589
01:22:27,340 --> 01:22:29,260
0,330 330,420 420,600 600,930 930,1920
You, at some point, you
在某个时候，你追踪对象从上到下，

2590
01:22:29,260 --> 01:22:30,460
0,210 210,510 510,630 630,900 900,1200
you trace the object {up,and}

2591
01:22:30,460 --> 01:22:32,260
0,360 360,690 1080,1560 1560,1710 1710,1800
down, correct,| {} and at
|在某些时候，你不再添加任何对象，

2592
01:22:32,260 --> 01:22:33,580
0,120 120,660 660,810 810,1080 1080,1320
some point, you're not adding

2593
01:22:33,580 --> 01:22:34,900
0,360 360,690 690,1080 1080,1260 1260,1320
any objects anymore,| because you
|因为你过去已经复制过了。

2594
01:22:34,900 --> 01:22:35,770
0,210 210,540 540,720 720,780 780,870
already copied them in the

2595
01:22:35,770 --> 01:22:36,720
0,510
past.|
|

2596
01:22:36,920 --> 01:22:38,270
0,420 450,750 750,870 870,1050 1050,1350
Okay okay, that makes sense.|
好的，理解了。|

2597
01:22:38,270 --> 01:22:39,230
0,180 180,330 330,480 480,630 630,960
You don't add any more,|
你不再增加，|

2598
01:22:39,230 --> 01:22:40,910
0,630 630,1050 1050,1170 1170,1470 1470,1680
basically your {unscanned -} area
因为你的未扫描区域没有增长，

2599
01:22:40,910 --> 01:22:41,780
0,90 90,240 240,630 630,750 750,870
is not growing,| so if
|所以，如果你的未扫描区域不再增长，你就不会。

2600
01:22:41,780 --> 01:22:42,530
0,180 180,420 420,570 570,660 660,750
your {unscanned -} area is

2601
01:22:42,530 --> 01:22:43,610
0,150 150,390 390,720 720,810 810,1080
not growing anymore, you don't.|
|

2602
01:22:44,640 --> 01:22:46,410
0,660 810,1260 1260,1440 1440,1590 1590,1770
Okay, okay, and then when
好的，然后当你把它复制，取消映射，

2603
01:22:46,410 --> 01:22:47,820
0,120 120,450 450,540 540,870 870,1410
you copy it over you

2604
01:22:47,820 --> 01:22:48,990
0,270 270,600 600,810 810,1050 1050,1170
{unmap -} it,| so if
|如果有人试图访问旧指针，将是无效的，对吧。

2605
01:22:48,990 --> 01:22:51,090
0,330 330,630 630,1080 1200,1980 1980,2100
someone tries to access the

2606
01:22:51,090 --> 01:22:52,140
0,240 240,720 720,870 870,990 990,1050
old pointer is going to

2607
01:22:52,140 --> 01:22:54,690
0,120 120,720 1320,1770 2010,2370 2400,2550
be invalid, right.| Okay, that
|好的，理解了，谢谢。

2608
01:22:54,690 --> 01:22:56,640
0,150 150,390 390,810 1170,1770 1800,1950
makes sense, thanks.| Alright, I'll
|好的，回头见。

2609
01:22:56,640 --> 01:22:59,000
0,90 90,150 150,570 750,1350
see you guys later.|
|

2610
01:23:01,060 --> 01:23:03,620
0,480 480,1080 1410,1590 1590,1980
Thank you.| You're welcome.|
谢谢。|不用谢。|

2611
01:23:12,120 --> 01:23:13,410
0,480 480,570 570,960 990,1170 1170,1290
Okay, I think that may
好的，我想今天可能就到这里了。

2612
01:23:13,410 --> 01:23:15,146
0,60 60,750 810,1020 1020,1470
be it for today.
