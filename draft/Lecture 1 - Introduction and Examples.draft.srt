1
00:00:01,900 --> 00:00:06,160
0,690 2370,2820 2820,2940 2940,3450 3570,4260
Alright,| welcome to {6.S081 -
好的，|欢迎学习 6.S081 操作系统，

2
00:00:06,160 --> 00:00:09,130
0,270 270,840 840,1260 1260,1980 2610,2970
- -} operating systems,| I'm
|我是 Robert ，将和 Frans 一起执教，

3
00:00:09,130 --> 00:00:10,720
0,480 510,660 660,750 750,930 930,1590
Robert I'll be Co lecturing

4
00:00:10,720 --> 00:00:13,900
0,390 390,1260 1560,2520 2730,3090 3090,3180
with Frans| and David and
|David 和 Nicolass 作为助教。

5
00:00:13,900 --> 00:00:15,250
0,420 420,510 510,600 600,1110 1110,1350
Nicolass of the {TAs -}.|

6
00:00:16,450 --> 00:00:18,250
0,390 510,750 750,1470 1470,1710 1710,1800
So, {} please during the
在 zoom 讲座的的时候，

7
00:00:18,250 --> 00:00:19,780
0,240 240,600 600,900 900,1440 1440,1530
zoom lecturers,| ask questions,| you
|随时可以提问，|你可以讲话打断我，

8
00:00:19,780 --> 00:00:21,460
0,120 120,750 900,1290 1290,1440 1440,1680
can either interrupt me by

9
00:00:21,460 --> 00:00:24,130
0,510 510,1200 1380,1890 2100,2400 2400,2670
audio| or {} enter something
|或者在聊天窗口中输入一些东西。

10
00:00:24,130 --> 00:00:25,740
0,150 150,270 270,690 690,1260
into the chat window,|
|

11
00:00:25,840 --> 00:00:27,220
0,390 600,810 810,900 900,1290 1290,1380
{} {one,of} the staff will
我们会有一名工作人员查看并替你提问。

12
00:00:27,220 --> 00:00:28,240
0,210 210,300 300,510 510,840 840,1020
see and ask questions for

13
00:00:28,240 --> 00:00:28,840
0,210
you.|
|

14
00:00:29,900 --> 00:00:30,800
0,390 390,450 450,600 600,750 750,900
By the way, we'll be
顺便说一下，我们会录下这些讲座，

15
00:00:30,800 --> 00:00:32,540
0,450 450,630 630,1320 1320,1560 1560,1740
recording these lectures| and then
|然后把录像开放出来，

16
00:00:32,540 --> 00:00:33,800
0,120 120,420 420,900 900,1140 1140,1260
we'll post recordings later,| so
|这样你们可以复习，

17
00:00:33,800 --> 00:00:35,300
0,90 90,240 240,540 540,1380 1380,1500
you can review them| or
|或者对于来不了的人

18
00:00:35,300 --> 00:00:36,860
0,270 870,1110 1110,1200 1200,1410 1410,1560
for people who can't make

19
00:00:36,860 --> 00:00:38,420
0,150 150,720 1140,1320 1320,1410 1410,1560
this time| so they can
|他们仍然可以看到讲座。

20
00:00:38,420 --> 00:00:39,740
0,420 420,570 570,1200
nevertheless see lectures.|
|

21
00:00:40,710 --> 00:00:41,880
0,180 180,210 210,360 360,420 420,1170
Alright, I want to start
好的，首先我想列出一些课程目标，

22
00:00:42,210 --> 00:00:44,430
0,840 1470,1950 1950,2070 2070,2160 2160,2220
by laying out some of

23
00:00:44,430 --> 00:00:45,690
0,90 90,420 420,480 480,570 570,1260
the goals of the course,|

24
00:00:45,720 --> 00:00:46,500
0,390
So,
第一个目标是，

25
00:00:46,750 --> 00:00:48,910
0,540 540,990 990,1290 1290,1590 1590,2160
number one is to {},|

26
00:00:49,330 --> 00:00:53,680
0,1350 1500,2070 2280,3240 3240,3600 3600,4350
understand the design and implementation
理解操作系统的设计和实现。

27
00:00:53,680 --> 00:00:56,180
0,450 450,930 930,1590
of operating systems.|
|

28
00:00:56,310 --> 00:00:58,120
0,480 810,1560
{} Yeah,
是的，设计是一种高层次的结构，

29
00:00:58,840 --> 00:01:00,010
0,600 600,690 690,870 870,930 930,1170
design is sort of high

30
00:01:00,010 --> 00:01:02,650
0,390 390,1200 1200,1650 1740,2520 2520,2640
level structure| and implementation is
|而实现是实际中代码真正的样子，

31
00:01:02,650 --> 00:01:03,880
0,270 270,660 660,840 840,900 900,1230
really about what the code

32
00:01:03,880 --> 00:01:05,110
0,240 240,630 720,930 930,1080 1080,1230
looks like,| and we'll be
|我们将做这两个方面花费大量的时间。

33
00:01:05,110 --> 00:01:05,830
0,330 330,390 390,510 510,570 570,720
spending a lot of time

34
00:01:05,830 --> 00:01:06,740
0,180 180,660
with both.|
|

35
00:01:07,940 --> 00:01:10,970
0,570 570,810 810,1380 1920,2610 2610,3030
And in the interest of
为了更深入地理解这是怎么运行的，

36
00:01:11,570 --> 00:01:12,590
0,210 210,270 270,480 480,960 960,1020
getting {} deep understanding of

37
00:01:12,590 --> 00:01:14,420
0,150 150,420 420,810 1050,1650 1650,1830
what's going on,| you'll get
|你经通过一个小型操作系统获得实践经验，

38
00:01:14,420 --> 00:01:17,900
0,600 600,1560 1560,1800 1800,2250 2550,3480
hands-on experience with a small,

39
00:01:18,420 --> 00:01:19,500
0,720

40
00:01:21,060 --> 00:01:23,280
0,690 870,1230 1230,1620 1620,2070 2070,2220
a small operating system,| the
|就是我们的 xv6 操作系统。

41
00:01:23,280 --> 00:01:24,980
0,540 540,930 930,1440
xv6 operating system.|
|

42
00:01:25,320 --> 00:01:28,230
0,660 1620,2070 2100,2220 2220,2580 2580,2910
{} And in addition to
而且除了查看现有的操作系统，

43
00:01:28,230 --> 00:01:29,400
0,300 300,600 600,720 720,780 780,1170
actually looking at an existing

44
00:01:29,400 --> 00:01:31,530
0,360 360,870 870,1260 1260,1770 1830,2130
operating system,| you'll be {}
|你还可以从实验中获得一下经验，

45
00:01:31,530 --> 00:01:33,570
0,150 150,210 210,1020 1740,1980 1980,2040
in the labs get a

46
00:01:33,570 --> 00:01:35,160
0,180 180,270 270,1020 1020,1500 1500,1590
bunch of experience,| extending the
|扩展操作系统，改进操作系统，

47
00:01:35,160 --> 00:01:37,410
0,390 390,810 810,1350 1440,2100 2100,2250
operating system modifying improving its

48
00:01:37,410 --> 00:01:40,110
0,600 690,1230 1350,1680 1680,2040 2040,2700
behavior| and writing system software
|编写使用操作系统接口的系统软件，

49
00:01:40,110 --> 00:01:42,510
0,720 990,1200 1200,1710 1710,1920 1920,2400
that it uses the operating

50
00:01:42,510 --> 00:01:44,100
0,600 630,1230 1230,1320 1320,1410 1410,1590
system interfaces,| [if it works
|在运行应用程序时。

51
00:01:44,100 --> 00:01:45,140
0,90 90,690
an application].|

52
00:01:45,320 --> 00:01:45,980
0,420

53
00:01:46,520 --> 00:01:48,080
0,420 900,1230 1260,1350 1350,1500 1500,1560
So, {} {} this is
所以，这是你们在课程中要做的，

54
00:01:48,080 --> 00:01:48,620
0,180 180,300 300,420 420,480 480,540
what you're going to be

55
00:01:48,620 --> 00:01:50,420
0,210 210,270 270,330 330,1080 1110,1800
doing in the course. {}.|

56
00:01:51,560 --> 00:01:52,400
0,570

57
00:01:52,980 --> 00:01:55,350
0,120 120,690 1260,1740 1740,2070 2100,2370
We're also interested in what
在课程中，我们对操作系统本身的作用也很感兴趣。

58
00:01:55,350 --> 00:01:56,280
0,90 90,360 360,420 420,540 540,930
the purpose of the operating

59
00:01:56,280 --> 00:01:57,480
0,300 300,720 720,960 960,1080 1080,1200
system itself is as well

60
00:01:57,480 --> 00:01:58,800
0,210 210,270 270,1020
as the course.|

61
00:02:00,980 --> 00:02:01,700
0,150 150,240 240,540 540,600 600,720
So for that, I have
所以，我有一系列的东西，

62
00:02:01,700 --> 00:02:03,710
0,360 390,660 660,810 1590,1920 1920,2010
a sort of list of

63
00:02:03,710 --> 00:02:05,360
0,60 60,330 330,450 450,1080 1080,1650
a couple of things| which
|你知道，有很多操作系统，

64
00:02:05,540 --> 00:02:07,430
0,600 900,1230 1230,1380 1380,1560 1560,1890
{} you know there's lots

65
00:02:07,430 --> 00:02:09,260
0,120 120,510 510,1200 1200,1530 1530,1830
of operating system,| different operating
|不同的操作系统，

66
00:02:09,260 --> 00:02:11,750
0,480 480,660 660,1050 1290,1770 1980,2490
systems out there,| they typically
|它们通常有一个共同的目标。

67
00:02:11,750 --> 00:02:12,710
0,180 180,270 270,690 690,900 900,960
have a common set of

68
00:02:12,710 --> 00:02:13,780
0,840
purposes.|
|

69
00:02:15,150 --> 00:02:17,700
0,450 1050,1260 1260,1380 1380,1830 2250,2550
{} One of them is
其中之一就是对硬件的抽象，

70
00:02:17,700 --> 00:02:20,080
0,330 330,1200 1200,1290 1290,2100
to abstract the hardware,|

71
00:02:21,520 --> 00:02:23,440
0,660 780,990 990,1350 1500,1770 1770,1920
{} that is what you're
通常从买一台计算机开始，

72
00:02:23,440 --> 00:02:25,090
0,330 330,810 810,990 990,1290 1290,1650
given typically as a starting

73
00:02:25,090 --> 00:02:25,780
0,240 240,330 330,420 420,570 570,690
point is you buy a

74
00:02:25,780 --> 00:02:26,740
0,390 390,450 450,750 750,900 900,960
computer,| a computer has a
|计算机包括 CPU 和内存，

75
00:02:26,740 --> 00:02:28,300
0,330 330,420 420,960 1020,1410 1410,1560
CPU and memory,| but that's
|但这是一个非常低的层级。

76
00:02:28,300 --> 00:02:29,880
0,30 30,210 210,570 570,1290
a very low level.|
|

77
00:02:29,940 --> 00:02:32,040
0,480 510,960 960,1050 1050,1800 1830,2100
A set of resources,| it's
一系列的资源，|拥有更高级别的接口和抽象是非常棒的，

78
00:02:32,040 --> 00:02:32,940
0,510 510,570 570,690 690,720 720,900
fantastic to have a much

79
00:02:32,940 --> 00:02:35,910
0,360 360,810 1620,2250 2250,2340 2340,2970
higher level interfaces and abstractions|
|

80
00:02:35,910 --> 00:02:38,340
0,150 150,690 690,870 870,1440 2070,2430
that applications can use,| such
应用程序可以使用它们，|比如为了方便和可移植性而产生的进程或文件系统。

81
00:02:38,340 --> 00:02:40,170
0,120 120,690 690,810 810,1110 1110,1830
as processes or file systems

82
00:02:40,740 --> 00:02:42,600
0,360 360,450 450,1260 1260,1530 1530,1860
both for convenience and for

83
00:02:42,600 --> 00:02:43,740
0,870
portability.|
|

84
00:02:44,360 --> 00:02:46,700
0,360 360,630 630,1260 1680,2280 2280,2340
Another very important task of
操作系统的另一个非常重要的目标是

85
00:02:46,700 --> 00:02:48,170
0,90 90,480 480,960 1110,1350 1350,1470
an operating system is| to
|在许多应用程序中复用硬件。

86
00:02:48,170 --> 00:02:49,960
0,660 660,720 720,1500
multiplex the hardware

87
00:02:50,190 --> 00:02:52,000
0,330 330,630 630,1680
among many applications.|

88
00:02:52,360 --> 00:02:53,650
0,330 330,480 480,630 630,720 720,1290
{} You might be running
你可能运行文本编辑器，编译器，

89
00:02:53,650 --> 00:02:55,630
0,270 300,750 750,1470 1470,1710 1710,1980
a text editor, and a

90
00:02:55,660 --> 00:02:58,180
0,810 810,1110 1440,2250
compiler,| or maybe
|或者多个不同的数据库服务器，

91
00:02:58,280 --> 00:03:01,010
0,570 840,1590 1590,1890 1890,2340 2340,2730
a multiple different database servers|

92
00:03:01,010 --> 00:03:01,940
0,90 90,390 390,480 480,600 600,930
or something on your operating
或者其他什么东西，

93
00:03:01,940 --> 00:03:03,470
0,420 480,690 690,1380 1380,1470 1470,1530
system,| it's fantastic to be
|能够使用操作系统同时运行它们是很棒的，

94
00:03:03,470 --> 00:03:04,340
0,180 180,240 240,360 360,450 450,870
able to have the operating

95
00:03:04,340 --> 00:03:05,660
0,600 600,870 870,1140 1140,1200 1200,1320
system run both of them

96
00:03:05,660 --> 00:03:06,650
0,60 60,120 120,360 360,870 870,990
at the same time| or
而且所有同时运行的事情不会相互干扰。

97
00:03:06,650 --> 00:03:07,640
0,210 210,300 300,600 600,600 600,990
all the things are going

98
00:03:07,640 --> 00:03:08,600
0,210 210,270 270,330 330,600 600,960
on at the same time

99
00:03:08,690 --> 00:03:10,360
0,450 450,660 660,780 780,1350
without having them interfere.|
|

100
00:03:11,420 --> 00:03:13,010
0,390 390,540 540,750 750,1350 1350,1590
That's often called {multiplexing -},|
这通常叫做多路复用，|

101
00:03:13,970 --> 00:03:15,710
0,1260 1260,1410 1410,1560 1560,1680 1680,1740
because there may be a
因为操作系统上可能同时发生很多事情，

102
00:03:15,710 --> 00:03:16,850
0,180 180,270 270,570 570,1050 1050,1140
lot of things happening in

103
00:03:16,850 --> 00:03:17,750
0,90 90,450 450,780 780,840 840,900
the operating system at the

104
00:03:17,750 --> 00:03:19,190
0,210 210,510 510,960 960,1320 1320,1440
same time,| it's critical that
|它们必须不会相互干扰，

105
00:03:19,190 --> 00:03:22,220
0,120 120,360 360,1320 1380,2430 2580,3030
they not interfere unintentionally,| even
|即使有 bug 存在，

106
00:03:22,220 --> 00:03:23,720
0,90 90,180 180,300 300,1110 1140,1500
if they have bugs| and
|这也就是所谓的隔离性。

107
00:03:23,720 --> 00:03:25,700
0,450 780,1080 1110,1620 1620,1740 1740,1980
that's a task is called

108
00:03:25,700 --> 00:03:26,820
0,810
isolation.|
|

109
00:03:27,120 --> 00:03:28,480
0,120 120,480 480,930
The idea that,
它的主要思想是，

110
00:03:28,970 --> 00:03:31,910
0,720 1170,1590 1590,2520 2520,2730 2730,2940
{} different activities should not
不同的活动不应该互相干涉，

111
00:03:31,910 --> 00:03:33,290
0,60 60,360 360,420 420,990 1140,1380
be allowed to interfere,| on
|另一方面，

112
00:03:33,290 --> 00:03:33,800
0,60 60,180 180,330 330,420 420,510
the other hand,| there are
|不同的活动可以需要干涉，

113
00:03:33,800 --> 00:03:36,140
0,420 420,930 1200,1650 1650,2070 2070,2340
times when different activities would

114
00:03:36,140 --> 00:03:37,460
0,210 210,300 300,930 930,1170 1170,1320
like to interfere,| would like
|需要干涉来交互或协作，

115
00:03:37,460 --> 00:03:39,170
0,60 60,660 660,720 720,1380 1410,1710
to interact or cooperate,| so
|比如，如果我使用编辑器创建了一个文件，

116
00:03:39,200 --> 00:03:40,400
0,210 210,570 570,690 690,810 810,1200
for example if I create

117
00:03:40,400 --> 00:03:41,600
0,150 150,660 660,780 780,810 810,1200
a file with a text

118
00:03:41,600 --> 00:03:42,890
0,510 630,840 840,960 960,1140 1140,1290
editor,| and I'd like my
|我希望编译器可以读取该文件，

119
00:03:42,890 --> 00:03:44,480
0,570 570,690 690,900 900,960 960,1590
compiler to read the file|
|

120
00:03:44,990 --> 00:03:45,830
0,120 120,180 180,630 630,780 780,840
and we definitely want to
我们肯定希望允许这样的的共享。

121
00:03:45,830 --> 00:03:47,390
0,570 570,810 810,990 990,1080 1080,1560
allow that kind of sharing.|
|

122
00:03:47,860 --> 00:03:48,910
0,270 300,510 510,570 570,810 810,1050
{} So we wanna allow
所有我们希望这种用户想要的共享。

123
00:03:48,910 --> 00:03:51,360
0,420 420,1080 1470,2160
sharing [], {}

124
00:03:51,410 --> 00:03:52,400
0,240 240,300 300,570 570,690 690,990
sort of what the user

125
00:03:52,400 --> 00:03:55,120
0,210 210,300 300,990
has in mind.
|

126
00:03:55,670 --> 00:03:57,380
0,330 330,420 420,630 630,1560 1560,1710
But in many circumstances, the
但是在很多情况下，用户不想分享，

127
00:03:58,040 --> 00:03:59,360
0,300 300,540 540,780 780,1140 1140,1320
user doesn't want sharing,| maybe
|可能你登录到类似 Athena 的分时服务器，

128
00:03:59,360 --> 00:04:00,560
0,150 150,450 450,660 660,870 900,1200
you're logged into a time

129
00:04:00,560 --> 00:04:02,630
0,240 240,540 540,660 660,1650 1740,2070
sharing machine like Athena,| and
|你肯定不希望别人读取你的文件，

130
00:04:02,630 --> 00:04:03,410
0,90 90,210 210,390 390,540 540,780
you don't want other people

131
00:04:03,410 --> 00:04:05,000
0,90 90,270 270,390 390,1200 1350,1590
to read your files {},|
|

132
00:04:05,000 --> 00:04:05,810
0,180 180,300 300,510 510,690 690,810
so we also need as
所以我们需要，想分享的的时候分享，

133
00:04:05,810 --> 00:04:06,890
0,150 150,570 570,690 690,840 840,1080
well sharing we want to,|

134
00:04:06,920 --> 00:04:08,030
0,420 420,690 690,810 810,900 900,1110
not share when we don't
不想分享的时候不分享。

135
00:04:08,030 --> 00:04:09,640
0,240 240,480 810,1350
want to {}.|

136
00:04:09,760 --> 00:04:11,470
0,240 240,360 360,510 510,870 870,1710
Which we could call security
我们可以称其为安全系统或权限系统，

137
00:04:11,470 --> 00:04:13,390
0,180 180,270 270,750 750,1380 1740,1920
or a permission system,| an
|即一个访问控制系统。

138
00:04:13,390 --> 00:04:15,400
0,390 390,780 780,1110
access control system.|
|

139
00:04:16,650 --> 00:04:17,910
0,390 390,570 570,690 690,930 930,1260
Another thing that people value
人们看中操作系统的另一个原因是，

140
00:04:17,910 --> 00:04:19,470
0,90 90,450 450,930 930,1320 1410,1560
in operating systems is| if
|如果你为一台计算机的硬件上花了很多钱，

141
00:04:19,470 --> 00:04:20,100
0,150 150,390 390,420 420,570 570,630
you spend a lot of

142
00:04:20,100 --> 00:04:21,120
0,240 240,360 360,420 420,930 930,1020
money on the hardware on

143
00:04:21,120 --> 00:04:22,410
0,60 60,720 750,900 900,1140 1140,1290
a computer,| you'd like your
|你希望应用程序能够获得

144
00:04:22,410 --> 00:04:23,460
0,600 600,690 690,780 780,960 960,1050
application to be able to

145
00:04:23,460 --> 00:04:24,750
0,360 420,630 630,780 780,840 840,1290
get| a sort of full
硬件提供的全部性能。

146
00:04:24,750 --> 00:04:27,390
0,1020 1020,1320 1560,1890 1890,2460 2460,2640
performance that a hardware ought

147
00:04:27,390 --> 00:04:28,680
0,60 60,210 210,390 390,480 480,1290
to be able to provide.|

148
00:04:28,800 --> 00:04:30,440
0,480 750,1290
{} And,
而且，很多都是应用编程。

149
00:04:30,650 --> 00:04:31,310
0,150 150,330 330,390 390,570 570,660
a lot of that is

150
00:04:31,310 --> 00:04:33,980
0,210 210,780 780,1380 1950,2430
just application programming {}.|

151
00:04:34,010 --> 00:04:36,200
0,510 690,930 930,1560 1560,2010 2010,2190
But, {} inevitably, unfortunately, some
但是，不可避免的，操作系统必须确保

152
00:04:36,200 --> 00:04:37,370
0,120 120,270 270,630 630,780 780,1170
of it is the operating

153
00:04:37,370 --> 00:04:38,540
0,390 390,540 540,630 630,840 840,1170
system has to make sure

154
00:04:38,540 --> 00:04:42,410
0,300 360,1350 2130,2700 2700,2790 2790,3870
that| whatever services it provides
|它提供的任何服务都不会阻碍应用程序获得高性能，

155
00:04:42,470 --> 00:04:43,790
0,540 540,690 690,780 780,870 870,1320
don't get in the way

156
00:04:43,790 --> 00:04:46,010
0,390 390,960 960,1170 1170,1350 1350,2220
of applications getting high performance,|

157
00:04:46,250 --> 00:04:47,090
0,210 210,330 330,480 480,540 540,840
so you want to at
所以你希望至少不要阻碍，

158
00:04:47,090 --> 00:04:47,750
0,240 240,420 420,540 540,600 600,660
least not get in the

159
00:04:47,750 --> 00:04:49,880
0,540 540,1050 1140,1500 1500,1680 1680,2130
way| and maybe even help
|甚至可以帮助应用程序获得良好的性能。

160
00:04:49,880 --> 00:04:51,540
0,660 660,1380
applications achieve

161
00:04:51,650 --> 00:04:52,860
0,180 180,1050
good performance.|
|

162
00:04:54,150 --> 00:04:54,800
0,390

163
00:04:55,880 --> 00:04:58,740
0,600 690,1650 1980,2400
{} Finally {},
最后，大多数操作系统必须支持很多不同的应用程序，

164
00:04:58,880 --> 00:05:01,100
0,210 210,510 510,870 870,1440 2010,2220
with most operating systems have

165
00:05:01,100 --> 00:05:02,150
0,90 90,360 360,450 450,780 780,1050
to support a wide range

166
00:05:02,150 --> 00:05:03,470
0,90 90,360 360,1020 1020,1200 1200,1320
of different applications,| maybe it's
|可能是笔记本电脑运行编辑器，

167
00:05:03,470 --> 00:05:05,450
0,90 90,780 810,1260 1260,1560 1590,1980
a laptop running a text

168
00:05:05,450 --> 00:05:07,550
0,540 540,810 810,960 960,1230 1230,2100
editor,| maybe it's running games,|
|可能是运行游戏，|

169
00:05:07,610 --> 00:05:09,230
0,480 480,600 600,960 960,1320 1320,1620
maybe your operating system needs
也可能需要支持数据库服务或云计算，

170
00:05:09,230 --> 00:05:11,600
0,180 180,930 1170,1650 1650,2190 2190,2370
to support database servers or

171
00:05:11,600 --> 00:05:14,180
0,360 360,1140 1260,1710 1890,2340 2340,2580
cloud computation,| and usually because
|通常因为操作系统的设计和构建成本很高，

172
00:05:14,180 --> 00:05:16,700
0,330 330,780 780,1140 1290,1770 1770,2520
operating systems are quite expensive

173
00:05:16,760 --> 00:05:19,130
0,150 150,570 570,660 660,1200 1860,2370
to design and build,| people
|所以人们使用相同的操作系统来执行许多不同的任务，

174
00:05:19,130 --> 00:05:20,270
0,150 150,240 240,450 450,810 810,1140
use the same operating systems

175
00:05:20,270 --> 00:05:21,890
0,120 120,540 540,840 840,1440 1440,1620
for many different tasks,| like
|比如 Linux ，

176
00:05:21,890 --> 00:05:23,180
0,360 360,480 480,780 780,1140 1170,1290
Linux,| for example which I'm
|我相信大多数人都运行一个（操作系统），

177
00:05:23,180 --> 00:05:23,900
0,210 210,450 450,540 540,630 630,720
sure many of you are

178
00:05:23,900 --> 00:05:25,340
0,510 840,1050 1050,1140 1140,1380 1380,1440
running a,| is used in
在我提到的所有情况下，

179
00:05:25,340 --> 00:05:26,600
0,300 300,390 390,630 630,1200 1200,1260
all of the situations I

180
00:05:26,600 --> 00:05:27,800
0,450 450,570 570,660 660,870 870,1200
mentioned,| so the same operating
|所以相同的操作系统必须能够支持，

181
00:05:27,800 --> 00:05:28,610
0,300 300,480 480,630 630,720 720,810
system really has to be

182
00:05:28,610 --> 00:05:30,590
0,180 180,390 390,870 1020,1230 1230,1980
able to support| a range
|一系列非常不同的用途。

183
00:05:30,620 --> 00:05:31,380
0,360
of

184
00:05:31,430 --> 00:05:33,950
0,750 870,1170 1170,1470 1470,1770 1770,2520
{} often quite different uses.|
|

185
00:05:36,830 --> 00:05:38,000
0,420 450,780 780,1020 1020,1080 1080,1170
So we're hoping to be
所以我们希望能够，同时支持所有这些不同的目标。

186
00:05:38,000 --> 00:05:40,100
0,180 180,270 270,840 1590,2040 2040,2100
able to support sort of

187
00:05:40,100 --> 00:05:42,470
0,180 180,330 330,570 570,1380 1380,2370
all these different goals simultaneously.|

188
00:05:44,000 --> 00:05:44,900
0,240 240,330 330,480 480,660 660,900
And we'll hear more about
我们将在课程中听到更多关于这些的信息。

189
00:05:44,900 --> 00:05:45,860
0,150 150,270 270,630 660,900 900,960
all of them during the

190
00:05:45,860 --> 00:05:46,880
0,660
course.|
|

191
00:05:47,810 --> 00:05:50,150
0,420 450,810 810,1140 1140,1950 1980,2340
Alright, {} operating systems,| a
好的，对于操作系统，|几十年来人们总结出一套设计思想，

192
00:05:50,510 --> 00:05:51,830
0,90 90,180 180,540 540,930 930,1320
lot of people worked out

193
00:05:51,830 --> 00:05:54,740
0,90 90,360 360,660 1200,1920 1920,2910
a set of design ideas

194
00:05:54,770 --> 00:05:56,450
0,240 240,330 330,960 1230,1440 1440,1680
over the decades| have worked
|在组织事情方面运行良好，

195
00:05:56,450 --> 00:05:57,860
0,210 210,660 750,1020 1020,1080 1080,1410
pretty well sort of ways

196
00:05:57,860 --> 00:05:59,240
0,90 90,630 630,1200
of organizing things,|
|

197
00:05:59,310 --> 00:06:00,900
0,540 810,1050 1050,1140 1140,1320 1320,1590
I'm going to lay out
我来给你们展示一下这种经典设计。

198
00:06:00,900 --> 00:06:01,800
0,120 120,420 420,630 630,810 810,900
for you this sort of

199
00:06:02,220 --> 00:06:03,460
0,1020
classic.|
|

200
00:06:05,890 --> 00:06:08,590
0,240 240,1290 1590,2130 2130,2220 2220,2700
A organization sort of standard
也是这门课的标准组织方式，

201
00:06:08,590 --> 00:06:10,000
0,390 390,750 750,1140
deal for {}

202
00:06:10,600 --> 00:06:12,310
0,330 360,480 480,630 630,1170 1170,1710
{} for this course,| and
|实际上在很多操作系统上都是很常见的，

203
00:06:13,380 --> 00:06:15,420
0,600 1020,1230 1230,1470 1470,1710 1710,2040
{} is actually quite common

204
00:06:15,420 --> 00:06:17,400
0,510 540,900 900,1140 1140,1680 1680,1980
around for many {operate,systems},| so
|所以这是一种操作系统的内部组织方式，

205
00:06:17,400 --> 00:06:18,990
0,180 180,270 270,450 450,540 1110,1590
this is sort of OS

206
00:06:18,990 --> 00:06:20,980
0,420 420,1350 1410,1710
internal organization,| or
|我想用这个方框来表示计算机，

207
00:06:21,830 --> 00:06:24,200
0,450 1170,1800 1800,1890 1890,2100 2100,2370
the way I think about

208
00:06:24,200 --> 00:06:25,970
0,180 180,570 1080,1230 1230,1590 1590,1770
it is in terms of

209
00:06:25,970 --> 00:06:29,000
0,900 1170,1950 1950,2100 2100,2340 2340,3030
a box for the computer,|

210
00:06:29,810 --> 00:06:31,600
0,300 300,1020 1140,1380 1380,1470
the computer sort of
计算机包含许多硬件，

211
00:06:32,260 --> 00:06:32,980
0,330 330,450 450,480 480,630 630,720
comes with a bunch of

212
00:06:32,980 --> 00:06:34,210
0,330 330,870 870,1020 1020,1110 1110,1230
hardware resources,| which I'll put
|我把它们放在下面，

213
00:06:34,210 --> 00:06:35,170
0,90 90,150 150,600 600,810 810,960
at the bottom,| maybe their
|有 CPU 、 内存、用来存储的磁盘，可能还有网络接口，

214
00:06:35,170 --> 00:06:38,440
0,810 810,960 960,1920 2520,3150 3150,3270
CPU and ram, disk for

215
00:06:38,440 --> 00:06:41,020
0,930 930,1200 1470,1740 1740,1800 1800,2580
storage and maybe a network

216
00:06:41,080 --> 00:06:43,240
0,960 990,1170 1170,1440 1440,1500 1500,2160
interface,| this sort of hardware
|这些硬件是最下面一层。

217
00:06:43,240 --> 00:06:45,700
0,360 360,450 450,810 810,1560
that's the lowest layer.|
|

218
00:06:46,180 --> 00:06:47,590
0,300 300,390 390,480 480,1050 1290,1410
So at the top you
而在顶部，你想要运行各种应用程序，

219
00:06:47,590 --> 00:06:49,540
0,180 180,240 240,660 660,990 990,1950
want to run various applications,|
|

220
00:06:49,570 --> 00:06:51,100
0,540 570,690 690,1050 1050,1410 1410,1530
maybe a text editor I
或许是一个文本编辑器，这里我使用 vi 来表示，

221
00:06:51,100 --> 00:06:52,450
0,270 270,540 540,1110 1110,1260 1260,1350
have use VI as a

222
00:06:52,450 --> 00:06:53,950
0,300 300,750 1140,1290 1290,1380 1380,1500
text editor,| if you're going
|也可能是运行 C 编译器 CC ，

223
00:06:53,950 --> 00:06:55,420
0,60 60,210 210,300 300,600 600,1470
to run a C compiler

224
00:06:55,450 --> 00:06:57,730
0,1050 1320,1410 1410,1710 2040,2190 2190,2280
CC,| you know if you
|也可以运行很多我们今天会讨论的其他东西，

225
00:06:57,730 --> 00:06:58,810
0,210 210,450 450,540 540,780 780,1080
run lots of other things

226
00:06:58,810 --> 00:06:59,680
0,210 210,390 390,600 600,660 660,870
we're gonna talk a lot

227
00:06:59,680 --> 00:07:00,970
0,240 240,480 480,540 540,1080 1080,1290
today,| about the shell which
|比如 shell 作为命令行界面，

228
00:07:00,970 --> 00:07:02,040
0,150 150,360
is the

229
00:07:02,030 --> 00:07:02,520
0,60
{}

230
00:07:02,940 --> 00:07:04,650
0,450 450,690 690,1320 1470,1620 1620,1710
command line interface,| so we
|所以我们有了这些不同的程序在运行。

231
00:07:04,650 --> 00:07:05,670
0,120 120,240 240,390 390,600 600,1020
have all these different programs

232
00:07:05,670 --> 00:07:07,000
0,120 120,210 210,660
that are running.|
|

233
00:07:07,260 --> 00:07:08,610
0,420 450,690 690,840 840,1170 1230,1350
{} And this is the
而且这个运行应用程序的地方，通常称为用户空间。

234
00:07:08,610 --> 00:07:10,020
0,210 210,390 420,960 960,1020 1020,1410
sort of world in which

235
00:07:10,050 --> 00:07:11,820
0,450 540,1170 1170,1380 1380,1500 1500,1770
{} applications run is usually

236
00:07:11,820 --> 00:07:13,420
0,270 270,570 570,1440
called user space.|
|

237
00:07:14,260 --> 00:07:15,460
0,300 300,570 570,720 720,1080 1080,1200
{} And as distinct from
与此不同的是，这里有一个单独的程序，

238
00:07:15,460 --> 00:07:18,280
0,240 240,780 870,1260 1260,1890 1890,2820
that, there's a single program,|
|

239
00:07:19,440 --> 00:07:21,360
0,540 660,1170 1170,1470 1470,1650 1650,1920
a special program, that's always
一个特殊的程序，它一直运行着，就是所谓的内核，

240
00:07:21,360 --> 00:07:23,460
0,480 840,1110 1110,1200 1200,1860 1890,2100
running called the kernel| and
|内核是计算机资源的守护者，

241
00:07:23,460 --> 00:07:24,180
0,60 60,360 360,450 450,630 630,720
the kernel is sort of

242
00:07:24,180 --> 00:07:26,310
0,270 360,1260 1260,1380 1380,1560 1560,2130
the guardian of the resources

243
00:07:26,310 --> 00:07:27,690
0,90 90,180 180,840 960,1140 1140,1380
of the computer,| it's what
它在你开机时第一个启动，

244
00:07:27,690 --> 00:07:29,190
0,330 330,660 660,1020 1080,1290 1290,1500
first boots up you turn

245
00:07:29,190 --> 00:07:30,930
0,120 120,210 210,780 1080,1230 1230,1740
on the computer,| {} there's
|只有一个内核来管理数据

246
00:07:30,930 --> 00:07:32,010
0,150 150,360 360,420 420,630 630,1080
just one of it maintains

247
00:07:32,010 --> 00:07:33,560
0,600 720,1260
data {},|
|

248
00:07:33,640 --> 00:07:35,440
0,420 450,1020 1020,1590 1590,1740 1740,1800
to help manage each of
帮助管理进程，

249
00:07:35,440 --> 00:07:36,790
0,180 180,840 840,990 990,1080 1080,1350
these processes| and the kernel
并且内核也有很多的数据结构帮助访问，

250
00:07:36,790 --> 00:07:37,930
0,270 270,600 600,840 840,900 900,1140
also means lots of data

251
00:07:37,930 --> 00:07:41,260
0,420 420,510 510,990 2130,2880 2880,3330
structures to help interface,| and
|所有这些不同种类的硬件。

252
00:07:42,120 --> 00:07:43,350
0,450 480,720 720,810 810,1080 1080,1230
{} all the different kinds

253
00:07:43,350 --> 00:07:44,520
0,60 60,780
of hardware,|
|

254
00:07:45,020 --> 00:07:48,170
0,660 900,1290 1290,1590 1590,2400 2730,3150
{} these user programs need
这些用户程序需要使用的硬件。

255
00:07:48,170 --> 00:07:50,300
0,120 120,720 1380,1470 1470,1770 1770,2130
to use.| the kernel also
|内核也有很多内置服务，

256
00:07:50,300 --> 00:07:51,260
0,300 300,570 570,690 690,780 780,960
has built in a bunch

257
00:07:51,260 --> 00:07:53,240
0,90 90,1080
of services,|
|

258
00:07:53,550 --> 00:07:55,260
0,330 330,540 540,660 660,1260 1410,1710
and so, for example {}
比如，通常内核实现了一个文件系统，

259
00:07:55,260 --> 00:07:57,240
0,180 180,630 630,750 750,1170 1170,1980
there's typically a file system

260
00:07:57,980 --> 00:07:59,900
0,750 750,1200 1200,1290 1290,1740 1740,1920
implementation inside the kernel,| that
|它实现了文件名、文件内容和文件夹，

261
00:08:00,110 --> 00:08:02,660
0,510 510,780 780,1740 1770,2190 2190,2550
implements things like file names

262
00:08:02,660 --> 00:08:04,790
0,150 150,420 420,1080 1080,1320 1320,2130
and file contents and directories|
|

263
00:08:04,790 --> 00:08:07,070
0,360 960,1470 1470,1590 1590,1680 1680,2280
and understands how to store
并且知道如何将文件存储在磁盘上，

264
00:08:07,100 --> 00:08:07,910
0,90 90,420 420,480 480,570 570,810
the files in the disk,|
|

265
00:08:07,910 --> 00:08:09,110
0,150 150,450 630,1050 1050,1080 1080,1200
so your programs are going
所以程序访问内核中的文件，

266
00:08:09,110 --> 00:08:10,040
0,60 60,300 300,360 360,510 510,930
to talk to the files

267
00:08:10,040 --> 00:08:11,990
0,300 300,360 360,810 810,1140 1380,1950
inside the kernel| and file
然后文件系统访问磁盘。

268
00:08:11,990 --> 00:08:13,440
0,750 750,1050
implementations {is,going,to}

269
00:08:13,540 --> 00:08:14,760
0,270 270,360 360,450 450,990
talk to the disk.|

270
00:08:15,410 --> 00:08:16,660
0,180 180,390 390,1110
In this course,|
在这门课上，|

271
00:08:17,460 --> 00:08:18,990
0,330 360,600 600,720 720,1140 1140,1530
{} where we mostly focus
我们主要关注内核内部发生的所有事情，

272
00:08:18,990 --> 00:08:20,160
0,300 300,570 570,810 810,930 930,1170
on is all the things

273
00:08:20,160 --> 00:08:21,330
0,120 120,300 300,390 390,690 690,1170
that has to happen inside

274
00:08:21,330 --> 00:08:23,100
0,60 60,510 810,1140 1140,1620 1620,1770
the kernel,| {} and on
|还有用户程序和内核之间的接口，

275
00:08:23,100 --> 00:08:25,170
0,90 90,780 780,1170 1170,1470 1470,2070
the interfaces between user programs

276
00:08:25,170 --> 00:08:26,060
0,150 150,210 210,600
and the kernel,|
|

277
00:08:27,490 --> 00:08:28,930
0,240 240,450 450,780 810,870 870,1440
As well as the structure
还有内核里面的软件结构，

278
00:08:28,930 --> 00:08:31,000
0,150 150,240 240,990 1440,1710 1710,2070
of the software {} inside

279
00:08:31,000 --> 00:08:33,340
0,90 90,390 1110,1470 1530,2010
the kernel.| So {}
|所以我们很关心内核中的这些服务。

280
00:08:33,430 --> 00:08:34,270
0,180 180,330 330,390 390,600 600,840
we care a lot about

281
00:08:34,270 --> 00:08:37,030
0,540 570,1740 1770,2190 2190,2250 2250,2760
these services inside the kernel.|
|

282
00:08:38,610 --> 00:08:39,150
0,180 180,240 240,330 330,480 480,540
One of them is a
其中之一是我提到过的文件系统，

283
00:08:39,150 --> 00:08:40,560
0,270 270,570 570,630 630,1200 1230,1410
file system I mentioned,| there's
|

284
00:08:40,560 --> 00:08:42,000
0,630 630,1080
also {}
还有对进程的管理，

285
00:08:42,570 --> 00:08:44,700
0,1050 1050,1110 1110,1830 1830,2070 2070,2130
management of processes,| each of
|每个运行的程序被称为进程，

286
00:08:44,700 --> 00:08:46,620
0,240 240,750 750,1650 1650,1740 1740,1920
these running programs is called

287
00:08:46,620 --> 00:08:47,640
0,90 90,630 630,750 750,840 840,1020
the process,| and it has
|它有自己的内存，

288
00:08:47,640 --> 00:08:49,230
0,300 300,570 660,840 840,1080 1080,1590
things like its own memory,|
|

289
00:08:49,230 --> 00:08:51,180
0,150 150,720 750,1050 1050,1380 1380,1950
for example as well as
还有共享 CPU 时间。

290
00:08:51,420 --> 00:08:52,950
0,300 300,840 840,960 960,1050 1050,1530
a share of the CPU

291
00:08:52,950 --> 00:08:54,420
0,360 690,1170
time.| So,
|内核将进程作为内核服务进行管理，

292
00:08:54,760 --> 00:08:58,140
0,330 330,630 630,1560 2040,3090
{} kernel manages processes.

293
00:08:58,540 --> 00:09:00,730
0,240 240,300 330,660 660,1440 1710,2190
as a kernel service {},|
|

294
00:09:01,300 --> 00:09:03,220
0,300 300,720 780,1290 1290,1740 1740,1920
{} {} kernel manages the
内核管理内存的分配，

295
00:09:03,220 --> 00:09:06,070
0,780 780,1230 1260,1710 1740,2520 2730,2850
allocation of the memory,| the
|不同的进程需要不同数量的内存，

296
00:09:06,070 --> 00:09:07,630
0,270 270,840 840,1080 1080,1320 1320,1560
different processes need different amounts

297
00:09:07,630 --> 00:09:09,000
0,60 60,450 450,540 540,1050
of memory,| the kernel
|内核复用、划分内存，

298
00:09:10,970 --> 00:09:12,590
0,870 870,1020 1020,1110 1110,1470 1470,1620
multiplexes {} and divides up

299
00:09:12,590 --> 00:09:14,660
0,90 90,720 930,1470 1470,1560 1560,2070
the memory,| allocates the memory
|给不同的进程分配内存。

300
00:09:15,840 --> 00:09:17,130
0,510 600,900 900,990 990,1080 1080,1290
{} among all the different

301
00:09:17,130 --> 00:09:18,200
0,870
processes.|
|

302
00:09:22,240 --> 00:09:24,160
0,570

303
00:09:24,400 --> 00:09:25,480
0,90 90,390 390,540 540,570 570,1080
The kernel as I mentioned
正如我提到的，内核影响文件系统，

304
00:09:25,510 --> 00:09:26,650
0,270 270,570 570,630 630,870 870,1140
{} influence the file system,|
|

305
00:09:26,650 --> 00:09:27,880
0,210 210,450 450,660 660,930 930,1230
file system really comes into
文件系统实际上分为三个逻辑部分或几个逻辑部分，

306
00:09:27,880 --> 00:09:29,950
0,90 90,750 870,1620 1650,1920 1950,2070
a three logical or a

307
00:09:29,950 --> 00:09:31,270
0,240 240,300 300,690 690,1080 1080,1320
bunch of logical parts,| but
|但现在，我们可以从管理文件内容的角度来考虑它，

308
00:09:31,630 --> 00:09:32,350
0,150 150,360 360,450 450,540 540,720
for now, we can think

309
00:09:32,350 --> 00:09:33,310
0,60 60,180 180,300 300,630 630,960
of it in terms of

310
00:09:33,310 --> 00:09:35,650
0,510 510,780 780,1500 1500,2010 2010,2340
managing file content that's inside

311
00:09:35,650 --> 00:09:37,510
0,600 630,1170 1170,1260 1260,1590 1590,1860
files,| figuring out where on
|找到内容在磁盘中的位置。

312
00:09:37,510 --> 00:09:38,360
0,630
disk.|
|

313
00:09:39,080 --> 00:09:40,190
0,240 240,480 480,570 570,960 960,1110
Each {file's -} content {ought,to}
每个文件内容都是可以变化的，

314
00:09:40,190 --> 00:09:42,080
0,420 720,1050 1050,1320 1320,1560 1560,1890
live,| file system also somewhat
|文件系统也在某种程度上管理一个命名空间，

315
00:09:42,080 --> 00:09:44,150
0,600 630,1140 1140,1200 1200,1530 1530,2070
separately manages a name space,|
|

316
00:09:44,150 --> 00:09:44,990
0,120 210,420 420,660 660,780 780,840
that each file has a
每个文件都有一个名字，

317
00:09:44,990 --> 00:09:47,180
0,630 660,1050 1050,1260 1260,1380 1380,2190
name| and there's a hierarchy
|有一个层级目录，每个目录中有多个文件，

318
00:09:47,180 --> 00:09:49,700
0,270 270,1380 1650,2010 2010,2430 2430,2520
of directories, every directory has

319
00:09:49,700 --> 00:09:50,480
0,60 60,240 240,300 300,660 660,780
a bunch of files in

320
00:09:50,480 --> 00:09:52,490
0,150 150,300 300,570 570,1200 1860,2010
it,| all that's managed by
|所有这些都是由文件系统管理的。

321
00:09:52,490 --> 00:09:53,640
0,120 120,390 390,870
the file system.|
|

322
00:09:54,030 --> 00:09:55,410
0,330 450,720 720,1050 1050,1230 1230,1380
{} There's typically some sort
通常会有某种安全策略，

323
00:09:55,410 --> 00:09:57,750
0,60 60,570 570,1290 1890,2220 2220,2340
of security arrangement,| maybe we'll
|有时也称为访问控制。

324
00:09:57,750 --> 00:09:59,440
0,210 210,300 300,690 690,1380
call it access control.|
|

325
00:10:01,750 --> 00:10:03,370
0,330 330,390 390,630 630,1380 1380,1620
Which the kernel decides| that
由内核决定，|当一个进程想要读取，使用资源时，

326
00:10:03,580 --> 00:10:04,750
0,270 270,330 330,540 540,960 960,1170
when a given process wants

327
00:10:04,750 --> 00:10:06,760
0,120 120,960 1020,1530 1560,1830 1830,2010
to read, {} use some

328
00:10:06,760 --> 00:10:08,260
0,450 450,690 690,900 900,1230 1230,1500
resource,| maybe read something from
|或许是从磁盘读取东西，使用内存，

329
00:10:08,260 --> 00:10:09,700
0,270 270,480 480,630 630,1110 1170,1440
disk, use some memory,| the
|内核内部的访问控制机制，

330
00:10:09,700 --> 00:10:11,200
0,330 330,600 600,1110 1110,1440 1440,1500
access control machinery inside the

331
00:10:11,200 --> 00:10:12,130
0,390 390,480 480,660 660,840 840,930
kernel| is what gets to
|可以决定它是允许还是不允许，

332
00:10:12,130 --> 00:10:13,330
0,360 360,630 630,720 720,840 840,1200
decide yes it's {} allowed

333
00:10:13,330 --> 00:10:14,530
0,90 90,240 240,420 420,780 960,1200
is that not allowed,| that
|这也会很复杂，

334
00:10:14,530 --> 00:10:15,730
0,120 120,270 270,420 420,1080 1080,1200
can get pretty complicated| if
|如果我们讨论的是类似 Athena 的分时系统，

335
00:10:15,730 --> 00:10:16,900
0,90 90,330 330,600 600,840 840,1170
we're talking about time sharing

336
00:10:16,900 --> 00:10:18,910
0,540 540,810 1080,1470 1470,1920 1920,2010
systems like Athena systems,| where
|在那里，每个进程可能由不同的用户运行，

337
00:10:18,910 --> 00:10:20,020
0,330 600,720 720,810 810,1020 1020,1110
there's you know each of

338
00:10:20,020 --> 00:10:21,490
0,270 270,900 900,1020 1020,1230 1260,1470
these processes may be run

339
00:10:21,490 --> 00:10:22,720
0,150 150,240 240,540 540,990 990,1230
by a different user| and
|有不同的访问控制规则，

340
00:10:22,930 --> 00:10:24,910
0,210 210,600 630,960 960,1350 1350,1980
have different access control rules,|

341
00:10:24,940 --> 00:10:26,290
0,330 330,450 450,600 600,750 750,1350
apply to what it's allowed
是否允许访问其内容。

342
00:10:26,320 --> 00:10:27,180
0,120 120,300 300,570
to get at.|
|

343
00:10:28,830 --> 00:10:30,570
0,240 240,330 330,450 450,1110 1110,1740
And in a real full-blown
在一个成熟的操作系统中，

344
00:10:30,570 --> 00:10:32,160
0,360 360,840 1140,1410 1410,1530 1530,1590
operating system| turns out to
|还有很多其他的服务，

345
00:10:32,160 --> 00:10:33,900
0,90 90,480 480,750 750,930 930,1740
be many, many other services,|
|

346
00:10:34,050 --> 00:10:35,340
0,120 120,180 180,540 570,1080 1080,1290
you know there's typically some
你知道，不同的进程通常有某种方式互相通信，

347
00:10:35,340 --> 00:10:36,780
0,240 240,390 390,750 750,1350 1350,1440
way for different processes to

348
00:10:36,780 --> 00:10:37,920
0,270 270,390 390,510 510,870 870,1140
talk to each other,| called
|这称为进程间通信，

349
00:10:37,950 --> 00:10:40,860
0,150 150,540 540,1470 2250,2610 2610,2910
inter process communication,| there's typically
|通常有很多软件使用网络，

350
00:10:40,860 --> 00:10:42,210
0,60 60,570 570,810 810,930 930,1350
a whole bunch of software

351
00:10:42,210 --> 00:10:43,830
0,450 450,540 540,630 630,1320 1440,1620
associated with the network things,|

352
00:10:43,830 --> 00:10:46,200
0,150 150,270 270,1140 1140,1590 1590,2370
like the {TCP/IP -} protocols
比如用于网络通信的的 TCP/IP 协议，

353
00:10:46,200 --> 00:10:48,690
0,270 480,930 930,1020 1020,1590 1920,2490
for talking the network {},|
|

354
00:10:49,900 --> 00:10:51,670
0,480 480,840 840,1170 1170,1290 1290,1770
there's typically support for sound
通常也会支持声卡，

355
00:10:51,670 --> 00:10:53,320
0,660 660,810 810,930 930,1020 1020,1650
cards,| there may be drivers
|可能会有上百个不同磁盘和上百个网卡驱动，

356
00:10:53,320 --> 00:10:54,880
0,120 120,630 630,720 720,1080 1080,1560
for hundreds of different disks

357
00:10:54,880 --> 00:10:55,960
0,150 150,510 510,570 570,810 810,1080
and hundreds of different network

358
00:10:55,960 --> 00:10:57,430
0,420 510,840 840,930 930,1080 1080,1470
cards,| so in a full-blown
|所以在一个成熟的操作系统中，

359
00:10:57,430 --> 00:10:59,620
0,360 360,720 720,990 1260,1680 1830,2190
operating system| is a huge
|有大量的东西，

360
00:10:59,620 --> 00:11:00,310
0,150 150,210 210,480 480,600 600,690
amount of stuff here| and
|这可能会在内核中运行数百万行代码。

361
00:11:00,310 --> 00:11:01,420
0,120 120,300 300,480 480,540 540,1110
this may run to millions

362
00:11:01,420 --> 00:11:03,340
0,90 90,480 480,570 570,1200 1470,1920
of lines of code inside

363
00:11:03,340 --> 00:11:04,120
0,60 60,510
the kernel.|
|

364
00:11:05,300 --> 00:11:06,890
0,360 1110,1350 1350,1470 1470,1530 1530,1590
So that's sort of a
这是对内核内部的概述，

365
00:11:06,890 --> 00:11:08,120
0,240 240,600 600,660 660,840 840,1230
quick overview of whats inside

366
00:11:08,120 --> 00:11:10,790
0,60 60,540 1440,1710 1710,2130 2130,2670
the kernel,| we're also interested
|我们还对应用程序与内核交互，

367
00:11:10,790 --> 00:11:12,890
0,90 90,510 510,1500 1530,2010 2010,2100
in how applications interact with

368
00:11:12,890 --> 00:11:14,030
0,60 60,450 480,690 690,930 930,1140
the kernel| and what that
|以及相关的接口定义感兴趣。

369
00:11:14,030 --> 00:11:16,320
0,690 900,1560 1560,1890
interface looks like.|
|

370
00:11:19,060 --> 00:11:20,520
0,570 600,1200
The {}
一般，所以这是内核的 API 。

371
00:11:22,160 --> 00:11:25,160
0,330 360,1410 1980,2610 2640,2850 2850,3000
{} usual, {} so this

372
00:11:25,160 --> 00:11:26,990
0,120 120,390 570,1590 1590,1740 1740,1830
is the API for the

373
00:11:26,990 --> 00:11:27,860
0,570
kernel.|
|

374
00:11:30,610 --> 00:11:31,780
0,270 270,810 810,960 960,1080 1080,1170
How applications get at the
应用程序如何访问内核，

375
00:11:31,780 --> 00:11:34,000
0,450 720,1110 1470,1800 1800,2040 2040,2220
kernel,| {} typically that's done
|通常是通过系统调用来完成的，

376
00:11:34,000 --> 00:11:35,410
0,120 120,330 330,570 570,990 990,1410
with something called system calls|
|

377
00:11:35,410 --> 00:11:36,430
0,120 120,300 300,360 360,720 720,1020
and these are things that
它们看起来像是程序使用的函数调用，

378
00:11:36,520 --> 00:11:38,200
0,360 360,570 570,930 930,1470 1470,1680
look like function calls| that

379
00:11:38,320 --> 00:11:39,240
0,600

380
00:11:39,480 --> 00:11:41,880
0,420 420,510 510,960 1620,2010 2010,2400
programs can make,| but actually
|但实际上是跳入内核，

381
00:11:41,880 --> 00:11:43,500
0,300 300,420 420,540 540,1110 1110,1620
jump into the kernel| and
|并在执行内核中实现的系统调用，

382
00:11:43,770 --> 00:11:46,530
0,810 810,1080 1290,1710 1710,1950 1950,2760
execute {} system call implementation

383
00:11:46,530 --> 00:11:48,000
0,90 90,180 180,600 900,1260 1260,1470
in the kernel,| I'll talk
|在这个讲座的后半部分，我会谈到这些，

384
00:11:48,000 --> 00:11:49,170
0,210 360,600 600,840 840,1050 1050,1170
a bunch about that in

385
00:11:49,170 --> 00:11:49,980
0,180 180,420 420,600 600,660 660,810
the latter part of this

386
00:11:49,980 --> 00:11:51,810
0,540 1110,1440 1440,1590 1590,1770 1770,1830
lecture,| for now just to
|现在，只是让你初步了解一下。

387
00:11:51,810 --> 00:11:53,100
0,90 90,210 210,270 270,660 660,1290
give you a flavor here,|
|

388
00:11:53,100 --> 00:11:54,390
0,390 390,450 450,840 840,960 960,1290
what a couple of different
应用程序代码中几个不同的系统调用是什么样的。

389
00:11:54,390 --> 00:11:55,470
0,300 300,570 570,750 750,930 930,1080
system calls might look like

390
00:11:55,470 --> 00:11:56,880
0,90 90,180 180,600 600,1170 1290,1410
in the source code of

391
00:11:56,880 --> 00:11:58,180
0,90 90,780
an application.|
|

392
00:12:00,310 --> 00:12:01,810
0,240 240,510 510,870 870,1200 1320,1500
One might be that| if
其中一个是，|如果应用程序想要打开文件，

393
00:12:01,810 --> 00:12:02,890
0,90 90,330 330,450 450,900 900,1080
you want an application wants

394
00:12:02,890 --> 00:12:04,420
0,90 90,300 300,360 360,1020 1290,1530
to open a file,| and
|它可以调用 open 系统调用。

395
00:12:04,420 --> 00:12:06,220
0,480 480,720 720,840 840,1380 1380,1800
it calls the open system

396
00:12:06,220 --> 00:12:07,000
0,450
call,|
|

397
00:12:07,420 --> 00:12:09,100
0,360 450,1020 1020,1140 1140,1410 1410,1680
and tells the open system
把文件名传给 open 系统调用，

398
00:12:09,100 --> 00:12:09,940
0,210 210,300 300,660 660,750 750,840
called the name of the

399
00:12:09,940 --> 00:12:11,500
0,570 780,930 930,1170 1170,1320 1320,1560
file,| so maybe it wants
|它想要打开一个名为 out 的文件并写入，

400
00:12:11,500 --> 00:12:12,730
0,270 390,690 690,780 780,1050 1050,1230
to open a file for

401
00:12:12,730 --> 00:12:14,830
0,690 720,1080 1080,1470 1470,1620 1950,2100
writing called out| and {}
|下一个参数是 1 ，

402
00:12:14,830 --> 00:12:15,850
0,90 90,180 180,450 450,840 840,1020
{} {} next argument here

403
00:12:15,850 --> 00:12:17,500
0,510 840,1200 1200,1290 1290,1440 1440,1650
saying 1 in this case.|
|

404
00:12:17,500 --> 00:12:18,130
0,150 150,240 240,360 360,420 420,630
Saying I want to write
我想写那个文件，

405
00:12:18,130 --> 00:12:19,990
0,240 240,630 870,1020 1020,1350 1410,1860
that file,| and so this
|这个看起来像函数调用。

406
00:12:19,990 --> 00:12:20,740
0,150 150,300 300,540 540,660 660,750
thing that looks like a

407
00:12:20,740 --> 00:12:21,820
0,390 390,810
function call.|
|

408
00:12:22,670 --> 00:12:23,810
0,150 150,420 420,510 510,840 840,1140
It opens the system calls
open 系统调用实际上是跳入内核的指定代码，

409
00:12:23,810 --> 00:12:25,910
0,420 420,810 810,1230 1230,1530 1800,2100
actually special code that jumps

410
00:12:25,910 --> 00:12:26,660
0,150 150,210 210,570 570,660 660,750
into the kernel| and the
|内核可以获得这些参数，

411
00:12:26,660 --> 00:12:28,400
0,270 270,420 420,840 840,1020 1020,1740
kernel can retrieve these arguments,|
|

412
00:12:28,700 --> 00:12:29,930
0,480 480,600 600,900 900,1140 1140,1230
executes some kernel code that
执行一些实现 open 的内核代码，

413
00:12:29,930 --> 00:12:31,220
0,420 420,750 750,960 960,1230 1230,1290
implements open,| maybe talks to
|可能是访问磁盘，然后返回一个值，

414
00:12:31,220 --> 00:12:33,050
0,120 120,600 930,1290 1290,1410 1410,1830
the disk, and then returns

415
00:12:33,050 --> 00:12:34,160
0,60 60,420 420,540 540,810 810,1110
a value| and that's this
|这就是文件描述符， fd 表示文件描述符。

416
00:12:34,190 --> 00:12:35,620
0,390 390,1140
file descriptor,

417
00:12:36,240 --> 00:12:37,560
0,360 360,570 570,870 870,1020 1020,1320
as fd stands for file

418
00:12:37,560 --> 00:12:39,690
0,660 1050,1230 1230,1470 1470,1860 2010,2130
descriptor,| {} which is the
程序可以使用文件描述符来访问这个打开的文件。

419
00:12:39,690 --> 00:12:40,740
0,390 390,510 510,720 720,930 930,1050
program can then use as

420
00:12:40,740 --> 00:12:42,840
0,300 300,1050 1260,1410 1410,1980 1980,2100
a handle to refer to

421
00:12:42,840 --> 00:12:44,540
0,510 510,840 840,1410
this open file.|
|

422
00:12:44,760 --> 00:12:46,290
0,390 1170,1290 1290,1350 1350,1470 1470,1530
{} If you want to
如果你想写入一个文件，

423
00:12:46,290 --> 00:12:47,610
0,240 240,330 330,450 450,870 870,1320
write to a file,| the
|需要使用系统调用 write ，

424
00:12:48,240 --> 00:12:49,340
0,360 360,810
system {call,did},

425
00:12:49,400 --> 00:12:50,300
0,150 150,270 270,600 600,690 690,900
to do that is called

426
00:12:50,330 --> 00:12:51,890
0,600 870,960 960,1050 1050,1170 1170,1560
write,| you have to pass
|你必须向它传递一个文件描述符，

427
00:12:51,890 --> 00:12:52,760
0,120 120,300 300,360 360,570 570,870
it one of these file

428
00:12:52,760 --> 00:12:54,440
0,600 600,660 660,960 960,1380 1380,1680
descriptors,| the same was returned
|跟 open 返回的类似，

429
00:12:54,440 --> 00:12:55,420
0,120 120,660
by open,|
|

430
00:12:55,700 --> 00:12:57,530
0,570 600,870 870,1020 1020,1710 1710,1830
{} these are arguments that
这些是系统调用中传递的参数。

431
00:12:57,530 --> 00:12:58,850
0,210 480,870 870,930 930,990 990,1320
are passed in the system

432
00:12:58,850 --> 00:12:59,600
0,420
call.|
|

433
00:12:59,770 --> 00:13:01,090
0,300 300,450 450,990 990,1230 1230,1320
From the program into the
从程序到内核，

434
00:13:01,090 --> 00:13:02,470
0,510 870,1080 1080,1170 1170,1290 1290,1380
kernel,| and you give it
|你给它一个指向一个字符缓冲区的指针，

435
00:13:02,470 --> 00:13:03,740
0,120 120,960
a pointer

436
00:13:03,960 --> 00:13:05,370
0,150 150,270 270,600 600,720 720,1410
to a buffer of characters,|
|

437
00:13:05,370 --> 00:13:06,720
0,300 720,930 930,1170 1170,1260 1260,1350
so an easy way to
在 C 语言中，一个简单的方法是，

438
00:13:06,720 --> 00:13:07,470
0,120 120,330 330,390 390,480 480,750
do that in the C

439
00:13:07,470 --> 00:13:09,240
0,450 450,840 840,1140 1140,1350 1350,1770
programming language,| which these examples
|使用双引号，然后加上字符串，

440
00:13:09,240 --> 00:13:10,770
0,90 90,420 420,690 690,1080 1110,1530
are written by as double

441
00:13:10,770 --> 00:13:12,080
0,420 420,960
quotes then

442
00:13:12,340 --> 00:13:13,870
0,330 330,450 450,1140 1140,1230 1230,1530
{} the string,| the bytes
|字符串中的 \n 表示换行，

443
00:13:13,870 --> 00:13:15,670
0,60 60,120 120,750 1050,1680 1680,1800
of the string backslash n

444
00:13:15,670 --> 00:13:17,350
0,150 150,210 210,420 420,1020 1350,1680
is a new line| and
|第三个参数是字符数。

445
00:13:17,350 --> 00:13:18,460
0,150 150,480 480,900 900,1020 1020,1110
the third argument is the

446
00:13:18,460 --> 00:13:19,940
0,330 330,420 420,1350
count of characters.|
|

447
00:13:20,160 --> 00:13:21,450
0,600 780,960 960,1050 1050,1200 1200,1290
{} If you want to
如果想写入，这里是关键，

448
00:13:21,450 --> 00:13:22,800
0,420 660,870 870,1020 1020,1170 1170,1350
write so this really gets

449
00:13:22,800 --> 00:13:24,720
0,390 690,1170 1170,1350 1350,1830 1830,1920
point,| pass this address in
|把内存中的这个地址传过去，

450
00:13:24,720 --> 00:13:25,620
0,630
memory,|
|

451
00:13:25,860 --> 00:13:26,640
0,120 120,240 240,480 480,540 540,780
so you're telling the kernel
告诉内核，请把这个地址的 6 个字节

452
00:13:26,640 --> 00:13:28,290
0,210 210,480 480,780 810,1200 1200,1650
look, please write 6 bytes

453
00:13:28,290 --> 00:13:29,850
0,180 180,360 360,1110 1320,1440 1440,1560
from this address| to the
|写入到这个文件描述符关联的文件中。

454
00:13:29,850 --> 00:13:31,680
0,450 450,630 630,900 900,1200 1200,1830
file that this file descriptor

455
00:13:31,710 --> 00:13:32,840
0,510 510,810
refers to.|
|

456
00:13:33,750 --> 00:13:35,970
0,360 600,930 930,1020 1020,1890 1890,2220
A much more exciting system
一个更有意思的系统调用是 fork 系统调用，

457
00:13:35,970 --> 00:13:37,590
0,300 300,510 750,1380 1380,1500 1500,1620
call the encounter is the

458
00:13:37,590 --> 00:13:39,600
0,330 330,630 630,1080 1500,1890 1890,2010
fork system call fork is

459
00:13:39,600 --> 00:13:41,430
0,180 180,510 510,960 990,1260 1500,1830
the system call,| that creates
|它创建一个新的进程，

460
00:13:41,430 --> 00:13:42,560
0,30 30,150 150,990
a new process,|
|

461
00:13:42,620 --> 00:13:43,480
0,570

462
00:13:44,160 --> 00:13:46,080
0,330 330,1380 1380,1650 1650,1890 1890,1920
and returns actually creates a
并返回一个与调用方相同的进程，

463
00:13:46,080 --> 00:13:47,430
0,360 360,540 540,1140 1140,1230 1230,1350
process that's identical to the

464
00:13:47,430 --> 00:13:50,190
0,570 870,1290 1320,1710 1710,2430 2430,2760
caller| and fork returns the
|fork 返回新创建进程的进程标识符 pid 。

465
00:13:50,400 --> 00:13:53,040
0,1080 1080,1170 1170,1620 1620,2430 2430,2640
identifier the process identifier {pid

466
00:13:53,040 --> 00:13:56,100
0,510 840,1320 1770,2130 2130,2760 3000,3060
-} {of,the} new process {}.|
|

467
00:13:56,100 --> 00:13:57,920
0,270 270,780 780,900 900,1410
More complicated than [],
更复杂的[]，我们还会听到更多关于这方面的内容。

468
00:13:58,040 --> 00:13:59,270
0,120 120,360 360,540 540,780 780,1230
we'll hear more about this.|
|

469
00:14:00,740 --> 00:14:02,030
0,300 300,510 510,690 690,840 840,1290
So again, these are all
同样，这些看起来像函数调用，

470
00:14:02,030 --> 00:14:04,730
0,180 180,360 360,720 720,1440 2370,2700
look like function calls,| but
|但是系统调用很特殊，因为它们跳入内核。

471
00:14:04,730 --> 00:14:05,690
0,60 60,360 360,570 570,630 630,960
the system calls are special

472
00:14:05,690 --> 00:14:06,560
0,180 180,330 330,600 600,750 750,870
because they jump into the

473
00:14:06,560 --> 00:14:07,240
0,390
kernel.|
|

474
00:14:08,200 --> 00:14:10,120
0,150 150,540 540,1200 1590,1740 1740,1920
{} That's taste, we'll see
这是初步了解，稍后我们会看到更多。

475
00:14:10,120 --> 00:14:10,960
0,180 180,540
more later.|
|

476
00:14:15,800 --> 00:14:16,640
0,270 270,390 390,570 570,780 780,840
That is a sort of
这是一个简单的概述，

477
00:14:16,640 --> 00:14:20,000
0,270 270,930 960,1560 2100,2550 2640,3360
quick overview,| {} I wanna
我想提一下为什么我发现操作系统的学习，

478
00:14:20,530 --> 00:14:22,480
0,210 210,600 600,900 900,1140 1140,1950
just mention why I find

479
00:14:22,540 --> 00:14:23,860
0,360 360,810 810,900 900,1230 1230,1320
a operating the study of

480
00:14:23,860 --> 00:14:25,220
0,390 390,1140
operating systems,|
|

481
00:14:25,300 --> 00:14:29,260
0,180 180,870 900,1710 2010,2610 3060,3960
to be both a challenging
既有挑战性，又十分有趣。

482
00:14:29,260 --> 00:14:30,460
0,360 360,900
and interesting.|
|

483
00:14:32,710 --> 00:14:33,580
0,240 240,360 360,450 450,630 630,870
Why you know why it's
为什么值得在这方面开一门课。

484
00:14:33,580 --> 00:14:34,620
0,270 270,840
maybe worth

485
00:14:35,360 --> 00:14:37,520
0,540 960,1620 1620,1860 1860,2100 2100,2160
{} intellectually worth taking a

486
00:14:37,520 --> 00:14:39,240
0,300 300,390 390,510 510,930
course in this area.|
|

487
00:14:39,370 --> 00:14:40,120
0,180 180,300 300,540 540,630 630,750
So, one reason why it's
这很难的一个原因是，环境是难以应对的，

488
00:14:40,120 --> 00:14:41,890
0,360 360,510 510,780 780,1230 1260,1770
hard is that the environment

489
00:14:41,890 --> 00:14:44,980
0,60 60,870 1200,1650 1890,2520 2520,3090
is unforgiving,| {} programming environment
|内核的编程环境是难以应对的，

490
00:14:44,980 --> 00:14:46,360
0,420 420,480 480,840 840,990 990,1380
inside the kernels {unforgiving -},|
|

491
00:14:46,360 --> 00:14:48,180
0,480 690,1560
because you're,
因为当你在编程时，

492
00:14:50,570 --> 00:14:51,950
0,300 300,510 510,660 660,1290 1290,1380
your when you're programming,| when
|当你修改或扩展内核，

493
00:14:51,950 --> 00:14:53,030
0,90 90,600 600,690 690,1020 1020,1080
you're modifying the kernel or

494
00:14:53,030 --> 00:14:54,200
0,390 390,480 480,780 780,840 840,1170
extending the kernel| or writing
|或编写新的操作系统内核时，

495
00:14:54,200 --> 00:14:55,580
0,30 30,240 240,630 630,960 960,1380
a new operating system kernel,|

496
00:14:55,640 --> 00:14:57,620
0,450 450,870 870,990 990,1740 1740,1980
you're providing the infrastructure that
你提供的是其他人认为已经存在的基础设施，

497
00:14:57,740 --> 00:14:59,480
0,480 480,780 780,1320 1320,1440 1440,1740
everybody else assumes| is already
|用来运行他们的程序。

498
00:14:59,480 --> 00:15:01,280
0,480 480,600 600,780 780,930 930,1800
present to run their programs.|
|

499
00:15:01,640 --> 00:15:02,750
0,180 180,420 450,750 750,960 960,1110
And then everybody else gets
任何人编写应用程序都在操作系统上运行，

500
00:15:02,750 --> 00:15:03,830
0,60 60,450 450,780 780,930 930,1080
an operating system under their

501
00:15:03,830 --> 00:15:05,600
0,720 780,930 930,1050 1050,1380 1440,1770
program| when they write ordinary
|当他们编写普通应用程序时，

502
00:15:05,600 --> 00:15:08,030
0,480 480,900 900,1140 1440,2010 2010,2430
application programs,| but when we
|但是当我们构建操作系统时，

503
00:15:08,030 --> 00:15:09,230
0,270 270,600 600,960 960,1110 1110,1200
build operating systems| what we
|操作系统下直接是硬件，

504
00:15:09,230 --> 00:15:11,150
0,300 300,540 540,630 630,1200 1200,1920
get is the hardware underneath

505
00:15:11,390 --> 00:15:13,820
0,210 210,570 570,1020 1800,2160 2160,2430
our operating system| which turns
|结果是更难处理。

506
00:15:13,820 --> 00:15:15,110
0,150 150,240 240,540 570,900 900,1290
out to be more difficult

507
00:15:15,110 --> 00:15:15,950
0,60 60,300 300,510 540,660 660,840
to deal with.| In this
|在本课程中，

508
00:15:15,950 --> 00:15:17,900
0,360 360,600 960,1650
course,| we {}
|我们用到一个叫 QEMU 的硬件模拟器，

509
00:15:18,340 --> 00:15:19,450
0,270 270,450 450,540 540,750 750,1110
we get to use a

510
00:15:19,480 --> 00:15:21,070
0,420 420,960 960,1170 1170,1410 1410,1590
hardware simulator called {QEMU -

511
00:15:21,070 --> 00:15:22,500
0,300 750,1140
-} {}.|
|

512
00:15:22,790 --> 00:15:25,370
0,270 510,1500 1710,1860 1860,2460 2460,2580
That simulates a CPU and
它模拟一个 CPU 和一台计算机，

513
00:15:25,370 --> 00:15:26,450
0,60 60,600 600,750 750,900 900,1080
a computer| and that makes
|这样做会好一点，

514
00:15:26,450 --> 00:15:27,470
0,240 240,390 390,540 540,750 750,1020
a little bit better,| but
|但它仍然是困难的编程环境。

515
00:15:27,530 --> 00:15:28,730
0,510 510,840 840,960 960,1140 1140,1200
it's still a kind of

516
00:15:28,730 --> 00:15:30,980
0,90 90,750 960,1200 1200,1740 1740,2250
a difficult, {} environment programming.|
|

517
00:15:32,360 --> 00:15:33,380
0,270 270,480 480,600 600,690 690,1020
Another reason why it's hard
另一个困难又有趣的原因是，

518
00:15:33,380 --> 00:15:35,090
0,90 90,540 540,720 720,1200 1590,1710
and interesting is| because if
|当你在设计操作系统时，

519
00:15:35,090 --> 00:15:36,620
0,120 120,630 630,720 720,1170 1170,1530
you're designing and operating system,|
|

520
00:15:36,620 --> 00:15:37,670
0,90 90,180 180,300 300,960 960,1050
you have to satisfy a
必须解决一系列矛盾。

521
00:15:37,670 --> 00:15:39,860
0,270 270,450 870,1830
bunch of tensions,|
|

522
00:15:39,980 --> 00:15:41,390
0,390 390,510 510,810 810,960 960,1410
{} that require real design
这需要真正的设计思想，

523
00:15:41,390 --> 00:15:42,950
0,300 510,930 1050,1290 1290,1440 1440,1560
thought.| So one is that
|其中之一是，你希望操作系统要有效率。

524
00:15:42,950 --> 00:15:44,840
0,150 150,390 390,1050 1080,1500 1500,1890
you'd like your operating system

525
00:15:44,840 --> 00:15:46,480
0,90 90,240 240,480 480,1380
to be both efficient.|
|

526
00:15:46,720 --> 00:15:48,520
0,600 870,1080 1080,1320 1320,1650 1650,1800
{} Which often means that
这通常意味着它在接近硬件的底层上运行，

527
00:15:48,520 --> 00:15:49,930
0,210 420,1080 1080,1140 1140,1170 1170,1410
it operates at a low

528
00:15:49,930 --> 00:15:51,280
0,270 270,540 540,630 630,720 720,1350
level close to the hardware,|
|

529
00:15:51,640 --> 00:15:53,260
0,450 510,720 720,900 900,1020 1020,1620
but for ease of use,|
但是为了便于使用，|

530
00:15:53,290 --> 00:15:54,850
0,360 360,840 840,1110 1110,1320 1320,1560
and because real live people
而且现实生活中的人必须使用你的操作系统编写程序，

531
00:15:54,850 --> 00:15:56,710
0,90 90,180 180,360 360,1260 1530,1860
have to write programs that

532
00:15:56,710 --> 00:15:58,120
0,150 150,330 330,660 660,1050 1110,1410
use your operating system,| we'd
|所以我们希望它也是一个正确的高层次抽象。

533
00:15:58,120 --> 00:15:59,380
0,210 210,360 360,750 750,870 870,1260
like it also to be

534
00:15:59,590 --> 00:16:02,360
0,450 630,960 960,1500 1500,2430
a right abstract high-level.|
|

535
00:16:02,660 --> 00:16:04,430
0,240 270,690 690,1380 1440,1650 1650,1770
A portable interfaces| and it's
一个可移植的接口，|提供简单的抽象接口需要巧妙的技巧，

536
00:16:04,430 --> 00:16:05,690
0,30 30,240 240,570 570,660 660,1260
a neat trick to provide

537
00:16:05,720 --> 00:16:07,310
0,360 390,870 870,1380 1380,1530 1530,1590
a abstract interfaces that are

538
00:16:07,310 --> 00:16:08,240
0,600
simple.|
|

539
00:16:08,320 --> 00:16:09,880
0,390 420,1110 1260,1410 1410,1470 1470,1560
A portable but they are
便携的但也是高效的。

540
00:16:09,880 --> 00:16:11,320
0,300 300,900
also efficient.|
|

541
00:16:11,910 --> 00:16:14,220
0,390 690,990 990,1620 1860,2040 2040,2310
{} Another tension is| that
另一个矛盾是，|

542
00:16:14,370 --> 00:16:15,600
0,180 180,360 360,450 450,1110 1140,1230
we'd like to provide a
我们要提供一个非常强大的操作系统服务，

543
00:16:15,600 --> 00:16:18,240
0,240 240,1290 1350,1800 1800,2070 2070,2640
very powerful operating system services,|

544
00:16:18,240 --> 00:16:19,590
0,150 150,360 540,660 660,960 960,1350
so that the operating system
让操作系统可以承担很多责任。

545
00:16:19,590 --> 00:16:20,610
0,150 150,600 600,690 690,930 930,1020
can shoulder a lot of

546
00:16:20,610 --> 00:16:21,580
0,90 90,660
the burden.|

547
00:16:21,680 --> 00:16:24,680
0,630 1170,1650 1680,2070 2070,2820 2820,3000
{} {} Running programs like
运行程序像强大的操作系统服务。

548
00:16:24,680 --> 00:16:26,000
0,90 90,1020
a powerful

549
00:16:26,070 --> 00:16:27,920
0,510 510,840 840,1680
operating system services.|
|

550
00:16:28,630 --> 00:16:30,460
0,450 810,1410
{} But,
但是，我们也希望有简单的接口。

551
00:16:30,860 --> 00:16:31,640
0,270 270,480 480,600 600,660 660,780
we also want to have

552
00:16:31,640 --> 00:16:33,120
0,330 330,1320
simple interfaces,|
|

553
00:16:34,770 --> 00:16:36,150
0,420 450,690 690,810 810,1020 1020,1380
{} that we don't want
我们不想让程序员使用一个非常复杂、难以理解的接口，

554
00:16:36,510 --> 00:16:38,400
0,420 450,990 990,1620 1620,1830 1830,1890
a tremendously complex hard to

555
00:16:38,400 --> 00:16:40,290
0,480 480,1080 1080,1260 1260,1770 1770,1890
understand interfaces for programmers to

556
00:16:40,290 --> 00:16:42,000
0,270 270,750 1230,1500 1500,1590 1590,1710
use,| because I'm not going
|因为我也不会去理解它们，

557
00:16:42,000 --> 00:16:43,020
0,60 60,510 510,600 600,720 720,1020
to understand them,| and they
|他们会发现它很难使用，

558
00:16:43,050 --> 00:16:43,950
0,240 240,450 450,540 540,780 780,900
may find it hard to

559
00:16:43,950 --> 00:16:45,080
0,660
use,|

560
00:16:45,790 --> 00:16:47,380
0,570 1050,1200 1200,1320 1320,1380 1380,1590
{} so this is really
所以这是一个很简单的 API ，

561
00:16:47,380 --> 00:16:49,210
0,360 360,1020 1020,1170 1170,1440 1530,1830
simple API,| and so this
|所以可以提供一个简单的接口，

562
00:16:49,210 --> 00:16:50,590
0,180 180,660 660,720 720,1200 1230,1380
is possible to do to

563
00:16:50,590 --> 00:16:53,290
0,600 630,840 840,1680 1710,2580 2580,2700
provide a simple interfaces,| that
并在内部拥有强大机制，

564
00:16:53,290 --> 00:16:56,290
0,150 150,1170 1260,1860 1890,2460 2460,3000
have powerful a machinery inside

565
00:16:56,290 --> 00:16:57,850
0,420 540,690 690,990 990,1110 1110,1560
them,| will always be searching
|这一直在寻找。

566
00:16:57,850 --> 00:16:58,500
0,360
for.|
|

567
00:16:58,700 --> 00:17:01,790
0,210 210,270 270,690 690,1290 2250,3090
Sort of simple interfaces provide
简单的接口提供强大的服务，

568
00:17:02,330 --> 00:17:05,420
0,330 360,1140 1140,2010 2430,2670 2670,3090
a powerful services.| Hey, Robbery,
|嘿， Robert ，有人提问。

569
00:17:05,420 --> 00:17:06,380
0,60 60,240 240,720 720,840 840,960
{we've,got} a question in the

570
00:17:06,380 --> 00:17:07,200
0,480
chat.|
|

571
00:17:07,280 --> 00:17:08,840
0,360 360,690 690,810 810,1260 1260,1560
{} What is unique slash
系统调用跳入内核有什么特别之处，

572
00:17:08,840 --> 00:17:10,580
0,420 420,750 750,990 990,1380 1380,1740
different about saying system calls

573
00:17:10,580 --> 00:17:12,200
0,270 270,450 450,540 540,1020 1020,1620
jump into the kernel,| i.e
|与跳转到另一个函数的标准函数调用相比。

574
00:17:12,200 --> 00:17:13,340
0,120 120,570 570,660 660,720 720,1140
as opposed to a standard

575
00:17:13,340 --> 00:17:14,480
0,360 360,630 630,750 750,1050 1050,1140
function call that jumps to

576
00:17:14,480 --> 00:17:15,540
0,270 270,750
another function.|
|

577
00:17:15,660 --> 00:17:16,340
0,330

578
00:17:18,100 --> 00:17:19,630
0,450 450,750 750,1020 1020,1380 1410,1530
Well, the kernel has, the
好的，内核是一段始终驻留的代码，

579
00:17:19,630 --> 00:17:21,500
0,390 390,750 780,1590
kernel is, {}

580
00:17:21,950 --> 00:17:22,670
0,180 180,360 360,420 420,600 600,720
a piece of code that's

581
00:17:22,670 --> 00:17:24,800
0,420 420,1170 1170,1350 1350,1620 1620,2130
always resident,| that has special
|它具有特权，

582
00:17:24,800 --> 00:17:26,780
0,930 960,1200 1200,1470 1500,1740 1740,1980
privileges| that were that because
|因为内核在机器启动时加载，

583
00:17:26,780 --> 00:17:29,000
0,120 120,780 840,1260 1560,1950 1950,2220
it booted the machine booted

584
00:17:29,000 --> 00:17:31,250
0,60 60,630 1020,1680 1770,2130 2130,2250
the kernel,| {} kernel has
|内核具有特权，

585
00:17:31,250 --> 00:17:33,080
0,600 630,1350 1350,1440 1440,1560 1560,1830
special privileges,| it can get
|它可以直接访问各种硬件，

586
00:17:33,080 --> 00:17:34,760
0,510 510,900 1200,1380 1380,1620 1620,1680
directly at all kinds of

587
00:17:34,760 --> 00:17:36,770
0,540 540,840 870,990 990,1260 1260,2010
hardware,| like the disk device
|比如磁盘，普通用户程序不能访问，

588
00:17:36,860 --> 00:17:38,570
0,240 240,690 690,900 900,1410 1410,1710
that ordinary user programs can't

589
00:17:38,570 --> 00:17:39,650
0,150 150,450 780,930 930,990 990,1080
get at,| so if you
|所以如果你执行一个普通函数调用，

590
00:17:39,650 --> 00:17:41,210
0,150 150,360 360,630 630,1110 1110,1560
make a an ordinary function

591
00:17:41,210 --> 00:17:42,100
0,570
call,|
|

592
00:17:42,160 --> 00:17:43,060
0,600

593
00:17:43,920 --> 00:17:45,570
0,660 750,1080 1080,1170 1170,1440 1440,1650
the function your calling doesn't
你调用的函数没有任何关于硬件的特权，

594
00:17:45,570 --> 00:17:46,950
0,330 420,870 870,1080 1080,1230 1230,1380
get it doesn't get any

595
00:17:46,950 --> 00:17:48,660
0,390 390,1080 1080,1260 1260,1650 1650,1710
special privileges with respect to

596
00:17:48,660 --> 00:17:49,920
0,60 60,660 870,1110 1110,1170 1170,1260
the hardware,| whereas if you
|而你在内核执行系统调用，

597
00:17:49,920 --> 00:17:50,820
0,150 150,180 180,540 540,780 780,900
make a system call into

598
00:17:50,820 --> 00:17:53,400
0,90 90,690 1800,2220 2220,2400 2400,2580
the kernel,| we'll talk about
|后面我们会详细讨论这是如何工作的，

599
00:17:53,400 --> 00:17:54,630
0,120 120,270 270,600 600,840 930,1230
how this works,| but that
|这就像当系统调用跳到内核时，

600
00:17:54,630 --> 00:17:57,000
0,270 270,690 1710,2010 2010,2250 2250,2370
ends up as when it

601
00:17:57,000 --> 00:17:58,110
0,330 330,510 510,720 720,780 780,1110
jumps into when the system

602
00:17:58,110 --> 00:17:59,340
0,180 180,480 480,600 600,690 690,1230
call jumps into the kernel,|

603
00:17:59,730 --> 00:18:01,560
0,330 360,750 750,1110 1110,1770 1770,1830
{} system call implementation in
然后内核中的系统调用实现获得所有这些特权，

604
00:18:01,560 --> 00:18:02,520
0,90 90,360 360,570 570,780 780,960
the kernel then gets all

605
00:18:02,520 --> 00:18:04,080
0,150 150,510 510,1050 1050,1200 1200,1560
these special privileges,| so that
这样它就可以修改各种敏感的受保护的硬件资源，

606
00:18:04,170 --> 00:18:06,960
0,240 240,1080 1440,2190 2190,2370 2370,2790
it can modify all kinds

607
00:18:06,960 --> 00:18:09,440
0,600 630,1290 1290,1440 1440,2160
of sensitive and protected

608
00:18:09,730 --> 00:18:11,770
0,540 630,1110 1110,1740 1740,1950 1950,2040
{} hardware resources,| like for
|比如直接访问硬盘，

609
00:18:11,770 --> 00:18:13,240
0,360 360,570 570,960 960,1140 1140,1470
example getting directly at the

610
00:18:13,360 --> 00:18:14,320
0,330 330,780
hard disk.|
|

611
00:18:15,730 --> 00:18:16,630
0,330 360,540 540,630 630,720 720,900
{} We'll see a lot
我们稍后会看到更多关于这些的细节。

612
00:18:16,630 --> 00:18:17,890
0,120 120,480 480,660 660,810 810,1260
more detail for all this

613
00:18:18,220 --> 00:18:19,020
0,480
shortly.|
|

614
00:18:20,330 --> 00:18:22,070
0,330 330,810 870,1020 1020,1320 1320,1740
Okay, so a final tension
好的，我们要说的最后一个矛盾是，

615
00:18:22,070 --> 00:18:23,510
0,120 120,240 240,600 600,840 1080,1440
that we want| that all
|所有操作系统都需要满足你的需求，

616
00:18:23,510 --> 00:18:25,070
0,300 300,660 660,780 780,870 870,1560
operating systems need to satisfy

617
00:18:25,130 --> 00:18:26,000
0,180 180,300 300,450 450,780 780,870
your gonna give programs,| as
|尽可能的灵活，

618
00:18:26,000 --> 00:18:27,560
0,180 180,1050 1080,1230 1230,1350 1350,1560
much flexibility as you can,|
|

619
00:18:27,560 --> 00:18:28,460
0,90 90,180 180,300 300,390 390,900
you don't want to constrain
你不想限制它们，

620
00:18:28,460 --> 00:18:29,330
0,300 510,630 630,690 690,810 810,870
them,| so you want to
|所以你想要很灵活的接口。

621
00:18:29,330 --> 00:18:30,680
0,90 90,270 270,1050
have very flexible

622
00:18:30,740 --> 00:18:31,760
0,780

623
00:18:33,060 --> 00:18:34,680
0,690 690,990 1050,1290 1290,1440 1440,1620
interfaces.| But you do need
|但是确实需要在一定程度上约束程序，

624
00:18:34,680 --> 00:18:36,000
0,60 60,420 420,720 720,1020 1020,1320
to constrain program somewhat,| because
|因为你必须有一些安全概念。

625
00:18:36,030 --> 00:18:37,200
0,240 240,630 630,870 870,930 930,1170
you absolutely have to have

626
00:18:37,200 --> 00:18:38,740
0,180 180,510 510,600 600,1230
some notion of security.|
|

627
00:18:38,880 --> 00:18:40,520
0,600 900,1380

628
00:18:41,770 --> 00:18:44,170
0,480 480,720 720,990 990,1710 1800,2400
We love for programs programs
我们喜欢编程，编程很自由，

629
00:18:44,170 --> 00:18:45,100
0,360 360,600 600,690 690,750 750,930
complete freedom,| but it can't
|但它不能是完全自由的，

630
00:18:45,100 --> 00:18:46,150
0,90 90,540 540,720 720,810 810,1050
be complete can't be really

631
00:18:46,150 --> 00:18:48,130
0,480 720,1320 1470,1680 1680,1800 1800,1980
complete,| because we don't want
|因为我们不想让程序直接访问硬件，

632
00:18:48,130 --> 00:18:49,210
0,360 360,420 420,540 540,930 930,1080
programs to get directly at

633
00:18:49,210 --> 00:18:50,470
0,60 60,630 630,750 750,840 840,1260
the hardware| or to interfere
|或者干扰其他程序，

634
00:18:50,470 --> 00:18:52,330
0,150 150,330 330,1020 1020,1290 1320,1860
with other programs| or a
|或者在某种程度上干扰操作系统本身的操作。

635
00:18:53,170 --> 00:18:53,830
0,240 240,300 300,420 420,600 600,660
sort of be able to

636
00:18:53,830 --> 00:18:55,090
0,390 390,480 480,600 600,1110 1110,1260
interfere with the operation of

637
00:18:55,090 --> 00:18:57,140
0,270 510,990 990,1290 1290,1740
the operating system itself.|
|

638
00:18:57,360 --> 00:18:59,370
0,390 780,1050 1050,1260 1260,1440 1440,2010
{} So, these are all
这就是你们需要知道的。

639
00:18:59,490 --> 00:19:00,820
0,780 780,1050
you know.|
|

640
00:19:01,490 --> 00:19:02,330
0,210 210,600 600,660 660,780 780,840
It's possible to do a
做好这项工作是可能的，

641
00:19:02,330 --> 00:19:03,260
0,150 150,480 480,600 600,720 720,930
good job| and we'll talk
|我们将对此进行大量讨论，

642
00:19:03,260 --> 00:19:04,100
0,60 60,210 210,450 450,600 600,840
a lot about it,| but
|但这总是令人费解，

643
00:19:04,430 --> 00:19:05,030
0,180 180,390 390,420 420,540 540,600
it's always a bit of

644
00:19:05,030 --> 00:19:06,050
0,90 90,420 420,480 480,900 900,1020
a puzzle| to provide sort
|在这两列中同时提供这两个属性。

645
00:19:06,050 --> 00:19:08,930
0,90 90,480 480,570 570,1350 2280,2880
of both of these properties

646
00:19:08,930 --> 00:19:10,100
0,60 60,270 270,360 360,510 510,1170
in both of these columns.|
|

647
00:19:11,630 --> 00:19:13,190
0,540 540,690 690,780 780,1170 1260,1560
Another thing that makes OS
另一个让操作系统设计变得困难和有趣的是，

648
00:19:13,190 --> 00:19:14,390
0,330 330,540 540,630 630,1080 1080,1200
design hard and interesting is|
|

649
00:19:14,390 --> 00:19:16,100
0,210 540,870 870,1380 1380,1650 1650,1710
that operating systems provide a
操作系统提供了很多功能和服务，

650
00:19:16,100 --> 00:19:16,850
0,210 210,270 270,630 630,720 720,750
lot of features and a

651
00:19:16,850 --> 00:19:18,080
0,180 180,270 270,840 840,1110 1110,1230
lot of services,| but they
|但它们实际上倾向于交互，

652
00:19:18,080 --> 00:19:20,510
0,270 270,540 540,630 630,1440 1830,2430
actually tend to interact| and
|而且有时以奇怪的方式进行交互，

653
00:19:20,510 --> 00:19:21,770
0,390 390,480 480,750 750,1140 1140,1260
sometimes in odd ways| that
|这需要很多思考，

654
00:19:21,770 --> 00:19:22,760
0,330 330,390 390,570 570,630 630,990
require a lot of thought,|
|

655
00:19:22,760 --> 00:19:24,440
0,270 360,780 780,930 930,1230 1230,1680
so even the simple examples
即使是我给出的简单示例。

656
00:19:24,440 --> 00:19:25,960
0,60 60,660 690,1260
I gave {}.|
|

657
00:19:26,640 --> 00:19:27,780
0,240 240,390 390,630 630,810 810,1140
{} With open and fork,
使用 open 和 fork ，这两个交互，

658
00:19:27,780 --> 00:19:29,280
0,270 270,540 540,1080 1080,1410 1410,1500
those two interact actually| if
|如果一个程序使用 open 系统调用分配文件描述符，

659
00:19:29,280 --> 00:19:31,120
0,90 90,720 900,1530
a program {}

660
00:19:31,310 --> 00:19:32,840
0,480 480,540 540,810 810,1380 1380,1530
allocates a file descriptor with

661
00:19:32,840 --> 00:19:34,940
0,90 90,450 450,840 840,1380 1860,2100
the open system call,| and
|然后使用 fork 分配相同的程序。

662
00:19:34,940 --> 00:19:36,680
0,210 210,420 420,690 690,1500
then that same program

663
00:19:36,780 --> 00:19:38,760
0,630 840,1860
{} fork.|
|

664
00:19:39,610 --> 00:19:40,810
0,450 480,630 630,720 720,1110 1110,1200
{} And the semantics of
fork 的语义是，

665
00:19:40,810 --> 00:19:41,890
0,480 480,660 660,870 870,990 990,1080
fork just turned out to

666
00:19:41,890 --> 00:19:43,000
0,150 150,450 540,870 870,1080 1080,1110
be| that you create a
|你创建一个新进程，它是当前进程的副本，

667
00:19:43,000 --> 00:19:44,530
0,120 120,660 660,870 870,1050 1050,1530
new process that's a copy

668
00:19:44,530 --> 00:19:46,180
0,90 90,210 210,480 480,1050 1200,1650
of the current process,| this
|你打开的这个文件描述符，

669
00:19:46,180 --> 00:19:48,820
0,360 360,810 810,990 990,1650
file descriptor you opened,|
|

670
00:19:49,640 --> 00:19:50,840
0,330 330,660 660,990 990,1080 1080,1200
if that's truly to be
实际上是一个副本，

671
00:19:50,840 --> 00:19:52,040
0,90 90,450 450,600 600,810 810,1200
a copy,| this file descriptor
|这个文件描述符仍然在子进程中存在并可用,

672
00:19:52,040 --> 00:19:54,080
0,270 270,660 660,900 930,1620 1620,2040
still has to be present

673
00:19:54,080 --> 00:19:55,550
0,120 120,510 510,630 630,720 720,1470
and usable in the child,|
|

674
00:19:56,240 --> 00:19:56,920
0,360

675
00:19:57,320 --> 00:19:57,980
0,210 210,330 330,420 420,570 570,660
and so that has to
所以必须仔细考虑，

676
00:19:57,980 --> 00:19:58,940
0,120 120,390 390,630 630,840 840,960
be thought,| through that is
|这就是文件，

677
00:19:58,940 --> 00:20:00,380
0,180 180,720 720,810 810,1200 1200,1440
the files,| the opened file
|打开的文件描述符以这种方式与 fork 交互，

678
00:20:00,380 --> 00:20:01,820
0,510 510,960 960,1080 1080,1380 1380,1440
descriptors interact with fork in

679
00:20:01,820 --> 00:20:04,310
0,150 150,570 570,1020 1410,1890 2070,2490
this interesting way| and somebody
|必须找到让子进程能读取到

680
00:20:04,310 --> 00:20:05,780
0,150 150,240 240,540 540,900 1200,1470
has to figure out {}

681
00:20:05,780 --> 00:20:06,650
0,180 180,240 240,600 600,690 690,870
should the child be able

682
00:20:06,650 --> 00:20:07,900
0,240 300,540 540,930
to get at,|
|

683
00:20:07,960 --> 00:20:10,000
0,120 120,390 390,900 900,1620 1620,2040
the file descriptors created before
fork 调用之前创建的文件描述符，

684
00:20:10,000 --> 00:20:11,140
0,270 270,360 360,690 930,1080 1080,1140
fork is called| and the
|答案是肯定的，

685
00:20:11,140 --> 00:20:12,340
0,210 210,420 420,510 510,600 600,1200
answer has to be yes,|
|

686
00:20:12,580 --> 00:20:13,630
0,180 180,480 480,840 840,930 930,1050
the operating systems we're going
这就是我们要看的操作系统。

687
00:20:13,630 --> 00:20:14,500
0,60 60,270 270,540
to look at.|
|

688
00:20:14,620 --> 00:20:15,500
0,420

689
00:20:17,070 --> 00:20:18,390
0,420 420,660 810,960 960,1110 1110,1320
Alright and so other things
好的，其他有趣的事情我已经提过了，

690
00:20:18,390 --> 00:20:19,320
0,120 120,540 570,780 780,870 870,930
that are turned out to

691
00:20:19,320 --> 00:20:21,210
0,90 90,810 810,1230 1230,1470 1470,1890
be interesting I already mentioned,|
|

692
00:20:21,210 --> 00:20:22,860
0,300 420,870 870,1350 1350,1530 1530,1650
that operating systems have to
操作系统必须满足各种各样的用途，

693
00:20:22,860 --> 00:20:24,090
0,330 330,480 480,600 600,870 870,1230
cater to a wide variety

694
00:20:24,090 --> 00:20:26,250
0,90 90,990 1020,1140 1140,1410 1410,2160
of uses,| the same OS
|同样的操作系统适用于数据库服务器和智能手机，

695
00:20:26,280 --> 00:20:28,620
0,300 300,600 600,1020 1080,1830 1830,2340
used both for database servers

696
00:20:28,620 --> 00:20:31,890
0,510 510,1200 1200,1320 1320,1920 2880,3270
and smartphones, for example.| And
|而且操作系统，随着时间的推移，

697
00:20:31,890 --> 00:20:33,280
0,390 390,1170
operating systems,

698
00:20:33,410 --> 00:20:35,240
0,270 270,510 510,780 780,990 990,1830
{} as time goes on,|
|

699
00:20:35,270 --> 00:20:37,280
0,270 270,1080 1080,1230 1230,1350 1350,2010
the hardware that you run
你运行的硬件，得到的硬件，

700
00:20:37,490 --> 00:20:38,780
0,450 450,600 600,870 870,1020 1020,1290
hardware, you get,| but typical
|普通的计算机会发生变化，

701
00:20:38,780 --> 00:20:41,720
0,510 510,1350 1620,1980 1980,2160 2160,2940
computers changes,| maybe get superfast
|可能使用超高速的固态硬盘存储替代机械硬盘。

702
00:20:41,720 --> 00:20:43,670
0,480 480,1080 1080,1410 1410,1470 1470,1950
ssd storage instead of mechanical

703
00:20:43,670 --> 00:20:45,280
0,270 270,600 600,690 690,1260
hard drive, for example.|
|

704
00:20:45,360 --> 00:20:47,010
0,270 270,510 510,930 930,1140 1140,1650
And about fifteen years ago,|
大概十五年前，|

705
00:20:47,070 --> 00:20:49,290
0,540 540,750 750,1650 1680,2070 2070,2220
multi core computers went from
多核计算机从稀有发展到无处不在，

706
00:20:49,290 --> 00:20:51,870
0,510 660,1080 1080,1980 1980,2100 2100,2580
being rare curiosities to being

707
00:20:51,900 --> 00:20:55,260
0,750 2130,2610 2610,2850 2850,3180 3180,3360
pervasive| and and recently we've
|最近我们看到了数量级的提速，

708
00:20:55,260 --> 00:20:57,360
0,600 600,900 900,960 960,1440 1440,2100
seen order of magnitude speedups|
|

709
00:20:57,360 --> 00:20:58,890
0,180 180,330 330,660 660,1080 1080,1530
and how fast networks operate|
和网络操作速度，|

710
00:20:59,190 --> 00:21:00,240
0,120 120,240 240,360 360,570 570,1050
and so all these require
所以这些都需要重新思考。

711
00:21:00,240 --> 00:21:01,340
0,870
rethinks.|
|

712
00:21:01,440 --> 00:21:03,900
0,660 1200,1530 1530,2190 2190,2250 2250,2460
{} {} Periodically of how
定期介绍操作系统是如何设计的。

713
00:21:03,900 --> 00:21:05,560
0,330 330,750 750,810 810,1320
operating systems are designed.|
|

714
00:21:06,510 --> 00:21:10,200
0,480 840,1530 2940,3090 3090,3540 3540,3690
Now so so those are
这些就是你可能选择这门课的原因。

715
00:21:10,200 --> 00:21:11,490
0,240 240,300 300,510 510,660 720,1290
those are sort of intellectually

716
00:21:11,490 --> 00:21:12,150
0,180 180,270 270,420 420,600 600,660
why you might take the

717
00:21:12,150 --> 00:21:13,470
0,360 360,510 510,750 750,1050 1050,1320
course,| there's also some more
|还有一些更实际的原因，

718
00:21:13,470 --> 00:21:15,060
0,540 540,930 930,1170 1170,1410 1410,1590
practical reasons,| why you might
|你选择这门课的原因，

719
00:21:15,060 --> 00:21:16,800
0,90 90,720 750,1170 1260,1440 1440,1740
be glad to have taken

720
00:21:16,800 --> 00:21:18,690
0,150 150,660 780,1170 1170,1500 1740,1890
this course,| one is if
|一个是如果你对计算机内部发生的事情感兴趣，

721
00:21:18,690 --> 00:21:19,860
0,150 150,480 480,540 540,690 690,1170
you're interested in what happens

722
00:21:19,860 --> 00:21:21,510
0,360 360,870 870,990 990,1170 1170,1650
inside computers,| what goes on
|想知道并探寻计算机内部的秘密，

723
00:21:21,540 --> 00:21:23,010
0,270 270,480 480,810 810,870 870,1470
and saw under the hood

724
00:21:23,340 --> 00:21:24,390
0,330 330,510 510,570 570,660 660,1050
a sort of in secret,|
|

725
00:21:24,390 --> 00:21:25,020
0,150 150,270 270,420 420,540 540,630
when you turn on your
当你打开计算机时，

726
00:21:25,020 --> 00:21:26,220
0,630 690,900 900,1050 1050,1110 1110,1200
computer,| {} this is a
|这是一个很好的课程，

727
00:21:26,220 --> 00:21:28,080
0,180 180,450 450,570 570,900 1290,1860
good course to take,| similarly
|类似地，如果你喜欢基础设施，

728
00:21:28,080 --> 00:21:29,430
0,120 120,240 240,450 450,1170 1170,1350
if you like infrastructure| that
|也就是如果你喜欢建立一种服务，

729
00:21:29,430 --> 00:21:30,780
0,150 150,390 480,720 720,840 840,1350
is if if you enjoy

730
00:21:30,780 --> 00:21:33,240
0,720 990,1440 1440,1590 1590,1680 1680,2460
building a sort of services|
|

731
00:21:33,240 --> 00:21:34,680
0,270 300,660 660,1110 1110,1230 1230,1440
that other programs can then
其他程序可以使用的服务。

732
00:21:34,680 --> 00:21:36,160
0,690 750,1230
use them.|
|

733
00:21:36,510 --> 00:21:37,680
0,180 180,420 420,540 540,810 810,1170
This is of course essentially
当然，这基本上都是关于基础设施的，

734
00:21:37,680 --> 00:21:39,630
0,180 180,480 480,1140 1140,1500 1590,1950
all about infrastructure,| because that's
|因为这就是操作系统。

735
00:21:39,660 --> 00:21:41,070
0,210 210,360 360,630 630,1050 1050,1410
that's what operating systems are.|
|

736
00:21:42,350 --> 00:21:43,250
0,300 300,450 450,630 630,810 810,900
If you ever need to
如果你曾经花费大量时间来跟踪应用程序代码中的 bug ，

737
00:21:43,250 --> 00:21:44,000
0,240 240,270 270,420 420,480 480,750
spend a lot of time

738
00:21:44,000 --> 00:21:46,160
0,330 330,540 540,1260 1260,1560 1560,2160
tracking down bugs in application

739
00:21:46,160 --> 00:21:47,870
0,510 540,780 780,1050 1050,1230 1230,1710
code| or tracking down security
|或跟踪安全问题，

740
00:21:47,870 --> 00:21:51,440
0,630 960,1410 1410,2250 2310,3060 3060,3570
problems| often that involves understanding
|通常会设计到了解操作系统内部发生了什么，

741
00:21:51,440 --> 00:21:52,490
0,180 180,300 300,570 570,720 720,1050
what was going on inside

742
00:21:52,490 --> 00:21:54,020
0,120 120,510 510,870 960,1410 1410,1530
the operating system,| because it's
|因为最终是操作系统实施了很多安全措施，

743
00:21:54,020 --> 00:21:55,880
0,420 420,540 540,870 870,1260 1260,1860
ultimately the operating system that

744
00:21:56,180 --> 00:21:57,710
0,510 510,570 570,750 750,840 840,1530
enforces a lot of security,|
|

745
00:21:57,710 --> 00:22:00,020
0,540 870,1500 1500,1740 1740,1920 1920,2310
and when things go wrong,|
当事情发生错误时，|

746
00:22:00,020 --> 00:22:01,190
0,120 120,330 330,690 690,990 990,1170
it's the operating system has
操作系统必须收拾残局，

747
00:22:01,190 --> 00:22:02,090
0,120 120,300 300,420 420,510 510,900
to pick up the pieces,|
|

748
00:22:02,090 --> 00:22:04,310
0,300 390,720 720,1080 1080,1740 1740,2220
so that's often involved in
通常设计到跟踪 bug ，然后最终。

749
00:22:04,730 --> 00:22:06,950
0,450 450,690 690,1260 1500,1650 1650,2220
tracking down bugs and finally.|
|

750
00:22:08,000 --> 00:22:09,050
0,210 210,390 390,810 810,960 960,1050
Two more questions from the
在聊天中有两个问题，

751
00:22:09,050 --> 00:22:10,580
0,390 390,840 930,1140 1140,1410 1410,1530
chat,| so the first is|
|第一个是，|

752
00:22:10,580 --> 00:22:11,510
0,240 240,630 630,720 720,810 810,930
how important is it for
对于应用程序开发人员来说，

753
00:22:11,510 --> 00:22:13,490
0,480 480,1110 1110,1230 1230,1590 1590,1980
application developers,| to truly deeply
|真正深入理解开发应用程序的操作系统有多重要，

754
00:22:13,490 --> 00:22:15,110
0,600 600,690 690,1080 1080,1560 1560,1620
understand the operating systems of

755
00:22:15,110 --> 00:22:17,180
0,450 450,600 600,1230 1230,1620 1950,2070
developing their applications for,| do
|它们是否需要称为专家。

756
00:22:17,180 --> 00:22:18,320
0,120 120,720 720,930 930,990 990,1140
they necessarily need to be

757
00:22:18,320 --> 00:22:19,420
0,780
experts.|
|

758
00:22:19,810 --> 00:22:20,680
0,360 360,510 510,690 690,780 780,870
You don't have to be
你不需要成为专家，

759
00:22:20,680 --> 00:22:21,820
0,90 90,690 690,900 900,1020 1020,1140
an expert,| but if you
|但是如果你花费大量时间

760
00:22:21,820 --> 00:22:23,830
0,660 720,1320 1350,1650 1650,1710 1710,2010
spend a lot of time|

761
00:22:23,830 --> 00:22:25,750
0,570 570,930 930,1470 1470,1560 1560,1920
developing and maintaining and debugging
开发、维护和调试应用程序，

762
00:22:25,750 --> 00:22:28,570
0,840 900,1230 1230,2010 2550,2730 2730,2820
applications,| you'll eventually end up
|你最终会对操作系统有很多了解，

763
00:22:28,570 --> 00:22:29,410
0,270 270,330 330,510 510,720 720,840
knowing a lot about the

764
00:22:29,410 --> 00:22:31,420
0,360 360,750 750,1170 1170,1710
operating system,| whether you,
|无论你是有意或无意，

765
00:22:31,520 --> 00:22:32,240
0,180 180,300 300,510 510,630 630,720
whether you meant to or

766
00:22:32,240 --> 00:22:33,240
0,330 330,780
not,| just
它就出现了，而且你经常被迫理解它。

767
00:22:34,140 --> 00:22:36,000
0,150 150,360 360,600 600,1110 1170,1860
it just comes up and

768
00:22:36,030 --> 00:22:37,530
0,150 150,360 360,690 690,750 750,1500
you're often forced to understand.|
|

769
00:22:38,100 --> 00:22:38,900
0,450

770
00:22:39,640 --> 00:22:41,080
0,330 330,450 450,780 780,1140 1140,1440
And the second question is,|
第二个问题是，|

771
00:22:41,080 --> 00:22:43,030
0,210 210,690 690,1170 1170,1680 1680,1950
do high-level programming languages like
像 Python 这样的高级编程语言是否直接使用系统调用，

772
00:22:43,030 --> 00:22:45,310
0,690 960,1200 1200,1500 1500,1740 1740,2280
python use system calls directly,|

773
00:22:45,310 --> 00:22:46,810
0,240 240,420 420,720 720,1050 1050,1500
are there built in slash
是否为了方便编写了内置的包装器。

774
00:22:46,810 --> 00:22:48,340
0,510 510,660 660,1350
wrappers for convenience.|
|

775
00:22:48,710 --> 00:22:49,910
0,120 120,300 300,360 360,720 720,1200
A lot of high-level languages
很多高级语言在某种程度上是从操作系统中转移出来的，

776
00:22:49,910 --> 00:22:51,230
0,420 630,840 840,900 900,990 990,1320
are sort of at one

777
00:22:51,230 --> 00:22:53,750
0,690 690,990 990,1410 1410,2130 2310,2520
{of,move} from system calls,| that's
|这是正确的。

778
00:22:53,750 --> 00:22:56,360
0,390 390,750 750,1170 1560,2310
absolutely true.| So {},
|所以，部分原因是许多语言想要提供可移植的环境，

779
00:22:56,600 --> 00:22:58,550
0,270 270,630 630,1290 1650,1770 1770,1950
but partially because a lot

780
00:22:58,550 --> 00:23:00,320
0,90 90,750 780,990 990,1050 1050,1770
of languages want to provide

781
00:23:00,350 --> 00:23:02,900
0,1020 1260,1410 1410,1830 1830,2430 2430,2550
portable a portable environment,| that
|可以运行在许多不同的操作系统上，

782
00:23:02,900 --> 00:23:04,040
0,210 210,270 270,510 510,810 810,1140
works on many different operating

783
00:23:04,040 --> 00:23:05,300
0,390 390,450 450,540 540,720 720,1260
systems,| so they can't necessarily
|因此它们不一定要致力于任何一种操作系统的特定系统调用，

784
00:23:05,300 --> 00:23:07,280
0,480 690,930 930,1050 1050,1650 1650,1980
commit to the specific system

785
00:23:07,280 --> 00:23:08,840
0,390 390,570 600,810 810,1110 1110,1560
calls or any one operating

786
00:23:08,840 --> 00:23:09,580
0,450
system.|
|

787
00:23:09,980 --> 00:23:12,410
0,510 1380,1560 1560,1830 1830,2040 2040,2430
{} So, {} the answer,|
所以答案是，|

788
00:23:12,410 --> 00:23:13,280
0,60 60,420 420,510 510,660 660,870
the question I think is|
我想问题的答案是，|

789
00:23:13,280 --> 00:23:14,810
0,120 120,210 210,360 360,1290 1320,1530
if you use python {},|
如果你使用 Python ，|

790
00:23:14,810 --> 00:23:16,460
0,150 150,540 540,1410
you're somewhat insulated
你多少与系统调用接口有些隔离。

791
00:23:16,570 --> 00:23:18,190
0,480 480,810 810,1110 1110,1380 1380,1620
from {} the system call

792
00:23:18,190 --> 00:23:19,420
0,600 600,660 660,750 750,1170 1170,1230
interface,| you know internally of
|Python 内部当然会做，

793
00:23:19,420 --> 00:23:20,760
0,210 210,600 600,1110
course python makes,|
|

794
00:23:20,900 --> 00:23:21,830
0,210 210,270 270,390 390,660 660,930
has to make system calls
调用系统调用来完成它的工作。

795
00:23:21,830 --> 00:23:23,360
0,150 150,270 270,540 540,900 1230,1530
get its work done {}.|
|

796
00:23:23,360 --> 00:23:24,340
0,690
And,
当然，在 Python 和许多其他语言中，

797
00:23:24,520 --> 00:23:25,720
0,300 300,390 390,810 810,990 990,1200
certainly in python and many

798
00:23:25,720 --> 00:23:27,100
0,180 180,660 660,960 960,1080 1080,1380
other languages,| there is usually
|通常有一种方法可以直接进入系统调用，

799
00:23:27,100 --> 00:23:28,510
0,90 90,300 300,390 390,720 900,1410
a way to get directly

800
00:23:28,510 --> 00:23:29,840
0,510
at

801
00:23:29,990 --> 00:23:31,400
0,150 150,450 450,750 750,1110 1110,1410
the system calls| whatever your
|无论你使用什么操作系统。

802
00:23:31,610 --> 00:23:33,770
0,360 360,720 720,1500 1620,1980 1980,2160
operating system, you're running on.|
|

803
00:23:35,480 --> 00:23:36,890
0,210 210,510 510,660 660,1260 1260,1410
And folks for questions,| you
想提问的各位同学，|你可以自己提问，

804
00:23:36,890 --> 00:23:37,700
0,120 120,390 390,570 570,720 720,810
can just feel free to

805
00:23:37,700 --> 00:23:38,720
0,240 240,330 330,750 750,840 840,1020
jump in yourself and ask

806
00:23:38,720 --> 00:23:39,500
0,330 330,420 420,540 540,690 690,780
questions,| you don't need to
|不一定需要通过聊天提出问题。

807
00:23:39,500 --> 00:23:40,880
0,150 150,300 300,390 390,750
go through the chat.|
|

808
00:23:43,410 --> 00:23:45,260
0,540 570,1140
Okay {}.|
好的。|

809
00:23:46,020 --> 00:23:48,540
0,660 720,1410
Alright, sorry,
好的，抱歉，现在我要花几分钟，

810
00:23:49,510 --> 00:23:51,400
0,720 1140,1380 1380,1440 1440,1650 1650,1890
I'm going to spend a

811
00:23:51,400 --> 00:23:52,660
0,240 240,300 300,660 660,900 900,1260
couple of minutes now| talking
|讨论 6.S081 的课程结构，

812
00:23:52,660 --> 00:23:56,710
0,690 690,1110 1620,2040 2040,2970 3570,4050
about a class structure of

813
00:23:56,950 --> 00:24:00,980
0,600 1560,2340 2340,2520 2520,3180
{6.S081 - - -},|

814
00:24:01,140 --> 00:24:04,200
0,660 1140,1620 1620,1980 1980,2520 2520,3060
before switching back to actual
然后再回到技术内容部分，

815
00:24:04,200 --> 00:24:06,960
0,390 390,960 1230,1500 1500,2190 2610,2760
technical content.| So there is
|这里有一个课程的网站，

816
00:24:06,960 --> 00:24:08,370
0,60 60,600 600,690 690,780 780,1410
a website for the course,|
|

817
00:24:08,370 --> 00:24:08,970
0,270 270,330 330,420 420,540 540,600
which I don't want to
我现在不想写出来，

818
00:24:08,970 --> 00:24:09,990
0,240 240,450 450,660 660,900 900,1020
write out just now,| but
|但是你可以在谷歌上搜索 6.S081 找到它。

819
00:24:09,990 --> 00:24:11,220
0,300 300,690 720,900 900,990 990,1230
it's {} you can find

820
00:24:11,220 --> 00:24:11,940
0,60 60,150 150,360 360,450 450,720
it by looking for {6.S081

821
00:24:11,940 --> 00:24:13,470
0,450 450,600 600,900 900,1080 1080,1530
- - -} on Google.|
|

822
00:24:14,280 --> 00:24:18,030
0,330 450,720 720,1590 2070,2730 2730,3750
And the website, {} has
这个网站有一个课程表，

823
00:24:19,890 --> 00:24:23,740
0,750 1290,2580 2910,3570
a schedule {},|
|

824
00:24:23,980 --> 00:24:25,720
0,210 210,780 810,1020 1020,1650 1650,1740
it has the assignments on
课程表上有作业，还有实验作业。

825
00:24:25,720 --> 00:24:26,860
0,60 60,600 600,690 690,870 870,1140
the schedule that has the

826
00:24:26,890 --> 00:24:28,560
0,450 450,1500
lab assignments.|
|

827
00:24:28,740 --> 00:24:29,880
0,330 330,510 510,660 660,1050 1050,1140
{} And it has the
它也有关于课程结构的其他信息，

828
00:24:29,880 --> 00:24:31,380
0,210 210,330 420,1080 1080,1260 1260,1500
sort of information about course

829
00:24:31,380 --> 00:24:33,270
0,450 450,690 690,960 990,1380 1380,1890
structure,| like the grading policy
|比如课程的评分标准。

830
00:24:33,270 --> 00:24:33,900
0,150 150,300
on it.|
|

831
00:24:34,240 --> 00:24:36,400
0,450 600,750 750,960 960,1440 1470,2160
{} The other big resource
你需要跟踪的另一个重要资源是 Piazza 。

832
00:24:36,400 --> 00:24:37,930
0,90 90,570 900,1080 1080,1260 1260,1530
you're gonna wanna keep track

833
00:24:37,930 --> 00:24:39,260
0,210 210,990
of piazza.|
|

834
00:24:39,960 --> 00:24:41,190
0,330 330,450 450,720 750,1110 1110,1230
{} I guess, everybody was
我想，来这里的每个人都是通过 Piazza 。

835
00:24:41,190 --> 00:24:42,090
0,210 210,420 420,600 600,750 750,900
here got here by way

836
00:24:42,090 --> 00:24:44,490
0,630 930,1170 1170,1500 1830,2130 2130,2400
piazza,| {} but as well
|但是还有，

837
00:24:44,490 --> 00:24:46,890
0,450 450,1110 1470,1800 1800,2040 2040,2400
as {},| so we used
|所以我们定期来做两件主要的事情，

838
00:24:46,890 --> 00:24:48,150
0,540 540,660 660,840 840,1050 1050,1260
periodically for two main things,|
|

839
00:24:48,150 --> 00:24:49,290
0,270 270,630 660,870 870,960 960,1140
one is as a way
一是人们能够对实验作业提出问题，

840
00:24:49,290 --> 00:24:50,010
0,90 90,390 390,540 540,660 660,720
of people being able to

841
00:24:50,010 --> 00:24:51,540
0,240 240,870 870,1110 1110,1260 1260,1530
ask questions about the lab

842
00:24:51,540 --> 00:24:53,200
0,780 780,1320
assignments,| and
|工作人员会试着回答这些问题，

843
00:24:53,420 --> 00:24:55,400
0,450 690,990 990,1410 1410,1800 1830,1980
a course staff will try

844
00:24:55,400 --> 00:24:56,420
0,90 90,330 330,450 450,780 780,1020
to answer these questions,| but
|

845
00:24:56,480 --> 00:24:57,890
0,240 240,390 390,780 780,1170 1170,1410
you should feel absolutely free
你们也可以完全自由地回答彼此的问题，

846
00:24:57,890 --> 00:24:59,210
0,90 90,420 420,600 600,840 840,1320
to answer each other's questions

847
00:24:59,210 --> 00:25:01,100
0,150 150,480 810,1170 1530,1710 1710,1890
as well| and the other
|在 Piazza 上发生的另一件事是，

848
00:25:01,100 --> 00:25:01,910
0,150 150,300 300,420 420,690 690,810
big thing that happens on

849
00:25:01,910 --> 00:25:03,770
0,360 360,480 480,660 660,1620 1680,1860
piazza,| if there's announcements there's
|如果有课程公告，就会发布在上面，

850
00:25:03,770 --> 00:25:05,180
0,150 150,630 630,840 840,900 900,1410
any announcements about the course.|
|

851
00:25:05,500 --> 00:25:06,940
0,420 510,660 660,840 840,900 900,1440
{} We'll put the announcement
我们会把公告放在 Piazza 上，

852
00:25:06,940 --> 00:25:08,020
0,150 150,600 600,780 780,990 990,1080
on piazza,| so you should
|所以你应该关注 Piazza 上的公告，

853
00:25:08,020 --> 00:25:09,100
0,210 210,300 300,510 510,630 630,1080
keep an eye on piazza

854
00:25:09,100 --> 00:25:10,510
0,90 90,630 630,870 870,1080 1080,1410
for announcements,| even if {}
|即使你不用它来寻找实验帮助。

855
00:25:11,220 --> 00:25:11,940
0,150 150,300 300,510 510,630 630,720
you're not using it for

856
00:25:11,940 --> 00:25:12,760
0,270 270,570
lab help.|
|

857
00:25:13,580 --> 00:25:14,220
0,90
Yeah.|
是的。|

858
00:25:15,460 --> 00:25:16,340
0,600

859
00:25:16,700 --> 00:25:17,690
0,300 300,300 300,870 870,930 930,990
The {} one of the
课程的很大一部分就是这些课程。

860
00:25:17,690 --> 00:25:18,710
0,210 210,450 450,540 540,870 870,1020
big parts of course is

861
00:25:18,710 --> 00:25:21,040
0,300 300,480 480,1380 1440,2010
that these lectures {}.|
|

862
00:25:22,020 --> 00:25:23,080
0,480 510,780

863
00:25:24,150 --> 00:25:27,420
0,840 840,1260 1440,2190 2340,2940 2940,3270
Lectures will cover basic ideas
这个讲座会涉及到操作系统的基本理念。

864
00:25:27,420 --> 00:25:28,800
0,90 90,450 450,1200
of operating systems.|
|

865
00:25:28,860 --> 00:25:31,110
0,510 1410,1710 1710,1770 1770,1890 1890,2250
{} Some of the lectures
有些课程会详细研究 xv6 的代码，

866
00:25:31,110 --> 00:25:33,060
0,90 90,180 180,690 690,870 870,1950
will be devoted to detailed

867
00:25:33,090 --> 00:25:35,400
0,390 390,990 990,1110 1110,1320 1710,2310
a study of the code

868
00:25:35,400 --> 00:25:36,510
0,180 180,360 360,510 510,930 930,1110
in {xv6 - -},| which
|这是我们的小型教学操作系统，

869
00:25:36,510 --> 00:25:38,010
0,150 150,300 300,750 750,1140 1140,1500
is our small teaching operating

870
00:25:38,010 --> 00:25:40,590
0,540 1410,1560 1560,1980 2130,2430 2430,2580
system| and so talk about
|讨论它是如何工作的，

871
00:25:40,590 --> 00:25:41,850
0,210 210,270 270,720 720,1080 1080,1260
how it works,| we'll look
|我们会在课程中查看代码，演示代码执行过程，

872
00:25:41,850 --> 00:25:43,050
0,60 60,120 120,570 570,990 990,1200
at the code and show

873
00:25:43,050 --> 00:25:44,940
0,90 90,330 330,960 960,1230 1230,1890
the code executing during lectures,|
|

874
00:25:45,810 --> 00:25:47,280
0,210 210,270 270,690 690,1170 1170,1470
and in addition, before many
另外，在很多课程之前

875
00:25:47,280 --> 00:25:48,090
0,90 90,180 180,600 600,690 690,810
of the lectures,| we'll be
|我们会先阅读书中的作业，

876
00:25:48,090 --> 00:25:50,220
0,840 840,1110 1110,1620 1620,1890 1890,2130
assignments reading assignments from a

877
00:25:50,220 --> 00:25:52,320
0,570 930,1290 1350,1590 1590,1650 1650,2100
book,| that sort of describes
|这本书描述了 xv6 是如何运行的，

878
00:25:52,320 --> 00:25:54,840
0,300 300,1170 1170,1770 1770,2190 2280,2520
how xv6 operates| and why
|以及为什么它是这样设计的。

879
00:25:54,840 --> 00:25:56,220
0,180 180,570 570,750 750,1110
it's designed that way.|
|

880
00:25:56,670 --> 00:25:57,690
0,240 240,450 450,600 600,690 690,1020
So you do the readings
所以你应该在上课前阅读，

881
00:25:57,690 --> 00:25:59,640
0,210 210,300 300,900 1680,1830 1830,1950
before the class,| so they
|这样就能听懂课程上的讨论，

882
00:25:59,640 --> 00:26:01,230
0,120 120,840 840,1020 1020,1530 1530,1590
do understand the discussion in

883
00:26:01,230 --> 00:26:02,880
0,60 60,720 1170,1500 1500,1560 1560,1650
the class,| some of the
|一些课程专门讲授背景知识，

884
00:26:02,880 --> 00:26:04,950
0,360 360,480 480,900 900,1170 1200,2070
lectures are devoted to background|

885
00:26:04,950 --> 00:26:05,580
0,60 60,300 300,390 390,510 510,630
to help you do the
帮助你做实验。

886
00:26:05,580 --> 00:26:06,540
0,840
labs.|
|

887
00:26:06,660 --> 00:26:08,400
0,450 540,690 690,1290 1290,1500 1500,1740
{} So, like about C
比如 C 语言是如何工作的，

888
00:26:08,400 --> 00:26:10,200
0,420 420,510 510,780 780,1170 1350,1800
works of,| how the {RISC-V
|RISC-V ，也就是我们要使用的微处理器，

889
00:26:10,200 --> 00:26:11,940
0,510 510,690 690,810 810,900 900,1740
-} which is the microprocessor

890
00:26:11,940 --> 00:26:13,080
0,120 120,240 240,360 360,810
that we'll be using,|
|

891
00:26:13,200 --> 00:26:15,120
0,510 540,780 780,1080 1080,1260 1260,1920
{} that you'll find helpful
你们会发现这对理解如何做实验很有帮助，

892
00:26:15,960 --> 00:26:16,980
0,210 210,660 660,780 780,900 900,1020
in understanding how to do

893
00:26:16,980 --> 00:26:18,300
0,90 90,630 780,990 990,1230 1230,1320
the labs| and towards the
|在课程快结束的时候，

894
00:26:18,300 --> 00:26:19,420
0,150 150,210 210,270 270,990
end of the course,|
|

895
00:26:19,890 --> 00:26:22,350
0,330 330,630 630,810 810,1500 1860,2460
we'll spend some lectures discussing
我们会用一些课讨论一些操作系统论文，

896
00:26:22,350 --> 00:26:25,500
0,330 360,750 750,1110 1110,2010 2730,3150
some operating system papers,| research
|研究论文和该领域的一些经典论文，

897
00:26:25,500 --> 00:26:27,360
0,630 630,900 900,1080 1080,1500 1500,1860
papers and some classic papers

898
00:26:27,360 --> 00:26:29,250
0,60 60,150 150,660 960,1470 1500,1890
in the field,| which you
|会要求你们在课程前阅读这些论文，

899
00:26:29,700 --> 00:26:30,660
0,330 330,510 510,600 600,720 720,960
will ask that you read

900
00:26:30,660 --> 00:26:31,470
0,240 240,300 300,570 570,720 720,810
before the lecture| and then
|然后我们会在课程中讨论这些论文。

901
00:26:31,470 --> 00:26:32,340
0,90 90,270 270,330 330,570 570,870
we'll sort of talk about

902
00:26:32,340 --> 00:26:34,410
0,150 570,1290 1290,1590 1590,1650 1650,2070
the papers during the lecture,|
|

903
00:26:34,980 --> 00:26:36,210
0,330 330,570 570,630 630,1110 1110,1230
for all the lectures are
对于所有的讲座，

904
00:26:36,210 --> 00:26:37,560
0,270 270,360 360,420 420,960 1080,1350
almost all the lectures,| we
|我们要求你在讲座之前，

905
00:26:37,560 --> 00:26:38,700
0,450 450,750 750,870 870,1110 1110,1140
ask that you submit a

906
00:26:38,700 --> 00:26:40,980
0,450 450,660 660,780 780,1440 1620,2280
question about the reading {},|
|

907
00:26:41,010 --> 00:26:43,740
0,210 210,300 300,960 1140,2220 2430,2730
for the lecture before the
提交一个关于所读文章的问题。

908
00:26:43,770 --> 00:26:45,090
0,420 420,690 690,750 750,810 810,1320
actual time of the lecture.|

909
00:26:45,300 --> 00:26:45,900
0,360
Which
你们中的很多人都参加了这次讲座，谢谢你们。

910
00:26:45,950 --> 00:26:46,820
0,360 360,480 480,660 660,750 750,870
many or all of you

911
00:26:46,820 --> 00:26:48,380
0,210 210,450 450,930 960,1440 1440,1560
did for this lecture for

912
00:26:48,380 --> 00:26:50,030
0,150 150,390 390,660 840,1290 1470,1650
which thank you,| {} and
|我们会查看这些问题来帮助我们。

913
00:26:50,030 --> 00:26:50,960
0,120 120,240 240,420 420,600 600,930
we will read those questions

914
00:26:50,960 --> 00:26:52,580
0,90 90,330 330,870
to help us.|
|

915
00:26:52,970 --> 00:26:54,260
0,600 600,750 750,1020 1020,1200 1200,1290
Guide us about what to
指导我们讨论什么，

916
00:26:54,260 --> 00:26:55,760
0,210 210,540 540,840 1080,1230 1230,1500
talk about| and we'll try
|我们会努力回答尽可能多的问题，

917
00:26:55,760 --> 00:26:57,080
0,90 90,660 660,990 990,1260 1260,1320
to answer as many of

918
00:26:57,080 --> 00:26:58,040
0,60 60,450 450,510 510,630 630,960
the questions as we can,|
|

919
00:26:58,040 --> 00:27:00,560
0,540 570,900 900,1260 1260,1740 1800,2520
although there's rarely time, unfortunately
尽管很少有时间，不过我们没有时间回答所有问题。

920
00:27:00,560 --> 00:27:01,340
0,150 150,240 240,330 330,630 630,780
for us to answer all

921
00:27:01,340 --> 00:27:02,460
0,90 90,240
of them.|
|

922
00:27:02,800 --> 00:27:04,360
0,450 600,810 810,1020 1020,1200 1200,1560
{} The next big part
课程的下一个重要部分是实验。

923
00:27:04,360 --> 00:27:04,990
0,60 60,120 120,450 450,540 540,630
of the course of the

924
00:27:04,990 --> 00:27:05,980
0,840
labs.|
|

925
00:27:06,400 --> 00:27:08,320
0,180 180,270 270,780 780,1350 1380,1920
There's a programming lab do,
几乎每周都有一个编程实验，

926
00:27:08,350 --> 00:27:09,320
0,720

927
00:27:09,820 --> 00:27:12,250
0,390 390,570 570,1080 1950,2280 2280,2430
almost every week| and the
|实验的目的是，

928
00:27:12,250 --> 00:27:13,000
0,180 180,240 240,330 330,660 660,750
point of the labs is|

929
00:27:13,000 --> 00:27:13,780
0,120 120,270 270,390 390,510 510,780
to help you get hands
帮助你亲身体验实现和使用操作系统。

930
00:27:13,780 --> 00:27:15,940
0,150 150,870 870,1380
on experience with

931
00:27:16,110 --> 00:27:19,620
0,840 840,1260 1260,1920 2310,2940 2940,3510
implementing and using operating systems.|
|

932
00:27:20,690 --> 00:27:23,330
0,540 1110,1830 1830,1980 1980,2250 2250,2640
A lab that's due next
下周到期的一个实验是，

933
00:27:23,330 --> 00:27:25,760
0,330 330,840 840,1260 1260,1680 1680,2430
week is| actually about using
|关于如何编写调用系统调用的应用程序，

934
00:27:25,760 --> 00:27:27,830
0,270 300,690 690,1260 1260,1410 1680,2070
about writing applications that make

935
00:27:27,830 --> 00:27:29,030
0,120 120,480 480,570 570,900 900,1200
the call the system calls,|
|

936
00:27:29,030 --> 00:27:30,240
0,90 90,180 180,480 480,870
we'll be talking about.|
随后我们会讨论。|

937
00:27:31,520 --> 00:27:32,810
0,270 270,510 510,600 600,990 990,1290
Whereas most of those labs
与此之后的大多数实验不同，

938
00:27:32,810 --> 00:27:34,550
0,270 270,540 540,840 840,1260 1260,1740
after that are involved,| you
|要么实现基本的操作系统功能，

939
00:27:35,150 --> 00:27:37,370
0,300 300,1200 1230,1560 1560,1920 1920,2220
either implementing basic operating system

940
00:27:37,370 --> 00:27:38,860
0,450 450,690 690,1200
features| or adding
|或想 xv6 操作系统添加内核扩展，

941
00:27:39,020 --> 00:27:41,000
0,210 210,540 540,1440 1440,1590 1590,1980
a kernel extensions to the

942
00:27:41,090 --> 00:27:42,360
0,270 270,420 420,1110
{xv6 - -}

943
00:27:42,770 --> 00:27:45,350
0,660 660,1170 2010,2130 2130,2280 2280,2580
operating system,| the very last
|最后一个实验，

944
00:27:45,350 --> 00:27:46,670
0,300 300,750 870,1110 1110,1170 1170,1320
lab and one| in which
|是添加一个网络栈，和网络驱动程序，

945
00:27:46,670 --> 00:27:48,080
0,90 90,330 330,570 570,840 870,1410
you actually add a network

946
00:27:48,080 --> 00:27:49,430
0,420 420,540 540,570 570,900 900,1350
stack and a network driver,|

947
00:27:49,430 --> 00:27:50,210
0,180 180,300 300,390 390,570 570,780
so you'll be able to
以便能够通过网络连接到你运行的操作系统。

948
00:27:50,240 --> 00:27:51,500
0,450 450,570 570,750 750,810 810,1260
connect in over the network

949
00:27:51,500 --> 00:27:52,760
0,330 480,630 630,900 900,1170 1170,1260
to the operating system that

950
00:27:52,760 --> 00:27:53,540
0,120 120,540
you run.|
|

951
00:27:55,560 --> 00:27:56,700
0,330 330,750 750,840 840,960 960,1140
You should, if you have
如果你对实验有问题，

952
00:27:56,700 --> 00:27:58,500
0,300 300,390 390,480 480,1290 1290,1800
problems with the lab's,| they'll
|助教会在办公时间提供帮助。

953
00:27:58,500 --> 00:28:00,740
0,180 180,540 540,1260 1320,1770
be office hours that

954
00:28:00,830 --> 00:28:02,900
0,690 840,1560 1560,1680 1680,1980 1980,2070
{} TAs will hold.| In
|你也可以把问题发布到 Piazza 上，

955
00:28:02,900 --> 00:28:05,360
0,360 360,480 480,1230 1800,2160 2160,2460
addition you can post questions

956
00:28:05,360 --> 00:28:07,250
0,90 90,630 870,1230 1230,1470 1470,1890
to piazza| and very often
|而且通常可以从 Piazza 上获得有用的答案，

957
00:28:07,250 --> 00:28:07,850
0,120 120,210 210,360 360,450 450,600
you'll be able to get

958
00:28:07,850 --> 00:28:10,370
0,270 270,600 600,750 750,1320 2040,2520
useful answers from piazza| more
|比在办公时间更快。

959
00:28:10,370 --> 00:28:11,810
0,330 330,570 570,720 720,1080 1080,1440
quickly than from office hours.|
|

960
00:28:13,060 --> 00:28:15,430
0,420 420,870 870,1290 1290,2250 2250,2370
We welcome you discussing the
我们欢迎你讨论实验，

961
00:28:15,430 --> 00:28:16,900
0,570 570,810 810,960 960,1050 1050,1470
labs talking about the labs,|
|

962
00:28:16,900 --> 00:28:18,670
0,180 180,330 330,450 450,840 1170,1770
talking about how to design
讨论如何设计实验解决方案，

963
00:28:18,670 --> 00:28:20,980
0,660 930,1320 1320,1740 1740,1950 2040,2310
the lab solutions,| but we
|但是我们要求不要看别人的解决方案。

964
00:28:20,980 --> 00:28:21,820
0,120 120,180 180,540 540,630 630,840
ask you please do not

965
00:28:21,820 --> 00:28:23,410
0,150 150,270 270,420 420,750 750,1590
look at other people's solutions.|
|

966
00:28:23,680 --> 00:28:25,270
0,510 510,960 960,1320 1320,1380 1380,1590
Relapse, please all the code
重复一遍，你编写的所有代码都应该是自己的，

967
00:28:25,270 --> 00:28:26,140
0,120 120,390 390,540 540,660 660,870
you write should be your

968
00:28:26,140 --> 00:28:27,850
0,210 210,480 540,690 690,1110 1320,1710
own| and you shouldn't share
|而且你不应该分享代码或查看其他解决方案。

969
00:28:27,850 --> 00:28:29,620
0,510 510,750 1080,1440 1440,1680 1680,1770
code or a look at

970
00:28:29,620 --> 00:28:30,620
0,210 210,870
other solutions.|
|

971
00:28:32,740 --> 00:28:34,300
0,1320
Grading,
评分，当然，今年主要由实验决定的。

972
00:28:35,800 --> 00:28:38,000
0,120 120,840 1170,1950
of course {},

973
00:28:38,480 --> 00:28:40,250
0,120 120,240 240,570 570,1230 1530,1770
will be mostly determined from

974
00:28:40,250 --> 00:28:41,960
0,90 90,540 540,750 750,1110 1230,1710
the labs this year,| so
|所以 70% 的成绩将是根据你的实验结果，

975
00:28:42,080 --> 00:28:43,520
0,750 750,810 810,870 870,1230 1230,1440
70% of the grade will

976
00:28:43,520 --> 00:28:45,120
0,540 600,1170
be, {}

977
00:28:45,780 --> 00:28:46,140
0,60

978
00:28:46,620 --> 00:28:48,390
0,150 150,600 600,1230 1500,1740 1740,1770
{} based on whether or

979
00:28:48,390 --> 00:28:50,310
0,330 330,570 570,1230 1230,1380 1380,1920
not your lab,| you submit
|你提交的代码是否通过测试，

980
00:28:50,340 --> 00:28:51,540
0,420 420,510 510,900 900,1020 1020,1200
passes the tests| and we
|我们评分使用我们提供的相同的测试，

981
00:28:51,540 --> 00:28:52,380
0,150 150,480 480,570 570,750 750,840
for grading, we run the

982
00:28:52,380 --> 00:28:54,600
0,360 360,1020 1380,1710 1710,1830 1830,2220
same tests that we supply

983
00:28:54,600 --> 00:28:55,710
0,240 240,450 450,600 600,780 780,1110
you,| so if your lab
|所以如果你的实验通过了我们提供的所有实验，

984
00:28:55,710 --> 00:28:57,390
0,630 810,990 990,1080 1080,1530 1530,1680
passes all the tests that

985
00:28:57,390 --> 00:28:58,200
0,120 120,270 270,420 420,540 540,810
we give you,| the chance
|你就可以得到实验的全部分数。

986
00:28:58,200 --> 00:28:58,920
0,60 60,210 210,330 330,510 510,720
to show you that full

987
00:28:58,920 --> 00:29:00,260
0,270 270,390 390,450 450,1020
credit for the lab.|
|

988
00:29:00,500 --> 00:29:02,930
0,420 930,1650 1650,1710 1710,1770 1770,2430
{} 20% of the grade
20% 的分数来自实验检查会议，

989
00:29:03,650 --> 00:29:04,460
0,240 240,420 420,570 570,660 660,810
{} is going to be

990
00:29:04,460 --> 00:29:08,180
0,270 270,720 720,1200 1200,1860 3570,3720
from lab checkoff meetings| for
|你们每个人都将随机选择几个实验，

991
00:29:08,180 --> 00:29:09,440
0,180 180,270 270,480 480,870 900,1260
each of you will pick

992
00:29:09,440 --> 00:29:10,790
0,60 60,330 330,390 390,870 870,1350
a couple of randomly selected

993
00:29:10,790 --> 00:29:11,810
0,570 570,750 750,870 870,930 930,1020
labs| and one of the
|有一个小组将与你们交谈，

994
00:29:11,810 --> 00:29:13,040
0,300 300,390 390,750 750,810 810,1230
teams will talk to you|
|

995
00:29:13,280 --> 00:29:14,330
0,240 240,420 420,480 480,840 840,1050
and ask you questions about
询问你们关于实现实验的问题，

996
00:29:14,330 --> 00:29:15,350
0,90 90,660 660,810 810,870 870,1020
your implementation| just to make
|确保你们真的理解发生了什么。

997
00:29:15,350 --> 00:29:17,180
0,330 330,570 900,1470
sure that {}

998
00:29:17,320 --> 00:29:18,490
0,240 240,330 330,540 540,960 960,1170
are you really understand what's

999
00:29:18,490 --> 00:29:19,620
0,270 270,840
going on.|
|

1000
00:29:20,180 --> 00:29:21,920
0,300 300,540 540,840 840,1080 1080,1740
It's a lab check offs.|
这是实验检查。|

1001
00:29:23,870 --> 00:29:26,600
0,450 450,1200 1290,1770 1770,2370
There's a 10% remaining.|
还剩 10% 。|

1002
00:29:28,040 --> 00:29:29,240
0,30 30,480 630,690 690,990 990,1200
A lot of, {} kind
很多，比如是或否，一或零的事，

1003
00:29:29,240 --> 00:29:30,980
0,150 150,600 630,840 840,1320 1350,1740
of be, like a yes

1004
00:29:30,980 --> 00:29:32,690
0,60 60,780 810,1080 1080,1170 1170,1710
or no, one or zero

1005
00:29:32,720 --> 00:29:33,590
0,240 240,330 330,570 570,720 720,870
type of thing| or would
|或者他们会，

1006
00:29:33,590 --> 00:29:34,460
0,180 180,570
they be,|
|

1007
00:29:35,100 --> 00:29:37,860
0,300 300,510 510,1260 1980,2520 2550,2760
like could someone get, like
比如答对了部分问题，但不是所有问题都答对了，

1008
00:29:37,860 --> 00:29:39,270
0,120 120,390 390,1020 1080,1320 1320,1410
if they answered some of

1009
00:29:39,270 --> 00:29:40,740
0,60 60,540 540,810 810,1050 1080,1470
the questions right, but not

1010
00:29:40,740 --> 00:29:41,580
0,120 120,210 210,600 600,750 750,840
all the questions right,| when
|当他们是这种情况时，分数是怎样的。

1011
00:29:41,580 --> 00:29:43,160
0,120 120,480 510,690 690,1350
they get in between,

1012
00:29:43,570 --> 00:29:44,700
0,210 210,780
so {the,grade}.|
|

1013
00:29:45,060 --> 00:29:45,810
0,150 150,240 240,330 330,540 540,750
You know I haven't thought
你知道，我还没有想过这件事。

1014
00:29:45,810 --> 00:29:46,880
0,180 180,780
this through,|
|

1015
00:29:47,380 --> 00:29:49,660
0,690 1230,1470 1470,1770 1770,2070 2070,2280
{} there's certainly room for
当然有部分学分的情况，但是。

1016
00:29:49,660 --> 00:29:51,880
0,330 330,660 660,960 1650,2010 2010,2220
partial credit, but.| It's not
|它不是二选一的，

1017
00:29:51,880 --> 00:29:53,170
0,240 240,390 390,600 600,660 660,1290
{}, it won't be binary,|
|

1018
00:29:53,440 --> 00:29:55,210
0,360 360,720 720,1050 1440,1650 1650,1770
it'll definitely be you can
你当然可以获得部分学分。

1019
00:29:55,210 --> 00:29:56,540
0,300 300,570 570,900
receive partial credit.|
|

1020
00:29:56,940 --> 00:29:57,680
0,480
Okay.|
好的。|

1021
00:29:59,470 --> 00:30:01,180
0,600 630,750 750,990 990,1590 1590,1710
{} The last 10% is
最后的 10% 是由家庭作业

1022
00:30:01,180 --> 00:30:02,200
0,150 150,210 210,540 540,750 750,1020
going to be {} driven

1023
00:30:02,200 --> 00:30:04,720
0,150 150,240 240,870 870,1470 1500,2520
by the homework| and participation
|以及讲座和 Piazza 的参与决定的。

1024
00:30:04,900 --> 00:30:06,920
0,360 360,810 810,1230 1230,1680
during lecture and piazza.|
|

1025
00:30:07,480 --> 00:30:08,300
0,570

1026
00:30:08,900 --> 00:30:10,220
0,270 270,360 360,450 450,930 930,1320
There will be no exams
今年不会有考试或小测验。

1027
00:30:10,220 --> 00:30:11,740
0,90 90,870
or quizzes

1028
00:30:13,300 --> 00:30:14,520
0,210 210,960
this year.|
|

1029
00:30:15,150 --> 00:30:16,710
0,630 990,1170 1170,1260 1260,1410 1410,1560
{} And so what, that
所以，这意味着大部分的，

1030
00:30:16,710 --> 00:30:17,580
0,240 240,360 360,540 540,810 810,870
means is that most of

1031
00:30:17,580 --> 00:30:20,100
0,90 90,90 900,1050 1050,1380 1500,2520
the {},| you know 90%
|你知道 90% 的成绩是由实验决定的。

1032
00:30:20,100 --> 00:30:22,200
0,150 150,450 750,1320 1320,1680 1710,2100
of the grade is being

1033
00:30:22,200 --> 00:30:23,580
0,210 210,330 330,450 450,960 960,1380
driven by the lab.| So
|所以你应该花很多时间在实验上，

1034
00:30:23,880 --> 00:30:24,780
0,360 360,630
you should

1035
00:30:25,050 --> 00:30:25,830
0,330 330,360 360,480 480,540 540,780
spend a lot of time

1036
00:30:25,830 --> 00:30:27,660
0,60 60,150 150,870 900,1440 1560,1830
in the labs,| {} make
|确保你早点开始，

1037
00:30:27,660 --> 00:30:29,610
0,270 270,570 900,1140 1140,1470 1470,1950
sure that you start early|
|

1038
00:30:29,610 --> 00:30:30,990
0,210 210,360 360,570 570,930 930,1380
and have enough time to
有足够的时间完成实验，并解决 bug ，

1039
00:30:31,290 --> 00:30:33,540
0,420 420,990 1050,1500 1770,2100 2100,2250
complete them and work out

1040
00:30:33,540 --> 00:30:34,440
0,330 330,390 390,600 600,690 690,900
bugs| in order to get
|以获得满分。

1041
00:30:34,440 --> 00:30:35,400
0,240 240,540
full credit.|
|

1042
00:30:37,270 --> 00:30:38,380
0,510 510,600 600,720 720,1050 1050,1110
And you know as a
你知道，因此这是一门

1043
00:30:38,380 --> 00:30:39,400
0,300 300,390 390,540 540,690 690,1020
result of that this is

1044
00:30:39,460 --> 00:30:40,300
0,150 150,210 210,480 480,540 540,840
going to be a| very
|非常实用的面向软件的课程。

1045
00:30:40,300 --> 00:30:42,940
0,210 210,270 270,1350 1680,2160 2160,2640
kind of hands-on software oriented

1046
00:30:42,940 --> 00:30:43,660
0,570
course.|
|

1047
00:30:44,580 --> 00:30:46,170
0,180 180,390 390,840 840,1230 1230,1590
{} Any questions about the
关于课程组织，还有什么问题吗？

1048
00:30:47,180 --> 00:30:49,000
0,630 630,690 690,780 780,1350
machinery of the course?|
|

1049
00:30:53,760 --> 00:30:54,900
0,390 390,540 540,750 750,840 840,1140
{} We've got a couple
在聊天中有几个问题。

1050
00:30:54,900 --> 00:30:56,940
0,540 540,690 690,1320 1770,1920 1920,2040
questions in chat.| So the
|第一个是组织管理的问题，

1051
00:30:56,940 --> 00:30:58,800
0,420 420,540 540,600 600,1110 1110,1860
first is a logistical question,|
|

1052
00:30:58,950 --> 00:31:00,450
0,600 600,900 900,1140 1140,1260 1260,1500
currently {6.S081 - - -}
当前， 6.S081 没有像往常一样在系统主修课程中，

1053
00:31:00,450 --> 00:31:01,560
0,210 210,540 540,660 660,1020 1020,1110
isn't listed as usual for

1054
00:31:01,560 --> 00:31:02,910
0,90 90,510 510,1110 1110,1230 1230,1350
the system's concentration in the

1055
00:31:02,910 --> 00:31:04,980
0,720 1080,1230 1230,1380 1380,1710 1710,2070
[],| are there plans added
|以后有没有增加课程的计划。

1056
00:31:04,980 --> 00:31:05,760
0,90 90,180 180,390 390,450 450,780
to the list of classes

1057
00:31:05,760 --> 00:31:07,080
0,420 420,570 570,780 780,930 930,1320
later.| I think for that
|我想因为它不是批准的高级研究生课程，

1058
00:31:07,350 --> 00:31:09,210
0,570 570,780 780,1350 1350,1500 1500,1860
because it's not an {AAGS

1059
00:31:09,210 --> 00:31:10,380
0,210 210,540 540,750 750,960 960,1170
- -},| it's an {AUS
|它是高级本科课程，

1060
00:31:10,380 --> 00:31:12,150
0,540 540,720 720,1080 1080,1470 1500,1770
-},| it can't be used
|它不能满足安排要求，

1061
00:31:12,150 --> 00:31:13,680
0,90 90,540 540,870 870,1440 1440,1530
to fulfill arrange requirements,| so
|所以它不是研究生水平的课程。

1062
00:31:13,680 --> 00:31:14,760
0,180 180,330 330,390 390,810 810,1080
it's not a graduate level

1063
00:31:14,760 --> 00:31:15,700
0,720
class.|
|

1064
00:31:15,970 --> 00:31:17,060
0,480 480,780
But, {}
但是，我们有唯一的家庭作业来提交问题，

1065
00:31:19,270 --> 00:31:21,430
0,1050 1290,1560 1560,1680 1680,2040 2040,2160
and then we have is

1066
00:31:21,430 --> 00:31:22,540
0,120 120,360 360,720 720,780 780,1110
the only homework to submit

1067
00:31:22,540 --> 00:31:24,040
0,480 480,690 690,810 810,870 870,1500
questions| looking at the calendar
|看看日历似乎是这样。

1068
00:31:24,040 --> 00:31:24,790
0,180 180,480 480,570 570,690 690,750
that appears to be the

1069
00:31:24,790 --> 00:31:25,620
0,660
case.|
|

1070
00:31:28,360 --> 00:31:30,400
0,240 240,360 360,720 720,1290
Unless I'm forgetting something,
除非我忘了什么，我想就是这样的。

1071
00:31:31,270 --> 00:31:32,110
0,90 90,240 240,450 450,510 510,840
I think that's the case,

1072
00:31:32,110 --> 00:31:33,540
0,510
yes.|
|

1073
00:31:35,140 --> 00:31:37,450
0,390 390,1290 1740,2010 2010,2190 2190,2310
So have, {} are there
那么，有没有分数比例的情况，

1074
00:31:37,450 --> 00:31:39,250
0,210 210,630 630,1170 1170,1320 1320,1800
gonna be cutoffs for grades,|
|

1075
00:31:39,250 --> 00:31:40,390
0,180 180,420 420,840 840,1050 1050,1140
like X percent gets in
像是百分之 X 的人得 A ，百分之 Y 得 B 等等。

1076
00:31:40,390 --> 00:31:41,560
0,240 240,480 480,870 870,1080 1080,1170
A, Y percent gets a

1077
00:31:41,560 --> 00:31:45,820
0,300 300,1350 1950,2730 2730,3180 3480,4260
B etc.| No no, {}
|不，不，你知道我们努力给学生自由。

1078
00:31:47,640 --> 00:31:48,600
0,570 570,660 660,780 780,840 840,960
{}, you know we're going

1079
00:31:48,600 --> 00:31:51,630
0,90 90,360 360,900 1080,1650 2760,3030
to try to {} free

1080
00:31:51,630 --> 00:31:53,100
0,330 330,1110
student estimate.|
|

1081
00:31:53,320 --> 00:31:56,290
0,900 1200,1800 1800,1890 1890,2130 2130,2970
I'm impression of how well
我的评价是你对材料理解得好坏，

1082
00:31:56,620 --> 00:31:58,630
0,330 330,690 690,750 750,1440 1470,2010
you've understood the material {},|
|

1083
00:31:59,250 --> 00:32:00,210
0,210 210,480 480,510 510,720 720,960
and assign a grade based
并在此基础上给出一个分数，

1084
00:32:00,210 --> 00:32:01,230
0,90 90,270 270,360 360,750 750,1020
on that,| so there's no
|所以不会有预先设定的比例。

1085
00:32:01,230 --> 00:32:03,080
0,930 930,1140 1140,1650
predetermined cut offs.|
|

1086
00:32:07,950 --> 00:32:10,020
0,540 1020,1320 1320,1890
Alright anything else?|
好的，还有其他问题吗？|

1087
00:32:13,660 --> 00:32:16,210
0,900 1080,1350 1380,1680 1680,2190 2220,2550
Alright, just real quick for
好的，对于聊天中询问主修要求的人来说，

1088
00:32:16,210 --> 00:32:18,850
0,600 600,840 840,930 930,1950 2250,2640
folks in the chat asking

1089
00:32:18,850 --> 00:32:20,980
0,570 570,1380
about the

1090
00:32:21,070 --> 00:32:23,290
0,750 750,1530 1710,2010 2010,2160 2160,2220
concentration requirement,| I'm not a
|我不是百分之百确定，

1091
00:32:23,290 --> 00:32:25,030
0,240 240,600 600,1170 1260,1530 1530,1740
hundred percent certain {},| but
|但 6.S081 不是，

1092
00:32:25,030 --> 00:32:26,770
0,360 360,570 570,990 990,1200 1200,1740
{6.S081 - -} is not,|
|

1093
00:32:26,890 --> 00:32:28,480
0,180 180,510 510,930 930,1320 1320,1590
it's a temporary number before
它是课程获得正式编号之前的一个临时编号，

1094
00:32:28,480 --> 00:32:30,010
0,90 90,360 360,840 870,1320 1320,1530
the class gets official one,|
|

1095
00:32:30,010 --> 00:32:31,390
0,150 150,300 330,720 720,990 990,1380
so it certainly won't be
所以它不会出现在任何地方，

1096
00:32:31,810 --> 00:32:33,940
0,630 630,1290 1470,1650 1650,1860 1860,2130
listed anywhere,| if you need
|如果你需要它来实现主修课程，

1097
00:32:33,940 --> 00:32:35,200
0,120 120,210 210,540 540,600 600,1260
it to fulfill a concentration,|
|

1098
00:32:35,200 --> 00:32:35,920
0,60 60,210 210,330 330,570 570,720
I think your best bet
我想你最好的选择是填写一份请愿书，

1099
00:32:35,920 --> 00:32:36,700
0,90 90,360 360,450 450,660 660,780
is probably to fill out

1100
00:32:36,700 --> 00:32:38,710
0,60 60,660 660,1020 1020,1410 1410,2010
a petition| or to email
|或给 Katrina Kurtz 发送邮件，

1101
00:32:38,710 --> 00:32:40,270
0,300 300,480 480,840 840,960 960,1560
somebody like Katrina {} Kurtz,|

1102
00:32:40,780 --> 00:32:41,980
0,150 150,600 600,900 900,1110 1110,1200
to see a what the
查看是什么状态，

1103
00:32:41,980 --> 00:32:44,680
0,390 390,750 1260,1590 1590,1920 1920,2700
status is,| we don't control,
|我们无法控制哪些课程满足这些要求。

1104
00:32:45,570 --> 00:32:47,370
0,120 120,270 270,690 840,1200 1200,1800
you know what what classes

1105
00:32:47,370 --> 00:32:49,230
0,570 600,810 810,1020 1020,1110 1110,1860
fill these kind of requirements,

1106
00:32:49,260 --> 00:32:50,400
0,750
unfortunately.|
|

1107
00:32:51,240 --> 00:32:52,260
0,240 240,360 360,540 540,900 900,1020
And for what language will
这门课将使用什么语言，将使用 C 语言。

1108
00:32:52,260 --> 00:32:53,070
0,120 120,390 390,450 450,720 720,810
be using the class, will

1109
00:32:53,070 --> 00:32:55,180
0,90 90,210 210,630
be in C.|
|

1110
00:32:55,490 --> 00:32:57,020
0,150

1111
00:32:58,700 --> 00:33:00,520
0,630 840,1470
Alright, um.|
好的。|

1112
00:33:00,960 --> 00:33:01,380
0,60

1113
00:33:02,400 --> 00:33:03,600
0,720 750,900 900,960 960,1140 1140,1200
Alright, for the rest of
好的，对于这堂课剩下的时间，

1114
00:33:03,600 --> 00:33:04,440
0,60 60,300 300,360 360,570 570,840
the lecture,| I want to
|我想谈一下，

1115
00:33:04,470 --> 00:33:07,050
0,480 480,870 870,1620 1770,2190 2190,2580
talk about how {} {}|
|

1116
00:33:07,050 --> 00:33:08,370
0,180 180,420 420,660 660,900 900,1320
what system calls look like
系统调用看起来像应用程序。

1117
00:33:08,670 --> 00:33:10,800
0,1170 1320,1860
applications {}.|
|

1118
00:33:11,290 --> 00:33:12,970
0,330 570,690 690,840 840,1380 1380,1680
And you know since the
你知道，因为系统调用

1119
00:33:13,000 --> 00:33:15,310
0,330 330,660 660,810 810,1200 1500,2310
system calls| are the interface
|是操作系统提供服务的接口，

1120
00:33:15,340 --> 00:33:16,600
0,90 90,210 210,930 930,1140 1140,1260
to the services that the

1121
00:33:16,600 --> 00:33:18,640
0,390 390,660 660,1260 1260,1320 1740,2040
operating system provides| is actually
|所以这些系统实际是什么样，

1122
00:33:18,640 --> 00:33:20,560
0,240 240,870 900,1230 1230,1440 1440,1920
pretty important what those systems

1123
00:33:20,560 --> 00:33:21,880
0,210 210,330 330,450 450,960 960,1320
look like,| what applications expect
|应用程序从系统调用中得到什么，

1124
00:33:21,880 --> 00:33:23,740
0,120 120,480 480,1080 1320,1710 1710,1860
from system calls and how

1125
00:33:23,740 --> 00:33:25,360
0,120 120,540 540,900 990,1140 1230,1620
they behave,| so it's worth
|所以理解接口是什么样子是值得的。

1126
00:33:25,360 --> 00:33:26,830
0,630 630,810 810,870 870,1260 1260,1470
understanding what the interface looks

1127
00:33:26,830 --> 00:33:28,280
0,1170
like.|
|

1128
00:33:29,380 --> 00:33:30,550
0,360 360,540 540,660 660,1080 1080,1170
{} You'll be using the
你将在第一个实验中使用我们谈到的系统调用，

1129
00:33:30,550 --> 00:33:31,570
0,240 240,450 450,540 540,780 780,1020
system calls we talk about

1130
00:33:31,570 --> 00:33:32,840
0,90 90,180 180,450 450,1020
in the first lab,|
|

1131
00:33:32,960 --> 00:33:35,930
0,360 360,930 1200,1890 1890,2220 2250,2970
{} and extending and improving
在后续的实验中，扩展和增强这些系统调用的内部实现。

1132
00:33:35,930 --> 00:33:38,330
0,180 180,1200 1230,1680 1680,2340 2340,2400
the implementation internal implementation of

1133
00:33:38,330 --> 00:33:39,830
0,150 150,420 420,810 810,930 930,1500
these system calls in subsequent

1134
00:33:39,830 --> 00:33:40,460
0,390
labs.|
|

1135
00:33:40,960 --> 00:33:42,370
0,360 360,420 420,600 600,960 960,1410
What we're gonna do is
我们将演示一些程序的简单示例。

1136
00:33:42,400 --> 00:33:44,860
0,450 450,720 720,1110 1110,2070 2100,2460
show some simple examples of

1137
00:33:44,890 --> 00:33:47,260
0,420 420,1500
little programs.|
|

1138
00:33:47,980 --> 00:33:51,220
0,510 750,1470 1680,2040 2040,2730 2880,3240
That call system calls and
它调用系统调用，我将在 xv6 中运行它们。

1139
00:33:51,220 --> 00:33:52,960
0,270 270,540 540,810 810,1410 1410,1740
I'll run them in {xv6

1140
00:33:52,960 --> 00:33:53,960
0,270 270,480 480,720
-} four you.|
|

1141
00:33:54,540 --> 00:33:56,490
0,420 1200,1410 1410,1620 1620,1830 1830,1950
I'm gonna run them,| the
我将运行它们，|xv6 是一个简单的类 unix 操作系统，

1142
00:33:56,490 --> 00:33:58,140
0,330 330,570 570,690 690,1080 1170,1650
{xv6 -} is a {},

1143
00:33:58,550 --> 00:34:00,200
0,210 210,360 360,930 930,1050 1050,1650
it's a unix, a simplified

1144
00:34:00,200 --> 00:34:02,000
0,420 420,630 630,1050 1050,1500 1500,1800
unix like operating system,| unix
|unix 是一个古老的操作系统，

1145
00:34:02,000 --> 00:34:04,130
0,150 150,420 690,1380 1380,1740 1740,2130
is a old operating system,|
|

1146
00:34:04,130 --> 00:34:07,460
0,420 1890,2220 2220,2430 2430,2910 2910,3330
that's at least intellectual basis
至少作为许多当前操作系统的基础，

1147
00:34:07,460 --> 00:34:09,320
0,270 270,660 660,1110 1110,1440 1440,1860
for many present-day operating systems,|
|

1148
00:34:09,320 --> 00:34:11,300
0,150 150,300 300,900 900,1140 1440,1980
such as Linux and {OS,X}
比如 Linux 和 OS X ，|
|

1149
00:34:11,480 --> 00:34:12,980
0,270 270,390 390,690 690,1020 1020,1500
it's in very common use,|
它使用非常广泛，|

1150
00:34:13,010 --> 00:34:13,760
0,480

1151
00:34:14,540 --> 00:34:17,660
0,510 510,1290 1860,2520 2520,2820 2820,3120
{xv6 -} our teaching operating
xv6 我们的教学操作系统要简单地多，

1152
00:34:17,660 --> 00:34:19,820
0,360 360,480 480,690 690,1260 1740,2160
system is much simpler| and
|在某种程度上收到 unix 的启发，

1153
00:34:19,880 --> 00:34:21,650
0,240 240,300 300,870 870,1080 1080,1770
sort of inspired by unix|
|

1154
00:34:21,650 --> 00:34:22,970
0,120 120,510 660,840 840,1020 1020,1320
and has the same overall
具有相同的整体结构，

1155
00:34:22,970 --> 00:34:25,070
0,420 420,540 540,840 870,1500 1500,2100
structure,| but is dramatically simpler
|但是比任何真正的 unix 操作系统都要简单。

1156
00:34:25,340 --> 00:34:27,440
0,300 300,630 630,1200 1200,1650 1650,2100
than any real unix operating

1157
00:34:27,440 --> 00:34:28,180
0,420
system.|
|

1158
00:34:28,610 --> 00:34:29,440
0,570

1159
00:34:30,750 --> 00:34:32,850
0,240 240,570 570,780 780,1020 1050,2100
It's simple enough that hopefully,|
它足够简单，|

1160
00:34:33,120 --> 00:34:35,070
0,570 780,930 930,1380 1710,1830 1830,1950
{} you know it would
你可以阅读所有的源码，

1161
00:34:35,070 --> 00:34:37,260
0,330 360,960 960,1530 1530,1950 1950,2190
be relatively straightforward, {for,you,to} read

1162
00:34:37,260 --> 00:34:38,820
0,270 270,360 360,660 660,1200 1290,1560
all the source code,| as
|同时阅读这本书，

1163
00:34:38,820 --> 00:34:39,840
0,150 150,300 300,450 450,540 540,1020
well as read the book,|
|

1164
00:34:40,080 --> 00:34:41,640
0,390 750,900 900,1140 1140,1200 1200,1560
in a couple of weeks.|
在几周时间内。|

1165
00:34:41,640 --> 00:34:42,840
0,270 270,480 480,570 570,1140 1140,1200
Certainly during the semester| in
当然在本学期，|为了理解所有 xv6 内部发生的事情。

1166
00:34:42,840 --> 00:34:44,370
0,240 240,510 720,1080 1080,1140 1140,1530
order to kind of understand

1167
00:34:44,370 --> 00:34:46,140
0,240 240,390 390,600 600,1140 1140,1770
all of what happens inside

1168
00:34:46,140 --> 00:34:47,200
0,210 210,360 360,960
{xv6 - -}.|
|

1169
00:34:47,680 --> 00:34:48,400
0,450

1170
00:34:49,680 --> 00:34:50,970
0,300 300,540 540,960 960,1140 1140,1290
{xv6 -} runs on the
xv6 运行在 RISC-V 处理器上，

1171
00:34:50,970 --> 00:34:53,760
0,330 330,1110 1140,2040 2190,2520 2520,2790
{RISC-V -} processor, {RISC-V -}

1172
00:34:53,760 --> 00:34:55,410
0,960 1110,1350 1350,1470 1470,1560 1560,1650
microprocessor,| and this is the
|这也是最近 6.004 课程使用的微处理器。

1173
00:34:55,410 --> 00:34:57,540
0,450 450,1260 1260,1560 1560,1710 1710,2130
same microprocessor that's the focus

1174
00:34:57,540 --> 00:34:58,830
0,150 150,570 570,900 900,1170 1170,1290
of recent {6.004 - -

1175
00:34:58,830 --> 00:34:59,700
0,510
-}.|
|

1176
00:34:59,800 --> 00:35:00,760
0,240 240,480 480,720 720,810 810,960
{} So many of you
所以，你们中的很多人可能对 RISC-V 指令集有相当多的了解。

1177
00:35:00,760 --> 00:35:03,040
0,90 90,600 990,1980 1980,2250 2250,2280
may actually know quite a

1178
00:35:03,040 --> 00:35:04,090
0,180 180,360 360,480 480,720 720,1050
bit about the {RISC-V -}

1179
00:35:04,090 --> 00:35:05,240
0,510 510,870
instruction set.|
|

1180
00:35:05,780 --> 00:35:07,430
0,360 900,1110 1110,1410 1410,1560 1560,1650
{} In theory you could
理论上你可以在 RISC-V 计算机上运行 xv6 ，

1181
00:35:07,430 --> 00:35:09,320
0,390 390,1290 1290,1440 1440,1770 1770,1890
run xv6 on top of

1182
00:35:09,320 --> 00:35:11,720
0,240 240,450 450,720 720,1350 2190,2400
a {RISC-V -} computer| and
|也已经有人这么做了。

1183
00:35:11,720 --> 00:35:14,160
0,270 270,480 480,810 1650,2160
people done that {}.|
|

1184
00:35:14,560 --> 00:35:15,430
0,390 390,510 510,630 630,690 690,870
But we're going to run
但是我们要在 QEMU 机器仿真器下运行，

1185
00:35:15,430 --> 00:35:16,570
0,150 150,360 360,480 480,900 900,1140
it under the {QEMU -

1186
00:35:16,570 --> 00:35:19,480
0,630 810,1620 1620,2280 2340,2700 2700,2910
-} machine emulator,| just write
|只需要把我们得到的写下来。

1187
00:35:19,480 --> 00:35:20,680
0,150 150,450 450,540 540,930
this down we got.|
|

1188
00:35:20,810 --> 00:35:22,190
0,210 210,600 600,990 990,1110 1110,1380
Our operating system is {xv6
我们的操作系统是 xv6 ，

1189
00:35:22,190 --> 00:35:24,950
0,210 210,990 1380,2070 2100,2460 2460,2760
- -},| {} runs on
|运行在 RISC-V 微处理器之上，

1190
00:35:24,950 --> 00:35:26,300
0,270 270,1080
{RISC-V -}

1191
00:35:26,720 --> 00:35:29,630
0,1080 1500,1980 1980,2160 2160,2400 2430,2910
microprocessor| and not just RISC-V
|不仅是 RISC-V 微处理器，

1192
00:35:29,630 --> 00:35:31,160
0,720 720,870 870,960 960,1440 1440,1530
microprocessor,| but we assume a
|还有周围的一些硬件，

1193
00:35:31,160 --> 00:35:32,870
0,330 330,630 630,750 750,1260 1260,1710
certain amount of surrounding hardware,|
|

1194
00:35:32,870 --> 00:35:35,120
0,450 720,990 1020,1800 1800,1920 1920,2250
like a memory and a
比如内存和磁盘。

1195
00:35:35,240 --> 00:35:36,120
0,690
disk,|
|

1196
00:35:36,280 --> 00:35:38,440
0,630 780,1470 1500,1950 1950,2040 2040,2160
and console interface for us
还有控制台界面，我们可以访问它。

1197
00:35:38,440 --> 00:35:40,030
0,90 90,330 330,450 450,630 1080,1590
to talk to it {}.|
|

1198
00:35:40,740 --> 00:35:41,850
0,210 210,540 540,780 780,1020 1020,1110
We actually run under the
我们实际上是在 QEMU 机器模拟器下运行的。

1199
00:35:41,850 --> 00:35:43,300
0,420 420,630 630,1140
{QEMU - -}

1200
00:35:44,720 --> 00:35:46,980
0,480 720,1200 1200,1920
{} machine simulator.|
|

1201
00:35:48,440 --> 00:35:49,820
0,150 150,300 300,720 750,1170 1170,1380
So that which runs under
也是在 Linux 下运行的。

1202
00:35:49,820 --> 00:35:51,590
0,390 390,750 870,1260 1350,1590 1590,1770
Linux.| So {} all you
|所以你可以在没有硬件的情况下运行 xv6 。

1203
00:35:51,590 --> 00:35:52,800
0,90 90,570
can actually

1204
00:35:53,400 --> 00:35:55,230
0,420 480,810 810,1410 1410,1650 1650,1830
{} run xv6 without having

1205
00:35:55,230 --> 00:35:56,120
0,150 150,630
that hardware.|
|

1206
00:35:56,860 --> 00:35:58,420
0,420 420,750 780,1050 1050,1140 1140,1560
Okay, so kind of switch
好的，现在切换到演示代码。

1207
00:35:58,420 --> 00:36:00,340
0,300 300,990 1320,1710 1710,1830 1830,1920
to {} show {} the

1208
00:36:00,340 --> 00:36:01,260
0,660
code.|
|

1209
00:36:15,570 --> 00:36:18,360
0,480 480,840 1230,2070 2250,2670 2670,2790
Alright, so, {} first thing
好的，那么第一件事是，

1210
00:36:18,360 --> 00:36:21,540
0,360 360,600 600,600 1140,2040 2490,3180
is,| I've {} setup xv6
|我已经在我的笔记本电脑上安装了 xv6 ，

1211
00:36:21,540 --> 00:36:22,660
0,90 90,180 180,870
on my laptop,|
|

1212
00:36:22,800 --> 00:36:24,270
0,540 660,960 960,1110 1110,1320 1320,1470
I'm going to run it
我要运行它，输入 make qemu ，

1213
00:36:24,720 --> 00:36:25,740
0,330 330,600 600,720 720,870 870,1020
type make {qemu - -},|
|

1214
00:36:25,740 --> 00:36:26,790
0,180 180,360 360,570 570,840 840,1050
but you'll find yourself doing
你会在实验中发现做了更多的工作，

1215
00:36:26,790 --> 00:36:27,420
0,210 210,240 240,360 360,570 570,630
quite a bit during the

1216
00:36:27,420 --> 00:36:29,580
0,720 900,1080 1080,1350 1350,1980 1980,2160
labs,| {} which compiles {xv6
|它编译 xv6 ，是用 C 编写的，

1217
00:36:29,580 --> 00:36:30,510
0,150 150,450 450,600 600,780 780,930
- -} it's written in

1218
00:36:30,510 --> 00:36:32,130
0,450 450,600 600,720 720,1260 1260,1620
C,| so it's compiled with
|所以它使用 C 编译器编译，

1219
00:36:32,520 --> 00:36:35,490
0,240 240,960 1470,1860 1860,2160 2520,2970
C compiler,| maybe I'll make
|我应该先输入 make clean 清理一下，

1220
00:36:35,490 --> 00:36:37,230
0,480 480,750 750,1080 1440,1650 1650,1740
clean for you,| so you
|这样你们就可以看到实际的编译过程，

1221
00:36:37,230 --> 00:36:38,730
0,90 90,270 270,360 360,690 690,1500
can see the actual compilation|
|

1222
00:36:39,000 --> 00:36:40,290
0,180 180,240 240,780 780,1110 1110,1290
and I might make {qemu
我再输入 make qemu ，

1223
00:36:40,290 --> 00:36:41,640
0,330 330,750 780,960 960,1050 1050,1350
-},| which has the effect
|它开始编译和构建 xv6 内核，

1224
00:36:41,640 --> 00:36:44,130
0,210 750,1410 1410,1530 1530,2100 2100,2490
of compiling and building {xv6

1225
00:36:44,130 --> 00:36:45,180
0,210 210,690 690,840 840,960 960,1050
-} kernel| and all the
|以及所有用户程序，

1226
00:36:45,180 --> 00:36:48,270
0,510 540,1290 1830,2340 2460,2790 2790,3090
user processes| and then running
|然后在 QEMU 模拟器上运行。

1227
00:36:48,270 --> 00:36:49,920
0,150 150,330 330,450 450,720 720,1650
them under the QEMU emulator.|
|

1228
00:36:51,860 --> 00:36:52,790
0,300 300,360 360,690 690,840 840,930
Takes a moment around the
编译过程会花费一些时间。

1229
00:36:52,790 --> 00:36:53,880
0,930
compiles.|
|

1230
00:36:55,020 --> 00:36:55,560
0,60
Yeah.|
好的。|

1231
00:36:56,000 --> 00:36:56,810
0,180 180,360 360,480 480,660 660,810
And now we're up and
现在我们启动并运行 xv6 ，

1232
00:36:56,810 --> 00:36:59,090
0,570 570,1350 1410,1710 1710,1860 1860,2280
running {} {xv6 - -},|
|

1233
00:36:59,090 --> 00:37:00,350
0,120 120,210 210,600 600,900 900,1260
and the dollar sign prompt
你看到的 shell 中的 $ 符号，

1234
00:37:00,350 --> 00:37:01,700
0,90 90,270 270,540 540,630 630,1350
you see as the shell,|
|

1235
00:37:02,270 --> 00:37:03,530
0,300 300,420 420,570 570,990 990,1260
which is the command line
shell 是 xv6 的命令行界面，

1236
00:37:03,530 --> 00:37:06,440
0,900 930,1530 1560,2010 2010,2460 2460,2910
interface {} to xv6,| modeled
|仿造 unix 上的 shell 。

1237
00:37:06,440 --> 00:37:08,360
0,270 270,570 900,1350 1350,1470 1470,1920
after the shell on unix,|
|

1238
00:37:08,360 --> 00:37:09,160
0,210 210,510
which is
也是如果你登录到 Athena 系统，

1239
00:37:09,420 --> 00:37:11,070
0,330 330,480 480,870 1050,1410 1410,1650
{} if you log into

1240
00:37:11,070 --> 00:37:13,710
0,510 510,1050 1050,1170 1170,1440 2340,2640
Athena organization| and it's {}
|就像 Athena shell 显示的那样。

1241
00:37:13,710 --> 00:37:14,880
0,150 150,480 480,570 570,1020 1020,1170
it's like the shell that

1242
00:37:14,880 --> 00:37:16,080
0,360 360,690 690,870
Athena shows you.|
|

1243
00:37:18,180 --> 00:37:20,310
0,900 930,1560 1560,1950 1950,2040 2040,2130
Xv6 itself tiny and it
xv6 本身很小，它附带了一些使用程序，

1244
00:37:20,310 --> 00:37:21,540
0,180 180,270 270,330 330,780 780,1230
comes with a small number

1245
00:37:21,540 --> 00:37:23,920
0,150 150,660 660,1560 1590,2010
of utility programs,| and
|包含比如 ls 程序，

1246
00:37:24,220 --> 00:37:25,540
0,420 420,540 540,840 840,930 930,1320
including for example the ls

1247
00:37:25,540 --> 00:37:26,500
0,420 420,570 570,660 660,870 870,960
program| which {} about to
|运行 ls ，它会给出一个所有文件的列表，

1248
00:37:26,500 --> 00:37:28,510
0,540 870,1320 1320,1800 1800,1890 1890,2010
run run ls and it

1249
00:37:28,510 --> 00:37:29,260
0,150 150,240 240,300 300,570 570,750
gives me a list of

1250
00:37:30,210 --> 00:37:31,470
0,330 330,450 450,870 870,990 990,1260
all the files| and {xv6
|xv6 只有二十多个文件，

1251
00:37:31,470 --> 00:37:32,250
0,300 300,360 360,510 510,660 660,780
-} of which there are

1252
00:37:32,250 --> 00:37:34,770
0,180 180,420 420,570 570,1050 1770,2520
only about two dozen| including
|包括 grep kill mkdir 和 rm ，

1253
00:37:34,830 --> 00:37:36,320
0,180 180,330 330,870 870,1170
things like grep and

1254
00:37:36,410 --> 00:37:38,540
0,660 660,840 840,1140 1140,1680 1740,2130
kill and {mkdir -} {rm

1255
00:37:38,540 --> 00:37:40,550
0,960 1020,1290 1290,1410 1410,1560 1560,2010
-},| which may be familiar
|这些是我们熟悉的 unix 实用程序。

1256
00:37:40,550 --> 00:37:41,840
0,120 120,660 660,990
to us {}

1257
00:37:42,160 --> 00:37:43,640
0,180 180,570 570,1230
as unix utilities.|
|

1258
00:37:44,930 --> 00:37:46,100
0,360 360,510 510,780 780,1080 1080,1170
Okay, the first program, I'm
好的，我要演示的第一个程序是，

1259
00:37:46,100 --> 00:37:47,210
0,150 150,360 360,540 540,600 600,1110
gonna show you| to illustrate
|演示系统调用 copy ，

1260
00:37:47,210 --> 00:37:50,960
0,330 330,870 870,1290 1590,2280 3330,3750
system calls is a program

1261
00:37:50,960 --> 00:37:52,380
0,180 180,810
called copy.|
|

1262
00:37:54,520 --> 00:37:54,960
0,330

1263
00:37:59,890 --> 00:38:01,220
0,690

1264
00:38:01,900 --> 00:38:02,860
0,270 270,360 360,690 690,780 780,960
Here's the source is just
这里的代码只有一页。

1265
00:38:02,860 --> 00:38:04,260
0,60 60,720
a page.|
|

1266
00:38:07,320 --> 00:38:09,510
0,720 1440,1650 1650,1770 1770,1890 1890,2190
{} So what you're seeing
你在这里看到的程序，从第 8 行开始，

1267
00:38:09,510 --> 00:38:11,100
0,150 150,240 240,300 300,1140 1470,1590
here is a program that

1268
00:38:11,100 --> 00:38:12,210
0,390 390,570 570,840 840,1020 1020,1110
starts on line eight| and
|main 是 C 语言程序的一种约定，

1269
00:38:12,210 --> 00:38:13,350
0,600 630,780 780,960 960,1080 1080,1140
main is that sort of

1270
00:38:13,350 --> 00:38:15,660
0,660 660,810 810,1020 1020,1800 2160,2310
convention for C programs,| it
|在第 12 行有一个循环，

1271
00:38:15,660 --> 00:38:16,500
0,240 240,300 300,390 390,720 720,840
sits in a loop at

1272
00:38:16,500 --> 00:38:17,740
0,270 270,870
line twelve,|
|

1273
00:38:17,940 --> 00:38:19,290
0,420 420,630 630,720 720,900 900,1350
and over and over again,|
一遍又一遍地

1274
00:38:19,710 --> 00:38:22,020
0,330 660,1440 1440,1620 1620,2100 2130,2310
it reads some data as
在第 13 行读取一些数据作为输入，

1275
00:38:22,020 --> 00:38:23,820
0,480 480,780 900,1050 1050,1260 1260,1800
input and on line thirteen,|
|

1276
00:38:23,820 --> 00:38:24,900
0,150 150,390 390,690 690,780 780,1080
and then writes the data
然后在第 16 行将刚才读取的数据写入输出。

1277
00:38:24,900 --> 00:38:27,120
0,210 210,690 1530,1740 1740,2070 2070,2220
just read his output on

1278
00:38:27,120 --> 00:38:28,180
0,270 270,780
line sixteen.|
|

1279
00:38:28,390 --> 00:38:29,800
0,420 420,1080
{By,run} copy,
运行 copy ，在 xv6 中，等待读取输入，

1280
00:38:32,130 --> 00:38:34,980
0,450 750,1260 1260,1770 2250,2730 2730,2850
{} in xv6, {it's,waitng} to

1281
00:38:34,980 --> 00:38:36,570
0,210 210,570 570,720 720,1110 1350,1590
read input,| if I type
|如果我输入一些内容，

1282
00:38:36,570 --> 00:38:37,740
0,150 150,750
some input,|
|

1283
00:38:37,840 --> 00:38:39,190
0,390 390,690 690,840 840,1050 1050,1350
{} reads it and spits
它读取并返回给我。

1284
00:38:39,190 --> 00:38:39,970
0,90 90,330 330,480 480,600 600,780
it back up to me.|
|

1285
00:38:41,640 --> 00:38:42,930
0,210 210,510 510,870 870,1080 1080,1290
Very simple program just does
很简单的程序，只是做输入输出。

1286
00:38:42,930 --> 00:38:44,380
0,480
io.|
|

1287
00:38:44,950 --> 00:38:45,970
0,300 300,450 450,690 690,900 900,1020
{} It's really see as
就像我提到的，如果你不是很了解 C 语言，

1288
00:38:45,970 --> 00:38:47,770
0,60 60,570 960,1200 1200,1410 1410,1800
I mentioned, {} if you

1289
00:38:47,830 --> 00:38:49,090
0,270 270,480 480,660 660,1050 1050,1260
don't already know C,| it's
|Kernighan 和 Ritchie 编写的 C 程序设计语言很值得阅读。

1290
00:38:49,090 --> 00:38:52,540
0,630 630,990 990,1260 2190,3060 3120,3450
worthwhile getting the standard C

1291
00:38:52,540 --> 00:38:54,310
0,390 390,750 750,960 960,1110 1110,1770
programming language book by Kernighan

1292
00:38:54,310 --> 00:38:55,100
0,510
{and,Ritchie}.|
|

1293
00:38:55,180 --> 00:38:56,080
0,210 210,300 300,450 450,690 690,900
And I think there's a
我想在课程网站上有更完整的参考资料，

1294
00:38:56,730 --> 00:38:58,710
0,360 360,1110 1140,1710 1710,1890 1890,1980
more full reference to it

1295
00:38:58,710 --> 00:39:01,200
0,210 210,510 780,1080 1080,1620 2130,2490
on the course website| which
|想你解释使用 C 编程的直接方法。

1296
00:39:01,290 --> 00:39:02,680
0,540 540,630 630,840 840,1080
explains to you and

1297
00:39:02,760 --> 00:39:04,260
0,510 540,750 750,1230 1230,1380 1380,1500
{} very straightforward way how

1298
00:39:04,260 --> 00:39:05,380
0,60 60,390 390,480 480,840
to program in C.|
|

1299
00:39:06,140 --> 00:39:06,440
0,60
Yeah,
是的，像我之前提到的，

1300
00:39:08,180 --> 00:39:09,350
0,360 360,390 390,660 660,1020 1020,1170
as I mentioned before,| we
|我们编写这个程序，

1301
00:39:09,350 --> 00:39:11,090
0,210 210,600 600,960 960,1230 1230,1740
even write this program| makes
|使用了两个实际上是三个系统调用，

1302
00:39:11,570 --> 00:39:13,070
0,300 300,510 510,840 840,1170 1170,1500
two really three system calls|
|

1303
00:39:13,070 --> 00:39:14,660
0,270 270,510 510,690 690,1080 1200,1590
read, write and exit, our
read write exit 系统调用。

1304
00:39:14,960 --> 00:39:16,320
0,450 450,990
system calls.|
|

1305
00:39:16,460 --> 00:39:17,690
0,420 810,960 960,1050 1050,1170 1170,1230
{} If you look at
如果你看第 13 行的 read 调用，

1306
00:39:17,690 --> 00:39:18,950
0,60 60,300 300,450 450,870 870,1260
the call to read {on,line}

1307
00:39:18,950 --> 00:39:21,470
0,840 1140,1290 1290,1590 1590,1800 1800,2520
thirteen,| it takes three arguments,|
|它有三个参数，|

1308
00:39:22,500 --> 00:39:23,220
0,90 90,330 330,630 630,690 690,720
the first argument is a
第一个参数是一个文件描述符，

1309
00:39:23,220 --> 00:39:24,390
0,300 300,750 750,930 930,1020 1020,1170
file descriptor| which is really
|它实际上是对之前打开的文件的引用。

1310
00:39:24,390 --> 00:39:25,800
0,90 90,630 630,750 750,840 840,1410
a reference to a previously

1311
00:39:25,800 --> 00:39:27,060
0,300 300,900
opened file.|
|

1312
00:39:27,340 --> 00:39:29,680
0,270 270,720 780,900 900,1710 1800,2340
{} And the shell, {}
shell 确保当程序启动时，

1313
00:39:29,770 --> 00:39:31,840
0,630 630,930 1230,1500 1500,1770 1770,2070
ensures that when a program

1314
00:39:31,840 --> 00:39:33,340
0,390 390,570 570,1260
starts,| by default
|默认它的文件描述符 0 连接到控制台输入，

1315
00:39:33,440 --> 00:39:35,000
0,270 270,570 570,990 990,1440 1440,1560
it's file descriptor zero is

1316
00:39:35,000 --> 00:39:36,860
0,600 600,750 750,990 1020,1440 1440,1860
connected to the console input|
|

1317
00:39:36,860 --> 00:39:38,780
0,90 90,240 240,720 1020,1440 1440,1920
and its file descriptor one
它的文件描述符 1 连接到控制台输出，

1318
00:39:38,780 --> 00:39:41,090
0,390 660,1110 1110,1200 1200,1770 1800,2310
is connected to the console

1319
00:39:41,090 --> 00:39:42,020
0,390 390,480 480,630 630,810 810,930
output| and that's why I
|这就是为什么我能对 copy 程序输入，并查看输出。

1320
00:39:42,020 --> 00:39:43,220
0,150 150,330 330,450 450,780 780,1200
was able to type to

1321
00:39:43,920 --> 00:39:46,020
0,150 150,480 480,990 990,1410 1800,2100
this copy program and see

1322
00:39:46,020 --> 00:39:46,900
0,150 150,600
the output.|
|

1323
00:39:48,700 --> 00:39:50,770
0,540 1080,1320 1320,1410 1410,1710 1710,2070
{} You know these file
你知道，这些文件描述符期望，

1324
00:39:50,770 --> 00:39:53,110
0,480 480,690 1200,1890 1890,2010 2010,2340
descriptors are expected| the program
|程序期望这些文件描述符已经打开，

1325
00:39:53,110 --> 00:39:54,640
0,420 420,600 600,840 840,1350 1350,1530
expected these file descriptors have

1326
00:39:54,640 --> 00:39:56,050
0,120 120,660 660,990 990,1140 1140,1410
been previously opened| and set
|并由 shell 为其设置。

1327
00:39:56,050 --> 00:39:57,070
0,150 150,300 300,390 390,780 810,1020
up by the shell for

1328
00:39:57,070 --> 00:39:57,500
0,90
it.|
|

1329
00:39:57,600 --> 00:40:01,170
0,540 660,1530 1530,2280 2640,2940 2940,3570
And zero one file descriptors,
0 1 文件描述符是 unix 的普遍约定，

1330
00:40:01,920 --> 00:40:04,020
0,630 630,990 990,1560 1560,1860 1860,2100
pervasive unix convention,| many, many
|很多 unix 程序希望

1331
00:40:04,020 --> 00:40:05,790
0,330 330,750 750,1080 1080,1200 1200,1770
unix programs expect to| [read
|[误：从文件描述符 1 读取]，

1332
00:40:06,090 --> 00:40:07,830
0,150 150,420 420,870 870,1350 1350,1740
from file descriptor one]| and
|读取文件描述符 0 ，并写入文件描述符 1 。

1333
00:40:08,250 --> 00:40:09,810
0,360 360,570 570,930 930,1380 1380,1560
read file descriptor zero and

1334
00:40:09,810 --> 00:40:11,190
0,270 270,360 360,630 630,1020 1020,1380
write to file descriptor one.|
|

1335
00:40:12,730 --> 00:40:14,500
0,330 540,900 900,1290 1290,1410 1410,1770
A second argument to read
read 的第二个参数是一个指向内存的指针。

1336
00:40:14,500 --> 00:40:15,880
0,180 180,450 480,1020 1020,1140 1140,1380
is a pointer to some

1337
00:40:15,880 --> 00:40:17,000
0,660
memory.|
|

1338
00:40:17,160 --> 00:40:18,180
0,240 240,450 450,570 570,900 900,1020
{} Where the program is
程序告诉操作系统

1339
00:40:18,180 --> 00:40:19,710
0,420 420,540 540,930 930,1320 1320,1530
asking the operating system| to
|从这个内存地址读取数据，

1340
00:40:19,710 --> 00:40:21,020
0,360 360,870
read data

1341
00:40:21,390 --> 00:40:22,710
0,240 240,480 480,840 840,930 930,1320
into that address in memory,|
|

1342
00:40:22,710 --> 00:40:23,970
0,90 90,270 270,420 420,780 780,1260
so that's the buf argument|
这是 buf 参数，|

1343
00:40:24,630 --> 00:40:25,800
0,150 150,360 360,810
and line ten
在第 10 行，在栈上分配了 64 字节的内存。

1344
00:40:26,000 --> 00:40:28,100
0,480 480,1110 1110,1410 1410,1470 1470,2100
allocate 64 bytes of memory

1345
00:40:28,130 --> 00:40:30,060
0,150 150,240 240,720 1140,1620
on the stack {},|
|

1346
00:40:30,350 --> 00:40:31,520
0,180 180,420 420,540 540,750 750,1170
for read to read into.|
供 read 读取。|

1347
00:40:31,700 --> 00:40:32,720
0,150 150,210 210,450 450,840 840,1020
And the third argument to
read 的第三个参数是程序想要读入的最大字节数，

1348
00:40:32,720 --> 00:40:34,130
0,240 240,390 390,480 480,1080 1080,1410
read is the maximum number

1349
00:40:34,130 --> 00:40:35,300
0,90 90,600 600,780 780,840 840,1170
of bytes that the program
|

1350
00:40:35,300 --> 00:40:36,740
0,240 240,360 360,780 1170,1350 1350,1440
wants to read| and the
|而 buf 的大小最大是 64 字节，

1351
00:40:36,740 --> 00:40:38,360
0,300 300,390 390,750 750,1260 1380,1620
size of buf as just

1352
00:40:38,360 --> 00:40:40,850
0,420 450,1020 1050,1560 1560,2010 2370,2490
sixty maximum 64 bytes,| so
|所以 read 读取最多 64 字节，

1353
00:40:40,850 --> 00:40:41,900
0,90 90,540 540,720 720,960 960,1050
the {read,call} reads up to

1354
00:40:41,900 --> 00:40:44,450
0,510 510,930 930,1140 1140,1830 2400,2550
64 bytes| from whatever is
|从文件描述符 0 连接的地方，

1355
00:40:44,450 --> 00:40:45,860
0,360 360,420 420,630 630,990 990,1410
connected to file descriptor zero|

1356
00:40:45,860 --> 00:40:46,860
0,180 240,420 420,690
and that was
在本例中， 0 就是连接到我的终端。

1357
00:40:47,080 --> 00:40:48,520
0,270 270,720 720,810 810,960 960,1440
my terminal in this example,|
|

1358
00:40:48,820 --> 00:40:50,380
0,300 300,630 630,930 930,1110 1110,1560
the return value from read
read 的返回值可能是读取到的字节数，

1359
00:40:51,040 --> 00:40:52,690
0,150 150,420 420,810 1320,1560 1560,1650
it either it may be

1360
00:40:52,690 --> 00:40:53,290
0,150 150,210 210,270 270,540 540,600
sure of the number of

1361
00:40:53,290 --> 00:40:55,390
0,330 330,900 1350,1620 1620,1950 1950,2100
bytes read,| {} which would
|这里是 6 ，

1362
00:40:55,390 --> 00:40:57,100
0,420 720,1260 1260,1350 1350,1410 1410,1710
be six and a piece

1363
00:40:57,100 --> 00:40:59,740
0,630 780,1140 1140,1500 1500,2250 2250,2640
of {},| typing xyzzy by.|
|我输入 xyzzy 。|

1364
00:41:00,070 --> 00:41:00,740
0,360

1365
00:41:01,150 --> 00:41:02,200
0,330 330,540 540,630 630,930 930,1050
Read might be reading from
read 也可以从文件中读取，

1366
00:41:02,200 --> 00:41:03,160
0,120 120,600 630,750 750,810 810,960
a file,| if it gets
|如果到达文件末尾，

1367
00:41:03,160 --> 00:41:03,730
0,90 90,210 210,420 420,480 480,570
to the end of the

1368
00:41:03,730 --> 00:41:05,110
0,360 360,540 540,630 630,840 840,1380
file,| there's no more bytes,|
|没有更多字节，|

1369
00:41:05,110 --> 00:41:06,760
0,210 210,360 360,690 690,1260
read will return zero.|
read 将返回 0 。|

1370
00:41:07,160 --> 00:41:08,390
0,210 210,390 420,660 660,930 930,1230
And then some other error
如果发生其他错误，

1371
00:41:08,390 --> 00:41:10,340
0,510 510,780 1080,1200 1200,1440 1440,1950
occurred,| like the file descriptor
|比如文件描述符不存在，

1372
00:41:10,340 --> 00:41:12,380
0,270 270,840 1080,1350 1350,1560 1560,2040
doesn't exist,| read may return
|read 可能会返回 -1 。

1373
00:41:12,380 --> 00:41:13,440
0,360 360,780
minus one.|
|

1374
00:41:13,780 --> 00:41:15,160
0,120 120,420 990,1110 1110,1320 1320,1380
And so in many of
在很多例子中，比如在第 16 行。

1375
00:41:15,160 --> 00:41:16,600
0,180 180,780 780,960 960,1080 1080,1440
these examples like on line

1376
00:41:16,600 --> 00:41:17,860
0,510 510,960
sixteen there.|
|

1377
00:41:17,940 --> 00:41:19,860
0,360 390,510 510,840 1050,1440 1470,1920
{} I don't, my example
我的示例代码没有检查系统调用返回是否有错误，

1378
00:41:19,860 --> 00:41:21,810
0,360 360,780 780,1200 1200,1680 1680,1950
code doesn't check system call

1379
00:41:21,810 --> 00:41:24,240
0,510 510,720 720,1380
returns for errors.|
|

1380
00:41:24,540 --> 00:41:25,380
0,270 270,420 420,540 540,660 660,840
But you should be more
但是你应该比我更小心，

1381
00:41:25,380 --> 00:41:27,540
0,360 360,480 480,840 960,1410 1950,2160
careful than me {} {},|
|

1382
00:41:27,540 --> 00:41:28,860
0,420 510,690 690,810 810,1140 1140,1320
the you should figure out
你应该弄清楚系统调用是如何返回错误的，

1383
00:41:28,860 --> 00:41:30,750
0,360 360,690 690,1140 1230,1620 1620,1890
how system calls reflect errors,|
|

1384
00:41:30,750 --> 00:41:31,860
0,150 150,390 390,450 450,750 750,1110
it's usually a minus one
通常是返回 -1 ，

1385
00:41:31,860 --> 00:41:34,170
0,360 360,780 1110,1500 1650,2040 2070,2310
return value| and check all
|并检查所有系统调用的返回是否有错误。

1386
00:41:34,170 --> 00:41:36,360
0,300 300,660 870,1530 1530,1650 1650,2190
system called returns for errors.|
|

1387
00:41:37,280 --> 00:41:38,510
0,300 390,750 810,1020 1020,1170 1170,1230
And if you want to
如果你想知道系统调用参数和返回值是什么，

1388
00:41:38,510 --> 00:41:40,130
0,120 120,300 300,510 900,1260 1260,1620
know what the system call

1389
00:41:40,130 --> 00:41:41,360
0,330 330,420 420,720 720,1080 1080,1230
arguments and return values are,|
|

1390
00:41:41,360 --> 00:41:42,680
0,180 180,270 270,720 720,1020 1020,1320
there's a table and I
这里有一个表格，我想是在书中的第 2 章。

1391
00:41:42,950 --> 00:41:43,820
0,210 210,510 510,720 720,810 810,870
think chapter two in the

1392
00:41:43,820 --> 00:41:46,250
0,390 1320,1890 1890,2160 2160,2250 2250,2430
book,| explains all of the
|解释了所有 xv6 系统调用参数和返回值。

1393
00:41:46,250 --> 00:41:48,980
0,360 360,1110 1380,1710 1710,1950 1950,2730
{xv6 -} system call arguments

1394
00:41:48,980 --> 00:41:50,500
0,510
and

1395
00:41:50,880 --> 00:41:53,790
0,360 360,930 1890,2010 2010,2400 2400,2910
return values.| The question regarding
|关于 read 系统调用的问题。

1396
00:41:53,790 --> 00:41:55,920
0,360 360,1050 1050,1440 1650,1950 1950,2130
the read syscall.| What if
|如果我们将最大读取字节数

1397
00:41:55,920 --> 00:41:57,120
0,210 210,480 480,540 540,960 960,1200
we set the max read

1398
00:41:57,120 --> 00:41:58,860
0,240 240,750 750,1080 1080,1230 1230,1740
bytes to| size of buf
|设置为 buf 大小加 1 ，

1399
00:41:58,860 --> 00:42:00,240
0,240 240,660 660,990 990,1260 1260,1380
to one plus size of

1400
00:42:00,240 --> 00:42:01,830
0,510 510,960 1260,1380 1380,1500 1500,1590
buf big,| so what if
|所以如果我们尝试读取的大小超过该大小会怎样。

1401
00:42:01,830 --> 00:42:02,520
0,90 90,270 270,330 330,480 480,690
we try to read more

1402
00:42:02,520 --> 00:42:03,690
0,150 150,210 210,510 510,780 780,1170
than the size.| Yeah, then
|是的，如果有 65 个字节要读取，

1403
00:42:03,690 --> 00:42:06,180
0,480 480,600 600,750 750,1890 1890,2490
if there was 65 bytes

1404
00:42:06,180 --> 00:42:08,010
0,120 120,690 720,1110 1110,1470 1500,1830
to read,| then the operating
|操作系统会很高兴地把这 65 个字节复制到你提供的内存上，

1405
00:42:08,010 --> 00:42:09,690
0,360 360,510 510,1320 1320,1440 1440,1680
system would happily will just

1406
00:42:10,130 --> 00:42:12,800
0,360 360,570 570,1260 1260,2100 2520,2670
copy those sixty-five bytes to

1407
00:42:12,800 --> 00:42:14,750
0,60 60,900 930,1050 1050,1200 1200,1950
the memory that you provide,|
|

1408
00:42:14,780 --> 00:42:16,790
0,420 780,900 900,1410 1530,1770 1770,2010
and of course there's something
当然还有栈上的其他东西，

1409
00:42:16,790 --> 00:42:17,660
0,180 180,240 240,300 300,690 690,870
else on the stack up

1410
00:42:17,660 --> 00:42:19,700
0,360 390,930 1080,1200 1200,1620 1620,2040
there,| maybe the return program
|可能是返回程序计数器，

1411
00:42:19,700 --> 00:42:20,870
0,450 450,570 570,630 630,1140 1140,1170
counter| or an argument or
|或者参数或其他东西，

1412
00:42:20,870 --> 00:42:22,460
0,540 690,1080 1140,1380 1380,1500 1500,1590
something| and so if you
|所以如果你传入 65 个字节，

1413
00:42:22,460 --> 00:42:24,770
0,210 210,1110 1470,1680 1680,1890 1890,2310
pass 65,| then you're inviting
|那么你就是让内核

1414
00:42:24,770 --> 00:42:26,660
0,120 120,690 690,930 930,1320 1320,1890
a kernel| to write junk
|在栈上意想不到的位置写入垃圾数据。

1415
00:42:27,120 --> 00:42:28,920
0,660 750,900 900,1020 1020,1560 1560,1800
{} to an unexpected place

1416
00:42:28,920 --> 00:42:29,840
0,120 120,240 240,630
in your stack.|
|

1417
00:42:30,280 --> 00:42:31,360
0,300 300,390 390,540 540,600 600,1080
And so that's a bug|
因此，这是一个 bug ，|

1418
00:42:31,840 --> 00:42:32,950
0,570 570,630 630,750 750,990 990,1110
and it may cause your
它可能会导致你的程序崩溃。

1419
00:42:32,950 --> 00:42:34,160
0,210 210,300 300,990
[] to crash,|
|

1420
00:42:34,420 --> 00:42:36,340
0,120 120,270 270,510 510,1290 1320,1920
or do something else unexpected,|
或者做一些其他意想不到的事情，|

1421
00:42:37,390 --> 00:42:38,770
0,240 240,390 390,450 450,1260 1260,1380
so as a programmer, you
因此作为一个程序员，在这里必须小心，

1422
00:42:38,770 --> 00:42:39,580
0,120 120,210 210,300 300,660 660,810
have to be careful here,|
|

1423
00:42:39,580 --> 00:42:41,860
0,150 150,720 1110,1470 1470,1590 1590,2280
there's nobody writing in C
没有人使用 C 语言这样使用接口，

1424
00:42:41,860 --> 00:42:42,940
0,120 120,270 270,450 450,510 510,1080
with these kind of interfaces,|

1425
00:42:42,940 --> 00:42:43,540
0,420

1426
00:42:43,830 --> 00:42:45,960
0,540 1050,1200 1200,1560 1560,1890 1890,2130
{} it's very very easy
很容易编写的代码，

1427
00:42:45,960 --> 00:42:47,610
0,120 120,360 360,930 960,1230 1560,1650
to write code| that the
|编译器可以通过，并且可以运行，

1428
00:42:47,610 --> 00:42:48,720
0,390 390,480 480,810 810,1020 1020,1110
compiler is happy with and

1429
00:42:48,720 --> 00:42:50,340
0,120 120,480 480,690 750,1410 1410,1620
will run| but absolutely does
|但是做的是错误的事。

1430
00:42:50,340 --> 00:42:51,340
0,90 90,360 360,660
the wrong thing.|
|

1431
00:42:51,660 --> 00:42:55,350
0,450 1470,2010 3060,3330 3330,3450 3450,3690
{} So that's too bad
那太糟糕了，但事情就是这样。

1432
00:42:55,350 --> 00:42:56,730
0,210 390,1080 1080,1170 1170,1290 1290,1380
but it's the way it

1433
00:42:56,730 --> 00:42:57,320
0,390
is.|
|

1434
00:43:00,540 --> 00:43:01,860
0,390 540,810 810,1110 1110,1230 1230,1320
Okay, {} one thing to
好的，有一件事需要注意，

1435
00:43:01,860 --> 00:43:04,170
0,450 450,630 630,930 1680,1890 1890,2310
note is| that this copy
|这里的 copy 程序和 read write 系统调用，

1436
00:43:04,170 --> 00:43:05,520
0,570 570,660 660,1020 1020,1110 1110,1350
program and indeed the read

1437
00:43:05,520 --> 00:43:07,050
0,180 180,450 450,930 1200,1320 1320,1530
write system calls,| they don't
|它们不关心数据的格式，

1438
00:43:07,050 --> 00:43:08,190
0,360 360,600 600,690 690,1050 1050,1140
care about the format of

1439
00:43:08,190 --> 00:43:09,480
0,270 270,450 450,750 750,840 840,1290
data,| they're reading or writing
|它们只是在 copy 程序中读写，再读写。

1440
00:43:09,660 --> 00:43:10,860
0,210 210,360 360,720 810,1080 1080,1200
{} they just read and

1441
00:43:10,860 --> 00:43:12,480
0,420 540,930 930,1050 1050,1380 1470,1620
write read and write in

1442
00:43:12,480 --> 00:43:13,820
0,150 150,480 480,960
this copy program.|
|

1443
00:43:13,980 --> 00:43:15,120
0,360 360,570 570,750 750,960 960,1140
Just deal with eight bit
只是处理八位字节，使用八位字节流。

1444
00:43:15,120 --> 00:43:16,500
0,510 510,660 660,1110 1110,1200 1200,1380
bytes with screams of eight

1445
00:43:16,500 --> 00:43:17,600
0,210 210,840
bit bytes.|
|

1446
00:43:17,680 --> 00:43:19,780
0,540 930,1200 1200,1350 1350,1830 1830,2100
{} How you interpret them
如何解释它们，完全取决于应用程序。

1447
00:43:19,780 --> 00:43:20,680
0,270 270,600 600,720 720,810 810,900
is totally up to the

1448
00:43:20,680 --> 00:43:22,810
0,540 540,660 660,750 750,1410 1410,2130
application,| so the application maybe
|应用程序可能会解析数据记录作为 C 代码，

1449
00:43:23,300 --> 00:43:25,610
0,180 180,1020 1080,1410 1410,1740 1740,2310
{} parse these data records

1450
00:43:25,610 --> 00:43:26,840
0,180 180,300 300,630 630,960 960,1230
or as C source code,|
|

1451
00:43:26,840 --> 00:43:28,100
0,90 90,270 270,480 480,840
or who knows what.|
或者其他的格式。|

1452
00:43:28,890 --> 00:43:31,260
0,240 240,540 540,1110 1500,2100
The operating system {},
操作系统只知道这是八位字节流。

1453
00:43:33,030 --> 00:43:34,050
0,60 60,390 390,630 630,690 690,1020
the only things in terms

1454
00:43:34,050 --> 00:43:34,830
0,60 60,150 150,510 510,600 600,780
of a stream of eight

1455
00:43:34,830 --> 00:43:36,120
0,150 150,630
bit bytes.|
|

1456
00:43:36,220 --> 00:43:38,380
0,300 300,660 750,1200 1200,1830 1830,2160
Okay, so copy, assumed this
好的，所以 copy 可以假设文件描述符已经设置好，

1457
00:43:38,380 --> 00:43:39,580
0,420 420,570 570,930 930,1020 1020,1200
code, my copy I can

1458
00:43:39,580 --> 00:43:40,900
0,360 360,450 450,540 540,780 780,1320
assume that the file descriptors

1459
00:43:40,900 --> 00:43:42,670
0,90 90,270 270,540 540,870 1350,1770
are already set up {},|
|

1460
00:43:42,850 --> 00:43:44,230
0,180 180,300 300,450 450,840 1140,1380
but we need to need
但是我们需要有一种方法来创建文件描述符。

1461
00:43:44,230 --> 00:43:44,680
0,60 60,150 150,240 240,360 360,450
to have a way to

1462
00:43:44,680 --> 00:43:46,220
0,330 330,570 570,1320
create file descriptors.|
|

1463
00:43:46,280 --> 00:43:47,600
0,360 420,540 540,720 720,1200 1200,1320
And the most straightforward way
创建文件描述符的最直接的方法是使用 open 系统调用，

1464
00:43:47,600 --> 00:43:49,820
0,90 90,270 270,570 660,1200 1590,2220
to do that is {}

1465
00:43:50,210 --> 00:43:51,680
0,150 150,270 270,600 600,930 930,1470
with the open system call,|
|

1466
00:43:51,710 --> 00:43:52,730
0,120 120,240 240,450 450,540 540,1020
and so here's the source
这是一个调用 open 的程序代码，

1467
00:43:52,730 --> 00:43:54,650
0,180 180,270 270,1020 1020,1260 1620,1920
for a program that called

1468
00:43:54,650 --> 00:43:55,520
0,510
open,|
|

1469
00:43:55,720 --> 00:43:57,180
0,390 540,1200
That {},|
那个，

1470
00:43:58,120 --> 00:43:59,380
0,180 180,540 540,690 690,930 930,1260
I use the open system
我使用 open 系统调用。

1471
00:43:59,380 --> 00:44:01,120
0,390 870,990 990,1380 1380,1620 1620,1740
call.| A question from the
|聊天中有一个问题，

1472
00:44:01,120 --> 00:44:02,530
0,450 480,750 750,810 810,1050 1050,1410
chat,| what do you mean
|你说的字节流是什么意思。

1473
00:44:02,530 --> 00:44:04,570
0,450 450,660 660,1290 1290,1440 1440,2040
by a stream of bytes.|
|

1474
00:44:07,190 --> 00:44:08,930
0,90 90,90 990,1290 1290,1500 1500,1740
{} I I just mean
我的意思是如果一个文件包含一些字节，

1475
00:44:08,930 --> 00:44:10,580
0,180 180,330 330,450 450,900 900,1650
that if a file contains

1476
00:44:10,580 --> 00:44:12,060
0,60 60,300 300,360 360,1260
a bunch of bytes,|
|

1477
00:44:12,180 --> 00:44:14,580
0,510 510,1110 1110,1290 1290,1950 2040,2400
then read then successive spilling
然后读取连续一百万字节的内容，

1478
00:44:14,580 --> 00:44:15,810
0,90 90,420 420,870 870,930 930,1230
a pile contains a million

1479
00:44:15,810 --> 00:44:17,310
0,660 1050,1170 1170,1290 1290,1440 1440,1500
bytes,| if you make a
|如果你进行连续的 read 调用，

1480
00:44:17,310 --> 00:44:19,950
0,540 540,810 1050,1890 1890,2250 2250,2640
sequence of {read,calls},| each {for,100}
|每次 100 字节，

1481
00:44:19,950 --> 00:44:21,040
0,720
bytes,|
|

1482
00:44:21,160 --> 00:44:22,030
0,120 120,240 240,390 390,720 720,870
you know I'll just read
你知道，只会读取第一个 100 字节，

1483
00:44:22,030 --> 00:44:22,990
0,90 90,300 300,510 510,870 870,960
the first hundred bytes| and
|然后是第二个 100 字节，

1484
00:44:22,990 --> 00:44:24,010
0,120 120,210 210,480 480,720 720,1020
then the second hundred bytes

1485
00:44:24,010 --> 00:44:24,970
0,90 90,240 240,570 570,660 660,960
and| then third, the third
|然后是第三个 100 字节。

1486
00:44:24,970 --> 00:44:27,260
0,270 270,840
hundred bytes,|
|

1487
00:44:27,960 --> 00:44:28,880
0,180 180,630
That's all.|
就是这样。|

1488
00:44:32,000 --> 00:44:33,830
0,330 330,420 420,600 600,1260 1350,1830
Alright, so this program, {}
好的，那么这个程序调用 open ，我来运行它，

1489
00:44:33,830 --> 00:44:35,570
0,270 270,750 1080,1440 1440,1620 1620,1740
called open, I'll run it

1490
00:44:35,570 --> 00:44:36,380
0,210 210,450
for you.|
|

1491
00:44:36,720 --> 00:44:38,100
0,180 180,390 390,480 480,870 870,1380
{} What it does is
它所做的是创建一个名为 output.txt 的新文件，

1492
00:44:38,730 --> 00:44:40,140
0,390 420,900 900,1260 1260,1290 1290,1410
{} open creates a new

1493
00:44:40,140 --> 00:44:41,940
0,390 390,660 660,990 990,1230 1230,1800
file called {output.txt - -},|
|

1494
00:44:41,940 --> 00:44:43,650
0,120 120,300 300,570 570,990 1260,1710
and then write some bytes
然后向其中写入一些字节，

1495
00:44:43,650 --> 00:44:45,480
0,120 120,330 870,1380 1380,1530 1530,1830
to it,| I'm gonna finish
|我已经完成了这个操作，

1496
00:44:45,480 --> 00:44:46,170
0,210 210,300 300,390 390,510 510,690
this,| so we don't see
|但是我们看不到任何东西，

1497
00:44:46,170 --> 00:44:48,180
0,450 450,690 690,840 1320,1650 1650,2010
anything,| because it broke data,
|因为它将数据放到了这个文件中，

1498
00:44:48,180 --> 00:44:49,260
0,210 210,510 510,840 840,960 960,1080
this file,| open, but we
|但是我们可以查看它创建的 output.txt 文件，

1499
00:44:49,260 --> 00:44:50,380
0,420 420,780
can look

1500
00:44:50,700 --> 00:44:52,290
0,240 240,600 600,840 840,1380 1380,1590
this {output.txt - -} file

1501
00:44:52,290 --> 00:44:54,870
0,180 180,570 570,810 1200,1770 1980,2580
that created it,| and see
|可以看到 ooo 写在那里。

1502
00:44:55,110 --> 00:44:57,030
0,300 300,420 420,1290 1290,1560 1590,1920
{} the {"ooo" -} wrote

1503
00:44:57,030 --> 00:44:58,710
0,210 360,690 1020,1200 1200,1590 1590,1680
there,| so an eleven in
|程序中的第 11 行调用了 open 系统调用，

1504
00:44:58,710 --> 00:45:00,100
0,90 90,930
the program

1505
00:45:00,430 --> 00:45:02,020
0,330 330,450 450,720 720,1140 1140,1590
makes the open system call,|
|

1506
00:45:02,380 --> 00:45:03,910
0,360 360,450 450,510 510,1230 1230,1530
give it a filename {output.txt
给它一个文件名 output.txt ，

1507
00:45:03,910 --> 00:45:05,980
0,180 180,840 840,1050 1260,1500 1560,2070
- -}| and the O
|open 中第二个参数中的 O_ 选项或标志，

1508
00:45:05,980 --> 00:45:07,780
0,120 120,570 570,1260 1350,1710 1710,1800
{underscore -} stuff {} in

1509
00:45:07,780 --> 00:45:08,860
0,90 90,390 390,690 690,750 750,1080
the second argument to open

1510
00:45:08,860 --> 00:45:11,410
0,210 390,1380 1380,1560 1950,2400 2400,2550
or flags| that tell the
|告诉内核中实现的 open 系统调用，

1511
00:45:11,410 --> 00:45:13,390
0,300 300,660 660,1170 1200,1920 1920,1980
open system call implementation in

1512
00:45:13,390 --> 00:45:14,650
0,60 60,540 540,750 840,1110 1110,1260
the kernel,| that we'd like
|我们想要使用这个名字创建一个文件，并且写入。

1513
00:45:14,650 --> 00:45:15,820
0,150 180,630 630,720 720,1050 1050,1170
to create a file with

1514
00:45:15,820 --> 00:45:17,170
0,210 210,660 810,1080 1110,1230 1230,1350
its name and we're going

1515
00:45:17,170 --> 00:45:18,020
0,90 90,300 300,420
to write it,|
|

1516
00:45:18,860 --> 00:45:20,720
0,390 390,810 810,930 930,1380 1380,1860
open returns a newly allocated
open 返回新分配的文件描述符。

1517
00:45:20,720 --> 00:45:22,000
0,270 270,990
file descriptor.|
|

1518
00:45:22,570 --> 00:45:23,340
0,540

1519
00:45:23,740 --> 00:45:24,490
0,150 150,210 210,360 360,690 690,750
And the file descriptor is
文件描述符只是一个很小的数字，

1520
00:45:24,490 --> 00:45:26,170
0,180 180,240 240,570 570,1110 1320,1680
just a small number,| probably
|

1521
00:45:26,170 --> 00:45:26,890
0,180 180,240 240,420 420,480 480,720
two or three or four
可能是 2 3 或 4 等。

1522
00:45:26,890 --> 00:45:27,760
0,510
something.|
|

1523
00:45:28,430 --> 00:45:29,360
0,240 240,420 420,510 510,780 780,930
And then we pass that
然后我们将相同的文件描述符与缓冲区一起传递，

1524
00:45:29,360 --> 00:45:31,580
0,240 240,480 480,1020 1020,1470 1920,2220
same file descriptor right along

1525
00:45:31,580 --> 00:45:32,960
0,90 90,150 150,690 690,1020
with the buffer| and
|

1526
00:45:33,050 --> 00:45:33,980
0,240 240,510 510,570 570,810 810,930
a number of ways to
有多种方式写入数据，

1527
00:45:33,980 --> 00:45:36,410
0,390 750,960 960,1320 1320,1620 1620,2430
write {} that writes data,|
|

1528
00:45:37,040 --> 00:45:38,420
0,150 150,300 300,900 900,1140 1140,1380
{} the file, the file
对于文件描述符索引用的文件。

1529
00:45:38,420 --> 00:45:40,080
0,600 630,1110 1110,1350
descriptor refers to.|
|

1530
00:45:41,430 --> 00:45:42,630
0,270 270,480 480,780 780,1140 1140,1200
What that file descriptor is
文件描述符实际上做的是

1531
00:45:42,630 --> 00:45:44,670
0,270 270,810 810,1230 1230,1830 1830,2040
actually doing is| indexing into
|索引到内核中一个维护进程状态的表中，

1532
00:45:44,670 --> 00:45:46,260
0,90 90,330 330,1020 1050,1500 1500,1590
a little table inside the

1533
00:45:46,260 --> 00:45:48,840
0,660 660,1230 1230,1710 2070,2250 2250,2580
kernel maintains state for each

1534
00:45:48,840 --> 00:45:50,700
0,570 570,780 780,1260 1290,1500 1500,1860
process,| that's running each program
|就是你运行的每个程序，

1535
00:45:50,700 --> 00:45:52,020
0,120 120,240 240,630 960,1080 1080,1320
that you run and among

1536
00:45:52,020 --> 00:45:53,610
0,240 240,600 600,720 720,1020 1020,1590
other things,| the kernel remembers
|内核会为通过文件描述符索引运行的进程记住一张表，

1537
00:45:53,610 --> 00:45:55,440
0,60 60,570 570,750 750,1380 1530,1830
a table for every running

1538
00:45:55,440 --> 00:45:57,630
0,570 570,900 1290,1740 1740,1890 1890,2190
process of index by file

1539
00:45:57,630 --> 00:46:00,030
0,870 1200,1650 1650,1800 1800,2220 2220,2400
descriptors| and the table sort
|这张表告诉内核每个文件描述符引用的是什么。

1540
00:46:00,030 --> 00:46:01,590
0,120 540,900 900,990 990,1290 1290,1560
of tells the kernel what

1541
00:46:01,590 --> 00:46:03,420
0,210 210,510 510,1170 1230,1710 1710,1830
each file descriptor refers to.|
|

1542
00:46:05,040 --> 00:46:05,740
0,450
Okay,
好的，关键点是每个进程都有自己的文件描述符空间。

1543
00:46:08,020 --> 00:46:10,390
0,900 930,1650 1680,2070 2070,2190 2190,2370
a critical point is that

1544
00:46:10,390 --> 00:46:12,130
0,150 150,570 570,750 750,930 960,1740
each process has its own

1545
00:46:12,220 --> 00:46:13,660
0,270 270,390 390,990 990,1080 1080,1440
sort of space of file

1546
00:46:13,660 --> 00:46:15,040
0,690 690,990
descriptors.| So,
|因此，在运行两个不同的进程前，

1547
00:46:15,200 --> 00:46:17,420
0,450 450,690 690,900 900,1560 1560,2220
before running two different processes,

1548
00:46:17,420 --> 00:46:18,740
0,150 150,420 420,960 960,1050 1050,1320
two different programs and different

1549
00:46:18,740 --> 00:46:20,480
0,720 900,1050 1050,1140 1140,1470 1470,1740
processes| and they both open
|它们都会打开一个文件，

1550
00:46:20,480 --> 00:46:21,470
0,120 120,510 510,630 630,750 750,990
a file,| they may actually
|它们可能会得到相同的文件描述符编号，

1551
00:46:21,470 --> 00:46:23,000
0,180 180,240 240,690 690,1170 1170,1530
get the same number back

1552
00:46:23,000 --> 00:46:24,560
0,120 120,180 180,450 450,1080 1350,1560
as a file descriptor,| but
|但是因为内核为每个进程维护单独的文件描述符，

1553
00:46:24,560 --> 00:46:25,760
0,330 330,420 420,720 720,1140 1140,1200
because the kernel maintains a

1554
00:46:25,760 --> 00:46:27,800
0,690 690,1080 1080,1620 1620,1770 1770,2040
separate file descriptor for each

1555
00:46:27,800 --> 00:46:29,000
0,900
process,|
|

1556
00:46:29,080 --> 00:46:30,940
0,90 90,450 450,690 690,1140 1140,1860
The same file descriptor number
所以相同的文件描述符号在不同的进程中可能引用不同的文件。

1557
00:46:31,150 --> 00:46:32,980
0,210 210,480 480,600 600,1080 1080,1830
may refer to different files

1558
00:46:33,010 --> 00:46:34,720
0,330 360,690 690,1560
in different processes.|
|

1559
00:46:37,040 --> 00:46:38,510
0,180 180,540 540,720 720,1200 1230,1470
Any questions that open about
关于 open 程序，有什么问题吗？

1560
00:46:38,510 --> 00:46:39,640
0,180 180,360 360,840
this little program.|
|

1561
00:46:40,240 --> 00:46:40,960
0,150 150,240 240,360 360,390 390,720
Now we had a question
在聊天中有一个问题，

1562
00:46:40,960 --> 00:46:42,130
0,90 90,180 180,660 660,990 990,1170
in the chat,| question from
|一个不熟悉 C 语言的人提出的问题，

1563
00:46:42,130 --> 00:46:43,720
0,300 300,510 510,870 870,1020 1020,1590
someone not familiar with C,|
|

1564
00:46:43,990 --> 00:46:45,370
0,420 420,510 510,690 690,1110 1110,1380
how are these files being
这些文件和普通的 C 程序有什么不同，

1565
00:46:45,370 --> 00:46:47,290
0,720 720,1170 1170,1320 1320,1650 1650,1920
described different from normal C

1566
00:46:47,290 --> 00:46:48,970
0,540 540,690 690,810 810,1140 1140,1680
programs,| is it because we're
|是不是因为我们只使用内核调用，

1567
00:46:49,090 --> 00:46:50,950
0,360 360,600 600,900 900,1380 1380,1860
only using kernel calls,| i.e
|也就是说，我们能不能用 python 打开或写入文件。

1568
00:46:50,950 --> 00:46:52,480
0,330 330,450 450,1020 1020,1410 1410,1530
couldn't we also open or

1569
00:46:52,480 --> 00:46:54,040
0,210 210,300 300,840 900,1230
write a file {in,python}.|
|

1570
00:46:58,500 --> 00:46:59,060
0,330

1571
00:46:59,440 --> 00:47:00,460
0,90 90,240 240,390 390,450 450,1020
I don't think I understand
我想我不明白的是，

1572
00:47:00,460 --> 00:47:01,260
0,360
that,|
|

1573
00:47:02,000 --> 00:47:02,930
0,150 150,210 210,450 450,750 750,930
it's a C program, that's
它是一个 C 程序，打开或写入一个文件。

1574
00:47:02,930 --> 00:47:04,160
0,330 330,450 450,720 720,810 810,1230
opening and writing a file,|
|

1575
00:47:12,480 --> 00:47:13,180
0,450

1576
00:47:15,620 --> 00:47:17,750
0,480 480,690 690,750 750,960 960,2130
that's going to move on.|
然后继续下去。|

1577
00:47:20,640 --> 00:47:24,480
0,360 360,630 870,1470 2940,3450 3450,3840
Alright so you might ask
好的，你可能问的是。

1578
00:47:24,480 --> 00:47:26,910
0,300 300,570 570,1200 1200,1830 1830,2430
what actually happens when.| Maybe
|也许问题是，

1579
00:47:26,940 --> 00:47:28,410
0,150 150,540 540,630 630,900 930,1470
the question is| when someone
|当使用 C 语言做这件事，

1580
00:47:28,860 --> 00:47:30,120
0,210 210,480 480,570 570,690 690,1260
is doing it in C,|
|

1581
00:47:30,120 --> 00:47:31,200
0,240 240,630 630,720 720,990 990,1080
any different than doing it
除了语法，与使用 python 有什么不同。

1582
00:47:31,200 --> 00:47:33,090
0,90 90,570 570,990 990,1080 1080,1890
in python minus the syntax.|
|

1583
00:47:34,240 --> 00:47:37,810
0,630 630,1500 1740,2430 2430,2880 3030,3570
Well it's not really, um.|
它不是。

1584
00:47:38,620 --> 00:47:39,400
0,330
And,
当然也有办法。

1585
00:47:40,680 --> 00:47:42,840
0,300 300,720 720,1080 1080,1470 1590,2160
there's certainly ways to, um.|
|

1586
00:47:44,410 --> 00:47:47,560
0,420 420,1110 1380,2340 2580,2940 2940,3150
Python provides nice function calls
Python 提供了良好的函数调用，打开文件或做这些事。

1587
00:47:47,560 --> 00:47:48,820
0,120 120,720 720,960 960,1170 1170,1260
for opening and doing all

1588
00:47:48,820 --> 00:47:50,040
0,150 150,510 510,660
these things too.|
|

1589
00:47:50,830 --> 00:47:52,060
0,120 120,420 420,810 810,900 900,1230
Or opening files, for example
打开文件，比如读写文件，

1590
00:47:52,060 --> 00:47:54,040
0,90 90,420 420,750 750,1320 1530,1980
in reading writing files {},|
|

1591
00:47:54,310 --> 00:47:56,560
0,450 450,630 630,1110 1110,1410 2040,2250
there's a layer of a
通常有一个层级比较高的函数，

1592
00:47:56,560 --> 00:47:58,000
0,330 330,600 600,840 840,1050 1050,1440
higher somewhat higher level functions

1593
00:47:58,000 --> 00:48:00,970
0,540 870,1710 1920,2340 2340,2400 2400,2970
typically,| not pointers the memory,
|比如，没有指向内存的指针。

1594
00:48:00,970 --> 00:48:01,940
0,90 90,690
for example.|
|

1595
00:48:02,140 --> 00:48:03,040
0,660

1596
00:48:03,690 --> 00:48:05,220
0,210 210,480 480,630 630,1170 1200,1530
And python has more error
Python 也为你提供了更多的错误检查，

1597
00:48:05,220 --> 00:48:06,680
0,450 450,750 750,1200
checking for you,|
|

1598
00:48:07,140 --> 00:48:08,700
0,510 1020,1140 1140,1260 1260,1380 1380,1560
{} but when you open
但是当你在 python 中打开文件，

1599
00:48:08,700 --> 00:48:10,140
0,60 60,360 360,420 420,1140 1140,1440
a file in python| {or,write,a,file}
|或在 python 中写文件，

1600
00:48:10,140 --> 00:48:11,940
0,210 210,870 870,1470
on python,| the
|python 调用底层的系统调用。

1601
00:48:11,960 --> 00:48:13,360
0,390 390,600 600,720 720,1140
python calls you make

1602
00:48:14,300 --> 00:48:16,970
0,450 450,930 930,1470 1950,2340 2340,2670
boil down to system calls

1603
00:48:16,970 --> 00:48:18,160
0,210 210,390 390,870
just like these.|
|

1604
00:48:19,840 --> 00:48:21,220
0,120 120,330 330,810 810,960 960,1380
Is that a good answer.|
这个答案怎么样。|

1605
00:48:25,860 --> 00:48:28,940
0,210 210,660 1170,1560
Think so.| Alright.|
我想是的。|好的。|

1606
00:48:30,980 --> 00:48:32,840
0,660 690,1290
Alright {}.|
好的。|

1607
00:48:33,560 --> 00:48:35,390
0,300 300,690 930,1140 1140,1290 1290,1830
I've been over here talking
我在这里讨论，

1608
00:48:35,390 --> 00:48:36,680
0,180 180,450 450,960
to the {},|
|

1609
00:48:39,120 --> 00:48:41,370
0,240 240,450 450,810 810,1320 1500,2250
{xv6 - -} is unix,
xv6 是 unix ，比如 shell ，

1610
00:48:41,460 --> 00:48:44,100
0,480 750,1680 1980,2130 2130,2250 2280,2640
like shell| and the shell
|shell 人们也经常称作命令行接口，

1611
00:48:44,100 --> 00:48:45,090
0,90 90,300 480,690 690,870 870,990
is what people often call

1612
00:48:45,090 --> 00:48:47,400
0,90 90,420 420,630 630,1410 1800,2310
the command line interface,| {}
|相对更图形化的用户界面。

1613
00:48:47,400 --> 00:48:48,840
0,180 180,480 480,840 870,1080 1110,1440
as opposed to {} more

1614
00:48:48,870 --> 00:48:50,980
0,720 720,1080 1080,1740
graphical user interface.|
|

1615
00:48:51,240 --> 00:48:53,550
0,480 1080,1500 1500,2130 2130,2220 2220,2310
{} The {shell,turns},| if you
shell 是，|如果你没有用过 shell ，

1616
00:48:53,550 --> 00:48:54,540
0,210 210,450 450,540 540,900 900,990
haven't used the shell,| the
|shell 是一个非常有用的界面，

1617
00:48:54,540 --> 00:48:55,950
0,390 390,660 660,960 960,1050 1050,1410
shell turns out to be

1618
00:48:56,250 --> 00:48:57,570
0,150 150,390 390,720 720,1200 1200,1320
a pretty useful interface| for
|对于 unix 系统的系统管理，

1619
00:48:57,570 --> 00:48:59,220
0,180 180,330 330,630 630,1410 1500,1650
things like system management of

1620
00:48:59,220 --> 00:49:01,920
0,360 360,1050 2220,2370 2370,2640 2640,2700
unix systems,| it provides a
|他提供了很多实用程序，

1621
00:49:01,920 --> 00:49:04,020
0,180 180,270 270,1020 1020,1560 1590,2100
lot of utilities| for messing
|来处理文件，开发程序，

1622
00:49:04,020 --> 00:49:05,490
0,210 210,360 360,1110 1110,1350 1350,1470
around with files and for

1623
00:49:05,490 --> 00:49:07,080
0,330 330,990 990,1260
program development| and
|以及编写脚本来完成这些事。

1624
00:49:07,140 --> 00:49:08,850
0,300 300,660 660,1350 1440,1560 1560,1710
on writing scripts to do

1625
00:49:08,850 --> 00:49:10,470
0,120 120,330 330,660 660,1050 1320,1620
all these things.| So, {some
|所以在继续之前。

1626
00:49:10,470 --> 00:49:12,340
0,210 210,360 360,1020 1020,1560
- -} before run.|
|

1627
00:49:12,550 --> 00:49:13,420
0,30 120,300 300,420 420,480 480,870
I just want to demonstrate
我想演示几个 shell 功能，

1628
00:49:13,420 --> 00:49:15,250
0,30 30,240 240,750 750,1200 1230,1830
a few shell features.| Ordinarily,
|当你输入东西的时候，

1629
00:49:15,250 --> 00:49:17,290
0,120 120,240 240,540 540,1200 1380,2040
when you type things {},|
|

1630
00:49:17,770 --> 00:49:19,000
0,180 180,540 540,660 660,1140 1140,1230
you're telling the shell to
你在高数 shell 运行一个程序，

1631
00:49:19,000 --> 00:49:20,320
0,390 390,480 480,1080 1080,1200 1200,1320
run a program,| so when
|所以当我输入 ls ，

1632
00:49:20,320 --> 00:49:21,460
0,60 60,360 360,780 780,960 960,1140
I type ls,| what that
|我的意思是要求 shell 运行名为 ls 的程序，

1633
00:49:21,460 --> 00:49:23,410
0,450 450,780 1020,1200 1200,1500 1500,1950
means is I'm asking the

1634
00:49:23,410 --> 00:49:25,480
0,390 390,870 870,960 960,1770
{shell,to} run the program

1635
00:49:25,530 --> 00:49:26,910
0,210 210,450 450,600 600,1260 1260,1380
whose name is ls| and
|这真正的含义是

1636
00:49:27,300 --> 00:49:28,290
0,180 180,360 360,570 570,870 870,990
what that really means is|
|

1637
00:49:28,290 --> 00:49:30,000
0,210 210,300 300,1170 1470,1590 1590,1710
there's a file in the
在文件系统中，有一个叫做 ls 的文件

1638
00:49:30,000 --> 00:49:31,890
0,330 330,660 660,990 990,1710 1710,1890
file system called ls,| that
|它包含一些指令，一些机器指令，

1639
00:49:31,890 --> 00:49:34,140
0,420 420,600 600,1620 1740,1920 1920,2250
contains some instructions, some machine

1640
00:49:34,140 --> 00:49:35,880
0,750 1110,1230 1230,1350 1350,1680 1680,1740
instructions| and I'm asking the
|我要求 shell 运行 ls 文件中的这些指令，

1641
00:49:35,880 --> 00:49:38,280
0,390 390,480 480,1140 1350,1470 1470,2400
shell to run the instructions

1642
00:49:38,280 --> 00:49:39,120
0,150 150,240 240,330 330,450 450,840
that are in the file

1643
00:49:39,120 --> 00:49:41,550
0,300 300,1050 1650,1800 1800,2190 2190,2430
called ls,| {} ls, now
|现在 ls 真正做的是，

1644
00:49:41,550 --> 00:49:43,140
0,600 660,810 810,930 930,1170 1170,1590
ls what it actually does

1645
00:49:43,140 --> 00:49:44,660
0,270 660,1290
is {},|
|

1646
00:49:44,940 --> 00:49:45,840
0,150 150,210 210,690 690,780 780,900
get a listing of the
获取当前目录中的文件列表，

1647
00:49:45,840 --> 00:49:47,220
0,390 390,450 450,510 510,780 780,1380
files in the current directory,|
|

1648
00:49:47,250 --> 00:49:48,000
0,150 150,240 240,360 360,630 630,750
and you can see up
你可以在上面的第 4 行看到，

1649
00:49:48,000 --> 00:49:49,230
0,150 150,240 240,330 330,630 630,1230
there on the fourth line,|
|

1650
00:49:49,620 --> 00:49:52,380
0,360 720,1350 1350,1470 1470,1980 2010,2760
that among the other files
同其他文件一起， ls 也是存在的。

1651
00:49:52,380 --> 00:49:52,900
0,210
that

1652
00:49:52,980 --> 00:49:54,630
0,480 480,660 660,1440 1440,1530 1530,1650
ls as exists,| and this
|这个列表，

1653
00:49:54,630 --> 00:49:56,040
0,420 420,750 750,900 900,1140 1140,1410
list is,| a file called
|一个叫做 ls 的文件，实际上它包含了我刚才运行的指令。

1654
00:49:56,040 --> 00:49:57,660
0,660 690,900 900,1020 1020,1140 1140,1620
ls which is in fact

1655
00:49:58,140 --> 00:49:59,580
0,120 120,420 420,840 840,900 900,1440
the file containing the instructions

1656
00:49:59,580 --> 00:50:00,540
0,90 90,300 300,540
I just ran.|
|

1657
00:50:02,370 --> 00:50:03,090
0,120 120,300 300,450 450,510 510,720
The shell does a few
除了运行程序， shell 还为你做了其他事情，

1658
00:50:03,090 --> 00:50:04,110
0,270 270,570 570,720 720,840 840,1020
other things for you other

1659
00:50:04,110 --> 00:50:06,750
0,150 150,450 450,1230 2250,2580 2580,2640
than running programs| allows you
|还允许你重定向 IO ，

1660
00:50:06,750 --> 00:50:08,790
0,150 150,750 750,1410 1740,1950 1950,2040
to redirect io,| so for
|比如，如果我输入 ls > out ，

1661
00:50:08,790 --> 00:50:10,230
0,330 330,450 450,570 570,840 840,1440
example if I say ls

1662
00:50:10,230 --> 00:50:11,490
0,300 300,450 450,810 870,1050 1050,1260
greater than out,| what that
|意思是要求 shell 运行 ls 命令，

1663
00:50:11,490 --> 00:50:13,470
0,390 390,750 930,1320 1320,1410 1410,1980
means is asking the shell

1664
00:50:13,500 --> 00:50:15,210
0,180 180,270 270,630 630,1170 1530,1710
run the ls command,| but
|但将其输入重定向到名为 out 的文件。

1665
00:50:15,210 --> 00:50:16,830
0,150 150,390 390,960 960,1530 1530,1620
with its output redirected to

1666
00:50:16,830 --> 00:50:18,260
0,150 150,510 510,840 840,1110
the file called out.|
|

1667
00:50:18,520 --> 00:50:19,920
0,330 330,540 540,1170
I run ls,
我运行 ls ，

1668
00:50:21,080 --> 00:50:22,130
0,120 120,240 240,360 360,510 510,1050
we don't see any output,|
我们看不到任何输出，|

1669
00:50:22,340 --> 00:50:23,420
0,180 180,300 300,570 570,720 720,1080
because the output all went
因为输出都重定向了。

1670
00:50:23,420 --> 00:50:24,080
0,420
out.|
|

1671
00:50:24,960 --> 00:50:27,090
0,510 960,1380 1380,1470 1470,1830 1860,2130
{} Now, I can, out
现在 out 包含一些数据，

1672
00:50:27,090 --> 00:50:28,380
0,360 360,420 420,630 630,720 720,1290
contains a bunch of data,|
|

1673
00:50:28,530 --> 00:50:30,380
0,480 840,1050 1050,1560
{} we could,|
我们可以，|

1674
00:50:30,900 --> 00:50:32,700
0,120 120,450 450,1110 1290,1710 1710,1800
the cat command reads a
cat 命令读取文件并显示其中的内容，

1675
00:50:32,700 --> 00:50:34,770
0,390 390,600 600,1590 1590,1650 1650,2070
file and displays the contents

1676
00:50:34,770 --> 00:50:35,850
0,90 90,150 150,660 660,900 990,1080
of the file,| so I
|我输入 cat out 。

1677
00:50:35,850 --> 00:50:37,080
0,180 180,540 540,870
say cat out.|
|

1678
00:50:37,190 --> 00:50:38,180
0,210 210,330 330,390 390,750 750,990
Just going to see now
可以看到这和 ls 的输出是一样的。

1679
00:50:38,180 --> 00:50:39,320
0,240 300,690 690,870 870,1020 1020,1140
the now this is the

1680
00:50:39,320 --> 00:50:41,080
0,360 360,720 720,810 810,1470
same output of ls.|
|

1681
00:50:41,170 --> 00:50:41,860
0,120 120,240 240,480 480,600 600,690
You can also run a
你也可以运行命令 grep ，|

1682
00:50:41,860 --> 00:50:42,940
0,330 330,630 630,930 930,1020 1020,1080
command like grep| and I
|我给它一个参数 x ， grep x 。

1683
00:50:42,940 --> 00:50:43,870
0,150 150,300 300,390 390,480 480,930
can give it an argument

1684
00:50:43,870 --> 00:50:46,060
0,480 480,570 570,750 900,1260 1260,2190
x and what grep x.|
|

1685
00:50:46,520 --> 00:50:47,690
0,120 120,330 330,660 660,1050 1050,1170
The grep command searches for
grep 命令通过模式搜索。

1686
00:50:47,690 --> 00:50:48,700
0,750
patterns.|
|

1687
00:50:49,080 --> 00:50:51,960
0,690 1380,1740 1740,1950 1950,2280 2550,2880
Again {} if I run
同样的，如果我运行 grep x ，

1688
00:50:51,960 --> 00:50:53,550
0,330 360,870 870,1020 1020,1200 1200,1590
grep x,| it's gonna search
|它会搜索包含 x 的输入行，

1689
00:50:53,550 --> 00:50:54,360
0,420
for

1690
00:50:54,680 --> 00:50:56,510
0,900 930,1080 1080,1380 1380,1440 1440,1830
lines of input to contain

1691
00:50:56,510 --> 00:50:58,520
0,540 870,1020 1020,1200 1200,1740 1740,2010
x,| I can redirect,| tell
|我也可以重定向，|告诉 shell 把 grep 的输入重定向到 out 文件。

1692
00:50:58,520 --> 00:50:59,750
0,90 90,510 510,630 630,1080 1080,1230
the shell to redirect its

1693
00:50:59,750 --> 00:51:01,190
0,420 420,600 600,690 690,1080 1080,1440
input from the file out.|
|

1694
00:51:01,700 --> 00:51:02,510
0,150 150,300 300,390 390,630 630,810
In order to look for
用来查找保存 ls 结果中的 x 实例。

1695
00:51:02,510 --> 00:51:04,790
0,540 540,660 660,1260 1470,1770 1770,2280
instances of x that saved

1696
00:51:04,790 --> 00:51:06,020
0,480 480,930
ls output.|
|

1697
00:51:07,150 --> 00:51:08,230
0,180 180,420 420,540 540,750 750,1080
It turns out there's three
结果是这里有三个文件包含 x 。

1698
00:51:08,230 --> 00:51:11,920
0,870 1470,1980 1980,2640 2670,3090 3090,3690
files whose names contain x.|
|

1699
00:51:13,000 --> 00:51:13,520
0,60

1700
00:51:14,000 --> 00:51:14,960
0,630
Um.|
嗯。|

1701
00:51:15,560 --> 00:51:16,190
0,180 180,300 300,360 360,600 600,630
We're going to spend a
我们花一些时间在 shell 上，

1702
00:51:16,190 --> 00:51:16,820
0,180 180,240 240,480 480,570 570,630
bunch of time with the

1703
00:51:16,820 --> 00:51:20,090
0,600 630,1200 1770,2220 2220,2430 2880,3270
shell,| {} {} its shell
|shell 是 unix 的一种最传统和最基本的接口，

1704
00:51:20,090 --> 00:51:21,200
0,90 90,270 270,330 330,420 420,1110
is sort of the most

1705
00:51:21,860 --> 00:51:26,540
0,1020 1110,1650 1650,2190 2190,2970 3990,4680
traditional and fundamental interface {of,unix},|
|

1706
00:51:26,540 --> 00:51:27,680
0,330 330,540 540,780 780,930 930,1140
because when unix was first
因为在 unix 最初开发的时候，

1707
00:51:27,680 --> 00:51:29,510
0,570 570,960 1320,1500 1500,1590 1590,1830
developed,| {} all there was
|所有的都是简单的终端接口。

1708
00:51:29,510 --> 00:51:31,010
0,120 120,390 390,780 780,1350 1350,1500
was simple terminal interfaces,| like
|比如我们现在使用的，

1709
00:51:31,010 --> 00:51:32,540
0,60 60,240 240,390 390,900 1260,1530
the one we're using {}|
|

1710
00:51:32,540 --> 00:51:33,710
0,240 390,510 510,720 720,960 960,1170
and the main use of
unix 最初的主要用途是分时共享，

1711
00:51:34,070 --> 00:51:36,290
0,300 300,780 780,1140 1380,1770 1770,2220
unix originally was time sharing,|
|

1712
00:51:36,290 --> 00:51:37,370
0,30 30,270 270,420 420,750 750,1080
a bunch of people logging
许多人同时登录到一台机器上，

1713
00:51:37,370 --> 00:51:38,750
0,150 150,240 240,510 510,1140 1170,1380
into the same machine,| much
|很像 Athena ，使用 shell 交互。

1714
00:51:38,750 --> 00:51:41,120
0,150 150,720 1110,1560 1830,2280 2280,2370
like Athena and talking to

1715
00:51:41,120 --> 00:51:41,960
0,660
shells.|
|

1716
00:51:43,300 --> 00:51:46,450
0,270 1050,1680 1680,1950 1950,2400 2400,3150
A question about system calls
有一个关于系统调用和编译器的问题，

1717
00:51:46,450 --> 00:51:48,130
0,210 210,330 330,1200 1410,1530 1530,1680
and the compiler,| how does
|编译器如何处理系统调用，

1718
00:51:48,130 --> 00:51:49,750
0,60 60,570 570,840 840,1170 1170,1620
the compiler handles system calls,|
|

1719
00:51:49,750 --> 00:51:51,310
0,360 390,840 840,1350 1350,1530 1530,1560
does assembly generated make a
是由汇编语言对操作系统定义的一些代码段做过程调用吗？

1720
00:51:51,310 --> 00:51:52,600
0,420 420,720 720,810 810,990 990,1290
procedure call to some code

1721
00:51:52,600 --> 00:51:54,820
0,600 1020,1620 1620,1770 1770,1860 1860,2220
segment, defined by the operating

1722
00:51:54,820 --> 00:51:55,480
0,390
system.|
|

1723
00:51:57,020 --> 00:51:58,700
0,300 300,480 480,570 570,1200 1350,1680
{} There's a special {RISC-V
有一个特殊的 RISC-V 指令，

1724
00:51:58,700 --> 00:52:00,470
0,270 270,1080 1080,1260 1260,1380 1380,1770
-} instruction,| that a program
|程序可以调用它将控制权转到到内核，

1725
00:52:00,470 --> 00:52:02,060
0,120 120,510 510,750 750,1230 1230,1590
can call that transfers control

1726
00:52:02,060 --> 00:52:04,010
0,150 150,240 240,690 780,1170 1350,1950
under the kernel,| so indeed
|所以当你编写 C 代码，调用系统调用，

1727
00:52:04,370 --> 00:52:05,360
0,180 180,300 300,510 510,720 720,990
when you write C code

1728
00:52:05,360 --> 00:52:06,350
0,90 90,300 300,360 360,690 690,990
that makes the system call,|
|

1729
00:52:06,350 --> 00:52:08,360
0,390 390,870 1200,1710
{like,open} {and,write} {}|
比如 open write ，|

1730
00:52:08,600 --> 00:52:10,280
0,180 180,600 600,870 870,1260 1260,1680
and technically what actually happens
实际上是 open 是 C 库中的一个 C 函数，

1731
00:52:10,280 --> 00:52:11,960
0,240 240,870 1080,1260 1260,1320 1320,1680
is open is a C

1732
00:52:11,960 --> 00:52:14,150
0,810 840,990 990,1080 1080,1380 1380,2190
function in the C library,|
|

1733
00:52:14,620 --> 00:52:16,960
0,420 600,810 810,960 960,2130 2190,2340
{} but the instructions in
但是这个函数中的指令实际上是及其指令，

1734
00:52:16,960 --> 00:52:18,970
0,300 300,750 750,900 900,1500 1530,2010
that function are really machine

1735
00:52:18,970 --> 00:52:21,360
0,660 660,780 780,1050 1290,2070
instructions,| it's not open,
|它不是 open ， open 函数不是一个 C 函数，

1736
00:52:21,820 --> 00:52:22,870
0,150 150,480 480,870 870,960 960,1050
the open function that we

1737
00:52:22,870 --> 00:52:24,280
0,360 360,600 600,660 660,900 900,1410
calling isn't a C function,|
|

1738
00:52:24,490 --> 00:52:26,820
0,450 450,510 510,1230 1470,1950
implemented in assembler| and
而是由汇编语言实现，|在 RISC-V 中，汇编语言的这个特殊指令叫做 ecall ，

1739
00:52:26,950 --> 00:52:29,540
0,180 180,690 690,1440 1680,2310
the assembly code {}

1740
00:52:30,290 --> 00:52:32,300
0,570 570,690 690,840 840,1320 1320,2010
consists of this special instructions

1741
00:52:32,300 --> 00:52:34,060
0,210 210,480 510,1290
actually called ecall,

1742
00:52:34,140 --> 00:52:35,430
0,150 150,450 450,870 870,960 960,1290
on {RISC-V -},| the special
|这个特殊指令转移控制权到内核中，

1743
00:52:35,430 --> 00:52:37,440
0,480 480,570 570,1050 1050,1680
instruction that transfers control

1744
00:52:37,580 --> 00:52:39,620
0,210 210,300 300,870 1320,1740 1770,2040
into the kernel,| and then
|然后内核查看进程内存和寄存器，

1745
00:52:39,620 --> 00:52:40,760
0,90 90,420 420,720 720,900 900,1140
the kernel looks at the

1746
00:52:40,790 --> 00:52:42,380
0,510 510,900 900,990 990,1500 1500,1590
processes memory and registers| to
|找出参数是什么。

1747
00:52:42,380 --> 00:52:43,700
0,270 270,420 420,660 660,1020
figure out what the

1748
00:52:44,260 --> 00:52:45,160
0,480 480,630
arguments were.|
|

1749
00:52:50,610 --> 00:52:53,490
0,510 870,1410 2070,2490 2490,2820 2820,2880
Alright the next example, I
好的，下一个例子，我想看的程序是 fork 。

1750
00:52:53,490 --> 00:52:54,240
0,120 120,180 180,330 330,450 450,750
want to look at is

1751
00:52:54,300 --> 00:52:56,850
0,1260 1260,1500 1500,1620 1620,1920 1920,2550
example program that calls fork.|
|

1752
00:52:58,420 --> 00:53:01,810
0,540 540,1320 1800,2340 3030,3240 3240,3390
Creating process, {} so this
创建进程，这是很简单的 fork 的应用，

1753
00:53:01,810 --> 00:53:02,720
0,120 120,510
is the

1754
00:53:03,430 --> 00:53:04,690
0,360 360,630 630,840 840,900 900,1260
very simple use of fork,|
|

1755
00:53:04,690 --> 00:53:06,430
0,90 90,300 300,930 1140,1260 1260,1740
at line twelve we're calling
在第 12 行，我们调用了 fork ，

1756
00:53:06,430 --> 00:53:07,900
0,510 510,720 840,1050 1050,1260 1260,1470
fork| and what fork does
|fork 所做的是，

1757
00:53:07,900 --> 00:53:08,420
0,270
is|
|

1758
00:53:08,670 --> 00:53:10,320
0,330 330,390 390,1230 1380,1560 1560,1650
creates a copy of the
创建一个调用进程的指令和数据的内存的复制，

1759
00:53:10,320 --> 00:53:12,630
0,660 690,1110 1140,1710 1710,1920 1920,2310
memory of instructions and data

1760
00:53:12,660 --> 00:53:14,640
0,150 150,390 690,1050 1050,1830 1830,1980
of the calling process,| now
|现在我们有两个使用相同内存的进程。

1761
00:53:14,640 --> 00:53:15,720
0,60 60,150 150,330 330,960 960,1080
we have two processes with

1762
00:53:15,720 --> 00:53:17,720
0,780 1080,1710
identical memory.|
|

1763
00:53:18,010 --> 00:53:19,420
0,540 660,780 780,990 990,1260 1260,1410
Fork the fork system call
fork 系统调用在两个进程中都会返回，

1764
00:53:19,420 --> 00:53:22,080
0,780 780,960 960,1320 1320,2340
returns in both processes,|
|

1765
00:53:22,360 --> 00:53:23,920
0,210 210,360 360,420 420,810 810,1560
{} in the original process,|
在原始进程中，|

1766
00:53:24,430 --> 00:53:26,080
0,270 270,660 660,900 900,1110 1110,1650
the fork system call returns
fork 返回一个大于 0 的进程 id ，

1767
00:53:26,080 --> 00:53:27,400
0,150 150,630 630,1050 1050,1200 1200,1320
the process id which is

1768
00:53:27,400 --> 00:53:28,800
0,210 570,990
a {}

1769
00:53:29,080 --> 00:53:30,640
0,210 210,570 570,840 840,990 990,1560
an integer greater than zero,|
|

1770
00:53:30,850 --> 00:53:31,480
0,300

1771
00:53:32,100 --> 00:53:33,900
0,270 270,690 690,1110 1320,1530 1530,1800
the original process fork returns
原始进程中， fock 返回的是新创建进程的进程 id ，

1772
00:53:33,900 --> 00:53:34,950
0,90 90,480 480,840 840,960 960,1050
the process id of the

1773
00:53:34,950 --> 00:53:37,020
0,330 330,660 660,1290 1800,2010 2010,2070
newly created process| and in
|而在新进程中， fock 返回 0 。

1774
00:53:37,020 --> 00:53:38,880
0,60 60,330 330,660 660,1290 1560,1860
the newly created process fork

1775
00:53:38,880 --> 00:53:40,960
0,660 690,1020 1050,1710
returns a zero.|
|

1776
00:53:41,630 --> 00:53:42,650
0,210 210,390 390,570 570,630 630,1020
So we sort of break
所以即使两个进程有相同的内存，

1777
00:53:42,650 --> 00:53:43,850
0,180 180,270 270,360 360,1020 1050,1200
even though the processes have

1778
00:53:43,850 --> 00:53:46,160
0,330 330,810 1380,1800 1800,1950 1950,2310
identical memory,| you can break
|你也可以通过 fork 的返回值区分它们。

1779
00:53:46,160 --> 00:53:48,320
0,90 90,720 720,1110 1560,1860 1860,2160
the symmetry of old versus

1780
00:53:48,320 --> 00:53:49,640
0,120 120,690 690,870 870,990 990,1320
new process by the return

1781
00:53:49,640 --> 00:53:50,800
0,330 330,510 510,930
value from fork.|
|

1782
00:53:50,940 --> 00:53:52,560
0,240 240,360 360,600 600,1320 1500,1620
And in line sixteen, you
在第 16 行，你可以看到代码检查并判断，

1783
00:53:52,560 --> 00:53:54,300
0,120 120,480 960,1230 1230,1320 1320,1740
can see code {} checks

1784
00:53:54,300 --> 00:53:55,260
0,90 90,360 360,510 510,630 630,960
and say| if the process
|如果进程 id 等于 0 ，就是子进程，

1785
00:53:55,260 --> 00:53:56,310
0,270 270,390 390,570 570,870 870,1050
id is equal zero must

1786
00:53:56,310 --> 00:53:57,510
0,90 90,150 150,840 870,990 990,1200
be the child,| you must
|肯定是在子进程中运行。

1787
00:53:57,510 --> 00:53:58,140
0,120 120,240 240,480 480,570 570,630
now be running in the

1788
00:53:58,140 --> 00:53:59,100
0,570
child.|
|

1789
00:53:59,420 --> 00:54:01,130
0,480 1110,1260 1260,1440 1440,1560 1560,1710
{} Of course there's two
当然这里有两个进程，

1790
00:54:01,130 --> 00:54:02,840
0,510 510,720 720,810 810,990 990,1710
processes,| in the other process,
|在另一个进程，调用进程中，

1791
00:54:03,260 --> 00:54:04,670
0,510 510,660 660,750 750,1050 1050,1410
{} in the calling process,|
|

1792
00:54:04,670 --> 00:54:05,450
0,180 180,300 300,540 540,720 720,780
which is usually called the
称为父进程，返回的进程 id 大于 0 。

1793
00:54:05,450 --> 00:54:07,550
0,510 900,1410 1410,1650 1650,1770 1770,2100
parent, process id is greater

1794
00:54:07,550 --> 00:54:08,560
0,180 180,690
than zero.|
|

1795
00:54:08,640 --> 00:54:10,230
0,510 720,900 900,990 990,1470 1470,1590
{} So the child will
所以子进程会输出 child ，而父进程会输出 parent 。

1796
00:54:10,230 --> 00:54:12,030
0,330 330,930 930,1290 1290,1350 1350,1800
print child and the parent

1797
00:54:12,420 --> 00:54:13,500
0,90 90,240 240,810
will print parent,|
|

1798
00:54:14,350 --> 00:54:16,480
0,390 390,480 480,600 600,1170 1710,2130
and then they'll both exit.|
然后它们都会退出。|

1799
00:54:16,810 --> 00:54:17,890
0,150 150,270 270,300 300,600 600,1080
So when I run fork,|
我运行 fork ，|

1800
00:54:19,380 --> 00:54:22,050
0,300 300,600 600,690 690,1170 2160,2670
now here we get {},
我们可以得到，它看起来像是乱码。

1801
00:54:22,800 --> 00:54:23,550
0,180 180,210 210,360 360,600 600,750
so it may look like

1802
00:54:23,550 --> 00:54:24,860
0,750
garbage.|
|

1803
00:54:25,230 --> 00:54:26,520
0,270 270,510 510,960 960,1080 1080,1290
What's actually happening is| that
实际发生的是，|在调用 fork 之后，两个进程都会运行，

1804
00:54:26,850 --> 00:54:27,900
0,300 300,390 390,780 780,990 990,1050
after the fork, both of

1805
00:54:27,900 --> 00:54:29,340
0,150 150,660 660,780 780,1290 1320,1440
these processes are running,| they're
|它们同时运行，

1806
00:54:29,340 --> 00:54:30,360
0,270 270,570 570,660 660,750 750,1020
both running at the same

1807
00:54:30,360 --> 00:54:32,610
0,540 720,1200 1440,1890 1890,1950 1950,2250
time| and QEMU is actually
|QEMU 为真正我模拟了多核微处理器，

1808
00:54:32,610 --> 00:54:35,540
0,480 480,1260 1680,2100 2100,2610
emulating a multi core

1809
00:54:35,750 --> 00:54:37,220
0,780 780,990 990,1140 1140,1320 1320,1470
microprocessor for me,| so they
|所以实际上它们是几乎是同时运行的，

1810
00:54:37,220 --> 00:54:39,380
0,240 240,450 450,990 1470,1980 1980,2160
really are running {} at

1811
00:54:39,380 --> 00:54:40,400
0,90 90,330 330,540 540,900 900,1020
the very same time,| so
|所以当它们产生输出时，

1812
00:54:40,400 --> 00:54:41,820
0,120 120,240 240,540 540,1050
when they produce output,|
|

1813
00:54:41,850 --> 00:54:42,990
0,150 150,480 480,690 690,1080 1080,1140
they're producing each byte of
它们同时产生每个字节，

1814
00:54:42,990 --> 00:54:44,070
0,210 210,630 630,720 720,810 810,1080
their output at the same

1815
00:54:44,070 --> 00:54:45,240
0,270 270,390 390,480 480,690 690,1170
time as the other process

1816
00:54:45,240 --> 00:54:46,560
0,150 150,540 540,600 600,1080 1080,1320
is,| producing the corresponding bytes
|产生输出对应的字节，

1817
00:54:46,560 --> 00:54:47,940
0,90 90,300 300,660 1110,1260 1260,1380
of its output,| so the
|所以两个进程的输出是交错的。

1818
00:54:47,940 --> 00:54:49,050
0,270 270,330 330,420 420,570 570,1110
output of the two processes

1819
00:54:49,050 --> 00:54:50,360
0,240
are

1820
00:54:50,820 --> 00:54:52,710
0,270 270,870 1440,1650 1650,1770 1770,1890
{interleave -}.| {} You can
|你可以看到它们都会输出 f ，

1821
00:54:52,710 --> 00:54:53,760
0,210 210,450 450,570 570,780 780,1050
see that they're both typing

1822
00:54:53,760 --> 00:54:54,540
0,570
f,|
|

1823
00:54:54,800 --> 00:54:56,120
0,420 600,720 720,930 930,1080 1080,1320
{} they're both gonna type
它们都会从 fork 返回。

1824
00:54:56,120 --> 00:54:57,380
0,240 240,930
for return.|
|

1825
00:54:57,800 --> 00:54:58,730
0,420 450,630 630,690 690,780 780,930
{} So you can see
所以你可以看到两个 f ，

1826
00:54:58,730 --> 00:54:59,540
0,90 90,300 300,450 450,720 720,810
the f from both of

1827
00:54:59,540 --> 00:55:00,500
0,180 180,270 270,420 420,750 750,960
them,| in the o both
|两个 o ，两个 r ，等等。

1828
00:55:00,500 --> 00:55:01,100
0,60 60,240 240,330 330,390 390,600
of them and they r

1829
00:55:01,100 --> 00:55:02,500
0,330 330,510 510,750 750,1080
both and so on.|
|

1830
00:55:02,920 --> 00:55:04,080
0,210 210,390 390,480 480,870
{} One of them,|
其中之一，|

1831
00:55:04,700 --> 00:55:05,600
0,420 420,570 570,690 690,810 810,900
{} you can see the
你可以看到第一行末尾的 0 ，

1832
00:55:05,600 --> 00:55:06,380
0,420 420,510 510,600 600,720 720,780
zero at the end of

1833
00:55:06,380 --> 00:55:08,060
0,150 150,420 420,720 720,1080 1500,1680
that first line is,| in
|子进程会返回 0 。

1834
00:55:08,060 --> 00:55:09,740
0,120 120,630 630,810 810,1140 1140,1680
the child for return zero.|
|

1835
00:55:10,100 --> 00:55:12,050
0,450 690,930 930,1380 1380,1590 1590,1950
{} I'm guessing that the
我猜父进程应该返回 19 ，

1836
00:55:12,620 --> 00:55:14,760
0,630 630,1050 1050,1860
parent {fork,return} nineteen,|
|

1837
00:55:14,960 --> 00:55:16,550
0,150 150,270 270,390 390,1140 1200,1590
that is the child's process
这是子进程的进程 id 19 ，

1838
00:55:16,550 --> 00:55:18,740
0,300 300,960 1260,1530 1530,2070 2070,2190
id nineteen,| under xv6, that
|在 xv6 中，意味着是系统启动以来创建的第 19 个进程。

1839
00:55:18,740 --> 00:55:20,510
0,300 300,570 570,660 660,1200 1200,1770
basically means the nineteenth process

1840
00:55:20,510 --> 00:55:22,250
0,150 600,720 720,1140 1140,1350 1350,1740
that was created since boot.|
|

1841
00:55:22,860 --> 00:55:23,580
0,240 240,360 360,450 450,630 630,720
{} And then one of
其中之一，输出 child ，

1842
00:55:23,580 --> 00:55:26,130
0,150 150,720 720,1920 2310,2460 2460,2550
them prints child| and you
|你可以看到 c h i l d ，

1843
00:55:26,130 --> 00:55:26,880
0,90 90,240 240,330 330,570 570,750
can see the c h

1844
00:55:26,880 --> 00:55:28,350
0,150 150,330 330,990 990,1380 1380,1470
i l d,| interleave with
|与另一个交互显示，另一个输出 parent 。

1845
00:55:28,350 --> 00:55:29,580
0,240 240,450 450,780 900,1080 1080,1230
that is the other one

1846
00:55:29,580 --> 00:55:30,480
0,540
{print,parent}.|
|

1847
00:55:30,670 --> 00:55:32,580
0,720 840,1440
So, yeah,
是的，这是 fork 的一种愚蠢的用法，

1848
00:55:32,930 --> 00:55:34,010
0,210 210,300 300,510 510,870 870,1080
this is a silly use

1849
00:55:34,010 --> 00:55:35,060
0,90 90,510 540,810 810,930 930,1050
of fork,| but we can
|但是我们可以在这个输出中清楚地看到，

1850
00:55:35,060 --> 00:55:37,310
0,510 1020,1500 1500,1590 1590,1740 1740,2250
see vividly in this output|
|

1851
00:55:37,310 --> 00:55:38,990
0,180 390,570 570,900 900,1020 1020,1680
that has created two processes
它创建了两个进程。

1852
00:55:38,990 --> 00:55:39,640
0,150 150,300
that are.|
|

1853
00:55:39,920 --> 00:55:40,820
0,210 210,510 510,600 600,780 780,900
And both of them are
并且返回的两个进程都在运行，

1854
00:55:40,820 --> 00:55:42,830
0,390 750,960 960,1290 1290,1500 1500,2010
running for returning both processes

1855
00:55:42,830 --> 00:55:43,880
0,90 90,180 180,420 420,690
and they're both running.|
|

1856
00:55:44,710 --> 00:55:46,030
0,300 300,720 720,990 990,1080 1080,1320
But also note that one
但要注意的是一个输出 child ，另一个输出 parent ，

1857
00:55:46,030 --> 00:55:47,080
0,270 270,720 720,810 810,900 900,1050
printed child and the other

1858
00:55:47,080 --> 00:55:49,750
0,330 1410,1740 1830,1980 1980,2460 2460,2670
parent,| so it's important that
|这很重要， fork 返回的两个进程不同。

1859
00:55:49,930 --> 00:55:51,480
0,300 300,690 690,1290
fork returns differently

1860
00:55:51,770 --> 00:55:53,150
0,300 300,450 450,510 510,660 660,1380
{} and the two processes.|
|

1861
00:55:59,680 --> 00:56:02,380
0,900 1230,1710 1710,1800 1800,2160 2160,2700
Question {},| the child process
有一个提问，|fork 返回的子进程总是和父进程一样，

1862
00:56:02,380 --> 00:56:03,430
0,150 150,240 240,600 600,690 690,1050
as a result of fork

1863
00:56:03,430 --> 00:56:04,750
0,330 330,780 780,870 870,990 990,1320
always identical to the parent

1864
00:56:04,750 --> 00:56:05,890
0,540 540,690 690,900 900,1020 1020,1140
process| or could they be
|它们会不一样吗？

1865
00:56:05,890 --> 00:56:06,740
0,510
different.|
|

1866
00:56:08,250 --> 00:56:12,060
0,30 150,1170 2790,3510 3510,3690 3690,3810
{} {} In {xv6 -
在 xv6 中，是一样的，

1867
00:56:12,060 --> 00:56:13,560
0,300 300,390 390,1200
-} are identical,|
|

1868
00:56:13,740 --> 00:56:16,080
0,660 750,1470 1470,1560 1560,1950 1950,2340
{} except the return value
除了 fork 的返回值。

1869
00:56:16,080 --> 00:56:17,120
0,210 210,750
from fork.|
|

1870
00:56:17,260 --> 00:56:18,430
0,210 210,360 360,540 540,1110 1110,1170
You know the instructions are
你知道指令是相同的，

1871
00:56:18,430 --> 00:56:19,450
0,90 90,450 450,660 660,930 930,1020
the same,| that data is
|数据是相同的，栈也是相同的，

1872
00:56:19,450 --> 00:56:21,130
0,90 90,510 510,630 630,1110 1110,1680
the same, the stack is

1873
00:56:21,130 --> 00:56:23,650
0,120 120,720 960,1410 1770,2130 2130,2520
the same,| {} also both
|两个进程有自己不同的地址空间，

1874
00:56:24,140 --> 00:56:27,770
0,930 1350,1620 2310,2850 2850,3420 3420,3630
processes, the process copies and

1875
00:56:27,800 --> 00:56:29,090
0,210 210,690 690,900 900,1050 1050,1290
they both have their own

1876
00:56:29,090 --> 00:56:30,080
0,690
separate

1877
00:56:30,160 --> 00:56:32,380
0,420 420,1050 1050,1230 1230,1470 1920,2220
address spaces,| that is they
|它们都认为自己的内存从 0 开始，

1878
00:56:32,380 --> 00:56:34,030
0,210 210,480 870,990 990,1290 1290,1650
both have they both think

1879
00:56:34,030 --> 00:56:35,080
0,210 210,360 360,690 690,990 990,1050
that their memory starts at

1880
00:56:35,080 --> 00:56:36,220
0,450 450,600 600,810 810,990 990,1140
zero| and goes on up
|并向上增长，

1881
00:56:36,220 --> 00:56:37,160
0,180 180,600
from there,|
|

1882
00:56:37,400 --> 00:56:40,070
0,600 750,1110 1110,1320 1320,2010 2430,2670
{} but it's different it's
但是其实是不同的内存。

1883
00:56:40,070 --> 00:56:42,240
0,480 720,1200 1200,1800
different different memory,

1884
00:56:42,340 --> 00:56:43,330
0,450 480,630 630,690 690,870 870,990
{} with the two of

1885
00:56:43,330 --> 00:56:43,960
0,270
them.|
|

1886
00:56:45,030 --> 00:56:46,320
0,180 180,210 210,360 360,960 960,1290
In a more sophisticated operating
在一个更复杂的操作系统中，

1887
00:56:46,320 --> 00:56:48,510
0,360 360,480 480,600 600,1020 1590,2190
system,| there are some details
|有一些细节，我们并不关心，

1888
00:56:48,510 --> 00:56:49,650
0,330 360,480 480,750 750,930 930,1140
which we definitely don't care

1889
00:56:49,650 --> 00:56:51,900
0,390 840,1380 1410,1530 1530,1770 1770,2250
about them,| they may occasionally
|它们可能偶尔导致父进程与子进程不同，

1890
00:56:51,900 --> 00:56:53,850
0,660 1230,1500 1500,1620 1620,1890 1890,1950
cause parent and child to

1891
00:56:53,850 --> 00:56:54,750
0,210 210,330 360,540 540,660 660,900
{differ -},| but in {xv6
|但在 xv6 中，除了返回值，都是相同的。

1892
00:56:54,750 --> 00:56:55,860
0,270 270,420 420,510 510,810 810,1110
-}, they're the same except

1893
00:56:55,860 --> 00:56:57,020
0,60 60,420 420,720
the return value.|
|

1894
00:56:57,880 --> 00:56:59,050
0,450 480,630 630,810 810,1110 1110,1170
{} So the memory is
所以内存是相同的，

1895
00:56:59,050 --> 00:57:00,340
0,90 90,360 360,600 600,1050 1050,1290
the same,| in addition the
|另外，文件描述符表是复制的。

1896
00:57:00,340 --> 00:57:01,100
0,420

1897
00:57:02,010 --> 00:57:04,530
0,360 360,1200 1230,1770 1770,1890 1890,2520
file descriptor table is copied.|
|

1898
00:57:05,260 --> 00:57:07,480
0,270 270,390 390,510 510,1260 1920,2220
So if the parent had
所以，如果父进程打开一些文件，

1899
00:57:07,510 --> 00:57:08,920
0,210 210,660 660,1170
some files open,|
|

1900
00:57:09,140 --> 00:57:10,880
0,540 600,780 780,870 870,1470 1470,1740
{} and the child sees
子进程也会看到一组相同的文件描述符。

1901
00:57:10,880 --> 00:57:12,350
0,90 90,690 690,990 990,1110 1110,1470
the same set of file

1902
00:57:12,350 --> 00:57:13,580
0,870
descriptors.|
|

1903
00:57:13,800 --> 00:57:15,330
0,360 390,690 690,870 870,1410 1410,1530
{} Although the child is
虽然子进程看到的是复制的文件描述符信息表。

1904
00:57:15,330 --> 00:57:16,740
0,360 360,510 510,600 600,660 660,1410
seeing them in a copy

1905
00:57:17,180 --> 00:57:18,560
0,210 210,510 660,1020 1020,1110 1110,1380
of the table of file

1906
00:57:18,560 --> 00:57:20,780
0,450 450,1080
descriptor information.|
|

1907
00:57:21,550 --> 00:57:22,210
0,180 180,330 330,480 480,600 600,660
And so we'll see in
我们随后会看到，这是很重要的，

1908
00:57:22,210 --> 00:57:23,260
0,60 60,390 390,600 720,840 840,1050
a moment, that it's quite

1909
00:57:23,260 --> 00:57:25,780
0,450 450,630 1320,1470 1470,1950 1950,2520
important| that a fork copies
|fork 复制打开的文件描述符表和内存。

1910
00:57:25,780 --> 00:57:27,490
0,330 600,1020 1020,1170 1170,1470 1470,1710
the table of open file

1911
00:57:27,490 --> 00:57:28,690
0,690 690,840 840,1020 1020,1140 1140,1200
descriptors as well as the

1912
00:57:28,690 --> 00:57:29,420
0,450
memory.|
|

1913
00:57:31,340 --> 00:57:32,420
0,300 300,780
Okay, so
好的， fork 创建一个新进程，

1914
00:57:33,360 --> 00:57:34,470
0,330 480,720 720,960 960,990 990,1110
{} fork creates a new

1915
00:57:34,470 --> 00:57:36,270
0,510 510,780 1080,1380 1380,1530 1530,1800
process,| but when we run
|当我们在 shell 中运行东西时，

1916
00:57:36,270 --> 00:57:38,250
0,390 390,510 510,570 570,1200 1410,1980
stuff in the shell {},|
|

1917
00:57:39,030 --> 00:57:40,350
0,180 180,600 600,960 960,1290 1290,1320
the shell indeed creates a
shell 实际上创建了一个新进程来运行你输入的命令。

1918
00:57:40,350 --> 00:57:41,880
0,150 150,600 600,720 720,1200 1290,1530
new process to run each

1919
00:57:41,880 --> 00:57:43,260
0,390 390,540 540,630 630,1080
command that you type,|
|

1920
00:57:43,320 --> 00:57:44,040
0,240 270,390 390,480 480,630 630,720
{} but it needs to
但它需要在其中运行命令，

1921
00:57:44,040 --> 00:57:45,000
0,210 210,360 360,420 420,840 840,960
actually run the command in

1922
00:57:45,000 --> 00:57:46,260
0,120 330,660 780,1020 1020,1050 1050,1260
it,| so if I type
|所以如果我输入 ls ，

1923
00:57:46,260 --> 00:57:48,390
0,630 900,1020 1020,1200 1200,1500 1530,2130
ls,| we need to shell
|我们需要 shell fork 创建一个新进程运行 ls ，

1924
00:57:48,750 --> 00:57:50,070
0,540 540,630 630,840 840,900 900,1320
forks to create a process

1925
00:57:50,070 --> 00:57:51,450
0,120 120,300 300,720 720,990 1230,1380
to run ls,| but there
|但是这个新进程需要一些方法，

1926
00:57:51,450 --> 00:57:52,560
0,180 180,270 270,360 360,630 630,1110
needs to be some way

1927
00:57:53,740 --> 00:57:55,630
0,240 240,600 810,1110 1110,1620 1620,1890
for that new process| actually
|来实际运行 ls 程序中的指令。

1928
00:57:55,630 --> 00:57:56,830
0,210 210,300 300,930 930,1080 1080,1200
run the instructions from the

1929
00:57:56,830 --> 00:57:58,200
0,420 420,1080
ls program.|
|

1930
00:57:58,510 --> 00:57:59,740
0,360 360,570 570,1050 1050,1140 1140,1230
Below those instructions from the

1931
00:57:59,740 --> 00:58:02,590
0,300 300,720 720,1230 2580,2760 2760,2850
file called ls and the

1932
00:58:02,590 --> 00:58:04,090
0,510 510,1020 1020,1110 1110,1320 1320,1500
example program, I'm gonna show

1933
00:58:04,090 --> 00:58:05,180
0,120 120,210 210,240 240,600
you in a minute.

1934
00:58:05,320 --> 00:58:06,640
0,330 330,600 600,990 990,1230 1230,1320
Um uses echo echo is

1935
00:58:06,640 --> 00:58:08,860
0,30 30,300 300,570 570,1230 1710,2220
a very simple command a

1936
00:58:09,070 --> 00:58:10,450
0,240 240,450 450,720 720,1260 1260,1380
just takes whatever arguments you

1937
00:58:10,450 --> 00:58:11,650
0,270 270,480 480,630 630,900 900,1200
pass to it and writes

1938
00:58:11,650 --> 00:58:12,860
0,270 270,420 420,570 570,930
them to its output.

1939
00:58:13,860 --> 00:58:15,000
0,300 300,450 450,900 900,990 990,1140
And I prepared for you

1940
00:58:15,000 --> 00:58:17,060
0,60 60,540 540,870 870,1470
a programme called exact.

1941
00:58:17,470 --> 00:58:17,920
0,240
Eat.

1942
00:58:21,300 --> 00:58:22,320
0,750
I'm.

1943
00:58:22,880 --> 00:58:26,020
0,900 1470,1920 1950,2340 2340,2880
Which a run which.

1944
00:58:26,830 --> 00:58:28,390
0,300 300,450 450,840 840,1170 1170,1560
Makes the exact system called

1945
00:58:28,390 --> 00:58:31,060
0,330 510,1200 1200,1290 1290,1800 1800,2670
which replaces the calling process

1946
00:58:31,420 --> 00:58:32,890
0,240 240,330 330,930 930,1230 1230,1470
with the instructions read from

1947
00:58:32,890 --> 00:58:35,440
0,270 330,840 1020,1500 1500,1650 1650,2550
a particular file, you specify

1948
00:58:35,650 --> 00:58:36,720
0,420
a.

1949
00:58:37,110 --> 00:58:38,700
0,690 690,780 780,1290 1290,1410 1410,1590
Loads the instructions from that

1950
00:58:38,700 --> 00:58:40,830
0,510 540,810 810,900 900,1200 1200,2130
file over the current process

1951
00:58:40,830 --> 00:58:42,720
0,210 210,960 960,1110 1110,1410 1410,1890
or discarding its current memory

1952
00:58:42,990 --> 00:58:44,970
0,150 150,330 330,870 900,1620 1710,1980
and then starts executing those

1953
00:58:44,970 --> 00:58:46,770
0,630 630,900 1290,1410 1410,1680 1680,1800
instructions, so the call to

1954
00:58:46,770 --> 00:58:48,720
0,630 810,1260 1260,1500 1500,1860 1860,1950
exec system call exact on

1955
00:58:48,720 --> 00:58:50,920
0,270 270,780
line twelve.

1956
00:58:52,620 --> 00:58:53,280
0,210 210,330 330,390 390,540 540,660
It's going to have the

1957
00:58:53,280 --> 00:58:54,750
0,360 360,600 660,780 780,1140 1140,1470
effect of the operating system

1958
00:58:54,750 --> 00:58:56,070
0,420 420,510 510,1080 1080,1230 1230,1320
loading the instructions from the

1959
00:58:56,070 --> 00:58:57,900
0,570 570,840 870,1530
file called echo.

1960
00:58:57,980 --> 00:58:59,240
0,180 180,270 270,540 540,1080 1080,1260
In the current process sort

1961
00:58:59,240 --> 00:59:01,370
0,120 300,1170 1620,1770 1770,2070 2070,2130
of replacing the memory of

1962
00:59:01,370 --> 00:59:03,500
0,90 90,330 330,990 1320,1770 1770,2130
the current process and then

1963
00:59:03,500 --> 00:59:04,940
0,420 420,480 480,1170
starting to execute.

1964
00:59:05,260 --> 00:59:07,000
0,150 150,450 450,1080 1080,1320 1590,1740
Um, those instructions and in

1965
00:59:07,000 --> 00:59:08,440
0,330 330,450 450,570 570,870 870,1440
addition, you can pass arguments

1966
00:59:08,440 --> 00:59:10,480
0,330 330,540 540,1110 1110,1560 1590,2040
command line arguments echo exec

1967
00:59:10,480 --> 00:59:12,040
0,330 330,390 390,570 780,1290 1290,1560
allows you to pass an

1968
00:59:12,160 --> 00:59:13,960
0,570 570,660 660,960 960,1140 1140,1800
array of command line arguments.

1969
00:59:14,670 --> 00:59:15,450
0,60 60,150 150,360 360,420 420,780
It was just an array

1970
00:59:15,450 --> 00:59:17,370
0,90 90,600 600,690 690,1170 1590,1920
of pointers in c line

1971
00:59:17,370 --> 00:59:19,200
0,330 330,990 990,1200 1200,1260 1260,1830
ten sets up an array

1972
00:59:19,200 --> 00:59:19,780
0,180
of.

1973
00:59:19,810 --> 00:59:21,430
0,540 540,1050 1050,1200 1200,1230 1230,1620
Character pointers which are essentially

1974
00:59:21,430 --> 00:59:24,100
0,750 1170,1620 1620,2220 2220,2400 2400,2670
strings and initialize that array

1975
00:59:24,100 --> 00:59:24,900
0,150 150,480
to be.

1976
00:59:25,040 --> 00:59:27,140
0,480 900,1020 1020,1560 1560,1620 1620,2100
A to contain the strings

1977
00:59:27,140 --> 00:59:29,120
0,420 420,660 660,870 870,1410 1620,1980
echo this is echo I'm.

1978
00:59:29,480 --> 00:59:31,310
0,420 450,690 690,1170 1170,1260 1260,1830
And that's equivalent to calling

1979
00:59:31,490 --> 00:59:32,600
0,300 300,600 600,720 720,870 870,1110
running back with them and

1980
00:59:32,600 --> 00:59:33,140
0,300
with.

1981
00:59:33,360 --> 00:59:34,470
0,120 120,360 360,810 810,990 990,1110
The three arguments, this is

1982
00:59:34,470 --> 00:59:35,820
0,450 870,1020 1020,1140 1140,1290 1290,1350
echo and so when I

1983
00:59:35,820 --> 00:59:36,960
0,300 300,780
want zach.

1984
00:59:38,200 --> 00:59:40,930
0,360 690,1380 1920,2400 2430,2580 2580,2730
Um, indeed, um I see

1985
00:59:40,930 --> 00:59:41,980
0,180 180,450 450,600 600,720 720,1050
this output, this is echo,

1986
00:59:41,980 --> 00:59:43,240
0,180 600,840 840,960 960,1050 1050,1260
but even though I ran

1987
00:59:43,240 --> 00:59:45,670
0,60 60,450 450,810 870,1560 1560,2430
the exact command exact program.

1988
00:59:45,980 --> 00:59:47,330
0,150 150,240 240,600 600,1080 1080,1350
What the exact program does

1989
00:59:47,330 --> 00:59:48,950
0,180 180,630 750,840 840,1230 1230,1620
is calling the exact system

1990
00:59:48,950 --> 00:59:50,390
0,420 540,660 660,1050 1050,1320 1320,1440
call to replace itself with

1991
00:59:50,390 --> 00:59:51,530
0,510 690,840 840,960 960,1020 1020,1140
echo and so it was

1992
00:59:51,530 --> 00:59:53,220
0,150 150,300 300,660 660,1350
really the echo program.

1993
00:59:53,320 --> 00:59:55,260
0,540 570,1080 1080,1260 1260,1680
I'm producing this output.

1994
00:59:58,600 --> 01:00:00,340
0,360 870,1170 1170,1320 1320,1410 1410,1740
And something about the exact

1995
01:00:00,340 --> 01:00:02,230
0,510 690,1020 1020,1380 1380,1770 1770,1890
system call, that's important for

1996
01:00:02,230 --> 01:00:03,790
0,240 240,420 420,690 1050,1380 1380,1560
us is that a it

1997
01:00:04,120 --> 01:00:06,910
0,450 450,1380 1380,1470 1470,1980 2190,2790
exact preserves the current table

1998
01:00:06,910 --> 01:00:08,950
0,90 90,420 420,1260 1470,1680 1680,2040
of file descriptors, so whatever

1999
01:00:08,950 --> 01:00:10,810
0,240 240,690 690,1080 1080,1380 1380,1860
file descriptor zero one two

2000
01:00:10,810 --> 01:00:12,490
0,480 480,810 840,1230 1230,1290 1290,1680
etc were referred to before

2001
01:00:12,490 --> 01:00:13,810
0,450 750,960 960,1170 1170,1230 1230,1320
exec, they refer to the

2002
01:00:13,810 --> 01:00:15,730
0,390 390,990 1350,1530 1530,1680 1680,1920
same thing in this new

2003
01:00:15,730 --> 01:00:17,420
0,1440
program.

2004
01:00:17,670 --> 01:00:19,280
0,240 240,750 750,930 930,1320
Whose instructions we've loaded.

2005
01:00:20,220 --> 01:00:21,690
0,330 330,540 540,660 660,870 900,1470
Another point is that ordinarily

2006
01:00:21,690 --> 01:00:23,850
0,570 570,780 780,990 990,1680 1920,2160
exact does not return because

2007
01:00:23,850 --> 01:00:25,780
0,420 420,1470
exact replaces.

2008
01:00:26,040 --> 01:00:28,440
0,360 510,810 810,1230 1230,1560 1560,2400
The current processes memory entirely,

2009
01:00:28,530 --> 01:00:30,060
0,420 720,900 900,1110 1110,1200 1200,1530
um, there's nothing for exact

2010
01:00:30,060 --> 01:00:32,130
0,60 60,480 480,750 1110,1650 1980,2070
to return to exact you

2011
01:00:32,130 --> 01:00:32,620
0,210
know.

2012
01:00:32,990 --> 01:00:34,340
0,480 480,630 630,1110 1110,1200 1200,1350
Read the instructions for that

2013
01:00:34,340 --> 01:00:35,360
0,300 300,390 390,750 750,900 900,1020
file and execute them and

2014
01:00:35,360 --> 01:00:36,830
0,150 150,390 390,660 1050,1350 1350,1470
then that's it, I'm the

2015
01:00:36,830 --> 01:00:38,240
0,180 180,360 360,720 720,1200 1200,1410
only time exactly turns is

2016
01:00:38,240 --> 01:00:40,730
0,210 540,780 780,1110 1110,1920 2160,2490
if some error occurred that

2017
01:00:40,730 --> 01:00:42,320
0,510 510,660 660,1020 1020,1380 1380,1590
prevented the operating system from

2018
01:00:42,320 --> 01:00:43,610
0,300 300,480 480,900 900,1110 1110,1290
running that program for you,

2019
01:00:43,940 --> 01:00:44,750
0,270 270,390 390,660 660,750 750,810
so for example if the

2020
01:00:44,750 --> 01:00:46,820
0,270 270,780 1020,1440 1440,1530 1530,2070
program doesn't exist at all.

2021
01:00:48,080 --> 01:00:49,700
0,510 510,810 810,1140 1140,1230 1230,1620
Exact can't find a file

2022
01:00:49,700 --> 01:00:51,620
0,300 300,750 840,960 960,1470 1800,1920
called echo, for example an

2023
01:00:51,620 --> 01:00:53,390
0,390 390,540 540,930 930,1260 1260,1770
exec would return negative one.

2024
01:00:54,220 --> 01:00:55,080
0,570
I'm.

2025
01:00:55,520 --> 01:00:58,250
0,420 420,660 2040,2370 2370,2640 2640,2730
Signal that something wrong it

2026
01:00:58,250 --> 01:00:59,390
0,240 420,600 600,780 780,840 840,1140
couldn't couldn't find the file

2027
01:00:59,390 --> 01:01:00,650
0,90 90,570 570,900 900,1080 1080,1260
so ordinarily exact does not

2028
01:01:00,650 --> 01:01:01,460
0,570
return.

2029
01:01:01,520 --> 01:01:04,790
0,150 150,330 330,900 1680,2220 2730,3270
It only returns a colonel.

2030
01:01:05,220 --> 01:01:06,600
0,270 270,630 630,810 810,870 870,1380
Couldn't actually run the fireplace.

2031
01:01:10,430 --> 01:01:11,740
0,330 330,450 450,930
Questions about exactly.

2032
01:01:12,620 --> 01:01:13,490
0,120 120,360 360,450 450,540 540,870
The question in the chat

2033
01:01:13,490 --> 01:01:14,450
0,150 150,330 330,390 390,510 510,960
is what is the last

2034
01:01:14,450 --> 01:01:16,070
0,480 480,870 870,1020 1020,1200 1200,1620
zero four in R V.

2035
01:01:18,850 --> 01:01:20,110
0,210 210,690 690,870 870,1170 1170,1260
It Marks the end of

2036
01:01:20,110 --> 01:01:23,170
0,150 150,870 1830,2370 2370,2520 2520,3060
the array c is so

2037
01:01:23,170 --> 01:01:24,720
0,300 300,840 840,1200
low level that.

2038
01:01:25,000 --> 01:01:27,280
0,660 900,1140 1140,1890
Um, there's no.

2039
01:01:27,670 --> 01:01:30,490
0,240 240,570 570,810 810,1500 1890,2820
The sea or a scheme.

2040
01:01:32,340 --> 01:01:33,960
0,240 240,390 390,480 480,1290
Doesn't have a wafer.

2041
01:01:34,650 --> 01:01:35,640
0,420 420,480 480,750 750,870 870,990
Code to find out how

2042
01:01:35,640 --> 01:01:37,470
0,210 210,270 270,540 540,990 1380,1830
long the array is a

2043
01:01:37,500 --> 01:01:38,760
0,180 180,330 330,630 630,720 720,1260
and so tell the colonel

2044
01:01:38,760 --> 01:01:39,400
0,270
that.

2045
01:01:39,570 --> 01:01:40,560
0,780
I'm.

2046
01:01:40,970 --> 01:01:41,810
0,240 240,330 330,450 450,660 660,840
You know we met at

2047
01:01:42,320 --> 01:01:43,760
0,270 270,540 540,870 870,1170 1170,1440
the array contains eco, this

2048
01:01:43,760 --> 01:01:45,140
0,180 180,630 630,720 720,960 960,1380
is eco and nothing more.

2049
01:01:46,560 --> 01:01:47,820
0,180 180,390 390,960 960,1110 1110,1260
We put zero was the

2050
01:01:47,820 --> 01:01:49,710
0,690 780,1230 1230,1320 1320,1410 1410,1890
last strip as the last.

2051
01:01:50,030 --> 01:01:52,130
0,720 960,1290 1290,1350 1350,1560 1560,2100
Pointer, each of those strings

2052
01:01:52,130 --> 01:01:53,000
0,90 90,300 300,540 540,630 630,870
in double quotes is actually

2053
01:01:53,000 --> 01:01:54,710
0,150 360,810 810,930 930,1110 1110,1710
a pointer to some memory

2054
01:01:54,920 --> 01:01:56,440
0,180 180,510 510,720 720,1290
that contains those bites.

2055
01:01:56,720 --> 01:01:58,160
0,300 300,810 810,1260 1260,1320 1320,1440
That fifth element of the

2056
01:01:58,160 --> 01:02:00,080
0,420 420,600 600,840 1440,1830 1830,1920
array is a {pointer's -}

2057
01:02:00,080 --> 01:02:01,970
0,300 300,420 420,870 1230,1380 1380,1890
value is zero, the convention

2058
01:02:01,970 --> 01:02:02,960
0,150 150,240 240,300 300,750 810,990
is that a pointer whose

2059
01:02:02,960 --> 01:02:04,160
0,300 300,390 390,810 810,1020 1050,1200
value is zero or what's

2060
01:02:04,160 --> 01:02:05,500
0,210 210,240 240,510 510,1020
called a null pointer.

2061
01:02:05,590 --> 01:02:06,520
0,630
I'm.

2062
01:02:07,050 --> 01:02:10,200
0,420 420,630 1050,1650 1650,2070 2550,3150
Sort of signifies nothing, I'm

2063
01:02:10,230 --> 01:02:10,980
0,210 210,390
with it.

2064
01:02:11,620 --> 01:02:13,990
0,180 180,390 390,750 1980,2190 2190,2370
You were gone, so the

2065
01:02:14,020 --> 01:02:15,040
0,450 450,510 510,570 570,900 900,1020
code in the kernel has

2066
01:02:15,040 --> 01:02:16,570
0,570 600,930 930,1050 1050,1200 1200,1530
actually walks through this array

2067
01:02:16,570 --> 01:02:17,680
0,270 270,330 330,600 600,780
until it finds it.

2068
01:02:18,090 --> 01:02:19,920
0,630 900,1140 1140,1440 1440,1530 1530,1830
Element whose value is zero.

2069
01:02:24,690 --> 01:02:27,510
0,600 1050,1500 1830,1980 2520,2730 2730,2820
Okay, um, all right, so

2070
01:02:27,510 --> 01:02:28,350
0,180 180,300 300,510 510,570 570,840
this is how a program

2071
01:02:28,350 --> 01:02:29,780
0,120 120,510 510,1140
can replace itself.

2072
01:02:30,800 --> 01:02:31,760
0,150 150,390 390,750 750,870 870,960
With another program from a

2073
01:02:31,760 --> 01:02:32,810
0,330 330,510 510,750 750,930 930,1050
file, but actually when we

2074
01:02:32,810 --> 01:02:33,800
0,210 210,480 480,540 540,630 630,990
run stuff in the shell

2075
01:02:33,800 --> 01:02:35,960
0,180 180,510 510,1440 1710,1980 1980,2160
like ecco ABC, um or

2076
01:02:35,960 --> 01:02:39,050
0,540 540,930 930,1290 1290,1980 2940,3090
ls or anything else, we

2077
01:02:39,050 --> 01:02:39,920
0,90 90,240 240,300 300,750 750,870
don't want to replace the

2078
01:02:39,920 --> 01:02:41,180
0,450 480,570 570,840 960,1200 1200,1260
shell, we don't have a

2079
01:02:41,180 --> 01:02:43,000
0,390 390,630 630,960 960,1530
shell, just call exact.

2080
01:02:43,420 --> 01:02:45,340
0,390 540,930 1080,1230 1230,1470 1500,1920
A because, that would replace

2081
01:02:45,340 --> 01:02:46,180
0,120 120,360 360,450 450,510 510,840
the shell with the echo

2082
01:02:46,180 --> 01:02:48,240
0,450 450,780 780,1110 1110,1680
command then neko exited.

2083
01:02:48,320 --> 01:02:49,820
0,120 120,210 210,300 300,840 1380,1500
That would be it you

2084
01:02:49,820 --> 01:02:50,810
0,270 540,660 660,780 780,900 900,990
know we don't want an

2085
01:02:50,810 --> 01:02:52,040
0,210 210,300 300,720 720,810 810,1230
echo to replace the shell,

2086
01:02:52,040 --> 01:02:53,480
0,270 420,630 630,870 870,1080 1080,1440
so the shell actually does

2087
01:02:53,480 --> 01:02:54,660
0,180 180,690
is four.

2088
01:02:54,940 --> 01:02:56,140
0,180 180,330 330,420 420,900 900,1200
And then the child calls

2089
01:02:56,140 --> 01:02:57,850
0,480 600,720 720,870 870,930 930,1710
exec and that's an extremely

2090
01:02:57,850 --> 01:03:01,180
0,660 690,1410 1590,2220 2520,2940 2940,3330
common unix idiom program instead.

2091
01:03:01,600 --> 01:03:03,190
0,600 1050,1290 1290,1350 1350,1500 1500,1590
I'm want to run a

2092
01:03:03,190 --> 01:03:04,780
0,330 330,510 510,870 870,1470 1500,1590
program, but regain control what

2093
01:03:04,780 --> 01:03:05,980
0,90 90,240 240,360 360,630 630,1200
they do is call fork

2094
01:03:06,100 --> 01:03:07,120
0,150 150,270 270,360 360,750 750,1020
and have the child called

2095
01:03:07,120 --> 01:03:07,880
0,450
Jack.

2096
01:03:08,000 --> 01:03:09,860
0,180 180,600 600,870 960,1290 1290,1860
So here's a simple example,

2097
01:03:10,520 --> 01:03:12,400
0,270 270,630 630,960 960,1530
this fork exec program.

2098
01:03:14,310 --> 01:03:16,620
0,150 150,330 330,990 1890,2130 2130,2310
In this program call four

2099
01:03:16,620 --> 01:03:18,330
0,330 330,930 960,1110 1110,1200 1200,1710
nine twelve in the child

2100
01:03:18,330 --> 01:03:19,440
0,210 210,300 300,600 600,1020 1020,1110
sort of line fourteen we

2101
01:03:19,440 --> 01:03:20,940
0,180 180,630 630,840 840,990 990,1500
call exact much like before

2102
01:03:21,120 --> 01:03:22,940
0,210 210,300 300,900 900,1620
for the child process.

2103
01:03:23,380 --> 01:03:26,320
0,690 1260,1650 1650,1830 1830,2340 2340,2940
Um has to replace itself

2104
01:03:26,320 --> 01:03:28,060
0,360 360,480 480,750 750,1380
with the echo command.

2105
01:03:28,220 --> 01:03:29,630
0,480 510,870 870,1020 1020,1140 1140,1410
I'm echo, does this thing

2106
01:03:29,630 --> 01:03:31,220
0,90 90,510 540,1260
and then exits.

2107
01:03:31,680 --> 01:03:32,760
0,120 120,240 240,300 300,690 690,1080
And then the parent process,

2108
01:03:32,760 --> 01:03:35,370
0,360 360,960 960,1440 1590,2160 2250,2610
regains control because um when

2109
01:03:35,940 --> 01:03:37,360
0,330 330,1050
fork returns.

2110
01:03:38,000 --> 01:03:39,080
0,300 300,420 420,690 690,990 990,1080
Greater than zero value in

2111
01:03:39,080 --> 01:03:40,040
0,60 60,360 360,780 780,870 870,960
the parent process, so the

2112
01:03:40,040 --> 01:03:41,330
0,240 240,660 660,870 870,1230 1230,1290
parent process then continues to

2113
01:03:41,330 --> 01:03:43,160
0,360 360,450 450,1110 1320,1560 1560,1830
execute at nineteen and unix

2114
01:03:43,160 --> 01:03:45,380
0,390 390,600 600,1170 1350,1860 1860,2220
provides a wait system call

2115
01:03:45,380 --> 01:03:47,810
0,240 240,1500 1500,1890 1890,2010 2010,2430
line 24 process to wait

2116
01:03:47,810 --> 01:03:49,730
0,540 810,1020 1020,1230 1260,1770 1770,1920
for for a child that

2117
01:03:49,730 --> 01:03:52,010
0,450 450,600 600,990 1350,1770 2010,2280
created with four because when

2118
01:03:52,010 --> 01:03:53,870
0,60 60,210 210,300 300,990 1320,1860
I run a command on

2119
01:03:54,290 --> 01:03:55,600
0,90 90,510 510,990
the command line.

2120
01:03:56,330 --> 01:03:59,450
0,390 390,870 1890,2430 2430,2550 2550,3120
We want shell to wait

2121
01:03:59,660 --> 01:04:01,190
0,150 150,360 360,720 720,840 900,1530
for the command to finish

2122
01:04:01,400 --> 01:04:02,630
0,330 330,450 450,720 720,810 810,1230
before it prints the prompt

2123
01:04:02,630 --> 01:04:03,980
0,540 570,870 870,960 960,1230 1230,1350
again before it prints is

2124
01:04:03,980 --> 01:04:05,300
0,330 330,540 540,840 870,1170 1170,1320
Dollar sign prompt asking me

2125
01:04:05,300 --> 01:04:06,620
0,120 120,360 360,750
for more input.

2126
01:04:06,730 --> 01:04:07,900
0,180 180,300 300,450 450,750 750,1170
So it's the wheat system

2127
01:04:07,900 --> 01:04:09,700
0,360 990,1290 1290,1350 1350,1650 1650,1800
call allows a process to

2128
01:04:09,700 --> 01:04:10,870
0,330 330,660 690,900 900,1020 1020,1170
wait for any of its

2129
01:04:10,870 --> 01:04:12,940
0,390 390,510 510,1080 1410,1680 1680,2070
children to return and this

2130
01:04:12,970 --> 01:04:15,070
0,420 420,780 780,870 870,1110 1650,2100
status argument is that um.

2131
01:04:15,590 --> 01:04:17,080
0,510 510,1110
Away for.

2132
01:04:17,950 --> 01:04:20,590
0,180 210,630 630,1380 1440,1980 2130,2640
An exiting child to communicate

2133
01:04:20,590 --> 01:04:24,190
0,630 630,1380 1860,2820 2820,3000 3000,3600
one integer 32 bit value

2134
01:04:24,400 --> 01:04:26,260
0,180 180,240 240,630 630,1110 1500,1860
from the exiting child to

2135
01:04:26,320 --> 01:04:28,180
0,180 180,540 540,1020 1020,1380 1380,1860
the waiting parents online seventeen

2136
01:04:28,180 --> 01:04:29,890
0,150 150,480 480,570 570,1020 1500,1710
that argument to exit that

2137
01:04:29,890 --> 01:04:31,060
0,510 510,690 690,810 810,1110 1110,1170
one that's the argument to

2138
01:04:31,060 --> 01:04:32,000
0,390
exit.

2139
01:04:32,060 --> 01:04:34,790
0,150 150,630 630,1260 1860,2490 2490,2730
The operating system passes that

2140
01:04:34,790 --> 01:04:37,070
0,750 780,960 960,1050 1050,1470 1470,2280
one from the exiting child.

2141
01:04:37,460 --> 01:04:38,570
0,420 450,570 570,660 660,990 990,1110
A to the call to

2142
01:04:38,570 --> 01:04:40,310
0,390 390,630 630,1080 1080,1260 1260,1740
wait line twenty so wait

2143
01:04:40,520 --> 01:04:42,460
0,330 330,1080 1080,1470
the ampersand weight.

2144
01:04:42,700 --> 01:04:44,170
0,360 360,510 510,870 870,960 960,1470
Um is passing the address

2145
01:04:44,170 --> 01:04:46,240
0,90 90,180 180,840 840,1650 1980,2070
of the status variable to

2146
01:04:46,240 --> 01:04:47,770
0,90 90,480 480,570 570,1080 1110,1530
the kernel, the kernel fills

2147
01:04:47,770 --> 01:04:49,400
0,120 120,300 300,840 840,1290
in that address with.

2148
01:04:49,720 --> 01:04:51,520
0,300 300,900 900,1320 1320,1440 1440,1800
I'm child's argument to exit.

2149
01:04:52,770 --> 01:04:53,940
0,150 150,210 210,630 630,780 780,1170
And the convention in unix

2150
01:04:53,940 --> 01:04:56,340
0,120 120,360 750,960 960,1230 1470,2400
is that if a program

2151
01:04:56,340 --> 01:04:58,710
0,360 360,930 930,1440 1530,2190 2220,2370
completes successfully exit exits with

2152
01:04:58,710 --> 01:05:00,120
0,420 420,1140
status zero.

2153
01:05:00,430 --> 01:05:01,870
0,180 180,330 330,480 840,1020 1020,1440
Um, but it has encountered

2154
01:05:01,870 --> 01:05:03,940
0,150 150,810 810,1080 1080,1290 1290,2070
an error at line seventeen.

2155
01:05:04,280 --> 01:05:06,590
0,510 810,1110 1230,1680 1680,2190 2190,2310
I'm the unix convention is

2156
01:05:06,590 --> 01:05:07,550
0,120 120,210 210,450 450,840 840,960
that you pass one to

2157
01:05:07,550 --> 01:05:08,900
0,420 870,990 990,1140 1140,1260 1260,1350
exit and so if you

2158
01:05:08,900 --> 01:05:10,730
0,540 570,810 930,1290 1290,1680 1680,1830
care the calling process can

2159
01:05:10,730 --> 01:05:11,930
0,210 210,330 330,450 450,1020 1020,1200
look at the status from

2160
01:05:11,930 --> 01:05:13,180
0,330
weight.

2161
01:05:13,240 --> 01:05:14,700
0,570 570,870 870,1140
Decide whether the.

2162
01:05:15,270 --> 01:05:19,080
0,750 990,1380 1380,2010 3150,3360 3360,3810
Child completed successfully a professor

2163
01:05:19,080 --> 01:05:20,400
0,300 300,510 510,1050
Morris quick question.

2164
01:05:20,560 --> 01:05:23,710
0,390 720,1740 1950,2340 2340,2760 2760,3150
Yes, about the exact call

2165
01:05:23,710 --> 01:05:25,570
0,300 300,990 1200,1380 1380,1530 1530,1860
nine fifteen um, we mentioned

2166
01:05:25,570 --> 01:05:27,250
0,330 330,630 630,810 810,1170 1170,1680
not a bit ago that

2167
01:05:27,280 --> 01:05:29,500
0,630 660,1320 1350,1860 1860,2010 2010,2220
exec will completely go into

2168
01:05:29,500 --> 01:05:30,760
0,120 120,390 390,870 900,1020 1020,1260
the echo program and not

2169
01:05:30,760 --> 01:05:32,660
0,570 600,840 840,1170 1170,1680
return to fork exec.

2170
01:05:33,060 --> 01:05:35,010
0,330 330,840 870,1290 1320,1590 1620,1950
Um, so, oh, ha would

2171
01:05:35,010 --> 01:05:36,330
0,210 210,480 480,720 720,1230 1230,1320
ever reach line sixteen and

2172
01:05:36,330 --> 01:05:37,260
0,600
seventeen.

2173
01:05:38,170 --> 01:05:38,960
0,510
Well.

2174
01:05:39,720 --> 01:05:41,190
0,300 300,390 390,570 570,990 990,1470
Not for this exact code

2175
01:05:41,190 --> 01:05:42,480
0,180 180,300 300,810 810,930 930,1290
because there happens to be

2176
01:05:42,480 --> 01:05:44,700
0,60 60,480 480,720 720,1170 1650,2220
a program called echo, but

2177
01:05:44,760 --> 01:05:46,410
0,270 270,360 360,930 930,1200 1200,1650
if I modify that code

2178
01:05:46,410 --> 01:05:47,670
0,150 150,300 300,660 660,900 900,1260
here, let me just modify

2179
01:05:47,670 --> 01:05:50,220
0,120 120,750 1800,2070 2070,2250 2250,2550
this code okay so first

2180
01:05:50,220 --> 01:05:50,970
0,90 90,180 180,330 330,540 540,750
let me just run for

2181
01:05:50,970 --> 01:05:51,820
0,480
Kazakh.

2182
01:05:53,590 --> 01:05:55,990
0,330 330,600 600,960 960,1680 2040,2400
It actually does execute echo

2183
01:05:55,990 --> 01:05:56,980
0,120 120,300 300,750 750,840 840,990
with those arguments we see

2184
01:05:56,980 --> 01:05:58,390
0,150 150,600 600,780 780,900 900,1410
the output, this is eco

2185
01:05:58,660 --> 01:05:59,740
0,510 540,780 780,870 870,990 990,1080
m and we see the

2186
01:05:59,740 --> 01:06:01,900
0,450 450,1050 1080,1350 1350,1620 1620,2160
child exited to show that.

2187
01:06:02,900 --> 01:06:05,270
0,660 690,1140 1140,1800 2100,2310 2310,2370
Eco exited successfully and the

2188
01:06:05,270 --> 01:06:06,680
0,330 330,570 570,840 1170,1320 1320,1410
parent wages for let me

2189
01:06:06,680 --> 01:06:07,180
0,270
just.

2190
01:06:07,370 --> 01:06:08,720
0,420 420,480 480,870 870,1050 1050,1350
Modify the program for you.

2191
01:06:09,630 --> 01:06:11,340
0,270 270,540 540,600 600,1170 1380,1710
Um, instead of echo going

2192
01:06:11,340 --> 01:06:12,480
0,60 60,570 600,810 810,1050 1050,1140
to run some command that

2193
01:06:12,480 --> 01:06:13,580
0,180 180,840
doesn't exist.

2194
01:06:14,180 --> 01:06:14,940
0,540
MHM.

2195
01:06:15,360 --> 01:06:16,740
0,300 300,630 630,780 780,1140 1140,1380
Um, actually the exit out

2196
01:06:16,740 --> 01:06:18,870
0,390 420,990 1170,1500 1500,1680 1680,2130
of a queue, um you.

2197
01:06:19,240 --> 01:06:20,950
0,330 330,840 840,1050 1050,1620 1620,1710
With control a ax and

2198
01:06:20,950 --> 01:06:22,030
0,180 180,570 570,630 630,870 870,1080
then rebuild the whole thing

2199
01:06:22,030 --> 01:06:23,380
0,60 60,300 300,450 450,630 630,1350
in order to {re-compile. -}

2200
01:06:23,920 --> 01:06:25,380
0,180 180,1200
I modified.

2201
01:06:25,850 --> 01:06:27,020
0,450 450,570 570,750 750,960 960,1170
Forbes now run four weeks

2202
01:06:27,020 --> 01:06:29,180
0,150 150,630 630,900 900,1650 1980,2160
back again after modifying it.

2203
01:06:29,800 --> 01:06:30,760
0,150 150,300 300,480 480,840 840,960
And this time because the

2204
01:06:30,760 --> 01:06:32,280
0,300 300,390 390,720 720,1230
program we're asking too.

2205
01:06:32,760 --> 01:06:34,220
0,600 690,1140
I'm actually.

2206
01:06:36,600 --> 01:06:37,950
0,120 120,480 480,630 630,1020 1020,1350
The program, we're asking to

2207
01:06:38,070 --> 01:06:40,380
0,360 360,570 570,1170 1530,1980 1980,2310
execute doesn't exist, exec does

2208
01:06:40,380 --> 01:06:42,150
0,780 900,1080 1080,1230 1230,1350 1350,1770
return we see the exact

2209
01:06:42,150 --> 01:06:43,560
0,600 600,1080
failed output.

2210
01:06:43,840 --> 01:06:45,760
0,510 630,810 810,900 900,1230 1230,1920
Um, and the exit one

2211
01:06:45,850 --> 01:06:46,750
0,210 210,330 330,390 390,690 690,900
you'll see the one there

2212
01:06:46,750 --> 01:06:47,920
0,330 360,840 840,1020 1020,1110 1110,1170
is communicated back to the

2213
01:06:47,920 --> 01:06:49,270
0,450 450,630 630,870 870,960 960,1350
parent which says the child

2214
01:06:49,270 --> 01:06:50,760
0,360 360,450 450,810 810,1170
exited the status one.

2215
01:06:52,280 --> 01:06:54,920
0,240 240,810 810,2040 2070,2520 2520,2640
So exact returns back to

2216
01:06:54,920 --> 01:06:56,690
0,150 150,690 690,1170 1170,1440 1440,1770
the calling function when something

2217
01:06:56,690 --> 01:06:57,680
0,180 180,570
went wrong.

2218
01:06:57,740 --> 01:06:58,520
0,450
Yes.

2219
01:07:01,180 --> 01:07:01,700
0,150
Yeah.

2220
01:07:08,700 --> 01:07:11,040
0,390 420,870
Okay good.

2221
01:07:14,680 --> 01:07:17,140
0,510 540,960 1080,1500 1500,1800 1830,2460
Alright, um something that s

2222
01:07:17,140 --> 01:07:18,190
0,210 210,270 270,570 570,840 840,1050
going to note here that

2223
01:07:18,340 --> 01:07:19,540
0,300 300,570 690,960 960,1020 1020,1200
actually think many of you

2224
01:07:19,540 --> 01:07:21,240
0,300 300,720 750,960 960,1230
already noted is that.

2225
01:07:21,300 --> 01:07:22,830
0,330 330,750 810,1050 1050,1140 1140,1530
A it is a common

2226
01:07:22,830 --> 01:07:24,660
0,390 390,600 600,810 810,1380 1560,1830
idiom here, this fork followed

2227
01:07:24,660 --> 01:07:26,100
0,120 120,600 600,660 660,780 780,1440
by exec in the child

2228
01:07:26,580 --> 01:07:28,170
0,510 630,990 990,1380 1380,1440 1440,1590
and it's potentially a bit

2229
01:07:28,170 --> 01:07:30,090
0,540 540,660 660,1050 1380,1860 1860,1920
wasteful the fork copies the

2230
01:07:30,090 --> 01:07:32,080
0,390 390,870 870,1800
entire parent process.

2231
01:07:32,320 --> 01:07:34,240
0,210 210,750 900,1380 1380,1800 1800,1920
But exact throws away all

2232
01:07:34,240 --> 01:07:36,550
0,210 210,600 600,1230 1530,1830 1830,2310
that copied memory and replaces

2233
01:07:36,550 --> 01:07:37,840
0,180 180,360 360,870 870,990 990,1290
it with, whatever is in

2234
01:07:37,840 --> 01:07:38,860
0,270 270,270
the um.

2235
01:07:39,670 --> 01:07:40,990
0,300 300,660 660,780 780,900 900,1320
A file that you're running,

2236
01:07:40,990 --> 01:07:43,210
0,360 1770,1950 1950,2040 2040,2130 2130,2220
so you know if you're

2237
01:07:43,210 --> 01:07:43,960
0,240 240,420 420,540 540,690 690,750
worried about this kind of

2238
01:07:43,960 --> 01:07:46,600
0,360 360,840 1110,2070 2130,2550 2550,2640
stuff, the copy implied by

2239
01:07:46,600 --> 01:07:47,580
0,150 150,690
the fork.

2240
01:07:48,160 --> 01:07:49,690
0,690 720,840 840,1050 1050,1260 1260,1530
Is in some sense mostly

2241
01:07:49,690 --> 01:07:51,070
0,420 420,690 690,810 810,1050 1050,1380
wasted because all that copied

2242
01:07:51,070 --> 01:07:52,450
0,390 390,630 630,930 930,1140 1140,1380
memory is just thrown away

2243
01:07:52,450 --> 01:07:54,010
0,120 120,660 660,780 780,1050 1110,1560
and replaced by the exact.

2244
01:07:55,270 --> 01:07:56,500
0,240 240,510 510,780 780,1080 1080,1230
And this affects actually would

2245
01:07:56,500 --> 01:07:57,940
0,120 120,720 720,810 810,990 990,1440
be significant for big programs,

2246
01:07:57,940 --> 01:07:58,870
0,90 90,180 180,270 270,390 390,930
if you have a multi

2247
01:07:58,870 --> 01:08:00,610
0,480 480,960 960,1050 1050,1350 1350,1740
gigabyte program that calls forth.

2248
01:08:01,050 --> 01:08:02,460
0,420 420,540 540,720 750,1080 1080,1410
Um, and it did indeed

2249
01:08:02,460 --> 01:08:03,360
0,300 300,420 420,480 480,780 780,900
copy all the memory would

2250
01:08:03,360 --> 01:08:05,010
0,450 510,930 930,1020 1020,1230 1230,1650
actually take a fair fraction

2251
01:08:05,010 --> 01:08:06,600
0,60 60,120 120,540 600,1260 1500,1590
of a second perhaps to

2252
01:08:06,600 --> 01:08:07,620
0,90 90,240 240,660
do the copy.

2253
01:08:07,740 --> 01:08:08,820
0,510 540,720 720,900 900,1020 1020,1080
Um, which could be a

2254
01:08:08,820 --> 01:08:09,560
0,420
problem.

2255
01:08:10,080 --> 01:08:10,900
0,510
HMM.

2256
01:08:12,520 --> 01:08:14,320
0,570 660,1110 1170,1650 1650,1740 1740,1800
Um, but later in the

2257
01:08:14,320 --> 01:08:16,570
0,390 390,600 600,1260 1530,2070 2070,2250
course you'll actually implement some

2258
01:08:16,570 --> 01:08:18,370
0,750 750,870 870,1260 1260,1470 1470,1800
optimization in particular something called

2259
01:08:18,370 --> 01:08:20,410
0,390 390,570 570,870 870,1440 1710,2040
copy on write fork which

2260
01:08:20,410 --> 01:08:22,870
0,360 600,1200 1200,1650 1650,2280 2280,2460
will eliminate almost all of

2261
01:08:22,870 --> 01:08:25,480
0,150 150,1020 1380,1680 1680,2490 2490,2610
the apparent a inefficiency of

2262
01:08:25,480 --> 01:08:27,280
0,450 450,1080 1080,1380 1380,1500 1500,1800
fork copying only to have

2263
01:08:27,370 --> 01:08:28,870
0,450 450,660 660,870 870,990 990,1500
exact throw away the copy.

2264
01:08:29,180 --> 01:08:29,780
0,90 90,300 300,420 420,540 540,600
It turns out with a

2265
01:08:29,780 --> 01:08:31,280
0,240 240,300 300,750 750,1320 1320,1500
bunch of tricks involving a

2266
01:08:31,310 --> 01:08:32,760
0,270 270,570 570,1080
virtual memory system.

2267
01:08:32,920 --> 01:08:34,630
0,480 960,1200 1200,1380 1380,1620 1620,1710
Um, you can build a

2268
01:08:34,630 --> 01:08:36,040
0,420 420,660 660,1080 1080,1320 1320,1410
fork, that's lazy about the

2269
01:08:36,040 --> 01:08:37,750
0,660 690,960 960,1110 1110,1350 1350,1710
copy and that doesn't do

2270
01:08:37,900 --> 01:08:39,520
0,270 270,600 900,1230 1230,1500 1500,1620
in the common case of

2271
01:08:39,520 --> 01:08:40,960
0,240 240,630 630,900 900,1020 1020,1440
fork immediately followed by exec.

2272
01:08:41,420 --> 01:08:42,530
0,240 240,450 450,570 570,780 780,1110
Um, or you don't actually

2273
01:08:42,530 --> 01:08:43,310
0,120 120,180 180,270 270,390 390,780
have to do the copy

2274
01:08:43,310 --> 01:08:44,630
0,240 240,330 330,690 690,960 960,1320
because the child doesn't actually

2275
01:08:44,630 --> 01:08:45,770
0,330 330,600 600,690 690,780 780,1140
use most of the memory.

2276
01:08:46,900 --> 01:08:47,600
0,420
HMM.

2277
01:08:48,100 --> 01:08:48,850
0,150 150,300 300,390 390,540 540,750
I think you'll find that's

2278
01:08:48,850 --> 01:08:50,410
0,270 360,660 660,780 780,1170 1170,1560
a fun and interesting lab

2279
01:08:51,040 --> 01:08:53,230
0,390 390,720 720,1140 1470,2010 2010,2190
question from chat, why does

2280
01:08:53,230 --> 01:08:55,360
0,120 120,540 540,1050 1080,1740 1740,2130
the parent process parent waiting

2281
01:08:55,360 --> 01:08:57,370
0,780 780,1110 1110,1230 1230,1620 1620,2010
completely before the child calls

2282
01:08:57,370 --> 01:08:58,140
0,450
exec.

2283
01:08:59,240 --> 01:08:59,840
0,60
Yeah.

2284
01:09:00,710 --> 01:09:03,000
0,300 300,870 1110,2010
It's just chance.

2285
01:09:03,820 --> 01:09:05,980
0,690 1140,1770
I'm bi.

2286
01:09:06,940 --> 01:09:07,900
0,150 150,570 570,720 720,870 870,960
Why is it that you

2287
01:09:07,900 --> 01:09:09,880
0,120 120,720 720,1410 1410,1590 1590,1980
know the observation is that,

2288
01:09:09,970 --> 01:09:12,060
0,630 1140,1290 1290,1710
um, you know.

2289
01:09:13,130 --> 01:09:14,240
0,360 390,540 540,810 810,960 960,1110
Um, it could be that

2290
01:09:14,240 --> 01:09:15,590
0,90 90,510 510,1050 1050,1230 1230,1350
the parents output could be

2291
01:09:15,590 --> 01:09:17,540
0,630 630,720 720,810 810,1500 1560,1950
interleaved with the child's output

2292
01:09:17,540 --> 01:09:18,200
0,60 60,150 150,420 420,540 540,660
in the same area that

2293
01:09:18,200 --> 01:09:20,180
0,90 90,330 330,870 900,1200 1230,1980
we saw before with similar

2294
01:09:20,180 --> 01:09:22,400
0,330 330,810 1230,1620 1920,2040 2040,2220
fork example, um, it just

2295
01:09:22,400 --> 01:09:23,780
0,390 390,630 630,720 720,1020 1230,1380
happens not to be there's

2296
01:09:23,780 --> 01:09:25,280
0,180 180,990 990,1260 1260,1410 1410,1500
no guarantee that this is

2297
01:09:25,280 --> 01:09:26,480
0,120 120,420 420,540 540,660 660,1200
the output, we would see

2298
01:09:26,720 --> 01:09:27,800
0,330 330,540 540,750
in fact we.

2299
01:09:28,070 --> 01:09:29,450
0,420 420,690 690,810 810,1320 1320,1380
We shouldn't be surprised if

2300
01:09:29,450 --> 01:09:30,170
0,90 90,240 240,360 360,660 660,720
we saw the lines of

2301
01:09:30,170 --> 01:09:30,890
0,120 120,420 420,510 510,600 600,720
the output in the other

2302
01:09:30,890 --> 01:09:33,240
0,510 870,1170 1170,1530 1530,2070
order a orange league.

2303
01:09:33,620 --> 01:09:35,720
0,300 300,1020 1020,1230 1230,1530 1530,2100
I suspect what's going on

2304
01:09:35,750 --> 01:09:37,550
0,210 210,540 1050,1230 1230,1530 1530,1800
is that it takes a

2305
01:09:37,580 --> 01:09:38,990
0,270 270,360 360,720 720,810 810,1410
bit of time and effort.

2306
01:09:39,770 --> 01:09:40,940
0,180 180,720 720,960 960,1140 1140,1170
The exact system caused a

2307
01:09:40,940 --> 01:09:42,050
0,180 180,300 300,810 810,1020 1020,1110
little bit expensive because it

2308
01:09:42,050 --> 01:09:43,730
0,120 120,300 390,1170 1170,1320 1320,1680
has to load all those

2309
01:09:43,790 --> 01:09:45,260
0,210 210,330 330,540 870,1380 1380,1470
you have to access the

2310
01:09:45,260 --> 01:09:46,400
0,300 300,630 630,750 750,1050 1050,1140
file system and access the

2311
01:09:46,400 --> 01:09:47,870
0,330 330,480 480,840 840,930 930,1470
disk and read the contents

2312
01:09:47,870 --> 01:09:49,010
0,90 90,150 150,480 480,750 750,1140
of a file called echo

2313
01:09:49,010 --> 01:09:50,780
0,240 240,390 390,810 840,1080 1080,1770
off the disk into memory,

2314
01:09:51,050 --> 01:09:53,180
0,660 660,990 990,1530 1530,1680 1680,2130
a after allocating some memory

2315
01:09:53,180 --> 01:09:54,500
0,150 150,420 420,600 600,900 900,1320
and that even after freeing

2316
01:09:54,500 --> 01:09:55,460
0,180 180,540 540,660 660,750 750,960
some memory from the old

2317
01:09:55,460 --> 01:09:57,080
0,390 390,630 900,1410 1410,1590 1590,1620
process so there's quite a

2318
01:09:57,080 --> 01:09:58,280
0,120 120,180 180,720 720,1140 1140,1200
bit of machinery involved in

2319
01:09:58,280 --> 01:10:00,230
0,90 90,480 480,810 810,1140 1560,1950
the exact system call, um.

2320
01:10:00,860 --> 01:10:03,050
0,330 330,1050 1500,1740 1740,1980 1980,2190
And apparently that takes long

2321
01:10:03,050 --> 01:10:04,190
0,300 300,450 450,510 510,900 900,1140
enough that the parent can

2322
01:10:04,190 --> 01:10:06,500
0,570 840,1410 1410,1530 1530,2040
complete producing the output.

2323
01:10:06,580 --> 01:10:08,320
0,690 690,780 780,1170 1170,1320 1320,1740
Before the exec is finished

2324
01:10:08,320 --> 01:10:09,680
0,120 120,510 510,720 720,1080
and started running ecco.

2325
01:10:10,400 --> 01:10:11,960
0,180 180,300 300,420 420,840
Does that make sense.

2326
01:10:15,360 --> 01:10:17,160
0,360 360,930 930,1110 1110,1200 1200,1800
Another question is a convention

2327
01:10:17,160 --> 01:10:18,480
0,120 120,210 210,660 660,1020 1020,1320
that the child can't wait

2328
01:10:18,480 --> 01:10:19,560
0,120 120,210 210,780
for the parent.

2329
01:10:21,520 --> 01:10:24,790
0,390 390,840 840,1530 1920,2850 2910,3270
There's not a way unix

2330
01:10:24,790 --> 01:10:25,960
0,390 390,630 630,720 720,1020 1020,1170
doesn't have a way for

2331
01:10:25,960 --> 01:10:27,160
0,90 90,810
the child.

2332
01:10:28,220 --> 01:10:29,690
0,360 360,510 510,1110 1110,1410 1410,1470
There's no straightforward waving a

2333
01:10:29,690 --> 01:10:30,860
0,360 360,600 600,780 780,810 810,1170
child away from a parent.

2334
01:10:31,930 --> 01:10:33,860
0,180 180,510 510,960 960,1590
The wait system call.

2335
01:10:34,680 --> 01:10:36,510
0,240 240,660 660,960 1080,1380 1380,1830
Because it's the only mechanism

2336
01:10:36,510 --> 01:10:38,460
0,540 570,870 1110,1410 1410,1650 1650,1950
available well the wait system

2337
01:10:38,460 --> 01:10:41,130
0,480 780,1530 1710,1890 1890,2040 2040,2670
call waits for your children.

2338
01:10:41,880 --> 01:10:42,700
0,120 120,330 330,540
And that's it.

2339
01:10:43,620 --> 01:10:44,730
0,180 180,300 300,480 480,840 840,1110
And so what weight what

2340
01:10:44,730 --> 01:10:47,370
0,240 240,600 600,1260 1620,2100 2430,2640
weight does is, um, if

2341
01:10:47,370 --> 01:10:48,980
0,210 210,450 450,630 630,1350
you have any children.

2342
01:10:49,080 --> 01:10:49,830
0,180 180,360 360,420 420,570 570,750
And one of them has

2343
01:10:49,830 --> 01:10:52,110
0,300 300,960 1350,1590 1590,1800 1800,2280
already exited what does exit.

2344
01:10:52,740 --> 01:10:54,540
0,180 180,420 420,600 600,1230 1590,1800
Then we will return but

2345
01:10:54,540 --> 01:10:55,080
0,90 90,180 180,300 300,420 420,540
you know if you don't

2346
01:10:55,080 --> 01:10:56,340
0,120 120,270 270,720 720,990 990,1260
have any children say, because

2347
01:10:56,340 --> 01:10:57,300
0,120 120,630
you are.

2348
01:10:57,360 --> 01:11:00,450
0,510 1890,2070 2070,2220 2220,2520 2520,3090
Because in this simple case,

2349
01:11:00,720 --> 01:11:01,660
0,630
um.

2350
01:11:02,120 --> 01:11:02,930
0,150 150,300 300,450 450,510 510,810
It was just a parent

2351
01:11:02,930 --> 01:11:04,520
0,150 150,780 1020,1140 1140,1230 1230,1590
and child if the child

2352
01:11:04,520 --> 01:11:05,660
0,300 300,840
called wait.

2353
01:11:06,890 --> 01:11:07,730
0,120 120,390 390,570 570,660 660,840
The child doesn't have any

2354
01:11:07,730 --> 01:11:09,200
0,600 870,1050 1050,1110 1110,1260 1260,1470
children and in that case,

2355
01:11:09,200 --> 01:11:10,640
0,240 240,420 420,780 780,1290 1290,1440
wait just returns immediately with

2356
01:11:10,640 --> 01:11:12,500
0,30 30,450 450,1110 1140,1470 1470,1860
a minus one error return

2357
01:11:12,500 --> 01:11:14,000
0,480 630,810 810,1170 1170,1410 1410,1500
saying this process doesn't have

2358
01:11:14,000 --> 01:11:14,740
0,120 120,450
any children.

2359
01:11:15,440 --> 01:11:16,940
0,330 330,570 840,1140 1140,1380 1380,1500
Anyway, the short answer is

2360
01:11:16,940 --> 01:11:17,660
0,150 150,300 300,510 510,630 630,720
there's no way for a

2361
01:11:17,660 --> 01:11:19,280
0,690 1020,1140 1140,1350 1350,1470 1470,1620
child to wait for its

2362
01:11:19,280 --> 01:11:20,400
0,480 480,570 570,900
parent to exit.

2363
01:11:21,930 --> 01:11:23,070
0,150 150,450 450,840 840,1020 1020,1140
And another question when we

2364
01:11:23,070 --> 01:11:24,720
0,240 240,390 390,810 810,1440 1440,1650
say the child copies all

2365
01:11:24,720 --> 01:11:26,370
0,90 90,900 1050,1290 1290,1350 1350,1650
the memory from the parent

2366
01:11:26,370 --> 01:11:28,290
0,450 450,900 930,1560 1560,1710 1710,1920
process, what exactly do we

2367
01:11:28,290 --> 01:11:29,430
0,360 360,540 540,690 690,1020 1050,1140
refer to by that I

2368
01:11:29,430 --> 01:11:30,870
0,210 210,300 300,870 1110,1230 1230,1440
thought the child is going

2369
01:11:30,870 --> 01:11:32,970
0,480 600,1080 1080,1170 1170,1680 1680,2100
to define the variables again.

2370
01:11:37,570 --> 01:11:38,640
0,720
I'm.

2371
01:11:39,050 --> 01:11:40,250
0,180 180,360 360,510 510,840 840,1200
Or when you compile this,

2372
01:11:40,250 --> 01:11:41,840
0,150 150,450 630,1320
you know, um.

2373
01:11:45,260 --> 01:11:48,740
0,540 540,1530 1800,2130 2130,2400 2400,3480
After compilation, your c program.

2374
01:11:49,220 --> 01:11:49,820
0,150 150,300 300,360 360,540 540,600
It's just a bunch of

2375
01:11:49,820 --> 01:11:51,800
0,570 570,630 630,1200 1650,1830 1830,1980
instructions in memory that live

2376
01:11:51,800 --> 01:11:52,720
0,90 90,660
in Ram.

2377
01:11:53,430 --> 01:11:54,400
0,690
I'm.

2378
01:11:55,070 --> 01:11:56,060
0,300 300,450 450,690 690,810 810,990
And so those can be

2379
01:11:56,060 --> 01:11:57,000
0,660
copied.

2380
01:11:57,360 --> 01:11:58,500
0,210 210,330 330,510 510,930 930,1140
Because they're just bites living

2381
01:11:58,500 --> 01:11:59,610
0,90 90,420 420,900 900,1020 1020,1110
in Ram, those can be

2382
01:11:59,610 --> 01:12:02,020
0,360 360,630 630,1260 1560,2130
copied somewhere else, um.

2383
01:12:02,370 --> 01:12:04,200
0,240 240,510 600,1170 1170,1590 1590,1830
And with appropriate trick having

2384
01:12:04,200 --> 01:12:05,190
0,60 60,180 180,330 330,720 720,990
to do with setting up.

2385
01:12:06,500 --> 01:12:07,880
0,120 120,330 330,450 540,930 930,1380
A sort of virtual memory

2386
01:12:07,880 --> 01:12:10,340
0,600 600,960 1050,1530 1980,2250 2250,2460
{mapping's -} and make map

2387
01:12:10,340 --> 01:12:11,030
0,180 180,300 300,360 360,630 630,690
things look the same in

2388
01:12:11,030 --> 01:12:12,020
0,60 60,420 420,510 510,570 570,990
the child and the parent

2389
01:12:12,020 --> 01:12:12,860
0,90 90,180 180,390 390,750 750,840
you can just copy the

2390
01:12:12,860 --> 01:12:14,480
0,570 570,930 930,1410 1410,1530 1530,1620
parent's memory image to the

2391
01:12:14,480 --> 01:12:15,780
0,570 600,1020
child and.

2392
01:12:16,360 --> 01:12:17,760
0,600 600,660 660,1080
Executing the child.

2393
01:12:20,660 --> 01:12:21,560
0,150 150,480 480,570 570,660 660,900
And even though we're looking

2394
01:12:21,560 --> 01:12:22,580
0,90 90,360 360,750 750,870 870,1020
at c programs, you should

2395
01:12:22,580 --> 01:12:23,360
0,210 210,300 300,480 480,600 600,780
think of them as just

2396
01:12:23,360 --> 01:12:25,610
0,30 30,270 270,660 900,1320 1320,2250
a bunch of machine instructions.

2397
01:12:26,920 --> 01:12:28,180
0,450 510,690 690,930 930,1200 1200,1260
Um, which is bytes in

2398
01:12:28,180 --> 01:12:29,200
0,330 330,420 420,510 510,600 600,1020
memory that can be copied.

2399
01:12:31,280 --> 01:12:32,660
0,180 180,360 360,810 810,960 960,1380
If a parent has multiple

2400
01:12:32,660 --> 01:12:34,460
0,780 780,960 960,1260 1260,1470 1470,1800
children would wait just return

2401
01:12:34,460 --> 01:12:35,270
0,90 90,300 300,420 420,510 510,810
as soon as the first

2402
01:12:35,270 --> 01:12:36,860
0,360 360,960 960,1260 1260,1440 1440,1590
child finishes meaning that there

2403
01:12:36,860 --> 01:12:38,300
0,150 150,270 270,480 480,780 780,1440
could be some more interleaving

2404
01:12:38,300 --> 01:12:39,470
0,120 120,210 210,540 540,660 660,1170
with the parent and unfinished

2405
01:12:39,470 --> 01:12:40,850
0,570 840,990 990,1110 1110,1290 1290,1380
children with their need to

2406
01:12:40,850 --> 01:12:42,290
0,150 150,600 600,990 990,1290 1290,1440
be multiple separate ways to

2407
01:12:42,290 --> 01:12:44,100
0,390 390,600 600,1020 1020,1530
ensure all children finished.

2408
01:12:44,340 --> 01:12:46,500
0,780 840,1140 1140,1320 1320,1770 1800,2160
Yes, yeah, if you call

2409
01:12:46,500 --> 01:12:47,370
0,270 270,420 420,510 510,750 750,870
forth more than one if

2410
01:12:47,370 --> 01:12:49,650
0,690 690,1050 1050,1680 1710,2010 2010,2280
a given process calls for

2411
01:12:49,950 --> 01:12:50,820
0,750
twice.

2412
01:12:51,360 --> 01:12:54,030
0,540 1110,1890 2130,2340 2340,2580 2580,2670
Um, then it wants to

2413
01:12:54,030 --> 01:12:54,900
0,120 120,240 240,420 420,780 780,870
wait for both children and

2414
01:12:54,900 --> 01:12:56,760
0,150 150,240 240,480 480,810 1110,1860
has to call wait twice

2415
01:12:56,850 --> 01:12:58,140
0,240 240,420 420,540 540,960
each call to wait.

2416
01:12:58,280 --> 01:12:59,930
0,180 180,690 690,870 870,1200 1200,1650
Will return as soon as

2417
01:12:59,990 --> 01:13:01,490
0,330 330,510 510,630 630,1020 1020,1500
one of the children exits

2418
01:13:01,490 --> 01:13:02,750
0,120 120,450 570,750 750,960 960,1260
you don't when weight returns

2419
01:13:02,750 --> 01:13:04,370
0,90 90,210 210,750 750,1020 1020,1620
you don't necessarily know which

2420
01:13:04,670 --> 01:13:06,560
0,540 540,660 660,1200 1500,1650 1650,1890
child is exited the weight

2421
01:13:06,560 --> 01:13:08,930
0,630 630,960 1080,1500 1500,1890 1890,2370
returns the child's process ID

2422
01:13:08,930 --> 01:13:09,920
0,150 150,300 300,570 570,840 840,990
as its return value so

2423
01:13:09,920 --> 01:13:11,060
0,90 90,210 210,810
you can tell.

2424
01:13:11,420 --> 01:13:13,190
0,330 330,480 480,1230 1440,1530 1530,1770
After we returns you know

2425
01:13:13,250 --> 01:13:14,060
0,240 240,420 420,510 510,720 720,810
which one it was at

2426
01:13:14,060 --> 01:13:14,740
0,390
exit.

2427
01:13:19,030 --> 01:13:19,620
0,330
HMM.

2428
01:13:22,660 --> 01:13:24,610
0,120 120,210 210,570 570,1200 1320,1950
As a final example, um.

2429
01:13:25,640 --> 01:13:27,520
0,270 270,450 450,570 570,1530
I'd like to show.

2430
01:13:28,080 --> 01:13:30,510
0,480 480,990 990,1260 1260,1860 1980,2430
Um, how all these um

2431
01:13:30,570 --> 01:13:33,640
0,600 600,1590 1950,2520
facilities combine, um.

2432
01:13:33,740 --> 01:13:37,730
0,870 1860,2760 2760,3120 3120,3720 3720,3990
To implement io direction, so

2433
01:13:37,790 --> 01:13:39,410
0,240 240,360 360,1020 1170,1530 1530,1620
if you remember, um, the

2434
01:13:39,410 --> 01:13:40,670
0,420 420,810 810,990 990,1080 1080,1260
shell provides us with this

2435
01:13:40,670 --> 01:13:42,770
0,300 300,1230 1680,1800 1800,1920 1920,2100
handy syntax I can say

2436
01:13:42,770 --> 01:13:44,180
0,240 240,510 510,660 660,990 990,1410
echo hello is going out.

2437
01:13:44,830 --> 01:13:46,240
0,510 600,870 870,1080 1080,1170 1170,1410
Um that runs the echo

2438
01:13:46,240 --> 01:13:48,310
0,600 600,840 840,1320 1410,1800 1800,2070
command that argument sending it.

2439
01:13:48,800 --> 01:13:50,750
0,600 1050,1470 1470,1620 1620,1830 1830,1950
First, hmm that sends its

2440
01:13:50,750 --> 01:13:51,800
0,270 270,330 330,450 450,720 720,1050
output to the file out

2441
01:13:51,800 --> 01:13:52,980
0,120 120,420 420,870
and looked out.

2442
01:13:53,120 --> 01:13:54,480
0,300 570,780 780,1050
Or better yet.

2443
01:13:55,340 --> 01:13:56,900
0,570 660,870 870,930 930,1380 1380,1560
I'm on the capcom and

2444
01:13:56,900 --> 01:13:59,660
0,120 120,360 360,1050 1470,2040 2250,2760
with its input connected from

2445
01:13:59,690 --> 01:14:01,730
0,210 210,450 450,930 1560,1920 1920,2040
the out file, we can

2446
01:14:01,730 --> 01:14:02,960
0,150 150,360 360,720 720,1110 1110,1230
see that saved output from

2447
01:14:02,960 --> 01:14:04,080
0,60 60,300 300,660
the echo command.

2448
01:14:04,980 --> 01:14:06,870
0,540 1080,1320 1320,1470 1470,1560 1560,1890
Um the way the shell

2449
01:14:06,870 --> 01:14:08,060
0,330 330,540 540,840
sets this up.

2450
01:14:08,840 --> 01:14:11,630
0,360 390,1050 1230,1830 1890,2070 2070,2790
Um is, um, as follows.

2451
01:14:13,390 --> 01:14:14,360
0,660
I'm.

2452
01:14:15,320 --> 01:14:18,500
0,420 1080,1410 1440,1980 1980,2310 2310,3180
It a shell first forks

2453
01:14:18,620 --> 01:14:20,300
0,420 420,540 540,750 750,1440 1530,1680
like on line thirteen and

2454
01:14:20,300 --> 01:14:22,280
0,300 360,630 630,750 750,1620 1860,1980
then in the child, the

2455
01:14:22,280 --> 01:14:23,960
0,510 540,1200 1200,1320 1320,1530 1530,1680
shell changes the way the

2456
01:14:23,960 --> 01:14:25,520
0,300 300,870 870,960 960,1260 1260,1560
file descriptors are set up

2457
01:14:25,520 --> 01:14:27,530
0,150 150,300 300,420 420,1530 1710,2010
so that the child's file

2458
01:14:27,530 --> 01:14:28,980
0,420 420,750 750,1080
descriptor, one which.

2459
01:14:29,200 --> 01:14:31,210
0,180 180,960 1110,1410 1410,1800 1800,2010
By convention most programs used

2460
01:14:31,210 --> 01:14:33,140
0,90 90,210 210,690 1140,1650
for the output, um.

2461
01:14:33,470 --> 01:14:35,690
0,210 210,720 840,1290 1320,2040 2040,2220
This shell a changes the

2462
01:14:35,690 --> 01:14:37,430
0,570 570,810 810,1290 1290,1380 1380,1740
child's file descriptor to one

2463
01:14:37,430 --> 01:14:39,530
0,120 120,840 870,1170 1170,1560 1620,2100
to refer to this output

2464
01:14:39,530 --> 01:14:41,750
0,510 900,1440 1440,1620 1620,1890 1890,2220
file, and then run whatever

2465
01:14:41,750 --> 01:14:42,950
0,360 360,450 450,780 840,990 990,1200
commands you wanted and that

2466
01:14:42,950 --> 01:14:45,470
0,450 450,750 840,1380 1410,2280 2280,2520
leaves the parent shells file

2467
01:14:45,470 --> 01:14:47,960
0,390 390,630 630,1590 2040,2220 2220,2490
scripter one unchanged so this

2468
01:14:47,990 --> 01:14:49,760
0,420 420,690 960,1530 1530,1650 1650,1770
idiom of forking and in

2469
01:14:49,760 --> 01:14:51,800
0,60 60,870 1200,1470 1470,1830 1830,2040
a child a changing around

2470
01:14:51,800 --> 01:14:53,260
0,90 90,390 390,1290
the file descriptors.

2471
01:14:53,360 --> 01:14:54,620
0,120 120,390 390,600 600,1050 1050,1260
A is the usual way

2472
01:14:54,620 --> 01:14:55,520
0,150 150,240 240,660 660,750 750,900
in your next I saw

2473
01:14:56,120 --> 01:14:57,360
0,180 210,930
a redirect.

2474
01:14:57,460 --> 01:14:58,960
0,270 270,360 360,750 750,1110 1350,1500
Input an output for a

2475
01:14:58,960 --> 01:14:59,980
0,360 360,450 450,570 570,810 810,1020
command that you run but

2476
01:15:00,130 --> 01:15:01,600
0,570 570,960 960,1050 1050,1350 1350,1470
not affect the input and

2477
01:15:01,600 --> 01:15:04,300
0,480 480,960 1080,1530 1770,2310 2310,2700
output for a calling program

2478
01:15:04,300 --> 01:15:04,990
0,240 240,360 360,450 450,600 600,690
because we don't want to

2479
01:15:04,990 --> 01:15:06,720
0,360 360,450 450,900 900,1380
redirect the shell's output.

2480
01:15:07,150 --> 01:15:08,650
0,450 780,990 990,1110 1110,1260 1260,1500
Um, we only want to

2481
01:15:08,800 --> 01:15:11,500
0,630 1200,1320 1320,1830 1830,2340 2340,2700
redirect the child programs output.

2482
01:15:12,670 --> 01:15:13,810
0,300 300,360 360,510 510,660 660,1140
Anyway, the way this works

2483
01:15:14,050 --> 01:15:15,490
0,120 120,330 330,600 600,990 990,1440
we call fork unusual way,

2484
01:15:15,730 --> 01:15:17,620
0,510 540,840 840,1170 1170,1440 1440,1890
a line fifteen only executes

2485
01:15:17,620 --> 01:15:18,720
0,60 60,150 150,750
in the child.

2486
01:15:18,860 --> 01:15:20,030
0,210 210,540 540,630 630,690 690,1170
The reason for the close

2487
01:15:20,030 --> 01:15:21,410
0,330 330,450 450,690 690,1260 1260,1380
one on line fifteen is

2488
01:15:21,410 --> 01:15:23,200
0,150 150,270 270,480 480,990
that in this program.

2489
01:15:23,590 --> 01:15:25,270
0,210 210,1020 1050,1290 1290,1470 1470,1680
We're redirecting a just the

2490
01:15:25,270 --> 01:15:26,530
0,480 480,540 540,630 630,900 900,1260
output of the echo command,

2491
01:15:26,530 --> 01:15:27,490
0,150 150,390 390,450 450,750 750,960
so when I run this

2492
01:15:27,490 --> 01:15:28,360
0,510
redirect.

2493
01:15:28,640 --> 01:15:31,130
0,270 300,1050 1680,2100 2100,2220 2220,2490
A program produces no output

2494
01:15:31,130 --> 01:15:32,450
0,390 390,630 630,900 900,1200 1200,1320
itself, it ran echo with

2495
01:15:32,450 --> 01:15:34,010
0,150 150,570 570,960 960,1080 1080,1560
its output directly to output

2496
01:15:34,010 --> 01:15:35,380
0,240 240,1050
dot txt.

2497
01:15:35,540 --> 01:15:36,560
0,210 210,330 330,660 690,930 930,1020
So when I look at

2498
01:15:36,560 --> 01:15:39,720
0,450 450,720 720,1530 2340,2880
output dot txt, um.

2499
01:15:39,770 --> 01:15:41,330
0,150 150,330 330,630 660,1200 1200,1560
I see this expected output,

2500
01:15:41,750 --> 01:15:42,560
0,120 120,300 300,390 390,450 450,810
the reason for the close

2501
01:15:42,560 --> 01:15:44,540
0,180 180,300 300,540 540,1320
one on line fifteen.

2502
01:15:44,900 --> 01:15:46,880
0,180 180,450 1020,1530 1560,1800 1800,1980
Is that a we want

2503
01:15:46,880 --> 01:15:48,410
0,690 840,1080 1080,1110 1170,1440 1440,1530
one as a sort of

2504
01:15:48,530 --> 01:15:50,300
0,630 630,990 990,1230 1230,1650 1650,1770
conventional output file script to

2505
01:15:50,300 --> 01:15:52,160
0,270 270,360 360,720 720,1260 1710,1860
refer to something else, it

2506
01:15:52,160 --> 01:15:53,990
0,780 810,1140 1140,1230 1230,1530 1740,1830
happens so we don't have

2507
01:15:53,990 --> 01:15:55,070
0,150 150,660 660,750 750,900 900,1080
a child, we don't want

2508
01:15:55,070 --> 01:15:56,360
0,60 60,630 630,750 750,1050 1050,1290
to use the father scripture,

2509
01:15:56,360 --> 01:15:57,470
0,330 330,510 510,600 600,870 870,1110
one that the shell had

2510
01:15:57,500 --> 01:15:58,790
0,180 180,570 570,660 660,720 720,1290
that's connected to the console.

2511
01:15:59,660 --> 01:16:00,830
0,300 300,420 420,750 750,870 870,1170
Um the call to open

2512
01:16:00,830 --> 01:16:02,480
0,90 90,330 330,900 900,1050 1050,1650
on line sixteen is guaranteed

2513
01:16:02,480 --> 01:16:04,820
0,90 90,480 480,840 840,1620 1920,2340
to return one because, um

2514
01:16:04,880 --> 01:16:06,170
0,120 120,600 600,690 690,1080 1080,1290
the semantics of open are

2515
01:16:06,170 --> 01:16:07,850
0,180 210,540 540,900 900,1020 1020,1680
that open returns the lowest.

2516
01:16:08,410 --> 01:16:10,090
0,300 300,750 750,1080 1080,1320 1320,1680
File descriptor number, that's not

2517
01:16:10,090 --> 01:16:12,430
0,450 450,630 630,1260 2070,2280 2280,2340
currently in use in the

2518
01:16:12,430 --> 01:16:14,080
0,360 360,1020 1050,1380 1380,1470 1470,1650
calling process since we just

2519
01:16:14,080 --> 01:16:15,260
0,300 300,870
closed one.

2520
01:16:15,420 --> 01:16:16,950
0,180 180,360 360,750 750,1140 1140,1530
And file descriptor zero is

2521
01:16:18,330 --> 01:16:19,590
0,330 330,660 660,720 720,780 780,1260
still connected to the console,

2522
01:16:19,590 --> 01:16:20,400
0,60 60,420
I mean.

2523
01:16:20,460 --> 01:16:22,380
0,600 900,1260 1260,1380 1380,1830 1830,1920
I'm open is guaranteed to

2524
01:16:22,380 --> 01:16:23,440
0,330 330,780
return one.

2525
01:16:24,290 --> 01:16:26,660
0,300 300,540 540,870 1350,1590 1590,2370
So after the line sixteen

2526
01:16:27,050 --> 01:16:28,310
0,240 240,510 510,750 750,840 840,1260
Bob scripture one is connected

2527
01:16:28,310 --> 01:16:29,880
0,150 150,750
as fire.

2528
01:16:30,220 --> 01:16:31,540
0,90 90,330 330,690 690,1080 1080,1320
The movie exec echo echo

2529
01:16:31,540 --> 01:16:32,980
0,180 180,780 930,1110 1110,1350 1350,1440
just writes its output, the

2530
01:16:32,980 --> 01:16:34,900
0,180 180,510 510,990 1350,1680 1680,1920
file descriptor one and now

2531
01:16:34,900 --> 01:16:35,920
0,120 120,270 270,450 450,810 840,1020
go to this file and

2532
01:16:35,920 --> 01:16:36,640
0,90 90,300 300,420 420,600 600,720
the cool thing about this

2533
01:16:36,640 --> 01:16:37,720
0,90 90,450 450,600 600,750 750,1080
is echo had no idea

2534
01:16:37,720 --> 01:16:39,310
0,180 180,420 420,660 1080,1320 1320,1590
what's going on echo doesn't

2535
01:16:39,310 --> 01:16:40,450
0,210 210,270 270,450 450,720 720,1140
need to know about IoT

2536
01:16:40,450 --> 01:16:42,040
0,630 660,810 810,1170 1200,1320 1320,1590
direction at all, it just

2537
01:16:42,310 --> 01:16:43,330
0,270 270,420 420,690 690,750 750,1020
writes its output, the file

2538
01:16:43,330 --> 01:16:44,400
0,420 420,750
descriptor one.

2539
01:16:45,160 --> 01:16:48,130
0,510 690,1050 1050,1140 1140,1860 2430,2970
I'm only the shell, a

2540
01:16:48,160 --> 01:16:49,140
0,270 270,660
knows about.

2541
01:16:49,330 --> 01:16:50,600
0,420 420,1020
Io redirection.

2542
01:16:52,380 --> 01:16:54,720
0,300 300,690 690,1620 1650,2250 2250,2340
This example also illustrates the

2543
01:16:54,720 --> 01:16:55,540
0,180 180,390
sort of.

2544
01:16:56,090 --> 01:16:58,250
0,390 390,630 1020,1860 1860,2010 2010,2160
Kind of neatness of the

2545
01:16:58,250 --> 01:17:00,110
0,690 690,1080 1080,1350 1350,1440 1440,1860
separation between fork and exact

2546
01:17:00,110 --> 01:17:01,040
0,60 60,300 300,450 450,840 840,930
the fact that fork and

2547
01:17:01,040 --> 01:17:03,440
0,480 480,720 780,1320 1320,1710 1710,2400
exact our separate system calls

2548
01:17:04,220 --> 01:17:05,100
0,450
separate.

2549
01:17:05,560 --> 01:17:07,720
0,330 330,1140
Um functions.

2550
01:17:08,130 --> 01:17:09,270
0,390 390,510 510,720 720,810 810,1140
Means that there's a period

2551
01:17:09,270 --> 01:17:10,440
0,60 60,510 570,750 750,840 840,1170
of time in the child

2552
01:17:10,440 --> 01:17:11,720
0,360 360,450 450,1020
between the fork.

2553
01:17:11,980 --> 01:17:13,030
0,270 270,420 420,630 630,960 960,1050
Between them for returns in

2554
01:17:13,030 --> 01:17:14,680
0,90 90,540 600,810 810,1320 1320,1650
the child and exactly which

2555
01:17:14,890 --> 01:17:16,480
0,180 180,720 720,1080 1080,1170 1170,1590
were still running the calling

2556
01:17:16,480 --> 01:17:18,970
0,630 630,1380 1380,1500 1500,1650 1980,2490
processes instructions, so the calling

2557
01:17:18,970 --> 01:17:20,080
0,840
process.

2558
01:17:20,160 --> 01:17:21,090
0,180 180,240 240,360 360,630 630,930
Even though it's running in

2559
01:17:21,420 --> 01:17:22,680
0,390 390,900 900,960 960,1170 1170,1260
those instructions are running in

2560
01:17:22,680 --> 01:17:24,120
0,90 90,630 930,1110 1110,1350 1350,1440
the child, it's still the

2561
01:17:24,120 --> 01:17:26,010
0,330 330,990 990,1680 1680,1770 1770,1890
calling processes instructions that are

2562
01:17:26,010 --> 01:17:27,600
0,570 990,1080 1080,1170 1170,1260 1260,1590
executed and so the calling

2563
01:17:27,600 --> 01:17:30,120
0,450 450,570 570,1440 2130,2400 2400,2520
process is still able to

2564
01:17:30,120 --> 01:17:31,920
0,450 450,1140 1200,1500 1500,1740 1740,1800
change things and still in

2565
01:17:31,920 --> 01:17:33,660
0,450 450,600 600,870 870,1110 1110,1740
control up until line nineteen.

2566
01:17:34,380 --> 01:17:35,250
0,150 150,300 300,480 480,540 540,870
And this sort of interval

2567
01:17:35,250 --> 01:17:37,230
0,330 330,540 540,630 630,1170 1530,1980
between fork and exec gives

2568
01:17:37,230 --> 01:17:38,310
0,120 120,330 330,390 390,780 780,1080
the show a chance to

2569
01:17:38,580 --> 01:17:40,350
0,450 450,600 600,690 690,990 990,1770
change what the file scriptures,

2570
01:17:40,380 --> 01:17:41,820
0,390 390,570 570,720 720,1140
refer to for example.

2571
01:17:43,180 --> 01:17:45,460
0,390 390,840 840,1170 1170,1590 1650,2280
Any questions about this redirect

2572
01:17:45,460 --> 01:17:46,220
0,420
example.

2573
01:17:46,560 --> 01:17:46,940
0,60
Yeah.

2574
01:17:55,220 --> 01:17:58,400
0,420 450,990 2220,3030 3030,3120 3120,3180
Alright I'm about out of

2575
01:17:58,400 --> 01:18:00,080
0,600
time.

2576
01:18:00,410 --> 01:18:01,760
0,300 390,810 810,1020 1020,1140 1140,1350
Just wrap up we look

2577
01:18:01,760 --> 01:18:03,520
0,150 150,540 540,900 930,1440
at unix is, um.

2578
01:18:03,800 --> 01:18:05,690
0,300 300,510 510,600 600,1170 1290,1890
A bunch of the interfaces,

2579
01:18:05,690 --> 01:18:07,820
0,150 150,480 480,570 570,1650 1680,2130
the eunuchs as Iowa process

2580
01:18:07,820 --> 01:18:10,160
0,810 1410,1770 1800,2100 2100,2190 2190,2340
abstractions a thing to take

2581
01:18:10,160 --> 01:18:10,910
0,240 240,360 360,570 570,660 660,750
away from this is if

2582
01:18:10,910 --> 01:18:12,770
0,180 180,660 660,750 750,1200 1200,1860
the interfaces are relatively simple

2583
01:18:12,800 --> 01:18:14,630
0,120 120,300 300,870 1020,1290 1290,1830
and just pass a imagers

2584
01:18:14,630 --> 01:18:16,070
0,180 180,420 420,960 960,1050 1050,1440
like file descriptors and process

2585
01:18:16,070 --> 01:18:17,750
0,420 420,660 660,780 780,1110 1110,1680
ideas back and forth across

2586
01:18:18,050 --> 01:18:20,450
0,150 150,780 780,1140 1140,1590 1980,2400
his arguments system calls, um.

2587
01:18:20,820 --> 01:18:21,900
0,390 420,750
But sir.

2588
01:18:22,360 --> 01:18:24,130
0,150 150,210 210,870 870,1590 1620,1770
Well, the functionality inside the

2589
01:18:24,130 --> 01:18:26,710
0,420 420,660 660,1500 1530,2310 2310,2580
interface is relatively sophisticated like.

2590
01:18:27,180 --> 01:18:29,340
0,510 510,630 630,1290 1290,1470 1740,2160
Creating new processes and copying

2591
01:18:29,340 --> 01:18:31,560
0,60 60,360 360,870 1260,1440 1440,2220
the current process and furthermore

2592
01:18:31,710 --> 01:18:32,880
0,390 390,570 570,690 690,1110 1110,1170
I show some examples of

2593
01:18:32,880 --> 01:18:34,410
0,270 270,330 330,480 480,600 600,1530
ways in which the abstractions

2594
01:18:34,440 --> 01:18:37,200
0,330 330,870 870,1380 1710,2520 2520,2760
zo individually simple combine in

2595
01:18:37,200 --> 01:18:39,900
0,390 390,1140 1350,1500 1500,2100 2400,2700
useful ways, for example to

2596
01:18:39,990 --> 01:18:40,800
0,630
produce.

2597
01:18:40,890 --> 01:18:42,120
0,360 360,960
Io redirection.

2598
01:18:44,030 --> 01:18:45,080
0,180 180,270 270,690 690,960 960,1050
There's a lab due at

2599
01:18:45,080 --> 01:18:46,100
0,90 90,180 180,270 270,570 570,1020
the end of next week

2600
01:18:46,970 --> 01:18:48,770
0,240 240,390 390,660 660,1230 1230,1800
and that lab involves writing

2601
01:18:48,830 --> 01:18:50,360
0,390 390,720 720,1320 1320,1440 1440,1530
more simple utilities like the

2602
01:18:50,360 --> 01:18:51,470
0,240 240,360 360,750 750,870 870,1110
ones I showed that use

2603
01:18:51,470 --> 01:18:52,310
0,90 90,390 390,690 690,780 780,840
the system calls that we

2604
01:18:52,310 --> 01:18:54,000
0,570
discuss.

2605
01:18:54,140 --> 01:18:54,980
0,210 210,450 450,600 600,690 690,840
So, have fun with that

2606
01:18:54,980 --> 01:18:56,780
0,390 420,900 1290,1590 1590,1710 1710,1800
lab and I'll see you

2607
01:18:56,780 --> 01:18:57,880
0,60 60,330 330,510 510,840
in class next week.

2608
01:18:58,640 --> 01:18:59,420
0,570
MHM.

2609
01:19:01,520 --> 01:19:02,580
0,270 270,510 510,660
And that's it.

2610
01:19:08,480 --> 01:19:08,940
0,180 180,300
Thank you.

2611
01:19:15,170 --> 01:19:16,550
0,330 330,450 450,510 510,720 720,1380
Since I'm the one recording,

2612
01:19:16,670 --> 01:19:18,110
0,510 540,750 750,870 870,1050 1050,1440
how do I end this

2613
01:19:18,680 --> 01:19:20,210
0,300 300,420 420,810 810,1050 1050,1530
first time recording in lecture

2614
01:19:20,600 --> 01:19:21,710
0,240 240,300 300,420 420,570 570,1110
or they will be exit.

2615
01:19:22,520 --> 01:19:23,870
0,330 510,870 870,1200 1200,1230 1230,1350
Okay, nothing special I can

2616
01:19:23,870 --> 01:19:24,680
0,120 120,450 450,600 600,690 690,810
just exit it will be

2617
01:19:24,680 --> 01:19:25,580
0,270 270,630
saved somewhere.

2618
01:19:26,220 --> 01:19:28,020
0,1050 1080,1500
Yes, awesome.

2619
01:19:32,010 --> 01:19:33,060
0,30 90,510 510,630 630,900 900,1050
I assume we'll create some

2620
01:19:33,060 --> 01:19:34,520
0,630 720,1140
directory and.

2621
01:19:35,120 --> 01:19:35,990
0,300 300,330 330,630 630,750 750,870
Sticking a file in that

2622
01:19:35,990 --> 01:19:36,840
0,480
directory.

2623
01:19:38,600 --> 01:19:39,800
0,180 180,420 420,780 780,1020 1020,1200
There's also office hours right

2624
01:19:39,800 --> 01:19:41,140
0,240 240,480 480,840
after this right.

2625
01:19:41,930 --> 01:19:46,380
0,480 930,1380 3270,3780
Yes, perfect cool.

2626
01:19:48,050 --> 01:19:48,480
0,300
Happy.

2627
01:19:50,340 --> 01:19:51,220
0,480
Alright.

2628
01:19:51,580 --> 01:19:53,680
0,390 870,1140 1140,1410 1410,1740 1890,2100
Alright, thank you and I'll

2629
01:19:53,680 --> 01:19:55,060
0,180 180,240 240,420 420,750 960,1380
see you next week, thanks.

