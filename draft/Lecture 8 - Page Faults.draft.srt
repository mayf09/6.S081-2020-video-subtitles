1
00:00:12,310 --> 00:00:13,330
0,390 390,690 690,840 840,960 960,1020
Okay, okay, we get a
好的，我们检查一下声音，大家都能听到我说话吗？

2
00:00:13,330 --> 00:00:14,920
0,300 300,900 930,1110 1110,1410 1410,1590
sound check, can everybody hear

3
00:00:14,920 --> 00:00:15,820
0,390
me?|
|

4
00:00:18,980 --> 00:00:22,340
0,510 900,1470 2010,2580 2760,3180 3180,3360
Yep.| Okay, good, whatever, let's
是的。|好的，我们开始。

5
00:00:22,340 --> 00:00:26,060
0,1170 1170,1500 1500,2220 2580,3180 3180,3720
{} going.| {} Good afternoon,
|下午好，傍晚好，早上好，晚上好，无论你在哪里。

6
00:00:26,060 --> 00:00:27,020
0,150 180,390 390,690 690,810 810,960
or good evening or good

7
00:00:27,020 --> 00:00:29,090
0,570 1170,1260 1260,1500 1500,1800 1800,2070
morning or good night, wherever

8
00:00:29,090 --> 00:00:32,300
0,150 150,480 1020,1650 1770,2400 2400,3210
you are.| {} Today's lecture,
|今天的讲座，我要讲的是页面错误。

9
00:00:32,300 --> 00:00:33,230
0,60 60,210 210,270 270,420 420,930
I'm going to be, about

10
00:00:33,230 --> 00:00:34,320
0,240 240,720
page fault.|
|

11
00:00:34,780 --> 00:00:39,010
0,750 870,2040 2160,2610 2610,3180 3510,4230
In particular, we're gonna {}
具体来说，我们的计划的是，

12
00:00:39,040 --> 00:00:40,760
0,480 480,630 630,1170
plan is to,|
|

13
00:00:41,930 --> 00:00:46,880
0,810 1230,2010 2340,3300 3630,4260 4260,4950
cover {} implement, {} implemented
使用页面错误，实现几个虚拟内存功能。

14
00:00:46,880 --> 00:00:48,220
0,570
{number,of}

15
00:00:50,130 --> 00:00:52,480
0,780 780,1170 1170,1800
virtual memory features,

16
00:00:53,660 --> 00:00:55,720
0,390 390,810 810,1020 1020,1440
{} using page faults.|
使用页面错误。|

17
00:01:03,680 --> 00:01:05,510
0,510 510,1320 1320,1410 1410,1740 1740,1830
{} And the features that
我们接下来要看的功能是懒分配，

18
00:01:05,510 --> 00:01:06,560
0,120 120,270 270,390 390,660 660,1050
we're gonna be looking at

19
00:01:06,560 --> 00:01:09,580
0,510 750,1170 1200,1620 1620,2490
are {} lazy allocation,|
|

20
00:01:09,760 --> 00:01:10,960
0,180 180,240 240,750 780,1110 1110,1200
which is the topic of
这是下一个实验的主题。

21
00:01:10,960 --> 00:01:12,440
0,90 90,360 360,930
the next lab.|
|

22
00:01:12,920 --> 00:01:14,520
0,810

23
00:01:14,950 --> 00:01:16,000
0,240 240,360 360,600 600,810 810,1050
Yeah, we're gonna look at
是的，我们还要看，写入时复制 fork ，按需调页，以及内存映射文件， mmap 。

24
00:01:16,000 --> 00:01:18,780
0,360 360,840 870,1500 1500,2160
demand {}, copy-and-write fork,

25
00:01:20,100 --> 00:01:22,700
0,840 870,1170 1170,1980
{} demand paging,

26
00:01:27,340 --> 00:01:28,990
0,540 540,690 690,780 780,990 990,1650
and {memory -} map files,

27
00:01:29,170 --> 00:01:30,600
0,240 240,390 390,780
{mmap - -}.|
|

28
00:01:32,540 --> 00:01:35,020
0,720 960,1830
And, um.|
还有，嗯。|

29
00:01:35,080 --> 00:01:36,520
0,180 180,810 870,1110 1110,1290 1290,1440
And almost you know in
几乎所有操作系统都实现了这些功能，

30
00:01:36,520 --> 00:01:37,450
0,150 150,210 210,270 270,570 570,930
sort of {} [] operating

31
00:01:37,450 --> 00:01:39,220
0,360 360,630 630,1050 1050,1320 1320,1770
system actually implements all these

32
00:01:39,340 --> 00:01:42,130
0,720 1590,2010 2010,2250 2250,2340 2340,2790
features,| look inside of Linux,
|深入 Linux ，你会看到所有这些功能都已经实现。

33
00:01:42,130 --> 00:01:43,330
0,360 360,540 540,720 720,930 930,1200
you'll see all these features

34
00:01:43,330 --> 00:01:45,790
0,480 480,1080 1080,1620 1830,2280 2280,2460
actually are implemented.| {} In
|在 xv6 中，目前（这些功能）一个都没有实现。

35
00:01:45,790 --> 00:01:47,080
0,330 330,570 570,720 720,810 810,1290
{xv6 -}, as it stands

36
00:01:47,080 --> 00:01:48,340
0,210 210,330 330,480 480,600 600,1260
none of them are implemented.|
|

37
00:01:49,340 --> 00:01:51,230
0,510 510,780 780,1140 1140,1620 1620,1890
{} In fact, what page
实际上，页面错误在 xv6 中做的是，

38
00:01:51,230 --> 00:01:53,870
0,240 240,960 960,1650 1650,2130 2130,2640
fault {does,in} xv6,| if {page,fault,happens,in}
|如果在用户空间中发生页面错误，就杀死这个进程，没有别的[事情]。

39
00:01:53,870 --> 00:01:55,640
0,300 300,960 960,1380 1380,1680 1680,1770
user space, basically kill the

40
00:01:55,640 --> 00:01:57,920
0,570 930,1290 1290,1740
process, whatever [interesting].|
|

41
00:01:57,920 --> 00:01:59,030
0,360 360,750 750,900 900,960 960,1110
{} And so in this
所以在这次演讲中，我们要探索一下，

42
00:01:59,030 --> 00:02:00,050
0,240 240,300 300,420 420,480 480,1020
lecture, we're going to explore|
|

43
00:02:00,050 --> 00:02:01,220
0,300 300,630 630,840 840,960 960,1170
what interesting things, you could
可以在页面错误处理器中做什么有趣的事情，来实现这些功能。

44
00:02:01,220 --> 00:02:02,180
0,210 210,360 360,450 450,690 690,960
do in the page fault

45
00:02:02,180 --> 00:02:04,250
0,450 780,1230 1230,1500 1500,1860 1860,2070
handler to actually implement these

46
00:02:04,250 --> 00:02:06,050
0,690 1020,1260 1260,1440 1440,1740 1740,1800
features.| So this lecture a
|所以这节课，减少了演示代码，更多是设计层面的。

47
00:02:06,050 --> 00:02:07,880
0,180 180,330 330,870 900,1680 1680,1830
little bit less walking through

48
00:02:07,880 --> 00:02:10,700
0,540 540,810 810,1710 1710,2370 2370,2820
code and understanding existing code,

49
00:02:10,790 --> 00:02:11,840
0,240 240,390 390,510 510,690 690,1050
a little bit more design

50
00:02:11,840 --> 00:02:13,760
0,450 570,1050 1050,1560 1560,1620 1620,1920
level.| {} In the sense,
|从这个意义上来说，我们甚至没有代码可看。

51
00:02:13,760 --> 00:02:14,780
0,210 210,420 420,570 570,750 750,1020
we don't even have code

52
00:02:14,780 --> 00:02:15,680
0,90 90,330 330,480
to look at.|
|

53
00:02:16,130 --> 00:02:17,630
0,450 570,810 810,990 990,1170 1170,1500
{} Another thing that's important
另一个重要的东西是懒分配，

54
00:02:17,630 --> 00:02:18,500
0,60 60,390 390,540 540,600 600,870
to mention is {} lazy

55
00:02:18,500 --> 00:02:19,550
0,450 450,570 570,900 900,960 960,1050
allocation,| is topic of the
|是下一个实验的主题，

56
00:02:19,550 --> 00:02:21,080
0,210 210,630 900,1230 1230,1320 1320,1530
next lab,| hopefully it will
|希望它能在今天推出。

57
00:02:21,140 --> 00:02:23,480
0,240 240,360 360,810 960,1800 1800,2340
push out today.| {} And
|写入时复制 fork ，也是一个实验的主题，

58
00:02:23,540 --> 00:02:25,460
0,750 750,1290 1320,1470 1470,1650 1650,1920
copy-on-write fork, it's gonna be

59
00:02:25,460 --> 00:02:26,900
0,780 780,1110 1110,1170 1170,1350 1350,1440
a topic of one of

60
00:02:26,900 --> 00:02:28,910
0,90 90,600 720,1380 1380,1800 1830,2010
the labs| and {} {mmap
|还有， mmap 也是后续实验的另一个主题。

61
00:02:28,910 --> 00:02:29,840
0,390 420,660 660,780 780,840 840,930
-} is going to be

62
00:02:29,840 --> 00:02:30,890
0,300 300,660 660,750 750,960 960,1050
another topic of one of

63
00:02:30,890 --> 00:02:32,380
0,210 210,660 660,1140
the subsequent labs.|
|

64
00:02:32,500 --> 00:02:33,670
0,210 210,360 360,510 510,630 630,1170
{} So this is gonna
所以这是操作系统中最有趣的部分之一，

65
00:02:33,730 --> 00:02:34,870
0,60 300,480 480,570 570,750 750,1140
be one of the interesting

66
00:02:34,870 --> 00:02:36,370
0,420 420,570 570,630 630,930 930,1500
parts of an operating system,|
|

67
00:02:36,460 --> 00:02:37,870
0,690 690,840 840,930 930,1200 1200,1410
we're gonna be spending quite
我们将在这些实验上花费很多时间。

68
00:02:37,870 --> 00:02:38,560
0,30 30,150 150,210 210,480 480,690
a bit of time on

69
00:02:38,560 --> 00:02:39,720
0,180 180,720
these labs.|
|

70
00:02:41,110 --> 00:02:42,760
0,630 660,1110 1110,1230 1230,1320 1320,1650
Now, {} you know before
现在，在深入讨论细节之前，

71
00:02:42,760 --> 00:02:45,790
0,570 570,1050 1050,1920 1920,2610 2820,3030
diving into details,| {} it
|回顾一下可能会有帮助，

72
00:02:45,790 --> 00:02:48,160
0,150 150,600 600,1080 1080,1620 1620,2370
is probably helpful to {}

73
00:02:48,400 --> 00:02:49,150
0,300 300,360 360,510 510,630 630,750
take a little bit of

74
00:02:49,150 --> 00:02:50,920
0,330 330,570 570,1050 1080,1380 1380,1770
{} step back| and so
|你可以认为虚拟内存主要有两个好处。

75
00:02:51,010 --> 00:02:52,300
0,270 270,510 510,780 780,990 990,1290
you can think about virtual

76
00:02:52,300 --> 00:02:53,760
0,330 330,870
memory having

77
00:02:54,550 --> 00:02:56,820
0,570 570,1080 1080,1770
two major benefits.|
|

78
00:03:02,370 --> 00:03:04,700
0,690 720,870 870,1560
One is isolation,
一个是隔离，从某种意义上说，隔离是，

79
00:03:05,140 --> 00:03:06,970
0,480 540,1380 1380,1470 1470,1530 1530,1830
so isolation in the sense

80
00:03:06,970 --> 00:03:08,980
0,360 570,1020 1020,1320 1320,1620 1620,2010
that,| {} virtual memory allows
|虚拟内存允许操作系统，给每个应用程序提供自己的地址空间，

81
00:03:08,980 --> 00:03:10,150
0,120 120,480 480,870 870,990 990,1170
the operating system to give

82
00:03:10,150 --> 00:03:11,620
0,300 300,900 900,1050 1050,1200 1200,1470
every application it's own address

83
00:03:11,620 --> 00:03:13,480
0,480 540,810 810,990 990,1140 1140,1860
space,| and so it's impossible
|使一个应用程序不可能意外地或恶意地修改另一应用程序的地址空间。

84
00:03:13,480 --> 00:03:15,850
0,480 540,1140 1140,1770 1770,1920 1920,2370
for one application to {},

85
00:03:15,880 --> 00:03:17,740
0,390 390,570 570,1080 1080,1140 1140,1860
or by accidental or maliciously

86
00:03:17,830 --> 00:03:20,140
0,480 480,1230 1230,1530 1530,2070 2070,2310
to modify another application address

87
00:03:20,140 --> 00:03:21,020
0,510
space.|
|

88
00:03:21,080 --> 00:03:22,430
0,360 360,480 480,660 660,930 930,1350
{} It also provides isolation
它还提供了用户和内核地址空间之间的隔离，我们讨论过的，

89
00:03:22,430 --> 00:03:23,630
0,360 360,630 630,720 720,960 960,1200
between user and kernel address

90
00:03:23,630 --> 00:03:24,890
0,270 270,390 390,690 720,1020 1020,1260
space as we talk about

91
00:03:24,890 --> 00:03:26,360
0,270 270,330 330,660 840,1350 1350,1470
quite a bit| and as
|也是你们在页表实验中看到的那样。

92
00:03:26,360 --> 00:03:27,200
0,240 240,450 450,540 540,630 630,840
you've seen in the page

93
00:03:27,200 --> 00:03:28,340
0,270 270,630
table lab.|
|

94
00:03:28,570 --> 00:03:30,220
0,510 540,840 840,990 990,1230 1230,1650
{} But sort of another
虚拟内存的另一个好处，

95
00:03:30,220 --> 00:03:32,710
0,420 420,540 540,870 870,1500 1800,2490
view or another benefit {}

96
00:03:32,890 --> 00:03:35,080
0,570 600,1080 1080,1590 1590,1710 1710,2190
of virtual memory,| {you,know} alluded
|之前我提到过几次，

97
00:03:35,080 --> 00:03:36,850
0,240 240,360 360,600 600,990 990,1770
to a couple times earlier|
|

98
00:03:37,150 --> 00:03:39,070
0,690 690,1200 1200,1560 1560,1890 1890,1920
is that it provides a
它提供了一定程度的间接性。

99
00:03:39,070 --> 00:03:40,520
0,270 270,360 360,870
level of indirection,|
|

100
00:03:47,340 --> 00:03:49,290
0,210 210,420 450,1140 1140,1860 1860,1950
{you,know}, the processor instructions, you
处理器指令，只使用虚拟地址，

101
00:03:49,290 --> 00:03:50,910
0,120 120,360 360,570 570,900 900,1620
know only use virtual addresses,|
|

102
00:03:51,680 --> 00:03:52,700
0,330 330,510 510,600 600,840 840,1020
{} but the {kernel -}
而内核定义了从虚拟地址到物理地址的映射，

103
00:03:52,700 --> 00:03:53,960
0,240 240,480 480,660 660,720 720,1260
gets to sort of define

104
00:03:53,960 --> 00:03:55,730
0,90 90,750 810,1080 1080,1440 1440,1770
the mapping from virtual addresses

105
00:03:55,730 --> 00:03:57,900
0,600 630,1080 1080,1680
to physical addresses,|
|

106
00:03:58,800 --> 00:04:00,960
0,540 540,1080 1080,1620 1620,1890 1890,2160
and that allows all kinds
它允许各种有趣的功能，

107
00:04:00,960 --> 00:04:03,860
0,90 90,750 750,1620 1650,2310
of interesting {- -

108
00:04:03,860 --> 00:04:04,940
0,540
-},

109
00:04:04,940 --> 00:04:06,260
0,330 330,780 780,990 990,1080 1080,1320
interesting features,| like the ones
|就像我们要在这节课中讨论的那样。

110
00:04:06,260 --> 00:04:07,220
0,120 120,240 240,330 330,690 690,960
we're gonna be talking about

111
00:04:07,220 --> 00:04:09,720
0,450 450,600 600,1050 1410,1920
in this lecture {}.|
|

112
00:04:10,910 --> 00:04:12,160
0,660
The.
这个，

113
00:04:12,550 --> 00:04:13,680
0,630
Second.|
稍等。|

114
00:04:16,700 --> 00:04:17,880
0,600

115
00:04:18,200 --> 00:04:20,040
0,510 510,1200
And the.|
还有。|

116
00:04:24,280 --> 00:04:26,020
0,120 120,630 630,1050 1050,1560 1560,1740
The {kernel -} controls this
内核控制着从虚拟地址空间到物理地址空间的映射，

117
00:04:26,020 --> 00:04:28,600
0,450 450,870 1380,1800 1800,2280 2280,2580
particular mapping {} from virtual

118
00:04:28,600 --> 00:04:30,940
0,810 840,1200 1200,1410 1410,1800 1890,2340
to physical address space| and
|到目前为止，xv6 的映射都很无趣，

119
00:04:30,940 --> 00:04:32,380
0,510 510,660 660,900 900,990 990,1440
most so far in xv6,

120
00:04:32,380 --> 00:04:33,250
0,120 120,390 390,540 540,600 600,870
that mapping has to be

121
00:04:33,250 --> 00:04:35,590
0,390 390,840 1710,1890 1890,2280 2280,2340
quite boring,| in fact the
|事实上，内核主要是恒等映射，

122
00:04:35,590 --> 00:04:36,760
0,390 390,510 510,840 840,870 870,1170
kernel is mostly {} direct

123
00:04:36,760 --> 00:04:38,440
0,510 690,960 960,1110 1110,1500 1530,1680
mapping| and a couple of
|xv6 做了几件有趣的事情，

124
00:04:38,440 --> 00:04:39,970
0,420 420,690 690,870 870,990 990,1530
interesting things that we do,

125
00:04:39,970 --> 00:04:42,340
0,570 690,1020 1020,1350 1350,1950 1980,2370
{} {xv6 -} does,| which
|其中一个我们可以看到的是 trampoline 页。

126
00:04:42,340 --> 00:04:43,510
0,120 120,480 480,810 810,960 960,1170
is mapping one as we've

127
00:04:43,510 --> 00:04:45,480
0,420 540,630 630,1140 1140,1650
seen, the trampoline page,|
|

128
00:04:46,330 --> 00:04:48,700
0,660 690,990 990,1350 1350,1920 2010,2370
allowed {} kernel map one
允许内核将一个页面映射到多个地址空间，

129
00:04:48,700 --> 00:04:50,650
0,390 390,750 750,1050 1050,1290 1290,1950
page into many address spaces,|
|

130
00:04:50,770 --> 00:04:52,360
0,630 630,990 990,1260 1260,1380 1380,1590
another interesting case that we've
另一个可以看到的有趣的例子是守护页，

131
00:04:52,360 --> 00:04:55,210
0,570 690,1020 1020,1260 1260,1800 2100,2850
seen is the guard page,|
|

132
00:04:55,750 --> 00:04:57,280
0,150 150,600 600,810 810,1080 1080,1530
to protect {stack - -},
它用来在用户空间和内核空间中保护栈。

133
00:04:57,370 --> 00:04:59,590
0,540 540,600 600,660 660,1050 1050,2220
both in the kernel, in

134
00:04:59,620 --> 00:05:01,090
0,270 270,690 900,990 990,1230 1230,1470
kernel space and user space

135
00:05:01,090 --> 00:05:02,400
0,180 180,450 450,930
and kernel space.|
|

136
00:05:02,940 --> 00:05:04,170
0,300 300,360 360,480 480,840 840,1230
But if you think about
但是你想一下，

137
00:05:04,170 --> 00:05:06,000
0,180 180,360 360,840 870,1170 1170,1830
it,| so far that mapping
|目前为止，这种映射是相对静态的，

138
00:05:06,180 --> 00:05:08,160
0,390 390,600 600,1050 1050,1770 1800,1980
has been relatively static,| you
|我们设置一次，用户或内核页表映射，

139
00:05:08,160 --> 00:05:09,840
0,450 990,1230 1230,1410 1410,1530 1530,1680
know we set it up

140
00:05:09,840 --> 00:05:11,310
0,540 720,870 870,990 990,1230 1230,1470
once, you know maybe per

141
00:05:11,310 --> 00:05:12,930
0,510 510,840 870,1170 1170,1350 1350,1620
user, {} kernel page table

142
00:05:12,930 --> 00:05:13,920
0,360 360,660 660,870 870,930 930,990
mapping,| setup once in the
|在开始时设置一次，还有进程 fork 时设置一次，

143
00:05:13,920 --> 00:05:16,830
0,540 660,1590 1710,2520 2520,2790 2790,2910
beginning and processes once at

144
00:05:16,830 --> 00:05:18,540
0,480 540,1110 1110,1320 1320,1470 1470,1710
fork| and they're sort of
|然后内核不会对这个映射做任何其他的事情。

145
00:05:18,630 --> 00:05:19,530
0,120 120,390 390,570 570,750 750,900
the kernel doesn't really do

146
00:05:19,530 --> 00:05:20,700
0,330 330,600 600,720 720,870 870,1170
anything else with this mapping.|
|

147
00:05:21,680 --> 00:05:23,450
0,420 450,1050 1050,1350 1350,1590 1590,1770
And what page fault gives
而页面错误给我们的是，让这些映射变为动态的。

148
00:05:23,450 --> 00:05:25,310
0,390 570,990 990,1320 1320,1560 1560,1860
us is actually to make

149
00:05:25,310 --> 00:05:28,040
0,150 150,720 720,1740 2130,2370 2370,2730
these maps dynamic.| So using
|所以使用页面错误，我们可以改变，

150
00:05:28,040 --> 00:05:29,360
0,270 270,780
page faults,

151
00:05:34,690 --> 00:05:36,480
0,210 210,360 360,450 450,1260
and we can change,|
|

152
00:05:37,170 --> 00:05:38,100
0,180 180,240 240,510 510,630 630,930
{} the kernel can change
内核可以动态地改变映射。

153
00:05:38,100 --> 00:05:39,220
0,90 90,540
the mapping,

154
00:05:45,490 --> 00:05:47,050
0,210 210,870 870,1080 1080,1170 1170,1560
{sort,of} dynamically on the fly.|
|

155
00:05:47,080 --> 00:05:47,800
0,150 150,330 330,540 540,660 660,720
And this turns out to
这是一种非常强大的机制，

156
00:05:47,800 --> 00:05:52,990
0,570 600,1770 1770,2490 2730,4620 4650,5190
be extremely {} powerful mechanism,|
|

157
00:05:52,990 --> 00:05:54,800
0,120 120,270 270,510 510,1260
so you can combine
将页表和页面错误结合起来，

158
00:05:54,800 --> 00:05:56,380
0,300 300,1050
page tables

159
00:05:56,380 --> 00:05:58,570
0,210 210,540 540,1170 1440,1680 1680,2190
and page faults,| {} you,
|内核有了极大的灵活性。

160
00:05:58,570 --> 00:06:01,030
0,630 750,1080 1080,1830 1830,2310 2310,2460
{} have enormous, kernel has

161
00:06:01,030 --> 00:06:02,500
0,60 60,510 510,720 720,780 780,1470
an enormous amount of flexibility.|
|

162
00:06:03,000 --> 00:06:04,260
0,120 120,390 390,480 480,1080 1080,1260
{} And the flexibility [comes
灵活性是因为你可以在运行时修改指向。

163
00:06:04,260 --> 00:06:05,610
0,300 300,510 510,630 630,750 750,1350
down], because you can change

164
00:06:05,610 --> 00:06:07,290
0,180 180,480 480,600 600,1080 1080,1680
the level of [direction] on

165
00:06:07,290 --> 00:06:08,360
0,120 120,450
the fly.|

166
00:06:08,800 --> 00:06:09,960
0,600

167
00:06:09,960 --> 00:06:11,280
0,300 300,780 810,1140 1140,1200 1200,1320
And, so what we're going
所以我们要做的是，

168
00:06:11,280 --> 00:06:12,210
0,60 60,120 120,510 510,600 600,930
to be doing is basically|
|

169
00:06:12,210 --> 00:06:13,410
0,300 300,420 420,540 540,750 750,1200
looking at all kinds of
研究这种动态映射或动态修改页表的各种用法，

170
00:06:13,560 --> 00:06:16,560
0,1050 1170,1740 1800,2190 2190,2370 2370,3000
usages of {} this dynamic

171
00:06:16,590 --> 00:06:18,810
0,180 180,750 750,1050 1050,1500 1500,2220
{re-mapping -} or dynamic changing

172
00:06:18,840 --> 00:06:20,460
0,300 300,360 360,660 660,1230 1380,1620
of the page tables {},|
|

173
00:06:20,460 --> 00:06:21,990
0,150 150,540 540,600 600,1050 1050,1530
that gives you {} interesting
这给你带来有趣的功能。

174
00:06:21,990 --> 00:06:23,000
0,540
features.|
|

175
00:06:24,770 --> 00:06:26,000
0,510 540,840 840,900 900,1110 1110,1230
{} So the first thing,
所以我们要考虑的第一件事，

176
00:06:26,000 --> 00:06:26,630
0,120 120,270 270,390 390,480 480,630
we may want to think

177
00:06:26,630 --> 00:06:27,800
0,420 480,780 780,900 900,990 990,1170
about,| {} is a little
|是需要什么信息，

178
00:06:27,800 --> 00:06:30,200
0,300 300,930 930,1410 1410,1860 1860,2400
bit, {} is what information

179
00:06:30,200 --> 00:06:31,400
0,120 120,660 690,870 870,960 960,1200
is needed,| you know if
|如果发生页面错误，

180
00:06:31,400 --> 00:06:33,440
0,240 240,330 330,690 930,1410 1410,2040
here in a {page,fault} happens,|
|

181
00:06:34,740 --> 00:06:37,060
0,600 900,1770
{} and,
内核需要响应这个页面错误，

182
00:06:37,420 --> 00:06:39,820
0,600 1080,1620 1620,1920 1920,2010 2010,2400
{} kernel wants to respond

183
00:06:39,820 --> 00:06:40,720
0,90 90,270 270,510 510,810 810,900
to this page fault,| you
|那么它需要什么信息才能做出回应。

184
00:06:40,720 --> 00:06:42,190
0,90 90,390 390,1200 1200,1380 1380,1470
know what information does it

185
00:06:42,190 --> 00:06:43,930
0,240 240,510 510,1080 1200,1470 1470,1740
need to actually be able

186
00:06:43,930 --> 00:06:45,060
0,90 90,600
to respond.|
|

187
00:06:45,270 --> 00:06:46,050
0,330 330,450 450,570 570,720 720,780
{} You know sort of
很明显，我们需要错误的虚拟地址，

188
00:06:46,050 --> 00:06:48,450
0,420 600,1110 1110,1440 1470,2130 2130,2400
quite {} {you,know} obviously, we'd

189
00:06:48,450 --> 00:06:50,220
0,210 210,300 300,900 1140,1380 1380,1770
like to have the virtual

190
00:06:50,220 --> 00:06:51,260
0,600
address

191
00:06:52,700 --> 00:06:56,510
0,480 990,1740 2040,2730 2730,3030 3030,3810
of, {} virtual address {of,faulting},|
|

192
00:07:00,040 --> 00:07:01,180
0,390 390,540 540,870 870,900 900,1140
where gonna cause {} page
（这个地址）会引起页面错误。

193
00:07:01,180 --> 00:07:02,160
0,420
fault.|
|

194
00:07:05,270 --> 00:07:06,680
0,360 600,930 930,1110 1110,1170 1170,1410
Say you want to see
比如，你想看到这个，错误虚拟地址。

195
00:07:06,680 --> 00:07:07,600
0,300
this,

196
00:07:09,080 --> 00:07:12,320
0,270 270,900 1350,1830 1830,2310
the faulting virtual address.|
|

197
00:07:15,440 --> 00:07:17,000
0,360 360,750 750,990 990,1380 1380,1560
And you've seen presumably some
你可能已经在页表实验中，看到了一些这样的错误，

198
00:07:17,000 --> 00:07:18,890
0,60 60,240 240,1110 1110,1500 1500,1890
of these panic calls in

199
00:07:18,920 --> 00:07:20,600
0,120 120,360 360,510 510,990 1290,1680
your page fault lab {},|
|

200
00:07:20,600 --> 00:07:21,560
0,510 510,570 570,660 660,750 750,960
and you know the kernel
内核实际上有额外的状态，

201
00:07:21,560 --> 00:07:23,450
0,240 240,510 510,840 840,1350 1590,1890
actually has extra [status] {},|
|

202
00:07:23,450 --> 00:07:24,230
0,90 90,300 300,420 420,660 660,780
in fact that prints them
当我们发生页面错误时，把它们打印出来，

203
00:07:24,230 --> 00:07:25,340
0,240 240,450 450,570 570,840 840,1110
out when we actually page

204
00:07:25,340 --> 00:07:27,590
0,150 150,690 810,1470 1500,1920 1920,2250
fault happens| and {} it
|它在 stval 寄存器里。

205
00:07:27,590 --> 00:07:28,730
0,330 330,420 420,540 540,930 930,1140
happens to be sitting in

206
00:07:28,730 --> 00:07:30,500
0,480 510,1350
the {stval

207
00:07:30,590 --> 00:07:32,380
0,660 660,1200
-} register.|
|

208
00:07:35,530 --> 00:07:38,350
0,240 240,900 930,1620 1620,1920 1920,2820
So when {} user application,
所以，当用户应用程序导致页面错误时，

209
00:07:38,560 --> 00:07:40,600
0,780 810,1230 1230,1290 1290,1530 1530,2040
{} causes a page fault,|
|

210
00:07:40,840 --> 00:07:42,460
0,420 450,870 870,1200 1200,1560 1560,1620
the {page,fault} basically invokes the
页面错误调用相同的陷阱机制，

211
00:07:42,460 --> 00:07:45,220
0,720 750,1410 1410,2130 2250,2490 2490,2760
same trap machinery,| {} that
|像 Robert 在上一节课中谈到的，

212
00:07:45,220 --> 00:07:46,300
0,300 300,660 660,750 750,810 810,1080
Robert discussed in the last

213
00:07:46,300 --> 00:07:48,040
0,510 780,1050 1050,1170 1170,1410 1410,1740
lecture,| {} it's almost completely
|它们几乎完全相同，

214
00:07:48,040 --> 00:07:50,680
0,690 870,1620 1650,2340 2340,2400 2400,2640
identical,| {} {but,in,the,case,of} {} page
|但是在页面错误的情况下，它还会把错误地址放入 stval 寄存器中。

215
00:07:50,680 --> 00:07:51,820
0,300 300,390 390,690 690,810 810,1140
fault, it also will put

216
00:07:51,850 --> 00:07:54,250
0,180 180,660 660,1230 1380,2100 2130,2400
the faulting address into that

217
00:07:54,250 --> 00:07:56,380
0,390 390,900 1110,1770
{stval -} register.|
|

218
00:07:57,370 --> 00:07:58,630
0,150 150,390 390,630 630,990 990,1260
So that is, {} one
这就是，我们可能要知道的一件事，

219
00:07:58,630 --> 00:07:59,410
0,150 150,240 240,360 360,630 630,780
thing that we probably want

220
00:07:59,410 --> 00:08:00,820
0,210 330,750 750,840 840,1290 1290,1410
to know,| the second thing
|我们可能想知道的第二件事，是错误类型。

221
00:08:00,820 --> 00:08:01,480
0,90 90,210 210,450 450,600 600,660
that we probably want to

222
00:08:01,480 --> 00:08:02,560
0,360 390,570 570,690 690,990 990,1080
know is the type of

223
00:08:02,560 --> 00:08:03,620
0,600
fault.|
|

224
00:08:11,580 --> 00:08:12,900
0,540 540,780 780,960 960,1140 1140,1320
{} Because it may be,
因为可能，

225
00:08:12,900 --> 00:08:13,920
0,120 120,390 390,540 540,1020 1020,1020
in terms of {} {},|
|

226
00:08:13,920 --> 00:08:15,090
0,450 450,600 600,750 750,810 810,1170
we may want to do
我们可能希望做出不同的回应，

227
00:08:15,090 --> 00:08:17,130
0,360 360,1080 1080,1530 1530,1770 1770,2040
respond different differently| in terms
|对于加载指令引起的页面错误，

228
00:08:17,130 --> 00:08:19,800
0,240 570,870 870,1380 1590,2460 2460,2670
of to {} page fault

229
00:08:19,800 --> 00:08:21,120
0,150 150,270 270,360 360,600 600,1320
due to a load instruction|
|

230
00:08:21,270 --> 00:08:22,470
0,210 210,420 420,600 600,810 810,1200
or page fault due to
或由于保存指令的页面错误，

231
00:08:22,770 --> 00:08:24,450
0,150 150,510 510,1050 1080,1410 1410,1680
a store instruction,| or page
|或由于跳转指令引起的页面错误。

232
00:08:24,450 --> 00:08:25,800
0,240 240,510 510,930 930,1110 1110,1350
fault due to a jump

233
00:08:25,800 --> 00:08:26,880
0,570
instruction.|
|

234
00:08:26,880 --> 00:08:28,980
0,540 840,1530 1560,1770 1770,1980 1980,2100
{} And, {} so in
如果你查看 RISC-V 文档。

235
00:08:28,980 --> 00:08:30,030
0,330 330,630 630,720 720,900 900,1050
fact if you look at

236
00:08:30,030 --> 00:08:32,970
0,270 270,510 510,960 990,2130 2400,2940
the {RISC-V -} documentation {}.|
|

237
00:08:33,930 --> 00:08:35,610
0,510 540,900 900,1080 1080,1260 1260,1680
{} Here's the {RISC-V -}
这里是 RISC-V 文档，

238
00:08:35,610 --> 00:08:38,130
0,960 960,1110 1110,1650 1710,2190 2190,2520
documentation in here,| {} in
|在 scause 中，我们在 trap 课程中提到的，

239
00:08:38,130 --> 00:08:39,420
0,240 240,450 450,780 780,870 870,1290
the {scause -}, we {}

240
00:08:39,420 --> 00:08:40,800
0,150 150,660 690,930 930,1290 1290,1380
that we was mentioning the

241
00:08:40,800 --> 00:08:43,200
0,300 300,750 900,1380 1380,1770 1770,2400
trap lecture,| {} there are,
|有一些与页面错误有关的原因，

242
00:08:43,350 --> 00:08:45,960
0,360 360,480 480,1080 1110,1740 1770,2610
{} a member of {}

243
00:08:46,780 --> 00:08:49,030
0,750 780,1380 1380,1620 1620,1890 1890,2250
{} causes that actually related

244
00:08:49,030 --> 00:08:50,530
0,90 90,330 330,750 960,1260 1260,1500
to page faults,| so yeah
|是的，看一下编号 13 ，是一个加载页面错误，

245
00:08:50,530 --> 00:08:51,430
0,120 120,210 210,300 300,510 510,900
but if you look at

246
00:08:51,700 --> 00:08:54,610
0,780 930,2130 2160,2790 2790,2880 2880,2910
{} number thirteen, it's a

247
00:08:54,610 --> 00:08:56,980
0,270 270,480 480,960 1140,1560 1560,2370
load page fault,| number fifteen
|编号 15 是一个存储页面错误，

248
00:08:57,010 --> 00:08:58,360
0,210 210,300 300,600 600,870 870,1350
is a store page fault,|
|

249
00:08:58,510 --> 00:08:59,740
0,330 330,510 510,960 960,1080 1080,1230
and number twelve is an
而编号 12 是指令页面错误。

250
00:08:59,740 --> 00:09:01,320
0,510 510,750 750,1140
instruction page fault.|

251
00:09:01,410 --> 00:09:03,210
0,240 240,420 420,990 1020,1590 1620,1800
So these are, {} in
所以，这些在 scause 寄存器中，然后我们就能得到这些信息。

252
00:09:03,210 --> 00:09:04,890
0,120 120,360 360,720 720,1290 1380,1680
the {scause -} register, then

253
00:09:04,890 --> 00:09:06,840
0,90 90,270 270,510 510,1140
we get that information.|
|

254
00:09:08,880 --> 00:09:10,410
0,120 120,240 240,570 570,1110 1140,1530
And so there's three different
所以，有三种不同的类型，读，写和指令。

255
00:09:10,410 --> 00:09:11,640
0,480 480,570 570,690 690,780 780,1230
types, you know {} read

256
00:09:12,060 --> 00:09:13,240
0,570
write

257
00:09:13,240 --> 00:09:15,580
0,570 570,1050 1050,1710
and {} instruction.|
|

258
00:09:16,820 --> 00:09:18,080
0,240 240,510 510,720 720,1140 1170,1260
And just go back,| you
往回走一点，|有一个 scause 实际上是由 ecall 指令引起的，

259
00:09:18,080 --> 00:09:20,780
0,150 150,600 990,1770 1860,2400 2430,2700
know the one {} {scause

260
00:09:20,780 --> 00:09:22,910
0,510 510,780 780,1200 1200,1650 1650,2130
-}, {you,know} actually was caused

261
00:09:22,910 --> 00:09:25,040
0,540 840,1080 1080,1200 1200,1560 1560,2130
by {} the [ecall] instruction,|
|

262
00:09:25,040 --> 00:09:26,780
0,300 300,660 660,750 750,1020 1020,1740
to actually the kernel transfer
内核传输是编号 8 。

263
00:09:26,810 --> 00:09:28,160
0,150 150,450 450,840
is number eight.|
|

264
00:09:28,310 --> 00:09:29,270
0,240 240,420 420,690 690,750 750,960
Alright, so that's the one
好的，这就是我们在 trap 讲座中看到的，

265
00:09:29,270 --> 00:09:30,440
0,120 120,240 240,480 480,870 900,1170
that we saw in the

266
00:09:30,560 --> 00:09:31,700
0,420 420,810 810,900 900,960 960,1140
trap lecture,| that we spend
|我们在 trap 演讲中花了很多时间思考。

267
00:09:31,700 --> 00:09:32,390
0,30 30,210 210,270 270,450 450,690
a lot of time thinking

268
00:09:32,390 --> 00:09:33,560
0,300 300,450 450,600 600,810 810,1170
about in that trap lecture.|
|

269
00:09:33,620 --> 00:09:35,120
0,270 270,840 870,1140 1140,1230 1230,1500
But basically all the other
但基本上所有其他页面错误或异常，

270
00:09:35,120 --> 00:09:37,670
0,270 270,600 600,690 690,1380 2340,2550
page faults or exceptions| use
|使用相同的机制从用户空间到内核空间，

271
00:09:37,670 --> 00:09:40,340
0,120 120,720 750,1530 1530,1890 1980,2670
the same mechanism to transfer

272
00:09:40,340 --> 00:09:42,200
0,180 180,390 390,720 720,1020 1020,1860
from user space {} to

273
00:09:42,260 --> 00:09:45,350
0,360 360,870 1200,1710 1920,2460 2550,3090
kernel space| and {} once
|一旦进入内核空间，出现页面错误，

274
00:09:45,380 --> 00:09:46,340
0,270 270,480 480,840 840,900 900,960
in kernel space, in the

275
00:09:46,340 --> 00:09:47,270
0,180 180,270 270,360 360,600 600,930
case of the page fault,|
|

276
00:09:47,270 --> 00:09:49,580
0,240 240,570 570,1080 1170,1950 1950,2310
the {stval -} register set,
就设置 stval 寄存器，设置 scause 寄存器。

277
00:09:49,640 --> 00:09:51,220
0,270 270,570 570,990 990,1260
{scause -} register set.|
|

278
00:09:52,060 --> 00:09:53,320
0,300 300,390 390,630 630,960 1050,1260
Then the third thing, {}
然后，我们可能想知道的第三件事是，

279
00:09:53,320 --> 00:09:54,220
0,180 180,300 300,690 690,840 840,900
that we probably want to

280
00:09:54,220 --> 00:09:57,100
0,570 810,1590 1650,1920 1920,2070 2070,2880
know is| {} the instruction
|引起页面错误的指令的虚拟地址。

281
00:09:58,960 --> 00:10:00,310
0,150 150,420 420,900 900,990 990,1350
or {} address the virtual

282
00:10:00,310 --> 00:10:01,420
0,600
address

283
00:10:01,680 --> 00:10:03,260
0,240 240,1050
of instruction,

284
00:10:05,500 --> 00:10:07,150
0,300 300,900 900,960 960,1230 1230,1650
that cause the page fault.|
|

285
00:10:14,890 --> 00:10:16,210
0,540 570,780 780,930 930,990 990,1320
And, {} you know, anybody
还有，有没有人还记得，

286
00:10:16,210 --> 00:10:17,980
0,360 360,1170 1230,1380 1380,1530 1530,1770
remember| where you know from
|从 trap 课程中，指令在哪里，地址在哪里？

287
00:10:17,980 --> 00:10:19,150
0,90 90,390 390,690 690,1050 1050,1170
the trap lecture, where the

288
00:10:19,150 --> 00:10:20,740
0,390 390,630 720,1260 1260,1350 1350,1590
where the instruction is, where

289
00:10:20,740 --> 00:10:22,080
0,180 180,870
the addresses?|
|

290
00:10:25,220 --> 00:10:26,440
0,660
Anybody?|
有人知道吗？|

291
00:10:26,560 --> 00:10:28,030
0,180 180,360 390,810 810,1110 1110,1470
Is it {} {sepc -}?
是 sepc 吗？

292
00:10:28,600 --> 00:10:30,670
0,360 360,810 1080,1410 1410,1920 1920,2070
Yeah exactly.| And there's this
是的，正确。|这里有个 sepc 寄存器，管理者模式异常程序计数器，

293
00:10:30,670 --> 00:10:32,710
0,420 420,480 480,1470 1470,1740 1740,2040
register, {} sepc correct, the

294
00:10:32,920 --> 00:10:35,620
0,690 690,1230 1230,1770 1770,2130 2130,2700
supervisor exception exception program counter,|
|

295
00:10:35,740 --> 00:10:36,820
0,390 390,720 720,810 810,1020 1020,1080
{} there is where it
作为陷阱处理代码的一部分，它保存在哪里？

296
00:10:36,820 --> 00:10:37,690
0,300 300,480 480,660 660,720 720,870
is and where is that

297
00:10:37,690 --> 00:10:38,720
0,570
saved

298
00:10:40,530 --> 00:10:41,520
0,360 360,570 570,630 630,720 720,990
as part of the trap

299
00:10:41,520 --> 00:10:43,040
0,450 450,1020
handling code?|
|

300
00:10:45,000 --> 00:10:46,500
0,150 150,210 210,540 540,930 1140,1500
In the {trapframe -}?| Yeah,
在 trapframe ？|是的，在 trapframe 中，

301
00:10:46,500 --> 00:10:47,430
0,210 210,390 390,450 450,690 690,930
there's in the {trapframe -}

302
00:10:47,460 --> 00:10:49,200
0,210 210,720 720,840 840,1200 1200,1740
correct,| there's {} {trapframe -}
|这里有一个 trapframe epc ，包含异常程序计数器。

303
00:10:49,230 --> 00:10:52,260
0,900 1260,1590 1590,1950 1950,2460 2490,3030
epc, actually has the exception

304
00:10:52,260 --> 00:10:53,480
0,300 300,720
program counter.|
|

305
00:10:54,150 --> 00:10:55,260
0,240 240,600 630,870 870,1050 1050,1110
So we think about the
所以，我们考虑一下 xv6 所做的硬件机制，

306
00:10:55,260 --> 00:10:56,490
0,240 240,720 720,810 810,930 930,1230
hardware mechanism actually what {xv6

307
00:10:56,490 --> 00:10:58,020
0,240 240,690 780,1290 1290,1440 1440,1530
-} does,| {} we have
|当出现页面错误时，有三条可能对我们非常有价值的信息，

308
00:10:58,020 --> 00:10:59,190
0,240 240,510 510,600 600,1080 1080,1170
three pieces of information are

309
00:10:59,190 --> 00:11:00,540
0,270 270,690 690,1050 1050,1200 1200,1350
probably extremely valuable to us,

310
00:11:00,540 --> 00:11:01,860
0,270 270,480 480,660 660,960 960,1320
when we get actually {page,fault},|
|

311
00:11:01,890 --> 00:11:04,170
0,600 660,990 990,1860 1860,1980 1980,2280
namely the address of cause
即引起错误的地址，错误类型，

312
00:11:04,170 --> 00:11:06,480
0,570 780,1200 1290,1590 1590,1680 1680,2310
fault, the type of fault|
|

313
00:11:06,750 --> 00:11:08,730
0,630 630,840 840,1260 1260,1590 1590,1980
and the exception program counter
还有异常程序计数器，比如它发生在用户空间的什么地方。

314
00:11:08,730 --> 00:11:09,900
0,150 150,630 630,870 870,960 960,1170
like where did it happen

315
00:11:09,900 --> 00:11:11,080
0,60 60,300 300,810
to user space.|
|

316
00:11:11,200 --> 00:11:12,130
0,240 240,390 390,690 690,750 750,930
And the reason we care
我们关心异常程序计数器的原因是，

317
00:11:12,130 --> 00:11:12,940
0,60 60,210 210,390 390,450 450,810
a lot about the exception

318
00:11:12,940 --> 00:11:14,800
0,300 300,810 810,990 990,1410 1650,1860
program counter is| because {}
|因为当我们想在处理程序中修复页表时，

319
00:11:14,800 --> 00:11:15,880
0,450 450,600 600,870 870,1020 1020,1080
when we probably want to

320
00:11:15,880 --> 00:11:17,680
0,780 810,1230 1230,1290 1290,1650 1650,1800
repair, in the handler going

321
00:11:17,680 --> 00:11:19,240
0,60 60,570 570,810 840,1050 1050,1560
to repair the {pagetable -}|
|

322
00:11:19,660 --> 00:11:20,650
0,270 270,510 510,630 630,750 750,990
and then we're gonna basically
然后我们会重新运行相同的指令，

323
00:11:20,650 --> 00:11:23,230
0,510 510,600 600,870 870,1440 1770,2580
restart the same instruction| and
|希望在修复页面错误或修复页表之后，

324
00:11:23,230 --> 00:11:24,910
0,420 420,750 810,1140 1140,1590 1590,1680
hopefully the after repairing the

325
00:11:24,910 --> 00:11:26,260
0,240 240,570 570,870 930,1290 1290,1350
page fault or reparing the

326
00:11:26,260 --> 00:11:27,730
0,210 210,690 720,930 930,1350 1350,1470
{pagetables -}| that instruction can
|那条指令可以继续运行。

327
00:11:27,730 --> 00:11:29,170
0,180 180,510 570,930 930,1080 1080,1440
just run without any trouble.|
|

328
00:11:29,560 --> 00:11:30,310
0,150 150,210 210,300 300,660 660,750
And so it's important that
所以，可以重新执行引起错误的指令是很重要的。

329
00:11:30,310 --> 00:11:31,390
0,60 60,180 180,300 300,480 480,1080
we can be {} resume

330
00:11:31,390 --> 00:11:33,550
0,210 210,840 840,1020 1020,1500 1800,2160
the instruction that actually {}

331
00:11:33,550 --> 00:11:35,200
0,240 240,630 630,840 840,1140 1140,1650
that we {} cause fault.|
|

332
00:11:38,370 --> 00:11:39,270
0,150 150,300 300,360 360,540 540,900
Is that all makes sense?|
这些能理解吗？|

333
00:11:42,960 --> 00:11:45,000
0,510 630,1230 1380,1710 1710,1800 1800,2040
Okay, so now I'm gonna
好的，现在我要看一下，

334
00:11:45,000 --> 00:11:46,650
0,420 420,1020 1140,1260 1260,1440 1440,1650
look at,| you know the
|实际上 RISC-V 给我们提供的基础机制和基本信息，

335
00:11:46,650 --> 00:11:49,290
0,330 330,930 930,1560 1980,2520 2520,2640
basic mechanism and {basic,information} that

336
00:11:49,290 --> 00:11:50,130
0,60 60,240 240,510 510,570 570,840
the {RISC-V -} is actually

337
00:11:50,130 --> 00:11:51,840
0,240 240,570 870,1230 1230,1620 1620,1710
giving us| {} and I
|我想看一份功能清单，

338
00:11:51,840 --> 00:11:52,800
0,180 180,240 240,450 450,540 540,960
want to look at {},

339
00:11:54,020 --> 00:11:55,730
0,540 540,810 810,1020 1020,1110 1110,1710
basically go through a list

340
00:11:55,760 --> 00:11:58,100
0,690 990,1800
of {},

341
00:11:58,300 --> 00:11:59,650
0,120 120,210 210,810 870,1110 1110,1350
you know features| {} that
|可以帮助我们理解，

342
00:11:59,650 --> 00:12:00,670
0,120 120,390 390,720 720,870 870,1020
will help us, you know

343
00:12:00,670 --> 00:12:01,900
0,90 90,540 540,810 810,1110 1110,1230
we understand actually| how we
|我们如何使用页面错误程序修复页表，并做一些有趣的事情。

344
00:12:01,900 --> 00:12:03,880
0,360 360,870 1020,1380 1380,1590 1590,1980
can {} use the {page,fault}

345
00:12:03,880 --> 00:12:06,910
0,420 420,1080 1080,1380 1410,2190 2250,3030
handler to {} repair the

346
00:12:07,440 --> 00:12:09,150
0,300 300,690 690,1260 1290,1410 1410,1710
{pagetable -} and do interesting

347
00:12:09,150 --> 00:12:10,740
0,450 780,990 990,1050 1050,1290 1290,1590
things.| So the first thing
|所以我想看的第一件事是分配，特别是， sbrk 。

348
00:12:10,740 --> 00:12:11,760
0,330 330,480 480,540 540,720 720,1020
I want to look at

349
00:12:11,970 --> 00:12:16,100
0,780 780,1470 1710,2370 2490,3240
is {} allocation, {}

350
00:12:17,300 --> 00:12:19,100
0,210 210,1020 1380,1500 1500,1590 1590,1800
in particular, you know {sbrk

351
00:12:19,100 --> 00:12:20,200
0,510
-}.|
|

352
00:12:25,210 --> 00:12:26,380
0,330 330,480 480,780 780,870 870,1170
So sbrk is the system
所以， sbrk 是 xv6 提供的系统调用，

353
00:12:26,380 --> 00:12:28,360
0,600 660,1200 1200,1530 1530,1800 1800,1980
call, {} that {xv6 -}

354
00:12:28,360 --> 00:12:31,150
0,660 780,1650 1680,2070 2070,2640 2640,2790
provides,| that {} allows an
|它允许应用程序增加自己的堆空间，

355
00:12:31,150 --> 00:12:33,310
0,690 690,840 840,1290 1290,1680 1680,2160
application to basically grow grow

356
00:12:33,310 --> 00:12:35,320
0,120 120,570 840,1110 1110,1200 1200,2010
its heap| when the application
|当应用程序启动时， sbrk 指向这里，

357
00:12:35,620 --> 00:12:38,830
0,600 600,1230 1590,2160 2160,2640 2640,3210
{} starts {} {sbrk -}

358
00:12:39,070 --> 00:12:40,620
0,570 570,1080
points here,|
|

359
00:12:41,470 --> 00:12:42,400
0,120 120,330 360,720 720,870 870,930
at the bottom of the
位于堆的底部，栈的顶端，

360
00:12:42,400 --> 00:12:43,450
0,390 390,510 510,630 630,930 930,1050
heap, you know top of

361
00:12:43,450 --> 00:12:45,190
0,60 60,570 960,1170 1170,1440 1440,1740
the stack,| in fact it's
|实际上，这也是 p->sz 指向的地方。

362
00:12:45,190 --> 00:12:46,540
0,90 90,390 390,720 720,1260 1260,1350
the same place where you

363
00:12:46,540 --> 00:12:48,640
0,210 510,930 930,1380 1380,1980 1980,2100
know {p->sz } basically you

364
00:12:48,640 --> 00:12:49,840
0,120 120,450 450,690
know points to.|
|

365
00:12:50,200 --> 00:12:51,040
0,150 150,270 270,420 420,570 570,840
And so when {sbrk -}
所以，当调用 sbrk 时，

366
00:12:51,040 --> 00:12:52,930
0,510 660,1170 1170,1470 1470,1590 1590,1890
called,| for example, {sbrk -}
|比如 sbrk 1 2 3 4 5 ，

367
00:12:52,930 --> 00:12:53,920
0,330 330,510 510,660 660,840 840,990
called, it's like one two

368
00:12:53,920 --> 00:12:54,760
0,180 180,390 390,690 690,750 750,840
three four five,| you know
|数字是你想要分配的页数，

369
00:12:54,760 --> 00:12:55,810
0,90 90,300 300,360 360,720 720,1050
the number of pages that

370
00:12:55,810 --> 00:12:56,380
0,150 150,240 240,360 360,510 510,570
you know you want to

371
00:12:56,380 --> 00:12:59,890
0,570 870,1620 1830,2760 2760,3030 3030,3510
allocate,| the sbrk system call
|sbrk 系统调用提高这个界限，到这里某个地方。

372
00:12:59,980 --> 00:13:01,640
0,510 510,840 840,1260
basically bumps up

373
00:13:01,840 --> 00:13:03,560
0,120 120,240 240,450 450,1140
you know this boundary,

374
00:13:06,770 --> 00:13:08,260
0,270 270,540 540,990
to something there.|
|

375
00:13:08,350 --> 00:13:10,420
0,660 660,1020 1020,1590 1590,1740 1740,2070
And that {} and so
这就是说，当调用 sbrk 系统调用时，

376
00:13:10,450 --> 00:13:12,130
0,210 210,390 390,690 690,1170 1320,1680
what, that means that when

377
00:13:12,130 --> 00:13:13,870
0,240 270,480 480,750 750,1410 1470,1740
the sbrk actually happens or

378
00:13:13,870 --> 00:13:15,430
0,390 510,810 810,990 990,1080 1080,1560
sbrk system call is called,|
|

379
00:13:15,460 --> 00:13:17,440
0,180 180,570 570,1080 1080,1410 1410,1980
the kernel allocation physical memory,
内核分配物理内存，映射到用户用用程序的地址空间，

380
00:13:17,680 --> 00:13:20,050
0,690 690,810 810,1590 1920,2070 2070,2370
map it into the address

381
00:13:20,050 --> 00:13:22,750
0,450 450,840 840,1530 1560,1860 1860,2700
space of the user application,|
|

382
00:13:23,050 --> 00:13:24,610
0,300 300,660 660,720 720,1320 1380,1560
{} zero the memory and
将内存置零，然后从系统调用返回。

383
00:13:24,610 --> 00:13:25,510
0,90 90,360 360,720 720,840 840,900
then basically return from the

384
00:13:25,510 --> 00:13:26,480
0,330 330,630
system call.|
|

385
00:13:27,210 --> 00:13:29,580
0,510 870,1380 1380,1710 1710,2280 2280,2370
{} And after time and
之后，应用程序可以增长它需要的物理内存，

386
00:13:29,580 --> 00:13:32,040
0,1260 1260,1680 1680,1830 1830,2370 2370,2460
the application can grow, you

387
00:13:32,040 --> 00:13:33,840
0,120 120,450 510,960 960,1410 1410,1800
know that physical memory or

388
00:13:34,080 --> 00:13:35,610
0,450 450,600 600,720 720,1200 1200,1530
memory that it needs| or
|或者它可能多次调用 sbrk 。

389
00:13:35,610 --> 00:13:37,410
0,60 60,300 300,660 840,1530 1530,1800
it might want {} by

390
00:13:37,410 --> 00:13:38,940
0,150 150,420 420,750 750,1020 1020,1530
just calling multiple times to

391
00:13:38,940 --> 00:13:39,860
0,180 180,510
{sbrk -}.|
|

392
00:13:39,950 --> 00:13:41,780
0,240 240,360 360,870 870,1110 1110,1830
{} The application also decrease
应用程序还可以使用一个负数调用 sbrk ，来缩小它的地址空间。

393
00:13:41,780 --> 00:13:43,670
0,330 360,960 990,1290 1290,1590 1590,1890
or shrink its address space

394
00:13:43,670 --> 00:13:44,840
0,240 240,570 570,990 990,1110 1110,1170
by calling sbrk with a

395
00:13:44,840 --> 00:13:45,980
0,360 360,660
negative number.|
|

396
00:13:46,830 --> 00:13:47,550
0,210 210,240 240,360 360,420 420,720
But I want to focus
但是，我想把重点放在增加地址空间的情况下。

397
00:13:47,550 --> 00:13:48,330
0,90 90,150 150,390 390,630 630,780
on the case where we're

398
00:13:48,330 --> 00:13:50,490
0,570 660,1170 1170,1500 1500,1740 1740,2160
growing {} the address space.|
|

399
00:13:50,730 --> 00:13:52,410
0,660 780,1020 1020,1290 1290,1560 1560,1680
And in {xv6 -} as
在 xv6 中， sbrk 是急切的，

400
00:13:52,410 --> 00:13:55,650
0,120 120,600 900,1710 1710,2280 3060,3240
it is, {} the {sbrk

401
00:13:55,650 --> 00:13:58,350
0,360 360,900 900,1410 2250,2460 2460,2700
-} is eager| or does
|或者我们称之为[急分配]，

402
00:13:58,350 --> 00:13:59,610
0,330 330,570 570,720 720,1050 1050,1260
what we're gonna call eager

403
00:13:59,610 --> 00:14:00,720
0,600
allocation,|
|

404
00:14:03,650 --> 00:14:06,140
0,780 780,1170 1170,1620 1620,1920 1920,2490
namely as soon as the
也就是说，只要一调用 sbrk ，

405
00:14:07,490 --> 00:14:09,860
0,660 660,1080 1080,1440 1470,2070 2130,2370
{sbrk -} {} called,| the
|内核会立即分配应用程序需要的物理内存。

406
00:14:09,860 --> 00:14:11,960
0,420 420,690 690,1260 1260,1890 1890,2100
kernel will immediately allocate the

407
00:14:11,960 --> 00:14:13,910
0,270 270,840 930,1350 1350,1440 1440,1950
physical memory that the application

408
00:14:13,910 --> 00:14:15,120
0,120 120,450 450,780
is asking for.|
|

409
00:14:15,570 --> 00:14:16,440
0,210 210,330 330,600 600,750 750,870
And it turns out that
在实践中，

410
00:14:16,440 --> 00:14:18,210
0,120 120,750 930,1140 1140,1350 1350,1770
in practice,| it's actually hard
|应用程序很难预测，它需要多少内存，

411
00:14:18,210 --> 00:14:20,180
0,120 120,720 720,810 810,1440
for applications to predict,

412
00:14:20,180 --> 00:14:21,290
0,300 300,480 480,660 660,960 960,1110
{} how much memory they

413
00:14:21,290 --> 00:14:22,280
0,450
need,|
|

414
00:14:22,310 --> 00:14:25,940
0,660 660,1230 1410,1980 2190,2700 2700,3630
{} so, {} typically applications
所以，通常情况下，应用程序会多申请，

415
00:14:28,770 --> 00:14:30,600
0,330 330,390 390,690 690,1260
tend to over ask,|
|

416
00:14:36,600 --> 00:14:37,230
0,120 120,210 210,300 300,570 570,630
and so they ask a
所以，它们申请的比需要的多，

417
00:14:37,230 --> 00:14:38,190
0,210 210,450 450,600 600,720 720,960
lot more than they really

418
00:14:38,190 --> 00:14:41,310
0,480 720,1200 1200,2370 2400,2790 2790,3120
need,| {} and often that
|通常，这意味着地址空间会有比较大的增长，

419
00:14:41,310 --> 00:14:43,200
0,270 270,930 930,1230 1230,1380 1380,1890
means which means that basically

420
00:14:43,200 --> 00:14:44,370
0,90 90,210 210,300 300,690 690,1170
you know the address space

421
00:14:44,370 --> 00:14:45,720
0,390 390,690 690,930 930,990 990,1350
will grow quite a bit,|
|

422
00:14:45,840 --> 00:14:47,190
0,390 390,780 780,900 900,1200 1200,1350
{} even with memory does
即使应用程序从未使用到的内存。

423
00:14:47,190 --> 00:14:48,360
0,210 210,540 540,930 930,1050 1050,1170
actually never used by the

424
00:14:48,360 --> 00:14:49,440
0,570
application.|
|

425
00:14:49,530 --> 00:14:50,640
0,240 240,360 360,540 540,930 930,1110
You might think that was
你可能认为那很愚蠢，怎么会发生这种事，

426
00:14:50,640 --> 00:14:52,380
0,480 570,990 990,1140 1140,1290 1290,1740
stupid, how could that happen,|
|

427
00:14:52,620 --> 00:14:54,000
0,420 450,600 600,810 810,1020 1020,1380
well, you know, think about
嗯，想想如果你写一个程序，

428
00:14:54,000 --> 00:14:55,050
0,150 150,270 270,450 450,540 540,1050
if you write an application

429
00:14:55,050 --> 00:14:57,390
0,660 660,1320 1530,1800 1800,2010 2010,2340
program| and {} the typical
|典型的程序可能会输入，

430
00:14:57,390 --> 00:14:59,370
0,450 450,1110 1110,1650 1650,1860 1860,1980
application program maybe reach an

431
00:14:59,370 --> 00:15:01,260
0,510 510,1020 1020,1260 1260,1470 1470,1890
input| or has a matrix
|或者具有用于某些计算的矩阵，

432
00:15:01,260 --> 00:15:03,780
0,150 150,780 780,1470 1530,1770 1770,2520
that uses for some computation,|
|

433
00:15:04,140 --> 00:15:05,910
0,570 720,1020 1020,1320 1320,1380 1380,1770
{} and often the application
通常，应用程序编写者会为最坏的情况做准备，

434
00:15:05,910 --> 00:15:07,290
0,270 270,480 480,660 690,1260 1260,1380
writer sort of plans for

435
00:15:07,290 --> 00:15:09,510
0,90 90,330 330,810 840,930 930,2220
the worst case,| you know
|为最大的矩阵分配内存，而应用程序可能永远不需要。

436
00:15:09,510 --> 00:15:10,740
0,450 450,750 750,840 840,930 930,1230
allocates memory for the biggest

437
00:15:10,740 --> 00:15:12,900
0,450 450,870 870,1350 1350,1620 1620,2160
matrix, the application might never

438
00:15:12,900 --> 00:15:13,920
0,240 240,660
ever need.|
|

439
00:15:13,980 --> 00:15:15,390
0,270 270,360 360,450 450,780 780,1410
But in the common case,|
但是一般情况下，|

440
00:15:15,510 --> 00:15:17,130
0,450 450,750 750,1290 1290,1350 1350,1620
application maybe computes are much
应用程序的计算，可能是小得多的输入或小得多的矩阵，

441
00:15:17,130 --> 00:15:18,870
0,600 630,1320 1320,1470 1470,1500 1500,1740
smaller input or a much

442
00:15:18,870 --> 00:15:22,350
0,630 660,1590 1890,2640 2820,3210 3210,3480
smaller matrix| and so it's
|事实上，对于应用程序程序员来说，这很常见，

443
00:15:22,380 --> 00:15:24,300
0,570 570,1230 1350,1530 1530,1770 1770,1920
quite common, in fact for

444
00:15:24,300 --> 00:15:25,980
0,420 420,960 960,1080 1080,1380 1380,1680
application programmers| and probably if
|如果你考虑一下自己编写的应用程序，

445
00:15:25,980 --> 00:15:26,760
0,120 120,270 270,480 480,630 630,780
you think about your own

446
00:15:26,760 --> 00:15:29,100
0,540 540,1020 1080,1440 1440,1740 1740,2340
applications written| to actually over
|过多申请并拥有它们使用（的内存）。

447
00:15:29,100 --> 00:15:30,690
0,540 570,870 870,1200 1200,1410 1410,1590
ask and actually [own] their

448
00:15:30,690 --> 00:15:31,580
0,570
use.|
|

449
00:15:32,100 --> 00:15:34,320
0,480 630,1140 1140,1470 1470,1650 1650,2220
{} And we'd like to,
我们希望，原则上，不是什么大问题，

450
00:15:34,650 --> 00:15:36,180
0,690 690,840 840,870 870,1170 1170,1530
principle, not a big problem,|
|

451
00:15:36,180 --> 00:15:37,470
0,150 150,270 270,390 390,690 690,1290
but you know using actually
使用虚拟内存和页面错误处理程序，

452
00:15:37,500 --> 00:15:38,850
0,270 270,570 570,930 930,1110 1110,1350
{} virtual memory and page

453
00:15:38,850 --> 00:15:40,320
0,210 210,660 900,1230 1230,1380 1380,1470
fault handlers,| {} we can
|我们完全可以以一种聪明的方式做出回应，

454
00:15:40,320 --> 00:15:43,770
0,210 210,840 1770,2520 2520,2880 2910,3450
actually totally totally {} responded

455
00:15:43,770 --> 00:15:44,520
0,270 270,420 420,600 600,660 660,750
at, in sort of an

456
00:15:44,520 --> 00:15:46,860
0,510 510,930 1320,1890
intelligent manner {},|
|

457
00:15:46,860 --> 00:15:49,230
0,510 600,870 870,1320 1320,1980 1980,2370
and, {} by basically doing
通过使用懒分配。

458
00:15:49,230 --> 00:15:50,800
0,450 450,1020
lazy allocation.|
|

459
00:15:59,060 --> 00:16:00,530
0,570 570,720 720,990 990,1200 1200,1470
And the basic idea is
它的基本想法很简单，

460
00:16:00,530 --> 00:16:02,630
0,540 540,1020 1170,1740 1740,1950 1950,2100
very simple,| {} at {sbrk
|在 sbrk 中我们基本上什么也不做，

461
00:16:02,630 --> 00:16:03,760
0,540
-},

462
00:16:06,460 --> 00:16:07,750
0,180 180,450 450,690 690,900 900,1290
we're basically gonna do almost

463
00:16:07,750 --> 00:16:09,130
0,390 600,810 810,1110 1110,1260 1260,1380
nothing,| the only thing that
|我们唯一要做的是，记住增加了地址空间，

464
00:16:09,130 --> 00:16:10,120
0,90 90,270 270,330 330,630 630,990
we need to know, remember

465
00:16:10,120 --> 00:16:11,200
0,120 120,360 360,570 570,810 810,1080
of course that we get

466
00:16:11,200 --> 00:16:12,250
0,300 300,630 630,840 840,960 960,1050
grow address space,| so the
|所以，我们唯一要做的就是 p->sz 增加一个数，

467
00:16:12,250 --> 00:16:13,150
0,210 210,300 300,540 540,720 720,900
only thing we are going

468
00:16:13,150 --> 00:16:14,170
0,60 60,180 180,600 690,840 840,1020
to be doing is actually

469
00:16:14,170 --> 00:16:15,700
0,510 510,870 1080,1200 1200,1320 1320,1530
bumping up you know {p->sz

470
00:16:15,700 --> 00:16:16,780
0,570
-},

471
00:16:18,220 --> 00:16:19,300
0,150 150,240 240,720 720,960 960,1080
you know, whatever with the

472
00:16:19,300 --> 00:16:21,040
0,1170
number,|
|

473
00:16:21,690 --> 00:16:23,250
0,210 210,570 570,930 930,1230 1230,1560
{you,know,set} {p->sz -} to one
把 p->sz 设置成一个加上 n 的大小，

474
00:16:23,250 --> 00:16:24,720
0,120 120,210 210,780 780,1110 1110,1470
of the new size plus

475
00:16:24,720 --> 00:16:25,980
0,120 120,210 210,510 930,1080 1080,1260
you {know,n}| and {you,know} what
|n 是内存的分配量。

476
00:16:25,980 --> 00:16:26,580
0,90 90,240 240,300 300,540 540,600
n is the amount of

477
00:16:26,580 --> 00:16:28,180
0,270 270,450 450,1080
memory that's allocated.|
|

478
00:16:28,600 --> 00:16:29,680
0,150 150,510 540,630 630,900 900,1080
And then you know, {}
然后，我们没有分配，

479
00:16:29,680 --> 00:16:31,000
0,300 330,630 630,810 810,1260 1260,1320
that we don't allocate,| the
|内核在这时没有分配任何物理内存，

480
00:16:31,000 --> 00:16:32,320
0,240 240,450 450,840 840,1050 1050,1320
kernel doesn't allocate any physical

481
00:16:32,320 --> 00:16:33,220
0,270 270,330 330,450 450,750 750,900
memory at that particular point

482
00:16:33,220 --> 00:16:34,270
0,60 60,360 360,420 420,630 630,1050
of time,| it doesn't zero,
|它什么也没做。

483
00:16:34,270 --> 00:16:35,980
0,420 420,900 900,1170
there's absolutely nothing.|
|

484
00:16:36,070 --> 00:16:37,320
0,600

485
00:16:37,570 --> 00:16:38,290
0,210 210,270 270,420 420,630 630,720
Then, at some point the
然后，在某个时刻，应用程序可能会使用该内存，

486
00:16:38,290 --> 00:16:39,670
0,420 420,600 600,930 930,1050 1050,1380
application will use or might

487
00:16:39,670 --> 00:16:41,110
0,300 300,540 540,900 900,1260 1260,1440
use that memory, correct,| if
|如果那是它需要的一块内存，

488
00:16:41,110 --> 00:16:41,830
0,150 150,240 240,480 480,660 660,720
it is actually one of

489
00:16:41,830 --> 00:16:42,730
0,90 90,300 300,390 390,720 720,900
the pieces of memory that

490
00:16:42,730 --> 00:16:44,890
0,150 150,330 330,900 1140,1650 1650,2160
it really needs| {} and
|这会导致页面错误。

491
00:16:44,890 --> 00:16:46,030
0,420 420,510 510,840 840,900 900,1140
that will cause a page

492
00:16:46,030 --> 00:16:46,920
0,450
fault.|
|

493
00:16:47,360 --> 00:16:48,720
0,330 330,720
{Because -}
因为，我们没有映射那块内存到页面映射中，

494
00:16:48,720 --> 00:16:50,200
0,120 120,450 450,1140
we didn't map,

495
00:16:50,530 --> 00:16:52,120
0,240 240,600 600,870 870,1410 1410,1590
that memory actually into the

496
00:16:52,120 --> 00:16:53,860
0,240 240,450 450,840 1230,1530 1530,1740
page map yet,| {} and
|因此，如果我们引用虚拟地址，高于 p->sz 但是低于 p->sz + n ，

497
00:16:53,860 --> 00:16:55,240
0,540 540,570 570,960 960,1170 1170,1380
so, {} if we do

498
00:16:55,240 --> 00:16:57,310
0,540 540,990 990,1560 1740,1890 1890,2070
reference virtual address, you know

499
00:16:57,310 --> 00:16:58,390
0,390 420,510 510,630 630,840 840,1080
above, you know, this p->sz

500
00:16:58,390 --> 00:17:00,580
0,540 690,1200 1200,1590 1590,2010 2010,2190
{}, but below p->sz plus

501
00:17:00,580 --> 00:17:02,110
0,450 600,930 930,1230 1230,1350 1350,1530
n,| {} what we'd like
|我们希望的是，内核分配一个页面并重新启动指令。

502
00:17:02,110 --> 00:17:03,880
0,120 120,600 630,1200 1200,1500 1500,1770
to be happening is that

503
00:17:03,880 --> 00:17:05,590
0,90 90,390 390,960 990,1320 1320,1710
you know the kernel allocate

504
00:17:05,590 --> 00:17:07,540
0,30 30,360 360,660 720,1440 1440,1950
a page and restarts instruction.|
|

505
00:17:08,190 --> 00:17:09,660
0,540 930,1110 1110,1260 1260,1320 1320,1470
So, {} if we get
所以，如果我们遇到页面错误，

506
00:17:09,660 --> 00:17:10,830
0,60 60,270 270,780 930,1080 1080,1170
a page fault| and we
|并且看到虚拟地址高于 p->sz ，抱歉，低于 p->sz ，

507
00:17:10,830 --> 00:17:12,090
0,150 150,270 270,360 360,720 720,1260
see that the virtual address

508
00:17:12,510 --> 00:17:14,520
0,660 660,870 870,1080 1080,1170 1170,2010
is {} bigger than p->sz,

509
00:17:14,670 --> 00:17:16,980
0,510 510,1320 1380,1710
it's below, sorry,

510
00:17:17,490 --> 00:17:19,480
0,210 210,480 480,720 720,1320
these below {p->sz -},

511
00:17:21,430 --> 00:17:22,930
0,330 330,540 540,810 810,1170 1260,1500
{} for p->sz,| then we
|而且这个地址高于栈，

512
00:17:22,930 --> 00:17:24,100
0,480 480,630 630,780 780,1020 1020,1170
know that this must be

513
00:17:24,100 --> 00:17:26,170
0,330 330,840 870,1230 1230,1560 1560,2070
virtual address {I,guess} above stack,|
|

514
00:17:28,770 --> 00:17:29,670
0,180 180,450 450,630 630,780 780,900
we know that this is
我们知道这是一个堆中的地址，

515
00:17:29,670 --> 00:17:31,380
0,540 540,990 990,1320 1320,1470 1470,1710
{} an address that actually

516
00:17:31,380 --> 00:17:32,310
0,240 240,360 360,450 450,510 510,930
comes out of the heap,|
|

517
00:17:32,430 --> 00:17:33,630
0,330 330,420 420,660 660,1110 1110,1200
but for which we, the
但是，内核还没有为它分配任何物理内存。

518
00:17:33,630 --> 00:17:36,600
0,270 270,600 600,1380 1620,2280 2400,2970
kernel hasn't allocated any physical

519
00:17:36,600 --> 00:17:37,680
0,300 300,600
memory yet.|
|

520
00:17:38,050 --> 00:17:39,730
0,180 180,600 720,1080 1080,1590 1590,1680
And so the response to
对这个页面错误的反应可以很直接，

521
00:17:39,730 --> 00:17:40,720
0,120 120,330 330,600 600,900 900,990
this page fault could be

522
00:17:40,720 --> 00:17:42,370
0,300 300,960 960,1350 1350,1440 1440,1650
reasonably straightforward,| in the page
|在页面错误处理程序中，我们可以分配一个页面，

523
00:17:42,370 --> 00:17:43,990
0,180 180,480 480,1140 1290,1530 1530,1620
fault handler itself, we can

524
00:17:43,990 --> 00:17:46,260
0,750 900,1170 1170,1680
allocate a page,|
|

525
00:17:46,420 --> 00:17:48,220
0,270 270,720 720,1200
{} using kalloc,
使用 kalloc ，分配一页，置零，并映射到页表中，

526
00:17:48,580 --> 00:17:50,300
0,450 450,600 600,1200
allocate one page,

527
00:17:50,740 --> 00:17:52,320
0,360 360,450 450,930
zero the page,

528
00:17:55,690 --> 00:17:57,260
0,390 390,450 450,1020
map the page

529
00:17:57,260 --> 00:17:58,460
0,450 450,570 570,780 780,1050 1050,1200
into the {pagetable -},| so
|更新页表，然后重启指令。

530
00:17:58,460 --> 00:18:00,340
0,420 420,480 480,720 720,1320
updating the {pagetables -},

531
00:18:03,050 --> 00:18:04,730
0,240 240,660 660,1080 1080,1170 1170,1680
then basically restart the instruction.|
|

532
00:18:07,000 --> 00:18:08,320
0,180 180,240 240,780 780,1140 1290,1320
So, for example is a
比如，加载指令或保存指令，

533
00:18:08,320 --> 00:18:09,610
0,330 330,870 870,960 960,1020 1020,1290
load instruction or a store

534
00:18:09,610 --> 00:18:11,620
0,720 840,1140 1140,1500 1500,1770 1800,2010
instruction| that loads from or
|从进程已经包含，但实际未分配的内存中加载或读取，

535
00:18:11,620 --> 00:18:12,880
0,120 120,510 510,630 630,720 720,1260
to read you know from

536
00:18:13,000 --> 00:18:15,610
0,480 840,1350 1350,1950 1980,2160 2160,2610
{} not allocated {} piece

537
00:18:15,610 --> 00:18:17,110
0,270 270,630 630,780 780,1050 1050,1500
of memory that actually the

538
00:18:17,140 --> 00:18:20,080
0,360 360,870 1140,2190 2190,2580 2580,2940
process has,| now after we
|现在，我们映射了这个物理页面后，重启命令应该可以正常工作。

539
00:18:20,110 --> 00:18:21,880
0,330 330,420 420,660 660,1230 1230,1770
mapped in this physical page,

540
00:18:22,000 --> 00:18:23,770
0,270 270,810 810,1230 1230,1650 1650,1770
{} the restart instruction should

541
00:18:23,770 --> 00:18:24,620
0,180 180,510
just work.|
|

542
00:18:25,210 --> 00:18:26,800
0,270 270,480 480,600 600,1020
{Amiar -}, go ahead.|
Amiar ，继续。|

543
00:18:28,260 --> 00:18:30,090
0,300 300,840 870,990 990,1140 1140,1830
Right, so I was wondering
好的，我想知道在急分配的情况下，

544
00:18:30,480 --> 00:18:31,590
0,480 480,570 570,840 840,990 990,1110
in the case where we're

545
00:18:31,590 --> 00:18:34,710
0,270 270,900 900,1710 2160,2790 2790,3120
doing eager allocation,| {} and
|某一时刻，进程消耗很多内存，

546
00:18:34,710 --> 00:18:35,670
0,120 120,390 390,480 480,720 720,960
there comes a point where

547
00:18:35,670 --> 00:18:37,560
0,420 420,1020 1020,1200 1200,1440 1440,1890
process consumes so much memory,|
|

548
00:18:37,560 --> 00:18:39,120
0,300 300,420 420,750 750,1410 1410,1560
that it actually exhausts the
它耗尽物理内存资源，

549
00:18:39,120 --> 00:18:42,420
0,450 450,990 990,1800 2790,3030 3030,3300
physical memory resource,| if we
|如果我们不使用急分配，而使用懒分配，

550
00:18:42,420 --> 00:18:44,160
0,300 300,450 450,720 720,1560 1560,1740
don't do eager allocation, we

551
00:18:44,160 --> 00:18:46,950
0,150 150,510 510,1140 2310,2520 2520,2790
do lazy instead,| at what
|在什么情况下，应用程序才会知道没有物理内存。

552
00:18:46,950 --> 00:18:48,600
0,330 330,480 480,540 540,1260 1260,1650
point would the application know

553
00:18:48,600 --> 00:18:49,530
0,150 150,270 270,360 360,540 540,930
that there is no physical

554
00:18:49,530 --> 00:18:50,420
0,420
memory.|
|

555
00:18:50,700 --> 00:18:52,260
0,540 540,600 600,750 750,1320 1320,1560
{} Yeah, that's a great
是的，这是个很好的问题，

556
00:18:52,260 --> 00:18:54,300
0,510 630,1230 1230,1380 1380,1560 1560,2040
question,| {} you know, basically
|基本上，从应用程序的角度看，

557
00:18:54,300 --> 00:18:55,350
0,120 120,240 240,600 600,870 870,1050
you know it almost looks

558
00:18:55,350 --> 00:18:57,390
0,90 90,210 210,780 780,1230 1230,2040
through the application,| there's {this,illusion}
|有无限多的内存。

559
00:18:57,390 --> 00:18:59,640
0,540 930,1710 1710,2010 2010,2190 2190,2250
of unlimited physical amount of

560
00:18:59,640 --> 00:19:00,520
0,390
memory.|
|

561
00:19:00,750 --> 00:19:01,530
0,270 270,360 360,510 510,720 720,780
{You,know}, at some point of
当然在某些时候，你可能用得太多了，

562
00:19:01,530 --> 00:19:03,150
0,450 450,540 540,780 780,1290 1290,1620
course, you know you might

563
00:19:03,150 --> 00:19:04,260
0,240 240,420 420,840 840,990 990,1110
use so much,| you know
|基本上使用了所有物理内存，

564
00:19:04,260 --> 00:19:06,660
0,270 270,600 1290,1890 1890,2130 2130,2400
that basically use all physical

565
00:19:06,660 --> 00:19:07,710
0,360 360,480 480,630 630,840 840,1050
memory,| and so if then
|所以，如果它再多申请一页，

566
00:19:07,710 --> 00:19:09,360
0,210 240,630 630,900 900,1110 1110,1650
it touches one more page,|
|

567
00:19:09,420 --> 00:19:10,350
0,90 90,270 270,480 480,630 630,930
{} which there's no physical
这个时候，物理内存不够用了。

568
00:19:10,350 --> 00:19:11,760
0,300 300,780 810,930 930,1080 1080,1410
memory present at that particular

569
00:19:11,760 --> 00:19:12,860
0,180 180,240 240,630
point in time.|

570
00:19:12,860 --> 00:19:13,850
0,540 540,630 630,750 750,960 960,990
Then you know there's a
然后内核可以采取几个操作，

571
00:19:13,850 --> 00:19:14,540
0,210 210,270 270,540 540,630 630,690
couple of actions that the

572
00:19:14,540 --> 00:19:15,680
0,240 240,360 360,690 720,960 960,1140
kernel can take| and I'll
|稍后我会谈到更复杂的问题，

573
00:19:15,680 --> 00:19:17,390
0,210 210,540 720,930 930,1470 1470,1710
talk about more sophisticated ones

574
00:19:17,390 --> 00:19:19,130
0,450 660,1110 1110,1410 1410,1590 1590,1740
later,| {} what you're gonna
|你要在 lazy 实验中做的是，

575
00:19:19,130 --> 00:19:20,660
0,90 90,510 510,870 870,1170 1200,1530
be doing in the lazy

576
00:19:20,660 --> 00:19:22,790
0,570 780,1440 1440,1590 1590,1710 1710,2130
lab| is you know if
|如果内存增长到没有空闲内存，

577
00:19:22,790 --> 00:19:24,410
0,60 60,630 630,960 990,1410 1440,1620
the memories {} up and

578
00:19:24,410 --> 00:19:26,180
0,360 360,720 720,1110 1110,1260 1260,1770
there's no more free memory,|
|

579
00:19:26,390 --> 00:19:27,760
0,450 450,990
{} {you,just}
在这种情况下，你只需要返回一个错误，并杀死进程。

580
00:19:27,820 --> 00:19:29,320
0,540 540,630 630,960 960,1320 1320,1500
return an error, actually kill

581
00:19:29,320 --> 00:19:30,760
0,90 90,660 780,990 990,1110 1110,1440
the process in that particular

582
00:19:30,760 --> 00:19:31,680
0,450
case.|
|

583
00:19:32,660 --> 00:19:34,040
0,540 540,840 840,930 930,1140 1140,1380
{} And so because you're
而且因为内存不足，内核也不能做什么，

584
00:19:34,040 --> 00:19:35,090
0,120 120,180 180,660 690,870 870,1050
out of memory, so there's

585
00:19:35,090 --> 00:19:36,530
0,270 270,330 330,660 660,1050 1080,1440
nothing kernel can do| and
|这时，只能返回或杀死进程。

586
00:19:36,530 --> 00:19:37,910
0,60 60,210 210,510 510,960 960,1380
at that point, {you,know} return

587
00:19:37,910 --> 00:19:39,440
0,210 210,420 420,510 510,1050
or kill the process.|
|

588
00:19:40,970 --> 00:19:42,110
0,360 360,840 840,960 960,1020 1020,1140
That's you're going to do
这就是你要在 lazy 实验中做的，

589
00:19:42,110 --> 00:19:43,190
0,90 90,390 390,720 720,840 840,1080
in lazy lab,| we'll see
|我们稍后会在这节课中看到，

590
00:19:43,190 --> 00:19:44,180
0,300 300,390 390,540 540,870 870,990
later in this lecture,| you
|你可以做的比这更复杂。

591
00:19:44,180 --> 00:19:45,350
0,90 90,210 210,420 420,1050 1050,1170
can be more sophisticated than

592
00:19:45,350 --> 00:19:46,240
0,300
that.|
|

593
00:19:48,040 --> 00:19:48,790
0,240 240,390 390,420 420,630 630,750
{} And I think this
我想这引出了一个话题，

594
00:19:48,790 --> 00:19:50,050
0,180 180,660 660,1080 1080,1200 1200,1260
is generally brings up a

595
00:19:50,050 --> 00:19:51,520
0,480 480,780 780,1110 1110,1350 1350,1470
topic| that is we have
|我们有一组运行在操作系统上的进程，

596
00:19:51,520 --> 00:19:53,020
0,60 60,450 450,510 510,1080 1080,1500
a collection of processes running

597
00:19:53,020 --> 00:19:55,210
0,600 930,1080 1080,1410 1410,1950 1950,2190
on an operating system,| there's
|而物理内存是有限的，

598
00:19:55,210 --> 00:19:56,140
0,60 60,450 450,630 630,690 690,930
a limited amount of physical

599
00:19:56,140 --> 00:19:57,730
0,390 570,870 870,1050 1050,1290 1290,1590
memory,| and that {limited -}
|并且这些有限的物理内存必须以某种方式在应用程序之间共享。

600
00:19:57,730 --> 00:19:58,960
0,270 270,600 600,840 840,930 930,1230
physical memory must be shared

601
00:19:58,960 --> 00:19:59,770
0,60 60,270 270,480 480,750 750,810
in some way between the

602
00:19:59,770 --> 00:20:01,040
0,840
applications.|
|

603
00:20:01,040 --> 00:20:02,150
0,240 240,600 720,900 900,1080 1080,1110
And so I'll talk a
我将在 10 20 分钟后，详细讨论这个问题。

604
00:20:02,150 --> 00:20:03,200
0,180 180,360 360,600 600,810 810,1050
little bit much more about

605
00:20:03,200 --> 00:20:05,660
0,90 90,690 900,1530 1530,1950
it in 10,20 minutes.|
|

606
00:20:07,440 --> 00:20:09,750
0,510 750,1080 1080,1290 1290,1800 1800,2310
Okay, there's a question {}
好的，聊天窗口中有个问题。

607
00:20:10,080 --> 00:20:11,850
0,510 510,630 630,720 720,1260 1380,1770
{} in the chat.| Why
|为什么虚拟地址比较不是从零开始的。

608
00:20:11,850 --> 00:20:13,620
0,90 90,150 150,660 660,1260 1260,1770
is the condition virtual address,

609
00:20:13,620 --> 00:20:16,080
0,1950
{}

610
00:20:16,290 --> 00:20:17,940
0,360 360,630 630,1170 1170,1410 1410,1650
virtual address [booms] doesn't start

611
00:20:17,940 --> 00:20:19,120
0,90 90,720
at zero.|
|

612
00:20:19,150 --> 00:20:21,760
0,660 660,1200 1320,1920 2280,2550 2550,2610
{} OK, {} there's a
好的，这是一个关于这个检查的问题。

613
00:20:21,760 --> 00:20:23,350
0,270 270,450 450,660 660,1230 1230,1590
question about this particular check

614
00:20:23,350 --> 00:20:25,460
0,570 900,1590
here {}.|
|

615
00:20:26,140 --> 00:20:29,040
0,630 840,1380 1620,2370
So, {} remember,
所以，这里有栈，

616
00:20:30,260 --> 00:20:32,030
0,360 360,630 630,750 750,1080 1080,1770
we have our stack here,|
|

617
00:20:32,590 --> 00:20:34,840
0,780 780,960 960,1260 1260,1470 1470,2250
and we have our data
这里有进程的数据和文本，

618
00:20:35,230 --> 00:20:36,640
0,690 690,930 930,1080 1080,1290 1290,1410
here and we have our

619
00:20:36,640 --> 00:20:39,220
0,510 540,720 720,990 990,1650 1980,2580
text in user process| and
|我们把 p->sz 增加到更大的位置。

620
00:20:39,310 --> 00:20:41,170
0,360 360,600 600,930 930,1350 1380,1860
basically we've bumped up {p->sz

621
00:20:41,170 --> 00:20:42,980
0,360 360,450 450,750 750,1350
-} to something bigger.|
|

622
00:20:45,120 --> 00:20:46,950
0,510 570,990 990,1320 1320,1410 1410,1830
{} We've {bumped,up} the [growth],
我们已经增加了[]，但是没有分配内存，

623
00:20:46,980 --> 00:20:48,180
0,240 240,420 420,480 480,900 900,1200
we havn't the allocated memory

624
00:20:48,180 --> 00:20:49,290
0,210 210,480 510,660 660,810 810,1110
here yet,| so this memory
|所以这个内存还没有物理分配，

625
00:20:49,290 --> 00:20:50,940
0,240 240,510 510,900 900,1230 1230,1650
has not been physically allocated

626
00:20:50,940 --> 00:20:52,380
0,210 210,360 360,570 570,1020 1140,1440
yet,| so this check this
|所以这个检查，如果地址落在 p->sz 以下，

627
00:20:52,380 --> 00:20:54,000
0,510 630,840 840,930 930,1260 1260,1620
check if the address falls

628
00:20:54,000 --> 00:20:55,110
0,270 270,450 450,900 900,1020 1020,1110
below {p->sz -}| and it
|它是用户地址空间中的有效地址，

629
00:20:55,110 --> 00:20:56,580
0,240 240,300 300,360 360,840 870,1470
actually is a valid address

630
00:20:56,580 --> 00:20:57,750
0,240 240,330 330,600 600,840 840,1170
in the user address space,|
|

631
00:20:57,750 --> 00:20:59,580
0,330 330,630 660,1140 1140,1320 1320,1830
if there above {p->sz -},
如果在 p->sz 之上，可能是编程错误，

632
00:20:59,610 --> 00:21:01,350
0,570 570,750 750,810 810,1260 1260,1740
presumably that's a programming error,|
|

633
00:21:01,500 --> 00:21:03,270
0,540 540,960 960,1140 1140,1530 1530,1770
{} and the program or
用户应用程序试图在内存中，引用实际上不属于它的内存。

634
00:21:03,270 --> 00:21:04,620
0,240 240,840 840,1080 1080,1170 1170,1350
user applications trying to {reference

635
00:21:04,620 --> 00:21:05,760
0,360 360,450 450,720 720,870 870,1140
-} in memory that actually

636
00:21:05,760 --> 00:21:06,740
0,240 240,600
doesn't have.|
|

637
00:21:07,390 --> 00:21:08,770
0,450 450,600 600,840 840,900 900,1380
Hopefully that answered the question.|
希望我回答了这个问题。|

638
00:21:11,380 --> 00:21:12,780
0,270 270,510 510,780
Yeah, thank you.|
是的，谢谢。|

639
00:21:12,810 --> 00:21:15,360
0,510 900,1410 1440,2070 2220,2490 2490,2550
Okay, so to get a
好的，为了感受一下懒分配是什么，

640
00:21:15,360 --> 00:21:16,440
0,180 180,300 300,390 390,480 480,1080
little bit of {} feel,

641
00:21:16,650 --> 00:21:18,000
0,750 750,900 900,990 990,1230 1230,1350
{} you know what it

642
00:21:18,000 --> 00:21:20,850
0,360 360,1170 1200,1560 1560,2130 2700,2850
actually means {} and this

643
00:21:20,850 --> 00:21:22,980
0,270 270,900 1170,1560 1560,1890 2100,2130
lazy allocation,| {} and {}
|这可能是今天唯一要做的编程或代码，

644
00:21:22,980 --> 00:21:24,460
0,330 330,720 720,1020
that's probably {},

645
00:21:24,630 --> 00:21:26,850
0,300 300,960 1200,1530 1530,1590 1590,2220
the only sort of programming

646
00:21:26,850 --> 00:21:28,140
0,240 240,510 510,1080 1080,1200 1200,1290
or code things that were

647
00:21:28,140 --> 00:21:29,310
0,120 120,180 180,240 240,660 660,1170
going to be doing {}

648
00:21:29,520 --> 00:21:31,530
0,420 420,720 780,1470 1500,1770 1770,2010
today is {},| let's try
|让我们看看它在代码中的样子。

649
00:21:31,530 --> 00:21:33,600
0,360 390,810 840,1260 1260,1680 1680,2070
to sort of sketch out

650
00:21:33,600 --> 00:21:35,010
0,240 240,660 660,960 960,1260 1260,1410
or look actually how will

651
00:21:35,010 --> 00:21:36,860
0,210 210,480 480,810 810,1410
look in the {in,code}.|

652
00:21:37,030 --> 00:21:38,240
0,660

653
00:21:38,350 --> 00:21:39,070
0,240 240,300 300,420 420,630 630,720
When the {[] -}, you
当[]，你可以看到它非常简单，

654
00:21:39,070 --> 00:21:39,760
0,240 240,420 420,480 480,630 630,690
see that it will be

655
00:21:39,760 --> 00:21:43,180
0,630 630,1320 1530,2010 2010,2730 2760,3420
surprising easy| {and -} furthermore
|另外，这可能对 lazy 实验有很大帮助。

656
00:21:43,210 --> 00:21:44,260
0,360 360,510 510,810 810,870 870,1050
{} it's probably {} big

657
00:21:44,260 --> 00:21:47,290
0,930 930,1290 1290,1590 1620,2400 2400,3030
help for the lazy lab.|
|

658
00:21:48,150 --> 00:21:49,080
0,150 150,360 360,720 720,840 840,930
And so, hopefully that will
所以，希望这能帮助你更直接地开始。

659
00:21:49,080 --> 00:21:50,490
0,210 210,420 420,630 630,1020 1050,1410
help you get going pretty

660
00:21:50,490 --> 00:21:51,760
0,750
straightforwardly.|
|

661
00:21:52,600 --> 00:21:53,800
0,420 420,510 510,720 720,1110 1110,1200
And at large [resources] to
让我们看几个页面错误。

662
00:21:53,800 --> 00:21:55,660
0,180 180,270 270,300 300,840 1140,1860
look at a couple {}

663
00:21:57,990 --> 00:21:59,160
0,600
{page,faults}

664
00:21:59,700 --> 00:22:01,650
0,30 30,30 1110,1350 1350,1440 1440,1950
{}.| I have a question,
|我有个问题，我有一个想法，

665
00:22:01,650 --> 00:22:03,000
0,510 510,630 630,780 780,960 960,1350
actually we got a point,|
|

666
00:22:03,810 --> 00:22:04,980
0,450 450,570 570,690 690,990 990,1170
why do we actually need
为什么我们杀死应用程序，

667
00:22:04,980 --> 00:22:06,360
0,90 90,300 300,390 390,1050 1080,1380
to kill the application,| could
|操作系统能不能返回一个负数，内存不足什么的。

668
00:22:06,360 --> 00:22:07,830
0,330 330,780 780,1170 1170,1380 1380,1470
the operating system just to

669
00:22:07,830 --> 00:22:09,330
0,240 240,420 420,900 1140,1440 1440,1500
return {like,a} [negative], out of

670
00:22:09,330 --> 00:22:10,950
0,360 360,600 600,720 720,1050 1050,1620
memory trying to something else.|
|

671
00:22:11,970 --> 00:22:13,290
0,480 480,780 780,900 900,960 960,1320
Let's respond to the question
我们稍后再回答这个问题，

672
00:22:13,290 --> 00:22:14,940
0,30 30,210 210,330 330,720 1050,1650
a little bit later {},|
|

673
00:22:14,940 --> 00:22:16,110
0,540 540,600 600,810 810,1080 1080,1170
in the page fault, we're
在页面错误中，我们直接杀死该进程，

674
00:22:16,110 --> 00:22:16,800
0,120 120,210 210,390 390,600 600,690
going to just kill the

675
00:22:16,800 --> 00:22:17,780
0,600
process,|
|

676
00:22:17,780 --> 00:22:18,890
0,420 420,660 660,780 780,990 990,1110
{} but you know we
但是，我们可以在[]实验中做得更复杂，

677
00:22:18,890 --> 00:22:20,900
0,150 150,270 270,420 420,1170 1650,2010
could be more sophisticated, {in,[]}

678
00:22:20,900 --> 00:22:21,860
0,420
lab,|
|

679
00:22:21,950 --> 00:22:23,270
0,480 480,750 750,810 810,960 960,1320
real kernels are more sophisticated.|
真正的内核更复杂。|

680
00:22:25,060 --> 00:22:26,500
0,420 570,960 960,1230 1230,1320 1320,1440
Okay, {} although in the
好的，虽然最后它们可能还是被杀死，

681
00:22:26,500 --> 00:22:27,520
0,210 210,300 300,510 510,690 690,1020
end they might still kill,|
|

682
00:22:27,790 --> 00:22:29,290
0,210 210,570 570,990 990,1170 1170,1500
if there's no more memory,
如果没有更多的内存，还有什么能做的，

683
00:22:29,290 --> 00:22:30,370
0,240 240,570 570,870 870,960 960,1080
what what's there to be

684
00:22:30,370 --> 00:22:31,510
0,360 390,540 540,660 660,840 840,1140
done,| you know there's basically
|我们基本上别无选择。

685
00:22:31,510 --> 00:22:32,640
0,180 180,660
no choice.|
|

686
00:22:32,880 --> 00:22:34,080
0,630

687
00:22:34,140 --> 00:22:35,610
0,510 540,810 810,960 960,1290 1290,1470
Okay, {} so the first
好的，所以首先我要修改的，

688
00:22:35,610 --> 00:22:37,200
0,270 270,570 570,1080 1080,1140 1140,1590
thing we're going to modify,|
|

689
00:22:37,200 --> 00:22:39,210
0,360 690,1110 1110,1260 1260,1470 1470,2010
so remember that's {growproc -}
growproc 增加应用程序的地址空间，

690
00:22:39,210 --> 00:22:40,110
0,120 120,210 210,480 480,810 810,900
you know actually grows to

691
00:22:40,110 --> 00:22:41,490
0,270 270,570 570,690 690,780 780,1380
address space with the application,|
|

692
00:22:41,490 --> 00:22:42,570
0,390 390,750 750,870 870,960 960,1080
allocates memory and all that
分配内存和其他的东西，

693
00:22:42,570 --> 00:22:43,590
0,120 120,180 180,510 600,870 870,1020
kind of stuff,| we're just
|我们不会这么做，

694
00:22:43,590 --> 00:22:44,840
0,180 180,330 330,450 450,720
not gonna do that,|
|

695
00:22:45,090 --> 00:22:46,110
0,180 180,330 330,480 480,810 810,1020
you're just gonna set {p->sz
你只需要设置 p->sz 为 p->sz + n 。

696
00:22:46,110 --> 00:22:47,960
0,480 480,690 690,1290
-}, {you,know} to

697
00:22:48,480 --> 00:22:50,560
0,390 390,630 630,1680
{} {p->sz -}

698
00:22:51,040 --> 00:22:52,480
0,180 180,480 480,750 1080,1260 1260,1440
{} plus n.| So let's
|现在，让我们假设数字只是增长而不用考虑减少，

699
00:22:52,480 --> 00:22:53,860
0,360 360,480 480,660 660,870 870,1380
assume that number only growing

700
00:22:53,860 --> 00:22:55,360
0,150 150,210 210,570 570,1080 1080,1500
and not worry about shrinking

701
00:22:55,360 --> 00:22:56,740
0,120 120,510 930,1080 1080,1290 1290,1380
for now,| and that is
|这就是我们要做的。

702
00:22:56,740 --> 00:22:57,520
0,150 150,270 270,420 420,510 510,780
what we're gonna be doing.|
|

703
00:22:58,350 --> 00:23:00,150
0,420 450,780 780,1140 1140,1320 1320,1800
So this grows the virtual
所以，这会使虚拟地址空间增加 n ，这就是我们要做的。

704
00:23:00,150 --> 00:23:02,580
0,240 240,780 780,1290 1290,1770 2040,2430
address space by n {},

705
00:23:02,580 --> 00:23:03,930
0,210 210,690 720,1140 1140,1260 1260,1350
that's all we're going to

706
00:23:03,930 --> 00:23:04,940
0,150 150,330
be doing.|
|

707
00:23:05,920 --> 00:23:06,850
0,360 360,540 540,660 660,750 750,930
Let's see if I can
让我们看看，是否有编程错误，

708
00:23:06,850 --> 00:23:08,260
0,180 180,270 270,660 660,1170 1200,1410
make no programming mistakes,| I
|我想，我有一个编程错误。

709
00:23:08,260 --> 00:23:09,790
0,270 270,420 420,480 480,900 900,1530
did make a programming mistake,

710
00:23:10,520 --> 00:23:12,620
0,750 780,1410
I guess.|
|

711
00:23:13,060 --> 00:23:14,650
0,150 150,330 330,600 600,1230 1230,1590
I don't have proc p
我这里没有 proc p ，所以 myproc 。

712
00:23:14,650 --> 00:23:16,480
0,270 270,450 450,1230
here, {so,myproc -}.|
|

713
00:23:24,000 --> 00:23:25,170
0,450 450,600 600,690 690,1020 1020,1170
Yeah, so the program just
是的，所以程序只是像往常启动一样运行，

714
00:23:25,170 --> 00:23:26,760
0,510 570,1050 1050,1260 1260,1380 1380,1590
runs {} {as,usual} we {}

715
00:23:26,760 --> 00:23:28,320
0,540 690,1050 1050,1050 1050,1440 1440,1560
boot,| {} I think if
|我想如果我们执行 echo hi ，我们会遇到一个页面错误，

716
00:23:28,320 --> 00:23:29,880
0,150 150,390 390,630 630,930 930,1560
we do like echo hi,

717
00:23:30,090 --> 00:23:31,530
0,420 420,600 600,810 810,990 990,1440
{} we're gonna get actually

718
00:23:31,530 --> 00:23:32,730
0,90 90,330 330,690 720,1110 1110,1200
a page fault| and the
|我们出现页面错误的原因是，

719
00:23:32,730 --> 00:23:33,450
0,330 330,450 450,540 540,660 660,720
reason that we get a

720
00:23:33,450 --> 00:23:35,310
0,210 210,480 480,690 690,1140 1470,1860
page fault is because {},|
|

721
00:23:35,310 --> 00:23:37,680
0,210 210,840 870,1050 1050,2130 2130,2370
the shell {} who's gonna
shell 要 fork echo ，然后子进程执行 echo ，

722
00:23:37,680 --> 00:23:39,960
0,630 630,750 750,1260 1260,1650 1650,2280
fork {you,know} echo and then

723
00:23:39,960 --> 00:23:42,090
0,180 180,510 510,960 1110,1590 1590,2130
the child's gonna exec echo,|
|

724
00:23:42,270 --> 00:23:43,590
0,330 330,480 480,720 720,990 990,1320
{} the shell actually allocate
shell 实际上分配了一些内存，

725
00:23:43,590 --> 00:23:44,540
0,120 120,540
some memory,|
|

726
00:23:44,630 --> 00:23:45,920
0,360 360,510 510,660 660,930 930,1290
and so the shell calls
因此 shell 调用 sbrk ，然后事情不太好，

727
00:23:45,920 --> 00:23:47,930
0,180 180,690 900,1710 1710,1950 1950,2010
{sbrk -} and things are

728
00:23:47,930 --> 00:23:49,280
0,150 150,390 390,660 690,1140 1170,1350
not looking good,| but it's
|但是，这里的信息看起来比较有趣，

729
00:23:49,280 --> 00:23:50,300
0,120 120,180 180,510 510,600 600,1020
sort of interesting to look

730
00:23:50,330 --> 00:23:52,100
0,420 420,510 510,720 720,1230 1320,1770
at, you know, the {}

731
00:23:52,100 --> 00:23:54,170
0,540 540,900 1170,1470 1470,1740 1740,2070
information here,| so here's {}
|这里打印出 scause 寄存器，它的值是 15 。

732
00:23:54,230 --> 00:23:55,100
0,180 180,420 420,570 570,690 690,870
it prints out the {scause

733
00:23:55,100 --> 00:23:57,280
0,510 570,1710
-} register,

734
00:23:57,280 --> 00:23:58,960
0,540 540,750 750,1140 1140,1350 1350,1680
{} the value {scause -}

735
00:23:58,960 --> 00:24:00,660
0,210 210,450 450,1170
and it's fifteen.|
|

736
00:24:00,660 --> 00:24:02,610
0,480 480,870 870,1380 1380,1590 1590,1950
{} Anybody, remember what fifteen
有没有人记得 15 是什么？

737
00:24:02,610 --> 00:24:03,700
0,570
is?|

738
00:24:06,860 --> 00:24:07,580
0,150 150,240 240,360 360,480 480,720
You know from that table
从刚在我展示的那张表中，

739
00:24:07,580 --> 00:24:08,300
0,210 210,390 390,450 450,540 540,720
{I,just} show you a little

740
00:24:08,300 --> 00:24:09,440
0,150 150,390 390,690 690,960 960,1140
bit a while ago {},|
|

741
00:24:09,440 --> 00:24:10,640
0,240 240,390 390,510 510,930 960,1200
actually used to write or
用于写入或存储页面错误。

742
00:24:10,640 --> 00:24:12,160
0,360 360,630 630,1020
store page fault.|
|

743
00:24:12,420 --> 00:24:13,980
0,330 330,480 480,690 690,1050 1080,1560
We {see -} this process
我们看到的进程 3 ，可能是 shell 。

744
00:24:13,980 --> 00:24:16,020
0,570 840,1020 1020,1350 1350,1440 1440,2040
three, that's probably the shell.|
|

745
00:24:16,520 --> 00:24:17,900
0,330 330,480 480,690 690,900 900,1380
And we actually see the
我们实际上看到的是异常程序计数器，它是 12a4 ，

746
00:24:17,930 --> 00:24:19,550
0,390 390,780 780,1290 1290,1440 1440,1620
exception program counter, it's one

747
00:24:19,550 --> 00:24:20,930
0,210 210,360 360,960 1110,1290 1290,1380
two a four| and we
|我们可以看到发生错误的虚拟地址是 4008 。

748
00:24:20,930 --> 00:24:22,100
0,270 270,360 360,900 900,1110 1110,1170
see the address given the

749
00:24:22,100 --> 00:24:23,120
0,300 300,570 570,660 660,900 900,1020
virtual address in which we

750
00:24:23,120 --> 00:24:25,240
0,390 390,570 570,690 690,1290 1290,1590
fault, which is {4008 -}.|
|

751
00:24:25,440 --> 00:24:26,550
0,210 210,330 330,540 540,990 990,1110
And so let's look at
那么让我们来看一下 shell 的汇编代码，

752
00:24:26,550 --> 00:24:27,480
0,450 570,690 690,780 780,840 840,930
the, you know, we can

753
00:24:27,480 --> 00:24:28,900
0,180 180,300 300,750
look at the

754
00:24:29,590 --> 00:24:32,050
0,660 660,1050 1050,1200 1200,1830 2190,2460
assembly of the shell,| {makefile
|makefile 为我们生成了该文件，

755
00:24:32,050 --> 00:24:34,000
0,450 510,1050 1050,1140 1140,1500 1530,1950
-} nice for us, nice

756
00:24:34,000 --> 00:24:34,960
0,270 270,480 480,630 630,750 750,960
enough for us to actually

757
00:24:34,960 --> 00:24:36,820
0,390 390,750 1290,1680 1680,1770 1770,1860
generate that| and we can
|我们可以看看地址 12a4 。

758
00:24:36,820 --> 00:24:38,480
0,210 210,330 330,540 540,1200
look at the address

759
00:24:38,510 --> 00:24:41,240
0,660 870,1320 1320,2190
{} {12a4 -}.|
|

760
00:24:41,660 --> 00:24:43,070
0,900 900,990 990,1140 1140,1260 1260,1410
And you know we see
我们看到是个一个存储指令，

761
00:24:43,070 --> 00:24:44,720
0,570 600,720 720,840 840,1620 1620,1650
indeed, you know, there's a

762
00:24:44,720 --> 00:24:46,160
0,270 270,900 900,1110 1110,1200 1200,1440
store instruction right,| the store
|这个存储指令看起来就是发生错误的地方。

763
00:24:46,160 --> 00:24:48,470
0,720 1050,1590 1590,1950 1950,2100 2100,2310
instruction and {}, it looks

764
00:24:48,470 --> 00:24:49,880
0,420 420,600 600,810 810,960 960,1410
like that's where we're faulting.|
|

765
00:24:50,860 --> 00:24:52,720
0,630 660,900 900,1290 1290,1620 1620,1860
{} So {you,know} scroll back
往后滚动一点，看这里的汇编代码，

766
00:24:52,720 --> 00:24:53,890
0,90 90,330 330,750 750,990 990,1170
a little bit and look

767
00:24:53,890 --> 00:24:56,050
0,60 60,210 210,720 720,1230 1500,2160
at this assembly here {},|
|

768
00:24:56,050 --> 00:24:57,700
0,180 180,300 300,480 480,1290 1320,1650
you know we see {}
我们看到这实际上是 malloc 实现的一部分。

769
00:24:57,700 --> 00:24:58,720
0,210 210,420 420,600 600,720 720,1020
that actually this is in

770
00:24:58,720 --> 00:25:00,130
0,300 300,420 420,600 600,1260 1260,1410
part of the implementation of

771
00:25:00,130 --> 00:25:01,180
0,570
malloc.|
|

772
00:25:01,330 --> 00:25:02,890
0,240 240,420 420,600 600,900 900,1560
{} So that seems {}
所以这看起来是完全合理的，这是 malloc 实现，

773
00:25:02,950 --> 00:25:05,230
0,330 330,780 780,1290 1290,1530 1530,2280
totally reasonable, here's malloc implementation,|
|

774
00:25:05,470 --> 00:25:07,000
0,210 210,690 690,870 870,1230 1230,1530
not surprising that we, presumably
这并不奇怪，我们使用 sbrk 获得一些内存来实现用户 malloc 。

775
00:25:07,000 --> 00:25:08,140
0,300 300,570 570,720 720,1050 1050,1140
we use {sbrk -} to

776
00:25:08,140 --> 00:25:10,510
0,150 150,300 300,1080 1080,1740 1740,2370
get some memory for implementing

777
00:25:10,510 --> 00:25:12,940
0,480 870,1410 1410,1950
the user malloc.|
|

778
00:25:13,060 --> 00:25:15,640
0,540 570,1110 1110,1410 1410,1950 1950,2580
And, {} {we're} basically initializing
我们把从内核得到内存，初始化为一个空闲列表，

779
00:25:15,640 --> 00:25:16,900
0,90 90,270 270,660 660,870 870,1260
a free list of the

780
00:25:16,930 --> 00:25:17,950
0,450 450,510 510,780 780,930 930,1020
use the memory that we've

781
00:25:17,950 --> 00:25:19,900
0,210 210,630 960,1290 1290,1380 1380,1950
just gotten from the kernel,|
|

782
00:25:20,140 --> 00:25:22,210
0,420 420,660 660,930 930,1260 1260,2070
and this line {12a4 -},
这个 12a4 行，我猜是写入一些东西，

783
00:25:22,450 --> 00:25:25,240
0,1050 1260,1890 1890,2340 2340,2430 2430,2790
{} [] writes, you know,

784
00:25:25,330 --> 00:25:26,470
0,150 150,300 300,630 630,1020 1020,1140
I guess write something {insides

785
00:25:26,470 --> 00:25:29,980
0,600 870,2220 2250,2700 2730,3150 3150,3510
-}| { -} but we
|但我们正在写入实际上未分配的内存。

786
00:25:30,010 --> 00:25:30,970
0,210 210,420 420,510 510,840 840,960
were writing to memory that

787
00:25:30,970 --> 00:25:32,500
0,210 210,450 450,570 570,1140
actually hasn't been allocated.|
|

788
00:25:33,240 --> 00:25:34,050
0,330 330,540 540,630 630,690 690,810
Another reason that we could
我们可以看到内存可能未分配的另一个原因是，

789
00:25:34,050 --> 00:25:35,160
0,360 360,510 510,570 570,840 840,1110
see that the memory probably

790
00:25:35,160 --> 00:25:37,830
0,180 180,720 720,1170 1470,2010 2040,2670
not allocated is,| {} the
|我认为 shell 实际上有四页文本和数据，

791
00:25:37,950 --> 00:25:39,060
0,180 180,450 450,690 690,840 840,1110
{I,think} shell actually has four

792
00:25:39,060 --> 00:25:41,580
0,660 690,1170 1230,1830 1830,2070 2070,2520
pages of text and data|
|

793
00:25:41,820 --> 00:25:43,500
0,360 360,510 510,840 840,1200 1200,1680
and we're basically sitting just
我们正在第四页的上方，在第五页，

794
00:25:43,530 --> 00:25:45,000
0,390 390,510 510,840 840,1380 1380,1470
above the fourth page, in

795
00:25:45,000 --> 00:25:46,110
0,90 90,330 330,660 660,840 840,1110
the fifth page,| in fact
|实际上，我们的位置比它高出 8 个字节，

796
00:25:46,110 --> 00:25:47,400
0,60 60,330 330,600 600,960 960,1290
we're sitting eight bytes above

797
00:25:47,400 --> 00:25:48,600
0,240 570,750 750,930 930,1020 1020,1200
it,| that sort of makes
|这在某种程度上是有道理的，

798
00:25:48,600 --> 00:25:51,270
0,540 840,1830 2100,2460 2460,2550 2550,2670
sense,| {} look at the
|再看一下指令，在 {124a -} ，

799
00:25:51,270 --> 00:25:52,830
0,480 480,750 750,1050 1050,1380 1380,1560
instruction again, {where,at} {124a -

800
00:25:52,830 --> 00:25:53,700
0,480
-},|
|

801
00:25:53,790 --> 00:25:56,100
0,900 900,1290 1290,1470 1470,1740 1740,2310
{} {you,know} see here basically
这里 a0 可能放的是 4000 ， 8 是额外的偏移量，

802
00:25:56,100 --> 00:25:59,700
0,480 480,690 690,1380 1380,2010 2670,3600
probably {a0 -} holds 4000

803
00:26:00,000 --> 00:26:01,590
0,360 360,540 540,690 690,1050 1050,1590
and eight is the additional

804
00:26:01,590 --> 00:26:02,850
0,540 570,690 690,810 810,1050 1050,1260
offset,| you know that we're
|我们实际上引用的，这就是错误所在。

805
00:26:02,850 --> 00:26:04,060
0,300 300,810
actually referencing,

806
00:26:05,020 --> 00:26:06,780
0,330 330,570 570,1200
that's the fault.|
|

807
00:26:07,050 --> 00:26:08,070
0,390 390,540 540,720 720,810 810,1020
And now what we like
现在我们想做的是，做一些稍微复杂一点的事。

808
00:26:08,070 --> 00:26:09,030
0,90 90,330 330,480 480,570 570,960
to do, is you know

809
00:26:09,090 --> 00:26:11,310
0,570 570,810 810,1230 1230,1770 1800,2220
{} do something {} slightly

810
00:26:11,310 --> 00:26:13,660
0,540 870,1800
more sophisticated.|
|

811
00:26:13,660 --> 00:26:15,070
0,510 510,960 960,1110 1110,1290 1290,1410
{} Then, we're gonna be
然后，我们要做的是，让我们到 trap.c ，

812
00:26:15,070 --> 00:26:16,810
0,390 660,1050 1050,1320 1320,1620 1620,1740
doing and so let's go

813
00:26:16,810 --> 00:26:18,820
0,150 150,630 1050,1470 1470,1860 1860,2010
to {} {} {trap.c -

814
00:26:18,820 --> 00:26:19,720
0,390
-},|
|

815
00:26:27,280 --> 00:26:29,170
0,870 900,1350 1350,1560 1560,1680 1680,1890
and {} look at {usertrap
查看 usertrap ，这个发生在 usertrap ，

816
00:26:29,170 --> 00:26:30,850
0,510 690,1020 1020,1380 1380,1620 1620,1680
-}, this {happens,in} {usertrap -

817
00:26:30,850 --> 00:26:31,900
0,540
-},|
|

818
00:26:34,600 --> 00:26:35,530
0,270 270,540 540,780 780,870 870,930
{} {usertrap -} is the
usertrap 是 Robert 上周讨论过的函数，

819
00:26:35,530 --> 00:26:37,090
0,300 300,390 390,690 690,1050 1080,1560
function that we, {} Robert

820
00:26:37,090 --> 00:26:38,980
0,120 120,630 630,1170 1170,1380 1380,1890
had discussed a week ago,|
|

821
00:26:39,250 --> 00:26:40,870
0,600 600,870 870,1110 1110,1290 1290,1620
{} and it just goes
它只是对于不同的原因，执行一些操作，

822
00:26:40,870 --> 00:26:42,820
0,240 240,300 300,600 600,1290 1530,1950
through the different causes and

823
00:26:42,820 --> 00:26:44,710
0,450 450,600 600,960 1050,1530 1560,1890
perform some action,| so we're
|所以，这一行是 scause 8 ，

824
00:26:44,740 --> 00:26:45,790
0,30 60,330 330,450 450,870 870,1050
a little bit, here's {},

825
00:26:46,060 --> 00:26:47,350
0,300 300,600 600,750 750,930 930,1290
this line is {scause -}

826
00:26:47,350 --> 00:26:48,520
0,420 420,720 720,810 810,990 990,1170
eight| and you know that's
|就是我们要处理系统调用的点。

827
00:26:48,520 --> 00:26:49,450
0,120 120,420 420,570 570,780 780,930
the point we're going to

828
00:26:49,450 --> 00:26:50,980
0,390 390,630 630,1170
process system calls.|
|

829
00:26:51,360 --> 00:26:52,620
0,390 390,630 630,810 810,870 870,1260
{} Then there's a line
然后，有一行用于检查是否有设备中断，并处理设备中断，

830
00:26:52,620 --> 00:26:53,610
0,180 180,480 480,720 720,810 810,990
that checks whether there was

831
00:26:53,610 --> 00:26:55,650
0,600 600,840 840,1200 1200,1800 1800,2040
any a device interrupt and

832
00:26:55,650 --> 00:26:57,420
0,480 480,780 780,870 870,1380 1380,1770
processes inside of device interrupt,|
|

833
00:26:57,840 --> 00:26:58,770
0,180 180,300 300,510 510,840 840,930
and if there's none of
如果这些都没有发生，我们得到一个 trap ，并杀死进程。

834
00:26:58,770 --> 00:27:00,090
0,240 240,390 390,690 690,840 840,1320
those to happen, then basically

835
00:27:00,090 --> 00:27:01,290
0,180 180,330 330,660 660,720 720,1200
we get this a trap

836
00:27:01,590 --> 00:27:02,520
0,270 270,360 360,690 690,750 750,930
and the process of being

837
00:27:02,520 --> 00:27:03,380
0,390
killed.|
|

838
00:27:03,610 --> 00:27:04,690
0,360 360,720 720,870 870,930 930,1080
And basically what we need
我们需要做的是，

839
00:27:04,690 --> 00:27:06,220
0,60 60,480 510,1050 1050,1290 1290,1530
to do is,| you need
|需要在这里添加一些代码，检查另一种情况，

840
00:27:06,220 --> 00:27:07,360
0,90 90,390 390,570 570,840 840,1140
to add some code here,

841
00:27:07,360 --> 00:27:09,260
0,480 510,780 780,1380
that {you,know} checks

842
00:27:10,010 --> 00:27:11,750
0,330 330,450 450,720 720,1200 1380,1740
{} for another case, right,|
|

843
00:27:11,750 --> 00:27:13,100
0,540 540,660 660,900 900,1110 1110,1350
basically I guess the case
我想我们要做的是，添加一行 if r_scause ，

844
00:27:13,100 --> 00:27:13,940
0,120 120,240 240,390 390,540 540,840
that we want to []

845
00:27:13,940 --> 00:27:15,760
0,420 420,750 750,1260
{a,line} is if

846
00:27:15,760 --> 00:27:17,900
0,300 300,810 810,930 930,1590
{} {r_scause - -},|
|

847
00:27:18,050 --> 00:27:19,160
0,90 90,360 360,510 510,840 840,1110
{[] - -} call it
r_scause 是不是 15 ，

848
00:27:19,190 --> 00:27:20,780
0,210 210,390 420,930
like it's {r_scause

849
00:27:21,020 --> 00:27:22,440
0,240 240,930
- -}

850
00:27:22,530 --> 00:27:23,720
0,630
is

851
00:27:24,450 --> 00:27:25,940
0,990
fifteen,|
|

852
00:27:27,550 --> 00:27:28,300
0,210 210,330 330,390 390,510 510,750
we want to do something
我们想做点别的事。

853
00:27:28,300 --> 00:27:29,300
0,510
else.|
|

854
00:27:32,000 --> 00:27:33,520
0,270 270,390 390,510 510,840
Does that make sense?|
这个能理解吗？|

855
00:27:34,620 --> 00:27:35,190
0,120 120,270 270,360 360,420 420,570
So what do you want
那么，你想在这里做什么，

856
00:27:35,190 --> 00:27:36,320
0,60 60,120 120,570
to do here,|
|

857
00:27:42,130 --> 00:27:42,790
0,210 210,300 300,450 450,540 540,660
what is sort of the
对这些代码，你的计划什么？

858
00:27:42,790 --> 00:27:44,920
0,450 450,810 810,1470 1470,1620 1620,2130
plan for [] for these

859
00:27:45,100 --> 00:27:46,540
0,210 210,390 390,450 450,870
couple lines of code?|
|

860
00:27:50,130 --> 00:27:51,930
0,450 450,870 870,1020 1020,1470 1470,1800
We want to check if
我们可能要检查 p->sz 是不是大于 stval 中的虚拟地址。

861
00:27:52,020 --> 00:27:55,560
0,360 360,1170 1500,2250 2370,3030 3030,3540
{p->sz -} is more than

862
00:27:55,680 --> 00:27:57,540
0,270 270,750 750,1410
the virtual address

863
00:27:57,570 --> 00:27:59,520
0,810 840,1440
that {}

864
00:27:59,780 --> 00:28:03,420
0,660 960,1500 1500,2100 2310,3180
in {stval -}, perhaps.|
|

865
00:28:03,760 --> 00:28:06,180
0,660 750,1860
Yeah, {go,ahead}.|
是的，继续。|

866
00:28:06,480 --> 00:28:07,320
0,270 270,450 450,630 630,750 750,840
Oh, and this is the
然后，我认为做一些像 uvmalloc 做的事情。

867
00:28:07,320 --> 00:28:09,600
0,330 330,780 1140,1470 1470,1860 1860,2280
case then do something like

868
00:28:10,190 --> 00:28:11,580
0,840
{uvmalloc

869
00:28:11,820 --> 00:28:15,080
0,660 750,1140 1170,1980 2010,2700
- - -}, {I,think}.|
|

870
00:28:15,170 --> 00:28:15,920
0,180 180,330 330,510 510,630 630,750
That's one way we could
这是我们可以做的一种方法，

871
00:28:15,920 --> 00:28:17,300
0,120 120,360 420,1110 1110,1290 1290,1380
do it,| {} so I'm
|因为只是一个演示，我会偷懒一下，

872
00:28:17,300 --> 00:28:18,260
0,120 120,180 180,390 390,480 480,960
going to cut some corners

873
00:28:18,260 --> 00:28:19,820
0,300 300,480 480,630 630,1110 1110,1560
just for a demo| and
|在实验里，你需要多做一点工作，

874
00:28:19,850 --> 00:28:21,500
0,510 510,990 1050,1140 1140,1350 1350,1650
presumably in the lab itself,

875
00:28:21,500 --> 00:28:22,040
0,90 90,210 210,360 360,420 420,540
you will need to do

876
00:28:22,040 --> 00:28:22,940
0,30 30,180 180,300 300,540 540,900
a little bit more work,|
|

877
00:28:23,120 --> 00:28:26,030
0,630 630,1290 1440,1830 1830,2280 2670,2910
but basically here's the sort,
但是，这是我们需要的代码片段。

878
00:28:26,030 --> 00:28:27,920
0,120 120,510 540,1020 1020,1470 1500,1890
I think [] code section

879
00:28:27,920 --> 00:28:29,300
0,60 60,330 330,450 450,930
of code, we need.|
|

880
00:28:29,670 --> 00:28:31,660
0,420 420,690 690,930 930,1470
{} So let's see.|
让我们看看。|

881
00:28:32,700 --> 00:28:34,320
0,330 330,420 420,1050
Where I was.|
我在哪里。|

882
00:28:34,410 --> 00:28:35,880
0,30 30,390 390,930
{} Here's usertrap,
这是 usertrap ，让我把它粘贴进去。

883
00:28:37,990 --> 00:28:39,100
0,210 210,330 330,420 420,720 840,1110
{} let me just kind

884
00:28:39,100 --> 00:28:40,640
0,60 60,330 330,600 600,900
of paste into it.|
|

885
00:28:41,230 --> 00:28:42,130
0,240 240,330 330,420 420,570 570,900
And we can look at,
我们可以看看，只有一条用于调试的 print 语句，

886
00:28:42,670 --> 00:28:43,750
0,600 600,720 720,840 840,1020 1020,1080
{} you know just a

887
00:28:43,750 --> 00:28:45,970
0,180 180,570 570,1200 1260,1620 1620,2220
print statement {for,debugging}| and basically
|我们要在这个处理程序里做的是，分配一个物理页。

888
00:28:45,970 --> 00:28:47,200
0,570 570,750 750,810 810,1080 1080,1230
we're going to do in

889
00:28:47,200 --> 00:28:48,640
0,270 270,750 750,870 870,1050 1050,1440
this handler, I'm gonna allocate

890
00:28:48,640 --> 00:28:50,020
0,60 60,360 360,840
a physical page.|
|

891
00:28:50,190 --> 00:28:51,690
0,720 720,900 900,1050 1050,1200 1200,1500
{} If there's no physical
如果没有物理页面，意味着我们内存不足，我们要杀死这个进程，

892
00:28:51,690 --> 00:28:52,800
0,390 390,750 750,930 930,1050 1050,1110
page, mean we're out of

893
00:28:52,800 --> 00:28:54,540
0,420 420,720 1080,1380 1380,1560 1560,1740
memory, {} we're gonna kill

894
00:28:54,540 --> 00:28:57,090
0,120 120,510 510,990 1290,2040 2100,2550
the process for now,| if
|如果有物理页面，我们将页面清零，

895
00:28:57,090 --> 00:28:58,440
0,210 210,240 240,540 540,990 990,1350
there's a physical page, we'll

896
00:28:58,440 --> 00:28:59,820
0,300 300,420 420,930
zero the page,|
|

897
00:28:59,850 --> 00:29:01,350
0,240 240,330 330,510 510,1080 1110,1500
then we just map the
然后，我们只需要将页面映射到用户地址空间中适当的地址，

898
00:29:01,350 --> 00:29:03,750
0,480 480,750 750,1110 1110,1890 1890,2400
page at the appropriate address,

899
00:29:03,780 --> 00:29:06,120
0,180 180,810 1260,2070 2070,2250 2250,2340
in the address space of

900
00:29:06,120 --> 00:29:07,500
0,90 90,630 720,900 900,930 930,1380
the user| in {} particular
|[特别]将其映射到四舍五入的虚拟地址上，

901
00:29:07,500 --> 00:29:09,660
0,300 300,390 390,690 690,1110 1350,2160
map it on the rounded

902
00:29:09,660 --> 00:29:11,760
0,390 390,750 750,1260 1470,1830 1830,2100
down virtual address,| so the
|所以，这里的错误地址是 4008 ，是第五页中的第八个字节，

903
00:29:11,760 --> 00:29:13,830
0,390 390,810 810,1350 1350,1530 1530,2070
faulting address {4008,here - -},

904
00:29:14,070 --> 00:29:15,480
0,600 600,750 750,870 870,1110 1140,1410
{} and so that's eight

905
00:29:15,480 --> 00:29:17,730
0,360 360,1140 1380,1470 1470,1710 1710,2250
bytes into the fifth page|
|

906
00:29:17,880 --> 00:29:18,750
0,210 210,300 300,480 480,540 540,870
and we want to map
我们想要映射这个物理页面到虚拟页面的底部，所以是 4000 ，

907
00:29:18,750 --> 00:29:19,950
0,150 150,510 510,930 930,1140 1140,1200
that physical page at the

908
00:29:19,950 --> 00:29:21,600
0,360 360,480 480,570 570,1020 1260,1650
bottom of the physical, virtual

909
00:29:21,600 --> 00:29:23,240
0,330 330,540 540,660 660,1230
page, so at 4000,|
|

910
00:29:23,530 --> 00:29:25,210
0,420 420,750 750,840 840,1440 1440,1680
rounded down to {4000,then -}
四舍五入到 4000 ，然后将 4000 映射到这个物理页面。

911
00:29:25,210 --> 00:29:26,230
0,120 120,390 390,570 570,870 870,1020
we map {4000 -} to
我们将4000映射到此物理页面。

912
00:29:26,230 --> 00:29:27,600
0,120 120,450 450,870
this physical page.|
|

913
00:29:27,950 --> 00:29:28,670
0,150 150,270 270,450 450,660 660,720
And then of course we
当然，我们还要设置常用的权限位， u 标志位，还有读和写。

914
00:29:28,670 --> 00:29:29,960
0,90 90,180 180,360 360,570 570,1290
have to set the usual

915
00:29:29,960 --> 00:29:31,310
0,390 390,690 690,810 810,1020 1020,1350
permission bits, you know u

916
00:29:31,310 --> 00:29:33,000
0,480 480,600 600,720 720,1140
bit, read and write.|
|

917
00:29:34,140 --> 00:29:35,400
0,120 120,210 210,330 330,720
Does that make sense?|
这能理解吗？|

918
00:29:38,380 --> 00:29:39,160
0,300 300,420 420,600 600,660 660,780
Yeah, I guess I can
我想我可以删掉这一行。

919
00:29:39,160 --> 00:29:40,240
0,270 270,420 420,510 510,660 660,1080
get rid of this line.|
|

920
00:29:42,540 --> 00:29:43,980
0,480 480,750 750,930 930,1230 1230,1440
{} So let's see, let's
让我们看看，试一下。

921
00:29:43,980 --> 00:29:45,340
0,180 180,390 390,840
try it out.|
|

922
00:29:49,750 --> 00:29:51,070
0,420 420,510 510,930 930,1110 1110,1320
And I guess I made
我想，我犯了一些错误。

923
00:29:51,070 --> 00:29:52,480
0,120 120,870
some mistakes.|
|

924
00:29:54,570 --> 00:29:55,500
0,150 150,390 390,660 660,780 780,930
I think that on the
我认为在 else 那里，你在底部没有开始的括号。

925
00:29:55,500 --> 00:29:56,640
0,480 480,600 600,750 750,1020 1020,1140
else, you don't have an

926
00:29:56,640 --> 00:29:58,500
0,360 360,810 810,960 960,1080 1080,1860
opening bracket at the bottom.|
|

927
00:29:59,430 --> 00:30:01,600
0,300 300,1680
Oh yeah,
哦，是的，所以，我需要多一个（括号），哦，是的。

928
00:30:01,970 --> 00:30:03,590
0,420 420,630 630,1200 1230,1470 1470,1620
yeah, so if, I do

929
00:30:03,590 --> 00:30:04,970
0,420 810,960 960,1050 1050,1200 1200,1380
I do I need one

930
00:30:04,970 --> 00:30:06,820
0,390 900,1050 1050,1350
more, oh yeah.|
|

931
00:30:10,340 --> 00:30:11,330
0,180 180,450 450,540 540,810 840,990
Oh, sorry, I mean on
哦，抱歉，我是说在 else 的右边，你没有正确的括号，

932
00:30:11,330 --> 00:30:12,410
0,150 150,480 480,690 690,990 990,1080
the else right here, you

933
00:30:12,410 --> 00:30:14,030
0,150 150,450 450,570 570,960 960,1620
don't have an opening bracket

934
00:30:14,030 --> 00:30:17,000
0,390 870,1620 1650,2310 2310,2640 2640,2970
right,| like when is else
|else 是 printf usertrap unexpected scause 那里的。

935
00:30:17,000 --> 00:30:18,290
0,210 210,480 480,660 660,750 750,1290
{printf -} {usertrap - -}

936
00:30:18,950 --> 00:30:22,180
0,660 660,1440
unexpected scause.|
|

937
00:30:24,580 --> 00:30:26,380
0,120 120,450 450,690 690,1230
And hopefully all [work],
希望都是正常的，太棒了，所以 echo hi 。

938
00:30:27,490 --> 00:30:29,800
0,480 480,810 810,1140 1140,1740
excellent, so echo hi.|
|

939
00:30:29,800 --> 00:30:30,910
0,390 390,570 570,810 810,990 990,1110
Now, of course we're going
现在，我们当然很乐观，希望它能工作，

940
00:30:30,910 --> 00:30:31,900
0,60 60,210 210,630 630,750 750,990
to be optimistic and hope

941
00:30:31,900 --> 00:30:33,100
0,90 90,540 570,960 960,1140 1140,1200
it works,| I'll tell you
|我告诉你这是不能工作的，

942
00:30:33,100 --> 00:30:34,520
0,60 60,300 300,630
it won't work,|
|

943
00:30:34,520 --> 00:30:35,720
0,540 570,750 750,840 840,1020 1020,1200
{} but we did get
但我们确实得到了两个页面错误，

944
00:30:35,720 --> 00:30:36,890
0,90 90,330 330,780 810,1080 1080,1170
two page faults right,| we
|我们得到了页面错误 4008 ，这个是前面看到的，

945
00:30:36,890 --> 00:30:38,360
0,180 180,390 390,600 600,1080 1080,1470
gotta page fault {4008 -},

946
00:30:38,360 --> 00:30:39,530
0,90 90,180 180,630 630,1020 1020,1170
you know primarily {[] -},|
|

947
00:30:39,530 --> 00:30:40,460
0,240 240,360 360,480 480,720 720,930
because we've got another page
[因为]我们又得到了另一个页面错误。

948
00:30:40,460 --> 00:30:41,320
0,360
fault.|
|

949
00:30:41,380 --> 00:30:42,550
0,180 180,300 300,630 630,840 840,1170
And so the only problem
所以我们剩下的问题是 uvmunmap 报错，

950
00:30:42,550 --> 00:30:44,560
0,240 240,720 750,1170 1170,1560 1560,2010
we've left is there's a

951
00:30:44,800 --> 00:30:47,900
0,480 480,990 1440,2100 2100,2580
{uvmunmap -} complaining that,|
|

952
00:30:51,360 --> 00:30:52,170
0,90 90,210 210,570 570,720 720,810
{} as complaining that there
指出一些想要取消映射的页实际上并没有映射。

953
00:30:52,170 --> 00:30:54,750
0,60 60,300 300,750 750,1200 1200,2580
are some page that we're

954
00:30:54,780 --> 00:30:55,860
0,300 300,450 450,720 720,810 810,1080
trying to unmap is actually

955
00:30:55,860 --> 00:30:57,020
0,210 210,630
not mapped.|
|

956
00:30:57,050 --> 00:30:58,340
0,300 300,720 720,870 870,960 960,1290
And what could it be.|
那会是什么呢。|

957
00:31:02,450 --> 00:31:03,440
0,300 300,420 420,570 570,780 780,990
What would you think {if
你认为是什么问题造成这个错误。

958
00:31:03,440 --> 00:31:04,430
0,60 60,180 180,390 390,510 510,990
-} we get this panic.|
|

959
00:31:07,200 --> 00:31:08,540
0,180 180,780
{} Anybody?|
有人知道吗？|

960
00:31:13,620 --> 00:31:14,790
0,240 240,570 570,750 750,900 900,1170
What memories being {unmapped -}
这里取消映射的是最有可能是哪些内存？

961
00:31:14,790 --> 00:31:15,680
0,360
here,

962
00:31:16,190 --> 00:31:17,540
0,270 270,810
most likely.|
|

963
00:31:21,900 --> 00:31:23,460
0,180 180,450 450,570 570,870 870,1560
The one that was lazily
那个懒分配但实际没有分配的。

964
00:31:23,520 --> 00:31:26,580
0,780 810,1080 1080,1440 1440,2160 2430,3060
allocated not actually allocated.| Yeah,
|是的，是懒分配的内存，但实际上还没有分配。

965
00:31:26,580 --> 00:31:28,290
0,540 600,870 870,1110 1110,1380 1380,1710
exactly the memory [] lazily

966
00:31:28,290 --> 00:31:29,640
0,510 510,630 630,930 930,1110 1110,1350
allocated, but actually it hasn't

967
00:31:29,640 --> 00:31:30,960
0,150 150,390 390,750 840,1230 1230,1320
been used yet, right.| And
|所以，对于懒分配的内存，还没有物理页面。

968
00:31:30,960 --> 00:31:31,800
0,120 120,270 270,390 390,540 540,840
so there is no physical

969
00:31:31,800 --> 00:31:33,090
0,270 270,390 390,600 600,960 960,1290
page for that particular lazy

970
00:31:33,090 --> 00:31:33,960
0,420
memory.|
|

971
00:31:34,220 --> 00:31:36,240
0,210 210,750 900,1440
And so, {}
因此，在这种情况下，当 pte 为零时，就是还没有映射，

972
00:31:36,360 --> 00:31:37,560
0,60 90,450 450,810 810,1110 1110,1200
in this case when the

973
00:31:37,560 --> 00:31:39,220
0,390 390,510 510,1140
pte is zero,

974
00:31:39,220 --> 00:31:40,300
0,120 120,300 300,630 630,720 720,1080
you know there's no mapping

975
00:31:40,300 --> 00:31:42,040
0,360 600,810 810,990 990,1230 1230,1740
yet,| that's not really panic,
|这并不是真的错误，这实际上是我们期望的发生的。

976
00:31:42,070 --> 00:31:42,670
0,90 90,210 210,330 330,390 390,600
you know this is actually

977
00:31:42,670 --> 00:31:43,930
0,300 300,420 420,990 990,1050 1050,1260
what we expect you know

978
00:31:43,930 --> 00:31:45,600
0,300 300,720 810,1170
could happen right.|
|

979
00:31:45,770 --> 00:31:46,910
0,540 540,690 690,930 930,1020 1020,1140
And in fact for that
事实上，对于这一页来说，你不需要做任何事，

980
00:31:46,910 --> 00:31:47,900
0,210 210,420 420,810 810,930 930,990
page, you don't have to

981
00:31:47,900 --> 00:31:49,430
0,120 120,510 750,1020 1020,1200 1200,1530
do anything,| you can just
|你可以继续，转到下一页。

982
00:31:49,430 --> 00:31:50,630
0,540 600,660 690,1020 1020,1110 1110,1200
continue to go to the

983
00:31:50,630 --> 00:31:51,840
0,210 210,660
next page.|
|

984
00:31:53,620 --> 00:31:55,000
0,150 150,270 270,420 420,780
Does that make sense?|
这个能理解吗？|

985
00:31:56,000 --> 00:31:57,540
0,180 180,390 390,480 480,990
So let's do that,
那我们就这么做，现在执行 echo hi ，

986
00:31:58,820 --> 00:31:59,660
0,270 270,480 480,540 540,600 600,840
now those are the echo

987
00:31:59,660 --> 00:32:01,220
0,480 690,930 930,1350 1350,1470 1470,1560
hi,| and we've got two
|我们得到两个页面错误，但是 hi （命令）起作用了，

988
00:32:01,220 --> 00:32:02,840
0,210 210,660 660,960 960,1110 1110,1620
page faults, but hi works,|
|

989
00:32:02,900 --> 00:32:05,180
0,180 180,510 510,690 690,1680 1710,2280
and so we're basically {}
所以，我们有了一种非常基本的懒分配方案。

990
00:32:05,660 --> 00:32:07,340
0,540 660,840 840,1350 1380,1590 1590,1680
{} {you,know} have sort of

991
00:32:07,340 --> 00:32:09,980
0,330 330,810 810,1500 1500,2310 2310,2640
a very basic minimal lazy

992
00:32:09,980 --> 00:32:12,020
0,480 480,1020 1050,1560
allocation scheme working.|
|

993
00:32:14,700 --> 00:32:16,420
0,240 240,600 600,810 810,1170
Any questions about this?|
关于这个，有什么问题吗？|

994
00:32:16,820 --> 00:32:18,590
0,600 600,720 720,990 1020,1230 1230,1770
Sorry, I didn't really follow,
抱歉，我没听懂，为什么你可以继续，你能再解释一遍吗？

995
00:32:18,620 --> 00:32:20,030
0,300 300,450 450,570 570,780 780,1410
why you could just continue,

996
00:32:20,240 --> 00:32:21,620
0,510 510,600 600,900 900,1050 1050,1380
could you explain that again.|
|

997
00:32:22,010 --> 00:32:24,380
0,1230 1350,1860
Yeah, so
是的，所以这个 bug 表示我们正在释放未映射的页面。

998
00:32:24,670 --> 00:32:27,010
0,690 1050,1350 1350,1620 1620,2160 2160,2340
the the bug indicated {}

999
00:32:27,010 --> 00:32:28,660
0,180 180,330 330,840 840,1320 1350,1650
that we had were trying

1000
00:32:28,660 --> 00:32:30,340
0,90 90,300 300,960 1080,1440 1440,1680
to free page that actually

1001
00:32:30,340 --> 00:32:31,600
0,90 90,270 270,720
is not mapped.|
|

1002
00:32:32,480 --> 00:32:33,740
0,570 570,690 690,930 930,1110 1110,1260
And you know how could
这是怎么发生的，唯一的原因是，

1003
00:32:33,740 --> 00:32:34,880
0,150 150,540 540,780 780,870 870,1140
that happen, well the only

1004
00:32:34,880 --> 00:32:35,780
0,180 180,300 300,420 420,780 780,900
reason that could happen is|
|

1005
00:32:35,780 --> 00:32:38,630
0,630 810,1350 1350,1590 1590,2130 2310,2850
because {} {sbrk -} moved
因为 sbrk 向上移动了 p->sz ，

1006
00:32:38,630 --> 00:32:40,940
0,180 180,450 450,1110 1350,2040 2070,2310
up {p->sz -},| {} but
|但是这个应用程序从未使用过这个内存，

1007
00:32:40,940 --> 00:32:42,320
0,270 270,720 720,810 810,1170 1170,1380
never used, the application never

1008
00:32:42,320 --> 00:32:43,910
0,360 360,780 810,990 990,1380 1410,1590
used in that memory| and
|所以它实际上还没有映射，因为它没有被分配。

1009
00:32:43,910 --> 00:32:44,960
0,300 300,420 420,690 690,900 900,1050
so it actually has no

1010
00:32:44,960 --> 00:32:46,040
0,390 390,660 660,870 870,930 930,1080
mapping yet, because it was

1011
00:32:46,040 --> 00:32:47,600
0,240 240,540 540,1050
actually not allocated.|
|

1012
00:32:47,660 --> 00:32:49,250
0,390 390,510 510,930 930,1440 1440,1590
Because we're lazily allocating, we're
因为我们是懒分配，只在需要时才为这些页面分配物理内存，

1013
00:32:49,250 --> 00:32:50,870
0,270 270,720 720,1020 1020,1410 1410,1620
only allocating physical memory for

1014
00:32:50,870 --> 00:32:52,340
0,210 210,780 810,1170 1170,1260 1260,1470
those pages when we need

1015
00:32:52,340 --> 00:32:53,540
0,240 510,690 690,780 780,990 990,1200
it,| if we didn't need
|如果我们不需要它，那么就不会有映射，

1016
00:32:53,540 --> 00:32:54,710
0,270 480,810 810,900 900,1080 1080,1170
it, then there will be

1017
00:32:54,710 --> 00:32:55,550
0,150 150,540 540,630 630,720 720,840
no mapping| and so it's
|所以出现这种情况是完全合理的，

1018
00:32:55,550 --> 00:32:56,840
0,300 300,720 720,840 840,990 990,1290
totally reasonable that there actually

1019
00:32:56,840 --> 00:32:57,290
0,90 90,210 210,270 270,360 360,450
is going to be a

1020
00:32:57,290 --> 00:33:00,020
0,600 750,1740 1800,2100 2100,2280 2280,2730
case| where there's no mapping
|虚拟地址还没有映射，因为他们实际上还没有被分配。

1021
00:33:00,020 --> 00:33:01,160
0,120 120,180 180,510 510,870 870,1140
for {} virtual address, because

1022
00:33:01,160 --> 00:33:02,690
0,150 150,420 420,750 750,1200 1200,1530
they're actually wasn't allocated yet.|
|

1023
00:33:03,130 --> 00:33:04,720
0,480 480,690 690,870 870,1350 1350,1590
And for that case, we
这种情况下，我们什么都不用做，

1024
00:33:04,720 --> 00:33:05,710
0,180 180,360 360,450 450,570 570,990
just have to do nothing,|
|

1025
00:33:05,830 --> 00:33:06,860
0,90 90,510
you know,
我们可以释放这一页，但是没有页面要释放，

1026
00:33:06,980 --> 00:33:08,120
0,450 480,630 630,900 900,1050 1050,1140
{} we can free the

1027
00:33:08,120 --> 00:33:09,110
0,330 330,600 600,720 720,810 810,990
page, but there is no

1028
00:33:09,110 --> 00:33:10,250
0,180 180,600 840,990 990,1080 1080,1140
free page,| and so the
|所以，最好的办法就是继续，转到循环的中的下一页。

1029
00:33:10,250 --> 00:33:11,480
0,210 210,360 360,570 570,720 720,1230
best thing is to continue

1030
00:33:11,480 --> 00:33:12,110
0,150 150,300 300,420 420,540 540,630
and just go to the

1031
00:33:12,110 --> 00:33:13,040
0,210 210,480 480,570 570,660 660,930
next page in the loop.|
|

1032
00:33:14,380 --> 00:33:16,030
0,450 480,600 600,780 780,1260 1470,1650
Okay, that makes sense, thank
好的，理解了，谢谢。

1033
00:33:16,030 --> 00:33:16,860
0,420
you.|
|

1034
00:33:16,920 --> 00:33:18,330
0,210 210,480 480,750 750,870 870,1410
Yeah, {if,we} didn't do continue,
是的，如果我们不是继续，但是继续往前，

1035
00:33:18,330 --> 00:33:20,340
0,150 150,900 900,990 990,1290 1650,2010
but basically you know just

1036
00:33:20,340 --> 00:33:21,480
0,180 180,510 510,810 810,960 960,1140
kept going,| then we would
|然后我们可以创建一个页面，这样你就可以释放这个页面了，

1037
00:33:21,480 --> 00:33:22,470
0,210 210,360 360,420 420,810 810,990
actually create a page that

1038
00:33:22,470 --> 00:33:23,460
0,90 90,420
would be

1039
00:33:23,460 --> 00:33:24,390
0,60 60,210 210,360 360,870 870,930
you can do free the

1040
00:33:24,390 --> 00:33:26,640
0,330 1350,1620 1620,1770 1770,1860 1860,2250
page,| that's why it continues
|这就是为什么这里是继续。

1041
00:33:26,640 --> 00:33:27,460
0,270
there.|
|

1042
00:33:27,550 --> 00:33:28,760
0,240 240,660
Make sense.|
理解了。|

1043
00:33:30,770 --> 00:33:33,820
0,270 270,630 630,1290 1830,2370
{} Another question,| in
我也有一个问题，|在 uvmunmap 中，我认为 panic 是有原因的，

1044
00:33:34,040 --> 00:33:36,050
0,690 690,870 870,1350 1560,1680 1680,2010
{uvmunmap - -}, I assumed

1045
00:33:36,050 --> 00:33:37,370
0,150 150,570 570,960 990,1140 1140,1320
the panic was that was

1046
00:33:37,370 --> 00:33:38,690
0,540 660,870 870,1080 1080,1230 1230,1320
there was there for a

1047
00:33:38,690 --> 00:33:41,120
0,480 690,1170 1170,1530 1560,1890 1890,2430
reason,| so a more correct
|所以，更合理的实现是使用两个版本，

1048
00:33:41,150 --> 00:33:42,980
0,210 210,480 480,930 930,1710 1710,1830
a more reasonable implementation is

1049
00:33:42,980 --> 00:33:44,780
0,90 90,300 300,540 540,1440 1650,1800
to have two versions| and
|然后我们使用不会 panic 的那个。

1050
00:33:44,780 --> 00:33:45,350
0,90 90,210 210,360 360,420 420,570
we would use the one

1051
00:33:45,350 --> 00:33:46,740
0,120 120,390 390,810
that doesn't panic.|
|

1052
00:33:47,090 --> 00:33:49,670
0,510 510,1110 1110,1350 1350,1470 1470,2580
Yeah, because why was the
是的，因为为什么会 panic ，

1053
00:33:49,670 --> 00:33:50,750
0,180 180,660 660,870 870,930 930,1080
the panic,| while it was
|它是一个不变量，对于未修改的 xv6 来说，这是正确的，

1054
00:33:50,750 --> 00:33:52,910
0,420 420,540 540,1350 1770,2010 2010,2160
basically an invariant {} that

1055
00:33:52,910 --> 00:33:54,350
0,180 180,240 240,360 360,930 960,1440
used to be true for

1056
00:33:54,380 --> 00:33:57,800
0,660 660,1410 1890,2340 2340,2940 2940,3420
unmodified xv6,| actually unmodified xv6
|实际上，未修改的 xv6 永远不应该存在用户内存未映射的情况。

1057
00:33:57,800 --> 00:33:58,760
0,180 180,450 450,600 600,690 690,960
should never have a case

1058
00:33:58,760 --> 00:34:00,080
0,330 330,600 600,900 900,1200 1200,1320
where those user memory that

1059
00:34:00,080 --> 00:34:01,160
0,120 120,270 270,660
was not map.|
|

1060
00:34:01,500 --> 00:34:02,520
0,180 180,300 300,570 570,870 870,1020
And so therefore {the,panic} goes
所以，出现了 panic ，

1061
00:34:02,520 --> 00:34:04,260
0,300 600,810 810,1020 1020,1590 1590,1740
up,| we now change the
|我们现在修改了 xv6 的设计，

1062
00:34:04,260 --> 00:34:05,850
0,420 420,510 510,1230 1290,1500 1500,1590
design of xv6,| so we
|所以我们必须调整，这个不变量不再是真的，

1063
00:34:05,850 --> 00:34:07,620
0,120 120,180 180,810 1050,1650 1650,1770
have to adjust {} and

1064
00:34:07,620 --> 00:34:08,970
0,150 150,210 210,570 570,810 810,1350
this {} invariant is no

1065
00:34:08,970 --> 00:34:10,410
0,300 300,750 960,1200 1200,1320 1320,1440
longer true,| so we've got
|所以我们必须消除 panic ，

1066
00:34:10,410 --> 00:34:11,730
0,120 120,420 420,510 510,840 840,1320
to remove the panic| and
|因为那个不变量不再是真的，合理地，不再是真的。

1067
00:34:12,420 --> 00:34:13,680
0,480 480,720 720,810 810,1140 1140,1260
{} because that invariant is

1068
00:34:13,680 --> 00:34:14,900
0,180 180,330 330,660
just not true,

1069
00:34:17,040 --> 00:34:19,880
0,1440 1470,1710 1710,1920 1920,2310
legitimately not true anymore.|
|

1070
00:34:20,290 --> 00:34:22,560
0,420 420,570 570,960 960,1440
{} I see, thanks.|
我明白了，谢谢。|

1071
00:34:23,880 --> 00:34:25,100
0,150 150,300 300,630
That makes sense?|
这能理解吗？|

1072
00:34:26,300 --> 00:34:28,220
0,330 330,900 1170,1410 1410,1650 1650,1920
So, {} so a couple
所以，有几条[评论]，

1073
00:34:28,220 --> 00:34:31,340
0,690 690,1380 2370,2670 2670,2850 2850,3120
comments,| {} this will hopefully
|希望这对下一个实验有帮助，

1074
00:34:31,340 --> 00:34:32,900
0,180 180,210 210,510 510,810 810,1560
help a lot with {}

1075
00:34:32,930 --> 00:34:34,280
0,480 480,810 810,930 930,1200 1200,1350
next lab,| in fact this
|实际上，这是下一个实验的三个组成部分之一，

1076
00:34:34,280 --> 00:34:35,450
0,120 120,480 480,570 570,960 990,1170
is one of the three

1077
00:34:35,450 --> 00:34:37,040
0,420 420,510 510,600 600,1110 1140,1590
components of the lab, of

1078
00:34:37,040 --> 00:34:38,360
0,120 120,330 330,930 930,1140 1140,1320
the next lab,| {} one
|是你必须做的第一件事，

1079
00:34:38,360 --> 00:34:38,960
0,60 60,150 150,360 360,510 510,600
of the first things you

1080
00:34:38,960 --> 00:34:40,970
0,120 120,210 210,540 870,1680 1710,2010
have to do| and hopefully
|希望这能帮你节省一些时间，

1081
00:34:40,970 --> 00:34:41,600
0,120 120,240 240,420 420,510 510,630
this will save you some

1082
00:34:41,600 --> 00:34:43,700
0,510 810,1320 1320,1530 1530,1680 1680,2100
time,| maybe make up for
|或许可以降低你在页面错误实验的痛苦。

1083
00:34:43,820 --> 00:34:44,660
0,300 300,390 390,630 630,750 750,840
all the pain that you

1084
00:34:44,660 --> 00:34:46,610
0,210 210,690 720,1530 1530,1800 1800,1950
went through {} in the

1085
00:34:46,610 --> 00:34:48,260
0,540 540,960 990,1350
{page,fault} {} lab.|
|

1086
00:34:48,760 --> 00:34:50,800
0,420 540,1080 1080,1440 1440,1650 1650,2040
{} But clearly not enough
但显然还不够，

1087
00:34:50,830 --> 00:34:51,820
0,360 360,480 480,630 630,750 750,990
right,| yeah, so like what
|很多东西是，

1088
00:34:51,820 --> 00:34:53,720
0,270 270,900 930,1050 1050,1320
things are,| you know,
|我们做了一些改变，

1089
00:34:54,000 --> 00:34:54,900
0,120 120,300 300,450 450,780 780,900
we made these changes,| but
|但可能还有更多的东西被破坏。

1090
00:34:54,900 --> 00:34:56,190
0,120 120,360 360,360 360,900 900,1290
more things are still probably

1091
00:34:56,190 --> 00:34:57,240
0,480
broken.|
|

1092
00:35:01,090 --> 00:35:02,380
0,150 150,390 390,660 660,810 810,1290
{} One already was mentioned,|
已经提到的一个是，|

1093
00:35:02,410 --> 00:35:03,160
0,120 120,330 330,570 570,660 660,750
I actually didn't do it
我没有检查虚拟地址是否低于 p->sz ，

1094
00:35:03,160 --> 00:35:04,540
0,60 60,480 480,810 810,1170 1170,1380
to check whether actually the

1095
00:35:04,540 --> 00:35:06,310
0,330 330,840 1110,1290 1290,1590 1590,1770
virtual address was below {p->sz

1096
00:35:06,310 --> 00:35:07,780
0,390 390,930 930,1050 1050,1350 1350,1470
-}| which we probably should
|这是我们应该做的。

1097
00:35:07,780 --> 00:35:08,620
0,360
do.|
|

1098
00:35:08,840 --> 00:35:09,710
0,240 240,390 390,600 600,720 720,870
Any other things that might
还有什么东西可能被破坏了吗？

1099
00:35:09,710 --> 00:35:10,840
0,90 90,540
be broken?|
|

1100
00:35:17,560 --> 00:35:18,740
0,660
Anybody?|
有人知道吗？|

1101
00:35:25,020 --> 00:35:26,670
0,690 690,840 840,1260 1260,1380 1380,1650
Number of bytes to grow
通过 sbrk 增加的进程字节数，是一个整型而不是无符号整型，

1102
00:35:26,670 --> 00:35:28,290
0,120 120,570 570,960 960,1170 1170,1620
the process by {sbrk -}

1103
00:35:28,320 --> 00:35:29,340
0,180 180,330 330,720 720,810 810,1020
is an int and not

1104
00:35:29,340 --> 00:35:31,140
0,90 90,600 600,840 840,1380 1410,1800
an unsigned int,| so negative
|所以可以使用负数。

1105
00:35:31,140 --> 00:35:33,140
0,480 480,720 720,840 840,1380
numbers could be used.|
|

1106
00:35:33,560 --> 00:35:34,730
0,300 300,390 390,840 840,1080 1080,1170
Yes, and negative numbers can
是的，可以使用负数，这意味着缩小地址空间，

1107
00:35:34,730 --> 00:35:35,750
0,180 180,270 270,390 390,600 600,1020
use and that means shrinking

1108
00:35:35,750 --> 00:35:37,190
0,90 90,360 360,840 1230,1380 1380,1440
the address space,| so if
|所以如果我们缩小地址空间，

1109
00:35:37,190 --> 00:35:38,120
0,90 90,360 360,450 450,690 690,930
we shrink the address space,|
|

1110
00:35:38,120 --> 00:35:38,780
0,120 120,330 330,480 480,540 540,660
we also have to be
我们也要小心一点。

1111
00:35:38,780 --> 00:35:40,080
0,60 60,270 270,750
a little careful.|
|

1112
00:35:40,110 --> 00:35:41,010
0,330 330,480 480,540 540,750 750,900
{} So it turns out
所以在操作系统中有很多不同的情况，

1113
00:35:41,010 --> 00:35:42,270
0,150 150,240 240,630 630,930 930,1260
there's a whole bunch of,

1114
00:35:42,270 --> 00:35:43,770
0,150 150,780 840,1290 1290,1410 1410,1500
as usual, {} in an

1115
00:35:43,770 --> 00:35:44,640
0,300 300,600 600,690 690,750 750,870
operating system and a whole

1116
00:35:44,640 --> 00:35:45,750
0,150 150,210 210,450 450,870 870,1110
bunch of different cases, right,|
|

1117
00:35:45,750 --> 00:35:47,790
0,330 330,810 960,1740 1770,1980 1980,2040
where which we're going to
在那里，我们要查看这个页表条目，

1118
00:35:47,790 --> 00:35:49,020
0,60 60,420 420,630 630,870 870,1230
be looking at this particular

1119
00:35:49,020 --> 00:35:50,490
0,180 180,450 450,870 1110,1380 1380,1470
{pagetable -} entry| and for
|对于所有这些不同的情况，我们可能需要修改 xv6 。

1120
00:35:50,490 --> 00:35:51,570
0,90 90,240 240,480 480,930 930,1080
all those different cases we

1121
00:35:51,570 --> 00:35:52,740
0,240 240,510 510,630 630,690 690,1170
might actually have to modify

1122
00:35:52,740 --> 00:35:54,200
0,150 150,420 420,990
{xv6 -} slightly.|
|

1123
00:35:54,290 --> 00:35:56,090
0,630 630,930 930,1290 1290,1470 1470,1800
And that's exactly what basically
这正是实验的目的所在，

1124
00:35:56,090 --> 00:35:57,350
0,90 90,360 360,450 450,900 900,1260
the lab is about| is
|要做得足够好，你需要通过 usertests 。

1125
00:35:57,350 --> 00:35:58,610
0,90 90,360 420,840 840,1020 1020,1260
you know doing good enough

1126
00:35:58,610 --> 00:35:59,630
0,390 390,480 480,810 810,930 930,1020
job that basically you can

1127
00:35:59,630 --> 00:36:01,060
0,300 300,510 510,1020
pass {usertests -}.|
|

1128
00:36:01,060 --> 00:36:02,500
0,300 300,990 990,1230 1230,1290 1290,1440
Usertests will stress a whole
usertests 会有很多你需要处理的情况。

1129
00:36:02,500 --> 00:36:03,850
0,180 180,240 240,750 750,1140 1140,1350
bunch of other cases that

1130
00:36:03,850 --> 00:36:04,720
0,300 300,450 450,600 600,660 660,870
you will need to deal

1131
00:36:04,720 --> 00:36:05,560
0,300
with.|
|

1132
00:36:07,550 --> 00:36:08,660
0,600
Okay?|
好吧?|

1133
00:36:11,340 --> 00:36:12,960
0,300 300,600 600,690 690,1110
Any questions so far?|
目前为止，有什么问题吗？|

1134
00:36:18,300 --> 00:36:19,590
0,210 210,360 360,630 630,1140 1200,1290
Okay, let me {},| in
好的，让我，|我想讲一下其他用途或你可以做的很酷的事情，

1135
00:36:19,590 --> 00:36:20,400
0,120 120,450 450,570 570,720 720,810
that case I want to

1136
00:36:20,400 --> 00:36:21,300
0,180 180,360 360,420 420,630 630,900
talk about a bunch of

1137
00:36:21,300 --> 00:36:25,020
0,630 630,1590 1890,2670 2670,2850 2850,3720
other {} usages or cool

1138
00:36:25,050 --> 00:36:26,610
0,750 750,840 840,930 930,1230 1230,1560
things you can do| once
|一旦你有了页面错误，页表可以动态更新。

1139
00:36:26,610 --> 00:36:28,080
0,300 300,660 660,900 900,1260 1260,1470
you have page faults and

1140
00:36:28,080 --> 00:36:30,060
0,240 240,600 600,630 1050,1470 1470,1980
{pagetables -} are updated dynamically.|
|

1141
00:36:30,870 --> 00:36:32,670
0,540 780,1110 1110,1290 1290,1440 1440,1800
{} Another one that is
另一个几乎是微不足道的，但是经常使用的，

1142
00:36:32,910 --> 00:36:35,460
0,480 480,1020 1260,2010 2040,2400 2400,2550
almost trivial, {} but you

1143
00:36:35,460 --> 00:36:38,430
0,60 60,540 540,1050 1350,2130 2130,2970
know commonly used {}| is
|就是按需补零。

1144
00:36:38,460 --> 00:36:41,320
0,270 270,780 840,1650 1650,2250
what's called zero filled,

1145
00:36:42,260 --> 00:36:44,740
0,900 1170,1860
zero fill

1146
00:36:45,190 --> 00:36:46,660
0,360 360,870
on demand.|
|

1147
00:36:51,300 --> 00:36:53,040
0,750 750,1020 1020,1290 1290,1500 1500,1740
{} It turns out that
事实上，在操作系统中，有很多空页。

1148
00:36:53,040 --> 00:36:55,590
0,1230 1290,1770 1770,2340 2340,2430 2430,2550
in operating systems, you know

1149
00:36:55,590 --> 00:36:56,880
0,120 120,180 180,510 510,750 750,1290
there are many null pages.|
|

1150
00:36:58,140 --> 00:36:59,670
0,660 690,990 990,1110 1110,1170 1170,1530
And, {} so, for example
如果你查看用户地址空间，

1151
00:36:59,670 --> 00:37:00,480
0,60 60,180 180,360 360,450 450,810
if you look at the

1152
00:37:01,060 --> 00:37:02,710
0,540 540,930 930,1290 1290,1380 1380,1650
{} address space in user

1153
00:37:02,710 --> 00:37:05,530
0,600 780,1440 1920,2370 2370,2610 2610,2820
space,| {} {xv6 -} doesn't
|xv6 并不是很[先进]，

1154
00:37:05,530 --> 00:37:07,450
0,600 600,720 720,1230 1230,1290 1320,1920
really is not as [advanced],|
|

1155
00:37:07,450 --> 00:37:08,740
0,690 690,930 930,1050 1050,1200 1200,1290
but if you look at
如果你看一下二进制文件的布局，

1156
00:37:08,740 --> 00:37:10,450
0,90 90,540 540,690 690,930 930,1710
the layout of a binary,|
|

1157
00:37:10,660 --> 00:37:11,950
0,540 540,540 540,870 870,990 990,1290
{} I mean {[] -},|
我的意思是，|

1158
00:37:11,950 --> 00:37:13,060
0,60 60,150 150,360 360,480 480,1110
you know there's some text,
这有一些文本，这有数据段，

1159
00:37:13,150 --> 00:37:14,170
0,300 300,480 480,690 690,750 750,1020
there's what's called the data

1160
00:37:14,170 --> 00:37:16,300
0,570 900,1260 1260,1470 1470,1860 1860,2130
segment| and there's typically also
|而且通常还有所谓的 BSS 段。

1161
00:37:16,300 --> 00:37:17,320
0,210 210,510 510,720 720,930 930,1020
what something is called the

1162
00:37:17,320 --> 00:37:18,800
0,540 540,1050
BSS segment.|
|

1163
00:37:20,170 --> 00:37:21,760
0,720 780,1200 1230,1410 1410,1530 1530,1590
{} And so when the
所以，当编译器生成二进制文件时，

1164
00:37:21,760 --> 00:37:24,880
0,630 660,1500 1500,2490 2520,3030 3030,3120
compiler produces a binary,| you
|基本上填充这三个部分，

1165
00:37:24,880 --> 00:37:25,840
0,150 150,450 450,720 720,780 780,960
know basically fills in these

1166
00:37:25,840 --> 00:37:27,550
0,240 240,810 990,1170 1170,1620 1620,1710
three segments,| the text you
|文本是指令，

1167
00:37:27,550 --> 00:37:28,750
0,90 90,210 210,930 930,1080 1080,1200
know the instructions,| {you,know} the
|数据是全局变量，它的值不是零，所以是初始化数据。

1168
00:37:28,750 --> 00:37:30,640
0,300 300,630 630,1050 1050,1350 1350,1890
data is basically global variables,

1169
00:37:30,640 --> 00:37:32,080
0,120 120,420 420,660 660,720 720,1440
that actually have a value

1170
00:37:32,140 --> 00:37:33,520
0,180 180,240 240,480 480,960
that is not zero,

1171
00:37:33,580 --> 00:37:36,520
0,240 240,390 390,1260 1260,2370
so {} initialized data.|
|

1172
00:37:41,860 --> 00:37:43,480
0,360 360,1080 1080,1200 1200,1560 1560,1620
In BBS, is basically a
在 BBS 里，是一种描述，

1173
00:37:43,480 --> 00:37:45,430
0,600 630,810 810,1290 1410,1830 1830,1950
description,| that says well there's
|说明这里有很多变量，

1174
00:37:45,430 --> 00:37:46,540
0,30 30,150 150,330 330,390 390,1110
a whole bunch of variables|
|

1175
00:37:46,690 --> 00:37:48,790
0,510 510,900 900,1260 1260,1410 1410,2100
and it's basically their sizes
它们的大小，它们应该都是零。

1176
00:37:48,850 --> 00:37:49,480
0,150 150,210 210,360 360,510 510,630
and they all should be

1177
00:37:49,480 --> 00:37:50,480
0,480
zero.|
|

1178
00:37:51,010 --> 00:37:52,090
0,420 420,570 570,630 630,930 930,1080
{} And the reason that
它们没有被列出来的原因是，

1179
00:37:52,090 --> 00:37:53,590
0,270 270,390 390,810 810,1140 1140,1500
they are basically not listed

1180
00:37:53,590 --> 00:37:54,670
0,480 510,600 600,810 810,990 990,1080
out,| you know or the
|或者这些内存不在文件中，

1181
00:37:54,670 --> 00:37:56,200
0,570 570,900 900,1110 1110,1320 1320,1530
memory is not right there

1182
00:37:56,200 --> 00:37:57,220
0,120 120,210 210,600 600,870 870,1020
in the files,| because it
|因为这会节省大量的，

1183
00:37:57,220 --> 00:37:58,360
0,300 300,750 750,870 870,1080 1080,1140
will save a lot of|
|

1184
00:37:58,360 --> 00:37:59,500
0,150 210,630 630,690 690,750 750,1140
for example, if you declare
比如，如果你在 C 中声明一个大矩阵，

1185
00:37:59,500 --> 00:38:01,600
0,210 210,660 660,900 900,1410 1650,2100
big matrix in C,| on
|文件顶部是一个全局变量，

1186
00:38:01,600 --> 00:38:02,380
0,90 90,270 270,360 360,450 450,780
the top of the file

1187
00:38:02,380 --> 00:38:03,520
0,60 60,120 120,360 360,900 900,1140
is a global variable| and
|它会自动将属性设置为零，

1188
00:38:03,520 --> 00:38:06,640
0,270 300,930 930,1410 1410,2100 2280,3120
it's automatically attribute zeros,| why
|为什么要分配文件中的所有空间，

1189
00:38:06,640 --> 00:38:07,870
0,480 480,600 600,720 720,1110 1110,1230
allocate all the space in

1190
00:38:07,870 --> 00:38:09,370
0,90 90,630 720,990 990,1320 1320,1500
the file,| {} just like
|就像是，对于内容中的这个变量，应该是零。

1191
00:38:09,370 --> 00:38:10,450
0,360 360,480 480,900 900,990 990,1080
no that basically you know

1192
00:38:10,450 --> 00:38:12,400
0,120 120,270 270,720 720,1380 1680,1950
for this particular variable in

1193
00:38:12,430 --> 00:38:14,080
0,120 120,480 480,690 690,1020 1140,1650
the content should be zero.|
|

1194
00:38:15,320 --> 00:38:16,940
0,150 150,690 690,900 900,1380 1410,1620
And amazingly on exec, on
令人惊讶的是，在普通操作系统的 exec 上，

1195
00:38:16,940 --> 00:38:18,200
0,60 60,420 420,720 720,1110 1110,1260
a normal operating system on

1196
00:38:18,200 --> 00:38:19,700
0,450 720,1050 1050,1260 1260,1320 1320,1500
exec,| we'll look at these
|我们来看看这三个部分，

1197
00:38:19,700 --> 00:38:21,700
0,510 780,1440
three {}

1198
00:38:21,730 --> 00:38:24,370
0,780 1020,1590 1590,2160 2160,2490 2490,2640
{} segments,| [] usual thing
|像 xv6 对文本和数据做的操作，

1199
00:38:24,370 --> 00:38:25,810
0,150 150,390 390,660 660,1230 1230,1440
that {xv6 -} does for

1200
00:38:25,810 --> 00:38:27,220
0,300 300,420 420,870 960,1290 1290,1410
text and data,| but for
|但是对 BSS ，它会分配内存来保存 BSS ，并将其置零。

1201
00:38:27,220 --> 00:38:29,380
0,810 990,1290 1290,1470 1470,2100 2100,2160
BSS, it will allocate you

1202
00:38:29,380 --> 00:38:31,120
0,300 300,1110 1350,1440 1440,1680 1680,1740
know memory to hold the

1203
00:38:31,120 --> 00:38:33,250
0,720 840,1170 1170,1530 1530,1800 1800,2130
BSS and basically stick zeroes

1204
00:38:33,250 --> 00:38:34,120
0,150 150,420
in there.|
|

1205
00:38:34,120 --> 00:38:35,080
0,420
So,
所以，分配地址空间，其中有数据，

1206
00:38:35,330 --> 00:38:36,480
0,570
{}

1207
00:38:36,480 --> 00:38:38,730
0,480 480,780 780,1290 1290,1590 1590,2250
allocated address space takes data

1208
00:38:38,910 --> 00:38:40,800
0,420 690,1230 1230,1350 1350,1650 1650,1890
in it| and then we're
|然后我们查看，这个相当于 BSS ，

1209
00:38:40,800 --> 00:38:43,260
0,630 930,1470
basically {look,at},

1210
00:38:43,990 --> 00:38:45,040
0,180 180,660 660,720 720,810 810,1050
the equivalent of the BSS,|
|

1211
00:38:45,040 --> 00:38:46,510
0,390 390,600 600,660 660,960 960,1470
{you,know} all the global variables
所有的全局变量都是零，

1212
00:38:46,510 --> 00:38:47,710
0,120 120,480 480,780 780,960 960,1200
that basically zero| and maybe
|也许还有很多很多页，

1213
00:38:47,710 --> 00:38:49,320
0,240 240,480 480,1080
many many pages,|
|

1214
00:38:51,540 --> 00:38:52,560
0,150 150,240 240,420 420,690 690,1020
and all those pages basically
所有这些页内容都是零，

1215
00:38:52,560 --> 00:38:53,400
0,180 180,240 240,420 420,480 480,840
have to have the content

1216
00:38:53,400 --> 00:38:54,380
0,480
zero,|
|

1217
00:38:55,570 --> 00:38:56,530
0,150 150,300 300,420 420,750 750,960
so that's the virtual address
这就是虚拟地址空间。

1218
00:38:56,530 --> 00:38:58,240
0,480 480,600 600,840 840,1260 1260,1710
space.| And so typical trick,
|所以，一般的技巧是，

1219
00:38:58,270 --> 00:38:58,960
0,90 90,210 210,300 300,570 570,690
you know, to do is|
|

1220
00:38:58,960 --> 00:39:00,070
0,90 90,240 240,420 420,900 930,1110
to say like wow, I've
有很多的页面需要是零，

1221
00:39:00,070 --> 00:39:01,030
0,120 120,270 270,450 450,810 810,960
got so many pages that

1222
00:39:01,030 --> 00:39:02,170
0,180 180,240 240,390 390,870 900,1140
need to have zero,| what
|我要在物理内存中做的是，

1223
00:39:02,170 --> 00:39:03,820
0,90 90,270 270,750 840,1140 1140,1650
I'm gonna do in physical

1224
00:39:03,820 --> 00:39:04,840
0,510
memory,|
|

1225
00:39:05,160 --> 00:39:06,330
0,270 270,360 360,480 480,900 900,1170
this is the virtual address
这是虚拟地址空间和物理地址内存，

1226
00:39:06,330 --> 00:39:08,550
0,450 990,1200 1200,1320 1320,1650 1650,2220
space and the physical address

1227
00:39:08,580 --> 00:39:10,620
0,810 1080,1350 1350,1530 1530,1620 1620,2040
memory,| {} what I'm gonna
|我要做的是，你可以分配一个零页，把它填满零，

1228
00:39:10,620 --> 00:39:11,700
0,180 180,480 690,900 900,1020 1020,1080
do is you're going to

1229
00:39:11,700 --> 00:39:14,060
0,450 450,1050 1050,1380 1380,1860
allocate one zero page,

1230
00:39:14,410 --> 00:39:15,430
0,150 150,270 270,360 360,450 450,1020
and fill it with zeros,|
|

1231
00:39:15,610 --> 00:39:17,170
0,120 120,480 480,1080 1110,1440 1440,1560
and basically map all the
然后把所有其他页面（需要是零的）都映射到这一页。

1232
00:39:17,170 --> 00:39:18,500
0,180 180,780
other pages

1233
00:39:18,650 --> 00:39:20,180
0,240 240,480 480,990
{to,that} one page.|
|

1234
00:39:24,200 --> 00:39:25,310
0,120 120,180 180,510 510,1050 1050,1110
You know saving myself, you
这节省了很多物理内存，至少在开始阶段。

1235
00:39:25,310 --> 00:39:26,420
0,120 120,570
know lots

1236
00:39:26,450 --> 00:39:27,410
0,180 180,390 420,630 630,690 690,960
you know, lots of physical

1237
00:39:27,410 --> 00:39:28,310
0,270 270,360 360,540 540,630 630,900
memory, at least at start

1238
00:39:28,310 --> 00:39:29,120
0,270
up.|
|

1239
00:39:29,520 --> 00:39:31,020
0,480 780,930 930,1110 1110,1200 1200,1500
And of course those mappings
当然，这些映射必须是特殊对待，

1240
00:39:31,020 --> 00:39:32,190
0,180 180,270 270,420 420,690 690,1170
has to be limit care,

1241
00:39:32,400 --> 00:39:34,170
0,600 600,660 660,1170 1200,1440 1440,1770
{dominate -} care,| we can't
|我们不允许对它写入，

1242
00:39:34,170 --> 00:39:35,760
0,510 510,690 690,1200 1200,1260 1260,1590
{}, you know we cannot

1243
00:39:35,760 --> 00:39:37,230
0,270 270,510 510,930 960,1260 1260,1470
allow write {to,it} right,| because
|因为每个页都依赖于它保持为零，

1244
00:39:37,230 --> 00:39:38,400
0,450 450,780 780,840 840,930 930,1170
everybody's relying on the fact

1245
00:39:38,400 --> 00:39:39,900
0,210 210,510 510,780 780,1260 1290,1500
that actually stays zero,| so
|所以，我们把它映射为只读。

1246
00:39:39,900 --> 00:39:41,040
0,90 90,240 240,510 510,750 840,1140
we just map it read

1247
00:39:41,040 --> 00:39:41,900
0,360
only.|
|

1248
00:39:43,440 --> 00:39:44,580
0,180 180,390 390,480 480,630 630,1140
And then, at some point,
然后，在某个时候，当应用程序开始写入，

1249
00:39:44,700 --> 00:39:46,920
0,210 210,300 300,1170 1350,1680 1680,2220
when an application starts writing

1250
00:39:46,920 --> 00:39:47,640
0,120 120,330 330,450 450,570 570,720
to one of| you know
|开始加载或保存 BSS 中的页面，

1251
00:39:47,640 --> 00:39:48,930
0,300 360,750 750,1110 1110,1230 1230,1290
that basically started as a

1252
00:39:48,930 --> 00:39:50,430
0,630 630,780 780,900 900,1380 1380,1500
loader and in store, if

1253
00:39:50,430 --> 00:39:52,110
0,240 240,360 360,630 960,1530 1530,1680
one of the pages that

1254
00:39:52,110 --> 00:39:53,700
0,360 360,660 660,750 750,840 840,1590
actually part of the BSS,|
|

1255
00:39:53,940 --> 00:39:55,470
0,660 660,870 870,1230 1230,1320 1320,1530
{} so because he wants
因为它想在那里保存内存，

1256
00:39:55,470 --> 00:39:57,060
0,90 90,420 420,810 840,1230 1230,1590
you to whatever store one

1257
00:39:57,060 --> 00:39:58,650
0,180 180,390 390,750 750,1230 1230,1590
or two there content there,|
|

1258
00:39:58,770 --> 00:39:59,640
0,390 390,450 450,570 570,630 630,870
{we'll,going} to get a page
我们会得到页面错误。

1259
00:39:59,640 --> 00:40:00,420
0,360
fault.|
|

1260
00:40:06,240 --> 00:40:07,170
0,480 480,600 600,750 750,870 870,930
And so what should we
那么，在这种情况下，我们应该如何处理页面错误呢？

1261
00:40:07,170 --> 00:40:08,070
0,150 150,240 240,300 300,510 510,900
do on the page fault,

1262
00:40:10,560 --> 00:40:12,120
0,150 150,270 270,600 600,1050
in this particular case.|
|

1263
00:40:15,170 --> 00:40:16,300
0,600
Anybody?|
有人知道吗？|

1264
00:40:23,850 --> 00:40:24,960
0,180 180,570
Go ahead,
继续，有人吗，在这个页面错误，我们应该怎么做。

1265
00:40:25,310 --> 00:40:26,660
0,720 870,990 990,1140 1140,1260 1260,1350
anybody, I do what should

1266
00:40:26,660 --> 00:40:27,170
0,90 90,210 210,270 270,330 330,510
we do in the page

1267
00:40:27,170 --> 00:40:28,220
0,210 210,510
fault here.|
|

1268
00:40:28,430 --> 00:40:30,020
0,240 240,690 690,780 780,1200 1200,1590
I think we should make
我想我们应该新建一页，都写入零，并重新运行该指令。

1269
00:40:30,020 --> 00:40:33,470
0,240 270,660 660,1560 1590,2130 2520,3450
a new page and {all,write}

1270
00:40:33,960 --> 00:40:36,090
0,540 540,900 900,1050 1050,1290 1290,2130
zeroes and rerun that instruction.|
|

1271
00:40:36,450 --> 00:40:38,130
0,450 480,930 930,1140 1140,1380 1380,1680
Yeah exactly,| so let's let's
是的，正确，|我们假设我画的，有一个存储指令发生在这里。

1272
00:40:38,130 --> 00:40:39,420
0,360 360,540 540,690 690,840 840,1290
assume this were my drawing,

1273
00:40:39,420 --> 00:40:41,280
0,150 150,450 450,1140 1170,1500 1500,1860
that's actually the store instruction

1274
00:40:41,280 --> 00:40:42,210
0,270 270,330 330,630 630,720 720,930
happens to one of the

1275
00:40:42,240 --> 00:40:43,260
0,570
top.|
|

1276
00:40:43,460 --> 00:40:44,060
0,120 120,210 210,300 300,450 450,600
And what we really want
我们真正想做的是，

1277
00:40:44,060 --> 00:40:45,530
0,60 60,210 210,660 660,990 1080,1470
to do basically is| allocate
|使用 kalloc 分配一个新的物理页面，将其置零，

1278
00:40:45,530 --> 00:40:46,940
0,30 30,210 210,510 510,720 720,1410
a new physical page, a

1279
00:40:46,940 --> 00:40:48,890
0,300 300,660 660,840 840,1380 1770,1950
page memory {you,know} kalloc, put

1280
00:40:48,890 --> 00:40:50,000
0,360 360,480 480,750 750,1050 1050,1110
zeros in there,| because you
|因为这就是我们想要的，

1281
00:40:50,000 --> 00:40:51,140
0,120 120,240 240,420 420,510 510,1140
know that's what we're expecting|
|

1282
00:40:51,380 --> 00:40:52,400
0,150 150,270 270,390 390,510 510,1020
and then we can change
然后我们可以把顶部映射修改为这个映射，

1283
00:40:52,400 --> 00:40:54,080
0,150 150,690 690,1230 1260,1620 1620,1680
the top mapping for the

1284
00:40:54,080 --> 00:40:55,620
0,240 240,330 330,540 540,1080
one for this particular,|
|

1285
00:40:55,620 --> 00:40:58,650
0,240 240,480 480,960 1380,2160 2850,3030
because this guy [], let
因为这个页面，假设是这个，

1286
00:40:58,650 --> 00:40:59,400
0,90 90,330 330,450 450,600 600,750
me assume that there's this

1287
00:40:59,400 --> 00:41:00,870
0,390 540,870 870,1020 1020,1290 1290,1470
one,| we can change this
|我们可以修改这个映射为读写，

1288
00:41:00,870 --> 00:41:02,070
0,510 510,600 600,750 750,960 960,1200
mapping, you know to be

1289
00:41:02,070 --> 00:41:03,320
0,210 210,720
read write,|
|

1290
00:41:03,960 --> 00:41:05,980
0,480 480,900 900,1470
and pointed to
并指着这个新页面，

1291
00:41:06,130 --> 00:41:07,440
0,150 150,300 300,780
the new page,|
|

1292
00:41:11,860 --> 00:41:13,210
0,180 180,480 480,660 660,1110 1110,1350
and then you basically so
然后更新 PTE ，并重启指令。

1293
00:41:13,210 --> 00:41:15,100
0,660
copy

1294
00:41:15,490 --> 00:41:17,620
0,330 330,840 840,1560
or update pte,

1295
00:41:19,970 --> 00:41:21,290
0,150 150,330 330,660 660,750 750,1320
and then restart the instruction.|
|

1296
00:41:28,780 --> 00:41:29,920
0,120 120,270 270,570
And that's it.|
就是这样。|

1297
00:41:30,610 --> 00:41:32,200
0,600 810,1260 1260,1350 1350,1500 1500,1590
{} Why is this an
为什么这是一种有效的，

1298
00:41:32,200 --> 00:41:33,820
0,630 660,930 930,1380 1380,1470 1470,1620
effective| why, why do we
|为什么我们认为这是一个很好的优化。

1299
00:41:33,820 --> 00:41:34,510
0,150 150,270 270,360 360,630 630,690
think this is actually a

1300
00:41:34,510 --> 00:41:35,960
0,150 150,840
good optimization.|
|

1301
00:41:39,570 --> 00:41:41,160
0,390 390,510 510,840 840,1260 1290,1590
Why do operating systems do
为什么操作系统这么做。

1302
00:41:41,160 --> 00:41:42,000
0,270
it.|
|

1303
00:41:49,190 --> 00:41:50,420
0,690
Anybody?|
有人知道吗？|

1304
00:41:52,420 --> 00:41:53,770
0,180 180,420 420,750 750,960 960,1350
You don't need it though.|
你不需要它。|

1305
00:41:54,280 --> 00:41:56,420
0,240 240,660 960,1560
Go ahead {}.|
继续。|

1306
00:41:57,200 --> 00:41:58,070
0,150 150,330 330,510 510,570 570,870
You don't need to use
你不需要使用用户要求的那么多内存，

1307
00:41:58,070 --> 00:41:59,570
0,180 180,570 570,960 960,1170 1170,1500
as much memory as the

1308
00:41:59,600 --> 00:42:01,160
0,360 360,960 960,1140 1140,1260 1260,1560
user requests,| so it's just
|所以更好的是在你需要的时候创造它。

1309
00:42:01,160 --> 00:42:03,260
0,330 330,1080 1500,1770 1770,1890 1890,2100
better to build it when

1310
00:42:03,260 --> 00:42:04,340
0,240 300,480 480,630 630,840 840,1080
it when you need it.|
|

1311
00:42:04,700 --> 00:42:06,560
0,390 480,750 750,1020 1020,1710 1710,1860
Yeah, makes sense, similar to
是啊，有道理，类似于懒分配，

1312
00:42:06,560 --> 00:42:08,210
0,150 150,450 450,900 900,1410 1410,1650
the lazy allocation,| basically if
|如果程序说分配了巨大的列表，

1313
00:42:08,210 --> 00:42:11,360
0,390 510,1680 1710,1980 1980,2520 2520,3150
the program say allocated huge

1314
00:42:11,360 --> 00:42:12,200
0,90 90,240 240,390 390,720 720,840
you {know,array}| or {} you
|或者对于糟糕的输入，

1315
00:42:12,200 --> 00:42:13,490
0,210 210,390 390,600 630,900 900,1290
know for the worst possible

1316
00:42:13,490 --> 00:42:14,460
0,540
input,|
|

1317
00:42:14,490 --> 00:42:15,720
0,390 390,570 570,660 660,960 960,1230
{} it's a global array,
它是一个全局数组，它全部为零，

1318
00:42:15,720 --> 00:42:16,320
0,120 120,300 300,450 450,510 510,600
it all has to be

1319
00:42:16,320 --> 00:42:17,760
0,300 300,510 510,750 750,1020 1020,1440
zero,| but maybe only fraction
|但可能只有一小部分被使用。

1320
00:42:17,760 --> 00:42:18,980
0,90 90,270 270,720
is being used.|
|

1321
00:42:20,230 --> 00:42:21,920
0,210 210,330 330,570 570,1170
What's the second advantage.|
第二个优势是什么？|

1322
00:42:28,830 --> 00:42:29,820
0,300 300,660 660,780 780,900 900,990
Second advantage you have to
第二个优势是，你在 exec 中需要做的工作更少，

1323
00:42:29,820 --> 00:42:30,960
0,120 120,330 330,540 540,630 630,1140
do less work in exec|
|

1324
00:42:31,320 --> 00:42:32,730
0,420 420,720 720,960 960,1260 1260,1410
and so the program may
所以，程序可能会启动更快，获得更好的交互性能，

1325
00:42:32,730 --> 00:42:34,980
0,390 390,1140 1140,1590 1590,1920 1920,2250
start quicker and get basically

1326
00:42:34,980 --> 00:42:36,960
0,300 300,720 720,1320 1320,1740 1890,1980
better interactive performance,| because you
|因为你实际上不需要分配内存，

1327
00:42:36,960 --> 00:42:38,010
0,150 150,360 360,570 570,660 660,1050
don't really have to allocate

1328
00:42:38,010 --> 00:42:38,790
0,240 240,300 300,480 480,630 630,780
memory,| you don't really have
|你不需要将内存置零，

1329
00:42:38,790 --> 00:42:39,780
0,300 300,630 630,720 720,900 900,990
zero memory,| you only have
|你只需要分配一个零页，

1330
00:42:39,780 --> 00:42:41,220
0,90 90,450 450,780 780,1020 1020,1440
to allocate zero one page|
|

1331
00:42:41,460 --> 00:42:42,510
0,150 150,210 210,630 630,870 870,1050
and the rest like just
其他只是映射页表，

1332
00:42:42,510 --> 00:42:44,220
0,510 810,1020 1020,1260 1260,1620 1620,1710
mapping the {pagetables -},| you
|你只需写入 PTE 条目。

1333
00:42:44,220 --> 00:42:44,820
0,150 150,270 270,360 360,540 540,600
just have to write the

1334
00:42:44,820 --> 00:42:46,060
0,300 300,840
pte entries.|
|

1335
00:42:47,340 --> 00:42:48,560
0,90 90,180 180,270 270,630
Does that make sense?|
这能理解吗？|

1336
00:42:49,400 --> 00:42:52,400
0,360 360,930 960,2100 2100,2310 2310,3000
But our updates or writes,
但是我们的更新或写入会变慢，

1337
00:42:54,210 --> 00:42:56,160
0,390 810,1050 1050,1170 1170,1500 1500,1950
so they will become slower,|
|

1338
00:42:56,160 --> 00:42:57,750
0,360 360,570 570,1140 1170,1260 1260,1590
because every time a page
因为每次都会发生页面错误。

1339
00:42:57,750 --> 00:42:59,700
0,180 180,360 360,810 810,1230 1650,1950
fault will occur and.| Yeah
|是的，这是绝对有道理的，

1340
00:42:59,700 --> 00:43:01,380
0,450 450,690 690,870 870,1200 1200,1680
so you know there's absolute

1341
00:43:01,380 --> 00:43:03,240
0,420 630,810 810,1020 1020,1500 1500,1860
point,| {} so we basically
|所以我们推迟了一些花费，

1342
00:43:03,240 --> 00:43:04,530
0,510 510,720 720,810 810,900 900,1290
postponed some of the cost

1343
00:43:04,530 --> 00:43:05,860
0,390 420,840
later, right,|
|

1344
00:43:05,860 --> 00:43:07,570
0,420 420,1350 1350,1440 1440,1620 1620,1710
{} at the point that
在我们执行页面错误时，

1345
00:43:07,570 --> 00:43:08,410
0,90 90,180 180,240 240,480 480,840
we do the page fault,|
|

1346
00:43:08,830 --> 00:43:11,170
0,600 600,720 720,1200 1410,2010 2010,2340
and you know partially relying
依赖或希望并不是所有的页面都被使用了。

1347
00:43:11,170 --> 00:43:12,130
0,120 120,420 420,540 540,750 750,960
or hoping that maybe not

1348
00:43:12,130 --> 00:43:12,850
0,120 120,180 180,450 450,540 540,720
all the pages are being

1349
00:43:12,850 --> 00:43:13,840
0,540
used.|
|

1350
00:43:13,840 --> 00:43:15,190
0,570 600,720 720,870 870,930 930,1350
{} Good like for example
比如，如果页面是 4096 字节，

1351
00:43:15,190 --> 00:43:16,420
0,270 270,360 360,720 720,930 930,1230
if the pages four ninety

1352
00:43:16,420 --> 00:43:17,590
0,270 270,480 480,750 750,960 960,1170
six four thousand ninety six

1353
00:43:17,590 --> 00:43:19,510
0,540 900,1410 1410,1530 1530,1650 1650,1920
bytes,| {} you know basically
|基本上我们每 4096 个零就有一个页面错误。

1354
00:43:19,510 --> 00:43:20,380
0,90 90,210 210,360 360,570 570,870
we're gonna take one page

1355
00:43:20,380 --> 00:43:23,590
0,510 540,840 840,2040 2040,2640 2850,3210
fault per 4096 zeros, right.|
|

1356
00:43:24,190 --> 00:43:25,330
0,150 150,270 270,390 390,600 600,1140
And so do some []
那里有一些[]。

1357
00:43:25,330 --> 00:43:26,180
0,300
there.|
|

1358
00:43:27,700 --> 00:43:29,200
0,270 270,360 360,450 450,1140 1140,1500
But it's a great point,|
但这是一个很好的观点，|

1359
00:43:29,230 --> 00:43:30,190
0,90 90,240 240,540 540,750 750,960
you know certainly we've made
我们增加了页面错误的成本。

1360
00:43:30,190 --> 00:43:31,960
0,180 180,1110 1170,1410 1410,1680 1680,1770
page, we have added the

1361
00:43:31,960 --> 00:43:32,980
0,270 270,330 330,420 420,630 630,1020
cost of the page fault.|
|

1362
00:43:33,530 --> 00:43:34,280
0,180 180,330 330,420 420,510 510,750
How much is the cost
页面错误的成本是多少，我们应该怎么考虑？

1363
00:43:34,280 --> 00:43:35,960
0,60 60,150 150,540 540,1500 1500,1680
of the {page,fault}, how should

1364
00:43:35,960 --> 00:43:37,280
0,90 90,270 270,480 480,780
we think about that.|
|

1365
00:43:38,140 --> 00:43:39,430
0,150 150,240 240,780 780,990 990,1290
These are comparable to store
这些与存储指令相比，成本要高得多。

1366
00:43:39,430 --> 00:43:40,990
0,630 630,960 960,1080 1080,1290 1290,1560
instruction more is much more

1367
00:43:41,020 --> 00:43:42,320
0,750
expensive.|
|

1368
00:43:48,300 --> 00:43:51,240
0,660 660,1170 1170,1950 2010,2400 2400,2940
More expensive, right.| Yeah, why.|
更高。|是的，为什么。|

1369
00:43:52,720 --> 00:43:55,180
0,270 270,960 960,1380 1380,1920 1920,2460
{} Store will just {}
保存需要时间访问内存，

1370
00:43:56,270 --> 00:43:57,920
0,540 540,810 810,930 930,1470 1500,1650
like need to record, it

1371
00:43:57,920 --> 00:43:59,690
0,510 600,840 840,1110 1110,1440 1440,1770
will take some time to

1372
00:43:59,690 --> 00:44:01,200
0,270 270,480 480,900
get to the

1373
00:44:01,320 --> 00:44:03,390
0,180 180,600 600,930 930,1380 1620,2070
to RAM,| but the fault
|但是，错误必须访问内核。

1374
00:44:03,390 --> 00:44:04,050
0,120 120,300 300,420 420,540 540,660
will have to go to

1375
00:44:04,050 --> 00:44:05,420
0,150 150,780
the kernel.|
|

1376
00:44:05,510 --> 00:44:07,550
0,510 600,870 870,990 990,1350 1830,2040
Yeah, so, in fact how
是的，那么，有多少个保存指令，

1377
00:44:07,550 --> 00:44:08,720
0,180 180,450 450,840 840,1020 1020,1170
many store instruction were there,|
|

1378
00:44:08,720 --> 00:44:10,820
0,300 300,480 480,1080 1410,1950 1950,2100
even in the {}, the
像 Robert 上周展示给你的 trap 处理代码，

1379
00:44:10,820 --> 00:44:12,260
0,270 270,630 630,930 930,1110 1110,1440
trap handling code that Robert

1380
00:44:12,260 --> 00:44:13,910
0,270 270,510 510,780 780,1110 1290,1650
showed you last week| or
|或者你在 trap 实验中所做的。

1381
00:44:13,910 --> 00:44:15,260
0,300 300,450 450,600 600,930 930,1350
actually that you're doing currently

1382
00:44:15,260 --> 00:44:17,480
0,120 120,480 930,1740
in the {trap,lab}.|
|

1383
00:44:19,500 --> 00:44:21,210
0,270 270,990 990,1200 1200,1530 1530,1710
{} Well at least like
好吧，至少有一百个。

1384
00:44:21,210 --> 00:44:22,710
0,90 90,630 780,1230 1230,1350 1350,1500
a hundred.| Yeah at least
|是的，至少有一百个，需要保存寄存器。

1385
00:44:22,710 --> 00:44:23,520
0,60 60,360 360,600 600,750 750,810
a hundred, correct, used to

1386
00:44:23,520 --> 00:44:25,540
0,270 270,660 660,1320
save store registers.|
|

1387
00:44:25,710 --> 00:44:26,550
0,330 330,480 480,630 630,810 810,840
{} So there's quite a
所以有相当多的，

1388
00:44:26,550 --> 00:44:27,810
0,330 330,420 420,570 570,810 810,1260
bit| and so there's both
|所以，从用户空间到内核空间的开销也很大，

1389
00:44:27,810 --> 00:44:29,730
0,60 60,630 630,990 990,1680 1680,1920
the overhead of transferring from

1390
00:44:29,730 --> 00:44:30,870
0,240 240,480 480,570 570,810 810,1140
user space to kernel space

1391
00:44:30,870 --> 00:44:31,830
0,90 90,450 450,690 690,870 870,960
as well| as all the
|还有所有用来保存和恢复状态的指令。

1392
00:44:31,830 --> 00:44:33,390
0,540 540,630 630,720 720,900 900,1560
instructions that are being executed

1393
00:44:33,720 --> 00:44:35,550
0,780 780,1020 1020,1350 1350,1440 1440,1830
{} to save and restore

1394
00:44:35,550 --> 00:44:36,480
0,450
state.|
|

1395
00:44:36,660 --> 00:44:37,920
0,360 360,600 600,780 780,900 900,1260
So page fault is definitely
所以，页面错误肯定不是免费的，

1396
00:44:37,920 --> 00:44:39,960
0,450 450,900 1470,1650 1650,1770 1770,2040
not free,| so the question
|所以，之前提出的问题是非常好的问题。

1397
00:44:39,960 --> 00:44:41,010
0,90 90,210 210,420 420,810 810,1050
that was asked earlier very

1398
00:44:41,010 --> 00:44:42,020
0,120 120,480
good question.|
|

1399
00:44:45,570 --> 00:44:46,680
0,630
Okay.|
好的。|

1400
00:44:47,190 --> 00:44:48,360
0,180 180,360 360,990 990,1050 1050,1170
So let's look at some
让我们来看一些更多能做的优化，

1401
00:44:48,360 --> 00:44:51,330
0,570 690,1080 1080,1890 1890,2130 2820,2970
more {} optimizations {} that

1402
00:44:51,330 --> 00:44:52,590
0,330 330,420 420,600 600,1080 1080,1260
what can do,| these ones
|这些都是非常无聊的，或者非常直接的，

1403
00:44:52,590 --> 00:44:53,880
0,90 90,240 240,390 420,750 750,1290
are sort of reasonable boring,

1404
00:44:54,270 --> 00:44:56,640
0,210 210,510 510,810 810,1530 1830,2370
or maybe reasonable straightforward {},|
|

1405
00:44:56,640 --> 00:44:58,380
0,330 330,570 570,960 1200,1620 1620,1740
and we're gonna hopefully get
我们希望有更多更令人兴奋的（优化）。

1406
00:44:58,380 --> 00:44:59,970
0,30 30,180 180,270 270,600 1230,1590
a little bit more couple

1407
00:44:59,970 --> 00:45:01,340
0,150 150,510 510,990
more exciting ones.|
|

1408
00:45:02,120 --> 00:45:03,560
0,780 780,930 930,1020 1020,1290 1290,1440
See what is next what
看看下一步我想做什么。

1409
00:45:03,560 --> 00:45:04,460
0,30 30,270 270,330 330,510 510,900
I wanted to do about

1410
00:45:04,460 --> 00:45:05,160
0,120
it.|
|

1411
00:45:05,160 --> 00:45:06,960
0,480 510,810 810,1260
{} Next one,
下一个，是非常常见的，在许多操作系统中实现了，

1412
00:45:06,990 --> 00:45:08,340
0,180 180,210 210,630 630,930 930,1350
it's a very common one,

1413
00:45:08,610 --> 00:45:10,320
0,510 510,750 750,990 990,1350 1350,1710
{} in many operating systems

1414
00:45:10,320 --> 00:45:11,490
0,570 600,750 750,810 810,1050 1050,1170
implemented| and the fact that
|实际上，这也是其中一个实验的一个主题。

1415
00:45:11,490 --> 00:45:12,840
0,330 330,870 870,990 990,1230 1230,1350
will also be one of

1416
00:45:12,840 --> 00:45:14,310
0,180 180,600 600,810 810,1200 1230,1470
the topics in the one

1417
00:45:14,310 --> 00:45:15,380
0,60 60,150 150,630
of the labs.|
|

1418
00:45:16,250 --> 00:45:17,660
0,300 300,720 720,870 870,1080 1110,1410
So let's do the next
那么让我们来做下一个。

1419
00:45:17,660 --> 00:45:18,580
0,390
one.|
|

1420
00:45:19,010 --> 00:45:21,110
0,570 570,840 840,1050 1050,1290 1290,2100
{} And that is {copy-on-write
这就是写入时复制 fork ，或者称为 COW fork 。

1421
00:45:22,330 --> 00:45:23,880
0,480 480,990
- -}

1422
00:45:23,880 --> 00:45:25,000
0,600
fork,

1423
00:45:27,800 --> 00:45:29,820
0,210 210,510 510,870 870,1560
or something called COW

1424
00:45:30,170 --> 00:45:31,340
0,600
fork.|

1425
00:45:34,960 --> 00:45:37,900
0,600 1020,1500 1500,1590 1590,2220 2310,2940
{} And you know, {}
[观察]是非常直截了当的，

1426
00:45:38,140 --> 00:45:40,660
0,960 960,1680 1680,1860 1860,2400 2400,2520
observation is pretty straightforward,| in
|实际上，我们已经在讲座中做过几次[观察]。

1427
00:45:40,660 --> 00:45:42,280
0,450 450,540 540,960 960,1140 1140,1620
fact we made this observation

1428
00:45:42,280 --> 00:45:43,360
0,30 30,240 240,510 510,570 570,1080
a couple times in lecture.|
|

1429
00:45:44,170 --> 00:45:47,100
0,600 690,1290 1290,1800 1800,2340
Um, but when {}.|
但是，当。|

1430
00:45:48,680 --> 00:45:49,520
0,270 270,510 510,630 630,720 720,840
Let's say you know the
比如 shell ，我们刚才讨论的，

1431
00:45:49,520 --> 00:45:52,100
0,540 570,1500 1530,1800 1800,2160 2160,2580
shell, we're talking [] a

1432
00:45:52,100 --> 00:45:53,840
0,270 270,570 570,780 840,1230 1230,1740
second ago,| so shell runs
|shell 运行进程命令，

1433
00:45:54,680 --> 00:45:57,170
0,540 600,1230 1230,1380 1380,1830 2250,2490
and process's command| and {}
|它实际上执行 fork 来创建子进程，

1434
00:45:57,170 --> 00:45:58,520
0,120 120,480 480,720 720,1230 1260,1350
it actually does fork to

1435
00:45:58,520 --> 00:45:59,980
0,300 300,870
create child,|
|

1436
00:46:00,670 --> 00:46:01,660
0,210 210,330 330,420 420,870 870,990
and so the fork {you,know}
所以 fork 保留了 shell 的副本，

1437
00:46:01,660 --> 00:46:03,490
0,360 360,630 630,1080 1080,1260 1260,1830
basically keep copy of shell|
|

1438
00:46:03,880 --> 00:46:04,690
0,300 300,450 450,570 570,690 690,810
{} and so we got
所以我们既有父进程又有子进程，

1439
00:46:04,690 --> 00:46:05,530
0,60 60,540 540,630 630,720 720,840
a parent and we got

1440
00:46:05,530 --> 00:46:07,510
0,90 90,720 1020,1260 1260,1440 1440,1980
the child| and the child
|而子进程做的第一件事就是 exec ，

1441
00:46:07,510 --> 00:46:08,410
0,330 330,510 510,570 570,660 660,900
almost one of the first

1442
00:46:08,410 --> 00:46:09,250
0,210 210,300 300,630 630,720 720,840
things it does is an

1443
00:46:09,250 --> 00:46:10,870
0,480 600,1050 1050,1410 1410,1440 1440,1620
exec,| maybe execute a couple
|或许执行几条指令，

1444
00:46:10,870 --> 00:46:12,910
0,60 60,780 1050,1380 1380,1680 1680,2040
of instructions| and then actually
|然后执行 exec ，比如运行 echo  。

1445
00:46:12,910 --> 00:46:14,170
0,420 420,690 690,990 990,1050 1050,1260
execs, for example to run

1446
00:46:14,170 --> 00:46:15,120
0,420
echo.|
|

1447
00:46:16,800 --> 00:46:18,390
0,600 600,720 720,840 840,960 960,1590
And as we now know,
正如我们所知，在上一个实验中看到的，

1448
00:46:18,420 --> 00:46:20,880
0,540 540,1260 1260,1620 1620,2010 2010,2460
{} saw in last lab,|
|

1449
00:46:21,030 --> 00:46:21,990
0,210 210,300 300,390 390,690 690,960
you know the fork creates
fork 创建了 shell 地址空间的完全副本，

1450
00:46:21,990 --> 00:46:23,610
0,60 60,420 420,960 990,1200 1200,1620
a complete duplicate of the

1451
00:46:23,640 --> 00:46:25,530
0,630 630,960 960,1440 1620,1770 1770,1890
shell address space,| and then
|然后 exec 做的第一件事，

1452
00:46:25,530 --> 00:46:26,520
0,420 420,540 540,750 750,900 900,990
exec the first thing that

1453
00:46:26,520 --> 00:46:28,200
0,300 300,660 660,1170 1230,1530 1530,1680
basically does,| it throws out
|它会丢弃它，并将其替换为包含 echo 的地址空间。

1454
00:46:28,200 --> 00:46:30,390
0,570 630,900 900,1470 1470,1740 1770,2190
away and replaces it with

1455
00:46:30,390 --> 00:46:32,160
0,90 90,360 360,930 930,1320 1320,1770
an address space containing echo.|
|

1456
00:46:33,060 --> 00:46:34,950
0,600 750,1200 1230,1350 1350,1590 1590,1890
And so it seems slightly
所以这看起来有点浪费，

1457
00:46:34,950 --> 00:46:36,870
0,510 540,810 810,1290 1290,1470 1470,1920
wasteful right,| yeah, so here
|比如，这里我们有自己的父虚拟地址空间，

1458
00:46:36,870 --> 00:46:37,920
0,150 150,270 270,420 420,660 660,1050
let's say we have our

1459
00:46:38,440 --> 00:46:40,840
0,570 600,1020 1020,1260 1260,1800
parent virtual address space,|
|

1460
00:46:41,290 --> 00:46:43,090
0,510 510,690 690,1230 1350,1680 1680,1800
{} and then here we
然后，这里我们有了一个子（地址空间）。

1461
00:46:43,090 --> 00:46:44,520
0,90 90,210 210,810
have a child.|
|

1462
00:46:46,030 --> 00:46:48,280
0,810 1170,1530 1530,1800 1800,1920 1920,2250
And {} what we're actually
我们在用户物理内存中实际做的是，

1463
00:46:48,280 --> 00:46:49,930
0,390 390,540 540,690 690,1050 1050,1650
doing in user physical memory,|
|

1464
00:46:52,970 --> 00:46:54,050
0,240 240,300 300,390 390,690 690,1080
and in the normal case
在正常的 xv6 或未修改的 xv6 中，

1465
00:46:54,050 --> 00:46:55,070
0,210 210,480 480,780 780,900 900,1020
in {xv6 -} or in

1466
00:46:55,070 --> 00:46:56,900
0,690 690,960 960,1440 1590,1710 1710,1830
unmodified {xv6 -},| you know
|我们之前看到的 shell 有四个页面，一二三四。

1467
00:46:56,900 --> 00:46:57,680
0,180 180,240 240,450 450,570 570,780
there's a bunch of like

1468
00:46:57,680 --> 00:46:58,730
0,90 90,270 270,480 480,930 930,1050
there were four pages, we

1469
00:46:58,730 --> 00:47:00,830
0,570 960,1170 1170,1410 1410,1710 1710,2100
saw that the shell has

1470
00:47:00,830 --> 00:47:02,340
0,240 240,330 330,510 510,990
one two three four.|
|

1471
00:47:02,340 --> 00:47:04,500
0,690 720,1560 1590,1710 1710,1800 1800,2160
And, {} you know when
当运行 fork 时，

1472
00:47:04,500 --> 00:47:07,470
0,450 600,990 990,1320 1350,1860 1890,2970
we start, when fork runs,|
|

1473
00:47:07,620 --> 00:47:08,970
0,690 690,900 900,1020 1020,1200 1200,1350
basically you do look at
查看这四个页面，一二三四，

1474
00:47:08,970 --> 00:47:10,260
0,210 210,390 390,720 720,1050 1050,1290
those four pages one two

1475
00:47:10,260 --> 00:47:12,240
0,330 330,810 990,1350 1350,1800 1800,1980
three four| and copy all
|并把父（地址空间）的所有内容复制到子（地址空间）。

1476
00:47:12,240 --> 00:47:13,770
0,90 90,750 1080,1200 1200,1320 1320,1530
the content you know from

1477
00:47:13,770 --> 00:47:15,630
0,240 240,960 1140,1320 1320,1650 1650,1860
those pages the parent into

1478
00:47:15,630 --> 00:47:16,620
0,90 90,570
the child.|
|

1479
00:47:17,180 --> 00:47:20,180
0,480 960,1470 1560,2610 2610,2790 2790,3000
{} And then as soon
然后，一旦 exec 发生，我们就会释放这些页面。

1480
00:47:20,180 --> 00:47:21,500
0,120 120,180 180,480 480,900 900,1320
as the exec happens, basically

1481
00:47:21,500 --> 00:47:22,250
0,90 90,210 210,300 300,510 510,750
we're going to free these

1482
00:47:22,250 --> 00:47:23,420
0,690
pages.|
|

1483
00:47:23,420 --> 00:47:25,100
0,420 420,750 750,960 960,1350 1350,1680
And allocate new pages actually
并且分配新的页面，包含 echo 的内容。

1484
00:47:25,100 --> 00:47:26,720
0,750 750,840 840,1230 1230,1320 1320,1620
have the content of echo

1485
00:47:26,720 --> 00:47:27,540
0,90 90,210
in it.|
|

1486
00:47:27,990 --> 00:47:29,160
0,660
So,
所以，对于这种情况，有一种好的组织方式是非常有效的，

1487
00:47:29,990 --> 00:47:31,520
0,150 150,420 420,1110 1110,1380 1380,1530
a good organization one that

1488
00:47:31,520 --> 00:47:32,360
0,270 270,450 450,540 540,600 600,840
actually tends to be very

1489
00:47:32,360 --> 00:47:34,670
0,600 690,1080 1080,1320 1320,1680 1680,2310
effective for this particular sequence|
|

1490
00:47:34,880 --> 00:47:36,140
0,240 240,660 690,780 780,1080 1080,1260
is that you know if
如果父进程在它的地址空间中有四个映射，

1491
00:47:36,140 --> 00:47:38,480
0,480 810,1500 1530,1620 1620,2040 2040,2340
we if the parent has

1492
00:47:38,480 --> 00:47:39,650
0,210 210,450 450,870 870,1080 1080,1170
these four {mappings -}, you

1493
00:47:39,650 --> 00:47:41,060
0,120 120,270 270,510 510,810 810,1410
know in its address space,|
|

1494
00:47:42,020 --> 00:47:43,730
0,390 390,690 690,1170 1170,1320 1320,1710
going from whatever the zero
比如，零在这里，一在这里，等等。

1495
00:47:43,730 --> 00:47:45,260
0,240 240,750 750,1050 1080,1320 1320,1530
goes here, the first one

1496
00:47:45,260 --> 00:47:47,100
0,180 180,780 780,870 870,1290
goes there and whatever.|
|

1497
00:47:47,980 --> 00:47:49,600
0,690 720,1200 1200,1290 1290,1530 1530,1620
Instead, when we create the
当我们创建子进程的地址空间时，

1498
00:47:49,600 --> 00:47:50,950
0,330 330,540 540,900 900,1260 1260,1350
child's address space,| instead of
|不是复制或分配新的物理内存，

1499
00:47:50,950 --> 00:47:52,390
0,270 270,750 750,840 840,1290 1290,1440
creating copying and allocating new

1500
00:47:52,390 --> 00:47:53,680
0,300 300,810 840,1110 1110,1170 1170,1290
physical memory,| what we could
|而是共享父进程已经分配的物理页面。

1501
00:47:53,680 --> 00:47:54,940
0,270 270,390 390,780
do is just

1502
00:47:54,940 --> 00:47:58,120
0,750 1080,1290 1290,1590 1590,2130 2130,3180
share the physical pages that

1503
00:47:58,120 --> 00:48:00,480
0,690 690,1020 1020,1170 1170,1710
{parent,actually} already has allocated.|
|

1504
00:48:00,540 --> 00:48:01,860
0,150 150,300 300,480 480,810 930,1320
And so we just set
所以，我们只是把子进程的 pte 指向父进程物理页面的相同位置。

1505
00:48:01,860 --> 00:48:03,750
0,60 60,720 720,900 900,1740 1740,1890
the ptes with child to

1506
00:48:03,750 --> 00:48:04,830
0,90 90,630 630,900 900,990 990,1080
the same pointing to the

1507
00:48:04,830 --> 00:48:06,570
0,240 240,570 570,1110 1440,1620 1620,1740
same physical pages as in

1508
00:48:06,570 --> 00:48:07,660
0,60 60,570
the parent.|
|

1509
00:48:08,780 --> 00:48:09,380
0,150 150,240 240,360 360,480 480,600
And we're going to be
我们要更小心一点，

1510
00:48:09,380 --> 00:48:10,670
0,60 60,270 270,660 660,990 990,1290
a little careful again, correct,|
|

1511
00:48:10,670 --> 00:48:11,930
0,210 210,330 330,450 450,1020 1020,1260
because if the child wants
因为如果子进程想要修改其中一个页面，

1512
00:48:11,930 --> 00:48:12,950
0,60 60,510 510,750 750,810 810,1020
to modify one of these

1513
00:48:12,950 --> 00:48:14,600
0,540 630,1170
pages,| that
|那个更新不应该对父进程可见，

1514
00:48:14,600 --> 00:48:16,130
0,450 450,600 600,840 840,960 990,1530
updates should not be visible

1515
00:48:16,130 --> 00:48:17,240
0,150 150,240 240,630 630,870 870,1110
to the parent,| because we
|因为我们希望父进程和子进程之间有很强的隔离，

1516
00:48:17,240 --> 00:48:18,560
0,180 180,480 480,1050 1050,1260 1260,1320
want strong isolation between the

1517
00:48:18,560 --> 00:48:19,610
0,300 300,450 450,810 810,930 930,1050
parent and child,| so we
|所以我们需要更小心一点，

1518
00:48:19,610 --> 00:48:20,390
0,180 180,390 390,510 510,570 570,780
need to be a little

1519
00:48:20,390 --> 00:48:21,800
0,150 150,660 960,1200 1200,1290 1290,1410
more careful,| so to be
|所以为了更小心一点，

1520
00:48:21,800 --> 00:48:23,000
0,60 60,240 240,390 390,960 1050,1200
a little more careful about,|
|

1521
00:48:23,000 --> 00:48:23,480
0,120 120,180 180,270 270,390 390,480
what we can do is
我们能做的就是，将这些子页面和父页面的映射都设置为只读。

1522
00:48:23,480 --> 00:48:25,850
0,240 750,1080 1080,1350 1350,1950 1980,2370
just map those pages both

1523
00:48:25,850 --> 00:48:27,890
0,90 90,720 1050,1410 1410,1500 1500,2040
the child and the parent

1524
00:48:28,130 --> 00:48:29,240
0,270 270,660
read only.|
|

1525
00:48:32,870 --> 00:48:34,520
0,720 840,1170 1170,1260 1260,1560 1560,1650
And then of course we're
当然，我们也会在某一时刻得到页面错误，

1526
00:48:34,520 --> 00:48:35,090
0,120 120,180 180,300 300,330 330,570
going to get a page

1527
00:48:35,090 --> 00:48:36,720
0,270 270,390 390,570 570,1080
fault at some point,|
|

1528
00:48:36,750 --> 00:48:37,560
0,270 270,360 360,630 630,690 690,810
because the parent is going
因为父进程要运行子进程运行的（位置）。

1529
00:48:37,560 --> 00:48:38,370
0,90 90,300 300,420 420,480 480,810
to run where the child

1530
00:48:38,370 --> 00:48:39,620
0,90 90,210 210,300 300,690
is going to run.|
|

1531
00:48:40,130 --> 00:48:42,860
0,540 540,540 1680,2460 2460,2580 2580,2730
And, {} maybe you know
或许子进程或父进程执行保存指令，

1532
00:48:42,860 --> 00:48:44,510
0,150 150,570 570,900 900,1380 1380,1650
the {child,or} parent will do

1533
00:48:44,510 --> 00:48:46,310
0,360 390,750 750,1290 1290,1500 1500,1800
a store instruction| to maybe
|可能将数据保存到某个全局变量中，

1534
00:48:46,310 --> 00:48:48,170
0,360 360,660 660,1170 1290,1590 1590,1860
save the data to some

1535
00:48:48,170 --> 00:48:50,020
0,270 270,810 810,1350
global variable somewhere,|
|

1536
00:48:50,020 --> 00:48:50,740
0,90 90,150 150,330 330,630 630,720
and at that point you
在这时，会导致页面错误，

1537
00:48:50,740 --> 00:48:51,970
0,210 210,540 570,990 990,1140 1140,1230
know, {} that that will

1538
00:48:51,970 --> 00:48:53,260
0,210 210,270 270,540 540,870 870,1290
cause a page fault,| because
|因为你正在写入的页面，映射为只读，

1539
00:48:53,260 --> 00:48:54,100
0,90 120,330 330,660 660,780 780,840
you were writing to a

1540
00:48:54,100 --> 00:48:55,930
0,270 270,570 570,840 840,1260 1260,1830
page that is mapped {read,only},|
|

1541
00:48:56,110 --> 00:48:57,070
0,150 150,270 270,330 330,540 540,960
we get a page fault|
我们得到一个页面错误，|

1542
00:48:57,160 --> 00:48:57,790
0,210 210,330 330,450 450,510 510,630
and so what do we
那么我们需要做什么。

1543
00:48:57,790 --> 00:48:58,600
0,150 150,210 210,450 450,720 720,810
need to do.| Well, we
|我们需要把那个页面复制一份，

1544
00:48:58,600 --> 00:48:59,290
0,120 120,180 180,300 300,360 360,690
need to make a copy

1545
00:48:59,290 --> 00:49:00,420
0,60 60,150 150,570
of the page,|
|

1546
00:49:03,120 --> 00:49:04,680
0,240 240,510 510,840 840,1380 1380,1560
so let's assume {that's -}
我们假设子进程执行存储指令，

1547
00:49:04,680 --> 00:49:06,420
0,120 120,510 510,630 630,1230 1260,1740
the child that actually {}

1548
00:49:06,420 --> 00:49:08,280
0,240 240,390 390,720 720,1440 1560,1860
does the store instruction,| so
|所以我们分配一个新的页面，

1549
00:49:08,280 --> 00:49:09,660
0,150 150,510 510,540 540,750 750,1380
we allocate a new page,|
|

1550
00:49:11,400 --> 00:49:13,590
0,240 270,930 960,1290 1290,1950 2070,2190
we copy the content of
我们复制出现错误的页面内容到新页面，

1551
00:49:13,590 --> 00:49:15,180
0,600 600,930 930,1170 1170,1440 1440,1590
{} of the page that

1552
00:49:15,180 --> 00:49:16,830
0,150 150,510 510,960 1020,1470 1470,1650
were faulted on into this

1553
00:49:16,830 --> 00:49:18,480
0,150 150,750 990,1170 1170,1470 1470,1650
new page,| we map that
|我们把那一页映射到子进程中，

1554
00:49:18,480 --> 00:49:20,550
0,600 870,1080 1080,1440 1440,1560 1560,2070
page {} into the child,|
|

1555
00:49:20,550 --> 00:49:21,330
0,120 120,300 300,480 480,600 600,780
and this guy we can
而这个我们可以映射为读写，

1556
00:49:21,330 --> 00:49:22,920
0,300 300,600 600,1020 1020,1350 1350,1590
map read write,| because now
|因为私有页面仅在子进程的地址空间中可见，

1557
00:49:22,920 --> 00:49:25,110
0,420 420,750 750,1260 1290,1920 1920,2190
private page only visible in

1558
00:49:25,110 --> 00:49:26,880
0,270 270,600 600,810 810,1290 1590,1770
the child's address space,| in
|实际上，出错的页面，

1559
00:49:26,880 --> 00:49:28,290
0,360 660,810 810,1020 1020,1170 1170,1410
fact the page that actually

1560
00:49:28,290 --> 00:49:29,190
0,90 90,210 210,570 570,810 810,900
will be fault on,| we
|我们现在也可以将父进程页面（标记为）读写。

1561
00:49:29,190 --> 00:49:30,000
0,120 120,330 330,450 450,630 630,810
can also now map page

1562
00:49:30,000 --> 00:49:31,100
0,210 210,690
read write

1563
00:49:31,130 --> 00:49:32,920
0,600 600,780 780,1260
into the parent.|
|

1564
00:49:34,060 --> 00:49:34,720
0,120 120,240 240,330 330,600 600,660
And so we copy the
所以，我们复制页面，映射它，然后重启指令。

1565
00:49:34,720 --> 00:49:36,680
0,540 570,930 930,1290
page, map it

1566
00:49:38,040 --> 00:49:39,920
0,300 300,720 720,1230
and restart instruction.|
|

1567
00:49:44,940 --> 00:49:46,290
0,150 150,390 390,840 840,1170 1170,1350
And when restarting starting really
重启意思是，执行 userret ，

1568
00:49:46,290 --> 00:49:47,520
0,360 360,450 450,630 630,870 870,1230
means you know doing {userret

1569
00:49:47,520 --> 00:49:49,200
0,300 690,750 780,1110 1110,1350 1350,1680
-}| the same way that
|与上周的讲座中返回用户空间的方法相同。

1570
00:49:49,230 --> 00:49:51,660
0,570 630,1320 1410,1560 1560,1860 1860,2430
{} return to user space,

1571
00:49:51,900 --> 00:49:53,580
0,480 480,840 840,1200 1230,1500 1500,1680
{} in the last week's

1572
00:49:53,580 --> 00:49:54,460
0,360
lecture.|
|

1573
00:49:56,690 --> 00:49:57,830
0,150 150,300 300,450 450,930 960,1140
Does this make sense, any
这能理解吗，关于这个，有什么问题吗。

1574
00:49:57,830 --> 00:49:59,720
0,420 420,630 630,810 810,1320
questions about this one.|
|

1575
00:49:59,720 --> 00:50:01,130
0,240 240,720 720,870 870,1260 1260,1410
I'm sorry, {} when you
抱歉，当你说我们把父进程的虚拟地址映射为读写，

1576
00:50:01,130 --> 00:50:03,560
0,270 270,690 720,1320 1320,1560 1560,2430
say we mapped the parents

1577
00:50:03,860 --> 00:50:06,470
0,570 600,1320 1320,1740 1740,2310 2370,2610
{} virtual address to we

1578
00:50:06,470 --> 00:50:08,840
0,690 750,1110 1110,1650 1740,2280 2280,2370
also read write,| how do
|我们如何找到它，跟子进程的一样吗？

1579
00:50:08,840 --> 00:50:10,340
0,180 180,570 570,690 690,1110 1200,1500
we find it out, is

1580
00:50:10,340 --> 00:50:12,080
0,90 90,390 390,690 690,840 840,1740
the same as the child's?|
|

1581
00:50:12,200 --> 00:50:14,480
0,960 960,1380 1410,1740 1740,2100 2100,2280
{Yeah,because} the address space of
是的，因为子进程的地址空间是父进程地址空间的副本，

1582
00:50:14,480 --> 00:50:15,500
0,90 90,390 390,450 450,510 510,1020
the child is a duplicate

1583
00:50:15,500 --> 00:50:18,020
0,270 270,870 1140,1620 1620,2040 2040,2520
of the parents address space

1584
00:50:18,050 --> 00:50:19,760
0,300 300,660 750,1080 1080,1440 1440,1710
right,| so if we fault
|所以，如果我们在一个虚拟地址出现错误，

1585
00:50:19,760 --> 00:50:21,290
0,240 240,270 270,630 630,960 960,1530
to a particular virtual address,|
|

1586
00:50:21,640 --> 00:50:22,750
0,270 270,360 360,600 600,900 900,1110
seems the address spaces are
地址空间是相等的，

1587
00:50:22,750 --> 00:50:25,090
0,510 720,840 840,960 960,1350 1920,2340
equal,| you know the same
|同一个虚拟地址，同时在父进程的地址空间和子进程的地址空间。

1588
00:50:25,090 --> 00:50:26,440
0,300 300,570 570,900 900,960 960,1350
virtual address both the parents

1589
00:50:26,440 --> 00:50:27,520
0,420 420,690 690,900 900,990 990,1080
address space and in the

1590
00:50:27,520 --> 00:50:29,100
0,360 360,660 660,1110
child's address space.|

1591
00:50:31,580 --> 00:50:33,480
0,270 270,600 600,960 960,1290
Makes sense, thank you.|
理解了，谢谢。|

1592
00:50:36,490 --> 00:50:39,910
0,330 330,720 720,1230 1410,1860 2640,3420
{} Another question?| Yeah.| For,
另一个问题？|嗯。|比如，某个没有父进程的进程，或许第一个启动的，

1593
00:50:39,910 --> 00:50:42,340
0,270 270,810 1080,1350 1350,1830 1830,2430
let's say, like some {parentless

1594
00:50:42,340 --> 00:50:44,470
0,630 780,1560 1590,1830 1830,2010 2010,2130
-} process, maybe like the

1595
00:50:44,470 --> 00:50:46,390
0,240 240,390 390,510 510,1140 1290,1920
first one that launches,| does
|它是否使用它的页面设置位读权限，

1596
00:50:46,390 --> 00:50:49,280
0,360 690,1110 1110,1320 1320,2250
it use its pages,

1597
00:50:49,280 --> 00:50:50,900
0,240 240,390 390,510 510,1080 1110,1620
god, does it set just

1598
00:50:50,900 --> 00:50:53,060
0,420 420,1320 1560,1860 1860,2040 2040,2160
read permissions| or does it
|或者以读写开始，当它 fork 时。

1599
00:50:53,060 --> 00:50:54,590
0,300 300,540 540,690 690,930 930,1530
start off with read write,

1600
00:50:55,010 --> 00:50:57,380
0,780 780,930 930,1500 1530,1680 1680,2370
when it forks it modifies.|
|

1601
00:50:58,060 --> 00:50:59,170
0,420 420,660 660,870 870,1020 1020,1110
OK, OK, it's up to
好的，这是由你决定的，

1602
00:50:59,170 --> 00:51:01,510
0,360 1470,1830 1830,1980 1980,2010 2010,2340
you,| {} if I knew
|这也是一个实验，

1603
00:51:01,510 --> 00:51:03,580
0,180 180,300 300,540 540,720 720,2070
this is also one lab,|
|

1604
00:51:04,240 --> 00:51:05,290
0,150 150,240 240,660 660,930 930,1050
you can implement {copy-on-write -
你可以在 lazy 实验后实现写入时复制，

1605
00:51:05,290 --> 00:51:07,120
0,420 480,1050 1050,1380 1380,1530 1530,1830
-} {} after the lazy

1606
00:51:07,120 --> 00:51:09,010
0,420 810,1350 1350,1650 1650,1770 1770,1890
lab,| {} you have some
|你有一些自由，

1607
00:51:09,010 --> 00:51:10,120
0,480 480,570 570,690 690,930 930,1110
freedom| and an easy thing
|容易做的是映射为只读，

1608
00:51:10,120 --> 00:51:11,050
0,90 90,300 300,480 480,630 630,930
to do is just also

1609
00:51:11,050 --> 00:51:12,550
0,240 240,330 330,510 510,900 1230,1500
map {} read only,| you
|你会得到页面错误，

1610
00:51:12,550 --> 00:51:13,510
0,90 90,240 240,300 300,510 510,960
will get a page fault,|
|

1611
00:51:13,840 --> 00:51:15,670
0,390 390,660 660,1260 1290,1440 1440,1830
and then you do whatever
然后，你可以执行在写入时复制时也会执行的操作。

1612
00:51:15,670 --> 00:51:16,630
0,60 60,450 450,660 660,780 780,960
you normally also would do

1613
00:51:16,630 --> 00:51:18,000
0,90 90,150 150,900
in the {copy-on-write}.|
|

1614
00:51:18,030 --> 00:51:18,690
0,180 180,300 300,420 420,570 570,660
So you can use the
所以，在这两种情况下，你可以使用相同的机制。

1615
00:51:18,690 --> 00:51:20,490
0,300 300,960 1170,1440 1440,1590 1590,1800
same mechanism, {} in both

1616
00:51:20,490 --> 00:51:21,540
0,540
cases.|
|

1617
00:51:22,750 --> 00:51:23,830
0,300 300,480 480,750 750,870 870,1080
There's no reason to actually
没有理由对第一个进程专门处理。

1618
00:51:23,830 --> 00:51:26,920
0,540 540,1560 1830,2490 2520,2910 2910,3090
specialize for some separate for

1619
00:51:26,920 --> 00:51:28,520
0,360 360,600 600,1080
the first process.|
|

1620
00:51:30,100 --> 00:51:33,980
0,420 1860,2550 2550,3240
{Okay,thanks}.| So {},
好的，谢谢。|我也有一个问题，

1621
00:51:33,980 --> 00:51:35,150
0,210 210,510 510,630 630,690 690,1170
I also have a question,|
|

1622
00:51:35,150 --> 00:51:37,040
0,540 780,1290 1290,1500 1500,1620 1620,1890
{} given that we like
考虑到我们经常复制整个页面，

1623
00:51:37,040 --> 00:51:39,170
0,270 270,360 360,900 900,1260 1260,2130
kind of copy whole tables,

1624
00:51:39,230 --> 00:51:41,390
0,450 480,900 900,1260 1260,1890 1890,2160
sorry, whole pages around pretty

1625
00:51:41,390 --> 00:51:45,230
0,630 1380,2100 2130,2970 2970,3450 3450,3840
often,| {} does any, like
|存储器硬件有没有实现一个特殊指令，

1626
00:51:45,230 --> 00:51:47,720
0,420 420,900 900,1770 2130,2430 2430,2490
memory hardware implement like a

1627
00:51:47,720 --> 00:51:50,420
0,570 570,1200 1200,1350 1350,2070 2070,2700
specific instruction,| because basically memory
|因为内存硬件通常只有一些行，

1628
00:51:50,570 --> 00:51:52,220
0,600 600,780 780,1140 1140,1410 1410,1650
hardware will usually just have

1629
00:51:52,220 --> 00:51:53,960
0,360 570,930 930,1200 1200,1590 1590,1740
like some data lines| to
|读取或保存内存，

1630
00:51:53,960 --> 00:51:55,490
0,360 360,630 630,810 810,990 990,1530
say read me or stored

1631
00:51:55,880 --> 00:51:58,160
0,540 750,1200 1200,1710 1770,2160 2160,2280
{} just memory,| but we
|但是我们有把 a 页复制到 b 页。

1632
00:51:58,160 --> 00:51:59,990
0,210 210,480 480,690 690,1110 1110,1830
have like [] copy page

1633
00:52:00,080 --> 00:52:03,740
0,300 300,510 510,780 780,1140 2430,3660
a to page b.| Yeah,
|是的， x86 有复制内存范围的硬件指令。

1634
00:52:03,740 --> 00:52:06,380
0,600 600,990 990,1410 1410,2100 2100,2640
x86 example has hardware instructions

1635
00:52:06,380 --> 00:52:08,090
0,330 330,690 690,960 960,1110 1110,1710
for copying range of memory.|
|

1636
00:52:08,560 --> 00:52:10,060
0,900 900,1020 1020,1080 1080,1290 1290,1500
{} You know {RISC-V -}
RISC-V 没有。

1637
00:52:10,060 --> 00:52:12,060
0,480 600,1410
doesn't {}.|
|

1638
00:52:12,180 --> 00:52:13,800
0,600 690,1020 1020,1230 1230,1320 1320,1620
Um, yeah, but of course
是的，当然在非常高性能实现中，

1639
00:52:13,800 --> 00:52:15,390
0,90 90,240 240,720 720,1320 1350,1590
you know in, {} in

1640
00:52:15,390 --> 00:52:17,280
0,120 120,360 360,540 540,960 960,1890
a very high performance implementation,|
|

1641
00:52:17,550 --> 00:52:20,340
0,810 1140,2190 2190,2460 2460,2640 2640,2790
{} {all,the,reads} writes will be
所有读取写入会使用流水线，

1642
00:52:20,340 --> 00:52:23,160
0,270 270,690 1050,1620 1620,2310 2400,2820
{pipelined -},| {} in hopefully
|希望以内存带宽的速度运行。

1643
00:52:23,160 --> 00:52:23,880
0,210 210,330 330,390 390,660 660,720
run at the speed of

1644
00:52:23,880 --> 00:52:25,240
0,90 90,360 360,930
the memory bandwidth.|
|

1645
00:52:28,150 --> 00:52:30,370
0,330 330,480 480,960 960,1560 1560,2220
Note that actually, {} in
注意，原则上，我们会幸运地在加载和存储或复制时[节省]，

1646
00:52:30,370 --> 00:52:31,870
0,570 570,900 900,1080 1080,1170 1170,1500
principle, we might be lucky

1647
00:52:31,870 --> 00:52:33,430
0,120 120,240 240,810 810,1140 1140,1560
and we're saving, correct, on

1648
00:52:33,430 --> 00:52:35,050
0,300 300,390 390,870 870,1020 1020,1620
loads and stores or copies,|
|

1649
00:52:35,290 --> 00:52:36,700
0,360 360,420 420,600 600,900 900,1410
because in this particular picture,
因为在这张图片里，我只复印了一份，

1650
00:52:36,790 --> 00:52:38,080
0,180 180,390 390,570 570,810 810,1290
I made only one copy|
|

1651
00:52:38,140 --> 00:52:40,330
0,510 630,810 810,1080 1140,1830 1830,2190
and in the unmodified case,
而在未修改的情况下，我们会复制全部四页。

1652
00:52:40,360 --> 00:52:41,320
0,180 180,300 300,420 420,720 720,960
we would have copied all

1653
00:52:41,320 --> 00:52:42,560
0,240 240,810
four pages.|
|

1654
00:52:43,120 --> 00:52:44,650
0,210 210,360 360,900 900,1200 1200,1530
And so, hopefully this is
所以，无论是在存储器消耗方面还是在性能方面，这是更好的，

1655
00:52:44,710 --> 00:52:46,300
0,480 480,900 930,1260 1260,1350 1350,1590
strictly better, both in terms

1656
00:52:46,300 --> 00:52:47,800
0,90 90,330 330,900 900,1290 1290,1500
of memory consumption and in

1657
00:52:47,800 --> 00:52:49,150
0,270 270,330 330,960 1110,1290 1290,1350
terms of performance,| {you,know} fork
|fork 会更快。

1658
00:52:49,150 --> 00:52:50,540
0,180 180,360 360,420 420,870
will just be faster.|
|

1659
00:52:54,090 --> 00:52:55,290
0,120 120,240 240,360 360,630 630,1200
I have a quick question,|
我有一个问题，|

1660
00:52:55,470 --> 00:52:58,650
0,480 900,1590 1680,2280 2280,2850 2880,3180
{} when when the page
当页面错误发生时，

1661
00:52:58,650 --> 00:53:00,300
0,240 240,720 720,1080 1080,1350 1350,1650
fault occurs| and we see
|我们看到本质上是我们试图写入只读地址，

1662
00:53:00,300 --> 00:53:02,610
0,330 360,600 600,1050 1050,1740 1860,2310
that it was essentially like

1663
00:53:02,610 --> 00:53:03,480
0,120 120,210 210,510 510,660 660,870
we were trying to write

1664
00:53:03,480 --> 00:53:04,620
0,150 150,240 240,420 420,630 630,1140
to a read only address,|
|

1665
00:53:04,830 --> 00:53:06,030
0,300 300,510 510,720 720,840 840,1200
{} how does the kernel
内核是如何知道这是一种写入时复制 fork 的情况，

1666
00:53:06,030 --> 00:53:08,100
0,720 750,1320 1470,1800 1800,1950 1950,2070
tell, {} like this is

1667
00:53:08,100 --> 00:53:09,630
0,480 480,1020 1020,1110 1110,1230 1230,1530
a situation where it's {copy-on-write

1668
00:53:09,630 --> 00:53:11,010
0,150 150,360 360,750 810,1170 1170,1380
- -} fork| versus just
|而不是试图写入因为某些合法原因标记位只读的内存，

1669
00:53:11,010 --> 00:53:12,240
0,30 30,630 630,870 870,960 960,1230
a situation where the memory

1670
00:53:12,240 --> 00:53:12,990
0,90 90,210 210,420 420,510 510,750
it was trying to write

1671
00:53:12,990 --> 00:53:14,250
0,330 330,510 510,840 840,1050 1050,1260
was was marked as read

1672
00:53:14,250 --> 00:53:16,560
0,270 270,450 450,960 1170,2010 2010,2310
only for some legitimate reason|
|

1673
00:53:16,560 --> 00:53:17,580
0,240 240,390 390,660 660,780 780,1020
other than {copy-on-write - -}
而不是写入时复制 fork ，

1674
00:53:17,580 --> 00:53:18,480
0,240 240,450 450,660 660,840 840,900
fork| is just kind of
|在内存中是一种不变量，

1675
00:53:18,480 --> 00:53:21,060
0,150 150,840 840,1140 1410,2100 2130,2580
an invariance that if a

1676
00:53:21,060 --> 00:53:22,230
0,270 270,510 510,840 840,990 990,1170
its user memory,| then it
|然后它被映射为读写，除非它是写入时复制 fork 的结果。

1677
00:53:22,230 --> 00:53:23,490
0,300 300,420 420,780 780,990 990,1260
will be mapped read write,

1678
00:53:23,490 --> 00:53:24,660
0,420 420,510 510,720 720,870 870,1170
unless it was a result

1679
00:53:24,660 --> 00:53:25,660
0,60 60,330 330,480 480,720
of {copy-on-write -} fork.|
|

1680
00:53:25,880 --> 00:53:27,920
0,450 450,780 1140,1440 1440,1740 1740,2040
Yeah {} yeah, so it
是的，所以它是一个需要在内核中维护的不变量，

1681
00:53:27,920 --> 00:53:29,510
0,180 180,600 600,1260 1260,1410 1410,1590
is an invariant that needs

1682
00:53:29,510 --> 00:53:30,320
0,90 90,210 210,660 660,750 750,810
to be maintained in the

1683
00:53:30,320 --> 00:53:31,790
0,390 390,510 510,810 840,1170 1170,1470
kernel| and the kernel must
|内核必须以某种方式识别这是写入时复制页面，

1684
00:53:31,790 --> 00:53:32,930
0,420 420,480 480,720 720,990 990,1140
recognize in some way that

1685
00:53:32,930 --> 00:53:33,680
0,150 150,270 270,330 330,630 630,750
this is a {copy-on-write -

1686
00:53:33,680 --> 00:53:34,730
0,240 240,480 480,630 630,750 750,1050
-} page, if you will.|
|

1687
00:53:35,340 --> 00:53:36,660
0,480 630,810 810,930 930,1110 1110,1320
{} And so I'm very
我很高兴你问了这个问题，

1688
00:53:36,660 --> 00:53:37,500
0,210 210,270 270,420 420,480 480,840
glad you asked the question,|
|

1689
00:53:37,500 --> 00:53:39,210
0,480 570,630 720,1200 1200,1590 1590,1710
because it turns out you
因为 RISC-V 硬件，几乎所有的可分页硬件都支持这一点。

1690
00:53:39,210 --> 00:53:40,680
0,120 120,450 450,660 660,990 990,1470
know the {RISC-V -} hardware,

1691
00:53:40,680 --> 00:53:42,060
0,270 270,510 510,720 720,990 990,1380
almost all {pagetable -} hardware

1692
00:53:42,060 --> 00:53:43,290
0,240 240,360 360,720 720,810 810,1230
actually has support for this.|
|

1693
00:53:43,870 --> 00:53:45,700
0,780 780,1080 1110,1350 1350,1560 1560,1830
{} And we didn't mention
我们之前没有提过，

1694
00:53:45,700 --> 00:53:47,020
0,90 90,480 480,630 630,930 930,1320
it earlier,| but here's are
|我们使用的两级或多级的页表都使用 pte ，

1695
00:53:47,080 --> 00:53:48,940
0,1080 1110,1230 1230,1320 1320,1710 1710,1860
usual you know, whatever two

1696
00:53:48,940 --> 00:53:51,340
0,540 630,1080 1080,1320 1320,2190 2190,2400
level, {} or multilevel {pagetable

1697
00:53:51,340 --> 00:53:53,620
0,510 630,960 960,1740
-} use pte,|
|

1698
00:53:56,040 --> 00:53:57,540
0,600 780,930 930,1140 1140,1260 1260,1500
and you're looking at {pte
你看到的 pte ，我讲过 0 到 7 的标志位，

1699
00:53:57,540 --> 00:53:58,380
0,270 270,390 390,450 450,540 540,840
-}, you know I talked

1700
00:53:58,380 --> 00:53:59,610
0,240 240,330 330,690 690,810 810,1230
about the bits you know

1701
00:53:59,730 --> 00:54:01,350
0,420 420,750 750,930 930,1440 1470,1620
one zero through seven,| but
|但没讲过这两个位， RSW 。

1702
00:54:01,350 --> 00:54:02,940
0,480 510,810 810,1020 1020,1170 1170,1590
not about these two bits,

1703
00:54:03,270 --> 00:54:04,620
0,270 270,840
{RSW -}.|
|

1704
00:54:06,190 --> 00:54:08,440
0,540 570,900 900,1170 1170,1590 1590,2250
And, {} they are reserved
它们是为管理软件保留的。

1705
00:54:08,440 --> 00:54:10,200
0,120 120,660 660,1200
for supervisor software.|
|

1706
00:54:10,200 --> 00:54:12,450
0,630 720,870 870,1320 1320,1920 1950,2250
So the supervisor software, this
所以管理软件，内核可以随意使用这些位。

1707
00:54:12,450 --> 00:54:14,250
0,120 120,210 210,720 990,1680 1680,1800
is the kernel, {} you

1708
00:54:14,250 --> 00:54:15,630
0,300 300,540 540,720 720,1140 1140,1380
can use these bits at

1709
00:54:15,630 --> 00:54:17,520
0,540 540,810 810,930 930,1380
its own free will.|
|

1710
00:54:17,550 --> 00:54:18,780
0,240 240,360 360,600 600,810 810,1230
And so one thing one
所以可以做的一件事是

1711
00:54:18,780 --> 00:54:20,040
0,120 120,450 450,780 780,990 990,1260
could do is| like say
|决定是一个写入时复制页面还是写入时复制错误。

1712
00:54:20,040 --> 00:54:21,330
0,420 420,540 540,690 720,930 930,1290
decide that being a basically

1713
00:54:21,330 --> 00:54:22,410
0,240 240,390 390,450 450,510 510,1080
means this is a {copy-on-write}

1714
00:54:22,410 --> 00:54:24,460
0,390 420,570 570,1140 1140,1560
page or {copy-on-write} fault.|
|

1715
00:54:24,610 --> 00:54:25,810
0,150 150,300 300,480 480,540 540,1200
And so when the kernel
所以当内核把这些页表用于写入时复制，

1716
00:54:26,110 --> 00:54:29,620
0,1170 1170,1530 1530,1800 1800,2520 2790,3510
programs these page tables for

1717
00:54:29,650 --> 00:54:31,180
0,150 150,960 960,1260 1260,1350 1350,1530
{} copy-on-write,| you can just
|你可以直接设置这些页面的 pte 的位，

1718
00:54:31,180 --> 00:54:32,740
0,300 300,600 600,690 690,1470 1470,1560
put on the ptes, you

1719
00:54:32,740 --> 00:54:34,180
0,120 120,330 330,510 510,840 840,1440
know for these particular pages,

1720
00:54:34,640 --> 00:54:37,370
0,450 450,690 840,1680 1680,2220 2250,2730
{ - - -} {the,bits},|
|

1721
00:54:37,370 --> 00:54:38,060
0,90 90,180 180,360 360,450 450,690
you know set to be
设置为写入时复制，

1722
00:54:38,090 --> 00:54:39,650
0,270 270,1080 1110,1260 1260,1380 1380,1560
a copy-on-write,| so that when
|在发生页面错误时，

1723
00:54:39,650 --> 00:54:41,840
0,120 150,600 600,780 780,1380 1620,2190
the page fault happens| and
|我们看到设置了写入时复制位，

1724
00:54:41,960 --> 00:54:43,220
0,270 270,480 480,600 600,660 660,1260
we see that the copy-on-write

1725
00:54:43,220 --> 00:54:44,990
0,300 300,870 960,1500 1500,1620 1620,1770
bit set,| then we just
|那我们到这里（之前的情况），

1726
00:54:44,990 --> 00:54:46,320
0,150 150,330 330,510 510,900
go off into this,|
|

1727
00:54:46,780 --> 00:54:47,710
0,150 150,540 540,630 630,720 720,930
and otherwise we do something
否则我们就做些别的事，比如，可能是懒分配。

1728
00:54:47,710 --> 00:54:48,580
0,360
else,

1729
00:54:49,970 --> 00:54:50,960
0,120 120,420 420,600 600,720 720,990
for example, maybe the lazy

1730
00:54:50,960 --> 00:54:52,160
0,600
allocation.|
|

1731
00:54:54,310 --> 00:54:55,580
0,120 120,210 210,330 330,660
Does that make sense?|
这能理解吗？|

1732
00:54:56,450 --> 00:54:57,800
0,240 240,510 510,780
Yep, thank you.|
好的，谢谢你。|

1733
00:54:57,980 --> 00:54:59,990
0,150 150,210 210,450 450,810 810,2010
And in fact in {}
实际上，在实验中，你要做的一件事是，

1734
00:54:59,990 --> 00:55:01,340
0,360 360,480 480,930 930,1290 1290,1350
in the lab, one of

1735
00:55:01,340 --> 00:55:01,940
0,90 90,240 240,360 360,510 510,600
the things you will be

1736
00:55:01,940 --> 00:55:03,350
0,330 330,480 480,870 870,1170 1170,1410
doing is| probably use that
|使用这个位在 pte 中设置写入时复制。

1737
00:55:03,350 --> 00:55:04,340
0,300 300,450 450,660 690,960 960,990
bit you know set a

1738
00:55:04,340 --> 00:55:06,600
0,570 570,930 930,1200 1230,1680
copy-on-write in the pte.|
|

1739
00:55:07,380 --> 00:55:09,240
0,480 720,930 930,1110 1110,1350 1350,1860
{} There's one more []
还有一个[]将在写入时复制实验中显示出来，

1740
00:55:09,270 --> 00:55:10,410
0,240 240,420 420,630 630,840 840,1140
that will show up in

1741
00:55:10,410 --> 00:55:12,030
0,630 660,1170 1170,1320 1320,1440 1440,1620
the {copy-on-write -} lab| is
|目前在 xv6 中，一个物理页面或多或少只属于一个进程，

1742
00:55:12,030 --> 00:55:14,460
0,240 420,930 930,1440 1680,2340 2340,2430
that there's some currently in

1743
00:55:14,460 --> 00:55:16,980
0,750 750,1620 1620,1740 1740,2100 2100,2520
xv6, basically a physical page

1744
00:55:17,070 --> 00:55:18,870
0,600 600,660 660,960 960,1350 1350,1800
more or less only belongs

1745
00:55:18,870 --> 00:55:20,820
0,90 90,780 870,1560
to one process,|
|

1746
00:55:20,820 --> 00:55:21,660
0,210 210,270 270,690 690,780 780,840
with the exception of the
除了 trampoline 页面，它从来不会被释放，

1747
00:55:21,660 --> 00:55:24,150
0,450 450,960 1500,1800 1800,1950 1950,2490
trampoline page, which that trampoline

1748
00:55:24,150 --> 00:55:25,230
0,90 90,360 360,690 690,840 840,1080
were never free,| so that's
|所以这不是一个特别大的问题。

1749
00:55:25,230 --> 00:55:26,070
0,210 210,420 420,540 540,600 600,840
not really going to a

1750
00:55:26,070 --> 00:55:27,540
0,330 330,510 510,960
particular big issue.|
|

1751
00:55:27,630 --> 00:55:29,190
0,450 480,720 720,810 810,1050 1050,1560
{} But for these pages
但是，对于那些有多个进程或者多个地址指向相同物理地址的页面，

1752
00:55:29,190 --> 00:55:31,300
0,210 210,750 750,900 900,1500
you now we have

1753
00:55:31,300 --> 00:55:33,490
0,480 480,1380 1440,1590 1590,1950 1950,2190
multiple processes or multiple address

1754
00:55:33,490 --> 00:55:34,750
0,450 450,780 780,870 870,960 960,1260
spaces pointing to the same

1755
00:55:34,750 --> 00:55:36,180
0,360 360,930
physical address,|
|

1756
00:55:36,180 --> 00:55:36,870
0,90 90,180 180,240 240,600 600,690
and so, for example if
比如，如果父进程立即退出，

1757
00:55:36,870 --> 00:55:38,800
0,90 90,660 720,1440
the parent exits

1758
00:55:38,800 --> 00:55:40,240
0,510 510,930 930,1050 1050,1200 1200,1440
right away,| we're gonna live
|我们就要小心，

1759
00:55:40,240 --> 00:55:41,260
0,90 90,390 390,510 510,630 630,1020
with care and be careful

1760
00:55:41,260 --> 00:55:42,970
0,390 390,780 1110,1320 1320,1470 1470,1710
right,| because can we free
|因为如果父进程退出，我们能立即释放那一页吗。

1761
00:55:42,970 --> 00:55:44,560
0,180 180,420 420,1020
that page immediately,

1762
00:55:44,560 --> 00:55:46,080
0,90 90,180 180,450 450,1020
if the parent exits.|
|

1763
00:55:50,520 --> 00:55:52,290
0,690 690,1050 1050,1440 1440,1590 1590,1770
Maybe not, because there may
可能不能，因为可能有多个子进程。

1764
00:55:52,290 --> 00:55:55,200
0,240 240,750 750,1800 1800,2520 2520,2910
be multiple children processes.| Yeah,
|是啊，可能有子进程在用那个页面，

1765
00:55:55,200 --> 00:55:56,550
0,180 180,330 330,450 450,1020 1020,1350
there might be child using

1766
00:55:56,550 --> 00:55:57,930
0,120 120,450 450,630 630,750 750,1380
that page| and so we've
|内核将释放该页面，那么我们会有麻烦，

1767
00:55:58,200 --> 00:55:59,460
0,270 270,450 450,630 630,780 780,1260
kernel would free that page,

1768
00:55:59,580 --> 00:56:01,740
0,870 990,1770 1770,1920 1920,2010 2010,2160
then, {} you know we're

1769
00:56:01,740 --> 00:56:03,030
0,120 120,240 240,300 300,750 780,1290
gonna be in trouble,| because
|因为如果你看一下 kfree ，

1770
00:56:03,030 --> 00:56:04,710
0,480 480,930 1230,1380 1380,1530 1530,1680
basically the if you look

1771
00:56:04,710 --> 00:56:05,880
0,90 90,360 360,720 720,960 960,1170
at {kfree -},| {kfree -}
|一旦释放页面， kfree 会写入所有[类型]，

1772
00:56:05,880 --> 00:56:07,650
0,540 540,1050 1050,1170 1170,1350 1350,1770
actually writes all kinds once

1773
00:56:07,650 --> 00:56:09,450
0,300 300,450 450,660 660,1230 1530,1800
on a free page| and
|然后子进程使用那一页运行，

1774
00:56:09,450 --> 00:56:10,380
0,180 180,360 360,450 450,720 720,930
so then the child runs

1775
00:56:10,380 --> 00:56:11,130
0,90 90,240 240,480 480,600 600,750
with that page| and all
|各种奇怪的事情就会发生。

1776
00:56:11,130 --> 00:56:11,880
0,180 180,240 240,570 570,750 750,750
kinds of bizarre things are

1777
00:56:11,880 --> 00:56:12,840
0,210 210,570
gonna happen.|
|

1778
00:56:14,040 --> 00:56:15,330
0,210 210,660 660,810 810,1080 1080,1290
So what should you be
那么，现在释放应该怎么做呢？

1779
00:56:15,330 --> 00:56:16,700
0,180 180,330 330,750
now for free.|
|

1780
00:56:23,450 --> 00:56:25,940
0,480 480,1260 1290,1800 1800,2130 2160,2490
{} Free, if you don't
我想是在没有子进程的情况下释放。

1781
00:56:25,940 --> 00:56:28,910
0,420 420,1320 1650,1830 1830,2430 2460,2970
have children, I guess.| Yeah,
|是的，我们用更一般的方式来解释这一说法，

1782
00:56:28,910 --> 00:56:29,930
0,330 330,480 480,690 690,750 750,1020
we may be {} better

1783
00:56:29,930 --> 00:56:30,500
0,180 180,300 300,450 450,510 510,570
way of sort of a

1784
00:56:30,500 --> 00:56:31,580
0,210 210,480 480,780 780,870 870,1080
more general version of that

1785
00:56:31,580 --> 00:56:32,840
0,450 450,540 540,630 630,870 870,1260
statement| is to say well
|就是我们需要做的是，每个物理页面有一个 ref 计数。

1786
00:56:32,870 --> 00:56:33,530
0,180 180,240 240,420 420,570 570,660
what we really need to

1787
00:56:33,530 --> 00:56:34,670
0,540 600,780 780,900 900,1080 1080,1140
do is we need a

1788
00:56:34,670 --> 00:56:35,940
0,240 240,780
ref count

1789
00:56:38,790 --> 00:56:40,560
0,360 360,660 660,1140
every physical page.|
|

1790
00:56:41,130 --> 00:56:42,240
0,390 390,690 690,870 870,1020 1020,1110
And when we free the
当我们释放页面时，我们将引用减少 1 ，

1791
00:56:42,240 --> 00:56:44,160
0,390 390,960 990,1650 1650,1710 1710,1920
page, we decrease the ref

1792
00:56:44,160 --> 00:56:45,420
0,210 210,330 330,840 1020,1170 1170,1260
down by one| and if
|如果引用计数达到零，那么我们就可以释放页面了。

1793
00:56:45,420 --> 00:56:46,680
0,60 60,270 270,540 540,840 840,1260
the ref count reaches zero,

1794
00:56:46,680 --> 00:56:47,700
0,300 300,630 630,750 750,870 870,1020
then actually we can free

1795
00:56:47,700 --> 00:56:48,720
0,60 60,570
the page.|
|

1796
00:56:48,940 --> 00:56:49,900
0,390 390,540 540,660 660,780 780,960
And so you will have
所以，你必须在写入时复制中引入一些额外的数据结构或元信息，

1797
00:56:49,900 --> 00:56:51,700
0,90 90,840 840,1110 1110,1560 1560,1800
to introduce some additional data

1798
00:56:51,700 --> 00:56:53,620
0,480 480,630 630,1320 1320,1800 1800,1920
structure or meta information in

1799
00:56:53,620 --> 00:56:55,870
0,90 90,660 660,1770 1770,2160 2160,2250
the copy-on-write,| [] actually do
|用来做引用计数。

1800
00:56:55,870 --> 00:56:57,020
0,180 180,360 360,690
that ref counting.|
|

1801
00:56:59,740 --> 00:57:00,820
0,270 270,390 390,510 510,840 840,1080
Where can we store this,|
我们把这个存放在哪里，|

1802
00:57:00,820 --> 00:57:01,900
0,210 210,480 480,720 720,810 810,1080
because this if we ever
因为如果每一页都有引用计数，这会是很多。

1803
00:57:01,900 --> 00:57:03,130
0,270 270,360 360,630 630,990 990,1230
have the ref count every

1804
00:57:03,130 --> 00:57:04,300
0,360 360,720 720,930 930,1050 1050,1170
single page, that can be

1805
00:57:04,300 --> 00:57:06,730
0,120 120,540 1020,1590 1590,2010 2280,2430
a lot.| Yeah well for
|是的，对于内存的每一个物理页面，我们必须有引用计数。

1806
00:57:06,730 --> 00:57:07,990
0,300 300,660 660,870 870,960 960,1260
every physical page of memory,

1807
00:57:07,990 --> 00:57:08,830
0,420 420,510 510,660 660,720 720,840
we will have to do

1808
00:57:08,830 --> 00:57:10,040
0,60 60,210 210,690
a ref count.|
|

1809
00:57:10,760 --> 00:57:11,690
0,270 270,480 480,570 570,720 720,930
Yeah, you can get away
是的，你可以少一点，

1810
00:57:11,690 --> 00:57:12,470
0,180 180,240 240,450 450,570 570,780
with a little bit less,|
|

1811
00:57:12,470 --> 00:57:13,550
0,120 120,360 360,540 540,900 930,1080
but then we're in for
但在实验里进行简化，

1812
00:57:13,550 --> 00:57:15,050
0,180 180,660 660,990 990,1140 1140,1500
{} simplification {in,lab},| we're just
|对于每 4096 字节，

1813
00:57:15,050 --> 00:57:17,780
0,150 150,840 1230,1560 1560,1740 1740,2730
for everyone for every 4096

1814
00:57:17,780 --> 00:57:18,820
0,570
bytes,|
|

1815
00:57:18,820 --> 00:57:19,600
0,150 150,300 300,420 420,750 750,780
we need to contain a
我们需要包含一个引用计数。

1816
00:57:19,600 --> 00:57:20,800
0,300 300,660
reference count.|
|

1817
00:57:23,630 --> 00:57:25,310
0,390 390,750 750,1080 1080,1230 1230,1680
Can we write that down
我们能不能把它写在另外两个空闲位上，然后说，不超过 4 。

1818
00:57:25,310 --> 00:57:27,140
0,180 180,480 480,990 990,1230 1230,1830
in those other two free

1819
00:57:27,170 --> 00:57:29,420
0,720 720,1110 1110,1290 1290,1710
bits and say that,

1820
00:57:29,600 --> 00:57:36,020
0,600 990,1860 2280,2910 3030,4740 4740,6420
{no,more,than} four.| {} Good yeah,
|很好，不是不合理，

1821
00:57:36,380 --> 00:57:39,590
0,1410 1410,1920 1920,2310 2340,3030 3030,3210
not unreasonable,| but {} you
|但是如果你把它 fork 多次，

1822
00:57:39,590 --> 00:57:40,340
0,210 210,330 330,510 510,660 660,750
know if you're fork it

1823
00:57:40,340 --> 00:57:41,640
0,300 300,870
multiple times,|
|

1824
00:57:41,640 --> 00:57:42,990
0,270 270,510 510,660 660,990 1020,1350
that be too bad, right,|
那就太糟糕了，|

1825
00:57:44,320 --> 00:57:45,670
0,300 300,540 540,960 960,1170 1170,1350
after three times or four
三四次之后，你就不能再做优化了。

1826
00:57:45,670 --> 00:57:46,840
0,240 240,330 330,780 780,930 930,1170
times, you can't do can't

1827
00:57:46,840 --> 00:57:48,480
0,90 90,210 210,750 750,1110
do the optimization anymore.|
|

1828
00:57:52,120 --> 00:57:53,890
0,510 630,1020 1020,1140 1140,1440 1440,1770
Yeah there's some freedom here.|
是的，这里有一些自由。|

1829
00:57:54,960 --> 00:57:57,570
0,240 240,1020 1020,1560 1890,2130 2130,2610
{} Also, {} do you
还有，你真的需要用那个位来指定它是不是写入时复制，

1830
00:57:57,570 --> 00:57:58,740
0,330 330,540 540,630 630,870 870,1170
really need to use that

1831
00:57:58,740 --> 00:58:00,180
0,360 360,570 570,1110 1110,1290 1290,1440
bit to specify if it's

1832
00:58:00,180 --> 00:58:01,650
0,90 90,390 390,570 570,870 870,1470
a {copy-on-write - -},| because
|因为内核也可以维护有关进程的一些信息。

1833
00:58:01,890 --> 00:58:04,890
0,330 330,720 720,900 900,1530 1980,3000
the kernel could also maintain

1834
00:58:04,890 --> 00:58:07,530
0,450 480,1290 1290,1710 1710,1830 1830,2640
some information about the processes

1835
00:58:07,530 --> 00:58:08,400
0,330
that.|
|

1836
00:58:08,430 --> 00:58:11,010
0,150 150,1140 1410,1980 1980,2310 2310,2580
Yeah yeah yeah, you could
是的，你可以做任何事，

1837
00:58:11,010 --> 00:58:11,880
0,90 90,180 180,360 360,720 720,870
you could do anything,| some
|一些其他事项信息连同进程地址空间，

1838
00:58:11,880 --> 00:58:13,260
0,210 210,420 420,900 900,1200 1200,1380
other matter information along with

1839
00:58:13,260 --> 00:58:14,550
0,300 300,630 630,900 900,1200 1200,1290
the process address space| to
|比如在这个和那个之间的虚拟地址是文本地址，

1840
00:58:14,550 --> 00:58:16,380
0,210 210,540 540,1020 1050,1470 1470,1830
say basically well virtual addresses

1841
00:58:16,380 --> 00:58:17,250
0,300 300,450 450,540 540,780 780,870
between this and that are

1842
00:58:17,250 --> 00:58:18,990
0,300 300,930 1230,1560 1560,1650 1650,1740
text addresses,| so we have
|所以，我们在那里有一个页面错误，它一定是写入时复制或其他什么。

1843
00:58:18,990 --> 00:58:20,460
0,90 90,420 420,840 840,990 990,1470
a {page,fault} there and it

1844
00:58:20,460 --> 00:58:22,170
0,240 240,630 630,1260 1290,1380 1380,1710
must be copy-on-write or something.|
|

1845
00:58:23,090 --> 00:58:24,260
0,510 540,720 720,930 930,1080 1080,1170
{} In fact one of
实际上，后来的一个实验里，

1846
00:58:24,260 --> 00:58:25,190
0,90 90,300 300,690 690,780 780,930
the later labs,| you know
|你会扩展 xv6 维护的元信息，正是这个原因。

1847
00:58:25,190 --> 00:58:28,070
0,570 570,930 930,1470 1860,2490 2490,2880
you'll certainly extend {} the

1848
00:58:28,100 --> 00:58:29,420
0,240 240,690 690,840 840,1080 1080,1320
meta information that {xv6 -}

1849
00:58:29,420 --> 00:58:30,580
0,720
maintains,

1850
00:58:30,640 --> 00:58:32,120
0,360 360,450 450,630 630,900
exactly for that reason.|
|

1851
00:58:34,110 --> 00:58:34,890
0,240 240,300 300,420 420,480 480,780
There's a bit of freedom
这里有一些自由，当你开始实现这些实验时。

1852
00:58:34,890 --> 00:58:36,060
0,330 420,660 660,870 870,990 990,1170
here and when you start

1853
00:58:36,060 --> 00:58:37,520
0,360 360,540 540,960
implementing these labs.|
|

1854
00:58:41,040 --> 00:58:42,330
0,240 240,450 450,750 750,960 960,1290
Any further questions about this?|
关于这个，还有什么问题吗？|

1855
00:59:03,900 --> 00:59:06,060
0,630 1080,1590 1620,1920 1920,2040 2040,2160
Okay, {} let's go to
好的，让我们进入下一个，叫做按需调页，

1856
00:59:06,060 --> 00:59:07,380
0,60 60,270 270,510 690,1110 1110,1320
the next one, {} there's

1857
00:59:07,380 --> 00:59:10,040
0,300 300,870 930,1560 1560,2040
something called demand paging,|
|

1858
00:59:11,350 --> 00:59:13,060
0,480 480,810 810,1140 1140,1530 1530,1710
another very popular one in
是另一个在大多数操作系统中非常流行的。

1859
00:59:13,060 --> 00:59:15,160
0,240 240,600 600,960 960,1530
most operating systems implemented.|
|

1860
00:59:15,830 --> 00:59:16,980
0,630

1861
00:59:17,100 --> 00:59:18,990
0,180 180,480 480,1230 1680,1800 1800,1890
And so the you know
所以，它是回到了 exec 。

1862
00:59:18,990 --> 00:59:20,100
0,180 180,330 330,510 510,810 810,1110
it just goes back basically

1863
00:59:20,100 --> 00:59:21,620
0,360 360,990
to exec.|
|

1864
00:59:24,220 --> 00:59:27,190
0,330 330,900 900,1020 1020,1770 1770,2970
So currently in unmodified xv6,|
目前在未修改的 xv6 中，|

1865
00:59:27,190 --> 00:59:29,320
0,120 120,270 270,870 870,1530
you know xv6 loads
xv6 加载文本段，和数据段，

1866
00:59:29,350 --> 00:59:31,020
0,240 240,450 450,990
the text segment,

1867
00:59:32,250 --> 00:59:34,860
0,330 330,420 420,660 660,1260 1680,2610
and the data segment profile|
|

1868
00:59:34,950 --> 00:59:36,700
0,270 270,600 600,1170
and maps in
并急切地映射到页表中。

1869
00:59:37,250 --> 00:59:40,020
0,750 1110,1500 1500,2160
eagerly in basically

1870
00:59:40,620 --> 00:59:42,100
0,390 390,840
into the

1871
00:59:42,100 --> 00:59:43,340
0,270 270,690
{pagetable -}.|
|

1872
00:59:46,960 --> 00:59:48,850
0,510 510,900 900,990 990,1410 1410,1890
And basically the same observation
和我们对懒分配和置零观察到的一样，

1873
00:59:48,850 --> 00:59:50,110
0,120 120,210 210,480 480,630 630,1260
that we made for lazy

1874
00:59:50,110 --> 00:59:51,880
0,240 240,570 570,1140 1260,1560 1560,1770
and zero filled,| is that
|我们可以做的是，为什么要急切地去做，

1875
00:59:51,880 --> 00:59:53,140
0,570 690,930 930,1020 1020,1110 1110,1260
well what we could do

1876
00:59:53,140 --> 00:59:54,070
0,150 150,300 300,540 540,690 690,930
is like why do it

1877
00:59:54,070 --> 00:59:55,690
0,360 420,870 870,1200 1200,1470 1470,1620
eagerly,| why not just wait
|为什么不等一会儿，直到看到应用程序是否真的需要，

1878
00:59:55,690 --> 00:59:57,610
0,60 60,240 240,690 1020,1800 1800,1920
a little while, until to

1879
00:59:57,610 --> 00:59:59,080
0,270 270,450 450,750 750,1020 1020,1470
see if actually the application

1880
00:59:59,080 --> 01:00:00,430
0,210 210,870 870,990 990,1110 1110,1350
really needs,| you know those
|那些特别的指令，二进制文件可能会很大。

1881
01:00:00,430 --> 01:00:01,780
0,390 390,540 540,630 630,1230 1230,1350
particular set of instructions, you

1882
01:00:01,780 --> 01:00:03,370
0,540 570,990 990,1200 1200,1290 1290,1590
know {the,binary} might be very

1883
01:00:03,370 --> 01:00:04,180
0,390
big.|
|

1884
01:00:04,270 --> 01:00:06,100
0,450 450,1080 1110,1380 1380,1680 1680,1830
{} In {} instead of
不是真的从磁盘中全部加载进去，

1885
01:00:06,100 --> 01:00:08,710
0,690 930,1770 1800,2280 2280,2430 2430,2610
actually {} loading it all

1886
01:00:08,710 --> 01:00:09,730
0,300 330,450 450,570 570,720 720,1020
in you know from disk,|
|

1887
01:00:09,730 --> 01:00:10,630
0,120 120,330 330,390 390,480 480,900
it tends to be expensive
它往往是昂贵的操作，

1888
01:00:10,630 --> 01:00:12,820
0,810 1110,1620 1620,1860 1860,1950 1950,2190
operation,| {} maybe the data
|可能数据段比实际需要的要大得多，

1889
01:00:12,820 --> 01:00:13,870
0,300 300,360 360,600 600,840 840,1050
segment is much bigger than

1890
01:00:13,870 --> 01:00:15,550
0,210 210,660 660,840 840,1050 1260,1680
really needs than the typical

1891
01:00:15,550 --> 01:00:17,890
0,270 270,750 780,1800 1890,2130 2130,2340
use case requires,| we don't
|我们没必要这么做。

1892
01:00:17,890 --> 01:00:18,970
0,270 270,540 540,630 630,750 750,1080
really have to do that.|
|

1893
01:00:19,700 --> 01:00:21,680
0,180 180,570 600,960 960,1200 1590,1980
And so instead of {},
所以，在 exec 中，不是真正分配虚拟地址空间，

1894
01:00:21,680 --> 01:00:23,840
0,180 180,750 1080,1410 1410,1530 1530,2160
on exec, instead of actually

1895
01:00:23,900 --> 01:00:25,250
0,390 390,750 750,840 840,1140 1140,1350
we allocate the virtual address

1896
01:00:25,250 --> 01:00:26,540
0,420 420,480 480,720 720,1230 1230,1290
space,| you know allocate the
|为文件里的文本和数据分配地址空间，

1897
01:00:26,540 --> 01:00:28,970
0,480 480,900 1050,1440 1800,1920 1920,2430
address space for the text

1898
01:00:28,970 --> 01:00:30,890
0,480 480,810 1140,1470 1470,1710 1710,1920
{and,the,data} {} {} that's in

1899
01:00:30,890 --> 01:00:32,600
0,90 90,690 810,1200 1200,1560 1560,1710
the file,| {} but in
|但在 pte 中并没有全部映射，

1900
01:00:32,600 --> 01:00:34,880
0,90 90,930 1110,1560 1560,2010 2010,2280
the ptes were not mapped

1901
01:00:34,880 --> 01:00:36,650
0,540 810,1110 1110,1260 1260,1410 1410,1770
all,| we're just gonna keep
|我们只会保留其中一页，

1902
01:00:36,650 --> 01:00:38,450
0,420 420,1140 1140,1560 1560,1740 1740,1800
{you,know} pte for one of

1903
01:00:38,450 --> 01:00:39,980
0,150 150,570 570,870 870,1080 1080,1530
these pages,| we just cannot
|我们不能设置有效位，因此有效位为零。

1904
01:00:39,980 --> 01:00:41,600
0,150 150,690 690,870 870,1410 1410,1620
set {valid,bit}, so {valid,bit} to

1905
01:00:41,600 --> 01:00:42,420
0,420
zero.|
|

1906
01:00:44,180 --> 01:00:45,470
0,420 420,810 810,900 900,1200 1200,1290
{} And of course you
当然，在我们得到第一个页面错误时，

1907
01:00:45,470 --> 01:00:46,730
0,60 60,330 330,840 840,1020 1020,1260
know, when we're gonna get

1908
01:00:46,730 --> 01:00:48,540
0,120 120,570 600,870 870,1290
our first page fault,|
|

1909
01:00:49,840 --> 01:00:50,740
0,270 270,360 360,480 480,750 750,900
if we do this in
如果我们在 exec 中这样做，比如修改 xv6 来做这个。

1910
01:00:50,740 --> 01:00:52,090
0,510 540,900 900,1080 1080,1230 1230,1350
exec and let's say we

1911
01:00:52,090 --> 01:00:53,110
0,420 420,600 600,840 840,930 930,1020
modify {xv6 -} to do

1912
01:00:53,110 --> 01:00:54,060
0,420
this.|
|

1913
01:00:54,350 --> 01:00:55,400
0,270 270,420 420,540 540,930 930,1050
When will our first page
当第一个页面错误发生时，

1914
01:00:55,400 --> 01:00:56,620
0,270 270,660
fault happen,|
|

1915
01:00:59,900 --> 01:01:01,250
0,330 330,540 540,810 810,1230 1230,1350
what's the first instruction that
为用户地址或用户程序运行的第一条指令是什么。

1916
01:01:01,250 --> 01:01:02,420
0,90 90,270 270,720 720,900 900,1170
is being run for user

1917
01:01:02,420 --> 01:01:03,420
0,510
address

1918
01:01:05,310 --> 01:01:06,780
0,210 210,390 390,450 450,990
or {user -} program.|
或用户程序。|

1919
01:01:09,690 --> 01:01:10,650
0,240 240,390 390,450 450,660 660,960
Where does the user program
用户程序从哪里开始。

1920
01:01:10,650 --> 01:01:11,680
0,480
start.|
|

1921
01:01:12,220 --> 01:01:14,020
0,120 120,300 330,960 960,1350 1350,1800
Is it loading the initial
是不是在 uvminit 中的加载初始代码。

1922
01:01:14,020 --> 01:01:15,880
0,540 840,1140 1140,1230 1230,1320 1320,1860
code, in {uvminit - -}.|
|

1923
01:01:16,000 --> 01:01:19,480
0,780 780,990 990,1200 1200,1380 1380,3480
Yeah okay, we're just {[]
是的，好的，我们只是[]，

1924
01:01:19,480 --> 01:01:21,670
0,480 510,930 930,1440 1440,2010 2010,2190
- -},| modifying exec and
|修改的 exec 没有调用 uvminit ，其中。

1925
01:01:21,670 --> 01:01:23,110
0,240 240,570 570,810 810,1110 1110,1440
not called the {uvminit -

1926
01:01:23,110 --> 01:01:24,700
0,150 150,390 390,1080
- -}, where.|
|

1927
01:01:25,200 --> 01:01:26,380
0,690

1928
01:01:28,660 --> 01:01:30,160
0,120 120,630 780,1110 1110,1230 1230,1500
So mostly when we actually
所以大多数情况下，如果你还记得[]或类似的东西，

1929
01:01:30,160 --> 01:01:31,120
0,150 150,240 240,540 540,720 720,960
if you remember from for

1930
01:01:31,120 --> 01:01:32,110
0,270 270,270 270,630 630,780 780,990
[] or something like that,|
|

1931
01:01:32,110 --> 01:01:33,280
0,150 150,240 240,450 450,750 750,1170
you know the place where
应用程序是从地址零开始的，

1932
01:01:33,280 --> 01:01:34,870
0,60 60,450 450,780 780,1290 1290,1590
an application starts exactly address

1933
01:01:34,870 --> 01:01:37,870
0,450 1110,1680 1680,2100 2490,2700 2700,3000
zero,| pictures {a,little,bit} is leading
|图片中的这里，

1934
01:01:37,870 --> 01:01:38,860
0,240 240,480
here,| but
|但是这是文本，这里是零，它上升到某个数字，

1935
01:01:38,920 --> 01:01:40,870
0,270 270,690 690,870 870,1530 1740,1950
here's text, here zero it

1936
01:01:40,870 --> 01:01:42,010
0,180 180,300 300,360 360,540 540,1140
goes up to some number|
|

1937
01:01:42,190 --> 01:01:43,390
0,120 120,480 480,540 540,780 780,1200
and basically the first instruction
第一条指令在这里，

1938
01:01:43,390 --> 01:01:45,100
0,360 360,570 570,1080 1410,1620 1620,1710
whatever sits here,| that's the
|这是我们实际上的第一个指令，

1939
01:01:45,100 --> 01:01:46,090
0,270 270,660 660,750 750,840 840,990
first instruction that we're gonna

1940
01:01:46,090 --> 01:01:47,710
0,450 450,660 660,1260 1320,1500 1500,1620
actually,| that address, that's the
|那个地址，是第一条指令，我们会得到页面错误。

1941
01:01:47,710 --> 01:01:48,700
0,300 300,720 720,810 810,930 930,990
first instruction, we're going to

1942
01:01:48,700 --> 01:01:49,930
0,120 120,180 180,390 390,750 900,1230
get a page fault, right.|
|

1943
01:01:51,190 --> 01:01:52,750
0,270 270,390 390,510 510,1020 1200,1560
Because we have not loaded
因为我们还没有加载它。

1944
01:01:52,750 --> 01:01:53,600
0,240
it.|
|

1945
01:02:02,940 --> 01:02:03,480
0,150 150,270 270,330 330,420 420,540
So what do you want
那么你想要什么页面错误。

1946
01:02:03,480 --> 01:02:04,680
0,60 60,240 240,660
the page fault.|
|

1947
01:02:07,930 --> 01:02:08,650
0,330 330,450 450,570 570,630 630,720
Well we're going to do
好的，我们将在页面错误中做的是，

1948
01:02:08,650 --> 01:02:10,300
0,60 60,120 120,750 900,1200 1200,1650
in the {page,fault},| it's basically
|注意到这是其中一个按需页面，

1949
01:02:10,300 --> 01:02:11,620
0,270 270,600 600,960 960,1170 1170,1320
will note that this is

1950
01:02:11,620 --> 01:02:13,600
0,240 240,630 630,750 750,990 990,1980
{} one of these {}

1951
01:02:13,720 --> 01:02:15,420
0,630 630,1230
{on,demand} pages,|
|

1952
01:02:15,420 --> 01:02:17,340
0,510 510,1230 1260,1470 1470,1560 1560,1920
{} we have to remember
我们要事先在某个地方记住，

1953
01:02:17,340 --> 01:02:18,840
0,510 510,1020 1020,1320 1320,1410 1410,1500
somewhere earlier,| that you know
|这对应于一些文件。

1954
01:02:18,840 --> 01:02:21,020
0,180 180,870 870,1170 1170,1650
this corresponds to some,

1955
01:02:21,020 --> 01:02:22,880
0,330 330,510 510,1290 1290,1770 1770,1860
{} that this corresponds to
这对应于某个文件。

1956
01:02:22,880 --> 01:02:24,280
0,240 240,810
some file.|
|

1957
01:02:25,920 --> 01:02:26,880
0,300 300,480 480,570 570,750 750,960
Imagine what we're gonna do
假设我们在页面错误处理代码中要做的是把页面从文件读到内存中，

1958
01:02:26,880 --> 01:02:29,130
0,120 120,780 840,1560 1560,1950 1950,2250
in the {page,fault} handler is

1959
01:02:29,130 --> 01:02:30,280
0,540
read,

1960
01:02:30,400 --> 01:02:32,040
0,150 150,300 300,480 480,1170
you know that block

1961
01:02:33,210 --> 01:02:35,860
0,720 930,1230 1230,1410 1410,2040
page {} from file

1962
01:02:38,130 --> 01:02:39,540
0,270 270,840
into memory,|
|

1963
01:02:41,890 --> 01:02:43,820
0,510 510,660 660,1230
map the memory
将内存映射到页表中，

1964
01:02:45,700 --> 01:02:47,520
0,270 270,360 360,600 600,1140
into the {pagetable -},|
|

1965
01:02:49,460 --> 01:02:51,440
0,420 420,810 810,930 930,1410
then restart the instruction,|
然后重启指令，|

1966
01:02:56,720 --> 01:02:58,100
0,600 600,900 900,1080 1080,1260 1260,1380
and, {} then we're off
然后，我们就可以继续运行了。

1967
01:02:58,100 --> 01:02:59,690
0,90 90,420 930,1200 1200,1320 1320,1590
for running right.| And so
|所以在最坏的情况下，

1968
01:02:59,690 --> 01:03:01,160
0,120 120,420 420,690 690,1380 1380,1470
we're gonna go in the

1969
01:03:01,160 --> 01:03:02,540
0,240 240,480 480,780 780,1110 1110,1380
worst case,| if the user
|如果用户程序使用所有文本，使用所有数据，

1970
01:03:02,540 --> 01:03:03,740
0,450 450,720 720,930 930,1050 1050,1200
program uses all of its

1971
01:03:03,740 --> 01:03:05,000
0,480 570,900 900,1080 1080,1170 1170,1260
text, uses all of this

1972
01:03:05,000 --> 01:03:06,050
0,480 600,810 810,870 870,990 990,1050
data,| then we're going to
|那么我们会在程序的每一个页面都有一个页面错误。

1973
01:03:06,050 --> 01:03:07,310
0,180 180,240 240,510 510,990 990,1260
get a page {fault,for} every

1974
01:03:07,310 --> 01:03:09,080
0,540 540,630 630,750 750,1140 1140,1770
page, you know in the,

1975
01:03:10,220 --> 01:03:12,440
0,480 540,900 900,1050 1050,1680
in {} the program.|
|

1976
01:03:12,590 --> 01:03:13,610
0,450 480,690 690,750 750,900 900,1020
{} But you know we
但是，如果我们在这个程序中很幸运，

1977
01:03:13,610 --> 01:03:15,050
0,150 150,630 630,750 750,840 840,1440
get lucky in the program,|
|

1978
01:03:15,050 --> 01:03:15,860
0,150 150,420 420,570 570,720 720,810
it doesn't use all of
它不会使用所有数据段，

1979
01:03:15,860 --> 01:03:17,150
0,180 180,420 420,840 840,990 990,1290
its data segment| or doesn't
|或者不会使用所有文本段，

1980
01:03:17,150 --> 01:03:17,810
0,120 120,240 240,330 330,450 450,660
use all of its text

1981
01:03:17,810 --> 01:03:20,060
0,450 570,1350 1350,1500 1500,1710 1710,2250
segment,| then we might save
|那么我们可能会节省一些内存，

1982
01:03:20,060 --> 01:03:21,530
0,120 120,570 570,1080 1110,1230 1230,1470
some memory| and {} we
|我们当然会让 exec 表现得更快，

1983
01:03:21,530 --> 01:03:23,480
0,360 360,630 630,1140 1140,1230 1230,1950
certainly make exec {you,know} perform,

1984
01:03:23,480 --> 01:03:24,340
0,90 90,330
you know,

1985
01:03:24,340 --> 01:03:25,390
0,180 180,630 630,750 750,930 930,1050
much quicker| and it'll be
|它会更具互动性，

1986
01:03:25,390 --> 01:03:26,620
0,60 60,210 210,420 420,660 660,1230
a little bit more interactive,|
|

1987
01:03:26,770 --> 01:03:28,060
0,300 300,360 360,660 660,990 990,1290
assumes the program starts boom
假设程序开始运行，

1988
01:03:28,060 --> 01:03:30,070
0,120 120,420 870,1170 1170,1650 1680,2010
it's running,| well we actually
|我们必须准确地做任何工作。

1989
01:03:30,070 --> 01:03:30,790
0,120 120,180 180,270 270,450 450,720
have to do any work

1990
01:03:30,790 --> 01:03:31,700
0,450
exactly.|
|

1991
01:03:33,480 --> 01:03:34,830
0,210 210,330 330,570 570,870 870,1350
Does that makes this observation
这个能理解吗？

1992
01:03:34,830 --> 01:03:35,860
0,120 120,480
makes sense?|
|

1993
01:03:42,140 --> 01:03:44,690
0,300 300,810 1050,1350 1350,2220 2220,2550
Okay so there's a slight
好的，按需调页有一个扩展，这是按需调页的第二部分。

1994
01:03:44,690 --> 01:03:46,800
0,510 510,600 600,930 930,1530
extension to demand paging,

1995
01:03:51,520 --> 01:03:52,300
0,90 90,300 300,360 360,450 450,780
so this is the second

1996
01:03:52,300 --> 01:03:53,470
0,210 210,270 270,390 390,540 540,1170
part of the demand paging.|
|

1997
01:03:59,150 --> 01:04:00,720
0,270 270,510 510,990
Right, there's more.|
是的，这里还有更多。|

1998
01:04:01,390 --> 01:04:02,540
0,600

1999
01:04:04,960 --> 01:04:07,630
0,270 270,660 690,990 990,1530 1770,2670
Part two demand paging,| {in,principle},
按需调页的第二部分，|原则上，这里有一点小问题，

2000
01:04:07,630 --> 01:04:08,200
0,150 150,210 210,390 390,510 510,570
there's a little bit of

2001
01:04:08,200 --> 01:04:09,640
0,90 90,510 510,900 930,1290 1290,1440
{} problem here,| that we
|我们还没有真正讨论过，

2002
01:04:09,640 --> 01:04:11,470
0,240 240,450 450,990 1350,1620 1620,1830
haven't really discussed,| it might
|可能是这样的，

2003
01:04:11,470 --> 01:04:12,700
0,60 60,150 150,750 780,1080 1080,1230
be the case,| may be
|可能就是我们真正在读的文件，

2004
01:04:12,700 --> 01:04:13,900
0,120 120,570 570,720 720,870 870,1200
the file that we're actually

2005
01:04:13,900 --> 01:04:15,010
0,390 390,570 570,720 750,1020 1020,1110
reading| or the text and
|或者文本和数据段甚至比物理内存更大，

2006
01:04:15,010 --> 01:04:16,090
0,210 210,510 510,600 600,810 810,1080
data segments are even bigger

2007
01:04:16,090 --> 01:04:16,960
0,150 150,360 360,660 660,780 780,870
than what actually is in

2008
01:04:16,960 --> 01:04:19,000
0,300 300,660 690,1350 1410,1560 1560,2040
physical memory,| or if multiple
|或者多个应用程序以按需调页开始，

2009
01:04:19,000 --> 01:04:21,820
0,870 1170,1770 1770,1890 1890,2220 2220,2820
applications started with demand paging,|
|

2010
01:04:21,850 --> 01:04:23,620
0,300 300,510 510,990 1020,1200 1200,1770
maybe there's some of their
也许有一些它们的二进制文件，比物理内存要大。

2011
01:04:23,830 --> 01:04:25,600
0,870 870,990 990,1320 1320,1470 1470,1770
{binarys -}, {} it's basically

2012
01:04:25,600 --> 01:04:26,560
0,240 240,390 390,540 540,840 840,960
bigger than there actually is

2013
01:04:26,560 --> 01:04:27,660
0,30 30,360 360,720
a physical memory.|
|

2014
01:04:28,700 --> 01:04:30,530
0,240 240,690 840,1080 1080,1350 1440,1830
And so, {} the typical
所以，如果你深入按需调页，

2015
01:04:30,530 --> 01:04:31,970
0,300 300,420 420,570 570,960 960,1440
thing you know what {},

2016
01:04:32,150 --> 01:04:33,230
0,210 210,330 330,540 540,840 840,1080
if you go down this

2017
01:04:33,230 --> 01:04:35,570
0,300 300,780 780,1590 1620,2100 2100,2340
demand paging,| {} [] is
|如果你的内存耗尽，

2018
01:04:35,570 --> 01:04:37,040
0,150 150,750 930,1140 1140,1260 1260,1470
to actually if you run

2019
01:04:37,040 --> 01:04:38,340
0,240 240,300 300,780
out of memory,|
|

2020
01:04:38,990 --> 01:04:40,640
0,150 150,330 330,840 840,1110 1110,1650
so if kalloc returns zero,
如果 kalloc 返回零，就是内存不足。

2021
01:04:41,420 --> 01:04:42,940
0,180 180,330 330,420 420,990
it's out of memory.|
|

2022
01:04:45,440 --> 01:04:46,960
0,180 180,240 240,930
So, for example,
比如，你的按需页面，

2023
01:04:46,990 --> 01:04:48,310
0,120 120,270 270,450 450,810 810,1320
you know your demand page,|
|

2024
01:04:48,340 --> 01:04:49,450
0,180 180,330 330,360 360,630 630,1110
you get a page fault
你在需要从文件系统调入的页面出现页面错误，

2025
01:04:49,450 --> 01:04:51,640
0,210 210,690 690,1800 1830,2070 2070,2190
at some {} page, that

2026
01:04:51,640 --> 01:04:53,200
0,180 180,270 270,690 690,1170 1200,1560
needs to be a paged

2027
01:04:53,200 --> 01:04:55,780
0,330 690,1140 1140,1650 1680,2010 2010,2580
in from a file system,|
|

2028
01:04:56,050 --> 01:04:57,040
0,420 420,510 510,690 690,840 840,990
but you don't have any
但是你没有更多的空闲页面，你需要做些什么。

2029
01:04:57,040 --> 01:04:58,600
0,240 240,480 480,1080 1290,1440 1440,1560
more free pages, you need

2030
01:04:58,600 --> 01:04:59,660
0,60 60,180 180,570
to do something.|
|

2031
01:04:59,720 --> 01:05:01,010
0,420 420,600 600,720 720,1080 1080,1290
And so the typical this
所以又回到了前面的问题，

2032
01:05:01,010 --> 01:05:02,570
0,210 210,630 750,840 840,1230 1230,1560
comes back to earlier question,|
|

2033
01:05:02,570 --> 01:05:03,290
0,90 90,360 360,420 420,630 630,720
for example the same is
比如，跟懒分配类似，

2034
01:05:03,290 --> 01:05:05,090
0,180 180,300 300,780 780,1260 1290,1800
to for lazy or {}|
|

2035
01:05:05,510 --> 01:05:06,140
0,180 180,240 240,390 390,450 450,630
you know what to do
如果你的内存用完了，该怎么做。

2036
01:05:06,140 --> 01:05:06,680
0,90 90,180 180,360 360,480 480,540
if you run out of

2037
01:05:06,680 --> 01:05:07,580
0,390
memory.|
|

2038
01:05:07,610 --> 01:05:08,330
0,270 270,390 390,480 480,630 630,720
So if you run out
所以如果内存用完了，

2039
01:05:08,330 --> 01:05:09,710
0,60 60,390 390,720 720,1230 1230,1380
of memory,| one option that
|一个很明显的选择就是逐出一个页面。

2040
01:05:09,710 --> 01:05:11,930
0,120 120,510 510,900 900,1380 1770,2220
you really clearly have is

2041
01:05:11,930 --> 01:05:14,700
0,690 870,1680 1680,1770 1770,2310
to evict a page.|
|

2042
01:05:19,260 --> 01:05:20,490
0,180 180,270 270,720 720,1050 1050,1230
You can {for,example} instead of
比如，你可以选择一个页面，写会到文件中。

2043
01:05:20,490 --> 01:05:21,480
0,150 150,270 270,420 420,600 600,990
you know you can {for,example}

2044
01:05:21,480 --> 01:05:22,170
0,90 90,270 270,330 330,570 570,690
and pick the page and
然后选择页面并写回文件。

2045
01:05:22,170 --> 01:05:24,210
0,300 300,690 900,1110 1110,1500 1530,2040
write to the file back.|
|

2046
01:05:25,020 --> 01:05:26,190
0,510 510,600 600,810 810,1020 1020,1170
So {} for example it's
比如，一个修改过的数据页面，

2047
01:05:26,190 --> 01:05:28,140
0,450 780,1170 1170,1470 1470,1770 1770,1950
a data page that got

2048
01:05:28,140 --> 01:05:29,430
0,570 570,780 780,930 930,1080 1080,1290
modified,| so you can write
|你就可以把它写回文件系统。

2049
01:05:29,430 --> 01:05:30,840
0,300 300,810 960,1080 1080,1170 1170,1410
it back to the file

2050
01:05:30,840 --> 01:05:31,760
0,360
system.|
|

2051
01:05:32,160 --> 01:05:33,930
0,540 990,1260 1260,1440 1440,1650 1650,1770
{} And then once you
一旦你选择了这一页，

2052
01:05:33,930 --> 01:05:35,190
0,180 180,240 240,840 870,1140 1140,1260
pick the page| and then
|然后你就有了一个新的空闲页面，

2053
01:05:35,190 --> 01:05:35,910
0,120 120,270 270,300 300,480 480,720
you have a new free

2054
01:05:35,910 --> 01:05:37,320
0,510 840,990 990,1080 1080,1170 1170,1410
page| and you can put
|你可以使用这个新的空闲页面，

2055
01:05:37,320 --> 01:05:39,990
0,540 630,1380 1380,1680 1710,2100 2340,2670
the use that you use

2056
01:05:39,990 --> 01:05:42,510
0,90 90,990 1140,1710 1710,1890 1890,2520
the new just free page,|
|

2057
01:05:47,020 --> 01:05:48,730
0,120 120,780 780,900 900,1020 1020,1710
to satisfy you know the
来解决你遇到的错误，

2058
01:05:49,060 --> 01:05:50,830
0,570 570,690 690,840 840,1380 1590,1770
fault that you had| and
|然后再次重启指令。

2059
01:05:50,830 --> 01:05:52,570
0,210 210,540 540,1050 1050,1380 1380,1740
then basically restarting instruction again.|
|

2060
01:05:58,810 --> 01:06:00,040
0,300 300,720 720,1080 1080,1170 1170,1230
Again, restarting instruction is a
再说一次，重启指令有点复杂，

2061
01:06:00,040 --> 01:06:01,300
0,180 180,300 300,840 840,1170 1170,1260
little more complicated,| because the
|因为整个机制是调用 userret ，

2062
01:06:01,300 --> 01:06:03,670
0,660 930,1620 1620,1860 1860,2250 2250,2370
whole machinery to basically do

2063
01:06:03,670 --> 01:06:06,670
0,330 330,720 1110,1830 1830,1830 2460,3000
{userret -}| and {} started
|开始并转移回用户空间，等等。

2064
01:06:06,670 --> 01:06:08,530
0,870 900,1320 1320,1560 1560,1620 1620,1860
and transfer back to user

2065
01:06:08,530 --> 01:06:09,800
0,330 330,780
space, etc.|
|

2066
01:06:11,070 --> 01:06:11,850
0,300 300,420 420,510 510,690 690,780
{} And so this is
一个典型的操作系统将执行此操作，

2067
01:06:11,850 --> 01:06:13,410
0,600 600,870 870,1170 1170,1470 1470,1560
a typical operating system will

2068
01:06:13,410 --> 01:06:15,300
0,120 120,540 600,1260 1500,1680 1680,1890
do this| and of course
|当然，关键问题是要驱逐哪一页。

2069
01:06:15,300 --> 01:06:16,410
0,60 60,210 210,600 600,750 750,1110
the key question is like

2070
01:06:16,560 --> 01:06:18,340
0,330 330,630 630,1200
what page {to,evict}.|
|

2071
01:06:19,890 --> 01:06:21,700
0,390 390,630 630,750 750,1290
Which one to choose?|
该选哪一个？|

2072
01:06:22,340 --> 01:06:24,110
0,270 270,720 720,810 810,990 990,1770
So what are some candidates|
那么什么是候选者，|

2073
01:06:24,110 --> 01:06:25,680
0,90 90,180 180,330 330,1050
you know what do,
有什么合理的方法来选择一个页面来驱逐。

2074
01:06:25,950 --> 01:06:26,880
0,210 210,330 330,480 480,600 600,930
what would be a reasonable

2075
01:06:26,880 --> 01:06:28,320
0,570 570,780 780,1110 1110,1170 1170,1440
policy for choosing a page

2076
01:06:28,320 --> 01:06:29,420
0,90 90,540
to evict.|
|

2077
01:06:30,280 --> 01:06:32,410
0,450 450,900 900,1350 1650,2010 2010,2130
Least recently used.| Yeah, so
最近最少使用。|是的，所以这是最常用的策略，最近最少使用，或者 LRU 。

2078
01:06:32,410 --> 01:06:34,540
0,180 180,270 270,780 1020,1560 1560,2130
this is the most commonly

2079
01:06:34,540 --> 01:06:35,660
0,570
used

2080
01:06:35,660 --> 01:06:38,180
0,870 870,1440 1440,1950
strategy, {least,recently} used,

2081
01:06:43,910 --> 01:06:45,290
0,210 210,480 540,750 750,900 900,1380
or {LRU - - -}.|
|

2082
01:06:47,860 --> 01:06:49,720
0,540 540,690 690,870 870,990 990,1860
And, {} that was gonna
那是典型的被扔掉的页面，

2083
01:06:49,870 --> 01:06:52,450
0,1320 1320,1440 1440,1950 1980,2460 2460,2580
page was typically {} is

2084
01:06:52,450 --> 01:06:54,040
0,270 270,600 1050,1260 1260,1470 1470,1590
thrown out,| {} there's a
|通常有一些可以做的小优化，

2085
01:06:54,130 --> 01:06:55,720
0,270 270,450 450,570 570,1140 1140,1590
couple sort of twist typically

2086
01:06:55,720 --> 01:06:57,580
0,300 300,540 690,870 870,1200 1200,1860
{[] -} some small optimizations

2087
01:06:57,580 --> 01:06:59,350
0,180 180,540 840,1320 1350,1680 1680,1770
that do,| {} if you
|如果你必须选择一页，

2088
01:06:59,350 --> 01:07:00,190
0,150 150,240 240,420 420,480 480,840
have to pick the page|
|

2089
01:07:00,190 --> 01:07:01,340
0,540
and
你必须在脏页和非脏页之间做出选择，

2090
01:07:01,430 --> 01:07:02,930
0,510 870,1050 1050,1140 1140,1230 1230,1500
{} you have to choice

2091
01:07:02,930 --> 01:07:04,160
0,270 270,540 540,810 810,960 960,1230
between dirty page and {non-dirty

2092
01:07:04,160 --> 01:07:05,570
0,210 210,600 600,780 780,1020 1020,1410
-} page,| so dirty pages
|所以，脏页是有保存（东西）的，

2093
01:07:05,570 --> 01:07:06,350
0,240 240,420 420,510 510,660 660,780
page where there was a

2094
01:07:06,350 --> 01:07:08,180
0,300 300,750 1170,1410 1410,1620 1620,1830
store to| and {non-dirty -}
|而非脏页只有读取，没有被写入，

2095
01:07:08,180 --> 01:07:10,040
0,540 540,780 780,1110 1110,1710 1710,1860
pages or pages basically has

2096
01:07:10,040 --> 01:07:11,150
0,210 210,510 540,690 690,900 900,1110
been read, but not written

2097
01:07:11,150 --> 01:07:12,350
0,300 600,810 810,990 990,1110 1110,1200
to,| which one would you
|你选择哪一个先驱逐出去。

2098
01:07:12,350 --> 01:07:13,340
0,510
prefer

2099
01:07:13,590 --> 01:07:15,120
0,510 510,960
evict first.|
|

2100
01:07:16,700 --> 01:07:18,140
0,330 330,630 630,930 930,1320 1320,1440
{} Dirty one, because you
脏页，因为不管怎样，你总要写脏的那个。

2101
01:07:18,140 --> 01:07:19,340
0,120 120,480 480,720 720,1110 1110,1200
would have to write the

2102
01:07:19,340 --> 01:07:20,660
0,300 300,660 660,810 810,1020 1020,1320
dirty one at some point

2103
01:07:20,660 --> 01:07:21,840
0,630
anyway.|
|

2104
01:07:21,840 --> 01:07:23,300
0,990
Yeah.|
嗯。|

2105
01:07:23,460 --> 01:07:24,930
0,300 300,630 660,990 990,1140 1140,1470
{} So sorry, say again
抱歉，请再说一遍，确认一下。

2106
01:07:24,930 --> 01:07:27,020
0,450 480,840 840,1230 1230,1530
actually just double-check there.|
|

2107
01:07:27,130 --> 01:07:29,110
0,420 420,660 660,960 960,1320 1320,1980
{} I said dirty, because
我说的是脏页，因为脏页在某一时刻需要写入内存。

2108
01:07:29,110 --> 01:07:30,400
0,450 450,870 870,990 990,1200 1200,1290
dirty pages would need to

2109
01:07:30,400 --> 01:07:31,930
0,150 150,420 420,630 630,1230 1320,1530
be written into memory at

2110
01:07:31,930 --> 01:07:33,180
0,180 180,720
some point.|
|

2111
01:07:33,180 --> 01:07:36,240
0,330 330,540 540,990 1020,2490 2520,3060
Yeah that's true, {} then
是的，那是真的，也许现在你得写两遍，

2112
01:07:36,240 --> 01:07:36,960
0,270 270,450 450,510 510,630 630,720
maybe now you have to

2113
01:07:36,960 --> 01:07:38,130
0,120 120,210 210,780 810,990 990,1170
write it twice,| you know
|一旦你写了，以后可能会再次修改。

2114
01:07:38,130 --> 01:07:39,000
0,240 240,330 330,540 540,720 720,870
once you write it may

2115
01:07:39,000 --> 01:07:40,840
0,180 180,600 600,840 840,1320
be modified later again.|
|

2116
01:07:41,490 --> 01:07:43,770
0,120 120,390 390,720 720,1260 1380,2280
And so actually typically.| OK
所以实际上。|好的，我明白了。

2117
01:07:43,800 --> 01:07:45,720
0,720 720,750 780,1320 1320,1800 1800,1920
{OK's -} {I,see}.| Exactly the
|恰恰相反，选择没有写入的页或者非脏页，

2118
01:07:45,720 --> 01:07:46,780
0,510
opposite,

2119
01:07:46,870 --> 01:07:48,040
0,240 240,420 420,720 720,810 810,1170
{} they choose a page

2120
01:07:48,040 --> 01:07:49,030
0,210 210,450 450,600 600,810 810,990
that actually has not been

2121
01:07:49,030 --> 01:07:50,320
0,480 510,660 660,750 750,990 990,1290
written or it's not dirty,|
|

2122
01:07:50,320 --> 01:07:50,950
0,180 180,300 300,450 450,570 570,630
because you don't have to
因为你不需要做任何事，

2123
01:07:50,950 --> 01:07:52,120
0,180 180,600 750,930 930,1020 1020,1170
do anything,| you can just
|你可以重新使用它，

2124
01:07:52,120 --> 01:07:53,410
0,390 390,660 690,870 870,960 960,1290
reuse it,| you can just
|如果它在[页表一]中，你可以标记它，

2125
01:07:53,770 --> 01:07:55,960
0,450 720,1470 1470,1800 1800,2100 2100,2190
take mark if it is

2126
01:07:55,960 --> 01:07:57,190
0,360 360,480 480,930 930,1020 1020,1230
present in {} in {pagetable

2127
01:07:57,190 --> 01:07:58,630
0,240 240,690 720,930 930,1200 1200,1440
-} one,| you mark there
|你标记它是无效的，就可以了。

2128
01:07:58,630 --> 01:08:00,490
0,90 90,210 210,720 1170,1410 1410,1860
is non valid and then

2129
01:08:00,520 --> 01:08:01,700
0,330 330,630
you're done.|
|

2130
01:08:01,700 --> 01:08:02,450
0,300 300,420 420,510 510,630 630,750
{} And then you can
然后，你可以在另一个页表中重用该页面。

2131
01:08:02,450 --> 01:08:03,980
0,570 570,720 720,990 990,1140 1140,1530
reuse that page in another

2132
01:08:03,980 --> 01:08:05,120
0,240 240,570
{pagetable -}.|
|

2133
01:08:05,340 --> 01:08:06,540
0,180 180,270 270,390 390,750 750,1200
And so the preference intensity
所以偏好是首先选择非脏页。

2134
01:08:06,540 --> 01:08:08,010
0,150 150,390 390,1050 1050,1350 1350,1470
is a take pages that

2135
01:08:08,010 --> 01:08:10,380
0,180 180,540 780,1320 1350,2160 2160,2370
have been {} not {non-dirty

2136
01:08:10,380 --> 01:08:11,980
0,300 300,600 600,1110
-} ones first.|
|

2137
01:08:13,600 --> 01:08:14,440
0,240 240,330 330,510 510,720 720,840
Can I just ask for
我能不能问一下确认那些脏页。

2138
01:08:14,440 --> 01:08:15,970
0,60 60,750 750,870 870,990 990,1530
a clarification on the dirty

2139
01:08:17,090 --> 01:08:18,400
0,810
pages.|
|

2140
01:08:18,400 --> 01:08:20,380
0,330 330,1290
Yeah.| So,
嗯。|所以，我知道，就像在缓存里，

2141
01:08:20,380 --> 01:08:22,780
0,630 1140,1410 1410,1920 1920,2130 2130,2400
{} I I know, like

2142
01:08:22,780 --> 01:08:24,010
0,150 150,270 270,840 840,1080 1080,1230
in a cache,| when we
|在内存中，我们说一行是脏的，

2143
01:08:24,010 --> 01:08:25,030
0,210 210,630 630,750 750,900 900,1020
have memory and then we

2144
01:08:25,030 --> 01:08:26,200
0,270 270,540 540,660 660,1020 1020,1170
say okay a line is

2145
01:08:26,200 --> 01:08:27,430
0,390 390,690 690,780 780,1080 1080,1230
dirty,| because it hasn't been
|因为它还没有被写入内存，

2146
01:08:27,430 --> 01:08:29,050
0,210 210,360 360,930 1110,1440 1440,1620
written to memory,| but what
|但是内存中的一页是什么样子的呢，它脏在哪里，

2147
01:08:29,050 --> 01:08:30,340
0,180 180,270 270,600 600,750 750,1290
about a page in memory

2148
01:08:30,340 --> 01:08:31,570
0,150 150,300 300,450 450,570 570,1230
like what does it correspond

2149
01:08:31,570 --> 01:08:32,380
0,150 150,390 390,570 570,690 690,810
to like, how is it

2150
01:08:32,380 --> 01:08:33,340
0,270 270,480 480,660 660,750 750,960
dirty,| where does it have
|它要写回哪里，

2151
01:08:33,340 --> 01:08:34,570
0,120 120,210 210,540 540,900 900,1230
to be written back to,|
|

2152
01:08:34,690 --> 01:08:36,040
0,240 240,480 480,900 900,990 990,1350
it just exists in memory
它只是存在于内存中，

2153
01:08:36,040 --> 01:08:37,240
0,210 210,390 390,660 660,720 720,1200
right,| isn't that the whole
|是不是它不存在于其他地方，

2154
01:08:37,270 --> 01:08:38,470
0,420 420,660 660,870 870,990 990,1200
whole thing like it doesn't

2155
01:08:38,470 --> 01:08:40,330
0,360 360,660 660,930 930,1350 1650,1860
exist anywhere else really,| so
|那么它是如何变脏的。

2156
01:08:40,330 --> 01:08:41,410
0,180 180,330 330,420 420,540 540,1080
when can it be dirty.|
|

2157
01:08:41,890 --> 01:08:42,730
0,180 180,360 360,480 480,540 540,840
Yeah okay, so for example
好的，比如，如果按需页面是文件页面，

2158
01:08:42,730 --> 01:08:43,990
0,180 180,330 330,720 720,990 990,1260
if the demand page file

2159
01:08:43,990 --> 01:08:45,060
0,480
page,|
|

2160
01:08:45,290 --> 01:08:46,400
0,240 240,540 540,660 660,810 810,1110
{} actually we'll talk about
实际上，我们稍后会谈到，

2161
01:08:46,400 --> 01:08:47,270
0,120 120,180 180,600 600,780 780,870
in a second,| like in
|在下一个，可能有点太多了，

2162
01:08:47,270 --> 01:08:50,180
0,90 90,540 570,1950 2070,2460 2460,2910
the next {}, maybe a

2163
01:08:50,180 --> 01:08:51,290
0,180 180,300 300,390 390,750 780,1110
little bit too much,| but
|但是内存映射文件，

2164
01:08:51,290 --> 01:08:52,970
0,90 90,420 420,960 1080,1500 1500,1680
if you {} memory map

2165
01:08:52,970 --> 01:08:55,160
0,630 660,1500 1650,1890 1890,2130 2130,2190
files,| where you map a
|你把文件映射到内存，

2166
01:08:55,160 --> 01:08:58,250
0,360 360,1050 1050,1770 1800,2370 2700,3090
file into {} memory {},|
|

2167
01:08:58,250 --> 01:08:59,450
0,240 240,450 450,660 660,1020 1020,1200
and then do store to
然后把对它保存，那么你就会弄脏那一页。

2168
01:08:59,450 --> 01:09:00,260
0,120 120,330 330,420 420,540 540,810
it, then you would dirty

2169
01:09:00,260 --> 01:09:01,280
0,210 210,630
that page.|
|

2170
01:09:01,280 --> 01:09:02,630
0,300 300,450 450,660 660,870 870,1350
Okay so that only applies|
好的，所以这只适用于|

2171
01:09:02,630 --> 01:09:04,190
0,450 480,720 720,810 810,1140 1140,1560
when like a page actually
一个页面不仅对应内存，还对应文件或其他东西。

2172
01:09:04,190 --> 01:09:05,630
0,540 540,840 840,1050 1050,1140 1140,1440
response not just to some

2173
01:09:05,630 --> 01:09:06,770
0,390 390,540 540,930 930,1050 1050,1140
memory, but also to a
而且还可以存储到文件或其他文件中。

2174
01:09:06,770 --> 01:09:08,720
0,420 420,510 510,810 810,1320 1500,1950
file or something else.| Okay,
|好的，理解了。

2175
01:09:09,310 --> 01:09:10,870
0,270 270,420 420,570 570,1050 1260,1560
okay, that makes sense.| Yeah.|
|嗯。|

2176
01:09:13,020 --> 01:09:14,790
0,330 330,510 510,780 780,1020 1020,1770
Okay, so just to {},
好的，所以我想再多说两点与此相关的观点，

2177
01:09:14,820 --> 01:09:15,480
0,120 120,210 210,390 390,480 480,660
you know just to make

2178
01:09:15,480 --> 01:09:16,590
0,180 180,300 300,450 450,630 630,1110
one more two more points

2179
01:09:17,170 --> 01:09:20,140
0,600 600,690 690,1110 1410,2280 2670,2970
related to this,| {} if
|如果你再看这个 pte ，

2180
01:09:20,140 --> 01:09:21,040
0,180 180,360 360,450 450,810 840,900
you look at this {}

2181
01:09:21,040 --> 01:09:23,100
0,570 600,1020 1020,1470
{} pte again,|
|

2182
01:09:23,220 --> 01:09:24,150
0,180 180,300 300,450 450,630 630,930
so we saw this {RSW
所以我们看这个 RSW 位，

2183
01:09:24,150 --> 01:09:26,100
0,360 360,750 900,1320 1320,1590 1590,1950
-} bit,| {} you'll notice
|你会注意到第七位，就是脏页位。

2184
01:09:26,100 --> 01:09:27,180
0,150 150,510 510,750 750,810 810,1080
there actually is a bit

2185
01:09:27,180 --> 01:09:28,320
0,480 480,660 660,750 750,840 840,1140
seven, that is the dirty

2186
01:09:28,320 --> 01:09:29,260
0,330
bit.|
|

2187
01:09:29,320 --> 01:09:31,150
0,270 270,570 570,1020 1050,1380 1380,1830
So when the paging hardware
所以当硬件曾经写入页面，

2188
01:09:31,150 --> 01:09:32,470
0,180 180,240 240,660 660,870 870,1320
where the hardware ever writes

2189
01:09:32,470 --> 01:09:33,520
0,90 90,180 180,420 420,870 870,1050
you know to page| then
|就会设置这个脏页位，

2190
01:09:33,520 --> 01:09:34,690
0,210 210,330 330,480 480,750 750,1170
[watch] this set dirty bits,|
|

2191
01:09:34,840 --> 01:09:36,280
0,180 180,270 270,570 570,870 870,1440
so the operating system {later,can,see},|
这样操作系统稍后就可以看到，|

2192
01:09:36,280 --> 01:09:37,540
0,120 120,120 120,600 600,810 810,1260
{}, oh, this actually page
可以很容易地看到这个页面有写入。

2193
01:09:37,690 --> 01:09:38,890
0,210 210,450 450,750 750,990 990,1200
can easily see this page

2194
01:09:38,890 --> 01:09:40,420
0,210 210,510 510,780 780,1050
that's actually written to.|
|

2195
01:09:41,290 --> 01:09:42,880
0,330 330,930 930,1140 1140,1290 1290,1590
And similarly there is a
同样的，还有一个 A 位，表示访问，

2196
01:09:43,630 --> 01:09:45,360
0,360 360,570 570,720 720,1140
{} {} A bit,

2197
01:09:46,260 --> 01:09:47,700
0,270 270,420 420,690 690,810 810,1440
{} that stands for access,|
|

2198
01:09:48,760 --> 01:09:50,140
0,180 180,300 300,750 750,1110 1110,1380
and so whenever pages either
所以每当页面读取或写入，访问位会被设置。

2199
01:09:50,140 --> 01:09:52,270
0,420 450,750 750,1140 1200,1740 1770,2130
written or written either read

2200
01:09:52,270 --> 01:09:53,890
0,210 210,690 870,1110 1110,1440 1440,1620
or written the access bit

2201
01:09:53,890 --> 01:09:55,060
0,150 150,240 240,630
will be set.|
|

2202
01:09:55,090 --> 01:09:57,640
0,750 780,1320 1740,1980 1980,2460 2460,2550
And, {} and why is
为什么知道这一点是有用的？

2203
01:09:57,640 --> 01:09:59,120
0,120 120,420 420,510 510,900
it useful to know?|
|

2204
01:10:07,430 --> 01:10:08,300
0,120 120,330 330,570 570,720 720,870
In one way, could that
这可以以哪种方式帮助内核？

2205
01:10:08,300 --> 01:10:09,640
0,240 240,300 300,780
help the kernel?|
|

2206
01:10:09,730 --> 01:10:11,260
0,450 480,720 720,960 960,1140 1140,1530
Well, the ones that haven't
嗯，那些还没被访问过的，你可以驱逐。

2207
01:10:11,260 --> 01:10:14,110
0,180 690,1680 1680,1800 1800,2370 2550,2850
been accessed, you can, you

2208
01:10:14,110 --> 01:10:15,560
0,150 150,540 540,930
can evict right.|
|

2209
01:10:15,650 --> 01:10:17,360
0,330 330,1230 1230,1380 1380,1470 1470,1710
Yeah, what are you saying
是的，你的意思是如果你想实施最近用过的，

2210
01:10:17,360 --> 01:10:17,960
0,210 210,300 300,390 390,540 540,600
that if you want to

2211
01:10:17,960 --> 01:10:20,160
0,420 420,690 690,1050 1050,1620
implement these recently used,|
|

2212
01:10:20,280 --> 01:10:23,010
0,570 570,1440 1440,2280 2280,2640 2640,2730
{} if {}, if you
如果你发现一个页面在一段时间内没有被访问过，

2213
01:10:23,010 --> 01:10:23,970
0,210 210,270 270,540 540,660 660,960
find a page that basically

2214
01:10:23,970 --> 01:10:24,960
0,240 240,360 360,750 750,840 840,990
hasn't been accessed in some

2215
01:10:24,960 --> 01:10:25,890
0,240 240,300 300,630 630,750 750,930
period of time,| you know
|你知道它最近没有被使用过，

2216
01:10:25,890 --> 01:10:27,000
0,90 90,300 300,600 600,750 750,1110
it actually hasn't been recently

2217
01:10:27,000 --> 01:10:28,170
0,390 420,600 600,870 870,1110 1110,1170
used,| so it actually is
|所以它是一个驱逐候选者，

2218
01:10:28,170 --> 01:10:29,850
0,60 60,480 480,600 600,1020 1290,1680
a candidate for eviction,| while
|而设置了访问位的页面，不是驱逐候选者。

2219
01:10:29,850 --> 01:10:30,960
0,90 90,390 390,510 510,870 870,1110
the pages that have the

2220
01:10:30,960 --> 01:10:32,340
0,330 330,510 510,840 960,1140 1140,1380
access bit set are not

2221
01:10:32,340 --> 01:10:33,900
0,180 180,570 570,690 690,1110
really candidates for eviction.|
|

2222
01:10:34,990 --> 01:10:37,300
0,360 390,960 1170,1590 1590,1950 1950,2310
So, {} {A,bit} typically used
所以， A 位通常用来实现这个 LRU 策略。

2223
01:10:37,300 --> 01:10:38,500
0,210 210,510 510,630 630,930 930,1200
where actually is typically used

2224
01:10:38,500 --> 01:10:40,870
0,900 930,1470 1470,1650 1650,1950 1950,2370
to implement this {LRU -}

2225
01:10:40,900 --> 01:10:42,200
0,180 180,780
{} strategy.|
|

2226
01:10:44,540 --> 01:10:45,830
0,420 420,660 660,810 810,960 960,1290
Okay, but would you have
好的，但是你需要每隔一段时间重置访问位为未访问。

2227
01:10:45,830 --> 01:10:48,560
0,480 480,1440 1470,2160
to reset {}

2228
01:10:48,560 --> 01:10:51,470
0,570 630,1410 1410,2280 2310,2490 2490,2910
the access bits to not

2229
01:10:51,470 --> 01:10:52,940
0,600 600,930 930,1290 1290,1380 1380,1470
access every once in a

2230
01:10:52,940 --> 01:10:55,190
0,600 630,1290 1320,1860 1860,2160 2160,2250
while.| Exactly, that's exactly what
|没错，这是操作系统会做的事情。

2231
01:10:55,190 --> 01:10:56,480
0,90 90,330 330,750 750,900 900,1290
the typical {operation,system} will do.|
|

2232
01:10:57,170 --> 01:10:58,250
0,360 360,510 510,720 720,870 870,1080
{} And if they []
可能所有内存，

2233
01:10:58,250 --> 01:10:59,510
0,180 180,450 450,570 570,810 810,1260
even maybe for all memory,|
|

2234
01:10:59,510 --> 01:11:02,480
0,120 120,540 540,720 720,1200 1350,2970
they [sweep] for memory [],|
从内存中[清除]，|

2235
01:11:02,480 --> 01:11:03,590
0,120 120,420 420,840 840,990 990,1110
{} famous algorithm, which is
著名的算法，称为时钟算法，就是这样做的一种方式。

2236
01:11:03,590 --> 01:11:04,880
0,150 150,240 240,570 570,1110 1110,1290
called the clock algorithm that

2237
01:11:04,880 --> 01:11:05,810
0,60 60,450 450,630 630,720 720,930
is one way of doing

2238
01:11:05,810 --> 01:11:06,540
0,210
it.|
|

2239
01:11:10,810 --> 01:11:11,770
0,360 360,540 540,660 660,780 780,960
[] why would you need
为什么要设置它，为什么要重置。

2240
01:11:11,770 --> 01:11:12,940
0,120 120,420 420,750 870,1050 1050,1170
to set it, why would

2241
01:11:12,940 --> 01:11:14,740
0,180 180,510 510,900 900,1260
you to reset it.|
|

2242
01:11:14,740 --> 01:11:15,400
0,150 150,360 360,450 450,600 600,660
Well, if you want to
如果你想知道我们的页面最近是什么时候使用的，

2243
01:11:15,400 --> 01:11:16,810
0,300 300,570 570,690 690,1020 1020,1410
know when our pages recently

2244
01:11:16,810 --> 01:11:19,000
0,540 600,1380 1380,1710 1710,1950 1950,2190
used,| {} you need and
|你需要做一个定期的决定，

2245
01:11:19,000 --> 01:11:20,380
0,120 120,270 270,330 330,810 810,1380
you make a periodic decision,|
|

2246
01:11:20,800 --> 01:11:22,090
0,330 330,540 540,750 750,1080 1080,1290
{} then say maybe every
然后比如每一百毫秒，或者其他时间，

2247
01:11:22,090 --> 01:11:23,740
0,210 210,870 870,1080 1080,1470 1470,1650
hundred milliseconds or whatever every

2248
01:11:23,740 --> 01:11:25,660
0,420 420,780 780,1230 1230,1590 1590,1920
seconds,| you clear the access
|你清除访问位，

2249
01:11:25,660 --> 01:11:27,670
0,300 660,1140 1140,1440 1440,1620 1620,2010
bit,| yeah it gets access
|它在接下来的 100 毫秒内访问，

2250
01:11:27,670 --> 01:11:28,780
0,120 120,210 210,420 420,600 600,1110
in the next hundred milliseconds,|
|

2251
01:11:28,780 --> 01:11:29,560
0,90 90,300 300,420 420,540 540,780
you know it was used
你知道它在过去的 100 毫秒内使用的。

2252
01:11:29,560 --> 01:11:30,760
0,60 60,120 120,330 330,540 540,1200
in the last hundred milliseconds.|
|

2253
01:11:32,730 --> 01:11:33,690
0,300 300,390 390,630 630,720 720,960
And the pages that don't
那些没有设置访问位的页面，在最近的毫秒内没有使用过。

2254
01:11:33,690 --> 01:11:35,040
0,180 180,390 390,960 960,1080 1080,1350
have the access bit set

2255
01:11:35,040 --> 01:11:36,060
0,150 150,390 390,630 630,780 780,1020
were not used in last

2256
01:11:36,060 --> 01:11:37,360
0,60 60,150 150,360 360,780
in the {milliseconds -}.|
|

2257
01:11:39,150 --> 01:11:39,810
0,180 180,270 270,480 480,570 570,660
And so then you can
这样你就可以记录他们如何使用，

2258
01:11:39,810 --> 01:11:41,520
0,210 210,720 720,840 840,1170 1170,1710
keep counters with how intentionally

2259
01:11:41,520 --> 01:11:42,720
0,120 120,600 600,720 720,1020 1020,1200
they used| and what is
|特别是帮助我们实现。

2260
01:11:42,720 --> 01:11:44,970
0,480 480,810 840,1320 1590,2160 2160,2250
and for really especially the

2261
01:11:44,970 --> 01:11:48,210
0,720 720,1470 1500,2190 2190,2550 2550,3240
[steppingstone] to [sophisticate] our implementation.|
|

2262
01:11:52,840 --> 01:11:54,400
0,390 420,960
Okay {}.|
好的。|

2263
01:11:55,350 --> 01:11:56,040
0,150 150,300 300,360 360,480 480,690
I want to talk about
我想再谈一件事，

2264
01:11:56,040 --> 01:11:58,500
0,210 210,660 660,870 870,1170 1170,2460
one more used to {},|
|

2265
01:11:59,310 --> 01:12:01,500
0,1170 1170,1350 1350,1530 1530,2010 2010,2190
the last one actually you
最后一个，你也在一个实验中实现。

2266
01:12:01,500 --> 01:12:03,510
0,270 270,360 360,510 510,1020 1020,2010
also will be implementing in

2267
01:12:03,690 --> 01:12:05,200
0,390 390,450 450,540 540,1050
one of the labs.|
|

2268
01:12:05,440 --> 01:12:07,120
0,300 300,570 570,960 1080,1410 1410,1680
And that is a memory
这就是内存映射文件。

2269
01:12:07,120 --> 01:12:08,400
0,180 180,780
mapped files.|
|

2270
01:12:21,140 --> 01:12:22,790
0,210 210,600 600,720 720,1170 1200,1650
The idea is that {}
想法是，我们有地址空间，

2271
01:12:22,790 --> 01:12:24,050
0,90 90,210 210,600 600,720 720,1260
you know we're we have

2272
01:12:24,080 --> 01:12:26,270
0,360 360,660 660,1260 1680,2040 2040,2190
our address space,| what we
|我们想做的是加载将整个文件或部分文件到地址空间中，

2273
01:12:26,270 --> 01:12:26,870
0,210 210,330 330,390 390,480 480,600
really want to do is

2274
01:12:26,870 --> 01:12:28,490
0,330 330,480 480,750 750,1050 1050,1620
basically be able to load

2275
01:12:28,520 --> 01:12:29,630
0,60 60,270 270,720 720,840 840,1110
the whole file or parts

2276
01:12:29,630 --> 01:12:30,500
0,60 60,180 180,510 510,780 780,870
of the file into the

2277
01:12:30,500 --> 01:12:31,790
0,270 270,720 870,1110 1110,1200 1200,1290
address space,| so that we
|这样我们就可以使用加载存储指令来操作文件的内容，

2278
01:12:31,790 --> 01:12:33,500
0,90 90,300 300,990 1020,1290 1290,1710
can just manipulate the content

2279
01:12:33,500 --> 01:12:34,490
0,90 90,180 180,480 480,660 660,990
of the file using load

2280
01:12:34,490 --> 01:12:35,780
0,210 210,900
store instructions,|
|

2281
01:12:36,650 --> 01:12:39,530
0,810 900,1200 1200,1950 1950,2280 2460,2880
{} {} instead of {}
你可以读或写。

2282
01:12:39,530 --> 01:12:41,330
0,480 570,1080 1080,1200 1200,1350 1350,1800
read else you can write

2283
01:12:41,360 --> 01:12:42,400
0,480
{}.|
|

2284
01:12:42,400 --> 01:12:43,270
0,360 360,510 510,630 630,780 780,870
And to be able to
为了能够支持这一点，

2285
01:12:43,270 --> 01:12:44,650
0,330 330,570 570,660 660,810 810,1380
support that,| you know a
|在大多数现代操作系统中，提供一个系统调用 mmap ，

2286
01:12:44,650 --> 01:12:46,150
0,300 300,600 600,1020 1020,1230 1230,1500
typical operating system where most

2287
01:12:46,150 --> 01:12:48,670
0,300 300,600 600,1050 1050,1560 2040,2520
modern operating systems called provide

2288
01:12:48,670 --> 01:12:50,960
0,360 360,630 630,1230 1230,1800
a system call mmap,|
|

2289
01:12:52,120 --> 01:12:53,980
0,690 750,1140 1140,1410 1410,1770 1770,1860
and basically mmap takes a
mmap 使用虚拟地址，虚拟地址长度，[保护]，标志位，

2290
01:12:53,980 --> 01:12:55,780
0,300 300,810 840,1320 1350,1680 1680,1800
virtual address or pick some

2291
01:12:55,780 --> 01:12:58,060
0,360 360,840 960,1800
virtual address length,

2292
01:12:58,180 --> 01:13:00,480
0,1740
protection,

2293
01:13:00,780 --> 01:13:02,420
0,990
flags,|
|

2294
01:13:02,420 --> 01:13:03,410
0,150 150,270 270,330 330,510 510,990
we're going to talk about|
我们要讨论的，|

2295
01:13:03,710 --> 01:13:05,330
0,270 270,660 660,900 900,1320 1320,1620
and then file descriptor of
然后是打开文件的文件描述符和偏移量。

2296
01:13:05,330 --> 01:13:06,980
0,60 60,390 390,1020 1380,1530 1530,1650
an open file and an

2297
01:13:06,980 --> 01:13:08,060
0,540
offset.|
|

2298
01:13:08,960 --> 01:13:10,460
0,420 420,660 660,840 840,1260 1260,1500
Maybe [with] {this's -} like
也许你应该，

2299
01:13:10,460 --> 01:13:12,530
0,150 150,630 660,1470 1830,1980 1980,2070
you should| map you know
|映射这个文件描述符到这个虚拟地址，

2300
01:13:12,530 --> 01:13:13,610
0,120 120,420 420,510 510,810 810,1080
this file {} descriptor {}

2301
01:13:14,450 --> 01:13:15,530
0,180 180,360 360,450 450,1020 1020,1080
to this {} addressing a
如果这是寻址虚拟地址，

2302
01:13:15,530 --> 01:13:17,210
0,420 420,930 930,1080 1080,1320 1350,1680
virtual address,| you know file
|文件描述符从文件 f 中的偏移量开始，

2303
01:13:17,210 --> 01:13:18,950
0,60 60,420 420,660 960,1230 1230,1740
{} descriptor { -} starting

2304
01:13:18,950 --> 01:13:20,960
0,390 390,1170 1230,1620 1620,1710 1710,2010
from offset in the file

2305
01:13:20,960 --> 01:13:22,700
0,420 750,900 900,1140 1170,1530 1530,1740
f,| you know map that
|把它映射到虚拟地址 va 的地址。

2306
01:13:22,700 --> 01:13:24,170
0,420 630,870 870,930 930,1350 1350,1470
in at the address at

2307
01:13:24,170 --> 01:13:25,980
0,90 90,420 420,780 780,1320
the virtual address va.|
|

2308
01:13:26,420 --> 01:13:27,620
0,420 420,540 540,870 870,1050 1050,1200
And do that we have
做这个，我们有一些[保护]，读，写等。

2309
01:13:27,620 --> 01:13:29,150
0,150 150,630 630,840 840,1080 1080,1530
some protection {} read, write

2310
01:13:29,180 --> 01:13:30,240
0,540
etc.|
|

2311
01:13:30,830 --> 01:13:31,730
0,210 210,390 390,510 510,660 660,900
So let's say is read
我们假设是读写，

2312
01:13:31,730 --> 01:13:33,890
0,420 540,1350 1440,1590 1590,1740 1740,2160
write,| then you know the
|那么内核实现 mmap 的方法是，

2313
01:13:34,130 --> 01:13:36,590
0,750 840,1290 1290,1920 1920,2160 2160,2460
kernel {} when and so,

2314
01:13:37,160 --> 01:13:38,300
0,180 180,330 330,420 420,780 780,1140
the way it currently implements
它目前实现mmap的方式，

2315
01:13:38,300 --> 01:13:40,610
0,180 180,660 840,1680 1890,2040 2040,2310
{mmap -} is,| it does
|它急切地做，大多数系统都急切的做，

2316
01:13:40,610 --> 01:13:42,140
0,600 690,930 930,1170 1170,1380 1380,1530
eagerly, {} which is like

2317
01:13:42,140 --> 01:13:43,340
0,330 390,720 720,870 870,990 990,1200
most systems does do it

2318
01:13:43,340 --> 01:13:46,340
0,390 600,1020 1020,1590 1620,2460 2490,3000
eagerly,| {} basically copy, read
|复制，读取从偏移量开始的所有字节，

2319
01:13:46,340 --> 01:13:47,600
0,210 210,300 300,750 810,1140 1140,1260
all the bytes starting from

2320
01:13:47,600 --> 01:13:49,670
0,600 810,1410 1410,1620 1620,1920 1920,2070
offset,| [] bytes starting from
|加载从偏移量开始的字节到内存中，

2321
01:13:49,670 --> 01:13:52,100
0,390 390,1140 1140,1380 1380,1980 2100,2430
offset into {} memory,| sets
|设置 pte 指向物理内存的位置，

2322
01:13:52,100 --> 01:13:55,820
0,180 180,750 1350,2220 2460,3060 3090,3720
up the ptes to point

2323
01:13:55,820 --> 01:13:58,100
0,210 210,600 630,900 900,1260 1260,2280
to the physical memory for

2324
01:13:58,130 --> 01:14:00,650
0,630 630,690 690,1320 1530,1890 1890,2520
blocks are located| and basically
|从那时起，应用程序使用加载保存指令修改文件，

2325
01:14:00,650 --> 01:14:02,680
0,150 150,360 360,840 960,1620
from then on the

2326
01:14:02,680 --> 01:14:05,260
0,570 570,1200 1200,1560 1560,2190 2250,2580
{} application use [], use

2327
01:14:05,260 --> 01:14:06,430
0,240 240,330 330,570 570,1050 1050,1170
load and store instructions to

2328
01:14:06,430 --> 01:14:08,950
0,240 240,1560 1590,1680 1680,2250 2400,2520
actually modify the file| and
|当所有都完成后，

2329
01:14:08,950 --> 01:14:10,900
0,60 60,330 330,540 540,1050 1110,1950
the maybe when they were

2330
01:14:10,900 --> 01:14:12,760
0,180 180,630 870,1080 1080,1320 1320,1860
all done,| {} there's typically
|会有一个对应的 unmap 调用，

2331
01:14:12,760 --> 01:14:14,500
0,120 120,750 750,930 930,1230 1230,1740
a corresponding {unmap -} call,|
|

2332
01:14:14,860 --> 01:14:17,000
0,390 390,1080 1170,1650
{} that {},
和 len ，然后允许应用程序，我已经完成使用这个文件，

2333
01:14:17,000 --> 01:14:19,670
0,240 240,480 480,1140 1350,1920 1950,2670
and at length, then allows

2334
01:14:19,670 --> 01:14:20,810
0,60 60,450 450,540 540,780 780,1140
the application to say, OK

2335
01:14:20,810 --> 01:14:21,830
0,210 210,420 420,540 540,690 690,1020
I'm done with this particular

2336
01:14:21,830 --> 01:14:22,940
0,480 540,720 720,810 810,900 900,1110
file| and at the point
|在 unmap 的时候，需要把脏页写会。

2337
01:14:22,940 --> 01:14:24,170
0,60 60,240 240,780 960,1110 1110,1230
of {unmap -} and we

2338
01:14:24,170 --> 01:14:25,220
0,180 180,270 270,540 540,960 960,1050
need to write back the

2339
01:14:25,220 --> 01:14:26,500
0,300 300,810
dirty blocks.|
|

2340
01:14:32,190 --> 01:14:33,120
0,180 180,270 270,390 390,660 660,930
And we can easily figure
我们可以很容易地找出哪些块是脏的，

2341
01:14:33,120 --> 01:14:34,410
0,180 180,390 390,720 720,780 780,1290
out which blocks are dirty,|
|

2342
01:14:34,620 --> 01:14:36,780
0,990 1020,1140 1140,1410 1440,1980 1980,2160
because they have D bit
因为它们在 PTE 中设置了 D 位。

2343
01:14:36,780 --> 01:14:38,240
0,180 180,360 360,900
set into pte.|
|

2344
01:14:38,660 --> 01:14:40,460
0,240 240,300 300,750 1020,1470 1470,1800
Now, of course in any
现在，在任何内存或复杂的内存实现中，

2345
01:14:40,460 --> 01:14:43,370
0,480 480,780 780,1320 1320,1770 1800,2910
memory or sophisticated memory implementation,|
|

2346
01:14:43,640 --> 01:14:44,990
0,630 660,870 870,990 990,1140 1140,1350
{} this is all done
这些都是最近才做的，

2347
01:14:44,990 --> 01:14:46,040
0,510 510,600 600,720 720,900 900,1050
[lately],| you know you just
|你不是立即映射文件，

2348
01:14:46,040 --> 01:14:47,570
0,180 180,540 540,630 630,870 870,1530
don't map the file immediately,|
|

2349
01:14:47,780 --> 01:14:48,920
0,360 360,540 540,690 690,780 780,1140
you just keep a record
你只要在某个地方保存一份记录，

2350
01:14:48,920 --> 01:14:50,120
0,330 330,420 420,510 510,900 900,1200
somewhere on the [],| saying
|比如，这个 pte 属于这个特定的文件描述符，

2351
01:14:50,120 --> 01:14:51,170
0,210 210,630 630,690 690,810 810,1050
like well you know this

2352
01:14:51,170 --> 01:14:53,360
0,300 300,750 960,1620 1620,2100 2100,2190
{PTE -} really belongs to

2353
01:14:53,360 --> 01:14:54,740
0,180 180,510 510,720 720,1170 1170,1380
this particular file descriptor,| so
|所有，在旁边有一些控制信息，

2354
01:14:54,740 --> 01:14:56,720
0,240 240,630 870,1500 1500,1890 1890,1980
there's some information maintained on

2355
01:14:56,720 --> 01:14:57,770
0,90 90,420 420,540 540,690 690,1050
the side| which is typically
|通常在一个结构中 vma ，或虚拟内存区。

2356
01:14:57,770 --> 01:14:58,620
0,360
called

2357
01:14:58,900 --> 01:14:59,710
0,150 150,180 180,540 540,720 720,810
in a structure called the

2358
01:14:59,710 --> 01:15:01,720
0,510 510,810 810,990 1020,1500 1500,2010
vma or the virtual memory

2359
01:15:01,720 --> 01:15:02,920
0,540
area.|
|

2360
01:15:07,810 --> 01:15:08,830
0,150 150,480 480,570 570,690 690,1020
For example, for this file
比如，对于此文件 f 有一个 vma ，

2361
01:15:08,830 --> 01:15:09,940
0,210 210,450 450,540 540,750 750,1110
f would be one {vma

2362
01:15:09,940 --> 01:15:10,840
0,270 270,510 510,630 630,690 690,900
-}| and in a {vma
|在 vma 中我们记录文件描述符、偏移量等，

2363
01:15:10,840 --> 01:15:12,370
0,240 240,450 450,1200 1200,1290 1290,1530
-} we record the file

2364
01:15:12,370 --> 01:15:15,220
0,540 540,660 660,1290 1320,1950 2190,2850
descriptor the offset etc,| where
|我们应该使用的内容在哪里，

2365
01:15:15,220 --> 01:15:16,660
0,120 120,450 450,1110 1110,1260 1260,1440
the actual content that then

2366
01:15:16,660 --> 01:15:18,250
0,150 150,660 690,1290 1290,1470 1470,1590
we should live| and so
|当我们得到在 vma 中地址的页面错误时，

2367
01:15:18,250 --> 01:15:19,840
0,210 210,690 840,1410 1410,1530 1530,1590
when we {} get a

2368
01:15:19,840 --> 01:15:21,550
0,270 270,690 780,1080 1080,1140 1140,1710
page fault for a particular

2369
01:15:21,550 --> 01:15:23,200
0,420 420,780 780,900 900,1200 1200,1650
address that's in this {vma

2370
01:15:23,200 --> 01:15:24,340
0,480 540,780 780,870 870,990 990,1140
-},| then we can go
|然后我们可以离开，内核从磁盘读取它，加载到内存中。

2371
01:15:24,340 --> 01:15:25,570
0,390 390,780 780,840 840,1110 1110,1230
off and the kernel can

2372
01:15:25,570 --> 01:15:27,340
0,210 210,330 330,480 480,930 990,1770
read it from disk and

2373
01:15:27,490 --> 01:15:28,860
0,270 270,390 390,630 630,990
bring it into memory.|
|

2374
01:15:30,340 --> 01:15:31,900
0,360 840,1020 1020,1380 1380,1440 1440,1560
And in response to an
回答早先的一个问题，

2375
01:15:31,900 --> 01:15:32,950
0,210 210,540 540,630 630,960 960,1050
earlier question| is one of
|这个脏页位很重要的原因之一是，

2376
01:15:32,950 --> 01:15:33,820
0,60 60,330 330,450 450,600 600,870
the reasons that this dirty

2377
01:15:33,820 --> 01:15:34,840
0,180 180,270 270,660 660,930 930,1020
bit is important,| because as
|因为 mmap 必须写回脏块。

2378
01:15:34,840 --> 01:15:35,680
0,210 210,540 540,630 630,750 750,840
{mmap -}, you have to

2379
01:15:35,680 --> 01:15:37,510
0,270 270,690 690,960 990,1320 1320,1830
write back the dirty blocks.|
|

2380
01:15:40,930 --> 01:15:42,320
0,120 120,270 270,420 420,840
Does this make sense?|
这个能理解吗？|

2381
01:15:43,960 --> 01:15:47,650
0,180 180,420 420,1140 2550,3300 3330,3690
{} {I,have,a} question.| {} Maybe
我有一个问题。|也许这是一个普遍的问题，

2382
01:15:47,650 --> 01:15:49,060
0,180 180,330 330,450 450,930 960,1410
this is a more general

2383
01:15:49,060 --> 01:15:50,680
0,390 390,690 1080,1350 1350,1440 1440,1620
issue,| but could it ever
|比如说多个进程[]是否在内存映射辅助内存相同的文件，

2384
01:15:50,680 --> 01:15:51,490
0,120 120,210 210,570 570,660 660,810
be an issue of say

2385
01:15:51,490 --> 01:15:53,560
0,420 420,930 930,1230 1230,1530 1710,2070
multiple process [] are memory

2386
01:15:53,560 --> 01:15:55,240
0,390 390,480 480,1140 1170,1560 1560,1680
mapping the same file on

2387
01:15:55,240 --> 01:15:56,770
0,390 390,990 1050,1140 1140,1230 1230,1530
secondary storage| and then like
|然后同步。

2388
01:15:57,750 --> 01:16:00,120
0,540 540,990 1380,1560 1560,1890 1890,2370
[synchronization] is.| {} Good question,
|好问题，那么， Unix 中的语义是什么，

2389
01:16:00,180 --> 01:16:01,830
0,810 840,1020 1020,1290 1290,1500 1500,1650
{} so what is the

2390
01:16:01,830 --> 01:16:03,300
0,510 510,690 690,960 960,1050 1050,1470
semantics in Unix in general|
|

2391
01:16:03,300 --> 01:16:04,650
0,150 150,390 390,720 720,990 990,1350
like what happens if multiple
比如，如果多个进程使用读取或写入系统调用读取或写入同一文件，会发生什么情况。

2392
01:16:04,650 --> 01:16:05,880
0,570 570,840 840,930 930,1170 1170,1230
processes read or write to

2393
01:16:05,880 --> 01:16:07,350
0,90 90,300 300,660 660,930 930,1470
the same file using {read,or,write}

2394
01:16:07,350 --> 01:16:08,580
0,270 270,720
system calls.|
|

2395
01:16:18,930 --> 01:16:20,430
0,210 210,330 330,540 540,960 960,1500
Did you needs guarantee anything.|
你需要保证什么吗。|

2396
01:16:22,500 --> 01:16:24,440
0,390 390,1200
It's undefined.|
这是不确定的。|

2397
01:16:24,560 --> 01:16:26,180
0,450 450,660 660,960 960,1110 1110,1620
Yeah yeah there's like no
是的，写会以某种顺序出现，

2398
01:16:26,780 --> 01:16:28,040
0,480 480,780 780,990 990,1080 1080,1260
the reason write will show

2399
01:16:28,040 --> 01:16:29,210
0,90 90,180 180,330 330,690 780,1170
up in some order| or
|或者写入将以某种顺序出现，

2400
01:16:29,240 --> 01:16:29,990
0,90 90,330 330,450 450,630 630,750
the writes will show up

2401
01:16:29,990 --> 01:16:30,860
0,60 60,270 270,600 630,780 780,870
in some order,| so if
|如果两个进程写入文件中的同一块，

2402
01:16:30,860 --> 01:16:32,000
0,180 180,570 570,750 750,1020 1020,1140
two process you write to

2403
01:16:32,000 --> 01:16:33,340
0,90 90,330 330,810
the same block

2404
01:16:33,370 --> 01:16:34,960
0,150 150,870 960,1140 1140,1260 1260,1590
of {the,file},| you know either
|可能是第一次写的，或第二次写的，其中之一。

2405
01:16:34,960 --> 01:16:36,100
0,90 90,300 300,630 630,840 840,1140
the first process writes go

2406
01:16:36,100 --> 01:16:37,150
0,210 210,270 270,510 510,810 810,1050
or the second process writes

2407
01:16:37,150 --> 01:16:38,940
0,300 570,780 780,870 870,1230
go, one of two.|
|

2408
01:16:38,940 --> 01:16:39,990
0,240 240,360 360,630 630,960 960,1050
And so here's basically the
所以这里也是一样的东西，

2409
01:16:39,990 --> 01:16:41,100
0,180 180,540 540,810 810,960 960,1110
same thing,| we don't really
|我们不需要保证什么。

2410
01:16:41,100 --> 01:16:42,700
0,150 150,210 210,630 630,1020
have to guarantee anything.|
|

2411
01:16:42,980 --> 01:16:43,850
0,150 150,270 270,480 480,540 540,870
If you want to do
如果你想做一个更复杂的 Unix 操作系统支持文件锁，

2412
01:16:43,880 --> 01:16:45,620
0,210 210,420 420,900 900,1260 1260,1740
a more sophisticated Unix operating

2413
01:16:45,620 --> 01:16:47,760
0,330 330,750 750,1020 1020,1590
system support file locking,|
|

2414
01:16:47,760 --> 01:16:48,960
0,120 120,210 210,300 300,600 600,1200
where you can lock files
在那里你可以锁定文件，然后你就可以正确地同步，

2415
01:16:49,200 --> 01:16:51,180
0,150 150,630 660,1020 1020,1380 1410,1980
and then you can properly

2416
01:16:51,180 --> 01:16:53,370
0,660 900,1290 1290,1890 1890,2070 2070,2190
synchronize,| by default, there's no
|默认情况下，这里没有同步，或者在这一级没有同步。

2417
01:16:53,370 --> 01:16:54,640
0,750
synchronization,

2418
01:16:55,600 --> 01:16:56,740
0,150 150,360 360,840 840,960 960,1140
or no synchronization at this
或者在此级别没有同步。

2419
01:16:56,740 --> 01:16:57,660
0,360
level.|
|

2420
01:17:01,880 --> 01:17:03,040
0,120 120,270 270,570
That makes sense?|
能理解吗？|

2421
01:17:04,440 --> 01:17:05,550
0,180 180,390 390,660 660,900 900,1110
{} I'm sorry, what is
抱歉，长度是什么，标志位是什么。

2422
01:17:05,550 --> 01:17:07,470
0,540 540,750 750,960 960,1110 1110,1920
length and what is flags.|
|

2423
01:17:07,830 --> 01:17:09,570
0,270 270,1020 1050,1500 1500,1620 1620,1740
Of [like] length is the
长度是你要映射的文件以字节为单位的长度。

2424
01:17:09,570 --> 01:17:10,860
0,540 720,900 900,1140 1140,1200 1200,1290
length of the you know

2425
01:17:10,860 --> 01:17:11,730
0,120 120,540 540,660 660,810 810,870
the area you want to

2426
01:17:11,730 --> 01:17:12,810
0,420 420,540 540,840 840,1020 1020,1080
map the file number of

2427
01:17:12,810 --> 01:17:13,800
0,510
bytes.|
|

2428
01:17:13,890 --> 01:17:16,590
0,720 750,1170 1170,1590 1590,2010 2040,2700
{} Flags {read,write} X flags,
标志读写 X ，标志当你映射是会看到，

2429
01:17:16,590 --> 01:17:18,090
0,120 120,420 420,1200 1200,1350 1350,1500
you know you'll see that

2430
01:17:18,090 --> 01:17:19,080
0,150 150,240 240,510 510,570 570,990
when you do a map,|
|

2431
01:17:19,080 --> 01:17:20,670
0,60 60,60 1050,1260 1260,1380 1380,1590
{} I think this has
我认为这与映射的区域是私有的还是共享的有关。

2432
01:17:20,670 --> 01:17:21,960
0,60 60,210 210,510 510,1050 1050,1290
to do with whether the

2433
01:17:21,960 --> 01:17:23,070
0,270 270,360 360,570 570,1020 1020,1110
area is mapped private or

2434
01:17:23,070 --> 01:17:24,080
0,570
shared.|
|

2435
01:17:24,250 --> 01:17:25,990
0,450 450,780 780,960 960,1530 1530,1740
If it's mapped shared and
如果它被映射为共享，那么它可以在多个进程之间共享。

2436
01:17:25,990 --> 01:17:27,190
0,450 450,660 660,780 780,900 900,1200
then it can be shared

2437
01:17:27,190 --> 01:17:28,980
0,270 270,600 600,1260
among multiple processes.|
|

2438
01:17:35,160 --> 01:17:36,450
0,180 180,420 420,780 780,960 960,1290
Any further questions about this?|
关于这个，还有什么问题吗？|

2439
01:17:41,540 --> 01:17:43,070
0,240 240,510 510,780 780,1080 1080,1530
{} If some other process
如果某个其他进程修改了这个文件，

2440
01:17:43,070 --> 01:17:44,570
0,510 510,630 630,960 960,1080 1080,1500
modifies the file in this,|
|

2441
01:17:44,600 --> 01:17:45,980
0,420 420,780 780,990 990,1230 1230,1380
that means that this will
也就是说这个不会在这里体现出来，是吗。

2442
01:17:45,980 --> 01:17:47,750
0,300 300,450 450,1110 1110,1410 1410,1770
not be reflected here, right.|
|

2443
01:17:48,470 --> 01:17:50,060
0,330 330,540 540,1020
{} That's correct,
没错，除非映射位共享的，那么你就应该体现这些变化。

2444
01:17:50,180 --> 01:17:51,530
0,360 360,780 780,900 900,1170 1170,1350
{} unless I think if

2445
01:17:51,530 --> 01:17:53,060
0,300 300,780 810,1020 1020,1170 1170,1530
mapped shared, then you're supposed

2446
01:17:53,060 --> 01:17:54,760
0,60 60,420 420,600 600,1140
to reflect those changes.|
|

2447
01:17:55,030 --> 01:17:56,200
0,390 390,510 510,690 690,810 810,1170
Right, but then they would
好的，但之后它们将使用相同的文件描述符。

2448
01:17:56,200 --> 01:17:57,160
0,120 120,450 450,540 540,780 780,960
be using the same file

2449
01:17:57,160 --> 01:18:00,040
0,780
descriptor.|
|

2450
01:18:01,240 --> 01:18:03,010
0,270 270,780 780,1050 1050,1140 1140,1770
I'm hazy on the exact
我对 mmap 的确切语义不清楚，

2451
01:18:03,040 --> 01:18:05,350
0,660 660,1290 1500,1950 1950,2100 2100,2310
semantics of mmap,| when things
|当文件被分享的时候，那里会发生什么。

2452
01:18:05,350 --> 01:18:06,790
0,90 90,540 540,900 900,1050 1050,1440
are shared and what exactly

2453
01:18:06,790 --> 01:18:07,900
0,270 270,570
happens there.|
|

2454
01:18:08,220 --> 01:18:09,120
0,330 330,480 480,690 690,810 810,900
Okay I guess so I
好的，我想，就像习语中的情况一样，

2455
01:18:09,120 --> 01:18:10,440
0,240 240,360 360,600 600,690 690,1320
guess in like the idiomatic

2456
01:18:10,440 --> 01:18:11,970
0,330 330,510 510,750 750,1320 1350,1530
case,| {} and shared they
|它们分享了，必须反映出来，

2457
01:18:11,970 --> 01:18:14,070
0,150 150,390 390,900 1170,1860 1860,2100
would have to reflect it,|
|

2458
01:18:14,070 --> 01:18:15,930
0,360 750,1020 1020,1110 1110,1620 1620,1860
but if a process just
但是如果一个进程上打开完全相同的文件名，我想设置为分开的，

2459
01:18:15,930 --> 01:18:17,400
0,180 180,720 720,1050 1050,1140 1140,1470
like actually open the same

2460
01:18:17,400 --> 01:18:19,500
0,330 330,630 630,1170 1170,1560
file name completely set

2461
01:18:19,560 --> 01:18:22,020
0,690 690,840 840,1260 1980,2220 2220,2460
separately I think,| it could
|它可以是不同步的，即使它是共享的。

2462
01:18:22,020 --> 01:18:23,100
0,150 150,240 240,540 540,930 930,1080
be a [un synced], even

2463
01:18:23,100 --> 01:18:25,600
0,120 120,270 270,750
if it's shared.|
|

2464
01:18:31,040 --> 01:18:32,720
0,300 300,720 780,1320 1350,1500 1500,1680
Okay, so {}, so this
好的，在文件系统实验之后，你会做内存映射文件。

2465
01:18:32,720 --> 01:18:33,920
0,60 60,570 570,690 690,930 930,1200
is after the file system

2466
01:18:33,920 --> 01:18:35,720
0,390 420,660 660,1200 1200,1410 1410,1800
lab, you actually {} do

2467
01:18:35,720 --> 01:18:37,360
0,180 180,450 450,660 660,1170
{} memory map files.|
|

2468
01:18:37,420 --> 01:18:38,230
0,240 240,450 450,540 540,660 660,810
And that will be our
这是我们最后一次虚拟内存实验，

2469
01:18:38,230 --> 01:18:40,000
0,540 540,1020 1020,1500 1500,1680 1680,1770
last virtual memory sort of

2470
01:18:40,000 --> 01:18:41,560
0,510 540,1020 1020,1140 1140,1500 1500,1560
lab,| unless you decide at
|除非你最后决定做更多虚拟内存功能或练习或者做任何你想做的事，

2471
01:18:41,560 --> 01:18:42,280
0,150 150,300 300,360 360,480 480,720
the end to do more

2472
01:18:42,280 --> 01:18:44,710
0,300 300,720 720,990 1440,2280 2280,2430
virtual memory {} features or

2473
01:18:44,710 --> 01:18:46,000
0,660 660,780 780,1080 1080,1140 1140,1290
exercises or whatever you wanna

2474
01:18:46,000 --> 01:18:47,950
0,240 660,1200 1260,1380 1380,1590 1590,1950
do,| {} you know the
|用主要工作来结束这节课。

2475
01:18:47,950 --> 01:18:49,120
0,180 180,600 600,720 720,840 840,1170
main job is to conclude

2476
01:18:49,120 --> 01:18:50,900
0,120 120,690 720,1320
this lecture {}.|
|

2477
01:18:51,100 --> 01:18:52,280
0,600
The,
这是总结。

2478
01:18:52,310 --> 01:18:54,040
0,60 60,240 240,330 330,900
{} sort of summary.|
|

2479
01:18:56,000 --> 01:18:57,110
0,150 150,300 300,570 570,900 930,1110
You know, we've lived in
我们了解了页表工作的很多细节。

2480
01:18:57,110 --> 01:18:58,160
0,60 60,480 480,750 750,960 960,1050
the past, in terms of

2481
01:18:58,160 --> 01:19:00,650
0,480 510,1230 1230,1770 1770,2250 2250,2490
great detail exactly how {pagetables

2482
01:19:00,650 --> 01:19:01,920
0,300 300,720
-} work.|
|

2483
01:19:03,050 --> 01:19:04,070
0,150 150,330 330,390 390,630 630,1020
We've done a couple labs,
我们做了几个实验，一个是页面的实验，

2484
01:19:04,070 --> 01:19:04,970
0,300 300,540 540,600 600,690 690,900
one lab of the {pagetables

2485
01:19:04,970 --> 01:19:06,710
0,540 540,1020 1020,1200 1200,1260 1260,1740
-},| we've looked a lot
|我们看了 trap 和页面错误如何工作。

2486
01:19:06,710 --> 01:19:08,440
0,150 150,270 270,690 690,1170
like how traps work,

2487
01:19:08,470 --> 01:19:11,710
0,1290 1380,1530 1530,1800 1800,2340 2700,3240
and {you,know} page fault,| and
|如果你把这两者结合起来，

2488
01:19:11,710 --> 01:19:13,090
0,210 240,570 570,960 990,1260 1260,1380
it turns out if you

2489
01:19:13,090 --> 01:19:14,520
0,360 360,420 420,900
combine the two,|
|

2490
01:19:16,250 --> 01:19:18,200
0,210 210,330 330,840 840,1710 1710,1950
now you're gonna implement very
现在你将实现非常强大和优雅的虚拟内存功能。

2491
01:19:18,200 --> 01:19:20,740
0,750 900,1320 1320,1950
powerful and elegant

2492
01:19:22,430 --> 01:19:25,240
0,1470 1470,1680 1680,2190
virtual memory features.|
|

2493
01:19:25,780 --> 01:19:26,710
0,330 330,420 420,570 570,810 810,930
And you know went through
我列了一张清单，

2494
01:19:26,710 --> 01:19:27,580
0,60 60,210 210,390 390,450 450,870
a whole list of them,|
|

2495
01:19:28,030 --> 01:19:29,800
0,630 660,1200 1200,1620 1620,1710 1710,1770
{} mostly focusing on the
主要集中在那些将要实现的未来实验上，

2496
01:19:29,800 --> 01:19:30,550
0,240 240,360 360,570 570,690 690,750
ones, that actually going to

2497
01:19:30,550 --> 01:19:33,250
0,120 120,600 600,900 900,1440 1830,2700
be implementing future lab,| but
|但是这只是一个子集，

2498
01:19:33,250 --> 01:19:34,300
0,120 120,330 330,690 690,810 810,1050
you know this is only

2499
01:19:34,300 --> 01:19:36,020
0,30 30,510 540,660 660,1230
a subset,| for example
|比如，一些操作系统实现了今天讨论的所有这些。

2500
01:19:36,020 --> 01:19:37,010
0,360 360,480 480,570 570,810 810,990
{} of the ones that

2501
01:19:37,010 --> 01:19:38,120
0,120 120,300 300,480 480,810 810,1110
you know some operating systems

2502
01:19:38,120 --> 01:19:39,890
0,450 450,600 840,1140 1140,1470 1470,1770
implement the typical operating system

2503
01:19:39,890 --> 01:19:40,670
0,90 90,420 420,510 510,600 600,780
to implement all the ones

2504
01:19:40,670 --> 01:19:42,400
0,90 90,480 480,840 840,1170
that actually discussed today.|
|

2505
01:19:42,400 --> 01:19:43,360
0,120 120,210 210,360 360,420 420,960
If you look at Linux
如果你看 Linux ，所有这些都（实现了）。

2506
01:19:43,360 --> 01:19:44,170
0,210 210,360 360,540 540,600 600,810
and as all of them.|
|

2507
01:19:45,800 --> 01:19:47,420
0,210 210,450 450,930 960,1380 1380,1620
And many more interesting other
还有更多有趣的技巧，

2508
01:19:47,420 --> 01:19:49,100
0,480 540,1080 1080,1200 1200,1500 1500,1680
tricks,| but this hopefully gives
|但希望这能让你更好地感受虚拟内存的力量，

2509
01:19:49,100 --> 01:19:50,090
0,90 90,240 240,690 690,810 810,990
you good sense, you know

2510
01:19:50,090 --> 01:19:51,230
0,300 300,480 480,570 570,1080 1080,1140
sort out the power of

2511
01:19:51,230 --> 01:19:53,240
0,300 300,720 960,1380 1380,1470 1470,2010
virtual memory,| once you dynamically
|一旦你可以在页面错误处理程序中动态修改页表。

2512
01:19:53,240 --> 01:19:54,920
0,150 150,510 510,900 930,1170 1170,1680
can change the {pagetables -}

2513
01:19:54,920 --> 01:19:56,240
0,420 420,570 570,780 780,960 960,1320
in the page fault handler.|
|

2514
01:19:59,010 --> 01:20:00,450
0,90 90,270 270,420 420,1170 1170,1440
I think there's exactly at
我想正好是在 25 ，

2515
01:20:00,840 --> 01:20:01,950
0,570 570,690 690,930 930,1050 1050,1110
25,| so maybe that's a
|所以也许是结束的时间了，

2516
01:20:01,950 --> 01:20:03,300
0,180 180,360 360,720 750,1230 1230,1350
good point to stop,| but
|但是如果你有任何问题，可以随意提问。

2517
01:20:03,300 --> 01:20:04,290
0,90 90,150 150,270 270,450 450,990
if you have any questions,

2518
01:20:04,290 --> 01:20:05,340
0,360 360,540 540,630 630,840 840,1050
feel free to ask them.|
|

2519
01:20:08,250 --> 01:20:09,210
0,180 180,600 600,690 690,840 840,960
If not, you know we
如果没有，祝你顺利完成 trap 实验。

2520
01:20:09,210 --> 01:20:10,350
0,120 120,240 240,450 450,840 840,1140
should, good luck finishing the

2521
01:20:10,350 --> 01:20:11,640
0,690
{trap,lab}.|
|

2522
01:20:11,870 --> 01:20:13,220
0,240 240,480 480,870 930,1260 1260,1350
I hope it's not as
我希望不会像往年那么痛苦，

2523
01:20:13,220 --> 01:20:15,080
0,420 420,600 600,690 690,1200
painful as the year,|
|

2524
01:20:15,510 --> 01:20:16,620
0,180 180,300 300,390 390,870 900,1110
we're not as hard as
不像页面实验那么难。

2525
01:20:16,620 --> 01:20:18,580
0,390 480,690 690,930 930,1350
the {pagetable -} lab.|
|

2526
01:20:21,650 --> 01:20:23,000
0,450 480,840 840,900 900,1080 1080,1350
{} Sorry I had another
抱歉，我有另一个问题，

2527
01:20:23,000 --> 01:20:24,590
0,390 390,720 720,960 960,1380 1410,1590
question,| when you map in
|当你在上一张幻灯片中映射时，

2528
01:20:24,590 --> 01:20:27,110
0,450 450,870 870,1350 1380,2040 2280,2520
the previous slide,| {} when
|当你映射整个文件或将其放入内存时，

2529
01:20:27,110 --> 01:20:28,880
0,300 330,750 750,870 870,1200 1200,1770
you map the whole file

2530
01:20:28,880 --> 01:20:29,810
0,210 210,420 420,570 570,840 840,930
or when you put it

2531
01:20:29,810 --> 01:20:31,520
0,270 270,840 960,1200 1200,1410 1410,1710
into memory,| and it turns
|如果发现它比长度还长，然后，会发生什么。

2532
01:20:31,520 --> 01:20:32,600
0,150 150,240 240,360 360,810 810,1080
out to be longer than

2533
01:20:32,600 --> 01:20:33,500
0,480
length,

2534
01:20:33,560 --> 01:20:34,640
0,540
{}

2535
01:20:35,820 --> 01:20:37,680
0,330 330,570 570,1380
then, what happens.|
|

2536
01:20:37,680 --> 01:20:38,880
0,450 450,540 540,630 630,900 900,1200
Sorry if the file doesn't
抱歉，如果文件不能放入虚拟地址空间？

2537
01:20:38,880 --> 01:20:39,750
0,210 210,300 300,390 390,660 660,870
fit in the virtual address

2538
01:20:39,750 --> 01:20:40,800
0,480
space?|
|

2539
01:20:41,040 --> 01:20:42,540
0,480 660,870 870,1050 1050,1140 1140,1500
Oh I guess it was
哦，我猜长度就是我们想要的文件大小。

2540
01:20:42,570 --> 01:20:45,300
0,420 420,780 780,1170 1170,1860 2040,2730
like length is how much

2541
01:20:45,390 --> 01:20:47,490
0,240 240,420 420,1200 1230,1440 1440,2100
of the file, we want.|
|

2542
01:20:48,390 --> 01:20:49,950
0,210 210,540 570,930 930,1320 1320,1560
Yes, so length, just like
是的，长度，就像我们希望从偏移量 off 开始映射文件描述符的 10 个字节。

2543
01:20:49,950 --> 01:20:50,820
0,120 120,270 270,330 330,690 690,870
we want to map like

2544
01:20:50,820 --> 01:20:51,960
0,210 210,690 690,930 930,990 990,1140
ten bytes out of the

2545
01:20:51,960 --> 01:20:54,240
0,240 240,630 630,1350 1590,1890 1890,2280
file descriptor starting at offset

2546
01:20:54,240 --> 01:20:55,060
0,390
off.|
|

2547
01:20:55,580 --> 01:20:57,680
0,600 600,840 840,1230 1230,1770 1890,2100
Oh, okay, okay, so if
哦，好的，如果文件长于（length），

2548
01:20:57,680 --> 01:20:58,670
0,90 90,330 330,450 450,750 750,990
the file is longer than,|
|

2549
01:20:58,670 --> 01:20:59,990
0,180 180,540 540,870 870,1170 1170,1320
we're not gonna put all
我们不会把这它整个放入内存中。

2550
01:20:59,990 --> 01:21:03,420
0,90 90,300 330,660 660,1650
of it into memory.|
|

2551
01:21:03,610 --> 01:21:05,320
0,360 360,510 510,840 870,1140 1140,1710
Okay I see, thank you.|
好的，我明白了，谢谢。|

2552
01:21:08,500 --> 01:21:10,150
0,720 750,900 900,930 930,1320 1500,1650
I got a question, I've
我有个问题，我在驱逐页面上有个问题。

2553
01:21:10,150 --> 01:21:12,760
0,120 120,180 180,690 690,1440 2130,2610
got a question on the

2554
01:21:12,820 --> 01:21:15,240
0,480 480,1050
evicting pages.|
|

2555
01:21:15,300 --> 01:21:17,400
0,750 1170,1590 1590,1680 1680,1920 1920,2100
So basically we talked about
我们在按需调页第二部分讨论了这个问题，

2556
01:21:17,400 --> 01:21:18,570
0,120 120,420 420,540 540,840 840,1170
it after the demand paging

2557
01:21:18,570 --> 01:21:19,590
0,300 300,570 570,720 720,810 810,1020
part two,| but is that
|但是这是一个一般的程序吗，

2558
01:21:19,590 --> 01:21:21,180
0,270 270,960 960,1410 1410,1470 1470,1590
a general procedure,| we would
|我们会在这些技术中使用任何一种，

2559
01:21:21,180 --> 01:21:22,020
0,180 180,270 270,540 540,630 630,840
use in any of these

2560
01:21:22,020 --> 01:21:23,610
0,570 570,720 720,810 810,1320 1320,1590
techniques,| if we discover that
|如果我们发现我们已经超越了物理边界。

2561
01:21:23,610 --> 01:21:24,930
0,150 150,270 270,420 420,900 900,1320
we're out of physical boundary.|
|

2562
01:21:24,960 --> 01:21:26,760
0,630 630,900 900,1170 1170,1350 1350,1800
Yeah that's just the common
是的，这只是常见的主要机制，

2563
01:21:26,760 --> 01:21:28,350
0,420 420,960 960,1140 1140,1290 1290,1590
majorly mechanism,| like, so even
|即使在懒分配中，

2564
01:21:28,350 --> 01:21:30,780
0,870 900,1200 1200,1860 1860,2220 2220,2430
in lazy allocation,| we run
|我们在没有可供分配给页面的内存时运行，

2565
01:21:30,780 --> 01:21:33,030
0,90 90,150 150,450 450,930 1290,2250
at the point where {}

2566
01:21:33,120 --> 01:21:34,710
0,270 270,390 390,750 750,1140 1140,1590
there's no memory available anymore

2567
01:21:34,710 --> 01:21:35,910
0,150 150,570 570,660 660,720 720,1200
to allocate to the page|
|

2568
01:21:36,150 --> 01:21:37,680
0,630 630,720 720,870 870,1140 1140,1530
and you know we support
我们支持按需调页，

2569
01:21:37,680 --> 01:21:39,630
0,270 270,810 810,1230 1230,1650 1650,1950
demand paging| or whatever we
|或者我们驱逐的任何东西，通常使用 LRU 。

2570
01:21:39,630 --> 01:21:40,800
0,420 420,510 510,630 630,810 810,1170
evict you know some page

2571
01:21:40,800 --> 01:21:42,600
0,120 300,660 660,930 930,1380
you typically using LRU.|
|

2572
01:21:43,440 --> 01:21:44,700
0,330 510,840 840,960 960,1080 1080,1260
Okay.| One way to think
好的。|一种考虑的方式是，在稳定状态下，

2573
01:21:44,700 --> 01:21:46,230
0,360 360,510 510,720 720,1170 1170,1530
about is that in steady

2574
01:21:46,230 --> 01:21:47,760
0,360 360,480 480,810 810,1110 1110,1530
state,| the operating system basically
|操作系统基本上在任何时候都在使用所有内存的情况下运行。

2575
01:21:47,760 --> 01:21:49,830
0,690 990,1350 1350,1530 1530,1680 1680,2070
runs {} with all memory

2576
01:21:49,830 --> 01:21:51,930
0,90 90,540 900,1530 1530,1710 1710,2100
in use at any time.|
|

2577
01:21:52,520 --> 01:21:55,610
0,600 600,1560 2580,2880 2880,2940 2940,3090
And {} want to use
希望使用所有内存，

2578
01:21:55,610 --> 01:21:57,440
0,120 120,570 1080,1560 1560,1650 1650,1830
all memory| and so when
|所以当我们开始一些新的事情时，

2579
01:21:57,440 --> 01:21:58,430
0,90 90,300 300,480 480,900 930,990
we start something new,| you
|我们得腾出一些地方，

2580
01:21:58,430 --> 01:21:59,270
0,120 120,240 240,450 450,570 570,840
know we have to make

2581
01:21:59,270 --> 01:22:00,830
0,210 210,570 630,1260 1260,1410 1410,1560
some room| and {LRU -
|而 LRU 就是这样做的一种方式。

2582
01:22:00,830 --> 01:22:01,490
0,120 120,210 210,540 540,570 570,660
-} is basically a way

2583
01:22:01,490 --> 01:22:02,540
0,120 120,210 210,450
to do it.|
|

2584
01:22:03,290 --> 01:22:05,000
0,450 630,810 810,1170 1290,1500 1500,1710
Okay, makes sense, thank you.
好的，理解了，谢谢。
