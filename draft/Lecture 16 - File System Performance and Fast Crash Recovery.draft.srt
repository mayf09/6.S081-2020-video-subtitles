1
00:00:02,020 --> 00:00:03,670
0,450 480,990 1290,1410 1410,1590 1590,1650
Alright, actually, it's time to
好的，是时候开始了。

2
00:00:03,670 --> 00:00:07,420
0,480 2070,2640
start.| Alright,
|好的，就想 Frans 所说的，

3
00:00:07,810 --> 00:00:08,980
0,330 330,510 510,780 780,840 840,1170
okay as Frans were saying

4
00:00:08,980 --> 00:00:10,540
0,210 210,390 390,780 780,1380 1380,1560
for you,| {} feel free
|随时可以打断进行提问，

5
00:00:10,540 --> 00:00:12,190
0,90 90,420 420,540 540,1110 1110,1650
to interrupt with questions| and
|并且可以让你的摄像头开着，

6
00:00:12,970 --> 00:00:14,080
0,420 420,600 600,810 840,1020 1020,1110
feel free to leave your

7
00:00:14,080 --> 00:00:15,100
0,330 330,660 660,810 810,900 900,1020
camera on,| so that we
|这样我们就可以看到彼此。

8
00:00:15,100 --> 00:00:16,160
0,270
can

9
00:00:16,250 --> 00:00:17,450
0,360 360,480 480,660 660,780 780,1200
see each other {} people.|
|

10
00:00:18,320 --> 00:00:19,370
0,330 510,810 810,870 870,990 990,1050
{} This is going to
这将是另一节关于日志的课，

11
00:00:19,370 --> 00:00:20,870
0,90 90,360 360,660 660,900 900,1500
be another lecture about logging,|
|

12
00:00:21,230 --> 00:00:22,280
0,210 210,390 390,600 600,690 690,1050
{} this time a case
这一次对 Linux 中现在的日志系统的研究，

13
00:00:22,280 --> 00:00:24,440
0,510 510,1080 1110,1380 1530,1830 1830,2160
study of the current logging

14
00:00:24,440 --> 00:00:26,540
0,450 450,930 930,1230 1260,1770 1770,2100
{system -} in {Linux's -}|
|

15
00:00:26,810 --> 00:00:28,580
0,420 420,930 930,1170 1170,1470 1470,1770
{} {ext3 -} file system,|
ext3 文件系统，|

16
00:00:28,580 --> 00:00:30,260
0,150 150,270 270,750 750,1110 1110,1680
which is extremely widely used|
它应用非常广泛，|

17
00:00:30,620 --> 00:00:32,390
0,450 1080,1380 1380,1530 1530,1680 1680,1770
{} and we'll try to
而且我们尝试涉足一些现实世界的设计问题，

18
00:00:32,390 --> 00:00:33,530
0,240 240,570 570,810 810,930 930,1140
dip into some of the

19
00:00:33,530 --> 00:00:35,480
0,210 210,330 330,810 810,1170 1170,1950
kind of real-world design problems,|
|

20
00:00:35,510 --> 00:00:37,460
0,330 330,870 870,1050 1050,1650 1650,1950
that a high performance file
高性能文件系统必须处理的，

21
00:00:37,460 --> 00:00:38,820
0,630
system

22
00:00:38,880 --> 00:00:39,870
0,300 300,480 480,570 570,840 840,990
{} has to deal with,|
|

23
00:00:39,870 --> 00:00:41,220
0,180 180,360 540,960 960,1290 1290,1350
when it adds logging to
当它将日志添加到文件系统时。

24
00:00:41,220 --> 00:00:42,520
0,90 90,330 330,720
the file system.|
|

25
00:00:42,550 --> 00:00:43,840
0,300 300,450 450,810 870,1050 1050,1290
I'm just gonna go spend
我要花几分钟，

26
00:00:43,840 --> 00:00:46,300
0,60 60,270 270,900 1080,1620 1620,2460
a few minutes,| basically reviewing
|回顾一下为什么我们谈论日志，

27
00:00:46,600 --> 00:00:47,890
0,210 210,330 330,570 570,750 750,1290
why we're talking about logging,|
|

28
00:00:48,820 --> 00:00:51,670
0,300 300,930 1170,1740 2250,2580 2670,2850
the reason, {} that we
我们觉得日志很重要的原因是，

29
00:00:51,670 --> 00:00:53,080
0,180 180,540 540,690 690,870 870,1410
feel logging is pretty important

30
00:00:53,170 --> 00:00:54,400
0,150 150,330 330,510 510,840 930,1230
is that,| it's been a
|它是一个非常成功和重要的想法，

31
00:00:54,400 --> 00:00:56,800
0,660 660,1320 1320,1440 1440,1830 1830,2400
tremendously successful and important idea,|
|

32
00:00:57,550 --> 00:00:59,320
0,270 270,720 720,870 870,1560 1560,1770
it's almost like logging is
日志是一种神奇的方式，

33
00:00:59,320 --> 00:01:01,210
0,210 210,300 300,510 540,1320 1320,1890
kind of a magic way|
|

34
00:01:01,210 --> 00:01:03,460
0,150 150,480 480,960 960,1680 1680,2250
to add crash recovery to
将崩溃恢复添加到几乎任何现有存储系统。

35
00:01:04,330 --> 00:01:06,790
0,390 390,840 840,1020 1020,1830 1890,2460
any almost any existing storage

36
00:01:06,790 --> 00:01:07,820
0,480
system.|
|

37
00:01:07,940 --> 00:01:09,660
0,450 540,810 810,870 870,1140
{} Sort of, {}
在很多方面是不相关的，

38
00:01:09,660 --> 00:01:11,070
0,150 150,360 360,570 570,780 780,1410
in many ways pretty orthogonal|
|

39
00:01:11,070 --> 00:01:11,880
0,60 60,390 390,480 480,630 630,810
to whatever it is you're
无论你想存储的是什么。

40
00:01:11,880 --> 00:01:13,770
0,270 270,480 480,540 540,1110 1530,1890
actually trying to store.| And
|所以，你可以看到日志应用于大量不同的存储情况，

41
00:01:13,770 --> 00:01:15,060
0,120 120,270 270,420 420,780 780,1290
so you see logging applied

42
00:01:15,060 --> 00:01:16,740
0,60 60,150 150,570 570,960 960,1680
in a huge number of

43
00:01:16,830 --> 00:01:20,160
0,420 420,930 930,1830 2370,2760 2760,3330
different storage situations,| certainly databases
|当然有数据库和文件系统，

44
00:01:20,160 --> 00:01:21,330
0,120 120,420 420,840 840,960 960,1170
and file systems,| but also
|而且还有许多非常专业的系统，

45
00:01:21,330 --> 00:01:23,790
0,240 240,480 480,1140 1140,1860 2340,2460
many very specialized systems,| that
|它们需要存储东西并在崩溃后恢复。

46
00:01:23,790 --> 00:01:24,900
0,180 180,240 240,510 510,960 960,1110
need to store things and

47
00:01:24,900 --> 00:01:26,850
0,390 390,630 630,1290 1560,1830 1830,1950
recover after crashes.| {} You
|你还可以看到在分布式系统中大量使用日志，

48
00:01:26,850 --> 00:01:28,110
0,180 180,360 360,810 810,1170 1170,1260
also see logging used a

49
00:01:28,110 --> 00:01:30,900
0,570 870,1440 1440,2160 2160,2670 2670,2790
lot in distributed systems,| as
|作为从故障中恢复的一种方式，

50
00:01:30,900 --> 00:01:33,030
0,90 90,270 270,390 390,1500 1830,2130
a way of organizing the

51
00:01:33,030 --> 00:01:35,730
0,690 690,900 900,1590 1830,2280 2310,2700
recovery from failure,| because among
|因为与其他东西相比，日志是一种结构化的方式，

52
00:01:35,730 --> 00:01:36,840
0,180 180,390 390,720 720,840 840,1110
other things, logging is a

53
00:01:36,840 --> 00:01:38,220
0,570 570,810 810,870 870,1140 1140,1380
structured way of saying,| well
|这是崩溃前发生的所有事情，

54
00:01:38,250 --> 00:01:39,240
0,420 420,570 570,690 690,900 900,990
here's all the things that

55
00:01:39,240 --> 00:01:40,770
0,510 510,690 690,930 930,1020 1020,1530
happened just before the crash|
|

56
00:01:40,770 --> 00:01:42,180
0,240 450,720 720,810 810,900 900,1410
and if we can understand
如果我们能理解它们，

57
00:01:42,180 --> 00:01:43,560
0,180 180,330 330,630 630,780 780,1380
them,| then maybe we can
|也许我们就能更容易地从崩溃中恢复。

58
00:01:43,680 --> 00:01:44,730
0,390 390,540 540,600 600,900 900,1050
recover from the crash more

59
00:01:44,730 --> 00:01:45,480
0,390
easily.|
|

60
00:01:45,630 --> 00:01:46,700
0,510

61
00:01:46,700 --> 00:01:47,930
0,420 420,540 540,600 600,840 840,1230
Plus there's a huge amount
再加上有大量有趣的东西可以细想，

62
00:01:47,960 --> 00:01:49,790
0,390 690,1110 1110,1410 1410,1500 1500,1830
of interesting stuff to chew

63
00:01:49,790 --> 00:01:52,250
0,390 420,1200 1200,1980 2130,2370 2370,2460
on,| when you try to
|当你尝试构建高性能日志系统时。

64
00:01:52,250 --> 00:01:55,500
0,180 180,390 390,1500 1830,2520
build high performance {}

65
00:01:55,500 --> 00:01:57,380
0,600 600,1320
logging systems.|
|

66
00:01:57,560 --> 00:01:58,400
0,300 300,450 450,480 480,810 810,840
And as I mentioned a
就像我几分钟前提到的，

67
00:01:58,400 --> 00:01:59,360
0,150 150,390 390,660 660,840 840,960
few minutes ago,| just as
|作为术语，当我们讨论日志时，

68
00:01:59,360 --> 00:02:02,240
0,210 330,750 750,840 840,1770 2220,2880
a point of terminology when

69
00:02:02,240 --> 00:02:03,980
0,150 150,360 360,600 600,1350 1440,1740
we talk about log,| it's
|它谈论的事情和今天的读物完全一样，

70
00:02:04,010 --> 00:02:05,090
0,240 240,360 360,510 510,1020 1020,1080
talking about this exactly the

71
00:02:05,090 --> 00:02:06,770
0,270 270,540 540,720 720,1140 1140,1680
same thing as today's reader,|
|

72
00:02:06,860 --> 00:02:08,240
0,480 480,660 660,960 960,1200 1200,1380
reading was talking about when
读物说的是 journal 这个词，

73
00:02:08,240 --> 00:02:09,170
0,90 90,390 420,630 630,720 720,930
it said use the word

74
00:02:09,170 --> 00:02:12,500
0,510 540,720 720,1080 1110,1980 3030,3330
journal,| they're just synonyms.| And
|它们是同义词。|此外，今天的读物谈到了

75
00:02:12,500 --> 00:02:14,390
0,450 450,810 1020,1380 1380,1650 1650,1890
furthermore the today's reading talked

76
00:02:14,390 --> 00:02:15,650
0,240 270,660 660,750 750,1140 1140,1260
about| adding a journal to
|在 ext2 中增加 journal ，

77
00:02:15,650 --> 00:02:17,960
0,510 510,1050 1320,1560 1560,1950 1950,2310
{ext2 -},| the modern name
|结果文件系统的现代名称是 ext3 ，

78
00:02:17,960 --> 00:02:19,310
0,90 90,210 210,750 750,1020 1020,1350
for the resulting file system

79
00:02:19,310 --> 00:02:22,000
0,180 180,750 750,1410
is {ext3 -},|
|

80
00:02:22,810 --> 00:02:23,920
0,270 270,510 510,810 810,990 990,1110
{} which is how I'm
我就是这么称呼它的。

81
00:02:23,920 --> 00:02:24,820
0,120 120,180 180,480 480,630 630,900
going to refer to it.|
|

82
00:02:25,840 --> 00:02:26,960
0,600
Okay,
好的，我想花点时间，

83
00:02:27,500 --> 00:02:29,570
0,540 960,1170 1170,1290 1290,1350 1350,2070
{} I want to spend,|
|

84
00:02:29,600 --> 00:02:31,640
0,510 630,1440 1440,1590 1590,1710 1710,2040
the way I'm going to
我要谈论 ext3 的方式是

85
00:02:31,670 --> 00:02:34,700
0,450 450,990 1170,1680 1680,2280 2370,3030
talk about {ext3 -} is|
|

86
00:02:35,630 --> 00:02:36,980
0,450 450,1020 1020,1110 1110,1200 1200,1350
by contrasting it to some
将它与 xv6 进行某种程度的对比，

87
00:02:36,980 --> 00:02:38,150
0,360 360,510 510,690 690,810 810,1170
extent with {xv6 - -}|
|

88
00:02:38,150 --> 00:02:39,770
0,90 90,750 750,1290 1290,1380 1380,1620
and explaining ways in which
并解释 ext3 修复一些性能问题的方法，

89
00:02:39,770 --> 00:02:42,080
0,420 420,780 780,1500 1530,1740 1740,2310
{ext3 -} fixes some performance

90
00:02:42,080 --> 00:02:44,840
0,750 930,1770 2070,2490
problems,| {} that
|xv6 日志具有的问题，

91
00:02:44,930 --> 00:02:46,790
0,420 420,780 780,1140 1140,1710 1710,1860
{xv6 -} logging has| and
|并在过程中改变一些语义，

92
00:02:46,790 --> 00:02:47,900
0,270 270,330 330,540 540,1050 1050,1110
along the way changes a

93
00:02:47,900 --> 00:02:49,730
0,240 240,360 360,510 510,1200 1200,1830
few of the semantic of,|
|

94
00:02:51,260 --> 00:02:51,600
0,150

95
00:02:52,220 --> 00:02:54,260
0,180 180,510 510,750 750,1500
what happens during crashes.|
在崩溃中会发生什么。|

96
00:02:55,380 --> 00:02:57,300
0,360 360,480 480,630 630,990 1170,1920
Alright, so this is {
好的，这是 xv6 的日志回顾，

97
00:02:57,420 --> 00:02:59,420
0,180 180,420 420,570 570,1410
-} {xv6 - -}

98
00:02:59,670 --> 00:03:02,580
0,630 660,1140 1140,1740 1890,2280 2280,2910
{} log review,| should remember,|
|应该记住，|

99
00:03:03,120 --> 00:03:04,560
0,840

100
00:03:07,870 --> 00:03:09,440
0,720

101
00:03:09,500 --> 00:03:12,200
0,90 90,870 1680,2010 2040,2370 2370,2700
this disk, the file system
这个 xv6 的文件系统磁盘，

102
00:03:12,200 --> 00:03:13,640
0,450 450,600 600,780 780,930 930,1440
disk for {xv6 - -},|
|

103
00:03:13,820 --> 00:03:15,050
0,420 780,900 900,960 960,1110 1110,1230
there's you know you can
你可以认为它有两个部分，

104
00:03:15,050 --> 00:03:15,950
0,330 330,390 390,480 480,600 600,900
think of it as having

105
00:03:15,950 --> 00:03:17,390
0,330 330,900 900,1050 1050,1260 1260,1440
two parts,| it's got a
|它上面有一个文件系统树，

106
00:03:17,420 --> 00:03:19,340
0,660 660,1080 1080,1500 1500,1710 1710,1920
file system tree on it,|
|

107
00:03:19,340 --> 00:03:21,080
0,180 180,360 420,840 840,1620 1620,1740
with a root directory| and
有一个根目录，|在根目录下，可能还有其他目录，

108
00:03:21,080 --> 00:03:22,280
0,180 180,300 300,480 480,990 990,1200
under the root directory, maybe

109
00:03:22,280 --> 00:03:24,410
0,210 210,480 480,1380 1380,1590 1740,2130
there's other directories {} in

110
00:03:24,410 --> 00:03:26,090
0,660 690,840 840,1050 1050,1170 1170,1680
those,| this might be directory
|可能是目录一和目录二，

111
00:03:26,090 --> 00:03:28,760
0,420 420,780 780,1410 1410,2070 2430,2670
one and directory two, {}|
|

112
00:03:28,760 --> 00:03:29,480
0,150 150,270 270,480 480,570 570,720
we can think of this
我们可以认为文件系统只是一个数据结构，

113
00:03:29,480 --> 00:03:30,770
0,360 420,840 840,1020 1020,1110 1110,1290
as file system is just

114
00:03:30,770 --> 00:03:31,790
0,60 60,390 390,840 840,960 960,1020
a data structure,| is a
|是一个树形结构的数据结构，

115
00:03:31,820 --> 00:03:34,010
0,330 330,750 750,990 990,1560 1830,2190
tree structure data structure,| may
|可能它有文件，位于目录中，

116
00:03:34,010 --> 00:03:35,960
0,90 90,150 150,330 330,1500
be it has files,

117
00:03:35,960 --> 00:03:38,000
0,360 360,690 690,780 780,870 870,2040
{} sitting in the directories|
|

118
00:03:38,120 --> 00:03:40,370
0,330 330,480 480,720 720,1350 1350,2250
{} and each file has
每个文件中都有一些块编号，

119
00:03:40,880 --> 00:03:42,020
0,330 330,750 750,930 930,1080 1080,1140
a block number of a

120
00:03:42,020 --> 00:03:42,950
0,210 210,270 270,660 660,750 750,930
bunch of blocks in it|
|

121
00:03:43,100 --> 00:03:45,080
0,360 360,540 540,900 1170,1680 1680,1980
and there's some other data,
还有一些其他的数据，不是树形结构，

122
00:03:45,080 --> 00:03:46,130
0,210 210,330 330,480 480,690 690,1050
that's not really tree structure,|
|

123
00:03:46,130 --> 00:03:47,540
0,150 150,330 330,450 450,720 720,1410
like, there's the {bitmap -},
比如，这里有一个位图，表示每个块，

124
00:03:47,900 --> 00:03:49,670
0,540 540,840 870,1080 1080,1620 1620,1770
{ -} that indicates for

125
00:03:49,670 --> 00:03:51,440
0,240 240,780 810,1200 1200,1410 1410,1770
every block,| whether that block
|它是空闲的还是分配的。

126
00:03:51,440 --> 00:03:53,060
0,480 510,660 660,840 870,1500 1500,1620
is you know free or

127
00:03:53,060 --> 00:03:54,220
0,690
allocated.|
|

128
00:03:54,540 --> 00:03:57,870
0,510 1860,2250 2250,2610 2670,3210 3210,3330
{} And the inodes and
索引结点，目录内容和位图块

129
00:03:57,870 --> 00:03:59,310
0,150 150,690 690,1260 1260,1350 1350,1440
the directory contents and the

130
00:03:59,310 --> 00:04:00,780
0,210 210,450 450,1110 1110,1290 1290,1470
{bitmap -} blocks| are going
|被称为元数据，

131
00:04:00,780 --> 00:04:02,070
0,90 90,300 300,390 390,540 540,1290
to refer to as metadata,|
|

132
00:04:02,760 --> 00:04:04,560
0,750 750,1080 1080,1200 1200,1470 1470,1800
contrast blocks that hold file
对比保存文件内容的块，我们称为文件内容块。

133
00:04:04,560 --> 00:04:06,960
0,450 450,870 900,990 990,1320 2160,2400
content which we'll call file

134
00:04:06,960 --> 00:04:09,480
0,300 300,780 1680,1980 1980,2250 2280,2520
content blocks.| Okay, so in
|好的，那么除了文件系统，

135
00:04:09,480 --> 00:04:10,920
0,300 300,360 360,450 450,720 720,1440
addition to the file system,|
|

136
00:04:11,370 --> 00:04:14,190
0,600 630,930 930,1170 1170,2190 2370,2820
{} {xv6 -} log, near
xv6 日志，在磁盘的开头附近，

137
00:04:14,190 --> 00:04:15,240
0,60 60,420 420,480 480,570 570,1050
the beginning of the disk|
|

138
00:04:15,240 --> 00:04:16,860
0,240 360,810 810,1020 1020,1290 1290,1620
and {xv6 -} log is
xv6 日志相对简单，

139
00:04:16,890 --> 00:04:18,360
0,390 390,750 750,840 840,1050 1050,1470
relatively simple,| it has this
|它有 header 块，

140
00:04:18,390 --> 00:04:19,840
0,510 510,1080
header block,|
|

141
00:04:20,990 --> 00:04:23,270
0,720 990,1320 1320,1590 1590,1860 1860,2280
{} and then some number
然后是一些区块，包含块的更新版本。

142
00:04:23,270 --> 00:04:25,790
0,390 600,1260 1260,1410 1410,1860 1890,2520
of blocks, that contain updated

143
00:04:25,790 --> 00:04:27,980
0,840 840,1320 1590,2040 2040,2130 2130,2190
versions of blocks| from the
|来自文件系统数据块和元数据块。

144
00:04:27,980 --> 00:04:30,140
0,300 300,840 1020,1290 1290,1770 1770,2160
file system data blocks and

145
00:04:30,140 --> 00:04:32,900
0,450 450,1170
metadata blocks.|
|

146
00:04:33,510 --> 00:04:35,490
0,420 960,1110 1110,1290 1290,1710 1710,1980
And in this [initial] header
在这个开始的 header 块中，

147
00:04:35,490 --> 00:04:38,940
0,540 570,1290 1290,1650 1680,2280 2280,3450
block,| there's a block numbers,|
|有一个块编号，|

148
00:04:39,060 --> 00:04:42,180
0,450 450,1380 1710,2220 2250,2730 2730,3120
{} where {} these blocks
那些日志中的块应该写入的位置，

149
00:04:42,180 --> 00:04:43,290
0,120 120,510 510,510 510,690 690,1110
{in,the} log ought to be

150
00:04:43,900 --> 00:04:45,610
0,390 810,1080 1080,1290 1290,1470 1470,1710
{} written to,| like maybe
|比如，第一个应该去块 17 ，

151
00:04:45,610 --> 00:04:46,330
0,120 120,360 360,510 510,660 660,720
the first one should go

152
00:04:46,330 --> 00:04:47,830
0,90 90,360 360,1200 1200,1320 1320,1500
to block 17| and then
|然后是 29 ，无论是什么。

153
00:04:47,830 --> 00:04:49,870
0,870 930,1470 1470,1650 1650,1950 1950,2040
29, who knows whatever it

154
00:04:49,870 --> 00:04:52,090
0,390 1680,1950 1950,2070 2070,2160 2160,2220
maybe.| And then in the
|然后在计算机中，

155
00:04:52,090 --> 00:04:53,220
0,660
computer,|
|

156
00:04:54,310 --> 00:04:55,330
0,300 300,420 420,540 540,690 690,1020
{} we have some user
我们有一些用户进程可能调用 write create ，

157
00:04:55,330 --> 00:04:57,370
0,510 510,720 720,960 960,1380 1380,2040
process, that's maybe calling write,

158
00:04:57,670 --> 00:04:59,140
0,630 630,810 810,960 960,1260 1260,1470
create,| some other system call
|某些其他修改文件系统的系统调用。

159
00:04:59,140 --> 00:05:00,430
0,60 60,480 480,570 570,810 810,1290
that modifies the file system.|
|

160
00:05:03,110 --> 00:05:04,970
0,810 840,1260 1260,1440 1440,1530 1530,1860
And, {} there's a block
而且，计算机中有一个块缓存，

161
00:05:04,970 --> 00:05:06,320
0,900
cache

162
00:05:06,320 --> 00:05:07,490
0,120 120,180 180,570 570,660 660,1170
in the computer| and initially
|最初 write 只会进入块缓存，

163
00:05:07,490 --> 00:05:08,390
0,120 120,510 510,720 720,810 810,900
the writes just go to

164
00:05:08,390 --> 00:05:10,060
0,90 90,390 390,1140
the block cache,|
|

165
00:05:10,350 --> 00:05:11,640
0,720

166
00:05:13,470 --> 00:05:15,330
0,240 240,450 450,870 870,1200 1410,1860
it's just copies of {}
它只是磁盘上块的拷贝，

167
00:05:15,390 --> 00:05:17,060
0,390 390,540 540,630 630,1170
block from the disk,|
|

168
00:05:17,410 --> 00:05:20,470
0,540 1020,1380 1380,1800 1800,2250 2250,3060
{} so initially write updates
所以最初 write 更新文件块或索引节点

169
00:05:20,470 --> 00:05:21,880
0,390 390,720 720,810 810,930 930,1410
file blocks or {inodes -}|
|

170
00:05:21,880 --> 00:05:23,770
0,120 120,720 1110,1560 1560,1770 1770,1890
or whatever those writes go
或其他写入到那里的任何东西，

171
00:05:23,770 --> 00:05:25,300
0,420 420,510 510,930 1050,1440 1440,1530
there,| and then at the
|然后在操作结束时，

172
00:05:25,300 --> 00:05:27,760
0,120 120,180 180,240 240,1020 2190,2460
end of an operation,| these
|这些数据块被复制到日志中，

173
00:05:27,760 --> 00:05:28,600
0,270 270,330 330,660 660,720 720,840
blocks are copied to the

174
00:05:28,600 --> 00:05:29,530
0,300 300,390 390,510 510,630 630,930
log| and when we've copied
|当我们复制完所有数据块时，

175
00:05:29,530 --> 00:05:30,940
0,120 120,180 180,570 570,1020 1020,1410
all the block's log,| then
|然后我们将块编号写入 header 块，

176
00:05:31,710 --> 00:05:32,910
0,210 210,570 570,690 690,960 960,1200
we write the block numbers

177
00:05:32,910 --> 00:05:33,630
0,60 60,150 150,390 390,630 630,720
to the header block,| to
|表示这个事务更新已完成。

178
00:05:33,630 --> 00:05:36,570
0,420 420,600 1110,1470 1560,1950 1950,2940
indicate that {} this transactions

179
00:05:36,570 --> 00:05:37,980
0,210 210,270 270,720 720,810 810,1410
where is updates is complete.|
|

180
00:05:39,060 --> 00:05:40,020
0,300 300,360 360,480 480,840 840,960
And in the code for
在文件系统的代码中，你会看到，

181
00:05:40,020 --> 00:05:41,430
0,90 90,360 360,690 690,840 840,1410
the file system, you'll see,|
|

182
00:05:43,240 --> 00:05:45,790
0,480 690,1350 1380,1860 1860,2280 2280,2550
that every system call that
每个修改文件系统的系统调用，

183
00:05:45,820 --> 00:05:48,550
0,600 600,690 690,1020 1020,1650 2250,2730
modifies the file system,| somewhere
|某处有一个 begin_op ，

184
00:05:48,550 --> 00:05:49,600
0,120 120,180 180,570 570,870 870,1050
has a {begin_op -},| which
|表示将要开始对文件系统的一组更新，

185
00:05:49,600 --> 00:05:51,400
0,450 540,720 720,1290 1290,1380 1380,1800
says {} about to start

186
00:05:51,400 --> 00:05:53,470
0,480 480,1110 1140,1320 1320,1980 1980,2070
a group of updates to

187
00:05:53,470 --> 00:05:55,600
0,120 120,510 510,1140 1320,1800 1800,2130
the file system,| please don't
|在我做完之前，不要做它们中的任何一个，

188
00:05:55,600 --> 00:05:56,830
0,300 300,630 630,720 720,900 900,1230
do any of them until

189
00:05:56,830 --> 00:05:58,480
0,150 150,840 960,1230 1230,1290 1290,1650
I finished,| so we have|
|所以我们有，|

190
00:05:58,480 --> 00:05:59,590
0,90 90,420 660,870 870,930 930,1110
and then there's a bunch
然后有些读取和写入块，

191
00:05:59,590 --> 00:06:01,210
0,60 60,510 510,840 840,1470 1470,1620
of block reads writes| and
|然后是 end_op ，

192
00:06:01,210 --> 00:06:02,180
0,450
then

193
00:06:02,240 --> 00:06:04,360
0,510 750,1050 1050,1590
{} {end_op -},|
|

194
00:06:04,690 --> 00:06:06,010
0,360 360,720 720,840 840,1110 1110,1320
which tells the file system
它告诉文件系统日志系统

195
00:06:06,010 --> 00:06:08,080
0,300 300,750 960,1350 1350,1890 1890,2070
logging system| {} completely done
|完全完成我要执行的所有写入。

196
00:06:08,080 --> 00:06:08,920
0,180 180,270 270,540 540,660 660,840
all the writes I'm gonna

197
00:06:08,920 --> 00:06:12,010
0,390 630,1110 1380,2640 2640,2700 2700,3090
do.| So between the begin_op
|所以，在 begin_op 和 end_op 之间，

198
00:06:12,010 --> 00:06:13,180
0,180 180,270 270,510 510,930 930,1170
and the {end_op -},| the
|写入仅进入缓存，

199
00:06:13,180 --> 00:06:14,320
0,480 480,810 810,960 960,1050 1050,1140
writes only go to the

200
00:06:14,320 --> 00:06:16,690
0,840 1080,1440 1590,1890 1890,2130 2130,2370
cache| and {} when the
|当系统调用进行 end_op 调用时，

201
00:06:16,960 --> 00:06:18,250
0,390 390,720 720,960 960,1110 1110,1290
system call makes this {end_op

202
00:06:18,250 --> 00:06:20,440
0,180 180,720 930,1590 1680,1920 1920,2190
-} call,| then the file
|然后，文件系统将修改后的块从缓存复制到日志中。

203
00:06:20,440 --> 00:06:22,630
0,360 360,960 960,1320 1410,1920 1920,2190
system copies the modified blocks

204
00:06:22,630 --> 00:06:23,650
0,90 90,180 180,720 720,900 900,1020
from the cache into the

205
00:06:23,650 --> 00:06:24,640
0,570
log.|
|

206
00:06:24,670 --> 00:06:27,100
0,390 480,1200 1650,1860 1860,2100 2100,2430
And after it's written all
在将所有这些修改过的数据块写入日志后，

207
00:06:27,100 --> 00:06:28,270
0,210 210,630 630,930 930,1080 1080,1170
these modified blocks into the

208
00:06:28,270 --> 00:06:30,220
0,510 540,1140 1140,1650 1650,1860 1860,1950
log,| only then, does the
|只有这样，文件系统才会将块编号写入

209
00:06:30,220 --> 00:06:31,450
0,270 270,570 570,810 810,870 870,1230
file system write the block

210
00:06:31,450 --> 00:06:34,510
0,840 1140,1590 2100,2370 2370,2760 2760,3060
numbers| in a single disk,
|单个磁盘中，写入到 header 块。

211
00:06:34,510 --> 00:06:36,040
0,390 600,720 720,810 810,1050 1050,1530
right, to the header block.|
|

212
00:06:36,760 --> 00:06:37,870
0,300 330,630 630,840 840,1020 1020,1110
{} And that's called the
这称为提交点，

213
00:06:37,870 --> 00:06:39,130
0,390 390,870 900,1050 1050,1140 1140,1260
commit point,| this is the
|这是文件系统将这些块编号写入 header 块之前的点，

214
00:06:39,130 --> 00:06:40,900
0,330 330,1020 1020,1170 1170,1440 1440,1770
point before the file system

215
00:06:40,900 --> 00:06:42,010
0,240 240,420 420,750 750,1020 1020,1110
wrote these block numbers to

216
00:06:42,010 --> 00:06:43,390
0,90 90,330 330,870 1110,1320 1320,1380
the header block,| if the
|如果发生了崩溃，

217
00:06:43,390 --> 00:06:45,460
0,390 390,510 510,1140 1260,1830 1830,2070
crash had happened,| then none
|这些写入都不会应用，

218
00:06:45,460 --> 00:06:46,690
0,120 120,390 390,1020 1020,1140 1140,1230
of these writes would have

219
00:06:46,690 --> 00:06:49,390
0,120 120,990 1440,2220 2220,2310 2310,2700
been applied,| after the crash
|在崩溃和重新启动之后。

220
00:06:49,390 --> 00:06:50,540
0,120 120,720
and reboot.|
|

221
00:06:50,750 --> 00:06:52,430
0,390 390,510 510,810 810,1350 1350,1680
After the file system writes
在文件系统写入 header 块的块编号之后，

222
00:06:52,430 --> 00:06:53,270
0,180 180,480 480,720 720,780 780,840
these block numbers of the

223
00:06:53,270 --> 00:06:55,760
0,240 240,780 1200,1950 1950,2130 2130,2490
header block,| after that {this,write}
|在这个写入完成后，

224
00:06:55,760 --> 00:06:57,590
0,120 120,600 630,780 780,960 960,1830
is complete,| then it's guaranteed
|那么可以保证，

225
00:06:57,590 --> 00:06:58,400
0,240 270,510 510,600 600,750 750,810
that,| even if there's a
|即使在这一点上发生崩溃，

226
00:06:58,400 --> 00:06:59,900
0,390 390,480 480,660 660,990 1230,1500
crash at this point,| the
|恢复软件也会查看日志，

227
00:06:59,900 --> 00:07:01,160
0,480 480,870 870,1020 1020,1200 1200,1260
recovery software will look at

228
00:07:01,160 --> 00:07:02,900
0,120 120,660 690,1410 1410,1530 1530,1740
the log,| see that there's
|看到在 header 块中有块编号，

229
00:07:02,900 --> 00:07:04,070
0,330 330,720 720,840 840,900 900,1170
block numbers in the header

230
00:07:04,070 --> 00:07:06,200
0,450 510,1110 1170,1680 1680,1920 1920,2130
block| and write all these
|将这些在 header 块中提到的块写入

231
00:07:06,200 --> 00:07:07,430
0,510 510,630 630,660 660,1110 1110,1230
blocks that are mentioned in

232
00:07:07,430 --> 00:07:09,170
0,60 60,270 270,720 750,1230 1230,1740
the header block| to their
|它们在文件系统的原位置。

233
00:07:09,200 --> 00:07:11,570
0,510 510,1590 1770,1950 1950,2040 2040,2370
home locations in the file

234
00:07:11,570 --> 00:07:12,360
0,420
system.|
|

235
00:07:12,960 --> 00:07:14,100
0,270 300,480 480,690 690,900 900,1140
And so what's going on
所以这里是一种技术，

236
00:07:14,100 --> 00:07:15,930
0,210 210,540 540,630 630,1350 1500,1830
here is a technique| to
|允许所有的写入，

237
00:07:15,930 --> 00:07:17,430
0,510 510,870 870,990 990,1110 1110,1500
allow all of the writes,|
|

238
00:07:17,430 --> 00:07:18,810
0,120 120,660 780,960 960,1020 1020,1380
that happen in the system
在 begin_op 和 end_op 之间的系统调用中发生

239
00:07:18,810 --> 00:07:20,010
0,210 210,540 540,600 600,960 960,1200
call between the {begin_op -}

240
00:07:20,010 --> 00:07:21,900
0,90 90,180 180,450 450,900 1770,1890
and the {end_op -}| to
|是原子的，关于崩溃，

241
00:07:21,900 --> 00:07:23,550
0,300 330,1020 1020,1140 1140,1560 1560,1650
be atomic with respect to

242
00:07:23,550 --> 00:07:24,940
0,990
crashes,|
|

243
00:07:25,160 --> 00:07:26,660
0,210 210,510 540,1140 1140,1410 1410,1500
that is either all of
要么所有的事情都发生，

244
00:07:26,660 --> 00:07:28,060
0,180 180,780
them happen,|
|

245
00:07:28,380 --> 00:07:29,400
0,240 240,330 330,570 570,810 810,1020
because the file system got
因为文件系统在崩溃之前只写 header 块，

246
00:07:29,400 --> 00:07:30,180
0,150 150,330 330,450 450,720 720,780
as far as writing the

247
00:07:30,180 --> 00:07:31,860
0,270 270,540 540,810 810,900 900,1680
header block before the crash|
|

248
00:07:32,100 --> 00:07:33,360
0,180 180,480 480,600 600,720 720,1260
or none of them happen,|
或者它们都没有发生，|

249
00:07:33,980 --> 00:07:35,930
0,450 450,510 510,810 810,1170 1170,1950
because the crash happened before
因为崩溃发生在文件系统写入 header 块之前。

250
00:07:35,960 --> 00:07:36,890
0,120 120,360 360,660 660,840 840,930
the file system wrote the

251
00:07:36,890 --> 00:07:38,140
0,240 240,780
header block.|
|

252
00:07:39,620 --> 00:07:40,520
0,150 150,270 270,360 360,750 750,900
And so it's important that
所以重要的是，在崩溃和重启之后，

253
00:07:40,520 --> 00:07:41,720
0,240 240,300 300,600 600,690 690,1200
after a crash and restart,|
|

254
00:07:41,720 --> 00:07:42,950
0,180 180,300 300,720 720,1050 1050,1230
there's some recovery software that
有一些恢复软件可以运行来读取日志，

255
00:07:42,950 --> 00:07:44,330
0,300 300,450 450,690 690,810 810,1380
runs that reads the log,|
|

256
00:07:44,420 --> 00:07:45,680
0,420 420,480 480,540 540,810 810,1260
looks at the header block|
查看 header 块，|

257
00:07:45,710 --> 00:07:47,510
0,180 180,960 1320,1500 1500,1590 1590,1800
and decides is the header
并确定块编号是不是在 header 块中，

258
00:07:47,510 --> 00:07:48,770
0,240 240,540 540,840 840,1140 1140,1260
block actually block numbers in

259
00:07:48,770 --> 00:07:49,820
0,180 180,270 270,720 810,960 960,1050
it or not,| if it
|如果是，

260
00:07:49,820 --> 00:07:50,900
0,690
does,|
|

261
00:07:50,990 --> 00:07:53,600
0,360 840,1530 1530,2010 2010,2520 2520,2610
{} writes possibly rewrite all
写操作可能会将所有这些数据块重写到它们的原位置，

262
00:07:53,600 --> 00:07:54,590
0,210 210,600 600,690 690,810 810,990
these blocks to their home

263
00:07:54,590 --> 00:07:56,600
0,810 990,1230 1230,1320 1320,1500 1500,2010
locations,| if the header blocks
|如果 header 块中没有任何块编号，

264
00:07:56,630 --> 00:07:57,890
0,510 510,630 630,750 750,990 990,1260
doesn't have any block numbers

265
00:07:57,890 --> 00:07:58,760
0,120 120,240 240,420 420,510 510,870
in it,| then the recovery
|则恢复软件不会执行任何操作。

266
00:07:58,760 --> 00:08:00,280
0,270 270,450 450,810
software does nothing.|
|

267
00:08:00,640 --> 00:08:01,760
0,510

268
00:08:02,260 --> 00:08:03,340
0,180 180,540 540,690 690,840 840,1080
Any questions about this quick
关于这个快速复习，有什么问题？

269
00:08:03,340 --> 00:08:04,400
0,450
review?|
|

270
00:08:10,740 --> 00:08:12,450
0,480 510,930 1200,1380 1380,1440 1440,1710
Okay, {} there's a couple
好的，有几点非常重要，

271
00:08:12,450 --> 00:08:15,940
0,300 780,1200 1200,1650 1650,2340
of super important points,|
|

272
00:08:16,660 --> 00:08:19,300
0,570 780,1170 1200,1800 1800,2220 2400,2640
{} to remember about {xv6
记住 xv6 ，甚至大多数日志记录系统。

273
00:08:19,300 --> 00:08:21,040
0,120 120,480 480,960 1050,1470 1470,1740
- -} and indeed most

274
00:08:21,040 --> 00:08:22,780
0,270 270,780 810,1320 1320,1500 1500,1740
logging systems.| One is that
|一个是 xv6 以及所有日志系统

275
00:08:22,780 --> 00:08:24,130
0,180 180,330 330,840 840,1050 1050,1350
{xv6 - -} all logging

276
00:08:24,130 --> 00:08:26,200
0,480 480,1080 1110,1620 1620,1830 1830,2070
systems,| essentially obey what's called
|都遵循所谓的预写规则。

277
00:08:26,200 --> 00:08:27,800
0,90 90,330 330,630 630,1080
the {write-ahead -} rule.|
|

278
00:08:28,530 --> 00:08:30,000
0,360 360,870
That is
也就是说，当你有一些操作的一些写入，

279
00:08:33,080 --> 00:08:33,860
0,330 330,390 390,480 480,570 570,780
whenever you have a bunch

280
00:08:33,860 --> 00:08:34,940
0,90 90,510 510,720 720,870 870,1080
of writes done by some

281
00:08:34,940 --> 00:08:36,260
0,570 570,660 660,840 840,1080 1080,1320
operation| and those writes all
|而这些写入都需要是原子的，

282
00:08:36,260 --> 00:08:39,180
0,210 210,300 300,420 420,1290
need to be atomic,|
|

283
00:08:39,760 --> 00:08:42,370
0,180 180,570 570,1170 1170,1650 1740,2610
the system has to write
系统必须将所有这些更新的的数据写入日志，

284
00:08:42,960 --> 00:08:44,940
0,450 450,570 570,1080 1110,1800 1800,1980
all of these updated, all

285
00:08:44,940 --> 00:08:46,380
0,120 120,660 780,1170 1170,1290 1290,1440
the updated data to the

286
00:08:46,380 --> 00:08:48,750
0,840 960,1860 1860,1950 1950,2040 2040,2370
log,| before it is allowed
|在允许将应用这些更新之前，

287
00:08:48,750 --> 00:08:49,950
0,60 60,510 510,870 870,960 960,1200
to apply any of those

288
00:08:49,950 --> 00:08:51,690
0,780 810,930 930,1020 1020,1200 1200,1740
updates| to the home locations
|到文件系统中的原位置，

289
00:08:51,690 --> 00:08:53,040
0,60 60,150 150,480 480,900 1080,1350
in the file system,| that
|也就是说，我们需要预先声明所有更新，

290
00:08:53,040 --> 00:08:54,330
0,240 300,720 720,900 900,1230 1230,1290
is that we're required to

291
00:08:54,330 --> 00:08:55,890
0,180 180,240 240,570 570,1260 1260,1560
sort of pre declare all

292
00:08:55,890 --> 00:08:56,910
0,150 150,630 630,750 750,840 840,1020
the updates| that we want
|我们想要是原子的，

293
00:08:56,910 --> 00:08:59,400
0,60 60,690 720,900 900,1680 1980,2490
to have the atomic, {}|
|

294
00:08:59,430 --> 00:09:00,270
0,240 240,540 540,690 690,750 750,840
pre declare them in the
在日志中预先声明它们，

295
00:09:00,270 --> 00:09:01,860
0,300 300,570 570,690 690,900 1020,1590
log,| before we can apply
|在我们可以将任何一个应用到文件系统之前，

296
00:09:01,860 --> 00:09:02,460
0,240 240,300 300,420 420,510 510,600
any of them to the

297
00:09:02,460 --> 00:09:03,870
0,270 270,600 810,1140 1140,1380 1380,1410
file system,| as called the
|即所谓的预写规则。

298
00:09:03,870 --> 00:09:05,060
0,210 210,450 450,780
{write-ahead -} rule.|
|

299
00:09:05,970 --> 00:09:07,380
0,270 270,360 360,540 540,630 630,1410
This is really the foundation
这是日志允许崩溃恢复的基础。

300
00:09:07,380 --> 00:09:08,240
0,330
of

301
00:09:08,670 --> 00:09:11,250
0,570 900,1170 1170,1710 1830,2250 2250,2580
{} how logging allows crash

302
00:09:11,250 --> 00:09:12,360
0,540
recovery.|
|

303
00:09:12,360 --> 00:09:13,290
0,210 210,330 330,540 540,720 720,930
So the {write-head -} rule
所以，预先规则允许这些更新

304
00:09:13,290 --> 00:09:15,660
0,480 480,960 1230,1710 1710,1800 1800,2370
allows this collection of updates|
|

305
00:09:15,660 --> 00:09:16,600
0,300
to
相对于崩溃看起来是原子的。

306
00:09:16,660 --> 00:09:17,980
0,420 420,840 840,960 960,1260 1260,1320
appear atomic with respect to

307
00:09:17,980 --> 00:09:20,230
0,630 990,1380 1440,1800 1800,2040 2040,2250
crashes.| {} There's another rule
|还有一条我没有谈到的规则，

308
00:09:20,230 --> 00:09:23,180
0,210 210,480 480,720 720,1080
I haven't talked about,|
|

309
00:09:23,800 --> 00:09:25,930
0,240 240,450 450,870 1110,1320 1320,2130
which is that we can't
那就是我们不能释放或重复使用日志，

310
00:09:26,540 --> 00:09:28,910
0,600 600,810 810,1740 1740,1860 1860,2370
free or reuse the log,|
|

311
00:09:28,910 --> 00:09:30,680
0,90 90,180 180,630 750,1200 1440,1770
you know we xv6 use
xv6 对每个系统调用反复使用日志，

312
00:09:30,680 --> 00:09:31,460
0,90 90,300 300,510 510,600 600,780
the log over and over

313
00:09:31,460 --> 00:09:32,570
0,270 270,480 480,630 630,810 810,1110
again,| ones for every system
|每个系统调用一次，

314
00:09:32,570 --> 00:09:33,890
0,360 420,720 720,990 990,1140 1140,1320
call,| we cannot allow to
|我们不允许重用日志，

315
00:09:33,890 --> 00:09:35,750
0,360 360,450 450,1080 1110,1500 1500,1860
reuse the log,| until all
|在日志中的所有写入

316
00:09:35,750 --> 00:09:36,770
0,90 90,270 270,780 780,930 930,1020
of the writes that are

317
00:09:36,770 --> 00:09:37,760
0,120 120,240 240,600 600,720 720,990
in the log| have actually
|都已经写入磁盘上的原位置之前。

318
00:09:37,760 --> 00:09:38,660
0,180 180,420 420,510 510,690 690,900
been written to their home

319
00:09:38,660 --> 00:09:40,480
0,540 540,660 660,780 780,1410
locations on the disk.|
|

320
00:09:40,510 --> 00:09:42,040
0,480 750,1140 1140,1260 1260,1320 1320,1530
{} So this is also
所以这也是我所说的释放法则，

321
00:09:42,040 --> 00:09:43,030
0,150 150,210 210,390 390,480 480,990
what I {called -} freeing

322
00:09:43,030 --> 00:09:44,140
0,540
rule,|
|

323
00:09:45,010 --> 00:09:46,280
0,720

324
00:09:47,690 --> 00:09:49,320
0,330 330,1140
which says,
也就是说，我们不能覆盖或重用日志，直到，

325
00:09:49,750 --> 00:09:52,060
0,360 360,720 720,1260 1260,1410 1410,2310
we can't overwrite or reuse

326
00:09:52,090 --> 00:09:54,580
0,210 210,360 360,960 1050,1860 2220,2490
{} the log until, {}|
|

327
00:09:54,580 --> 00:09:56,710
0,180 180,450 1200,1530 1530,1800 1800,2130
or the part of log
或者部分日志包含指定事务，

328
00:09:56,710 --> 00:09:58,330
0,90 90,330 330,390 390,750 750,1620
that holds a particular transaction,|
|

329
00:09:58,570 --> 00:09:59,410
0,150 150,240 240,480 480,570 570,840
you know set of writes
一组需要原子的写入，

330
00:09:59,410 --> 00:10:00,340
0,90 90,240 240,300 300,390 390,930
that need to be atomic,|
|

331
00:10:00,400 --> 00:10:01,510
0,240 240,450 450,780 780,930 930,1110
we can't reuse that part
我们不能重用这部分日志，

332
00:10:01,510 --> 00:10:02,530
0,60 60,120 120,420 420,630 630,1020
of the log| until all
|直到所有写入，

333
00:10:02,530 --> 00:10:04,090
0,150 150,810 990,1230 1230,1320 1320,1560
the writes,| that are not
|不是部分日志，

334
00:10:04,090 --> 00:10:04,990
0,150 150,210 210,330 330,600 600,900
part of the log,| all
|所有它们都被反映到

335
00:10:04,990 --> 00:10:05,840
0,120 120,390
of them

336
00:10:05,870 --> 00:10:08,060
0,390 390,600 600,990 1380,1920 1920,2190
{} have been reflected into|
|

337
00:10:08,060 --> 00:10:09,260
0,300 300,600
the {}
文件系统中的原位置。

338
00:10:10,940 --> 00:10:12,380
0,300 300,720 720,960 960,1380 1380,1440
{} actual home location in

339
00:10:12,380 --> 00:10:13,760
0,90 90,360 360,690 900,1140 1140,1380
the file system.| So the
|所以， xv6 中的事务，

340
00:10:13,760 --> 00:10:15,200
0,330 330,510 510,630 630,960 960,1440
deal {in,xv6 - -} that,|
|

341
00:10:15,200 --> 00:10:16,640
0,30 30,540 540,810 810,1080 1080,1440
{} what {end_op -} does
end_op 触发了大量工作，

342
00:10:16,640 --> 00:10:17,690
0,300 300,570 570,630 630,870 870,1050
actually triggers a whole lot

343
00:10:17,690 --> 00:10:19,580
0,60 60,450 600,1050 1050,1350 1440,1890
of work, first| and the
|而文件系统，正如我提到的那样，写入所有日志，

344
00:10:20,060 --> 00:10:21,500
0,480 480,840 840,930 930,1140 1200,1440
file system, you know as

345
00:10:21,500 --> 00:10:22,340
0,60 60,450 450,660 660,750 750,840
I mentioned writes all the

346
00:10:22,340 --> 00:10:23,210
0,300 300,360 360,600 600,780 780,870
logs,| the log writes the
|日志写入 header 日志，写入 header 块，

347
00:10:23,210 --> 00:10:24,520
0,210 210,690
header log,

348
00:10:24,640 --> 00:10:25,870
0,240 240,300 300,510 510,960 990,1230
writes the header block,| and
|然后文件系统将所有这些块写入它们的原始位置，

349
00:10:25,870 --> 00:10:29,230
0,690 930,1140 1140,1440 1440,2820 3000,3360
then the file system writes

350
00:10:29,230 --> 00:10:30,190
0,150 150,330 330,660 660,780 780,960
all these blocks their home

351
00:10:30,190 --> 00:10:31,480
0,510 510,630 630,720 720,1140 1140,1290
locations,| this is assuming no
|这是假设不发生崩溃的情况下。

352
00:10:31,480 --> 00:10:32,740
0,480 480,660 660,750 750,840 840,1260
crash which is the ordinary

353
00:10:32,740 --> 00:10:34,390
0,570 930,1140 1140,1320 1320,1410 1410,1650
case.| So then the file
|所以文件系统第二次写入时，

354
00:10:34,390 --> 00:10:35,380
0,480
system

355
00:10:35,380 --> 00:10:36,610
0,420 420,510 510,810 810,1170 1170,1230
write the second time| you
|所有块到它们在磁盘上的原位置，

356
00:10:36,610 --> 00:10:38,080
0,300 510,840 840,1020 1020,1380 1380,1470
know all these blocks to

357
00:10:38,080 --> 00:10:39,160
0,270 300,510 510,900 900,990 990,1080
the home locations on the

358
00:10:39,160 --> 00:10:41,110
0,240 240,390 390,720 720,1290 1680,1950
disk,| and then after {}
|然后在所有原位置都被更新之后，

359
00:10:41,110 --> 00:10:42,130
0,210 210,300 300,450 450,930 930,1020
all the home locations have

360
00:10:42,130 --> 00:10:43,690
0,90 90,570 630,1200 1200,1410 1410,1560
been updated,| only then does
|只有在那时，文件系统才继续，

361
00:10:43,690 --> 00:10:45,340
0,90 90,300 300,600 600,1050 1350,1650
the file system go,| {xv6
|xv6 文件系统从 header 块中擦除这些块编号，

362
00:10:45,340 --> 00:10:47,260
0,120 120,600 780,1260 1380,1650 1650,1920
- -} {} file system

363
00:10:47,290 --> 00:10:49,390
0,810 840,1200 1200,1500 1500,1860 1860,2100
erase these block numbers from

364
00:10:49,390 --> 00:10:50,860
0,150 150,420 420,840 840,930 930,1470
the header block,| to indicate
|表明我们已完成这个事务，

365
00:10:50,860 --> 00:10:52,150
0,300 540,810 810,1050 1050,1170 1170,1290
that we're done with this

366
00:10:52,150 --> 00:10:54,100
0,780 1020,1350 1350,1470 1470,1620 1620,1950
transaction| and we can reuse
|并且可以重用日志。

367
00:10:54,100 --> 00:10:55,480
0,120 120,570 780,930 930,1050 1050,1380
the log.| And it's critical
|删除块编号是至关重要的，

368
00:10:55,480 --> 00:10:57,130
0,90 90,900 990,1230 1230,1320 1320,1650
to erase {} the block

369
00:10:57,130 --> 00:10:59,200
0,540 600,1170 1170,1500 1500,1860 1860,2070
numbers,| before writing anything new
|在向日志中写入任何新内容之前，

370
00:10:59,200 --> 00:11:00,040
0,60 60,180 180,510 510,720 720,840
to the log,| because we
|因为我们不想处于这样的情况，

371
00:11:00,040 --> 00:11:00,790
0,270 270,480 480,540 540,630 630,750
wouldn't want to be in

372
00:11:00,790 --> 00:11:01,600
0,60 60,450 450,600 600,720 720,810
a position,| where there were
|在 header 中先前事务的一些块编号，

373
00:11:01,600 --> 00:11:02,950
0,270 420,780 780,1110 1110,1260 1260,1350
some block numbers from a

374
00:11:02,950 --> 00:11:04,960
0,630 630,1290 1290,1350 1350,1410 1410,2010
previous transaction in the header,|
|

375
00:11:05,110 --> 00:11:07,720
0,690 750,1950 2070,2250 2250,2340 2340,2610
but blocks from a new
但是块来自新的事务，

376
00:11:07,720 --> 00:11:09,200
0,990
transaction,|
|

377
00:11:09,260 --> 00:11:11,150
0,360 360,600 600,870 870,1410 1440,1890
presumably different block numbers sitting
可能是不同的块编号在日志中，

378
00:11:11,150 --> 00:11:12,560
0,90 90,150 150,690 1020,1290 1290,1410
in the log,| because then
|因为崩溃可能会应用这些内容

379
00:11:12,560 --> 00:11:14,240
0,60 60,570 570,900 930,1260 1260,1680
a crash would might apply

380
00:11:14,240 --> 00:11:17,930
0,300 300,1350 1650,2280 2430,2790 2820,3690
these contents| to the stale
|应用留在 header 块中过期的块编号。

381
00:11:18,020 --> 00:11:19,490
0,390 390,990 990,1230 1230,1410 1410,1470
block numbers left over in

382
00:11:19,490 --> 00:11:20,390
0,60 60,270 270,630 660,810 810,900
the header block.| So if
|所以你先删除 header 块，

383
00:11:20,390 --> 00:11:21,290
0,90 90,420 420,480 480,630 630,900
you erase the header block

384
00:11:21,290 --> 00:11:23,000
0,450 630,810 810,990 990,1320 1350,1710
first,| so this is freeing
|所以这是一条释放规则，

385
00:11:23,000 --> 00:11:24,230
0,180 180,300 300,690 750,1140 1140,1230
rule,| that says before we're
|规定在我们被允许从日志中删除事务之前，

386
00:11:24,230 --> 00:11:26,870
0,240 240,630 960,1770 1860,2100 2100,2640
allowed to erase a transaction

387
00:11:26,870 --> 00:11:28,130
0,90 90,180 180,810 840,1170 1170,1260
from the log,| we have
|我们必须将所有这些块写入文件系统。

388
00:11:28,130 --> 00:11:28,970
0,90 90,270 270,450 450,600 600,840
to write all these blocks

389
00:11:28,970 --> 00:11:30,040
0,300 330,690
{to,the,file} system.|
|

390
00:11:30,690 --> 00:11:31,920
0,630

391
00:11:31,920 --> 00:11:33,420
0,510 780,990 990,1080 1080,1230 1230,1500
Okay, so the net effect
好的，这样做的最终效果是

392
00:11:33,420 --> 00:11:34,710
0,60 60,300 300,450 450,570 570,1290
of this is| to make
|复杂的或需要多次写入的文件系统更新，

393
00:11:35,680 --> 00:11:36,940
0,270 270,540 540,780 780,1110 1110,1260
{} file system updates which

394
00:11:36,940 --> 00:11:38,680
0,120 120,240 240,810 810,1050 1380,1740
can be complicated and require

395
00:11:38,680 --> 00:11:40,030
0,240 240,870 900,1110 1110,1200 1200,1350
many writes| and the net
|实际效果是使每个系统调用是原子的，

396
00:11:40,030 --> 00:11:40,900
0,300 300,420 420,510 510,660 660,870
effect is to make each

397
00:11:40,900 --> 00:11:42,580
0,330 330,570 570,930 930,1050 1050,1680
system call essentially be atomic,|
|

398
00:11:43,060 --> 00:11:44,050
0,300 300,450 450,720 720,810 810,990
all its writes or none
对于崩溃来说，全部写入或没有写入。

399
00:11:44,050 --> 00:11:44,920
0,90 90,330 360,510 510,810 810,870
of them with respect to

400
00:11:44,920 --> 00:11:46,140
0,690
crashes.|
|

401
00:11:47,680 --> 00:11:49,840
0,300 300,780 990,1620
Okay, so {},
好的，日志方案通向 Linux 的桥梁是

402
00:11:51,080 --> 00:11:52,130
0,180 180,330 330,480 480,570 570,1050
so the sort of bridge

403
00:11:52,130 --> 00:11:54,560
0,150 150,1050 1140,1920 1920,2100 2100,2430
to {} Linux is logging

404
00:11:54,560 --> 00:11:56,330
0,570 570,840 840,900 900,1380 1380,1770
scheme,| is the question of
|是关于 xv6 日志有什么问题，

405
00:11:56,450 --> 00:11:57,830
0,540 540,780 780,870 870,1140 1140,1380
what's wrong with {xv6 -}

406
00:11:57,830 --> 00:11:59,330
0,390 390,720 720,930 930,1290 1290,1500
logging,| why doesn't Linux just
|为什么 Linux 不使用与 xv6 完全相同的方案。

407
00:11:59,330 --> 00:12:00,890
0,180 180,810 810,900 900,1200 1200,1560
use exactly the same scheme,

408
00:12:00,890 --> 00:12:02,090
0,60 60,270 270,390 390,720 720,1200
the {xv6 - -} does.|
|

409
00:12:02,720 --> 00:12:03,620
0,210 210,270 270,480 480,570 570,900
And the answer is basically
答案是它很慢，

410
00:12:03,620 --> 00:12:04,970
0,120 120,240 240,750 870,1080 1080,1350
that it's slow,| the {xv6
|xv6 方案相当慢，

411
00:12:04,970 --> 00:12:06,710
0,300 300,660 660,900 900,1260 1260,1740
-} scheme is quite slow,|
|

412
00:12:08,240 --> 00:12:09,470
0,300 300,660 660,900 900,1170 1170,1230
every system call,| before a
每个系统调用，|在 xv6 中，比如 write 或 create 这样的系统调用返回前，

413
00:12:09,470 --> 00:12:11,360
0,300 300,600 630,1050 1050,1590 1710,1890
system call {like,write} {or,create} can

414
00:12:11,360 --> 00:12:14,480
0,510 510,630 630,1470 1560,2130 2190,3120
return in xv6,| {} all
|我刚才说的这些东西都要完成，

415
00:12:14,480 --> 00:12:15,380
0,90 90,270 270,570 570,660 660,900
of this stuff I just

416
00:12:15,380 --> 00:12:16,850
0,270 270,540 540,750 750,840 840,1470
talked about has to complete,|
|

417
00:12:16,910 --> 00:12:19,520
0,390 420,1170 1170,1590 1710,2100 2100,2610
so before your file creation
所以，在你的文件创建系统调用返回用户空间之前，

418
00:12:19,520 --> 00:12:20,510
0,270 270,510 510,630 630,930 930,990
system call can return to

419
00:12:20,510 --> 00:12:22,800
0,240 240,750 960,1830
user space, {}|
|

420
00:12:22,990 --> 00:12:24,670
0,480 600,900 900,1020 1020,1470 1470,1680
the {it,has} to finish all
它必须完成 end_op 所做的所有工作，

421
00:12:24,670 --> 00:12:25,510
0,60 60,300 300,450 450,630 630,840
the stuff that {end_op -}

422
00:12:25,510 --> 00:12:26,740
0,300 300,450 450,750 750,1050 1050,1230
does,| which means write every
|这意味着将每个块写入日志，

423
00:12:26,740 --> 00:12:27,820
0,300 300,390 390,450 450,870 870,1080
block to the log,| write
|写入 header 块，

424
00:12:27,820 --> 00:12:29,530
0,120 120,420 420,960 1020,1470 1470,1710
the header block,| write all
|写入所有块到这里的位置，

425
00:12:29,530 --> 00:12:31,090
0,210 210,600 600,750 750,1290 1290,1560
those blocks {to,the} locations here,|
|

426
00:12:31,090 --> 00:12:32,200
0,150 150,480 480,570 570,810 810,1110
and erase the header block,|
并删除 header 块，|

427
00:12:32,200 --> 00:12:33,370
0,90 90,270 270,420 420,570 570,1170
and then you can return.|
然后就可以返回了。|

428
00:12:33,400 --> 00:12:35,360
0,330 330,630 630,810 810,1440
And during that time,|
在此期间，|

429
00:12:35,360 --> 00:12:37,040
0,690 750,1230 1230,1380 1380,1530 1530,1680
{} not only does each
不仅每个系统调用需要很长时间，

430
00:12:37,040 --> 00:12:38,000
0,300 300,480 480,660 660,720 720,960
system call take a long

431
00:12:38,000 --> 00:12:39,650
0,330 330,750 870,1320 1320,1530 1530,1650
time,| but nothing else can
|而且文件系统中不会发生其他事情，

432
00:12:39,650 --> 00:12:41,210
0,390 390,480 480,600 600,930 930,1560
happen in the file system,|
|

433
00:12:41,240 --> 00:12:43,580
0,930 960,1470 1470,1830 1830,2130 2130,2340
while any system call is
当所有系统调用提交，

434
00:12:43,580 --> 00:12:45,890
0,750 1080,1530 1650,1860 1860,2010 2010,2310
committing| {} and then writing
|将其块写入其原位置。

435
00:12:45,890 --> 00:12:46,820
0,150 150,540 540,600 600,750 750,930
its blocks to their home

436
00:12:46,820 --> 00:12:48,290
0,480 480,630 630,810 810,1260 1260,1470
location.| So the system calls
|所以系统调用一次只发生一个，

437
00:12:48,290 --> 00:12:49,280
0,210 210,420 420,840 840,960 960,990
really occur one at a

438
00:12:49,280 --> 00:12:51,560
0,540 660,1050 1140,1350 1350,1650 1650,2280
time| and each system call
|并且每个系统调用都需要许多磁盘写入。

439
00:12:51,770 --> 00:12:54,060
0,390 390,840 840,1230 1230,1830
requires many disk writes.|
|

440
00:12:54,500 --> 00:12:57,110
0,390 600,840 840,1080 1260,2220 2220,2610
{} And the technical term
每个系统调用必须

441
00:12:57,110 --> 00:12:58,370
0,180 180,450 450,840 840,1080 1080,1260
for every system call has

442
00:12:58,370 --> 00:12:59,390
0,150 150,510 510,690 690,930 930,1020
to| wait for all of
|等待其所有磁盘写入完成的术语称为同步。

443
00:12:59,390 --> 00:13:01,130
0,210 210,1050 1050,1170 1170,1620 1620,1740
its {disk,writes} to complete is

444
00:13:01,130 --> 00:13:02,840
0,240 240,1230
called synchronous.|
|

445
00:13:02,840 --> 00:13:04,600
0,570 720,1260
Um, this,
嗯，这个，可能拼写不一样。

446
00:13:05,800 --> 00:13:07,140
0,810
{}

447
00:13:09,470 --> 00:13:10,940
0,420 420,750 750,1080 1080,1230 1230,1470
probably spelled differently from that.|
|

448
00:13:11,210 --> 00:13:12,470
0,390 390,540 540,660 660,990 990,1260
Anyway, {xv6 - -} system
无论如何，对于磁盘来说， xv6 系统调用是同步的。

449
00:13:12,470 --> 00:13:13,670
0,210 210,270 270,780 780,900 900,1200
call are synchronous with respect

450
00:13:13,670 --> 00:13:14,600
0,60 60,510 510,630 630,750 750,930
to disk.| So they're very
|所以它们非常慢，

451
00:13:14,600 --> 00:13:16,070
0,180 180,540 750,1050 1050,1140 1140,1470
very slow,| and they were
|对于机械磁盘更是慢的可怕，

452
00:13:16,250 --> 00:13:18,650
0,750 750,1320 1440,1650 1650,1920 1920,2400
horribly slow {} with mechanical

453
00:13:18,650 --> 00:13:20,570
0,240 240,570 570,870 1080,1410 1410,1920
hard drives,| because each write
|因为每一次写入都需要 10 毫秒。

454
00:13:20,990 --> 00:13:23,090
0,180 180,690 690,900 900,1110 1110,2100
{you,know} basically take ten milliseconds.|
|

455
00:13:23,270 --> 00:13:24,260
0,120 120,300 300,450 450,690 690,990
We're talking about many writes
我们谈论的是许多写入的系统调用，

456
00:13:24,260 --> 00:13:26,210
0,120 120,420 420,720 720,1020 1620,1950
for system calls,| so {xv6
|所以， xv6 在一秒钟内只能执行几个文件系统修改系统调用。

457
00:13:26,210 --> 00:13:27,650
0,240 240,420 420,660 660,1020 1140,1440
-} could only do a

458
00:13:27,650 --> 00:13:29,960
0,720 870,1260 1260,1560 1560,2010 2010,2310
few file system modifying system

459
00:13:29,960 --> 00:13:31,120
0,270 270,330 330,360 360,720
calls for a second.|
|

460
00:13:31,240 --> 00:13:32,050
0,150 150,210 210,450 450,600 600,810
And I wonder if we
我想如果我们运行 xv6 固态硬盘速度更快，

461
00:13:32,050 --> 00:13:34,660
0,870 1230,1560 1560,1830 1830,2310 2310,2610
ran {xv6 -} {solid,state} drive

462
00:13:34,660 --> 00:13:35,890
0,60 60,180 180,600 600,750 750,1230
to be faster,| but still
|但仍然没有达到应有的效率。

463
00:13:36,190 --> 00:13:37,540
0,330 330,780 780,900 900,1260 1260,1350
not nearly as efficient as

464
00:13:37,540 --> 00:13:38,560
0,90 90,270 270,510
it could be.|
|

465
00:13:39,260 --> 00:13:41,330
0,330 720,1320 1320,1500 1500,1920 1920,2070
{} Another more detail thing
另一个需要注意的更详细的事情是，

466
00:13:41,330 --> 00:13:42,200
0,90 90,360 360,600 600,780 780,870
to notice about this is|
|

467
00:13:42,200 --> 00:13:43,220
0,150 150,390 390,630 630,780 780,1020
that every block is written
每个块在 xv6 方案中写入两次，

468
00:13:43,220 --> 00:13:44,300
0,600 600,660 660,750 750,960 960,1080
twice in the {xv6 -

469
00:13:44,300 --> 00:13:46,370
0,240 240,690 1410,1620 1620,1830 1830,2070
-} scheme,| it's written once
|它第一次写入日志，

470
00:13:46,370 --> 00:13:47,330
0,90 90,180 180,750 750,840 840,960
to the log| and then
|然后第二次写入磁盘。

471
00:13:47,330 --> 00:13:48,800
0,60 60,420 420,840 900,1260 1350,1470
at second time to the

472
00:13:48,800 --> 00:13:49,760
0,510
disk.|
|

473
00:13:49,790 --> 00:13:50,600
0,150 150,270 270,420 420,510 510,810
And so this is also
所以这也是，

474
00:13:50,600 --> 00:13:51,820
0,390 390,540
something that,|
|

475
00:13:51,820 --> 00:13:53,020
0,360 360,510 510,810 810,930 930,1200
there's good reasons for that,|
有好的理由，|

476
00:13:53,020 --> 00:13:55,510
0,270 420,1020 1440,1740 1770,2250 2250,2490
but {} it's something that
但是 ext3 可以部分修复这个问题。

477
00:13:55,750 --> 00:13:58,120
0,420 420,840 870,1290 1290,1890
{ext3 -} partially fixes.|
|

478
00:13:59,730 --> 00:14:01,800
0,300 300,750 1080,1620 1620,1710 1710,2070
Okay, so on the Linux
好的，那么在 Linux 上，

479
00:14:01,800 --> 00:14:03,720
0,450 480,900 900,1140 1140,1500 1500,1920
is,| under the today's reading
|根据今天的论文，它是，

480
00:14:03,720 --> 00:14:05,820
0,120 120,570 570,1170 1650,1950 1950,2100
and it's {} sort of,|
|

481
00:14:06,420 --> 00:14:07,350
0,150 150,390 390,450 450,660 660,930
I'm going to talk about
我要谈谈这个 ext3 文件系统，

482
00:14:07,350 --> 00:14:08,360
0,360
the

483
00:14:09,560 --> 00:14:11,720
0,690 720,1170 1200,1650 1650,1920 1920,2160
this {} {ext3 -} file

484
00:14:11,720 --> 00:14:13,670
0,330 330,510 510,720 750,1590 1650,1950
system,| which is what the
|今天的论文经过几年的变化，

485
00:14:14,060 --> 00:14:15,890
0,600 600,990 990,1230 1230,1560 1560,1830
today's reading had turned into

486
00:14:15,890 --> 00:14:17,060
0,120 120,300 300,630 630,900 900,1170
a few years later| after
|在更多的发展之后，

487
00:14:17,060 --> 00:14:18,600
0,60 60,210 210,360 360,1050
a bit more development,|
|

488
00:14:19,020 --> 00:14:21,000
0,360 360,720 750,960 960,1380 1380,1980
{} and was widely used.|
并得到广泛应用。|

489
00:14:22,520 --> 00:14:25,080
0,450 450,1080 1260,1950
Okay, so {}
好的，所以 ext3 ，

490
00:14:25,950 --> 00:14:27,720
0,480 480,1050
{ext3 -},|
|

491
00:14:28,100 --> 00:14:29,480
0,780

492
00:14:29,660 --> 00:14:32,750
0,240 240,630 630,690 690,2010 2430,3090
it's actually a modification {}
它是对之前的无日志文件系统的修改。

493
00:14:32,750 --> 00:14:34,640
0,630 630,930 930,1110 1110,1440 1440,1890
previous {logless -} file system.|
|

494
00:14:34,640 --> 00:14:36,760
0,150 150,240 240,480 480,930
So they really did
所以，他们真的利用现有存储系统，

495
00:14:36,850 --> 00:14:38,590
0,210 210,420 420,870 870,1170 1230,1740
play this game of taking

496
00:14:38,590 --> 00:14:39,880
0,420 420,780 780,1050 1050,1140 1140,1290
existing storage system| and sort
|并在它上面加上日志，

497
00:14:39,880 --> 00:14:41,350
0,60 60,660 660,1050 1050,1200 1200,1470
of layering logging on top

498
00:14:41,350 --> 00:14:42,070
0,150 150,270 270,420 420,510 510,720
of it,| in a way
|使底层 ext2 文件系统几乎没有修改，

499
00:14:42,070 --> 00:14:45,460
0,240 510,1260 1260,1710 1980,2790 2790,3390
that left the underlying {ext2

500
00:14:45,460 --> 00:14:47,860
0,450 450,840 840,1380 1500,1950 1950,2400
-} file system {} almost

501
00:14:47,860 --> 00:14:50,800
0,750 750,1230 1350,1740 1740,2250 2460,2940
unmodified,| although not quite. {}|
|虽然不是完全没有。|

502
00:14:50,950 --> 00:14:51,760
0,270 270,360 360,420 420,690 690,810
So in a sense, the
所以，从某种意义上说，日志是一种非常容易，

503
00:14:51,760 --> 00:14:52,720
0,330 330,450 450,450 450,780 780,960
logging was a very kind

504
00:14:52,720 --> 00:14:53,860
0,210
of

505
00:14:54,160 --> 00:14:56,650
0,810 1080,1200 1200,1410 1440,1860 1890,2490
easy,| you know {at,least,in} principle,
|至少，对它们来说升级很容易。

506
00:14:56,650 --> 00:14:58,280
0,270 270,690 690,870 870,1050
easy upgrade for them.|
|

507
00:14:58,490 --> 00:15:02,540
0,540 1350,1770 1770,2370 2400,3330 3390,4050
{} {Ex3 -} keeps {}
ex3 保持着类似于 xv6 的数据结构，

508
00:15:02,810 --> 00:15:04,460
0,390 390,870 870,990 990,1110 1110,1650
data structures that are similar

509
00:15:04,460 --> 00:15:05,740
0,300 300,750
to {}

510
00:15:06,750 --> 00:15:08,260
0,870
{}

511
00:15:08,860 --> 00:15:11,050
0,420 420,810 810,1380 1380,1530 1530,2190
{} {xv6's -},| in memory,
|在内存中，有一个块缓存，一个回写缓存，

512
00:15:11,170 --> 00:15:13,400
0,390 390,600 600,900 900,1680
there's a block cache,

513
00:15:13,720 --> 00:15:16,260
0,510 630,1020 1020,1290 1290,2070
a write back cache,|
|

514
00:15:17,690 --> 00:15:19,020
0,780

515
00:15:19,450 --> 00:15:20,260
0,240 240,270 270,450 450,510 510,810
there's a bunch of cache
这里有一些缓存块，

516
00:15:20,260 --> 00:15:21,560
0,840
blocks,|
|

517
00:15:21,920 --> 00:15:22,970
0,360 360,420 420,540 540,630 630,1050
some of them are clean,|
其中一些是干净的，|

518
00:15:22,970 --> 00:15:23,540
0,60 60,150 150,390 390,480 480,570
in the sense that they
因为它们没有被修改，

519
00:15:23,540 --> 00:15:24,770
0,150 150,270 270,750 750,1020 1020,1230
haven't been modified,| since you
|因为它们与磁盘上的内容完全相同，

520
00:15:24,770 --> 00:15:25,730
0,150 150,600 600,660 660,870 870,960
know identical to what's on

521
00:15:25,730 --> 00:15:26,360
0,60 60,270 270,390 390,480 480,630
the disk,| some of them
|有一些是脏的，

522
00:15:26,360 --> 00:15:27,830
0,510 510,630 630,1050 1050,1260 1260,1470
dirty,| {in,the} sense that they've
|它们被写入，

523
00:15:27,830 --> 00:15:29,270
0,150 150,450 450,810 1050,1350 1350,1440
been written to,| since they
|自从从磁盘读取它们，

524
00:15:29,270 --> 00:15:30,320
0,120 120,300 300,420 420,510 510,1050
were read from the disk|
|

525
00:15:30,560 --> 00:15:31,400
0,420 420,540 540,600 600,690 690,840
and some of them were
有一些人是固定的，

526
00:15:31,400 --> 00:15:32,600
0,540 540,630 630,810 810,960 960,1200
pinned| and that they're not
|因为它们不允许被写回磁盘，

527
00:15:32,600 --> 00:15:33,800
0,390 390,480 480,780 780,960 960,1200
allowed to be written back

528
00:15:33,800 --> 00:15:35,390
0,120 120,720 870,1470 1470,1530 1530,1590
to disk,| because of the
|因为回写规则，

529
00:15:35,390 --> 00:15:36,890
0,210 210,510 510,810 1050,1260 1260,1500
write back rule,| I mean
|我是说因为释放规则，预写规则。

530
00:15:36,890 --> 00:15:37,970
0,240 240,300 300,360 360,780 780,1080
because of the freeing rule,

531
00:15:38,180 --> 00:15:40,980
0,180 180,600 600,960 1560,2340
the write-ahead rule. {}|
|

532
00:15:41,130 --> 00:15:44,100
0,540 540,900 900,1380 1470,1860 2340,2970
Ext2 also cause {} maintain
ext2 还维护一些事务信息，

533
00:15:44,100 --> 00:15:47,360
0,600 810,1920 1920,2700
some transaction information,|
|

534
00:15:49,840 --> 00:15:52,750
0,540 1470,1680 1680,1830 1830,2340 2340,2910
{} you can maintain information
你可以维护多个事务的信息，

535
00:15:52,750 --> 00:15:55,210
0,330 330,840 870,1500 1500,2310 2310,2460
actually about multiple transactions| that
|它们在不同运行阶段并行。

536
00:15:55,210 --> 00:15:57,550
0,240 330,1020 1020,1290 1290,1740 1740,2340
are concurrently in different stages

537
00:15:57,550 --> 00:15:59,560
0,90 90,870 1020,1470 1650,1890 1890,2010
of execution.| So, {} there
|所以，可能有许多不同的事务，

538
00:15:59,560 --> 00:16:00,220
0,150 150,210 210,270 270,570 570,660
might be a number of

539
00:16:00,220 --> 00:16:03,100
0,540 660,1740 1740,1950 1950,2340 2400,2880
different transactions,| that the {ext3
|ext3 系统跟踪着，

540
00:16:03,100 --> 00:16:04,780
0,300 300,750 750,1320
-} system is

541
00:16:04,810 --> 00:16:06,940
0,330 330,630 630,930 1440,1650 1650,2130
keeping track of,| each one,
|每个事务都有一个序列号，

542
00:16:06,970 --> 00:16:08,380
0,210 210,750 750,900 900,960 960,1410
each transaction has a sequence

543
00:16:08,380 --> 00:16:09,460
0,480
number,|
|

544
00:16:10,530 --> 00:16:12,280
0,660

545
00:16:12,460 --> 00:16:14,830
0,630 900,1290 1290,1440 1440,1860 1860,2370
a set of block numbers
事务系统的一些块编号，

546
00:16:14,830 --> 00:16:16,780
0,210 210,570 690,1260 1260,1590 1590,1950
that the transaction system is|
|

547
00:16:16,810 --> 00:16:19,030
0,390 390,690 690,810 810,1530 1530,2220
logging system is remembering are
日志系统记住事务修改的块，

548
00:16:19,540 --> 00:16:21,880
0,600 600,1230 1230,1350 1350,1560 1560,2340
blocks modified by that transaction,|
|

549
00:16:22,210 --> 00:16:23,440
0,210 210,420 420,660
so these are
所以这是一组块编号。

550
00:16:23,440 --> 00:16:24,560
0,600
{}

551
00:16:25,010 --> 00:16:27,200
0,480 480,540 540,870 870,1590
set of block numbers.|
|

552
00:16:27,400 --> 00:16:28,630
0,150 150,300 300,510 510,960 960,1230
And this really refers to
这是缓存块，

553
00:16:28,750 --> 00:16:31,210
0,420 420,1050 1050,1410 1620,1830 1830,2460
cache blocks,| because any modifications
|因为任何修改至少开始只发生在缓存中。

554
00:16:31,210 --> 00:16:32,230
0,90 90,270 270,660 660,750 750,1020
at least initially {you,know} happen

555
00:16:32,230 --> 00:16:34,240
0,240 240,360 360,420 420,1050 1590,2010
only in the cache.| And
|然后是一组被称为 handle 的东西，

556
00:16:34,360 --> 00:16:35,110
0,300 300,360 360,540 540,600 600,750
then a set of what

557
00:16:35,110 --> 00:16:36,720
0,60 60,270 270,1170
are called handles,|
|

558
00:16:39,970 --> 00:16:42,340
0,390 390,840 870,1590 1590,1950 1950,2370
which are information about system
它们是有关仍在并发执行的系统调用的信息，

559
00:16:42,340 --> 00:16:43,540
0,300 300,420 420,480 480,720 720,1200
calls that are still concurrently

560
00:16:43,540 --> 00:16:45,610
0,840 930,1500 1530,1770 1770,2010 2010,2070
executing| and as part of
|并且作为事务的一部分，

561
00:16:45,610 --> 00:16:47,590
0,120 120,930 930,1350 1380,1830 1830,1980
this transaction| and reading and
|以及读取和写入缓存块。

562
00:16:47,590 --> 00:16:49,920
0,510 540,1080 1080,1890
writing cache blocks.|
|

563
00:16:49,920 --> 00:16:50,880
0,390

564
00:16:51,000 --> 00:16:52,660
0,210 210,300 300,420 420,1110
And on the disk,
在磁盘上，

565
00:16:56,120 --> 00:16:57,230
0,150 150,210 210,720 720,960 960,1110
on the disk,| just like
|就像 xv6 一样，有通常的文件系统树，

566
00:16:57,230 --> 00:16:59,180
0,960 1050,1320 1320,1410 1410,1680 1680,1950
xv6, there's the usual file

567
00:16:59,180 --> 00:17:00,660
0,300 300,960
system tree,|
|

568
00:17:00,720 --> 00:17:02,760
0,300 300,810 810,1410 1410,1920 1920,2040
{inode -} directory blocks and
索引节点目录块和文件等等，

569
00:17:02,760 --> 00:17:05,730
0,450 450,540 540,1050 1290,2400 2700,2970
files and whatnot,| and {}
|还有一些位图块

570
00:17:05,730 --> 00:17:08,670
0,300 300,630 630,930 930,1770 1920,2940
there's {bitmap -} blocks| indicating
|表示每个数据块是否已分配，

571
00:17:09,480 --> 00:17:10,740
0,150 150,240 240,690 690,870 870,1260
you know whether each block

572
00:17:10,740 --> 00:17:12,450
0,480 630,870 870,1080 1080,1200 1200,1710
is data block is allocated

573
00:17:12,450 --> 00:17:14,250
0,60 60,600 1080,1470 1470,1590 1590,1800
or free| and so these
|这些就是我所说的文件系统数据块的原位置，

574
00:17:14,250 --> 00:17:15,060
0,60 60,210 210,420 420,540 540,810
are what I'll be calling

575
00:17:15,060 --> 00:17:16,500
0,60 60,300 300,1080 1080,1170 1170,1440
the home locations of file

576
00:17:16,500 --> 00:17:18,540
0,270 270,690 1080,1590 1590,1860 1860,2040
system blocks| and then on
|然后在磁盘的指定部分，是日志。

577
00:17:18,540 --> 00:17:19,740
0,120 120,300 300,450 450,1020 1020,1200
a sort of designated part

578
00:17:19,740 --> 00:17:20,960
0,90 90,180 180,780
of the disk,

579
00:17:21,110 --> 00:17:22,240
0,600
{}

580
00:17:22,340 --> 00:17:23,780
0,330 330,450 450,930
there's the log.|
|

581
00:17:25,510 --> 00:17:26,500
0,240 240,420 420,690 690,870 870,990
And so, so far this
目前为止，这与 xv6 非常相似，

582
00:17:26,500 --> 00:17:27,280
0,120 120,330 330,600 600,660 660,780
is pretty similar to {xv6

583
00:17:27,280 --> 00:17:28,900
0,120 120,480 510,750 750,1140 1140,1620
- -},| the main difference
|主要区别在于 ext3 能够

584
00:17:28,900 --> 00:17:30,800
0,270 270,630 720,1350
is the {}

585
00:17:31,080 --> 00:17:32,220
0,420 420,630 630,690 690,1080 1080,1140
{ext3's - -} ability| to
|同时跟踪多个事务

586
00:17:32,220 --> 00:17:34,440
0,180 180,450 450,540 540,1260 1740,2220
keep track of multiple {}

587
00:17:34,950 --> 00:17:36,270
0,660 660,750 750,810 810,1020 1020,1320
transactions at the same time|
|

588
00:17:36,270 --> 00:17:38,430
0,240 390,810 810,1470 1470,1830 1860,2160
in different stages of their
在其执行的不同阶段。

589
00:17:38,430 --> 00:17:39,540
0,630
execution.|
|

590
00:17:42,290 --> 00:17:43,010
0,300 300,390 390,540 540,600 600,720
Now, I want to look
现在我想更仔细地看看 ext3 中的日志，

591
00:17:43,010 --> 00:17:46,310
0,120 120,690 690,1470 1920,2220 2220,3300
more closely at what's inside

592
00:17:46,340 --> 00:17:47,960
0,240 240,720 720,990 1020,1440 1440,1620
the log in {ext3 -},|
|

593
00:17:47,960 --> 00:17:49,370
0,90 90,150 150,360 360,810 810,1410
is a bit different from
与 xv6 日志略有不同。

594
00:17:49,820 --> 00:17:50,990
0,180 180,480 480,660 660,870 870,1170
{} what's in the {xv6

595
00:17:50,990 --> 00:17:52,320
0,300 300,780
-} log.|
|

596
00:17:58,730 --> 00:18:00,860
0,420 420,630 630,930 930,1530
There's a log format,|
有一种日志格式，|

597
00:18:04,010 --> 00:18:06,050
0,510 1260,1530 1530,1590 1590,1980 1980,2040
{} at the beginning of
在日志的开头，有一些东西叫做超级块，

598
00:18:06,050 --> 00:18:06,890
0,60 60,300 300,450 450,660 660,840
the log, there's something called

599
00:18:06,890 --> 00:18:08,520
0,60 60,420 420,1110
the super block,|
|

600
00:18:11,080 --> 00:18:12,760
0,450 450,660 660,720 720,1110 1110,1680
{} and the super block,
这是日志超级块，

601
00:18:13,530 --> 00:18:14,550
0,180 180,240 240,330 330,720 720,1020
this is the log super

602
00:18:14,550 --> 00:18:15,990
0,270 270,630 630,840 840,1080 1110,1440
block| different from the file
|与文件系统的超级块不同。

603
00:18:15,990 --> 00:18:17,760
0,300 300,600 600,1020
system super block.|
|

604
00:18:18,290 --> 00:18:19,820
0,270 270,540 540,750 750,990 990,1530
The log super block contains
日志超级块包含日志中第一个有效事务的偏移量和序列号，

605
00:18:19,820 --> 00:18:21,350
0,150 150,630 630,750 750,1200 1200,1530
the offset and sequence number

606
00:18:21,350 --> 00:18:25,130
0,240 240,570 600,1380 1770,2790 2790,3780
of the {} first valid

607
00:18:25,520 --> 00:18:27,200
0,720 720,810 810,900 900,1500 1530,1680
transaction in the log,| so
|所以会有一个偏移量，

608
00:18:27,200 --> 00:18:28,340
0,120 120,270 270,360 360,450 450,1140
it's gonna have an offset,|
|

609
00:18:28,990 --> 00:18:30,850
0,360 360,360 810,1140 1140,1560 1560,1860
just a byte number, block
只是在日志中的一个字节数，块编号，

610
00:18:30,850 --> 00:18:31,900
0,240 240,360 360,420 420,930 930,1050
number in the log| and
|然后是这个序列号，

611
00:18:31,900 --> 00:18:33,550
0,150 150,510 510,810 840,1140 1140,1650
then this lo- {} sequence

612
00:18:33,550 --> 00:18:34,510
0,180 180,480 480,480 480,810 810,960
number,| remember I said that
|记得我说过每个事务都有自己的序列号，

613
00:18:34,510 --> 00:18:36,340
0,420 690,1410 1410,1560 1560,1710 1710,1830
every transaction has its own

614
00:18:36,340 --> 00:18:38,230
0,390 390,720 900,1350 1350,1680 1710,1890
sequence number,| and then the
|然后剩下的日志，

615
00:18:38,230 --> 00:18:39,040
0,210 210,270 270,360 360,720 720,810
rest of the log,| the
|日志只是磁盘上已知大小的一串连续数据块。

616
00:18:39,040 --> 00:18:39,760
0,180 180,240 240,420 420,450 450,720
log is just a bunch

617
00:18:39,760 --> 00:18:41,440
0,270 300,1170
of sequential

618
00:18:41,440 --> 00:18:42,760
0,390 390,540 540,870 870,990 990,1320
blocks on disks of {a,known}

619
00:18:42,760 --> 00:18:44,060
0,810
size.|
|

620
00:18:46,150 --> 00:18:47,560
0,420 420,1080 1080,1140 1140,1350 1350,1410
Every transaction, the rest of
每个事务，剩下的日志包含事务，

621
00:18:47,560 --> 00:18:49,180
0,120 120,360 360,840 840,900 900,1620
the log consists of transactions,|
|

622
00:18:49,210 --> 00:18:51,220
0,240 240,930 930,1500 1500,1800 1800,2010
each transaction consists of a
每个事务包含一个描述块，

623
00:18:51,220 --> 00:18:53,220
0,630 630,1200
descriptor block,|
|

624
00:18:53,980 --> 00:18:55,260
0,720

625
00:18:55,510 --> 00:18:57,900
0,270 270,690 690,1080 1080,1860
which contains block numbers
包含块编号，

626
00:18:58,150 --> 00:19:00,020
0,630 630,870 870,1290
{just,as} in the,|
|

627
00:19:00,300 --> 00:19:01,560
0,480 480,660 660,750 750,960 960,1260
much like the header block
非常像 xv6 中的 header 块。

628
00:19:01,560 --> 00:19:02,780
0,120 120,210 210,600
in the {}

629
00:19:03,520 --> 00:19:05,230
0,390 390,660 660,780 780,1200 1560,1710
{xv6 -}.| And then the
|然后，

630
00:19:05,230 --> 00:19:06,790
0,420 420,600 600,1350 1350,1500 1500,1560
set of,| for each of
|对于每个块编号，

631
00:19:06,790 --> 00:19:08,320
0,150 150,420 420,840 840,960 960,1530
these block numbers,| the actual
|实际更新的内容块对应于块编号，

632
00:19:08,350 --> 00:19:11,580
0,540 540,1230 1560,2730
updated content block

633
00:19:11,720 --> 00:19:13,370
0,390 420,870 870,1020 1020,1320 1320,1650
{} corresponding that block number|
|

634
00:19:13,370 --> 00:19:14,600
0,330 330,480 480,870 870,1200 1200,1230
and then finally for {}
最后，对于完成并提交的事务，

635
00:19:14,600 --> 00:19:16,520
0,630 630,780 780,1050 1050,1740 1740,1920
transaction that's actually finished and

636
00:19:16,520 --> 00:19:19,250
0,660 1080,1620 1650,1980 1980,2250 2250,2730
committed,| {} {there'll,be,a} commit block,|
|这里会有一个提交块，|

637
00:19:22,590 --> 00:19:23,730
0,270 270,360 360,360 360,840 840,1140
this is a separate block
这是日志中一个单独的块。

638
00:19:23,730 --> 00:19:25,700
0,90 90,180 180,840 900,1680
in the log. {}|
|

639
00:19:26,380 --> 00:19:27,550
0,480 480,810 810,930 930,1050 1050,1170
And because there can be
因为可以有多个事务日志，

640
00:19:27,550 --> 00:19:29,980
0,270 270,390 390,1050 1140,1740 1860,2430
more than one {} transaction

641
00:19:29,980 --> 00:19:31,990
0,450 450,1050 1200,1620 1620,1860 1860,2010
log,| that commit block may
|那个提交块后面可能是下一个描述块，

642
00:19:31,990 --> 00:19:33,880
0,120 120,630 630,1140 1260,1740 1740,1890
be followed by {} the

643
00:19:33,880 --> 00:19:36,880
0,300 300,1170 1170,1740 1740,2430 2700,3000
next transaction's descriptor block| and
|然后是一些数据块，

644
00:19:36,880 --> 00:19:38,200
0,240 240,420 420,720 720,1230 1230,1320
then some data blocks| and
|然后也许下一个事务的提交块。

645
00:19:38,200 --> 00:19:40,840
0,150 150,660 960,1530 1590,1980 1980,2640
then maybe the next transmission,

646
00:19:40,990 --> 00:19:43,500
0,570 570,1320 1320,1620 1620,2160
{transaction's -} commit block.|
|

647
00:19:44,610 --> 00:19:46,440
0,210 210,270 270,450 450,1110 1500,1830
So we have multiple,| log
所以我们有多个，|日志文件可能相当长，

648
00:19:46,440 --> 00:19:47,250
0,120 120,210 210,300 300,540 540,810
file can be quite long|
|

649
00:19:47,250 --> 00:19:49,680
0,210 210,780 930,1620 1620,2310 2310,2430
and contain many transactions in
并包含多个事务。

650
00:19:49,680 --> 00:19:50,380
0,90
it.|
|

651
00:19:52,600 --> 00:19:53,800
0,420 450,630 630,930 930,1110 1110,1200
{} So this we can
所以我们可以可以，

652
00:19:53,800 --> 00:19:55,060
0,210 210,270 270,630 660,1110 1110,1260
think of this| offset and
|它们之间的偏移量和序列号，

653
00:19:55,060 --> 00:19:56,980
0,390 390,720 720,1110 1110,1590 1590,1920
sequence numbers basically between them,|
|

654
00:19:57,100 --> 00:19:59,520
0,510 600,1230 1230,1890
{} pointing to
指向最开始的，

655
00:19:59,520 --> 00:20:00,810
0,60 60,150 150,420 420,600 600,1290
at the very, the first|
|

656
00:20:00,960 --> 00:20:03,480
0,390 420,1080 1080,1380 1380,1650 1710,2520
the beginning of the earliest
编号最小的有效事务日志的开头。

657
00:20:03,570 --> 00:20:06,750
0,480 480,960 1200,2040 2040,2640 2640,3180
lowest numbered valid transaction log.|
|

658
00:20:08,200 --> 00:20:10,340
0,1080 1080,1560

659
00:20:10,950 --> 00:20:13,050
0,210 210,600 600,1290 1290,1710 1710,2100
A little detail here that
这里的一些小细节会很重要，

660
00:20:13,080 --> 00:20:15,180
0,270 270,630 630,1320 1350,1710 1710,2100
will become important {a,little} while,|
|

661
00:20:15,180 --> 00:20:17,130
0,120 120,360 480,1350 1350,1500 1500,1950
is that these the descriptor
这些是描述符块和提交块，

662
00:20:17,130 --> 00:20:19,230
0,570 570,810 810,900 900,1230 1230,2100
blocks and the commit blocks,|
|

663
00:20:20,760 --> 00:20:21,660
0,390 390,600 600,660 660,750 750,900
in order to be able
为了能够将它们与数据块区分，

664
00:20:21,660 --> 00:20:22,920
0,180 180,420 420,900 900,1050 1050,1260
to help distinguish them from

665
00:20:22,920 --> 00:20:24,840
0,270 300,540 540,780 780,1590 1680,1920
data, from data blocks,| if
|如果它们在崩溃和恢复后扫描日志时，

666
00:20:24,840 --> 00:20:26,610
0,300 300,510 660,1230 1230,1560 1560,1770
when they're scanning log after

667
00:20:26,610 --> 00:20:27,870
0,30 30,330 330,420 420,960 1050,1260
a crash and recovery,| the
|提交块的描述以魔数开始，

668
00:20:27,870 --> 00:20:29,100
0,360 360,420 420,480 480,750 750,1230
description of the commit blocks

669
00:20:29,160 --> 00:20:31,830
0,660 660,1110 1140,1500 1650,2340 2340,2670
start with a magic number,|
|

670
00:20:31,830 --> 00:20:33,140
0,180 180,360 360,780
which is just
它是一个 32 位数，

671
00:20:33,340 --> 00:20:35,110
0,300 300,840 840,1020 1020,1470 1470,1770
some 32 bit number,| that
|在数据中不太可能发生，

672
00:20:35,110 --> 00:20:36,200
0,510
{}

673
00:20:37,350 --> 00:20:39,720
0,270 270,390 390,1260 1320,1890 1980,2370
{} is unlikely to occur

674
00:20:39,720 --> 00:20:40,860
0,90 90,510
in data,|
|

675
00:20:41,350 --> 00:20:42,700
0,360 360,630 630,990 990,1080 1080,1350
and that helps the log
帮助日志软件区分描述符和提交块与数据块。

676
00:20:42,700 --> 00:20:45,620
0,720 1080,1410 1410,2250
software {} distinguish

677
00:20:46,070 --> 00:20:47,450
0,300 300,750 750,840 840,1080 1080,1380
{} descriptor and commit blocks

678
00:20:47,450 --> 00:20:48,980
0,150 150,360 360,870
from data blocks.|
|

679
00:20:52,460 --> 00:20:54,110
0,420 450,1080 1170,1380 1380,1560 1560,1650
Okay, {} with this in
好的，记住这个结构，

680
00:20:54,110 --> 00:20:55,310
0,510 510,630 630,750 750,1140 1140,1200
mind, with this structure in

681
00:20:55,310 --> 00:20:56,150
0,360 360,420 420,540 540,600 600,840
mind,| I'm going to talk
|我要谈谈 ext3 获得良好性能的高级方法。

682
00:20:56,150 --> 00:20:58,730
0,270 270,600 1230,1860 1860,1980 1980,2580
about the high-level the ways,

683
00:20:58,730 --> 00:21:00,440
0,510 570,1050 1050,1290 1290,1530 1530,1710
that {ext3 -} gets good

684
00:21:00,440 --> 00:21:01,730
0,510 510,600 600,750 750,960 960,1290
performance.| And there's really three
|有三个主要原因。

685
00:21:01,730 --> 00:21:05,270
0,930 1050,1470 1470,1860 2220,3210 3360,3540
main.| But, a question,| is
|但是，有一个问题，|是否有可能至少该系统在提交块之前有描述符块，

686
00:21:05,270 --> 00:21:06,980
0,120 120,750 750,1140 1140,1500 1500,1710
it possible for {at,least} this

687
00:21:06,980 --> 00:21:08,870
0,570 570,750 750,1170 1230,1380 1380,1890
system to have a descriptor

688
00:21:08,870 --> 00:21:10,370
0,450 450,780 780,900 900,1200 1200,1500
block before they commit block,|
|

689
00:21:10,370 --> 00:21:11,840
0,180 180,390 390,600 600,1230 1230,1470
let's say two transactions going
比如两个事务同时进行。

690
00:21:11,840 --> 00:21:12,800
0,120 120,180 180,270 270,540 540,960
on at the same time.|
|

691
00:21:13,930 --> 00:21:15,850
0,240 240,360 360,480 480,840 840,1920
There can be multiple transactions
日志中可以有多个事务。

692
00:21:16,800 --> 00:21:18,640
0,180 180,300 300,1320
in the log.|
|

693
00:21:19,160 --> 00:21:20,780
0,600 630,840 840,900 900,1470 1470,1620
{} That's a transaction to
在下一个事务开始之前，这个事务完成。

694
00:21:20,780 --> 00:21:21,980
0,330 330,660 660,780 780,1050 1050,1200
finish before the next one

695
00:21:21,980 --> 00:21:24,740
0,180 180,750 1230,1470 1470,2190 2220,2760
can start.| Yeah, we're talking
|是的，我们正在讨论这件事，

696
00:21:24,740 --> 00:21:25,700
0,60 60,360 360,570 570,750 750,960
a moment about that,| but
|但是是这样的，

697
00:21:25,700 --> 00:21:27,740
0,570 570,840 840,960 960,1530 1530,2040
it is the case,| yes,
|是的，一次只有一个未完成事务，

698
00:21:27,740 --> 00:21:29,680
0,570 660,1380
that {}

699
00:21:29,680 --> 00:21:31,420
0,450 450,660 660,870 870,1410 1410,1740
there's there's only one open

700
00:21:31,420 --> 00:21:33,760
0,690 690,780 780,840 840,1380 1920,2340
transaction at a time, {}|
|

701
00:21:34,150 --> 00:21:36,180
0,240 240,570 570,690 690,1290
and this is really
这张图片不太合适，

702
00:21:36,180 --> 00:21:37,530
0,480 510,840 840,1080 1080,1170 1170,1350
{} not quite the right

703
00:21:37,530 --> 00:21:38,460
0,300 300,420 420,630 630,870 870,930
picture for that,| because the
|因为当前打开的事务，

704
00:21:38,460 --> 00:21:40,770
0,330 330,570 570,1380 1680,2070 2070,2310
current open transaction,| the current
|当前打开的事务是系统调用正在向其中执行写入的事务，

705
00:21:40,770 --> 00:21:42,630
0,180 180,690 690,1170 1170,1260 1260,1860
open transaction is the transaction

706
00:21:42,630 --> 00:21:44,430
0,180 180,390 390,810 810,1350 1350,1800
into which system calls are

707
00:21:44,640 --> 00:21:47,730
0,930 930,1110 1110,1830 2670,2940 2940,3090
performing their writes| and so
|所以当前打开的事务只存在于内存中，

708
00:21:47,730 --> 00:21:49,260
0,120 120,540 540,780 780,1290 1290,1530
the current open transaction really

709
00:21:49,260 --> 00:21:50,980
0,240 240,600 600,690 690,1290
only exists in memory,|
|

710
00:21:51,670 --> 00:21:53,140
0,420 420,600 600,900 900,1200 1200,1470
{} and because current system
因为当前的系统调用是更新，

711
00:21:53,140 --> 00:21:54,760
0,300 300,510 510,720 720,840 840,1620
calls are sort of updating,|
|

712
00:21:54,820 --> 00:21:56,080
0,300 300,480 480,780 780,1140 1140,1260
their just updating block the
它们只是更新内存中的文件系统块缓存块，

713
00:21:56,080 --> 00:21:58,390
0,810 990,1380 1380,1620 1620,1890 1890,2310
cached block file system blocks

714
00:21:58,390 --> 00:22:00,880
0,180 180,720 1080,1860 1860,2040 2040,2490
in memory,| when the {ext3
|当 ext3 系统决定结束当前打开的事务时，

715
00:22:00,880 --> 00:22:03,040
0,210 210,540 540,990 990,1110 1110,2160
-} system decides to finished

716
00:22:03,530 --> 00:22:06,770
0,360 390,990 990,1260 1260,2220 2700,3240
the current open transaction, {}|
|

717
00:22:07,370 --> 00:22:08,510
0,420 420,480 480,780 780,840 840,1140
{you,know,after} it decides to finish
在它决定结束时，

718
00:22:08,510 --> 00:22:10,160
0,240 420,1080 1080,1320 1320,1470 1470,1650
it,| {} it'll do two
|它会做两件事，

719
00:22:10,160 --> 00:22:10,880
0,240 240,450 450,570 570,630 630,720
things,| one is it will
|一个是它启动一个新的打开的事务，

720
00:22:10,880 --> 00:22:12,470
0,270 270,330 330,630 630,900 900,1590
start a new open transaction,|
|

721
00:22:12,470 --> 00:22:13,130
0,180 180,270 270,360 360,420 420,660
which will be the next
也就是下一个事务，

722
00:22:13,130 --> 00:22:15,500
0,660 750,1470 1530,1890 1890,2010 2010,2370
transaction| and it will then
|然后它写入刚刚完成的事务，

723
00:22:15,500 --> 00:22:16,940
0,480 480,960
write the

724
00:22:16,940 --> 00:22:19,880
0,180 180,720 720,1380 1380,2190 2430,2940
the just finished transaction,| start
|开始将刚刚完成的事务写入磁盘，

725
00:22:19,880 --> 00:22:21,380
0,270 270,420 420,660 660,960 960,1500
writing with just finished transactions

726
00:22:21,380 --> 00:22:22,190
0,120 120,330 330,510 510,600 600,810
to {disk -},| may actually
|可能需要相当长的时间。

727
00:22:22,190 --> 00:22:24,680
0,150 150,360 360,420 420,840 1890,2490
take quite a while.| So,
|所以，整个故事是，

728
00:22:27,140 --> 00:22:29,150
0,600 1110,1230 1230,1680 1680,1800 1800,2010
so you know the full

729
00:22:29,150 --> 00:22:29,930
0,330 330,420 420,540 540,720 720,780
story is that,| there's a
|有一些更老的事务在磁盘上，

730
00:22:29,930 --> 00:22:31,340
0,210 210,300 300,630 630,1290 1290,1410
bunch of older transactions on

731
00:22:31,340 --> 00:22:32,120
0,270 270,420 420,600 600,660 660,780
disk,| that all of which
|所有都是关闭的，

732
00:22:32,120 --> 00:22:35,330
0,60 60,900 1080,2190 2550,2910 2910,3210
are closed| plus one open
|加上一个在内存中打开的事务。

733
00:22:35,330 --> 00:22:36,950
0,720 720,990 990,1170 1170,1530 1530,1620
transaction really only exists in

734
00:22:36,950 --> 00:22:37,900
0,480
memory.|
|

735
00:22:38,690 --> 00:22:40,100
0,240 240,300 300,480 480,930 930,1410
And at least initially,| these
并且至少最开始，|磁盘上的这些事务

736
00:22:40,100 --> 00:22:41,840
0,840 840,930 930,1020 1020,1200 1200,1740
transactions that are on disk,|
|

737
00:22:42,520 --> 00:22:44,530
0,330 330,630 630,1350 1350,1920 1920,2010
{} may only exist in
可能仅以日志记录的形式存在，

738
00:22:44,530 --> 00:22:45,640
0,90 90,540 540,630 630,750 750,1110
the form of the log

739
00:22:45,640 --> 00:22:47,620
0,810 840,1020 1020,1410 1410,1890 1890,1980
records| and haven't initially at
|还没有写到它们的原地址，

740
00:22:47,620 --> 00:22:48,670
0,270 270,420 420,780 780,900 900,1050
least been written to their

741
00:22:48,670 --> 00:22:49,990
0,240 240,870 870,960 960,1080 1080,1320
home locations| and then after
|然后一段时间后，

742
00:22:49,990 --> 00:22:51,340
0,30 30,300 300,390 390,450 450,1350
a while in the background,|
|

743
00:22:51,580 --> 00:22:53,530
0,540 720,1320 1350,1800 1800,1890 1890,1950
{} the starting with the
从最早的事务开始，

744
00:22:53,530 --> 00:22:56,260
0,360 360,1080 1290,1920 1950,2310 2310,2730
oldest transaction,| the logging system
|日志系统会写入，

745
00:22:56,260 --> 00:22:58,540
0,330 480,840 840,1080 1110,1530 1530,2280
will you know write these,|
|

746
00:22:59,380 --> 00:23:00,670
0,270 270,630 630,1140 1140,1230 1230,1290
{} update blocks in the
将日志中的这些更新块写入它们的原位置，

747
00:23:00,670 --> 00:23:02,080
0,450 450,540 540,630 630,780 780,1410
log to their home locations|
|

748
00:23:02,080 --> 00:23:03,010
0,120 120,330 330,540 540,750 750,930
and then once that's been
然后，一旦每个完整的事务完成，

749
00:23:03,010 --> 00:23:05,500
0,330 330,510 510,1110 1290,1710 1710,2490
done for each complete transaction,|
|

750
00:23:05,560 --> 00:23:07,150
0,630 630,720 720,1080 1080,1440 1440,1590
then the logging system can
然后，日志系统可以释放并重用日志中的这些空间，

751
00:23:07,150 --> 00:23:09,260
0,390 390,570 570,1680
free and reuse

752
00:23:09,260 --> 00:23:10,190
0,210 210,420 420,810 810,870 870,930
{} this space in the

753
00:23:10,190 --> 00:23:11,600
0,570 930,1110 1110,1200 1200,1320 1320,1410
log| and so this is
|所以这是一个环形的日志，

754
00:23:11,600 --> 00:23:12,950
0,180 180,240 240,750 750,1170 1170,1350
really a circular log,| when
|当你到达日志末尾时，

755
00:23:12,950 --> 00:23:14,750
0,300 780,1470 1470,1530 1530,1650 1650,1800
you get to the end

756
00:23:14,750 --> 00:23:16,880
0,60 60,120 120,840 840,1230 1560,2130
of the log,| the logging
|日志系统开始使用开头的块，

757
00:23:16,880 --> 00:23:17,960
0,510
system

758
00:23:18,290 --> 00:23:19,940
0,300 300,660 660,900 900,990 990,1650
{} start using the blocks

759
00:23:19,940 --> 00:23:21,320
0,60 60,150 150,720 780,1200 1260,1380
at the beginning| and you
|你必须释放它们，

760
00:23:21,320 --> 00:23:23,450
0,300 300,450 450,720 720,1110 1680,2130
have to free them, {}|
|

761
00:23:24,050 --> 00:23:25,250
0,240 240,420 420,720 720,840 840,1200
free these blocks by writing
将它们写入原位置来释放这些块，

762
00:23:25,250 --> 00:23:26,150
0,120 120,210 210,330 330,450 450,900
them to their home locations,|
|

763
00:23:26,150 --> 00:23:27,080
0,270 270,330 330,450 450,570 570,930
before it can be used.|
然后才能使用它们。|

764
00:23:29,590 --> 00:23:30,620
0,570
Okay.|
好的。|

765
00:23:31,110 --> 00:23:32,220
0,300 300,420 420,600 600,810 810,1110
Okay, so there's three ways
好的，有三种方式可以让 ext3 获得良好性能，

766
00:23:32,220 --> 00:23:33,390
0,210 210,390 390,570 570,780 780,1170
that {} the system gets

767
00:23:33,510 --> 00:23:34,890
0,480 510,870 870,1020 1020,1200 1200,1380
{} {ext3 -} gets good

768
00:23:34,890 --> 00:23:37,740
0,900 1320,1830 2070,2400 2400,2580 2580,2850
performance,| {} one is that
|一个是它有异步系统调用，

769
00:23:37,740 --> 00:23:40,050
0,420 990,1320 1320,1440 1440,1980 1980,2310
it has {asynchronous -} system

770
00:23:40,050 --> 00:23:42,180
0,360 360,480 480,750 1020,1440 1440,2130
calls,| that is system calls
|也就是系统调用在写磁盘之前就返回，

771
00:23:42,240 --> 00:23:44,010
0,690 690,1290 1290,1470 1470,1680 1680,1770
return before they've written the

772
00:23:44,010 --> 00:23:45,570
0,570 600,690 690,960 960,1170 1170,1560
disk,| the system call just
|系统调用只是更新内存中的缓存块，然后返回，

773
00:23:45,570 --> 00:23:48,090
0,660 660,1050 1050,1770 1860,2130 2130,2520
updates cache blocks in memory,

774
00:23:48,090 --> 00:23:49,650
0,90 90,210 210,930 930,1290 1320,1560
and then returns,| never never
|不需要写入磁盘，

775
00:23:49,650 --> 00:23:50,640
0,180 180,270 270,540 540,600 600,990
has to write the disk,|
|

776
00:23:50,640 --> 00:23:51,360
0,150 150,270 270,360 360,600 600,720
never has to wait for
不需要等待磁盘写入，

777
00:23:51,360 --> 00:23:52,680
0,780
{disk,writes},|
|

778
00:23:52,680 --> 00:23:54,090
0,360 390,570 570,750 750,840 840,1410
although may wait for {disk,reads
虽然需要等待磁盘读取。

779
00:23:54,090 --> 00:23:56,880
0,240 1380,1740 1740,2010 2010,2250 2250,2790
-}.| The next big idea
|下一个获得高性能方法是批处理，

780
00:23:57,120 --> 00:23:59,420
0,390 390,1080 1080,1740
for {performance,is} batching,|
|

781
00:24:01,690 --> 00:24:02,770
0,240 240,330 330,420 420,660 660,1080
{} we can batch many
我们可以将多个系统调用在单个事务中批量处理。

782
00:24:03,070 --> 00:24:04,450
0,330 330,600 600,750 750,840 840,1380
system calls into a single

783
00:24:04,660 --> 00:24:07,210
0,900 1350,1830 1860,2010 2010,2340 2340,2550
transaction.| And the final big
|最后一个获得高性能的方法是并发。

784
00:24:07,210 --> 00:24:08,980
0,270 270,390 390,990 990,1140 1140,1770
idea for {performance,is} {concurrency -}.|
|

785
00:24:12,480 --> 00:24:13,200
0,120 120,330 330,420 420,570 570,720
And these are all the
这些是所有的事情，

786
00:24:13,200 --> 00:24:14,460
0,360 360,510 510,570 570,1050 1050,1260
things,| these are basically the
|ext3 做的，而 xv6 没有做的事情。

787
00:24:14,460 --> 00:24:16,080
0,360 360,540 600,1020 1020,1200 1200,1620
things that {ext3 -} does,

788
00:24:16,080 --> 00:24:18,900
0,480 750,1140 1140,1650 2190,2610 2610,2820
that {xv6 -} doesn't do.|
|

789
00:24:20,270 --> 00:24:21,410
0,570 570,750 750,810 810,960 960,1140
Okay, so I'm gonna talk
好的，我将分别谈谈这三个高性能技术。

790
00:24:21,410 --> 00:24:22,430
0,360 420,600 600,750 750,810 810,1020
about each one of these

791
00:24:22,430 --> 00:24:25,800
0,570 900,1410 1410,2130
three performance techniques.|
|

792
00:24:28,170 --> 00:24:29,640
0,270 270,780 780,1080 1080,1320 1320,1470
Oh, sorry, I wanted to
抱歉，我想问一下批处理的事，

793
00:24:29,640 --> 00:24:33,390
0,540 750,1140 1140,1890 3000,3390 3390,3750
ask about batching,| {I,think,xv6 -}
|我想 xv6 允许多个系统调用

794
00:24:33,390 --> 00:24:34,590
0,510 510,720 720,1020 1020,1110 1110,1200
allow for there to be

795
00:24:34,590 --> 00:24:37,110
0,690 990,1440 1440,1860 1860,2100 2100,2520
multiple system calls| that do
|同时执行 start_op end_op ，

796
00:24:37,350 --> 00:24:39,340
0,390 390,780 870,1140 1140,1440
{start_op -} {end_op -},

797
00:24:39,400 --> 00:24:41,100
0,480 690,1200
{} like

798
00:24:41,100 --> 00:24:42,150
0,270 270,510 510,690 690,780 780,1050
at kind of the same

799
00:24:42,150 --> 00:24:44,040
0,570 630,870 870,1380
time,| so then
|然后它们一起提交。

800
00:24:44,100 --> 00:24:46,800
0,240 240,450 450,1200 1230,2010 2130,2700
they will commit together.| Yeah,
|是的， xv6 是有限数量的批处理。

801
00:24:46,800 --> 00:24:47,850
0,180 180,480 480,660 660,810 810,1050
that's true, {xv6 - -}

802
00:24:47,850 --> 00:24:48,690
0,150 150,240 240,570 570,780 780,840
is a limited amount of

803
00:24:48,690 --> 00:24:53,480
0,360 1680,2100 2610,3000 3000,3420
batching.| Right, thank you.|
|好的，谢谢。|

804
00:24:56,340 --> 00:24:58,820
0,270 270,450 450,990 1020,1800
Okay, so first, {}
好的，那么第一个，异步系统调用，

805
00:25:00,580 --> 00:25:02,160
0,1080
asynchronous

806
00:25:02,990 --> 00:25:04,400
0,360 360,930
system calls,|
|

807
00:25:05,320 --> 00:25:06,540
0,630

808
00:25:06,720 --> 00:25:07,640
0,60

809
00:25:08,520 --> 00:25:09,510
0,270 270,420 420,630 630,750 750,990
this just means the system
这意味着系统调用返回，

810
00:25:09,510 --> 00:25:10,890
0,240 240,840 900,1020 1020,1140 1140,1380
calls return,| but they were
|但是它们修改了缓存中的块，然后返回，

811
00:25:10,890 --> 00:25:12,030
0,390 390,720 720,780 780,840 840,1140
modified blocks in the cache

812
00:25:12,030 --> 00:25:14,880
0,150 150,990 1560,1890 1890,2130 2130,2850
then return,| {} don't particularly,
|没有触发磁盘写入。

813
00:25:15,670 --> 00:25:18,490
0,420 420,660 660,900 900,1350 2610,2820
don't trigger disk writes.| So
|所以，这对系统调用快速返回是一个明显的优势。

814
00:25:18,490 --> 00:25:19,840
0,150 150,240 240,330 330,840 840,1350
this has the obvious advantage

815
00:25:19,840 --> 00:25:21,370
0,450 450,630 660,990 990,1200 1200,1530
of the system calls return

816
00:25:21,370 --> 00:25:22,500
0,570
quickly.|
|

817
00:25:22,800 --> 00:25:24,330
0,480 570,810 810,1050 1050,1380 1380,1530
{} It also allows for
它也支持 IO 并发，

818
00:25:24,330 --> 00:25:26,460
0,330 330,450 450,1290 1560,1770 1770,2130
IO {concurrency -},| {} that
|即应用程序可以进行一些文件系统调用，

819
00:25:26,460 --> 00:25:29,190
0,360 510,930 1350,1770 1800,2490 2490,2730
is {} the application can

820
00:25:29,190 --> 00:25:30,600
0,330 330,480 480,780 780,1080 1080,1410
make some file system system

821
00:25:30,600 --> 00:25:32,070
0,240 240,360 360,1230 1260,1380 1380,1470
calls,| that imply that the
|这意味着文件系统要做大量的磁盘写入，

822
00:25:32,070 --> 00:25:32,940
0,210 210,480 480,660 660,780 780,870
file system to do a

823
00:25:32,940 --> 00:25:35,010
0,180 180,270 270,510 510,1200 1200,2070
bunch of disk operations, {disk,writes},|
|

824
00:25:35,610 --> 00:25:37,260
0,270 270,390 390,1200 1230,1500 1500,1650
but the application can then
但是应用可以返回到计算

825
00:25:37,260 --> 00:25:39,140
0,330 330,420 420,1320
return to computing|
|

826
00:25:39,140 --> 00:25:41,270
0,300 300,570 840,1260 1350,2040 2040,2130
{} at in parallel with
与文件系统执行写入并行，

827
00:25:41,270 --> 00:25:42,800
0,90 90,450 450,930 930,1200 1200,1530
the file system doing whatever

828
00:25:42,800 --> 00:25:43,670
0,150 150,480 480,660 660,810 810,870
the writes are| that are
|那些系统调用所需的写入，

829
00:25:43,670 --> 00:25:45,650
0,600 600,720 720,930 930,1290 1290,1980
required by those system calls,|
|

830
00:25:46,670 --> 00:25:47,840
0,300 300,480 480,720 720,1080 1080,1170
so this called IO {concurrency
这就是 IO 并发。

831
00:25:47,840 --> 00:25:49,020
0,660
-}.|
|

832
00:25:49,600 --> 00:25:51,220
0,270 300,780 780,840 840,1290 1290,1620
And without {asynchronous -} system
如果没有异步系统调用，

833
00:25:51,220 --> 00:25:52,540
0,510 600,840 840,1080 1080,1140 1140,1320
calls,| it's hard to get
|就很难获得 IO 并发性，

834
00:25:52,540 --> 00:25:54,740
0,420 420,630 630,1650
IO {concurrency -},|
|

835
00:25:55,520 --> 00:25:57,650
0,450 450,510 510,660 660,1290 1290,2130
hard to get overlap between
很难在磁盘操作和应用程序计算之间重叠，

836
00:25:57,950 --> 00:25:59,990
0,300 300,600 600,1290 1290,1500 1500,2040
{} disk operations and application

837
00:25:59,990 --> 00:26:01,730
0,600 600,810 810,990 990,1530 1530,1740
computing,| if the applications always
|如果应用程序必须等待磁盘写入完成。

838
00:26:01,730 --> 00:26:02,600
0,120 120,210 210,450 450,600 600,870
have to wait for the

839
00:26:02,810 --> 00:26:04,600
0,720 720,840 840,1320
{disk,writes} to complete.|
|

840
00:26:05,070 --> 00:26:07,620
0,510 1260,1470 1470,1680 1680,2100 2190,2550
{} The other thing that's
异步系统调用的另一个好处是，

841
00:26:07,620 --> 00:26:08,880
0,300 300,510 510,570 570,960 960,1260
nice about {asynchronous -} system

842
00:26:08,880 --> 00:26:11,100
0,390 390,660 660,1230 1410,1590 1590,2220
calls is that| they allow,
|它们使执行大量批处理变得更容易，

843
00:26:11,100 --> 00:26:12,300
0,120 120,300 300,390 420,1080 1080,1200
they make it easier to

844
00:26:12,300 --> 00:26:13,950
0,330 330,690 690,990 990,1080 1080,1650
do large amounts of batching,|
|

845
00:26:14,250 --> 00:26:16,360
0,150 150,540 600,1080 1080,1650
so there's help batching.|
可以帮助批处理。|

846
00:26:19,080 --> 00:26:22,200
0,480 810,1020 1020,2130 2130,2460 2490,3120
{} The downside of asynchronous
异步系统调用的缺点是，

847
00:26:22,200 --> 00:26:24,720
0,330 330,780 780,990 990,1350 1860,2520
system calls is that, {}|
|

848
00:26:25,690 --> 00:26:27,130
0,240 240,570 570,960 960,1200 1200,1440
it means that just because
这意味着因为系统调用返回，

849
00:26:27,130 --> 00:26:29,320
0,90 90,360 360,660 660,1410 1440,2190
the system calls return,| doesn't
|并不意味着工作，

850
00:26:29,320 --> 00:26:31,630
0,690 690,1020 1020,1200 1200,1740 1890,2310
mean that the work that,|
|

851
00:26:31,840 --> 00:26:33,760
0,660 690,1110 1140,1380 1500,1650 1650,1920
{} {} {} that system
（并不意味着）系统调用应该做的工作已经完成，

852
00:26:33,760 --> 00:26:35,050
0,420 420,630 750,1050 1050,1170 1170,1290
call {} ought to have

853
00:26:35,050 --> 00:26:36,820
0,510 510,690 690,960 960,1110 1110,1770
done, has actually been completed,|
|

854
00:26:36,880 --> 00:26:38,110
0,360 390,660 660,990 990,1110 1110,1230
so for example if you
所以，如果你编写一个程序，

855
00:26:38,110 --> 00:26:39,550
0,180 180,240 240,660 660,870 960,1440
write a program| that creates
|它创建文件并写入一些数据，

856
00:26:39,550 --> 00:26:40,450
0,60 60,420 420,540 540,720 720,900
a file and write some

857
00:26:40,450 --> 00:26:42,220
0,930 930,1080 1080,1230 1230,1680 1680,1770
data,| and then closes the
|然后关闭该文件，

858
00:26:42,220 --> 00:26:44,350
0,480 480,600 600,900 930,1470 1470,2130
file,| and then prints done
|然后在控制台上打印完成给用户，

859
00:26:44,530 --> 00:26:45,460
0,240 240,330 330,690 690,810 810,930
on the console to the

860
00:26:45,460 --> 00:26:46,440
0,570
user,|
|

861
00:26:46,470 --> 00:26:48,060
0,480 600,780 780,1050 1050,1350 1350,1590
{} and then you pull
然后你拔下电脑电源，

862
00:26:48,060 --> 00:26:48,870
0,120 120,180 180,510 510,720 720,810
out the power plug on

863
00:26:48,870 --> 00:26:50,620
0,90 90,720
your computer,|
|

864
00:26:50,650 --> 00:26:51,820
0,240 240,390 390,750 750,810 810,1170
have to restart the computer,|
重新启动电脑，|

865
00:26:51,820 --> 00:26:52,720
0,150 150,390 390,540 540,750 750,900
your data may not be
你的数据可能不在那里了，

866
00:26:52,720 --> 00:26:53,830
0,450 480,720 720,870 870,1020 1020,1110
there,| even though all the
|即使所有系统调用都返回了，

867
00:26:53,830 --> 00:26:55,510
0,300 300,600 600,1290 1290,1500 1500,1680
system calls returned| and even
|即使程序说，

868
00:26:55,510 --> 00:26:56,620
0,120 120,240 240,780 780,840 840,1110
though the programs are just

869
00:26:56,650 --> 00:26:58,120
0,570 600,960 960,1050 1050,1320 1350,1470
said| look, you know I
|我调用了那些系统调用，而且它们返回了。

870
00:26:58,120 --> 00:26:59,170
0,240 240,390 390,630 630,900 900,1050
called those system calls they

871
00:26:59,170 --> 00:27:00,140
0,450
return.|
|

872
00:27:00,140 --> 00:27:02,000
0,420 690,960 960,1170 1170,1500 1500,1860
{} And this means that
这意味着在一个异步系统调用的世界里，

873
00:27:02,600 --> 00:27:04,370
0,480 810,960 960,1050 1050,1530 1530,1770
{} in a world with

874
00:27:04,370 --> 00:27:07,040
0,570 570,840 840,1440 1500,2520 2520,2670
asynchronous system calls,| applications have
|应用程序必须写得更仔细，

875
00:27:07,040 --> 00:27:08,330
0,120 120,270 270,540 540,780 780,1290
to be written more carefully,|
|

876
00:27:08,330 --> 00:27:09,380
0,150 150,360 390,570 570,690 690,1050
if they if they care
如果它们关心自己在崩溃中的行为，

877
00:27:09,380 --> 00:27:12,050
0,450 1350,1530 1530,1980 1980,2130 2130,2670
about their behavior with respect

878
00:27:12,050 --> 00:27:13,820
0,450 480,1260 1290,1470 1470,1560 1560,1770
to crashes,| this is actually
|这是一个很大的问题，

879
00:27:13,820 --> 00:27:14,780
0,150 150,210 210,270 270,450 450,960
kind of a big deal

880
00:27:14,840 --> 00:27:15,760
0,360
in,|
|

881
00:27:17,360 --> 00:27:19,130
0,210 210,390 390,510 510,1290 1500,1770
in {xv6 - -} {},
在 xv6 中，如果一个写入返回，

882
00:27:19,130 --> 00:27:21,420
0,510 510,600 600,900 900,1710
if a write returned,|
|

883
00:27:21,420 --> 00:27:22,440
0,390 420,540 540,750 750,870 870,1020
{} the data was on
数据就在磁盘上，

884
00:27:22,440 --> 00:27:23,340
0,90 90,510 510,600 600,780 780,900
the disk| and would be
|并且在崩溃后还在那里，

885
00:27:23,340 --> 00:27:25,020
0,180 180,420 420,480 480,1170 1500,1680
there after a crash, {}|
|

886
00:27:25,020 --> 00:27:26,130
0,270 270,570 570,930 930,1050 1050,1110
{in,ext3 - -}, if a
在 ext3 中，如果写入返回，

887
00:27:26,130 --> 00:27:27,640
0,210 210,1050
write returns,|
|

888
00:27:27,900 --> 00:27:29,250
0,570 630,810 810,900 900,1020 1020,1350
just, you don't know anything
|你对崩溃后会发生什么一无所知，

889
00:27:29,250 --> 00:27:30,240
0,210 210,360 360,450 450,720 720,990
about what will happen after

890
00:27:30,240 --> 00:27:31,260
0,30 30,630 660,840 840,900 900,1020
a crash,| may or may
|可能在那里，也可能不在那里。

891
00:27:31,260 --> 00:27:32,440
0,210 210,330 330,600
not be there.|
|

892
00:27:32,440 --> 00:27:35,110
0,540 1410,1710 1710,1770 1770,1950 1950,2670
{} So it is possible
所以，尽管异步系统调用可能编写谨慎的程序，

893
00:27:35,200 --> 00:27:36,640
0,450 450,540 540,900 900,1200 1200,1440
despite {asynchronous -} system calls

894
00:27:36,640 --> 00:27:37,900
0,90 90,300 300,660 660,1110 1110,1260
to write careful programs,| like
|比如数据库就需要小心，

895
00:27:37,900 --> 00:27:39,700
0,840 840,1020 1020,1080 1080,1200 1200,1800
databases need to be careful,|
|

896
00:27:39,910 --> 00:27:41,290
0,630 630,1020 1020,1200 1200,1290 1290,1380
text editors need to be
文本编辑器需要小心，

897
00:27:41,290 --> 00:27:42,430
0,450 480,660 660,960 960,1080 1080,1140
careful,| {if,I} write out a
|如果我写一个文件，

898
00:27:42,430 --> 00:27:43,450
0,450 450,540 540,630 630,750 750,1020
file,| you know I do
|我不想，

899
00:27:43,450 --> 00:27:45,010
0,300 300,810 1140,1350 1350,1500 1500,1560
not want,| if there's a
|如果我在文本编辑器里写一个文件的时候停电了，

900
00:27:45,010 --> 00:27:46,240
0,300 300,630 630,810 810,900 900,1230
power failure while I'm writing

901
00:27:46,240 --> 00:27:46,960
0,150 150,180 180,570 570,630 630,720
out a file in my

902
00:27:46,960 --> 00:27:48,730
0,360 360,750 780,1230 1230,1290 1290,1770
text editor,| that I {don't,want}
|我不想在启动之后看到乱码或部分文件，

903
00:27:49,150 --> 00:27:50,350
0,330 330,480 480,870 870,960 960,1200
after be starting to see

904
00:27:50,350 --> 00:27:51,820
0,540 540,600 600,660 660,1020 1020,1470
garbage or a partial file|
|

905
00:27:51,850 --> 00:27:52,600
0,90 90,210 210,360 360,420 420,750
and I want to see
我想看的是旧文件或新文件。

906
00:27:52,600 --> 00:27:53,710
0,300 300,390 390,600 600,990 990,1110
either the old file or

907
00:27:53,710 --> 00:27:54,920
0,90 90,240 240,690
the new file.|
|

908
00:27:54,920 --> 00:27:55,760
0,300 300,420 420,540 540,600 600,840
{} And so the file
所以文件系统还提供了一些用于谨慎应用的技术，

909
00:27:55,760 --> 00:27:57,920
0,240 240,540 540,990 990,1350 1620,2160
system also provides some techniques

910
00:27:57,920 --> 00:28:01,440
0,120 120,690 690,1800 1830,2400
for careful applications,| to
|在崩溃的情况下获得可预测的行为，

911
00:28:01,900 --> 00:28:05,170
0,360 360,1320 1410,2310 2340,2730 2730,3270
get predictable behavior despite crashes,|
|

912
00:28:05,170 --> 00:28:06,070
0,90 90,180 180,510 510,810 810,900
and the main tool for
主要工具是系统调用 fsync ，

913
00:28:06,070 --> 00:28:08,590
0,210 210,300 300,750 1140,2070 2070,2520
that is called, system call

914
00:28:08,620 --> 00:28:09,740
0,600
{}

915
00:28:10,000 --> 00:28:12,080
0,420 420,570 570,990 990,1410
called {fsync -},| which
|所有 Unix 系统都有，

916
00:28:12,730 --> 00:28:14,230
0,180 180,450 450,810 810,1140 1140,1500
{you,know} all Unix systems have,|
|

917
00:28:14,230 --> 00:28:15,580
0,150 150,330 330,510 510,930 930,1350
and what this basically says
这里说的是，

918
00:28:15,580 --> 00:28:17,650
0,180 180,480 1620,1800 1800,2010 2010,2070
is that| you pass it
|你向它传递一个文件描述符，

919
00:28:17,650 --> 00:28:19,240
0,60 60,300 300,1020
a file descriptor,|
|

920
00:28:19,240 --> 00:28:20,080
0,150 150,240 240,540 540,600 600,840
and it tells the file
它告诉文件系统，执行所有写入，

921
00:28:20,080 --> 00:28:21,700
0,300 300,510 510,870 870,1260 1260,1620
system, look actually do all

922
00:28:21,700 --> 00:28:23,230
0,90 90,240 240,1110 1200,1410 1410,1530
of the writes,| I may
|我可能调用了写入很多东西并调用 fsync ，

923
00:28:23,230 --> 00:28:24,070
0,120 120,390 390,600 600,630 630,840
have called write a bunch

924
00:28:24,070 --> 00:28:25,030
0,60 60,480 480,570 570,750 750,960
of things and call {fsync

925
00:28:25,030 --> 00:28:26,140
0,390 420,630 630,840 840,1020 1020,1110
-},| I now want you
|我现在想让你真正写入，

926
00:28:26,140 --> 00:28:27,640
0,120 120,600 600,780 780,930 930,1500
to actually do the writes|
|

927
00:28:27,670 --> 00:28:29,320
0,600 600,900 900,1320 1320,1500 1500,1650
and don't return from this
不要在写入到磁盘之前从系统调用返回，

928
00:28:29,320 --> 00:28:30,550
0,330 330,600 600,840 840,930 930,1230
system call until the writes

929
00:28:30,550 --> 00:28:32,140
0,180 180,420 420,930 930,1200 1350,1590
are on disk| and are
|保证它们还在那里，如果发生崩溃。

930
00:28:32,140 --> 00:28:33,700
0,480 480,540 540,690 690,1050 1050,1560
guaranteed to be still there,

931
00:28:34,060 --> 00:28:35,410
0,210 210,390 390,570 570,630 630,1350
{} if there's a crash.|
|

932
00:28:35,530 --> 00:28:36,850
0,480 750,930 930,1110 1110,1200 1200,1320
So {} if you look
所以，如果你查看数据库或文本编辑器的代码，

933
00:28:36,850 --> 00:28:37,780
0,90 90,420 420,660 660,840 840,930
at the source code for

934
00:28:37,780 --> 00:28:39,670
0,720 720,870 870,1260 1260,1770 1770,1890
databases or text editors,| a
|还有其他关心它们数据的程序，

935
00:28:39,670 --> 00:28:41,170
0,300 300,360 360,810 1080,1410 1410,1500
number of other programs that

936
00:28:41,170 --> 00:28:42,190
0,180 180,330 330,540 540,660 660,1020
really care about their data,|
|

937
00:28:42,310 --> 00:28:43,870
0,240 240,720 750,990 990,1050 1050,1560
you'll see sort of carefully
你会看到一些对 fsync 的调用，

938
00:28:43,870 --> 00:28:45,430
0,390 390,840 840,930 930,1110 1110,1560
place calls to {fsync -},|
|

939
00:28:45,810 --> 00:28:47,320
0,270 270,390 390,630 630,900
{} in order to
为了克服这个，

940
00:28:47,410 --> 00:28:49,960
0,360 360,420 420,1200 1200,1830 2040,2550
sort of overcome this, {}|
|

941
00:28:50,620 --> 00:28:51,790
0,120 120,390 390,660 660,990 990,1170
to fight that against these
为了避免这些异步系统调用。

942
00:28:51,790 --> 00:28:53,740
0,480 480,810 810,1170 1200,1650 1650,1950
asynchronous system calls.| Most programs
|大多数程序，比如编译器，

943
00:28:53,740 --> 00:28:55,660
0,180 180,480 510,900 930,1560 1560,1920
are like your compiler,| it's
|这不是大问题，

944
00:28:55,660 --> 00:28:57,370
0,120 120,300 300,720 720,1050 1500,1710
no big deal,| if a
|如果发生崩溃，编译器的输出消失了，

945
00:28:57,370 --> 00:28:58,720
0,180 180,450 450,510 510,570 570,1350
the output of the compiler

946
00:28:58,720 --> 00:28:59,650
0,240 240,570 570,690 690,870 870,930
goes away, if there's a

947
00:28:59,650 --> 00:29:00,940
0,480 480,660 660,810 810,1050 1050,1290
crash,| there for many many
|有很多很多程序，

948
00:29:00,940 --> 00:29:02,800
0,780 960,1200 1200,1470 1470,1710 1710,1860
programs,| {you,know} don't call {fsync
|不会调用 fsync ，

949
00:29:02,800 --> 00:29:03,790
0,210 210,330 330,570 570,900 900,990
-}| are very happy to
|很高兴得到异步系统调用的良好性能，

950
00:29:03,790 --> 00:29:05,200
0,180 180,360 360,600 600,1290 1290,1410
get the good performance of

951
00:29:05,200 --> 00:29:07,210
0,540 540,840 840,1350 1770,1920 1920,2010
asynchronous system calls| and are
|并不担心它们的崩溃行为。

952
00:29:07,210 --> 00:29:08,500
0,180 180,510 510,750 750,960 960,1290
not worried about their crash

953
00:29:08,500 --> 00:29:09,440
0,480
behavior.|
|

954
00:29:12,530 --> 00:29:14,510
0,360 360,750 870,1410 1470,1680 1680,1980
Okay, so.| This, is this
好的，那么。|这是不是有时也叫 flush ，

955
00:29:14,510 --> 00:29:16,910
0,750 750,1140 1140,1380 1380,1800 1800,2400
also called like flush sometimes,|
|

956
00:29:16,910 --> 00:29:18,200
0,210 210,330 330,630 630,960 990,1290
because I think that that
因为我以前听过这个词。

957
00:29:18,200 --> 00:29:19,850
0,600 720,960 960,1170 1170,1380 1380,1650
words, I've heard that word

958
00:29:19,850 --> 00:29:22,220
0,540 600,1410 1410,1620 1620,1980 2040,2370
before.| Yeah, you could,| a
|是的，你可以，|一种合理的解释 fsync 作用的方式是，

959
00:29:22,220 --> 00:29:23,330
0,420 420,540 540,600 600,900 900,1110
reasonable way to explain what

960
00:29:23,390 --> 00:29:24,410
0,180 180,360 360,660 660,780 780,1020
{fsync -} does is that|
|

961
00:29:24,470 --> 00:29:26,840
0,240 240,1050 1110,1500 1500,1980 1980,2370
it flushes all previous writes
它将这个文件的所有写入刷新到磁盘，

962
00:29:26,840 --> 00:29:27,710
0,90 90,300 300,660 660,750 750,870
to this file to the

963
00:29:27,710 --> 00:29:29,300
0,570 660,810 810,1020 1020,1380 1380,1590
disk| and only returns that,|
|并且返回，|

964
00:29:30,080 --> 00:29:31,340
0,450 450,630 630,990 990,1170 1170,1260
{flush,is} a reasonable word for
flush 是一个合理的词，

965
00:29:31,340 --> 00:29:33,320
0,420 600,1050 1050,1350 1350,1440 1440,1980
this,| flush writes to disk.|
|flush 写入到磁盘中。|

966
00:29:35,060 --> 00:29:37,060
0,60

967
00:29:37,090 --> 00:29:38,170
0,270 270,450 450,660 660,780 780,1080
Okay, so that's the asynchronous
好的，这就是异步系统调用。

968
00:29:38,170 --> 00:29:39,760
0,300 300,540 540,630 630,1050 1080,1590
system calls.| The next {}
|ext3 使用的下一种技术是批处理。

969
00:29:40,480 --> 00:29:42,730
0,660 780,1020 1020,1440 1440,1650 1650,2250
technique the {ext3 -} uses

970
00:29:42,760 --> 00:29:44,400
0,240 240,390 390,930
{} is batching.|
|

971
00:29:46,560 --> 00:29:49,400
0,690
And,
这里的做法是，

972
00:29:50,040 --> 00:29:51,270
0,120 120,390 390,780 780,960 960,1230
the game here is that,|
|

973
00:29:51,270 --> 00:29:52,590
0,420 420,540 540,720 720,900 900,1320
there's at any one time,|
在任何时候，|

974
00:29:52,590 --> 00:29:55,880
0,180 180,750 750,870 870,1770
there's always {} one
ext3 中总是有一个打开的事务，

975
00:29:56,090 --> 00:29:58,160
0,510 510,1470
open transaction

976
00:29:58,340 --> 00:30:00,050
0,150 150,300 300,570 570,960 1170,1710
in the {ex3 -} {ext3

977
00:30:00,050 --> 00:30:01,180
0,510
-},|
|

978
00:30:01,480 --> 00:30:03,790
0,510 600,1170 1170,1800 1800,1950 1950,2310
{} a transaction in {ext3
ext3 中的事务可以

979
00:30:03,790 --> 00:30:05,140
0,240 240,360 360,810 810,1260 1260,1350
-} can| actually hold the
|保存许多不同系统调用的写入，

980
00:30:05,140 --> 00:30:07,180
0,330 330,450 450,1020 1050,1680 1740,2040
writes of many different many

981
00:30:07,180 --> 00:30:10,330
0,480 480,840 840,1470 1710,2370 2880,3150
distinct system calls,| {} so
|所以 ext3 要做的是启动一个新事务，

982
00:30:10,330 --> 00:30:11,710
0,210 240,660 660,840 840,1080 1080,1380
the {what,ext3 -} does is

983
00:30:11,710 --> 00:30:12,490
0,300 300,360 360,600 600,630 630,780
going to start a new

984
00:30:12,490 --> 00:30:14,050
0,600 600,870 870,990 990,1230 1260,1560
transaction now| and then for
|然后在接下来的几秒钟内，

985
00:30:14,050 --> 00:30:15,850
0,60 60,480 510,900 900,960 960,1800
the next couple of seconds,|
|

986
00:30:15,850 --> 00:30:17,560
0,270 270,630 630,840 840,960 960,1710
all system calls that execute
执行的所有系统调用都是，

987
00:30:17,590 --> 00:30:19,840
0,450 540,1110 1200,1680 1680,2100 2100,2250
are,| {} their writes are
|它们的写入都是那个大事务的一部分，

988
00:30:19,840 --> 00:30:21,130
0,300 300,360 360,540 540,1020 1020,1290
part of that one big

989
00:30:21,130 --> 00:30:23,110
0,840 1080,1260 1260,1410 1410,1530 1530,1980
transaction,| I think by default,|
|我认为默认情况下，|

990
00:30:23,200 --> 00:30:25,210
0,480 480,990 1110,1650 1650,1980 1980,2010
{ext3 -} only creates a
ext3 只在每 5 秒创建一个新事务，

991
00:30:25,210 --> 00:30:27,010
0,90 90,630 630,810 810,1140 1140,1800
new transaction every five seconds,|
|

992
00:30:27,040 --> 00:30:28,900
0,180 180,330 330,960 960,1380 1680,1860
so each transaction may have
所以每个事务可能有最多 5 秒的系统调用，

993
00:30:28,900 --> 00:30:30,010
0,120 120,240 240,480 480,960 960,1110
up to five seconds worth

994
00:30:30,010 --> 00:30:31,630
0,90 90,420 420,750 750,960 1290,1620
of system calls {in,it},| all
|所以作为一个大的批处理，

995
00:30:31,630 --> 00:30:32,830
0,120 120,180 180,510 510,1110 1110,1200
as a huge batch,| and
|然后在 5 秒钟结束时，

996
00:30:32,830 --> 00:30:33,550
0,210 210,300 300,450 450,630 630,720
then at the end of

997
00:30:33,550 --> 00:30:34,860
0,60 60,330 330,1110
the five seconds,|
|

998
00:30:34,980 --> 00:30:36,140
0,570

999
00:30:36,480 --> 00:30:38,130
0,510 510,720 720,870 870,1290 1380,1650
{ext3 -} will commit the
ext3 提交这个单个的大事务，

1000
00:30:38,130 --> 00:30:39,660
0,450 450,690 690,1320 1320,1440 1440,1530
single big transaction| that may
|可能包含上百个更新块，

1001
00:30:39,660 --> 00:30:41,340
0,120 120,540 540,930 960,1350 1350,1680
have hundreds of updated blocks

1002
00:30:41,340 --> 00:30:43,020
0,90 90,270
in it,|
|

1003
00:30:43,020 --> 00:30:44,280
0,240 240,390 390,930 930,990 990,1260
commit this transaction to {disk
将这个事务作为单个事务提交。

1004
00:30:44,280 --> 00:30:46,020
0,390 390,570 570,660 660,1020 1020,1740
-} as a single transaction.|
|

1005
00:30:46,440 --> 00:30:47,160
0,150 150,240 240,330 330,570 570,720
And so the reason why
所以这个有优势的的原因，

1006
00:30:47,160 --> 00:30:48,640
0,150 150,270 270,360 360,900
this is a win,|
|

1007
00:30:48,930 --> 00:30:50,070
0,240 240,480 480,570 570,840 930,1140
{} first of all, it
首先，它分散了一些固定的事务成本，

1008
00:30:50,070 --> 00:30:52,320
0,360 360,540 540,930 930,1530 1530,2250
spreads some fixed transaction costs,|
|

1009
00:30:52,350 --> 00:30:54,510
0,750 750,900 900,1200 1200,1680 1680,2160
amortizes some fixed transaction costs
摊销了很多系统调用中固定的事务成本，

1010
00:30:54,510 --> 00:30:56,130
0,360 360,690 690,1050 1050,1440 1440,1620
across many system calls,| so,
|比如，你必须写入描述符块和提交块，

1011
00:30:56,130 --> 00:30:57,420
0,60 60,630 960,1110 1110,1200 1200,1290
for example, you have to

1012
00:30:57,420 --> 00:30:58,770
0,180 180,270 270,750 750,1230 1230,1350
write the descriptor block and

1013
00:30:58,770 --> 00:31:00,810
0,90 90,420 420,930 1260,1590 1800,2040
the commit block| and {}
|你必须在机械驱动器上寻找，

1014
00:31:00,810 --> 00:31:02,070
0,210 240,480 480,600 600,1110 1140,1260
you have to seek on

1015
00:31:02,070 --> 00:31:03,030
0,30 30,480 480,690 690,780 780,960
a mechanical drive,| at least
|至少你必须寻找，

1016
00:31:03,030 --> 00:31:04,110
0,60 60,150 150,240 240,720 780,1080
you have to seek| and
|让驱动器旋转到日志所在的位置，

1017
00:31:04,110 --> 00:31:05,160
0,120 120,210 210,480 480,960 960,1050
let the drive rotate to

1018
00:31:05,160 --> 00:31:06,060
0,90 90,360 360,480 480,600 600,900
the place where the log

1019
00:31:06,060 --> 00:31:07,290
0,240 240,420 420,690 690,750 750,1230
is,| and those are significant
|这些都是很大的开销，

1020
00:31:07,290 --> 00:31:09,570
0,570 870,1290 1650,1950 1950,2160 2160,2280
costs| and they only have
|而它们对于批处理只需要做一次，

1021
00:31:09,570 --> 00:31:10,470
0,90 90,300 300,510 510,750 750,900
to be done once for

1022
00:31:10,470 --> 00:31:11,580
0,420 420,720 720,780 780,1020 1020,1110
batch,| instead of once per
|而不是每个系统调用一次。

1023
00:31:11,580 --> 00:31:12,540
0,360 360,630
system call.|
|

1024
00:31:12,540 --> 00:31:13,710
0,90 90,210 300,600 600,690 690,1170
So, it lowers the impact
因此，它降低了这些成本的影响。

1025
00:31:13,710 --> 00:31:17,100
0,60 60,570 870,1170 1170,1770 2790,3390
of those those costs. {}|
|

1026
00:31:17,580 --> 00:31:18,570
0,240 240,420 420,570 570,840 840,990
The other big deal is
另一个大事是，

1027
00:31:18,570 --> 00:31:20,370
0,420 750,990 990,1380 1380,1560 1560,1800
that,| {} another big deal
|另一个大事是它允许写入吸收，

1028
00:31:20,370 --> 00:31:22,050
0,150 150,270 270,360 360,1170 1200,1680
is that it allows {write,absorption

1029
00:31:22,050 --> 00:31:23,340
0,750
-},|
|

1030
00:31:23,850 --> 00:31:26,420
0,570 570,780 780,1110 1380,2010
{} that is, {}|
也就是说，|

1031
00:31:29,000 --> 00:31:31,070
0,210 210,480 480,570 570,1410 1440,2070
it's often the case,| that
它是这种情况，|你有一个完整的系统调用序列，

1032
00:31:31,490 --> 00:31:32,420
0,180 180,300 300,360 360,510 510,930
you have a whole sequence

1033
00:31:32,420 --> 00:31:33,500
0,90 90,420 420,690 690,870 870,1080
of system calls,| that end
|一次又一次地修改完全相同的块，

1034
00:31:33,500 --> 00:31:35,120
0,180 180,750 750,870 870,1260 1260,1620
up modifying the very same

1035
00:31:35,120 --> 00:31:36,590
0,420 420,720 720,810 810,1020 1020,1470
blocks over and over again,|
|

1036
00:31:36,740 --> 00:31:38,330
0,240 240,390 390,960 1110,1500 1500,1590
so for example if I
比如，如果我创建了一大堆文件，

1037
00:31:38,330 --> 00:31:39,050
0,300 300,330 330,450 450,630 630,720
create a whole bunch of

1038
00:31:39,050 --> 00:31:40,910
0,840 1020,1410 1410,1530 1530,1740 1740,1860
files,| {} I need to
|我需要分配一堆 inode ，

1039
00:31:40,910 --> 00:31:41,780
0,390 390,420 420,600 600,750 750,870
allocate a bunch of {inodes

1040
00:31:41,780 --> 00:31:43,910
0,570 570,930 1020,1380 1380,1770 1770,2130
-}| and that means all
|所有的 inode 都很小，可能只有 64 个字节，

1041
00:31:43,910 --> 00:31:45,140
0,90 90,360 360,570 600,1020 1020,1230
{inodes -} are small, maybe

1042
00:31:45,140 --> 00:31:46,670
0,540 540,900 900,1050 1050,1290 1290,1530
64 bytes,| so many, many
|这么多 inode 可以放在一个块中，

1043
00:31:46,670 --> 00:31:47,360
0,120 120,300 300,540 540,630 630,690
{inodes -} fit in a

1044
00:31:47,360 --> 00:31:49,130
0,480 690,990 990,1440 1440,1560 1560,1770
block,| so creating a bunch
|所以，连续创建一堆文件

1045
00:31:49,130 --> 00:31:50,180
0,90 90,420 420,480 480,570 570,1050
of files in a row|
|

1046
00:31:50,330 --> 00:31:52,280
0,270 270,510 510,1080 1230,1770 1770,1950
is gonna dirty many {inodes
会使几个块中的许多 inode 变脏，

1047
00:31:52,280 --> 00:31:54,320
0,420 420,540 540,630 630,1050 1050,2040
-} in a few blocks,|
|

1048
00:31:54,600 --> 00:31:56,400
0,480 600,1110 1200,1380 1380,1590 1590,1800
{} because there's many {inodes
因为有很多块的 inode 。

1049
00:31:56,400 --> 00:31:58,290
0,150 150,300 300,690 720,1410 1500,1890
-} for block.| Similarly, if
|类似地，如果我要将大量数据写入文件，

1050
00:31:58,290 --> 00:32:01,020
0,300 450,1350 1410,2010 2370,2670 2670,2730
I'm writing a bunch of

1051
00:32:01,020 --> 00:32:01,710
0,210 210,330 330,420 420,660 660,690
data to a file,| I
|我可能需要分配很多数据块，

1052
00:32:01,710 --> 00:32:02,520
0,150 150,330 330,390 390,780 780,810
may need to allocate a

1053
00:32:02,520 --> 00:32:04,020
0,180 180,270 270,510 510,1110 1140,1500
lot of data blocks,| {I,may}
|我可能会翻转空闲位图中的许多位，

1054
00:32:04,020 --> 00:32:06,390
0,600 630,1200 1200,1560 1560,1710 1710,2370
{} flip many of the

1055
00:32:06,930 --> 00:32:08,370
0,600 600,720 720,810 810,1230 1230,1440
bits in the block free

1056
00:32:08,370 --> 00:32:10,800
0,540 1260,1560 1560,1800 1800,2160 2160,2430
map| and {if,I} allocate blocks
|如果我分配彼此相邻的块，

1057
00:32:10,800 --> 00:32:11,430
0,120 120,150 150,390 390,510 510,630
that are next to each

1058
00:32:11,430 --> 00:32:12,660
0,360 480,750 750,930 930,1170 1170,1230
other,| {} their bits are
|它们的位将放在同一个块中，

1059
00:32:12,660 --> 00:32:13,110
0,120 120,180 180,270 270,360 360,450
going to be in the

1060
00:32:13,110 --> 00:32:14,520
0,420 420,1050
same block,|
|

1061
00:32:14,520 --> 00:32:15,330
0,120 120,210 210,270 270,480 480,810
and so I may put
所以，我可能在一个块中放很多位，

1062
00:32:15,330 --> 00:32:16,800
0,360 360,870 870,1020 1020,1260 1260,1470
many bits in just one

1063
00:32:16,800 --> 00:32:18,960
0,540 630,840 840,1140 1140,1470 1470,2160
block,| so many system calls
|所以，许多系统调用可能会一次又一次地操作相同的块。

1064
00:32:18,990 --> 00:32:21,900
0,570 810,1350 1950,2460 2460,2850 2850,2910
again {} may operating the

1065
00:32:21,900 --> 00:32:22,860
0,240 240,480 480,720 720,810 810,960
same blocks over and over

1066
00:32:22,860 --> 00:32:24,180
0,390 390,810
again.| And
|在使用批处理的系统中，

1067
00:32:24,620 --> 00:32:25,880
0,150 150,210 210,450 450,570 570,1260
in the system with batching,|
|

1068
00:32:25,910 --> 00:32:28,040
0,630 780,1350 1350,1650 1650,1860 1860,2130
{} those many many writes
这些很多写入相同的数据块，

1069
00:32:28,040 --> 00:32:29,540
0,150 150,390 390,780 780,990 990,1500
the same blocks,| just happen
|只是对缓存发生得非常快，

1070
00:32:29,840 --> 00:32:31,790
0,330 330,900 900,1050 1050,1140 1140,1950
very quickly to the cached,|
|

1071
00:32:31,940 --> 00:32:33,680
0,660 690,1080 1080,1140 1140,1410 1410,1740
{} just the cache copies
只是数据块的缓存拷贝，

1072
00:32:33,680 --> 00:32:34,550
0,120 120,420 420,600 600,690 690,870
of blocks,| because we're not
|因为我们还没有写入磁盘，

1073
00:32:34,550 --> 00:32:36,080
0,240 240,330 330,840 1050,1380 1380,1530
writing the disk| and then
|然后，我们将这些少量数据块写入磁盘，

1074
00:32:36,080 --> 00:32:38,500
0,150 150,600 630,1290 1350,1980
we write the {}

1075
00:32:38,650 --> 00:32:39,820
0,270 270,600 600,840 840,900 900,1170
those small number of blocks

1076
00:32:39,820 --> 00:32:41,230
0,90 90,180 180,540 570,1020 1020,1410
to the disk| only once
|只在事务结束时写入一次，

1077
00:32:41,230 --> 00:32:41,710
0,90 90,210 210,360 360,420 420,480
at the end of the

1078
00:32:41,710 --> 00:32:43,660
0,750 900,1050 1050,1110 1110,1530 1530,1950
transaction| and the single block
|而单个块写入日志，

1079
00:32:43,660 --> 00:32:45,520
0,330 330,540 540,900 1230,1650 1650,1860
write into the, {} on

1080
00:32:45,520 --> 00:32:47,110
0,60 240,720 720,930 930,1050 1050,1590
the writing of the log,|
|

1081
00:32:47,170 --> 00:32:49,960
0,900 1470,1950 1950,2190 2190,2520 2520,2790
reflects many many system calls
将许多修改的系统调用放入同一个块中。

1082
00:32:49,960 --> 00:32:50,980
0,150 150,240 240,870 870,960 960,1020
{with -} modifications to the

1083
00:32:50,980 --> 00:32:52,120
0,210 210,630 660,810 810,960 960,1140
same block.| So this {write,absorption
|所以，这种写入吸收可以减少总次数的数量，

1084
00:32:52,120 --> 00:32:53,580
0,510 510,630 630,930
-} could be|

1085
00:32:53,580 --> 00:32:54,560
0,330

1086
00:32:54,940 --> 00:32:56,590
0,720 720,780 780,1020 1020,1470 1500,1650
reduce the amount of the
明显减少我们必须写入块的总次数，

1087
00:32:56,590 --> 00:32:58,420
0,360 360,780 1050,1650 1650,1740 1740,1830
total number times we have

1088
00:32:58,420 --> 00:33:00,280
0,120 120,360 360,480 570,1080 1170,1860
to write the block dramatically|
|

1089
00:33:00,280 --> 00:33:01,840
0,360 360,480 480,720 720,1200 1200,1560
compared to a synchronous system,
与类似 xv6 的同步系统相比。

1090
00:33:01,840 --> 00:33:02,740
0,420
like

1091
00:33:02,760 --> 00:33:04,540
0,300 300,510 510,630 630,1260
{} {xv6 - -}.|
|

1092
00:33:05,870 --> 00:33:07,670
0,540 930,1080 1080,1170 1170,1530 1530,1800
{} And the final big
最后的重大优势是磁盘调度，

1093
00:33:07,670 --> 00:33:10,790
0,420 420,960 960,1350 1350,1980 2430,3120
win is disk scheduling, {}|
|

1094
00:33:12,530 --> 00:33:13,980
0,240 240,840
in general,
一般来说，即使我们，

1095
00:33:14,350 --> 00:33:15,360
0,360
{}

1096
00:33:16,100 --> 00:33:18,440
0,360 360,750 750,1140 1140,1710
even if we are,|
|

1097
00:33:18,590 --> 00:33:19,850
0,570 570,690 690,780 780,900 900,1260
suppose we have to write
假设我们必须向磁盘写入一千个块，

1098
00:33:19,880 --> 00:33:21,170
0,330 330,720 720,1140 1140,1230 1230,1290
a thousand blocks to the

1099
00:33:21,170 --> 00:33:23,150
0,630 1170,1440 1470,1800 1800,1890 1890,1980
disk,| it turns out to
|它的效率要高得多，

1100
00:33:23,150 --> 00:33:24,590
0,90 90,330 330,480 480,1080 1110,1440
be much more efficient,| certainly
|当然是在机械磁盘上，

1101
00:33:24,590 --> 00:33:25,850
0,90 90,600 600,930 930,1050 1050,1260
in mechanical drives,| but even
|但是即使在固态驱磁盘中，

1102
00:33:25,850 --> 00:33:27,500
0,90 90,390 390,660 660,1260 1320,1650
in solid state drives,| to
|为了在顺序位置中一次写入一千个块，

1103
00:33:27,500 --> 00:33:29,510
0,240 240,360 360,1200 1230,1800 1800,2010
write a thousand blocks all

1104
00:33:29,510 --> 00:33:32,090
0,120 120,750 780,990 1050,1710 1710,2580
at once in sequential locations,|
|

1105
00:33:32,150 --> 00:33:32,750
0,180 180,270 270,360 360,480 480,600
as you would do to
就像你对日志所做的那样，

1106
00:33:32,750 --> 00:33:34,730
0,90 90,630 1050,1440 1440,1620 1620,1980
a log,| as much faster
|做这个要快的多，

1107
00:33:34,730 --> 00:33:35,660
0,60 60,180 180,510 510,750 750,930
to do that| than to
|跟写入一千个块每次都在不同的地方比较，

1108
00:33:35,660 --> 00:33:38,000
0,300 330,660 660,1230 1230,1890 1920,2340
write a thousand blocks one

1109
00:33:38,000 --> 00:33:38,990
0,90 90,120 120,600 600,690 690,990
at a time to different

1110
00:33:38,990 --> 00:33:41,450
0,990 1380,1710 1710,1890 1890,1980 1980,2460
locations| or even a thousand
|甚至一千个块，

1111
00:33:41,450 --> 00:33:43,430
0,840 870,1050 1050,1320 1320,1680 1770,1980
blocks,| {you,know} even write the
|甚至在日志中写入相同的块一千次。

1112
00:33:43,430 --> 00:33:45,620
0,240 240,750 780,960 960,1500 1500,2190
same block a thousand times

1113
00:33:45,620 --> 00:33:46,760
0,120 120,180 180,870
in a log.|
|

1114
00:33:47,860 --> 00:33:49,600
0,390 720,990 990,1380 1380,1620 1620,1740
So by handing up the
所以，通过让磁盘进行大批量写入，

1115
00:33:49,600 --> 00:33:51,310
0,330 330,720 720,1230 1230,1350 1350,1710
disk large batches of writes

1116
00:33:51,310 --> 00:33:53,410
0,120 120,600 930,1440 1680,1980 1980,2100
to do,| {} this can
|这样可以更有效率，

1117
00:33:53,410 --> 00:33:55,930
0,120 120,330 330,480 480,1080 2250,2520
be much more efficient,| there's
|我们不仅获得效率

1118
00:33:55,930 --> 00:33:57,040
0,270 270,690 690,900 900,990 990,1110
also not only do we

1119
00:33:57,040 --> 00:33:58,660
0,270 270,390 390,960 960,1140 1140,1620
get an efficiency| from writing
|从顺序写入日志中的很多块，

1120
00:33:58,660 --> 00:33:59,800
0,120 120,480 480,660 660,720 720,1140
a large number of blocks

1121
00:33:59,800 --> 00:34:01,660
0,540 540,630 630,690 690,1230 1380,1860
sequentially in the log,| but
|但是即使我们要写入原位置，

1122
00:34:01,810 --> 00:34:02,800
0,480 480,630 630,750 750,900 900,990
even when we go to

1123
00:34:02,800 --> 00:34:04,270
0,210 210,270 270,570 570,1350 1350,1470
write the home locations| for
|为一批写入，

1124
00:34:04,270 --> 00:34:06,010
0,480 510,690 690,750 750,1470 1470,1740
this, for a batch of

1125
00:34:06,010 --> 00:34:08,890
0,540 900,1530 1530,2070 2160,2580 2760,2880
{} writes,| resulting from a
|由单个大事务中的一批操作产生，

1126
00:34:08,890 --> 00:34:10,090
0,330 330,420 420,1050 1050,1140 1140,1200
batch of operations in a

1127
00:34:10,090 --> 00:34:12,280
0,270 270,420 420,1110 1440,1830 1830,2190
single big transaction,| even then
|如果我们可以向该驱动器大量的写入，

1128
00:34:12,280 --> 00:34:13,480
0,150 150,240 240,390 390,900 930,1200
if we can hand a

1129
00:34:13,480 --> 00:34:15,370
0,360 360,810 810,1290 1290,1410 1410,1890
very large number of writes

1130
00:34:15,370 --> 00:34:16,390
0,90 90,210 210,720 720,930 930,1020
to that drive,| even if
|即使有不同的位置，

1131
00:34:16,390 --> 00:34:17,800
0,180 180,240 240,510 510,1140 1140,1410
there are different locations,| because
|因为有原位置，

1132
00:34:17,800 --> 00:34:19,060
0,240 240,330 330,420 420,660 660,1260
there to the home locations,|
|

1133
00:34:19,680 --> 00:34:20,610
0,240 240,330 330,660 660,780 780,930
you know referred to by
涉及多个不同的系统调用，

1134
00:34:20,610 --> 00:34:22,650
0,240 240,600 600,900 900,1410 1680,2040
many different system calls,| if
|如果我们允许磁盘调度大量不同的写入，

1135
00:34:22,650 --> 00:34:23,910
0,90 90,390 390,570 570,1110 1110,1260
we allow the disk to

1136
00:34:23,910 --> 00:34:27,030
0,930 1200,1560 1650,2250 2250,2670 2670,3120
schedule a large number of

1137
00:34:27,060 --> 00:34:28,620
0,510 510,960 990,1260 1260,1380 1380,1560
distinct writes,| it can pick
|它可以选一个顺序把它们放进去，

1138
00:34:28,620 --> 00:34:29,520
0,120 120,420 420,540 540,750 750,900
an order to do them

1139
00:34:29,520 --> 00:34:31,770
0,240 240,480 480,1020 1020,1680 1980,2250
in,| that's particularly efficient on
|这在机械磁盘上特别有效率，

1140
00:34:31,770 --> 00:34:33,240
0,30 30,510 510,750 750,930 930,1470
a mechanical drive,| this {would,done}
|这对它们进行排序，

1141
00:34:34,350 --> 00:34:37,260
0,810 1080,1440 1470,2160 2160,2580 2580,2910
involve {} sorting them| and
|按驱动器上的磁道号进行排序，

1142
00:34:37,590 --> 00:34:39,180
0,570 570,720 720,870 870,1320 1320,1590
sorting them by track number

1143
00:34:39,180 --> 00:34:40,350
0,90 90,150 150,570 570,690 690,1170
on the drive| and doing
|从一个到另一个只需一次小的寻找，

1144
00:34:40,470 --> 00:34:41,820
0,420 660,1020 1020,1110 1110,1290 1290,1350
{} you know just a

1145
00:34:41,820 --> 00:34:42,900
0,210 210,630 630,780 780,1020 1020,1080
little seek from one to

1146
00:34:42,900 --> 00:34:44,430
0,120 120,840 900,1230 1230,1440 1440,1530
the next,| and they can
|它们可以进行这种排序，

1147
00:34:44,430 --> 00:34:45,450
0,120 120,300 300,660 750,900 900,1020
do this sort,| if you
|如果你同时得到所有的块。

1148
00:34:45,450 --> 00:34:46,820
0,210 210,450 450,570 570,840
get all of the

1149
00:34:46,820 --> 00:34:48,080
0,420 420,480 480,570 570,810 810,1260
blocks at the same time.|
|

1150
00:34:48,500 --> 00:34:49,280
0,240 240,390 390,600 600,720 720,780
And but even on a
即使是在固态硬盘上，

1151
00:34:49,280 --> 00:34:50,540
0,480 480,780 780,840 840,1110 1110,1260
{solid,state} drive,| it turns out
|这里也有一些小优势，

1152
00:34:50,540 --> 00:34:52,730
0,420 450,750 990,1800 1800,2100 2100,2190
there's a smaller win to

1153
00:34:52,730 --> 00:34:54,380
0,120 120,510 510,960 1320,1560 1560,1650
be gotten| from giving the
|给磁盘大量的工作去做。

1154
00:34:54,380 --> 00:34:55,220
0,210 210,480 480,540 540,750 750,840
disk lots of work to

1155
00:34:55,220 --> 00:34:55,960
0,210
do.|
|

1156
00:34:56,150 --> 00:34:57,290
0,330 330,480 480,690 780,1020 1020,1140
Anyway, so this you can
不管怎么说，你能得到这种磁盘调度，

1157
00:34:57,290 --> 00:34:58,340
0,180 180,420 420,690 690,810 810,1050
only really get this kind

1158
00:34:58,340 --> 00:35:00,890
0,240 240,660 690,930 930,1650 2160,2550
of {} disk scheduling,| if
|如果你有非常大批量写入交给磁盘，

1159
00:35:00,890 --> 00:35:02,150
0,180 180,390 390,630 630,900 900,1260
you have very large batches

1160
00:35:02,150 --> 00:35:03,590
0,120 120,360 360,690 690,840 840,1440
of write {to,give} to drive,|
|

1161
00:35:03,650 --> 00:35:04,820
0,180 180,420 420,750 750,1020 1020,1170
so there's another win from
所以这是批处理的又一个优势。

1162
00:35:04,820 --> 00:35:05,800
0,450
batch.|
|

1163
00:35:09,180 --> 00:35:11,200
0,720 750,1410
Alright, {}|
好的，|

1164
00:35:11,410 --> 00:35:12,440
0,360
and,
ext3 的最后一个重大优势是并发，

1165
00:35:12,440 --> 00:35:13,610
0,90 90,390 390,570 570,810 810,1170
a final big win from

1166
00:35:13,610 --> 00:35:14,660
0,450
{}

1167
00:35:15,700 --> 00:35:18,520
0,210 210,810 810,1170 1170,2070 2490,2820
the ext3 gets concurrency,| it's
|它有两种并发性，

1168
00:35:18,520 --> 00:35:19,520
0,150 150,360
really get

1169
00:35:19,580 --> 00:35:22,430
0,360 360,1110 1110,1680 2100,2730 2730,2850
two kinds of concurrency| that
|与 xv6 比较。

1170
00:35:22,430 --> 00:35:23,900
0,90 90,570 570,930
it benefits from

1171
00:35:27,510 --> 00:35:29,840
0,300 300,720 720,780 780,1800
{} compared to xv6.|
|

1172
00:35:31,670 --> 00:35:32,940
0,570

1173
00:35:34,340 --> 00:35:36,200
0,390 390,660 660,990 1590,1770 1770,1860
One is that, it can
一个是，它可以允许多个系统调用同时执行，

1174
00:35:36,200 --> 00:35:37,400
0,270 270,510 510,840 840,1110 1110,1200
allow many system calls to

1175
00:35:37,400 --> 00:35:38,660
0,450 450,510 510,600 600,870 870,1260
execute at the same time,|
|

1176
00:35:38,660 --> 00:35:40,910
0,390 420,630 630,780 780,1590 1620,2250
so we can have many
所以，我们可以并行进行多个系统调用。

1177
00:35:40,910 --> 00:35:43,520
0,480 480,840 840,1680 1800,1890 1890,2610
individual system calls in parallel.|
|

1178
00:35:44,370 --> 00:35:45,520
0,600

1179
00:35:45,520 --> 00:35:48,180
0,630 1110,1530 1530,2100
Because at least,|
因为至少，|

1180
00:35:49,340 --> 00:35:51,260
0,600 630,1320
{} until
在 ext3 决定关闭并提交当前事务之前，

1181
00:35:51,400 --> 00:35:53,170
0,600 660,1110 1110,1320 1320,1680 1680,1770
{} {ext3 -} decides to

1182
00:35:53,170 --> 00:35:54,640
0,360 360,540 540,630 630,1050 1050,1470
close out and commit the

1183
00:35:55,500 --> 00:35:58,860
0,330 330,1170 2610,3120 3120,3270 3270,3360
current transaction,| {the,system,call} don't have
|系统调用不必相互等待，

1184
00:35:58,860 --> 00:35:59,670
0,120 120,330 330,480 480,630 630,810
to wait for each other,|
|

1185
00:35:59,670 --> 00:36:00,840
0,90 90,210 210,330 330,780 780,1170
they can all modify blocks
它们都可以修改属于当前事务的块，

1186
00:36:00,840 --> 00:36:01,410
0,90 90,150 150,420 420,480 480,570
that are part of the

1187
00:36:01,410 --> 00:36:02,670
0,240 240,780 780,870 870,1020 1020,1260
current transaction| and all these
|并且所有这些系统调用都可以并行执行，

1188
00:36:02,670 --> 00:36:04,500
0,270 270,510 510,810 810,1350 1350,1830
many many system calls can

1189
00:36:05,440 --> 00:36:08,080
0,480 480,690 690,1470 1470,1890 2040,2640
execute in parallel| and contribute
|并向当前事务添加块，

1190
00:36:08,080 --> 00:36:09,370
0,330 330,390 390,480 480,750 750,1290
blocks to the current transaction,|
|

1191
00:36:09,610 --> 00:36:10,870
0,270 270,780 780,1140 1140,1230 1230,1260
that's particularly important on a
这在多核计算机上尤为重要，

1192
00:36:10,870 --> 00:36:12,610
0,300 300,480 480,1110 1170,1620 1620,1740
{multi-core -} machine,| where we
|在没有不同内核的地方，

1193
00:36:12,610 --> 00:36:13,150
0,150 150,300 300,360 360,480 480,540
don't want to have the

1194
00:36:13,150 --> 00:36:14,260
0,270 270,540 540,690 690,990 990,1110
different cores,| we're waiting for
|我们等待锁，

1195
00:36:14,260 --> 00:36:16,870
0,90 90,720 1590,1980 1980,2070 2070,2610
a lock,| {in,xv6 - -}
|在 xv6 经常是不允许的，

1196
00:36:17,260 --> 00:36:18,370
0,330 330,480 480,690 690,900 900,1110
{} we often, it's often

1197
00:36:18,370 --> 00:36:18,970
0,60 60,270 270,360 360,450 450,600
the case that you're not

1198
00:36:18,970 --> 00:36:20,920
0,720 750,1080 1080,1260 1260,1470 1470,1950
allowed,| system call can't proceed,|
|系统调用不能进行，|

1199
00:36:20,920 --> 00:36:22,800
0,540 750,1440
because {}
因为当前事务正忙于做其他事情。

1200
00:36:23,640 --> 00:36:24,870
0,120 120,360 360,870 870,990 990,1230
the current transaction is busy

1201
00:36:24,870 --> 00:36:26,480
0,180 180,480 480,1140
doing something else.|
|

1202
00:36:26,690 --> 00:36:27,710
0,570 570,630 630,690 690,930 930,1020
Most of the time in
在 ext3 中的大多数情况下，

1203
00:36:27,710 --> 00:36:29,160
0,360 360,870
{ext3 -},|
|

1204
00:36:29,780 --> 00:36:31,520
0,360 360,660 660,1080 1290,1560 1560,1740
many system calls {} can
许多系统调用都可以修改当前事务。

1205
00:36:31,520 --> 00:36:33,800
0,390 390,480 480,720 720,1320
modify the current transaction.|
|

1206
00:36:33,860 --> 00:36:35,870
0,390 390,540 540,810 810,1260 1590,2010
The other way that {ext3
ext3 获得并发性的另一种方式是

1207
00:36:35,870 --> 00:36:37,520
0,210 210,450 450,1110 1110,1320 1320,1650
-} gets concurrency is that|
|

1208
00:36:37,730 --> 00:36:40,040
0,210 210,360 360,510 510,1020 1020,2310
there can be multiple transactions,|
可以有多个事务，|

1209
00:36:40,070 --> 00:36:42,740
0,720 720,1440 1440,1620 1620,2010 2010,2670
older transactions in different stages
处于不同执行阶段的旧事务。

1210
00:36:42,740 --> 00:36:44,160
0,90 90,900
of execution.|
|

1211
00:36:44,460 --> 00:36:45,500
0,510

1212
00:36:46,670 --> 00:36:47,630
0,240 240,330 330,570 570,630 630,960
So it's true, {} system
所以，只有一个打开的事务可以接收系统调用，

1213
00:36:47,630 --> 00:36:49,640
0,600 660,1050 1050,1230 1260,1710 1710,2010
calls only the one open

1214
00:36:49,640 --> 00:36:51,620
0,840 900,1110 1110,1440 1440,1740 1740,1980
transaction can receive system calls,|
|

1215
00:36:51,620 --> 00:36:52,730
0,210 210,330 330,480 480,990 990,1110
but the other transactions that
但是其他正在向磁盘写入内容的事务可以并行进行，

1216
00:36:52,730 --> 00:36:53,690
0,60 60,330 330,570 570,660 660,960
are writing things to disk

1217
00:36:53,690 --> 00:36:54,800
0,150 150,300 300,450 450,510 510,1110
can go on in parallel,|
|

1218
00:36:55,040 --> 00:36:58,700
0,540 840,1530 1530,1860 1860,3210
so many older transactions|
所以很多老的事务，|

1219
00:37:00,470 --> 00:37:02,690
0,330 660,1170 1350,1620 1620,2040 2040,2220
and {} the different sort
在事务生命周期中的不同阶段，

1220
00:37:02,690 --> 00:37:04,610
0,90 210,1110 1110,1200 1200,1230 1230,1920
of stages in a transaction's

1221
00:37:04,610 --> 00:37:05,630
0,270 270,420 420,570 570,750 750,1020
life,| that can go on
|可以并行进行。

1222
00:37:05,630 --> 00:37:08,390
0,120 120,870 2190,2520 2520,2700 2700,2760
in parallel.| First, there's the
|首先，这里有一个打开的事务，

1223
00:37:08,390 --> 00:37:10,400
0,270 270,570 570,1470
one open transaction,|
|

1224
00:37:12,220 --> 00:37:13,480
0,390 390,540 540,660 660,990 1020,1260
{} there can be some
可以有一些最近的事务，

1225
00:37:13,480 --> 00:37:15,130
0,270 270,360 360,1320 1320,1470 1470,1650
number of transactions that are

1226
00:37:15,160 --> 00:37:17,380
0,630 780,1230 1500,1860 1860,2010 2010,2220
recent| and {} the file
|文件系统正在提交它们，

1227
00:37:17,380 --> 00:37:18,970
0,300 300,450 450,930 930,1260 1260,1590
system is committing them,| but
|但它们仍在将数据块写入磁盘，

1228
00:37:19,030 --> 00:37:20,650
0,240 240,720 720,1110 1110,1260 1260,1620
they're still writing their blocks

1229
00:37:20,650 --> 00:37:21,730
0,120 120,210 210,750 780,990 990,1080
to the disk,| so we
|所以，我们有一些事务正在提交到日志中。

1230
00:37:21,730 --> 00:37:23,100
0,240 360,810
have {}

1231
00:37:23,100 --> 00:37:24,360
0,270 270,480 480,540 540,1200 1200,1260
some number of transactions are

1232
00:37:24,360 --> 00:37:26,460
0,360 360,1050 1140,1350 1350,1470 1470,2100
currently committing to the log.|
|

1233
00:37:30,280 --> 00:37:30,790
0,150 150,210 210,330 330,420 420,510
And we don't have to
我们不用等这些结束，

1234
00:37:30,790 --> 00:37:32,020
0,150 150,240 240,420 420,510 510,1230
wait for these to finish,|
|

1235
00:37:32,080 --> 00:37:33,460
0,210 210,300 300,420 420,720 930,1380
that is we can continue
我们可以在新的打开事务中继续系统调用，

1236
00:37:33,460 --> 00:37:34,720
0,120 120,420 420,750 750,900 900,1260
with system calls in the

1237
00:37:35,050 --> 00:37:36,760
0,300 300,570 570,1200 1200,1440 1440,1710
new open transaction,| while the
|虽然之前仍在写入日志的事务

1238
00:37:36,880 --> 00:37:38,830
0,450 450,1080 1080,1380 1380,1830 1860,1950
previous transactions still writing to

1239
00:37:38,830 --> 00:37:40,870
0,120 120,570 600,930 960,1380 1380,2040
the log| hasn't actually finished,
|还没有完成，仍在提交中。

1240
00:37:41,500 --> 00:37:43,060
0,90 90,480 480,750 1230,1410 1410,1560
{} committing yet.| Of course,
|当然，这个阶段结束，

1241
00:37:43,060 --> 00:37:44,440
0,120 120,420 420,870 870,1080 1080,1380
this stage ends,| when the
|当事务将提交块写入磁盘中的日志时。

1242
00:37:44,680 --> 00:37:46,240
0,540 540,780 780,930 930,1230 1230,1560
transaction writes its commit block

1243
00:37:46,240 --> 00:37:48,010
0,90 90,210 210,750 1110,1290 1290,1770
to the disk, the log.|
|

1244
00:37:48,590 --> 00:37:49,700
0,540

1245
00:37:49,790 --> 00:37:52,130
0,330 330,480 480,810 1110,1590 1620,2340
There can be {} transactions,|
可以存在事务，|

1246
00:37:52,130 --> 00:37:54,440
0,150 150,420 810,1320 1320,1650 1650,2310
that are even older transactions
甚至更旧的事务正在写入，

1247
00:37:54,440 --> 00:37:55,960
0,90 90,240 240,900
that are writing,|
|

1248
00:37:56,250 --> 00:37:57,690
0,330 330,510 510,1080 1080,1350 1350,1440
{} their blocks from the
它们的块缓存到原位置，

1249
00:37:57,690 --> 00:38:00,630
0,810 1470,1590 1590,1680 1680,1860 1860,2940
cache to the home locations,|
|

1250
00:38:01,830 --> 00:38:04,290
0,180 180,630 630,1260 1320,1830 2100,2460
the modified blocks| and {}
修改后的数据块，|最后，没有更多工作，

1251
00:38:04,290 --> 00:38:07,230
0,1020 1980,2340 2340,2580 2580,2760 2760,2940
finally this doesn't take much

1252
00:38:07,230 --> 00:38:08,640
0,240 240,480 570,840 840,990 990,1410
work,| but there can be,
|那么最老的事务可以被释放。

1253
00:38:08,700 --> 00:38:10,380
0,120 120,540 540,1200 1200,1260 1260,1680
the oldest transactions are being

1254
00:38:11,310 --> 00:38:12,560
0,720
freed.|
|

1255
00:38:13,960 --> 00:38:14,950
0,210 210,420 420,630 630,840 840,990
This doesn't really take work
这并不需要工作本身，

1256
00:38:14,950 --> 00:38:17,180
0,750 750,870 870,1170 1170,1650
itself,| the work is,|
|工作是，|

1257
00:38:17,860 --> 00:38:19,810
0,180 180,330 330,780 780,1020 1050,1950
it's really writing {} transactions
它在写事务到它们的原位置，

1258
00:38:19,840 --> 00:38:20,860
0,120 120,240 240,420 450,750 750,1020
to their home, the blocks

1259
00:38:20,860 --> 00:38:22,060
0,60 60,150 150,270 270,900 930,1200
of their home locations,| but
|不管怎样，通常存在多个事务，

1260
00:38:22,060 --> 00:38:24,580
0,210 210,780 780,1140 1140,1500 1500,2520
anyway, there's typically multiple transactions|
|

1261
00:38:25,270 --> 00:38:27,430
0,660 660,900 900,1260 1260,1530 1530,2160
existence in these different stages.|
存在于不同的阶段。|

1262
00:38:28,450 --> 00:38:30,400
0,210 210,480 480,630 630,1290 1470,1950
And so in particular, {}|
所以，特别是，|

1263
00:38:30,520 --> 00:38:32,350
0,630 630,990 990,1230 1230,1380 1380,1830
new system calls can execute
新的系统调用可以在不等待较旧事务的情况下执行，

1264
00:38:32,350 --> 00:38:34,240
0,300 300,600 600,750 750,1020 1020,1890
without waiting for older transactions|
|

1265
00:38:34,240 --> 00:38:35,770
0,150 150,780 810,1110 1110,1440 1440,1530
to either finish committing to
完成对日志的提交，

1266
00:38:35,770 --> 00:38:37,870
0,120 120,600 630,1290 1290,1710 1710,2100
the log| or finish writing
|或完成写入它们的原位置，

1267
00:38:37,870 --> 00:38:39,610
0,180 180,630 630,750 750,900 900,1740
their blocks, their home locations,|
|

1268
00:38:40,180 --> 00:38:41,170
0,120 120,600 600,660 660,840 840,990
in contrast to {xv6 -
与 xv6 不同的是，

1269
00:38:41,170 --> 00:38:42,340
0,330 330,720
-},| where
|新的系统调用必须等待所有完成，

1270
00:38:42,370 --> 00:38:43,600
0,480 480,780 780,960 960,1140 1140,1230
new system calls had to

1271
00:38:43,600 --> 00:38:44,680
0,210 210,300 300,450 450,540 540,1080
wait for this to complete

1272
00:38:44,680 --> 00:38:46,080
0,330 360,810
for all,|
|

1273
00:38:46,710 --> 00:38:48,330
0,150 150,210 210,630 630,990 990,1620
for the one previous transaction.|
对于之前的事务。|

1274
00:38:49,100 --> 00:38:50,000
0,120 120,210 210,270 270,450 450,900
I have a quick question,|
我有一个问题，|

1275
00:38:50,540 --> 00:38:51,620
0,300 300,480 480,660 660,780 780,1080
so how does it work,|
那么它是如何工作的，|

1276
00:38:51,620 --> 00:38:53,510
0,510 510,750 750,900 900,1680 1680,1890
when there's an operation| or
当有操作时，|或者当有东西写入缓存块时，

1277
00:38:53,840 --> 00:38:55,160
0,330 330,630 630,810 810,1140 1140,1320
when something is writing to

1278
00:38:55,160 --> 00:38:56,480
0,150 150,540 540,960 990,1230 1230,1320
a cache block| and the
|而块也在被写入到磁盘中。

1279
00:38:56,480 --> 00:38:57,890
0,300 300,420 420,750 750,1020 1020,1410
block is also being writing

1280
00:38:57,890 --> 00:38:59,140
0,180 180,270 270,810
to the disk.|
|

1281
00:38:59,260 --> 00:39:01,870
0,360 360,540 540,930 1020,1650 2370,2610
Okay, so there's { -},|
好的，所以这，|

1282
00:39:01,870 --> 00:39:02,980
0,150 150,510 510,630 630,1050 1050,1110
so that is indeed a
这确实是个问题，

1283
00:39:02,980 --> 00:39:07,030
0,630 660,1110 1710,2610 3360,3660 3660,4050
problem,| {} and the {
|而且，

1284
00:39:08,400 --> 00:39:09,920
0,900
-},|
|

1285
00:39:10,660 --> 00:39:12,550
0,390 390,660 690,1140 1140,1650 1650,1890
there's a potential difficulty here,|
这里有一个潜在的困难，|

1286
00:39:12,550 --> 00:39:15,640
0,510 1140,1560 1590,2520 2700,2850 2850,3090
because a transaction you know
因为事务写入日志的内容

1287
00:39:15,970 --> 00:39:17,350
0,330 330,450 450,510 510,1140 1140,1380
stuff that a transaction writes

1288
00:39:17,350 --> 00:39:18,430
0,90 90,180 180,510 510,750 750,1080
to the log| should only
|应该仅包括由该事务中的系统调用进行的更新，

1289
00:39:18,430 --> 00:39:20,950
0,570 570,1290 1290,1650 1650,2070 2310,2520
include updates made by a

1290
00:39:20,950 --> 00:39:22,090
0,300 300,720 720,840 840,990 990,1140
system calls that were in

1291
00:39:22,090 --> 00:39:24,550
0,180 180,1080 1320,1770 1770,2130 2130,2460
that transaction,| shouldn't include any
|不应包括其他块更新，

1292
00:39:25,210 --> 00:39:27,220
0,270 270,630 630,1380 1410,1710 1710,2010
any block updates| made by
|由事务后的系统调用所做的，

1293
00:39:27,220 --> 00:39:28,510
0,330 330,630 630,720 720,930 930,1290
system calls that came after

1294
00:39:28,510 --> 00:39:31,780
0,210 210,930 1170,2130 2190,2880 3090,3270
that transaction,| {} because if
|因为如果你这样做了，

1295
00:39:31,780 --> 00:39:33,640
0,90 90,600 630,1050 1050,1230 1230,1860
you did,| {} you risk
|你可能会有提交的风险，

1296
00:39:34,210 --> 00:39:36,820
0,600 840,1260 1260,1470 1470,2460 2460,2610
{} sort of committing,| but
|日志更新只表示了部分系统调用，

1297
00:39:36,820 --> 00:39:39,160
0,330 330,450 450,1080 1110,2130 2160,2340
having the log updates that

1298
00:39:39,160 --> 00:39:42,580
0,270 270,870 930,2160 2160,2550 2550,3420
only represent partial system calls,|
|

1299
00:39:42,790 --> 00:39:44,110
0,540 660,840 840,960 960,1140 1140,1320
{} as we want to
因为我们希望确保

1300
00:39:44,140 --> 00:39:45,520
0,210 210,360 360,510 720,840 840,1380
make sure| that a transaction
|事务只包含所有给定的系统调用更新，

1301
00:39:45,520 --> 00:39:47,020
0,210 210,660 660,1080 1080,1290 1290,1500
only contains all of any

1302
00:39:47,020 --> 00:39:48,680
0,270 270,600 600,1230
given system calls

1303
00:39:49,470 --> 00:39:51,450
0,780 930,1260 1260,1350 1350,1620 1620,1980
updates,| so we can't afford
|所以，我们不能允许事务

1304
00:39:51,450 --> 00:39:53,730
0,60 60,240 240,300 300,1350 1680,2280
to have a transaction| include
|包含事务开始关闭后发生的任何更新，

1305
00:39:53,730 --> 00:39:55,170
0,480 480,750 750,960 960,1320 1320,1440
updates made by anything that

1306
00:39:55,170 --> 00:39:57,780
0,390 390,750 750,870 870,1710 2100,2610
happened after the transaction {}

1307
00:39:57,990 --> 00:40:00,150
0,630 630,720 720,1320 1890,2070 2070,2160
started to close| and the
|ext3 解决它的方法，

1308
00:40:00,150 --> 00:40:01,260
0,210 210,420 420,570 570,750 750,1110
way {ext3 - -} deals

1309
00:40:01,260 --> 00:40:02,200
0,90 90,450
with that,|
|

1310
00:40:02,350 --> 00:40:03,610
0,180 180,360 360,630 720,930 930,1260
{} is that at least
至少在理论上，

1311
00:40:03,610 --> 00:40:04,600
0,510 510,600 600,720 720,900 900,990
{notionally -},| it makes a
|它制作一个副本，

1312
00:40:04,600 --> 00:40:06,730
0,630 930,1080 1080,1320 1530,1980 1980,2130
copy,| when it decides to
|当它决定结束当前打开的事务时，

1313
00:40:06,730 --> 00:40:07,900
0,300 300,510 510,600 600,930 930,1170
wrap up the current open

1314
00:40:07,900 --> 00:40:09,850
0,630 930,1320 1320,1500 1500,1590 1590,1950
transaction,| it makes a copy
|它会复制该事务的所有块，

1315
00:40:09,850 --> 00:40:11,770
0,180 180,510 510,630 630,1560 1590,1920
of all the blocks for

1316
00:40:11,770 --> 00:40:13,210
0,180 180,870 870,1230 1230,1350 1350,1440
that transaction| as of the
|直到它结束该事务为止。

1317
00:40:13,210 --> 00:40:14,410
0,360 360,450 450,870 870,1050 1050,1200
time it closed out this

1318
00:40:14,410 --> 00:40:15,640
0,720
transaction.|
|

1319
00:40:15,730 --> 00:40:16,660
0,330 330,480 480,630 660,870 870,930
{} So it sort of
所以它在某种程度上复制了所有的块，

1320
00:40:16,660 --> 00:40:17,600
0,420
makes

1321
00:40:17,600 --> 00:40:18,530
0,300 300,390 390,510 510,570 570,930
copies of all the blocks|
|

1322
00:40:18,530 --> 00:40:19,580
0,150 150,300 300,450 450,780 780,1050
and then it's though that
然后，通过复制的块，

1323
00:40:19,580 --> 00:40:21,200
0,420 420,510 510,600 600,1170 1350,1620
copy of the blocks| that
|那个事务提交它的日志，

1324
00:40:21,200 --> 00:40:23,600
0,90 90,930 1560,1980 1980,2220 2220,2400
the transaction commits into its

1325
00:40:23,600 --> 00:40:26,330
0,630 960,1170 1170,1380 1380,1650 1650,2730
log| and any newer transactions
|任何较新的事务都有它们自己修改的块副本，

1326
00:40:26,330 --> 00:40:27,960
0,210 210,390 390,1140
have their own

1327
00:40:27,960 --> 00:40:29,070
0,360 360,450 450,630 630,990 990,1110
copy of that block that

1328
00:40:29,070 --> 00:40:30,600
0,120 120,600 600,930
they modify,| it's
|与提交到日志的副本不同。

1329
00:40:30,600 --> 00:40:32,130
0,360 360,690 690,960 960,1140 1140,1530
different copy from {the,moment} committing

1330
00:40:32,130 --> 00:40:34,420
0,90 90,180 180,630
to the log.|
|

1331
00:40:34,570 --> 00:40:35,890
0,360 810,930 930,1080 1080,1140 1140,1320
And in order to make
为了让这个更高效，

1332
00:40:35,890 --> 00:40:37,540
0,150 150,630 630,900 1050,1410 1410,1650
this efficient,| the system actually
|系统使用了写入时复制方案，

1333
00:40:37,540 --> 00:40:38,350
0,210 210,270 270,420 420,480 480,810
uses a kind of {copy-on-write

1334
00:40:38,350 --> 00:40:40,510
0,120 120,270 270,780 780,1050 1470,2160
- -} scheme| to avoid
|避免复制，直到它注意到

1335
00:40:40,810 --> 00:40:41,980
0,390 390,450 450,840 840,1080 1080,1170
making the copies until it

1336
00:40:41,980 --> 00:40:43,270
0,330 330,840 840,960 960,1050 1050,1290
actually notices| that a newer
|更新的事务需要写入那个块。

1337
00:40:43,270 --> 00:40:45,010
0,720 990,1260 1260,1380 1380,1560 1560,1740
transaction needs to write that

1338
00:40:45,010 --> 00:40:45,840
0,420
block.|
|

1339
00:40:46,080 --> 00:40:48,420
0,360 390,690 690,1050
Cool, {that,make} sense.|
酷，理解了。|

1340
00:40:51,730 --> 00:40:53,660
0,540 690,1290
Okay. {}|
好的。|

1341
00:40:54,590 --> 00:40:56,150
0,390 390,540 540,690 690,1080 1170,1560
Good, and so the the
很好，并发可以提高性能的原因，

1342
00:40:56,150 --> 00:40:57,530
0,240 240,480 480,810 810,990 990,1380
reason why concurrency helps performance

1343
00:40:57,530 --> 00:40:59,780
0,420 420,630 630,960 1890,2130 2130,2250
again| is that it can
|它可以帮助我们，

1344
00:40:59,780 --> 00:41:01,550
0,240 240,840 1290,1560 1560,1650 1650,1770
help us,| if we can
|如果我们可以并行运行系统调用，

1345
00:41:01,550 --> 00:41:02,660
0,180 180,450 450,660 660,720 720,1110
run system calls in parallel,|
|

1346
00:41:02,660 --> 00:41:04,670
0,150 150,330 330,630 630,1080 1080,2010
we get {multi-core -} parallelism,|
我们得到了多核并行，|

1347
00:41:04,880 --> 00:41:07,670
0,720 1620,2040 2040,2130 2130,2250 2250,2790
and if we can run
如果我们可以同时运行应用程序和系统调用，

1348
00:41:07,730 --> 00:41:09,680
0,1140 1140,1260 1260,1590 1590,1860 1860,1950
applications and system calls at

1349
00:41:09,680 --> 00:41:10,730
0,60 60,390 390,660 660,780 780,1050
the same time,| we're writing
|我们正在写入磁盘，

1350
00:41:10,730 --> 00:41:11,630
0,90 90,480 480,630 630,750 750,900
a disk,| then we can
|我们可以获得 IO 并发性，

1351
00:41:11,630 --> 00:41:13,700
0,450 570,1140 1140,1440 1440,1890 1890,2070
get {IO,concurrency - -},| that
|它可以在 CPU 之间重叠，

1352
00:41:13,700 --> 00:41:16,520
0,210 210,720 720,1290 1560,2460
is overlap between CPU,|
|

1353
00:41:16,520 --> 00:41:18,890
0,510 510,900 990,1350 1350,1950 1950,2370
and {} CPU execution and
CPU 执行和磁盘 IO 。

1354
00:41:18,890 --> 00:41:20,390
0,630 780,1050 1050,1200 1200,1350 1350,1500
{disk,IO}.| And all these sort
|所有这些帮助，

1355
00:41:20,390 --> 00:41:22,190
0,60 60,600 900,1050 1050,1530 1530,1800
of help,| {} use the
|更有效地利用硬件资源和使用机器。

1356
00:41:22,340 --> 00:41:23,930
0,450 450,960 960,1050 1050,1410 1410,1590
hardware resources, the machine more

1357
00:41:23,930 --> 00:41:25,760
0,540 570,750 750,1380
efficiently, more intensively.|
|

1358
00:41:27,370 --> 00:41:30,070
0,390 390,510 510,930 930,1350 1920,2700
Alright, any questions about concurrency?|
好的，有没有关于并发性的问题？|

1359
00:41:35,810 --> 00:41:37,490
0,300 300,360 360,540 540,1260 1470,1680
Alright, I want to just
好的，我想让你感受一下

1360
00:41:37,490 --> 00:41:38,390
0,90 90,210 210,300 300,840 840,900
give you a taste of|
|

1361
00:41:38,390 --> 00:41:40,370
0,540 690,1080 1080,1410 1410,1710 1710,1980
what the actual file system
实际的文件系统代码，

1362
00:41:40,370 --> 00:41:41,660
0,750 810,960 960,1080 1080,1230 1230,1290
code,| if you look at
|如果你查看文件系统的 Linux 源码，

1363
00:41:41,660 --> 00:41:43,580
0,240 390,900 900,1530 1530,1680 1680,1920
the Linux source for the

1364
00:41:44,100 --> 00:41:46,620
0,270 270,780 1080,1950
file system, {}|
|

1365
00:41:46,990 --> 00:41:48,850
0,360 360,630 630,900 900,1380 1380,1860
sort of somewhat abstract level,|
从抽象的层次，|

1366
00:41:49,300 --> 00:41:50,440
0,240 240,300 300,390 390,780 870,1140
this is the way each
这是每个系统调用的样子。

1367
00:41:50,440 --> 00:41:52,900
0,480 480,810 810,1410 1590,2130 2130,2460
system call looks.| {} So
|你可能有 unlink 系统调用，

1368
00:41:52,990 --> 00:41:54,310
0,270 270,450 450,600 600,930 930,1320
you might have {unlink -}

1369
00:41:54,310 --> 00:41:55,720
0,360 360,870
system call,|
|

1370
00:41:57,710 --> 00:41:58,610
0,180 180,300 300,510 510,630 630,900
and this is you know
这在 xv6 中非常熟悉，

1371
00:41:59,700 --> 00:42:01,880
0,360 360,900 900,1230 1230,1770
pretty familiar from {}

1372
00:42:02,270 --> 00:42:03,920
0,210 210,330 330,840 1080,1440 1440,1650
{xv6 - -},| we need
|每个系统调用需要说，

1373
00:42:03,920 --> 00:42:04,910
0,120 120,360 360,630 630,810 810,990
to every system call needs

1374
00:42:04,910 --> 00:42:06,530
0,120 120,510 540,930 930,1020 1020,1620
to say,| here's the beginning
|这是写入序列的开始，

1375
00:42:06,530 --> 00:42:08,060
0,120 120,210 210,660 660,780 780,1530
of the sequence of writes,|
|

1376
00:42:08,090 --> 00:42:08,840
0,240 240,480 480,540 540,660 660,750
I'm about to do a
我即将执行一系列写入操作，

1377
00:42:08,840 --> 00:42:09,950
0,330 330,420 420,870 870,1020 1020,1110
sequence of writes| and they
|它们需要关于崩溃是原子的。

1378
00:42:09,950 --> 00:42:10,970
0,180 180,270 270,360 360,900 900,1020
need to be atomic with

1379
00:42:10,970 --> 00:42:12,110
0,330 330,390 390,750 750,930 930,1140
respect to crash.| So every
|所以，任何系统调用，

1380
00:42:12,110 --> 00:42:14,510
0,270 270,600 1260,1470 1470,1830 1830,2400
system call,| on any transaction
|

1381
00:42:14,510 --> 00:42:15,470
0,390 390,540 540,720 720,810 810,960
system,| there has to be
|必须有一个清晰的开头和结尾，

1382
00:42:15,470 --> 00:42:16,910
0,330 330,780 780,990 990,1080 1080,1440
a clear sort of begin

1383
00:42:16,910 --> 00:42:19,280
0,600 900,1500 1500,1950 1950,2190 2190,2370
{and,end},| everything between these two
|这两点之间的一切都需要是原子的。

1384
00:42:19,280 --> 00:42:21,680
0,810 960,1650 1650,1740 1740,1830 1830,2400
points needs to be atomic.|
|

1385
00:42:22,270 --> 00:42:24,520
0,450 450,840 840,930 930,1680
And there's a start
这里有一个名为 start 的系统调用，

1386
00:42:25,880 --> 00:42:27,470
0,420 420,540 540,840 840,1230 1230,1590
call the system call code

1387
00:42:27,470 --> 00:42:29,900
0,510
makes,|
|

1388
00:42:30,620 --> 00:42:31,940
0,180 180,270 270,690 690,930 930,1320
and it turns out that,|
事实证明，|

1389
00:42:32,030 --> 00:42:33,260
0,270 270,570 570,750 750,1140 1140,1230
{} {ext3 -} has to
ext3 必须知道处于活动状态的不同系统调用，

1390
00:42:33,260 --> 00:42:34,670
0,120 120,780 780,930 930,1050 1050,1410
be aware of the different

1391
00:42:34,670 --> 00:42:36,350
0,390 390,720 720,840 840,960 960,1680
system calls that are active,|
|

1392
00:42:36,770 --> 00:42:38,300
0,240 240,600 600,810 840,1350 1350,1530
for reasons I'll explain that
原因我会马上解释。

1393
00:42:38,630 --> 00:42:39,500
0,60 60,150 150,450 450,540 540,870
in a minute or two.|
|

1394
00:42:39,710 --> 00:42:41,420
0,450 450,780 840,1230 1230,1560 1560,1710
{} So every system call,|
所以，每个系统调用，|

1395
00:42:41,420 --> 00:42:42,530
0,120 120,180 180,390 390,810 810,1110
when I call start actually
当我调用 start 时，会得到一个所谓的句柄，

1396
00:42:42,530 --> 00:42:43,760
0,240 240,390 390,570 570,630 630,1230
gets what's called a handle,|
|

1397
00:42:44,240 --> 00:42:45,680
0,480 510,810 810,960 960,1050 1050,1440
{} this is a unique
这是这个特定系统调用的唯一标识符，

1398
00:42:45,680 --> 00:42:47,990
0,690 690,840 870,1320 1320,1890 1890,2310
identifier of this particular system

1399
00:42:47,990 --> 00:42:50,600
0,510 930,1410 1440,1800 1860,2280 2280,2610
call,| {} and the writes
|它创建的写入是日志，

1400
00:42:50,600 --> 00:42:52,700
0,180 180,750 750,1170
that {it,makes} are

1401
00:42:52,730 --> 00:42:54,110
0,600 600,690 690,810 810,1080 1080,1380
logging,| {} the file systems
|文件系统用于跟踪，

1402
00:42:54,110 --> 00:42:55,160
0,120 120,360 360,660 660,810 810,1050
{sort,of} {keep,track} of,| yeah that
|那个写入是由这个特定的系统调用完成的，

1403
00:42:55,160 --> 00:42:56,060
0,210 210,360 360,540 540,660 660,900
write was done by this

1404
00:42:56,060 --> 00:42:57,340
0,720
particular

1405
00:42:57,960 --> 00:42:59,610
0,360 360,690 1110,1410 1410,1560 1560,1650
system calls| and then the
|然后系统调用这些读写块，

1406
00:42:59,610 --> 00:43:00,600
0,270 270,420 420,630 630,900 900,990
system call these read and

1407
00:43:00,600 --> 00:43:01,920
0,210 210,930 960,1110 1110,1260 1260,1320
write blocks| and so it
|所以它获得块，

1408
00:43:01,920 --> 00:43:03,450
0,240 240,540 750,1170 1170,1440 1440,1530
makes a get hold of

1409
00:43:03,450 --> 00:43:04,560
0,90 90,600 600,750 750,990 990,1110
a block,| or really a
|或者一个块缓冲器缓存，

1410
00:43:04,920 --> 00:43:08,760
0,600 1290,1830 2100,2640 2670,3150 3150,3840
buffer, a block cache buffer,|
|

1411
00:43:08,910 --> 00:43:10,160
0,330 330,450 450,780
makes it get
调用它，

1412
00:43:10,160 --> 00:43:11,960
0,630 840,990 990,1140 1200,1710 1710,1800
call| and it tells the
|它给出句柄，

1413
00:43:11,960 --> 00:43:13,250
0,630 630,750 750,900 900,960 960,1290
handle| and then the block
|然后是它需要读写的块。

1414
00:43:13,250 --> 00:43:14,180
0,300 300,360 360,600 600,720 720,930
number it needs to read

1415
00:43:14,180 --> 00:43:15,300
0,120 120,510
or write.|
|

1416
00:43:18,090 --> 00:43:18,690
0,240 240,270 270,390 390,540 540,600
Then it may do a
然后它可能会执行大量这样的写入操作。

1417
00:43:18,690 --> 00:43:19,650
0,240 240,330 330,570 570,810 810,960
bunch of these write,| if
|如果你需要修改很多块。

1418
00:43:19,650 --> 00:43:21,390
0,120 120,300 300,540 900,1470 1470,1740
you need to modify many

1419
00:43:21,390 --> 00:43:22,600
0,750
blocks.|
|

1420
00:43:22,600 --> 00:43:25,360
0,480 960,1350 1350,2250 2250,2430 2430,2760
And then modifies, so then
然后修改缓存中的块。

1421
00:43:25,540 --> 00:43:26,500
0,480 480,540 540,840 840,900 900,960
modify the blocks in the

1422
00:43:26,500 --> 00:43:27,660
0,720
cache.|
|

1423
00:43:31,680 --> 00:43:33,720
0,210 210,360 360,600 600,1260 1500,2040
And when it's done,| this,
当它完成时，|这个特定的系统调用完成时，

1424
00:43:33,720 --> 00:43:35,280
0,210 210,570 570,840 840,1140 1140,1560
this particular system calls done,|
|

1425
00:43:35,640 --> 00:43:37,320
0,330 330,630 630,780 780,1170 1170,1680
it makes a stop call,|
它发出一个 stop 调用，

1426
00:43:39,970 --> 00:43:41,410
0,300 300,630 630,720 720,1200 1230,1440
and pass the handle to
并传递句柄给 stop 调用。

1427
00:43:41,410 --> 00:43:43,580
0,270 270,630
stop call.|
|

1428
00:43:45,490 --> 00:43:47,620
0,570 840,1530
So, {}
所以，这些是为了通知日志系统，

1429
00:43:49,330 --> 00:43:49,990
0,120 120,300 300,360 360,480 480,660
a lot of what this

1430
00:43:49,990 --> 00:43:51,820
0,90 90,540 570,930 990,1710 1710,1830
is about is informing the

1431
00:43:51,820 --> 00:43:53,080
0,390 390,750 750,930 930,1050 1050,1260
logging system,| you know once
|一旦系统调用开始，

1432
00:43:53,080 --> 00:43:55,150
0,600 600,870 870,1080 1110,1770 1890,2070
a system call starts,| a
|不允许提交事务，

1433
00:43:55,150 --> 00:43:56,380
0,540 540,630 630,870 870,1140 1140,1230
transaction is not allowed to

1434
00:43:56,380 --> 00:43:58,000
0,600 630,990 990,1230 1230,1320 1320,1620
commit| until all the system
|直到该事务中开始的所有系统调用都已完成。

1435
00:43:58,000 --> 00:43:59,320
0,300 300,450 450,960 960,1140 1140,1320
calls that started in that

1436
00:43:59,320 --> 00:44:02,560
0,660 660,840 840,1650 1860,2340 2490,3240
transaction have finished.| So {}
|因为它们是多个事务，

1437
00:44:02,920 --> 00:44:05,260
0,600 1440,2040 2040,2130 2130,2250 2250,2340
and because they're gonna be

1438
00:44:05,260 --> 00:44:06,860
0,300 300,1230
multiple transactions,|
|

1439
00:44:07,210 --> 00:44:08,410
0,450 450,600 600,900 900,1140 1140,1200
{} the system has to
系统必须能够联系，

1440
00:44:08,410 --> 00:44:09,370
0,90 90,240 240,330 330,750 750,960
be able to associate,| one
|使用句柄的一个原因，

1441
00:44:09,370 --> 00:44:10,000
0,60 60,120 120,420 420,540 540,630
of the reasons for the

1442
00:44:10,000 --> 00:44:11,830
0,540 540,810 810,930 930,1380 1530,1830
handles,| so the system the
|文件系统可以记得

1443
00:44:11,860 --> 00:44:13,210
0,270 270,570 570,750 750,1230 1230,1350
file system can remember| for
|对于每个系统调用是哪个事务的一部分。

1444
00:44:13,210 --> 00:44:14,650
0,150 150,450 450,690 690,840 840,1440
each system call which transaction

1445
00:44:14,650 --> 00:44:16,180
0,60 60,210 210,720 960,1350 1350,1530
it was part of.| So
|所以它知道，哦，这个刚结束，

1446
00:44:16,180 --> 00:44:17,320
0,90 90,450 450,660 660,780 780,1140
it knows, oh and this

1447
00:44:17,320 --> 00:44:20,530
0,180 300,1110 2490,2820 2820,3120 3120,3210
just finishes,| that's one of
|这是特定事务等待的系统调用之一，

1448
00:44:20,530 --> 00:44:21,730
0,90 90,450 450,750 750,810 810,1200
the system calls a particular

1449
00:44:21,730 --> 00:44:23,320
0,510 510,630 630,990 990,1230 1230,1590
transaction was waiting for,| before
|在它可以提交之前。

1450
00:44:23,320 --> 00:44:25,840
0,60 60,210 210,540 540,1050
it could actually commit.|
|

1451
00:44:26,850 --> 00:44:27,960
0,210 210,570 570,660 660,990 990,1110
We pass the handle to
我们将句柄传递给 get 系统调用，

1452
00:44:27,960 --> 00:44:28,920
0,120 120,330 330,630 630,870 870,960
the get system call,| so
|每个事务都有一堆块，

1453
00:44:28,920 --> 00:44:31,500
0,240 840,1320 1320,1710 1740,2040 2040,2580
that every system every transaction

1454
00:44:31,500 --> 00:44:32,670
0,180 180,270 270,600 600,720 720,1170
has a bunch of blocks,|
|

1455
00:44:32,670 --> 00:44:34,590
0,150 150,300 510,1350 1350,1650 1650,1920
that are associated with with
与作为该事务的一部分的被修改的块相关。

1456
00:44:34,590 --> 00:44:35,940
0,360 360,960 960,1080 1080,1290 1290,1350
blocks modified as part of

1457
00:44:35,940 --> 00:44:37,500
0,150 150,870 1200,1350 1350,1470 1470,1560
that transaction.| So what we're
|所以，我们在这里要说的，

1458
00:44:37,500 --> 00:44:39,090
0,300 300,930 930,1260 1260,1380 1380,1590
saying here,| among as well
|除了获得块的指针之外，

1459
00:44:39,090 --> 00:44:40,470
0,180 180,480 480,750 960,1320 1320,1380
as getting a pointer to

1460
00:44:40,470 --> 00:44:41,730
0,90 90,540 600,900 900,990 990,1260
the block| is we're telling
|我们告诉日志系统，

1461
00:44:41,730 --> 00:44:43,170
0,90 90,450 450,780 780,1050 1080,1440
the logging system,| look, this
|这个块编号是这个事务的一部分，

1462
00:44:43,170 --> 00:44:44,970
0,420 420,990 1080,1350 1350,1650 1650,1800
block number is part of

1463
00:44:44,970 --> 00:44:47,310
0,120 120,1080 1080,1440 1500,1830 1830,2340
the transaction,| that this handle
|这个句柄所关联的（事务）。

1464
00:44:47,310 --> 00:44:48,500
0,540 540,780
refers to.|
|

1465
00:44:49,710 --> 00:44:51,080
0,570

1466
00:44:51,110 --> 00:44:52,700
0,480 480,780 780,990 990,1260 1260,1590
This stop call doesn't actually
这个 stop 调用并不会调用提交，

1467
00:44:52,700 --> 00:44:54,200
0,330 330,390 390,870 1140,1320 1320,1500
calls a commit,| it just
|它只是告诉日志系统，

1468
00:44:54,200 --> 00:44:55,670
0,240 240,360 360,690 690,1020 1020,1470
tells that logging system,| look,
|在这个事务中活动的系统调用减少了一个。

1469
00:44:55,880 --> 00:44:57,050
0,150 150,450 540,660 660,750 750,1170
you know you have one

1470
00:44:57,050 --> 00:44:58,430
0,450 450,810 810,1170 1170,1260 1260,1380
fewer system calls that are

1471
00:44:58,430 --> 00:45:01,580
0,780 1500,1710 1710,1860 1860,2610
active in this transaction.|
|

1472
00:45:01,860 --> 00:45:03,180
0,420 450,600 600,720 720,780 780,1320
{} And so a transaction
所以，一个事务可以提交，

1473
00:45:03,180 --> 00:45:04,920
0,150 150,360 360,810 810,1140 1170,1740
can only commit,| if all
|只有这个事务中启动的所有系统调用都调用了 stop 时，

1474
00:45:04,920 --> 00:45:05,790
0,90 90,180 180,480 480,750 750,870
of the system calls that

1475
00:45:05,790 --> 00:45:08,250
0,630 630,720 720,900 900,1740 2040,2460
started in this transaction have

1476
00:45:08,250 --> 00:45:10,200
0,300 300,840 840,1050 1380,1830 1830,1950
called stops,| the transaction has
|事务必须做一些记录，

1477
00:45:10,200 --> 00:45:11,130
0,60 60,180 180,330 330,780 780,930
to do some bookkeeping,| has
|记住开始的所有句柄，

1478
00:45:11,130 --> 00:45:12,300
0,330 330,420 420,540 540,1020 1020,1170
remember all the handles that

1479
00:45:12,300 --> 00:45:13,380
0,540 540,720 720,840 840,930 930,1080
started,| so that it can
|这样，当它们调用 stop 时，可以进行检查。

1480
00:45:13,380 --> 00:45:14,580
0,180 180,300 300,600 600,720 720,1200
sort of check them off

1481
00:45:15,600 --> 00:45:17,680
0,270 270,690 690,990 990,1590
as those calls finish.|
|

1482
00:45:20,440 --> 00:45:22,390
0,390 600,1140 1350,1530 1530,1650 1650,1950
So {} with this structure
所以考虑到这个结构，

1483
00:45:22,390 --> 00:45:23,200
0,240 240,330 330,480 480,600 600,810
{in,mind},| I'm just going to
|我将展示完整的序列，

1484
00:45:23,230 --> 00:45:25,240
0,360 360,630 630,840 840,1260 1260,2010
lay out the complete sequence|
|

1485
00:45:25,240 --> 00:45:27,220
0,900 1080,1260 1260,1350 1350,1770 1770,1980
of what it takes to
提交事务需要什么。

1486
00:45:27,250 --> 00:45:29,050
0,270 270,330 330,1020 1200,1560 1620,1800
commit a transaction.| So you
|所以，在某个时候，当所有的，

1487
00:45:29,050 --> 00:45:30,100
0,90 90,210 210,480 480,870 870,1050
know at some point when

1488
00:45:30,100 --> 00:45:32,200
0,300 300,570 930,1380 1410,1830 1830,2100
all the,| {} every five
|每隔 5 秒，文件系统会考虑，

1489
00:45:32,200 --> 00:45:34,060
0,450 450,720 900,1290 1290,1710 1710,1860
seconds, the file system is

1490
00:45:34,060 --> 00:45:34,780
0,120 120,210 210,360 360,450 450,720
going to think to itself,|
|

1491
00:45:34,780 --> 00:45:35,800
0,210 210,690 690,870 870,960 960,1020
oh, now would be a
哦，现在是提交当前打开的事务的好时机。

1492
00:45:35,800 --> 00:45:36,700
0,150 150,330 330,450 450,810 810,900
good time to commit the

1493
00:45:36,700 --> 00:45:38,420
0,300 300,480 480,1200
current open transaction.|
|

1494
00:45:38,600 --> 00:45:40,340
0,450 540,780 780,1050 1050,1200 1200,1740
And so here's what happens
所以，这是会发生的事，

1495
00:45:40,340 --> 00:45:41,540
0,240 240,480
when the,|
|

1496
00:45:42,180 --> 00:45:43,890
0,360 360,510 510,1110 1110,1290 1560,1710
here's what's involved in the
当文件系统提交事务时。

1497
00:45:43,890 --> 00:45:46,060
0,270 270,750
file system

1498
00:45:46,170 --> 00:45:47,550
0,390 390,480 480,1110 1110,1230 1230,1380
committing a transaction.| So, these
|所以，有这些步骤。

1499
00:45:47,550 --> 00:45:49,240
0,90 90,270 270,1170
are like steps.|
|

1500
00:45:55,810 --> 00:45:57,480
0,390 390,990
So first,
所以，首先，我们必须阻塞所有新的系统调用，

1501
00:45:58,800 --> 00:45:59,850
0,270 270,360 360,480 480,900 900,1050
we have to block any

1502
00:45:59,850 --> 00:46:02,430
0,150 150,510 510,1260 1380,2070 2100,2580
new system calls,| we need
|我们需要让我们的事务只反映整个系统调用，

1503
00:46:02,430 --> 00:46:06,030
0,90 90,810 1440,1770 1770,2730 2790,3600
to have our transaction reflect

1504
00:46:06,890 --> 00:46:08,630
0,360 360,720 720,1200 1200,1530 1530,1740
{} only entire system calls,|
|

1505
00:46:08,630 --> 00:46:09,260
0,90 90,150 150,450 450,570 570,630
so we don't want to
所以我们不想让任何新的开始，

1506
00:46:09,260 --> 00:46:11,540
0,120 120,420 420,660 660,1380 1620,2280
let anything new start, {}|
|

1507
00:46:12,620 --> 00:46:13,970
0,390 390,570 570,810 810,900 900,1350
when we're trying to commit
当我们试图提交事务时，

1508
00:46:13,970 --> 00:46:15,350
0,90 90,930 1050,1170 1170,1320 1320,1380
the transaction,| we want to
|我们希望只包括已经开始的系统调用，

1509
00:46:15,350 --> 00:46:17,060
0,180 180,570 900,1260 1260,1530 1530,1710
only include system calls that

1510
00:46:17,120 --> 00:46:19,280
0,300 300,570 570,1080 1980,2100 2100,2160
have already started,| so you
|所以你需要阻塞新的系统调用。

1511
00:46:19,280 --> 00:46:20,330
0,120 120,210 210,600 600,720 720,1050
need to block new system

1512
00:46:20,330 --> 00:46:21,800
0,690 690,720 720,1020 1020,1230 1230,1470
calls.| {} There's actually another
|还有另一个原因，我要谈一谈，

1513
00:46:21,800 --> 00:46:23,320
0,210 210,270 270,540 540,1020
reason, I'll talk about,|
|

1514
00:46:23,380 --> 00:46:24,520
0,630

1515
00:46:25,630 --> 00:46:26,530
0,270 270,390 390,540 540,630 630,900
why we need to block
为什么我们需要阻塞新的系统调用。

1516
00:46:26,530 --> 00:46:28,100
0,90 90,420 420,1020
new system calls.|
|

1517
00:46:29,980 --> 00:46:30,790
0,180 180,240 240,480 480,540 540,810
This is actually a little
这是一个小的性能缺陷，

1518
00:46:30,790 --> 00:46:32,110
0,120 120,210 210,300 300,840 840,1320
bit of a performance defect,|
|

1519
00:46:32,110 --> 00:46:32,590
0,120 120,240 240,300 300,420 420,480
there's going to be a
这里会有一段时间，

1520
00:46:32,590 --> 00:46:34,510
0,330 330,420 420,720 720,1170 1620,1920
period of time here, {}|
|

1521
00:46:34,510 --> 00:46:36,670
0,900 1350,1590 1590,1860 1860,2040 2040,2160
when {} system calls have
系统调用必须等待并且不允许执行，

1522
00:46:36,670 --> 00:46:37,690
0,90 90,570 660,780 780,840 840,1020
to wait and are not

1523
00:46:37,690 --> 00:46:38,800
0,210 210,270 270,720 750,930 930,1110
allowed to execute,| so that's
|所以那太糟糕了。

1524
00:46:38,800 --> 00:46:39,860
0,150 150,600
too bad.|
|

1525
00:46:40,040 --> 00:46:41,300
0,420 450,540 540,810 810,1080 1080,1260
{} The second step is
第二步是，

1526
00:46:41,300 --> 00:46:42,400
0,270
that,|
|

1527
00:46:42,400 --> 00:46:42,880
0,180 180,210 210,240 240,420 420,480
there are a bunch of
有一些已经启动的系统调用，

1528
00:46:42,880 --> 00:46:44,140
0,300 300,480 480,570 570,810 810,1260
system calls have already started|
|

1529
00:46:44,140 --> 00:46:44,740
0,90 90,180 180,390 390,450 450,600
that are part of this
它们是该事务的一部分，

1530
00:46:44,740 --> 00:46:47,170
0,690 1770,2070 2070,2160 2160,2340 2340,2430
transaction,| that we need to
|我们需要等它们完成，

1531
00:46:47,170 --> 00:46:48,370
0,180 180,270 270,420 420,540 540,1200
wait for them to finish,|
|

1532
00:46:48,610 --> 00:46:49,930
0,540 750,870 870,1020 1020,1080 1080,1320
so we need to wait
所以我们需要等待未完成的系统调用，

1533
00:46:49,930 --> 00:46:53,140
0,870 1440,1590 1590,2190 2190,2490 2490,3210
for the outstanding system calls,|
|

1534
00:46:54,850 --> 00:46:55,960
0,150 150,240 240,360 360,480 480,1110
that are in this transaction.|
它们在这个事务中。|

1535
00:46:59,440 --> 00:47:00,160
0,240 240,300 300,510 510,570 570,720
Because of course we want
因为我们当然希望事务反映它们的所有写入，

1536
00:47:00,160 --> 00:47:01,750
0,90 90,660 660,810 810,1290 1290,1590
the transaction to reflect all

1537
00:47:01,750 --> 00:47:03,490
0,90 90,270 270,990 1470,1650 1650,1740
of their writes,| so we
|所以我们需要等它们完成。

1538
00:47:03,490 --> 00:47:04,000
0,150 150,210 210,360 360,420 420,510
need to wait for them

1539
00:47:04,000 --> 00:47:06,430
0,90 90,660 1170,1650 1830,2340 2340,2430
to finish.| The next thing
|接下来发生的事情是，

1540
00:47:06,430 --> 00:47:07,450
0,90 90,450 450,750 750,900 900,1020
that happens is| you know
|一旦该事务的所有系统调用都完成，

1541
00:47:07,450 --> 00:47:08,530
0,270 270,450 450,540 540,840 840,1080
once all the system calls

1542
00:47:08,530 --> 00:47:10,240
0,120 120,330 330,930 930,990 990,1710
for this transaction are finished,|
|

1543
00:47:10,300 --> 00:47:11,200
0,120 120,300 300,510 510,660 660,900
and have done their writes
并且完成对缓存的写入，

1544
00:47:11,200 --> 00:47:12,340
0,120 120,180 180,660 720,900 900,1140
into the cache,| it turns
|就可以启动新事务，

1545
00:47:12,340 --> 00:47:13,210
0,120 120,300 300,450 450,780 780,870
out then it's okay to

1546
00:47:13,210 --> 00:47:14,350
0,240 240,270 270,420 420,1020 1020,1140
start a new transaction| and
|并让这些被阻塞的系统调用继续进行。

1547
00:47:14,350 --> 00:47:15,760
0,180 180,390 390,810 810,1110 1110,1410
let these blocked system calls

1548
00:47:15,760 --> 00:47:17,560
0,510 780,1020 1020,1410 1440,1680 1680,1800
continue.| So now we're gonna
|所以现在我们要打开一个新的事务，

1549
00:47:17,560 --> 00:47:19,580
0,300 300,390 390,600 600,1530
open a new transaction|
|

1550
00:47:19,580 --> 00:47:22,130
0,510 510,870 900,1140 1140,1560 2010,2550
for these, for any subsequent
为任何后续的系统调，

1551
00:47:22,130 --> 00:47:23,640
0,300 300,990
system calls,|
|

1552
00:47:24,690 --> 00:47:25,940
0,660

1553
00:47:28,710 --> 00:47:30,060
0,270 300,420 420,600 600,1080 1110,1350
{} but now this,| I'm
但是现在，|我继续我们最初的事务，

1554
00:47:30,060 --> 00:47:31,170
0,480 480,570 570,870 870,990 990,1110
continuing the story with our

1555
00:47:31,170 --> 00:47:32,880
0,390 390,990 990,1170 1170,1500 1530,1710
original transaction| which is now
|它现在已经结束。

1556
00:47:32,880 --> 00:47:36,360
0,810 1980,2340 2340,2640 2640,2820 2820,3480
closed.| So remember the log
|所以记住 ext3 中的日志

1557
00:47:36,360 --> 00:47:38,490
0,360 360,780 870,1290 1290,1650 1650,2130
{} in {ext3 -}| contains
|包含描述符、数据块和提交块。

1558
00:47:38,490 --> 00:47:40,020
0,690 690,780 780,1020 1020,1350 1350,1530
descriptors and data blocks and

1559
00:47:40,020 --> 00:47:43,110
0,300 300,990 1830,2070 2070,2580 2700,3090
commit blocks.| So now, {}
|现在，我们知道修改的全部数据块，

1560
00:47:43,110 --> 00:47:44,730
0,180 180,450 450,570 570,930 930,1620
we know the full set

1561
00:47:44,940 --> 00:47:46,720
0,630 660,1350
of {}

1562
00:47:47,200 --> 00:47:49,270
0,510 510,1440 1470,1770 1770,1980 1980,2070
blocks modified| by all the
|这个事务中的所有系统调用（所修改的），

1563
00:47:49,270 --> 00:47:50,080
0,300 300,510 510,600 600,720 720,810
system calls that were in

1564
00:47:50,080 --> 00:47:52,270
0,150 150,930 1350,1950 1950,2070 2070,2190
this transaction,| because they all
|因为它们都使用一个句柄调用了 get ，

1565
00:47:52,270 --> 00:47:53,830
0,300 300,630 630,990 1020,1140 1140,1560
called get with a handle,|
|

1566
00:47:53,830 --> 00:47:54,640
0,210
that
告诉我们是哪个事务的一部分，

1567
00:47:54,730 --> 00:47:56,170
0,300 300,450 450,720 720,870 870,1440
told us about what transactions

1568
00:47:56,170 --> 00:47:57,790
0,60 60,480 750,1230 1320,1500 1500,1620
are part of,| we know
|我们知道该事务的全部修改块，

1569
00:47:57,790 --> 00:47:58,930
0,90 90,390 390,630 630,690 690,1140
the full set of modified

1570
00:47:58,930 --> 00:48:00,610
0,300 300,390 390,570 570,1290 1440,1680
blocks for this transaction,| so
|所以现在我们可以写一个描述符块，

1571
00:48:00,610 --> 00:48:01,390
0,150 150,240 240,390 390,630 630,780
now we can write a

1572
00:48:01,390 --> 00:48:02,860
0,360 360,420 420,960
{descriptor -} block,|
|

1573
00:48:04,510 --> 00:48:05,840
0,690

1574
00:48:05,960 --> 00:48:07,280
0,270 270,510 510,810 810,930 930,1320
that has all the block
有所有块编号，

1575
00:48:07,280 --> 00:48:08,700
0,900
numbers|
|

1576
00:48:09,460 --> 00:48:11,140
0,570 810,1020 1020,1260 1260,1350 1350,1680
{} for all the blocks
对于这个事务的的所有脏块。

1577
00:48:11,140 --> 00:48:13,040
0,360 360,450 450,660 660,1350
dirty to this transaction.|
|

1578
00:48:17,770 --> 00:48:18,790
0,210 210,420 420,540 540,630 630,1020
We're also going to write
我们还将写入修改的块，

1579
00:48:18,790 --> 00:48:21,790
0,630 780,1470 1470,2040 2040,2670 2670,3000
the actual modified blocks| from
|从磁盘缓存到日志中，

1580
00:48:21,790 --> 00:48:24,970
0,450 1260,1650 1650,2340 2400,2910 2940,3180
the disk cache {} into

1581
00:48:24,970 --> 00:48:26,500
0,120 120,630 750,1050 1110,1290 1290,1530
the log| and in fact
|事实上，如果有人问一个问题，

1582
00:48:26,500 --> 00:48:27,610
0,60 60,600 600,870 870,1050 1050,1110
if somebody somebody asks a

1583
00:48:27,610 --> 00:48:28,780
0,390 390,630 630,780 780,900 900,1170
question about,| oh, what happens
|如果下一个事务修改了这个会发生什么，

1584
00:48:28,780 --> 00:48:30,400
0,90 90,150 150,390 390,1110 1140,1620
if the next transaction modifies

1585
00:48:30,400 --> 00:48:31,660
0,120 120,420 420,570 570,900 900,1260
this,| what we're actually writing
|我们在这个阶段实际写入的是

1586
00:48:31,660 --> 00:48:32,920
0,120 120,270 270,720 720,990 990,1260
in this stage is| the
|这个事务块保存的副本，

1587
00:48:32,980 --> 00:48:35,320
0,240 240,300 300,900 900,1710 1710,2340
sort of saved copies of

1588
00:48:35,440 --> 00:48:36,720
0,810
{}

1589
00:48:36,920 --> 00:48:38,540
0,210 210,840 840,1230 1230,1560 1560,1620
this transactions blocks| as of
|在它完成时。

1590
00:48:38,540 --> 00:48:39,920
0,120 120,420 420,600 600,720 720,1380
the time when it finished.|
|

1591
00:48:41,050 --> 00:48:42,560
0,180 180,390 390,930
{So,I'm} gonna write
所以，我要把块写入日志。

1592
00:48:42,730 --> 00:48:44,840
0,210 210,720 1080,1620
the actual {}

1593
00:48:45,100 --> 00:48:46,860
0,510 510,600 600,1140
blocks {to,the} log.|
|

1594
00:48:52,070 --> 00:48:53,920
0,390 540,1290
{} Now,
现在，我们要等这些写入结束，

1595
00:48:54,140 --> 00:48:55,310
0,120 120,330 330,720 720,840 840,1170
we're gonna wait for these

1596
00:48:55,490 --> 00:48:58,000
0,450 450,570 570,1410
writes to finish,|
|

1597
00:49:02,630 --> 00:49:04,640
0,330 330,480 480,570 570,1290 1320,2010
these need to finish {}
这些需要完成，然后我们才能继续。

1598
00:49:05,630 --> 00:49:07,380
0,300 300,420 420,540 540,1200
before we can proceed.|
|

1599
00:49:07,980 --> 00:49:09,000
0,210 210,300 300,870 870,960 960,1020
Once the descriptor and the
一旦确保描述符和数据块在磁盘上，

1600
00:49:09,000 --> 00:49:10,680
0,210 210,570 570,960 990,1620 1620,1680
data blocks are guaranteed to

1601
00:49:10,680 --> 00:49:12,390
0,210 210,480 480,570 570,1290 1320,1710
be on the disk,| then
|然后，我们可以将提交记录写入日志。

1602
00:49:12,390 --> 00:49:13,290
0,90 90,240 240,510 510,570 570,900
we can write the commit

1603
00:49:13,290 --> 00:49:15,200
0,540 570,690 690,780 780,1440
record to the log.|
|

1604
00:49:21,180 --> 00:49:22,230
0,360 360,570 570,750 750,900 900,1050
And once that write is
一旦写入完成，我们就必须等待它完成。

1605
00:49:22,230 --> 00:49:24,750
0,660 1110,1650 2010,2280 2280,2370 2370,2520
finished, we have to wait

1606
00:49:24,750 --> 00:49:26,180
0,120 120,180 180,240 240,870
for it to finish.|
|

1607
00:49:31,420 --> 00:49:32,470
0,180 180,390 390,660 660,780 780,1050
So we're waiting for the
所以我们在等待提交写入完成，

1608
00:49:32,500 --> 00:49:33,520
0,270 270,360 360,450 450,810 810,1020
waiting for the commit write

1609
00:49:33,520 --> 00:49:35,350
0,90 90,510 630,930 930,1230 1230,1830
to finish,| at this point,
|一旦提交写入完成，

1610
00:49:35,440 --> 00:49:36,490
0,360 360,450 450,750 750,900 900,1050
once the commit write is

1611
00:49:36,490 --> 00:49:39,760
0,450 1110,1440 1440,2280 2280,2730 2790,3270
finished,| this transaction,| {} with
|这个事务，|用技术术语来说，

1612
00:49:39,760 --> 00:49:41,020
0,180 210,480 480,540 540,960 960,1260
the sort of technical term

1613
00:49:41,020 --> 00:49:42,490
0,150 150,360 450,750 750,1320 1320,1470
is| that this transaction has
|就是这个事务达到了提交点，

1614
00:49:42,490 --> 00:49:43,960
0,270 270,420 420,750 750,1230 1260,1470
reached its commit point that

1615
00:49:43,960 --> 00:49:45,660
0,570
is,|
|

1616
00:49:46,060 --> 00:49:47,830
0,330 330,1230 1230,1350 1350,1680 1680,1770
it's guaranteed the writes and
在这一点上保证写入和事务在崩溃中幸存下来，

1617
00:49:47,830 --> 00:49:49,450
0,480 480,570 570,1080 1080,1170 1170,1620
transaction are guaranteed to survive

1618
00:49:49,450 --> 00:49:50,530
0,60 60,480 480,540 540,720 720,1080
a crash at this point,|
|

1619
00:49:50,710 --> 00:49:51,610
0,300 300,450 450,540 540,810 810,900
{} if the crash had
如果崩溃发生在写提交块之前，

1620
00:49:51,610 --> 00:49:54,010
0,600 660,1530 1530,1860 1860,2190 2190,2400
occurred before this before writing

1621
00:49:54,010 --> 00:49:55,380
0,90 90,330 330,840
the commit block,|
|

1622
00:49:55,560 --> 00:49:56,640
0,120 120,330 330,390 390,450 450,1080
the writes of the transaction
事务的写入不会出现在崩溃并重启之后，

1623
00:49:56,640 --> 00:49:58,620
0,180 180,570 570,1140 1140,1800 1860,1980
would not appear after a

1624
00:49:58,620 --> 00:50:00,660
0,450 450,600 600,1230 1620,1800 1800,2040
crash and reboot| and running
|并运行恢复软件，

1625
00:50:00,660 --> 00:50:02,070
0,90 90,450 450,1020 1140,1350 1350,1410
the recovery software,| if a
|如果崩溃现在发生，

1626
00:50:02,070 --> 00:50:03,630
0,270 270,570 570,960 960,1260 1260,1560
crash occurs now,| after the
|在提交块已经写入磁盘之后，

1627
00:50:03,930 --> 00:50:05,850
0,480 480,900 900,1170 1170,1440 1620,1920
commit point after the commit

1628
00:50:05,850 --> 00:50:06,540
0,210 210,330 330,510 510,600 600,690
block has written to the

1629
00:50:06,540 --> 00:50:09,360
0,570 990,1560 1800,2190 2190,2310 2310,2820
disk,| {} then they're guaranteed
|然后可以保证

1630
00:50:09,360 --> 00:50:10,460
0,270 270,630
to {}|
|

1631
00:50:10,460 --> 00:50:12,200
0,150 150,630 630,900 900,990 990,1740
those writes all the writes
保证事务中的所有写入

1632
00:50:12,560 --> 00:50:13,940
0,150 150,210 210,840 840,960 960,1380
in the transaction are guaranteed|
|

1633
00:50:13,940 --> 00:50:15,800
0,90 90,600 600,930 930,1440 1440,1860
to appear after crash reboot
在崩溃、重启和恢复之后出现。

1634
00:50:15,800 --> 00:50:17,000
0,150 150,720
and recovery.|
|

1635
00:50:18,010 --> 00:50:20,320
0,330 330,510 510,1170 1500,2070 2070,2310
Okay, and now and only
好的，现在，

1636
00:50:20,320 --> 00:50:22,780
0,600 720,1440 1500,1650 1650,1710 1710,2460
now,| {} in the background,
|所有这些事情都是在幕后发生的，

1637
00:50:22,870 --> 00:50:24,160
0,450 450,660 660,840 840,930 930,1290
all this kind of happened

1638
00:50:24,160 --> 00:50:25,870
0,90 90,150 150,690 690,1020 1020,1710
in the background,| no process
|没有进程在等待这些东西，

1639
00:50:25,870 --> 00:50:26,770
0,150 150,330 330,660 660,750 750,900
was really waiting for this

1640
00:50:26,770 --> 00:50:29,800
0,450 1770,2250 2250,2400 2400,2550 2550,3030
stuff,| now we can write
|现在，我们可以将事务块写入

1641
00:50:29,800 --> 00:50:32,120
0,360 390,1110 1110,1920
the transactions blocks|
|

1642
00:50:32,390 --> 00:50:33,560
0,120 120,270 270,570 570,1110 1110,1170
to their home locations in
它们在文件系统中的原位置。

1643
00:50:33,560 --> 00:50:34,860
0,90 90,360 360,750
the file system.|
|

1644
00:50:40,430 --> 00:50:42,180
0,30 510,1140

1645
00:50:43,540 --> 00:50:46,360
0,570 600,1110 1530,1740 1740,2130 2400,2820
And, {} {I,ll -}  talk
我将在几分钟后讨论，

1646
00:50:46,360 --> 00:50:47,320
0,180 180,240 240,270 270,450 450,960
about in a few minutes|
|

1647
00:50:47,620 --> 00:50:49,690
0,990 990,1320 1320,1410 1410,1740 1740,2070
after all of these writes
在这些写入都完成后，

1648
00:50:49,690 --> 00:50:51,200
0,120 120,930
have completed,|
|

1649
00:50:51,200 --> 00:50:54,200
0,630 1110,1530 1530,1860 1860,2310 2340,3000
{} for all the blocks
作为该事务一部分的所有块，

1650
00:50:54,200 --> 00:50:54,800
0,120 120,180 180,420 420,480 480,600
that are part of this

1651
00:50:54,800 --> 00:50:56,930
0,630 750,1260 1260,1500 1500,1920 1950,2130
transaction,| then only then can
|只有那时，我们才能重用那部分日志。

1652
00:50:56,930 --> 00:50:58,760
0,210 210,1440
we reuse

1653
00:50:58,820 --> 00:51:00,170
0,600 600,840 840,1170 1170,1260 1260,1350
{} that part of the

1654
00:51:00,170 --> 00:51:01,360
0,690
log.|
|

1655
00:51:03,760 --> 00:51:05,020
0,450 480,720 720,780 780,990 990,1260
So in a very busy
所以在一个非常繁忙的系统中，

1656
00:51:05,020 --> 00:51:06,760
0,570 840,1260 1260,1440 1440,1530 1530,1740
system,| {} if the head
|如果日志头赶上了尾，

1657
00:51:06,760 --> 00:51:07,600
0,60 60,150 150,360 360,720 720,840
of the log catches up

1658
00:51:07,600 --> 00:51:08,350
0,90 90,180 180,450 450,570 570,750
with the tail,| there may
|可能无法启动新事务，

1659
00:51:08,350 --> 00:51:09,670
0,510 510,750 750,960 960,1140 1140,1320
actually may not be able

1660
00:51:09,670 --> 00:51:10,960
0,120 120,330 330,360 360,480 480,1290
to start a new transaction|
|

1661
00:51:10,960 --> 00:51:12,460
0,540 570,990 990,1080 1080,1260 1260,1500
until all of these writes
直到最旧的事务的所有这些写入完成，

1662
00:51:12,460 --> 00:51:13,480
0,90 90,510 510,600 600,690 690,1020
have finished for the oldest

1663
00:51:13,480 --> 00:51:15,880
0,660 690,1140 1770,1950 1950,2130 2130,2400
transaction,| because we may need
|因为我们可能需要日志空间，

1664
00:51:15,880 --> 00:51:17,740
0,240 240,630 630,750 750,1020 1410,1860
log space,| so we won't,|
|所以我们不会，|

1665
00:51:17,950 --> 00:51:18,910
0,150 150,270 270,420 420,540 540,960
we may need to reuse
我们可能需要重用最旧的事务日志空间，

1666
00:51:18,910 --> 00:51:20,290
0,90 90,390 390,870 870,1110 1110,1380
the oldest transaction log space,|
|

1667
00:51:20,290 --> 00:51:21,010
0,90 90,210 210,330 330,570 570,720
we have to write for
我们必须进行写入

1668
00:51:21,010 --> 00:51:22,540
0,120 120,360 360,600 870,1410 1410,1530
it to| {} write all
|写入所有缓存块到它们的原位置，

1669
00:51:22,540 --> 00:51:24,040
0,90 90,600 600,930 930,1350 1350,1500
the cache cache blocks {to,their}

1670
00:51:24,040 --> 00:51:27,040
0,180 180,930 1560,2040 2040,2550 2550,3000
home locations,| this usually you
|通常人们尽量把日志做得足够大，

1671
00:51:27,040 --> 00:51:27,850
0,300 300,450 450,540 540,690 690,810
people try to make the

1672
00:51:27,850 --> 00:51:29,560
0,270 270,420 420,690 690,1200 1230,1710
log big enough,| this happens
|这种情况很少发生，

1673
00:51:29,560 --> 00:51:31,870
0,210 210,720 810,1080 1080,1350 1980,2310
pretty rarely,| so that this
|所以，这些东西可以在后台进行。

1674
00:51:31,870 --> 00:51:32,500
0,210 210,330 330,450 450,570 570,630
stuff can go on in

1675
00:51:32,500 --> 00:51:33,240
0,60 60,630
the background.|
|

1676
00:51:35,490 --> 00:51:36,810
0,210 210,480 480,630 630,780 780,1320
Any questions about these steps?|
任何关于这些步骤，有什么问题吗？|

1677
00:51:39,600 --> 00:51:41,280
0,270 270,690 690,1200 1230,1380 1380,1680
Oh, sorry, where are those
哦，抱歉，那些东西在哪里运行？

1678
00:51:41,280 --> 00:51:42,300
0,450
run?|
|

1679
00:51:42,560 --> 00:51:44,960
0,330 330,570 570,870 900,1320 1770,2400
Those what?| We write for
它们什么？|我们写入这些文件系统的东西。

1680
00:51:44,990 --> 00:51:48,290
0,510 510,1110 1830,2160 2160,2730 2760,3300
doing this file system stuff.|
|

1681
00:51:51,480 --> 00:51:52,620
0,450 450,570 570,690 690,900 900,1140
Oh, so you said that
哦，你说没有程序等着这些事情做完，

1682
00:51:52,650 --> 00:51:54,600
0,240 240,780 780,1050 1050,1560 1560,1950
no process is waiting for

1683
00:51:54,630 --> 00:51:57,570
0,630 660,1020 1020,1410 2160,2490 2490,2940
those things to get done,|
|

1684
00:51:57,600 --> 00:52:00,030
0,480 510,1230 1440,2040 2070,2280 2280,2430
so where, where are they
那么它们在哪里运行？

1685
00:52:00,030 --> 00:52:02,160
0,630 630,990 990,1170 1170,1650
scheduled where they run?|
|

1686
00:52:02,520 --> 00:52:05,700
0,810 900,1470 1470,1590 1590,2130 2130,3180
Oh, there's a background thread,|
哦，有一个后台线程，|

1687
00:52:07,270 --> 00:52:08,980
0,150 150,180 180,570 570,960
there's a background thread,
在内核中专门有一个后台线程。

1688
00:52:10,120 --> 00:52:13,150
0,180 180,240 240,510 510,1260 2010,3030
in the kernel dedicated.| {I,see,,thank}
|我明白了，谢谢。

1689
00:52:13,150 --> 00:52:14,120
0,390
you.|
|

1690
00:52:18,500 --> 00:52:20,560
0,300 300,780 780,1530
{I,have} question actually
我有关于重用部分日志的问题，

1691
00:52:20,710 --> 00:52:22,210
0,360 360,900 900,1140 1140,1290 1290,1500
about reusing part of the

1692
00:52:22,210 --> 00:52:24,460
0,720 900,1170 1170,1680
log,| so let's,|
|所以，让我们，|

1693
00:52:24,550 --> 00:52:25,990
0,240 240,390 390,990 990,1110 1110,1440
let's say eventually we start
比如，最终我们开始使用日志的特定部分，

1694
00:52:25,990 --> 00:52:27,910
0,540 540,690 690,1230 1230,1710 1710,1920
using a particular section of

1695
00:52:27,910 --> 00:52:29,120
0,630
log,|
|

1696
00:52:29,880 --> 00:52:31,800
0,390 390,930 1050,1350 1350,1530 1530,1920
and log, the that particular,
而日志那个特定的部分，

1697
00:52:31,800 --> 00:52:33,600
0,390 480,570 570,810 810,1200 1200,1800
as I think just mentioned,|
|

1698
00:52:33,720 --> 00:52:35,400
0,150 150,480 480,720 720,1140
that particular log of
日志的特定部分，

1699
00:52:35,400 --> 00:52:36,690
0,600 600,810 810,900 900,990 990,1290
particular part of the log|
|

1700
00:52:36,690 --> 00:52:39,360
0,960 1380,1620 1620,1770 1770,1950 1950,2670
actually in my new transaction,|
在我的新事务中，|

1701
00:52:39,360 --> 00:52:40,820
0,900
actually,

1702
00:52:41,070 --> 00:52:42,240
0,210 210,330 330,630 630,720 720,1170
end up using the whole
最终使用刚刚被释放的日志部分，

1703
00:52:42,270 --> 00:52:43,800
0,570 570,930 930,1080 1080,1320 1320,1530
log part was just freed

1704
00:52:43,800 --> 00:52:45,570
0,420 450,780 780,1050 1050,1320 1320,1770
up| and there's nothing else,|
|没有其他的了，|

1705
00:52:45,600 --> 00:52:46,940
0,810
there's
没有空间给日志了，

1706
00:52:46,940 --> 00:52:48,380
0,300 300,720 720,870 870,990 990,1440
{no,more} space for the log,|
|

1707
00:52:48,680 --> 00:52:50,600
0,360 360,750 750,1410 1410,1710 1710,1920
what the log, then like
然后系统只是等待，

1708
00:52:50,600 --> 00:52:52,010
0,120 120,210 210,540 540,870 870,1410
with the system just wait|
|

1709
00:52:52,250 --> 00:52:53,680
0,900
until
直到日志的另一部分被释放，

1710
00:52:53,920 --> 00:52:55,360
0,420 420,780 780,1140 1140,1290 1290,1440
the another portion of log

1711
00:52:55,360 --> 00:52:56,710
0,150 150,360 360,810 840,1080 1080,1350
is freed up,| or would
|或者它会做一些其他事情？

1712
00:52:56,710 --> 00:52:58,270
0,90 90,210 210,570 570,1050 1080,1560
it do something else too?|
|

1713
00:52:58,690 --> 00:53:02,740
0,390 390,1440 1470,1740 1740,2400 3150,4050
{} Yes, it'll wait,| let
是的，它会等待，|让我来画一张图，

1714
00:53:02,740 --> 00:53:03,550
0,180 180,420 420,570 570,660 660,810
me though, let me just

1715
00:53:03,550 --> 00:53:05,800
0,150 150,270 270,990 1020,1230 1710,2250
draw a picture| to help
|确定我回答的问题是对的。

1716
00:53:05,800 --> 00:53:06,670
0,90 90,240 240,390 390,480 480,870
me make sure I'm answering

1717
00:53:06,670 --> 00:53:08,590
0,60 60,210 210,600 600,1260 1530,1920
the right question here.| We
|我们可以把日志看作是这条线，

1718
00:53:08,590 --> 00:53:09,460
0,120 120,270 270,330 330,420 420,870
can think of the log

1719
00:53:09,460 --> 00:53:11,180
0,450 630,930 930,1320
as just this

1720
00:53:11,440 --> 00:53:12,100
0,210 210,360 360,540 540,600 600,660
{linear -},| part of the
|是磁盘的一部分，

1721
00:53:12,100 --> 00:53:13,840
0,480 600,840 840,1080 1080,1320 1320,1740
disk| and any given time,|
|在任何给定的时间，|

1722
00:53:13,840 --> 00:53:16,460
0,90 90,390 480,1110 1410,2040
you know maybe {}
也许最老的有效事务是 t7 ，

1723
00:53:16,490 --> 00:53:18,110
0,270 270,360 360,660 660,960 960,1620
maybe the oldest valid transaction

1724
00:53:18,110 --> 00:53:19,940
0,360 360,480 480,630 660,960 960,1830
is you know {t7 -},|
|

1725
00:53:20,180 --> 00:53:22,370
0,660 660,1200 1230,1860 1860,1950 1950,2190
then there's t8 in this
然后这个地区有 t8 ，

1726
00:53:22,370 --> 00:53:24,290
0,840 1320,1470 1470,1590 1590,1710 1710,1920
region| and we have {t9
|然后我们有 t9 ，

1727
00:53:24,290 --> 00:53:26,540
0,840 870,1020 1020,1950 1950,2190 2190,2250
-}| and we want to
|我们想要开始，

1728
00:53:26,540 --> 00:53:27,540
0,510
start,|
|

1729
00:53:27,850 --> 00:53:28,390
0,150 150,240 240,330 330,480 480,540
you know, we want to
我们想把 t10 放在这里。

1730
00:53:28,390 --> 00:53:30,520
0,210 210,450 450,900 900,1620
put {t10 -} here.|
|

1731
00:53:30,520 --> 00:53:31,700
0,600

1732
00:53:33,120 --> 00:53:34,580
0,780
The.|
这个。|

1733
00:53:39,140 --> 00:53:40,850
0,270 270,390 390,630 630,1170 1560,1710
Let's see,| what one you
让我们看看，|首先，我们想开始一个新的事务，把它放在这里。

1734
00:53:40,850 --> 00:53:41,600
0,90 90,210 210,420 420,540 540,750
know we'd like to start

1735
00:53:41,600 --> 00:53:42,650
0,30 30,150 150,810 810,960 960,1050
a new transaction put it

1736
00:53:42,650 --> 00:53:44,720
0,420 660,1440
here. {}|
|

1737
00:53:44,870 --> 00:53:46,140
0,660
The,
我们可能要等待 t7

1738
00:53:46,590 --> 00:53:47,700
0,240 240,570 570,750 750,870 870,1110
we may have to wait

1739
00:53:47,700 --> 00:53:49,440
0,1020
{for,t7}|
|

1740
00:53:49,740 --> 00:53:51,180
0,840
to
把它的所有块写到原位置上，

1741
00:53:51,180 --> 00:53:53,640
0,600 960,1680 1680,1890 1890,2010 2010,2460
{} write all it's blocks

1742
00:53:53,640 --> 00:53:54,810
0,90 90,210 210,420 420,1080 1080,1170
to their home locations,| so
|这样我们才能释放它。

1743
00:53:54,810 --> 00:53:55,890
0,90 90,210 210,360 360,660 660,1080
that we can free it.|
|

1744
00:53:57,100 --> 00:53:58,150
0,240 240,420 420,570 570,780 780,1050
And that may mean that
这可能意味着事务 10 中的东西不得不暂停，

1745
00:53:58,150 --> 00:54:00,280
0,390 540,1230 1260,1590 1590,1650 1650,2130
the transaction stuff in transaction

1746
00:54:00,280 --> 00:54:02,920
0,330 330,480 480,690 690,1350 1560,2640
10 may have to pause,|
|

1747
00:54:03,480 --> 00:54:05,120
0,630 630,1080
waiting for
等待日志中的这些空间释放。

1748
00:54:05,270 --> 00:54:06,290
0,210 210,570 570,630 630,720 720,1020
this space in the log

1749
00:54:06,290 --> 00:54:07,560
0,90 90,390 390,870
to free up.|
|

1750
00:54:08,180 --> 00:54:09,110
0,180 180,300 300,390 390,630 630,930
{Is,that} what you're talking about?|
这是你说的吗？|

1751
00:54:09,710 --> 00:54:11,150
0,270 270,750 750,1020 1020,1230 1230,1440
Yeah, so let's say that,|
是的，这么说吧，|

1752
00:54:11,840 --> 00:54:12,440
0,180 180,270 270,450 450,510 510,600
so it could be the
所以一开始可能是这种情况，

1753
00:54:12,440 --> 00:54:14,300
0,300 300,540 540,600 600,1170 1290,1860
case at the beginning,| {you,I}
|我可以把事务 10 的块放在可用空间中，

1754
00:54:14,510 --> 00:54:15,980
0,330 330,540 540,780 780,1200 1200,1470
can put in blocks for

1755
00:54:15,980 --> 00:54:17,840
0,240 240,810 810,1260 1350,1740 1740,1860
a transaction 10 in the

1756
00:54:17,840 --> 00:54:19,730
0,720 930,1260 1260,1620 1620,1740 1740,1890
actual free space right now,|
|

1757
00:54:19,730 --> 00:54:21,200
0,150 150,930
but eventually,
但是最终，如果日志变得足够大，

1758
00:54:21,230 --> 00:54:22,400
0,180 180,390 390,660 660,840 840,1170
if log grows big enough,|
|

1759
00:54:22,400 --> 00:54:23,150
0,210 210,390 390,510 510,570 570,750
it's just going to run
它就会耗尽空闲空间，

1760
00:54:23,150 --> 00:54:24,440
0,120 120,270 270,660 660,1170 1170,1290
out of free space| and
|在这一点上，

1761
00:54:24,440 --> 00:54:24,980
0,60 60,180 180,330 330,420 420,540
at that point,| it's just
|它需要等待事务 7 。

1762
00:54:24,980 --> 00:54:25,880
0,120 120,180 180,330 330,450 450,900
going to wait for transaction

1763
00:54:25,880 --> 00:54:28,520
0,330 330,960 1290,1920 1980,2160 2160,2640
7 to.| Yes.| Be recorded,
|是的。|被记录下来，好的。

1764
00:54:28,550 --> 00:54:30,230
0,330 330,660 660,1110 1110,1590 1590,1680
okay.| Yes, yes, certainly if
|是的，是的，如果有足够的活动进行，

1765
00:54:30,230 --> 00:54:32,120
0,150 150,540 570,1080 1080,1380 1380,1890
there's enough activity going on|
|

1766
00:54:32,210 --> 00:54:33,380
0,240 240,300 300,630 630,900 900,1170
and the log wraps around
而日志绕回得足够快，

1767
00:54:33,380 --> 00:54:35,000
0,360 360,840 960,1260 1260,1440 1440,1620
quickly enough,| you may end
|你可能不得不等待新的新系统调用，

1768
00:54:35,000 --> 00:54:36,140
0,120 120,360 360,480 480,780 780,1140
up having to wait for

1769
00:54:36,140 --> 00:54:39,500
0,300 570,840 840,1680 2010,2610 2610,3360
a new new system calls,|
|

1770
00:54:41,080 --> 00:54:41,830
0,120 120,210 210,450 450,630 630,750
we may not even be
我们甚至可能无法启动系统调用，

1771
00:54:41,830 --> 00:54:42,850
0,180 180,270 270,600 600,690 690,1020
able to start the system

1772
00:54:42,850 --> 00:54:45,580
0,420 420,810 1920,2340 2340,2460 2460,2730
calls,| because before we can
|在我们释放日志中的空间之前，

1773
00:54:45,580 --> 00:54:46,630
0,300 300,420 420,870 870,960 960,1050
free up space in the

1774
00:54:46,630 --> 00:54:48,160
0,420 420,630 630,930 960,1380 1380,1530
log| for the blocks that
|为它们修改的块。

1775
00:54:48,160 --> 00:54:49,660
0,90 90,210 210,300 300,1020 1200,1500
they're going to modify.| And
|如果你关心这件事的细节，

1776
00:54:50,710 --> 00:54:51,520
0,240 240,360 360,510 510,630 630,810
you know if you care

1777
00:54:51,520 --> 00:54:52,360
0,150 150,210 210,600 600,660 660,840
about the details of this|
|

1778
00:54:52,360 --> 00:54:53,050
0,60 60,300 300,420 420,600 600,690
it turns out there's some
就会发现这里有死锁的可能，

1779
00:54:53,050 --> 00:54:56,260
0,420 420,960 960,1440 1950,2640
potential deadlocks here, {}|
|

1780
00:54:56,510 --> 00:55:00,710
0,450 450,1620 1830,2310 2340,3150 3570,4200
that require that mean {}
意思是 ext3 最终，

1781
00:55:01,250 --> 00:55:03,110
0,450 450,720 720,960 960,1260 1470,1860
{ext3 -} ends up,| system
|系统调用必须预先声明它们将需要多少块，

1782
00:55:03,110 --> 00:55:04,640
0,210 210,390 390,600 690,1050 1050,1530
calls have to pre declare

1783
00:55:04,640 --> 00:55:05,630
0,120 120,330 330,750 750,870 870,990
how many blocks they're going

1784
00:55:05,630 --> 00:55:07,040
0,90 90,690 840,1140 1140,1290 1290,1410
to need,| so that the
|这样日志系统能知道需要多少，

1785
00:55:07,040 --> 00:55:10,250
0,330 330,990 1140,2130 2160,2700 2910,3210
logging system knows {} how

1786
00:55:10,250 --> 00:55:11,300
0,690
much,|
|

1787
00:55:11,300 --> 00:55:13,010
0,360 360,540 540,930 930,1200 1200,1710
you can reason about whether
你可以推论这个事务是否有足够的空间，

1788
00:55:13,010 --> 00:55:14,020
0,390
or

1789
00:55:14,640 --> 00:55:15,990
0,300 300,510 510,1050 1050,1170 1170,1350
there's enough space for this

1790
00:55:15,990 --> 00:55:17,580
0,720 1020,1260 1260,1350 1350,1470 1470,1590
transaction,| because we don't want
|因为我们不想让事务开始，

1791
00:55:17,580 --> 00:55:18,630
0,60 60,360 360,450 450,960 960,1050
to allow a transaction to

1792
00:55:18,630 --> 00:55:20,560
0,690 720,1230
start that,|
|

1793
00:55:20,710 --> 00:55:21,730
0,180 180,480 480,750 750,840 840,1020
we wouldn't actually be able
我们不能提交到日志中。

1794
00:55:21,730 --> 00:55:22,780
0,60 60,330 330,480 480,570 570,1050
to commit into the log.|
|

1795
00:55:26,390 --> 00:55:29,540
0,630 870,1350 1380,2010 2010,2220 2220,3150
Okay.| Let's, let's say,| it's
好的。|假设，|你试图放入的新日志或新事务，

1796
00:55:29,630 --> 00:55:31,340
0,210 240,750 750,1380 1410,1620 1620,1710
the new log or the

1797
00:55:31,340 --> 00:55:32,360
0,150 150,690 690,810 810,960 960,1020
new transaction you're trying to

1798
00:55:32,360 --> 00:55:34,130
0,360 360,600 600,720 720,1170 1380,1770
put,| goes to like 8
|要到事务 8 ，

1799
00:55:34,160 --> 00:55:36,380
0,510 510,690 990,1530 1920,2100 2100,2220
{transaction -} 8,| so you
|所以你必须等待 7 和 8 ，对吧，

1800
00:55:36,380 --> 00:55:37,220
0,90 90,270 270,420 420,660 660,840
will have to wait for

1801
00:55:37,220 --> 00:55:39,320
0,780 780,1170 1170,1590 1620,1950 1950,2100
7 and 8 right,| so
|那么这是怎么运作的？

1802
00:55:39,320 --> 00:55:41,180
0,150 150,300 300,810 840,1380 1410,1860
how does that work?| You
|你的意思是，

1803
00:55:41,180 --> 00:55:42,160
0,480
mean,|
|

1804
00:55:42,920 --> 00:55:44,260
0,270 270,600
okay so,|
好的，|

1805
00:55:44,720 --> 00:55:46,160
0,270 270,450 450,870 870,1140 1140,1440
{it's -} transaction 7 and
事务 7 ，事务 8 和事务 9 ，

1806
00:55:46,160 --> 00:55:47,870
0,540 540,660 660,1260 1260,1620 1620,1710
transaction 8 transaction 9,| at
|至少在这张图中的都必须完成，

1807
00:55:47,870 --> 00:55:48,890
0,180 180,240 240,390 390,900 900,1020
least in this diagram have

1808
00:55:48,890 --> 00:55:50,780
0,270 270,990 1110,1410 1410,1740 1740,1890
all completed| or that all
|或者所有系统调用都已完成。

1809
00:55:50,780 --> 00:55:52,430
0,90 90,450 450,690 690,780 780,1650
the system calls have finished.|
|

1810
00:55:53,180 --> 00:55:55,730
0,660 930,1230 1230,1920 1920,2220 2250,2550
And these transactions are {}
这些事务在日志中提交，

1811
00:55:55,730 --> 00:55:57,080
0,450 450,510 510,630 630,1170 1200,1350
committed in the log,| because
|因为这些是旧事务。

1812
00:55:57,080 --> 00:55:58,610
0,120 120,210 210,330 330,540 540,1530
these are the old transactions.|
|

1813
00:55:59,000 --> 00:56:00,080
0,540
So,
所以，在这张图中，

1814
00:56:00,540 --> 00:56:01,860
0,300 300,540 540,930 930,1020 1020,1320
in this picture,| at least
|我们刚开始事务 10 ，

1815
00:56:01,860 --> 00:56:04,020
0,390 390,690 690,1080 1080,1710 1710,2160
we're just starting transaction 10,|
|

1816
00:56:05,230 --> 00:56:06,460
0,150 150,270 270,540 540,930 930,1230
and so new system calls
所以，新的系统调用将写入事务 10 。

1817
00:56:06,460 --> 00:56:07,210
0,30 30,150 150,240 240,360 360,750
are going to be writing

1818
00:56:07,210 --> 00:56:09,160
0,210 210,360 360,960 960,1350
into a transaction 10.|
|

1819
00:56:11,750 --> 00:56:13,580
0,330 330,510 510,630 630,870 870,1830
Right, but you said that,|
是的，但是你说过，|

1820
00:56:14,460 --> 00:56:16,400
0,510 510,720 720,870 870,1410
transaction 10 is not
事务 10 太大不能放入那个空间，

1821
00:56:16,400 --> 00:56:17,450
0,270 270,540 540,630 630,870 870,1050
big enough to fill that

1822
00:56:17,450 --> 00:56:19,220
0,360 360,480 480,660 660,870 870,1770
space,| so you need to
|所以你需要释放事务 7 ，

1823
00:56:19,430 --> 00:56:22,190
0,660 660,1290 1290,1740 1740,2220 2430,2760
free transactions 7 right,| you
|你需要等待它提交到磁盘中。

1824
00:56:22,190 --> 00:56:23,090
0,150 150,270 270,510 510,630 630,900
need to wait for that

1825
00:56:23,090 --> 00:56:24,860
0,210 210,600 750,1110 1110,1230 1230,1770
to like commit to disk.|
|

1826
00:56:26,200 --> 00:56:28,450
0,1440 1470,1710 1710,1860 1860,2160 2160,2250
Yes.| But what happens if
是的。|但是，会发生什么，

1827
00:56:28,450 --> 00:56:30,040
0,420 420,570 570,1050
you,| if it's,
|如果事务 10 比事务 7 大，

1828
00:56:30,190 --> 00:56:31,690
0,240 240,570 570,720 720,1110 1110,1500
if 10 is like bigger

1829
00:56:31,690 --> 00:56:33,040
0,330 330,690 690,1080 1080,1260 1260,1350
than like 7,| like it
|它要到事务 8 。

1830
00:56:33,040 --> 00:56:34,600
0,240 240,420 420,780 810,1410 1410,1560
goes to 8 transaction.| We
|我们必须等待，

1831
00:56:34,600 --> 00:56:35,740
0,90 90,210 210,390 390,480 480,1140
have to wait for to,|
|

1832
00:56:36,970 --> 00:56:37,990
0,210 210,660 660,780 780,900 900,1020
yeah, we may have to
是的，我们必须等待，

1833
00:56:37,990 --> 00:56:40,180
0,210 210,690 900,1470 1470,1680 1680,2190
wait for,| however big transaction
|不管事务 10 有多大，

1834
00:56:40,180 --> 00:56:42,160
0,300 300,930 1620,1770 1770,1860 1860,1980
10 is,| you know we
|我们需要足够的磁盘空间来容纳它，

1835
00:56:42,160 --> 00:56:43,260
0,510
need,

1836
00:56:43,750 --> 00:56:44,770
0,210 210,390 390,600 600,930 930,1020
we need enough space on

1837
00:56:44,770 --> 00:56:46,330
0,60 60,300 300,390 390,810 1200,1560
the disk to {fit,it}| and
|而不是足够的日志来容纳它，

1838
00:56:46,420 --> 00:56:47,500
0,210 210,630 630,900 900,990 990,1080
not enough space in the

1839
00:56:47,500 --> 00:56:49,000
0,300 300,360 360,750 990,1290 1290,1500
log to {fit,it}| and so
|所以，如果事务 10 很大，

1840
00:56:49,000 --> 00:56:50,410
0,390 390,480 480,930 930,1170 1170,1410
indeed if transaction 10 and

1841
00:56:50,410 --> 00:56:51,940
0,210 210,510 510,690 690,960 960,1530
it turns out being big,|
|

1842
00:56:52,300 --> 00:56:54,370
0,480 480,1290 1410,1650 1650,1740 1740,2070
it may need to force
它可能需要强制多个事务，

1843
00:56:54,370 --> 00:56:56,380
0,450 450,840 960,1620 1680,1860 1860,2010
multiple transactions,| multiple of the
|多个最旧事务写入它们的原位置，

1844
00:56:56,380 --> 00:56:59,360
0,480 480,1410 1890,2490
oldest transactions {}

1845
00:56:59,600 --> 00:57:00,620
0,210 210,540 540,630 630,840 840,1020
to write to their home

1846
00:57:00,620 --> 00:57:03,260
0,660 960,1260 1290,1530 1530,2340 2490,2640
locations| and free themselves.| I
|并释放它们自己。|我猜它的代码是怎么工作的，

1847
00:57:03,260 --> 00:57:04,850
0,210 210,720 750,960 960,1230 1230,1590
guess how, how does code

1848
00:57:04,850 --> 00:57:06,140
0,90 90,390 390,870 900,1140 1140,1290
for that work,| like does
|比如，它是不是查看它有多大，

1849
00:57:06,140 --> 00:57:08,030
0,360 360,810 900,1440 1440,1650 1650,1890
it just run through how

1850
00:57:08,030 --> 00:57:08,870
0,210 210,300 300,510 510,630 630,840
big it is| and like
|这里有一个事务，这里也有一个事务，

1851
00:57:08,870 --> 00:57:10,130
0,210 210,420 420,630 630,720 720,1260
say hey there's a transaction

1852
00:57:10,130 --> 00:57:11,480
0,450 450,570 570,630 630,1140 1140,1350
here and a transaction here|
|

1853
00:57:11,480 --> 00:57:12,140
0,90 90,180 180,390 390,510 510,660
and it's like I have
我必须等待它们两个。

1854
00:57:12,140 --> 00:57:13,100
0,150 150,360 360,600 600,870 870,960
to wait for both of

1855
00:57:13,100 --> 00:57:13,800
0,210
them.|
|

1856
00:57:15,300 --> 00:57:17,860
0,330 330,540 540,810 810,2070
The file system knows,
文件系统知道日志中的所有事务有多大，

1857
00:57:19,390 --> 00:57:20,290
0,330 330,480 480,660 660,840 840,900
knows how big all the

1858
00:57:20,290 --> 00:57:22,000
0,810 810,900 900,960 960,1410 1410,1710
transactions in the log are,|
|

1859
00:57:23,110 --> 00:57:24,880
0,330 360,510 510,1350 1350,1470 1470,1770
and it remembers| and remember
它记得，|记得我的意思是文件系统记得

1860
00:57:24,880 --> 00:57:26,110
0,0 0,270 450,810 810,870 870,1230
I mean actually the {file,system}

1861
00:57:26,110 --> 00:57:27,400
0,330 330,600 600,630 630,930 930,1290
remembers| quite a bit about
|相当多关于每个较旧事务的信息，

1862
00:57:27,400 --> 00:57:28,720
0,180 180,240 240,450 450,690 690,1320
each of these older transactions,|
|

1863
00:57:28,720 --> 00:57:30,250
0,90 90,570 600,840 840,1020 1020,1530
it knows for each one
它知道每一个都是不是可写，

1864
00:57:30,280 --> 00:57:33,430
0,660 660,810 810,1350 2250,2640 2850,3150
whether it's written,| for file
|文件系统跟踪所有这些块

1865
00:57:33,430 --> 00:57:34,750
0,360 390,780 780,1080 1080,1140 1140,1320
system keeps track of for

1866
00:57:34,750 --> 00:57:36,220
0,210 210,540 540,750 750,990 990,1470
every block| in all of
|在每个旧事务中的（块），

1867
00:57:36,250 --> 00:57:37,600
0,240 240,300 300,480 480,660 660,1350
each of these older transactions|
|

1868
00:57:37,600 --> 00:57:38,980
0,630 630,690 690,870 870,1170 1170,1380
whether it has written that
它是否已经把那个块写到原位置，

1869
00:57:38,980 --> 00:57:40,420
0,360 360,450 450,570 570,750 750,1440
block to the home location,|
|

1870
00:57:41,230 --> 00:57:42,490
0,330 330,480 480,600 600,780 780,1260
so that it can know,|
这样它就可以知道，|

1871
00:57:42,490 --> 00:57:44,380
0,570 750,930 930,1410 1440,1620 1620,1890
oh, I've written, it could
哦，我已经写好了，它可以知道是不是。

1872
00:57:44,380 --> 00:57:46,120
0,210 210,510 510,570 570,1200
know whether or not.|
|

1873
00:57:46,360 --> 00:57:47,290
0,150 150,570 570,660 660,870 870,930
And recognize the point at
并识别完成点，

1874
00:57:47,290 --> 00:57:48,400
0,150 150,300 300,750 750,990 990,1110
which is finished| writing all
|写入所有事务 7 的块或事务 8 的块。

1875
00:57:48,400 --> 00:57:49,810
0,90 90,600 600,840 840,1380 1380,1410
the transactions 7 blocks or

1876
00:57:49,810 --> 00:57:51,100
0,570 570,720 720,960 960,1050 1050,1290
transactions 8 blocks.| So there's
|所以这里有相当多的记录，

1877
00:57:51,100 --> 00:57:52,180
0,360 360,390 390,540 540,630 630,1080
quite a lot of bookkeeping

1878
00:57:52,180 --> 00:57:53,500
0,240 240,390 390,690
going on here,|
|

1879
00:57:53,880 --> 00:57:55,410
0,360 360,540 540,840 840,1260 1260,1530
help the file system to
帮助文件系统了解每个旧事务的状态。

1880
00:57:56,090 --> 00:57:58,190
0,690 690,960 960,1440 1440,1620 1620,2100
understand in detail the state

1881
00:57:58,190 --> 00:57:59,420
0,90 90,570
of every

1882
00:57:59,480 --> 00:58:01,040
0,300 300,930
old transaction.|
|

1883
00:58:07,420 --> 00:58:08,580
0,510
Okay.|
好的。|

1884
00:58:09,880 --> 00:58:12,250
0,540 630,930 930,1260 1380,1860 2100,2370
{} Okay, so,| {} indeed
好的，那么，|这是关于如何重用日志空间的主题，

1885
00:58:12,250 --> 00:58:13,930
0,270 270,690 690,1050 1050,1140 1140,1680
there's there's on the topic

1886
00:58:13,930 --> 00:58:15,100
0,300 300,510 510,630 630,960 960,1170
of how to reuse log

1887
00:58:15,100 --> 00:58:16,420
0,270 270,420 420,660 660,870 870,1320
space,| there's one little detail
|这里有一个小细节需要说。

1888
00:58:16,420 --> 00:58:18,220
0,270 270,540 1410,1650 1650,1710 1710,1800
here that needs to be

1889
00:58:18,220 --> 00:58:20,050
0,420 480,810 810,900 900,1500 1530,1830
said.| If you remember, at
|如果你记得，一开始的时候。

1890
00:58:20,050 --> 00:58:21,400
0,90 90,750 750,930 930,1230 1260,1350
the beginning of the.| Let
|让我来写一下图表，

1891
00:58:21,400 --> 00:58:24,400
0,240 690,1140 1140,1260 1260,1560 1560,3000
me, let me writing diagram,|
|

1892
00:58:24,880 --> 00:58:27,640
0,180 180,480 480,810 1680,2220 2220,2760
is actually a super block
是一个超级块，

1893
00:58:27,640 --> 00:58:28,360
0,330
though,|
|

1894
00:58:28,360 --> 00:58:30,220
0,480 540,1170 1170,1500 1500,1800 1800,1860
{} log super block at
日志超级块在日志的开头。

1895
00:58:30,220 --> 00:58:31,420
0,60 60,420 420,510 510,600 600,1200
the beginning of the log.|
|

1896
00:58:32,470 --> 00:58:35,080
0,510 1200,1740 1920,2280 2280,2400 2400,2610
And {} so in any
所以在任何给定的时间里，

1897
00:58:35,080 --> 00:58:35,950
0,210 210,540 540,600 600,750 750,870
given time,| you might have
|你可能会有日志超级块，

1898
00:58:35,950 --> 00:58:37,630
0,150 150,450 450,750 750,1350 1380,1680
the log super block,| and
|然后是一些事务，

1899
00:58:37,630 --> 00:58:39,560
0,390 420,1380
then {}

1900
00:58:39,890 --> 00:58:43,260
0,420 420,660 660,750 750,2010
some set of transactions,|
|

1901
00:58:43,410 --> 00:58:44,670
0,150 150,210 210,510 510,690 690,1260
you know, maybe those transaction
可能事务 4 是最新的事务，

1902
00:58:44,670 --> 00:58:46,800
0,540 540,780 780,1050 1560,1770 1770,2130
4 which is the newest

1903
00:58:46,800 --> 00:58:49,260
0,720 720,840 840,1320 1620,1920 1920,2460
transaction| and then a transaction
|然后是事务 1 ，较旧的事务，

1904
00:58:49,260 --> 00:58:50,720
0,930
1,

1905
00:58:52,170 --> 00:58:53,640
0,90 90,390 390,1200 1200,1320 1320,1470
the older transactions,| so what
|这意味着，

1906
00:58:53,640 --> 00:58:54,600
0,150 150,360 360,510 510,720 870,960
this means is that,| of
|当然，日志是环绕在一起的。

1907
00:58:54,600 --> 00:58:55,590
0,210 210,300 300,570 570,690 690,990
course the log is wrapped

1908
00:58:55,590 --> 00:58:56,800
0,630
around.|
|

1909
00:58:57,110 --> 00:58:58,640
0,510

1910
00:58:59,510 --> 00:59:01,020
0,870

1911
00:59:01,200 --> 00:59:02,700
0,300 300,510 510,630 630,870
And you know the,|
你知道，|

1912
00:59:03,060 --> 00:59:04,340
0,690
yeah,
我们是否可以重复使用一部分日志的规则，

1913
00:59:04,640 --> 00:59:05,540
0,150 150,450 450,570 570,780 780,900
the rule for whether we

1914
00:59:05,540 --> 00:59:06,320
0,150 150,450 450,510 510,720 720,780
could reuse a part of

1915
00:59:06,320 --> 00:59:08,360
0,90 90,660 1410,1590 1590,1740 1740,2040
the log,| now I've mentioned
|我已经提到了，再说一遍，

1916
00:59:08,360 --> 00:59:09,320
0,150 150,630 630,780 780,840 840,960
this {before,,I,just} want to say

1917
00:59:09,320 --> 00:59:10,370
0,90 90,570 630,870 870,960 960,1050
it again| is that we
|我们可以重用日志，

1918
00:59:10,370 --> 00:59:11,660
0,150 150,450 450,570 570,990 990,1290
can reuse the log,| so
|我们就可以重用日志中事务 2 的这一部分，

1919
00:59:11,660 --> 00:59:13,460
0,150 150,270 270,990 1320,1620 1620,1800
we can reuse this part

1920
00:59:13,460 --> 00:59:14,450
0,60 60,120 120,330 330,450 450,990
of the log that transaction

1921
00:59:14,450 --> 00:59:16,100
0,270 270,420 420,690 750,1140 1170,1650
2 is in,| if t2
|如果 t2 已经提交，

1922
00:59:16,100 --> 00:59:18,950
0,150 150,870 1260,1620 1710,2430 2490,2850
has committed| {} and all
|并且所有 t2 的块已写入它们在文件系统中的原位置，

1923
00:59:18,950 --> 00:59:20,120
0,90 90,330 330,660 660,1080 1080,1170
of {t2 -} blocks have

1924
00:59:20,120 --> 00:59:21,080
0,150 150,360 360,450 450,720 720,960
been written to their home

1925
00:59:21,080 --> 00:59:22,850
0,690 690,780 780,870 870,1200 1200,1770
locations in the file system,|
|

1926
00:59:23,600 --> 00:59:24,650
0,240 240,390 510,690 690,810 810,1050
so that there can never
这样在崩溃之后就不需要重播这些块了。

1927
00:59:24,650 --> 00:59:26,270
0,150 150,360 360,990 1260,1590 1590,1620
be any need after a

1928
00:59:26,270 --> 00:59:28,100
0,450 450,1470
crash replay

1929
00:59:28,250 --> 00:59:29,900
0,240 240,1140
these blocks,

1930
00:59:29,900 --> 00:59:30,960
0,480
right.|
|

1931
00:59:31,160 --> 00:59:33,560
0,450 540,1170 1230,1500 1500,1680 1680,2400
{} And if all transactions
并且如果在事务 2 之前的所有事务也被释放。

1932
00:59:33,560 --> 00:59:35,720
0,660 660,810 810,1470 1470,1920 1950,2160
prior to transaction 2 have

1933
00:59:35,720 --> 00:59:37,360
0,300 300,480 480,1170
also been freed.|
|

1934
00:59:37,510 --> 00:59:38,620
0,210 210,420 420,630 630,1020 1020,1110
So if those conditions are
如果这些条件都是真的，

1935
00:59:38,620 --> 00:59:40,450
0,120 120,630 660,1050 1080,1470 1470,1830
all true,| then we can
|然后我们可以释放并重用 t2 所在的那部分日志，

1936
00:59:40,630 --> 00:59:42,250
0,240 240,570 570,720 720,1530 1530,1620
{} free and reuse the

1937
00:59:42,250 --> 00:59:43,000
0,210 210,270 270,360 360,600 600,750
part of the log that

1938
00:59:43,000 --> 00:59:44,890
0,210 210,390 390,750 750,870 1320,1890
{t2 -} sits in, {}|
|

1939
00:59:45,610 --> 00:59:46,630
0,450 480,690 690,780 780,870 870,1020
{} so we can only
所以我们能使用 t2 ，

1940
00:59:46,630 --> 00:59:48,430
0,210 210,420 420,690 690,1230 1380,1800
use {t2 -}| and after
|在 t2 t1 完成提交之后，

1941
00:59:48,430 --> 00:59:49,810
0,210 210,540 540,930 930,1200 1200,1380
{t2 -} is, after {t1

1942
00:59:49,810 --> 00:59:52,000
0,420 420,900 930,1350 1350,1680 1710,2190
-} is finished all committing|
|

1943
00:59:52,000 --> 00:59:53,080
0,90 90,330 330,600 600,960 960,1080
and writing its blocks to
并且写入日志块到原位置中，

1944
00:59:53,080 --> 00:59:54,100
0,360 390,480 480,570 570,780 780,1020
log {} to the home

1945
00:59:54,100 --> 00:59:56,380
0,390 390,810 1110,1530 1530,1890 1890,2280
locations also,| and then this
|然后这个超级块，

1946
00:59:56,650 --> 00:59:59,710
0,660 660,1230 1470,1710 1710,2040 2220,3060
super block,| for the convenience
|为了方便崩溃后的恢复软件，

1947
00:59:59,710 --> 01:00:01,120
0,150 150,390 390,870 870,1200 1200,1410
of the recovery software after

1948
01:00:01,120 --> 01:00:02,710
0,60 60,630 840,1260 1260,1500 1500,1590
a crash,| {} if we
|如果我们决定我们可以，

1949
01:00:02,710 --> 01:00:04,330
0,450 450,600 600,750 750,1050 1470,1620
decide that we can,| if
|如果文件系统决定

1950
01:00:04,330 --> 01:00:05,530
0,150 150,360 360,630 630,1050 1050,1200
the file system decides| it
|它可以释放和重用日志的特定部分，

1951
01:00:05,880 --> 01:00:08,070
0,150 150,840 840,1080 1080,1590 1590,2190
can free and reuse a

1952
01:00:08,070 --> 01:00:09,660
0,420 420,630 630,690 690,780 780,1590
particular part of the log,|
|

1953
01:00:09,960 --> 01:00:11,820
0,450 510,870 870,1410 1410,1500 1500,1860
{} it rewrites the super
它也重写超级块，

1954
01:00:11,820 --> 01:00:14,010
0,480 510,1110 1560,1890 1890,2070 2070,2190
block too,| super block as
|超级块作为第一个事务日志的指针，

1955
01:00:14,010 --> 01:00:15,400
0,90 90,450 450,540 540,870
a pointer to the

1956
01:00:15,400 --> 01:00:18,300
0,360 420,630 630,1290 1500,2340
begin the first {}

1957
01:00:18,360 --> 01:00:21,120
0,810 810,1380 1410,1560 1560,1950 2340,2760
transaction log| and so as
|所以，作为释放部分日志的一部分，

1958
01:00:21,120 --> 01:00:22,290
0,240 240,300 300,900 900,1110 1110,1170
part of freeing part of

1959
01:00:22,290 --> 01:00:24,480
0,90 90,600 870,1200 1200,1650 1650,2190
the log,| file system modifies
|文件系统修改超级块指向

1960
01:00:24,480 --> 01:00:25,620
0,60 60,360 360,750 750,1050 1050,1140
{} super block point to|
|

1961
01:00:25,620 --> 01:00:27,780
0,120 120,690 990,1620 1620,1800 1800,2160
the new beginning of the
日志中当前最旧事务的开始。

1962
01:00:28,290 --> 01:00:30,660
0,150 150,270 270,780 780,1530 1650,2370
of the now oldest transaction

1963
01:00:30,660 --> 01:00:31,820
0,90 90,180 180,690
in the log.|
|

1964
01:00:32,540 --> 01:00:34,380
0,150 150,270 270,570 570,1380
And then there's crash,|
然后发生崩溃，|

1965
01:00:34,740 --> 01:00:36,030
0,210 210,270 270,630 630,1050 1050,1290
at the recovery software reads
恢复软件读取超级块，找到开始的日志。

1966
01:00:36,030 --> 01:00:37,650
0,60 60,360 360,840 1020,1560 1560,1620
the super block, finds the

1967
01:00:37,650 --> 01:00:39,020
0,330 330,900
beginning log.|
|

1968
01:00:42,160 --> 01:00:43,960
0,420 450,840 1350,1560 1560,1710 1710,1800
Okay, so if there's a
好的，如果发生崩溃，|

1969
01:00:43,960 --> 01:00:47,500
0,840 990,1620 1980,2100 2100,2520 3090,3540
crash,| {} of course a
|当然崩溃导致 RAM 中的所有东西都消失了，

1970
01:00:47,500 --> 01:00:48,760
0,810
crash

1971
01:00:48,820 --> 01:00:51,340
0,750 870,1470 1470,1830 1830,1950 1950,2520
{} causes everything in RAM

1972
01:00:51,340 --> 01:00:53,590
0,390 390,1350 1440,1710 1710,1920 1920,2250
to evaporate,| so all that
|所以，所有记录，

1973
01:00:53,590 --> 01:00:54,910
0,630 630,750 750,840 840,1050 1050,1320
bookkeeping| that the file system
|文件系统记录着哪些块已写入原位置，

1974
01:00:54,910 --> 01:00:56,020
0,120 120,420 420,630 630,810 810,1110
is keeping about what blocks

1975
01:00:56,020 --> 01:00:57,700
0,90 90,210 210,840
have been written

1976
01:00:57,790 --> 01:00:58,840
0,150 150,240 240,390 390,870 870,1050
to the home locations,| that's
|如果发生崩溃或停电，这些都会丢失，

1977
01:00:58,840 --> 01:00:59,890
0,240 240,750 750,810 810,990 990,1050
all lost if there's a

1978
01:00:59,890 --> 01:01:02,560
0,510 510,600 600,930 930,1440 1470,2670
crash or power failure,| however
|然而，其中一个假设是

1979
01:01:02,680 --> 01:01:03,550
0,420 420,630 630,750 750,810 810,870
so that one of the

1980
01:01:03,550 --> 01:01:05,050
0,480 480,570 570,810 810,1170 1170,1500
assumptions is| there's nothing useful
|RAM 中没有任何有用的东西，

1981
01:01:05,050 --> 01:01:06,880
0,90 90,600 780,1080 1080,1590 1590,1830
in RAM,| the only stuff
|在崩溃过程中唯一能保存下来的东西是

1982
01:01:06,880 --> 01:01:08,740
0,570 660,870 870,1320
that's can be

1983
01:01:08,800 --> 01:01:10,630
0,420 420,690 690,750 750,1290 1290,1830
preserved across the {crash,is}| whatever's
|磁盘上的任何东西，

1984
01:01:10,630 --> 01:01:13,060
0,120 120,210 210,750 1830,2310 2310,2430
on the disk,| but we
|我们参与了所有这些关于日志的讨论，

1985
01:01:13,060 --> 01:01:15,070
0,330 330,1170 1170,1560 1620,1830 1830,2010
are absolutely in all these

1986
01:01:15,070 --> 01:01:17,200
0,540 540,780 780,1200 1260,1890 1890,2130
discussions about logging,| assuming that
|假设盘完全完好无损，

1987
01:01:17,230 --> 01:01:19,030
0,270 270,600 600,720 720,1140 1140,1800
the disk is completely intact,|
|

1988
01:01:19,030 --> 01:01:20,020
0,180 180,480 480,660 660,870 870,990
that nothing went wrong with
磁盘没有任何问题。

1989
01:01:20,020 --> 01:01:21,160
0,90 90,690
the disk.|
|

1990
01:01:21,190 --> 01:01:22,360
0,480

1991
01:01:22,360 --> 01:01:23,290
0,210 210,390 390,660 660,750 750,930
So, so maybe the right
所以，也许你们应该考虑的正确模型是，

1992
01:01:23,290 --> 01:01:24,100
0,360 360,450 450,510 510,600 600,810
model for you to think|
|

1993
01:01:24,100 --> 01:01:24,820
0,120 120,390 390,480 480,600 600,720
in terms of is that
出现电源故障，

1994
01:01:24,820 --> 01:01:25,840
0,120 120,240 240,300 300,630 630,1020
there was a power failure,|
|

1995
01:01:25,840 --> 01:01:26,920
0,120 120,360 360,510 510,750 750,1080
that everything was humming along
所有的东西都在嗡嗡作响，然后停电了，

1996
01:01:26,920 --> 01:01:27,940
0,90 90,300 300,360 360,690 690,1020
and then the power failed,|
|

1997
01:01:27,940 --> 01:01:28,960
0,90 90,330 330,570 570,930 930,1020
the system just stopped at
系统在某个点上停止了，

1998
01:01:28,960 --> 01:01:30,790
0,210 210,780 1080,1590 1590,1740 1740,1830
some point| {} and the
|在电源恢复后，

1999
01:01:30,790 --> 01:01:32,710
0,330 330,810 1050,1470 1470,1800 1800,1920
disk is after power is

2000
01:01:32,710 --> 01:01:34,300
0,480 480,810 810,1020 1020,1200 1200,1590
restored,| this just has whatever
|这上面有所有东西，

2001
01:01:34,300 --> 01:01:35,530
0,90 90,330 330,510 510,780 1020,1230
it had on it,| at
|在断电时的（东西）。

2002
01:01:35,530 --> 01:01:36,670
0,90 90,360 360,480 480,750 780,1140
the point of the power

2003
01:01:36,670 --> 01:01:37,620
0,450
failure.|
|

2004
01:01:37,620 --> 01:01:40,110
0,150 150,360 360,1290 1440,2010 2010,2490
So we're absolutely not considering
所以我们绝对不会考虑

2005
01:01:40,110 --> 01:01:42,090
0,660 660,720 720,1020 1020,1140 1140,1980
situations| in which the disk
|磁盘不知何故被崩溃损坏或损坏。

2006
01:01:42,330 --> 01:01:45,420
0,660 660,1380 1410,1980 1980,2040 2040,3090
was somehow corrupted or destroyed

2007
01:01:45,720 --> 01:01:47,220
0,240 240,330 330,1080
by the crash.|
|

2008
01:01:47,310 --> 01:01:48,400
0,480

2009
01:01:49,500 --> 01:01:51,160
0,480

2010
01:01:51,740 --> 01:01:52,640
0,180 180,330 330,540 540,810 810,900
And so the crash of
所以崩溃当然可能会中断，

2011
01:01:52,640 --> 01:01:55,740
0,210 210,360 360,1290
course may interrupt,|
|

2012
01:01:55,740 --> 01:01:57,210
0,120 120,450 450,1170 1170,1350 1350,1470
yeah whatever transactions were in
是的，事务正在提交或还没有提交，

2013
01:01:57,210 --> 01:01:58,650
0,60 60,390 390,660 690,1320 1320,1440
the middle of committing are

2014
01:01:58,650 --> 01:02:00,060
0,240 240,450 450,840 840,1170 1170,1410
not yet committing yet| or
|或者不管崩溃打断什么，

2015
01:02:00,330 --> 01:02:02,640
0,420 420,690 960,1470 1470,1590 1620,2310
whatever the crash may interrupt,|
|

2016
01:02:03,000 --> 01:02:04,860
0,540 1110,1440 1440,1500 1500,1770 1770,1860
{} either the commit of
无论是事务的提交

2017
01:02:04,860 --> 01:02:07,260
0,60 60,930 960,1470 1560,1890 1890,2400
a transaction| or the writing
|或者写入事务块到它们的原位置。

2018
01:02:07,260 --> 01:02:09,300
0,150 150,510 540,1290 1290,1860 1860,2040
of a transactions blocks into

2019
01:02:09,300 --> 01:02:12,540
0,180 180,390 390,1260 1830,2220
their home locations.| So,
|所以，这意味着磁盘上的日志，

2020
01:02:12,600 --> 01:02:13,380
0,150 150,270 270,510 510,630 630,780
what that means is that

2021
01:02:13,380 --> 01:02:14,970
0,120 120,360 360,630 630,1320 1410,1590
the on disk log,| when
|当电力恢复，回复运转时，

2022
01:02:14,970 --> 01:02:16,170
0,90 90,450 450,570 570,1080 1080,1200
the power is restored and

2023
01:02:16,170 --> 01:02:17,430
0,390 390,810 810,990 990,1140 1140,1260
recovery sufferers run,| it's going
|它会有一堆旧的完整的事务，

2024
01:02:17,430 --> 01:02:18,570
0,60 60,360 540,720 720,960 960,1140
to have a bunch of

2025
01:02:18,570 --> 01:02:21,480
0,480 480,990 1020,1350 1350,1710 1710,2910
complete transactions, older complete transactions,|
|

2026
01:02:21,600 --> 01:02:22,440
0,180 180,330 330,450 450,630 630,840
{you,know} may be {t1 -}
可能是 t1 和 t2 。

2027
01:02:22,440 --> 01:02:23,740
0,120 120,270 270,720
and {t2 -}.|
|

2028
01:02:24,600 --> 01:02:27,240
0,630 780,1320 1320,1650 2010,2490 2490,2640
{} Let me take a
让我举一个新的例子，用于恢复。

2029
01:02:27,240 --> 01:02:30,060
0,150 150,630 630,1350 2010,2190 2190,2820
new example, for for recovery.|
|

2030
01:02:30,840 --> 01:02:32,100
0,510 510,600 600,720 720,870 870,1260
Let's say we have the
比如我们有一个超级块，

2031
01:02:32,280 --> 01:02:35,040
0,480 480,780 1140,1560 1560,2190
again the super block,|
|

2032
01:02:35,400 --> 01:02:36,680
0,660

2033
01:02:37,470 --> 01:02:39,660
0,870 900,1650
and, {}
而且，也许在崩溃的时候，

2034
01:02:40,040 --> 01:02:40,820
0,300 300,360 360,420 420,720 720,780
maybe at the time of

2035
01:02:40,820 --> 01:02:42,980
0,60 60,600 600,990 1020,1560
the crash,| the {}
|最老的事务是 t6 ，

2036
01:02:43,280 --> 01:02:45,360
0,480 480,1470
oldest transaction

2037
01:02:45,510 --> 01:02:46,640
0,540
{}

2038
01:02:47,430 --> 01:02:48,720
0,240 240,450 450,990 990,1080 1080,1290
was {t6 -}| and then
|然后是 t7 ，

2039
01:02:48,720 --> 01:02:50,070
0,240 240,420 420,990 990,1080 1080,1350
there's {t7 -},| then we
|然后我们绕回来，还在崩溃之前 t8 ，

2040
01:02:50,160 --> 01:02:51,630
0,420 420,840 840,1110 1110,1410 1410,1470
wrapped around still before the

2041
01:02:51,630 --> 01:02:55,020
0,420 420,810 810,1200 2520,2940 3030,3390
crash {t8 -}| and there
|而且这里曾经有一个 t5 ，

2042
01:02:55,020 --> 01:02:58,500
0,720 720,870 870,1170 1170,2250 2640,3480
was a {t5 -}, {}|
|

2043
01:02:59,480 --> 01:03:01,760
0,390 390,870 900,1620 1620,2040 2070,2280
{} but t8 has, let
但是 t8 已经已经重写了 t5 的第一部分，

2044
01:03:01,760 --> 01:03:04,190
0,120 120,870 900,1200 1200,1620 1650,2430
us imagine has started has

2045
01:03:04,670 --> 01:03:05,990
0,630 630,750 750,1050 1050,1230 1230,1320
overwritten the first part of

2046
01:03:05,990 --> 01:03:07,880
0,570 600,900 900,1080 1080,1380 1380,1890
t5,| because {t5 -} was,
|因为我们知道 t5 在崩溃之前已经释放了，

2047
01:03:08,450 --> 01:03:09,560
0,330 330,510 510,660 660,840 840,1110
we know that {t5 -}

2048
01:03:09,560 --> 01:03:10,940
0,150 150,480 480,780 780,870 870,1380
was freed before the crash,|
|

2049
01:03:10,940 --> 01:03:13,070
0,180 1080,1320 1320,1650 1650,1920 1920,2130
but the recovery software doesn't
但是恢复软件不一定知道这一点。

2050
01:03:13,070 --> 01:03:15,740
0,600 600,990 1560,2070
necessarily know that.|
|

2051
01:03:16,650 --> 01:03:19,560
0,420 810,1200 1200,1350 1350,1830 2580,2910
And let's say the super
假设超级块指向 t6 ，

2052
01:03:19,560 --> 01:03:21,210
0,270 270,720 720,990 990,1230 1230,1650
block points to {t6 -}|
|

2053
01:03:21,210 --> 01:03:22,950
0,120 120,360 360,720 1200,1680 1680,1740
as being the start of
作为最老的有效事务的开始，

2054
01:03:22,950 --> 01:03:26,280
0,60 60,540 540,1170 1200,2010 3150,3330
the oldest valid transaction,| {t5
|t5 已经释放。

2055
01:03:26,280 --> 01:03:28,400
0,600 960,1650
-} {is,free}.|
|

2056
01:03:28,490 --> 01:03:31,460
0,660 1680,2430 2430,2580 2580,2640 2640,2970
{} We're going to reboot
我们要重新启动，

2057
01:03:31,460 --> 01:03:32,840
0,90 90,180 180,600 600,1020 1020,1380
with an [attack] disk,| the
|恢复软件读取超级块，

2058
01:03:32,870 --> 01:03:34,100
0,330 330,630 630,840 840,900 900,1230
recovery software reads the super

2059
01:03:34,100 --> 01:03:34,910
0,330 330,420 420,540 540,690 690,810
block| and so then it
|然后，它知道日志的开始位置，

2060
01:03:34,910 --> 01:03:36,860
0,480 480,810 840,1170 1170,1230 1230,1950
knows the where the beginning

2061
01:03:37,100 --> 01:03:38,360
0,120 120,240 240,570 570,900 930,1260
of the log is,| then
|然后恢复软件将在日志中向前扫描，

2062
01:03:38,360 --> 01:03:39,350
0,90 90,390 390,810 810,930 930,990
the recover software's going to

2063
01:03:39,350 --> 01:03:41,420
0,600 600,1230 1230,1320 1320,1410 1410,2070
scan forward in the log|
|

2064
01:03:41,450 --> 01:03:42,350
0,180 180,390 390,510 510,780 780,900
to try to find the
试图找到日志的末尾。

2065
01:03:42,350 --> 01:03:44,040
0,360 360,450 450,570 570,1350
end of the log.|
|

2066
01:03:44,190 --> 01:03:46,320
0,540 1290,1590 1590,1860 1860,1980 1980,2130
{} We need to have
我们需要找到解决问题的方法，

2067
01:03:46,320 --> 01:03:47,640
0,90 90,450 450,630 630,870 870,1320
a way for it, {}|
|

2068
01:03:48,600 --> 01:03:50,040
0,120 120,450 450,780 780,1020 1020,1440
to actually figure out, oh
真正弄清楚日志的末尾，

2069
01:03:50,130 --> 01:03:51,510
0,180 180,480 840,1170 1170,1260 1260,1380
you know that's the end

2070
01:03:51,510 --> 01:03:54,000
0,60 60,180 180,840 930,1560 2070,2490
of the log,| the way
|它做到这一点的方法是，

2071
01:03:54,000 --> 01:03:55,400
0,150 150,450 450,810
it does that

2072
01:03:55,710 --> 01:03:57,300
0,390 630,960 960,1140 1140,1410 1410,1590
is| {} we know that
|我们知道每个事务都包含一个描述符块，

2073
01:03:57,300 --> 01:04:00,210
0,690 1050,1290 1290,2250 2400,2820 2820,2910
every {} transaction consists of

2074
01:04:00,210 --> 01:04:02,370
0,60 60,660 660,1170 1260,1650 1680,2160
a descriptor block| that indicates
|它指示事务上有多少数据块，

2075
01:04:02,370 --> 01:04:03,960
0,330 330,630 630,990 990,1380 1380,1590
how many data blocks are

2076
01:04:03,960 --> 01:04:05,550
0,60 60,150 150,930 1230,1470 1470,1590
on the transaction,| such as
|比如描述符块说有 17 个数据块，

2077
01:04:05,550 --> 01:04:06,600
0,300 300,540 540,750 750,900 900,1050
descriptor blocks says, oh yeah

2078
01:04:06,600 --> 01:04:07,920
0,180 180,630 630,870 870,1230 1230,1320
there's 17 data blocks| and
|我们预计会有 17 个数据块最终提交记录。

2079
01:04:07,920 --> 01:04:09,390
0,90 90,480 480,930 930,1170 1170,1470
we expect 17 data blocks

2080
01:04:09,390 --> 01:04:11,120
0,120 120,480 480,780 780,1320
and finally commit record.|
|

2081
01:04:11,120 --> 01:04:13,250
0,420 930,1110 1110,1230 1230,1620 1620,2130
{} And then another descriptor
然后是另一个描述符记录，

2082
01:04:13,250 --> 01:04:14,930
0,390 390,540 540,990 1080,1440 1440,1680
record| and then the number
|然后描述符块包含的数据块的数量，

2083
01:04:14,930 --> 01:04:16,100
0,90 90,300 300,630 630,1050 1050,1170
of data blocks implied by

2084
01:04:16,100 --> 01:04:17,840
0,90 90,690 690,1230 1350,1620 1620,1740
the descriptor block| and then
|然后是另一个提交块。

2085
01:04:17,840 --> 01:04:20,180
0,270 270,570 570,1080 1320,1830 2160,2340
another commit block.| {} And
|所以，正向扫描中的日志软件，

2086
01:04:20,180 --> 01:04:21,530
0,180 180,540 630,930 930,1260 1260,1350
so the log software in

2087
01:04:21,530 --> 01:04:23,140
0,60 60,390 390,1110
the scan forward,|
|

2088
01:04:23,200 --> 01:04:24,490
0,420 420,720 720,930 930,1200 1200,1290
{} maybe {t6 -} and
可能 t6 和 t7 都没问题，

2089
01:04:24,490 --> 01:04:25,450
0,120 120,390 390,510 510,810 810,960
{t7 -} are fine,| then
|然后它看一下 t8 ， t8 有一些描述符块。

2090
01:04:25,450 --> 01:04:25,990
0,90 90,240 240,300 300,450 450,540
it's going to look at

2091
01:04:25,990 --> 01:04:28,150
0,870 870,1050 1050,1200 1200,1650 1650,2160
{t8,t8} got some descriptor block.|
|

2092
01:04:29,800 --> 01:04:31,240
0,330
And,
然后，恢复软件查找

2093
01:04:31,480 --> 01:04:32,590
0,210 210,300 300,630 630,960 960,1110
then the recovery suffers gonna

2094
01:04:32,590 --> 01:04:35,220
0,180 180,780 780,1320 1320,1830
look forward to {}|
|

2095
01:04:35,540 --> 01:04:37,250
0,450 450,630 630,960 960,1050 1050,1710
where the end of transaction
事务的结尾在哪里，

2096
01:04:37,250 --> 01:04:38,090
0,180 180,360 360,570 570,660 660,840
it should be| and look
|并寻找一个提交块。

2097
01:04:38,090 --> 01:04:39,980
0,360 360,810 900,1290
for a {}

2098
01:04:41,540 --> 01:04:43,670
0,420 420,900 1020,1290 1290,1560 1710,2130
commit block.| And so there's
|所以这里可能发生几件事，

2099
01:04:43,670 --> 01:04:45,110
0,60 60,360 360,690 990,1350 1350,1440
a couple of things that

2100
01:04:45,110 --> 01:04:45,980
0,90 90,180 180,540 540,780 780,870
may have happened here,| it
|可能是事务确实提交了，

2101
01:04:45,980 --> 01:04:48,100
0,180 180,390 390,690 1020,1530
could be that {}

2102
01:04:48,720 --> 01:04:49,920
0,450 450,540 540,750 750,1080 1080,1200
transaction it did commit| and
|恢复软件找到提交块，

2103
01:04:49,920 --> 01:04:51,390
0,270 270,600 600,930 930,1230 1230,1470
that the recovery software finds

2104
01:04:51,390 --> 01:04:54,090
0,90 90,330 330,840 1650,2160 2160,2700
the commit block,| it'll then
|然后它会寻找另一个，

2105
01:04:54,540 --> 01:04:56,550
0,420 420,600 600,1530 1830,1950 1950,2010
look for another,| you know
|它不知道事务是最后一个事务，

2106
01:04:56,550 --> 01:04:58,320
0,90 90,390 390,720 720,990 1260,1770
it doesn't know that transaction

2107
01:04:58,320 --> 01:05:00,420
0,210 210,450 450,1560 1710,2040 2040,2100
is last transactions| needs to
|需要找出这一点，

2108
01:05:00,420 --> 01:05:01,470
0,240 240,420 420,660 660,870 870,1050
figure that out,| so it's
|所以，它查找接下来的一个块，

2109
01:05:01,470 --> 01:05:02,160
0,120 120,180 180,540 540,600 600,690
going to look at the

2110
01:05:02,160 --> 01:05:04,290
0,270 270,540 540,1230 1380,1650 1650,2130
very next block| to see
|查看这是否是有效的描述符块，

2111
01:05:04,320 --> 01:05:05,860
0,390 390,1200
if this

2112
01:05:05,860 --> 01:05:07,570
0,150 150,210 210,660 660,1170 1170,1710
is a valid descriptor block,|
|

2113
01:05:08,620 --> 01:05:10,690
0,480 720,1410 1440,1740 1740,1920 1920,2070
{} now we know that
我们知道这个块只是一个随机的块，

2114
01:05:10,690 --> 01:05:11,710
0,180 180,420 420,540 540,750 750,1020
this block was really just

2115
01:05:11,740 --> 01:05:12,970
0,120 120,750 750,1080 1080,1170 1170,1230
a random block| in the
|在事务 5 中，

2116
01:05:12,970 --> 01:05:14,170
0,210 210,270 270,810 810,1110 1110,1200
middle of transaction 5| and
|完全不是描述符块，

2117
01:05:14,170 --> 01:05:15,160
0,210 210,300 300,660 660,720 720,990
not a {descriptor -} block

2118
01:05:15,160 --> 01:05:16,570
0,120 120,510 750,1050 1050,1110 1110,1410
at all,| then the question
|那么问题是

2119
01:05:16,570 --> 01:05:18,400
0,120 120,390 390,660 660,1050 1380,1830
is| how can the recovery
|恢复软件如何能够可靠地区分，

2120
01:05:18,400 --> 01:05:20,500
0,360 360,990 990,1530 1530,1950 1950,2100
software reliably distinguish between,| oh,
|这是一个数据块，

2121
01:05:20,500 --> 01:05:21,720
0,210 210,420 420,690
this is a,

2122
01:05:21,780 --> 01:05:23,520
0,240 240,450 450,690 690,1230 1590,1740
just some data block| in
|在旧事务中间，

2123
01:05:23,520 --> 01:05:24,150
0,60 60,270 270,360 360,450 450,630
the middle of an old

2124
01:05:24,150 --> 01:05:26,730
0,660 660,1260 1380,1740 1740,2070 2310,2580
transaction| or it's the maybe
|或者是事务 9 的描述符块。

2125
01:05:26,730 --> 01:05:28,500
0,90 90,600 600,990 990,1200 1200,1770
the descriptor block for transaction

2126
01:05:28,500 --> 01:05:29,520
0,450
nine.|
|

2127
01:05:30,850 --> 01:05:32,620
0,270 270,690 690,960 960,1230 1260,1770
Any guesses for a reliable
有人知道有什么可靠的方法，可以做到这个吗？

2128
01:05:32,620 --> 01:05:34,150
0,360 360,450 450,570 570,870 1350,1530
method to do that?| Is
|是魔术数吗？

2129
01:05:34,150 --> 01:05:36,580
0,210 210,270 270,780 780,1380 1890,2430
that the magic number.| Yeah.|
|是的。|

2130
01:05:36,580 --> 01:05:37,480
0,240 240,360 360,510 510,780 780,900
Or is there just a
还是有一个保留位。

2131
01:05:37,480 --> 01:05:38,820
0,480 480,810
reserved bit.|
|

2132
01:05:39,110 --> 01:05:40,940
0,330 330,480 480,870 870,1410 1410,1830
There is indeed,| every {}
的确，|每个描述符提交块都以某个魔术数开头，

2133
01:05:41,000 --> 01:05:42,650
0,510 510,810 810,1140 1140,1500 1500,1650
descriptor commit block starts with

2134
01:05:42,650 --> 01:05:45,560
0,510 1590,1980 1980,2400 2430,2730 2730,2910
some magic number,| just just
|只是一个 32 位的值，

2135
01:05:45,560 --> 01:05:46,790
0,60 60,480 480,630 630,1020 1020,1230
a 32 bit value,| that
|这是恢复软件寻找的，

2136
01:05:46,790 --> 01:05:48,020
0,150 150,540 540,900 900,990 990,1230
the recovery software is looking

2137
01:05:48,020 --> 01:05:49,100
0,270 450,630 630,780 780,990 990,1080
for,| I don't actually know
|我其实不知道是什么。

2138
01:05:49,100 --> 01:05:51,290
0,90 90,240 240,690 690,930 1680,2190
what it is.| {} So,
|所以，游戏肯定是

2139
01:05:51,560 --> 01:05:52,660
0,540
{}

2140
01:05:52,750 --> 01:05:53,950
0,360 360,480 480,750 750,900 900,1200
definitely the game is| that
|我们到了事务 8 的末尾，

2141
01:05:54,280 --> 01:05:54,970
0,150 150,360 360,420 420,540 540,690
we come to the end

2142
01:05:54,970 --> 01:05:55,990
0,60 60,600 600,810 810,930 930,1020
of transaction 8,| if the
|如果下一个块以魔术数开头，

2143
01:05:55,990 --> 01:05:57,550
0,270 270,540 540,870 870,1440 1440,1560
very next block starts with

2144
01:05:57,550 --> 01:05:59,800
0,90 90,450 450,960 1320,1740 1950,2250
the magic number,| {} then
|然后恢复软件会假设，

2145
01:05:59,800 --> 01:06:01,480
0,90 90,450 450,900 900,1260 1260,1680
the recovery software's gonna assume

2146
01:06:01,480 --> 01:06:02,620
0,330 420,600 600,840 840,1080 1080,1140
that,| oh this is a
|哦，这是一个有效的描述符块。

2147
01:06:02,620 --> 01:06:04,240
0,300 300,750 750,1200
valid descriptor block.|
|

2148
01:06:06,200 --> 01:06:09,110
0,450 480,1020 1890,2250 2250,2430 2430,2910
{} {Could,you}, sorry, quick question,|
你能不能，抱歉，有个问题，|

2149
01:06:09,350 --> 01:06:11,030
0,510 540,720 720,840 840,990 990,1680
{} would it be unreliable|
它是不是不可靠的，|

2150
01:06:11,030 --> 01:06:13,970
0,150 150,480 480,1140 1380,1890 2310,2940
to try to like, {}
它理解为一个描述符块，

2151
01:06:14,060 --> 01:06:17,030
0,480 480,660 660,1200 1200,1860 1950,2970
interpret it as a descriptor

2152
01:06:17,030 --> 01:06:18,080
0,330 360,600 600,750 750,960 960,1050
block,| try to read the
|尝试读取指定它们的数据块的数量，

2153
01:06:18,080 --> 01:06:20,240
0,450 450,1020 1080,1500 1500,1950 1950,2160
number of data blocks that

2154
01:06:20,240 --> 01:06:21,710
0,750 750,930 930,1140 1140,1350 1350,1470
specifies them,| like see if
|比如，查看是否在指定的位置有提交块，

2155
01:06:21,710 --> 01:06:23,300
0,210 210,300 300,630 630,1170
there's a commit block

2156
01:06:23,300 --> 01:06:25,820
0,180 180,270 270,1050 1050,1770 2220,2520
at the expected location| after
|在一定数量的块之后。

2157
01:06:25,820 --> 01:06:27,240
0,90 90,330 330,390 390,900
the number of blocks.|
|

2158
01:06:27,630 --> 01:06:29,370
0,600 660,1110 1110,1440 1440,1560 1560,1740
{} Well, certainly if this
当然，如果这个日志看起来像一个描述符块，

2159
01:06:29,370 --> 01:06:30,150
0,210 210,450 450,600 600,720 720,780
log does look like a

2160
01:06:30,150 --> 01:06:32,580
0,450 450,1080 1350,1710 1710,1800 1800,2430
descriptor block,| then it will
|那么它会继续，

2161
01:06:32,580 --> 01:06:33,780
0,330 330,750 750,870 870,1050 1050,1200
skip forward| and try to
|并尝试读取对应的提交块，

2162
01:06:33,780 --> 01:06:35,490
0,270 270,330 330,900 900,1200 1200,1710
read the corresponding commit block,|
|

2163
01:06:35,880 --> 01:06:36,720
0,180 180,270 270,420 420,660 660,840
and if that commit block
如果提交块看起来不是提交块，

2164
01:06:36,720 --> 01:06:37,650
0,270 270,450 450,600 600,660 660,930
doesn't look like a commit

2165
01:06:37,650 --> 01:06:38,520
0,240 240,330 330,390 390,540 540,870
block| with the right magic
|有正确魔术数，

2166
01:06:38,520 --> 01:06:40,170
0,330 330,420 420,780 930,1320 1320,1650
number,| it will not believe
|它不会认为在这个事务中。

2167
01:06:40,170 --> 01:06:41,460
0,90 90,210 210,840
in this transaction.|
|

2168
01:06:43,760 --> 01:06:45,500
0,240 240,510 720,990 1080,1290 1530,1740
The the the the the
这里剩下的一点细节就是，

2169
01:06:45,500 --> 01:06:47,090
0,180 180,360 360,690 930,1320 1320,1590
thing that's {} one little

2170
01:06:47,090 --> 01:06:48,800
0,570 570,990 990,1290 1290,1410 1410,1710
remaining detail here is that,|
|

2171
01:06:48,920 --> 01:06:50,750
0,810 810,1290 1290,1380 1380,1500 1500,1830
this block that we're looking
我们查找的块，

2172
01:06:50,750 --> 01:06:52,070
0,180 180,420 420,540 540,720 720,1320
at here and we're wondering|
|

2173
01:06:52,070 --> 01:06:52,900
0,90 90,240
or the
或者恢复软件怀疑的，

2174
01:06:53,020 --> 01:06:54,730
0,330 360,720 720,1110 1110,1560 1560,1710
{} recovery software wondering,| if
|这是否是描述符块，

2175
01:06:54,730 --> 01:06:56,770
0,150 150,480 570,1050 1050,1440 1620,2040
it's a descriptor block,| this
|这可以是事务 5 中间的块，

2176
01:06:56,770 --> 01:06:58,930
0,450 450,960 990,1500 1530,1770 1770,2160
could be just a block

2177
01:06:58,930 --> 01:06:59,620
0,210 210,270 270,360 360,600 600,690
right in the middle of

2178
01:06:59,620 --> 01:07:02,350
0,570 570,900 900,1500 1890,2190 2190,2730
transaction 5| containing any arbitrary
|包含任意位模式，

2179
01:07:02,350 --> 01:07:04,270
0,240 240,840 1380,1560 1560,1770 1770,1920
bit pattern,| it could be
|它可能就是文件中的数据块，

2180
01:07:04,270 --> 01:07:05,620
0,360 390,600 600,780 780,1080 1080,1350
just like the data block

2181
01:07:05,620 --> 01:07:06,520
0,150 150,270 270,570 570,690 690,900
from a file,| that just
|恰好是从这个神奇的数字开始的。

2182
01:07:06,520 --> 01:07:07,870
0,630 630,720 720,1140 1140,1260 1260,1350
happens to begin with the

2183
01:07:07,870 --> 01:07:09,160
0,390 390,960
magic number.|
|

2184
01:07:09,400 --> 01:07:10,800
0,420

2185
01:07:10,940 --> 01:07:12,140
0,480 750,930 930,1020 1020,1110 1110,1200
So you know as a
所以，作为最后的细节，

2186
01:07:12,140 --> 01:07:14,240
0,330 330,780 780,990 1350,1800 1800,2100
final detail,| the logging system
|日志记录系统需要能够区分

2187
01:07:14,240 --> 01:07:15,110
0,390 390,540 540,660 660,810 810,870
needs to be able to

2188
01:07:15,110 --> 01:07:17,000
0,540 540,960 960,1050 1050,1470 1470,1890
distinguish| between a valid descriptor
|以魔术数开头的有效描述符块，

2189
01:07:17,000 --> 01:07:17,930
0,270 270,390 390,690 690,810 810,930
block that starts with this

2190
01:07:17,930 --> 01:07:20,300
0,360 360,810 840,1530 1620,2100 2100,2370
magic number| and just some
|还是一些以魔术数开头的数据块。

2191
01:07:20,300 --> 01:07:22,070
0,300 300,780 1110,1290 1290,1620 1620,1770
data block that starts with

2192
01:07:22,070 --> 01:07:23,400
0,60 60,420 420,840
the magic number.|
|

2193
01:07:23,490 --> 01:07:24,580
0,540

2194
01:07:24,920 --> 01:07:26,720
0,330 360,660 660,750 750,1290 1410,1800
And you can imagine various
你可以想象不同的方式来做到这一点，

2195
01:07:26,720 --> 01:07:27,830
0,210 210,270 270,510 510,750 900,1110
ways of doing that,| in
|在 ext3 所做的是，

2196
01:07:27,830 --> 01:07:29,900
0,420 450,1080 1080,1470 1470,1710 1710,2070
fact, what {ext3 -} does

2197
01:07:29,900 --> 01:07:31,190
0,540 600,990 990,1080 1080,1200 1200,1290
is,| whenever it's going to
|当它要向日志中写入块时，

2198
01:07:31,190 --> 01:07:32,000
0,240 240,300 300,630 630,720 720,810
write a block to the

2199
01:07:32,000 --> 01:07:33,350
0,390 390,600 600,840 840,900 900,1350
log,| that's not a descriptor
|这不是一个描述符块或提交块，

2200
01:07:33,350 --> 01:07:34,970
0,420 420,510 510,810 810,1230 1290,1620
block or commit block,| if
|如果块以魔术数开头，它将其替换为零，

2201
01:07:34,970 --> 01:07:35,930
0,180 180,450 450,750 750,870 870,960
that block starts with the

2202
01:07:35,930 --> 01:07:37,790
0,390 390,900 960,1230 1230,1680 1680,1860
magic number, it replaces that

2203
01:07:37,790 --> 01:07:40,430
0,90 90,780 1050,1410 2100,2580 2580,2640
with zero| and sets a
|并在该事务描述符块中设置与该块对应的位，

2204
01:07:40,430 --> 01:07:42,020
0,420 420,990 990,1050 1050,1200 1200,1590
bit corresponding to that block

2205
01:07:42,050 --> 01:07:44,330
0,420 420,630 630,1200 1200,1740 1740,2280
in that transaction descriptor block,|
|

2206
01:07:44,390 --> 01:07:46,850
0,240 240,420 420,660 660,1260 2220,2460
then that bit means this
这个位意味着这个特殊的数据块

2207
01:07:46,850 --> 01:07:49,550
0,480 480,780 780,1440 2130,2580 2580,2700
particular data block| started with
|以魔术数开始，我们用零代替它。

2208
01:07:49,550 --> 01:07:50,420
0,60 60,390 390,660 660,780 780,870
the magic number and we

2209
01:07:50,420 --> 01:07:51,880
0,420 420,510 510,600 600,1080
replace it with zero.|
|

2210
01:07:52,130 --> 01:07:53,360
0,360 360,540 540,720 720,840 840,1230
{} And then if the
如果恢复软件需要重放那个块，

2211
01:07:53,420 --> 01:07:54,800
0,390 390,750 750,870 870,1080 1080,1380
recovery software ever needs to

2212
01:07:54,920 --> 01:07:56,540
0,480 480,690 690,1230 1260,1440 1440,1620
replay that block,| so let's
|我们假设事务 8 有一个这样的块，

2213
01:07:56,540 --> 01:07:57,800
0,210 330,840 840,990 990,1110 1110,1260
say transaction 8 had one

2214
01:07:57,800 --> 01:07:59,600
0,60 60,210 210,630 630,810 1140,1800
of these blocks,| that originally
|它最初是以魔术数开始的，

2215
01:07:59,600 --> 01:08:00,590
0,300 300,390 390,450 450,750 750,990
started with the magic number,|
|

2216
01:08:00,590 --> 01:08:01,280
0,90 90,210 210,270 270,570 570,690
it's going to set the
它将设置这个魔术标志位，

2217
01:08:01,280 --> 01:08:03,480
0,360 420,630 630,990 990,1650
bit this magic flag,|
|

2218
01:08:03,600 --> 01:08:04,920
0,180 180,660 660,870 870,1230 1230,1320
{} corresponding that block and
对应描述符块替换魔术数为零，

2219
01:08:04,920 --> 01:08:06,600
0,90 90,510 510,870 870,1020 1020,1680
the descriptor block and replace

2220
01:08:06,630 --> 01:08:08,370
0,360 360,570 570,720 720,1140 1320,1740
magic number was zero,| if
|如果恢复重放这个块，

2221
01:08:08,370 --> 01:08:09,600
0,330 330,480 480,600 600,1020 1020,1230
recovery has to replay this

2222
01:08:09,600 --> 01:08:11,070
0,390 390,540 540,750 750,960 960,1470
block,| it'll see that flag|
|它将看到这个标志，|

2223
01:08:11,100 --> 01:08:12,690
0,150 150,600 600,1200 1200,1350 1350,1590
and before replaying this block
在将这个块重放到原位置之前，

2224
01:08:12,690 --> 01:08:14,130
0,90 90,210 210,360 360,1020 1080,1440
to its home location| will
|使用魔术数替换零。

2225
01:08:14,130 --> 01:08:15,600
0,420 420,510 510,1200 1230,1380 1380,1470
replace the zero with the

2226
01:08:15,600 --> 01:08:16,780
0,390 390,720
magic number.|
|

2227
01:08:17,350 --> 01:08:19,840
0,450 780,1830
And therefore,
所以，除了描述符或提交块之外，

2228
01:08:19,900 --> 01:08:21,490
0,420 450,900 900,1230 1230,1440 1440,1590
{} no block other than

2229
01:08:21,490 --> 01:08:22,930
0,90 90,600 600,720 720,1050 1050,1440
a descriptor or commit block|
|

2230
01:08:22,930 --> 01:08:24,070
0,150 150,630 630,990 990,1080 1080,1140
can possibly start with a
没有任何块可能以魔术数开头，

2231
01:08:24,070 --> 01:08:25,320
0,330 330,810
magic number,|
|

2232
01:08:25,380 --> 01:08:26,850
0,450 510,690 690,840 840,1110 1110,1470
{} in this logging system.|
在这个记录系统中。|

2233
01:08:26,850 --> 01:08:27,600
0,120 120,210 210,450 450,600 600,750
So we never have this
所以我们从来没有模棱两可，

2234
01:08:27,600 --> 01:08:29,610
0,750 1020,1380 1380,1470 1470,1770 1770,2010
ambiguity,| if the block after
|如果块在提交块之后，并以一个魔术数开头，

2235
01:08:29,610 --> 01:08:31,470
0,60 60,330 330,840 1290,1560 1560,1860
a commit block, {} starts

2236
01:08:31,470 --> 01:08:32,250
0,90 90,120 120,420 420,630 630,780
with a magic number,| then
|那么它一定是一个描述符块。

2237
01:08:32,250 --> 01:08:34,590
0,180 240,750 750,1170 1440,1800 1890,2340
it must be a descriptor

2238
01:08:34,590 --> 01:08:35,660
0,450
block.|
|

2239
01:08:39,320 --> 01:08:42,080
0,480 720,1260 1590,1980 1980,2130 2130,2760
Okay, {} alright,| so recovery,
好的，|我们在做恢复，

2240
01:08:42,080 --> 01:08:43,100
0,150 150,240 240,450 450,900 900,1020
we were doing recovery,| it
|它从块开始，

2241
01:08:43,100 --> 01:08:45,080
0,840 840,990 990,1410
starts at the

2242
01:08:45,290 --> 01:08:47,840
0,600 630,1350 1350,1530 1530,1860 2100,2550
{} block,| that the super
|从超级块表示最老的事务的块向前扫描，

2243
01:08:47,840 --> 01:08:49,250
0,270 270,660 660,930 930,1080 1080,1410
block says is the beginning

2244
01:08:49,250 --> 01:08:50,870
0,60 60,120 120,420 420,960 960,1620
of the oldest transaction scans

2245
01:08:50,870 --> 01:08:52,670
0,630 810,1140 1140,1290 1290,1410 1410,1800
forward,| {} and it'll scan
|它向前扫描，直到，

2246
01:08:52,670 --> 01:08:55,580
0,330 330,840 2340,2670 2670,2820 2820,2910
forward until you, you know

2247
01:08:55,580 --> 01:08:56,280
0,150
it,|
|

2248
01:08:56,460 --> 01:08:57,510
0,300 300,360 360,450 450,810 810,1050
look at the descriptor or
查找描述符或其对应的提交块，

2249
01:08:57,510 --> 01:08:59,280
0,90 90,300 300,1020 1020,1320 1320,1770
is their corresponding commit block|
|

2250
01:08:59,400 --> 01:09:00,600
0,330 330,480 480,660 660,1110 1110,1200
{} and it'll stop as
它停止在，

2251
01:09:00,600 --> 01:09:02,460
0,210 210,360 360,540 570,1380 1380,1860
soon as it sees| oh
|后面的是提交块，而不是描述符块，

2252
01:09:02,760 --> 01:09:03,930
0,150 150,420 420,840 840,960 960,1170
the log following a commit

2253
01:09:03,930 --> 01:09:05,130
0,240 240,510 510,540 540,930 930,1200
block, wasn't a descriptor block

2254
01:09:05,130 --> 01:09:06,240
0,90 90,600
at all,|
|

2255
01:09:06,360 --> 01:09:09,330
0,360 390,990 1230,1770 1770,2190 2430,2970
{} or yeah the block
或者，在提交块之后的块是一个描述符块，

2256
01:09:09,330 --> 01:09:10,500
0,270 270,480 480,810 810,1050 1050,1170
following a commit block is

2257
01:09:10,500 --> 01:09:12,540
0,30 30,480 480,840 840,1200 1260,2040
a descriptor block,| but {}
|但是应该有对应的提交块，

2258
01:09:12,810 --> 01:09:14,460
0,600 630,930 930,1230 1230,1380 1380,1650
the what should have been

2259
01:09:14,460 --> 01:09:16,620
0,60 60,690 690,960 960,1530 1800,2160
the corresponding commit block, {}|
|

2260
01:09:16,620 --> 01:09:17,640
0,210 210,540 540,630 630,990 990,1020
is now in fact a
是有效的提交块，没有魔术数。

2261
01:09:17,640 --> 01:09:18,960
0,330 330,570 570,960 990,1200 1200,1320
valid commit block, doesn't have

2262
01:09:18,960 --> 01:09:20,070
0,60 60,420 420,750 780,990 990,1110
the magic number.| So at
|所以在这一点上它会停止，

2263
01:09:20,070 --> 01:09:21,270
0,240 240,420 420,510 510,600 600,1200
that point it will stop,|
|

2264
01:09:21,540 --> 01:09:23,610
0,420 720,1290 1290,1590 1590,1800 1800,2070
{} recovery software will clear
恢复软件清除日志到结尾，

2265
01:09:23,610 --> 01:09:24,990
0,60 60,300 300,360 360,540 570,1380
the log to the ended,|
|

2266
01:09:25,770 --> 01:09:27,960
0,720 750,1140 1140,1230 1230,1680 1680,2190
{} at the point where
在最后一个有效提交块的地方。

2267
01:09:27,990 --> 01:09:30,570
0,420 420,1080 1110,1650 1650,2010 2010,2580
the last valid commit block.|
|

2268
01:09:30,980 --> 01:09:32,060
0,210 210,390 390,810 810,930 930,1080
And we'll ignore,| there may
我们会忽略，|这之后可能会有部分事务，

2269
01:09:32,060 --> 01:09:33,530
0,120 120,210 210,570 570,1140 1140,1470
be a partial transaction after

2270
01:09:33,530 --> 01:09:34,790
0,510 540,720 720,1050 1050,1140 1140,1260
this,| that started to commit
|开始提交，但没有结束，

2271
01:09:34,790 --> 01:09:36,890
0,180 180,420 420,990 1740,2040 2040,2100
but didn't finish,| but the
|但是恢复软件忽略那部分事务，

2272
01:09:36,890 --> 01:09:38,750
0,360 360,690 690,1350 1350,1560 1560,1860
recovery software ignores that partial

2273
01:09:38,750 --> 01:09:40,280
0,630 630,1080 1080,1140 1140,1350 1350,1530
transaction,| because it doesn't have
|因为它没有所有的写入，

2274
01:09:40,280 --> 01:09:41,660
0,120 120,210 210,900 1050,1260 1260,1380
all the writes,| so it
|所以不能自动恢复它，

2275
01:09:41,840 --> 01:09:43,130
0,270 270,570 570,660 660,1080 1080,1290
can't restore it {atomically -},|
|

2276
01:09:43,730 --> 01:09:44,840
0,180 180,300 300,390 390,750 750,1110
and then the recovery software
然后恢复软件将返回到日志的开头，

2277
01:09:44,840 --> 01:09:46,460
0,180 180,390 390,1020 1230,1410 1410,1620
will go through go back

2278
01:09:46,460 --> 01:09:47,060
0,60 60,120 120,420 420,510 510,600
to the beginning of the

2279
01:09:47,060 --> 01:09:49,520
0,540 600,900 900,1500 1500,1800 1800,2460
log| and replay each block,
|重放每个块，将每个块重写到其原位置，

2280
01:09:49,970 --> 01:09:51,350
0,540 540,750 750,1110 1110,1200 1200,1380
rewrite each block to its

2281
01:09:51,350 --> 01:09:53,300
0,180 180,810 1200,1590 1590,1800 1800,1950
home location,| {} all through
|一直贯穿日志，

2282
01:09:53,300 --> 01:09:54,540
0,120 120,720
the log,|
|

2283
01:09:54,910 --> 01:09:56,320
0,330 450,570 570,1080 1110,1290 1290,1410
{} {to,the} last, up to
到最后最后一个有效的提交块。

2284
01:09:56,320 --> 01:09:57,730
0,90 90,390 390,720 720,960 960,1410
the last valid commit block.|
|

2285
01:09:58,780 --> 01:09:59,920
0,570

2286
01:10:00,550 --> 01:10:02,560
0,210 210,390 390,480 480,780 1230,2010
And then it can restart
然后它可以重启剩下的操作系统，

2287
01:10:02,560 --> 01:10:04,060
0,90 90,420 420,540 540,840 990,1500
the rest of the operating

2288
01:10:04,060 --> 01:10:05,350
0,540 570,960 960,1020 1020,1230 1230,1290
system,| start the rest of
|启动剩下的操作系统和可以运行的普通程序，

2289
01:10:05,350 --> 01:10:07,630
0,90 90,420 420,840 840,1350 1830,2280
the operating system and ordinary

2290
01:10:07,630 --> 01:10:09,940
0,420 420,540 540,930 1620,1920 1920,2310
programs can run,| before recovery
|在恢复完成之前，你不能运行任何程序，

2291
01:10:09,940 --> 01:10:11,710
0,360 360,450 450,780 1230,1560 1560,1770
finishes, you can't you can't

2292
01:10:11,710 --> 01:10:13,120
0,240 240,450 450,960 960,1170 1170,1410
run any programs,| because the
|因为文件系统无效。

2293
01:10:13,630 --> 01:10:15,880
0,420 420,1080
file system

2294
01:10:16,140 --> 01:10:17,480
0,300 300,840
isn't valid.|
|

2295
01:10:19,780 --> 01:10:21,780
0,210 210,510 510,690 690,1350
Any questions about recovery?|
关于恢复，有什么问题吗？|

2296
01:10:22,690 --> 01:10:23,650
0,330 330,540 540,690 690,750 750,960
I I have a quick
我有一个简短的问题，

2297
01:10:23,650 --> 01:10:26,110
0,660 660,1170 1470,2160 2160,2340 2340,2460
question,| {} I think you
|我想以前提到过这一点，

2298
01:10:26,110 --> 01:10:27,640
0,300 300,480 480,900 900,1050 1050,1530
mentioned this before,| but what
|但是在 xv6 中缺少这个日志事务方案的哪些部分呢？

2299
01:10:27,640 --> 01:10:30,220
0,390 390,510 510,1170 1230,1710 1710,2580
parts of this logging transaction

2300
01:10:30,220 --> 01:10:32,020
0,330 330,480 480,1230
scheme is missing

2301
01:10:32,080 --> 01:10:35,230
0,420 420,810 810,1560 1620,2310 2580,3150
in {xv6 -}?| {} The
|在 xv6 中缺少的主要功能是

2302
01:10:35,230 --> 01:10:36,430
0,240 240,420 420,870 870,1110 1110,1200
main thing, it's missing in

2303
01:10:36,430 --> 01:10:37,480
0,300 300,540 540,630 630,720 720,1050
{xv6 -} is| the ability
|在日志中有多个事务的能力，

2304
01:10:37,480 --> 01:10:39,130
0,90 90,210 210,630 630,1530 1530,1650
to have multiple transactions in

2305
01:10:39,130 --> 01:10:40,810
0,90 90,690 1200,1380 1380,1560 1560,1680
the log,| so {xv6 -
|在 xv6 中，日志最多只有一个事务，

2306
01:10:40,810 --> 01:10:42,610
0,420 420,810 900,1200 1200,1620 1620,1800
-} there's only ever at

2307
01:10:42,610 --> 01:10:43,810
0,270 270,480 480,1050 1050,1140 1140,1200
most one transaction in the

2308
01:10:43,810 --> 01:10:46,630
0,600 1050,1410 1410,1740 1950,2430 2430,2820
log| and so you you
|所以你不能在 xv6 中得到这个并发性，

2309
01:10:46,630 --> 01:10:48,070
0,540 810,960 960,1110 1110,1290 1290,1440
can't you don't get this

2310
01:10:48,070 --> 01:10:50,530
0,600 600,690 690,1290 1290,1650 1680,2460
concurrency in xv6,| where while
|当我执行来自事务 7 的系统调用时，

2311
01:10:50,530 --> 01:10:52,990
0,120 120,960 1110,1770 1770,2190 2190,2460
I'm executing system calls from

2312
01:10:52,990 --> 01:10:55,560
0,1020 1140,2190
transaction 7,|
|

2313
01:10:55,650 --> 01:10:56,190
0,120 120,210 210,360 360,420 420,540
you know that are going
这将并行进入事务 7 ，

2314
01:10:56,190 --> 01:10:57,570
0,60 60,240 240,390 390,990 990,1380
to go into transaction 7,|
|

2315
01:10:57,600 --> 01:10:59,580
0,180 180,870 870,1020 1020,1380 1410,1980
in parallel, with that {ext3
同时， ext3 可以将事务 6 提交到磁盘。

2316
01:10:59,580 --> 01:11:02,490
0,330 330,480 480,750 780,1620 2250,2910
-} can be committing transactions

2317
01:11:02,490 --> 01:11:04,200
0,330 330,420 420,540 540,1260
6 to the disk.|
|

2318
01:11:04,830 --> 01:11:06,680
0,300 300,510 510,1050 1050,1290
That's not available of
这个并发性在 xv6 中是不可用的，

2319
01:11:06,680 --> 01:11:09,530
0,810 1260,1800 1920,2250 2250,2700 2700,2850
concurrency, {} {is,not} possible in

2320
01:11:09,530 --> 01:11:10,940
0,570 570,930
{ext- -},

2321
01:11:11,060 --> 01:11:13,430
0,360 420,690 690,840 840,1440 1710,2370
in {xv6 - -} {},|
|

2322
01:11:13,640 --> 01:11:15,980
0,780 810,1110 1140,1290 1290,1590 1590,2340
because the the log holds
因为日志只保存一个事务，

2323
01:11:16,010 --> 01:11:17,480
0,330 330,540 540,1200 1230,1410 1410,1470
just one transaction,| so we
|所以我们必须完成一个事务的所有工作，

2324
01:11:17,480 --> 01:11:18,650
0,90 90,180 180,750 750,900 900,1170
have to completely do all

2325
01:11:18,650 --> 01:11:19,940
0,90 90,360 360,480 480,660 660,1290
the work for one transaction,|
|

2326
01:11:19,940 --> 01:11:21,080
0,300 300,390 390,660 660,720 720,1140
before we're allowed to start
在我们允许开始下一个事务之前。

2327
01:11:21,080 --> 01:11:23,630
0,630 870,1200 1200,1500 1560,2010 2010,2550
anything with the next transaction.|
|

2328
01:11:24,690 --> 01:11:25,980
0,330 330,420 420,810 810,900 900,1290
So it's correct and simple,|
所以它是正确而简单的，|

2329
01:11:25,980 --> 01:11:27,330
0,270 630,900 900,1080 1080,1230 1230,1350
but {} you don't get
但是你不会从 xv6 中获得太多的并行性。

2330
01:11:27,330 --> 01:11:28,890
0,60 60,240 240,300 300,1200 1380,1560
a lot of parallelism out

2331
01:11:28,890 --> 01:11:30,280
0,90 90,390 390,870
of {xv6 -}.|
|

2332
01:11:30,730 --> 01:11:32,440
0,330 330,600 600,870 900,1500 1530,1710
Okay, thank you,| are you
好的，谢谢,|你是说，

2333
01:11:32,440 --> 01:11:33,680
0,270 270,690
saying that,|
|

2334
01:11:33,680 --> 01:11:34,850
0,240 240,330 330,540 540,720 720,1170
it can still have multiple
它仍然可以有多个事务块，

2335
01:11:34,850 --> 01:11:36,260
0,660 660,990 990,1140 1140,1230 1230,1410
transaction blocks,| but it just
|但是它不能异步执行它们，

2336
01:11:36,260 --> 01:11:38,540
0,300 300,810 810,1140 1200,1350 1350,2280
can't execute them {asynchronously -},|
|

2337
01:11:40,540 --> 01:11:42,060
0,120 120,330 330,630 960,1380
would that be correct?|
对吗？|

2338
01:11:42,390 --> 01:11:44,760
0,390 390,960 1200,1560 1560,1710 1710,2370
{xv6 - -}?| {xv6 -}.|
xv6 ？|xv6 。|

2339
01:11:45,000 --> 01:11:47,670
0,870 870,1050 1050,2130 2130,2370 2370,2670
Yeah, it, it only has
是的，它只有，

2340
01:11:47,670 --> 01:11:48,700
0,480
the,|
|

2341
01:11:48,820 --> 01:11:50,500
0,240 240,810 810,900 900,1380 1380,1680
{} once it decides to,|
一旦它决定，|

2342
01:11:51,540 --> 01:11:52,700
0,600

2343
01:11:52,730 --> 01:11:53,900
0,150 150,330 360,660 810,1140 1140,1170
I mean the picture a
我的意思是图片有点混乱，

2344
01:11:53,900 --> 01:11:54,950
0,180 180,330 330,660 660,840 840,1050
little bit confused,| because {xv6
|因为 xv6 可以允许一个以上的系统调用进入单个事务，

2345
01:11:54,950 --> 01:11:56,960
0,390 420,900 900,1560 1560,1890 1890,2010
-} can allow more than

2346
01:11:56,960 --> 01:11:58,040
0,450
one

2347
01:11:58,040 --> 01:12:00,050
0,570 570,1140 1320,1590 1590,1680 1680,2010
system call into a single

2348
01:12:00,050 --> 01:12:01,910
0,690 720,960 960,1350 1350,1590 1590,1860
transaction,| so {xv6 -} does
|所以 xv6 确实有一些并发性，

2349
01:12:01,910 --> 01:12:03,020
0,150 150,570 570,690 690,930 930,1110
have some of this {concurrency

2350
01:12:03,020 --> 01:12:04,420
0,480 480,810
-} {in,it},|
|

2351
01:12:04,420 --> 01:12:05,260
0,240 240,390 390,600 600,690 690,840
{} and some of this
还有一些批处理，

2352
01:12:05,260 --> 01:12:07,270
0,600 690,1140 1170,1560 1560,1800 1800,2010
batching,| but once {xv6 -}
|但是一旦 xv6 决定开始提交事务，

2353
01:12:07,270 --> 01:12:08,470
0,360 360,450 450,750 750,1140 1140,1200
decides to start committing a

2354
01:12:08,470 --> 01:12:09,940
0,960
transaction,|
|

2355
01:12:10,360 --> 01:12:11,650
0,240 240,390 390,570 570,660 660,1290
{} it has to completely
它必须完全完成那个事务，

2356
01:12:11,650 --> 01:12:13,780
0,360 360,480 480,660 660,1500 1620,2130
finish with that transaction,| committed
|提交到磁盘，

2357
01:12:13,780 --> 01:12:15,130
0,90 90,750 750,900 900,1050 1050,1350
to disk,| you know write
|写入块到原位置，

2358
01:12:15,130 --> 01:12:16,450
0,90 90,360 360,780 780,1080 1080,1320
the header block write the

2359
01:12:16,450 --> 01:12:18,100
0,420 420,510 510,600 600,780 780,1650
blocks to the home locations|
|

2360
01:12:18,340 --> 01:12:20,890
0,330 330,810 1140,1740 1740,1800 1800,2550
and then erase the transaction
然后从日志中擦除该事务，

2361
01:12:20,890 --> 01:12:21,910
0,180 180,270 270,750 780,930 930,1020
from the log,| it has
|它必须完成所有这些事情，

2362
01:12:21,910 --> 01:12:22,810
0,60 60,150 150,360 360,540 540,900
to do all that stuff,|
|

2363
01:12:22,810 --> 01:12:24,250
0,570 570,660 660,810 810,1260 1260,1440
before it can execute any
在执行任何新的系统调用之前。

2364
01:12:24,250 --> 01:12:25,960
0,180 180,600 600,1350
new system calls.|
|

2365
01:12:26,200 --> 01:12:27,700
0,240 240,360 360,810 1110,1290 1290,1500
Because there's nowhere you know
因为没有什么地方

2366
01:12:28,150 --> 01:12:29,140
0,450 450,660 660,750 750,930 930,990
there's nowhere| to put the
|可以放置新系统调用的修改，

2367
01:12:29,140 --> 01:12:30,310
0,630 630,690 690,780 780,870 870,1170
modifications for the new system

2368
01:12:30,310 --> 01:12:31,930
0,270 270,510 510,660 780,1140 1140,1620
calls| until the previous transaction
|直到前一事务完全完成，

2369
01:12:31,930 --> 01:12:34,180
0,120 120,540 540,1140 1770,2010 2010,2250
is completely finished,| so xv6
|所以， xv6 之间的某种交替，

2370
01:12:34,180 --> 01:12:36,310
0,300 300,480 1200,1770 1770,2040 2040,2130
sort of alternates,| between it
|可以运行几个系统调用，然后提交事务，

2371
01:12:36,310 --> 01:12:37,030
0,90 90,240 240,300 300,420 420,720
can run a few system

2372
01:12:37,030 --> 01:12:39,130
0,720 990,1290 1290,1800 1830,2040 2040,2100
calls and then commit the

2373
01:12:39,130 --> 01:12:40,520
0,990
transaction,|
|

2374
01:12:40,520 --> 01:12:41,180
0,120 120,360 360,480 480,540 540,660
and then run a few
然后再运行几个系统调用，

2375
01:12:41,180 --> 01:12:41,900
0,120 120,390 390,570 570,660 660,720
more system calls,| but it
|但是它不能重叠这两个。

2376
01:12:41,900 --> 01:12:43,580
0,300 480,750 750,960 960,1410 1410,1680
can't serve {overlap,those -} two.|
|

2377
01:12:44,790 --> 01:12:47,140
0,210 210,720 720,930 930,1500
Alright.| {ext3 -} can.|
好的。|ext3 可以。|

2378
01:12:47,210 --> 01:12:48,440
0,360 360,660
Thank you.|
谢谢。|

2379
01:12:57,830 --> 01:13:00,620
0,510 630,1200 2220,2580 2580,2670 2670,2790
Okay, {} so that was
好的，这是 ext3 设计中相对简单的部分，

2380
01:13:00,620 --> 01:13:02,660
0,90 90,660 660,1440 1440,1710 1710,2040
a relatively straightforward part of

2381
01:13:02,870 --> 01:13:06,520
0,600 600,1230 1380,2250 2280,2730
{ext3 -} design, {}|
|

2382
01:13:06,520 --> 01:13:07,930
0,120 120,360 360,510 510,1020 1050,1410
it turns out there's also
它还有一堆棘手的细节，

2383
01:13:07,930 --> 01:13:09,610
0,60 60,300 300,630 720,1230 1380,1680
a bunch of a tricky

2384
01:13:09,610 --> 01:13:11,230
0,900 930,1170 1170,1350 1350,1410 1410,1620
details,| a few of which
|其中有几点我想谈谈。

2385
01:13:11,230 --> 01:13:12,070
0,60 60,180 180,240 240,480 480,840
I want to talk about.|
|

2386
01:13:12,520 --> 01:13:15,250
0,450 480,600 600,1020 1020,1710 2220,2730
So I mentioned before, that
我之前提到过，有一个打开的事务，

2387
01:13:15,520 --> 01:13:16,240
0,150 150,210 210,390 390,480 480,720
you know there's an open

2388
01:13:16,240 --> 01:13:18,400
0,810 1170,1380 1380,1680 1680,1950 1950,2160
transaction,| but when {ext3 -}
|但是当 ext3 决定想要关闭打开的事务时，

2389
01:13:18,400 --> 01:13:19,600
0,600 600,690 690,900 900,1080 1080,1200
decides that it wants to

2390
01:13:19,600 --> 01:13:23,020
0,840 840,990 990,1260 1260,2130 3060,3420
close the open transaction,| it
|它必须等待所有系统调用完成，

2391
01:13:23,020 --> 01:13:24,010
0,180 180,330 330,690 690,840 840,990
has to wait for all

2392
01:13:24,010 --> 01:13:25,360
0,330 330,570 570,660 660,840 840,1350
system calls {} that transaction

2393
01:13:25,360 --> 01:13:26,680
0,90 90,990
to finish|
|

2394
01:13:26,680 --> 01:13:27,980
0,540 540,750
before it,
在任何新的事务可以开始前，

2395
01:13:27,980 --> 01:13:29,750
0,270 270,690 690,930 930,1110 1110,1770
any trans-, any new transactions

2396
01:13:29,750 --> 01:13:31,100
0,90 90,390 390,450 450,1050 1170,1350
are allowed to start,| so
|所以可能有这样一张图片，

2397
01:13:31,100 --> 01:13:32,270
0,210 240,570 570,660 660,1050 1050,1170
that maybe a picture for

2398
01:13:32,270 --> 01:13:33,770
0,330 330,480 480,840 1260,1410 1410,1500
that is that,| you know
|我们有原始的旧事务 t1 ，

2399
01:13:33,770 --> 01:13:35,920
0,120 120,510 960,1560
we had {}

2400
01:13:35,980 --> 01:13:39,070
0,660 660,1260 1440,2280 2280,2490 2490,3090
original old transaction {t1 -},|
|

2401
01:13:39,400 --> 01:13:40,840
0,240 240,330 330,750 750,1140 1140,1440
then there were multiple system
在事务 1 中执行多个系统调用，

2402
01:13:40,840 --> 01:13:43,420
0,540 1230,2070
calls {}

2403
01:13:43,480 --> 01:13:45,340
0,570 570,660 660,1200 1200,1500 1590,1860
executing in transaction 1,| if
|如果我们想要关闭事务 1 ，

2404
01:13:45,340 --> 01:13:46,960
0,90 90,240 240,300 300,990 990,1620
we want to close transaction

2405
01:13:46,960 --> 01:13:47,980
0,300 300,390 390,480 480,600 600,1020
1,| we have to stop
|我们必须停止接受新的系统调用，

2406
01:13:47,980 --> 01:13:49,600
0,510 510,660 660,1020 1020,1440 1440,1620
accepting new system calls,| because
|因为我们想等现有的调用完成后才能提交，

2407
01:13:49,600 --> 01:13:50,200
0,90 90,240 240,300 300,510 510,600
we want to wait for

2408
01:13:50,200 --> 01:13:51,490
0,90 90,540 540,750 750,840 840,1290
the existing ones to finish

2409
01:13:51,490 --> 01:13:53,380
0,240 240,360 360,570 570,1050 1380,1890
before we can commit,| but
|但在所有这些系统调用完成之前，

2410
01:13:53,380 --> 01:13:55,090
0,480 480,930 930,1110 1110,1380 1380,1710
until these all these system

2411
01:13:55,090 --> 01:13:57,670
0,300 300,990 1560,2040 2040,2250 2250,2580
calls finished,| no new system
|在ext3 中不允许启动新的系统调用。

2412
01:13:57,670 --> 01:13:58,780
0,270 270,330 330,570 570,660 660,1110
calls are allowed to start

2413
01:13:58,780 --> 01:14:00,490
0,150 150,600 600,1080 1200,1530 1530,1710
in {ext3 -}.| So if
|所以如果这里有事务 2 ，

2414
01:14:00,490 --> 01:14:02,170
0,180 180,300 300,930 930,1200 1200,1680
there's some transaction 2 here,|
|

2415
01:14:02,470 --> 01:14:03,550
0,420 420,510 510,750 750,810 810,1080
nothing is allowed to happen
在事务 2 中不允许发生任何事情，

2416
01:14:03,550 --> 01:14:05,220
0,90 90,660 660,1200
in transaction 2,|
|

2417
01:14:05,250 --> 01:14:07,170
0,630 630,1290 1350,1710 1710,1860 1860,1920
nothing {allows,to},| system calls are
任何事情都不允许，|系统调用允许开始，直到这些系统调用已经完成，

2418
01:14:07,170 --> 01:14:08,430
0,150 150,210 210,720 720,990 990,1260
allowed to start until these

2419
01:14:08,430 --> 01:14:11,040
0,300 300,750 780,1170 1170,1920 2340,2610
system calls have finished,| and
|并且只有在那时，事务 2 才能开始接受系统调用。

2420
01:14:11,070 --> 01:14:13,380
0,390 390,1080 1230,1500 1500,2100 2100,2310
only then can transaction 2

2421
01:14:13,380 --> 01:14:16,500
0,630 840,1590 1590,1950 1950,2700
start accepting system calls.|
|

2422
01:14:16,500 --> 01:14:18,220
0,420 570,1200
So, {}
所以，这里有一段时间，

2423
01:14:18,220 --> 01:14:19,240
0,180 180,240 240,600 600,660 660,1020
there's a period of time

2424
01:14:19,240 --> 01:14:22,360
0,480 660,1020 1020,1710 1860,2400 2850,3120
here,| in which {} new
|其中新的系统调用都被阻塞，

2425
01:14:22,360 --> 01:14:23,500
0,240 240,450 450,540 540,660 660,1140
system calls are all blocked,|
|

2426
01:14:23,920 --> 01:14:25,690
0,240 240,570 570,1140 1140,1590 1650,1770
that reduces performance,| because it
这降低了性能，|因为它可以执行系统调用，

2427
01:14:25,690 --> 01:14:27,070
0,150 150,240 240,330 330,1080 1080,1380
could have been executing system

2428
01:14:27,070 --> 01:14:28,120
0,300 300,450 450,540 540,690 690,1050
calls,| but we're not allowed
|但我们不允许这样做，

2429
01:14:28,120 --> 01:14:30,430
0,180 510,990 990,1140 1140,1740 1740,2310
to,| then the question is,|
|那么问题是，|

2430
01:14:30,940 --> 01:14:33,970
0,600 600,990 990,1560 1560,2220 2550,3030
how come {ext3 -} doesn't
为什么 ext3 不允许在事务 2 中启动新的系统调用，

2431
01:14:33,970 --> 01:14:35,290
0,300 300,540 540,900 900,1200 1200,1320
allow new system calls to

2432
01:14:35,290 --> 01:14:37,450
0,480 480,570 570,1140 1140,1560 1740,2160
start in transaction 2,| until
|直到事务 1 中的所有系统调用都完成。

2433
01:14:37,450 --> 01:14:38,980
0,300 300,630 630,900 900,960 960,1530
all system calls in transaction

2434
01:14:38,980 --> 01:14:39,840
0,330

2435
01:14:39,870 --> 01:14:41,220
0,810
finished.|
|

2436
01:14:41,570 --> 01:14:42,700
0,570

2437
01:14:43,330 --> 01:14:44,200
0,270 270,390 390,540 690,810 810,870
And you know it's a
这是一个好问题，因为它限制了性能，

2438
01:14:44,200 --> 01:14:45,190
0,90 90,450 450,660 660,720 720,990
good question, because it limits

2439
01:14:45,190 --> 01:14:47,320
0,690 1020,1410 1710,1950 1950,2010 2010,2130
performance,| so let me give
|让我给你们举个例子，

2440
01:14:47,320 --> 01:14:49,210
0,60 60,120 120,720 720,1290 1470,1890
you an example,| if if
|如果 ext3 没有做到这一点，

2441
01:14:49,240 --> 01:14:50,590
0,120 120,390 390,690 750,1170 1170,1350
the {ext3 -} didn't do

2442
01:14:50,590 --> 01:14:52,750
0,570 570,750 750,810 810,1650 1680,2160
this,| then the following bad
|那么可能会出现以下糟糕的情况。

2443
01:14:52,750 --> 01:14:55,040
0,660 660,840 840,1800
situation could arise.|
|

2444
01:14:55,810 --> 01:14:57,820
0,300 330,510 510,1170 1200,1830 1830,2010
So let's suppose transaction 1
那么，让我们假设事务 1 说其中有一个系统调用，

2445
01:14:57,820 --> 01:14:59,020
0,240 240,450 450,810 810,1080 1080,1200
says one system call in

2446
01:14:59,020 --> 01:15:00,760
0,270
it,|
|

2447
01:15:01,040 --> 01:15:02,920
0,210 210,360 360,450 450,1290
and it's a create,
它是 create ，创建文件的系统调用，

2448
01:15:03,830 --> 01:15:04,910
0,240 240,510 510,690 690,750 750,1080
a system call the create

2449
01:15:04,910 --> 01:15:06,290
0,450 450,690 690,750 750,1020 1020,1380
file,| maybe a file called
|可能是一个名为 x 的文件，

2450
01:15:06,290 --> 01:15:08,930
0,660 960,1440 1770,2070 2070,2220 2220,2640
x| and {} the idea
|想法是，在这个 create 完成之前，

2451
01:15:08,930 --> 01:15:10,070
0,120 120,270 270,660 660,810 810,1140
is that before this create

2452
01:15:10,070 --> 01:15:12,560
0,150 150,930 990,1500 1500,1800 2190,2490
is finished,| {} the file
|文件系统决定要启动一个新事务，

2453
01:15:12,560 --> 01:15:13,460
0,210 210,540 540,600 600,810 810,900
system decides it wants to

2454
01:15:13,460 --> 01:15:15,050
0,210 210,240 240,390 390,1230 1260,1590
start a new transaction,| open
|打开一个新事务，

2455
01:15:15,050 --> 01:15:16,250
0,150 150,180 180,300 300,1050 1050,1200
up a new transaction| and
|并且它将在 create 之后接受任何系统调用，

2456
01:15:16,250 --> 01:15:17,360
0,180 180,300 300,420 450,900 900,1110
it's going to accept any

2457
01:15:17,360 --> 01:15:18,710
0,330 330,540 540,840 840,900 900,1350
system calls after the create|
|

2458
01:15:18,710 --> 01:15:20,360
0,390 420,600 600,750 750,870 870,1650
in in this new transaction,
在这个新的事务 t2 中，

2459
01:15:20,480 --> 01:15:22,220
0,570 570,780 780,1050 1470,1530 1530,1740
transaction {t2 -}| is going
|事务 t2 开始，在 t1 结束之前，

2460
01:15:22,220 --> 01:15:23,720
0,60 60,240 240,450 450,630 630,1500
to say {t2 -} starts,

2461
01:15:24,280 --> 01:15:26,470
0,240 240,570 570,990 990,1710 1860,2190
{} before t1 finishes,| and
|我们现在开始执行事务 2 中的系统调用，

2462
01:15:26,470 --> 01:15:27,850
0,150 150,390 390,810 810,1110 1110,1380
we start executing system calls

2463
01:15:27,850 --> 01:15:30,060
0,270 270,600 600,1200 1200,1650
now in transaction 2,|
|

2464
01:15:31,450 --> 01:15:33,520
0,540 690,1290 1290,1500 1500,1680 1680,2070
maybe transaction {t2 -} calls
可能事务 t2 在某个其他文件上调用 unlink ，

2465
01:15:33,520 --> 01:15:34,480
0,180 180,450 450,600 600,780 780,960
{unlink -} on some other

2466
01:15:34,480 --> 01:15:36,190
0,390 390,660 840,1170 1170,1410 1410,1710
file,| well then {unlink -}
|那么 unlink 将释放与 y 相关联的 inode ，

2467
01:15:36,190 --> 01:15:37,540
0,120 120,630 630,810 810,960 960,1350
will free the {inode -}

2468
01:15:37,540 --> 01:15:39,340
0,480 480,630 630,1200
associated with y,

2469
01:15:39,690 --> 01:15:41,730
0,360 360,450 450,690 720,1470 1500,2040
right,| and so maybe maybe,|
|所以可能，|

2470
01:15:42,390 --> 01:15:44,430
0,240 240,540 540,1440 1530,1770 1770,2040
I'm having time go this
在图中，我的时间是这个方向。

2471
01:15:44,430 --> 01:15:46,140
0,150 150,270 270,390 390,1140
way in my diagram.|
|

2472
01:15:46,170 --> 01:15:47,300
0,510

2473
01:15:47,550 --> 01:15:48,990
0,570 600,840 840,1050 1050,1320 1320,1440
Maybe at this point in
可能在这个时间点，事务 2 标记 inode 空闲，

2474
01:15:48,990 --> 01:15:51,420
0,480 480,1080 1080,1320 1320,1830 1890,2430
time transaction 2 {} marks

2475
01:15:51,420 --> 01:15:52,770
0,150 150,300 300,510 510,750 750,1350
the {inode -} is free,|
|

2476
01:15:52,800 --> 01:15:53,790
0,300 300,390 390,630 630,750 750,990
marks the inode for y
标记 y 的 inode 空闲，

2477
01:15:53,790 --> 01:15:55,800
0,210 210,720 960,1650 1650,1890 1890,2010
is free,| create {of,course} has
|create 当然必须为 x 分配 inode ，

2478
01:15:55,800 --> 01:15:57,060
0,120 120,600 600,690 690,810 810,1260
to allocate an {inode -}

2479
01:15:57,090 --> 01:15:58,830
0,210 210,780 870,1170 1170,1260 1260,1740
for x,| maybe it allocates
|也许它在这个时间点分配了一个 inode ，

2480
01:15:58,830 --> 01:15:59,610
0,90 90,210 210,450 450,570 570,780
an {inode -} at this

2481
01:15:59,610 --> 01:16:00,900
0,240 240,360 360,780
point in time,|
|

2482
01:16:01,200 --> 01:16:03,570
0,390 420,1200 1500,1860 1920,2250 2250,2370
well, because the create is
因为 create 是在 unlink 释放之后分配的，

2483
01:16:03,570 --> 01:16:05,400
0,480 480,810 810,900 900,1260 1260,1830
allocating after the unlink freed,|
|

2484
01:16:05,460 --> 01:16:06,960
0,420 420,570 570,870 870,1410 1410,1500
{} it might reuse the
它可能重复使用相同的 inode ，

2485
01:16:06,960 --> 01:16:08,580
0,360 360,480 480,1020 1050,1230 1230,1620
same {inode -},| so maybe
|所以也许 x 会得到与 y 相同的 inode ，

2486
01:16:08,850 --> 01:16:10,020
0,420 420,840 840,960 960,1020 1020,1170
x gets going to get

2487
01:16:10,020 --> 01:16:11,130
0,60 60,390 390,510 510,900 900,1110
the same {inode -} that

2488
01:16:11,130 --> 01:16:12,690
0,270 270,660 660,960 990,1410 1410,1560
y had,| say maybe {inode
|比如 inode 17 ，

2489
01:16:12,690 --> 01:16:14,120
0,240 240,990
-} 17,

2490
01:16:14,650 --> 01:16:16,540
0,510 570,810 810,1350
right,| and then,|
|然后，|

2491
01:16:16,660 --> 01:16:18,160
0,630 720,990 990,1080 1080,1290 1290,1500
{} which is okay, because
这是可以的，因为 unlink 释放了这个 inode 。

2492
01:16:18,160 --> 01:16:19,690
0,390 390,570 570,1020 1020,1170 1170,1530
unlink free this inode.| So,
|所以，看起来还不是问题，

2493
01:16:20,370 --> 01:16:21,150
0,210 210,330 330,450 450,510 510,780
doesn't look like a problem

2494
01:16:21,150 --> 01:16:22,740
0,390 660,1140 1290,1440 1440,1500 1500,1590
yet,| {} you know the
|关键是，

2495
01:16:22,740 --> 01:16:23,430
0,240 240,360 360,450 450,630 630,690
point is,| we're trying to
|我们在试着关闭事务 1 ，

2496
01:16:23,430 --> 01:16:24,660
0,270 270,780 780,930 930,1050 1050,1230
close transaction 1,| so then
|所以，当 create 完成时，我们关闭事务 1 ，

2497
01:16:24,660 --> 01:16:25,710
0,210 210,270 270,540 540,960 960,1050
when the create finishes, we

2498
01:16:25,710 --> 01:16:27,690
0,240 240,720 720,1080 1230,1680 1740,1980
close transaction 1| and we're
|我们要写入，

2499
01:16:27,690 --> 01:16:28,620
0,120 120,210 210,660 660,810 810,930
going to write,| let's say
|假设事务提交，

2500
01:16:28,620 --> 01:16:30,360
0,630 630,900 900,1410 1410,1530 1530,1740
transaction actually commits,| we write
|我们将其所有修改写入磁盘。

2501
01:16:30,360 --> 01:16:31,500
0,180 180,270 270,390 390,1020 1020,1140
all of its modifications to

2502
01:16:31,500 --> 01:16:32,660
0,540
disk.|
|

2503
01:16:32,660 --> 01:16:35,900
0,240 240,960 990,1740 2310,2730 2730,3240
{} Fantastic,| however {} supposing
太棒了，|不过假设 unlink 需要一段时间，还没有结束，

2504
01:16:35,900 --> 01:16:37,760
0,990 1050,1320 1320,1470 1470,1650 1650,1860
after the {unlink -} takes

2505
01:16:37,760 --> 01:16:40,040
0,420 420,630 630,930 930,1200 1710,2280
{a,while} hasn't finished yet, {}|
|

2506
01:16:40,070 --> 01:16:42,140
0,390 390,750 750,930 930,1290 1290,2070
supposing after this commit finishes,|
假设提交完成后，|

2507
01:16:42,170 --> 01:16:43,760
0,210 210,270 270,1140
there's a crash,
这里发生崩溃。

2508
01:16:44,970 --> 01:16:45,940
0,420
right.|
|

2509
01:16:47,790 --> 01:16:49,800
0,480 480,570 570,1020 1020,1500 1500,2010
When the recovery software runs,|
当恢复软件运行时，|

2510
01:16:49,860 --> 01:16:50,760
0,330 330,450 450,510 510,690 690,900
it's going to see that
它将看到事务 1 已提交，

2511
01:16:50,760 --> 01:16:52,960
0,540 540,870 870,1590
transaction 1 committed,|
|

2512
01:16:53,080 --> 01:16:55,030
0,570 870,1020 1020,1140 1140,1710 1710,1950
{} and that transaction two
而事务 2 没有，

2513
01:16:55,030 --> 01:16:56,680
0,510 630,840 840,960 960,1290 1290,1650
didn't,| so the recovery software
|所以恢复软件会完全忽略事务 2 ，

2514
01:16:56,680 --> 01:16:58,270
0,150 150,360 360,750 750,1050 1050,1590
gonna just completely ignore transaction

2515
01:16:58,270 --> 01:16:59,590
0,270 660,840 840,990 990,1170 1170,1320
two,| so that means the
|所以这意味着 unlink 写入从来没有发生过，

2516
01:16:59,590 --> 01:17:01,840
0,210 210,600 720,1110 1110,1410 1410,2250
{unlink -} never took place

2517
01:17:02,020 --> 01:17:03,640
0,210 210,780 780,900 900,1230 1230,1620
it's writes,| the recovery software
|恢复软件不会执行对磁盘的 unlink 写入，

2518
01:17:03,640 --> 01:17:06,670
0,1020 1290,1800 1800,2670 2730,2880 2880,3030
won't won't perform the {unlink

2519
01:17:06,670 --> 01:17:07,990
0,330 330,660 660,750 750,840 840,1320
-} writes to the disk,|
|

2520
01:17:08,020 --> 01:17:09,490
0,390 390,750 750,1140 1140,1320 1320,1470
therefore won't free the {inode
所以不会释放 inode ，

2521
01:17:09,490 --> 01:17:10,540
0,540
-},|

2522
01:17:10,630 --> 01:17:13,210
0,720 750,1050 1050,1380 1380,1980 2190,2580
won't won't delete y,| after
不会删除 y ，|在崩溃和恢复后 y 仍然存在，

2523
01:17:13,210 --> 01:17:14,590
0,180 240,600 600,690 690,1050 1050,1380
the crash and recovery y

2524
01:17:14,590 --> 01:17:16,210
0,270 270,840 990,1260 1260,1380 1380,1620
still exist,| it will still
|它仍将使用 inode 17 ，

2525
01:17:16,210 --> 01:17:17,620
0,120 120,360 360,540 540,660 660,1410
be using {inode -} 17,|
|

2526
01:17:17,710 --> 01:17:19,840
0,420 420,510 510,870 870,1500 1530,2130
however the create transaction did
但是 create 事务确实完成了，

2527
01:17:20,110 --> 01:17:21,370
0,480 480,570 570,960 960,1140 1140,1260
complete| and therefore x is
|所以 x 也将使用 inode 17 ，

2528
01:17:21,370 --> 01:17:22,690
0,120 120,180 180,330 330,870 900,1320
going to be using {inode

2529
01:17:22,690 --> 01:17:23,920
0,180 180,690 690,840 840,1140 1140,1230
-} 17 as well| and
|所以，现在我们错误地有两个文件

2530
01:17:23,920 --> 01:17:25,840
0,120 120,330 330,510 510,1410 1440,1920
so now we mistakenly have

2531
01:17:25,840 --> 01:17:28,270
0,240 240,1140 1890,2070 2070,2370 2370,2430
two files| that happen to
|恰好使用相同的 inode ，

2532
01:17:28,270 --> 01:17:29,230
0,120 120,360 360,450 450,720 720,960
be using the same {inode

2533
01:17:29,230 --> 01:17:29,960
0,390
-},|
|

2534
01:17:30,200 --> 01:17:31,430
0,300 300,480 480,570 570,810 810,1230
which means I'll share content|
这意味着我将共享内容，|

2535
01:17:31,430 --> 01:17:32,210
0,90 90,270 270,360 360,660 660,780
or write to one will
或者向其中一个文件写入，内容会神秘地出现在另一个文件中。

2536
01:17:32,210 --> 01:17:35,480
0,1050 1080,1410 1410,1830 2220,2700 3000,3270
mysteriously show up in the

2537
01:17:35,480 --> 01:17:36,700
0,180 180,660
other file.|
|

2538
01:17:36,870 --> 01:17:38,010
0,240 240,360 360,780 780,870 870,1140
Which is completely the wrong
这完全是错误的，对吧。

2539
01:17:38,010 --> 01:17:39,080
0,420
thing,

2540
01:17:39,080 --> 01:17:39,980
0,270 270,360 360,510 510,750 750,900
right.| The whole point was
|重点是我们想要 unlink y ，

2541
01:17:39,980 --> 01:17:41,030
0,210 210,450 450,540 540,750 750,1050
we wanted to {unlink -}

2542
01:17:41,030 --> 01:17:42,650
0,540 750,930 930,1170 1170,1230 1230,1620
y| and use a freed
|并使用释放的 inode x ，

2543
01:17:42,650 --> 01:17:44,120
0,150 150,390 390,960 960,1350 1350,1470
{inode -} x,| not {inode
|而不是已经在使用的 inode ，

2544
01:17:44,120 --> 01:17:44,930
0,180 180,300 300,450 450,690 690,810
-} that was already in

2545
01:17:44,930 --> 01:17:47,780
0,570 1080,1530 1800,2250 2250,2430 2430,2850
use,| so something's gone terribly
|所以这里出了严重的问题。

2546
01:17:47,780 --> 01:17:49,940
0,240 240,660
wrong here.|
|

2547
01:17:49,970 --> 01:17:51,860
0,450 480,780 780,900 900,1170 1590,1890
And you know the one
思考这件事的一种方式是，

2548
01:17:51,860 --> 01:17:52,790
0,120 120,210 210,510 510,780 780,930
way of thinking about it

2549
01:17:52,790 --> 01:17:55,460
0,180 180,480 930,1080 1470,1920 1920,2670
is| that the {unlink -}
|unlink 应该在事务 2 ，

2550
01:17:56,040 --> 01:17:57,180
0,60 60,510 510,630 630,930 930,1140
in transaction in what should

2551
01:17:57,180 --> 01:17:59,250
0,90 90,210 210,780 780,990 990,2070
have been transaction 2,| {wrote,a,block}
|写入一个块，修改一个块，

2552
01:17:59,460 --> 01:18:02,280
0,540 540,600 600,1080 1680,2070 2100,2820
modified a block| and essentially
|本质上，修改后的块被更早的事务使用，

2553
01:18:02,280 --> 01:18:04,680
0,360 360,1020 1020,1470 1470,1710 1710,2400
that modified block was used

2554
01:18:04,680 --> 01:18:06,510
0,180 180,330 360,810 810,1620 1650,1830
by an earlier transaction,| so
|所以，更晚的事务修改了块，

2555
01:18:06,510 --> 01:18:08,040
0,60 60,390 390,1020 1020,1470 1470,1530
a later transaction, modified a

2556
01:18:08,040 --> 01:18:10,320
0,540 930,1140 1140,1440 1440,1950 1950,2280
block| and that modified block
|而修改后的块被更早的事务看到，

2557
01:18:10,320 --> 01:18:11,640
0,150 150,750 750,900 900,990 990,1320
was seen by an earlier

2558
01:18:11,640 --> 01:18:15,630
0,930 1080,1560 1650,2310 2640,3300 3300,3990
transaction| and indeed information base
|来自事务 2 的修改信息

2559
01:18:16,440 --> 01:18:18,180
0,180 180,360 360,990 990,1140 1140,1740
on this modification from transaction

2560
01:18:18,180 --> 01:18:20,490
0,450 480,780 780,1500 1500,1710 1710,2310
2| was incorporated into transaction
|被合并到事务 1 中。

2561
01:18:20,490 --> 01:18:21,560
0,480
one.|
|

2562
01:18:22,100 --> 01:18:23,260
0,570

2563
01:18:23,260 --> 01:18:25,000
0,300 300,510 510,810 810,1080 1320,1740
But that means that we've
这意味着我们在这里失去了原子性，

2564
01:18:25,000 --> 01:18:26,350
0,390 390,630 630,810 810,960 960,1350
lost {atomicity - -} here,|
|

2565
01:18:26,350 --> 01:18:28,840
0,480 600,870 870,1200 1890,2400 2400,2490
because the whole goal of
因为这件事的整个目标是，

2566
01:18:28,840 --> 01:18:29,680
0,210 210,330 330,480 480,750 750,840
this was| that all the
|unlink 的所有修改都应该发生，或者一个也不发生，

2567
01:18:29,680 --> 01:18:31,300
0,900 900,1050 1050,1200 1200,1350 1350,1620
modifications for the {unlink -}

2568
01:18:31,300 --> 01:18:32,260
0,180 180,540 540,630 630,870 870,960
should occur or none of

2569
01:18:32,260 --> 01:18:33,120
0,270
them,|
|

2570
01:18:33,240 --> 01:18:34,500
0,570 570,810 810,990 990,1110 1110,1260
not just some of them,|
不是它们中的一部分，|

2571
01:18:34,500 --> 01:18:36,120
0,270 270,480 480,900 900,1290 1290,1620
but what's essentially happened here
但这里本质上发生的是，

2572
01:18:36,120 --> 01:18:38,760
0,390 450,780 780,1290 1290,1740 2070,2640
is,| because transaction 1 committed
|因为事务 1 提交了这个 inode 的空闲，

2573
01:18:38,760 --> 01:18:39,720
0,90 90,540 540,630 630,810 810,960
the free of this {inode

2574
01:18:39,720 --> 01:18:41,640
0,540 840,1170 1170,1380 1380,1530 1530,1920
-},| it means that some
|这意味着一些修改事务发生了，

2575
01:18:41,640 --> 01:18:44,460
0,480 810,1410 1410,1530 1530,2070 2100,2820
of transaction to modify modifications

2576
01:18:44,460 --> 01:18:46,680
0,300 300,840 1110,1770 1800,1980 1980,2220
actually occurred,| {} but others
|但其他没有发生，

2577
01:18:46,680 --> 01:18:48,540
0,150 150,630 900,1110 1110,1350 1350,1860
did not,| we broke {atomicity
|我们通过在较早的事务中包含较晚事务的写入打破了原子性。

2578
01:18:48,540 --> 01:18:50,840
0,210 210,600 990,1830
-} by including

2579
01:18:50,840 --> 01:18:53,240
0,120 120,780 810,1500 1500,2070 2250,2400
a later transaction's write in

2580
01:18:53,240 --> 01:18:56,150
0,120 120,570 570,1260 1800,2130 2580,2910
an earlier transaction.| And you
|你可以想象有多种不同的方式来处理这个，

2581
01:18:56,150 --> 01:18:58,100
0,90 90,330 330,1170 1290,1680 1680,1950
can actually imagine multiple different

2582
01:18:58,100 --> 01:18:59,450
0,360 360,420 420,780 780,900 900,1350
ways of dealing with this,

2583
01:19:00,080 --> 01:19:03,230
0,330 1620,2070 2070,2460 2460,2610 2610,3150
right,| maybe create could notice
|也许 create 可以注意到 17 是被一个未来的事务释放了的，

2584
01:19:03,230 --> 01:19:04,910
0,210 240,960 960,1080 1080,1230 1230,1680
that 17 had been freed

2585
01:19:04,910 --> 01:19:05,880
0,150 150,510
by a

2586
01:19:06,120 --> 01:19:07,470
0,120 120,270 270,330 330,660 660,1350
you know a future transaction|
|

2587
01:19:07,470 --> 01:19:08,610
0,420 420,660 660,840 840,1020 1020,1140
and not use that {inode
并且不使用这个 inode ，

2588
01:19:08,610 --> 01:19:11,070
0,390 780,990 990,1140 1140,1620 1950,2460
-},| {} in fact {}
|事实上， ext3 对此采取了非常简单的方法，

2589
01:19:11,070 --> 01:19:12,930
0,420 420,660 660,960 960,1530 1650,1860
{ext3 -} takes a pretty

2590
01:19:12,930 --> 01:19:14,910
0,270 270,630 630,720 720,1140 1740,1980
simple approach to this,| it
|它不允许启动任何系统调用，

2591
01:19:14,910 --> 01:19:16,590
0,300 300,600 600,1080 1080,1440 1440,1680
doesn't allow any system call

2592
01:19:16,590 --> 01:19:19,920
0,120 120,750 1620,2280 2670,3030 3030,3330
to start| until all system
|直到来自前一事务的所有系统调用都已完成，

2593
01:19:19,920 --> 01:19:21,570
0,330 330,450 450,540 540,1020 1020,1650
calls from the previous transaction

2594
01:19:21,570 --> 01:19:22,980
0,180 180,810 840,1020 1020,1170 1170,1410
have finished,| so there's no
|所以，这不可能，

2595
01:19:22,980 --> 01:19:25,830
0,870 1290,1470 1470,1590 1590,2220 2430,2850
possibility of a transaction,| a
|事务的系统调用看到修改，

2596
01:19:25,830 --> 01:19:27,240
0,300 300,450 450,600 600,1170 1170,1410
system call from transaction when

2597
01:19:27,240 --> 01:19:29,340
0,480 480,540 540,1410 1470,1860 1860,2100
seeing a modify,| seeing an
|看到来自未来事务系统调用的更新。

2598
01:19:29,550 --> 01:19:30,740
0,840
update

2599
01:19:30,740 --> 01:19:32,060
0,240 240,750 750,1020 1020,1260 1260,1320
from a system call the

2600
01:19:32,060 --> 01:19:33,560
0,330 330,930
future transaction.|
|

2601
01:19:33,650 --> 01:19:34,760
0,450 450,630 630,690 690,930 930,1110
Essentially, all of the {unlink
本质上， unlink 被阻塞，

2602
01:19:34,760 --> 01:19:36,740
0,180 180,330 330,1020 1350,1830 1830,1980
-} is pushed, {} is

2603
01:19:36,740 --> 01:19:38,270
0,660 660,870 870,1110 1110,1170 1170,1530
blocked| not allowed to start
|在 t1 提交之前不允许开始。

2604
01:19:38,270 --> 01:19:40,910
0,480 780,1170 1530,1800 1800,2040 2040,2640
until {} {t1 -} commits.|
|

2605
01:19:42,390 --> 01:19:44,140
0,240 240,570 570,780 780,1260
Any questions about this?|
对于这个，有什么问题吗？|

2606
01:19:46,660 --> 01:19:48,850
0,750 1230,1350 1350,1530 1530,1590 1590,2190
So I have a question
所以我有一个问题，

2607
01:19:48,850 --> 01:19:52,900
0,660 810,1470 2010,2340 2370,2940 2940,4050
about| {} what exactly happens,
|当你关闭一个打开的事务时，到底会发生什么，

2608
01:19:53,170 --> 01:19:55,150
0,240 240,390 390,1530 1560,1710 1710,1980
when you close an open

2609
01:19:55,150 --> 01:19:57,430
0,720 810,1020 1020,1140 1140,1320 1320,2280
transaction,| does it like snapshot,|
|它是否像快照，|

2610
01:19:58,540 --> 01:20:01,030
0,600 1020,1200 1200,1290 1290,1830 2130,2490
{} like the current state
比如当前状态缓存。

2611
01:20:01,030 --> 01:20:03,220
0,90 90,450 450,660 660,1530 1560,2190
of like the cache.| Yes,
|是的，完全正确，

2612
01:20:03,790 --> 01:20:05,230
0,210 210,630 630,930 1020,1290 1290,1440
that's exactly right,| so when
|所以，当我们关闭这个事务时，

2613
01:20:05,230 --> 01:20:07,150
0,90 90,420 420,540 540,1260 1380,1920
we close this transaction,| at
|至少在原则上，

2614
01:20:07,150 --> 01:20:08,920
0,210 210,300 300,900 1110,1470 1470,1770
least in principle,| the system
|系统会复制所有的块，

2615
01:20:08,920 --> 01:20:10,450
0,240 240,300 300,750 750,1170 1170,1530
makes a copy of all

2616
01:20:10,450 --> 01:20:11,680
0,90 90,330 330,420 420,540 540,1230
the blocks,| that were modified
|在这个事务中系统调用所修改的块，

2617
01:20:11,680 --> 01:20:12,640
0,120 120,510 510,780 780,840 840,960
by system calls in this

2618
01:20:12,640 --> 01:20:15,160
0,750 1560,2010 2010,2280 2280,2460 2460,2520
transaction,| logging system makes a
|日志系统将它们复制到缓存中，

2619
01:20:15,160 --> 01:20:15,970
0,360 360,450 450,660 660,720 720,810
copy of them in the

2620
01:20:15,970 --> 01:20:18,790
0,780 1260,1380 1380,1800 1800,2370 2520,2820
cache,| {sort,of} private copy just
|这是一种仅用于事务提交它们的私有副本。

2621
01:20:18,790 --> 01:20:21,760
0,1650 1650,1890 1890,2370 2370,2580
{for,this} transaction commit them.|
|

2622
01:20:22,170 --> 01:20:24,000
0,120 120,270 270,570 570,1170 1170,1830
And then future transactions execute
然后，未来的事务在实际缓存的块上执行某种操作，

2623
01:20:24,270 --> 01:20:25,440
0,270 270,330 330,480 480,600 600,1170
sort of on the real

2624
01:20:25,440 --> 01:20:27,960
0,480 480,1140 1260,1530 1530,2070 2070,2520
cached blocks,| this transaction commits
|这个事务从其修改的块的私有副本进行提交。

2625
01:20:27,960 --> 01:20:29,760
0,180 180,360 360,750 750,1350 1680,1800
from its private copy of

2626
01:20:29,760 --> 01:20:31,280
0,90 90,330 330,390 390,1020
the blocks it modified.|
|

2627
01:20:31,690 --> 01:20:32,410
0,150 150,270 270,390 390,510 510,720
And then when it's done
然后，当它完成提交这些私有数据块复制到磁盘后，

2628
01:20:32,410 --> 01:20:34,360
0,420 420,1050 1110,1320 1320,1650 1650,1950
committing those it's private copy

2629
01:20:34,360 --> 01:20:35,920
0,150 150,390 390,510 510,1050 1380,1560
those blocks to disk,| you
|可以把那些复制扔掉。

2630
01:20:35,920 --> 01:20:37,420
0,90 390,690 690,870 870,1200 1200,1500
can throw those copies away.|
|

2631
01:20:43,150 --> 01:20:44,500
0,690
Yes.|
是的。|

2632
01:20:46,610 --> 01:20:48,660
0,570 630,1080
Okay. {}|
好的。|

2633
01:20:48,690 --> 01:20:50,790
0,750 930,1350 1350,1830 1830,1950 1950,2100
There's, it turns out this
这个，这是

2634
01:20:50,790 --> 01:20:52,460
0,90 90,390 390,510 510,960
is| one of about
|大约六个或十几个类似的小的怪事之一，

2635
01:20:52,670 --> 01:20:53,780
0,390 390,480 480,900 900,990 990,1110
half a dozen or a

2636
01:20:53,780 --> 01:20:56,420
0,630 810,1080 1080,1140 1140,2250 2280,2640
dozen sort of similar little

2637
01:20:56,420 --> 01:20:58,370
0,720 720,1020 1020,1350 1440,1800 1800,1950
quirks,| that {} {ext3 -}
|ext3 必须解决，

2638
01:20:58,370 --> 01:21:00,380
0,330 330,420 420,750 750,1050 1050,2010
has to deal with,| because
|因为为了支持并发，

2639
01:21:00,410 --> 01:21:02,450
0,240 240,600 600,720 720,1260 1260,2040
in order to support concurrency,|
|

2640
01:21:02,540 --> 01:21:03,710
0,330 330,600 600,750 750,990 990,1170
there's a whole bunch of
有一大堆类似的排序的琐事，

2641
01:21:04,190 --> 01:21:06,500
0,570 570,720 750,1380 1380,1620 1620,2310
kind of similar little ordering

2642
01:21:06,500 --> 01:21:07,730
0,540 540,690 690,870 870,990 990,1230
niggles,| that have to be
|这是 ext3 必须正确处理的特殊情况，

2643
01:21:07,730 --> 01:21:09,950
0,180 660,1290 1290,1680 1680,1890 1890,2220
the special cases that {ext3

2644
01:21:09,950 --> 01:21:11,030
0,210 210,450 450,540 540,720 720,1080
-} has to get right,|
|

2645
01:21:13,370 --> 01:21:13,880
0,60 60,210 210,300 300,420 420,510
{which -} we don't have
我们没时间讨论这个，

2646
01:21:13,880 --> 01:21:15,380
0,180 180,270 270,510 510,870 1050,1500
time to talk about, {}|
|

2647
01:21:15,440 --> 01:21:16,850
0,360 360,480 480,810 810,1020 1020,1410
but the take home points|
但是要点，|

2648
01:21:16,850 --> 01:21:17,540
0,120 120,270 270,450 450,630 630,690
that I want people to
我想人们记住的关于日志 ext3 的，

2649
01:21:17,540 --> 01:21:19,640
0,420 420,750 780,1380 1380,1680 1680,2100
remember about logging about {ext3

2650
01:21:19,640 --> 01:21:22,070
0,480 960,1530 1530,1650 1650,2010 2010,2430
-},| first, the general point
|首先，一般的观点，

2651
01:21:22,190 --> 01:21:24,080
0,420 750,990 990,1410 1410,1740 1740,1890
that,| {} what logs are
|日志是关于使多步磁盘更新成为原子的，

2652
01:21:24,080 --> 01:21:25,550
0,120 120,510 510,750 750,1110 1110,1470
all about is making {multi-step

2653
01:21:25,550 --> 01:21:28,070
0,450 450,840 840,1560 1560,2310 2310,2520
-} disk updates atomic,| all
|对于崩溃，全部发生或全部没有，

2654
01:21:28,070 --> 01:21:30,080
0,90 90,660 750,1050 1050,1440 1440,2010
or nothing with {respect,to} crashes,|
|

2655
01:21:30,080 --> 01:21:30,720
0,270
like,
这是关于日志最需要记住的一件事，

2656
01:21:30,980 --> 01:21:31,910
0,150 150,360 360,450 450,720 720,930
yeah, that's the main thing

2657
01:21:31,910 --> 01:21:34,760
0,90 90,420 420,720 720,1200 2160,2850
to remember about logging,| the
|日志的正确性取决于预写规则。

2658
01:21:34,760 --> 01:21:36,260
0,540 540,630 630,1080 1080,1170 1170,1500
logging the correctness of logging

2659
01:21:36,260 --> 01:21:37,340
0,330 330,420 420,570 570,810 810,1080
depends on the {write-ahead -}

2660
01:21:37,340 --> 01:21:39,380
0,420 510,720 720,1050 1350,1800 1800,2040
rule.| It's another critical thing
|另一件需要记住的重要事情是，

2661
01:21:39,380 --> 01:21:40,610
0,60 60,540 570,720 720,1050 1050,1230
to remember| you'll hear {write-ahead
|你会经常听到预写日志和预写规则，

2662
01:21:40,610 --> 01:21:42,560
0,450 450,1170 1230,1500 1500,1680 1680,1950
-} log and {write-ahead -}

2663
01:21:42,560 --> 01:21:43,610
0,390 390,480 480,870 870,960 960,1050
rule a lot| in the
|在崩溃恢复业务中。

2664
01:21:43,610 --> 01:21:45,980
0,180 180,270 270,660 660,1320 1440,2370
kind of crash recovery business.|
|

2665
01:21:46,450 --> 01:21:47,710
0,300 300,360 360,780 780,1080 1080,1260
And the {write-ahead -} rule
预写规则规定

2666
01:21:47,710 --> 01:21:48,430
0,210 210,330 330,450 450,600 600,720
says that| you have to
|你必须提交对日志的所有更改，

2667
01:21:48,430 --> 01:21:50,410
0,690 840,1320 1320,1770 1770,1860 1860,1980
commit all changes to the

2668
01:21:50,410 --> 01:21:52,330
0,600 630,1440 1440,1590 1590,1860 1860,1920
log,| before you're allowed to
|在允许对主位置进行任何修改之前，

2669
01:21:52,330 --> 01:21:54,130
0,330 360,690 690,780 780,870 870,1800
make any of the modifications

2670
01:21:54,130 --> 01:21:56,020
0,90 90,210 210,480 480,1350 1560,1890
to the home locations| in
|在文件系统中。

2671
01:21:56,020 --> 01:21:57,280
0,90 90,390 390,810
the file system.|
|

2672
01:21:57,400 --> 01:21:58,580
0,630

2673
01:21:58,780 --> 01:22:00,730
0,210 210,600 600,1440 1440,1860 1860,1950
And recovery absolutely relies on
而且恢复也依赖于这条规则，

2674
01:22:00,730 --> 01:22:03,310
0,210 210,600 1200,1710 2100,2520 2520,2580
this rule,| a lot of
|很多要点，

2675
01:22:03,310 --> 01:22:05,140
0,60 60,420 420,690 690,1050 1500,1830
the point,| at least for
|至少对于文件系统，

2676
01:22:05,140 --> 01:22:06,100
0,330 330,690 690,750 750,900 900,960
file systems,| a lot of
|日志的要点是简单快速恢复，

2677
01:22:06,100 --> 01:22:07,420
0,60 60,300 300,420 420,840 840,1320
the point of logging is

2678
01:22:07,450 --> 01:22:10,360
0,600 600,1020 1020,1680 2340,2820 2820,2910
simply fast recovery,| log may
|日志中可能有几百个块，

2679
01:22:10,360 --> 01:22:11,380
0,120 120,180 180,390 390,660 660,1020
have a couple hundred blocks

2680
01:22:11,380 --> 01:22:12,520
0,90 90,270 390,750 750,840 840,1140
in it,| you can replay
|你可以在不到一秒的时间里重放几百个块，

2681
01:22:12,520 --> 01:22:13,990
0,60 60,330 330,570 570,1050 1050,1470
a couple hundred blocks in

2682
01:22:14,050 --> 01:22:16,240
0,510 510,750 750,810 810,1440 1710,2190
way under a second| and
|然后启动你的文件系统，

2683
01:22:16,240 --> 01:22:18,160
0,510 720,990 990,1110 1110,1350 1350,1920
then boom your file system,|
|

2684
01:22:18,220 --> 01:22:19,210
0,240 240,300 300,510 510,810 810,990
even a very large one
即使是一个非常大的，现在也可以使用了。

2685
01:22:19,210 --> 01:22:21,220
0,450 480,1050 1050,1290 1290,1440 1440,2010
is, now fit for use.|
|

2686
01:22:21,880 --> 01:22:22,930
0,150 150,210 210,510 510,750 750,1050
Now the final point for
现在，最后关于 ext3 的更详细的一点是，

2687
01:22:23,020 --> 01:22:24,310
0,210 210,420 420,840 840,1080 1080,1290
a more detailed point about

2688
01:22:24,310 --> 01:22:25,210
0,90 90,390 390,660 660,750 750,900
the {ext3 -} is| that
|它使用批处理和并发

2689
01:22:25,210 --> 01:22:26,920
0,150 150,450 450,900 900,1080 1080,1710
it uses batching and concurrency|
|

2690
01:22:26,920 --> 01:22:30,010
0,90 90,360 1140,1950 1950,2220 2220,3090
to get considerably better performance
来获得比 xv6 好得多的性能，

2691
01:22:30,040 --> 01:22:32,020
0,480 870,1260 1260,1410 1410,1710 1710,1980
than {xv6 - -} does,|
|

2692
01:22:32,020 --> 01:22:33,550
0,450 600,960 960,1050 1050,1110 1110,1530
although {} at the case
尽管在很高的复杂性的情况下，

2693
01:22:33,550 --> 01:22:37,330
0,360 390,1320 2100,2610 2610,2970 2970,3780
of considerable considerably higher complexity,|
|

2694
01:22:37,830 --> 01:22:40,080
0,120 120,510 510,1020 1020,1470 1530,2250
to support concurrency than xv6
为了支持比 xv6 更高的并发。

2695
01:22:40,080 --> 01:22:40,900
0,300
has.|
|

2696
01:22:42,910 --> 01:22:43,990
0,150 150,330 330,450 450,570 570,1080
And that's all for today,|
今天就到这里，|

2697
01:22:44,080 --> 01:22:46,450
0,300 300,630 630,960 1350,1560 1560,2370
I'm happy to take questions.|
我很高兴回答大家的问题。|

2698
01:22:49,560 --> 01:22:51,270
0,450 570,990 990,1110 1110,1320 1320,1710
Um, hi, I had another
嗯，嗨，我还有一个问题是关于，

2699
01:22:51,270 --> 01:22:54,360
0,600 600,1080 1140,1800 1830,2580 2790,3090
question is {} about,| so
|所以你说，

2700
01:22:54,360 --> 01:22:56,970
0,180 180,420 420,750 900,1620 1950,2610
you said that,| {} thinks
|靠着有一个文件系统调用，

2701
01:22:56,970 --> 01:22:59,370
0,390 420,1020 1020,1530 1620,2160 2160,2400
that there's a file system|
|

2702
01:22:59,370 --> 01:23:00,570
0,210 210,330 330,600 600,900 900,1200
like a file system thread
文件系统线程来做所有这些事情，

2703
01:23:00,570 --> 01:23:02,220
0,90 90,600 600,750 750,1020 1020,1650
that does all this stuff,|
|

2704
01:23:02,720 --> 01:23:04,400
0,540 570,840 840,990 990,1200 1200,1680
there must be only one
这些线程中必须只有一个，

2705
01:23:04,400 --> 01:23:07,490
0,330 330,1110 1140,1890 1890,2310 2310,3090
of these threads,| because otherwise
|否则它可以完成刚才所说的事情。

2706
01:23:08,090 --> 01:23:09,200
0,180 180,570
it could

2707
01:23:09,260 --> 01:23:10,490
0,240 240,570 600,780 780,1110 1110,1230
it could do basically what

2708
01:23:10,490 --> 01:23:11,960
0,180 180,390 390,690 690,1050 1050,1470
it just talked about, right.|
|

2709
01:23:13,680 --> 01:23:14,940
0,570

2710
01:23:15,400 --> 01:23:16,480
0,180 180,420 420,780 780,930 930,1080
It may indeed be that
可能确实只有一个，

2711
01:23:16,480 --> 01:23:18,130
0,210 210,420 420,840 1170,1350 1350,1650
there's just one,| I actually
|我其实不知道有多少个，

2712
01:23:18,130 --> 01:23:18,940
0,210 210,270 270,420 420,630 630,810
don't know how many there

2713
01:23:18,940 --> 01:23:20,680
0,600 780,1260 1260,1380 1380,1650 1650,1740
are,| one is certainly a
|一当然是一个特别有吸引力的数字，

2714
01:23:20,680 --> 01:23:24,640
0,540 540,1440 1470,2070 2100,3000 3270,3960
particularly attractive number,| because {}
|因为日志是正确的很多基本原理是，

2715
01:23:24,670 --> 01:23:25,810
0,300 300,450 450,750 750,900 900,1140
{you,know} a lot of the

2716
01:23:25,810 --> 01:23:27,070
0,540 540,660 660,870 870,960 960,1260
rationale for why the logging

2717
01:23:27,070 --> 01:23:28,480
0,150 150,600 600,750 750,990 1110,1410
is correct is| that you
|较旧的事务在较新的事务之前提交，

2718
01:23:28,480 --> 01:23:30,640
0,120 120,390 540,1050 1050,2010 2010,2160
know the older transactions or

2719
01:23:30,760 --> 01:23:31,700
0,120 120,390
you know

2720
01:23:31,760 --> 01:23:34,040
0,450 450,720 720,990 990,1890 1920,2280
committed before newer transactions, {}|
|

2721
01:23:34,400 --> 01:23:36,020
0,720 720,1020 1020,1350 1350,1530 1530,1620
I I don't think it's
我不认为这是只有一个线程的合乎逻辑的必然性，

2722
01:23:36,020 --> 01:23:38,720
0,90 90,540 540,1260 1260,1650 1980,2700
a logical necessity that {}

2723
01:23:39,360 --> 01:23:40,470
0,180 180,330 330,510 510,750 750,1110
there be only one thread,|
|

2724
01:23:40,470 --> 01:23:42,340
0,120 120,300 300,420 420,1200
so you could imagine,
你可以想象，旧的事务以重叠的方式提交，

2725
01:23:43,540 --> 01:23:46,270
0,330 330,1650 1680,2430 2430,2610 2610,2730
old transactions committing in an

2726
01:23:46,270 --> 01:23:48,080
0,660 660,1230
overlapped way,|
|

2727
01:23:48,080 --> 01:23:50,990
0,360 420,990 990,1230 1230,1950 2010,2910
{you,know} essentially using multiple threads,
本质上是使用多个线程，每个事务一个线程。

2728
01:23:52,090 --> 01:23:53,780
0,270 270,390 390,480 480,1110
one for each transaction.|
|

2729
01:23:54,410 --> 01:23:56,220
0,360 360,660 660,810 810,1230
Oh, okay, I see.|
好的，我明白了。|

2730
01:23:57,450 --> 01:23:58,860
0,330 330,450 450,900
Okay, I see.|
好的，我知道了。|

2731
01:23:59,540 --> 01:24:01,550
0,120 120,360 360,870 930,1380 1470,2010
I {have,a} question,| {} in
我有个问题，|当你谈论崩溃的时候，

2732
01:24:01,730 --> 01:24:03,260
0,360 360,480 480,750 750,960 960,1530
when you're talking about crashes|
|

2733
01:24:03,260 --> 01:24:04,280
0,90 90,180 180,300 300,480 480,1020
and you had that diagram
你有一张 t8 重写 t5 的图，

2734
01:24:04,280 --> 01:24:07,130
0,150 150,840 1110,2100 2160,2430 2430,2850
of t8 rewriting {t5 -}|
|

2735
01:24:08,130 --> 01:24:09,330
0,300 300,480 480,630 630,810 810,1200
{} that was being freed,|
它正在被释放，|

2736
01:24:10,520 --> 01:24:13,850
0,480 960,1260 1260,1620 1620,2220 2220,3330
{} so what happens if
那么，如果 t8 在崩溃时没有真正被提交，会发生什么，

2737
01:24:13,880 --> 01:24:16,310
0,960 960,1350 1350,1680 1680,2130 2220,2430
t8 hasn't actually committed at

2738
01:24:16,310 --> 01:24:17,480
0,90 90,330 330,450 450,540 540,1170
the point of the crash,|
|

2739
01:24:17,780 --> 01:24:19,970
0,420 630,1290 1320,1590 1590,1860 1860,2190
{} because there could be
因为可能 t5 ，

2740
01:24:20,000 --> 01:24:21,800
0,540 570,870 870,1170 1170,1410 1410,1800
maybe {t5 -},| if it's
|如果它因为需要重写而被释放的话，

2741
01:24:21,800 --> 01:24:24,110
0,240 240,750 750,1410 1590,2040 2040,2310
being freed as something needs

2742
01:24:24,110 --> 01:24:25,700
0,150 150,510 510,900 1230,1440 1440,1590
to rewrite it,| then there
|那么可能存在来自 t5 的提交块，

2743
01:24:25,700 --> 01:24:26,990
0,240 240,360 360,420 420,870 870,1290
could be a commit block

2744
01:24:26,990 --> 01:24:28,790
0,210 210,480 480,870 900,1050 1050,1800
from {t5 -} that exists,|
|

2745
01:24:29,380 --> 01:24:30,540
0,600

2746
01:24:30,690 --> 01:24:31,710
0,150 150,300 300,450 450,510 510,1020
it may be a location
它可能是 t8 预测它存在的位置，

2747
01:24:31,710 --> 01:24:33,120
0,300 300,720 720,840 840,960 960,1410
where t8 would have predicted

2748
01:24:33,120 --> 01:24:34,800
0,120 120,360 420,1170
it to exist,|
|

2749
01:24:34,950 --> 01:24:36,960
0,180 180,390 390,660 660,930 1230,2010
and then couldn't that inaccurately
那么这是不是能准确地表示

2750
01:24:36,960 --> 01:24:38,520
0,540 540,720 720,1140 1140,1290 1290,1560
represent| that t8 was actually
|t8 已经被提交了吗？

2751
01:24:38,550 --> 01:24:40,380
0,210 210,510 510,660 660,1110 1500,1830
had actually been committed.| Okay,
|好的，让我试着画出出这个场景，

2752
01:24:40,380 --> 01:24:41,310
0,420 450,660 660,720 720,840 840,930
so let me try to

2753
01:24:41,310 --> 01:24:44,610
0,450 450,750 750,930 930,1800 3060,3300
draw out the scenario,| so
|所以我们有这个古老的事务 t5 ，

2754
01:24:44,610 --> 01:24:46,650
0,120 120,420 450,810 810,1200 1200,2040
we have this ancient transaction

2755
01:24:46,830 --> 01:24:48,680
0,390 390,1410
{t5 -},

2756
01:24:51,430 --> 01:24:52,480
0,510
right,|
|

2757
01:24:52,990 --> 01:24:54,550
0,540 720,1140 1140,1230 1230,1320 1320,1560
and {} you know maybe
也许这里是 t6 ，

2758
01:24:54,550 --> 01:24:57,460
0,990 1290,1680 1680,1800 1800,1950 1950,2910
t6 here,| and then we're,
|然后绕回来是 t8 ，

2759
01:24:57,460 --> 01:24:59,740
0,240 240,540 540,840 840,1770
you've wrapped around t8,|
|

2760
01:24:59,860 --> 01:25:01,450
0,390 570,870 870,960 960,1290 1290,1590
and you know t8 started
t8 现在开始在某个地方，

2761
01:25:01,450 --> 01:25:02,830
0,210 210,420 420,690 750,1200 1200,1380
somewhere now,| it's because {t5
|因为 t5 是空闲的，

2762
01:25:02,830 --> 01:25:05,260
0,330 330,720 1170,1770 1770,2340 2340,2430
-} is free,| t8 is
|t8 开始增长，

2763
01:25:05,260 --> 01:25:06,460
0,420 420,630
starting the

2764
01:25:06,490 --> 01:25:07,880
0,270 270,810
eat up,|
|

2765
01:25:10,960 --> 01:25:13,270
0,240 240,840 840,990 990,1530 2130,2310
{t5 -} that is,| the
t5 是，|t8 的末尾超过 t5 的开始。

2766
01:25:13,270 --> 01:25:14,920
0,240 240,330 330,720 720,1140 1140,1650
end of t8 is overrun

2767
01:25:14,920 --> 01:25:15,910
0,90 90,390 390,480 480,660 660,990
the beginning of {t5 -}

2768
01:25:15,940 --> 01:25:16,880
0,90 90,420
is that.|
|

2769
01:25:17,330 --> 01:25:19,490
0,270 270,600 1080,1350 1410,1890 1890,2160
Okay, and the worry is,|
好的，令人担忧的是，|

2770
01:25:19,490 --> 01:25:20,660
0,180 180,270 270,510 510,810 810,1170
okay, of course if {t8,did}
好的，当然如果 t8 提交了，

2771
01:25:20,660 --> 01:25:21,530
0,330 330,450 450,630 630,810 810,870
commit,| then it'll end up
|然后它将以提交块结束，

2772
01:25:21,530 --> 01:25:22,610
0,120 120,240 240,480 480,810 810,1080
in a commit block,| and
|而且看起来都很合理，

2773
01:25:22,910 --> 01:25:24,770
0,240 240,750 840,1050 1050,1260 1260,1860
it all look pretty reasonable,|
|

2774
01:25:25,790 --> 01:25:26,510
0,120 120,300 300,330 330,630 630,720
if there's a crash in
如果恢复出现崩溃，

2775
01:25:26,510 --> 01:25:28,310
0,570 750,1080 1080,1140 1140,1590 1590,1800
recovery| and the scenario worried
|而担心的情况是 t8 没有提交。

2776
01:25:28,310 --> 01:25:30,110
0,150 150,600 600,810 810,1200 1200,1800
about t8 did not commit.|
|

2777
01:25:33,590 --> 01:25:36,200
0,390 390,1830 2100,2340 2340,2490 2490,2610
Right.| Yeah, okay,| so the
是的。|是的，好的，|所以，[]确实如此，

2778
01:25:36,200 --> 01:25:38,990
0,720 720,1590 1590,2010 2010,2250 2340,2790
[] yeah exactly,| so t8,
|所以 t8 碰巧会把它的提交块放在

2779
01:25:39,620 --> 01:25:42,060
0,480 510,810 810,2040
t8 just happens

2780
01:25:42,340 --> 01:25:43,150
0,150 150,300 300,480 480,570 570,810
to be going to put

2781
01:25:43,150 --> 01:25:44,500
0,180 180,450 450,690 690,780 780,1350
its commit block| in exactly
|和 t5 放提交块完全相同的地方，

2782
01:25:44,500 --> 01:25:45,670
0,90 90,360 360,660 660,750 750,1170
the same place where t5

2783
01:25:45,670 --> 01:25:47,440
0,360 360,630 630,1110 1140,1620 1620,1770
puts commit block,| but it
|但是它没有写入提交块，

2784
01:25:47,440 --> 01:25:48,340
0,240 240,510 510,660 660,750 750,900
didn't quite get the write

2785
01:25:48,340 --> 01:25:49,420
0,270 270,360 360,600 600,780 780,1080
{the,commit,block},| {it's -} all good,
|所有都是好的，除了，

2786
01:25:49,420 --> 01:25:51,340
0,600 930,1290 1290,1560 1560,1680 1680,1920
except,| this we have a
|我们有一个完全正确的 t8 ，

2787
01:25:51,640 --> 01:25:53,170
0,450 450,810 810,1080 1080,1410 1410,1530
totally correct {t8 -},| but
|但它是 t5 的提交块。

2788
01:25:53,170 --> 01:25:54,250
0,180 180,420 420,720 720,810 810,1080
it's {t5's - -} commit

2789
01:25:54,250 --> 01:25:55,160
0,480
block.|
|

2790
01:25:55,160 --> 01:25:56,260
0,720
Yeah.|
嗯。|

2791
01:25:56,590 --> 01:25:58,060
0,240 240,690 690,1140 1140,1320 1320,1470
You're wondering,| gosh looks just
你在想，|天哪，看起来像一个提交块，

2792
01:25:58,060 --> 01:25:59,770
0,120 120,210 210,450 450,900 1170,1710
like a commit block,| okay,
|好的，答案是

2793
01:25:59,800 --> 01:26:01,000
0,210 210,540 540,690 690,930 930,1200
the answer is that| the
|描述符块和提交块

2794
01:26:01,000 --> 01:26:01,940
0,330
{}

2795
01:26:01,970 --> 01:26:03,440
0,600 600,930 930,1020 1020,1230 1230,1470
descriptor blocks and commit blocks|
|

2796
01:26:03,440 --> 01:26:04,400
0,120 120,270 270,420 420,690 690,960
as well as everything else
以及其他所有内容都具有事务的序列号，

2797
01:26:04,400 --> 01:26:05,990
0,180 180,270 270,780 780,1260 1410,1590
have the sequence number of

2798
01:26:05,990 --> 01:26:07,580
0,60 60,810 810,960 960,1140 1140,1590
the transactions,| so this descriptor
|所以这个描述符块有一个 8 ，

2799
01:26:07,580 --> 01:26:09,440
0,420 600,1230 1230,1380 1410,1710 1710,1860
block has an 8 in

2800
01:26:09,440 --> 01:26:10,220
0,210
it,|
|

2801
01:26:10,900 --> 01:26:13,240
0,360 360,660 660,930 930,1860 1890,2340
and but {t5's -} commit
但是 t5 的提交描述符，

2802
01:26:13,240 --> 01:26:14,460
0,660
descriptor,

2803
01:26:14,630 --> 01:26:15,650
0,300 300,480 480,630 630,780 780,1020
doesn't matter,| but {t5 -}
|但是 t5 提交块中有一个 5 。

2804
01:26:15,650 --> 01:26:17,060
0,270 270,630 660,900 900,960 960,1410
commit block has a 5

2805
01:26:17,060 --> 01:26:17,920
0,90 90,240
in it.|
|

2806
01:26:18,070 --> 01:26:20,380
0,300 540,1380 1380,1800 1830,2040 2040,2310
Okay, yeah.| And so yeah
好的，好的。|是的，它查看 8 像魔术数一样。

2807
01:26:20,380 --> 01:26:21,370
0,150 150,330 330,720 720,840 840,990
it's looking 8 as well

2808
01:26:21,370 --> 01:26:23,290
0,90 90,150 150,450 450,1140 1290,1920
as the magic number.| {Good,question}.|
|好问题。|

2809
01:26:25,440 --> 01:26:26,550
0,300 330,630 630,750 750,900 900,1110
{} Wait, but in this
等等，但在这种情况下，

2810
01:26:26,550 --> 01:26:28,230
0,510 510,900 900,1080 1080,1440 1440,1680
case,| would you also have
|你也有 t5 的描述符块，

2811
01:26:28,230 --> 01:26:29,790
0,90 90,660 660,1020 1020,1230 1230,1560
the descriptor block of {t5

2812
01:26:29,790 --> 01:26:31,890
0,630 630,1080 1080,1230 1230,1650 1740,2100
-},| so you don't really
|所以你并不需要这些数字。

2813
01:26:31,890 --> 01:26:33,660
0,210 210,330 330,1320
need the numbers.|
|

2814
01:26:35,290 --> 01:26:37,150
0,570 570,750 750,930 930,1350 1350,1860
Well, in this particular case,|
嗯，在这个特殊的案例中，|

2815
01:26:37,150 --> 01:26:39,550
0,600 1050,1470 1470,1920 1920,2310 2310,2400
so {yeah,t5 -} used to
t5 过去有一个描述符块，里面有一个 5 ，

2816
01:26:39,550 --> 01:26:41,350
0,210 210,270 270,810 810,1140 1140,1800
have a descriptor block here,

2817
01:26:41,350 --> 01:26:42,250
0,150 150,210 210,630 630,750 750,900
with a 5 in it,|
|

2818
01:26:42,280 --> 01:26:44,380
0,870 960,1500 1500,1680 1680,1800 1800,2100
however {t8 -} is so
然而， t8 太大，

2819
01:26:44,380 --> 01:26:46,930
0,510 510,750 840,1380 1410,2310 2310,2550
large,| that t8 overwrote this
|t8 重写了描述符块，

2820
01:26:46,930 --> 01:26:48,520
0,540 540,900 900,1170 1200,1470 1470,1590
descriptor block,| with one of
|使用它自己的数据块。

2821
01:26:48,520 --> 01:26:50,680
0,150 150,540 540,840 840,1800
its own data blocks.|
|

2822
01:26:51,140 --> 01:26:53,120
0,180 180,690 1110,1350 1350,1590 1590,1980
So that {t5 -} descriptor
所以 t5 描述符块就没了，

2823
01:26:53,120 --> 01:26:54,290
0,240 240,420 420,900 900,1020 1020,1170
blocks have gone| and been
|取而代之的是 t8 的块。

2824
01:26:54,290 --> 01:26:55,820
0,450 450,600 600,780 810,1260 1260,1530
replaced by {} {t8 -}

2825
01:26:55,820 --> 01:26:56,920
0,600
block.|
|

2826
01:26:57,180 --> 01:26:58,320
0,180 180,510 510,960 960,1020 1020,1140
So, yeah used to be
所以，是的，曾经是事务 5 ，

2827
01:26:58,320 --> 01:26:59,850
0,480 480,630 630,1200 1200,1410 1410,1530
evidence for transaction 5,| but
|但现在它不见了。

2828
01:26:59,850 --> 01:27:01,200
0,180 180,600 690,840 840,960 960,1350
now it's now it's gone.|
|

2829
01:27:05,100 --> 01:27:06,000
0,270 270,390 390,480 480,750 750,900
So do we know the
那么，在我们开始之前，我们知道事务 8 的大小吗？

2830
01:27:06,000 --> 01:27:08,340
0,360 360,450 450,1080 1110,1680 1710,2340
size of transaction 8 before

2831
01:27:08,340 --> 01:27:09,680
0,120 120,720
we started.|
|

2832
01:27:11,560 --> 01:27:13,680
0,660

2833
01:27:14,800 --> 01:27:18,080
0,720 720,1890 1950,2550
Mhm mm, um.|
嗯。|

2834
01:27:19,270 --> 01:27:20,480
0,810

2835
01:27:21,800 --> 01:27:22,760
0,300 300,450 450,510 510,600 600,960
Sorry, this is a complex
抱歉，这是个复杂的问题，

2836
01:27:22,760 --> 01:27:25,660
0,420 1470,1920
question,| the
|很可能是，

2837
01:27:25,860 --> 01:27:27,240
0,270 270,780 780,870 870,1260 1260,1380
it's probably the case that

2838
01:27:27,240 --> 01:27:28,480
0,120 120,720
ex- that,|
|

2839
01:27:29,840 --> 01:27:31,100
0,660

2840
01:27:31,160 --> 01:27:33,350
0,390 420,870 870,1260 1260,1500 1500,2190
okay, when t8 was opened
好的，当 t8 作为活动事务打开时，

2841
01:27:34,060 --> 01:27:35,710
0,210 210,330 330,840 840,1500 1500,1650
as the active transaction,| the
|系统调用正在写入，

2842
01:27:35,740 --> 01:27:37,150
0,330 330,600 600,690 690,990 990,1410
system calls were writing into|
|

2843
01:27:37,180 --> 01:27:38,380
0,210 210,390 390,600 600,690 690,1200
at that point in time,|
在那个时间点上，|

2844
01:27:38,380 --> 01:27:39,580
0,120 120,480 480,840 840,960 960,1200
the system didn't know how
系统不知道 t8 会有多大，

2845
01:27:39,580 --> 01:27:40,720
0,210 210,600 600,750 750,1020 1020,1140
big t8 was going to

2846
01:27:40,720 --> 01:27:41,600
0,300
be,|
|

2847
01:27:41,660 --> 01:27:44,150
0,930 990,1170 1170,1500 1500,1980 1980,2490
when the system starts committing
当系统开始提交 t8 时，

2848
01:27:44,150 --> 01:27:47,570
0,870 1200,1530 1530,2130 2580,3000 3000,3420
t8,| it {does,know}, it {does,know},
|它确实知道 t8 是多少，

2849
01:27:48,100 --> 01:27:49,390
0,210 210,510 510,630 630,810 810,1290
it does know how {t8

2850
01:27:49,390 --> 01:27:51,190
0,180 180,330 330,720 750,1500 1620,1800
-} be t8 is,| the
|系统没有开始提交 t8 ，

2851
01:27:51,190 --> 01:27:53,290
0,360 360,600 600,900 900,1530 1530,2100
system doesn't start committing t8,|
|

2852
01:27:53,320 --> 01:27:55,060
0,300 300,600 600,900 900,1050 1050,1740
until after t8 is closed,|
在 t8 关闭之后，|

2853
01:27:55,060 --> 01:27:56,080
0,240 240,330 330,450 450,750 750,1020
all of its system calls
它的所有系统调用都已完成。

2854
01:27:56,080 --> 01:27:57,360
0,60 60,750
are finished.|
|

2855
01:27:57,880 --> 01:27:58,720
0,150 150,240 240,510 510,750 750,840
And at that point the
在这一点上，系统知道，

2856
01:27:58,720 --> 01:27:59,980
0,360 360,870 870,900 900,1050 1050,1260
system knows,| I mean it's
|我的意思是，所有的写入都已完成，

2857
01:27:59,980 --> 01:28:01,030
0,390 390,510 510,840 840,960 960,1050
all the writes that were

2858
01:28:01,030 --> 01:28:02,770
0,540 690,960 960,1020 1020,1230 1230,1740
done,| all the writes {for,t8}
|t8 的所有写入都已完成，

2859
01:28:02,770 --> 01:28:04,060
0,180 180,840 840,960 960,1050 1050,1290
have completed,| all the system
|所有的系统调用都已完成，

2860
01:28:04,060 --> 01:28:04,870
0,210 210,240 240,630 630,720 720,810
calls are completed,| so the
|所以系统知道它有多大。

2861
01:28:04,870 --> 01:28:05,800
0,240 240,450 450,630 630,810 810,930
system knows how big it

2862
01:28:05,800 --> 01:28:08,260
0,420 570,1140
is. {}|
|

2863
01:28:08,290 --> 01:28:09,370
0,330 330,570 570,660 660,870 870,1080
One reason why that must
必须这样做的一个原因是，

2864
01:28:09,370 --> 01:28:10,840
0,240 240,420 420,660 780,990 990,1470
be is that| the descriptor
|描述符块持有该事务中的完整块列表，

2865
01:28:10,840 --> 01:28:13,630
0,390 390,1680 1680,2100 2190,2580 2580,2790
block holds the complete list

2866
01:28:13,630 --> 01:28:15,010
0,60 60,480 480,540 540,690 690,1380
of blocks in that transaction|
|

2867
01:28:15,100 --> 01:28:15,730
0,120 120,240 240,300 300,390 390,630
and so at the time
所以在描述符块写入的时候，

2868
01:28:15,730 --> 01:28:16,780
0,60 60,480 480,720 720,840 840,1050
the descriptor block was written,|
|

2869
01:28:16,780 --> 01:28:19,000
0,210 210,600 600,1140 1440,1890 1890,2220
which is first the logging
这是第一次，日志系统知道

2870
01:28:19,000 --> 01:28:20,260
0,330 330,570 570,720 720,930 930,1260
system knew| how many blocks
|我们将在 t8 中有多少个块。

2871
01:28:20,260 --> 01:28:21,490
0,90 90,420 720,1020 1020,1110 1110,1230
that we're going to be

2872
01:28:21,490 --> 01:28:22,560
0,120 120,360 360,720
in {t8 -}.|
|

2873
01:28:24,550 --> 01:28:25,580
0,720
Yeah.|
是的。|

2874
01:28:25,610 --> 01:28:26,510
0,240 240,480 480,600 600,810 810,900
Oh, okay, I see, I
哦，好的，我知道了，

2875
01:28:26,510 --> 01:28:27,440
0,390
see,|
|

2876
01:28:27,440 --> 01:28:28,720
0,240 240,690
thank you.|
谢谢。|

2877
01:28:30,260 --> 01:28:31,730
0,330 330,510 510,1020 1020,1170 1170,1470
{} Why don't we just
为什么我们不

2878
01:28:31,730 --> 01:28:33,140
0,570 570,750 750,1020 1020,1290 1290,1410
kind of| like have the
|把提交信息放到描述符块中来避免这类问题，

2879
01:28:33,140 --> 01:28:35,090
0,480 480,1140 1140,1410 1410,1560 1560,1950
commit information into the {descriptor

2880
01:28:35,090 --> 01:28:36,380
0,60 60,480 480,660 660,1110 1110,1290
-} block and avoid this

2881
01:28:36,380 --> 01:28:38,060
0,240 240,330 330,900 1260,1590 1590,1680
kind of problem,| because I
|我知道这不太好，

2882
01:28:38,060 --> 01:28:39,200
0,270 270,390 390,510 510,840 840,1140
know I know it's not

2883
01:28:39,200 --> 01:28:40,100
0,300 300,450 450,570 570,750 750,900
great,| that we have to
|我们必须回去，

2884
01:28:40,100 --> 01:28:41,240
0,210 210,570 570,690 690,930 930,1140
go back| and like write
|比如不是按顺序写入的，

2885
01:28:41,240 --> 01:28:43,120
0,240 240,330 330,420 420,1200
back to the location,

2886
01:28:43,150 --> 01:28:45,220
0,420 420,630 630,750 750,1740 1740,2070
like not in sequence,| but
|但那会不会有帮助？

2887
01:28:45,490 --> 01:28:47,170
0,300 300,480 480,900 1170,1530 1530,1680
wouldn't that help?| Okay, so
|好的，所以建议是，

2888
01:28:47,170 --> 01:28:48,700
0,90 90,630 630,840 840,1080 1140,1530
the proposal is that,| instead
|与其有一个提交块，

2889
01:28:48,700 --> 01:28:49,990
0,60 60,240 240,300 300,630 630,1290
of having a commit block,|
|

2890
01:28:51,240 --> 01:28:52,590
0,570 600,810 810,1110 1110,1230 1230,1350
{} we basically have the
我们让描述符块当作提交块，

2891
01:28:52,590 --> 01:28:53,670
0,420 420,630 630,900 900,1020 1020,1080
descriptor block act as a

2892
01:28:53,670 --> 01:28:55,440
0,240 240,690 1050,1350 1380,1680 1680,1770
commit block| and {xv6 -
|而且 xv6 与此非常相似。

2893
01:28:55,440 --> 01:28:56,910
0,210 210,510 510,930 960,1260 1260,1470
-} actually is very much

2894
01:28:56,910 --> 01:28:58,160
0,210 210,720
like this.|
|

2895
01:28:58,340 --> 01:28:59,540
0,600

2896
01:29:00,470 --> 01:29:01,310
0,300 300,450 450,600 600,690 690,840
And I, you know you
你知道你能这样做，

2897
01:29:01,310 --> 01:29:03,440
0,90 90,210 210,390 810,1500
could do it, {}|
|

2898
01:29:03,470 --> 01:29:05,540
0,150 150,750 960,1470 1470,1830 1830,2070
{} and {} and and
事实上，我认为你能这样做，

2899
01:29:05,540 --> 01:29:06,320
0,210 210,450 450,540 540,690 690,780
in fact I think you

2900
01:29:06,320 --> 01:29:07,730
0,90 90,270 270,390 390,810 1290,1410
can do it,| without at
|至少 ext3 不降低效率，

2901
01:29:07,730 --> 01:29:08,900
0,180 180,270 270,630 630,840 840,1170
least an {ext3 -} without

2902
01:29:08,900 --> 01:29:10,460
0,960
sacrificing

2903
01:29:10,580 --> 01:29:12,530
0,780 810,1410 1470,1680 1680,1830 1830,1950
efficiency,| however, you have to
|然而，你必须同样，

2904
01:29:12,530 --> 01:29:13,430
0,240 240,330 330,750 750,810 810,900
play the same,| you have
|你必须以与 xv6 相同的方式构建它，

2905
01:29:13,430 --> 01:29:14,570
0,210 300,840 840,1020 1020,1080 1080,1140
to structure this in the

2906
01:29:14,570 --> 01:29:15,800
0,270 270,390 390,630 840,1080 1080,1230
same way that {xv6 -

2907
01:29:15,800 --> 01:29:18,800
0,270 270,540 540,960
-} does,| namely
|也就是说，

2908
01:29:19,540 --> 01:29:21,070
0,180 180,420 420,780 810,1260 1290,1530
you, you, you,| {} if
|如果有一个，

2909
01:29:21,070 --> 01:29:22,390
0,210 210,420 660,780 930,1230 1230,1320
there's a,| you have to
|你必须在描述符块中有一些东西，

2910
01:29:22,390 --> 01:29:23,410
0,90 90,450 450,540 540,630 630,1020
be something in the descriptor

2911
01:29:23,410 --> 01:29:24,790
0,180 180,300 300,960 990,1290 1290,1380
block,| that indicates this is
|表明这是一个提交事务，

2912
01:29:24,790 --> 01:29:26,800
0,90 90,420 420,1140 1620,1920 1920,2010
a commit transaction| and we're
|我们不允许设置任何标志，

2913
01:29:26,800 --> 01:29:28,390
0,330 330,630 630,690 690,1320 1320,1590
not allowed to set whatever

2914
01:29:28,390 --> 01:29:30,760
0,180 180,570 570,1200 1350,1830 1830,2370
that flag is,| until after
|在所有数据块写入之前，

2915
01:29:30,760 --> 01:29:31,960
0,330 330,420 420,540 540,840 840,1200
all of the data blocks

2916
01:29:31,960 --> 01:29:33,040
0,90 90,240 240,600 810,990 990,1080
have been written,| so the
|所以顺序是，

2917
01:29:33,040 --> 01:29:34,270
0,420 420,510 510,660 660,780 780,1230
routine would have to be,|
|

2918
01:29:34,330 --> 01:29:35,530
0,300 300,570 570,810 810,930 930,1200
we don't write the commit
我们不先写提交挡路，

2919
01:29:35,530 --> 01:29:37,630
0,330 330,1080 1260,1770 1770,1890 1890,2100
block first,| instead we write
|相反，我们首先写入事务 8 的所有数据块，

2920
01:29:37,630 --> 01:29:38,470
0,120 120,210 210,450 450,750 750,840
all the data blocks for

2921
01:29:38,470 --> 01:29:40,480
0,600 600,780 780,1350 1500,1800 1800,2010
transaction 8 first,| and then
|然后我们回去写下提交块和块编号，

2922
01:29:40,480 --> 01:29:41,710
0,120 120,300 300,690 690,810 810,1230
we go back and write

2923
01:29:42,080 --> 01:29:42,950
0,60 60,360 360,660 660,780 780,870
the commit block with the

2924
01:29:42,950 --> 01:29:44,780
0,360 360,1320
block numbers,|
|

2925
01:29:44,810 --> 01:29:46,490
0,600 660,840 840,960 960,1440 1440,1680
{} with a descriptor block,
这个描述符块，不管它现在是什么，

2926
01:29:46,490 --> 01:29:48,140
0,240 240,330 330,510 510,870 900,1650
whatever it is now| and
|还有某种魔力，这是一个提交的事务。

2927
01:29:48,140 --> 01:29:50,000
0,210 210,420 420,510 510,1230 1560,1860
some kind of magic, this

2928
01:29:50,000 --> 01:29:52,490
0,120 120,450 450,630 630,1350 1800,2490
is really a committed transaction.|
|

2929
01:29:52,850 --> 01:29:53,690
0,180 180,450 450,540 540,720 720,840
So we can write all
所以我们可以写入所有数据块，

2930
01:29:53,690 --> 01:29:54,530
0,90 90,270 270,600 600,690 690,840
the data blocks| and then
|然后返回并写入提交块，

2931
01:29:54,530 --> 01:29:55,550
0,120 120,450 450,540 540,810 810,1020
go back and write the

2932
01:29:55,580 --> 01:29:57,480
0,240 240,630 780,1350
commit block,| that
|这个描述符提交块，不管是什么，

2933
01:29:57,570 --> 01:30:00,090
0,690 690,1020 1020,1320 1320,1740 2070,2520
descriptor commit block, whatever, {}|
|

2934
01:30:00,150 --> 01:30:01,650
0,300 300,480 480,630 630,990 990,1500
I don't know any, {}|
我不知道，|

2935
01:30:03,120 --> 01:30:04,320
0,210 210,570 570,750 750,960 960,1200
I don't know any reason
我不知道为什么这个不能工作。

2936
01:30:04,320 --> 01:30:05,190
0,210 210,390 390,600 600,720 720,870
why this couldn't be made

2937
01:30:05,190 --> 01:30:06,040
0,60 60,390
to work.|
|

2938
01:30:06,250 --> 01:30:07,260
0,510

2939
01:30:07,670 --> 01:30:08,810
0,270 270,450 450,720 720,930 930,1140
It I I don't think
我不认为它，

2940
01:30:08,810 --> 01:30:09,800
0,390
it,|
|

2941
01:30:11,300 --> 01:30:12,320
0,330 330,600 630,720 720,870 870,1020
it doesn't,| I don't think
它没有，|我认为它没有真正消除我们讨论过的任何问题，

2942
01:30:12,320 --> 01:30:13,940
0,240 240,690 690,1290 1290,1530 1530,1620
it really eliminates any of

2943
01:30:13,940 --> 01:30:15,830
0,270 360,900 900,1020 1020,1560 1560,1890
the problems we've discussed,| because
|因为我们还有这个问题，

2944
01:30:15,980 --> 01:30:17,330
0,240 240,480 480,600 600,750 750,1350
we still have this problem,|
|

2945
01:30:17,870 --> 01:30:19,370
0,480 480,810 810,1140 1140,1290 1290,1500
the original problem was,| gosh
最初的问题是，|天哪，我们如何区分这个提交块，

2946
01:30:19,370 --> 01:30:21,170
0,300 300,360 360,480 480,1110 1230,1800
how do we distinguish this

2947
01:30:21,170 --> 01:30:23,390
0,420 420,720 720,1170 1260,1950 1950,2220
commit block,| this stale commit
|这个来自事务 5 的旧提交块，

2948
01:30:23,390 --> 01:30:24,890
0,240 240,360 360,900 900,1350 1350,1500
block from transaction 5| from
|来自事务 8 的真实提交块，

2949
01:30:24,890 --> 01:30:26,180
0,60 60,300 300,750 750,1020 1020,1290
a true commit block for

2950
01:30:26,180 --> 01:30:27,290
0,510 510,720 750,930 930,1050 1050,1110
transaction 8,| we're going to
|我们在这里也会遇到同样的问题，

2951
01:30:27,290 --> 01:30:28,460
0,90 90,150 150,390 390,720 720,1170
have the same problem here,|
|

2952
01:30:28,790 --> 01:30:30,020
0,210 210,270 270,780 810,1020 1020,1230
you know this it could
这可能是在这里的东西，

2953
01:30:30,020 --> 01:30:31,490
0,120 120,240 240,450 450,780 780,1470
be that what's sitting here,|
|

2954
01:30:31,820 --> 01:30:32,900
0,150 150,300 300,510 510,960 960,1080
you know just happens to
恰好是事务 5 中的描述符块。

2955
01:30:32,900 --> 01:30:34,430
0,150 150,240 240,720 720,1230 1290,1530
be the descriptor block from

2956
01:30:34,430 --> 01:30:36,260
0,600 600,1530
transaction 5.|
|

2957
01:30:36,500 --> 01:30:37,280
0,270 270,420 420,540 540,600 600,780
And so you know maybe
所以，也许我们继续，

2958
01:30:37,280 --> 01:30:38,270
0,180 180,420 420,630 630,780 780,990
we've gone ahead| and written
|写入事务的所有数据块，

2959
01:30:38,270 --> 01:30:39,050
0,120 120,210 210,420 420,660 660,780
all the data blocks for

2960
01:30:39,050 --> 01:30:40,010
0,510 510,660 660,750 750,870 870,960
transaction data| and then there
|然后发生了崩溃，

2961
01:30:40,010 --> 01:30:41,720
0,120 120,180 180,810 930,1350 1350,1710
was a crash,| the recovery
|恢复软件仍然需要能够区分，

2962
01:30:41,720 --> 01:30:42,770
0,270 270,690 690,900 900,990 990,1050
software still needs to be

2963
01:30:42,770 --> 01:30:43,670
0,150 150,240 240,390 390,480 480,900
able to tell the difference

2964
01:30:43,670 --> 01:30:45,080
0,870
between,|
|

2965
01:30:45,500 --> 01:30:46,040
0,90 90,150 150,300 300,360 360,540
to be able to look
查看这个描述符块，

2966
01:30:46,040 --> 01:30:47,330
0,60 60,480 510,960 960,1200 1200,1290
at this descriptor block| and
|然后等一下，

2967
01:30:47,330 --> 01:30:48,640
0,150 150,330 330,390 390,690
say wait a minute,|
|

2968
01:30:49,190 --> 01:30:50,090
0,150 150,210 210,360 360,600 600,900
you know there's something wrong
这里有些不对劲，

2969
01:30:50,090 --> 01:30:51,650
0,330 660,960 960,1050 1050,1260 1260,1560
here,| even though this looks
|尽管这看起来是一个有效的描述符块，

2970
01:30:51,650 --> 01:30:53,090
0,180 180,270 270,720 720,1200 1200,1440
like a valid descriptor block,|
|

2971
01:30:53,090 --> 01:30:54,400
0,150 150,330 330,750
it's not really.|
但实际上并非如此。|

2972
01:30:54,550 --> 01:30:55,690
0,270 270,450 450,630 630,960 960,1140
And so we still have
所以我们仍然需要魔术数，

2973
01:30:55,690 --> 01:30:57,040
0,120 120,420 420,480 480,870 870,1350
to have the magic number|
|

2974
01:30:57,040 --> 01:30:59,200
0,600 600,840 840,1530 1530,2010 2040,2160
and the transaction number, the
事务号，序列号。

2975
01:30:59,200 --> 01:31:00,500
0,390 390,750
sequence number.|
|

2976
01:31:01,310 --> 01:31:02,840
0,390 390,840 840,1080 1080,1260 1260,1530
Oh, yeah, that makes sense,|
哦，是的，理解了，|

2977
01:31:02,840 --> 01:31:03,740
0,150 150,270 270,360 360,570 570,900
yeah, I was just thinking,|
是的，我只是在想，|

2978
01:31:03,740 --> 01:31:05,270
0,270 270,600 600,1080 1110,1320 1320,1530
like we'd have,| we kind
比如我们应该有，|我们提交描述符块的一部分，

2979
01:31:05,270 --> 01:31:06,470
0,60 60,330 330,630 630,780 780,1200
of have like to commit

2980
01:31:06,470 --> 01:31:07,730
0,270 270,450 450,540 540,1020 1020,1260
part in the description block,|
|

2981
01:31:07,730 --> 01:31:08,960
0,150 150,690 690,900 900,1110 1110,1230
but obviously like when we
但很明显，当我们开始 t8 时，

2982
01:31:08,960 --> 01:31:10,220
0,420 420,420 750,900 900,1170 1170,1260
start t8,| we write the
|我们写入描述符块，它是未提交的，

2983
01:31:10,220 --> 01:31:12,080
0,450 450,780 780,1080 1080,1260 1260,1860
description block saying it's uncommitted,|
|

2984
01:31:12,080 --> 01:31:12,890
0,150 150,270 270,480 480,600 600,810
then we write the data
然后我们写入数据块，

2985
01:31:12,890 --> 01:31:14,420
0,360 360,540 540,660 660,1140 1320,1530
blocks,| then we say it's
|那么我们现在就说它是一个提交块。

2986
01:31:14,420 --> 01:31:16,520
0,90 90,540 540,1080 1440,1830 1830,2100
a committed {} block, now.|
|

2987
01:31:16,730 --> 01:31:18,080
0,180 180,390 390,600 600,1230 1230,1350
The thing that could be
这里可以节省的是

2988
01:31:18,080 --> 01:31:19,610
0,420 420,600 600,690 690,840 840,1530
saved here is| the expense
|等待这些写入的花费，

2989
01:31:19,610 --> 01:31:21,320
0,150 150,720 720,870 870,1110 1110,1710
of waiting for these writes|
|

2990
01:31:21,320 --> 01:31:22,910
0,330 330,930 930,1230 1230,1320 1320,1590
and then writing a commit
然后写入一个提交块，

2991
01:31:22,910 --> 01:31:24,680
0,510 540,870 870,1170 1170,1620 1620,1770
block right,| that wait is
|等待的花费很高，

2992
01:31:24,680 --> 01:31:25,850
0,270 270,750 750,840 840,960 960,1170
quite expensive,| we're not allowed
|我们不允许开始写入提交块，

2993
01:31:25,850 --> 01:31:26,570
0,60 60,420 420,510 510,660 660,720
to start the write of

2994
01:31:26,570 --> 01:31:27,500
0,90 90,360 360,630 630,840 840,930
the commit block| until the
|直到数据块位于磁盘上，

2995
01:31:27,500 --> 01:31:28,520
0,210 210,630
data blocks

2996
01:31:28,520 --> 01:31:30,500
0,330 330,570 570,660 660,1230 1440,1980
are on the disk| and
|我不认为，

2997
01:31:30,560 --> 01:31:32,930
0,660 660,1050 1050,1320 1320,1740 1740,2370
I I I don't think,|
|

2998
01:31:33,500 --> 01:31:34,190
0,300 300,450 450,510 510,630 630,690
we have to have the
我们必须有相同的等待，

2999
01:31:34,190 --> 01:31:35,990
0,480 480,1020 1020,1380 1380,1680 1680,1800
same wait before we end

3000
01:31:35,990 --> 01:31:36,740
0,240 240,390 390,510 510,660 660,750
here,| in this sort of
|在新的单个块方案中，

3001
01:31:36,740 --> 01:31:38,810
0,480 570,870 870,1170 1170,1650 1830,2070
new single block scheme,| we
|我们必须有相同的等待，

3002
01:31:38,810 --> 01:31:39,530
0,120 120,210 210,300 300,390 390,720
have to have the same

3003
01:31:39,530 --> 01:31:41,690
0,330 630,1200 1260,1770 1770,1920 1920,2160
{wait -},| before we're allowed
|在我们写入这个新的描述符块之前，

3004
01:31:41,690 --> 01:31:42,710
0,90 90,300 300,450 450,570 570,1020
to write this new descriptor

3005
01:31:42,710 --> 01:31:44,000
0,480 660,840 840,930 930,1230 1230,1290
block,| so it saves a
|所以它省了一个块，

3006
01:31:44,000 --> 01:31:45,620
0,600 630,840 840,930 930,1140 1140,1620
block,| but it doesn't save,
|但是我不认为它省了时间。

3007
01:31:45,620 --> 01:31:46,400
0,270 300,540 540,660 660,690 690,780
I don't think I would

3008
01:31:46,400 --> 01:31:47,660
0,180 180,360 360,840
save much time.|
|

3009
01:31:47,840 --> 01:31:50,920
0,540 840,1410 1590,2070 2070,2490
{} The trick I,|
技巧，|

3010
01:31:50,920 --> 01:31:52,780
0,360 570,870 870,1020 1020,1410 1410,1860
the trick that later versions
更高版本的 Linux 文件系统的技巧，

3011
01:31:52,780 --> 01:31:53,890
0,90 90,270 270,570 570,810 810,1110
of the Linux file system

3012
01:31:53,890 --> 01:31:55,450
0,300 300,570 870,1110 1110,1170 1170,1560
play that,| sort of does
|确实达到了你想要的效果。

3013
01:31:55,450 --> 01:31:56,320
0,240 240,450 450,570 570,750 750,870
do what I think you're

3014
01:31:56,320 --> 01:31:58,560
0,360 360,810
hoping for.|
|

3015
01:31:59,000 --> 01:32:00,800
0,240 240,390 450,780 1200,1470
You know the the,|
你知道，|

3016
01:32:01,100 --> 01:32:02,030
0,150 150,300 300,660 660,780 780,930
this is looking into the
查看 ext4 完成了以下（操作）

3017
01:32:02,840 --> 01:32:05,360
0,540 540,1170 1440,1770 1770,1890 1890,2520
{ext4 -} does the following|
|

3018
01:32:05,420 --> 01:32:06,890
0,360 360,630 630,1170 1170,1230 1230,1470
for better efficiency of writing
用来更高效地写入提交块。

3019
01:32:06,890 --> 01:32:09,840
0,60 60,330 330,810
the commit blocks.|
|

3020
01:32:09,840 --> 01:32:13,260
0,390 540,990 990,1800 1800,2370 2670,3420
It {ext4 -} will write
ext4 同时写入所有数据块和提交块，

3021
01:32:13,260 --> 01:32:14,520
0,240 240,600 630,900 900,990 990,1260
out the all the data

3022
01:32:14,520 --> 01:32:16,380
0,630 720,1080 1080,1170 1170,1560 1560,1860
blocks and the commit block

3023
01:32:16,380 --> 01:32:18,160
0,90 90,180 180,600 600,1290
at the same time,|
|

3024
01:32:18,370 --> 01:32:19,810
0,540 540,750 750,870 870,1020 1020,1440
{} that is it doesn't
也就是说，它不等待，

3025
01:32:19,810 --> 01:32:21,060
0,660
wait,|
|

3026
01:32:21,060 --> 01:32:21,990
0,120 120,210 210,420 420,660 660,930
for the data block writes
数据块写入完成，在写入提交块之前，

3027
01:32:21,990 --> 01:32:23,010
0,90 90,360 360,690 690,930 930,1020
to finish before writes the

3028
01:32:23,010 --> 01:32:24,210
0,270 270,720 750,960 960,1020 1020,1200
commit block,| so it doesn't
|所以它不会有这么长的暂停时间，

3029
01:32:24,210 --> 01:32:25,890
0,150 150,300 300,510 510,1080 1230,1680
have this long pause,| but
|但是有一个严重的问题，

3030
01:32:26,130 --> 01:32:28,350
0,690 690,960 960,1410 1500,1950 1950,2220
then there's this terrible issue,|
|

3031
01:32:28,350 --> 01:32:29,550
0,150 150,390 390,480 480,600 600,1200
what happens if the disk,|
如果磁盘，|

3032
01:32:29,610 --> 01:32:30,480
0,240 240,480 480,570 570,780 780,870
the disk is free to
磁盘盘可以自由地进行无序写入，

3033
01:32:30,480 --> 01:32:31,710
0,150 150,540 540,660 660,750 750,1230
do writes out of order,|
|

3034
01:32:32,070 --> 01:32:33,360
0,150 150,390 390,510 510,720 720,1290
{} what if the disk
如果磁盘首先写入提交块，

3035
01:32:33,720 --> 01:32:35,430
0,540 540,780 780,1050 1050,1350 1350,1710
writes the commit block first,|
|

3036
01:32:35,430 --> 01:32:37,380
0,390 390,480 480,1020 1440,1890 1890,1950
before it actually performs the
在它执行数据块写入之前，

3037
01:32:37,380 --> 01:32:38,280
0,270 270,360 360,420 420,630 630,900
writes for the data blocks|
|

3038
01:32:38,280 --> 01:32:39,120
0,90 90,210 210,360 360,420 420,840
and then there's a crash,|
然后发生崩溃，|

3039
01:32:39,120 --> 01:32:39,750
0,120 120,180 180,270 270,360 360,630
then we have a commit
然后我们有一个提交块，

3040
01:32:39,750 --> 01:32:41,610
0,450 570,990 990,1230 1320,1410 1410,1860
block| without having to discover
|而没有写入的数据块，

3041
01:32:41,610 --> 01:32:42,900
0,270 270,510 510,600 600,810 810,1290
having written the data blocks|
|

3042
01:32:43,170 --> 01:32:44,460
0,240 240,300 300,570 570,840 840,1290
and the way {ext4 -}
而 ext4 解决这个问题的方式，

3043
01:32:44,490 --> 01:32:45,860
0,510 510,840
solves that,|
|

3044
01:32:45,890 --> 01:32:47,140
0,630

3045
01:32:48,050 --> 01:32:49,440
0,870
is
它在提交块中有一个校验和，

3046
01:32:49,760 --> 01:32:51,480
0,210 210,330 330,420 420,1200
it has a checksum

3047
01:32:51,720 --> 01:32:53,520
0,150 150,240 240,540 540,1020 1410,1800
in the commit block,| over
|对所有数据块进行校验和。

3048
01:32:53,520 --> 01:32:54,480
0,120 120,360 360,540 540,750 750,960
a {checksum -} over all

3049
01:32:54,480 --> 01:32:56,100
0,90 90,300 300,990
the data blocks.|
|

3050
01:32:56,190 --> 01:32:57,300
0,540

3051
01:32:57,300 --> 01:32:58,890
0,300 300,600 630,1050 1350,1530 1530,1590
And so if there's a
所以，如果在写入提交块后发生崩溃，

3052
01:32:58,890 --> 01:33:00,360
0,450 450,780 780,1080 1080,1170 1170,1470
crash happens after the commit

3053
01:33:00,360 --> 01:33:01,470
0,210 210,360 360,600 600,1020 1020,1110
block was written,| before the
|在写入数据块之前，

3054
01:33:01,470 --> 01:33:02,400
0,210 210,480 480,570 570,810 810,930
data blocks were written,| the
|校验和将不起作用。

3055
01:33:02,400 --> 01:33:04,260
0,420 420,630 630,870 870,1320
checksum won't work out.|
|

3056
01:33:04,380 --> 01:33:05,430
0,240 240,570 570,870 870,990 990,1050
The recovery software look at
恢复软件查看校验和，

3057
01:33:05,430 --> 01:33:06,330
0,120 120,570 570,660 660,750 750,900
this checksum| and then it'll
|然后它计算日志中数据块的校验和，

3058
01:33:06,330 --> 01:33:07,530
0,480 480,540 540,930 930,1110 1110,1200
compute the checksum over the

3059
01:33:07,530 --> 01:33:08,980
0,240 240,540 540,660 660,870
data blocks that are

3060
01:33:08,980 --> 01:33:09,790
0,240 240,360 360,450 450,720 720,810
actually in the log,| if
|如果它们不相同，

3061
01:33:09,790 --> 01:33:10,570
0,120 120,300 300,360 360,690 690,780
they're not the same,| it
|它就知道出了问题。

3062
01:33:10,570 --> 01:33:12,040
0,510 510,630 630,900 900,1080 1080,1470
knows that something went wrong.|
|

3063
01:33:12,630 --> 01:33:13,590
0,210 210,420 420,540 540,690 690,960
{} And so by doing
所以，通过这样做，

3064
01:33:13,590 --> 01:33:16,740
0,450 1050,1470 1470,1650 1650,1980 1980,3150
this,| {ext4 -} basically saves
|ext4 在机械硬盘上，节省了一个旋转，

3065
01:33:16,770 --> 01:33:17,880
0,150 150,240 240,630 630,840 840,1110
on a mechanical drive saves

3066
01:33:17,880 --> 01:33:20,860
0,90 90,480 480,1500
an entire rotations,|
|

3067
01:33:21,010 --> 01:33:22,150
0,270 360,600 600,960 960,1050 1050,1140
that would happen, if it
它会发生，|如果必须在提交之前等待数据块。

3068
01:33:22,150 --> 01:33:23,560
0,120 120,450 780,1230 1230,1350 1350,1410
had to wait for the

3069
01:33:23,560 --> 01:33:25,180
0,210 210,750 750,1020 1020,1080 1080,1620
data blocks before it commits.|
|

3070
01:33:27,820 --> 01:33:30,340
0,330 330,900
Okay, thanks.|
好的，谢谢。|

3071
01:33:34,800 --> 01:33:36,800
0,540 600,900 900,1500
Oh that's cool.|
哦，太酷了。|

3072
01:33:38,980 --> 01:33:41,900
0,510 510,720 720,900 900,1470
I love this stuff.|
我喜欢这些东西。|

3073
01:33:41,900 --> 01:33:44,300
0,510 600,900 900,1140 1140,1620 1950,2400
This is very cool, {}|
这太酷了，|

3074
01:33:44,450 --> 01:33:45,380
0,180 180,390 390,450 450,720 720,930
I wanted to ask also
我还想问一下数据块，

3075
01:33:45,380 --> 01:33:47,060
0,240 240,570 570,990 990,1470 1470,1680
about the data blocks,| just
|只是内容块。

3076
01:33:47,060 --> 01:33:50,090
0,180 180,1080 1290,1950 2250,2820 2850,3030
the content blocks.| So I
|所以我想疑问的，

3077
01:33:50,090 --> 01:33:51,170
0,150 150,180 180,330 330,780 780,1080
think I got confused,| but
|但是在我们讨论的步骤中，

3078
01:33:51,680 --> 01:33:53,120
0,810 810,900 900,1260 1260,1380 1380,1440
{where,in} the steps that we

3079
01:33:53,120 --> 01:33:54,720
0,150 150,510 510,1020
were talking about,|
|

3080
01:33:54,720 --> 01:33:56,190
0,630 630,870 870,1170 1170,1410 1410,1470
{} on your one of
在你之前的一块板上，

3081
01:33:56,190 --> 01:33:58,380
0,120 120,480 480,1080 1110,1860 1950,2190
your previous boards,| where would
|那个是在哪里做的？

3082
01:33:58,380 --> 01:34:00,280
0,480 480,750 750,1320
that be done?|
|

3083
01:34:01,020 --> 01:34:01,860
0,180 180,300 300,480 480,600 600,840
Where would which be done.|
在哪里哪个做呢？|

3084
01:34:02,340 --> 01:34:03,540
0,240 240,630
So like,
所以，不是元数据块，而是实际的。

3085
01:34:03,540 --> 01:34:05,490
0,240 240,570 570,900 900,1530 1530,1950
{} not the metadata blocks,

3086
01:34:05,490 --> 01:34:08,550
0,390 600,1050 1140,1500 1500,2070 2070,3060
but {} the actual.| {File,content},|
|文件内容，|好的，这是，对此有多种答案，

3087
01:34:09,180 --> 01:34:12,720
0,600 810,1500 1500,1770 2070,2640 2940,3540
alright, {okay,this,is}, { - -

3088
01:34:12,720 --> 01:34:13,770
0,150 180,390 390,570 570,660 660,1050
- -} sort of multiple

3089
01:34:13,770 --> 01:34:16,500
0,360 360,420 420,780 1020,2070
answers to this,| in
|在 ext3 中有多种模式，

3090
01:34:17,770 --> 01:34:21,040
0,540 780,1320 1320,1950 2250,2880 2880,3270
{} {ext3 -} has multiple

3091
01:34:21,040 --> 01:34:25,960
0,960 2340,3300 4200,4470 4470,4830 4830,4920
modes,| for what happens to
|对于数据块发生的情况，

3092
01:34:25,960 --> 01:34:27,640
0,90 90,360 360,720 720,780 780,1680
the data blocks,| I think
|我记得有两三个，

3093
01:34:28,340 --> 01:34:29,630
0,390 390,810 810,1020 1020,1110 1110,1290
there's three {or,two} of which

3094
01:34:29,630 --> 01:34:31,840
0,120 120,750 780,1590
I remember, {}|
|

3095
01:34:31,840 --> 01:34:34,120
0,480 480,1050 1050,1680
there's journal data
有日志数据和顺序数据，

3096
01:34:36,570 --> 01:34:38,660
0,540 540,870 870,1440
and order data,

3097
01:34:39,100 --> 01:34:40,840
0,420 420,720 930,1110 1110,1470 1470,1740
in the,| {} and when
|当你配置 ext3 文件系统时，

3098
01:34:40,840 --> 01:34:42,100
0,180 180,630 630,720 720,1050 1050,1260
you configure an {ext3 -}

3099
01:34:42,100 --> 01:34:43,960
0,240 240,630 630,810 930,1470 1470,1860
file system,| you tell Linux
|你告诉 Linux 你想要什么，

3100
01:34:43,960 --> 01:34:46,360
0,270 270,390 390,810
which you want,|

3101
01:34:47,240 --> 01:34:49,610
0,210 210,420 420,810 1230,1950 1980,2370
{} if you {} ask
如果你要求日志数据，

3102
01:34:49,610 --> 01:34:51,170
0,150 150,510 510,930 1020,1260 1260,1560
for journal data,| then file
|文件内容只是直接写入日志，

3103
01:34:51,170 --> 01:34:52,310
0,390 390,570 570,720 720,960 960,1140
content just goes write into

3104
01:34:52,310 --> 01:34:53,390
0,90 90,390 390,540 540,750 750,1080
the log,| there's nothing special
|没有什么特别的，

3105
01:34:53,390 --> 01:34:54,830
0,240 240,510 510,630 630,930 990,1440
going on,| if you write
|如果你将数据写入文件，

3106
01:34:54,830 --> 01:34:56,690
0,180 180,240 240,360 360,1050 1500,1860
data to a file| and
|引起 inode 更新，

3107
01:34:56,690 --> 01:34:57,530
0,150 150,450 450,600 600,690 690,840
that causes the {inode -}

3108
01:34:57,530 --> 01:34:59,090
0,120 120,240 240,930 1080,1290 1290,1560
to be updated,| then the
|然后日志将包含你的数据，

3109
01:34:59,630 --> 01:35:01,130
0,450 450,570 570,780 780,1260 1260,1500
log is gonna contain your

3110
01:35:01,130 --> 01:35:02,720
0,360 360,780 780,900 900,1380 1380,1590
data| and the updated an
|并更新 inode ，

3111
01:35:02,720 --> 01:35:03,860
0,600
inode,|
|

3112
01:35:04,820 --> 01:35:06,110
0,120 120,240 240,900 900,1140 1140,1290
you know everything, everything gets
所有被修改的东西都会记入日志，

3113
01:35:06,110 --> 01:35:07,310
0,450 450,660 660,720 720,780 780,1200
modified goes in the log,|
|

3114
01:35:07,760 --> 01:35:09,890
0,420 1200,1560 1560,1830 1830,2010 2010,2130
{} that's journal data.| But,
那就是日志数据。|当然，它很慢，

3115
01:35:09,890 --> 01:35:11,030
0,60 60,210 210,300 300,510 510,1140
of course it's quite slow|
|

3116
01:35:11,060 --> 01:35:12,020
0,120 120,510 510,690 690,780 780,960
or slower than you might
或者比你想象的要慢，

3117
01:35:12,020 --> 01:35:15,860
0,270 270,750 1110,1590 2190,3570 3570,3840
hope,| because {} you know,|
|因为，|

3118
01:35:16,530 --> 01:35:17,730
0,210 210,600 600,720 720,930 930,1200
now if you write a
如果你写一整串数据，

3119
01:35:17,760 --> 01:35:18,930
0,180 180,360 360,420 420,840 930,1170
whole bunch of data,| it
|它必须写一次到日志，

3120
01:35:18,930 --> 01:35:19,650
0,150 150,210 210,330 330,510 510,720
has to be written once

3121
01:35:19,650 --> 01:35:20,370
0,90 90,180 180,510 510,600 600,720
to the log| and then
|然后第二次到原位置，

3122
01:35:20,370 --> 01:35:21,300
0,60 60,420 420,720 720,840 840,930
a second time to the

3123
01:35:21,300 --> 01:35:22,770
0,150 150,630 630,930 1050,1200 1200,1470
home location,| so the journal
|所以，日志数据方案简单明了，但速度很慢。

3124
01:35:22,770 --> 01:35:25,980
0,270 270,630 630,930 2130,2940 2940,3210
data scheme is straightforward, but

3125
01:35:26,100 --> 01:35:27,440
0,360 360,810
{} slow.|
|

3126
01:35:29,320 --> 01:35:30,310
0,150 150,300 300,450 450,630 630,990
Then there's this other order
然后，还有另一种顺序数据方案，

3127
01:35:30,310 --> 01:35:32,860
0,240 240,780 1560,1800 1800,2310 2340,2550
data scheme,| that people that's
|那就是人们最流行的模式，

3128
01:35:32,860 --> 01:35:34,540
0,270 270,360 360,570 570,990 990,1680
actually the most popular mode,|
|

3129
01:35:35,970 --> 01:35:37,560
0,300 300,810 810,990 990,1380 1380,1590
{} avoid, that doesn't write
避免，不将数据写入日志，

3130
01:35:37,560 --> 01:35:38,910
0,90 90,390 390,510 510,630 630,1350
the data to the log,|
|

3131
01:35:39,440 --> 01:35:40,550
0,90 90,180 180,420 420,660 660,1110
in the order data scheme,|
在顺序数据方案中，|

3132
01:35:40,580 --> 01:35:42,680
0,570 570,1260 1290,1500 1530,1830 1830,2100
only metadata like {inodes -
只有像 inode 和目录块这样的元数据才会写入日志，

3133
01:35:42,680 --> 01:35:43,910
0,90 90,180 180,690 690,1140 1140,1230
-} and directory blocks are

3134
01:35:43,910 --> 01:35:45,500
0,210 210,330 330,420 420,960 1140,1590
written to the log| and
|而文件内容块直接写入文件系统中的原位置，

3135
01:35:45,980 --> 01:35:47,180
0,360 360,720 720,930 930,1020 1020,1200
file content block is just

3136
01:35:47,180 --> 01:35:48,770
0,240 240,960 990,1140 1140,1380 1380,1590
written directly to the home

3137
01:35:48,770 --> 01:35:50,120
0,540 540,600 600,690 690,960 960,1350
locations in the file system|
|

3138
01:35:51,320 --> 01:35:52,250
0,210 210,360 360,720 720,750 750,930
and so it's a lot
所以它的速度要快得多，

3139
01:35:52,250 --> 01:35:53,680
0,390 390,840
faster,| because
|因为你不必写入文件内容两次，

3140
01:35:53,890 --> 01:35:54,460
0,150 150,240 240,330 330,420 420,570
you don't have to write

3141
01:35:54,460 --> 01:35:56,590
0,120 120,330 330,660 660,1230 1980,2130
the file content twice,| it
|这确实会导致更复杂的情况，

3142
01:35:56,590 --> 01:35:57,790
0,210 210,390 390,450 450,600 600,1200
does lead to more complexity

3143
01:35:57,790 --> 01:35:59,680
0,210 210,870 900,1410
though,| because {}
|因为如果，

3144
01:36:02,640 --> 01:36:04,110
0,180 180,510 510,1080 1080,1290 1290,1470
if you,| you can't just
|你不能随时写文件数据，

3145
01:36:04,110 --> 01:36:05,700
0,240 240,330 330,660 660,1170 1170,1590
write the file data anytime

3146
01:36:05,700 --> 01:36:07,620
0,120 120,750 930,1530 1530,1740 1740,1920
you want,| because then there's
|因为这样会有风险，

3147
01:36:07,620 --> 01:36:09,180
0,90 90,540 540,990
a risk that,|
|

3148
01:36:09,180 --> 01:36:10,300
0,540

3149
01:36:10,360 --> 01:36:11,470
0,420 420,510 510,660 660,870 870,1110
if you don't worry about
如果你不担心你写 inode 的顺序，

3150
01:36:11,470 --> 01:36:12,190
0,90 90,390 390,450 450,630 630,720
the order in which you

3151
01:36:12,190 --> 01:36:13,450
0,180 180,480 480,660 660,1020 1020,1260
write the {inodes -},| there's
|文件数据存在这样的风险，

3152
01:36:13,450 --> 01:36:14,740
0,90 90,360 360,720 840,1200 1200,1290
the file data, there's the

3153
01:36:14,740 --> 01:36:16,390
0,420 420,690 780,1200 1200,1320 1320,1650
risk,| that {} you might
|你可能执行写入操作，

3154
01:36:16,750 --> 01:36:18,250
0,780 810,1020 1020,1140 1140,1410 1410,1500
{} do a write,| that
|导致为文件分配新的块，

3155
01:36:18,250 --> 01:36:19,510
0,510 510,630 630,840 840,1200 1200,1260
causes a new block to

3156
01:36:19,510 --> 01:36:21,790
0,150 150,720 720,930 930,1560 1800,2280
be allocated for file {}|
|

3157
01:36:22,030 --> 01:36:23,740
0,210 210,540 540,900 960,1560 1560,1710
and have the updated {inode
并将更新后的 inode 写入日志并提交，

3158
01:36:23,740 --> 01:36:25,690
0,720 780,1320 1350,1650 1650,1830 1830,1950
-} be written into the

3159
01:36:25,690 --> 01:36:27,400
0,540 540,660 660,1230 1290,1590 1590,1710
log and committed| and then
|然后发生崩溃，

3160
01:36:27,400 --> 01:36:28,810
0,120 120,210 210,660 660,1050 1050,1410
have a crash happen,| before
|在你写入实际文件内容到磁盘之前，

3161
01:36:28,810 --> 01:36:30,460
0,210 420,810 810,1170 1170,1290 1290,1650
you get around to writing

3162
01:36:30,460 --> 01:36:31,780
0,120 120,450 450,750 750,1230 1230,1320
the actual file content to

3163
01:36:31,780 --> 01:36:33,280
0,180 180,720 930,1140 1140,1230 1230,1500
the disk,| and then after
|然后在恢复之后，

3164
01:36:33,280 --> 01:36:34,480
0,750
recovery,|
|

3165
01:36:34,510 --> 01:36:35,530
0,240 240,480 480,570 570,690 690,1020
{} what you would see
你将看到的是，

3166
01:36:35,530 --> 01:36:37,030
0,300 330,780 840,1050 1050,1350 1350,1500
is| the {inode -} with
|包含新分配的数据块的 inode ，

3167
01:36:37,030 --> 01:36:38,500
0,90 90,420 450,750 750,1230 1230,1470
the new newly allocated data

3168
01:36:38,500 --> 01:36:41,230
0,540 840,1140 1140,1380 1410,2160 2190,2730
block,| but the old contents
|但是数据块的旧内容

3169
01:36:41,230 --> 01:36:42,250
0,60 60,270 270,510 510,870 870,1020
of that data block| from
|来自之前使用该数据块的文件，

3170
01:36:42,250 --> 01:36:44,620
0,630 660,1290 1290,1980 1980,2190 2190,2370
whatever file previously used that

3171
01:36:44,620 --> 01:36:45,800
0,240 240,720
data block,|
|

3172
01:36:45,890 --> 01:36:47,810
0,510 600,840 840,1050 1050,1470 1740,1920
{} and so if you're
所以，如果你运行的系统有多个用户，比如 Athena ，

3173
01:36:47,810 --> 01:36:48,590
0,210 210,300 300,570 570,660 660,780
running a system that has

3174
01:36:48,590 --> 01:36:50,450
0,330 330,690 690,810 810,1320 1350,1860
multiple users, like Athena system,|
|

3175
01:36:50,660 --> 01:36:52,100
0,720 810,990 990,1200 1200,1320 1320,1440
then it could be that
可能是一个用户最终

3176
01:36:52,100 --> 01:36:53,480
0,270 270,630 630,810 810,1140 1140,1380
one user will end up|
|

3177
01:36:53,480 --> 01:36:55,250
0,240 240,330 330,840 840,1110 1110,1770
having a file that contains
拥有的文件包含另一个用户已删除文件的内容。

3178
01:36:55,250 --> 01:36:57,260
0,510 510,690 690,1110 1110,1560 1560,2010
contents from another user's deleted

3179
01:36:57,260 --> 01:36:58,280
0,480
file.|
|

3180
01:36:58,650 --> 01:36:59,670
0,150 150,240 240,450 450,810 810,1020
If we're not careful about
如果我们不注意顺序，

3181
01:36:59,670 --> 01:37:00,930
0,120 120,480 480,540 540,720 720,1260
the order| in which we
|写入数据与 inode 的顺序。

3182
01:37:01,200 --> 01:37:03,030
0,300 300,420 420,960 1020,1470 1470,1830
write the data versus the

3183
01:37:03,360 --> 01:37:05,860
0,180 180,990
{inode -}.|
|

3184
01:37:06,550 --> 01:37:08,170
0,270 270,720 720,990 990,1380 1380,1620
A {ext3 -} order data
ext3 顺序数据模式解决这个，

3185
01:37:08,170 --> 01:37:11,710
0,300 300,750 750,1140 1290,2100 2760,3540
mode solves this,| by not
|通过不提交修改的 inode ，

3186
01:37:11,710 --> 01:37:14,050
0,690 690,1200 1200,1800 1800,1980 1980,2340
committing a modified {inode -}|
|

3187
01:37:14,050 --> 01:37:16,510
0,360 480,1410 1530,1680 1680,2010 2010,2460
until after the file content
直到文件内容写入磁盘之后，

3188
01:37:16,510 --> 01:37:17,800
0,240 240,390 390,600 600,660 660,1290
has been written to disk,|
|

3189
01:37:18,040 --> 01:37:19,090
0,150 150,210 210,390 390,900 900,1050
so if your application and
所以，如果你的应用程序写入文件，

3190
01:37:19,090 --> 01:37:20,170
0,90 90,300 300,390 390,480 480,1080
you write to a file|
|

3191
01:37:20,710 --> 01:37:21,850
0,330 330,600 600,780 780,1080 1080,1140
and that write causes a
那个写入导致分配新的块，

3192
01:37:21,850 --> 01:37:23,380
0,150 150,450 450,660 690,840 840,1530
new block to be allocated,|
|

3193
01:37:23,800 --> 01:37:25,390
0,240 240,390 390,750 750,1230 1230,1590
{} the file system will
文件系统将新文件内容写入新分配的块，

3194
01:37:25,630 --> 01:37:27,430
0,480 480,570 570,810 810,1260 1260,1800
write the new file content

3195
01:37:27,430 --> 01:37:28,900
0,90 90,180 180,450 450,930 930,1470
to the newly allocated block,|
|

3196
01:37:29,080 --> 01:37:30,010
0,240 240,450 450,630 630,810 810,930
and once that write is
一旦写入完成，

3197
01:37:30,010 --> 01:37:31,660
0,510 540,1080 1080,1350 1350,1500 1500,1650
finished,| only then will it
|它才会提交事务。

3198
01:37:31,660 --> 01:37:33,700
0,600 630,750 750,1680
commit the transaction.|
|

3199
01:37:33,760 --> 01:37:34,860
0,540

3200
01:37:34,860 --> 01:37:36,780
0,570 1020,1440 1440,1590 1590,1800 1800,1920
That causes the {inode -}
这导致 inode 更新为包含新的块编号，

3201
01:37:36,780 --> 01:37:37,620
0,60 60,180 180,630 630,690 690,840
to be updated to have

3202
01:37:37,620 --> 01:37:38,880
0,60 60,210 210,510 510,1050 1110,1260
the new block number| and
|这意味着，崩溃，

3203
01:37:38,880 --> 01:37:41,130
0,150 150,450 450,960 1230,1380 1380,2250
that means that a crash,|
|

3204
01:37:41,250 --> 01:37:42,150
0,150 150,300 300,360 360,780 780,900
if there's a crash is
如果崩溃发生在，

3205
01:37:42,150 --> 01:37:43,320
0,180 180,270 270,630 630,1020 1020,1170
going to happen| between when
|写入数据时，

3206
01:37:43,320 --> 01:37:44,760
0,120 120,330 330,420 420,900 1020,1440
you wrote the data,| after
|写入数据之后和写入 inode 之前，

3207
01:37:44,760 --> 01:37:45,480
0,60 60,240 240,300 300,540 540,720
you wrote the data and

3208
01:37:45,480 --> 01:37:46,320
0,330 330,450 450,600 600,750 750,840
before you wrote the {inode

3209
01:37:46,320 --> 01:37:48,870
0,330 390,840 840,1200 1200,1860 2220,2550
-},| therefore won't reveal {}
|不会显示别人删除的旧数据块

3210
01:37:48,900 --> 01:37:51,120
0,420 420,870 870,1440 1500,1950 1950,2220
somebody else's old deleted data

3211
01:37:51,120 --> 01:37:52,000
0,510
block|
|

3212
01:37:52,060 --> 01:37:53,110
0,150 150,330 330,420 420,570 570,1050
{} to the new user
给新用户文件。

3213
01:37:53,110 --> 01:37:54,100
0,480
file.|
|

3214
01:37:56,790 --> 01:37:58,480
0,420 420,600 600,930
Okay, I see.|
好的，我明白了。|

3215
01:37:58,630 --> 01:37:59,650
0,360 360,480 480,780 780,960 960,1020
Okay, I see,| but it
好的，我明白了，|但是它仍然可以有数据，而没有 inode 。

3216
01:37:59,650 --> 01:38:00,820
0,210 210,450 450,780 780,900 900,1170
could still have the data,

3217
01:38:00,820 --> 01:38:02,500
0,360 390,900 900,1020 1020,1170 1170,1680
but not the {inode -}.|
|

3218
01:38:03,310 --> 01:38:05,380
0,150 150,270 270,600 600,1200 1200,2070
Yeah, you might allocate.| Yeah,
是的，你可能分配。|是的，如果发生崩溃，

3219
01:38:06,310 --> 01:38:07,270
0,120 120,270 270,330 330,660 660,960
it was a crash,| after
|在你写入数据块之后，写入 inode 之前，

3220
01:38:07,270 --> 01:38:08,230
0,300 300,630 630,690 690,900 900,960
you after you wrote the

3221
01:38:08,230 --> 01:38:09,250
0,210 210,420 420,750 750,810 810,1020
data block before you wrote

3222
01:38:09,250 --> 01:38:11,080
0,120 120,270 270,600 600,1290 1560,1830
the {inode -},| then you
|那么你已经更新了数据块，

3223
01:38:11,080 --> 01:38:12,160
0,150 150,540 540,630 630,870 870,1080
have updated the data block,|
|

3224
01:38:12,160 --> 01:38:13,480
0,90 90,180 180,450 450,900 900,1320
but it doesn't matter,| because
但这并不重要，|因为你不仅没有写 inode ，

3225
01:38:13,540 --> 01:38:14,650
0,480 480,660 660,810 810,900 900,1110
not only did you not

3226
01:38:14,650 --> 01:38:15,550
0,180 180,330 330,480 480,780 780,900
write the {inode -},| you
|你也没有写更新块，空闲位图块，

3227
01:38:15,550 --> 01:38:17,800
0,240 240,510 510,930 930,1320 1350,2250
also didn't write the updated

3228
01:38:18,560 --> 01:38:20,870
0,960 990,1590 1590,1770 1770,1980 1980,2310
block, free {bitmap -} block,|
|

3229
01:38:21,290 --> 01:38:22,700
0,480 480,600 600,690 690,1110 1110,1410
blocks will be free and
块是空闲的，并且可以分配给其他东西，

3230
01:38:22,700 --> 01:38:23,810
0,180 180,300 300,750 750,840 840,1110
could be allocated for something

3231
01:38:23,810 --> 01:38:24,800
0,360 390,540 540,630 630,810 810,990
else,| so would not even
|所以一个块都不会丢。

3232
01:38:24,800 --> 01:38:25,980
0,180 180,240 240,660
lose a block.|
|

3233
01:38:26,730 --> 01:38:28,440
0,510 720,870 870,990 990,1500 1500,1710
Alright, and if it's an
好的，如果是老块，

3234
01:38:28,440 --> 01:38:30,210
0,240 240,570 570,960 990,1230 1230,1770
old block,| then it's still
|那还是可以的，对吧。

3235
01:38:30,210 --> 01:38:33,270
0,630 960,1410 1890,2280 2700,2940 2940,3060
okay, right.| {Say,it,again}.| If it
|再说一遍。|如果只是，

3236
01:38:33,270 --> 01:38:34,360
0,180 180,540
was just,|
|

3237
01:38:34,360 --> 01:38:35,620
0,90 90,210 210,330 330,1050 1080,1260
it is the same, the
它是一样的块，写入新的数据，

3238
01:38:35,620 --> 01:38:36,970
0,210 210,570 570,900 900,1200 1200,1350
same block just write some

3239
01:38:36,970 --> 01:38:38,440
0,150 150,480 480,660 660,930 960,1470
new data to it,| but
|但是一样的块，一样的大小，一样的位置，

3240
01:38:38,650 --> 01:38:40,800
0,360 360,690 690,960 960,1680
same block, same size,

3241
01:38:40,890 --> 01:38:44,080
0,600 750,1530 1620,1860 1860,2640
{} same same location,|
|

3242
01:38:44,900 --> 01:38:46,850
0,360 390,630 630,1140 1140,1620 1620,1950
but we already wrote,| like
但是我们已经写入，|比如不是我们创建一个新的块，

3243
01:38:46,880 --> 01:38:48,080
0,240 240,600 600,750 750,840 840,1200
it's not that we created

3244
01:38:48,080 --> 01:38:49,550
0,90 90,300 300,690 690,960 990,1470
a new block,| but in
|而是在旧的块，我们写入一些额外的数据，

3245
01:38:49,550 --> 01:38:51,800
0,240 270,630 630,1320 1350,1830 1860,2250
the old block, we just

3246
01:38:51,830 --> 01:38:53,450
0,390 390,570 570,990 990,1350 1350,1620
wrote some extra data,| but
|但它有一点，

3247
01:38:53,450 --> 01:38:54,380
0,210 210,420 420,480 480,720 720,930
it was a little bit,|
|

3248
01:38:54,380 --> 01:38:55,430
0,180 180,330 330,720 750,990 990,1050
so it didn't need to
所以它不需要创造一个新的。

3249
01:38:55,430 --> 01:38:56,700
0,240 240,750
create {a,new,one}.|
|

3250
01:38:57,220 --> 01:38:58,420
0,270 270,450 450,750 750,1080 1080,1200
Yeah, we wrote data,| we
是的，我们写入数据，|我们最终将数据写入块中，

3251
01:38:58,420 --> 01:38:59,320
0,240 240,330 330,600 600,720 720,900
ended up writing to a

3252
01:38:59,500 --> 01:39:01,360
0,390 390,630 630,990 1260,1740 1740,1860
data to a block,| that
|它没有被任何文件使用，

3253
01:39:01,360 --> 01:39:02,260
0,150 150,360 360,510 510,750 750,900
was not in use by

3254
01:39:02,260 --> 01:39:03,460
0,210 210,660
any file,|
|

3255
01:39:03,830 --> 01:39:06,980
0,900 900,1080 1080,1650 2190,2640 2880,3150
it's not visible.| Right, okay
它是不可见的。|好的，我明白了，|

3256
01:39:06,980 --> 01:39:08,740
0,120 120,360 360,660 660,1140
I see,| thank you,
|谢谢。再见。

3257
01:39:09,150 --> 01:39:10,420
0,720
goodbye.
