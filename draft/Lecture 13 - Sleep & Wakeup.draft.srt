1
00:00:05,470 --> 00:00:07,390
0,720 750,1380 1410,1710 1710,1800 1800,1920
Alright, {I'd} like to get
好的，我要开始了，

2
00:00:07,390 --> 00:00:09,640
0,690 750,1110 1200,1590 1590,1830 1830,2250
started,| can anyone hear me?|
|有人能听到我说话吗？|

3
00:00:10,750 --> 00:00:12,100
0,540
{Yep,loud,and,clear}.|
是的，声音很大，而且清楚。|

4
00:00:12,270 --> 00:00:14,310
0,600 600,990 1110,1470 1470,1620 1620,2040
Alright, so today my plan
好的，那么今天我的计划是，

5
00:00:14,310 --> 00:00:15,240
0,240 240,420 420,690 690,750 750,930
is| for first I want
|首先，我想花几分钟

6
00:00:15,240 --> 00:00:16,320
0,60 60,270 270,300 300,510 510,1080
to spend a few minutes|
|

7
00:00:16,320 --> 00:00:18,900
0,510 750,1170 1170,1800 1800,1980 1980,2580
{} {re-emphasizing -} some points
重新强调上周课程中关于线程切换的一些观点，

8
00:00:18,900 --> 00:00:20,490
0,480 480,720 750,1020 1020,1380 1380,1590
from the lecture last week

9
00:00:20,490 --> 00:00:22,530
0,240 240,630 630,1110 1110,1680 1890,2040
on thread switching,| because they
|因为它们是重要的观点，

10
00:00:22,530 --> 00:00:23,280
0,180 180,270 270,330 330,390 390,750
turned out to be important

11
00:00:23,280 --> 00:00:24,780
0,480 480,990 990,1020 1020,1260 1260,1500
points,| and I would spend
|我会用这节课的大部分时间讨论一个称为协作的东西，

12
00:00:24,780 --> 00:00:25,740
0,210 210,270 270,330 330,660 660,960
most of the lecture talking

13
00:00:25,740 --> 00:00:29,610
0,390 660,930 930,1350 1530,2760 3390,3870
about something called coordination| which
|它是 xv6 休眠唤醒机制的大的术语，

14
00:00:29,610 --> 00:00:30,750
0,90 90,180 180,510 510,780 780,1140
is the larger term for

15
00:00:30,900 --> 00:00:32,250
0,240 240,360 360,600 600,1020 1020,1350
{xv6 - -} sleeping wakeup

16
00:00:32,250 --> 00:00:34,470
0,600 750,990 990,1740 1860,2070 2070,2220
mechanism| and particularly I'm going
|我要特别谈一下唤醒丢失的问题。

17
00:00:34,470 --> 00:00:35,280
0,60 60,210 210,330 330,450 450,810
to talk about the lost

18
00:00:35,280 --> 00:00:36,400
0,330 330,750
wakeup problem.|
|

19
00:00:36,900 --> 00:00:40,020
0,570 690,1140 1440,1980 2160,2940 2940,3120
Alright, so, {} one, {}
好的，有一点我想再提一下，

20
00:00:40,020 --> 00:00:40,770
0,210 210,450 450,510 510,660 660,750
one point I want to

21
00:00:40,770 --> 00:00:42,810
0,330 330,630 630,1230 1260,1530 1530,2040
just mention again is that,|
|

22
00:00:42,840 --> 00:00:44,020
0,570

23
00:00:46,620 --> 00:00:47,790
0,150 150,240 240,630 630,1020 1020,1170
is the fact that {xv6
是 xv6 当有东西调用 swtch ，

24
00:00:47,790 --> 00:00:50,610
0,150 150,600 600,1410 1650,2370 2460,2820
- -} whenever {} anything

25
00:00:50,610 --> 00:00:53,490
0,300 300,960 960,1110 1110,1950 2370,2880
calls switch| to switch from
|要从一个线程切换到另一个线程，

26
00:00:53,490 --> 00:00:55,020
0,210 210,450 450,570 570,1080 1230,1530
one thread to another,| usually
|通常从内核线程到调度器线程，

27
00:00:55,020 --> 00:00:56,340
0,210 210,420 540,960 960,1230 1230,1320
from a kernel thread to

28
00:00:56,340 --> 00:00:58,650
0,240 240,690 690,1080 1290,1830 1980,2310
the scheduler thread,| {} it's
|它总是在预先获取这个进程的锁。

29
00:00:58,650 --> 00:01:01,560
0,330 330,1350 1680,1980 1980,2100 2100,2910
always preceded by an acquire

30
00:01:01,560 --> 00:01:05,480
0,720 1440,1860 1860,2820 2850,3510
of this process's lock.|
|

31
00:01:06,050 --> 00:01:08,180
0,600 660,990 990,1590 1590,1950 1950,2130
{} So process requires this
所以进程获取这个锁调用 swtch ，

32
00:01:08,180 --> 00:01:10,460
0,330 330,570 570,1230 1530,1920 1920,2280
lock call swtch,| {} which
|它总是切换到调度器，

33
00:01:10,460 --> 00:01:11,780
0,270 270,630 630,780 780,870 870,1320
always switches into the scheduler|
|

34
00:01:11,780 --> 00:01:12,710
0,90 90,210 210,300 300,780 780,930
and it's the scheduler that
而调度器释放那个锁。

35
00:01:12,710 --> 00:01:14,580
0,390 390,510 510,990
releases the lock.|
|

36
00:01:14,730 --> 00:01:17,880
0,540 1830,2190 2190,2340 2340,2760 2760,3150
{ -} In fact almost
事实上，顺序是这样的，

37
00:01:17,880 --> 00:01:18,900
0,240 240,330 330,690 690,870 870,1020
always the sequence looks more

38
00:01:18,900 --> 00:01:21,030
0,210 210,720 780,810 810,1410 1410,2130
like this| or a process
|或者一个进程因为某种原因想要休眠，

39
00:01:21,090 --> 00:01:21,690
0,210 210,390 390,450 450,510 510,600
who wants to go to

40
00:01:21,690 --> 00:01:22,830
0,270 270,360 360,570 570,990 990,1140
sleep for some reason,| it's
|它让出 CPU 等待某些东西，

41
00:01:22,830 --> 00:01:24,090
0,360 360,450 450,930 930,1020 1020,1260
yielding the CPU for waiting

42
00:01:24,090 --> 00:01:25,560
0,90 90,570 750,1050 1050,1110 1110,1470
for something| and it acquires
|它会获取自己的锁，

43
00:01:25,560 --> 00:01:26,910
0,60 60,360 360,450 450,1110 1140,1350
a lock on itself,| it
|设置自己的状态，

44
00:01:26,910 --> 00:01:29,060
0,510 510,750 750,1620
sets its state,|
|

45
00:01:29,090 --> 00:01:30,660
0,990

46
00:01:30,660 --> 00:01:31,590
0,390 390,600 600,630 630,870 870,930
and there's a number of
这里有很多状态，

47
00:01:31,590 --> 00:01:32,940
0,210 210,660 660,870 870,960 960,1350
different states,| what we see
|我们上周看到的，

48
00:01:32,940 --> 00:01:34,230
0,120 120,270 270,600 600,810 810,1290
we saw last week was,|
|

49
00:01:34,260 --> 00:01:35,730
0,390 540,900 900,1170 1170,1290 1290,1470
{} set state to {runnable
将状态从运行中设置为可运行，

50
00:01:35,730 --> 00:01:36,720
0,90 90,450
- -}

51
00:01:38,370 --> 00:01:40,350
0,300 300,420 420,990 1290,1800 1800,1980
instead of running,| {} and
|然后调用 swtch ，

52
00:01:40,350 --> 00:01:42,630
0,150 150,360 360,1140 1500,1620 1620,2280
then call swtch| or sched
|或者调用 sched 来调用 swtch 。

53
00:01:42,630 --> 00:01:45,420
0,630 840,1290 1290,1560 1560,2190
which itself calls swtch.|
|

54
00:01:45,910 --> 00:01:47,860
0,390 990,1380 1380,1710 1740,1860 1860,1950
{} And that you know
这个 swtch 是将线程切换到调度器线程，

55
00:01:47,860 --> 00:01:50,650
0,210 210,840 840,1290 1290,1860 1860,2790
this switch basically switches threads

56
00:01:51,340 --> 00:01:53,320
0,360 360,600 600,780 780,1290 1290,1980
over into the scheduler thread,|
|

57
00:01:53,900 --> 00:01:56,180
0,600 600,810 810,1350 1470,1950 1950,2280
which so as previous call
与之前调用 swtch 一样，

58
00:01:56,180 --> 00:01:58,130
0,90 90,570 570,750 750,1050 1320,1950
to swtch,| {} this scheduler
|这个调度器线程返回。

59
00:01:58,130 --> 00:01:59,860
0,240 240,1260
thread returns.|
|

60
00:02:00,390 --> 00:02:02,190
0,780 1020,1290 1290,1440 1440,1650 1650,1800
{} And then this was
然后调度器线程释放这个进程的锁，

61
00:02:02,640 --> 00:02:07,320
0,570 600,2610 2610,3330 3450,3960 3960,4680
{} scheduler thread calls release

62
00:02:07,320 --> 00:02:09,620
0,630 990,1800
on {}

63
00:02:09,850 --> 00:02:10,960
0,210 210,450 450,510 510,600 600,1110
the lock of the process,|
|

64
00:02:10,960 --> 00:02:12,910
0,510 540,840 840,1260 1260,1320 1320,1950
that's just yielded the CPU.|
让出CPU 。|

65
00:02:13,960 --> 00:02:15,920
0,480

66
00:02:16,370 --> 00:02:18,320
0,420 420,840 840,960 960,1410 1560,1950
The reason for this, just
这样做的原因，只是重复一下，是因为，

67
00:02:18,320 --> 00:02:20,510
0,90 90,720 960,1500 1710,1920 1920,2190
to repeat, {} is that,|
|

68
00:02:20,750 --> 00:02:21,900
0,570

69
00:02:22,130 --> 00:02:24,170
0,510 510,1080 1080,1170 1170,1350 1350,2040
the acquisition of this lock
获取进程上的锁

70
00:02:24,200 --> 00:02:25,940
0,300 300,360 360,810 810,1620 1620,1740
on the process| prevents the
|会阻止不同核心的调度器，

71
00:02:25,940 --> 00:02:27,890
0,570 570,720 720,840 840,1230 1230,1950
scheduler on a different core|
|

72
00:02:27,980 --> 00:02:30,830
0,600 1230,1680 1740,2490 2490,2730 2730,2850
from from looking right at
在这个时间点上查看，

73
00:02:30,830 --> 00:02:33,080
0,300 300,630 630,750 750,1530 1830,2250
this point in time, {}|
|

74
00:02:33,080 --> 00:02:34,550
0,240 240,660 660,870 870,870 870,1470
and saying that, oh this
然后说，这个线程是可运行的，并试图运行它，

75
00:02:34,550 --> 00:02:37,190
0,570 570,930 930,1650 1800,2370 2400,2640
thread is runnable and trying

76
00:02:37,190 --> 00:02:38,600
0,120 120,360 360,690 930,1170 1170,1410
to run it,| because every
|因为每个其他核心也许运行一个调度器循环，

77
00:02:38,600 --> 00:02:39,740
0,150 150,480 480,750 750,1020 1020,1140
other core maybe running a

78
00:02:39,740 --> 00:02:42,500
0,540 540,1140 1590,1920 1920,2040 2040,2760
scheduler loop,| which is continually
|它不断地在进程表上循环，

79
00:02:42,500 --> 00:02:44,160
0,360 360,600 600,1170
looping over the

80
00:02:44,280 --> 00:02:46,020
0,420 420,870 900,1290 1290,1440 1440,1740
process table,| looking for runnable
|寻找可运行的线程，

81
00:02:46,020 --> 00:02:47,670
0,630 720,1080 1080,1290 1290,1440 1440,1650
threads,| {} so any one
|所以它们中的任何一个都可能看到这个线程是可运行的，

82
00:02:47,670 --> 00:02:48,720
0,90 90,300 300,600 600,900 900,1050
of them may see that

83
00:02:48,720 --> 00:02:50,370
0,150 150,390 390,480 480,1020 1290,1650
this thread is runnable,| if
|如果我们没有获取进程锁，

84
00:02:50,370 --> 00:02:51,780
0,120 120,450 450,840 840,930 930,1410
we hadn't acquired the process

85
00:02:51,780 --> 00:02:53,190
0,480 750,1050 1050,1170 1170,1260 1260,1410
lock,| {} so the fact
|所以我们获得进程锁意味着，

86
00:02:53,190 --> 00:02:54,030
0,90 90,180 180,420 420,480 480,840
that we acquired the process

87
00:02:54,030 --> 00:02:55,140
0,240 240,420 420,630 750,960 960,1110
lock means| that the other
|其他调度器，在查看进程状态之前，

88
00:02:55,140 --> 00:02:56,790
0,540 540,870 870,1140 1140,1380 1380,1650
schedulers, before they even look

89
00:02:56,790 --> 00:02:57,930
0,90 90,240 240,630 630,720 720,1140
at a process of state,|
|

90
00:02:58,080 --> 00:02:59,640
0,630 630,990 990,1140 1140,1440 1440,1560
must acquire its lock.| So
必须取得它的锁。|所以我们知道这次获得之后，

91
00:02:59,640 --> 00:03:01,290
0,90 90,360 360,720 720,930 930,1650
we know after this acquisition,|
|

92
00:03:01,350 --> 00:03:02,400
0,390 390,540 540,870 870,990 990,1050
no other threads going to
没有其他线程会查看该锁。

93
00:03:02,400 --> 00:03:03,600
0,150 150,210 210,330 330,720 840,1200
look at the lock.| We
|我们不能在这里放弃锁，

94
00:03:03,600 --> 00:03:04,950
0,420 420,600 600,840 840,960 960,1350
can't give up the lock

95
00:03:04,950 --> 00:03:05,910
0,330 330,510 510,600 600,810 810,960
here though,| we can't give
|我们不能在调用 swtch 之前放弃锁，

96
00:03:05,910 --> 00:03:07,380
0,150 150,270 270,720 720,1140 1140,1470
up the lock before calling

97
00:03:07,380 --> 00:03:09,150
0,630 630,780 780,1200 1350,1530 1530,1770
swtch,| that is this thread
|也就是说，这个线程获取锁，

98
00:03:09,150 --> 00:03:10,050
0,390 390,450 450,720 720,840 840,900
acquires the lock,| but it
|但它不能放弃它，

99
00:03:10,050 --> 00:03:11,730
0,240 240,360 360,450 450,870 1080,1680
can't give it up,| because
|因为如果我们这么做了，

100
00:03:11,730 --> 00:03:13,140
0,90 90,210 210,570 570,990 1020,1410
if we did,| then right
|那么在我们放弃之后，

101
00:03:13,140 --> 00:03:14,250
0,270 270,420 420,630 630,690 690,1110
after we gave it up,|
|

102
00:03:14,340 --> 00:03:17,010
0,390 390,900 1590,1980 1980,2520 2520,2670
some other core scheduler would
某个其他核心的调度器可能会开始运行这个进程，

103
00:03:17,010 --> 00:03:18,750
0,330 330,660 660,900 900,1050 1050,1740
probably start running this process,|
|

104
00:03:18,780 --> 00:03:20,730
0,360 360,900 1110,1530 1530,1800 1800,1950
even though the thread is
即使那个线程当前正在这个核心上运行。

105
00:03:20,730 --> 00:03:22,530
0,480 480,990 1020,1230 1230,1440 1440,1800
currently running on this core.|
|

106
00:03:22,960 --> 00:03:24,400
0,210 210,420 420,810 810,1230 1230,1440
And having two cores run
让两个核心运行相同的线程，使用相同的堆栈，

107
00:03:24,400 --> 00:03:26,140
0,60 60,420 420,1110 1230,1650 1650,1740
the same thread, using the

108
00:03:26,140 --> 00:03:28,400
0,270 270,720 720,1260
same stack,| is
|会造成瞬间的崩溃。

109
00:03:28,550 --> 00:03:29,690
0,390 480,660 660,870 870,930 930,1140
{} would cause a pretty

110
00:03:29,690 --> 00:03:31,200
0,300 300,990
instant crash.|
|

111
00:03:31,980 --> 00:03:34,350
0,240 240,900 960,1530 1590,1950 1950,2370
And therefore the process acquires
所以，进程获取锁，

112
00:03:34,350 --> 00:03:35,730
0,510 540,690 690,1020 1020,1320 1320,1380
lock| and does release it
|在调用 swtch 时释放它，

113
00:03:35,730 --> 00:03:36,690
0,90 90,330 330,720 720,810 810,960
at called swtch| and {}
|不同的线程，即调度器线程释放锁，

114
00:03:36,690 --> 00:03:38,490
0,450 450,840 840,1140 1140,1260 1260,1800
different thread, namely the scheduler

115
00:03:38,490 --> 00:03:40,890
0,450 630,1440 1440,1890 1890,2010 2010,2400
thread actually releases the lock,|
|

116
00:03:40,920 --> 00:03:42,240
0,120 120,180 180,540 570,1110 1110,1320
at a point after this
在这个线程完全停止使用其自己的堆栈之后，

117
00:03:42,240 --> 00:03:44,130
0,480 540,840 840,1230 1230,1650 1650,1890
thread has completely stopped using

118
00:03:44,130 --> 00:03:45,300
0,180 180,330 330,900 930,1110 1110,1170
its own stack,| so at
|这时另一个内核的调度器运行这个线程是可以的，

119
00:03:45,300 --> 00:03:46,380
0,180 180,390 390,540 540,900 900,1080
this point, it's okay for

120
00:03:46,380 --> 00:03:48,960
0,540 750,1350 1350,2130
another core scheduler

121
00:03:49,270 --> 00:03:51,610
0,690 960,1530 1530,1710 1710,2040 2040,2340
{} running this thread,| because
|因为线程现在不再运行，

122
00:03:51,610 --> 00:03:53,110
0,90 90,360 360,630 630,1170 1230,1500
the thread is now no

123
00:03:53,110 --> 00:03:54,610
0,270 270,660 960,1140 1140,1290 1290,1500
longer running| and has given
|并且已经放弃了处理器。

124
00:03:54,610 --> 00:03:56,950
0,870 1230,1530 1530,1650 1650,1740 1740,2340
up given up the processor.|
|

125
00:03:58,920 --> 00:04:00,240
0,450 570,720 720,900 900,960 960,1320
Okay, so that's an important
好的，这是很重要的一点，

126
00:04:00,240 --> 00:04:02,070
0,480 810,1080 1080,1470 1470,1650 1650,1830
point| and it'll come up
|它几分钟后会出来，

127
00:04:02,070 --> 00:04:02,970
0,90 90,150 150,330 330,750 750,900
in a few minutes,| it's
|这是诸多限制之一，

128
00:04:02,970 --> 00:04:04,200
0,150 150,210 210,330 330,570 570,1230
one of the many constraints|
|

129
00:04:04,200 --> 00:04:05,580
0,120 120,210 210,840 840,990 990,1380
on the design of the
在 sleep wakeup 协同机制的设计上。

130
00:04:05,610 --> 00:04:07,650
0,540 540,780 780,960 960,1530 1530,2040
sleep {wakeup -} coordination scheme.|
|

131
00:04:09,040 --> 00:04:10,820
0,210 210,720 720,1350
Any questions about
关于 swtch 持有 p->lock ，有什么问题吗？

132
00:04:11,150 --> 00:04:12,710
0,210 210,630 630,870 870,1050 1050,1560
this {holding -} of the

133
00:04:12,890 --> 00:04:15,220
0,390 390,720 720,1110 1110,1830
{p->lock -} across switch?|
|

134
00:04:19,200 --> 00:04:20,920
0,660 660,1110
Yeah, if.|
是的，如果。|

135
00:04:20,920 --> 00:04:22,930
0,570 660,960 960,1050 1050,1290 1290,2010
Yes.| When we have multiple
是的。|当我们有多个核心时，

136
00:04:22,930 --> 00:04:24,700
0,780 840,990 990,1230 1230,1560 1560,1770
cores,| the only reason they're
|它们能看到相同的锁的唯一原因是，

137
00:04:24,700 --> 00:04:26,650
0,420 420,960 990,1230 1230,1290 1290,1950
able to have the same

138
00:04:26,770 --> 00:04:27,820
0,390 390,540 540,630 630,930 930,1050
view of the lock is,|
|

139
00:04:27,820 --> 00:04:29,800
0,330 330,600 600,1050 1050,1470 1470,1980
because there's a single shared
因为只有一个共享的物理内存系统，是吗？

140
00:04:29,800 --> 00:04:32,050
0,570 570,960 960,1440 1440,1800 2040,2250
physical memory system right?| That
|这是正确的。

141
00:04:32,050 --> 00:04:33,360
0,90 90,750
is correct.|
|

142
00:04:33,610 --> 00:04:36,250
0,390 390,720 720,1320 1410,1710 1710,2640
So, is there like implementations|
那么，有没有这样的实现，|

143
00:04:36,250 --> 00:04:38,380
0,240 240,840 870,1290 1290,1620 1620,2130
where there's weird file systems,|
其中有奇怪的文件系统，|

144
00:04:38,380 --> 00:04:40,510
0,210 210,570 570,1020 1020,1380 1380,2130
that can guarantee this [adversity]|
可以保证这一逆境，|

145
00:04:40,510 --> 00:04:41,880
0,180 180,270 270,420 420,810
so we can [lock].|
这样我们就可以使用锁。|

146
00:04:43,510 --> 00:04:45,220
0,150 150,270 270,480 480,690 690,1710
If you buy two computers,
如果你买两台计算机，那么它们不会共享内存，对吧，

147
00:04:45,340 --> 00:04:46,810
0,300 300,390 390,570 570,780 780,1470
then they don't share memory,

148
00:04:48,740 --> 00:04:49,940
0,390 450,750 750,900 900,1080 1080,1200
right,| so that's one way
|所以，一种方式是如果你购买两台计算机，

149
00:04:49,940 --> 00:04:50,510
0,120 120,240 240,330 330,450 450,570
to do if you buy

150
00:04:50,510 --> 00:04:52,340
0,240 240,690 690,1470 1470,1740 1740,1830
two separate computers,| then they
|这样它们就不会共享内存，

151
00:04:52,340 --> 00:04:53,900
0,210 210,570 570,1050 1050,1320 1320,1560
won't share memory| and we
|我们就不会有任何这些问题了。

152
00:04:53,900 --> 00:04:54,800
0,330 330,480 480,630 630,690 690,900
won't have any of these

153
00:04:54,800 --> 00:04:57,020
0,780
problems.|
|

154
00:04:57,020 --> 00:04:58,540
0,120 120,360 360,510 510,900
It's just that the
只是从处理器芯片的角度来看，

155
00:04:58,720 --> 00:05:00,850
0,720 840,1410 1410,1710 1710,1890 1890,2130
way processor chips look,| these
|如今，单个处理器芯片上总是有多个核心，

156
00:05:00,850 --> 00:05:03,310
0,840 870,1560 1680,1890 1890,2100 2100,2460
days, {} there's always multiple

157
00:05:03,310 --> 00:05:04,510
0,330 330,450 450,510 510,750 750,1200
cores on a single processor

158
00:05:04,510 --> 00:05:05,590
0,270 270,390 390,510 510,600 600,1080
chip| and so the hardware
|所以，硬件被构建为让多个核心共享相同的内存系统。

159
00:05:05,590 --> 00:05:07,720
0,480 600,900 900,1500 1830,1950 1950,2130
just is built to have

160
00:05:07,720 --> 00:05:09,940
0,480 480,1140 1170,1770 1770,1860 1860,2220
multiple cores sharing the same

161
00:05:09,940 --> 00:05:11,220
0,390 390,780
memory system.|
|

162
00:05:12,340 --> 00:05:14,600
0,390 660,750 750,1050 1050,1620
Oh I see, thanks.|
我明白了，谢谢。|

163
00:05:17,750 --> 00:05:19,180
0,990
Okay,
好的，这是一点。

164
00:05:19,710 --> 00:05:22,100
0,180 180,300 300,510 510,1230
so that's one point.|
|

165
00:05:22,540 --> 00:05:24,820
0,360 360,900 930,1350 1830,2160 2160,2280
Another point,| I don't think
还有一点，|我还没有提到，

166
00:05:24,820 --> 00:05:25,840
0,120 120,480 480,660 660,930 930,1020
I've mentioned yet,| has to
|与一个事实有关，

167
00:05:25,840 --> 00:05:28,780
0,450 450,1050 1470,2220 2250,2670 2670,2940
do with {} {the,fact} that|
|

168
00:05:29,080 --> 00:05:30,820
0,300 300,480 480,630 630,1440 1470,1740
in {xv6 - -}, a
在 xv6 中，进程在调用 swtch 时不允许持有任何其他锁。

169
00:05:30,820 --> 00:05:32,380
0,450 450,600 600,1080 1080,1500 1500,1560
process is not allowed to

170
00:05:32,380 --> 00:05:34,690
0,510 840,1170 1170,1470 1470,2100 2130,2310
hold any other lock when

171
00:05:34,690 --> 00:05:36,920
0,210 540,870 870,1800
it calls swtch.|
|

172
00:05:36,950 --> 00:05:38,990
0,450 660,1230 1230,1380 1380,1980 1980,2040
A process is required to
进程调用 swtch 时需要持有 p->lock ，

173
00:05:38,990 --> 00:05:40,310
0,360 360,840 840,1170 1170,1260 1260,1320
hold {p->lock -} when it

174
00:05:40,310 --> 00:05:42,140
0,270 270,870 1410,1590 1590,1650 1650,1830
called swtch,| but it is
|但当它调用 swtch 时，禁止持有任何其他锁，

175
00:05:42,140 --> 00:05:44,030
0,780 870,990 990,1350 1410,1710 1710,1890
forbidden to hold any other

176
00:05:44,030 --> 00:05:45,320
0,330 330,420 420,510 510,750 750,1290
lock when it calls swtch,|
|

177
00:05:45,350 --> 00:05:46,550
0,180 180,300 300,420 420,750 750,1200
so this is another important
所以这是另一个重要的限制，

178
00:05:46,550 --> 00:05:47,960
0,540 540,660 660,750 750,1170 1170,1410
constraint| on the design of
|关于很多东西的设计，

179
00:05:48,110 --> 00:05:50,260
0,570 570,990 990,1620
many things,| including
|包括休眠是如何工作的。

180
00:05:50,260 --> 00:05:51,310
0,270 270,450 450,810 810,930 930,1050
{} how sleep is going

181
00:05:51,310 --> 00:05:53,080
0,60 60,390 420,780 930,1470 1470,1770
to work.| So now let
|让我来描述一下这件事的理由，

182
00:05:53,080 --> 00:05:53,980
0,90 90,300 300,420 420,540 540,900
me lay out the reasoning

183
00:05:53,980 --> 00:05:55,210
0,120 120,300 300,600 630,840 840,1230
for this,| so it's no
|这是当你调用 swtch 时，没有其他的锁。

184
00:05:55,210 --> 00:05:56,900
0,210 210,1140
other locks,

185
00:05:56,930 --> 00:05:58,260
0,750

186
00:06:01,900 --> 00:06:03,140
0,570

187
00:06:03,140 --> 00:06:04,740
0,120 120,240 240,420 420,1080
when you call swtch.|
|

188
00:06:07,980 --> 00:06:09,540
0,390 390,510 510,1230 1260,1500 1500,1560
{} A scenario, sort of
这个方案说明了为什么这条规则必须强制执行，

189
00:06:09,540 --> 00:06:11,130
0,480 480,660 660,870 870,1320 1350,1590
illustrating why this is this

190
00:06:11,130 --> 00:06:12,120
0,210 210,450 450,540 540,630 630,990
rule has to be enforced,|
|

191
00:06:12,120 --> 00:06:13,200
0,90 90,360 360,450 450,570 570,1080
and this is a rule
这是一条规则，

192
00:06:13,200 --> 00:06:14,020
0,240
that,|
|

193
00:06:14,020 --> 00:06:15,000
0,120 120,390
you know,
如果你扩展，

194
00:06:15,030 --> 00:06:16,140
0,510
{if,you're},

195
00:06:16,530 --> 00:06:18,360
0,810 810,1110 1110,1230 1230,1320 1320,1830
extending,| {you,know} you're a programmer
|你是开发 xv6 内核的程序员，

196
00:06:18,360 --> 00:06:19,800
0,450 450,540 540,840 840,1080 1080,1440
developing the {xv6 -} kernel|
|

197
00:06:19,800 --> 00:06:20,940
0,90 90,210 210,600 600,900 900,1140
have to follow this rule
必须遵守这条规则以及其他一些规则。

198
00:06:20,940 --> 00:06:22,950
0,300 300,600 660,1200 1200,1380 1380,2010
along with many other rules.|
|

199
00:06:24,340 --> 00:06:25,690
0,240 240,450 450,1050 1050,1140 1140,1350
So the justification for this
那么这条规则的正确性，

200
00:06:25,690 --> 00:06:27,430
0,360 390,870 870,960 960,1230 1230,1740
rule| supposing we have process
|假设我们有进程一，有进程一的内核线程，

201
00:06:27,430 --> 00:06:29,470
0,360 360,600 1110,1290 1290,1680 1680,2040
one or the kernel thread

202
00:06:29,470 --> 00:06:31,330
0,120 120,540 540,990 1140,1530 1590,1860
for process one| and it
|它会获取一些锁，

203
00:06:31,330 --> 00:06:33,440
0,420 420,780 780,1500
acquires some lock,|
|

204
00:06:33,560 --> 00:06:34,880
0,150 150,540 540,1020 1020,1230 1230,1320
{you,know} not {impressive -}, but
这并不稀奇，只是一些锁，

205
00:06:34,880 --> 00:06:36,170
0,330 390,720 720,870 870,1050 1050,1290
just some lock,| maybe it's
|可能它正在使用磁盘或使用 uart 控制台，

206
00:06:36,170 --> 00:06:37,400
0,330 330,420 420,810 810,900 900,1230
using the disk or using

207
00:06:37,400 --> 00:06:39,320
0,150 150,420 420,810 900,1050 1050,1920
the {uart -} to console|
|

208
00:06:39,320 --> 00:06:41,680
0,240 390,990 990,1260 1260,1770
and acquire some lock.|
并且获取一些锁。|

209
00:06:41,680 --> 00:06:43,330
0,390 540,780 780,1110 1110,1290 1290,1650
{} And supposing it did
假设它发生了，

210
00:06:43,330 --> 00:06:45,670
0,630 1140,1590 1590,1740 1740,1830 1830,2340
then,| give up the CPU
|通过调用 swtch 或 yield 或 sched 或其他方法放弃了 CPU ，

211
00:06:45,670 --> 00:06:47,320
0,150 150,480 480,1110 1110,1590 1590,1650
by calling {swtch,or} yield or

212
00:06:47,320 --> 00:06:48,850
0,420 420,510 510,870 870,1320 1320,1530
sched or something,| while still
|但是仍然持有这把锁。

213
00:06:48,850 --> 00:06:50,220
0,270 270,450 450,990
holding this lock.|
|

214
00:06:50,570 --> 00:06:52,280
0,510 990,1170 1170,1320 1320,1530 1530,1710
{} So now {p1 -}
所以现在 p1 持有锁，

215
00:06:52,280 --> 00:06:54,050
0,600 600,990 990,1140 1140,1320 1320,1770
holds lock,| this lock held,
|持有锁，但是并没有运行。

216
00:06:54,050 --> 00:06:55,800
0,210 210,390 390,570 570,960
but it's not running.|
|

217
00:06:56,310 --> 00:06:57,750
0,360 390,960 960,1290 1290,1410 1410,1440
And imagine also for a
想象一下，

218
00:06:57,750 --> 00:06:58,530
0,300 300,420 420,570 570,750 750,780
moment| that we're on a
|我们在一台只有一个核心的机器上。

219
00:06:58,530 --> 00:06:59,790
0,420 420,570 570,750 750,810 810,1260
machine with just a single

220
00:06:59,790 --> 00:07:00,960
0,660
core.|
|

221
00:07:01,600 --> 00:07:02,500
0,240 240,360 360,510 510,690 690,900
{} So there's only one
所以只有一个核心，

222
00:07:02,500 --> 00:07:04,720
0,450 630,900 900,1350 1350,1560 1560,2220
core,| the {process,one} called swtch
|进程一调用 swtch ，转移调度器，

223
00:07:04,900 --> 00:07:06,340
0,180 180,660 660,780 780,1320 1320,1440
which transfers the scheduler,| the
|调度器看到进程二的内核线程在等待运行，

224
00:07:06,340 --> 00:07:07,780
0,450 450,690 690,780 780,1050 1050,1440
scheduler sees {aha -} process

225
00:07:07,780 --> 00:07:09,310
0,480 480,810 810,1140 1140,1260 1260,1530
two's kernel thread is waiting

226
00:07:09,310 --> 00:07:10,480
0,90 90,540 780,990 990,1080 1080,1170
to run| and so the
|所以调度器切换进程，

227
00:07:10,480 --> 00:07:12,400
0,390 390,780 780,870 870,1500 1530,1920
scheduler switches the process,| starts
|开始运行进程二，切换到进程二，

228
00:07:12,460 --> 00:07:14,110
0,390 390,750 750,960 960,1290 1290,1650
running process to two, switches

229
00:07:14,110 --> 00:07:15,610
0,90 90,450 450,690 990,1200 1200,1500
to process two| and supposing
|假设进程二，不管出于什么原因，

230
00:07:15,610 --> 00:07:16,870
0,360 360,540 540,690 690,960 960,1260
process two for whatever reason,|
|

231
00:07:16,870 --> 00:07:18,040
0,300 300,450 450,780 780,1080 1080,1170
maybe it also wants to
或许它还想使用磁盘或 uart 之类的东西，

232
00:07:18,040 --> 00:07:19,600
0,210 210,300 300,810 810,1050 1140,1560
use the disk or use

233
00:07:19,600 --> 00:07:20,770
0,120 120,300 300,600 600,660 660,1170
that {uart -} or something|
|

234
00:07:20,890 --> 00:07:22,750
0,300 300,420 420,900 900,1560 1590,1860
and it calls acquire on
它对同一个锁调用 acquire ，

235
00:07:22,750 --> 00:07:24,360
0,120 120,540 540,1230
the same lock,|
|

236
00:07:27,700 --> 00:07:29,080
0,270 270,360 360,450 450,900 900,1380
so we have a second
所以我们第二次获取这把锁，

237
00:07:29,080 --> 00:07:30,940
0,540 540,630 630,810 810,1410 1560,1860
acquire of this lock,| it's
|这是同一把锁。

238
00:07:30,940 --> 00:07:32,830
0,90 90,900 900,990 990,1290 1290,1890
the same the same lock.|
|

239
00:07:33,360 --> 00:07:34,620
0,330 600,810 810,900 900,1110 1110,1260
Of course, the lock already
当然，锁已经持有了，

240
00:07:34,620 --> 00:07:35,820
0,360 360,450 450,600 600,930 930,1200
held,| so this acquire can't
|所以这个 acquire 拿不到它，

241
00:07:35,820 --> 00:07:37,170
0,180 180,420 540,900 900,990 990,1350
get it,| these are spin
|这些是自旋锁，

242
00:07:37,170 --> 00:07:39,090
0,690 720,1170 1200,1470 1470,1620 1620,1920
locks,| so what this actually
|所以，这会导致，

243
00:07:39,090 --> 00:07:40,320
0,360 360,450 450,840 840,990 990,1230
causes to happen is that|
|

244
00:07:40,350 --> 00:07:43,110
0,540 540,990 1050,1530 1530,2100 2100,2760
process two {} inside acquire
进程二内部的 acquire 会在一个循环中，

245
00:07:43,140 --> 00:07:44,010
0,240 240,510 510,690 690,780 780,870
will just sit in a

246
00:07:44,010 --> 00:07:45,480
0,390 390,960 960,1290 1290,1380 1380,1470
loop| spinning waiting for the
|旋转等待锁被释放。

247
00:07:45,480 --> 00:07:47,220
0,270 270,360 360,480 480,1260
lock to be released.|
|

248
00:07:47,280 --> 00:07:48,960
0,240 240,630 630,810 810,1440 1470,1680
And acquire won't return| and
而且 acquire 不会返回，|既然 acquire 不会返回，

249
00:07:48,960 --> 00:07:51,000
0,180 180,540 540,780 780,1410 1470,2040
since acquire doesn't return,| process
|进程二不能，没有机会，

250
00:07:51,000 --> 00:07:52,050
0,330 330,720 720,900 900,990 990,1050
two can't, doesn't have a

251
00:07:52,050 --> 00:07:53,100
0,480 480,690 690,840 840,930 930,1050
chance,| even though it may
|即使它愿意在完成的时候让出 CPU ，

252
00:07:53,100 --> 00:07:54,180
0,150 150,510 510,630 630,990 990,1080
be willing to yield the

253
00:07:54,180 --> 00:07:55,650
0,450 450,600 600,750 750,1110 1110,1470
CPU when it's done later

254
00:07:55,650 --> 00:07:56,940
0,480 600,960 960,1020 1020,1200 1200,1290
on,| {} it doesn't get
|它没有机会这样做，

255
00:07:56,940 --> 00:07:57,690
0,60 60,360 360,480 480,690 690,750
a chance to,| because the
|因为 acquire 在锁释放之前不会返回。

256
00:07:57,690 --> 00:07:59,700
0,360 360,900 1290,1710 1710,1920 1920,2010
acquire doesn't return until the

257
00:07:59,700 --> 00:08:01,290
0,240 240,330 330,900 1110,1470 1470,1590
lock is released.| {You,know}, but
|但是唯一能释放锁的方法是，

258
00:08:01,290 --> 00:08:01,980
0,60 60,240 240,330 330,450 450,690
the only way the lock

259
00:08:01,980 --> 00:08:03,480
0,120 120,270 270,810 990,1290 1290,1500
could be released is| if
|如果进程一恢复执行，

260
00:08:03,540 --> 00:08:06,870
0,630 630,1320 1590,2160 2220,2700 2700,3330
process one {} resumes execution,|
|

261
00:08:06,870 --> 00:08:08,840
0,120 120,660 660,1440
and presumably later,
并且可能稍后，它是正确的，没有严重的 bug ，

262
00:08:09,160 --> 00:08:10,900
0,180 180,360 360,1170 1260,1440 1440,1740
{} it's correctly, it doesn't

263
00:08:10,900 --> 00:08:12,670
0,480 750,1140 1140,1440 1440,1590 1590,1770
have terrible bugs in it,|
|

264
00:08:12,820 --> 00:08:14,230
0,270 270,570 570,690 690,780 780,1410
it was going to call
它会打算释放这个锁，

265
00:08:14,260 --> 00:08:15,610
0,90 90,270 270,840 840,960 960,1350
it was intending to release

266
00:08:15,610 --> 00:08:17,410
0,180 180,810 1020,1560 1560,1710 1710,1800
this lock right,| but it
|但这还没有发生，

267
00:08:17,410 --> 00:08:18,880
0,240 240,600 600,960
hasn't happened yet,|
|

268
00:08:18,910 --> 00:08:20,350
0,300 300,390 390,570 570,1290 1320,1440
because it's called swtch| and
因为它调用了 swtch ，|而进程二正在旋转，等待这个锁，

269
00:08:20,350 --> 00:08:22,300
0,390 390,720 720,1050 1290,1710 1710,1950
process two is spinning waiting

270
00:08:22,300 --> 00:08:22,900
0,90 90,150 150,330 330,420 420,600
for the lock,| so this
|所以这是一个死锁，

271
00:08:22,900 --> 00:08:25,360
0,90 90,180 180,1020 1350,1920
is a deadlock, right,|
|

272
00:08:25,700 --> 00:08:27,950
0,810 1170,1860 1860,1980 1980,2070 2070,2250
{} and it will just
这会导致系统冻结。

273
00:08:27,950 --> 00:08:30,230
0,240 240,330 330,810 810,1470 1980,2280
cause the system to {}

274
00:08:30,230 --> 00:08:31,480
0,750
freeze.|
|

275
00:08:32,230 --> 00:08:33,440
0,660

276
00:08:34,570 --> 00:08:35,920
0,210 210,480 480,540 540,1080 1080,1350
And while I described this
我描述这个的上下文是，

277
00:08:35,920 --> 00:08:36,730
0,150 150,210 210,660 660,750 750,810
in the context| of a
|一台只有一个 CPU ，一个核心，

278
00:08:36,730 --> 00:08:38,290
0,420 420,540 540,570 570,1050 1050,1560
machine with a single CPU,

279
00:08:38,290 --> 00:08:40,300
0,90 90,390 390,990 1590,1860 1860,2010
a single core,| you can
|你可以想象，

280
00:08:40,300 --> 00:08:42,910
0,450 450,1320 1320,1650 1710,2190 2190,2610
construct scenarios| that using multiple
|使用多个锁将导致相同类型的死锁，

281
00:08:42,910 --> 00:08:44,820
0,750
locks

282
00:08:44,910 --> 00:08:46,110
0,270 270,480 480,840 840,1020 1020,1200
{} would cause this same

283
00:08:46,110 --> 00:08:47,220
0,210 210,270 270,870 900,1050 1050,1110
kind of deadlock| on a
|在一台有多个核心的机器上。

284
00:08:47,220 --> 00:08:49,260
0,330 330,450 450,810 810,1530
machine with multiple cores.|
|

285
00:08:49,980 --> 00:08:51,120
0,270 270,390 390,480 480,540 540,1140
And so as a result,
所以，在 xv6 中有一个普遍的限制，

286
00:08:51,180 --> 00:08:53,190
0,510 510,600 600,810 840,1290 1290,2010
we have a general prohibition

287
00:08:53,190 --> 00:08:55,100
0,210 210,990 990,1290
in xv6,| that
|不能在 swtch 时持有锁。

288
00:08:55,100 --> 00:08:56,090
0,150 150,330 330,540 540,630 630,990
you're not allowed to hold

289
00:08:56,090 --> 00:08:59,120
0,300 300,1020 1440,2430 2430,2490 2490,3030
spin locks across the swtch.|
|

290
00:09:01,060 --> 00:09:02,320
0,180 180,540 540,720 720,870 870,1260
Any questions about this rule?|
对于这条规则，有什么问题吗？|

291
00:09:06,720 --> 00:09:09,120
0,510 1230,1800 1800,2130 2160,2310 2310,2400
{There's,a,question,in,the,chat,Robert}.| Oh, {} would you
聊天中有个问题，罗伯特。|能否有一个定时器中断，切换到 p1 来解决死锁？

292
00:09:09,120 --> 00:09:10,500
0,90 90,150 150,630 630,1020 1020,1380
have a timer interrupt, switch

293
00:09:10,500 --> 00:09:11,880
0,90 90,330 330,690 690,900 900,1380
to {p1 -} which resolves

294
00:09:11,880 --> 00:09:14,190
0,120 120,660 960,1380 1380,1770 1860,2310
the deadlock.| Okay so, {}
|好吧，那么，确实是这样，

295
00:09:14,220 --> 00:09:15,360
0,300 300,450 450,660 660,930 930,1140
yet, it does turn out,|
|

296
00:09:15,360 --> 00:09:16,830
0,120 120,270 270,780 990,1260 1260,1470
so we're running, both all
所以所有这些东西都运行在内核中，

297
00:09:16,830 --> 00:09:17,520
0,60 60,330 330,540 540,630 630,690
the stuffs running in the

298
00:09:17,520 --> 00:09:20,040
0,510 660,1290 1290,1380 1380,2010 2010,2520
kernel right,| {you,know} acquire release
|acquire release 都是内核代码，

299
00:09:20,040 --> 00:09:21,960
0,510 510,600 600,810 810,1470
which you know only

300
00:09:21,960 --> 00:09:22,920
0,210 210,510 510,690 690,810 810,960
so kernel code,| so not
|不是运行在用户空间中，

301
00:09:22,920 --> 00:09:24,150
0,210 210,300 300,540 540,900 900,1230
running in user space,| but
|但确实定时器中断可能会发生，

302
00:09:24,150 --> 00:09:26,340
0,480 600,1080 1080,1440 1440,1890 1980,2190
indeed a timer interrupt could

303
00:09:26,340 --> 00:09:30,240
0,720 750,1380 1620,2340 2880,3660 3690,3900
occur| and {} xv6 is
|而且 xv6 允许定时器中断发生，

304
00:09:30,240 --> 00:09:33,120
0,870 960,1440 1440,1770 1770,2430 2610,2880
actually allows timer interrupts to

305
00:09:33,120 --> 00:09:35,220
0,570 570,1170 1290,1620 1620,1800 1800,2100
happen| in while running kernel
|在运行内核代码，系统调用代码时，

306
00:09:35,220 --> 00:09:37,440
0,570 810,1140 1170,1530 1530,1740 1740,2220
code, {} system call code|
|

307
00:09:37,500 --> 00:09:38,520
0,360 360,450 450,810 810,900 900,1020
and in fact if you
事实上，如果你查看内核陷阱代码，

308
00:09:38,520 --> 00:09:40,290
0,180 180,270 270,660 1020,1410 1410,1770
look at the {} kernel

309
00:09:40,290 --> 00:09:41,760
0,360 360,870 870,1050 1110,1410 1410,1470
trap code| or whatever it
|或者不管在 trap.c 里的什么，

310
00:09:41,760 --> 00:09:42,780
0,180 180,270 270,540 540,720 720,1020
is in {trap.c - -},|
|

311
00:09:42,870 --> 00:09:44,310
0,270 270,570 570,900 930,1380 1380,1440
you'll see that if a
你会看到，如果发生定时器中断，

312
00:09:44,310 --> 00:09:46,770
0,360 360,690 690,1140 1140,1800 1920,2460
timer interrupt happens,| while xv6
|当 xv6 执行内核时，

313
00:09:46,770 --> 00:09:48,090
0,210 300,840 840,900 900,1200 1200,1320
is executing the kernel,| it
|它会调用 yield 。

314
00:09:48,090 --> 00:09:49,480
0,180 180,420 420,1110
will call yield.|
|

315
00:09:49,480 --> 00:09:50,740
0,480 510,720 720,870 870,930 930,1260
{} So if a timer
所以如果定时器中断发生，

316
00:09:50,740 --> 00:09:52,840
0,360 360,690 690,1380 1500,1980 1980,2100
interrupt could happen,| while we're
|当我们在这里运行 acquire 时，

317
00:09:52,840 --> 00:09:54,700
0,240 240,330 330,750 750,1230 1650,1860
running {acquire -} here,| then
|那么我们就会得救，

318
00:09:54,700 --> 00:09:55,900
0,540
actually

319
00:09:56,510 --> 00:09:58,280
0,510 510,930 930,1110 1110,1200 1200,1770
{} we would be saved,|
|

320
00:09:58,280 --> 00:10:00,260
0,690 720,810 810,1050 1050,1740 1740,1980
because we call yield switch
因为我们调用 yield ，返回到这里，

321
00:10:00,260 --> 00:10:01,280
0,210 210,390 390,480 480,870 870,1020
back here| and hopefully {p1
|希望 p1 恢复并最终释放锁，

322
00:10:01,280 --> 00:10:02,330
0,240 240,390 390,540 540,960 960,1050
-} would then resume and

323
00:10:02,330 --> 00:10:04,010
0,420 420,720 720,810 810,1140 1170,1680
eventually release the lock,| however,
|然而，由于上一节课已经解释过的原因，

324
00:10:05,120 --> 00:10:07,730
0,240 240,570 570,840 900,1530 1920,2610
for reasons that were explained

325
00:10:07,730 --> 00:10:09,770
0,60 60,120 120,480 480,900 960,2040
in a previous lecture,| acquire
|acquire 在开始等待锁之前关闭中断，

326
00:10:09,860 --> 00:10:12,620
0,660 660,990 990,1980 2010,2700 2700,2760
turns off interrupts before it

327
00:10:12,620 --> 00:10:13,490
0,360 360,450 450,690 690,780 780,870
starts to wait for the

328
00:10:13,490 --> 00:10:15,440
0,330 330,570 570,750 780,1770 1770,1950
lock,| because we absolutely for
|出于其他原因，

329
00:10:15,440 --> 00:10:18,020
0,210 210,630 630,1020 1020,1740 2010,2580
other reasons,| cannot afford to
|不能承受在我们持有锁的同时发生中断，

330
00:10:18,020 --> 00:10:19,670
0,180 180,270 270,750 750,1140 1170,1650
have an interrupt happen while

331
00:10:19,670 --> 00:10:20,780
0,120 120,420 420,510 510,930 960,1110
we're holding a lock,| because
|因为那会导致另一种死锁。

332
00:10:20,780 --> 00:10:21,950
0,150 150,270 270,570 570,750 750,1170
that would cause a different

333
00:10:21,950 --> 00:10:23,340
0,210 210,300 300,990
kind of deadlock.|
|

334
00:10:23,340 --> 00:10:26,120
0,210 210,390 390,810 810,1890
It's the interrupt handler,
它是中断处理程序，需要获取锁，

335
00:10:26,690 --> 00:10:28,100
0,600 600,750 750,1110 1110,1320 1320,1410
needed to use, needed to

336
00:10:28,100 --> 00:10:30,560
0,420 420,540 540,1050 1410,2010 2280,2460
acquire the lock,| that this
|这个 acquire 可能是刚刚获得的，

337
00:10:30,560 --> 00:10:33,580
0,720 750,1050 1050,1800
acquire had possibly

338
00:10:33,580 --> 00:10:34,810
0,210 210,690 870,1080 1080,1140 1140,1230
just acquired,| so if you
|所以，如果你查看 xv6 中的 acquire 代码，

339
00:10:34,810 --> 00:10:35,530
0,120 120,180 180,240 240,570 570,720
look at the code for

340
00:10:35,530 --> 00:10:36,640
0,30 30,360 360,570 570,690 690,1110
{acquire -} {xv6 - -},|
|

341
00:10:36,790 --> 00:10:37,540
0,210 210,330 330,450 450,660 660,750
you'll see the first thing
你会看到它做的第一件事就是关闭中断，然后旋转

342
00:10:37,540 --> 00:10:38,320
0,90 90,300 300,420 420,630 630,780
it does is turn off

343
00:10:38,320 --> 00:10:40,540
0,600 630,900 900,1080 1080,1920 2070,2220
interrupts and then spins| and
|你可能会想，为什么它不是旋转，然后关闭中断，

344
00:10:40,540 --> 00:10:41,770
0,90 90,210 210,450 450,810 840,1230
you may wonder those, why

345
00:10:41,770 --> 00:10:43,180
0,180 180,300 300,1050 1050,1230 1230,1410
doesn't it spin and then

346
00:10:43,180 --> 00:10:44,290
0,210 210,390 390,960 960,1050 1050,1110
turn off interrupts| and the
|原因是这将允许短时间内发生，

347
00:10:44,290 --> 00:10:45,910
0,270 270,690 990,1200 1200,1290 1290,1620
reason is that would allow

348
00:10:45,910 --> 00:10:46,930
0,90 90,390 390,690 690,750 750,1020
a short period of time

349
00:10:46,930 --> 00:10:47,680
0,150 150,450 450,510 510,660 660,750
to occur| in which the
|锁被持有，但是中断没有被禁用，

350
00:10:47,680 --> 00:10:49,660
0,270 270,390 390,1020 1230,1500 1500,1980
lock is held, but interrupts

351
00:10:49,660 --> 00:10:52,360
0,300 300,1050 1290,1650 1650,2370 2580,2700
weren't disabled| and again {}
|再一次，如果这个时间段发生设备中断，可能会导致死锁。

352
00:10:52,360 --> 00:10:53,950
0,330 330,720 720,930 930,1380 1410,1590
device interrupted that time might

353
00:10:53,950 --> 00:10:55,060
0,240 240,270 270,780
cause a deadlock.|
|

354
00:10:55,260 --> 00:10:57,240
0,270 270,870 870,1050 1050,1350 1350,1980
So, unfortunately,| this other requirement
所以，不幸的是，|这是另一个要求我们关闭中断，

355
00:10:57,240 --> 00:10:59,220
0,120 120,660 780,1140 1140,1650 1650,1980
that we leave interrupts off|
|

356
00:10:59,220 --> 00:11:00,330
0,180 180,270 270,690 690,930 930,1110
while we're spinning waiting for
当我们旋转等待锁时，

357
00:11:00,330 --> 00:11:02,790
0,420 480,1470 1500,1680 1680,2040 2040,2460
lock| prevents the timer interrupt
|防止定时器中断关闭，

358
00:11:02,790 --> 00:11:03,840
0,120 120,360 360,630 630,720 720,1050
from going off| and therefore
|并且防止了进程二回到进程一。

359
00:11:03,840 --> 00:11:05,970
0,990 990,1320 1320,1470 1470,1650 1650,2130
prevents process two from yielding

360
00:11:05,970 --> 00:11:07,360
0,210 210,300 300,660 660,900
back to process one.|
|

361
00:11:07,970 --> 00:11:09,280
0,180 180,210 210,360 360,750
That's a good question.|
这是个好问题。|

362
00:11:09,770 --> 00:11:10,900
0,510

363
00:11:11,060 --> 00:11:12,110
0,300 300,540 540,810 810,990 990,1050
{Okay,so} another question,| can I
好的，另一个问题，|我可以重复一下如何避免死锁吗？

364
00:11:12,110 --> 00:11:14,780
0,330 330,510 510,1410 1500,1890 1890,2670
repeat how deadlocks are avoided?|
|

365
00:11:15,990 --> 00:11:17,560
0,990

366
00:11:19,440 --> 00:11:20,820
0,300 300,840 840,930 930,1290 1290,1380
Oh, deadlocks are avoided in
在 xv6 中通过禁止这个来避免死锁，

367
00:11:20,820 --> 00:11:22,320
0,180 180,330 330,690 720,990 990,1500
{xv6 - -} by prohibiting

368
00:11:22,320 --> 00:11:25,320
0,480 1830,2310 2310,2520 2520,2700 2700,3000
this,| xv6 code is not
|xv6 代码不允许获取 p->lock 以外的任何锁，

369
00:11:25,320 --> 00:11:26,600
0,780
allowed

370
00:11:26,630 --> 00:11:28,220
0,240 240,870 870,1080 1080,1380 1380,1590
to acquire any lock other

371
00:11:28,220 --> 00:11:30,080
0,300 420,840 840,1500 1530,1710 1710,1860
than {p->lock -},| and then
|然后调用 swtch ，

372
00:11:30,080 --> 00:11:31,700
0,210 210,960 1170,1410 1410,1500 1500,1620
call swtch| and if you
|如果你看一下 swtch 的代码，

373
00:11:31,700 --> 00:11:32,300
0,120 120,180 180,240 240,510 510,600
look at the code for

374
00:11:32,300 --> 00:11:33,680
0,270 270,450 450,810
swtch,| there's actually
|在 swtch 里有一些检查，

375
00:11:33,900 --> 00:11:35,160
0,240 240,630 630,750 750,1110 1110,1260
some checks in swtch,| that
|检查除了 p->lock 之外没有锁被持有。

376
00:11:35,160 --> 00:11:36,390
0,60 60,510 510,630 630,990 990,1230
are equivalent to checking that

377
00:11:36,420 --> 00:11:38,190
0,390 390,780 780,900 900,1440 1470,1770
no locks are held other

378
00:11:38,190 --> 00:11:39,680
0,120 120,510 510,1050
than {p->lock -}.|
|

379
00:11:40,020 --> 00:11:41,190
0,240 240,480 540,900 900,1020 1020,1170
So the problem with this
所以问题是这个代码，

380
00:11:41,190 --> 00:11:42,640
0,150 150,390 390,960
is this code,|
|

381
00:11:43,000 --> 00:11:43,600
0,150 150,240 240,480 480,540 540,600
if it occurred in the
如果它发生在 xv6 内核中，将是非法的。

382
00:11:43,600 --> 00:11:45,370
0,450 450,810 840,1080 1080,1170 1170,1770
xv6 kernel would be illegal|
|

383
00:11:45,370 --> 00:11:46,810
0,150 150,360 450,870 870,1140 1140,1440
and would could easily cause
很容易造成死锁，

384
00:11:46,810 --> 00:11:48,520
0,60 60,660 900,1080 1080,1200 1200,1710
a deadlock,| so it's forbidden.|
|所以这是被禁止的。|

385
00:11:50,190 --> 00:11:51,240
0,180 180,330 330,570 570,630 630,1050
As that answered the {question?，Okay}.|
这回答了这个问题吗？好的。|

386
00:11:53,790 --> 00:11:54,860
0,480

387
00:11:54,920 --> 00:11:56,400
0,180 180,930
Other questions?|
还有其他问题吗？|

388
00:12:01,580 --> 00:12:03,140
0,450 480,870 930,1170 1170,1290 1290,1560
Okay, {} okay, so keep
好的，记住这条规则，

389
00:12:03,140 --> 00:12:05,390
0,240 240,600 600,960 1170,1770 1830,2250
this rule| and {} previous
|以及预先在 swtch 中持有 p->lock ，

390
00:12:05,390 --> 00:12:06,560
0,180 180,240 240,510 510,840 840,1170
need to hold {p->lock -}

391
00:12:06,560 --> 00:12:08,510
0,360 360,660 660,750 750,1410 1440,1950
across switch in mind,| because
|因为它们会再次出现，

392
00:12:08,510 --> 00:12:09,980
0,180 180,360 360,450 450,990 1080,1470
they'll come up again| in
|在我们讨论睡眠和唤醒是如何工作的时候。

393
00:12:09,980 --> 00:12:11,450
0,150 150,630 630,690 690,840 840,1470
our discussion of how sleep

394
00:12:11,480 --> 00:12:12,880
0,180 180,390 390,540 540,930
and {wakeup -} work.|
|

395
00:12:15,160 --> 00:12:18,120
0,510 510,690 690,1410 1440,2040
Alright new topic, {}
好的，新主题，协调，

396
00:12:22,510 --> 00:12:24,200
0,1140
coordination,|
|

397
00:12:29,370 --> 00:12:31,180
0,480 480,690 690,1320
{which,really} means sleep/-,
就是 sleep/wakeup 。

398
00:12:35,170 --> 00:12:36,920
0,390 390,1050
the. {}|
|

399
00:12:38,880 --> 00:12:39,760
0,60

400
00:12:40,450 --> 00:12:41,140
0,180 180,330 330,360 360,480 480,690
We've heard a lot about
我们听说过很多关于锁的事，

401
00:12:41,140 --> 00:12:43,270
0,690 690,930 930,1260 1260,1350 1350,2130
locks| and locks are fantastic
|锁在某些情况下是很棒的，

402
00:12:43,300 --> 00:12:45,100
0,120 120,720 720,900 900,1200 1200,1800
for situations| where different threads
|不同的线程不必担心，

403
00:12:45,130 --> 00:12:46,570
0,510 540,840 840,900 900,1320 1320,1440
really want to not be

404
00:12:46,570 --> 00:12:47,770
0,720 720,810 810,960 960,1050 1050,1200
aware| and not have to
|而不必担心或考虑其他线程在做什么，

405
00:12:47,770 --> 00:12:48,790
0,240 240,480 480,540 540,750 750,1020
worry about or think about

406
00:12:48,790 --> 00:12:49,720
0,180 180,330 330,660 660,750 750,930
what other threads are up

407
00:12:49,720 --> 00:12:50,890
0,240 540,660 660,840 840,1080 1080,1170
to,| we hold locks and
|我们持有锁并共享数据，

408
00:12:50,890 --> 00:12:52,120
0,150 150,660 750,900 900,1080 1080,1230
share data,| that means we
|这意味着我们不必担心这种可能性，

409
00:12:52,120 --> 00:12:53,260
0,240 240,570 570,720 720,840 840,1140
just never have to worry

410
00:12:53,260 --> 00:12:54,550
0,240 240,360 360,960 960,1080 1080,1290
about the possibility| that some
|其他的锁是或不是使用这些数据，

411
00:12:54,550 --> 00:12:56,350
0,180 180,540 540,840 1200,1710 1710,1800
other lock is is or

412
00:12:56,350 --> 00:12:57,640
0,240 240,600 600,750 750,1050 1050,1290
maybe not, who knows, using

413
00:12:57,640 --> 00:12:59,140
0,150 150,420 420,870 870,990 990,1500
that data,| because the lock,
|因为锁导致一次只发生一件事，

414
00:12:59,350 --> 00:13:00,250
0,210 210,270 270,600 600,810 810,900
so it causes things to

415
00:13:00,250 --> 00:13:01,240
0,240 240,420 420,510 510,570 570,990
happen one at a time,|
|

416
00:13:01,630 --> 00:13:03,730
0,1050 1320,1470 1470,1560 1560,1770 1770,2100
but when you're writing threaded
但是当你编写线程化代码时，

417
00:13:03,730 --> 00:13:05,890
0,540 570,720 720,900 900,1260 1260,2160
code,| there are also situations
|也有某些情况，你需要等待特定的事件，

418
00:13:05,890 --> 00:13:08,350
0,180 180,330 330,1290 1290,2070 2130,2460
where you explicitly want to

419
00:13:08,350 --> 00:13:09,940
0,330 330,480 480,720 720,1290 1290,1590
wait for some specific event|
|

420
00:13:09,940 --> 00:13:11,440
0,150 150,300 300,690 810,1140 1140,1500
where you want different threads
你希望不同的线程进行交互。

421
00:13:11,440 --> 00:13:12,540
0,120 120,990
to interact.|
|

422
00:13:12,570 --> 00:13:13,900
0,660

423
00:13:14,530 --> 00:13:16,260
0,450 450,600 600,1200
So, for example,
比如，假设我们有管道，

424
00:13:16,260 --> 00:13:18,180
0,330 330,780 780,930 930,1260 1290,1920
{} supposing, we have pipes|
|

425
00:13:18,180 --> 00:13:18,930
0,90 90,150 150,270 270,360 360,750
and we got a reader
我们有读取者和写入者，

426
00:13:18,930 --> 00:13:20,160
0,120 120,210 210,750 810,1110 1110,1230
and a writer right,| if
|如果我正在读取管道，

427
00:13:20,160 --> 00:13:22,360
0,390 660,1020 1020,1080 1080,1680
I'm reading a pipe,|
|

428
00:13:22,360 --> 00:13:23,380
0,150 150,270 270,420 420,660 660,1020
{} and there's nothing currently
而当前在管道中没有要读取的内容，

429
00:13:23,380 --> 00:13:24,370
0,120 120,330 330,420 420,510 510,990
to read in the pipe,|
|

430
00:13:24,550 --> 00:13:25,420
0,450 450,600 600,660 660,720 720,870
I want to be able
我希望能够等待任何其他进程将数据写入管道，

431
00:13:25,420 --> 00:13:27,040
0,150 150,690 840,1170 1170,1410 1410,1620
to wait for any other

432
00:13:27,040 --> 00:13:28,270
0,510 510,660 660,870 870,1110 1110,1230
process to write data to

433
00:13:28,270 --> 00:13:29,200
0,90 90,510 510,600 600,780 780,930
the pipe,| I want to
|我想等待管道不是空的事件。

434
00:13:29,200 --> 00:13:30,220
0,390 390,570 570,720 720,930 930,1020
wait for this sort of

435
00:13:30,220 --> 00:13:32,200
0,600 600,720 720,1020 1020,1350 1350,1980
pipe is not empty event.|
|

436
00:13:32,620 --> 00:13:34,570
0,450 840,1410 1410,1530 1530,1680 1680,1950
{} Similarly if I'm reading
同样的，如果我正在读取磁盘，或正在写入磁盘，

437
00:13:34,570 --> 00:13:36,100
0,120 120,960
the disk,

438
00:13:36,420 --> 00:13:38,060
0,180 180,480 480,570 570,1140
or writing the disk.|
|

439
00:13:38,150 --> 00:13:39,440
0,630

440
00:13:41,650 --> 00:13:42,640
0,120 120,240 240,450 450,570 570,990
If I'm reading the disk,|
如果我在读取磁盘，|

441
00:13:42,640 --> 00:13:43,780
0,300 330,570 570,720 720,900 960,1140
then I want to be
然后我希望告诉磁盘控制器，

442
00:13:43,780 --> 00:13:44,620
0,120 120,210 210,480 480,570 570,840
able to tell the disk

443
00:13:44,620 --> 00:13:46,090
0,570 570,810 810,1140 1140,1410 1410,1470
controller,| look, please read a
|请读取磁盘上的某个块，

444
00:13:46,090 --> 00:13:47,620
0,540 540,840 840,930 930,1020 1020,1530
particular block on the disk,|
|

445
00:13:47,740 --> 00:13:48,430
0,150 150,240 240,390 390,450 450,690
it may take a long
可能需要很多毫秒，

446
00:13:48,430 --> 00:13:50,830
0,240 240,1290 1410,1830 1830,2070 2070,2400
time milliseconds,| long long time
|在磁盘完成读取完成之前需要很长时间，

447
00:13:50,830 --> 00:13:52,600
0,330 330,420 420,870 1080,1470 1470,1770
before the disk {} finally

448
00:13:52,600 --> 00:13:53,680
0,390 390,480 480,690 690,1020 1020,1080
finishes the read,| especially if
|特别是如果它必须寻找和旋转，

449
00:13:53,680 --> 00:13:54,550
0,60 60,210 210,390 390,750 750,870
it has to seek and

450
00:13:54,550 --> 00:13:57,130
0,570 1650,2010 2010,2100 2100,2490 2490,2580
rotate| and the process is
|正在读取的进程需要等待这个特定事件，

451
00:13:57,130 --> 00:13:58,150
0,210 210,300 300,630 690,930 930,1020
doing the read needs to

452
00:13:58,150 --> 00:13:58,780
0,60 60,210 210,300 300,510 510,630
be able to wait for

453
00:13:58,780 --> 00:14:00,700
0,390 390,960 960,1500 1650,1800 1800,1920
that specific event,| we want
|我们希望等待磁盘读取完成。

454
00:14:00,700 --> 00:14:01,840
0,60 60,300 300,540 540,660 660,1140
to wait for the {disk,read}

455
00:14:01,840 --> 00:14:02,900
0,90 90,750
to complete.|
|

456
00:14:03,070 --> 00:14:04,200
0,570

457
00:14:05,330 --> 00:14:07,070
0,300 300,930 1170,1500 1500,1650 1650,1740
{} Similarly you may have
同样地，你可能已经注意到，

458
00:14:07,070 --> 00:14:08,810
0,540 540,840 840,1050 1050,1170 1170,1740
noticed,| {} when you're programming,
|当你编程的时候， unix 程序可以进行 wait 系统调用。

459
00:14:08,810 --> 00:14:10,670
0,330 450,960 960,1350 1350,1740 1740,1860
that a unix program can

460
00:14:10,670 --> 00:14:12,410
0,210 210,330 330,660 660,1140 1140,1740
make the wait system call.|
|

461
00:14:12,950 --> 00:14:14,450
0,420 540,780 780,990 990,1230 1230,1500
{} And what wait does
而 wait 所做的是，

462
00:14:14,450 --> 00:14:15,740
0,120 120,300 330,930 930,990 990,1290
is| it causes the calling
|它使调用进程等待，直到它的任意子进程退出，

463
00:14:15,740 --> 00:14:17,270
0,450 450,600 600,930 930,1260 1290,1530
process to wait, until any

464
00:14:17,270 --> 00:14:18,890
0,90 90,300 300,870 870,1230 1260,1620
of its children exit,| so
|所以，这里我们故意让父进程等待，

465
00:14:18,920 --> 00:14:20,360
0,390 390,480 480,600 600,720 720,1440
here we have the parent

466
00:14:20,360 --> 00:14:22,520
0,570 570,1170 1170,1710 1740,2010 2010,2160
process intentionally waiting| for some
|等待某种由另一个进程引起的事件。

467
00:14:22,520 --> 00:14:23,840
0,420 420,600 600,660 660,1200 1200,1320
event sort of caused by

468
00:14:23,840 --> 00:14:25,340
0,300 300,990
another process.|
|

469
00:14:25,490 --> 00:14:26,720
0,180 180,390 390,480 480,570 570,1230
So these are all situations
所以，这些都是进程需要等待事件的情况，

470
00:14:26,720 --> 00:14:28,280
0,450 690,840 840,1230 1230,1410 1410,1560
where a process needs to

471
00:14:28,280 --> 00:14:30,020
0,390 390,540 540,780 810,1320 1320,1740
wait for a specific event|
|

472
00:14:30,020 --> 00:14:32,510
0,480 510,870 870,1530 1530,1980 2040,2490
either typically IO or another
通常是 IO 或另一进程，

473
00:14:32,510 --> 00:14:34,520
0,750 780,1230 1230,1500
process,| sort of
|[]发生一些具体的事情。

474
00:14:34,580 --> 00:14:36,920
0,330 330,900 900,990 990,1530 1770,2340
{} [] that something specific

475
00:14:36,920 --> 00:14:38,080
0,120 120,690
has happened.|
|

476
00:14:39,190 --> 00:14:40,750
0,270 270,540 540,1260 1260,1380 1380,1560
{} And coordination is the
协调是一种工具，

477
00:14:40,750 --> 00:14:42,430
0,180 180,270 690,1200 1200,1380 1380,1680
sort of tool| that helps
|帮助我们解决这类问题，

478
00:14:42,430 --> 00:14:44,080
0,480 510,960 990,1350 1350,1470 1470,1650
us {} solve these kind

479
00:14:44,080 --> 00:14:46,120
0,60 60,750 900,1170 1170,1830 1890,2040
of problems| or implement {}
|或者实现这些要求，

480
00:14:46,120 --> 00:14:48,250
0,240 240,420 420,480 480,1320 1710,2130
these kind of requirements| and
|而且协调是很基础的，

481
00:14:48,340 --> 00:14:50,530
0,570 570,840 840,1260 1260,1860 1860,2190
coordination is totally fundamental,| just
|就像锁一样，协调是另一个基本工具，

482
00:14:50,530 --> 00:14:52,960
0,180 180,330 330,450 450,1080 1740,2430
just like with locks, coordination

483
00:14:52,960 --> 00:14:55,090
0,120 120,360 360,1020 1020,1560 1560,2130
is another fundamental tool| for
|用于编写线程化程序，

484
00:14:55,210 --> 00:14:56,620
0,420 420,810 810,1260 1260,1350 1350,1410
writing threaded programs| and it
|并且它总是出现。

485
00:14:56,620 --> 00:14:57,380
0,180 180,420
comes up

486
00:14:57,380 --> 00:14:58,760
0,300 300,360 360,810
all the time.|
|

487
00:14:59,520 --> 00:15:01,590
0,510 510,840 960,1230 1230,1620 1620,2070
Alright, so, {} how could
好的，那么，我们怎么让一个进程或一个线程等待这种事件，

488
00:15:01,590 --> 00:15:04,140
0,690 720,960 960,1050 1050,2250 2310,2550
we have a process or

489
00:15:04,140 --> 00:15:06,150
0,120 120,780 780,1200 1200,1560 1590,2010
a thread wait for this

490
00:15:06,150 --> 00:15:08,430
0,210 210,300 300,780 990,1560 1980,2280
kind of event,| {} so
|一种可能的非常简单的方法是，

491
00:15:08,430 --> 00:15:11,160
0,150 150,960 1260,1320 1530,2100 2100,2730
one possibility is extremely straightforward

492
00:15:11,160 --> 00:15:13,020
0,390 540,1050 1050,1320 1320,1530 1530,1860
one is| just a busy
|就是忙等待循环，

493
00:15:13,020 --> 00:15:14,080
0,600
wait

494
00:15:14,110 --> 00:15:15,340
0,150 150,690
to loop,|
|

495
00:15:15,770 --> 00:15:18,540
0,270 270,390 390,510 510,1260
so you could imagine.|
你可以想象。|

496
00:15:18,570 --> 00:15:19,440
0,150 150,240 240,600 600,720 720,870
And we'll discard this as
我们马上就会把它当作一个坏想法扔掉，

497
00:15:19,440 --> 00:15:20,070
0,60 60,300 300,510 510,570 570,630
a bad idea in a

498
00:15:20,070 --> 00:15:22,140
0,360 360,690 1410,1710 1710,1950 1950,2070
moment,| but let's say we
|但是假设我们想要从管道中读取，

499
00:15:22,140 --> 00:15:22,860
0,180 180,300 300,510 510,630 630,720
want to read from a

500
00:15:22,860 --> 00:15:24,390
0,660 720,1050 1050,1290 1290,1470 1470,1530
pipe,| we just write a
|我们在管道读取函数中编写了一个循环，

501
00:15:24,390 --> 00:15:25,650
0,360 360,450 450,540 540,900 930,1260
loop in the pipe read

502
00:15:25,650 --> 00:15:27,060
0,480 480,600 600,1260 1260,1350 1350,1410
function| that says you know
|也就是 while 管道缓冲器是空的，

503
00:15:27,060 --> 00:15:29,260
0,1050
while

504
00:15:29,320 --> 00:15:30,550
0,150 150,300 300,390 390,870 870,1230
you know the pipe buffer

505
00:15:30,550 --> 00:15:32,080
0,120 120,960
is empty,|
|

506
00:15:33,050 --> 00:15:37,280
0,840 1350,1650 1650,2670 2760,3570 3600,4230
{} we're gonna do absolutely
我们什么都不会做，

507
00:15:37,280 --> 00:15:38,520
0,420
nothing,

508
00:15:38,710 --> 00:15:39,910
0,360 420,570 570,750 750,960 960,1200
right,| now we're gonna let
|现在我们在这个循环中的旋转，

509
00:15:39,910 --> 00:15:40,990
0,330 330,390 390,570 570,870 870,1080
sit in this loop going

510
00:15:40,990 --> 00:15:42,220
0,240 240,540 540,600 600,750 750,1230
around around in this loop,|
|

511
00:15:42,340 --> 00:15:44,140
0,630 630,900 900,1170 1170,1380 1380,1800
until maybe some other thread
直到另一个线程或另一个核心

512
00:15:44,140 --> 00:15:45,850
0,120 120,360 360,930 990,1530 1530,1710
on another core| writes into
|写入缓冲区，使其不为空，

513
00:15:45,850 --> 00:15:46,660
0,120 120,450 450,540 540,720 720,810
the buffer and makes it

514
00:15:46,660 --> 00:15:47,680
0,240 240,660 660,750 750,870 870,1020
not empty| and then this
|然后这个循环就会结束，

515
00:15:47,680 --> 00:15:48,640
0,180 180,270 270,660 660,780 780,960
loop will finish| and then
|然后我们会返回数据，

516
00:15:48,640 --> 00:15:50,170
0,480 480,810 810,900 900,1350 1380,1530
we'll return the data| or
|或者无论我们如何处理这些数据。

517
00:15:50,170 --> 00:15:51,220
0,300 300,390 390,540 540,600 600,1050
whatever it is we're supposed

518
00:15:51,340 --> 00:15:52,120
0,120 120,270 270,390 390,450 450,780
to do with the data.|
|

519
00:15:53,320 --> 00:15:54,500
0,600

520
00:15:55,640 --> 00:15:56,640
0,60

521
00:15:56,700 --> 00:15:57,660
0,150 150,240 240,540 540,750 750,960
So you imagine writing code
所以，你可以想象这样编写代码，

522
00:15:57,660 --> 00:15:58,530
0,150 150,330 330,420 420,750 750,870
like this| and actually there
|实际上有一点，

523
00:15:58,530 --> 00:15:59,670
0,210 210,330 330,600 600,780 780,1140
is a little bit of,|
|

524
00:15:59,790 --> 00:16:01,500
0,240 240,480 480,1200 1230,1380 1380,1710
there may be {you,know} small
可能像这样有很少的代码，

525
00:16:01,500 --> 00:16:02,460
0,240 240,300 300,600 600,780 780,960
amount of code like this,|
|

526
00:16:02,460 --> 00:16:04,680
0,210 240,510 510,660 660,1530 1920,2220
like if you know that
如果你知道你等待的事情极有可能发生，

527
00:16:04,680 --> 00:16:05,610
0,90 90,270 270,420 420,720 720,930
the thing you're waiting for

528
00:16:05,610 --> 00:16:07,920
0,270 300,900 900,1680 1680,1770 1770,2310
is extremely likely to happen|
|

529
00:16:07,920 --> 00:16:08,970
0,300 330,540 540,900 900,960 960,1050
and a tenth of a
十分之一微秒，

530
00:16:08,970 --> 00:16:11,430
0,780 780,960 960,1410 1620,2280 2280,2460
microsecond,| let's say this may
|这种等待可能是最好的方式，

531
00:16:11,430 --> 00:16:12,240
0,180 180,300 300,570 570,720 720,810
be the best way to

532
00:16:12,240 --> 00:16:13,950
0,240 240,480 480,570 870,1290 1410,1710
wait for it,| so {}
|所以，对于一些设备硬件通常是这样完成的。

533
00:16:13,950 --> 00:16:15,450
0,390 390,570 570,690 690,1020 1020,1500
typically this is done with

534
00:16:15,480 --> 00:16:16,860
0,330 330,540 540,840 840,960 960,1380
{} some kind of device

535
00:16:16,860 --> 00:16:18,020
0,750
hardware.|
|

536
00:16:18,520 --> 00:16:19,600
0,180 180,300 300,510 510,570 570,1080
When you ask the device
当你要求设备硬件执行某些操作时，

537
00:16:19,630 --> 00:16:20,770
0,420 420,480 480,630 630,900 900,1140
hardware to do something,| you
|你知道它总是会在很短的时间内完成这项任务，

538
00:16:20,770 --> 00:16:22,510
0,630 660,810 810,960 960,1350 1350,1740
know it will always complete

539
00:16:22,510 --> 00:16:23,650
0,180 180,630 630,720 720,810 810,1140
that task in a tiny

540
00:16:23,650 --> 00:16:25,840
0,240 240,300 300,840
amount of time,|
|

541
00:16:25,870 --> 00:16:27,340
0,270 270,510 510,630 630,930 1050,1470
just sitting in a short
只是在一个短的循环里，可能是正确的选择。

542
00:16:27,340 --> 00:16:28,750
0,510 720,1020 1020,1140 1140,1200 1200,1410
loop can be the right

543
00:16:28,750 --> 00:16:30,460
0,420 450,750 750,1050 1140,1440 1440,1710
answer.| But if this might
|但是，如果这可能需要很多毫秒长的时间，

544
00:16:30,460 --> 00:16:32,200
0,330 330,540 540,780 780,1020 1020,1740
take a long time milliseconds,|
|

545
00:16:32,200 --> 00:16:32,830
0,120 120,240 240,390 390,570 570,630
or you just don't know
或者你不知道时间有多长，

546
00:16:32,830 --> 00:16:34,540
0,240 240,570 570,900 1110,1530 1530,1710
how long right,| maybe it's
|可能需要 10 分钟，

547
00:16:34,540 --> 00:16:35,920
0,120 120,210 210,630 660,900 900,1380
going to be ten minutes|
|

548
00:16:35,920 --> 00:16:37,480
0,360 360,660 660,1110 1110,1230 1230,1560
before whatever process is writing
在任何进程写入管道之前，

549
00:16:37,480 --> 00:16:40,270
0,90 90,630 1560,1890 1890,2160 2160,2790
the pipe actually writes anything,|
|

550
00:16:40,330 --> 00:16:41,110
0,360 360,450 450,600 600,720 720,780
then we don't want to
那么我们就不想在那里旋转，浪费 CPU 时间，

551
00:16:41,110 --> 00:16:42,520
0,330 330,600 600,720 720,1020 1020,1410
spin there and waste CPU

552
00:16:42,520 --> 00:16:43,990
0,510 540,780 780,990 990,1110 1110,1470
time,| which could be used
|它可以用来找到更多的 π 的数字或其他有用的东西，

553
00:16:43,990 --> 00:16:46,060
0,330 930,1470 1470,1650 1650,2010 2010,2070
to find more digits of

554
00:16:46,060 --> 00:16:47,890
0,510 510,690 690,990 990,1260 1260,1830
pi or something else useful,|
|

555
00:16:48,190 --> 00:16:49,690
0,480 540,750 750,930 930,1170 1200,1500
{} we want to give
相反，我们想放弃 CPU 。

556
00:16:49,690 --> 00:16:51,360
0,120 120,240 240,660 660,1320
up the CPU instead.|
|

557
00:16:52,060 --> 00:16:54,700
0,600 1020,1650 1650,2220 2250,2520 2520,2640
{} And only {we,want} some
我们想要像 swtch 一样放弃 CPU ，

558
00:16:54,700 --> 00:16:55,240
0,120 120,210 210,330 330,420 420,540
way to give up the

559
00:16:55,240 --> 00:16:56,920
0,360 360,570 570,1080 1110,1410 1410,1680
CPU like swtch,| but actually
|但在我们关心的事件发生时重新获得 CPU ，

560
00:16:56,920 --> 00:16:58,420
0,540 540,600 600,1140 1140,1410 1410,1500
regain the CPU when the

561
00:16:58,420 --> 00:16:59,860
0,300 300,420 420,630 630,1080 1170,1440
event we care about has

562
00:16:59,860 --> 00:17:01,420
0,330 330,870 930,1080 1080,1200 1200,1560
actually occurred| and it's that
|这种协调是一种技术，

563
00:17:01,420 --> 00:17:03,610
0,720 960,1650 1650,1770 1770,1920 1920,2190
that coordination is all about

564
00:17:03,610 --> 00:17:04,750
0,450 450,660 660,900 900,1020 1020,1140
techniques| to give up the
|放弃 CPU ，直到条件出现，我们等待的事件发生。

565
00:17:04,750 --> 00:17:07,630
0,810 960,1650 1680,2220 2250,2790 2790,2880
CPU until the condition, the

566
00:17:07,630 --> 00:17:08,980
0,390 390,480 480,630 630,990 990,1350
event that we're waiting for

567
00:17:08,980 --> 00:17:10,360
0,180 180,480 480,1050
has actually occurred.|
|

568
00:17:10,620 --> 00:17:13,860
0,510 810,1500 1530,2220 2400,2880 2880,3240
{} And again {} sleep
再一次， sleep/wakeup ，

569
00:17:13,860 --> 00:17:14,940
0,120 120,330 330,420 420,840 840,1080
and {wakeup -},| there's a
|有多种不同的协调原语，

570
00:17:14,940 --> 00:17:16,800
0,450 450,510 510,810 810,1350 1350,1860
number of different coordination primitives|
|

571
00:17:16,800 --> 00:17:17,910
0,90 90,330 330,450 450,930 930,1110
that people have invented over
在很多年中，人们发明的。

572
00:17:17,910 --> 00:17:19,980
0,60 60,720
the years.|
|

573
00:17:20,200 --> 00:17:21,940
0,240 240,420 420,540 540,1290 1320,1740
And {xv6 - -} {}
xv6 与许多 Unix 的风格相同，

574
00:17:21,940 --> 00:17:23,230
0,150 150,480 480,570 570,900 900,1290
in common with many flavors

575
00:17:23,230 --> 00:17:25,390
0,90 90,840 1410,1740 1740,1980 1980,2160
of Unix,| uses something called
|使用一种 sleep/wakeup 的东西。

576
00:17:25,390 --> 00:17:26,840
0,240 240,360 360,570 570,870
sleep and {wakeup -}.|
|

577
00:17:27,290 --> 00:17:29,440
0,540 900,1500
Okay, {}
好的，在这样的背景下，

578
00:17:29,440 --> 00:17:30,670
0,240 240,360 360,570 570,1140 1140,1230
alright, with this background,| I'd
|我想切换到查看 xv6 的代码。

579
00:17:30,670 --> 00:17:34,420
0,180 180,1230 1260,2130 2130,2940 3390,3750
like to switch to a

580
00:17:34,420 --> 00:17:36,190
0,330 330,720 750,1050 1050,1650 1650,1770
looking at {} {code,in} {xv6

581
00:17:36,190 --> 00:17:37,420
0,750
-}.|
|

582
00:17:41,940 --> 00:17:44,460
0,810 1170,1500 1500,1650 1650,2070 2070,2520
{} Alright, so {I,just} {}
好的，我刚分享了我的屏幕，

583
00:17:44,490 --> 00:17:46,530
0,390 390,510 510,1320 1440,1950 1950,2040
shared my screen,| let me
|如果屏幕共享起作用了，请让我知道。

584
00:17:46,530 --> 00:17:48,030
0,180 180,300 300,540 540,930 930,1500
know if the screen share

585
00:17:48,090 --> 00:17:50,460
0,150 150,300 300,780 1080,1710
did on work. {}|
|

586
00:17:50,460 --> 00:17:52,380
0,330 330,510 510,870 1050,1320 1320,1920
Okay, I have in preparation
好的，我已经为这次课程做了准备，

587
00:17:52,380 --> 00:17:55,500
0,120 120,330 330,870 1200,1770 2220,3120
for this lecture,| {} rewritten
|重写了 UART 驱动程序中的一些代码，

588
00:17:55,500 --> 00:17:57,090
0,240 240,330 330,390 390,1140 1170,1590
some of the code in

589
00:17:57,090 --> 00:17:59,340
0,270 270,780 780,1530 1560,1890 1890,2250
the uart driver,| that's the
|这是 xv6 用来从控制台读写字符的串行驱动程序，

590
00:17:59,460 --> 00:18:01,380
0,630 630,1110 1110,1380
serial driver that

591
00:18:01,410 --> 00:18:02,760
0,330 330,600 600,930 930,1110 1110,1350
{xv6 -} uses to read

592
00:18:02,760 --> 00:18:04,110
0,150 150,480 720,1170 1170,1290 1290,1350
and write characters from the

593
00:18:04,110 --> 00:18:06,270
0,660 1470,1740 1740,1860 1860,1980 1980,2160
console,| so I have this
|所以我写了这个 uartwrite 函数，

594
00:18:06,270 --> 00:18:07,620
0,330 330,510 510,690 690,1020 1020,1350
function {uartwrite - -},| which
|当像 shell 这样的程序打印提示符或产生任何其他输出时，

595
00:18:07,650 --> 00:18:08,640
0,300 300,420 420,750 750,900 900,990
when a program like the

596
00:18:08,640 --> 00:18:10,140
0,510 510,840 840,990 990,1440 1440,1500
shell prints its prompt or

597
00:18:10,140 --> 00:18:12,210
0,360 360,570 570,810 810,1290 1380,2070
produces any other output, {}|
|

598
00:18:12,990 --> 00:18:14,340
0,480 480,660 660,750 750,990 990,1350
that makes a write system
会使用一个 write 系统调用，

599
00:18:14,340 --> 00:18:16,140
0,450 450,810 990,1230 1230,1470 1470,1800
call| and in my slightly
|在我稍微修改的 xv6 版本中，

600
00:18:16,140 --> 00:18:17,160
0,390 390,660 660,720 720,900 900,1020
modified version of {xv6 -

601
00:18:17,160 --> 00:18:18,690
0,420 450,780 780,960 960,1230 1230,1530
-}| that write system call
|write 系统调用以 uartwrite 的调用结束，

602
00:18:18,720 --> 00:18:20,070
0,510 510,840 870,1050 1050,1080 1080,1350
ends up with a call

603
00:18:20,070 --> 00:18:21,750
0,150 150,390 390,570 600,1200 1290,1680
to {uartwrite - -},| in
|在 uart 驱动中，

604
00:18:21,750 --> 00:18:23,010
0,180 180,510 510,810 810,990 990,1260
the uart driver| which actually
|将这个循环中的字符逐个写入 uart 硬件。

605
00:18:23,010 --> 00:18:24,630
0,330 330,450 450,1260 1260,1410 1410,1620
writes the characters in this

606
00:18:24,630 --> 00:18:27,300
0,810 1200,1710 1710,1890 1890,2460 2490,2670
loop one by one to

607
00:18:27,300 --> 00:18:29,280
0,420 600,1020 1020,1740
the uart hardware.|
|

608
00:18:29,840 --> 00:18:31,740
0,570

609
00:18:31,740 --> 00:18:33,270
0,240 240,390 390,870 1140,1410 1410,1530
And this is written in
这是以一种经典的设备驱动程序风格编写的。

610
00:18:33,270 --> 00:18:34,890
0,60 60,210 210,300 300,1140 1230,1620
a sort of classic device

611
00:18:34,890 --> 00:18:37,300
0,330 330,1080
driver style.|
|

612
00:18:37,480 --> 00:18:38,890
0,210 210,360 360,630 630,870 870,1410
You'll see code like this
你会在许多设备驱动程序中看到这样的代码。

613
00:18:39,100 --> 00:18:40,570
0,360 360,480 480,720 720,990 990,1470
{} in many device drivers.|
|

614
00:18:41,920 --> 00:18:43,270
0,390 390,870 1050,1230 1230,1290 1290,1350
Okay, so one of the
好的，这里发生的一件事是，

615
00:18:43,270 --> 00:18:44,440
0,210 210,360 360,600 600,810 810,1170
things that's going on here

616
00:18:44,470 --> 00:18:46,000
0,150 150,330 330,420 420,780 780,1530
is| that the uart hardware
|uart 硬件一次只能接受一个字符进行传输，

617
00:18:46,030 --> 00:18:48,730
0,210 210,450 450,960 1740,2130 2130,2700
can only accept one character

618
00:18:48,730 --> 00:18:50,260
0,150 150,840 840,960 960,1020 1020,1530
for transmission at a time,|
|

619
00:18:50,530 --> 00:18:51,220
0,180 180,300 300,390 390,540 540,690
and so the way this
所以这段代码需要查看的，

620
00:18:51,220 --> 00:18:52,780
0,240 240,390 390,480 480,990 1110,1560
code has to look,| typically
|通常你有很多想要写入的字符，

621
00:18:52,780 --> 00:18:53,800
0,120 120,330 330,420 420,870 870,1020
have lots of characters you

622
00:18:54,040 --> 00:18:55,690
0,210 210,270 270,660 1380,1560 1560,1650
want to write,| it can
|它可以向 uart 硬件写入字符，

623
00:18:55,690 --> 00:18:56,560
0,210 210,240 240,690 690,750 750,870
write a character to the

624
00:18:56,560 --> 00:18:58,240
0,270 270,840 1230,1470 1470,1620 1620,1680
uart hardware,| {} and it
|它需要等待 uart 硬件

625
00:18:58,240 --> 00:18:58,930
0,150 150,270 270,510 510,600 600,690
needs to wait for the

626
00:18:58,930 --> 00:19:00,220
0,270 270,600 600,720 720,870 870,1290
uart hardware| to say yes
|是的，我已经把那个字符发送完了，

627
00:19:00,220 --> 00:19:01,780
0,210 240,720 750,1080 1080,1230 1230,1560
I finished sending that character,|
|

628
00:19:01,780 --> 00:19:02,500
0,120 120,330 330,510 510,570 570,720
I'm ready for a new
我准备好接受一个新的字符了，

629
00:19:02,500 --> 00:19:04,150
0,240 240,360 360,870 1230,1320 1320,1650
one| and then the driver
|然后驱动可以写入一个新的，

630
00:19:04,150 --> 00:19:04,990
0,150 150,360 360,390 390,540 540,840
can write a new one,|
|

631
00:19:05,640 --> 00:19:06,750
0,270 270,390 390,810 810,870 870,1110
a new character the next
下一个要输出的的新的字符，

632
00:19:06,750 --> 00:19:09,780
0,540 540,630 630,1080 1410,2460 2640,3030
character to output,| because this
|因为这个硬件运行起来非常慢，

633
00:19:09,780 --> 00:19:11,970
0,480 480,660 660,1110 1110,1470 1470,2190
hardware can operate very slowly,|
|

634
00:19:12,000 --> 00:19:13,530
0,330 390,810 810,990 990,1080 1080,1530
like maybe only a thousand
可能每秒只有一千个字符，

635
00:19:13,530 --> 00:19:15,270
0,510 510,600 600,1140 1320,1530 1530,1740
characters per second,| the amount
|我们在字符之间等待的时间可能非常长，

636
00:19:15,270 --> 00:19:15,840
0,60 60,210 210,300 300,420 420,570
of time we have to

637
00:19:15,840 --> 00:19:18,120
0,420 420,1050 1050,1950 2010,2160 2160,2280
wait between characters can be

638
00:19:18,120 --> 00:19:19,440
0,210 210,600 660,750 750,1260 1260,1320
very long,| in milliseconds in
|以毫秒为单位，在现代计算机上是很长的时间，

639
00:19:19,440 --> 00:19:20,940
0,90 90,480 480,810 810,1350 1350,1500
a long, long time, on

640
00:19:20,940 --> 00:19:22,950
0,330 330,810 810,1170 1470,1740 1740,2010
modern computer,| it's you know
|可能是十亿个，百万个机器周期，

641
00:19:22,950 --> 00:19:24,750
0,180 180,780 780,1290 1290,1350 1350,1800
a billion cycles a million

642
00:19:24,750 --> 00:19:27,120
0,510 510,900 1500,1890 1980,2160 2160,2370
cycles maybe,| which a huge
|这可以做大量的工作，

643
00:19:27,120 --> 00:19:27,660
0,150 150,210 210,390 390,480 480,540
amount of work could be

644
00:19:27,660 --> 00:19:29,190
0,210 210,540 660,960 960,1110 1110,1530
done,| so we'd really prefer
|所以，我们不希望只是旋转，

645
00:19:29,190 --> 00:19:31,290
0,270 270,510 510,780 780,1500 1530,2100
not to just spin| waiting
|等待 uart 完成每个字符的发送。

646
00:19:31,290 --> 00:19:32,010
0,120 120,210 210,420 420,600 600,720
for the {uart -} to

647
00:19:32,010 --> 00:19:33,620
0,300 300,570 570,750 750,1320
finish sending each character.|
|

648
00:19:33,710 --> 00:19:34,760
0,450 570,750 750,900 900,960 960,1050
{} We like to have
我们想要有更好的方式，

649
00:19:34,760 --> 00:19:36,230
0,60 60,300 300,720 870,1080 1080,1470
a better way,| and so
|事实上，像大多数操作系统一样， xv6 有更好的方式，

650
00:19:37,050 --> 00:19:38,670
0,120 120,540 840,1080 1080,1200 1200,1620
in fact, {xv6 - -}

651
00:19:38,670 --> 00:19:40,320
0,420 420,480 480,690 690,1050 1050,1650
has a better way like

652
00:19:40,320 --> 00:19:42,600
0,210 210,510 510,1080 1140,1830 1950,2280
most operating systems,| {} the
|uart 硬件在完成发送每个字符后引发中断，

653
00:19:42,600 --> 00:19:44,910
0,360 360,1140 1380,1830 1830,2160 2160,2310
uart hardware will raise an

654
00:19:44,910 --> 00:19:46,830
0,690 690,930 930,1110 1110,1590 1590,1920
interrupt after it's finished sending

655
00:19:46,830 --> 00:19:48,900
0,240 240,1080 1290,1680 1680,1830 1830,2070
each character,| {} and so
|所以我们不仅仅有这个写入例程，

656
00:19:48,930 --> 00:19:50,010
0,270 300,510 510,720 720,930 930,1080
we have not just this

657
00:19:50,010 --> 00:19:52,140
0,240 240,900 1500,1740 1740,1950 1950,2130
write routine,| we'll see uart
|我们将看到 uart 驱动程序有一个中断例程，

658
00:19:52,140 --> 00:19:53,730
0,300 300,450 450,540 540,990 990,1590
driver has an interrupt routine|
|

659
00:19:53,880 --> 00:19:55,350
0,570 600,840 840,1020 1020,1290 1290,1470
which I think {trap.c -
我认为会调用 trap.c ，

660
00:19:55,350 --> 00:19:56,760
0,210 210,690 690,840 840,930 930,1410
-} calls| when the uart
|当 uart 硬件发出中断通知已完成时，

661
00:19:56,760 --> 00:19:59,520
0,960 1140,1710 1710,1800 1800,2550 2610,2760
hardware raises an interrupt to

662
00:19:59,520 --> 00:20:00,660
0,180 180,300 300,480 480,900 900,1140
say that it's finished| and
|中断例程检查 uart ，

663
00:20:00,780 --> 00:20:02,440
0,210 210,540 540,1080
the interrupt routine

664
00:20:02,440 --> 00:20:03,700
0,540 540,660 660,870 870,1080 1080,1260
checks that {uart -}| to
|读取 uart 硬件中的一个内存映射寄存器，

665
00:20:03,730 --> 00:20:05,170
0,420 420,600 600,660 660,960 990,1440
read one of the memory

666
00:20:05,170 --> 00:20:06,520
0,240 240,870 870,960 960,1050 1050,1350
mapped registers in the uart

667
00:20:06,520 --> 00:20:08,140
0,570 960,1050 1050,1260 1260,1380 1380,1620
hardware| to look for the
|查找表示已经完成发送的标志，

668
00:20:08,170 --> 00:20:09,760
0,480 480,600 600,1080 1110,1320 1320,1590
flag that says I'm done

669
00:20:09,760 --> 00:20:11,620
0,690 750,900 900,990 990,1380 1500,1860
transmitting,| which is this {LSR_TX_IDLE
|应该是 LSR_TX_IDLE 标志，

670
00:20:11,620 --> 00:20:13,750
0,150 150,630 630,870 870,1410 1560,2130
- - -} flag,| and
|如果设置了这个标志，

671
00:20:13,750 --> 00:20:15,580
0,60 60,240 240,480 480,990 1050,1830
if that flag set,| then
|那么中断例程在内存中设置该标志，

672
00:20:15,850 --> 00:20:17,320
0,330 330,420 420,690 690,1050 1050,1470
{} the interrupt routine actually

673
00:20:17,590 --> 00:20:19,180
0,210 210,690 690,1230
{} sets this

674
00:20:19,180 --> 00:20:20,960
0,360 360,420 420,1050
flag in memory,|
|

675
00:20:21,020 --> 00:20:22,310
0,300 300,420 420,600 600,750 750,1290
{} and makes this wakeup
然后调用这个 wakeup 调用，

676
00:20:22,310 --> 00:20:24,980
0,540 690,1410 1440,1800 1800,2310 2310,2670
call| which will calls the
|这将调用 uartwrite ，

677
00:20:24,980 --> 00:20:26,990
0,270 270,510 540,1230 1290,1740 1740,2010
{uartwrite - -},| whatever thread
|不管 uartwrite 是哪个线程，

678
00:20:26,990 --> 00:20:28,130
0,90 90,210 210,450 450,840 840,1140
is in {uartwrtie -},| to
|从这里的睡眠中恢复过来，

679
00:20:28,130 --> 00:20:30,260
0,480 810,1440 1440,1590 1590,1740 1740,2130
{} return from its sleep

680
00:20:30,260 --> 00:20:33,320
0,570 720,1290 1830,2760 2760,2820 2820,3060
here| and attempt to send
|并尝试发送新字符。

681
00:20:33,320 --> 00:20:34,460
0,30 30,150 150,720
a new character.|
|

682
00:20:34,930 --> 00:20:36,070
0,150 150,240 240,540 540,780 780,1140
So the game is that,|
所以流程是这样的，|

683
00:20:37,020 --> 00:20:38,370
0,300 300,450 450,1050 1050,1260 1260,1350
if a thread needs to
如果线程需要等待某些东西，

684
00:20:38,370 --> 00:20:39,210
0,180 180,300 300,660 660,750 750,840
wait for something| and here
|在这里，我们需要等待 uart 硬件

685
00:20:39,210 --> 00:20:39,810
0,150 150,210 210,330 330,480 480,600
we are, we need to

686
00:20:39,810 --> 00:20:41,670
0,330 330,510 510,870 1200,1620 1620,1860
wait for the {uart -}

687
00:20:41,700 --> 00:20:42,960
0,600 600,750 750,900 900,1170 1170,1260
hardware| to be willing to
|能够接受新字符，

688
00:20:42,960 --> 00:20:44,190
0,300 300,330 330,450 450,1020 1050,1230
accept a new character| to
|通常调用 sleep ，并等待特定条件，

689
00:20:44,190 --> 00:20:46,050
0,210 210,840 1020,1620 1620,1770 1770,1860
call sleep waiting for a

690
00:20:46,050 --> 00:20:49,680
0,720 1020,1530 1530,2070 2220,2880 3150,3630
specific condition, usually,| {} and
|当条件满足时，

691
00:20:49,680 --> 00:20:51,690
0,270 270,330 330,900 900,1230 1230,2010
when the condition is fulfilled,|
|

692
00:20:51,960 --> 00:20:53,640
0,540 570,930 930,1080 1080,1590 1590,1680
{} code that realizes the
实现该条件的代码调用 wakeup 。

693
00:20:53,640 --> 00:20:55,080
0,450 450,570 570,1080 1080,1200 1200,1440
condition is fulfilled what called

694
00:20:55,080 --> 00:20:55,940
0,240 240,540
{wakeup -}.|
|

695
00:20:56,210 --> 00:20:57,200
0,180 180,360 360,720 720,810 810,990
So these sleeps and {wakeups
所以这些 sleep 和 wakeup 是成对的。

696
00:20:57,200 --> 00:20:58,500
0,150 150,240 240,780
-} are paired.|
|

697
00:20:58,890 --> 00:21:00,420
0,270 270,660 930,1320 1320,1410 1410,1530
{} And sleep will look
sleep 会查看实现情况，

698
00:21:00,420 --> 00:21:01,440
0,90 90,180 180,780 780,930 930,1020
at the implementation by and

699
00:21:01,440 --> 00:21:02,490
0,180 180,420 540,870 870,1020 1020,1050
by,| but sleep does a
|sleep 会做很多事情，

700
00:21:02,490 --> 00:21:03,750
0,210 210,300 300,750 750,900 900,1260
number of things| and then
|然后调用 swtch 来放弃 CPU 。

701
00:21:03,750 --> 00:21:05,790
0,330 330,1110 1140,1290 1290,1590 1590,2040
calls swtch in order to

702
00:21:05,820 --> 00:21:07,380
0,180 180,330 330,420 420,1020
give up the CPU.|
|

703
00:21:07,450 --> 00:21:08,740
0,660

704
00:21:08,800 --> 00:21:10,570
0,750 750,1050 1050,1290 1290,1380 1380,1770
One {} thing to notice
需要注意的一件事是，

705
00:21:10,570 --> 00:21:12,250
0,120 120,930 1050,1230 1230,1530 1530,1680
is| that the wakeup and
|wakeup 和 sleep 必须以某种方式联系在一起，

706
00:21:12,250 --> 00:21:13,180
0,270 270,390 390,510 510,660 660,930
sleep have to be linked

707
00:21:13,180 --> 00:21:15,130
0,360 360,990 1020,1200 1200,1590 1770,1950
together somehow,| that is {}
|就是我们调用 wakeup ，

708
00:21:15,130 --> 00:21:16,660
0,210 240,750 750,1050 1080,1290 1290,1530
{we,call} {wakeup -},| we really
|我们只想唤醒等待特定事件的线程，

709
00:21:16,660 --> 00:21:17,530
0,210 210,360 360,450 450,690 690,870
only want to {wakeup -}

710
00:21:17,860 --> 00:21:18,970
0,510 510,600 600,690 690,960 960,1110
threads that are waiting for

711
00:21:18,970 --> 00:21:20,710
0,90 90,810 810,1410 1410,1560 1560,1740
the specific event,| that we
|我们[意识到]已经发生，

712
00:21:20,710 --> 00:21:22,510
0,420 420,540 540,1050 1230,1470 1470,1800
realize has happened| and so
|所以 sleep 和 wakeup 都有这个参数，

713
00:21:22,810 --> 00:21:23,740
0,390 390,480 480,630 630,750 750,930
sleep and {wakeup -} take

714
00:21:23,740 --> 00:21:24,980
0,150 150,750
this argument|
|

715
00:21:25,010 --> 00:21:26,540
0,720 900,1110 1110,1230 1230,1440 1440,1530
{} which is called the
它被称为睡眠通道，

716
00:21:26,540 --> 00:21:28,310
0,420 420,1050 1290,1470 1470,1560 1560,1770
sleep channel,| it's {} {wakeup
|这里 wakeup 支持同样的值，我们传给 sleep 的值，

717
00:21:28,310 --> 00:21:30,020
0,210 210,1110 1110,1200 1200,1410 1410,1710
-} supplies the very same

718
00:21:30,020 --> 00:21:33,530
0,600 600,1350 1380,2040 2430,3150 3150,3510
value here, that we're passing

719
00:21:33,530 --> 00:21:35,090
0,90 90,720 750,1290 1290,1380 1380,1560
to sleep,| sleep and {wakeup
|sleep 和 wakeup 不会真的查看，

720
00:21:35,090 --> 00:21:36,920
0,90 90,480 810,1020 1020,1170 1170,1830
-} actually don't really look,|
|

721
00:21:37,010 --> 00:21:38,660
0,270 270,510 510,690 690,960 960,1650
don't care what these these,|
不在乎这些是什么，|

722
00:21:38,660 --> 00:21:40,430
0,180 180,360 360,540 540,1590 1590,1770
they just take 64 bit
它们在这里只取 64 位的值，

723
00:21:40,430 --> 00:21:41,420
0,450 450,600 600,660 660,780 780,990
values here,| they don't care
|它们不在乎它们是什么，

724
00:21:41,420 --> 00:21:43,280
0,120 120,240 240,420 420,780 1590,1860
what they are really,| the
|唯一发生的事情是，

725
00:21:43,280 --> 00:21:44,420
0,300 300,420 420,570 570,870 870,1140
only thing that's going on

726
00:21:44,420 --> 00:21:45,320
0,150 150,450
is that,|
|

727
00:21:46,170 --> 00:21:49,380
0,480 1500,1830 1830,2010 2010,2130 2130,3210
{} when if we sleep
当我们在特定的睡眠通道，等待通道上睡眠时，

728
00:21:49,880 --> 00:21:51,780
0,150 150,360 360,1320
on that particular

729
00:21:51,780 --> 00:21:54,000
0,480 510,990 990,1560 1560,1980 1980,2220
{} sleep channels, particular wait

730
00:21:54,000 --> 00:21:56,640
0,600 1500,2100 2100,2280 2280,2400 2400,2640
channel,| we want to {wakeup
|我们希望 wakeup 传递与此相同的值，

731
00:21:56,640 --> 00:21:57,720
0,180 180,270 270,630 630,750 750,1080
-} to pass the very

732
00:21:57,720 --> 00:21:59,370
0,360 360,780 780,1290 1290,1410 1410,1650
same value here,| in order
|表示它想要唤醒哪些睡眠者。

733
00:21:59,370 --> 00:22:01,200
0,120 120,390 390,630 1110,1410 1410,1830
to show that {} indicate

734
00:22:01,230 --> 00:22:02,490
0,420 420,870 870,960 960,1170 1170,1260
which sleepers it wants to

735
00:22:02,490 --> 00:22:03,360
0,210 210,450
{wakeup -}.|
|

736
00:22:06,020 --> 00:22:07,760
0,150 150,450 450,600 600,870 870,1740
Any questions about this interface?|
关于这个接口，有什么问题吗？|

737
00:22:08,000 --> 00:22:09,660
0,570 600,1050
{} Okay.|
好的。|

738
00:22:10,570 --> 00:22:11,920
0,330 360,540 540,780 780,840 840,1350
{} So there's a question
所以有一个问题需要确认，

739
00:22:11,920 --> 00:22:13,000
0,150 150,210 210,570 570,690 690,1080
just to clarify| the process
|进程不是对每个写入的字符唤醒。

740
00:22:13,000 --> 00:22:14,470
0,120 120,390 390,660 660,840 840,1470
is not woken up every

741
00:22:15,060 --> 00:22:16,530
0,120 120,300 300,720 720,990 990,1470
for every character that's written.|
|

742
00:22:20,550 --> 00:22:22,590
0,480 690,1050 1050,1260 1320,1560 1560,2040
Okay, let's see,| in this
好的，让我看看，|在这个为了演示而改写的驱动程序中，

743
00:22:22,590 --> 00:22:24,660
0,600 600,750 750,900 900,1410 1410,2070
driver that I've specially hacked

744
00:22:24,750 --> 00:22:28,020
0,270 270,930 930,1680 2820,3150 3150,3270
for demonstration purposes,| there's an
|每个字符都有一个中断，

745
00:22:28,020 --> 00:22:30,690
0,660 690,960 960,1740 1890,2280 2280,2670
interrupt per character,| so the
|所以 uartwrite 的工作方式是

746
00:22:30,690 --> 00:22:32,460
0,420 450,690 690,840 840,1560 1560,1770
the {} the way {uartwrite

747
00:22:32,460 --> 00:22:33,660
0,150 150,420 420,810 810,960 960,1200
- -} works is that|
|

748
00:22:33,690 --> 00:22:35,280
0,240 270,510 510,1200 1200,1350 1350,1590
for each character| that is
对于每个字符，|在这个 while 中，对于缓冲区中要写入的每个字符，

749
00:22:35,280 --> 00:22:36,120
0,60 60,210 210,570 570,780 780,840
in this while for each

750
00:22:36,120 --> 00:22:37,320
0,360 360,420 420,540 540,840 840,1200
character in the buffer character

751
00:22:37,320 --> 00:22:40,380
0,420 420,510 510,990 1200,1920 1980,3060
supposed to write,| we wait
|我们在这个循环中等待，

752
00:22:40,410 --> 00:22:42,450
0,720 750,870 870,1080 1080,1500 1680,2040
here in this loop,| until
|直到 uart 准备好接受另一个字符，

753
00:22:42,450 --> 00:22:43,260
0,90 90,420 420,510 510,720 720,810
the uart is ready to

754
00:22:43,260 --> 00:22:45,240
0,390 390,630 630,840 840,1590 1800,1980
accept one more character,| we
|我们再写入一个字符，

755
00:22:45,240 --> 00:22:47,040
0,300 300,510 510,720 720,1440
write one more character,|
|

756
00:22:47,340 --> 00:22:48,630
0,270 270,420 420,570 570,840 840,1290
we set this done flag
我们把这个完成标志设置为 0 ，

757
00:22:48,630 --> 00:22:51,630
0,120 120,870 1620,2160 2250,2760 2790,3000
to zero,| {} and go
|返回，在 sleep 中等待，知道完成标志为 1 。

758
00:22:51,630 --> 00:22:53,490
0,450 450,720 720,1320 1380,1770 1770,1860
back and wait typically in

759
00:22:53,490 --> 00:22:54,780
0,450 480,720 720,810 810,1020 1020,1290
sleep until the done flag

760
00:22:54,780 --> 00:22:55,880
0,90 90,480
is one.|
|

761
00:22:55,970 --> 00:22:57,470
0,420 540,720 720,810 810,1110 1110,1500
{} And then after the
然后，在 uart 发送完这个字符之后，

762
00:22:58,070 --> 00:22:59,450
0,180 180,420 420,840 840,1170 1170,1380
{uart -} finished sending this

763
00:22:59,450 --> 00:23:01,460
0,630 690,960 960,1590 1680,1920 1920,2010
character,| it'll interrupt and the
|它会中断，并且中断例程完成标志设置为 1 ，并进行唤醒，

764
00:23:01,460 --> 00:23:02,720
0,360 360,660 660,780 780,1050 1050,1260
interrupt routine will set done

765
00:23:02,720 --> 00:23:03,410
0,60 60,360 360,480 480,600 600,690
to one and do the

766
00:23:03,410 --> 00:23:04,280
0,240 240,390 390,570 570,630 630,870
{wakeup -},| so in fact
|所以，这里有一个 sleep wakeup ，

767
00:23:04,280 --> 00:23:05,560
0,120 120,270 270,600
there is a

768
00:23:05,560 --> 00:23:07,030
0,420 420,630 630,1050 1050,1200 1200,1470
wake- {} sleep and {wakeup

769
00:23:07,030 --> 00:23:07,930
0,180 180,270 270,360 360,840 840,900
-}| in an iteration of
|对于每个字符的循环的迭代中，

770
00:23:07,930 --> 00:23:08,950
0,120 120,480 480,600 600,780 780,1020
the loop for every single

771
00:23:08,950 --> 00:23:12,310
0,630 1950,2310 2310,2850 2940,3090 3090,3360
character| and more the uart
|uart 实际上有能力发送一些数量，

772
00:23:12,310 --> 00:23:14,740
0,150 150,540 540,1080 1080,1410 1530,2430
is actually capable of sending

773
00:23:15,340 --> 00:23:17,820
0,720 750,1230 1230,1590 1590,1980
{} some number,| like
|比如 4 个或 16 个或更多字符，

774
00:23:17,850 --> 00:23:19,860
0,600 600,1170 1170,1260 1260,1500 1500,2010
4 16 or something characters

775
00:23:19,860 --> 00:23:20,460
0,90 90,150 150,420 420,540 540,600
at a time,| so a
|所以，更高效的驱动程序

776
00:23:20,460 --> 00:23:22,650
0,210 210,570 570,990 990,1320 1740,2190
more efficient driver| would would
|在这个循环的每次迭代中向 uart 传递 16 个字符，

777
00:23:22,920 --> 00:23:25,050
0,480 510,960 960,1530 1530,2040 2040,2130
{} hand 16 characters to

778
00:23:25,050 --> 00:23:27,480
0,120 120,690 1050,1560 1590,1920 1920,2430
the uart {} per iteration

779
00:23:27,480 --> 00:23:28,740
0,90 90,300 300,750 930,1110 1110,1260
of this loop| and there'd
|每 16 个字符有一个中断，

780
00:23:28,740 --> 00:23:29,940
0,90 90,180 180,600 600,780 780,1200
be an interrupt every 16

781
00:23:29,940 --> 00:23:32,190
0,600 750,990 990,1320 1320,1590 1590,2250
characters| and higher speed devices
|并且更高速的设备，比如以太网驱动器，

782
00:23:32,520 --> 00:23:34,560
0,180 180,570 570,810 840,1410 1410,2040
are typically like ethernet drivers,|
|

783
00:23:35,050 --> 00:23:36,520
0,390 390,690 690,930 930,1140 1140,1470
typically accept many more bytes
通常每个中断接收多得多的字节。

784
00:23:36,520 --> 00:23:38,720
0,90 90,450 600,930 930,1590
than that per interrupt.|
|

785
00:23:39,890 --> 00:23:42,260
0,660 1140,1890
Alright. {}|
好的。|

786
00:23:42,320 --> 00:23:43,280
0,330 330,480 480,630 630,720 720,960
Okay, so this is just
好的，这只是接口概况的展示。

787
00:23:43,280 --> 00:23:45,420
0,180 330,1020 1020,1200 1200,1560
an illustration of {}

788
00:23:46,250 --> 00:23:47,450
0,150 150,240 240,630 630,840 840,1200
what the interface looks like.|
|

789
00:23:48,140 --> 00:23:50,750
0,570 1380,1920 1950,2340 2340,2460 2460,2610
{} {} Sleep and {wakeup
sleep 和 wakeup 很好用，

790
00:23:50,750 --> 00:23:51,950
0,90 90,180 180,450 450,1020 1080,1200
-} are nice,| because for
|它们好用的一个原因是，它们相对灵活，

791
00:23:51,950 --> 00:23:53,180
0,300 300,540 540,660 660,1050 1050,1230
one reason they're nice, they're

792
00:23:53,180 --> 00:23:55,460
0,480 480,1350 1740,2040 2040,2220 2220,2280
relatively flexible,| sleep {wakeup -}
|sleep wakeup 并不关心 uart 是什么。

793
00:23:55,460 --> 00:23:56,450
0,180 180,420 420,720 720,900 900,990
don't really care what it

794
00:23:56,450 --> 00:23:58,820
0,120 120,330 330,510 510,900
is {uart -} to.|
|

795
00:23:58,880 --> 00:24:00,120
0,120 120,270 270,660
Yeah, you can.|
是的，你可以。|

796
00:24:00,730 --> 00:24:01,720
0,360 360,450 450,540 540,660 660,990
You don't have to tell
你不必告诉 sleep 你在等什么，

797
00:24:01,720 --> 00:24:02,950
0,390 390,480 480,600 600,900 900,1230
sleep what you're waiting for,|
|

798
00:24:02,950 --> 00:24:03,610
0,90 90,210 210,300 300,420 420,660
you don't have to tell
不必告诉 wakeup 发生了什么事，

799
00:24:03,610 --> 00:24:05,140
0,360 360,540 540,810 810,1230 1320,1530
wakeup what event happened,| you
|你只需要使用匹配的睡眠通道 64 位值。

800
00:24:05,140 --> 00:24:05,890
0,210 210,330 330,390 390,540 540,750
just need to have these

801
00:24:05,890 --> 00:24:08,620
0,720 840,1320 1320,1950 2070,2580 2580,2730
matching sleep channel 64 bit

802
00:24:08,620 --> 00:24:09,760
0,660
values.|

803
00:24:10,790 --> 00:24:13,610
0,720 900,1410 1440,1620 1620,2130 2130,2820
However, {} there's one {}
然而， sleep 接口有一个有趣的属性，

804
00:24:13,610 --> 00:24:15,920
0,720 840,1650 1650,1920 1920,2040 2040,2310
interesting property of the sleep

805
00:24:15,920 --> 00:24:17,570
0,600 750,1020 1020,1110 1110,1200 1200,1650
interface,| we have to pass
|我们要在这里传递一个锁，

806
00:24:17,570 --> 00:24:19,040
0,150 150,300 300,660 660,1200 1260,1470
it a lock here,| there's
|第二个参数，这个锁参数，

807
00:24:19,040 --> 00:24:21,320
0,60 60,420 420,1020 1470,2010 2040,2280
a second argument, {} this

808
00:24:21,320 --> 00:24:23,720
0,300 300,840 1140,1890
lock argument| and
|为什么 sleep 需要第二个参数，背后有一个很大的故事。

809
00:24:23,990 --> 00:24:25,850
0,570 660,870 870,930 930,1170 1170,1860
{} there's a big story

810
00:24:25,880 --> 00:24:28,100
0,540 540,1110 1110,1710 1740,2070 2070,2220
behind why sleep takes this

811
00:24:28,100 --> 00:24:30,480
0,390 390,990
second argument.|
|

812
00:24:30,480 --> 00:24:32,550
0,540 750,1230 1230,1350 1350,1680 1680,2070
And {} I'm gonna explain
我会解释这是怎么回事，

813
00:24:32,550 --> 00:24:34,380
0,210 210,450 450,930 960,1380 1410,1830
what's going on,| but the
|但更高层次的画面是，

814
00:24:34,380 --> 00:24:36,840
0,210 210,780 1230,2070 2070,2220 2220,2460
high level picture is,| that
|这似乎是不可能的，

815
00:24:38,940 --> 00:24:40,170
0,360 360,660 660,900 900,1170 1170,1230
it's not doesn't seem to

816
00:24:40,170 --> 00:24:42,480
0,150 150,750 1140,1530 1710,2250 2250,2310
be possible| to design a
|设计一种完全不知道你要等待的是什么的 sleep 。

817
00:24:42,480 --> 00:24:45,480
0,570 570,1170 1380,1560 1560,2250 2250,3000
sleep that is completely ignorant

818
00:24:45,510 --> 00:24:46,920
0,510 540,990 990,1080 1080,1260 1260,1410
of what it is you're

819
00:24:46,920 --> 00:24:48,300
0,210 210,330 330,600 600,1020
trying to wait for.|
|

820
00:24:48,470 --> 00:24:49,560
0,540

821
00:24:50,420 --> 00:24:51,680
0,480 480,780 780,1020 1020,1200 1200,1260
It's hard to write a
很难写出一种通用的 sleep ，

822
00:24:51,680 --> 00:24:52,850
0,150 150,210 210,510 510,810 810,1170
sort of general purpose sleep,|
|

823
00:24:52,850 --> 00:24:54,920
0,240 510,990 990,1530 1560,1950 1950,2070
that simply sleeps waiting for
它只是在睡眠，等待一些特定的事件，

824
00:24:54,920 --> 00:24:57,170
0,180 180,690 690,1170 1470,1920 2040,2250
some specific event| {} and
|这很危险，

825
00:24:57,170 --> 00:24:58,160
0,210 210,360 360,750 750,900 900,990
this is danger,| which we'll
|我们稍后会看到，称为 lost wakeups ，

826
00:24:58,160 --> 00:24:58,940
0,180 180,270 270,330 330,600 600,780
see in a moment called

827
00:24:58,940 --> 00:25:00,890
0,330 330,570 570,1170 1200,1530 1650,1950
lost {wakeups -}| that just
|每种协调机制，

828
00:25:00,890 --> 00:25:02,690
0,210 210,450 450,1110 1110,1590 1590,1800
about every coordination mechanism| has
|必须以某种方式处理这种问题。

829
00:25:02,690 --> 00:25:03,980
0,180 180,540 540,720 720,1200 1200,1290
to grapple with somehow and

830
00:25:03,980 --> 00:25:06,300
0,180 180,300 300,900
deal with somehow.|
|

831
00:25:06,360 --> 00:25:08,460
0,420 420,840 840,930 930,1290 1290,2100
And then the sleep interface,
而 sleep 接口，我们必须传入一个锁，

832
00:25:08,520 --> 00:25:09,660
0,390 390,720 720,990 990,1050 1050,1140
{} this fact, we have

833
00:25:09,660 --> 00:25:10,650
0,90 90,360 360,420 420,840 840,990
to pass a lock| is
|是一种有点丑陋的实现，

834
00:25:10,650 --> 00:25:11,670
0,270 270,390 390,540 540,780 780,1020
sort of a little bit

835
00:25:11,670 --> 00:25:14,850
0,390 570,1470 1470,2490 2520,2910 2910,3180
of ugly implementation,| leaking through
|以某种方式泄漏到接口中，

836
00:25:14,850 --> 00:25:16,800
0,210 210,360 360,1110 1140,1500 1560,1950
into the interface in {a,way},|
|

837
00:25:16,800 --> 00:25:17,700
0,150 150,570 570,660 660,840 840,900
I'll explain in just a
我稍后会解释。

838
00:25:17,700 --> 00:25:18,520
0,300
moment.|
|

839
00:25:22,080 --> 00:25:23,130
0,240 240,390 390,840 840,960 960,1050
Yeah, I'll explain,| this is
好的，我会解释，|有一个问题，

840
00:25:23,130 --> 00:25:23,730
0,60 60,330 330,450 450,510 510,600
a question,| why do we
|为什么我们需要完成标志和睡眠通道？

841
00:25:23,730 --> 00:25:25,410
0,180 180,360 360,600 600,1110 1200,1680
need the done flag and

842
00:25:25,410 --> 00:25:27,030
0,90 90,390 390,810 840,1050 1050,1620
the sleep channel?| I will
|我会抓住这个问题，

843
00:25:27,030 --> 00:25:28,140
0,270 270,360 360,420 420,570 570,1110
hold on to that question,|
|

844
00:25:28,230 --> 00:25:29,790
0,600 630,870 870,1230 1230,1410 1410,1560
{} I'll explain that in
在五分钟或十分钟后解释这个问题。

845
00:25:29,790 --> 00:25:31,340
0,210 210,270 270,420 420,1080
five or ten minutes.|
|

846
00:25:32,000 --> 00:25:34,880
0,480 1110,1410 1410,1800 2040,2370 2400,2880
{} Okay, so {} before
好的，在解释为什么 sleep 要用这个锁之前，

847
00:25:34,880 --> 00:25:36,830
0,630 630,1170 1170,1710 1710,1830 1830,1950
explaining why it is that

848
00:25:36,830 --> 00:25:37,730
0,270 270,360 360,630 630,720 720,900
sleep is doing with this

849
00:25:37,730 --> 00:25:39,320
0,420 630,930 930,930 930,1380 1380,1590
lock,| {} I actually want
|我想讨论一下，

850
00:25:39,320 --> 00:25:40,720
0,390 450,780
to {}

851
00:25:40,720 --> 00:25:41,860
0,330 330,570 570,630 630,840 840,1140
{} talk a bit| about
|如果我们有一个更简单的 sleep 会有什么影响，

852
00:25:41,860 --> 00:25:43,270
0,210 210,300 300,900 900,1050 1050,1410
what the implications would be

853
00:25:43,270 --> 00:25:44,680
0,390 570,1080 1080,1200 1200,1320 1320,1410
if {} we had a

854
00:25:44,680 --> 00:25:47,500
0,450 450,1170 1530,1890 1890,2400 2430,2820
simpler sleep,| {} that didn't
|它不需要额外的锁参数。

855
00:25:47,500 --> 00:25:49,060
0,330 330,570 570,810 810,1050 1110,1560
have didn't take that extra

856
00:25:49,090 --> 00:25:52,880
0,330 330,870 2040,3090
lock argument.| So.|
|所以。|

857
00:25:59,180 --> 00:26:01,100
0,450 450,900
Alright so.|
好的，那么。|

858
00:26:02,080 --> 00:26:03,360
0,690

859
00:26:05,390 --> 00:26:06,950
0,180 180,240 240,570 570,930 930,1560
And the topic here is
这里的主题是 lost wakeups ，

860
00:26:06,980 --> 00:26:08,880
0,210 210,570 570,810 810,1380
{} lost {wakeups -},|
|

861
00:26:12,040 --> 00:26:13,540
0,390 390,780
that's the
这是现在要描述的问题。

862
00:26:14,350 --> 00:26:16,930
0,450 450,660 660,1170 1170,1470 2010,2580
problem gonna describe now. {}|
|

863
00:26:17,320 --> 00:26:19,340
0,450 750,1410
so, {}
所以，假设接口只是

864
00:26:19,340 --> 00:26:21,020
0,540 540,930 930,1050 1050,1470 1470,1680
suppose that the interface was|
|

865
00:26:21,020 --> 00:26:24,160
0,720 750,1320 1650,2610
just {} sleep
sleep 在任意的通道上，没有第二个参数，

866
00:26:25,300 --> 00:26:27,400
0,330 330,540 540,1110 1110,1530 1530,2100
on this arbitrary channel value
在没有第二自变量的该任意信道值上，

867
00:26:27,430 --> 00:26:30,250
0,240 240,690 720,1140 1140,1710 1980,2820
with no second argument, {}|
|

868
00:26:31,570 --> 00:26:33,010
0,540 840,990 990,1170 1170,1290 1290,1440
{} you can't make this
这个不能正常工作，

869
00:26:33,010 --> 00:26:33,820
0,240 240,330 330,420 420,690 690,810
work,| so I'm actually gonna
|所以我把这叫做 broken_sleep 。

870
00:26:33,820 --> 00:26:35,940
0,180 180,360 360,780 780,1560
call this {broken_sleep -}.|
|

871
00:26:37,560 --> 00:26:39,930
0,390 390,840 1200,1380 1380,1470 1470,2370
{} And you could imagine,|
你可以想象，|

872
00:26:39,960 --> 00:26:40,950
0,450 450,570 570,660 660,840 840,990
{} if we didn't know
如果我们不是更清楚地知道这一点，

873
00:26:40,950 --> 00:26:42,540
0,330 330,630 720,1140 1140,1260 1260,1590
better that,| { -} sleep
|这样的 sleep 可以简单地将进程状态设置为这个特殊的休眠值，

874
00:26:42,540 --> 00:26:45,120
0,150 150,360 360,570 570,1290 1980,2580
like this could simply set

875
00:26:45,120 --> 00:26:46,340
0,600
the

876
00:26:46,380 --> 00:26:48,340
0,690 690,870 870,1380
state of the

877
00:26:48,400 --> 00:26:49,960
0,990
process

878
00:26:50,200 --> 00:26:51,790
0,150 150,330 330,750 750,1140 1140,1590
to this special sleeping value|
|

879
00:26:51,790 --> 00:26:52,600
0,180 180,480 480,540 540,660 660,810
which says I don't want
表示不想继续运行了，我在等待一个特定的事件，

880
00:26:52,600 --> 00:26:53,680
0,60 60,240 240,720 720,930 930,1080
to run anymore, {I'm -}

881
00:26:53,680 --> 00:26:55,210
0,360 360,480 480,540 540,990 990,1530
waiting for a specific event|
|

882
00:26:55,660 --> 00:26:56,650
0,270 270,630 630,720 720,840 840,990
and then if you look
如果你看一下 sleep 的 xv6 实现，

883
00:26:56,650 --> 00:26:58,270
0,90 90,390 420,1050 1050,1530 1530,1620
at the xv6 implementation of

884
00:26:58,270 --> 00:26:59,080
0,270 270,390 390,510 510,600 600,810
sleep,| you'll see it does
|你会看到它还做了其他事情，

885
00:26:59,080 --> 00:27:01,900
0,360 390,720 720,960 960,1530 2400,2820
this among other things,| we
|我们需要记录这个特殊的睡眠通道值，

886
00:27:01,900 --> 00:27:03,730
0,180 180,390 390,960 960,1110 1110,1830
need to record this special

887
00:27:03,730 --> 00:27:05,540
0,390 390,750 750,1320
sleep channel value,|
|

888
00:27:05,540 --> 00:27:06,680
0,180 180,360 360,390 390,720 720,1140
so that a future call
这样将来的 wakeup 调用就可以意识到我们在等待的东西，

889
00:27:06,710 --> 00:27:08,240
0,210 210,420 420,570 570,870 900,1530
to {wakeup -} can realize

890
00:27:08,240 --> 00:27:09,350
0,90 90,240 240,540 540,930 930,1110
that we're actually waiting for

891
00:27:09,350 --> 00:27:10,340
0,300
the

892
00:27:10,340 --> 00:27:11,570
0,30 30,300 300,480 480,660 660,1230
{thing -},| that the {}
|wakeup 为我们唤醒，

893
00:27:12,940 --> 00:27:13,900
0,270 270,390 390,510 510,840 840,960
{wakeup -} is waking us

894
00:27:13,900 --> 00:27:15,100
0,150 150,390 390,660 780,1020 1020,1200
up for,| so you could
|你可以想象 sleep 被打破，

895
00:27:15,100 --> 00:27:16,720
0,330 330,690 690,1260 1290,1440 1440,1620
imagine a sleep and would

896
00:27:16,720 --> 00:27:18,520
0,90 90,600 630,1050 1080,1410 1410,1800
be broken,| that really just
|它只做了这些，

897
00:27:18,520 --> 00:27:19,480
0,180 180,630 660,750 750,870 870,960
did this,| I guess you'd
|我想你也必须获取这个进程的锁。

898
00:27:19,480 --> 00:27:22,060
0,90 90,360 360,660 840,1620 2010,2580
have to take acquire {}

899
00:27:22,740 --> 00:27:24,300
0,330 330,720 720,870 870,1140 1140,1560
this process is locked also.|
|

900
00:27:25,890 --> 00:27:26,700
0,300 300,420 420,510 510,570 570,810
{} And then of course,
当然，然后[] wakeup 。

901
00:27:26,700 --> 00:27:28,200
0,210 210,930
[] wakeup.|
|

902
00:27:31,920 --> 00:27:33,200
0,720

903
00:27:34,280 --> 00:27:35,120
0,150 150,270 270,480 480,660 660,840
And this really is pretty
这是关于 wakeup 是如何工作的，

904
00:27:35,120 --> 00:27:36,740
0,180 180,300 300,690 690,1200 1410,1620
much how wakeup works, {}|
|

905
00:27:36,740 --> 00:27:37,400
0,150 150,300 300,360 360,540 540,660
we want to {wakeup -}
我们想唤醒所有的线程，

906
00:27:37,400 --> 00:27:38,450
0,240 240,390 390,840 840,960 960,1050
all the threads| that are
|它们正在等待，使用了特定的信道值调用 sleep ，

907
00:27:38,450 --> 00:27:40,010
0,420 420,840 1050,1260 1260,1320 1320,1560
waiting on that are called

908
00:27:40,010 --> 00:27:41,510
0,420 420,540 540,720 720,1170 1170,1500
sleep with this particular channel

909
00:27:41,510 --> 00:27:42,860
0,450 630,960 960,1110 1110,1200 1200,1350
value,| {} so we're just
|所以我们只是，

910
00:27:42,860 --> 00:27:43,820
0,120 120,180 180,660 660,780 780,960
going to say,| you know
|for each p 和进程表，

911
00:27:43,820 --> 00:27:45,220
0,210 210,900
for each

912
00:27:45,960 --> 00:27:48,240
0,660 660,1170 1200,1290 1290,1740 1740,2280
p and the process table,|
|

913
00:27:51,530 --> 00:27:54,060
0,570 750,1890
{} if
如果状态是睡眠状态，

914
00:27:55,410 --> 00:27:57,630
0,180 180,600 750,930 930,1260 1260,2220
the state if it's sleeping,|
|

915
00:28:00,790 --> 00:28:03,880
0,540 570,1290 1530,1860 1860,2430 2430,3090
{} and it's sleeping on
它睡眠在我们要唤醒的信道上，

916
00:28:04,120 --> 00:28:05,380
0,180 180,600 600,750 750,900 900,1260
the channel that we're waking

917
00:28:05,380 --> 00:28:06,460
0,540
up,|
|

918
00:28:12,250 --> 00:28:13,600
0,750

919
00:28:13,990 --> 00:28:16,420
0,840 870,1230 1230,1320 1320,1800 1800,2430
then set the state to
然后将状态设置为可运行的，

920
00:28:17,370 --> 00:28:18,440
0,510
runnable,|
|

921
00:28:22,230 --> 00:28:23,820
0,360 360,780 780,1140 1140,1350 1350,1590
actually modular [], this is
实际上模块[]，这就是 wakeup 所做的。

922
00:28:23,820 --> 00:28:25,350
0,300 300,570 570,840 840,1140 1170,1530
pretty much what a wakeup

923
00:28:25,350 --> 00:28:26,380
0,510
does.|
|

924
00:28:27,370 --> 00:28:28,700
0,720

925
00:28:29,410 --> 00:28:31,990
0,360 360,690 1020,1590 2010,2250 2250,2580
Okay, so {}, some alternate
好吧，这个替补的[]会更好，

926
00:28:31,990 --> 00:28:33,340
0,450 450,630 630,780 780,870 870,1350
[] [] would be nice,|
|

927
00:28:33,340 --> 00:28:34,450
0,360 390,690 690,780 780,990 990,1110
if sleep and {wakeup -}
如果 sleep 和 wakeup 都这么简单。

928
00:28:34,450 --> 00:28:35,740
0,90 90,240 240,750
with this simple.|
|

929
00:28:35,740 --> 00:28:36,920
0,600

930
00:28:37,060 --> 00:28:39,490
0,450 450,540 540,1140 1140,1740 1860,2430
Let me demonstrate though, {}|
让我来演示一下，|

931
00:28:45,500 --> 00:28:47,500
0,330 330,390 390,1050
let me demonstrate.|
让我来演示一下。|

932
00:28:47,840 --> 00:28:49,620
0,720

933
00:28:50,520 --> 00:28:52,480
0,1200

934
00:28:55,060 --> 00:28:56,440
0,390 660,1050 1050,1110 1110,1200 1200,1380
Well, before I go back
在我回到 xv6 代码之前，

935
00:28:56,440 --> 00:28:58,030
0,120 120,420 420,750 750,1230 1230,1590
to the {xv6 -} code,|
|

936
00:28:58,390 --> 00:28:59,740
0,420 480,720 720,810 810,960 960,1350
{} let me just outline|
让我来概述一下，|

937
00:28:59,740 --> 00:29:00,880
0,240 240,360 360,510 510,990 990,1140
how you would use this
你将如何在 uart 驱动程序中使用这个 sleep 和 wakeup ，

938
00:29:00,880 --> 00:29:02,590
0,300 300,420 420,660 660,1080 1590,1710
sleep and {wakeup -} in

939
00:29:02,590 --> 00:29:03,490
0,90 90,360 360,690 690,780 780,900
the uart driver| and this
|在某种程度上，是我们已经看到的情况的重复，

940
00:29:03,490 --> 00:29:04,360
0,60 60,210 210,270 270,390 390,870
is sort of a repeat

941
00:29:04,360 --> 00:29:05,350
0,60 60,180 180,330 330,570 570,990
of what we've already seen,|
|

942
00:29:05,350 --> 00:29:07,480
0,180 180,540 540,990 1230,1710 1710,2130
but using this slightly simpler
但是使用这个稍微简单一点的接口。

943
00:29:07,480 --> 00:29:08,640
0,720
interface.|
|

944
00:29:08,700 --> 00:29:11,140
0,510 630,1020 1020,1140 1140,1920
{} You would have.|
你会有。|

945
00:29:11,140 --> 00:29:12,280
0,210 210,540 540,600 600,870 870,1140
And indeed the driver does
驱动完成这个，有完成标志，

946
00:29:12,280 --> 00:29:13,330
0,210 210,300 300,480 480,720 720,1050
this you have this done

947
00:29:13,330 --> 00:29:14,740
0,840
flag,|
|

948
00:29:15,570 --> 00:29:17,970
0,630 810,1230 1230,1410 1410,1620 1620,2400
{} then {uartwrite - -},|
然后 uartwrite ，|

949
00:29:22,740 --> 00:29:24,870
0,840 1290,1500 1500,1710 1710,1830 1830,2130
{} you know would say
对于缓冲区中的每个字符，

950
00:29:24,870 --> 00:29:26,580
0,210 210,1140
for each

951
00:29:27,690 --> 00:29:29,720
0,600 600,660 660,750 750,1470
character in the buffer,|
|

952
00:29:32,060 --> 00:29:34,310
0,780 1200,1440 1440,1560 1560,1920 1920,2250
{} and then which check
然后检查完成标志，

953
00:29:34,310 --> 00:29:35,990
0,180 180,450 450,1140 1170,1470 1470,1680
this done flag| just say
|还没有完成，就去睡觉，

954
00:29:35,990 --> 00:29:37,620
0,240 240,480 480,990
while not done,

955
00:29:41,220 --> 00:29:42,880
0,240 240,330 330,1290
go to sleep,|
|

956
00:29:44,880 --> 00:29:46,620
0,180 180,330 330,870 870,1200 1200,1740
and then pass that {}
然后传递一个信道，不管是 tx_chan 还是别的，

957
00:29:47,010 --> 00:29:49,800
0,570 570,930 930,1650 1650,2340 2340,2790
channel whatever was {tx_chan -}

958
00:29:49,800 --> 00:29:51,020
0,60 60,660
or something,|
|

959
00:29:51,410 --> 00:29:52,940
0,300 300,450 450,1020 1110,1440 1440,1530
doesn't really matter.| Okay and
其实并不重要。|好的，然后我们将 c 发送给 uart ，

960
00:29:52,940 --> 00:29:54,470
0,120 120,270 270,420 420,840 840,1530
then we're gonna send c

961
00:29:55,820 --> 00:29:57,400
0,150 150,240 240,960
to the uart,|
|

962
00:29:57,430 --> 00:29:59,500
0,480 480,690 690,960 960,1260 1260,2070
{} and set done equals
并将 done 设置为 0 。

963
00:30:00,640 --> 00:30:02,040
0,480 510,870
zero right.|
|

964
00:30:03,030 --> 00:30:04,200
0,420 420,570 570,690 690,780 780,1170
{} And then the interrupt
然后，中断例程将其完成标志设置为真，

965
00:30:04,200 --> 00:30:05,460
0,690
routine

966
00:30:07,990 --> 00:30:09,190
0,420 420,690 690,750 750,930 930,1200
just sets it done flag

967
00:30:09,190 --> 00:30:10,800
0,120 120,300 300,390 390,1050
is equal to true,|
|

968
00:30:10,830 --> 00:30:11,490
0,150 150,210 210,390 390,540 540,660
and of course {wakeup -}.|
当然还有 wakeup 。|

969
00:30:12,100 --> 00:30:13,240
0,570

970
00:30:13,660 --> 00:30:14,440
0,270 270,420 420,480 480,660 660,780
So this is how we
所以，这就是我们如何使用这种简化的 broken_sleep 。

971
00:30:14,440 --> 00:30:16,020
0,150 150,1050
could use

972
00:30:17,220 --> 00:30:19,470
0,270 270,420 420,1230 1230,1650 1650,2250
{} this simplified {broken_sleep -}.|
|

973
00:30:19,680 --> 00:30:20,430
0,240 240,330 330,450 450,570 570,750
Alright, so this is really
好的，这其实是 broken_sleep 。

974
00:30:20,430 --> 00:30:22,280
0,450 450,960
{broken_sleep -}.|
|

975
00:30:22,400 --> 00:30:24,530
0,480 1050,1290 1290,1470 1470,1620 1620,2130
{} With this is missing
这里，缺少的是锁，

976
00:30:24,530 --> 00:30:26,740
0,630 660,840 840,1560
though is locking,|
|

977
00:30:27,280 --> 00:30:30,730
0,570 1620,2040 2040,2460 2460,3000 3000,3450
{} so actually, both {}
所以，实际上，两个例程，

978
00:30:31,280 --> 00:30:33,110
0,510 510,600 600,1140 1170,1740 1740,1830
both of these routines| for
|写入例程和中断例程的都必须使用锁。

979
00:30:33,110 --> 00:30:34,370
0,240 240,390 390,660 660,1050 1050,1260
both the write routine and

980
00:30:34,370 --> 00:30:36,020
0,120 120,450 450,810 840,1470 1470,1650
the interrupt routine absolutely have

981
00:30:36,020 --> 00:30:37,920
0,120 120,870
to lock.|
|

982
00:30:37,920 --> 00:30:40,140
0,300 330,780 780,1230 1230,1470 1470,2220
And one reason is that,|
其中一个原因是，|

983
00:30:40,320 --> 00:30:41,700
0,390 390,690 690,990 990,1290 1290,1380
this done flag, anytime we
这个完成标志，任何时候我们共享数据时，

984
00:30:41,700 --> 00:30:43,140
0,120 120,480 480,900 930,1260 1260,1440
have shared data,| we really
|我们都需要对共享数据加锁，

985
00:30:43,140 --> 00:30:43,770
0,150 150,210 210,360 360,390 390,630
need to put a lock

986
00:30:43,770 --> 00:30:45,780
0,210 210,300 300,570 570,960 1740,2010
around the shared data,| and
|另一个原因是，

987
00:30:45,780 --> 00:30:46,830
0,60 60,270 270,600 600,750 750,1050
the other reason is that,|
|

988
00:30:47,010 --> 00:30:48,270
0,780 780,810 810,990 990,1170 1170,1260
actually I didn't put it
实际上我没有把它放在这里，

989
00:30:48,270 --> 00:30:49,170
0,120 120,420 420,600 600,810 810,900
in here,| but both the
|但是中断例程和写入例程

990
00:30:49,170 --> 00:30:51,480
0,360 360,780 780,1380 1380,1890 1980,2310
interrupt routine and the write

991
00:30:51,480 --> 00:30:53,040
0,480 510,810 810,930 930,1470 1470,1560
routine| need to access the
|都需要访问 uart 硬件本身，

992
00:30:53,040 --> 00:30:54,540
0,570 570,780 780,930 930,1080 1080,1500
hardware that {uart -} hardware

993
00:30:54,540 --> 00:30:56,400
0,660 720,1080 1110,1620 1620,1770 1770,1860
itself| and typically it's an
|通常这是一个错误，

994
00:30:56,400 --> 00:30:58,050
0,480 510,870 870,1140 1230,1500 1500,1650
error,| unless you're very very
|除非你非常非常聪明，

995
00:30:58,050 --> 00:31:00,330
0,540 1320,1740 1740,1860 1860,2190 2190,2280
clever,| it's an error to
|让两个线程

996
00:31:00,330 --> 00:31:03,210
0,210 210,420 420,1140 1350,2460 2520,2880
have two threads| concurrently try
|同时读写内存映射硬件寄存器是错误的，

997
00:31:03,210 --> 00:31:04,350
0,150 150,390 390,540 540,930 930,1140
to read and write the

998
00:31:04,350 --> 00:31:06,870
0,360 360,630 630,1020 1020,1740 2340,2520
memory mapped hardware registers,| so
|所以，我们需要在这两个子例程中都设置一个锁，

999
00:31:06,870 --> 00:31:08,040
0,90 90,240 240,300 300,570 570,1170
we need a lock around

1000
00:31:08,070 --> 00:31:09,600
0,480 690,1080 1080,1290 1290,1380 1380,1530
{} in both of these

1001
00:31:09,600 --> 00:31:10,710
0,150 150,480 480,570 570,810 810,1110
{subroutines -}| in order to
|为了避免对完成标志竞争访问和对硬件的竞争访问。

1002
00:31:10,710 --> 00:31:11,340
0,360
{}

1003
00:31:12,530 --> 00:31:14,480
0,270 270,1530
{} avoid

1004
00:31:14,630 --> 00:31:18,110
0,600 750,1800 1830,2820 2820,3210 3210,3480
{} both racing access on

1005
00:31:18,110 --> 00:31:19,640
0,270 270,510 510,900 900,1440 1440,1530
done and racing accesses to

1006
00:31:19,640 --> 00:31:21,920
0,90 90,420 450,1050 1500,1890 2100,2280
the {hardware -}.| {} So
|所以问题是我们应该把锁放在哪里。

1007
00:31:21,920 --> 00:31:22,700
0,60 60,390 390,450 450,660 660,780
the question is where should

1008
00:31:22,700 --> 00:31:23,720
0,120 120,270 270,360 360,750 750,1020
we put the locks in.|
|

1009
00:31:25,050 --> 00:31:27,120
0,420 510,1110 1350,1530 1560,1950 1950,2070
{} It's it's easy in
在中断例程中很容易做到，

1010
00:31:27,120 --> 00:31:28,500
0,180 180,570 570,1140 1140,1230 1230,1380
the interrupt routine,| we're gonna
|我们在开始就加锁，

1011
00:31:28,500 --> 00:31:29,760
0,420 420,540 540,1080 1110,1170 1170,1260
lock our lock at the

1012
00:31:29,760 --> 00:31:31,080
0,750
beginning,|
|

1013
00:31:31,290 --> 00:31:32,430
0,360 360,540 570,960 960,1020 1020,1140
whatever the lock I think
不管是什么锁，我想它叫 uart_tx_lock 或别的什么，

1014
00:31:32,430 --> 00:31:33,540
0,90 90,330 330,510 510,660 660,1110
its called {uart_tx_lock - -

1015
00:31:33,540 --> 00:31:34,800
0,240 240,300 300,780 780,1200 1200,1260
-} or something| and we're
|然后我们在最后解锁。

1016
00:31:34,800 --> 00:31:35,730
0,150 150,540 540,600 600,750 750,930
gonna unlock at the end.|
|

1017
00:31:36,880 --> 00:31:38,500
0,210 210,450 450,810 810,1110 1110,1620
So the interrupt routine just
所以中断例程只是获取一个锁并释放它，

1018
00:31:38,590 --> 00:31:39,700
0,270 270,330 330,540 540,720 720,1110
takes a lock and releases

1019
00:31:39,700 --> 00:31:40,840
0,150 390,600 600,900 900,990 990,1140
it,| the puzzle is where
|难题是如何在 uart 例程中放置锁。

1020
00:31:40,840 --> 00:31:42,160
0,90 90,240 240,360 360,870 870,1320
to put the locks in

1021
00:31:42,760 --> 00:31:44,660
0,120 120,330 330,480 480,1020
the {uart -} routine.|
|

1022
00:31:45,330 --> 00:31:47,240
0,330 330,1080
One possibility
一种可能是，

1023
00:31:47,680 --> 00:31:48,700
0,180 180,360 360,540 540,720 720,1020
is| that {uartwrite - -}
|uartwrite 可以持有的锁

1024
00:31:48,700 --> 00:31:49,900
0,150 150,600 600,720 720,1110 1110,1200
could hold the lock| for
|对于发送每个字符的整个序列。

1025
00:31:49,900 --> 00:31:52,030
0,120 120,600 600,1320 1320,1740 1770,2130
the entire sequence of trying

1026
00:31:52,030 --> 00:31:53,320
0,60 60,330 330,390 390,1020 1050,1290
to send a character each

1027
00:31:53,320 --> 00:31:54,420
0,600
character.|
|

1028
00:31:54,450 --> 00:31:55,680
0,330 330,510 510,630 630,810 840,1230
{} So we could acquire
所以，我们可以在这里获取锁，在这里释放锁。

1029
00:31:55,680 --> 00:31:57,180
0,90 90,390 390,930
the lock here,

1030
00:32:01,700 --> 00:32:03,760
0,420 420,990 990,1650
and unlock here.|
|

1031
00:32:06,200 --> 00:32:07,640
0,210 210,480 480,600 600,1200 1380,1440
So lock and unlock it
所以，加锁和解锁在处理每个字符的开头和结尾，

1032
00:32:07,640 --> 00:32:08,720
0,180 180,270 270,720 720,810 810,1080
at the beginning and very

1033
00:32:08,720 --> 00:32:11,360
0,390 390,900 900,1050 1050,1650 2430,2640
end processing each character,| so
|那么为什么这肯定行不通呢。

1034
00:32:11,360 --> 00:32:12,920
0,240 240,540 540,690 690,1020 1170,1560
why, why does this definitely

1035
00:32:12,920 --> 00:32:14,140
0,210 210,660
not work.|
|

1036
00:32:22,680 --> 00:32:24,450
0,660 660,960 960,1110 1110,1500 1500,1770
One reason is that| the
其中一个原因是|我们走出这个循环的唯一方法是，

1037
00:32:24,450 --> 00:32:25,200
0,180 180,360 360,450 450,570 570,750
only way we can get

1038
00:32:25,200 --> 00:32:26,860
0,120 120,180 180,420 420,1110
out of this loop

1039
00:32:26,890 --> 00:32:28,450
0,210 210,330 330,450 450,900 900,1560
is that| the interrupt routine
|中断例程将完成标志设置为 1 ，

1040
00:32:28,480 --> 00:32:30,490
0,450 450,720 720,810 810,1410 1620,2010
sets done to one,| but
|但是如果我们在整个序列中持有这个锁，

1041
00:32:30,490 --> 00:32:31,870
0,60 60,150 150,390 390,600 600,1380
if we hold this lock

1042
00:32:32,140 --> 00:32:34,240
0,180 180,360 360,690 690,1530 1890,2100
for this entire sequence in

1043
00:32:34,240 --> 00:32:35,770
0,360 510,660 660,1020 1020,1230 1230,1530
it,| the interrupt routine also
|中断例程也需要锁，

1044
00:32:35,770 --> 00:32:37,240
0,210 210,300 300,810 900,1320 1320,1470
needs to lock| {} and
|所以它会在这里旋转等待锁，

1045
00:32:37,240 --> 00:32:38,020
0,150 150,300 300,450 450,660 660,780
so it will sit here

1046
00:32:38,020 --> 00:32:39,400
0,360 360,630 630,720 720,840 840,1380
spinning waiting for the lock,|
|

1047
00:32:39,490 --> 00:32:41,620
0,690 960,1470 1620,1800 1800,2040 2040,2130
because {} we hold the
因为我们持有锁，

1048
00:32:41,620 --> 00:32:42,850
0,510 630,870 870,1050 1050,1170 1170,1230
lock| and aren't going to
|并且在设置完成之前不会释放它，

1049
00:32:42,850 --> 00:32:44,230
0,360 360,630 660,1020 1020,1260 1260,1380
release it until done is

1050
00:32:44,230 --> 00:32:45,490
0,570 600,780 780,990 990,1110 1110,1260
set,| but done can only
|但是完成标志只能在中断例程获得锁时才能设置，

1051
00:32:45,490 --> 00:32:46,450
0,120 120,360 360,510 510,600 600,960
be set when the interrupt

1052
00:32:46,450 --> 00:32:48,100
0,570 660,990 990,1140 1140,1470 1470,1650
routine {} is actually able

1053
00:32:48,100 --> 00:32:49,330
0,90 90,210 210,300 300,720 900,1230
to get the lock,| so
|所以我们不能简单地持有锁

1054
00:32:49,360 --> 00:32:50,950
0,210 210,690 690,930 930,1290 1290,1590
we cannot just simply hold

1055
00:32:50,950 --> 00:32:52,680
0,120 120,570 750,1350
the lock {}|
|

1056
00:32:53,590 --> 00:32:55,690
0,510 510,810 810,1500 1530,2040 2040,2100
across the entire sequence of
在发送每个字符的整个序列中。

1057
00:32:55,690 --> 00:32:57,520
0,420 420,690 690,1320
sending each character.|
|

1058
00:32:57,580 --> 00:32:58,860
0,690

1059
00:33:00,070 --> 00:33:02,380
0,510 510,840 1080,1440 1440,2160 2160,2310
Alright, so another possibility,| the
好的，那么另一种可能是，|这里的令人讨厌的问题是

1060
00:33:02,500 --> 00:33:04,330
0,390 390,570 600,1170 1170,1560 1560,1830
sort of nasty problem here

1061
00:33:04,330 --> 00:33:06,130
0,120 120,300 360,1500 1500,1680 1680,1800
is| that {uartwrite -} was
|uartwrite 持有锁，

1062
00:33:06,130 --> 00:33:07,390
0,390 390,480 480,1050 1050,1170 1170,1260
holding a lock| at the
|在它希望中断进程发生的时候，

1063
00:33:07,390 --> 00:33:09,250
0,420 420,540 540,690 690,1530 1560,1860
time when it expected the

1064
00:33:09,250 --> 00:33:11,260
0,420 420,810 810,900 900,1590 1620,2010
interrupt routine to execute| which
|就在这里，

1065
00:33:11,260 --> 00:33:12,370
0,210 210,570 570,840 840,930 930,1110
is right here,| the only
|我们需要中断例程执行的唯一时间是，

1066
00:33:12,370 --> 00:33:13,810
0,360 360,690 900,1110 1110,1290 1290,1440
time when we really need

1067
00:33:13,810 --> 00:33:15,010
0,120 120,450 450,720 720,810 810,1200
the interrupt routine to execute

1068
00:33:15,010 --> 00:33:15,800
0,360
is,|
|

1069
00:33:15,800 --> 00:33:16,880
0,210 210,330 330,480 480,750 750,1080
is at this point here|
就在这一点上，|

1070
00:33:17,060 --> 00:33:18,110
0,420 420,570 570,780 780,840 840,1050
otherwise it's okay to hold
其他时间持有锁也没有问题，

1071
00:33:18,110 --> 00:33:19,940
0,60 60,450 690,900 900,1110 1110,1830
the lock,| so another possibility
|所以另一种可能是在开始时获得锁，

1072
00:33:19,940 --> 00:33:21,290
0,120 120,240 240,480 540,1260 1260,1350
would be to acquire the

1073
00:33:21,290 --> 00:33:22,520
0,240 240,300 300,360 360,930 930,1230
lock at the beginning,| because
|因为我们需要保护对这个共享变量 done 的访问，

1074
00:33:22,520 --> 00:33:23,990
0,120 120,540 600,750 750,1200 1200,1470
we need to protect our

1075
00:33:24,020 --> 00:33:25,200
0,600
{access,to}

1076
00:33:25,490 --> 00:33:27,410
0,180 180,540 540,900 900,1350 1470,1920
this shared variable done,| but
|但在调用 sleep 前释放它，

1077
00:33:27,680 --> 00:33:29,080
0,510 510,810
release it

1078
00:33:29,480 --> 00:33:30,800
0,810
{}

1079
00:33:32,640 --> 00:33:33,900
0,300 300,390 390,600 600,660 660,1260
before the call to sleep,|
|

1080
00:33:34,140 --> 00:33:35,580
0,360 360,600 600,1050 1050,1170 1170,1440
{} that gives the interrupt
这给了中断例程机会执行并将完成标志设置为 1 ，

1081
00:33:35,580 --> 00:33:37,050
0,270 270,360 360,660 660,930 960,1470
routine a chance to execute

1082
00:33:37,050 --> 00:33:38,130
0,180 180,450 450,630 630,690 690,1080
and set done to one|
|

1083
00:33:38,130 --> 00:33:39,480
0,360 360,450 450,540 540,690 690,1350
and then we'll just re-acquire
然后我们会在 sleep 返回后重新获取它。

1084
00:33:39,480 --> 00:33:42,640
0,150 1170,1590 1590,1890 1890,2700
it after sleep returns.|
|

1085
00:33:43,470 --> 00:33:44,370
0,300 300,510 510,600 600,690 690,900
So then we go back
然后我们回到开始，再检查一遍，

1086
00:33:44,370 --> 00:33:45,030
0,90 90,180 180,270 270,540 540,660
up to the top and

1087
00:33:45,030 --> 00:33:45,900
0,210 210,420 420,690 690,750 750,870
check done again,| we have
|我们又拿到了锁。

1088
00:33:45,900 --> 00:33:47,640
0,120 120,360 360,660
the lock again.|
|

1089
00:33:48,080 --> 00:33:49,980
0,720

1090
00:33:50,100 --> 00:33:51,630
0,360 360,690 750,1200 1200,1290 1290,1530
Alright, so let me actually
好的，让我修改驱动程序来做这件事。

1091
00:33:51,630 --> 00:33:52,860
0,420 420,570 570,930 930,1080 1080,1230
modify my driver to do

1092
00:33:52,860 --> 00:33:54,040
0,630
this.|
|

1093
00:33:58,940 --> 00:34:00,940
0,360 360,720 720,1410
We'll see, yeah.|
我们会看到，好的。|

1094
00:34:01,740 --> 00:34:03,570
0,270 270,360 360,420 420,1110 1110,1830
See what the consequences are.|
看看后果是什么。|

1095
00:34:06,050 --> 00:34:08,020
0,660 690,1290
Alright. {}|
好的。|

1096
00:34:08,020 --> 00:34:09,220
0,300 300,450 450,780 780,870 870,1200
So the sleep we're talking
所以我们所说的 sleep ，我们想要，

1097
00:34:09,220 --> 00:34:10,600
0,300 300,810 810,930 930,1140 1140,1380
about where we want to,|
|

1098
00:34:10,900 --> 00:34:11,800
0,120 120,210 210,420 420,600 600,900
you can see this code
你可以看到，这个代码所做的，

1099
00:34:11,800 --> 00:34:13,840
0,270 270,690 1410,1740 1740,1830 1830,2040
actually does,| acquire the lock
|在开始时获取锁，并在结束时释放它，

1100
00:34:13,840 --> 00:34:15,010
0,60 60,360 360,720 720,1080 1080,1170
at the very beginning and

1101
00:34:15,010 --> 00:34:16,120
0,270 270,360 360,450 450,570 570,1110
release it at the end|
|

1102
00:34:16,300 --> 00:34:17,680
0,300 300,480 480,840 840,1080 1080,1380
and the interrupt routine also
并且中断例程也获取和释放。

1103
00:34:17,680 --> 00:34:19,690
0,810 810,990 990,1530 1650,1950 1950,2010
acquires and releases.| And the
|建议是我们要做两件事，

1104
00:34:19,690 --> 00:34:22,060
0,540 540,1020 1170,1800 1950,2280 2280,2370
proposal is that we do

1105
00:34:22,060 --> 00:34:23,600
0,210 210,480 480,720 720,1140
two things,| one is,
|一个是，我们要探索为什么我的 broken_sleep 方法，

1106
00:34:24,130 --> 00:34:26,920
0,750 1020,1320 1320,1770 1800,2220 2220,2790
{} we're gonna, we're exploring

1107
00:34:26,920 --> 00:34:28,510
0,90 90,480 480,720 720,1170 1170,1590
is why my {broken_sleep -}

1108
00:34:28,510 --> 00:34:30,360
0,660 780,1350
idea,| that
|它只使用一个参数，

1109
00:34:30,360 --> 00:34:31,540
0,600
{}

1110
00:34:31,570 --> 00:34:33,100
0,330 330,600 600,660 660,990 990,1530
only takes a single argument,|
|

1111
00:34:33,130 --> 00:34:34,540
0,300 300,480 480,720 720,1050 1050,1410
why that doesn't work.| So
为什么不能工作。|所以为了正确地进行使用锁，

1112
00:34:35,050 --> 00:34:36,070
0,90 90,570 570,720 720,900 900,1020
the idea is that in

1113
00:34:36,070 --> 00:34:36,820
0,150 150,210 210,330 330,390 390,750
order to make the locking

1114
00:34:36,820 --> 00:34:37,840
0,420 420,600 600,690 690,810 810,1020
workout right,| we're gonna call
|我们调用 broken_sleep ，

1115
00:34:37,840 --> 00:34:39,010
0,300 300,630 630,930 930,1080 1080,1170
{broken_sleep -} alright,| but we're
|但是我们在这里释放锁，

1116
00:34:39,010 --> 00:34:41,780
0,150 150,1020 1350,2340
gonna release {}

1117
00:34:42,520 --> 00:34:44,160
0,420 420,1080
{the,lock} here,|
|

1118
00:34:44,570 --> 00:34:46,970
0,300 300,930 930,1230 1410,1800 1800,2400
and re-acquire it after sleep
并在 sleep 返回后重新获得它。

1119
00:34:47,280 --> 00:34:48,660
0,840
returns.|
|

1120
00:34:53,730 --> 00:34:55,050
0,360 360,720 720,870 870,1050 1050,1320
And literally all this {broken_sleep
这个 broken_sleep 所做的就是，

1121
00:34:55,050 --> 00:34:57,180
0,330 330,990 1140,1590 1590,1740 1740,2130
-} does {} is| exactly
|我写在白板上的东西，

1122
00:34:57,180 --> 00:34:57,930
0,150 150,240 240,540 540,660 660,750
what I wrote on my

1123
00:34:57,930 --> 00:34:59,580
0,210 210,780 780,1080 1080,1200 1200,1650
little whiteboard,| namely, it sets
|也就是，它将状态设置为睡眠，

1124
00:34:59,580 --> 00:35:02,040
0,390 1170,1740 1740,1860 1860,2370 2370,2460
the state to sleeping| and
|并将信道设置为 tx_chan 参数，

1125
00:35:02,040 --> 00:35:04,290
0,300 300,450 450,1020 1020,1680 2070,2250
sets the channel to {}

1126
00:35:04,290 --> 00:35:06,600
0,210 210,810 810,1260 1260,1920 2040,2310
this {tx_chan -} argument,| then
|然后调用 swtch 。

1127
00:35:06,600 --> 00:35:08,140
0,420 420,1140
call swtch.|
|

1128
00:35:08,170 --> 00:35:09,280
0,510

1129
00:35:09,810 --> 00:35:11,020
0,660
Alright,
好的，让我们看看会发生什么。

1130
00:35:11,020 --> 00:35:13,040
0,300 300,480 480,600 600,1320
let's see what happens.|
|

1131
00:35:21,020 --> 00:35:22,220
0,450 450,630 630,780 780,840 840,1200
Oh, wow look at that,
哦，看看这个，真的成功了，

1132
00:35:22,730 --> 00:35:24,650
0,570 600,960 960,1440 1440,1560 1560,1920
{} actually managed,| so {init
|所以 init 正在打印，它是 init 启动消息，

1133
00:35:24,650 --> 00:35:26,150
0,300 300,570 570,990 990,1350 1350,1500
-} is printing out, it's

1134
00:35:26,150 --> 00:35:27,530
0,150 150,390 390,930 930,960 960,1380
{init -} starting {} message,|
|

1135
00:35:27,530 --> 00:35:28,520
0,90 90,180 180,450 450,900 900,990
and it actually managed to
它成功地写下了几个字符，

1136
00:35:28,520 --> 00:35:30,140
0,270 270,330 330,510 510,1470 1470,1620
write a few characters| and
|但是似乎卡住了。

1137
00:35:30,140 --> 00:35:31,400
0,180 180,390 390,450 450,540 540,1260
that seems to have hung.|
|

1138
00:35:31,930 --> 00:35:33,160
0,660

1139
00:35:33,160 --> 00:35:34,060
0,150 150,270 270,690 690,810 810,900
And it turns out that
如果我输入一个字符，

1140
00:35:34,060 --> 00:35:35,140
0,120 120,210 210,600 600,660 660,1080
if I type a character,|
|

1141
00:35:35,140 --> 00:35:35,980
0,270 270,450 450,510 510,780 780,840
I'm going to type a
我输入一个句号，

1142
00:35:35,980 --> 00:35:37,400
0,870
period,|
|

1143
00:35:38,110 --> 00:35:41,650
0,510 570,870 870,1350 1410,2100 2670,3540
by typing peri- period, {}
通过输入句号，输出重新启动了，

1144
00:35:42,280 --> 00:35:44,680
0,660 690,1800
output restarts,|
|

1145
00:35:44,680 --> 00:35:46,750
0,510 780,1260 1260,1560 1560,1770 1770,2070
{} maybe make more output
也许我运行 ls 会产生更多的输出，

1146
00:35:46,750 --> 00:35:48,840
0,240 240,660 660,1470
{I,run} ls,| oops,
|糟糕， ls 也输出几个字符，然后就停了，

1147
00:35:48,840 --> 00:35:50,980
0,600 600,1500
ls also

1148
00:35:51,390 --> 00:35:52,470
0,330 330,390 390,540 540,990 990,1080
emitted a few characters and

1149
00:35:52,470 --> 00:35:53,610
0,120 120,810 810,930 930,1050 1050,1140
then stopped,| but if I
|但是如果我输入一些东西，我输入 x ，

1150
00:35:53,610 --> 00:35:55,560
0,300 300,810 810,990 990,1350 1530,1950
type something, I type type

1151
00:35:55,560 --> 00:35:56,780
0,690
x,|
|

1152
00:35:57,120 --> 00:35:59,080
0,240 240,360 360,570 570,1440
will do {restart -}
将重新启动 ls ，它将继续运行。

1153
00:35:59,200 --> 00:36:01,220
0,600 600,780 780,1050 1050,1470
ls, it'll keep going.|
|

1154
00:36:02,060 --> 00:36:03,180
0,570
So.|
所以。|

1155
00:36:03,550 --> 00:36:04,820
0,600

1156
00:36:05,170 --> 00:36:05,680
0,150 150,210 210,270 270,390 390,510
What do you think is
你觉得这是怎么回事？

1157
00:36:05,680 --> 00:36:07,020
0,240 240,420 420,780
going on here?|
|

1158
00:36:08,170 --> 00:36:09,040
0,210 210,330 330,480 480,540 540,870
So you want to propose
所以你想提出一个理论。

1159
00:36:09,040 --> 00:36:10,360
0,90 90,750
a theory.|
|

1160
00:36:19,660 --> 00:36:20,840
0,540

1161
00:36:20,960 --> 00:36:22,040
0,270 270,540 540,840 840,990 990,1080
The problem definitely has to
这个问题肯定与我刚刚更改的代码有关，

1162
00:36:22,040 --> 00:36:22,880
0,210 210,300 300,390 390,720 720,840
do with the code that

1163
00:36:22,880 --> 00:36:24,740
0,90 90,360 360,1080 1290,1650 1680,1860
I just changed,| so what's
|那么发生了什么。

1164
00:36:24,740 --> 00:36:25,840
0,510
happening.|
|

1165
00:36:33,790 --> 00:36:35,650
0,480 480,810 900,1410 1410,1620 1620,1860
Alright, so what's going on
好的，这里的问题是，

1166
00:36:35,650 --> 00:36:37,900
0,420 450,690 690,1230 1380,1920 1950,2250
here is| that my new
|我的新代码释放了锁，

1167
00:36:37,900 --> 00:36:40,320
0,600 630,1890
code releases

1168
00:36:40,510 --> 00:36:41,940
0,180 180,840
the lock,|
|

1169
00:36:41,940 --> 00:36:43,110
0,450 450,630 630,900 900,960 960,1170
releases this lock at this
在这里释放了锁，

1170
00:36:43,110 --> 00:36:45,060
0,420 480,750 750,960 960,1260 1260,1950
point,| and then right here,
|然后在这里，中断发生了，

1171
00:36:46,600 --> 00:36:47,960
0,750
{}

1172
00:36:47,960 --> 00:36:49,400
0,180 180,570 570,1050 1050,1320 1320,1440
the interrupt happens,| because as
|因为一旦你释放锁，

1173
00:36:49,400 --> 00:36:50,150
0,210 210,300 300,390 390,660 660,750
soon as you release the

1174
00:36:50,150 --> 00:36:52,040
0,540 810,1140 1140,1230 1230,1590 1680,1890
lock,| first of all, the
|首先，会重新启用中断，

1175
00:36:52,040 --> 00:36:53,120
0,390 390,480 480,600 600,990 990,1080
interrupts are {re-enabled -},| so
|所以，在这个 CPU 上，中断可能发生，

1176
00:36:53,120 --> 00:36:54,380
0,120 120,270 270,780 780,1140 1140,1260
in this CPU interrupts could

1177
00:36:54,380 --> 00:36:55,250
0,360 360,510 510,570 570,600 600,870
happen,| this is a {multi-core
|这是一台多核心机器，

1178
00:36:55,250 --> 00:36:56,510
0,180 180,540 540,660 660,900 900,1260
-} machine,| so actually interrupts
|所以中断可以在任何核心上进行，

1179
00:36:56,510 --> 00:36:58,340
0,90 90,180 180,660 720,1110 1440,1830
can be taken on {}

1180
00:36:58,900 --> 00:37:01,990
0,300 300,960 1260,1950 2010,2400 2430,3090
any core,| {} so almost
|所以几乎可以肯定，在这我标记的这一点上发生的是，

1181
00:37:01,990 --> 00:37:04,030
0,690 1140,1410 1410,1710 1710,1890 1890,2040
certainly what's going on at

1182
00:37:04,030 --> 00:37:05,140
0,210 210,600 600,720 720,840 840,1110
this point that I've marked

1183
00:37:05,140 --> 00:37:05,950
0,60 60,150 150,510 510,600 600,810
in the code is| that
|在其他核心上， UART 中断正在执行，

1184
00:37:05,980 --> 00:37:08,920
0,330 330,570 570,840 840,1500 2730,2940
on some other core, the

1185
00:37:08,920 --> 00:37:11,740
0,390 390,1020 1110,1350 1350,2280 2670,2820
uart interrupt is executing| and
|它在 acquire 上，

1186
00:37:11,740 --> 00:37:13,480
0,150 150,660 660,780 780,870 870,1740
it's sitting in {acquire -},|
|

1187
00:37:14,090 --> 00:37:15,950
0,450 450,540 540,780 780,1380 1620,1860
waiting for this lock on
等待其他核心上的锁。

1188
00:37:15,950 --> 00:37:17,480
0,240 240,420 420,1080
some other core.|
|

1189
00:37:17,510 --> 00:37:18,860
0,780

1190
00:37:19,350 --> 00:37:20,010
0,120 120,270 270,360 360,570 570,660
And so as soon as
所以当我释放了锁，

1191
00:37:20,010 --> 00:37:20,940
0,120 120,480 480,570 570,750 750,930
I release it,| that other
|另一个核心将获得锁，

1192
00:37:20,940 --> 00:37:22,860
0,570 1050,1200 1200,1350 1350,1410 1410,1920
core is going to acquire

1193
00:37:22,860 --> 00:37:24,330
0,120 120,720 1110,1260 1260,1380 1380,1470
the lock,| is going to
|会看到 uart 已经完成了字符的发送，

1194
00:37:24,330 --> 00:37:26,160
0,540 540,780 780,1080 1080,1560 1560,1830
see that the uart has

1195
00:37:26,160 --> 00:37:28,650
0,480 480,750 750,840 840,1530 1860,2490
completed sending the character, {}|
|

1196
00:37:29,340 --> 00:37:31,110
0,360 360,510 510,570 570,1140 1380,1770
it's going to set this
它将把这个传输完成标志设置为 1 ，

1197
00:37:31,170 --> 00:37:33,120
0,570 570,840 840,1230 1230,1320 1320,1950
transmit done flag to one,|
|

1198
00:37:33,900 --> 00:37:35,280
0,240 240,750 960,1110 1110,1230 1230,1380
just great,| and then it's
太棒了，|然后它使用 tx_chan 调用 wakeup 。

1199
00:37:35,280 --> 00:37:37,590
0,180 180,480 480,1170 1620,1860 1860,2310
gonna call wakeup on {tx_chan

1200
00:37:37,590 --> 00:37:38,760
0,510
-}.|
|

1201
00:37:39,130 --> 00:37:41,110
0,150 150,240 240,480 480,1080 1110,1980
Which is also fine, except,|
这也很好，除了，|

1202
00:37:42,090 --> 00:37:43,350
0,360 360,510 510,900 900,1170 1170,1260
because the writing thread is
因为写入线程仍在释放和 broken_sleep 之间执行，

1203
00:37:43,350 --> 00:37:45,810
0,210 210,1020 1470,1980 1980,2070 2070,2460
still executing between the release

1204
00:37:45,810 --> 00:37:47,370
0,90 90,180 180,480 480,960 1320,1560
and the {broken_sleep -},| the
|写线程还没有进入睡眠，

1205
00:37:47,370 --> 00:37:48,660
0,270 270,660 690,1020 1020,1200 1200,1290
writing thread hasn't gone to

1206
00:37:48,660 --> 00:37:51,330
0,300 300,780 1110,1770 1860,2040 2040,2670
sleep yet,| so the wakeup
|所以，中断例程调用的 wakeup

1207
00:37:51,330 --> 00:37:53,340
0,180 180,480 570,1020 1020,1470 1470,2010
that the interrupt routine calls|
|

1208
00:37:53,370 --> 00:37:55,140
0,390 390,660 660,900 900,1050 1050,1770
doesn't actually {wakeup -} anything
并没有唤醒任何东西，

1209
00:37:55,140 --> 00:37:56,400
0,360 390,630 630,900 900,1080 1080,1260
up,| because nothing's yet gone
|因为没有什么东西睡眠在那个信道上。

1210
00:37:56,400 --> 00:37:57,540
0,60 60,360 360,450 450,630 630,1140
to sleep on that channel.|
|

1211
00:37:58,680 --> 00:38:01,590
0,300 330,1170 1590,2280 2310,2520 2520,2910
And then, {} the writing
然后，写入线程将继续调用这个 broken_sleep

1212
00:38:01,590 --> 00:38:04,170
0,420 420,780 810,1710 1800,2160 2340,2580
thread will proceed to call

1213
00:38:04,170 --> 00:38:05,580
0,180 180,510 510,870 870,1020 1020,1410
this {broken_sleep -}| which will,
|这将将状态设置为睡眠，并设置睡眠信道，

1214
00:38:06,360 --> 00:38:07,920
0,210 210,450 480,870 870,1170 1200,1560
you know, set the state

1215
00:38:07,920 --> 00:38:09,210
0,60 60,570 570,900 900,1140 1140,1290
to sleeping and set the

1216
00:38:09,210 --> 00:38:10,800
0,270 270,750 810,1110 1110,1200 1200,1590
sleep channel,| but the interrupt
|但是中断已经发生，并且 wakeup 已经被调用，

1217
00:38:10,800 --> 00:38:11,700
0,150 150,390 390,720 720,840 840,900
has already happened and the

1218
00:38:11,700 --> 00:38:12,510
0,240 240,330 330,450 450,690 690,810
{wakeup -} has already been

1219
00:38:12,510 --> 00:38:15,150
0,540 570,810 810,1110 1110,1920 2040,2640
called,| so this sleep, {}
|所以这个睡眠，什么都不会唤醒，

1220
00:38:15,270 --> 00:38:17,070
0,780 780,900 900,1080 1080,1290 1290,1800
nothing will ever {wakeup -},|
|

1221
00:38:17,430 --> 00:38:18,540
0,210 210,300 300,570 570,780 780,1110
because the wakeup already happened.|
因为唤醒已经发生了。|

1222
00:38:20,270 --> 00:38:21,920
0,420 420,510 510,780 780,1080 1110,1650
This is called the lost
这就是所谓的丢失唤醒问题。

1223
00:38:21,920 --> 00:38:23,180
0,180 180,330 330,600
{wakeup -} problem.|
|

1224
00:38:23,180 --> 00:38:24,260
0,510

1225
00:38:24,860 --> 00:38:26,420
0,1020
Any
关于为什么或如何发生这种情况，有什么问题吗？

1226
00:38:26,510 --> 00:38:28,070
0,570 570,780 780,1230 1230,1320 1320,1560
questions about why or how

1227
00:38:28,070 --> 00:38:29,660
0,210 210,1050
this arises?|
|

1228
00:38:39,330 --> 00:38:41,340
0,390 690,1020 1020,1170 1170,1350 1350,2010
Yeah, {} is it always
是的，是不是一直都是这样，

1229
00:38:41,340 --> 00:38:42,660
0,360 360,450 450,570 570,660 660,1320
going to be the case,|
|

1230
00:38:42,690 --> 00:38:45,240
0,720 750,1170 1170,1620 1620,2190 2220,2550
that once something gets {}
一旦东西丢失了，

1231
00:38:45,240 --> 00:38:47,370
0,390 390,630 630,1080 1260,1740 1740,2130
lost,| once {} a wakeup
|一旦 wakeup 丢失了，

1232
00:38:47,370 --> 00:38:48,960
0,330 330,930 930,1230 1260,1500 1500,1590
gets lost,| that on the
|在下一次，所有被缓冲的东西都会被丢弃。

1233
00:38:48,960 --> 00:38:50,640
0,420 420,720 720,1260 1260,1500 1500,1680
next time, everything that's been

1234
00:38:50,640 --> 00:38:51,630
0,330 330,480 480,690 690,870 870,990
buffered is just going to

1235
00:38:51,630 --> 00:38:54,090
0,150 150,600 1200,1620 1620,1770 1770,2460
get dumped.| Well, it completely
|好的，这完全取决于发生了事情的细节。

1236
00:38:54,090 --> 00:38:55,890
0,450 450,510 510,600 600,1320 1320,1800
depends on the details of

1237
00:38:56,280 --> 00:38:57,900
0,360 360,600 600,1080 1140,1380 1380,1620
what's going on.| In this
|在这种情况下，它只是，

1238
00:38:57,900 --> 00:38:59,850
0,450 690,900 900,1230 1230,1620 1620,1950
case it's actually just us,|
|

1239
00:39:00,620 --> 00:39:03,020
0,630 630,990 990,1140 1140,2100 2100,2400
it's sort of accidental that,|
这是一种意外，|

1240
00:39:03,680 --> 00:39:07,040
0,390 390,870 870,1500 2100,3180 3180,3360
me typing something caused the
我输入某些内容会导致输出恢复，

1241
00:39:07,040 --> 00:39:08,840
0,390 390,510 510,1110 1230,1440 1440,1800
output to resume,| me typing
|我输入会导致输出得到修复，

1242
00:39:08,900 --> 00:39:11,990
0,690 840,1230 1230,1410 1470,2250 2430,3090
input caused the output {}

1243
00:39:12,020 --> 00:39:13,760
0,360 360,960 1020,1290 1320,1530 1530,1740
get fixed| and the reason
|原因是 uart 只有一种中断，

1244
00:39:13,760 --> 00:39:14,450
0,120 120,300 300,420 420,600 600,690
for that is that the

1245
00:39:14,450 --> 00:39:16,070
0,330 330,630 630,930 930,1350 1350,1620
uart has only one kind

1246
00:39:16,070 --> 00:39:17,270
0,90 90,570 570,660 660,1020 1020,1200
of interrupt,| it makes it,
|它调用相同的中断例程，

1247
00:39:17,740 --> 00:39:18,970
0,150 150,420 420,510 510,900 900,1230
it calls the same interrupt

1248
00:39:18,970 --> 00:39:21,580
0,600 630,1290 1290,1560 1800,2460 2490,2610
routine| whether for input to
|无论是信号输入还是信号完成输出，

1249
00:39:21,580 --> 00:39:22,990
0,300 300,900 900,1020 1020,1110 1110,1410
signal input and the signal

1250
00:39:22,990 --> 00:39:24,970
0,510 510,1110 1590,1770 1770,1890 1890,1980
completed output,| so when I
|所以，当我输入内容时，

1251
00:39:24,970 --> 00:39:26,740
0,450 450,930 930,1080 1080,1200 1200,1770
type something which is input,|
|

1252
00:39:26,950 --> 00:39:29,170
0,420 480,930 960,1320 1320,1710 1710,2220
the this uart interrupt routine
会调用 uart 中断例程，

1253
00:39:29,170 --> 00:39:31,120
0,180 180,810 1020,1440 1500,1620 1620,1950
gets called| and the uart
|而 uart 将其作为输入已经到达的信号，

1254
00:39:31,120 --> 00:39:32,080
0,120 120,450 450,540 540,690 690,960
is thinking of is calling

1255
00:39:32,080 --> 00:39:33,040
0,150 150,390 390,450 450,840 840,960
it just a signal that

1256
00:39:33,040 --> 00:39:34,360
0,330 330,480 480,1140 1140,1260 1260,1320
input has arrived,| but in
|但实际上 xv6 中的中断例程，

1257
00:39:34,360 --> 00:39:35,950
0,270 270,390 390,750 750,1440 1440,1590
fact the interrupt routine in

1258
00:39:35,950 --> 00:39:38,800
0,930 1140,1350 1350,1800 1800,2340
xv6,| {you,know} looks for,
|注意到这段代码需要写入，

1259
00:39:38,800 --> 00:39:41,320
0,210 210,810 810,990 990,1320 1650,2520
{you,know} notices that the {}

1260
00:39:41,620 --> 00:39:42,430
0,210 210,270 270,330 330,510 510,810
you know the way this

1261
00:39:42,430 --> 00:39:43,870
0,210 210,780 780,870 870,1020 1020,1440
code happens to be written|
|

1262
00:39:44,140 --> 00:39:46,510
0,330 330,570 1470,1710 1710,2010 2010,2370
is that if the uart
如果 uart 准备好发送另一个字符，

1263
00:39:46,510 --> 00:39:47,620
0,90 90,300 300,360 360,840 840,1110
is ready to transmit another

1264
00:39:47,620 --> 00:39:49,120
0,390 390,480 480,930 930,1230 1230,1500
character,| it always calls {wakeup
|它总是调用 wakeup ，

1265
00:39:49,120 --> 00:39:50,900
0,390 780,1230
-}, {}|
|

1266
00:39:50,900 --> 00:39:52,580
0,270 270,420 420,780 1230,1410 1410,1680
even though it's a while
虽然刚才可能已经调用过 wakeup 了，

1267
00:39:52,580 --> 00:39:53,750
0,240 240,510 510,750 750,900 900,1170
ago maybe I had already

1268
00:39:53,750 --> 00:39:54,980
0,240 240,480 480,720 990,1140 1140,1230
called {wakeup -},| so it's
|所以这在某种程度上是偶然的，

1269
00:39:54,980 --> 00:39:56,000
0,150 150,210 210,780 780,900 900,1020
sort of accidental| that me
|我输入字符导致重启，

1270
00:39:56,000 --> 00:39:58,130
0,360 360,1200 1680,1980 1980,2070 2070,2130
typing characters caused us to

1271
00:39:58,130 --> 00:40:00,530
0,150 150,780 960,1140 1140,1290 1290,2400
get restarted| and so sometimes
|有时候，如果有丢失的唤醒，

1272
00:40:01,010 --> 00:40:02,240
0,330 330,480 480,690 690,1020 1020,1230
if there are lost {wakeups

1273
00:40:02,240 --> 00:40:04,760
0,540 570,1800 1830,2190 2190,2430 2430,2520
-},| sometimes they sort of
|幸运地话，有时它们会以这种方式修复自己，

1274
00:40:04,760 --> 00:40:06,020
0,240 240,780 780,870 870,1020 1020,1260
fix themselves in this way,

1275
00:40:06,020 --> 00:40:07,490
0,120 120,240 240,600 600,780 840,1470
if you're lucky| and sometimes
|而有时它们不会，

1276
00:40:07,490 --> 00:40:08,480
0,120 120,540 630,840 840,930 930,990
they don't,| like if the
|如果 uart 具有分开的接收和发送中断例程，

1277
00:40:08,480 --> 00:40:10,640
0,330 330,630 630,1140 1410,2040 2040,2160
uart had separate receive and

1278
00:40:10,640 --> 00:40:12,720
0,480 480,810 810,1290 1290,1680
transmit interrupt routines,| then
|那就没有办法摆脱这件事了。

1279
00:40:12,840 --> 00:40:13,800
0,180 180,300 300,510 510,720 720,960
there have been no getting

1280
00:40:13,800 --> 00:40:15,080
0,150 150,210 210,750
out of this.|
|

1281
00:40:16,040 --> 00:40:17,030
0,90 90,240 240,360 360,450 450,990
Does that answer your question?|
这回答了你的问题吗？|

1282
00:40:17,360 --> 00:40:19,380
0,360 360,600 600,1050
Yes, thank you.|
好的，谢谢。|

1283
00:40:22,940 --> 00:40:24,080
0,570
Okay.|
好的。|

1284
00:40:24,170 --> 00:40:26,030
0,810 990,1320 1320,1530 1530,1620 1620,1860
So.| Yes, please go ahead.|
所以。|好的，请继续。|

1285
00:40:26,210 --> 00:40:28,640
0,300 300,900 900,1200 1200,1650 1950,2430
What purpose does the {tx_done
tx_done 位的作用是什么？

1286
00:40:28,640 --> 00:40:30,680
0,480 480,810 810,1680
-} bit serve?|
|

1287
00:40:31,820 --> 00:40:32,960
0,180 180,270 270,660 660,900 900,1140
Oh, the {tx_done -} bit,|
哦， tx_done 位，|

1288
00:40:33,110 --> 00:40:34,640
0,540 540,840 840,960 960,1110 1110,1530
{} or you mean this
你是说这个标志 tx_done ，

1289
00:40:34,640 --> 00:40:37,310
0,750 750,1080 1080,1500 1950,2370 2370,2670
flag {tx_done -},| it is
|这是中断例程与 uartwrite 通信的一种方式。

1290
00:40:37,340 --> 00:40:38,540
0,660 660,750 750,930 930,1080 1080,1200
simply a way for the

1291
00:40:38,540 --> 00:40:42,170
0,570 570,1200 1290,1590 1590,2820 3300,3630
interrupt routine to communicate to

1292
00:40:42,170 --> 00:40:44,000
0,330 330,540 570,1260
{uartwrite - -}.|
|

1293
00:40:44,000 --> 00:40:47,150
0,720 1140,1560 1590,2370 2370,2820 2820,3150
That a previously transmitted character
先前传输的字符已经完成，

1294
00:40:47,150 --> 00:40:48,830
0,150 150,900 1110,1290 1290,1410 1410,1680
is finished| and it's OK
|uartwrite 可以继续传输下一个字符，

1295
00:40:48,830 --> 00:40:49,670
0,120 120,300 300,480 480,720 720,840
for {uartwrite - -} to

1296
00:40:49,670 --> 00:40:51,200
0,600 600,690 690,1200 1200,1290 1290,1530
proceed to transmitting the next

1297
00:40:51,200 --> 00:40:52,700
0,510 810,1080 1080,1200 1200,1260 1260,1500
character,| so it's a little
|所以它是一小段，

1298
00:40:52,700 --> 00:40:54,000
0,300 300,720
piece of,|
|

1299
00:40:54,320 --> 00:40:55,850
0,300 300,450 450,660 660,840 840,1530
just like a little communication
中断例程到 uartwrite 的一个小通信标志。

1300
00:40:55,850 --> 00:40:57,530
0,390 390,570 570,660 660,1080 1080,1680
flag from the interrupt routine

1301
00:40:58,280 --> 00:40:59,680
0,180 180,510 510,810
to {uartwrite -}.|
|

1302
00:41:03,430 --> 00:41:05,830
0,840 840,1110 1110,1500 1710,2070 2070,2400
Because if it it could
因为如果它会睡眠，

1303
00:41:05,920 --> 00:41:07,270
0,390 390,480 480,630 630,1170 1200,1350
like it would sleep| and
|然后，当它醒来时，它会知道，

1304
00:41:07,270 --> 00:41:08,230
0,150 150,240 240,420 420,600 600,960
then it would know that

1305
00:41:08,380 --> 00:41:10,040
0,210 210,420 450,810 810,1140
when it wakes up,|
|

1306
00:41:10,100 --> 00:41:12,230
0,300 300,840 840,990 990,1290 1350,2130
it's probably {uart -} interrupted
可能是 uart 中断唤醒了它，

1307
00:41:12,410 --> 00:41:14,520
0,330 330,480 480,810 990,1530
woke it up,| so
|所以可能已经设置了 tx_done 位，

1308
00:41:15,010 --> 00:41:17,050
0,480 480,750 900,1470 1470,1710 1710,2040
probably the {tx_done -} bit

1309
00:41:17,560 --> 00:41:19,270
0,420 450,660 660,870 870,1170 1170,1710
like would have been set,|
|

1310
00:41:19,300 --> 00:41:20,230
0,300 300,450 450,540 540,720 720,930
but if we didn't have
但如果我们没有它，

1311
00:41:20,230 --> 00:41:22,210
0,270 690,1200 1230,1680 1680,1860 1860,1980
it,| so I guess I'm
|所以我想我是说，

1312
00:41:22,210 --> 00:41:24,070
0,240 240,510 840,1200 1200,1500 1500,1860
saying that| actually {wakeup -}
|wakeup 应该知道它是由 uart 中断引起的。

1313
00:41:24,340 --> 00:41:25,600
0,420 450,720 720,930 930,1080 1080,1260
it should know that it's

1314
00:41:25,600 --> 00:41:28,210
0,210 210,450 450,900 1410,2190 2400,2610
from {uart -} interrupt.| Okay,
|好的，这是你提问的另一种方式，

1315
00:41:28,210 --> 00:41:28,990
0,150 150,330 330,570 570,690 690,780
so is another way of

1316
00:41:28,990 --> 00:41:30,220
0,270 270,390 390,810 810,1020 1020,1230
phrasing your question,| how come
|为什么这里会有个 while 循环，

1317
00:41:30,220 --> 00:41:31,930
0,180 180,330 330,900 900,1200 1200,1710
there's this while loop here,|
|

1318
00:41:33,540 --> 00:41:35,100
0,330 330,390 390,600 600,930 930,1560
instead of just.| Okay, okay
而不是仅仅。|好的，我想回答了我的问题，

1319
00:41:35,100 --> 00:41:36,450
0,240 240,330 330,840 960,1110 1110,1350
{I,think,answer} my question,| {} I
|我想问题的答案是，

1320
00:41:36,450 --> 00:41:37,320
0,240 240,420 420,690 690,780 780,870
think the answer to my

1321
00:41:37,320 --> 00:41:38,610
0,330 330,510 510,870 870,990 990,1290
question is,| because {uart -}
|因为 uart 中断有两个目的。

1322
00:41:38,670 --> 00:41:40,860
0,660 660,930 930,1050 1050,1770 1770,2190
interrupt serve two purposes.| Okay,
|好的。

1323
00:41:40,890 --> 00:41:41,800
0,330
yeah.|
|

1324
00:41:42,040 --> 00:41:44,050
0,480 480,1110 1110,1290 1290,1470 1470,2010
Yeah yeah yeah,| in general,
是的，|一般说来，你的问题的答案是

1325
00:41:44,080 --> 00:41:45,700
0,390 390,810 960,1290 1290,1380 1380,1620
did your answer your question

1326
00:41:45,700 --> 00:41:46,630
0,60 60,180 180,270 270,360 360,930
is| sort of a specific
|更笼统的回答的一个具体例子，

1327
00:41:46,630 --> 00:41:47,770
0,420 420,510 510,570 570,780 780,1140
instance of the more general

1328
00:41:47,770 --> 00:41:50,220
0,450 450,870 1050,1800
answer that, {}|
|

1329
00:41:51,520 --> 00:41:54,010
0,420 420,930 1680,1860 1860,2100 2100,2490
{} it's it just turns
事实证明这不是实际的，

1330
00:41:54,010 --> 00:41:56,830
0,360 360,450 450,990 1470,1890 1890,2820
out to be not practical|
|

1331
00:41:56,860 --> 00:41:58,540
0,270 270,750 780,1380 1380,1470 1470,1680
to make sleeps and {wakeups
让睡眠和唤醒保证精确，

1332
00:41:58,540 --> 00:42:01,300
0,120 120,720 750,1620 1620,2220 2220,2760
-} speed precise guaranteed precise,|
|

1333
00:42:01,300 --> 00:42:02,500
0,180 180,300 300,570 630,960 960,1200
that is that if sleep
也就是说，如果 sleep 返回，

1334
00:42:02,500 --> 00:42:04,990
0,390 390,810 840,1260 1260,1980 2010,2490
returns,| then for sure, whatever
|那么可以肯定，无论你等待的是什么都已经发生了。

1335
00:42:04,990 --> 00:42:06,250
0,150 150,420 420,600 600,720 720,1260
you're waiting for has happened.|
|

1336
00:42:06,340 --> 00:42:07,540
0,390
So,
举个例子，假设我们有两个进程，

1337
00:42:07,600 --> 00:42:09,190
0,210 210,630 630,720 720,1260 1350,1590
one example of this is

1338
00:42:09,190 --> 00:42:10,570
0,300 540,900 900,1050 1050,1140 1140,1380
that suppose we have two

1339
00:42:10,570 --> 00:42:12,580
0,600 600,750 750,840 840,1650 1710,2010
processes,| that are both trying
|它们同时试图写入 uart ，

1340
00:42:12,580 --> 00:42:13,480
0,90 90,270 270,390 390,600 600,900
to write that {uart -}

1341
00:42:13,510 --> 00:42:14,740
0,210 210,300 300,570 570,1050 1080,1230
at the same time,| they're
|它们都在 uartwrite ，它们可以，

1342
00:42:14,740 --> 00:42:15,670
0,210 210,330 330,480 480,630 630,930
both in {uartwrite - -}

1343
00:42:15,730 --> 00:42:17,290
0,120 120,210 210,480 480,960 1200,1560
and they can,| because after
|因为在一个写完一个字符之后，它会休眠，

1344
00:42:17,290 --> 00:42:18,640
0,300 300,540 540,600 600,1170 1170,1350
one writes a character, it'll

1345
00:42:18,640 --> 00:42:21,850
0,750 1020,1650 1770,2640 2670,2940 2940,3210
sleep,| {} releasing that turns
|释放锁，

1346
00:42:21,850 --> 00:42:23,140
0,180 180,480 480,570 570,960 1050,1290
out releasing the lock| and
|然后另一个可以进入循环

1347
00:42:23,140 --> 00:42:24,250
0,120 120,210 210,390 390,660 660,1110
then the other one can

1348
00:42:24,280 --> 00:42:25,870
0,390 390,630 630,1050 1050,1350 1380,1590
enter that loop| and try
|并等待，直到 uart 不忙。

1349
00:42:25,870 --> 00:42:26,920
0,120 120,360 360,630 630,840 840,1050
to wait until {uart -}

1350
00:42:26,950 --> 00:42:28,940
0,210 210,660 1050,1560
not busy {}.|
|

1351
00:42:29,120 --> 00:42:30,230
0,210 210,300 300,690 690,840 840,1110
And they both may both
它们可能最终都会睡眠，

1352
00:42:30,230 --> 00:42:32,210
0,180 180,360 360,960 1200,1740 1800,1980
end up sleeping| and when
|并且当 uart 中发生中断时，

1353
00:42:32,210 --> 00:42:33,200
0,60 60,390 390,810 810,900 900,990
an interrupt happens in the

1354
00:42:33,200 --> 00:42:34,190
0,270 270,390 390,660 660,840 840,990
uart,| can accept one more
|可以再接受一个字符，

1355
00:42:34,190 --> 00:42:35,540
0,540 540,690 690,930 930,1020 1020,1350
character,| they'll both be woken
|它们都会被唤醒，

1356
00:42:35,540 --> 00:42:37,730
0,390 600,1050 1050,1230 1230,1440 1440,2190
up up,| but only one
|但只有一个能真正写入这个字符。

1357
00:42:38,090 --> 00:42:39,620
0,300 300,600 600,810 810,900 900,1530
should actually write the character.|
|

1358
00:42:40,270 --> 00:42:41,740
0,240 240,390 390,570 570,930 930,1470
And that this while loop.|
这个 while 循环。|

1359
00:42:42,180 --> 00:42:43,350
0,180 180,390 390,690 690,780 780,1170
And in fact you'll see
事实上，我相信在 xv6 中的每个 sleep 都会出现 while 循环，

1360
00:42:43,350 --> 00:42:44,970
0,150 150,480 480,810 810,1020 1020,1620
a while loop every sleep,

1361
00:42:44,970 --> 00:42:46,800
0,270 270,570 570,630 630,1140 1500,1830
{in,xv6 -} I believe, {}|
|

1362
00:42:46,800 --> 00:42:48,420
0,390 390,690 690,900 900,1290 1290,1620
it's because this problem of,|
就是因为这个问题，|

1363
00:42:48,690 --> 00:42:49,950
0,300 300,540 540,870 870,1110 1110,1260
you maybe woken up,| but
你可能醒来了，|但实际上有人拿走了你等待的东西，

1364
00:42:49,950 --> 00:42:51,330
0,240 240,660 660,1020 1020,1230 1230,1380
really somebody else sort of

1365
00:42:51,330 --> 00:42:52,320
0,360 360,480 480,720 720,840 840,990
took the thing you were

1366
00:42:52,320 --> 00:42:53,250
0,300 300,630 630,750 750,840 840,930
waiting for,| so you have
|所以你得再睡眠一次，

1367
00:42:53,250 --> 00:42:55,230
0,120 120,390 390,930 1110,1380 1380,1980
to sleep again,| this happens
|这种情况随处可见。

1368
00:42:56,110 --> 00:42:57,420
0,720
pervasively.|
|

1369
00:42:59,600 --> 00:43:02,380
0,390 390,570 570,1020 1230,1710
Okay.| Thank you.| Yes.|
好的。|谢谢。|好的。|

1370
00:43:03,000 --> 00:43:04,900
0,480 480,600 600,660 660,1230
I've got a question.|
我有个问题。|

1371
00:43:04,900 --> 00:43:06,670
0,300 330,870 1110,1350 1350,1440 1440,1770
Yes.| {} So it looks
好的。|所以看起来我们只看到一次丢失的唤醒，

1372
00:43:06,670 --> 00:43:08,500
0,570 930,1260 1260,1380 1380,1590 1590,1830
like {} we only saw

1373
00:43:08,500 --> 00:43:10,870
0,360 360,720 720,930 930,1200 1500,2370
one lost {wakeup -},| because
|因为只要我们按下键输入一个字符，

1374
00:43:10,930 --> 00:43:12,070
0,150 150,270 270,390 390,510 510,1140
as soon as we pressed

1375
00:43:12,100 --> 00:43:13,360
0,180 180,240 240,960 960,1050 1050,1260
like a character,| the rest
|剩下的输出就都出来了，

1376
00:43:13,360 --> 00:43:14,830
0,90 90,180 180,720 1230,1410 1410,1470
of the output of the

1377
00:43:14,830 --> 00:43:16,330
0,450 450,690 690,990 990,1200 1200,1500
entire rest output came out,|
|

1378
00:43:16,510 --> 00:43:18,070
0,480 480,540 540,690 690,1080 1080,1560
shouldn't we have seen multiple
我们不是应该看到多个丢失的唤醒吗，

1379
00:43:18,070 --> 00:43:19,720
0,270 270,420 420,630 630,1200 1410,1650
lost {wakeups -} where,| why
|为什么没有再发生一次。

1380
00:43:19,720 --> 00:43:21,220
0,300 300,540 540,1020
didn't happen again.|
|

1381
00:43:21,220 --> 00:43:22,240
0,240 240,360 360,690 690,780 780,1020
Oh, it did it did
哦，它是这样的，

1382
00:43:22,240 --> 00:43:23,170
0,150 150,270 270,660 660,810 810,930
here,| let me let me
|让我来运行这个，

1383
00:43:23,170 --> 00:43:24,430
0,180 180,360 360,630 630,870 870,1260
run this,| {I'm,going,to} run readme,|
|我要运行 readme ，|

1384
00:43:24,460 --> 00:43:25,630
0,270 270,570 570,810 810,990 990,1170
{I'm,going,to} cat {README -} right,|
我要执行 cat README ，|

1385
00:43:25,630 --> 00:43:26,710
0,180 180,360 360,570 570,810 810,1080
which is a couple thousand
这是几千字节，

1386
00:43:26,710 --> 00:43:29,980
0,420 600,1050 1620,2130 2130,3030 3090,3270
bytes,| so, oops, I had
|所以，糟糕，我已经输入一些东西了。

1387
00:43:29,980 --> 00:43:31,300
0,210 210,480 480,870
already typed something.|
|

1388
00:43:31,570 --> 00:43:32,470
0,180 180,390 390,600 600,690 690,900
I guess we've got one
我想我们已经有一个字符，

1389
00:43:32,470 --> 00:43:33,700
0,480 570,780 780,900 900,960 960,1230
character,| I'm going to type
|我要输入一个句号，

1390
00:43:33,700 --> 00:43:35,280
0,60 60,960
a period,|
|

1391
00:43:35,370 --> 00:43:36,000
0,240 240,300 300,420 420,450 450,630
{} we got a few
我们又多了几个字符，然后它又卡住了。

1392
00:43:36,000 --> 00:43:37,200
0,180 180,930 930,1020 1020,1110 1110,1200
more characters and then it

1393
00:43:37,200 --> 00:43:38,680
0,180 180,330 330,840
hung up again.|
|

1394
00:43:38,680 --> 00:43:39,820
0,90 90,240 240,420 420,720 720,1140
I'm gonna take another period,
我要再输入一个句号，另外几个字符。

1395
00:43:39,820 --> 00:43:41,860
0,450 450,690 690,1500
another couple characters.|
|

1396
00:43:41,890 --> 00:43:42,700
0,300 300,510 510,540 540,780 780,810
Each time I type a
每次我输入句号，会引起输入的中断，

1397
00:43:42,700 --> 00:43:44,470
0,390 390,510 510,1050 1050,1260 1320,1770
period that causes an interrupt

1398
00:43:44,470 --> 00:43:46,380
0,630 630,720 720,1350
for the input,|
|

1399
00:43:46,470 --> 00:43:47,430
0,240 240,450 450,720 720,840 840,960
which then wakes up the
然后唤醒这个进程，

1400
00:43:47,430 --> 00:43:48,240
0,450 450,570 570,630 630,720 720,810
process| and it could do
|它可以再写出几个字符，然后再挂起来。

1401
00:43:48,240 --> 00:43:49,140
0,60 60,210 210,390 390,810 810,900
a few more characters of

1402
00:43:49,140 --> 00:43:51,000
0,330 330,540 540,840 840,1380
wirtes then hangs again.|
|

1403
00:43:51,060 --> 00:43:52,590
0,480 480,690 690,1020 1020,1230 1230,1530
{You,know} another lost {wakeup -}.|
另一个丢失的唤醒。|

1404
00:43:53,930 --> 00:43:56,240
0,420 660,1680 1680,1890 1890,2070 2070,2310
{} Yeah, just miss that,
是的，错过了，有道理。

1405
00:43:56,510 --> 00:43:57,800
0,270 270,570 900,1080 1080,1200 1200,1290
makes sense.| Yeah, so I'm
|是的，所以我输入句号，

1406
00:43:57,800 --> 00:43:58,850
0,270 270,630 630,750 750,870 870,1050
typing period,| here I get
|每次丢失的唤醒都会得到几个字符，

1407
00:43:58,850 --> 00:44:01,040
0,330 690,900 900,1440 1440,1830 1830,2190
a couple characters per lost

1408
00:44:01,040 --> 00:44:01,730
0,180 180,270 270,450 450,570 570,690
{wakeup -},| because of the
|因为丢失的唤醒需要这个巧合，

1409
00:44:01,730 --> 00:44:04,130
0,270 270,720 870,1410 1410,1560 1560,2400
lost wakeup requires this coincidence,|
|

1410
00:44:04,130 --> 00:44:06,020
0,210 570,870 870,1470 1470,1620 1620,1890
that the interrupt has already
中断已经发生了，并且等待获取锁，

1411
00:44:06,020 --> 00:44:07,190
0,480 480,570 570,690 690,1050 1050,1170
happened and was waiting to

1412
00:44:07,190 --> 00:44:08,600
0,330 330,420 420,900
acquire the lock,|
|

1413
00:44:08,690 --> 00:44:10,000
0,420 420,750
just that,|
正是这样，|

1414
00:44:10,200 --> 00:44:11,400
0,330 330,480 480,630 630,1140 1140,1200
we get that coincidence a
我们经常会遇到这样的巧合，但并不总是。

1415
00:44:11,400 --> 00:44:12,000
0,150 150,210 210,270 270,480 480,600
lot of the time, but

1416
00:44:12,000 --> 00:44:13,220
0,180 180,330 330,390 390,660
not all the time.|
|

1417
00:44:15,650 --> 00:44:17,260
0,570
Alright.|
好的。|

1418
00:44:17,260 --> 00:44:19,900
0,330 330,540 1170,1680 1680,2100 2100,2640
Okay so our goal then
好的，我们的目标是避免这个丢失唤醒的问题，

1419
00:44:19,930 --> 00:44:20,680
0,270 270,390 390,570 570,690 690,750
is to get rid of

1420
00:44:20,680 --> 00:44:22,300
0,270 270,540 540,870 870,1290 1290,1620
this lost wakeup problem,| by
|通过消除这个窗口，

1421
00:44:22,330 --> 00:44:24,910
0,420 420,1260 1260,1410 1410,1920 1920,2580
somehow eliminating this window here,|
|

1422
00:44:25,540 --> 00:44:27,370
0,840 840,930 930,1620 1620,1740 1740,1830
between the release of the
在 release(&uart_tx_lock) 之间，

1423
00:44:27,370 --> 00:44:28,570
0,360 360,750 750,960 960,1110 1110,1200
{uart_tx_lock - -},| which we
|我们必须释放它，

1424
00:44:28,570 --> 00:44:30,880
0,420 420,540 540,1170 1170,1680 1830,2310
have to release,| because the
|因为中断需要这个锁，

1425
00:44:30,880 --> 00:44:32,770
0,630 750,1170 1170,1410 1410,1740 1740,1890
interrupt needs that lock,| so
|所以我们必须释放锁。

1426
00:44:32,770 --> 00:44:33,310
0,120 120,210 210,330 330,450 450,540
we know we have to

1427
00:44:33,310 --> 00:44:34,840
0,270 270,390 390,780
release the lock.|
|

1428
00:44:34,840 --> 00:44:35,590
0,150 150,450 450,540 540,690 690,750
But somehow we want to
但是，我们想要消除这个窗口

1429
00:44:35,590 --> 00:44:37,150
0,480 480,630 630,1020 1020,1380 1380,1560
eliminate this window| between when
|在释放锁和进程将自己标记为睡眠中，

1430
00:44:37,150 --> 00:44:39,010
0,150 150,510 510,630 630,1170 1590,1860
we release the lock and

1431
00:44:39,010 --> 00:44:40,690
0,480 480,570 570,1020 1020,1410 1410,1680
when the process actually marks

1432
00:44:40,690 --> 00:44:42,940
0,330 330,420 420,1140 1560,1830 1830,2250
itself as sleeping,| so that
|所以中断的 wakeup 可以看到进程处于睡眠状态，

1433
00:44:42,940 --> 00:44:44,020
0,150 150,540 540,810 810,990 990,1080
the interrupts {wakeup -} will

1434
00:44:44,020 --> 00:44:45,040
0,330 330,450 450,540 540,930 930,1020
see that the process is

1435
00:44:45,040 --> 00:44:46,210
0,390 390,570 570,870 870,1050 1050,1170
sleeping| and actually wake it
|真正唤醒它，而不会丢失唤醒。

1436
00:44:46,210 --> 00:44:47,530
0,330 360,480 480,810 810,1080 1080,1320
up and therefore not lose

1437
00:44:47,530 --> 00:44:48,580
0,90 90,330 330,630
the {wakeup -}.|
|

1438
00:44:48,970 --> 00:44:50,470
0,360 720,1020 1020,1110 1110,1170 1170,1500
So we've got to somehow
所以我们要消除这个窗口。

1439
00:44:50,470 --> 00:44:53,040
0,330 330,510 510,990
close that window.|
|

1440
00:44:53,570 --> 00:44:54,950
0,570 630,780 780,870 870,1020 1020,1380
{} And to do that,
要做到这一点，会使睡眠接口变得更复杂，

1441
00:44:55,040 --> 00:44:56,570
0,180 180,450 450,750 780,1200 1200,1530
we gotta make sleep's interface

1442
00:44:56,570 --> 00:44:57,860
0,60 60,210 210,330 330,450 450,1290
a little bit more complicated,|
|

1443
00:44:58,160 --> 00:44:59,880
0,510 660,1170
{} so,
所以，回到原来可以工作的 sleep ，

1444
00:44:59,880 --> 00:45:01,780
0,210 210,510 510,660 660,1050
go back to the

1445
00:45:02,050 --> 00:45:03,220
0,600
{}

1446
00:45:04,090 --> 00:45:05,800
0,570 570,960 960,1410 1410,1530 1530,1710
original working sleep| and I
|我称为可工作的 sleep ，

1447
00:45:05,800 --> 00:45:07,450
0,390 390,480 480,780 780,1200 1320,1650
called a working sleep| and
|人们解决这个问题的方式是

1448
00:45:07,630 --> 00:45:10,540
0,450 480,960 960,1650 1800,2670 2670,2910
the way that people solve

1449
00:45:10,540 --> 00:45:11,820
0,150 150,720
this problem

1450
00:45:11,880 --> 00:45:13,890
0,120 120,240 240,720 750,1830 1830,2010
is| that sleep requires,| even
|就是 sleep 需要，|即使 sleep 并不知道你在等什么，

1451
00:45:13,890 --> 00:45:15,180
0,90 90,660 660,960 960,1170 1170,1290
though sleep doesn't really know

1452
00:45:15,180 --> 00:45:16,890
0,180 180,300 300,630 630,1020 1320,1710
what you're waiting for,| it
|它需要你在等待一些东西，

1453
00:45:16,890 --> 00:45:18,060
0,450 450,570 570,690 690,810 810,1170
requires that you be waiting

1454
00:45:18,060 --> 00:45:20,790
0,180 180,1200 1350,1560 1560,2400 2430,2730
for something| and furthermore that
|另外，还需要一个锁，

1455
00:45:20,790 --> 00:45:22,200
0,150 150,330 330,420 420,1080 1140,1410
there be a lock| that
|保护你等待的任何东西。

1456
00:45:22,200 --> 00:45:23,880
0,630 630,1050 1050,1140 1140,1500 1500,1680
protects whatever it is you're

1457
00:45:23,880 --> 00:45:25,080
0,330 330,690
waiting for.|
|

1458
00:45:25,710 --> 00:45:26,790
0,360 360,420 420,780 780,900 900,1080
So it requires that there
所以它需要有一个睡眠状态，

1459
00:45:26,790 --> 00:45:28,580
0,120 120,210 210,570 570,1200
be a sleep condition,|
|

1460
00:45:28,910 --> 00:45:29,720
0,180 180,270 270,480 480,660 660,810
which it doesn't really know
它并不知道，

1461
00:45:29,720 --> 00:45:32,420
0,450 870,1440 1800,2190 2190,2580 2580,2700
about| the sleep condition is
|睡眠状态是 tx_done 等于 1 ，

1462
00:45:32,420 --> 00:45:33,860
0,210 210,600 600,870 870,1020 1020,1440
that {tx_done -} is equal

1463
00:45:33,980 --> 00:45:36,020
0,180 180,810 1470,1770 1770,1950 1950,2040
to one,| sleep doesn't know
|sleep 不知道睡眠状态是什么，

1464
00:45:36,020 --> 00:45:36,920
0,120 120,210 210,420 420,780 780,900
what the sleep condition is,|
|

1465
00:45:36,920 --> 00:45:37,940
0,150 150,240 240,630 630,810 810,1020
but it does it is
但是它需要有一个锁，

1466
00:45:38,090 --> 00:45:39,530
0,1020 1020,1140 1140,1260 1260,1380 1380,1440
requires, that there be a

1467
00:45:39,530 --> 00:45:40,850
0,330 330,450 450,990 990,1080 1080,1320
lock,| that protects the sleep
|保护睡眠状态，也就是 uart_tx_lock ，

1468
00:45:40,850 --> 00:45:43,130
0,450 450,1260 1260,1440 1440,1830 1830,2280
condition, namely this {uart_tx_lock -

1469
00:45:43,130 --> 00:45:45,050
0,420 690,1170 1320,1500 1500,1800 1800,1920
-}| and the lock be
|当你检查状态时，是持有锁的，

1470
00:45:45,050 --> 00:45:47,150
0,810 960,1650 1650,1770 1770,1980 1980,2100
locked when you check the

1471
00:45:47,150 --> 00:45:48,230
0,480 480,570 570,690 690,990 990,1080
condition,| that you hold the
|你一直持有锁直到调用 sleep ，

1472
00:45:48,230 --> 00:45:49,700
0,300 300,540 540,660 660,870 870,1470
lock until you call sleep,|
|

1473
00:45:50,030 --> 00:45:51,140
0,390 390,540 540,660 660,750 750,1110
{} and that you pass
然后把锁传递给 sleep 。

1474
00:45:51,140 --> 00:45:52,340
0,90 90,360 360,450 450,930
the lock to sleep.|
|

1475
00:45:52,430 --> 00:45:54,290
0,180 180,300 300,750 750,1320 1320,1860
And what sleep promises essentially
在接口层面上， sleep 保证的是

1476
00:45:54,290 --> 00:45:55,490
0,90 90,300 330,810 810,1080 1080,1200
at the interface level is|
|

1477
00:45:55,490 --> 00:45:57,560
0,240 420,780 780,1080 1080,1740 1740,2070
that it's gonna {atomically -}
它会原子地使进程睡眠并释放锁，

1478
00:45:57,800 --> 00:45:59,180
0,450 450,540 540,930 930,1050 1050,1380
put the process to sleep

1479
00:45:59,180 --> 00:46:00,860
0,180 180,510 510,630 630,1170 1470,1680
and release the lock| as
|作为一种，至少是一对不可分割的行动，

1480
00:46:00,860 --> 00:46:01,940
0,30 30,270 270,540
a sort of,

1481
00:46:01,940 --> 00:46:03,200
0,150 150,450 570,810 810,960 960,1260
at least it is an

1482
00:46:03,230 --> 00:46:05,210
0,810 810,1140 1140,1200 1200,1890 1890,1980
indivisible pair of actions,| at
|至少对于 wakeup 来说是这样的。

1483
00:46:05,210 --> 00:46:06,740
0,390 390,510 510,900 900,990 990,1530
least with respect to {wakeup

1484
00:46:07,100 --> 00:46:08,280
0,600
-}.|
|

1485
00:46:09,000 --> 00:46:10,100
0,540
So,
所以， wakeup 不会再看到这种情况，

1486
00:46:10,160 --> 00:46:11,510
0,300 300,420 420,510 510,900 930,1350
{wakeup -} will never see

1487
00:46:11,510 --> 00:46:12,740
0,180 180,690 690,930 930,1110 1110,1230
this situation,| which yeah you
|你释放了锁，但是进程没有睡眠，

1488
00:46:12,740 --> 00:46:14,300
0,300 300,420 420,990 1020,1230 1230,1560
release the lock, but {you,know}

1489
00:46:14,300 --> 00:46:15,710
0,120 120,540 540,630 630,810 810,1410
the process is not sleep,|
|

1490
00:46:16,160 --> 00:46:17,330
0,390 390,660 660,810 810,1110 1110,1170
sleep makes the release of
sleep 释放锁，进入睡眠状态是原子的。

1491
00:46:17,330 --> 00:46:18,590
0,60 60,330 330,660 720,990 990,1260
the lock and putting the

1492
00:46:18,860 --> 00:46:22,960
0,480 480,630 630,1350
{process,to,sleep} the atomic.|
|

1493
00:46:23,110 --> 00:46:24,190
0,270 270,360 360,720 720,840 840,1080
And the rules for this
这里的规则是必须有一个条件，

1494
00:46:24,190 --> 00:46:24,940
0,180 180,390 390,510 510,660 660,750
is that there has to

1495
00:46:24,940 --> 00:46:25,810
0,90 90,390 390,630 630,690 690,870
be, this has to be

1496
00:46:25,810 --> 00:46:27,940
0,90 90,900 1410,1740 1800,2070 2070,2130
a condition,| which has to
|必须有一个保护条件的锁，

1497
00:46:27,940 --> 00:46:28,990
0,150 150,240 240,540 540,960 960,1050
be a lock protecting the

1498
00:46:28,990 --> 00:46:30,520
0,630 870,1080 1080,1260 1260,1440 1440,1530
condition,| the lock has to
|当你调用 sleep 时，必须持有锁，

1499
00:46:30,520 --> 00:46:31,300
0,120 120,360 360,480 480,570 570,780
be held when you call

1500
00:46:31,300 --> 00:46:32,230
0,420 420,480 480,570 570,660 660,930
sleep,| you have to pass
|你必须把锁传递给 sleep ，

1501
00:46:32,230 --> 00:46:33,010
0,90 90,300 300,390 390,660 660,780
the lock to sleep,| and
|另外，当你调用 wakeup 时，也必须持有锁。

1502
00:46:33,010 --> 00:46:35,650
0,960 1140,1470 1470,1680 1680,2070 2280,2640
furthermore {} the lock has

1503
00:46:35,650 --> 00:46:36,880
0,90 90,210 210,750
to be held,

1504
00:46:36,880 --> 00:46:38,680
0,570 900,1200 1200,1290 1290,1530 1530,1800
when {} you call {wakeup

1505
00:46:38,680 --> 00:46:39,640
0,390
-}.|
|

1506
00:46:39,640 --> 00:46:41,110
0,150 150,540 540,870 930,1410 1410,1470
This condition lock needs to
当你调用 wakeup 时，需要持有这个条件锁，

1507
00:46:41,110 --> 00:46:42,100
0,210 240,570 570,690 690,780 780,990
be held when you call

1508
00:46:42,100 --> 00:46:42,910
0,210 210,300 330,570 570,690 690,810
{wakeup -} {wakeup -},| so
|所以这些都是程序员最好遵守的规则，

1509
00:46:42,910 --> 00:46:45,460
0,120 120,210 210,990
these are rules,

1510
00:46:45,460 --> 00:46:46,450
0,120 120,210 210,630 630,750 750,990
that the programmer had better

1511
00:46:46,450 --> 00:46:47,980
0,630 660,1020 1170,1320 1320,1470 1470,1530
follow,| if they want to
|如果想要使用 sleep 和 wakeup 编写正确的代码。

1512
00:46:47,980 --> 00:46:49,210
0,150 150,450 450,750 750,990 990,1230
write correct code using sleep

1513
00:46:49,210 --> 00:46:50,700
0,90 90,300 300,450
and {wakeup -}.|
|

1514
00:46:52,790 --> 00:46:53,820
0,540
Alright.|
好的。|

1515
00:46:54,140 --> 00:46:55,700
0,1020

1516
00:46:55,790 --> 00:46:57,350
0,240 240,450 450,720 720,1020 1320,1560
So let's look at the
让我们来看看 sleep 和 wakeup ，

1517
00:46:57,380 --> 00:46:59,090
0,330 330,420 420,600 600,1080 1260,1710
sleep and {wakeup -}, {}|
|

1518
00:46:59,150 --> 00:47:00,260
0,270 270,330 330,600 600,960 960,1110
trying to spot how they
试着发现它们是如何

1519
00:47:00,260 --> 00:47:02,030
0,630 810,1140 1140,1350 1350,1620 1620,1770
actually| use this extra little
|使用这个额外信息和这些规则，

1520
00:47:02,030 --> 00:47:03,410
0,240 240,300 300,1080 1080,1200 1200,1380
piece of information and these

1521
00:47:03,410 --> 00:47:05,840
0,720 1140,1440 1440,2010 2010,2250 2250,2430
rules| to avoid lost {wakeups
|以避免丢失的唤醒。

1522
00:47:05,840 --> 00:47:06,950
0,390 540,750 750,930 930,990 990,1110
-}.| So first I want
|首先我想看一下 wakeup ，

1523
00:47:06,950 --> 00:47:07,670
0,60 60,180 180,270 270,480 480,720
to look at {wakeup -},|
|

1524
00:47:10,130 --> 00:47:12,050
0,810 810,900 900,1080 1080,1230 1230,1920
{wakeup -} not very surprising,|
wakeup 并不令人惊讶，|

1525
00:47:12,530 --> 00:47:13,550
0,330 330,480 480,750 750,840 840,1020
it just runs through the
它遍历整个进程表，

1526
00:47:13,550 --> 00:47:16,370
0,300 300,660 660,1140 1500,1740 1770,2820
entire process table,| it locks
|它锁定每个进程，

1527
00:47:16,400 --> 00:47:19,460
0,360 360,1320 1530,2010 2010,2280 2490,3060
every process,| remember that, after
|还记得吗，在进程加锁之后，

1528
00:47:19,460 --> 00:47:21,110
0,120 120,510 510,1140 1140,1230 1230,1650
it's locked process,| you can't
|你不能查看加锁进程的状态，

1529
00:47:21,110 --> 00:47:22,040
0,180 180,420 420,480 480,510 510,930
really look at a process

1530
00:47:22,040 --> 00:47:23,090
0,60 60,330 330,570 570,870 870,1050
at state with locking it,|
|

1531
00:47:23,390 --> 00:47:25,280
0,180 180,450 450,600 600,1320 1620,1890
it locks each process,| if
它锁定每个进程，|如果进程处于睡眠状态，

1532
00:47:25,280 --> 00:47:27,260
0,180 180,630 630,720 720,1530
the process is sleeping,|
|

1533
00:47:27,320 --> 00:47:29,420
0,390 390,870 870,1290 1380,1890 1890,2100
{} and the channel that's
而且睡眠的信道跟传递给 wakeup 的信道一样，

1534
00:47:29,420 --> 00:47:30,650
0,390 390,630 630,720 720,840 840,1230
sleeping for is the same

1535
00:47:30,650 --> 00:47:31,670
0,390 390,510 510,660 660,960 960,1020
channel that was passed to

1536
00:47:31,670 --> 00:47:32,880
0,270 270,690
{wakeup -},|
|

1537
00:47:32,880 --> 00:47:34,500
0,510 510,750 750,930 930,1410 1410,1620
then {wakeup -} marks the
然后 wakeup 将进程的状态更改为可运行，

1538
00:47:34,500 --> 00:47:35,760
0,390 390,480 480,870 870,960 960,1260
changes the process of state

1539
00:47:35,760 --> 00:47:37,410
0,120 120,660 900,1050 1050,1260 1260,1650
to runnable| and then releases
|然后释放进程的锁。

1540
00:47:37,410 --> 00:47:38,960
0,90 90,630 630,1110
the process's lock.|
|

1541
00:47:40,400 --> 00:47:42,320
0,300 300,450 450,900 900,1380
So no surprises here.|
这里没有什么令人惊讶的地方。|

1542
00:47:42,960 --> 00:47:45,660
0,360 360,540 540,960 960,1440 1980,2700
{} We'll ignore my {broken_sleep
我们忽略我的 broken_sleep ，

1543
00:47:45,660 --> 00:47:46,770
0,450 450,690 690,900 900,1050 1050,1110
-}| and instead look at
|而是查看原来的 sleep ，

1544
00:47:46,770 --> 00:47:48,540
0,300 300,990 1200,1440 1440,1680 1680,1770
sleep itself,| so here's the
|这里是 sleep 的实现，

1545
00:47:48,540 --> 00:47:50,340
0,600 600,690 690,1260
implementation of sleep,|
|

1546
00:47:50,630 --> 00:47:51,880
0,780

1547
00:47:52,820 --> 00:47:54,380
0,240 240,510 510,900 900,1170 1170,1560
with now, this new lock
现在，有这个新的 lock 参数。

1548
00:47:54,380 --> 00:47:55,500
0,510
argument.|
|

1549
00:47:56,690 --> 00:47:58,520
0,600 1080,1320 1320,1410 1410,1560 1560,1830
{} So we know sleep
所以我们知道 sleep 必须释放条件锁，

1550
00:47:58,520 --> 00:47:59,840
0,360 360,510 510,990 990,1200 1200,1320
has to reduce has to

1551
00:47:59,840 --> 00:48:02,180
0,810 840,1080 1080,1500 1500,2070 2100,2340
release that condition lock| that
|这是它的第二个参数，

1552
00:48:02,270 --> 00:48:03,500
0,210 210,540 540,990 990,1110 1110,1230
its second argument,| we know
|我们知道它必须释放它，

1553
00:48:03,500 --> 00:48:04,190
0,60 60,210 210,330 330,600 600,690
it has to release it,|
|

1554
00:48:04,190 --> 00:48:05,320
0,300 300,570
because the
因为中断例程必须能够获取，

1555
00:48:05,410 --> 00:48:06,280
0,120 120,180 180,300 300,600 600,870
you know the interrupt routine

1556
00:48:06,280 --> 00:48:06,850
0,150 150,240 240,330 330,450 450,570
has to be able to

1557
00:48:06,850 --> 00:48:08,050
0,540 570,810 810,900 900,1050 1050,1200
acquire,| so we know there's
|所以我们知道在 sleep 中某个地方释放锁，

1558
00:48:08,050 --> 00:48:08,920
0,120 120,180 180,330 330,750 750,870
going to be release of

1559
00:48:08,920 --> 00:48:10,540
0,240 240,540 540,870 870,1230 1230,1620
that lock somewhere inside sleep,|
|

1560
00:48:10,540 --> 00:48:12,160
0,90 90,660 690,1200 1200,1290 1290,1620
and indeed here's the release
实际上，这是那个释放锁的地方，

1561
00:48:12,160 --> 00:48:13,600
0,60 60,240 240,690 930,1260 1260,1440
of that lock,| of course
|当然，我们会担心，

1562
00:48:13,600 --> 00:48:15,580
0,150 150,780 1020,1380 1380,1680 1680,1980
we're worried,| after we release
|在我们在这一点解锁之后，

1563
00:48:15,580 --> 00:48:17,170
0,90 90,510 510,900 990,1350 1350,1590
the lock that at this

1564
00:48:17,170 --> 00:48:19,720
0,300 300,870 1140,2220 2220,2340 2340,2550
very point,| {wakeup -} might
|可能会调用 wakeup 并且唤醒该进程，

1565
00:48:19,720 --> 00:48:22,330
0,90 90,840 1140,1950 2160,2400 2400,2610
be called and might wake

1566
00:48:22,330 --> 00:48:23,680
0,120 120,300 300,990 1020,1290 1290,1350
up this process,| so in
|所以为了唤醒这个进程，

1567
00:48:23,680 --> 00:48:25,030
0,240 240,540 660,1080 1080,1260 1260,1350
order to might try to

1568
00:48:25,030 --> 00:48:25,930
0,150 150,240 240,390 390,780 780,900
wake up this process,| but
|不过，我们还没有标记为睡眠，

1569
00:48:25,930 --> 00:48:26,680
0,60 60,210 210,300 300,480 480,750
of course we haven't marked

1570
00:48:26,680 --> 00:48:28,450
0,390 390,630 810,1080 1080,1410 1560,1770
sleeping yet, right,| so we
|所以我们不能让 wakeup 执行。

1571
00:48:28,450 --> 00:48:30,430
0,480 480,1080 1260,1470 1470,1680 1680,1980
cannot afford to have {wakeup

1572
00:48:30,430 --> 00:48:31,880
0,330 360,1170
-} execute.|
|

1573
00:48:31,880 --> 00:48:33,100
0,660

1574
00:48:33,550 --> 00:48:35,740
0,660 720,1050 1050,1410 1410,1890 1920,2190
Oops.| Have wakeup execute, right,
糟糕。|让 wakeup 在这个 release 之后执行，即使我们已经释放。

1575
00:48:35,740 --> 00:48:37,750
0,210 210,420 420,1080 1650,1920 1920,2010
after this release, even though

1576
00:48:37,750 --> 00:48:38,740
0,150 150,510 510,690 690,750 750,990
we're releasing.| So in order
|所以为了避免这种情况发生，

1577
00:48:38,740 --> 00:48:39,850
0,390 420,690 690,840 840,1050 1050,1110
to cause that not to

1578
00:48:39,850 --> 00:48:41,920
0,480 480,1140 1140,1530 1530,1620 1620,2070
happen,| before releasing the condition
|在释放条件锁之前，

1579
00:48:41,920 --> 00:48:45,130
0,360 390,750 780,1920 2310,2610 2700,3210
lock,| sleep acquires the lock
|sleep 会获取将要睡眠的进程的锁。

1580
00:48:45,130 --> 00:48:46,270
0,180 180,300 300,750 750,900 900,1140
of the process that's going

1581
00:48:46,270 --> 00:48:47,440
0,90 90,750
to sleep.|
|

1582
00:48:47,470 --> 00:48:49,080
0,210 210,330 330,1050
If you recall,
如果你还记得， wakeup 必须在持有条件锁的情况下调用，

1583
00:48:51,190 --> 00:48:53,650
0,420 420,810 1050,1620 2070,2370 2370,2460
{wakeup -} {} must be

1584
00:48:53,650 --> 00:48:54,880
0,390 450,630 630,720 720,1050 1050,1230
called with the condition lock

1585
00:48:54,880 --> 00:48:57,160
0,480 480,990 1050,1290 1290,2130 2130,2280
held| and it acquires the,|
|并且它获取，|

1586
00:48:57,490 --> 00:48:58,660
0,180 180,360 450,810 810,930 930,1170
if it's about to {wakeup
如果要唤醒进程，

1587
00:48:58,660 --> 00:49:00,220
0,150 150,540 540,660 660,1110 1140,1560
-} process,| it first must
|它首先必须等待获取进程锁。

1588
00:49:00,220 --> 00:49:01,570
0,210 210,330 330,660 660,810 810,1350
wait to acquire that process's

1589
00:49:01,570 --> 00:49:02,620
0,480
lock.|
|

1590
00:49:02,710 --> 00:49:03,840
0,540

1591
00:49:04,400 --> 00:49:06,800
0,420 480,930 930,1050 1050,2040 2070,2400
So for the entire amount
所以在这段时间里，

1592
00:49:06,800 --> 00:49:08,120
0,60 60,510 510,900 900,1110 1110,1320
of time,| between when {uartwrite
|在 uartwrite 检查状态之前，

1593
00:49:08,120 --> 00:49:10,820
0,240 240,870 1260,1680 1680,2490 2490,2700
- -} between, before {uartwrite

1594
00:49:10,820 --> 00:49:12,890
0,180 180,510 510,1140 1200,1320 1320,2070
- -} checked the condition,|
|

1595
00:49:13,160 --> 00:49:15,140
0,810 1290,1470 1470,1620 1680,1890 1890,1980
{} when we when we
当我们在这里调用 sched 时，

1596
00:49:15,140 --> 00:49:17,360
0,240 240,600 600,1110 1440,1950 1950,2220
call sched here,| this thread
|这个线程始终持有条件锁和 p->lock 中的一个。

1597
00:49:17,360 --> 00:49:19,610
0,360 360,990 990,1230 1230,1860 2100,2250
holds one or another of

1598
00:49:19,610 --> 00:49:21,140
0,120 120,600 600,930 930,1050 1050,1530
the condition lock and {p->lock

1599
00:49:21,140 --> 00:49:23,100
0,390 390,540 540,690 690,1590
-} at all times.|
|

1600
00:49:23,910 --> 00:49:24,930
0,180 180,480 480,570 570,870 870,1020
I just go back to
我回到 uart ，想强调这一点，

1601
00:49:24,930 --> 00:49:26,940
0,270 270,870 1200,1380 1380,1440 1440,2010
{uart -}, want to emphasize

1602
00:49:26,940 --> 00:49:29,010
0,450 480,900 960,1560 1560,1770 1770,2070
this,| {} {uartwrite - -}
|uartwrite 在这里获取状态锁，

1603
00:49:29,010 --> 00:49:30,620
0,1080
acquires

1604
00:49:30,620 --> 00:49:32,810
0,90 90,630 630,960 960,1590 1890,2190
the condition lock here| and
|并将状态锁一直持有到它调用 sleep ，

1605
00:49:32,810 --> 00:49:34,280
0,540 540,630 630,1020 1020,1230 1230,1470
holds the condition lock all

1606
00:49:34,280 --> 00:49:35,120
0,90 90,240 240,540 540,630 630,840
the way through to where

1607
00:49:35,120 --> 00:49:36,860
0,60 60,390 390,1020 1410,1590 1590,1740
it calls sleep,| so it
|所以它获得状态锁，

1608
00:49:37,160 --> 00:49:38,870
0,330 330,390 390,720 720,1020 1410,1710
requires the condition lock,| checks
|在持有条件锁的情况下检查，

1609
00:49:38,870 --> 00:49:39,680
0,90 90,420 420,510 510,570 570,810
the condition with {} lock

1610
00:49:39,680 --> 00:49:41,630
0,510 660,990 990,1470 1650,1860 1860,1950
held,| call sleep with the
|在持有状态锁的情况下调用 sleep ，

1611
00:49:41,630 --> 00:49:43,610
0,360 360,570 570,1050 1290,1590 1590,1980
condition lock held,| so {wakeup
|所以 wakeup 现在什么都做不了，

1612
00:49:43,610 --> 00:49:44,300
0,240
-}

1613
00:49:44,450 --> 00:49:46,070
0,270 270,360 360,750 750,1140 1140,1620
can't do anything now,| because
|因为它甚至不允许调用 wakeup ，

1614
00:49:46,100 --> 00:49:47,150
0,30 180,540 540,750 750,900 900,1050
it can not even allowed

1615
00:49:47,150 --> 00:49:48,710
0,90 90,420 420,660 660,810 930,1560
to call {wakeup -},| until
|直到调用者拥有条件锁，

1616
00:49:48,890 --> 00:49:50,090
0,360 360,420 420,840 840,1110 1110,1200
until the caller owns the

1617
00:49:50,090 --> 00:49:51,440
0,360 360,600 600,780 780,1020 1020,1350
condition locks,| so wakeup definitely
|所以 wakeup 肯定不是现在执行，

1618
00:49:51,440 --> 00:49:54,110
0,210 210,660 660,1080 2100,2430 2430,2670
not executing now,| we still
|我们还持有锁，我们调用 sleep ，

1619
00:49:54,110 --> 00:49:54,950
0,180 180,270 270,510 510,630 630,840
hold the lock, we call

1620
00:49:54,950 --> 00:49:56,060
0,630
sleep,|
|

1621
00:49:57,110 --> 00:49:59,020
0,600 630,1410
{} sleep
sleep 释放了条件锁，

1622
00:49:59,050 --> 00:50:00,520
0,390 390,480 480,810 810,1110 1110,1470
releases the condition lock,| but
|但首先获取进程锁。

1623
00:50:00,610 --> 00:50:03,820
0,690 960,2010 2010,2130 2130,2670 2670,3210
first acquires the process's lock.|
|

1624
00:50:04,710 --> 00:50:05,940
0,660

1625
00:50:06,030 --> 00:50:08,160
0,390 390,510 510,630 630,1350 1500,2130
And if you remember,| oops,|
如果你还记得，|糟糕，|

1626
00:50:10,050 --> 00:50:11,670
0,360 360,600 600,1020 1230,1530 1530,1620
{} {wakeup -}, {wakeup -}
调用 wakeup 使用条件锁，

1627
00:50:11,670 --> 00:50:12,810
0,120 120,540 540,660 660,750 750,1140
is called with the condition

1628
00:50:12,810 --> 00:50:15,480
0,450 720,1350 1710,2160 2160,2310 2310,2670
lock,| {} after we release
|在我们释放它之后。

1629
00:50:15,480 --> 00:50:16,300
0,240
it.|
|

1630
00:50:16,530 --> 00:50:17,580
0,480
Sorry,
抱歉，在我们释放条件之后，

1631
00:50:17,580 --> 00:50:18,630
0,330 330,390 390,630 630,720 720,1050
after we release the condition

1632
00:50:18,630 --> 00:50:19,350
0,210 210,420 420,510 510,600 600,720
lock,| {wakeup -} can be
|wakeup 可以被调用，

1633
00:50:19,350 --> 00:50:21,450
0,540 570,990 990,1230 1230,1530 1590,2100
called,| but {wakeup -} won't
|但是 wakeup 不会看到这个进程，

1634
00:50:21,630 --> 00:50:22,770
0,270 270,330 330,420 420,870 870,1140
look at the process| until
|直到它拥有我们持有的进程锁。

1635
00:50:22,770 --> 00:50:23,970
0,90 90,300 300,390 390,810 810,1200
it has the process lock

1636
00:50:24,090 --> 00:50:24,870
0,180 180,240 240,510 510,630 630,780
which we hold.| So okay,
|好的，所以 wakeup 仍然没有被执行。

1637
00:50:24,870 --> 00:50:25,710
0,210 210,390 390,480 480,600 600,840
so {wakeup -} is still

1638
00:50:25,710 --> 00:50:28,320
0,210 210,870
not executing.|
|

1639
00:50:30,900 --> 00:50:32,940
0,630 1080,1320 1320,1410 1410,1770 1770,2040
{Acquire -} the process lock,
获取进程锁，释放条件锁，

1640
00:50:32,940 --> 00:50:34,710
0,270 270,330 330,690 690,1200 1230,1770
release the condition lock,| while
|在持有进程锁的同时，

1641
00:50:34,710 --> 00:50:36,180
0,330 330,450 450,870 870,1110 1110,1470
holding the process lock,| mark
|把进程标记为睡眠在这个信道上，

1642
00:50:36,180 --> 00:50:39,090
0,330 480,1230 1350,1620 1620,2430 2640,2910
the process as sleeping on

1643
00:50:39,090 --> 00:50:41,100
0,150 150,540 540,1140 1500,1800 1800,2010
this particular channel| and then
|然后调用 sched ，它会调用 swtch ，

1644
00:50:41,100 --> 00:50:42,990
0,270 270,660 660,870 870,1140 1140,1890
calls sched, which calls swtch

1645
00:50:43,230 --> 00:50:43,950
0,240 270,390 390,570 570,660 660,720
right,| we still have the
|我们仍然持有进程锁，所以 wakeup 没有做任何事情，

1646
00:50:43,950 --> 00:50:45,360
0,390 390,660 660,750 750,1080 1140,1410
process lock, so wakeup still

1647
00:50:45,360 --> 00:50:47,190
0,210 210,420 420,990 1200,1740 1740,1830
isn't doing anything,| and if
|如果你还记得，

1648
00:50:47,190 --> 00:50:49,320
0,120 120,510 510,930 1200,1440 1440,2130
you remember,| the {you,know} switching
|从这个线程切换到调度程序线程，

1649
00:50:49,470 --> 00:50:51,300
0,300 300,450 450,1290 1290,1740 1740,1830
away from this thread to

1650
00:50:51,300 --> 00:50:52,860
0,90 90,510 510,960 1200,1500 1500,1560
the scheduler thread| and the
|调度器例程在调用 swtch 返回后，

1651
00:50:52,860 --> 00:50:54,120
0,360 360,450 450,810 810,1140 1140,1260
scheduler {} routine after it's

1652
00:50:54,120 --> 00:50:56,520
0,210 210,300 300,600 600,1200 1260,2400
called the swtch returns,| releases
|释放最近运行的进程锁。

1653
00:50:56,760 --> 00:50:59,580
0,450 540,1080 1080,1530 1560,2340 2340,2820
{} recently running process's lock.|
|

1654
00:50:59,920 --> 00:51:02,050
0,360 390,690 690,960 960,1500 1740,2130
So at this point, after
所以，在这里，在调度器中时，

1655
00:51:02,050 --> 00:51:03,760
0,210 210,480 480,540 540,1200 1230,1710
we're in the scheduler,| wakeup
|wakeup 可以获取这个进程的 p->lock ，

1656
00:51:03,760 --> 00:51:06,250
0,150 150,570 570,1560 1740,2190 2190,2490
can finally acquire {p->lock -}

1657
00:51:06,250 --> 00:51:08,710
0,90 90,300 300,1110 1350,2310 2310,2460
for this process,| notice that
|注意到它睡眠在这个信道上，

1658
00:51:08,710 --> 00:51:10,040
0,120 120,810
it's sleeping

1659
00:51:10,040 --> 00:51:12,350
0,600 630,1440 1440,1620 1620,2130 2130,2310
and on this channel| and
|并将它的状态设置为唤醒。

1660
00:51:12,350 --> 00:51:13,340
0,240 240,360 360,630 630,720 720,990
set its state to {wakeup

1661
00:51:13,340 --> 00:51:14,080
0,330
-}.|
|

1662
00:51:14,110 --> 00:51:16,060
0,240 240,360 360,840 840,1020 1200,1950
So we guaranteed the effect
所以我们保证了规则的效果，

1663
00:51:16,060 --> 00:51:17,920
0,600 870,1320 1350,1650 1650,1740 1740,1860
of the rule| that you
|当你调用 sleep 时，必须持有条件锁，

1664
00:51:17,920 --> 00:51:18,760
0,150 150,240 240,390 390,480 480,840
have to hold the condition

1665
00:51:18,760 --> 00:51:20,560
0,210 210,330 330,690 690,1560 1620,1800
lock when calling sleep, {}|
|

1666
00:51:20,560 --> 00:51:21,430
0,120 120,300 300,390 390,630 630,870
the fact that sleep knows
sleep 知道这个锁，

1667
00:51:21,430 --> 00:51:22,600
0,240 240,420 420,660 660,810 810,1170
about that lock| and release
|并且只有在获取 p->lock 之后才释放它，

1668
00:51:22,600 --> 00:51:24,580
0,180 270,630 630,930 930,1410 1410,1980
it only after requiring process

1669
00:51:24,610 --> 00:51:26,620
0,390 390,930 1110,1530 1530,1800 1800,2010
{p->lock -}| and {wakeup -}
|而 wakeup 需要持有这两个锁，

1670
00:51:27,120 --> 00:51:28,680
0,240 240,330 330,540 540,840 840,1560
needing to hold both locks|
|

1671
00:51:29,010 --> 00:51:29,820
0,150 150,390 390,480 480,600 600,810
in order to [think about]
为了[考虑]这个进程，

1672
00:51:29,820 --> 00:51:31,530
0,150 150,660 870,1230 1230,1470 1500,1710
this process| means that we
|意味着我们不会再失去一个 wakeup ，

1673
00:51:31,530 --> 00:51:33,270
0,150 150,390 390,930 960,1650 1650,1740
can no longer lose a

1674
00:51:33,270 --> 00:51:35,130
0,240 240,630 870,1380 1500,1740 1740,1860
{wakeup -},| {} so we
|所以我们解决了丢失唤醒的问题。

1675
00:51:35,130 --> 00:51:36,720
0,420 420,600 600,870 870,1200 1200,1590
fix this lost wakeup problem.|
|

1676
00:51:39,050 --> 00:51:39,950
0,150 150,450 450,540 540,750 750,900
I realized a little bit
我意识到有些[关联]，

1677
00:51:39,950 --> 00:51:42,440
0,750 1380,1620 1620,2100 2100,2280 2280,2490
involved,| any questions about what's
|对于这里的事情，有什么问题吗？

1678
00:51:42,440 --> 00:51:43,700
0,210 210,360 360,660
going on here?|
|

1679
00:52:02,910 --> 00:52:04,770
0,360 360,660 1020,1410 1410,1620 1620,1860
Alright, well, feel free to
好的，请随时提问。

1680
00:52:04,770 --> 00:52:06,660
0,780 1020,1320 1320,1650 1650,1740 1740,1890
{} ask questions at any

1681
00:52:06,660 --> 00:52:08,380
0,1230
time.|
|

1682
00:52:09,480 --> 00:52:11,250
0,330 330,480 480,690 690,840 840,1770
Alright, so we saw one,
好的，我们看到这个案例

1683
00:52:11,280 --> 00:52:13,080
0,150 150,270 270,480 480,1170 1470,1800
we saw this one {},

1684
00:52:13,080 --> 00:52:14,100
0,210 210,270 270,390 390,660 660,1020
look at this one case,|
|

1685
00:52:14,100 --> 00:52:15,280
0,60 60,270 270,540
in which were
其中使用 sleep 和 wakeup ，并避免了丢失唤醒，

1686
00:52:15,430 --> 00:52:17,140
0,600 630,930 930,1380 1380,1500 1500,1710
{} using sleep and {wakeup

1687
00:52:17,140 --> 00:52:18,400
0,210 720,990 990,1080 1080,1140 1140,1260
-} {} in a way

1688
00:52:18,400 --> 00:52:19,810
0,120 120,600 600,870 870,1050 1050,1410
that avoids lost {wakeups -},|
|

1689
00:52:20,140 --> 00:52:21,730
0,450 450,900 900,1350 1350,1530 1530,1590
{} there's a bunch of
在 xv6 中还有很多其他的版本，

1690
00:52:21,730 --> 00:52:23,140
0,330 330,420 420,630 630,750 750,1410
others in {xv6 - -},|
|

1691
00:52:23,200 --> 00:52:24,760
0,210 210,360 360,840 840,1350 1380,1560
{} this particular one, the
特别是，我们在等待的条件，

1692
00:52:24,760 --> 00:52:25,900
0,360 360,480 480,660 660,960 960,1140
thing that we're waiting for

1693
00:52:25,900 --> 00:52:27,130
0,120 120,630 630,780 780,900 900,1230
the condition that we're waiting

1694
00:52:27,130 --> 00:52:29,650
0,450 900,1110 1110,1320 1320,1710 1800,2520
for,| {you,know} is that interrupt
|是发生中断，

1695
00:52:29,650 --> 00:52:30,970
0,120 120,570 570,690 690,810 810,1320
has occurred,| that has signalled
|表明硬件已经准备好做下一件事，

1696
00:52:30,970 --> 00:52:32,470
0,150 180,630 630,750 750,1140 1140,1500
that hardware is ready to

1697
00:52:33,310 --> 00:52:36,100
0,300 300,360 360,660 660,1050 2370,2790
do the next thing,| there's
|也有一些时候内核代码调用 sleep

1698
00:52:36,100 --> 00:52:38,320
0,510 570,990 990,1320 1320,1830
also times when {}

1699
00:52:38,760 --> 00:52:40,500
0,540 540,780 780,1080 1080,1500 1530,1740
kernel code calls sleep| in
|为了等待其他的线程做一些事情，

1700
00:52:40,500 --> 00:52:41,130
0,180 180,270 270,450 450,540 540,630
order to wait for a

1701
00:52:41,130 --> 00:52:42,210
0,210 210,390 390,630 630,990 990,1080
diff some other thread to

1702
00:52:42,210 --> 00:52:43,680
0,150 150,720 900,1170 1170,1260 1260,1470
do something,| which is not
|在概念上并没有什么不同，

1703
00:52:43,680 --> 00:52:44,940
0,360 360,450 450,540 540,720 720,1260
actually in the end conceptually

1704
00:52:44,940 --> 00:52:46,590
0,390 390,600 930,1290 1290,1440 1440,1650
different,| but {} may feel
|但可能感觉有点不同，

1705
00:52:46,590 --> 00:52:47,520
0,30 30,180 180,300 300,600 600,930
a little bit different,| so
|例如，在管道代码中，

1706
00:52:48,180 --> 00:52:49,140
0,240 240,300 300,390 390,660 660,960
{} in the pipe code,

1707
00:52:49,140 --> 00:52:50,300
0,90 90,660
for example,|
|

1708
00:52:50,680 --> 00:52:51,250
0,210 210,300 300,390 390,480 480,570
{} if you look at
如果你查看 piperead ，

1709
00:52:51,250 --> 00:52:52,640
0,330 330,780
{piperead -},|
|

1710
00:52:56,210 --> 00:52:58,370
0,600 1140,1770 1770,1920 1920,2070 2070,2160
{ - -} there's a
这里有一堆东西，你可以忽略，

1711
00:52:58,370 --> 00:52:59,480
0,180 180,240 240,540 540,810 810,1110
bunch of junk here which

1712
00:52:59,480 --> 00:53:00,830
0,270 270,420 420,540 540,1020 1020,1350
you have to ignore,| but
|但是管道中的的读系统调用，最终调用 piperead ，

1713
00:53:00,950 --> 00:53:02,120
0,570
{}

1714
00:53:02,520 --> 00:53:03,810
0,420 450,780 780,1020 1020,1200 1200,1290
the read system call on

1715
00:53:03,810 --> 00:53:04,770
0,60 60,420 420,600 600,690 690,960
the pipe, ends up calling

1716
00:53:04,770 --> 00:53:06,690
0,300 300,690 840,1140 1140,1200 1200,1920
{piperead -},| there's a lock
|这里有一把锁保护管道，

1717
00:53:07,080 --> 00:53:08,670
0,300 300,690 690,780 780,1440 1470,1590
that protects the pipe| and
|而这就是条件锁，

1718
00:53:08,670 --> 00:53:09,630
0,120 120,330 540,690 690,750 750,960
this is going to end

1719
00:53:09,630 --> 00:53:12,040
0,210 210,750 990,1950
up being {}

1720
00:53:12,440 --> 00:53:14,810
0,120 120,540 540,1050 1440,2160 2160,2370
the condition lock,| {pipereed -}
|piperead 需要等待，直到有数据缓冲在管道中，

1721
00:53:14,810 --> 00:53:16,040
0,270 270,420 420,780 780,1050 1050,1230
needs to wait until there's

1722
00:53:16,040 --> 00:53:17,810
0,420 570,1230 1260,1590 1590,1680 1680,1770
actually data buffered in the

1723
00:53:17,810 --> 00:53:20,540
0,570 720,1290 1290,1590 1650,2130 2130,2730
pipe,| {} and that condition
|那个条件是数据就绪，

1724
00:53:20,540 --> 00:53:22,940
0,540 1200,1500 1500,1710 1710,2010 2010,2400
is that there's data ready,|
|

1725
00:53:22,940 --> 00:53:25,100
0,420 450,720 720,1290 1530,1830 1830,2160
is {nread -} {or,nwrite -}
是 nwrite 大于 nread ，

1726
00:53:25,100 --> 00:53:26,390
0,180 180,630 630,780 780,1020 1020,1290
is greater than {nread -}|
|

1727
00:53:26,390 --> 00:53:27,260
0,180 180,360 360,570 570,780 780,870
that is more bytes have
也就是写入的字节多于读取的字节，

1728
00:53:27,260 --> 00:53:29,210
0,150 150,480 480,630 630,1080 1410,1950
been written than read,| while
|当这不是真的， piperead 在 sleep 上，等待那种条件，

1729
00:53:29,210 --> 00:53:31,180
0,330 330,810 810,1470
that's not true,

1730
00:53:31,580 --> 00:53:33,560
0,690 690,900 900,1200 1200,1320 1320,1980
{piperead -} sits in sleep,

1731
00:53:34,180 --> 00:53:36,010
0,480 720,990 990,1110 1110,1260 1260,1830
{} waiting for that condition,|
|

1732
00:53:36,100 --> 00:53:39,400
0,630 900,1830 1830,2160 2160,2790 2970,3300
and passes in this pipe
然后传入这个管道锁，

1733
00:53:39,400 --> 00:53:40,840
0,510 570,720 720,1140 1140,1350 1350,1440
lock,| the condition lock that
|条件锁到 sleep 中，

1734
00:53:40,840 --> 00:53:42,790
0,330 330,420 420,810 810,990 990,1950
protects the condition into sleep,|
|

1735
00:53:44,150 --> 00:53:45,320
0,210 210,510 510,630 630,900 900,1170
in order to protect against
为了防止丢失唤醒。

1736
00:53:45,320 --> 00:53:46,160
0,270 270,480 480,630 630,750 750,840
lost {wakeup -}.| So the
|所以你可能丢失唤醒的原因是，

1737
00:53:46,160 --> 00:53:46,910
0,240 240,360 360,450 450,600 600,750
reason why you might get

1738
00:53:46,910 --> 00:53:47,960
0,300 300,510 510,690 690,840 840,1050
lost {wakeup -} is| that
|在不同的核心上，

1739
00:53:47,990 --> 00:53:50,100
0,390 390,480 480,810 810,1530
on a different core,|
|

1740
00:53:50,580 --> 00:53:52,290
0,450 930,1230 1230,1530 1530,1650 1650,1710
a little farther up in
在文件的上面一点，

1741
00:53:52,290 --> 00:53:53,160
0,90 90,420 420,540 540,600 600,870
the file,| on a different
|在另一个核心上，

1742
00:53:53,160 --> 00:53:54,810
0,480 570,840 840,1170 1170,1410 1410,1650
core,| there's probably some other
|可能有其他线程，刚刚调用了 pipewrite ，

1743
00:53:54,810 --> 00:53:57,270
0,690 780,1380 1410,1860 1860,2040 2040,2460
thread, {} just now calling

1744
00:53:57,270 --> 00:53:59,040
0,390 390,900 1260,1440 1440,1560 1560,1770
{pipewrite -}| and it's gonna
|它会将字节添加到管道缓冲区，

1745
00:53:59,040 --> 00:54:00,320
0,750
add

1746
00:54:00,380 --> 00:54:02,510
0,510 1020,1530 1530,1620 1620,1800 1800,2130
{} byte to the pipe

1747
00:54:02,510 --> 00:54:03,800
0,300 300,450 450,720 720,1020 1020,1290
buffer,| and finally {call,the} {wakeup
|最后在 piperead 等待的信道上调用 wakeup ，

1748
00:54:03,800 --> 00:54:06,420
0,450 570,1350 1350,1620 1620,2070
-} on the {}

1749
00:54:06,480 --> 00:54:08,760
0,540 540,720 870,1170 1170,1470 1500,2280
channel, that {piperead -} waiting

1750
00:54:08,760 --> 00:54:11,250
0,330 570,930 1170,1500 1500,1890 2340,2490
for| and you know we
|我们想要避免读取者检查的风险，

1751
00:54:11,250 --> 00:54:12,420
0,120 120,180 180,570 570,690 690,1170
want to avoid the risk

1752
00:54:12,420 --> 00:54:14,580
0,180 180,990 990,1140 1140,1440 1440,2160
that between the reader checking,|
|

1753
00:54:15,180 --> 00:54:17,310
0,240 240,630 1200,1860 1860,2010 2010,2130
{} there's, noticing there's no
注意到这里没有字节可读，并且调用 sleep ，

1754
00:54:17,310 --> 00:54:19,140
0,330 330,450 450,960 1080,1500 1500,1830
bytes to read and calling

1755
00:54:19,140 --> 00:54:20,790
0,600 630,990 990,1140 1140,1410 1410,1650
sleep,| we do not want
|我们不想让另一个核心上的 pipewrite 在这里睡眠，

1756
00:54:20,790 --> 00:54:22,470
0,390 630,1050 1050,1320 1320,1440 1440,1680
to {pipewrite -} on another

1757
00:54:22,470 --> 00:54:23,700
0,240 240,300 300,660 660,840 840,1230
core to sleep in there,|
|

1758
00:54:25,220 --> 00:54:27,260
0,270 270,510 510,900 900,1500 1830,2040
and add bytes and wake
增加字节，唤醒我们，在我们进入睡眠之前，

1759
00:54:27,260 --> 00:54:28,130
0,150 150,270 270,570 570,720 720,870
us up, before we've even

1760
00:54:28,130 --> 00:54:29,300
0,150 150,240 240,780 900,1020 1020,1170
gone to sleep, {right -},|
|

1761
00:54:29,300 --> 00:54:30,050
0,120 120,180 180,240 240,540 540,750
would be a lost {wakeup
会是一次丢失的唤醒。

1762
00:54:30,050 --> 00:54:30,880
0,300
-}.|
|

1763
00:54:31,600 --> 00:54:33,730
0,450 480,690 690,1260 1260,1920 1950,2130
And this lock basically this
这把锁，

1764
00:54:33,730 --> 00:54:34,630
0,330 330,420 420,480 480,720 720,900
lock| and the fact that
|sleep 很小心地释放它，

1765
00:54:35,380 --> 00:54:36,760
0,390 390,480 480,780 780,1020 1020,1380
sleep is careful about releasing

1766
00:54:36,760 --> 00:54:38,540
0,270
it,|
|

1767
00:54:38,540 --> 00:54:40,970
0,750 810,990 990,1440 1440,1920 1950,2430
prevent a writer from sleeping
防止写入者睡眠，

1768
00:54:40,970 --> 00:54:42,080
0,390 450,720 720,810 810,1050 1050,1110
in,| between the check of
|在检查条件和睡眠之间，

1769
00:54:42,080 --> 00:54:43,220
0,90 90,510 510,600 600,690 690,1140
the condition and the sleep,|
|

1770
00:54:43,280 --> 00:54:44,060
0,180 180,270 270,540 540,690 690,780
because the writer has to
因为写入者也必须获得锁。

1771
00:54:44,060 --> 00:54:45,540
0,300 300,390 390,720 720,930
acquire the lock too.|
|

1772
00:54:48,670 --> 00:54:50,050
0,390 390,840 960,1080 1080,1290 1290,1380
And {} for those of
对于你们来说，

1773
00:54:50,050 --> 00:54:52,460
0,150 150,210 210,1050 1080,1650
you {} are, {}|
|

1774
00:54:53,610 --> 00:54:55,710
0,150 150,450 450,720 720,1170 1530,2100
the people asked about wrapping
有人问到关于包裹 sleep 和 while 循环的问题，

1775
00:54:55,710 --> 00:54:58,170
0,450 450,570 570,870 870,1350 1590,2460
sleep and while loops,| both
|pipereed 和 pipewrite 都是在一段时间内睡眠的例子，

1776
00:54:58,170 --> 00:54:59,670
0,330 330,600 600,840 840,1230 1230,1500
{pipereed -} and {pipewrite -}

1777
00:54:59,670 --> 00:55:01,530
0,150 150,780 780,1020 1020,1470 1470,1860
are examples of {} sleep

1778
00:55:01,560 --> 00:55:03,540
0,390 390,450 450,540 540,1110 1770,1980
wrapped in a while,| so
|比如，这是 piperead 等待数据出现的循环，

1779
00:55:03,540 --> 00:55:04,880
0,90 90,450 450,750
for example the,

1780
00:55:05,050 --> 00:55:06,310
0,390 420,630 630,720 720,870 870,1260
{} this is the loop

1781
00:55:06,310 --> 00:55:08,260
0,270 570,900 900,1380 1380,1800 1800,1950
that {piperead -} waits for

1782
00:55:08,260 --> 00:55:09,580
0,330 330,480 480,960 960,1200 1200,1320
data to appear,| waits for
|等待管道缓冲器为非空，

1783
00:55:09,580 --> 00:55:10,510
0,60 60,330 330,570 570,870 870,930
the buff pipe buffer to

1784
00:55:10,510 --> 00:55:12,280
0,90 90,360 360,810 1260,1590 1590,1770
be non empty,| {} and
|这个 sleep 被包裹在一个循环中，

1785
00:55:12,280 --> 00:55:13,120
0,60 60,330 330,450 450,780 780,840
the sleep is wrapped in

1786
00:55:13,120 --> 00:55:14,820
0,90 90,510 600,780 780,1170
a loop| and again
|再说一次，原因是，

1787
00:55:15,120 --> 00:55:16,380
0,210 210,480 480,690 690,900 1020,1260
the reason is that,| there
|完全可以有多个进程读取相同的管道，

1788
00:55:16,380 --> 00:55:17,580
0,150 150,270 270,750 750,1050 1050,1200
could be perfectly well be

1789
00:55:17,580 --> 00:55:19,860
0,660 660,1470 1470,1890 1890,2010 2010,2280
multiple processes reading the very

1790
00:55:19,860 --> 00:55:21,510
0,360 360,930 1260,1470 1470,1560 1560,1650
same pipe| and so if
|所以，如果写入着向管道写入一个字节，

1791
00:55:21,510 --> 00:55:23,070
0,120 120,450 450,780 780,1260 1260,1560
a writer writes one byte

1792
00:55:23,070 --> 00:55:24,930
0,90 90,180 180,900 1350,1740 1740,1860
to the pipe,| {} so
|那里只有一个字节，

1793
00:55:24,930 --> 00:55:26,130
0,150 150,300 300,540 540,840 840,1200
there's only one byte there,|
|

1794
00:55:26,190 --> 00:55:27,150
0,240 240,540 540,660 660,720 720,960
the writer's going to call
写入者会调用 wakeup ，

1795
00:55:27,150 --> 00:55:28,160
0,270 270,510
{wakeup -},|
|

1796
00:55:28,660 --> 00:55:29,740
0,180 180,450 450,630 630,840 840,1080
{} that's gonna {wakeup -}
这将唤醒所有正在读取该管道的多个进程，

1797
00:55:29,890 --> 00:55:31,690
0,390 390,570 600,1110 1110,1710 1710,1800
all the multiple processes that

1798
00:55:31,690 --> 00:55:33,670
0,180 180,540 540,840 840,1620 1650,1980
were reading that pipe,| but
|但是管道中只有一个字节，

1799
00:55:33,670 --> 00:55:34,540
0,150 150,300 300,540 540,780 780,870
there's only one byte in

1800
00:55:34,540 --> 00:55:37,000
0,90 90,690 960,1740 2070,2310 2310,2460
the pipe,| {} and so
|所以其中一个进程会首先被唤醒，

1801
00:55:37,000 --> 00:55:38,380
0,390 390,450 450,660 660,1260 1260,1380
one of those processes going

1802
00:55:38,380 --> 00:55:40,420
0,60 60,270 270,480 480,1320 1620,2040
to {wakeup -} first, right,|
|

1803
00:55:40,480 --> 00:55:41,620
0,510 600,780 780,840 840,990 990,1140
it's going to come out
它会首先从睡眠中醒来。

1804
00:55:41,620 --> 00:55:43,690
0,60 60,180 180,570 570,1260 1380,2070
of its sleep first.| Actually,
|这提醒了我，

1805
00:55:43,690 --> 00:55:44,890
0,180 180,510 510,600 600,840 840,1200
this reminds me,| there's another
|关于 sleep ，还有一件重要的事情我忘了说，

1806
00:55:45,040 --> 00:55:46,120
0,360 360,570 570,660 660,1020 1020,1080
crucial thing I forgot to

1807
00:55:46,120 --> 00:55:47,600
0,330 330,540 540,1050
mention about sleep,|
|

1808
00:55:47,890 --> 00:55:49,080
0,660

1809
00:55:49,170 --> 00:55:50,760
0,180 180,510 510,810 990,1230 1230,1590
and that's that the last
这是 sleep 做的最后一件事，

1810
00:55:50,760 --> 00:55:52,230
0,240 240,630 630,1080 1080,1290 1290,1470
thing sleep does,| let's look
|我们来看一下，

1811
00:55:52,230 --> 00:55:53,440
0,180 180,540
at, {}|
|

1812
00:55:55,980 --> 00:55:57,920
0,420 420,750 750,990 990,1350
here's, here's the, {},|
这里是，|

1813
00:55:57,920 --> 00:55:59,300
0,480 630,1110 1110,1170 1170,1290 1290,1380
sorry,| here's the end of
抱歉，|这里是 sleep 的结尾，

1814
00:55:59,300 --> 00:56:00,950
0,480 600,840 840,1140 1140,1320 1320,1650
sleep,| the last thing sleep
|sleep 做的最后一件事是获取条件锁，

1815
00:56:00,950 --> 00:56:03,140
0,540 540,960 960,1620 1620,1740 1740,2190
does is acquires the condition

1816
00:56:03,140 --> 00:56:05,210
0,510 750,990 990,1260 1560,1860 1860,2070
lock,| so you must call
|所以，你必须在持有条件锁的情况下调用 sleep ，

1817
00:56:05,210 --> 00:56:06,170
0,270 270,360 360,450 450,780 780,960
sleep with the condition lock

1818
00:56:06,170 --> 00:56:08,120
0,540 750,930 930,1200 1200,1860 1860,1950
held| and sleep re-acquires it
|sleep 在返回之前重新获取它。

1819
00:56:08,120 --> 00:56:09,920
0,330 330,420 420,1320
before it returns.|
|

1820
00:56:10,850 --> 00:56:13,940
0,840 1260,1590 1590,1980 2430,2910 2910,3090
{} Okay, so what that
好的，这意味着，

1821
00:56:13,940 --> 00:56:14,870
0,270 270,390 390,570 570,810 810,930
means is that,| if there
|如果有一群读者，

1822
00:56:14,870 --> 00:56:15,800
0,90 90,150 150,330 330,480 480,930
were a bunch of readers,|
|

1823
00:56:15,800 --> 00:56:16,850
0,180 180,420 420,720 720,900 900,1050
there's one byte written to
有一个字节被写入管道，

1824
00:56:16,850 --> 00:56:17,750
0,240 240,420 420,540 540,630 630,900
just return to a pipe|
|

1825
00:56:17,750 --> 00:56:18,650
0,90 90,120 120,330 330,450 450,900
and a bunch of readers
有一群读者被唤醒，

1826
00:56:18,650 --> 00:56:20,180
0,120 120,300 300,600 600,900 900,1530
that all woken up,| one
|其中一个会成功，

1827
00:56:20,180 --> 00:56:22,460
0,180 180,780 870,1110 1110,1920 2040,2280
of them will succeed,| one
|其中一个线程成功获取这个锁，

1828
00:56:22,460 --> 00:56:24,170
0,90 90,450 690,1380 1380,1500 1500,1710
of the sleep, so one

1829
00:56:24,170 --> 00:56:25,310
0,90 90,180 180,570 570,660 660,1140
of the threads will succeed

1830
00:56:25,310 --> 00:56:27,000
0,90 90,540 540,720 720,1200
in acquiring this lock,|
|

1831
00:56:27,000 --> 00:56:27,810
0,150 150,300 300,510 510,630 630,810
{} the others will be
其他线程会等待并睡眠，旋转等待锁，

1832
00:56:27,810 --> 00:56:29,460
0,330 330,480 480,840 960,1410 1410,1650
waiting and sleep, spinning waiting

1833
00:56:29,460 --> 00:56:30,900
0,90 90,180 180,540 810,1200 1200,1440
for the lock,| that one
|一个幸运的睡眠进程将会返回，

1834
00:56:30,900 --> 00:56:33,600
0,300 300,1110 1350,2040 2040,2160 2160,2700
lucky process sleep will return,|
|

1835
00:56:33,600 --> 00:56:34,140
0,60 60,150 150,270 270,480 480,540
it will come back to
它会回到这个检查上，

1836
00:56:34,140 --> 00:56:35,910
0,150 150,420 420,510 510,840 1260,1770
this check| and {you,know} {p->nwrite
|p->nwrite 比 nread 大 1 ，

1837
00:56:35,910 --> 00:56:37,140
0,150 150,390 390,510 510,840 840,1230
- -} is one larger

1838
00:56:37,140 --> 00:56:38,490
0,120 120,390 390,900 1020,1230 1230,1350
than {nread -},| so its
|所以有数据可读，

1839
00:56:38,490 --> 00:56:39,630
0,360 360,690 690,750 750,840 840,1140
data {to,read},| it will fall
|它会跳出循环，

1840
00:56:39,630 --> 00:56:40,320
0,120 120,180 180,270 270,510 510,690
out of the loop,| will
|将读取一个字节，

1841
00:56:40,320 --> 00:56:41,700
0,240 240,300 300,540 540,1050 1200,1380
read the one byte| and
|现在缓冲区里什么都没有了，

1842
00:56:41,700 --> 00:56:42,360
0,120 120,270 270,510 510,570 570,660
now there's nothing in the

1843
00:56:42,360 --> 00:56:44,820
0,480 660,1320 1320,1440 1440,2010
buffer,| release the lock,
|释放锁，然后返回，

1844
00:56:44,820 --> 00:56:46,170
0,120 120,720 780,1050 1050,1230 1230,1350
and return,| and now the
|现在下一个线程被唤醒，

1845
00:56:46,170 --> 00:56:47,820
0,480 480,990 990,1140 1140,1320 1320,1650
next thread that was woken

1846
00:56:47,820 --> 00:56:48,660
0,360
up,|
|

1847
00:56:48,660 --> 00:56:50,550
0,540 840,1200 1200,1680 1680,1800 1800,1890
{} it's sleep will be
它的 sleep 能够重新获得状态锁，

1848
00:56:50,550 --> 00:56:51,810
0,150 150,270 270,750 750,840 840,1260
able to re-acquire the condition

1849
00:56:51,810 --> 00:56:53,730
0,600 780,960 960,1200 1200,1320 1320,1920
lock,| it's sleep will return,
|它的 sleep 将返回，重新检查循环条件，

1850
00:56:53,850 --> 00:56:55,280
0,210 210,300 300,840
it will return,

1851
00:56:55,280 --> 00:56:57,350
0,450 480,1350 1380,1530 1530,1740 1740,2070
{} recheck the loop condition,|
|

1852
00:56:57,350 --> 00:56:59,720
0,180 180,960 1230,1890 1920,2160 2160,2370
but now {} {nread -}
但是现在 nread 等于 nwrite ，

1853
00:56:59,720 --> 00:57:00,860
0,150 150,360 360,480 480,660 660,1140
is equal to {nwrite -},|
|

1854
00:57:01,040 --> 00:57:02,330
0,270 270,450 450,720 720,1140 1140,1290
and so that thread and
所以这个线程和任何其他等待的线程将返回睡眠状态。

1855
00:57:02,330 --> 00:57:03,830
0,240 240,450 450,780 780,1200 1260,1500
any other thread waiting will

1856
00:57:03,830 --> 00:57:05,360
0,60 60,300 300,390 390,870 1050,1530
go back to sleep.| This
|这里再次强调，

1857
00:57:05,360 --> 00:57:07,010
0,390 510,840 840,990 990,1080 1080,1650
is again just to reinforce,|
|

1858
00:57:07,010 --> 00:57:09,740
0,510 1560,1950 1950,2190 2190,2490 2490,2730
why almost every, maybe every
为什么几乎每次调用 sleep ，

1859
00:57:09,740 --> 00:57:10,940
0,180 180,270 270,720 750,1110 1110,1200
call to sleep| has to
|都必须包裹在一个重新检查条件的循环中。

1860
00:57:10,940 --> 00:57:11,870
0,150 150,510 510,570 570,630 630,930
be wrapped in a loop

1861
00:57:11,870 --> 00:57:13,190
0,150 180,360 360,780 780,870 870,1320
that {re-checks -} the condition.|
|

1862
00:57:14,620 --> 00:57:15,760
0,630

1863
00:57:18,360 --> 00:57:20,610
0,600 600,930 1320,1440 1440,1560 1560,2250
Questions about the way sleep,
关于管道使用 sleep ，有什么问题吗？

1864
00:57:20,640 --> 00:57:22,960
0,870 870,1050 1050,1710
pipes use sleep?|
|

1865
00:57:33,670 --> 00:57:35,440
0,660 690,1140
Alright, {}
好的， sleep wakeup 接口规则有点复杂。

1866
00:57:35,650 --> 00:57:37,300
0,240 240,390 390,810 810,1170 1170,1650
{} the {sleep,and} wakeup interface

1867
00:57:37,300 --> 00:57:38,860
0,330 330,930 930,1290 1290,1470 1470,1560
rules are a little bit

1868
00:57:38,860 --> 00:57:40,900
0,870 900,1440
complex. {}|
|

1869
00:57:41,420 --> 00:57:42,740
0,360 360,420 420,510 510,780 780,1320
Because you have to reveal
因为你需要透露睡眠时在等待什么，

1870
00:57:42,740 --> 00:57:43,880
0,60 60,300 300,360 360,720 720,1140
a bit to sleep about

1871
00:57:44,030 --> 00:57:44,870
0,150 150,330 330,420 420,690 690,840
{} what you're waiting for,|
|

1872
00:57:44,870 --> 00:57:45,530
0,60 60,150 150,240 240,540 540,660
you have to tell the
你必须告诉锁，并遵守一些规则，

1873
00:57:45,530 --> 00:57:47,000
0,360 360,450 450,660 660,870 870,1470
lock and follow some rules,|
|

1874
00:57:48,500 --> 00:57:50,990
0,150 150,510 810,1290 1290,1860 2130,2490
which is sometimes annoying.| On
这有时是令人讨厌的。|另一方面， sleep 和 wakeup 是相当灵活的，

1875
00:57:50,990 --> 00:57:51,680
0,90 90,210 210,360 360,600 600,690
the other hand, sleep and

1876
00:57:51,680 --> 00:57:53,480
0,210 210,570 570,810 810,1410 1410,1800
{wakeup -} pretty flexible,| partially,
|部分原因是，它们不需要真正理解条件本身，

1877
00:57:53,480 --> 00:57:54,620
0,210 210,300 300,570 630,990 990,1140
because they don't actually have

1878
00:57:54,620 --> 00:57:56,450
0,60 60,720 720,780 780,1200 1200,1830
to understand the condition itself,|
|

1879
00:57:56,630 --> 00:57:57,410
0,210 210,330 330,480 480,570 570,780
that just has to be
只需要一个条件，一个锁，

1880
00:57:57,410 --> 00:57:58,490
0,90 90,600 600,840 840,990 990,1080
a condition and be a

1881
00:57:58,490 --> 00:58:00,470
0,540 780,1230 1350,1740 1740,1800 1800,1980
lock,| {} there are other
|还有其他一些级别稍高的方案，

1882
00:58:00,470 --> 00:58:02,600
0,660 660,810 810,1110 1530,1830 1830,2130
schemes that are somewhat higher

1883
00:58:02,600 --> 00:58:04,640
0,510 690,900 900,1080 1080,1770 1770,2040
level,| there's other coordination seems
|还有其他的协调，比如 semaphore ，

1884
00:58:04,640 --> 00:58:05,750
0,180 180,330 330,840 840,960 960,1110
like the semaphore,| you read
|你从今天的阅读材料中读到的，

1885
00:58:05,750 --> 00:58:07,220
0,420 420,720 810,1020 1020,1170 1170,1470
about in {} the reading

1886
00:58:07,220 --> 00:58:08,690
0,90 90,540 780,1050 1050,1350 1350,1470
for today,| in which the
|其中接口不是那么复杂，

1887
00:58:08,690 --> 00:58:11,030
0,540 540,840 870,1440 1440,1680 1680,2340
interface is slightly less complex,|
|

1888
00:58:11,030 --> 00:58:11,900
0,120 120,210 210,660 660,750 750,870
like the semaphores, you don't
比如信号量，你不必告诉信号量有关锁的信息，

1889
00:58:11,900 --> 00:58:12,620
0,90 90,180 180,360 360,450 450,720
have to tell the {semaphore

1890
00:58:12,620 --> 00:58:15,040
0,180 180,360 360,450 450,1080
-} about a lock,|
|

1891
00:58:15,100 --> 00:58:16,270
0,270 270,390 390,930 930,990 990,1170
and the caller to {semaphore
并且信号量的调用者不必担心丢失唤醒，

1892
00:58:16,270 --> 00:58:17,200
0,210 210,390 390,660 660,810 810,930
- -} doesn't have to

1893
00:58:17,200 --> 00:58:19,000
0,360 360,750 780,1230 1230,1440 1440,1800
worry about lost {wakeups -},|
|

1894
00:58:19,030 --> 00:58:20,440
0,540 540,660 660,1290 1290,1350 1350,1410
internally the implementation of the
信号量的内部实现，

1895
00:58:20,440 --> 00:58:21,820
0,300 300,570 720,1140 1140,1260 1260,1380
{semaphore -},| again as you
|就像你们在今天的阅读材料中看到的，

1896
00:58:21,820 --> 00:58:23,590
0,270 270,420 420,690 1290,1680 1680,1770
saw in the reading for

1897
00:58:23,590 --> 00:58:25,240
0,240 240,480 480,900 900,1560 1560,1650
today,| the internal implementation of
|信号量的内部实现担心丢失唤醒。

1898
00:58:25,240 --> 00:58:27,280
0,270 270,720 720,1050 1050,1590
{semaphores -} worries about

1899
00:58:27,340 --> 00:58:28,360
0,180 180,480 480,660 660,780 780,1020
{} lost {wakeup -}.| So,
|因为接口专用于这些递增递减计数器，

1900
00:58:28,420 --> 00:58:31,330
0,300 300,420 420,960 960,1320 1440,2910
because the interface is specialized

1901
00:58:31,360 --> 00:58:33,070
0,210 210,390 390,570 570,870 870,1710
to these up down counters,|
|

1902
00:58:34,560 --> 00:58:35,580
0,480 480,690 690,750 750,930 930,1020
the need to deal with
处理丢失唤醒的需要不会显示到接口中。

1903
00:58:35,580 --> 00:58:36,870
0,240 240,480 480,810 810,1050 1050,1290
lost wakeup doesn't leak through

1904
00:58:36,870 --> 00:58:39,180
0,210 210,360 360,1170 1770,1980 1980,2310
into the interface.| So that
|所以信号量稍微简单一些，

1905
00:58:39,420 --> 00:58:40,770
0,270 270,480 480,570 570,840 840,1350
{semaphores -} are somewhat simpler,|
|

1906
00:58:40,770 --> 00:58:42,810
0,240 240,390 390,600 600,1140 1410,2040
although they're less general,| if
尽管它们不那么普遍，|如果你没有一个计数，

1907
00:58:43,050 --> 00:58:44,730
0,240 240,630 1170,1440 1440,1530 1530,1680
you don't, if {you,don't} have

1908
00:58:44,730 --> 00:58:46,140
0,690 690,810 810,1020 1020,1260 1260,1410
{a,count},| you're not waiting for
|你不是在等待计数，

1909
00:58:46,140 --> 00:58:47,740
0,570 570,1110
count,| then
|那么信号量不一定会对你非常有帮助。

1910
00:58:47,920 --> 00:58:48,910
0,240 240,480 480,540 540,630 630,990
{semaphores - -} are not

1911
00:58:49,180 --> 00:58:51,070
0,1290 1290,1410 1410,1470 1470,1590 1590,1890
necessarily going to be super

1912
00:58:51,070 --> 00:58:52,840
0,330 330,540 540,660 1170,1320 1320,1770
helpful for you.| So that
|所以，我说 sleep 和 wakeup 会更普遍一些。

1913
00:58:52,960 --> 00:58:54,400
0,360 360,690 690,840 840,960 960,1440
that causes me to claim

1914
00:58:54,400 --> 00:58:55,660
0,180 390,840 840,930 930,1110 1110,1260
that sleep and {wakeup -}

1915
00:58:55,660 --> 00:58:57,100
0,90 90,270 270,420 420,810
a little more general.|
|

1916
00:58:57,500 --> 00:58:59,140
0,630

1917
00:58:59,350 --> 00:59:00,140
0,60

1918
00:59:00,440 --> 00:59:02,740
0,720 810,1530
Alright. {}|
好的。|

1919
00:59:02,980 --> 00:59:03,970
0,210 210,360 360,690 690,780 780,990
So with sleep and {wakeup
所以有了 sleep 和 wakeup 的经验，

1920
00:59:03,970 --> 00:59:05,710
0,330 360,600 600,690 690,1260 1320,1740
-} under our belts,| I
|我想谈谈 xv6 面临的另一种挑战，

1921
00:59:06,130 --> 00:59:07,330
0,360 360,420 420,570 570,870 870,1200
want to talk about one

1922
00:59:07,330 --> 00:59:09,130
0,690 720,1020 1020,1080 1080,1650 1650,1800
more kind of challenge that

1923
00:59:09,130 --> 00:59:10,330
0,180 180,300 300,600 600,1050 1050,1200
{xv6 - -} faces,| that's
|它与 sleep 和 wakeup 有关，

1924
00:59:10,330 --> 00:59:11,320
0,210 210,600 600,690 690,900 900,990
actually related to sleep and

1925
00:59:11,320 --> 00:59:13,510
0,210 210,540 1560,1800 1800,2040 2040,2190
{wakeup -}| and that's how
|那就是如何关闭线程。

1926
00:59:13,510 --> 00:59:15,970
0,120 120,420 420,720 720,1650 2010,2460
to shut down threads. {}|
|

1927
00:59:16,000 --> 00:59:17,890
0,240 240,570 570,1260 1410,1590 1590,1890
Every threading system, the threads
每个线程系统，线程最终都需要退出，

1928
00:59:17,890 --> 00:59:19,030
0,330 330,510 510,600 600,1020 1020,1140
eventually need to exit| and
|我们需要清理它们的状态，释放它们的堆栈，

1929
00:59:19,030 --> 00:59:20,140
0,60 60,210 210,420 570,1020 1020,1110
we need to clean up

1930
00:59:20,140 --> 00:59:22,090
0,150 150,600 600,900 900,1050 1050,1950
their state, free their stack,|
|

1931
00:59:22,300 --> 00:59:24,280
0,420 420,570 570,720 720,1320 1650,1980
on {xv6 - -}, when
在 xv6 上，当一个进程退出时，

1932
00:59:24,280 --> 00:59:26,140
0,60 60,570 570,1470
a process exits,|
|

1933
00:59:26,550 --> 00:59:27,570
0,300 300,450 450,630 630,870 870,1020
we need to free its
我们需要释放它的用户内存，

1934
00:59:27,570 --> 00:59:28,920
0,240 240,750 750,870 870,1170 1170,1350
user memory| and free its
|释放它的页表，释放它的 trapframe ，

1935
00:59:28,920 --> 00:59:30,090
0,300 300,630 630,780 780,990 990,1170
page table and free its

1936
00:59:30,090 --> 00:59:33,210
0,330 330,1110 1320,2370 2370,2460 2460,3120
{trapframe -},| mark the process
|将进程表中的插槽标记为可重用。

1937
00:59:33,210 --> 00:59:34,200
0,90 90,390 390,480 480,570 570,990
the slot in the process

1938
00:59:34,200 --> 00:59:37,320
0,420 420,810 1020,1560 1860,2580 2940,3120
table as {} reusable.| So,
|所以，典型的清理要求是，

1939
00:59:37,320 --> 00:59:38,430
0,150 150,210 210,390 390,450 450,1110
these are sort of typical

1940
00:59:38,460 --> 00:59:39,720
0,450 450,930 930,1020 1020,1080 1080,1260
cleanup requirements is| a bunch
|一堆东西需要释放，

1941
00:59:39,720 --> 00:59:40,230
0,60 60,210 210,300 300,450 450,510
of stuff that has to

1942
00:59:40,230 --> 00:59:42,600
0,120 120,750 1080,1620 1620,1980 1980,2370
be freed| when threads exit
|当线程退出或被杀死时。

1943
00:59:44,120 --> 00:59:45,500
0,870
{}

1944
00:59:45,730 --> 00:59:48,610
0,660 690,1080 1470,1680 1680,2280 2460,2880
or {} or killed.| So,
|但是这里有两个大问题，

1945
00:59:48,610 --> 00:59:50,140
0,300 300,510 510,690 690,1020 1020,1530
but there's two big problems

1946
00:59:50,140 --> 00:59:51,940
0,90 90,570 570,900 960,1590 1680,1800
that arise here,| with {}
|与线程退出或杀死线程有关，

1947
00:59:51,940 --> 00:59:53,830
0,390 390,930 1080,1260 1260,1560 1560,1890
thread exit or killing threads,|
|

1948
00:59:53,830 --> 00:59:55,120
0,210 210,360 360,600 750,1020 1020,1290
one is that we can't
其一，我们不能仅仅伸手，

1949
00:59:55,120 --> 00:59:56,290
0,210 210,540 540,780 780,870 870,1170
just reach out,| we can't
|我们通常不能伸手，单方面摧毁另一个线程，

1950
00:59:56,290 --> 00:59:57,820
0,480 480,690 690,990 990,1350 1350,1530
usually just reach out and

1951
00:59:57,970 --> 01:00:01,360
0,840 840,1440 1440,1800 1800,2430 2730,3390
unilaterally destroy another thread, {}|
|

1952
01:00:01,780 --> 01:00:03,100
0,360 360,720 720,840 840,1140 1140,1320
the problem is that,| other
问题是，|其他线程可能正在另一个核心上执行，

1953
01:00:03,100 --> 01:00:04,480
0,330 330,480 480,780 780,870 870,1380
thread may actually be currently

1954
01:00:04,480 --> 01:00:06,220
0,660 660,870 870,1200 1200,1590 1590,1740
executing on another core| and
|并使用其堆栈，

1955
01:00:06,220 --> 01:00:08,050
0,300 300,480 480,1050 1050,1320 1500,1830
using its stack| and maybe
|可能要将寄存器保存在结构上下文中或其他什么，

1956
01:00:08,050 --> 01:00:09,430
0,270 270,360 360,600 600,750 750,1380
about to save its registers

1957
01:00:09,430 --> 01:00:10,750
0,120 120,270 270,570 570,1260 1260,1320
in its struct context or

1958
01:00:10,750 --> 01:00:12,430
0,420 780,1140 1140,1320 1320,1590 1590,1680
whatever,| the other thread if
|另一个线程，如果它在内核中，可能持有锁，

1959
01:00:12,430 --> 01:00:13,960
0,120 120,180 180,270 270,780 1080,1530
it's in the kernel, {}

1960
01:00:13,990 --> 01:00:15,280
0,300 300,690 690,1110 1110,1170 1170,1290
maybe holding locks,| it may
|它可能正在对内核数据结构进行一些复杂的更新，

1961
01:00:15,280 --> 01:00:15,970
0,120 120,240 240,330 330,600 600,690
be in the middle of

1962
01:00:15,970 --> 01:00:18,130
0,330 360,1350 1350,1860 1860,2010 2010,2160
some complicated update to a

1963
01:00:18,130 --> 01:00:19,990
0,270 270,540 540,1320 1650,1770 1770,1860
kernel data structure,| and if
|如果我们只是简单地强行中止它，

1964
01:00:19,990 --> 01:00:21,580
0,120 120,390 390,960 960,1320 1320,1590
we simply somehow shoot down

1965
01:00:21,580 --> 01:00:22,570
0,90 90,420 420,540 540,900 900,990
the thread| and stop it
|并停止，杀死在它的[轨道]上，

1966
01:00:22,570 --> 01:00:24,220
0,240 240,300 300,450 450,1080 1200,1650
dead in its [tracks],| then
|那么它可能已经完成了对一些内核数据的部分更新，

1967
01:00:24,310 --> 01:00:25,390
0,240 240,360 360,450 450,690 690,1080
it may have gotten halfway

1968
01:00:25,390 --> 01:00:27,820
0,690 840,990 990,1410 1410,1980 2130,2430
through a delicate update to

1969
01:00:27,820 --> 01:00:29,500
0,210 210,540 540,1020 1230,1590 1590,1680
some kernel data,| but we
|但我们在它完成之前强行中止了。

1970
01:00:29,500 --> 01:00:30,490
0,240 240,330 330,630 630,930 930,990
shot it down before it

1971
01:00:30,490 --> 01:00:31,400
0,630
completed.|
|

1972
01:00:31,920 --> 01:00:34,600
0,600 1500,2160
{} So,
所以，我们不能承受这些事情发生。

1973
01:00:34,810 --> 01:00:36,730
0,480 900,1170 1170,1410 1410,1770 1770,1920
{} we can't afford any

1974
01:00:36,730 --> 01:00:38,560
0,60 60,210 210,360 360,450 450,1830
of those things to happen.|
|

1975
01:00:39,820 --> 01:00:42,610
0,480 480,990 1050,1230 1230,1620 2520,2790
Another problem is that even
另一个问题是，即使线程调用 exit ，

1976
01:00:42,610 --> 01:00:43,810
0,90 90,150 150,510 510,810 810,1200
if a thread calls exit|
|

1977
01:00:43,810 --> 01:00:45,250
0,180 180,420 420,750 750,1290 1290,1440
and sort of decided for
不是决定要杀死，

1978
01:00:45,250 --> 01:00:46,660
0,390 390,570 570,930 930,1020 1020,1410
its not killed,| but decided
|而是自己决定要退出，

1979
01:00:46,660 --> 01:00:47,560
0,90 90,420 420,540 540,630 630,900
for itself that it wants

1980
01:00:47,560 --> 01:00:50,320
0,240 270,720 1620,1800 1800,2130 2130,2760
to quit,| it has resources
|它具有在执行时使用的资源，

1981
01:00:50,320 --> 01:00:52,090
0,120 120,240 240,630 630,930 930,1770
that it uses while executes|
|

1982
01:00:52,090 --> 01:00:53,710
0,300 330,600 600,1020 1020,1140 1140,1620
like its stack, for example
比如它的堆栈，和在进程表中的插槽，

1983
01:00:53,710 --> 01:00:54,640
0,120 120,330 330,750 750,840 840,930
and its slot in the

1984
01:00:54,640 --> 01:00:57,190
0,480 480,960 1170,1740 1980,2430 2430,2550
process table,| and while it's
|当它还在执行时，

1985
01:00:57,190 --> 01:00:58,560
0,210 210,960
still executing,|
|

1986
01:00:58,650 --> 01:00:59,970
0,240 240,630 750,960 960,1170 1170,1320
{} it, it may not
它可能不能释放还在使用的资源。

1987
01:00:59,970 --> 01:01:00,990
0,60 60,210 210,300 300,660 660,1020
be able to free up

1988
01:01:01,200 --> 01:01:02,280
0,150 150,630 630,750 750,840 840,1080
the resources that is still

1989
01:01:02,280 --> 01:01:03,300
0,390
using.|
|

1990
01:01:03,800 --> 01:01:04,580
0,270 270,420 420,540 540,690 690,780
{} So we need a
所以我们需要一种方法让线程，

1991
01:01:04,580 --> 01:01:07,100
0,270 270,510 510,960 960,1440 1740,2520
way for threads to, {}|
|

1992
01:01:07,190 --> 01:01:08,720
0,330 330,540 540,840 840,1020 1020,1530
for those last few resources,|
对于最后几个资源，|

1993
01:01:08,720 --> 01:01:09,860
0,90 90,150 150,510 510,600 600,1140
that are critical to execution
释放对执行至关重要的东西，

1994
01:01:09,860 --> 01:01:11,000
0,60 60,420 420,570 570,930 930,1140
to somehow be freed,| even
|即使线程需要它们，

1995
01:01:11,000 --> 01:01:12,140
0,120 120,210 210,480 480,750 750,1140
though the thread needs them,|
|

1996
01:01:12,530 --> 01:01:13,970
0,390 390,630 630,1050 1050,1200 1200,1440
even just execute any code
即使只是执行任何代码。

1997
01:01:13,970 --> 01:01:14,960
0,120 120,480
at all.|
|

1998
01:01:16,560 --> 01:01:17,610
0,270 270,450 450,630 630,780 780,1050
Okay, so keep these two
好的，记住这两个问题，

1999
01:01:17,610 --> 01:01:19,800
0,510 510,600 600,1080 1170,1740 1890,2190
problems in mind,| {} {xv6
|xv6 实际上有两个东西，

2000
01:01:19,800 --> 01:01:21,800
0,180 180,390 390,570 570,1410
-} actually has two,

2001
01:01:21,800 --> 01:01:23,150
0,600 780,990 990,1200 1200,1290 1290,1350
{} two things,| that are
|关于停止线程或进程，

2002
01:01:23,150 --> 01:01:25,970
0,420 420,570 570,990 990,1680 2070,2820
related to shutting down threads

2003
01:01:25,970 --> 01:01:27,950
0,90 90,870 960,1410 1410,1590 1590,1980
or processes,| one is exit
|一个是退出，另一个是杀死。

2004
01:01:27,950 --> 01:01:29,000
0,90 90,150 150,390 390,750 780,1050
and the {other,is} kill.| So
|那么，我们先来看一下退出。

2005
01:01:29,030 --> 01:01:30,350
0,180 180,270 270,390 390,690 690,1320
let's look at exit first.|
|

2006
01:01:31,160 --> 01:01:32,060
0,210 210,480 480,540 540,600 600,900
I'll look at the code
我会查看 proc.c 中用于退出的代码，

2007
01:01:32,060 --> 01:01:33,140
0,120 120,450 450,600 600,900 900,1080
for exit in {proc.c -

2008
01:01:33,140 --> 01:01:34,160
0,420
-},|
|

2009
01:01:34,810 --> 01:01:36,070
0,240 240,480 480,570 570,810 810,1260
{} this is what the
这是 exit 系统调用所调用的。

2010
01:01:36,770 --> 01:01:40,220
0,360 360,630 630,1170 1230,2010
exit system call calls.|
|

2011
01:01:41,480 --> 01:01:42,830
0,630 630,1020 1020,1110 1110,1170 1170,1350
{} And you know what
退出最终要做的，

2012
01:01:42,830 --> 01:01:43,490
0,210 210,390 390,480 480,600 600,660
exit has to do in

2013
01:01:43,490 --> 01:01:44,930
0,120 120,660 660,780 780,1230 1230,1440
the end,| we know sort
|从外部接口上了解，

2014
01:01:44,930 --> 01:01:45,950
0,60 60,210 210,330 330,900 900,1020
of from the outside from

2015
01:01:45,950 --> 01:01:47,180
0,60 60,540 540,720 870,1080 1080,1230
the interface,| that it's gonna
|它会释放进程内存和页表，

2016
01:01:47,180 --> 01:01:48,740
0,330 330,630 630,720 720,1140 1140,1560
free up the process memory

2017
01:01:48,740 --> 01:01:50,150
0,120 120,420 420,810 810,990 990,1410
and page tables,| {got,to} {close,its}
|关闭打开的文件，

2018
01:01:50,150 --> 01:01:52,640
0,240 240,1020 1590,1950 2010,2280 2280,2490
open files| and we also
|我们也知道有一个 wait 调用，

2019
01:01:52,640 --> 01:01:53,720
0,180 180,360 360,570 570,720 720,1080
know that there's this wait

2020
01:01:53,720 --> 01:01:54,830
0,330 330,450 450,540 540,990 990,1110
call,| that the parent may
|可能是父进程创造的，

2021
01:01:54,830 --> 01:01:57,260
0,120 120,690 750,1200 1200,1590 1800,2430
be making, making| and exit
|exit 最终也必须唤醒父进程，

2022
01:01:57,260 --> 01:01:59,060
0,300 300,960 1020,1500 1500,1710 1710,1800
has to eventually cause the

2023
01:01:59,060 --> 01:02:00,080
0,360 360,450 450,540 540,840 840,1020
parent to be woken up

2024
01:02:00,140 --> 01:02:01,910
0,240 240,570 1440,1620 1620,1710 1710,1770
as well| and so we're
|所以我们要在 exit 代码中查看这些东西。

2025
01:02:01,910 --> 01:02:02,450
0,120 120,180 180,330 330,450 450,540
going to look for all

2026
01:02:02,450 --> 01:02:03,880
0,210 210,540 540,660 660,900
these things in the,

2027
01:02:04,080 --> 01:02:05,180
0,510
{}

2028
01:02:05,390 --> 01:02:07,220
0,150 150,450 450,870 1320,1650 1650,1830
{in,the} exit code.| So you
|所以你可以看到一些这样的东西，

2029
01:02:07,220 --> 01:02:08,750
0,90 90,810 1110,1320 1320,1380 1380,1530
can see some of this

2030
01:02:08,750 --> 01:02:11,300
0,390 390,750 780,1230 1500,2130 2130,2550
stuff,| like exit specifically closes
|比如 exit 关闭打开的文件，

2031
01:02:11,300 --> 01:02:12,680
0,90 90,360 360,1020 1020,1170 1170,1380
the open files,| and this
|这可能非常复杂，

2032
01:02:12,680 --> 01:02:13,820
0,180 180,360 360,450 450,660 660,1140
might actually be quite complex,|
|

2033
01:02:13,820 --> 01:02:15,680
0,180 180,270 270,720 720,960 1230,1860
because the files or file
因为文件系统关闭文件，

2034
01:02:15,680 --> 01:02:17,480
0,300 300,840 840,1200 1200,1470 1470,1800
system files closing them,| actually
|涉及到比如引用计数的东西。

2035
01:02:17,480 --> 01:02:19,250
0,570 570,750 750,900 900,1230 1230,1770
involves things like reference counting.|
|

2036
01:02:19,520 --> 01:02:20,740
0,780

2037
01:02:21,070 --> 01:02:21,940
0,270 300,420 420,570 570,750 750,870
And we haven't gotten there
我们还没到那一步，

2038
01:02:21,940 --> 01:02:22,780
0,180 180,330 330,420 420,630 630,840
yet,| but we'll see that,|
|但我们会看到，|

2039
01:02:22,930 --> 01:02:24,000
0,510
{}

2040
01:02:24,030 --> 01:02:24,900
0,330 330,540 540,570 570,660 660,870
this takes a fair amount
这需要相当多的工作。

2041
01:02:24,900 --> 01:02:26,010
0,60 60,240 240,450 570,690 690,1110
of work.| But a process
|但是当你调用 exit 时，进程会继续并关闭它自己的文件。

2042
01:02:26,010 --> 01:02:27,000
0,180 180,360 360,450 450,810 810,990
goes ahead and closes when

2043
01:02:27,000 --> 01:02:28,560
0,90 90,330 330,660 810,1410 1410,1560
you call exit, closes its

2044
01:02:28,560 --> 01:02:30,120
0,240 240,1050
own files.|
|

2045
01:02:30,950 --> 01:02:32,270
0,390 510,750 750,930 930,1080 1080,1320
And it also does something
它也会做一些类似的事情，

2046
01:02:32,270 --> 01:02:34,760
0,570 570,750 750,1440 1440,1710 1920,2490
similar,| it has a record
|它具有当前工作目录的记录，

2047
01:02:34,760 --> 01:02:36,710
0,120 120,480 780,1140 1140,1470 1470,1950
of the current working directory,|
|

2048
01:02:36,710 --> 01:02:37,790
0,180 180,300 300,570 570,990 990,1080
which is what's changed when
就是当你是使用 cd 时会变的目录，

2049
01:02:37,790 --> 01:02:38,720
0,90 90,300 300,750 750,840 840,930
you call cd,| and it
|它需要在将该引用释放到文件系统中。

2050
01:02:38,720 --> 01:02:40,190
0,240 240,480 690,1140 1170,1380 1380,1470
needs to to sort of

2051
01:02:40,280 --> 01:02:42,260
0,750 750,1020 1020,1650 1650,1890 1890,1980
release that reference into the

2052
01:02:42,260 --> 01:02:43,600
0,330 330,870
file system.|
|

2053
01:02:43,750 --> 01:02:45,250
0,390 420,840 990,1260 1260,1350 1350,1500
{} Then there's some other
然后，还有其他一些讨厌的事情发生，

2054
01:02:45,250 --> 01:02:47,500
0,360 360,630 630,780 780,1680 1710,2250
horrible stuff that happens,| that's
|这与事实有关，

2055
01:02:47,500 --> 01:02:48,940
0,540 540,690 690,810 810,1200 1200,1440
related to the fact,| that
|如果进程退出，

2056
01:02:49,180 --> 01:02:51,490
0,330 330,420 420,1290 1590,2190 2190,2310
if a process exits,| but
|但它有自己的子进程，

2057
01:02:51,490 --> 01:02:52,840
0,120 120,630 660,1110 1110,1200 1200,1350
it has children of its

2058
01:02:52,840 --> 01:02:54,200
0,810
own,|
|

2059
01:02:54,200 --> 01:02:57,440
0,600 750,1470 1470,1950 1950,2430 2460,3240
{} those children are inherited
这些子进程由初始进程继承，

2060
01:02:57,440 --> 01:02:59,540
0,330 330,540 540,870 870,1680 1710,2100
by the init process,| because
|因为事实证明，

2061
01:02:59,540 --> 01:03:00,410
0,150 150,240 240,540 540,750 750,870
as it turns out,| we'll
|我们几分钟后就会看到，

2062
01:03:00,410 --> 01:03:01,430
0,210 210,300 300,360 360,540 540,1020
see in a few minutes,|
|

2063
01:03:01,430 --> 01:03:04,040
0,270 840,1320 1320,1710 1710,1860 1860,2610
that every process that exits,
每个退出的进程，都有来自父进程的对应的等待，

2064
01:03:04,370 --> 01:03:04,940
0,150 150,330 330,420 420,510 510,570
there has to be a

2065
01:03:04,940 --> 01:03:07,070
0,540 540,1200 1230,1410 1410,1470 1470,2130
corresponding wait from a parent,|
|

2066
01:03:07,070 --> 01:03:09,640
0,300 510,1110 1110,1650 1650,2130
that actually finishes up
这完成了退出过程中的一些步骤，

2067
01:03:09,640 --> 01:03:10,660
0,300 300,540 540,600 600,690 690,1020
{} some of the steps

2068
01:03:10,660 --> 01:03:12,580
0,90 90,570 1260,1530 1530,1710 1710,1920
in exiting| {} and so
|所以如果我退出，我的子进程需要等待，

2069
01:03:12,580 --> 01:03:14,500
0,180 180,300 300,870 1020,1380 1380,1920
if I exit, my children

2070
01:03:14,500 --> 01:03:15,340
0,150 150,330 330,420 420,510 510,840
they need to be waited

2071
01:03:15,340 --> 01:03:16,330
0,270 270,360 360,480 480,600 600,990
for,| I was their parent,
|我是它们的父进程，我不会等待它们，

2072
01:03:16,330 --> 01:03:16,870
0,90 90,180 180,300 300,360 360,540
I'm not going to wait

2073
01:03:16,870 --> 01:03:17,950
0,120 120,210 210,390 390,540 540,1080
for them,| because I've exited.|
|因为我已经退出了。|

2074
01:03:18,130 --> 01:03:19,660
0,300 300,630 660,1110 1200,1500 1500,1530
{} And so there's a
所以这里有一段代码，

2075
01:03:19,660 --> 01:03:20,590
0,330 330,420 420,660 660,840 840,930
stretch of code here| and
|exit 重新给退出进程的子进程设置父进程，

2076
01:03:20,590 --> 01:03:22,900
0,480 480,720 750,1080 1080,1380 1380,2310
exit that is {re-parenting -}

2077
01:03:23,080 --> 01:03:24,880
0,270 270,690 690,1230 1230,1650 1650,1800
the exiting processes children,| so
|这样它们的父进程就是 init ，

2078
01:03:24,880 --> 01:03:25,840
0,150 150,300 300,750 750,900 900,960
that their parents of {}

2079
01:03:25,840 --> 01:03:27,490
0,360 360,570 570,870 1020,1410 1410,1650
init,| which is process id
|它的进程 ID 是 1 。

2080
01:03:27,490 --> 01:03:28,260
0,330
one.|
|

2081
01:03:28,620 --> 01:03:29,880
0,690

2082
01:03:29,970 --> 01:03:32,700
0,90 90,240 240,780 1080,1620 2130,2730
And then finally, a process
最后，一个进程唤醒它的父进程，

2083
01:03:32,700 --> 01:03:33,780
0,240 240,360 360,480 480,660 660,1080
wakes up its own parent,|
|

2084
01:03:34,170 --> 01:03:35,280
0,180 180,360 360,510 510,840 840,1110
which might be waiting and
可能在睡眠并等待，

2085
01:03:35,760 --> 01:03:37,360
0,450 450,540 540,1020
sleeping and wait,|
|

2086
01:03:37,360 --> 01:03:38,700
0,540

2087
01:03:39,500 --> 01:03:41,680
0,870 1020,1590
and {}
并将自己的状态设置为僵尸状态，

2088
01:03:41,680 --> 01:03:42,730
0,420 420,510 510,840 840,930 930,1050
sets its state to the

2089
01:03:42,730 --> 01:03:45,490
0,540 540,1110 2220,2430 2430,2640 2640,2760
zombie state,| it turns out
|我们还没有，

2090
01:03:45,490 --> 01:03:46,580
0,90 90,510
we haven't,|
|

2091
01:03:46,580 --> 01:03:47,150
0,180 180,300 300,450 450,510 510,570
but we'll see in a
但我们稍后会看到，

2092
01:03:47,150 --> 01:03:48,410
0,330 330,510 510,600 600,960 960,1260
moment,| but the process hasn't
|这个进程还没有完全释放所有的资源，

2093
01:03:48,410 --> 01:03:50,600
0,660 660,1200 1200,1740 1740,2100 2100,2190
completely finished releasing all of

2094
01:03:50,600 --> 01:03:52,640
0,210 210,1080 1440,1740 1740,1890 1890,2040
its resources,| {} so it's
|所以它没有准备好重新使用，

2095
01:03:52,640 --> 01:03:53,900
0,270 270,660 660,900 900,1020 1020,1260
not quite ready to be

2096
01:03:53,900 --> 01:03:56,360
0,930 1290,2040 2040,2190 2190,2250 2250,2460
reused,| we want to end
|我们想要在一个位置结束，

2097
01:03:56,360 --> 01:03:57,500
0,150 150,240 240,330 330,720 720,1140
up in a position,| where
|这个进程所有的状态可以由 fork 重用，

2098
01:03:57,620 --> 01:03:58,880
0,210 210,570 570,720 720,1080 1110,1260
the process can be and

2099
01:03:58,880 --> 01:04:00,410
0,180 180,660 750,1260 1260,1350 1350,1530
all its state can be

2100
01:04:00,410 --> 01:04:02,510
0,450 450,600 600,690 690,1320 1590,2100
reused by a fork,| by
|被另一个不相关的 fork 使用。

2101
01:04:02,510 --> 01:04:04,400
0,300 300,600 600,1080 1080,1260 1260,1890
some other fork that's unrelated

2102
01:04:04,400 --> 01:04:05,100
0,270
right.|
|

2103
01:04:05,100 --> 01:04:06,000
0,180 180,330 330,420 420,570 570,900
{} But we're not quite
但我们还没到那一步，

2104
01:04:06,000 --> 01:04:07,920
0,210 210,630 750,1410 1440,1680 1680,1920
there yet,| {} and we'll
|稍后我们会看到为什么，

2105
01:04:07,920 --> 01:04:08,820
0,150 150,360 360,450 450,510 510,900
see why in a moment,|
|

2106
01:04:08,820 --> 01:04:09,960
0,270 270,360 360,600 600,690 690,1140
{} we set the state
我们把状态设为僵尸状态，

2107
01:04:10,020 --> 01:04:11,260
0,150 150,660
to zombie,|
|

2108
01:04:11,760 --> 01:04:14,370
0,480 600,1110 1110,1740 2100,2310 2310,2610
{} and then we're not
然后我们还没做完，

2109
01:04:14,370 --> 01:04:15,540
0,270 270,570 570,780 780,990 990,1170
done yet,| we haven't freed
|我们还没有释放这个进程，

2110
01:04:15,540 --> 01:04:17,940
0,90 90,930 990,1470 1710,1980 2040,2400
the process,| {} we just
|我们只是跳到调度器中，

2111
01:04:17,940 --> 01:04:19,800
0,270 270,450 450,540 540,1470
jump into the scheduler,|
|

2112
01:04:20,200 --> 01:04:22,660
0,240 240,660 660,900 900,1590 1590,2460
{} without having completely finished
还没有完全释放我们的资源。

2113
01:04:23,250 --> 01:04:24,440
0,630
{}

2114
01:04:24,440 --> 01:04:26,580
0,300 300,510 510,1440
freeing our resources.|
|

2115
01:04:27,730 --> 01:04:29,160
0,900
Okay.|
好的。|

2116
01:04:29,440 --> 01:04:31,300
0,270 270,330 330,720 720,900 900,1860
So the story here continues,|
所以这里的故事还在继续，|

2117
01:04:31,330 --> 01:04:32,470
0,210 210,390 390,600 600,810 810,1140
{} this point {} zombie
这里僵尸进程不会运行，

2118
01:04:32,470 --> 01:04:34,210
0,330 330,540 540,660 660,1260 1530,1740
process won't be run, {}|
|

2119
01:04:34,210 --> 01:04:36,100
0,120 120,600 600,1110 1110,1560 1560,1890
the scheduler only runs runnable
调度器仅运行可运行的进程，

2120
01:04:36,100 --> 01:04:38,020
0,600 600,720 720,1170 1260,1710 1710,1920
processes,| so this process isn't
|这个进程没有释放，

2121
01:04:38,020 --> 01:04:39,280
0,240 240,870 900,1050 1050,1170 1170,1260
quite free,| because that would
|因为这是状态等于未使用，

2122
01:04:39,280 --> 01:04:41,500
0,120 120,450 450,750 750,1590 1710,2220
be state equals unused,| but
|但它肯定不会再运行了，

2123
01:04:41,500 --> 01:04:42,160
0,90 90,360 360,480 480,600 600,660
it's definitely not going to

2124
01:04:42,160 --> 01:04:43,930
0,180 180,570 600,900 900,1320 1320,1770
run again,| because {in,state} zombie,|
|因为在僵尸状态中，|

2125
01:04:43,930 --> 01:04:45,280
0,120 120,570 570,630 630,720 720,1350
so [] to the scheduler,
所以对于调度器，现在运行的是其他东西。

2126
01:04:45,310 --> 01:04:47,980
0,510 510,900 1410,1740 1740,2040 2040,2670
scheduler now runs something else.|
|

2127
01:04:48,580 --> 01:04:49,620
0,480

2128
01:04:49,740 --> 01:04:51,480
0,270 270,660 660,900 900,1260 1470,1740
We knew from the sort
我们从关于退出和等待的描述中知道，

2129
01:04:51,480 --> 01:04:53,460
0,60 60,600 600,1050 1050,1530 1530,1980
of description of {exit,and} wait,|
|

2130
01:04:53,520 --> 01:04:55,830
0,180 180,870 870,1290 1530,2010 2100,2310
in Unix that, {} if
在 Unix 中，如果进程退出，

2131
01:04:55,830 --> 01:04:58,170
0,60 60,480 480,1110 1110,1680 2160,2340
a process exits,| then {}
|那么它的父进程调用 wait ，

2132
01:04:58,170 --> 01:05:00,330
0,150 150,480 480,960 960,1530 1890,2160
its parent calls wait, {}|
|

2133
01:05:00,330 --> 01:05:01,350
0,180 180,510 510,690 690,930 930,1020
the wait, that wait is
wait 将返回信号通知父进程，

2134
01:05:01,350 --> 01:05:02,580
0,150 150,210 210,660 660,750 750,1230
going to return to signal

2135
01:05:02,760 --> 01:05:04,620
0,150 150,240 240,720 720,1140 1560,1860
to the parent,| that one
|它的一个子进程退出了，

2136
01:05:04,620 --> 01:05:05,790
0,90 90,210 210,510 510,660 660,1170
of its children is exited,|
|

2137
01:05:05,970 --> 01:05:06,660
0,210 210,300 300,420 420,600 600,690
so we can look for
所以我们可以查看 wait 的实现。

2138
01:05:06,660 --> 01:05:08,520
0,120 120,720 720,810 810,1350
the implementation of wait.|
|

2139
01:05:12,770 --> 01:05:14,780
0,330 330,750 1500,1680 1680,1770 1770,2010
Also, here is the big
wait 的实现也是一个大的循环，

2140
01:05:14,780 --> 01:05:16,940
0,900 990,1200 1200,1830 1830,1950 1950,2160
loop, this implementation of wait,|
|

2141
01:05:16,940 --> 01:05:18,680
0,180 270,660 660,870 870,1170 1170,1740
but really what's going on
但是当进程调用 wait 时，

2142
01:05:19,430 --> 01:05:20,450
0,180 180,330 330,510 510,690 690,1020
is that when a process

2143
01:05:20,450 --> 01:05:22,940
0,270 270,780 1230,1710 1710,2370 2370,2490
calls wait,| it scans the
|它扫描进程表，

2144
01:05:22,940 --> 01:05:24,600
0,480 480,1050
process table,|
|

2145
01:05:25,560 --> 01:05:28,440
0,480 540,1080 1080,1230 1230,2190 2550,2880
{} looking for processes whose
查找父进程为当前进程的进程，

2146
01:05:28,440 --> 01:05:31,380
0,960 1170,1410 1410,1530 1530,1890 1890,2940
parent is the current process,|
|

2147
01:05:31,930 --> 01:05:33,180
0,690

2148
01:05:34,400 --> 01:05:35,630
0,180 180,270 270,690 690,900 900,1230
and in particular looking for
特别是查找这样的进程，

2149
01:05:35,660 --> 01:05:36,920
0,600 600,780 780,1080 1080,1170 1170,1260
processes,| whose parent is the
|它的父进程是当前进程并且处于僵尸状态，

2150
01:05:36,920 --> 01:05:39,350
0,330 330,840 840,1230 1230,1710 1710,2430
current process and {in,state} zombie,|
|

2151
01:05:39,380 --> 01:05:41,480
0,210 210,570 780,1560 1560,1860 1860,2100
that is they've gotten that
那就是它们走到这一步，

2152
01:05:41,480 --> 01:05:43,850
0,630 630,900 900,1410 1560,1770 1770,2370
far,| in {} in exit
|在退出或即将完成退出。

2153
01:05:43,970 --> 01:05:46,040
0,120 120,450 450,840 840,1260
or almost finished exiting.|
|

2154
01:05:46,070 --> 01:05:47,280
0,600

2155
01:05:47,280 --> 01:05:48,330
0,120 120,240 240,360 360,840 870,1050
So now we found this
所以现在我们发现这调用 wait 系统调用，

2156
01:05:48,330 --> 01:05:49,170
0,240 240,330 330,690 690,780 780,840
called a wait to the

2157
01:05:49,170 --> 01:05:50,250
0,240 240,510 510,810 810,1020 1020,1080
wait system calls,| found a
|找到已退出的子进程。

2158
01:05:50,250 --> 01:05:52,500
0,390 390,1020 1020,1140 1140,1590 1590,2250
child process that has exited.|
|

2159
01:05:53,170 --> 01:05:54,380
0,630

2160
01:05:54,930 --> 01:05:56,640
0,1050
And,
我不知道你是否记得 exit 可以返回这个 32 位的退出状态，

2161
01:05:56,760 --> 01:05:57,510
0,450 450,480 480,600 600,660 660,750
{} I don't know if

2162
01:05:57,510 --> 01:05:59,520
0,60 60,570 600,1110 1110,1320 1320,2010
you remember exit can return

2163
01:05:59,670 --> 01:06:02,190
0,390 510,1050 1050,1350 1770,2100 2100,2520
this 32 bit exit status,|
|

2164
01:06:02,190 --> 01:06:03,210
0,60 60,150 150,750 750,840 840,1020
so the parents of the
让父进程，剩下的代码可以收集这些信息，

2165
01:06:03,240 --> 01:06:04,410
0,270 270,450 450,510 510,780 780,1170
next bunch of code collects

2166
01:06:04,410 --> 01:06:05,820
0,300 630,960 960,1080 1080,1230 1230,1410
that,| {} and then it's
|然后是父进程调用 freproc ，

2167
01:06:05,820 --> 01:06:08,430
0,120 120,1200 1560,1860 1860,2280 2280,2610
the parent that calls {freeproc

2168
01:06:08,430 --> 01:06:10,080
0,540 870,1110 1110,1350 1350,1560 1560,1650
-},| {} which does the
|完成了最后一部，释放进程的资源。

2169
01:06:10,080 --> 01:06:11,940
0,540 540,1230 1230,1440 1440,1770 1770,1860
final steps in freeing up

2170
01:06:11,940 --> 01:06:13,890
0,600 600,1350 1440,1710 1710,1830 1830,1950
process's resources.| So we'll look
|所以我们来看一下 freproc ，

2171
01:06:13,890 --> 01:06:15,200
0,90 90,300 300,840
at {freeproc -},|
|

2172
01:06:15,670 --> 01:06:16,540
0,210 210,330 330,420 420,510 510,870
and this is the final
这是最后一次关闭，这是很难处理的，

2173
01:06:16,540 --> 01:06:18,010
0,540 540,630 630,1050 1050,1260 1260,1470
shutdown of stuff, that would

2174
01:06:18,010 --> 01:06:19,510
0,90 90,360 390,1020 1020,1200 1200,1500
be quite awkward,| if the
|如果退出进程在执行时被释放，

2175
01:06:19,870 --> 01:06:21,730
0,180 180,300 300,630 630,1140 1140,1860
if the exiting process itself

2176
01:06:21,730 --> 01:06:23,500
0,420 420,840 840,900 900,1110 1110,1770
freed, while it was executing,|
|

2177
01:06:24,520 --> 01:06:26,260
0,240 240,510 510,840 840,1320 1350,1740
it freezes {trapframe -}, freeze
它冻结 trapframe ，冻结用户页表，

2178
01:06:26,260 --> 01:06:28,720
0,300 330,600 600,960 960,1530 1740,2460
the user page table, {}|
|

2179
01:06:29,260 --> 01:06:30,340
0,570
and
如果我们释放内核堆栈，

2180
01:06:30,340 --> 01:06:32,770
0,210 210,390 390,1200 1230,1590 1590,2430
if we freed kernel stacks,|
|

2181
01:06:32,800 --> 01:06:35,710
0,480 600,1530 1710,2160 2160,2610 2610,2910
the process's, existing process's kernel
现有进程的内核堆栈也将在这里释放，

2182
01:06:35,710 --> 01:06:36,940
0,300 300,390 390,510 510,840 840,1230
stack would be freed here

2183
01:06:37,120 --> 01:06:39,310
0,420 690,1290 1290,1650 1650,1740 1740,2190
also,| but because of the
|但是由于堆栈保护页，

2184
01:06:40,180 --> 01:06:41,320
0,750
{}

2185
01:06:41,880 --> 01:06:43,500
0,180 180,570 570,1020 1020,1320 1320,1620
{} stack guard, kernel stack

2186
01:06:43,500 --> 01:06:44,430
0,240 240,480 480,690 690,840 840,930
stack guard page is,| we
|我们没有释放内核堆栈，

2187
01:06:44,430 --> 01:06:46,080
0,180 180,510 510,1080 1170,1440 1440,1650
don't actually ever turns out,

2188
01:06:46,080 --> 01:06:47,910
0,90 90,420 420,1020 1050,1470 1470,1830
we don't free, whenever free
无论何时释放内核堆栈，我们都不会免费，

2189
01:06:47,910 --> 01:06:50,640
0,330 630,1080 1080,1770 2370,2640 2640,2730
the kernel stacks,| but all
|但是这些东西在退出时都是一种潜在的痛苦，

2190
01:06:50,640 --> 01:06:51,300
0,90 90,330 330,420 420,540 540,660
the stuff that would be

2191
01:06:51,300 --> 01:06:52,230
0,90 90,300 300,420 420,870 870,930
a sort of potentially a

2192
01:06:52,230 --> 01:06:53,550
0,360 360,450 450,810 1080,1230 1230,1320
pain to free in the

2193
01:06:53,550 --> 01:06:54,460
0,390
exit,|
|

2194
01:06:54,520 --> 01:06:55,750
0,300 300,390 390,690 690,1080 1080,1230
while the exiting process is
当正在运行的退出进程由父进程释放时。

2195
01:06:55,750 --> 01:06:57,310
0,420 600,870 870,1230 1230,1440 1440,1560
running is freed by the

2196
01:06:57,310 --> 01:06:58,600
0,660
parent.|
|

2197
01:06:59,380 --> 01:07:00,580
0,690

2198
01:07:00,610 --> 01:07:01,540
0,240 240,360 360,450 450,750 750,930
One thing to notice here
这里需要注意的一件事是，

2199
01:07:01,540 --> 01:07:04,080
0,90 90,270 270,870 1350,1980
is that,| wait {},
|wait 不仅是为了父进程方便，

2200
01:07:04,170 --> 01:07:05,340
0,300 300,420 420,780 780,1080 1080,1170
wait is not just for

2201
01:07:05,340 --> 01:07:06,870
0,120 120,870 870,990 990,1410 1410,1530
the convenience of parents,| that
|它们想知道子进程什么时候退出，

2202
01:07:06,870 --> 01:07:07,650
0,180 180,240 240,360 360,510 510,780
want to know when their

2203
01:07:07,770 --> 01:07:09,150
0,150 150,300 300,660 660,750 750,1380
when their children have exited,|
|

2204
01:07:09,390 --> 01:07:10,800
0,390 570,1020 1020,1110 1110,1350 1350,1410
{} wait is actually {}
wait 实际上是退出进程的关键部分，

2205
01:07:10,800 --> 01:07:12,090
0,390 390,720 720,840 840,930 930,1290
critical piece of the exit

2206
01:07:12,090 --> 01:07:14,430
0,690 690,1020 1050,1230 1230,1710 2130,2340
process| and you really in
|在 Unix 中，这是一个需要，

2207
01:07:14,430 --> 01:07:16,710
0,570 810,1020 1020,1200 1200,1290 1290,2280
Unix, it's just a requirement,|
|

2208
01:07:16,920 --> 01:07:18,330
0,420 420,540 540,690 690,840 840,1410
that there be a wait
wait 对应于每个退出的进程，

2209
01:07:18,360 --> 01:07:20,670
0,270 270,960 960,1140 1140,1800 1830,2310
that corresponds to every exiting

2210
01:07:20,670 --> 01:07:21,900
0,570 570,690 690,900 900,1110 1110,1230
process| and that's really the
|这就是为什么当进程退出其子进程时，

2211
01:07:21,900 --> 01:07:23,970
0,300 300,810 1050,1620 1680,1890 1890,2070
reason why {} when a

2212
01:07:23,970 --> 01:07:26,370
0,390 390,840 840,1050 1050,1830 2070,2400
process exits its children| are
|某种程度上给了 init ，

2213
01:07:26,370 --> 01:07:27,480
0,150 150,240 240,510 510,930 930,1110
sort of given away to

2214
01:07:27,480 --> 01:07:28,600
0,240 240,570
{init -},|
|

2215
01:07:28,630 --> 01:07:30,370
0,570 870,1110 1140,1470 1470,1590 1590,1740
{} they're turning to {init
它们成为了 init 的子进程，

2216
01:07:30,370 --> 01:07:31,990
0,240 240,750 870,1110 1110,1470 1470,1620
-} children,| {} when init
|当 init 在循环中调用 wait 时，

2217
01:07:31,990 --> 01:07:34,030
0,420 420,780 780,1050 1050,1590 1800,2040
does just calls wait in

2218
01:07:34,030 --> 01:07:36,640
0,60 60,1230 1470,2010 2010,2280 2280,2610
a loop,| because every process
|因为每个进程都要等待，

2219
01:07:36,640 --> 01:07:37,780
0,240 240,300 300,420 420,720 720,1140
has to be waited for,|
|

2220
01:07:37,780 --> 01:07:39,610
0,180 180,390 390,750 1140,1710 1710,1830
so that the parent can
让父进程可以调用 freproc 并完成资源释放，

2221
01:07:39,610 --> 01:07:41,410
0,210 210,450 450,870 870,1020 1020,1800
call {freeproc -} and finish

2222
01:07:41,710 --> 01:07:43,120
0,330 330,480 510,1170 1170,1290 1290,1410
freeing up resources| and then
|然后当它完全完成的时候，

2223
01:07:43,120 --> 01:07:44,740
0,90 90,210 210,630 630,1110
when it's completely done,|
|

2224
01:07:44,860 --> 01:07:46,630
0,480 750,960 960,1440 1440,1560 1560,1770
{} it sets if the
如果父进程完成释放所有退出进程资源，

2225
01:07:46,630 --> 01:07:48,280
0,450 450,660 660,900 900,1230 1230,1650
parents done freeing all the

2226
01:07:48,640 --> 01:07:51,730
0,540 540,1080 1080,1770 2400,2700 2700,3090
exit processes resources,| {} sets
|将子进程状态设置为未使用，

2227
01:07:51,730 --> 01:07:54,160
0,180 180,570 570,870 870,1740 1740,2430
that child state unused,| now
|现在 fork 或将来调用 fork 可以重用该进程槽。

2228
01:07:54,310 --> 01:07:57,100
0,1050 1380,1800 2280,2580 2580,2670 2670,2790
fork {} and you know

2229
01:07:57,100 --> 01:07:58,510
0,270 270,750 750,960 960,1020 1020,1410
some future called a fork

2230
01:07:58,510 --> 01:07:59,890
0,210 210,570 570,720 720,1110 1110,1380
can reuse that process slot.|
|

2231
01:08:03,760 --> 01:08:06,200
0,180 180,900
Any questions?|
有什么问题吗？|

2232
01:08:07,890 --> 01:08:09,180
0,360 360,480 480,750 750,810 810,1290
Oh, I have a question
哦，我有个关于 sleep 的问题，

2233
01:08:09,180 --> 01:08:12,270
0,480 480,1590 1740,2070 2070,2670 2880,3090
about sleep,| {} so in
|所以在 sleep 中，我们。

2234
01:08:12,270 --> 01:08:16,320
0,930 960,1830 1860,2460 2490,3180 3420,4050
sleep where we are {}.|
|

2235
01:08:17,500 --> 01:08:19,720
0,390 390,960 1200,1560 1560,1740 1740,2220
Yeah, so when we are,|
是的，当我们，|

2236
01:08:20,860 --> 01:08:22,390
0,150 150,360 360,600 600,930 960,1530
oh, sorry, not sleep {},
哦，抱歉，不是 sleep ，而是 exit 。

2237
01:08:22,940 --> 01:08:24,110
0,450 450,510 510,690 690,810 810,1170
exit.| I want say exit,
|我想说的是 exit ，是的。

2238
01:08:24,110 --> 01:08:25,600
0,390
yeah.|
|

2239
01:08:28,340 --> 01:08:30,560
0,420 450,1050 1110,1530 1530,1680 1680,2220
Yeah, so why are we,|
是的，为什么我们，|

2240
01:08:31,450 --> 01:08:33,730
0,330 330,480 480,870 1110,1710 1710,2280
why are we grabbing original
为什么我们要在重新分配父进程前[抓住]最初的父进程，

2241
01:08:33,730 --> 01:08:35,580
0,510 510,1290
parent before

2242
01:08:35,800 --> 01:08:38,740
0,540 780,1650 1680,1860 1860,2100 2100,2940
we reparent,| is that necessary.|
|这是必须的吗。|

2243
01:08:42,000 --> 01:08:43,580
0,510 510,930
This is
这是[]代码，处理一种可能性，

2244
01:08:43,640 --> 01:08:46,640
0,840 840,1710 1740,2100 2100,2820 2820,3000
[] code, that's wrestling with

2245
01:08:46,640 --> 01:08:50,060
0,90 90,1260 1320,1920 2040,2400 2400,3420
the possibility| that a process
|进程和父进程同时退出的情况。

2246
01:08:50,390 --> 01:08:52,760
0,300 300,510 510,1200 1500,1710 1710,2370
and its parent may exit

2247
01:08:53,000 --> 01:08:55,280
0,360 360,480 480,870 870,1530
at the same time.|
|

2248
01:08:55,670 --> 01:08:58,280
0,660 930,1260 1260,1470 1470,2010
{} And there's some,|
还有一些，|

2249
01:08:58,800 --> 01:09:01,230
0,420 690,1110 1110,1350 1350,2070 2070,2430
{} even though ordinarily, just
尽管最初的，不关心进程退出，

2250
01:09:01,230 --> 01:09:02,460
0,270 270,570 570,780 780,900 900,1230
nothing interesting going on process

2251
01:09:02,460 --> 01:09:04,740
0,1050 1350,1560 1560,1830 1830,2100 2100,2280
exits,| its parent waits for
|它的父进程等待它，一切都很好，

2252
01:09:04,740 --> 01:09:07,140
0,210 300,690 690,1230 2040,2310 2310,2400
it, everything's fine,| but it
|但它可能是进程退出的父进程，

2253
01:09:07,140 --> 01:09:08,310
0,210 210,390 390,510 510,1020 1020,1170
could be that parent, that

2254
01:09:08,310 --> 01:09:09,810
0,60 60,450 450,1080 1170,1410 1410,1500
a process exits| and its
|并且它的父进程同时退出，

2255
01:09:09,810 --> 01:09:10,920
0,270 270,570 570,900 900,990 990,1110
parent process exits at the

2256
01:09:10,920 --> 01:09:12,660
0,240 240,540 540,630 630,930 990,1740
same time| and so while
|所以当我们试图唤醒父进程，告诉它我们已经退出时，

2257
01:09:12,660 --> 01:09:14,610
0,180 180,720 720,1110 1140,1770 1770,1950
we're trying to wake up

2258
01:09:14,610 --> 01:09:15,570
0,120 120,450 450,540 540,780 780,960
our parent to tell we've

2259
01:09:15,570 --> 01:09:17,370
0,660 690,960 960,1230 1230,1350 1350,1800
exited,| that parent is itself
|那个父进程已经退出了。

2260
01:09:17,370 --> 01:09:18,460
0,570
exiting.|
|

2261
01:09:18,460 --> 01:09:20,440
0,510 810,1170 1170,1740 1740,1920 1920,1980
{} And a lot of
这里有很多这样的代码，

2262
01:09:20,440 --> 01:09:23,760
0,150 150,480 480,1260 1980,2790
this code here,| which
|我觉得我一年前是明白的，

2263
01:09:23,760 --> 01:09:24,900
0,180 180,450 450,750 780,1050 1050,1140
I feel I kind of

2264
01:09:24,900 --> 01:09:25,980
0,360 360,420 420,630 630,900 900,1080
understood a year ago,| but
|但现在不再明白了，

2265
01:09:26,100 --> 01:09:28,080
0,270 270,450 450,750 750,1560 1590,1980
don't any longer understand, {}|
|

2266
01:09:28,110 --> 01:09:29,550
0,150 150,390 390,690 690,1170 1260,1440
is about taking care of
是关于处理这种罕见的父进程和子进程同时退出的情况。

2267
01:09:29,550 --> 01:09:31,770
0,180 180,900 1140,1620 1620,1770 1770,2220
this rare case of concurrent

2268
01:09:31,770 --> 01:09:32,820
0,420 420,510 510,600 600,960 960,1050
exits of a parent and

2269
01:09:32,820 --> 01:09:33,900
0,600
child.|
|

2270
01:09:33,960 --> 01:09:35,760
0,450 750,1200 1350,1530 1530,1590 1590,1800
{} And if it weren't
如果不是因为这个，

2271
01:09:35,760 --> 01:09:36,750
0,120 120,480 570,720 720,840 840,990
for that,| it would all
|那么这一切都会非常简单，

2272
01:09:36,750 --> 01:09:38,520
0,90 90,510 510,1230 1230,1650 1650,1770
be extremely straightforward,| {a,parent}, the
|进程有一个父进程，

2273
01:09:38,520 --> 01:09:39,780
0,390 390,480 480,600 600,690 690,1260
process would have a parent|
|

2274
01:09:39,930 --> 01:09:41,640
0,450 480,720 720,840 840,1200 1230,1710
and it would just wake
它只需要在这里唤醒它的父进程。

2275
01:09:41,640 --> 01:09:42,570
0,150 150,300 300,660 660,750 750,930
up its parent at this

2276
01:09:42,570 --> 01:09:43,700
0,540
point.|
|

2277
01:09:43,700 --> 01:09:44,780
0,360

2278
01:09:45,660 --> 01:09:47,060
0,780
And,
而且，我们不会，

2279
01:09:47,810 --> 01:09:49,190
0,270 270,570 660,960 990,1170 1170,1380
we wouldn't,| {} it were
|它是对于父进程和子进程同时退出的。

2280
01:09:49,190 --> 01:09:50,450
0,150 150,540 540,900 900,960 960,1260
for concurrent exits a parent

2281
01:09:50,450 --> 01:09:51,720
0,90 90,720
and child.|
|

2282
01:09:51,780 --> 01:09:52,740
0,150 150,450 450,540 540,780 780,960
The child could just wake
子进程可以唤醒父进程。

2283
01:09:52,740 --> 01:09:54,810
0,120 120,300 300,840 1200,1680 1710,2070
up its parent period.| Okay,
|好的，我明白了，谢谢。

2284
01:09:54,810 --> 01:09:56,730
0,180 180,450 450,780 780,1200 1230,1920
I see, thank you.| Sorry
|抱歉，我不能解释更多了。

2285
01:09:56,730 --> 01:09:57,930
0,180 210,420 420,630 630,720 720,1200
to not really be explaining

2286
01:09:57,930 --> 01:09:58,760
0,240
here.|
|

2287
01:09:59,510 --> 01:10:00,320
0,300 330,450 450,570 570,630 630,810
{} I have a quick
我有一个简短的问题，

2288
01:10:00,320 --> 01:10:02,450
0,510 1050,1410 1410,1650 1650,1950 1950,2130
question,| {} so why are
|为什么我们要在唤醒父进程之后将进程状态设置为僵尸状态，

2289
01:10:02,450 --> 01:10:04,580
0,180 180,540 540,900 1290,1770 1770,2130
we setting the process state

2290
01:10:04,580 --> 01:10:06,140
0,90 90,660 660,1170 1170,1320 1320,1560
to zombie after we wake

2291
01:10:06,140 --> 01:10:08,240
0,210 210,630 690,1410 1560,1920 1920,2100
up the parent,| we want
|我们想在此之前这么做。

2292
01:10:08,240 --> 01:10:10,250
0,60 60,210 210,540 690,1380 1620,2010
to do that before.| Oh
|哦，是的，是因为我们获得了，

2293
01:10:10,250 --> 01:10:11,680
0,870
yeah,

2294
01:10:12,210 --> 01:10:14,580
0,210 210,480 480,600 600,1860 2160,2370
it turns out because we've

2295
01:10:14,580 --> 01:10:16,080
0,600 600,870
acquired the,|
|

2296
01:10:16,170 --> 01:10:18,300
0,330 420,810 810,1410 1410,1560 1560,2130
the existing processes that required
现有进程获取了自己进程锁，

2297
01:10:18,300 --> 01:10:20,220
0,180 180,360 360,960 960,1410 1680,1920
its own process lock,| the
|父进程不能看到这个进程。

2298
01:10:20,220 --> 01:10:21,330
0,360 360,660 660,870 870,930 930,1110
parent can't look at this

2299
01:10:21,330 --> 01:10:22,760
0,900
process.|
|

2300
01:10:22,760 --> 01:10:25,310
0,480 1110,1350 1350,1770 1770,2460 2460,2550
And we've acquired our own
我们在这里获得了自己的锁，

2301
01:10:25,310 --> 01:10:26,090
0,270 270,540 540,630 630,720 720,780
lock here| and then we're
|然后我们调用 sched ，

2302
01:10:26,090 --> 01:10:27,290
0,120 120,180 180,360 360,930 930,1200
going to call sched,| the
|父进程需要等待子进程的锁，也就是 p->lock ，

2303
01:10:27,320 --> 01:10:28,460
0,660
parent,

2304
01:10:28,490 --> 01:10:30,980
0,240 540,900 900,1350 1380,2070 2070,2490
is parents wait acquires p->

2305
01:10:31,220 --> 01:10:32,900
0,450 450,570 570,1080 1080,1470 1470,1680
requires the child's lock, which

2306
01:10:32,900 --> 01:10:35,180
0,360 390,750 750,1260 1650,2190 2190,2280
is {p->lock -}| and so
|这意味着在这个获取

2307
01:10:35,180 --> 01:10:36,350
0,180 180,330 330,480 480,1020 1020,1170
that means that between this

2308
01:10:36,350 --> 01:10:39,230
0,720 780,1500 1590,2370 2400,2760 2760,2880
acquire| and when after we
|和我们调用 sched 之后，调度器线程释放 p->lock 之间，

2309
01:10:39,230 --> 01:10:40,790
0,240 240,630 630,750 750,810 810,1560
call sched and the scheduler

2310
01:10:40,790 --> 01:10:43,280
0,300 300,1230 1350,1710 1710,2100 2100,2490
thread releases this {p->lock -},|
|

2311
01:10:43,340 --> 01:10:44,870
0,180 180,540 540,900 900,1320 1350,1530
the parent can't look at
在这块代码中，父进程不能看到这个进程。

2312
01:10:44,870 --> 01:10:46,720
0,180 180,720 720,900 900,1410
this process in this

2313
01:10:46,780 --> 01:10:48,790
0,330 360,690 690,780 780,1500 1530,2010
{} block of code.| Okay.|
|好的。|

2314
01:10:48,940 --> 01:10:49,870
0,240 240,360 360,690 690,780 780,930
So the order of this
所以这些东西的顺序并不重要，

2315
01:10:49,870 --> 01:10:52,620
0,570 960,1350 1350,1620 1620,2190
stuff doesn't matter,| indeed
|事实上，如果我们没有锁，

2316
01:10:52,910 --> 01:10:54,170
0,540 570,840 840,930 930,1140 1140,1260
{} if we didn't have

2317
01:10:54,170 --> 01:10:55,260
0,90 90,540
the {lock,up},|
|

2318
01:10:55,350 --> 01:10:57,510
0,210 210,810 810,1080 1080,1530 1890,2160
it's possible some other.| Well,
也有可能其他的。|在大多数情况下，如果我们不持有锁，任何顺序都不会起作用。

2319
01:10:58,810 --> 01:11:01,390
0,870 870,1080 1080,2070 2070,2310 2310,2580
in most situations, no order

2320
01:11:01,390 --> 01:11:02,890
0,180 180,780 990,1200 1200,1290 1290,1500
would work if we didn't

2321
01:11:02,890 --> 01:11:04,340
0,210 210,300 300,900
hold the lock.|
|

2322
01:11:04,520 --> 01:11:05,720
0,690

2323
01:11:06,530 --> 01:11:07,580
0,360 360,600 600,840 840,900 900,1050
Anyway, yeah because we hold
不管怎样，是的，因为我们有一把锁，顺序无关紧要，

2324
01:11:07,580 --> 01:11:09,050
0,60 60,390 390,660 990,1170 1170,1470
a lock, that the order

2325
01:11:09,050 --> 01:11:10,130
0,390 390,570 570,720 720,810 810,1080
doesn't matter,| because the parent
|因为父进程看不到。

2326
01:11:10,130 --> 01:11:11,930
0,210 210,630 990,1200 1200,1380 1380,1800
can't look.| That makes sense.|
|理解了。|

2327
01:11:19,020 --> 01:11:20,820
0,540 570,1170
Okay. {}|
好的。|

2328
01:11:21,980 --> 01:11:23,390
0,390 420,630 630,780 780,1140 1140,1410
{} Okay, so the trick
好的，我想强调的技巧是，

2329
01:11:23,390 --> 01:11:25,520
0,570 570,1260 1620,1800 1830,2100 2100,2130
here is the trick I

2330
01:11:25,520 --> 01:11:26,810
0,270 270,330 330,840 840,1020 1020,1290
wanted to emphasize was that,|
|

2331
01:11:27,290 --> 01:11:28,340
0,510

2332
01:11:29,150 --> 01:11:31,040
0,150 150,540 540,780 780,1230 1350,1890
to a great extent, actually
在很大程度上，子进程没有，

2333
01:11:31,430 --> 01:11:33,830
0,330 330,1020 1170,1770 2190,2310 2310,2400
the child doesn't,| in the
|最终，子进程并没有释放所有的资源，

2334
01:11:33,830 --> 01:11:34,730
0,150 150,210 210,450 450,720 720,900
end, the child doesnt free

2335
01:11:34,730 --> 01:11:35,930
0,120 120,270 270,930 930,1110 1110,1200
all its resources,| because it
|因为它不能，因为它仍在执行，

2336
01:11:35,930 --> 01:11:36,980
0,300 300,510 510,600 600,780 780,1050
can't, because it's still using

2337
01:11:36,980 --> 01:11:38,780
0,60 60,330 330,810 810,930 930,1800
the whole executes| and instead
|取而代之的是一些其他线程，也就是父线程

2338
01:11:39,080 --> 01:11:40,850
0,420 420,810 810,1350 1380,1680 1680,1770
some other thread, namely the

2339
01:11:40,850 --> 01:11:42,980
0,630 780,1470 1470,1560 1560,2040 2040,2130
parent| does the freeing of
|来释放执行所需的资源，

2340
01:11:42,980 --> 01:11:44,480
0,120 120,570 570,1140 1140,1320 1320,1500
the delicate resources that are

2341
01:11:44,600 --> 01:11:45,980
0,960
required

2342
01:11:45,980 --> 01:11:48,110
0,450 480,690 690,1290 1800,1950 1950,2130
{} for execution,| so that's
|所以这是一种技巧，

2343
01:11:48,110 --> 01:11:49,490
0,150 150,210 210,690 900,1260 1260,1380
sort of a trick| to
|让我们极大地简化了退出。

2344
01:11:49,490 --> 01:11:51,020
0,300 300,570 570,900
allow us to

2345
01:11:51,020 --> 01:11:53,810
0,600 900,1140 1140,1530 1530,2340 2370,2790
{} that greatly simplify exit.|
|

2346
01:11:56,080 --> 01:11:58,080
0,600 630,1440
Okay, {}
好的，我最后要看的是 kill ，

2347
01:11:58,080 --> 01:11:59,310
0,90 90,810 900,1050 1050,1110 1110,1230
the last thing I want

2348
01:11:59,310 --> 01:12:00,270
0,60 60,180 180,270 270,390 390,960
to look at is kill,|
|

2349
01:12:00,690 --> 01:12:02,580
0,510 630,870 870,1200 1260,1500 1500,1890
{} so that you know
你知道 kill 系统调用，

2350
01:12:02,580 --> 01:12:04,290
0,90 90,390 390,750 750,1170 1380,1710
the kill system call, {}|
|

2351
01:12:04,290 --> 01:12:06,180
0,300 300,990 990,1110 1110,1590 1590,1890
one process in Unix can
在 Unix 中，可以调用 kill 系统调用，

2352
01:12:06,360 --> 01:12:07,410
0,330 330,480 480,630 630,750 750,1050
call that make the kill

2353
01:12:07,410 --> 01:12:09,420
0,330 330,840 1110,1470 1470,1530 1530,2010
system call,| passes the process
|传递另一个进程的进程 id ，

2354
01:12:09,420 --> 01:12:11,040
0,300 300,360 360,450 450,900 900,1620
id of a different process|
|

2355
01:12:11,280 --> 01:12:12,570
0,390 390,480 480,780 780,1050 1050,1290
and the goal is that|
目标是，|

2356
01:12:12,660 --> 01:12:14,010
0,360 360,480 480,720 720,960 1020,1350
that should cause that other
导致另一个进程，目标进程停止执行。

2357
01:12:14,010 --> 01:12:15,810
0,540 540,630 630,990 990,1560 1590,1800
process, the target process to

2358
01:12:15,810 --> 01:12:17,360
0,450 480,1110
stop executing.|
|

2359
01:12:17,510 --> 01:12:19,490
0,450 600,1170 1440,1740 1740,1800 1800,1980
{} And if we're not
如果我们一不小心，

2360
01:12:19,490 --> 01:12:21,320
0,540 540,630 630,720 720,1080 1080,1830
careful,| you know this risks
|这有风险，特别是如果内核中执行的其他进程，

2361
01:12:21,350 --> 01:12:23,060
0,390 390,480 480,720 720,1260 1260,1710
especially if other processes executing

2362
01:12:23,060 --> 01:12:24,340
0,90 90,180 180,690
in the kernel,|
|

2363
01:12:24,560 --> 01:12:27,320
0,630 1620,2070 2070,2310 2310,2430 2430,2760
{} this risk is probably
这个风险可能在几分钟前就提到了，

2364
01:12:27,320 --> 01:12:28,370
0,300 300,360 360,510 510,780 780,1050
mentioned a few minutes ago,|
|

2365
01:12:28,370 --> 01:12:30,320
0,420 540,1080 1080,1320 1740,1890 1890,1950
where gosh that you know
你想杀死的进程的内核线程，

2366
01:12:30,320 --> 01:12:31,250
0,120 120,450 450,780 780,840 840,930
the kernel thread of the

2367
01:12:31,250 --> 01:12:32,240
0,390 390,510 510,690 690,750 750,990
process you're trying to kill|
|

2368
01:12:32,240 --> 01:12:33,350
0,240 450,690 720,840 840,930 930,1110
might might in the middle
可能正在更新一些东西，

2369
01:12:33,350 --> 01:12:34,610
0,60 60,480 480,990 990,1110 1110,1260
of updating something,| you know
|比如，更新文件系统，创建文件，

2370
01:12:34,610 --> 01:12:36,050
0,330 330,390 390,690 690,1020 1020,1440
updating the file system, creating

2371
01:12:36,050 --> 01:12:37,490
0,90 90,480 480,630 630,1140 1200,1440
a file, for example| and
|我们不能直接杀死它，

2372
01:12:37,490 --> 01:12:38,540
0,90 90,330 330,690 690,930 930,1050
we can't just kill it

2373
01:12:38,540 --> 01:12:40,700
0,600 630,1020 1020,1080 1080,1650 1650,2160
dead on the spot,| because
|因为这将使一些多步骤操作只完成一半。

2374
01:12:40,730 --> 01:12:42,710
0,300 300,450 450,780 780,1230 1230,1980
that would leave some delicate

2375
01:12:43,070 --> 01:12:45,020
0,300 300,540 540,1080 1080,1440 1440,1950
multi step operation only halfway

2376
01:12:45,020 --> 01:12:46,080
0,690
completed.|
|

2377
01:12:46,200 --> 01:12:47,280
0,270 270,480 480,600 600,930 930,1080
Now, so we know that
现在，我们知道 kill 不能真正停止目标进程，

2378
01:12:47,280 --> 01:12:48,720
0,720
kill

2379
01:12:48,720 --> 01:12:50,520
0,360 360,870 870,1230 1230,1680 1680,1800
can't really just stop the

2380
01:12:50,520 --> 01:12:54,600
0,450 450,1410 1830,2340 2730,3480 3630,4080
target process,| and indeed in
|事实上，在 xv6 中，在 Unix 中也是如此，

2381
01:12:54,600 --> 01:12:56,250
0,150 150,600 600,900 1140,1230 1230,1650
{xv6 -} and the Unix

2382
01:12:56,250 --> 01:12:57,990
0,150 150,600 720,1020 1020,1470 1470,1740
as well,| {} kill does
|kill 几乎不会做什么事情，

2383
01:12:58,620 --> 01:13:01,770
0,480 480,990 990,1470 2430,2700 2700,3150
almost absolutely nothing,| it scans
|它扫描进程表，查找目标进程 id ，

2384
01:13:01,770 --> 01:13:03,090
0,90 90,480 480,810 810,1140 1140,1320
the process table looking for

2385
01:13:03,090 --> 01:13:05,130
0,300 540,900 900,1290 1290,1710 1770,2040
the target process id| and
|只是在进程的进程结构中设置这个标志，

2386
01:13:05,130 --> 01:13:07,560
0,360 360,690 690,960 960,1890
just sets this flag

2387
01:13:07,780 --> 01:13:10,420
0,780 930,1050 1050,1260 1260,2160 2190,2640
{} in that process's process

2388
01:13:10,420 --> 01:13:11,580
0,690
structure,|
|

2389
01:13:12,000 --> 01:13:12,990
0,360 360,660 660,780 780,870 870,990
and also, if it was
而且，如果它处于睡眠状态，调用到可运行，

2390
01:13:12,990 --> 01:13:15,720
0,660 1170,1770 2100,2460 2460,2580 2580,2730
sleeping, {} calls to be

2391
01:13:15,720 --> 01:13:16,800
0,420 420,600 600,750 750,960 960,1080
runnable,| so to wake up
|从睡眠中唤醒，

2392
01:13:16,800 --> 01:13:18,000
0,180 180,600 600,810 840,1140 1140,1200
from sleep,| but all it
|它所做的就是设置这个标志，

2393
01:13:18,000 --> 01:13:19,080
0,180 180,270 270,450 450,630 630,1080
does is set this flag,|
|

2394
01:13:19,110 --> 01:13:20,310
0,300 300,600 600,960 960,1050 1050,1200
it doesn't stop the other
它不会停止另一个进程的执行或任何类似的操作。

2395
01:13:20,310 --> 01:13:23,220
0,390 390,660 840,2100 2280,2550 2550,2910
process from executing or anything

2396
01:13:23,220 --> 01:13:24,140
0,270 270,390
like it.|
|

2397
01:13:24,400 --> 01:13:26,020
0,600

2398
01:13:26,490 --> 01:13:28,560
0,330 330,1260
Kill itself
kill 是非常温和的，

2399
01:13:28,650 --> 01:13:30,480
0,360 360,720 720,1260
{} very gentle,|
|

2400
01:13:30,790 --> 01:13:33,730
0,600 1890,2100 2100,2400 2400,2610 2610,2940
{} the game is that,|
游戏是，|

2401
01:13:33,730 --> 01:13:36,520
0,120 120,510 510,1350 1380,1740 2280,2790
the target process at points
目标进程在内核代码中，

2402
01:13:36,520 --> 01:13:38,050
0,120 120,210 210,630 630,1170 1170,1530
in the kernel code| where
|在那里会安全地停止执行，

2403
01:13:38,050 --> 01:13:39,220
0,120 120,270 270,420 420,1050 1050,1170
it would be safe to

2404
01:13:39,220 --> 01:13:40,940
0,330 330,1200
stop executing,|

2405
01:13:41,170 --> 01:13:43,540
0,420 450,720 720,1410 1440,2130 2130,2370
the other process checks its
另一个进程检查它自己的终止标志，

2406
01:13:43,570 --> 01:13:45,370
0,450 450,870 870,1530 1560,1710 1710,1800
own killed flag,| and if
|如果设置了，

2407
01:13:45,370 --> 01:13:47,380
0,180 180,720 810,1050 1050,1260 1260,2010
it's set,| the other process
|其他进程会自动退出，调用 exit 函数，

2408
01:13:47,440 --> 01:13:50,650
0,180 180,300 300,1410 1650,2220 2850,3210
sort of voluntarily exits, calls

2409
01:13:50,650 --> 01:13:52,810
0,210 210,540 540,930 1590,2040 2040,2160
this exit function| and you
|你可以在 trap.c 上看到其中的一些点，

2410
01:13:52,810 --> 01:13:53,620
0,90 90,330 330,510 510,570 570,810
can see some of those

2411
01:13:53,620 --> 01:13:54,860
0,750
points

2412
01:13:54,860 --> 01:13:57,050
0,630 630,900 900,1440 1830,1920 1920,2190
at {trap.c -},| in fact
|实际上，你可以在 trap.c 中看到所有的点，

2413
01:13:57,050 --> 01:13:57,560
0,60 60,150 150,270 270,450 450,510
you can see all the

2414
01:13:57,560 --> 01:14:00,560
0,630 1110,1440 1440,1650 1650,2130 2430,3000
points {trap.c - -}, {}|
|

2415
01:14:01,400 --> 01:14:02,270
0,300 300,390 390,540 540,660 660,870
so if we're in {usertrap
所以，如果我们在 usertrap 中，

2416
01:14:02,270 --> 01:14:03,530
0,90 90,600 600,840 840,900 900,1260
- -}| in a system
|在实际执行系统调用之前，

2417
01:14:03,530 --> 01:14:05,930
0,570 900,1200 1200,1620 1620,1920 1920,2400
call, {} before actually executing

2418
01:14:05,930 --> 01:14:06,920
0,60 60,390 390,660 690,870 870,990
the system call,| if the
|如果进程已被终止，

2419
01:14:06,920 --> 01:14:08,570
0,420 420,570 570,810 810,960 960,1650
process has already been killed|
|

2420
01:14:08,840 --> 01:14:10,250
0,360 450,660 660,990 990,1200 1200,1410
or if kill has been
或者如果在这个进程调用了 kill ，

2421
01:14:10,550 --> 01:14:12,320
0,390 390,510 510,690 690,1260 1500,1770
called for this process,| then
|然后进程调用 exit 并离开。

2422
01:14:12,320 --> 01:14:13,790
0,90 90,480 480,810 810,1230 1290,1470
the process calls exit and

2423
01:14:13,790 --> 01:14:14,920
0,210 210,720
goes away.|
|

2424
01:14:15,180 --> 01:14:16,080
0,270 270,390 390,510 510,570 570,900
And this is a point
这是内核中的一个点，没有持有任何锁，

2425
01:14:16,080 --> 01:14:17,040
0,150 150,360 390,690 690,810 810,960
in the kernel where it's

2426
01:14:17,040 --> 01:14:18,180
0,150 150,420 420,600 600,990 990,1140
not holding any locks,| it's
|它没有在做任何事情，

2427
01:14:18,180 --> 01:14:18,810
0,180 180,240 240,330 330,570 570,630
not in the middle of

2428
01:14:18,810 --> 01:14:20,940
0,300 300,930 1380,1830 1830,1980 1980,2130
doing anything,| and so it's
|所以，进程是安全的，只需退出并调用 exit 。

2429
01:14:20,940 --> 01:14:22,320
0,330 330,750 750,840 840,930 930,1380
completely safe for the process

2430
01:14:22,320 --> 01:14:24,720
0,120 120,600 900,1830 2010,2160 2160,2400
to just quit and call

2431
01:14:24,720 --> 01:14:25,580
0,330
exit.|
|

2432
01:14:26,230 --> 01:14:28,210
0,450 900,1290 1290,1470 1470,1560 1560,1980
{} And there's a similar
在 usertrap 末尾有一个类似的检查。

2433
01:14:28,210 --> 01:14:30,250
0,630 990,1260 1260,1410 1410,1590 1590,2040
check, {} at the end

2434
01:14:30,250 --> 01:14:31,960
0,300 300,600 600,1200
of {usertrap -}.|
|

2435
01:14:31,990 --> 01:14:33,120
0,630

2436
01:14:33,920 --> 01:14:35,540
0,240 240,570 570,630 630,990 990,1620
So after a system call,
所以，在系统调用之后，进程还会检查它是否被终止，

2437
01:14:37,470 --> 01:14:38,520
0,150 150,480 480,690 690,960 960,1050
the process also checks if

2438
01:14:38,520 --> 01:14:40,110
0,150 150,330 330,840 900,1110 1110,1590
it's being killed| and indeed
|实际上，这段代码会执行，

2439
01:14:40,140 --> 01:14:43,020
0,330 330,690 690,1260
this code here

2440
01:14:43,200 --> 01:14:45,900
0,990 1230,1440 1440,2130 2160,2280 2280,2700
executes,| even if the process
|即使进程被中断打断，

2441
01:14:45,900 --> 01:14:47,610
0,330 360,900 900,1020 1020,1140 1140,1710
is interrupted by an interrupt,|
|

2442
01:14:47,610 --> 01:14:48,870
0,210 210,360 360,750 750,840 840,1260
so for example the timer
比如，定时器中断关闭，

2443
01:14:48,870 --> 01:14:51,840
0,360 360,570 570,1020 1290,2070 2700,2970
interrupt goes off,| then this
|然后，这段代码会执行，

2444
01:14:51,840 --> 01:14:53,100
0,210 210,330 330,990 990,1140 1140,1260
code will execute| and we'll
|我们会看到这个进程已被终止，

2445
01:14:53,100 --> 01:14:54,600
0,420 420,540 540,630 630,1320 1320,1500
see that the process has

2446
01:14:54,600 --> 01:14:55,530
0,90 90,540 540,660 660,840 840,930
been killed| and then the
|然后这个进程将会退出。

2447
01:14:55,530 --> 01:14:58,340
0,450 450,600 600,900
process will exit.|
|

2448
01:14:59,350 --> 01:15:00,850
0,180 180,450 480,1080 1080,1200 1200,1500
And so what that means
所以，这意味着，

2449
01:15:00,850 --> 01:15:02,410
0,120 120,330 330,780 840,1230 1230,1560
is| that the what kill
|kill 的意思是，

2450
01:15:02,410 --> 01:15:04,930
0,1020 1080,1590 1710,1860 1860,2400 2400,2520
means, kill the meaning of

2451
01:15:04,930 --> 01:15:06,280
0,390 390,480 480,870 870,1140 1140,1350
kill,| the effective kill is
|kill 的作用不是直接停止其他进程，

2452
01:15:06,280 --> 01:15:08,050
0,240 240,960 990,1500 1500,1620 1620,1770
not exactly stop the other

2453
01:15:08,050 --> 01:15:09,620
0,420 420,660 660,1050
process right now,|
|

2454
01:15:09,650 --> 01:15:11,720
0,240 240,480 480,690 690,1170 1380,2070
it's much more like,| well
而更像是，|如果用户空间中的其他进程，

2455
01:15:12,080 --> 01:15:13,190
0,240 240,540 570,750 750,840 840,1110
you know if the process

2456
01:15:13,190 --> 01:15:14,900
0,240 240,750 750,900 900,1170 1170,1710
other processes in user space,|
|

2457
01:15:14,900 --> 01:15:16,010
0,480 540,690 690,900 900,1020 1020,1110
then the next time it
然后下一次它进行系统调用时，

2458
01:15:16,010 --> 01:15:17,900
0,210 210,270 270,750 750,1410
makes a system call,|
|

2459
01:15:18,500 --> 01:15:20,720
0,120 120,300 300,1110 1800,2130 2130,2220
it will exit| or the
它会退出，|或者下一次定时器中断发生时，

2460
01:15:20,720 --> 01:15:21,980
0,240 240,390 390,420 420,840 840,1260
next time a timer interrupt

2461
01:15:21,980 --> 01:15:23,840
0,210 210,510 510,1020 1050,1590 1590,1860
goes off| while executing user
|当目标进程执行其他用户代码时，

2462
01:15:23,840 --> 01:15:26,240
0,450 450,630 630,990 1230,1680 1680,2400
code in the target process,|
|

2463
01:15:26,360 --> 01:15:27,350
0,150 150,270 270,720 720,900 900,990
if it's interrupted by a
如果它被定时器中断或其他中断中断，

2464
01:15:27,350 --> 01:15:28,550
0,360 360,750 750,780 780,960 960,1200
timer interrupt or some other

2465
01:15:28,550 --> 01:15:30,440
0,510 660,1020 1020,1080 1080,1200 1200,1890
interrupt,| then it will also
|那么它也会退出。

2466
01:15:30,470 --> 01:15:31,550
0,450 450,600 600,810 810,990 990,1080
exit.| So there might be
|所以，这里可能会有明显的延迟，

2467
01:15:31,550 --> 01:15:33,710
0,210 300,780 780,1110 1110,1650 1680,2160
a significant delay,| between when
|在一个进程调用 kill 和另一个进程实际退出。

2468
01:15:33,710 --> 01:15:35,720
0,240 240,660 660,930 930,1440
one process calls kill

2469
01:15:35,750 --> 01:15:36,650
0,330 330,480 480,600 600,720 720,900
{} and when the other

2470
01:15:36,650 --> 01:15:39,080
0,420 420,1050 1050,1830
process actually exits.|
|

2471
01:15:39,440 --> 01:15:40,370
0,360 360,600 600,750 750,810 810,930
And that's just the way
事情就是这样的。

2472
01:15:40,370 --> 01:15:43,180
0,90 90,540 1590,2250
it is. {}|
|

2473
01:15:43,180 --> 01:15:44,120
0,450

2474
01:15:44,420 --> 01:15:45,530
0,270 270,330 330,540 540,600 600,1110
There's a sort of intermediate
虽然有一个中间问题，

2475
01:15:45,530 --> 01:15:47,330
0,450 450,960 1170,1320 1320,1410 1410,1800
question| though if the process
|如果进程没有在自己的用户空间，

2476
01:15:47,330 --> 01:15:48,560
0,180 180,630 630,780 780,990 990,1230
is not in use, it's

2477
01:15:48,560 --> 01:15:49,760
0,180 180,450 450,930 930,1080 1080,1200
own user space,| but is
|而是在进行系统调用中，

2478
01:15:49,760 --> 01:15:50,270
0,90 90,180 180,360 360,450 450,510
in the middle of a

2479
01:15:50,270 --> 01:15:52,920
0,420 420,1080
system call,|
|

2480
01:15:53,180 --> 01:15:54,890
0,150 150,300 300,1140 1470,1590 1590,1710
and it's killed,| do we
它被杀死，|我们需要做些什么特别的事情吗？

2481
01:15:54,890 --> 01:15:56,240
0,180 180,240 240,330 330,630 630,1350
need to do anything special?|
|

2482
01:15:57,110 --> 01:15:58,070
0,150 150,360 360,480 480,660 660,960
The reason why this may
可能会出现这种情况的原因是，

2483
01:15:58,280 --> 01:16:00,380
0,270 270,930 990,1350 1350,1560 1560,2100
come up {} is,| suppose
|假设进程正在从控制台读取，

2484
01:16:00,380 --> 01:16:01,760
0,90 90,600 600,750 750,1200 1200,1380
the process is reading from

2485
01:16:01,760 --> 01:16:03,120
0,60 60,1020
the console,

2486
01:16:03,150 --> 01:16:04,470
0,390 450,810 810,930 930,1200 1200,1320
right,| you know reading for
|读取你输入的下一个字符，

2487
01:16:04,470 --> 01:16:05,550
0,60 60,270 270,690 690,840 840,1080
the next character you type,|
|

2488
01:16:05,550 --> 01:16:06,540
0,240 240,330 330,570 570,750 750,990
you may not type another
你可能知道明天都不会输入另一个字符。

2489
01:16:06,540 --> 01:16:08,440
0,450 450,720 720,1290
character until tomorrow.|

2490
01:16:08,440 --> 01:16:09,160
0,300 300,480 480,540 540,630 630,720
{} And it would be
这是可以的，如果你终止进程，

2491
01:16:09,160 --> 01:16:10,810
0,660 660,840 1200,1350 1350,1440 1440,1650
nice if when you kill

2492
01:16:10,810 --> 01:16:12,460
0,90 90,570 570,720 1050,1440 1440,1650
the process,| it actually went
|它实际上在明天之前就消失了。

2493
01:16:12,460 --> 01:16:14,640
0,600 600,960 960,1560
away before tomorrow.|
|

2494
01:16:14,640 --> 01:16:15,820
0,630

2495
01:16:15,970 --> 01:16:18,430
0,330 330,720 720,1050 1050,1680 2100,2460
And for that reason, in
所以，在 xv6 的很多点上。

2496
01:16:18,430 --> 01:16:19,420
0,60 60,360 360,450 450,840 840,990
a number of points in

2497
01:16:19,420 --> 01:16:20,620
0,210 210,360 360,870 870,990 990,1200
{xv6 - -}| in which
|当进程在睡眠中，

2498
01:16:20,620 --> 01:16:23,710
0,90 90,600 600,870 960,1590 1950,3090
a process is {} sleeping,|
|

2499
01:16:24,320 --> 01:16:25,880
0,300 300,450 450,720 720,1050 1050,1560
{xv6 - -} actually arranges
xv6 会安排，

2500
01:16:25,880 --> 01:16:27,350
0,120 120,240 240,420 420,1050 1050,1470
that,| if it's killed while
|如果它在内核中睡眠时被杀死，

2501
01:16:27,350 --> 01:16:29,420
0,420 420,510 510,600 600,1260 1380,2070
sleeping in the kernel, {}|
|

2502
01:16:29,990 --> 01:16:32,120
0,210 210,630 630,1050 1050,1590 1740,2130
it will actually exit.| So,
它实际上会退出。|让我来展示一下这个机制，

2503
01:16:32,150 --> 01:16:32,840
0,270 270,330 330,480 480,630 630,690
let me show you the

2504
01:16:32,840 --> 01:16:34,480
0,600 600,720 720,1080
machinery for that,|
|

2505
01:16:34,760 --> 01:16:35,570
0,270 270,390 390,630 630,750 750,810
{} the first thing to
首先要看的就是 kill 本身。

2506
01:16:35,570 --> 01:16:36,530
0,210 210,360 360,510 510,660 660,960
look at is in kill

2507
01:16:36,530 --> 01:16:37,940
0,810
itself.|
|

2508
01:16:39,020 --> 01:16:40,580
0,480 510,690 690,810 810,1170 1170,1560
{} You can see that
你可以看到，如果目标进程处于睡眠状态，

2509
01:16:41,180 --> 01:16:42,350
0,210 210,330 330,660 660,1080 1080,1170
if the target process is

2510
01:16:42,350 --> 01:16:43,720
0,810
sleeping,|
|

2511
01:16:43,720 --> 01:16:44,980
0,210 210,570 570,660 660,930 930,1260
then kill will set state
然后 kill 会将状态设置为可运行，

2512
01:16:44,980 --> 01:16:46,570
0,120 120,660 960,1200 1200,1380 1380,1590
to runnable| and that'll mean
|这意味着即使它调用了 sleep ，

2513
01:16:46,570 --> 01:16:47,320
0,180 210,480 480,570 570,630 630,750
that even if it had

2514
01:16:47,320 --> 01:16:48,720
0,330 330,870
called sleep,|
|

2515
01:16:48,750 --> 01:16:49,890
0,120 120,540 540,660 660,900 900,1140
the scheduler will now run
调度器现在也会运行它，

2516
01:16:49,890 --> 01:16:50,970
0,180 210,390 390,570 660,810 810,1080
it| and it will simply
|它会简单地从睡眠中恢复过来。

2517
01:16:50,970 --> 01:16:52,800
0,510 510,690 690,1350
return from sleep.|
|

2518
01:16:52,800 --> 01:16:54,270
0,480 780,990 990,1140 1140,1350 1350,1470
{} And so let's look
所以让我们来看看一个真正重要的地方，

2519
01:16:54,270 --> 01:16:56,010
0,90 90,120 120,450 450,1050 1560,1740
at a place where that

2520
01:16:56,010 --> 01:16:57,420
0,240 240,840 840,960 960,1050 1050,1410
actually matters,| in the pipe
|在管道代码中，如果进程处于睡眠状态，等待读取管道，

2521
01:16:57,420 --> 01:16:59,640
0,570 1110,1500 1530,1710 1710,1770 1770,2220
code, {} if a process

2522
01:16:59,640 --> 01:17:01,140
0,150 150,480 510,1140 1140,1410 1410,1500
is in sleep waiting to

2523
01:17:01,140 --> 01:17:02,500
0,180 180,240 240,870
read a pipe,|
|

2524
01:17:03,390 --> 01:17:04,920
0,960

2525
01:17:05,190 --> 01:17:07,200
0,210 210,390 390,1230 1350,1800 1800,2010
and it's killed, kill set
它被杀死， kill 设置从睡眠到可运行，

2526
01:17:07,200 --> 01:17:08,340
0,120 120,390 390,420 420,690 690,1140
to {runnable - -} return

2527
01:17:08,340 --> 01:17:09,660
0,150 150,630 720,990 990,1230 1230,1320
from sleep,| go back to
|回到这个循环的顶部，

2528
01:17:09,660 --> 01:17:10,770
0,60 60,330 330,390 390,570 570,1110
the top of this loop,|
|

2529
01:17:11,310 --> 01:17:12,840
0,870 1050,1200 1200,1290 1290,1410 1410,1530
probably if there was no
如果在管道中没有数据，

2530
01:17:12,840 --> 01:17:13,830
0,240 240,330 330,390 390,600 600,990
data in the pipe,| before
|在管道中仍然没有数据，

2531
01:17:13,830 --> 01:17:14,640
0,90 90,360 360,600 600,690 690,810
the pi-, still be no

2532
01:17:14,640 --> 01:17:16,380
0,240 240,360 360,450 450,990 1140,1740
data in the pipe,| and
|现在， piperead 会检查进程是否已被终止，

2533
01:17:16,380 --> 01:17:19,050
0,720 1440,1950 1950,2190 2190,2280 2280,2670
now {piperead -} at least

2534
01:17:19,050 --> 01:17:21,000
0,630 630,930 930,1050 1050,1740 1770,1950
checks whether the process has

2535
01:17:21,000 --> 01:17:22,260
0,120 120,720 840,1080 1080,1170 1170,1260
been killed| and if it
|如果它已经被杀死，

2536
01:17:22,260 --> 01:17:23,190
0,210 210,330 330,630 630,870 870,930
has been killed,| instead of
|不是再次睡眠，

2537
01:17:23,190 --> 01:17:24,900
0,360 360,930 1110,1260 1260,1530 1530,1710
sleeping again,| the {piperead -}
|piperead 会返回一个错误，并不重要，

2538
01:17:24,900 --> 01:17:27,240
0,120 120,900 1140,1620 1890,2250 2250,2340
will return {} return an

2539
01:17:27,240 --> 01:17:28,800
0,330 330,540 540,720 720,1170 1200,1560
error, doesn't really matter,| but
|但我们要回到的是这个系统调用，

2540
01:17:28,800 --> 01:17:32,130
0,270 270,1020 1020,1650 1920,2760 3000,3330
we're returning to is {}

2541
01:17:32,160 --> 01:17:33,840
0,450 510,930 930,1380 1380,1560 1560,1680
this {syscall -},| since we're
|因为我们在系统调用中，

2542
01:17:33,840 --> 01:17:35,880
0,60 60,120 120,450 450,930 1230,2040
in a system call, {}|
|

2543
01:17:36,400 --> 01:17:38,110
0,360 360,750 750,990 990,1440 1440,1710
where pipe really returns to
管道最终返回系统调用，

2544
01:17:38,110 --> 01:17:39,340
0,210 210,330 330,570 570,810 810,1230
in the end is returns

2545
01:17:39,340 --> 01:17:41,230
0,120 120,210 210,600 600,1020 1260,1890
from the system call, {}|
|

2546
01:17:41,470 --> 01:17:43,420
0,300 300,960 990,1260 1260,1530 1530,1950
and then {} {usertrap -}
然后 usertrap 再次检查 p->killed ，

2547
01:17:43,660 --> 01:17:45,610
0,330 330,660 660,1050 1080,1650 1770,1950
checks {p->killed -} again| and
|现在可以退出了。

2548
01:17:45,610 --> 01:17:47,680
0,90 90,270 270,690 1200,1590 1590,2070
will now exit.| So for,
|所以，对于 sleep 来说，

2549
01:17:48,290 --> 01:17:51,230
0,270 270,1410 1500,2010 2070,2430 2430,2940
{} sleeps,| that we know
|我们知道[逃脱]是可以的，当它被杀死，

2550
01:17:51,230 --> 01:17:53,420
0,210 210,1140 1470,1620 1620,1830 1830,2190
it's okay to just bail

2551
01:17:53,420 --> 01:17:54,440
0,210 210,420 420,540 540,600 600,1020
out of when a process

2552
01:17:54,440 --> 01:17:56,780
0,150 150,840 1200,1920 1920,1920 1920,2340
is killed,| {those -} {loop's
|这些循环检查 killed 标志，

2553
01:17:56,780 --> 01:17:58,310
0,270 360,660 660,750 750,1080 1080,1530
-} check the killed flag,|
|

2554
01:17:58,340 --> 01:17:59,900
0,300 300,390 390,480 480,750 750,1560
but there are also sleeps
但也有 sleep 这样是不可以的，

2555
01:17:59,990 --> 01:18:00,920
0,150 150,210 210,360 360,720 720,930
where it would not be

2556
01:18:00,920 --> 01:18:03,410
0,690 1140,1680 1770,2010 2010,2370 2370,2490
okay,| for a process to
|对一个要退出的进程，

2557
01:18:03,410 --> 01:18:04,340
0,270 270,390 390,540 540,870 870,930
quit,| if it's killed in
|如果它在睡眠状态下被杀死。

2558
01:18:04,340 --> 01:18:05,520
0,210 210,780
that sleep.|
|

2559
01:18:05,990 --> 01:18:07,400
0,330 330,510 510,600 600,1050 1170,1410
{} So, for example if
比如，如果某个进程正在更新磁盘上的文件系统，

2560
01:18:07,400 --> 01:18:08,180
0,60 60,450 450,600 600,690 690,780
a process is in the

2561
01:18:08,180 --> 01:18:09,680
0,240 240,330 360,930 930,1020 1020,1500
middle of updating the file

2562
01:18:09,680 --> 01:18:10,970
0,390 390,570 570,900 900,960 960,1290
system on disk| to create
|要创建新文件，

2563
01:18:10,970 --> 01:18:12,560
0,60 60,180 180,780 960,1470 1470,1590
a new file| that is
|现在不是时候，

2564
01:18:12,560 --> 01:18:13,340
0,180
it

2565
01:18:13,340 --> 01:18:15,200
0,420 420,1110 1260,1620 1620,1710 1710,1860
bad time,| even if it's
|即使它在睡眠等待磁盘，

2566
01:18:15,200 --> 01:18:16,520
0,420 420,690 690,810 810,900 900,1320
sleeping waiting for the disk,|
|

2567
01:18:16,520 --> 01:18:17,720
0,180 180,240 240,540 540,1020 1050,1200
that's a bad time for
对于一个进程来说，现在不是退出的时候，

2568
01:18:17,720 --> 01:18:19,310
0,60 60,630 630,900 900,1200 1290,1590
a process to {} just

2569
01:18:19,310 --> 01:18:20,360
0,300 300,390 390,660 660,900 900,1050
decide to quit,| because it's
|因为它已经被杀死，

2570
01:18:20,360 --> 01:18:21,020
0,90 90,360 360,450 450,600 600,660
been killed,| we want to
|我们要完成完整的文件系统操作，

2571
01:18:21,020 --> 01:18:22,490
0,360 360,450 450,900 900,1170 1170,1470
finish the complete file system

2572
01:18:22,490 --> 01:18:24,410
0,630 750,1140 1140,1470 1470,1800 1800,1920
operation,| and only then have
|只有在那时进程才可以退出，

2573
01:18:24,410 --> 01:18:26,270
0,120 120,540 540,1050 1380,1740 1740,1860
the process exit,| {} and
|所以你可以看到这个，

2574
01:18:26,270 --> 01:18:27,230
0,120 120,240 240,360 360,570 570,960
so you can see this,|
|

2575
01:18:27,350 --> 01:18:28,580
0,300 300,570 570,660 660,990 990,1230
we've looked at this,| but
我们已经看过了，|但我将在磁盘驱动程序中展示。

2576
01:18:28,580 --> 01:18:29,640
0,540
{}

2577
01:18:29,930 --> 01:18:31,310
0,420 420,720 720,1020 1020,1170 1170,1380
I'll show you in the

2578
01:18:31,310 --> 01:18:33,800
0,660 660,960 1350,1890
disk driver. {}|
|

2579
01:18:33,960 --> 01:18:35,310
0,180 180,750 750,810 810,900 900,1350
An example of a sleep
睡眠循环的一个例子，

2580
01:18:35,310 --> 01:18:37,380
0,510 570,840 840,1140 1140,1440 1440,2070
loop,| that doesn't check killed,|
|不会检查 killed ，|

2581
01:18:37,590 --> 01:18:39,180
0,630 630,690 690,930
look at that,|
看那里,|

2582
01:18:40,720 --> 01:18:41,440
0,150 150,360 360,480 480,570 570,720
so here we are, this
所以在这里，这是 sleep ，

2583
01:18:41,440 --> 01:18:43,180
0,120 120,210 210,870 1290,1470 1470,1740
is the sleep| in which
|进程等待磁盘完成读取磁盘块，

2584
01:18:43,180 --> 01:18:45,380
0,330 330,750 780,1650
they {} process

2585
01:18:45,470 --> 01:18:46,520
0,390 390,510 510,630 630,960 960,1050
waits for the disk to

2586
01:18:46,520 --> 01:18:48,230
0,300 300,660 660,1020 1020,1290 1290,1710
finish reading a disk block,|
|

2587
01:18:48,290 --> 01:18:49,520
0,210 210,330 360,750 750,990 990,1230
and it absolutely doesn't check
它绝对不会检查 killed ，

2588
01:18:49,520 --> 01:18:50,720
0,540
killed,|
|

2589
01:18:50,750 --> 01:18:52,280
0,630 720,930 930,1020 1020,1260 1260,1530
{} because it wants to
因为它想要完成它，

2590
01:18:52,310 --> 01:18:53,690
0,930 960,1050 1050,1230 1230,1320 1320,1380
finish it,| maybe in the
|也许在创建文件的过程中，

2591
01:18:53,690 --> 01:18:54,860
0,240 240,420 420,780 780,870 870,1170
middle of creating a file,|
|

2592
01:18:54,860 --> 01:18:56,330
0,150 150,480 480,960 960,1260 1260,1470
which involves multiple disk reads
涉及多个磁盘读取和写入，

2593
01:18:56,330 --> 01:18:57,620
0,90 90,540 690,1020 1020,1080 1080,1290
and writes,| want to finish
|想要完成整个文件系统操作，

2594
01:18:57,620 --> 01:18:59,420
0,90 90,510 510,780 780,1080 1080,1800
the entire file system operation,|
|

2595
01:18:59,600 --> 01:19:01,640
0,180 180,480 480,810 810,1260 1650,2040
the entire system call| and
整个系统调用，|然后才检查 p->killed 并退出。

2596
01:19:01,730 --> 01:19:03,380
0,390 390,690 690,1050 1050,1410 1410,1650
only then check {p->killed -}

2597
01:19:03,380 --> 01:19:04,300
0,60 60,390
and exit.|
|

2598
01:19:06,990 --> 01:19:10,040
0,600 600,780 780,1290
Questions about anything?|
有什么问题吗？|

2599
01:19:10,820 --> 01:19:11,870
0,270 270,420 420,600 600,660 660,1050
{} I have a question,|
我有一个问题，|

2600
01:19:11,870 --> 01:19:14,480
0,510 540,900 900,1740 1860,2400 2400,2610
about why kill allowed in
为什么 kill 允许以这种方式，

2601
01:19:14,480 --> 01:19:15,800
0,90 90,300 300,390 390,810 1050,1320
the way it it,| why
|为什么进程不会杀死所有其他的进程，

2602
01:19:15,800 --> 01:19:17,240
0,270 270,330 330,1050 1050,1290 1290,1440
wouldn't the process kill all

2603
01:19:17,240 --> 01:19:18,680
0,90 90,420 420,720 720,1080 1080,1440
the other {processes -}| if
|你可以自己运行。

2604
01:19:18,710 --> 01:19:20,160
0,180 180,300 300,810
you can run,

2605
01:19:20,620 --> 01:19:22,340
0,450 480,630 630,1170
oh, by itself.|
|

2606
01:19:25,140 --> 01:19:26,100
0,420 420,540 540,690 690,840 840,960
Well, you know you do
你知道，如果你在麻省理工学院的 Athena 分时机器上这样做，

2607
01:19:26,100 --> 01:19:27,360
0,240 240,780 780,900 900,1050 1050,1260
that MIT on a {Athena

2608
01:19:27,360 --> 01:19:28,260
0,60 60,300 300,510 510,780 780,900
-} time sharing machine| will
|可能会把你赶出学校。

2609
01:19:28,260 --> 01:19:28,890
0,210 210,390 390,510 510,570 570,630
probably kick you out of

2610
01:19:28,890 --> 01:19:29,980
0,570
school.|
|

2611
01:19:31,490 --> 01:19:33,890
0,690 990,1350 1350,1740 1890,2310 2310,2400
{} Right, but why is
是的，但是为什么允许这样做呢？

2612
01:19:33,890 --> 01:19:36,290
0,150 150,930 1050,1740 1740,2130 2130,2400
it allowed.| It's allowed {in,xv6
|在 xv6 允许，因为 xv6 是一个玩具操作系统，

2613
01:19:36,290 --> 01:19:37,820
0,360 360,1050
-}, because

2614
01:19:37,910 --> 01:19:39,380
0,510 510,600 600,690 690,1050 1050,1470
xv6 is a toy operating

2615
01:19:39,380 --> 01:19:40,920
0,570 570,930
system,| that
|它只是

2616
01:19:41,960 --> 01:19:43,400
0,840
{}

2617
01:19:43,400 --> 01:19:44,900
0,330 330,690 690,900
it just the,|
|

2618
01:19:44,960 --> 01:19:46,130
0,420 420,540 540,750 750,840 840,1170
anything that has to do
在 xv6 中，任何与权限有关的东西都不存在，

2619
01:19:46,130 --> 01:19:47,400
0,570
with

2620
01:19:48,220 --> 01:19:50,830
0,180 180,1620 1830,2100 2100,2280 2280,2610
like permissions just doesn't exist

2621
01:19:50,830 --> 01:19:52,570
0,90 90,240 240,390 390,990 1530,1740
in {xv6 - -},| in
|在 Linux 或真正的操作系统中，

2622
01:19:52,570 --> 01:19:53,980
0,570 570,690 690,780 780,990 990,1410
Linux or a real operating

2623
01:19:53,980 --> 01:19:56,500
0,630 1170,1440 1440,1890 1890,2340 2340,2520
system,| every process has a
|每个进程都有一个用户 id ，

2624
01:19:56,500 --> 01:19:58,720
0,360 360,1080 1410,1590 1590,2130 2130,2220
user id,| that corresponds to
|对应于执行该进程的人类用户，

2625
01:19:58,720 --> 01:19:59,740
0,180 180,450 450,510 510,900 900,1020
the more or less to

2626
01:19:59,740 --> 01:20:01,780
0,60 60,690 840,1260 1260,1590 1590,2040
the human user who's executing

2627
01:20:01,780 --> 01:20:04,180
0,90 90,870 930,1380 1440,2010 2010,2400
the process| and some system
|一些系统调用使用进程的用户 id

2628
01:20:04,180 --> 01:20:06,610
0,750 900,1350 1350,1470 1470,1830 1830,2430
calls use the user id

2629
01:20:06,640 --> 01:20:07,570
0,120 120,240 240,690 690,780 780,930
of the process| to kind
|检查允许哪些进程执行此操作，

2630
01:20:07,570 --> 01:20:08,530
0,90 90,480 480,690 690,870 870,960
of check what is the

2631
01:20:08,530 --> 01:20:10,030
0,420 420,720 720,810 810,960 960,1500
process allowed to do this,|
|

2632
01:20:10,450 --> 01:20:11,740
0,270 270,480 480,690 690,870 870,1290
{} and so in Linux,
所以在 Linux 中，你会在这里看到一个额外的检查，

2633
01:20:11,740 --> 01:20:13,990
0,90 90,240 240,690 690,1290 1650,2250
you would see a {}

2634
01:20:14,230 --> 01:20:16,750
0,540 540,840 840,1530 1560,1830 1830,2520
extra check here,| that said
|就是调用进程必须具有相同的用户 id ，

2635
01:20:17,090 --> 01:20:18,160
0,450
that

2636
01:20:18,160 --> 01:20:19,540
0,150 150,570 570,1110 1110,1290 1290,1380
the calling process has to

2637
01:20:19,540 --> 01:20:21,250
0,90 90,210 210,690 690,1080 1080,1710
have the same user id,|
|

2638
01:20:21,340 --> 01:20:22,480
0,270 270,360 360,840 840,930 930,1140
as the process is trying
与想要杀死的进程一样，

2639
01:20:22,480 --> 01:20:24,070
0,60 60,600 810,1260 1260,1410 1410,1590
to kill,| otherwise it's not
|否则是不允许的。

2640
01:20:24,070 --> 01:20:25,160
0,630
allowed.|
|

2641
01:20:25,730 --> 01:20:27,230
0,210 210,690 1110,1290 1290,1440 1440,1500
And that, at least in
而且，至少在分时背景下，

2642
01:20:27,230 --> 01:20:29,140
0,60 60,300 300,540 540,1260
a time sharing context,|
|

2643
01:20:29,170 --> 01:20:30,460
0,300 300,510 510,600 600,930 930,1290
{} we have multiple users|
我们有多个用户，|

2644
01:20:30,460 --> 01:20:31,000
0,120 120,180 180,300 300,450 450,540
and we don't want them
我们不希望他们杀死彼此的进程，

2645
01:20:31,000 --> 01:20:32,320
0,60 60,240 240,390 390,660 660,1320
to kill each other's processes,|
|

2646
01:20:32,410 --> 01:20:34,450
0,840 1050,1350 1350,1380 1380,1590 1590,2040
that's more or less sufficient
这或多或少可以防止人们，

2647
01:20:34,450 --> 01:20:35,650
0,60 60,300 300,630 630,960 990,1200
to keep people from| make
|使其难以杀死其他人的进程。

2648
01:20:35,650 --> 01:20:36,700
0,90 90,330 330,420 420,750 750,1050
it hard for people to

2649
01:20:37,570 --> 01:20:39,620
0,240 240,420 420,690 690,1470
kill other people's processes.|
|

2650
01:20:41,090 --> 01:20:43,440
0,390 390,570 570,840 840,1230
Okay {I,see}, thank you.|
好的，我明白了，谢谢。|

2651
01:20:45,400 --> 01:20:47,320
0,420 450,930 930,1140 1140,1650 1650,1920
{} Does init process ever
init 进程是否会退出？

2652
01:20:47,320 --> 01:20:48,380
0,420
exit?|
|

2653
01:20:48,770 --> 01:20:50,840
0,300 300,420 420,480 480,1440
{} Let me check.|
让我找找。|

2654
01:20:54,430 --> 01:20:57,580
0,540 1770,2160 2160,2400 2400,2760 2760,3150
Yes, if fork fails, exit,|
是的，如果 fork 失败，退出，|

2655
01:20:57,640 --> 01:20:59,110
0,780 810,930 930,1140 1140,1410 1410,1470
however the real answer to
然而，这个问题的真正答案是否定的，

2656
01:20:59,110 --> 01:21:00,610
0,60 60,330 330,480 480,840 1200,1500
the question is no, {}|
|

2657
01:21:00,610 --> 01:21:02,740
0,120 120,750 1290,1530 1530,1770 1770,2130
the intent is that init
其目的是 init 永远不会退出，

2658
01:21:02,740 --> 01:21:04,390
0,360 360,690 1020,1290 1290,1500 1500,1650
never exit,| they just sit
|它们只是在这个循环中，

2659
01:21:04,390 --> 01:21:06,340
0,90 90,270 270,720 1110,1680 1680,1950
in this loop| {} and
|一遍又一遍地调用 wait ，

2660
01:21:06,340 --> 01:21:08,120
0,150 150,270 270,630 630,1290
what is doing is

2661
01:21:08,480 --> 01:21:09,590
0,300 300,630 630,840 840,960 960,1110
calling wait over and over

2662
01:21:09,590 --> 01:21:12,020
0,360 750,1140 1140,1290 1290,1560 1560,2430
again,| {} if init exits,
|如果 init 退出，我认为这是系统中的致命错误，系统将崩溃。

2663
01:21:12,080 --> 01:21:13,220
0,180 180,390 390,540 540,630 630,1140
I think that's a fatal

2664
01:21:13,220 --> 01:21:14,150
0,360 360,450 450,540 540,840 840,930
error in the system will

2665
01:21:14,150 --> 01:21:16,300
0,780 900,1650
crash. {}|
|

2666
01:21:16,360 --> 01:21:17,380
0,300 300,570 570,870 870,930 930,1020
There's code somewhere in the
内核中的某个地方有代码，可能在 exit 中。

2667
01:21:17,380 --> 01:21:18,880
0,330 330,420 420,1050 1200,1380 1380,1500
kernel, it says, may be

2668
01:21:18,880 --> 01:21:19,940
0,90 90,450
in exit.|
|

2669
01:21:19,940 --> 01:21:21,500
0,360 360,570 570,930
Just check exit.|
检查一下 exit 。|

2670
01:21:21,620 --> 01:21:22,860
0,660

2671
01:21:30,240 --> 01:21:32,070
0,840 870,1410 1410,1560 1560,1680 1680,1830
{} Yeah, here we are,
是的，在这里， exit ，在 exit 的开头，

2672
01:21:32,070 --> 01:21:32,820
0,240 240,300 300,360 360,660 660,750
exit, at the beginning of

2673
01:21:32,820 --> 01:21:34,320
0,330 510,750 750,870 870,1140 1140,1500
exit,| if it looks like
|如果当前进程是是 init 进程，那就是一个 panic 。

2674
01:21:34,320 --> 01:21:35,400
0,90 90,330 330,750 750,930 930,1080
the current process is the

2675
01:21:35,400 --> 01:21:37,230
0,210 210,840 1080,1230 1230,1290 1290,1830
init process, it's a panic.|
|

2676
01:21:37,860 --> 01:21:39,440
0,420 450,1050
{} Because,
因为，这个系统最终会陷入停顿，

2677
01:21:40,040 --> 01:21:41,210
0,180 180,420 420,510 510,870 870,1170
this system would eventually []

2678
01:21:41,210 --> 01:21:41,900
0,90 90,150 150,480 480,600 600,690
to a halt,| if there
|如果没有 init ，

2679
01:21:41,900 --> 01:21:43,070
0,180 180,390 390,510 510,810 840,1170
were no {init -},| because
|因为这样就没有什么东西收集，

2680
01:21:43,070 --> 01:21:44,750
0,630 630,750 750,930 930,1050 1050,1680
then there would be nothing

2681
01:21:44,780 --> 01:21:46,730
0,510 540,960 960,1020 1020,1380 1380,1950
collect,| nothing to call wait
|没有什么东西调用 wait 对于那些退出的进程，

2682
01:21:47,030 --> 01:21:48,500
0,240 240,390 390,750 750,1350 1350,1470
on these exiting processes| and
|并且没有任何东西可以完成进程的释放，

2683
01:21:48,500 --> 01:21:49,940
0,300 300,390 390,870 870,960 960,1440
nothing to complete the freeing

2684
01:21:49,940 --> 01:21:51,230
0,60 60,180 180,750 750,840 840,1290
of the processes| and gradually
|慢慢地，我们的进程耗尽了，

2685
01:21:51,230 --> 01:21:52,400
0,150 150,330 330,450 450,510 510,1170
we run out of processes,|
|

2686
01:21:52,400 --> 01:21:53,360
0,120 120,540
and then
那就是另一个错误了。

2687
01:21:54,400 --> 01:21:55,420
0,150 150,240 240,450 450,720 720,1020
that would be some other

2688
01:21:55,420 --> 01:21:56,660
0,390
error.|
|

2689
01:21:56,940 --> 01:21:57,930
0,360 360,540 540,630 630,870 870,990
We have to have {init
我们必须有 init 。

2690
01:21:57,930 --> 01:21:58,700
0,300
-}.|
|

2691
01:21:58,700 --> 01:21:59,510
0,180 180,270 270,450 450,720 720,810
So the real answer is
所以真正的答案是不，

2692
01:21:59,510 --> 01:22:00,440
0,150 150,270 270,420 420,540 540,930
that no,| {} it really
|它确实不能被允许退出，

2693
01:22:00,470 --> 01:22:01,430
0,240 240,300 300,570 570,630 630,960
can't be allowed to exit,|
|

2694
01:22:02,260 --> 01:22:03,600
0,180 180,390 390,720
better not exit.|
最好不要退出。|

2695
01:22:08,750 --> 01:22:09,880
0,540
Okay.|
好的。|

2696
01:22:10,220 --> 01:22:11,580
0,840

2697
01:22:12,580 --> 01:22:13,960
0,210 210,330 330,900
Any other questions?|
还有其他问题吗？|

2698
01:22:16,280 --> 01:22:18,500
0,480 510,720 720,930 930,1500 1530,2220
Um, it's another question, {}|
这是另一个问题，|

2699
01:22:18,770 --> 01:22:20,120
0,750
so,
所以，我们在这节课上还没有谈到太多，

2700
01:22:20,300 --> 01:22:21,350
0,270 270,420 420,600 600,870 870,1050
we haven't really talked about

2701
01:22:21,350 --> 01:22:22,160
0,210 210,270 270,420 420,660 660,810
much in this class yet,|
|

2702
01:22:22,160 --> 01:22:24,300
0,210 210,330 330,690 690,1650
but look what happens
但看看关闭操作系统会发生什么或需要发生什么。

2703
01:22:24,640 --> 01:22:25,540
0,150 150,300 300,510 510,600 600,900
or what needs to happen

2704
01:22:25,540 --> 01:22:27,460
0,240 270,810 810,1110 1110,1200 1200,1920
to shut down the OS.|
|

2705
01:22:28,480 --> 01:22:30,500
0,330 330,900
Got unplugged.|
被拔掉电源。|

2706
01:22:30,840 --> 01:22:34,950
0,480 510,1470 1500,2520 3030,3690 3690,4110
Okay.| Okay.| Yeah.| Yeah, this
好的。|好的。|是的。|是的，这很复杂，

2707
01:22:34,950 --> 01:22:36,420
0,180 180,750 750,1320 1320,1410 1410,1470
is very complex,| and it
|这取决于你运行的是什么，

2708
01:22:36,420 --> 01:22:37,740
0,420 420,630 630,810 810,960 960,1320
depends on what you're running,|
|

2709
01:22:37,740 --> 01:22:39,260
0,300 390,960
if you're,
如果你在，如果机器当前什么都不做，

2710
01:22:39,260 --> 01:22:40,430
0,180 180,360 360,690 690,1020 1020,1170
if the operating if the

2711
01:22:40,430 --> 01:22:41,990
0,390 390,480 480,780 780,990 990,1560
machine is currently doing nothing,|
|

2712
01:22:42,650 --> 01:22:46,730
0,630 750,1170 2910,3240 3720,4020 4020,4080
{} well, {} part of
好的，这个问题的部分答案是，

2713
01:22:46,730 --> 01:22:47,510
0,60 60,300 300,390 390,690 690,780
the answer the question is|
|

2714
01:22:47,510 --> 01:22:48,800
0,150 150,240 240,630 630,960 960,1290
that the file system ends
文件系统最终，

2715
01:22:48,800 --> 01:22:50,580
0,240 240,840
up being,|
|

2716
01:22:50,610 --> 01:22:52,110
0,450 510,870 870,960 960,1170 1170,1500
{} because the file system
因为文件系统是永久性的，

2717
01:22:52,110 --> 01:22:53,940
0,180 180,1020 1320,1440 1440,1620 1620,1830
is permanent,| you know the
|文件系统会从一个重启到另一个重启。

2718
01:22:53,940 --> 01:22:55,380
0,240 240,510 510,600 600,1050 1050,1440
file system is carried over

2719
01:22:55,380 --> 01:22:57,560
0,390 390,780 780,900 900,1590
from reboot to reboot.|
|

2720
01:22:57,790 --> 01:22:59,470
0,510 570,1080 1080,1440 1440,1530 1530,1680
{} We need to leave
我们需要让文件系统保持良好的状态，

2721
01:22:59,470 --> 01:23:00,370
0,60 60,360 360,660 660,720 720,900
the file system in good

2722
01:23:00,370 --> 01:23:02,170
0,570 690,1050 1110,1500 1500,1620 1620,1800
shape,| so if we were
|所以，如果我们正在对文件系统进行某些更新，

2723
01:23:02,170 --> 01:23:03,790
0,120 120,210 210,780 1200,1380 1380,1620
in the middle of some

2724
01:23:03,790 --> 01:23:04,930
0,360 360,450 450,540 540,840 840,1140
update to the file system,|
|

2725
01:23:04,930 --> 01:23:06,610
0,150 150,510 510,600 600,1200 1230,1680
like creating a file,| then
比如创建文件，|然后我们想要关闭系统或者停电之类的，

2726
01:23:06,640 --> 01:23:08,110
0,480 720,1110 1110,1170 1170,1380 1380,1470
we want to shut the

2727
01:23:08,110 --> 01:23:09,280
0,330 330,690 690,750 750,810 810,1170
system down or the power

2728
01:23:09,280 --> 01:23:10,780
0,270 270,330 330,630 630,810 810,1500
fails or something,| we absolutely
|我们绝对需要一个策略来确保，

2729
01:23:10,780 --> 01:23:12,340
0,180 180,240 240,1020 1050,1320 1320,1560
need a strategy to make

2730
01:23:12,340 --> 01:23:13,940
0,480 480,750
sure that,|
|

2731
01:23:14,340 --> 01:23:15,000
0,240 240,360 360,510 510,600 600,660
even though we were in
尽管我们正在对文件系统进行一些复杂的更新，

2732
01:23:15,000 --> 01:23:15,930
0,90 90,270 270,360 360,480 480,930
the middle of some complex

2733
01:23:15,930 --> 01:23:17,010
0,300 300,360 360,450 450,720 720,1080
update to the file system,|
|

2734
01:23:17,010 --> 01:23:17,850
0,180 180,270 270,510 510,780 780,840
that we don't leave it
我们不会把它留在文件系统中，

2735
01:23:17,850 --> 01:23:19,140
0,210 510,630 630,900 900,1200 1200,1290
in the file system in

2736
01:23:19,140 --> 01:23:21,270
0,60 60,540 870,1140 1140,1560 1560,2130
a state,| we don't expose
|我们不会在磁盘文件系统结构中公开任何损坏的不变量，

2737
01:23:21,270 --> 01:23:23,130
0,180 180,540 540,1500 1560,1740 1740,1860
any broken invariance in the

2738
01:23:23,130 --> 01:23:25,950
0,420 420,960 1110,1590 1590,1950 1950,2820
on disk file system structures,|
|

2739
01:23:26,100 --> 01:23:27,060
0,210 210,270 270,510 510,720 720,960
because the files is really
因为文件实际上只是一种在磁盘上的数据结构。

2740
01:23:27,060 --> 01:23:28,050
0,180 180,240 240,480 480,840 840,990
just a data structure, that

2741
01:23:28,050 --> 01:23:29,580
0,240 240,480 480,1050
lives on disk.|
|

2742
01:23:29,750 --> 01:23:32,120
0,480 630,1050 1050,1410 1410,1950 1950,2370
So there's like a lot
所以有很多这样的，

2743
01:23:32,120 --> 01:23:33,320
0,600
of,|
|

2744
01:23:33,320 --> 01:23:34,700
0,360 360,570 570,750 750,810 810,1380
{} that's sort of machinery
一些机制来确保，

2745
01:23:34,700 --> 01:23:35,990
0,480 480,750 780,1020 1020,1200 1200,1290
involved in making sure that|
|

2746
01:23:35,990 --> 01:23:37,010
0,90 90,210 210,420 420,930 930,1020
if you shut down or
如果你关机了或者停电了或者谁知道会发生什么，

2747
01:23:37,010 --> 01:23:38,120
0,120 120,480 480,930 930,1020 1020,1110
the power fails or who

2748
01:23:38,120 --> 01:23:39,680
0,180 180,510 510,780 1050,1350 1350,1560
knows what that,| {} the
|我们可以恢复磁盘上的文件系统。

2749
01:23:39,680 --> 01:23:41,390
0,660 750,1320 1320,1440 1440,1530 1530,1710
disk can, that we can

2750
01:23:41,390 --> 01:23:43,070
0,540 540,870 870,1230 1230,1530 1530,1680
recover the file system on

2751
01:23:43,070 --> 01:23:45,000
0,600
disk.|
|

2752
01:23:45,030 --> 01:23:45,900
0,150 150,240 240,480 480,720 720,870
For the rest of, it's
对于其他，不是为了这个，

2753
01:23:45,900 --> 01:23:48,540
0,150 150,270 270,720
not for that,|
|

2754
01:23:49,100 --> 01:23:50,630
0,570 600,1260 1260,1350 1350,1440 1440,1530
then, whether you have to
那么，你是不是要做一些特殊的事情来关机，

2755
01:23:50,630 --> 01:23:52,700
0,210 210,570 570,990 990,1080 1080,2070
do anything special to shutdown|
|

2756
01:23:52,730 --> 01:23:54,710
0,330 330,450 450,720 1260,1830 1830,1980
depends on what processes you're
取决于你正在运行什么进程，

2757
01:23:54,710 --> 01:23:55,940
0,390 480,720 720,840 840,1080 1080,1230
running,| if you're running some
|如果你正在运行某个重要的服务器，一台数据库服务器，

2758
01:23:55,940 --> 01:23:58,280
0,540 540,1110 1110,1380 1380,1860 1860,2340
important server, a database server,|
|

2759
01:23:58,280 --> 01:23:59,480
0,420 450,540 540,660 660,780 780,1200
that a lot of other
许多其他计算机依赖，并从网络上访问，

2760
01:23:59,480 --> 01:24:00,950
0,510 510,900 900,1140 1140,1260 1260,1470
computers depend on and use

2761
01:24:00,950 --> 01:24:02,990
0,150 150,210 210,780 1260,1620 1680,2040
over the network,| {} who
|答案可能是你不被允许关机，

2762
01:24:02,990 --> 01:24:04,670
0,570 810,1080 1080,1320 1320,1470 1470,1680
knows, the answer may be

2763
01:24:04,670 --> 01:24:05,630
0,210 210,390 390,630 630,900 900,960
that you just cannot be

2764
01:24:05,630 --> 01:24:07,160
0,300 300,360 360,600 600,900 900,1530
allowed to shut down,| because
|因为你提供的服务对很多其他计算机都很重要。

2765
01:24:07,160 --> 01:24:08,840
0,120 120,450 450,540 540,1170 1170,1680
you're providing a service that's

2766
01:24:08,870 --> 01:24:09,590
0,360 360,420 420,480 480,660 660,720
critical to a bunch of

2767
01:24:09,590 --> 01:24:11,080
0,180 180,900
other computers.|
|

2768
01:24:11,080 --> 01:24:11,830
0,180 180,270 270,540 540,600 600,750
If your computer is not
如果你的计算机没有执行任何操作。

2769
01:24:11,830 --> 01:24:13,460
0,180 180,360 360,420 420,1020
doing much of anything.|
|

2770
01:24:13,790 --> 01:24:15,140
0,930

2771
01:24:15,200 --> 01:24:16,010
0,330 330,450 450,540 540,660 660,810
Then you can just turn
那你就可以把它关掉，

2772
01:24:16,010 --> 01:24:18,300
0,90 90,750 930,1680
it off| and
|它会停止执行，

2773
01:24:18,300 --> 01:24:20,220
0,60 60,150 150,360 360,870 1740,1920
it will stop executing| and
|没有什么可做的，

2774
01:24:20,220 --> 01:24:21,180
0,150 150,360 360,570 570,660 660,960
there's not much to do,|
|

2775
01:24:21,270 --> 01:24:22,440
0,480 630,810 810,870 870,960 960,1170
really, may be the answer
真的，也许你问题的答案是，

2776
01:24:22,440 --> 01:24:23,820
0,60 60,150 150,480 480,840
to your question is,|
|

2777
01:24:24,360 --> 01:24:24,840
0,120 120,180 180,300 300,360 360,480
if you want to shut
如果你想关闭计算机，

2778
01:24:24,840 --> 01:24:25,680
0,150 150,210 210,570 570,720 720,840
down the computer,| make sure
|确保文件系统状态良好，

2779
01:24:25,680 --> 01:24:26,730
0,60 60,300 300,540 540,690 690,1050
the file system is in

2780
01:24:26,730 --> 01:24:27,960
0,180 180,540 570,750 750,870 870,1230
good shape| and then stop
|然后停止执行指令，就好了。

2781
01:24:27,960 --> 01:24:30,270
0,480 480,1320 1500,1710 1710,1860 1860,2310
executing instructions and that's fine.|
|

2782
01:24:31,730 --> 01:24:33,440
0,510 510,600 600,750 750,1140 1260,1710
Good.| That makes sense, yeah,
好的。|有道理，是的，谢谢。

2783
01:24:33,470 --> 01:24:34,920
0,210 210,540
thank you.|
|

2784
01:24:37,090 --> 01:24:38,460
0,300 300,840
Anything else?|
还要别的吗？|

2785
01:24:41,980 --> 01:24:43,360
0,240 240,810 840,1110 1110,1260 1260,1380
Oh, sorry, {} I have
哦，抱歉，我还有一个问题，

2786
01:24:43,360 --> 01:24:44,590
0,300 300,660 660,840 840,1020 1020,1230
another question,| so what is
|那么这个信号量接口是什么。

2787
01:24:44,590 --> 01:24:47,400
0,270 270,540 540,1080 1350,2370
this {semaphore -} interface.|
|

2788
01:24:48,740 --> 01:24:50,560
0,210 210,420 420,1260
About p {and,v}.|
关于 p 和 v 。|

2789
01:24:53,330 --> 01:24:56,180
0,750 1050,1440 1440,1830 2160,2610 2610,2850
So just two, just those
所以，只有这两个函数？

2790
01:24:56,180 --> 01:24:57,620
0,120 120,900
two functions?|
|

2791
01:24:57,650 --> 01:24:59,900
0,810 840,1710
Um, yeah.|
嗯，是的。|

2792
01:25:00,100 --> 01:25:02,260
0,1110 1110,1200 1200,1380 1380,1560 1560,2160
Yeah, xv6 doesn't have semaphores
是的， xv6 实际上没有信号量，

2793
01:25:02,260 --> 01:25:03,310
0,210 210,390 750,900 900,960 960,1050
really,| but you know the
|但是书中的信号量，我想它只是 p 和 v ，

2794
01:25:03,310 --> 01:25:04,300
0,240 240,720 720,780 780,900 900,990
books semaphores, I think it's

2795
01:25:04,300 --> 01:25:05,830
0,180 180,300 300,420 420,810 870,1530
just p and v,| there
|信号量对象有两个方法 p 和 v 。

2796
01:25:05,830 --> 01:25:07,000
0,150 150,270 270,900 900,1080 1080,1170
are two methods, you have

2797
01:25:07,000 --> 01:25:08,020
0,60 60,300 300,480 480,870 870,1020
a {semaphore -} object has

2798
01:25:08,020 --> 01:25:09,310
0,150 150,720 720,870 870,990 990,1290
two methods p and v.|
|

2799
01:25:11,010 --> 01:25:13,080
0,810 930,1080 1080,1320 1320,1590 1590,2070
Okay, I see, thank you.|
好的，我明白了，谢谢。|

2800
01:25:13,110 --> 01:25:14,200
0,450
Sure.|
好的。|

2801
01:25:20,600 --> 01:25:22,200
0,270 270,810
Anything else?|
还要别的吗？|

2802
01:25:25,170 --> 01:25:26,153
0,660
Alright.
好的。
