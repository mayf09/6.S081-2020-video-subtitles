1
00:00:06,750 --> 00:00:09,060
0,720 720,900 900,1590 1620,2100 2130,2310
{} Good afternoon, {} quick
下午好，快速试音。

2
00:00:09,060 --> 00:00:10,480
0,210 210,570
sound check.|
|

3
00:00:10,510 --> 00:00:11,920
0,120 120,330 330,480 480,810
Can people hear me?|
大家能听到我说话吗？|

4
00:00:12,270 --> 00:00:13,320
0,510
Yes.|
是的。|

5
00:00:13,820 --> 00:00:15,140
0,750
Thanks.|
谢谢。|

6
00:00:15,350 --> 00:00:17,300
0,300 300,510 510,1230 1500,1740 1740,1950
Okay, so {} I guess
好的，我想今天到目前为止，

7
00:00:17,300 --> 00:00:19,370
0,1020 1200,1320 1320,1590 1590,1740 1740,2070
today you know so far,|
|

8
00:00:19,370 --> 00:00:21,380
0,150 150,240 240,510 510,1020 1470,2010
it's the last lecture of
这是本学期的最后一节 6.S081 的课。

9
00:00:21,740 --> 00:00:22,550
0,180 180,240 240,420 420,660 660,810
{6.S081 - - -} this

10
00:00:22,550 --> 00:00:23,760
0,630
semester.|
|

11
00:00:23,960 --> 00:00:25,160
0,630
And,
我们并没有一个正式的话题，

12
00:00:25,220 --> 00:00:26,960
0,330 330,510 510,810 810,1140 1140,1740
{} we don't really have

13
00:00:26,990 --> 00:00:30,500
0,420 420,1110 1110,1920 2160,2910 2940,3510
a formal {} topic {},|
|

14
00:00:30,620 --> 00:00:31,280
0,180 180,270 270,480 480,570 570,660
there's a {Q&A - -}
这是一个问答课程，

15
00:00:31,280 --> 00:00:33,380
0,540 870,1200 1200,1410 1410,1950 1950,2100
lecture,| so feel free to
|所以你可以随便问任何问题，

16
00:00:33,380 --> 00:00:36,380
0,240 240,840 1530,1920 1920,2430 2490,3000
ask questions about anything {},|
|

17
00:00:36,410 --> 00:00:37,430
0,150 150,390 420,510 510,720 720,1020
this is I guess last,|
我想这是最后一次，|

18
00:00:37,430 --> 00:00:39,320
0,450 690,1140 1140,1410 1410,1560 1560,1890
your last chance at least
至少是你们这学期最后一次上这门课了。

19
00:00:39,320 --> 00:00:40,490
0,150 150,480 480,570 570,720 720,1170
this semester for this class.|
|

20
00:00:41,260 --> 00:00:43,240
0,600 630,1140 1140,1560 1560,1650 1650,1980
{} By default, my plan
默认情况下，我的计划是

21
00:00:43,240 --> 00:00:45,160
0,150 150,570 570,1020 1260,1770 1770,1920
was| to {} go over
|根据电子邮件上的问题复习几个主题，

22
00:00:45,160 --> 00:00:47,320
0,30 30,210 210,750 780,1950 1950,2160
a couple topics based on

23
00:00:47,320 --> 00:00:49,540
0,180 180,840 840,1230 1230,1770 1830,2220
the questions over email,| then
|然后我要稍微讨论一下网络实验的解决方案。

24
00:00:49,540 --> 00:00:49,960
0,60 60,150 150,270 270,330 330,420
I was going to talk

25
00:00:49,960 --> 00:00:50,860
0,30 30,210 210,330 330,570 570,900
a little bit about network

26
00:00:50,860 --> 00:00:51,860
0,480
lab,

27
00:00:52,170 --> 00:00:53,760
0,180 180,930
the solutions.|
|

28
00:00:53,850 --> 00:00:56,100
0,450 450,1560 1560,1980 1980,2190 2190,2250
{} If possible, also a
如果可能的话，再花一点时间介绍一下 mmap 实验，

29
00:00:56,100 --> 00:00:57,630
0,180 180,600 600,750 990,1320 1320,1530
little bit of time about

30
00:00:57,630 --> 00:00:59,120
0,120 120,420 420,930
the mmap lab,|
|

31
00:01:00,110 --> 00:01:01,760
0,390 390,690 690,870 870,1050 1050,1650
again talking about those solutions.|
再次谈论这些解决方案。|

32
00:01:02,090 --> 00:01:02,870
0,420 420,540 540,630 630,750 750,780
And then there were a
然后有很多关于后续课程的问题，

33
00:01:02,870 --> 00:01:04,370
0,210 210,270 270,600 600,870 870,1500
lot of questions about the

34
00:01:04,430 --> 00:01:06,440
0,510 510,1230 1380,1680 1680,1740 1740,2010
following classes| and in fact
|事实上，我会先讲到这一点。

35
00:01:06,440 --> 00:01:08,450
0,420 420,630 630,1050 1170,1440 1440,2010
I think I'll cover that

36
00:01:08,480 --> 00:01:09,580
0,570
first.|
|

37
00:01:10,120 --> 00:01:12,670
0,600 840,1470 1470,1770 1770,2100 2100,2550
{} But before diving in
但是在深入到这三个主题中的一个之前，

38
00:01:12,700 --> 00:01:14,770
0,840 1320,1650 1650,1740 1740,1920 1920,2070
{} any of these three

39
00:01:14,770 --> 00:01:16,750
0,510 510,870 870,990 990,1410 1410,1980
topics,| let me remind you
|让我提醒你，有一个科目评估正在进行中，

40
00:01:16,750 --> 00:01:19,220
0,360 360,780 900,1920
there's a subject

41
00:01:19,280 --> 00:01:21,040
0,1110
evaluation

42
00:01:22,090 --> 00:01:23,800
0,450 450,660 660,1020 1020,1260 1260,1710
{} {outgoing -} {ongoing -},|
|

43
00:01:23,800 --> 00:01:27,280
0,1320 1350,2010 2070,2340 2340,3030 3210,3480
and we as staff of
而我们作为 6.S081 的工作人员，

44
00:01:27,280 --> 00:01:28,780
0,150 150,420 420,540 540,1170 1170,1500
{6.S081 -},| we appreciate you
|我们感谢你对 6.S081 的反馈。

45
00:01:28,780 --> 00:01:29,740
0,450
{}

46
00:01:29,740 --> 00:01:31,180
0,120 120,300 300,420 420,1050 1050,1440
{} give your feedback on

47
00:01:31,180 --> 00:01:33,060
0,120 120,150 150,300 300,720
{6.S081 - - -}.|
|

48
00:01:33,060 --> 00:01:34,800
0,120 120,480 480,600 600,1380 1620,1740
And hopefully it's positive,| you
希望它是积极的，|我们明年有机会再次授课。

49
00:01:34,800 --> 00:01:35,520
0,150 150,240 240,360 360,450 450,720
know we get a chance

50
00:01:35,520 --> 00:01:37,410
0,210 210,480 480,990 1020,1620 1620,1890
to teach again next year.|
|

51
00:01:39,320 --> 00:01:40,040
0,150 150,330 330,480 480,540 540,720
And maybe this is also
也许这也是一个很好的时机，

52
00:01:40,040 --> 00:01:41,720
0,480 480,660 660,960 960,1440 1560,1680
a good time| to you
|谢谢你们参加今天的课程，

53
00:01:41,720 --> 00:01:43,190
0,420 420,900 900,1140 1140,1230 1230,1470
know actually thank you for

54
00:01:43,190 --> 00:01:44,900
0,480 480,840 840,1380 1410,1590 1590,1710
attending today's lecture,| even though
|即使没有非常正式的计划，

55
00:01:44,900 --> 00:01:45,950
0,240 240,420 420,630 750,990 990,1050
there's not a sort of

56
00:01:45,950 --> 00:01:47,450
0,210 210,480 480,780 780,960 960,1500
very formal program,| I also
|我页感谢工作人员，

57
00:01:47,450 --> 00:01:48,680
0,720 720,810 810,1020 1020,1110 1110,1230
appreciate the fact that with

58
00:01:48,680 --> 00:01:49,820
0,90 90,360 360,450 450,810 810,1140
the staff| and generally appreciate
|我很感激你们非常忙碌，

59
00:01:49,820 --> 00:01:51,500
0,60 60,360 360,570 810,1590 1590,1680
the fact that {} you

60
00:01:51,500 --> 00:01:53,330
0,150 150,540 660,990 990,1230 1230,1830
know you're being very engaged,|
|

61
00:01:53,330 --> 00:01:55,640
0,990 1050,1230 1230,1770 1770,1890 1890,2310
and in particular the paper
尤其论文不是直接对应实验，

62
00:01:55,640 --> 00:01:56,660
0,210 210,390 390,810 810,900 900,1020
that not directly to the

63
00:01:56,660 --> 00:01:58,220
0,450 450,540 540,870 1110,1260 1260,1560
labs,| you know it's clear
|很明显，你们中的许多人都深入论文中，

64
00:01:58,220 --> 00:01:59,720
0,240 240,630 630,720 720,1170 1170,1500
that many of you dove

65
00:01:59,720 --> 00:02:00,890
0,240 240,330 330,840 840,1020 1020,1170
into the papers| and try
|试图真正理解它们，

66
00:02:00,890 --> 00:02:02,090
0,120 120,330 330,780 780,1050 1050,1200
to really understand them,| and
|在电子邮件上问一些很棒的问题。

67
00:02:02,090 --> 00:02:03,500
0,360 360,630 630,780 780,1020 1020,1410
ask great {} great question

68
00:02:03,500 --> 00:02:05,750
0,120 120,930 930,1260 1260,1590 1920,2250
of over email.| So, {}
|所以，我们非常感谢你们的努力。

69
00:02:05,750 --> 00:02:08,480
0,420 480,960 960,1170 1170,1650 1650,2730
we very much appreciate the

70
00:02:08,540 --> 00:02:09,640
0,810
engagement.|
|

71
00:02:10,780 --> 00:02:13,920
0,900 1290,1710 1710,2190 2190,2580
Any questions, before I
在我讲每个主题之前，有什么问题吗？

72
00:02:14,090 --> 00:02:14,900
0,240 240,390 390,540 540,720 720,810
go with each set of

73
00:02:14,900 --> 00:02:15,980
0,570
topics?|
|

74
00:02:21,540 --> 00:02:23,490
0,210 210,390 390,960 1290,1710 1710,1950
Okay, let me start with
好的，让我从电子邮件中出现最多的问题开始，

75
00:02:23,490 --> 00:02:24,750
0,390 420,720 720,810 810,1050 1050,1260
the question that probably came

76
00:02:24,750 --> 00:02:26,460
0,120 120,420 420,540 540,1080 1140,1710
up most in email,| what
|接下来是什么。

77
00:02:26,460 --> 00:02:28,460
0,540
next.|
|

78
00:02:28,580 --> 00:02:29,990
0,540 540,810 810,1020 1020,1380 1380,1410
{} There's a quite a
有很多课程是面向系统的，

79
00:02:29,990 --> 00:02:31,940
0,300 300,360 360,1080 1140,1290 1290,1950
number of classes {} that

80
00:02:31,970 --> 00:02:35,900
0,780 1320,1770 1770,2250 2250,2790 3150,3930
{} systems oriented focused {},|
|

81
00:02:36,350 --> 00:02:37,970
0,180 180,510 510,990 990,1080 1080,1620
and I'm sure I missed
我肯定我错过了一些课，

82
00:02:38,060 --> 00:02:39,500
0,270 270,450 450,720 720,780 780,1440
{} a number of classes,|
|

83
00:02:39,590 --> 00:02:40,520
0,300 300,480 480,630 630,810 810,930
{} that I should have
我应该在这里列出的，

84
00:02:40,520 --> 00:02:42,830
0,330 330,810 1080,1620 1620,1770 1770,2310
listed here,| {} {you,know} immediately
|它与操作系统直接相关，

85
00:02:42,830 --> 00:02:44,660
0,600 600,900 900,1020 1020,1380 1380,1830
straightly related to operating systems,|
|

86
00:02:44,660 --> 00:02:45,680
0,120 120,240 240,750 750,870 870,1020
you know clearly you know
当然，如果你学过 6.033 ，

87
00:02:45,680 --> 00:02:46,490
0,150 150,270 270,480 480,720 720,810
if you have taken {6.033

88
00:02:46,490 --> 00:02:47,720
0,390 390,750 780,990 990,1020 1020,1230
-} yet,| it's a great
|这是一门很棒的课程，

89
00:02:47,720 --> 00:02:49,220
0,270 270,360 360,750 750,1200 1200,1500
class to take,| particularly we
|尤其是我们阅读或学习如何阅读论文。

90
00:02:49,370 --> 00:02:51,470
0,1200 1380,1560 1560,1860 1860,1980 1980,2100
read or learn how to

91
00:02:51,470 --> 00:02:52,860
0,270 300,990
read papers.|
|

92
00:02:52,950 --> 00:02:54,600
0,450 510,1020 1020,1140 1140,1260 1260,1650
{} {6.828 - - -}
6.828 是我们最初提供的唯一操作系统课程，

93
00:02:54,630 --> 00:02:57,180
0,570 570,900 900,1620 1650,2250 2250,2550
{} which the originally only

94
00:02:57,180 --> 00:02:59,910
0,270 270,810 840,1830 2130,2310 2310,2730
OS class {} we offered,|
|

95
00:02:59,940 --> 00:03:03,030
0,510 1140,2100 2100,2340 2400,2850 2850,3090
this year or second year
今年或者第二年，

96
00:03:03,030 --> 00:03:04,890
0,450 720,990 990,1500 1500,1710 1710,1860
we're,| this year first year
|今年是提供这两门课的第一年，

97
00:03:04,890 --> 00:03:07,080
0,60 60,450 450,900 1200,1890 1890,2190
of offering both,| so {6.S081
|所以， 6.S081 是本科生操作系统，

98
00:03:07,080 --> 00:03:08,220
0,60 60,300 300,450 450,600 600,1140
- -} is {undergrad -}

99
00:03:08,220 --> 00:03:09,030
0,90 90,300 300,540 540,690 690,810
{OS -}| and {6.828 -
|6.828 作为研究生的操作系统课程。

100
00:03:09,030 --> 00:03:11,520
0,150 150,420 540,1260 1950,2370 2370,2490
- - - - -

101
00:03:11,520 --> 00:03:12,810
0,210 210,360 360,600 600,930 930,1290
-} as the grad level

102
00:03:12,810 --> 00:03:14,840
0,270 270,810 990,1530
OS class {}.|
|

103
00:03:14,870 --> 00:03:16,640
0,450 480,570 570,870 900,1710 1710,1770
And you know basically {}
6.828 假设，

104
00:03:16,640 --> 00:03:17,750
0,150 150,300 300,690 690,840 840,1110
{6.828 -} issues| you've taken
|你已经选了 6.S081 或本科生操作系统，

105
00:03:17,750 --> 00:03:20,480
0,330 330,840 900,1380 1380,2370 2370,2730
{6.S081 -} or {undergrad,OS}| {and,you,know}
|在新的项目和构建有趣的操作系统工件，

106
00:03:20,570 --> 00:03:22,550
0,450 450,810 810,1290 1320,1500 1500,1980
goes off in new projects

107
00:03:22,550 --> 00:03:26,150
0,1080 1440,1830 1830,2430 2430,3120 3120,3600
and building interesting OS artifacts,|
|

108
00:03:26,680 --> 00:03:28,210
0,570 570,810 840,1080 1080,1290 1290,1530
and {} reading more papers
从文献中阅读更多的论文，

109
00:03:28,210 --> 00:03:29,500
0,120 120,180 180,600 750,990 990,1290
from the literature| and more
|以及更多的现代研究文献。

110
00:03:29,500 --> 00:03:31,390
0,180 180,360 360,1050 1050,1380 1380,1890
of the modern research literature.|
|

111
00:03:32,660 --> 00:03:34,130
0,480 480,720 720,810 810,870 870,1470
Then maybe you are more
然后也许你更，

112
00:03:34,190 --> 00:03:35,810
0,120 120,240 240,600 960,1440 1440,1620
you know,| the OS sort
|操作系统有很多与硬件的接口，

113
00:03:35,810 --> 00:03:36,530
0,180 180,270 270,420 420,690 690,720
of you know there's a

114
00:03:36,530 --> 00:03:37,400
0,150 150,240 240,660 660,810 810,870
lot of interfacing with the

115
00:03:37,400 --> 00:03:38,750
0,600 630,930 930,1020 1020,1140 1140,1350
hardware,| would have been more
|有更多的系统的硬件方面，

116
00:03:38,750 --> 00:03:40,250
0,90 90,600 690,1170 1170,1440 1440,1500
of the hardware side of

117
00:03:40,250 --> 00:03:41,720
0,570 570,660 660,840 840,1080 1140,1470
systems,| you know the computer
|计算机架构课程 6.823 ，

118
00:03:41,720 --> 00:03:42,980
0,420 420,750 750,840 840,990 990,1260
architecture class {6.823 - -},|
|

119
00:03:42,980 --> 00:03:44,060
0,180 180,300 330,690 690,780 780,1080
which I believe is offered
我相信会在即将到来的春天提供，

120
00:03:44,060 --> 00:03:45,560
0,120 120,300 300,570 570,1020 1260,1500
to the coming Spring| and
|当然还有 6.111 ，

121
00:03:45,560 --> 00:03:47,150
0,60 60,270 270,450 450,1440 1440,1590
of course there's 6.111,| {you,know}
|是构建硬件设备的东西。

122
00:03:47,150 --> 00:03:48,200
0,180 180,240 240,600
sort of the

123
00:03:48,230 --> 00:03:50,990
0,180 180,540 540,1080 1140,2130 2130,2760
{} building something hardware devices.|
|

124
00:03:51,460 --> 00:03:53,590
0,480 900,1110 1110,1620 1800,2070 2070,2130
{} On the sort of
在性能方面，在编译器方面，

125
00:03:53,590 --> 00:03:54,970
0,510 510,870 870,930 930,990 990,1380
performance sides, in the compiler

126
00:03:54,970 --> 00:03:56,080
0,300 300,510 510,600 600,840 840,1110
sides,| {6.172 - - -},
|6.172 6.035 是个好地方，

127
00:03:56,080 --> 00:03:57,010
0,210 210,330 330,540 540,870 870,930
{6.035 - - -} for

128
00:03:57,010 --> 00:03:58,480
0,90 90,240 240,810 840,1080 1110,1470
a good places,| a number
|你们中的一些人同时选修了 6.172 ，

129
00:03:58,480 --> 00:03:59,380
0,90 90,300 300,420 420,690 690,900
of you are taking {6.172

130
00:03:59,380 --> 00:04:01,360
0,150 150,870 900,1050 1050,1620 1620,1980
- -} in parallel with

131
00:04:01,360 --> 00:04:03,400
0,270 270,660 690,1050 1380,1980 1980,2040
{6.S081 -},| so but if
|如果你选了编译课程 6.035

132
00:04:03,400 --> 00:04:04,180
0,90 90,210 210,450 450,510 510,780
you have taken for example

133
00:04:04,180 --> 00:04:05,830
0,60 60,420 420,780 780,1440 1440,1650
the compiled class 6.035| or
|或动态编译器课程，

134
00:04:05,830 --> 00:04:08,350
0,990 1080,1500 1500,1950 1950,2460 2460,2520
dynamic compiler class,| both of
|它们两个也都是很棒的课程。

135
00:04:08,350 --> 00:04:10,240
0,210 210,690 900,1170 1170,1380 1380,1890
them are also great classes.|
|

136
00:04:11,580 --> 00:04:12,840
0,360 390,780 780,930 930,990 990,1260
{} System is a broad
系统是一个宽泛的话题，

137
00:04:12,840 --> 00:04:15,060
0,810 840,1380 1380,1560 1560,1860 1860,2220
topic,| {} so like there's
|所以，这里有网络，

138
00:04:15,090 --> 00:04:16,620
0,360 390,1140 1140,1350 1350,1500 1500,1530
{} networking| and there's a
|以及一大批课程，

139
00:04:16,620 --> 00:04:18,090
0,240 240,630 630,750 750,1350 1350,1470
whole branch of classes {}|
|

140
00:04:18,090 --> 00:04:19,380
0,180 180,480 480,570 570,990 990,1290
whole [] of classes around
围绕网络的整个课程，

141
00:04:19,380 --> 00:04:21,180
0,690 750,1080 1080,1110 1110,1470 1470,1800
networking,| and a whole stream
|以及围绕数据库的整个课程，

142
00:04:21,180 --> 00:04:23,940
0,60 60,420 420,960 990,2100 2160,2760
of class around databases {},|
|

143
00:04:24,240 --> 00:04:25,240
0,210 210,510
{which,are,all} good
这些都是好的和重要的，

144
00:04:25,240 --> 00:04:28,570
0,780 960,1530 1560,1800 1800,2490 2550,3330
{} and {} important,| and
|你在 6.S081 中看到的方面

145
00:04:28,780 --> 00:04:31,120
0,600 600,750 750,960 960,2040 2040,2340
aspects that you've seen {in,6.S081

146
00:04:31,120 --> 00:04:32,140
0,150 150,450 450,570 570,840 840,1020
- -}| will show up
|将在这些课程中以更重要的方式出现。

147
00:04:32,140 --> 00:04:34,060
0,300 300,630 630,810 810,1350 1350,1920
in much more prominent ways

148
00:04:34,330 --> 00:04:36,020
0,420 420,510 510,750 750,1260
{} in those classes.|
|

149
00:04:36,510 --> 00:04:38,700
0,510 690,1140 1140,1560 1560,2010 2010,2190
For example, networking clears a
比如，网络是一个很棒的话题 6.829 ，

150
00:04:38,700 --> 00:04:40,050
0,240 240,600 600,990 1080,1260 1260,1350
great topic of {6.829 -

151
00:04:40,050 --> 00:04:41,190
0,390 390,570 570,750 750,960 960,1140
-},| and so you'll see
|你会在那里看到更多关于网络的内容，

152
00:04:41,190 --> 00:04:42,660
0,60 60,240 240,390 390,990 990,1470
a lot more about networking

153
00:04:42,660 --> 00:04:44,400
0,390 720,1200 1200,1380 1380,1500 1500,1740
there,| {than,you've} seen in {6.S081
|比起你已经在 6.S081 中看到的，

154
00:04:44,400 --> 00:04:46,320
0,120 120,570 840,1140 1140,1350 1350,1920
- -},| {} {6.830 -}
|6.830 ，我们讨论过文件系统，

155
00:04:46,320 --> 00:04:47,070
0,90 90,210 210,300 300,540 540,750
you know we talked about

156
00:04:47,070 --> 00:04:48,510
0,240 240,720 720,840 840,1020 1020,1440
file systems,| you know clearly
|是另一种重要的存储系统，

157
00:04:48,510 --> 00:04:50,160
0,240 240,300 300,720 720,1230 1560,1650
{another -} important classes of

158
00:04:50,160 --> 00:04:52,590
0,420 420,990 990,1560 1560,2160 2340,2430
storage systems,| and probably in
|可能在一些方面对许多应用程序更重要，数据库，

159
00:04:52,590 --> 00:04:53,760
0,180 180,390 390,540 540,930 930,1170
some ways more important for

160
00:04:53,760 --> 00:04:55,830
0,240 240,1020 1020,1650 1650,1830 1830,2070
many applications, databases,| and so
|所以你有 6.830 这个很棒的课程

161
00:04:56,130 --> 00:04:57,840
0,180 180,330 330,630 630,930 930,1710
you get 6.830 {a,great} topic

162
00:04:57,840 --> 00:04:58,620
0,300 300,390 390,600 600,630 630,780
class| to learn a lot
|来学习更多关于数据库的知识。

163
00:04:58,620 --> 00:05:00,020
0,210 210,450 450,1080
more about databases.|
|

164
00:05:00,780 --> 00:05:01,830
0,180 180,300 300,570 570,720 720,1050
{} In terms of like
这些课程，

165
00:05:01,830 --> 00:05:03,000
0,540 540,720 720,780 780,1110 1110,1170
classes,| that are sort of
|有时叫做 PDOS 课程，

166
00:05:03,000 --> 00:05:04,470
0,660 690,780 780,870 870,1230 1230,1470
{} you know sometimes called

167
00:05:04,470 --> 00:05:06,180
0,420 420,540 540,750 750,930 930,1710
whatever the {PDOS -} classes,|
|

168
00:05:07,440 --> 00:05:08,970
0,240 240,480 660,1020 1020,1110 1110,1530
there's a number of them,|
这里有很多课程，|

169
00:05:09,030 --> 00:05:10,890
0,660 720,870 870,1020 1020,1440 1440,1860
{} {6.824 - -} distributed
6.824 分布式系统课程将开设，

170
00:05:10,890 --> 00:05:12,510
0,270 270,840 870,1170 1170,1500 1500,1620
systems class {} will be

171
00:05:12,510 --> 00:05:15,240
0,300 300,600 600,1110 1650,2280 2430,2730
offering that,| { -} coming
|在下学期春季学期，

172
00:05:15,240 --> 00:05:18,260
0,360 360,630 630,1230 1230,2370
semester Spring semester,| and
|本学期在 6.S081 涉及的教职员工，

173
00:05:18,600 --> 00:05:20,040
0,420 420,540 540,960 990,1320 1320,1440
section of the number of

174
00:05:20,040 --> 00:05:21,080
0,450
the

175
00:05:21,140 --> 00:05:22,790
0,420 420,780 780,1020 1020,1410 1410,1650
staff involved this semester in

176
00:05:22,790 --> 00:05:23,810
0,150 150,390 390,540 540,630 630,1020
{6.S081 -}| will be involved
|将参与 6.824 。

177
00:05:23,810 --> 00:05:25,180
0,120 120,210 210,360 360,810
in {6.824 - -}.|
|

178
00:05:25,330 --> 00:05:27,250
0,510 510,1020 1020,1410 1410,1620 1620,1920
{} There's {6.858 - -}
有 6.858 是计算机安全课程，

179
00:05:27,250 --> 00:05:29,020
0,240 240,420 420,750 1050,1380 1380,1770
which is a computer security

180
00:05:29,020 --> 00:05:30,610
0,630 810,1080 1080,1260 1260,1500 1500,1590
class,| {} we won't be
|今年春天我们不会提供，

181
00:05:30,610 --> 00:05:32,500
0,330 330,420 420,1020 1020,1560 1590,1890
offering in that coming this

182
00:05:32,500 --> 00:05:34,690
0,540 540,1140 1170,1650 1650,1740 1740,2190
Spring,| {} {but,we,hope} to {offer,it}
|但是我们希望在下一学年提供。

183
00:05:34,690 --> 00:05:36,720
0,420 450,810 810,1230 1230,1530
the next academic year.|
|

184
00:05:36,870 --> 00:05:38,670
0,330 330,660 660,1170 1440,1650 1650,1800
And there's {} {6.826 -
有 6.826 是计算机系统原理，

185
00:05:38,670 --> 00:05:40,350
0,690 720,870 870,1140 1140,1260 1260,1680
-} {} which are principles

186
00:05:40,350 --> 00:05:41,730
0,90 90,390 390,750 750,1020 1020,1380
of computer system,| so a
|有很多人问起验证和系统软件，

187
00:05:41,760 --> 00:05:42,900
0,210 210,270 270,510 510,870 870,1140
number of people ask about

188
00:05:42,900 --> 00:05:44,970
0,630 630,720 720,1020 1020,1590 1770,2070
verification and system software {},|
|

189
00:05:44,970 --> 00:05:45,690
0,180 180,270 270,330 330,660 660,720
this is the class you
这就是你要学的课程，

190
00:05:45,690 --> 00:05:47,010
0,270 270,390 390,540 540,900 900,1320
take,| if you are interested
|如果你对那个主题感兴趣。

191
00:05:47,010 --> 00:05:48,200
0,60 60,270 270,720
in that topic.|
|

192
00:05:48,780 --> 00:05:51,660
0,450 630,1260 1260,1620 1620,2160 2160,2880
{} More broadly speaking,| a
更广泛地说，|很多人想知道研究要怎么继续，

193
00:05:51,780 --> 00:05:53,100
0,210 210,270 270,480 480,870 870,1320
lot of people wondering what

194
00:05:53,100 --> 00:05:53,850
0,60 60,270 270,510 510,660 660,750
is actually going on in

195
00:05:53,850 --> 00:05:55,110
0,450 450,570 570,660 660,1140 1140,1260
research,| if you're interested,| you
|如果你感兴趣，|几乎所有系统文献的论文都是公开的，

196
00:05:55,110 --> 00:05:57,180
0,630 810,1200 1200,1350 1350,1470 1470,2070
know almost all the papers

197
00:05:57,180 --> 00:05:58,890
0,300 300,450 450,810 810,1350 1350,1710
in the systems literature are

198
00:05:58,890 --> 00:06:00,390
0,420 420,840 840,1140 1140,1290 1290,1500
publicly available,| even the ones
|甚至最近的会议，

199
00:06:00,390 --> 00:06:02,040
0,90 90,210 210,810 810,1500 1530,1650
of the recent conferences,| for
|比如， OSDI 会议在几周前举行，

200
00:06:02,040 --> 00:06:04,170
0,510 510,840 1110,1530 1530,1680 1680,2130
example the {OSDI -} conference

201
00:06:04,170 --> 00:06:05,400
0,240 240,270 270,540 540,750 750,1230
happened a couple weeks ago,|
|

202
00:06:05,700 --> 00:06:07,110
0,510 510,960 960,1140 1140,1230 1230,1410
{} and you can just
你可以看着它们，

203
00:06:07,110 --> 00:06:08,490
0,120 120,240 240,840 840,1170 1170,1380
look at them| and see
|看看有哪些主题，

204
00:06:08,490 --> 00:06:09,450
0,180 180,300 300,360 360,810 810,960
what kind of topics are

205
00:06:09,450 --> 00:06:10,800
0,390 390,840 840,990 990,1050 1050,1350
covered| and read the papers
|看看你觉得有趣的论文，

206
00:06:10,800 --> 00:06:11,760
0,120 120,210 210,420 420,510 510,960
that you find it interesting,|
|

207
00:06:11,760 --> 00:06:13,050
0,180 180,270 270,660 660,720 720,1290
all the talks are published,|
所有的讨论都发表了，|

208
00:06:13,410 --> 00:06:14,820
0,150 150,390 390,450 450,840 840,1410
{} one of advantages of,
会议的优势之一，

209
00:06:14,820 --> 00:06:16,080
0,120 120,540
you know,

210
00:06:16,170 --> 00:06:17,370
0,390 390,780 780,930 930,1080 1080,1200
{conference -},| that all these
|所有这些会议都是虚拟的，

211
00:06:17,370 --> 00:06:18,750
0,360 360,450 450,1020 1020,1200 1200,1380
conference are virtual,| and so
|所以所有的会议都被记录下来了，

212
00:06:18,750 --> 00:06:21,090
0,210 210,780 810,1290 1290,1800 1800,2340
all the conferences {} are

213
00:06:21,120 --> 00:06:22,110
0,480 480,570 570,690 690,780 780,990
recorded,| and you can just
|你可以查看它们，看看发生了什么。

214
00:06:22,110 --> 00:06:23,670
0,210 210,450 450,1110 1140,1410 1410,1560
watch them and see what's

215
00:06:23,670 --> 00:06:24,720
0,210 210,510
going on.|
|

216
00:06:24,850 --> 00:06:26,260
0,210 210,300 300,690 690,1020 1020,1410
If you interested in the
如果你对这两部分感兴趣，

217
00:06:26,290 --> 00:06:27,430
0,240 240,300 300,480 480,810 810,1140
sort of two parts,| there's
|这里有研究的部分，

218
00:06:27,430 --> 00:06:29,290
0,120 120,480 480,960 1350,1620 1620,1860
the research part,| {} then
|当然还有实践中正在进行的事情。

219
00:06:29,290 --> 00:06:30,430
0,90 90,300 300,690 690,900 900,1140
of course there's what's going

220
00:06:30,430 --> 00:06:31,570
0,180 180,240 240,690 690,1020 1020,1140
on in practice.| And you
|如果你有兴趣

221
00:06:31,570 --> 00:06:32,890
0,120 120,270 270,570 570,1020 1020,1320
know if you're interested in|
|

222
00:06:32,920 --> 00:06:34,210
0,330 330,720 720,780 780,930 930,1290
keeping track of what's happening
跟踪 Linux 正在发生的事情，

223
00:06:34,210 --> 00:06:35,830
0,150 150,600 600,960 960,1200 1200,1620
with Linux| and how that's
|以及它是如何发展的，

224
00:06:36,070 --> 00:06:39,010
0,630 630,780 780,1440 1800,2610 2610,2940
how it's evolving,| {lwn.net -
|lwn.net 发布了常规的页面和非常有趣的文章，

225
00:06:39,010 --> 00:06:40,360
0,270 270,450 450,690 690,990 990,1350
- - -} actually publish

226
00:06:40,360 --> 00:06:42,100
0,780 780,1020 1020,1350 1350,1650 1650,1740
a very regular page and

227
00:06:42,100 --> 00:06:43,780
0,420 420,690 690,1020 1020,1410 1410,1680
a very interesting articles| about
|关于围绕 Linux 内核的重大变化或话题。

228
00:06:43,780 --> 00:06:46,210
0,210 240,480 480,1170 1170,1620 1770,2430
like big changes or topics

229
00:06:46,210 --> 00:06:47,620
0,210 210,390 390,1050 1050,1140 1140,1410
that are around the Linux

230
00:06:47,620 --> 00:06:48,340
0,390
kernel.|
|

231
00:06:49,470 --> 00:06:51,480
0,570 630,1140 1140,1230 1230,1590 1590,2010
{} Finally you know, {}
最后，如果你对做实验感到兴奋，

232
00:06:51,510 --> 00:06:52,920
0,210 210,360 360,780 810,1200 1200,1410
if you're just excited about

233
00:06:52,920 --> 00:06:54,000
0,180 180,510 510,570 570,990 990,1080
like doing the labs,| you
|只需要继续 hack 就行了，

234
00:06:54,000 --> 00:06:55,500
0,150 150,360 360,690 720,1080 1080,1500
know just keep keep hacking,|
|

235
00:06:55,620 --> 00:06:57,420
0,270 270,540 570,720 720,1110 1470,1800
{} I think you can
我认为你可以很容易地创造出项目，

236
00:06:57,450 --> 00:06:58,920
0,450 450,570 570,750 750,870 870,1470
easily to cook up projects|
|

237
00:06:58,920 --> 00:07:01,740
0,1020 1050,1410 1410,1680 1680,2040 2040,2820
are either by doing extension
要么通过扩展实验，

238
00:07:01,740 --> 00:07:02,940
0,120 120,570 570,810 810,990 990,1200
of labs| or just trying
|或者试一试你自己的事情，

239
00:07:02,940 --> 00:07:03,870
0,210 210,360 360,420 420,600 600,930
things out on your own,|
|

240
00:07:04,740 --> 00:07:06,330
0,270 270,330 330,660 660,1050 1050,1590
it's a great way to
这是学习和查看事物运作方式的一种很好的方式。

241
00:07:06,330 --> 00:07:08,730
0,390 390,870 870,1050 1800,2310 2310,2400
really learn and appreciate how

242
00:07:08,730 --> 00:07:10,060
0,210 210,630
things work.|
|

243
00:07:10,090 --> 00:07:11,050
0,150 150,480 480,750 750,780 780,960
You probably got a good
你在实验里可能对此有很好的感觉，

244
00:07:11,050 --> 00:07:11,830
0,210 210,270 270,480 480,690 690,780
sense of that during the

245
00:07:11,830 --> 00:07:14,290
0,480 480,930 1230,1920 1920,2160 2160,2460
labs,| we're {sort,of} big fans
|我们是边做边学的铁杆粉丝，

246
00:07:14,290 --> 00:07:16,210
0,150 150,420 420,570 570,1050 1230,1920
of learning by doing| and
|还有很多你自己可以做的事。

247
00:07:16,210 --> 00:07:19,360
0,450 2340,2820 2820,2970 2970,3060 3060,3150
a lot that you can

248
00:07:19,360 --> 00:07:20,460
0,90 90,240 240,420 420,630
do on your own.|
|

249
00:07:20,960 --> 00:07:22,200
0,690

250
00:07:22,930 --> 00:07:24,900
0,390 390,930 930,1500
Any questions about
关于 6.S081 之后的下一步，还有什么问题吗？

251
00:07:26,850 --> 00:07:29,130
0,240 240,780 1080,1770 1770,1920 1920,2280
what next after {6.S081 -}?|
|

252
00:07:41,410 --> 00:07:42,520
0,600
Okay?|
好的？|

253
00:07:43,180 --> 00:07:44,620
0,210 210,420 420,780 780,990 990,1440
Well, let's talk about the
好吧，我们来谈谈网络实验室，

254
00:07:45,790 --> 00:07:47,140
0,300 300,840
net lab,|
|

255
00:07:47,360 --> 00:07:49,640
0,1020 1350,1650 1650,1860 1860,2130 2130,2280
{} it was due I
我想昨天就该交了。

256
00:07:49,640 --> 00:07:52,420
0,180 180,1050 1500,2250
guess yesterday {}.|
|

257
00:07:54,500 --> 00:07:55,780
0,690

258
00:07:56,100 --> 00:07:57,990
0,210 210,720 840,1290 1290,1680 1680,1890
And so as a couple
因此，作为几件事，也许我会开始慢慢潜水，

259
00:07:57,990 --> 00:07:59,610
0,360 360,690 690,840 840,1200 1200,1620
things maybe I'll start {}

260
00:07:59,820 --> 00:08:01,980
0,390 390,720 750,1620 1620,1950 1950,2160
dive in slowly,| I start
|我从最高层开始一点

261
00:08:01,980 --> 00:08:02,460
0,60 60,210 210,300 300,390 390,480
a little bit at the

262
00:08:02,460 --> 00:08:05,100
0,480 840,1440 1590,2370 2370,2430 2430,2640
top| and let me talk
|让我用泛泛的术语来谈谈实验室。

263
00:08:05,100 --> 00:08:06,420
0,60 60,240 240,390 390,570 570,1320
a little bit in generic

264
00:08:06,450 --> 00:08:09,340
0,570 570,990 1590,1950 1950,2400
terms about the lab.|
|

265
00:08:13,390 --> 00:08:14,710
0,630 630,660 660,870 870,1050 1050,1320
There's a couple things right,|
有几件事是对的，|

266
00:08:14,710 --> 00:08:15,490
0,210 210,210 210,420 420,600 600,780
first I want to talk
首先，我想稍微谈谈一些结构性的东西，

267
00:08:15,490 --> 00:08:16,480
0,60 60,240 240,360 360,570 570,990
a little bit about just

268
00:08:16,480 --> 00:08:18,320
0,90 90,780 780,1320
{sort,of} structural things,|
|

269
00:08:19,120 --> 00:08:20,530
0,360 360,720 720,840 840,930 930,1410
{} that sort of influence
这会影响实验室的设计，或者说你知道实验室的编码。

270
00:08:20,530 --> 00:08:21,820
0,270 270,750 750,840 840,900 900,1290
the design of the lab

271
00:08:21,820 --> 00:08:23,080
0,360 360,450 450,600 600,870 900,1260
or you know {} {the,coding}

272
00:08:23,080 --> 00:08:24,520
0,90 90,180 180,570 840,1260 1260,1440
of the lab.| And there
|在各方面有四种不同的东西，

273
00:08:24,520 --> 00:08:25,930
0,180 480,840 840,1110 1110,1320 1320,1410
are four different things in

274
00:08:25,930 --> 00:08:27,010
0,570 570,750 750,810 810,990 990,1080
aspects,| one of these I
|其中一个我只想谈一谈硬件，

275
00:08:27,010 --> 00:08:27,550
0,120 120,270 270,330 330,510 510,540
just want to talk a

276
00:08:27,550 --> 00:08:29,140
0,210 210,330 330,510 510,1110
little bit about hardware,|
|

277
00:08:29,140 --> 00:08:30,070
0,480 480,570 570,690 690,870 870,930
{} you know, this is
你知道，这是我们其中一个实验室，

278
00:08:30,070 --> 00:08:30,970
0,180 180,270 270,360 360,690 690,900
one of the labs where

279
00:08:30,970 --> 00:08:32,980
0,570 600,1200 1530,1800 1800,1860 1860,2010
we,| {} there's a lot
|软件和硬件之间有很多互动，

280
00:08:32,980 --> 00:08:34,090
0,90 90,480 480,720 720,1020 1020,1110
of interaction between software and

281
00:08:34,090 --> 00:08:35,260
0,270 270,360 360,630 630,870 870,1170
hardware,| in fact the hardware
|事实上，硬件在很大程度上决定了这一报价的结构。

282
00:08:35,260 --> 00:08:37,090
0,600 600,990 990,1170 1170,1440 1440,1830
determines for a great part

283
00:08:37,090 --> 00:08:38,740
0,150 150,360 360,630 990,1350 1350,1650
like how the the structure

284
00:08:38,740 --> 00:08:39,840
0,90 90,240 240,630
of this offer.|
|

285
00:08:40,250 --> 00:08:41,810
0,480 540,990 990,1080 1080,1260 1260,1560
{Then,a} little bit about software
然后稍微介绍一下软件结构，

286
00:08:41,810 --> 00:08:43,080
0,660
structure,|
|

287
00:08:43,170 --> 00:08:44,460
0,450 450,780 780,1050 1050,1230 1230,1290
{} and just sort of
我想回到这个一般性的话题上来

288
00:08:44,460 --> 00:08:45,660
0,270 270,390 390,540 540,840 840,1200
back to this general topic|
|

289
00:08:45,660 --> 00:08:46,650
0,150 150,240 240,570 570,720 720,990
that we covered in a
我们在学期中期的某个地方谈到了，你知道的，司机的组织

290
00:08:46,650 --> 00:08:47,790
0,180 180,390 600,990 990,1080 1080,1140
sort of somewhere in the

291
00:08:47,790 --> 00:08:48,810
0,210 210,270 270,360 360,690 690,1020
middle of the term about

292
00:08:48,810 --> 00:08:50,100
0,120 120,270 270,630 630,1200 1200,1290
you know the organization of

293
00:08:50,100 --> 00:08:51,330
0,420 420,810 810,930 930,1020 1020,1230
drivers| relative to the rest
|相对于睡觉的操作系统内核。

294
00:08:51,330 --> 00:08:52,560
0,60 60,210 210,510 510,780 780,1230
of the operating system kernel.|
|

295
00:08:52,890 --> 00:08:53,670
0,300 300,450 450,510 510,660 660,780
Then talk a little bit
然后再具体谈一下硬件结构，

296
00:08:53,670 --> 00:08:55,590
0,120 120,720 750,1110 1110,1410 1410,1920
more specific about hardware structures,|
|

297
00:08:55,590 --> 00:08:57,220
0,120 120,240 240,480 510,1200
you know the rings,
你知道戒指，你知道描述符，

298
00:08:57,340 --> 00:08:58,900
0,540 540,1230 1230,1290 1290,1440 1440,1560
{} and you know the

299
00:08:58,900 --> 00:09:01,000
0,780
descriptors,|
|

300
00:09:02,500 --> 00:09:03,880
0,270 270,540 540,750 750,1200 1200,1380
{} {are,the} two primary sort
是驱动程序处理或必须处理的两种主要硬件结构。

301
00:09:03,880 --> 00:09:05,230
0,60 60,330 330,810 810,1020 1020,1350
of hardware structures that the

302
00:09:05,530 --> 00:09:07,090
0,720 720,1050 1050,1350 1350,1500 1500,1560
driver deals with or it

303
00:09:07,090 --> 00:09:08,360
0,210 210,390 390,750
must deal with.|
|

304
00:09:08,780 --> 00:09:10,580
0,150 150,630 630,1050 1050,1200 1200,1800
And then I'll talk to
然后我会谈到代码，特别是解决方案，

305
00:09:10,610 --> 00:09:11,660
0,210 210,390 390,450 450,930 930,1050
talk about the code and

306
00:09:11,660 --> 00:09:14,030
0,360 360,450 450,1170 1560,2040 2040,2370
particularly the solutions,| {} and
|关注一下mbufs的作用，

307
00:09:14,060 --> 00:09:15,830
0,750 750,1110 1260,1380 1380,1650 1650,1770
focusing on a little bit

308
00:09:15,830 --> 00:09:16,700
0,270 270,360 360,600 600,690 690,870
about the role of {mbufs

309
00:09:16,700 --> 00:09:17,760
0,510
-},|
|

310
00:09:19,780 --> 00:09:21,070
0,150 150,270 270,900 1020,1140 1140,1290
you know locking a lot
你知道，通过电子邮件锁定了很多问题，

311
00:09:21,070 --> 00:09:22,690
0,60 60,600 690,1050 1050,1290 1290,1620
of questions {} over email,|
|

312
00:09:22,690 --> 00:09:24,460
0,540 630,1110 1110,1350 1350,1440 1440,1770
about why not to lock
关于为什么不锁定接收锁定、接收函数中的接收、

313
00:09:24,460 --> 00:09:26,710
0,330 330,720 720,1140 1230,1740 1740,2250
in receive lock, receive {}

314
00:09:26,710 --> 00:09:28,570
0,90 90,180 180,450 450,990 1080,1860
in the receive function,| why
|为什么接收处理程序中的循环，

315
00:09:28,570 --> 00:09:29,710
0,90 90,480 510,690 690,750 750,1140
the loop in the receive

316
00:09:29,710 --> 00:09:30,920
0,660
handler,|
|

317
00:09:31,140 --> 00:09:32,850
0,720 750,1350 1350,1440 1440,1530 1530,1710
and {} you know what
你知道你所知道的旗帜的意思是什么吗，

318
00:09:32,850 --> 00:09:34,980
0,600 600,690 690,870 870,1470 1680,2130
exactly you know the {flags

319
00:09:34,980 --> 00:09:36,810
0,90 90,420 420,480 480,1020 1080,1830
-} meaning the command,| {}
|描述符结构的命令字段，

320
00:09:36,840 --> 00:09:38,310
0,480 480,990 1020,1320 1320,1410 1410,1470
command {} field of the

321
00:09:38,310 --> 00:09:40,710
0,420 420,510 510,600 600,1200 1740,2400
structure of the descriptor {},|
|

322
00:09:40,710 --> 00:09:41,610
0,210 210,450 450,720 720,840 840,900
and so we'll get to
因此，我们将在查看代码的同时查看顶部，从而了解这些问题。

323
00:09:41,610 --> 00:09:42,600
0,240 240,510 510,630 630,870 870,990
those issues as we as

324
00:09:42,600 --> 00:09:43,440
0,150 150,330 330,420 420,480 480,840
we look at the top

325
00:09:43,830 --> 00:09:44,430
0,150 150,300 300,450 450,540 540,600
as we look at the

326
00:09:44,430 --> 00:09:45,240
0,390
code.|
|

327
00:09:45,330 --> 00:09:46,380
0,540

328
00:09:47,110 --> 00:09:48,730
0,330 330,660 660,1230 1230,1500 1500,1620
Just before {drive,in} it, may
就在开车之前，可能是值得的，

329
00:09:48,730 --> 00:09:50,320
0,150 150,720 720,840 840,1230 1230,1590
be worthwhile,| so reminding ourselves
|所以在这里提醒我们自己，挑战是什么，尽管它们可能还在你的脑海中记忆犹新

330
00:09:50,320 --> 00:09:51,730
0,300 300,480 480,720 720,1200 1200,1410
here, what the challenges are

331
00:09:51,730 --> 00:09:53,530
0,360 420,720 720,1230 1470,1740 1740,1800
although they're probably fresh in

332
00:09:53,530 --> 00:09:55,030
0,150 150,510 540,1200 1230,1440 1440,1500
your head| like from a
|比如从高水平和核心人才挑战的角度来看，这是你在这个实验室必须面对的问题之一。

333
00:09:55,030 --> 00:09:56,140
0,180 180,660 660,810 810,1020 1020,1110
high level and one of

334
00:09:56,140 --> 00:09:57,370
0,90 90,270 270,360 360,840 840,1230
the sort of core talent

335
00:09:57,370 --> 00:09:58,780
0,450 450,660 660,1200 1200,1320 1320,1410
challenges that you have to

336
00:09:58,780 --> 00:09:59,680
0,180 180,300 300,360 360,510 510,900
deal with in this lab.|
|

337
00:10:01,610 --> 00:10:02,900
0,150 150,360 360,660 660,930 1020,1290
If you'll jump in {}
如果你要跳进去的话还有任何我可能错过的和你挣扎过的。

338
00:10:02,900 --> 00:10:04,490
0,360 360,690 690,930 930,1230 1230,1590
to and any ones that

339
00:10:04,490 --> 00:10:05,450
0,30 30,240 240,330 330,600 600,960
I might have missed and

340
00:10:05,450 --> 00:10:07,000
0,180 360,780 780,990
you struggled with.|
|

341
00:10:07,030 --> 00:10:08,050
0,180 180,390 390,450 450,840 870,1020
So, first of all you
那么，首先你知道有硬件规格，

342
00:10:08,050 --> 00:10:09,610
0,120 120,360 360,450 450,750 750,1560
know there's the hardware specification,|
|

343
00:10:10,120 --> 00:10:12,610
0,660 900,1770 1770,1980 2010,2220 2220,2490
{} you know it's a
你知道这是一份PDF文件，是一份相当严肃的文件，

344
00:10:13,210 --> 00:10:14,890
0,570 570,690 690,960 990,1380 1380,1680
PDF, is a pretty serious

345
00:10:14,890 --> 00:10:17,530
0,630 1080,1530 1530,1980 1980,2340 2340,2640
document,| {} and this network
|而这个网络部件E1000，尽管它是一个合理的简单网卡，

346
00:10:17,530 --> 00:10:20,620
0,480 510,1500 1500,2850 2850,2970 2970,3090
part {} {E1000,,even} though it's

347
00:10:20,620 --> 00:10:22,420
0,450 450,720 720,1290 1290,1620 1620,1800
a reasonable simple network card,|
|

348
00:10:22,420 --> 00:10:24,010
0,360 360,660 660,690 690,900 900,1590
is still a very sophisticated
仍然是一件非常复杂的硬件，

349
00:10:24,010 --> 00:10:25,690
0,210 240,480 480,540 540,1140 1410,1680
{} piece of hardware {},|
|

350
00:10:25,690 --> 00:10:26,440
0,210 210,420 420,480 480,690 690,750
that offers a lot of
它提供了许多不同的功能和编程方式

351
00:10:26,440 --> 00:10:28,330
0,240 240,750 750,1290 1320,1680 1680,1890
different features and ways you

352
00:10:28,330 --> 00:10:30,940
0,600 720,1350 1380,1830 2160,2400 2400,2610
can program| and you're just
|你只是掌握了你所知道的卡的功能，以及你是如何对它进行编程的，

353
00:10:30,940 --> 00:10:32,260
0,330 330,450 450,840 840,960 960,1320
getting on top of actually

354
00:10:32,260 --> 00:10:33,640
0,270 270,630 630,780 780,1050 1050,1380
what you know the card

355
00:10:33,640 --> 00:10:35,140
0,570 600,1020 1020,1230 1230,1350 1350,1500
does and how do you

356
00:10:35,140 --> 00:10:36,670
0,420 420,630 900,1350 1350,1440 1440,1530
program it,| {} you know
|你知道，仅仅将所有这些都内在化是困难的，也是一个挑战。

357
00:10:36,670 --> 00:10:38,470
0,210 210,1050 1050,1200 1200,1560 1680,1800
just internalizing all that {}

358
00:10:38,470 --> 00:10:41,170
0,960 960,1440 1500,2070 2280,2610 2610,2700
is difficult and poses a

359
00:10:41,170 --> 00:10:41,960
0,510
challenge.|
|

360
00:10:42,420 --> 00:10:43,600
0,660

361
00:10:45,280 --> 00:10:46,460
0,630

362
00:10:46,520 --> 00:10:48,260
0,870 900,1020 1020,1350 1350,1470 1470,1740
Second, I think you know
第二，我想你知道主要的挑战，事情的并发性，

363
00:10:48,290 --> 00:10:50,390
0,330 330,930 930,1320 1350,1860 1860,2100
major challenges, the concurrency side

364
00:10:50,390 --> 00:10:51,560
0,90 90,570
of things,|
|

365
00:10:52,620 --> 00:10:53,520
0,240 240,330 330,480 480,570 570,900
and there's sort of two
有两个部分的并发性使这个实验具有挑战性，

366
00:10:53,520 --> 00:10:55,440
0,540 540,1170 1200,1590 1590,1710 1710,1920
parts the concurrency that makes

367
00:10:55,440 --> 00:10:58,260
0,240 240,960 960,1830 1950,2460 2460,2820
this lab challenging,| one is
|一个就是硬件和软件之间的并发性，

368
00:10:58,260 --> 00:10:59,280
0,210 210,270 270,690 690,960 960,1020
just the concurrency between the

369
00:10:59,280 --> 00:11:00,760
0,330 330,450 450,930
hardware and software,|
|

370
00:11:01,060 --> 00:11:02,830
0,420 420,540 540,870 870,1410 1440,1770
like the network card is
就像网卡就是在做一些事情，像发送数据包，同时接收数据包，

371
00:11:02,830 --> 00:11:04,210
0,240 240,510 510,870 870,1050 1050,1380
just doing things, like sending

372
00:11:04,210 --> 00:11:05,650
0,450 450,870 870,1290 1290,1350 1350,1440
package, receiving packets at the

373
00:11:05,650 --> 00:11:07,480
0,300 300,1020 1020,1170 1170,1560 1560,1830
same time,| {you,know,the} OS kernel
|您知道操作系统内核正在运行，并且驱动程序正在运行

374
00:11:07,480 --> 00:11:08,380
0,90 90,360 360,450 450,510 510,900
is running and the driver

375
00:11:08,380 --> 00:11:09,670
0,90 90,390 720,1080 1080,1170 1170,1290
is running| and so there
|所以在硬件和软件之间必须有一些协调计划，

376
00:11:09,670 --> 00:11:10,990
0,150 150,240 240,330 330,750 750,1320
has to be some coordination

377
00:11:10,990 --> 00:11:13,420
0,600 780,1500 1500,1590 1590,2220 2220,2430
plan between the {hardware,and,software -},|
|

378
00:11:13,420 --> 00:11:14,530
0,120 120,330 330,600 600,750 750,1110
{you,know} to actually make sure
你知道要确保每件事都能顺利解决。

379
00:11:14,530 --> 00:11:16,860
0,240 240,600 600,900 900,1260
that everything works out.|
|

380
00:11:16,860 --> 00:11:17,970
0,270 270,540 540,570 570,900 900,1110
{} And a large part
你知道，很大一部分司机都在处理这种协调问题。

381
00:11:17,970 --> 00:11:19,770
0,60 60,120 120,720 840,1200 1200,1800
of the driver {} is

382
00:11:19,770 --> 00:11:22,020
0,120 120,1020 1050,1710 1710,1830 1830,2250
you know dealing with that

383
00:11:22,050 --> 00:11:23,340
0,750
coordination.|
|

384
00:11:23,860 --> 00:11:25,510
0,510 660,1050 1050,1260 1260,1350 1350,1650
{} There's also the software
还有软件转换协调软件，

385
00:11:25,510 --> 00:11:27,020
0,360 360,960
software convert

386
00:11:27,250 --> 00:11:30,700
0,930 1290,1590 1590,2400 2610,3060 3060,3450
coordination,| the driver multiple threads,
|驱动程序多线程，其中多个内核线程可能在驱动程序内部运行的处理程序周围结束

387
00:11:30,700 --> 00:11:32,050
0,150 150,480 480,780 780,1080 1080,1350
where multiple kernel threads might

388
00:11:32,050 --> 00:11:34,060
0,270 270,660 660,900 900,1500 1530,2010
be ending around handler run

389
00:11:34,060 --> 00:11:36,100
0,420 420,480 480,570 570,1170 1410,2040
inside of the driver {}|
|

390
00:11:36,100 --> 00:11:36,730
0,210 210,300 300,420 420,480 480,630
and we've got to make
我们要确保他们不会互相践踏，不会有其他事情发生

391
00:11:36,730 --> 00:11:38,560
0,210 210,330 330,930 960,1440 1470,1830
sure that they don't step

392
00:11:38,560 --> 00:11:40,630
0,150 150,270 270,540 540,1050 1710,2070
on each other's toes, nothing

393
00:11:40,630 --> 00:11:42,190
0,300 300,840 840,1020 1140,1380 1380,1560
else happens| and this comes
|这很像你知道的锁定主题。

394
00:11:42,190 --> 00:11:42,970
0,60 60,300 300,510 510,720 720,780
a lot to like you

395
00:11:42,970 --> 00:11:44,660
0,330 420,1230
know locking

396
00:11:44,660 --> 00:11:46,980
0,720 840,1770
{} topic.|
|

397
00:11:47,160 --> 00:11:49,140
0,510 510,810 810,1230 1230,1380 1380,1980
Even the, even this driver,|
就是那个，就是这个司机，|

398
00:11:49,140 --> 00:11:51,480
0,180 180,300 300,900 930,1560 1590,2340
thinks a reasonable {} straightforward,
就软件并发性而言，我认为这是一个合理的直截了当的想法，

399
00:11:51,660 --> 00:11:53,220
0,300 300,570 570,690 690,1110 1140,1560
in terms of the concurrency

400
00:11:53,220 --> 00:11:55,830
0,570 720,1110 1110,1770 1800,2130 2130,2610
for software concurrency,| but nevertheless
|但是尽管如此，你还是知道一些需要注意和思考的事情。

401
00:11:55,830 --> 00:11:57,540
0,210 210,510 510,870 870,1230 1230,1710
{you,know} something that requires attention

402
00:11:57,540 --> 00:11:58,080
0,120 120,180 180,360 360,480 480,540
and a little bit of

403
00:11:58,080 --> 00:11:58,940
0,360
thinking.|
|

404
00:11:59,260 --> 00:12:00,820
0,210 210,570 570,690 690,900 900,1560
And finally I guess I
最后，我想我可能在你名单的首位，或者你的许多名单上，

405
00:12:01,450 --> 00:12:02,410
0,150 150,600 600,720 720,780 780,960
was probably on the top

406
00:12:02,410 --> 00:12:03,430
0,60 60,240 240,570 570,720 720,1020
of your list or many

407
00:12:03,430 --> 00:12:05,140
0,90 90,270 270,900 900,1080 1080,1710
of your list,| just debugging
|仅仅是调试就有点困难，

408
00:12:05,320 --> 00:12:06,940
0,270 270,630 900,1290 1290,1500 1500,1620
this is a little bit

409
00:12:06,940 --> 00:12:08,040
0,510
hard,|
|

410
00:12:08,070 --> 00:12:09,510
0,360 360,450 450,780 780,960 960,1440
{a,little,bit -} something more challenging
更具挑战性的纯软件调试，

411
00:12:09,510 --> 00:12:11,160
0,150 150,450 450,810 810,1230 1230,1650
{} {of,pure} software debugging,| because
|因为您不能在网卡内部设置断点，

412
00:12:11,310 --> 00:12:13,140
0,360 360,600 600,1020 1050,1530 1530,1830
you can't set {breakpoints -}

413
00:12:13,140 --> 00:12:14,490
0,420 420,510 510,600 600,900 900,1350
inside of the network card,|
|

414
00:12:14,550 --> 00:12:15,960
0,150 150,270 270,540 540,870
you know you're in
你知道你在给寄存器编程

415
00:12:15,960 --> 00:12:17,910
0,540 540,630 630,1380 1380,1560 1560,1950
program the registers| and then
|然后这会给卡片一脚，说“请做好你的工作”

416
00:12:17,910 --> 00:12:18,720
0,150 150,300 300,450 450,540 540,810
this would give the card

417
00:12:18,720 --> 00:12:19,650
0,30 30,330 330,420 420,540 540,930
a kick and say like

418
00:12:19,650 --> 00:12:21,480
0,210 210,300 300,450 450,840 1320,1830
please do your work| and
|然后如果卡什么也不做，或者你看不到你的包从另一面出来，

419
00:12:21,480 --> 00:12:22,170
0,120 120,210 210,270 270,420 420,690
then if the card doesn't

420
00:12:22,170 --> 00:12:23,070
0,150 150,540 540,690 690,780 780,900
do anything or you don't

421
00:12:23,070 --> 00:12:24,090
0,120 120,240 240,570 570,840 840,1020
see your packet coming out

422
00:12:24,090 --> 00:12:25,080
0,90 90,210 210,390 390,900 900,990
on the other side,| you
|你知道，在数据包率的记录中，

423
00:12:25,080 --> 00:12:27,360
0,150 150,420 960,1230 1230,1800 1920,2280
know in the log of

424
00:12:27,360 --> 00:12:28,140
0,300
{}

425
00:12:28,460 --> 00:12:31,520
0,420 450,780 780,1260 1590,2670 2700,3060
the packet rates,| then you
|那你基本上就得挠你的头

426
00:12:31,520 --> 00:12:32,480
0,360 360,510 510,600 600,840 840,960
basically have to scratch your

427
00:12:32,480 --> 00:12:34,070
0,270 270,480 480,900 900,1200 1200,1590
head| and start thinking about
|并开始思考您可能出了什么问题，或者您可能在硬件规范中遗漏了什么，

428
00:12:34,070 --> 00:12:35,810
0,570 570,780 780,1380 1380,1500 1500,1740
what you might have gone

429
00:12:35,810 --> 00:12:36,920
0,300 300,450 450,690 690,810 810,1110
wrong or what you might

430
00:12:36,920 --> 00:12:38,450
0,150 150,540 540,810 810,1200 1200,1530
have missed in the hardware

431
00:12:38,450 --> 00:12:41,570
0,900 1770,2490 2670,2850 2850,2940 2940,3120
specification,| and you have to
|你必须来回绕圈

432
00:12:41,570 --> 00:12:42,770
0,330 330,570 570,660 660,960 960,1200
circle back and forth| and
|而且没有一种简单的方法，

433
00:12:42,830 --> 00:12:43,970
0,300 300,450 450,630 630,840 840,1140
there's no sort of easy

434
00:12:43,970 --> 00:12:46,610
0,660 660,1290 1290,1860 1860,2130 2130,2640
way,| {} you just cannot
|你不能单步通过网卡，你知道的。

435
00:12:46,610 --> 00:12:48,700
0,270 270,810 840,990 990,1650
single step {you,know} through

436
00:12:48,730 --> 00:12:50,420
0,300 330,720 720,1140
the network card.|
|

437
00:12:52,550 --> 00:12:53,480
0,150 150,270 270,540 570,870 870,930
Does that make sense in
就挑战而言，这有意义吗？

438
00:12:53,480 --> 00:12:54,500
0,180 180,270 270,810 810,900 900,1020
terms of challenges| you know
|你知道，这与你自己的经历是一致的

439
00:12:54,500 --> 00:12:55,940
0,150 150,300 300,540 540,990 990,1440
there's that line up with

440
00:12:55,940 --> 00:12:57,500
0,180 180,330 330,900 900,1260 1320,1560
your own experience| or {}
|或者我错过了一些，错过了你处理的核心挑战之一。

441
00:12:57,500 --> 00:12:58,670
0,60 60,450 450,690 690,810 810,1170
I missing some of the,

442
00:12:59,410 --> 00:13:00,550
0,600 600,750 750,810 810,870 870,1140
missing one of the core

443
00:13:00,550 --> 00:13:01,930
0,510 510,690 690,870 870,1140 1140,1380
challenges that you dealt with.|
|

444
00:13:18,330 --> 00:13:21,020
0,300 300,510 510,2160
Okay, well, yeah.|
好的，嗯，是的。|

445
00:13:21,390 --> 00:13:22,350
0,180 180,390 390,480 480,600 600,960
Let's talk to the, {}
让我们来谈谈，让我们从硬件方面开始，

446
00:13:22,350 --> 00:13:23,640
0,180 180,390 390,600 600,870 870,1290
let's start with the hardware

447
00:13:23,640 --> 00:13:25,560
0,210 210,270 270,720 810,1440 1440,1920
side of things,| {} and
|我想从那里开始的原因是，

448
00:13:25,950 --> 00:13:27,300
0,360 840,960 960,1140 1140,1170 1170,1350
{} the reason I want

449
00:13:27,300 --> 00:13:28,920
0,60 60,330 330,570 570,1080 1140,1620
to start there,| because {}
|因为你知道，很容易记住或忘记这样一个事实，你实际上是在和硬件打交道，

450
00:13:28,920 --> 00:13:29,490
0,120 120,180 180,270 270,360 360,570
you know, it's so easy

451
00:13:29,490 --> 00:13:30,960
0,60 60,420 420,660 660,1170 1170,1470
to keep or lose track

452
00:13:30,960 --> 00:13:31,740
0,60 60,150 150,420 420,570 570,780
of the fact that you're

453
00:13:31,740 --> 00:13:33,000
0,270 270,480 480,570 570,930 930,1260
actually dealing with hardware here,|
|

454
00:13:33,360 --> 00:13:35,070
0,540 540,630 630,840 900,1140 1140,1710
{} you know even through
您知道，即使通过您知道的某种虚拟化，QEMU也会对其进行模拟

455
00:13:35,070 --> 00:13:36,300
0,120 120,270 270,540 540,600 600,1230
you know sort of virtualized

456
00:13:36,300 --> 00:13:38,070
0,240 240,360 360,660 660,1560 1560,1770
where it is emulated by

457
00:13:38,070 --> 00:13:39,570
0,360 360,750 750,1140 1140,1320 1320,1500
{QEMU -}| and you're just
|你只是在你的雅典娜或你的笔记本电脑上运行它，

458
00:13:39,570 --> 00:13:41,100
0,210 210,330 330,510 510,1080
running it on your,

459
00:13:41,130 --> 00:13:42,030
0,270 270,390 390,510 510,750 750,900
on {Athena - -} or

460
00:13:42,030 --> 00:13:44,280
0,120 120,780 930,1320 1320,1800 1800,2250
your laptop,| {} the actual
|QEMU实现的实际内容是硬件。

461
00:13:44,280 --> 00:13:45,840
0,180 180,330 330,810 810,930 930,1560
thing that's implemented by QEMU

462
00:13:45,840 --> 00:13:47,100
0,120 120,570 750,900 900,990 990,1260
is hardware.| So it's usually
|所以它通常会再次提醒你，

463
00:13:47,100 --> 00:13:48,810
0,150 150,360 360,450 450,900 1140,1710
gonna remind you again,| you've
|你以前看过这张照片，

464
00:13:48,810 --> 00:13:50,880
0,150 150,240 240,510 510,1140 1410,2070
seen this picture before {},|
|

465
00:13:50,880 --> 00:13:51,660
0,90 90,210 210,330 330,660 660,780
you know the way to
你知道思考这件事的方式是

466
00:13:51,660 --> 00:13:52,680
0,150 150,450 450,570 570,720 720,1020
think about it is that|
|

467
00:13:52,680 --> 00:13:54,060
0,90 90,240 240,840 840,1350 1350,1380
you know QEMU emulate a
你知道，QEMU模拟一个完整的设备和处理器电路板。

468
00:13:54,060 --> 00:13:57,060
0,420 420,1050 1200,1890 1890,2370 2490,3000
complete board {} of {}

469
00:13:57,060 --> 00:13:59,480
0,870 870,1410 1410,2040
devices and processor.|
|

470
00:13:59,750 --> 00:14:02,240
0,480 480,1020 1410,1950
{} And um.|
还有嗯。|

471
00:14:02,370 --> 00:14:03,840
0,540 840,1200

472
00:14:04,220 --> 00:14:05,990
0,450 450,720 720,900 900,1650 1650,1770
{} And so we all
所以我们都知道我会在开始之前稍微谈一谈，

473
00:14:05,990 --> 00:14:06,740
0,210 210,330 330,510 510,600 600,750
know I'll talk a little

474
00:14:06,740 --> 00:14:08,210
0,180 180,450 450,780 780,1080 1080,1470
bit before about,| the processor
|处理器实际上就像整个电路板的一小块，

475
00:14:08,210 --> 00:14:09,350
0,210 210,360 360,510 510,690 690,1140
actually these are like almost

476
00:14:09,350 --> 00:14:11,000
0,180 180,240 240,570 570,1140
like a small piece

477
00:14:11,000 --> 00:14:12,440
0,120 120,240 240,900
of the whole

478
00:14:12,530 --> 00:14:14,090
0,690 690,1170 1170,1260 1260,1380 1380,1560
{} board,| you know the
|你知道这扇子上的东西吗，

479
00:14:14,090 --> 00:14:14,810
0,150 150,270 270,450 450,540 540,720
thing that sits on the

480
00:14:14,810 --> 00:14:16,820
0,300 300,630 870,1500 1500,1740 1740,2010
fan here,| {} but then
|但是还有一系列设备，您知道这些设备都连接到或可以连接到这块板上

481
00:14:16,820 --> 00:14:19,010
0,450 450,720 720,1260 1260,1410 1410,2190
there's a range of devices,

482
00:14:19,010 --> 00:14:20,780
0,90 90,240 240,570 570,1110 1140,1770
you know that are connected

483
00:14:20,810 --> 00:14:21,710
0,150 150,330 330,420 420,810 810,900
or can be connected to

484
00:14:21,710 --> 00:14:23,990
0,180 180,600 930,1530 1530,1680 1680,2280
this board| and then interact
|然后进行交互，你知道我们使用在处理器上运行的代码，

485
00:14:23,990 --> 00:14:25,430
0,90 90,360 360,510 510,660 660,1440
you know we use the

486
00:14:25,460 --> 00:14:26,840
0,390 390,660 660,750 750,840 840,1380
code running on the processor,|
|

487
00:14:26,840 --> 00:14:28,460
0,120 120,300 300,1110 1110,1350 1350,1620
you know here use this
你知道在这里使用这个特殊的实验室，

488
00:14:28,460 --> 00:14:30,020
0,330 330,750 750,1080 1080,1200 1200,1560
particular lab,| what is really
|真正有趣的是，它实际上是以太网插孔

489
00:14:30,020 --> 00:14:31,160
0,420 420,600 600,720
interesting sort of,

490
00:14:31,280 --> 00:14:32,510
0,180 180,360 360,840 840,1080 1080,1230
it is actually {Ethernet -}

491
00:14:32,510 --> 00:14:33,920
0,420 540,960 960,1050 1050,1200 1200,1410
jack| where you can block
|在那里可以使用挡路以太网电缆

492
00:14:33,920 --> 00:14:35,240
0,480 480,600 600,1050 1050,1200 1200,1320
{Ethernet -} cable| and then
|然后另一个实际上是你知道的网卡把它的包送过来。

493
00:14:35,240 --> 00:14:36,050
0,60 60,240 240,330 330,690 690,810
the other is actually the

494
00:14:36,050 --> 00:14:37,370
0,300 300,420 420,510 510,810 810,1320
thing that the network card

495
00:14:37,370 --> 00:14:38,660
0,120 120,450 450,630 630,990 990,1290
{you,know} sends its package over.|
|

496
00:14:40,440 --> 00:14:42,870
0,600 630,1260 1440,2010 2010,2160 2160,2430
{} {You,know}, {QEMU -} doesn't
你知道，QEMU并不完全模仿这块板，

497
00:14:42,870 --> 00:14:44,880
0,360 360,750 750,960 960,1380 1650,2010
emulate exactly this board,| {so,things}
|所以像这样的事情略有不同，

498
00:14:44,880 --> 00:14:46,170
0,180 180,300 300,810 810,960 960,1290
like {are,slightly} differently,| but again
|但是你也知道，至少在概念上，这就像这幅画，你应该把它放在你的脑海里，对吗？

499
00:14:46,170 --> 00:14:47,850
0,60 60,330 330,510 510,960 1080,1680
you know at least conceptually,

500
00:14:47,850 --> 00:14:48,750
0,180 180,300 300,510 510,570 570,900
this is like the picture,

501
00:14:48,750 --> 00:14:49,710
0,150 150,270 270,420 420,540 540,960
you should have in your

502
00:14:49,740 --> 00:14:50,820
0,210 210,330 330,660 690,960 960,1080
in your head right| and
|因此，当有写入寄存器的进程时，

503
00:14:50,820 --> 00:14:52,230
0,120 120,450 510,870 870,1020 1020,1410
so when there's a process

504
00:14:52,230 --> 00:14:54,450
0,390 510,1230 1230,1980 1980,2070 2070,2220
{} writing registers,| you know
|您知道设备驱动程序会花费一些东西才能发生

505
00:14:54,450 --> 00:14:55,980
0,180 180,330 330,750 750,1230 1260,1530
of the device driver that

506
00:14:55,980 --> 00:14:57,540
0,660 660,870 870,1110 1110,1200 1200,1560
costs some stuff to happen|
|

507
00:14:57,540 --> 00:14:58,860
0,150 150,480 480,840 840,1020 1020,1320
that actually ends some packages
这实际上结束了一些包裹从这根电缆里出来

508
00:14:58,860 --> 00:15:00,000
0,210 210,390 390,480 480,630 630,1140
comes out of this cable|
|

509
00:15:00,240 --> 00:15:02,320
0,480 480,930 930,1410
that's connected to
它连接到以太网接口。

510
00:15:02,380 --> 00:15:03,860
0,450 450,540 540,990
{Ethernet -} connector.|
|

511
00:15:05,840 --> 00:15:07,200
0,360 360,900
{You,know,in} a
你知道的稍微多一点，你知道的稍微多一点，在示意图中，

512
00:15:07,310 --> 00:15:10,190
0,540 540,1290 1380,2130 2130,2310 2310,2880
slightly more {} you know

513
00:15:12,680 --> 00:15:14,030
0,300 300,570 570,900 900,1200 1200,1350
{} {in,a} slightly more in

514
00:15:14,030 --> 00:15:17,150
0,1380 1530,2250 2250,2910 2910,3000 3000,3120
a schematic diagram,| you know
|你知道这里的照片基本上是一样的，

515
00:15:17,150 --> 00:15:18,380
0,180 180,330 330,630 630,930 930,1230
this is the same picture

516
00:15:18,380 --> 00:15:19,670
0,420 420,540 540,1050 1050,1110 1110,1290
basically in here,| you know
|你知道我们在这里看到的是我们的处理器，

517
00:15:19,670 --> 00:15:20,690
0,180 180,510 510,810 810,870 870,1020
we're seeing here is our

518
00:15:20,690 --> 00:15:21,920
0,750
processor,|
|

519
00:15:21,920 --> 00:15:23,300
0,180 180,570 570,690 690,990 990,1380
{} board that has four
上面有四个核心的电路板，

520
00:15:23,300 --> 00:15:24,890
0,480 480,690 690,930 1140,1530 1530,1590
cores on it,| {} it
|它具有L1和L2高速缓存，

521
00:15:24,890 --> 00:15:26,420
0,480 600,840 840,1110 1110,1230 1230,1530
has {l1 -} and l2

522
00:15:26,420 --> 00:15:27,920
0,540 540,720 720,1110 1110,1260 1260,1500
cache,| and then there's like
|然后有一种你知道的记忆中的联系，

523
00:15:27,920 --> 00:15:28,880
0,60 60,510 510,600 600,750 750,960
a link you know go

524
00:15:28,880 --> 00:15:30,020
0,90 90,540 690,840 840,930 930,1140
to memory,| so {here's -}
|这是一个存储器，当我随机存取存储器时

525
00:15:30,020 --> 00:15:30,710
0,30 30,420 420,510 510,630 630,690
a memory, and when I

526
00:15:30,710 --> 00:15:32,870
0,660 990,1350 1350,1620 1620,1980 1980,2160
RAM random access memory| and
|正如我们稍后将看到的，你知道游戏实际上是一个重要的角色。

527
00:15:32,990 --> 00:15:33,890
0,210 210,390 390,720 720,810 810,900
as we'll see in a

528
00:15:33,890 --> 00:15:35,150
0,360 360,480 480,660 660,1110 1110,1260
second, you know that play

529
00:15:35,150 --> 00:15:36,520
0,60 60,330 330,570 570,960
is actually big role.|
|

530
00:15:36,520 --> 00:15:37,990
0,210 210,600 600,840 840,1380 1380,1470
And here like intersection to
这里像交叉口连接到，因为这里实际上连接到千兆位以太网控制器。

531
00:15:37,990 --> 00:15:39,910
0,360 360,600 600,870 870,1380 1740,1920
link {you,know} to the, for

532
00:15:39,910 --> 00:15:40,990
0,270 270,510 510,690 690,960 960,1080
here actually it's linked to

533
00:15:40,990 --> 00:15:43,480
0,210 210,810 1110,1470 1470,2010
the gigabit Ethernet controller.|
|

534
00:15:44,350 --> 00:15:46,240
0,630 750,1320
{You,know}, {}
你知道，只是有点混乱，你会想一想这个级别的细节到底是怎么回事。

535
00:15:46,470 --> 00:15:47,550
0,210 210,240 240,390 390,510 510,1080
just a little bit messy

536
00:15:47,550 --> 00:15:48,390
0,150 150,390 390,450 450,600 600,840
you sort of think about

537
00:15:48,390 --> 00:15:50,640
0,450 570,840 840,1290 1290,1380 1380,2250
the this level of detail

538
00:15:50,640 --> 00:15:51,870
0,180 180,570 570,630 630,900 900,1230
what exactly is going on.|
|

539
00:15:51,930 --> 00:15:53,160
0,150 150,270 270,600 600,840 840,1230
And so {for,the,rest,of -} lecture
所以对于睡觉讲课来说，这里的图片稍微简单一点，

540
00:15:53,160 --> 00:15:54,060
0,150 150,270 270,510 510,660 660,900
here a little bit more

541
00:15:54,060 --> 00:15:56,520
0,630 1230,1980
simpler picture,|
|

542
00:15:58,240 --> 00:16:00,130
0,510 510,720 900,1260 1260,1530 1530,1890
and the picture guys really
照片上的人真的你是你在你的脑海里

543
00:16:00,130 --> 00:16:01,450
0,300 300,600 600,750 750,870 870,1320
you're you're in your head|
|

544
00:16:01,780 --> 00:16:04,570
0,870 900,1380 1380,1680 1680,2250 2280,2790
and you probably developed while
你可能是在做实验的时候开发的，如下所示。

545
00:16:04,570 --> 00:16:06,880
0,270 270,1110 1110,1230 1230,1770
doing lab {is,as} follows.|
|

546
00:16:07,780 --> 00:16:10,500
0,1380 1380,1680 1680,2220
Basically have are
基本上有四个处理器，或者说核心，

547
00:16:10,960 --> 00:16:12,940
0,300 300,570 570,1380
basically four processors,

548
00:16:13,360 --> 00:16:14,920
0,240 240,930
or cores,|
|

549
00:16:15,470 --> 00:16:17,480
0,270 270,480 480,750 750,1410
here's are {RISC-V -},|
这是RISC-V，|

550
00:16:19,120 --> 00:16:21,460
0,750 960,1170 1170,1770 1770,1980 1980,2340
and then there's {RISC-V -}
然后是内核和执行指令的RISC-V，你在写，

551
00:16:21,460 --> 00:16:22,960
0,330 330,660 660,990 990,1080 1080,1500
{} of cores and execute

552
00:16:22,960 --> 00:16:26,020
0,810 840,1260 1740,2160 2280,2550 2550,3060
instructions, {} you're you're writing,|
|

553
00:16:26,170 --> 00:16:27,160
0,420 420,540 540,660 660,840 840,990
and you can just think
你可以想想看，它们几乎都与你的公交车相连

554
00:16:27,160 --> 00:16:28,120
0,240 240,420 420,600 600,750 750,960
about them, they're sort of

555
00:16:28,150 --> 00:16:29,560
0,300 300,720 720,780 780,930 930,1410
all connected to your bus|
|

556
00:16:29,560 --> 00:16:30,190
0,90 90,240 240,390 390,450 450,630
and then there's a little
然后有一个小小的简化，

557
00:16:30,190 --> 00:16:32,050
0,150 150,270 270,450 810,1650 1650,1860
bit of a simplification,| but
|但这会让你更容易解释事情。

558
00:16:32,050 --> 00:16:33,040
0,150 150,300 300,480 480,600 600,990
like it makes it easier

559
00:16:33,040 --> 00:16:34,780
0,330 330,900 900,1320
to explain things.|
|

560
00:16:34,780 --> 00:16:36,190
0,240 240,420 420,900 900,960 960,1410
And so on the bus,
所以在公交车上，你知道那里有随机存取存储器，

561
00:16:36,190 --> 00:16:37,060
0,60 60,240 240,480 480,570 570,870
you know there's the random

562
00:16:37,060 --> 00:16:38,420
0,270 270,810
access memory,|
|

563
00:16:40,030 --> 00:16:41,560
0,480 480,720 720,810 810,1440 1470,1530
where all the data you
其中您所知道的内核实际使用的所有数据都是历史的，它本身存储的内核[]，

564
00:16:41,560 --> 00:16:43,120
0,120 120,240 240,570 570,900 900,1560
know the kernel actually uses

565
00:16:43,120 --> 00:16:44,890
0,840 840,900 900,1170 1170,1590 1590,1770
historic, the kernel [] that

566
00:16:44,890 --> 00:16:46,330
0,330 330,780 780,840 840,1170 1200,1440
itself stores,| you know look
|你知道吗，你看，在学期开始的时候有很多细节。

567
00:16:46,330 --> 00:16:47,320
0,90 90,330 330,480 510,810 810,990
at there's a great amount

568
00:16:47,320 --> 00:16:47,980
0,60 60,300 300,360 360,420 420,660
of detail in the beginning

569
00:16:47,980 --> 00:16:49,450
0,60 60,120 120,630 1020,1260 1260,1470
of the semester.| And then
|然后这就是你知道的这个特别的实验室，

570
00:16:49,450 --> 00:16:50,530
0,240 240,360 360,570 570,750 750,1080
this you know for {this,particular}

571
00:16:50,530 --> 00:16:51,730
0,330 330,420 420,540 540,720 720,1200
lab,| the thing that's interesting
|有趣的是，在公交车上，实际上是网卡，你知道E1000是什么。

572
00:16:51,730 --> 00:16:52,960
0,150 150,360 360,630 630,690 690,1230
is that on the bus,

573
00:16:53,570 --> 00:16:55,490
0,420 420,690 690,1230 1230,1500 1500,1920
{} is actually {} the

574
00:16:55,730 --> 00:16:57,100
0,360 360,810
network card,

575
00:16:57,320 --> 00:16:58,370
0,150 150,270 270,510 510,750 750,1050
you know {E1000 - -}

576
00:16:58,460 --> 00:16:59,920
0,150 150,270 270,450 450,900
what {E1000 - -}.|
|

577
00:17:01,910 --> 00:17:04,220
0,540 570,780 780,960 960,1470 1920,2310
And you know the RAM
您知道，RAM通常更多地通过一些专用总线直接连接到RISC-V处理器

578
00:17:04,220 --> 00:17:05,630
0,90 90,600 600,870 870,1260 1260,1410
is generally more connected to

579
00:17:05,630 --> 00:17:07,190
0,210 210,630 630,1050 1050,1440 1440,1560
the RISC-V processor directly with

580
00:17:07,190 --> 00:17:09,500
0,180 180,540 540,960 1140,1680 1680,2310
some private bus| {} and
|并且网络设备倾向于在较慢类型的总线上，

581
00:17:09,530 --> 00:17:11,630
0,690 690,1350 1350,1920 1920,1980 1980,2100
network devices tend to be

582
00:17:11,630 --> 00:17:12,890
0,180 180,240 240,960 990,1200 1200,1260
on a slower type of

583
00:17:12,890 --> 00:17:14,570
0,360 570,780 780,1170 1170,1410 1410,1680
bus,| in particular bus that
|尤其是实验室中总线，

584
00:17:14,570 --> 00:17:15,590
0,300 300,450 450,540 540,960 960,1020
{} in the lab,| you
|您知道，实际上有一条PCIa PCIe总线连接处理器部分和网络部分。

585
00:17:15,590 --> 00:17:17,060
0,120 120,390 390,540 540,1080 1080,1470
know there's a {PCIa -}

586
00:17:17,150 --> 00:17:19,460
0,480 480,900 930,1860 1860,2040 2040,2310
{PCIe -} bus that actually

587
00:17:19,460 --> 00:17:20,400
0,540
connects

588
00:17:20,400 --> 00:17:22,770
0,660 900,1560 1560,2100 2100,2190 2190,2370
the processor part, you know

589
00:17:22,770 --> 00:17:24,580
0,240 240,570 600,930 930,1320
with the network part.|
|

590
00:17:27,260 --> 00:17:29,150
0,540 870,1320 1320,1380 1380,1800 1800,1890
{} {You,know,to,get} the network to
你知道要让电视网做点什么，

591
00:17:29,150 --> 00:17:30,770
0,150 150,720 840,1200 1200,1320 1320,1620
do something,| {} the network
|网卡内部有控制器

592
00:17:30,770 --> 00:17:33,380
0,750 750,1620 1650,2160 2160,2490 2490,2610
card has controller inside of

593
00:17:33,380 --> 00:17:34,430
0,330 330,660 660,780 780,870 870,1050
it| and you know these
|你知道这些控制器都有寄存器。

594
00:17:34,430 --> 00:17:36,480
0,420 420,750 750,1530
controller has registers.|
|

595
00:17:37,690 --> 00:17:39,460
0,450 450,600 600,1200
And you can,
您可以知道，这些寄存器的一个很酷的方面是，它们被称为内存映射IO寄存器

596
00:17:39,460 --> 00:17:40,600
0,150 150,240 240,300 300,540 540,1140
one of the cool aspects

597
00:17:40,660 --> 00:17:42,250
0,150 210,390 390,600 600,930 930,1590
of you know these registers,

598
00:17:42,250 --> 00:17:43,870
0,120 120,420 420,780 780,1350 1350,1620
they are called memory {}

599
00:17:43,870 --> 00:17:46,870
0,510 750,1620 1620,2310 2520,2910 2910,3000
mapped IO registers| and so
|所以你可以用你知道的任何一颗星，0x和任何值来写它们

600
00:17:46,870 --> 00:17:47,890
0,120 120,240 240,450 450,720 720,1020
you could just write them

601
00:17:47,890 --> 00:17:49,840
0,630 630,1050 1050,1140 1140,1830 1860,1950
with whatever a star you

602
00:17:49,840 --> 00:17:51,940
0,360 660,960 960,1560 1620,1770 1770,2100
know, {0x -} and whatever

603
00:17:51,940 --> 00:17:53,170
0,90 90,570 570,930 930,1050 1050,1230
the value is| you know
|您知道或在物理内存空间中，该特定寄存器的值是多少。

604
00:17:53,170 --> 00:17:54,610
0,390 390,600 600,840 840,1140 1140,1440
or in the physical memory

605
00:17:54,610 --> 00:17:56,260
0,570 720,1020 1020,1110 1110,1470 1470,1650
space what the value is

606
00:17:56,260 --> 00:17:57,700
0,120 120,240 240,660 660,1050
for that particular register.|
|

607
00:17:57,760 --> 00:17:58,810
0,300 300,450 450,600 600,870 870,1050
{you,know}, like we might have
你知道，就像我们可能有我们的头，我们的尾巴。

608
00:17:58,810 --> 00:18:00,060
0,180 180,660
our head,

609
00:18:00,060 --> 00:18:01,880
0,120 120,480 480,1230
our tail registers.|
|

610
00:18:02,260 --> 00:18:03,610
0,540 570,720 720,840 840,930 930,1350
And you know we can,
你知道我们可以，驱动程序可以通过执行加载或存储指令来写入这些，你知道到地址，

611
00:18:03,610 --> 00:18:05,740
0,90 120,840 840,1260 1440,1800 1800,2130
the driver can write those

612
00:18:05,740 --> 00:18:07,540
0,210 210,960 960,1320 1320,1740 1740,1800
by executing {} load or

613
00:18:07,540 --> 00:18:09,460
0,240 240,870 1170,1350 1350,1500 1500,1920
store instruction, you know to

614
00:18:09,460 --> 00:18:10,600
0,120 120,750 750,840 840,930 930,1140
the address,| you know, of
|你知道，在物理地址空间中的对应于该寄存器的位置。

615
00:18:10,600 --> 00:18:12,040
0,330 330,870 870,990 990,1170 1170,1440
{corresponds -} you know in

616
00:18:12,040 --> 00:18:13,780
0,210 210,600 600,870 870,1410 1530,1740
the physical address space to

617
00:18:13,780 --> 00:18:15,220
0,150 150,690 690,780 780,990 990,1440
the location of that register.|
|

618
00:18:15,770 --> 00:18:17,240
0,420 420,510 510,750 750,990 990,1470
And the hardware will ensure
硬件将确保当我们加载或存储时，

619
00:18:17,240 --> 00:18:18,620
0,240 240,390 390,510 510,810 810,1380
when we do load {or,store},|
|

620
00:18:18,710 --> 00:18:19,910
0,150 150,270 270,510 510,840 840,1200
you know that that store
你知道，那家商店要么去，你知道，去，

621
00:18:19,910 --> 00:18:20,990
0,210 210,450 450,780 780,840 840,1080
will either go you know

622
00:18:20,990 --> 00:18:22,540
0,150 150,300 300,960
go to the,|
|

623
00:18:22,660 --> 00:18:23,800
0,180 180,270 270,570 780,1050 1050,1140
if it is one of
如果它是控制寄存器之一，则将转到控制寄存器，

624
00:18:23,800 --> 00:18:24,850
0,150 150,450 450,780 780,900 900,1050
the control register, will go

625
00:18:24,850 --> 00:18:26,050
0,120 120,180 180,540 540,1050 1050,1200
to the control registers,| if
|如果GO ONCE地址在RAM中，则会进入RAM。

626
00:18:26,050 --> 00:18:28,540
0,60 60,360 420,1050 1050,1590 2040,2490
the {go,once -} {address,is,in} RAM

627
00:18:28,540 --> 00:18:29,470
0,270 270,420 420,510 510,630 630,930
will go to the RAM.|
|

628
00:18:31,270 --> 00:18:32,410
0,270 270,390 390,510 510,660 660,1140
So you can just manipulate
因此，您可以通过加载、读取和写入这些控制寄存器来操作程序网卡

629
00:18:32,410 --> 00:18:35,050
0,90 90,780 1050,1650 1680,2310 2310,2640
the program {} network card

630
00:18:35,050 --> 00:18:36,760
0,360 390,870 870,1050 1230,1620 1620,1710
by loading, {} reading and

631
00:18:36,760 --> 00:18:38,590
0,480 540,690 690,960 960,1320 1320,1830
writing {} these control registers|
|

632
00:18:38,590 --> 00:18:39,940
0,180 180,510 510,1110 1110,1230 1230,1350
and basically bits in these
正如您所看到的，这些控制寄存器中的位基本上具有特殊意义。

633
00:18:39,940 --> 00:18:41,590
0,390 390,840 840,1020 1020,1380 1380,1650
control registers have special meaning

634
00:18:41,590 --> 00:18:42,800
0,150 150,240 240,360 360,720
as you have seen.|
|

635
00:18:43,570 --> 00:18:45,440
0,510 810,1350
Um, now,
嗯，现在，对于这个特殊的卡，你知道网络需要通过网络发送数据包，

636
00:18:45,500 --> 00:18:46,580
0,150 150,270 270,600 600,990 990,1080
for this particular card {you,know}

637
00:18:46,580 --> 00:18:48,560
0,600 600,1140 1140,1380 1380,1650 1830,1980
{network card} needs to send

638
00:18:48,560 --> 00:18:50,450
0,240 240,600 600,660 660,1230 1380,1890
packets across the network,| and
|你知道它需要把包裹送到某个地方。

639
00:18:50,450 --> 00:18:51,110
0,90 90,240 240,450 450,600 600,660
you know it needs to

640
00:18:51,110 --> 00:18:52,600
0,120 120,180 180,540 540,960
get the packet somewhere.|
|

641
00:18:53,010 --> 00:18:54,870
0,300 300,660 900,1350 1350,1530 1530,1860
And so, {} the packets
所以，包实际上是活的，你知道的，就像我们稍后会看到的那样，你知道，只是活在内存中的某个地方，

642
00:18:54,870 --> 00:18:56,160
0,0 0,240 240,900 930,1110 1110,1290
{actually -} live, you know

643
00:18:56,160 --> 00:18:57,870
0,360 420,1200 1230,1380 1380,1530 1530,1710
are allocated as we'll see

644
00:18:57,870 --> 00:18:58,620
0,90 90,120 120,450 450,600 600,750
in a second you know

645
00:18:58,620 --> 00:18:59,820
0,240 240,390 390,720 720,810 810,1200
just live somewhere in memory,|
|

646
00:19:01,930 --> 00:19:04,180
0,600 870,1470 1710,1950 1950,2130 2130,2250
{} and and what we
事实上，我们所做的就是，除了这些数据包之外，

647
00:19:04,180 --> 00:19:05,860
0,270 270,660 930,1110 1110,1350 1350,1680
do is, in fact, in

648
00:19:05,860 --> 00:19:07,000
0,330 330,450 450,600 600,1050 1050,1140
addition to these packets,| you
|你知道，有两个环形结构也存在于记忆中。

649
00:19:07,000 --> 00:19:08,080
0,90 90,360 360,510 510,600 600,1080
know there's sort of two

650
00:19:08,080 --> 00:19:09,460
0,240 240,780 780,930 930,1170 1170,1380
ring structures that also live

651
00:19:09,460 --> 00:19:10,440
0,90 90,450
in memory.|
|

652
00:19:14,420 --> 00:19:16,400
0,720 750,1380
And, {}
而且，我们可以，你知道，程序，

653
00:19:19,300 --> 00:19:20,110
0,150 150,270 270,570 570,660 660,810
and we can you know

654
00:19:20,110 --> 00:19:22,240
0,600 690,1530 1530,1920 1920,2040 2040,2130
program,| {} and we can
|我们可以告诉卡片，你知道卡片也知道这些环形结构在哪里，

655
00:19:22,240 --> 00:19:23,140
0,150 150,240 240,720 720,810 810,900
tell the card, you know

656
00:19:23,140 --> 00:19:24,490
0,120 120,540 540,630 630,1020 1020,1350
the {card,also -} knows where

657
00:19:24,490 --> 00:19:26,740
0,180 180,330 330,750 750,1050 1740,2250
these ring structures are,| {you,know,it,has,address}
|你知道它的地址你知道TX环在哪里

658
00:19:26,740 --> 00:19:28,570
0,450 450,720 990,1170 1170,1620 1620,1830
where to {you,know} tx ring

659
00:19:28,570 --> 00:19:29,410
0,330 330,450 450,540 540,600 600,840
is| you know it has
|你知道它有去RX RING的地址

660
00:19:29,410 --> 00:19:31,140
0,120 120,540 540,930 930,1170
an address where to

661
00:19:31,260 --> 00:19:33,420
0,300 300,510 510,690 690,1140 1590,2160
{rx -} ring is| and
|您知道，硬件卡会查看这些地址来实际查看需要发送哪些数据包，

662
00:19:33,420 --> 00:19:35,010
0,120 120,300 300,690 690,1080 1080,1590
you know the hardware card

663
00:19:35,040 --> 00:19:37,530
0,570 570,660 660,930 930,1620 1950,2490
looks at those addresses {}

664
00:19:37,530 --> 00:19:38,970
0,210 210,420 420,780 780,1020 1020,1440
to actually see which packets

665
00:19:38,970 --> 00:19:40,110
0,150 150,210 210,330 330,750 870,1140
need to be sent,| so
|因此，在这里，我们可能有一个需要传输的数据包队列

666
00:19:40,110 --> 00:19:41,010
0,330 330,420 420,630 630,840 840,900
here we might have a

667
00:19:41,010 --> 00:19:42,960
0,510 570,900 1080,1650 1650,1800 1800,1950
queue of packets that need

668
00:19:42,960 --> 00:19:43,950
0,90 90,210 210,750 750,930 930,990
to be transmitted| or a
|或者对需要接收的分组进行排队。

669
00:19:43,950 --> 00:19:44,910
0,240 240,600 600,690 690,840 840,960
queue packets that need to

670
00:19:44,910 --> 00:19:46,100
0,150 150,780
be received.|
|

671
00:19:48,910 --> 00:19:51,100
0,870 900,1650
And, {}
还有，你知道，你知道的E1000的DMA

672
00:19:52,010 --> 00:19:53,570
0,180 180,450 480,780 780,1470 1470,1560
you know, the E1000 you

673
00:19:53,570 --> 00:19:55,700
0,390 660,1170 1200,1530 1530,2040 2040,2130
know {} {DMAs -}| you
|你知道，比如你知道他们会在第一个因素上发挥作用，

674
00:19:55,700 --> 00:19:57,170
0,420 420,540 540,1020 1020,1380 1380,1470
know, for example like you

675
00:19:57,170 --> 00:19:58,370
0,150 150,360 510,870 870,930 930,1200
know they're going to work

676
00:19:58,370 --> 00:20:01,130
0,690 1020,1140 1140,1560 1560,2010 2010,2760
on the first {factor,to} sent,|
|

677
00:20:01,130 --> 00:20:02,420
0,120 120,420 420,690 690,1230 1230,1290
will {DMA -} basically you
将DMA基本上您知道那些与分组相关联的分组数据，

678
00:20:02,420 --> 00:20:05,300
0,180 180,510 540,1140 1320,2250 2250,2880
know those packets data associated

679
00:20:05,300 --> 00:20:06,740
0,150 150,450 450,540 540,990 1140,1440
with the the packets,| {you,know}
|你知道直接从RAM到网络，

680
00:20:06,740 --> 00:20:08,750
0,480 480,840 840,1230 1230,1770 1800,2010
straight from RAM to the

681
00:20:08,750 --> 00:20:09,720
0,510
network,|
|

682
00:20:09,980 --> 00:20:11,600
0,450 450,840 840,1110 1110,1200 1200,1620
without actually having the processor
在完全不涉及处理器的情况下，

683
00:20:11,600 --> 00:20:13,940
0,420 420,480 480,750 1800,2070 2070,2340
involved at all,| {what,is,called} DMA,
|这就是所谓的DMA，即直接存储器访问。

684
00:20:13,940 --> 00:20:15,500
0,300 300,570 570,1170
direct memory access.|
|

685
00:20:19,130 --> 00:20:20,420
0,780
Okay.|
好吧。|

686
00:20:21,890 --> 00:20:23,540
0,300 300,510 510,990 1140,1350 1350,1650
This makes sense in terms
这对于RISC-V RAM和E1000的组织来说，从更抽象的角度来看是有意义的。

687
00:20:23,540 --> 00:20:25,220
0,150 150,240 240,540 540,1020 1020,1680
of a more abstract picture

688
00:20:25,250 --> 00:20:27,710
0,600 600,1020 1020,1470 1620,2310 2310,2460
a for the organization of

689
00:20:27,710 --> 00:20:28,940
0,630
the

690
00:20:29,360 --> 00:20:31,490
0,210 210,780 810,1470 1500,2010 2010,2130
{RISC-V -} RAM and {E1000

691
00:20:31,490 --> 00:20:32,780
0,180 180,630
- -}.|
|

692
00:20:33,070 --> 00:20:34,820
0,270 270,660 660,900 900,1260
Any questions about this?|
对此有什么问题吗？|

693
00:20:41,500 --> 00:20:42,850
0,180 180,360 360,540 540,1050 1080,1350
So, one thing in talking
所以，在谈论硬件、软件并发性时，

694
00:20:42,850 --> 00:20:46,270
0,240 390,1650 1650,1950 1950,2640 2700,3420
about hardware, software concurrency,| clearly
|显然，您了解E1000和处理器

695
00:20:46,270 --> 00:20:48,850
0,90 90,270 270,870 1080,2460 2460,2580
you know the {E1000,and} you

696
00:20:48,850 --> 00:20:50,740
0,90 90,180 180,840 840,1560 1560,1890
know the processor| or both
|或者同时操纵这些发送和接收队列或环。

697
00:20:50,740 --> 00:20:53,890
0,660 660,990 990,1740 1740,2010 2010,3150
manipulating these transmission and {}

698
00:20:53,920 --> 00:20:56,940
0,900 900,1320 1320,1440 1650,2640
reception queues or rings.|
|

699
00:20:57,030 --> 00:20:57,690
0,180 180,300 300,450 450,600 600,660
And so, there has to
因此，在给定的Take协议中必须有某种协议，

700
00:20:57,690 --> 00:20:59,220
0,90 90,240 240,960 1170,1320 1320,1530
be some protocol {sort,of} give

701
00:20:59,220 --> 00:21:00,330
0,120 180,450 450,630 630,900 900,1110
and take in a given

702
00:21:00,330 --> 00:21:02,160
0,210 210,840 900,1590 1590,1680 1680,1830
take protocol,| where you know
|你知道在某些情况下，环的特定部分是由网卡拥有或操作的，

703
00:21:02,160 --> 00:21:03,810
0,90 90,240 240,750 870,1350 1350,1650
at some point, particular parts

704
00:21:03,810 --> 00:21:05,250
0,60 60,150 150,630 690,1050 1050,1440
of the ring are operated

705
00:21:05,250 --> 00:21:07,470
0,390 390,1050 1050,1230 1230,1740 1770,2220
through {are,owned} or operated by

706
00:21:07,470 --> 00:21:09,180
0,450 480,1020 1020,1320 1320,1410 1410,1710
the network card,| and there
|有些部件可能在软件或操作系统内核的控制之下。

707
00:21:09,180 --> 00:21:10,380
0,60 60,420 420,630 630,720 720,1200
are parts that are maybe

708
00:21:10,380 --> 00:21:11,850
0,300 300,690 690,840 840,1020 1020,1470
under control of the software

709
00:21:11,850 --> 00:21:13,280
0,60 60,180 180,540 630,990
or the OS kernel.|
|

710
00:21:13,500 --> 00:21:14,370
0,330 330,600 600,750 750,810 810,870
And you'll see in the
你会在下半场看到这是安排好的，

711
00:21:14,370 --> 00:21:15,750
0,300 300,480 480,630 630,750 750,1380
second half that is arranged,|
|

712
00:21:15,960 --> 00:21:16,950
0,480 480,690 690,810 810,900 900,990
{} but you know we
但你知道我们又有点小心翼翼了，

713
00:21:16,950 --> 00:21:17,910
0,120 120,180 180,330 330,480 480,960
got a little bit careful

714
00:21:17,910 --> 00:21:19,290
0,360 360,570 570,810 810,1110 1110,1380
again,| that the concurrent doesn't
|并发不会被操作系统绊倒或绊倒，反之亦然。

715
00:21:19,290 --> 00:21:21,420
0,240 240,870 1260,1680 1680,1860 1860,2130
trip over {} or trip

716
00:21:21,420 --> 00:21:23,220
0,600 660,960 960,1110 1110,1440 1440,1800
over {} the operating system

717
00:21:23,220 --> 00:21:24,090
0,60 60,150 150,300 300,450 450,870
or the other way around.|
|

718
00:21:28,540 --> 00:21:30,520
0,270 270,810 840,1200 1200,1560 1560,1980
{A,quick} question, so is there
一个快速问题，那么RAM中是否有单独的发送环和接收环

719
00:21:30,520 --> 00:21:33,400
0,450 750,1350 1470,2190 2190,2490 2490,2880
a separate transmit ring and

720
00:21:33,400 --> 00:21:35,140
0,330 330,990 1050,1200 1200,1320 1320,1740
and {receive,ring} in the RAM|
|

721
00:21:35,140 --> 00:21:37,210
0,210 210,600 1050,1320 1320,1770 1770,2070
and then, {} also in
然后，也在E1000或E1000驱动程序中。

722
00:21:37,210 --> 00:21:40,270
0,240 240,1350 1350,1560 1560,2100 2310,3060
the {E1000,or} {E1000 -} driver.|
|

723
00:21:40,570 --> 00:21:41,710
0,300 300,570 570,630 630,810 810,1140
Yeah, well the one way,|
是啊，好吧，有一种方法，|

724
00:21:41,710 --> 00:21:42,850
0,210 210,330 330,630 630,840 840,1140
okay so there's two things
好的，有两件事正在发生

725
00:21:42,850 --> 00:21:43,960
0,270 270,480 480,630 630,930 930,1110
going on| and we look
|我们马上来看一下代码，

726
00:21:43,960 --> 00:21:44,440
0,60 60,120 120,360 360,450 450,480
at the code in a

727
00:21:44,440 --> 00:21:47,560
0,480 660,1380 1650,2190 2430,2700 2730,3120
second,| {} the the the
|传输环和接收基本上驻留在RAM中。

728
00:21:47,590 --> 00:21:50,170
0,750 750,1140 1140,1380 1380,2100 2100,2580
transmission ring and receiving basically

729
00:21:50,170 --> 00:21:51,540
0,330 330,570 570,1020
lived in RAM.|
|

730
00:21:51,740 --> 00:21:54,620
0,270 270,900 930,1380 1410,2820 2820,2880
And both the {E1000,and} the
E1000和RISC-V都可以操作实际存储在RAM中的环。

731
00:21:54,620 --> 00:21:56,810
0,240 240,720 720,1470 1470,1800 1800,2190
{RISC-V -} manipulates the ring

732
00:21:56,840 --> 00:21:58,730
0,390 390,570 570,1140 1170,1530 1530,1890
that actually stored in RAM.|
|

733
00:21:59,910 --> 00:22:01,140
0,660

734
00:22:01,140 --> 00:22:03,360
0,360 360,1110 1110,1170 1170,1410 1680,2220
And those are the rings
这些就是您在硬件文档中看到的环。

735
00:22:03,360 --> 00:22:03,930
0,120 120,240 240,420 420,510 510,570
that you saw in the

736
00:22:03,930 --> 00:22:05,520
0,270 270,1020
hardware documentation.|
|

737
00:22:05,520 --> 00:22:06,300
0,180 180,540 540,630 630,720 720,780
It happens to be the
恰好情况是xv6也具有维护一种mbuf环的驱动程序，

738
00:22:06,300 --> 00:22:07,770
0,420 420,690 690,960 960,1200 1200,1470
case that {xv6 -} also

739
00:22:07,770 --> 00:22:10,650
0,240 240,900 930,1620 1620,2010 2010,2880
has a driver maintains a

740
00:22:11,220 --> 00:22:12,030
0,300 300,360 360,450 450,660 660,810
sort of a ring of

741
00:22:12,030 --> 00:22:14,730
0,750 1080,1860 1860,2040 2040,2130 2130,2700
mbufs,| separately of the transmit
|与发送环和RX环分开，

742
00:22:14,730 --> 00:22:16,770
0,240 240,660 660,930 930,1350 1440,2040
ring and {rx -} ring,|
|

743
00:22:16,830 --> 00:22:18,120
0,300 300,480 480,690 690,840 840,1290
like there's something like tx
好像有类似TX mbufs的东西。

744
00:22:18,120 --> 00:22:19,260
0,720
mbufs.|
|

745
00:22:21,460 --> 00:22:22,540
0,150 150,510 510,660 660,780 780,1080
And that's you know that
你知道，这是只有操作系统才真正了解的数据结构，

746
00:22:22,540 --> 00:22:23,890
0,180 180,300 300,510 510,960 960,1350
is the data structure only

747
00:22:23,890 --> 00:22:25,000
0,120 120,450 450,720 720,900 900,1110
the operating system really knows

748
00:22:25,000 --> 00:22:27,430
0,420 840,1530 1560,1950 1950,2220 2220,2430
about,| the network card doesn't
|网卡并不真的知道这件事

749
00:22:27,430 --> 00:22:28,240
0,180 180,330 330,600 600,720 720,810
really know about it| and
|并且网卡只知道TX环和RX环，

750
00:22:28,270 --> 00:22:30,130
0,360 360,630 630,990 990,1410 1410,1860
network card only knows about

751
00:22:30,580 --> 00:22:32,860
0,570 570,930 1110,1680 1680,2100 2100,2280
{} the the tx ring

752
00:22:32,860 --> 00:22:34,510
0,180 180,390 390,900 990,1380 1380,1650
and rx ring,| {} because
|因为这些值是编程到寄存器中的值，

753
00:22:34,510 --> 00:22:35,440
0,270 270,330 330,420 420,780 780,930
those are the values that

754
00:22:35,440 --> 00:22:37,600
0,210 210,720 720,1230 1230,1440 1440,2160
were programmed into the registers,|
|

755
00:22:37,720 --> 00:22:38,950
0,330 330,510 510,870 870,1140 1140,1230
saying like here's where you
说这里是你可以找到的地址，这里是你可以找到传送环的地址，

756
00:22:38,950 --> 00:22:40,120
0,150 150,540 540,780 780,840 840,1170
can find here's the address

757
00:22:40,120 --> 00:22:40,900
0,210 210,270 270,390 390,690 690,780
where you can find the

758
00:22:40,900 --> 00:22:42,340
0,570 630,930 930,990 990,1320 1320,1440
{transmit,ring},| here's the address where
|这是你可以找到接收铃的地址。

759
00:22:42,340 --> 00:22:43,270
0,60 60,150 150,360 360,450 450,930
you can find the {receive,ring}.|
|

760
00:22:44,520 --> 00:22:45,810
0,300 300,420 420,600 600,930 1140,1290
Yeah, that makes sense.| That
是啊，这就说得通了。|这事儿可以理解?

761
00:22:45,810 --> 00:22:46,900
0,120 120,450
makes sense?|
|

762
00:22:49,840 --> 00:22:50,950
0,330 330,510 510,900 900,1020 1020,1110
Okay, so that's sort of
好的，这就是硬件图片，在一个更简明的版本中，

763
00:22:50,950 --> 00:22:52,960
0,60 60,450 450,1050 1170,1830 1830,2010
the hardware picture, {} in

764
00:22:52,960 --> 00:22:55,750
0,210 210,390 390,1260 1260,1770 2070,2790
a more schematic version {},|
|

765
00:22:55,930 --> 00:22:56,980
0,570 570,720 720,750 750,960 960,1050
let's talk a little bit
让我们稍微谈谈软件结构。

766
00:22:56,980 --> 00:22:58,680
0,210 210,270 270,600 600,1200
about the software structure.|
|

767
00:22:59,520 --> 00:23:00,960
0,330 330,390 390,600 600,1080 1080,1440
There's a big confusing actually
在这个实验室里，这个实际上有一个很大的令人困惑的地方。

768
00:23:00,960 --> 00:23:03,500
0,270 270,1800
{in,this} {in,this,lab}.|
|

769
00:23:05,870 --> 00:23:07,480
0,1140
{So,software,structure}.|
所以软件结构。|

770
00:23:10,700 --> 00:23:11,860
0,630

771
00:23:12,050 --> 00:23:14,570
0,300 300,1170 1170,1470 1500,2400 2430,2520
So, let's just draw you
所以，让我们画出我们最关心的事情，当然你知道司机，

772
00:23:14,570 --> 00:23:15,200
0,120 120,240 240,420 420,510 510,630
know the thing that we

773
00:23:15,200 --> 00:23:16,250
0,210 210,390 390,660 660,720 720,1050
most care about, of course

774
00:23:16,250 --> 00:23:17,630
0,180 180,330 330,420 420,1080 1110,1380
you know the driver,| so
|这就是我们的驱动程序，E1000驱动程序。

775
00:23:17,630 --> 00:23:19,440
0,330 330,600 630,1290
here's our driver,

776
00:23:19,690 --> 00:23:21,970
0,600 720,1140 1140,1290 1290,1650 1650,2280
the {e1000 - -} driver.|
|

777
00:23:26,150 --> 00:23:27,980
0,660 660,990 990,1440 1440,1650 1650,1830
And it basically has only
它基本上只有两个功能，

778
00:23:27,980 --> 00:23:30,470
0,180 180,810 1020,1500 1500,1980 2010,2490
two functions,| as a transmit
|作为发送功能，并且它具有接收功能。

779
00:23:30,470 --> 00:23:31,640
0,630
function,

780
00:23:35,200 --> 00:23:37,060
0,330 330,450 450,900 900,1260 1260,1860
and it has a receive

781
00:23:37,090 --> 00:23:38,320
0,510
function.|
|

782
00:23:40,810 --> 00:23:43,060
0,630 630,720 720,990 990,1590 1620,2250
And the receive function runs
并且接收功能响应于中断而运行。

783
00:23:43,060 --> 00:23:46,080
0,150 150,600 600,840 840,1470
in response to interrupts.|
|

784
00:23:46,300 --> 00:23:48,220
0,240 240,660 660,1260
{So,an} interrupt happens,
所以中断发生了，然后你知道xv6，你将使用通常的中断机制，

785
00:23:48,550 --> 00:23:50,530
0,540 570,660 660,750 750,1560 1560,1980
then you know xv6, you

786
00:23:50,560 --> 00:23:53,170
0,240 240,570 570,1020 1050,1980 2130,2610
will use the usual interrupt

787
00:23:53,170 --> 00:23:55,150
0,690 690,750 750,960 960,1380 1380,1980
mechanism,| you know {a,trap} happen,
|你知道陷阱发生了，陷阱你知道，看看网卡有没有中断，

788
00:23:55,540 --> 00:23:56,710
0,450 450,840 870,960 960,1080 1080,1170
trap look you know to

789
00:23:56,710 --> 00:23:57,640
0,150 150,240 240,420 420,510 510,930
see if there's an interrupt

790
00:23:57,640 --> 00:23:58,660
0,150 150,210 210,510 510,900 900,1020
from the network card,| if
|如果出现中断，网卡将调用接收函数。

791
00:23:58,660 --> 00:23:59,830
0,240 240,360 360,810 810,870 870,1170
there's an interruption, the network

792
00:23:59,830 --> 00:24:00,910
0,330 330,450 450,630 630,720 720,1080
card will call the receive

793
00:24:00,910 --> 00:24:01,720
0,330
function.|
|

794
00:24:02,600 --> 00:24:04,010
0,360 360,450 450,540 540,1260 1260,1410
And as you remember we
正如你们所记得的，我们曾经有过一堂关于设备驱动程序的课程，

795
00:24:04,010 --> 00:24:05,720
0,210 210,960 1290,1380 1410,1650 1650,1710
used to have one of

796
00:24:05,720 --> 00:24:06,890
0,90 90,360 360,630 630,840 840,1170
the previous lectures about device

797
00:24:06,890 --> 00:24:08,240
0,600 690,930 930,990 990,1110 1110,1350
drivers,| you know it's often
|您知道，将设备驱动程序分成两部分通常是有帮助的。

798
00:24:08,240 --> 00:24:09,380
0,390 390,510 510,720 720,840 840,1140
helpful to think of the

799
00:24:09,380 --> 00:24:10,550
0,360 360,630 630,720 720,1050 1050,1170
device drivers were split in

800
00:24:10,550 --> 00:24:11,760
0,150 150,720
two parts.|
|

801
00:24:11,760 --> 00:24:13,830
0,210 210,570 570,870 870,1530 1830,2070
{You,know} the bottom half which
您知道在中断处理程序的上下文中运行的下半部分，

802
00:24:13,830 --> 00:24:15,570
0,480 480,810 810,1020 1020,1590 1590,1740
runs in the context of

803
00:24:15,570 --> 00:24:17,060
0,90 90,450 450,960
of interrupt handler,|
|

804
00:24:18,160 --> 00:24:19,450
0,480 480,660 660,1020 1020,1230 1230,1290
typically {name,for} those in the
通常以上半部分的人命名，

805
00:24:19,450 --> 00:24:20,820
0,330 330,870
top half,|
|

806
00:24:22,880 --> 00:24:24,050
0,240 240,690 690,990 990,1080 1080,1170
which generally runs in the
它通常运行在您知道的内核进程或类似于用户级进程的上下文中，

807
00:24:24,050 --> 00:24:26,900
0,720 750,1500 1650,2430 2430,2730 2730,2850
context of {} you know

808
00:24:26,900 --> 00:24:28,460
0,300 300,900 900,1290 1290,1500 1500,1560
kernel process or like a

809
00:24:28,460 --> 00:24:29,960
0,450 450,900 900,1080 1080,1200 1200,1500
{user,level} process,| so for example
|举个例子，如果你想一下位于这上面的东西，

810
00:24:29,960 --> 00:24:31,550
0,60 60,120 120,300 300,750 1020,1590
if you think about things

811
00:24:31,550 --> 00:24:32,240
0,90 90,270 270,330 330,600 600,690
that sit on top of

812
00:24:32,240 --> 00:24:34,880
0,510 690,930 930,1200 1200,2040 2070,2640
here,| {} there's the network
|这是实际实现IP、UDP等的网络堆栈代码，位于此之上。

813
00:24:34,880 --> 00:24:37,070
0,480 900,1230 1230,1350 1350,1680 1680,2190
stack code that actually implements

814
00:24:37,070 --> 00:24:39,140
0,90 90,180 180,1260 1440,1950 1950,2070
you know IP UDP and

815
00:24:39,140 --> 00:24:40,910
0,120 120,360 360,630 990,1350 1350,1770
etc, {} sit above this.|
|

816
00:24:41,430 --> 00:24:42,570
0,210 210,660 660,810 810,960 960,1140
And then you know there
然后你知道，我们通常的，你知道的，

817
00:24:42,570 --> 00:24:43,500
0,360
is,

818
00:24:43,500 --> 00:24:45,030
0,90 90,330 330,510 510,1290 1380,1530
you know, our usual you

819
00:24:45,030 --> 00:24:46,680
0,120 120,300 300,390 390,1080
know sort of line,|
|

820
00:24:47,160 --> 00:24:48,750
0,120 120,360 390,720 720,1080 1080,1590
you know kernel space blow,
你知道内核空间爆炸，用户空间膨胀

821
00:24:48,750 --> 00:24:51,300
0,270 270,540 540,1470 1470,1980
user space up| and
|你知道这是非常OS的世界观

822
00:24:51,300 --> 00:24:52,470
0,270 270,420 420,540 540,810 810,1170
{you,know} this is very OS

823
00:24:52,470 --> 00:24:53,670
0,210 210,300 300,390 390,780 780,1200
view of the world| where
|用户空间不是特别大或特别重要的地方

824
00:24:53,700 --> 00:24:55,860
0,360 360,660 660,810 810,1410 1830,2160
user space not particularly that

825
00:24:55,860 --> 00:24:58,530
0,240 240,360 360,960 1230,2070 2130,2670
big or important| and, {}
|而且，您知道，用户级程序中的任何网络测试都不是示例。

826
00:24:58,530 --> 00:25:00,090
0,90 90,240 240,690 690,1020 1200,1560
you know example are t

827
00:25:00,090 --> 00:25:01,950
0,420 420,690 690,1140 1170,1650 1650,1860
whatever net test {in,the,user} level

828
00:25:01,950 --> 00:25:05,070
0,630 1140,1620 1650,2130 2130,2670 2970,3120
program| runs user space and
|运行用户空间并进行系统调用，

829
00:25:05,070 --> 00:25:06,780
0,120 120,360 360,630 630,1290
it makes system calls,|
|

830
00:25:06,780 --> 00:25:08,520
0,330 330,630 630,840 840,1140 1140,1740
system calls go to the
系统调用进入网络堆栈，

831
00:25:09,090 --> 00:25:11,880
0,570 600,1050 1050,1560 1920,2610 2610,2790
{} network stack,| {} for
|例如，如果您知道使用文件描述符调用Write系统调用，

832
00:25:11,880 --> 00:25:13,290
0,510 510,720 720,870 870,1020 1020,1410
example like if you knew

833
00:25:14,630 --> 00:25:16,200
0,420 420,540 540,1020
calls the write

834
00:25:16,570 --> 00:25:19,120
0,390 390,990 1020,1590 1590,1830 1830,2550
system call, {with,a} file descriptor,|
|

835
00:25:19,420 --> 00:25:20,680
0,180 180,510 510,1020 1020,1110 1110,1260
the kernel knows you know
内核知道您知道对于该文件描述符，如果您确实写了，

836
00:25:20,680 --> 00:25:21,910
0,150 150,330 330,570 570,1080 1080,1230
for that file descriptor, if

837
00:25:21,910 --> 00:25:23,170
0,90 90,300 300,720 720,1110 1140,1260
you do write,| then you
|那么您就知道写入应该发送到网络堆栈，

838
00:25:23,170 --> 00:25:24,220
0,240 240,450 450,720 720,840 840,1050
know the write should go

839
00:25:24,220 --> 00:25:25,900
0,150 150,390 390,690 690,1140 1320,1680
to the network stack,| the
|网络堆栈建立数据包

840
00:25:25,900 --> 00:25:26,920
0,270 270,540 540,810 810,930 930,1020
network stack builds up the

841
00:25:26,920 --> 00:25:28,630
0,600 780,930 930,1320 1320,1410 1410,1710
packets| and then it calls
|然后它调用传输。

842
00:25:28,630 --> 00:25:29,720
0,630
transmit.|
|

843
00:25:30,830 --> 00:25:32,960
0,360 360,540 540,1140 1140,1620 1620,2130
And then transmits whatever manipulates
然后发送TX队列或环操作的传输队列的任何内容，

844
00:25:32,960 --> 00:25:35,330
0,270 1320,1800 1800,2130 2130,2280 2280,2370
the transmission queue that the

845
00:25:35,330 --> 00:25:37,460
0,600 630,780 780,1200 1380,2010 2010,2130
{tx,queue} or ring| and you
|你知道，实际上会收到数据包，你知道，通常是网络，

846
00:25:37,460 --> 00:25:38,840
0,120 120,360 360,690 690,960 960,1380
know that actually gets packets,

847
00:25:38,840 --> 00:25:40,160
0,90 90,210 210,540 540,1140 1170,1320
you know often network,| at
|在某种程度上，响应可能会返回回来，

848
00:25:40,160 --> 00:25:41,270
0,150 150,390 390,540 540,930 930,1110
some point a response might

849
00:25:41,270 --> 00:25:42,680
0,330 330,750 750,930 930,1320 1320,1410
go back come back,| you
|你知道那会引起中断

850
00:25:42,680 --> 00:25:43,520
0,90 90,270 270,420 420,780 780,840
know that will generate an

851
00:25:43,520 --> 00:25:45,050
0,600 750,990 990,1110 1110,1200 1200,1530
interrupt| and then the receive
|然后接收功能将运行并检查您知道的接收铃声，对吧。

852
00:25:45,050 --> 00:25:46,580
0,360 360,510 510,840 840,990 990,1530
function will run and inspect

853
00:25:46,580 --> 00:25:47,620
0,60 60,210 210,600
you know the

854
00:25:47,620 --> 00:25:49,040
0,600 600,840
receive ring,

855
00:25:49,700 --> 00:25:50,640
0,390
right.|
|

856
00:25:50,760 --> 00:25:51,810
0,360 360,570 570,630 630,840 840,1050
So there's a couple things
所以你知道有几样东西是你想要的，

857
00:25:51,810 --> 00:25:53,560
0,210 210,540 540,1200
that {you,know} wanna,|
|

858
00:25:53,560 --> 00:25:54,370
0,300 300,420 420,540 540,600 600,810
{} I want to point
我想指出的是，您知道在并发性方面。

859
00:25:54,370 --> 00:25:55,510
0,360 390,480 480,660 660,840 840,1140
out you know in terms

860
00:25:55,510 --> 00:25:58,060
0,60 60,720 930,1950
of concurrency {}.|
|

861
00:25:58,060 --> 00:25:59,590
0,480 780,960 960,1170 1170,1230 1230,1530
And so, first of all,
因此，首先，就像中断处理器一样，

862
00:25:59,590 --> 00:26:01,000
0,240 240,360 360,750 750,1080 1080,1410
like the interrupt handler,| basically
|基本上可以随时跑对了，

863
00:26:01,000 --> 00:26:02,680
0,120 120,810 990,1140 1140,1350 1350,1680
can run at any instant

864
00:26:02,680 --> 00:26:04,120
0,60 60,450 480,840 840,1350 1350,1440
in time right,| {you,know} you
|你知道你可能是用户空间，

865
00:26:04,240 --> 00:26:05,500
0,360 360,510 510,780 780,1140 1140,1260
might be user space,| and
|如果出现中断，您知道中断机制将耗费当前用户程序切换到内核模式，

866
00:26:05,500 --> 00:26:06,640
0,120 120,540 540,720 720,990 1020,1140
if interrupt comes in you

867
00:26:06,640 --> 00:26:08,650
0,120 120,420 510,930 930,1620 1620,2010
know the interrupt mechanism will

868
00:26:08,650 --> 00:26:10,480
0,540 540,600 600,720 720,1020 1110,1830
cost you know the current

869
00:26:10,480 --> 00:26:11,650
0,330 330,420 420,750 750,840 840,1170
{user -} program to switch

870
00:26:11,650 --> 00:26:12,850
0,270 270,450 450,720 720,1140 1140,1200
to the kernel mode,| you
|您知道代码的陷阱功能，我们在它运行之前已经看到过

871
00:26:12,850 --> 00:26:14,710
0,210 210,420 420,810 810,1800 1800,1860
know the trap functionality of

872
00:26:14,800 --> 00:26:16,000
0,420 420,570 570,750 750,1080 1080,1200
code, we've seen before it

873
00:26:16,000 --> 00:26:17,290
0,330 330,570 570,780 780,1110 1110,1290
runs| and it will all
|它将会全部收到。

874
00:26:17,290 --> 00:26:18,250
0,480 480,570 570,690 690,870 870,960
received.| So we might be
|所以我们可能正处于某个用户进程中，

875
00:26:18,250 --> 00:26:19,090
0,60 60,120 120,420 420,510 510,840
in the middle of some

876
00:26:19,300 --> 00:26:21,070
0,540 540,930 930,1050 1050,1650 1650,1770
user process,| in boom, we
|在BOOM中，我们得到一个中断，突然我们就进入了接收功能。

877
00:26:21,070 --> 00:26:22,060
0,120 120,210 210,570 570,660 660,990
get an interrupt and suddenly

878
00:26:22,060 --> 00:26:23,080
0,150 150,240 240,330 330,660 660,1020
we're in the receive function.|
|

879
00:26:23,900 --> 00:26:24,890
0,150 150,360 360,450 450,540 540,990
And even in the kernel
即使在内核中，如果我们没有持有锁，

880
00:26:24,890 --> 00:26:26,150
0,210 210,390 390,780 780,990 990,1260
like if we're not holding

881
00:26:26,150 --> 00:26:27,830
0,480 480,600 600,990 990,1320 1320,1680
locks,| {you,know} locks turn interrupts
|你知道锁会关闭中断，

882
00:26:27,830 --> 00:26:28,940
0,240 240,480 480,660 660,840 840,1110
off,| but we're not holding
|但我们没有锁定，我们可能会被打断

883
00:26:28,940 --> 00:26:30,020
0,390 390,660 660,810 810,990 990,1080
locks, we could get an

884
00:26:30,020 --> 00:26:32,060
0,600 600,1020 1320,1590 1590,1710 1710,2040
interrupt| and {} the kernel
|并且内核可以基本上将程序计数器改变为中断处理程序

885
00:26:32,060 --> 00:26:34,430
0,630 630,1380 1590,1710 1710,2070 2070,2370
may change the program counter

886
00:26:34,430 --> 00:26:36,770
0,390 390,630 630,1050 1500,1830 1830,2340
basically to the interrupt handler|
|

887
00:26:36,770 --> 00:26:38,750
0,420 450,1140 1140,1200 1200,1590 1590,1980
and run the receive function.|
并运行接收功能。|

888
00:26:39,560 --> 00:26:40,610
0,150 150,480 480,810 810,960 960,1050
So this code sort of
所以这段代码有点像是运行你知道在下半部分的东西，

889
00:26:40,610 --> 00:26:41,510
0,360 360,480 480,540 540,660 660,900
runs you know the things

890
00:26:41,510 --> 00:26:42,530
0,150 150,300 300,360 360,600 600,1020
that in the bottom half,|
|

891
00:26:42,530 --> 00:26:45,200
0,750 750,1020 1020,1740 1740,2070 2070,2670
{you,know,can,basically} run instantly almost anytime.|
你知道，基本上任何时候都可以立刻跑起来。|

892
00:26:45,950 --> 00:26:47,120
0,510 510,600 600,660 660,900 900,1170
{} In the code, in
在代码的上半部分，它实际上代表用户级进程或内核线程运行

893
00:26:47,120 --> 00:26:49,160
0,480 600,960 960,1440 1530,1830 1830,2040
the top half, it really

894
00:26:49,160 --> 00:26:51,260
0,510 510,690 690,1350 1350,1800 1830,2100
operates on behalf of a

895
00:26:51,260 --> 00:26:52,970
0,270 270,540 540,1200 1200,1380 1380,1710
user level processes or kernel

896
00:26:52,970 --> 00:26:54,650
0,330 330,570 570,960 960,1230 1230,1680
threads| that actually make calls
|真正打进上半场的人。

897
00:26:54,650 --> 00:26:55,980
0,360 360,810
into the

898
00:26:56,010 --> 00:26:58,080
0,570 600,990 990,1500
{} top half.|
|

899
00:26:58,080 --> 00:26:59,280
0,330 330,720 720,870 870,1050 1050,1200
{You,know} easily could have been
你很容易就知道情况可能是这样的，

900
00:26:59,280 --> 00:27:00,720
0,60 60,480 780,1050 1050,1260 1260,1440
the case,| in fact this
|事实上，即使在网络测试中也是如此，

901
00:27:00,720 --> 00:27:01,530
0,90 90,150 150,450 450,720 720,810
is the case even in

902
00:27:01,530 --> 00:27:02,850
0,180 180,630 630,870 870,1080 1080,1320
net test,| we might actually
|我们实际上可能会对一大堆流程进行网络测试，

903
00:27:02,850 --> 00:27:05,580
0,480 480,1200 1230,1590 1590,1950 2310,2730
have {} net test for

904
00:27:05,760 --> 00:27:07,170
0,150 150,360 360,540 540,600 600,1410
a whole bunch of processes,|
|

905
00:27:07,470 --> 00:27:08,640
0,180 180,270 270,390 390,660 660,1170
that we have actually many
我们实际上有很多例子，其中一个测试。

906
00:27:08,640 --> 00:27:10,200
0,570 570,870 870,960 960,1050 1050,1560
instances one of the tests.|
|

907
00:27:10,230 --> 00:27:11,340
0,150 150,240 240,720 720,1050 1050,1110
We have many instances of
我们有很多网络测试运行的实例，

908
00:27:11,340 --> 00:27:12,680
0,210 210,450 450,870
net test running,|
|

909
00:27:14,700 --> 00:27:16,290
0,150 150,240 240,540 540,840 840,1590
and they all jump into
并且它们都跳到网络堆栈中，

910
00:27:16,290 --> 00:27:17,340
0,210 210,540 540,900 900,990 990,1050
the network stack,| and they
|你们都知道它们当时被称为传送器，对吧。

911
00:27:17,340 --> 00:27:19,110
0,600 600,690 690,840 840,1200 1200,1770
all you know then called

912
00:27:19,110 --> 00:27:20,600
0,600 870,1260
transmit, right.|
|

913
00:27:20,820 --> 00:27:21,900
0,300 300,510 510,630 630,720 720,1080
So that is the case,|
所以情况就是这样，|

914
00:27:21,900 --> 00:27:22,680
0,180 180,270 270,570 570,660 660,780
so we're looking at this
所以我们从并发性的角度来看待这个问题，

915
00:27:22,680 --> 00:27:25,440
0,120 120,180 180,690 690,1560 1740,2760
from the perspective concurrency,| multiple
|多个发件人可以实际位于上下文中，也可以位于上半部分

916
00:27:25,440 --> 00:27:27,270
0,720 870,1140 1140,1380 1380,1530 1530,1830
senders {} can be actually

917
00:27:27,270 --> 00:27:28,320
0,90 90,150 150,750 750,900 900,1050
in the context, it can

918
00:27:28,320 --> 00:27:29,280
0,90 90,180 180,270 270,540 540,960
be in the top half|
|

919
00:27:29,310 --> 00:27:30,510
0,150 150,300 300,420 420,630 630,1200
and so it's pretty clear,
所以很明显，你知道我们需要一些锁定方案或纪律

920
00:27:30,510 --> 00:27:31,290
0,90 90,240 240,330 330,510 510,780
you know we need some

921
00:27:31,290 --> 00:27:34,260
0,480 480,1140 1500,1650 1650,2310 2670,2970
locking scheme or discipline {}|
|

922
00:27:34,260 --> 00:27:35,820
0,450 450,660 660,1050 1050,1380 1380,1560
to at least make sure
至少要确保不同的发送者不会被对方绊倒。

923
00:27:35,820 --> 00:27:38,040
0,570 570,900 900,1290 1290,1980 2010,2220
that different senders don't trip

924
00:27:38,040 --> 00:27:39,040
0,210 210,330 330,600
over each other.|
|

925
00:27:40,380 --> 00:27:41,910
0,390 390,480 480,630 630,960 960,1530
Then on the bottom half,|
然后在下半部分，|

926
00:27:42,480 --> 00:27:44,520
0,330 330,540 540,1140 1170,1560 1560,2040
there's only one interrupt handler
只有一个中断处理程序是正确的，

927
00:27:44,550 --> 00:27:45,870
0,420 510,810 810,1170 1170,1260 1260,1320
correct,| there's never, in the
|在接收器将由多个调用的情况下，永远不会有多个接收器同时运行

928
00:27:45,870 --> 00:27:46,710
0,300 300,420 420,510 510,750 750,840
case that the receive is

929
00:27:46,710 --> 00:27:47,670
0,120 120,180 180,270 270,690 690,960
going to be called by

930
00:27:47,670 --> 00:27:49,950
0,690 900,1350 1350,1680 1680,2070 2070,2280
multiple, there's multiple receivers running

931
00:27:49,950 --> 00:27:51,600
0,120 120,180 180,450 450,930 1320,1650
at the same time| in
|在不同的核心上并行，您知道中断发生时的中断处理程序，

932
00:27:51,600 --> 00:27:52,800
0,420 420,540 540,780 780,1110 1110,1200
parallel on different cores, you

933
00:27:52,800 --> 00:27:54,930
0,90 90,420 720,870 870,1740 1740,2130
know the the interrupt handler

934
00:27:54,930 --> 00:27:57,000
0,510 510,690 690,750 750,1350 1350,2070
{} when an interrupt happens,|
|

935
00:27:57,270 --> 00:27:58,800
0,450 450,690 690,1200 1200,1290 1290,1530
{} the {process,is} {alert -}
这个过程是警示它的。

936
00:27:58,800 --> 00:27:59,560
0,330
it.|
|

937
00:27:59,560 --> 00:28:01,660
0,630 690,1110 1110,1290 1290,1710 1710,2100
{} And if future interrupts
如果将来发生中断，它们实际上会被阻塞，直到当前中断被实际处理为止

938
00:28:01,660 --> 00:28:04,300
0,600 600,810 810,1440 1470,2130 2160,2640
happen, they're actually blocked until

939
00:28:04,300 --> 00:28:06,280
0,330 390,900 900,1320 1320,1650 1650,1980
the current interrupt actually dealt

940
00:28:06,280 --> 00:28:07,780
0,330 540,720 720,990 990,1110 1110,1500
with| and so in fact,
|所以事实上，当接收功能运行时，

941
00:28:08,050 --> 00:28:09,480
0,930
{}

942
00:28:09,870 --> 00:28:11,670
0,690 690,750 750,990 990,1320 1320,1800
when the receive function runs,|
|

943
00:28:11,910 --> 00:28:13,770
0,480 480,660 660,960 960,1200 1200,1860
{} there's actually only one
在调用接收时，实际上只有一个中断处理程序在运行。

944
00:28:14,100 --> 00:28:16,140
0,150 150,210 210,810 810,1350 1350,2040
{interrupt,handler - -} running, {at,the}

945
00:28:16,350 --> 00:28:18,030
0,540 540,930 930,1140 1140,1230 1230,1680
time that calls for receive.|
|

946
00:28:18,760 --> 00:28:20,560
0,180 180,510 540,840 840,1170 1170,1800
And so there's no real
因此，在接收本身中并不存在真正的即时并发，

947
00:28:21,060 --> 00:28:23,820
0,420 420,1320 1410,2070 2070,2370 2370,2760
immediately concurrency {} in receive

948
00:28:23,820 --> 00:28:26,490
0,540 540,1290 1560,2040 2040,2340 2340,2670
itself,| although of course the
|当然，您知道的传输线程可以与中断处理程序并发运行，

949
00:28:26,940 --> 00:28:29,040
0,840 870,1020 1020,1350 1470,1950 1950,2100
transmit you know threads can

950
00:28:29,040 --> 00:28:30,870
0,510 510,1110 1110,1350 1350,1470 1470,1830
run concurrently with the interrupt

951
00:28:30,870 --> 00:28:32,010
0,330 330,450 450,840 840,960 960,1140
handler,| for example we might
|例如，我们可能有一个运行中断处理程序的内核，

952
00:28:32,010 --> 00:28:33,180
0,150 150,390 390,780 780,1050 1050,1170
have one core running an

953
00:28:33,180 --> 00:28:35,130
0,390 390,930 1140,1560 1560,1680 1680,1950
interrupt handler,| may have another
|可能有另一个核心实际上即将传输。

954
00:28:35,130 --> 00:28:37,380
0,570 570,1260 1260,1890 1890,2160 2160,2250
core actually is about to

955
00:28:37,380 --> 00:28:38,380
0,570
transmit.|
|

956
00:28:39,860 --> 00:28:40,840
0,450
This,
这个，这个有什么问题吗？

957
00:28:42,300 --> 00:28:44,040
0,240 240,630 630,870 870,1230
any questions about this?|
|

958
00:28:45,870 --> 00:28:46,770
0,240 240,390 390,450 450,810 810,900
It's sort of important to
拥有它，理解它是一件很重要的事情。

959
00:28:46,770 --> 00:28:47,820
0,480
have,

960
00:28:49,730 --> 00:28:51,160
0,120 120,810
to understand.|
|

961
00:28:51,310 --> 00:28:52,120
0,90 90,150 150,300 300,390 390,810
It's a bit of review
这是一点复习，但也很重要。

962
00:28:52,120 --> 00:28:53,350
0,240 240,540 540,960 960,1050 1050,1230
but it's important {too -}.|
|

963
00:29:00,400 --> 00:29:02,260
0,270 270,600 630,990 1140,1620 1620,1860
Okay, so.| I guess I
好的，那么。|我想我有一个一般性的问题，

964
00:29:02,260 --> 00:29:04,180
0,210 210,360 360,780 780,1440 1530,1920
have a general question,| how
|我们怎么知道，什么应该被归类为下半部分和上半部分。

965
00:29:04,180 --> 00:29:05,620
0,90 90,210 210,840
do we know,

966
00:29:05,740 --> 00:29:07,060
0,480 660,780 780,1140 1140,1200 1200,1320
what is supposed to be

967
00:29:07,060 --> 00:29:08,890
0,600 600,780 780,990 990,1440 1440,1830
classified as a bottom half

968
00:29:08,890 --> 00:29:10,280
0,90 90,150 150,450 450,870
and the top half.|
|

969
00:29:10,430 --> 00:29:12,200
0,330 330,570 570,1140 1140,1590 1590,1770
{} So, yeah I think
所以，是的，我认为考虑这件事的方式是

970
00:29:12,200 --> 00:29:12,800
0,60 60,150 150,240 240,390 390,600
the way to think about

971
00:29:12,800 --> 00:29:13,730
0,90 90,240 240,450 450,720 720,930
it is that| anything that
|在中断处理程序的上下文中运行的任何东西，都是下半部分。

972
00:29:13,730 --> 00:29:14,540
0,180 180,240 240,330 330,720 720,810
runs in the context of

973
00:29:14,540 --> 00:29:15,650
0,90 90,480 480,870 900,1050 1050,1110
an interrupt handler, that's the

974
00:29:15,650 --> 00:29:16,780
0,270 270,630
bottom half.|
|

975
00:29:17,330 --> 00:29:18,350
0,360 360,420 420,600 600,900 900,1020
And in this case is
在这种情况下，基本上就是接收。

976
00:29:18,350 --> 00:29:19,920
0,360 360,540 540,1020
basically just receive.|
|

977
00:29:20,700 --> 00:29:22,200
0,630 660,1020 1020,1230 1230,1440 1440,1500
And anything that runs in
在常规进程或线程内核线程的上下文中运行的任何东西，您都知道这是上半部分。

978
00:29:22,200 --> 00:29:23,280
0,60 60,420 420,540 540,600 600,1080
the context of {} regular

979
00:29:23,280 --> 00:29:24,460
0,690
process,

980
00:29:24,760 --> 00:29:26,620
0,390 390,810 870,1230 1230,1650 1680,1860
or thread kernel thread, you

981
00:29:26,620 --> 00:29:27,880
0,90 90,330 330,660 690,930 930,1260
know that's the top half.|
|

982
00:29:32,200 --> 00:29:33,970
0,510 780,1290 1440,1620 1620,1680 1680,1770
Okay, {} so if you
好的，如果你再仔细看一下这张照片，

983
00:29:33,970 --> 00:29:36,100
0,120 120,180 180,330 330,990 1020,2130
look at this picture a

984
00:29:36,520 --> 00:29:38,860
0,600 600,720 720,1200 1560,1920 1920,2340
little bit more,| since we're,
|因为我们，实际上让我在这里有一个高级别的声明，

985
00:29:39,010 --> 00:29:41,140
0,450 450,630 630,1140 1140,1230 1230,2130
actually let me have a

986
00:29:41,140 --> 00:29:42,640
0,300 300,630 780,1200 1230,1440 1440,1500
{high,level,statement} here,| a lot of
|很多人问你为什么没有锁定接收，哪里需要锁定。

987
00:29:42,640 --> 00:29:44,050
0,210 210,570 570,630 630,1080 1200,1410
people ask you know why

988
00:29:44,050 --> 00:29:45,720
0,240 240,660 660,1230
no locking receive,

989
00:29:46,320 --> 00:29:49,140
0,690 900,1920 2010,2430 2430,2610 2610,2820
and {} where is lock

990
00:29:49,140 --> 00:29:51,330
0,480 810,1500 1530,1710 1710,1890 1890,2190
needed.| And so the first
|所以第一眼看上去，

991
00:29:51,330 --> 00:29:53,620
0,630 630,1740
glance {},|
|

992
00:29:53,680 --> 00:29:55,120
0,240 420,690 690,870 870,930 930,1440
it might not be necessary
如有必要，可能不需要锁定，

993
00:29:55,120 --> 00:29:56,200
0,150 150,360 360,450 450,870 870,1080
to lock if necessary correct,|
|

994
00:29:56,200 --> 00:29:57,820
0,210 210,360 360,570 570,930 930,1620
because there's only one instance
因为只有一个正在运行的接收实例，

995
00:29:57,850 --> 00:30:00,100
0,480 750,1440 1440,1860 1890,2040 2040,2250
of receive running,| so there's
|因此没有同时运行多个接收实例

996
00:30:00,100 --> 00:30:01,570
0,240 240,600 600,990 990,1080 1080,1470
not multiple instances of receive

997
00:30:01,570 --> 00:30:02,620
0,180 180,300 300,360 360,600 600,1050
running at the same time|
|

998
00:30:02,770 --> 00:30:04,210
0,210 210,300 300,510 510,1170 1200,1440
and so these receives, since
因此这些接收，因为只有一个接收，所以它不与任何其他接收共享数据结构，

999
00:30:04,210 --> 00:30:05,530
0,120 120,360 360,570 570,960 990,1320
there's only one receive, it

1000
00:30:05,530 --> 00:30:06,730
0,210 210,420 420,660 660,1050 1050,1200
doesn't share data structures with

1001
00:30:06,730 --> 00:30:07,840
0,180 180,360 360,720 720,930 930,1110
any other receive,| because there's
|因为他们只有一个，对吧。

1002
00:30:07,840 --> 00:30:08,860
0,180 180,420 420,480 480,690 720,1020
only one of them, right.|
|

1003
00:30:09,380 --> 00:30:10,370
0,240 240,570 570,810 810,870 870,990
Now, of course it could
现在，当然可以是接收器和发送器共享数据结构的情况，

1004
00:30:10,370 --> 00:30:11,150
0,90 90,150 150,480 480,660 660,780
be the case that the

1005
00:30:11,150 --> 00:30:12,830
0,390 390,480 480,540 540,1200 1380,1680
receive and the transmitter shared

1006
00:30:12,830 --> 00:30:14,120
0,240 240,810 840,1050 1050,1170 1170,1290
data structures,| but as we
|但正如我们在一秒钟内看到的，事实并非如此，

1007
00:30:14,120 --> 00:30:15,260
0,210 210,270 270,330 330,870 930,1140
see in a second that

1008
00:30:15,260 --> 00:30:16,340
0,210 210,300 300,510 510,570 570,1080
actually is not the case,|
|

1009
00:30:16,860 --> 00:30:18,540
0,360 360,810 810,1110 1110,1440 1440,1680
{} basically the transmission part
基本上，驱动程序的传输部分完全独立于驱动程序的接收部分，即接收分组。

1010
00:30:18,540 --> 00:30:19,890
0,60 60,150 150,750 780,900 900,1350
of the driver is completely

1011
00:30:19,890 --> 00:30:22,710
0,510 510,840 840,1680 1740,2610 2610,2820
separate from the reception part

1012
00:30:22,710 --> 00:30:24,900
0,90 90,150 150,720 900,1650 1650,2190
of the driver, receiving packets.|
|

1013
00:30:25,380 --> 00:30:26,280
0,120 120,240 240,360 360,390 390,900
And so as a result,
因此，接收实际上并不需要真正的锁定，

1014
00:30:26,430 --> 00:30:28,290
0,300 300,600 600,1020 1020,1560 1560,1860
{} receive doesn't really, doesn't

1015
00:30:28,290 --> 00:30:29,670
0,210 210,480 480,1110 1140,1290 1290,1380
need actually locks,| you know
|您知道，它实际上并不与任何其他并发活动共享数据结构。

1016
00:30:29,670 --> 00:30:30,930
0,120 120,330 330,570 570,900 900,1260
it's really not sharing data

1017
00:30:30,960 --> 00:30:32,250
0,450 450,600 600,750 750,930 930,1290
structures with any other concurrent

1018
00:30:32,250 --> 00:30:33,220
0,450
activity.|
|

1019
00:30:34,400 --> 00:30:36,350
0,420 870,1320 1320,1620 1620,1740 1740,1950
A weird part is that
奇怪的是你们知道你们中的一些人发现了

1020
00:30:36,350 --> 00:30:37,190
0,90 90,210 210,390 390,480 480,840
you know some of you

1021
00:30:37,190 --> 00:30:38,420
0,570 570,720 720,810 810,1020 1020,1230
found out| if you do
|如果您确实使用了锁，您实际上会感到恐慌。

1022
00:30:38,420 --> 00:30:39,760
0,270 270,330 330,840
use a lock,

1023
00:30:39,760 --> 00:30:40,870
0,540 540,720 720,930 930,1020 1020,1110
{} you actually get a

1024
00:30:40,870 --> 00:30:41,980
0,510
panic.|
|

1025
00:30:42,100 --> 00:30:43,210
0,450 450,600 600,720 720,870 870,1110
{} And so let me
所以让我简单地说一下，

1026
00:30:43,210 --> 00:30:44,290
0,420 420,510 510,690 690,810 810,1080
say a little bit about

1027
00:30:44,290 --> 00:30:47,170
0,180 180,750 1290,1740 1980,2670 2670,2880
that,| because the reason that
|因为恐慌发生的原因有一点是因为，

1028
00:30:47,170 --> 00:30:48,130
0,240 240,540 540,660 660,750 750,960
panic happens is a little

1029
00:30:48,130 --> 00:30:49,960
0,150 150,450 450,660 660,990 1260,1830
bit because,| there's a this
|在xv6内核中实际上有一个软件结构，比您想象的要稍微复杂一些

1030
00:30:49,960 --> 00:30:52,210
0,150 150,510 510,960 960,1500 1500,2250
the software structure actually in

1031
00:30:52,510 --> 00:30:54,610
0,360 360,660 660,870 870,1140 1140,2100
in {xv6 -} kernel slightly,

1032
00:30:54,610 --> 00:30:56,500
0,330 600,1470
{ -}

1033
00:30:56,740 --> 00:30:58,240
0,360 360,510 510,1110 1140,1380 1380,1500
slightly more complicated than you

1034
00:30:58,240 --> 00:31:00,310
0,180 180,510 720,1200 1380,1710 1710,2070
might think| and the reason
|原因是基本上接收中断处理程序只做了相当多的工作，

1035
00:31:00,310 --> 00:31:02,290
0,180 180,450 450,990 990,1200 1200,1980
is that basically the receive

1036
00:31:02,320 --> 00:31:03,940
0,390 390,870 870,1170 1170,1350 1350,1620
{} interrupt handler just quite

1037
00:31:03,940 --> 00:31:05,140
0,60 60,180 180,240 240,690
a bit of work,|
|

1038
00:31:05,140 --> 00:31:06,190
0,300 300,540 540,780 780,1020 1020,1050
or can do quite a
或者可以做相当多的工作，

1039
00:31:06,190 --> 00:31:07,360
0,120 120,210 210,600 900,1050 1050,1170
bit of work,| so let
|所以让我稍微谈一谈这件事。

1040
00:31:07,360 --> 00:31:07,990
0,90 90,240 240,300 300,480 480,630
me talk a little bit

1041
00:31:07,990 --> 00:31:09,040
0,270 270,480
about it.|
|

1042
00:31:09,430 --> 00:31:10,630
0,270 270,390 390,480 480,780 780,1200
{} In the particular case
在特定的情况下，它实际上做了相当多的工作，

1043
00:31:10,630 --> 00:31:11,710
0,210 210,690 690,870 870,1050 1050,1080
that actually does quite a

1044
00:31:11,710 --> 00:31:13,870
0,120 120,240 240,990 990,1680 1680,2160
bit of work,| {for,example} ARP
|例如ARP请求，

1045
00:31:14,660 --> 00:31:17,200
0,870 1200,1890
{} requests,|
|

1046
00:31:20,180 --> 00:31:20,900
0,240 240,330 330,480 480,570 570,720
ARP is one of those
ARP是罗伯特刚才谈到的数据包类型之一，

1047
00:31:20,900 --> 00:31:22,610
0,270 270,570 570,1260 1260,1500 1500,1710
packet types that Robert talked

1048
00:31:22,610 --> 00:31:23,690
0,180 180,210 210,390 390,630 630,1080
about a little while ago,|
|

1049
00:31:23,990 --> 00:31:25,760
0,480 480,810 810,930 930,1350 1350,1770
but basically what happens like
但基本上发生的事情就像中断一样，

1050
00:31:25,760 --> 00:31:27,300
0,60 60,420 420,600 600,960
an interrupt comes in,|
|

1051
00:31:27,570 --> 00:31:30,660
0,180 180,450 450,930 930,1560 2430,3090
so an ARP request for
因此ARP请求发现，

1052
00:31:30,960 --> 00:31:32,610
0,600 600,720 720,810 810,1170 1170,1650
discovery,| but the ethernet addresses
|但是以太网地址是你知道进入的IP地址，

1053
00:31:32,610 --> 00:31:35,040
0,480 480,1530 1560,1920 1920,2340 2340,2430
were an IP address you

1054
00:31:35,040 --> 00:31:36,180
0,120 120,330 330,660 660,750 750,1140
know comes in,| you know
|你知道那会叫你知道eth1000_recv，

1055
00:31:36,740 --> 00:31:37,970
0,150 150,360 360,480 480,1110 1140,1230
{} that will call you

1056
00:31:37,970 --> 00:31:39,620
0,150 150,330 330,540 540,900 900,1650
know {eth1000_recv - - -},|
|

1057
00:31:43,400 --> 00:31:45,020
0,750 750,1140 1140,1260 1260,1380 1380,1620
{} and you know it'll
你知道它会管它叫什么Net_Rx，

1058
00:31:45,020 --> 00:31:46,700
0,420 420,780 780,1050 1050,1290 1290,1680
call whatever {net_rx - -},|
|

1059
00:31:46,700 --> 00:31:48,050
0,270 270,390 390,510 510,930 960,1350
so that will go call
这样就会调用前面图片上的网络堆栈，

1060
00:31:48,050 --> 00:31:50,060
0,930 990,1140 1140,1500 1500,1890 1890,2010
into the network stack on

1061
00:31:50,060 --> 00:31:51,770
0,60 60,540 570,1440 1440,1530 1530,1710
the previous pictures,| of that
|在这里接收对此代码的调用，

1062
00:31:51,770 --> 00:31:54,560
0,750 960,1320 1320,2010 2340,2550 2550,2790
receives calls into this code

1063
00:31:54,560 --> 00:31:55,780
0,240 240,720
over here,|
|

1064
00:31:56,460 --> 00:31:59,190
0,570 780,1170 1170,1770 1800,1980 1980,2730
{} net receive {you,know} calls
NET RECEIVE你知道调用OOPS，NET RECEIVE调用NET_RX_ARP。

1065
00:32:03,540 --> 00:32:05,640
0,570 570,960 960,1530
{oops,,net,receive} calls {}

1066
00:32:06,260 --> 00:32:08,760
0,630 720,1170 1170,1770
{net_rx_arp - -

1067
00:32:08,970 --> 00:32:11,300
0,1020 1020,1710
- -}.|
|

1068
00:32:12,690 --> 00:32:14,400
0,570 570,780 780,1440 1440,1620 1620,1710
And it {} and you
而且你知道它看起来你知道有一个ARP数据包

1069
00:32:14,400 --> 00:32:15,540
0,150 150,330 330,900 900,1020 1020,1140
know it looks you know

1070
00:32:15,540 --> 00:32:16,860
0,210 210,270 270,480 480,1020 1020,1320
there's an ARP packet| and
|并且基本上发回xv6的这一特定情况的以太网地址

1071
00:32:16,860 --> 00:32:18,810
0,360 360,540 540,900 900,1590 1590,1950
basically sends back the ethernet

1072
00:32:18,810 --> 00:32:20,490
0,300 300,600 600,810 810,990 990,1680
address [] for this particular

1073
00:32:20,910 --> 00:32:25,170
0,1800 2220,2670 2670,3090 3300,3870 3870,4260
for {xv6 -}| and then
|然后它这样做，你当然知道发送数据包的方式，

1074
00:32:25,170 --> 00:32:25,770
0,60 60,210 210,270 270,480 480,600
the way it does that

1075
00:32:25,770 --> 00:32:26,550
0,60 60,420 420,480 480,660 660,780
of course you know to

1076
00:32:26,550 --> 00:32:27,690
0,210 210,300 300,720 720,960 960,1140
send the packet,| it will
|它将调用E1000_Transmit Right。

1077
00:32:27,690 --> 00:32:30,320
0,570 870,1110 1110,1380 1380,2190
call {you,know}, {e1000_transmit -

1078
00:32:31,740 --> 00:32:33,060
0,690
-}

1079
00:32:36,470 --> 00:32:37,790
0,390 390,810 840,930 930,1140 1170,1320
right.| And you know we
|你知道，我们知道这实际上需要一把锁，

1080
00:32:37,790 --> 00:32:39,140
0,240 240,510 510,720 720,990 990,1350
know that will actually need

1081
00:32:39,140 --> 00:32:40,920
0,90 90,540 540,600 600,1140
to acquire a lock,|
|

1082
00:32:42,070 --> 00:32:43,210
0,270 270,480 480,630 630,1020 1050,1140
well, you did that you
嗯，你知道只要有eth1000_lock，你就会这么做。

1083
00:32:43,210 --> 00:32:45,550
0,150 150,570 570,840 840,1170 1170,2340
know whenever there's {eth1000_lock -}.|
|

1084
00:32:50,860 --> 00:32:51,970
0,120 120,390 390,540 540,870 870,1110
The reason that actually has
实际上必须上锁的原因是

1085
00:32:51,970 --> 00:32:52,930
0,330 360,540 540,690 690,750 750,960
to go on a lock

1086
00:32:52,930 --> 00:32:53,710
0,90 90,360 360,450 450,660 660,780
is| because there might be
|因为可能有多个发送者，你知道发送者不应该被绊倒，被对方绊倒。

1087
00:32:53,710 --> 00:32:55,450
0,720 720,1200 1200,1470 1470,1590 1590,1740
multiple senders and you know

1088
00:32:55,450 --> 00:32:56,590
0,210 210,540 540,720 720,930 930,1140
the senders should not trip

1089
00:32:56,590 --> 00:32:59,110
0,840 1200,1740 1950,2190 2190,2400 2400,2520
over over, trip over each

1090
00:32:59,110 --> 00:32:59,880
0,240
other.|
|

1091
00:33:00,440 --> 00:33:01,820
0,510 900,1020 1020,1170 1170,1320 1320,1380
{} So that's sort of
所以这就是一幅图画，

1092
00:33:01,820 --> 00:33:02,750
0,90 90,450 450,540 540,780 780,930
the picture,| so what we're
|所以我们基本上就这张前一张图片而言，

1093
00:33:02,750 --> 00:33:03,830
0,420 420,540 540,780 780,840 840,1080
basically in terms of this

1094
00:33:03,830 --> 00:33:05,090
0,360 360,690 690,840 840,930 930,1260
previous picture,| what we're seeing
|我们在这里看到的是，

1095
00:33:05,090 --> 00:33:06,560
0,330 330,450 450,750
here is that,|
|

1096
00:33:06,590 --> 00:33:08,200
0,150 150,480 480,1080
the bottom half
下半部分可能最终调用上半部分中的代码

1097
00:33:08,660 --> 00:33:10,970
0,570 780,1260 1260,1500 1500,1980 1980,2310
{} may end up {call,the}

1098
00:33:10,970 --> 00:33:12,770
0,390 390,510 510,810 870,1260 1260,1800
code in the top half|
|

1099
00:33:12,950 --> 00:33:14,360
0,270 270,420 420,810 810,1320 1320,1410
and come back into the
然后从上半部分回到车手身上。

1100
00:33:14,360 --> 00:33:16,010
0,600 600,840 840,900 900,1200 1200,1650
driver through the top half.|
|

1101
00:33:17,400 --> 00:33:18,630
0,390 390,600 600,840 840,1110 1110,1230
And a number of, you
还有一些，你知道你在这方面遇到了麻烦，

1102
00:33:18,630 --> 00:33:20,460
0,510 750,1080 1080,1260 1260,1500 1500,1830
know you run into trouble

1103
00:33:20,460 --> 00:33:22,050
0,120 120,480 480,1170 1230,1410 1410,1590
with that,| because you know
|因为你知道，你知道，你不是百分之百清楚，你不需要在接收部分加锁

1104
00:33:22,050 --> 00:33:24,570
0,810 1200,1860 1860,1980 1980,2130 2160,2520
the {} you know {it's,not,100%

1105
00:33:24,570 --> 00:33:25,620
0,240 240,600 600,720 720,840 840,1050
-} clear that you didn't

1106
00:33:25,620 --> 00:33:27,870
0,480 510,1050 1050,1620 1620,2100 2130,2250
need a locks in the

1107
00:33:27,870 --> 00:33:30,060
0,540 540,1260 1290,1740 1860,2070 2070,2190
receiving {} part| and so
|所以你们中相当多的人遇到了这种特殊的虫子，

1108
00:33:30,060 --> 00:33:31,020
0,210 210,270 270,510 510,750 750,960
quite a {number,of} you run

1109
00:33:31,020 --> 00:33:32,460
0,180 180,360 360,750 750,1050 1050,1440
into this particular bug,| where
|您实际上需要在接收中输入eth1000_lock。

1110
00:33:32,520 --> 00:33:34,540
0,510 510,750 750,1560
you're actually required

1111
00:33:37,210 --> 00:33:40,220
0,720 750,1290 1290,2460
the {you,know} eth1000_lock

1112
00:33:42,800 --> 00:33:44,340
0,210 210,900
in receive.|
|

1113
00:33:45,460 --> 00:33:46,420
0,150 150,270 270,450 450,570 570,960
And that worked all fine
这一切都很正常，只是偶尔你会惊慌失措。

1114
00:33:46,420 --> 00:33:47,410
0,330 330,690 690,900 900,960 960,990
correctly, except once in a

1115
00:33:47,410 --> 00:33:49,000
0,210 210,300 300,450 450,990
while you {get,a} panic.|
|

1116
00:33:49,670 --> 00:33:50,570
0,480 480,570 570,690 690,810 810,900
Why do you get the
你为什么会惊慌失措。

1117
00:33:50,570 --> 00:33:51,660
0,540
panic.|
|

1118
00:33:52,140 --> 00:33:53,190
0,360 360,450 450,600 600,870 870,1050
Hopefully with this picture, that's
希望这张照片能让你看得很清楚，但是。

1119
00:33:53,190 --> 00:33:54,600
0,210 210,570 570,870
pretty clear, but.|
|

1120
00:33:59,400 --> 00:34:00,600
0,90 90,270 270,510 510,750 870,1200
I mean, isn't it going
我是说，这不会是同一把锁吗，

1121
00:34:00,600 --> 00:34:01,590
0,90 90,180 180,270 270,660 660,990
to be the same lock,|
|

1122
00:34:01,590 --> 00:34:03,420
0,270 270,510 540,660 660,1740 1740,1830
because that the e1000_transmit is
因为E1000_Transmit将尝试向下获取堆栈。

1123
00:34:03,420 --> 00:34:04,530
0,120 120,180 180,360 360,510 510,1110
going to try to acquire

1124
00:34:04,560 --> 00:34:07,020
0,240 240,330 330,720 1050,1680 1680,2460
down the stack.| {Yeah,exactly}, correct,|
|是的，没错，没错，|

1125
00:34:07,380 --> 00:34:08,430
0,300 300,570 570,840 840,930 930,1050
{so,eth1000 -} here at this
所以在这一点上，eth1000现在拥有这把锁，

1126
00:34:08,430 --> 00:34:10,110
0,360 360,720 720,1050 1050,1140 1140,1680
point now owns the lock,|
|

1127
00:34:10,320 --> 00:34:11,580
0,330 330,570 570,870 870,1050 1050,1260
holds it calls {net_rx -
保留它，调用NET_RX，调用NET_RX_ARP，E1000_Transmit，然后再次调用Acquisition

1128
00:34:11,580 --> 00:34:13,470
0,240 240,510 510,900 900,1200 1320,1890
-}, calls {net_rx_arp -}, {e1000_transmit

1129
00:34:13,470 --> 00:34:14,640
0,180 180,270 270,810 810,990 990,1170
- - -}, then calls

1130
00:34:14,640 --> 00:34:16,200
0,360 360,780 1140,1350 1350,1440 1440,1560
acquire again| and as you
|你们可能还记得以前的实验，

1131
00:34:16,200 --> 00:34:17,760
0,210 210,600 600,720 720,1080 1080,1560
might remember from previous labs,|
|

1132
00:34:17,940 --> 00:34:20,190
0,360 360,1080 1110,1680 1680,1950 1950,2250
if require {} it's called
如果需要，就叫它，它已经挂起了，

1133
00:34:20,190 --> 00:34:21,580
0,180 180,480 480,1050
it's already held,|
|

1134
00:34:21,610 --> 00:34:23,440
0,510 510,720 720,780 780,1380 1410,1830
{} that's a deadlock right,|
这是个僵局，对吧|

1135
00:34:23,440 --> 00:34:25,090
0,120 120,780 780,1140 1140,1350 1350,1650
and so {xv6 -} kernel
因此xv6内核出现了恐慌。

1136
00:34:25,090 --> 00:34:26,100
0,510
panics.|
|

1137
00:34:28,240 --> 00:34:30,280
0,960 1170,1410 1410,1740 1740,1980 1980,2040
Question, let's let's assume we
问题是，让我们假设我们的锁实现略有不同，

1138
00:34:30,280 --> 00:34:32,170
0,180 180,570 570,930 930,1230 1230,1890
had a slightly different implementation

1139
00:34:32,170 --> 00:34:33,430
0,150 150,450 450,690 690,900 960,1260
of locks,| such as those
|比如那些(狂热分子)和其他关怀，

1140
00:34:33,430 --> 00:34:35,240
0,390 390,510 510,720 720,1200
[fanatics] and other care,|
|

1141
00:34:35,480 --> 00:34:37,670
0,480 750,900 900,1230 1230,1740 1920,2190
like it would such, let's
就像这样，让我们假设，如果我想获得很多已经持有的东西，什么都没有发生。

1142
00:34:37,670 --> 00:34:38,510
0,240 240,420 420,540 540,630 630,840
assume like if I wanted

1143
00:34:38,510 --> 00:34:39,680
0,120 120,420 420,480 480,750 750,1170
to acquire a lot already

1144
00:34:39,680 --> 00:34:41,840
0,330 330,600 600,1140 1380,1860 1890,2160
held nothing happened.| Yeah so,
|是的，这些就是所谓的递归锁，

1145
00:34:41,840 --> 00:34:43,700
0,690 720,870 870,1500 1500,1710 1710,1860
{ -} these are these

1146
00:34:43,700 --> 00:34:45,580
0,120 120,450 450,870 870,1410
are called recursive locks,|
|

1147
00:34:47,660 --> 00:34:48,950
0,300 300,450 450,810 810,1200 1200,1290
or {reentrant -} locks is
或者可重入锁是它们的另一种名称。

1148
00:34:48,950 --> 00:34:50,390
0,270 270,450 450,990 990,1320 1320,1440
another way the name for

1149
00:34:50,390 --> 00:34:51,580
0,360
them.|
|

1150
00:34:51,580 --> 00:34:52,690
0,360 360,510 510,630 630,780 780,1110
And so if you have
所以如果你有一个递归锁，可重入锁，

1151
00:34:52,720 --> 00:34:54,130
0,120 120,510 510,900 900,1110 1110,1410
a recursive locks, {reentrant -}

1152
00:34:54,130 --> 00:34:55,420
0,330 330,780 780,900 900,1140 1140,1290
locks,| then you know you
|然后你知道你可以自由地做这件事，这不会有问题的。

1153
00:34:55,420 --> 00:34:56,620
0,300 450,780 780,900 900,1110 1110,1200
could freely do this and

1154
00:34:56,620 --> 00:34:57,520
0,60 60,180 180,270 270,420 420,900
it would be no problem.|
|

1155
00:34:58,170 --> 00:34:59,580
0,660 660,930 930,1080 1080,1290 1290,1410
And I think one of
我想你们中的一位通过电子邮件向我提到，实际上实现的递归锁

1156
00:34:59,580 --> 00:35:01,710
0,480 600,1050 1050,1680 1680,2010 2010,2130
you over email mentioned to

1157
00:35:01,710 --> 00:35:03,360
0,180 180,390 390,870 870,1170 1170,1650
me that actually the implemented

1158
00:35:03,360 --> 00:35:04,950
0,330 330,810 870,960 960,1440 1440,1590
recursive locks| to actually deal
|才能真正解决这个特殊的问题。

1159
00:35:04,950 --> 00:35:06,460
0,120 120,240 240,600 600,1020
with this particular problem.|
|

1160
00:35:06,660 --> 00:35:08,220
0,240 240,390 390,750 780,1170 1170,1560
And so they did required
因此他们需要锁定eth1000_recv函数，

1161
00:35:08,220 --> 00:35:10,530
0,60 60,360 360,480 480,1110 1380,2310
to lock in the eth1000_recv

1162
00:35:10,530 --> 00:35:13,230
0,570 840,1440 1440,2070 2100,2580 2580,2700
function,| {} and {} {you,know}
|您知道，在死机之后，基本上修复了xv6方向的获取释放支持递归锁定。

1163
00:35:13,230 --> 00:35:14,700
0,270 270,330 330,780 780,1080 1080,1470
after the panic, basically fixed

1164
00:35:14,700 --> 00:35:17,610
0,870 870,1350 1350,2070 2070,2370 2370,2910
{acquire,release} {in,the} xv6 direction support

1165
00:35:17,640 --> 00:35:19,160
0,330 330,600 600,1080
{} recursive locks.|
|

1166
00:35:20,760 --> 00:35:21,810
0,150 150,270 270,450 450,540 540,1050
And that would {be,a} solution.|
这将是一个解决方案。|

1167
00:35:23,240 --> 00:35:24,980
0,360 420,840 840,1230 1230,1680 1680,1740
A simple solution, it's a
一个简单的解决方案，这是一个很好的解决方案，

1168
00:35:24,980 --> 00:35:28,460
0,240 240,840 900,1620 1710,3480 3480,3480
fine solution,| { -} a
|我们计划的解决方案和现有的员工解决方案

1169
00:35:28,460 --> 00:35:30,200
0,420 420,540 540,690 690,1170 1170,1740
solution that we intended and

1170
00:35:30,230 --> 00:35:31,970
0,210 720,1050 1050,1380 1380,1590 1590,1740
the staff solution as is|
|

1171
00:35:31,970 --> 00:35:33,620
0,480 480,660 660,900 900,1410 1410,1650
basically just doesn't require locks
基本上根本不需要在接收中锁定，

1172
00:35:33,620 --> 00:35:35,360
0,180 180,690 1050,1230 1230,1500 1500,1740
in receive at all,| because
|因为事实证明这是没有必要的。

1173
00:35:35,360 --> 00:35:36,380
0,90 90,450 480,720 720,870 870,1020
it actually turned out not

1174
00:35:36,380 --> 00:35:37,560
0,60 60,150 150,720
to be necessary.|
|

1175
00:35:39,910 --> 00:35:41,110
0,330 330,450 450,570 570,750 750,1200
Sorry, can you say again,
对不起，你能再说一遍吗，为什么在接收中不能有两个线程。

1176
00:35:41,110 --> 00:35:42,970
0,390 390,720 720,990 990,1200 1200,1860
why there couldn't be two

1177
00:35:43,150 --> 00:35:45,660
0,840 990,1230 1230,1920
threads in receive.|
|

1178
00:35:46,550 --> 00:35:47,600
0,240 240,420 420,780 780,990 990,1050
There's only one thread in
在接收中只有一个线程，即运行中断处理程序。

1179
00:35:47,600 --> 00:35:49,310
0,480 510,630 630,930 930,1230 1230,1710
receive, the interrupt handler runs.|
|

1180
00:35:49,930 --> 00:35:51,220
0,150 150,330 330,690 690,990 990,1290
There's only one receive function
在任何内核上，一次只有一个接收函数在运行。

1181
00:35:51,220 --> 00:35:52,180
0,210 210,450 450,570 570,630 630,960
ever running at the time

1182
00:35:52,180 --> 00:35:53,780
0,210 240,540 540,1020
on any core.|
|

1183
00:35:54,110 --> 00:35:56,030
0,390 390,630 630,960 960,1380 1380,1920
That actually calls into the
这实际上会调用上半部分，即操作系统的上半部分

1184
00:35:56,390 --> 00:35:59,930
0,420 420,1050 1110,1290 1290,1920 2010,3540
top half of the, {the,top,half,of,the}

1185
00:35:59,930 --> 00:36:01,640
0,300 300,840 1230,1350 1350,1470 1470,1710
operating system| and that calles
|回调到下半部，

1186
00:36:01,640 --> 00:36:03,800
0,780 780,1050 1050,1410 1410,1770 1800,2160
back out into the bottom

1187
00:36:03,800 --> 00:36:05,930
0,480 1380,1650 1650,1710 1710,1770 1770,2130
half,| {sorry,not} in the bottom,
|抱歉，不在底部，这会回调到E1000_Transmit

1188
00:36:05,960 --> 00:36:07,940
0,240 240,480 480,810 810,1320 1320,1980
that calls back into e1000_transmit|
|

1189
00:36:07,940 --> 00:36:09,230
0,180 180,690 690,1050 1050,1230 1230,1290
and transmit definitely needs to
并且传输肯定需要获取锁定，

1190
00:36:09,230 --> 00:36:10,340
0,360 360,420 420,750
acquire a lock,|
|

1191
00:36:10,430 --> 00:36:13,360
0,330 330,600 600,1320 1320,2370
so even receive, eth1000_recv,
因此，即使在持有锁的同时接收eth1000_recv

1192
00:36:13,360 --> 00:36:15,610
0,690 690,1080 1080,1200 1200,1650 1740,2250
while holding the lock| calls
|调用E1000_Transmit，该E1000_Transmit尝试获取中断处理程序已经持有的相同锁，

1193
00:36:15,610 --> 00:36:17,620
0,120 120,1230 1290,1620 1620,1950 1950,2010
{e1000_transmit -} which tries to

1194
00:36:17,620 --> 00:36:18,880
0,390 390,450 450,750 750,1080 1080,1260
acquire the same lock that

1195
00:36:18,880 --> 00:36:20,650
0,180 180,540 540,870 870,1260 1260,1770
the interrupt handler already holds,|
|

1196
00:36:21,600 --> 00:36:23,250
0,240 240,390 390,900 1050,1500 1500,1650
if you have, if you
如果您有，如果您锁定了接收处理程序。

1197
00:36:23,250 --> 00:36:25,600
0,390 390,840 900,1380 1380,1830
locked in receive handler.|
|

1198
00:36:26,830 --> 00:36:28,820
0,210 210,720 870,1410
I see, so
我明白了，所以是这样的，

1199
00:36:29,100 --> 00:36:30,270
0,420 450,600 600,720 720,840 840,1170
so it is the case,|
|

1200
00:36:30,270 --> 00:36:32,250
0,0 420,960 960,1380 1380,1410 1410,1980
{} like one {interrupt -}
就像一次中断就会响起

1201
00:36:32,310 --> 00:36:33,630
0,240 240,420 420,750 750,840 840,1320
can go off| and then
|然后，当它还在运行时，另一个中断可能也会发生。

1202
00:36:34,200 --> 00:36:37,260
0,480 480,720 720,1380 1380,2070 2190,3060
while it's still running another

1203
00:36:37,290 --> 00:36:38,760
0,570 570,780 780,930 930,1260 1260,1470
interrupt could go off as

1204
00:36:38,760 --> 00:36:41,070
0,390 420,750 750,1740 1740,1920 1920,2310
well, is.| No, no the
|不，不是那张照片，也许可以回到这张照片上，

1205
00:36:41,070 --> 00:36:42,180
0,480 480,690 690,810 810,930 930,1110
picture, maybe {} go back

1206
00:36:42,180 --> 00:36:43,740
0,90 90,240 240,690 990,1170 1170,1560
to this picture,| so interrupt
|所以中断发生了，它调用接收函数，

1207
00:36:43,740 --> 00:36:44,840
0,570
happens,

1208
00:36:44,930 --> 00:36:46,370
0,180 180,420 420,480 480,840 840,1440
that calls the receive function,|
|

1209
00:36:46,760 --> 00:36:47,990
0,210 210,390 390,600 600,900 900,1230
there's only one receive function
只有一个接收函数在运行，

1210
00:36:47,990 --> 00:36:50,180
0,510 630,840 840,1170 1170,1500 1500,2190
running,| that receive function calls
|接收函数调用您知道RX Net Receiver，

1211
00:36:50,540 --> 00:36:52,670
0,150 150,330 330,660 660,1170 1200,2130
you know {rx -} net

1212
00:36:52,700 --> 00:36:54,230
0,690 690,960 960,1140 1140,1290 1290,1530
receive,| {that,calls} {rx -} net
|调用RX网络接收ARP

1213
00:36:54,230 --> 00:36:56,300
0,570 570,990 1200,1440 1440,1860 1860,2070
receive arp| and that arp
|发送ARP函数调用，

1214
00:36:56,300 --> 00:36:58,500
0,540 660,1110 1110,1740
function calls transmit,|
|

1215
00:36:58,740 --> 00:37:00,090
0,450 450,570 570,750 750,930 930,1350
and if you were using
如果你在发送和接收中使用相同的锁定，

1216
00:37:00,090 --> 00:37:01,710
0,90 90,450 450,930 960,1110 1110,1620
the same lock in transmit

1217
00:37:01,710 --> 00:37:03,090
0,120 120,750 870,1110 1110,1260 1260,1380
and receive,| {you,know} you would
|你知道你会陷入僵局的。

1218
00:37:03,090 --> 00:37:04,400
0,150 150,210 210,780
get a deadlock.|
|

1219
00:37:08,100 --> 00:37:09,600
0,390 390,540 540,840 840,1110 1110,1500
Okay I see, thank you.|
好的，我明白了，谢谢。|

1220
00:37:13,660 --> 00:37:15,240
0,240 240,390 390,660 660,1050
{That's,sort,of -}, yeah, okay,|
有点像是，是的，好的，|

1221
00:37:15,540 --> 00:37:16,470
0,120 120,330 330,720 720,780 780,930
and so basically the two
所以基本上有两种解决方案，

1222
00:37:16,470 --> 00:37:18,030
0,420 420,510 510,960 990,1410 1410,1560
solutions to this,| one is
|一种是使用递归锁，

1223
00:37:18,030 --> 00:37:20,000
0,120 120,420 420,870 870,1410
to use recursive locks,|
|

1224
00:37:20,370 --> 00:37:22,350
0,300 300,750 750,1200 1290,1560 1560,1980
other solution was no walks
另一种解决方案是不走进接待处，

1225
00:37:22,350 --> 00:37:23,480
0,570
in

1226
00:37:23,780 --> 00:37:25,120
0,780
receive,|
|

1227
00:37:25,790 --> 00:37:27,200
0,660 660,810 810,1020 1020,1230 1230,1410
or you know, have two
或者你知道，有两把锁。

1228
00:37:27,200 --> 00:37:28,360
0,540
locks.|
|

1229
00:37:31,040 --> 00:37:31,970
0,270 270,450 450,510 510,720 720,930
All three of them are
这三个都是完全合理的解决方案。

1230
00:37:31,970 --> 00:37:33,820
0,360 360,720 720,1290
totally reasonable solutions.|
|

1231
00:37:37,000 --> 00:37:38,580
0,210 210,510 510,690 690,1050
Any questions about this?|
对此有什么问题吗？|

1232
00:37:39,070 --> 00:37:40,120
0,240 240,390 390,570 570,690 690,1050
Would there be a reason
会不会有理由在接待员周围加锁呢。

1233
00:37:40,120 --> 00:37:41,500
0,120 120,300 300,360 360,780 810,1380
to have a lock around

1234
00:37:41,530 --> 00:37:44,020
0,570 570,750 750,1080 1380,1890 2400,2490
receive at all.| No, in
|不，在这种特殊情况下，根本没有理由加锁。

1235
00:37:44,020 --> 00:37:45,250
0,180 180,510 510,750 750,900 900,1230
this particular case, there's no

1236
00:37:45,250 --> 00:37:46,000
0,270 270,330 330,480 480,510 510,750
reason to have a lock

1237
00:37:46,000 --> 00:37:47,340
0,60 60,360
at all.|
|

1238
00:37:49,540 --> 00:37:51,520
0,390 390,600 600,1140 1320,1800 1800,1980
What would be, could we
我们能想出这样一种情况吗？如果你想要一个接收锁，

1239
00:37:51,520 --> 00:37:52,780
0,210 210,330 330,390 390,1050 1050,1260
think of a situation where

1240
00:37:52,780 --> 00:37:54,250
0,240 240,510 570,900 960,1110 1110,1470
you would want a receive

1241
00:37:54,250 --> 00:37:55,000
0,240 240,390 390,480 480,660 660,750
lock,| would be like if
|就像你有两块网卡之类的。

1242
00:37:55,000 --> 00:37:57,040
0,150 150,480 480,1110 1140,1470 1470,2040
you had two network cards

1243
00:37:57,250 --> 00:37:58,460
0,90 90,720
or something.|
|

1244
00:37:58,550 --> 00:38:00,440
0,480 480,930 930,1590 1590,1740 1740,1890
Yeah, or {} if you
是啊，或者如果你还记得UART代码的话，

1245
00:38:00,440 --> 00:38:01,940
0,180 180,510 510,630 630,1110 1110,1500
like if you remember in

1246
00:38:01,940 --> 00:38:05,930
0,750 780,1170 1170,1680 2040,3180 3630,3990
the UART code,| {} okay,
|好的，您可能想要共享锁的一个常见原因是

1247
00:38:05,930 --> 00:38:08,570
0,210 990,1560 1560,1770 1770,2340 2340,2640
so may a common reason

1248
00:38:08,570 --> 00:38:09,410
0,240 240,390 390,630 630,780 780,840
why you might want to

1249
00:38:09,410 --> 00:38:11,090
0,270 270,360 360,780 780,1350 1350,1680
have a locking {shared,is}| because
|因为下半部分，上半部分是共享的数据结构。

1250
00:38:11,090 --> 00:38:12,410
0,270 300,840 840,1170 1170,1260 1260,1320
the bottom half, in the

1251
00:38:12,410 --> 00:38:14,450
0,330 330,810 1170,1560 1560,1830 1830,2040
top half a shared data

1252
00:38:14,450 --> 00:38:15,480
0,570
structures.|
|

1253
00:38:17,200 --> 00:38:18,760
0,150 150,270 270,780 780,1110 1110,1560
So, for example the receive
因此，例如，接收和发送可能操作相同的共享数据结构，

1254
00:38:18,760 --> 00:38:20,560
0,150 150,600 600,1260 1260,1710 1710,1800
and transmit might manipulate the

1255
00:38:20,560 --> 00:38:22,180
0,270 270,480 480,690 690,1290 1530,1620
same shared data structures,| at
|在这一点上你需要你需要一把锁，

1256
00:38:22,180 --> 00:38:23,470
0,150 150,450 450,570 570,1170 1170,1290
that point you need you

1257
00:38:23,470 --> 00:38:24,490
0,150 150,240 240,630 690,900 900,1020
need a lock,| and so
|例如，您记得在您的控制台驱动程序中，

1258
00:38:24,490 --> 00:38:25,480
0,60 60,390 390,480 480,870 870,990
for example you remember from

1259
00:38:25,480 --> 00:38:27,060
0,90 90,450 450,1080
your console driver,|
|

1260
00:38:27,060 --> 00:38:28,320
0,390 390,540 540,780 780,810 810,1260
{} they shared a queue,|
他们共用一个队列，|

1261
00:38:29,100 --> 00:38:31,500
0,510 510,930 930,1830 1890,2220 2220,2400
and so receive {} handler
因此接收处理程序需要获得队列，

1262
00:38:31,500 --> 00:38:32,970
0,90 90,390 390,690 720,1230 1230,1470
{} needed to get queue,|
|

1263
00:38:33,120 --> 00:38:34,590
0,300 300,660 660,990 990,1200 1200,1470
need to lock to actually
需要锁定才能实际访问该队列。

1264
00:38:34,590 --> 00:38:35,550
0,150 150,420 420,510 510,690 690,960
get access to that queue.|
|

1265
00:38:39,480 --> 00:38:40,680
0,120 120,450 450,630 630,720 720,1200
Does that answer your question?|
这回答了你的问题吗？|

1266
00:38:42,500 --> 00:38:43,820
0,390 660,1080
Yeah, thanks.|
好的，谢谢。|

1267
00:38:44,720 --> 00:38:45,470
0,120 120,240 240,390 390,600 600,750
And so this brings me
这就引出了我想提出的第二点。

1268
00:38:45,470 --> 00:38:46,340
0,150 150,330 330,390 390,690 690,870
up with a second sort

1269
00:38:46,340 --> 00:38:47,090
0,60 60,330 330,420 420,690 690,750
of point I wanted to

1270
00:38:47,090 --> 00:38:48,080
0,420
make.|
|

1271
00:38:48,230 --> 00:38:51,620
0,690 720,1350 1620,2400 2820,3210 3210,3390
{} That the {} let
这让我实际上画了一幅新画，因为它有点拥挤。

1272
00:38:51,620 --> 00:38:52,400
0,60 60,360 360,540 540,630 630,780
me actually draw a new

1273
00:38:52,400 --> 00:38:53,180
0,300 300,510 510,570 570,720 720,780
picture, because it gets a

1274
00:38:53,180 --> 00:38:55,370
0,210 210,750 1170,1650 1830,2040 2040,2190
little crowded.| {} We think
|我们再考虑下半部分，上半部分。

1275
00:38:55,370 --> 00:38:56,780
0,210 210,330 330,660 660,990 990,1410
about this bottom half again,

1276
00:38:56,780 --> 00:38:58,220
0,90 90,150 150,510 510,960
ane the top half.|
|

1277
00:39:00,670 --> 00:39:01,690
0,120 120,330 330,390 390,780 780,1020
So here's the bottom little
下面是最底层的一些抽象内容，但是你知道它可能会有帮助。

1278
00:39:01,690 --> 00:39:03,070
0,120 120,690 690,870 870,990 990,1380
bit abstract, but you know

1279
00:39:03,400 --> 00:39:05,020
0,150 150,300 300,390 390,990
it may be helpful.|
|

1280
00:39:07,110 --> 00:39:09,390
0,570 630,1140 1350,1860 1860,2010 2010,2280
In much typically in much
在许多软件、驱动程序软件

1281
00:39:09,390 --> 00:39:11,610
0,510 510,1080 1110,1620 1620,1860 1860,2220
software, {} driver {software -},|
|

1282
00:39:11,640 --> 00:39:13,590
0,570 570,900 900,1230 1230,1590 1590,1950
the bottom half basically doesn't
下半部分基本上不会真正进入上半部分。

1283
00:39:13,590 --> 00:39:15,870
0,450 450,930 930,1890 1920,2010 2010,2280
really call into the top

1284
00:39:15,870 --> 00:39:17,000
0,240 240,330 330,690
half at all.|
|

1285
00:39:17,360 --> 00:39:18,170
0,240 240,390 390,450 450,750 750,810
{} So, for example if
因此，例如，如果您返回并查看控制台代码，

1286
00:39:18,170 --> 00:39:19,070
0,90 90,210 210,660 660,780 780,900
you go back and you

1287
00:39:19,070 --> 00:39:20,390
0,150 150,240 240,330 330,1050 1080,1320
look at the console {}

1288
00:39:20,390 --> 00:39:22,460
0,480 690,960 960,1380 1380,1800 1800,2070
code,| {} this sequence of
|这一系列的秘密不可能在那里发生

1289
00:39:22,460 --> 00:39:24,500
0,570 600,990 990,1440 1440,1800 1800,2040
{} secrets cannot happen there|
|

1290
00:39:24,530 --> 00:39:25,790
0,360 360,450 450,690 690,930 930,1260
and the reason doesn't happen
而没有发生的原因是因为下半部分通常做的工作很少，

1291
00:39:25,790 --> 00:39:26,870
0,90 90,390 390,540 540,870 870,1080
is because the bottom half

1292
00:39:26,870 --> 00:39:28,310
0,420 420,600 600,810 810,1020 1020,1440
typically does very little work,|
|

1293
00:39:28,550 --> 00:39:29,540
0,300 300,510 510,630 630,720 720,990
the only thing it does
它唯一能做的就是抓到包，把包放在队列里。

1294
00:39:29,540 --> 00:39:30,890
0,270 270,540 540,810 810,900 900,1350
maybe you grab the packet,

1295
00:39:31,100 --> 00:39:31,940
0,330 330,390 390,720 720,780 780,840
stick the packet in the

1296
00:39:31,940 --> 00:39:32,800
0,390
queue.|
|

1297
00:39:34,000 --> 00:39:35,020
0,150 150,540 540,660 660,810 810,1020
And then, at some point
然后，在后来的某个时候，

1298
00:39:35,020 --> 00:39:36,640
0,540 660,810 810,990 990,1230 1290,1620
later,| you know the the
|你知道上半部分，你知道在上半部分有一条单独的线

1299
00:39:37,890 --> 00:39:38,940
0,150 150,480 480,840 840,900 900,1050
{} top half, you know

1300
00:39:38,940 --> 00:39:40,260
0,180 180,210 210,540 540,930 930,1320
there's a separate thread in

1301
00:39:40,260 --> 00:39:41,460
0,90 90,420 420,720 720,810 810,1200
the top half| that basically
|它基本上查看该队列，然后从队列中抓取数据包，

1302
00:39:41,460 --> 00:39:42,270
0,210 210,270 270,420 420,720 720,810
looks at that queue and

1303
00:39:42,270 --> 00:39:43,290
0,120 120,450 450,780 780,900 900,1020
then grabs packets out of

1304
00:39:43,290 --> 00:39:44,280
0,90 90,300 300,390 390,690 720,990
the queue,| and then keeps
|然后继续做任何需要做的事。

1305
00:39:44,280 --> 00:39:45,180
0,90 90,240 240,660 660,840 840,900
on doing whatever needs to

1306
00:39:45,180 --> 00:39:46,100
0,90 90,390
be done.|
|

1307
00:39:46,400 --> 00:39:48,380
0,330 330,630 630,1440 1440,1800 1800,1980
Now, for simplicity a in
现在，为了简化这一简单性并减少代码量，

1308
00:39:48,380 --> 00:39:50,960
0,360 1020,1650 1650,2070 2160,2520 2520,2580
this simplicity and reduce the

1309
00:39:50,960 --> 00:39:52,250
0,180 180,240 240,690 900,1110 1110,1290
amount of code,| {} that
|这不是这些特殊的驱动程序遵循的结构，

1310
00:39:52,250 --> 00:39:53,210
0,60 60,240 240,330 330,780 780,960
is not the structure that

1311
00:39:53,210 --> 00:39:54,950
0,180 180,540 540,900 900,1410 1620,1740
these particular driver follows,| this
|这个司机可能偶尔会打来电话，

1312
00:39:54,950 --> 00:39:56,090
0,420 660,720 720,810 810,1080 1080,1140
{driver -} {} once in

1313
00:39:56,090 --> 00:39:57,230
0,60 60,480 480,690 690,900 900,1140
a while may actually call

1314
00:39:57,230 --> 00:39:58,560
0,360
up

1315
00:39:58,650 --> 00:40:00,560
0,150 150,390 390,720 720,1050
in,| call up actually
|实际上有时候这个结构是由司机遵循的，

1316
00:40:00,560 --> 00:40:02,180
0,480 480,660 660,1110 1110,1290 1290,1620
sometimes this structure is followed

1317
00:40:02,180 --> 00:40:03,560
0,120 120,210 210,660 660,930 930,1380
by the driver,| but once
|但偶尔，它实际上可以进入上半部分

1318
00:40:03,560 --> 00:40:04,310
0,60 60,330 330,390 390,510 510,750
in awhile, it can actually

1319
00:40:04,310 --> 00:40:05,690
0,180 180,510 510,600 600,930 930,1380
go into the top half|
|

1320
00:40:05,780 --> 00:40:07,070
0,180 180,300 300,660 660,960 960,1290
and come back out into
然后回到下半场。

1321
00:40:07,070 --> 00:40:08,420
0,240 270,540 540,900
the bottom half.|
|

1322
00:40:15,210 --> 00:40:16,840
0,210 210,510 510,660 660,930
Any questions about this?|
对此有什么问题吗？|

1323
00:40:23,120 --> 00:40:25,100
0,600 930,1230 1230,1500 1500,1680 1680,1980
Okay, so that's sort of
好的，我想这是某种程度上的软件并发性

1324
00:40:25,130 --> 00:40:27,500
0,120 120,480 480,960 960,1710 1800,2370
I guess software concurrency {}|
|

1325
00:40:27,500 --> 00:40:28,310
0,270 270,480 480,690 690,780 780,810
and {we'll,come} back to a
稍后我们会回到更多的话题，

1326
00:40:28,310 --> 00:40:29,180
0,150 150,360 360,660 660,780 780,870
little more later,| if we
|如果我们更详细地看一下代码。

1327
00:40:29,180 --> 00:40:30,170
0,150 150,510 510,600 600,810 810,990
look at the code in

1328
00:40:30,170 --> 00:40:31,440
0,30 30,180 180,300 300,750
a bit more detail.|
|

1329
00:40:31,440 --> 00:40:32,820
0,630 660,1020 1020,1080 1080,1290 1290,1380
{} Talk a little bit
稍微谈一下戒指的事。

1330
00:40:32,820 --> 00:40:34,100
0,180 180,270 270,750
about the rings.|
|

1331
00:40:37,540 --> 00:40:38,860
0,270 270,510 510,1110 1110,1170 1170,1320
And so basically the way
所以基本上就像你想的那样，

1332
00:40:38,860 --> 00:40:39,730
0,60 60,210 210,480 480,780 780,870
you think about it,| you
|你知道那里有铃声，

1333
00:40:39,730 --> 00:40:41,280
0,210 210,750
know there

1334
00:40:42,040 --> 00:40:45,130
0,630 840,1380 1380,1830 2310,2580 2580,3090
ring,| {} there's two rings
|有两个环，一个用于接收，一个用于发送，

1335
00:40:45,160 --> 00:40:46,390
0,120 120,450 450,570 570,1140 1140,1230
and one for receiving and

1336
00:40:46,390 --> 00:40:47,950
0,180 180,330 330,870 870,1140 1350,1560
one for sending,| {you,know} {tx
|你知道TX RX都住在RAM里。

1337
00:40:47,950 --> 00:40:50,170
0,420 420,690 690,1200 1230,1890 1890,2220
-} {rx -} both lives

1338
00:40:50,170 --> 00:40:52,420
0,630 750,1620
in RAM.|
|

1339
00:40:52,510 --> 00:40:54,400
0,690 690,810 810,930 930,1200 1200,1890
And you know they're manipulated
您知道它们是由运行在RISC-V内核上的代码操纵的

1340
00:40:54,430 --> 00:40:56,830
0,870 900,1380 1380,1680 1680,1950 1950,2400
by code running on the

1341
00:40:57,280 --> 00:40:59,590
0,570 570,810 810,1320 1320,1860 1860,2310
{RISC-V -} cores| and by
|你也知道网卡本身。

1342
00:40:59,590 --> 00:41:00,490
0,180 180,300 300,420 420,690 690,900
you know the network card

1343
00:41:00,490 --> 00:41:01,500
0,540
itself.|
|

1344
00:41:01,710 --> 00:41:02,280
0,210 210,330 330,420 420,510 510,570
So there has to be
所以网卡之间一定有某种协议

1345
00:41:02,280 --> 00:41:03,750
0,210 210,780 780,1080 1080,1140 1140,1470
some protocol between the network

1346
00:41:03,750 --> 00:41:06,420
0,420 420,1110 1620,2310 2340,2550 2550,2670
card| and {} the {RISC-V
|当然还有RISC-V，

1347
00:41:06,420 --> 00:41:08,880
0,360 360,510 510,960 990,1740 2100,2460
-} of course,| about who
|关于谁可以看什么，

1348
00:41:08,880 --> 00:41:09,780
0,210 210,270 270,480 480,540 540,900
gets to look at what,|
|

1349
00:41:10,020 --> 00:41:11,760
0,660 1020,1230 1230,1380 1380,1470 1470,1740
and {} so the way
因此，这是硬件设备中非常常见的组织方式，

1350
00:41:11,760 --> 00:41:12,870
0,210 210,330 330,420 420,810 810,1110
this is a very common

1351
00:41:12,870 --> 00:41:15,270
0,690 690,930 930,1230 1230,1860 2160,2400
organization in hardware devices {},|
|

1352
00:41:15,270 --> 00:41:16,080
0,90 90,210 210,360 360,690 690,810
the way that typically is
通常的做法是，

1353
00:41:16,080 --> 00:41:17,910
0,600 600,900 900,1050 1440,1770 1770,1830
done,| there's {sort,of}, look at
|在某种程度上，看看传输队列，

1354
00:41:17,910 --> 00:41:19,380
0,60 60,480 480,780 780,990 990,1470
the transmit queue,| there's basically
|基本上有一些固定大小的结构描述符的队列，

1355
00:41:19,380 --> 00:41:20,580
0,360 360,750 750,840 840,990 990,1200
a queue of some fixed

1356
00:41:20,580 --> 00:41:22,560
0,180 180,660 660,1350 1380,1560 1560,1980
size structures descriptors,| as we'll
|我们马上就会看到，

1357
00:41:22,560 --> 00:41:24,330
0,240 240,390 390,810 810,1230 1500,1770
looking in a second,| these
|这些是描述符。

1358
00:41:24,330 --> 00:41:25,600
0,90 90,180 180,900
are the descriptors.|
|

1359
00:41:29,360 --> 00:41:31,640
0,630 630,1080 1080,2040 2040,2220 2220,2280
And the organization or the
实际上在驱动程序和网卡之间发生的组织或协调是

1360
00:41:31,640 --> 00:41:33,320
0,630 630,750 750,870 870,1440 1440,1680
coordination that is actually a

1361
00:41:33,320 --> 00:41:37,430
0,570 570,990 990,1680 1770,2730 3090,4110
that's happening between the driver

1362
00:41:37,430 --> 00:41:39,410
0,630 660,930 930,1320 1320,1830 1830,1980
and network card is| the
|消费者与生产者的协调。

1363
00:41:39,410 --> 00:41:40,720
0,840
consumer

1364
00:41:41,750 --> 00:41:43,100
0,750
producer

1365
00:41:45,180 --> 00:41:46,720
0,960
coordination.|
|

1366
00:41:47,430 --> 00:41:48,900
0,870 870,1080 1080,1230 1230,1320 1320,1470
Basically, one way to think
基本上，可以用一种方式来考虑，

1367
00:41:48,900 --> 00:41:49,770
0,270 270,450 450,540 540,660 660,870
about it,| you know there
|你知道，如果这是传输队列，

1368
00:41:49,770 --> 00:41:51,540
0,360 690,1320 1320,1440 1440,1650 1650,1770
is a if this is

1369
00:41:51,540 --> 00:41:52,710
0,90 90,570 570,930 930,1020 1020,1170
the transmit queue,| you know
|你知道也许有个头指针，

1370
00:41:52,710 --> 00:41:53,850
0,210 210,570 570,870 870,930 930,1140
there's maybe there's a head

1371
00:41:53,850 --> 00:41:54,960
0,600
pointer,|
|

1372
00:41:56,520 --> 00:41:58,400
0,300 300,360 360,630 630,1320
there's a tail pointer,|
有一个尾部指针，|

1373
00:42:00,440 --> 00:42:02,270
0,540 540,660 660,750 750,1200 1350,1830
and you know this the
你知道，尾部指针是由软件控制的。

1374
00:42:02,420 --> 00:42:03,710
0,300 300,570 570,660 660,1140 1140,1290
tail pointer is controlled by

1375
00:42:03,710 --> 00:42:05,080
0,90 90,690
the software.|
|

1376
00:42:05,580 --> 00:42:06,570
0,210 210,330 330,510 510,810 810,990
And so the software looks
所以软件会查看尾部指针，

1377
00:42:06,570 --> 00:42:07,980
0,90 90,180 180,450 450,1020 1020,1410
at the tail pointer,| and
|如果只有一次，立即发送另一个数据包，

1378
00:42:07,980 --> 00:42:09,420
0,120 120,540 540,840 840,870 870,1440
if once in a minute,

1379
00:42:09,420 --> 00:42:11,250
0,210 210,480 480,1230 1230,1560 1560,1830
send another packet,| sticks it,
|把它贴上，你知道在尾巴加1的位置的环里

1380
00:42:11,250 --> 00:42:12,930
0,90 90,240 240,840 1170,1530 1530,1680
you know in a the

1381
00:42:12,930 --> 00:42:14,040
0,330 330,540 540,660 660,1050 1050,1110
ring at the location of

1382
00:42:14,040 --> 00:42:15,240
0,240 240,480 480,870 870,990 990,1200
tail plus one| and then
|然后向上移动尾巴指向那个方向。

1383
00:42:15,240 --> 00:42:16,800
0,360 360,780 990,1230 1230,1500 1500,1560
moves up tail pointing in

1384
00:42:16,800 --> 00:42:17,900
0,150 150,600
that direction.|
|

1385
00:42:19,240 --> 00:42:20,980
0,600 720,840 840,1110 1110,1590 1590,1740
And the head pointer is
并且头指针通常由硬件控制。

1386
00:42:20,980 --> 00:42:22,330
0,330 330,690 690,780 780,870 870,1350
usually controlled by the hardware.|
|

1387
00:42:24,750 --> 00:42:27,030
0,300 300,420 420,1050 1290,1650 1680,2280
{So,tail} by software, {head,by} hardware|
所以软件跟在后面，头跟在硬件后面|

1388
00:42:27,030 --> 00:42:28,350
0,270 270,720 720,1050 1050,1170 1170,1320
and basically the you know
基本上，你知道，硬件基本上是看头部的

1389
00:42:28,350 --> 00:42:29,490
0,90 90,510 510,900 900,1080 1080,1140
the hardware basically looks at

1390
00:42:29,490 --> 00:42:30,390
0,60 60,330 330,660 660,810 810,900
the head| and this is
|这是要发送的第一个数据包，

1391
00:42:30,390 --> 00:42:31,350
0,120 120,390 390,690 690,810 810,960
the first packet that is

1392
00:42:31,350 --> 00:42:32,190
0,120 120,180 180,300 300,630 690,840
going to be sent,| you
|你知道在描述符里有一点信息

1393
00:42:32,190 --> 00:42:33,120
0,270 270,480 480,570 570,810 810,930
know there's a little bit

1394
00:42:33,120 --> 00:42:34,530
0,90 90,600 600,690 690,780 780,1410
of information in the descriptor|
|

1395
00:42:34,680 --> 00:42:36,420
0,240 240,480 480,1050 1050,1200 1200,1740
or enough information that descriptor
或者网卡要查看的描述符足够多的信息

1396
00:42:36,570 --> 00:42:37,920
0,390 390,660 660,960 960,1260 1260,1350
for the network card to

1397
00:42:37,920 --> 00:42:38,790
0,270 270,390 390,540 540,660 660,870
look at| and say like
|然后说，哦，这是我移动到电缆所需的字节数。

1398
00:42:38,790 --> 00:42:39,840
0,270 270,450 450,540 540,660 660,1050
oh this is the bytes

1399
00:42:39,840 --> 00:42:41,370
0,150 150,300 300,540 540,930 990,1530
that I need to move

1400
00:42:41,370 --> 00:42:43,290
0,330 330,540 540,1080 1110,1680 1680,1920
on to the move {on,to}

1401
00:42:43,290 --> 00:42:44,140
0,90 90,480
the cable.|
|

1402
00:42:44,950 --> 00:42:46,540
0,300 300,480 480,720 720,1170 1260,1590
And once it's done, it
一旦完成，它就会将头指针朝那个方向移动，

1403
00:42:46,540 --> 00:42:48,070
0,360 360,480 480,720 720,1320 1350,1530
moves the head pointer in

1404
00:42:48,070 --> 00:42:50,080
0,180 180,600 720,1170 1170,1260 1260,2010
that direction,| once it's consumed,
|一旦它被使用，您就知道传输队列中的一个数据包。

1405
00:42:50,110 --> 00:42:50,860
0,150 150,210 210,450 450,570 570,750
you know one of the

1406
00:42:50,860 --> 00:42:52,330
0,360 360,510 510,630 630,990 1020,1470
packets out of the transmission

1407
00:42:52,330 --> 00:42:53,140
0,300
queue.|
|

1408
00:42:53,630 --> 00:42:54,350
0,150 150,300 300,420 420,540 540,720
And one way to think
考虑这个问题的一种方式是，这里之间，尾巴之间的所有描述符，

1409
00:42:54,350 --> 00:42:56,150
0,210 210,330 330,480 480,810 1080,1800
about it is that all

1410
00:42:56,180 --> 00:42:59,000
0,450 510,1410 1440,2280
the descriptors between

1411
00:42:59,000 --> 00:43:01,900
0,1020 1080,1590 1590,1650 1650,2400
here, between the tail,|
|

1412
00:43:02,540 --> 00:43:03,590
0,420 420,570 570,750 750,840 840,1050
and so all the things
所以实际上正在填写的所有东西，

1413
00:43:03,590 --> 00:43:04,850
0,90 90,150 150,660 660,900 900,1260
that are actually being filled

1414
00:43:04,850 --> 00:43:07,850
0,390 870,1500 1710,2310 2310,2730 2730,3000
in,| {} like details moved
|比如细节上移到了这里。

1415
00:43:07,850 --> 00:43:09,420
0,150 150,420 420,510 510,1080
up maybe to here.|
|

1416
00:43:12,540 --> 00:43:13,290
0,120 120,210 210,360 360,450 450,750
You know all the packets
您知道作为实际填充的所有描述符条目的所有分组，

1417
00:43:13,290 --> 00:43:14,910
0,150 150,360 360,570 570,840 1110,1620
that are all the descriptor

1418
00:43:14,910 --> 00:43:15,960
0,330 330,450 450,510 510,750 750,1050
entries that are actually filled

1419
00:43:15,960 --> 00:43:17,100
0,240 300,600 600,870 870,960 960,1140
in,| the way you think
|您对它们的看法是，它们属于网卡拥有的硬件。

1420
00:43:17,100 --> 00:43:18,440
0,270 270,480 480,780
about them is,

1421
00:43:18,640 --> 00:43:19,510
0,240 240,360 360,660 660,780 780,870
they are owned by the

1422
00:43:19,510 --> 00:43:20,770
0,540 540,780 780,900 900,960 960,1260
hardware owned by the network

1423
00:43:20,770 --> 00:43:21,720
0,420
card.|
|

1424
00:43:21,810 --> 00:43:22,860
0,150 150,420 420,690 690,750 750,1050
The network card is allowed
网卡被允许读取它们，用它们做事情，

1425
00:43:22,860 --> 00:43:24,600
0,90 90,300 300,870 1140,1530 1530,1740
to read them, do things

1426
00:43:24,600 --> 00:43:26,310
0,180 180,630 750,1470 1470,1650 1650,1710
with them,| {} but the
|但是软件和软件不允许对此做任何事情，

1427
00:43:26,310 --> 00:43:27,420
0,540 540,630 630,720 720,1050 1050,1110
software and the software is

1428
00:43:27,420 --> 00:43:29,220
0,360 360,690 690,870 900,1260 1260,1800
not allowed to do anything

1429
00:43:29,220 --> 00:43:31,140
0,360 540,870 870,1470 1500,1560 1560,1920
{with,that},| like if the software
|比如如果软件在这些描述符上乱涂乱画，

1430
00:43:31,140 --> 00:43:33,000
0,120 120,210 210,930 1200,1650 1650,1860
would be scribbling over these

1431
00:43:33,000 --> 00:43:36,510
0,780 1080,2700 2700,2850 2850,3330 3330,3510
descriptors,| while they really sort
|虽然它们在某种程度上是由网卡的硬件磁盘拥有的，

1432
00:43:36,510 --> 00:43:37,560
0,60 60,330 330,540 540,720 720,1050
of owned by the hardware

1433
00:43:37,560 --> 00:43:39,210
0,330 330,600 600,990 990,1320 1440,1650
disk by network card,| that
|这将改变网卡看到的数据

1434
00:43:39,210 --> 00:43:40,560
0,120 120,540 540,660 660,1020 1020,1350
would change the data that

1435
00:43:40,560 --> 00:43:42,360
0,540 570,900 900,1140 1140,1680 1680,1800
the network card sees| and
|这将是非常不受欢迎的。

1436
00:43:42,360 --> 00:43:43,800
0,150 150,300 300,510 510,780 780,1440
that would be pretty undesirable.|
|

1437
00:43:44,460 --> 00:43:46,500
0,750 990,1170 1170,1590 1710,1920 1920,2040
{} And so, {} the
所以，协议基本上是

1438
00:43:46,500 --> 00:43:48,450
0,360 360,840 840,1050 1050,1470 1470,1950
protocol basically is that| {like,once}
|就像一旦你知道软件将尾部指针向上移动了一个，

1439
00:43:48,450 --> 00:43:49,560
0,90 90,180 180,300 300,690 690,1110
you know the software moves

1440
00:43:49,560 --> 00:43:50,880
0,90 90,390 390,720 720,960 960,1320
the tail pointer one up,|
|

1441
00:43:51,060 --> 00:43:52,830
0,750 870,1020 1020,1080 1080,1290 1290,1770
then you know that point
则您知道您刚刚移动到传输队列中的网络队列中的点

1442
00:43:52,860 --> 00:43:54,270
0,210 210,420 420,660 660,990 990,1410
you have just moved into

1443
00:43:54,270 --> 00:43:55,320
0,120 120,510 510,870 870,960 960,1050
the network queue in the

1444
00:43:55,320 --> 00:43:56,760
0,420 420,780 810,990 990,1200 1200,1440
transmission queue| is now owned
|现在归硬件所有

1445
00:43:56,760 --> 00:43:57,990
0,120 120,210 210,690 1020,1170 1170,1230
by the hardware| and it
|它会一直存在，你知道它将归硬件所有，直到它必须被发送出去

1446
00:43:57,990 --> 00:43:59,280
0,120 120,630 660,960 960,1050 1050,1290
will stick in you know

1447
00:43:59,280 --> 00:44:00,480
0,120 120,360 360,570 570,1080 1080,1200
it will be owned by

1448
00:44:00,480 --> 00:44:02,400
0,90 90,630 660,1470 1500,1770 1770,1920
the hardware until it has

1449
00:44:02,400 --> 00:44:03,930
0,60 60,180 180,690 810,1140 1140,1530
to be sent| and basically
|基本上，直到头指针移过，你才知道那个特定的结构。

1450
00:44:03,930 --> 00:44:05,460
0,390 390,480 480,720 720,1020 1020,1530
until the head pointer moves

1451
00:44:05,460 --> 00:44:06,720
0,540 540,600 600,690 690,930 930,1260
past you know that particular

1452
00:44:06,720 --> 00:44:07,540
0,420
structure.|
|

1453
00:44:09,890 --> 00:44:11,320
0,180 180,300 300,420 420,870
Does that make sense?|
这说得通吗？|

1454
00:44:18,950 --> 00:44:20,540
0,300 300,480 480,990 990,1380 1380,1590
Good, for transmission, basically it's
很好，对于传输来说，基本上都是一样的故事，

1455
00:44:20,540 --> 00:44:21,650
0,120 120,330 330,840 870,990 990,1110
the same story,| you know
|你知道，有一个头指针，基本上是由硬件控制的

1456
00:44:21,650 --> 00:44:23,600
0,330 330,810 1200,1650 1650,1770 1770,1950
there's a there's a head

1457
00:44:23,600 --> 00:44:24,740
0,630
pointer

1458
00:44:24,880 --> 00:44:27,160
0,660 690,960 960,1710
{} that basically

1459
00:44:28,610 --> 00:44:30,740
0,360 360,1020 1020,1200 1200,1350 1350,2130
that's controlled by the hardware|
|

1460
00:44:30,770 --> 00:44:32,150
0,210 210,480 480,570 570,840 840,1380
and there's a tail pointer
这里有一个尾部指针，由它控制，还有一个软件指针，

1461
00:44:32,150 --> 00:44:33,820
0,180 180,270 270,720 720,1110
that is controlled by,

1462
00:44:33,850 --> 00:44:35,800
0,540 540,750 750,1050 1140,1620 1620,1950
there is the software pointer,|
|

1463
00:44:35,800 --> 00:44:37,220
0,690

1464
00:44:37,340 --> 00:44:38,900
0,420 420,810 810,900 900,1410 1410,1560
and basically the packets in
基本上，介于两者之间的数据包实际上是硬件已接收到的数据包

1465
00:44:38,900 --> 00:44:40,280
0,810
between

1466
00:44:40,840 --> 00:44:42,640
0,540 540,750 750,1110 1110,1200 1200,1800
are are packets are actually

1467
00:44:42,640 --> 00:44:45,700
0,180 180,180
{ -

1468
00:44:45,760 --> 00:44:47,140
0,210 210,360 360,510 510,1260 1260,1380
-} have been received by

1469
00:44:47,140 --> 00:44:50,000
0,60 60,780 780,1290 1680,2340
the hardware| and {
|你知道，通过期待尾部指针

1470
00:44:50,410 --> 00:44:51,850
0,480 480,870 870,990 990,1140 1140,1440
-} and you know by

1471
00:44:52,060 --> 00:44:53,200
0,480 480,570 570,780 780,1050 1050,1140
expecting the tail pointer| and
|该软件可以查看是否真的有新的数据包，您知道该数据包已经准备好可以使用了

1472
00:44:53,200 --> 00:44:54,070
0,60 60,390 390,480 480,750 750,870
the software can see if

1473
00:44:54,070 --> 00:44:55,180
0,180 180,450 450,480 480,690 690,1110
there's actually a new packet,

1474
00:44:55,180 --> 00:44:55,960
0,120 120,240 240,420 420,510 510,780
you know that is ready

1475
00:44:55,960 --> 00:44:58,390
0,180 180,570 960,1890 1890,2220 2220,2430
to be consumed| and {if,it's}
|如果它已准备好可以使用，硬件将通过在状态字段中声明该DD位来指示这一点。

1476
00:44:58,390 --> 00:44:59,500
0,210 210,330 330,420 420,1050 1050,1110
ready to be consumed, the

1477
00:44:59,500 --> 00:45:00,910
0,240 240,330 330,780 780,1140 1140,1410
hardware will indicate that by

1478
00:45:00,910 --> 00:45:02,110
0,240 240,420 420,810 810,1050 1050,1200
saying that DD bit in

1479
00:45:02,110 --> 00:45:03,380
0,60 60,450 450,840
the status field.|
|

1480
00:45:03,440 --> 00:45:04,760
0,180 180,300 300,510 510,750 750,1320
And so when the {DD,bit}
因此当设置DD位时，硬件和软件都是好的，

1481
00:45:04,760 --> 00:45:06,470
0,150 150,450 510,960 960,1530 1530,1710
is set, hardware software are

1482
00:45:06,470 --> 00:45:07,730
0,270 300,390 390,600 600,810 810,1260
good,| you know these packets,
|你知道这些数据包，你知道硬件已经完成了，

1483
00:45:07,730 --> 00:45:08,570
0,90 90,330 330,480 480,780 780,840
you know the hardware is

1484
00:45:08,570 --> 00:45:10,220
0,240 240,420 420,630 960,1470 1470,1650
done with it,| and so
|所以它可以把它拿出来，把尾部指针向上移动一个。

1485
00:45:10,220 --> 00:45:11,420
0,210 210,420 420,690 690,810 810,1200
it can take it out

1486
00:45:11,600 --> 00:45:12,680
0,210 210,480 480,540 540,780 780,1080
and move the tail pointer

1487
00:45:12,680 --> 00:45:13,720
0,240 240,540
one up.|
|

1488
00:45:14,920 --> 00:45:15,760
0,180 180,420 420,600 600,750 750,840
And so there's sort of
因此，在驱动程序和我们的硬件之间存在某种程度上的取舍

1489
00:45:15,760 --> 00:45:18,190
0,240 240,420 420,510 510,1200 1500,2430
this give and take between

1490
00:45:18,220 --> 00:45:21,700
0,810 1230,1980 1980,2550 2550,2730 2730,3480
{} driver and our hardware|
|

1491
00:45:21,730 --> 00:45:24,040
0,150 150,390 390,1230 1230,2040 2070,2310
to actually coordinate they don't
为了真正协调它们不会被对方绊倒。

1492
00:45:24,040 --> 00:45:25,420
0,180 180,480 480,600 600,840
trip over each other.|
|

1493
00:45:27,340 --> 00:45:29,080
0,210 210,540 540,810 810,1170
Any questions about the
关于戒指有什么问题吗？

1494
00:45:31,270 --> 00:45:32,380
0,570
rings?|
|

1495
00:45:34,850 --> 00:45:36,200
0,780

1496
00:45:36,200 --> 00:45:37,280
0,120 120,330 330,720 780,930 930,1080
Is this like, is this
这是不是像这样，这是不是一种普遍的实现方式

1497
00:45:37,280 --> 00:45:39,100
0,240 240,1230
a universal

1498
00:45:39,100 --> 00:45:40,760
0,330 330,480 480,750 750,1110
way to kind of

1499
00:45:41,000 --> 00:45:42,800
0,390 390,810 810,1080 1080,1650 1650,1800
{} implement| like user or
|例如用户或具有共享内存的两个事物之间的任何类型的通信。

1500
00:45:42,800 --> 00:45:44,240
0,210 210,360 360,450 450,1050 1050,1440
any kind of communication between

1501
00:45:44,240 --> 00:45:45,260
0,150 150,420 420,540 540,780 780,1020
two things that have shared

1502
00:45:45,260 --> 00:45:46,240
0,420
memory.|
|

1503
00:45:46,270 --> 00:45:47,650
0,360 360,510 510,600 600,960 960,1380
Yeah it's a pretty {}
是的，这当然也是在软件领域，你看这个，

1504
00:45:47,650 --> 00:45:48,790
0,330 330,570 570,750 750,1050 1050,1140
certainly also in software, you

1505
00:45:48,790 --> 00:45:50,410
0,150 150,300 300,720 810,1260 1260,1620
see this,| but many hardware
|但是很多硬件设备玩了点小把戏，

1506
00:45:50,410 --> 00:45:51,460
0,450 450,720 720,810 810,990 990,1050
devices played {} sort of

1507
00:45:51,460 --> 00:45:52,420
0,420
trick,|
|

1508
00:45:52,510 --> 00:45:56,200
0,810 810,1890 1950,2220 2220,2850 3180,3690
{} we're going to {producer
我们将在硬件和软件之间进行生产者和消费者风格的协调。

1509
00:45:56,200 --> 00:45:59,080
0,60 60,420 420,1050 1080,1950 2160,2880
-} consumer style {} coordination

1510
00:45:59,080 --> 00:46:00,250
0,240 240,300 300,570 570,690 690,1170
between the hardware and software.|
|

1511
00:46:05,350 --> 00:46:06,340
0,150 150,330 330,540 540,780 780,990
So yeah, they're very common
所以，是的，它们是非常常见的结构。

1512
00:46:06,340 --> 00:46:07,380
0,480
structure.|
|

1513
00:46:08,430 --> 00:46:09,660
0,300 300,480 480,540 540,630 630,1230
Maybe one or two questions,
也许有一两个问题，你可以问一下，

1514
00:46:09,690 --> 00:46:11,040
0,630 690,780 780,930 930,1140 1140,1350
{} you can ask about

1515
00:46:11,040 --> 00:46:12,420
0,210 420,570 570,990 990,1200 1200,1380
it,| like why is there
|比如为什么真的会有排队，为什么会有戒指。

1516
00:46:12,420 --> 00:46:13,620
0,210 210,360 360,420 420,810 840,1200
actually even a queue, why

1517
00:46:13,620 --> 00:46:14,820
0,90 90,240 240,330 330,660
is there a ring.|
|

1518
00:46:14,910 --> 00:46:16,020
0,360 480,600 600,810 810,990 990,1110
Okay, the reason there's a
好的，之所以有一枚戒指是正确的，

1519
00:46:16,020 --> 00:46:17,220
0,390 390,570 570,660 660,870 870,1200
{ring,correct},| because the queue wraps
|因为队列缠绕，队列缠绕以使其大小固定，

1520
00:46:17,220 --> 00:46:19,440
0,450 660,930 930,1170 1170,1620 1650,2220
around, queue wraps around to

1521
00:46:19,470 --> 00:46:21,140
0,210 210,300 300,540 540,780
make it fix size,|
|

1522
00:46:21,590 --> 00:46:22,970
0,360 360,540 540,660 660,840 840,1380
{but,you,know}, why, why not, {}
但是你知道，为什么，为什么不，你知道，让排队一个条目，一个条目，

1523
00:46:23,570 --> 00:46:25,220
0,210 210,390 390,810 810,1260 1380,1650
{you,know} have {queue,one} entry, one

1524
00:46:25,220 --> 00:46:26,320
0,510
entry,|
|

1525
00:46:27,900 --> 00:46:29,190
0,240 240,570 570,690 690,750 750,1290
{like,it's} almost like the UART,|
就像是UART一样，|

1526
00:46:29,550 --> 00:46:30,510
0,210 210,510 510,600 600,780 780,960
you remember the {UART -
您还记得UART驱动程序和控制器基本上只有一个寄存器发送一个字节

1527
00:46:30,510 --> 00:46:32,550
0,150 150,150 810,1350 1350,1440 1440,2040
-} {} driver and controller

1528
00:46:32,550 --> 00:46:34,020
0,150 150,540 540,720 720,930 930,1470
is basically only one register

1529
00:46:34,500 --> 00:46:35,790
0,300 300,570 570,660 660,1170 1170,1290
to send a byte| and
|另一个寄存器接收一个字节。

1530
00:46:35,790 --> 00:46:36,870
0,150 150,390 390,750 750,1050 1050,1080
there's another register receive a

1531
00:46:36,870 --> 00:46:37,720
0,360
byte.|
|

1532
00:46:38,880 --> 00:46:41,190
0,360 360,510 510,1170 1170,1890 1920,2310
And so why have, why
那么，为什么，为什么要选择这个复杂的计划，

1533
00:46:41,190 --> 00:46:42,450
0,120 120,240 240,360 360,870 870,1260
go for this complicated scheme,|
|

1534
00:46:42,450 --> 00:46:43,530
0,300 300,450 450,750 750,1020 1020,1080
you could have yourself a
你可以让你自己有一个单一的登记簿

1535
00:46:43,530 --> 00:46:44,550
0,270 270,720 720,810 810,900 900,1020
single register| and then you
|然后你基本上可以说你知道硬件，这个寄存器现在已经准备好了，发送它，

1536
00:46:44,550 --> 00:46:45,870
0,180 180,510 510,810 810,900 900,1320
can basically say you know

1537
00:46:46,410 --> 00:46:47,850
0,630 630,840 840,1200 1200,1260 1260,1440
hardware, this register is now

1538
00:46:47,850 --> 00:46:49,240
0,300 300,600 600,840
ready, send it,|
|

1539
00:46:49,390 --> 00:46:50,860
0,390 390,510 510,720 720,990 990,1470
and then {you,just} wait until
然后你就等这件事办完了。

1540
00:46:50,860 --> 00:46:51,960
0,540
the

1541
00:46:51,960 --> 00:46:52,980
0,540
{it's,done}.|
|

1542
00:46:55,300 --> 00:46:57,400
0,240 240,690 690,1260 1320,1920 1920,2100
To allow for when there
以允许在有分组突发时使用。

1543
00:46:57,400 --> 00:47:00,480
0,150 150,720 720,1320 1650,2550
are bursts of packets.|
|

1544
00:47:00,480 --> 00:47:01,420
0,450
Yeah,
是啊，就是这样，

1545
00:47:01,780 --> 00:47:03,400
0,240 240,750 1080,1320 1320,1410 1410,1620
yeah exactly,| you know the
|您知道网卡或电缆性能相当高的网络接口，

1546
00:47:03,400 --> 00:47:05,290
0,570 600,1170 1170,1320 1320,1380 1380,1890
network interface where the network

1547
00:47:05,290 --> 00:47:07,150
0,780 780,870 870,1320 1320,1590 1590,1860
card or cable is pretty

1548
00:47:07,150 --> 00:47:08,470
0,150 150,600 600,930 930,1170 1170,1320
high performance,| {in,fact} very high
|事实上，性能非常高，每秒千兆位。

1549
00:47:08,470 --> 00:47:11,160
0,510 780,1530 1590,1710 1710,2160
performance, gigabits per second.|
|

1550
00:47:11,310 --> 00:47:13,680
0,690 690,1170 1410,1680 1680,2250 2250,2370
And so, {} it can
因此，这对内核来说可能很困难，处理器实际上跟上了它，

1551
00:47:13,680 --> 00:47:14,910
0,90 90,360 360,510 510,720 720,1230
be hard for the core,

1552
00:47:14,910 --> 00:47:15,960
0,90 90,540 540,750 750,930 930,1050
the processors actually keep up

1553
00:47:15,960 --> 00:47:16,920
0,120 120,300 330,540 540,660 660,960
with it,| so you would
|所以你想给它一大堆包裹，

1554
00:47:16,920 --> 00:47:17,670
0,210 210,300 300,480 480,630 630,750
like to give it a

1555
00:47:17,670 --> 00:47:18,750
0,210 210,450 450,510 510,990 990,1080
whole bunch of packets,| you
|您知道网络或网络卡块

1556
00:47:18,750 --> 00:47:19,800
0,150 150,240 240,570 570,660 660,1050
know the networks or network

1557
00:47:19,800 --> 00:47:21,300
0,360 510,870 870,1230 1230,1320 1320,1500
card chunk along| and I'll
|我会把他们高速送出去。

1558
00:47:21,300 --> 00:47:22,230
0,210 210,330 330,660 660,750 750,930
send them out at high

1559
00:47:22,230 --> 00:47:23,220
0,510
speed.|
|

1560
00:47:23,280 --> 00:47:24,480
0,150 150,720 720,840 840,990 990,1200
And similarly you know in
类似地，你知道在接收过程中，你可能会收到一连串的信息包进来

1561
00:47:24,480 --> 00:47:25,410
0,450 450,570 570,720 720,900 900,930
reception you might get a

1562
00:47:25,410 --> 00:47:26,880
0,420 420,510 510,870 870,1110 1110,1470
burst of packets coming in|
|

1563
00:47:27,270 --> 00:47:28,650
0,810 810,930 930,1080 1080,1140 1140,1380
and you want to place
你想把它们放在队列里

1564
00:47:28,650 --> 00:47:29,550
0,120 120,240 240,300 300,720 720,900
them in the queue| and
|然后操作系统就可以开始处理队列了，对吧。

1565
00:47:29,550 --> 00:47:30,960
0,570 570,630 630,990 990,1290 1290,1410
then the operating system can

1566
00:47:30,960 --> 00:47:32,740
0,390 390,900 900,990 990,1290
start processing the queue,

1567
00:47:33,290 --> 00:47:34,260
0,420
right.|
|

1568
00:47:35,090 --> 00:47:36,170
0,300 300,390 390,570 570,630 630,1080
And so this is a
所以这是一种常见的，

1569
00:47:36,200 --> 00:47:37,320
0,630
common,|
|

1570
00:47:39,270 --> 00:47:40,440
0,600 600,720 720,780 780,1050 1050,1170
this is the reason that
这就是这些队列通常用于处理突发的原因。

1571
00:47:40,440 --> 00:47:42,000
0,150 150,450 450,540 540,960
these queues are common

1572
00:47:43,930 --> 00:47:45,580
0,270 270,540 540,1080
to handle bursts.|
|

1573
00:47:48,910 --> 00:47:49,900
0,150 150,390 390,510 510,600 600,990
What happens if the {queue,is}
如果队列已经满了怎么办，比如接待处。

1574
00:47:49,900 --> 00:47:52,360
0,390 930,1260 1260,1800
full, like reception.|
|

1575
00:47:58,950 --> 00:48:02,070
0,210 210,570 570,1140 1380,2160 2220,3120
I think the the document
我想文件提到它做了某种形式的拖尾计划。

1576
00:48:02,070 --> 00:48:03,390
0,420 420,540 540,780 810,1110 1110,1320
mentioned that it does some

1577
00:48:03,390 --> 00:48:05,040
0,270 270,420 420,720 750,1140 1140,1650
form of {} drop tail

1578
00:48:05,100 --> 00:48:06,360
0,690
scheme.|
|

1579
00:48:06,810 --> 00:48:09,480
0,1770 1770,1890 1890,2220 2220,2580 2580,2670
Yeah, there yeah basically the
是的，在那里，是的，基本上数据包会被丢弃。

1580
00:48:09,480 --> 00:48:10,820
0,240 240,360 360,810
packets get dropped.|
|

1581
00:48:11,170 --> 00:48:13,420
0,210 210,780 810,1410 1410,1830 1830,2250
So any future incoming packets,
因此，如果队列已满，则任何未来传入的数据包，

1582
00:48:13,420 --> 00:48:14,710
0,90 90,150 150,420 420,690 690,1290
if the {queue,is} full,| the
|否则环里就没有地方了，

1583
00:48:14,740 --> 00:48:16,180
0,390 390,840 870,1050 1050,1200 1200,1440
packets or there's no room

1584
00:48:16,180 --> 00:48:17,500
0,390 390,480 480,600 600,1050 1050,1320
anymore in the ring,| the
|网卡不能对该正确数据执行任何操作，

1585
00:48:17,500 --> 00:48:18,760
0,270 270,540 540,750 750,900 900,1260
network card can't do anything

1586
00:48:18,760 --> 00:48:19,780
0,270 270,630 630,750 750,900 900,1020
{with,that} correct,| and so the
|所以它实际上唯一能做的就是删除数据包

1587
00:48:19,780 --> 00:48:21,340
0,270 270,600 600,780 780,1140 1140,1560
only option it actually has

1588
00:48:21,340 --> 00:48:22,360
0,270 270,540
to {}

1589
00:48:22,360 --> 00:48:24,280
0,540 570,960 960,1020 1020,1470 1500,1920
basically delete the packet| or
|或者没有添加到环中，因此消失。

1590
00:48:24,740 --> 00:48:25,700
0,270 270,540 540,630 630,720 720,960
not added to the ring

1591
00:48:25,700 --> 00:48:27,440
0,180 180,540 540,1230
and therefore disappears.|
|

1592
00:48:27,890 --> 00:48:28,850
0,240 240,510 510,750 750,810 810,960
So, one reason to have
所以，有时丢包的一个原因是，

1593
00:48:28,850 --> 00:48:30,560
0,360 360,660 660,1140 1140,1410 1410,1710
packet loss, sometimes is that,|
|

1594
00:48:31,170 --> 00:48:32,970
0,810 810,1110 1110,1440 1440,1710 1710,1800
{} and operating system is
并且操作系统过载，

1595
00:48:32,970 --> 00:48:34,680
0,690 720,840 840,1020 1020,1350 1440,1710
overloaded,| you know {with,packet} can't
|你知道，包裹跟不上了，环被填满了

1596
00:48:34,680 --> 00:48:35,730
0,180 180,570 570,720 720,810 810,1050
keep up and the ring

1597
00:48:35,730 --> 00:48:37,410
0,600 810,990 990,1440 1470,1560 1560,1680
fills| and then you know
|然后您就知道数据包会被丢弃。

1598
00:48:37,410 --> 00:48:39,160
0,360 450,720 720,870 870,1260
the packets get dropped.|
|

1599
00:48:41,110 --> 00:48:42,220
0,210 210,450 450,630 630,1020 1020,1110
{You,know} higher level software, of
您知道，更高级的软件，当然可能像TCP连接可能会重新传输这些数据包，

1600
00:48:42,220 --> 00:48:43,600
0,270 270,540 540,720 720,780 780,1380
course maybe like {} TCP

1601
00:48:43,600 --> 00:48:46,300
0,450 450,750 780,1140 1140,1710 1740,2700
connection might {re-transmit - -}

1602
00:48:46,300 --> 00:48:47,770
0,0 0,540 810,1320 1320,1410 1410,1470
those packets,| but this is
|但这也是数据包可能被丢弃的原因之一。

1603
00:48:47,770 --> 00:48:49,180
0,300 300,630 630,990 990,1290 1290,1410
one reason why packets can

1604
00:48:49,180 --> 00:48:50,120
0,120 120,480
get dropped.|
|

1605
00:48:52,730 --> 00:48:53,630
0,180 180,480 480,570 570,630 630,900
So even if the hardware
所以即使硬件运行得很好，

1606
00:48:53,630 --> 00:48:55,430
0,150 150,210 210,450 450,960 1350,1800
sort of works all perfectly

1607
00:48:55,430 --> 00:48:56,810
0,600 720,930 930,1050 1050,1320 1320,1380
fine,| you know because of
|您知道，由于这些突发事件，[]部分可能会被删除。

1608
00:48:56,810 --> 00:48:58,010
0,180 180,690 690,1020 1020,1110 1110,1200
these {bursts -} you know

1609
00:48:58,010 --> 00:48:58,940
0,90 90,270 270,600 600,690 690,930
it can happen that []

1610
00:48:58,940 --> 00:49:00,320
0,300 300,450 450,570 570,930
section might get dropped.|
|

1611
00:49:01,240 --> 00:49:02,080
0,210 210,330 330,450 450,570 570,840
So you had a really
所以你有一个非常非常大的爆裂。

1612
00:49:02,080 --> 00:49:03,440
0,270 270,450 450,840
really big burst.|
|

1613
00:49:07,010 --> 00:49:08,900
0,300 330,510 510,990 990,1440 1470,1890
{} The head and {}
头指针和尾指针，它们都是队列的软件抽象。

1614
00:49:08,930 --> 00:49:10,970
0,540 540,1080 1080,1350 1350,1530 1530,2040
tail pointers, they're all software

1615
00:49:10,970 --> 00:49:12,560
0,690 690,960 1020,1140 1140,1230 1230,1590
abstractions, right, of the queue.|
|

1616
00:49:13,160 --> 00:49:14,900
0,630 630,870 870,1050 1050,1620 1620,1740
{} Okay, so these are
好的，这些实际上是这些控制寄存器，

1617
00:49:14,900 --> 00:49:15,950
0,270 270,510 510,660 660,840 840,1050
actually turns out that those

1618
00:49:15,950 --> 00:49:17,930
0,510 510,720 720,990 990,1380 1380,1980
are {} these control registers

1619
00:49:18,050 --> 00:49:19,460
0,270 270,390 390,690 690,1080 1080,1410
right,| so there's a control
|所以有一个用于硬件的控制寄存器，即头指针，

1620
00:49:19,460 --> 00:49:21,650
0,390 390,660 660,1020 1200,1590 1620,2190
register for the hardware {the,header

1621
00:49:21,650 --> 00:49:22,730
0,240 240,630 630,720 720,750 750,1080
-} pointer is,| a control
|用于基本尾部指针的控制寄存器，

1622
00:49:22,730 --> 00:49:25,220
0,420 420,690 690,990 1380,2280 2310,2490
register for the basically the

1623
00:49:25,220 --> 00:49:26,690
0,360 360,750 840,1140 1140,1290 1290,1470
tail pointers,| there's no real
|硬件和软件之间没有真正的区别，

1624
00:49:26,690 --> 00:49:28,010
0,420 420,630 630,930 930,1200 1200,1320
distinction between hardware {software -},|
|

1625
00:49:28,010 --> 00:49:29,450
0,450 450,570 570,960 960,1230 1230,1440
basically the driver knows about
基本上司机知道尾部指针，

1626
00:49:29,450 --> 00:49:30,320
0,60 60,300 300,660 660,780 780,870
the tail pointer,| and it
|并且它知道硬件知道尾指针和头指针

1627
00:49:30,320 --> 00:49:31,400
0,180 180,600 600,690 690,930 930,1080
knows about the hardware knows

1628
00:49:31,400 --> 00:49:32,820
0,240 240,300 300,540 540,1020
about the tail pointer

1629
00:49:32,820 --> 00:49:35,820
0,1440 1890,2130 2130,2670 2700,2880 2880,3000
and header pointer| and use
|并使用基本的控制寄存器。

1630
00:49:35,820 --> 00:49:37,600
0,60 60,300 300,690 690,1230
a basic control registers.|
|

1631
00:49:37,720 --> 00:49:39,610
0,690 1350,1530 1530,1620 1620,1830 1830,1890
{Okay,yeah}.| It will soon the
好的好的。|它很快就会在几秒钟内生成代码，这些代码是如何出现的，

1632
00:49:39,610 --> 00:49:40,720
0,300 300,690 690,840 840,1020 1020,1110
{code,in} seconds, how did the

1633
00:49:40,720 --> 00:49:41,820
0,540
{shows,up},|
|

1634
00:49:42,810 --> 00:49:43,620
0,210 210,330 330,420 420,510 510,810
make sure you go back
一定要回到我们的，

1635
00:49:43,620 --> 00:49:46,560
0,180 180,660 990,1950 2040,2730 2760,2940
to our,| {} maybe let's
|也许让我们看看这张照片还在这里

1636
00:49:46,560 --> 00:49:48,420
0,270 660,870 870,1140 1140,1320 1320,1860
see this picture still here,|
|

1637
00:49:48,840 --> 00:49:50,670
0,660 660,930 1020,1410 1410,1740 1740,1830
here's that earlier picture we
这是我们之前看过的那张照片

1638
00:49:50,670 --> 00:49:52,140
0,240 240,540 870,1290 1290,1380 1380,1470
looked at| and you know
|你知道，这是一个控制寄存器，用来控制头部，

1639
00:49:52,140 --> 00:49:54,240
0,690 720,1200 1200,1620 1620,1770 1770,2100
here's control register that holds

1640
00:49:54,240 --> 00:49:56,040
0,120 120,420 540,1080 1080,1470 1470,1800
the head,| here control register
|这里是保持尾部的控制寄存器

1641
00:49:56,040 --> 00:49:57,300
0,90 90,390 390,480 480,1020 1020,1260
that holds the tail| and
|当然还有一个是接待的，一个是送的。

1642
00:49:57,300 --> 00:49:58,410
0,300 300,510 510,630 630,900 900,1110
of course there's one for

1643
00:49:58,410 --> 00:49:59,790
0,270 270,720 720,840 840,1020 1020,1380
both reception and one for

1644
00:50:00,030 --> 00:50:00,880
0,450
sending.|
|

1645
00:50:04,300 --> 00:50:05,380
0,630
Okay?|
好吧?|

1646
00:50:08,810 --> 00:50:10,800
0,660 660,780 780,990 990,1470
Let's go back here.|
我们回到这里吧。|

1647
00:50:11,290 --> 00:50:12,790
0,300 300,870 930,1320 1320,1470 1470,1500
Okay, so let's talk a
好的，我们来谈谈描述符。

1648
00:50:12,790 --> 00:50:14,140
0,210 210,330 330,540 540,600 600,1350
little bit about the descriptors.|
|

1649
00:50:15,250 --> 00:50:17,260
0,390 390,600 600,1110 1440,1950 1950,2010
And so the descriptors are
因此描述符由硬件定义

1650
00:50:17,260 --> 00:50:19,060
0,330 330,420 420,510 510,1050 1470,1800
defined by the hardware| and
|所以硬件说这就是经文应该是什么样子，

1651
00:50:19,060 --> 00:50:20,350
0,150 150,360 360,810 810,1080 1080,1290
so the hardware says like

1652
00:50:20,350 --> 00:50:21,730
0,420 420,810 810,900 900,1200 1200,1380
here's how the scriptures should

1653
00:50:21,730 --> 00:50:23,110
0,150 150,510 510,810 810,990 990,1380
look like,| and you {driver
|而你的司机，你知道，这些是部分，你可以填上

1654
00:50:23,110 --> 00:50:24,670
0,270 300,420 420,780 1140,1470 1470,1560
-} you know these are

1655
00:50:24,670 --> 00:50:25,450
0,90 90,360 360,450 450,540 540,780
the bits, you can fill

1656
00:50:25,450 --> 00:50:26,170
0,210 210,360 360,420 420,510 510,720
in| and if you fill
|如果你填上告诉我跟着做的那一小段，好的。

1657
00:50:26,170 --> 00:50:27,460
0,90 90,300 300,660 720,990 990,1290
in that bit that tells

1658
00:50:27,460 --> 00:50:29,160
0,120 120,360 360,840 1110,1470
me to follow, right.|
|

1659
00:50:29,270 --> 00:50:30,960
0,240 240,360 360,690 690,1110
And so here's the
所以这里有两个描述符很重要，

1660
00:50:30,960 --> 00:50:32,940
0,210 210,870 870,1410
{} two {}

1661
00:50:33,090 --> 00:50:34,620
0,510 510,600 600,1260 1290,1410 1410,1530
descriptors are important,| you know,
|您知道，这是接收描述符RX

1662
00:50:34,620 --> 00:50:35,960
0,330 330,750
here's the

1663
00:50:37,380 --> 00:50:39,100
0,480 480,1170
receive descriptor

1664
00:50:39,680 --> 00:50:40,730
0,300 300,480 480,600 600,870 870,1050
{rx -}| and here's a
|这是一个TX，其中一个TX描述符。

1665
00:50:40,730 --> 00:50:42,080
0,540 540,780 780,900 900,990 990,1350
tx, one of the tx

1666
00:50:42,080 --> 00:50:43,260
0,600
descriptors.|
|

1667
00:50:43,380 --> 00:50:44,100
0,210 210,330 330,540 540,660 660,720
And so let's look a
所以让我们稍微看一下。

1668
00:50:44,100 --> 00:50:46,540
0,240 240,570 600,1860
little bit {}.|
|

1669
00:50:46,600 --> 00:50:48,370
0,630 630,840 840,870 870,1230 1230,1770
Yeah it's a little bit,|
是啊，是有点，|

1670
00:50:48,820 --> 00:50:51,190
0,570 930,1410 1410,1500 1500,1830 1830,2370
{} probably the most important
可能最重要的部分是这个地址，

1671
00:50:51,190 --> 00:50:53,440
0,270 270,450 450,1080 1110,1800
part is this address,|
|

1672
00:50:53,530 --> 00:50:54,820
0,450 450,660 660,960 960,1170 1170,1290
{} and that is the
这就是软件填写的地址

1673
00:50:54,820 --> 00:50:56,320
0,390 390,630 630,840 840,1230 1230,1500
address that the software filled

1674
00:50:56,320 --> 00:50:57,850
0,240 240,360 360,660 660,1380 1380,1530
in| to say where they
|为了说明它们应该将分组转储到哪里的硬件，

1675
00:50:57,850 --> 00:50:59,200
0,330 360,660 660,870 870,1170 1170,1350
should where the hardware to

1676
00:50:59,200 --> 00:51:01,510
0,450 720,810 810,1170 1290,1800 1800,2310
dump the packet,| {where,in} {RAM,to
|在RAM到驱动程序的什么地方，网卡应该把接收到的数据放到RAM的什么地方，

1677
00:51:01,540 --> 00:51:05,380
0,420 420,420 1470,2160 2430,3150 3390,3840
-} {} the driver, where

1678
00:51:05,380 --> 00:51:06,400
0,150 150,240 240,510 510,810 810,1020
should the network card put

1679
00:51:06,400 --> 00:51:08,380
0,540 570,930 930,1140 1140,1320 1320,1980
the data that is received

1680
00:51:08,380 --> 00:51:09,670
0,390 390,720 840,1080 1080,1170 1170,1290
into RAM,| so it's the
|因此，如果您愿意的话，它是接收缓冲区的地址。

1681
00:51:09,670 --> 00:51:11,860
0,480 480,840 840,1170 1320,1860 1860,2190
address of the reception buffer,

1682
00:51:11,860 --> 00:51:12,840
0,120 120,210 210,600
if you will.|
|

1683
00:51:13,690 --> 00:51:14,920
0,690

1684
00:51:17,080 --> 00:51:18,010
0,150 150,450 450,540 540,690 690,930
And then you know probably
然后你知道可能最重要的部分是

1685
00:51:18,010 --> 00:51:19,720
0,60 60,240 240,570 570,1080 1080,1710
the most important part {}

1686
00:51:19,720 --> 00:51:22,270
0,780 840,1680 1680,2010 2010,2160 2160,2550
in| {} is the status
|是您已经看到的Status字段。

1687
00:51:22,270 --> 00:51:24,020
0,360 360,540 540,720 720,1200
field as you've seen.|
|

1688
00:51:24,020 --> 00:51:25,970
0,570 570,750 750,1080 1080,1470 1500,1950
{} So when the driver
所以当司机基本上还在继续看尾巴的时候

1689
00:51:25,970 --> 00:51:27,260
0,360 360,690 690,1080 1080,1140 1140,1290
basically still continues to look

1690
00:51:27,260 --> 00:51:28,370
0,150 150,240 240,330 330,420 420,1110
sort of at the tail|
|

1691
00:51:28,430 --> 00:51:29,150
0,150 150,390 390,510 510,660 660,720
and sees that there's a
并且看到收到了一个新的数据包

1692
00:51:29,150 --> 00:51:31,460
0,210 210,630 1260,1530 1530,1740 1740,2310
new packet has been received|
|

1693
00:51:31,670 --> 00:51:32,750
0,270 270,360 360,630 630,750 750,1080
and the way it tells
它判断是否接收到新数据包的方式是

1694
00:51:32,750 --> 00:51:33,620
0,210 210,330 330,480 480,810 810,870
whether a new packet {}

1695
00:51:33,620 --> 00:51:35,390
0,420 420,870 1050,1320 1320,1560 1560,1770
received is| is that the
|DD位是否正确，

1696
00:51:35,390 --> 00:51:37,550
0,450 450,810 810,1260 1290,1650 1650,2160
DD bit correct,| is set
|由硬件设置。

1697
00:51:37,980 --> 00:51:39,980
0,420 420,690 690,900 900,1470
{} by the hardware.|
|

1698
00:51:40,540 --> 00:51:41,860
0,360 360,900 900,990 990,1110 1110,1320
{} And you know the
您知道阴影区域是数据包描述符的字段，

1699
00:51:41,860 --> 00:51:45,010
0,390 390,1050 1500,1980 1980,2400 2610,3150
shaded areas are the fields

1700
00:51:45,010 --> 00:51:46,810
0,90 90,270 270,660 660,1230 1230,1800
of the packet descriptor of

1701
00:51:46,810 --> 00:51:47,860
0,480
the,|
|

1702
00:51:47,920 --> 00:51:49,870
0,690 840,1170 1170,1230 1230,1650 1650,1950
{} receive {} descriptor actually
接收描述符实际上是硬件填写的

1703
00:51:49,870 --> 00:51:51,370
0,60 60,390 390,660 660,1020 1140,1500
the hardware fills in| and
|白色，你知道，未加阴影的是由软件填入的实际加阴影的字段，

1704
00:51:51,370 --> 00:51:52,330
0,60 60,570 600,750 750,840 840,960
the white you know the

1705
00:51:52,330 --> 00:51:53,800
0,450 720,1080 1080,1290 1290,1380 1380,1470
non shaded ones are the

1706
00:51:53,800 --> 00:51:55,120
0,330 330,420 420,690 690,1050 1050,1320
fields that actually shaded in

1707
00:51:55,120 --> 00:51:56,380
0,330 330,570 570,690 690,900 900,1260
are filled in by the

1708
00:51:56,380 --> 00:51:58,060
0,480 720,1260 1260,1440 1440,1560 1560,1680
software,| again here we see
|同样，我们在这里看到了软件所拥有的某些东西的明显区别，

1709
00:51:58,060 --> 00:52:00,220
0,150 150,420 420,990 990,1410 1620,2160
this clear distinction about somethings

1710
00:52:00,220 --> 00:52:01,240
0,90 90,300 300,480 480,690 690,1020
are owned by {software -},|
|

1711
00:52:01,270 --> 00:52:04,090
0,540 540,840 840,1140 1140,1710 2040,2820
somethings are owned by {}
有些东西归硬件所有。

1712
00:52:04,790 --> 00:52:06,220
0,360 360,450 450,900
by the hardware.|
|

1713
00:52:08,760 --> 00:52:10,650
0,300 300,420 420,1080 1080,1230 1230,1890
Okay, and there's a similar
好的，还有一个类似的描述符，非常简单的描述符，

1714
00:52:10,680 --> 00:52:13,290
0,90 90,600 630,1800 1830,2340 2340,2610
you know {} descriptor, {}

1715
00:52:13,290 --> 00:52:14,760
0,180 180,450 450,840 840,1020 1020,1470
very simple descriptor that looks,|
|

1716
00:52:15,150 --> 00:52:16,350
0,630 630,870 870,930 930,1080 1080,1200
{} that's a {hardware -}
这是传输的硬件描述符，

1717
00:52:16,350 --> 00:52:18,480
0,300 300,510 510,930 960,1710 1950,2130
descriptor for the transmission,| it
|它有一个地址，这个地址当然是数据在内存中的地址，需要发送。

1718
00:52:18,480 --> 00:52:20,730
0,600 600,810 810,1440 1500,1680 1680,2250
has an address, the address

1719
00:52:20,730 --> 00:52:22,170
0,60 60,330 330,480 480,810 930,1440
of course is the address

1720
00:52:22,170 --> 00:52:23,940
0,660 660,780 780,1140 1140,1560 1560,1770
where the data is in

1721
00:52:23,940 --> 00:52:25,050
0,510 510,720 720,900 900,1020 1020,1110
memory, that needs to be

1722
00:52:25,050 --> 00:52:26,000
0,540
sent.|
|

1723
00:52:26,000 --> 00:52:26,540
0,120 120,240 240,330 330,510 510,540
And then it has a
然后它有一个预算和一个命令字段。

1724
00:52:26,540 --> 00:52:28,460
0,750 750,930 930,960 960,1380 1380,1920
budget has a command field.|
|

1725
00:52:29,160 --> 00:52:30,540
0,480 480,840 840,990 990,1080 1080,1380
And here's how the software
这是软件告诉司机告诉网卡的方式，

1726
00:52:30,540 --> 00:52:31,950
0,360 360,450 450,1080 1080,1350 1350,1410
tells the driver tells the

1727
00:52:31,950 --> 00:52:33,120
0,330 330,660 720,960 960,1020 1020,1170
network card,| this is what
|这就是您应该对此特定包执行的操作

1728
00:52:33,120 --> 00:52:34,020
0,120 120,240 240,510 510,750 750,900
you should do with this

1729
00:52:34,020 --> 00:52:35,460
0,360 360,720 720,1050 1050,1260 1260,1440
particular packet| or {you,know} this
|或者你知道，这就是你应该知道的关于这个特殊包裹的信息。

1730
00:52:35,460 --> 00:52:36,330
0,60 60,210 210,300 300,480 480,870
is what you should know

1731
00:52:36,330 --> 00:52:37,960
0,240 240,360 360,690 690,1140
about this particular packet.|
|

1732
00:52:38,290 --> 00:52:40,420
0,420 600,810 810,990 990,1470 1710,2130
And so one thing, yeah
所以有一件事，是的，我们，我想我们感觉到了两条路，两件我们填满的东西

1733
00:52:40,420 --> 00:52:41,230
0,270 270,360 360,540 540,630 630,810
we I think we feeling

1734
00:52:41,230 --> 00:52:42,490
0,270 270,690 690,870 870,1140 1140,1260
two path, two things we

1735
00:52:42,490 --> 00:52:44,770
0,420 450,780 780,1440 1470,1920 1920,2280
filled| a EOP says {you,know}
|EOP说您知道数据包的末尾

1736
00:52:44,770 --> 00:52:46,750
0,540 720,960 960,1020 1020,1560 1860,1980
the end of packet| and
|这基本上告诉驱动程序，这是特定包的最后一个描述符

1737
00:52:46,750 --> 00:52:48,160
0,120 120,450 450,690 690,750 750,1410
that basically tells the driver,

1738
00:52:48,310 --> 00:52:50,050
0,270 270,420 420,540 540,990 990,1740
this is the last descriptor

1739
00:52:50,230 --> 00:52:51,970
0,390 390,480 480,840 840,1320 1320,1740
of a particular packet| and
|现在你知道了吗，不管这些描述符里有什么数据，你都知道。

1740
00:52:51,970 --> 00:52:53,500
0,270 270,780 780,870 870,1140 1170,1530
now can you know send

1741
00:52:53,500 --> 00:52:54,940
0,420 450,540 540,720 720,1140 1140,1440
off you know whatever data

1742
00:52:54,940 --> 00:52:56,520
0,210 210,300 300,480 480,1140
that's in these descriptors.|
|

1743
00:52:56,900 --> 00:52:58,850
0,720 720,1500 1500,1560 1560,1770 1770,1950
{} And I think we
我认为我们将响应设置为请求命令位

1744
00:52:58,850 --> 00:53:00,320
0,330 330,900
set the

1745
00:53:02,110 --> 00:53:05,830
0,810 810,960 960,1890 1950,2850 3270,3720
response {you,know} requested {} command

1746
00:53:05,830 --> 00:53:09,850
0,390 660,1350 1350,2130 2130,2340 3060,4020
bit| or {RS,I,think,it} is {},|
|或者RS我想是的|

1747
00:53:09,880 --> 00:53:11,980
0,720 720,990 990,1260 1260,1650 1680,2100
basically tells network card when
基本上就是告诉网卡你做完了，

1748
00:53:11,980 --> 00:53:14,530
0,150 150,690 930,1950 1950,2130 2130,2550
you're done,| transmitting this thing
|传输这个东西，你知道设置，设置它实际传输的比特。

1749
00:53:14,680 --> 00:53:16,600
0,240 240,540 570,1080 1080,1350 1350,1920
you know {} set the,

1750
00:53:18,740 --> 00:53:19,520
0,180 180,270 270,570 570,690 690,780
set the bit that it

1751
00:53:19,520 --> 00:53:21,160
0,210 210,360 360,480 480,1080
actually has been transmitted.|
|

1752
00:53:21,430 --> 00:53:22,450
0,210 210,390 390,510 510,810 810,1020
We'll see you second how
我们会教你怎么换衣服。

1753
00:53:22,450 --> 00:53:24,220
0,510 510,660 660,870 870,1200
how to change up.|
|

1754
00:53:25,570 --> 00:53:26,880
0,210 210,780
Any questions?|
有什么问题吗？|

1755
00:53:32,230 --> 00:53:33,370
0,180 180,450 450,630 630,1080 1080,1140
So one one thing to
所以有一件事要牢记在心，你知道，对于这些结构，

1756
00:53:33,370 --> 00:53:34,600
0,180 180,240 240,720 990,1110 1110,1230
keep in mind, you know

1757
00:53:34,600 --> 00:53:35,680
0,120 120,300 300,750 780,990 990,1080
with these structures,| these are
|这些都是由硬件定义的，就像硬件一样，软件不能控制它们的结构，

1758
00:53:35,680 --> 00:53:37,180
0,300 300,390 390,450 450,930 960,1500
defined by the hardware, like

1759
00:53:37,180 --> 00:53:38,920
0,540 540,840 840,930 930,1320 1320,1740
hardware, software has no control

1760
00:53:38,920 --> 00:53:40,210
0,150 150,270 270,1050 1050,1170 1170,1290
over their structure,| you know
|你知道，这是由硬件和网卡逐字定义的。

1761
00:53:40,210 --> 00:53:42,040
0,270 270,570 720,1230 1230,1680 1680,1830
there's just literally defined by

1762
00:53:42,040 --> 00:53:43,480
0,90 90,480 810,1140 1140,1200 1200,1440
the hardware, by the network

1763
00:53:43,480 --> 00:53:44,240
0,300
card.|
|

1764
00:53:44,860 --> 00:53:46,210
0,540 810,1080 1080,1230 1230,1290 1290,1350
Okay, let's look at a
好的，让我们看一小段代码

1765
00:53:46,210 --> 00:53:48,670
0,180 180,270 270,360 360,840 1260,2460
little bit of code| and
|看看解决方案是什么样子

1766
00:53:48,700 --> 00:53:50,290
0,450 450,990 990,1080 1080,1380 1380,1590
see what the solution looks

1767
00:53:50,290 --> 00:53:51,310
0,300 300,660 660,780 780,930 930,1020
like| and we'll look at
|我们将看几个我们还没有看过的问题，你知道mbuf。

1768
00:53:51,310 --> 00:53:52,570
0,60 60,450 450,810 840,1140 1140,1260
a couple of issues that

1769
00:53:52,570 --> 00:53:53,920
0,120 120,300 300,540 540,1050 1110,1350
we haven't looked at yet,

1770
00:53:53,920 --> 00:53:55,000
0,150 150,660
{you,know,the,mbufs -}.|
|

1771
00:53:55,060 --> 00:53:57,370
0,360 360,660 990,1440 1440,2040 2070,2310
{ -} issues if during
传输过程中的问题和接收过程中的问题。

1772
00:53:57,370 --> 00:53:59,020
0,480 480,630 630,960 960,1230 1230,1650
transmission and issues during receiving.|
|

1773
00:54:00,600 --> 00:54:01,590
0,120 120,240 240,390 390,660 660,990
And this would be presumably
你们大概都很熟悉这一点，

1774
00:54:01,590 --> 00:54:02,820
0,210 210,420 420,810 810,1110 1110,1230
all well familiar with to

1775
00:54:02,820 --> 00:54:03,870
0,270 270,540 540,720 720,960 960,1050
you,| given the fact that
|考虑到你刚刚完成实验室的事实。

1776
00:54:03,870 --> 00:54:05,250
0,240 600,810 810,1110 1110,1140 1140,1380
you just finished the lab.|
|

1777
00:54:07,220 --> 00:54:08,480
0,660

1778
00:54:08,880 --> 00:54:10,560
0,210 210,330 330,1020 1020,1230 1230,1680
Okay, so here, just to
好的，那么这里，为了达到顶端，这是传送环。

1779
00:54:10,560 --> 00:54:13,140
0,720 750,1020 1020,1110 1110,1950 1950,2580
go to the top, here's

1780
00:54:13,140 --> 00:54:14,580
0,60 60,510 510,870
the transmit ring.|
|

1781
00:54:15,040 --> 00:54:17,530
0,600 600,990 1080,1290 1290,1920 1920,2490
Yeah, and that's basically the
是的，这基本上就是描述符环，

1782
00:54:17,560 --> 00:54:19,300
0,300 300,390 390,1020 1020,1350 1350,1740
ring of descriptors,| {you,know} we
|你知道我们在最后几张幻灯片中抽签了。

1783
00:54:19,330 --> 00:54:20,650
0,300 300,660 660,750 750,840 840,1320
drew off in the last

1784
00:54:20,650 --> 00:54:22,640
0,690 690,780 780,1350
couple of slides.|
|

1785
00:54:22,670 --> 00:54:24,050
0,240 240,300 300,870 930,1170 1170,1380
There's a separate, we talked
有一个单独的，我们简要地谈过这个，

1786
00:54:24,050 --> 00:54:25,070
0,360 360,630 630,780 780,990 990,1020
briefly about this,| there's a
|基本上有一个独立的mbuf环，

1787
00:54:25,070 --> 00:54:27,590
0,600 630,1320 1440,2130 2130,2370 2370,2520
separate {} basically ring of

1788
00:54:27,590 --> 00:54:29,780
0,690 930,1500 1500,1710 1710,2040 2040,2190
mbufs,| but in that ring
|但在这个环中，你完全知道软件或驱动程序只是抽象硬件，

1789
00:54:29,780 --> 00:54:31,130
0,120 120,840 840,960 960,1110 1110,1350
is completely you know a

1790
00:54:31,130 --> 00:54:34,190
0,900 900,1110 1110,1560 1560,2160 2160,3060
software or driver only abstraction

1791
00:54:34,550 --> 00:54:37,970
0,1110 1140,2610 2760,3000 3000,3090 3090,3420
{} hardware,| this is defined
|这个是这个结构定义的，是硬件定义的，对，

1792
00:54:37,970 --> 00:54:40,160
0,120 120,600 600,1500 1740,1890 1890,2190
by this structure is defined

1793
00:54:40,160 --> 00:54:41,140
0,90 90,150 150,570
by the hardware,

1794
00:54:41,760 --> 00:54:42,600
0,330 330,420 420,540 540,600 600,840
right,| and if you look
|如果你看一下。

1795
00:54:42,600 --> 00:54:43,480
0,270
at.|
|

1796
00:54:43,480 --> 00:54:44,480
0,480
Oops.|
哎呀。|

1797
00:54:54,960 --> 00:54:56,320
0,240 240,450 450,810

1798
00:55:02,990 --> 00:55:04,760
0,150 150,480 480,570 570,1110 1140,1770
{You,know} look at the definitions,|
你知道，看看定义，|

1799
00:55:04,760 --> 00:55:06,740
0,180 180,450 450,1020 1020,1470 1470,1980
but here's struct {tx_desc -},|
但是这里是struct tx_desc，|

1800
00:55:06,860 --> 00:55:08,360
0,240 240,810 810,1020 1110,1200 1200,1500
that corresponds to the C
这正好对应于硬件实际定义的结构的C版本，

1801
00:55:08,360 --> 00:55:10,310
0,510 510,660 660,1350 1350,1440 1440,1950
version of exactly the structure

1802
00:55:10,310 --> 00:55:11,270
0,210 210,420 420,540 540,870 870,960
that actually was defined by

1803
00:55:11,270 --> 00:55:12,830
0,60 60,480 510,600 600,750 840,1560
the hardware,| you know 64
|你知道64位地址，

1804
00:55:12,830 --> 00:55:14,420
0,300 660,1260 1260,1380 1380,1500 1500,1590
bit address,| you know the
|您知道LENGTH字段、CSO、BYTE、CMD字节、STATUS字节、CSS字节，然后是表示特殊的TO字。

1805
00:55:14,420 --> 00:55:15,950
0,240 240,480 480,570 570,780 780,1530
length field, the {cso -},

1806
00:55:16,400 --> 00:55:17,480
0,240 240,390 390,570 570,780 780,1080
byte the {cmd -} byte,

1807
00:55:17,480 --> 00:55:18,980
0,90 90,420 420,870 870,960 960,1500
the status byte, the css

1808
00:55:18,980 --> 00:55:21,200
0,420 420,570 570,1170 1200,1650 1650,2220
byte, and then to word

1809
00:55:21,200 --> 00:55:22,300
0,120 120,540
for special.|
|

1810
00:55:22,590 --> 00:55:23,520
0,150 150,300 300,330 330,690 690,930
And there's a similar ring
还有一个类似的环，它是由硬件字面上定义的，

1811
00:55:23,520 --> 00:55:24,780
0,420 420,540 540,870 870,1170 1170,1260
that is literally defined by

1812
00:55:24,780 --> 00:55:25,840
0,90 90,540
the hardware,|
|

1813
00:55:25,840 --> 00:55:27,400
0,120 120,390 390,870 870,1170 1170,1560
or similar descriptors received descriptor
或类似的描述符接收到的描述符，如由硬件定义的

1814
00:55:27,400 --> 00:55:28,540
0,120 120,420 420,510 510,990 990,1140
as defined by hardware| and
|并且那些区域已经看到与这些硬件结构相对应的装饰。

1815
00:55:28,540 --> 00:55:30,370
0,180 180,450 450,570 570,960 960,1830
those regions have see decorations

1816
00:55:30,490 --> 00:55:32,560
0,960 960,1080 1080,1230 1230,1530 1530,2070
corresponding to these hardware structures.|
|

1817
00:55:34,970 --> 00:55:36,230
0,270 270,390 390,540 540,630 630,1260
Alright, let's look at transmit.|
好的，让我们来看一下传输。|

1818
00:55:37,780 --> 00:55:39,850
0,630 630,870 870,1770 1770,1860 1860,2070
{} So here's the sort
因此，这是一种用于传输的员工解决方案，

1819
00:55:39,850 --> 00:55:41,650
0,60 60,660 660,1050 1050,1170 1170,1800
of staff solution for transmit,|
|

1820
00:55:42,390 --> 00:55:44,670
0,600 960,1410 1410,1470 1470,1980 2010,2280
{you,know} acquires a lock| and
你知道获得了一把锁|我们之前说的需要锁的原因是

1821
00:55:44,670 --> 00:55:45,840
0,60 60,360 360,660 660,810 810,1170
the reason we said before

1822
00:55:45,840 --> 00:55:46,920
0,210 210,510 510,750 750,840 840,1080
that needed lock is| because
|因为有多个函数或多个线程，内核威胁可能会同时调用Transmit。

1823
00:55:46,920 --> 00:55:48,570
0,450 450,900 900,990 990,1380 1380,1650
multiple functions or multiple threads,

1824
00:55:48,570 --> 00:55:50,730
0,270 270,540 540,810 810,1410 1770,2160
kernel threats might call {}

1825
00:55:50,730 --> 00:55:51,900
0,390 390,450 450,510 510,720 720,1170
transmit at the same time.|
|

1826
00:55:53,460 --> 00:55:54,420
0,150 150,540 540,690 690,870 870,960
And then it looks at
然后它看着尾巴，

1827
00:55:54,420 --> 00:55:55,710
0,60 60,690 900,1050 1050,1170 1170,1290
the tail,| you know to
|你知道，看看房间里有没有能真正发送新包裹的人，

1828
00:55:55,710 --> 00:55:57,660
0,270 270,390 390,630 630,1170 1170,1950
see if there's any, {}

1829
00:55:58,300 --> 00:55:59,350
0,150 150,240 240,630 630,750 750,1050
in the room to actually

1830
00:55:59,350 --> 00:56:01,420
0,360 360,570 570,1380 1410,1770 1770,2070
sent a new packet,| because
|因为你知道网卡落后了

1831
00:56:01,420 --> 00:56:02,980
0,90 90,240 240,540 900,1350 1350,1560
you know the network card

1832
00:56:02,980 --> 00:56:05,380
0,330 330,900 900,1620 1620,1920 1920,2400
got behind| and all the
|并且所有的描述符实际上都在使用中。

1833
00:56:05,410 --> 00:56:07,390
0,420 420,840 840,1050 1050,1470 1470,1980
descriptors actually are {be,in} used.|
|

1834
00:56:08,170 --> 00:56:08,770
0,180 180,270 270,330 330,450 450,600
And so the way it
所以它检查的方式是，你实际上是这里的描述符区域，

1835
00:56:08,770 --> 00:56:10,840
0,510 960,1320 1320,1560 1560,1770 1770,2070
checks, {} where you're actually

1836
00:56:10,840 --> 00:56:13,390
0,240 240,690 690,1260 1260,1650 2040,2550
the descriptor region {} here's,|
|

1837
00:56:13,390 --> 00:56:15,760
0,1050 1080,1410 1410,1770 1770,1920 1920,2370
by checking whether the DD
通过检查是否未设置DD位。

1838
00:56:15,760 --> 00:56:18,440
0,390 630,1140 1140,1830
bit {} is

1839
00:56:18,440 --> 00:56:19,620
0,300 300,600
not set.|
|

1840
00:56:20,120 --> 00:56:21,890
0,540 540,720 720,900 900,1200 1500,1770
{} And if it is
如果是这样的话，

1841
00:56:21,890 --> 00:56:23,420
0,960
then,|
|

1842
00:56:25,410 --> 00:56:27,030
0,270 270,420 420,690 690,990 1020,1620
if it's not set then
如果没有设置，则它立即返回，根本不发送数据包，

1843
00:56:27,270 --> 00:56:29,760
0,210 210,420 420,1140 1170,1950 1950,2490
{} it returns {} immediately,

1844
00:56:29,760 --> 00:56:30,750
0,300 300,540 540,600 600,900 900,990
not sending the packet at

1845
00:56:30,750 --> 00:56:31,980
0,420 600,750 750,870 870,990 990,1230
all,| and in any other
|在任何其他情况下，这种情况都会持续下去，

1846
00:56:31,980 --> 00:56:33,660
0,540 540,930 930,1110 1110,1350 1350,1680
case, gonna it keeps on,|
|

1847
00:56:33,660 --> 00:56:34,860
0,300 300,420 420,660 660,840 840,1200
going and actually will send
实际上会发送mbuf。

1848
00:56:34,860 --> 00:56:36,040
0,210 210,690
the mbuf.|
|

1849
00:56:39,760 --> 00:56:40,780
0,210 210,390 390,690 690,900 900,1020
So if there's still an
因此，如果tx_mbufs中的此位置仍有mbuf，

1850
00:56:40,780 --> 00:56:42,460
0,210 210,720 870,1050 1050,1230 1230,1680
{mbuf -} in this position

1851
00:56:42,460 --> 00:56:43,750
0,150 150,480 480,810 810,1140 1140,1290
in the {tx_mbufs -},| and
|在，这是一段时间以前的mbuf，你知道免费的mbuf，

1852
00:56:43,750 --> 00:56:45,010
0,540 540,690 690,780 780,930 930,1260
in, this is an mbuf

1853
00:56:45,010 --> 00:56:46,600
0,90 90,420 420,810 840,1260 1260,1590
for {a,while} back {you,know} free

1854
00:56:46,600 --> 00:56:47,680
0,210 210,330 330,660 660,960 960,1080
that {mbuf -},| because we're
|因为我们实际上要把mbuf插入到这个描述符中，

1855
00:56:47,680 --> 00:56:48,550
0,120 120,180 180,480 480,750 750,870
going to actually stick in

1856
00:56:48,550 --> 00:56:50,080
0,120 120,450 450,840 870,1350 1350,1530
an {mbuf -} into this

1857
00:56:50,080 --> 00:56:51,670
0,720 1020,1200 1200,1380 1380,1530 1530,1590
descriptor,| we just need to
|我们只需要记住你知道的，但是如果我们停留在那个描述符

1858
00:56:51,670 --> 00:56:52,900
0,450 450,840 840,960 960,1050 1050,1230
remember which you know {mbuf

1859
00:56:52,900 --> 00:56:53,800
0,270 270,360 360,600 600,690 690,900
-} we stop in that

1860
00:56:53,800 --> 00:56:55,480
0,690 810,960 960,1230 1230,1380 1380,1680
descriptor| and so the way
|我们做到这一点的方法是将其保存在tx_mbuf中。

1861
00:56:55,480 --> 00:56:56,230
0,120 120,210 210,510 510,600 600,750
we do that is by

1862
00:56:56,230 --> 00:56:57,670
0,270 270,510 510,780 780,1170 1230,1440
keeping that in the {tx_mbufs

1863
00:56:57,670 --> 00:56:58,860
0,750
-}.|
|

1864
00:56:59,820 --> 00:57:00,600
0,210 210,390 390,480 480,690 690,780
And then we fill in
然后我们填写描述符，

1865
00:57:00,600 --> 00:57:03,030
0,60 60,630 900,1500 1860,2280 2280,2430
the descriptor,| and {} so
|所以我们要填满的第一样东西是头部

1866
00:57:03,030 --> 00:57:03,870
0,60 60,270 270,420 420,510 510,840
the first thing we'll filling

1867
00:57:03,870 --> 00:57:04,830
0,120 120,240 240,660 660,810 810,960
is the head| and we
|然后我们填入，我们把地址放入mbuf中第一个头的开始，

1868
00:57:04,830 --> 00:57:06,450
0,420 420,990 1020,1260 1260,1440 1440,1620
fill in, {} we put

1869
00:57:06,450 --> 00:57:09,540
0,60 60,210 210,810 900,1860 2220,3090
in the address the start

1870
00:57:09,570 --> 00:57:11,310
0,270 270,630 630,960 960,1500 1530,1740
of the first header in

1871
00:57:11,310 --> 00:57:12,400
0,120 120,660
the mbuf,|
|

1872
00:57:13,470 --> 00:57:15,100
0,300 300,480 480,570 570,1170
then, put the length,|
然后，把长度，|

1873
00:57:15,220 --> 00:57:17,350
0,420 420,660 660,810 810,1800 1890,2130
step state is zero,| put
阶跃状态为零，|在我们讨论第二个时，通过发送RS和EOP位来放置命令字段。

1874
00:57:17,350 --> 00:57:18,730
0,180 180,540 540,810 810,900 900,1380
the command field in place

1875
00:57:18,730 --> 00:57:20,980
0,330 330,570 570,900 900,1620 1950,2250
by sending both RS and

1876
00:57:20,980 --> 00:57:22,240
0,120 120,600 600,930 930,1080 1080,1260
the EOP bit as we

1877
00:57:22,240 --> 00:57:23,760
0,390 390,480 480,960
discuss the second.|
|

1878
00:57:23,760 --> 00:57:26,540
0,930 1380,2250
And, {}
然后，基本上你会被同步，以确保实际上没有重新排序，

1879
00:57:26,540 --> 00:57:27,740
0,150 150,300 300,960 960,1080 1080,1200
and then basically you'll be

1880
00:57:27,740 --> 00:57:28,910
0,600 600,690 690,870 870,1080 1080,1170
synchronized to make {actually -}

1881
00:57:28,910 --> 00:57:30,860
0,210 210,510 510,690 690,1380 1380,1950
sure there's no reordering of,|
|

1882
00:57:30,890 --> 00:57:32,600
0,150 150,240 240,480 480,1050 1440,1710
you know that all these
您知道，所有这些指令都是在下一条指令之前执行的。

1883
00:57:32,600 --> 00:57:34,340
0,540 540,630 630,1260 1290,1680 1680,1740
instructions are performed before the

1884
00:57:34,340 --> 00:57:35,800
0,300 300,960
next instruction.|
|

1885
00:57:36,140 --> 00:57:37,070
0,150 150,270 270,330 330,540 540,930
And what the next instruction
以及它的下一条指令实际执行什么操作来更新尾部指针

1886
00:57:37,070 --> 00:57:38,240
0,240 240,360 360,570 570,1080 1080,1170
does it actually updates the

1887
00:57:38,240 --> 00:57:39,710
0,270 270,690 840,1080 1080,1350 1350,1470
tail pointer| and so the
|因此[采用者]更新尾部指针

1888
00:57:39,710 --> 00:57:41,330
0,540 540,870 870,1110 1110,1320 1320,1620
[adoptive] updates the tail pointer|
|

1889
00:57:41,330 --> 00:57:42,290
0,90 90,180 180,420 420,660 660,960
and the tail point correct
且尾点正确为网卡中的控制寄存器，

1890
00:57:42,290 --> 00:57:43,340
0,510
is

1891
00:57:43,340 --> 00:57:45,050
0,420 420,990 1020,1290 1290,1380 1380,1710
{a,control} register in the network

1892
00:57:45,050 --> 00:57:46,850
0,420 840,1050 1050,1170 1170,1530 1530,1800
card,| and so basically when
|所以基本上当我们更新尾部指针时，

1893
00:57:46,850 --> 00:57:48,200
0,120 120,450 450,540 540,810 810,1350
we update the tail pointer,|
|

1894
00:57:48,290 --> 00:57:50,510
0,210 210,720 720,1080 1110,1800 1830,2220
the {network,card} knows aha something
网卡知道发生了什么变化

1895
00:57:50,510 --> 00:57:52,130
0,660 960,1140 1140,1230 1230,1380 1380,1620
changed| and it's going to
|它将读取该描述符处的数据

1896
00:57:52,130 --> 00:57:54,470
0,570 630,750 750,930 930,1680 1770,2340
read you know the data

1897
00:57:54,470 --> 00:57:57,620
0,570 570,990 990,1710 1950,2610 2610,3150
at that descriptor| {} and
|它将基本上读取我们刚刚填写的这些字段，

1898
00:57:57,620 --> 00:57:58,550
0,150 150,270 270,330 330,630 630,930
it's going to basically read

1899
00:57:58,550 --> 00:58:00,020
0,150 150,570 570,900 900,1200 1200,1470
these fields, we've just filled

1900
00:58:00,020 --> 00:58:01,100
0,180 330,540 540,630 630,780 780,1080
in,| so we're gonna basically
|所以我们基本上要绝对确保，所有这些写入，所有的存储都在内存中实现，

1901
00:58:01,100 --> 00:58:02,880
0,240 240,660 660,1080 1080,1350
make absolutely sure that,

1902
00:58:02,880 --> 00:58:04,410
0,210 210,720 750,1290 1290,1410 1410,1530
all these writes, all the

1903
00:58:04,410 --> 00:58:06,750
0,570 660,1140 1140,1740 1740,1800 1800,2340
stores are materialized in memory,|
|

1904
00:58:06,780 --> 00:58:08,880
0,870 870,990 990,1320 1320,1590 1590,2100
before the network card actually
在网卡实际读取它们之前

1905
00:58:08,910 --> 00:58:10,080
0,360 360,720 720,900 900,1020 1020,1170
reads them| and so this
|这就是为什么那里有同步同步的原因。

1906
00:58:10,080 --> 00:58:11,250
0,60 60,300 300,390 390,660 660,1170
is why the {__sync_synchronize -}

1907
00:58:11,250 --> 00:58:12,000
0,270
there.|
|

1908
00:58:13,760 --> 00:58:14,540
0,120 120,240 240,330 330,570 570,780
And then we release about
然后我们释放一把锁

1909
00:58:14,540 --> 00:58:15,410
0,60 60,360 360,450 450,570 570,870
a lock| and that's basically
|这基本上就是我们传输数据包所要做的全部工作。

1910
00:58:15,410 --> 00:58:16,100
0,120 120,210 210,330 330,420 420,690
all we have to do

1911
00:58:16,190 --> 00:58:17,760
0,150 150,570 570,600 600,1050
to transmit a packet.|
|

1912
00:58:20,790 --> 00:58:21,960
0,180 180,270 270,660 660,780 780,1170
Can you explain the {__sync_synchronize
你能再解释一下同步同步吗，比如。

1913
00:58:21,960 --> 00:58:24,380
0,930 990,1440 1470,1860
-} again, like

1914
00:58:24,380 --> 00:58:25,240
0,420
what.|
|

1915
00:58:25,270 --> 00:58:28,870
0,1170 1950,2250 2250,2610 2610,2970 2970,3600
Yeah, it's mostly memory ordering
是的，基本上是技术上的内存排序是正确的，

1916
00:58:28,960 --> 00:58:30,850
0,810 810,1200 1200,1620 1620,1710 1710,1890
technicality correct,| compilers are free
|编译器可以自由地重新排序指令，

1917
00:58:30,850 --> 00:58:32,660
0,120 120,450 450,1290
to reorder instructions,|
|

1918
00:58:32,660 --> 00:58:35,180
0,570 570,1380 1500,2100 2100,2310 2310,2520
{} the writes might actually
写入实际上可能位于L1缓存或L2缓存中

1919
00:58:35,180 --> 00:58:36,980
0,240 240,360 360,1290 1380,1560 1560,1800
sit in the {L1 -}

1920
00:58:36,980 --> 00:58:37,970
0,390 390,480 480,600 600,780 780,990
cache or the {L2 -

1921
00:58:37,970 --> 00:58:40,340
0,180 180,750 1110,1560 1560,1890 1890,2370
-} cache| and sync basically
|基本上同步同步的记忆围栏

1922
00:58:40,340 --> 00:58:41,390
0,180 180,690 690,810 810,990 990,1050
the synchronize {} sort of

1923
00:58:41,390 --> 00:58:43,460
0,90 90,420 420,990 1290,1770 1770,2070
{} memory fence| {} that
|这会告诉硬件和编译器，请不要在此屏障上移动任何指令，

1924
00:58:43,460 --> 00:58:45,260
0,420 420,480 480,960 960,1170 1170,1800
tells the hardware and compiler,

1925
00:58:45,350 --> 00:58:47,510
0,660 690,990 990,1350 1350,1620 1620,2160
please don't move any instructions

1926
00:58:47,510 --> 00:58:49,300
0,420 420,570 570,1170
across this barrier,|
|

1927
00:58:49,630 --> 00:58:51,250
0,630 630,840 840,1170 1170,1380 1380,1620
and make sure that all
并确保你所知道的所有屏障之前的所有商店的所有数据实际上都是在内存中实现的。

1928
00:58:51,250 --> 00:58:52,720
0,90 90,420 420,810 810,930 930,1470
the data that you know

1929
00:58:52,720 --> 00:58:54,100
0,150 150,240 240,810 810,1260 1260,1380
all the stores before this

1930
00:58:54,100 --> 00:58:56,560
0,540 630,900 900,1350 1350,1800 1800,2460
barrier are actually actually materialized

1931
00:58:56,560 --> 00:58:57,560
0,90 90,540
in RAM.|
|

1932
00:58:58,700 --> 00:58:59,360
0,150 150,210 210,420 420,570 570,660
And the reason that is
重要的原因是，

1933
00:58:59,360 --> 00:59:01,820
0,510 510,630 630,1110 1230,1680 2040,2460
important is,| because the, go
|因为，刚才回到我们的照片，

1934
00:59:01,820 --> 00:59:03,320
0,270 270,390 390,840 900,1380 1380,1500
back to our picture for

1935
00:59:03,320 --> 00:59:04,840
0,60 60,270 270,510 510,1020
a little while ago,|
|

1936
00:59:05,380 --> 00:59:08,900
0,1410 1440,1500 1530,2370 2370,3000
all the way back
一路回到这里。

1937
00:59:09,460 --> 00:59:10,540
0,600
here.|
|

1938
00:59:10,710 --> 00:59:12,240
0,180 180,480 540,1290 1290,1380 1380,1530
Make sure both you know
请确保您知道运行驱动程序代码的RISC-V内核基本上都将此处的值放在正确的四舍五入中，

1939
00:59:12,240 --> 00:59:13,800
0,360 360,600 600,900 900,1350 1350,1560
the {RISC-V -} cores that

1940
00:59:13,800 --> 00:59:15,570
0,150 150,450 450,810 810,1170 1200,1770
run the driver code basically

1941
00:59:15,570 --> 00:59:16,590
0,210 210,660 660,720 720,900 900,1020
put values {} here in

1942
00:59:16,590 --> 00:59:18,360
0,300 330,570 570,780 1050,1380 1380,1770
round right,| but {you,know} {those,values,are}
|但你知道这些价值观正在逆转，

1943
00:59:18,360 --> 00:59:19,680
0,480 480,570 570,750 750,990 990,1320
reversing,| the {L1 -} cache
|L1高速缓存和L2高速缓存以及存储器刷新并确保它们实际出现在RAM中，

1944
00:59:19,680 --> 00:59:21,270
0,120 120,450 450,990 1350,1530 1530,1590
and L2 cache and the

1945
00:59:21,270 --> 00:59:22,770
0,330 330,630 630,810 810,1380 1380,1500
memory flush and ensures that

1946
00:59:22,770 --> 00:59:23,520
0,90 90,330 330,570 570,690 690,750
they actually show up in

1947
00:59:23,520 --> 00:59:24,930
0,60 60,480 600,810 810,900 900,1410
the RAM,| this is important
|这一点很重要，因为只要我们更新尾部指针，

1948
00:59:24,930 --> 00:59:25,770
0,240 240,330 330,540 540,660 660,840
because as soon as we

1949
00:59:25,770 --> 00:59:27,690
0,390 390,450 450,720 720,1170 1170,1920
update the tail pointer,| {the,e1000,is}
|E1000将在RAM中查找这些描述符。

1950
00:59:27,690 --> 00:59:28,470
0,120 120,180 180,330 330,450 450,780
going to look into RAM

1951
00:59:28,470 --> 00:59:30,040
0,150 150,390 390,1200
for these descriptors.|
|

1952
00:59:30,970 --> 00:59:31,690
0,300 300,420 420,540 540,600 600,720
And we've got to make
我们必须确保所有的字段确实都设置好了，

1953
00:59:31,690 --> 00:59:33,190
0,150 150,300 300,450 450,780 1050,1500
sure that all the fields

1954
00:59:33,190 --> 00:59:34,580
0,90 90,390 390,810
are indeed set,|
|

1955
00:59:34,800 --> 00:59:36,420
0,540 540,600 600,1080 1080,1290 1290,1620
otherwise, it would read stale
否则，它将读取过时的值。

1956
00:59:36,420 --> 00:59:37,640
0,660
values.|
|

1957
00:59:40,360 --> 00:59:41,760
0,270 270,360 360,510 510,780
Does that make sense?|
这说得通吗？|

1958
00:59:43,410 --> 00:59:44,500
0,360 360,570
{Yep,thank} you.|
好的谢谢。|

1959
00:59:46,320 --> 00:59:48,300
0,570 720,990 990,1110 1110,1500 1500,1980
{} Why do mbuf exist,|
为什么mbuf会存在，|

1960
01:00:00,660 --> 01:00:01,560
0,330 330,540 540,690 690,840 840,900
why have these sort of
为什么会有这种分离的结构，为什么会有这两种对应的结构。

1961
01:00:01,560 --> 01:00:03,240
0,330 330,870 870,1170 1200,1530 1530,1680
separate structure of, why have

1962
01:00:03,240 --> 01:00:04,800
0,210 210,960
these two

1963
01:00:06,200 --> 01:00:08,500
0,210 210,420 420,1020 1020,1650
sort of corresponding structures.|
|

1964
01:00:09,590 --> 01:00:10,520
0,210 210,300 300,570 570,840 840,930
So I guess part of
所以我想部分原因是如果司机需要告诉硬件东西在哪里，这一切都很好，

1965
01:00:10,520 --> 01:00:12,300
0,180 180,480 480,1140
it is it's

1966
01:00:12,300 --> 01:00:13,770
0,450 450,780 780,930 930,1290 1290,1470
all nice and well if

1967
01:00:13,770 --> 01:00:15,660
0,240 240,750 750,1170 1170,1380 1380,1890
the driver needs to talk

1968
01:00:15,660 --> 01:00:17,970
0,390 420,540 540,990 990,1620 2040,2310
to the hardware about where

1969
01:00:17,970 --> 01:00:18,810
0,270 270,540 540,630 630,720 720,840
things are,| but at the
|但归根结底，我们确实需要存储数据包，以便以某种方式将其传递到网络堆栈。

1970
01:00:18,810 --> 01:00:19,380
0,120 120,240 240,300 300,450 450,570
end of the day, we

1971
01:00:19,380 --> 01:00:20,340
0,180 180,480 480,540 540,870 870,960
do need to store the

1972
01:00:20,340 --> 01:00:21,540
0,480 480,570 570,840 840,1080 1080,1200
packet to hand off to

1973
01:00:21,540 --> 01:00:23,420
0,90 90,420 420,720 720,1260
the network stack somehow.|
|

1974
01:00:24,020 --> 01:00:25,670
0,270 270,840 900,1050 1050,1440 1440,1650
Yeah exactly,| you know, so
是的，就是这样，|你知道，所以你知道，考虑这个问题的一种方式是，你知道mbuf完全不那么抽象，

1975
01:00:25,670 --> 01:00:26,660
0,180 180,270 270,660 660,870 870,990
you know so one way

1976
01:00:26,660 --> 01:00:27,350
0,90 90,210 210,450 450,540 540,690
to think about it is

1977
01:00:27,350 --> 01:00:28,160
0,180 180,450 480,570 570,690 690,810
that the you know the

1978
01:00:28,160 --> 01:00:29,510
0,210 210,450 450,510 510,990 990,1350
{mbufs -} {} completely less

1979
01:00:29,510 --> 01:00:30,890
0,600 600,900 900,990 990,1170 1170,1380
abstraction,| nothing to do with
|与网卡一点关系都没有

1980
01:00:30,890 --> 01:00:32,420
0,300 300,840 870,1200 1200,1410 1410,1530
really the network card at

1981
01:00:32,420 --> 01:00:34,040
0,330 720,900 900,1050 1050,1320 1320,1620
all| and it's there because
|它之所以在那里，是因为你知道，如果在某个时候，你知道，可能会收到一个数据包，

1982
01:00:34,040 --> 01:00:35,900
0,300 300,390 390,600 600,1200 1200,1860
like you know if {

1983
01:00:36,500 --> 01:00:37,640
0,330 330,480 480,570 570,840 840,1140
-} at some point, {}

1984
01:00:37,640 --> 01:00:39,110
0,120 120,570 600,1080 1080,1410 1410,1470
you know maybe receive a

1985
01:00:39,110 --> 01:00:40,310
0,480 480,570 570,690 690,960 960,1200
packet,| you know we headed
|你知道我们要去网络堆栈，

1986
01:00:40,310 --> 01:00:41,450
0,180 180,270 270,360 360,810 810,1140
off to the network stack,|
|

1987
01:00:41,450 --> 01:00:42,440
0,180 180,240 240,510 510,750 750,990
in the network stack now
在网络堆栈中现在停留在某个队列中，

1988
01:00:42,440 --> 01:00:43,850
0,300 300,450 450,600 600,1170 1260,1410
sticks at some queue,| so
|这样当稍后用户进程调用Read时，

1989
01:00:43,850 --> 01:00:44,930
0,120 120,300 300,690 690,810 810,1080
that when later a user

1990
01:00:44,930 --> 01:00:46,610
0,330 330,570 570,960 990,1170 1170,1680
process calls read,| you actually
|你其实可以读的。

1991
01:00:46,610 --> 01:00:47,680
0,150 150,330 330,540
can read it.|
|

1992
01:00:48,000 --> 01:00:49,650
0,480 570,810 810,1260 1260,1410 1410,1650
In, the meantime we need
同时，我们需要一些结构来保存我们实际收到的数据

1993
01:00:49,650 --> 01:00:50,850
0,60 60,210 210,390 390,900 900,1200
to have some structure, that

1994
01:00:50,850 --> 01:00:52,170
0,300 300,480 480,930 990,1200 1200,1320
holds that data that we

1995
01:00:52,170 --> 01:00:53,670
0,270 270,870 870,960 960,1170 1170,1500
actually received| and that's exactly
|这就是那些mbuf结构。

1996
01:00:53,670 --> 01:00:54,990
0,90 90,270 270,630 630,1020 1020,1320
what those mbuf structures are.|
|

1997
01:01:01,310 --> 01:01:02,690
0,330 330,450 450,540 540,840 840,1380
Sorry, can you talk about
抱歉，你能不能谈谈，

1998
01:01:02,720 --> 01:01:04,380
0,450 480,1080
{} the,|
|

1999
01:01:04,700 --> 01:01:05,880
0,600
like
例如，如何在代码中使用链接列表结构，

2000
01:01:05,880 --> 01:01:07,380
0,390 390,660 660,750 750,1080 1080,1500
how, how do you use

2001
01:01:07,380 --> 01:01:09,570
0,150 150,450 450,810 810,1680 2010,2190
the link list structure in

2002
01:01:09,570 --> 01:01:10,410
0,150 150,420 420,690 690,720 720,840
your code,| because I was
|因为我试着去理解它并追踪它

2003
01:01:10,410 --> 01:01:11,560
0,270 270,660
trying to

2004
01:01:11,620 --> 01:01:13,030
0,210 210,720 720,870 870,1080 1080,1410
to understand it and track

2005
01:01:13,030 --> 01:01:15,070
0,90 90,660 1260,1650 1650,1860 1860,2040
it down| and it seems
|似乎有一些推尾或推头，

2006
01:01:15,070 --> 01:01:17,720
0,150 150,480 480,990 1230,2040
like there's some push

2007
01:01:17,840 --> 01:01:20,360
0,600 600,930 930,1200 1200,1650 1710,2520
tail or push head,| but
|但我在我的代码里从来不叫它，

2008
01:01:21,040 --> 01:01:22,360
0,60 60,270 270,810 930,1230 1230,1320
I don't ever call it

2009
01:01:22,360 --> 01:01:24,220
0,330 330,630 630,1320
in my code,|
|

2010
01:01:24,220 --> 01:01:25,660
0,180 180,360 360,540 540,990 1290,1440
oh, it might be it
哦，可能是net.c文件的问题。

2011
01:01:25,660 --> 01:01:26,950
0,180 180,360 360,480 480,1020 1020,1290
might be the {net.c -

2012
01:01:26,950 --> 01:01:28,640
0,300 300,1050
-} file.|
|

2013
01:01:30,200 --> 01:01:31,910
0,180 180,570 570,780 780,1320 1320,1710
{Well,the} networks c files file,
好的，网络c文件文件，我们给了你[]。

2014
01:01:31,910 --> 01:01:33,110
0,210 210,420 420,510 510,630 630,1200
we gave you to [].|
|

2015
01:01:33,770 --> 01:01:34,880
0,840
Yeah.|
嗯。|

2016
01:01:39,650 --> 01:01:41,520
0,330 330,660 660,810 810,1290
And where you're thinking.|
以及你在想什么。|

2017
01:01:42,800 --> 01:01:44,810
0,570 570,750 750,1050 1050,1620 1650,2010
If you look for something
如果你想找像拉式汽水这样的东西，我想是汽水。

2018
01:01:44,810 --> 01:01:45,840
0,450
like

2019
01:01:46,640 --> 01:01:49,940
0,720 750,2460 2490,2610 2610,2790 2790,3300
{} {pull,pop}, I think pop.|
|

2020
01:01:50,580 --> 01:01:51,740
0,660

2021
01:01:54,210 --> 01:01:56,250
0,690 900,1260 1260,1500 1500,1800 1830,2040
Yeah, so this is this
是的，这是它看起来唯一使用mbuf的链表结构的地方。

2022
01:01:56,250 --> 01:01:57,390
0,60 60,180 180,420 420,780 780,1140
is the only place where

2023
01:01:57,390 --> 01:01:59,040
0,120 120,330 330,690 720,1020 1020,1650
it looks like it does

2024
01:01:59,160 --> 01:02:00,990
0,630 630,990 990,1140 1140,1470 1470,1830
things with the linked list

2025
01:02:00,990 --> 01:02:05,040
0,840 1110,1710 1860,2550 3300,3810 3870,4050
structure of mbuf| and if
|如果您不调用此函数或Push尾巴，

2026
01:02:05,040 --> 01:02:06,600
0,120 120,270 270,780 810,1290 1290,1560
you don't ever call this

2027
01:02:06,600 --> 01:02:09,180
0,390 390,810 1110,1260 1260,2100 2400,2580
function or the {push,tail},| you
|基本上，您只需将mbuf视为一个由多少个字符组成的数组，

2028
01:02:09,180 --> 01:02:11,010
0,390 390,840 840,1170 1170,1320 1320,1830
basically just treat the mbuf

2029
01:02:11,010 --> 01:02:12,060
0,690
as

2030
01:02:12,290 --> 01:02:13,740
0,210 210,960
an array

2031
01:02:13,740 --> 01:02:17,610
0,660 900,1560 1860,2130 2130,2730 2940,3870
of like how many characters,|
|

2032
01:02:17,670 --> 01:02:18,860
0,600
so,
那么，为什么mbuf会在那里。

2033
01:02:18,890 --> 01:02:20,570
0,240 240,510 510,660 660,1050 1050,1680
so why is mbuf there.|
|

2034
01:02:21,370 --> 01:02:23,880
0,840 1080,2070
Because here,
因为在这里，当你收到UDP数据包时，

2035
01:02:24,740 --> 01:02:26,810
0,900 1140,1530 1530,1710 1710,2040 2040,2070
{} when you receive a

2036
01:02:26,810 --> 01:02:29,150
0,360 360,900 1320,1530 1530,1980 1980,2340
UDP packet,| so the {UDP,packet}
|因此UDP数据包从网卡传入，

2037
01:02:29,150 --> 01:02:29,990
0,210 210,300 300,480 480,540 540,840
comes in from the network

2038
01:02:29,990 --> 01:02:31,070
0,450 480,660 660,840 840,1020 1020,1080
card,| it goes to the
|它进入网络堆栈，

2039
01:02:31,070 --> 01:02:32,420
0,300 300,780
network stack,|
|

2040
01:02:32,450 --> 01:02:34,760
0,540 540,660 660,1290 1380,1980 2010,2310
then the UDP packet, the
然后是UDP数据包，即保存该UDP数据包的UDP的mbuf

2041
01:02:34,760 --> 01:02:35,930
0,240 240,420 420,570 570,660 660,1170
{mbuf -} for the UDP

2042
01:02:35,930 --> 01:02:37,640
0,150 150,510 510,720 750,1380 1380,1710
that holds that {} UDP

2043
01:02:37,640 --> 01:02:39,170
0,420 810,960 960,1140 1140,1440 1440,1530
packet| is actually stuck in
|实际上就在这里排着队，

2044
01:02:39,170 --> 01:02:40,720
0,60 60,450 480,720 720,1080
a queue right here,|
|

2045
01:02:42,090 --> 01:02:43,590
0,360 360,450 450,1050 1080,1380 1380,1500
on the socket for the
在接收器的插座上。

2046
01:02:43,590 --> 01:02:44,760
0,630
receiver.|
|

2047
01:02:47,460 --> 01:02:48,600
0,300 300,720 750,960 960,1050 1050,1140
And so this is the
这就是为什么您可以在mbuf中拥有队列的原因。

2048
01:02:48,600 --> 01:02:49,380
0,240 240,360 360,480 480,570 570,780
reason that you can have

2049
01:02:49,380 --> 01:02:50,840
0,300 300,510 510,990
queues within mbufs.|
|

2050
01:02:54,420 --> 01:02:55,230
0,180 180,270 270,510 510,570 570,810
And the reason is stack
原因是堆叠在队列中是正确的，

2051
01:02:55,230 --> 01:02:56,100
0,90 90,150 150,360 360,600 600,870
in the queue there correct,|
|

2052
01:02:56,100 --> 01:02:56,940
0,90 90,480 480,570 570,690 690,840
is because you know who
是因为你知道谁知道，你知道将要从这个特定套接字读取的用户进程，

2053
01:02:56,940 --> 01:02:57,930
0,360 360,420 420,570 570,720 720,990
knows, you know the user

2054
01:02:57,930 --> 01:02:59,130
0,360 360,510 510,630 630,720 720,1200
process that's going to read

2055
01:02:59,160 --> 01:03:00,180
0,120 120,270 270,540 540,720 720,1020
you know from this particular

2056
01:03:00,180 --> 01:03:01,860
0,510 960,1110 1110,1410 1410,1530 1530,1680
socket,| {you,know} might be doing
|你知道可能在做别的事

2057
01:03:01,860 --> 01:03:03,240
0,270 270,810 840,1170 1170,1260 1260,1380
something else| and at some
|在以后的某个时刻，它将调用Read系统调用，

2058
01:03:03,240 --> 01:03:04,290
0,210 210,570 570,870 870,990 990,1050
point later it's going to

2059
01:03:04,290 --> 01:03:05,310
0,180 180,270 270,450 450,750 750,1020
call the read system call,|
|

2060
01:03:05,310 --> 01:03:06,240
0,180 180,240 240,420 420,690 690,930
then the read system call
然后read系统调用将从该套接字中删除mbuf。

2061
01:03:06,240 --> 01:03:07,170
0,60 60,180 180,240 240,810 840,930
is going to remove you

2062
01:03:07,170 --> 01:03:08,730
0,180 180,540 900,1230 1230,1410 1410,1560
know that {mbuf -} from

2063
01:03:08,730 --> 01:03:10,060
0,360 420,900
that socket.|
|

2064
01:03:11,780 --> 01:03:13,730
0,210 210,570 570,1350 1380,1590 1590,1950
And so, {} the point
因此，每个套接字的点可以具有用于接收的mbuf列表。

2065
01:03:13,730 --> 01:03:15,320
0,390 390,630 630,1080 1080,1230 1230,1590
with each socket can have

2066
01:03:15,320 --> 01:03:17,180
0,450 450,960 990,1260 1260,1410 1410,1860
a list of {mbufs -}

2067
01:03:19,020 --> 01:03:20,800
0,690 690,1230
for reception.|
|

2068
01:03:22,070 --> 01:03:24,000
0,180 180,450 450,780 780,1320
I see, thank you.|
我明白了，谢谢你。|

2069
01:03:25,840 --> 01:03:26,770
0,210 210,390 390,480 480,720 720,930
Okay, let's go back to
好的，让我们回到司机的问题上。

2070
01:03:26,770 --> 01:03:28,100
0,120 120,810
the driver.|
|

2071
01:03:28,190 --> 01:03:30,780
0,180 180,540 780,2040
So {that,was} transmit.|
所以那是传输的。|

2072
01:03:32,480 --> 01:03:34,100
0,240 240,720 720,840 840,1500 1530,1620
So then we receive, you
所以我们收到了，你知道几乎相似的，没有太大差别的，

2073
01:03:34,100 --> 01:03:36,590
0,210 210,930 930,1800 1950,2310 2310,2490
know almost similar, not that

2074
01:03:36,590 --> 01:03:39,950
0,180 180,750 1170,2010 2040,3030 3030,3360
much difference,| {} basically {you,know}
|基本上，您知道从网卡读取尾部指针。

2075
01:03:39,950 --> 01:03:41,240
0,210 210,300 300,630 630,990 990,1290
read the tail pointer from

2076
01:03:41,240 --> 01:03:43,160
0,570 600,900 900,1380
the network card.|
|

2077
01:03:43,220 --> 01:03:44,870
0,420 420,630 630,960 960,1350 1350,1650
{} You see there actually
你看，实际上那里有一个包裹，

2078
01:03:44,870 --> 01:03:47,150
0,60 60,600 690,1530 1920,2100 2100,2280
a packet,| and if there's
|如果有数据包，则设置DD字段，

2079
01:03:47,150 --> 01:03:48,530
0,60 60,420 420,690 690,960 960,1380
a packet, then the DD

2080
01:03:48,530 --> 01:03:51,110
0,570 810,1740 1740,1950 1950,2100 2100,2580
field {} would be set,|
|

2081
01:03:51,770 --> 01:03:52,850
0,240 240,420 420,510 510,810 810,1080
{} if the DD field
如果没有设置DD字段，

2082
01:03:52,850 --> 01:03:54,500
0,120 120,390 390,780 810,1530 1530,1650
is not set,| then we
|然后我们就知道没有包了，所以我们就完事了，

2083
01:03:54,500 --> 01:03:55,580
0,180 180,390 390,540 540,930 930,1080
know there's no packet and

2084
01:03:55,580 --> 01:03:56,920
0,180 180,360 360,780
so we're done,|
|

2085
01:03:57,200 --> 01:03:58,820
0,240 240,540 540,720 720,1500 1500,1620
if it is set, we're
如果设置好了，我们就去读，

2086
01:03:58,820 --> 01:04:00,320
0,120 120,390 420,630 630,930
going to read it,|
|

2087
01:04:00,740 --> 01:04:02,220
0,930

2088
01:04:02,220 --> 01:04:03,810
0,450 450,660 660,750 750,1440 1440,1590
and read the length, you
读一读长度，你知道的。

2089
01:04:03,810 --> 01:04:04,960
0,600
know.|
|

2090
01:04:04,960 --> 01:04:07,120
0,240 240,540 540,1380 1800,2010 2010,2160
And when we when we
当我们调用和net_rx时，

2091
01:04:07,120 --> 01:04:08,710
0,510 510,870 870,1140 1140,1290 1290,1590
call and {net_rx - -},|
|

2092
01:04:08,710 --> 01:04:10,240
0,210 210,660 660,840 840,1200 1200,1530
{you,know} do up call into
你知道，向上调用更高级别的堆栈。

2093
01:04:10,240 --> 01:04:11,780
0,90 90,300 300,540 540,990
the higher level stack.|
|

2094
01:04:11,930 --> 01:04:14,270
0,660 660,1230 1230,1770 1770,1890 1890,2340
{} And when we're done,
当我们做完的时候，你知道我们基本上是自由的，你知道那个入口。

2095
01:04:14,270 --> 01:04:15,600
0,150 150,300 300,750
you know we're

2096
01:04:16,050 --> 01:04:17,520
0,360 360,720 720,900 900,1290 1350,1470
{} basically free up you

2097
01:04:17,520 --> 01:04:19,530
0,120 120,450 600,1260 1350,1830 1830,2010
know that entry.| {} So
|以便驱动程序可以使用它来实际接收其中的更多数据包。

2098
01:04:19,530 --> 01:04:20,760
0,180 180,450 450,810 810,1050 1050,1230
that the driver can use

2099
01:04:20,760 --> 01:04:21,840
0,120 120,300 300,510 510,840 840,1080
it to actually receive more

2100
01:04:21,840 --> 01:04:23,000
0,330 330,450 450,630
packets in it.|
|

2101
01:04:23,340 --> 01:04:25,290
0,450 450,540 540,990 1020,1500 1500,1950
And the real [crucial] operation
而且真正的[关键]作业区是正确的，

2102
01:04:25,290 --> 01:04:26,460
0,270 270,360 360,690 690,870 870,1170
area is correct,| we bump
|我们基本上是撞上尾巴告诉司机，

2103
01:04:26,460 --> 01:04:27,840
0,150 150,450 450,540 540,1260 1260,1380
up basically the tail to

2104
01:04:27,840 --> 01:04:29,760
0,180 180,240 240,870 1260,1770 1800,1920
tell the driver,| hey you
|嘿，你知道我们已经用完了，你可以再用一次，

2105
01:04:29,760 --> 01:04:30,570
0,150 150,300 300,510 510,690 690,810
know we're done with it,

2106
01:04:30,570 --> 01:04:31,560
0,150 150,300 300,480 480,600 600,990
you can use it again,|
|

2107
01:04:31,590 --> 01:04:32,670
0,90 90,210 210,660 660,900 900,1080
you know here's again that
你知道这里又是那个位置。

2108
01:04:32,670 --> 01:04:33,520
0,390
slot.|
|

2109
01:04:35,900 --> 01:04:37,040
0,210 210,480 480,570 570,870 870,1140
So maybe the most interesting
所以也许最有趣的问题是你问了多少问题

2110
01:04:37,040 --> 01:04:38,810
0,420 420,870 900,1260 1290,1710 1710,1770
question is and number of

2111
01:04:38,810 --> 01:04:40,880
0,570 570,960 990,1140 1140,1620 1650,2070
questions have you asked| why
|为什么在那里的时候，为什么这是一个循环。

2112
01:04:40,880 --> 01:04:42,320
0,150 150,240 240,600 600,930
is the while there,

2113
01:04:45,530 --> 01:04:46,250
0,300 300,390 390,540 540,660 660,720
why is this in a

2114
01:04:46,250 --> 01:04:47,200
0,480
loop.|
|

2115
01:04:47,690 --> 01:04:49,130
0,210 210,330 330,480 480,1140 1140,1440
Don't you get {an,interrupt} then
你不会被打断然后你就知道你抓到了一包然后你就完成了，

2116
01:04:49,130 --> 01:04:49,940
0,90 90,210 210,360 360,570 570,810
you know you grab one

2117
01:04:49,940 --> 01:04:51,290
0,300 300,390 390,570 570,750 990,1350
packet then you've done,| a
|很多人实际上忘记了While循环，

2118
01:04:51,320 --> 01:04:52,490
0,270 270,330 330,540 540,690 690,1170
number of people that actually

2119
01:04:53,020 --> 01:04:54,430
0,390 390,750 750,930 930,1350 1350,1410
forgot {while,loop},| but first you
|但首先，请注意，在该测试期间，您基本上在某个点上不再收到数据包。

2120
01:04:54,430 --> 01:04:56,080
0,330 360,870 870,1020 1020,1560 1560,1650
know notice that basically at

2121
01:04:56,080 --> 01:04:57,160
0,120 120,390 390,480 480,630 630,1080
some point you don't receive

2122
01:04:57,160 --> 01:04:58,750
0,360 360,690 690,960 960,1140 1140,1590
packets anymore, during that test.|
|

2123
01:05:02,840 --> 01:05:04,340
0,210 210,360 360,1140 1170,1380 1380,1500
Is it because you would
是因为您希望仅用一个中断就能传输尽可能多的准备好的数据包，

2124
01:05:04,340 --> 01:05:05,780
0,300 300,390 390,930 930,1110 1110,1440
like to transmit as many

2125
01:05:05,780 --> 01:05:07,010
0,450 450,630 630,780 780,1050 1050,1230
packets that are ready as

2126
01:05:07,010 --> 01:05:08,900
0,480 480,660 660,870 870,1170 1170,1890
possible with only one interrupt,|
|

2127
01:05:08,900 --> 01:05:10,820
0,150 150,360 360,510 510,1170 1680,1920
so that you can kind
这样你就可以在某种程度上摊销中断的成本。

2128
01:05:10,820 --> 01:05:12,170
0,150 150,780 780,900 900,1230 1230,1350
of amortize the cost of

2129
01:05:12,170 --> 01:05:13,440
0,120 120,840
the interrupt.|
|

2130
01:05:13,780 --> 01:05:15,460
0,480 480,870 870,1140 1140,1290 1290,1680
Yeah, this, this is absolutely
是的，这，这绝对是其中的一部分，

2131
01:05:15,460 --> 01:05:16,240
0,150 150,210 210,390 390,510 510,780
part of it,| you know
|你知道，我们先来谈谈你们写的根本原因，

2132
01:05:16,240 --> 01:05:17,920
0,270 270,480 480,600 600,1080 1230,1680
you get to the let's

2133
01:05:17,920 --> 01:05:18,970
0,210 210,390 390,660 660,780 780,1050
first talk about you know

2134
01:05:18,970 --> 01:05:20,530
0,300 450,750 750,990 990,1080 1080,1560
the root cause you guys

2135
01:05:20,530 --> 01:05:23,860
0,360 1200,1800 1920,2760 2760,2970 2970,3330
write,| a number of burst
|一些突发包进来了，

2136
01:05:23,860 --> 01:05:25,180
0,330 330,540 540,840
package comes in,|
|

2137
01:05:25,330 --> 01:05:26,980
0,750 750,1020 1020,1260 1260,1500 1500,1650
and the network card will
并且网卡将产生中断，

2138
01:05:26,980 --> 01:05:29,350
0,690 720,1020 1020,1590 1950,2190 2190,2370
generate the interrupt,| but more
|但是有更多的信息包进来了

2139
01:05:29,350 --> 01:05:30,490
0,300 300,360 360,600 600,870 960,1140
packets are coming in| and
|所以它只会把它们放在实际可以使用的三个描述符中，

2140
01:05:30,490 --> 01:05:31,570
0,150 150,240 240,390 390,690 720,1080
so it will just put

2141
01:05:31,570 --> 01:05:32,950
0,120 120,270 270,600 600,810 810,1380
them in the three descriptors

2142
01:05:32,950 --> 01:05:34,390
0,180 180,420 420,810 810,960 960,1440
right that actually can use,|
|

2143
01:05:35,060 --> 01:05:37,190
0,750 870,1260 1260,1590 1590,1770 1770,2130
{} can't generate more interrupts,
无法生成更多中断，因为已生成中断

2144
01:05:37,190 --> 01:05:39,800
0,270 270,510 510,1020 1020,1560 1950,2610
because already generated interrupt| and
|在某种程度上，你知道不管是什么过程

2145
01:05:39,800 --> 01:05:40,820
0,120 120,330 330,780 780,870 870,1020
at some point you know

2146
01:05:40,820 --> 01:05:42,950
0,810 840,1320 1320,1410 1410,1800 1800,2130
the whatever the process| or
|或者你知道，也许我们的核心只是在一段关闭中断的代码中，

2147
01:05:42,950 --> 01:05:44,120
0,90 90,180 180,600 600,960 960,1170
you know, maybe we were

2148
01:05:44,120 --> 01:05:45,380
0,180 180,450 450,780 780,1140 1140,1260
the core was just in

2149
01:05:45,380 --> 01:05:46,250
0,60 60,390 390,450 450,720 720,870
a section of code that

2150
01:05:46,250 --> 01:05:47,600
0,450 450,600 600,1050 1050,1290 1290,1350
turned off interrupts,| because it
|因为它在做一些原子的事情，

2151
01:05:47,600 --> 01:05:49,190
0,120 120,270 270,540 540,1050 1410,1590
was doing something atomic,| at
|在它的最后，你知道有一个锁的释放，它实际上关闭了中断，

2152
01:05:49,190 --> 01:05:49,790
0,120 120,240 240,360 360,510 510,600
the end of it, you

2153
01:05:49,790 --> 01:05:50,720
0,150 150,330 330,420 420,720 720,930
know there's a release from

2154
01:05:50,720 --> 01:05:52,190
0,390 390,570 570,750 750,990 990,1470
lock that actually turns interruption

2155
01:05:52,190 --> 01:05:53,420
0,210 360,690 690,900 900,960 960,1230
off,| that point of time,
|那个时间点，然后基本上就这么做了。

2156
01:05:53,420 --> 01:05:54,680
0,150 150,510 510,660 660,840
then basically do it.|
|

2157
01:05:54,680 --> 01:05:57,020
0,510 540,1200 1230,1920 1920,2010 2010,2340
{} Receive handlers, the interrupt
接收处理程序，中断处理程序将要运行，

2158
01:05:57,020 --> 01:05:59,270
0,300 300,780 1140,1770 1770,2160 2160,2250
handler {going,to,run},| but between a
|但是在第一个信息包传入到您收到处理程序之前的一段时间内

2159
01:05:59,270 --> 01:06:00,710
0,450 450,780 780,900 900,1170 1170,1440
period when the first packet

2160
01:06:00,710 --> 01:06:01,610
0,210 210,420 420,510 510,780 780,900
comes in and before you

2161
01:06:01,610 --> 01:06:02,690
0,330 330,600 600,900 900,1050 1050,1080
receive handler runs| there's a
|可能还有一大堆其他的包裹可能已经进来了。

2162
01:06:02,690 --> 01:06:03,470
0,120 120,270 270,330 330,480 480,780
whole bunch of other packets

2163
01:06:03,470 --> 01:06:05,600
0,240 240,720 930,1230 1230,1710 1860,2130
might have could have could

2164
01:06:05,600 --> 01:06:06,820
0,240 240,450 450,690
have come in.|
|

2165
01:06:07,430 --> 01:06:09,050
0,480 480,900 900,1230 1260,1440 1440,1620
{} And so we don't
所以我们不会在While循环中运行，会留下这些数据包，

2166
01:06:09,050 --> 01:06:10,310
0,330 330,450 450,540 540,840 840,1260
run in the while loop,

2167
01:06:10,340 --> 01:06:13,100
0,300 300,690 690,930 930,1620 2010,2760
will leave those packets {},|
|

2168
01:06:13,100 --> 01:06:14,510
0,420 420,660 660,750 750,1020 1020,1410
will grab the first one
会抓到第一个，也会抓到另一个

2169
01:06:14,540 --> 01:06:15,650
0,300 300,450 450,690 690,690 690,1110
and will grab the other|
|

2170
01:06:15,650 --> 01:06:16,640
0,120 120,210 210,480 480,690 690,990
and the later ones you
后面的放在右边的队列里，

2171
01:06:16,640 --> 01:06:18,050
0,360 360,630 630,870 870,960 960,1410
stick there in the queue

2172
01:06:18,140 --> 01:06:19,100
0,240 240,390 390,570 570,780 780,960
right,| they're just sitting there
|他们就坐在那个拳击场里。

2173
01:06:19,100 --> 01:06:20,200
0,90 90,270 270,570
in that ring.|
|

2174
01:06:20,680 --> 01:06:22,420
0,390 450,780 780,1260 1260,1620 1620,1740
Now, if subsequent interrupt would
现在，如果随后的中断会进来，

2175
01:06:22,420 --> 01:06:23,320
0,150 150,360 360,630 630,840 840,900
come in,| we'll grab the
|我们会搭下一辆，

2176
01:06:23,320 --> 01:06:25,480
0,240 240,600 1020,1710 1710,1950 1950,2160
next one,| but like the
|但就像测试一样，你知道他们会做什么，他们会运行他们的UDP数据包，

2177
01:06:25,480 --> 01:06:26,740
0,630 660,810 810,900 900,1110 1110,1260
tests, you know what they

2178
01:06:26,740 --> 01:06:28,630
0,330 330,540 540,1140 1140,1470 1470,1890
do they run their UDP

2179
01:06:28,630 --> 01:06:29,620
0,480 480,600 600,720 720,870 870,990
packets,| you know, so they
|你知道，他们会发送一大堆测试，因为有10个ping请求是并行发送的，

2180
01:06:29,620 --> 01:06:30,700
0,240 240,390 390,450 450,690 690,1080
send off a whole bunch

2181
01:06:30,700 --> 01:06:31,480
0,180 180,330 330,420 420,510 510,780
like one of the test

2182
01:06:31,480 --> 01:06:33,760
0,330 330,510 510,1050 1350,1830 1830,2280
since like ten ping request

2183
01:06:33,760 --> 01:06:35,140
0,120 120,840 1050,1170 1170,1260 1260,1380
in parallel,| you know the
|你知道有十个回复是平行的，你知道是对的。

2184
01:06:35,140 --> 01:06:37,390
0,390 390,930 930,1290 1290,1740 1740,2250
ten responses coming parallel back,

2185
01:06:37,420 --> 01:06:38,640
0,150 150,330 330,780
you know correct.|
|

2186
01:06:38,640 --> 01:06:40,860
0,180 180,270 270,600 600,1050 1230,2220
{} The first one receives
第一个接收到的信号产生中断，

2187
01:06:40,860 --> 01:06:42,420
0,420 420,510 510,1080 1170,1380 1380,1560
generates an interrupt,| the other
|其他九个人进入队列，

2188
01:06:42,420 --> 01:06:43,980
0,480 480,660 660,870 870,960 960,1560
nine go into the queue,|
|

2189
01:06:44,480 --> 01:06:46,940
0,720 900,1410 1440,1770 1770,2010 2010,2460
{} the higher level software,
更高级的软件，你知道，达到了第一个，

2190
01:06:46,940 --> 01:06:47,750
0,90 90,240 240,480 480,570 570,810
you know reached the first

2191
01:06:47,750 --> 01:06:48,800
0,480
one,|
|

2192
01:06:48,830 --> 01:06:50,900
0,570 750,900 900,1440 1440,1830 1830,2070
{} and then returns like
然后就像做完了一样回来

2193
01:06:50,900 --> 01:06:52,010
0,150 150,480 750,930 930,990 990,1110
it's done| and at that
|在这一点上，什么都不会发生，

2194
01:06:52,010 --> 01:06:53,750
0,390 390,660 660,1020 1020,1440 1440,1740
point, nothing happens anymore,| because
|因为接收器正在等待更多的接收分组，

2195
01:06:53,750 --> 01:06:55,190
0,300 300,780 780,900 900,1260 1260,1440
the receiver is waiting for

2196
01:06:55,190 --> 01:06:56,840
0,300 300,600 600,1020 1170,1410 1410,1650
more receive packets,| they happen
|他们碰巧在那里，他们坐在拳台上，

2197
01:06:56,840 --> 01:06:57,650
0,90 90,240 240,510 510,630 630,810
to be there, they're sitting

2198
01:06:57,650 --> 01:06:59,180
0,90 90,180 180,600 780,1080 1080,1530
in the ring,| {} except
|除了你知道，你收到的不是在WHILE循环中做的

2199
01:06:59,180 --> 01:07:00,080
0,90 90,360
you know,

2200
01:07:00,080 --> 01:07:01,490
0,360 540,990 990,1170 1170,1290 1290,1410
you received didn't do them

2201
01:07:01,490 --> 01:07:02,210
0,120 120,180 180,450 450,630 630,720
in a while loop| and
|所以没有去接他们。

2202
01:07:02,210 --> 01:07:03,140
0,120 120,390 390,540 540,660 660,930
so didn't pick them up.|
|

2203
01:07:05,850 --> 01:07:07,160
0,150 150,240 240,390 390,720
Does that make sense?|
这说得通吗？|

2204
01:07:13,160 --> 01:07:14,360
0,150 150,240 240,540 540,780 780,1200
So, for example if the
所以，举个例子，如果测试程序会发送，

2205
01:07:14,390 --> 01:07:15,710
0,300 300,810 810,930 930,1050 1050,1320
test programs would have sent,|
|

2206
01:07:15,710 --> 01:07:17,720
0,630 630,1290 1470,1890 1890,1980 1980,2010
one request waited for a
一个请求等待响应，一个请求等待响应，

2207
01:07:17,720 --> 01:07:19,700
0,600 600,960 960,1470 1500,1890 1890,1980
response, one request waited for

2208
01:07:19,700 --> 01:07:21,650
0,60 60,720 900,1680 1710,1830 1830,1950
a response,| then you would
|那么您永远不会注意到这一点，您需要执行一次While循环。

2209
01:07:21,650 --> 01:07:23,240
0,540 630,1110 1110,1260 1260,1350 1350,1590
never notice that, you needed

2210
01:07:23,240 --> 01:07:24,520
0,150 150,210 210,450 450,810
to a while loop.|
|

2211
01:07:24,550 --> 01:07:25,870
0,480 480,690 690,840 840,1170 1170,1320
{} And it's because like
这是因为好像会有一连串的回复，

2212
01:07:25,870 --> 01:07:27,040
0,180 180,240 240,540 540,630 630,1170
there's a burst of responses

2213
01:07:27,040 --> 01:07:28,780
0,210 210,360 360,870 990,1320 1320,1740
might come back,| {} and
|而这只会一起产生一个中断。

2214
01:07:28,780 --> 01:07:30,460
0,450 450,690 690,1050 1050,1350 1350,1680
that only generate together one

2215
01:07:30,460 --> 01:07:31,480
0,510
interrupt.|
|

2216
01:07:35,020 --> 01:07:36,610
0,180 180,480 480,630 630,840 1320,1590
Any questions about that, about
对那个，这个有什么问题吗？

2217
01:07:36,610 --> 01:07:37,990
0,210 210,510 510,720 720,810 810,1380
this?| I have a question,|
|我有个问题，|

2218
01:07:37,990 --> 01:07:39,700
0,510 540,780 780,960 960,1500 1500,1710
{} so for example if
例如，如果不是一段时间，

2219
01:07:39,700 --> 01:07:41,470
0,660 660,780 780,1290 1290,1770 1770,1770
instead of a while {}

2220
01:07:41,470 --> 01:07:42,700
0,690
one,|
|

2221
01:07:42,700 --> 01:07:43,600
0,300 300,480 480,630 630,780 780,900
{} we would have a
我们会有一个只遍历整个队列的for循环，

2222
01:07:43,600 --> 01:07:44,740
0,300 300,510 510,720 720,900 900,1140
for loop that just goes

2223
01:07:44,740 --> 01:07:45,790
0,210 210,270 270,540 540,840 840,1050
through the whole queue,| that
|出于同样的原因，这也是错误的。

2224
01:07:45,790 --> 01:07:48,220
0,120 120,660 660,1230 1260,2190 2220,2430
would also be wrong for

2225
01:07:48,220 --> 01:07:51,160
0,120 120,390 390,840 1200,2820 2820,2940
the same reason.| No, we
|不，我们跳过所有未设置DD的列表。

2226
01:07:51,160 --> 01:07:51,940
0,240 240,390 390,450 450,690 690,780
skip all the ones that

2227
01:07:51,940 --> 01:07:53,260
0,240 240,360 360,690 690,930 930,1320
have the DD not set.|
|

2228
01:07:54,670 --> 01:07:56,410
0,240 240,600 600,750 750,1320 1560,1740
Okay, we should only we
好的，我们应该我们应该只看数据包

2229
01:07:56,410 --> 01:07:57,490
0,270 270,480 480,570 570,960 960,1080
{should,only} look at packets| and
|实际上我们应该只看尾点。

2230
01:07:57,490 --> 01:07:59,560
0,540 540,1230 1440,1830 1830,2010 2010,2070
actually {} {we,should,only} look at

2231
01:07:59,560 --> 01:08:00,760
0,60 60,300 300,660
the tail point.|
|

2232
01:08:02,170 --> 01:08:03,280
0,360 360,480 480,600 600,990 990,1110
But you know {in,principle}, you
但你知道原则上你可以跳过整个队列

2233
01:08:03,280 --> 01:08:04,870
0,120 120,330 360,870 870,960 960,1590
could just skip the whole

2234
01:08:04,870 --> 01:08:06,100
0,510 510,600 600,780 780,990 990,1230
queue| and I guess look
|我想看看DD数据包，

2235
01:08:06,100 --> 01:08:07,390
0,60 60,150 150,510 510,1020 1020,1290
at the DD packets,| {you,know}
|您知道，让他们看到DD位已设置

2236
01:08:07,390 --> 01:08:08,410
0,120 120,330 330,630 630,900 900,1020
{} let them see the

2237
01:08:08,410 --> 01:08:09,640
0,390 390,600 600,720 720,1080 1110,1230
DD bit is set| and
|这可能行得通，我不知道我还没试过。

2238
01:08:09,640 --> 01:08:10,660
0,270 270,480 480,780 810,900 900,1020
that might work I don't

2239
01:08:10,660 --> 01:08:11,920
0,210 210,480 510,780 780,1020 1020,1260
know I haven't tried that.|
|

2240
01:08:14,060 --> 01:08:16,910
0,480 480,690 690,1110 1110,1770 1950,2850
Okay, but isn't the device
好的，但是在我们读到“陈旧”之后，这个设备不能在接收器里放更多的mbuf吗？

2241
01:08:16,910 --> 01:08:19,760
0,450 450,1140 1410,1650 1650,2280 2280,2850
able to put more mbufs

2242
01:08:19,760 --> 01:08:22,220
0,180 180,300 300,1170 1200,2280 2280,2460
in the receive after we

2243
01:08:22,220 --> 01:08:23,820
0,300 300,1050
read stale.|
|

2244
01:08:25,000 --> 01:08:26,460
0,360 360,930
Yeah yeah.|
对，对。|

2245
01:08:29,070 --> 01:08:30,120
0,540
Okay.|
好吧。|

2246
01:08:32,080 --> 01:08:33,380
0,180 180,300 300,420 420,810
And we have to.|
我们必须这么做。|

2247
01:08:42,200 --> 01:08:43,310
0,180 180,390 390,810 810,960 960,1110
It's very dangerous, like this
这是非常危险的，就像这个提议一样，

2248
01:08:43,310 --> 01:08:44,360
0,450 450,540 540,750 750,960 960,1050
proposal of like sort of

2249
01:08:44,360 --> 01:08:45,680
0,270 270,750 750,1080 1080,1200 1200,1320
looping around,| and you know
|你知道，看着DD片场，

2250
01:08:45,680 --> 01:08:47,480
0,270 270,570 570,1140 1140,1470 1470,1800
seeing {} DD set,| because
|因为你知道我们真的应该这么做，

2251
01:08:47,480 --> 01:08:49,340
0,120 120,540 990,1290 1290,1740 1740,1860
you know really we should

2252
01:08:49,340 --> 01:08:50,150
0,150 150,270 270,390 390,600 600,810
do,| we should not look
|我们不应该考虑真正由驱动程序或硬件控制的BUF

2253
01:08:50,150 --> 01:08:51,560
0,390 450,690 690,990 990,1170 1170,1410
at {} buf that really

2254
01:08:51,560 --> 01:08:52,700
0,60 60,420 420,540 540,630 630,1140
are controlled by the driver

2255
01:08:53,330 --> 01:08:54,680
0,180 180,330 330,420 420,930 1170,1350
or by the hardware| and
|只需查看实际可用的缓冲区即可查看此缓冲区

2256
01:08:54,680 --> 01:08:55,700
0,180 180,360 360,480 480,720 720,1020
only look at {} buffers

2257
01:08:55,700 --> 01:08:57,020
0,120 120,390 390,810 810,930 930,1320
are actually available to watch

2258
01:08:57,550 --> 01:08:59,530
0,180 180,630 690,1230 1620,1830 1830,1980
this buffer| and which is
|并且其由DD比特指示

2259
01:08:59,530 --> 01:09:00,760
0,420 420,540 540,660 660,990 990,1230
indicated by the DD bit|
|

2260
01:09:00,760 --> 01:09:01,750
0,150 150,510 510,630 630,930 930,990
and basically by looking at
基本上是通过查看尾部指针。

2261
01:09:01,750 --> 01:09:03,020
0,90 90,330 330,720
the tail pointer.|
|

2262
01:09:04,080 --> 01:09:05,910
0,420 420,750 750,1260 1290,1770 1770,1830
Basically, anything owned between the
基本上，尾部和头部之间拥有的任何东西都归硬件所有。

2263
01:09:05,910 --> 01:09:06,930
0,390 390,570 570,660 660,900 900,1020
tail and the head is

2264
01:09:06,930 --> 01:09:08,960
0,240 240,480 480,750 960,1500
owned by the hardware.|
|

2265
01:09:13,220 --> 01:09:14,810
0,390 390,660 660,780 780,1080 1080,1590
Going back to the {}
回到mbuf，就像我们需要mbuf的原因一样，

2266
01:09:14,810 --> 01:09:16,280
0,480 540,930 930,1050 1050,1350 1350,1470
mbuf, like the reason we

2267
01:09:16,280 --> 01:09:17,870
0,240 240,330 330,780 1170,1470 1470,1590
need the mbuf,| why do
|为什么我们需要缓冲区中的其他信息，如[]数组。

2268
01:09:17,870 --> 01:09:19,790
0,210 210,720 750,1020 1020,1560 1590,1920
we need {} the other

2269
01:09:19,790 --> 01:09:21,320
0,600 600,690 690,810 810,1260 1290,1530
information in the buffer like

2270
01:09:21,320 --> 01:09:24,580
0,780 810,1440 1440,1830 2100,2670
the [] array {}.|
|

2271
01:09:24,580 --> 01:09:25,300
0,90 90,270 270,420 420,630 630,720
I think it's called the
我想它叫后备店。

2272
01:09:25,300 --> 01:09:26,900
0,390 390,930
backing store.|
|

2273
01:09:28,760 --> 01:09:30,380
0,390 390,570 570,960 960,1290 1290,1620
It gets in {net.h -
它会进入net.h。

2274
01:09:30,380 --> 01:09:31,540
0,450
-}.|
|

2275
01:09:40,490 --> 01:09:42,020
0,570 600,750 750,1200 1230,1380 1380,1530
So we need we need
所以我们需要我们需要BUF场，对吗，

2276
01:09:42,020 --> 01:09:43,040
0,60 60,270 270,540 540,810 810,1020
the buf field, correct,| because
|因为它实际上包含了数据。

2277
01:09:43,040 --> 01:09:44,300
0,90 90,330 330,720 720,780 780,1260
it actually contains the data.|
|

2278
01:09:46,800 --> 01:09:48,360
0,120 120,420 420,660 660,1140 1140,1560
I thought the head contains
我以为头部包含指向数据的指针。

2279
01:09:48,360 --> 01:09:49,410
0,60 60,480 480,600 600,690 690,1050
a pointer to the data.|
|

2280
01:09:49,590 --> 01:09:50,580
0,210 210,600 600,810 810,900 900,990
Yeah yeah okay,| but the
好的，好的，|但是BUF实际上是实际分配的空间，

2281
01:09:50,580 --> 01:09:51,990
0,240 240,600 600,720 720,930 930,1410
buf actually is the actual

2282
01:09:51,990 --> 01:09:53,460
0,600 600,1200 1200,1290 1290,1350 1350,1470
allocates space,| you know the
|你知道整包东西都是对的，

2283
01:09:53,460 --> 01:09:55,410
0,240 240,720 720,1050 1290,1560 1560,1950
whole packets right,| and then
|然后Head拿到积分进入BUF，

2284
01:09:55,440 --> 01:09:57,240
0,480 480,690 690,960 960,1350 1350,1800
head get points into buf,|
|

2285
01:09:57,420 --> 01:09:58,620
0,510 510,630 630,1050 1050,1140 1140,1200
basically the start of the
基本上是数据包的开头。

2286
01:09:58,620 --> 01:09:59,560
0,480
packet.|
|

2287
01:10:01,450 --> 01:10:02,840
0,390 390,780
Okay, okay.|
好的，好的。|

2288
01:10:04,160 --> 01:10:05,210
0,150 150,420 420,570 570,780 780,1050
And this is {mbuf -},
这是姆布夫，这是

2289
01:10:05,210 --> 01:10:06,710
0,270 270,420 420,930 1080,1350 1350,1500
this is,| {} okay so
|好的，mbuf的更多上下文是您在许多网络堆栈中看到的结构，

2290
01:10:06,710 --> 01:10:08,270
0,270 330,780 780,870 870,1110 1110,1560
a little bit more context

2291
01:10:08,270 --> 01:10:09,080
0,60 60,270 270,630 630,720 720,810
to {mbuf -} is a

2292
01:10:09,080 --> 01:10:10,160
0,420 420,570 570,720 720,990 990,1080
structure that you see in

2293
01:10:10,160 --> 01:10:11,270
0,60 60,270 270,420 420,720 720,1110
a lot of network stacks,|
|

2294
01:10:11,270 --> 01:10:12,260
0,270 270,420 420,570 570,660 660,990
so you look in the
所以你看一下Linux内核，你会看到类似于下面这样的结构

2295
01:10:12,260 --> 01:10:13,670
0,240 240,660 660,840 840,1050 1050,1410
Linux kernel, you'll see structure

2296
01:10:13,670 --> 01:10:14,690
0,300 300,480 480,750 750,840 840,1020
similar like this| and it's
|它通常被称为mbufs，所以我们必须这样做。

2297
01:10:14,690 --> 01:10:16,280
0,330 330,600 600,750 750,1170
typically called {mbufs -},

2298
01:10:16,280 --> 01:10:17,420
0,240 240,390 390,540 540,780 780,1140
and so we have to.|
|

2299
01:10:19,060 --> 01:10:20,260
0,270 270,420 420,540 540,1080 1080,1200
We could have simplified this
如果我们想的话，我们可以把这个结构简化很多。

2300
01:10:20,260 --> 01:10:21,340
0,330 330,660 660,720 720,960 960,1080
structure quite a bit, if

2301
01:10:21,340 --> 01:10:23,020
0,90 90,450 450,690 930,1440 1440,1680
we wanted to| {} and
|或许接下来我们应该，

2302
01:10:23,020 --> 01:10:24,490
0,300 300,750 750,990 990,1110 1110,1470
maybe subsequent {here,is} we should,|
|

2303
01:10:24,550 --> 01:10:25,720
0,600 630,780 780,930 930,1020 1020,1170
{} but this is sort
但这在某种程度上是在操作系统内核中表示数据包的标准方式。

2304
01:10:25,720 --> 01:10:26,710
0,60 60,150 150,510 510,900 900,990
of the standard way in

2305
01:10:26,710 --> 01:10:29,290
0,330 330,990 990,1410 1740,2370 2370,2580
which packets are represented in

2306
01:10:29,290 --> 01:10:30,880
0,360 360,630 630,1140
operating system kernels.|
|

2307
01:10:39,430 --> 01:10:40,840
0,270 270,690 690,930 930,1230 1230,1410
Okay, any further questions about
好的，关于这个还有什么问题吗？

2308
01:10:40,840 --> 01:10:41,720
0,270
this?|
|

2309
01:10:48,810 --> 01:10:50,160
0,900

2310
01:10:50,760 --> 01:10:51,450
0,180 180,210 210,300 300,360 360,690
So I have a choice
所以我现在有一个选择，

2311
01:10:51,450 --> 01:10:53,910
0,450 480,1260 1410,2040 2040,2190 2190,2460
now,| a couple of things
|关于网络驱动程序，我可以说几件事，

2312
01:10:53,910 --> 01:10:54,720
0,120 120,270 270,480 480,720 720,810
I could say about the

2313
01:10:54,720 --> 01:10:57,300
0,270 270,870 1140,2040 2190,2520 2520,2580
network driver,| but then I
|但是那样我就没有时间谈论mmap了。

2314
01:10:57,300 --> 01:10:58,140
0,210 210,330 330,480 480,750 750,840
won't have any time to

2315
01:10:58,140 --> 01:10:59,820
0,210 210,450 450,540 540,1200
talk about {mmap -}.|
|

2316
01:10:59,880 --> 01:11:00,780
0,270 270,390 390,540 540,720 720,900
{} I could also talk
我也可以稍微谈一下mmap，然后就到此为止，

2317
01:11:00,780 --> 01:11:01,380
0,30 30,210 210,300 300,510 510,600
a little bit about {mmap

2318
01:11:01,380 --> 01:11:03,450
0,540 570,1320 1320,1680 1680,1770 1770,2070
-} and then and stop

2319
01:11:03,450 --> 01:11:04,320
0,330
here,|
|

2320
01:11:04,500 --> 01:11:05,670
0,390 390,480 480,720 720,780 780,1170
{} in terms of talking
在与网络驱动程序对话方面。

2321
01:11:05,670 --> 01:11:07,120
0,60 60,150 150,450 450,930
to the network driver.|
|

2322
01:11:09,640 --> 01:11:11,820
0,690 870,1560
Any preferences?|
有什么喜好吗？|

2323
01:11:24,740 --> 01:11:26,280
0,300 300,960
No preferences.|
没有偏好。|

2324
01:11:31,350 --> 01:11:32,460
0,210 210,300 300,540 540,600 600,1110
Let me talk a little
让我简单介绍一下mmap，

2325
01:11:32,460 --> 01:11:33,510
0,150 150,450 450,570 570,810 810,1050
bit about {mmap -},| because
|因为有几次出现了一个问题

2326
01:11:33,510 --> 01:11:34,680
0,240 240,510 510,690 690,1080 1080,1170
there was a question that

2327
01:11:34,680 --> 01:11:35,940
0,210 210,300 300,360 360,600 600,1260
came up a couple times|
|

2328
01:11:36,330 --> 01:11:38,070
0,600 600,810 810,960 960,1080 1080,1740
and that might be worth
这可能是值得解决的问题，

2329
01:11:38,100 --> 01:11:40,640
0,630 630,1290 1380,1980
{} addressing,| {
|这几乎更多的是关于你知道mmap为什么存在的问题，

2330
01:11:40,920 --> 01:11:42,420
0,480 480,1020 1020,1290 1290,1440 1440,1500
-} it's almost more a

2331
01:11:42,420 --> 01:11:44,130
0,300 300,780 780,900 900,1200 1230,1710
question about you know why

2332
01:11:44,130 --> 01:11:47,430
0,300 300,960 1290,2190 2400,3240 3240,3300
mmap exists,| then, {} you
|那么，你实际上就知道如何实现它了。

2333
01:11:47,430 --> 01:11:48,360
0,90 90,300 300,420 420,540 540,930
know actually how to implement

2334
01:11:48,360 --> 01:11:49,020
0,180
it.|
|

2335
01:11:49,680 --> 01:11:51,330
0,270 270,660 900,1260 1260,1500 1500,1650
{} So there's no real
所以没有听起来不同的真正的反对意见，

2336
01:11:51,330 --> 01:11:53,340
0,570 570,840 840,1140 1140,1680 1710,2010
objections which sounds different,| let
|让我更多地谈谈mmap。

2337
01:11:53,340 --> 01:11:54,750
0,210 480,960 960,1020 1020,1200 1200,1410
me talk a little bit

2338
01:11:54,750 --> 01:11:56,340
0,360 360,630 630,1020
more about mmap.|
|

2339
01:11:56,750 --> 01:11:57,860
0,210 210,450 450,570 570,720 720,1110
So this is your last
因此，在下课之前，这是您最后一次询问有关网络驱动程序的问题。

2340
01:11:57,860 --> 01:11:58,880
0,240 240,360 360,570 570,690 690,1020
chance to ask any questions

2341
01:11:58,880 --> 01:12:00,260
0,150 150,210 210,450 450,930 990,1380
about the network driver until

2342
01:12:00,260 --> 01:12:01,520
0,120 120,240 240,300 300,720
the end of class.|
|

2343
01:12:06,660 --> 01:12:08,620
0,690 810,1440
Okay, {}
好的，我们来谈谈mbufs，哦，mmap。

2344
01:12:09,630 --> 01:12:11,310
0,300 300,630 630,810 810,870 870,1680
let's talk about the mbufs,

2345
01:12:11,400 --> 01:12:13,540
0,540 900,1590
oh, mmap.|
|

2346
01:12:19,070 --> 01:12:20,480
0,360 360,540 540,1080

2347
01:12:28,610 --> 01:12:30,120
0,270 270,450 450,840
Okay, so the,
好的，所以这个问题实际上与展示文件系统API有关，

2348
01:12:30,330 --> 01:12:32,370
0,630 660,990 990,1320 1320,1710 1710,2040
the question really relates to

2349
01:12:32,370 --> 01:12:33,840
0,120 120,330 330,540 540,810 810,1470
show the file system API,|
|

2350
01:12:33,990 --> 01:12:36,030
0,420 420,840 1320,1590 1590,1800 1800,2040
and so the file system
因此该文件系统具有相当广泛的API，

2351
01:12:36,030 --> 01:12:38,220
0,180 180,420 420,720 720,1290 1320,2190
has a reasonable broad API,|
|

2352
01:12:38,820 --> 01:12:41,550
0,420 420,1260 1260,1830 1830,2430 2430,2730
supporting directories, symbolic links, hard
支持目录、符号链接、硬链接等，

2353
01:12:41,550 --> 01:12:43,320
0,360 360,720 720,1110 1110,1440 1440,1770
links, etc etc,| but presumably
|但是大概主要的，它的主要部分是文件API，对不对，

2354
01:12:43,320 --> 01:12:44,430
0,60 60,600 600,690 690,900 900,1110
the main the main part

2355
01:12:44,430 --> 01:12:45,720
0,90 90,180 180,360 360,810
of it is the

2356
01:12:45,720 --> 01:12:47,070
0,90 90,570 570,990 990,1260 1260,1350
the file API, correct,| the
|文件API，您现在已经很熟悉了，

2357
01:12:47,070 --> 01:12:49,620
0,300 300,720 720,1050 1860,2160 2160,2550
file API, you're well familiar

2358
01:12:49,620 --> 01:12:52,080
0,150 150,300 300,900
to you now,|
|

2359
01:12:52,110 --> 01:12:53,680
0,300 300,390 390,1020
open the file,
打开文件，您知道，如果有一些权限，

2360
01:12:54,910 --> 01:12:56,110
0,120 120,210 210,570 600,840 840,1200
you know with {some -}

2361
01:12:56,110 --> 01:12:57,670
0,750 780,1110 1110,1320 1320,1410 1410,1560
permissions,| and once you have
|一旦你打开了文件，

2362
01:12:57,670 --> 01:12:59,200
0,270 270,390 390,1050 1290,1410 1410,1530
opened the file,| you know
|您知道，您可以使用一些数据从文件中读取数据，并将其读入缓冲区。

2363
01:12:59,200 --> 01:13:00,880
0,120 120,450 510,1110 1200,1590 1590,1680
you can read from the

2364
01:13:00,880 --> 01:13:02,020
0,570
file,

2365
01:13:04,600 --> 01:13:06,910
0,750 930,1260 1260,1350 1350,2070 2100,2310
{} into a buffer, with

2366
01:13:06,910 --> 01:13:08,440
0,330 390,960
some data.|
|

2367
01:13:08,830 --> 01:13:11,560
0,810 870,1620 1620,1980 2010,2640 2640,2730
And you can write you
你可以通过文件写下你知道的，

2368
01:13:11,560 --> 01:13:13,080
0,120 120,240 240,330 330,990
know through the file,|
|

2369
01:13:15,040 --> 01:13:16,510
0,330 330,660 660,930 930,1290 1290,1470
{} whatever file descriptor and
不管是什么文件描述符和buf，你知道的，

2370
01:13:16,510 --> 01:13:18,550
0,510 540,630 630,780 780,1410 1800,2040
buf, you know len,| so
|假设我们，然后我们可以关闭文件描述符。

2371
01:13:18,550 --> 01:13:19,960
0,180 180,390 390,840
let's say we,

2372
01:13:20,080 --> 01:13:22,210
0,810 930,1320 1320,1440 1440,1530 1530,2130
and then we can close

2373
01:13:22,690 --> 01:13:24,320
0,270 270,450 450,570 570,900
the file {descriptor -}.|
|

2374
01:13:25,070 --> 01:13:25,910
0,300 300,450 450,570 570,690 690,840
Now let's say we want
现在假设我们想要编写一个应用程序

2375
01:13:25,910 --> 01:13:27,860
0,60 60,240 240,300 300,990 1230,1950
to write an application| and
|你可以想一想，你知道，可能只是一个文件，你知道，文件通常是一个字节数组，

2376
01:13:27,860 --> 01:13:29,240
0,120 120,210 210,390 390,660 660,1380
you can think about the,

2377
01:13:30,050 --> 01:13:30,860
0,210 210,390 390,570 570,780 780,810
{you,know} may be just a

2378
01:13:30,860 --> 01:13:32,600
0,420 420,720 720,1170 1170,1440 1440,1740
file as, {} {you,know} files

2379
01:13:32,600 --> 01:13:34,520
0,420 420,600 600,1230 1470,1800 1800,1920
normally {} a array of

2380
01:13:34,520 --> 01:13:36,050
0,420 420,1050 1050,1200 1200,1410 1410,1530
bytes,| but like maybe this
|但就像这个应用程序可能有的那样，它是一个存储在其中的结构数组。

2381
01:13:36,050 --> 01:13:37,820
0,570 570,1200 1230,1440 1440,1560 1560,1770
application has sort of it's

2382
01:13:37,820 --> 01:13:38,960
0,150 150,420 420,480 480,960 960,1140
an array of struct that

2383
01:13:38,960 --> 01:13:40,280
0,90 90,450 450,570 570,750 930,1320
are stored in it.| So,
|所以，假设应用程序想要更新结构，

2384
01:13:40,830 --> 01:13:42,030
0,480 480,630 630,720 720,810 810,1200
and let's say the application

2385
01:13:42,030 --> 01:13:43,320
0,150 150,240 240,540 540,1170 1170,1290
wants to update {the,struct} {},|
|

2386
01:13:43,320 --> 01:13:44,220
0,270 270,420 420,540 540,690 690,900
so you know we have
所以你知道我们必须提交申请，

2387
01:13:44,220 --> 01:13:45,780
0,120 120,660
to file,|
|

2388
01:13:46,170 --> 01:13:47,460
0,360 360,450 450,960 960,1140 1140,1290
here's a file and so
这是一个文件，所以分成你知道的structs，

2389
01:13:47,460 --> 01:13:48,960
0,480 480,840
divided in

2390
01:13:49,240 --> 01:13:50,710
0,120 120,420 480,960 960,1170 1170,1470
you know structs,| {you,know,whatever -}
|您知道使用文件长度的任意零

2391
01:13:50,710 --> 01:13:52,210
0,300 300,720 750,1140 1140,1230 1230,1500
zero to use the file

2392
01:13:52,210 --> 01:13:54,100
0,570 570,1140 1140,1260 1260,1440 1440,1890
length| and you know we
|你知道我们可能喜欢在中间，

2393
01:13:54,550 --> 01:13:55,900
0,570 600,990 990,1200 1200,1260 1260,1350
{} maybe like in the

2394
01:13:55,900 --> 01:13:58,390
0,570 930,1320 1320,1560 1560,2130 2130,2490
middle,| let's have structure sixty
|让我们有一个60字节的结构

2395
01:13:58,390 --> 01:13:59,680
0,330 330,390 390,810 810,1200 1200,1290
bytes| or something and you
|或者别的什么，你知道我们想要更新其中的一个

2396
01:13:59,680 --> 01:14:00,790
0,120 120,240 240,450 450,720 720,1110
know we want to update

2397
01:14:00,790 --> 01:14:02,470
0,180 180,270 270,750 1050,1260 1290,1680
one of these| or maybe
|或者可能想要更新第一个。

2398
01:14:02,470 --> 01:14:03,310
0,210 210,270 270,480 480,570 570,840
want to update the first

2399
01:14:03,310 --> 01:14:03,960
0,180
one.|
|

2400
01:14:05,680 --> 01:14:06,370
0,210 210,390 390,450 450,510 510,690
And so in a way
因此，在某种程度上，我们可以正确地做到这一点，

2401
01:14:06,370 --> 01:14:07,240
0,90 90,240 240,330 330,540 540,870
we could do that correctly,|
|

2402
01:14:07,240 --> 01:14:08,620
0,240 240,780 810,1080 1080,1200 1200,1380
we read and we open
我们读，我们打开文件，我们读，你知道，第一，你知道，不管是16个字节，

2403
01:14:08,620 --> 01:14:10,030
0,90 90,720 720,900 900,1320 1320,1410
the file, we read, you

2404
01:14:10,030 --> 01:14:11,410
0,150 150,570 600,1230 1230,1290 1290,1380
know the first you know

2405
01:14:11,410 --> 01:14:13,300
0,270 270,690 690,1260
whatever sixteen bytes,|
|

2406
01:14:13,800 --> 01:14:15,180
0,420 420,510 510,1020 1020,1140 1140,1380
respond to this you know
回应这个你知道我们，

2407
01:14:15,180 --> 01:14:16,300
0,540
we,|
|

2408
01:14:16,420 --> 01:14:18,340
0,330 330,630 630,1320 1320,1410 1410,1920
let's say updates you know
假设更新您知道第一个字段结构，

2409
01:14:18,370 --> 01:14:20,890
0,180 180,810 1110,1740 1740,2310 2340,2520
the first field struct,| the
|该结构的第一个字节，您知道是1。

2410
01:14:20,890 --> 01:14:22,180
0,360 360,630 630,690 690,960 960,1290
first byte of that struct,

2411
01:14:22,180 --> 01:14:23,170
0,60 60,180 180,330 330,450 450,990
you know to be one.|
|

2412
01:14:23,880 --> 01:14:25,350
0,540 540,690 690,780 780,990 990,1470
And then we call write,
然后我们调用Write，基本上将其写回

2413
01:14:26,340 --> 01:14:27,600
0,360 360,630 630,990 990,1170 1170,1260
{} to basically write it

2414
01:14:27,600 --> 01:14:28,680
0,480 510,660 660,750 750,840 840,1080
back| and then we close
|然后我们关闭文件。

2415
01:14:28,680 --> 01:14:29,600
0,60 60,450
the file.|
|

2416
01:14:29,800 --> 01:14:30,970
0,270 270,540 540,750 750,900 900,1170
So if when is write
那么，如果何时写入发生在哪里，那么它实际写入的位置是哪里。

2417
01:14:30,970 --> 01:14:31,870
0,330 330,510 510,690 690,810 810,900
happens where, where does it

2418
01:14:31,870 --> 01:14:33,100
0,240 240,660
actually write.|
|

2419
01:14:41,090 --> 01:14:43,370
0,330 330,840 840,1110 1110,1500 1500,2280
So we've set this memory
所以我们把这个记忆放在另一个之上，

2420
01:14:43,370 --> 01:14:44,750
0,390 390,480 480,990 990,1080 1080,1380
above the one,| {you,know} will
|你知道会不会先把这个改成一，

2421
01:14:44,750 --> 01:14:45,860
0,570
this

2422
01:14:46,130 --> 01:14:47,540
0,300 300,480 480,750 750,840 840,1410
first by change to one,|
|

2423
01:14:52,140 --> 01:14:53,740
0,270 270,360 360,630 630,1020
if we call write.|
如果我们调用Write。|

2424
01:15:08,510 --> 01:15:09,530
0,180 180,450 450,510 510,720 720,1020
So, remember the file descriptor
因此，请记住，没有正确设置与之关联的文件描述符。

2425
01:15:09,530 --> 01:15:11,540
0,180 180,660 750,1320 1320,1500 1500,2010
has {not,set} associated with {it,correct}.|
|

2426
01:15:13,320 --> 01:15:15,930
0,660 690,1530 1650,2160 2160,2460 2460,2610
And reads read pushes that
然后读读将偏移量向前推，

2427
01:15:15,930 --> 01:15:17,250
0,480 480,570 570,660 660,1110 1110,1320
offset you know forward,| in
|在本例中，我们读取了16个字节，

2428
01:15:17,250 --> 01:15:18,750
0,150 150,450 450,930 930,1140 1140,1500
this case, we've read sixteen

2429
01:15:18,750 --> 01:15:19,950
0,360 360,570 570,660 660,1020 1020,1200
bytes,| {you,know} the offset goes
|你知道偏移量从0上升到16。

2430
01:15:19,950 --> 01:15:22,020
0,150 150,540 540,990 990,1410 1440,2070
from up zero to sixteen.|
|

2431
01:15:22,960 --> 01:15:23,920
0,150 150,270 270,450 450,600 600,960
And so where does write
那么写在哪里写呢，

2432
01:15:23,920 --> 01:15:24,880
0,390
write,|
|

2433
01:15:27,190 --> 01:15:28,390
0,480 480,570 570,870 870,1050 1050,1200
as you notice there's no
正如您注意到的，在write系统调用中没有偏移量参数，

2434
01:15:28,390 --> 01:15:29,620
0,630
offset

2435
01:15:29,710 --> 01:15:31,690
0,570 570,1110 1110,1350 1350,1560 1560,1980
{} argument in the write

2436
01:15:31,720 --> 01:15:33,130
0,330 330,750 780,990 990,1290 1290,1410
system call,| so where does
|那么它写在哪里。

2437
01:15:33,130 --> 01:15:34,160
0,120 120,480
it write.|
|

2438
01:15:37,070 --> 01:15:38,460
0,870
Len?|
伦？|

2439
01:15:39,180 --> 01:15:41,010
0,210 210,1050 1050,1320 1320,1530 1530,1830
{Yeah,you} will write len bytes
是的，您将在文件中写入偏移量的len字节，

2440
01:15:41,010 --> 01:15:42,420
0,330 330,750 750,870 870,960 960,1410
which offset in the file,|
|

2441
01:15:44,080 --> 01:15:45,940
0,660 660,870 870,1260 1260,1350 1350,1860
presumably len exactly at sixteen
据推测，Len正好在16点对。

2442
01:15:45,970 --> 01:15:46,920
0,390
right.|
|

2443
01:15:46,920 --> 01:15:49,140
0,600 1020,1410 1410,1650 1650,1770 1770,2220
That's write here, so which,
那就是在这里写，那么这个字节会变成一个正确的。

2444
01:15:49,320 --> 01:15:50,700
0,420 420,720 720,840 840,1230 1230,1380
this byte will change to

2445
01:15:50,700 --> 01:15:52,020
0,300 300,720
one correct.|
|

2446
01:15:54,090 --> 01:15:56,060
0,480 480,750 750,1440
Not the actual
而不是我们实际想要修改的东西。

2447
01:15:56,730 --> 01:15:57,570
0,240 240,390 390,480 480,600 600,840
thing that we are actually

2448
01:15:57,570 --> 01:15:59,000
0,210 210,270 270,900
trying to modify.|
|

2449
01:15:59,970 --> 01:16:01,280
0,150 150,240 240,390 390,720
Does that make sense?|
这说得通吗？|

2450
01:16:02,540 --> 01:16:03,710
0,210 210,390 390,600 600,870 870,1170
So the way you've written
所以你写这份申请书的方式，

2451
01:16:03,710 --> 01:16:04,730
0,150 150,630 630,690 690,900 900,1020
this application,| it turns out
|原来，曾经有一次系统调用，我们并没有太多谈论，

2452
01:16:04,730 --> 01:16:05,840
0,90 90,180 180,540 540,810 810,1110
there was once a system

2453
01:16:05,840 --> 01:16:06,680
0,210 210,360 360,450 450,630 630,840
call that we didn't really

2454
01:16:06,680 --> 01:16:07,790
0,270 270,420 420,660 660,750 750,1110
talk much about at all,|
|

2455
01:16:07,910 --> 01:16:09,410
0,420 420,660 660,960 960,1260 1260,1500
but every operating system, unix
但是每一种操作系统，Unix操作系统都被称为系统LSeek。

2456
01:16:09,410 --> 01:16:11,360
0,300 300,570 570,990 990,1680 1680,1950
operating system is called system

2457
01:16:11,360 --> 01:16:12,800
0,420 420,930
called lseek.|
|

2458
01:16:14,220 --> 01:16:15,750
0,120 120,570 570,960 960,1110 1110,1530
And lseek allows you basically
而lSeek允许您基本上将偏移量更改为某个位置。

2459
01:16:15,750 --> 01:16:17,520
0,330 330,750 750,900 900,1590 1590,1770
to change the offset to

2460
01:16:17,520 --> 01:16:18,820
0,180 180,690
some position.|
|

2461
01:16:18,850 --> 01:16:20,350
0,210 210,750 750,1050 1050,1200 1200,1500
And so in this particular
所以在这个特殊的案例中，

2462
01:16:20,350 --> 01:16:21,490
0,270 270,450 450,630 630,690 690,1140
case,| we want to do
|我们想要的效果是，我们要写这个结构，而不是那个结构。

2463
01:16:21,520 --> 01:16:23,290
0,570 840,1140 1140,1230 1230,1680 1680,1770
{} have the effect that

2464
01:16:23,290 --> 01:16:24,250
0,90 90,210 210,300 300,570 570,960
we're going to write this

2465
01:16:24,280 --> 01:16:26,140
0,390 390,690 690,870 870,1320
struct not that one.|
|

2466
01:16:26,140 --> 01:16:27,100
0,210 210,360 360,510 510,690 690,960
Then we would have said
那么我们就会说，你知道，所以你知道，基本上是将偏移量重置为，

2467
01:16:27,100 --> 01:16:28,360
0,270 270,330 330,630 630,810 810,1260
like you know, so you

2468
01:16:28,360 --> 01:16:30,190
0,90 90,600 630,1140 1140,1680 1680,1830
know zero basically resetting the

2469
01:16:30,190 --> 01:16:33,560
0,390 390,570 570,1080 1470,2340
offset to actually {}

2470
01:16:33,590 --> 01:16:35,330
0,660 690,900 900,1200 1200,1410 1410,1740
zero,| so then this write
|那么这个写操作实际上会把你现在的偏移量排序为零。

2471
01:16:35,330 --> 01:16:36,440
0,120 120,450 450,690 690,870 870,1110
would actually sort your now

2472
01:16:36,440 --> 01:16:38,100
0,390 390,1140
offset zero.|
|

2473
01:16:38,380 --> 01:16:39,700
0,150 150,420 420,600 600,870 870,1320
And then this write actually
然后这个写，实际上，你会在前16个字节写。

2474
01:16:39,700 --> 01:16:41,050
0,90 90,420 420,780 810,1230 1230,1350
you would write actually at

2475
01:16:41,050 --> 01:16:43,340
0,120 120,660 900,1350 1350,1800
the first sixteen bytes.|
|

2476
01:16:44,170 --> 01:16:45,520
0,150 150,270 270,390 390,750
Does that make sense?|
这说得通吗？|

2477
01:16:51,700 --> 01:16:52,990
0,150 150,270 270,330 330,750 750,1290
So this is slightly inconvenient
所以正确地说这有点不方便，

2478
01:16:52,990 --> 01:16:53,920
0,300 300,360 360,510 510,690 690,930
correctly,| if you think about
|如果你仔细想想，

2479
01:16:53,920 --> 01:16:55,390
0,420 600,1050 1050,1260 1260,1350 1350,1470
this,| you look at this
|你看这个界面，实际上有相当多的东西在运行，

2480
01:16:55,390 --> 01:16:56,830
0,540 540,900 900,1170 1170,1410 1410,1440
interface, there's actually quite a

2481
01:16:56,830 --> 01:16:58,000
0,120 120,180 180,420 420,630 630,1170
bit of stuff going on,|
|

2482
01:16:58,000 --> 01:16:59,080
0,90 90,180 180,270 270,660 690,1080
you know you gotta open,
你知道你得打开，你得读一读，

2483
01:16:59,080 --> 01:16:59,980
0,90 90,270 270,510 510,810 810,900
you gotta read it,| you
|你知道你可以寻找它，然后你就可以写它了。

2484
01:16:59,980 --> 01:17:00,730
0,90 90,240 240,390 390,630 630,750
know you can seek it

2485
01:17:00,730 --> 01:17:01,360
0,90 90,180 180,270 270,390 390,630
and then you can write

2486
01:17:01,360 --> 01:17:02,080
0,210
it.|
|

2487
01:17:02,310 --> 01:17:03,990
0,330 330,480 480,870 870,1200 1200,1680
And so, one reason that
因此，mmap流行的原因之一。

2488
01:17:03,990 --> 01:17:05,560
0,120 120,300 300,420 420,1020
{mmap -} is popular.|
|

2489
01:17:06,600 --> 01:17:07,440
0,360 360,480 480,600 600,780 780,840
If you can sort of
如果你能在某种程度上避免，你就会知道这些复杂的情况。

2490
01:17:07,440 --> 01:17:09,780
0,870 1050,1740 1740,1860 1860,1980 1980,2340
avoid {} you know these

2491
01:17:09,780 --> 01:17:11,340
0,180 180,1080
these complications.|
|

2492
01:17:11,460 --> 01:17:12,810
0,450 450,540 540,750 750,1020 1020,1350
Because if we write this
因为如果我们用mmap写这篇文章，

2493
01:17:12,810 --> 01:17:14,250
0,450 450,930 930,1020 1020,1230 1230,1440
using mmap,| you know, we
|你知道，我们做的FD是打开的，我们像以前一样打开文件。

2494
01:17:14,250 --> 01:17:15,840
0,270 270,480 480,870 870,1020 1020,1590
do {fd -} is open

2495
01:17:16,110 --> 01:17:17,130
0,210 210,330 330,570 570,660 660,1020
and we open the file

2496
01:17:17,130 --> 01:17:18,460
0,150 150,720
as before.|
|

2497
01:17:20,980 --> 01:17:23,110
0,180 180,810 1050,1710 1740,1980 1980,2130
And then you know we
然后你知道我们只需要给mmap打电话。

2498
01:17:23,110 --> 01:17:24,820
0,180 180,450 450,630 630,1260
just call {mmap -}.|
|

2499
01:17:26,240 --> 01:17:27,230
0,120 120,270 270,330 330,450 450,990
It's going to be whatever
不管我们的结构是什么，

2500
01:17:27,230 --> 01:17:28,490
0,150 150,600 630,990 990,1170 1170,1260
our struct,| let's say our
|让我们说我们的结构，你知道的，废话，废话，

2501
01:17:28,490 --> 01:17:29,960
0,360 360,900
struct h,

2502
01:17:30,020 --> 01:17:31,700
0,690 690,810 810,1170
{} you know,

2503
01:17:32,230 --> 01:17:33,310
0,180 180,330 330,870 900,990 990,1080
blah, blah blah,| you know
|您知道文件、读、写权限的任何链接，

2504
01:17:33,310 --> 01:17:34,990
0,630 840,1140 1140,1470 1470,1590 1590,1680
whatever some link for the

2505
01:17:34,990 --> 01:17:39,080
0,660 1170,2400 2910,3480
file, {} read,

2506
01:17:40,610 --> 01:17:43,120
0,660 1080,1830
write permissions,|
|

2507
01:17:43,530 --> 01:17:45,690
0,780 780,930 930,1020 1020,1290 1290,2160
{} you know map shared,
您知道映射共享，文件描述符为零。

2508
01:17:48,100 --> 01:17:50,920
0,360 360,510 510,780 780,1680 2040,2820
{} and file descriptor zero.|
|

2509
01:17:52,160 --> 01:17:53,990
0,210 210,750 780,1020 1020,1170 1170,1830
And then, {} so now
然后，现在基本上有了这个点，我们就在mmap中了，

2510
01:17:54,230 --> 01:17:55,700
0,660 660,780 780,930 930,1170 1170,1470
basically with this dot correct

2511
01:17:55,700 --> 01:17:56,750
0,150 150,270 270,750 750,930 930,1050
we're in mmapping,| you know
|你知道文件f在h位置，你知道在内存中。

2512
01:17:56,750 --> 01:17:58,850
0,150 150,570 570,1020 1320,2040 2040,2100
the file f at the

2513
01:17:58,850 --> 01:18:00,530
0,480 480,1080 1110,1260 1260,1470 1470,1680
location h, you know in

2514
01:18:00,530 --> 01:18:01,580
0,540
memory.|
|

2515
01:18:01,580 --> 01:18:02,930
0,300 330,720 720,810 810,960 960,1350
{} Now, we can just
现在，我们可以说h，不管第一个字节是0还是1，就像我们之前做的那样。

2516
01:18:02,930 --> 01:18:05,270
0,420 450,1110 1110,1560 1560,1830 1830,2340
say h whatever first byte

2517
01:18:05,960 --> 01:18:07,430
0,330 330,810 810,930 930,1320 1320,1470
is zero or one that

2518
01:18:07,430 --> 01:18:08,860
0,90 90,210 210,870
we did before.|
|

2519
01:18:08,980 --> 01:18:10,000
0,210 210,720 720,780 780,930 930,1020
And then you know at
然后你知道，在某种程度上，你知道，我们可以在世界地图上，

2520
01:18:10,000 --> 01:18:10,870
0,150 150,600 600,690 690,810 810,870
some point you know we

2521
01:18:10,870 --> 01:18:12,200
0,300 300,840
can munmap,|
|

2522
01:18:16,440 --> 01:18:19,160
0,480 510,1290 1320,2160
{you,know,the} munmap {}
你知道世界地图，对吧，

2523
01:18:20,690 --> 01:18:21,830
0,480 510,810 810,930 930,1050 1050,1140
h right,| and so if
|因此，如果我们思考这个问题，我们就会在记忆中寻找。

2524
01:18:21,830 --> 01:18:22,970
0,120 120,270 270,510 510,720 720,1140
we think about this, we

2525
01:18:22,970 --> 01:18:24,400
0,180 180,270 270,870
look in memory.|
|

2526
01:18:24,400 --> 01:18:25,660
0,390 420,900 900,1020 1020,1140 1140,1260
We're looking at this from
我们是从文件的角度来看这件事的，

2527
01:18:25,660 --> 01:18:26,920
0,60 60,450 450,570 570,660 660,1260
the perspective of the file,|
|

2528
01:18:27,310 --> 01:18:28,210
0,120 120,180 180,360 360,540 540,900
you know what this does
你知道这能解决什么问题，

2529
01:18:28,210 --> 01:18:29,620
0,360 360,600 600,900 900,1170 1170,1410
correct,| code literally did is
|字面意思是这样做的代码基本上就是你有一个指向这个h的指针

2530
01:18:29,620 --> 01:18:30,940
0,420 420,510 510,630 630,660 660,1320
basically you've got a pointer

2531
01:18:31,360 --> 01:18:33,040
0,120 120,510 510,1050 1410,1590 1590,1680
to this h| and you
|你可以在这里更新，你知道那件事是一对一的

2532
01:18:33,040 --> 01:18:34,330
0,120 120,270 300,780 780,1200 1200,1290
can just update here, you

2533
01:18:34,330 --> 01:18:35,560
0,150 150,390 390,600 600,690 690,1230
know that thing to one|
|

2534
01:18:35,920 --> 01:18:36,910
0,270 270,390 390,600 600,750 750,990
and be done with it
然后把它做好。

2535
01:18:36,970 --> 01:18:37,820
0,420
right.|
|

2536
01:18:38,360 --> 01:18:39,350
0,270 270,450 450,570 570,840 840,990
And so if we sort
因此，如果我们需要操纵文件结构，即位于文件内部的数据结构，

2537
01:18:39,350 --> 01:18:40,970
0,90 90,570 570,630 630,1440 1470,1620
of need to manipulate you

2538
01:18:40,970 --> 01:18:43,130
0,210 210,600 600,1230 1260,1800 1800,2160
know file structure, data structure

2539
01:18:43,130 --> 01:18:44,060
0,150 150,390 390,720 720,840 840,930
that sits inside of a

2540
01:18:44,060 --> 01:18:45,920
0,600 900,1320 1320,1500 1500,1620 1620,1860
file,| {} this {mmap -}
|这个mmap界面要方便得多。

2541
01:18:45,920 --> 01:18:47,570
0,390 390,510 510,720 720,840 840,1650
interface is much more convenient.|
|

2542
01:18:48,060 --> 01:18:49,410
0,600 630,690 690,810 810,990 990,1350
Then you know this previous
然后你知道之前的界面，我们是你知道我们必须阅读，

2543
01:18:49,410 --> 01:18:51,210
0,690 930,1470 1470,1560 1560,1710 1710,1800
interface, we're you know we

2544
01:18:51,210 --> 01:18:52,170
0,180 180,270 270,720 720,810 810,960
have to read,| you know
|你知道我们操纵了记忆你知道我们你知道我们在找回

2545
01:18:52,170 --> 01:18:54,210
0,570 720,1320 1320,1410 1410,1950 1950,2040
we manipulated the memory you

2546
01:18:54,210 --> 01:18:55,320
0,180 180,540 540,630 630,780 780,1110
know we you know {we,seek}

2547
01:18:55,320 --> 01:18:56,310
0,480 480,570 570,690 690,810 810,990
back| and then we actually
|然后我们实际写下信息。

2548
01:18:56,310 --> 01:18:57,680
0,270 270,360 360,870
write the information.|
|

2549
01:18:57,740 --> 01:18:59,060
0,330 330,750 750,870 870,1020 1020,1320
{} And in this particular
在这个特殊的案例中，

2550
01:18:59,060 --> 01:19:00,320
0,300 300,630 630,930 930,1050 1050,1260
case,| we really can think
|我们真的可以将文件看作是字节数组，

2551
01:19:00,320 --> 01:19:02,180
0,450 630,840 840,1230 1230,1380 1380,1860
about the file as being

2552
01:19:02,180 --> 01:19:03,500
0,240 240,630 630,720 720,1230 1230,1320
an array of bytes,| you
|你知道，我们可以随意书写，而不必真正导航来跳来跳去，

2553
01:19:03,500 --> 01:19:04,520
0,120 120,300 300,390 390,720 720,1020
know that we can write

2554
01:19:04,520 --> 01:19:06,440
0,240 240,600 1110,1440 1440,1680 1680,1920
willy nilly, without actually having

2555
01:19:06,440 --> 01:19:07,790
0,120 120,690 690,750 750,1020 1020,1350
to navigate to jump around,|
|

2556
01:19:11,950 --> 01:19:13,600
0,780 780,1050 1050,1260 1260,1470 1470,1650
do people see what the
人们看到mmap界面的优势了吗。

2557
01:19:13,600 --> 01:19:15,250
0,750 870,1050 1050,1260 1260,1410 1410,1650
advantage of the {mmap -}

2558
01:19:15,250 --> 01:19:16,640
0,810
interfaces.|
|

2559
01:19:23,960 --> 01:19:25,680
0,270 270,600 600,810 810,1080
Any questions about this?|
对此有什么问题吗？|

2560
01:19:28,170 --> 01:19:30,390
0,630 630,870 870,1260 1260,1920 1920,2220
Many big storage systems {}
许多大型存储系统都使用这种方式，

2561
01:19:30,390 --> 01:19:32,670
0,660 660,1350 1350,1920 1920,2190 2190,2280
use {} this,| like I
|就像我不知道，比如数据库，他们是经常使用还是不经常使用。

2562
01:19:32,670 --> 01:19:34,170
0,150 150,300 300,510 510,1380 1380,1500
don't know like databases do

2563
01:19:34,170 --> 01:19:35,250
0,150 150,360 360,570 570,690 690,1080
they use this a lot

2564
01:19:35,250 --> 01:19:37,200
0,360 360,660 660,1050 1380,1590 1590,1950
or not really.| They {use,this}
|他们经常用这个。

2565
01:19:37,200 --> 01:19:38,260
0,60 60,540
a lot.|
|

2566
01:19:38,600 --> 01:19:39,440
0,270 270,420 420,570 570,600 600,840
{} I think a lot
我认为很多应用程序都使用mmap，

2567
01:19:39,440 --> 01:19:40,850
0,60 60,600 600,930 930,1020 1020,1410
of applications use {mmap -},|
|

2568
01:19:40,880 --> 01:19:42,680
0,510 510,690 690,1500 1500,1710 1710,1800
because for these kinds of
因为对于像数据库这样的东西来说要方便得多，

2569
01:19:42,680 --> 01:19:43,730
0,300 300,480 480,540 540,930 930,1050
things like a database is

2570
01:19:43,730 --> 01:19:45,220
0,270 270,360 360,930
much more convenient,|
|

2571
01:19:47,270 --> 01:19:48,770
0,510 510,660 660,960 960,1320 1320,1500
{} then this interface, this
那么这个接口，这个接口非常正确，

2572
01:19:48,770 --> 01:19:49,850
0,360 360,450 450,780 780,1020 1020,1080
interface is great correct,| if
|如果您需要从标准输入读取，

2573
01:19:49,850 --> 01:19:50,720
0,180 180,510 510,570 570,750 750,870
you need to read from

2574
01:19:50,720 --> 01:19:52,340
0,360 360,840 960,1320 1320,1560 1560,1620
standard input,| and there's a
|有一个字节流进入，

2575
01:19:52,340 --> 01:19:53,570
0,360 360,450 450,750 750,1020 1020,1230
stream of bytes coming in,|
|

2576
01:19:53,600 --> 01:19:54,560
0,240 240,450 450,630 630,840 840,960
you read you read you
你阅读并产生一些输出，一些其他的流。

2577
01:19:54,560 --> 01:19:55,520
0,270 270,480 480,600 600,840 840,960
read and you produce some

2578
01:19:55,520 --> 01:19:58,280
0,480 480,990 990,1590 1680,2250
output {some,other} {} stream.|
|

2579
01:19:58,910 --> 01:20:00,650
0,270 270,720 720,1380 1380,1680 1680,1740
That interface that interface is
接口非常适合这里的那个接口，

2580
01:20:00,650 --> 01:20:02,240
0,210 210,570 570,660 660,990 1350,1590
very suitable for here,| you
|您不必更新偏移量，

2581
01:20:02,240 --> 01:20:03,500
0,180 180,300 300,390 390,720 720,1260
don't have to update offset,|
|

2582
01:20:03,500 --> 01:20:04,430
0,60 60,180 180,360 360,690 690,930
you know you read, get
你知道你会阅读，立即更新偏移量，

2583
01:20:04,430 --> 01:20:05,750
0,300 300,660 660,1080 1080,1170 1170,1320
offset immediately update,| you read
|你再读一遍，再读一遍，等等。

2584
01:20:05,750 --> 01:20:06,650
0,390 390,510 510,660 660,690 690,900
again, you read a bit

2585
01:20:06,650 --> 01:20:08,240
0,330 330,660 660,1110 1290,1470 1470,1590
further etc etc.| So it's
|所以它对于面向流的输入来说真的很好。

2586
01:20:08,240 --> 01:20:10,250
0,240 240,450 450,900 900,1320 1320,2010
really good for stream oriented

2587
01:20:10,760 --> 01:20:12,100
0,210 210,840
{} input.|
|

2588
01:20:12,190 --> 01:20:13,180
0,330 330,540 540,690 690,780 780,990
{} Well, this is really
嗯，这真的很不错，

2589
01:20:13,180 --> 01:20:14,230
0,270 270,360 360,450 450,660 660,1050
good,| you know if the
|你知道如果文件有数据结构，并且使用文件的一种更新基本片段，

2590
01:20:14,260 --> 01:20:17,350
0,360 360,990 1020,1410 1410,2700 2700,3090
file has data structure, and

2591
01:20:17,350 --> 01:20:18,720
0,480 480,660 660,870
{use,one,of} sort of

2592
01:20:18,810 --> 01:20:21,030
0,480 510,1050 1080,1860 1860,2160 2160,2220
{} update basic pieces of

2593
01:20:21,030 --> 01:20:22,470
0,90 90,570 570,840 840,1020 1020,1440
the file,| and you know
|你知道任意的位置。

2594
01:20:22,500 --> 01:20:24,360
0,630 630,1350
arbitrary locations.|
|

2595
01:20:32,220 --> 01:20:34,400
0,750 780,1410
Okay, {}
好的，让我想想，我要开始了，时间快用完了。

2596
01:20:36,390 --> 01:20:38,580
0,330 330,690 720,1440 1770,2130 2130,2190
let's see, I'm going to

2597
01:20:38,580 --> 01:20:40,260
0,270 270,1110
start on

2598
01:20:40,500 --> 01:20:41,190
0,270 270,360 360,540 540,630 630,690
about to run out of

2599
01:20:41,190 --> 01:20:43,200
0,480 720,1470
time {}.|
|

2600
01:20:43,270 --> 01:20:45,000
0,300 300,420 420,750 750,1170
So let me {}
所以让我停在这里，

2601
01:20:45,000 --> 01:20:46,620
0,510 540,900 900,1200 1200,1470 1470,1620
so stop here,| hopefully this
|希望这篇关于mmap的小道消息，

2602
01:20:46,620 --> 01:20:48,750
0,540 900,1320 1320,1620 1620,1740 1740,2130
one tidbit about {mmap -},|
|

2603
01:20:48,750 --> 01:20:50,580
0,60 60,300 300,480 510,1290 1290,1830
you know it's useful to
你知道知道这一点很有用，

2604
01:20:50,610 --> 01:20:53,380
0,540 930,1440 1440,1860 1860,2130
know,| {} and {}
|告诉你为什么你知道这是一个很受欢迎的计划。

2605
01:20:53,380 --> 01:20:54,430
0,180 180,300 300,600 600,870 870,1050
tells you why you know

2606
01:20:54,430 --> 01:20:55,330
0,270 270,420 420,660 660,840 840,900
that sort of is a

2607
01:20:55,330 --> 01:20:57,240
0,750 750,1320
popular scheme.|
|

2608
01:20:57,240 --> 01:20:58,380
0,570

2609
01:21:00,080 --> 01:21:02,030
0,390 390,630 630,930 960,1470 1470,1950
{} Let's see,| {} so
让我们看看,|所以我，我想实际上你知道，我们基本上这堂课快结束了

2610
01:21:02,060 --> 01:21:03,470
0,210 210,420 420,660 660,1050 1050,1410
I I think that actually

2611
01:21:03,470 --> 01:21:04,940
0,60 60,210 210,480 480,930 960,1470
you know we were basically

2612
01:21:04,940 --> 01:21:05,870
0,120 120,300 300,480 480,840 840,930
we come to the end

2613
01:21:05,870 --> 01:21:07,160
0,90 90,240 240,690 720,1170 1170,1290
of this lecture| and I
|我猜6的末尾是6，6,081

2614
01:21:07,160 --> 01:21:08,560
0,210 210,330 330,510 510,840
guess the end of

2615
01:21:08,710 --> 01:21:10,140
0,660
{

2616
01:21:12,580 --> 01:21:13,240
0,150 150,240 240,360 360,450 450,660
-} the end of six

2617
01:21:13,240 --> 01:21:15,490
0,150 150,480 480,810 1500,2040 2040,2250
{} the six {6.S081 -

2618
01:21:15,490 --> 01:21:17,860
0,120 120,510 540,900 900,1350 1740,2370
- -}| and so again
|所以你再一次知道，如果你没有填写反馈调查，

2619
01:21:17,860 --> 01:21:18,670
0,150 150,270 270,360 360,660 660,810
you know if you have

2620
01:21:18,670 --> 01:21:20,860
0,270 270,510 510,720 720,1620
not filled out the

2621
01:21:20,860 --> 01:21:22,480
0,360 360,930 930,1080 1080,1380 1380,1620
feedback survey,| you know {}
|你知道请这样做，

2622
01:21:22,510 --> 01:21:24,760
0,360 360,1080 1530,1770 1770,2130 2160,2250
please {} do so,| you
|你知道，如果你能填一下科目评估，我们会很感激的。

2623
01:21:24,760 --> 01:21:26,740
0,210 210,990 990,1650 1650,1740 1740,1980
know we appreciate if you

2624
01:21:26,740 --> 01:21:28,300
0,270 270,390 390,480 480,840 840,1560
fill out the subject evaluation.|
|

2625
01:21:29,180 --> 01:21:30,920
0,660 660,840 840,1170 1170,1290 1290,1740
And and again I wanna
我再一次感谢你们的关注，

2626
01:21:31,160 --> 01:21:32,820
0,300 300,540 540,1050
thank you for

2627
01:21:33,060 --> 01:21:34,710
0,240 240,390 390,1020 1050,1530 1530,1650
{} your attention,| again it
|这又是一个奇怪的学期，

2628
01:21:34,710 --> 01:21:36,330
0,90 90,150 150,510 510,1110 1170,1620
is a strange semester {},|
|

2629
01:21:36,330 --> 01:21:37,290
0,180 180,600 630,720 720,870 870,960
I wish I could have
我希望我能亲自见到你们所有人。

2630
01:21:37,290 --> 01:21:38,400
0,180 180,330 330,510 510,600 600,1110
met you all in person.|
|

2631
01:21:39,620 --> 01:21:41,450
0,150 150,240 240,540 540,1050 1080,1830
Talk to you {} {in,person}
无论是上课还是课前或课后都可以和你面谈，

2632
01:21:41,450 --> 01:21:42,980
0,420 420,810 810,870 870,1200 1200,1530
either class or before class

2633
01:21:42,980 --> 01:21:45,800
0,120 120,390 390,900 1260,2040 2040,2820
or after class,| {} and
|不幸的是，正如它所发生的那样，

2634
01:21:46,280 --> 01:21:47,640
0,810
unfortunately,

2635
01:21:47,870 --> 01:21:49,850
0,210 210,300 300,780 810,1710 1770,1980
as it happened,| {} but
|但我希望你能拿到相当多的6.S081

2636
01:21:49,850 --> 01:21:51,410
0,120 120,480 480,900 930,1380 1380,1560
I hope you got quite

2637
01:21:51,410 --> 01:21:52,940
0,30 30,180 180,690 690,1020 1020,1530
a bit of {} 6.S081|
|

2638
01:21:52,940 --> 01:21:54,560
0,270 630,810 810,1110 1110,1350 1350,1620
and {} certainly {with,the} staff
当然还有工作人员，感谢你们的订婚，

2639
01:21:54,560 --> 01:21:55,460
0,210 210,480 480,690 690,780 780,900
and {} thank you for

2640
01:21:55,460 --> 01:21:57,260
0,90 90,660 750,1320 1320,1560 1560,1800
the engagement,| {} you guys
|这学期你们都表现得很棒。

2641
01:21:57,260 --> 01:21:59,060
0,90 90,390 390,930 1020,1350 1350,1800
have been wonderful this semester.|
|

2642
01:21:59,860 --> 01:22:01,320
0,300 300,450 450,900
So with that,
到此为止，谢谢你。

2643
01:22:01,320 --> 01:22:02,320
0,150 150,480
thank you.|
|

2644
01:22:03,150 --> 01:22:04,020
0,120 120,240 240,360 360,510 510,870
If you have any questions,
如果你有任何问题，请不要离开。

2645
01:22:04,020 --> 01:22:05,940
0,210 210,810 810,1140
please hang around.|
|

2646
01:22:06,550 --> 01:22:07,600
0,180 180,300 300,690 750,960 960,1050
But I'm sure some of
但我相信你们中的一些人有最后期限。

2647
01:22:07,600 --> 01:22:09,160
0,120 120,240 240,900
you have deadlines.|
|

2648
01:22:10,100 --> 01:22:11,480
0,390 390,540 540,870 870,990 990,1380
Honestly on behalf of the
老实说，我也代表助教，

2649
01:22:11,750 --> 01:22:13,130
0,510 510,630 630,930 930,1110 1110,1380
TAs as well,| we've really
|我们真的很享受在上班时间和你们一起结账的时光，

2650
01:22:13,130 --> 01:22:15,320
0,780 1140,1650 1710,1920 1920,1980 1980,2190
enjoyed {} all the time

2651
01:22:15,320 --> 01:22:16,160
0,90 90,330 330,420 420,540 540,840
we spent with you guys

2652
01:22:16,160 --> 01:22:17,450
0,90 90,420 420,930 930,1050 1050,1290
in office hours and doing

2653
01:22:17,450 --> 01:22:18,470
0,300 300,660 660,750 750,900 900,1020
check offs,| and this is
|这是第一学期，我们做了检查

2654
01:22:18,470 --> 01:22:19,670
0,90 90,330 330,750 750,960 960,1200
the first semester, we've done

2655
01:22:19,670 --> 01:22:20,750
0,240 240,540 540,660 660,810 810,1080
check offs| and then David
|然后大卫和我都觉得这是一个非常愉快的过程

2656
01:22:20,750 --> 01:22:22,310
0,90 90,210 210,750 840,1470 1470,1560
and I both found it

2657
01:22:22,310 --> 01:22:23,870
0,60 60,240 240,690 690,1290 1290,1560
a really enjoyable process| and
|你们知道，希望我们能帮你们摆脱困境，并进行一些愉快的交谈，

2658
01:22:23,900 --> 01:22:24,680
0,90 90,210 210,540 540,660 660,780
you know hopefully we were

2659
01:22:24,680 --> 01:22:26,420
0,240 240,690 1020,1320 1320,1440 1440,1740
able to help you guys

2660
01:22:26,420 --> 01:22:27,530
0,480 480,630 630,810 810,960 960,1110
out and have some good

2661
01:22:27,530 --> 01:22:29,330
0,690 690,810 810,1080 1080,1410 1500,1800
conversations,| as well so thanks
|我也很感谢你让这学期过得很棒

2662
01:22:29,330 --> 01:22:30,050
0,120 120,360 360,450 450,510 510,720
for making it a great

2663
01:22:30,050 --> 01:22:31,760
0,480 480,720 840,1470 1470,1620 1620,1710
semester| and adjusting on the
|和我们一起调整飞翔，解决所有的远程学习问题，

2664
01:22:31,760 --> 01:22:32,960
0,330 330,450 450,780 780,960 960,1200
fly with us with all

2665
01:22:32,960 --> 01:22:34,120
0,120 120,390 390,780
of the {}

2666
01:22:34,180 --> 01:22:36,280
0,420 420,780 780,1170 1170,1590 1620,2100
remote learning problems,| we've run
|我们遇到并不得不面对完成这一课程的绝对乐趣。

2667
01:22:36,280 --> 01:22:37,360
0,450 450,600 600,780 780,840 840,1080
into and had to deal

2668
01:22:37,360 --> 01:22:39,310
0,390 660,930 930,1320 1320,1620 1620,1950
with an absolute pleasure achieving

2669
01:22:39,310 --> 01:22:40,420
0,150 150,660
this course.|
|

2670
01:22:46,360 --> 01:22:48,960
0,180 180,390 390,960
Any further questions?|
还有什么问题吗？|

2671
01:22:49,170 --> 01:22:50,280
0,450 450,600 600,780 780,930 930,1110
Again, feel free to hang
再说一次，你可以随便闲逛。

2672
01:22:50,280 --> 01:22:51,320
0,390
around.|
|

2673
01:23:00,530 --> 01:23:02,270
0,420 420,930 1080,1260 1260,1590 1590,1740
Oh, {} I had a
哦，我有个问题，

2674
01:23:02,270 --> 01:23:04,960
0,990 1530,2160
question,| so,
|所以，哦，是的，非常感谢你的课，我真的很喜欢这门课，这是最好的一学期，

2675
01:23:05,020 --> 01:23:06,910
0,630 690,1200 1230,1470 1470,1680 1680,1890
it's it's oh yeah, thank

2676
01:23:06,910 --> 01:23:07,480
0,90 90,210 210,390 390,510 510,570
you so much for the

2677
01:23:07,480 --> 01:23:09,250
0,330 330,600 630,900 900,1170 1170,1770
class, I really like class,

2678
01:23:09,280 --> 01:23:11,500
0,120 120,360 360,720 720,1440 1530,2220
the best class semester {},|
|

2679
01:23:11,620 --> 01:23:13,420
0,300 300,660 660,780 780,1110 1110,1800
I wanted to ask about
我想问一下中断的情况，收到的中断，

2680
01:23:13,660 --> 01:23:16,210
0,510 510,1350 1350,1470 1470,1830 1830,2550
the interrupts, the received interrupts,|
|

2681
01:23:16,270 --> 01:23:18,250
0,300 300,660 660,1260 1560,1830 1830,1980
how does the how does
硬件如何知道软件何时完成，

2682
01:23:18,250 --> 01:23:19,940
0,150 150,600 600,1290
the hardware knows

2683
01:23:19,970 --> 01:23:21,160
0,690
when

2684
01:23:21,450 --> 01:23:23,160
0,270 270,360 360,750 750,1020 1020,1710
when the software has finished,|
|

2685
01:23:24,130 --> 01:23:26,410
0,240 240,930 1170,1320 1320,1680 1680,2280
{} handling the previous interrupt,
处理上一个中断，而不是发出另一个中断。

2686
01:23:26,410 --> 01:23:28,480
0,330 360,780 780,1080 1080,1560
not issue another one.|
|

2687
01:23:28,800 --> 01:23:32,220
0,540 540,1800 1830,2580 2580,2940 2940,3420
Because the there's multiple steps,|
因为有多个步骤，|

2688
01:23:32,880 --> 01:23:35,400
0,600 600,1200 1200,1950 2250,2400 2400,2520
{} one is you know
一是你知道你看到的是底部的E1000，

2689
01:23:35,400 --> 01:23:36,740
0,150 150,780
you're looking

2690
01:23:40,480 --> 01:23:42,430
0,540 540,780 780,1620 1650,1860 1860,1950
{e1000 - -} at the

2691
01:23:42,430 --> 01:23:45,010
0,600 990,1560 1560,1710 1710,2040 2040,2580
bottom,| we {re-enable -} interrupts
|我们重新启用中断，或者我们告诉卡片，我们已经准备好接收进一步的中断。

2692
01:23:45,400 --> 01:23:46,420
0,180 180,270 270,510 510,570 570,1020
or we tell the card,

2693
01:23:46,420 --> 01:23:47,590
0,300 300,540 540,630 630,930 930,1170
we're ready to receive further

2694
01:23:47,590 --> 01:23:48,580
0,480
interrupts.|
|

2695
01:23:49,170 --> 01:23:50,910
0,150 150,330 330,570 570,1050 1080,1740
So that's why we {}
这就是我们告诉卡产生中断的原因，

2696
01:23:50,910 --> 01:23:51,810
0,120 120,210 210,390 390,510 510,900
tell the card to generate

2697
01:23:51,810 --> 01:23:53,280
0,510 960,1050 1050,1290 1290,1350 1350,1470
interrupts,| of course at this
|当然，在这一点上，中断实际上并没有真正打开，

2698
01:23:53,280 --> 01:23:54,720
0,270 270,570 570,810 810,1230 1230,1440
point interrupts actually not really

2699
01:23:54,720 --> 01:23:55,830
0,240 240,690 690,840 840,930 930,1110
turned on,| and we just
|我们只需告诉卡片，您可以再次生成中断。

2700
01:23:55,830 --> 01:23:56,640
0,240 240,300 300,600 600,690 690,810
tells the card you can

2701
01:23:56,640 --> 01:23:58,280
0,360 360,720 720,1080
generate interrupts again.|
|

2702
01:23:58,280 --> 01:24:00,080
0,630 900,1080 1080,1410 1410,1590 1590,1800
{} The interrupts get turned
中断被正确打开，

2703
01:24:00,080 --> 01:24:01,340
0,300 300,630 630,990 1020,1140 1140,1260
on correct,| like you know
|正如您知道这些函数一样，您知道中断启用

2704
01:24:01,340 --> 01:24:02,750
0,420 420,510 510,630 630,810 810,1410
by you know these functions,

2705
01:24:02,750 --> 01:24:05,090
0,60 60,210 210,810 870,1560 1980,2340
you know interrupt enable| and
|在这一点上，如果您打开中断启用，

2706
01:24:05,090 --> 01:24:06,110
0,90 90,270 270,660 660,840 840,1020
at that point, if you

2707
01:24:06,110 --> 01:24:08,930
0,240 240,360 360,1170 1170,2580 2610,2820
turn on {interrupt,enable},| if this
|如果设置了此字段，再加上您知道启用中断的位置

2708
01:24:08,930 --> 01:24:10,760
0,330 330,750 960,1590 1590,1680 1680,1830
field set, plus you know

2709
01:24:10,760 --> 01:24:11,690
0,120 120,420 420,570 570,720 720,930
the point where you turn

2710
01:24:11,690 --> 01:24:13,130
0,180 180,480 480,930 960,1140 1140,1440
on interrupt enable| and actually
|实际上中断可能会再次发生。

2711
01:24:13,130 --> 01:24:14,780
0,480 480,690 690,900 900,1200
interrupt might happen again.|
|

2712
01:24:15,680 --> 01:24:17,210
0,480 600,780 780,1110 1110,1320 1320,1530
Right, I forgot about this
好的，我忘了这个收银机了，非常感谢。

2713
01:24:17,210 --> 01:24:18,680
0,570 570,780 780,870 870,1020 1020,1470
register, thank you so much.|
|

2714
01:24:18,680 --> 01:24:19,460
0,90 90,270 270,480 480,600 600,780
Yeah, it's just like one
是的，就像一条指令，很容易漏掉。

2715
01:24:19,460 --> 01:24:23,220
0,510 2220,2730 2730,2820 2820,3210
instruction, easy to miss.|
|

2716
01:24:25,960 --> 01:24:27,340
0,180 180,300 300,810
Any other questions?|
还有其他问题吗？|

2717
01:24:30,500 --> 01:24:32,440
0,510 510,660 660,990
Thank you all.|
谢谢大家。|

2718
01:24:32,580 --> 01:24:34,040
0,360 360,510 510,900
Thank you, okay.|
谢谢你，好的。|

2719
01:24:36,520 --> 01:24:37,960
0,450 450,900
Thank you.|
谢谢。|

2720
01:24:38,770 --> 01:24:40,500
0,450 450,1080
Thank you.|
谢谢。|

2721
01:24:40,910 --> 01:24:43,000
0,180 180,300 300,420 420,930
Thank you so much.
非常感谢。
