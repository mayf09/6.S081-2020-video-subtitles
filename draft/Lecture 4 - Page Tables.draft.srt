1
00:00:00,000 --> 00:00:02,070
0,270 270,720 750,1200 1440,1920 1920,2070
Sound check, can everybody hear
声音检查，大家能听到我说话吗？

2
00:00:02,070 --> 00:00:03,000
0,360
me?|
|

3
00:00:04,690 --> 00:00:08,260
0,510 1110,1830 2040,2640 3090,3360 3360,3570
Yep. Yep. Okay.| okay, so
是的。是的。好的。|好的，欢迎收听 6.S081 的下一节课，

4
00:00:08,260 --> 00:00:09,910
0,510 510,990 990,1080 1080,1290 1290,1650
welcome to the next lecture

5
00:00:09,910 --> 00:00:11,830
0,150 150,240 240,660 660,1080 1260,1920
in the {6.S081 -} {},|
|

6
00:00:11,860 --> 00:00:14,110
0,390 390,570 570,990 1170,1230 1260,2250
wherever you are, in particular,
无论你在哪里，特别是，我希望西海岸，佛罗里达和阿拉巴马的人们都还好，

7
00:00:14,740 --> 00:00:15,550
0,120 120,300 300,420 420,510 510,810
I hope that the folks

8
00:00:15,550 --> 00:00:16,600
0,90 90,180 180,390 390,780 780,1050
on the west coast or

9
00:00:16,600 --> 00:00:18,310
0,150 150,780 780,960 1020,1560 1560,1710
in Florida and Alabama do

10
00:00:18,310 --> 00:00:20,620
0,540 600,990 990,1140 1140,1380 1410,2310
okay,| you know the terrible
|你知道那边的情况很糟糕。

11
00:00:20,680 --> 00:00:22,380
0,750 750,1110
circumstances there.|
|

12
00:00:24,140 --> 00:00:25,820
0,660 750,1110 1110,1260 1260,1560 1560,1680
So, {} the topic for
所以今天的主题是虚拟内存，

13
00:00:25,820 --> 00:00:28,280
0,540 540,1080 1410,1740 1740,2010 2010,2460
today, where is virtual memory,|
|

14
00:00:28,310 --> 00:00:29,450
0,720 720,780 780,900 900,960 960,1140
particularly we're going to talk
特别地，我们会讨论页表，

15
00:00:29,450 --> 00:00:31,340
0,210 210,480 480,1080 1110,1590 1590,1890
about page tables,| we'll return
|我们会多次回到这个主题，

16
00:00:31,340 --> 00:00:32,870
0,90 90,240 240,780 810,1260 1290,1530
to this topic a few

17
00:00:32,870 --> 00:00:34,070
0,480 480,570 570,690 690,810 810,1200
times,| there will be multiple
|会有多次关于这个的讲座。

18
00:00:34,070 --> 00:00:35,640
0,330 330,570 570,1080
{[] -} lectures.|
|

19
00:00:36,030 --> 00:00:37,800
0,420 600,930 930,1230 1230,1500 1500,1770
And maybe just start off
或许我们可以再次从回答问题开始，

20
00:00:37,800 --> 00:00:39,300
0,240 240,420 420,630 630,990 1020,1500
and {you,know} get our question

21
00:00:39,300 --> 00:00:41,920
0,390 390,660 660,1080 1380,2010
answer going again {},|
|

22
00:00:42,130 --> 00:00:43,120
0,30 180,390 390,570 570,660 660,990
I would like to ask
我的问题是，通过 6.004 或 6.033 课程，你对虚拟内存有什么印象。

23
00:00:43,120 --> 00:00:43,960
0,180 180,240 240,450 450,720 720,840
you a little bit, what

24
00:00:43,960 --> 00:00:45,910
0,60 60,150 150,720 720,1350 1380,1950
do you remember from {}

25
00:00:45,910 --> 00:00:47,620
0,270 270,540 540,810 810,1230 1260,1710
about virtual memory from {6.004

26
00:00:47,620 --> 00:00:49,810
0,300 300,780 780,1290 1830,2010 2010,2190
-} maybe from {6.033 -

27
00:00:49,810 --> 00:00:51,280
0,600 600,720 720,870 870,1140 1140,1470
-} if you're taking that.|
|

28
00:00:51,880 --> 00:00:53,440
0,510 600,1050 1050,1260 1260,1380 1380,1560
{} I'll tell you my
我会先说一下自己对虚拟内存的看法，

29
00:00:53,440 --> 00:00:54,670
0,330 330,540 540,600 600,930 930,1230
own sort of view on

30
00:00:54,670 --> 00:00:56,170
0,330 330,660 660,870 870,1200 1200,1500
virtual memory,| which is when
|当我第一次学习它，还是一个学生的时候，

31
00:00:56,170 --> 00:00:56,860
0,60 60,330 330,420 420,570 570,690
I took it, to {}

32
00:00:56,860 --> 00:00:57,850
0,300 300,510 510,780 780,900 900,990
first learned about it, {}

33
00:00:57,850 --> 00:00:58,540
0,210 210,450 450,510 510,630 630,690
learned about it as a

34
00:00:58,540 --> 00:01:00,130
0,480 690,930 930,1230 1230,1320 1320,1590
student,| I thought it was
|我想它是很直接的，能有多难，

35
00:01:00,130 --> 00:01:01,330
0,210 210,960 960,1050 1050,1140 1140,1200
pretty straightforward, you know how

36
00:01:01,330 --> 00:01:02,200
0,240 240,330 330,420 420,660 660,870
hard can it be,| it's
|就是一个表将虚拟地址映射到物理地址。

37
00:01:02,200 --> 00:01:04,150
0,60 60,480 480,1020 1080,1620 1620,1950
a table that maps virtual

38
00:01:04,150 --> 00:01:05,820
0,300 300,390 390,720 720,1320
addresses to physical addresses,|
|

39
00:01:05,880 --> 00:01:07,110
0,210 210,720 750,870 870,1020 1020,1230
{ -} you know maybe
或许有点复杂，但不是那么复杂，

40
00:01:07,110 --> 00:01:08,640
0,90 90,270 270,480 480,1020 1020,1530
a little more complicated, but

41
00:01:08,880 --> 00:01:10,980
0,630 630,810 810,1440 1650,1980 1980,2100
not that complicated,| only when
|只有当用它编程时，我才知道虚拟内存是巧妙的，迷人的，非常强大。

42
00:01:10,980 --> 00:01:12,330
0,90 90,300 300,900 900,1050 1050,1350
you start programming with it

43
00:01:12,570 --> 00:01:14,970
0,210 210,450 450,870 870,1500 1530,2400
I should really learned that

44
00:01:15,000 --> 00:01:17,280
0,180 180,450 450,510 510,1050 1080,2280
virtual memory is tricky and

45
00:01:17,310 --> 00:01:18,560
0,720
fascinating,

46
00:01:18,740 --> 00:01:21,280
0,540 600,1380 1380,1950
{} very powerful.|
|

47
00:01:21,430 --> 00:01:23,290
0,540 570,780 780,1320 1500,1770 1770,1860
And so hopefully in the
所以我希望在后面的课程和实验中，你们能从这个角度理解虚拟内存。

48
00:01:23,290 --> 00:01:25,090
0,540 540,1080 1080,1230 1230,1680 1680,1800
next couple of lectures, in

49
00:01:25,090 --> 00:01:26,050
0,90 90,270 270,510 510,570 570,960
the next couple of labs,

50
00:01:26,050 --> 00:01:29,110
0,570 570,1080 1710,2160 2160,2760 2790,3060
you you'll know appreciate {}

51
00:01:29,110 --> 00:01:30,610
0,270 270,540 540,690 690,870 870,1500
virtual memory from that perspective.|
|

52
00:01:30,760 --> 00:01:31,960
0,630 630,750 750,810 810,1050 1050,1200
We want to ask me
我们会对在线的一些人进行提问，

53
00:01:31,960 --> 00:01:33,100
0,60 60,270 270,540 540,960 960,1140
a couple people here that

54
00:01:33,100 --> 00:01:34,300
0,180 180,690 690,780 780,900 900,1200
are online,| you know what
|通过 6.004 或 6.033 课程，你对虚拟内存有什么印象。

55
00:01:34,300 --> 00:01:35,740
0,60 60,150 150,660 720,1230 1230,1440
do you remember {} about

56
00:01:35,740 --> 00:01:37,750
0,270 270,780 1050,1320 1350,1620 1620,2010
virtual memory from either {6.004

57
00:01:37,750 --> 00:01:39,520
0,420 420,810 1020,1320 1320,1410 1410,1770
-} or 6.033 you take

58
00:01:39,520 --> 00:01:40,220
0,300
it.|
|

59
00:01:40,340 --> 00:01:41,360
0,330 330,450 450,630 630,780 780,1020
Again, I'm just gonna call
同样，我会点名，然后你分享自己的印象。

60
00:01:41,360 --> 00:01:42,860
0,150 150,630 630,900 1110,1290 1290,1500
some names and you know

61
00:01:44,520 --> 00:01:47,070
0,360 360,1020 1050,1800 1830,2100 2100,2550
share your memories about the.|
|

62
00:01:47,100 --> 00:01:48,760
0,540 570,1140
Adela Yang.|
Adela Yang.|

63
00:01:53,360 --> 00:01:55,250
0,390 390,600 600,690 690,1140 1590,1890
Sorry, what's the question?| What
不好意思，问题是什么？|通过 6.004 或 6.033 课程，你对虚拟内存有什么印象。

64
00:01:55,250 --> 00:01:57,380
0,60 60,120 120,840 930,1650 1650,2130
do you remember {} about

65
00:01:57,410 --> 00:01:58,940
0,420 420,780 780,960 960,1170 1170,1530
virtual memory from maybe {6.004

66
00:01:58,940 --> 00:02:00,620
0,390 390,780 900,1530 1530,1620 1620,1680
-} or 6.033, if you

67
00:02:00,620 --> 00:02:01,780
0,90 90,300 300,600
have taken that.|
|

68
00:02:02,020 --> 00:02:05,110
0,750 1170,1830 1830,2130 2160,2760 2760,3090
It uses like offset to
它使用偏移来保存虚拟地址到物理地址的映射。

69
00:02:05,110 --> 00:02:07,690
0,330 330,480 480,1170 1200,2250 2250,2580
save on like remembering virtual

70
00:02:07,690 --> 00:02:09,700
0,660 690,930 930,1440 1440,1770 1770,2010
address to physical address map

71
00:02:09,700 --> 00:02:11,500
0,450
things.|
|

72
00:02:11,650 --> 00:02:14,470
0,660 660,1260 1410,2250 2250,2670 2670,2820
Okay, how about {Abraham -}
好的， Abraham Caldera 。

73
00:02:14,470 --> 00:02:15,660
0,210 210,720
{Caldera -}.|
|

74
00:02:20,040 --> 00:02:21,600
0,300 300,600 660,780 780,900 900,1560
{Abraham -}, are you online?|
Abraham ，你在线吗？|

75
00:02:23,230 --> 00:02:24,820
0,510 600,900 900,1140 1140,1500 1500,1590
Yeah, {} my memory is
是的，我的印象是，它使用了一种[间接]表示的方法来保护物理硬件，

76
00:02:24,820 --> 00:02:26,960
0,150 150,330 330,810 1080,1590
that it uses {},

77
00:02:26,960 --> 00:02:28,490
0,240 240,330 330,570 570,870 1290,1530
it's a way of one

78
00:02:28,490 --> 00:02:30,650
0,540 540,780 780,1080 1080,1560 1560,2160
protecting the physical hardware by

79
00:02:32,020 --> 00:02:33,790
0,90 90,840 900,1470 1470,1530 1530,1770
{kind,of} [] representation of it,|

80
00:02:34,480 --> 00:02:35,320
0,270 270,390 390,570 570,690 690,840
and then yeah you can
还有，使用 44 位的虚拟地址映射到 64 位的物理地址。

81
00:02:35,320 --> 00:02:37,330
0,330 480,900 900,1230 1230,1560 1740,2010
{have,like} some virtual address things

82
00:02:37,330 --> 00:02:38,360
0,210
like

83
00:02:38,360 --> 00:02:40,310
0,270 270,450 450,720 720,1230 1620,1950
[] in {44 -} of

84
00:02:40,310 --> 00:02:42,620
0,210 990,1440 1440,1620 1620,1920 1920,2310
bit, maps some physical address,

85
00:02:43,520 --> 00:02:44,990
0,240 240,420 810,1140 1140,1200 1200,1470
{} that's usually I think

86
00:02:44,990 --> 00:02:47,840
0,450 450,900 1020,1260 1680,2040
64 bits in fact.|
|

87
00:02:48,100 --> 00:02:49,240
0,570
{Okay,good},
好的， Bibic Pendant 。

88
00:02:50,540 --> 00:02:52,760
0,870 1200,1320 1320,1590 1590,1830 1830,2220
{} how about {} Bibic

89
00:02:52,760 --> 00:02:53,880
0,540
Pendant.|
|

90
00:02:55,440 --> 00:02:56,720
0,660

91
00:02:56,750 --> 00:02:58,640
0,300 300,450 450,840 840,1290 1320,1890
What I remember was {}
我的印象是每个进程可以有独立的地址空间，

92
00:02:59,160 --> 00:03:00,680
0,240 240,360 360,1050
you can have,

93
00:03:00,830 --> 00:03:02,780
0,480 480,690 690,1290 1290,1740 1770,1950
{} each process has a

94
00:03:02,780 --> 00:03:04,620
0,420 450,810 810,1380
separate address space,|
|

95
00:03:04,620 --> 00:03:06,160
0,450 450,990
and, {
还有，内存管理单元或者其他技术

96
00:03:06,220 --> 00:03:07,300
0,510
-}

97
00:03:07,300 --> 00:03:09,040
0,60 60,420 420,960 960,1350 1350,1740
the memory management unit or

98
00:03:09,040 --> 00:03:10,120
0,30 30,240 240,420 420,660 660,1080
I mean some other technique|
|

99
00:03:10,120 --> 00:03:11,440
0,240 240,360 360,720 720,810 810,1320
can be used to map
可以用来映射每个进程虚拟空间的虚拟地址到物理地址。

100
00:03:11,830 --> 00:03:13,660
0,420 420,630 630,1020 1020,1500 1500,1830
{} the virtual addresses of

101
00:03:13,810 --> 00:03:15,160
0,150 150,450 450,990 1020,1200 1200,1350
the address space of each

102
00:03:15,160 --> 00:03:16,300
0,120 120,240 240,870 870,1020 1020,1140
of the processes to the

103
00:03:16,300 --> 00:03:17,380
0,630
physical

104
00:03:17,380 --> 00:03:19,740
0,540 720,1260 1260,1830
{} physical address,|
|

105
00:03:20,040 --> 00:03:23,700
0,930 960,1500 2010,2880 2880,3270 3270,3660
and the virtual address that
而且虚拟地址的低位是相同的，

106
00:03:23,700 --> 00:03:25,500
0,180 180,570 570,1080 1350,1590 1590,1800
the lower bits are kind

107
00:03:25,500 --> 00:03:26,490
0,60 60,150 150,420 420,570 570,990
of the same,| so that,
|所以，映射是以块位单位的，这能够提高性能。

108
00:03:26,550 --> 00:03:28,710
0,300 300,600 630,1350 1380,2010 2010,2160
{} the the mapping is

109
00:03:28,710 --> 00:03:31,230
0,150 150,810 900,1800 1830,2370 2370,2520
in blocks which helps with

110
00:03:31,230 --> 00:03:32,360
0,720
performance.|
|

111
00:03:33,880 --> 00:03:35,880
0,930 930,1590
Wiseley Wu.|
Wiseley Wu.|

112
00:03:39,580 --> 00:03:41,860
0,1530
Yeah,
是的，我印象最深的是虚拟地址允许我们保护每个进程的物理地址，

113
00:03:41,860 --> 00:03:42,640
0,180 180,270 270,390 390,540 540,780
yeah I guess what I

114
00:03:42,640 --> 00:03:44,350
0,300 300,630 630,750 750,1080 1080,1710
remember most is that virtual

115
00:03:44,380 --> 00:03:46,930
0,570 570,900 900,1140 1140,1740 2010,2550
address allows us to {}

116
00:03:47,760 --> 00:03:50,310
0,210 210,720 750,1410 1410,2010 2010,2550
yeah protect physical addresses from

117
00:03:50,310 --> 00:03:52,560
0,120 120,840 1320,1710 1710,1800 1800,2250
each process| and we can
|而且我们可以使用一些巧妙的操作，让物理地址上对应的位也可以在虚拟地址上使用。

118
00:03:52,890 --> 00:03:55,020
0,180 180,450 450,1110 1200,1980 1980,2130
use some clever manipulation, so

119
00:03:55,020 --> 00:03:56,670
0,240 240,570 600,900 900,1050 1050,1650
that the bits that correspond

120
00:03:56,670 --> 00:03:57,750
0,90 90,240 240,570 570,930 930,1080
to the physical address can

121
00:03:57,750 --> 00:03:59,010
0,120 120,480 480,870 870,1050 1050,1260
be used somehow in the

122
00:03:59,040 --> 00:04:01,260
0,840 870,1410 1410,1500 1500,1740
virtual addresses as well.|
|

123
00:04:02,600 --> 00:04:05,720
0,540 540,870 870,1530 1830,2550
{} Wilson Spearmen, Spearmen.|
Wilson Spearmen, Spearmen.|

124
00:04:09,040 --> 00:04:10,300
0,180 180,300 300,630 630,780 780,1260
Yeah, I remember it's really
是的，我的印象是它是隔离的基础，

125
00:04:10,300 --> 00:04:12,760
0,540 540,930 930,1650 1650,2130 2130,2460
fundamental to isolation,| because every
|因为每个进程可以假装有自己的内存可以使用。

126
00:04:12,760 --> 00:04:14,980
0,480 480,630 630,1380 1410,2130 2130,2220
process can basically pretend that

127
00:04:14,980 --> 00:04:17,470
0,90 90,660 690,930 930,1440 1770,2490
it has its own set

128
00:04:17,470 --> 00:04:19,340
0,60 60,390 390,510 510,1050
of memory to use.|
|

129
00:04:20,470 --> 00:04:22,270
0,210 210,450 480,990 1020,1260 1260,1800
Good, good, well, so clearly
好的，显然这是很好的，这里有两个主题，

130
00:04:22,270 --> 00:04:25,390
0,600 840,1080 1080,1470 1560,2460 2790,3120
{} that's awesome, so clear

131
00:04:25,390 --> 00:04:27,220
0,120 120,420 420,690 690,1170 1170,1830
two themes here, correct {},|
|

132
00:04:27,220 --> 00:04:28,390
0,390 390,750 750,840 840,990 990,1170
one is you know there's
一个是这里有某种形式的映射，这种映射可以帮助实现隔离，

133
00:04:28,390 --> 00:04:30,400
0,150 150,420 420,510 510,1110 1470,2010
some form of mapping and

134
00:04:30,400 --> 00:04:31,720
0,90 90,480 480,570 570,1110 1110,1320
the mapping is helpful in

135
00:04:31,720 --> 00:04:34,000
0,180 180,270 270,600 600,1230 1950,2280
sort of achieving isolation,| this
|这就是我们讨论虚拟内存的原因，因为隔离。

136
00:04:34,000 --> 00:04:35,800
0,60 60,540 540,720 720,1290 1320,1800
is exactly the reason we're

137
00:04:35,800 --> 00:04:37,660
0,390 390,870 900,1110 1110,1440 1440,1860
talking about {} virtual memory

138
00:04:37,660 --> 00:04:38,760
0,660
{you,know,isolation}.|
|

139
00:04:38,850 --> 00:04:40,200
0,210 210,540 570,780 780,870 870,1350
And so what we'll see
所以我们在接下来的课程中会看到，

140
00:04:40,200 --> 00:04:41,640
0,270 270,630 660,1260 1260,1380 1380,1440
is that, {} in the

141
00:04:41,640 --> 00:04:43,020
0,330 330,420 420,540 540,990 1020,1380
next, you know the next

142
00:04:43,020 --> 00:04:43,980
0,180 180,240 240,540 540,630 630,960
couple of lectures,| in particular
|特别是当你使用虚拟内存编程时，

143
00:04:43,980 --> 00:04:44,940
0,120 120,210 210,390 390,840 840,960
when we start programming use

144
00:04:44,940 --> 00:04:47,250
0,300 300,750 990,1470 1500,2130 2130,2310
virtual memory,| {} really get
|会真正深刻理解它的能力。

145
00:04:47,250 --> 00:04:49,290
0,90 90,570 570,1380 1440,1830 1830,2040
an in-depth understanding of what

146
00:04:49,290 --> 00:04:50,660
0,180 180,630 630,960
its power is.|
|

147
00:04:50,780 --> 00:04:52,190
0,570 750,1050 1050,1170 1170,1230 1230,1410
{} And so to get
所以，为了让理解它，

148
00:04:52,190 --> 00:04:53,210
0,60 60,330 330,600 600,690 690,1020
a {sense,of} that,| you know
|这是第一节课，主要讨论虚拟内存的机制，

149
00:04:53,240 --> 00:04:54,260
0,210 210,330 330,420 420,660 660,1020
this is the first lecture

150
00:04:54,260 --> 00:04:55,520
0,120 120,600 600,1050 1050,1200 1200,1260
and mostly focusing on the

151
00:04:55,520 --> 00:04:58,820
0,990 1200,1800 1800,2520 2550,2970 2970,3300
mechanisms {} for {} virtual

152
00:04:58,820 --> 00:05:00,170
0,510 570,780 780,900 900,1200 1200,1350
memory,| and then later we
|然后，我们可以看到，使用这些机制来获得很酷的技巧。

153
00:05:00,170 --> 00:05:01,070
0,150 150,510 510,660 660,750 750,900
can see how we can

154
00:05:01,070 --> 00:05:02,660
0,180 180,360 360,960 960,1050 1050,1590
use these mechanisms to achieve

155
00:05:02,660 --> 00:05:04,040
0,90 90,240 240,450 450,1020
you know cool tricks.|
|

156
00:05:04,670 --> 00:05:05,960
0,390 420,510 510,810 810,900 900,1290
So the topic for today
所以今天的主题是，计划分为三部分。

157
00:05:05,960 --> 00:05:08,030
0,270 270,750 750,870 870,1440 1590,2070
or agenda for today {},

158
00:05:08,030 --> 00:05:09,350
0,240 240,690 690,1080 1080,1260 1260,1320
the plan is sort of

159
00:05:09,350 --> 00:05:10,720
0,240 240,810
three part.|
|

160
00:05:10,810 --> 00:05:11,890
0,300 300,690 690,810 810,870 870,1080
{} {First,I'm} going to talk
首先，我要讲的是地址空间，

161
00:05:11,890 --> 00:05:13,690
0,240 240,300 300,570 570,1260 1290,1800
about the address spaces,| as
|就是你们中一些人刚才在回答问题中提到的。

162
00:05:13,690 --> 00:05:14,680
0,150 150,270 270,450 450,840 840,990
some of you mentioned in

163
00:05:14,680 --> 00:05:16,360
0,510 540,1050
your {}

164
00:05:16,360 --> 00:05:17,800
0,270 270,390 390,450 450,840
just what we {},

165
00:05:18,070 --> 00:05:19,840
0,270 270,960 960,1110 1110,1440 1440,1770
just mentioned, just briefly mentioned

166
00:05:19,840 --> 00:05:21,580
0,840 840,1170 1170,1530 1530,1590 1590,1740
{} in response to this

167
00:05:21,580 --> 00:05:23,710
0,510 840,1470 1530,1890 1890,1950 1950,2130
question.| I'm going to talk
|我还要讲的是页式硬件，

168
00:05:23,710 --> 00:05:25,330
0,180 180,270 270,660 660,1320 1320,1620
about the paging hardware paging

169
00:05:25,330 --> 00:05:26,460
0,570
hardware,|
|

170
00:05:27,020 --> 00:05:28,280
0,420 420,540 540,780 780,1170 1170,1260
and I'm gonna focus of
当然，主要是 RISC-V 的页式硬件，

171
00:05:28,280 --> 00:05:29,300
0,240 240,390 390,450 450,780 780,1020
course on the paging hardware

172
00:05:29,300 --> 00:05:31,000
0,300 300,390 390,600 600,1170
of the {RISC-V -},|
|

173
00:05:31,390 --> 00:05:33,940
0,450 630,990 990,1410 1410,1740 1740,2550
{} but basically every processor,
但是基本上所有现代处理器都有某种形式的页式硬件，

174
00:05:34,270 --> 00:05:37,480
0,1590 1590,2130 2130,2460 2460,2760 2760,3210
modern processor has some form

175
00:05:37,480 --> 00:05:39,190
0,360 390,810 810,1260 1290,1530 1530,1710
of paging hardware| and sort
|它是支持虚拟内存的默认机制。

176
00:05:39,190 --> 00:05:41,260
0,120 120,720 900,1620 1620,1950 1950,2070
of de- {}, if you

177
00:05:41,260 --> 00:05:43,030
0,270 270,360 360,780 780,1320 1320,1770
will the default mechanism for

178
00:05:43,030 --> 00:05:45,550
0,510 510,1080 1290,1860 1860,2190 2190,2520
actually {} supporting virtual memory.|
|

179
00:05:46,270 --> 00:05:48,010
0,150 150,600 750,1260 1260,1470 1470,1740
And then, {} the last
然后，本节课的最后一个部分，是查看一些 xv6 虚拟内存代码，

180
00:05:48,010 --> 00:05:49,210
0,180 180,270 270,330 330,810 810,1200
part of the lecture is

181
00:05:49,210 --> 00:05:51,070
0,150 150,390 390,810 810,1470 1500,1860
going to walk through some

182
00:05:51,070 --> 00:05:53,140
0,240 240,450 450,1020 1020,1710 1740,2070
{xv6 - -} {} virtual

183
00:05:53,140 --> 00:05:56,240
0,270 270,810 1140,1860 1890,2520
memory code| and {}
|以及内核地址空间和用户地址空间的布局。

184
00:05:56,300 --> 00:05:59,510
0,900 1260,2070 2130,2250 2250,2820 2850,3210
layout of the kernel address

185
00:05:59,510 --> 00:06:01,850
0,660 900,1260 1260,1500 1500,1740 1740,2340
space and user address spaces.|
|

186
00:06:02,700 --> 00:06:04,350
0,180 180,390 390,930 960,1260 1260,1650
So that's the main plan.|
所以这是主要计划。|

187
00:06:05,820 --> 00:06:06,980
0,630

188
00:06:08,260 --> 00:06:10,060
0,300 300,870 960,1410 1410,1560 1560,1800
Okay, so {} if we
好的，我们回答了，记得你们回答这个问题提到的，

189
00:06:10,060 --> 00:06:11,080
0,120 120,360 360,540 540,690 690,1020
{answers -}, you know remeber

190
00:06:11,080 --> 00:06:12,700
0,60 60,210 210,780 1050,1380 1380,1620
of you mentioned, {} in

191
00:06:12,700 --> 00:06:14,500
0,630 630,720 720,900 900,1530 1680,1800
response to this question,| you
|使用虚拟内存的一个原因是可以获得隔离，

192
00:06:14,500 --> 00:06:17,980
0,360 840,1380 1380,2340 2370,3030 3060,3480
know one driving {} reason

193
00:06:17,980 --> 00:06:19,330
0,120 120,450 450,720 720,1200 1200,1350
to have virtual memory is

194
00:06:19,330 --> 00:06:20,590
0,360 360,480 480,690 690,1020 1020,1260
because you can use it

195
00:06:20,680 --> 00:06:22,240
0,150 150,510 510,1140 1320,1440 1440,1560
to achieve isolation,| if you
|如果你正确设置页表，正确使用它们编程，

196
00:06:22,240 --> 00:06:23,170
0,150 150,270 270,360 360,600 600,930
set up the page tables

197
00:06:23,170 --> 00:06:25,420
0,750 900,1140 1140,1530 1530,1620 1620,2250
correctly and program them correctly,|
|

198
00:06:25,570 --> 00:06:26,350
0,300 300,450 450,570 570,660 660,780
{} then you can in
理论上你就可以获得强隔离。

199
00:06:26,350 --> 00:06:28,700
0,360 360,1020 1020,1350 1350,1920
principle achieve strong isolation.|
|

200
00:06:29,020 --> 00:06:30,100
0,420 480,690 690,840 840,930 930,1080
And so this is to
这再次提醒我们，我们想从隔离获得什么，

201
00:06:30,100 --> 00:06:31,090
0,240 240,390 390,780 810,900 900,990
remind us again, you know

202
00:06:31,090 --> 00:06:32,350
0,240 240,360 360,630 630,840 840,1260
what we want with from

203
00:06:32,350 --> 00:06:34,210
0,750 750,1050 1050,1590 1590,1680 1680,1860
isolation,| let's say you know
|我们来看我们的标准图片，

204
00:06:34,210 --> 00:06:35,620
0,300 330,690 690,1170 1170,1290 1290,1410
our standard picture,| we have
|我们有一些用户程序，比如 shell cat 和所有你在实验一中构建的实用程序，

205
00:06:35,620 --> 00:06:37,690
0,120 120,360 360,1170 1170,1290 1320,2070
some user applications, like shell,

206
00:06:38,230 --> 00:06:40,450
0,600 600,810 810,900 900,1530 1680,2220
cat, all the util things

207
00:06:40,450 --> 00:06:41,950
0,150 150,300 300,810 840,1380 1380,1500
that you've built {} in

208
00:06:41,950 --> 00:06:44,760
0,690 990,1380 1380,1770 1770,2310
{lab,one}| and we have
|在下面，我们有内核，操作系统在内核空间中。

209
00:06:44,790 --> 00:06:48,450
0,810 840,1350 2430,2910 2910,3180 3180,3660
kernel or kernel sitting below,

210
00:06:48,450 --> 00:06:49,710
0,150 150,210 210,570 570,1020 1020,1260
{} the operating system sitting

211
00:06:49,710 --> 00:06:51,180
0,90 90,390 390,990
in kernel space.|
|

212
00:06:51,300 --> 00:06:52,440
0,600 600,720 720,810 810,990 990,1140
And you know what we
我们要做的是把这些应用程序圈起来，

213
00:06:52,440 --> 00:06:54,510
0,270 270,360 360,960 1290,1890 1890,2070
like to do is sort

214
00:06:54,510 --> 00:06:56,520
0,90 90,510 600,720 720,990 1020,2010
of have you know boxes

215
00:06:56,580 --> 00:06:58,220
0,510 510,1110
around these

216
00:06:59,380 --> 00:07:00,820
0,630 630,780 780,960 960,1110 1110,1440
applications,| so that they can't
|让它们不会互相影响，

217
00:07:00,820 --> 00:07:02,410
0,330 330,660 660,900 900,1350 1440,1590
really affect each other| and
|同样的，我们希望内核或操作系统完全独立，

218
00:07:02,410 --> 00:07:04,810
0,690 690,810 810,1380 1410,1890 1890,2400
similar we wanted {} to

219
00:07:04,810 --> 00:07:07,600
0,450 630,1110 1200,2100 2250,2700 2700,2790
be completely independent of the

220
00:07:07,600 --> 00:07:08,830
0,300 300,390 390,720 720,1080 1080,1230
kernel, the operating system,| so
|如果一个应用程序因为意外或故意做了一些坏事情，

221
00:07:08,830 --> 00:07:10,060
0,210 210,480 480,570 570,1080 1080,1230
that if an application does

222
00:07:10,060 --> 00:07:12,310
0,300 300,840 870,1560 1560,1980 1980,2250
something either accidentally bad or

223
00:07:12,310 --> 00:07:14,080
0,570 570,1020 1290,1500 1500,1710 1710,1770
maliciously bad,| {} that it
|它不会影响到操作系统，

224
00:07:14,080 --> 00:07:15,280
0,240 240,450 450,750 750,870 870,1200
doesn't really affect the operating

225
00:07:15,280 --> 00:07:16,020
0,390
system,|
|

226
00:07:16,580 --> 00:07:18,560
0,150 150,360 360,510 510,990 1320,1980
so that's our goal.| And
这是我们的目标。|我们今天关注的这个问题的[特定方面]，是内存相关的东西，

227
00:07:18,740 --> 00:07:20,930
0,270 270,1290 1350,2040 2040,2100 2100,2190
the particular aspect of the

228
00:07:20,930 --> 00:07:22,040
0,300 300,450 450,780 810,1020 1020,1110
problem that we want to

229
00:07:22,040 --> 00:07:24,050
0,360 360,510 510,1170 1320,1890 1890,2010
focus on today is the

230
00:07:24,050 --> 00:07:25,730
0,360 360,570 570,1080 1140,1500 1500,1680
memory side {of,things},| {} so
|我们关注的是内存隔离。

231
00:07:25,730 --> 00:07:26,750
0,180 180,420 420,600 600,660 660,1020
we really want to focus

232
00:07:26,750 --> 00:07:28,380
0,150 150,450 450,1140
on memory isolation.|
|

233
00:07:29,930 --> 00:07:32,300
0,570 690,990 990,1830 1980,2310 2310,2370
And by default, if we
默认情况下，如果我们不做任何事情，我们不会有内存隔离，

234
00:07:32,300 --> 00:07:33,920
0,210 210,330 330,1080 1110,1410 1410,1620
don't do anything, we don't

235
00:07:33,920 --> 00:07:35,690
0,330 330,660 660,960 960,1530 1560,1770
really have memory isolation right,|
|

236
00:07:35,690 --> 00:07:37,160
0,420 720,900 900,1020 1020,1200 1200,1470
because if you think about
因为你想一下，只有一个 RISC-V 电路板，上周我展示的那个，

237
00:07:37,160 --> 00:07:38,270
0,240 420,840 840,960 960,1020 1020,1110
it there's going to be

238
00:07:38,270 --> 00:07:40,130
0,540 600,1080 1080,1350 1350,1740 1740,1860
one {RISC-V -} boards that

239
00:07:40,130 --> 00:07:41,120
0,120 120,360 360,480 480,780 780,990
I showed you last week,|
|

240
00:07:41,120 --> 00:07:42,830
0,240 240,540 540,810 810,1410 1500,1710
it has {} memory, a
它包含内存，很多 DRAM 芯片，

241
00:07:42,830 --> 00:07:44,440
0,240 240,300 300,690 690,1230
bunch of DRAM chips,|
|

242
00:07:44,650 --> 00:07:46,870
0,600 600,1350 1350,1500 1500,1860 1860,2220
{} in the DRAM chips
在 DRAM 芯片中，保存着应用程序的代码，

243
00:07:46,870 --> 00:07:48,190
0,60 60,210 210,330 330,990 1020,1320
you know the code for

244
00:07:48,190 --> 00:07:50,980
0,150 150,1110 1290,2220 2220,2340 2340,2790
these applications {} is stored,|
|

245
00:07:51,610 --> 00:07:53,170
0,840 870,1050 1050,1110 1110,1470 1470,1560
{for,example,somewhere} in the memory is
比如内存中某处是内核，文本，数据，栈，任何东西，

246
00:07:53,170 --> 00:07:55,810
0,90 90,570 1410,1830 1830,2160 2160,2640
the kernel text data stack

247
00:07:55,810 --> 00:07:58,210
0,420 750,1440 1440,1500 1500,2130 2130,2400
everything,| somewhere in memory used
|如果 shell 在运行，内存中某处是 shell ，

248
00:07:58,210 --> 00:07:59,080
0,90 90,390 390,510 510,600 600,870
to shell if the shell

249
00:07:59,080 --> 00:07:59,940
0,60 60,420
is running,|
|

250
00:07:59,970 --> 00:08:01,950
0,420 420,870 870,1470 1470,1770 1770,1980
{} {somewhere,in} {memory,is} the cat
还有，内存中某处是 cat 程序。

251
00:08:01,950 --> 00:08:03,020
0,540
program.|
|

252
00:08:03,350 --> 00:08:04,460
0,510

253
00:08:04,640 --> 00:08:05,690
0,180 180,300 300,450 450,810 810,1050
And so there's one sort
这里有一个物理内存，从 0 到一个很大的地址，

254
00:08:05,690 --> 00:08:06,590
0,60 60,360 360,720 720,780 780,900
of physical memory, you know

255
00:08:06,590 --> 00:08:07,880
0,300 300,420 420,690 690,840 840,1290
sort of starting from zero

256
00:08:07,880 --> 00:08:09,710
0,360 360,450 450,1290 1290,1500 1500,1830
to you know big {}

257
00:08:09,740 --> 00:08:11,930
0,720 720,1260 1500,1680 1680,2040 2040,2190
big address,| {you,know} depending how
|取决于我们的机器上有多少内存，

258
00:08:11,930 --> 00:08:13,010
0,150 150,420 420,570 570,900 900,1080
much memory we have, really

259
00:08:13,010 --> 00:08:14,390
0,240 240,330 330,420 420,1020 1080,1380
have in our machine| and
|在物理内存中，所有程序都必须存在，

260
00:08:14,390 --> 00:08:15,500
0,150 150,330 330,630 630,960 960,1110
in that physical memory all

261
00:08:15,500 --> 00:08:17,000
0,150 150,600 600,840 840,960 960,1500
these programs must be present,|
|

262
00:08:17,420 --> 00:08:19,340
0,570 570,630 630,780 780,1170 1320,1920
otherwise you know the processor
否则处理器甚至不能执行它们的指令。

263
00:08:19,340 --> 00:08:21,230
0,240 240,690 690,1050 1050,1200 1200,1890
can't even execute their instructions.|
|

264
00:08:22,360 --> 00:08:23,350
0,210 210,270 270,390 390,540 540,990
This is what the risk
这里很明显有个风险是，

265
00:08:23,380 --> 00:08:24,670
0,90 90,210 210,600 600,990 990,1290
you know clearly here is|
|

266
00:08:24,820 --> 00:08:26,350
0,270 270,480 480,810 810,900 900,1530
that let's say you know
比如说，让我们简化一下，

267
00:08:26,380 --> 00:08:27,310
0,300 300,420 420,480 480,660 660,930
let's make a little bit

268
00:08:27,310 --> 00:08:28,570
0,90 90,330 330,960 960,1080 1080,1260
you know simplistic,| {} let's
|比如 shell 位于地址 0 到 200 （不是）， 2000 ， 1000 到 2000 ，

269
00:08:28,570 --> 00:08:30,310
0,210 210,510 510,1140 1380,1500 1500,1740
say the shell, you know

270
00:08:30,310 --> 00:08:31,660
0,240 240,510 510,570 570,960 990,1350
sit for {} in address

271
00:08:31,660 --> 00:08:33,900
0,540 540,780 780,1110 1110,1710
0 to address 200,

272
00:08:34,880 --> 00:08:36,110
0,180 180,540 540,840 840,1140 1140,1230
{2000 -}, {1000 -} to

273
00:08:36,110 --> 00:08:37,260
0,600
2000,|
|

274
00:08:37,720 --> 00:08:38,680
0,360 360,540 540,690 690,750 750,960
and let's say you know
比如 cat 有一个程序错误，

275
00:08:38,680 --> 00:08:40,180
0,510 540,690 690,780 780,1110 1110,1500
the you know whatever cat

276
00:08:40,180 --> 00:08:42,550
0,270 270,600 630,990 990,1590 1770,2370
has a programming error {},|
|

277
00:08:42,550 --> 00:08:44,800
0,240 240,1020 1020,1140 1140,1500 1590,2250
it loads, you know in
它加载 1000 到寄存器 a0 ，而 1000 是 shell 开始的地址，

278
00:08:44,830 --> 00:08:47,340
0,960 1080,1290 1290,2070
register {a0 -},

279
00:08:47,750 --> 00:08:49,730
0,270 270,450 450,690 690,1170 1200,1980
let's say loads the 1000,

280
00:08:49,730 --> 00:08:51,950
0,270 600,1140 1140,1500 1500,2100 2100,2220
{you,know} address basically corresponding to

281
00:08:51,950 --> 00:08:53,120
0,90 90,360 360,450 450,570 570,1170
the start of the shell|
|

282
00:08:53,420 --> 00:08:54,380
0,180 180,570 570,660 660,780 780,960
and then you know by
然后，意外的，它执行了 sd 指令 $7 a0 ，

283
00:08:54,380 --> 00:08:56,540
0,660 720,1290 1290,1680 1680,2070 2070,2160
accident, {} it executes sd

284
00:08:56,540 --> 00:08:57,860
0,840
instruction

285
00:08:58,010 --> 00:08:59,980
0,540 540,1350
{$7 -},

286
00:09:00,110 --> 00:09:02,040
0,690 690,870 870,1350
{} {a0 -},|
|

287
00:09:02,980 --> 00:09:04,000
0,180 180,450 450,510 510,900 900,1020
which has the effect of
这条指令的效果是把 7 写到地址 1000 ，

288
00:09:04,000 --> 00:09:05,140
0,210 210,600 600,780 780,1050 1050,1140
that, basically it writes the

289
00:09:05,140 --> 00:09:06,820
0,360 360,840 840,990 990,1110 1110,1680
value 7 to the address

290
00:09:06,820 --> 00:09:08,740
0,1290 1290,1410 1410,1680 1680,1830 1830,1920
1000,| {and,so} it would be
|它会修改属于 shell 的内存镜像，

291
00:09:08,740 --> 00:09:10,840
0,600 600,1200 1380,1500 1500,1620 1620,2100
scribbling over you know the,

292
00:09:10,870 --> 00:09:12,880
0,450 450,540 540,990 990,1500 1650,2010
basically the memory image {}

293
00:09:12,880 --> 00:09:14,050
0,150 150,510 510,600 600,720 720,1170
that belongs to the shell,|
|

294
00:09:14,830 --> 00:09:16,180
0,180 180,300 300,450 450,960 960,1350
and so, now we're certainly
所以，现在我们打破了隔离，这是我们不想要的。

295
00:09:16,180 --> 00:09:18,040
0,510 540,1020 1050,1410 1410,1560 1560,1860
not, {} certain would break

296
00:09:18,040 --> 00:09:20,680
0,810 1050,1650 1650,2220 2220,2340 2340,2640
isolation {} and be quite

297
00:09:20,680 --> 00:09:22,100
0,870
undesirable.|
|

298
00:09:22,360 --> 00:09:24,220
0,270 270,660 720,1140 1140,1380 1380,1860
And so we want something
所以我们希望在不同程序之间真正隔离这些内存，

299
00:09:24,220 --> 00:09:25,840
0,120 120,510 510,810 810,1410 1410,1620
that basically really separates these

300
00:09:25,840 --> 00:09:27,280
0,510 510,660 660,750 750,1050 1050,1440
memories from the different programs

301
00:09:27,280 --> 00:09:28,180
0,180 180,300 300,600 600,720 720,900
from each other,| so that
|让这种事情不会发生。

302
00:09:28,180 --> 00:09:29,440
0,210 210,360 360,690 690,900 900,1260
things like that just cannot

303
00:09:29,440 --> 00:09:30,300
0,330
happen.|
|

304
00:09:31,590 --> 00:09:32,880
0,210 210,390 390,750 750,1020 1020,1290
So one way {you,know,to} do
解决这个问题的一种方法是，地址空间。

305
00:09:32,880 --> 00:09:35,700
0,450 570,1260 1470,2040 2040,2460 2460,2820
that {} is an idea

306
00:09:35,700 --> 00:09:36,960
0,300 300,420 420,630 630,1020 1020,1260
that's you know typically called

307
00:09:36,960 --> 00:09:38,440
0,330 330,990
address spaces.|
|

308
00:09:44,500 --> 00:09:46,660
0,570 690,870 870,1440 1440,1860 1860,2160
And the basic idea is
它的基本思想很简单，我们给每个程序包括内核分配自己的地址空间。

309
00:09:46,930 --> 00:09:48,760
0,990 990,1230 1230,1320 1320,1560 1560,1830
straightforward, what we wanna do

310
00:09:48,760 --> 00:09:51,190
0,150 150,540 540,840 870,1470 1500,2430
is basically give every application

311
00:09:51,190 --> 00:09:53,110
0,420 420,510 510,1140 1500,1680 1680,1920
including the kernel its own

312
00:09:53,110 --> 00:09:54,360
0,270 270,780
address space.|
|

313
00:09:55,090 --> 00:09:56,080
0,360 360,630 630,720 720,840 840,990
And so we can think
我们可以考虑这个例子，

314
00:09:56,080 --> 00:09:57,520
0,210 210,420 420,960 960,1110 1110,1440
about this example,| {we,use} cat
|我们运行 cat ，它有地址空间从 0 到某个最大值，

315
00:09:57,520 --> 00:09:58,620
0,570
running,

316
00:09:58,770 --> 00:09:59,490
0,150 150,390 390,480 480,660 660,720
you know it has an

317
00:09:59,490 --> 00:10:01,320
0,300 300,720 720,1020 1020,1110 1110,1830
address space starting at zero

318
00:10:01,350 --> 00:10:02,640
0,180 180,510 540,750 750,1200 1200,1290
you know to whatever some

319
00:10:02,640 --> 00:10:05,700
0,390 390,1050 1710,2220 2220,2700 2700,3060
maximum value,| {say,shell} run {has,an}
|shell 有自己的地址空间，也是从 0 到某个值，

320
00:10:05,700 --> 00:10:06,870
0,300 300,600 600,720 720,900 900,1170
address space, its own address

321
00:10:06,870 --> 00:10:08,370
0,450 450,810 810,1110 1110,1230 1230,1500
space, also starting at address

322
00:10:08,370 --> 00:10:10,710
0,570 750,1260 1890,2130 2130,2220 2220,2340
zero, {} going to some

323
00:10:10,710 --> 00:10:12,300
0,660 810,960 960,1080 1080,1170 1170,1590
value,| you know the kernel
|内核有自己的地址空间，操作系统有自己的地址空间。

324
00:10:12,300 --> 00:10:14,000
0,210 210,450 450,780 780,1320
has {its,own} address space,

325
00:10:14,690 --> 00:10:16,040
0,510 510,690 690,810 810,990 990,1350
OS has its own address

326
00:10:16,040 --> 00:10:17,060
0,480
space.|
|

327
00:10:17,640 --> 00:10:19,650
0,660 870,1110 1110,1290 1290,1770 1770,2010
And so, for example when
所以，当 cat ，我们回到上一张讲稿中的例子，

328
00:10:19,650 --> 00:10:21,060
0,420 420,510 510,690 690,1260 1260,1410
cat, you know refers to,

329
00:10:21,060 --> 00:10:22,470
0,210 210,540 540,750 750,1290 1320,1410
really go back to the

330
00:10:22,470 --> 00:10:23,880
0,450 450,540 540,630 630,990 990,1410
example of the previous slide

331
00:10:23,880 --> 00:10:27,060
0,330 330,1080 1590,2100 2100,2430 2430,3180
where we did,| whatever store
|保存 7 到 a0 。

332
00:10:27,360 --> 00:10:29,610
0,750 780,1560 1650,1770 1770,2040 2040,2250
7 to you know {a0

333
00:10:29,610 --> 00:10:30,860
0,750
-}.|
|

334
00:10:30,950 --> 00:10:32,240
0,360 360,570 570,870 870,1110 1110,1290
And let's say in {a0
比如 a0 的值是 1000 ，

335
00:10:32,240 --> 00:10:33,560
0,480 480,750 750,780 780,1230 1230,1320
-}, there's a value {}

336
00:10:33,560 --> 00:10:36,410
0,1410 1410,1530 1530,1830 1830,2460 2460,2850
1000,| {you,know} if cat execute
|如果 cat 执行这条指令，会写入地址 1000 ，

337
00:10:36,410 --> 00:10:38,660
0,90 90,870 1140,1590 1590,1860 1860,2250
an instruction, {} will write

338
00:10:38,660 --> 00:10:41,000
0,180 180,510 510,900 900,2040 2040,2340
to the address 1000,| {but,it's}
|但是这是它自己的地址 1000 ，而不是 shell 的地址 1000 。

339
00:10:41,000 --> 00:10:43,640
0,180 180,720 750,1140 1140,2220 2220,2640
its own address {1000,,it's} not,

340
00:10:43,670 --> 00:10:44,540
0,120 120,210 210,330 330,720 720,870
you know the address of

341
00:10:44,540 --> 00:10:46,580
0,420 420,1050 1050,1140 1140,1560 1860,2040
the {1000,of} the shell,| so
|所以，每个程序在自己的地址空间运行，

342
00:10:46,580 --> 00:10:48,770
0,390 390,870 870,1500 1500,1980 1980,2190
basically every program runs with

343
00:10:48,770 --> 00:10:50,210
0,90 90,270 270,540 540,1110 1290,1440
its own address space,| has
|有它自己的值，并且这些地址都是完全独立的。

344
00:10:50,210 --> 00:10:52,310
0,90 90,360 360,870 870,1650 1680,2100
its own value and those

345
00:10:52,310 --> 00:10:54,300
0,420 420,540 540,960 960,1650
addresses are completely independent.|
|

346
00:10:54,360 --> 00:10:55,950
0,570 570,690 690,840 840,1050 1050,1590
{} You know this notion
在这种不同地址空间的概念下，

347
00:10:55,950 --> 00:10:58,290
0,150 150,900 900,1140 1140,1590 1620,2340
of different address spaces,| {cat,doesn't}
|cat 甚至不能访问属于 shell 的地址。

348
00:10:58,290 --> 00:10:59,550
0,180 180,390 390,480 480,1110 1110,1260
really have an ability to

349
00:10:59,550 --> 00:11:01,830
0,210 210,1050 1110,1650 1680,1860 1860,2280
even refer to an address

350
00:11:01,830 --> 00:11:03,030
0,90 90,360 360,960 960,1080 1080,1200
that actually belongs to the

351
00:11:03,030 --> 00:11:03,940
0,450
shell.|
|

352
00:11:04,900 --> 00:11:05,620
0,210 210,300 300,480 480,630 630,720
And so that's sort of
所以这是我们要达成的目标，

353
00:11:05,620 --> 00:11:08,710
0,1470 1590,2310 2310,2520 2520,2760 2760,3090
the game, that were the

354
00:11:08,710 --> 00:11:09,610
0,210 210,450 450,600 600,750 750,900
end goal that we'd like

355
00:11:09,610 --> 00:11:10,900
0,90 90,660 690,1020 1020,1170 1170,1290
to achieve,| because it's going
|因为它会给我们提供强隔离，

356
00:11:10,900 --> 00:11:11,830
0,90 90,420 420,510 510,630 630,930
to provide us with strong

357
00:11:11,830 --> 00:11:13,690
0,540 540,930 1140,1290 1290,1500 1590,1860
isolation,| because you know it's
|因为 cat 想访问其他不是它的内存是不能的。

358
00:11:13,690 --> 00:11:14,920
0,180 180,360 360,840 840,960 960,1230
just not possible for cat

359
00:11:14,920 --> 00:11:15,940
0,90 90,450 450,570 570,780 780,1020
to refer to any other

360
00:11:15,940 --> 00:11:17,500
0,360 360,540 540,630 630,1050 1140,1560
memory that is not its

361
00:11:17,500 --> 00:11:18,320
0,360
own.|
|

362
00:11:19,080 --> 00:11:19,980
0,150 150,270 270,390 390,630 630,900
And so, our goal now
所以，我们现在的目标是复用所有不同的地址空间在一个物理内存上，

363
00:11:19,980 --> 00:11:21,150
0,240 240,540 540,810 810,990 990,1170
{[] } basically sort of

364
00:11:21,360 --> 00:11:23,760
0,480 480,750 750,1080 1080,1590 1620,2400
figure out how to multiplex

365
00:11:23,760 --> 00:11:25,200
0,120 120,300 300,870 900,1230 1230,1440
as you will, all these

366
00:11:25,200 --> 00:11:27,120
0,450 450,840 840,1530 1560,1860 1860,1920
different address bases on a

367
00:11:27,120 --> 00:11:29,460
0,930 1110,1710 1710,2070 2070,2280 2280,2340
single physical memory,| because in
|因为根本上，我们只有一些 DRAM 芯片，

368
00:11:29,460 --> 00:11:30,750
0,120 120,480 510,720 720,1020 1020,1290
the end, we only have

369
00:11:30,750 --> 00:11:31,920
0,60 60,240 240,300 300,660 660,1170
a bunch of DRAM chips,|
|

370
00:11:32,220 --> 00:11:33,540
0,390 390,840 840,930 930,1200 1200,1320
{} were you know {}
你知道，内存位于 RAM 芯片上。

371
00:11:33,540 --> 00:11:35,010
0,240 240,540 540,930 930,1080 1080,1470
RAM chips where the memories

372
00:11:35,010 --> 00:11:35,960
0,210 210,420
{locate -}.|
|

373
00:11:36,930 --> 00:11:38,900
0,240 240,780 870,1440
And so, {
所以，我的计划是。

374
00:11:40,210 --> 00:11:41,350
0,540 540,720 720,840 840,930 930,1140
-} and so I sort

375
00:11:41,350 --> 00:11:42,700
0,120 120,480 480,660 660,900 900,1350
of plan.| Okay, yeah, {Amiar
|好的， Amiar ，你有一个问题，请继续。

376
00:11:42,700 --> 00:11:43,480
0,300 300,360 360,450 450,480 480,780
-}, you have a question,

377
00:11:43,480 --> 00:11:44,580
0,150 150,510
go ahead.|
|

378
00:11:46,260 --> 00:11:47,880
0,180 180,390 390,570 570,1110 1110,1620
Yeah, so I'm wondering {}
是的，我想知道，在物理硬件配置中，只有这么多空间，

379
00:11:47,970 --> 00:11:50,250
0,600 630,750 750,1620 1620,1830 1830,2280
in the configuration of the

380
00:11:50,520 --> 00:11:52,770
0,600 600,1320 1500,1770 1770,2010 2010,2250
physical hardware, there's only so

381
00:11:52,770 --> 00:11:55,140
0,240 240,990 1410,1770 1770,2100 2100,2370
much space| and in the
|而在虚拟内存布局中，也有一个最大虚拟地址，

382
00:11:55,140 --> 00:11:57,210
0,510 510,870 870,1440 1470,1710 1710,2070
virtual memory layout, there's also

383
00:11:57,210 --> 00:12:00,090
0,90 90,420 420,900 900,1590 2040,2880
a max virtual address,| by
|从设计上来说，虚拟地址是否要足够小。

384
00:12:00,090 --> 00:12:02,220
0,540 540,750 750,1230 1260,1710 1710,2130
design is the virtual address

385
00:12:02,220 --> 00:12:03,990
0,360 360,480 480,690 690,1170 1170,1770
made to be small enough.|
|

386
00:12:04,510 --> 00:12:06,910
0,150 150,840 1140,1380 1380,1620 1620,2400
{} No, no, not necessarily,|
不，不需要，|

387
00:12:06,910 --> 00:12:08,110
0,150 150,480 480,660 660,990 990,1200
you know the virtual address
虚拟地址空间可以比物理内存大，

388
00:12:08,110 --> 00:12:09,220
0,270 270,390 390,600 600,990 990,1110
space could be bigger than

389
00:12:09,220 --> 00:12:10,420
0,60 60,360 360,780 780,900 900,1200
the physical memory,| the physical
|物理内存也可以比虚拟地址空间大，

390
00:12:10,420 --> 00:12:11,290
0,270 270,390 390,510 510,750 750,870
memory could be bigger than

391
00:12:11,290 --> 00:12:13,180
0,60 60,390 390,600 600,1170 1440,1890
the virtual address space {}|
|

392
00:12:13,180 --> 00:12:13,690
0,120 120,210 210,390 390,480 480,510
and we'll see in a
我们等一下会看到这是如何发生的，

393
00:12:13,690 --> 00:12:14,470
0,240 240,390 390,570 570,690 690,780
second how it all can

394
00:12:14,470 --> 00:12:16,480
0,510 660,870 870,1140 1140,1350 1350,2010
happen,| it's actually {one,of} the
|我们会看到，这是页表很酷的部分之一，它非常灵活。

395
00:12:16,510 --> 00:12:18,070
0,240 240,540 540,1110 1140,1410 1410,1560
cool parts about {} as

396
00:12:18,070 --> 00:12:19,330
0,150 150,330 330,450 450,720 720,1260
we'll see with page tables,

397
00:12:19,570 --> 00:12:21,580
0,180 180,420 420,1020 1020,1530
{} that's extremely flexible.|
|

398
00:12:22,110 --> 00:12:23,490
0,390 390,660 660,930 1020,1200 1200,1380
So, is it, is it
那么，物理内存可能耗尽吗，

399
00:12:23,490 --> 00:12:25,680
0,540 540,900 930,1380 1500,1680 1680,2190
possible that like the physical

400
00:12:25,680 --> 00:12:28,280
0,660 660,1080 1080,1950
memory gets exhausted,|
|

401
00:12:28,280 --> 00:12:29,930
0,360 360,690 690,840 840,1050 1050,1650
{} because so many processes
因为很多进程使用它们的虚拟（地址）空间。

402
00:12:29,930 --> 00:12:31,910
0,570 570,810 810,990 990,1380 1380,1980
use all their virtual space.|
|

403
00:12:31,940 --> 00:12:34,670
0,300 300,510 510,840 840,1410 1800,2730
Yeah, that's certainly possible and
是的，完全可能，我们等一会会看到，

404
00:12:34,670 --> 00:12:35,390
0,120 120,300 300,390 390,450 450,720
we'll see in a second

405
00:12:35,390 --> 00:12:36,770
0,360 360,450 450,1110 1110,1200 1200,1380
how,| for example you know
|比如你有许多大的应用程序，

406
00:12:36,770 --> 00:12:37,730
0,90 90,210 210,720 720,900 900,960
you have a bunch of

407
00:12:37,730 --> 00:12:39,050
0,180 180,840 840,1020 1020,1140 1140,1320
big applications| that each have
|每个程序都有一个大页表，它们分配了很多内存，

408
00:12:39,050 --> 00:12:40,520
0,240 240,750 750,1230 1230,1350 1350,1470
big page tables and they

409
00:12:40,520 --> 00:12:41,570
0,360 360,390 390,540 540,600 600,1050
allocate a lot of memory,|
|

410
00:12:41,570 --> 00:12:42,350
0,180 180,300 300,480 480,570 570,780
at some point you run
在某个时刻，内存就会用完。

411
00:12:42,350 --> 00:12:43,460
0,120 120,180 180,540
out of memory.|
|

412
00:12:43,920 --> 00:12:45,630
0,180 180,390 390,840 840,1020 1020,1710
I see, thanks.| And so
我明白了，谢谢。|那么，这个在 xv6 中哪里出现了，有人知道吗？

413
00:12:46,200 --> 00:12:47,160
0,360 360,510 510,630 630,840 840,960
where does this show up

414
00:12:47,160 --> 00:12:48,840
0,60 60,240 240,360 360,930 990,1680
in {xv6 - -}, anybody?|
|

415
00:12:52,530 --> 00:12:54,440
0,300 300,930 930,1350
You, you sure
你肯定在现在做的 syscall 实验中碰到了。

416
00:12:54,440 --> 00:12:55,730
0,420 420,570 570,720 720,1050 1050,1290
touched on a little bit

417
00:12:55,730 --> 00:12:57,530
0,240 240,900 930,1350 1350,1710 1710,1800
in the syscall lab, that

418
00:12:57,530 --> 00:12:58,940
0,120 120,480 480,840
you're currently doing.|
|

419
00:13:01,310 --> 00:13:03,260
0,270 270,390 390,690 690,1320
Where are pages allocated.|
分配页面在哪里。|

420
00:13:08,660 --> 00:13:10,130
0,450 780,930 930,1020 1020,1110 1110,1470
Or if you do {syscall,lab
或者，如果你完成了 syscall 实验的第一部分，打印空闲内存地址数量。

421
00:13:10,130 --> 00:13:11,930
0,540 540,750 750,1200 1200,1410 1410,1800
-}, you finished in one

422
00:13:11,930 --> 00:13:13,010
0,360 360,420 420,480 480,810 810,1080
part of the syscall lab,

423
00:13:13,010 --> 00:13:14,270
0,360 360,690 690,840 840,1050 1050,1260
[] printing how much free

424
00:13:14,270 --> 00:13:15,720
0,270 270,960
memory {address,is}.|
|

425
00:13:17,720 --> 00:13:20,240
0,420 420,630 630,1110 1140,2070 2160,2520
Kalloc?| Yeah, {kalloc -} right,
kalloc?|是的， kalloc ， kalloc 有一个空闲页面列表，

426
00:13:20,240 --> 00:13:21,200
0,270 270,540 540,690 690,780 780,960
{kalloc -} have a list

427
00:13:21,200 --> 00:13:22,730
0,90 90,270 270,930 1200,1350 1350,1530
of free pages,| if that
|如果空闲页面列表在某个时刻是空的，

428
00:13:22,730 --> 00:13:23,750
0,180 180,270 270,450 450,840 840,1020
list of free pages, there's

429
00:13:23,750 --> 00:13:25,250
0,120 120,720 750,990 990,1260 1260,1500
an empty or runs out

430
00:13:25,250 --> 00:13:27,110
0,90 90,240 240,660 870,1620 1620,1860
at some point,| then {you,know}
|那么 kalloc 会返回一个空指针，

431
00:13:27,110 --> 00:13:28,100
0,270 270,360 360,480 480,570 570,990
kalloc is going to return

432
00:13:28,100 --> 00:13:30,140
0,60 60,240 240,840 1140,1680 1680,2040
a null pointer| and hopefully
|希望操作系统做一些明智的事情，

433
00:13:30,140 --> 00:13:31,880
0,90 90,630 630,810 810,1080 1080,1740
the {operation,system} does something [sensible],|
|

434
00:13:31,880 --> 00:13:33,260
0,180 180,480 480,1050 1050,1290 1290,1380
that basically propagated back to
把消息传回给用户应用程序，

435
00:13:33,260 --> 00:13:34,700
0,120 120,480 480,990 990,1260 1260,1440
the user application,| saying like
|表示没有更多内存给你或者完全没有内存给任何程序。

436
00:13:34,700 --> 00:13:35,750
0,360 360,450 450,720 750,930 930,1050
well you know no more

437
00:13:35,750 --> 00:13:36,830
0,330 330,450 450,780 780,960 960,1080
memory for you or no

438
00:13:36,830 --> 00:13:38,270
0,120 120,450 450,510 510,1050 1290,1440
more memory in total for

439
00:13:38,270 --> 00:13:39,100
0,420
nobody.|
|

440
00:13:40,970 --> 00:13:42,040
0,630
Okay?|
好的？|

441
00:13:43,110 --> 00:13:44,370
0,300 300,420 420,690 690,780 780,1260
{And,there's} a job for OS
操作系统需要优雅地处理这种情况，

442
00:13:44,370 --> 00:13:45,900
0,120 120,420 420,600 600,900 900,1530
to handle those cases gracefully,|
|

443
00:13:46,410 --> 00:13:48,480
0,510 540,930 930,1470 1470,1980 1980,2070
gracefully generally means propagating an
一般是把错误信息传回给用户程序。

444
00:13:48,480 --> 00:13:50,040
0,210 210,540 540,720 720,990 990,1560
error message to user application.|
|

445
00:13:57,280 --> 00:13:59,280
0,270 270,750 780,1440
Okay, good {}.|
好的。|

446
00:13:59,400 --> 00:14:00,480
0,210 210,360 360,480 480,660 660,1080
So how do you implement
那么如何实现这些地址空间，如何复用所有的地址空间在单个物理内存上。

447
00:14:00,480 --> 00:14:02,340
0,330 360,600 600,1230 1290,1740 1740,1860
these address spaces, {} you

448
00:14:02,340 --> 00:14:03,810
0,60 60,270 270,690 690,1290 1290,1470
know how basically multiplex all

449
00:14:03,810 --> 00:14:05,040
0,150 150,390 390,780 780,1170 1170,1230
these address spaces across a

450
00:14:05,040 --> 00:14:06,580
0,330 330,600 600,1020
single physical memory.|
|

451
00:14:06,580 --> 00:14:09,430
0,450 570,1230 1260,1860 1860,2190 2190,2850
And the most common approach
最常见的，也是非常灵活的方法是使用页表。

452
00:14:09,460 --> 00:14:10,900
0,240 240,240 240,570 570,1020 1020,1440
and a very flexible approach

453
00:14:10,900 --> 00:14:12,760
0,180 180,270 270,780 810,1230 1230,1860
is to use page tables.|
|

454
00:14:17,330 --> 00:14:19,430
0,510 690,990 990,1320 1320,1500 1500,2100
{} The idea is, {}
想法是，这是硬件支持的，

455
00:14:19,460 --> 00:14:20,390
0,270 270,390 390,480 480,810 810,930
this is a {hardware -}

456
00:14:20,390 --> 00:14:22,610
0,570 690,1020 1350,1620 1620,1710 1710,2220
support,| so this is implemented
|所以这是由处理器或叫做内存管理单元的硬件实现的，

457
00:14:22,610 --> 00:14:24,680
0,120 120,780 930,1260 1260,1350 1350,2070
in hardware by the processor

458
00:14:24,680 --> 00:14:26,810
0,330 360,1110 1110,1590 1590,1860 1860,2130
or by unit {called,the} memory

459
00:14:26,810 --> 00:14:28,670
0,540 540,900 1230,1500 1500,1590 1590,1860
management unit,| so the picture
|所以，你脑海中要有的画面是，

460
00:14:28,670 --> 00:14:29,810
0,120 120,570 570,720 720,990 990,1140
that you should have your

461
00:14:29,810 --> 00:14:31,400
0,240 240,630 840,1260 1260,1470 1470,1590
head is,| {you,know} yeah, the
|CPU 执行任何指令，

462
00:14:31,400 --> 00:14:32,580
0,720
CPU,

463
00:14:32,730 --> 00:14:34,890
0,210 210,600 600,1410 1410,1590 1590,2160
that executes instructions {you,know} whatever

464
00:14:34,920 --> 00:14:35,980
0,450
are,|
|

465
00:14:35,980 --> 00:14:37,920
0,630 660,1350
{you,know}, {
比如存储指令，把 $7 放入 a0 间接引用，

466
00:14:38,580 --> 00:14:40,440
0,300 300,480 480,810 810,1470 1470,1860
-} are store instruction that

467
00:14:40,470 --> 00:14:41,640
0,330 330,450 450,540 540,810 810,1170
was you know putting {$7

468
00:14:41,640 --> 00:14:44,100
0,630 660,1080 1080,1830
-} {into -}

469
00:14:44,440 --> 00:14:47,520
0,630 630,900 900,1680 1710,2550
{} {a0 -} indirect,|
|

470
00:14:47,580 --> 00:14:48,780
0,240 240,720 720,930 930,1110 1110,1200
{so,that} executes those kind of
执行这些指令，

471
00:14:48,780 --> 00:14:51,030
0,840 1200,1860 1860,1950 1950,2040 2040,2250
instructions| and you know when
|当它执行存储指令，加载指令，任何含有地址的指令，

472
00:14:51,030 --> 00:14:52,680
0,120 120,480 480,750 840,1290 1290,1650
it executes {one,of,those} store instruction,

473
00:14:52,680 --> 00:14:54,270
0,330 330,690 690,1140 1140,1440 1440,1590
load instruction, whatever anything that

474
00:14:54,270 --> 00:14:56,040
0,360 360,570 570,660 660,1290 1530,1770
actually has an address,| {you,know}
|那个地址我们都应该认为是虚拟地址，

475
00:14:56,040 --> 00:14:57,690
0,180 180,780 810,1350 1380,1560 1560,1650
that address we're going to

476
00:14:57,690 --> 00:14:58,770
0,150 150,450 450,600 600,660 660,1080
think about as a virtual

477
00:14:58,770 --> 00:14:59,790
0,420 450,630 630,750 750,960 960,1020
address,| so it's not a
|它不是物理地址，而是虚拟地址。

478
00:14:59,790 --> 00:15:01,410
0,330 330,600 600,780 780,1140 1140,1620
physical address, {it's,a} virtual address.|
|

479
00:15:02,100 --> 00:15:02,880
0,210 210,300 300,360 360,720 720,780
And so, for example the
比如，我们在这使用的 a0 中的值，

480
00:15:02,880 --> 00:15:04,230
0,480 480,630 630,750 750,1230 1230,1350
value in {a0 -} that

481
00:15:04,230 --> 00:15:06,240
0,150 150,450 450,960 1020,1500 1500,2010
we're using here,| {} yeah
|比如说是 1000 ， 0x1000 就是一个虚拟地址，

482
00:15:06,420 --> 00:15:08,700
0,270 270,570 570,1740
say that's 1000,

483
00:15:08,760 --> 00:15:11,160
0,270 270,780 1140,1380 1380,2100 2100,2400
{0x1000,data - - -} is

484
00:15:11,160 --> 00:15:12,720
0,180 180,510 510,960 960,1200 1200,1560
a virtual address| and virtual
|虚拟地址通过内存管理单元路由，

485
00:15:12,720 --> 00:15:15,150
0,450 450,1110 1140,1950 2160,2340 2340,2430
addresses basically routed {through -}

486
00:15:15,150 --> 00:15:16,680
0,450 450,690 690,960 960,1230 1230,1530
something what's called the memory

487
00:15:16,680 --> 00:15:18,140
0,480 480,900
management unit,|
|

488
00:15:21,160 --> 00:15:23,230
0,570 570,1260 1320,1470 1470,1710 1710,2070
{} and the memory manager
内存管理单元把它转换成物理地址。

489
00:15:23,230 --> 00:15:25,300
0,360 360,1170 1170,1410 1440,1950 1950,2070
unit translates it into a

490
00:15:25,300 --> 00:15:26,740
0,360 360,930
physical address.|
|

491
00:15:27,690 --> 00:15:29,790
0,510 510,810 810,1140 1140,1500 1500,2100
And that physical address then
然后那个物理地址在内存中进行索引，

492
00:15:29,790 --> 00:15:31,830
0,180 180,480 480,870 870,1350 1590,2040
was actually used to index

493
00:15:31,830 --> 00:15:34,080
0,180 180,840 1290,1710 1710,1980 1980,2250
into memory| and load whatever
|加载值或保存需要写入的值。

494
00:15:34,080 --> 00:15:36,480
0,540 540,1020 1080,1470 1470,1890 1890,2400
value or {} store whatever

495
00:15:36,480 --> 00:15:37,470
0,360 360,570 570,630 630,750 750,990
value needs to be written

496
00:15:37,470 --> 00:15:38,200
0,270
there.|
|

497
00:15:38,700 --> 00:15:40,290
0,420 570,750 750,870 870,960 960,1590
{} And so the CPU,
所以从 CPU 的角度来看，

498
00:15:40,290 --> 00:15:41,190
0,180 180,240 240,570 570,840 840,900
from the CPU point of

499
00:15:41,190 --> 00:15:43,110
0,420 450,630 630,960 960,1500 1530,1920
view,| it always issues, every
|它总是，一旦 MMU 启动，每条指令[发出的]都是虚拟地址。

500
00:15:43,110 --> 00:15:45,630
0,480 480,720 720,1350 1590,1890 1890,2520
instruction that [issues], {} once

501
00:15:45,630 --> 00:15:47,220
0,90 90,360 360,630 630,1290 1320,1590
the MMU is enabled are

502
00:15:47,220 --> 00:15:48,620
0,330 330,930
virtual addresses.|
|

503
00:15:49,100 --> 00:15:50,780
0,240 240,570 570,1230 1230,1380 1380,1680
And to translate these virtual
为了把虚拟地址转换成物理地址，一般 MMU 有一张表。

504
00:15:50,780 --> 00:15:52,730
0,300 300,390 390,690 690,1200 1260,1950
addresses to physical addresses, basically

505
00:15:52,730 --> 00:15:53,990
0,150 150,540 540,750 750,810 810,1260
the MMU has a table,|
|

506
00:15:55,060 --> 00:15:57,370
0,630 1050,1800 1800,2040 2040,2100 2100,2310
and virtual address on one
虚拟地址在一边，物理地址在一边，

507
00:15:57,370 --> 00:15:58,540
0,360 360,630 630,870 870,930 930,1170
side, physical address on one

508
00:15:58,540 --> 00:16:00,580
0,540 810,990 990,1170 1170,1590 1590,2040
side,| the other side potential
|另一边的这里可能是我们的条目 1000 ，

509
00:16:00,580 --> 00:16:02,620
0,390 390,810 1050,1320 1320,1710 1710,2040
here is our entry for

510
00:16:02,620 --> 00:16:05,860
0,1860 1860,2430 2430,2610 2610,3000 3000,3240
1000,| {and,maybe} that maps to
|可能映射到无论什么， 0x （开头的）某个值，在内存中的某个地方，

511
00:16:05,860 --> 00:16:07,640
0,660 720,1260
whatever {}

512
00:16:07,860 --> 00:16:09,540
0,150 150,360 360,570 570,1110 1140,1680
you know, {0x -} whatever

513
00:16:09,750 --> 00:16:11,010
0,180 180,420 420,720 720,1080 1080,1260
you're [making something up], we'd

514
00:16:11,010 --> 00:16:12,960
0,270 270,480 480,690 690,1350
like {something -} value,

515
00:16:13,020 --> 00:16:14,670
0,420 420,510 510,780 780,1170 1470,1650
somewhere in physical memory,| so
|所以这个在虚拟地址和物理地址之间的映射是很灵活的。

516
00:16:14,670 --> 00:16:16,200
0,180 180,660 660,1050 1050,1440 1440,1530
this mapping between virtual and

517
00:16:16,200 --> 00:16:18,540
0,300 300,870 1170,1740 1740,2070 2070,2340
physical { -} is quite

518
00:16:18,540 --> 00:16:19,600
0,510
flexible.|
|

519
00:16:19,890 --> 00:16:21,000
0,390 390,510 510,720 720,990 990,1110
So on one side, we
所以，一边是虚拟地址，另一边是物理地址。

520
00:16:21,000 --> 00:16:21,900
0,210 210,330 330,600 600,840 840,900
have the virtual address, on

521
00:16:21,900 --> 00:16:22,560
0,90 90,270 270,450 450,570 570,660
the other side of the

522
00:16:22,560 --> 00:16:23,940
0,300 300,870
physical addresses.|
|

523
00:16:24,670 --> 00:16:25,940
0,630

524
00:16:26,030 --> 00:16:27,980
0,600 600,690 690,810 810,1290 1290,1950
Typically, you know this mapping
通常，这个映射也保存在内存中。

525
00:16:28,070 --> 00:16:29,210
0,510 510,570 570,810 810,1080 1080,1140
itself is also stored in

526
00:16:29,210 --> 00:16:30,220
0,480
memory.|
|

527
00:16:30,220 --> 00:16:31,390
0,360 360,510 510,600 600,990 990,1170
And so the CPU has
所以 CPU 有一些寄存器用来指出，包含物理地址的页表保存在哪里。

528
00:16:31,390 --> 00:16:34,210
0,270 270,960 1350,1860 1860,2190 2190,2820
some register that basically points

529
00:16:34,210 --> 00:16:37,180
0,570 900,2070 2070,2460 2460,2550 2550,2970
to, that contains the physical

530
00:16:37,180 --> 00:16:39,280
0,630 900,1350 1350,1740 1740,1830 1830,2100
address of where the page

531
00:16:39,280 --> 00:16:40,720
0,330 330,510 510,1020
table is stored.|
|

532
00:16:40,720 --> 00:16:42,430
0,150 150,480 480,960 990,1590 1590,1710
So somewhere in basically the
所以某个地方存放物理地址的页表或映射，

533
00:16:42,430 --> 00:16:43,870
0,240 240,510 510,630 630,900 930,1440
page table or just map

534
00:16:43,870 --> 00:16:46,060
0,240 240,630 630,960 960,1530 1920,2190
somewhere stored physical memory {},|
|

535
00:16:46,060 --> 00:16:47,110
0,300 300,540 540,840 840,960 960,1050
let's say, yeah you know
比如，地址 10 ，

536
00:16:47,110 --> 00:16:48,480
0,630
whatever

537
00:16:48,480 --> 00:16:50,880
0,390 390,930 1380,1860 1860,2250 2250,2400
address 10| and basically this
|在 RISC-V 中的这个寄存器叫做 satp ，保存着地址 10 ，

538
00:16:50,880 --> 00:16:52,320
0,570 570,810 810,930 930,1290 1290,1440
register which is called on

539
00:16:52,320 --> 00:16:54,360
0,60 60,300 300,750 750,960 960,2040
the {RISC-V -} {satp -},

540
00:16:54,810 --> 00:16:58,140
0,750 750,1020 1860,2370 2370,2880 2970,3330
{you,know,stores} the address 10| and
|CPU 告诉内存管理单元，到哪里寻找把虚拟地址转换为物理地址的映射。

541
00:16:58,140 --> 00:17:00,330
0,480 660,960 960,1230 1230,1650 1740,2190
so {} that the CPU

542
00:17:00,330 --> 00:17:01,500
0,120 120,390 390,570 570,840 840,1170
can tell the memory manager

543
00:17:01,500 --> 00:17:04,410
0,360 450,1230 1230,1350 1350,2070 2160,2910
unit where to find basically

544
00:17:04,410 --> 00:17:06,390
0,120 120,780 810,990 990,1200 1200,1980
the map to actually translate

545
00:17:06,570 --> 00:17:08,550
0,600 600,960 960,1080 1080,1380 1380,1980
{} virtual to physical addresses.|
|

546
00:17:10,020 --> 00:17:11,250
0,150 150,450 450,540 540,840 840,1230
And then the basic idea
然后，基本想法是给每个应用程序自己的映射。

547
00:17:11,250 --> 00:17:12,900
0,120 120,330 330,690 720,1020 1020,1650
is to give every application

548
00:17:12,900 --> 00:17:14,220
0,150 150,330 330,810
it's own map.|
|

549
00:17:14,310 --> 00:17:15,840
0,630 720,900 900,1230 1230,1320 1320,1530
So {you,know} cat is gonna
所以 cat 有自己的映射。糟糕。

550
00:17:15,840 --> 00:17:18,180
0,390 390,600 600,1050 1320,1770
have it's map. Oops.|
|

551
00:17:19,120 --> 00:17:20,680
0,210 210,480 480,1170
So every app,
每个应用程序，它自己的。糟糕。

552
00:17:22,000 --> 00:17:23,040
0,480
{it's,own}.

553
00:17:23,350 --> 00:17:25,060
0,1500
Oops.|
|

554
00:17:25,180 --> 00:17:27,160
0,690 810,1080 1080,1440 1440,1560 1560,1980
Yeah, {} Bibic go ahead.|
是的， Bibic 继续。|

555
00:17:29,410 --> 00:17:31,780
0,660 870,1440 1440,1620 1620,1950 1950,2370
{} So the {MMU -},
所以， MMU 你说它不用保存映射，那么它是只做转换吗，

556
00:17:31,780 --> 00:17:34,570
0,270 270,930 1320,1620 1620,1920 1920,2790
you said it doesn't necessarily

557
00:17:34,600 --> 00:17:37,300
0,510 510,600 600,1290 1590,2280 2310,2700
store the mapping, so does

558
00:17:37,300 --> 00:17:39,130
0,330 420,930 930,1260 1290,1740 1740,1830
it just just just do

559
00:17:39,130 --> 00:17:40,960
0,150 150,1080 1110,1350 1350,1440 1440,1830
the translation,| like it will
|就像，它读取内存并转换，但是不用保存映射。

560
00:17:40,990 --> 00:17:42,580
0,390 390,480 480,1200 1230,1440 1440,1590
read the memory and do

561
00:17:42,580 --> 00:17:44,800
0,90 90,900 900,1080 1080,1320 1320,2220
the translation, but not necessarily

562
00:17:45,700 --> 00:17:47,890
0,480 480,540 540,1170 1170,1770 1770,2190
store the mappings.| That's exactly
|这就是你脑海中应该有的画面。

563
00:17:47,890 --> 00:17:48,790
0,90 90,300 300,660 660,780 780,900
the right picture that you

564
00:17:48,790 --> 00:17:49,980
0,120 120,300 300,480 480,810
should {have,in} your head.|
|

565
00:17:52,780 --> 00:17:53,920
0,210 210,390 390,630 630,810 810,1140
And {} every map, okay
每个映射，好的，所以映射保存在内存中，

566
00:17:54,010 --> 00:17:56,470
0,270 270,1110 1500,1890 1890,2220 2220,2460
so the map itself {stored,in}

567
00:17:56,470 --> 00:17:58,300
0,570 570,840 840,990 990,1350 1350,1830
memory,| {MMU -} just basically
|MMU 只是访问查看映射，

568
00:17:58,300 --> 00:17:59,770
0,480 480,600 600,1110 1110,1380 1380,1470
walks or looks into the

569
00:17:59,770 --> 00:18:00,550
0,360 360,450 450,540 540,690 690,780
map| and we'll see in
|我们过一会会看到，这个映射比我画在这里的要更复杂。

570
00:18:00,550 --> 00:18:01,480
0,60 60,510 540,690 690,780 780,930
a second you know this

571
00:18:01,480 --> 00:18:02,770
0,210 210,270 270,630 630,780 780,1290
map is slightly more complicated

572
00:18:02,770 --> 00:18:03,520
0,120 120,180 180,330 330,510 510,750
than I was just draw

573
00:18:03,520 --> 00:18:04,420
0,390
here.|
|

574
00:18:05,300 --> 00:18:07,280
0,570 720,1080 1080,1500 1530,1800 1800,1980
So every app has its
所以，每个应用程序有它自己的映射，

575
00:18:07,280 --> 00:18:08,380
0,600
own

576
00:18:09,640 --> 00:18:11,120
0,210 210,390 390,900
its own map,|
|

577
00:18:12,340 --> 00:18:14,470
0,450 450,690 690,1080 1080,1440 1440,2130
and that map basically defines
那个映射定义了它的地址空间。

578
00:18:14,470 --> 00:18:16,040
0,210 210,510 510,1050
its address space.|
|

579
00:18:16,380 --> 00:18:18,000
0,150 150,270 270,540 540,870 870,1620
And so when the CPU
所以当 CPU ，当操作系统从一个应用程序切换到另一个应用程序，

580
00:18:18,090 --> 00:18:19,290
0,180 180,360 360,450 450,810 810,1200
or when the operating system

581
00:18:19,290 --> 00:18:20,670
0,480 480,570 570,1020 1020,1140 1140,1380
switches the CPU from one

582
00:18:20,670 --> 00:18:22,500
0,690 900,1050 1050,1200 1200,1710 1710,1830
process from one application to

583
00:18:22,500 --> 00:18:24,420
0,270 270,930 1110,1260 1260,1500 1500,1920
another application,| it also switches
|它也会切换 satp 寄存器的内容，

584
00:18:24,420 --> 00:18:26,370
0,540 540,960 960,1080 1080,1470 1680,1950
the content of this {satp

585
00:18:26,370 --> 00:18:29,310
0,450 450,990 990,1440 1740,2250 2250,2940
-} register,| to {} store
|用来保存对应进程映射的根地址。

586
00:18:29,310 --> 00:18:31,020
0,390 420,930 930,1050 1050,1140 1140,1710
the root of the map

587
00:18:31,200 --> 00:18:32,920
0,180 180,300 300,780 780,1380
of the appropriate process.|
|

588
00:18:33,410 --> 00:18:34,640
0,300 300,450 450,510 510,720 720,1230
And so in that way,
所以在这种方式下，多个应用程序运行在 CPU 上，

589
00:18:34,670 --> 00:18:36,500
0,720 720,780 780,900 900,1230 1230,1830
basically you know multiple applications

590
00:18:36,500 --> 00:18:37,550
0,90 90,540 540,780 780,900 900,1050
to run on the {CPU

591
00:18:37,550 --> 00:18:38,750
0,360 360,600 600,780 780,870 870,1200
-},| every time we switch
|每次从一个应用程序切换到另一个应用程序，

592
00:18:38,750 --> 00:18:39,920
0,330 330,450 450,630 630,1080 1080,1170
between from one application to

593
00:18:39,920 --> 00:18:41,690
0,120 120,330 330,1080 1140,1410 1410,1770
the next application,| we also
|也会切换 satp 寄存器，指向那个应用程序对应的映射。

594
00:18:41,690 --> 00:18:44,510
0,420 420,840 1110,1620 1620,2220 2220,2820
switch the {} satp register

595
00:18:44,510 --> 00:18:45,830
0,180 180,570 570,690 690,840 840,1320
to point to the appropriate

596
00:18:45,830 --> 00:18:47,400
0,240 240,330 330,480 480,1080
map for that application.|
|

597
00:18:47,430 --> 00:18:48,900
0,150 150,240 240,420 420,720 720,1470
And in that way, basically
在这种方式下， cat 的虚拟地址与 shell 的虚拟地址转换不同，

598
00:18:49,020 --> 00:18:52,800
0,720 750,1350 1350,1980 2220,2940 3120,3780
{} virtual addresses for {}

599
00:18:52,830 --> 00:18:54,990
0,480 480,540 540,1200 1200,1770 1770,2160
cat are translated differently than

600
00:18:54,990 --> 00:18:56,970
0,150 150,540 540,1020 1020,1680 1740,1980
the virtual addresses for the

601
00:18:56,970 --> 00:18:58,050
0,360 360,690 690,810 810,900 900,1080
shell,| because you know each
|因为它们都有自己的映射。

602
00:18:58,050 --> 00:18:59,100
0,240 240,330 330,510 510,870 870,1050
one of them has their

603
00:18:59,100 --> 00:19:00,080
0,120 120,540
own map.|
|

604
00:19:02,380 --> 00:19:03,600
0,90 90,270 270,630
That makes sense?|
能理解吗？|

605
00:19:06,470 --> 00:19:07,600
0,600
Okay,
好的，所以，这是基本计划，

606
00:19:07,720 --> 00:19:10,000
0,210 210,300 300,1080 1860,2070 2070,2280
so {we -}, this is

607
00:19:10,000 --> 00:19:11,410
0,180 180,600 600,1110 1140,1350 1350,1410
the basic plan| and the
|目前为止我画的或者解释的方法是很初级的，也是不合理的。

608
00:19:11,410 --> 00:19:13,750
0,240 240,600 630,1290 1290,1740 1740,2340
way I've drawn or gonna

609
00:19:13,750 --> 00:19:15,070
0,360 360,420 420,600 600,1110 1140,1320
explain it so far it's

610
00:19:15,070 --> 00:19:17,740
0,210 210,870 990,1530 1530,1890 1920,2670
pretty naive, {} and unreasonable.|
|

611
00:19:18,240 --> 00:19:20,220
0,360 360,750 780,900 900,1410
{} Yeah, Bibic, {go,head}.|
是的， Bibic ，继续。|

612
00:19:20,830 --> 00:19:22,600
0,300 300,570 600,1230
I'm sorry, {}
抱歉，你说 satp 寄存器为进程做修改，

613
00:19:22,850 --> 00:19:25,520
0,630 990,1530 1560,1950 2130,2490 2490,2670
so {} the you said

614
00:19:25,520 --> 00:19:27,110
0,90 90,300 300,720 720,1350 1350,1590
the {satp -} register gets

615
00:19:27,110 --> 00:19:28,910
0,600 630,930 930,1200 1200,1290 1290,1800
modified {} for the process,|
|

616
00:19:28,940 --> 00:19:30,980
0,300 300,510 510,1170 1170,1440 1440,2040
I am guessing the value
我想每个进程的 satp 寄存器的值是由内核保存的。

617
00:19:30,980 --> 00:19:32,690
0,390 450,810 810,1050 1050,1290 1290,1710
of {} for {satp -}

618
00:19:32,690 --> 00:19:34,780
0,510 510,720 720,870 870,1680
register for each process

619
00:19:34,780 --> 00:19:36,250
0,180 180,690 690,840 840,960 960,1470
is stored by the kernel.|
|

620
00:19:36,490 --> 00:19:38,350
0,480 780,1050 1050,1140 1140,1560 1560,1860
Yes yes, the {kernel,is} writing
是的，内核写入 satp 寄存器，

621
00:19:38,350 --> 00:19:40,330
0,510 510,900 900,960 960,1290 1320,1980
satp register,| in fact writing
|事实上，写入或读取，特别是写入 satp 寄存器是一个特权指令。

622
00:19:40,330 --> 00:19:42,370
0,150 150,570 570,1200 1230,1710 1710,2040
or reading, {} particular writing

623
00:19:42,370 --> 00:19:44,110
0,630 660,1170 1170,1530 1530,1650 1650,1740
the satp register is a

624
00:19:44,110 --> 00:19:45,600
0,420 420,930
privilege instruction.|
|

625
00:19:45,830 --> 00:19:47,720
0,540 570,690 690,930 930,1440 1440,1890
So {} user application cannot
所以用户程序不能更新页面映射寄存器，

626
00:19:47,720 --> 00:19:49,280
0,390 570,1080 1080,1140 1140,1380 1380,1560
just update the page map

627
00:19:49,280 --> 00:19:50,600
0,600 600,780 780,930 930,1140 1140,1320
register| and say like I
|说现在自己希望运行在这个页面映射，

628
00:19:50,600 --> 00:19:51,260
0,180 180,240 240,390 390,510 510,660
want to run with this

629
00:19:51,260 --> 00:19:53,060
0,210 210,390 390,810 1200,1650 1650,1800
page map now,| because that
|因为这回违反隔离性，

630
00:19:53,060 --> 00:19:54,960
0,150 150,570 570,1380
would violate {}

631
00:19:54,960 --> 00:19:56,700
0,600 960,1170 1170,1260 1260,1440 1440,1740
isolation right,| so it's only
|所以只有内核，内核模式的代码可以更新它。

632
00:19:56,700 --> 00:19:58,110
0,60 60,480 480,900 900,1050 1050,1410
the kernel, only the code

633
00:19:58,110 --> 00:19:58,980
0,60 60,330 330,540 540,630 630,870
in kernel mode can actually

634
00:19:58,980 --> 00:20:00,120
0,270 270,480
update it.|
|

635
00:20:03,730 --> 00:20:05,020
0,270 270,750 840,1080 1080,1140 1140,1290
Okay, so as I said
好的，像我说的，这张图片是很初级的，

636
00:20:05,020 --> 00:20:06,130
0,90 90,300 300,360 360,570 570,1110
this picture is pretty naive,|
|

637
00:20:06,190 --> 00:20:07,360
0,510 510,630 630,720 720,930 930,1170
{} you know one thing
我还没有说过这个映射是如何工作的。

638
00:20:07,360 --> 00:20:08,350
0,60 60,240 240,450 450,630 630,990
I haven't really said anything

639
00:20:08,350 --> 00:20:09,730
0,300 300,510 510,690 690,960 960,1380
about how this actually map

640
00:20:09,730 --> 00:20:10,760
0,570
works.|
|

641
00:20:10,760 --> 00:20:12,650
0,510 510,1110 1380,1680 1680,1800 1800,1890
{} And, {} you know
我画的这种方式，看起来表示每个虚拟地址都在映射中有一个条目。

642
00:20:12,650 --> 00:20:14,120
0,150 150,510 510,780 780,1170 1170,1470
the way I've drawn out

643
00:20:14,120 --> 00:20:15,860
0,210 210,300 300,840 840,1110 1140,1740
seems to indicate {} basically

644
00:20:15,860 --> 00:20:17,510
0,150 150,630 660,1050 1050,1500 1500,1650
for every virtual address, you

645
00:20:17,510 --> 00:20:18,140
0,120 120,180 180,510 510,570 570,630
have an entry in the

646
00:20:18,140 --> 00:20:19,060
0,420
map.|
|

647
00:20:19,370 --> 00:20:21,170
0,540 540,1020 1110,1410 1440,1650 1650,1800
{} And if you do
如果你这么做了，在 RISC-V 中它（映射）会有多大。

648
00:20:21,170 --> 00:20:22,280
0,300 300,540 540,690 690,900 900,1110
that, how big would that

649
00:20:22,280 --> 00:20:23,200
0,330
be

650
00:20:25,400 --> 00:20:26,860
0,240 240,480 480,960
on {RISC-V -}.|
|

651
00:20:32,380 --> 00:20:33,640
0,720
Anybody?|
有人知道吗？|

652
00:20:36,150 --> 00:20:37,350
0,150 150,360 360,810 810,990 990,1200
How many addresses are there
理论上， RISC-V 上有多少地址，

653
00:20:37,350 --> 00:20:38,220
0,120 120,210 210,420 420,750 750,870
on the {RISC-V -} in

654
00:20:38,220 --> 00:20:39,750
0,480 480,690 690,930 930,1350 1380,1530
principle| or how big, how
|或者寄存器能存储多少地址，

655
00:20:39,750 --> 00:20:41,190
0,180 180,780 780,900 900,1020 1020,1440
many addresses {could -} registers

656
00:20:41,190 --> 00:20:42,160
0,420
store,|
|

657
00:20:46,090 --> 00:20:48,040
0,690 690,780 780,1260 1260,1440 1440,1950
registers are 64 bit wide,
寄存器是 64 位的，那么是多少地址。

658
00:20:48,620 --> 00:20:50,200
0,120 120,210 210,390 390,1020
so, how many addresses.|
|

659
00:20:52,490 --> 00:20:53,760
0,690
Anybody?|
有人知道吗？|

660
00:20:53,850 --> 00:20:55,110
0,120 120,330 330,510 510,780 780,1260
I know I'm so insulting
我知道问这些问题是对你们智力的侮辱，但是（这很重要）。

661
00:20:55,110 --> 00:20:56,340
0,120 120,660 660,810 810,1080 1080,1230
your intelligence by asking these

662
00:20:56,340 --> 00:20:57,680
0,390 390,720
questions, but.|
|

663
00:21:00,110 --> 00:21:00,860
0,150 150,240 240,390 390,690 690,750
We have some answers in
我们在聊天窗口中有一些答案，比如 2 的 64 次方。

664
00:21:00,860 --> 00:21:01,760
0,120 120,480 480,660 660,810 810,900
the chat, like 2 to

665
00:21:01,760 --> 00:21:03,350
0,120 120,840 840,1230 1230,1410 1410,1590
the 64.| I I didn't
|我没有看聊天窗口，抱歉，是的， 2 的 64 次方。

666
00:21:03,350 --> 00:21:04,610
0,120 120,210 210,420 420,810 1020,1260
see the chat, sorry, {}

667
00:21:04,610 --> 00:21:05,870
0,150 150,390 390,480 480,1050 1080,1260
yeah, 2 to 64.| {Let,me}
|让我看下能不能把聊天窗口显示出来，让我看到它。

668
00:21:05,870 --> 00:21:06,920
0,180 180,300 300,360 360,570 570,1050
see if I can actually

669
00:21:06,920 --> 00:21:08,150
0,270 270,420 420,510 510,900 1050,1230
pop up the chat, so

670
00:21:08,150 --> 00:21:09,320
0,60 60,180 180,360 360,570
I could see it.|
|

671
00:21:13,460 --> 00:21:14,420
0,120 120,210 210,420 420,660 660,960
Yeah, 2 to {64 -},
是的， 2 的 64 次方，谢谢。

672
00:21:14,420 --> 00:21:15,520
0,270 270,510
thank you.|
|

673
00:21:17,000 --> 00:21:19,070
0,240 240,630 720,960 960,1650 1860,2070
Alright, so this table would
好的，这张表是巨大的，

674
00:21:19,070 --> 00:21:21,470
0,120 120,960 1350,1890 1890,2070 2070,2400
be gigantic,| {} in fact,
|实际上，我们知道仅包含这张表就会使用所有内存，

675
00:21:21,470 --> 00:21:22,820
0,330 390,660 660,840 840,1230 1230,1350
we know all memory would

676
00:21:22,820 --> 00:21:24,170
0,90 90,720 720,930 930,1110 1110,1350
be consumed by just having

677
00:21:24,170 --> 00:21:25,070
0,90 90,420 420,510 510,630 630,900
the table,| so that seems
|所以这是不合理的。

678
00:21:25,070 --> 00:21:26,160
0,600
unreasonable.|
|

679
00:21:26,350 --> 00:21:27,490
0,300 300,480 480,660 660,780 780,1140
{} And so in fact
事实上，事情不是这样工作的。

680
00:21:27,490 --> 00:21:28,240
0,90 90,180 180,450 450,630 630,750
you know that's not how

681
00:21:28,240 --> 00:21:29,460
0,240 240,690
things work.|
|

682
00:21:29,520 --> 00:21:30,450
0,360 360,510 510,750 750,810 810,930
{} In fact I'm going
我会分两步来解释它在 RISC-V 中是如何工作的。

683
00:21:30,450 --> 00:21:31,800
0,60 60,300 300,600 600,1170 1170,1350
to go {in,two} steps to

684
00:21:31,800 --> 00:21:32,820
0,300 300,450 450,540 540,750 750,1020
actually how it actually works

685
00:21:32,820 --> 00:21:34,320
0,90 90,150 150,360 360,780 1110,1500
in the {RISC-V -}.| {So,step}
|第一步是，不要对每个地址[]，而是对每个页面。

686
00:21:34,320 --> 00:21:36,810
0,510 720,1560 1800,1950 1950,2340 2340,2490
one is {you,know} don't [play

687
00:21:36,810 --> 00:21:40,050
0,90 90,690 780,1470 1500,2190 2220,3240
the game] {} per address,

688
00:21:40,050 --> 00:21:42,040
0,150 150,450 450,810 810,1440
but do per page.|
|

689
00:21:44,580 --> 00:21:45,780
0,180 180,330 330,900 900,960 960,1200
So you translate a page
每次转换一个页面，

690
00:21:45,780 --> 00:21:46,860
0,120 120,180 180,780 870,1020 1020,1080
at a time| and a
|在 RISC-V 中，一个页是 4 KB ，也就是 4096 字节。

691
00:21:46,860 --> 00:21:49,110
0,510 510,510 510,1440 1440,1770 1770,2250
page {} on {the,RISC-V -}

692
00:21:49,110 --> 00:21:50,700
0,150 150,420 420,1080
is 4 kilobytes,

693
00:21:51,860 --> 00:21:52,970
0,300 300,480 480,720 720,960 960,1110
which is a 4 and

694
00:21:52,970 --> 00:21:55,080
0,1110 1110,1620
4096 bytes.|
|

695
00:21:55,140 --> 00:21:56,880
0,240 240,330 330,600 600,1200 1290,1740
This is pretty common, {}
这很常见，几乎所有处理器页面大小使用 4 KB ，或者支持 4 KB 。

696
00:21:56,880 --> 00:21:58,830
0,330 330,540 540,1380 1380,1530 1530,1950
almost all processors {you,know} use

697
00:21:58,830 --> 00:22:00,570
0,450 450,720 720,960 960,1290 1290,1740
roughly page size 4 kilobyte,

698
00:22:00,720 --> 00:22:02,580
0,570 600,900 900,1110 1110,1380 1380,1860
{or,support} page size 4 kilobytes.|
|

699
00:22:03,420 --> 00:22:04,860
0,120 120,240 240,630 630,810 810,1440
And so now getting translation
所以现在转换工作有些不同，

700
00:22:04,860 --> 00:22:06,840
0,210 210,540 540,1110 1140,1410 1500,1980
works slightly differently,| so here
|这里，我们有虚拟地址，分为两部分，一个是索引，一个是偏移量，

701
00:22:06,840 --> 00:22:08,130
0,150 150,270 270,390 390,750 750,1290
we have our virtual address,

702
00:22:09,370 --> 00:22:11,200
0,420 420,510 510,900 900,1170 1170,1830
basically, we split {in,two} pieces,

703
00:22:11,350 --> 00:22:12,640
0,150 150,810
an index

704
00:22:13,320 --> 00:22:14,900
0,360 360,420 420,960
and an offset,|
|

705
00:22:15,300 --> 00:22:16,230
0,240 240,330 330,420 420,810 810,930
and so the offset is
偏移量就是页面内部的字节。

706
00:22:16,230 --> 00:22:17,520
0,390 390,510 510,900 900,1200 1200,1290
basically the byte within the

707
00:22:17,520 --> 00:22:18,600
0,600
page.|
|

708
00:22:18,880 --> 00:22:20,170
0,300 300,420 420,660 660,780 780,1290
And so when we do,
所以当 MMU 做转换的时候，它使用索引在映射中，

709
00:22:20,170 --> 00:22:21,610
0,240 240,360 360,450 450,1170 1200,1440
{} when the MMU does

710
00:22:21,610 --> 00:22:23,020
0,90 90,900 930,1080 1080,1320 1320,1410
the translation, it takes the

711
00:22:23,020 --> 00:22:25,960
0,660 960,1560 1590,2040 2040,2790 2820,2940
index, {} indexes into the

712
00:22:25,960 --> 00:22:26,980
0,570
map,|
|

713
00:22:26,980 --> 00:22:28,660
0,270 270,450 450,960 1020,1320 1320,1680
that gives you some physical
给你一些内存中的物理页面编号，

714
00:22:28,660 --> 00:22:31,690
0,240 240,750 1650,1830 1830,2370 2820,3030
page number in memory,| and
|那个物理页面编号指向 4096 字节中的一些物理页。

715
00:22:31,690 --> 00:22:33,490
0,480 480,810 810,1080 1080,1590 1590,1800
that physical page number that

716
00:22:33,520 --> 00:22:35,590
0,420 420,540 540,990 1230,1830 1830,2070
points to some physical page

717
00:22:35,590 --> 00:22:37,740
0,90 90,1110 1110,1740
of 4096 bytes.|
|

718
00:22:38,040 --> 00:22:39,720
0,150 150,600 600,720 720,1170 1170,1680
And then the offset part,
然后偏移量部分，索引那个物理页，

719
00:22:39,870 --> 00:22:42,270
0,450 450,1020 1020,1410 1410,1890 2040,2400
basically indexes into that physical

720
00:22:42,270 --> 00:22:44,040
0,480 540,810 810,1260 1260,1350 1350,1770
page,| for example, the offset
|比如，偏移量是 12 那么你知道那个页中的第 12 个条目被使用。

721
00:22:44,040 --> 00:22:45,680
0,180 180,450 450,1140
is {you,know} 12,

722
00:22:45,770 --> 00:22:48,440
0,660 810,960 960,1440 1470,2130
then you know the,

723
00:22:48,600 --> 00:22:50,730
0,300 300,450 450,1140 1410,1920 1920,2130
{} the 12th entry of

724
00:22:50,730 --> 00:22:52,950
0,360 390,1020 1020,1110 1110,1590 1590,2220
that page is actually {}

725
00:22:52,980 --> 00:22:54,020
0,540
used.|
|

726
00:22:54,110 --> 00:22:55,310
0,180 180,390 390,510 510,960 960,1200
A lot of people, a
很多人问到了这个，

727
00:22:55,310 --> 00:22:56,510
0,180 180,300 300,480 480,990 990,1200
lot of you, mentioned in

728
00:22:56,510 --> 00:22:59,040
0,570 600,960 960,1200 1200,1410
the, mentioned in the,|
|

729
00:22:59,100 --> 00:23:00,300
0,300 300,660 660,720 720,780 780,1200
in response to the question,
回答这个问题，有一种方法获得偏移量，

730
00:23:00,300 --> 00:23:02,010
0,600 600,900 900,1050 1050,1410 1410,1710
there's [always] some scheme of

731
00:23:02,010 --> 00:23:04,410
0,330 330,420 420,1110 1110,1980 2160,2400
taking an offset| and adding
|把偏移量加到基础页面上，得到真正的物理地址位置，

732
00:23:04,410 --> 00:23:05,280
0,270 270,360 360,480 480,780 780,870
that to the base of

733
00:23:05,280 --> 00:23:07,980
0,90 90,630 870,1290 1290,1800 1800,2700
the page {} to obtain

734
00:23:07,980 --> 00:23:10,500
0,120 120,720 720,1140 1500,2250 2250,2520
the actual {} memory physical

735
00:23:10,500 --> 00:23:12,210
0,240 240,690 690,1170 1200,1290 1290,1710
memory location,| where {} value
|保存，加载值的那个位置。

736
00:23:12,210 --> 00:23:14,340
0,750 750,990 990,1440 1440,1590 1590,2130
store, where value will be

737
00:23:14,520 --> 00:23:15,660
0,450 450,630
loaded too.|
|

738
00:23:16,410 --> 00:23:17,190
0,210 210,300 300,390 390,480 480,780
And one of the interesting
关于 RISC-V 的一个有趣的事情是，

739
00:23:17,190 --> 00:23:18,330
0,300 300,600 600,660 660,840 840,1140
things about the {RISC-V -}

740
00:23:18,330 --> 00:23:19,890
0,300 300,690 690,840 840,930 930,1560
is| and this is a
|这也是对一些问题的回答，有人问物理地址或虚拟地址都是 64 位的，

741
00:23:19,950 --> 00:23:21,330
0,390 390,480 480,750 750,1200 1200,1380
response to some questions again,

742
00:23:21,330 --> 00:23:22,080
0,270 270,420 420,600 600,750 750,750
somebody asks {} like {}

743
00:23:22,380 --> 00:23:24,200
0,450 540,1290
the physical

744
00:23:24,200 --> 00:23:25,520
0,270 270,540 540,930 930,1260 1260,1320
{} or virtual addresses are

745
00:23:25,520 --> 00:23:27,140
0,570 570,1050
64 bits,|
|

746
00:23:28,250 --> 00:23:29,330
0,240 240,450 450,540 540,810 810,1080
which makes {} totally sense
这完全正确，因为 RISC-V 是 64 位寄存器。

747
00:23:29,330 --> 00:23:30,950
0,270 270,570 570,1080 1110,1380 1380,1620
correct, because the {RISC-V -}

748
00:23:30,950 --> 00:23:32,900
0,60 60,570 570,750 750,1380
is 64 bit register.|
|

749
00:23:33,220 --> 00:23:35,020
0,480 510,750 750,840 840,1230 1230,1800
{} But in fact on
但是实际上我们在 RISC-V 处理器上，并没有使用所有 64 位，

750
00:23:35,020 --> 00:23:36,670
0,270 270,630 630,1110 1110,1320 1320,1650
the RISC-V processor that we're

751
00:23:36,670 --> 00:23:38,890
0,660 990,1500 1530,1950 1950,2130 2130,2220
using, {} not all of

752
00:23:38,890 --> 00:23:40,660
0,60 60,660 660,870 870,1230 1230,1770
the 64 bits actually used,|
|

753
00:23:41,190 --> 00:23:43,890
0,990 990,1080 1080,1380 1380,2190 2520,2700
namely, the top 25 are
也就是，最高的 25 位没有使用。

754
00:23:43,890 --> 00:23:45,030
0,210 210,420 420,660 660,750 750,1140
actually not used at all.|
|

755
00:23:45,800 --> 00:23:47,510
0,660 660,870 870,960 960,1200 1200,1710
{} And so that limits
所以，这限制了虚拟地址，

756
00:23:47,510 --> 00:23:48,650
0,120 120,570 570,720 720,780 780,1140
the size of {} virtual

757
00:23:48,650 --> 00:23:50,330
0,510 720,870 870,1200 1200,1290 1290,1680
address,| that limits the size
|限制了虚拟地址空间在 2 的 39 次方，大概是 512 GB 。

758
00:23:50,330 --> 00:23:51,530
0,120 120,210 210,570 570,870 870,1200
of {} virtual address space

759
00:23:51,530 --> 00:23:52,520
0,270 270,570 570,660 660,930 930,990
2 to the power of

760
00:23:52,520 --> 00:23:53,640
0,570
39,

761
00:23:54,970 --> 00:23:56,700
0,180 180,420 420,480 480,1200
{} which is roughly

762
00:23:56,980 --> 00:23:58,980
0,330 330,1470
{} 512

763
00:23:59,230 --> 00:24:00,520
0,720
gigabyte.|
|

764
00:24:04,220 --> 00:24:06,230
0,630 810,1140 1140,1560 1560,1680 1680,2010
{} And so of course
当然未来版本的处理器可能需要支持更大的地址空间，[也可以完成]，

765
00:24:06,230 --> 00:24:07,940
0,90 90,180 180,960 1020,1560 1560,1710
you know later { -}

766
00:24:07,940 --> 00:24:09,500
0,540 540,630 630,720 720,1290 1290,1560
version of the processor might

767
00:24:09,500 --> 00:24:11,000
0,360 360,630 630,870 870,1410 1410,1500
support bigger address spaces {}

768
00:24:11,000 --> 00:24:12,680
0,210 210,300 300,1140 1260,1410 1410,1680
that is necessary and {[could,then]}

769
00:24:12,680 --> 00:24:13,730
0,210 210,570 600,750 750,990 990,1050
be done,| and so for
|比如使用这 25 位中的一些，来构建更大的虚拟地址空间。

770
00:24:13,730 --> 00:24:15,380
0,330 330,510 510,600 600,990 1050,1650
example some of those 25

771
00:24:15,380 --> 00:24:17,510
0,270 270,480 480,780 810,1500 1500,2130
bits that are basically used,

772
00:24:17,510 --> 00:24:19,610
0,240 240,360 360,810 810,1320 1470,2100
could be used to build

773
00:24:19,610 --> 00:24:21,840
0,630 660,1050 1050,1260 1260,1890
bigger virtual address spaces.|
|

774
00:24:22,310 --> 00:24:23,840
0,150 150,600 870,1290 1290,1410 1410,1530
And so, {} and so
所以，索引中还剩下 39 位，

775
00:24:23,840 --> 00:24:24,980
0,60 60,210 210,570 570,930 990,1140
in the index and you

776
00:24:24,980 --> 00:24:26,420
0,90 90,300 300,750 750,930 930,1440
know where 39 bits left,|
|

777
00:24:26,450 --> 00:24:27,260
0,120 120,210 210,420 420,480 480,810
you know as the virtual
虚拟地址中的 27 位是索引，我们等一会会看到为什么是 27 ，

778
00:24:27,260 --> 00:24:29,240
0,510 540,1020 1020,1380 1410,1710 1710,1980
address {27 -}, {27 -}

779
00:24:29,240 --> 00:24:30,500
0,390 420,570 570,1050 1050,1170 1170,1260
bits are index and we'll

780
00:24:30,500 --> 00:24:31,520
0,180 180,360 360,510 510,570 570,1020
see you in a second

781
00:24:31,520 --> 00:24:33,320
0,330 330,480 480,540 540,1290
why there are 27

782
00:24:33,470 --> 00:24:35,120
0,510 510,720 720,1350 1350,1470 1470,1650
{} are index| and then
|然后 12 位是偏移量，必须是 12 ，因为 2 的 12 次方是 4096 。

783
00:24:35,120 --> 00:24:36,380
0,90 90,930
the 12

784
00:24:36,470 --> 00:24:37,920
0,270 270,900
are offset,

785
00:24:38,280 --> 00:24:39,390
0,450 450,570 570,720 720,900 900,1110
and you know there has

786
00:24:39,390 --> 00:24:40,680
0,90 90,210 210,870 870,1140 1140,1290
to be 12, because 2

787
00:24:40,680 --> 00:24:42,240
0,120 120,210 210,510 510,1050 1080,1560
to the power 12 is

788
00:24:42,510 --> 00:24:44,220
0,1290
4096.|
|

789
00:24:45,420 --> 00:24:46,500
0,540
Alright?|
好的？|

790
00:24:46,590 --> 00:24:48,300
0,180 180,330 330,660 660,1290 1500,1710
So that's virtual addresses on
而在 RISC-V 物理地址，实际上是 56 位。

791
00:24:48,300 --> 00:24:50,310
0,60 60,300 300,840 960,1500 1500,2010
the {RISC-V -} physical addresses,

792
00:24:50,310 --> 00:24:51,300
0,120 120,210 210,330 330,570 570,990
as you can see here

793
00:24:51,300 --> 00:24:53,010
0,120 120,390 390,1050 1050,1260 1260,1710
are actually 56 bits wide.|
|

794
00:24:57,940 --> 00:24:59,380
0,150 150,270 270,600 600,1200 1200,1440
So the physical memory, {you,know}
所以物理内存可以比单个虚拟地址空间大。

795
00:24:59,380 --> 00:25:01,120
0,150 150,300 300,900 930,1320 1320,1740
can be bigger than the

796
00:25:01,570 --> 00:25:03,540
0,300 300,690 690,990 990,1500
single virtual address space.|
|

797
00:25:03,900 --> 00:25:05,040
0,180 180,330 330,660 660,780 780,1140
But it's limited {to,2} power
但是它限制在 2 的 56 次方，

798
00:25:05,040 --> 00:25:06,600
0,60 60,120 120,840 930,1050 1050,1560
up to 56,| you know
|大多数板可能不支持 2 的 56 次方物理内存，因为这是一个很大的物理内存，

799
00:25:06,600 --> 00:25:08,250
0,300 300,720 720,1140 1140,1260 1260,1650
most boards probably {you,know} don't

800
00:25:08,250 --> 00:25:09,210
0,420 420,540 540,660 660,750 750,960
support 2 to the power

801
00:25:09,210 --> 00:25:11,460
0,60 60,780 1080,1710 1710,2010 2010,2250
of 56 {} physical memory,

802
00:25:11,460 --> 00:25:12,990
0,240 240,450 480,1200 1200,1470 1470,1530
because a gigantic amount of

803
00:25:12,990 --> 00:25:15,240
0,330 330,780 1020,1500 1500,1620 1620,2250
physical memory,| but in principle
|但是理论上，如果你能制造出，一块板也能支持 2 的 56 次方物理内存。

804
00:25:15,240 --> 00:25:16,710
0,480 480,870 900,1020 1020,1440 1440,1470
{a,board} could, you know, {}

805
00:25:16,710 --> 00:25:18,240
0,480 480,570 570,690 690,1320 1320,1530
if you could manufacture it,

806
00:25:18,480 --> 00:25:19,800
0,300 300,720 720,960 960,1050 1050,1320
{} support {2,to} the power

807
00:25:19,800 --> 00:25:21,380
0,540 540,870 870,1170
56 physical memory.|
|

808
00:25:22,020 --> 00:25:23,100
0,120 120,300 300,360 360,510 510,1080
And so in this scheme,
所以在这种方案中，物理地址是 56 位，

809
00:25:23,130 --> 00:25:25,500
0,360 360,690 690,1320 1320,2130 2160,2370
then if 56 {} bits

810
00:25:25,500 --> 00:25:26,880
0,120 120,180 180,480 480,930 960,1380
for the physical address,| {44
|44 位是物理地址编号， PPN ，

811
00:25:26,880 --> 00:25:28,170
0,390 390,450 450,870 870,960 960,1290
-} are basically the physical

812
00:25:28,170 --> 00:25:30,360
0,270 270,720 720,810 810,1410 1680,2190
page number, the PPN,| 12
|12 位是偏移量，从虚拟地址继承而来。

813
00:25:30,360 --> 00:25:31,470
0,240 240,360 360,450 450,930 930,1110
again are the offset that

814
00:25:31,470 --> 00:25:33,300
0,120 120,750 750,1140 1140,1470 1470,1830
are inherited directly from the

815
00:25:33,360 --> 00:25:34,960
0,690 690,1170
virtual address.|
|

816
00:25:36,810 --> 00:25:38,240
0,150 150,300 300,480 480,900
Does that make sense?|
能理解吗？|

817
00:25:40,560 --> 00:25:42,330
0,300 300,300 1080,1380 1380,1560 1560,1770
So, {} you know stop
所以，在这里停顿一下，你可以整理自己的想法，

818
00:25:42,330 --> 00:25:43,380
0,60 60,120 120,300 300,630 630,1050
for a second here, you

819
00:25:43,380 --> 00:25:44,730
0,300 300,390 390,870 930,1140 1140,1350
collect your thoughts,| the only
|我想指出的是，这个材料很重要，

820
00:25:44,730 --> 00:25:45,630
0,330 330,390 390,600 600,660 660,900
point I wanted to make

821
00:25:45,630 --> 00:25:48,780
0,330 330,540 540,990 1770,2160 2160,3150
here is that this material

822
00:25:48,780 --> 00:25:50,070
0,180 180,630 630,840 840,1050 1050,1290
is important,| so just ask
|所以可以问问题，细节很重要，这会是很大一部分，

823
00:25:50,070 --> 00:25:53,160
0,660 930,1230 1230,1650 1650,2520 2670,3090
questions, the details matter, and

824
00:25:53,160 --> 00:25:54,480
0,120 120,300 300,750 750,960 960,1320
it will be a large

825
00:25:54,480 --> 00:25:56,010
0,510 540,930 930,1080 1080,1290 1290,1530
part of,| you, you really
|你需要完全理解这个东西，来做后面的实验，页表实验。

826
00:25:56,010 --> 00:25:56,910
0,150 150,240 240,630 630,750 750,900
need to understand all this

827
00:25:56,910 --> 00:25:58,290
0,390 420,870 870,1050 1050,1170 1170,1380
stuff {} to be able

828
00:25:58,290 --> 00:25:59,910
0,270 270,690 690,870 870,1290 1410,1620
to basically do lab, the

829
00:25:59,910 --> 00:26:01,560
0,270 270,720 780,1080 1080,1320 1320,1650
next lab, page table lab.|
|

830
00:26:02,580 --> 00:26:03,750
0,150 150,270 270,630 660,840 840,1170
Yeah, {Amiar -}, go ahead,
是的， Amiar ，请继续。

831
00:26:03,780 --> 00:26:04,760
0,450
please.|
|

832
00:26:05,210 --> 00:26:05,960
0,210 210,360 360,450 450,570 570,750
{} If you can go
你能退一张幻灯片吗，我希望屏幕显示，让我更清楚。

833
00:26:05,960 --> 00:26:07,490
0,270 270,480 480,1140 1170,1320 1320,1530
back one slide, I hope

834
00:26:07,490 --> 00:26:09,280
0,90 90,420 420,540 540,1200
the [screen], {so,I'm} clear.|
|

835
00:26:10,770 --> 00:26:12,260
0,270 270,510 510,870
Which one there,
哪一张，页表幻灯片？

836
00:26:12,290 --> 00:26:15,180
0,300 300,780 780,1200 1620,2430
page tables slide? Yeah.|
是的。|

837
00:26:20,250 --> 00:26:22,580
0,180 180,660 960,1740
This one? No.|
这张吗？不是。|

838
00:26:22,670 --> 00:26:24,110
0,330 360,630 630,870 870,1080 1260,1440
The most recent one, but
最近的那一张，但也不是很重要，

839
00:26:24,110 --> 00:26:25,250
0,90 90,330 330,600 600,750 750,1140
it also doesn't really matter,|
|

840
00:26:25,310 --> 00:26:26,780
0,330 330,870 870,1020 1020,1140 1140,1470
{} yeah, this is perfect,
是的，就是这张，谢谢。

841
00:26:26,780 --> 00:26:28,610
0,180 180,390 840,1080 1080,1230 1230,1830
thank you.| So I'm wondering
|所以，我想知道 4096 字节的页面，它在内存中分配是不是连续的。

842
00:26:28,700 --> 00:26:32,870
0,390 390,2520 2550,3450 3540,3810 3810,4170
this {4096,byte} range which we've

843
00:26:32,870 --> 00:26:34,760
0,450 450,540 540,1170 1410,1590 1590,1890
called a page, is that

844
00:26:34,790 --> 00:26:37,130
0,510 510,630 630,1380 1410,2040 2040,2340
assigned as a continuous chunk

845
00:26:37,130 --> 00:26:38,450
0,150 150,660 810,1080 1080,1260 1260,1320
in memory.| Yes, there's a
|是的，有连续的 4096 字节在物理内存中。

846
00:26:38,450 --> 00:26:41,780
0,450 450,1380 1740,2340 2400,3150 3150,3330
continuous physical, continuous range of

847
00:26:41,780 --> 00:26:45,440
0,1680 1800,2430 2430,2880 2880,3300
4096 bytes {in,physical} memory.|
|

848
00:26:46,520 --> 00:26:49,610
0,570 930,1110 1110,1560 1950,3000 3000,3090
{I,see} and then the.| {You,know,the,map}
我明白了，然后。|映射是以 4096 字节为粒度的。

849
00:26:49,610 --> 00:26:51,380
0,210 210,480 480,990 990,1470 1500,1770
at {[granularity] -} of {4096

850
00:26:51,380 --> 00:26:53,160
0,240 240,480 480,720 720,1170
- - -} bytes.|
|

851
00:26:53,490 --> 00:26:55,380
0,420 420,630 630,900 930,1740 1770,1890
Okay, and then 12 the
然后偏移量 12 ，因为 2 的 12 次方是 4096 ，所以可以包含每个块。

852
00:26:55,380 --> 00:26:57,270
0,930 1230,1500 1500,1650 1650,1770 1770,1890
offset like 2 to the

853
00:26:57,270 --> 00:26:59,520
0,300 300,450 450,1470 1470,1710 1710,2250
12 is 4096, {so,that's} sufficient

854
00:26:59,520 --> 00:27:00,990
0,600 690,1020 1020,1230 1230,1350 1350,1470
to cover each of the

855
00:27:00,990 --> 00:27:04,180
0,570 1470,1890 1890,1980 1980,2610
chunks.| {Yeah,each,byte} in {the,page}.|
|是的，页面中的每个字节。|

856
00:27:04,760 --> 00:27:06,740
0,180 180,390 390,570 570,1020 1080,1980
And where does the 56
还有图片中的 56 是怎么来的，之前的我都能跟上，但是我不知道它是怎么来的。

857
00:27:06,740 --> 00:27:08,480
0,270 270,720 750,900 900,990 990,1740
come from in the diagram,

858
00:27:08,600 --> 00:27:10,520
0,300 300,510 510,1200 1440,1680 1680,1920
I could follow up until

859
00:27:10,520 --> 00:27:11,480
0,150 150,270 270,360 360,780 780,960
then, but I didn't get

860
00:27:11,480 --> 00:27:13,220
0,150 150,330 330,540 540,840 1110,1740
where that came from {}.|
|

861
00:27:13,220 --> 00:27:15,140
0,810 810,1050 1050,1380
Designers cooked up,
这是设计师们决定的，硬件设计师决定物理内存是多大，

862
00:27:15,170 --> 00:27:16,790
0,270 270,420 420,720 720,1230 1230,1620
so the hardware designers decide

863
00:27:16,790 --> 00:27:17,930
0,180 180,510 540,630 630,840 840,1140
how big you know physical

864
00:27:17,930 --> 00:27:20,240
0,540 660,1410 1410,1620 1620,2010 2010,2310
addresses,| basically for whatever board
|取决于他们设计哪块板， RISC-V 设计师决定 56 位物理地址是个好主意。

865
00:27:20,240 --> 00:27:22,610
0,600 630,930 930,990 990,1410 1830,2370
they want to design {}

866
00:27:22,610 --> 00:27:24,260
0,420 420,810 810,1170 1200,1410 1410,1650
and so the {RISC-V -}

867
00:27:24,260 --> 00:27:26,840
0,750 1050,1290 1290,1710 1710,1860 1860,2580
designers who decided at 56

868
00:27:26,840 --> 00:27:28,040
0,270 270,630 630,990 990,1140 1140,1200
that physical addresses were a

869
00:27:28,040 --> 00:27:29,060
0,150 150,480
good idea.|
|

870
00:27:30,540 --> 00:27:32,010
0,420 420,660 660,990 990,1140 1140,1470
{} And usually the way
通常他们得出这个数字的方法是根据技术趋势。

871
00:27:32,010 --> 00:27:32,850
0,240 240,480 480,630 630,720 720,840
they come up with these

872
00:27:32,850 --> 00:27:33,930
0,420 420,690 690,840 840,990 990,1080
numbers is they look at

873
00:27:33,930 --> 00:27:35,500
0,510 510,1110
technology trends.|
|

874
00:27:35,500 --> 00:27:36,790
0,360 360,600 600,840 840,1170 1170,1290
And say like well we
比如我们想在后面的 5 年内可用，

875
00:27:36,790 --> 00:27:37,630
0,180 180,240 240,390 390,720 720,840
want to be able for

876
00:27:37,630 --> 00:27:39,070
0,60 60,360 360,870 870,1350 1350,1440
the next {sort,of,5} years,| you
|我们预测物理内存不会大于 2 的 56 次方。

877
00:27:39,070 --> 00:27:40,870
0,390 390,510 510,1110 1110,1470 1500,1800
know {we,don't} predict the physical

878
00:27:40,870 --> 00:27:42,220
0,360 360,510 510,660 660,1020 1020,1350
memory will be ever bigger

879
00:27:42,220 --> 00:27:42,940
0,120 120,270 270,360 360,450 450,720
than 2 to the power

880
00:27:42,940 --> 00:27:44,140
0,750
56.|
|

881
00:27:44,740 --> 00:27:45,850
0,450 450,540 540,810 810,870 870,1110
Probably they think it won't
可能他们想的是不会大于某个更小的值，留出一些余量，

882
00:27:45,850 --> 00:27:47,140
0,90 90,330 330,720 780,1080 1080,1290
be bigger than something much

883
00:27:47,140 --> 00:27:48,610
0,450 450,780 780,1140 1140,1230 1230,1470
smaller, but then you know

884
00:27:48,610 --> 00:27:50,350
0,180 180,300 300,720 960,1260 1260,1740
give them some {leeway -},|
|

885
00:27:50,350 --> 00:27:51,250
0,150 150,300 300,420 420,780 780,900
you know, in case you
防止他们的预测出错，他们选择一个更大的数。

886
00:27:51,250 --> 00:27:53,260
0,150 150,300 300,690 690,1260 1530,2010
know their predictions wrong, {}

887
00:27:53,260 --> 00:27:54,430
0,270 270,540 540,930 930,1110 1110,1170
they pick a slightly {}

888
00:27:54,430 --> 00:27:55,380
0,240 240,570
bigger number.|
|

889
00:27:56,700 --> 00:27:57,660
0,120 120,240 240,390 390,630 630,960
Does that make sense?| {I,see},
理解了吗？|理解了，是的，谢谢。

890
00:27:58,640 --> 00:28:00,230
0,330 360,900 1170,1350 1350,1530 1530,1590
yeah, thanks.| {Yeah,a} lot of
|是的，很多人问到这个。

891
00:28:00,230 --> 00:28:01,720
0,210 210,420 420,630 630,960
people ask about this.|
|

892
00:28:03,880 --> 00:28:05,320
0,390 390,720 720,840 840,1110 1110,1440
Anybody else, who raised hand,
还有人举手吗，我想有很多人要提问，

893
00:28:05,350 --> 00:28:06,160
0,240 240,390 390,540 540,600 600,810
I think there's a bunch

894
00:28:06,160 --> 00:28:07,570
0,60 60,300 300,660 660,1200 1200,1410
of people asking questions| and
|但是我的 zomm 不能显示超过两个人举手，只是显示很多人举手。

895
00:28:07,570 --> 00:28:09,730
0,570 570,1020 1050,1560 1560,1800 1800,2160
unfortunately my zoom doesn't show

896
00:28:09,730 --> 00:28:10,570
0,150 150,360 360,450 450,600 600,840
if more than two people

897
00:28:10,570 --> 00:28:12,250
0,240 240,570 570,1050 1080,1410 1410,1680
raised hands, just multiple people

898
00:28:12,250 --> 00:28:13,560
0,90 90,330 330,420 420,780
are raising their hands.|
|

899
00:28:13,710 --> 00:28:15,030
0,390 390,570 570,870 870,1110 1110,1320
So you please jump in
所以如果有问题，可以直接提问。

900
00:28:15,060 --> 00:28:15,780
0,120 120,180 180,270 270,330 330,720
if you have a question.|
|

901
00:28:20,160 --> 00:28:21,300
0,660
Okay.|
好的。|

902
00:28:21,570 --> 00:28:24,450
0,720 1110,1380 1380,1440 1440,1830 2190,2880
I have a question. {Yeah,go,ahead}.|
我有一个问题。是的，请继续。|

903
00:28:24,660 --> 00:28:27,150
0,390 390,600 600,1140 1800,2010 2010,2490
{} So if the virtual
所以，虚拟内存可以达到 2 的 27 次方，物理内存可以达到 2 的 56 次方，

904
00:28:27,150 --> 00:28:28,680
0,450 450,690 690,960 960,1290 1290,1530
memory is up to 2

905
00:28:28,680 --> 00:28:30,060
0,120 120,240 240,570 570,690 690,1380
to the power of 27

906
00:28:30,060 --> 00:28:31,290
0,180 180,300 300,720 720,1110 1110,1230
and the physical memory is

907
00:28:31,290 --> 00:28:32,490
0,240 240,420 420,570 570,690 690,1200
up {to,2} to the power

908
00:28:32,670 --> 00:28:34,440
0,150 150,270 270,390 390,1320 1350,1770
{} to the 56 right,|
|

909
00:28:34,710 --> 00:28:37,460
0,720 1110,1260 1260,1470 1470,2220
so we could have,
所以我们有多个进程，会耗尽虚拟内存，而没有用完物理内存。

910
00:28:38,540 --> 00:28:41,240
0,570 900,1410 1410,1890 1890,2520 2520,2700
we have multiple processes that

911
00:28:41,240 --> 00:28:42,620
0,180 180,660 660,810 810,990 990,1380
could exhaust all their virtual

912
00:28:42,620 --> 00:28:45,020
0,450 450,960 1500,1950 1950,2160 2160,2400
memories without using up all

913
00:28:45,020 --> 00:28:47,920
0,210 210,660 660,1110
the physical memory.|
|

914
00:28:48,320 --> 00:28:49,380
0,540
Yeah,
是的，完全正确。

915
00:28:52,230 --> 00:28:53,620
0,180 180,510 510,810
that's absolutely correct.|
|

916
00:28:53,980 --> 00:28:55,630
0,630 750,1110 1110,1260 1260,1320 1320,1650
Okay.| I have a question
好的。|我也有个问题，

917
00:28:55,630 --> 00:28:58,750
0,240 1380,1650 1650,1650 2550,2880 2880,3120
{too -},| oh so this
|这个物理地址的 56 ，它是不是可能内存位置的数目，

918
00:28:58,750 --> 00:29:01,090
0,930 960,1200 1200,1350 1350,1740 1740,2340
56 for the physical address

919
00:29:01,120 --> 00:29:03,180
0,180 180,600 600,1530
is that the,

920
00:29:03,240 --> 00:29:05,160
0,240 240,750 750,900 900,1470 1470,1920
the number of possible memory

921
00:29:05,160 --> 00:29:07,260
0,960 1350,1560 1560,1560 1560,1920 1920,2100
locations,| I I don't think
|我不认为它是位的数目，因为这是 64 位机器，

922
00:29:07,260 --> 00:29:08,610
0,180 180,420 420,750 750,990 990,1350
it's the number of bits

923
00:29:08,610 --> 00:29:10,890
0,630 630,750 750,1380 1380,1590 1590,2280
because the 64 bit machine,|
|

924
00:29:11,160 --> 00:29:12,960
0,270 270,780 780,1380 1380,1650 1650,1800
{} that 56 could go
56 可能扩展到 64 ，但是他们选择了只使用 56 。

925
00:29:12,960 --> 00:29:14,580
0,240 240,600 720,1140 1140,1470 1470,1620
up to {64 -}, but

926
00:29:14,580 --> 00:29:16,320
0,120 120,480 480,900 900,1260
they just chose it

927
00:29:16,320 --> 00:29:18,120
0,240 240,540 540,720 720,1500 1530,1800
to have just 56.| That's
|正确，你可以这样想，只需要使用 56 位而不是 64 位。

928
00:29:18,120 --> 00:29:19,710
0,300 480,810 810,1230 1230,1500 1500,1590
correct, that's correct, one way

929
00:29:19,710 --> 00:29:20,400
0,90 90,240 240,510 510,570 570,690
to think about it, then

930
00:29:20,400 --> 00:29:21,120
0,120 120,330 330,450 450,540 540,720
they only have to run

931
00:29:21,120 --> 00:29:23,070
0,480 480,1410 1410,1530 1530,1590 1590,1950
56 wide on the board

932
00:29:23,100 --> 00:29:24,760
0,120 120,390 390,480 480,1200
as opposed to 64.|
|

933
00:29:25,530 --> 00:29:26,640
0,180 180,660
I see,
我明白了，谢谢。

934
00:29:26,640 --> 00:29:27,580
0,120
thanks.|
|

935
00:29:30,240 --> 00:29:31,890
0,540 720,1200 1200,1470 1470,1560 1560,1650
Okay?| I also have a
好的？|我也有个问题，

936
00:29:31,890 --> 00:29:35,340
0,600 630,1290 1590,2430 2460,2700 2700,3450
question,| {} so kind of
|你能回退一张幻灯片吗。

937
00:29:35,370 --> 00:29:36,330
0,180 180,270 270,450 450,750 750,960
could you go back one

938
00:29:36,330 --> 00:29:38,240
0,360 360,810
slide, maybe.|
|

939
00:29:38,800 --> 00:29:41,920
0,570 1080,1830 1890,2190 2190,2280 2280,3120
{} So from the CPU,
从 CPU ，我们通过 MMU 到内存，

940
00:29:41,950 --> 00:29:43,750
0,600 630,870 870,1380 1380,1620 1620,1800
{} we go through the

941
00:29:43,750 --> 00:29:45,160
0,720 720,960 960,1140 1140,1290 1290,1410
MMU and then to the

942
00:29:45,160 --> 00:29:48,160
0,630 1050,1410 1410,1830 1860,2370 2370,3000
memory,| {} but where where
|但是对于不同进程有什么不同，

943
00:29:48,160 --> 00:29:50,440
0,450 450,630 630,780 780,1980 2010,2280
here is the distinction for

944
00:29:50,440 --> 00:29:53,470
0,510 510,2010 2130,2520 2520,2790 2790,3030
different processes,| because like each
|因为每个进程，比如 shell 进程有地址 0x1000 ，ls 进程也有地址 0x1000 ，

945
00:29:53,470 --> 00:29:55,780
0,660 690,1260 1260,2010 2010,2220 2220,2310
process, like process like the

946
00:29:55,780 --> 00:29:57,340
0,240 240,720 720,990 990,1380 1380,1560
shell process has something at

947
00:29:57,340 --> 00:29:59,560
0,480 480,810 870,1410 1410,1800 1800,2220
address like {0x1000 - -

948
00:29:59,560 --> 00:30:01,450
0,330 330,600 600,900 900,1500 1560,1890
- - - -} and

949
00:30:01,450 --> 00:30:02,920
0,210 210,360 360,750 750,1170 1170,1470
then the ls process also

950
00:30:02,920 --> 00:30:04,210
0,120 120,420 420,570 570,900 900,1290
has something at address {0x1000

951
00:30:04,210 --> 00:30:05,740
0,270 270,510 510,750 750,1050 1050,1530
- - - - -},|
|

952
00:30:05,860 --> 00:30:07,030
0,240 240,330 330,510 510,600 600,1170
so we need to translate
所以我们需要转换它们到不同的物理地址，所以。

953
00:30:07,030 --> 00:30:09,850
0,210 210,330 330,780 780,1440 2040,2820
those to different physical so

954
00:30:10,030 --> 00:30:12,660
0,1230 1230,1770 1770,2430
yeah.| {The,satp} register,
|satp 寄存器包含使用哪个映射的地址，

955
00:30:13,330 --> 00:30:15,490
0,810 810,930 930,1530 1530,1800 1800,2160
contains the register, {} contains

956
00:30:15,490 --> 00:30:16,840
0,90 90,450 450,630 630,930 930,1350
the address of which map

957
00:30:16,840 --> 00:30:18,120
0,120 120,570
to use,|
|

958
00:30:18,460 --> 00:30:19,870
0,300 300,720 720,960 960,1170 1170,1410
so ls runs with {its,own}
所以 ls 使用自己的映射运行， cat 也使用自己的映射运行。

959
00:30:19,870 --> 00:30:21,790
0,600 690,870 870,1260 1260,1770 1770,1920
map, you know {cat,run} with

960
00:30:21,790 --> 00:30:23,950
0,300 300,900 930,1350 1350,1920 1920,2160
{its,own} map.| Okay, so each
|好的，所以每个进程有完全是它自己的的映射。

961
00:30:23,950 --> 00:30:26,050
0,390 390,600 600,1050 1080,1320 1320,2100
process will have its completely

962
00:30:26,050 --> 00:30:27,780
0,240 240,750
own map.|
|

963
00:30:28,140 --> 00:30:29,740
0,210 210,540 540,780 780,1080
Makes sense, thank you.|
理解了，谢谢。|

964
00:30:29,740 --> 00:30:30,280
0,180 180,240 240,390 390,540 540,540
And in fact there's a
实际上，这是引出下一个知识点的[方法]，

965
00:30:30,280 --> 00:30:32,230
0,600 630,1230 1230,1380 1380,1440 1440,1950
great [way] to the next

966
00:30:33,100 --> 00:30:35,200
0,780 1080,1290 1290,1470 1470,1710 1710,2100
point,| so if every process
|所以每个进程有自己的映射，这个映射有多大，比如我画的这个。

967
00:30:35,200 --> 00:30:36,580
0,150 150,270 270,420 420,930
has its own map,

968
00:30:36,870 --> 00:30:38,220
0,150 150,660 810,1080 1080,1230 1230,1350
you know how big is

969
00:30:38,220 --> 00:30:39,360
0,210 210,600 600,780 780,960 960,1140
this map like that I'd

970
00:30:39,360 --> 00:30:40,720
0,330 330,810
drawn here.|
|

971
00:30:40,870 --> 00:30:42,130
0,240 240,390 390,690 690,1050 1080,1260
Well, that map is 2
这个映射有 2 的 27 次方个条目，这是很大的。

972
00:30:42,130 --> 00:30:43,900
0,90 90,210 210,510 510,1290 1320,1770
to the power 27 entries

973
00:30:43,900 --> 00:30:44,860
0,420
correct,

974
00:30:46,460 --> 00:30:47,960
0,450 450,600 600,780 780,1020 1020,1500
{} and that's pretty big.|
|

975
00:30:49,030 --> 00:30:50,200
0,300 300,510 510,540 540,720 720,1170
{} And that would fill
所以如果每个进程有完整的页表，那会很快填满物理内存，

976
00:30:50,200 --> 00:30:52,000
0,300 300,690 690,990 990,1650 1710,1800
physical memory reasonable quickly {}

977
00:30:52,000 --> 00:30:53,650
0,210 210,540 540,1020 1020,1530 1530,1650
if every process exactly have

978
00:30:53,650 --> 00:30:55,690
0,120 120,900 900,990 990,1380 1410,2040
{} complete you know [populated]

979
00:30:55,690 --> 00:30:56,620
0,450
map,|
|

980
00:30:56,620 --> 00:30:58,360
0,120 120,240 240,480 480,1320 1350,1740
and then there's gigantic, means
这是巨大的，意味着每个进程都很大，

981
00:30:58,360 --> 00:30:59,410
0,90 90,330 330,690 690,780 780,1050
that every process is very

982
00:30:59,410 --> 00:31:00,970
0,360 750,930 930,1050 1050,1140 1140,1560
big,| and so in fact
|所以，实际上，这不是硬件存储页表的方式，

983
00:31:01,060 --> 00:31:02,380
0,240 240,360 360,600 600,690 690,1320
this is not the way

984
00:31:02,440 --> 00:31:04,360
0,540 570,900 900,1260 1260,1650 1650,1920
the {hardware,actually -} stores page

985
00:31:04,360 --> 00:31:05,740
0,540 540,600 600,1050 1050,1140 1140,1380
tables,| {} you can think
|你可以把它想成一个数组，从 0 到 2 的 27 次方，

986
00:31:05,740 --> 00:31:06,850
0,210 210,300 300,870 870,1020 1020,1110
about it conceptually as an

987
00:31:06,850 --> 00:31:08,260
0,630 840,960 960,1080 1080,1290 1290,1410
array, you know going from

988
00:31:08,260 --> 00:31:09,940
0,270 270,720 720,810 810,1110 1110,1680
0 to {2,to} power 27,|
|

989
00:31:09,940 --> 00:31:10,750
0,120 120,420 420,480 480,720 720,810
but actually is not what
但是实际上不是这样的。

990
00:31:10,750 --> 00:31:12,100
0,330 330,420 420,1020
happens in practice.|
|

991
00:31:12,160 --> 00:31:14,410
0,150 150,780 960,1230 1230,1260 1260,2250
In practice, it's a multi-level
实际上，它是一个多级结构，

992
00:31:14,650 --> 00:31:16,420
0,390 390,870 930,1110 1110,1440 1440,1770
{} structure,| that here actually
|这是由硬件实现的真正的 RISC-V 页表结构。

993
00:31:16,420 --> 00:31:18,600
0,90 90,660 660,960 960,1680
the real {RISC-V -}

994
00:31:20,900 --> 00:31:22,160
0,210 210,630
page table

995
00:31:23,380 --> 00:31:24,970
0,780 780,960 960,1110 1110,1200 1200,1590
structure and what the hardware

996
00:31:24,970 --> 00:31:26,180
0,630
implements.|
|

997
00:31:26,820 --> 00:31:28,260
0,270 270,450 450,960 960,1290 1290,1440
And so what happens with
所以我们之前看到的 27 位索引发生了什么，

998
00:31:28,260 --> 00:31:29,580
0,90 90,750 750,1050 1050,1200 1200,1320
the 27 bits that we

999
00:31:29,580 --> 00:31:32,200
0,330 330,1020 1200,1410 1410,2070
saw earlier, the index,|
|

1000
00:31:32,260 --> 00:31:35,020
0,210 210,480 480,1080 1110,1710 1920,2760
it's actually split in three
它分位三个 9 位数字。

1001
00:31:35,320 --> 00:31:38,160
0,480 510,840 840,1170 1230,2340
{} 9 bit numbers.|
|

1002
00:31:38,220 --> 00:31:39,990
0,570 570,690 690,1170 1170,1260 1260,1770
And the first the top
最开始的顶部 9 位作为顶层页表目录的索引，

1003
00:31:39,990 --> 00:31:41,610
0,240 240,750 1020,1230 1230,1560 1560,1620
9 bits are used to

1004
00:31:41,610 --> 00:31:43,770
0,660 660,1050 1050,1410 1500,1890 1890,2160
index into the top level

1005
00:31:43,770 --> 00:31:45,960
0,270 270,960 1200,1950 1950,2070 2070,2190
page table directory as they

1006
00:31:45,960 --> 00:31:47,040
0,90 90,540
are called,|
|

1007
00:31:47,130 --> 00:31:48,420
0,210 210,390 390,480 480,690 690,1290
and so in one directory,
所以在一个目录中，是 4096 字节，跟页面大小一样。

1008
00:31:48,420 --> 00:31:49,020
0,60 60,150 150,330 330,420 420,600
you know one of these

1009
00:31:49,020 --> 00:31:50,430
0,510 510,600 600,960 990,1140 1140,1410
guys, you know is {4096

1010
00:31:50,430 --> 00:31:53,430
0,510 510,1050 1530,2010 2010,2460 2460,3000
-} bytes, {4096 -} bytes,

1011
00:31:54,250 --> 00:31:55,600
0,330 330,450 450,510 510,810 810,1350
just like the page size.|
|

1012
00:31:56,160 --> 00:31:58,830
0,570 660,1980 1980,2370 2370,2580 2580,2670
A PTE entry one of
一个 PTE 条目是 64 字节，抱歉，我的意思是 64 位，跟寄存器一样， 8 字节。

1013
00:31:58,830 --> 00:32:00,120
0,150 150,630 630,840 840,1020 1020,1290
the entries in the thing

1014
00:32:00,120 --> 00:32:02,400
0,480 480,1230 1230,1830
is 64 bytes,

1015
00:32:03,520 --> 00:32:04,990
0,240 240,720 720,1080 1080,1110 1110,1470
{} 64 bit I mean,

1016
00:32:05,020 --> 00:32:07,540
0,450 1080,1470 1470,1590 1590,2070 2070,2520
sorry, like the register with,

1017
00:32:07,540 --> 00:32:09,000
0,240 240,420 420,960
so 8 bytes.|
|

1018
00:32:09,000 --> 00:32:10,230
0,180 180,360 360,660 660,810 810,1230
And so there's gonna mean
所以是 4096 除以 8 ，有 512 个条目在每个目录页面中。

1019
00:32:10,230 --> 00:32:11,940
0,240 240,360 360,630 630,840 840,1710
that you do {4096 -}

1020
00:32:12,710 --> 00:32:14,330
0,390 390,540 540,1080 1140,1470 1470,1620
divided by 8, means there

1021
00:32:14,330 --> 00:32:16,260
0,60 60,780 780,1440
are 512 entries

1022
00:32:16,260 --> 00:32:17,550
0,150 150,300 300,390 390,810 840,1290
in one of those directory

1023
00:32:17,550 --> 00:32:18,660
0,600
pages.|
|

1024
00:32:19,370 --> 00:32:20,810
0,180 180,510 510,690 690,1110 1110,1440
So basically what happens is
所以，发生的是 satp 指向顶层目录，

1025
00:32:20,810 --> 00:32:22,340
0,210 210,330 330,600 600,1170 1200,1530
like the {satp -} points

1026
00:32:22,340 --> 00:32:24,620
0,120 120,240 240,840 1140,1650 1650,2280
to the top root directory,|
|

1027
00:32:24,650 --> 00:32:25,670
0,150 150,390 390,480 480,810 810,1020
we take the top level
我们使用顶层 9 位索引页面目录，得到一个新的物理页面编号。

1028
00:32:25,670 --> 00:32:27,560
0,270 270,630 630,1080 1080,1500 1500,1890
9 bits index into the

1029
00:32:27,740 --> 00:32:29,720
0,330 330,1050 1470,1620 1620,1770 1770,1980
page directory, and now gives

1030
00:32:29,720 --> 00:32:30,710
0,90 90,120 120,360 360,720 720,990
us a new physical page

1031
00:32:30,710 --> 00:32:31,580
0,420
number.|
|

1032
00:32:32,040 --> 00:32:33,330
0,120 120,270 270,600 600,840 840,1290
And that physical page number
这个物理页面编号是下一级页面目录，

1033
00:32:33,330 --> 00:32:35,040
0,360 360,720 720,1020 1020,1530 1530,1710
is the page directory for

1034
00:32:35,040 --> 00:32:36,510
0,90 90,360 360,780 990,1170 1170,1470
the next level,| so then
|完后我们使用下一级索引索引页面目录，

1035
00:32:36,510 --> 00:32:37,650
0,120 120,300 300,360 360,600 600,1140
we use the next level

1036
00:32:37,980 --> 00:32:40,350
0,210 210,960 1230,1740 1740,2160 2160,2370
{} index to index into

1037
00:32:40,350 --> 00:32:42,570
0,510 600,870 870,1560 1710,1830 1830,2220
that page directory| and then
|同样的，我们会找到一个底层页面目录。

1038
00:32:42,570 --> 00:32:43,620
0,90 90,300 300,480 480,570 570,1050
you know and so forth,

1039
00:32:43,650 --> 00:32:44,340
0,120 120,240 240,390 390,600 600,690
you know we like to

1040
00:32:44,340 --> 00:32:45,390
0,270 270,720 750,840 840,930 930,1050
find one you know we

1041
00:32:45,390 --> 00:32:46,710
0,180 180,360 390,810 810,1110 1110,1320
get the bottom level page

1042
00:32:46,710 --> 00:32:47,800
0,630
directory.|
|

1043
00:32:47,800 --> 00:32:48,940
0,240 240,450 450,840 840,1050 1050,1140
And that basically gives us
这就是虚拟内存映射到物理内存的条目。

1044
00:32:48,940 --> 00:32:50,860
0,120 120,750 840,1170 1170,1560 1560,1920
the entry, {} that maps

1045
00:32:50,860 --> 00:32:51,730
0,120 120,420 420,690 690,810 810,870
the virtual address to {}

1046
00:32:51,730 --> 00:32:53,020
0,330 330,840
physical address.|
|

1047
00:32:55,680 --> 00:32:56,700
0,210 210,270 270,510 510,720 720,1020
So in some sense, it's
所以某种意义上，它和上一张幻灯片展示的很像，

1048
00:32:56,700 --> 00:32:58,170
0,180 180,510 510,960 960,1230 1230,1470
very similar to {} where

1049
00:32:58,170 --> 00:32:59,160
0,270 270,360 360,450 450,750 750,990
showed in the previous slide,|
|

1050
00:32:59,160 --> 00:33:00,840
0,420 420,510 510,960 960,1350 1350,1680
except {you,know} basically index happens
除了索引发生三步而不是一步，

1051
00:33:00,840 --> 00:33:01,830
0,90 90,300 300,630 630,930 930,990
in three steps instead of

1052
00:33:01,830 --> 00:33:03,330
0,240 240,690 1020,1260 1260,1380 1380,1500
one step,| and this is
|这种方案的优点是，

1053
00:33:03,330 --> 00:33:04,980
0,720 720,840 840,1140 1140,1560 1560,1650
advantage, the main advantage of

1054
00:33:04,980 --> 00:33:06,990
0,120 120,510 510,690 690,1140 1380,2010
this scheme is that,| {if,large}
|如果地址空间的大部分空间没有使用，你不需要为它们分配页表条目。

1055
00:33:06,990 --> 00:33:08,250
0,630 630,690 690,750 750,1020 1020,1260
parts of the address space

1056
00:33:08,250 --> 00:33:09,600
0,60 60,300 300,510 510,1080 1230,1350
are not being used, you

1057
00:33:09,600 --> 00:33:10,290
0,150 150,300 300,360 360,540 540,690
don't have to have any

1058
00:33:10,290 --> 00:33:11,610
0,240 240,510 510,840 840,1050 1050,1320
page table entries for that.|
|

1059
00:33:12,930 --> 00:33:14,040
0,210 210,600 600,780 780,930 930,1110
For example, let's say you
比如，有一个地址空间，

1060
00:33:14,040 --> 00:33:15,510
0,210 210,450 450,570 570,900 900,1470
have a {address -} space,|
|

1061
00:33:16,120 --> 00:33:18,130
0,360 360,870 900,1170 1170,1470 1470,2010
that has only one page
它只有一个页面，最底部的页面 4096 ，在地址空间中没有其他页面，

1062
00:33:18,130 --> 00:33:21,370
0,330 330,420 420,720 720,1230 1950,3240
like the bottom page 4096,

1063
00:33:22,800 --> 00:33:24,330
0,450 450,780 780,990 990,1350 1350,1530
and no other pages are

1064
00:33:24,330 --> 00:33:25,740
0,90 90,150 150,420 420,930 1230,1410
in the address space,| so
|只有地址 0 到 4095 ， 4096 真正映射，

1065
00:33:25,740 --> 00:33:27,840
0,330 330,720 720,1020 1020,1110 1110,2100
only addresses 0 to 4095,

1066
00:33:27,840 --> 00:33:29,130
0,90 90,390 390,540 540,840 840,1290
{} 4096 are actually mapped,|
|

1067
00:33:29,490 --> 00:33:30,720
0,150 150,330 330,600 600,900 900,1230
how many page table entry
那么需要多少页表条目或页表目录来映射这个页面。

1068
00:33:30,720 --> 00:33:31,830
0,150 150,360 360,630 630,1050 1050,1110
or page table directories do

1069
00:33:31,830 --> 00:33:33,060
0,150 150,360 360,600 600,870 870,1230
you need to map that

1070
00:33:33,360 --> 00:33:35,360
0,810 1020,1560
particular page.|
|

1071
00:33:39,280 --> 00:33:40,180
0,240 240,330 330,480 480,720 720,900
Well, you need one of
好的，你需要一个顶级条目，你需要这个条目里的值是 0 ，

1072
00:33:40,180 --> 00:33:41,600
0,420 420,900
top, correct,

1073
00:33:41,790 --> 00:33:43,320
0,180 180,270 270,600 600,990 990,1530
and you need basically value

1074
00:33:43,320 --> 00:33:45,240
0,120 120,420 420,810 810,1290 1320,1920
in that entry for 0,|
|

1075
00:33:46,500 --> 00:33:47,850
0,150 150,420 420,660 660,900 900,1350
the top level 9 bits,
最顶级的 9 位， 0 0 ，你需要一个条目是 0 。

1076
00:33:47,850 --> 00:33:49,560
0,90 90,360 360,900 900,1500 1530,1710
you know 0 0, so

1077
00:33:49,560 --> 00:33:50,760
0,90 90,420 420,690 690,1050 1050,1200
you need an entry for

1078
00:33:50,760 --> 00:33:51,820
0,540
0.|
|

1079
00:33:51,880 --> 00:33:52,990
0,150 150,330 330,570 570,690 690,1110
So that means you need
你还需要一个中间条目，它对应接下来的九个 [0 位]，

1080
00:33:52,990 --> 00:33:54,910
0,420 420,690 690,990 990,1500 1740,1920
one middle level entry, you

1081
00:33:54,910 --> 00:33:56,500
0,120 120,270 270,720 720,1050 1050,1590
know that basically {} corresponds

1082
00:33:56,500 --> 00:33:57,640
0,90 90,150 150,660 690,840 840,1140
to the next, you know

1083
00:33:57,670 --> 00:33:59,200
0,480 480,780 780,1200 1230,1380 1380,1530
nine 0 bits| and then
|然后还需要一个条目对应接下来的九个 0 位。

1084
00:33:59,200 --> 00:34:00,280
0,240 240,570 570,690 690,780 780,1080
one entry for the {}

1085
00:34:00,280 --> 00:34:01,800
0,180 180,390 390,660 660,1080
next nine 0 bits.|
|

1086
00:34:02,140 --> 00:34:03,550
0,210 210,570 570,690 690,810 810,1410
So basically we get away
所以，我们需要三个页面目录。

1087
00:34:03,610 --> 00:34:07,520
0,510 690,1410 1590,2700 2700,3390
with three page directories.|
|

1088
00:34:11,420 --> 00:34:12,680
0,300 300,450 450,780 780,1170 1170,1260
In our previous scheme on
在之前幻灯片的前一个方案中，我们需要 2 的 27 次方个条目，

1089
00:34:12,680 --> 00:34:14,240
0,90 90,390 390,960 1080,1440 1440,1560
the previous slide correct, we

1090
00:34:14,240 --> 00:34:15,080
0,120 120,300 300,390 390,480 480,840
have 2 to the power

1091
00:34:15,080 --> 00:34:17,390
0,690 690,1290 1320,1860 1860,1950 1950,2310
27 entries,| now we basically
|现在我们只需要 3 乘以 512 个条目就可以了。

1092
00:34:17,390 --> 00:34:18,440
0,150 150,240 240,420 420,600 600,1050
have to have 3 times

1093
00:34:18,440 --> 00:34:20,030
0,360 360,1050 1050,1380 1380,1500 1500,1590
whatever 512 entries that were

1094
00:34:20,030 --> 00:34:20,900
0,330
done.|
|

1095
00:34:21,920 --> 00:34:24,320
0,300 300,390 390,660 660,1230 1320,2400
That's the main reason why
这就是硬件使用这种多级树方案的原因。

1096
00:34:24,350 --> 00:34:26,240
0,630 630,750 750,870 870,1290 1290,1890
{} you know actual hardware

1097
00:34:26,420 --> 00:34:27,410
0,210 210,600 600,660 660,930 930,990
{} has a sort of

1098
00:34:27,410 --> 00:34:30,260
0,840 1020,1500 1500,1770 1770,2370 2370,2850
hierarchical {}, {} multilevel tree

1099
00:34:30,290 --> 00:34:31,340
0,540
scheme.|
|

1100
00:34:32,570 --> 00:34:33,860
0,240 240,600 600,810 810,1080 1080,1290
Any questions about this, because
关于这个有什么问题吗，因为这很重要。

1101
00:34:33,860 --> 00:34:35,260
0,150 150,330 330,810
it's pretty important.|
|

1102
00:34:36,270 --> 00:34:37,290
0,180 180,360 360,510 510,630 630,1020
{Samir -}, {} go ahead.|
Samir ，继续。|

1103
00:34:39,000 --> 00:34:42,200
0,510 720,1200 1200,1800 1800,2460
So my question is,
我的问题是，每个页表的 PPN 数字是 44 位，

1104
00:34:42,760 --> 00:34:45,160
0,300 300,960 1290,1560 1560,1950 1950,2400
as since the PPN number

1105
00:34:45,160 --> 00:34:46,750
0,210 210,660 660,900 900,1320 1320,1590
from each page table is

1106
00:34:46,750 --> 00:34:48,380
0,330 330,540 540,1170
{44 -} bits,|
|

1107
00:34:48,440 --> 00:34:50,480
0,420 420,750 750,1410 1650,1950 1950,2040
and the second, say the
虚拟内存边上的表，我们从哪里得到其他 12 位。

1108
00:34:50,480 --> 00:34:52,670
0,270 270,960 1170,1890 1890,2070 2070,2190
middle table [resides] on the

1109
00:34:52,670 --> 00:34:54,350
0,420 420,900 1290,1470 1470,1560 1560,1680
virtual memory, where do we

1110
00:34:54,350 --> 00:34:55,970
0,240 240,420 660,1050 1050,1380 1380,1620
get the missing 12 bits

1111
00:34:55,970 --> 00:34:56,880
0,240
from.|
|

1112
00:34:57,300 --> 00:34:58,620
0,180 180,390 390,660 660,960 960,1320
Well, the final 12 bits,
好的，最后的 12 位，好的，你说这个 44 ，是吧。

1113
00:34:58,620 --> 00:35:00,240
0,210 210,570 600,1020 1020,1200 1200,1620
okay so good good good,

1114
00:35:00,270 --> 00:35:01,620
0,180 180,600 600,870 870,1080 1080,1350
so you're saying these {44

1115
00:35:01,620 --> 00:35:02,980
0,300 300,690
-} right.|
|

1116
00:35:02,980 --> 00:35:04,120
0,450 450,690 690,780 780,960 960,1140
Yes.| What is going on
是的。|这里是如何发生的，

1117
00:35:04,120 --> 00:35:05,350
0,90 90,270 270,540 540,780 780,1230
with that,| well all page
|好的，所有页面目录或页面[行]，它们的物理页面编号是 44 加上 12 个零位。

1118
00:35:05,350 --> 00:35:06,700
0,180 180,420 420,870 870,1050 1050,1350
all page directories or page

1119
00:35:06,700 --> 00:35:07,800
0,330
line,

1120
00:35:08,180 --> 00:35:09,680
0,300 300,450 450,570 570,1080 1080,1500
and so they basically they're

1121
00:35:09,680 --> 00:35:11,300
0,630 660,960 960,1200 1200,1500 1500,1620
{} physical page number is

1122
00:35:11,300 --> 00:35:13,280
0,270 270,630 630,840 870,1590 1770,1980
{44 -} plus 12 {}

1123
00:35:13,280 --> 00:35:16,320
0,0 1080,1740 1740,2010 2010,2400
{} 12 zero bits.|
|

1124
00:35:18,940 --> 00:35:20,110
0,330 330,450 450,630 630,840 840,1170
And so what actually happens
所以，如果我们看这些 PTE 条目，它们都有相同的形式，

1125
00:35:20,110 --> 00:35:20,680
0,60 60,150 150,330 330,390 390,570
if we look at these

1126
00:35:20,680 --> 00:35:22,540
0,600 600,1170 1200,1470 1470,1710 1710,1860
PTE entries, they all have

1127
00:35:22,540 --> 00:35:23,680
0,60 60,330 330,510 510,600 600,1140
the same sort of form

1128
00:35:23,740 --> 00:35:24,430
0,120 120,390 390,510 510,630 630,690
right,| if you look at
|看其中一个，有 44 位，还有 12 个零位，

1129
00:35:24,430 --> 00:35:26,050
0,150 150,210 210,390 390,930 1500,1620
one of these guys, {there,are}

1130
00:35:26,050 --> 00:35:28,150
0,270 270,750 780,1500 1650,1920 1920,2100
{44 -} bits, {} there

1131
00:35:28,150 --> 00:35:29,620
0,60 60,450 450,720 720,1170 1170,1470
are 12 bits zeros,| so
|所以 44 加上 12 是 56 ，给我们一个物理地址，

1132
00:35:29,620 --> 00:35:30,730
0,90 90,300 300,450 450,720 870,1110
that gives {us -} {}

1133
00:35:30,730 --> 00:35:32,890
0,360 360,570 570,1170 1410,1560 1560,2160
44 plus 12 is 56,

1134
00:35:32,890 --> 00:35:33,640
0,180 180,390 390,570 570,690 690,750
so that gives us a

1135
00:35:33,640 --> 00:35:35,500
0,360 360,870 1260,1560
physical address, right.|
|

1136
00:35:36,610 --> 00:35:38,320
0,510 660,810 810,930 930,1110 1110,1710
{} And so that means
所以，这里有 64 位，有一些位是保留的，没有使用，

1137
00:35:38,470 --> 00:35:40,270
0,600 600,1080 1080,1380 1380,1590 1590,1800
there's 64 bits, there's actually

1138
00:35:40,270 --> 00:35:41,800
0,180 180,450 450,930 1170,1290 1290,1530
some bits left there not

1139
00:35:41,800 --> 00:35:43,240
0,150 150,570 600,720 720,1080 1320,1440
being used,| in fact the
|实际上，末尾的 10 位完全没有使用，

1140
00:35:43,240 --> 00:35:44,800
0,300 300,600 600,840 840,990 990,1560
bottom 12 bits will basically

1141
00:35:44,800 --> 00:35:46,270
0,150 150,240 240,480 480,780 810,1470
or the bottom 10 definitely

1142
00:35:46,510 --> 00:35:47,890
0,300 300,510 510,960 960,1140 1140,1380
bottom bits are not used

1143
00:35:47,890 --> 00:35:49,090
0,300 300,420 420,510 510,840 840,1200
{at,all}| and in fact the
|实际上，页表硬件保存了很多标志来控制转换，

1144
00:35:49,090 --> 00:35:52,210
0,360 360,930 1110,1920 2160,2550 2670,3120
paging hardware stores or stores

1145
00:35:52,210 --> 00:35:54,220
0,60 60,300 300,360 360,1140 1200,2010
a bunch of flags that

1146
00:35:54,220 --> 00:35:55,870
0,660 660,720 720,1380 1380,1470 1470,1650
control the translation,| we'll talk
|我们过一会会讨论这些标志。

1147
00:35:55,870 --> 00:35:56,650
0,210 210,360 360,660 660,720 720,780
about those flags in the

1148
00:35:56,650 --> 00:35:57,560
0,420
second.|
|

1149
00:35:57,740 --> 00:36:00,020
0,540 900,1500 1530,1740 1740,2040 2040,2280
{} And {} but they're
但是它们控制转换，它们保存在末尾 10 位。

1150
00:36:00,020 --> 00:36:01,400
0,480 510,780 780,960 960,1320 1320,1380
there {} to control the

1151
00:36:01,400 --> 00:36:03,050
0,600 600,720 720,900 900,1320 1320,1650
translation and they're stored basically

1152
00:36:03,050 --> 00:36:04,250
0,60 60,150 150,450 450,750 750,1200
in the bottom 10 bits.|

1153
00:36:05,100 --> 00:36:06,600
0,270 270,450 450,690 690,1020 1020,1500
{} It also means that
这也意味着，如果你把它们加起来，是 54 位，还有 10 位保留。

1154
00:36:06,660 --> 00:36:07,470
0,120 120,330 330,510 510,630 630,810
you know if you add

1155
00:36:07,470 --> 00:36:08,850
0,210 210,420 420,630 630,810 810,1380
these two up, that's 54

1156
00:36:08,850 --> 00:36:10,770
0,480 810,1290 1290,1470 1470,1680 1680,1920
bits, basically there's ten bits

1157
00:36:10,770 --> 00:36:11,860
0,480
left.|
|

1158
00:36:11,920 --> 00:36:13,390
0,180 180,390 390,990 1020,1290 1290,1470
There are unused, those 10
它们没有被使用，这些 10 位也是为未来的增长（保留的），

1159
00:36:13,390 --> 00:36:14,920
0,270 270,660 660,1230 1260,1350 1350,1530
bits are again, you know

1160
00:36:14,920 --> 00:36:17,230
0,330 330,810 810,1500 1890,2220 2220,2310
for future growth,| so at
|某个时刻，我们可能有一种新的 RISC-V 处理器，

1161
00:36:17,230 --> 00:36:18,040
0,150 150,390 390,480 480,690 690,810
some point we might have

1162
00:36:18,040 --> 00:36:18,850
0,60 60,270 270,540 540,630 630,810
a new type of {RISC-V

1163
00:36:18,850 --> 00:36:20,710
0,240 240,870 1110,1290 1290,1470 1470,1860
-} processor| that will have
|它有稍微不同的页表结构，

1164
00:36:20,710 --> 00:36:22,060
0,90 90,480 480,750 750,1110 1110,1350
a slightly different structure page

1165
00:36:22,060 --> 00:36:23,620
0,660 780,930 930,1020 1020,1260 1260,1560
tables,| and it might actually
|它就可能物理页面编号多于 44 位。

1166
00:36:23,620 --> 00:36:25,180
0,210 210,810 840,1110 1110,1380 1380,1560
have bigger than {44 -}

1167
00:36:25,180 --> 00:36:26,470
0,240 240,510 510,750 750,1020 1020,1290
bits for the physical page

1168
00:36:26,470 --> 00:36:27,260
0,270
number.|
|

1169
00:36:29,440 --> 00:36:30,720
0,270 270,420 420,600
Okay? Thank you.|
好的？谢谢。|

1170
00:36:31,380 --> 00:36:32,340
0,210 210,600 600,720 720,810 810,960
In fact, you can see]
你可以看这里，如果你看画在这里的一个条目，

1171
00:36:32,340 --> 00:36:33,090
0,120 120,450 450,600 600,660 660,750
it here, like if you

1172
00:36:33,090 --> 00:36:33,990
0,150 150,240 240,270 270,570 570,900
look at a single entry,

1173
00:36:33,990 --> 00:36:36,540
0,450 480,990 990,1380 1380,1950 2070,2550
correct, that's drawn here {},|
|

1174
00:36:36,540 --> 00:36:38,240
0,90 90,210 210,420 420,1170
you know they're basically
这里有 10 个位保留，没有被使用。

1175
00:36:38,470 --> 00:36:40,210
0,900 900,1140 1140,1530 1530,1680 1680,1740
10 bits left, that are

1176
00:36:40,210 --> 00:36:41,520
0,180 180,360 360,780
not being used.|
|

1177
00:36:42,000 --> 00:36:43,440
0,540 810,1020 1020,1140 1140,1290 1290,1440
{} Okay, so let's look
好的，我们来看标志位，因为它很重要。

1178
00:36:43,440 --> 00:36:44,400
0,90 90,180 180,780 780,930 930,960
at the flags for a

1179
00:36:44,400 --> 00:36:45,720
0,480 510,990 990,1140 1140,1260 1260,1320
second, because it's sort of

1180
00:36:45,720 --> 00:36:46,940
0,630
important.|
|

1181
00:36:47,610 --> 00:36:49,680
0,390 390,690 690,1590 1620,1890 1890,2070
So every translation in the
每个转换的最后 10 位，保存着许多标志位，

1182
00:36:49,680 --> 00:36:50,550
0,300 300,510 510,720 720,840 840,870
bottom ten bits, there are

1183
00:36:50,550 --> 00:36:51,690
0,60 60,240 240,330 330,630 630,1140
a bunch of flag stored|
|

1184
00:36:51,990 --> 00:36:53,820
0,240 240,330 330,720 720,1350 1470,1830
and the first flag {}
第一个标志是 valid ，

1185
00:36:53,820 --> 00:36:55,280
0,390 390,960
is valid,|
|

1186
00:36:55,510 --> 00:36:57,850
0,420 420,960 990,1260 1260,1860 1860,2340
{} if {} {valid,bit} set,
如果设置了 valid 位，意味着这是一个可用的 PTE ，可以使用它来转换。

1187
00:36:57,880 --> 00:36:58,780
0,210 210,540 540,690 690,810 810,900
that means this is a

1188
00:36:58,780 --> 00:37:00,940
0,420 420,1170 1350,1890 1890,2010 2010,2160
valid PTE, and you can

1189
00:37:00,940 --> 00:37:02,540
0,150 150,270 270,360 360,1050
use it for translation.|
|

1190
00:37:03,150 --> 00:37:05,100
0,330 330,480 480,990 1170,1830 1830,1950
And so we're we're going
所以，我们来看看这个例子，

1191
00:37:05,100 --> 00:37:06,360
0,60 60,270 270,360 360,660 660,1260
to run my little example

1192
00:37:06,360 --> 00:37:07,770
0,150 150,270 270,480 480,1260 1260,1410
that I used here,| three
|三个页面目录只使用了条目 0 ，只有条目 0 设置了 valid 位，

1193
00:37:07,770 --> 00:37:09,630
0,240 240,930 1050,1260 1260,1590 1590,1860
page directories were only entry

1194
00:37:09,630 --> 00:37:11,160
0,390 390,480 480,930 990,1260 1260,1530
zero is used, then only

1195
00:37:11,160 --> 00:37:12,930
0,210 210,810 810,990 990,1230 1230,1770
entry zero will have {valid,bits}

1196
00:37:12,930 --> 00:37:14,010
0,420 510,690 690,900 900,960 960,1080
set| and none of the
|其他 511 个条目都没有设置 valid 位。

1197
00:37:14,010 --> 00:37:15,390
0,240 240,510 510,600 600,930 930,1380
other {511 - -} entries,

1198
00:37:15,390 --> 00:37:16,740
0,180 180,540 540,720 720,1230 1230,1350
will not have valid bit

1199
00:37:16,740 --> 00:37:17,440
0,330
set.|
|

1200
00:37:18,610 --> 00:37:20,590
0,120 120,210 210,510 510,810 810,1980
And that basically tells {}
告诉 MMU ，不需要继续查询这个 PTE ，这个 PTE 不包含有效信息。

1201
00:37:20,650 --> 00:37:21,700
0,210 210,330 330,360 360,630 630,1050
the {MMU - -} well,

1202
00:37:21,700 --> 00:37:22,360
0,60 60,210 210,360 360,540 540,660
you know you don't have

1203
00:37:22,360 --> 00:37:24,700
0,90 90,360 360,660 660,840 840,2340
to chase down {this,PTE}, {this,PTE}

1204
00:37:24,700 --> 00:37:26,440
0,390 390,780 780,900 900,1230 1230,1740
just contains no valid information.|
|

1205
00:37:27,820 --> 00:37:30,400
0,600 780,990 990,1260 1260,1890 2070,2580
Then {} R means you're
然后 R 表示允许从页面读，

1206
00:37:30,400 --> 00:37:31,600
0,330 330,450 450,840 840,1050 1050,1200
allowed to read from that

1207
00:37:31,600 --> 00:37:33,700
0,570 630,990 990,1560 1680,1860 1860,2100
page,| write means you're allowed
|write 表示允许向页面写，

1208
00:37:33,700 --> 00:37:34,990
0,150 150,540 540,630 630,780 780,1290
to write to the page,|
|

1209
00:37:35,230 --> 00:37:37,420
0,660 660,1290 1440,1770 1770,2130 2130,2190
execute means you're allowed to
execute 表示可以执行它的指令，

1210
00:37:37,420 --> 00:37:39,300
0,360 360,870 870,1140 1140,1380
execute instruction from it,|
|

1211
00:37:39,330 --> 00:37:41,640
0,450 450,930 960,1380 1380,1950 2190,2310
{ -} user means you
user 表示运行在用户空间的程序也可以访问这个页面，

1212
00:37:41,640 --> 00:37:42,810
0,270 270,570 570,840 840,1080 1080,1170
know {} this page is

1213
00:37:42,810 --> 00:37:44,640
0,270 270,870 870,1110 1110,1230 1230,1830
also accessible by a process

1214
00:37:44,640 --> 00:37:46,760
0,660 660,900 900,1140 1140,1680
running in user space,|
|

1215
00:37:47,340 --> 00:37:48,180
0,150 150,240 240,300 300,480 480,840
and then the other bits
其他位不是那么重要，会在（用到的）某个时刻展示，

1216
00:37:48,180 --> 00:37:49,200
0,120 120,390 390,510 510,960 960,1020
you not that important, it

1217
00:37:49,200 --> 00:37:49,920
0,180 180,360 360,450 450,540 540,720
will show up at some

1218
00:37:49,920 --> 00:37:51,960
0,390 750,1050 1050,1560 1560,1650 1650,2040
point,| {} {those,are} {sort,of} five
|这些就是五个比较重要的位。

1219
00:37:51,960 --> 00:37:53,240
0,390 390,810
important bits.|
|

1220
00:37:55,970 --> 00:37:57,380
0,150 150,300 300,450 450,870
Does that make sense?|
能理解吗？|

1221
00:37:59,300 --> 00:38:00,280
0,810
Yeah,
是的， Nithya ，我可能读错你的名字，我向你道歉。

1222
00:38:01,740 --> 00:38:03,870
0,240 240,660 1050,1320 1320,1590 1590,2130
{Nithya -}, I'd probably mispronouncing

1223
00:38:03,870 --> 00:38:05,670
0,90 90,570 630,810 810,1740 1740,1800
your name, I apologize to

1224
00:38:05,670 --> 00:38:06,540
0,150
you.|
|

1225
00:38:06,860 --> 00:38:08,660
0,420 420,720 720,810 810,1560 1560,1800
That's that's the representation, thank
就是那么读的，谢谢，

1226
00:38:08,660 --> 00:38:10,460
0,240 690,1050 1050,1230 1230,1560 1560,1800
you,| {} I had a
|我有一个关于三个页表的问题，

1227
00:38:10,460 --> 00:38:12,020
0,150 150,600 600,1110 1140,1410 1410,1560
quick question about {} the

1228
00:38:12,020 --> 00:38:15,020
0,360 360,660 660,1200 1800,2370 2700,3000
three page tables,| so how
|这些地址或 PPN 值是如何组成最后的物理地址的，我可能错过了。

1229
00:38:15,020 --> 00:38:16,730
0,150 150,450 450,1290 1290,1530 1530,1710
are the addresses or like

1230
00:38:16,730 --> 00:38:19,250
0,90 90,810 810,1590 1620,2340 2340,2520
the PPN values combined to

1231
00:38:19,250 --> 00:38:20,630
0,270 270,360 360,660 660,1020 1020,1380
form the final physical address

1232
00:38:20,630 --> 00:38:22,280
0,720 720,900 900,1170
{I,might} miss that.|
|

1233
00:38:22,370 --> 00:38:23,660
0,270 270,600 600,840 840,990 990,1290
{} Yeah, well {I,may} not
是的，可能说的不是非常明确，

1234
00:38:23,660 --> 00:38:25,310
0,150 150,330 330,660 660,900 900,1650
say that [] very explicitly,|
|

1235
00:38:25,400 --> 00:38:27,440
0,540 570,1050 1110,1290 1290,1560 1560,2040
{} so the first PPN
第一个 PPN 在顶级页表，

1236
00:38:27,440 --> 00:38:28,790
0,330 330,630 630,720 720,960 960,1350
{correct,in} top the page table,|
|

1237
00:38:29,330 --> 00:38:30,470
0,150 150,420 420,990 990,1080 1080,1140
the first PPN in the
在顶级页面目录的第一个 PPN 包含了下一级的物理地址。

1238
00:38:30,470 --> 00:38:31,970
0,240 240,630 630,690 690,840 840,1500
top level of page directory

1239
00:38:32,300 --> 00:38:35,150
0,630 630,870 870,1680 1920,2640 2670,2850
contains the physical address of

1240
00:38:35,150 --> 00:38:37,040
0,90 90,660 660,960 960,1410 1500,1890
the next level down, right.|
|

1241
00:38:37,780 --> 00:38:39,580
0,630 630,960 960,1470 1470,1530 1530,1800
And one contains the one
这个又包含下一级，

1242
00:38:39,580 --> 00:38:40,720
0,240 240,450 450,900 900,1020 1020,1140
next level down| and then
|然后在最后一个，我们有 44 位，

1243
00:38:40,720 --> 00:38:42,190
0,120 120,240 240,750 750,1080 1080,1470
in the final one we

1244
00:38:42,190 --> 00:38:43,690
0,300 300,480 480,930 1020,1290 1290,1500
still have are [] {44

1245
00:38:43,690 --> 00:38:45,340
0,180 180,600 690,990 990,1440 1440,1650
-} bits,| that contains then
|包含我们想要转换的真正的页面物理地址。

1246
00:38:45,340 --> 00:38:47,110
0,120 120,750 780,1200 1200,1530 1530,1770
the actual physical address of

1247
00:38:47,110 --> 00:38:48,250
0,120 120,600 600,810 810,930 930,1140
the page that we're actually

1248
00:38:48,250 --> 00:38:49,800
0,210 210,300 300,780 780,1020
trying to translate to.|
|

1249
00:38:50,150 --> 00:38:52,550
0,720 750,930 930,1170 1170,1620 1710,2400
Okay, that makes sense.| Okay,
好的，理解了。|好的，有一个有趣的问题，

1250
00:38:52,550 --> 00:38:53,960
0,120 120,360 360,900 900,1200 1200,1410
and one interesting question, just

1251
00:38:53,960 --> 00:38:55,430
0,150 150,240 240,540 540,870 900,1470
let us {[] -},| before
|让我在回答其他两个举手的问题之前，先回答自己的问题，

1252
00:38:55,490 --> 00:38:57,050
0,300 300,450 450,1170 1200,1380 1380,1560
let me answer my own

1253
00:38:57,050 --> 00:38:58,670
0,330 330,690 990,1350 1350,1440 1440,1620
question before answering the two

1254
00:38:58,670 --> 00:39:00,830
0,270 270,480 480,870 1020,1680 1830,2160
raised hands here,| {} look
|再看这张图片，为什么页面目录保存的是物理页面编号，而不是虚拟地址。

1255
00:39:00,830 --> 00:39:02,900
0,270 270,330 330,450 450,960 1200,2070
back at this picture, why,

1256
00:39:02,930 --> 00:39:03,920
0,240 240,330 330,420 420,750 750,990
why are the physical page

1257
00:39:03,920 --> 00:39:04,970
0,240 240,600 600,690 690,840 840,1050
numbers stored in these page

1258
00:39:04,970 --> 00:39:06,040
0,690
directories,

1259
00:39:07,800 --> 00:39:09,780
0,270 270,630 630,960 990,1500 1500,1980
why not a virtual address.|
|

1260
00:39:11,520 --> 00:39:12,750
0,390 390,480 480,690 690,870 870,1230
Because we need to look
因为我们要查找内存，比如在内存中查找下一个目录。

1261
00:39:12,750 --> 00:39:14,040
0,120 120,360 360,600 600,1050 1050,1290
it up in memory like

1262
00:39:14,040 --> 00:39:15,300
0,270 270,420 420,540 540,810 810,1260
look up the next directory

1263
00:39:15,300 --> 00:39:17,040
0,120 120,660 810,1230 1260,1500 1500,1740
in memory.| Yeah right, we
|是的，正确，我们不能使用一种转换方案依赖另一种转换方案，

1264
00:39:17,040 --> 00:39:18,780
0,120 120,420 420,900 930,1170 1170,1740
could not have a translation

1265
00:39:18,780 --> 00:39:20,040
0,450 450,780 780,840 840,990 990,1260
scheme depends on yet another

1266
00:39:20,040 --> 00:39:22,200
0,510 510,900 900,1290 1290,1680 1680,2160
translation scheme,| we could {sort,of}
|我们可能会递归查找，所以那是没意义的。

1267
00:39:22,200 --> 00:39:23,250
0,90 90,450 450,750 750,930 930,1050
recursive [] look, so that

1268
00:39:23,250 --> 00:39:24,680
0,120 120,390 390,570 570,990
just doesn't make sense.|
|

1269
00:39:24,680 --> 00:39:25,430
0,90 90,150 150,510 510,570 570,750
That is exactly the right
这就是正确答案，它必须是物理编号，

1270
00:39:25,430 --> 00:39:26,280
0,330
answer,

1271
00:39:26,310 --> 00:39:26,880
0,120 120,330 330,420 420,510 510,570
it has to be a

1272
00:39:26,880 --> 00:39:28,140
0,330 330,690 720,930 930,1110 1110,1260
physical number,| how about the
|那么 satp 呢，它保存的是物理地址还是虚拟地址。

1273
00:39:28,140 --> 00:39:29,010
0,270 270,600 600,720 720,810 810,870
{satp -}, what do you

1274
00:39:29,010 --> 00:39:30,210
0,210 210,570 570,930 930,1050 1050,1200
{satp - -}, what does

1275
00:39:30,210 --> 00:39:31,230
0,90 90,420 420,660 660,930 930,1020
it store, it store a

1276
00:39:31,230 --> 00:39:32,700
0,300 300,600 600,630 630,1050 1050,1470
physical address or virtual address.|
|

1277
00:39:39,190 --> 00:39:41,350
0,420 420,750 750,1530 1530,1980 1980,2160
{} Also physical, assuming that
也是物理地址，因为第一个页面目录也在内存中。

1278
00:39:41,350 --> 00:39:42,490
0,120 120,420 420,600 600,1020 1020,1140
the first page directory is

1279
00:39:42,490 --> 00:39:45,250
0,240 240,300 300,720 720,1020 2220,2760
also in memory right.| {Yeah,exactly},
|是的，没错，它必须是一个物理编号，因为我们使用它来转换。

1280
00:39:45,400 --> 00:39:46,030
0,180 180,330 330,480 480,540 540,630
so it has to be

1281
00:39:46,030 --> 00:39:47,380
0,30 30,360 360,750 750,1020 1020,1350
a physical number, because we're

1282
00:39:47,380 --> 00:39:48,220
0,210 210,480 480,540 540,750 750,840
actually trying to use it

1283
00:39:48,220 --> 00:39:50,120
0,120 120,840
for translation.|
|

1284
00:39:50,120 --> 00:39:52,010
0,690 690,1290 1290,1590 1590,1710 1710,1890
And, {} so you know
所以， satp 需要知道页面目录[路由]的物理页面编号。

1285
00:39:52,010 --> 00:39:52,820
0,180 180,480 480,540 540,720 720,810
the satp you need to

1286
00:39:52,820 --> 00:39:53,960
0,210 210,450 450,540 540,900 900,1140
know what the physical page

1287
00:39:53,960 --> 00:39:55,910
0,300 300,660 990,1380 1380,1470 1470,1950
number is [on] the [route]

1288
00:39:55,940 --> 00:39:57,620
0,120 120,480 510,720 720,1200
of the page directory.|
|

1289
00:39:59,180 --> 00:39:59,960
0,240 240,330 330,420 420,570 570,780
Okay, there were two other
好的，这里有两个问题，两个人举手了，

1290
00:39:59,960 --> 00:40:01,190
0,510 510,780 780,930 930,1170 1170,1230
questions or to people who

1291
00:40:01,190 --> 00:40:02,750
0,150 150,270 270,750 1050,1200 1200,1560
raise their hands,| you do,
|你可以重复你的问题，如果还没有解决。

1292
00:40:02,750 --> 00:40:03,680
0,420
{}

1293
00:40:06,120 --> 00:40:08,300
0,330 330,420 420,930 930,1650
repeat your question if

1294
00:40:08,750 --> 00:40:09,680
0,270 270,360 360,570 570,690 690,930
if it hasn't been answered

1295
00:40:09,680 --> 00:40:10,640
0,360
yet.|
|

1296
00:40:10,760 --> 00:40:12,920
0,600 630,1260 1290,1380 1380,2040 2040,2160
So there's a hierarchy of
所以有一个三个表组成的层次结构，

1297
00:40:12,920 --> 00:40:14,900
0,330 330,1110 1440,1620 1620,1830 1830,1980
three tables| and each of
|每个表由虚拟地址的一部分 9 个位索引，

1298
00:40:14,900 --> 00:40:16,190
0,150 150,300 300,870 870,1170 1170,1290
them is indexed by a

1299
00:40:16,190 --> 00:40:17,900
0,300 300,450 450,540 540,1080 1080,1710
part of the virtual address,

1300
00:40:17,930 --> 00:40:20,440
0,630 660,1170 1170,1440 1440,1830
each nine bits long,|
|

1301
00:40:22,740 --> 00:40:23,910
0,210 210,600 600,900 900,1110 1110,1170
so I'm not sure I
我不太明白它们之间的连接是如何发生的，

1302
00:40:23,910 --> 00:40:27,690
0,1050 1410,2100 2100,2850 2850,3360 3360,3780
understand how [chaining] between them

1303
00:40:27,690 --> 00:40:28,890
0,510 510,600 600,750 750,960 960,1200
happens| and what it's [meant]
|只使用三个 9 位来索引每个表不是已经足够了吗？

1304
00:40:28,890 --> 00:40:30,150
0,90 90,690 690,870 870,1110 1110,1260
to accomplish like shouldn't it

1305
00:40:30,150 --> 00:40:31,620
0,120 120,840 870,1020 1020,1230 1230,1470
be sufficient to just use

1306
00:40:31,620 --> 00:40:34,230
0,390 390,1290 1590,1860 1860,2130 2130,2610
those three nine bit addresses

1307
00:40:34,230 --> 00:40:34,980
0,90 90,360 360,540 540,690 690,750
to index into each of

1308
00:40:34,980 --> 00:40:35,760
0,240
them.|
|

1309
00:40:36,780 --> 00:40:38,190
0,210 210,510 510,750 750,870 870,1410
That's correct, so the first
正确，第一个顶级 9 位用来索引第一个顶级页表目录，

1310
00:40:38,580 --> 00:40:39,600
0,360 360,540 540,750 750,930 930,1020
top level nine bits are

1311
00:40:39,600 --> 00:40:40,380
0,210 210,270 270,480 480,690 690,780
used to index that in

1312
00:40:40,380 --> 00:40:41,850
0,90 90,360 360,720 720,1200 1200,1470
the first top page level

1313
00:40:41,850 --> 00:40:43,140
0,480 480,720 750,1140 1140,1200 1200,1290
directory,| the second in the
|第二个索引第二个，但三个索引第三个。

1314
00:40:43,140 --> 00:40:44,250
0,210 210,630 630,750 750,840 840,1110
next one and the third

1315
00:40:44,250 --> 00:40:45,520
0,60 60,120 120,360 360,630
in the third one.|
|

1316
00:40:46,060 --> 00:40:47,240
0,540

1317
00:40:48,240 --> 00:40:49,470
0,330 330,600 600,750 750,990 990,1230
So, maybe I'm just not
所以，可能我没有明白，当一个进程访问一个虚拟地址，

1318
00:40:49,470 --> 00:40:52,290
0,720 720,900 900,1470 1530,2100 2130,2820
understanding this correctly, so when

1319
00:40:52,380 --> 00:40:54,150
0,450 450,600 600,1170 1170,1710 1710,1770
{} a process requests a

1320
00:40:54,150 --> 00:40:56,520
0,690 720,1560 1560,1920 1920,2040 2040,2370
certain virtual address to be

1321
00:40:56,520 --> 00:40:57,870
0,300 300,570 810,930 930,1140 1140,1350
looked up,| it loads into
|虚拟地址加载到 satp 寄存器，得到对应的顶级页表，

1322
00:40:57,870 --> 00:41:00,000
0,570 630,1410 1410,1920 1920,2070 2070,2130
the satp register or the

1323
00:41:00,000 --> 00:41:02,700
0,390 390,900 1170,1380 1380,1920 2310,2700
CPU does and that gets

1324
00:41:02,700 --> 00:41:05,070
0,60 60,180 180,1200 1200,1860 1860,2370
to the corresponding correct highest

1325
00:41:05,070 --> 00:41:07,360
0,570 570,870 870,1290
level page table,|
|

1326
00:41:07,640 --> 00:41:09,830
0,210 210,570 570,1020 1020,1440 1440,2190
and then that page table
然后那个页表会。

1327
00:41:10,590 --> 00:41:12,100
0,960
will.|
|

1328
00:41:12,130 --> 00:41:12,790
0,150 150,270 270,450 450,600 600,660
And we use them to
我们使用 27 位中的顶级 9 位来索引页面目录。

1329
00:41:12,790 --> 00:41:14,200
0,300 300,510 510,780 780,1140 1140,1410
top level nine bits from

1330
00:41:14,200 --> 00:41:16,030
0,60 60,840 1170,1290 1290,1680 1680,1830
the 27 to index into

1331
00:41:16,030 --> 00:41:17,580
0,210 210,420 420,960
that page directory.|
|

1332
00:41:18,660 --> 00:41:19,680
0,150 150,270 270,510 510,750 750,1020
And then what is what
那么它的结果是什么，

1333
00:41:19,680 --> 00:41:20,850
0,120 120,240 240,630 630,810 810,1170
is the result of that,|
|

1334
00:41:20,850 --> 00:41:22,260
0,150 150,330 330,600 600,990 990,1410
like if the result is
比如结果是 MMU 创建一个新页表吗。

1335
00:41:22,320 --> 00:41:24,210
0,390 390,840 840,1410 1470,1740 1740,1890
there's nothing there, does the

1336
00:41:24,210 --> 00:41:26,160
0,300 300,750 750,1500 1500,1650 1650,1950
{MMU -} create a page

1337
00:41:26,160 --> 00:41:27,900
0,420 450,930 960,1170 1170,1290 1290,1740
table.| No no, the MMU
|不，不是， MMU 告诉操作系统或处理器，抱歉，我不能转换这个地址，

1338
00:41:27,900 --> 00:41:29,610
0,330 330,570 570,690 690,1020 1020,1710
basically tells the operating system

1339
00:41:29,850 --> 00:41:31,050
0,150 150,360 360,450 450,840 840,1200
or tells the processor, sorry

1340
00:41:31,050 --> 00:41:32,400
0,90 90,330 330,690 690,810 810,1350
I couldn't translate that address|
|

1341
00:41:32,580 --> 00:41:35,040
0,1080 1080,1560 1560,2040 2040,2280 2280,2460
{} and basically turns into
然后生成一个页面错误，这个我们后面会讨论。

1342
00:41:35,040 --> 00:41:35,940
0,60 60,300 300,600 630,780 780,900
a page fault which we'll

1343
00:41:35,940 --> 00:41:36,660
0,180 180,390 390,420 420,600 600,720
talk about a little bit

1344
00:41:36,660 --> 00:41:37,460
0,330
later.|
|

1345
00:41:38,970 --> 00:41:40,980
0,180 180,510 870,1470 1470,1950 1950,2010
But just cannot translate the
但是不能转换地址，它不转换地址，

1346
00:41:40,980 --> 00:41:42,390
0,390 390,450 450,720 720,1140 1140,1410
address, it doesn't translate,| it's
|就像你不能除零，如果你这样做，处理器会拒绝。

1347
00:41:42,390 --> 00:41:43,050
0,150 150,240 240,360 360,420 420,660
like you know you can't

1348
00:41:43,050 --> 00:41:44,370
0,270 270,360 360,960 990,1110 1110,1320
divide by zero, you know

1349
00:41:44,370 --> 00:41:45,270
0,360 390,480 480,660 660,750 750,900
if you try to do

1350
00:41:45,270 --> 00:41:46,740
0,180 180,270 270,810 810,1290 1290,1470
that the processor refuses to

1351
00:41:46,740 --> 00:41:47,680
0,150 150,390
do it.|
|

1352
00:41:50,110 --> 00:41:51,820
0,210 210,540 570,1140
I see, okay.|
我明白了，好的。|

1353
00:41:54,030 --> 00:41:55,650
0,510 570,780 780,1110 1110,1230 1230,1620
Brandon, what about you Brandon?|
Brandon ，你有什么问题？|

1354
00:41:56,320 --> 00:41:57,820
0,450 630,1110 1110,1260 1260,1320 1320,1500
Yeah, {} so I just
是的，我想确认我理解了，可能已经说过了

1355
00:41:57,820 --> 00:41:58,750
0,420 420,480 480,660 660,870 870,930
wanted to make sure I

1356
00:41:58,750 --> 00:42:00,430
0,720 720,1170 1170,1320 1320,1500 1500,1680
understand how, I think maybe

1357
00:42:00,430 --> 00:42:01,300
0,90 90,240 240,360 360,510 510,870
we come up with it,|
|

1358
00:42:01,660 --> 00:42:03,190
0,210 210,270 270,480 480,810 810,1530
but I want to understand
但是我想知道中间页表，我们如何计算它们的物理地址，

1359
00:42:03,190 --> 00:42:05,320
0,330 330,900 1200,1350 1350,1410 1410,2130
how the kind of intermediate

1360
00:42:05,320 --> 00:42:07,390
0,330 330,1440 1470,1830 1830,1980 1980,2070
page tables, well how we

1361
00:42:07,390 --> 00:42:08,500
0,360 360,420 420,720 720,990 990,1110
calculate the physical address of

1362
00:42:08,500 --> 00:42:09,540
0,660
those,|
|

1363
00:42:09,540 --> 00:42:11,280
0,540 570,870 870,1080 1080,1230 1230,1740
{} so, is it correct
所以，这是否正确，如果我们想找到第二级页表物理地址，

1364
00:42:11,280 --> 00:42:12,390
0,360 360,570 570,690 690,750 750,1110
that say if we were

1365
00:42:12,420 --> 00:42:13,590
0,270 270,360 360,570 570,630 630,1170
trying to find a second

1366
00:42:13,590 --> 00:42:15,420
0,240 240,480 480,960 960,1320 1320,1830
level page tables physical address,|
|

1367
00:42:15,420 --> 00:42:17,010
0,90 90,240 240,660 690,780 780,1590
we would take the PPN
我们就使用第一级页表的 PPN ，它的 44 位，

1368
00:42:17,310 --> 00:42:18,270
0,210 210,300 300,540 540,720 720,960
from the first level page

1369
00:42:18,270 --> 00:42:20,040
0,540 570,810 810,1050 1050,1290 1290,1770
table, that's {44 -} bits|
|

1370
00:42:20,070 --> 00:42:20,880
0,210 210,300 300,450 450,720 720,810
and then we add the
然后加上最初的虚拟地址的 12 位，得到完整的 56 位，就是这个问题。

1371
00:42:20,880 --> 00:42:22,440
0,330 330,540 540,1200 1260,1500 1500,1560
twelve bit offset from the

1372
00:42:22,440 --> 00:42:23,610
0,240 240,570 570,870 870,990 990,1170
original virtual address to get

1373
00:42:23,610 --> 00:42:25,710
0,120 120,330 330,870 870,1140 1380,2100
the full 56 bits, {this,question,is}.|
|

1374
00:42:26,010 --> 00:42:27,450
0,450 450,750 750,930 930,1020 1020,1440
We don't add the offset
我们不用加上偏移量，我们只是使用十二个 0 位，

1375
00:42:27,450 --> 00:42:28,500
0,180 180,270 270,540 540,930 930,1050
from the virtual address, we

1376
00:42:28,500 --> 00:42:29,970
0,210 210,420 420,720 720,1020 1020,1470
just take twelve zero bits,|
|

1377
00:42:30,980 --> 00:42:31,970
0,150 150,270 270,450 450,510 510,990
so we take the PPN,
我们使用 PPN ，它是 44 位。

1378
00:42:31,970 --> 00:42:33,980
0,120 120,360 360,540 540,990 1140,2010
that's {44 -} bits.| Okay.|
|好的。|

1379
00:42:34,010 --> 00:42:35,540
0,840 870,1170 1170,1380 1380,1470 1470,1530
Twelve zero bits at the
后面跟上 12 个 0 位，就得到了 56 位物理地址，就是下一个页面目录，

1380
00:42:35,540 --> 00:42:36,560
0,480 510,600 600,720 720,900 900,1020
bottom and that gives us

1381
00:42:36,560 --> 00:42:38,330
0,90 90,660 660,870 870,1200 1200,1770
{} 56 bit physical address

1382
00:42:38,630 --> 00:42:39,470
0,150 150,330 330,480 480,570 570,840
and that's where the next

1383
00:42:39,470 --> 00:42:41,090
0,210 210,810 810,960 960,1080 1080,1620
page directories,| and this requires
|这需要每个页面目录是对齐的。

1384
00:42:41,090 --> 00:42:42,440
0,120 120,420 420,690 690,930 930,1350
that basically every page directories

1385
00:42:42,440 --> 00:42:43,860
0,210 210,660
page aligned.|
|

1386
00:42:44,500 --> 00:42:45,500
0,390

1387
00:42:45,500 --> 00:42:47,000
0,330 330,780 810,1170 1200,1350 1350,1500
I see, OK, that makes
我明白了，好的，有道理。

1388
00:42:47,000 --> 00:42:47,820
0,300
sense.|
|

1389
00:42:49,880 --> 00:42:50,540
0,120 120,270 270,330 330,450 450,660
So these are all great
这些都是好问题，这些东西是你们在页表实验中会遇到的，

1390
00:42:50,540 --> 00:42:51,380
0,330 330,420 420,630 630,720 720,840
questions and these are all

1391
00:42:51,380 --> 00:42:52,310
0,180 180,270 270,420 420,510 510,930
things you're gonna be struggling

1392
00:42:52,310 --> 00:42:53,300
0,240 240,300 300,510 510,750 750,990
within the page table lab,|
|

1393
00:42:53,300 --> 00:42:54,950
0,390 720,1140 1140,1440 1440,1560 1560,1650
so it's very good to
所以，现在问出来很好。

1394
00:42:54,950 --> 00:42:56,420
0,180 180,300 300,510 510,840
ask them right now.|
|

1395
00:42:56,700 --> 00:42:57,860
0,630

1396
00:43:00,000 --> 00:43:01,950
0,540 570,1110 1140,1320 1320,1440 1440,1950
Okay, {} let me see.|
好的，让我看一下。|

1397
00:43:01,950 --> 00:43:03,520
0,0

1398
00:43:04,410 --> 00:43:07,470
0,450 570,1530 1530,2160 2190,2400 2400,3060
Yes, {} okay, let me
好的，让我稍等一下，[整理]一下思绪，看看我在哪里。

1399
00:43:07,500 --> 00:43:08,820
0,420 420,570 570,720 720,780 780,1320
hold on for a second,

1400
00:43:09,620 --> 00:43:11,520
0,300 300,600 600,780 780,1410
I [] my thoughts,

1401
00:43:12,670 --> 00:43:14,580
0,300 300,660 660,930 930,1350
see where I am.|
|

1402
00:43:16,300 --> 00:43:18,370
0,270 270,480 480,960 1140,1560 1560,2070
Good good, good, okay, one,
好的，还有一件事情我想讲一下，因为你们会看到，

1403
00:43:18,400 --> 00:43:20,110
0,450 450,630 630,780 780,1500 1590,1710
{} sort of, {} you

1404
00:43:20,110 --> 00:43:21,550
0,270 300,660 660,1080 1080,1320 1320,1440
know one other thing that

1405
00:43:21,550 --> 00:43:23,200
0,60 60,210 210,270 270,840 1110,1650
I want to mention, because

1406
00:43:23,200 --> 00:43:25,150
0,120 120,330 330,570 570,960 1410,1950
you will see that {},|
|

1407
00:43:25,300 --> 00:43:26,650
0,210 210,360 360,450 450,1050 1080,1350
is that if we think
就是，我们考虑刚才我展示的这种方案，

1408
00:43:26,650 --> 00:43:27,790
0,210 210,660 750,900 900,1020 1020,1140
about this, you know the

1409
00:43:27,790 --> 00:43:28,960
0,270 270,360 360,480 480,660 660,1170
scheme that I just showed

1410
00:43:29,110 --> 00:43:30,490
0,360 360,660 660,900 900,1170 1170,1380
right,| {} what really seems
|看上去是我们或者处理器从内存加载值，保存值到内存，

1411
00:43:30,490 --> 00:43:31,300
0,60 60,180 180,420 420,690 690,810
to be going on is

1412
00:43:31,300 --> 00:43:33,160
0,180 180,450 450,1050 1050,1350 1350,1860
that we load or store

1413
00:43:33,160 --> 00:43:34,750
0,360 360,480 480,1080 1320,1530 1530,1590
value to memory or the

1414
00:43:34,750 --> 00:43:35,950
0,540 570,870 870,900 900,1140 1140,1200
processor loads or stores of

1415
00:43:35,950 --> 00:43:37,330
0,240 240,330 330,810 840,1050 1050,1380
value to memory,| we basically
|我们必须三次访问内存，

1416
00:43:37,330 --> 00:43:38,320
0,90 90,180 180,330 330,600 600,990
have to do three memory

1417
00:43:38,320 --> 00:43:40,030
0,570 600,960 990,1290 1290,1410 1410,1710
lookups right,| one in the
|一次是顶级页面目录，一次是中级页面目录，还有一次是底部页面目录。

1418
00:43:40,120 --> 00:43:41,230
0,360 360,450 450,540 540,720 720,1110
top of the page directory,

1419
00:43:41,230 --> 00:43:43,150
0,210 210,900 900,1170 1170,1740 1770,1920
one intermediate page directory and

1420
00:43:43,150 --> 00:43:44,170
0,90 90,330 330,450 450,660 660,1020
then one in the bottom

1421
00:43:44,170 --> 00:43:45,380
0,210 210,420 420,870
level page directory.|
|

1422
00:43:45,500 --> 00:43:46,760
0,180 180,390 390,660 660,960 1170,1260
It looks like that you
看起来对虚拟地址的内存引用都需要三次内存访问，这是很昂贵的。

1423
00:43:46,760 --> 00:43:48,230
0,120 120,390 390,720 720,1290 1320,1470
know any memory reference to

1424
00:43:48,230 --> 00:43:50,510
0,330 330,780 780,1170 1170,1680 1680,2280
virtual address basically requires three

1425
00:43:50,510 --> 00:43:52,180
0,600 600,1170
memory reach,

1426
00:43:52,400 --> 00:43:53,780
0,360 360,450 450,630 630,810 810,1380
and so that seems expensive.|
|

1427
00:43:54,540 --> 00:43:56,610
0,390 390,600 600,1020 1170,1650 1650,2070
{} And so, {} what
所以，实际中做的，几乎所有处理器所做的，

1428
00:43:56,610 --> 00:43:58,200
0,480 480,690 690,1170 1170,1350 1350,1590
happens in practice where almost

1429
00:43:58,200 --> 00:43:59,640
0,330 330,600 600,900 900,1140 1140,1440
all every processor does is,|
|

1430
00:43:59,700 --> 00:44:00,960
0,180 180,390 390,450 450,960 960,1260
it has a cache sitting
它在旁边有一个缓存，包含着最近使用的转换，

1431
00:44:00,960 --> 00:44:02,520
0,120 120,180 180,630 660,810 810,1560
on the side, that contains

1432
00:44:02,550 --> 00:44:04,700
0,540 540,810 810,1740
recently used translations,|
|

1433
00:44:05,300 --> 00:44:06,980
0,150 150,270 270,390 390,750 750,1680
and this is called translation
这称为转换后备缓冲器，你会经常看到这个术语 TLB 。

1434
00:44:07,710 --> 00:44:09,220
0,930
look-aside

1435
00:44:10,260 --> 00:44:11,480
0,780
buffer,

1436
00:44:11,790 --> 00:44:13,380
0,270 270,480 480,690 690,870 870,1590
and you'll see that term

1437
00:44:14,390 --> 00:44:16,340
0,330 330,930 930,1380
quite often, the

1438
00:44:16,370 --> 00:44:17,980
0,300 300,570 570,960
{TLB - -}.|
|

1439
00:44:18,370 --> 00:44:19,900
0,780 780,870 870,1140 1140,1440 1440,1530
Basically it's nothing else than
它只是保存了页表条目或 PTE 条目的缓存。

1440
00:44:19,900 --> 00:44:21,180
0,60 60,420 420,750
the cache of

1441
00:44:22,500 --> 00:44:25,050
0,810 810,1050 1050,1500 1530,2010 2010,2550
page table entries, PTE entries.|
|

1442
00:44:28,180 --> 00:44:29,530
0,150 150,300 300,390 390,750 750,1350
So when the processor has
所以当处理器第一次访问查找虚拟地址，

1443
00:44:29,560 --> 00:44:30,340
0,90 90,300 300,450 450,660 660,780
you know the first time

1444
00:44:30,340 --> 00:44:31,390
0,60 60,390 390,690 690,780 780,1050
the processor routes and {look,up}

1445
00:44:31,390 --> 00:44:32,710
0,330 330,720 720,810 810,990 990,1320
virtual address,| you know walks
|硬件遍历这个页面，这三级页表，

1446
00:44:32,710 --> 00:44:35,140
0,300 300,1200 1230,1710 1710,2040 2040,2430
this {} hardware, walks this

1447
00:44:35,380 --> 00:44:37,360
0,1200 1200,1470 1470,1590 1590,1740 1740,1980
page {} the three level

1448
00:44:37,360 --> 00:44:38,950
0,270 270,870 1050,1260 1260,1410 1410,1590
page tables,| that will come
|最后找到那个虚拟地址的最终物理地址，

1449
00:44:38,950 --> 00:44:40,090
0,270 270,570 570,660 660,840 840,1140
out with you know the

1450
00:44:40,090 --> 00:44:42,490
0,390 390,1050 1080,1860 1920,2250 2250,2400
final physical page finally of

1451
00:44:42,490 --> 00:44:43,570
0,270 270,510 510,660 660,780 780,1080
{PPN -} for that particular

1452
00:44:43,570 --> 00:44:45,370
0,300 300,750 930,1140 1140,1260 1260,1800
virtual address,| and then basically
|然后， TLB 保存 [VA, PA] 映射，

1453
00:44:45,370 --> 00:44:47,140
0,180 420,690 690,780 780,1320 1320,1770
the {} the TLB stores

1454
00:44:47,140 --> 00:44:49,580
0,270 270,960 990,1230 1230,2040
that VA PA PN,

1455
00:44:49,980 --> 00:44:53,100
0,570 900,1530 1560,2130 2370,2820 2820,3120
{} PA mapping {} on

1456
00:44:53,100 --> 00:44:54,600
0,90 90,510 840,1080 1080,1200 1200,1500
the side| and so then
|让你下次访问这个虚拟地址，可以直接查询 TLB ,

1457
00:44:54,600 --> 00:44:55,650
0,60 60,300 300,600 600,780 780,1050
the next time you refer

1458
00:44:55,650 --> 00:44:57,300
0,90 90,240 240,840 840,1170 1170,1650
to that particular virtual address,

1459
00:44:57,450 --> 00:44:58,500
0,360 360,510 510,750 750,930 930,1050
{} can just look up

1460
00:44:58,500 --> 00:45:00,090
0,300 300,480 480,630 630,900 930,1590
straight up in the TLB|
|

1461
00:45:00,090 --> 00:45:01,560
0,360 360,420 420,870 870,990 990,1470
and the TLB will respond
TLB 会直接返回而不用遍历页表。

1462
00:45:01,560 --> 00:45:02,580
0,390 390,450 450,720 720,930 930,1020
instead of having to the

1463
00:45:02,580 --> 00:45:03,760
0,210 210,480 480,840
page table walk.|
|

1464
00:45:05,240 --> 00:45:07,660
0,570 990,1410 1410,1530 1530,1890
{} Yep, {Amiar -}.|
是的， Amiar 。|

1465
00:45:09,710 --> 00:45:12,200
0,870 1080,1350 1350,1500 1500,1740 1740,2490
So the {TLB - -}
所以 TLB 把虚拟地址映射到页面的物理地址，

1466
00:45:12,230 --> 00:45:15,200
0,900 1110,1920 1920,2490 2490,2670 2670,2970
map virtual addresses to the

1467
00:45:15,230 --> 00:45:16,970
0,450 450,780 780,930 930,1020 1020,1740
physical address of the page,|
|

1468
00:45:17,150 --> 00:45:19,160
0,210 210,330 330,810 810,1440 1470,2010
that the virtual address along
除了虚拟地址的偏移量，

1469
00:45:19,160 --> 00:45:21,080
0,180 180,420 420,1110 1320,1530 1530,1920
with the offset, {} absolutely

1470
00:45:21,080 --> 00:45:23,780
0,360 1410,1800 1800,1980 1980,2130 2130,2700
right,| wouldn't it be more
|那么缓存页表级别是不是更有效呢。

1471
00:45:23,780 --> 00:45:25,340
0,510 510,660 660,960 960,1380 1380,1560
efficient to like cache at

1472
00:45:25,340 --> 00:45:27,160
0,180 180,510 510,900 900,1380
the page table level.|
|

1473
00:45:27,780 --> 00:45:29,790
0,330 330,690 720,1020 1020,1560 1710,2010
{} Okay, so I let
好的，让我来退一步，

1474
00:45:29,790 --> 00:45:30,930
0,480 480,690 690,750 750,900 900,1140
me take a step back

1475
00:45:30,930 --> 00:45:32,670
0,330 480,1140 1230,1440 1440,1470 1470,1740
here,| {} there are many
|实现 TLB 有很多方式，

1476
00:45:32,670 --> 00:45:34,050
0,300 300,360 360,750 750,840 840,1380
ways of implementing the TLB,|
|

1477
00:45:34,560 --> 00:45:35,790
0,300 300,510 510,750 750,1080 1080,1230
{} the most important thing
最重要的事情是你知道有 TLB ，

1478
00:45:35,790 --> 00:45:36,450
0,150 150,240 240,360 360,420 420,660
that you need to know

1479
00:45:36,450 --> 00:45:37,020
0,150 150,270 270,390 390,540 540,570
is that there is a

1480
00:45:37,020 --> 00:45:37,960
0,480
TLB,|
|

1481
00:45:38,230 --> 00:45:40,300
0,510 510,990 990,1200 1200,1680 1680,2070
{} and the exact details
而 TLB 实现的准确细节，

1482
00:45:40,300 --> 00:45:41,410
0,120 120,390 390,510 510,600 600,1110
of actually how the TLB

1483
00:45:41,410 --> 00:45:42,400
0,90 90,510 510,600 600,780 780,990
has implemented,| this sort of
|我们不会在这个话题上讨论很多细节。

1484
00:45:42,430 --> 00:45:44,020
0,150 150,570 720,840 840,1350 1350,1590
you know {not,the} topic, we're

1485
00:45:44,020 --> 00:45:45,250
0,270 270,570 570,870 870,1050 1050,1230
gonna talk about in great

1486
00:45:45,250 --> 00:45:46,420
0,180 180,240 240,660
amount of detail,

1487
00:45:46,420 --> 00:45:47,650
0,150 150,450 480,810 810,900 900,1230
{} that's not at all.|
|

1488
00:45:47,920 --> 00:45:49,270
0,720 720,1020 1020,1140 1140,1290 1290,1350
{} And so this is
所以这是处理器旁边的一个东西，

1489
00:45:49,270 --> 00:45:50,740
0,270 270,510 510,810 810,1080 1080,1470
really something that sits {in,side}

1490
00:45:50,740 --> 00:45:51,580
0,60 60,150 150,600 600,720 720,840
of the processor| and is
|大多数对操作系统是隐藏的，操作系统并不知道 TLB 如何操作，

1491
00:45:51,580 --> 00:45:52,810
0,390 390,690 690,810 810,930 930,1230
mostly hidden from the operating

1492
00:45:52,810 --> 00:45:53,980
0,300 300,420 420,690 690,930 930,1170
system, the operating system doesn't

1493
00:45:53,980 --> 00:45:54,970
0,180 180,480 480,630 630,750 750,990
really know how the {TLB

1494
00:45:54,970 --> 00:45:56,120
0,120 120,720
-} operates,|
|

1495
00:45:56,270 --> 00:45:57,710
0,450 750,900 900,1200 1200,1350 1350,1440
{} the only thing, the
你只需要知道 TLB 存在的原因是，

1496
00:45:57,710 --> 00:45:58,580
0,240 240,330 330,480 480,540 540,870
reason you need to know

1497
00:45:58,580 --> 00:45:59,840
0,150 150,240 240,450 450,600 600,1260
that the {TLB -} exist,|
|

1498
00:46:00,050 --> 00:46:01,490
0,210 210,540 540,660 660,780 780,1440
is that if you switch
如果你切换页表，那么操作系统要告诉处理器它在切换页表，

1499
00:46:01,550 --> 00:46:02,920
0,270 270,900
page tables,

1500
00:46:03,700 --> 00:46:06,190
0,840 1140,1560 1560,1680 1680,2100 2100,2490
then, typically the operating system

1501
00:46:06,190 --> 00:46:08,290
0,300 300,450 450,1110 1350,1680 1680,2100
needs to tell the processor

1502
00:46:08,290 --> 00:46:09,940
0,180 180,330 330,690 690,960 960,1650
that it's switching page tables,|
|

1503
00:46:10,740 --> 00:46:12,720
0,630 840,1380
and the
然后 TLB 需要刷新。

1504
00:46:12,950 --> 00:46:13,850
0,270 270,480 480,690 690,750 750,900
{TLB -} needs to be

1505
00:46:13,850 --> 00:46:15,000
0,600
flushed.|
|

1506
00:46:16,790 --> 00:46:18,050
0,270 270,660 660,750 750,1110 1110,1260
Because basically you send {}
因为你会发送旧的条目，

1507
00:46:18,050 --> 00:46:19,190
0,330 330,780 780,900 900,1050 1050,1140
stale entries,| {} if you
|如果你切换到新的页表， TLB 中的条目就可能不是有效的，

1508
00:46:19,190 --> 00:46:20,120
0,330 330,420 420,480 480,660 660,930
switch to a new page

1509
00:46:20,120 --> 00:46:21,830
0,540 780,1020 1020,1530 1530,1650 1650,1710
table, the entries in the

1510
00:46:21,830 --> 00:46:23,000
0,390 390,540 540,750 750,840 840,1170
TLB may not be valid

1511
00:46:23,000 --> 00:46:24,440
0,570 780,990 990,1110 1110,1260 1260,1440
anymore| and so they need
|所以要删除它们，否则转换可能会出现错误。

1512
00:46:24,440 --> 00:46:26,390
0,60 60,210 210,840 870,1380 1380,1950
to be removed, because otherwise

1513
00:46:26,390 --> 00:46:27,380
0,60 60,210 210,330 330,870 870,990
you know the translation would

1514
00:46:27,380 --> 00:46:28,540
0,180 180,720
be incorrect.|
|

1515
00:46:28,830 --> 00:46:30,360
0,240 240,450 450,810 810,1200 1200,1530
And so the operating system
所以操作系统知道这里有一个 TLB ，

1516
00:46:30,360 --> 00:46:32,730
0,180 180,630 630,1530 1890,2040 2040,2370
is typically aware is aware

1517
00:46:32,730 --> 00:46:33,630
0,120 120,480 480,510 510,630 630,900
that there's a {}, that

1518
00:46:33,630 --> 00:46:34,950
0,150 150,540 570,1050 1050,1260 1260,1320
there is a {TLB -

1519
00:46:34,950 --> 00:46:36,900
0,390 420,1170 1200,1680 1680,1890 1890,1950
-},| only basically tell the
|只是偶尔告诉硬件，我不再使用它们了，因为我要切换页表。

1520
00:46:36,900 --> 00:46:37,650
0,300 300,480 480,540 540,570 570,750
hardware, once in a while,

1521
00:46:37,650 --> 00:46:38,880
0,360 360,630 630,780 780,1080 1080,1230
saying okay we'll don't use

1522
00:46:38,880 --> 00:46:40,590
0,120 120,720 750,1410 1410,1560 1560,1710
them anymore, because I'm gonna

1523
00:46:40,590 --> 00:46:42,040
0,240 240,510 510,1080
switch page tables.|
|

1524
00:46:44,150 --> 00:46:45,830
0,390 390,510 510,870 870,1440 1440,1680
And in fact on, {you,know},
实际上，在 RISC-V 中，刷新 TLB 的指令是 sfence_vma ，

1525
00:46:45,830 --> 00:46:48,100
0,660 1050,1680
the {}

1526
00:46:48,880 --> 00:46:49,840
0,210 210,330 330,540 540,900 900,960
{} the {RISC-V -} the

1527
00:46:49,840 --> 00:46:51,370
0,510 510,630 630,900 900,960 960,1530
instruction to flush the TLB

1528
00:46:51,370 --> 00:46:53,420
0,120 120,570 570,780 780,1470
is called {sfence_vma -

1529
00:46:53,620 --> 00:46:55,560
0,690 690,900 900,1050 1050,1380
- - - -},|
|

1530
00:46:57,230 --> 00:46:59,340
0,690 690,750 750,900 900,1410
{I'm,not} {actually - -},
我不是很确定，

1531
00:46:59,720 --> 00:47:02,460
0,540 540,750 750,1320 1650,2160
flush the TLB.| Bibic.|
刷新 TLB 。|Bibic.|

1532
00:47:03,780 --> 00:47:04,900
0,480

1533
00:47:04,900 --> 00:47:05,980
0,210 210,300 300,420 420,510 510,1080
So I have a question,
我有一个问题，不是关于 TLB ，但是它带来了这个问题，

1534
00:47:05,980 --> 00:47:08,200
0,420 570,1020 1050,1350 1350,1710 1710,2220
{} like not regarding TLB,

1535
00:47:08,200 --> 00:47:10,120
0,330 360,480 480,840 840,1680 1680,1920
but {} that brought kind

1536
00:47:10,120 --> 00:47:12,550
0,630 660,870 870,1290 1350,2160 2160,2430
of this question,| the three
|我们使用的三级页面，是由操作系统还是硬件实现的。

1537
00:47:12,550 --> 00:47:15,190
0,750 780,1770 1770,2190 2220,2400 2400,2640
level support, that the three

1538
00:47:15,190 --> 00:47:16,900
0,480 480,870 900,1380 1380,1590 1590,1710
level {} paging, that we

1539
00:47:16,900 --> 00:47:19,120
0,480 930,1140 1140,1380 1410,2070 2070,2220
have, is it implemented by

1540
00:47:19,120 --> 00:47:20,440
0,150 150,600 600,1080 1080,1230 1230,1320
the operating system or the

1541
00:47:20,440 --> 00:47:22,210
0,360 360,930 1200,1290 1290,1680 1680,1770
hardware itself.| Is implemented in
|是由硬件实现的，所有这些都在硬件发生的，

1542
00:47:22,210 --> 00:47:23,200
0,570
hardware,

1543
00:47:23,450 --> 00:47:24,530
0,330 330,510 510,630 630,870 870,1080
so you know there's all

1544
00:47:24,530 --> 00:47:26,600
0,300 300,390 390,870 1140,1440 1440,2070
happens in hardware,| the MMU
|MMU 是硬件的一部分，而不是在操作系统中。

1545
00:47:26,600 --> 00:47:28,250
0,180 180,300 300,870 900,1050 1050,1650
is a block of hardware,

1546
00:47:28,800 --> 00:47:30,120
0,480 480,570 570,660 660,960 960,1320
not in the operating system,|
|

1547
00:47:30,180 --> 00:47:31,560
0,270 270,720 720,840 840,900 900,1380
we'll see in a second
我们过一会会看到，当我们查看 xv6 时，

1548
00:47:31,650 --> 00:47:32,700
0,390 390,450 450,600 600,720 720,1050
when we look at {xv6

1549
00:47:32,700 --> 00:47:34,590
0,450 690,1200 1200,1500 1500,1770 1770,1890
-},| {xv6 -} has some
|xv6 有一个函数模拟页表遍历，

1550
00:47:34,590 --> 00:47:36,540
0,690 780,1020 1020,1590 1590,1710 1710,1950
function that models the page

1551
00:47:36,540 --> 00:47:37,650
0,270 270,600 600,810 810,1050 1050,1110
table walk,| because once in
|因为有时， xv6 必须做一些硬件做的事情，

1552
00:47:37,650 --> 00:47:39,030
0,60 60,570 570,660 660,1020 1020,1380
a while you know {xv6

1553
00:47:39,030 --> 00:47:40,140
0,210 210,540 540,840 840,930 930,1110
-} basically has to do

1554
00:47:40,140 --> 00:47:41,220
0,210 210,300 300,510 510,630 630,1080
what the {hareware -} does,|
|

1555
00:47:42,040 --> 00:47:43,570
0,570 570,870 870,990 990,1260 1260,1530
{} and so it also
它有一个名叫 walk 的函数，做的事情相同，不过是在软件中。

1556
00:47:43,570 --> 00:47:44,380
0,90 90,300 300,450 450,510 510,810
it does have a function

1557
00:47:44,380 --> 00:47:45,970
0,180 180,720 750,1080 1080,1410 1410,1590
called walk, that basically does

1558
00:47:45,970 --> 00:47:48,130
0,450 450,540 540,810 810,1290 1500,2160
exactly the same thing, but

1559
00:47:48,130 --> 00:47:49,220
0,60 60,540
in software.|
|

1560
00:47:51,370 --> 00:47:52,780
0,690 930,1170 1170,1230 1230,1380 1380,1410
So, can I ask a
我能问个问题吗，

1561
00:47:52,780 --> 00:47:56,480
0,600 1740,2310 2310,3150
question,| so {}
|所以，在这个方案中，处理器内存在哪里，

1562
00:47:56,600 --> 00:47:58,550
0,780 780,990 990,1230 1230,1710 1710,1950
where in this scheme does

1563
00:47:58,550 --> 00:48:00,380
0,120 120,690 690,1200 1200,1620 1620,1830
the processor cache [fit],| does
|是在地址转换之前还是之后。

1564
00:48:00,380 --> 00:48:02,510
0,120 120,540 540,1110 1110,1560 1650,2130
it happen before the address

1565
00:48:02,510 --> 00:48:05,930
0,690 690,900 900,1560 2010,2700 3030,3420
translation or after.| Yeah, yeah
|是的，让我往回切换一下，让我看看。

1566
00:48:05,930 --> 00:48:06,710
0,180 180,330 330,480 480,660 660,780
okay, let me, {} so

1567
00:48:06,710 --> 00:48:07,610
0,150 150,450 450,690 690,720 720,900
let's switch back a little

1568
00:48:07,610 --> 00:48:09,860
0,240 270,510 510,1140 1230,1950 1950,2250
bit a couple, {} let

1569
00:48:09,860 --> 00:48:11,040
0,180 180,720
me see.|
|

1570
00:48:13,120 --> 00:48:14,440
0,300 300,660 660,780 780,900 900,1320
Okay, usually {MMU - -}
好的， MMU ，你可以这样认为，

1571
00:48:14,500 --> 00:48:16,570
0,480 480,750 750,840 840,990 990,2070
will really the way to

1572
00:48:16,570 --> 00:48:17,800
0,180 180,600 600,840 840,1020 1020,1230
think about is,| that all
|所有这些东西，这一块都在处理器中。

1573
00:48:17,800 --> 00:48:19,040
0,210 210,750
this stuff

1574
00:48:19,860 --> 00:48:20,940
0,90 90,180 180,300 300,510 510,1080
you know the whole block

1575
00:48:21,030 --> 00:48:22,650
0,210 210,600 600,660 660,1080 1080,1620
is inside the processor silicon.|
|

1576
00:48:24,350 --> 00:48:25,310
0,210 210,420 420,480 480,690 690,960
So there's a {RISC-V -}
所以，这是 RISC-V 芯片，在它里面是 CPU ，

1577
00:48:25,310 --> 00:48:27,080
0,450 900,1140 1140,1530 1530,1620 1620,1770
chip and inside of it

1578
00:48:27,080 --> 00:48:28,400
0,120 120,210 210,840 840,1080 1080,1320
is the CPU,| in fact
|实际上，这里有多个核心，四核，这是 MMU ，

1579
00:48:28,400 --> 00:48:29,630
0,90 90,120 120,510 510,870 870,1230
there are multiple CPU, correct,

1580
00:48:29,630 --> 00:48:31,220
0,270 270,780 1110,1410 1410,1560 1560,1590
four cores and there's a

1581
00:48:31,220 --> 00:48:32,990
0,180 180,330 330,810 1020,1710 1710,1770
{MMU - -}| and you
|你可以这样考虑，在 CPU 这一侧，有一个 TLB 。

1582
00:48:32,990 --> 00:48:33,740
0,120 120,270 270,360 360,510 510,750
know you can think about

1583
00:48:33,740 --> 00:48:35,090
0,270 270,570 570,870 870,1200 1200,1350
that, either on this on

1584
00:48:35,090 --> 00:48:36,200
0,60 60,450 450,900 900,990 990,1110
the CPU side, you know

1585
00:48:36,200 --> 00:48:38,040
0,270 270,720 750,1020 1020,1380
there's a {TLB -}.|
|

1586
00:48:41,330 --> 00:48:42,400
0,630
Okay?|
好的？|

1587
00:48:44,450 --> 00:48:46,430
0,180 180,360 360,720 750,1410 1590,1980
That makes sense, {} but
有道理，但是我想我的问题是，

1588
00:48:46,430 --> 00:48:47,330
0,120 120,300 300,420 420,750 750,900
I guess my question was

1589
00:48:47,330 --> 00:48:50,360
0,330 330,510 510,960 1350,2040 2370,3030
about the like,| {} cache
|缓存，不是说 TLB ，只是说普通的缓存，

1590
00:48:50,390 --> 00:48:51,680
0,180 180,510 510,870 900,1170 1170,1290
in terms of not the

1591
00:48:51,680 --> 00:48:53,510
0,450 450,600 600,900 900,1230 1260,1830
TLB, but just a normal

1592
00:48:53,510 --> 00:48:55,400
0,450 450,750 750,1110 1140,1500 1500,1890
cache,| like, {} because sometimes
|比如有时候，我们不是都访问内存。

1593
00:48:55,400 --> 00:48:56,300
0,90 90,210 210,570 570,720 720,900
we don't actually go all

1594
00:48:56,300 --> 00:48:57,230
0,60 60,210 210,420 420,840 840,930
the way to access the

1595
00:48:57,230 --> 00:48:59,240
0,510 780,1170 1170,1590 1590,1920 1920,2010
memory.| Yeah good point, I
|是的，好想法，我想我在上周一展示了这种方案，

1596
00:48:59,240 --> 00:48:59,960
0,150 150,240 240,480 480,630 630,720
think I showed like the

1597
00:48:59,960 --> 00:49:01,760
0,300 300,720 720,900 900,1350 1350,1800
scheme last [week] correct on

1598
00:49:01,760 --> 00:49:03,170
0,300 300,420 420,510 510,840 840,1410
Monday| of the RISC-V processor
|RISC-V 处理器有 l1 缓存， l2 缓存，

1599
00:49:03,170 --> 00:49:04,310
0,90 90,330 330,540 540,810 810,1140
and has {l1 -} cache,

1600
00:49:04,310 --> 00:49:05,540
0,90 90,270 270,450 450,660 660,1230
it has {l2 -} cache,|
|

1601
00:49:05,910 --> 00:49:07,710
0,780 780,1170 1170,1290 1290,1650 1650,1800
some caches are indexed by
其中一些缓存由物理地址索引，一些缓存由虚拟地址索引，

1602
00:49:07,710 --> 00:49:09,140
0,390 390,930
physical address,

1603
00:49:09,170 --> 00:49:10,520
0,270 270,660 660,750 750,1170 1170,1350
some caches are indexed by

1604
00:49:10,520 --> 00:49:11,900
0,390 390,900
virtual address,|
|

1605
00:49:11,900 --> 00:49:12,680
0,60 60,150 150,540 540,690 690,780
so the caches that are
所以由虚拟地址索引的缓存在 MMU 之前，

1606
00:49:12,680 --> 00:49:14,120
0,330 330,450 450,810 810,1230 1230,1440
indexed by virtual address sit

1607
00:49:14,120 --> 00:49:16,500
0,780 990,1170 1170,1830
before the MMU,|

1608
00:49:16,560 --> 00:49:17,790
0,270 270,630 630,780 780,1050 1050,1230
and cache their index by
而由物理地址索引的缓存在 MMU 之后。

1609
00:49:17,790 --> 00:49:19,620
0,390 390,810 810,1200 1200,1320 1320,1830
physical addresses after the MMU.|
|

1610
00:49:25,020 --> 00:49:26,400
0,150 150,570 780,990 990,1110 1110,1380
{Does,that} {make,sence}?| Can I also
这个能理解吗？|我也有一个问题，我的问题是，

1611
00:49:26,400 --> 00:49:28,500
0,180 180,240 240,840 1020,1590 1620,2100
ask a question, my question

1612
00:49:28,500 --> 00:49:30,330
0,330 360,540 540,840 840,1200 1320,1830
is,| you said that the
|你说了， TLB 遍历，

1613
00:49:30,360 --> 00:49:33,030
0,450 720,1380 1380,1770 1980,2520 2520,2670
{} TLB, it walks,| so
|所以把东西放入 TLB ，硬件可以遍历页表，

1614
00:49:33,030 --> 00:49:34,080
0,30 30,330 330,420 420,810 810,1050
{} like to put stuff

1615
00:49:34,080 --> 00:49:36,450
0,210 210,780 810,1050 1050,1830 1860,2370
into TLB, the hardware walks

1616
00:49:36,450 --> 00:49:39,760
0,360 360,810 840,1260 1260,2040
through the page tables,|
|

1617
00:49:39,850 --> 00:49:41,890
0,360 360,480 480,630 630,1200 1680,2040
why do we write walk
那么，我们为什么要写 walk 函数，如果硬件可以完成。

1618
00:49:41,890 --> 00:49:43,300
0,480 480,660 660,1080 1080,1230 1230,1410
function, if hardware can do

1619
00:49:43,300 --> 00:49:44,380
0,420
that.|
|

1620
00:49:44,580 --> 00:49:47,070
0,480 480,600 600,1050 1200,1740 1800,2490
Very good question, {} one
好问题，有几个原因，为什么我们需要这么做或者为什么 xv6 需要它，

1621
00:49:47,070 --> 00:49:48,750
0,570 570,720 720,1140 1140,1410 1410,1680
reason, {} a couple reasons

1622
00:49:48,750 --> 00:49:49,890
0,270 270,390 390,540 540,780 810,1140
why we do it or

1623
00:49:49,890 --> 00:49:51,750
0,210 210,780 780,1320 1320,1470 1470,1860
why xv6 needs it,| one
|一个是当它设置初始化页面时，

1624
00:49:51,750 --> 00:49:52,650
0,150 150,300 300,420 420,600 600,900
is when it actually sets

1625
00:49:52,650 --> 00:49:54,060
0,90 90,210 210,540 540,780 780,1410
up the initial page tables,|
|

1626
00:49:54,980 --> 00:49:56,240
0,630 630,750 750,810 810,1050 1050,1260
{} you know it needs
它需要对三级页表编程，所以它需要模拟三级页表。

1627
00:49:56,240 --> 00:49:57,770
0,120 120,870 870,1230 1230,1350 1350,1530
to program the the three

1628
00:49:57,770 --> 00:49:59,420
0,660 900,1110 1110,1320 1320,1410 1410,1650
levels and so it needs

1629
00:49:59,420 --> 00:50:00,740
0,120 120,540 540,1050 1050,1140 1140,1320
to basically emulate the three

1630
00:50:00,740 --> 00:50:01,760
0,570
levels.|
|

1631
00:50:02,120 --> 00:50:05,090
0,780 1170,1410 1410,1830 1860,2310 2310,2970
{} And {} other example,
另一个例子，你在 syscall 实验中遇到或正在遇到的，

1632
00:50:05,090 --> 00:50:06,530
0,210 210,390 390,930 930,1320 1320,1440
that you actually sort of

1633
00:50:06,530 --> 00:50:08,060
0,210 210,780 780,1050 1050,1290 1290,1530
run into or are running

1634
00:50:08,060 --> 00:50:09,620
0,390 390,570 570,660 660,1050 1050,1560
into in the syscall lab,|
|

1635
00:50:09,800 --> 00:50:11,270
0,390 390,570 570,750 750,870 870,1470
is that when you copy,|
是当你复制，|

1636
00:50:11,420 --> 00:50:13,070
0,270 270,870 870,1170 1170,1260 1260,1650
the {in,xv6 -} the kernel
在 xv6 中，内核有自己的页表，每个用户地址空间有自己的页表，

1637
00:50:13,070 --> 00:50:14,330
0,180 180,300 300,450 450,720 720,1260
has its own page table

1638
00:50:14,540 --> 00:50:16,370
0,330 330,570 570,960 960,1560 1560,1830
and every user address space

1639
00:50:16,370 --> 00:50:17,480
0,180 180,300 300,450 450,720 720,1110
has its own page table,|
|

1640
00:50:18,140 --> 00:50:19,070
0,390 390,570 570,810 810,870 870,930
and with once in a
有时，比如 sysinfo ， sysinfo 结构体存在于用户空间中，

1641
00:50:19,070 --> 00:50:21,230
0,510 510,1080 1110,1470 1470,1620 1620,2160
while, for example {sysinfo -}

1642
00:50:21,230 --> 00:50:22,310
0,120 120,390 390,750 750,840 840,1080
{you,know} like, {} the point

1643
00:50:22,310 --> 00:50:24,290
0,150 150,450 450,1410 1410,1650 1650,1980
of sysinfo struct that lives

1644
00:50:24,290 --> 00:50:26,270
0,120 120,390 390,960 1170,1680 1680,1980
in user space,| the kernel
|内核需要转换地址让它自己可以读写那个地址。

1645
00:50:26,270 --> 00:50:27,380
0,180 180,240 240,360 360,990 990,1110
needs to be translated to

1646
00:50:27,380 --> 00:50:28,460
0,120 120,510 510,690 690,900 900,1080
an address that it can

1647
00:50:28,460 --> 00:50:30,040
0,240 240,630 630,840 840,1110
use to {read,and,write} it.|
|

1648
00:50:30,340 --> 00:50:31,630
0,600 600,780 780,870 870,1200 1200,1290
And so, for example if
所以，比如，如果你查看 copyin 或 copyout ，

1649
00:50:31,630 --> 00:50:33,520
0,90 90,450 450,1050 1050,1440 1470,1890
you're looking {copyin -} or

1650
00:50:33,520 --> 00:50:36,670
0,420 420,900 1230,2250 2250,2370 2370,3150
{copyout -},| basically the kernel
|内核转换用户虚拟地址，使用用户页表获取物理地址，

1651
00:50:36,790 --> 00:50:39,910
0,1050 1200,1680 1680,2040 2040,2490 2490,3120
translates the user virtual address

1652
00:50:40,000 --> 00:50:42,670
0,690 690,810 810,1410 1410,1920 1950,2670
using the user {} virtual,

1653
00:50:42,670 --> 00:50:44,440
0,390 390,450 450,900 930,1380 1380,1770
using the user page table

1654
00:50:44,440 --> 00:50:45,400
0,120 120,300 300,450 450,540 540,960
to get out of physical

1655
00:50:45,400 --> 00:50:47,770
0,390 390,720 720,1110 1110,1500 1830,2370
address,| that kernel then {}
|然后内核获得一个可以用来读写内存地址。

1656
00:50:48,160 --> 00:50:50,020
0,750 750,870 870,1200 1200,1590 1590,1860
get an address out actually

1657
00:50:50,020 --> 00:50:50,980
0,150 150,240 240,540 540,690 690,960
then the kernel can use

1658
00:50:50,980 --> 00:50:51,640
0,90 90,240 240,360 360,510 510,660
to read and write that

1659
00:50:51,640 --> 00:50:52,400
0,390
memory.|
|

1660
00:50:54,570 --> 00:50:55,140
0,150 150,270 270,300 300,510 510,570
So there's a bunch of
所以，有很多地方可以展示，希望我可以在 10 到 15 分钟内讲到。

1661
00:50:55,140 --> 00:50:56,130
0,270 270,360 360,450 450,750 750,990
places where to show up

1662
00:50:56,280 --> 00:50:57,630
0,210 210,510 510,750 750,960 960,1350
and I'll talk about hopefully

1663
00:50:57,630 --> 00:50:59,310
0,480 480,810 810,990 990,1350 1350,1680
in whatever ten minutes fifteen

1664
00:50:59,310 --> 00:51:00,300
0,420
minutes.|
|

1665
00:51:00,610 --> 00:51:02,080
0,390 390,480 480,540 540,1080 1110,1470
I have a question, why
我有一个问题，为什么硬件不开放那个 walk 函数，

1666
00:51:02,080 --> 00:51:05,350
0,510 510,1080 1560,2370 2370,2520 2520,3270
doesn't the hardware like expose

1667
00:51:05,350 --> 00:51:06,670
0,300 300,660 660,1080 1080,1230 1230,1320
that walk function,| so we
|让我们不需要自己实现，可能还有 bug ，

1668
00:51:06,670 --> 00:51:07,450
0,150 150,300 300,420 420,630 630,780
don't have to write our

1669
00:51:07,450 --> 00:51:08,890
0,240 240,510 510,1020 1020,1170 1170,1440
own and potentially have bugs

1670
00:51:08,890 --> 00:51:10,390
0,60 60,240 540,1080 1080,1320 1320,1500
in it,| why isn't there
|为什么没有比如一个特权指令，你可以传入虚拟地址，返回物理地址。

1671
00:51:10,390 --> 00:51:12,250
0,240 240,690 960,1350 1350,1440 1440,1860
like {you,know} maybe a privileged

1672
00:51:12,250 --> 00:51:13,270
0,480 480,570 570,630 630,720 720,1020
instruction that you can pass

1673
00:51:13,270 --> 00:51:14,290
0,30 30,390 390,780 780,900 900,1020
a virtual address and will

1674
00:51:14,290 --> 00:51:15,970
0,180 180,630 630,780 780,1140 1140,1680
give back the physical address.|
|

1675
00:51:16,380 --> 00:51:17,430
0,300 300,450 450,510 510,840 840,1050
Well, this is just like
好的，这就像存入虚拟地址，然后返回，它会为你做好，

1676
00:51:17,430 --> 00:51:18,450
0,270 270,540 540,690 690,750 750,1020
just store to the virtual

1677
00:51:18,450 --> 00:51:19,050
0,240 240,330 330,390 390,540 540,600
address, and you get the

1678
00:51:19,050 --> 00:51:20,580
0,420 420,1140 1140,1230 1230,1410 1410,1530
back and will do it

1679
00:51:20,580 --> 00:51:22,530
0,240 240,450 450,720 1200,1530 1530,1950
right for you,| {} so
|所以，我们会在后面的页表实验中看到，

1680
00:51:22,590 --> 00:51:24,270
0,150 150,330 330,870 870,1230 1230,1680
{} we'll see later on,

1681
00:51:24,390 --> 00:51:26,760
0,600 600,1140 1200,1740 1770,2070 2070,2370
{} in the next lab,

1682
00:51:26,760 --> 00:51:28,050
0,60 60,270 270,600 600,960 1140,1290
the page table lab,| in
|实际上，这是你们要做的，你么要以稍微不同的方式设置页表，

1683
00:51:28,050 --> 00:51:29,100
0,240 240,390 390,810 810,930 930,1050
fact that's exactly what you'll

1684
00:51:29,100 --> 00:51:30,570
0,120 120,480 480,720 720,1230 1230,1470
be doing, you'll actually set

1685
00:51:30,570 --> 00:51:31,740
0,90 90,180 180,390 390,630 630,1170
up the page table slightly

1686
00:51:31,740 --> 00:51:32,730
0,510 510,630 630,780 780,870 870,990
differently,| so that you can
|让你们可以在 copyin 和 copyinstr 中避免 walk 。

1687
00:51:32,730 --> 00:51:35,280
0,630 630,720 720,1740 1770,2070 2070,2550
avoid the {walk,in} {} copy

1688
00:51:35,280 --> 00:51:36,750
0,270 270,690 690,990 990,1080 1080,1470
in and {copyinstr - -}.|
|

1689
00:51:42,500 --> 00:51:43,370
0,150 150,270 270,360 360,450 450,870
I think this will become
我想这个在我们过一会讨论 xv6 时，会变的更清楚。好吗？

1690
00:51:43,370 --> 00:51:44,180
0,270 270,360 360,390 390,690 690,810
clear in a second that

1691
00:51:44,180 --> 00:51:45,230
0,240 240,510 510,600 600,810 810,1050
we when we talk about

1692
00:51:45,230 --> 00:51:45,890
0,90 90,210 210,300 300,360 360,660
we look at the {xv6

1693
00:51:45,890 --> 00:51:47,240
0,390 420,840
-}. Okay?|
|

1694
00:51:49,700 --> 00:51:51,740
0,330 330,780 810,1470
Okay, good {}.|
好的。|

1695
00:51:51,800 --> 00:51:53,960
0,360 360,600 600,960 990,1800 1800,2160
One more extra, basically before
在进入 xv6 之前，我想再说一点，

1696
00:51:53,960 --> 00:51:55,730
0,300 300,480 480,1170 1170,1530 1530,1770
jumping into xv6, I wanted

1697
00:51:55,730 --> 00:51:58,100
0,180 180,360 360,780 780,1320 1800,2370
to make one point {},|
|

1698
00:51:58,610 --> 00:52:01,010
0,750 750,870 870,990 990,1410 1440,2400
{one,way} to think about {}
考虑页表的一种方式，

1699
00:52:01,040 --> 00:52:02,860
0,150 150,450 750,1320
you know, {}

1700
00:52:03,100 --> 00:52:04,540
0,330 330,900
page tables,|
|

1701
00:52:05,980 --> 00:52:07,420
0,360 360,600 600,720 720,1140 1140,1440
{ -} a popular way
一种流行的说法，页表提供了某种间接性，

1702
00:52:07,420 --> 00:52:10,510
0,150 150,450 450,900 1140,2040 2550,3090
to phrase this, {} page

1703
00:52:10,510 --> 00:52:13,200
0,750 870,2040
tables provide

1704
00:52:13,290 --> 00:52:15,300
0,240 240,540 540,600 600,1230
a level of indirection,|
|

1705
00:52:19,670 --> 00:52:20,920
0,630
and,
这种间接性是我说过的从虚拟地址到物理地址的映射，

1706
00:52:25,100 --> 00:52:26,780
0,180 180,600 660,1230 1380,1560 1560,1680
and that, {} and so

1707
00:52:26,780 --> 00:52:28,130
0,360 360,540 540,1110 1110,1260 1260,1350
basically this indirection, what I'm

1708
00:52:28,130 --> 00:52:29,060
0,270 270,540 540,630 630,750 750,930
talking about, you know this

1709
00:52:29,060 --> 00:52:30,200
0,330 330,480 480,810 810,1050 1050,1140
mapping from virtual address to

1710
00:52:30,200 --> 00:52:32,510
0,300 300,870 1320,1440 1440,1620 1620,2310
physical address,| and this mapping
|这个映射完全在操作系统的控制中，

1711
00:52:32,690 --> 00:52:35,000
0,120 120,750 750,1020 1020,1830
is completely under control

1712
00:52:35,120 --> 00:52:36,800
0,180 180,300 300,630 630,1110
of the operating system,|
|

1713
00:52:38,350 --> 00:52:40,360
0,240 240,450 450,810 840,960 960,2010
as we've seen, you know
像我们看到的，之前几张幻灯片所说的，

1714
00:52:40,360 --> 00:52:41,500
0,360 360,450 450,690 690,990 990,1140
{in,the,last} {} couple slides, we

1715
00:52:41,500 --> 00:52:43,510
0,480 780,1200 1200,1350 1350,1530 1530,2010
talk,| {} and that means
|这意味着操作系统，因为它完全控制（页表）转换，

1716
00:52:43,510 --> 00:52:45,310
0,180 180,270 270,660 660,1350 1410,1800
that the operating system, because

1717
00:52:45,310 --> 00:52:46,270
0,120 120,240 240,330 330,510 510,960
it has so much control

1718
00:52:46,270 --> 00:52:47,950
0,330 330,420 420,600 600,1320 1320,1680
over it, has control, complete

1719
00:52:47,950 --> 00:52:50,170
0,420 420,570 570,1320 1530,2040 2100,2220
control that translation,| {} it
|它可以做各种有意思的技巧。

1720
00:52:50,170 --> 00:52:51,040
0,120 120,330 330,570 570,780 780,870
can do all kinds of

1721
00:52:51,040 --> 00:52:52,320
0,330 330,900
interesting tricks.|
|

1722
00:52:52,630 --> 00:52:54,190
0,660 660,870 870,960 960,1020 1020,1560
{} And so for example
比如，一种技巧是，我会在后面讲到，

1723
00:52:54,190 --> 00:52:55,720
0,180 180,510 510,990 1020,1440 1440,1530
like one trick, {} {you,know,we'll}

1724
00:52:55,780 --> 00:52:56,650
0,240 240,270 270,480 480,630 630,870
talk a little bit about

1725
00:52:56,650 --> 00:52:58,210
0,210 210,360 360,660 660,1350 1350,1560
this,| like if a page
|如果一个页面条目是无效的，硬件会返回页面错误。

1726
00:52:58,210 --> 00:52:59,980
0,330 330,420 420,1140 1380,1620 1620,1770
entry is invalid and will

1727
00:52:59,980 --> 00:53:01,120
0,360 360,750 750,810 810,1080 1080,1140
really return a page, you

1728
00:53:01,120 --> 00:53:02,890
0,180 180,300 300,660 660,1050 1050,1770
know the hardware will a

1729
00:53:03,100 --> 00:53:04,700
0,480 480,750 750,1170
raise page fault.|
|

1730
00:53:04,820 --> 00:53:06,350
0,210 210,690 690,810 810,1080 1080,1530
In response, the page fault,
作为回应页面错误，操作系统可以更新页表，然后重新执行该指令。

1731
00:53:06,530 --> 00:53:08,120
0,270 270,570 570,840 840,990 990,1590
the operating system could update

1732
00:53:08,150 --> 00:53:09,410
0,120 120,360 360,930 960,1110 1110,1260
the page tables and then

1733
00:53:09,410 --> 00:53:11,460
0,360 360,900 900,1500
maybe {restart,the} instruction.|
|

1734
00:53:11,610 --> 00:53:12,450
0,480 480,600 600,720 720,780 780,840
And so there are all
所以通过操纵页表，可以在运行时做很多事情。

1735
00:53:12,450 --> 00:53:13,200
0,180 180,270 270,540 540,630 630,750
kinds of things they can

1736
00:53:13,200 --> 00:53:15,810
0,390 390,1020 1020,1290 1290,1800 2010,2610
do at run time {}

1737
00:53:15,810 --> 00:53:17,970
0,540 570,1170 1170,1800 1800,1890 1890,2160
{} by manipulating the page

1738
00:53:17,970 --> 00:53:19,040
0,660
tables.|
|

1739
00:53:19,160 --> 00:53:20,480
0,450 600,960 960,1140 1140,1260 1260,1320
And we're not going to
我们不会在今天讨论，但是两周后，我们有一节课专门讨论这个主题，

1740
00:53:20,480 --> 00:53:22,070
0,180 180,630 630,840 840,1110 1110,1590
talk about it {} today,

1741
00:53:22,070 --> 00:53:23,660
0,240 240,660 690,840 840,1230 1230,1590
but in two weeks, we'll

1742
00:53:23,660 --> 00:53:25,880
0,150 150,210 210,720 810,1770 1770,2220
have a lecture exactly about

1743
00:53:25,880 --> 00:53:27,380
0,180 180,600 600,930 960,1230 1230,1500
this topic,| about what cool
|关于有了页表和页面错误，你可以做什么很酷的事情。

1744
00:53:27,380 --> 00:53:28,580
0,300 300,450 450,600 600,870 870,1200
things can you do once

1745
00:53:28,580 --> 00:53:29,630
0,90 90,390 390,570 570,960 960,1050
you have page tables and

1746
00:53:29,630 --> 00:53:30,720
0,240 240,660
page faults.|
|

1747
00:53:31,140 --> 00:53:32,250
0,420 420,570 570,690 690,1050 1050,1110
{} But it's important to
但是要记得，这是一种令人难以置信的强大机制，

1748
00:53:32,250 --> 00:53:34,590
0,180 180,270 270,750 1110,1860 1950,2340
keep in mind that this

1749
00:53:34,590 --> 00:53:38,250
0,120 120,660 720,1410 1410,2520 2700,3660
is an incredibly powerful mechanism,|
|

1750
00:53:38,520 --> 00:53:40,080
0,330 330,690 690,1020 1050,1230 1230,1560
{} that {} will provide
可以给操作系统带来极大的灵活性。

1751
00:53:40,080 --> 00:53:41,580
0,60 60,390 390,750 750,1020 1050,1500
the operating system with tremendous

1752
00:53:41,580 --> 00:53:42,940
0,210 210,270 270,930
amount of flexibility.|
|

1753
00:53:43,410 --> 00:53:44,430
0,240 240,330 330,390 390,690 690,1020
And this is one reason
这也是页表如此流行的一个原因。

1754
00:53:44,430 --> 00:53:45,690
0,210 210,480 480,780 780,870 870,1260
why page tables are so

1755
00:53:45,690 --> 00:53:46,780
0,630
popular.|
|

1756
00:53:49,490 --> 00:53:50,630
0,570 600,720 720,870 870,930 930,1140
Okay, so what I wanna
好的，下面我要讲的是 xv6 ，

1757
00:53:50,630 --> 00:53:52,460
0,150 150,810 840,1020 1020,1470 1470,1830
do next, is actually talk

1758
00:53:52,460 --> 00:53:54,280
0,540 540,1290
about xv6,|
|

1759
00:53:54,580 --> 00:53:56,230
0,720 720,1110 1110,1290 1290,1350 1350,1650
{} and sort of see
看看这些在 xv6 中是如何发生的。

1760
00:53:56,230 --> 00:53:57,850
0,330 330,540 540,750 750,1110 1110,1620
how it all plays out

1761
00:53:57,880 --> 00:53:59,580
0,390 390,1200
in xv6.|
|

1762
00:53:59,610 --> 00:54:00,330
0,180 180,270 270,480 480,600 600,720
So the first thing, I'm
我要做的第一件事是查看内核页表布局，

1763
00:54:00,330 --> 00:54:01,830
0,180 180,720 780,1140 1140,1260 1260,1500
gonna do, {} is going

1764
00:54:01,830 --> 00:54:03,480
0,60 60,240 240,360 360,1080 1200,1650
to look at the kernel

1765
00:54:03,480 --> 00:54:05,700
0,540 690,1470 1500,1650 1650,1800 1800,2220
page layout, if you will,|
|

1766
00:54:05,730 --> 00:54:09,090
0,660 900,1710 1740,2370 2700,3240 3240,3360
{} and the mapping is
它的映射在这张幻灯片上，

1767
00:54:09,090 --> 00:54:10,920
0,90 90,300 300,780 1320,1500 1500,1830
on this slide,| so here's
|这边是内核的虚拟地址空间，

1768
00:54:10,920 --> 00:54:11,800
0,390
the

1769
00:54:12,100 --> 00:54:13,960
0,480 480,750 750,1350
virtual address space

1770
00:54:20,860 --> 00:54:22,180
0,180 180,270 270,750
of the kernel,|
|

1771
00:54:23,440 --> 00:54:24,850
0,210 210,630 630,1020 1020,1140 1140,1410
and {here,is} actually the physical
这边是物理内存，你可以把它认为是 DRAM ，

1772
00:54:24,850 --> 00:54:26,440
0,420 540,750 750,930 930,1050 1050,1590
memory, so this is basically

1773
00:54:26,440 --> 00:54:27,520
0,420 450,600 600,690 690,840 840,1080
whatever you can think about

1774
00:54:27,520 --> 00:54:28,880
0,150 150,300 300,810
this is DRAM,|
|

1775
00:54:31,760 --> 00:54:32,750
0,270 270,330 330,660 660,810 810,990
and in fact it is
而实际上并不是，让我来退回一点，

1776
00:54:32,750 --> 00:54:34,730
0,510 720,1110 1140,1350 1350,1590 1770,1980
not, {} let me take

1777
00:54:34,730 --> 00:54:36,680
0,120 120,360 360,960 1140,1530 1530,1950
that back immediately,| one part
|一部分是 DRAM ，还有一部分是 IO 设备。

1778
00:54:36,710 --> 00:54:38,100
0,150 150,840
is DRAM,

1779
00:54:38,560 --> 00:54:40,090
0,150 150,450 450,990 1080,1290 1290,1530
and one part is actually

1780
00:54:40,090 --> 00:54:41,780
0,360 360,1110
IO devices.|
|

1781
00:54:46,060 --> 00:54:48,400
0,330 330,480 480,900 930,1560 1950,2340
{} And so, {} to
我先讲一下幻灯片的右边的物理内存部分，

1782
00:54:48,400 --> 00:54:49,090
0,180 180,240 240,450 450,570 570,690
sort of maybe I'm going

1783
00:54:49,090 --> 00:54:50,050
0,60 60,210 210,420 420,510 510,960
to talk about the physical,

1784
00:54:50,050 --> 00:54:51,370
0,420 420,660 660,780 780,990 990,1320
{the,right} side of the slide

1785
00:54:51,370 --> 00:54:52,120
0,30 30,240 240,360 360,660 660,750
a little bit first| and
|过一会讲左边的部分。

1786
00:54:52,120 --> 00:54:52,840
0,120 120,210 210,390 390,630 630,720
then we'll talk about the

1787
00:54:52,840 --> 00:54:53,740
0,210 210,420 420,480 480,570 570,900
left side in the second.|
|

1788
00:54:54,360 --> 00:54:55,440
0,150 150,300 300,660 660,960 960,1080
So the right side of
幻灯片的右边部分完全是由硬件决定的，

1789
00:54:55,440 --> 00:54:57,690
0,810 840,1350 1380,1500 1500,1890 1890,2250
the slide is completely determined

1790
00:54:57,690 --> 00:54:58,820
0,90 90,180 180,600
by the hardware,|
|

1791
00:54:58,940 --> 00:54:59,900
0,360 360,510 510,600 600,690 690,960
{} and so the hardware
硬件设计师决定它的布局，

1792
00:54:59,900 --> 00:55:02,240
0,720 750,1230 1230,1680 1680,1800 1800,2340
designers, basically determine the layout

1793
00:55:02,240 --> 00:55:03,740
0,150 150,390 390,660 720,1140 1290,1500
of that is| and you
|像你上周看到的，当内核启动后，它从 0x8000 开始，

1794
00:55:03,740 --> 00:55:05,000
0,150 150,300 300,540 540,960 960,1260
know {as,you} saw before last

1795
00:55:05,000 --> 00:55:08,000
0,360 630,2010 2010,2070 2070,2370 2370,3000
week, when the kernel starts,

1796
00:55:08,090 --> 00:55:09,440
0,150 150,510 510,600 600,720 720,1350
it starts at this address

1797
00:55:09,470 --> 00:55:11,260
0,420 420,870 870,1380
{0x8000 - -},|
|

1798
00:55:11,720 --> 00:55:13,820
0,510 750,900 900,1380 1380,1980 1980,2100
{} and that's determined by
这是由硬件设计师决定的，

1799
00:55:13,820 --> 00:55:16,100
0,60 60,330 330,1020 1320,1890 1890,2280
the hardware designers,| {} and
|所以你应该很清楚，如果你查看这块电路板，

1800
00:55:16,100 --> 00:55:17,540
0,240 240,900 900,990 990,1290 1290,1440
so you should be more

1801
00:55:17,540 --> 00:55:19,730
0,570 840,1650 1650,1920 1920,2040 2040,2190
explicit, {} if you look

1802
00:55:19,730 --> 00:55:20,840
0,60 60,150 150,690 780,1050 1050,1110
at the board,| this is
|这跟我在周一展示的图片很类似，但是更好一点，更容易观察，

1803
00:55:20,840 --> 00:55:21,560
0,60 60,300 300,570 570,630 630,720
the same picture of the

1804
00:55:21,560 --> 00:55:23,000
0,450 450,570 570,720 720,1050 1050,1440
board that I showed on

1805
00:55:23,000 --> 00:55:23,960
0,330 330,480 480,600 600,930 930,960
Monday, but is hopefully a

1806
00:55:23,960 --> 00:55:25,700
0,240 240,750 780,1290 1290,1440 1440,1740
little better picture, it's easier

1807
00:55:25,700 --> 00:55:27,020
0,60 60,540 600,990 990,1080 1080,1320
to see,| here's our {RISC-V
|这里是 RISC-V 处理器，我们知道在处理器中有四个核心，

1808
00:55:27,020 --> 00:55:28,360
0,270 270,990
-} processor,

1809
00:55:28,420 --> 00:55:29,440
0,180 180,270 270,390 390,720 720,1020
and we now know correct

1810
00:55:29,440 --> 00:55:31,030
0,210 210,300 300,690 690,1200 1200,1590
in the RISC-V processor, {there,four}

1811
00:55:31,030 --> 00:55:32,350
0,540 570,840 840,960 960,1260 1260,1320
cores,| but there's also a
|还有一个 MMU ，还有一个 TLB ，

1812
00:55:32,350 --> 00:55:34,840
0,630 930,1140 1140,1290 1290,1950 1950,2490
MMU and there's also a

1813
00:55:34,840 --> 00:55:36,790
0,630 630,810 810,1170 1170,1650 1650,1950
TLB| or multiple TLB every
|或者多个 TLB ，每个 MMU 和每个核心有它自己的 TLB 。

1814
00:55:36,790 --> 00:55:38,140
0,270 270,450 450,540 540,990 1140,1350
core has its own, and

1815
00:55:38,140 --> 00:55:39,130
0,150 150,360 360,510 510,750 750,990
{MMU -} and every core

1816
00:55:39,130 --> 00:55:40,680
0,150 150,240 240,420 420,1020
has its own TLB.|
|

1817
00:55:40,800 --> 00:55:42,780
0,330 330,780 780,960 960,1440 1440,1980
And here are DRAM chips,
这里是 DRAM 芯片，电路板的设计者决定，

1818
00:55:43,780 --> 00:55:46,150
0,360 360,810 840,1560 1560,1890 1890,2370
and so basically the designers

1819
00:55:46,150 --> 00:55:47,260
0,90 90,150 150,480 480,570 570,1110
of the board have decided

1820
00:55:47,260 --> 00:55:49,690
0,420 630,1170 1170,1890 1920,2040 2040,2430
that,| {} when you know
|当虚拟地址转换位物理地址之后，

1821
00:55:50,110 --> 00:55:51,820
0,570 570,690 690,810 810,1230 1260,1710
after you know the translation

1822
00:55:51,820 --> 00:55:53,110
0,120 120,390 390,480 480,780 780,1290
from virtual to physical address,|
|

1823
00:55:53,200 --> 00:55:55,240
0,480 480,840 840,1260 1260,1470 1470,2040
basic physical addresses that's starting
物理地址从 0x8000 开始，指向 DRAM 芯片。

1824
00:55:55,240 --> 00:55:56,590
0,150 150,420 420,720 720,900 900,1350
you know at o eight

1825
00:55:56,590 --> 00:55:58,150
0,390 390,600 600,1200 1260,1470 1470,1560
{you,know} {a,lot,of} zeros, {actually -}

1826
00:55:58,150 --> 00:55:59,440
0,180 180,270 270,360 360,750 750,1290
go to the DRAM chips.|
|

1827
00:56:00,660 --> 00:56:03,180
0,570 570,690 690,1680 1680,2160 2250,2520
Addresses {} below 0x8000, may
在 0x8000 以下的地址，可能指向不同的 IO 设备。

1828
00:56:03,180 --> 00:56:04,740
0,180 180,300 300,570 570,810 810,1560
go to different IO devices.|
|

1829
00:56:05,260 --> 00:56:06,490
0,180 180,270 270,810 960,1230 1230,1230
And so the { -}
所以，平台，电路板设计者决定了物理布局。

1830
00:56:06,880 --> 00:56:09,550
0,810 810,1500 1500,2100 2100,2220 2220,2670
platform decides basically the designers

1831
00:56:09,550 --> 00:56:11,110
0,180 180,570 570,690 690,1140 1140,1560
this board have decided exactly

1832
00:56:11,110 --> 00:56:12,620
0,90 90,180 180,510 510,1020
what the physical layout.|
|

1833
00:56:12,770 --> 00:56:13,550
0,150 150,300 300,420 420,570 570,780
I think you can look
我想你可以查看物理布局，让我来展示给你，

1834
00:56:13,550 --> 00:56:14,810
0,150 150,480 480,600 600,960 960,1260
that up the physical layout,

1835
00:56:14,810 --> 00:56:16,400
0,120 120,210 210,450 450,810 1020,1590
if you want to, just

1836
00:56:16,400 --> 00:56:17,390
0,150 150,210 210,450 450,810 810,990
let me show you,| so
|所以这是我周一展示给你们的手册，

1837
00:56:17,390 --> 00:56:19,040
0,300 300,690 690,930 930,1500 1500,1650
here's the same manual that

1838
00:56:19,040 --> 00:56:21,230
0,90 90,390 390,540 540,1170 1650,2190
I showed you on {

1839
00:56:22,010 --> 00:56:23,400
0,420 420,870
- -}

1840
00:56:24,230 --> 00:56:26,090
0,420 420,780 810,1440 1500,1800 1800,1860
on the Monday| and if
|我记得，如果你跳到 31 页。

1841
00:56:26,090 --> 00:56:28,820
0,120 120,330 330,840 840,1290 1980,2730
you go to actually {}

1842
00:56:29,500 --> 00:56:31,570
0,240 240,600 600,1380 1380,1980 1980,2070
go to page 31, I

1843
00:56:31,570 --> 00:56:32,720
0,570
believe.|
|

1844
00:56:32,810 --> 00:56:34,520
0,480 480,690 690,1110 1200,1710 1710,1710
Yeah, it's the page {}
是的，是这一页，如果你向下滚动，

1845
00:56:35,180 --> 00:56:36,140
0,330 330,390 390,480 480,570 570,960
and if you go down,|
|

1846
00:56:36,140 --> 00:56:37,520
0,360 360,540 540,960 960,1050 1050,1380
this is what's the memory,
这里展示了电路板的内存映射，

1847
00:56:37,520 --> 00:56:38,720
0,90 90,390 420,900 900,1140 1140,1200
it will [spell] out the

1848
00:56:38,720 --> 00:56:40,550
0,270 270,570 570,840 870,1110 1110,1830
memory map is of the

1849
00:56:40,730 --> 00:56:42,860
0,570 600,1170 1440,1650 1650,1770 1770,2130
{} board| and we'll see
|我们可以看到零地址是保留的，没有任何东西，

1850
00:56:42,860 --> 00:56:44,270
0,150 150,450 450,690 690,1260 1290,1410
at address zero zero is

1851
00:56:44,270 --> 00:56:45,940
0,510 510,780 780,870 870,1200
reserved nothing is there,|
|

1852
00:56:46,000 --> 00:56:48,580
0,750 960,1200 1200,1560 1560,1980 2220,2580
{} if you go scroll
如果你继续向下滚动，会看到映射的很多不同东西的信息，

1853
00:56:48,580 --> 00:56:49,990
0,360 360,450 450,570 570,870 870,1410
down in this memory map,

1854
00:56:49,990 --> 00:56:52,630
0,420 420,1260 1260,1470 1470,2250 2250,2640
you'll see some information about

1855
00:56:52,630 --> 00:56:53,560
0,180 180,270 270,600 600,810 810,930
all the different things that

1856
00:56:53,560 --> 00:56:55,240
0,60 60,540 540,600 600,960 990,1680
are mapped,| for example Ethernet
|比如，以太网映射在 0x 某个地址，

1857
00:56:55,360 --> 00:56:56,860
0,600 600,750 750,1140 1140,1380 1380,1500
board is mapped at 0

1858
00:56:56,860 --> 00:56:58,630
0,420 420,1050 1080,1200 1200,1440 1440,1770
x one you know 0x

1859
00:56:58,630 --> 00:56:59,680
0,570
something,|
|

1860
00:57:00,010 --> 00:57:02,320
0,630 1050,1320 1320,1560 1560,2010 2010,2310
{} if you go further
如果你继续向下，糟糕，太过了，

1861
00:57:02,320 --> 00:57:04,720
0,660 690,1200 1530,1680 1680,1890 1890,2400
down, oops, too much down,|
|

1862
00:57:05,020 --> 00:57:07,180
0,600 600,900 900,1050 1050,1650 1890,2160
{} here you see the
这里你可以看到 0x8000 ，它是 DDR 内存，片外易失性内存，

1863
00:57:07,180 --> 00:57:08,860
0,420 420,780 780,930 930,1290 1290,1680
entry for {0x8000 - -

1864
00:57:08,890 --> 00:57:10,840
0,300 300,540 540,1230 1440,1860 1860,1950
- - -} correct and

1865
00:57:10,840 --> 00:57:13,210
0,300 300,750 750,1170 1170,1770 1770,2370
that actually is DDR memory,

1866
00:57:13,240 --> 00:57:14,800
0,150 150,420 420,690 690,1140 1140,1560
the {Off-Chip -} Volatile Memory,|
|

1867
00:57:15,010 --> 00:57:16,060
0,150 150,390 390,510 510,660 660,1050
so those are the DRAM
它是 DRAM 芯片，我在上一张幻灯片中展示的。

1868
00:57:16,060 --> 00:57:17,080
0,330 330,510 510,630 630,930 930,1020
chips, I just showed you

1869
00:57:17,080 --> 00:57:18,420
0,90 90,150 150,450 450,930
on the previous slide.|
|

1870
00:57:19,520 --> 00:57:20,390
0,120 120,240 240,360 360,660 660,870
And so it's just good
所以你要知道，即使我们讲的是 QEMU ，使用软件（模拟的），

1871
00:57:20,390 --> 00:57:21,380
0,90 90,270 270,450 450,690 690,990
to keep your head correct,

1872
00:57:21,380 --> 00:57:22,370
0,180 180,360 360,570 570,900 900,990
even though we're talking to

1873
00:57:22,370 --> 00:57:24,380
0,270 270,720 720,1200 1200,1830 1860,2010
QEMU, {you,know} using software,| in
|最终任何东西都是由实际的电路板决定的。

1874
00:57:24,380 --> 00:57:25,970
0,120 120,450 450,750 750,840 840,1590
the end everything is determined

1875
00:57:26,030 --> 00:57:27,590
0,870 870,990 990,1110 1110,1260 1260,1560
by you know the actual

1876
00:57:27,590 --> 00:57:28,580
0,510
board.|
|

1877
00:57:30,640 --> 00:57:32,260
0,210 210,330 330,450 450,870 870,1620
Okay, so go back to
好的，回到我的幻灯片，我们来看看这个布局。

1878
00:57:32,470 --> 00:57:35,320
0,690 1080,1230 1230,1860 2340,2670 2670,2850
{} my slides, so let's

1879
00:57:35,320 --> 00:57:36,700
0,150 150,240 240,840
look at the

1880
00:57:37,280 --> 00:57:39,500
0,870 900,1350 1380,1860 1860,2070 2100,2220
layout.| Yeah, {Noah -}, go
|是的， Noah ，继续。

1881
00:57:39,500 --> 00:57:40,440
0,390
ahead.|
|

1882
00:57:41,360 --> 00:57:42,320
0,240 240,390 390,540 540,720 720,960
Yeah, when you say that
是的，当你说这个布局是由硬件决定的，

1883
00:57:42,320 --> 00:57:43,640
0,420 420,630 630,840 840,930 930,1320
this this layout is determined

1884
00:57:43,640 --> 00:57:44,690
0,90 90,180 180,690 690,900 930,1050
by the hardware,| {} do
|你说的是 CPU 自己还是 CPU 所在的电路板。

1885
00:57:44,690 --> 00:57:46,550
0,120 120,690 690,1140 1170,1710 1710,1860
you specifically mean like the

1886
00:57:46,550 --> 00:57:48,650
0,480 480,990 1020,1320 1320,1770 1800,2100
CPU itself or the the

1887
00:57:48,650 --> 00:57:49,910
0,300 300,480 480,690 690,810 810,1260
board on which the CPU

1888
00:57:49,910 --> 00:57:51,500
0,810 870,1050 1050,1350 1350,1410 1410,1590
resides.| The board in which
|是 CPU 所在的电路板，

1889
00:57:51,500 --> 00:57:52,700
0,90 90,240 240,390 390,900 900,1200
the {CPU -} resides, correct,|
|

1890
00:57:52,700 --> 00:57:53,900
0,240 240,330 330,450 450,510 510,1200
because you know the board,
因为 CPU 是这个方块中的那个灰色的东西，比如 RISC-V ，

1891
00:57:53,990 --> 00:57:55,070
0,150 150,270 270,630 630,990 990,1080
you know the CPU is

1892
00:57:55,070 --> 00:57:56,300
0,360 390,840 840,1080 1080,1170 1170,1230
that grey thing in the

1893
00:57:56,300 --> 00:57:57,860
0,300 300,480 480,810 810,1200 1200,1560
middle that square thing, saying

1894
00:57:57,860 --> 00:58:00,080
0,660 660,870 870,1350 1590,1830 1830,2220
whatever {RISC-V -},| the DRAM
|DRAM 芯片在处理器旁边，

1895
00:58:00,080 --> 00:58:02,960
0,510 510,660 660,1050 1050,1560 1590,2880
chips are sitting off {}

1896
00:58:02,990 --> 00:58:04,610
0,300 300,390 390,900 930,1440 1440,1620
off the processor, correct,| it's
|是电路板设计者把芯片， DRAM ，很多 IO 设备放在一起。

1897
00:58:04,610 --> 00:58:05,810
0,120 120,390 390,870 870,990 990,1200
the board designers who put

1898
00:58:05,810 --> 00:58:08,090
0,210 240,900 900,1020 1020,1770 1860,2280
the chip the DRAM, {you,know}

1899
00:58:08,090 --> 00:58:09,950
0,90 90,390 390,750 750,1230 1230,1860
the many IO devices altogether.|
|

1900
00:58:11,580 --> 00:58:13,320
0,240 240,450 450,780 990,1350 1350,1740
{Got,it}, {thank,you}.| A large part
了解了，谢谢。|操作系统是有很多部分组成的，

1901
00:58:13,320 --> 00:58:14,250
0,90 90,180 180,510 510,840 840,930
of an operating system is

1902
00:58:14,250 --> 00:58:15,330
0,300 300,480 480,720 720,870 870,1080
actually| {you,know} {CPU,is -} one
|CPU 是其中之一，但是 IO 设备也同样重要，

1903
00:58:15,330 --> 00:58:16,830
0,480 540,690 690,810 810,1080 1080,1500
part, but the IO devices

1904
00:58:16,830 --> 00:58:17,910
0,90 90,180 180,360 360,450 450,1080
are at least as important,

1905
00:58:17,940 --> 00:58:19,050
0,450 450,660 660,810 810,960 960,1110
right| and so when you're
|所以当你编写操作系统时，既要处理 CPU ，也要处理 IO 设备，

1906
00:58:19,050 --> 00:58:20,460
0,210 210,300 300,600 600,1110 1170,1410
writing an operating system, you

1907
00:58:20,460 --> 00:58:21,270
0,270 270,390 390,480 480,690 690,810
both have to deal with

1908
00:58:21,270 --> 00:58:22,380
0,90 90,570 570,720 720,960 960,1110
the CPU as well as

1909
00:58:22,380 --> 00:58:23,160
0,120 120,240 240,420 420,480 480,780
you know with the IO

1910
00:58:23,160 --> 00:58:24,270
0,510 510,600 600,660 660,1020 1020,1110
devices,| you know [if] you
|如果你想通过互联网发送一个包，

1911
00:58:24,270 --> 00:58:24,990
0,150 150,210 210,360 360,420 420,720
want to send a packet

1912
00:58:24,990 --> 00:58:26,490
0,150 150,240 240,690 930,1200 1200,1500
over the Internet,| well, somebody
|必须有人接手，网络驱动， NIC 卡会去做这个，

1913
00:58:26,490 --> 00:58:27,580
0,240 240,630
has to,

1914
00:58:28,770 --> 00:58:29,730
0,270 270,600 600,690 690,810 810,960
take {}, you know the

1915
00:58:29,730 --> 00:58:31,320
0,300 300,720 720,810 810,1170 1170,1590
network driver, the NIC card

1916
00:58:31,320 --> 00:58:32,070
0,120 120,300 300,420 420,660 660,750
to actually do that,| and
|这才是操作系统。

1917
00:58:32,070 --> 00:58:33,500
0,150 150,270 270,600 600,900
that's the operating system.|
|

1918
00:58:35,430 --> 00:58:36,990
0,510 900,1110 1110,1350 1350,1410 1410,1560
So going back to the
所以，回到这张图片的右侧，就是物理地址布局，

1919
00:58:36,990 --> 00:58:38,010
0,240 240,390 390,450 450,630 630,1020
right side of this picture

1920
00:58:38,010 --> 00:58:38,910
0,240 240,360 360,420 420,540 540,900
correct, which is the physical

1921
00:58:38,910 --> 00:58:40,890
0,600 660,1440 1620,1770 1770,1860 1860,1980
address layout,| you know we
|我们看到底部没有使用，像我在文档中展示的那样，

1922
00:58:40,890 --> 00:58:42,630
0,180 180,630 630,990 1230,1590 1590,1740
see basically the bottom was

1923
00:58:42,630 --> 00:58:43,920
0,600 600,750 750,840 840,1140 1140,1290
unused as I showed you

1924
00:58:43,920 --> 00:58:45,870
0,180 180,450 450,810 810,1470 1800,1950
on that {} document,| it
|它的 0x1000 物理地址是 boot ROM ，

1925
00:58:45,870 --> 00:58:46,770
0,210 210,360 360,600 600,600 600,900
turns out that {0x1000 -

1926
00:58:46,770 --> 00:58:48,300
0,180 180,390 390,960 990,1230 1230,1530
- - -} that physical

1927
00:58:48,300 --> 00:58:49,440
0,390 390,570 570,840 840,900 900,1140
address, that's where the boot

1928
00:58:49,440 --> 00:58:50,730
0,510 510,600 600,930 930,1140 1140,1290
ROM is,| so when you
|所以，当你启动电路板，第一件事就是运行 boot ROM 里面的代码。

1929
00:58:50,730 --> 00:58:52,470
0,270 270,840 870,990 990,1620 1620,1740
turn on {you,know,that,board -}, the

1930
00:58:52,470 --> 00:58:53,460
0,270 270,390 390,510 510,900 900,990
first thing that happens is

1931
00:58:53,460 --> 00:58:55,470
0,270 270,660 660,720 720,1200 1350,2010
actually {code,in} the {boot,ROM} runs.|
|

1932
00:58:55,930 --> 00:58:56,680
0,150 150,270 270,360 360,480 480,750
And when the boot ROM
当 boot ROM 完成后，它会跳转到 [0x8000] ，

1933
00:58:56,680 --> 00:58:58,060
0,90 90,570 780,960 960,1230 1230,1380
is done, it actually will

1934
00:58:58,060 --> 00:58:59,680
0,330 330,420 420,660 660,1350 1350,1620
jump to this {[0x8000] -

1935
00:58:59,680 --> 00:59:01,390
0,630 810,990 990,1260 1260,1620 1620,1710
-}| and it's job of
|操作系统的工作是需要确保那里有一些数据。

1936
00:59:01,390 --> 00:59:02,470
0,120 120,420 420,720 720,840 840,1080
the operating system make sure

1937
00:59:02,470 --> 00:59:03,640
0,120 120,300 300,660
that there's some,

1938
00:59:03,760 --> 00:59:04,690
0,90 90,210 210,360 360,600 600,930
you know some data there.|
|

1939
00:59:05,430 --> 00:59:06,180
0,180 180,360 360,510 510,570 570,750
And then there's a bunch
然后，我们还要讨论一些其他设备，

1940
00:59:06,180 --> 00:59:07,680
0,60 60,420 420,1080 1080,1290 1290,1500
of other devices that we'll

1941
00:59:07,680 --> 00:59:09,440
0,240 240,600 600,810 810,1170
talk about,| there is
|这是中断控制器，我们会在下周讨论，

1942
00:59:09,630 --> 00:59:11,820
0,690 690,810 810,1140 1140,1770 1800,2190
{} the interrupt controller, {}

1943
00:59:11,820 --> 00:59:12,660
0,150 150,330 330,510 510,600 600,840
we'll talk about it next

1944
00:59:12,660 --> 00:59:14,640
0,360 840,1170 1170,1380 1380,1470 1470,1980
week,| {} there's a CLINT,
|这是 CLINT ，我们在下周讨论的关于中断的另一个[故事]，

1945
00:59:14,700 --> 00:59:16,410
0,720 720,1170 1170,1530 1530,1590 1590,1710
another {} part of the

1946
00:59:16,410 --> 00:59:18,450
0,660 660,1350 1500,1740 1740,1860 1860,2040
interrupt [story], that we'll talk

1947
00:59:18,450 --> 00:59:20,010
0,240 240,480 480,840 1020,1170 1170,1560
about next week,| so basically
|基本上是，多种设备可以产生中断，

1948
00:59:20,010 --> 00:59:21,960
0,390 390,930 930,1110 1110,1470 1470,1950
multiple devices can generate interrupts,|
|

1949
00:59:21,960 --> 00:59:22,920
0,150 150,330 330,390 390,630 630,960
there needs to be planned
所以需要一种方案来路由这些中断到合适的[请求]级别，

1950
00:59:22,920 --> 00:59:24,240
0,90 90,330 330,480 480,960 960,1320
to route those interrupts to

1951
00:59:24,390 --> 00:59:26,340
0,360 360,630 630,720 720,1380 1410,1950
{} to the appropriate request

1952
00:59:26,340 --> 00:59:27,600
0,420 420,510 510,660 660,810 810,1260
level,| and that's all implemented
|这些都是由中断控制器实现的。

1953
00:59:27,600 --> 00:59:30,380
0,690 810,1380 1380,1740 1740,2400
by those interrupt controllers.|
|

1954
00:59:30,530 --> 00:59:32,060
0,300 300,450 450,540 540,930 1200,1530
{} And let me finish,
稍等一下，让我先讲完这个幻灯片，再回答问题。

1955
00:59:32,060 --> 00:59:32,990
0,120 120,150 150,630 660,840 840,930
for a second, you know

1956
00:59:32,990 --> 00:59:35,150
0,240 240,390 390,870 870,1440 1800,2160
this, this slide before answer

1957
00:59:35,150 --> 00:59:36,980
0,30 30,540
your question.|
|

1958
00:59:36,980 --> 00:59:38,660
0,510 510,780 780,960 960,1470 1500,1680
Then there's a UART, that
这里有一个 UART ，它是与 console 和显示器交互的设备，

1959
00:59:38,660 --> 00:59:40,910
0,240 240,300 300,1050 1230,2010 2040,2250
was the device, {} that

1960
00:59:40,910 --> 00:59:41,720
0,150 150,420 420,540 540,690 690,810
was actually, the thing that

1961
00:59:41,720 --> 00:59:44,030
0,570 900,1050 1050,1500 1500,2010 2010,2310
actually, the device actually UART

1962
00:59:44,030 --> 00:59:45,200
0,300 300,420 420,630 630,1020 1020,1170
device, that actually interacts with

1963
00:59:45,200 --> 00:59:46,850
0,90 90,750 750,870 870,930 930,1650
the console and the display|
|

1964
00:59:47,090 --> 00:59:48,290
0,150 150,270 270,600 600,720 720,1200
and then there's the {VIRTIO_disk
这里是 VIRTIO_disk ，属于，它与磁盘交互，

1965
00:59:48,290 --> 00:59:50,480
0,210 210,360 360,900 1230,1950 1950,2190
- - -} {} and

1966
00:59:50,480 --> 00:59:52,100
0,210 210,780 810,1290 1290,1560 1560,1620
that's the device, there's a

1967
00:59:52,100 --> 00:59:53,750
0,450 450,960 960,1200 1200,1440 1440,1650
device belong, it's that actually

1968
00:59:53,750 --> 00:59:55,010
0,300 300,390 390,480 480,930 1110,1260
interacts with the disk| and
|所以当你写入到地址，比如 0x2000 ，这个地址对应 CLINT ，

1969
00:59:55,010 --> 00:59:56,480
0,120 120,300 300,510 510,960 1230,1470
so when you write to

1970
00:59:56,480 --> 00:59:58,460
0,510 510,630 630,1170 1170,1410 1410,1980
location to address, let's say

1971
00:59:58,820 --> 01:00:00,410
0,210 210,510 510,690 690,930 930,1590
{0x2000 - - - -},

1972
01:00:00,960 --> 01:00:03,000
0,630 630,870 870,1200 1200,1530 1530,2040
then, that physical address corresponds

1973
01:00:03,000 --> 01:00:04,080
0,90 90,180 180,720 810,960 960,1080
to the CLINT| and so
|所以，当你运行保存指令，加载指令，你就是在读写实现 CLINT 的芯片，

1974
01:00:04,080 --> 01:00:04,650
0,90 90,210 210,330 330,390 390,570
when you want to do

1975
01:00:04,650 --> 01:00:06,330
0,330 330,750 750,810 810,1080 1080,1680
store instruction, {} load instruction,

1976
01:00:06,390 --> 01:00:08,700
0,570 600,990 990,1140 1140,1650 1680,2310
you're reading and writing to

1977
01:00:08,730 --> 01:00:10,920
0,720 780,1200 1200,1350 1350,1830 1830,2190
the chip, that implements the

1978
01:00:10,920 --> 01:00:12,780
0,510 510,510 510,1410
{ -} CLINT,|
|

1979
01:00:13,190 --> 01:00:14,120
0,240 240,390 390,630 630,810 810,930
we'll see later what that
我们后面会看这是什么意思，现在你可以认为是，

1980
01:00:14,120 --> 01:00:15,650
0,360 360,810 870,1050 1050,1410 1410,1530
exactly means, but basically you

1981
01:00:15,650 --> 01:00:16,460
0,90 90,240 240,480 480,630 630,810
can think about| this as
|这是直接与设备交互，而不是读写物理内存。

1982
01:00:16,460 --> 01:00:18,200
0,660 660,990 990,1140 1140,1200 1200,1740
interacting directly with the device

1983
01:00:18,200 --> 01:00:19,130
0,120 120,360 360,570 570,660 660,930
and not reading or writing

1984
01:00:19,130 --> 01:00:20,320
0,330 330,690
physical memory.|
|

1985
01:00:21,780 --> 01:00:23,240
0,180 180,360 360,390 390,870
Yeah, there's a question.|
是的，有什么问题。|

1986
01:00:24,240 --> 01:00:25,500
0,390 420,660 660,990 990,1170 1170,1260
{} So just trying to
所以，我想确认一下 0x8000 以下的地址不存在与 DRAM 中，

1987
01:00:25,500 --> 01:00:28,440
0,270 270,660 660,1110 1140,1950 1950,2940
make sure the addresses below

1988
01:00:28,440 --> 01:00:30,450
0,720 720,1020 1020,1380 1380,1740 1740,2010
{0x8000 - - -}, they

1989
01:00:30,450 --> 01:00:32,370
0,300 300,600 600,1110 1110,1260 1260,1920
don't really exist in DRAM,|
|

1990
01:00:33,660 --> 01:00:34,800
0,210 210,540 540,630 630,960 960,1140
if when we mention those
如果我们使用这些地址，它们直接指向其他硬件。

1991
01:00:34,800 --> 01:00:35,880
0,420 420,510 510,900 900,1020 1020,1080
addresses, we directly go to

1992
01:00:35,880 --> 01:00:37,710
0,300 330,600 600,900 900,1290 1320,1830
the other {hardwares -}.| Yeah,
|是的，回到这张图片，

1993
01:00:37,740 --> 01:00:38,940
0,330 330,540 540,930 930,1080 1080,1200
yeah, so if you go

1994
01:00:38,940 --> 01:00:40,860
0,210 210,270 270,390 390,960 1410,1920
back to this picture,| anything
|任何 0x8000 以上的（地址），是 DRAM 芯片。

1995
01:00:40,860 --> 01:00:42,450
0,450 450,450 450,780 780,1170 1170,1590
above {0x8000 - - -},

1996
01:00:42,450 --> 01:00:43,380
0,450
correct,

1997
01:00:45,310 --> 01:00:47,200
0,270 270,480 480,840 840,1350
that's these DRAM chips.|
|

1998
01:00:48,020 --> 01:00:49,640
0,780 870,1020 1020,1110 1110,1200 1200,1620
And you know I can't
我不能画出，指出 CLINT ，但是这里是以太网（控制器），

1999
01:00:49,670 --> 01:00:50,780
0,390 390,390 390,810 810,1020 1020,1110
draw, I can't point you

2000
01:00:50,780 --> 01:00:52,340
0,90 90,150 150,720 810,1350 1350,1560
to the CLINT, {} but

2001
01:00:52,340 --> 01:00:54,440
0,210 210,510 510,1080 1440,1770 1770,2100
like generally here is {Ethernet

2002
01:00:54,440 --> 01:00:55,300
0,270
-},|
|

2003
01:00:55,980 --> 01:00:57,180
0,210 210,330 330,690 690,750 750,1200
and so that's {} particular
所以这个可写的特殊物理地址，可以（执行）加载保存指令，称为内存映射 IO ，

2004
01:00:57,180 --> 01:00:58,140
0,300 300,600 600,690 690,780 780,960
physical address and we can

2005
01:00:58,140 --> 01:00:59,640
0,480 510,690 690,900 930,1260 1260,1500
write you know load store

2006
01:00:59,640 --> 01:01:01,050
0,540 540,690 690,930 930,1170 1170,1410
instructions is called memory mapped

2007
01:01:01,050 --> 01:01:02,700
0,540 750,1020 1020,1290 1290,1560 1560,1650
IO,| we can load and
|我们可以（执行）加载保存指令，对以太网卡编程。

2008
01:01:02,700 --> 01:01:04,350
0,210 210,750 750,870 870,1020 1020,1650
store instructions, we can program

2009
01:01:04,380 --> 01:01:05,800
0,330 330,420 420,960
{Ethernet -} controller.|
|

2010
01:01:09,340 --> 01:01:10,810
0,390 390,630 630,810 810,900 900,1470
I also have a question,
我也有一个问题，为什么顶部的很大一块是没有使用，为什么不使用。

2011
01:01:10,840 --> 01:01:13,240
0,780 810,1260 1260,1620 1620,1890 1890,2400
why was this big chunk

2012
01:01:13,300 --> 01:01:15,130
0,180 180,240 240,750 810,1170 1170,1830
at the top says unused,

2013
01:01:15,460 --> 01:01:16,780
0,240 240,330 330,600 600,840 840,1320
why is it not used.|
|

2014
01:01:17,110 --> 01:01:21,250
0,1530 1530,1740 1740,3120 3150,3840 3840,4140
{Oh,Okay}, so remember not every
好的，你记得不是所有机器，这里是 2 的 56 次方物理地址空间，

2015
01:01:21,250 --> 01:01:22,990
0,450 450,690 690,1080 1080,1230 1230,1740
machine, not every, so there's

2016
01:01:23,200 --> 01:01:24,730
0,180 180,330 330,420 420,720 720,1530
2 to the power 56

2017
01:01:25,190 --> 01:01:27,320
0,360 360,960 960,1350 1350,1590 1590,2130
{} bytes physical address space,|
|

2018
01:01:27,770 --> 01:01:28,790
0,360 360,510 510,600 600,780 780,1020
{} but you don't have
但是如果你不需要，你不会在板上插入那么多内存，

2019
01:01:28,790 --> 01:01:30,170
0,480 510,660 660,780 780,1200 1200,1380
those you know plugin that

2020
01:01:30,170 --> 01:01:31,550
0,180 180,660 660,990 990,1080 1080,1380
much memory into the board,

2021
01:01:31,550 --> 01:01:32,300
0,90 90,180 180,330 330,540 540,750
if you don't want to,|
|

2022
01:01:32,940 --> 01:01:34,050
0,300 300,510 510,750 750,1020 1020,1110
and so some parts of
所以一些部分没有使用，取决于板上实际有多少 DRAM 芯片。

2023
01:01:34,050 --> 01:01:35,600
0,120 120,240 240,390 390,1020
it may be unused,

2024
01:01:35,600 --> 01:01:36,590
0,390 390,450 450,540 540,780 780,990
depending on how much {you,know}

2025
01:01:36,590 --> 01:01:37,700
0,240 240,390 390,720 720,840 840,1110
{DRAM -} chips actually sitting

2026
01:01:37,700 --> 01:01:38,840
0,90 90,180 180,570
on the board.|
|

2027
01:01:42,300 --> 01:01:43,140
0,150 150,420 420,510 510,690 690,840
In fact, {} like in
实际上，在 xv6 中，我想我们只有 128 MB （内存）。

2028
01:01:43,140 --> 01:01:45,360
0,300 300,870 1080,1740 1740,1860 1860,2220
{xv6 }, we I think

2029
01:01:45,390 --> 01:01:47,730
0,540 540,960 960,1170 1170,1890 1980,2340
limit ourselves to {128 -

2030
01:01:47,730 --> 01:01:49,180
0,240 240,870
-} megabyte

2031
01:01:50,440 --> 01:01:51,680
0,150 150,270 270,750
and no more.|
|

2032
01:01:55,360 --> 01:01:58,660
0,420 420,870 870,1560 2040,2670 2970,3300
So when a, {} when
当加载保存指令从 CPU 发出时，

2033
01:01:58,660 --> 01:02:00,940
0,300 300,750 750,1140 1140,1950 1950,2280
a load {or,store} instruction goes

2034
01:02:00,940 --> 01:02:03,070
0,240 240,330 330,480 480,1530 1560,2130
out of the CPU {},|
|

2035
01:02:03,100 --> 01:02:04,920
0,390 390,690 690,1320
does that go
它如何知道路由到对应的 IO ，是已经在 CPU 中了吗，

2036
01:02:04,920 --> 01:02:06,510
0,360 420,600 600,1260 1260,1440 1440,1590
like {} where does it

2037
01:02:06,510 --> 01:02:07,920
0,300 300,720 720,810 810,960 960,1410
get routed to the correct

2038
01:02:07,920 --> 01:02:09,270
0,420 420,690 690,960 960,1230 1230,1350
IO, like already from the

2039
01:02:09,270 --> 01:02:11,070
0,690 870,1170 1170,1410 1410,1470 1470,1800
CPU,| so kind of like
|比如，在 CPU 发出之前，

2040
01:02:11,160 --> 01:02:12,900
0,540 540,720 720,1260 1260,1620 1620,1740
if the CPU before it

2041
01:02:12,900 --> 01:02:13,950
0,270 270,390 390,690 690,810 810,1050
sends it out,| it says
|它知道如果小于 0x8000 ，然后就发送到对应的 IO 设备，

2042
01:02:13,950 --> 01:02:14,910
0,180 180,270 270,480 480,780 780,960
OK, if it's lower than

2043
01:02:14,910 --> 01:02:16,590
0,390 390,840 840,1350 1350,1530 1530,1680
zero x eight and all

2044
01:02:16,590 --> 01:02:18,240
0,90 90,690 840,1320 1320,1530 1530,1650
the zeros, then I'm going

2045
01:02:18,240 --> 01:02:19,200
0,60 60,390 390,540 540,840 840,960
to send it to the

2046
01:02:19,200 --> 01:02:20,580
0,420 420,660 660,1110 1110,1230 1230,1380
correct IO device,| and then
|否则就发送到内存，比如 DRAM 芯片。

2047
01:02:20,580 --> 01:02:21,870
0,420 420,540 540,750 750,1080 1080,1290
otherwise I'm gonna send it

2048
01:02:21,870 --> 01:02:25,110
0,390 510,2010 2190,2400 2400,2520 2520,3240
to the to the memory

2049
01:02:25,140 --> 01:02:26,960
0,360 360,450 450,900 900,1440
like the DRAM chip.|
|

2050
01:02:27,050 --> 01:02:28,070
0,480 480,600 600,690 690,840 840,1020
{Yeah,you,know}, you can think about
是的，你可以认为有一个分解器在 RISC-V 块中。

2051
01:02:28,070 --> 01:02:29,420
0,120 120,210 210,360 360,1020 1020,1350
as a {demultiplexer -} sitting

2052
01:02:29,420 --> 01:02:30,710
0,270 270,390 390,750 750,840 840,1290
on the inside of the

2053
01:02:30,740 --> 01:02:33,710
0,270 270,810 1140,2160 2490,2820 2820,2970
{RISC-V -} block.| Oh, {it's,also}
|噢，它也在那个块中。好的。

2054
01:02:33,710 --> 01:02:35,640
0,300 300,390 390,570 570,1140
inside of that block,

2055
01:02:35,730 --> 01:02:36,780
0,450
Okay.|
|

2056
01:02:38,140 --> 01:02:39,820
0,180 180,300 300,570 570,1260 1290,1680
And the memory controller and
然后，内存管理器进行路由。

2057
01:02:39,970 --> 01:02:41,760
0,630 630,720 720,1200
does a routing.|
|

2058
01:02:44,750 --> 01:02:46,100
0,420 450,780 780,1080 1080,1170 1170,1350
Good, very important to have
好的，弄清楚这些很重要。

2059
01:02:46,100 --> 01:02:46,820
0,120 120,240 240,330 330,450 450,720
that sort of all clear

2060
01:02:46,820 --> 01:02:48,000
0,90 90,210 210,600
in your head.|
|

2061
01:02:48,000 --> 01:02:49,140
0,630

2062
01:02:51,430 --> 01:02:52,420
0,240 240,360 360,540 540,780 780,990
Are we, okay, so now
好的，现在我想切换到这张图片的左边，

2063
01:02:52,420 --> 01:02:53,230
0,120 120,240 240,300 300,690 690,810
I want to switch to

2064
01:02:53,230 --> 01:02:54,610
0,180 180,450 450,960 1020,1230 1230,1380
the left side of this

2065
01:02:54,610 --> 01:02:56,530
0,540 1020,1200 1200,1320 1320,1440 1440,1920
picture,| and this is basically
|这是 xv6 设置的虚拟地址空间，

2066
01:02:56,530 --> 01:02:57,820
0,360 360,540 540,690 690,1050 1050,1290
what {xv6 - -} sets

2067
01:02:57,820 --> 01:03:01,120
0,390 840,1680 1680,2310 2430,3060 3060,3300
up to the virtual address

2068
01:03:01,120 --> 01:03:02,110
0,300 300,450 450,600 600,750 750,990
space that {xv6 - -}

2069
01:03:02,110 --> 01:03:03,160
0,210 210,450 450,570 570,720 720,1050
sets up,| so when the
|当机器启动时，还没有页面，

2070
01:03:03,250 --> 01:03:06,220
0,510 510,1140 1380,1650 1650,2130 2430,2970
machine boots, there's no {page,enable}

2071
01:03:06,220 --> 01:03:08,350
0,420 540,1380 1380,1650 1650,1950 1950,2130
yet,| {} {xv6 -} sets
|xv6 设置第一个页表，第一个虚拟地址空间，

2072
01:03:08,350 --> 01:03:10,930
0,210 210,420 420,960 990,1950 1950,2580
up the first page tables

2073
01:03:11,110 --> 01:03:12,580
0,570 570,780 780,1200 1200,1290 1290,1470
{the,first,virtual} address space| and that's
|是内核使用的虚拟地址空间，我们过一会会在代码中看到，

2074
01:03:12,580 --> 01:03:13,570
0,240 240,300 300,600 600,780 780,990
actually the virtual address space,

2075
01:03:13,570 --> 01:03:14,710
0,150 150,480 480,840 840,990 990,1140
the kernel uses and we'll

2076
01:03:14,710 --> 01:03:15,280
0,180 180,270 270,390 390,480 480,570
look at it in the

2077
01:03:15,280 --> 01:03:16,080
0,360
second

2078
01:03:16,080 --> 01:03:17,700
0,120 120,210 210,690 1020,1290 1290,1620
at the code,| {} but,
|这是它的布局，

2079
01:03:17,850 --> 01:03:18,870
0,510 510,660 660,840 840,900 900,1020
{} and this is the

2080
01:03:18,870 --> 01:03:20,310
0,540 570,690 690,780 780,1050 1050,1440
layout| and it turns out
|因为我们想让 xv6 保持简单，容易理解，

2081
01:03:20,610 --> 01:03:21,990
0,570 570,720 720,840 840,1260 1260,1380
{} you know, because we

2082
01:03:21,990 --> 01:03:23,070
0,180 180,240 240,450 450,660 660,1080
want to keep xv6 as

2083
01:03:23,070 --> 01:03:24,660
0,480 480,600 600,1080 1080,1230 1260,1590
simple as possible, it's easy

2084
01:03:24,660 --> 01:03:26,220
0,120 120,240 240,330 330,990 1320,1560
for you to understand,| the
|所以虚拟到物理的映射主要是恒等映射。

2085
01:03:26,220 --> 01:03:28,400
0,660 660,930 930,1710
mapping from virtual

2086
01:03:28,570 --> 01:03:30,040
0,180 180,900
to physical

2087
01:03:30,780 --> 01:03:32,430
0,180 180,630 630,720 720,1170 1170,1650
is mostly in identity mapping.|
|

2088
01:03:38,120 --> 01:03:39,260
0,150 150,510 510,630 630,750 750,1140
So basically what that means
基本上它的意思是，虚拟地址 0x2000 映射到物理地址 0x2000 ，

2089
01:03:39,260 --> 01:03:41,180
0,210 210,660 840,1290 1290,1650 1650,1920
is that the virtual address

2090
01:03:41,180 --> 01:03:42,500
0,120 120,300 300,450 450,630 630,1320
{0x2000 - - - -}

2091
01:03:43,190 --> 01:03:44,990
0,780 780,870 870,1230 1230,1620 1620,1800
mapped to physical address {0x2000

2092
01:03:44,990 --> 01:03:46,190
0,150 150,330 330,540 540,780 780,1200
- - - - -},|
|

2093
01:03:46,280 --> 01:03:47,540
0,210 240,450 450,780 780,1050 1050,1260
so the kernel will set
内核使用这种方法设置页表，

2094
01:03:47,540 --> 01:03:49,010
0,120 120,210 210,450 450,840 840,1470
up the page tables exactly

2095
01:03:49,010 --> 01:03:50,180
0,90 90,270 270,600 870,1080 1080,1170
in that way,| and so
|这意味着，所有在 PHYSTOP 之下的虚拟地址，

2096
01:03:50,180 --> 01:03:51,800
0,180 180,450 450,840 840,1230 1500,1620
that means basically that you

2097
01:03:51,800 --> 01:03:54,200
0,180 180,510 510,900 900,1380 1380,2400
know all virtual addresses {below,PHYSTOP

2098
01:03:54,200 --> 01:03:55,260
0,630
-},|
|

2099
01:03:55,810 --> 01:03:56,680
0,180 180,390 390,510 510,600 600,870
{} which is the top
PHYSTOP 是对应于右边的物理地址的最高物理内存。

2100
01:03:56,680 --> 01:03:58,960
0,60 60,330 330,870 1020,1590 1590,2280
of physical memory are identical

2101
01:03:58,960 --> 01:04:00,100
0,120 120,210 210,540 540,960 960,1140
to the physical addresses that

2102
01:04:00,100 --> 01:04:01,930
0,150 150,420 420,630 630,1050 1050,1830
are actually being used on

2103
01:04:01,930 --> 01:04:03,140
0,90 90,330 330,690
the right side.|
|

2104
01:04:03,170 --> 01:04:04,040
0,150 150,270 270,450 450,510 510,870
And so this is why
这也是为什么这些箭头都是直的，因为是恒等映射。

2105
01:04:04,040 --> 01:04:05,510
0,210 210,330 330,780 780,930 930,1470
all the arrows are straight,

2106
01:04:05,510 --> 01:04:07,800
0,270 270,480 690,1320 1320,1710
because it's identity mapping.|
|

2107
01:04:09,290 --> 01:04:10,360
0,570
Okay?|
好的？|

2108
01:04:10,830 --> 01:04:12,780
0,240 240,390 420,1260 1260,1830 1830,1950
There are small changes to
这里有一些小的改变，有两个东西要说。

2109
01:04:12,780 --> 01:04:15,450
0,570 660,1440 1770,2190 2190,2340 2340,2670
this, { -} there two

2110
01:04:15,450 --> 01:04:17,220
0,510 510,690 690,780 780,1230
important things to mention.|
|

2111
01:04:17,620 --> 01:04:19,930
0,720 750,1170 1170,1410 1410,1920 2040,2310
{Amiar -} {hold,on,a} second {}.|
Amiar ，稍等一会。|

2112
01:04:19,930 --> 01:04:21,550
0,420 420,600 600,870 900,1350 1350,1620
{Well,I} try to first mention
我想先说一下两件重要的东西。

2113
01:04:21,550 --> 01:04:22,480
0,90 90,270 270,630 630,840 840,930
the two important things to

2114
01:04:22,480 --> 01:04:25,060
0,540 1020,1650 1680,2130 2130,2190 2190,2580
mention,| {} first of all,
|首先，有一些页面，一些映射在内存中位置非常高，

2115
01:04:25,090 --> 01:04:27,460
0,240 240,810 900,1680 1710,1980 1980,2370
there's some pages, some maps

2116
01:04:27,460 --> 01:04:28,870
0,330 330,600 600,780 780,930 930,1410
very high up in memory,

2117
01:04:29,840 --> 01:04:31,680
0,750 780,1020 1020,1320
{ - -}

2118
01:04:33,360 --> 01:04:34,560
0,270 270,540 540,750 750,960 960,1200
some pages very high in

2119
01:04:34,560 --> 01:04:37,590
0,480 510,810 840,1650 1710,2280 2310,3030
memory,| for example the stack,
|比如，内核栈位于内存的比较高的位置。

2120
01:04:37,740 --> 01:04:39,930
0,750 780,1230 1230,1620 1620,1890 1890,2190
{} kernel stack actually sets

2121
01:04:39,930 --> 01:04:41,190
0,240 270,540 540,780 780,1080 1080,1260
up, is also map high

2122
01:04:41,190 --> 01:04:42,500
0,180 180,270 270,840
up in memory.|
|

2123
01:04:42,500 --> 01:04:43,400
0,180 180,330 330,420 420,750 750,900
{} And the reason is
它在内存中很高的原因是，我们有一个没有映射的守护页在它下面。

2124
01:04:43,400 --> 01:04:44,390
0,180 180,360 360,450 450,870 870,990
high up in memory, is

2125
01:04:44,390 --> 01:04:45,560
0,330 330,480 480,690 690,750 750,1170
because we have a guard

2126
01:04:45,560 --> 01:04:46,610
0,270 270,600 600,750 750,930 930,1050
page below it, that is

2127
01:04:46,610 --> 01:04:47,840
0,300 300,720
not mapped.|
|

2128
01:04:47,840 --> 01:04:49,070
0,90 90,210 210,420 420,840 840,1230
So the {PTE -} entry
所以，内核栈下面的 PTE 条目没有设置有效位。

2129
01:04:49,070 --> 01:04:51,050
0,480 480,870 1260,1590 1590,1920 1920,1980
below the kernel stack, of

2130
01:04:51,050 --> 01:04:51,890
0,150 150,210 210,300 300,570 570,840
one of the kernel stack

2131
01:04:51,890 --> 01:04:53,270
0,270 270,600 600,840 840,1050 1050,1380
{[] -} does have not

2132
01:04:53,270 --> 01:04:54,770
0,510 540,900 900,1050 1050,1350 1350,1500
have {} it's valid bit

2133
01:04:54,770 --> 01:04:55,700
0,420
set.|
|

2134
01:04:55,700 --> 01:04:57,350
0,660 660,840 840,1080 1080,1530 1530,1650
And, {} so if you
所以，如果内核栈溢出，会导致页面错误，

2135
01:04:57,350 --> 01:04:58,820
0,450 450,600 600,990 990,1230 1230,1470
know the kernel runs off

2136
01:04:58,820 --> 01:05:00,620
0,150 150,600 780,1110 1110,1290 1290,1800
its stack and will result

2137
01:05:00,620 --> 01:05:02,060
0,150 150,240 240,510 510,930 1200,1440
in a page fault,| which
|这比乱改内核的其他内存要好，

2138
01:05:02,060 --> 01:05:04,040
0,90 90,390 390,570 570,1380 1410,1980
is better than basically scribbling

2139
01:05:04,040 --> 01:05:05,060
0,240 240,390 390,570 570,900 900,1020
over some other memory that

2140
01:05:05,060 --> 01:05:06,350
0,60 60,360 360,840 1020,1200 1200,1290
the kernel has,| you get
|你得到一个 panic ，你就知道栈出问题了。

2141
01:05:06,350 --> 01:05:07,580
0,90 90,510 510,870 870,1080 1080,1230
an immediate panic, you know

2142
01:05:07,580 --> 01:05:09,260
0,150 150,450 450,990 990,1290
that something's {bad,to,stack -}.|
|

2143
01:05:10,820 --> 01:05:11,540
0,120 120,360 360,450 450,600 600,720
Of course, we don't want
当然，我们不想浪费物理内存，所以我们把栈放地很高，

2144
01:05:11,540 --> 01:05:13,370
0,60 60,540 540,870 870,1380 1590,1830
to waste physical memory and

2145
01:05:13,370 --> 01:05:14,330
0,210 210,450 450,570 570,720 720,960
so when we do that

2146
01:05:14,330 --> 01:05:16,070
0,210 210,720 750,1350 1350,1440 1440,1740
by basically putting the stack

2147
01:05:16,070 --> 01:05:19,010
0,630 870,1590 1590,2370 2400,2820 2820,2940
high,| {} and {} a
|再放一个空的 PTE 守护页在它下面，

2148
01:05:19,010 --> 01:05:20,690
0,480 480,840 840,960 960,1290 1290,1680
guard page, an empty guard

2149
01:05:20,690 --> 01:05:22,600
0,480 480,810 810,1140 1140,1410
PTE entry below it,|
|

2150
01:05:22,600 --> 01:05:23,920
0,300 300,540 540,660 660,990 990,1320
{} and the guard {}
守护页不会真正消耗物理内存，

2151
01:05:23,920 --> 01:05:25,780
0,570 660,1050 1050,1230 1230,1680 1680,1860
page doesn't really consume any

2152
01:05:25,780 --> 01:05:27,220
0,270 270,690 690,990 990,1230 1230,1440
physical memory right,| sitting high
|位于虚拟地址空间的高位，所以没有东西消耗。

2153
01:05:27,220 --> 01:05:28,060
0,180 180,270 270,330 330,630 630,840
up in the virtual address

2154
01:05:28,060 --> 01:05:29,860
0,330 330,660 810,1500 1500,1620 1620,1800
space, so nothing is being

2155
01:05:29,860 --> 01:05:30,960
0,630
consumed.|
|

2156
01:05:31,190 --> 01:05:32,330
0,270 270,480 480,870 870,1050 1050,1140
But that means, that they're
但是，这也意味着栈页面映射了两次，

2157
01:05:32,330 --> 01:05:33,560
0,240 240,390 390,660 660,930 930,1230
showing this case, stack page,

2158
01:05:33,560 --> 01:05:34,970
0,60 60,420 420,540 540,810 810,1410
for example is mapped twice,|
|

2159
01:05:35,360 --> 01:05:36,260
0,180 180,510 510,600 600,660 660,900
it's mapped at a high
一次映射在高地址，一次直接映射在 PHYSTOP 下面的一个地址。

2160
01:05:36,260 --> 01:05:39,110
0,630 930,1320 1320,1560 1560,2280 2400,2850
address {and,it's} map directly by

2161
01:05:39,110 --> 01:05:40,160
0,300 300,390 390,480 480,900 900,1050
one of the addresses that

2162
01:05:40,160 --> 01:05:41,580
0,300 300,570 570,1020
below {PHYSTOP -}.|
|

2163
01:05:42,590 --> 01:05:43,400
0,210 210,390 390,540 540,630 630,810
And so you can do,
这是页表可以做的所有很酷的事情之一，

2164
01:05:43,400 --> 01:05:44,990
0,360 360,450 450,630 630,1380 1410,1590
this is one example of

2165
01:05:44,990 --> 01:05:46,370
0,180 180,300 300,510 510,690 870,1380
all the sort of cool

2166
01:05:46,370 --> 01:05:47,510
0,360 360,480 480,600 600,930 930,1140
things you can do with

2167
01:05:47,510 --> 01:05:48,830
0,270 270,720 720,900 900,1020 1020,1320
page tables,| you can map
|你可以映射两次物理地址，也可以不映射物理地址，

2168
01:05:48,830 --> 01:05:50,930
0,90 90,540 540,870 870,1470 1650,2100
a physical address twice, you

2169
01:05:50,930 --> 01:05:52,490
0,420 420,630 630,690 690,990 990,1560
cannot map a physical address,|
|

2170
01:05:52,610 --> 01:05:53,840
0,780 780,900 900,1020 1020,1110 1110,1230
{} you know it can
它可以是一对一映射，一对多映射，多对多映射，所有这些都可以。

2171
01:05:53,840 --> 01:05:54,860
0,90 90,390 390,450 450,690 690,1020
be one to one mapping,

2172
01:05:54,860 --> 01:05:56,030
0,180 180,300 300,540 540,900 900,1170
one to many mapping, many

2173
01:05:56,030 --> 01:05:57,350
0,60 60,330 330,780 870,1200 1200,1320
to one mapping, all that

2174
01:05:57,350 --> 01:05:58,340
0,120 120,180 180,360 360,480 480,990
kind of stuff is possible,|
|

2175
01:05:58,930 --> 01:06:00,760
0,300 300,660 660,840 840,1170 1170,1830
{} {xv6 -} does really,
xv6 在很多地方都用到了这些技巧，

2176
01:06:00,760 --> 01:06:01,720
0,270 270,480 480,630 630,810 810,960
use many of them, but

2177
01:06:01,720 --> 01:06:02,710
0,150 150,210 210,480 480,870 870,990
there's a couple places we

2178
01:06:02,710 --> 01:06:05,110
0,210 210,420 420,930 1140,1890 1920,2400
use those tricks| and stacking
|守护页是 xv6 使用的很酷的技巧之一，主要用来追踪 bug 。

2179
01:06:05,110 --> 01:06:06,070
0,60 60,300 300,510 510,570 570,960
the guard page is one

2180
01:06:06,070 --> 01:06:06,910
0,450 450,510 510,660 660,750 750,840
example of one of the

2181
01:06:06,910 --> 01:06:09,250
0,240 240,630 630,1320 1320,1800 1800,2340
cool trick that xv6 uses,

2182
01:06:09,280 --> 01:06:10,900
0,570 570,660 660,900 900,1140 1140,1620
mostly to track down bugs.|
|

2183
01:06:12,880 --> 01:06:13,660
0,120 120,360 360,510 510,570 570,780
The second thing I wanted
我想说的第二个东西是权限。

2184
01:06:13,660 --> 01:06:14,860
0,60 60,360 360,540 540,840 870,1200
to mention is that {}

2185
01:06:14,860 --> 01:06:16,220
0,150 150,870
the permissions.|
|

2186
01:06:16,590 --> 01:06:17,700
0,240 240,330 330,750 750,840 840,1110
So, for example the kernel
比如，内核文本页面映射位 R-X ，意思是可以读取和执行，

2187
01:06:17,700 --> 01:06:19,200
0,600 840,960 960,1320 1320,1410 1410,1500
text, the pages for the

2188
01:06:19,200 --> 01:06:20,670
0,240 240,540 540,660 660,1080 1110,1470
kernel text are mapped {R-X

2189
01:06:20,670 --> 01:06:22,410
0,180 180,690 750,1350 1440,1650 1650,1740
- -}, meaning you can

2190
01:06:22,410 --> 01:06:23,550
0,180 180,390 390,480 480,870 870,1140
read it and execute it,|
|

2191
01:06:23,760 --> 01:06:24,900
0,240 240,300 300,720 720,1080 1080,1140
but you cannot write to
但是你不能写入内核文本，这也是为了避免 bug ，让我们可以尽早捕获它们，

2192
01:06:24,900 --> 01:06:26,160
0,300 300,690 690,810 810,1110 1110,1260
kernel text and again this

2193
01:06:26,160 --> 01:06:28,260
0,90 90,480 480,1110 1260,1980 1980,2100
is basically avoid bugs, so

2194
01:06:28,260 --> 01:06:29,280
0,120 120,210 210,480 480,600 600,1020
that we catch them early,|
|

2195
01:06:29,430 --> 01:06:30,870
0,510 510,780 780,870 870,1230 1230,1440
kernel data of course needs
内核数据当然需要写入，所以它映射为 RW- ，

2196
01:06:30,870 --> 01:06:31,590
0,60 60,210 210,480 480,570 570,720
to be able to be

2197
01:06:31,590 --> 01:06:32,730
0,240 240,660 660,840 840,1020 1020,1140
written to and so it

2198
01:06:32,730 --> 01:06:34,710
0,360 360,690 690,870 870,1290 1500,1980
has mapped read write,| but
|但是你不能执行内核数据页指令，所以执行位没有设置。

2199
01:06:34,710 --> 01:06:37,080
0,120 120,540 540,1140 1410,2130 2130,2370
you cannot execute {} out

2200
01:06:37,080 --> 01:06:39,810
0,240 270,720 720,1140 1140,1830 1890,2730
of kernel data pages instructions,

2201
01:06:40,680 --> 01:06:41,910
0,480 480,600 600,720 720,1110 1110,1230
{} so the {execute,bit} is

2202
01:06:41,910 --> 01:06:43,040
0,240 240,570
not set.|
|

2203
01:06:45,950 --> 01:06:47,320
0,180 180,330 330,480 480,840
Does that make sense?|
这些能理解吗？|

2204
01:06:48,000 --> 01:06:49,500
0,180 180,870 900,1260 1260,1440 1440,1500
{} I skip one or
我跳过了一两个问题，如果还没有解决，现在可以问。

2205
01:06:49,500 --> 01:06:50,670
0,90 90,540 540,720 720,900 900,1170
two questions, so if these

2206
01:06:50,670 --> 01:06:51,900
0,360 360,420 420,600 600,870 870,1230
questions are still not answered,

2207
01:06:51,900 --> 01:06:53,400
0,150 150,420 420,690 690,990
{you,know} please ask them.|
|

2208
01:06:55,790 --> 01:06:56,510
0,150 150,240 240,300 300,630 630,720
We have a question in
我们在聊天窗口中有一个问题，

2209
01:06:56,510 --> 01:06:58,560
0,90 90,540 810,1500
the chat {},|
|

2210
01:06:58,620 --> 01:06:59,880
0,120 120,240 240,360 360,930 930,1260
do we have multiple kernel
我们是否有多个内核栈对于不同的进程，比如 n 个 kstack 对 n 个进程。

2211
01:06:59,880 --> 01:07:01,590
0,420 420,630 630,900 900,1560 1560,1710
stacks for different processes like

2212
01:07:01,590 --> 01:07:03,510
0,270 270,630 630,1350 1350,1560 1560,1920
we have {n,kstacks -} for

2213
01:07:03,540 --> 01:07:06,240
0,810
{n,processes}.|
|

2214
01:07:06,790 --> 01:07:08,560
0,300 300,690 690,1320 1320,1530 1530,1770
{The,answer,is,yes,so} every process every user
是的，每个用户进程有一个对应的内核栈，我们过一会会看到。

2215
01:07:08,560 --> 01:07:10,210
0,300 300,450 450,510 510,1350 1350,1650
process has a corresponding kernel

2216
01:07:10,210 --> 01:07:11,180
0,390
stack,

2217
01:07:13,130 --> 01:07:13,910
0,120 120,240 240,390 390,630 630,780
{} we'll see that in

2218
01:07:13,910 --> 01:07:15,260
0,120 120,300 300,390 390,810
a little bit later.|
|

2219
01:07:17,350 --> 01:07:18,380
0,630
Okay?|
好的？|

2220
01:07:19,160 --> 01:07:21,290
0,390 390,510 510,630 630,1230 1500,2130
Okay, so let me {}.|
好的，让我。|

2221
01:07:21,320 --> 01:07:22,250
0,180 180,330 330,480 480,600 600,930
{Amair -}, {} go ahead.|
Amair ，继续。|

2222
01:07:24,010 --> 01:07:26,080
0,270 270,750 900,1110 1110,1620 1620,2070
So what's the virtual memory
所以，其他应用程序的虚拟内存映射在没有使用的物理内存上，还是。

2223
01:07:26,080 --> 01:07:28,740
0,180 180,900 1020,2040
of another application

2224
01:07:28,740 --> 01:07:29,730
0,330 330,420 420,780 780,870 870,990
map to somewhere in the

2225
01:07:29,730 --> 01:07:31,140
0,390 390,780 780,870 870,990 990,1410
physical memory in the unused

2226
01:07:31,140 --> 01:07:33,600
0,540 540,990 1290,1830
space or.| Yes,
|是的，很好的观点，这里有很多虚拟内存，

2227
01:07:33,600 --> 01:07:34,890
0,270 270,510 510,630 630,1020 1020,1290
{} very good points, so

2228
01:07:34,890 --> 01:07:36,960
0,450 480,1140 1500,1770 1770,1830 1830,2070
there's a bunch of physical

2229
01:07:36,960 --> 01:07:38,430
0,270 270,510 510,750 750,960 960,1470
memory, correct,| here's free memory,
|这里是空闲内存，这里也是空闲内存，

2230
01:07:39,340 --> 01:07:41,260
0,750 780,1020 1020,1380 1380,1560 1560,1920
{ -} that's free memory

2231
01:07:41,260 --> 01:07:43,450
0,180 180,510 540,930 1350,1710 1710,2190
here too, right,| {} and
|xv6 使用这些空闲内存保存页表和用户进程的页面，

2232
01:07:43,450 --> 01:07:44,830
0,300 300,480 480,630 630,1140 1140,1380
{} we use that, xv6

2233
01:07:44,830 --> 01:07:46,330
0,480 480,690 690,870 870,1290 1290,1500
use that free memory to

2234
01:07:46,330 --> 01:07:48,310
0,390 390,690 690,1290 1290,1710 1710,1980
basically store pages of page

2235
01:07:48,310 --> 01:07:50,800
0,480 480,990 990,1740 1890,2190 2190,2490
tables, user processes| as well
|还有用户进程的文本和数据。

2236
01:07:50,800 --> 01:07:52,570
0,240 240,390 390,600 600,1200 1350,1770
as you know the text

2237
01:07:52,570 --> 01:07:53,830
0,210 210,510 510,870 870,1050 1050,1260
and data of user level

2238
01:07:53,830 --> 01:07:54,920
0,720
processes.|
|

2239
01:07:55,780 --> 01:07:56,500
0,300 300,420 420,510 510,600 600,720
And if we are on
如果某个时刻我们有很多用户程序，

2240
01:07:56,500 --> 01:07:58,000
0,180 180,390 390,570 570,990 990,1500
many many, many user processes

2241
01:07:58,000 --> 01:07:58,780
0,90 90,240 240,480 480,630 630,780
at some point,| we'll run
|会出现内存溢出，然后 fork 或 exec 会返回错误。

2242
01:07:58,780 --> 01:07:59,860
0,150 150,240 240,390 390,900 900,1080
out of free memory, and

2243
01:07:59,860 --> 01:08:01,540
0,120 120,510 510,1020 1050,1260 1260,1680
then basically fork or exec

2244
01:08:01,540 --> 01:08:03,640
0,150 150,840 990,1110 1110,1500
will return an error.|
|

2245
01:08:04,900 --> 01:08:05,770
0,240 240,420 420,600 600,780 780,870
But that means that the
但是，这意味着（用户）进程的的虚拟空间比内核的虚拟空间小得多，是吗？

2246
01:08:05,770 --> 01:08:08,620
0,540 540,1020 1020,1560 2100,2700 2700,2850
virtual space for process are

2247
01:08:08,620 --> 01:08:09,850
0,210 210,570 570,720 720,840 840,1230
much smaller than the virtual

2248
01:08:09,850 --> 01:08:11,890
0,420 420,810 1140,1260 1260,1740 1770,2040
space for the kernel, right?|
|

2249
01:08:12,540 --> 01:08:14,010
0,240 240,330 330,600 600,1020 1020,1470
Well, the virtual spaces as
理论上，虚拟空间大小是一样的，但是它会[占用]更少。

2250
01:08:14,010 --> 01:08:15,510
0,90 90,390 390,840 840,930 930,1500
the same as the same

2251
01:08:15,960 --> 01:08:17,400
0,540 540,630 630,1200 1200,1350 1350,1440
size in principle, but it

2252
01:08:17,400 --> 01:08:19,600
0,120 120,270 270,510 510,1260
will be less [populated].|
|

2253
01:08:20,230 --> 01:08:21,560
0,690

2254
01:08:22,520 --> 01:08:24,110
0,300 300,420 420,810 810,990 990,1590
Then let me, let's look
让我们看看代码，我想所有这些东西会变得更清楚。

2255
01:08:24,110 --> 01:08:24,770
0,90 90,180 180,450 450,570 570,660
at some code and I

2256
01:08:24,770 --> 01:08:25,430
0,120 120,240 240,360 360,510 510,660
think that all this stuff

2257
01:08:25,430 --> 01:08:26,480
0,270 270,300 300,510 510,600 600,1050
becomes a bit more clear.|
|

2258
01:08:27,690 --> 01:08:29,250
0,540 540,780 780,960 960,1230 1230,1560
I just want small thing
我有一个小问题，

2259
01:08:29,280 --> 01:08:32,040
0,690 1290,1740 1740,1950 1950,2310 2310,2760
{} is,| so given that
|有很多进程，让每个进程一大部分内存映射到相同位置，

2260
01:08:32,070 --> 01:08:33,600
0,600 690,900 900,1170 1170,1320 1320,1530
{} a lot of the

2261
01:08:33,630 --> 01:08:35,010
0,300 390,690 690,1110 1110,1290 1290,1380
like, each process has a

2262
01:08:35,010 --> 01:08:36,450
0,240 240,600 600,810 810,1050 1050,1440
big part of the memory

2263
01:08:36,450 --> 01:08:38,040
0,390 390,510 510,630 630,900 900,1590
map to the same location,|
|

2264
01:08:38,130 --> 01:08:40,410
0,390 390,720 720,1500 1500,1680 1680,2280
is that optimized by like
是否把这些映射合并在一起是一种优化。

2265
01:08:40,560 --> 01:08:42,720
0,1050 1050,1320 1320,1500 1500,1740 1740,2160
consolidating that into one place

2266
01:08:42,720 --> 01:08:44,550
0,210 210,660 660,840 840,1170 1560,1830
that mapping or no {}.|
|

2267
01:08:44,580 --> 01:08:46,800
0,810 870,1470 1470,1740 1740,1980 1980,2220
Good, {xv6 -} does not
好的， xv6 没有做这个，

2268
01:08:46,800 --> 01:08:48,450
0,120 120,480 570,1230 1260,1500 1500,1650
do that,| {} like one
|在页表实验练习中的一个挑战就是实现这个。

2269
01:08:48,450 --> 01:08:49,920
0,90 90,180 180,540 540,1290 1290,1470
of the challenge exercises in

2270
01:08:49,920 --> 01:08:51,360
0,570 600,780 780,1110 1110,1290 1290,1440
the page table lab is

2271
01:08:51,360 --> 01:08:52,740
0,180 180,450 450,780 780,1020
to actually implement that.|
|

2272
01:08:54,540 --> 01:08:55,890
0,150 150,480 630,870 870,1080 1080,1350
I see.| The real operating
我知道了。|真正的操作系统会做这个，是的，好问题。

2273
01:08:55,890 --> 01:08:57,240
0,240 240,330 330,450 450,750
system would do that,

2274
01:08:58,710 --> 01:09:01,560
0,1170 1530,1800 1800,1890 1890,2310
yeah, very good question.|
|

2275
01:09:02,320 --> 01:09:02,980
0,210 210,360 360,450 450,600 600,660
I think you get a
我想你知道了，有了页表，任何事情都是可能的。

2276
01:09:02,980 --> 01:09:03,970
0,240 240,330 330,630 630,810 810,990
sense of, well all kinds

2277
01:09:03,970 --> 01:09:04,990
0,60 60,270 270,330 330,810 810,1020
of things are possible, once

2278
01:09:04,990 --> 01:09:06,440
0,90 90,210 210,450 450,960
you have page tables.|
|

2279
01:09:08,800 --> 01:09:10,450
0,930 990,1200 1200,1440 1440,1560 1560,1650
Okay, so let's do the
好的，我们开始平常的事情，再次启动 xv6 ，

2280
01:09:10,450 --> 01:09:12,720
0,300 300,720 1050,1710
usual thing, {}

2281
01:09:12,720 --> 01:09:14,850
0,510 600,1350 1350,1620 1620,1830 1830,2130
boot {} {xv6 -} again,|
|

2282
01:09:14,850 --> 01:09:15,810
0,90 90,480 510,570 570,720 720,960
and again you know QEMU
你知道 QEMU 用来模拟那个电路板，让我们。

2283
01:09:15,810 --> 01:09:17,460
0,360 360,720 720,1110 1110,1170 1170,1650
uses basically implementing the board,

2284
01:09:18,190 --> 01:09:20,980
0,900 1080,1860 2040,2190 2190,2340 2340,2790
{} and you know let's.|
|

2285
01:09:21,670 --> 01:09:22,280
0,540
Oops,
糟糕， -gdb 。

2286
01:09:26,750 --> 01:09:28,540
0,210 210,300 300,480 480,1050
{-gdb - - -}.|
|

2287
01:09:29,930 --> 01:09:31,880
0,360 360,660 660,1260 1290,1620 1620,1950
Last time, we looked at
上次，我们看了启动是什么样的，

2288
01:09:31,880 --> 01:09:33,710
0,750 750,840 840,1110 1110,1530 1530,1830
how the booting happens correct|
|

2289
01:09:33,710 --> 01:09:34,310
0,120 120,240 240,330 330,540 540,600
and then we got to
然后到了 main ，然后是内核的一个函数 kvminit ，它设置了内核地址空间。

2290
01:09:34,310 --> 01:09:35,510
0,510 510,600 600,690 690,1020 1020,1200
main and then basically one

2291
01:09:35,510 --> 01:09:36,800
0,60 60,150 150,420 420,780 780,1290
of the things that {

2292
01:09:37,280 --> 01:09:40,310
0,420 420,540 540,1380 1380,1860 2790,3030
-} the kernel, where one

2293
01:09:40,310 --> 01:09:41,390
0,60 60,120 120,420 420,540 540,1080
of the function is called

2294
01:09:41,390 --> 01:09:42,290
0,180 180,450 450,630 630,810 810,900
{kvminit - - -} and

2295
01:09:42,290 --> 01:09:43,070
0,150 150,390 390,600 600,690 690,780
that actually sets up the

2296
01:09:43,070 --> 01:09:44,600
0,270 270,750 900,1050 1050,1110 1110,1530
address space for the kernel.|
|

2297
01:09:45,100 --> 01:09:46,240
0,360 360,510 510,630 630,960 960,1140
And so we saw in
我们在上一张幻灯片的图片中看到它的样子，

2298
01:09:46,240 --> 01:09:47,170
0,90 90,600 600,810 810,870 870,930
the picture where in the

2299
01:09:47,170 --> 01:09:48,370
0,270 270,570 570,720 720,960 990,1200
previous slide, what that you

2300
01:09:48,370 --> 01:09:49,780
0,270 300,630 630,960 960,1260 1260,1410
know looks like| and here
|这里我们看 C 代码，它实际是如何设置的。

2301
01:09:49,780 --> 01:09:51,340
0,90 90,420 420,1020 1020,1410 1410,1560
we go, {see,C} code how

2302
01:09:51,340 --> 01:09:52,150
0,90 90,330 330,390 390,570 570,810
it actually is being set

2303
01:09:52,150 --> 01:09:52,860
0,240
up.|
|

2304
01:09:58,380 --> 01:10:01,500
0,690 840,1830 1860,2100 2100,2340 2700,3120
And, why, hold on, something's
为什么，稍等一下，有些东西不像我想那样。

2305
01:10:01,500 --> 01:10:03,240
0,210 210,600 1020,1260 1260,1410 1410,1740
not going as I wanted

2306
01:10:03,240 --> 01:10:04,260
0,510
to.|
|

2307
01:10:04,350 --> 01:10:07,380
0,1290 1290,2370
{Am,I,in,the,right} directories.|
我在对的目录吗。|

2308
01:10:11,120 --> 01:10:12,110
0,240 240,330 330,330 330,690 690,990
Hold on a second here
稍等一会，我来解决一下这个问题。

2309
01:10:12,110 --> 01:10:13,190
0,270 270,420 420,690 690,750 750,1080
while I'm trying to sort

2310
01:10:13,190 --> 01:10:14,960
0,120 120,300 300,1020
out my problems.|
|

2311
01:10:16,590 --> 01:10:18,260
0,300 300,450 450,1020
That is good,
这是好的，我是说在对的目录。

2312
01:10:21,380 --> 01:10:23,390
0,150 150,510 510,630 630,960 960,2010
I mean the right directories.|
|

2313
01:10:23,420 --> 01:10:27,160
0,810 1230,1710 2010,3030
Yeah, -gnu -gdb.|
是的， -gnu-gdb 。|

2314
01:10:28,080 --> 01:10:29,070
0,390 390,600 600,630 630,870 870,990
{I,want} set a breakpoint for
我在 main 设置一个断点来验证，好的，然后我在 kvminit 设置一个断点。

2315
01:10:29,070 --> 01:10:29,940
0,90 90,390 390,600 600,660 660,870
the main just to make

2316
01:10:29,940 --> 01:10:32,400
0,450 1110,1530 1560,1800 1800,2040 2040,2460
sure, good and then {I,set,a}

2317
01:10:32,400 --> 01:10:35,010
0,240 240,570 570,1140 1380,1950 1950,2610
{breakpoint -} at {kvminit -

2318
01:10:35,010 --> 01:10:36,280
0,240 240,630
- -}.|
|

2319
01:10:36,340 --> 01:10:37,210
0,240 240,330 330,450 450,630 630,870
Actually I can just step
我现在可以单步运行到那里，

2320
01:10:37,210 --> 01:10:38,400
0,90 90,210 210,630
to it now,|
|

2321
01:10:38,430 --> 01:10:40,710
0,960 1140,1590 1590,1710 1710,2070 2070,2280
next {consoleinit - -}, {printfinit
下一个 consoleinit printfinit ，我们之前看到过。

2322
01:10:40,710 --> 01:10:41,760
0,330 330,510 510,780 780,990 990,1050
-}, {we -} saw it

2323
01:10:41,760 --> 01:10:43,100
0,720
before,|
|

2324
01:10:43,250 --> 01:10:45,640
0,480 480,780 780,1050 1050,1830
{} physical memory allocator,|
物理内存分配器，|

2325
01:10:47,040 --> 01:10:48,380
0,750
and,
发生了我不希望发生的事，怎么回事。

2326
01:10:51,110 --> 01:10:52,520
0,270 270,630 630,1050 1050,1230 1230,1410
{you,know} something happens that I

2327
01:10:52,520 --> 01:10:55,440
0,210 210,450 450,1020
am not expecting,

2328
01:10:57,590 --> 01:10:59,960
0,540 540,870 870,1200 1200,1530
what is going on.|
|

2329
01:11:02,660 --> 01:11:04,610
0,420 420,570 570,900 900,1290 1290,1950
{We're,run} is right before lecture.|
在上课之前是好的。|

2330
01:11:04,610 --> 01:11:05,660
0,270 270,480 480,630 630,840 840,1050
{Ah,here}, that's what's going on,
这里，应该这样，输出（这些东西），好的，有意思。

2331
01:11:05,660 --> 01:11:08,560
0,300 300,810 1020,1860 1860,2310
actually printing, {} okay,

2332
01:11:08,710 --> 01:11:09,960
0,690
{}

2333
01:11:10,630 --> 01:11:12,460
0,510 990,1170 1170,1350 1350,1440 1440,1830
interesting.| Okay, one more time,
|好的，再一次看看我是不是更幸运，糟糕。

2334
01:11:12,460 --> 01:11:13,750
0,180 180,330 330,390 390,750 750,1290
see if I can get

2335
01:11:14,290 --> 01:11:16,200
0,570 570,870 870,1290
lucky more, oops.|
|

2336
01:11:19,280 --> 01:11:21,300
0,450 450,1080
{[] -}.|
[].|

2337
01:11:28,890 --> 01:11:31,440
0,840 840,1350 1350,1500 1500,2040 2310,2550
Continue, hopefully it will get
继续，希望能运行到那里，稍等一下。

2338
01:11:31,440 --> 01:11:32,460
0,450
there,

2339
01:11:33,010 --> 01:11:33,880
0,330 330,390 390,540 540,660 660,870
wait a little bit.| Okay,
|好的，我们到了 kvminit ，

2340
01:11:33,880 --> 01:11:35,140
0,330 330,540 540,630 630,900 930,1260
great, we're at the {kvminit

2341
01:11:35,140 --> 01:11:36,850
0,390 720,930 930,1320 1320,1500 1500,1710
-},| so basically we're now
|我们现在在这个函数里，你可以在右边的 emacs 缓存中看到。

2342
01:11:36,850 --> 01:11:38,650
0,210 210,540 540,1020 1140,1530 1530,1800
this function here, on the

2343
01:11:38,650 --> 01:11:39,700
0,240 240,480 480,570 570,690 690,1050
right side in the emacs

2344
01:11:39,700 --> 01:11:40,660
0,300 300,450 450,540 540,690 690,960
buffer, you can see it.|
|

2345
01:11:41,260 --> 01:11:43,400
0,690 870,1530
{} And,
我想我已经稍微修改了这个函数，希望我改过了。

2346
01:11:44,220 --> 01:11:46,050
0,750 810,1200 1200,1290 1290,1770 1770,1830
I think I've modified the

2347
01:11:46,050 --> 01:11:48,180
0,300 300,1020 1050,1650 1680,2100 2100,2130
function slightly, I hope I

2348
01:11:48,180 --> 01:11:49,160
0,360
did.|
|

2349
01:11:49,190 --> 01:11:50,680
0,900

2350
01:11:53,140 --> 01:11:54,400
0,210 210,390 390,450 450,630 630,1260
I think I did, {well,we'll,see}
我想我改过了，好的，一会会看到，

2351
01:11:54,670 --> 01:11:57,190
0,780 1230,1740 1740,1950 1950,2220 2220,2520
{},| and {what,we} knew is
|我们要做的是单步执行这个函数，

2352
01:11:57,190 --> 01:11:58,660
0,360 360,420 420,930 960,1290 1290,1470
going to walk step into

2353
01:11:58,660 --> 01:11:59,900
0,120 120,690
the function,|
|

2354
01:12:00,070 --> 01:12:01,990
0,630 630,900 900,1110 1110,1500 1500,1920
{} use the layout split,
使用分隔布局，更容易观察。

2355
01:12:01,990 --> 01:12:03,620
0,300 300,510 510,600 600,1080
just eaiser to see.|
|

2356
01:12:03,650 --> 01:12:04,460
0,300 300,450 450,510 510,570 570,810
And this is the first
首先，内核为顶级页面目录分配了一个物理页面，

2357
01:12:04,460 --> 01:12:05,180
0,180 180,330 330,450 450,540 540,720
thing that you can see

2358
01:12:05,180 --> 01:12:06,200
0,120 120,420 420,480 480,750 750,1020
is actually the kernel actually

2359
01:12:06,200 --> 01:12:07,670
0,390 390,450 450,750 750,1230 1230,1470
allocates a physical page for

2360
01:12:07,670 --> 01:12:09,200
0,210 240,540 540,810 810,1020 1020,1530
the top level page directory,|
|

2361
01:12:10,090 --> 01:12:12,100
0,360 360,840 870,1200 1200,1560 1560,2010
and then {} it zeroes
然后将其置零，所以所有 PTE 条目都是零。

2362
01:12:12,100 --> 01:12:13,180
0,150 150,570 600,780 780,930 930,1080
it out, so that all

2363
01:12:13,180 --> 01:12:14,560
0,90 90,510 510,840 840,900 900,1380
the PTE entries are zero.|
|

2364
01:12:15,360 --> 01:12:16,830
0,120 120,360 360,750 750,1080 1080,1470
And then basically starts mapping
然后映射每个 IO 设备，一个接一个。

2365
01:12:16,830 --> 01:12:19,950
0,450 660,1410 1500,2190 2190,2760 2760,3120
in every {} device, IO

2366
01:12:19,950 --> 01:12:21,600
0,360 360,570 570,690 690,1050
device one by one.|
|

2367
01:12:21,630 --> 01:12:22,830
0,330 330,480 480,570 570,1110 1110,1200
And so, for example the
比如， UART0 映射到内核地址空间，

2368
01:12:22,830 --> 01:12:25,050
0,360 360,990 1020,1500 1500,1770 1770,2220
{UART0 -} basically starts mapping

2369
01:12:25,050 --> 01:12:27,000
0,390 390,540 540,780 780,930 1230,1950
maps that into the kernel

2370
01:12:27,060 --> 01:12:28,770
0,510 510,900 900,1110 1110,1440 1500,1710
address space| and so we
|我们可以看一下 memlayout.h 文件，

2371
01:12:28,770 --> 01:12:29,940
0,120 120,300 300,570 690,870 870,1170
can look at a file

2372
01:12:29,940 --> 01:12:32,160
0,180 180,390 390,990 1380,1530 1530,2220
called {memlayout -},| is basically
|它将那个文档中的第 31 页转换成很多我们要用的常量。

2373
01:12:32,190 --> 01:12:34,140
0,660 660,780 780,1050 1050,1800 1800,1950
translate the page 31 that

2374
01:12:34,140 --> 01:12:34,980
0,90 90,450 450,630 630,780 780,840
I showed you from the

2375
01:12:34,980 --> 01:12:36,210
0,600 600,870 870,930 930,1140 1140,1230
documents into a bunch of

2376
01:12:36,210 --> 01:12:37,820
0,480 480,630 630,750 750,1140
constants that we're using.|
|

2377
01:12:38,020 --> 01:12:38,920
0,150 150,240 240,300 300,660 660,900
And so, for example here
比如，这里有地址 0x1000 是 URAT0 的地址。

2378
01:12:38,920 --> 01:12:39,910
0,90 90,360 360,570 570,660 660,990
it says what the address

2379
01:12:39,910 --> 01:12:41,710
0,120 120,480 1200,1350 1350,1560 1560,1800
of {} {0x1000 - -

2380
01:12:41,710 --> 01:12:43,080
0,180 180,510 510,870
- -} is,

2381
01:12:44,070 --> 01:12:46,080
0,930 1350,1500 1500,1770 1770,1860 1860,2010
{ -} what the UART0

2382
01:12:46,080 --> 01:12:47,140
0,570
address.|
|

2383
01:12:47,140 --> 01:12:48,610
0,180 180,810 810,1260 1290,1350 1350,1470
And so, {} you know
我们可以把它映射到地址空间，通过调用 kvmmap 函数，稍后会看到。

2384
01:12:48,610 --> 01:12:51,040
0,120 120,420 420,1170 1440,2340 2340,2430
we can basically map it

2385
01:12:51,040 --> 01:12:52,270
0,330 330,420 420,690 690,1050 1050,1230
into the address space by

2386
01:12:52,270 --> 01:12:53,740
0,330 330,480 480,930 930,1200 1200,1470
calling this function {kvmmap -

2387
01:12:53,740 --> 01:12:54,550
0,270 270,450 450,510 510,630 630,810
-} which I will look

2388
01:12:54,550 --> 01:12:55,800
0,120 120,210 210,750
in a second.|
|

2389
01:12:56,040 --> 01:12:58,290
0,240 240,780 960,1650 1890,2100 2100,2250
And then, {} in the
在页表实验的第一个练习中，要求你们实现一个 vmprint 函数，

2390
01:12:58,290 --> 01:13:00,660
0,480 570,1380 1380,1830 2100,2160 2160,2370
first exercise of the page

2391
01:13:00,660 --> 01:13:01,890
0,330 330,600 600,750 750,900 900,1230
table lab, you are asked

2392
01:13:01,890 --> 01:13:03,120
0,270 270,750 750,810 810,1080 1080,1230
to implement a function called

2393
01:13:03,120 --> 01:13:04,320
0,240 240,690
{vmprint -},|
|

2394
01:13:04,320 --> 01:13:05,940
0,270 270,480 480,630 660,1560 1560,1620
{} and I implemented it
我也实现了它，我会单步跳过它，

2395
01:13:05,940 --> 01:13:07,260
0,450 450,960 960,1080 1080,1260 1260,1320
too and I'm going to

2396
01:13:07,260 --> 01:13:08,220
0,270 270,630 630,750 750,840 840,960
step over it| and we'll
|我们会看到内核页表在调用 kvmmap 之后是如何设置的，

2397
01:13:08,220 --> 01:13:10,710
0,360 360,1080 1500,1560 1560,2130 2160,2490
see basically {} a page

2398
01:13:10,710 --> 01:13:11,900
0,750
tables,

2399
01:13:11,960 --> 01:13:13,670
0,540 630,1050 1050,1260 1260,1530 1530,1710
{} kernel page table as

2400
01:13:13,670 --> 01:13:14,720
0,120 120,210 210,450 450,720 720,1050
it is set up after

2401
01:13:14,720 --> 01:13:16,370
0,180 180,630 630,1080 1080,1200 1200,1650
that one call to {kvmmap

2402
01:13:16,370 --> 01:13:17,300
0,330 360,540 540,660 660,810 810,930
-},| so I'm gonna do
|我会单步执行，将会打印一些东西。

2403
01:13:17,300 --> 01:13:18,320
0,390
that,

2404
01:13:18,320 --> 01:13:18,980
0,90 90,210 210,330 330,390 390,660
and {} going to print

2405
01:13:18,980 --> 01:13:20,120
0,150 150,540
out something.|
|

2406
01:13:20,240 --> 01:13:20,750
0,180 180,270 270,330 330,450 450,510
And so we're going to
我们来看看这些输出，

2407
01:13:20,750 --> 01:13:21,380
0,150 150,240 240,420 420,540 540,630
look a little bit of

2408
01:13:21,380 --> 01:13:22,670
0,120 120,420 420,780 780,1020 1020,1290
the output here,| so here's
|这是页表，这个是顶级页面目录的物理地址，

2409
01:13:22,670 --> 01:13:23,510
0,60 60,300 300,570 570,750 750,840
the page table that is

2410
01:13:23,510 --> 01:13:24,480
0,330
the

2411
01:13:24,770 --> 01:13:27,050
0,480 480,1140 1530,1800 1800,1920 1920,2280
physical address of the top

2412
01:13:27,050 --> 01:13:30,290
0,690 990,2190 2430,2700 2700,3150 3150,3240
level {} page directory,| so
|就是位于 satp 的东西。

2413
01:13:30,290 --> 01:13:31,220
0,120 120,300 300,450 450,690 690,930
the thing that actually sits

2414
01:13:31,220 --> 01:13:32,660
0,150 150,300 300,780 780,990 990,1440
in {satp -}, or will

2415
01:13:32,660 --> 01:13:34,240
0,240 240,360 360,510 510,1110
sit in {satp -}.|
|

2416
01:13:34,600 --> 01:13:36,850
0,120 120,870 870,990 990,1650 2010,2250
And then we have a
我们有一个顶级页面目录的条目 0 ，

2417
01:13:36,850 --> 01:13:38,140
0,330 330,900 900,990 990,1050 1050,1290
entry zero of the top

2418
01:13:38,140 --> 01:13:39,880
0,210 210,450 450,750 750,990 990,1740
level page directory,| has one
|它里面也有一个 PTE 条目，包含着中级页表目录的物理地址，

2419
01:13:40,030 --> 01:13:42,200
0,900 900,1260 1260,1380 1380,1650
PTE entry in it,

2420
01:13:42,480 --> 01:13:44,970
0,630 630,1290 1320,1800 1800,2160 2160,2490
{} and that is the,

2421
01:13:44,970 --> 01:13:46,290
0,330 330,390 390,690 690,1050 1050,1320
contains the physical address for

2422
01:13:46,290 --> 01:13:47,460
0,150 150,420 420,690 690,900 900,1170
the middle level page table

2423
01:13:47,460 --> 01:13:48,520
0,540
directory,|
|

2424
01:13:48,580 --> 01:13:49,960
0,150 150,390 390,660 660,960 960,1380
the middle page level directory
中级页面目录包含一个条目 128 ，指向底部页表目录，

2425
01:13:49,960 --> 01:13:51,880
0,210 210,480 480,1050 1140,1710 1710,1920
has one entry namely {128

2426
01:13:51,880 --> 01:13:53,440
0,330 330,720 1020,1140 1140,1260 1260,1560
- -} and that points

2427
01:13:53,440 --> 01:13:54,070
0,90 90,180 180,510 510,570 570,630
to the bottom of the

2428
01:13:54,070 --> 01:13:55,360
0,180 180,540 540,1110 1110,1230 1230,1290
page table directory| and the
|而底部页表目录包含指向物理地址的条目。

2429
01:13:55,360 --> 01:13:56,680
0,300 300,510 510,780 780,1170 1170,1320
bottom page table directory has

2430
01:13:56,680 --> 01:13:57,730
0,90 90,360 360,600 600,780 780,1050
the entry then for the

2431
01:13:57,940 --> 01:13:59,360
0,390 390,960
physical page.|
|

2432
01:13:59,420 --> 01:14:00,530
0,300 300,390 390,480 480,690 690,1110
And you can see, indeed
可以看到，实际上这个物理地址是 0x1000 对应着 UART0 。

2433
01:14:00,530 --> 01:14:02,210
0,210 210,450 480,810 810,1470 1560,1680
that the physical address, you

2434
01:14:02,210 --> 01:14:03,530
0,120 120,240 240,540 570,1020 1020,1320
know for that bottom level

2435
01:14:03,530 --> 01:14:05,360
0,420 420,780 780,1350 1350,1590 1590,1830
is {0x1000 - - -

2436
01:14:05,360 --> 01:14:06,950
0,210 210,660 660,1320 1320,1410 1410,1590
- -} corresponding to {UART0

2437
01:14:06,950 --> 01:14:07,920
0,90 90,480
- -}.|
|

2438
01:14:08,900 --> 01:14:11,420
0,240 240,930 960,1470 1470,2010
So basically virtual address
所以，虚拟地址 1000 转换位物理地址 1000 。

2439
01:14:11,480 --> 01:14:13,310
0,360 360,570 570,810 810,1260 1260,1830
{1000 - - -} translates

2440
01:14:13,310 --> 01:14:14,630
0,210 210,600 600,900 900,1140 1140,1320
to physical address {[1000] -

2441
01:14:14,630 --> 01:14:16,160
0,180 180,540 540,990
- - -}.|
|

2442
01:14:16,560 --> 01:14:18,420
0,450 870,1110 1110,1350 1350,1620 1620,1860
And we can check double
我们可以确认一下所有都是正确的，

2443
01:14:18,420 --> 01:14:19,590
0,210 210,300 300,450 450,540 540,1170
check that this is {}

2444
01:14:19,590 --> 01:14:21,930
0,360 360,540 540,1080 1260,1680 1680,2340
indeed all legit, right,| by,
|我们用这个地址 0x10000000L ，对它右移 12 位，

2445
01:14:22,230 --> 01:14:24,330
0,540 540,870 870,1200 1200,1380 1380,2100
{} let's take that address,

2446
01:14:26,670 --> 01:14:28,350
0,360 360,960 960,1200 1200,1410 1410,1680
that {0x10000000L - - -

2447
01:14:28,350 --> 01:14:29,700
0,510 510,960 990,1170 1170,1230 1230,1350
- -} and we're going

2448
01:14:29,700 --> 01:14:31,400
0,90 90,300 300,390 390,1020
to {shift -} 12,|
|

2449
01:14:31,700 --> 01:14:33,740
0,720 870,1050 1050,1290 1290,1410 1410,2040
{} and that should be,
得到高位的 27 位，

2450
01:14:33,770 --> 01:14:35,660
0,900 1380,1500 1500,1590 1590,1710 1710,1890
{} you know that gives

2451
01:14:35,660 --> 01:14:37,700
0,120 120,240 240,570 570,840 840,2040
{} the top level {27,bits

2452
01:14:37,700 --> 01:14:38,920
0,720
-},|
|

2453
01:14:39,070 --> 01:14:41,110
0,150 150,510 510,1200 1590,1860 1860,2040
we shift 9, {} so
再右移 9 位，我用 0x10000 ，右移 9 位，并打印，

2454
01:14:41,110 --> 01:14:42,070
0,150 150,300 300,600 600,600 600,960
I'm gonna take {0x10000 -

2455
01:14:42,070 --> 01:14:43,720
0,180 180,450 450,1110
- - -}

2456
01:14:43,990 --> 01:14:45,850
0,210 210,780 780,1140 1140,1440 1440,1860
{} one zero zero zero,

2457
01:14:45,850 --> 01:14:48,250
0,570 570,900 900,1200 1200,1710 1860,2400
one zero, one more and

2458
01:14:48,250 --> 01:14:49,300
0,60 60,210 210,450 450,540 540,1050
we're gonna shift {} 9,

2459
01:14:49,880 --> 01:14:51,280
0,330 330,810
print that,|
|

2460
01:14:53,010 --> 01:14:54,540
0,360 360,600 600,720 720,1020 1020,1530
and that is {0x80 -}
结果是 0x80 ，按十进制打印 0x80 ，就是 128 。

2461
01:14:54,630 --> 01:14:56,520
0,270 270,630 630,1140 1140,1710 1710,1890
and actually print 0x80 as

2462
01:14:56,520 --> 01:14:58,440
0,60 60,630 630,1020 1020,1590 1620,1920
a decimal decimal number, it's

2463
01:14:58,440 --> 01:14:59,400
0,120 120,180 180,360 360,600 600,960
going to be {128 -

2464
01:14:59,400 --> 01:15:00,180
0,300
-}.|
|

2465
01:15:01,110 --> 01:15:02,220
0,600
Okay?|
好的？|

2466
01:15:02,310 --> 01:15:03,450
0,150 150,270 270,480 480,960 960,1140
So we see actually sort
所以，我们看到这些都是有道理的。

2467
01:15:03,450 --> 01:15:04,410
0,150 150,270 270,570 600,810 810,960
of you know it all

2468
01:15:04,410 --> 01:15:05,840
0,180 180,240 240,450 450,960
sort of makes sense.|
|

2469
01:15:05,900 --> 01:15:07,280
0,150 150,360 360,810 810,1080 1080,1380
We also see I printed
在这我们也打印出了标志位，

2470
01:15:07,280 --> 01:15:09,440
0,90 90,180 180,570 570,1080 1350,2160
out the flags here {},|
|

2471
01:15:09,440 --> 01:15:11,240
0,450 450,570 570,690 690,1200 1350,1800
and you know the bottom
底部（条目）包含读，写，有效，因为有效位是 1 。

2472
01:15:11,240 --> 01:15:13,910
0,360 360,780 780,1020 1020,1710 1770,2670
level has read, write and

2473
01:15:14,030 --> 01:15:16,310
0,720 870,1530 1560,1860 1860,2160 2160,2280
{} valid, because valid is

2474
01:15:16,310 --> 01:15:17,160
0,330
one.

2475
01:15:18,470 --> 01:15:20,060
0,210 210,510 510,690 690,1050
Any questions about this?|
关于这个有什么问题吗？|

2476
01:15:24,760 --> 01:15:27,300
0,540 600,1170 1320,1950
Okay, so {}
好的，所以内核继续用这个方式设置整个地址空间。

2477
01:15:27,300 --> 01:15:29,730
0,120 120,360 360,720 720,1470 1560,2430
the kernel basically proceeds {}

2478
01:15:29,730 --> 01:15:31,200
0,360 360,990 990,1290 1290,1410 1410,1470
{you,know} doing setting up the

2479
01:15:31,200 --> 01:15:32,550
0,540 540,840 840,1110 1110,1200 1200,1350
whole address space in this

2480
01:15:32,550 --> 01:15:33,480
0,420
way.|
|

2481
01:15:33,820 --> 01:15:35,410
0,600 600,840 840,1020 1020,1200 1200,1590
{} And so we've called
所以，我们对 VIRTIO CLINT PLIC 调用 kvmmap ，

2482
01:15:35,410 --> 01:15:37,450
0,330 330,480 480,1140 1140,1290 1290,2040
{kvmmap - -} for VIRTIO,

2483
01:15:37,450 --> 01:15:38,380
0,210 210,270 270,660 660,840 840,930
for the CLINT, for the

2484
01:15:38,380 --> 01:15:39,440
0,480
PLIC,|
|

2485
01:15:39,440 --> 01:15:41,810
0,330 330,810 810,1410 1440,1770 1770,2370
{} maps the kernel text,
映射内核文本，映射内核数据，

2486
01:15:41,900 --> 01:15:43,490
0,420 420,510 510,780 780,1440 1470,1590
maps the kernel memory or

2487
01:15:43,490 --> 01:15:44,960
0,240 240,810 990,1170 1170,1410 1410,1470
kernel data,| and then the
|然后是 TRAMPOLINE 页面，我们会在下周讨论它。

2488
01:15:44,960 --> 01:15:46,130
0,420 420,720 720,870 870,960 960,1170
TRAMPOLINE page, that we'll talk

2489
01:15:46,130 --> 01:15:47,340
0,180 180,420 420,750
about next week.|
|

2490
01:15:47,460 --> 01:15:48,660
0,390 390,540 540,630 630,690 690,1200
{} And so in fact
我们可以单步执行这个，看看最后的页面目录是什么样的。

2491
01:15:48,660 --> 01:15:49,770
0,120 120,420 420,690 690,930 930,1110
we can single step through

2492
01:15:49,770 --> 01:15:51,210
0,330 330,510 510,930 1050,1290 1290,1440
this and then see what

2493
01:15:51,210 --> 01:15:53,130
0,90 90,480 480,1050 1080,1680 1680,1920
the final page directory looks

2494
01:15:53,130 --> 01:15:54,080
0,420
like.|
|

2495
01:15:55,610 --> 01:15:57,950
0,390 390,660 660,1380 1410,2010 2010,2340
{} So, next next next
所以，下一步，下一步，下一步，下一步。

2496
01:15:57,950 --> 01:15:59,120
0,570
next.|
|

2497
01:15:59,330 --> 01:16:00,530
0,690 690,750 750,960 960,1140 1140,1200
Basically, you know set the
我们设置了 trampoline ，所以现在可以打印整个页表目录。

2498
01:16:00,530 --> 01:16:01,700
0,660 660,780 780,960 960,1050 1050,1170
trampoline, so now we're going

2499
01:16:01,700 --> 01:16:02,750
0,90 90,330 330,390 390,840 840,1050
to print the complete page

2500
01:16:02,750 --> 01:16:04,220
0,270 270,900
table directory.|
|

2501
01:16:04,220 --> 01:16:05,510
0,390 390,480 480,630 630,720 720,1290
And you know we see
我们看到很多 PTE 被设置了，

2502
01:16:05,990 --> 01:16:08,660
0,1290 1440,1920 1950,2190 2190,2250 2250,2670
basically a lot of PTE

2503
01:16:08,660 --> 01:16:11,420
0,90 90,420 420,900 900,1890 2010,2760
is actually being {} {set,up},|
|

2504
01:16:11,810 --> 01:16:13,160
0,630 630,960 960,1080 1080,1230 1230,1350
{} and I'm not going
我不会讲太多细节，

2505
01:16:13,160 --> 01:16:14,000
0,150 150,360 360,570 570,660 660,840
to talk about in any

2506
01:16:14,000 --> 01:16:16,340
0,690 870,1530 1560,1830 1830,1950 1950,2340
detail,| {} you know basically
|基本上就是填充页面目录，创建一个我们在上一张幻灯片看到的虚拟（地址）映射。

2507
01:16:16,340 --> 01:16:17,720
0,270 270,450 450,900
fills out the

2508
01:16:17,920 --> 01:16:19,870
0,150 150,870 1230,1440 1440,1680 1680,1950
page directory {} to actually

2509
01:16:19,870 --> 01:16:21,430
0,300 300,420 420,750 750,1170 1170,1560
create a virtual mapping mapping

2510
01:16:21,430 --> 01:16:22,390
0,180 180,300 300,660 660,900 900,960
that we basically saw in

2511
01:16:22,390 --> 01:16:23,780
0,90 90,450 450,870
the previous slide.|
|

2512
01:16:24,810 --> 01:16:26,010
0,300 300,480 480,1020 1020,1170 1170,1200
{} I expect, what I
下一步我想做的（事情）更有趣。

2513
01:16:26,010 --> 01:16:26,910
0,150 150,270 270,570 570,660 660,900
wanna do next is actually

2514
01:16:26,910 --> 01:16:29,660
0,330 330,420 420,1020 1470,2160
much more interesting {}.|
|

2515
01:16:29,690 --> 01:16:31,380
0,450 450,540 540,690 690,1170
Yeah, I'm {gonna -}.|
是的，我要做的是。|

2516
01:16:32,270 --> 01:16:33,350
0,240 240,360 360,540 540,720 720,1080
Yeah, I wanna go here
是的，我想到这里，或者我已经到了，

2517
01:16:33,350 --> 01:16:35,330
0,450 780,1080 1080,1380 1380,1590 1590,1980
actually, maybe already did this,|
|

2518
01:16:35,360 --> 01:16:37,340
0,690 690,930 930,1650 1650,1800 1800,1980
{} there 21, no, I'm
这是 21 行，不，我在 21 行，好的，单步执行。

2519
01:16:37,340 --> 01:16:38,690
0,390 390,630 630,810 810,1080 1080,1350
21, okay so single step

2520
01:16:38,690 --> 01:16:39,720
0,480
that.|
|

2521
01:16:40,550 --> 01:16:41,450
0,240 240,450 450,600 600,720 720,900
{} Okay, that's too bad
好的，它已经过去了，但是，让我来重启一下。

2522
01:16:41,450 --> 01:16:42,470
0,60 60,240 240,540 540,630 630,1020
I got past it, but

2523
01:16:42,560 --> 01:16:44,140
0,990
basically,

2524
01:16:44,380 --> 01:16:46,810
0,780 1170,1470 1470,1890 1920,2100 2100,2430
{} let me, let me

2525
01:16:46,810 --> 01:16:48,160
0,480 480,810
restart this.|
|

2526
01:16:51,080 --> 01:16:52,620
0,810
And
我想在 kvminithart 设置一个断点，然后继续。

2527
01:16:53,190 --> 01:16:54,750
0,120 120,420 450,780 780,1080 1080,1560
I wanna {breakpoint -} at

2528
01:16:54,780 --> 01:16:56,490
0,390 390,960 990,1380 1380,1620 1620,1710
{kvminithart - - - -

2529
01:16:56,490 --> 01:16:57,680
0,660
-},

2530
01:17:00,580 --> 01:17:02,220
0,330 330,1080
and continue.|
|

2531
01:17:03,680 --> 01:17:06,080
0,660 660,1260 1500,1830 1830,2340 2340,2400
Now {I'm,here} at {kvminithart -
现在我在 kvminithart 了，在这里可以看到，它写入 satp 寄存器，

2532
01:17:06,080 --> 01:17:07,070
0,90 90,540 540,690 690,750 750,990
- -} and you see

2533
01:17:07,070 --> 01:17:09,110
0,390 390,1020 1140,1470 1470,1680 1680,2040
here basically that will writing

2534
01:17:09,110 --> 01:17:10,520
0,120 120,360 360,720 720,1170 1200,1410
the {satp -} register,| so
|所以，内核在启用页表，让 MMU 可以使用我们刚才设置的页表。

2535
01:17:10,520 --> 01:17:11,450
0,330 330,390 390,720 720,810 810,930
basically the kernel is going

2536
01:17:11,450 --> 01:17:14,330
0,60 60,810 1080,1680 1800,2460 2460,2880
to enable the page table

2537
01:17:14,330 --> 01:17:16,130
0,270 270,360 360,750 750,1380 1410,1800
or the {} MMU, to

2538
01:17:16,130 --> 01:17:17,240
0,330 330,600 600,840 840,900 900,1110
basically start using the page

2539
01:17:17,240 --> 01:17:18,290
0,390 390,540 540,630 630,870 870,1050
table that we just set

2540
01:17:18,290 --> 01:17:18,980
0,270
up.|
|

2541
01:17:19,470 --> 01:17:23,200
0,540 690,1770 2160,2550 2550,3150
And one interesting question,
一个有趣的问题，好的，我再次切换到分隔模式，

2542
01:17:23,370 --> 01:17:24,420
0,330 330,450 450,660 660,870 870,1050
okay, so {let,me} go out

2543
01:17:24,420 --> 01:17:26,020
0,330 330,600 600,1050
layout split again,|
|

2544
01:17:26,020 --> 01:17:27,660
0,510 510,1080
{} so,
这里的某个地方，是这条指令，

2545
01:17:27,750 --> 01:17:29,280
0,540 540,990 990,1290 1290,1380 1380,1530
somewhere here correct is going

2546
01:17:29,280 --> 01:17:31,240
0,60 60,540 660,1170
to be {},

2547
01:17:31,300 --> 01:17:33,730
0,300 300,540 540,720 720,1590 1620,2430
here's the {} instruction {}|
|

2548
01:17:33,940 --> 01:17:35,960
0,600 1050,1470
and so,
执行这条指令之后，会发生一件非常激动人心的事情。

2549
01:17:36,080 --> 01:17:38,750
0,750 1110,1560 1560,1950 1950,2190 2190,2670
once, {} something really dramatic

2550
01:17:38,750 --> 01:17:41,240
0,630 960,1320 1320,1740 1740,1890 1890,2490
happens after executing this instruction.|
|

2551
01:17:42,280 --> 01:17:44,680
0,600 780,1260 1260,1650 1650,2190 2190,2400
{} Let's say yeah {you,know}
比如说，完全相同的指令，

2552
01:17:44,680 --> 01:17:45,940
0,150 150,360 360,630 630,810 810,1260
can say the same instruction

2553
01:17:45,940 --> 01:17:48,070
0,420 420,570 570,1230 1230,1680 1710,2130
exactly,| but there's this this
|但是一旦执行这条指令，转换下一条地址会发生什么。

2554
01:17:48,070 --> 01:17:50,110
0,570 900,1260 1260,1440 1440,1950 1950,2040
{} once this instruction is

2555
01:17:50,110 --> 01:17:51,400
0,450 450,690 690,810 810,1140 1140,1290
executed what will happen with

2556
01:17:51,400 --> 01:17:52,570
0,90 90,330 330,780 780,990 990,1170
the next address that's being

2557
01:17:52,570 --> 01:17:53,700
0,630
translated.|
|

2558
01:17:58,310 --> 01:17:59,570
0,510 660,810 810,900 900,1170 1170,1260
Well, at the point that
好的，在执行这条指令之前，还没有启动页表，所以也没有转换，

2559
01:17:59,570 --> 01:18:01,550
0,90 90,420 420,600 600,1290 1320,1980
we execute this instruction, before

2560
01:18:01,550 --> 01:18:03,500
0,390 390,540 540,1200 1260,1620 1620,1950
executing this instruction, there's no

2561
01:18:03,500 --> 01:18:04,760
0,240 240,540 540,870 870,1050 1050,1260
page tables enabled yet, so

2562
01:18:04,760 --> 01:18:06,710
0,270 270,750 750,1290 1650,1860 1860,1950
no translation happens,| with the
|然后程序计数器加 4 ，然后下一条指令执行，

2563
01:18:06,710 --> 01:18:08,120
0,510 630,930 930,1020 1020,1110 1110,1410
next and then the program

2564
01:18:08,120 --> 01:18:09,770
0,240 240,330 330,840 870,1080 1080,1650
counter is updated by four,

2565
01:18:10,280 --> 01:18:11,300
0,210 210,360 360,420 420,630 630,1020
and then the next instruction

2566
01:18:11,300 --> 01:18:12,620
0,90 90,780 810,960 960,1020 1020,1320
is executed| and the program
|这时，程序计数器就会使用虚拟页表内存来转换。

2567
01:18:12,620 --> 01:18:13,970
0,270 270,420 420,510 510,1080 1080,1350
counter will be translated using

2568
01:18:13,970 --> 01:18:15,800
0,120 120,420 420,900 1320,1560 1560,1830
the virtual page page table

2569
01:18:15,800 --> 01:18:16,740
0,420
memory.|
|

2570
01:18:17,140 --> 01:18:18,370
0,120 120,510 540,780 780,900 900,1230
And so this is a
所以，你可以认为，这是一个激动人心的时刻，

2571
01:18:18,430 --> 01:18:19,750
0,660 660,750 750,930 930,1140 1140,1320
way to think about this,

2572
01:18:19,750 --> 01:18:21,280
0,150 150,270 270,360 360,1020 1020,1530
this is a dramatic moment,|
|

2573
01:18:21,610 --> 01:18:23,860
0,300 300,720 720,810 810,1620 1800,2250
because basically the whole address
因为整个地址转换被启用，

2574
01:18:23,860 --> 01:18:25,360
0,600 600,660 660,960 960,1020 1020,1500
translation they started to enable|
|

2575
01:18:25,360 --> 01:18:26,500
0,120 120,390 390,750 750,1020 1020,1140
and every address needs {you,know}
每个地址都可能不一样了，

2576
01:18:26,500 --> 01:18:28,740
0,390 390,990 990,1320 1320,1770
maybe potentially something different,

2577
01:18:29,660 --> 01:18:30,920
0,210 210,420 420,810 810,960 960,1260
right,| because before we're running,
|因为在运行（这条指令）之前，使用物理地址，还没有页表和映射，

2578
01:18:30,920 --> 01:18:32,570
0,210 450,840 840,1320 1320,1530 1530,1650
use physical addresses, then the

2579
01:18:32,570 --> 01:18:33,740
0,210 210,480 480,780 780,1080 1080,1170
page table haven't install and

2580
01:18:33,740 --> 01:18:34,760
0,390 390,510 510,570 570,630 630,1020
whatever is in the mapping,|
|

2581
01:18:34,760 --> 01:18:35,600
0,150 150,300 300,450 450,540 540,840
now there's {} the new
现在有了虚拟地址的新含义。

2582
01:18:35,600 --> 01:18:37,340
0,690 690,840 840,900 900,1200 1200,1740
meaning of a virtual address.|
|

2583
01:18:38,680 --> 01:18:39,730
0,210 210,360 360,510 510,780 780,1050
{} And here's how this
实际上这个成果是非常显著的，

2584
01:18:39,730 --> 01:18:40,900
0,360 360,840 870,990 990,1080 1080,1170
works out, you know the

2585
01:18:40,900 --> 01:18:41,800
0,240 240,330 330,450 450,660 660,900
fact that this actually works

2586
01:18:41,800 --> 01:18:43,240
0,150 150,240 240,1020 1020,1260 1260,1440
out is remarkable,| because like
|因为下一条指令，下一个值是虚拟地址，而不是物理地址，

2587
01:18:43,240 --> 01:18:44,860
0,90 90,600 720,1350 1350,1410 1410,1620
the next instruction, the next

2588
01:18:44,860 --> 01:18:46,510
0,570 720,870 870,960 960,1320 1320,1650
value is a virtual address

2589
01:18:46,510 --> 01:18:47,650
0,90 90,240 240,300 300,630 630,1140
and not a physical address,|
|

2590
01:18:48,700 --> 01:18:50,020
0,750 750,1080 1080,1140 1140,1260 1260,1320
next instruction is going to
下一条指令将是 0x80001110 。

2591
01:18:50,020 --> 01:18:51,130
0,120 120,270 270,720 720,870 870,1110
be this, whatever {0x80001110 -

2592
01:18:51,130 --> 01:18:52,640
0,210 210,360 360,510 510,960
- - - -}.|
|

2593
01:18:52,760 --> 01:18:53,660
0,120 120,330 330,510 510,660 660,900
And why does this work
为什么这个能成功。

2594
01:18:53,660 --> 01:18:54,600
0,390
out.|
|

2595
01:18:55,960 --> 01:18:57,040
0,150 150,210 210,570 570,840 840,1080
Well, the reason works out
好的，成功的原因是内核设置的页面恒等映射，

2596
01:18:57,040 --> 01:18:57,880
0,90 90,360 360,420 420,750 750,840
is, because the kernel is

2597
01:18:57,880 --> 01:18:59,200
0,390 390,510 510,630 630,1080 1080,1320
{set,up} {with -} identity page

2598
01:18:59,200 --> 01:19:00,720
0,450 510,990
mapping,| so
|在启用虚拟页面硬件之后，

2599
01:19:00,750 --> 01:19:02,580
0,480 480,630 630,1080 1080,1410 1440,1830
after we enable the virtual

2600
01:19:02,580 --> 01:19:04,410
0,330 330,930 1170,1350 1350,1770 1770,1830
paging hardware,| we actually you
|这个转换器会转换成相同的物理地址，

2601
01:19:04,410 --> 01:19:06,240
0,150 150,330 330,840 960,1320 1320,1830
know this translator will translate

2602
01:19:06,240 --> 01:19:07,560
0,510 510,660 660,750 750,960 960,1320
again to the same physical

2603
01:19:07,560 --> 01:19:09,960
0,540 690,990 990,1860 1860,2040 2040,2400
address,| so indeed we'll actually
|所以，最终我们会执行正确的指令，

2604
01:19:09,960 --> 01:19:12,180
0,180 180,660 1260,1860 1860,1950 1950,2220
end up executing the right

2605
01:19:12,180 --> 01:19:14,250
0,690 780,1080 1080,1260 1260,1590 1590,2070
instruction,| because that's actually exactly
|因为那条指令通过虚拟硬件[编程]后的内存位置。

2606
01:19:14,250 --> 01:19:15,210
0,60 60,510 510,600 600,660 660,960
the instruction, that the memory

2607
01:19:15,210 --> 01:19:16,800
0,390 390,570 570,840 870,1260 1260,1590
location that the virtual hardware

2608
01:19:16,800 --> 01:19:17,900
0,60 60,450 450,720
is programmed {}.|
|

2609
01:19:19,120 --> 01:19:20,170
0,150 150,300 300,450 450,600 600,1050
So does this make sense?|
这个能理解吗？|

2610
01:19:22,920 --> 01:19:24,630
0,120 120,270 270,720 720,1320 1380,1710
{Again -}, one reason why
再一次，使用虚拟内存编程困难的一个原因是，

2611
01:19:24,630 --> 01:19:26,580
0,570 570,930 930,1200 1200,1290 1290,1950
programming virtual memory is difficult

2612
01:19:26,850 --> 01:19:28,050
0,210 210,510 510,720 720,810 810,1200
is,| because once you execute
|因为一旦你执行 satp 指令，加载页表到 satp 寄存器中，

2613
01:19:28,050 --> 01:19:29,880
0,150 150,240 240,450 450,1050 1050,1830
one of these satp instructions,

2614
01:19:29,940 --> 01:19:31,410
0,600 600,900 900,960 960,1170 1170,1470
{you,know} load a page table

2615
01:19:31,410 --> 01:19:34,230
0,150 150,720 1020,1980 1980,2220 2220,2820
in the {satp -} register,|
|

2616
01:19:34,260 --> 01:19:36,600
0,360 360,780 780,1260 1260,1920
your world completely changes.|
你的世界就完全改变了。|

2617
01:19:36,690 --> 01:19:38,100
0,600 630,930 930,1230 1230,1290 1290,1410
And every address is now
现在每个地址都会使用你设置的页表进行转换。

2618
01:19:38,100 --> 01:19:39,510
0,600 600,720 720,810 810,1140 1140,1410
translated with the page able

2619
01:19:39,510 --> 01:19:40,880
0,120 120,300 300,480 480,840
that you set up.|
|

2620
01:19:41,560 --> 01:19:42,490
0,180 180,300 300,540 540,870 870,930
And so what happens if
所以，如果页表设置错误，会发生什么。

2621
01:19:42,490 --> 01:19:44,080
0,90 90,300 300,600 600,900 900,1590
the page table {set,up} incorrectly,

2622
01:19:44,830 --> 01:19:46,630
0,270 270,390 390,1020 1350,1620 1620,1800
what would you, what might

2623
01:19:46,630 --> 01:19:47,620
0,360
happen.|
|

2624
01:19:53,660 --> 01:19:54,740
0,390 390,480 480,660 660,720 720,1080
Anybody who wants to {}
有人想回答，或在聊天窗口中回答。

2625
01:19:55,300 --> 01:19:56,800
0,450 450,870 870,1080 1080,1410 1410,1500
{say,that} answer or answered in

2626
01:19:56,800 --> 01:19:57,880
0,90 90,450 480,630 630,690 690,1080
the chat, {either -} way.|
|

2627
01:20:00,510 --> 01:20:02,250
0,210 210,390 390,900 900,1260 1260,1740
You could override kernel data.|
你可能覆盖内核数据。|

2628
01:20:02,980 --> 01:20:03,940
0,210 210,300 300,390 390,720 720,960
Yeah, you could overwrite kernel
是的，你可能覆盖内核数据，还会发生什么呢，

2629
01:20:03,940 --> 01:20:05,020
0,300 300,540 540,690 690,810 810,1080
data, what else could happen,|
|

2630
01:20:05,020 --> 01:20:06,670
0,270 270,510 510,930 960,1500 1500,1650
yeah, page fault, basically the
是的，页面错误，映射可能错误，地址不能转换，

2631
01:20:06,670 --> 01:20:09,880
0,630 990,1470 1470,1620 1620,2310 2670,3210
{} mapping may be incorrect

2632
01:20:09,880 --> 01:20:11,020
0,150 150,510 510,600 600,870 870,1140
and basically the address can't

2633
01:20:11,020 --> 01:20:12,130
0,150 150,630 630,750 750,990 990,1110
be translated at all,| and
|所以，内核，硬件不会这样做，造成内核停止或死机。

2634
01:20:12,130 --> 01:20:13,150
0,90 90,180 180,480 480,810 840,1020
so the kernel can, you

2635
01:20:13,150 --> 01:20:14,440
0,180 180,300 360,930 930,1170 1170,1290
know the hardware won't do

2636
01:20:14,440 --> 01:20:15,280
0,210 210,330 330,480 480,570 570,840
it and usally the kernel

2637
01:20:15,280 --> 01:20:16,880
0,150 150,540 540,630 630,1200
just stops and panics.|
|

2638
01:20:18,770 --> 01:20:20,100
0,150 150,240 240,390 390,840
Does that make sense?|
这个能理解吗？|

2639
01:20:20,100 --> 01:20:21,000
0,510

2640
01:20:21,000 --> 01:20:21,720
0,120 120,240 240,360 360,450 450,720
If you get a bug
如果你在页表中有 bug ，你会看到这些错误或崩溃。

2641
01:20:21,720 --> 01:20:23,320
0,90 90,180 180,450 450,1110
in your page tables,

2642
01:20:23,540 --> 01:20:24,260
0,150 150,270 270,510 510,630 630,720
you know you're going to

2643
01:20:24,260 --> 01:20:27,830
0,270 270,1350 1500,2610 2670,2910 2910,3570
see {these,are} errors or crashes.|
|

2644
01:20:28,720 --> 01:20:29,920
0,240 240,360 360,630 630,1020 1020,1200
And so, one reason that,|
所以，一个原因，|

2645
01:20:29,920 --> 01:20:31,420
0,360 360,450 450,690 690,1290 1380,1500
{for,example} the next lab, {}
下一个实验，今晚放出的页表实验比较难，

2646
01:20:31,420 --> 01:20:32,470
0,150 150,360 360,690 690,870 870,1050
the page table lab that

2647
01:20:32,470 --> 01:20:33,910
0,300 300,570 570,870 870,1170 1170,1440
will hand out or release

2648
01:20:33,910 --> 01:20:35,290
0,510 660,1050 1050,1140 1140,1290 1290,1380
tonight {} is gonna be

2649
01:20:35,290 --> 01:20:36,700
0,690 690,960 960,1170 1170,1350 1350,1410
hard,| because those kind of
|因为这些 bug 会出现。

2650
01:20:36,700 --> 01:20:38,140
0,300 300,450 450,690 690,930
bugs will show up,|
|

2651
01:20:38,200 --> 01:20:39,820
0,540 540,690 690,1080 1080,1350 1350,1620
{if,you're} not carefully enough or
如果你不够细心，或者你没有完全理解某些方面，

2652
01:20:39,820 --> 01:20:41,410
0,150 150,480 540,870 870,1410 1410,1590
you haven't fully internalized some

2653
01:20:41,410 --> 01:20:43,600
0,390 390,720 1110,1650 1650,1830 1830,2190
aspect yet| and you're basically
|你可能会遇到内核崩溃，陷入困境之中，

2654
01:20:43,600 --> 01:20:44,290
0,120 120,180 180,330 330,360 360,690
going to get a kernel

2655
01:20:44,290 --> 01:20:46,150
0,660 960,1350 1350,1440 1440,1590 1590,1860
crash and you're gonna have

2656
01:20:46,150 --> 01:20:46,930
0,60 60,240 240,540 540,660 660,780
a hard time| when you
|需要花一些时间和精力来调试追踪发生（这种情况）的原因。

2657
01:20:46,930 --> 01:20:47,920
0,420 420,570 570,630 630,780 780,990
will take a little bit

2658
01:20:47,920 --> 01:20:49,300
0,90 90,300 300,390 390,900 900,1380
of time and energy on

2659
01:20:49,300 --> 01:20:50,710
0,450 450,750 750,810 810,1110 1110,1410
detective work to basically track

2660
01:20:50,710 --> 01:20:52,500
0,450 450,750 750,960 960,1290
down why that happened.|
|

2661
01:20:53,370 --> 01:20:55,360
0,480 480,630 630,990 990,1410
And that's just the,
这就是虚拟内存编程的难点。

2662
01:20:55,390 --> 01:20:56,560
0,270 270,450 450,750 750,930 930,1170
that's just hard of like

2663
01:20:56,560 --> 01:20:58,180
0,420 420,720 720,1080
programming virtual memory,|
|

2664
01:20:58,320 --> 01:20:59,160
0,210 210,480 480,600 600,780 780,840
{} because it's such a
因为它是强大的，[原始的]，如果你错了，会产生严重的后果。

2665
01:20:59,160 --> 01:21:00,750
0,420 420,1080 1230,1350 1350,1470 1470,1590
powerful [primitive], you know you

2666
01:21:00,750 --> 01:21:01,980
0,90 90,210 210,690 720,1110 1110,1230
get {} wrong, you're going

2667
01:21:01,980 --> 01:21:03,140
0,60 60,540
to have

2668
01:21:03,480 --> 01:21:05,180
0,390 390,1200
powerful consequences.|
|

2669
01:21:08,090 --> 01:21:08,960
0,360 360,450 450,600 600,750 750,870
Yet, the other hand is
不过，另一方面，它是非常有趣的，我不想以负面结束，

2670
01:21:08,960 --> 01:21:10,130
0,360 360,540 540,630 630,930 930,1170
great amount of fun, so

2671
01:21:10,130 --> 01:21:10,760
0,60 60,180 180,300 300,420 420,630
I don't want to end

2672
01:21:10,760 --> 01:21:13,160
0,120 120,150 150,510 510,960 1800,2400
on a negative [note] {},|
|

2673
01:21:13,310 --> 01:21:14,630
0,480 480,750 750,990 990,1140 1140,1320
but all that will give
但是，所有这些都让你真正理解虚拟内存，以及它能做什么。

2674
01:21:14,630 --> 01:21:16,100
0,210 210,600 600,870 870,1350 1350,1470
you {sort,of} real understanding of

2675
01:21:16,100 --> 01:21:17,660
0,270 270,570 570,840 840,1170 1170,1560
actually what really virtual memory

2676
01:21:17,660 --> 01:21:18,320
0,240 240,360 360,480 480,570 570,660
is and what it can

2677
01:21:18,320 --> 01:21:19,080
0,270
do.|
|

2678
01:21:20,180 --> 01:21:21,140
0,210 210,300 300,510 510,750 750,960
Okay, I think I'm running
好的，我想我已经超时了，所以，我准备在这里结束，

2679
01:21:21,140 --> 01:21:21,800
0,90 90,180 180,450 450,600 600,660
out of time, so I'm

2680
01:21:21,800 --> 01:21:23,510
0,210 210,540 540,960 1020,1260 1260,1710
gonna stop here,| {} so
|让大家可以去下一节课或下一个活动，

2681
01:21:23,600 --> 01:21:24,260
0,210 210,300 300,450 450,510 510,660
people have time to go

2682
01:21:24,260 --> 01:21:25,040
0,90 90,210 210,420 420,750 750,780
to the next class or

2683
01:21:25,040 --> 01:21:26,840
0,210 210,780 1020,1620 1620,1710 1710,1800
next activity,| but if you
|但是如果你还有任何问题，请稍等，并提问。

2684
01:21:26,840 --> 01:21:28,400
0,90 90,300 300,780 780,1230 1230,1560
have any questions left {}

2685
01:21:28,400 --> 01:21:29,870
0,180 180,420 420,630 630,1050 1050,1470
{you,know} please hang on and

2686
01:21:29,870 --> 01:21:30,960
0,420 420,600
ask them.|
|

2687
01:21:31,440 --> 01:21:33,150
0,720 810,1110 1110,1380 1380,1530 1530,1710
And, {} we'll see you
周一见，祝你们顺利完成 syscall 实验。

2688
01:21:33,150 --> 01:21:34,340
0,120 120,630
on Monday,

2689
01:21:35,370 --> 01:21:37,110
0,240 240,390 390,720 720,1380 1380,1740
and good luck with finishing

2690
01:21:37,110 --> 01:21:38,640
0,240 240,540 540,1020
the syscall lab.|
|

2691
01:21:40,920 --> 01:21:42,150
0,360 390,810 810,930 930,1140 1140,1230
Um, hi I have a
我有一个关于 walk 的问题，

2692
01:21:42,150 --> 01:21:45,210
0,480 480,1020 1050,1710 2040,2670 2790,3060
question about walk,| {} so
|

2693
01:21:45,210 --> 01:21:46,650
0,120 120,720 750,1200 1230,1350 1350,1440
it says and in the
在代码中，返回 PTE 的第一张表，

2694
01:21:46,650 --> 01:21:48,680
0,390 390,510 510,1080 1080,1500
code, it returns the,

2695
01:21:48,830 --> 01:21:51,260
0,270 270,390 390,960 960,1800 2160,2430
like the first tables of

2696
01:21:51,260 --> 01:21:55,670
0,900 1200,2460 2700,3270 3480,3930 4200,4410
PTE, right,| {} {but -}
|但是，它是如何工作的，比如其他函数希望真正的 PTE 而不是物理地址。

2697
01:21:55,670 --> 01:21:56,630
0,210 210,360 360,450 450,720 720,960
how does it work, then

2698
01:21:56,630 --> 01:21:57,890
0,210 210,300 300,540 540,1020 1020,1260
like the other functions when

2699
01:21:57,890 --> 01:21:59,440
0,330 360,1110
they expect

2700
01:21:59,440 --> 01:22:02,080
0,240 240,720 720,1500 1890,2250 2430,2640
the actual PTE than like

2701
01:22:02,080 --> 01:22:03,900
0,120 120,600 600,1380
the physical address.|
|

2702
01:22:04,310 --> 01:22:05,560
0,420

2703
01:22:05,680 --> 01:22:08,710
0,690 810,1590 1590,2010 2010,2490 2490,3030
Yeah, basically this returns the
是的，这个返回页表的 PTE 条目。

2704
01:22:08,740 --> 01:22:10,810
0,780 840,1560 1560,1770 1770,1830 1830,2070
PTE entry in the page

2705
01:22:10,810 --> 01:22:12,140
0,390 420,810
table, right.|
|

2706
01:22:12,140 --> 01:22:13,250
0,480 480,600 600,840 840,990 990,1110
And the kernel could read
内核可以读写页表条目，你现在可以把值放入 PTE 中。

2707
01:22:13,250 --> 01:22:14,510
0,90 90,300 300,480 480,720 720,1260
or write page table entries,

2708
01:22:15,070 --> 01:22:16,900
0,660 660,1020 1020,1200 1200,1620 1620,1830
{} and so now you

2709
01:22:16,900 --> 01:22:18,370
0,150 150,480 480,1050 1050,1350 1350,1470
can stick values into the

2710
01:22:18,370 --> 01:22:19,560
0,630
PTE.|
|

2711
01:22:21,180 --> 01:22:22,320
0,270 270,540 540,900 900,990 990,1140
And so maybe I can
我可以画一张图，来帮助理解。

2712
01:22:22,320 --> 01:22:23,820
0,240 240,330 330,960 1080,1410 1410,1500
draw a picture, that is

2713
01:22:23,820 --> 01:22:26,240
0,630 990,1860
helpful {}.|
|

2714
01:22:26,330 --> 01:22:27,400
0,210 210,570
Let's see.|
让我们来看一下。|

2715
01:22:33,110 --> 01:22:34,360
0,90 90,360 360,720

2716
01:22:35,770 --> 01:22:36,790
0,390 390,630 630,840 840,930 930,1020
So, basically we have a
所以，我们有一个页面目录，

2717
01:22:36,790 --> 01:22:38,280
0,210 210,900
page directory,|
|

2718
01:22:45,000 --> 01:22:46,240
0,660
and
这个 walk 代码，

2719
01:22:46,240 --> 01:22:48,130
0,90 90,600 630,1140 1140,1560 1560,1890
you know this walk code,|
|

2720
01:22:48,130 --> 01:22:49,060
0,150 150,270 270,480 480,810 810,930
so the page directory has
页面目录有 512 个 PTE ，这是 0 ，这是 511 ，

2721
01:22:49,060 --> 01:22:50,760
0,300 300,420 420,1080
{512 - -}

2722
01:22:51,000 --> 01:22:52,580
0,450 450,540 540,690 690,960
{PTEs -} in it,

2723
01:22:56,960 --> 01:22:58,910
0,360 360,840 840,1050 1050,1410 1410,1950
{here's} 0, here's {511 -},|
|

2724
01:22:59,570 --> 01:23:01,040
0,480 480,810 810,990 990,1080 1080,1470
and basically what the function
这个函数的作用是，返回一个指针指向这些 PTE 中的一个，

2725
01:23:01,040 --> 01:23:03,080
0,540 630,900 900,1230 1230,1290 1290,2040
does, it returns the pointer

2726
01:23:03,410 --> 01:23:05,120
0,300 300,600 600,720 720,930 930,1710
to one of these PTEs,|
|

2727
01:23:06,040 --> 01:23:06,640
0,150 150,240 240,390 390,570 570,600
and so that's just a
这只是一个虚拟地址，指向那个特定的 PTE 。

2728
01:23:06,640 --> 01:23:08,350
0,360 360,900 960,1110 1110,1350 1350,1710
virtual address, and it points

2729
01:23:08,350 --> 01:23:09,520
0,90 90,270 270,600 600,750 750,1170
to that particular {PTE -}.|
|

2730
01:23:10,210 --> 01:23:11,830
0,600 600,780 780,870 870,1230 1230,1620
And now the kernel can
现在内核可以通过写入值来操纵这个 PTE ，

2731
01:23:11,860 --> 01:23:13,450
0,120 120,450 480,1020 1020,1170 1170,1590
you know manipulate that PTE

2732
01:23:13,450 --> 01:23:15,220
0,270 270,870 870,1170 1170,1620 1620,1770
by whatever writing values to

2733
01:23:15,220 --> 01:23:16,020
0,270
it,|
|

2734
01:23:16,020 --> 01:23:17,780
0,240 240,420 420,720 720,1260
like some physical address,
比如（写入）一些物理地址，包括后面的十位权限位。

2735
01:23:17,840 --> 01:23:20,240
0,720 1320,1560 1560,1650 1650,2160 2160,2400
maybe with some permissions or

2736
01:23:20,240 --> 01:23:21,170
0,300 300,450 450,570 570,660 660,930
into it for the {}

2737
01:23:21,170 --> 01:23:22,700
0,330 330,540 540,960
bottom ten bits.|
|

2738
01:23:23,730 --> 01:23:25,080
0,240 240,600 600,930 930,1290 1290,1350
And then basically updates the
然后更新页表目录，然后当你把它加载到 satp 中，

2739
01:23:25,080 --> 01:23:26,640
0,240 240,480 480,1050 1050,1260 1260,1560
page table directory and later

2740
01:23:26,640 --> 01:23:28,050
0,390 390,690 690,780 780,1110 1110,1410
on when you load that

2741
01:23:28,050 --> 01:23:29,880
0,300 300,480 480,1290
into {satp -},|

2742
01:23:29,880 --> 01:23:31,470
0,150 150,390 390,930 930,1260 1260,1590
now that affect that change
这一修改会生效。

2743
01:23:31,470 --> 01:23:33,040
0,150 150,330 330,540 540,1020
will go into affect.|
|

2744
01:23:35,350 --> 01:23:36,740
0,180 180,330 330,480 480,900
Does that make sense?|
这个能理解吗？|

2745
01:23:37,180 --> 01:23:38,230
0,330 330,450 450,660 660,930 930,1050
Yeah, that makes sense.| I
是的，能理解。|我想我的问题是为什么它遍历了三个页表，然后只返回第一个 PTE 。

2746
01:23:38,230 --> 01:23:39,400
0,210 210,330 330,540 540,960 960,1170
guess I just confused like

2747
01:23:39,400 --> 01:23:40,270
0,330 330,480 480,570 570,750 750,870
why does it do the

2748
01:23:40,270 --> 01:23:41,830
0,480 510,720 720,1260 1290,1500 1500,1560
work of going all the

2749
01:23:41,830 --> 01:23:43,870
0,180 180,360 360,720 750,1320 1710,2040
way to the third page

2750
01:23:43,870 --> 01:23:45,760
0,540 540,660 660,960 990,1260 1260,1890
table and then only return

2751
01:23:46,000 --> 01:23:48,700
0,210 210,690 900,1620 1890,2280 2280,2700
the first PTE.| No, return
|不，返回的是最后一个，让我来仔细一点，

2752
01:23:48,700 --> 01:23:50,170
0,270 270,690 690,870 870,1140 1140,1470
actually is the bottom one,

2753
01:23:51,720 --> 01:23:53,430
0,540 540,750 750,930 930,1110 1110,1710
actually, let me be careful,|
|

2754
01:23:53,490 --> 01:23:54,800
0,780

2755
01:23:55,350 --> 01:23:56,670
0,450 450,570 570,960 960,1050 1050,1320
if you know it goes
它通过 n 级，从 2 级开始，然后 1 级，再到 0 级，

2756
01:23:56,670 --> 01:23:58,200
0,180 180,270 270,420 420,960 1110,1530
through the n levels, started

2757
01:23:58,200 --> 01:23:59,070
0,210 210,540 540,630 630,780 780,870
level two and then go

2758
01:23:59,070 --> 01:24:00,210
0,150 150,360 360,690 690,1080 1080,1140
to level one, again to

2759
01:24:00,210 --> 01:24:01,420
0,210 210,720
level zero,|
|

2760
01:24:01,730 --> 01:24:04,280
0,660 870,1350 1350,1530 1530,2100 2100,2550
if {} the alloc {bit,set},
如果设置了 alloc 位，并且那一级不存在，它会创建一个中间页表目录，

2761
01:24:05,150 --> 01:24:07,100
0,780 780,990 990,1230 1230,1740 1770,1950
and level doesn't exist, it

2762
01:24:07,100 --> 01:24:08,810
0,450 450,900 900,1020 1020,1530 1530,1710
will create the intermediate page

2763
01:24:08,810 --> 01:24:10,320
0,360 360,930
table directory,|
|

2764
01:24:10,580 --> 01:24:11,840
0,180 180,480 480,570 570,1080 1110,1260
and zero it out and
把它置零，然后继续查找。

2765
01:24:11,840 --> 01:24:13,040
0,210 210,390 390,750 750,810 810,1200
then keep going to look.|
|

2766
01:24:13,770 --> 01:24:16,110
0,480 780,1200 1500,1740 1740,2160 2160,2340
So, {} you always end
所以，你总是找到底部 PTE ，

2767
01:24:16,110 --> 01:24:17,580
0,240 240,390 390,510 510,840 840,1470
up on the bottom PTE,|
|

2768
01:24:18,580 --> 01:24:20,350
0,210 210,570 570,900 900,1350 1530,1770
if {alloc,is} not set, you
如果 alloc 没有设置，你在第一个 PTE 停止，它没有值。

2769
01:24:20,350 --> 01:24:22,330
0,450 450,540 540,660 660,1200 1380,1980
stop at the first PTE,

2770
01:24:22,330 --> 01:24:23,980
0,150 150,420 420,630 630,1110
that doesn't have value.|
|

2771
01:24:25,560 --> 01:24:26,700
0,420 420,540 540,720 720,960 960,1140
Okay, that makes sense, this
好的，有道理，这是最后一个，实际上，好的。

2772
01:24:26,700 --> 01:24:27,930
0,90 90,240 240,630 630,1080 1110,1230
is the last one, the

2773
01:24:27,930 --> 01:24:30,270
0,630 690,1170 1230,1500 1500,1920 1920,2340
actual on, gonna have, okay.|
|

2774
01:24:31,410 --> 01:24:33,180
0,480 480,780 780,1200
Okay, thank you.|
好的，谢谢。|

2775
01:24:36,820 --> 01:24:38,360
0,270 270,420 420,1020
Any other questions?|
还有别的问题吗？|

2776
01:24:40,820 --> 01:24:41,600
0,300 300,480 480,570 570,720 720,780
{} So I have a
我有一个问题，所有东西都能理解，

2777
01:24:41,600 --> 01:24:45,110
0,570 1140,2190 2190,2640 2640,2910 2910,3510
question, basically everything made sense|
|

2778
01:24:45,140 --> 01:24:47,030
0,450 450,600 600,1290 1290,1410 1410,1890
until we mapped the virtual
直到我们将内核虚拟地址映射到物理地址。

2779
01:24:47,030 --> 01:24:49,040
0,600 600,1050 1380,1530 1530,1650 1650,2010
addresses to of the kernel

2780
01:24:49,040 --> 01:24:52,260
0,120 120,240 240,630 630,1380
to the physical addresses.|
|

2781
01:24:53,800 --> 01:24:55,510
0,210 210,360 360,990 990,1200 1200,1710
So my understanding is that
我的理解是，每个进程有它自己的页表，

2782
01:24:55,720 --> 01:24:57,100
0,270 270,720 720,840 840,1200 1200,1380
each process will have its

2783
01:24:57,100 --> 01:24:58,360
0,240 240,480 480,780 780,1050 1050,1260
own page table,| which is
|也是一个三级树，映射它的虚拟地址到物理地址，

2784
01:24:58,360 --> 01:24:59,830
0,420 420,540 540,720 720,1020 1020,1470
also a three level tree,

2785
01:24:59,920 --> 01:25:02,050
0,270 270,900 930,1200 1200,1620 1620,2130
which maps its virtual addresses

2786
01:25:02,050 --> 01:25:04,150
0,330 390,840 840,1470 1680,1800 1800,2100
to physical addresses,| but when
|但是，当我们把内核虚拟地址映射到物理地址，

2787
01:25:04,150 --> 01:25:06,520
0,120 120,420 420,1740 1740,2040 2040,2370
we map the kernel virtual

2788
01:25:06,520 --> 01:25:08,230
0,420 420,510 510,870 870,1530 1620,1710
addresses to physical addresses,| I
|我想我们没有考虑到内核虚拟地址[实际的树]，

2789
01:25:08,230 --> 01:25:09,610
0,180 180,360 360,450 450,960 960,1380
don't think we accounted for

2790
01:25:09,640 --> 01:25:10,810
0,120 120,570 570,840 840,1020 1020,1170
the [actual tree] of them

2791
01:25:11,830 --> 01:25:13,630
0,390 660,1110 1110,1560 1560,1680 1680,1800
{} virtual addresses of the

2792
01:25:13,630 --> 01:25:16,630
0,510 540,1020 1320,1740 1770,2130 2130,3000
kernel| or where other processes
|其他进程的虚拟地址在哪里，

2793
01:25:16,810 --> 01:25:19,150
0,180 180,510 510,930 960,1500 1500,2340
will have their virtual addresses|
|

2794
01:25:19,390 --> 01:25:20,640
0,600
and,
抱歉，是页表树，页表树在物理内存中指向哪里。

2795
01:25:20,700 --> 01:25:23,760
0,420 420,690 690,1110 1110,1950 2760,3060
I'm sorry, virtual addresses like

2796
01:25:23,760 --> 01:25:25,470
0,150 150,480 480,810 810,1260 1260,1710
the page table trees and

2797
01:25:26,200 --> 01:25:27,520
0,390 390,480 480,720 720,1020 1020,1320
whatever the page table tree

2798
01:25:27,550 --> 01:25:29,440
0,330 330,750 780,990 990,1200 1440,1890
points at in the physical

2799
01:25:29,440 --> 01:25:31,480
0,510 990,1290 1290,1710 1710,1860 1860,2040
memory.| Yeah, so yeah so
|是的，所以，回到这张关于内核虚拟地址空间的幻灯片，

2800
01:25:31,480 --> 01:25:33,790
0,390 390,780 780,1170 1170,2190 2190,2310
so you're back {this,slide} with

2801
01:25:33,790 --> 01:25:35,920
0,90 90,780 840,1590
the kernel {}

2802
01:25:35,920 --> 01:25:37,360
0,360 360,660 660,900 900,1200 1200,1440
{} address space, virtual kernel

2803
01:25:37,360 --> 01:25:39,100
0,240 240,780 1110,1500 1500,1590 1590,1740
address space| and so when
|当内核分配一个 proc 和为它准备的页表，

2804
01:25:39,100 --> 01:25:40,900
0,60 60,750 780,1170 1170,1260 1260,1800
the kernel allocates a proc,

2805
01:25:41,420 --> 01:25:43,820
0,690 690,1440 1470,1680 1680,2130 2130,2400
{} and page tables for

2806
01:25:43,820 --> 01:25:44,990
0,180 180,510 510,900 900,1050 1050,1170
that particular process,| they're going
|它们会分配在内存的这里，没有使用的内存。

2807
01:25:44,990 --> 01:25:46,820
0,60 60,150 150,930 1260,1560 1560,1830
to be allocated at of

2808
01:25:46,910 --> 01:25:48,860
0,540 540,990 1050,1590 1590,1710 1710,1950
memory here, memory is not

2809
01:25:48,860 --> 01:25:50,280
0,180 180,540 540,900
being used yet.|
|

2810
01:25:50,870 --> 01:25:52,310
0,330 330,420 420,1110 1140,1320 1320,1440
And the kernel is going
内核可能会为用户程序页表分配一些页面，并填充 PTE 。

2811
01:25:52,310 --> 01:25:55,010
0,120 120,900 1230,1890 1890,2370 2370,2700
to program, {} will probably

2812
01:25:55,010 --> 01:25:56,270
0,330 330,360 360,600 600,990 990,1260
allocate a couple pages for

2813
01:25:56,270 --> 01:25:57,470
0,240 240,480 480,900 900,1110 1110,1200
the page table of the

2814
01:25:57,470 --> 01:25:58,910
0,390 390,810 810,1200 1200,1320 1320,1440
user {} process and will

2815
01:25:58,910 --> 01:26:00,640
0,300 300,390 390,480 480,1260
fill in the PTEs.|
|

2816
01:26:01,460 --> 01:26:02,630
0,270 270,390 390,600 600,930 930,1170
And at some point when
到了内核运行进程的时候，

2817
01:26:02,630 --> 01:26:04,640
0,480 510,840 840,1140 1140,1320 1320,2010
the kernel runs that process,|
|

2818
01:26:04,880 --> 01:26:07,460
0,180 180,360 360,690 690,1500 1770,2580
it will load the root
它会加载分配给页表的这些页面的根物理地址到 satp 寄存器。

2819
01:26:07,960 --> 01:26:10,000
0,300 300,630 630,1170 1200,1530 1530,2040
{} physical address for those

2820
01:26:10,060 --> 01:26:11,290
0,330 330,480 480,570 570,1110 1110,1230
pages that is allocated for

2821
01:26:11,290 --> 01:26:13,180
0,180 180,450 450,780 780,1140 1440,1890
that page table or basically

2822
01:26:13,180 --> 01:26:14,440
0,210 210,420 420,630 630,1020 1020,1260
page table that built, into

2823
01:26:14,440 --> 01:26:16,180
0,180 180,720 720,1200
the satp register.|
|

2824
01:26:16,660 --> 01:26:18,670
0,150 150,240 240,450 450,1020 1230,2010
And at that point the
那时，处理器使用内核构建给这个进程的虚拟地址空间运行。

2825
01:26:18,970 --> 01:26:21,010
0,600 600,810 810,1320 1470,1830 1830,2040
processor will run with the

2826
01:26:21,010 --> 01:26:22,270
0,390 390,660 660,1050 1050,1170 1170,1260
virtual address space that the

2827
01:26:22,270 --> 01:26:23,920
0,450 450,1050 1050,1170 1170,1320 1320,1650
kernel constructed for that particular

2828
01:26:23,920 --> 01:26:25,000
0,600
process.|
|

2829
01:26:27,140 --> 01:26:28,370
0,210 210,390 390,660 660,1020 1020,1230
{} So the kernel give
所以，内核给了进程一些内存，

2830
01:26:28,370 --> 01:26:30,350
0,510 690,990 990,1170 1170,1380 1380,1980
up some of its memory

2831
01:26:30,650 --> 01:26:32,810
0,480 480,870 870,1620 1620,1800 1800,2160
{} for processes,| and then
|但是，理论上进程的虚拟空间和内核的一样大，但是实际上不是。

2832
01:26:33,020 --> 01:26:34,880
0,150 150,300 300,420 420,1050 1080,1860
but then the virtual space

2833
01:26:34,910 --> 01:26:36,470
0,180 180,630 630,990 990,1290 1290,1560
in theory is as big

2834
01:26:36,470 --> 01:26:38,560
0,150 150,270 270,900 900,1560
for the process as

2835
01:26:38,740 --> 01:26:40,210
0,120 120,390 390,690 1170,1380 1380,1470
the kernel {}, but in

2836
01:26:40,210 --> 01:26:41,770
0,480 480,540 540,840 840,1110 1110,1560
reality it is surely not.|
|

2837
01:26:42,450 --> 01:26:44,730
0,510 510,1320 1530,1890 1890,2010 2010,2280
{} Yeah, here's a picture
是的，这里有一张图片，是用户进程的虚拟地址空间布局，

2838
01:26:44,730 --> 01:26:45,420
0,90 90,180 180,540 540,630 630,690
with the layout of {}

2839
01:26:45,420 --> 01:26:46,500
0,360 360,570 570,810 810,930 930,1080
virtual address space of a

2840
01:26:46,500 --> 01:26:48,150
0,450 450,1020 1080,1230 1230,1560 1560,1650
{user,level} process| and again it
|它也从 0 到 MAXVA ，和内核空间一样的做法，

2841
01:26:48,150 --> 01:26:49,260
0,180 180,300 300,660 660,810 810,1110
goes from zero to {MAXVA

2842
01:26:49,260 --> 01:26:50,280
0,150 150,480
- -},

2843
01:26:51,910 --> 01:26:52,780
0,180 180,270 270,480 480,660 660,870
in the same way as

2844
01:26:52,780 --> 01:26:53,820
0,510
the

2845
01:26:54,240 --> 01:26:55,950
0,330 330,510 510,750 750,1110 1530,1710
kernel address space does| and
|它有自己的页表，映射那些内核设置的转换。

2846
01:26:55,950 --> 01:26:56,910
0,150 150,510 510,660 660,750 750,960
it's basically has his own

2847
01:26:56,910 --> 01:26:57,810
0,150 150,210 210,450 450,810 810,900
set of page tables to

2848
01:26:57,810 --> 01:26:59,880
0,330 330,510 510,870 870,1380 1380,2070
map those { -} translation

2849
01:27:00,490 --> 01:27:02,040
0,240 240,300 300,570 570,1050
that the kernel {set,up}.|
|

2850
01:27:03,190 --> 01:27:04,810
0,330 330,450 450,720 720,1080 1080,1620
But we can't actually use
但是，我们不能使用所有 MAXVA 虚拟地址。

2851
01:27:04,810 --> 01:27:06,100
0,210 210,330 330,420 420,720 720,1290
all of the {MAXVA -}

2852
01:27:06,130 --> 01:27:08,110
0,540 540,660 660,1200 1500,1830 1830,1980
{virtual,address}.| {No,we} cannot, {} we
|是的，我们不能，我们会内存溢出。

2853
01:27:08,110 --> 01:27:10,080
0,240 240,360 360,450 450,840
run out of memory.|
|

2854
01:27:11,620 --> 01:27:12,760
0,240 240,480 480,570 570,660 660,1140
So many of the processes
所以，很多进程都比所有虚拟地址空间小得多。

2855
01:27:12,760 --> 01:27:14,110
0,90 90,390 390,600 600,1080 1080,1350
are much much smaller, correct,

2856
01:27:14,110 --> 01:27:15,940
0,480 840,1200 1200,1380 1380,1500 1500,1830
than all of the virtual

2857
01:27:15,940 --> 01:27:17,140
0,210 210,720
address space.|
|

2858
01:27:19,940 --> 01:27:21,420
0,60 60,300 300,750
I see, {thank,you}.|
我明白了，谢谢。|

2859
01:27:23,260 --> 01:27:24,280
0,150 150,270 270,360 360,510 510,1020
I've got a quick question.
我有一个问题。是的。

2860
01:27:24,490 --> 01:27:25,500
0,510
Yeah.|
|

2861
01:27:26,020 --> 01:27:27,010
0,360 360,660 660,750 750,810 810,990
{} Could you go back
你能回到 walk 代码吗？

2862
01:27:27,010 --> 01:27:28,900
0,90 90,210 210,630 630,1110 1440,1890
to the walk code?| Yeah
|是的，当然，它是我最喜欢的函数之一。

2863
01:27:28,930 --> 01:27:30,380
0,270 270,840
yeah absolutely,

2864
01:27:31,500 --> 01:27:32,970
0,690 690,960 960,1020 1020,1140 1140,1470
it's one of my favorite

2865
01:27:32,970 --> 01:27:35,020
0,570
functions.|
|

2866
01:27:35,280 --> 01:27:38,190
0,450 480,930 930,1110 1110,1800 2280,2910
Um, so I guess {}
我想，我不理解的是，在你写 satp 寄存器之后，

2867
01:27:38,220 --> 01:27:39,510
0,330 330,480 480,630 630,990 990,1290
one thing I'm confused about

2868
01:27:39,510 --> 01:27:41,250
0,450 660,1080 1080,1290 1290,1650 1650,1740
is after you write to

2869
01:27:41,250 --> 01:27:43,170
0,90 90,390 390,540 540,1320 1710,1920
the {satp -} register,| can
|内核能直接访问物理地址吗，

2870
01:27:43,170 --> 01:27:45,600
0,90 90,450 450,1020 1020,1620 1620,2430
the kernel even access physical

2871
01:27:45,600 --> 01:27:47,220
0,540 540,1170 1170,1320 1320,1380 1380,1620
addresses directly,| so it looks
|从代码中看起来，它转换页面到一个物理地址，

2872
01:27:47,220 --> 01:27:48,120
0,240 240,330 330,420 420,720 720,900
like in the code that

2873
01:27:48,120 --> 01:27:49,350
0,210 210,900 900,990 990,1080 1080,1230
it's converting you know like

2874
01:27:49,350 --> 01:27:50,250
0,360 360,450 450,630 630,810 810,900
page was being sent to

2875
01:27:50,250 --> 01:27:51,510
0,90 90,450 450,990 990,1110 1110,1260
a physical address,| but if
|但是，如果设置了 satp ，它不会解释为虚拟地址吗。

2876
01:27:51,510 --> 01:27:53,720
0,510 510,630 630,1650
satp is set,

2877
01:27:53,870 --> 01:27:55,520
0,630 690,930 930,1020 1020,1110 1110,1650
{} won't that be interpreted

2878
01:27:55,520 --> 01:27:57,720
0,420 450,720 720,1020 1020,1470
as a virtual address.|
|

2879
01:27:57,870 --> 01:28:01,230
0,750 900,1770 1800,2220 2430,2820 2940,3360
Yeah, {} so, {} okay,
是的，好的，让我们来看一下 hartinint ，

2880
01:28:01,230 --> 01:28:03,240
0,120 120,420 420,690 690,1020 1260,2010
so let's look at {}

2881
01:28:03,840 --> 01:28:06,800
0,570 570,720 720,990
{hartinit - -},|
|

2882
01:28:09,740 --> 01:28:10,980
0,720
so,
kvminit ，构建内核地址空间，

2883
01:28:12,160 --> 01:28:13,720
0,360 360,780 780,930 930,1290 1290,1560
{kvminit -}, so {built,the} kernel

2884
01:28:13,720 --> 01:28:15,020
0,210 210,780
address space,|
|

2885
01:28:16,340 --> 01:28:17,690
0,180 180,450 450,660 660,870 870,1350
the kernel page {table -}
内核页表初始化物理-，地址转换为物理地址，并写入 satp 寄存器，

2886
01:28:17,870 --> 01:28:19,300
0,870
{}

2887
01:28:19,850 --> 01:28:23,360
0,660 660,1290 1290,1950 2910,3420 3420,3510
initially a physical, address is

2888
01:28:23,360 --> 01:28:26,480
0,570 570,1110 1950,2520 2520,2820 2820,3120
translated to a physical address

2889
01:28:26,480 --> 01:28:27,830
0,90 90,300 300,810 810,1080 1080,1350
and that's actually written into

2890
01:28:27,830 --> 01:28:29,540
0,210 210,720 720,1230
the satp register.|
|

2891
01:28:30,380 --> 01:28:32,210
0,630 900,1080 1080,1140 1140,1290 1290,1830
{} And at that point
这时，我们使用我们构建的地址空间运行，比如 kvminit 。

2892
01:28:32,240 --> 01:28:33,170
0,120 120,240 240,360 360,720 720,930
you know we're running with

2893
01:28:33,170 --> 01:28:34,790
0,420 450,1050 1050,1350 1350,1530 1530,1620
the address space that we've

2894
01:28:34,790 --> 01:28:37,250
0,720 840,1440 1440,1950 1950,2310 2310,2460
constructed, like before here this

2895
01:28:37,250 --> 01:28:38,600
0,390 390,840
{kvminit -}.|
|

2896
01:28:39,920 --> 01:28:41,390
0,570 600,1050 1050,1110 1110,1170 1170,1470
And {kvmmap - - -}
kvmmap 只是对每个地址或每个页面调用 walk 。

2897
01:28:41,390 --> 01:28:42,800
0,90 90,450 450,690 690,990 990,1410
is basically nothing else than

2898
01:28:42,890 --> 01:28:45,040
0,690 690,1620
calling {

2899
01:28:45,040 --> 01:28:47,470
0,600 600,1170 1290,1560 1560,1890 1890,2430
-} walk for every address

2900
01:28:47,470 --> 01:28:48,670
0,240 240,450 450,900 900,1110 1110,1200
or every page and [at

2901
01:28:48,670 --> 01:28:49,800
0,60 60,600
the range].|
|

2902
01:28:50,340 --> 01:28:51,180
0,360 360,450 450,630 630,720 720,840
And so what was your
所以，你的问题是什么？

2903
01:28:51,180 --> 01:28:52,860
0,570 570,1080
question {}?|
|

2904
01:28:53,660 --> 01:28:55,670
0,270 270,450 450,720 720,1200 1710,2010
Um I guess, it's does
我想，在设置 satp 之后，它仍然使用相同方式运行。

2905
01:28:55,670 --> 01:28:57,230
0,510 510,870 870,1140 1140,1260 1260,1560
walks still work the same

2906
01:28:57,230 --> 01:28:58,160
0,210 210,330 330,450 450,780 780,930
way if you call it

2907
01:28:58,160 --> 01:29:00,260
0,570 570,900 900,1320 1320,1680 1710,2100
after {satp -} is set.|
|

2908
01:29:00,590 --> 01:29:02,400
0,600 600,1260
Yeah, why.|
是的，为什么。|

2909
01:29:03,360 --> 01:29:04,560
0,810

2910
01:29:04,590 --> 01:29:06,630
0,1290 1290,1410 1410,1620 1620,1890 1920,2040
Why we work out, the
为什么能够成功，能成功的原因是内核（页表）设置是恒等映射。

2911
01:29:06,630 --> 01:29:07,530
0,270 270,330 330,510 510,720 720,900
reason it {} work out,

2912
01:29:07,530 --> 01:29:08,520
0,90 90,360 360,450 450,750 750,990
is because the kernel {set,up}

2913
01:29:08,520 --> 01:29:10,880
0,90 90,480 480,930
an identity mapping.|
|

2914
01:29:11,380 --> 01:29:13,540
0,930 930,1470
Um, okay,
好的，是的，是的。

2915
01:29:13,710 --> 01:29:16,950
0,600 660,1110 1410,1890 1890,2490 2700,3240
right, right.| Very important, very
|很重要，很好的问题，很多事情可以成功，因为这是设置的恒等映射。

2916
01:29:16,950 --> 01:29:19,170
0,120 120,510 1650,1890 1890,2130 2130,2220
good question, a lot of

2917
01:29:19,170 --> 01:29:20,250
0,270 270,450 450,750 750,840 840,1080
things just happened to work

2918
01:29:20,250 --> 01:29:21,570
0,240 240,480 480,780 780,870 870,1320
out, because actually the identity

2919
01:29:21,570 --> 01:29:22,880
0,300 300,390 390,540 540,750
mapping is set up.|
|

2920
01:29:24,650 --> 01:29:26,320
0,390 390,1050
I see,
我明白了，好的，我想我理解了，是的。

2921
01:29:26,320 --> 01:29:27,460
0,570 600,690 690,900 900,990 990,1140
okay I think that makes

2922
01:29:27,460 --> 01:29:30,280
0,270 270,870
sense, yeah.|
|

2923
01:29:31,360 --> 01:29:32,320
0,120 120,240 240,240 240,480 480,960
I have a quick question,
我有一个问题， satp 在哪里存放所有进程的（页表地址）。

2924
01:29:32,470 --> 01:29:34,750
0,510 720,990 990,1620 1620,2040 2040,2280
{ -} where the {satp

2925
01:29:34,750 --> 01:29:36,790
0,570 570,1140 1140,1590 1590,1830 1830,2040
-} registers stored for all

2926
01:29:36,790 --> 01:29:38,400
0,120 120,210 210,1050
of the processes.|
|

2927
01:29:38,460 --> 01:29:40,770
0,930 930,1140 1140,1500 1500,2070 2070,2310
There only one satp per
每个核心只有一个 satp ，但是在每个 proc 结构体中。

2928
01:29:40,770 --> 01:29:41,880
0,540
core,

2929
01:29:42,030 --> 01:29:43,350
0,300 300,570 570,780 780,1020 1020,1320
{} but in every proc

2930
01:29:43,350 --> 01:29:44,540
0,690
structure.|
|

2931
01:29:44,780 --> 01:29:46,000
0,660
Okay.|
好的。|

2932
01:29:46,330 --> 01:29:47,560
0,360 360,600 600,780 780,840 840,1230
If you look at {proc.h
如果你查看 proc.h ，这里有一个指向页表的指针。

2933
01:29:47,560 --> 01:29:48,660
0,450
-},

2934
01:29:48,980 --> 01:29:50,920
0,330 330,600 600,870 870,1410
{} there is {}

2935
01:29:52,740 --> 01:29:55,170
0,1320 1380,1950 1950,2040 2040,2160 2160,2430
a pointer to the page

2936
01:29:55,170 --> 01:29:57,480
0,420 510,930 990,1500 1590,1920 1920,2310
table, you're.| Okay, makes sense.|
|好的，理解了。|

2937
01:29:58,440 --> 01:30:01,200
0,420 420,1020 1800,2160 2250,2670 2670,2760
And also, with regards to
也是关于三级页表，

2938
01:30:01,200 --> 01:30:03,570
0,150 150,870 900,1680 1680,2220 2220,2370
the three page tables,| are
|三级页表可以组成完整的地址，

2939
01:30:03,570 --> 01:30:05,580
0,330 330,690 720,1230 1230,1650 1650,2010
like the three tables that

2940
01:30:05,790 --> 01:30:07,350
0,360 360,810 810,900 900,1170 1170,1560
can complete the full address

2941
01:30:07,350 --> 01:30:08,160
0,90 90,300 300,450 450,720 720,810
and help you get a

2942
01:30:08,160 --> 01:30:10,620
0,210 210,600 600,1020 1620,2010 2010,2460
full address for [] something,|
|

2943
01:30:11,040 --> 01:30:12,540
0,390 480,780 780,1080 1080,1380 1380,1500
{} how does how is
它比使用一个大页表好的地方是什么，我没有完全理解。

2944
01:30:12,540 --> 01:30:13,980
0,210 210,630 630,750 750,1080 1080,1440
that better, I guess than

2945
01:30:13,980 --> 01:30:16,290
0,240 240,870 1050,1530 1530,2040 2040,2310
than having one giant page

2946
01:30:16,290 --> 01:30:17,370
0,300 300,360 360,540 570,810 810,1080
table, I didn't really fully

2947
01:30:17,370 --> 01:30:19,950
0,510 510,630 690,2040 2040,2220 2220,2580
understand.| Good, a good question,|
|好的，一个好问题，|

2948
01:30:20,040 --> 01:30:21,480
0,420 420,750 750,1110 1110,1350 1350,1440
the reason is because in
因为在三级页表中，你可以把很多条目留空，

2949
01:30:21,480 --> 01:30:22,590
0,120 120,270 270,540 540,750 750,1110
the three level page table,

2950
01:30:22,590 --> 01:30:23,310
0,120 120,300 300,480 480,510 510,720
you can leave a lot

2951
01:30:23,310 --> 01:30:24,540
0,120 120,420 420,900
of entries empty,|
|

2952
01:30:25,060 --> 01:30:26,410
0,510 540,600 600,1050 1050,1170 1170,1350
so, for example if you
比如，如果你把顶级页表目录中的条目留空，

2953
01:30:26,410 --> 01:30:28,090
0,450 480,1080 1110,1530 1530,1590 1590,1680
leave the entry in the

2954
01:30:28,090 --> 01:30:29,830
0,300 300,510 510,750 750,1290 1320,1740
top level page table directory

2955
01:30:29,830 --> 01:30:31,120
0,540 690,840 840,1020 1020,1200 1200,1290
empty,| you don't have to
|你就不需要为这些条目创建中级页表或底部页表。

2956
01:30:31,120 --> 01:30:33,130
0,540 540,840 840,1230 1230,1470 1470,2010
create middle level page tables

2957
01:30:33,160 --> 01:30:34,450
0,270 270,540 540,750 750,960 960,1290
or bottom level page tables

2958
01:30:34,450 --> 01:30:36,070
0,90 90,450 690,840 840,1050 1050,1620
at all, for those entries.|
|

2959
01:30:37,070 --> 01:30:38,270
0,270 270,480 480,720 720,900 900,1200
And so like this means
这意味着整个虚拟地址空间的[]根本不需要任何映射。

2960
01:30:38,270 --> 01:30:39,950
0,150 150,240 240,600 600,1320 1500,1680
like a big [] of

2961
01:30:39,950 --> 01:30:41,180
0,90 90,420 420,720 720,960 960,1230
the whole virtual address space

2962
01:30:41,180 --> 01:30:42,200
0,270 270,420 420,510 510,750 750,1020
doesn't have to have any

2963
01:30:42,200 --> 01:30:43,760
0,480 480,630 630,1020
mapping at all.|
|

2964
01:30:44,860 --> 01:30:46,360
0,570 600,840 840,930 930,1290 1290,1500
Okay, okay.| You don't have
好的，好的。|你不需要表，它不存在。

2965
01:30:46,360 --> 01:30:47,350
0,60 60,390 390,690 720,840 840,990
the table there, it just

2966
01:30:47,350 --> 01:30:48,580
0,210 210,660
doesn't exist.|
|

2967
01:30:48,840 --> 01:30:51,150
0,150 150,390 390,1080 1140,1920 1950,2310
I see, basically allocating these
我明白了，按需分配这些块，[]，好的，理解了。

2968
01:30:51,150 --> 01:30:53,370
0,450 450,690 690,1320 1350,1770 1800,2220
chunks on demand, {[] -

2969
01:30:53,370 --> 01:30:54,750
0,90 90,360 510,900 960,1170 1170,1380
- -}, Okay that makes

2970
01:30:54,750 --> 01:30:56,160
0,390 420,630 630,750 750,1080 1080,1410
sense.| Yeah, you're starting basically
|是的，你从三个页面开始，一个顶级，一个中级，一个底部，

2971
01:30:56,160 --> 01:30:58,110
0,180 180,630 720,1080 1080,1560 1560,1950
with three page, three pages

2972
01:30:58,110 --> 01:30:58,980
0,300 300,480 480,570 570,630 630,870
namely, one for the top

2973
01:30:58,980 --> 01:31:00,570
0,240 240,510 510,840 840,1080 1080,1590
level, one for one intermediate,

2974
01:31:00,570 --> 01:31:02,550
0,300 300,600 600,1080 1200,1560 1560,1980
one {}, one bottom level|
|

2975
01:31:03,180 --> 01:31:04,350
0,390 390,570 570,720 720,840 840,1170
and then as you go
然后根据需要，可以创建更多的页表目录。

2976
01:31:04,350 --> 01:31:05,700
0,210 210,510 510,720 720,960 960,1350
you create more page table

2977
01:31:05,700 --> 01:31:06,740
0,660
directories.|
|

2978
01:31:06,740 --> 01:31:08,560
0,450 480,870 930,1260
Okay, okay, cool.|
好的，好的，酷。|

2979
01:31:09,140 --> 01:31:10,220
0,300 300,510 510,600 600,690 690,1080
Cool, thank you so much.
太好了，非常感谢。不用谢。

2980
01:31:10,400 --> 01:31:11,480
0,570
{You're,welcome}.|
|

2981
01:31:12,930 --> 01:31:14,540
0,240 240,420 420,1080
Any more questions?|
还有别的问题吗？|

2982
01:31:14,690 --> 01:31:15,710
0,240 240,450 450,510 510,690 690,1020
Um, sorry I have another
抱歉，我有另一个问题，一个很小的问题，

2983
01:31:15,710 --> 01:31:17,900
0,300 300,720 780,1440 1470,1770 1770,2190
one, it's really really small,|
|

2984
01:31:17,900 --> 01:31:20,360
0,360 390,870 900,1110 1110,1620 1650,2460
but {} in the {vm.c
但是在 vm.c 的第 43 行，第 41 行，

2985
01:31:20,660 --> 01:31:22,430
0,330 330,870 870,1140 1140,1470 1470,1770
- -} on line {43

2986
01:31:22,430 --> 01:31:26,150
0,600 1860,2370 2370,2850 2970,3240 3240,3720
-} {41 -} { -}|
|

2987
01:31:27,140 --> 01:31:28,640
0,180 180,630 630,1020
it says that,
它说，不，应该是 43 行，我的错，

2988
01:31:28,820 --> 01:31:30,260
0,180 180,390 390,630 630,1230 1260,1440
no, it might 43, my

2989
01:31:30,260 --> 01:31:32,690
0,390 420,1020 1440,1620 1620,1950 1950,2430
bad,| {} it says {PHYSTOP
|它说 PHYSTOP-(uint64)etext ，

2990
01:31:32,690 --> 01:31:35,750
0,480 510,1320 1650,1920 1920,2250 2250,3060
-} minus {} {uint64 -}

2991
01:31:35,810 --> 01:31:37,790
0,150 150,720 780,1320 1320,1620 1620,1980
{etext -},| but wouldn't that,
|但是它不会访问我们不应该访问的内存吗，

2992
01:31:38,370 --> 01:31:40,320
0,270 270,510 510,930 960,1410 1410,1950
would that go over the,

2993
01:31:41,100 --> 01:31:42,690
0,420 450,570 570,840 840,930 930,1590
{} I guess the memory

2994
01:31:42,720 --> 01:31:45,570
0,450 540,780 780,1410 1950,2280 2280,2850
that we shouldn't {} touch,|
|

2995
01:31:45,600 --> 01:31:46,620
0,270 270,420 420,570 570,840 840,1020
I don't know if that
我不知道有没有道理，但是会这样吗，

2996
01:31:46,620 --> 01:31:48,600
0,210 210,450 450,750 900,1470
makes sense, but {}

2997
01:31:48,600 --> 01:31:50,580
0,270 270,660 840,1440
wouldn't that go,|
|

2998
01:31:51,220 --> 01:31:52,870
0,120 120,360 360,390 390,720 900,1650
I guess I don't understand
我想我不理解它会不会访问到空闲内存。

2999
01:31:52,870 --> 01:31:53,980
0,270 270,390 390,540 540,780 780,1110
would they go over free

3000
01:31:53,980 --> 01:31:55,280
0,750
memory.|
|

3001
01:31:55,790 --> 01:31:58,490
0,630 660,2040 2040,2460 2460,2580 2580,2700
{} No, I don't think
不，我不这么认为， KERNBASE 0x8000 ，是内核在内存的起始位置，

3002
01:31:58,490 --> 01:32:00,920
0,300 300,1140 1410,1680 1680,1980 1980,2430
so, {} so {KERNBAE -}

3003
01:32:00,920 --> 01:32:02,600
0,150 150,660 660,1050 1050,1440 1440,1680
{0x8000 - - - -

3004
01:32:02,600 --> 01:32:04,010
0,240 240,660 690,1050 1080,1230 1230,1410
- -} right, so that's

3005
01:32:04,010 --> 01:32:06,060
0,90 90,660 720,1050 1050,1560
the beginning of memory

3006
01:32:06,090 --> 01:32:09,120
0,480 480,1500 1500,1770 1770,2310 2340,3030
{} {in,kernel} sits there| and
|基本上，这个东西是一个大小，

3007
01:32:09,450 --> 01:32:12,360
0,480 480,1590 1890,2400
{} basically {}

3008
01:32:12,470 --> 01:32:14,150
0,480 480,780 780,930 930,990 990,1680
this thing is a size,

3009
01:32:15,080 --> 01:32:16,250
0,240 240,390 390,390 390,990 990,1170
right,| so {etext -} is
|etext 是内核的最后一个地址，减去 KERNBASE ，得到内核的大小，

3010
01:32:16,250 --> 01:32:17,360
0,180 180,600 600,930 930,1020 1020,1110
the last address of the

3011
01:32:17,360 --> 01:32:19,760
0,630 930,1560 1560,1830 1830,2250 2250,2400
kernel, subtract {KERNBASE -} that

3012
01:32:19,760 --> 01:32:20,390
0,150 150,240 240,420 420,540 540,630
this will give you the

3013
01:32:20,390 --> 01:32:22,120
0,330 330,420 420,480 480,1170
size of the kernel

3014
01:32:22,710 --> 01:32:26,520
0,810 810,1410 1440,2460 2460,3120
{} in {} {in,byte}.|
|

3015
01:32:26,520 --> 01:32:28,020
0,750 750,870 870,1110 1110,1200 1200,1500
And you know, I {don't,know}
我不知道是多少，但是可能是 60 或 90 个页。

3016
01:32:28,020 --> 01:32:28,890
0,120 120,360 360,480 480,750 750,870
how much it is, but

3017
01:32:28,890 --> 01:32:30,900
0,660 990,1440 1440,1680 1680,1890 1890,2010
yeah yeah it's like you

3018
01:32:30,900 --> 01:32:32,190
0,90 90,510 510,570 570,900 900,1290
know sixty or ninety pages

3019
01:32:32,190 --> 01:32:33,680
0,90 90,330 330,510 510,870
or something like that.|
|

3020
01:32:34,300 --> 01:32:35,560
0,330 330,630 630,750 750,960 960,1260
{} And so this map
所以这个映射是内核文本。

3021
01:32:35,560 --> 01:32:36,850
0,210 210,570 570,690 690,1020 1020,1290
is basically the text part

3022
01:32:36,850 --> 01:32:38,080
0,90 90,180 180,720
of the kernel.|
|

3023
01:32:38,350 --> 01:32:42,430
0,660 1050,2520 2790,3210 3210,3450 3450,4080
{} And there's enough space,
这里有足够的空间，有足够的 DRAM 来映射内核文本。

3024
01:32:43,300 --> 01:32:45,190
0,450 450,720 720,930 930,1470 1560,1890
{} there's enough DRAM there

3025
01:32:45,190 --> 01:32:46,620
0,150 150,510 510,870
to map that,

3026
01:32:47,560 --> 01:32:48,860
0,120 120,360 360,750
the kernel text.|
|

3027
01:32:48,860 --> 01:32:49,730
0,90 90,270 270,480 480,600 600,870
I'm not sure I'm answering
我不确定我回答了你的问题，但是。

3028
01:32:49,730 --> 01:32:52,310
0,120 120,510 510,810 1410,2370 2370,2580
your question, but.| Oh, I
|我想，我理解了，我以为 etext 是从某个地方开始的，

3029
01:32:52,310 --> 01:32:53,600
0,360 420,540 540,720 720,750 750,1290
think, I think I understand,

3030
01:32:54,020 --> 01:32:55,670
0,180 180,420 420,780 930,1050 1050,1650
I thought that {etext -}

3031
01:32:55,850 --> 01:32:57,770
0,810 810,1230 1230,1530 1530,1830 1830,1920
starts somewhere else,| okay I
|好的，我想我理解了，谢谢。

3032
01:32:57,770 --> 01:32:58,940
0,150 150,180 180,480 480,720 750,1170
think I understand now, thank

3033
01:32:58,940 --> 01:33:00,290
0,210 210,540 540,900 900,1020 1020,1350
you.| {Okay,so,etext}, basically the last
|好的， etext 是内核最后一条指令的地址。

3034
01:33:00,290 --> 01:33:01,640
0,780 780,870 870,1170 1170,1260 1260,1350
instruction, the address of the

3035
01:33:01,640 --> 01:33:02,870
0,270 270,690 690,750 750,810 810,1230
last instruction of the kernel.|
|

3036
01:33:03,670 --> 01:33:04,770
0,690 750,1020
Okay, okay.
好的，好的。
