1
00:00:07,470 --> 00:00:09,440
0,1230
Alright,
好的，你们能听到我说话吗？

2
00:00:09,840 --> 00:00:10,890
0,150 150,240 240,420 420,630 630,1050
can you guys hear me?|
|

3
00:00:13,190 --> 00:00:14,360
0,630
Yes.|
是的。|

4
00:00:14,750 --> 00:00:16,370
0,330 330,450 1020,1380 1380,1560 1560,1620
Thank you.| Alright, today I
谢谢。|好的，今天我主要想说的是微内核，

5
00:00:16,370 --> 00:00:17,390
0,150 150,210 210,420 420,810 810,1020
want to talk about talk

6
00:00:17,390 --> 00:00:20,630
0,270 270,480 480,780 780,1410 2160,3240
mostly about micro kernels,| but
|首先，我们来了解一些背景，

7
00:00:20,630 --> 00:00:21,650
0,240 240,300 300,510 510,720 720,1020
first a little bit of

8
00:00:21,650 --> 00:00:23,980
0,330 360,1170 1170,1440 1440,1860
{} context| to {}
|以帮助解释

9
00:00:24,430 --> 00:00:25,450
0,240 240,300 300,480 480,780 780,1020
sort of help explain| why
|为什么人们一开始会探索微内核，

10
00:00:25,450 --> 00:00:27,460
0,630 840,1350 1350,1590 1590,1950 1950,2010
people explored micro kernels in

11
00:00:27,460 --> 00:00:30,190
0,90 90,330 330,750 1110,1530 1830,2730
the first place,| {} this
|人们获得微内核，

12
00:00:30,190 --> 00:00:31,420
0,570
{}

13
00:00:31,900 --> 00:00:33,370
0,660 660,840 840,900 900,1140 1140,1470
people got the micro kernels|
|

14
00:00:33,370 --> 00:00:34,660
0,120 120,360 360,450 450,780 780,1290
by trying to think about
试着广泛地思考内核应该做什么，

15
00:00:35,260 --> 00:00:37,360
0,390 390,750 750,1110 1110,1470 1590,2100
{} more broadly about what

16
00:00:37,360 --> 00:00:39,190
0,510 510,690 690,1020 1020,1620 1650,1830
kernels should actually do,| like
|就像我们在 xv6 中，

17
00:00:39,190 --> 00:00:40,210
0,330 420,540 540,660 660,840 840,1020
we've you know with {xv6

18
00:00:40,210 --> 00:00:41,740
0,120 120,510 510,630 1020,1380 1380,1530
- -},| is sort of
|某种程度上，做 Unix 所做的事情，

19
00:00:41,980 --> 00:00:43,270
0,480 480,570 570,840 840,960 960,1290
does the things that Unix

20
00:00:43,270 --> 00:00:44,080
0,390 390,480 480,570 570,750 750,810
does| and we kind of
|我们采用了这组抽象概念和系统调用，

21
00:00:44,080 --> 00:00:45,140
0,540
take

22
00:00:45,320 --> 00:00:47,090
0,450 450,690 690,930 930,1020 1020,1770
{} that set of abstractions

23
00:00:47,090 --> 00:00:49,070
0,90 90,450 450,930 930,1230 1710,1980
and system calls| and keep
|并保留了内核中的设施，

24
00:00:49,100 --> 00:00:50,450
0,270 270,360 360,1050 1050,1290 1290,1350
sort of facilities inside the

25
00:00:50,450 --> 00:00:52,340
0,390 390,570 570,780 1050,1410 1410,1890
kernels,| kind of for granted
|理所当然是我们试图设计的目标，

26
00:00:52,340 --> 00:00:54,170
0,180 180,420 750,1440 1440,1530 1530,1830
is the target of what

27
00:00:54,170 --> 00:00:55,160
0,90 90,270 270,330 330,780 780,990
we're trying to design,| but
|但是完全值得怀疑，

28
00:00:56,470 --> 00:00:58,690
0,450 450,750 750,1140 1140,1740 1770,2220
it's totally worth wondering,| gosh,
|天哪，内核首先应该做什么，

29
00:00:58,690 --> 00:00:59,590
0,270 270,450 450,480 480,780 780,900
what should a kernel do

30
00:00:59,590 --> 00:01:00,790
0,90 90,150 150,450 450,780 780,1200
in the first place,| maybe
|也许是 xv6 或 Linux 所做的特定类型的事情，

31
00:01:01,640 --> 00:01:02,630
0,300 300,390 390,750 750,930 930,990
maybe the particular kind of

32
00:01:02,630 --> 00:01:03,620
0,240 240,360 360,540 540,660 660,990
stuff that {xv6 - -}

33
00:01:03,620 --> 00:01:05,780
0,90 90,480 480,1260 1290,1740 1740,2160
or Linux does,| {} it's
|这不是最好的答案，

34
00:01:05,780 --> 00:01:07,130
0,240 240,420 420,510 510,780 780,1350
not really the best answer,|
|

35
00:01:07,160 --> 00:01:09,350
0,90 90,360 360,900 1170,1740 1980,2190
or maybe {it,is}.| And of
或者它是。|当然，我们这里的处境有些危险，

36
00:01:09,350 --> 00:01:11,630
0,570 990,1320 1320,1590 1590,1860 1860,2280
course we're on somewhat treacherous

37
00:01:11,630 --> 00:01:13,250
0,330 330,630 630,1290 1290,1440 1440,1620
ground here,| because now we're
|因为现在我们，

38
00:01:13,310 --> 00:01:15,470
0,870 960,1170 1170,1650 1650,2040 2040,2160
we're,| what kernels are is
|内核是一种为程序员的开发平台，

39
00:01:15,470 --> 00:01:17,030
0,180 180,240 240,330 330,960 960,1560
kind of a development platform

40
00:01:17,030 --> 00:01:18,770
0,120 120,960 1140,1470 1470,1560 1560,1740
for programmers,| as we know,|
|正如我们所知，|

41
00:01:18,770 --> 00:01:21,170
0,750 750,1050 1050,1350 1350,1830 1920,2400
programmers different people have very
程序员，不同的人有非常不同的主观偏好，

42
00:01:21,170 --> 00:01:24,140
0,750 1080,1560 1590,1860 1860,2010 2010,2970
different {} sort of subjective

43
00:01:24,140 --> 00:01:26,360
0,750 750,1200 1590,1770 1770,2010 2010,2220
preferences| about {} what kind
|他们喜欢在什么样的基础设施上编程。

44
00:01:26,360 --> 00:01:27,440
0,90 90,690 690,810 810,990 990,1080
of infrastructure they like to

45
00:01:27,440 --> 00:01:28,900
0,450 450,660 660,810 810,1080
program on.| So we
|所以我们不一定要期待一个最好的答案，

46
00:01:28,900 --> 00:01:30,730
0,300 300,990 990,1410 1410,1470 1470,1830
can't necessarily expect a single

47
00:01:30,730 --> 00:01:32,980
0,300 300,870 1230,1650
best answer {},|
|

48
00:01:33,270 --> 00:01:34,380
0,330 330,450 450,570 570,900 900,1110
but we can expect to
但是我们可以期望学到一些东西，

49
00:01:34,410 --> 00:01:36,060
0,240 240,480 480,1020 1200,1500 1500,1650
maybe learn something,| {} and
|或许可以取得一些进展，

50
00:01:36,060 --> 00:01:37,590
0,240 240,450 450,570 570,1140 1140,1530
maybe make some progress| by
|通过努力想一想可能的答案。

51
00:01:37,770 --> 00:01:38,700
0,360 360,420 420,570 570,750 750,930
trying to think about what

52
00:01:38,700 --> 00:01:41,070
0,330 330,510 510,810 1920,2130 2130,2370
answers might be.| So first
|所以首先，

53
00:01:41,070 --> 00:01:42,240
0,60 60,540 570,930 930,990 990,1170
of all,| let me try
|让我试着明确传统的方法，

54
00:01:42,240 --> 00:01:45,540
0,300 300,1410 1440,1860 1860,2370 2400,3300
to crystallize what the traditional

55
00:01:45,540 --> 00:01:48,600
0,960 960,1650 2400,2850 2850,3000 3000,3060
approaches| to what kind of
|我们应该使用什么样的内核接口，

56
00:01:48,600 --> 00:01:50,070
0,360 360,1170 1200,1290 1290,1410 1410,1470
kernel interfaces we ought to

57
00:01:50,070 --> 00:01:52,860
0,120 120,480 690,1350 1380,2430 2430,2790
be using| and Linux and
|Linux ， Unix 和 xv6 都是例子，

58
00:01:52,860 --> 00:01:54,030
0,510 510,630 630,780 780,930 930,1170
Unix and {xv6 - -}

59
00:01:54,030 --> 00:01:55,400
0,150 150,270 270,780 780,930
are all examples of,|
|

60
00:01:55,400 --> 00:01:58,130
0,420 1290,1590 1590,1710 1710,2220 2220,2730
of what I personally call
我个人所说的传统设计方法的例子，

61
00:01:58,190 --> 00:02:00,740
0,420 600,1230 1230,1590 1590,2220 2250,2550
a traditional design approach,| but
|但是用另一个词来形容它，

62
00:02:01,160 --> 00:02:02,390
0,450 450,780 780,960 960,1080 1080,1230
another word for it,| that
|那是一种概括，

63
00:02:02,390 --> 00:02:05,160
0,150 150,240 240,1230 1620,2160
kind of summarizes {},|
|

64
00:02:05,160 --> 00:02:06,090
0,150 150,300 300,570 570,690 690,930
but this approach has ended
这种方法最终像是宏大而单一的。

65
00:02:06,090 --> 00:02:09,160
0,150 150,360 360,750 750,1650
up like is monolithic.|
|

66
00:02:09,900 --> 00:02:11,500
0,60

67
00:02:13,510 --> 00:02:15,580
0,180 180,780 810,1440
{} Monolithic.| And
宏大而单一的。|这意味着内核是一个单一的大程序，

68
00:02:15,920 --> 00:02:17,060
0,270 270,510 510,660 660,990 990,1140
{} what that means is

69
00:02:17,060 --> 00:02:18,470
0,330 360,600 600,1110 1110,1320 1320,1410
that the kernel is a

70
00:02:18,470 --> 00:02:20,390
0,390 390,990 990,1500 1500,1620 1620,1920
single big program,| that does
|它可以做各种各样的事情，

71
00:02:20,390 --> 00:02:22,310
0,180 180,480 480,570 570,1260 1440,1920
all kinds of things,| all
|都在同一个程序内。

72
00:02:22,310 --> 00:02:25,260
0,270 270,330 330,600 600,1140
within the same program.|
|

73
00:02:25,470 --> 00:02:27,840
0,330 510,1110 1110,1350 1350,1590 1590,2370
And indeed this really reflects|
事实上，这确实反映了|

74
00:02:27,840 --> 00:02:28,980
0,120 120,270 270,570 570,810 810,1140
the way people thought about
人们对内核应该做什么的想法，

75
00:02:29,670 --> 00:02:30,570
0,210 210,600 600,720 720,780 780,900
what kernels ought to be

76
00:02:30,570 --> 00:02:32,820
0,420 480,840 840,990 990,1650 1650,2250
doing| a real hallmark of
|像 Linux 这样的内核的一个特点是，

77
00:02:33,480 --> 00:02:36,030
0,480 480,930 1290,1980 1980,2250 2250,2550
kernels like Linux is| that
|它们提供了强大的抽象，

78
00:02:36,120 --> 00:02:39,210
0,330 330,750 780,930 930,1770 2400,3090
they have, they provide powerful

79
00:02:39,210 --> 00:02:41,340
0,1260 1350,1500 1500,1590 1590,1770 1770,2130
abstractions,| you know they choose
|他们选择像文件系统这样的东西，

80
00:02:41,340 --> 00:02:44,010
0,240 240,510 540,1260 1260,2280 2280,2670
things like file systems| and
|这是一个复杂的项目，

81
00:02:44,010 --> 00:02:45,390
0,210 210,390 390,570 570,660 660,1380
which is really a complicated

82
00:02:45,390 --> 00:02:46,480
0,600
item,|
|

83
00:02:46,480 --> 00:02:47,980
0,390 510,780 780,870 870,1170 1170,1500
{} and they present file
它们提供文件系统，

84
00:02:47,980 --> 00:02:49,750
0,390 390,510 510,1020 1020,1110 1110,1770
systems| and files and directories
|文件、目录和文件描述符作为它们的接口，

85
00:02:49,750 --> 00:02:51,970
0,90 90,420 420,1320 1410,1950 1950,2220
and file descriptors as their

86
00:02:51,970 --> 00:02:53,710
0,600 600,840 840,1020 1020,1140 1140,1740
interface,| rather than for example
|而不是将磁盘硬件作为它们与应用程序的接口，

87
00:02:53,770 --> 00:02:57,250
0,870 960,2220 2220,2880 2880,3030 3030,3480
presenting {disk,hardware,as -} their interface

88
00:02:57,250 --> 00:03:00,010
0,90 90,1200 1230,1530 1920,2400 2430,2760
to applications,| so, {} and
|所以，使用强大的抽象，

89
00:03:00,910 --> 00:03:03,550
0,990 990,1350 1350,1830 1830,2400 2400,2640
using presenting powerful abstractions| instead
|而不是非常低级别的抽象有一些很大的优势，

90
00:03:03,550 --> 00:03:04,900
0,60 60,240 240,690 690,1230 1230,1350
of very low-level abstractions has

91
00:03:04,900 --> 00:03:07,750
0,90 90,270 270,1050 1320,1860 2250,2850
some big advantages,| {} monolithic
|宏内核通常有一种很大的抽象，

92
00:03:07,750 --> 00:03:09,160
0,300 300,570 570,960 990,1230 1230,1410
kernels often have a sort

93
00:03:09,160 --> 00:03:11,760
0,240 240,780 1050,2250
of big abstractions,|
|

94
00:03:13,030 --> 00:03:14,500
0,870

95
00:03:17,150 --> 00:03:18,340
0,600
like,
比如，文件系统。

96
00:03:18,570 --> 00:03:21,180
0,420 420,510 510,840 840,1320
file, the file system.|
|

97
00:03:21,180 --> 00:03:22,320
0,150 150,510 510,570 570,720 720,1140
One advantage of big abstract
大的抽象的一个优点是

98
00:03:22,320 --> 00:03:24,060
0,270 270,540 540,720 720,1050 1050,1740
is| that they're often portable
|它们通常是可移植的文件和目录，

99
00:03:24,420 --> 00:03:26,310
0,420 480,600 600,1170 1170,1260 1260,1890
{} of files and directories,|
|

100
00:03:26,310 --> 00:03:27,840
0,120 120,420 780,1170 1170,1440 1440,1530
you can implement files and
你可以在所有类型的存储上实现文件和目录，

101
00:03:27,840 --> 00:03:29,010
0,450 450,630 630,810 810,1110 1110,1170
directories on all kinds of

102
00:03:29,010 --> 00:03:32,850
0,930 1800,2100 2730,3360 3360,3690 3690,3840
storage| and file you can
|你可以使用文件和目录，

103
00:03:32,850 --> 00:03:34,200
0,210 210,480 480,570 570,960 960,1350
use files and directories,| []
|而不必担心运行的磁盘的品牌，

104
00:03:34,200 --> 00:03:35,550
0,270 270,360 360,630 630,930 960,1350
having to worry about what

105
00:03:35,550 --> 00:03:36,900
0,390 390,540 540,930 930,1200 1200,1350
brand of disk drive is

106
00:03:36,900 --> 00:03:38,160
0,270 270,600 600,810 840,1140 1140,1260
running on| or maybe it's
|或者它可能是固态硬盘而不是硬盘，

107
00:03:38,160 --> 00:03:39,210
0,120 120,630 630,900 900,960 960,1050
an ssd instead of a

108
00:03:39,210 --> 00:03:40,380
0,270 270,570 570,750 780,1050 1050,1170
hard drive,| or maybe it's
|或者它可能是一个网络文件系统，

109
00:03:40,380 --> 00:03:41,430
0,60 60,420 420,690 690,960 960,1050
a network file system| and
|所有的接口都是一样的，

110
00:03:41,430 --> 00:03:42,450
0,150 150,270 270,330 330,600 600,1020
all its the same interface,|
|

111
00:03:42,450 --> 00:03:44,310
0,450 810,1080 1080,1320 1320,1560 1560,1860
because the file system interface
因为文件系统接口非常抽象。

112
00:03:44,310 --> 00:03:45,600
0,120 120,480 480,690 690,1020 1020,1290
is pretty high level pretty

113
00:03:45,600 --> 00:03:47,800
0,720 930,1440 1440,1830
abstract.| {} So,
|所以，这样做的一个好处是，

114
00:03:47,800 --> 00:03:49,000
0,420 420,750 750,840 840,1050 1050,1200
an advantage of this is|
|

115
00:03:49,000 --> 00:03:51,130
0,180 180,540 1260,1830 1830,1920 1920,2130
that the way to get
获得可移植性的方法，

116
00:03:51,130 --> 00:03:52,520
0,750
portability,|
|

117
00:03:52,520 --> 00:03:53,630
0,270 270,330 330,870 870,990 990,1110
write an application and have
编写应用程序并使其在各种不同的硬件上运行，

118
00:03:53,630 --> 00:03:55,280
0,60 60,330 330,600 1140,1380 1380,1650
it run on all kinds

119
00:03:55,280 --> 00:03:56,450
0,60 60,300 300,720 720,960 960,1170
of different hardware| without having
|而不必修改应用程序。

120
00:03:56,450 --> 00:04:00,060
0,60 60,540 540,1110 1650,2430
to modify the application.|
|

121
00:04:00,150 --> 00:04:01,230
0,390 390,690 690,750 750,960 960,1080
Another example of this is
另一个例子是，

122
00:04:01,230 --> 00:04:05,070
0,330 630,1230 1770,2730 2730,3420 3450,3840
that| {} Unix Linux provides
|Unix Linux 提供了地址空间抽象。

123
00:04:05,070 --> 00:04:07,830
0,90 90,480 480,1410 1560,2430 2430,2760
an address space abstraction| rather
|而不是提供一些东西，

124
00:04:07,830 --> 00:04:10,140
0,180 180,810 840,1230 1230,1620 1620,2310
than providing something that's likes,|
|

125
00:04:10,230 --> 00:04:11,670
0,210 210,330 330,690 690,1050 1050,1440
rather than providing direct access
而不是提供对 MMU 硬件的直接访问，

126
00:04:11,670 --> 00:04:13,680
0,120 120,240 240,600 600,1140 1590,2010
to the MMU hardware| and
|对于可移植性有用，

127
00:04:14,070 --> 00:04:15,720
0,420 420,810 810,1140
that's useful {}

128
00:04:15,810 --> 00:04:17,070
0,150 150,900 900,1020 1020,1200 1200,1260
for portability| and sort of
|并且对应用程序隐藏了复杂性。

129
00:04:17,070 --> 00:04:20,260
0,330 330,840 840,990 990,1770
hide complexity from applications.|
|

130
00:04:20,440 --> 00:04:23,140
0,570 570,840 840,1290 1800,2580 2580,2700
So another big advantage of
所以，这些强大的抽象的另一大优势，

131
00:04:23,140 --> 00:04:25,360
0,360 510,1020 1020,1830 1830,2010 2010,2220
these powerful abstractions,| they tend
|它们往往对应用程序隐藏了复杂性。

132
00:04:25,360 --> 00:04:27,730
0,60 60,600 630,1230 1230,1380 1380,2370
to hide complexity from applications.|
|

133
00:04:30,690 --> 00:04:32,040
0,0 0,390 390,480 480,930 930,1350
The, so for example the
比如 xv6 提供的文件描述符接口，

134
00:04:32,160 --> 00:04:35,430
0,690 690,1740 1800,2520 2520,2760 3060,3270
file descriptor interface that {xv6

135
00:04:35,430 --> 00:04:36,510
0,120 120,330 330,750 750,870 870,1080
- -} provides,| it's very
|它是非常简单的接口，

136
00:04:36,510 --> 00:04:38,400
0,270 270,840 840,1110 1410,1680 1680,1890
simple interface,| but you just
|但你只需要读写文件描述符，

137
00:04:38,400 --> 00:04:39,270
0,240 240,330 330,570 570,660 660,870
read and write on file

138
00:04:39,270 --> 00:04:41,010
0,720 720,930 930,1080 1080,1230 1230,1740
descriptors,| couldn't get much simpler,|
|再简单不过了，|

139
00:04:41,100 --> 00:04:42,270
0,450 450,870 870,960 960,1110 1110,1170
but behind it is {}
但是在它的背后是非常复杂的代码，

140
00:04:42,270 --> 00:04:44,520
0,240 240,780 780,1200 1200,1680 1710,2250
very complicated code| for actually
|对于读写磁盘上的文件系统。

141
00:04:44,520 --> 00:04:46,650
0,360 360,450 450,1020 1020,1440 1590,2130
reading and writing a disk,

142
00:04:46,650 --> 00:04:48,150
0,90 90,360 360,690 690,900 900,1500
the file system on disk.|
|

143
00:04:48,850 --> 00:04:49,940
0,540

144
00:04:50,670 --> 00:04:51,840
0,180 180,360 360,540 540,660 660,1170
And that's nice for programmers,|
这对程序员来说是件好事，|

145
00:04:51,840 --> 00:04:52,530
0,120 120,210 210,360 360,540 540,690
but it makes for a
但它会让内核变得很大很复杂，

146
00:04:52,530 --> 00:04:55,440
0,240 240,750 750,1230 2400,2730 2730,2910
big complex kernel,| these big
|这些大的抽象还帮助内核管理和共享资源，

147
00:04:55,440 --> 00:04:57,450
0,540 540,840 840,1230 1230,1350 1350,2010
abstractions also help the kernel

148
00:04:57,480 --> 00:04:59,550
0,720 720,840 840,1200 1200,1860 1860,2070
manage and share resources,| we've
|我们已经委托给内核的事情，比如内存管理，

149
00:04:59,550 --> 00:05:01,080
0,630 630,720 720,810 810,1320 1320,1530
delegated to the kernel things,

150
00:05:01,080 --> 00:05:02,970
0,240 270,810 810,1440 1440,1620 1620,1890
like memory management,| the kernel
|内核跟踪哪些内存是空闲的，

151
00:05:02,970 --> 00:05:04,260
0,240 240,570 570,720 720,930 930,1290
keeps track of what memories

152
00:05:04,260 --> 00:05:06,930
0,420 540,960 1200,1830 1830,2160 2400,2670
free,| we similarly { -}
|类似地，内核跟踪磁盘的哪些部分是空闲的，

153
00:05:06,930 --> 00:05:07,770
0,120 120,360 360,570 570,780 780,840
the kernel keeps track of

154
00:05:07,770 --> 00:05:08,820
0,270 270,540 540,600 600,720 720,1050
what parts of the disk

155
00:05:08,820 --> 00:05:09,750
0,90 90,450 450,540 540,690 690,930
are free,| in what parts
|当前磁盘的哪些部分在使用。

156
00:05:09,750 --> 00:05:10,680
0,60 60,120 120,390 390,600 600,930
of the disk current current

157
00:05:10,680 --> 00:05:12,060
0,390 480,750 750,1110 1110,1260 1260,1380
use.| So programmers don't get
|所以程序员们不用考虑它，

158
00:05:12,060 --> 00:05:13,680
0,90 90,270 270,540 540,720 1140,1620
to think about it,| and
|再一次，它简化了程序，

159
00:05:14,010 --> 00:05:15,660
0,450 450,690 690,750 750,1290 1290,1650
that again, it simplifies programs,|
|

160
00:05:15,660 --> 00:05:17,280
0,90 90,330 330,660 660,810 810,1620
it also helps with robustness
它甚至还有助于增强健壮性和安全性，

161
00:05:17,280 --> 00:05:20,130
0,120 120,720 720,1080 1860,2430 2580,2850
and security even,| because if
|因为如果允许程序决定磁盘的哪些部分是空闲的，

162
00:05:20,130 --> 00:05:21,390
0,510 510,570 570,870 870,930 930,1260
programs are allowed to decide

163
00:05:21,390 --> 00:05:22,230
0,150 150,420 420,480 480,570 570,840
what parts of the disk

164
00:05:22,230 --> 00:05:23,460
0,90 90,360 360,450 450,720 750,1230
are free or not,| then
|那么也许一个程序可以使用

165
00:05:23,490 --> 00:05:26,010
0,360 360,630 630,1380 1380,1890 1890,2520
maybe one program could use|
|

166
00:05:26,010 --> 00:05:26,730
0,120 120,330 330,390 390,450 450,720
a part of the disk
另一个程序已经在使用的磁盘的一部分。

167
00:05:26,730 --> 00:05:27,690
0,180 180,390 390,570 570,840 840,960
that's already being used by

168
00:05:27,690 --> 00:05:28,900
0,300 300,780
another program.|
|

169
00:05:28,990 --> 00:05:30,120
0,540

170
00:05:30,210 --> 00:05:32,160
0,510 1410,1530 1530,1770 1770,1860 1860,1950
So the fact that the
所以实际上，内核负责资源管理，

171
00:05:32,160 --> 00:05:33,270
0,420 420,540 540,600 600,990 990,1110
kernel is in charge of

172
00:05:33,270 --> 00:05:34,920
0,420 420,1020
resource management,|
|

173
00:05:35,110 --> 00:05:36,240
0,570

174
00:05:36,980 --> 00:05:38,420
0,480 480,600 600,1080 1080,1170 1170,1440
helps with sharing and helps
帮助共享并帮助确保安全，

175
00:05:38,420 --> 00:05:40,490
0,90 90,810 1080,1320 1320,1530 1530,2070
with security,| {} but again
|但这也是某种程度上导致内核变大。

176
00:05:40,550 --> 00:05:42,440
0,300 300,360 360,750 750,960 1350,1890
it's a force that {}

177
00:05:42,740 --> 00:05:44,900
0,480 480,780 1230,1770 1770,1830 1830,2160
sort of causes the kernel

178
00:05:44,900 --> 00:05:46,140
0,60 60,180 180,630
to be big.|
|

179
00:05:46,870 --> 00:05:48,300
0,390

180
00:05:49,380 --> 00:05:50,850
0,300 300,600 600,1080 1080,1380 1380,1470
So anyway,| so having the
所以不管怎样，|让内核负责所有这些有趣的抽象，

181
00:05:50,850 --> 00:05:51,840
0,270 270,450 450,750 750,810 810,990
kernel being charge of all

182
00:05:51,840 --> 00:05:54,900
0,480 630,900 900,1230 1590,2250 2250,3060
these sort of juicy abstractions,|
|

183
00:05:54,900 --> 00:05:56,420
0,240 360,1020
that {}
即使它们只有简单的接口，

184
00:05:56,420 --> 00:05:57,200
0,210 210,300 300,390 390,480 480,780
even if they have simple

185
00:05:57,200 --> 00:05:58,700
0,960 990,1230 1230,1290 1290,1440 1440,1500
interfaces,| have a lot of
|里面有很多复杂的东西，

186
00:05:58,700 --> 00:06:00,710
0,510 510,990 1020,1350 1350,1560 1560,2010
complexity inside,| have let kernels
|让内核变成又大又复杂的东西。

187
00:06:00,710 --> 00:06:02,880
0,90 90,240 240,780
to be big

188
00:06:03,530 --> 00:06:06,470
0,180 180,780 780,1470 2310,2580 2580,2940
and complex items.| And another
|而这种整体式设计的另一个方面是，

189
00:06:06,470 --> 00:06:08,720
0,660 660,750 750,1140 1170,1860 1860,2250
aspect of this monolithic design

190
00:06:08,720 --> 00:06:10,760
0,630 630,870 1080,1650 1650,1770 1770,2040
approaches,| that because it's all
|因为这都是一个程序，

191
00:06:10,760 --> 00:06:12,560
0,240 240,1020 1080,1470 1470,1530 1530,1800
one program,| all the different
|所有不同的内核子系统，

192
00:06:12,560 --> 00:06:14,090
0,300 300,930 930,1050 1050,1170 1170,1530
kernel subsystems,| like the file
|比如文件系统，内存分配器，调度器以及虚拟内存，

193
00:06:14,090 --> 00:06:15,350
0,360 360,450 450,510 510,810 810,1260
system and the memory allocator

194
00:06:15,350 --> 00:06:17,210
0,150 150,930 930,1140 1140,1410 1410,1860
and scheduler and virtual memories,|
|

195
00:06:17,210 --> 00:06:18,140
0,150 150,300 300,570 570,630 630,930
they're all part of one
它们都是一个大的程序的一部分，

196
00:06:18,140 --> 00:06:20,030
0,300 300,750 750,1290 1440,1650 1650,1890
big integrated program,| it means
|这意味着它们可以窥探彼此的数据结构，

197
00:06:20,030 --> 00:06:21,050
0,150 150,240 240,420 420,780 780,1020
that they can peer into

198
00:06:21,050 --> 00:06:22,580
0,150 150,390 390,660 660,1380 1380,1530
each others data structures,| and
|所以，这往往会使设施的实施变得更容易，

199
00:06:22,580 --> 00:06:24,680
0,240 1110,1380 1380,1620 1620,2010 2010,2100
so that's just tended to

200
00:06:24,680 --> 00:06:26,210
0,210 210,420 480,900 930,1410 1410,1530
make it much easier to

201
00:06:26,210 --> 00:06:29,000
0,870 900,1290 1290,2250 2250,2520 2550,2790
implement {} facilities,| that are
|它在某种程度上是不止一个的一部分，

202
00:06:29,000 --> 00:06:30,140
0,150 150,240 240,660 660,750 750,1140
sort of parts of more

203
00:06:30,140 --> 00:06:32,270
0,120 120,900 1260,1800 1800,1980 1980,2130
than one| or what you
|或者你认为不止一种类型的模块或子系统，

204
00:06:32,270 --> 00:06:33,200
0,210 210,420 420,540 540,660 660,930
might think of as more

205
00:06:33,200 --> 00:06:34,670
0,90 90,300 300,510 510,660 720,1470
than one kind of module

206
00:06:34,670 --> 00:06:36,380
0,120 120,840 840,1020 1020,1140 1140,1710
or subsystem,| so for example
|比如，像 exec 这样的系统调用，

207
00:06:37,250 --> 00:06:38,840
0,120 120,450 450,630 630,810 810,1590
a system call like exec,|
|

208
00:06:39,620 --> 00:06:41,120
0,390 390,600 600,750 750,1140 1140,1500
exec has its fingers deeply
exec 深入文件系统，

209
00:06:41,120 --> 00:06:42,290
0,210 210,510 510,810 810,1020 1020,1170
into file system,| because it's
|因为它读取磁盘的二进制映像，

210
00:06:42,290 --> 00:06:44,330
0,540 540,1050 1050,1470 1470,1770 1770,2040
reading binary images of the

211
00:06:44,360 --> 00:06:45,500
0,600 600,690 690,840 840,930 930,1140
disk| in order to load
|以加载内存，

212
00:06:45,500 --> 00:06:47,120
0,180 180,750 810,1140 1140,1440 1440,1620
the memory,| it also has
|它还深入到内存分配和虚拟内存分页系统，

213
00:06:47,120 --> 00:06:49,130
0,120 120,510 510,690 690,960 1380,2010
its fingers into the memory

214
00:06:49,130 --> 00:06:51,140
0,570 570,690 690,1050 1050,1560 1560,2010
allocation and virtual memory paging

215
00:06:51,140 --> 00:06:52,250
0,450 510,780 780,840 840,990 990,1110
system,| because it needs to
|因为它需要设置新进程的地址空间，

216
00:06:52,250 --> 00:06:53,450
0,270 270,450 450,570 570,870 870,1200
set up the address space

217
00:06:53,450 --> 00:06:54,710
0,90 90,180 180,300 300,930 990,1260
of the new process,| but
|但这真的很容易，

218
00:06:54,710 --> 00:06:55,850
0,90 90,300 300,600 600,810 810,1140
it's really easy,| there's no
|在 xv6 或 Linux 中这样做没有问题，

219
00:06:56,090 --> 00:06:57,230
0,480 480,570 570,810 810,1020 1020,1140
problem with doing that in

220
00:06:57,230 --> 00:06:58,310
0,180 180,300 300,600 600,690 690,1080
{xv6 - -} or Linux,|
|

221
00:06:58,310 --> 00:07:00,260
0,450 840,1350 1350,1500 1500,1620 1620,1950
because both all the file
因为文件系统都在那里，

222
00:07:00,260 --> 00:07:01,880
0,360 360,510 510,750 750,1290 1500,1620
system is right there,| in
|在同一个内核程序中，

223
00:07:01,880 --> 00:07:03,110
0,90 90,330 330,630 630,1080 1080,1230
the same kernel program| and
|虚拟内存系统也是同一程序的一部分，

224
00:07:03,110 --> 00:07:04,160
0,150 150,420 420,660 660,930 930,1050
the virtual memory system is

225
00:07:04,160 --> 00:07:05,030
0,240 240,420 420,570 570,690 690,870
also right there as part

226
00:07:05,030 --> 00:07:07,280
0,60 60,120 120,390 390,870 1980,2250
of the same program| and
|如果你以某种方式严格分割，

227
00:07:07,280 --> 00:07:08,840
0,300 420,750 750,1260 1260,1350 1350,1560
if you somehow there was

228
00:07:08,840 --> 00:07:11,060
0,270 270,1110 1350,1890 1890,2160 2160,2220
a rigid split| between the
|在文件系统和虚拟内存系统之间，

229
00:07:11,060 --> 00:07:12,110
0,300 300,600 600,690 690,780 780,1050
file system and the virtual

230
00:07:12,110 --> 00:07:13,340
0,240 240,660 750,930 930,1020 1020,1230
memory system,| would be much
|要实现像 exec 这样的东西会困难得多，

231
00:07:13,340 --> 00:07:14,690
0,360 360,450 450,900 900,1170 1170,1350
harder to implement something like

232
00:07:14,690 --> 00:07:16,220
0,540 540,690 690,1080 1200,1470 1470,1530
exec,| that has sort of
|它深入到这两个[]。

233
00:07:16,220 --> 00:07:17,270
0,450 450,540 540,780 780,840 840,1050
fingers in both of these

234
00:07:17,270 --> 00:07:18,320
0,810
[].|
|

235
00:07:18,320 --> 00:07:19,400
0,240 240,420 420,540 540,600 600,1080
{} But in a monolithic
但是在宏系统中，只有一个大程序，

236
00:07:19,400 --> 00:07:20,870
0,420 420,630 630,750 750,900 900,1470
system just one big program,|
|

237
00:07:21,290 --> 00:07:23,600
0,570 810,1020 1020,1230 1230,1770
{} it's much easier.|
就容易多了。|

238
00:07:24,090 --> 00:07:26,130
0,330 600,1110 1110,1290 1290,1440 1440,2040
{} Another thing that makes
另一件事情让实现软件

239
00:07:27,270 --> 00:07:28,770
0,420 420,870 870,1170 1170,1200 1200,1500
implementing software| inside a {monolithic
|在 xv6 或 Linux 这样的宏内核中更简单的是，

240
00:07:28,770 --> 00:07:30,180
0,120 120,210 210,540 540,720 720,1410
- -} kernel like xv6

241
00:07:30,180 --> 00:07:31,290
0,90 90,420 420,780 780,900 900,1110
or Linux easy is that|
|

242
00:07:31,320 --> 00:07:32,910
0,480 480,570 570,1050 1050,1410 1410,1590
all the code runs with
所有代码都以完全硬件权限运行，

243
00:07:32,910 --> 00:07:36,450
0,840 1200,2160 2160,2940 2940,3180 3180,3540
full hardware privileges,| all {xv6
|比如，所有 xv6 都在管理员模式下运行，

244
00:07:36,450 --> 00:07:38,220
0,480 480,780 780,870 870,1500 1500,1770
-} runs in supervisor mode

245
00:07:38,220 --> 00:07:39,990
0,90 90,690 900,1290 1350,1590 1590,1770
for example,| {} which means
|这意味着没有限制，没有恼人，

246
00:07:39,990 --> 00:07:41,610
0,390 420,720 720,1290 1290,1440 1440,1620
there's no limits there's no

247
00:07:41,610 --> 00:07:44,040
0,960 1260,1470 1470,1710 1710,2310 2310,2430
irritating,| oh, you can't you
|你不能写那段内存，

248
00:07:44,040 --> 00:07:44,880
0,240 240,390 390,480 480,690 690,840
know me to write that

249
00:07:44,880 --> 00:07:45,870
0,330 330,570 570,750 750,840 840,990
memory here,| because you don't
|因为你没有足够的权限，

250
00:07:45,870 --> 00:07:47,640
0,120 120,300 300,1080 1290,1680 1680,1770
have enough privilege,| all the
|所有内核代码都以某种最大权限运行，

251
00:07:47,640 --> 00:07:49,480
0,300 300,660 660,1050 1050,1500
kernel code runs with

252
00:07:49,480 --> 00:07:52,500
0,210 210,750 750,1500
{sort,of} maximum privilege,|
|

253
00:07:52,710 --> 00:07:53,310
0,150 150,210 210,300 300,420 420,600
and you know the same
像 Linux 这样的操作系统也是如此。

254
00:07:53,310 --> 00:07:55,320
0,120 120,420 420,750 810,1170 1650,2010
is true of {} operating

255
00:07:55,320 --> 00:07:56,960
0,360 360,540 540,1110
systems like Linux.|
|

256
00:07:57,770 --> 00:08:02,360
0,480 570,1350 1650,1890 1890,2760 3750,4590
So, {} this design strategy,|
所以这个设计策略，|

257
00:08:02,360 --> 00:08:04,160
0,570 570,900 900,1380 1380,1560 1560,1800
it's very convenient for kernel
对于内核开发者来说是非常方便的，

258
00:08:04,160 --> 00:08:06,410
0,870 930,1590 1590,1740 1740,2010 2010,2250
developers| and it's made it
|它使得构建这些大型抽象变得很容易，

259
00:08:06,500 --> 00:08:08,090
0,600 600,930 930,1200 1200,1410 1410,1590
easy to build these big

260
00:08:08,090 --> 00:08:10,400
0,720 720,990 990,1230 1260,1830 1830,2310
abstractions| which are convenient for
|这对应用程序开发人员来说是方便的，

261
00:08:11,090 --> 00:08:14,600
0,360 360,900 900,1680 1710,3180 3300,3510
{} application developers,| however, {}
|然而，这里也有一些批评，

262
00:08:14,600 --> 00:08:15,980
0,240 240,810 810,960 960,1200 1200,1380
there's also a certain amount

263
00:08:15,980 --> 00:08:18,740
0,90 90,1050 1050,1260 1260,1560 1590,2760
to criticize| with the monolithic,
|对于传统的宏方法。

264
00:08:18,770 --> 00:08:22,640
0,570 570,1110 1110,2010
traditional monolithic approach.|
|

265
00:08:23,300 --> 00:08:24,500
0,270 270,420 420,540 540,1140 1140,1200
And this is starting to
这是开始的动力之一，

266
00:08:24,500 --> 00:08:25,580
0,90 90,270 270,330 330,390 390,1080
be part of the motivation|
|

267
00:08:25,580 --> 00:08:26,580
0,450
for
来研究其他架构，比如微内核，

268
00:08:27,730 --> 00:08:31,210
0,330 330,450 450,780 780,1830 3210,3480
looking at other architectures, like

269
00:08:31,210 --> 00:08:33,010
0,240 240,870 1290,1500 1500,1620 1620,1800
micro kernels,| so you might
|所以你可能会问，

270
00:08:33,010 --> 00:08:35,680
0,240 240,420 420,990
ask,| why not
|为什么不是宏内核。

271
00:08:35,790 --> 00:08:37,800
0,630 630,1410
monolithic kernels.|
|

272
00:08:43,290 --> 00:08:46,170
0,480 750,1170 2160,2610 2610,2700 2700,2880
So {} one is just
其中之一就是它们又大又复杂，

273
00:08:46,170 --> 00:08:47,640
0,90 90,270 270,480 480,600 600,1470
that they're big and complex,|
|

274
00:08:47,850 --> 00:08:50,340
0,330 330,720 720,1350 1350,1680 1740,2490
so anything that's {} Linux
所以任何 Linux 系统都取决于你是如何计算的，

275
00:08:50,340 --> 00:08:52,020
0,450 720,1140 1140,1290 1290,1530 1530,1680
is depending on how you

276
00:08:52,020 --> 00:08:53,880
0,600 600,780 780,1200 1200,1500 1500,1860
count,| {} Linux somewhere between
|Linux 在几十万到几百万行代码之间，

277
00:08:53,880 --> 00:08:55,560
0,300 300,720 720,810 810,1500 1500,1680
many hundreds of thousands and

278
00:08:55,560 --> 00:08:57,630
0,90 90,330 330,1110 1320,1980 1980,2070
a few million lines of

279
00:08:57,630 --> 00:09:00,060
0,630 840,1560 1770,2040 2040,2250 2250,2430
code| and people really do
|人们利用了这个事实，

280
00:09:00,060 --> 00:09:01,650
0,240 240,840 840,1110 1110,1230 1230,1590
take advantage of the fact,|
|

281
00:09:01,650 --> 00:09:02,850
0,180 180,540 540,750 750,840 840,1200
that one part of Linux
Linux 的一部分可以查看其他部分的数据，

282
00:09:02,850 --> 00:09:03,570
0,120 120,270 270,360 360,630 630,720
can sort of look at

283
00:09:03,570 --> 00:09:04,650
0,120 120,360 360,510 510,990 990,1080
the data of another| and
|这使得编程变得更容易，

284
00:09:04,650 --> 00:09:06,090
0,150 150,360 360,420 420,840 840,1440
that makes the programming easier,|
|

285
00:09:06,120 --> 00:09:07,290
0,330 330,420 420,690 690,900 900,1170
but it also makes there'd
但这也使得代码之间存在大量的互连和相互关系，

286
00:09:07,290 --> 00:09:09,420
0,150 150,240 240,540 540,900 900,2130
be a lot of interconnections

287
00:09:09,600 --> 00:09:11,910
0,570 570,1410 1410,1650 1650,2070 2070,2310
and interrelationships between code| and
|所以，它会是一个挑战，

288
00:09:11,910 --> 00:09:13,230
0,180 180,270 270,360 360,660 870,1320
so it can be {}

289
00:09:13,230 --> 00:09:14,640
0,150 150,300 300,750 750,1290 1290,1410
a bit challenging| sometimes to
|有时查看 Linux 内核代码，

290
00:09:14,640 --> 00:09:15,660
0,240 240,360 480,630 630,810 810,1020
look at the Linux kernel

291
00:09:15,660 --> 00:09:16,380
0,210 210,300 300,510 510,600 600,720
code| and figure out what
|找出它的目的是什么，

292
00:09:16,380 --> 00:09:19,680
0,120 120,300 300,450 1080,1440 3090,3300
it's up to| {} and
|任何时候，当你得到大程序，

293
00:09:19,680 --> 00:09:21,390
0,330 330,420 420,630 630,840 840,1710
anytime you get big programs,|
|

294
00:09:21,390 --> 00:09:23,100
0,390 390,600 600,690 690,990 1290,1710
especially ones that are a
特别是那些复杂结构的程序，

295
00:09:23,130 --> 00:09:25,140
0,510 510,990 990,1110 1110,1260 1260,2010
complex structure,| you get bugs,|
|你会有 bug ，|

296
00:09:26,670 --> 00:09:29,250
0,540 540,1020 1410,1950 1950,2190 2190,2580
{} and operating system kernels
操作系统内核也不例外，

297
00:09:29,250 --> 00:09:30,750
0,60 60,240 240,840 840,1260 1290,1500
are no exceptions| and over
|多年来，它们有各种各样的 bug ，

298
00:09:30,750 --> 00:09:31,440
0,90 90,270 270,420 420,600 600,690
the years, they've had all

299
00:09:31,440 --> 00:09:34,110
0,300 300,390 390,990 1590,2160 2160,2670
kinds of bugs,| including bugs
|包括可用于安全目的的漏洞。

300
00:09:34,110 --> 00:09:37,320
0,300 510,1050 1080,2040 2040,2460 2460,3210
that are exploitable for security.|
|

301
00:09:40,050 --> 00:09:41,220
0,570
So,
所以，这是一系列麻烦的关系，

302
00:09:44,250 --> 00:09:44,880
0,180 180,330 330,420 420,570 570,630
so this is sort of

303
00:09:44,880 --> 00:09:46,680
0,90 90,570 570,1140 1440,1740 1740,1800
{} trouble {} set of

304
00:09:46,680 --> 00:09:48,210
0,960 990,1140 1140,1260 1260,1470 1470,1530
relationships,| if you allow a
|如果你允许内核的大模型，

305
00:09:48,210 --> 00:09:49,260
0,150 150,420 420,510 510,630 630,1050
big model of the kernel,|
|

306
00:09:49,440 --> 00:09:51,540
0,210 210,480 480,1260 1290,1590 1590,2100
you almost certainly,| can't avoid
几乎可以肯定的是，|无法避免 bug 和可利用的安全问题，

307
00:09:51,540 --> 00:09:53,910
0,570 570,1320 1320,1740 1740,1890 1890,2370
bugs and {exploitable -} security

308
00:09:53,910 --> 00:09:55,890
0,690 1080,1260 1260,1440 1440,1530 1530,1980
problems| and that's a real
|这是一个真正的问题。

309
00:09:56,040 --> 00:09:57,420
0,150 150,420 450,630 630,870 1200,1380
I mean there really is

310
00:09:57,420 --> 00:09:58,360
0,60 60,420
a problem.|
|

311
00:10:00,490 --> 00:10:02,290
0,390 390,660 660,870 870,1260 1260,1800
Another reason why people are
人们对宏内核可能并不完全满意的另一个原因是，

312
00:10:02,350 --> 00:10:03,500
0,570
{}

313
00:10:03,500 --> 00:10:05,120
0,570 570,780 780,1170 1170,1500 1500,1620
maybe not entirely happy with

314
00:10:05,120 --> 00:10:07,100
0,510 510,1020 1020,1170 1170,1440 1590,1980
monolithic kernels is that,| they
|随着时间的推移，它们往往只会增长，具有所有想要的功能，

315
00:10:07,100 --> 00:10:09,410
0,390 390,630 660,1140 1170,1830 1830,2310
tend to just grow with

316
00:10:09,590 --> 00:10:11,780
0,360 360,870 870,1440 1440,1980 1980,2190
{} all desirable features over

317
00:10:11,780 --> 00:10:14,030
0,600 750,1080 1080,1560 1770,2160 2160,2250
time| and so you know
|所以 Linux 被用来做各种不同的事情，

318
00:10:14,030 --> 00:10:14,960
0,360 360,480 480,660 660,780 780,930
Linux is used for all

319
00:10:14,960 --> 00:10:15,920
0,210 210,270 270,510 510,750 750,960
kinds of different things,| from
|从电话听筒到桌面工作站，

320
00:10:15,950 --> 00:10:18,860
0,450 450,1230 1230,1740 1920,2340 2340,2910
telephone handsets to a desktop

321
00:10:18,860 --> 00:10:22,130
0,570 570,690 690,1440 1440,1710 2340,3270
workstations| and laptops to tablets
|从笔记本电脑，平板电脑到互联网上的服务器，

322
00:10:22,130 --> 00:10:23,690
0,330 360,900 900,1020 1020,1110 1110,1560
to servers on the Internet,|
|

323
00:10:23,690 --> 00:10:26,780
0,180 180,960 2100,2550 2550,2760 2760,3090
to routers| and that's caused
再到路由器，|这导致了 Linux ，

324
00:10:26,780 --> 00:10:28,310
0,90 90,510 510,870 870,1410 1410,1530
{Linux -},| it's fantastic that
|Linux 可以支持所有这些东西，这真是太棒了，

325
00:10:28,310 --> 00:10:29,420
0,270 270,420 420,810 810,900 900,1110
Linux can support all those

326
00:10:29,420 --> 00:10:30,740
0,480 540,870 870,1050 1050,1140 1140,1320
things,| {} but it has
|但它使它变得非常笼统，

327
00:10:30,740 --> 00:10:31,460
0,270 270,330 330,390 390,480 480,720
caused it to be very

328
00:10:31,460 --> 00:10:33,410
0,480 540,720 720,1050 1290,1860 1860,1950
general,| it has support in
|它支持很多不同的东西，

329
00:10:33,410 --> 00:10:34,370
0,120 120,240 240,450 450,690 690,960
there for many many different

330
00:10:34,370 --> 00:10:36,950
0,570 600,1140 1140,1500 1500,1950 1950,2580
things| and any one application|
|任何应用程序，|

331
00:10:36,950 --> 00:10:37,820
0,180 180,330 330,540 540,660 660,870
like me running my web
比如我运行 web 服务器，

332
00:10:37,820 --> 00:10:39,500
0,330 330,450 450,990 990,1140 1140,1680
{servers -},| unlikely to need
|不需要比如 Linux 非常复杂的声卡支持，

333
00:10:40,070 --> 00:10:41,450
0,300 300,450 450,870 870,1230 1230,1380
{} for example Linux is

334
00:10:41,450 --> 00:10:43,730
0,210 210,990 990,1440 1440,1770 1770,2280
very sophisticated sound card support,|
|

335
00:10:44,030 --> 00:10:45,380
0,270 270,450 450,690 690,840 870,1350
so there's just a huge
所以这里有大量的东西，

336
00:10:45,380 --> 00:10:46,720
0,210 210,270 270,570 570,1050
amount of stuff,| that's
|是为了让 Linux 成为通用的，

337
00:10:46,750 --> 00:10:48,250
0,150 150,540 540,840 1110,1260 1260,1500
{} there for to allow

338
00:10:48,250 --> 00:10:50,050
0,540 540,630 630,810 810,1080 1080,1800
Linux to be general purpose,|
|

339
00:10:50,230 --> 00:10:52,510
0,480 480,1050 1050,1140 1140,1590 1890,2280
{} which is good,| but
这很好，|但也有一个担心，

340
00:10:52,570 --> 00:10:55,660
0,1020 1020,1290 1290,2040 2040,2460
there's a worry,| that
|一般用途往往意味着缓慢，

341
00:10:55,960 --> 00:10:57,220
0,300 300,600 600,990 990,1110 1110,1260
{} general purpose is going

342
00:10:57,220 --> 00:10:58,540
0,90 90,360 360,420 420,660 660,1320
to tend to mean slow,|
|

343
00:10:58,990 --> 00:11:00,010
0,210 240,360 360,540 540,690 690,1020
that you know may be
可能对各种不同的东西都有好处，

344
00:11:00,430 --> 00:11:01,360
0,450 450,570 570,630 630,870 870,930
good for all kinds of

345
00:11:01,360 --> 00:11:02,800
0,240 240,540 540,810 840,1200 1200,1440
different things,| but maybe not
|但可能对任何特定的东西都不是最优的。

346
00:11:02,800 --> 00:11:05,350
0,720 1200,1500 1500,1860 1860,1980 1980,2550
optimum for anything in particular.|
|

347
00:11:06,160 --> 00:11:07,570
0,360 360,690 690,810 810,1020 1020,1410
{} so it's very hard
所以很难，

348
00:11:07,570 --> 00:11:08,500
0,330
to,|
|

349
00:11:08,500 --> 00:11:09,400
0,330 330,390 390,570 570,720 720,900
you know when you're trying
当你试着做一些非常快的东西，

350
00:11:09,400 --> 00:11:10,750
0,60 60,180 180,600 600,810 810,1350
to make something really fast,|
|

351
00:11:10,750 --> 00:11:11,980
0,180 180,450 450,600 810,1110 1110,1230
it's great to have it
最好让它只做一两件事，

352
00:11:11,980 --> 00:11:13,240
0,360 420,780 780,960 960,1170 1170,1260
just only do one or

353
00:11:13,240 --> 00:11:14,590
0,210 210,720 720,870 870,990 990,1350
two things,| you can focus
|你可以专注于优化单个代码路径，

354
00:11:14,590 --> 00:11:16,150
0,120 120,750 750,870 870,1260 1260,1560
on optimizing a single code

355
00:11:16,150 --> 00:11:18,220
0,480 1290,1470 1470,1560 1560,1890 1890,2070
path,| {but,if} your software needs
|但是如果你的软件需要做上千种不同的事情中的一个，

356
00:11:18,220 --> 00:11:19,510
0,90 90,540 840,1080 1080,1230 1230,1290
to do any one of

357
00:11:19,510 --> 00:11:20,560
0,60 60,450 450,720 720,960 960,1050
a thousand different things,| it's
|专注优化要困难得多。

358
00:11:20,560 --> 00:11:22,030
0,180 180,540 540,720 780,990 990,1470
much harder to have focused

359
00:11:22,030 --> 00:11:23,280
0,720
optimization.|
|

360
00:11:25,090 --> 00:11:26,590
0,330 330,510 510,780 1050,1440 1440,1500
So this is, Linux is
这就是， Linux 不一定很慢，

361
00:11:26,590 --> 00:11:28,060
0,180 180,660 660,990 990,1140 1140,1470
not necessarily slow,| but it's
|但是，你可能会想，

362
00:11:28,060 --> 00:11:29,170
0,90 90,240 240,660 660,810 810,1110
you know you might wonder,|
|

363
00:11:29,170 --> 00:11:30,100
0,90 90,210 210,420 420,540 540,930
if it's really as fast
它是否像可能的那样快，

364
00:11:30,100 --> 00:11:31,840
0,450 810,930 930,1050 1050,1530 1530,1740
as it could possibly be|
|

365
00:11:31,840 --> 00:11:34,080
0,300 360,660 660,1020 1020,1680
for any given situation.|
对于任何给定的情况。|

366
00:11:35,210 --> 00:11:36,290
0,210 210,300 300,420 420,630 630,1080
So if you think about
所以如果你仔细想想，

367
00:11:36,290 --> 00:11:37,370
0,90 90,240 240,420 690,870 870,1080
it,| how do you think,|
|你如何考虑，|

368
00:11:37,370 --> 00:11:38,870
0,270 270,390 390,540 540,870 1170,1500
if you think about almost
如果你考虑 Linux 或 xv6 中几乎所有东西，

369
00:11:38,870 --> 00:11:40,340
0,510 510,930 930,1260 1260,1320 1320,1470
anything in Linux or {xv6

370
00:11:40,340 --> 00:11:42,140
0,150 150,630 1170,1470 1470,1680 1680,1800
- -},| {} you know
|你可能会想，它是否真的需要做它所做的每一件事，

371
00:11:42,140 --> 00:11:43,040
0,180 180,360 360,630 630,840 840,900
you may wonder whether it

372
00:11:43,040 --> 00:11:44,000
0,180 180,390 390,480 480,630 630,960
really needs to do everything

373
00:11:44,000 --> 00:11:45,170
0,90 90,420 420,660 660,810 810,1170
it does,| so, for example
|比如，如果你通过管道写入单个字节，

374
00:11:45,170 --> 00:11:46,250
0,120 120,240 240,570 570,660 660,1080
if you write a single

375
00:11:46,250 --> 00:11:47,840
0,450 450,690 690,780 780,1350 1410,1590
byte over a pipe| from
|从一个进程到另一个进程，

376
00:11:47,840 --> 00:11:49,730
0,180 180,630 630,750 750,1230 1590,1890
one process to another,| but
|但是有很多指令会被执行，

377
00:11:49,730 --> 00:11:50,840
0,150 150,210 210,450 450,510 510,1110
there's a lot of instructions

378
00:11:50,840 --> 00:11:52,550
0,120 120,270 270,930 1110,1500 1500,1710
that get executed,| even {xv6
|即使是 xv6 ，它是一个简单的内核，

379
00:11:52,550 --> 00:11:53,420
0,120 120,480 480,660 660,780 780,870
- -} which is a

380
00:11:53,420 --> 00:11:56,390
0,330 330,810 1020,1320 1320,1710 1770,2970
simple kernel, right,| there's buffering,
|有缓冲，有锁，

381
00:11:56,390 --> 00:11:58,640
0,120 120,420 420,810 810,1710 1770,2250
you know there's locking,| there's
|有睡眠和唤醒，

382
00:11:58,640 --> 00:11:59,870
0,180 180,300 300,720 720,840 840,1230
could be {a,sleep} and {wakeup

383
00:11:59,870 --> 00:12:01,280
0,300 450,810 810,870 870,1200 1200,1410
-}| during a pipe read
|在管道读写时，

384
00:12:01,280 --> 00:12:02,150
0,120 120,450 450,600 600,810 810,870
and write,| there's maybe a
|可能有调度器，

385
00:12:02,150 --> 00:12:03,890
0,690 690,960 990,1290 1320,1680 1680,1740
scheduler| in may called the
|可能调用上下文切换，

386
00:12:03,890 --> 00:12:06,110
0,660 660,1200 1200,1560 1770,2160 2160,2220
scheduler context switch,| has a
|有很多东西可能不一定需要，

387
00:12:06,110 --> 00:12:07,500
0,150 150,210 210,630 630,1200
lot of stuff that's

388
00:12:07,650 --> 00:12:11,070
0,240 240,510 510,1650 2100,2700 3210,3420
maybe not necessarily,| {} the
|需要的绝对最小的，

389
00:12:11,070 --> 00:12:12,240
0,450 450,870 870,990 990,1080 1080,1170
absolute minimum that would be

390
00:12:12,240 --> 00:12:13,440
0,390 390,450 450,630 630,750 750,1200
required| to move a byte
|将一个字节从一个进程移动到另一个进程。

391
00:12:13,440 --> 00:12:15,360
0,510 600,840 840,1290 1290,1440 1440,1920
from one process to another.|
|

392
00:12:17,940 --> 00:12:19,290
0,270 270,780 780,1080 1080,1170 1170,1350
Another potential problem with these
这些大内核的另一个潜在问题是，

393
00:12:19,290 --> 00:12:21,240
0,180 180,780 780,960 960,1320 1410,1950
big kernels is that {},|
|

394
00:12:21,330 --> 00:12:22,660
0,720
they,
因为它们太大了，

395
00:12:22,660 --> 00:12:23,740
0,270 270,360 360,630 630,960 960,1080
because they're so big| and
|而且它们故意去掉一些非常复杂的抽象，

396
00:12:23,740 --> 00:12:26,050
0,120 120,300 300,360 360,1560 1710,2310
they sort of intentionally bite

397
00:12:26,050 --> 00:12:29,590
0,510 540,750 750,1020 1020,2100 2400,3540
off some very sophisticated abstractions,|
|

398
00:12:29,710 --> 00:12:30,310
0,210 210,390 390,450 450,570 570,600
they tend to have a
他们有很多设计决策，

399
00:12:30,310 --> 00:12:31,540
0,180 180,270 270,660 660,1080 1080,1230
lot of design decisions,| kind
|在内核中。

400
00:12:31,540 --> 00:12:32,830
0,90 90,510 510,690 690,810 810,1290
of baked into the kernel.|
|

401
00:12:33,390 --> 00:12:34,640
0,630

402
00:12:34,700 --> 00:12:36,680
0,390 1170,1350 1350,1770 1770,1890 1890,1980
So, {} you know in
所以，在某些方面你不能，

403
00:12:36,680 --> 00:12:38,150
0,240 240,360 360,540 540,1170 1200,1470
ways that you can't,| even
|即使你不同意他们的观点，

404
00:12:38,150 --> 00:12:38,930
0,90 90,180 180,570 570,660 660,780
if you disagree with them,|
|

405
00:12:38,930 --> 00:12:40,010
0,120 120,360 360,870 900,990 990,1080
you can't really you know
你也不能，应用程序只能接受它。

406
00:12:40,010 --> 00:12:41,750
0,300 300,690 780,1410 1410,1590 1590,1740
{[] -} applications just have

407
00:12:41,750 --> 00:12:43,490
0,180 420,720 720,870 870,1020 1260,1740
to live with it.| So,
|所以，相反的，

408
00:12:43,850 --> 00:12:45,000
0,480
{}

409
00:12:47,600 --> 00:12:48,410
0,150 150,210 210,390 390,600 630,810
you know as a as

410
00:12:48,410 --> 00:12:49,280
0,360 360,420 420,570 570,690 690,870
opposed to {},| in some
|在某个幻想世界里，

411
00:12:49,280 --> 00:12:51,170
0,450 450,690 690,930 930,1590 1590,1890
fantasy world,| maybe applications could
|也许应用程序可以做出更多的决定，

412
00:12:51,440 --> 00:12:52,250
0,390 390,420 420,600 600,750 750,810
make a lot more of

413
00:12:52,250 --> 00:12:53,900
0,90 90,630 630,960 1050,1500 1500,1650
the decisions,| so you know
|所以有一些例子，

414
00:12:53,900 --> 00:12:55,430
0,150 150,660 660,750 750,1050 1050,1530
some examples of things where|
|

415
00:12:56,420 --> 00:12:57,540
0,450

416
00:12:57,660 --> 00:12:59,250
0,450 450,690 690,1020 1020,1110 1110,1590
you may just you may
你可能会对 API 的设计方式感到失望，

417
00:12:59,280 --> 00:13:02,340
0,270 270,870 870,1170 1170,1770 2910,3060
be bummed out by the

418
00:13:02,340 --> 00:13:04,230
0,330 330,510 510,1020 1020,1590 1680,1890
way the API designed,| for
|比如，在 Unix 中，

419
00:13:04,230 --> 00:13:06,690
0,510 1110,1380 1380,1890 1890,2340 2340,2460
example in a Unix,| you
|你可以等待自己的子进程，

420
00:13:06,690 --> 00:13:08,040
0,150 150,390 390,690 780,990 990,1350
can wait for a process

421
00:13:08,040 --> 00:13:09,300
0,240 240,360 360,930 930,1140 1140,1260
your own children,| if you
|如果你 fork ，可以等待你的子进程，

422
00:13:09,300 --> 00:13:10,200
0,360 360,450 450,630 630,840 840,900
fork, you can wait for

423
00:13:10,200 --> 00:13:10,980
0,90 90,360 360,480 480,570 570,780
your children,| but you can't
|但你不能等待其他进程，

424
00:13:10,980 --> 00:13:12,210
0,180 180,300 300,450 450,660 660,1230
wait for some other process|
|

425
00:13:12,210 --> 00:13:13,260
0,180 330,750 750,870 870,990 990,1050
and maybe you want to
也许你想等待一个孙子进程或一个无关的进程，

426
00:13:13,260 --> 00:13:14,640
0,210 210,300 300,360 360,1140 1140,1380
wait for a grandchild or

427
00:13:14,670 --> 00:13:16,020
0,210 210,690 690,1110 1110,1200 1200,1350
an unrelated process,| but that's
|但这不是一个选择，

428
00:13:16,020 --> 00:13:17,160
0,150 150,330 330,390 390,900 1020,1140
just not an option,| it's
|它不是这样工作的，

429
00:13:17,160 --> 00:13:18,060
0,330 330,480 480,540 540,660 660,900
just not the way things

430
00:13:18,060 --> 00:13:19,290
0,390 570,930 930,1050 1050,1110 1110,1230
work,| even if it would
|即使这对你来说很方便，

431
00:13:19,290 --> 00:13:21,990
0,120 120,570 570,750 750,960 2070,2700
be convenient for you,| maybe
|也许您想要更改另一个进程地址空间的设置方式，

432
00:13:21,990 --> 00:13:23,520
0,150 150,390 390,720 750,1410 1410,1530
you want to change the

433
00:13:23,520 --> 00:13:25,860
0,450 450,1110 1110,1680 1680,1980 1980,2340
way another processes address space

434
00:13:25,860 --> 00:13:26,760
0,90 90,330 330,660 690,780 780,900
is set up,| you know
|也许可以调用和映射

435
00:13:26,760 --> 00:13:27,960
0,270 270,600 600,750 750,1080 1080,1200
maybe call and map on|
|

436
00:13:27,960 --> 00:13:30,120
0,390 390,510 510,780 780,1650 1920,2160
[] of another process that
你控制的另一个进程，

437
00:13:30,120 --> 00:13:32,060
0,150 150,720 720,1050 1080,1620
you're controlling,| but again,
|但是，这也不是一个选择，

438
00:13:32,180 --> 00:13:33,110
0,150 150,300 300,450 450,540 540,930
that's just not an option,|
|

439
00:13:33,110 --> 00:13:34,880
0,90 90,300 780,1230 1380,1680 1680,1770
you can map change your
你可以映射修改自己的地址空间，

440
00:13:34,880 --> 00:13:36,020
0,90 90,360 360,660 660,840 840,1140
own address space,| but not
|但不能修改其他进程的地址空间，

441
00:13:36,020 --> 00:13:37,730
0,510 510,600 660,930 930,1500 1500,1710
changes {} other process address

442
00:13:37,730 --> 00:13:39,620
0,450 600,960 960,1080 1080,1680 1680,1890
space,| maybe a database and
|可能是数据库，并且磁盘上有 B 树索引，

443
00:13:39,860 --> 00:13:42,320
0,570 570,960 990,1410 1410,1800 1800,2460
you have {B-tree -} indexes

444
00:13:42,320 --> 00:13:43,910
0,150 150,270 270,840 1230,1500 1500,1590
on the disk| and you
|你可能知道很多关于在磁盘上布局 B 树的最快方法，

445
00:13:43,910 --> 00:13:44,870
0,90 90,300 300,390 390,690 690,960
may know a lot about

446
00:13:44,870 --> 00:13:46,040
0,150 210,360 360,900 900,1050 1050,1170
it the fastest way to

447
00:13:46,040 --> 00:13:47,000
0,390 390,450 450,600 600,840 840,960
layout {} {B-tree -} on

448
00:13:47,000 --> 00:13:48,530
0,90 90,630 900,1290 1290,1380 1380,1530
a disk,| but if you're
|但是如果你使用文件系统读写文件，

449
00:13:48,530 --> 00:13:49,490
0,240 240,330 330,540 540,870 870,960
reading and writing files with

450
00:13:49,490 --> 00:13:50,780
0,90 90,360 360,810 870,1050 1050,1290
the file system,| the file
|文件系统不知道你是在写入 B 树，

451
00:13:50,780 --> 00:13:52,520
0,270 270,450 450,720 720,1440 1530,1740
system has no idea that

452
00:13:52,520 --> 00:13:53,630
0,210 210,510 510,840 840,900 900,1110
you're actually writing a {B-tree

453
00:13:53,630 --> 00:13:55,130
0,420 420,870 900,1230 1230,1350 1350,1500
-}| or how a {B-tree
|也不知道应该如何在磁盘上布局 B 树以实现最快的访问。

454
00:13:55,130 --> 00:13:55,910
0,240 240,360 360,420 420,540 540,780
-} ought to be laid

455
00:13:55,910 --> 00:13:56,750
0,150 150,270 270,360 360,720 720,840
out on a disk for

456
00:13:56,750 --> 00:13:59,160
0,480 480,1260 1500,2040
fastest access {}.|
|

457
00:13:59,190 --> 00:14:00,120
0,180 180,270 270,330 330,510 510,930
And so if your database
所以如果你的数据库有点麻烦，

458
00:14:00,120 --> 00:14:00,630
0,90 90,210 210,270 270,330 330,510
you're going to be kind

459
00:14:00,630 --> 00:14:02,070
0,90 90,600 600,690 690,1020 1080,1440
of bummed,| you know maybe
|也许你很高兴有这个文件系统供你支配，

460
00:14:02,070 --> 00:14:02,820
0,120 120,450 450,570 570,660 660,750
you're happy that you have

461
00:14:02,820 --> 00:14:03,810
0,150 150,390 390,720 720,870 870,990
this file system at your

462
00:14:03,810 --> 00:14:05,340
0,660 750,990 990,1050 1050,1260 1260,1530
disposal,| but it doesn't really
|但它并没有真正做你想做的事。

463
00:14:05,340 --> 00:14:06,120
0,120 120,300 300,390 390,690 690,780
do what you want to

464
00:14:06,120 --> 00:14:07,000
0,240
do.|
|

465
00:14:07,340 --> 00:14:08,480
0,330 450,780 780,870 870,1080 1080,1140
{} That's the sense in
这就是设计决策到大内核中的感觉。

466
00:14:08,480 --> 00:14:10,490
0,360 390,780 870,1500 1500,1920 1920,2010
which a design decisions are

467
00:14:10,490 --> 00:14:12,260
0,240 240,600 600,810 810,990 990,1770
often baked into big kernels.|
|

468
00:14:13,290 --> 00:14:16,020
0,240 240,660 660,810 810,1680 2070,2730
And finally, a specific {}
最后，还有一种特殊的问题，

469
00:14:16,470 --> 00:14:18,480
0,360 360,420 420,1110 1110,1410
sort of issue that,|
|

470
00:14:19,100 --> 00:14:20,360
0,840

471
00:14:20,920 --> 00:14:21,610
0,240 240,300 300,480 480,630 630,690
so it came up in
所以它可能是在 20 世纪 90 年代出现的，

472
00:14:21,610 --> 00:14:22,930
0,60 60,270 270,720 720,960 960,1320
a big way in the

473
00:14:23,140 --> 00:14:26,020
0,810 810,1260 1260,1740 1860,2190 2460,2880
{1990s -} probably,| a notion
|一种可扩展性的概念，

474
00:14:26,020 --> 00:14:27,680
0,60 60,570 570,780 780,1110
of {extensibility - -},|
|

475
00:14:28,420 --> 00:14:29,540
0,540

476
00:14:29,950 --> 00:14:30,820
0,300 300,540 540,600 600,780 780,870
{} that it might be
让程序能够在运行时修改内核，

477
00:14:30,820 --> 00:14:32,170
0,510 510,720 720,1200 1200,1290 1290,1350
desirable for programs to be

478
00:14:32,170 --> 00:14:33,280
0,120 120,210 210,600 600,690 690,1110
able to change the kernel

479
00:14:33,280 --> 00:14:34,180
0,150 150,240 240,720 750,840 840,900
on the fly,| to be
|能够下载内核中的新代码，

480
00:14:34,180 --> 00:14:35,260
0,120 120,180 180,690 690,810 810,1080
able to download new code

481
00:14:35,260 --> 00:14:36,130
0,120 120,210 210,540 540,600 600,870
in the kernel| or change
|或者改变它的运作方式之类的，

482
00:14:36,130 --> 00:14:36,970
0,60 60,180 180,270 270,750 750,840
the way it operates or

483
00:14:36,970 --> 00:14:39,130
0,450 750,1350 1530,1800 1800,2070 2070,2160
something,| {} in order to
|为了能让数据库

484
00:14:39,130 --> 00:14:40,840
0,180 180,510 510,870 900,1110 1110,1710
do things like have databases|
|

485
00:14:40,840 --> 00:14:42,940
0,210 210,330 330,870 870,1110 1290,2100
able to control the layout
能够控制磁盘上的数据布局。

486
00:14:42,940 --> 00:14:44,470
0,270 450,720 720,870 870,990 990,1530
of data on the disk.|
|

487
00:14:45,320 --> 00:14:49,820
0,450 1470,1830 2070,2850 3660,4140 4140,4500
{} At least in decades
至少在过去的几十年里，

488
00:14:49,820 --> 00:14:52,070
0,510 570,1170 1170,1590 1590,1920 1920,2250
past,| monolithic kernels tended not
|宏内核没有任何特定的功能，

489
00:14:52,340 --> 00:14:53,320
0,360
to,

490
00:14:53,500 --> 00:14:54,970
0,150 150,360 360,630 630,1080 1080,1470
to have any particular features,|
|

491
00:14:54,970 --> 00:14:55,930
0,120 120,390 390,570 600,780 780,960
that help with this kind
来帮助这种扩展能力，

492
00:14:55,930 --> 00:14:57,340
0,60 60,510 510,900 900,1020 1020,1410
of extensive ability,| you're just
|你只是困在内核中。

493
00:14:57,490 --> 00:14:58,540
0,360 360,450 450,690 690,780 780,1050
stuck with whatever the kernel

494
00:14:58,540 --> 00:15:00,140
0,300
did.|
|

495
00:15:01,490 --> 00:15:03,400
0,690 720,1290
Okay {}.|
好的。|

496
00:15:03,430 --> 00:15:04,570
0,300 300,480 480,570 570,780 780,1140
So, these were sort of
所以，这些都是人们考虑的一些问题，

497
00:15:05,280 --> 00:15:06,210
0,480 480,540 540,630 630,870 870,930
problems in the back of

498
00:15:06,210 --> 00:15:08,580
0,330 330,1080 1080,1350 1350,1680
people's minds,| that {}
|让他们思考其他的，

499
00:15:08,830 --> 00:15:09,880
0,360 360,480 480,570 570,750 750,1050
let them to think about

500
00:15:09,970 --> 00:15:11,950
0,330 330,720 720,1110 1320,1560 1560,1980
other kinds of,| other ways
|操作系统设计其他体系结构的方式，

501
00:15:11,950 --> 00:15:13,840
0,210 210,930 960,1170 1170,1740 1740,1890
of designing other architectures for

502
00:15:13,840 --> 00:15:16,120
0,330 330,960 1200,1740 1860,2190 2190,2280
operating systems| and and there
|而且有很多想法，

503
00:15:16,120 --> 00:15:17,540
0,60 60,210 210,660 660,810
were a number of,

504
00:15:17,690 --> 00:15:18,860
0,180 180,390 390,480 480,1020 1020,1170
a number of ideas,| some
|有些与人们追求的截然不同，

505
00:15:18,860 --> 00:15:20,030
0,240 240,570 570,840 840,930 930,1170
quite radically different that people

506
00:15:20,030 --> 00:15:21,500
0,540 750,1170 1170,1290 1290,1410 1410,1470
pursued,| {} we're going to
|我们要谈的是其中一个，

507
00:15:21,500 --> 00:15:22,400
0,120 120,270 270,510 510,570 570,900
talk about one of them,|
|

508
00:15:22,820 --> 00:15:25,640
0,420 450,1170 1680,2130 2130,2310 2310,2820
{} particularly popular one today|
今天特别受欢迎的一个，|

509
00:15:25,880 --> 00:15:26,480
0,150 150,300 300,360 360,540 540,600
and that's the idea of
这就是微内核的想法。

510
00:15:26,480 --> 00:15:27,900
0,330 330,960
micro kernels.|
|

511
00:15:29,290 --> 00:15:30,460
0,540

512
00:15:31,330 --> 00:15:33,340
0,210 210,570 570,1350 1350,1770 1770,2010
{} Micro kernels, although many
微内核，很多想法，

513
00:15:33,340 --> 00:15:34,930
0,60 60,150 150,780 780,1170 1350,1590
of the ideas| or go
|或者回到计算机历史的开始，

514
00:15:34,930 --> 00:15:36,370
0,240 240,330 330,450 450,1050 1050,1440
back to the beginning of

515
00:15:37,040 --> 00:15:38,780
0,180 180,570 570,1140
{} computer history,|
|

516
00:15:39,020 --> 00:15:41,030
0,540 630,930 930,1350 1350,1710 1770,2010
{} they became a sort
它们变成一种热门的研究课题，

517
00:15:41,030 --> 00:15:43,160
0,60 60,450 450,870 870,1470 1770,2130
of hot research topic {},|
|

518
00:15:43,160 --> 00:15:44,360
0,540 540,630 630,840 840,930 930,1200
starting in maybe the mid
可能从 20 世纪 80 年代中后期开始。

519
00:15:44,360 --> 00:15:46,520
0,120 120,510 570,960 960,1740
to late {1980s -}.|
|

520
00:15:46,550 --> 00:15:49,580
0,510 1500,2070 2100,2250 2250,2430 2430,3030
{} And the big idea,|
最重要的想法是，|

521
00:15:50,560 --> 00:15:51,940
0,780

522
00:15:52,710 --> 00:15:54,390
0,270 270,450 450,1290 1290,1500 1500,1680
so {} {micro,kernel} this this
顺便说一下，微内核这个词

523
00:15:54,390 --> 00:15:56,700
0,750 1170,1620 1620,1710 1710,1890 1890,2310
word, by the way| refers
|指的是一种一般的方法，一个概念，

524
00:15:56,700 --> 00:15:57,480
0,90 90,150 150,330 330,390 390,780
to a sort of general

525
00:15:57,480 --> 00:15:59,070
0,450 450,540 540,1170 1170,1410 1410,1590
approach, a concept,| it doesn't
|它不是任何特定的东西，

526
00:15:59,070 --> 00:16:00,840
0,240 240,330 330,690 720,1350 1350,1770
refer to any specific artifact,|
|

527
00:16:00,840 --> 00:16:03,120
0,90 90,210 210,780 1020,1650 1650,2280
there were many people who
有许多人设计和构建操作系统，

528
00:16:03,150 --> 00:16:05,400
0,420 420,510 510,870 1020,1860 1860,2250
designed and built operating systems|
|

529
00:16:05,400 --> 00:16:07,680
0,120 120,870 870,990 990,1920 2070,2280
that followed the general sort
根据微内核的一般方案，

530
00:16:07,680 --> 00:16:09,030
0,120 120,600 600,720 720,990 990,1350
of plan for micro kernels,|
|

531
00:16:09,030 --> 00:16:09,840
0,180 270,420 420,540 540,750 750,810
but you know each of
但是，这些项目中的每一个，

532
00:16:09,840 --> 00:16:11,580
0,150 150,720 930,1230 1230,1320 1320,1740
these projects,| ended up designing
|最终设计和操作系统都可能有很大的不同。

533
00:16:11,580 --> 00:16:12,630
0,90 90,390 390,840 840,930 930,1050
and operating systems may be

534
00:16:12,630 --> 00:16:13,950
0,270 270,570 570,690 690,810 810,1320
quite different from the others.|
|

535
00:16:14,070 --> 00:16:15,480
0,210 210,300 300,510 510,870 870,1410
So the key idea was
所以关键的想法是微小的内核，

536
00:16:15,570 --> 00:16:16,600
0,660
{}

537
00:16:16,840 --> 00:16:19,420
0,420 540,1260 1260,1950
the tiny kernel,|
|

538
00:16:19,640 --> 00:16:20,980
0,780

539
00:16:22,540 --> 00:16:26,080
0,180 180,1020 1380,1770 1800,2490 2490,3540
that supported {} just IPC
仅支持 IPC 进程间通信，

540
00:16:26,320 --> 00:16:29,140
0,240 240,600 600,1140 1140,1920 2190,2820
or inter process communication {},|
|

541
00:16:29,320 --> 00:16:31,510
0,870 1020,1410 1410,1620 1620,1890 1890,2190
and {} some sort of
以及某种线程或任务的概念。

542
00:16:31,510 --> 00:16:33,070
0,420 420,780 810,1020 1020,1500 1500,1560
notion of a threads or

543
00:16:33,070 --> 00:16:34,440
0,900
tasks.|
|

544
00:16:35,620 --> 00:16:36,430
0,180 180,270 270,390 390,480 480,810
So you have a kernel
所以，你有一个内核，它为你提供

545
00:16:36,430 --> 00:16:38,350
0,450 1110,1470 1470,1560 1560,1590 1590,1920
that provides you| a notion
|一种类似于抽象的进程的概念，

546
00:16:38,350 --> 00:16:39,970
0,270 420,840 840,900 900,1410 1410,1620
of sort of process like

547
00:16:39,970 --> 00:16:41,740
0,630 630,750 750,990 990,1140 1140,1770
abstraction| and away for processes
|进程之间可以互相通信，

548
00:16:41,740 --> 00:16:42,730
0,120 120,540 540,630 630,750 750,990
to communicate with each other,|
|

549
00:16:42,730 --> 00:16:44,830
0,120 120,480 750,990 990,1350 1350,2100
with this inter process communication|
通过这种进程间通信，|

550
00:16:44,890 --> 00:16:47,350
0,480 510,930 930,1560 1590,1830 2100,2460
and nothing else.| And everything
没有其他的了。|其他你可能想做的事，

551
00:16:47,350 --> 00:16:48,010
0,180 180,270 270,450 450,600 600,660
else you might want to

552
00:16:48,010 --> 00:16:49,420
0,210 210,390 390,570 570,870 870,1410
do,| like a file system
|比如要实现的文件系统，

553
00:16:49,450 --> 00:16:51,580
0,180 180,780 870,1230 1230,1470 1620,2130
you'd implement,| as a process
|作为进程或任务在用户级代码，

554
00:16:51,580 --> 00:16:52,330
0,90 90,180 180,540 540,660 660,750
as a task as a

555
00:16:52,330 --> 00:16:53,860
0,300 300,540 540,1110 1140,1440 1440,1530
user level code,| not in
|而不是在内核中。

556
00:16:53,860 --> 00:16:55,380
0,60 60,420 420,510 510,930
the kernel at all.|
|

557
00:16:55,850 --> 00:16:57,080
0,240 240,420 420,750 750,840 840,1230
{} So picture for that,|
所以，这里的图，|

558
00:16:58,040 --> 00:16:59,160
0,600

559
00:17:01,100 --> 00:17:02,030
0,390 390,630 630,750 750,870 870,930
maybe now we're going to
现在我们使用 u 表示微内核，

560
00:17:02,030 --> 00:17:05,030
0,630 840,1740 1740,1980 1980,2400 2400,3000
use u for micro kernel,|
|

561
00:17:05,090 --> 00:17:06,140
0,120 120,210 210,510 510,810 810,1050
and the micro kernel down
微内核在下面这里，

562
00:17:06,140 --> 00:17:07,580
0,390 390,480 480,570 570,840 1020,1440
here| and we got user
|在上面有用户空间进程，

563
00:17:07,580 --> 00:17:09,050
0,300 300,780 780,960 960,1290 1290,1470
space processes up here| and
|我们可能会运行所有常见的进程，

564
00:17:09,140 --> 00:17:10,160
0,540 540,660 660,780 780,930 930,1020
we might have all the

565
00:17:10,160 --> 00:17:11,990
0,210 210,300 300,780 780,1470 1470,1830
kind of usual processes run,|
|

566
00:17:11,990 --> 00:17:13,020
0,480
maybe
也许要运行 vi ，我最喜欢的文本编辑器，

567
00:17:13,140 --> 00:17:15,120
0,150 150,330 330,810 1020,1830 1860,1980
we're gonna run vi, my

568
00:17:15,120 --> 00:17:16,860
0,360 360,750 750,1260 1260,1380 1380,1740
favorite text editor,| and my
|还有我的编译器，我的窗口系统。

569
00:17:17,610 --> 00:17:19,540
0,300 300,1350
my compiler,

570
00:17:19,700 --> 00:17:21,900
0,360 360,810 810,1620
my windows system.|
|

571
00:17:22,500 --> 00:17:24,960
0,510

572
00:17:25,340 --> 00:17:26,510
0,300 300,660 660,840 840,1050 1050,1170
But also up here as
但这里也像常用进程一样，

573
00:17:26,510 --> 00:17:27,740
0,390 390,960 960,1050 1050,1170 1170,1230
usual processes,| we're going to
|我们使用文件系统，

574
00:17:27,740 --> 00:17:29,560
0,90 90,180 180,600 600,1170
have the file system,|
|

575
00:17:29,650 --> 00:17:31,780
0,270 270,420 420,1020 1020,1560 1560,2130
just as a server process
就像用户空间中的服务器进程一样，

576
00:17:31,780 --> 00:17:32,920
0,120 120,390 390,840 840,1050 1050,1140
in user space,| maybe we're
|也许我们会有一个磁盘驱动程序，

577
00:17:32,920 --> 00:17:34,600
0,120 120,180 180,390 390,1140 1140,1680
going to have a disk

578
00:17:34,600 --> 00:17:36,060
0,840
driver,|
|

579
00:17:36,180 --> 00:17:36,930
0,150 150,240 240,420 420,480 480,750
they know how to talk
它们知道如何与我的磁盘硬件通信，

580
00:17:36,930 --> 00:17:38,700
0,60 60,210 210,810 810,1140 1380,1770
to my {disk,hardware -},| maybe
|也许我们有一个网络堆栈，

581
00:17:38,700 --> 00:17:40,290
0,90 90,240 240,270 270,870 870,1590
we have a network stack,|
|

582
00:17:40,290 --> 00:17:41,480
0,630
that
它知道如何使用 TCP 与我的网卡交互，

583
00:17:43,080 --> 00:17:44,280
0,270 270,360 360,450 450,840 840,1200
knows how to talk talk

584
00:17:44,310 --> 00:17:47,250
0,1050 1050,1230 1230,1740 1770,2400 2400,2940
TCP to my network interface

585
00:17:47,250 --> 00:17:49,740
0,540 1110,1530 1530,1680 1680,2040 2040,2490
card,| maybe we'll have a
|也许我们有一个用户级别的进程，

586
00:17:49,860 --> 00:17:51,240
0,390 390,630 630,1110 1110,1290 1290,1380
user level process,| that's in
|负责执行花哨的分页技巧，

587
00:17:51,240 --> 00:17:53,910
0,420 420,630 690,1200 1200,2010 2010,2670
charge of doing fancy paging

588
00:17:53,910 --> 00:17:57,120
0,780 810,1470 1560,2040 2040,2400 2400,3210
tricks,| like memory mapped files|
|比如内存映射文件，|

589
00:17:57,120 --> 00:17:58,770
0,240 360,780 780,1200 1200,1530 1530,1650
or maybe implements {copy-on-write -
或者可能实现写入时复制， fork 等东西。

590
00:17:58,770 --> 00:18:01,280
0,210 210,570 570,660 660,1140
-} fork or something.|
|

591
00:18:01,560 --> 00:18:04,170
0,270 300,780 780,1410 1710,2310 2310,2610
And when my text editor
当我的文本编辑器需要读取文件时，

592
00:18:04,170 --> 00:18:05,520
0,270 270,390 390,540 540,630 630,1350
needs to read a file,|
|

593
00:18:05,760 --> 00:18:06,510
0,150 150,330 330,420 420,660 660,750
it needs to talk the
它需要与文件系统交互，

594
00:18:06,510 --> 00:18:08,520
0,270 270,690 690,810 810,1020
file system,| and so
|所以，它通过 IPC 进程间通信发送一条消息，

595
00:18:08,730 --> 00:18:10,740
0,330 330,540 540,1170 1170,1410 1410,2010
it's gonna send a {}

596
00:18:13,380 --> 00:18:17,130
0,420 420,1530 1560,2160 2160,3150 3570,3750
a message via IPC inter

597
00:18:17,130 --> 00:18:18,920
0,390 390,1260
process communication,|
|

598
00:18:19,010 --> 00:18:20,690
0,660 720,990 990,1080 1080,1350 1350,1680
{} to the file system
到文件系统服务器，

599
00:18:20,690 --> 00:18:22,310
0,540 840,1200 1200,1380 1380,1530 1530,1620
server,| which has all the
|其中包含所有文件系统代码，

600
00:18:22,310 --> 00:18:23,600
0,210 210,480 480,780 780,1080 1080,1290
file system code,| it's about
|它是关于文件和目录，

601
00:18:23,600 --> 00:18:24,950
0,390 390,480 480,990 990,1110 1110,1350
files and directories| and file
|并且文件系统服务器代码可能需要与磁盘交互，

602
00:18:24,950 --> 00:18:26,390
0,360 360,690 690,930 930,1110 1110,1440
system server code may need

603
00:18:26,390 --> 00:18:28,040
0,270 450,1050 1050,1140 1140,1260 1260,1650
to talk to the disk,|
|

604
00:18:28,040 --> 00:18:29,030
0,180 180,240 240,450 450,630 630,990
so it might send another
所以它可能发送磁盘读取或写入，

605
00:18:29,030 --> 00:18:30,620
0,390 480,690 690,810 810,1260 1290,1590
{} sort of disk read

606
00:18:30,620 --> 00:18:33,170
0,120 120,450 450,960 1440,1740 1740,2550
or write,| so another IPC
|另一个 IPC ，

607
00:18:33,350 --> 00:18:34,370
0,210 210,300 300,540 540,810 810,1020
to,| the disk driver which
|磁盘驱动以某种方式与硬件交互，

608
00:18:34,370 --> 00:18:36,620
0,270 270,630 630,870 870,1470 1980,2250
somehow talks this hardware,| this
|这个驱动程序可能返回一个磁盘块到文件服务器，

609
00:18:36,620 --> 00:18:38,700
0,360 360,570 570,1680
driver may return

610
00:18:38,920 --> 00:18:39,790
0,90 90,210 210,300 300,600 600,870
you know a disk block

611
00:18:39,790 --> 00:18:41,560
0,60 60,180 180,480 480,1140 1470,1770
to the file server| after
|在它完成它的事情之后，

612
00:18:41,560 --> 00:18:42,460
0,60 60,240 240,420 420,660 660,900
it does its thing,| maybe
|也许文件服务器最终再次返回你请求的数据，

613
00:18:42,460 --> 00:18:43,810
0,90 90,360 360,630 630,960 960,1350
the file server finally returns

614
00:18:43,810 --> 00:18:44,770
0,90 90,330 330,480 480,750 750,960
the data you ask for

615
00:18:44,770 --> 00:18:46,450
0,330 330,480 480,750 750,1110 1110,1680
again| by inter process communication
|通过进程间通信消息，

616
00:18:46,450 --> 00:18:48,880
0,570 900,1920 1920,1980 1980,2070 2070,2430
messages,| back to my text
|回到我的文本编辑器。

617
00:18:48,880 --> 00:18:49,700
0,390
editor.|
|

618
00:18:50,240 --> 00:18:52,190
0,360 420,750 750,900 900,1140 1680,1950
But you know the the
但是这里需要注意的关键是，

619
00:18:52,220 --> 00:18:53,390
0,360 360,510 510,570 570,930 930,1170
critical thing to notice here

620
00:18:53,390 --> 00:18:55,190
0,180 180,480 1260,1410 1410,1590 1590,1800
is that| the only stuff
|内核中唯一要做的就是，

621
00:18:55,190 --> 00:18:56,030
0,210 210,480 480,690 690,750 750,840
going down here in the

622
00:18:56,030 --> 00:18:58,370
0,420 420,570 570,1080 1080,1440 1440,2340
kernel is| support for these
|支持这些进程、任务或线程，

623
00:18:58,430 --> 00:19:01,190
0,1080 1350,1470 1470,2070 2070,2160 2160,2760
processes or tasks or threads,|
|

624
00:19:02,130 --> 00:19:03,720
0,300 300,390 390,630 630,1050 1080,1590
whatever they might be| and
无论它们是什么，|支持进程间通信消息传递，没有其他的，

625
00:19:04,590 --> 00:19:06,120
0,570 570,690 690,870 870,1080 1080,1530
support for the inter process

626
00:19:06,120 --> 00:19:08,160
0,690 690,1050 1050,1500 1590,1770 1770,2040
communication message passing and nothing

627
00:19:08,160 --> 00:19:09,300
0,240 240,360 360,510 510,840 840,1140
else,| there's no file system
|下面没有文件系统，

628
00:19:09,300 --> 00:19:11,250
0,240 240,480 480,630 630,990 1410,1950
down here,| there's no device
|下面的内核中也没有设备驱动程序，

629
00:19:11,250 --> 00:19:12,810
0,420 420,990 990,1290 1290,1470 1470,1560
drivers necessarily down here in

630
00:19:12,810 --> 00:19:14,640
0,60 60,570 570,840 840,1110 1230,1830
the kernel,| there's no network
|这里没有网络堆栈，

631
00:19:14,640 --> 00:19:16,500
0,540 870,1110 1110,1260 1260,1560 1560,1860
stack,| all that stuff is
|所有这些东西都在上面，

632
00:19:16,530 --> 00:19:18,030
0,210 210,480 480,930 1050,1440 1440,1500
up here,| as more or
|或多或少都是普通的用户级进程。

633
00:19:18,030 --> 00:19:20,970
0,510 1050,1620 1620,1860 1860,2070 2070,2940
less ordinary user level processes.|
|

634
00:19:21,790 --> 00:19:24,190
0,390 1650,1920 1920,2070 2070,2310 2310,2400
{} So they lead you
所以，它们会带来一个非常小的内核，

635
00:19:24,190 --> 00:19:26,710
0,150 150,1020 1320,1740 1740,2010 2010,2520
to a very small kernel|
|

636
00:19:26,710 --> 00:19:29,350
0,450 660,1260 1620,2130 2130,2340 2340,2640
with a relatively little code
包含相对较少的代码可以优化，

637
00:19:29,350 --> 00:19:31,720
0,900 900,1260 1320,1650 1650,1920 1920,2370
optimize,| like you can optimize
|比如你可以优化 IPC ，

638
00:19:31,720 --> 00:19:32,710
0,480 480,570 570,720 720,840 840,990
IPC| and there's not much
|没有太多其他的事情要做。

639
00:19:32,710 --> 00:19:34,460
0,180 180,420 420,750
else going on.|
|

640
00:19:36,590 --> 00:19:37,490
0,120 120,210 210,510 510,810 810,900
And so this is the
所以这是我们要在剩下的这节课上讨论的图片，

641
00:19:37,490 --> 00:19:38,240
0,210 210,270 270,570 570,630 630,750
kind of picture we're going

642
00:19:38,240 --> 00:19:39,080
0,60 60,330 330,660 660,750 750,840
to talk about for the

643
00:19:39,080 --> 00:19:40,220
0,210 210,270 270,330 330,840 840,1140
rest of the lecture| and
|让你们了解这件事的最终的情况。

644
00:19:40,460 --> 00:19:41,450
0,420 420,540 540,600 600,660 660,990
just give you a taste

645
00:19:41,450 --> 00:19:42,710
0,270 270,420 420,600 600,840 840,1260
of where this ended up.|
|

646
00:19:42,740 --> 00:19:45,110
0,450 630,1230 1230,1410 1410,1680 1680,2370
{} There are actually still
实际上，今天仍在使用一种微内核，

647
00:19:45,110 --> 00:19:46,850
0,390 690,1080 1080,1380 1380,1500 1500,1740
a micro kernels in use

648
00:19:46,850 --> 00:19:48,200
0,450 450,660 660,1020 1020,1140 1140,1350
today,| and indeed the {L4
|事实上， L4 微内核，

649
00:19:48,200 --> 00:19:49,400
0,270 270,540 540,810 810,1020 1020,1200
-} micro kernel| which is
|是今天论文讨论的主题所使用的，

650
00:19:49,400 --> 00:19:50,870
0,180 300,630 630,690 690,1020 1020,1470
the topic of today's paper

651
00:19:50,990 --> 00:19:52,730
0,780 780,930 930,1020 1020,1200 1200,1740
turns out to be used,|
|

652
00:19:52,970 --> 00:19:55,160
0,480 690,1080 1080,1440 1440,1920 1920,2190
{} there's many instances many
有很多 L4 实例运行，

653
00:19:55,160 --> 00:19:56,450
0,300 300,750 750,870 870,1050 1050,1290
many instances of {L4 -}

654
00:19:56,450 --> 00:19:57,950
0,360 360,810 900,1200 1200,1410 1410,1500
running,| because it's used in
|因为它被用在很多手机里，

655
00:19:57,950 --> 00:19:59,630
0,60 60,210 210,270 270,1050 1530,1680
a lot of cellphones| in
|在小型控制器上控制手机无线电，

656
00:19:59,630 --> 00:20:00,950
0,120 120,330 330,660 660,1230 1230,1320
the little micro controllers that

657
00:20:00,950 --> 00:20:02,630
0,360 360,510 510,780 780,990 990,1680
control the cell phone radios|
|

658
00:20:02,900 --> 00:20:04,700
0,570 570,690 690,1050 1050,1560 1560,1800
and it's also apparently used
而且它也被用于最近的 iPhone ，

659
00:20:04,700 --> 00:20:05,420
0,330
in

660
00:20:05,420 --> 00:20:07,700
0,390 390,1260 1410,1800 1800,1860 1860,2280
recent iPhones| as the operating
|作为 iPhone 上的专用 enclave 处理器上运行的操作系统，

661
00:20:07,700 --> 00:20:09,560
0,300 300,480 480,780 780,1290 1620,1860
system that runs on a

662
00:20:09,560 --> 00:20:11,960
0,750 990,1860
special dedicated

663
00:20:11,960 --> 00:20:13,580
0,540 540,1050 1050,1110 1110,1200 1200,1620
enclave processor in the iPhone,|
|

664
00:20:13,580 --> 00:20:15,890
0,120 120,840 840,1080 1230,1680 1680,2310
that hides the secret cryptographic
用于隐藏秘密的密钥。

665
00:20:15,890 --> 00:20:17,060
0,690
keys.|
|

666
00:20:17,270 --> 00:20:17,870
0,150 150,300 300,360 360,510 510,600
So there's a bunch of
所以，有很多嵌入式，

667
00:20:17,870 --> 00:20:20,420
0,750 1230,1710 1710,1950 1950,2190 2190,2550
embedded| where these micro kernels
|微内核胜出

668
00:20:20,420 --> 00:20:21,830
0,390 390,630 630,990 990,1170 1170,1410
have won out| in little
|在小型嵌入式专用计算机系统中，

669
00:20:21,830 --> 00:20:25,520
0,450 450,1530 1770,2190 2190,2940 3060,3690
embedded specialized computer systems,| not
|不是笔记本，

670
00:20:25,520 --> 00:20:28,130
0,180 180,840 840,1050 1530,1950 2010,2610
not laptops,| but a computer
|而是专用于单一专门任务的计算机，

671
00:20:28,310 --> 00:20:30,360
0,900 900,1140 1140,1560
dedicated to {

672
00:20:30,520 --> 00:20:32,710
0,360 360,660 660,1200 1200,1800 1830,2190
-} single specialized tasks| where
|可能不需要 Linux 的复杂性，

673
00:20:32,710 --> 00:20:33,580
0,240 270,450 450,630 630,810 810,870
you may not need the

674
00:20:33,580 --> 00:20:34,990
0,480 480,570 570,1020 1020,1200 1230,1410
complexity of Linux,| but you
|但是你确实需要一些操作系统。

675
00:20:34,990 --> 00:20:36,220
0,150 150,330 330,540 540,900 900,1230
do need some operating system.|
|

676
00:20:37,680 --> 00:20:38,970
0,270 270,360 360,540 540,750 750,1290
And the other thing,| that's
另一件事，|微内核的另一种最终结果是，

677
00:20:39,960 --> 00:20:40,950
0,120 120,330 330,510 510,570 570,990
the other sort of final

678
00:20:40,950 --> 00:20:43,020
0,660 1080,1320 1320,1620 1620,1980 1980,2070
result from micro kernels is

679
00:20:43,020 --> 00:20:44,520
0,180 240,630 630,1110 1110,1230 1230,1500
that,| the idea of user
|用户级服务与其他程序通过 IPC 与它们交互，

680
00:20:44,520 --> 00:20:47,340
0,420 420,1140 1140,1830 1920,2310 2580,2820
level services with with other

681
00:20:47,340 --> 00:20:48,810
0,330 330,630 630,750 750,1260 1320,1470
programs talking to them with

682
00:20:48,810 --> 00:20:51,390
0,720 900,1290 1290,1590 1590,2130 2250,2580
IPC,| that also has made
|也已经进入了很多操作系统，

683
00:20:51,390 --> 00:20:52,110
0,120 120,270 270,450 450,510 510,720
its way into a lot

684
00:20:52,110 --> 00:20:53,220
0,60 60,420 420,750 750,870 870,1110
of operating systems,| like Mac
|就像 Mac OS ，

685
00:20:53,220 --> 00:20:54,330
0,90 90,360 360,480 480,780 840,1110
{OS -},| which {} running
|它正运行着与你交谈，

686
00:20:54,330 --> 00:20:55,080
0,150 150,300 300,420 420,690 690,750
right now to talk to

687
00:20:55,080 --> 00:20:57,000
0,270 480,1050 1320,1620 1620,1740 1740,1920
you,| {} you know it's
|它既是一种普通的宏内核，

688
00:20:57,000 --> 00:20:58,470
0,270 450,720 720,780 1170,1320 1320,1470
a sort of as well

689
00:20:58,470 --> 00:20:59,070
0,120 120,300 300,360 360,540 540,600
as being a kind of

690
00:20:59,070 --> 00:21:01,410
0,690 720,1260 1260,1770 1800,2070 2070,2340
ordinary monolithic kernel,| it also
|它还很好地支持用户级服务，

691
00:21:01,410 --> 00:21:03,840
0,450 450,720 720,1320 1320,1920 2070,2430
has good support for a

692
00:21:03,840 --> 00:21:06,330
0,300 300,600 600,1380 1380,1830 1830,2490
user level services| and IPC
|以及 Unix 进程之间与服务交互的 IPC ，

693
00:21:06,330 --> 00:21:07,200
0,630
between

694
00:21:07,400 --> 00:21:08,810
0,330 330,870 870,1050 1080,1350 1350,1410
Unix processes to talk to

695
00:21:08,810 --> 00:21:10,760
0,150 150,630 630,1050 1560,1740 1740,1950
the service,| so, {} that
|所以，那个想法也是一个成功的想法，被广泛采用。

696
00:21:10,760 --> 00:21:12,100
0,240 240,690
idea also,

697
00:21:14,640 --> 00:21:15,660
0,60 60,210 210,270 270,750 750,1020
{} was a successful idea

698
00:21:15,660 --> 00:21:17,060
0,90 90,360 360,810
and widely adopted.|
|

699
00:21:17,550 --> 00:21:19,080
0,330 330,690 870,1380 1380,1470 1470,1530
Okay, so this is the
好的，这是基本架构，

700
00:21:19,080 --> 00:21:21,930
0,270 270,1080 1410,1980 2310,2760 2760,2850
basic architecture,| I'm going to
|我将继续谈论一些方式和原因，

701
00:21:21,990 --> 00:21:23,490
0,510 510,630 630,750 750,1170 1170,1500
go on and talk about

702
00:21:23,850 --> 00:21:25,530
0,240 240,540 540,780 1050,1530 1530,1680
some ways and reasons| why
|为什么这个有吸引力，

703
00:21:25,530 --> 00:21:26,970
0,180 180,300 300,390 390,1020 1080,1440
this might be attractive,| but
|但首先是高层次的问题，

704
00:21:26,970 --> 00:21:27,900
0,240 240,300 300,420 420,600 600,930
first are there any just

705
00:21:27,900 --> 00:21:29,520
0,150 150,270 270,750 750,1200 1200,1620
kind of high-level questions about,|
|

706
00:21:31,730 --> 00:21:32,390
0,180 180,270 270,390 390,450 450,660
what it is I mean
微内核是什么。

707
00:21:32,390 --> 00:21:33,760
0,90 90,180 180,450 450,810
by {} micro kernel.|
|

708
00:21:38,950 --> 00:21:41,260
0,780 840,1380
Okay {}.|
好的。|

709
00:21:42,700 --> 00:21:44,040
0,690
So,
那么，人们希望的是什么，

710
00:21:44,920 --> 00:21:45,820
0,330 330,480 480,570 570,660 660,900
what is it that people

711
00:21:45,820 --> 00:21:48,520
0,90 90,480 480,960 1440,2010
are hoping for, {}|
|

712
00:21:50,450 --> 00:21:52,680
0,330 330,630 630,630
when they {
当他们开始构建微内核的时候。

713
00:21:52,710 --> 00:21:54,240
0,330 330,660 660,900 900,1200 1230,1530
-} started building micro micro

714
00:21:54,240 --> 00:21:55,960
0,360 360,600
kernels.| So,
|所以，一个很大的动机，

715
00:21:56,340 --> 00:21:58,080
0,210 210,420 420,1350 1350,1620 1620,1740
one big motivation,| although you
|尽管你不一定会看到它被写得很多，

716
00:21:58,080 --> 00:21:59,220
0,210 210,690 690,870 870,960 960,1140
wouldn't necessarily see it written

717
00:21:59,220 --> 00:22:00,030
0,240 240,450 450,570 570,750 750,810
down much,| it's just a
|这只是一种审美。

718
00:22:00,030 --> 00:22:02,010
0,240 240,330 330,1290 1500,1830 1860,1980
sense of aesthetics, right.| I
|我想很多人都觉得

719
00:22:02,010 --> 00:22:02,730
0,180 180,390 390,480 480,660 660,720
think just a lot of

720
00:22:02,730 --> 00:22:05,790
0,570 750,1080 1080,1260 1260,1800 1800,3060
people feel| that huge complicated
|像 Linux 内核这样庞大复杂的单一程序，

721
00:22:05,850 --> 00:22:07,830
0,600 630,1020 1020,1500 1500,1710 1710,1980
a single programs like {}

722
00:22:07,890 --> 00:22:10,080
0,240 240,450 720,1110 1110,1620 1740,2190
like {} Linux kernel {}|
|

723
00:22:10,200 --> 00:22:11,460
0,150 150,330 330,510 510,720 720,1260
are just not very elegant,|
并不是很优雅，|

724
00:22:11,640 --> 00:22:12,960
0,240 240,750 750,900 900,1080 1080,1320
that surely we can build
当然，我们可以构建系统，

725
00:22:12,960 --> 00:22:15,990
0,300 300,570 1440,1770 1770,2430 2700,3030
something| that's much more {}
|更小，更有针对性的设计，

726
00:22:16,020 --> 00:22:18,030
0,420 420,600 600,1590 1590,1830 1830,2010
much much smaller much more

727
00:22:18,030 --> 00:22:19,410
0,360 360,810 810,1020 1020,1290 1290,1380
focused design,| isn't such a
|而不是一个巨大的有随机不同功能的[袋子]，

728
00:22:19,410 --> 00:22:21,380
0,300 300,690 690,1320
huge [grab bag]

729
00:22:21,380 --> 00:22:23,900
0,210 240,630 630,990 990,1740 2400,2520
of random different features,| so
|所以我觉得有一种强烈的审美，

730
00:22:23,900 --> 00:22:24,350
0,60 60,180 180,270 270,360 360,450
I think there was a

731
00:22:24,350 --> 00:22:25,960
0,480 480,690 690,900
strong sort of

732
00:22:26,580 --> 00:22:28,400
0,570 570,1200
aesthetic feeling,|
|

733
00:22:28,680 --> 00:22:29,700
0,360 360,450 450,570 570,690 690,1020
surely we can do better
我们当然可以做得比大内核更好。

734
00:22:29,700 --> 00:22:31,240
0,150 150,330 330,1020
than big kernels.|
|

735
00:22:31,360 --> 00:22:33,790
0,450 1680,1860 1860,2070 2070,2220 2220,2430
{} But others are more
但是还有其他更具体可以量化的东西，

736
00:22:33,790 --> 00:22:34,900
0,450 450,660 660,750 750,870 870,1110
specific things that you might

737
00:22:34,900 --> 00:22:36,640
0,90 90,300 300,510 540,1320 1320,1740
be able to quantify| or
|或者更小的内核可能更安全，

738
00:22:37,270 --> 00:22:39,010
0,420 420,630 630,870 870,1020 1020,1740
something a kernel that's small

739
00:22:40,030 --> 00:22:42,610
0,630 1050,1590 1590,1800 1800,1980 1980,2580
{} might be more secure,

740
00:22:44,930 --> 00:22:46,460
0,360 750,990 990,1200 1200,1470 1470,1530
right,| a few lines of
|代码越少， bug 越少，

741
00:22:46,460 --> 00:22:47,810
0,300 300,390 390,840 840,1140 1140,1350
code you have, probably fewer

742
00:22:47,810 --> 00:22:50,000
0,300 300,390 390,840 1200,1770 1770,2190
bugs you have,| less chance
|更少有人利用其中的 bug 来破坏安全，

743
00:22:50,000 --> 00:22:51,560
0,210 690,1110 1110,1200 1200,1380 1380,1560
of somebody be able to

744
00:22:51,560 --> 00:22:52,760
0,420 420,540 540,600 600,780 780,1200
exploit one of those bugs

745
00:22:52,760 --> 00:22:55,520
0,270 390,810 810,1440 1860,2250 2490,2760
to break security,| {} and
|然后最极端的是，

746
00:22:55,520 --> 00:22:56,820
0,180 180,420 420,810
then the {}

747
00:22:57,000 --> 00:22:59,840
0,660 660,780 780,1350 1590,2280
extreme of that {},|
|

748
00:22:59,930 --> 00:23:01,910
0,210 210,480 480,1110 1110,1560 1560,1980
you could imagine operating system
你可以想象操作系统可以证明是对的，

749
00:23:01,910 --> 00:23:04,580
0,300 300,720 720,1410 1530,2010 2010,2670
that's actually provable provably correct,|
|

750
00:23:05,300 --> 00:23:06,440
0,630

751
00:23:06,950 --> 00:23:08,270
0,300 300,630 630,900 960,1200 1200,1320
where somebody can sit down
有人可以写一份证明，

752
00:23:08,270 --> 00:23:09,110
0,90 90,210 210,240 240,540 540,840
and write a proof,| that
|操作系统没有 bug ，

753
00:23:09,410 --> 00:23:10,670
0,300 390,750 750,960 960,1140 1140,1260
the operating system has no

754
00:23:10,670 --> 00:23:11,780
0,420 420,510 510,660 660,1020 1020,1110
bugs| or does exactly what
|或者做它应该做的事，其他什么也不做。

755
00:23:11,780 --> 00:23:12,410
0,90 90,330 330,390 390,540 540,630
it's supposed to do and

756
00:23:12,410 --> 00:23:14,600
0,240 240,720 1500,1680 1680,2010 2010,2190
nothing else.| And indeed there
|并且确实有一个，

757
00:23:14,600 --> 00:23:16,310
0,180 180,390 390,720 1140,1380 1380,1710
is { -} at least
|

758
00:23:16,310 --> 00:23:17,440
0,600
one|
|

759
00:23:17,760 --> 00:23:20,880
0,930 930,1590 1590,2130 2130,2460 2460,3120
verified, proved correct, proved secure
证明是正确的，证明是安全的操作系统，叫做 seL4 ，

760
00:23:21,330 --> 00:23:23,100
0,450 450,750 750,1140 1140,1440 1440,1770
operating system named {seL4 -},|
|

761
00:23:23,100 --> 00:23:24,390
0,210 210,510 810,1140 1140,1230 1230,1290
which is one of the
它是 L4 微内核的众多后代之一，

762
00:23:24,390 --> 00:23:26,130
0,270 270,930 930,1020 1020,1110 1110,1740
many descendants of the L4

763
00:23:26,580 --> 00:23:27,820
0,300 300,750
micro kernel,|
|

764
00:23:27,880 --> 00:23:29,120
0,690

765
00:23:30,000 --> 00:23:32,280
0,420 720,1050 1050,1440 1500,1920 2010,2280
{} today's paper,| but you
今天的论文，|人们知道，

766
00:23:32,280 --> 00:23:33,330
0,300 300,390 390,630 630,960 960,1050
really you know people know|
|

767
00:23:33,330 --> 00:23:35,550
0,90 90,180 180,990 1440,2130 2130,2220
how to verify small to
如何验证中小型程序，

768
00:23:35,550 --> 00:23:36,660
0,270 270,570 570,960 960,1050 1050,1110
medium sized programs,| but they
|但他们不知道如何验证巨大的程序，

769
00:23:36,660 --> 00:23:37,410
0,120 120,210 210,300 300,390 390,750
don't know how to verify

770
00:23:37,410 --> 00:23:38,820
0,300 300,840 840,1080 1080,1170 1170,1410
huge programs| unless the fact
|除非微内核很小，

771
00:23:38,820 --> 00:23:40,770
0,120 120,630 630,720 720,1290 1500,1950
that {micro,kernels} are small,| sort
|一种关键的因素，能够证明它们是正确的。

772
00:23:40,770 --> 00:23:42,270
0,60 60,480 480,1110 1110,1350 1350,1500
of critical ingredient and be

773
00:23:42,270 --> 00:23:43,350
0,120 120,210 210,450 450,570 570,1080
able to prove their correct.|
|

774
00:23:44,320 --> 00:23:45,440
0,570

775
00:23:45,530 --> 00:23:46,430
0,330 330,540 540,630 630,750 750,900
Another reason why you might
你喜欢小的另一个原因是，

776
00:23:46,430 --> 00:23:48,320
0,180 180,690 720,900 900,1200 1500,1890
like small is that {}|
|

777
00:23:48,320 --> 00:23:49,760
0,360 360,570 570,630 630,1020 1020,1440
small amount of code is
少量代码通常更容易优化，

778
00:23:49,790 --> 00:23:50,630
0,240 240,270 270,480 480,750 750,840
often {like -} easier to

779
00:23:50,630 --> 00:23:52,640
0,930 930,1470
optimize,| than,
|跟大型程序比起来。

780
00:23:54,550 --> 00:23:56,780
0,420 420,870 870,1140 1140,1530
than a huge program.|
|

781
00:23:57,720 --> 00:23:59,160
0,360 360,630 630,870 870,1260 1260,1440
Another reason why small might
另一个小的可能更快原因是，

782
00:23:59,160 --> 00:24:00,390
0,300 300,390 390,840 840,960 960,1230
result in fast is that|
|

783
00:24:00,510 --> 00:24:01,350
0,240 240,360 360,450 450,570 570,840
you don't have to pay
你不必为很多你不用的功能考虑，

784
00:24:01,350 --> 00:24:03,020
0,600 600,1110
for {}

785
00:24:03,170 --> 00:24:04,100
0,150 150,330 330,390 390,750 750,930
a lot of features you

786
00:24:04,100 --> 00:24:05,420
0,180 180,720 750,870 870,1110 1110,1320
don't use,| {you,know} micro kernel
|微内核几乎不做任何事情，

787
00:24:05,420 --> 00:24:07,490
0,150 150,480 480,990 990,1410 1650,2070
does hardly anything,| then you're
|那么你不必关心很多你不会使用的功能。

788
00:24:07,490 --> 00:24:08,180
0,180 180,420 420,510 510,540 540,690
not paying for a lot

789
00:24:08,180 --> 00:24:09,170
0,60 60,420 420,540 540,690 690,990
of features you're not using.|
|

790
00:24:11,220 --> 00:24:13,520
0,660 660,930 930,1050 1050,1650
Another reason for small
另一个小的原因是，

791
00:24:13,580 --> 00:24:15,470
0,270 270,600 900,1260 1260,1560 1560,1890
is that,| {} small kernel
|小内核可能会产生更少的设计决策，

792
00:24:15,470 --> 00:24:17,150
0,270 270,660 660,840 840,1260 1260,1680
probably bakes in far fewer

793
00:24:17,150 --> 00:24:19,550
0,420 420,1170 1170,1650 1650,2070 2070,2400
design decisions,| forces fewer design
|让应用程序编写者做出更少的设计决策，

794
00:24:19,550 --> 00:24:22,730
0,450 450,570 570,1080 1080,1650 3030,3180
decisions on application writers| and
|所以，它给他们留下了更多灵活性，

795
00:24:22,730 --> 00:24:23,480
0,120 120,180 180,360 360,480 480,750
so it leaves them more

796
00:24:23,540 --> 00:24:25,100
0,510 510,690 690,780 780,960 960,1560
maybe leaves them more flexible

797
00:24:25,280 --> 00:24:26,750
0,720 720,810 810,930 930,1140 1140,1470
flexibility| to make their own
|让他们做自己的设计决策。

798
00:24:26,750 --> 00:24:28,300
0,330 330,1140
design decisions.|
|

799
00:24:30,800 --> 00:24:31,550
0,180 180,300 300,420 420,600 600,750
By the way, these are
顺便说一句，所有这些，

800
00:24:31,550 --> 00:24:33,300
0,210 210,390 390,630 660,1230
all,| these are not
|这些不是微内核方法的必然结果，

801
00:24:34,300 --> 00:24:36,100
0,600 600,1260 1260,1440 1440,1530 1530,1800
necessary consequences of the micro

802
00:24:36,100 --> 00:24:37,510
0,240 240,780 870,1140 1140,1200 1200,1410
kernel approach,| these are things
|这些都是人们希望通过使用微内核来实现的。

803
00:24:37,510 --> 00:24:38,530
0,120 120,330 330,630 630,900 900,1020
that people hoped for and

804
00:24:38,530 --> 00:24:40,000
0,270 270,390 390,1080 1110,1230 1230,1470
tried to achieve by using

805
00:24:40,000 --> 00:24:42,820
0,270 270,870 1200,1440 2310,2610 2610,2820
micro kernels.| And another set
|另一些原因，

806
00:24:42,820 --> 00:24:44,110
0,90 90,540 540,750 750,1020 1020,1290
of reasons,| why micro kernels
|微内核看起来很有吸引力与这样一个事实有关，

807
00:24:44,110 --> 00:24:45,190
0,240 240,630 630,840 840,930 930,1080
seemed attractive has to do

808
00:24:45,190 --> 00:24:46,510
0,120 120,210 210,600 600,840 840,1320
with the fact that| a
|很多代码都是用户级别的，

809
00:24:46,510 --> 00:24:47,290
0,180 180,270 270,360 360,630 630,780
lot of the code was

810
00:24:47,290 --> 00:24:48,580
0,60 60,420 420,780
at user level,|
|

811
00:24:49,110 --> 00:24:50,340
0,630
{}
很多特性和功能，

812
00:24:50,560 --> 00:24:51,190
0,150 150,270 270,270 270,540 540,630
that is a lot of

813
00:24:51,190 --> 00:24:52,720
0,540 540,660 660,1080 1080,1170 1170,1530
features and functions,| that we
|我们在内核中使用的，

814
00:24:52,900 --> 00:24:53,900
0,450
{sort,of}

815
00:24:53,900 --> 00:24:55,070
0,390 390,570 570,660 660,810 810,1170
grown used to being inside

816
00:24:55,070 --> 00:24:56,300
0,60 60,390 390,630 630,990 990,1230
the kernel| were actual user
|实际上是用户级别的服务，

817
00:24:56,300 --> 00:24:58,550
0,210 210,960 1140,1530 1620,2040 2040,2250
level services,| so they hope
|所以他们希望通过打破内核部分，

818
00:24:58,550 --> 00:24:59,960
0,150 150,480 480,1050 1110,1350 1350,1410
that by a sort of

819
00:24:59,960 --> 00:25:01,040
0,390 390,480 480,690 690,990 990,1080
breaking the kernel part| and
|运行不同的部分，比如用户级服务，

820
00:25:01,040 --> 00:25:02,300
0,180 180,300 300,570 570,1080 1080,1260
running the different parts, like

821
00:25:03,200 --> 00:25:04,850
0,480 510,750 750,1020 1020,1530 1530,1650
a user level services,| like
|比如文件服务，文件服务服务器，

822
00:25:04,850 --> 00:25:07,160
0,90 90,390 390,1140 1170,1920 1920,2310
a file service, for file

823
00:25:07,160 --> 00:25:09,650
0,570 810,1650 1890,2130 2130,2310 2310,2490
service server,| {} that might
|这可能会使代码更加模块化，

824
00:25:09,650 --> 00:25:11,500
0,690 690,960 960,1380
cause the {}

825
00:25:12,730 --> 00:25:13,630
0,90 90,420 420,480 480,660 660,900
the code to be more

826
00:25:13,630 --> 00:25:17,080
0,750 1230,1890 1890,2070 2070,2310 2730,3450
modular,| might sort of encourage
|可能会鼓励操作系统设计人员

827
00:25:17,140 --> 00:25:18,790
0,450 450,660 660,1080 1080,1170 1170,1650
operating system designers| to split
|将所有这些功能划分为许多单独的服务，

828
00:25:18,790 --> 00:25:20,230
0,270 270,420 420,630 630,1110 1110,1440
up all these functions into

829
00:25:20,350 --> 00:25:22,040
0,540 540,1170
many separate

830
00:25:22,040 --> 00:25:23,080
0,480
{}

831
00:25:23,080 --> 00:25:24,670
0,840 840,1020 1020,1320 1320,1440 1440,1590
services,| that might that might
|那也许是一件好事。

832
00:25:24,670 --> 00:25:25,900
0,90 90,150 150,330 330,630
be a good thing.|
|

833
00:25:26,330 --> 00:25:28,700
0,300 810,1350 1350,1590 1590,2160 2190,2370
{} User level code is
用户级代码也可能更容易修改，

834
00:25:28,700 --> 00:25:31,190
0,300 300,1200 1560,1890 1890,1980 1980,2490
also possibly easier to modify,|
|

835
00:25:31,190 --> 00:25:32,660
0,360 360,660 660,960 960,1080 1080,1470
its user level it's usually
用户级别通常更容易调整，替换或修改，

836
00:25:32,660 --> 00:25:34,100
0,330 330,630 750,1080 1080,1350 1350,1440
easier to tweak it or

837
00:25:34,100 --> 00:25:35,600
0,480 480,690 690,780 780,1290 1290,1500
replace it or modify it,|
|

838
00:25:35,600 --> 00:25:37,550
0,360 1020,1320 1320,1380 1380,1650 1650,1950
than doing the same stuff
比起在内核中做同样的事情，

839
00:25:37,550 --> 00:25:38,810
0,60 60,120 120,510 510,840 900,1260
in the kernel,| so maybe
|所以也许它更容易定制，

840
00:25:38,810 --> 00:25:40,700
0,120 120,390 390,480 480,1500
it's easier to customize,|
|

841
00:25:43,610 --> 00:25:47,030
0,510 750,1200 1200,1680 2640,3030 3030,3420
{} putting the operating systems
将操作系统置于用户级别，

842
00:25:47,030 --> 00:25:48,230
0,150 150,360 360,540 540,840 840,1200
at {user,level},| that also might
|这也可能使它们更健壮，

843
00:25:48,230 --> 00:25:50,240
0,150 150,270 270,480 480,1320 1770,2010
make them more robust {},|
|

844
00:25:50,240 --> 00:25:51,530
0,210 210,510 720,900 900,1140 1140,1290
you can, you can if
如果内核出了问题，

845
00:25:51,530 --> 00:25:52,550
0,240 270,570 570,750 750,900 900,1020
the kernel something goes wrong

846
00:25:52,550 --> 00:25:54,880
0,90 90,150 150,720
with the kernel,|
|

847
00:25:55,170 --> 00:25:56,970
0,240 240,390 390,1110 1110,1680 1680,1800
you know, usually you have
通常你收到 panic 然后重启，

848
00:25:56,970 --> 00:25:58,890
0,90 90,450 450,570 570,1050 1050,1920
to panic and reboot,| because,
|因为，你不能再相信内核里的东西了，

849
00:25:59,010 --> 00:26:00,990
0,420 660,810 810,1110 1350,1800 1800,1980
{} you know you can't

850
00:26:00,990 --> 00:26:02,250
0,420 420,870 870,1140 1140,1200 1200,1260
necessarily trust what's in the

851
00:26:02,250 --> 00:26:03,390
0,270 270,690 690,810 810,960 960,1140
kernel anymore,| if it's had
|如果它有一些 bug ，

852
00:26:03,390 --> 00:26:04,500
0,120 120,390 390,510 510,690 690,1110
some bug,| that maybe causes
|可能会导致它覆盖其数据的随机部分，

853
00:26:04,500 --> 00:26:06,270
0,120 120,210 210,930 1320,1500 1500,1770
it to overwrite a random

854
00:26:06,270 --> 00:26:08,130
0,210 210,270 270,450 450,780 1260,1860
part of its data,| whereas
|如果你有一堆用户级别的服务，

855
00:26:08,130 --> 00:26:09,120
0,240 240,540 570,750 750,810 810,990
if you have a bunch

856
00:26:09,120 --> 00:26:10,230
0,60 60,270 270,510 510,1020 1020,1110
of user level services| and
|它们中的一个发生故障，

857
00:26:10,230 --> 00:26:11,550
0,90 90,150 150,270 270,1110 1110,1320
one of them malfunctions| and
|除零操作，或这释放野指针，

858
00:26:11,640 --> 00:26:13,650
0,600 600,720 720,1320 1320,1590 1680,2010
devised by zero or {dereferences

859
00:26:13,650 --> 00:26:15,750
0,600 600,720 720,1050 1050,1530 1650,2100
-} a wild pointer,| maybe
|也许只有那台服务器崩溃，

860
00:26:15,750 --> 00:26:16,980
0,210 210,420 420,660 660,1110 1110,1230
only that one server will

861
00:26:16,980 --> 00:26:18,120
0,510 510,630 630,870 870,930 930,1140
crash| and leaving the rest
|让操作系统的其他部分完好无损，

862
00:26:18,120 --> 00:26:19,740
0,60 60,150 150,510 510,1080 1170,1620
of the operating system intact,|
|

863
00:26:19,740 --> 00:26:20,700
0,90 90,240 240,330 330,480 480,960
then maybe you can restart
然后也许你可以重启它，

864
00:26:20,700 --> 00:26:22,260
0,270 570,930 930,1050 1050,1230 1230,1560
it,| just that one server,|
|只重启那一台服务器，|

865
00:26:22,260 --> 00:26:24,760
0,180 180,990 1230,1620 1620,2130
so maybe user level,
所以，也许将操作系统功能移动到用户级进程，

866
00:26:25,050 --> 00:26:27,990
0,300 300,570 570,1590 2070,2490 2550,2940
{moving,OS -} functionality to user

867
00:26:27,990 --> 00:26:29,520
0,450 450,900 960,1230 1230,1320 1320,1530
process| might lead to more
|可能会带来更强的健壮性，

868
00:26:29,520 --> 00:26:31,680
0,660 780,1170 1170,1560
robustness,| {this,is} surprise,|
|这是令人惊讶的，|

869
00:26:31,680 --> 00:26:33,960
0,600 600,870 870,960 960,1680 1890,2280
particularly evident for drivers,| there
特别是对驱动程序来说，|内核中或硬件设备驱动程序中存在大多数 bug ，

870
00:26:33,960 --> 00:26:36,240
0,840 1020,1740 1770,1860 1860,1920 1920,2280
most bugs in the kernel

871
00:26:36,240 --> 00:26:37,500
0,150 150,660
or actually

872
00:26:37,700 --> 00:26:39,650
0,420 420,750 750,1410 1530,1860 1860,1950
hardware device drivers,| if we
|如果我们能设法将设备驱动程序移出内核，

873
00:26:39,650 --> 00:26:40,310
0,90 90,360 360,480 480,600 600,660
can manage to move the

874
00:26:40,310 --> 00:26:41,270
0,330 330,720 720,840 840,900 900,960
device drivers out of the

875
00:26:41,270 --> 00:26:42,770
0,540 660,960 960,1080 1080,1260 1260,1500
kernel,| then we might have
|那么我们在内核中崩溃的 bug 可能会少得多。

876
00:26:42,800 --> 00:26:44,810
0,270 270,660 780,1440 1440,1920 1920,2010
many fewer bugs crashes in

877
00:26:44,810 --> 00:26:46,640
0,60 60,420
the kernel.|
|

878
00:26:46,840 --> 00:26:47,950
0,150 150,210 210,600 600,1020 1020,1110
And the final advantage,| the
而最后一个好处，|人们想的是，

879
00:26:47,950 --> 00:26:49,150
0,330 330,450 450,750 750,990 990,1200
people were thinking about back

880
00:26:49,150 --> 00:26:50,740
0,210 210,360 360,690 930,1290 1290,1590
then is that,| you could
|你可以模拟一个或多个操作系统，

881
00:26:50,770 --> 00:26:52,510
0,540 540,630 630,870 870,1350 1350,1740
emulate one or multiple operating

882
00:26:52,510 --> 00:26:54,130
0,300 300,1170 1170,1260 1260,1530 1530,1620
system [personalities]| on top of
|在一个微内核上，

883
00:26:54,130 --> 00:26:55,540
0,90 90,390 390,810 1050,1260 1260,1410
a micro kernel,| so even
|所以，即使微内核几乎不直接为你做任何事情，

884
00:26:55,540 --> 00:26:56,830
0,120 120,390 390,690 690,1020 1110,1290
though micro kernel does does

885
00:26:56,830 --> 00:26:58,330
0,360 360,690 690,810 810,930 930,1500
hardly anything for you directly,|
|

886
00:26:58,360 --> 00:26:59,050
0,270 270,420 420,480 480,630 630,690
you might be able to
你也可以运行 Unix 服务器或其他东西在它上面，

887
00:26:59,050 --> 00:27:00,220
0,150 150,240 240,630 630,1080 1080,1170
run a Unix server or

888
00:27:00,220 --> 00:27:01,600
0,540 570,720 720,1020 1020,1080 1080,1380
something on top of it,|
|

889
00:27:01,900 --> 00:27:03,280
0,210 210,480 480,720 720,840 840,1380
{} maybe more than one
可能在一台机器上不止一个。

890
00:27:03,920 --> 00:27:06,110
0,390 390,570 570,630 630,1350 1470,2190
{} on the same machine.|
|

891
00:27:08,760 --> 00:27:09,810
0,120 120,330 330,510 510,720 720,1050
Of course, that's what today's
当然，这是今天的论文所说的，

892
00:27:09,810 --> 00:27:12,660
0,420 420,1110 1620,2040 2040,2130 2130,2850
papers about,| running {} Unix,
|在微内核上运行 Unix 或 Linux 作为服务，

893
00:27:12,990 --> 00:27:15,270
0,390 390,930 930,1260 1260,1500 1800,2280
running Linux as a service

894
00:27:15,270 --> 00:27:16,860
0,90 90,120 120,540 1050,1440 1440,1590
on a {micro,kernel},| these are
|这些都是人们希望的东西，

895
00:27:16,860 --> 00:27:18,200
0,780
all

896
00:27:18,680 --> 00:27:19,490
0,210 210,360 360,570 570,630 630,810
{} the set of things

897
00:27:19,490 --> 00:27:20,390
0,150 150,360 360,450 450,780 780,900
that people were hoping| to
|能够获得一些[吸引力]，

898
00:27:20,390 --> 00:27:21,740
0,120 120,300 300,630 810,1230 1230,1350
be able to get some

899
00:27:21,740 --> 00:27:24,680
0,450 450,690 690,1170 2190,2790 2790,2940
[traction]| on by looking into
|通过研究微内核设计。

900
00:27:24,680 --> 00:27:26,460
0,240 240,540 540,1290
micro kernel designs.|
|

901
00:27:27,010 --> 00:27:28,920
0,690 690,870 870,1320
{Of,course}, there's some
当然会有一些难题，你必须想清楚，

902
00:27:28,920 --> 00:27:31,140
0,450 750,960 960,1230 1710,2130 2130,2220
{} sort of puzzles, you

903
00:27:31,140 --> 00:27:32,720
0,90 90,210 210,450 450,960
have to think through,|
|

904
00:27:33,020 --> 00:27:34,600
0,180 180,1050
some challenges.|
一些挑战。|

905
00:27:37,810 --> 00:27:39,680
0,450 450,1350
One challenge,
如果你想设计自己的微内核，一个挑战是，

906
00:27:39,940 --> 00:27:40,720
0,210 210,300 300,420 420,480 480,780
if you want to design

907
00:27:40,720 --> 00:27:41,920
0,120 120,210 210,450 450,840 840,1200
your own micro kernel is|
|

908
00:27:42,160 --> 00:27:43,390
0,390 390,780 780,990 990,1080 1080,1230
actually figuring out you want
找出 API ，

909
00:27:43,390 --> 00:27:44,560
0,300 300,780 780,870 870,990 990,1170
the API| you want the
|你希望微内核系统调用接口

910
00:27:44,590 --> 00:27:46,300
0,420 420,660 660,1080 1080,1260 1260,1710
micro kernel system call interface|
|

911
00:27:46,300 --> 00:27:47,410
0,90 90,270 270,540 540,960 960,1110
to be as simple as
尽可能的简单，

912
00:27:47,410 --> 00:27:48,970
0,540 750,1050 1050,1140 1140,1290 1290,1560
possible,| because the whole point
|因为关键是要让它变得很小，

913
00:27:48,970 --> 00:27:49,960
0,120 120,210 210,390 390,480 480,990
was to keep it small|
|

914
00:27:50,290 --> 00:27:51,250
0,120 120,360 360,510 510,630 630,960
and what is the actual
什么是最小可以系统调用，

915
00:27:51,250 --> 00:27:54,160
0,510 510,870 900,1290 1410,2100 2520,2910
smallest set of useful system

916
00:27:54,160 --> 00:27:55,240
0,540 540,660 660,750 750,870 870,1080
calls| you can get [away]
|你可以[使用]的，

917
00:27:55,240 --> 00:27:56,080
0,420
with,|
|

918
00:27:56,140 --> 00:27:57,430
0,540 570,930 930,990 990,1170 1170,1290
{} you know what does
它看起来是什么样子的，

919
00:27:57,430 --> 00:27:58,720
0,90 90,270 270,600
it look like,|
|

920
00:27:59,240 --> 00:28:01,500
0,390 390,720 720,1170 1170,1710
that's not particularly clear,|
这不是特别清楚，|

921
00:28:02,720 --> 00:28:04,100
0,330 330,450 450,540 540,1020 1020,1380
look at the minimum system
看看最小的系统调用 API 。

922
00:28:04,100 --> 00:28:05,280
0,600
call

923
00:28:07,710 --> 00:28:09,000
0,660
API.|
|

924
00:28:10,590 --> 00:28:11,820
0,750

925
00:28:12,190 --> 00:28:13,540
0,330 330,540 540,870 870,1080 1080,1350
You need these this minimum
你需要最小系统调用 API ，

926
00:28:13,540 --> 00:28:15,160
0,450 450,720 720,1260 1260,1440 1440,1620
system call API,| it's great
|它越简单越好，

927
00:28:15,160 --> 00:28:16,660
0,210 210,690 720,1020 1050,1200 1200,1500
{to,be} simple,| but you actually
|但是你必须构建一些相当复杂的功能，

928
00:28:16,660 --> 00:28:17,230
0,90 90,210 210,300 300,480 480,570
have to be able to

929
00:28:17,230 --> 00:28:20,110
0,390 750,990 990,1230 1230,2070 2070,2880
build some pretty sophisticated features|
|

930
00:28:20,110 --> 00:28:21,460
0,210 210,450 450,630 630,1020 1020,1350
out of your minimum system
在你的最小系统调用 API 之外，

931
00:28:21,460 --> 00:28:23,320
0,300 300,750 750,1170 1530,1800 1800,1860
call API,| because even {}
|因为内核做的不够多，

932
00:28:23,320 --> 00:28:24,520
0,90 90,390 390,750 750,900 900,1200
the kernel doesn't do much,|
|

933
00:28:24,520 --> 00:28:25,150
0,90 90,180 180,270 270,360 360,630
you know in the end,
最终，你必须能够运行程序，

934
00:28:25,150 --> 00:28:25,810
0,330 330,420 420,480 480,540 540,660
you've got to be able

935
00:28:25,810 --> 00:28:27,100
0,90 90,330 330,960 960,1050 1050,1290
to run programs,| you got
|你可能试着在微内核上运行 Unix ，

936
00:28:27,100 --> 00:28:28,540
0,420 570,810 810,1110 1110,1170 1170,1440
maybe you're trying to run

937
00:28:28,540 --> 00:28:29,860
0,450 450,630 780,1080 1080,1200 1200,1320
Unix on top of a

938
00:28:29,860 --> 00:28:30,820
0,270 270,570 570,720 720,810 810,960
micro kernel,| to be able
|为了能够执行 fork mmap 之类的操作，

939
00:28:30,820 --> 00:28:32,350
0,120 120,570 570,750 750,1140 1140,1530
do things like fork {mmap

940
00:28:32,350 --> 00:28:35,500
0,450 780,1380 1500,2010 2310,2970 2970,3150
-},| {} so as part
|所以作为系统调用接口的一部分，

941
00:28:35,500 --> 00:28:37,060
0,60 60,150 150,390 390,660 660,1560
of the system call interface,|
|

942
00:28:37,090 --> 00:28:38,240
0,780
simple
简单低级系统调用接口，

943
00:28:38,490 --> 00:28:40,500
0,660 660,930 930,1110 1110,1620 1770,2010
low-level system call interface,| it
|它必须足够强大，

944
00:28:40,500 --> 00:28:41,940
0,300 300,420 420,570 570,1230 1230,1440
has to be powerful enough|
|

945
00:28:41,940 --> 00:28:44,540
0,120 120,990
to support
以支持人们需要做的所有事情，

946
00:28:45,620 --> 00:28:46,760
0,390 390,480 480,690 690,930 930,1140
all the stuff people need

947
00:28:46,760 --> 00:28:49,020
0,90 90,390 390,780 810,1590
to do,| like exec
|比如 exec 和 fork ，

948
00:28:49,370 --> 00:28:52,160
0,690 720,1530 1920,2070 2070,2580 2580,2790
and fork| and hack maybe
|甚至可能是写入时复制 fork |

949
00:28:52,160 --> 00:28:53,780
0,300 330,750 750,930 930,1200 1200,1620
even {copy-on-write - -} fork|

950
00:28:53,780 --> 00:28:56,630
0,300 540,1170 1170,1800 2280,2550 2550,2850
or memory mapping on disk
或磁盘文件的内存映射，

951
00:28:56,630 --> 00:28:57,770
0,690 690,810 810,1020 1020,1080 1080,1140
files,| but all in a
|但这些都在一个没有文件系统的内核中，

952
00:28:57,770 --> 00:28:59,180
0,300 300,480 660,990 990,1170 1170,1410
kernel that has no idea

953
00:28:59,180 --> 00:29:00,740
0,240 240,750 750,870 870,1200 1200,1560
about files or file system,|
|

954
00:29:01,310 --> 00:29:02,720
0,330 330,420 420,810 810,1260 1260,1410
needs to support exec,| but
需要支持 exec ，|但内核对文件一无所知。

955
00:29:02,720 --> 00:29:03,920
0,120 120,180 180,510 510,690 990,1200
with {} kernel that knows

956
00:29:03,920 --> 00:29:06,320
0,240 240,480 480,1110
nothing about files.|
|

957
00:29:06,440 --> 00:29:08,360
0,510 600,1110 1110,1320 1320,1470 1470,1920
{} We need the rest
我们需要操作系统的其他部分，

958
00:29:08,360 --> 00:29:09,680
0,150 150,630
of the,

959
00:29:11,090 --> 00:29:13,160
0,270 270,600 600,960 960,1590 1650,2070
the operating system,| somehow ensure
|以某种方式确保微内核可能非常简单，

960
00:29:13,160 --> 00:29:14,740
0,90 90,330 330,570 570,1020
that micro kernel maybe

961
00:29:14,860 --> 00:29:16,240
0,240 240,420 420,780 780,1110 1230,1380
{} very simple,| but you
|但是现在我们需要开发一些用户级的服务，

962
00:29:16,240 --> 00:29:18,550
0,60 60,540 540,1050 1380,2220 2220,2310
know now we're requiring the

963
00:29:18,550 --> 00:29:20,170
0,540 540,930 960,1350 1350,1530 1530,1620
development of some set of

964
00:29:20,170 --> 00:29:22,140
0,240 240,510 510,1170 1170,1380
user level servers,| that
|实现操作系统的其他部分，

965
00:29:22,140 --> 00:29:22,980
0,450 450,510 510,690 690,750 750,840
implement the rest of the

966
00:29:22,980 --> 00:29:24,960
0,330 330,810 1290,1560 1560,1650 1650,1980
operating system,| so we need,
|所以我们至少要做到这一点，

967
00:29:25,230 --> 00:29:26,250
0,240 270,510 510,600 600,780 780,1020
that has to get done

968
00:29:26,250 --> 00:29:27,390
0,120 120,540 540,690 690,840 840,1140
at least| and may require
|可能需要解决一些设计难题，

969
00:29:27,390 --> 00:29:31,200
0,390 990,1380 1380,1710 1710,2250 3480,3810
some solving design puzzles,| and
|最后，这种安排需要大量通信，

970
00:29:31,200 --> 00:29:33,270
0,540 540,1050 1620,1770 1770,1860 1860,2070
finally, the you know this

971
00:29:33,270 --> 00:29:34,650
0,690 720,1110 1110,1170 1170,1290 1290,1380
arrangement requires a lot of

972
00:29:34,650 --> 00:29:37,350
0,600 600,1080 1200,1440 1440,2040 2040,2700
chitchat| over inter processor communication
|通过 IPC 进程间通信，

973
00:29:37,350 --> 00:29:40,470
0,180 180,930 1290,1770 1920,2460 2580,3120
over IPC,| {} so there's
|所以会有很大的压力让 IPC 非常快，

974
00:29:40,470 --> 00:29:41,610
0,120 120,180 180,270 270,600 600,1140
going to be great pressure

975
00:29:41,610 --> 00:29:43,560
0,180 180,510 510,870 1080,1500
to make the {}

976
00:29:43,650 --> 00:29:45,520
0,810
{}

977
00:29:46,190 --> 00:29:47,720
0,150 150,330 330,570 570,1110 1110,1530
{you,know} IPC very fast,| so
|所以，需要知道 IPC 是否能足够快，

978
00:29:47,780 --> 00:29:49,860
0,180 180,510 510,1110
{you,know} wonder whether

979
00:29:49,950 --> 00:29:51,630
0,510 510,990 990,1140 1140,1350 1350,1680
IPC can be made fast

980
00:29:51,630 --> 00:29:52,600
0,450
enough,|
|

981
00:29:53,420 --> 00:29:56,390
0,390 780,1080 1080,1320 1320,1620 1620,2970
to keep micro kernels competitive.|
让微内核保持竞争力。|

982
00:29:57,700 --> 00:29:59,920
0,480 1110,1590 1710,1950 1950,2130 2130,2220
Alright, {} and just in
好的，一般说来，

983
00:29:59,920 --> 00:30:01,870
0,300 300,720 720,1050 1230,1560 1560,1950
general,| actually the not just
|不仅仅是 IPC 的速度，

984
00:30:01,930 --> 00:30:03,850
0,600 600,900 900,1110 1230,1470 1470,1920
IPC speed,| but in general,|
|但总的来说，|

985
00:30:04,720 --> 00:30:05,860
0,420 480,780 780,840 840,1050 1050,1140
a lot of reason to
有很多理由相信宏内核可以获得一定的性能，

986
00:30:05,860 --> 00:30:08,080
0,390 390,660 660,1230 1230,1770 1770,2220
believe that monolithic kernels derived

987
00:30:08,080 --> 00:30:09,910
0,240 240,1080 1080,1290 1290,1470 1650,1830
some performance| out of the
|因为它们是集成的，

988
00:30:09,910 --> 00:30:11,020
0,210 210,330 330,450 450,990 990,1110
fact that they're integrated,| that
|文件系统代码可以与虚拟内存代码和内存分配代码交互，

989
00:30:11,020 --> 00:30:12,310
0,90 90,330 330,660 660,1080 1080,1290
the file system code can

990
00:30:12,430 --> 00:30:13,720
0,420 420,510 510,600 600,930 930,1290
talk to the virtual memory

991
00:30:13,720 --> 00:30:15,460
0,270 270,420 420,690 690,1200 1200,1740
code and memory allocation code,|
|

992
00:30:15,730 --> 00:30:16,540
0,240 240,360 360,540 540,600 600,810
it's all sort of one
它是一个[快乐的]大项目。

993
00:30:16,540 --> 00:30:18,880
0,210 210,720 720,1050 1050,1710 1860,2340
big happy giant program {}.|
|

994
00:30:19,710 --> 00:30:21,570
0,270 270,360 360,480 480,1020 1560,1860
And if you require all
如果将所有这些内容拆分到单独的服务中，

995
00:30:21,570 --> 00:30:22,440
0,180 180,330 330,420 420,510 510,870
those things to be split

996
00:30:22,440 --> 00:30:23,730
0,180 180,390 390,720 720,1200 1200,1290
out into separate servers| or
|或者可能拆分到内核和用户级别，

997
00:30:23,730 --> 00:30:24,570
0,120 120,240 240,540 540,780 780,840
may be split between the

998
00:30:24,570 --> 00:30:26,730
0,570 570,780 1230,1680 1680,1980 1980,2160
kernel and user level,| there
|通过集成的方式进行优化的机会可能较少，

999
00:30:26,730 --> 00:30:28,140
0,120 120,240 240,570 570,1230 1230,1410
may be fewer opportunities for

1000
00:30:28,140 --> 00:30:30,330
0,780 780,960 960,1200 1200,1530 1560,2190
optimization by way of integration,|
|

1001
00:30:30,540 --> 00:30:31,500
0,390 390,510 510,690 690,840 840,960
then that may or may
然后可能会也可能不会损害性能。

1002
00:30:31,500 --> 00:30:34,230
0,540 1320,1530 1530,1650 1650,1890 1890,2730
not end up hurting performance.|
|

1003
00:30:34,600 --> 00:30:36,060
0,570

1004
00:30:37,200 --> 00:30:39,860
0,660
Alright.|
好的。|

1005
00:30:39,980 --> 00:30:40,700
0,150 150,360 360,450 450,630 630,720
So these are sort of
所以这些都是期望的优势，

1006
00:30:40,700 --> 00:30:44,270
0,870 870,1740 2130,2640 2640,2880 2880,3570
crosscutting {} hoped for wins|
|

1007
00:30:44,270 --> 00:30:45,770
0,360 420,780 780,840 840,1350 1350,1500
and sort of challenges that
以及所有挑战，

1008
00:30:45,770 --> 00:30:48,140
0,540 840,1080 1080,1320 1320,1830 2040,2370
all,| {} the many micro
|很多微内核项目所面对的。

1009
00:30:48,140 --> 00:30:52,220
0,390 390,930 930,1530
kernel projects faced.|
|

1010
00:30:53,000 --> 00:30:54,230
0,300 300,390 390,750 750,1110 1110,1230
Because of today's paper,| I'm
因为今天的论文，|我要告诉你们一些关于 L4 的事情，

1011
00:30:54,230 --> 00:30:56,600
0,750 1500,1950 1950,2100 2100,2130 2130,2370
gonna tell you a bunch

1012
00:30:56,600 --> 00:30:58,220
0,60 60,300 300,480 480,960 960,1620
of about {L4 -} specifically,|
|

1013
00:30:58,220 --> 00:30:59,560
0,210 210,390 390,630
which is {}
它是今天论文作者开发和使用的微内核。

1014
00:31:00,360 --> 00:31:01,980
0,180 180,450 450,990
the micro kernel

1015
00:31:02,320 --> 00:31:03,700
0,270 270,480 780,930 930,1290 1290,1380
{} the the authors of

1016
00:31:03,700 --> 00:31:05,440
0,360 360,630 630,1080 1080,1230 1230,1740
today's paper developed and used.|
|

1017
00:31:07,630 --> 00:31:10,800
0,840 840,1140 1140,1980
{L4,is -} not,
L4 当然不是最早的微内核，

1018
00:31:10,920 --> 00:31:12,090
0,210 210,420 420,540 540,630 630,1170
it's certainly not the earliest

1019
00:31:12,090 --> 00:31:13,170
0,240 240,540 540,690 690,930 930,1080
micro kernel ever made,| but
|但它是早期微内核之一，

1020
00:31:13,170 --> 00:31:14,430
0,540 540,840 840,930 930,1050 1050,1260
it's one of the sort

1021
00:31:14,430 --> 00:31:16,170
0,90 120,480 480,750 750,1410 1620,1740
of early micro kernels,| that
|从 20 世纪 80 年代开始的所有工作中，

1022
00:31:16,170 --> 00:31:16,890
0,240 240,390 390,480 480,600 600,720
came out of all the

1023
00:31:16,890 --> 00:31:18,750
0,240 240,360 360,870 1020,1770 1770,1860
work in this starting in

1024
00:31:18,750 --> 00:31:20,640
0,60 60,390 390,1020 1380,1710 1710,1890
the {1980s -}| and it's
|就工作原理而言，是相当有代表性的。

1025
00:31:20,640 --> 00:31:22,770
0,390 390,1080 1080,1230 1230,1470 1470,2130
fairly representative as far as

1026
00:31:22,950 --> 00:31:24,320
0,240 240,330 330,840
how it works.|
|

1027
00:31:25,140 --> 00:31:27,240
0,330 330,900 1230,1710 1710,1950 1950,2100
There's been, it's a bit
一些目标是，

1028
00:31:27,240 --> 00:31:28,830
0,60 60,120 120,450 450,1080 1410,1590
of a moving target was|
|

1029
00:31:28,830 --> 00:31:31,140
0,180 780,1230 1230,1350 1350,1860 1860,2310
the subject of [intense] development
它发展和演变了很多年，

1030
00:31:31,140 --> 00:31:32,550
0,90 90,570 570,720 720,930 930,1410
and evolution for many years|
|

1031
00:31:32,550 --> 00:31:34,050
0,300 360,540 540,750 750,990 990,1500
and it's still going strong,|
而且它仍然很强劲，|

1032
00:31:34,620 --> 00:31:35,400
0,150 150,270 270,420 420,600 600,780
if you look at on
如果查看维基百科上，

1033
00:31:35,400 --> 00:31:36,900
0,570 570,750 750,990 990,1170 1170,1500
Wikipedia,| you'll see that there's
|你会发现 L4 有 15 到 20 种不同的变体，

1034
00:31:37,170 --> 00:31:38,790
0,510 510,930 930,990 990,1320 1320,1620
maybe 15 or 20 different

1035
00:31:38,790 --> 00:31:39,870
0,450 450,540 540,690 690,990 990,1080
variants of {L4 -},| that
|它们来了又走，有些还在这里，

1036
00:31:39,870 --> 00:31:41,070
0,120 120,570 570,690 690,1050 1050,1200
have come and gone and

1037
00:31:41,070 --> 00:31:43,440
0,180 180,240 240,450 450,960 1710,2370
some are still here,| starting
|我想从 20 世纪 80 年代末开始，

1038
00:31:43,440 --> 00:31:44,130
0,120 120,300 300,360 360,450 450,690
I think in the late

1039
00:31:44,130 --> 00:31:46,530
0,330 330,990 1620,1920 2010,2280 2280,2400
{1980s -}| and I know
|我要向你们解释的是

1040
00:31:46,530 --> 00:31:47,660
0,150 150,330 330,690
what I'm gonna

1041
00:31:47,660 --> 00:31:48,800
0,240 240,510 540,960 960,1050 1050,1140
try to explain to you

1042
00:31:48,800 --> 00:31:50,060
0,120 120,300 300,990 990,1050 1050,1260
is| my understanding of how
|我对 L4 如何工作的理解，

1043
00:31:50,060 --> 00:31:51,770
0,270 270,570 570,1020 1140,1380 1380,1710
{L4 -} worked,| at about
|在今天的论文发表的时候。

1044
00:31:51,770 --> 00:31:53,870
0,90 90,720 870,1140 1140,1560 1560,2100
the time {} today's paper

1045
00:31:54,230 --> 00:31:55,460
0,300 300,750
came out.|
|

1046
00:31:55,820 --> 00:31:58,660
0,510 540,2190

1047
00:31:58,890 --> 00:32:01,600
0,600 600,1080 1380,2010
Alright, so {}
好的，那么从高的层面来说，

1048
00:32:02,320 --> 00:32:04,810
0,390 390,450 450,1680 1680,1950 1950,2490
just at a high level,|
|

1049
00:32:04,840 --> 00:32:07,630
0,540 1020,1470 1680,2160 2160,2310 2310,2790
{} the L4 was certainly
L4 当然是微型的，

1050
00:32:07,630 --> 00:32:09,160
0,600 600,720 720,900 930,1230 1230,1530
micro,| in the sense that
|从某种意义上说，它是一个小内核，

1051
00:32:09,220 --> 00:32:11,740
0,120 120,390 390,900 1080,1830 2400,2520
it was actually is a

1052
00:32:11,740 --> 00:32:13,540
0,270 270,720 780,1050 1050,1380 1410,1800
small kernel,| it has only
|它只有 7 个系统调用，

1053
00:32:13,540 --> 00:32:16,090
0,480 480,840 840,1590 2250,2490 2490,2550
7 system calls,| some of
|有些有点复杂，

1054
00:32:16,090 --> 00:32:17,020
0,90 90,180 180,330 330,450 450,930
them a little bit complex,|
|

1055
00:32:17,020 --> 00:32:17,800
0,150 150,360 360,450 450,660 660,780
but still it only has
但它仍然只有 7 个系统调用，

1056
00:32:17,800 --> 00:32:19,810
0,300 300,630 630,1080 1110,1590 1590,2010
7 system calls,| whereas today's
|而今天的 Linux ，我最后一次统计时，有三百多个，

1057
00:32:19,810 --> 00:32:20,620
0,330 330,420 420,630 630,750 750,810
Linux, the last time I

1058
00:32:20,620 --> 00:32:21,880
0,390 390,630 750,990 990,1050 1050,1260
counted, had in the mid

1059
00:32:21,880 --> 00:32:24,400
0,210 210,1080 1950,2160 2160,2340 2340,2520
three hundreds| and even {xv6
|甚至 xv6 是一个非常简单的内核，

1060
00:32:24,400 --> 00:32:25,210
0,120 120,450 450,600 600,750 750,810
- -} which is an

1061
00:32:25,210 --> 00:32:26,830
0,540 540,870 870,1230 1230,1380 1380,1620
extremely simple kernel,| even {xv6,has
|即使 xv6 也有 21 个系统调用，

1062
00:32:26,830 --> 00:32:29,440
0,360 360,870 870,1200 1200,1740 2400,2610
-} 21 system calls,| so
|所以 L4 只有 7 个，

1063
00:32:29,440 --> 00:32:30,520
0,180 180,750
{L4 -}

1064
00:32:31,070 --> 00:32:32,180
0,720
{}

1065
00:32:33,330 --> 00:32:34,740
0,270 270,450 450,780 1110,1290 1290,1410
it's only 7,| so by
|所以通过这个度量很简单，

1066
00:32:34,740 --> 00:32:36,150
0,180 180,420 420,510 510,960 1080,1410
that metric is simple {},|
|

1067
00:32:36,150 --> 00:32:37,320
0,180 180,360 360,540 540,720 720,1170
it's also not very big,|
它也不是很大，|

1068
00:32:37,530 --> 00:32:40,560
0,420 660,1020 1020,1320 1620,2190 2430,3030
{} I think, {} {as,the}
我认为，当这篇论文写成时，大约有 13000 行代码，

1069
00:32:40,560 --> 00:32:41,610
0,240 240,420 420,690 690,840 840,1050
time this paper was written

1070
00:32:41,610 --> 00:32:44,790
0,240 240,630 720,2520 2520,2610 2610,3180
at about {13,000,lines} of code,|
|

1071
00:32:45,600 --> 00:32:47,070
0,420 420,570 570,690 690,1020 1020,1470
just not too much,| {xv6
只是没有太多，|xv6 比这更小，

1072
00:32:47,070 --> 00:32:48,000
0,120 120,330 330,420 420,810 810,930
- -} is smaller than

1073
00:32:48,000 --> 00:32:49,740
0,300
that,|
|

1074
00:32:49,890 --> 00:32:50,940
0,120 120,240 240,480 480,810 810,1050
I think {xv6 -} maybe
我认为 xv6 内核可能有 6000 到 7000 行代码，

1075
00:32:50,940 --> 00:32:52,350
0,240 240,330 330,1110 1110,1170 1170,1410
six or {7000,lines} of code

1076
00:32:52,350 --> 00:32:53,580
0,60 60,150 150,510 660,900 900,1230
in the kernel,| but still
|但就内核而言， xv6 仍然非常简单，

1077
00:32:53,580 --> 00:32:54,750
0,300 300,480 480,750 750,1020 1020,1170
xv6 is very simple as

1078
00:32:54,750 --> 00:32:56,520
0,360 360,660 1230,1380 1380,1560 1560,1770
kernels [],| {L4 -} not
|L4 并不比这更复杂，

1079
00:32:56,520 --> 00:32:57,810
0,390 420,600 600,1050 1050,1140 1140,1290
much more complex than that,|
|

1080
00:32:57,810 --> 00:32:58,560
0,90 90,210 210,510 510,600 600,750
and this is you know
这是 Linux 的十分之一、二十分之一或三十分之一，

1081
00:32:58,980 --> 00:33:00,750
0,210 210,780 780,1110 1140,1710 1710,1770
a tenth or twentieth or

1082
00:33:00,750 --> 00:33:02,820
0,600 600,750 750,990 990,1530 1890,2070
thirtieth as big as as

1083
00:33:02,820 --> 00:33:05,020
0,720 870,1110 1110,1320 1320,1680
Linux,| is pretty small.|
|是相当小的。|

1084
00:33:05,520 --> 00:33:07,110
0,330 720,1080 1080,1290 1290,1500 1500,1590
{} It had only a
它只有几个基本的抽象，

1085
00:33:07,110 --> 00:33:10,380
0,450 480,930 930,1980
few basic abstractions,|
|

1086
00:33:10,950 --> 00:33:12,480
0,270 270,1020
it had
它有任务或地址空间的概念，

1087
00:33:12,960 --> 00:33:15,480
0,270 270,720 720,1320 2310,2430 2430,2520
a notion of what they

1088
00:33:15,480 --> 00:33:18,810
0,240 240,1260 1470,1980 1980,2340 2340,3330
called tasks or address spaces,|
|

1089
00:33:20,330 --> 00:33:21,720
0,780

1090
00:33:22,170 --> 00:33:23,010
0,180 180,450 450,600 600,630 630,840
and these more or less
这些或多或少对应于我们在 Unix 中所说的进程，

1091
00:33:23,010 --> 00:33:24,300
0,450 450,510 510,840 870,1140 1140,1290
correspond to what we would

1092
00:33:24,300 --> 00:33:25,740
0,210 210,300 300,810 810,930 930,1440
call a process in Unix,|
|

1093
00:33:25,740 --> 00:33:27,510
0,210 210,480 840,930 930,1170 1500,1770
{ -} it's a bunch
这是一堆从 0 开始的内存映射，

1094
00:33:27,510 --> 00:33:29,550
0,60 60,810 810,1560 1560,1950 1950,2040
of memories map starting at

1095
00:33:29,550 --> 00:33:32,320
0,660 660,1200 1680,2250
0| and {}
|你可以在这里执行，

1096
00:33:32,500 --> 00:33:33,730
0,270 270,540 540,690 690,780 780,1230
and you're able to execute

1097
00:33:33,730 --> 00:33:35,650
0,90 90,480 780,1320 1530,1800 1800,1920
in here,| {} just like
|就像在进程中，

1098
00:33:35,650 --> 00:33:37,000
0,60 60,120 120,660 660,960 960,1350
in the process,| when different
|与 xv6 的不同之处是，

1099
00:33:37,000 --> 00:33:38,120
0,540
from

1100
00:33:38,120 --> 00:33:39,920
0,210 210,780 810,1290 1290,1500 1560,1800
{xv6 -} is that| there
|每个任务可以有多个线程，

1101
00:33:39,920 --> 00:33:42,140
0,90 90,180 180,600 600,1740
can be multiple threads

1102
00:33:42,140 --> 00:33:44,380
0,420 630,870 870,1740
{} per task,|
|

1103
00:33:45,040 --> 00:33:46,360
0,300 300,540 540,1020 1020,1230 1230,1320
and {L4 -} was in
L4 负责在每个任务中调度多个执行线程。

1104
00:33:46,360 --> 00:33:50,170
0,510 510,900 2100,3030 3030,3480 3480,3810
charge of scheduling multiple threads

1105
00:33:50,170 --> 00:33:52,450
0,60 60,840 960,1350 1350,1530 1530,2280
of execution within each task.|
|

1106
00:33:54,260 --> 00:33:56,000
0,600 1080,1440 1440,1500 1500,1560 1560,1740
And part of the reason
这样的部分原因是

1107
00:33:56,000 --> 00:33:57,170
0,90 90,300 300,420 420,660 660,1170
for this is| just it's
|它有线程非常方便，

1108
00:33:57,170 --> 00:33:58,310
0,240 240,600 600,660 660,780 780,1140
very convenient to have threads|
|

1109
00:33:58,310 --> 00:34:00,230
0,90 90,150 150,690 690,1530 1530,1920
as a programming structuring program
将线程作为编程结构化工具，

1110
00:34:00,230 --> 00:34:02,240
0,510 510,1050 1230,1680 1680,1860 1860,2010
structuring tool| and it was
|它也是，

1111
00:34:02,240 --> 00:34:05,300
0,510 1110,1890 1890,1890 2490,2910 2910,3060
also,| {} I don't know
|我不知道他们是否支持多核机器，

1112
00:34:05,300 --> 00:34:06,680
0,90 90,210 210,480 480,1050 1050,1380
if they actually supported {multi-core

1113
00:34:06,680 --> 00:34:08,750
0,360 360,1080 1080,1890 1920,2010 2010,2070
-} multiprocessor machines,| at the
|在写这篇论文的时候，

1114
00:34:08,750 --> 00:34:09,680
0,210 210,300 300,540 540,690 690,930
time the paper was written,|
|

1115
00:34:09,680 --> 00:34:11,870
0,330 690,1230 1530,1740 1740,1950 1950,2190
but, {} they may well
但是，他们很可能有线程，

1116
00:34:11,870 --> 00:34:14,030
0,450 450,930 1230,1620 1650,2070 2070,2160
have and {} threads,| of
|当然，你需要能够

1117
00:34:14,030 --> 00:34:14,900
0,210 210,360 360,480 480,630 630,870
course just what you need

1118
00:34:14,900 --> 00:34:16,010
0,60 60,120 120,270 270,330 330,1110
to be able to| harness
|利用多个核心执行同一个程序，

1119
00:34:16,040 --> 00:34:18,620
0,540 540,1350 1500,2280 2280,2370 2370,2580
multiple cores executing the same

1120
00:34:18,620 --> 00:34:20,510
0,330 510,930 930,1380 1380,1500 1500,1890
program,| so there's are threads
|所以 L4 内核支持线程。

1121
00:34:20,510 --> 00:34:22,100
0,300 300,1140
supported by

1122
00:34:22,450 --> 00:34:23,900
0,300 300,510 510,870
{L4 -} kernel.|
|

1123
00:34:26,650 --> 00:34:29,170
0,750 900,1440 1440,1830 1830,2070 2070,2520
So so, {L4 -} supported
所以， L4 支持任务，

1124
00:34:29,170 --> 00:34:31,360
0,570 570,990 990,1110 1110,1320 1320,2190
tasks,| it knew about tasks,
|它知道任务，它知道线程，

1125
00:34:31,390 --> 00:34:33,310
0,90 90,330 330,570 570,1290 1440,1920
it knew about threads| and
|它也知道地址空间，

1126
00:34:33,370 --> 00:34:35,740
0,240 240,510 510,840 840,1350 1980,2370
it also knew about address

1127
00:34:35,740 --> 00:34:36,730
0,450 450,510 510,570 570,870 870,990
spaces,| in the sense that
|在这个意义上，你可以告诉 L4 ，

1128
00:34:36,730 --> 00:34:38,500
0,180 180,600 1110,1290 1290,1470 1470,1770
you could, you could ask

1129
00:34:38,500 --> 00:34:39,940
0,270 270,420 420,630 630,810 810,1440
tell {L4 -},| look, here's
|这是我们想要的页面映射到地址空间。

1130
00:34:39,940 --> 00:34:41,140
0,300 300,420 420,600 600,930 930,1200
how we want pages mapped

1131
00:34:41,140 --> 00:34:42,480
0,120 120,390 390,900
into address space.|
|

1132
00:34:43,110 --> 00:34:44,880
0,450 540,900 930,1230 1230,1500 1500,1770
{} And the other main
L4 知道的另一件主要事情是进程间通信，

1133
00:34:44,880 --> 00:34:46,290
0,600 630,900 900,1050 1050,1230 1230,1410
thing that {L4 -} knew

1134
00:34:46,290 --> 00:34:49,260
0,540 810,1200 1200,1650 2130,2340 2340,2970
about is {} inter process

1135
00:34:49,290 --> 00:34:51,750
0,690 690,1050 1170,1440 1440,1740 2220,2460
communication,| so that was every
|每个线程都有一个标识符，

1136
00:34:51,750 --> 00:34:53,670
0,330 330,480 480,570 570,1470 1650,1920
thread has an identifier| and
|一个线程可能会说，

1137
00:34:53,670 --> 00:34:54,570
0,180 180,450 450,570 570,690 690,900
one thread could say,| look,
|我想发送一条消息，

1138
00:34:54,570 --> 00:34:55,350
0,60 60,210 210,270 270,690 690,780
I want to send a

1139
00:34:55,350 --> 00:34:58,170
0,960 990,1110 1110,1350 1350,2070 2430,2820
message,| it just some bytes
|它只是给另一个线程几个字节，

1140
00:34:58,200 --> 00:34:59,970
0,360 360,630 630,990 990,1230 1260,1770
to another thread,| and here's
|这是这个标识符，

1141
00:34:59,970 --> 00:35:02,160
0,180 180,870 870,1380 1380,1710
this identifier,| please, {}
|请给另一个线程发送一条消息。

1142
00:35:03,200 --> 00:35:04,430
0,300 330,540 540,690 690,750 750,1230
{} please send a message

1143
00:35:04,430 --> 00:35:06,160
0,90 90,330 420,630 630,1110
to that other thread.|
|

1144
00:35:07,860 --> 00:35:08,640
0,180 180,360 360,450 450,630 630,780
So these are really the
所以，这些是任务，线程，地址空间和 IPC ，

1145
00:35:08,640 --> 00:35:10,920
0,660
only

1146
00:35:11,690 --> 00:35:14,360
0,480 510,990 990,1560 1620,1950 1950,2670
{} task, threads, address spaces

1147
00:35:14,690 --> 00:35:15,800
0,210 210,660 660,810 810,990 990,1110
and IPC| were really the
|实际上是唯一的抽象概念，

1148
00:35:15,800 --> 00:35:18,230
0,150 150,960 1080,1350 1350,1710 1710,2430
only abstractions,| the system calls,|
|系统调用，|

1149
00:35:19,670 --> 00:35:20,510
0,480 480,630 630,690 690,750 750,840
I don't know if I
我不知道是否能把它们全部列出来，

1150
00:35:20,510 --> 00:35:21,020
0,90 90,150 150,270 270,330 330,510
can be able to list

1151
00:35:21,020 --> 00:35:23,300
0,120 120,360 360,720 1020,1740
them all,| but {
|但是，系统调用是，

1152
00:35:25,830 --> 00:35:27,450
0,360 360,510 510,780 780,1260 1260,1620
-} the system calls were,|
|

1153
00:35:27,690 --> 00:35:28,920
0,270 270,450 450,600 600,690 690,1230
{} there was a thread,|
这里有一个线程，|

1154
00:35:29,160 --> 00:35:31,520
0,420 570,1020 1020,1830
{} thread create
线程创建系统调用，

1155
00:35:32,040 --> 00:35:34,200
0,450 510,930 930,1230 1230,1440 1440,2160
{} system call,| which also
|你给它一个地址空间 id ，创建一个新的线程，

1156
00:35:34,800 --> 00:35:35,940
0,210 210,360 360,540 540,630 630,1140
{} you gave it a

1157
00:35:35,970 --> 00:35:38,100
0,300 300,540 540,1050 1740,2040 2040,2130
address space id has to

1158
00:35:38,100 --> 00:35:39,120
0,180 180,180 180,330 330,570 570,1020
create a new thread| and
|如果地址空间分配已经存在，

1159
00:35:39,600 --> 00:35:40,530
0,210 210,330 330,600 600,870 870,930
if the address space are

1160
00:35:40,530 --> 00:35:41,640
0,360 360,480 480,690 690,1050 1050,1110
tasked in already exist,| it
|它会给你创建一个新的任务，

1161
00:35:41,640 --> 00:35:42,780
0,300 300,540 540,570 570,720 720,1140
would create a new task

1162
00:35:42,780 --> 00:35:44,340
0,150 150,360 540,990 990,1050 1050,1560
for you,| sort of combine
|将线程和任务创建结合在一起。

1163
00:35:44,340 --> 00:35:46,300
0,420 420,540 540,900 900,1440
thread and task creation.|
|

1164
00:35:46,390 --> 00:35:47,620
0,630

1165
00:35:48,030 --> 00:35:50,420
0,990 1050,1800
There's {}
有发送和接收，

1166
00:35:50,710 --> 00:35:52,720
0,420 420,540 540,1500
send and receive,|
|

1167
00:35:53,280 --> 00:35:54,570
0,390 390,780 780,900 900,1170 1170,1290
various flavors of send and
不同风格的发送和接收 IPC 系统调用。

1168
00:35:54,570 --> 00:35:57,720
0,810 990,1620 1620,1950 1950,2640
receive IPC system calls.|
|

1169
00:35:57,930 --> 00:35:59,060
0,510

1170
00:35:59,580 --> 00:36:01,140
0,510 510,600 600,780 780,1140 1170,1560
There's a way to {}
有一种方法将页面映射到你的或其他地址空间，

1171
00:36:01,140 --> 00:36:03,330
0,360 360,1080 1080,1410 1410,1860 1860,2190
map pages into your or

1172
00:36:03,330 --> 00:36:06,600
0,690 1080,1680 1680,2100 2100,2460 2730,3270
other address space,| so, {}
|所以你可以让 L4 改变你的地址空间的设置方式，

1173
00:36:07,050 --> 00:36:08,700
0,750 750,990 990,1170 1170,1500 1500,1650
you, you could ask the

1174
00:36:08,700 --> 00:36:09,840
0,300 300,450 450,570 570,1050 1050,1140
{L4 -} to change the

1175
00:36:09,840 --> 00:36:10,830
0,150 150,360 360,600 600,900 900,990
way your address space was

1176
00:36:10,830 --> 00:36:11,940
0,210 210,390 390,450 450,600 600,1110
set up,| the way your
|你的页表映射的设置方式，

1177
00:36:12,150 --> 00:36:13,320
0,240 240,450 450,870 870,930 930,1170
page table maps were set

1178
00:36:13,320 --> 00:36:14,310
0,210 240,480 480,540 540,660 660,990
up,| but you could also
|但是你也可以要求 L4 ，

1179
00:36:14,310 --> 00:36:16,110
0,450 450,1200 1230,1410 1410,1530 1530,1800
ask L4,| if you had
|如果你有正确的权限，

1180
00:36:16,890 --> 00:36:17,820
0,60 60,210 210,690 690,780 780,930
the right permissions to go|
|

1181
00:36:17,820 --> 00:36:18,930
0,120 120,360 360,450 450,570 570,1110
and change the way another
可以更改另一个任务的地址空间的设置方式。

1182
00:36:18,990 --> 00:36:20,940
0,690 690,930 1140,1470 1470,1830 1830,1950
{task's -} address space was

1183
00:36:20,940 --> 00:36:21,780
0,240 240,540
set up.|
|

1184
00:36:21,860 --> 00:36:23,420
0,480 510,1020
{} So,
因此，这实际上是通过 IPC 完成的，

1185
00:36:23,510 --> 00:36:24,500
0,420
{

1186
00:36:25,360 --> 00:36:26,500
0,660
-}

1187
00:36:27,470 --> 00:36:28,400
0,210 210,330 330,570 570,810 810,930
this was actually done through

1188
00:36:28,400 --> 00:36:29,690
0,150 150,570 570,660 660,1080 1080,1290
the IPC,| would spent through
|将通过 IPC 接口，

1189
00:36:29,690 --> 00:36:30,860
0,150 150,600 600,990 990,1050 1050,1170
the IPC interface,| {you,know} would
|将发送一个特殊的 IPC 消息，

1190
00:36:30,860 --> 00:36:33,080
0,300 300,540 570,1050 1050,1560 1560,2220
send a special IPC message,|
|

1191
00:36:33,230 --> 00:36:34,370
0,180 180,240 240,480 480,660 660,1140
that the kernel knew about
内核知道目标线程，

1192
00:36:34,820 --> 00:36:36,020
0,180 180,270 270,630 630,1080 1080,1200
to the target thread,| {and,the}
|并且内核将修改目标线程地址空间。

1193
00:36:36,020 --> 00:36:38,570
0,360 360,660 1650,2160 2160,2250 2250,2550
kernel would modify the target

1194
00:36:38,570 --> 00:36:40,020
0,240 240,480 480,1020
thread's address space.|
|

1195
00:36:41,050 --> 00:36:42,070
0,390 420,570 570,690 690,810 810,1020
{} And this is if
这是如果你创建一个新的线程，

1196
00:36:42,070 --> 00:36:42,760
0,120 120,180 180,480 480,540 540,690
you are creating a new

1197
00:36:42,760 --> 00:36:43,750
0,270 270,390 390,510 510,840 840,990
thread,| this is actually new
|实际上新创建的线程完全没有内存，

1198
00:36:43,750 --> 00:36:44,800
0,300 300,360 360,750 750,900 900,1050
threads are created with no

1199
00:36:44,800 --> 00:36:46,930
0,330 330,420 420,780 1920,2070 2070,2130
memory at all,| so if
|所以如果你想创建一个线程，

1200
00:36:46,930 --> 00:36:47,440
0,90 90,210 210,270 270,450 450,510
you want to create a

1201
00:36:47,440 --> 00:36:48,610
0,270 270,390 390,810 810,1020 1020,1170
thread,| you first call the
|你首先调用线程创建系统调用

1202
00:36:48,610 --> 00:36:49,840
0,330 330,630 630,930 930,1170 1170,1230
thread create system call| to
|

1203
00:36:49,840 --> 00:36:50,950
0,330 330,360 360,510 510,990 990,1110
create a new thread and
来创建新的线程，任务和地址空间，

1204
00:36:50,950 --> 00:36:52,660
0,420 420,900 900,990 990,1260 1260,1710
{} task and address space,|
|

1205
00:36:52,720 --> 00:36:54,700
0,570 570,750 750,1050 1050,1380 1650,1980
{and,then} you send it,| if
然后你发送它，|如果你创建一个神奇的 IPC ，

1206
00:36:54,730 --> 00:36:55,360
0,210 210,360 360,450 450,510 510,630
you make one of these

1207
00:36:55,360 --> 00:36:56,740
0,330 330,450 450,870 870,960 960,1380
magic {IPCs -}| to send
|来发送一些你自己的内存映射，

1208
00:36:56,800 --> 00:36:58,510
0,300 300,360 360,570 570,930 930,1710
some of your own memory

1209
00:36:58,900 --> 00:37:00,070
0,420 420,540 540,720 720,810 810,1170
maps of your own memory,|
|

1210
00:37:00,070 --> 00:37:01,720
0,120 120,330 330,960 960,1110 1110,1650
that you've prepared with instructions
你已经准备好的指令或数据，

1211
00:37:01,720 --> 00:37:03,400
0,60 60,540 1080,1200 1200,1470 1470,1680
or data| to map that
|为了将内存映射到新的，

1212
00:37:03,400 --> 00:37:04,840
0,360 360,570 570,660 660,930 1080,1440
memory into the new, {}|
|

1213
00:37:05,530 --> 00:37:06,820
0,180 180,270 270,660 690,960 960,1290
and so a new task
新的任务地址空间，

1214
00:37:06,820 --> 00:37:08,320
0,270 270,720 1110,1290 1290,1380 1380,1500
address space,| and then you
|然后发送一个特殊的 IPC 到这个新的任务，

1215
00:37:08,320 --> 00:37:10,180
0,180 180,180 180,570 570,990 990,1860
send a special start IPC

1216
00:37:10,360 --> 00:37:11,500
0,120 120,270 270,420 420,900 900,1140
to this new task| with
|通过程序计数器和你想开始执行的堆栈指针，

1217
00:37:11,500 --> 00:37:13,000
0,210 270,720 720,990 990,1140 1140,1500
the program counter and stack

1218
00:37:13,000 --> 00:37:13,750
0,360 360,450 450,600 600,690 690,750
pointer you want it to

1219
00:37:13,750 --> 00:37:15,340
0,270 270,750 750,1050 1350,1470 1470,1590
start executing with,| that will
|它将开始执行，

1220
00:37:15,340 --> 00:37:16,630
0,240 240,720 720,840 840,960 960,1290
start executing| and that memory
|并在要求启动程序计数器处设置内存。

1221
00:37:16,630 --> 00:37:18,250
0,150 150,630 840,1140 1140,1290 1290,1620
you've setup at the program

1222
00:37:18,250 --> 00:37:20,040
0,300 300,630 630,1230
counter {you,ask} startup.|
|

1223
00:37:20,600 --> 00:37:21,740
0,600

1224
00:37:21,740 --> 00:37:23,090
0,510 510,630 630,1020 1020,1230 1230,1350
There's a way not through
有一种方法不通过系统调用，

1225
00:37:23,090 --> 00:37:24,920
0,330 330,1050 1230,1350 1350,1710 1740,1830
system calls,| in fact I
|事实上，我不知道它是怎么工作的，

1226
00:37:24,920 --> 00:37:25,700
0,90 90,150 150,330 330,420 420,780
don't know how it worked,|
|

1227
00:37:25,700 --> 00:37:27,400
0,270 450,1110
but {}
但是特权任务可以映射设备硬件，

1228
00:37:27,400 --> 00:37:29,860
0,480 480,1140 1140,1410 1410,1950 1950,2460
privileged tasks could map device

1229
00:37:29,860 --> 00:37:31,320
0,840
hardware,|
|

1230
00:37:32,980 --> 00:37:35,440
0,180 180,1080 1110,1530 1530,2280 2280,2460
{you,know} device control registers into
映射设备控制寄存器到它们自己的地址空间。

1231
00:37:35,440 --> 00:37:38,300
0,180 180,300 300,630 630,1380
their own address spaces.|
|

1232
00:37:39,980 --> 00:37:41,030
0,330 330,510 510,720 720,900 900,1050
So, {L4 -} didn't really
所以， L4 对设备不是很了解，

1233
00:37:41,030 --> 00:37:42,170
0,150 150,330 330,540 540,960 960,1140
know much about devices| like
|比如磁盘或网卡，

1234
00:37:42,170 --> 00:37:44,060
0,510 510,690 690,1020 1020,1380 1380,1890
disks or network interface cards,|
|

1235
00:37:44,060 --> 00:37:46,340
0,330 510,810 810,1170 1170,1710
but {} user level
但是用户级软件可以直接访问，

1236
00:37:46,790 --> 00:37:48,830
0,690 690,870 870,1080 1080,1590 1590,2040
software could get directly at,|
|

1237
00:37:49,460 --> 00:37:50,780
0,930

1238
00:37:51,160 --> 00:37:52,180
0,210 210,540 540,570 570,900 900,1020
{user -} level software that
用户级软件可以实现设备驱动，

1239
00:37:52,180 --> 00:37:53,770
0,510 510,810 810,1170 1170,1350 1350,1590
implemented device drivers,| that user
|用户级软件可以直接访问设备硬件。

1240
00:37:53,770 --> 00:37:54,970
0,270 270,390 390,600 600,1020 1020,1200
level could get directly at

1241
00:37:54,970 --> 00:37:56,300
0,330 330,750
device hardware.|
|

1242
00:37:56,610 --> 00:37:58,170
0,390 570,1050 1050,1170 1170,1230 1230,1560
{} There was a way
有一种方法可以，

1243
00:37:58,170 --> 00:38:00,220
0,780 810,1410
to {}|
|

1244
00:38:00,220 --> 00:38:01,570
0,60 60,210 210,510 510,720 720,1350
you could tell {L4 -}
你可以告诉 L4 打开中断，

1245
00:38:01,600 --> 00:38:03,920
0,300 300,600 600,720 720,1830
to turn on interrupt,|
|

1246
00:38:04,560 --> 00:38:05,840
0,720

1247
00:38:05,870 --> 00:38:07,370
0,270 270,600 600,750 750,900 900,1500
any interrupt from any device,|
来自任何设备的任何中断，|

1248
00:38:07,520 --> 00:38:08,870
0,90 90,270 270,570 990,1170 1170,1350
L4 didn't really know which
L4 并不知道哪台设备打开。

1249
00:38:08,870 --> 00:38:10,760
0,390 390,630 630,1110 1530,1650 1650,1890
device just turned,| {} given
|把中断给 IPC 消息。

1250
00:38:10,760 --> 00:38:13,520
0,480 480,1110 1260,1470 1470,2010 2010,2760
interrupt into an IPC message.|
|

1251
00:38:14,070 --> 00:38:15,960
0,240 240,330 330,660 660,1470 1500,1890
So a device driver {}
所以设备驱动程序任务不仅读写设备硬件，

1252
00:38:15,990 --> 00:38:19,500
0,750 750,1200 2670,2910 2910,3090 3090,3510
task {} not just {read,write}

1253
00:38:19,500 --> 00:38:20,460
0,60 60,360 360,570 570,690 690,960
the device hardware,| but also
|也会告诉 L4 在设备中断的时候，

1254
00:38:20,460 --> 00:38:21,720
0,360 360,510 510,720 720,900 900,1260
tell {L4 -} well anytime

1255
00:38:21,720 --> 00:38:23,340
0,180 180,480 480,900 960,1350 1350,1620
that device interrupts,| please send
|请给我发送一条 IPC 消息，

1256
00:38:23,340 --> 00:38:25,890
0,120 120,210 210,720 720,1380 2010,2550
me an IPC message,| notifying
|通知我中断。

1257
00:38:25,890 --> 00:38:27,160
0,120 120,270 270,780
me the interrupt.|
|

1258
00:38:27,820 --> 00:38:31,000
0,480 840,1110 1110,1710 1740,2550 2580,3180
{} And finally one task
最后，一个任务告诉内核

1259
00:38:31,000 --> 00:38:33,220
0,540 600,720 720,1380 1410,1800 1800,2220
tell the kernel| to {}
|给它另一个任务页面错误的通知，

1260
00:38:33,940 --> 00:38:35,920
0,390 390,750 780,1620 1620,1680 1680,1980
give it notifications of another

1261
00:38:35,920 --> 00:38:39,010
0,450 450,780 780,1470 2550,2940 2970,3090
task page faults,| so if
|所以，如果这个任务出现页面错误，

1262
00:38:39,010 --> 00:38:41,020
0,360 390,690 690,900 900,1470 1650,2010
this task page fault, {}|
|

1263
00:38:41,140 --> 00:38:42,760
0,270 270,660 660,960 990,1350 1350,1620
{L4 -} would turn that
L4 会将其转换为 IPC 消息，

1264
00:38:42,760 --> 00:38:46,060
0,480 480,780 840,1260 1260,2070 2970,3300
into an IPC message| and
|并将它发送到另一个专用的分页任务，

1265
00:38:46,090 --> 00:38:47,770
0,330 330,480 480,630 630,900 900,1680
send it to another designated

1266
00:38:47,770 --> 00:38:49,480
0,540 540,1350
pager task,|
|

1267
00:38:49,930 --> 00:38:51,220
0,330 330,390 390,960 960,1020 1020,1290
send the notification the page
将页面错误通知发送给指定的页面任务，

1268
00:38:51,220 --> 00:38:52,510
0,210 210,300 300,390 390,990 990,1290
fault to a designated pager

1269
00:38:52,510 --> 00:38:54,010
0,60 60,480 480,600 600,750 750,1500
{} task,| so every task
|所以每个任务都有一个关联的分页任务，来处理它的页面错误，

1270
00:38:54,040 --> 00:38:55,870
0,270 270,330 330,990 990,1380 1380,1830
has an associated pager task,

1271
00:38:55,870 --> 00:38:57,250
0,120 120,540 540,690 690,960 960,1380
that handled its page faults,|
|

1272
00:38:57,460 --> 00:38:59,170
0,150 150,330 330,420 420,930 1500,1710
and that's the way you
这就是你把钩子挂在页面错误上的方式，

1273
00:38:59,170 --> 00:39:00,430
0,90 90,360 360,690 690,1050 1050,1260
know you get hooks into

1274
00:39:00,430 --> 00:39:01,930
0,360 390,930 930,1170 1170,1260 1260,1500
the page faults,| in order
|用来实现写入时复制， fork 或懒分配。

1275
00:39:01,930 --> 00:39:03,520
0,60 60,450 450,720 720,990 1050,1590
to implement things like {copy-on-write

1276
00:39:03,520 --> 00:39:04,930
0,150 150,450 450,930 930,1020 1020,1410
- -} fork or lazy

1277
00:39:04,930 --> 00:39:06,120
0,660
allocation.|
|

1278
00:39:07,990 --> 00:39:09,060
0,60

1279
00:39:09,060 --> 00:39:09,690
0,120 120,330 330,450 450,570 570,630
And that's it for the
内核就是这样，在 L4 中没有其他东西，

1280
00:39:09,690 --> 00:39:11,160
0,360 360,540 540,1140 1140,1380 1380,1470
kernel, there's nothing else in

1281
00:39:11,160 --> 00:39:12,150
0,180 180,390 390,540 540,660 660,990
{L4 -},| there's no file
|没有文件系统，

1282
00:39:12,150 --> 00:39:14,460
0,750 1080,1440 1440,1620 1620,2100 2100,2310
system,| L4 didn't itself had
|L4 本身并不支持 fork exec 之类的功能，

1283
00:39:14,460 --> 00:39:15,630
0,360 360,450 450,660 660,840 840,1170
support for things like {fork

1284
00:39:15,630 --> 00:39:18,270
0,210 210,900 1200,1740 1920,2520 2520,2640
-} exec,| {} didn't have
|除了这些非常简单的 IPC 之外，没有任何通信，

1285
00:39:18,270 --> 00:39:20,310
0,150 150,870 870,1500 1560,1740 1740,2040
any communication beyond these very

1286
00:39:20,310 --> 00:39:23,490
0,360 360,1200 1680,2250 2250,2730 2730,3180
simple IPC,| {like,did,not,pipes},| {did,not} device
|比如没有管道，|没有设备驱动程序，

1287
00:39:23,490 --> 00:39:25,290
0,570 570,690 690,1080 1080,1380 1380,1800
drivers,| no networking support nothing,|
|没有网络支持，什么都没有，|

1288
00:39:26,250 --> 00:39:27,510
0,540 540,750 750,840 840,930 930,1260
everything else if you wanted
如果你需要其他东西的话，

1289
00:39:27,510 --> 00:39:29,580
0,240 690,1110 1110,1260 1260,1350 1350,2070
it,| you need to supply
|你需要提供作为用户级别的服务。

1290
00:39:29,580 --> 00:39:31,890
0,630 780,1050 1050,1320 1320,1530 1530,2310
as a user level services.|
|

1291
00:39:37,080 --> 00:39:38,940
0,240 240,570 720,960 960,1410 1410,1860
Okay, so {} one thing
好的，那么一件事是，

1292
00:39:39,830 --> 00:39:41,340
0,360 360,930
that are,|
|

1293
00:39:41,630 --> 00:39:44,150
0,360 360,600 600,1020 1020,1740 1770,2520
L4 does supply is switching
L4 支持线程切换，

1294
00:39:44,150 --> 00:39:47,360
0,720 1200,2250 2370,2760 2760,2910 2910,3210
among threads,| L4 would actually
|L4 执行调度和上下文切换，

1295
00:39:47,360 --> 00:39:50,030
0,210 210,1020 1170,2040 2040,2190 2190,2670
do the scheduling and context

1296
00:39:50,030 --> 00:39:52,610
0,720 1320,1500 1500,1800 1800,2010 2010,2580
switches| in order to multiplex
|以便在多个线程中复用单个 CPU ，

1297
00:39:52,610 --> 00:39:54,050
0,60 60,360 360,780 780,1080 1080,1440
a single CPU among multiple

1298
00:39:54,050 --> 00:39:55,160
0,660 660,810 810,900 900,1020 1020,1110
threads| and the way it
|你会发现它做的方式完全不令人惊讶，

1299
00:39:55,160 --> 00:39:56,450
0,150 150,360 540,900 900,1020 1020,1290
did it you would find

1300
00:39:56,450 --> 00:39:59,570
0,420 420,1320 1710,2040 2220,2580 2580,3120
completely unsurprising,| {} {L4 -}
|L4 为每个线程、每个任务保存了寄存器，

1301
00:39:59,570 --> 00:40:02,120
0,390 390,540 540,960 960,1980 2340,2550
basically had saved registers for

1302
00:40:02,120 --> 00:40:03,860
0,240 240,810 810,900 900,1080 1080,1740
every task, for every thread,|
|

1303
00:40:04,580 --> 00:40:05,960
0,420 420,540 540,1020 1020,1080 1080,1380
when it executed a thread,|
当它执行线程时，|

1304
00:40:05,960 --> 00:40:08,300
0,60 60,540 900,1410 1410,1710 1800,2340
the executing thread would jump
执行线程会跳入用户空间，切换页表，

1305
00:40:08,300 --> 00:40:09,710
0,150 150,450 450,840 840,1140 1140,1410
into user space, switch page

1306
00:40:09,710 --> 00:40:10,910
0,360 360,450 450,630 630,1050 1050,1200
tables,| so that thread and
|所以，那个线程将在用户空间中执行一段时间，

1307
00:40:10,910 --> 00:40:11,870
0,150 150,390 390,510 510,900 900,960
that thread will execute for

1308
00:40:11,870 --> 00:40:13,460
0,300 300,540 540,990 1200,1410 1410,1590
{a,while} {in,user} space,| then maybe
|然后可能定时器中断响起，

1309
00:40:13,460 --> 00:40:14,960
0,60 60,750 870,1260 1260,1350 1350,1500
the timer interrupt would go

1310
00:40:14,960 --> 00:40:15,950
0,210 210,300 300,480 480,690 690,990
off| and that was actually
|这是 L4 所知道的一种设备，

1311
00:40:15,950 --> 00:40:16,910
0,30 30,390 390,690 690,810 810,960
a device {L4 -} knew

1312
00:40:16,910 --> 00:40:18,710
0,360 690,870 870,1230 1230,1530 1530,1800
about,| the timer interrupt might
|定时器中断会在一段时间后触发，

1313
00:40:18,710 --> 00:40:19,910
0,150 150,420 420,660 660,720 720,1200
go off after a while,|
|

1314
00:40:20,280 --> 00:40:21,480
0,420 420,510 510,720 720,1050 1050,1200
interrupting the {L4 -},| {L4
中断 L4 ，|L4 将保存这个任务的用户寄存器到任务中，

1315
00:40:21,480 --> 00:40:22,950
0,210 210,330 330,780 780,960 960,1470
-} would save this task's

1316
00:40:22,950 --> 00:40:24,990
0,240 240,870 870,990 990,1260 1560,2040
user registers in a per

1317
00:40:24,990 --> 00:40:27,990
0,1020 1350,1650 1650,1950 1950,2070 2220,3000
task,| an array of tasks
|一个任务线程数组结构，

1318
00:40:28,170 --> 00:40:30,360
0,480 480,1110 1350,1590 1590,1980 1980,2190
thread structures,| would save this
|会将这个线程寄存器保存起来，

1319
00:40:30,360 --> 00:40:31,520
0,690
threads

1320
00:40:31,610 --> 00:40:34,010
0,810 810,1290 1710,2190 2190,2250 2250,2400
registers away,| pick a new
|从循环中选择一个新任务运行，

1321
00:40:34,010 --> 00:40:35,150
0,330 330,690 690,780 780,870 870,1140
{task,to} run in a loop,|
|

1322
00:40:35,180 --> 00:40:36,530
0,360 360,570 570,660 660,1140 1140,1350
much like the scheduling loop
这与 xv6 中的调度循环非常像，

1323
00:40:36,530 --> 00:40:39,620
0,270 270,390 390,930 1320,2520
{in,xv6 - -},| restore
|从先前保存的寄存器恢复这个任务的寄存器，

1324
00:40:39,620 --> 00:40:42,110
0,210 210,1080 1380,2040 2040,2280 2310,2490
this task's registers out from

1325
00:40:42,110 --> 00:40:44,540
0,180 180,660 660,960 960,1710 1920,2430
its previously saved registers,| switch
|切换页表，

1326
00:40:44,540 --> 00:40:46,070
0,270 270,690 690,780 780,1110 1140,1530
page tables,| and then jump
|然后跳到这个任务，并执行一段时间，

1327
00:40:46,070 --> 00:40:47,270
0,180 180,360 360,720 720,810 810,1200
into this task and execute

1328
00:40:47,270 --> 00:40:49,190
0,150 150,240 240,300 300,660 1680,1920
it for a while,| until
|直到定时器中断停止

1329
00:40:49,190 --> 00:40:50,300
0,60 60,390 390,660 660,810 810,1110
the timer interrupt went off|
|

1330
00:40:50,300 --> 00:40:52,760
0,330 450,1050 1050,1500 1500,1980
or until this {}
或直到这个任务 yield ，

1331
00:40:53,060 --> 00:40:55,100
0,630 630,870 870,1560 1740,1860 1860,2040
task either yielded,| I think
|我想这里可能还有一个 yield 系统调用或类似的调用。

1332
00:40:55,100 --> 00:40:56,600
0,180 180,510 510,840 840,960 960,1500
there's also probably a yield

1333
00:40:56,600 --> 00:40:57,890
0,360 360,690 690,780 780,1110 1110,1290
system call or something like

1334
00:40:57,890 --> 00:40:58,640
0,150
it.|
|

1335
00:40:59,230 --> 00:41:00,370
0,360 420,750 750,870 870,1110 1110,1140
A task can yield a
一个任务可能会让出 CPU ，

1336
00:41:00,370 --> 00:41:02,320
0,540 540,930 990,1170 1170,1590 1590,1950
CPU| or a task could
|或者任务可能会等待接收 IPC ，

1337
00:41:02,560 --> 00:41:04,120
0,510 510,600 600,930 930,1020 1020,1560
wait to receive an IPC,|
|

1338
00:41:04,120 --> 00:41:06,060
0,120 120,300 300,900
in that case,|
在这种情况下，|

1339
00:41:06,090 --> 00:41:07,350
0,240 240,690 690,870 870,1080 1080,1260
{L4 -}, we jump back
我们跳回 L4 ，

1340
00:41:07,350 --> 00:41:08,340
0,120 120,300 300,690 690,870 870,990
into {L4 -}| and {L4
|L4 看到寄存器切换到新任务并运行，

1341
00:41:08,340 --> 00:41:10,500
0,450 480,720 720,870 870,1830 1860,2160
-} see this registers switch

1342
00:41:10,500 --> 00:41:11,790
0,120 120,150 150,270 270,930 1140,1290
to a new task and

1343
00:41:11,790 --> 00:41:13,530
0,270 270,750 810,1020 1020,1410 1410,1740
run task,| so that thread
|所以 L4 的线程切换部分是非常熟悉的。

1344
00:41:13,530 --> 00:41:14,730
0,360 360,630 630,720 720,870 870,1200
switching part of {L4 -}

1345
00:41:14,730 --> 00:41:16,180
0,210 210,630 630,840
is very, {}

1346
00:41:17,910 --> 00:41:19,170
0,120 120,240 240,360 360,570 570,1260
{ -} be very familiar.|
|

1347
00:41:25,350 --> 00:41:27,960
0,750 1050,1710
The {}.|
那个。|

1348
00:41:30,130 --> 00:41:31,630
0,660 660,750 750,1050 1050,1170 1170,1500
I I mentioned this before,|
我之前提到过这件事，|

1349
00:41:31,630 --> 00:41:33,220
0,240 240,630 660,960 960,1170 1170,1590
I just want to {}
我想说，因为它出现了，

1350
00:41:33,430 --> 00:41:34,760
0,210 210,300 300,510 510,960
because it comes up,|
|

1351
00:41:34,970 --> 00:41:37,910
0,120 120,570 570,1110 1380,2070 2220,2940
I wanna {} write here,|
我想写在这里，|

1352
00:41:39,830 --> 00:41:40,910
0,300 300,600 600,660 660,720 720,1080
this notion of a pager,|
这个分页的概念，|

1353
00:41:40,910 --> 00:41:45,680
0,240 630,960 1170,1680 3540,4380 4380,4770
{ -} the, repeat if
如果进程出现页面错误，

1354
00:41:45,680 --> 00:41:46,880
0,300 330,750 750,870 870,930 930,1200
a process is a page

1355
00:41:46,880 --> 00:41:49,760
0,510 1740,2160 2160,2280 2280,2370 2370,2880
fault,| traps into the kernel,|
|trap 出现在内核，|

1356
00:41:49,850 --> 00:41:50,720
0,180 180,240 240,450 450,720 720,870
and the kernel turns that
并且内核将页面错误转换为 IPC 消息，

1357
00:41:50,720 --> 00:41:51,920
0,240 240,510 510,690 690,750 750,1200
page fault into an IPC

1358
00:41:51,920 --> 00:41:53,930
0,450 450,630 630,840 900,1710 1710,2010
message| to a designated {pager
|发给指定的分页任务，

1359
00:41:53,930 --> 00:41:55,400
0,90 90,780 930,1140 1140,1380 1380,1470
-} task| and tells it
|并告诉它地址，

1360
00:41:55,400 --> 00:41:57,560
0,90 90,990
the address,|
|

1361
00:41:57,650 --> 00:41:59,000
0,270 720,930 930,1050 1050,1290 1290,1350
tells {} this {pager -}
告诉这个分页任务，

1362
00:41:59,000 --> 00:42:02,120
0,420 1260,1560 1560,2070 2070,2550 2550,3120
task| {} which thread faulted
|哪个线程出了故障，以及它在哪个地址上出了故障。

1363
00:42:02,120 --> 00:42:03,110
0,90 90,180 180,510 510,630 630,990
and the address it faulted

1364
00:42:03,110 --> 00:42:04,960
0,420 780,1290
on on.|
|

1365
00:42:05,050 --> 00:42:06,280
0,150 150,270 270,360 360,690 690,1230
And then the pager task,|
然后分页任务，|

1366
00:42:06,340 --> 00:42:07,150
0,270 270,330 330,570 570,660 660,810
if it wants to say
如果它想实现懒分配，

1367
00:42:07,150 --> 00:42:09,970
0,660 690,1290 1290,2160 2460,2610 2610,2820
implement lazy allocation,| {} maybe
|也许这个线程写入一些没有分配的内存，

1368
00:42:09,970 --> 00:42:12,160
0,210 210,720 1110,1920 1920,1980 1980,2190
this thread { -} write

1369
00:42:12,160 --> 00:42:13,390
0,150 150,450 450,540 540,690 690,1230
some memory that was {not,allocated}

1370
00:42:13,390 --> 00:42:14,890
0,270 270,420 420,540 840,1230 1230,1500
yet,| but I think that
|我想它要求懒分配，

1371
00:42:14,890 --> 00:42:15,730
0,150 150,360 360,420 420,780 780,840
it sort of asked to

1372
00:42:15,730 --> 00:42:18,160
0,390 420,810 810,1440 1680,2040 2040,2430
be lazily allocated,| its pager
|它的分页任务将负责从 L4 分配一些内存，

1373
00:42:18,160 --> 00:42:18,940
0,300 300,420 420,570 570,690 690,780
task would then be in

1374
00:42:18,940 --> 00:42:20,740
0,420 420,630 630,1110 1110,1260 1260,1800
charge of allocating some memory

1375
00:42:20,740 --> 00:42:23,380
0,210 210,390 390,930 1830,2490 2490,2640
from {L4 -},| sending one
|发送一个特殊的 IPC ，

1376
00:42:23,380 --> 00:42:25,930
0,60 60,240 240,930 1230,2070 2070,2550
of these special {IPCs -},|
|

1377
00:42:26,140 --> 00:42:29,920
0,510 630,1560 2400,2550 2550,3090 3330,3780
{} cause that caused {}
导致内存映射到这个任务中，

1378
00:42:29,950 --> 00:42:31,360
0,420 420,480 480,600 600,1200 1200,1410
memory to be mapped into

1379
00:42:31,360 --> 00:42:33,190
0,150 150,750 750,870 870,1290 1470,1830
this task,| and then sending
|然后发送 IPC 以恢复这个线程的执行。

1380
00:42:33,190 --> 00:42:35,290
0,90 90,450 450,540 540,1140 1350,2100
an IPC to resume execution

1381
00:42:35,620 --> 00:42:36,940
0,420 420,570 570,1050
inside this thread.|
|

1382
00:42:37,200 --> 00:42:38,320
0,390

1383
00:42:38,320 --> 00:42:39,310
0,240 240,420 420,540 540,690 690,990
So there was this notion
所以就有了分页任务的概念，

1384
00:42:39,310 --> 00:42:40,450
0,90 90,420 420,750 750,810 810,1140
of pager task| to implement
|来实现所有事情，

1385
00:42:40,450 --> 00:42:41,710
0,210 210,540 570,720 720,810 810,1260
all this all the stuff,|
|

1386
00:42:41,710 --> 00:42:42,940
0,240 480,720 720,840 840,1140 1140,1230
that {xv6 - -} or
xv6 或 Linux 在页面错误处理程序中实现的，

1387
00:42:42,940 --> 00:42:44,590
0,330 330,930 930,1140 1140,1410 1410,1650
Linux implements in page fault

1388
00:42:44,590 --> 00:42:46,300
0,450 450,720 810,1020 1020,1200 1320,1710
handlers,| like you could implement
|你可以用这个实现写入时复制 fork ，

1389
00:42:46,300 --> 00:42:47,620
0,330 330,540 540,810 810,1200 1200,1320
{copy-on-write - -} fork with

1390
00:42:47,620 --> 00:42:49,150
0,420 420,540 540,630 630,1170 1170,1530
this,| if you liked,| or
|如果你喜欢的话，|或这内存映射文件，

1391
00:42:49,360 --> 00:42:52,390
0,690 690,990 990,1590 1590,2100 2550,3030
memory mapped files,| all using
|它们都使用这些分页任务中的一个。

1392
00:42:52,390 --> 00:42:53,500
0,120 120,180 180,360 360,690 690,1110
one of these pager task.|
|

1393
00:42:53,500 --> 00:42:54,420
0,180 180,420
They were
它们是一种强大的用户级方式，

1394
00:42:54,420 --> 00:42:55,560
0,300 300,510
sort of

1395
00:42:56,060 --> 00:42:58,850
0,600 600,1050 1050,1410 1410,2070 2430,2790
powerful user level way {},|
|

1396
00:42:59,270 --> 00:43:01,400
0,300 300,780 780,1050 1050,1380 1650,2130
play tricks with a driven
使用页面错误驱动的技巧。

1397
00:43:01,400 --> 00:43:04,010
0,180 180,480 480,1080 2310,2520 2520,2610
by page faults.| And so
|所以这是一个例子，

1398
00:43:04,010 --> 00:43:05,450
0,150 150,210 210,270 270,900 1110,1440
this is an example,| one
|许多例子中的一个，

1399
00:43:05,450 --> 00:43:06,590
0,60 60,240 240,720 720,810 810,1140
of many examples,| in which
|像 L4 这样的微内核可能更灵活，

1400
00:43:07,310 --> 00:43:08,420
0,120 120,390 390,750 750,960 960,1110
{} micro kernel like {L4

1401
00:43:08,420 --> 00:43:09,530
0,420 450,690 690,780 780,870 870,1110
-} might have been quite

1402
00:43:09,530 --> 00:43:11,240
0,30 30,210 210,870 930,1590 1590,1710
a bit more flexible| for
|对于用户程序来说，

1403
00:43:11,240 --> 00:43:12,920
0,270 270,930 930,1110 1110,1170 1170,1680
user programs| than a conventional
|跟传统内核比起来，

1404
00:43:12,920 --> 00:43:14,750
0,360 630,840 840,1470 1470,1620 1620,1830
kernel,| like if you think
|比如，如果你让 Linux 做一些额外的事情，

1405
00:43:14,750 --> 00:43:15,680
0,360 360,510 510,570 570,720 720,930
Linux ought to do some

1406
00:43:15,680 --> 00:43:18,100
0,330 330,810 810,1140 1320,1980
extra thing,| like maybe
|比如，可能一些，

1407
00:43:18,500 --> 00:43:20,150
0,120 120,300 300,810 1290,1560 1560,1650
you know some you know,|
|

1408
00:43:20,150 --> 00:43:21,440
0,300 300,570 570,750 750,1140 1140,1290
if Linux didn't already have
如果 Linux 没有写入时复制 fork ，

1409
00:43:21,440 --> 00:43:22,490
0,330 330,420 420,660 660,960 960,1050
{copy-on-write - -} fork| and
|而你想要写入时复制 fork ，

1410
00:43:22,490 --> 00:43:23,540
0,120 120,480 480,540 540,750 750,1050
you wanted to have {copy-on-write

1411
00:43:23,540 --> 00:43:25,130
0,150 150,330 330,690 900,1410 1410,1590
- -} fork,| you really
|如果不修改内核，就无法在 Linux 中实现它，

1412
00:43:25,130 --> 00:43:26,450
0,330 330,660 660,840 840,930 930,1320
can't implement that in Linux

1413
00:43:26,450 --> 00:43:28,190
0,210 210,690 690,780 780,1230 1590,1740
without modifying the kernel,| and
|而且没有办法为 Linux 编写可移植的代码，

1414
00:43:28,190 --> 00:43:28,820
0,120 120,240 240,360 360,450 450,630
there's no way to write

1415
00:43:28,820 --> 00:43:31,160
0,390 390,1110 1380,1740 1740,2040 2040,2340
portable code,| portable user level
|可移植的用户级代码，

1416
00:43:31,160 --> 00:43:32,960
0,660 690,930 930,1530 1530,1680 1680,1800
code for Linux,| that could
|它可以实现写入时复制 fork 之类的东西。

1417
00:43:32,960 --> 00:43:34,220
0,450 450,720 720,870 870,1170 1170,1260
implement something like {copy-on-write -

1418
00:43:34,220 --> 00:43:35,280
0,180 180,570
-} fork.|
|

1419
00:43:38,020 --> 00:43:38,950
0,180 180,330 330,540 540,750 750,930
That's not quite true,| but
这并不完全正确，|但这是非常困难的，

1420
00:43:38,950 --> 00:43:39,940
0,120 120,210 210,330 330,540 540,990
it would be very difficult,|
|

1421
00:43:39,970 --> 00:43:42,730
0,660 1650,1980 1980,2220 2220,2310 2310,2760
whereas {L4 -} its relatively
而 L4 相对简单，

1422
00:43:42,730 --> 00:43:44,350
0,600 600,750 750,930 930,1140 1140,1620
straightforward,| {L4 -} is completely
|L4 已完全为你设置好，

1423
00:43:44,350 --> 00:43:45,340
0,270 270,510 510,780 780,930 930,990
set up for you| to
|以便你能编写用户级代码，

1424
00:43:45,340 --> 00:43:46,180
0,90 90,210 210,300 300,540 540,840
be able to write user

1425
00:43:46,180 --> 00:43:47,590
0,240 240,690 720,1020 1020,1290 1290,1410
level code,| that gets the
|它获取页面错误用来实现写入时复制 fork ，

1426
00:43:47,590 --> 00:43:49,360
0,300 300,870 990,1200 1200,1290 1290,1770
page faults that are required

1427
00:43:49,360 --> 00:43:50,890
0,90 90,900 930,1230 1230,1350 1350,1530
to drive {copy-on-write - -}

1428
00:43:50,890 --> 00:43:51,720
0,450
fork,|
|

1429
00:43:51,810 --> 00:43:53,610
0,630 840,1050 1050,1230 1230,1530 1530,1800
all in user space, without
所有都在用户空间中，而不必扰乱内核。

1430
00:43:53,610 --> 00:43:54,840
0,210 210,690 780,1080 1080,1170 1170,1230
having to mess with the

1431
00:43:54,840 --> 00:43:55,980
0,330
kernel.|
|

1432
00:43:56,320 --> 00:43:57,460
0,570

1433
00:43:58,030 --> 00:44:00,180
0,600 810,1350
Okay, {}
好的，关于 L4 如何工作，有没有什么问题？

1434
00:44:00,540 --> 00:44:01,590
0,270 270,420 420,720 720,870 870,1050
so any questions so far

1435
00:44:01,590 --> 00:44:03,180
0,360 390,930 960,1140 1140,1320 1320,1590
about {} how {L4 -}

1436
00:44:03,180 --> 00:44:04,340
0,660
works.|
|

1437
00:44:05,590 --> 00:44:06,520
0,180 180,450 450,570 570,690 690,930
Oh, sorry, can you just
哦，抱歉，你能解释一下线程和任务的区别吗？

1438
00:44:06,520 --> 00:44:08,200
0,690 690,810 810,1200 1200,1590 1590,1680
clarify the difference between a

1439
00:44:08,200 --> 00:44:10,540
0,450 450,570 570,630 630,1860 1920,2340
thread and a task {}?|
|

1440
00:44:10,540 --> 00:44:15,610
0,690 1620,2070 2310,3330 4050,4890 4890,5070
Yes, a task corresponds to|
是的，任务对应于，|

1441
00:44:15,610 --> 00:44:17,760
0,390 420,750 750,1440
{} {it's,like,a} process
它就像 xv6 中的进程，

1442
00:44:17,850 --> 00:44:19,560
0,600 870,1200 1200,1440 1440,1530 1530,1710
in {xv6 -},| it has
|它有一些内存和地址空间，

1443
00:44:19,560 --> 00:44:20,550
0,150 150,360 360,450 450,870 870,990
a bunch of memory and

1444
00:44:20,550 --> 00:44:22,470
0,360 360,960 1080,1500 1500,1620 1620,1920
address space| and you can
|你可以在其中执行用户代码，

1445
00:44:22,560 --> 00:44:24,660
0,450 450,720 720,990 990,1260 1530,2100
execute user code in it,|
|

1446
00:44:24,660 --> 00:44:26,180
0,150 150,270 270,990
{xv6 - -}
如果你在 xv6 中有一个进程，

1447
00:44:26,890 --> 00:44:27,580
0,120 120,180 180,270 270,300 300,690
if you have a process

1448
00:44:27,580 --> 00:44:28,840
0,60 60,690 720,930 930,1020 1020,1260
in xv6,| it can only,
|那么它只能有一个控制线程，

1449
00:44:28,840 --> 00:44:29,710
0,150 150,270 270,390 390,480 480,870
it can only be one

1450
00:44:29,710 --> 00:44:31,060
0,270 270,330 330,930 1140,1290 1290,1350
thread of control,| on a
|在一个 xv6 中的进程内执行，

1451
00:44:31,060 --> 00:44:32,950
0,660 720,870 870,990 990,1530 1530,1890
single you know executing inside

1452
00:44:32,950 --> 00:44:34,840
0,240 750,1380 1380,1590 1590,1770 1770,1890
a process in {xv6 -

1453
00:44:34,840 --> 00:44:37,210
0,570 600,990 990,1350 1620,2010 2010,2370
-},| but in modern operating
|但是在现代操作系统和 L4 中，

1454
00:44:37,210 --> 00:44:39,490
0,390 390,660 660,810 810,1320 1770,2280
systems and {L4 -}, {}|
|

1455
00:44:40,070 --> 00:44:41,480
0,120 120,210 210,780 780,1320 1320,1410
in a single process, in
在单个进程中，在单个地址空间中，

1456
00:44:41,480 --> 00:44:42,440
0,60 60,330 330,600 600,870 870,960
a single address space,| you
|如果你有多个内核，

1457
00:44:42,440 --> 00:44:43,670
0,90 90,780 810,990 990,1080 1080,1230
could have if you have

1458
00:44:43,670 --> 00:44:45,860
0,360 360,1080 1740,1950 1950,2040 2040,2190
multiple cores,| you can have
|你可以让多个内核执行单个任务，

1459
00:44:45,860 --> 00:44:49,850
0,720 720,1200 1200,1980 3330,3570 3570,3990
multiple cores executing a single

1460
00:44:49,850 --> 00:44:51,140
0,840
task,|
|

1461
00:44:51,440 --> 00:44:54,050
0,270 270,840 900,1470 1920,2430 2430,2610
for each, typically always each
通常每个核心都在任务的地址空间内设置自己的堆栈。

1462
00:44:54,050 --> 00:44:54,890
0,210 210,330 330,450 450,600 600,840
set up with its own

1463
00:44:54,890 --> 00:44:57,020
0,540 540,1020 1020,1230 1230,1770 1770,2130
stack inside that task's address

1464
00:44:57,020 --> 00:44:58,180
0,690
space.|
|

1465
00:44:58,480 --> 00:44:59,710
0,180 180,360 360,720 930,1110 1110,1230
And so if,| that means
所以，如果，|这意味着你可以，

1466
00:44:59,710 --> 00:45:00,550
0,120 120,270 270,360 360,690 690,840
you can,| for example write
|比如，编写一个程序可以获得并发速度，

1467
00:45:00,550 --> 00:45:02,290
0,60 60,420 420,1110 1290,1590 1590,1740
a single program that can

1468
00:45:02,290 --> 00:45:05,230
0,360 390,1200 1200,1770 1770,2130 2130,2940
get parallel speedup,| improve performance
|通过多核硬件增加性能，

1469
00:45:05,590 --> 00:45:07,390
0,420 420,780 780,1110 1110,1620 1620,1800
from {multi-core -} hardware| by
|通过多个线程每个运行在一个核心上，

1470
00:45:07,390 --> 00:45:09,910
0,450 840,1080 1080,1560 1560,1950 2220,2520
running one thread on having

1471
00:45:09,910 --> 00:45:11,110
0,300 300,660 660,840 840,1050 1050,1200
multiple threads each running a

1472
00:45:11,110 --> 00:45:12,700
0,270 270,690 930,1200 1200,1440 1440,1590
different core,| thereby getting more
|从而完成更多工作。

1473
00:45:12,700 --> 00:45:13,660
0,210 210,420
work done.|
|

1474
00:45:15,400 --> 00:45:16,690
0,270 270,270 270,600 600,870 870,1290
Okay, I see, thank you.|
好的，我明白了，谢谢。|

1475
00:45:16,930 --> 00:45:18,120
0,660
Yes.|
好的。|

1476
00:45:21,950 --> 00:45:23,920
0,570 660,1230
Okay, {}
好的，如你所见，

1477
00:45:24,700 --> 00:45:25,300
0,180 180,300 300,360 360,450 450,600
so as you can see,|
|

1478
00:45:25,300 --> 00:45:26,110
0,150 150,210 210,270 270,660 660,810
this is a design that
这是一个严重依赖 IPC 的设计，

1479
00:45:26,110 --> 00:45:29,560
0,300 300,780 780,1290 1530,2190 2640,3450
relies heavily on {} IPC,|
|

1480
00:45:29,770 --> 00:45:30,640
0,390 390,510 510,630 630,720 720,870
because you're going to want
因为你要与你的文件服务器交互，

1481
00:45:30,640 --> 00:45:31,300
0,60 60,240 240,300 300,390 390,660
to talk to your file

1482
00:45:31,300 --> 00:45:32,350
0,420 420,540 540,720 720,960 960,1050
server,| a file server is
|文件服务器想要与设备驱动器服务器交互，

1483
00:45:32,350 --> 00:45:32,980
0,120 120,180 180,330 330,390 390,630
going to want to talk

1484
00:45:32,980 --> 00:45:34,720
0,90 90,210 210,630 630,1050 1050,1740
to the device driver server,|
|

1485
00:45:34,900 --> 00:45:36,640
0,420 420,660 660,840 840,1320 1320,1740
you're gonna have IPC messages
你会看到 IPC 信息来回飞来飞去，

1486
00:45:36,640 --> 00:45:37,990
0,240 240,450 450,540 540,1050 1080,1350
flying back and forth,| for
|对于每个系统调用，对于每个页面错误，对于每个设备中断，

1487
00:45:37,990 --> 00:45:39,550
0,180 180,570 570,1080 1110,1380 1380,1560
every system call, for every

1488
00:45:39,550 --> 00:45:40,900
0,360 360,720 720,840 840,960 960,1350
page fault, for every device

1489
00:45:40,900 --> 00:45:42,640
0,480 570,810 810,1140 1140,1470 1470,1740
interrupt,| the IPC system just
|IPC 系统需要速度非常快，

1490
00:45:42,640 --> 00:45:44,830
0,180 180,240 240,360 360,960 1620,2190
has to be fast,| however
|现在我们开始讨论

1491
00:45:47,120 --> 00:45:49,200
0,480 480,600 600,960 960,1320
now we're starting to

1492
00:45:49,340 --> 00:45:50,960
0,540 990,1410
{ -}

1493
00:45:51,220 --> 00:45:52,960
0,480 480,720 720,840 840,1320 1320,1740
talk about| a serious potential
|微内核故事中的一个严重的潜在缺陷。

1494
00:45:52,960 --> 00:45:55,420
0,600 600,1050 1620,1770 1770,2160 2160,2460
defect in a micro kernel

1495
00:45:55,420 --> 00:45:57,780
0,630
story.|
|

1496
00:46:03,120 --> 00:46:04,360
0,60

1497
00:46:04,720 --> 00:46:05,590
0,210 210,450 450,540 540,630 630,870
So first let me show
首先让我给你们展示一个简单但是非常慢的设计，

1498
00:46:05,590 --> 00:46:08,710
0,360 360,960 1650,2100 2100,2820 2820,3120
you {} a straightforward but

1499
00:46:08,710 --> 00:46:10,880
0,240 240,570 570,1440
very slow design,|
|

1500
00:46:10,880 --> 00:46:14,000
0,810 1440,2190 2190,2580 2580,2790 2790,3120
for IPC patterned off of
模仿 Unix 管道的 IPC ，

1501
00:46:14,390 --> 00:46:15,860
0,390 390,1020 1020,1200 1200,1260 1260,1470
Unix pipes| and I'm bringing
|我之所以提到这一点，

1502
00:46:15,860 --> 00:46:17,480
0,150 150,330 330,810 840,1290 1290,1620
this up,| because some early
|是因为一些早期的微内核以这种方式工作，

1503
00:46:17,480 --> 00:46:19,400
0,270 270,840
micro kernels

1504
00:46:19,550 --> 00:46:21,290
0,480 660,1290 1290,1440 1440,1680 1680,1740
{} worked in sort of

1505
00:46:21,290 --> 00:46:22,190
0,150 150,510 510,660 660,750 750,900
a similar way| to what
|与我即将向你们展示的类似，

1506
00:46:22,190 --> 00:46:23,030
0,60 60,330 330,420 420,630 630,840
I'm about to show you,|
|

1507
00:46:23,090 --> 00:46:23,870
0,300 300,510 510,630 630,690 690,780
which turned out to be
结果证明是很慢的。

1508
00:46:23,870 --> 00:46:27,360
0,420 1560,1800 1800,2190 2310,2910
slow.| Okay, so {}
|好的，假设你有两个进程，

1509
00:46:28,060 --> 00:46:30,670
0,360 360,780 780,930 930,1860 1890,2610
let's suppose you have {}

1510
00:46:31,210 --> 00:46:32,050
0,120 120,210 210,360 360,660 690,840
you know you have two

1511
00:46:32,050 --> 00:46:33,760
0,570 570,660 660,840 840,1080 1080,1710
processes,| we got {P1 -},|
|我们有 P1 ，|

1512
00:46:34,120 --> 00:46:35,890
0,750 750,1080 1080,1410 1410,1590 1590,1770
{P1 -} wants to send
P1 想要向 P2 发送消息。

1513
00:46:35,890 --> 00:46:37,440
0,60 60,360 360,480 480,960
a message to P2.|
|

1514
00:46:37,560 --> 00:46:38,620
0,540

1515
00:46:39,710 --> 00:46:40,640
0,300 300,480 480,660 660,810 810,930
{} So how should that
那么这应该如何运作，

1516
00:46:40,640 --> 00:46:42,830
0,240 240,570 600,870 900,1320 1320,2190
actually work,| well, one possibility
|一种可能是有一个 send 系统调用，

1517
00:46:42,830 --> 00:46:44,510
0,180 180,300 300,720 750,960 960,1680
is to have a send

1518
00:46:44,510 --> 00:46:46,100
0,450 450,1020
system call,|
|

1519
00:46:46,320 --> 00:46:47,400
0,240 240,360 360,510 510,840 840,1080
and you give send system
你给 send 系统调用一个 id ，

1520
00:46:47,400 --> 00:46:48,960
0,240 240,390 390,1170 1170,1260 1260,1560
call the id| of the
|那个你想要发送消息的线程，

1521
00:46:49,630 --> 00:46:50,500
0,180 180,570 570,660 660,810 810,870
{} thread you want to

1522
00:46:50,500 --> 00:46:51,970
0,180 180,210 210,570 570,960 960,1470
send a message to| and
|以及指向消息的字节的指针，

1523
00:46:52,090 --> 00:46:54,520
0,690 720,1830
a pointer

1524
00:46:54,520 --> 00:46:56,050
0,300 300,420 420,1230 1230,1380 1380,1530
to the message to the

1525
00:46:56,050 --> 00:46:57,910
0,540 540,690 690,900 1560,1710 1710,1860
bytes,| may be that you
|可能是你想要发送到那个进程，

1526
00:46:57,910 --> 00:46:58,690
0,270 270,420 420,480 480,720 720,780
actually want to send to

1527
00:46:58,690 --> 00:47:00,340
0,180 180,630 630,870 930,1230 1230,1650
that process,| so this system
|所以这个系统调用将跳转到内核，

1528
00:47:00,340 --> 00:47:01,150
0,330 330,360 360,480 480,540 540,810
call are going to jump

1529
00:47:01,150 --> 00:47:03,460
0,120 120,210 210,750 960,1620 1890,2310
into the kernel,| you know
|也许我们可以设计这种仿照管道和 xv6 的方案，

1530
00:47:03,460 --> 00:47:04,930
0,210 210,330 330,810 810,1080 1080,1470
maybe we design this patterned

1531
00:47:04,930 --> 00:47:06,670
0,900 930,1320 1320,1410 1410,1620 1620,1740
after pipes and {xv6 -

1532
00:47:06,670 --> 00:47:08,140
0,480 750,990 990,1050 1050,1140 1140,1470
-},| so you can imagine
|所以你可以想象有一个等待消息的缓冲区，

1533
00:47:08,140 --> 00:47:10,000
0,120 120,360 360,690 1020,1590 1590,1860
there being a buffer of

1534
00:47:10,300 --> 00:47:12,700
0,570 570,1200 1290,1740 1800,2190 2190,2400
messages waiting,| maybe P2 doing
|也许 P2 正在做其他的事情，

1535
00:47:12,700 --> 00:47:14,230
0,210 210,450 450,630 630,1020 1230,1530
something else right now,| maybe
|可能它是服务器，正在为别人的请求提供服务，

1536
00:47:14,230 --> 00:47:15,190
0,90 90,150 150,540 540,660 660,960
it's a server, it's serving

1537
00:47:15,190 --> 00:47:16,690
0,270 270,570 570,1020 1020,1170 1170,1500
somebody else's request,| so it's
|所以它还没有准备好处理你的请求，

1538
00:47:16,690 --> 00:47:17,560
0,180 180,330 330,450 450,690 690,870
not ready to handle your

1539
00:47:17,560 --> 00:47:19,600
0,600 1080,1380 1380,1530 1530,1620 1620,2040
request,| {} you can imagine,
|您可以想象，也许内核中有一个等待消息的缓冲区，

1540
00:47:19,600 --> 00:47:21,010
0,270 270,390 390,840 840,990 990,1410
maybe a buffer of waiting

1541
00:47:21,010 --> 00:47:22,400
0,1080
messages

1542
00:47:22,490 --> 00:47:24,080
0,540 690,900 900,990 990,1410 1410,1590
{} in the kernel,| like
|就像管道缓冲区一样，

1543
00:47:24,080 --> 00:47:25,400
0,60 60,330 330,810 1050,1230 1230,1320
a pipe buffer,| when you
|当你调用 send 时，

1544
00:47:25,400 --> 00:47:26,840
0,180 180,810
call send,|
|

1545
00:47:27,180 --> 00:47:29,460
0,390 390,810 1140,1620 1620,1800 1800,2280
it {appends -} your message
它会将你的消息附加到这个缓冲区，

1546
00:47:29,460 --> 00:47:30,660
0,120 120,300 300,690 690,1080 1080,1200
to this buffer,| waiting for
|等待 P2 接收消息。

1547
00:47:30,660 --> 00:47:32,490
0,300 300,420 420,780 780,960 1410,1830
P2 to receive it.| {You,know},
|事实上几乎总是，

1548
00:47:32,520 --> 00:47:35,820
0,210 210,480 480,840 840,1830
in fact almost always,|
|

1549
00:47:36,060 --> 00:47:38,100
0,150 150,360 360,1200 1320,1740 1740,2040
in these systems, you rarely
在这些系统中，你很少仅仅想要发送一条信息，

1550
00:47:38,100 --> 00:47:38,970
0,270 270,510 510,570 570,810 810,870
just wanted to send a

1551
00:47:38,970 --> 00:47:40,860
0,600 870,1020 1020,1350 1350,1650 1650,1890
message,| you almost always wanted
|你几乎总是想得到回应，

1552
00:47:40,860 --> 00:47:41,910
0,60 60,180 180,240 240,810 810,1050
to get a response too,|
|

1553
00:47:41,910 --> 00:47:43,260
0,120 120,420 450,600 600,1260 1260,1350
you wanted an RPC, {}
你需要 RPC ，远程过程调用操作，

1554
00:47:43,260 --> 00:47:46,350
0,330 330,840 840,1320 1800,2790 2790,3090
remote procedure call operation,| so,
|所以， P1 可能会紧跟其后的是接收，

1555
00:47:46,410 --> 00:47:47,490
0,210 210,600 600,810 810,930 930,1080
in fact {P1 -} would

1556
00:47:47,490 --> 00:47:48,960
0,300 300,600 600,750 750,1320 1320,1470
probably follow this immediately by

1557
00:47:48,960 --> 00:47:50,160
0,150 150,810 810,960 960,1110 1110,1200
a receive| to try to
|以尝试获得响应，

1558
00:47:50,160 --> 00:47:52,140
0,150 150,240 240,750 750,1170 1590,1980
get the response back {},|
|

1559
00:47:52,320 --> 00:47:53,440
0,150 150,210 210,720
but in general,|
但总的来说，|

1560
00:47:53,500 --> 00:47:55,000
0,270 270,420 420,900 1110,1320 1320,1500
let's just imagine we're doing
让我们暂时设想一下我们正在进行单向 IPC ，

1561
00:47:55,000 --> 00:47:56,140
0,90 90,450 450,960 960,1050 1050,1140
a one-way IPC for the

1562
00:47:56,140 --> 00:47:57,940
0,270 270,390 390,750 750,1080 1290,1800
moment,| so send would append
|所以 send 会将你的消息附加到内核缓冲区中，

1563
00:47:57,940 --> 00:47:59,980
0,150 150,840 1200,1530 1530,1740 1740,2040
your message {} to the

1564
00:48:00,100 --> 00:48:02,170
0,240 240,570 570,1230 1500,1710 1710,2070
in kernel buffer,| {} we
|我们必须将消息字节从用户空间复制到这个缓冲区，

1565
00:48:02,170 --> 00:48:03,880
0,120 120,210 210,840 1200,1380 1380,1710
have to copy the message

1566
00:48:03,880 --> 00:48:05,200
0,390 390,540 540,780 780,1170 1170,1320
bytes from user space into

1567
00:48:05,200 --> 00:48:07,120
0,150 150,570 660,1230 1230,1380 1380,1920
this buffer| and then return
|然后返回，进程一可以做一些其他事情，

1568
00:48:07,120 --> 00:48:08,200
0,240 240,600 600,810 810,930 930,1080
and process one can do

1569
00:48:08,200 --> 00:48:10,480
0,300 300,630 630,900 1440,1830 1860,2280
something else,| like maybe prepared
|比如可能准备接收回复，

1570
00:48:10,480 --> 00:48:12,970
0,90 90,390 390,450 450,1170 1950,2490
to receive the response,| after
|过了一会儿，

1571
00:48:12,970 --> 00:48:14,860
0,30 30,270 270,480 480,990 1260,1890
a while,| {P2 -} {}
|P2 想要接收下一条消息，

1572
00:48:16,080 --> 00:48:17,400
0,240 240,690 750,930 930,990 990,1320
it's gonna want to receive

1573
00:48:17,400 --> 00:48:18,570
0,60 60,300 300,660 660,870 870,1170
the next message| just gonna
|只要调用 recv 系统调用，

1574
00:48:18,600 --> 00:48:20,100
0,180 180,240 240,660 660,990 990,1500
make the recv system call,|
|

1575
00:48:21,290 --> 00:48:24,680
0,690 930,1920 2160,2460 2460,2670 2670,3390
{} and that's gonna return
它将返回发送者的 id ，

1576
00:48:24,680 --> 00:48:26,180
0,180 180,570 570,660 660,750 750,1500
the id of the sender,|
|

1577
00:48:26,800 --> 00:48:28,750
0,360 360,570 570,960 960,1080 1080,1950
{} and copy the message
并将消息复制到 P2 的内存中，

1578
00:48:28,900 --> 00:48:31,510
0,270 270,720 720,1170 1650,2100 2160,2610
into P2's memory,| {} just
|把前面的消息从队列里拿出来，

1579
00:48:31,510 --> 00:48:32,860
0,150 150,330 330,630 810,1080 1080,1350
gonna take the front message

1580
00:48:32,860 --> 00:48:33,850
0,150 150,210 210,570 570,840 840,990
off the queue,| copy into
|复制到 P2 的内存里，

1581
00:48:33,850 --> 00:48:35,320
0,270 270,360 360,930
{P2's -} memory,|
|

1582
00:48:36,550 --> 00:48:39,200
0,180 180,330 330,870
and then return.|
然后返回。|

1583
00:48:40,800 --> 00:48:43,340
0,450 1080,1530
So {}.|
所以。|

1584
00:48:44,150 --> 00:48:45,140
0,480

1585
00:48:45,340 --> 00:48:46,560
0,780

1586
00:48:46,890 --> 00:48:49,380
0,390 390,510 510,930 930,1380 2100,2490
This is called, { -}|
这个叫做，|

1587
00:48:50,130 --> 00:48:52,290
0,330 330,690 720,1440 1440,1560 1560,2160
there's some words for this,|
有一些词来形容这个，|

1588
00:48:52,350 --> 00:48:53,910
0,180 180,450 450,930 930,1050 1050,1560
{} whose [] you'll see
你会在今天的论文中看到，

1589
00:48:54,240 --> 00:48:55,950
0,510 510,570 570,870 870,1350 1410,1710
saw in today's paper,| this
|这称为异步方案，

1590
00:48:55,950 --> 00:48:59,520
0,90 90,330 330,420 420,1590 2730,3570
is called an asynchronous scheme,|
|

1591
00:49:01,230 --> 00:49:02,850
0,600 660,1020 1020,1230 1230,1590 1590,1620
because {P1 -} sends a
因为 P1 发送消息而不需要等待任何东西，

1592
00:49:02,850 --> 00:49:03,900
0,360 360,570 570,750 750,840 840,1050
message without having to wait

1593
00:49:03,900 --> 00:49:04,860
0,150 150,420 420,480 480,600 600,960
for anything,| it just appends
|它只是追加到队列并返回，

1594
00:49:04,860 --> 00:49:07,440
0,180 180,600 600,690 690,1530 2310,2580
to queue and returns,| and
|它被称为缓冲系统，

1595
00:49:07,440 --> 00:49:09,570
0,120 120,660 660,960 960,1380 1380,2130
it's called a buffered system,|
|

1596
00:49:12,520 --> 00:49:15,610
0,1290 1590,1770 1770,2280 2310,2610 2610,3090
because the kernel {} copy
因为内核复制这个消息到缓冲区中，

1597
00:49:15,610 --> 00:49:16,750
0,150 150,480 480,660 660,750 750,1140
this message into the buffer|
|

1598
00:49:16,750 --> 00:49:18,430
0,210 210,390 390,750 750,1230 1440,1680
into its internal buffer on
到 send 的内部缓冲区中，

1599
00:49:18,430 --> 00:49:19,660
0,60 60,450 450,540 540,660 660,1230
the send| and then later
|然后稍后当接收发生时，

1600
00:49:20,050 --> 00:49:21,190
0,240 240,330 330,660 660,1050 1050,1140
when the receive happens,| it
|它将消息从缓冲区复制到目标，

1601
00:49:21,190 --> 00:49:22,150
0,360 360,450 450,750 750,900 900,960
copies the message out of

1602
00:49:22,150 --> 00:49:23,380
0,60 60,570 630,720 720,810 810,1230
the buffer to the target,|
|

1603
00:49:23,380 --> 00:49:25,210
0,120 120,270 270,600 660,1320 1320,1830
so this is asynchronous buffered.|
所以这是异步缓冲。|

1604
00:49:27,040 --> 00:49:27,940
0,240 240,330 330,540 540,630 630,900
If you're doing a full
如果你正在进行完整的请求响应对，

1605
00:49:27,940 --> 00:49:30,370
0,450 450,1260 1290,1830 1980,2250 2250,2430
request response pair,| then {P1
|然后 P1 将调用 send ，

1606
00:49:30,370 --> 00:49:30,880
0,120 120,180 180,300 300,360 360,510
-} is going to call

1607
00:49:30,880 --> 00:49:31,720
0,360 360,570 570,630 630,750 750,840
send,| {send -} going to
|send 将会返回，

1608
00:49:31,720 --> 00:49:32,950
0,510 540,900 900,1020 1020,1110 1110,1230
return,| {P1 -} is then
|然后 P1 直接，

1609
00:49:32,950 --> 00:49:35,110
0,870 930,1320 1320,1890 1950,2010 2010,2160
immediately,| let's assume we're going
|让我们假设这两组缓冲区，

1610
00:49:35,110 --> 00:49:36,670
0,60 60,270 270,540 540,780 930,1560
to assume that's really two

1611
00:49:36,670 --> 00:49:37,720
0,270 270,360 360,720 720,930 930,1050
sets of buffers,| one for
|每个方向一组，

1612
00:49:37,720 --> 00:49:39,850
0,120 120,690 1140,1410 1410,1590 1590,2130
each direction,| {P1 -} immediately
|P1 立即调用 recv ，

1613
00:49:39,850 --> 00:49:41,640
0,180 180,450 450,1350
gonna call recv,|
|

1614
00:49:42,880 --> 00:49:45,040
0,630 630,840 840,1440 1740,2070 2070,2160
recv gonna wait, need to
recv 将等待某些内容出现在应答缓冲区中，

1615
00:49:45,040 --> 00:49:46,360
0,300 300,390 390,690 690,810 810,1320
wait for something to appear

1616
00:49:46,360 --> 00:49:48,880
0,120 120,270 270,1200 1470,2040 2280,2520
in the reply buffer,| so
|所以它不得不让出 CPU ，

1617
00:49:48,880 --> 00:49:49,360
0,90 90,210 210,270 270,360 360,480
it's going to have to

1618
00:49:49,360 --> 00:49:50,890
0,390 390,480 480,1140 1140,1290 1290,1530
yield the CPU,| it's got
|它会做一些事情，

1619
00:49:50,890 --> 00:49:51,610
0,60 60,150 150,390 390,480 480,720
to do something| and call
|在 xv6 中，调用 sleep 并让出 CPU ，

1620
00:49:51,610 --> 00:49:53,140
0,480 480,630 630,1020 1020,1350 1350,1530
sleep in {xv6 -}, yield

1621
00:49:53,140 --> 00:49:56,050
0,60 60,690 1890,2250 2250,2640 2640,2910
the CPU,| on a single
|在单个 CPU 系统上，

1622
00:49:56,050 --> 00:49:57,220
0,390 390,750 750,870 870,990 990,1170
CPU system,| it may be
|可能只有在这一点上，

1623
00:49:57,220 --> 00:49:59,020
0,330 330,480 480,690 690,1260 1470,1800
only at this point,| that
|P1 放弃 CPU ， P2 才可以运行。

1624
00:49:59,020 --> 00:50:00,190
0,210 210,660 660,900 900,1080 1080,1170
{P1 -} gives up the

1625
00:50:00,190 --> 00:50:01,570
0,510 510,600 600,750 750,1230 1230,1380
CPU and now P2 can

1626
00:50:01,570 --> 00:50:02,420
0,420
run.|
|

1627
00:50:02,630 --> 00:50:04,490
0,270 270,840 840,1020 1140,1770 1770,1860
And indeed the hardware in
事实上，这个时代的硬件几乎都是单核的，

1628
00:50:04,490 --> 00:50:05,870
0,180 180,480 480,660 660,930 930,1380
this era was almost always

1629
00:50:05,870 --> 00:50:09,050
0,390 390,870 2040,2460 2460,2610 2610,3180
single core,| certainly this paper
|当然，这篇论文是在单核硬件上运行的，

1630
00:50:09,530 --> 00:50:10,580
0,180 180,360 360,600 600,720 720,1050
{} is running on single

1631
00:50:10,580 --> 00:50:12,320
0,210 210,600 600,900 960,1560 1560,1740
core hardware,| so {P1 -}
|所以 P1 将会，

1632
00:50:12,320 --> 00:50:14,240
0,90 90,450 720,1140 1140,1380 1380,1920
is gonna,| {P1 -} executing
|P1 执行， P1 不执行，

1633
00:50:14,240 --> 00:50:15,440
0,90 90,240 240,420 420,660 660,1200
and {P1 -} not executing|
|

1634
00:50:15,440 --> 00:50:16,550
0,240 240,420 420,630 630,900 900,1110
until {P1 -} finally gets
直到 P1 最终获得 CPU ，

1635
00:50:16,550 --> 00:50:18,230
0,210 210,360 360,960 960,1080 1080,1680
up the CPU| and recv
|recv 等待这里出现的消息，

1636
00:50:18,410 --> 00:50:19,490
0,450 450,570 570,600 600,930 930,1080
waiting for a message to

1637
00:50:19,490 --> 00:50:21,200
0,360 360,810 990,1260 1260,1500 1500,1710
appear here| and only then
|并且只有到那时， P2 才能被调度，调用 recv ，

1638
00:50:21,200 --> 00:50:22,430
0,150 150,390 390,540 540,660 660,1230
will {P2 -} be scheduled

1639
00:50:22,430 --> 00:50:24,200
0,210 210,300 300,570 570,1350
maybe to call recv,|
|

1640
00:50:24,320 --> 00:50:26,180
0,330 330,660 660,720 720,1350 1380,1860
recv copy the message| and
recv 复制消息，|然后 P2 调用它的 send ，

1641
00:50:26,180 --> 00:50:28,190
0,180 180,960 1170,1500 1500,1710 1710,2010
then P2 make it's called

1642
00:50:28,190 --> 00:50:29,560
0,780
{to,send},|
|

1643
00:50:31,020 --> 00:50:32,400
0,780

1644
00:50:32,800 --> 00:50:34,680
0,150 150,390 390,540 540,1320
to append its reply.|
追加其回复。|

1645
00:50:34,770 --> 00:50:35,960
0,450

1646
00:50:36,110 --> 00:50:37,160
0,120 120,420 420,510 510,810 810,1050
And then the send system
然后 send 系统调用返回到 P2 ，

1647
00:50:37,160 --> 00:50:38,900
0,240 240,780 780,840 840,1470 1470,1740
call return to P2| and
|在某一时刻， P2 可能会让出 CPU ，

1648
00:50:38,960 --> 00:50:40,070
0,90 90,240 240,450 450,780 780,1110
at some point, presumably P2

1649
00:50:40,070 --> 00:50:41,150
0,120 120,240 240,420 420,510 510,1080
will give up to CPU,|
|

1650
00:50:41,180 --> 00:50:42,140
0,210 210,300 300,720 720,810 810,960
maybe the timer will go
可能是计时器响起，

1651
00:50:42,140 --> 00:50:44,390
0,390 690,1020 1020,1260 1260,2040 2040,2250
off,| then {P1 -} will
|然后 P1 将在内核中恢复执行，

1652
00:50:44,390 --> 00:50:45,890
0,300 300,780 780,870 870,930 930,1500
resume execution in the kernel,|
|

1653
00:50:46,190 --> 00:50:47,780
0,600 600,840 840,900 900,1230 1230,1590
see there's a message there|
看到那里有一条消息，|

1654
00:50:47,780 --> 00:50:48,740
0,90 90,420 420,630 630,750 750,960
and return back to user
然后返回到用户空间，

1655
00:50:48,740 --> 00:50:51,350
0,630 1590,1950 1980,2190 2190,2340 2340,2610
space| and so that means
|所以这意味着，

1656
00:50:51,350 --> 00:50:53,090
0,180 180,300 300,780 780,1530 1590,1740
that,| {} this design is
|这个设计是缓慢的设计。

1657
00:50:53,090 --> 00:50:54,540
0,360 360,990
slow design.|
|

1658
00:50:54,990 --> 00:50:56,430
0,360 420,930 960,1110 1110,1350 1350,1440
{} There's in order to
为了得到请求和响应，

1659
00:50:56,430 --> 00:50:57,990
0,390 420,540 540,1290 1350,1500 1500,1560
have a request and a

1660
00:50:57,990 --> 00:51:02,550
0,1020 1440,2040 3750,4020 4020,4260 4260,4560
response,| { -} there's four
|需要四个系统调用，两个 send ，两个 recv ，

1661
00:51:02,550 --> 00:51:05,580
0,300 300,1140 1290,1560 1560,2520 2850,3030
system calls, two sends, and

1662
00:51:05,580 --> 00:51:07,320
0,180 180,930 1110,1230 1230,1350 1380,1740
two recvs,| you know each
|每一次用户内核穿越，

1663
00:51:07,870 --> 00:51:09,250
0,270 270,570 570,1050 1050,1170 1170,1380
user kernel crossings,| each one
|每一次都相当昂贵，

1664
00:51:09,250 --> 00:51:11,080
0,90 90,300 300,540 720,1170 1170,1830
of which is reasonably expensive,|
|

1665
00:51:11,380 --> 00:51:13,090
0,570 810,1230 1230,1380 1380,1620 1620,1710
{} there's a need to
这里需要休眠，

1666
00:51:13,090 --> 00:51:15,220
0,900 1020,1260 1260,1650 1650,1830 1830,2130
sleep,| this recv has to
|这个 recv 必须休眠，等待数据出现，

1667
00:51:15,520 --> 00:51:17,260
0,480 480,810 810,1230 1290,1590 1590,1740
sleep, waiting for data to

1668
00:51:17,260 --> 00:51:19,360
0,510 780,1320 1500,1890 1890,2040 2040,2100
appear,| {} and there's a
|有一个完整调用调度器循环，

1669
00:51:19,360 --> 00:51:21,100
0,390 390,750 750,840 840,1380 1380,1740
full call the scheduler loop|
|

1670
00:51:21,100 --> 00:51:22,660
0,150 150,180 180,690 690,1140 1140,1560
and a context switch from
以及从 P1 到 P2 的上下文切换，

1671
00:51:22,690 --> 00:51:24,100
0,180 180,360 360,420 420,900
{P1 -} to P2,|
|

1672
00:51:24,100 --> 00:51:24,850
0,180 180,270 270,450 450,540 540,750
{} in order to make
才能实现这个。

1673
00:51:24,850 --> 00:51:26,500
0,330 330,660 960,1140 1140,1290 1320,1650
this.| And you know each
|每个内核穿越和上下文切换都可能是昂贵的，

1674
00:51:26,500 --> 00:51:27,820
0,90 90,270 270,630 630,1200 1200,1320
of these kernel crossings and

1675
00:51:27,820 --> 00:51:29,770
0,480 480,660 660,930 930,1380 1380,1950
context switch is potentially expensive,|
|

1676
00:51:29,770 --> 00:51:30,970
0,330 390,780 780,870 870,1050 1050,1200
because {} you know every
因为你每次跨越内核用户边界时，

1677
00:51:30,970 --> 00:51:32,170
0,150 150,300 420,780 780,840 840,1200
time you cross the kernel

1678
00:51:32,170 --> 00:51:33,610
0,240 240,630 630,750 750,1050 1050,1440
user boundary,| you switch page
|你交换页表，

1679
00:51:33,610 --> 00:51:36,430
0,750 930,1590 1620,1860 1860,2160 2400,2820
tables| {} and that {}
|那个，

1680
00:51:36,910 --> 00:51:37,840
0,270 270,450
is {},|
|

1681
00:51:37,930 --> 00:51:39,310
0,240 240,420 420,480 480,690 690,1380
it has a near certainty
它几乎肯定会扰乱 CPU 缓存，

1682
00:51:39,310 --> 00:51:42,100
0,300 300,720 1140,2040 2040,2370 2370,2790
of {} disturbing the CPU

1683
00:51:42,100 --> 00:51:44,020
0,540 540,780 990,1560 1560,1650 1650,1920
caches,| like changing the page
|比如更改页表，

1684
00:51:44,020 --> 00:51:46,930
0,390 480,900 900,1410 1410,1710 2250,2910
table,| probably flushes the {}
|可能会刷新 TLB ，虚拟内存查找缓存，

1685
00:51:46,930 --> 00:51:48,250
0,240 240,420 420,840 840,1020 1020,1320
{TLB - -}, the virtual

1686
00:51:48,250 --> 00:51:49,480
0,270 270,570 570,990 990,1140 1140,1230
memory lookup cache,| which is
|这会让事情变慢。

1687
00:51:49,480 --> 00:51:50,530
0,120 120,180 180,420 420,690 690,1050
going to slow things down.|
|

1688
00:51:51,040 --> 00:51:52,100
0,480

1689
00:51:52,220 --> 00:51:54,540
0,510
So,
所以，这是一种相当慢的方式，

1690
00:51:54,540 --> 00:51:55,410
0,180 180,240 240,330 330,570 570,870
this is a pretty slow

1691
00:51:55,410 --> 00:51:56,550
0,120 120,210 210,570 660,1080 1080,1140
way to go| involves a
|涉及大量内核穿越消息，

1692
00:51:56,550 --> 00:51:58,890
0,120 120,180 180,420 420,1200 1770,2340
lot of kernel crossings message,|
|

1693
00:51:58,890 --> 00:52:00,480
0,420 420,510 510,990 990,1320 1320,1590
copying of messages between user
在用户和内核之间复制消息，

1694
00:52:00,480 --> 00:52:02,250
0,90 90,570 630,990 990,1680 1680,1770
and kernel,| maybe allocation of
|可能分配缓冲区等等，

1695
00:52:02,250 --> 00:52:05,550
0,870 900,1560 2580,2970 2970,3030 3030,3300
buffers etc,| but it turns
|但事实证明，

1696
00:52:05,550 --> 00:52:07,410
0,210 210,510 510,990 990,1470 1710,1860
out that,| for the, for
|对于这个[]案例，

1697
00:52:07,410 --> 00:52:08,730
0,150 150,810 810,1110 1110,1170 1170,1320
this [] case,| in which
|你发送请求，并且希望得到响应，

1698
00:52:08,730 --> 00:52:09,930
0,90 90,390 390,480 480,1080 1080,1200
you're sending a request and

1699
00:52:09,930 --> 00:52:10,350
0,90 90,210 210,270 270,390 390,420
you want to get a

1700
00:52:10,350 --> 00:52:13,290
0,480 480,900 1020,1560 2370,2760 2760,2940
response back,| { -} you
|你可以将其简化为相当简单的设计，

1701
00:52:13,290 --> 00:52:14,790
0,240 270,660 660,840 840,1170 1170,1500
can strip this down to

1702
00:52:14,790 --> 00:52:18,420
0,390 390,1110 1170,1920 2130,2820 3180,3630
{} considerably simpler design| and
|事实上，这就是它前进的方向。

1703
00:52:18,630 --> 00:52:19,290
0,90 90,360 360,480 480,570 570,660
in fact, this is the

1704
00:52:19,290 --> 00:52:21,160
0,150 150,360 360,1020
way it forward.|
|

1705
00:52:21,870 --> 00:52:22,830
0,270 270,480 480,600 600,810 810,960
And this was laid out
这是在一份著名的论文上发表的，

1706
00:52:22,830 --> 00:52:24,840
0,60 60,120 120,480 480,1020 1380,2010
in a famous paper {},|
|

1707
00:52:25,080 --> 00:52:26,910
0,480 480,900 900,1350 1350,1500 1500,1830
called improving IPC by kernel
称为通过内核设计改进 IPC ，

1708
00:52:26,910 --> 00:52:29,130
0,660 810,1500 1500,1560 1560,1830 1830,2220
design| published a few years
|在今天的论文前几年发表。

1709
00:52:29,130 --> 00:52:30,940
0,510 510,900 900,1320
before today's paper.|
|

1710
00:52:30,990 --> 00:52:32,220
0,720

1711
00:52:34,670 --> 00:52:35,750
0,480 480,600 600,750 750,810 810,1080
So it does a couple
所以它做了几件不同的事情，

1712
00:52:35,750 --> 00:52:38,030
0,510 540,1140 1200,1530 1530,1740 1740,2280
things differently,| for one thing,
|首先，它是同步的。

1713
00:52:38,420 --> 00:52:40,860
0,630 750,1020 1020,1980
{} it's synchronous.|
|

1714
00:52:42,330 --> 00:52:43,820
0,300 300,990
That is,|
这就是，|

1715
00:52:44,700 --> 00:52:47,280
0,540 1380,2070 2070,2310 2310,2370 2370,2580
{} there's none of this,
这里没有丢弃任何东西，

1716
00:52:47,280 --> 00:52:49,840
0,180 180,510 510,990 1290,2190
there's no { -}

1717
00:52:50,010 --> 00:52:51,900
0,600 600,930 930,1290 1290,1410 1410,1890
dropping something off| and returning
|返回并等待，

1718
00:52:51,900 --> 00:52:53,430
0,120 120,690 840,1170 1170,1320 1320,1530
and waiting,| letting the other
|让另一个进程提取数据，

1719
00:52:53,430 --> 00:52:55,380
0,600 750,1260 1260,1350 1350,1530 1530,1950
guy, letting the other process

1720
00:52:55,380 --> 00:52:56,850
0,150 150,300 300,390 390,810 1140,1470
pick up the data,| when
|它感觉像，

1721
00:52:56,850 --> 00:52:58,800
0,90 90,330 330,570 570,1380 1560,1950
it feels like,| instead {}
|不是 send 等待 recv 和 recv 等待 send 。

1722
00:52:58,920 --> 00:53:01,470
0,720 990,1410 1410,1560 1560,2310 2340,2550
send waits for receive and

1723
00:53:01,470 --> 00:53:03,120
0,450 450,750 750,840 840,1260 1260,1650
receive waits for send.| So,
|所以， P1 想要发送，我调用 send ，

1724
00:53:03,900 --> 00:53:05,400
0,390 540,840 840,1230 1230,1410 1410,1500
{} one process one and

1725
00:53:05,400 --> 00:53:06,210
0,30 30,180 180,240 240,600 660,810
I want to send and

1726
00:53:06,210 --> 00:53:09,020
0,210 210,450 450,1110 1560,2220
I call send {},|
|

1727
00:53:11,280 --> 00:53:13,650
0,420 420,960 960,1470 1470,1620 1620,2370
it doesn't copy my message
它不会将我的消息复制到缓冲区，

1728
00:53:13,740 --> 00:53:15,300
0,330 330,420 420,780 780,1020 1020,1560
into a buffer,| it actually
|P1 现在直接，

1729
00:53:15,450 --> 00:53:16,890
0,510 600,930 930,1110 1110,1230 1230,1440
{} {P1 -} will now

1730
00:53:16,890 --> 00:53:19,520
0,900 900,1200 1500,1920
immediately,| if {}
|如果 P1 在 L4 内核中发送，

1731
00:53:19,520 --> 00:53:21,020
0,150 150,540 540,900 900,1110 1320,1500
the P1 send in the

1732
00:53:21,020 --> 00:53:22,640
0,180 180,420 420,780 780,1380 1410,1620
{L4 -} kernel,| waits for
|等待 P2 调用 recv ，

1733
00:53:22,640 --> 00:53:24,770
0,690 690,780 780,1020 1020,1650 1830,2130
P2 to call recv| and
|并且如果 P2 已经在内核中等待调用 recv ，

1734
00:53:24,800 --> 00:53:26,030
0,120 120,480 480,660 660,1110 1110,1230
if P2 is already in

1735
00:53:26,030 --> 00:53:27,440
0,90 90,690 720,1260 1260,1350 1350,1410
the kernel waiting in a

1736
00:53:27,440 --> 00:53:29,540
0,210 210,300 300,1020 1230,1500 1530,2100
call to recv,| well {P2,is}
|P2 要么已经在内核中，等待调用 recv ，

1737
00:53:29,540 --> 00:53:30,950
0,300 300,660 660,750 750,840 840,1410
either already in the kernel,

1738
00:53:32,380 --> 00:53:33,100
0,300 300,390 390,450 450,630 630,720
waiting in a call to

1739
00:53:33,100 --> 00:53:36,520
0,810 1200,1740 2250,2760 2940,3120 3120,3420
recv| or {} {P1,send -}
|或者 P1 send 并等待，

1740
00:53:36,520 --> 00:53:37,630
0,180 180,450 450,630 630,750 780,1110
and wait for it,| wait
|等待 P2 的下一个调用 recv ，

1741
00:53:37,630 --> 00:53:38,710
0,150 150,540 540,630 630,900 900,1080
for {P2's -} next call

1742
00:53:38,710 --> 00:53:41,080
0,90 90,630 660,1710 1740,2220 2220,2370
to recv,| when both have
|当两者都到达这里时，

1743
00:53:41,080 --> 00:53:43,000
0,750 750,1200 1350,1500 1500,1680 1680,1920
arrived here,| when {P1 -}
|当 P1 在内核中，它调用 send ，

1744
00:53:43,000 --> 00:53:43,760
0,330
is,

1745
00:53:44,660 --> 00:53:45,800
0,480 480,720 720,810 810,900 900,1140
{in,the} kernel and it's called

1746
00:53:45,800 --> 00:53:46,730
0,390 390,750 750,810 810,870 870,930
{a,send},| {P2's -} in the
|P2 在内核中，调用 recv ，

1747
00:53:46,730 --> 00:53:47,990
0,330 330,480 480,720 720,780 780,1260
kernel is called to recv,|
|

1748
00:53:48,050 --> 00:53:49,670
0,450 450,660 660,810 810,1170 1170,1620
only then does anything happen,|
只有那时才会有事情发生，|

1749
00:53:49,790 --> 00:53:53,240
0,600 1170,1530 2010,2490 2940,3180 3180,3450
{} and {} one reason
这个速度快的原因之一是，

1750
00:53:53,240 --> 00:53:54,620
0,270 270,900
{this,is} fast

1751
00:53:55,000 --> 00:53:57,040
0,210 210,510 810,1230 1230,1620 1620,2040
is that,| if {P2,is} already
|如果 P2 已经在 recv ，

1752
00:53:57,040 --> 00:54:00,020
0,570 570,840 1350,1650 1650,2310
{in,recv},| then {P1 -},
|然后 P1 ，当它在内核中执行 send 时，

1753
00:54:00,050 --> 00:54:01,430
0,180 180,330 330,870 870,1290 1290,1380
when it's executing {send,in} the

1754
00:54:01,430 --> 00:54:03,890
0,480 510,870 870,1410 1950,2400 2400,2460
kernel,| can just without a
|可以没有上下文切换或通用调度，

1755
00:54:03,890 --> 00:54:06,650
0,600 600,1350 1380,2040 2220,2430 2430,2760
context switch or a general

1756
00:54:06,650 --> 00:54:09,000
0,300 300,840 900,1260 1260,1650
purpose scheduling,| can just
|可以直接跳回 P2 的用户空间，

1757
00:54:09,000 --> 00:54:10,770
0,720 720,1020 1020,1200 1200,1440 1440,1770
jump back into user space

1758
00:54:10,770 --> 00:54:12,570
0,210 210,1110 1140,1560 1560,1710 1710,1800
in P2,| as if it
|就像是从这个 recv 返回，

1759
00:54:12,570 --> 00:54:14,490
0,180 180,690 690,870 870,1080 1080,1920
was returning from this receive,

1760
00:54:15,050 --> 00:54:15,950
0,210 210,300 300,450 450,510 510,900
right,| and that's a much
|这是一条通过内核的更快的路径，

1761
00:54:15,950 --> 00:54:17,480
0,420 420,720 720,870 870,960 960,1530
faster path through the kernel,|
|

1762
00:54:17,570 --> 00:54:19,760
0,390 420,960 1230,1590 1590,1740 1740,2190
{} than you know saving
比起保存寄存器，放弃 CPU ，调用调度器，

1763
00:54:19,760 --> 00:54:21,290
0,540 540,780 780,900 900,990 990,1530
registers, giving up the CPU

1764
00:54:21,290 --> 00:54:23,810
0,330 330,390 390,1560 1920,2340 2340,2520
calling the scheduler| {} and
|并找到一个新的进程来运行，

1765
00:54:23,810 --> 00:54:24,860
0,300 300,360 360,510 510,960 960,1050
finding a new process to

1766
00:54:24,860 --> 00:54:26,840
0,300 300,930 960,1380 1380,1620 1620,1980
run,| instead {P1 -} send
|相反， P1 send 知道有等待的 recv ，

1767
00:54:26,840 --> 00:54:28,970
0,1110 1170,1470 1590,1770 1770,1860 1860,2130
knows that there's a waiting

1768
00:54:28,970 --> 00:54:31,540
0,780 900,1500 1620,1770 1770,2190
recv,| {} and just
|然后立刻跳到了 P2 ，

1769
00:54:32,060 --> 00:54:34,520
0,510 720,960 960,1110 1110,2070 2100,2460
{} sort of immediately jumps

1770
00:54:34,520 --> 00:54:36,350
0,180 180,780 1410,1650 1650,1770 1770,1830
into P2,| as if it
|就像它是从 recv 返回一样。

1771
00:54:36,350 --> 00:54:38,140
0,210 210,540 540,750 750,1260
was returning from recv.|
|

1772
00:54:39,080 --> 00:54:41,930
0,630 1770,1920 1920,2610 2610,2760 2760,2850
{} The scheme that they
他们开发的方案也是无缓冲的，

1773
00:54:41,930 --> 00:54:43,460
0,330 330,450 450,690 690,900 900,1530
developed is also {unbuffered -},|
|

1774
00:54:47,540 --> 00:54:48,620
0,360 360,540 540,660 660,780 780,1080
and it could do that
它可以部分做到这一点，

1775
00:54:48,620 --> 00:54:50,660
0,300 300,510 510,930 960,1260 1260,2040
partially,| because it's {} synchronous,|
|因为它是同步的，|

1776
00:54:52,220 --> 00:54:53,450
0,450 450,690 690,780 780,1080 1080,1230
when both the send and
当 send 和 recv 都在内核中，

1777
00:54:53,450 --> 00:54:55,160
0,720 750,990 990,1080 1080,1170 1170,1710
recv are in the kernel,|
|

1778
00:54:55,220 --> 00:54:57,650
0,540 900,1050 1050,1950 1980,2160 2160,2430
{} the message can be,|
信息可以，|

1779
00:54:58,040 --> 00:54:59,120
0,120 120,240 240,540 540,870 870,1080
you know send sending some
send 发送一些信息，

1780
00:54:59,120 --> 00:55:00,380
0,750
message,|
|

1781
00:55:00,780 --> 00:55:02,130
0,150 150,420 420,570 570,1020 1020,1350
the kernel can directly copy
内核可以直接将消息从用户空间复制到用户空间，

1782
00:55:02,130 --> 00:55:03,750
0,90 90,450 450,630 630,900 900,1620
the message from user space

1783
00:55:03,990 --> 00:55:05,550
0,180 180,450 450,960 960,1350 1350,1560
to user space,| without having
|而不必首先复制到内核中，然后再从内核中返回，

1784
00:55:05,550 --> 00:55:06,570
0,120 120,420 420,780 780,930 930,1020
to first copy into the

1785
00:55:06,570 --> 00:55:07,680
0,420 420,570 570,720 720,960 960,1110
kernel, and then back out

1786
00:55:07,680 --> 00:55:09,630
0,60 60,150 150,570 750,1290 1380,1950
of the kernel,| because because
|由于双方都在等待对方的系统调用，

1787
00:55:09,630 --> 00:55:11,880
0,540 930,1530 1530,1800 1800,2100 2100,2250
since both sides wait for

1788
00:55:11,880 --> 00:55:13,350
0,120 120,510 600,930 930,1170 1170,1470
the other system call,| what
|发生的事，

1789
00:55:13,350 --> 00:55:15,690
0,600 690,1020 1020,1410 1410,1710 1860,2340
happened,| that means that they've
|这意味着它们在等待这两个指针已经知道，

1790
00:55:15,690 --> 00:55:17,280
0,360 360,510 510,990 990,1470 1470,1590
waited for both pointers to

1791
00:55:17,280 --> 00:55:19,320
0,120 120,600 600,990 990,1770 1770,2040
be known,| recv specifies where
|recv 指定它希望将消息存放在何处，

1792
00:55:19,320 --> 00:55:20,620
0,90 90,480 480,840
it wants the

1793
00:55:20,650 --> 00:55:22,270
0,420 420,510 510,630 630,1320 1410,1620
message to be deposited,| so
|所以，在这一点上，

1794
00:55:22,270 --> 00:55:23,590
0,120 120,330 330,720 990,1170 1170,1320
at this point,| {} we
|我们知道这两个地址，然后内核可以直接复制，

1795
00:55:23,590 --> 00:55:24,880
0,150 150,390 390,840 840,960 960,1290
know both addresses, then kernel

1796
00:55:24,880 --> 00:55:26,170
0,210 210,330 330,390 390,690 690,1290
just do the copy directly,|
|

1797
00:55:26,200 --> 00:55:27,970
0,450 450,510 1110,1350 1350,1410 1410,1770
instead of through the kernel.|
而不是通过内核。|

1798
00:55:29,160 --> 00:55:33,040
0,450 1830,2490 2490,2730 2760,3270
{} For and {}
如果消息非常小，

1799
00:55:33,380 --> 00:55:35,060
0,150 150,240 240,630 630,1200 1320,1680
if the message is super

1800
00:55:35,060 --> 00:55:36,140
0,450 450,630 630,840 840,1020 1020,1080
small,| like maybe only a
|可能只有几十个字节，

1801
00:55:36,140 --> 00:55:38,930
0,180 180,510 510,1170 1200,2220 2340,2790
few dozen bytes,| then {}
|然后，它可以在没有任何复制的情况下在寄存器中传递，

1802
00:55:38,930 --> 00:55:39,980
0,120 120,240 240,360 360,870 870,1050
it can be passed in

1803
00:55:39,980 --> 00:55:41,780
0,510 510,930 930,1110 1110,1650 1650,1800
registers without any copy at

1804
00:55:41,780 --> 00:55:42,720
0,420
all,|
|

1805
00:55:43,370 --> 00:55:44,700
0,720

1806
00:55:45,270 --> 00:55:46,260
0,240 240,330 330,480 480,630 630,990
what you might call zero
你可以称之为零拷贝。

1807
00:55:46,260 --> 00:55:47,400
0,570
copy.|
|

1808
00:55:49,810 --> 00:55:51,580
0,540 540,630 630,1020 1020,1230 1230,1770
Remember the send only proceeds
请记住，只有当 P2 已经处于 recv 状态时， send 才会继续，

1809
00:55:51,580 --> 00:55:53,170
0,540 540,810 840,1170 1170,1290 1290,1590
if the P2 is already

1810
00:55:53,170 --> 00:55:55,390
0,90 90,570 570,810 1380,1890 1890,2220
in recv| and send basically
|send 直接跳转到 P2 ，

1811
00:55:55,390 --> 00:55:57,220
0,270 270,600 600,690 690,1290 1380,1830
jumps directly to P2,| well
|这条通过内核的代码路径

1812
00:55:57,250 --> 00:55:58,660
0,420 420,870 870,1170 1170,1320 1320,1410
this code path to the

1813
00:55:58,660 --> 00:56:01,360
0,570 870,1260 1260,1890 1950,2190 2190,2700
kernel| takes care to not
|注意不会干扰一堆寄存器，

1814
00:56:01,360 --> 00:56:03,550
0,750 750,840 840,1050 1050,1140 1140,2190
disturb a bunch of registers|
|

1815
00:56:03,790 --> 00:56:04,840
0,450 450,600 600,720 720,900 900,1050
{} and that means that
这意味着 P1 可以把它的系统调用，

1816
00:56:04,840 --> 00:56:05,770
0,180 180,480 480,600 600,780 780,930
{P1 -} can put its

1817
00:56:05,770 --> 00:56:07,390
0,300 300,630 660,1080 1110,1290 1290,1620
system call,| if the message
|如果消息很短，

1818
00:56:07,390 --> 00:56:08,500
0,60 60,510 600,840 840,930 930,1110
is short,| it can put
|它可以把消息放在某些指定的寄存器中，

1819
00:56:08,500 --> 00:56:11,080
0,60 60,570 570,840 840,1440 1620,2580
the message in certain designated

1820
00:56:11,080 --> 00:56:12,670
0,600 600,690 690,990 990,1500 1500,1590
registers,| the kernel guarantees to
|内核保证在 P2 之前保留这些寄存器，

1821
00:56:12,670 --> 00:56:15,250
0,420 420,660 660,1620 1980,2310 2310,2580
preserve those registers {} on

1822
00:56:15,250 --> 00:56:15,940
0,120 120,270 270,390 390,480 480,690
its way up to {P2

1823
00:56:15,940 --> 00:56:17,050
0,300 300,390 390,540 540,840 840,1110
-}| and that means that,|
|这意味着，|

1824
00:56:17,140 --> 00:56:18,200
0,750

1825
00:56:18,370 --> 00:56:20,650
0,330 330,390 390,960 1410,2100 2100,2280
when the kernel returns from
当内核作为 send 的结果从 recv 系统调用返回时，

1826
00:56:20,650 --> 00:56:22,030
0,90 90,510 510,810 810,1170 1170,1380
the recv system call {}

1827
00:56:22,270 --> 00:56:23,440
0,240 240,270 270,600 600,690 690,1170
as a result of send,|
|

1828
00:56:23,680 --> 00:56:25,990
0,240 240,780 780,870 870,1440 1470,2310
the contents of those designated
这些指定寄存器的内容保存了那个消息，

1829
00:56:25,990 --> 00:56:28,570
0,600 630,990 990,1080 1080,1800 2130,2580
registers hold the message| and
|根本不需要从一个内存复制到另一个内存，

1830
00:56:28,630 --> 00:56:29,620
0,420 420,690 690,840 840,900 900,990
therefore never had to be

1831
00:56:29,620 --> 00:56:30,880
0,390 390,510 510,750 750,900 900,1260
copied at all from memory

1832
00:56:30,880 --> 00:56:32,620
0,120 120,600 1020,1560 1560,1680 1680,1740
to memory,| never had to
|根本不用移动，

1833
00:56:32,620 --> 00:56:33,310
0,90 90,330 330,420 420,540 540,690
be moved at all,| they're
|它们只是在寄存器中，

1834
00:56:33,310 --> 00:56:34,150
0,180 180,450 450,690 690,780 780,840
just sitting right in the

1835
00:56:34,150 --> 00:56:35,140
0,540 540,690 690,780 780,870 870,990
registers,| where they can be
|在那里它们可以非常快地被访问。

1836
00:56:35,140 --> 00:56:36,880
0,510 510,750 750,1290
accessed very quickly.|
|

1837
00:56:37,110 --> 00:56:38,360
0,660

1838
00:56:38,770 --> 00:56:39,640
0,360 360,510 510,720 720,810 810,870
{} And this you know
这当然只适用于小信息，

1839
00:56:39,640 --> 00:56:40,750
0,390 390,540 540,750 750,840 840,1110
{of,course} only works for small

1840
00:56:40,750 --> 00:56:44,140
0,720 1230,1770 1950,2370 2370,2670 2670,3390
messages,| for very large messages,
|对于非常大的消息， L4 可以在 IPC 消息中携带页面映射，

1841
00:56:45,150 --> 00:56:46,590
0,270 270,540 540,660 660,1350 1350,1440
{L4 -} can carry a

1842
00:56:46,590 --> 00:56:49,200
0,540 540,1200 1320,1500 1500,2100 2100,2610
page mapping in IPC message,|
|

1843
00:56:49,200 --> 00:56:51,620
0,180 180,450 480,960 960,1950
so for huge messages,|
所以对于巨大的信息来说，|

1844
00:56:52,100 --> 00:56:53,420
0,750

1845
00:56:53,600 --> 00:56:54,650
0,180 180,420 420,510 510,960 960,1050
{you,know} like the result of
比如从文件里读取块之类的结果，

1846
00:56:54,650 --> 00:56:55,580
0,300 300,390 390,690 690,840 840,930
reading a block from a

1847
00:56:55,580 --> 00:56:58,200
0,330 330,390 390,1020 1200,1740
file or something {},|
|

1848
00:56:59,840 --> 00:57:01,010
0,150 150,240 240,720 750,1080 1080,1170
you could just send the
你可以只发送将映射到目标地址空间的页面，

1849
00:57:01,010 --> 00:57:02,180
0,390 390,510 510,630 630,990 990,1170
pages will be mapped into

1850
00:57:02,180 --> 00:57:04,040
0,90 90,450 450,720 720,1080 1080,1860
the target address space,| again
|同样不需要任何复制。

1851
00:57:04,190 --> 00:57:05,960
0,480 480,630 630,1230
without any copy.|
|

1852
00:57:06,390 --> 00:57:07,650
0,180 180,330 330,510 510,750 750,1260
And so it's done through
所以它是通过页面映射来完成的，

1853
00:57:07,860 --> 00:57:10,770
0,510 510,990 1470,2130 2130,2220 2220,2910
page mapping,| {give,away} the page|
|提供页面，|

1854
00:57:11,540 --> 00:57:13,920
0,360 390,840 840,960 960,1830
or access {[] -},
或提供访问权限以共享页面。

1855
00:57:14,620 --> 00:57:16,390
0,450 450,570 570,900 1350,1710 1710,1770
access to this permission to

1856
00:57:16,390 --> 00:57:17,880
0,300 300,360 360,900
share the page.|
|

1857
00:57:18,390 --> 00:57:19,620
0,150 150,330 330,780 780,1140 1140,1230
And so small messages are
所以小消息是快的，

1858
00:57:19,620 --> 00:57:21,870
0,480 960,1530 1530,1980 1980,2070 2070,2250
fast,| huge messages are pretty
|大消息也是相当快的，

1859
00:57:21,870 --> 00:57:22,920
0,510 510,720 720,900 900,990 990,1050
fast,| you still have to
|你仍然需要根据目标调整页表，

1860
00:57:22,920 --> 00:57:24,060
0,420 420,480 480,780 780,1050 1050,1140
adjust the page table to

1861
00:57:24,060 --> 00:57:25,650
0,360 360,600 840,1140 1140,1290 1290,1590
target,| but that's much faster
|但这比复制要快得多。

1862
00:57:25,650 --> 00:57:28,230
0,90 90,630 1530,1770 1770,2160 2160,2580
than copying.| And final trick
|L4 玩的最后一个把戏是，

1863
00:57:28,230 --> 00:57:30,150
0,210 210,330 330,600 600,1140 1170,1920
that {L4 -} played was|
|

1864
00:57:30,270 --> 00:57:33,090
0,780 780,1200 2190,2490 2490,2610 2610,2820
noticing that if you're doing
注意，如果你正在对请求和响应执行 RPC ，

1865
00:57:33,090 --> 00:57:34,200
0,90 90,570 570,660 660,750 750,1110
an RPC with the request

1866
00:57:34,200 --> 00:57:36,270
0,120 120,720 840,990 990,1200 1200,2070
and response,| are very stylized
|是非常程式化的对等的系统调用，

1867
00:57:36,270 --> 00:57:39,360
0,870 870,1500 1770,2640
peers of {}

1868
00:57:40,340 --> 00:57:42,620
0,750 1230,1680 1680,2040 2040,2160 2160,2280
{} system calls| and you
|你也可以将系统调用合并起来，

1869
00:57:42,620 --> 00:57:44,210
0,120 120,240 240,390 390,1080 1170,1590
may as well combine system

1870
00:57:44,210 --> 00:57:45,920
0,690 720,1020 1020,1110 1110,1440 1440,1710
calls| send and recv system
|合并 send 和 recv 系统调用，以减少内核穿越，

1871
00:57:45,920 --> 00:57:47,810
0,360 360,450 450,750 750,1230 1410,1890
calls in order to reduce

1872
00:57:47,810 --> 00:57:50,000
0,330 330,840 840,1290 1740,2040 2040,2190
kernel crossing,| so {} for
|所以，对于 RPC 的特殊情况，

1873
00:57:50,000 --> 00:57:51,260
0,180 180,510 510,660 660,720 720,1260
the special case of RPC,|
|

1874
00:57:51,260 --> 00:57:52,320
0,210 210,600
which is
这几乎总是人们在做的事情，

1875
00:57:52,320 --> 00:57:54,270
0,450 450,840 840,1140 1590,1860 1860,1950
almost always what people are

1876
00:57:54,270 --> 00:57:56,580
0,660 1230,1530 1530,1620 1620,1830 1830,2310
doing,| when they're using IPC,|
|当他们使用 IPC 时，|

1877
00:57:56,580 --> 00:57:58,140
0,120 120,240 240,330 330,1140 1170,1560
there was a call system
这里有一个 call 系统调用，

1878
00:57:58,140 --> 00:57:59,200
0,540
call,|
|

1879
00:58:00,790 --> 00:58:02,050
0,210 210,270 270,630 630,780 780,1260
and the call was basically
call 基本上是 send 加 recv 的组合，

1880
00:58:02,050 --> 00:58:05,000
0,90 90,930 1350,2340
{} combined send

1881
00:58:05,090 --> 00:58:07,000
0,480 480,1380
plus receive,|
|

1882
00:58:08,640 --> 00:58:09,750
0,360 360,630 630,720 720,1050 1050,1110
but without the return to
但是没有返回到用户空间，

1883
00:58:09,750 --> 00:58:11,880
0,270 270,930 930,1080 1080,1530
user space,| and then
|然后重新进入内核空间，

1884
00:58:11,880 --> 00:58:13,260
0,210 210,480 480,630 630,960 960,1380
{re-entry -} into kernel space,|
|

1885
00:58:13,260 --> 00:58:14,220
0,180 180,270 270,540 540,630 630,960
that a pair of system
这是一对系统调用执行的，

1886
00:58:15,710 --> 00:58:18,350
0,540 630,1380 1590,2160 2280,2550 2550,2640
calls take,| {} on the
|在服务器端，

1887
00:58:18,350 --> 00:58:19,640
0,300 300,750 750,870 870,1110 1110,1290
server side,| there was a
|只有一个调用，

1888
00:58:19,640 --> 00:58:20,760
0,570
{

1889
00:58:21,030 --> 00:58:22,350
0,510 510,600 600,900 900,1200 1200,1320
-} a single call| that
|可以发送来自一个系统调用的应答，

1890
00:58:22,350 --> 00:58:25,080
0,270 330,990 990,1110 1110,2040 2130,2730
would send the reply {}

1891
00:58:25,110 --> 00:58:27,390
0,810 870,1290 1290,1680 1680,2160 2160,2280
from one system call| and
|然后等待来自任何人的下一次系统调用的请求消息。

1892
00:58:27,390 --> 00:58:29,800
0,360 390,1380 1380,1860
then wait for

1893
00:58:30,190 --> 00:58:32,080
0,210 210,330 330,810 810,1440 1680,1890
{} the request message from

1894
00:58:32,080 --> 00:58:33,520
0,540 540,690 690,810 810,1080 1080,1440
anyone for the next system

1895
00:58:33,520 --> 00:58:34,420
0,330
call.|
|

1896
00:58:34,690 --> 00:58:35,500
0,150 150,270 270,360 360,750 750,810
And this is basically a
这是一个回应的发送，

1897
00:58:35,500 --> 00:58:37,990
0,510 510,840 1140,1470 1470,2160 2160,2490
send of one response,| but
|但是等待接收下一个请求，

1898
00:58:38,170 --> 00:58:39,760
0,570 570,660 660,1230 1260,1350 1350,1590
wait to receive the next

1899
00:58:39,760 --> 00:58:41,500
0,660 840,1080 1080,1200 1200,1560 1560,1740
request,| and this again cut
|这又一次将内核穿越的数量减少了一半，

1900
00:58:41,500 --> 00:58:42,250
0,90 90,390 390,450 450,660 660,750
in half the number of

1901
00:58:42,250 --> 00:58:45,370
0,270 270,1020 2250,2670 2670,2790 2790,3120
kernel crossings| and it turned
|事实证明，

1902
00:58:45,370 --> 00:58:46,960
0,210 210,510 630,960 960,1200 1200,1590
out that,| {} the sum
|所有这些优化的总和，

1903
00:58:46,960 --> 00:58:49,690
0,150 150,420 420,510 510,1500 1800,2730
of all of these {optimizations

1904
00:58:49,690 --> 00:58:50,890
0,210 240,570 570,720 720,810 810,1200
-},| now for the kind
|现在对于较短的 RPC ，

1905
00:58:50,890 --> 00:58:52,900
0,390 450,840 840,990 990,1530 1530,2010
of short {RPCs -}| which
|它是一个典型的工作负载，

1906
00:58:52,930 --> 00:58:53,820
0,450
{

1907
00:58:54,360 --> 00:58:56,490
0,600 690,1140 1320,1470 1470,1770 1770,2130
-} are {you,know} one typical

1908
00:58:56,490 --> 00:58:58,710
0,720 870,1290 1290,1560 1560,1920 1920,2220
workload,| all this led to
|所有这些会导致加速 20 倍。

1909
00:58:58,710 --> 00:59:00,660
0,540
a

1910
00:59:00,770 --> 00:59:02,700
0,510 510,690 690,1350
{20x -} speedup.|
|

1911
00:59:02,990 --> 00:59:04,250
0,300 300,390 390,600 600,840 900,1260
This is what their paper
这是他们的论文所说的，

1912
00:59:04,250 --> 00:59:05,600
0,390 390,630 630,780 780,1140 1140,1350
reported,| {20x -} speedup over
|比以前的系统快了 20 倍，

1913
00:59:05,600 --> 00:59:07,010
0,180 180,570 570,930 930,1110 1110,1410
there previous system,| which was
|大概有点像我在之前的设计中展示的。

1914
00:59:07,430 --> 00:59:08,630
0,660 660,720 720,870 870,990 990,1200
presumably a little bit more

1915
00:59:08,630 --> 00:59:09,560
0,210 210,330 330,390 390,750 750,930
like what I showed in

1916
00:59:09,560 --> 00:59:11,460
0,330 360,810 810,1320
a previous design.|
|

1917
00:59:11,680 --> 00:59:12,700
0,510

1918
00:59:12,880 --> 00:59:13,480
0,180 180,270 270,420 420,540 540,600
And so this was an
所以这是一个令人印象深刻的，

1919
00:59:13,480 --> 00:59:14,860
0,840
impressive,|
|

1920
00:59:15,980 --> 00:59:17,090
0,210 210,510 510,780 780,990 990,1110
{} this paper came out
这篇论文是在几年前由一些相同的作者发表的，

1921
00:59:17,090 --> 00:59:18,260
0,150 180,360 360,600 600,960 960,1170
a few years before the

1922
00:59:18,470 --> 00:59:19,400
0,360 420,630 630,690 690,750 750,930
by some of the same

1923
00:59:19,400 --> 00:59:20,720
0,510 510,780 780,930 930,1080 1080,1320
authors,| but few years before
|但在人们阅读之前的几年，

1924
00:59:20,720 --> 00:59:22,040
0,60 60,300 300,420 420,720 720,1320
the people were reading,| and
|这让人们对微内核有了更多的好感。

1925
00:59:22,040 --> 00:59:23,990
0,150 150,480 480,780 780,1110 1530,1950
this caused people to {}

1926
00:59:24,950 --> 00:59:26,120
0,390 390,690 690,960 960,1020 1020,1170
view micro kernels a little

1927
00:59:26,120 --> 00:59:27,500
0,90 90,270 270,870
bit more favorably.|
|

1928
00:59:27,780 --> 00:59:29,130
0,180 180,450 450,840 840,1080 1080,1350
{} The IPC could actually
IPC 是可以相当快的。

1929
00:59:29,130 --> 00:59:30,720
0,240 240,510 510,1020
be quite fast.|
|

1930
00:59:32,240 --> 00:59:34,220
0,180 180,600 600,930 930,1170
Any questions about {}
关于 L4 玩的这些 IPC 技巧，有什么问题吗？

1931
00:59:34,540 --> 00:59:35,980
0,180 180,480 480,690 690,1200 1200,1440
these {IPC -} tricks that

1932
00:59:36,460 --> 00:59:37,980
0,360 360,990
L4 plays?|
|

1933
00:59:39,340 --> 00:59:40,390
0,300 300,540 570,750 750,990 990,1050
Yeah, I I think I
是的，我想我错过了这个，

1934
00:59:40,390 --> 00:59:41,950
0,300 300,600 600,870 900,1170 1170,1560
missed this,| but, {} when
|但是，当进程发送有接收消息时，

1935
00:59:41,950 --> 00:59:44,140
0,120 120,210 210,1020 1050,1560 1680,2190
is a process {} sending

1936
00:59:44,140 --> 00:59:47,050
0,330 330,510 540,1290 1590,2580 2760,2910
there are receiving messages,| like
|它什么时候在使用那个系统调用？

1937
00:59:47,050 --> 00:59:48,010
0,210 210,300 300,450 450,720 720,960
when is it using that

1938
00:59:48,010 --> 00:59:49,240
0,300 300,690
system call?|
|

1939
00:59:50,200 --> 00:59:51,850
0,300 300,660 660,1020 1080,1500 1500,1650
Okay, actually, so for {RPCs
好的，实际上，对于 RPC ，对于请求响应，

1940
00:59:51,850 --> 00:59:54,130
0,540 540,690 690,1080 1080,1980 2010,2280
-}, for request response,| in
|事实上，进程使用这对系统调用，

1941
00:59:54,130 --> 00:59:55,240
0,480
fact,

1942
00:59:55,860 --> 00:59:58,290
0,420 420,930 930,1140 1140,1710 1890,2430
in fact, the the processes

1943
00:59:58,290 --> 01:00:00,200
0,210 210,390 390,780 780,1350
use this pair of

1944
01:00:00,430 --> 01:00:01,960
0,180 180,480 480,1110 1140,1380 1380,1530
of system calls| rather than
|而不是 send 和 recv 。

1945
01:00:01,960 --> 01:00:04,420
0,360 360,930 1380,1890
{send,and} secv {}.|
|

1946
01:00:04,420 --> 01:00:05,980
0,120 120,330 330,990
So yeah, call
所以，是的， call 有两个参数，

1947
01:00:06,040 --> 01:00:07,330
0,360 360,510 510,690 690,840 840,1290
you really get two arguments,|
|

1948
01:00:07,330 --> 01:00:07,930
0,30 30,330 330,420 420,540 540,600
{} message you want to
你要发送的消息和放置响应的位置，

1949
01:00:07,930 --> 01:00:09,730
0,690 840,1290 1290,1380 1380,1710 1710,1800
send and a place to

1950
01:00:09,730 --> 01:00:12,010
0,360 360,540 540,1470 1590,1800 1800,2280
put the response| and inside
|在内核内部，只是将这两者结合起来，

1951
01:00:12,010 --> 01:00:13,120
0,60 60,360 360,540 540,960 960,1110
the kernel just combines these

1952
01:00:13,120 --> 01:00:14,470
0,150 450,870 870,1110 1110,1200 1200,1350
two,| {} you could view
|你可以认为这是一种 hack ，

1953
01:00:14,470 --> 01:00:14,950
0,150 150,210 210,270 270,390 390,480
this is a bit of

1954
01:00:14,950 --> 01:00:17,140
0,60 60,420 420,660 1080,1650
a hack,| but {}
|但由于 IPC 非常频繁，

1955
01:00:17,230 --> 01:00:19,510
0,900 900,1290 1290,1410 1410,1680 1680,2280
because IPC is so frequent,|
|

1956
01:00:20,160 --> 01:00:21,660
0,210 210,750 750,1200 1200,1380 1380,1500
it's worth a little bit
它值得使用一些 hack 来让它更快。

1957
01:00:21,660 --> 01:00:22,530
0,60 60,420 420,510 510,600 600,870
of hack {} in order

1958
01:00:22,530 --> 01:00:23,360
0,150
to

1959
01:00:23,690 --> 01:00:25,160
0,90 90,300 300,420 420,900
{} make it fast.|
|

1960
01:00:25,340 --> 01:00:27,110
0,180 180,300 300,480 480,1140 1170,1770
And in the diagram up
在上面的图表里，在方框中，

1961
01:00:27,110 --> 01:00:28,520
0,300 300,480 480,570 570,960 960,1410
there, in the box,| where
|你让 P2 运行 recv 系统调用，

1962
01:00:28,550 --> 01:00:29,630
0,270 270,420 420,570 570,750 750,1080
{} you have {P2 -}

1963
01:00:29,630 --> 01:00:31,250
0,360 360,630 630,930 1140,1440 1440,1620
sending that are running the

1964
01:00:31,250 --> 01:00:34,130
0,420 420,750 750,1140 1260,2010 2520,2880
recv system call,| why, what
|是什么促使 P2 。

1965
01:00:34,130 --> 01:00:37,160
0,450 450,630 630,930 930,1350
prompted {P2 -} to.|
|

1966
01:00:37,280 --> 01:00:38,870
0,510 510,870 870,1260 1260,1410 1410,1590
{Okay,it} in {} in my
好的，在我的 RPC 世界里，

1967
01:00:38,870 --> 01:00:40,730
0,600 600,1260 1320,1500 1500,1590 1590,1860
RPC world,| {} we got,
|我们有客户端，

1968
01:00:40,760 --> 01:00:42,560
0,150 150,300 300,1290
we have clients,|
|

1969
01:00:43,840 --> 01:00:45,250
0,180 180,330 330,690 690,1290 1290,1410
and they're sending requests to
它们向服务器发送请求，

1970
01:00:45,250 --> 01:00:46,780
0,990
servers,|
|

1971
01:00:47,480 --> 01:00:48,980
0,900

1972
01:00:49,940 --> 01:00:50,540
0,150 150,210 210,420 420,480 480,600
and the server is going
服务器将做一些回应，

1973
01:00:50,540 --> 01:00:51,710
0,60 60,210 210,450 450,720 720,1170
to do something in reply,|
|

1974
01:00:51,710 --> 01:00:53,360
0,300 750,1140 1140,1500 1500,1590 1590,1650
so since P2 is the
所以既然 P2 是服务器，

1975
01:00:53,360 --> 01:00:54,800
0,330 330,450 450,900 900,1050 1050,1440
server,| we imagine that P2
|我们想象 P2 处于 while 循环中，

1976
01:00:54,800 --> 01:00:55,730
0,90 90,390 390,480 480,600 600,930
is sitting in a while

1977
01:00:55,730 --> 01:00:57,440
0,450 480,600 600,930 1350,1500 1500,1710
loop,| in which, in which
|它将从任何客户端接收下一条消息，

1978
01:00:57,440 --> 01:00:58,430
0,210 210,510 510,570 570,930 930,990
it's going to receive the

1979
01:00:58,430 --> 01:00:59,930
0,180 180,510 510,660 660,900 900,1500
next message from any client,|
|

1980
01:00:59,990 --> 01:01:00,680
0,270 270,300 300,480 480,600 600,690
do a little bit of
做一点工作来处理它，

1981
01:01:00,680 --> 01:01:01,640
0,270 270,330 330,750 750,900 900,960
work to process it,| you
|在数据库中查找一些数据或其他操作，

1982
01:01:01,640 --> 01:01:02,450
0,150 150,330 330,450 450,570 570,810
know look up some data

1983
01:01:02,450 --> 01:01:03,350
0,90 90,120 120,540 540,630 630,900
in a database or something,|
|

1984
01:01:03,350 --> 01:01:04,460
0,90 90,240 240,420 420,480 480,1110
and then send a reply|
然后发送回复，|

1985
01:01:04,490 --> 01:01:05,090
0,180 180,240 240,450 450,540 540,600
and go back to the
返回到循环的顶部并再次等待，

1986
01:01:05,090 --> 01:01:05,930
0,270 270,360 360,450 450,720 720,840
top of the loop and

1987
01:01:05,930 --> 01:01:07,490
0,210 210,660 870,1230 1290,1530 1530,1560
wait again,| so to {}
|所以最接近的情况是，

1988
01:01:07,490 --> 01:01:10,400
0,210 210,1200 1200,1380 1380,2130 2130,2910
first [approximation],| we expect P2
|我们希望 P2 会把所有的时间都花在等待来自任何人的下一条消息上，

1989
01:01:10,520 --> 01:01:13,580
0,390 390,660 660,810 810,1380 1560,3060
spends all its time waiting

1990
01:01:14,000 --> 01:01:15,080
0,150 150,210 210,450 450,900 900,1080
for the next message from

1991
01:01:15,080 --> 01:01:16,790
0,420 780,960 960,1080 1080,1530 1530,1710
anyone,| that can request from
|可以从任何人那里请求。

1992
01:01:16,790 --> 01:01:17,700
0,300
anyone.|
|

1993
01:01:19,170 --> 01:01:22,000
0,510 510,960 960,1380 1380,1890
And this design really,|
这个设计确实，|

1994
01:01:22,210 --> 01:01:23,380
0,510

1995
01:01:23,560 --> 01:01:24,910
0,360 360,690 690,900 900,960 960,1350
it does kind of rely
它有点依赖于 P2 ，

1996
01:01:24,910 --> 01:01:26,860
0,150 150,540 540,1290 1470,1680 1680,1950
on P2 always| and when
|当它在其他时间，

1997
01:01:26,860 --> 01:01:28,300
0,120 120,300 300,750 750,1080 1080,1440
it's at rest,| basically sitting
|就是在内核中，

1998
01:01:28,300 --> 01:01:29,260
0,90 90,180 180,720 750,900 900,960
in the kernel| in a
|在一个 recv 系统调用上，等待下一个请求，

1999
01:01:29,260 --> 01:01:32,680
0,420 420,690 690,1170 1200,2370 3150,3420
recv system call waiting for

2000
01:01:32,680 --> 01:01:33,700
0,60 60,300 300,780 780,900 900,1020
the next request,| so that
|所以下一个请求可以直接从该系统调用返回。

2001
01:01:33,700 --> 01:01:37,450
0,90 90,420 420,1320 1440,2220 2310,3750
the next request can directly

2002
01:01:37,750 --> 01:01:39,580
0,480 480,1080 1080,1230 1230,1470 1470,1830
basically return from that system

2003
01:01:39,580 --> 01:01:40,500
0,450
call.|
|

2004
01:01:40,560 --> 01:01:42,150
0,150 150,360 360,480 480,900 900,1590
And that's the fast path,|
这是一条捷径，|

2005
01:01:42,210 --> 01:01:44,070
0,510 540,1020 1020,1530 1530,1680 1680,1860
that's super efficient in this
在这个设计中是非常高效的。

2006
01:01:44,070 --> 01:01:46,820
0,480
design.|
|

2007
01:01:48,560 --> 01:01:49,580
0,270 270,450 450,570 570,900 900,1020
Sorry, just to follow up
抱歉，我只是想跟进一下，

2008
01:01:49,580 --> 01:01:51,410
0,90 90,420 960,1260 1260,1470 1470,1830
on that,| that means that,|
|也就是说，|

2009
01:01:51,800 --> 01:01:52,910
0,390 390,600 600,750 750,990 990,1110
{} you said that it
你说它来自 P1 返回 P2 ，

2010
01:01:52,910 --> 01:01:54,110
0,210 210,390 390,540 540,900 900,1200
goes from {P1 -} and

2011
01:01:54,110 --> 01:01:55,920
0,480 480,600 600,1230
returns to P2,|
|

2012
01:01:55,950 --> 01:01:57,210
0,210 210,450 450,600 600,780 780,1260
so like to come back,|
所以想要回来，|

2013
01:01:57,330 --> 01:01:58,680
0,150 150,300 300,570 570,900 930,1350
you would need to send
你需要回复，所以。

2014
01:01:58,680 --> 01:02:01,170
0,60 60,930 1080,1620 2190,2400 2400,2490
a response, so.| That's right,
|是的，我们希望 P2 会发送一个响应，

2015
01:02:01,170 --> 01:02:02,790
0,150 150,510 510,690 690,1080 1080,1620
we expect {P2 -} to

2016
01:02:03,810 --> 01:02:05,540
0,300 300,360 360,1290
send a response,|
|

2017
01:02:05,540 --> 01:02:06,890
0,390 600,840 840,1230 1230,1290 1290,1350
and that sending of the
并且响应的发送反向遵循基本相同的代码路径，

2018
01:02:06,890 --> 01:02:08,570
0,390 390,630 630,1170 1170,1590 1590,1680
response actually follows basically the

2019
01:02:08,570 --> 01:02:10,250
0,240 240,510 510,900 1050,1170 1170,1680
same code path in reverse,|
|

2020
01:02:10,250 --> 01:02:11,240
0,180 180,360 360,690 690,930 930,990
that when P2 sends a
当 P2 发送响应时，

2021
01:02:11,240 --> 01:02:13,720
0,810
response,|
|

2022
01:02:14,240 --> 01:02:15,920
0,300 300,480 480,1080 1080,1530 1530,1680
that that effectively causes {P1
有效地使 P1 返回，

2023
01:02:15,920 --> 01:02:18,140
0,270 270,360 360,1050 1050,1740
-} to return from,|
|

2024
01:02:18,320 --> 01:02:19,430
0,90 90,390 630,720 720,900 900,1110
I mean, P1 was actually
我是说， P1 实际上是在调用 call 系统调用，

2025
01:02:19,430 --> 01:02:21,020
0,180 180,570 600,930 930,1230 1230,1590
making this call system call,|
|

2026
01:02:21,230 --> 01:02:23,030
0,480 570,780 780,1350 1350,1440 1440,1800
so the delivery of {P2's
所以， P2 响应的传递导致 call ，

2027
01:02:23,030 --> 01:02:25,460
0,120 120,1140 1410,1980 1980,2040 2040,2430
-} response causes the call,|
|

2028
01:02:25,490 --> 01:02:26,900
0,120 120,480 480,630 630,1110 1230,1410
the return from this from
返回从这个系统调用回到 P1 。

2029
01:02:26,900 --> 01:02:27,980
0,180 180,510 510,750 750,960 960,1080
this system call back into

2030
01:02:27,980 --> 01:02:28,880
0,330
P1.|
|

2031
01:02:29,530 --> 01:02:31,000
0,360 360,510 510,900
Okay, I see,
好的，我明白了，谢谢。

2032
01:02:31,000 --> 01:02:32,770
0,270 270,660 960,1650 1650,1710 1710,1770
thank you.| This is a
|这与通常的设置略有不同，

2033
01:02:32,770 --> 01:02:33,550
0,150 150,270 270,570 570,690 690,780
little bit different from the

2034
01:02:33,550 --> 01:02:34,840
0,300 300,600 600,780 780,900 900,1290
usual setup,| where you think
|你认为可以跳转到内核和系统调用，

2035
01:02:35,110 --> 01:02:36,760
0,360 360,600 600,780 780,1140 1290,1650
you jump into the kernel

2036
01:02:36,760 --> 01:02:37,600
0,90 90,360 360,660 660,750 750,840
and system call| and you
|你执行该系统调用，

2037
01:02:37,600 --> 01:02:38,650
0,270 270,420 420,690 690,930 930,1050
execute that system call| and
|它将返回代表 P1 的所有工作，

2038
01:02:38,650 --> 01:02:40,000
0,90 90,750 750,1080 1080,1140 1140,1350
it returns sort of all

2039
01:02:40,000 --> 01:02:41,020
0,300 300,420 420,750 750,810 810,1020
working on behalf of {P1

2040
01:02:41,020 --> 01:02:42,010
0,390 450,690 690,750 750,810 810,990
-}| which is the way
|这是管道读写工作的方式，

2041
01:02:42,010 --> 01:02:44,200
0,360 480,810 810,1110 1110,1470 1590,2190
pipe read write work,| here,
|这里，你知道 P1 进入内核，

2042
01:02:44,200 --> 01:02:45,130
0,60 60,180 180,390 390,810 810,930
you know {P1 -} is

2043
01:02:45,130 --> 01:02:47,170
0,270 270,360 360,1050 1620,1770 1770,2040
entering the kernel,| {P1 -}
|P1 进入内核，返回却是 P2 .

2044
01:02:47,170 --> 01:02:49,100
0,270 270,360 360,1110
entering the kernel,|
|

2045
01:02:49,130 --> 01:02:50,360
0,570 570,660 660,900 900,1140 1140,1230
and you know that the

2046
01:02:50,360 --> 01:02:51,380
0,360 360,540 540,630 630,780 780,1020
return goes to {P2 -},|
|

2047
01:02:53,540 --> 01:02:55,340
0,300 300,360 360,660 660,990 1350,1800
kind of odd, but very
有点奇怪，但速度很快。

2048
01:02:55,340 --> 01:02:56,380
0,540
fast.|
|

2049
01:03:02,540 --> 01:03:05,630
0,480 630,1050 2580,2850 2850,3000 3000,3090
Okay, {} so this was
好的，所以这是对人们使用微内核的一种很大的贡献，

2050
01:03:05,630 --> 01:03:07,700
0,60 60,750 780,1470 1470,1710 1710,2070
a big big sort of

2051
01:03:08,600 --> 01:03:10,910
0,690 690,810 810,1230 1530,2070 2070,2310
contribution to people taking micro

2052
01:03:10,910 --> 01:03:12,440
0,630
kernels,|
|

2053
01:03:13,780 --> 01:03:15,040
0,330 330,750 750,840 840,1020 1020,1260
people's willingness to take micro
人们愿意使用微内核

2054
01:03:15,040 --> 01:03:17,920
0,210 210,990 1440,1830 1830,2250 2250,2880
kernel| seriously as potential replacement
|作为宏内核的潜在替代品，

2055
01:03:17,920 --> 01:03:20,620
0,330 330,660 1050,1590 1590,2070 2460,2700
for a monolithic kernels {},|
|

2056
01:03:20,620 --> 01:03:22,150
0,540 540,630 630,870 870,1050 1230,1530
however you know that you
但是，你仍然需要解决这个问题，

2057
01:03:22,150 --> 01:03:23,650
0,210 210,360 360,720 750,1110 1110,1500
still have to still leave

2058
01:03:23,650 --> 01:03:24,610
0,240 240,300 300,690 690,870 870,960
[] the question,| even if
|即使 RPC 很快，

2059
01:03:24,610 --> 01:03:26,110
0,120 120,420 420,810 810,1020 1020,1500
{RPC,is -} fast,| like where
|比如你从哪里得到操作系统的其他部分，

2060
01:03:26,110 --> 01:03:26,680
0,90 90,210 210,300 300,510 510,570
you get the rest of

2061
01:03:26,680 --> 01:03:29,440
0,120 120,450 450,840 2040,2520 2520,2760
the operating system,| {like,this,kernel} only
|内核只有百分之几的所有东西，

2062
01:03:29,440 --> 01:03:30,670
0,210 210,420 420,630 630,1110 1110,1230
has a few percent of

2063
01:03:30,670 --> 01:03:31,840
0,180 180,270 270,720 720,900 900,1170
all the stuff,| like file
|比如文件系统和网络堆栈，

2064
01:03:31,840 --> 01:03:33,010
0,390 390,480 480,720 720,1050 1050,1170
systems and network stacks,| we
|我们希望使用完整的操作系统。

2065
01:03:33,010 --> 01:03:34,300
0,360 360,450 450,840 990,1230 1230,1290
expect to be in a

2066
01:03:34,300 --> 01:03:35,700
0,210 210,540 540,990
full operating system.|
|

2067
01:03:35,700 --> 01:03:36,270
0,120 120,210 210,270 270,390 390,570
What do we do about
其他的部分，我们该怎么办，

2068
01:03:36,270 --> 01:03:38,340
0,90 90,630 1470,1620 1620,1740 1740,2070
the rest| and this question
|这个问题通常在大学研究项目的背景下提出，

2069
01:03:38,340 --> 01:03:40,290
0,60 60,390 390,630 630,1320 1680,1950
is usually being asked in

2070
01:03:40,290 --> 01:03:41,790
0,60 60,510 510,600 600,930 930,1500
the context of some university

2071
01:03:41,790 --> 01:03:43,950
0,420 420,870 870,1020 1020,1710 1740,2160
research project| with relatively limited
|他们资源相对有限，

2072
01:03:43,950 --> 01:03:47,550
0,720 2940,3210 3210,3390 3390,3480 3480,3600
resources,| we need to get
|我们需要从某个地方获得所有这些用户级别的服务。

2073
01:03:47,550 --> 01:03:49,240
0,120 120,300 300,600 600,1170
all those user level

2074
01:03:49,500 --> 01:03:52,800
0,660 660,1050 1560,2070 2550,3120 3120,3300
servers {from,somewhere}.| {} Actually there
|实际上，有一些专门的应用程序，

2075
01:03:52,800 --> 01:03:55,050
0,600 720,1410 1410,1980 1980,2070 2070,2250
are specialized applications| for which
|这不是一个太大的问题，

2076
01:03:55,050 --> 01:03:55,920
0,180 180,450 450,600 600,780 780,870
that's not too much of

2077
01:03:55,920 --> 01:03:57,930
0,90 90,510 510,750 750,1050 1380,2010
a problem,| if we're running
|如果我们运行的是某种设备，控制器，

2078
01:03:57,930 --> 01:03:59,490
0,240 720,900 900,1080 1080,1320 1320,1560
{} you know some sort

2079
01:03:59,490 --> 01:04:01,110
0,150 240,690 690,780 780,960 960,1620
of device you know controller,|
|

2080
01:04:01,110 --> 01:04:02,430
0,90 90,330 330,630 750,1020 1020,1320
or maybe the you know
或者你的车的点火控制系统，

2081
01:04:03,250 --> 01:04:05,260
0,300 300,1170 1170,1560 1560,1920 1920,2010
{} ignition control system for

2082
01:04:05,260 --> 01:04:07,660
0,150 150,720 720,1140 1350,2070 2070,2400
your car,| that is only
|这只运行了几千行代码，

2083
01:04:07,660 --> 01:04:08,740
0,300 300,390 390,570 570,870 870,1080
running a few thousand lines

2084
01:04:08,740 --> 01:04:09,880
0,60 60,300 300,690 690,930 930,1140
of code anyway,| maybe just
|可能只需要一个文件系统，

2085
01:04:09,880 --> 01:04:11,650
0,180 180,240 240,510 510,1020 1140,1770
need a file system {},|
|

2086
01:04:12,340 --> 01:04:13,090
0,210 210,300 300,390 390,510 510,750
then we can get away
然后，我们可以在用户级别使用很少的东西，

2087
01:04:13,090 --> 01:04:14,200
0,300 300,570 570,780 780,1050 1050,1110
with very little stuff at

2088
01:04:14,200 --> 01:04:16,120
0,270 270,630 630,990 1020,1320 1320,1920
user level| and micro kernels
|微内核对于这类应用来说完全是有意义的，

2089
01:04:16,240 --> 01:04:17,740
0,630 630,840 840,1230 1230,1380 1380,1500
totally makes sense for that

2090
01:04:17,740 --> 01:04:19,720
0,120 120,180 180,780 1110,1560 1680,1980
kind of application,| but but
|但是人们，

2091
01:04:19,720 --> 01:04:21,020
0,150 300,840
the people,|
|

2092
01:04:21,140 --> 01:04:22,160
0,210 210,270 270,420 420,600 600,1020
you know when these projects
当这些项目真的有目标的时候，

2093
01:04:22,160 --> 01:04:23,480
0,300 300,450 450,570 570,1170 1170,1320
really they had ambitions,| that
|使用它完全取代现有的操作系统，

2094
01:04:23,600 --> 01:04:25,310
0,420 600,810 810,900 900,1230 1230,1710
{oh,gosh} going to totally replace

2095
01:04:25,310 --> 01:04:27,950
0,690 1050,1500 1500,2010 2010,2220 2340,2640
existing operating systems,| and they
|他们希望能构建一些东西，

2096
01:04:27,950 --> 01:04:29,030
0,510 510,660 660,750 750,870 870,1080
hoped that they could build

2097
01:04:29,030 --> 01:04:30,020
0,270 270,390 390,660 660,810 810,990
something,| that people would want
|人们想要在他们的工作站上运行的东西，

2098
01:04:30,020 --> 01:04:31,070
0,60 60,360 360,510 510,930 930,1050
to run on their on

2099
01:04:31,070 --> 01:04:32,720
0,300 330,1260 1260,1350 1350,1560 1560,1650
their workstations| and run on
|在他们的服务器上运行，无处不在，

2100
01:04:32,720 --> 01:04:34,250
0,120 120,570 570,690 690,1170 1170,1530
their servers and everywhere,| just
|完全替换大的宏内核，

2101
01:04:34,400 --> 01:04:36,590
0,690 690,870 870,1320 1320,1650 1650,2190
replace big monolithic kernels altogether,|
|

2102
01:04:37,100 --> 01:04:38,330
0,480 480,690 690,810 810,1110 1110,1230
and but for that you
但是要做到这一点，你需要一个真正的，

2103
01:04:38,330 --> 01:04:39,320
0,90 90,270 270,570 570,660 660,990
know you need a real,|
|

2104
01:04:39,320 --> 01:04:40,250
0,90 90,210 210,450 450,540 540,930
you need all the stuff
你需要操作系统所能做的所有东西。

2105
01:04:40,250 --> 01:04:41,660
0,120 120,180 180,540 540,870 870,1410
that an operating system does.|
|

2106
01:04:42,200 --> 01:04:43,280
0,480

2107
01:04:43,280 --> 01:04:45,170
0,270 270,1020 1020,1110 1110,1470 1470,1890
One possibility, the most maybe
一种可能性，更多是一种哲学上的可能性，

2108
01:04:45,410 --> 01:04:49,640
0,240 240,300 300,1920 2070,3420 3450,4230
sort of philosophically consistent possibility|
|

2109
01:04:49,640 --> 01:04:52,370
0,210 210,420 420,870 1590,2010 2010,2730
would be to {re-implement -}
就是重新实现你需要的一切，

2110
01:04:52,400 --> 01:04:53,900
0,420 420,570 570,1140 1140,1350 1350,1500
everything you need,| but in
|而是以一种微内核的方式，

2111
01:04:53,900 --> 01:04:55,580
0,330 330,540 540,600 600,930 930,1680
a sort of micro kernel

2112
01:04:55,760 --> 01:04:57,140
0,480 480,780 780,1050 1050,1140 1140,1380
way| as lots and lots
|就像大量不同的用户级进程，

2113
01:04:57,140 --> 01:04:59,150
0,90 90,600 630,900 900,1110 1110,2010
of different user level processes,|
|

2114
01:04:59,420 --> 01:05:01,420
0,390 720,1020 1020,1170 1170,1650
{} but that's just,|
但那只是，|

2115
01:05:01,830 --> 01:05:04,710
0,510 510,990 1470,2280 2280,2700 2700,2880
actually people, {there,were} projects did
实际上人们，有很多项目都是这么做的，

2116
01:05:04,710 --> 01:05:05,820
0,180 180,330 330,510 510,540 540,1110
that,| but it's a vast
|但这是一项繁重的工作，

2117
01:05:05,820 --> 01:05:08,160
0,240 240,360 360,1050 1890,2160 2160,2340
amount of work| and more
|更具体地说，人们真的想运行，

2118
01:05:08,160 --> 01:05:09,900
0,810
specifically,

2119
01:05:09,960 --> 01:05:11,160
0,360 360,510 510,660 660,720 720,1200
people really want to run,|
|

2120
01:05:11,190 --> 01:05:12,280
0,120 120,480
you know,
为了让我使用笔记本电脑，

2121
01:05:12,280 --> 01:05:12,820
0,120 120,270 270,360 360,450 450,540
in order for me to

2122
01:05:12,820 --> 01:05:13,930
0,180 180,240 240,750 780,900 900,1110
use a laptop,| it just
|它必须运行 Emacs ，

2123
01:05:13,930 --> 01:05:16,180
0,330 330,480 480,750 780,1650 2040,2250
has to run Emacs| and
|它必须运行我最喜欢的 C 编译器，

2124
01:05:16,180 --> 01:05:17,290
0,210 210,540 540,630 630,960 960,1110
it has to run my

2125
01:05:17,290 --> 01:05:19,000
0,330 330,540 540,1170 1230,1590 1590,1710
favorite C compiler,| otherwise I'm
|否则我绝对不会切换到你们的操作系统。

2126
01:05:19,000 --> 01:05:20,230
0,420 420,840 840,1050 1050,1170 1170,1230
just definitely not going to

2127
01:05:20,230 --> 01:05:21,490
0,270 270,360 360,510 510,840 840,1260
switch to your operating system.|
|

2128
01:05:22,040 --> 01:05:23,360
0,480 570,750 750,900 900,1110 1110,1320
{} And what that meant
这意味着微内核要想获得任何形式的采用，

2129
01:05:23,360 --> 01:05:24,650
0,120 120,390 450,840 840,1200 1200,1290
is that micro kernels in

2130
01:05:24,650 --> 01:05:25,700
0,210 210,540 570,690 690,900 900,1050
order for to gain any

2131
01:05:25,700 --> 01:05:26,930
0,180 180,240 240,690 690,780 780,1230
kind of adoption,| they had
|它们必须能够支持现有的应用程序，

2132
01:05:26,930 --> 01:05:27,770
0,90 90,210 210,390 390,480 480,840
to be able to support

2133
01:05:27,770 --> 01:05:29,870
0,390 390,1320 1560,1800 1800,1950 1950,2100
existing applications,| {} they had
|它们必须能够兼容，

2134
01:05:29,870 --> 01:05:30,440
0,60 60,180 180,330 330,390 390,570
to be able to be

2135
01:05:30,440 --> 01:05:33,860
0,840 960,1500 1740,2610 2880,3090 3090,3420
compatible,| provide identical or at
|提供完全相同的或者至少在更高级别的 API 上相同的系统调用，

2136
01:05:33,860 --> 01:05:35,270
0,270 270,420 420,720 720,1110 1200,1410
least the system call at

2137
01:05:35,270 --> 01:05:39,020
0,210 360,1230 1230,2070 2340,2850 2850,3750
the higher level service API

2138
01:05:39,230 --> 01:05:40,700
0,510 510,660 660,810 810,1020 1110,1470
level,| they had to be
|它们必须完全兼容

2139
01:05:40,700 --> 01:05:42,080
0,300 300,780 780,870 870,1080 1080,1380
totally compatible with| some exist
|一些现有的操作系统，比如 Unix Linux ，

2140
01:05:42,080 --> 01:05:43,580
0,180 180,600 600,870 870,1110 1110,1500
{} operating system, like Unix

2141
01:05:43,580 --> 01:05:45,530
0,150 150,810 900,1170 1170,1590 1680,1950
like Linux,| in order for
|为了让任何人都愿意换。

2142
01:05:45,530 --> 01:05:46,490
0,390 390,510 510,630 630,870 870,960
anybody to be willing to

2143
01:05:46,490 --> 01:05:47,480
0,690
switch.|
|

2144
01:05:47,920 --> 01:05:50,110
0,300 600,810 810,1560 1560,1980 1980,2190
{} So these projects face
所以这些项目面临着一个更具体的问题，

2145
01:05:50,110 --> 01:05:51,280
0,180 210,390 390,780 780,1110 1110,1170
a more specific problem of|
|

2146
01:05:51,280 --> 01:05:51,970
0,210 210,330 330,480 480,600 600,690
how they were going to
它们将如何得到，

2147
01:05:51,970 --> 01:05:53,650
0,510 570,1350 1350,1440 1440,1560 1560,1680
get,| how are they going
|它们如何实现与现有应用程序的兼容性，

2148
01:05:53,650 --> 01:05:57,280
0,60 60,780 900,1890 2010,2760 2970,3630
to attain compatibility with existing

2149
01:05:57,280 --> 01:05:58,780
0,660 660,870 870,1020 1020,1440 1440,1500
applications| written for Linux or
|为 Linux 或 Windows 或其他平台编写的应用程序，

2150
01:05:58,780 --> 01:06:00,400
0,240 240,720 720,870 900,1290 1290,1620
maybe Windows or something,| but
|但是对于这个项目来说，是 Linux ，

2151
01:06:00,730 --> 01:06:02,170
0,540 690,840 840,990 990,1350 1350,1440
{} for this project, it

2152
01:06:02,170 --> 01:06:05,050
0,150 150,660 1800,2220 2250,2700 2700,2880
was Linux,| and rather than
|不是编写他们自己的全新的用户级服务器，

2153
01:06:05,050 --> 01:06:06,600
0,210 210,390 390,1050
write their own

2154
01:06:06,990 --> 01:06:08,070
0,390 390,600 600,780 780,840 840,1080
totally new set of user

2155
01:06:08,070 --> 01:06:09,780
0,210 210,690 690,780 780,1080 1080,1710
level servers,| they mimic Linux,
|它们模仿 Linux ，他们决定走一条更容易的路，

2156
01:06:09,810 --> 01:06:10,740
0,270 270,630 630,690 690,870 870,930
they decided to take a

2157
01:06:10,740 --> 01:06:12,930
0,660 660,990 990,1770 1800,1980 1980,2190
far easier path| and many
|很多项目都是这样做的，

2158
01:06:12,930 --> 01:06:14,610
0,390 390,540 540,810 810,990 1050,1680
projects did this,| of simply
|直接在他们的微内核上运行已有的宏内核，

2159
01:06:14,790 --> 01:06:18,870
0,780 780,1260 1260,1350 1350,2370 2550,4080
directly running an existing monolithic

2160
01:06:18,870 --> 01:06:22,020
0,570 1110,2070 2220,2640 2640,3060 3060,3150
kernel as on top of

2161
01:06:22,020 --> 01:06:23,480
0,150 150,480 480,900
their micro kernel,|
|

2162
01:06:23,930 --> 01:06:25,160
0,390 390,510 510,600 600,1080 1080,1230
instead of {re-implementing -} some
而不是重新实现一些新的东西，

2163
01:06:25,160 --> 01:06:26,840
0,180 180,540 690,930 930,1380 1500,1680
new thing| and says that's
|这正是今天论文的主题。

2164
01:06:26,840 --> 01:06:28,220
0,420 420,600 600,900 900,1260 1260,1380
exactly what today's paper is

2165
01:06:28,220 --> 01:06:31,100
0,480
about.|
|

2166
01:06:31,340 --> 01:06:33,980
0,240 240,1170 1290,2070
It has, {}
事实上， L4 微内核在底部，

2167
01:06:35,430 --> 01:06:37,230
0,630 630,780 780,990 990,1500 1500,1800
indeed, {you,know} {L4 -} micro

2168
01:06:37,230 --> 01:06:38,370
0,300 300,450 450,540 540,600 600,1140
kernel down at the bottom,|
|

2169
01:06:38,850 --> 01:06:40,340
0,900

2170
01:06:41,440 --> 01:06:42,860
0,780

2171
01:06:42,860 --> 01:06:44,720
0,270 270,900 900,1110 1110,1470 1590,1860
but also as like a
但也像一个相当大的服务器，

2172
01:06:44,720 --> 01:06:47,360
0,420 420,720 720,1470 1740,2100 2100,2640
pretty big server,| they run
|它们将完整的 Linux 内核作为用户级进程运行，

2173
01:06:47,540 --> 01:06:48,280
0,240
{}

2174
01:06:48,620 --> 01:06:51,260
0,240 390,720 720,1230 1230,1980 1980,2640
a pretty full Linux kernel

2175
01:06:51,880 --> 01:06:53,710
0,270 270,360 360,660 660,900 900,1830
as a user level process,|
|

2176
01:06:54,420 --> 01:06:55,980
0,420 570,900
and so,
这听起来可能有点令人惊讶，

2177
01:06:56,070 --> 01:06:56,730
0,150 150,240 240,450 450,480 480,660
that may sound a little

2178
01:06:56,730 --> 01:06:57,930
0,480 480,540 540,990 990,1170 1170,1200
surprising,| the {kernel,is} not a
|内核不是用户级进程，内核就是内核，

2179
01:06:57,930 --> 01:06:59,130
0,240 240,480 480,960 960,1140 1140,1200
user level process right, the

2180
01:06:59,130 --> 01:07:01,500
0,330 330,390 390,870 1800,2220 2220,2370
{kernel,is} the kernel,| you think
|你认为它是在硬件上运行的，

2181
01:07:01,500 --> 01:07:02,100
0,90 90,150 150,270 270,510 510,600
of it as running on

2182
01:07:02,100 --> 01:07:04,020
0,60 60,480 480,720 900,1410 1410,1920
the hardware,| but in fact
|但实际上 Linux 内核，

2183
01:07:04,020 --> 01:07:05,580
0,120 120,360 360,660 660,1170 1200,1560
you know Linux kernel| as
|如你所见，在 QEMU 中运行 xv6 ，

2184
01:07:05,580 --> 01:07:06,900
0,90 90,210 210,450 450,810
you can see from

2185
01:07:06,990 --> 01:07:08,040
0,330 330,540 540,660 660,990 990,1050
running {xv6 - -} in

2186
01:07:08,040 --> 01:07:09,360
0,240 240,570 570,780 780,1110 1140,1320
{QEMU -},| which is running
|就是在用户空间中运行的，

2187
01:07:09,360 --> 01:07:10,530
0,90 90,330 330,600 600,900 900,1170
in user space after all,|
|

2188
01:07:11,190 --> 01:07:12,300
0,390 390,690 690,870 870,1050 1050,1110
a kernel is just a
内核只是一个程序，

2189
01:07:12,300 --> 01:07:13,680
0,570 600,810 810,1020 1020,1230 1230,1380
program| and so with some
|所以，只要稍加修改，

2190
01:07:13,680 --> 01:07:15,720
0,1200 1260,1500 1500,1620 1620,1740 1740,2040
modifications,| it can be made
|它就可以在用户级别运行，

2191
01:07:15,720 --> 01:07:18,900
0,90 90,780 1860,2550 2550,2850 2850,3180
to run at user level,|
|

2192
01:07:19,200 --> 01:07:20,100
0,300 300,510 510,690 690,840 840,900
and so they had to
所以他们必须修改 Linux ，

2193
01:07:20,100 --> 01:07:22,230
0,420 420,930 930,1140 1320,1710 1710,2130
modify Linux| and they took
|他们在 Linux 中使用了很多低级的东西，

2194
01:07:22,230 --> 01:07:23,670
0,600 600,780 780,840 840,930 930,1440
a lot of the low-level

2195
01:07:23,670 --> 01:07:25,020
0,270 270,360 360,810 810,960 960,1350
stuff in Linux,| for example
|比如 Linux 中的代码，

2196
01:07:25,020 --> 01:07:25,890
0,90 90,180 180,480 480,570 570,870
of the code in Linux,|
|

2197
01:07:25,890 --> 01:07:26,730
0,90 90,480 480,540 540,660 660,840
that expects to be able
期望能够直接修改页表

2198
01:07:26,730 --> 01:07:28,590
0,120 120,570 570,960 960,1350 1350,1860
to directly modify page tables|
|

2199
01:07:28,590 --> 01:07:30,390
0,210 420,870 870,990 990,1230 1230,1800
or read and write processor
或读写处理器寄存器，

2200
01:07:30,390 --> 01:07:32,190
0,900 1050,1320 1320,1560 1560,1650 1650,1800
registers,| {} there were some
|他们需要修改一些低级别的东西，

2201
01:07:32,190 --> 01:07:33,210
0,450 450,690 690,810 810,930 930,1020
low-level stuff they had to

2202
01:07:33,210 --> 01:07:35,160
0,510 1020,1350 1350,1560 1560,1620 1620,1950
modify,| some parts of Linux
|Linux 的某些部分必须改变，

2203
01:07:35,160 --> 01:07:36,460
0,120 120,210 210,1050
had to change,|
|

2204
01:07:36,580 --> 01:07:37,760
0,600

2205
01:07:37,820 --> 01:07:39,740
0,120 120,390 390,840 1260,1770 1770,1920
in order to convert them
为了将它们转换为进行系统调用，

2206
01:07:39,740 --> 01:07:41,270
0,60 60,420 420,600 600,960 960,1530
to basically make system calls|
|

2207
01:07:41,270 --> 01:07:42,710
0,120 120,390 390,810 810,1290 1290,1440
or send IPC messages through
或者通过 L4 发送 IPC 消息，而不是直接访问硬件，

2208
01:07:42,710 --> 01:07:44,120
0,150 150,570 570,870 870,960 960,1410
{L4 -} instead of directly

2209
01:07:44,120 --> 01:07:46,280
0,180 180,570 840,1620 1860,2070 2070,2160
get at hardware,| but for
|但在很大程度上，

2210
01:07:46,280 --> 01:07:47,570
0,90 90,390 390,780 930,1170 1170,1290
the most part,| they were
|它们可以直接运行几乎所有 Linux ，而不需要修改，

2211
01:07:47,570 --> 01:07:48,770
0,150 150,240 240,660 660,870 870,1200
able to directly run, without

2212
01:07:48,770 --> 01:07:50,570
0,780 900,1200 1200,1560 1560,1710 1710,1800
change, {} almost all of

2213
01:07:50,570 --> 01:07:51,800
0,360 360,600 660,930 930,1110 1110,1230
Linux,| so that means they
|所以这意味着他们得到 Linux 的一部分，

2214
01:07:51,800 --> 01:07:53,330
0,210 210,390 390,750 750,840 840,1530
got as part of Linux,|
|

2215
01:07:53,390 --> 01:07:55,010
0,210 210,390 390,900 900,1530 1530,1620
you know file system and
文件系统和网络支持以及各种设备驱动程序，

2216
01:07:55,010 --> 01:07:56,900
0,240 300,990 990,1590 1590,1710 1710,1890
{} network support and all

2217
01:07:56,900 --> 01:08:00,780
0,270 270,420 570,1260 1260,2310
kinds of device drivers,|
|

2218
01:08:00,810 --> 01:08:01,890
0,270 270,450 450,720 750,870 870,1080
who knows what that comes
Linux 带来的东西，

2219
01:08:01,890 --> 01:08:03,140
0,120 120,720
with Linux,|
|

2220
01:08:03,380 --> 01:08:04,900
0,390 390,630 630,900
without having to
而不必编写他们自己的版本。

2221
01:08:04,900 --> 01:08:06,280
0,210 210,390 390,900 930,1290 1290,1380
write their own version of

2222
01:08:06,280 --> 01:08:10,240
0,480 1950,2550
this.| {You,know},
|事实上，这个设置的方式是，

2223
01:08:10,240 --> 01:08:10,870
0,60 60,270 270,330 330,450 450,630
in fact the way this

2224
01:08:10,870 --> 01:08:11,860
0,90 90,330 330,540 540,720 720,990
was set up was,| that
|Linux 内核作为一个 L4 任务运行，

2225
01:08:11,920 --> 01:08:15,280
0,930 930,1050 1050,1620 1710,2550 3030,3360
Linux, the Linux kernel ran

2226
01:08:15,280 --> 01:08:17,740
0,120 120,570 570,870 870,1320 1320,2460
as one {L4 -} task,|
|

2227
01:08:18,610 --> 01:08:20,920
0,390 420,690 690,1110 1110,2010 2040,2310
but each Linux process ran
但是每个 Linux 进程作为单独的 L4 任务运行，

2228
01:08:20,920 --> 01:08:22,600
0,150 150,210 210,990 1170,1440 1440,1680
as a separate {L4 -}

2229
01:08:22,600 --> 01:08:23,940
0,510 510,840
task,| when
|当您登录到这个 Linux 时，

2230
01:08:24,090 --> 01:08:25,350
0,210 210,450 450,600 600,810 810,1260
you log into this Linux|
|

2231
01:08:25,350 --> 01:08:25,950
0,90 90,180 180,420 420,510 510,600
and you ask it to
你让它为你运行一个 shell ，一个终端窗口或其他东西，

2232
01:08:25,950 --> 01:08:27,300
0,360 360,450 450,960 960,1200 1200,1350
run a shell for you,

2233
01:08:27,300 --> 01:08:28,650
0,90 90,510 510,810 810,870 870,1350
a terminal window or something,|
|

2234
01:08:28,770 --> 01:08:29,670
0,330 330,480 480,540 540,810 810,900
it's going to fire up
它将启动一个 L4 任务，

2235
01:08:29,670 --> 01:08:32,260
0,180 210,750 750,930 930,2070
an {L4 -} task,|
|

2236
01:08:32,260 --> 01:08:33,250
0,330 330,450 450,540 540,750 750,990
that's going to run that
它将在用户级别运行 Linux 程序，

2237
01:08:33,250 --> 01:08:35,470
0,450 450,1230 1380,1590 1590,1860 1860,2220
Linux program at user level,|
|

2238
01:08:36,760 --> 01:08:37,870
0,180 180,300 300,510 510,720 720,1110
so there were one task
所以这里 Linux 有一个任务，

2239
01:08:37,870 --> 01:08:39,280
0,120 120,540 540,630 630,870 870,1410
for Linux| and one task
|以及在 Linux 下启动的每个 Linux 进程都有一个任务，

2240
01:08:39,280 --> 01:08:41,470
0,150 180,750 780,1470 1470,2070 2070,2190
for each Linux process that

2241
01:08:41,470 --> 01:08:42,920
0,210 210,630 630,1050
you fire up

2242
01:08:43,200 --> 01:08:45,900
0,450 750,1080 1080,1470 1470,1710 1860,2700
{} under Linux| and Linux
|Linux 不是直接修改 VI 进程使用的页表，

2243
01:08:45,900 --> 01:08:47,790
0,480 480,570 570,1170 1170,1740 1740,1890
instead of directly modifying the

2244
01:08:48,210 --> 01:08:53,160
0,450 450,1230 2640,3630 3870,4500 4500,4950
page table {the,VI}, VI process

2245
01:08:53,160 --> 01:08:54,600
0,420 510,990 990,1110 1110,1230 1230,1440
uses,| Linux is going to
|Linux 将发送写 IPC 给 L4 ，

2246
01:08:54,630 --> 01:08:56,490
0,450 450,750 1110,1440 1440,1530 1530,1860
ask {} send the write

2247
01:08:56,550 --> 01:08:58,290
0,420 420,1020 1020,1290 1290,1380 1380,1740
{IPC,to,L4 - -}| to cause
|以使 L4 修改 VI 的页表。

2248
01:08:58,290 --> 01:09:00,240
0,210 210,660 660,930 1020,1620 1620,1950
{L4 -} to change {VI's

2249
01:09:00,240 --> 01:09:01,460
0,150 150,480 480,840
-} page table.|
|

2250
01:09:05,060 --> 01:09:07,380
0,420 420,780 780,1020 1020,1350
Any questions about that,
关于这里的基本方案，有什么问题吗？

2251
01:09:07,780 --> 01:09:08,980
0,150 150,240 240,540 540,870 870,1200
about the basic scheme? {}|
|

2252
01:09:14,120 --> 01:09:17,210
0,480 930,1290 1290,1500 1500,2310 2850,3090
{} Another thing to, another
另一件事改变的事，

2253
01:09:17,210 --> 01:09:19,130
0,90 90,180 180,300 300,1140 1440,1920
thing that was changed,| many
|很多小事都变了，

2254
01:09:19,130 --> 01:09:20,240
0,270 270,480 480,570 570,900 900,1110
small things were changed,| but
|但是，有一件特别有趣的事情是，

2255
01:09:20,480 --> 01:09:22,850
0,390 1020,1560 1560,1770 1770,2220 2220,2370
{ -} a specific thing

2256
01:09:22,850 --> 01:09:24,380
0,60 60,450 450,570 570,810 960,1530
of interest is that,| when
|当 VI 想要进行系统调用时，

2257
01:09:24,380 --> 01:09:25,280
0,360 360,630 630,720 720,840 840,900
VI wants to make a

2258
01:09:25,280 --> 01:09:26,820
0,450 450,750 750,990
system call,| so,
|所以，如果 VI 不知道它在 L4 上运行，

2259
01:09:27,000 --> 01:09:27,990
0,150 150,270 270,390 390,780 780,990
if {VI -} doesn't know

2260
01:09:27,990 --> 01:09:29,190
0,150 150,360 360,510 510,690 690,1200
it's running on {L4 -},|
|

2261
01:09:29,670 --> 01:09:32,430
0,480 810,1320 2040,2250 2250,2370 2370,2760
{ -} in this scheme,|
在这个方案中，|

2262
01:09:32,430 --> 01:09:35,010
0,510 870,1530 1530,1770 1770,1920 1920,2580
it's really all these programs
实际上所有这些程序认为自己运行在 Linux 上，

2263
01:09:35,010 --> 01:09:35,880
0,210 210,360 360,420 420,780 780,870
just think of themselves as

2264
01:09:35,880 --> 01:09:37,410
0,210 210,330 330,780 810,1230 1230,1530
running on Linux,| when VI
|当 VI 想要进行系统调用时，

2265
01:09:37,410 --> 01:09:38,250
0,210 210,300 300,390 390,450 450,840
wants to make a system

2266
01:09:38,250 --> 01:09:40,290
0,450 570,1200 1410,1590 1590,1800 1800,2040
call,| {} you know L4
|L4 不支持的系统调用，

2267
01:09:40,290 --> 01:09:43,560
0,210 210,510 990,2130 2370,2790 2790,3270
does not support,| its not
|它不是在进行 L4 系统调用，而是进行 Linux 系统调用，

2268
01:09:43,560 --> 01:09:44,730
0,330 330,480 480,660 660,930 930,1170
making {L4 -} system call,

2269
01:09:44,730 --> 01:09:46,320
0,240 240,570 570,810 810,1110 1320,1590
{it's,making} Linux system call,| so
|所以 VI 系统调用，比如 fork ，

2270
01:09:46,320 --> 01:09:48,270
0,360 360,840 840,1110 1110,1260 1260,1950
VI system calls like fork,|
|

2271
01:09:48,360 --> 01:09:50,220
0,240 240,450 450,510 510,840 840,1860
{} there's a little library,
这里有一个很小的库，链接到，

2272
01:09:50,280 --> 01:09:52,800
0,510 510,810 990,1590 1800,2100 2100,2520
basically that {} was linked

2273
01:09:52,800 --> 01:09:54,740
0,270 270,930 960,1530
into these {},|
|

2274
01:09:56,010 --> 01:09:57,690
0,390 420,900 900,1380 1380,1500 1500,1680
{} Linux processes that would
Linux 进程将返回调用，

2275
01:09:57,690 --> 01:10:00,060
0,690 1290,1890 1890,1980 1980,2190 2190,2370
return calls| like things like
|比如 fork exec pipe read 或 write 之类的调用，返回到 IPC 消息，

2276
01:10:00,060 --> 01:10:01,950
0,540 540,660 660,1260 1260,1380 1380,1890
fork or exec or pipe

2277
01:10:01,950 --> 01:10:04,920
0,300 300,660 810,1290 1290,2010 2010,2970
{read,or} write into IPC messages,|
|

2278
01:10:05,070 --> 01:10:06,690
0,540 540,690 690,780 780,900 900,1620
{} that it would send
它将发送到 Linux 任务，

2279
01:10:07,080 --> 01:10:09,330
0,330 600,750 750,900 900,1380 1380,2250
{} to the Linux task|
|

2280
01:10:09,450 --> 01:10:10,500
0,450 450,630 630,840 840,960 960,1050
{} and wait for the
并等待 Linux 任务的响应，

2281
01:10:10,500 --> 01:10:11,820
0,360 360,450 450,540 540,810 810,1320
response {} the Linux task,|
|

2282
01:10:11,820 --> 01:10:13,230
0,240 240,750 750,930 930,1260 1290,1410
then return as if the
然后返回，像系统调用返回一样。

2283
01:10:13,230 --> 01:10:14,760
0,330 330,660 660,1080
system call returned.|
|

2284
01:10:15,670 --> 01:10:16,780
0,240 240,360 360,750 750,930 930,1110
{} So so these little
所以，这些小库将系统调用返回到 Linux 的 IPC 消息中，

2285
01:10:16,780 --> 01:10:18,550
0,450 450,720 720,1020 1020,1350 1350,1770
libraries return system calls into

2286
01:10:20,270 --> 01:10:22,220
0,540 540,990 990,1110 1110,1560 1740,1950
IPC messages to Linux| and
|这意味着，

2287
01:10:22,220 --> 01:10:23,090
0,120 120,270 270,480 480,570 570,870
what that meant is that,|
|

2288
01:10:23,210 --> 01:10:24,500
0,240 240,390 390,690 690,990 990,1290
if the Linux kernel task
如果 Linux 内核任务没有做任何事情，

2289
01:10:24,500 --> 01:10:25,940
0,210 210,360 360,690 690,930 1020,1440
isn't doing anything, it isn't

2290
01:10:25,940 --> 01:10:27,920
0,210 210,570 570,1230 1350,1650 1650,1980
doing anything else,| it's sitting
|它在一个 recv 调用上，等待接收下一个系统调用请求 IPC ，

2291
01:10:27,920 --> 01:10:28,910
0,90 90,240 240,450 450,540 540,990
in a call {} recv，

2292
01:10:28,910 --> 01:10:30,020
0,300 300,420 420,510 510,810 810,1110
waiting for the next system

2293
01:10:30,020 --> 01:10:32,630
0,300 300,960 1110,1680 1680,2280 2370,2610
call request IPC| from any
|来自这些进程中的任何一个。

2294
01:10:32,630 --> 01:10:34,840
0,180 180,270 270,810 840,1710
one of these processes.|
|

2295
01:10:37,070 --> 01:10:38,180
0,450

2296
01:10:39,040 --> 01:10:39,820
0,120 120,270 270,450 450,570 570,780
And that led to it,|
这导致了，|

2297
01:10:39,940 --> 01:10:41,100
0,480

2298
01:10:41,330 --> 01:10:42,620
0,300 300,660 660,870 870,1020 1020,1290
that that leads to a
这导致了明显的不同，

2299
01:10:42,650 --> 01:10:45,360
0,780 780,1200 1200,1500 1500,1920
significant difference| between how
|这种 Linux 的工作方式与普通 Linux 的工作方式，

2300
01:10:45,560 --> 01:10:47,300
0,480 480,900 900,1380 1380,1530 1530,1740
this Linux works and how

2301
01:10:47,300 --> 01:10:49,790
0,420 420,750 750,1200 1980,2130 2130,2490
ordinary Linux works,| in ordinary
|在普通的 Linux 中，比如 xv6 ，

2302
01:10:49,790 --> 01:10:50,660
0,240 240,420 420,570 570,750 750,870
Linux, just like {xv6 -

2303
01:10:50,660 --> 01:10:52,520
0,420 420,690 690,930 1020,1710 1710,1860
-},| there's a basically a
|每个用户级进程都有一个对应的内核线程，

2304
01:10:52,550 --> 01:10:54,410
0,480 480,810 810,900 900,1710 1710,1860
kernel thread that corresponds to

2305
01:10:54,410 --> 01:10:56,660
0,720 900,1230 1230,1500 1500,1740 1740,2250
every {} user level process|
|

2306
01:10:56,660 --> 01:10:58,060
0,240 330,840
and when
并且当程序进行系统调用时，

2307
01:10:58,060 --> 01:10:59,170
0,300 300,450 450,480 480,780 780,1110
program makes a system call,|
|

2308
01:10:59,170 --> 01:10:59,960
0,150

2309
01:10:59,960 --> 01:11:01,580
0,210 210,480 870,1290 1290,1530 1530,1620
{} the kernel runs a
内核代表该系统调用运行一个线程，

2310
01:11:01,580 --> 01:11:02,390
0,240 240,330 330,600 600,660 660,810
thread on behalf of that

2311
01:11:02,390 --> 01:11:05,720
0,360 360,720 1080,1650 2130,2790 2820,3330
system call,| {} and when
|在普通 Linux 中，

2312
01:11:06,080 --> 01:11:07,760
0,210 210,660 660,1020 1020,1290 1290,1680
in ordinary Linux,| when Linux
|当 Linux 在内核线程之间切换时，

2313
01:11:07,760 --> 01:11:11,090
0,660 660,1440 1620,2040 2040,2820 2850,3330
switches between kernel threads,| that
|这意味着从一个进程切换到另一个进程，

2314
01:11:11,090 --> 01:11:12,800
0,390 390,1020 1020,1080 1080,1560 1560,1710
basically implies a switch from

2315
01:11:12,800 --> 01:11:14,680
0,240 240,750 750,900 900,1410
one process to another,|
|

2316
01:11:14,830 --> 01:11:15,640
0,240 240,390 390,570 570,750 750,810
{} so there's kind of
所以这是一对一的关系，

2317
01:11:15,640 --> 01:11:17,200
0,180 180,240 240,420 420,1080 1080,1560
one to one correspondence| between
|Linux 内核运行的内核线程，

2318
01:11:17,590 --> 01:11:18,660
0,480
{}

2319
01:11:19,500 --> 01:11:21,330
0,540 540,810 810,1020 1020,1380 1380,1830
what kernel thread Linux kernels

2320
01:11:21,330 --> 01:11:23,340
0,510 840,1260 1260,1470 1470,1890 1890,2010
running| and what process is
|和 Linux 完成后要运行的进程之间，

2321
01:11:23,340 --> 01:11:24,450
0,240 240,510 510,690 690,1020 1020,1110
gonna run when Linux is

2322
01:11:24,450 --> 01:11:26,190
0,360 450,1140 1140,1290 1290,1650 1650,1740
done,| here that connection is
|在这里，连接被打断了，

2323
01:11:26,190 --> 01:11:28,440
0,420 480,630 630,780 780,1440 1620,2250
broken,| they were indeed {}
|实际上，这个 Linux 服务器中，

2324
01:11:28,560 --> 01:11:30,630
0,210 210,450 450,900 900,1500 1530,2070
in this Linux server,| a
|一个内核线程对应于。

2325
01:11:30,660 --> 01:11:33,000
0,390 390,840 840,1530 1530,1650 1650,2340
kernel thread corresponding to each.|
|

2326
01:11:34,230 --> 01:11:35,640
0,180 180,540 870,1140 1140,1200 1200,1410
I'm sorry, let me start
抱歉，让我再说一遍，

2327
01:11:35,640 --> 01:11:36,980
0,270 270,630
again,| the
|Linux 内核服务器在单个 L4 线程中运行，

2328
01:11:37,300 --> 01:11:39,610
0,510 510,840 840,1470 1590,1830 1830,2310
Linux kernel server was running

2329
01:11:39,610 --> 01:11:41,230
0,390 390,450 450,1050 1050,1260 1260,1620
in a single {L4 -}

2330
01:11:41,230 --> 01:11:42,430
0,480 510,750 750,870 870,990 990,1200
thread,| so there was only
|所以在 Linux 中一次只有一个控制线程在执行，

2331
01:11:42,430 --> 01:11:44,920
0,60 60,810 1830,2070 2070,2130 2130,2490
a single sort of thread

2332
01:11:44,920 --> 01:11:46,720
0,90 90,540 540,1050 1050,1170 1170,1800
of control executing in Linux

2333
01:11:46,720 --> 01:11:48,280
0,150 150,210 210,780
at a time,|
|

2334
01:11:48,280 --> 01:11:49,960
0,780 810,1230 1230,1350 1350,1470 1470,1680
however, just as in {xv6
然而，就像在 xv6 中一样，

2335
01:11:49,960 --> 01:11:52,340
0,150 150,990 1170,1830
- -}, {}|
|

2336
01:11:52,370 --> 01:11:53,930
0,360 360,600 600,810 810,900 900,1560
this one thread of control
这个控制线程切换

2337
01:11:53,990 --> 01:11:56,390
0,480 480,1440 1470,1950 1950,2040 2040,2400
would switch| using a technique
|使用非常类似于 xv6 上下文切换的技术，

2338
01:11:56,390 --> 01:11:57,920
0,210 210,450 450,780
very much like

2339
01:11:59,480 --> 01:12:02,390
0,630 630,1110 1110,1440 2070,2280 2280,2910
xv6 context switch,| could switch
|可以在对应于每个用户进程的内核线程之间切换，

2340
01:12:02,390 --> 01:12:05,840
0,870 900,1440 1710,2160 2160,2700 2790,3450
between a kernel thread corresponding

2341
01:12:05,840 --> 01:12:08,030
0,150 150,390 390,630 630,1350 1380,2190
to each user process,| however,
|但是这些，

2342
01:12:08,660 --> 01:12:09,940
0,210 210,780
{} which

2343
01:12:10,030 --> 01:12:12,010
0,180 180,810 870,1200 1200,1680 1680,1980
of these,| the these kernel
|这些内核线程纯粹在 Linux 内部实现的，

2344
01:12:12,010 --> 01:12:13,450
0,240 240,330 330,750 750,1170 1170,1440
threads were implemented purely within

2345
01:12:13,450 --> 01:12:14,500
0,390 390,480 480,780 780,840 840,1050
Linux,| had nothing to do
|与 L4 级线程无关，

2346
01:12:14,500 --> 01:12:16,000
0,210 210,390 390,660 660,1290 1320,1500
with {L4 -} threads,| there's
|这里只有一个 L4 线程，

2347
01:12:16,000 --> 01:12:17,110
0,180 180,390 390,600 600,840 840,1110
only one {L4 -} thread

2348
01:12:17,110 --> 01:12:19,630
0,270 870,1290 1440,1830 1830,2160 2160,2520
here,| {} but which user
|但是哪个用户进程正在运行由 L4 确定，

2349
01:12:19,630 --> 01:12:21,520
0,450 450,630 630,1200 1260,1500 1500,1890
process was running was determined

2350
01:12:21,520 --> 01:12:22,940
0,150 150,360 360,900
by {L4 -},|
|

2351
01:12:22,940 --> 01:12:25,160
0,450 450,660 660,870 870,1680 1710,2220
so in this setup {},|
所以在这个设置中，|

2352
01:12:25,190 --> 01:12:26,660
0,510 510,690 690,810 810,1380 1380,1470
Linux might be serving a
Linux 可能服务于执行 VI 的内核线程的请求，

2353
01:12:26,660 --> 01:12:28,640
0,690 690,1410
request from

2354
01:12:28,820 --> 01:12:30,920
0,690 690,1080 1440,1740 1740,1980 1980,2100
executing the kernel thread for

2355
01:12:30,920 --> 01:12:32,780
0,480 510,990 990,1170 1170,1470 1470,1860
VI,| serving a VI system
|服务 VI 系统调用，

2356
01:12:32,780 --> 01:12:34,220
0,300 600,810 810,930 930,1230 1230,1440
call,| at the same time
|同时， L4 引起 shell 在用户空间中运行，

2357
01:12:34,220 --> 01:12:35,480
0,180 180,360 360,750 750,870 870,1260
that {L4 -} is causing

2358
01:12:35,480 --> 01:12:37,640
0,150 150,660 660,1020 1020,1320 1320,2160
this {shell,to} {run,in} user space,|
|

2359
01:12:38,080 --> 01:12:39,960
0,150 150,240 240,540 540,1350
which is very unlike
这与 xv6 或 linux 中的情况非常不同，

2360
01:12:39,960 --> 01:12:40,890
0,180 180,360 360,690 690,780 780,930
{} what happens in {xv6

2361
01:12:40,890 --> 01:12:42,180
0,150 150,360 360,450 450,870 870,1290
- -} or Linux| where
|在它们之中存在直接关系，

2362
01:12:42,630 --> 01:12:44,400
0,210 210,540 540,600 600,960 960,1770
{} there's a direct correspondence|
|

2363
01:12:44,400 --> 01:12:46,500
0,660 990,1110 1110,1290 1290,1410 1410,2100
between the sort of active
在活动内核线程和相应的用户级线程之间，

2364
01:12:46,530 --> 01:12:48,960
0,360 360,840 840,1020 1020,1290 1500,2430
kernel thread and the corresponding

2365
01:12:49,440 --> 01:12:50,730
0,210 210,450 450,690 690,1020 1020,1290
a user level thread,| here
|在这里，L4 运行，

2366
01:12:50,730 --> 01:12:51,930
0,90 90,450 450,720 720,930 930,1200
{L4 -} of running whatever|
|

2367
01:12:51,930 --> 01:12:53,850
0,90 90,390 390,840 1080,1530 1530,1920
it feels like {} and
Linux 内核中的这些线程更加私有，

2368
01:12:53,970 --> 01:12:54,990
0,360 360,630 630,690 690,750 750,1020
these threads in the Linux

2369
01:12:54,990 --> 01:12:56,280
0,360 360,510 510,840 870,1140 1140,1290
kernel are really much more

2370
01:12:56,280 --> 01:12:57,570
0,510 510,630 630,720 720,930 930,1290
private| and are just about
|关于 Linux 能够并发执行系统调用，

2371
01:12:57,600 --> 01:13:00,360
0,780 780,930 930,1170 1170,1740 1950,2760
Linux being able to concurrently

2372
01:13:00,360 --> 01:13:02,250
0,630 660,1080 1080,1530 1530,1650 1650,1890
execute system calls| in different
|在不同的执行阶段，

2373
01:13:02,250 --> 01:13:04,260
0,480 480,540 540,1140 1200,1620 1620,2010
stages of execution,| where maybe
|可能一个进程正在等待磁盘，

2374
01:13:04,780 --> 01:13:06,310
0,180 180,450 450,1050 1080,1200 1200,1530
{} one process is waiting

2375
01:13:06,310 --> 01:13:07,450
0,90 90,210 210,720 720,840 840,1140
for the disk in its

2376
01:13:07,450 --> 01:13:09,850
0,570 870,1140 1140,1620 1620,2010 2070,2400
thread,| {} Linux can run
|Linux 可以运行不同进程内核线程来服务进程系统调用。

2377
01:13:09,850 --> 01:13:11,980
0,180 180,630 960,1470 1470,1770 1770,2130
a different processe's kernel thread

2378
01:13:11,980 --> 01:13:14,320
0,270 330,1050 1320,1560 1560,1980 1980,2340
to serve that process system

2379
01:13:14,320 --> 01:13:15,020
0,240
call.|
|

2380
01:13:16,500 --> 01:13:17,620
0,510

2381
01:13:20,480 --> 01:13:22,430
0,570 660,900 900,1230 1230,1410 1410,1950
So, {} you might wonder
所以，你可能会想，为什么这个设计没有直接使用 L4 线程

2382
01:13:22,850 --> 01:13:25,400
0,930 930,1440 1440,1770 1770,2070 2070,2550
why this design didn't directly

2383
01:13:25,400 --> 01:13:27,470
0,210 210,390 390,660 660,1530 1740,2070
use {L4 -} threads {}|
|

2384
01:13:27,470 --> 01:13:30,290
0,120 120,810 810,1350 1410,2160 2160,2820
to implement the various different
来实现 Linux 内部的各种不同的内核线程，

2385
01:13:30,350 --> 01:13:31,560
0,810
{}

2386
01:13:32,650 --> 01:13:34,570
0,450 480,780 780,1020 1020,1320 1320,1920
{} kernel threads inside Linux,|
|

2387
01:13:35,110 --> 01:13:37,030
0,720 720,870 870,1410 1440,1800 1800,1920
why did Linux implement its
为什么 Linux 实现自己的内部线程，

2388
01:13:37,030 --> 01:13:38,770
0,360 360,570 570,810 840,1410 1410,1740
own sort of internal threads

2389
01:13:38,770 --> 01:13:39,880
0,390 390,660 660,720 720,1020 1020,1110
package| instead of using {L4
|而不是使用 L4 线程，

2390
01:13:39,880 --> 01:13:41,410
0,270 270,660 840,1170 1170,1260 1260,1530
-} threads,| and the answer
|答案是，在那个时候，

2391
01:13:41,410 --> 01:13:42,940
0,180 180,360 360,510 510,750 750,1530
was that in those days,|
|

2392
01:13:43,960 --> 01:13:45,490
0,600 630,840 840,1050 1050,1170 1170,1530
a, they didn't have access
a ，他们没有多核硬件，

2393
01:13:45,490 --> 01:13:46,800
0,90 90,330 330,630 630,780
to {multi-core -} {}

2394
01:13:46,800 --> 01:13:48,600
0,660 690,810 810,990 990,1440 1470,1800
hardware,| they were using single
|他们使用的是单核硬件，

2395
01:13:48,600 --> 01:13:49,500
0,180 180,570 570,720 720,810 810,900
core hardware,| so there were
|所以，这里没有性能优势，

2396
01:13:49,500 --> 01:13:53,190
0,270 270,1110 1110,2010 2310,2820 3390,3690
no performance advantage| to be
|在内核中同时执行多个线程，

2397
01:13:53,190 --> 01:13:54,840
0,240 240,360 360,900 900,1320 1320,1650
able to execute multiple threads

2398
01:13:54,840 --> 01:13:55,410
0,60 60,150 150,420 420,510 510,570
in the kernel at the

2399
01:13:55,410 --> 01:13:56,430
0,330 330,630 630,810 810,900 900,1020
same time,| because there was
|因为只有一个核心，

2400
01:13:56,430 --> 01:13:58,710
0,150 150,390 390,810 2100,2280 2280,2280
only one core,| so a
|所以，第二个线程无法执行，

2401
01:13:58,710 --> 01:14:00,240
0,330 330,540 540,780 780,870 870,1530
second thread couldn't be executing,|
|

2402
01:14:00,450 --> 01:14:01,680
0,240 240,450 450,750 750,870 870,1230
only one thread could execute
因为硬件的原因，一次只能执行一个线程，

2403
01:14:01,680 --> 01:14:02,340
0,120 120,180 180,450 450,600 600,660
at a time due to

2404
01:14:02,340 --> 01:14:04,500
0,60 60,630 1140,1710 1740,1890 1890,2160
the hardware,| and the other
|另一个可能更有说服力的原因是，

2405
01:14:04,500 --> 01:14:05,700
0,150 150,270 270,480 480,720 720,1200
may be even more powerful

2406
01:14:05,700 --> 01:14:06,750
0,300 300,450 450,660 660,780 780,1050
reason is that| in those
|那时候，他们用的这个 Linux 版本，

2407
01:14:06,750 --> 01:14:08,430
0,570 720,960 960,1260 1260,1380 1380,1680
days, the version of Linux

2408
01:14:08,430 --> 01:14:09,600
0,120 120,270 270,690
they were using,|
|

2409
01:14:09,850 --> 01:14:11,290
0,390 390,630 630,930 930,1110 1110,1440
{} did not did not
没有支持，

2410
01:14:11,290 --> 01:14:13,480
0,300 300,390 390,990 1140,1440 1440,2190
have the support,| that's required
|这需要有多个线程，多个核心，

2411
01:14:13,600 --> 01:14:15,520
0,240 240,600 630,1080 1080,1500 1500,1920
to have multiple threads multiple

2412
01:14:15,520 --> 01:14:17,380
0,630 630,1200 1200,1530 1530,1590 1590,1860
cores| executing inside the kernel
|同时在内核内执行，

2413
01:14:17,380 --> 01:14:18,760
0,90 90,180 180,450 450,900 1110,1380
at the same time,| they
|他们使用的是单处理器 Linux ，

2414
01:14:18,760 --> 01:14:20,620
0,120 120,420 420,660 660,1050 1050,1860
were using a {uni-processor -}

2415
01:14:20,650 --> 01:14:22,360
0,720 750,960 960,1170 1170,1380 1380,1710
Linux,| so old enough Linux,
|足够老的 Linux ，它只有一个核心用于内核，

2416
01:14:22,360 --> 01:14:24,580
0,210 1080,1560 1560,1710 1710,1920 1920,2220
it expected only one core

2417
01:14:24,580 --> 01:14:25,600
0,60 60,390 390,510 510,540 540,1020
the kernel at a time,|
|

2418
01:14:27,420 --> 01:14:28,530
0,180 180,420 420,690 690,960 960,1110
it didn't have things like
它没有像 xv6 那样的自旋锁，

2419
01:14:28,530 --> 01:14:29,850
0,90 90,420 420,990 990,1080 1080,1320
the spin locks the {xv6

2420
01:14:29,850 --> 01:14:31,110
0,120 120,420 420,990 1020,1140 1140,1260
- -} has,| that would
|这允许在内核内正确执行多个多核，

2421
01:14:31,110 --> 01:14:32,560
0,300 300,450 450,870
allow it to

2422
01:14:32,680 --> 01:14:35,890
0,270 300,1140 1590,2100 2100,2820 2850,3210
{} correctly execute multiple multiple

2423
01:14:35,890 --> 01:14:37,180
0,300 300,570 570,630 630,990 1050,1290
cores inside the kernel,| so
|所以，不会有性能优势，

2424
01:14:37,180 --> 01:14:37,780
0,90 90,210 210,300 300,450 450,600
there would have been no

2425
01:14:37,780 --> 01:14:41,230
0,600 600,1290 2310,2460 2460,2970 2970,3450
performance advantage| in having multiple
|在内核内具有多个活动的 L4 线程，

2426
01:14:41,230 --> 01:14:42,880
0,270 270,540 540,840 840,1290 1290,1650
{L4 -} threads active inside

2427
01:14:42,880 --> 01:14:44,950
0,90 90,570 1410,1830 1830,1920 1920,2070
the kernel,| but it would
|但它需要添加，

2428
01:14:44,950 --> 01:14:47,710
0,120 120,1050 1470,1890 1890,2430 2640,2760
have required adding in,| you
|为了增加性能，

2429
01:14:47,710 --> 01:14:49,390
0,90 90,240 240,390 390,1080 1080,1680
know for {you,know} performance,| when
|添加自旋锁和其他内容，

2430
01:14:49,510 --> 01:14:50,830
0,360 360,540 540,750 750,930 960,1320
adding in all the spin

2431
01:14:50,830 --> 01:14:51,820
0,330 330,420 420,570 570,840 840,990
locks and other stuff,| that's
|用来支持并发性，

2432
01:14:51,820 --> 01:14:54,190
0,420 420,510 510,1020 1290,2070 2160,2370
required to support concurrency,| so
|所以他们没有这么做。

2433
01:14:54,190 --> 01:14:54,860
0,210
they

2434
01:14:55,200 --> 01:14:58,800
0,300 300,390 390,630 2370,3030 3030,3600
didn't do it.| A drawback
|这种安排的一个缺点是，

2435
01:14:58,800 --> 01:15:00,300
0,60 60,210 210,840
of this arrangement

2436
01:15:00,510 --> 01:15:02,610
0,210 210,450 1230,1380 1380,1770 1770,2100
is that,| in ordinary Linux,
|在普通 Linux 中，在原生 Linux 中，

2437
01:15:02,610 --> 01:15:04,110
0,150 150,600 600,1200 1200,1410 1410,1500
in native Linux,| like you
|就像你直接在笔记本电脑上运行的，

2438
01:15:04,110 --> 01:15:05,070
0,90 90,360 360,750 750,840 840,960
would run directly on your

2439
01:15:05,070 --> 01:15:06,570
0,600 660,1110 1110,1260 1260,1320 1320,1500
laptop,| Linux has a lot
|Linux 有很多复杂的调度机制，

2440
01:15:06,570 --> 01:15:09,810
0,120 120,1260 1290,2430 2430,3060 3060,3240
of sophisticated scheduling machinery,| that
|可以对不同的进程设置优先级，

2441
01:15:09,810 --> 01:15:11,220
0,240 390,660 660,960 960,1110 1110,1410
can do things like impose

2442
01:15:11,220 --> 01:15:13,140
0,720 720,810 810,1080 1080,1770 1770,1920
priorities on different processes| or
|或者保证各种公平，

2443
01:15:13,140 --> 01:15:15,240
0,690 690,1050 1050,1290 1290,1350 1350,2100
ensure various kinds of fairness,|
|

2444
01:15:17,080 --> 01:15:18,400
0,180 180,300 300,480 480,990 990,1320
and that was fine, because
这很好，因为在你的笔记本电脑上，

2445
01:15:18,400 --> 01:15:19,690
0,180 180,450 630,810 810,900 900,1290
in {} on your laptop,|
|

2446
01:15:19,690 --> 01:15:21,280
0,210 210,510 510,780 810,990 990,1590
because Linux is in control
因为 Linux 控制着每个核心上运行的进程，

2447
01:15:21,280 --> 01:15:23,140
0,390 600,840 840,1290 1290,1410 1410,1860
of what process is running

2448
01:15:23,650 --> 01:15:24,970
0,210 210,360 360,870 900,1260 1260,1320
on each core,| but in
|但在这个设置中， Linux 根本不能控制这一点，

2449
01:15:24,970 --> 01:15:25,840
0,150 150,390 390,630 630,720 720,870
this setup, Linux is not

2450
01:15:25,840 --> 01:15:27,520
0,360 360,540 540,630 630,1050 1440,1680
controlling that at all,| and
|Linux 无法控制什么进程正在运行，

2451
01:15:27,520 --> 01:15:28,780
0,120 120,270 270,450 450,870 870,1260
Linux is no control over

2452
01:15:29,460 --> 01:15:31,380
0,390 660,930 930,1320 1320,1440 1440,1920
what, what process is running,|
|

2453
01:15:31,500 --> 01:15:33,240
0,360 360,630 630,1230 1230,1560 1560,1740
{} because {it,L4 -} that
因为执行此调度的是 L4 ，而不是 Linux ，

2454
01:15:33,240 --> 01:15:35,190
0,300 300,450 450,1080 1080,1350 1350,1950
does this scheduling, not Linux,|
|

2455
01:15:35,370 --> 01:15:37,200
0,270 270,900 930,1440 1440,1530 1530,1830
{you,know} these processes are scheduled
这些进程由 L4 调度，

2456
01:15:37,200 --> 01:15:37,980
0,120 120,270 270,540 540,660 660,780
by {L4 -},| so they
|所以，他们失去了让 Linux 负责调度的能力。

2457
01:15:37,980 --> 01:15:39,210
0,210 210,270 270,600 600,690 690,1230
kind of lost the ability

2458
01:15:39,210 --> 01:15:41,040
0,360 690,1020 1020,1590 1590,1740 1740,1830
to have Linux be in

2459
01:15:41,040 --> 01:15:43,060
0,540 540,750 750,930 960,1620
charge of a schedule.|
|

2460
01:15:43,300 --> 01:15:44,400
0,390

2461
01:15:44,640 --> 01:15:45,150
0,120 120,180 180,300 300,360 360,510
You know, it's a bit
这有点缺陷，

2462
01:15:45,150 --> 01:15:46,110
0,60 60,120 120,630 630,690 690,960
of a defect of this,|
|

2463
01:15:46,110 --> 01:15:48,750
0,270 510,1320 1980,2130 2130,2340 2340,2640
{} although I'm sure later
尽管我确信后来的 L4 版本有针对 Linux 或类似系统的某种方式，

2464
01:15:48,750 --> 01:15:50,640
0,330 330,420 420,600 600,1170 1410,1890
versions of {L4 -} had

2465
01:15:50,760 --> 01:15:53,550
0,930 930,1440 1800,2340 2340,2490 2490,2790
{some,way} for Linux or something

2466
01:15:53,550 --> 01:15:54,150
0,210 210,300 300,360 360,450 450,600
like it| to be able
|为了告诉 L4 调度器，

2467
01:15:54,150 --> 01:15:54,870
0,90 90,270 270,390 390,630 630,720
to tell the {L4 -}

2468
01:15:54,870 --> 01:15:57,690
0,390 390,480 480,810 810,1290 2610,2820
schedule,| {} look, please give
|请给这个进程更高的优先权或者别的什么，

2469
01:15:57,690 --> 01:15:59,070
0,180 180,570 570,840 840,1350 1350,1380
this process higher priority or

2470
01:15:59,070 --> 01:16:01,080
0,420 1470,1770 1770,1860 1860,1890 1890,2010
whatever,| so it's a bit
|所以这有点奇怪。

2471
01:16:01,080 --> 01:16:01,860
0,420
awkward.|
|

2472
01:16:06,950 --> 01:16:09,360
0,720 1020,1680
Alright {}.|
好的。|

2473
01:16:11,390 --> 01:16:13,040
0,1020
So,
所以，他们花了这么多功夫才让这件事开始。

2474
01:16:13,210 --> 01:16:13,900
0,240 240,300 300,450 450,570 570,690
so they went to all

2475
01:16:13,900 --> 01:16:16,030
0,180 180,750 960,1380 1710,1980 1980,2130
this work to get this

2476
01:16:16,030 --> 01:16:17,080
0,480
going.|
|

2477
01:16:17,780 --> 01:16:20,690
0,660 1350,2130 2490,2610 2610,2730 2730,2910
And, {} you should ask
而且，你应该问问自己，

2478
01:16:20,690 --> 01:16:21,800
0,570 570,630 630,690 690,930 930,1110
yourself| you know what is
|这篇关于微内核的论文带给我们的教训是什么？

2479
01:16:21,800 --> 01:16:23,750
0,390 480,660 660,780 780,1440 1440,1950
the, what's the takeaway lesson

2480
01:16:23,750 --> 01:16:26,480
0,360 420,600 600,810 810,1410 2040,2730
from from this paper about

2481
01:16:26,690 --> 01:16:29,760
0,570 570,1230
micro kernels.|
|

2482
01:16:29,970 --> 01:16:31,770
0,420 420,570 570,1410 1410,1590 1590,1800
{You,know} one things, so for
有一件事，所以对我们来说，

2483
01:16:31,770 --> 01:16:32,610
0,270 270,360 360,420 420,600 600,840
us,| you know this paper
|这篇论文有很多有趣的花絮，

2484
01:16:32,610 --> 01:16:33,810
0,120 120,180 180,360 360,540 780,1200
has a lot of interesting

2485
01:16:33,810 --> 01:16:35,250
0,480 480,660 660,840 840,1140 1140,1440
tidbits,| about how micro kernels
|关于微内核如何工作，

2486
01:16:35,250 --> 01:16:36,660
0,240 240,510 510,660 660,1020 1020,1410
work,| about how Linux works|
|关于 Linux 如何工作，|

2487
01:16:36,660 --> 01:16:38,280
0,120 120,540 750,1140 1140,1410 1410,1620
and how you set up
以及如何设置如何设计这样的系统，

2488
01:16:38,430 --> 01:16:39,300
0,180 180,270 270,360 360,810 810,870
how you can design a

2489
01:16:39,300 --> 01:16:41,040
0,270 270,420 420,630 630,1020 1170,1740
system like this,| which may
|这可能很有趣，

2490
01:16:41,040 --> 01:16:44,640
0,120 120,660 1560,2220 2310,2820 3090,3600
be interesting,| but a larger
|但在一个更大的世界里，人们想要吸取一些教训，

2491
01:16:44,640 --> 01:16:46,080
0,450 450,690 690,900 900,1230 1260,1440
world, people want to want

2492
01:16:46,080 --> 01:16:48,090
0,60 60,210 210,420 420,1230 1650,2010
to draw some lessons,| they
|他们需要的，

2493
01:16:48,090 --> 01:16:48,810
0,180 180,270 270,330 330,510 510,720
need to be able to,|
|

2494
01:16:49,790 --> 01:16:50,780
0,120 120,420 420,540 540,900 900,990
I present some lessons in
我在这篇论文中介绍了一些经验教训，

2495
01:16:50,780 --> 01:16:54,050
0,150 150,600 900,1380 2610,3090 3090,3270
this paper,| the paper is
|论文没有真正回答微内核是不是一个好主意，

2496
01:16:54,050 --> 01:16:55,850
0,390 390,690 690,1080 1080,1170 1170,1800
not really answering the question

2497
01:16:55,910 --> 01:16:56,840
0,210 210,510 510,750 750,840 840,930
are micro kernel is a

2498
01:16:56,840 --> 01:16:58,670
0,150 150,690 1140,1440 1440,1650 1650,1830
good idea,| that's not really
|这并不是这里真正发生的事情，

2499
01:16:58,670 --> 01:17:00,830
0,240 240,450 450,660 660,1050 1860,2160
what's going on here,| the
|这篇论文讨论了，

2500
01:17:00,830 --> 01:17:02,570
0,630 630,1080 1080,1170 1170,1500 1500,1740
paper what the paper is

2501
01:17:02,570 --> 01:17:04,280
0,300 300,390 390,690 720,1320 1320,1710
part of {} argument about|
|

2502
01:17:04,310 --> 01:17:06,800
0,630 630,990 990,1800 1830,2220 2220,2490
whether micro kernels have enough
微内核是否有足够的性能来值得使用，

2503
01:17:06,800 --> 01:17:09,900
0,1170 1200,1950 1980,2640
performance to, {}

2504
01:17:10,610 --> 01:17:12,170
0,150 150,270 270,540 540,900 1170,1560
to be worth using| and
|原因是，

2505
01:17:12,200 --> 01:17:13,880
0,210 210,510 510,660 660,1080 1080,1680
the reason is that| in
|在这篇论文发表之前的五年或者十年，

2506
01:17:14,030 --> 01:17:16,820
0,330 510,990 1320,1650 1680,2130 2130,2790
in {} maybe five years

2507
01:17:16,820 --> 01:17:17,810
0,270 270,300 300,480 480,690 690,990
five or ten years before

2508
01:17:17,810 --> 01:17:19,760
0,150 150,420 420,630 630,900 1740,1950
this paper came out,| there
|有一个著名的测量结果，

2509
01:17:19,760 --> 01:17:20,630
0,150 150,240 240,630 630,780 780,870
was a famous set of

2510
01:17:20,630 --> 01:17:21,650
0,540 540,690 690,870 870,930 930,1020
measurements,| on one of the
|在之前的一种称为 Mach 的微内核上，

2511
01:17:21,650 --> 01:17:23,180
0,540 540,810 810,1170 1170,1260 1260,1530
predecessor micro kernels and earlier

2512
01:17:23,180 --> 01:17:25,430
0,240 240,510 510,780 780,1320 1470,2250
micro kernel called Mach,| basically
|基本上在这种配置下运行，

2513
01:17:25,430 --> 01:17:27,170
0,390 390,630 630,900 900,1110 1110,1740
running in very much this

2514
01:17:27,560 --> 01:17:28,900
0,870
configuration,|
|

2515
01:17:29,000 --> 01:17:30,050
0,300 300,390 390,780 780,840 840,1050
but it's different, you know,
但这是不同的，内部设计完全不同，

2516
01:17:30,640 --> 01:17:32,500
0,240 240,450 450,990 990,1590 1590,1860
totally different design internally,| but
|但都是一样的架构。

2517
01:17:32,530 --> 01:17:34,060
0,480 480,540 540,600 600,840 840,1530
kind of the same architecture.|
|

2518
01:17:35,020 --> 01:17:36,960
0,750
This,
早先这个微内核项目的名字叫 Mach ，

2519
01:17:37,230 --> 01:17:38,160
0,180 180,330 330,390 390,540 540,930
the name of this earlier

2520
01:17:38,160 --> 01:17:39,780
0,270 270,600 600,1020 1020,1140 1140,1620
micro kernel project is Mach,|
|

2521
01:17:40,230 --> 01:17:42,000
0,840 840,1230 1230,1350 1350,1650 1650,1770
{there,was} measurements on Mach,| that
有对 Mach 的测量，|表示 Mach 比普通 Unix 慢得多，

2522
01:17:42,000 --> 01:17:44,340
0,300 300,450 450,930 960,1530 1560,2340
showed that Mach was dramatically

2523
01:17:44,340 --> 01:17:47,220
0,540 540,990 1020,1440 1470,2040 2040,2880
slower than just ordinary Unix,|
|

2524
01:17:47,700 --> 01:17:48,690
0,180 180,270 270,450 450,810 810,990
when it was run in
当它在这个配置中运行时，

2525
01:17:48,720 --> 01:17:50,940
0,270 270,1050 1050,1290 1380,2100 2100,2220
this configuration| and {} you
|这有很多原因，

2526
01:17:50,940 --> 01:17:51,870
0,150 150,300 300,630 630,720 720,930
know there are a lot

2527
01:17:51,870 --> 01:17:52,770
0,60 60,360 360,480 480,660 660,900
of reasons for that| having
|必须使用 IPC 系统，

2528
01:17:52,770 --> 01:17:54,540
0,60 60,330 330,930 990,1290 1290,1770
to do with the IPC

2529
01:17:54,540 --> 01:17:56,070
0,360 360,630 630,810 810,930 930,1530
system,| not being as optimized
|并不像你希望的那样优化，

2530
01:17:56,070 --> 01:17:57,360
0,60 60,150 150,390 390,900 1020,1290
as you might hope,| they're
|它们是有更多地切换上下文，

2531
01:17:57,360 --> 01:17:58,620
0,240 240,420 420,570 570,660 660,1260
being just sort of more

2532
01:17:58,650 --> 01:18:00,980
0,510 510,1080 1080,1350
context switches| and
|使用内核穿越和高速缓存未命中等等，

2533
01:18:00,980 --> 01:18:02,630
0,630 1110,1260 1260,1380 1380,1500 1500,1650
{} you know we use

2534
01:18:02,630 --> 01:18:04,730
0,90 90,450 450,1260 1260,1560 1710,2100
our kernel crossings and cache

2535
01:18:04,730 --> 01:18:05,870
0,300 300,390 390,780 780,1080 1080,1140
misses and whatever,| there's a
|Mach 慢的原因有很多，

2536
01:18:05,870 --> 01:18:06,770
0,90 90,240 240,300 300,690 690,900
whole lot of reasons why

2537
01:18:06,770 --> 01:18:09,440
0,480 960,1380 1380,1770 1770,2130 2220,2670
Mach was slow,| but many
|但是很多人看到这些基准测试结果，

2538
01:18:09,440 --> 01:18:11,510
0,480 570,1200 1200,1380 1380,1770 1770,2070
people saw those benchmark results,|
|

2539
01:18:11,510 --> 01:18:12,410
0,240 240,330 330,600 600,720 720,900
showing that Mach was much
显示 Mach 比原始操作系统慢得多，

2540
01:18:12,410 --> 01:18:14,420
0,390 390,750 840,1200 1200,1590 1590,2010
slower than native operating systems|
|

2541
01:18:14,420 --> 01:18:15,740
0,120 120,540 540,690 690,930 930,1320
and decided that micro kernels
并认为微内核是无可救药的低效的，

2542
01:18:15,740 --> 01:18:18,920
0,90 90,570 990,2040 2040,2490 2490,3180
were just hopeless, hopelessly inefficient,|
|

2543
01:18:19,040 --> 01:18:20,210
0,300 300,780 780,960 960,1050 1050,1170
where unlikely ever to be
不太可能快到可以竞争，

2544
01:18:20,210 --> 01:18:21,680
0,330 330,600 600,690 690,840 840,1470
fast enough to be competitive|
|

2545
01:18:21,680 --> 01:18:23,390
0,450 660,930 930,1200 1440,1590 1590,1710
and you know we should
我们都应该使用宏内核。

2546
01:18:23,390 --> 01:18:25,520
0,210 210,390 390,960 990,1530 1530,2130
just all use monolithic kernels.|
|

2547
01:18:26,320 --> 01:18:29,380
0,840 840,1530 1530,1800 2070,2310 2310,3060
Today's papers like an answer
今天的论文就像是对这一论点的回答，

2548
01:18:29,380 --> 01:18:31,690
0,810 960,1410 1440,1560 1560,1770 1770,2310
basically {} to that argument,|
|

2549
01:18:31,690 --> 01:18:33,670
0,420 600,960 960,1050 1350,1590 1590,1980
it's sort of the rebuttal
在某种程度上是对这一论点的反驳，

2550
01:18:33,670 --> 01:18:34,840
0,90 90,300 300,870 900,1080 1080,1170
to that argument,| and the
|这篇论文的重点是展示

2551
01:18:34,840 --> 01:18:35,740
0,240 240,300 300,450 450,750 750,900
point of this paper is

2552
01:18:35,740 --> 01:18:36,790
0,120 120,480 480,630 630,780 780,1050
to show| that you can
|你可以构建这个架构，

2553
01:18:36,790 --> 01:18:38,710
0,420 420,630 630,1440 1440,1830 1830,1920
build this architecture,| and if
|如果你注意优化性能，

2554
01:18:38,710 --> 01:18:40,810
0,120 120,540 720,1410 1410,1500 1500,2100
you pay attention to optimizing

2555
01:18:40,810 --> 01:18:43,000
0,690 810,1080 1080,1200 1200,1590 1680,2190
performance,| you can get a
|你可以得到有竞争力的性能，

2556
01:18:43,120 --> 01:18:46,210
0,720 720,1560 1560,2070 2100,2670 2670,3090
competitive performance| with native operating
|与直接运行 Unix 的原生操作系统相比，

2557
01:18:46,210 --> 01:18:48,580
0,570 570,960 1050,1500 1500,1740 1740,2370
systems just directly running Unix,|
|

2558
01:18:49,000 --> 01:18:50,240
0,180 180,840
and therefore
所以，你不能简单地根据性能来排除微内核，

2559
01:18:50,540 --> 01:18:52,310
0,270 270,660 660,1140 1140,1440 1440,1770
you can't dismiss micro kernels

2560
01:18:52,310 --> 01:18:53,300
0,390 390,510 510,570 570,930 930,990
simply on the basis of

2561
01:18:53,300 --> 01:18:55,340
0,840 1080,1590 1590,1710 1710,1890 1890,2040
performance,| you may not want
|你可能因为其他原因不想要它们，

2562
01:18:55,340 --> 01:18:56,420
0,120 120,240 240,420 420,870 870,1080
them for other reasons,| but
|但你不能以性能作为拒绝的理由，

2563
01:18:56,870 --> 01:18:58,940
0,420 450,600 600,870 870,1140 1140,2070
{} you can't use performance

2564
01:18:59,030 --> 01:19:00,470
0,420 420,510 510,810 810,900 900,1440
as the reason to reject,|
|

2565
01:19:01,010 --> 01:19:03,500
0,540 1050,1710 1710,1800 1800,2190 2190,2490
{} part of, a huge
提出这一论点的很大一部分原因是，

2566
01:19:03,500 --> 01:19:04,670
0,180 180,240 240,300 300,930 930,1170
part of the ingredients in

2567
01:19:04,910 --> 01:19:05,920
0,570
{}

2568
01:19:06,250 --> 01:19:07,330
0,330 330,480 480,840 840,960 960,1080
making that argument is that,|
|

2569
01:19:07,330 --> 01:19:08,320
0,90 90,240 240,330 330,750 750,990
they made the IPC much
他们使用我几分钟前提到的技术使 IPC 变得更快，

2570
01:19:08,320 --> 01:19:09,640
0,450 450,600 600,750 750,1200 1200,1320
faster with the techniques that

2571
01:19:09,640 --> 01:19:10,960
0,120 120,660 660,810 810,990 990,1320
I outlined a few minutes

2572
01:19:10,960 --> 01:19:12,310
0,360 540,750 750,900 900,990 990,1350
ago| and you can see
|你可以看到这一点，我认为在一个非常简单的基准表 2 中，

2573
01:19:12,310 --> 01:19:13,660
0,210 210,300 300,600 600,870 870,1350
this I think in a,

2574
01:19:14,340 --> 01:19:16,200
0,300 300,390 390,870 870,1230 1230,1860
in a very simple benchmark

2575
01:19:16,380 --> 01:19:17,430
0,420 420,720 720,900 900,960 960,1050
table 2,| if you have
|如果你有论文的复制，

2576
01:19:17,430 --> 01:19:18,360
0,60 60,450 450,540 540,600 600,930
a copy of the paper

2577
01:19:18,360 --> 01:19:21,060
0,120 120,390 600,1140 1770,2550 2550,2700
with you,| {} table 2
|表 2 是在硬件上以普通方式运行的原生 Linux 的测量结果，

2578
01:19:21,060 --> 01:19:23,400
0,150 150,870 870,1380 1530,1890 1920,2340
as measurements of just native

2579
01:19:23,400 --> 01:19:24,720
0,480 480,720 720,780 780,840 840,1320
Linux running in the ordinary

2580
01:19:24,720 --> 01:19:26,610
0,180 180,300 300,1080 1350,1740 1740,1890
way on hardware| and on
|在原生 Linux 上，他们展示了

2581
01:19:26,610 --> 01:19:28,080
0,300 300,780 780,930 930,1260 1260,1470
native Linux, they show that|
|

2582
01:19:28,080 --> 01:19:29,640
0,240 600,780 780,900 900,1110 1110,1560
{} {you,know} on their hardware
他们的硬件和 Linux 版本，

2583
01:19:29,640 --> 01:19:30,600
0,90 90,210 210,480 480,540 540,960
and their version of Linux,|
|

2584
01:19:30,780 --> 01:19:33,000
0,450 450,990 1020,1470 1470,1890 1890,2220
that {} a single simple
一个个简单的系统调用 getpid 花费了 1.7 微秒，

2585
01:19:33,000 --> 01:19:34,560
0,330 330,750 750,960 960,1140 1140,1560
system call {getpid - -}

2586
01:19:34,560 --> 01:19:36,270
0,330 330,720 720,990 990,1350 1350,1710
took {1.7 - -} {microseconds

2587
01:19:36,270 --> 01:19:37,400
0,750
-},|
|

2588
01:19:37,900 --> 01:19:39,550
0,420 540,810 810,930 930,1290 1290,1650
{} and they also show
它们还表明，

2589
01:19:39,550 --> 01:19:42,730
0,450 600,1290 2250,2490 2490,2550 2550,3180
that| the sort of equivalent
|在 L4 设置相同的东西，

2590
01:19:42,730 --> 01:19:44,500
0,210 210,390 390,900 990,1410 1410,1770
thing in there {L4 -}

2591
01:19:44,500 --> 01:19:45,790
0,540 660,900 900,1020 1020,1170 1170,1290
setup,| where you have to
|你必须发送 IPC 请求并获得 IPC 响应，

2592
01:19:45,790 --> 01:19:46,960
0,210 210,270 270,720 720,1080 1080,1170
send an IPC request and

2593
01:19:46,960 --> 01:19:48,610
0,120 120,180 180,600 600,1320 1350,1650
get an IPC response| just
|仅针对 getpid 系统调用，

2594
01:19:48,610 --> 01:19:50,020
0,120 120,450 480,720 720,1170 1170,1410
for this {getpid - -}

2595
01:19:50,020 --> 01:19:52,930
0,300 300,690 1020,1350 1350,1800 2160,2910
system call,| that that {}
|在 L4 Linux 下，这需要 4 微秒的时间，

2596
01:19:53,830 --> 01:19:56,410
0,600 750,1230 1530,1830 1830,2280 2280,2580
that took {} four {microseconds

2597
01:19:56,410 --> 01:19:58,360
0,600 630,930 930,1110 1110,1410 1410,1950
-} under {L4 -} Linux,|
|

2598
01:19:58,360 --> 01:19:59,290
0,210 210,330 330,420 420,600 600,930
which is to say twice
这意味着两倍的时间，

2599
01:19:59,290 --> 01:20:01,600
0,150 150,540 540,840 960,1470 1680,2310
as long,| but there's twice
|但是有两倍的工作在进行，

2600
01:20:01,600 --> 01:20:02,710
0,90 90,300 300,570 570,840 840,1110
as much work going on,|
|

2601
01:20:02,710 --> 01:20:04,270
0,240 240,360 360,780 840,1230 1230,1560
because you're doing two sets
因为你进行两组用户内核穿越，

2602
01:20:04,270 --> 01:20:06,130
0,120 120,360 360,660 660,1440 1440,1860
of user kernel crossings| instead
|不只是一个简单的系统调用，

2603
01:20:06,130 --> 01:20:08,200
0,240 720,1020 1020,1080 1080,1470 1470,2070
of just a single simple

2604
01:20:08,380 --> 01:20:10,540
0,450 450,900 990,1350 1350,1680 1770,2160
system call,| that is they
|也就是说，他们可以声称，

2605
01:20:10,540 --> 01:20:11,770
0,150 150,480 480,600 600,720 720,1230
could claim| that they appeared
|他们让这些 IPC 基础系统调用的花费降到了最低，

2606
01:20:11,770 --> 01:20:14,170
0,90 90,930 1500,1680 1680,1890 1890,2400
the expense of these IPC

2607
01:20:14,170 --> 01:20:15,610
0,240 240,510 510,960 990,1350 1350,1440
base system calls down to

2608
01:20:15,610 --> 01:20:17,290
0,450 450,540 540,1050 1080,1290 1290,1680
basically the minimum,| that is
|这是系统调用原生 Linux 花费的两倍，

2609
01:20:17,410 --> 01:20:18,940
0,570 570,630 630,1110 1110,1230 1230,1530
twice the cost of {}

2610
01:20:19,540 --> 01:20:21,310
0,330 330,600 600,900 900,1410 1470,1770
system call native Linux| and
|所以，他们的表现几乎和你预期的一样好。

2611
01:20:21,310 --> 01:20:22,360
0,270 270,390 390,480 480,720 720,1050
therefore they were doing roughly

2612
01:20:22,360 --> 01:20:23,470
0,120 120,360 360,750 780,990 990,1110
as good as you could

2613
01:20:23,470 --> 01:20:24,940
0,390 390,930
possibly expect.|
|

2614
01:20:26,400 --> 01:20:27,390
0,270 270,360 360,540 540,660 660,990
Now, of course that's still
当然，现在他们的系统速度仍然只有原生 Linux 的一半，

2615
01:20:27,900 --> 01:20:29,550
0,600 630,1110 1110,1200 1200,1350 1350,1650
their systems are still half

2616
01:20:29,550 --> 01:20:30,990
0,90 90,450 450,570 570,840 840,1440
as fast as native Linux,|
|

2617
01:20:33,220 --> 01:20:34,360
0,300 300,390 390,510 510,870 870,1140
and you know it's not
这不是很清楚，

2618
01:20:34,360 --> 01:20:36,010
0,390 390,990 1200,1380 1380,1500 1500,1650
clear| unless you did some
|除非你做一些测量，系统调用是否运行了两次，

2619
01:20:36,010 --> 01:20:38,170
0,420 420,1080 1140,1530 1530,1890 1890,2160
measurements whether system calls taking

2620
01:20:38,170 --> 01:20:39,700
0,450 450,600 600,1050 1050,1320 1320,1530
twice| or simple system calls
|或者简单的系统调用花费两倍的时间是灾难还是不是问题。

2621
01:20:39,700 --> 01:20:40,630
0,210 210,480 480,600 600,780 780,930
taking twice as long as

2622
01:20:40,630 --> 01:20:42,130
0,60 60,840 840,1200 1230,1440 1440,1500
a disaster or not a

2623
01:20:42,130 --> 01:20:43,930
0,540 1020,1380 1380,1470 1470,1710 1710,1800
problem.| And in order to
|为了表明这一点，

2624
01:20:43,930 --> 01:20:45,250
0,300 300,690 720,1050 1050,1170 1170,1320
show that,| you know it
|这可能是一场灾难，如果你执行大量系统调用，

2625
01:20:45,250 --> 01:20:46,390
0,150 150,240 240,300 300,840 840,1140
might be a disaster, if

2626
01:20:46,420 --> 01:20:46,870
0,120 120,210 210,270 270,390 390,450
you do a lot of

2627
01:20:46,870 --> 01:20:48,010
0,300 300,630 630,780 780,990 990,1140
system calls| or might be
|或者可能不成问题，如果你执行的系统调用相对较少，

2628
01:20:48,010 --> 01:20:50,170
0,210 210,270 270,810 810,1350 1950,2160
not a problem, if {}

2629
01:20:50,170 --> 01:20:51,430
0,120 120,270 270,750 750,930 930,1260
you do relatively few system

2630
01:20:51,430 --> 01:20:52,390
0,390 390,540 540,720 720,780 780,960
calls| or there's a lot
|或者每个系统调用有很多工作，

2631
01:20:52,390 --> 01:20:54,790
0,120 120,630 900,1170 1170,1560 1560,2400
of work per system calls,|
|

2632
01:20:55,200 --> 01:20:55,950
0,210 210,240 240,510 510,720 720,750
maybe a system calls are
可能系统调用比 getpid 更复杂。

2633
01:20:55,950 --> 01:20:57,090
0,150 150,690 690,810 810,990 990,1140
more complicated than {getpid -

2634
01:20:57,090 --> 01:20:59,670
0,420 780,1350 2010,2190 2190,2280 2280,2580
-}.| {} And the answer
|论文中的答案是 A 图基准测试，

2635
01:20:59,670 --> 01:21:00,930
0,120 240,540 540,660 660,750 750,1260
to that in the paper

2636
01:21:01,020 --> 01:21:03,540
0,390 420,660 660,1140 1140,1530 1560,2520
is the figure A benchmark,|
|

2637
01:21:04,040 --> 01:21:05,960
0,330 330,720 750,1140 1140,1410 1440,1920
using this benchmark called {AIM
使用这个名为 AIM 的基准测试，

2638
01:21:05,960 --> 01:21:07,370
0,510 780,1080 1080,1170 1170,1320 1320,1410
-},| which is just a
|这只是一个，

2639
01:21:07,370 --> 01:21:09,110
0,450 990,1230 1230,1290 1290,1650 1650,1740
more,| it's a benchmark that
|它是一个各种不同的系统调用的基准测试，

2640
01:21:09,110 --> 01:21:10,370
0,120 120,300 300,720 720,990 990,1260
has all kinds of different

2641
01:21:10,370 --> 01:21:11,300
0,270 270,540 540,630 630,810 810,930
system calls,| it reads and
|它读写文件，创建进程，

2642
01:21:11,300 --> 01:21:13,070
0,240 240,660 660,750 750,1050 1050,1770
writes files and creates processes|
|

2643
01:21:13,070 --> 01:21:14,060
0,180 180,360 360,450 450,900 900,990
does all the things with
用内核做进程做的所有事情，

2644
01:21:14,060 --> 01:21:16,370
0,90 90,450 450,660 930,1920 1920,2310
the kernel that processes do,|
|

2645
01:21:16,820 --> 01:21:17,960
0,210 210,300 300,720 720,1020 1020,1140
and they basically showed in
他们在图 A 中显示，

2646
01:21:17,960 --> 01:21:19,910
0,390 390,720 720,1110 1260,1560 1560,1950
figure A that| {} their
|他们的设置运行的是一个更完整的应用程序，

2647
01:21:19,910 --> 01:21:21,680
0,720 750,1320 1320,1440 1440,1620 1620,1770
setup running a much more

2648
01:21:21,680 --> 01:21:23,920
0,330 330,960 960,1110 1110,1770
full application that does,|
|

2649
01:21:24,420 --> 01:21:25,290
0,240 240,420 420,510 510,690 690,870
much more than just {getpid
不仅仅是 getpid ，

2650
01:21:25,290 --> 01:21:27,330
0,180 180,720 1020,1620 1620,1950 1950,2040
- -},| runs only a
|运行速度仅比本地 Linux 慢几个百分点，

2651
01:21:27,330 --> 01:21:29,070
0,210 210,630 630,1170 1170,1410 1410,1740
few percent slower than native

2652
01:21:29,070 --> 01:21:31,680
0,660 870,1200 1200,1500 1500,2220 2250,2610
Linux,| {} and therefore, hopefully
|所以，你可以预期，

2653
01:21:31,680 --> 01:21:32,820
0,120 120,240 240,630 630,750 750,1140
you could expect| that whatever
|无论你想在计算机上运行什么，

2654
01:21:32,820 --> 01:21:33,720
0,180 180,330 330,510 510,780 780,900
it is you wanted to

2655
01:21:33,720 --> 01:21:35,100
0,180 180,300 300,360 360,900 1080,1380
run on a computer,| would
|在 L4 上运行几乎与 Linux 同样快，

2656
01:21:35,100 --> 01:21:36,720
0,180 180,540 540,660 660,1110 1110,1620
run almost as fast under

2657
01:21:36,990 --> 01:21:38,400
0,240 240,510 510,750 750,1260 1260,1410
{L4 -} as Linux,| as
|就像在普通操作系统下一样，

2658
01:21:38,400 --> 01:21:39,960
0,90 90,360 360,810 1110,1260 1260,1560
it does under a straight

2659
01:21:39,960 --> 01:21:41,040
0,300 300,660
operating system,|
|

2660
01:21:41,040 --> 01:21:42,210
0,150 150,210 210,540 540,870 870,1170
{under -} native operating system|
在原生操作系统下，|

2661
01:21:42,480 --> 01:21:44,160
0,420 420,1050 1200,1350 1350,1500 1500,1680
and therefore you know they
所以，它们

2662
01:21:44,160 --> 01:21:45,990
0,270 540,1440 1440,1560 1560,1620 1620,1830
were basically| to a first
|基本上和直接运行 Linux 一样快，

2663
01:21:45,990 --> 01:21:49,160
0,630 630,750 750,1380 1860,2640
approximation as fast {}

2664
01:21:49,160 --> 01:21:50,630
0,210 210,390 390,570 570,870 870,1470
as just running straight Linux|
|

2665
01:21:50,630 --> 01:21:52,790
0,690 1230,1530 1530,1920 1920,2010 2010,2160
and {} therefore you should
所以，你应该认真对待它们。

2666
01:21:52,790 --> 01:21:54,940
0,150 150,240 240,840
take them seriously.|
|

2667
01:21:55,530 --> 01:21:57,000
0,390 390,780 1140,1290 1290,1410 1410,1470
Okay, so that was an
好的，这是一个令人印象深刻的结果，

2668
01:21:57,000 --> 01:21:58,140
0,330 330,660 660,750 750,840 840,1140
impressive result by the way,|
|

2669
01:21:58,200 --> 01:22:00,870
0,180 180,570 1260,1590 1590,1830 1830,2670
this is like someone unexpected
这是一个出乎意料的，并且很酷，

2670
01:22:01,350 --> 01:22:04,440
0,270 270,900 1590,2190 2190,2550 2550,3090
and cool,| just fast forwarding
|快进 20 年后，这一切就结束了，

2671
01:22:04,440 --> 01:22:07,380
0,360 360,990 1290,1920 2070,2760 2760,2940
twenty years, {} where this

2672
01:22:07,380 --> 01:22:08,310
0,240 240,450 450,570 570,600 600,930
ended up,| as I mentioned
|正如我之前提到的，

2673
01:22:08,310 --> 01:22:09,780
0,480 480,750 750,990 990,1290 1290,1470
before,| people actually use {L4
|人们在很多嵌入式环境中使用 L4 ，

2674
01:22:09,780 --> 01:22:11,490
0,600 900,1140 1140,1380 1380,1470 1470,1710
-} {} in a bunch

2675
01:22:11,490 --> 01:22:13,200
0,60 60,390 390,990 990,1380 1380,1710
of embedded situations,| particularly its
|特别是它用得很多，

2676
01:22:13,200 --> 01:22:14,400
0,240 240,300 300,810 960,1170 1170,1200
used a lot,| there are
|智能手机上运行 L4 的例子很多，

2677
01:22:14,400 --> 01:22:15,720
0,240 240,780 780,870 870,1050 1050,1320
many instances of {L4 -}

2678
01:22:15,720 --> 01:22:18,210
0,360 360,750 900,1380 1410,1560 1560,2490
running in {} in smartphones,|
|

2679
01:22:18,630 --> 01:22:20,730
0,510 780,1590 1590,1740 1740,1950 1950,2100
{} hidden from view but
隐藏在人们的视线之外，但不管怎样，

2680
01:22:20,730 --> 01:22:21,840
0,780
nevertheless,|
|

2681
01:22:22,160 --> 01:22:23,300
0,150 150,360 360,660 660,960 960,1140
and all running various kinds
并且所有运行的各种自定义软件，

2682
01:22:23,300 --> 01:22:24,740
0,60 60,360 360,780 780,1110 1140,1440
of custom software,| not not
|在这种情况下，它们不必与 Unix 兼容，

2683
01:22:24,740 --> 01:22:26,210
0,390 690,990 990,1110 1110,1230 1230,1470
running, they don't have to

2684
01:22:26,270 --> 01:22:29,420
0,270 270,1020 1020,1290 1710,2460 2940,3150
have compatibility with Unix, in

2685
01:22:29,420 --> 01:22:31,970
0,180 180,990 1320,1860 1860,2310 2310,2550
these situations,| micro kernels in
|微内核在其他更一般的情况下，

2686
01:22:32,060 --> 01:22:33,830
0,450 450,660 660,1050 1050,1620 1620,1770
other more general situations| like
|如工作站或服务器中从未真正流行起来，

2687
01:22:33,830 --> 01:22:36,500
0,630 630,690 690,1230 1230,1800 2040,2670
workstations or servers never really

2688
01:22:36,500 --> 01:22:38,150
0,390 390,840 840,1110 1200,1500 1500,1650
caught on,| and it's not
|这并不是因为这个设计一定有什么问题，

2689
01:22:38,150 --> 01:22:39,890
0,210 210,510 540,1170 1170,1470 1470,1740
because there's necessarily anything wrong

2690
01:22:39,890 --> 01:22:41,540
0,120 120,270 270,960 1080,1350 1350,1650
with that design,| it's just
|只是为了取代一些现有的软件，

2691
01:22:41,570 --> 01:22:42,680
0,180 180,300 300,690 720,840 840,1110
they would have in order

2692
01:22:42,680 --> 01:22:46,010
0,150 150,780 780,960 960,1980 2400,3330
to displace some existing software,|
|

2693
01:22:46,160 --> 01:22:47,480
0,360 360,600 600,1020 1020,1260 1260,1320
your new thing has to
你的新东西必须是更好的，

2694
01:22:47,480 --> 01:22:48,980
0,330 330,450 450,540 540,840 840,1500
be you know like better,|
|

2695
01:22:48,980 --> 01:22:50,270
0,180 180,450 450,570 570,690 690,1290
so people will be motivated
让人们将会被激励去转换。

2696
01:22:50,270 --> 01:22:51,340
0,90 90,810
to switch.|
|

2697
01:22:51,520 --> 01:22:52,570
0,210 210,390 390,660 660,930 930,1050
And these micro kernels were
这些微内核是很好的，自然优雅，

2698
01:22:52,570 --> 01:22:55,720
0,450 450,990 1440,1890 1890,2520
perfectly good, naturally elegant,|
|

2699
01:22:55,840 --> 01:22:57,040
0,480 510,630 630,690 690,810 810,1200
{} but it was hard
但是人们很难确切指出

2700
01:22:57,040 --> 01:22:57,940
0,60 60,420 420,540 540,810 810,900
to put, for people to

2701
01:22:57,940 --> 01:22:58,810
0,120 120,240 240,570 570,660 660,870
put their finger on,| why
|为什么它要好得多，

2702
01:22:58,810 --> 01:23:00,190
0,120 120,540 570,810 810,1020 1020,1380
it was so much better,|
|

2703
01:23:00,190 --> 01:23:01,060
0,120 120,270 270,630 630,780 780,870
that they should go to
他们应该不厌其烦地

2704
01:23:01,060 --> 01:23:02,800
0,90 90,750 840,1110 1110,1560 1560,1740
the trouble| of switching from
|从 Linux 或他们正在运行的切换过来，

2705
01:23:02,800 --> 01:23:03,850
0,480 480,540 540,810 810,930 930,1050
Linux or whatever they were

2706
01:23:03,850 --> 01:23:07,330
0,510 960,1440 1530,1980 1980,2460 3030,3480
running {} fits,| so it
|所以它从来没有真正流行起来，

2707
01:23:07,330 --> 01:23:08,410
0,240 240,450 450,690 690,900 900,1080
never really caught on,| not
|不一定是出于很好的原因，

2708
01:23:08,410 --> 01:23:10,000
0,570 570,690 690,870 870,1380 1380,1590
necessarily for good reasons,| but
|因为它们看起来要好得多。

2709
01:23:10,480 --> 01:23:12,580
0,810 810,900 900,1200 1320,1560 1560,2100
because they were like dramatically

2710
01:23:12,580 --> 01:23:13,360
0,330
better.|
|

2711
01:23:13,590 --> 01:23:15,000
0,240 240,300 300,450 450,810 990,1410
On the other hand,| many
另一方面，|来自这个架构的许多想法都产生了持久的影响，

2712
01:23:15,000 --> 01:23:17,130
0,450 450,600 600,780 780,1590 1620,2130
ideas from this architecture had

2713
01:23:17,130 --> 01:23:20,340
0,90 90,540 540,1230 1470,1980 2730,3210
a lasting impact,| {} the
|人们得出，

2714
01:23:20,400 --> 01:23:21,840
0,570 600,990 990,1080 1080,1170 1170,1440
the people have to work

2715
01:23:21,840 --> 01:23:24,030
0,480 870,1260 1290,1530 1530,1680 1680,2190
out| {} much more interesting
|更多有趣和灵活的方式来使用虚拟内存，

2716
01:23:24,030 --> 01:23:25,500
0,120 120,570 570,900 900,990 990,1470
and flexible ways of using

2717
01:23:25,620 --> 01:23:27,210
0,360 360,930 930,1050 1050,1290 1290,1590
virtual memory| in order to
|为了在微内核上支持操作系统，

2718
01:23:27,510 --> 01:23:29,370
0,810 810,1200 1200,1650 1650,1740 1740,1860
support operating systems on their

2719
01:23:29,370 --> 01:23:31,350
0,300 300,840 1020,1410 1410,1590 1590,1980
micro kernels| {} and those
|这些更复杂的接口

2720
01:23:31,350 --> 01:23:33,630
0,240 240,900 900,1710 1770,2160 2160,2280
more sophisticated interfaces| made their
|通过 mmap 等方式进入 Linux 等主流操作系统，

2721
01:23:33,630 --> 01:23:34,650
0,300 300,540 540,750 750,900 900,1020
way through things like {mmap

2722
01:23:34,650 --> 01:23:35,580
0,540
-}

2723
01:23:35,610 --> 01:23:37,740
0,450 480,780 780,1260 1260,1650 1650,2130
{} into mainstream operating systems

2724
01:23:37,740 --> 01:23:40,440
0,210 210,810 1350,1860 2010,2400 2400,2700
like Linux,| {} this idea
|这种在顶层运行操作系统的想法，

2725
01:23:40,440 --> 01:23:41,820
0,150 150,510 510,720 720,1080 1080,1380
of running an operating system

2726
01:23:41,820 --> 01:23:43,320
0,180 180,270 270,420 420,1050
kind of on top,|
|

2727
01:23:43,320 --> 01:23:44,460
0,270 270,420 420,570 660,900 900,1140
{} as a as a
作为低级操作系统之上的服务器，

2728
01:23:44,910 --> 01:23:46,680
0,870 870,1020 1020,1380 1380,1500 1500,1770
server on top of a

2729
01:23:46,710 --> 01:23:48,600
0,360 360,570 570,960 960,1440 1560,1890
lower level operating system,| is
|在今天以虚拟机监视器的形式非常流行，

2730
01:23:48,600 --> 01:23:50,190
0,630 630,1020 1020,1410 1410,1500 1500,1590
extremely popular today in the

2731
01:23:50,190 --> 01:23:51,840
0,330 330,510 570,840 840,1230 1230,1650
form of {} virtual machine

2732
01:23:51,840 --> 01:23:53,340
0,660 660,840 840,1020 1020,1350 1350,1500
monitors,| which use all over
|它们在各地使用各种云托管服务。

2733
01:23:53,340 --> 01:23:54,630
0,90 90,510 510,780 990,1230 1230,1290
the place and sort of

2734
01:23:54,630 --> 01:23:57,580
0,360 360,750 750,1590 1830,2490
cloud hosting services {}.|
|

2735
01:23:57,610 --> 01:23:58,990
0,180 180,630 630,750 750,1200 1200,1380
The desire for {extensibility -
对可扩展性的需求，你可以修改用户级服务，

2736
01:23:58,990 --> 01:24:01,580
0,360 480,810 810,990 1020,1950
-}, you could modify

2737
01:24:01,640 --> 01:24:03,710
0,570 900,1050 1050,1290 1290,1500 1500,2070
{} a user level service,|
|

2738
01:24:03,770 --> 01:24:05,390
0,510 510,660 660,900 900,1260 1260,1620
the way that played out
在 Linux 中发挥作用的方式是可加载的内核模块，

2739
01:24:05,390 --> 01:24:06,830
0,390 420,630 630,780 780,1230 1230,1440
in things like Linux was

2740
01:24:06,830 --> 01:24:08,420
0,120 120,390 390,750 750,1440 1440,1590
{loadable -} kernel modules| which
|允许你动态加载修改 Linux 内核的工作方式，

2741
01:24:08,420 --> 01:24:10,580
0,270 270,390 390,630 720,1230 1410,2160
allow you to load, modify

2742
01:24:10,580 --> 01:24:11,810
0,90 90,240 240,450 480,900 900,1230
the way the Linux kernel

2743
01:24:11,810 --> 01:24:14,180
0,240 240,360 360,450 450,1020 2100,2370
works on the fly,| and
|当然还有客户端服务器的类型，

2744
01:24:14,180 --> 01:24:15,320
0,90 90,420 420,720 780,1080 1080,1140
of course the sort of

2745
01:24:15,320 --> 01:24:17,090
0,510 510,960 960,1230 1230,1680 1680,1770
client server,| good support for
|对客户端服务器体系结构的良好支持，

2746
01:24:17,090 --> 01:24:19,180
0,180 180,510 510,810 810,1560
this client server architecture,|
|

2747
01:24:19,180 --> 01:24:20,050
0,300 300,480 480,600 600,720 720,870
also made its way into
也进入了像 MacOS 这样的内核，

2748
01:24:20,050 --> 01:24:21,400
0,330 330,540 540,840 840,930 930,1350
kernels like {MacOS - -},|
|

2749
01:24:21,400 --> 01:24:22,930
0,330 330,540 540,720 720,1320 1320,1530
which has good IPC and
它具有良好的 IPC 和良好的客户端服务器。

2750
01:24:23,200 --> 01:24:24,540
0,210 210,450 450,840
good client server.|
|

2751
01:24:25,700 --> 01:24:26,240
0,120 120,270 270,390 390,450 450,540
And that's all I have
这就是我对这堂课要说的全部内容，

2752
01:24:26,240 --> 01:24:27,320
0,90 90,240 240,360 360,510 510,1080
to say for this lecture,|
|

2753
01:24:27,350 --> 01:24:29,270
0,600 840,1260 1260,1590 1590,1680 1680,1920
{} I'm happy to stick
我很乐意留下来回答问题，谢谢。

2754
01:24:29,270 --> 01:24:31,700
0,570 840,960 960,1770 1920,2280 2280,2430
around for questions, thank you.|
|

2755
01:24:36,690 --> 01:24:37,860
0,300 300,600
Thank you.|
谢谢。|

2756
01:24:37,950 --> 01:24:39,180
0,150 150,450
You're welcome.|
不用谢。|

2757
01:24:40,150 --> 01:24:41,590
0,390 390,540 540,870 870,990 990,1440
Oh, I wanted to ask,|
哦，我想问一下，|

2758
01:24:41,590 --> 01:24:43,150
0,150 150,240 240,660 660,810 810,1560
so the paper we're talking
我们现在讨论的论文关于页表，

2759
01:24:43,180 --> 01:24:45,800
0,840 960,2100
about virtual,

2760
01:24:45,800 --> 01:24:48,100
0,360 390,810 810,1110 1110,1800
{} about page tables,|
|

2761
01:24:48,100 --> 01:24:49,720
0,360 450,630 630,870 870,1260 1260,1620
at I think {4.2 -
我想是在 4.2 ，

2762
01:24:49,720 --> 01:24:52,390
0,570 750,1860 1890,2010 2010,2250 2250,2670
-}| and it was saying
|它说的是如何，

2763
01:24:52,390 --> 01:24:53,700
0,600
how,|
|

2764
01:24:54,960 --> 01:24:55,950
0,210 210,450 450,510 510,780 780,990
I think it was kind
我想这和你之前提到的差不多，

2765
01:24:55,950 --> 01:24:57,330
0,90 90,480 480,690 690,810 810,1380
of what what you mentioned

2766
01:24:57,330 --> 01:24:59,220
0,690 720,1170 1170,1380 1380,1590 1590,1890
before,| where you said that
|你说有一种错误的方式可以做到这一点，

2767
01:24:59,730 --> 01:25:01,530
0,600 960,1230 1230,1350 1350,1590 1590,1800
there is a wrong way

2768
01:25:01,530 --> 01:25:03,720
0,120 120,300 300,720 1050,1320 1320,2190
to do that,| I think
|我想可能有点类似，

2769
01:25:03,750 --> 01:25:04,860
0,180 180,390 390,720 720,810 810,1110
might be kind of similar

2770
01:25:04,860 --> 01:25:07,040
0,90 90,480 510,1170 1200,1680
to that,| but {}
|但是如果做这件事，

2771
01:25:07,740 --> 01:25:09,510
0,210 210,360 360,660 660,1230 1260,1770
if you do this, this

2772
01:25:09,510 --> 01:25:11,010
0,210 210,300 300,420 420,990 990,1500
thing| that you explain this
|你现在在照片里解释的这件事，

2773
01:25:12,130 --> 01:25:14,280
0,420 420,660 660,990 990,1500
in your picture now,|
|

2774
01:25:14,280 --> 01:25:16,140
0,480 480,660 660,810 810,1290
{} would it be,
在这种情况下，页表是如何工作的？

2775
01:25:16,530 --> 01:25:17,520
0,150 150,390 390,690 690,870 870,990
I guess how how would

2776
01:25:17,520 --> 01:25:19,860
0,480 540,1500 1500,1950 1950,2130 2130,2340
the {page,tables} work in this

2777
01:25:19,860 --> 01:25:23,040
0,570 690,1530 2070,2490 2490,2940 2940,3180
case?| Well, are you, you
|好的，你可能指的是 4.3 节，双空间错误。

2778
01:25:23,040 --> 01:25:24,330
0,120 120,240 240,570 570,690 930,1290
may be referring to section

2779
01:25:24,330 --> 01:25:25,380
0,180 180,390 390,660 660,780 780,1050
{4.3 - -} the dual

2780
01:25:25,380 --> 01:25:28,380
0,420 420,990 1230,1770
space mistake.| {Oh,yes,sorry,4.3}.|
|哦，是的，抱歉， 4.3 。|

2781
01:25:28,380 --> 01:25:29,220
0,300 300,510 510,660 660,720 720,840
{} Yeah, that's a bit
是的，这是一个有点复杂的故事，

2782
01:25:29,220 --> 01:25:30,930
0,90 90,150 150,900 930,1440 1440,1710
of a complicated story,| but
|但让我们看看，

2783
01:25:31,050 --> 01:25:34,840
0,810 2010,2370 2370,2610 2610,2940
the {} let's see,|
|

2784
01:25:35,710 --> 01:25:36,850
0,330 330,390 390,450 450,1020 1020,1140
part of the background is
背景的一部分是 Linux 在那些日子里的工作方式，

2785
01:25:36,850 --> 01:25:38,110
0,120 120,270 270,480 480,960 960,1260
the way that Linux worked

2786
01:25:38,110 --> 01:25:39,790
0,90 90,330 330,810 810,1110 1380,1680
in those days,| and indeed
|事实上，直到最近，都是

2787
01:25:39,790 --> 01:25:42,490
0,240 240,840 900,1230 1230,1650 1770,2700
until recently is that| the
|当你在用户级别运行时，

2788
01:25:42,880 --> 01:25:43,930
0,180 180,330 330,600 600,780 780,1050
when you're running at user

2789
01:25:43,930 --> 01:25:46,060
0,450 930,1380 1380,1500 1500,1890 1890,2130
level,| {} the page table,
|页表实际上有，

2790
01:25:46,060 --> 01:25:47,560
0,150 150,540 540,750 750,1350 1380,1500
this actually has| both the
|进程页面，用户级页映射，

2791
01:25:47,560 --> 01:25:49,690
0,570 570,1080 1080,1500 1500,1830 1830,2130
processe's pages, {user,level} pages mapped

2792
01:25:49,690 --> 01:25:50,680
0,180 270,600 600,840 840,930 930,990
in| and all of the
|并且所有内核都映射到这个页表中，

2793
01:25:50,680 --> 01:25:51,880
0,300 300,630 630,780 780,930 930,1200
kernel mapped into that one

2794
01:25:51,880 --> 01:25:53,100
0,360 360,720
page table,|
|

2795
01:25:53,300 --> 01:25:55,760
0,420 420,1230 1230,1590 1620,2040 2070,2460
on xv6 anyway,| so when
在 x86 上，|所以，当你进行系统调用并跳入内核时，

2796
01:25:55,760 --> 01:25:57,320
0,90 90,270 270,480 510,1020 1020,1560
you made {} system call,

2797
01:25:58,220 --> 01:25:59,600
0,300 300,600 600,750 750,840 840,1380
and jumped into the kernel,|
|

2798
01:26:00,140 --> 01:26:01,490
0,180 180,480 480,660 660,1020 1020,1350
the kernel was already mapped
内核已映射到页表中，

2799
01:26:01,490 --> 01:26:02,930
0,180 180,240 240,540 540,1020 1260,1440
into the page table| and
|因此不需要页表切换，

2800
01:26:02,930 --> 01:26:04,280
0,270 270,450 450,780 780,1050 1050,1350
therefore no page table switch

2801
01:26:04,280 --> 01:26:05,870
0,150 150,810 1200,1380 1380,1470 1470,1590
was required,| when you make
|当你进行系统调用时，

2802
01:26:05,870 --> 01:26:07,250
0,60 60,360 360,750 750,1230 1230,1380
a system call,| its that
|它的成本要低得多，

2803
01:26:07,250 --> 01:26:08,150
0,150 150,270 270,600 600,690 690,900
much more expensive and much

2804
01:26:08,150 --> 01:26:09,860
0,180 180,780 1140,1530 1530,1620 1620,1710
more cheaper,| because there was
|因为没有页表切换，

2805
01:26:09,860 --> 01:26:10,910
0,120 120,390 390,660 660,960 960,1050
no page table switch,| if
|如果你在 xv6 中调用，

2806
01:26:10,910 --> 01:26:12,020
0,120 120,360 360,510 510,630 630,1110
you're {call,in} {xv6 - -},|
|

2807
01:26:12,020 --> 01:26:13,220
0,90 90,210 210,420 510,990 990,1200
you know the trampoline code
你知道 trampoline 代码切换页表，

2808
01:26:13,220 --> 01:26:16,070
0,300 300,570 570,900 900,1350 2670,2850
switches page tables,| which is
|这是一件昂贵的事情，

2809
01:26:16,070 --> 01:26:17,060
0,60 60,540 540,690 690,780 780,990
an expensive thing to do,|
|

2810
01:26:17,060 --> 01:26:17,900
0,270 270,420
because it
因为它刷新虚拟到物理映射的 TLB 高速缓存。

2811
01:26:17,900 --> 01:26:19,010
0,180 180,510 510,660 660,900 930,1110
{} {flushs -} the {TLB

2812
01:26:19,010 --> 01:26:21,140
0,210 210,570 600,1170 1170,1530 1650,2130
- -} cache of virtual

2813
01:26:21,140 --> 01:26:22,720
0,60 60,390 390,1050
to physical mappings.|
|

2814
01:26:22,810 --> 01:26:24,430
0,330 330,480 480,600 600,1080 1080,1620
Anyway, so for efficiency,| Linux
无论如何，为了提高效率，|Linux 在同一页表中映射内核和用户空间，

2815
01:26:24,430 --> 01:26:26,110
0,240 240,450 840,1230 1230,1500 1500,1680
used to map kernel and

2816
01:26:26,110 --> 01:26:27,010
0,210 210,480 480,570 570,660 660,900
user space in the same

2817
01:26:27,010 --> 01:26:29,340
0,270 270,750 1020,1230 1230,1830
page table| had fast
|具有很快的系统调用，

2818
01:26:29,340 --> 01:26:30,630
0,360 360,630 630,690 690,750 750,1290
system calls as a result,|
|

2819
01:26:30,660 --> 01:26:35,400
0,780 1890,2070 2070,2730 2730,3570 3930,4740
{} so they { -}
原因并不是很清楚，

2820
01:26:36,100 --> 01:26:36,850
0,120 120,360 360,450 450,600 600,750
for reasons that aren't very

2821
01:26:36,850 --> 01:26:39,070
0,360 360,810 810,1140 1560,1770 1770,2220
clear,| decided to do this
|他们决定执行相同的操作来设置 Unix 服务器中的映射。

2822
01:26:39,540 --> 01:26:40,770
0,450 450,780 780,870 870,1140 1140,1230
same thing to setup the

2823
01:26:40,770 --> 01:26:42,360
0,390 390,540 540,600 600,960 960,1590
mapping in the Unix server.|
|

2824
01:26:43,950 --> 01:26:45,060
0,540
Well,
好的，他们想要的是，

2825
01:26:45,320 --> 01:26:46,610
0,450 450,540 540,930 930,1110 1110,1290
what they wanted was that|

2826
01:26:46,610 --> 01:26:47,820
0,570
when
当 VI ，当一个进程将系统调用发送到这里时，

2827
01:26:48,030 --> 01:26:50,010
0,690 690,900 900,1140 1140,1620 1620,1980
VI, when a process {send,a}

2828
01:26:50,010 --> 01:26:51,690
0,330 330,570 570,750 750,1170 1260,1680
system call over here,| they
|他们希望页表处于活动状态，

2829
01:26:51,690 --> 01:26:52,800
0,330 330,450 450,690 690,780 780,1110
wanted to have the page

2830
01:26:52,800 --> 01:26:54,090
0,270 270,360 360,480 480,990 990,1290
table that was active,| well,
|在 Linux 服务器上处理那个系统调用的时候，

2831
01:26:54,860 --> 01:26:56,000
0,180 180,540
in the

2832
01:26:56,570 --> 01:26:57,830
0,330 330,540 540,750 750,1110 1110,1260
Linux server while processing that

2833
01:26:57,830 --> 01:26:59,780
0,300 300,600 690,1530 1560,1830 1830,1950
system call,| include all the
|包括所有虚拟内存映射，

2834
01:26:59,780 --> 01:27:01,730
0,390 390,840 840,1380 1380,1650 1650,1950
virtual memory {mappings - -},|
|

2835
01:27:01,730 --> 01:27:03,380
0,180 180,330 330,660 900,1530 1530,1650
mappings for the process that
send 系统调用的进程的映射。

2836
01:27:03,380 --> 01:27:05,300
0,420 420,600 600,990 990,1350
sent the system call.|
|

2837
01:27:05,360 --> 01:27:06,520
0,630

2838
01:27:06,980 --> 01:27:07,610
0,120 120,240 240,330 330,510 510,630
And that at least would
这至少使它，

2839
01:27:07,610 --> 01:27:08,560
0,150 150,360
make it|
|

2840
01:27:09,030 --> 01:27:10,500
0,240 240,750 750,840 840,1140 1140,1470
{} simpler to look up
更容易的查找传给系统调用参数的虚拟地址，

2841
01:27:10,830 --> 01:27:13,170
0,360 360,1380 1500,1950 1950,2040 2040,2340
virtual addresses past a system

2842
01:27:13,170 --> 01:27:15,030
0,210 210,600 600,900 900,1380 1380,1860
call arguments,| like {pass,to} read,|
|比如发送给 read ，|

2843
01:27:15,720 --> 01:27:17,520
0,270 270,510 510,660 660,1260 1530,1800
the reason why this worked
之所以效果不佳，

2844
01:27:17,520 --> 01:27:18,390
0,150 150,660 660,780 780,810 810,870
out poorly,| there are a
|原因有很多，

2845
01:27:18,390 --> 01:27:19,740
0,240 240,330 330,690 690,990 990,1350
bunch of reasons,| one is
|一是 L4 对 Linux 的东西一无所知，

2846
01:27:19,740 --> 01:27:21,520
0,450
that,

2847
01:27:21,750 --> 01:27:23,520
0,480 480,1020 1020,1410 1410,1650 1650,1770
{L4 -} which doesn't know

2848
01:27:23,520 --> 01:27:24,420
0,330 330,570 570,720 720,780 780,900
anything about any of Linux

2849
01:27:24,420 --> 01:27:26,010
0,450 600,960 960,1260 1260,1440 1440,1590
stuff,| {L4 -} just knows
|L4 只知道有两个进程，

2850
01:27:26,010 --> 01:27:27,990
0,180 180,300 300,1140 1140,1500 1530,1980
there's two processes| and so
|所以，当你将 IPC 从一个进程发送到另一个进程时，

2851
01:27:28,110 --> 01:27:29,400
0,150 150,390 450,720 720,780 780,1290
when you send an IPC

2852
01:27:29,400 --> 01:27:30,270
0,120 120,240 240,480 480,570 570,870
from one process to another,|
|

2853
01:27:30,270 --> 01:27:32,100
0,240 240,450 450,840 840,1140 1140,1830
L4 just switches page tables,|
L4 只是切换页表，|

2854
01:27:32,370 --> 01:27:33,570
0,210 210,420 420,600 600,930 930,1200
it always just switches {page,tables},|
它总是只切换页表，|

2855
01:27:33,570 --> 01:27:35,220
0,120 120,240 240,660 660,1110 1140,1650
{this -} guy {the,page,table}, VI,
这个页表， VI 的页表，

2856
01:27:35,220 --> 01:27:37,320
0,90 90,360 360,780 1410,1830 1830,2100
the page table,| {L4 -}
|L4 将页表与 Linux 内核相关联，

2857
01:27:37,320 --> 01:27:38,460
0,480 480,540 540,780 780,990 990,1140
associates a page table with

2858
01:27:38,460 --> 01:27:39,960
0,330 330,630 630,930 930,1170 1170,1500
Linux kernel,| just always switches
|只是总是切换页表，

2859
01:27:39,960 --> 01:27:41,940
0,240 240,660 750,1110 1140,1650 1650,1980
page tables,| so you couldn't
|所以，你甚至不能，

2860
01:27:41,940 --> 01:27:43,440
0,390 390,600 600,660 660,870 870,1500
even| due the {L4 -}
|由于 L4 系统调用的实现方式不同，

2861
01:27:43,590 --> 01:27:44,380
0,150 150,390
due to

2862
01:27:44,410 --> 01:27:45,460
0,150 150,420 420,480 480,810 810,1050
the different way system calls

2863
01:27:45,460 --> 01:27:46,660
0,60 60,540 540,780 870,990 990,1200
are implemented| and the fact
|并且涉及 L4 的事实是，

2864
01:27:46,660 --> 01:27:48,070
0,120 480,750 750,900 900,1020 1020,1410
that {L4 -} was involved,|
|

2865
01:27:48,160 --> 01:27:49,240
0,210 210,360 360,660 660,960 960,1080
there was no way to
在系统调用期间没有办法保留页表，

2866
01:27:49,240 --> 01:27:50,920
0,420 420,510 510,810 810,1290 1410,1680
preserve the page table during

2867
01:27:50,920 --> 01:27:52,200
0,60 60,360 360,750
a system call,|
|

2868
01:27:52,230 --> 01:27:54,240
0,150 150,330 330,570 570,1080 1620,2010
that just wasn't possible,| because
那是不可能的，|因为 L4 总是切换页表，

2869
01:27:54,390 --> 01:27:56,640
0,510 510,930 930,1320 1320,1560 1560,2250
L4 always switched page tables|
|

2870
01:27:56,940 --> 01:27:57,810
0,210 210,300 300,570 570,690 690,870
when it switched from one
当它在从一个进程切换到另一个进程时，

2871
01:27:57,810 --> 01:27:58,950
0,420 420,540 540,840 870,1050 1050,1140
process to another,| so they
|所以，他们永远不会获得无需切换页表的效率优势，

2872
01:27:58,950 --> 01:28:00,000
0,150 150,420 420,540 540,630 630,1050
were never going to get

2873
01:28:00,000 --> 01:28:01,530
0,120 120,750 750,1170 1170,1290 1290,1530
the efficiency win of not

2874
01:28:01,530 --> 01:28:03,000
0,210 210,270 270,540 540,810 810,1470
having to switch page tables,|
|

2875
01:28:03,030 --> 01:28:04,520
0,960
when
当它一旦从用户到内核的切换时。

2876
01:28:04,520 --> 01:28:06,140
0,180 180,480 720,990 990,1110 1110,1620
{} that once a crossing

2877
01:28:06,140 --> 01:28:08,060
0,240 570,870 870,1260 1260,1410 1410,1920
from from user to kernel.|
|

2878
01:28:08,860 --> 01:28:11,080
0,450 990,1590 1620,1740 1740,1920 1920,2220
{} But I think they
但我认为他们想要方便

2879
01:28:11,110 --> 01:28:13,060
0,390 390,480 480,1260 1260,1710 1740,1950
wanted the convenience| of being
|能够直接使用用户提供的虚拟地址，

2880
01:28:13,060 --> 01:28:14,780
0,150 150,240 240,720 720,1290
able to directly use

2881
01:28:14,970 --> 01:28:16,830
0,240 240,510 510,840 840,1110 1110,1860
{} user supplied virtual addresses,|
|

2882
01:28:17,630 --> 01:28:19,180
0,180 180,360 360,600 600,960
but that meant that
但这意味着映射是活跃的，

2883
01:28:19,630 --> 01:28:20,980
0,660 660,750 750,930 930,1260 1260,1350
{mappings -} they needed to

2884
01:28:20,980 --> 01:28:22,960
0,120 120,780 810,1440 1440,1590 1590,1980
be active| depended on which
|取决于它们代表哪个进程执行系统调用，

2885
01:28:22,960 --> 01:28:25,660
0,990 1050,1350 1350,1530 1530,2070 2070,2700
process they were executing a

2886
01:28:25,660 --> 01:28:26,860
0,360 360,540 540,630 630,1020 1020,1200
system call on behalf of,|
|

2887
01:28:27,160 --> 01:28:27,970
0,180 180,270 270,510 510,660 660,810
so there couldn't be any
所以 Linux 不可能有任何一个页表，

2888
01:28:27,970 --> 01:28:30,010
0,360 360,690 690,1140 1140,1290 1290,2040
one page table for Linux,|
|

2889
01:28:31,330 --> 01:28:32,710
0,390 390,930 930,1050 1050,1260 1260,1380
{page,table} Linux {sort,of} one is
LINUX 页表是否使用取决于发送系统调用 RPC 的进程，

2890
01:28:32,710 --> 01:28:34,090
0,300 300,600 600,690 690,840 840,1380
used depends on what process

2891
01:28:34,090 --> 01:28:35,280
0,720
sent

2892
01:28:35,430 --> 01:28:37,740
0,300 300,510 510,1080 1110,1650 1650,2310
system call RPC,| {but,L4 -}
|但是 L4 不知道怎么玩这个游戏，

2893
01:28:37,950 --> 01:28:38,880
0,510 510,690 690,750 750,840 840,930
did not know how to

2894
01:28:38,880 --> 01:28:40,170
0,210 210,390 390,750 960,1140 1140,1290
play that game,| {L4 -}
|L4 将单个页表与每个进程与每个任务相关联，

2895
01:28:40,170 --> 01:28:42,150
0,540 540,660 660,1290 1320,1650 1650,1980
associated a single page table

2896
01:28:42,150 --> 01:28:43,830
0,150 150,270 270,1080 1290,1500 1500,1680
with each process with each

2897
01:28:43,830 --> 01:28:46,260
0,690 930,1170 1170,1440 1740,1920 1920,2430
task,| and so in order
|所以它只会切换到那个页表，

2898
01:28:46,530 --> 01:28:47,190
0,120 120,180 180,270 270,420 420,660
and it would just switch

2899
01:28:47,190 --> 01:28:48,090
0,60 60,210 210,450 450,720 720,900
to that page table,| so
|所以运气不好，

2900
01:28:48,090 --> 01:28:49,290
0,240 240,750 750,840 840,1020 1020,1200
tough luck,| {Linux -} didn't
|Linux 没有任何方法使页表不同，

2901
01:28:49,290 --> 01:28:50,600
0,150 150,300 300,510 510,780
have any way to

2902
01:28:51,560 --> 01:28:52,520
0,330 330,390 390,630 630,870 870,960
cause the page table to

2903
01:28:52,520 --> 01:28:53,600
0,330 330,660 660,810 810,960 960,1080
differ| depending on who it's
|根据 send 系统调用的不同，

2904
01:28:53,600 --> 01:28:55,730
0,510 840,900 900,1140 1440,1800 1800,2130
sent to the system call,|
|

2905
01:28:56,210 --> 01:28:57,050
0,300 300,450 450,510 510,720 720,840
in order to deal with
为了解决这个问题，

2906
01:28:57,050 --> 01:28:59,300
0,420 600,1680
that,| apparently
|他们制作了一堆内核的共享内存副本，

2907
01:28:59,450 --> 01:29:00,710
0,420 420,660 660,720 720,1020 1020,1260
they made a bunch of

2908
01:29:00,770 --> 01:29:02,540
0,630 630,960 960,1590 1590,1680 1680,1770
shared memory copies of the

2909
01:29:02,540 --> 01:29:03,720
0,630
kernel,|
|

2910
01:29:03,720 --> 01:29:06,480
0,810 990,1260 1260,1650 1650,2610 2640,2760
one for each process| and
每个进程一个，|所以每个内核的共享内存副本，

2911
01:29:06,480 --> 01:29:07,410
0,150 180,450 450,510 510,660 660,930
so each of these shared

2912
01:29:07,410 --> 01:29:08,700
0,300 300,630 630,690 690,750 750,1290
memory copies of the kernel,|
|

2913
01:29:09,290 --> 01:29:10,820
0,180 180,300 300,810 810,1080 1110,1530
{} had exact had all
将所有内核内存映射到其中，

2914
01:29:10,820 --> 01:29:12,410
0,90 90,150 150,750 780,1260 1260,1590
of the kernel memory mapped

2915
01:29:12,410 --> 01:29:13,220
0,300 300,450 450,600 600,690 690,810
into it,| so they were
|所以它们都是相同的内核数据结构，

2916
01:29:13,220 --> 01:29:14,990
0,330 900,1020 1020,1260 1260,1560 1560,1770
all the same kernel data

2917
01:29:14,990 --> 01:29:17,750
0,570 600,1110 1200,1590 1590,2430 2460,2760
structures,| but each process had
|但是每个进程都有一个与之相关联的专用内核任务，

2918
01:29:17,750 --> 01:29:19,380
0,150 150,1110
a dedicated

2919
01:29:21,100 --> 01:29:22,780
0,390 390,780 780,1380 1380,1530 1530,1680
kernel task associated with it|
|

2920
01:29:22,780 --> 01:29:25,360
0,150 150,720 990,1620 1620,2190 2280,2580
and therefore that basically allowed
所以，这允许他们对 L4 使用技巧，

2921
01:29:25,360 --> 01:29:26,260
0,90 90,180 180,510 510,660 660,900
them to trick {L4 -}|
|

2922
01:29:26,260 --> 01:29:26,980
0,90 90,150 150,450 450,600 600,720
and to switch into the
并切换到适当的页表，

2923
01:29:26,980 --> 01:29:28,870
0,480 480,810 810,1170 1170,1290 1290,1890
appropriate page table,| that included
|包括进程加上内核，

2924
01:29:28,930 --> 01:29:31,090
0,450 450,1080 1080,1500 1500,1590 1590,2160
that process plus the kernel,|
|

2925
01:29:31,420 --> 01:29:33,070
0,660 660,780 780,960 960,1350 1350,1650
depending on which process {}
具体取决于哪个进程系统调用请求。

2926
01:29:33,070 --> 01:29:34,720
0,210 210,390 390,990
system call request.|
|

2927
01:29:34,720 --> 01:29:36,850
0,720 1200,1320 1320,1500 1500,1770 1770,2130
And you know I think
我觉得那挺管用的，

2928
01:29:36,850 --> 01:29:38,170
0,240 240,420 420,480 480,930 930,1320
that kind of worked,| but
|但是他们说他们工作很慢之类的，

2929
01:29:38,650 --> 01:29:39,430
0,150 150,420 420,600 600,690 690,780
I don't [] what they

2930
01:29:39,430 --> 01:29:40,720
0,210 210,330 330,690 690,840 840,1290
said they worked was slow

2931
01:29:40,720 --> 01:29:43,090
0,120 120,510 870,1920 1920,2250 2250,2370
or something,| because there were
|因为有很多任务。

2932
01:29:43,090 --> 01:29:44,540
0,30 30,210 210,270 270,990
a lot of tasks.|
|

2933
01:29:45,070 --> 01:29:46,220
0,480

2934
01:29:46,810 --> 01:29:48,280
0,300 300,450 450,660 660,1110 1110,1470
Anyway, it's a complicated story,|
不管怎么说，这是个复杂的故事，|

2935
01:29:48,280 --> 01:29:48,820
0,120 120,180 180,330 330,390 390,540
and I think it didn't
我认为这件事的效果不是很好。

2936
01:29:48,820 --> 01:29:49,570
0,180 180,300 300,450 450,630 630,750
work out very well for

2937
01:29:49,570 --> 01:29:52,360
0,630 990,1830 2160,2430 2430,2550 2550,2790
this.| Okay, okay I see,|
|好的，我明白了，|

2938
01:29:52,360 --> 01:29:53,350
0,120 120,510 540,660 660,840 840,990
I think I think that
我想这很好地解释了为什么这个东西更难，

2939
01:29:53,350 --> 01:29:56,170
0,870 900,1650 1650,2070 2100,2580 2580,2820
explains well why this thing

2940
01:29:56,170 --> 01:29:57,670
0,270 270,690 690,840 840,1080 1080,1500
is harder to do| than,
比我们做的 xv6 ，好的。

2941
01:29:58,100 --> 01:29:59,480
0,420 420,630 630,720 720,900 900,1380
well, what we do {xv6

2942
01:29:59,480 --> 01:30:00,760
0,240 240,690
-}, okay.|
|

2943
01:30:00,880 --> 01:30:02,200
0,360 360,480 480,690 690,990 990,1320
Yeah yeah, this, {} because
是的，这个，因为没有，

2944
01:30:02,200 --> 01:30:03,440
0,210 210,690
there's not,|
|

2945
01:30:03,500 --> 01:30:04,370
0,90 90,180 180,390 390,690 690,870
you have this picture {xv6
你有这张图片 xv6 甚至标准的 Linux

2946
01:30:04,370 --> 01:30:05,450
0,60 60,420 420,540 540,720 720,1080
- -} or even standard

2947
01:30:05,450 --> 01:30:06,830
0,300 300,570 600,870 870,1200 1200,1380
Linux| is much simpler than
|都比这个简单得多，

2948
01:30:06,830 --> 01:30:09,140
0,300 780,1020 1020,1230 1230,1590 1590,2310
this,| you're just jumping directly
|你只是直接跳到内核中，

2949
01:30:09,590 --> 01:30:10,760
0,420 420,480 480,840 840,1080 1080,1170
into the kernel| and the
|并且内核对所有分页硬件有直接控制权，

2950
01:30:10,760 --> 01:30:12,200
0,300 300,450 450,840 840,1080 1080,1440
kernel has control over direct

2951
01:30:12,200 --> 01:30:13,430
0,390 390,690 690,750 750,840 840,1230
control over all the paging

2952
01:30:13,430 --> 01:30:15,650
0,510 660,1050 1410,1740 1740,2070 2070,2220
hardware,| which doesn't have when
|当它运行 L4 时就没有了。

2953
01:30:15,650 --> 01:30:17,930
0,120 120,360 360,420 1470,1800 1980,2280
it runs L4.| Right, okay
|好的，我明白了，谢谢。

2954
01:30:17,930 --> 01:30:19,370
0,150 150,480 660,990 990,1230 1230,1440
I see, thank you, thank

2955
01:30:19,370 --> 01:30:20,240
0,450
you.|
|

2956
01:30:21,190 --> 01:30:23,590
0,150 150,330 330,750 750,1260 1530,2400
We're gonna ask, {} why,|
我们会问，为什么，|

2957
01:30:23,590 --> 01:30:25,990
0,750 810,990 990,1350 1350,1620 1620,2400
{ -} it seems like
看起来有些任务比其他任务更适合放在内核之外，

2958
01:30:26,380 --> 01:30:27,910
0,420 420,690 690,1140 1140,1260 1260,1530
some some tasks are more

2959
01:30:27,910 --> 01:30:29,920
0,660 660,780 780,1260 1290,1560 1560,2010
appropriate to be put outside

2960
01:30:29,920 --> 01:30:31,690
0,90 90,480 480,660 660,1260 1350,1770
the kernel than others,| but
|但是这个 L4 使用微内核的方法，

2961
01:30:31,690 --> 01:30:33,640
0,420 450,1020 1020,1440 1440,1560 1560,1950
this L4 like the approach

2962
01:30:33,640 --> 01:30:35,080
0,120 120,450 450,840 840,1170 1170,1440
with micro kernels| always seems
|似乎总是要么什么都有，要么什么都不是，

2963
01:30:35,080 --> 01:30:36,370
0,90 90,240 240,630 630,1170 1170,1290
to be either everything or

2964
01:30:36,370 --> 01:30:38,290
0,540 570,930 930,1500 1530,1770 1770,1920
nothing,| like either you have
|比如要么有一个宏内核来做所有的事情，要么什么都不做，

2965
01:30:38,290 --> 01:30:40,300
0,90 90,750 750,1080 1080,1440 1440,2010
a monolithic kernel doing everything

2966
01:30:40,300 --> 01:30:42,460
0,390 420,1050 1050,1290 1290,1590 1800,2160
or nothing,| just like I
|比如我觉得分页和其他一些事情在内核中可能非常有效，

2967
01:30:42,460 --> 01:30:44,350
0,120 120,420 420,1170 1170,1650 1650,1890
feel like paging and some

2968
01:30:44,350 --> 01:30:45,640
0,240 240,690 690,900 900,1050 1050,1290
other things could be very

2969
01:30:45,640 --> 01:30:47,170
0,480 480,840 840,960 960,1380 1380,1530
efficient inside the kernel,| and
|然后可能像文件系统，

2970
01:30:47,170 --> 01:30:48,970
0,360 420,750 750,960 960,1260 1260,1800
then maybe like file systems|
|

2971
01:30:48,970 --> 01:30:50,080
0,360 360,630 630,810 810,1020 1020,1110
that things that need to
需要交换的东西可能在外部，

2972
01:30:50,080 --> 01:30:51,160
0,150 150,510 510,780 780,960 960,1080
be {swappable -} could be

2973
01:30:51,160 --> 01:30:53,590
0,690 1260,1590 1590,1770 1770,1890 1890,2430
outside,| {} and then even
|然后，甚至可以拥有一个具有某些功能的内核，

2974
01:30:53,680 --> 01:30:54,760
0,300 300,480 480,630 630,900 900,1080
like you can maybe even

2975
01:30:54,760 --> 01:30:55,870
0,240 240,330 330,660 660,840 840,1110
have a kernel that has

2976
01:30:55,870 --> 01:30:57,250
0,150 150,870 870,1020 1020,1200 1200,1380
some functionality,| but you can
|但是你可以选择不使用它，而提供你自己的，

2977
01:30:57,250 --> 01:30:58,960
0,630 630,870 870,1230 1230,1500 1500,1710
opt to not use it

2978
01:30:58,960 --> 01:31:00,280
0,150 150,510 510,720 720,1020
and provide your own,|
|

2979
01:31:00,540 --> 01:31:02,430
0,150 150,330 330,810 1380,1740 1740,1890
is there any thing.| You
有没有什么。|你说的绝对是对的，

2980
01:31:02,430 --> 01:31:05,310
0,270 270,480 480,1710 2040,2400 2400,2880
say is absolutely well taken|
|

2981
01:31:05,310 --> 01:31:07,290
0,330 510,1170 1170,1260 1260,1590 1710,1980
and indeed there were a
确实有很多微内核或与微内核相关的项目，

2982
01:31:07,290 --> 01:31:08,520
0,270 270,330 330,720 720,1140 1140,1230
lot of micro kernel or

2983
01:31:08,520 --> 01:31:11,580
0,300 300,630 630,990 990,1920 2610,3060
micro kernel related projects| and
|它们中的许多制造了各种各样的混合内核，

2984
01:31:11,580 --> 01:31:12,930
0,300 300,390 390,690 690,1080 1080,1350
many of them built various

2985
01:31:12,930 --> 01:31:15,180
0,210 210,270 270,1020 1260,2100 2100,2250
kinds of hybrids,| like there's
|比如有几个不同版本的 Mach ，

2986
01:31:15,180 --> 01:31:16,260
0,240 240,270 270,540 540,780 780,1080
actually a couple different versions

2987
01:31:16,260 --> 01:31:17,220
0,120 120,480 480,630 630,840 840,960
of Mach| and some of
|其中一些是混合内核，

2988
01:31:17,220 --> 01:31:18,320
0,330
them

2989
01:31:18,640 --> 01:31:19,810
0,120 120,270 270,330 330,780 780,1170
{} sort of hybrid kernels,|
|

2990
01:31:19,810 --> 01:31:20,770
0,270 270,480 480,600 600,780 780,960
which yeah there was this
有这样一个微内核 IPC ，

2991
01:31:20,770 --> 01:31:21,760
0,270 270,480 480,600 600,690 690,990
micro kernel that knew about

2992
01:31:21,820 --> 01:31:23,530
0,750 750,930 930,1350 1440,1650 1650,1710
IPC,| but also in the
|但内核中是一个完整的 Unix ，

2993
01:31:23,530 --> 01:31:26,260
0,630 720,1320 1320,1410 1410,2190
kernel was a complete

2994
01:31:26,640 --> 01:31:28,680
0,840 990,1200 1200,1590 1590,1860 1860,2040
Unix,| so {for,instance} Mach {2.5
|比如， Mach 2.5 就是在内部使用混合内核，

2995
01:31:28,680 --> 01:31:30,280
0,270 270,1050
- -}

2996
01:31:30,340 --> 01:31:32,440
0,330 330,870 1110,1620 1620,1770 1770,2100
was this hybrid with it,|
|

2997
01:31:33,480 --> 01:31:35,070
0,240 240,480 480,810 810,1200 1200,1590
but micro kernel and Unix
微内核和 Unix 几乎都在同一个内核中。

2998
01:31:35,070 --> 01:31:35,670
0,210 210,390 390,450 450,540 540,600
all sort of in the

2999
01:31:35,670 --> 01:31:37,470
0,480 510,1020 1320,1560 1560,1710 1710,1800
same kernel| and you can
|你可以进行系统调用，

3000
01:31:37,470 --> 01:31:38,850
0,150 150,420 420,690 690,1260 1260,1380
make system calls either| and
|而且一些东西使用了微内核的方式，

3001
01:31:38,850 --> 01:31:40,200
0,180 180,450 450,600 600,960 960,1350
some stuff was built in

3002
01:31:40,680 --> 01:31:42,270
0,240 240,450 450,600 630,1260 1260,1590
the sort of micro kernel

3003
01:31:42,270 --> 01:31:43,680
0,270 270,420 420,630 630,1080 1080,1410
way,| but some things they
|但是有些东西他们只是用了 Mach 的内核，

3004
01:31:43,680 --> 01:31:44,910
0,90 90,270 270,570 690,870 870,1230
were just used the kernel

3005
01:31:44,910 --> 01:31:46,380
0,120 120,270 270,450 450,990 1260,1470
that was in Mach,| that
|它在 Mach 内核中，

3006
01:31:46,380 --> 01:31:47,550
0,120 120,390 390,690 780,930 930,1170
was built into the Mach

3007
01:31:47,550 --> 01:31:49,080
0,330 450,690 720,1110 1110,1320 1320,1530
kernel,| the Unix kernel was
|Unix 内核被内置到 Mach 内核中，

3008
01:31:49,080 --> 01:31:49,980
0,210 210,330 330,450 450,540 540,900
built into {the,Mach -} kernel,|
|

3009
01:31:50,280 --> 01:31:53,040
0,450 750,1350 1350,1800 1800,2070 2070,2760
a modern {MacOS -} also
一种现代 MacOS 构建方式也与所描述的方式类似，

3010
01:31:53,820 --> 01:31:54,750
0,450 450,510 510,570 570,720 720,930
built in a way that

3011
01:31:54,750 --> 01:31:56,160
0,270 510,660 660,780 780,870 870,1410
like the way you describe,|
|

3012
01:31:56,160 --> 01:31:58,620
0,60 60,180 180,600 600,1230 1800,2460
you know {MacOS -} has
MacOS 有一个完整的操作系统，

3013
01:31:59,880 --> 01:32:01,020
0,90 90,450 450,750 750,1050 1050,1140
a complete operating system| with
|里面有一个文件系统和所有的东西，

3014
01:32:01,020 --> 01:32:01,950
0,60 60,330 330,570 570,660 660,930
a file system and everything

3015
01:32:01,950 --> 01:32:02,970
0,360 360,480 480,600 600,720 720,1020
inside it,| but it also
|但它也很好地支持 IPC 和类似的线程，

3016
01:32:02,970 --> 01:32:05,250
0,150 150,330 330,780 780,1170 1530,2280
has good support for IPC

3017
01:32:05,250 --> 01:32:07,020
0,240 270,510 510,570 570,900 1170,1770
and sort of like threads,|
|

3018
01:32:07,020 --> 01:32:07,800
0,180 180,270 270,570 570,690 690,780
all the stuff you would
所有你想要构建的微内核式服务。

3019
01:32:07,800 --> 01:32:10,410
0,270 330,690 900,1290 1290,1980 2040,2610
want to build micro kernel

3020
01:32:10,410 --> 01:32:12,660
0,780 900,1890
style services.|
|

3021
01:32:13,570 --> 01:32:15,790
0,720 720,1350 1380,1770 1770,2130 2130,2220
{Is,Google's} Fuchsia, I'm aware of
谷歌的 Fuchsia 是不是也实现了其中一些想法？

3022
01:32:15,790 --> 01:32:16,930
0,270 270,810 810,900 900,990 990,1140
also implements some of these

3023
01:32:16,930 --> 01:32:18,820
0,360 360,570 570,690 690,1050 1560,1890
ideas {} as well.| I'll
|我敢打赌是的。

3024
01:32:18,820 --> 01:32:19,940
0,270 270,570
bet yeah.|
|

3025
01:32:22,180 --> 01:32:23,590
0,240 240,570 570,1020 1020,1140 1140,1410
So anyway, there's no one
所以不管怎样，没有一种方法，

3026
01:32:23,590 --> 01:32:24,940
0,570
way,|
|

3027
01:32:24,940 --> 01:32:25,720
0,270 270,360 360,600 600,690 690,780
there were people who were
有些人希望一个纯粹的，

3028
01:32:25,720 --> 01:32:26,920
0,210 210,300 300,840 840,1080 1110,1200
sort of hoping that a

3029
01:32:26,920 --> 01:32:28,580
0,1080
pure,|
|

3030
01:32:28,670 --> 01:32:31,430
0,120 120,480 480,1710 2010,2610 2610,2760
a very pure scheme could
非常纯粹的计划能够奏效，

3031
01:32:31,430 --> 01:32:32,940
0,120 120,330 330,420 420,930
be made to work,|
|

3032
01:32:36,860 --> 01:32:37,910
0,240 240,420 420,510 510,690 690,1050
it's not the only possible
这不是唯一可能的前进道路。

3033
01:32:37,910 --> 01:32:42,620
0,150 150,600 3120,3750 3750,4200 4230,4710
way forward.| Alright, thanks,| got
|好的，谢谢，|我要去我的下一节课了，

3034
01:32:42,620 --> 01:32:44,690
0,210 210,690 720,1200 1200,1560 1710,2070
around my {next,lecture},| {but,I'll,see} you
|但是我们会再见的。

3035
01:32:44,690 --> 01:32:47,060
0,360 1260,1470 1470,1710
guys.| {See,you,later -}.|
|再见。|

3036
01:32:48,790 --> 01:32:49,880
0,180 180,510
Thank you.|
谢谢。|

3037
01:32:49,940 --> 01:32:51,100
0,150 150,540
You're welcome.|
不用谢。|

3038
01:32:52,460 --> 01:32:53,750
0,390 390,660 660,900 900,1080 1080,1290
Oh, I I didn't have
哦，我没有，

3039
01:32:53,750 --> 01:32:54,680
0,150 210,300 300,630 630,870 870,930
a,| I have just a
|我只想说一句，

3040
01:32:54,680 --> 01:32:56,510
0,570 600,930 930,930 930,1560 1560,1830
remark,| I I think it's
|我觉得很有意思，

3041
01:32:56,510 --> 01:32:59,180
0,600 600,960 1110,1500 1650,2190 2190,2670
fascinating,| that it it's like
|它好像慢了 5% ，

3042
01:32:59,700 --> 01:33:00,990
0,300 300,660 660,1020 1020,1170 1170,1290
{5% -} slower,| but it
|但它做的工作要多得多，

3043
01:33:00,990 --> 01:33:02,490
0,210 210,330 330,570 570,960 990,1500
does so much more work,|
|

3044
01:33:02,580 --> 01:33:04,620
0,270 270,450 450,930 930,1080 1080,1410
yeah was fascinated with that.|
是的，它非常有意思。|

3045
01:33:06,120 --> 01:33:06,930
0,300 300,420 420,570 570,720 720,810
You mean that even though
你的意思是，即使它做更多的工作也只是稍微慢一点，

3046
01:33:06,930 --> 01:33:07,770
0,120 120,300 300,480 480,630 630,840
it's doing much more work

3047
01:33:07,770 --> 01:33:10,470
0,120 120,270 270,570 570,1560 2190,2700
is only slightly slower,| really
|IPC 的性能真的是[]。

3048
01:33:10,470 --> 01:33:12,360
0,240 240,360 360,780 900,1500 1500,1890
have a really {[] -}

3049
01:33:12,360 --> 01:33:15,960
0,240 240,540 1380,2100 2100,2850 3330,3600
over the IPC performance.| And
|当然，还有一件事需要记住，

3050
01:33:15,960 --> 01:33:17,640
0,480 480,1020 1020,1170 1170,1230 1230,1680
it's another thing to remember,

3051
01:33:17,640 --> 01:33:19,280
0,150 150,420 420,510 510,840
of course is that,|
|

3052
01:33:19,310 --> 01:33:20,660
0,210 210,420 420,720 720,1200 1230,1350
if you start doing,| if
如果你开始做，|如果你在每个系统调用中做大量的工作，

3053
01:33:20,660 --> 01:33:22,610
0,120 120,600 1050,1080 1110,1770 1770,1950
you're doing a significant amount

3054
01:33:22,610 --> 01:33:24,410
0,90 90,600 630,870 870,1290 1290,1800
of work per system call,|
|

3055
01:33:25,380 --> 01:33:26,940
0,120 120,390 540,1140 1140,1260 1260,1560
you know looking at files
查找文件和目录什么的，

3056
01:33:26,940 --> 01:33:28,950
0,90 90,900 900,990 990,1650 1710,2010
and directories or something,| then
|那么系统调用的成本，

3057
01:33:28,950 --> 01:33:30,120
0,60 60,660 660,750 750,840 840,1170
the cost of the system

3058
01:33:30,120 --> 01:33:31,860
0,270 270,360 360,840 840,1320 1320,1740
call,| the IPC itself starts
|IPC 本身成本就开始变得不那么重要了。

3059
01:33:31,860 --> 01:33:34,140
0,120 120,240 240,900 1140,1920
to be less important.|
|

3060
01:33:34,890 --> 01:33:36,210
0,270 270,420 420,900 900,960 960,1320
So the combination of faster
所以，更快的系统调用加上实际程序的组合

3061
01:33:36,210 --> 01:33:38,100
0,300 300,660 660,990 990,1230 1230,1890
system calls plus real programs|
|

3062
01:33:38,100 --> 01:33:39,810
0,150 150,390 390,660 660,960 1440,1710
do things other than making
可以做一些不同于进行系统调用的事情。

3063
01:33:39,810 --> 01:33:41,440
0,300 300,960
system calls.|
|

3064
01:33:41,750 --> 01:33:42,770
0,300 300,420 420,570 570,840 840,1020
But you would also like
但你也会希望交换页表。

3065
01:33:42,770 --> 01:33:45,740
0,960 1020,1410 1410,2010 2010,2400 2490,2970
switch page tables and.| Yeah.|
|是的。|

3066
01:33:45,890 --> 01:33:47,930
0,420 420,1020 1440,1650 1650,1920 1920,2040
The {others,have}.| Yeah, although the
其他系统有的。|是的，尽管论文，

3067
01:33:47,930 --> 01:33:49,100
0,390 390,480 480,750 750,960 960,1170
paper,| I did not talk
|我没有谈到它，

3068
01:33:49,100 --> 01:33:50,030
0,210 210,270 270,420 420,540 540,930
about it,| but the paper
|但是论文有一些巧妙的技巧，

3069
01:33:50,030 --> 01:33:51,800
0,240 240,420 420,780 780,1320 1320,1770
had some clever tricks| for
|可以避免切换页表的成本，

3070
01:33:52,100 --> 01:33:54,050
0,540 540,660 660,1260 1260,1440 1440,1950
avoiding the cost of switching

3071
01:33:54,050 --> 01:33:55,460
0,360 360,930 960,1260 1260,1350 1350,1410
page tables,| I don't know
|我不知道你是否还记得，

3072
01:33:55,460 --> 01:33:58,310
0,90 90,210 210,1080 2010,2280 2280,2850
if you remember for some

3073
01:33:58,340 --> 01:33:59,720
0,180 180,600 600,870 870,1170 1170,1380
of its,| on page 6,
|在第 6 页中，我们讨论的是标记 TLB 为很小的空间，

3074
01:33:59,720 --> 01:34:01,850
0,90 90,300 300,480 480,1500 1530,2130
we're talking about supporting tagged

3075
01:34:01,850 --> 01:34:03,890
0,390 390,450 450,750 750,1470 1710,2040
TLBs a small spaces,| they
|他们有一些聪明的想法来避免切换页表，

3076
01:34:03,890 --> 01:34:05,210
0,120 120,300 300,690 690,1140 1140,1320
have some clever ideas for

3077
01:34:05,210 --> 01:34:08,300
0,930 930,1590 1590,2010 2010,2730
not switch page tables,|
|

3078
01:34:08,600 --> 01:34:09,620
0,360 360,450 450,630 630,840 840,1020
which I had not heard
这是我在读这份论文之前听说过的。

3079
01:34:09,620 --> 01:34:10,430
0,120 120,420 420,510 510,630 630,810
of before I read this

3080
01:34:10,430 --> 01:34:12,140
0,390
paper.|
|

3081
01:34:12,340 --> 01:34:13,570
0,180 180,300 300,570 570,990 990,1230
This is pretty cool, thank
太酷了，非常感谢，再见。

3082
01:34:13,570 --> 01:34:16,020
0,90 90,270 270,840 1230,1860
you so much, bye.|
|

3083
01:34:16,020 --> 01:34:17,940
0,450
Goodbye.
再见。
