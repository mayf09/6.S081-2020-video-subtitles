1
00:00:02,310 --> 00:00:04,710
0,810 1470,1980 1980,2160 2160,2310 2310,2400
Alright.| Um, I'd like to
好的。|嗯，我想开始了。

2
00:00:04,710 --> 00:00:05,740
0,150 150,780
get started.|
|

3
00:00:05,820 --> 00:00:07,770
0,360 360,960 1020,1380 1380,1620 1620,1950
First, can anyone hear me.|
首先，有没有人能听到我说话。|

4
00:00:09,150 --> 00:00:11,310
0,690 1170,1710 1740,1950 1950,2010 2010,2160
Yes.| Good, thank you very
是。|好的，非常感谢。

5
00:00:11,310 --> 00:00:12,640
0,600
much.|
|

6
00:00:13,300 --> 00:00:14,560
0,240 240,750 750,1020 1020,1200 1200,1260
Alright, today I want to
好，今天我要讲的是，

7
00:00:14,560 --> 00:00:17,500
0,270 270,810 1080,1650 2040,2190 2190,2940
talk about,| {} the transition
|{}在用户代码中运行程序，在用户代码中运行程序和在内核中执行之间的转换，

8
00:00:17,500 --> 00:00:19,750
0,450 450,750 750,1050 1170,1650 1650,2250
between running in user code


9
00:00:19,780 --> 00:00:21,190
0,240 240,600 600,720 720,960 960,1410
running programs in user code


10
00:00:21,190 --> 00:00:23,050
0,450 690,1290 1290,1350 1350,1440 1440,1860
and executing in the kernel,|
|

11
00:00:23,410 --> 00:00:24,400
0,180 180,330 330,420 420,480 480,990
and this is the transition
这就是必须要发生的转变

12
00:00:24,400 --> 00:00:25,720
0,90 90,300 300,390 390,930 930,1320
that has to happen| whenever
|每当程序进行系统调用时

13
00:00:25,720 --> 00:00:26,710
0,90 90,360 360,540 540,600 600,990
a program makes a system


14
00:00:26,710 --> 00:00:28,510
0,630 660,1140 1140,1230 1230,1740 1740,1800
call| where it experiences a
|在那里它经历了一个错误，比如页面错误，除以零

15
00:00:28,510 --> 00:00:29,710
0,360 360,480 480,540 540,900 900,1200
fault like a page fault,


16
00:00:29,710 --> 00:00:31,240
0,60 60,360 360,510 510,1110 1200,1530
a divide by zero| or
|或者如果设备决定中断并且需要由内核设备驱动程序提供服务。

17
00:00:31,240 --> 00:00:33,220
0,150 150,210 210,1140 1170,1860 1860,1980
if a device decides to


18
00:00:33,220 --> 00:00:34,360
0,480 480,750 750,960 960,1050 1050,1140
interrupt and needs to be


19
00:00:34,360 --> 00:00:36,070
0,510 510,660 660,810 810,1320 1320,1710
served by a kernel device


20
00:00:36,070 --> 00:00:37,820
0,480
driver.|
|

21
00:00:38,020 --> 00:00:39,070
0,480 480,510 510,630 630,690 690,1050
There's a lot of careful
有很多精心的设计和一些重要的细节

22
00:00:39,070 --> 00:00:41,710
0,840 840,1230 1230,1410 1410,2040 2040,2640
design and some important details|
|

23
00:00:41,710 --> 00:00:43,600
0,150 150,300 300,960 1380,1680 1680,1890
that go into how these
深入了解这些陷阱是如何从用户到内核{}发生的

24
00:00:43,600 --> 00:00:45,760
0,1020 1350,1650 1650,1860 1860,2070 2070,2160
traps, {} from user to


25
00:00:45,760 --> 00:00:47,470
0,300 300,780 900,1290 1290,1350 1350,1710
kernel happen| and the details
|细节对于实施隔离安全和性能非常重要，

26
00:00:47,470 --> 00:00:49,990
0,270 360,840 840,1320 1320,1830 1950,2520
are pretty important for enforcing


27
00:00:49,990 --> 00:00:53,800
0,660 660,1410 1560,2160 2160,2430 2430,3810
isolation security and also performance,|
|

28
00:00:53,800 --> 00:00:55,600
0,210 210,390 390,810 810,990 1530,1800
there's many programs that {}
有很多程序对内核进行了大量的转换，

29
00:00:55,600 --> 00:00:56,740
0,510 510,570 570,660 660,1020 1020,1140
transition of the kernel a


30
00:00:56,740 --> 00:00:58,180
0,540 570,900 900,1020 1020,1140 1140,1440
lot,| either due to system
|或者由于系统调用页面页面错误，

31
00:00:58,180 --> 00:01:00,400
0,330 330,390 390,900 960,1650 1650,2220
calls a page page faults,|
|

32
00:01:01,000 --> 00:01:02,170
0,570 570,660 660,810 810,900 900,1170
and it can be super
它可以是非常重要的

33
00:01:02,170 --> 00:01:03,960
0,600 600,840 840,1110 1110,1470
important| that the {}
|{}陷阱机制尽可能地[]。

34
00:01:04,080 --> 00:01:05,640
0,300 300,780 780,930 930,1020 1020,1560
trap mechanism is as []


35
00:01:05,640 --> 00:01:06,600
0,120 120,690
as possible.|
|

36
00:01:07,530 --> 00:01:10,290
0,420 420,720 810,1500 1710,2190 2190,2760
Alright, so {} starting situation
好的，那么{}开始的情况是比较熟悉的

37
00:01:10,290 --> 00:01:15,090
0,750 780,960 960,2160 2550,3360 4530,4800
is pretty familiar| where we
|在我们有用户程序的地方，我使用shell作为示例。

38
00:01:15,090 --> 00:01:16,860
0,180 180,510 570,1140 1140,1710 1710,1770
have our user program I


39
00:01:16,860 --> 00:01:17,820
0,180 180,300 300,750 750,870 870,960
use the shell as an


40
00:01:17,820 --> 00:01:18,880
0,780
example.|
|

41
00:01:19,570 --> 00:01:21,130
0,300 300,510 510,750 750,1260 1260,1560
Running in user space {}.|
在用户空间{}中运行。|

42
00:01:21,520 --> 00:01:22,500
0,750
Um,
嗯，我们有一个内核{}，

43
00:01:23,630 --> 00:01:24,620
0,150 150,270 270,330 330,870 870,990
we have a kernel {},|
|

44
00:01:24,620 --> 00:01:25,400
0,60 60,420 420,540 540,720 720,780
the shell would like to
外壳希望执行{}对内核进行系统调用。

45
00:01:25,400 --> 00:01:26,300
0,120 120,240 240,420 420,450 450,900
do {} make a system


46
00:01:26,300 --> 00:01:28,780
0,480 1230,1500 1500,1590 1590,2190
call into the kernel.|
|

47
00:01:29,100 --> 00:01:29,760
0,240 240,300 300,420 420,480 480,660
And {} going to use
和{}要使用WRITE，使用此shell编写其提示符

48
00:01:29,760 --> 00:01:31,680
0,690 720,1050 1050,1320 1320,1680 1680,1920
write, use this shell writing


49
00:01:31,680 --> 00:01:33,450
0,210 210,810 810,870 870,1110 1110,1770
its prompt| the very first
|引导x86之后发生的第一次写入，

50
00:01:33,540 --> 00:01:34,980
0,480 480,600 600,1110 1110,1350 1350,1440
write that happens after you


51
00:01:34,980 --> 00:01:36,750
0,150 150,870 1140,1470 1470,1560 1560,1770
boot x86,| use the shell
|使用尝试写入的shell将Write系统调用作为示例。

52
00:01:36,750 --> 00:01:37,710
0,240 240,330 330,720 720,810 810,960
trying to write to make


53
00:01:37,710 --> 00:01:38,850
0,120 120,330 330,630 630,1050 1050,1140
the write system calls an


54
00:01:38,850 --> 00:01:39,600
0,480
example.|
|

55
00:01:39,840 --> 00:01:40,650
0,390 390,480 480,600 600,720 720,810
And so we need to
所以我们需要弄清楚

56
00:01:40,650 --> 00:01:42,660
0,300 300,420 420,600 600,990 1410,2010
figure out| how to actually
|如何真正让执行从在shell中运行转移到

57
00:01:42,660 --> 00:01:44,610
0,510 540,1170 1170,1230 1230,1770 1770,1950
get execution to transfer from


58
00:01:44,610 --> 00:01:45,600
0,210 210,330 330,390 390,720 720,990
running in the shell| and
|和具有用户权限的用户空间，在内核管理员权限下运行后，

59
00:01:45,900 --> 00:01:48,030
0,480 480,1020 1020,1170 1170,1410 1410,2130
user space with user privileges,


60
00:01:48,450 --> 00:01:49,500
0,330 330,540 540,630 630,690 690,1050
after running in the kernel


61
00:01:49,500 --> 00:01:52,890
0,600 600,1260 1560,2190 2640,3300 3300,3390
supervisor privileges,| the state of
|硬件的状态将非常重要，

62
00:01:52,890 --> 00:01:54,570
0,90 90,750 750,1470 1470,1620 1620,1680
the hardware is going to


63
00:01:54,570 --> 00:01:55,410
0,90 90,270 270,660 660,810 810,840
be very important,| because a
|因为我们所做的很多事情都在某种程度上改变了硬件状态

64
00:01:55,410 --> 00:01:56,100
0,150 150,210 210,300 300,390 390,690
lot of what we're doing


65
00:01:56,100 --> 00:01:57,450
0,150 150,360 360,480 780,1290 1290,1350
is kind of changing the


66
00:01:57,450 --> 00:01:58,860
0,360 360,750 750,1050
hardware state| from
|从适合运行用户代码的状态到适合运行内核代码的状态。

67
00:01:59,160 --> 00:02:00,780
0,360 360,870 870,1020 1020,1260 1260,1620
state appropriate for running user


68
00:02:00,780 --> 00:02:03,690
0,480 480,750 750,1260 1770,2460 2460,2910
code to a state appropriate


69
00:02:03,690 --> 00:02:05,860
0,120 120,360 360,660 660,1260
for running kernel code.|
|

70
00:02:06,060 --> 00:02:07,020
0,120 120,450 450,540 540,630 630,960
The state that we care
我们所关心的州，

71
00:02:07,020 --> 00:02:10,080
0,540 870,1530 1800,2280 2280,2700 2700,3060
about,| the biggest state maybe
|最大的州可能是32个用户注册。

72
00:02:10,080 --> 00:02:13,180
0,660 690,1470 1470,1800 1800,2880
the 32 user registers.|
|

73
00:02:13,440 --> 00:02:15,030
0,300 300,360 360,690 690,960 960,1590
As you remember this from
你还记得周一的讨论中提到的这一点，

74
00:02:15,480 --> 00:02:17,700
0,420 420,1110 1260,1560 1560,1830 1890,2220
monday's discussion,| we have all
|我们有所有的用户寄存器，看起来像{a0-}和{a1-}。

75
00:02:17,700 --> 00:02:19,050
0,90 90,390 390,900 900,1110 1110,1350
the user registers seems like


76
00:02:19,050 --> 00:02:21,270
0,270 270,1050 1050,1200 1200,1380 1380,2220
{a0 -} and {a1 -}.|
|

77
00:02:22,910 --> 00:02:23,930
0,420 420,600 600,750 750,780 780,1020
{RISC-V -} has a whole
{RISC-V-}总共有一大堆这32个

78
00:02:23,930 --> 00:02:25,040
0,210 210,270 270,510 510,1020 1020,1110
lot of these 32 in


79
00:02:25,040 --> 00:02:26,990
0,990 1050,1350 1350,1440 1440,1560 1560,1950
total| and we can expect
|我们可以预期用户代码将使用所有它们。

80
00:02:26,990 --> 00:02:27,860
0,210 210,420 420,510 510,690 690,870
user code to use all


81
00:02:27,860 --> 00:02:28,560
0,90 90,330
of them.|
|

82
00:02:28,720 --> 00:02:29,290
0,210 210,330 330,390 390,480 480,570
It's going to get the
如果将它们全部使用，它将获得最高的性能，

83
00:02:29,290 --> 00:02:30,550
0,270 270,810 810,960 960,1050 1050,1260
highest performance if it uses


84
00:02:30,550 --> 00:02:32,110
0,210 210,330 780,1170 1170,1500 1500,1560
all of them,| many of
|他们中的许多人都有特殊的目的，

85
00:02:32,110 --> 00:02:33,340
0,90 90,240 240,630 630,1140 1140,1230
them have special purposes,| a
|我们将看到的几个特别有趣的是堆栈指针，

86
00:02:33,340 --> 00:02:35,050
0,150 150,360 360,480 480,930 1050,1710
few which we'll see a


87
00:02:35,050 --> 00:02:36,460
0,420 420,750 750,1050 1050,1320 1320,1410
particularly interesting one is the


88
00:02:36,460 --> 00:02:38,290
0,450 450,1050 1080,1260 1260,1590 1590,1830
stack pointer,| is actually one
|实际上是这32个通用寄存器中的一个。

89
00:02:38,290 --> 00:02:40,480
0,90 90,360 360,1080 1290,1860 1860,2190
of these 32 general purpose


90
00:02:40,480 --> 00:02:41,480
0,810
registers.|
|

91
00:02:42,340 --> 00:02:45,070
0,600 2070,2400 2400,2490 2490,2580 2580,2730
{} Okay, we have these
{}好的，我们有这些寄存器，包括堆栈指针，

92
00:02:45,070 --> 00:02:47,830
0,870 870,1230 1230,1590 1590,2160 2280,2760
registers including stack pointer,| {}
|{}硬件中有单独的程序计数器寄存器。

93
00:02:47,860 --> 00:02:49,390
0,180 180,240 240,720 720,1170 1170,1530
there's a separate program counter


94
00:02:49,390 --> 00:02:51,460
0,750 780,930 930,1020 1020,1740
register in the hardware.|
|

95
00:02:51,580 --> 00:02:54,400
0,660 930,1530 1530,1650 1650,1980 1980,2820
{} There's the current mode
{}当前模式可以是{}管理员模式，也可以是用户模式，当然是用户模式。

96
00:02:54,430 --> 00:02:56,650
0,360 810,1020 1020,1830 1830,1920 1920,2220
either {} supervisor or user


97
00:02:56,650 --> 00:02:57,820
0,90 90,150 150,390 390,750 780,1170
and of course it's user


98
00:02:57,820 --> 00:02:58,540
0,480
mode.|
|

99
00:02:58,700 --> 00:03:00,260
0,270 270,750 750,930 930,1080 1080,1560
We're executing up in the
我们在贝壳里行刑。

100
00:03:00,410 --> 00:03:01,560
0,750
shell.|
|

101
00:03:02,840 --> 00:03:03,590
0,270 270,420 420,540 540,690 690,750
{} And then there's a
{}然后是一堆寄存器特殊寄存器

102
00:03:03,590 --> 00:03:05,660
0,240 240,420 420,1050 1050,1440 1440,2070
bunch of registers special registers|
|

103
00:03:05,660 --> 00:03:07,790
0,210 210,960 1140,1470 1470,1770 1770,2130
that control how the CPU
它控制着CPU的工作方式，

104
00:03:07,790 --> 00:03:09,110
0,330 330,480 480,720 720,810 810,1320
works,| like there's the satp
|与SATP寄存器类似，它包含指向页表的指针

105
00:03:09,110 --> 00:03:11,000
0,540 540,720 1020,1500 1500,1560 1560,1890
register, that contains a pointer


106
00:03:11,000 --> 00:03:13,220
0,180 180,750 930,1350 1350,1890 1980,2220
to the page table| and
|事实证明，还有其他几个对这场讨论非常重要的东西，

107
00:03:13,220 --> 00:03:13,880
0,150 150,360 360,450 450,600 600,660
it'll turn out there's a


108
00:03:13,880 --> 00:03:14,630
0,240 240,330 330,600 600,720 720,750
couple of others that are


109
00:03:14,630 --> 00:03:16,370
0,360 360,780 780,900 900,1050 1050,1740
super important for this discussion,|
|

110
00:03:16,550 --> 00:03:18,560
0,480 480,840 840,1140 1140,1680 1860,2010
there's {stvec -} which is
有{stvec-}，它是指令的{}{}地址

111
00:03:18,560 --> 00:03:19,180
0,240
the


112
00:03:19,180 --> 00:03:21,130
0,300 300,840 870,1230 1230,1380 1380,1950
{} {} address the instruction|
|

113
00:03:21,130 --> 00:03:23,140
0,210 660,1020 1020,1200 1200,1620 1620,2010
that {} should handle traps
{}应该处理内核中的陷阱{}。

114
00:03:23,140 --> 00:03:24,900
0,60 60,150 150,630 930,1500
in the kernel {}.|
|

115
00:03:25,450 --> 00:03:27,730
0,390 390,780 780,1380 1380,1650 1650,2280
There's a register called {SEPC}
有一个名为{SEPC}的寄存器，用于在陷阱期间保存程序计数器

116
00:03:27,730 --> 00:03:29,110
0,150 150,690 690,780 780,1110 1110,1380
for saving the program counter


117
00:03:29,110 --> 00:03:30,490
0,270 270,330 330,690 690,960 1140,1380
during a trap| and we'll
|我们会看到还有一个叫{ssccratch-}也很重要，

118
00:03:30,490 --> 00:03:31,660
0,150 150,330 330,630 630,780 780,1170
see there's another one called


119
00:03:32,110 --> 00:03:34,240
0,240 240,1110 1530,1710 1710,1920 1920,2130
{sscratch -} is also very


120
00:03:34,240 --> 00:03:35,530
0,450 750,960 960,1080 1080,1140 1140,1290
important,| so this is the
|因此，这是系统调用时正在运行的计算机的状态

121
00:03:35,530 --> 00:03:37,180
0,450 450,510 510,600 600,840 840,1650
state of the running machine


122
00:03:37,360 --> 00:03:38,320
0,540 540,600 600,810 810,900 900,960
at the time of the


123
00:03:38,320 --> 00:03:39,520
0,330 330,690 690,900 900,990 990,1200
system call| and we actually
|我们实际上需要改变这种状态，

124
00:03:39,520 --> 00:03:40,450
0,180 180,270 270,690 690,720 720,930
need to change a bunch


125
00:03:40,450 --> 00:03:41,410
0,60 60,210 210,630 630,720 720,960
of this state,| or do
|或者作为进入内核的一部分对状态执行操作，

126
00:03:41,410 --> 00:03:42,940
0,630 630,780 780,870 870,1320 1320,1530
things to the state as


127
00:03:42,940 --> 00:03:44,410
0,390 390,660 780,1200 1200,1380 1380,1470
part of getting into the


128
00:03:44,410 --> 00:03:47,200
0,540 870,1440 1800,2070 2070,2400 2400,2790
kernel,| {} and setting ourself
|{}并将我们自己设置为只在内核中运行普通的C函数。

129
00:03:47,200 --> 00:03:48,340
0,210 210,330 330,510 510,720 720,1140
up to run just ordinary


130
00:03:48,340 --> 00:03:49,720
0,240 240,780 780,870 870,930 930,1380
C functions in the kernel.|
|

131
00:03:50,210 --> 00:03:51,950
0,420 420,540 540,810 1290,1680 1680,1740
Certainly at the instant of
当然是在陷阱发生的瞬间，

132
00:03:51,950 --> 00:03:53,450
0,90 90,630 900,1170 1170,1260 1260,1500
the trap,| all the state
|CPU的所有状态都设置为运行用户代码，而不是内核代码。

133
00:03:53,450 --> 00:03:54,260
0,60 60,120 120,540 540,660 660,810
of the CPU is set


134
00:03:54,260 --> 00:03:55,400
0,90 90,180 180,360 360,630 630,1140
up to run user code


135
00:03:55,430 --> 00:03:57,560
0,990 1020,1230 1230,1530 1530,1830
not not kernel code.|
|

136
00:03:57,880 --> 00:03:58,720
0,240 240,330 330,570 570,660 660,840
So the things that are
因此，需要发生的事情在某种程度上是我将要谈论的内容的预览，

137
00:03:58,720 --> 00:03:59,590
0,180 180,240 240,390 390,480 480,870
going to need to happen


138
00:03:59,590 --> 00:04:00,490
0,120 120,300 300,360 360,420 420,900
is kind of a preview


139
00:04:00,490 --> 00:04:01,390
0,120 120,240 240,330 330,570 570,900
of what I'll talk about,|
|

140
00:04:01,720 --> 00:04:03,970
0,510 570,1050 1050,1170 1170,1500 1770,2250
{} one is that {},
{}一个是{}，我们需要保存全部的32个寄存器，

141
00:04:04,000 --> 00:04:04,990
0,240 240,420 420,510 510,750 750,990
we need to save all


142
00:04:04,990 --> 00:04:06,820
0,420 420,990 990,1320 1350,1530 1530,1830
32 registers,| because we want
|因为我们希望透明地恢复用户代码，

143
00:04:06,820 --> 00:04:09,460
0,540 810,1770 1800,1920 1920,2250 2250,2640
to resume the user code


144
00:04:09,460 --> 00:04:11,800
0,1050 1200,2040 2040,2100 2100,2250 2250,2340
transparently,| particularly if there's a
|特别是在存在用户代码不期望的设备中断的情况下

145
00:04:11,800 --> 00:04:12,970
0,360 360,720 720,870 870,960 960,1170
device interrupt which the user


146
00:04:12,970 --> 00:04:14,740
0,240 240,480 480,1140 1470,1680 1680,1770
code isn't expecting| and we
|我们希望能够让内核为中断提供服务，

147
00:04:14,740 --> 00:04:15,250
0,150 150,210 210,270 270,420 420,510
want to be able to


148
00:04:15,250 --> 00:04:16,120
0,90 90,180 180,450 450,780 780,870
have the kernel serve the


149
00:04:16,120 --> 00:04:17,380
0,390 390,480 480,780
interrupt,| and then
|然后恢复用户代码，而不会注意到任何差异

150
00:04:17,440 --> 00:04:19,330
0,690 690,870 870,1170 1170,1500 1500,1890
resume the user code without


151
00:04:19,330 --> 00:04:20,710
0,150 150,570 570,720 720,1260 1260,1380
ever noticing any difference| and
|这意味着这32个寄存器不能被内核干扰，

152
00:04:20,710 --> 00:04:21,610
0,120 120,300 300,390 390,570 570,900
that means that these 32


153
00:04:21,610 --> 00:04:23,170
0,510 510,750 750,840 840,1440 1440,1560
registers can't be disturbed by


154
00:04:23,170 --> 00:04:25,120
0,90 90,540 930,1350 1620,1890 1890,1950
the kernel,| which since the
|从内核开始，你需要使用它拥有的寄存器将它们全部保存在某个地方，

155
00:04:25,120 --> 00:04:26,080
0,300 300,450 450,690 690,840 840,960
kernel, you need to use


156
00:04:26,080 --> 00:04:27,100
0,90 90,600 600,690 690,930 930,1020
the registers it has to


157
00:04:27,100 --> 00:04:28,450
0,330 330,450 450,570 570,900 900,1350
save them all somewhere,| first
|首先，这些需要保存。

158
00:04:28,450 --> 00:04:29,590
0,180 180,330 330,390 390,480 480,1140
these need to be saved.|
|

159
00:04:30,460 --> 00:04:32,050
0,390 540,780 780,1080 1080,1350 1350,1590
{} The program counter also
{}程序计数器也需要保存在某个地方，

160
00:04:32,050 --> 00:04:33,250
0,180 180,240 240,360 360,720 720,1200
needs to be saved somewhere,|
|

161
00:04:33,310 --> 00:04:35,350
0,240 240,330 330,750 1140,1260 1260,2040
because we need a user,
因为我们需要一个用户，这几乎就像一个用户注册，

162
00:04:35,530 --> 00:04:36,310
0,120 120,420 420,510 510,570 570,780
it's almost like a user


163
00:04:36,310 --> 00:04:38,050
0,480 480,780 1170,1350 1350,1590 1590,1740
register,| so, {} we need
|因此，{}我们需要在用户程序停止的地方继续执行，

164
00:04:38,050 --> 00:04:39,760
0,90 90,420 420,930 930,1260 1380,1710
to continue executing the user


165
00:04:39,760 --> 00:04:40,930
0,270 270,390 390,510 510,750 750,1170
program where it left off,|
|

166
00:04:41,140 --> 00:04:42,880
0,360 360,720 720,840 840,1560 1590,1740
we switch the mode to
我们将模式切换到主管模式，

167
00:04:42,880 --> 00:04:44,220
0,600 600,1140
supervisor mode,|
|

168
00:04:44,600 --> 00:04:46,550
0,540 1200,1500 1500,1680 1680,1740 1740,1950
because we need to use
因为我们需要在内核中使用各种权限。

169
00:04:46,550 --> 00:04:47,960
0,270 270,780 780,870 870,930 930,1410
various privileges in the kernel.|
|

170
00:04:48,920 --> 00:04:50,260
0,450 480,1110
Um just,
这个刚刚{}页表指针目前指向用户页表，

171
00:04:50,520 --> 00:04:52,290
0,300 300,990 990,1290 1290,1650 1650,1770
{} page table pointer is


172
00:04:52,290 --> 00:04:53,610
0,330 330,690 690,900 900,990 990,1320
currently pointing towards the user


173
00:04:53,610 --> 00:04:55,950
0,330 330,690 690,1080 1110,1440 1440,2340
page table,| which only contains
|它只包含{}用户程序需要的映射。

174
00:04:56,310 --> 00:04:57,570
0,330 360,600 600,660 660,1110 1110,1260
{} just the mapping is


175
00:04:57,570 --> 00:04:59,160
0,120 120,420 420,930 930,1350
that user programs need.|
|

176
00:04:59,350 --> 00:05:00,310
0,360 360,540 540,630 630,750 750,960
Plus one or two more
再加上一两个，我们会看到的，

177
00:05:00,310 --> 00:05:01,480
0,120 120,210 210,480 480,720 810,1170
as we'll see,| but the
|但是用户页表不包含大量内核数据的映射，

178
00:05:01,480 --> 00:05:02,530
0,240 240,450 450,660 660,810 810,1050
user page table does not


179
00:05:02,530 --> 00:05:03,880
0,420 420,600 630,1140 1140,1260 1260,1350
contain the mappings for the


180
00:05:03,880 --> 00:05:05,020
0,300 300,390 390,480 480,810 810,1140
bulk of the kernel data,|
|

181
00:05:05,320 --> 00:05:06,010
0,150 150,240 240,360 360,450 450,690
so we need to switch
因此，在运行大多数内核代码之前，我们需要切换页表。

182
00:05:06,010 --> 00:05:07,540
0,330 330,720 720,1050 1050,1170 1170,1530
page tables before we can


183
00:05:07,600 --> 00:05:09,260
0,390 390,660 660,930 930,1380
run most kernel code.|
|

184
00:05:10,430 --> 00:05:11,420
0,270 270,420 420,510 510,870 870,990
We need to switch the
我们需要将堆栈指针切换为指向内核中某个位置的堆栈，

185
00:05:11,420 --> 00:05:12,530
0,420 420,780 780,870 870,1050 1050,1110
stack pointer to point to


186
00:05:12,530 --> 00:05:13,580
0,60 60,510 510,870 870,990 990,1050
a stack that's in the


187
00:05:13,580 --> 00:05:15,080
0,300 300,660 660,960 1020,1380 1380,1500
kernel somewhere,| because we need
|因为我们需要将调用C函数堆叠在。

188
00:05:15,080 --> 00:05:16,520
0,90 90,450 450,540 540,1080 1110,1440
to stack the call C


189
00:05:16,520 --> 00:05:17,560
0,450 450,780
functions on.|
|

190
00:05:17,920 --> 00:05:19,220
0,450
Um.|
恩。|

191
00:05:19,830 --> 00:05:20,700
0,210 210,480 480,570 570,720 720,870
And finally, we need to
最后，我们需要跳进，

192
00:05:20,700 --> 00:05:22,320
0,360 360,1080 1110,1290 1290,1410 1410,1620
jump into,| once we've set
|一旦我们把这一切都设置好了

193
00:05:22,320 --> 00:05:23,250
0,90 90,270 270,450 450,540 540,930
all this up| and switched
|并将所有这些资源转换为适合在内核中使用的资源，

194
00:05:23,250 --> 00:05:24,900
0,240 240,660 690,870 870,1050 1050,1650
all this all these resources


195
00:05:24,900 --> 00:05:26,790
0,120 120,450 690,1290 1290,1620 1650,1890
to be appropriate for use


196
00:05:26,790 --> 00:05:28,110
0,90 90,150 150,630 750,1170 1170,1320
in the kernel,| we need
|我们需要跳到内核C代码，

197
00:05:28,110 --> 00:05:29,400
0,90 90,480 480,750 750,1080 1080,1290
to jump to kernel C


198
00:05:29,400 --> 00:05:30,780
0,240 240,420 510,930 930,1080 1080,1380
code,| and once we're in
|一旦我们进入C代码，

199
00:05:30,780 --> 00:05:33,240
0,300 300,1380 1740,2070 2070,2190 2190,2460
C code,| life is much
|生活更像是一如既往的生意，

200
00:05:33,240 --> 00:05:36,240
0,720 2190,2460 2460,2550 2550,2880 2880,3000
more sort of business as


201
00:05:36,240 --> 00:05:37,380
0,420 420,540 540,690 690,900 900,1140
usual,| we're just running {}
|我们只是在这个内核中运行{}C程序，

202
00:05:37,380 --> 00:05:38,700
0,210 210,570 570,630 630,780 780,1320
C program in this kernel,|
|

203
00:05:38,940 --> 00:05:40,320
0,690 690,840 840,960 960,1260 1260,1380
and so far today at
至少今天到目前为止，我们稍后会讨论内核做了什么{C，code}，

204
00:05:40,320 --> 00:05:41,700
0,240 240,810 810,1020 1020,1260 1260,1380
least, we'll talk about what


205
00:05:41,700 --> 00:05:44,460
0,90 90,570 900,1800 1890,2370 2370,2760
the kernel does {C,code} later,|
|

206
00:05:44,490 --> 00:05:46,470
0,450 450,960 1110,1380 1380,1860 1860,1980
but today the discussion is
但今天的讨论真的是

207
00:05:46,470 --> 00:05:47,190
0,210 210,360 360,450 450,570 570,720
really| how to get from
|如何从用户空间进入内核，

208
00:05:47,190 --> 00:05:48,420
0,210 210,630 630,810 810,900 900,1230
user space into the kernel


209
00:05:48,420 --> 00:05:49,410
0,180 180,270 270,720 720,870 870,990
into a position,| where we
|在那里我们可以在内核中运行{}C代码。

210
00:05:49,410 --> 00:05:51,960
0,150 150,810 1230,1560 1590,1890 1890,2550
can run {} C code


211
00:05:52,020 --> 00:05:52,940
0,180 180,270 270,660
in the kernel.|
|

212
00:05:53,510 --> 00:05:54,500
0,300 420,690 690,720 720,900 900,990
{} There's a couple of
{}有几个高层次的目标，

213
00:05:54,500 --> 00:05:56,420
0,480 480,840 840,930 930,1740 1740,1920
high-level goals,| that constrain our
|这限制了我们在这方面的设计选择，

214
00:05:56,420 --> 00:05:58,850
0,480 480,930 930,1020 1020,1500 1890,2430
design options for this,| one
|一个是为了安全和隔离，

215
00:05:58,850 --> 00:06:00,320
0,150 150,450 660,810 810,1380 1380,1470
is that for security and


216
00:06:00,320 --> 00:06:01,730
0,540 540,690 690,1020 1020,1230 1230,1410
isolation,| we really don't want
|我们真的不想让用户代码干扰这个用户内核转换，

217
00:06:01,730 --> 00:06:03,800
0,90 90,360 360,720 720,1260 1260,2070
to let user code interfere


218
00:06:03,800 --> 00:06:06,140
0,510 510,990 990,1380 1380,1680 1680,2340
with this user kernel transition,|
|

219
00:06:06,140 --> 00:06:06,950
0,120 120,180 180,330 330,540 540,810
in a way that could
在某种程度上可能会破坏安全

220
00:06:06,950 --> 00:06:08,570
0,90 90,540 540,630 630,1320 1440,1620
be damaging to security| and
|所以这意味着{那是-}

221
00:06:08,570 --> 00:06:10,250
0,90 90,240 240,480 480,750 1080,1680
so that means {that's -}|
|

222
00:06:10,250 --> 00:06:11,600
0,0 0,330 330,390 390,1110 1110,1350
{} sort of hardware and
{}陷阱中涉及的各种硬件和内核机制

223
00:06:11,870 --> 00:06:14,060
0,780 810,1680 1680,1770 1770,1860 1860,2190
kernel mechanisms that are involved


224
00:06:14,060 --> 00:06:15,830
0,60 60,570 690,1050 1050,1410 1410,1770
in traps| really can't count
|真的不能指望任何来自用户空间的东西，

225
00:06:15,830 --> 00:06:17,750
0,360 390,870 870,1050 1050,1320 1320,1920
on anything from user space,|
|

226
00:06:17,870 --> 00:06:18,980
0,180 180,270 270,570 570,810 810,1110
you know we can't assume
你知道我们不能对这些登记簿做任何假设，

227
00:06:19,010 --> 00:06:20,540
0,450 450,690 690,900 900,1440 1440,1530
anything about these registers,| they
|它们可能充斥着可怕的恶意值，

228
00:06:20,540 --> 00:06:21,440
0,150 150,240 240,450 450,810 810,900
could be just filled with


229
00:06:21,440 --> 00:06:24,440
0,450 450,870 870,1830 2040,2580 2760,3000
terribly malicious values,| {} so
|{}所以基本上{xv6-}陷阱处理程序甚至不会真正查看这些寄存器，只是将它们保存起来{}。

230
00:06:24,440 --> 00:06:25,940
0,420 420,630 720,1110 1110,1260 1260,1500
basically the {xv6 -} trap


231
00:06:25,940 --> 00:06:26,960
0,240 240,420 420,600 600,750 750,1020
handler doesn't really even look


232
00:06:26,960 --> 00:06:28,550
0,120 120,540 570,1110 1110,1320 1320,1590
at these registers just saves


233
00:06:28,550 --> 00:06:30,480
0,120 120,540 1170,1650
them away {}.|
|

234
00:06:31,340 --> 00:06:32,960
0,360 360,690 960,1320 1320,1440 1440,1620
Okay so we're going to
好的，所以我们要小心

235
00:06:32,990 --> 00:06:34,460
0,300 300,360 360,450 450,1080 1350,1470
want to be careful| to
|在此陷阱机制期间针对故意恶意的用户代码保持隔离

236
00:06:34,460 --> 00:06:35,960
0,330 330,930 930,1140 1140,1260 1260,1500
preserve isolation during this trap


237
00:06:35,960 --> 00:06:37,220
0,510 510,1080
mechanism against


238
00:06:37,290 --> 00:06:40,290
0,960 990,1650 1650,1920 1920,2370 2610,3000
intentionally malicious user code| and
|另一件重要的事是，

239
00:06:40,290 --> 00:06:41,430
0,60 60,210 210,330 330,480 480,1140
the other thing that's important


240
00:06:41,430 --> 00:06:42,720
0,180 180,450 630,1110 1110,1230 1230,1290
is that,| we want to
|我们希望对用户代码是透明的，

241
00:06:42,720 --> 00:06:44,130
0,90 90,750 750,840 840,1080 1080,1410
be transparent to user code,|
|

242
00:06:44,160 --> 00:06:44,820
0,150 150,300 300,390 390,480 480,660
we'd like to be able
我们希望能够设下陷阱

243
00:06:44,820 --> 00:06:46,530
0,360 570,1020 1020,1110 1110,1530 1530,1710
to take the trap| and
|并在内核中处理我们的业务

244
00:06:46,530 --> 00:06:47,190
0,90 90,180 180,510 510,600 600,660
do our business in the


245
00:06:47,190 --> 00:06:48,720
0,330 330,540 660,1200 1200,1260 1260,1530
kernel| and resume the user
|并恢复用户代码，而不会注意到发生了任何有趣的事情。

246
00:06:48,720 --> 00:06:49,830
0,210 210,540 540,660 660,870 870,1110
code without it ever having


247
00:06:49,830 --> 00:06:51,120
0,60 60,480 480,630 630,1020 1020,1290
to notice that anything funny


248
00:06:51,120 --> 00:06:51,840
0,570
happened.|
|

249
00:06:52,060 --> 00:06:52,720
0,150 150,300 300,480 480,540 540,660
And that's just to make
这只是为了让编写用户代码变得更容易。

250
00:06:52,720 --> 00:06:53,650
0,120 120,420 420,510 510,690 690,930
it easier to write user


251
00:06:53,650 --> 00:06:56,340
0,450
code.|
|

252
00:06:56,770 --> 00:06:58,570
0,300 600,840 840,1140 1140,1230 1230,1800
And, {} something to note
而且，{}要注意的是，

253
00:06:58,600 --> 00:07:00,400
0,570 600,840 840,1140 1140,1410 1410,1800
to,| {} we care about
|{}我们这里关心的是隔离安全，

254
00:07:00,400 --> 00:07:02,050
0,600 600,1110 1110,1320 1320,1560 1560,1650
isolation security here,| today we're
|今天我们只想谈谈。

255
00:07:02,050 --> 00:07:03,310
0,150 150,300 300,570 570,840 840,1260
just gonna talk about the.|
|

256
00:07:03,460 --> 00:07:04,380
0,450


257
00:07:04,690 --> 00:07:05,560
0,180 180,330 330,390 390,810 810,870
Those sort of aspects of
这些涉及进入内核的安全方面，

258
00:07:05,560 --> 00:07:06,820
0,420 420,510 510,810 810,1110 1110,1260
security that involves getting into


259
00:07:06,820 --> 00:07:08,290
0,90 90,540 570,840 840,900 900,1470
the kernel,| but of course
|当然，这个系统被称为“实现”(Implementation)，

260
00:07:08,320 --> 00:07:10,210
0,330 330,570 570,780 780,1620 1620,1890
this system called implementations,| the
|内核中实际正确的实现，

261
00:07:10,210 --> 00:07:12,010
0,570 570,990 990,1650 1650,1740 1740,1800
actual right implementation in the


262
00:07:12,010 --> 00:07:13,930
0,510 660,1380 1380,1770 1770,1860 1860,1920
kernel,| also everything in the
|此外，内核中的所有内容都必须小心，

263
00:07:13,930 --> 00:07:15,280
0,270 270,510 510,600 600,780 780,1350
kernel has to be careful,|
|

264
00:07:15,310 --> 00:07:16,330
0,150 150,210 210,300 300,570 570,1020
has to be written carefully
也必须写得仔细和安全，

265
00:07:16,330 --> 00:07:19,570
0,150 150,660 660,1170 1980,2430 2670,3240
and securely also,| so even
|因此，即使这种向内核的过渡是完全安全的，

266
00:07:19,570 --> 00:07:21,250
0,120 120,330 330,1140 1380,1590 1590,1680
if this transition into the


267
00:07:21,250 --> 00:07:23,170
0,360 360,600 630,1020 1020,1620 1650,1920
kernel is perfectly secure,| the
|内核的整个睡觉都必须安全地编写

268
00:07:23,170 --> 00:07:23,980
0,180 180,360 360,420 420,480 480,810
whole rest of the kernel


269
00:07:23,980 --> 00:07:25,810
0,270 270,360 360,720 900,1230 1230,1830
has to be written securely|
|

270
00:07:25,810 --> 00:07:27,760
0,210 210,390 390,1050 1050,1260 1530,1950
and so mindful that user
而且要注意，用户代码可能会试图欺骗它。

271
00:07:27,760 --> 00:07:28,570
0,270 270,420 420,540 540,750 750,810
code may be trying to


272
00:07:28,570 --> 00:07:29,200
0,270 270,360
trick it.|
|

273
00:07:29,910 --> 00:07:30,480
0,60


274
00:07:30,810 --> 00:07:33,630
0,480 1170,1470 1470,2280 2280,2670 2670,2820
{} A particularly important thing
{}我想说的一件特别重要的事情，

275
00:07:33,630 --> 00:07:34,320
0,60 60,180 180,240 240,450 450,690
I want to talk about


276
00:07:34,320 --> 00:07:35,250
0,90 90,390 390,510 510,750 750,930
is| what it is that
|模式标志控制的是什么，

277
00:07:35,250 --> 00:07:39,420
0,90 90,870 870,1650 1740,2940 3930,4170
the mode flag controls,| this
|此模式可以是用户模式，也可以是管理员模式。

278
00:07:39,420 --> 00:07:40,770
0,390 390,630 630,900 900,1290 1290,1350
mode is either user or


279
00:07:40,770 --> 00:07:43,260
0,630 630,690 690,1080 1080,1800 2100,2490
supervisor,| of course user whatever
|当然，用户可以使用任何用户空间

280
00:07:43,260 --> 00:07:44,910
0,300 300,780 780,990 1230,1440 1440,1650
user space| and the mode
|并且模式标志被设置为在内核中执行的管理程序，

281
00:07:44,910 --> 00:07:46,170
0,210 210,300 300,450 450,540 540,1260
flag is set to supervisor


282
00:07:46,170 --> 00:07:47,340
0,150 150,540 540,630 630,690 690,1170
were executing in the kernel,|
|

283
00:07:47,460 --> 00:07:48,480
0,360 360,480 480,810 810,870 870,1020
but it's important to know
但重要的是要确切地知道我们获得了什么特权，

284
00:07:48,480 --> 00:07:52,710
0,810 1230,1980 2190,3270 3300,3510 3510,4230
exactly what privileges we gain,|
|

285
00:07:52,740 --> 00:07:53,940
0,180 180,570 570,660 660,1020 1020,1200
by changing the mode from
通过将模式从用户改变为管理员，

286
00:07:53,940 --> 00:07:55,500
0,300 300,390 390,1140 1200,1500 1500,1560
user to supervisor,| and it
|结果是{}。

287
00:07:55,500 --> 00:07:57,080
0,210 210,480 750,1290
turns out {}.|
|

288
00:07:57,320 --> 00:07:59,690
0,300 300,540 540,1020 1020,1320 1620,2370
These extra privileges are fairly
这些额外的特权是相当有限的，

289
00:07:59,720 --> 00:08:01,580
0,930 1200,1380 1380,1590 1590,1680 1680,1860
restrictive,| {} that is what
|{}这是您在主管模式下可以做的，在用户模式下不能做，

290
00:08:01,580 --> 00:08:02,960
0,150 150,270 270,570 570,720 720,1380
you can do in supervisor


291
00:08:02,960 --> 00:08:04,160
0,300 300,390 390,900 900,1080 1080,1200
mode, you couldn't do in


292
00:08:04,160 --> 00:08:06,680
0,300 300,720 1020,1620 1740,2190 2190,2520
user mode,| {} not maybe
|{}可能不是你想的那样的特权，

293
00:08:06,680 --> 00:08:07,420
0,540
as


294
00:08:07,710 --> 00:08:08,600
0,690


295
00:08:09,620 --> 00:08:10,670
0,240 240,660 660,750 750,840 840,1050
a privilege as you might


296
00:08:10,670 --> 00:08:11,870
0,240 240,360 360,510 510,600 600,1200
think so,| this is supervisor
|这正是它所控制的主管模式。

297
00:08:11,870 --> 00:08:14,750
0,540 1020,1770 1770,1890 1890,1980 1980,2880
mode exactly what it controls.|
|

298
00:08:15,760 --> 00:08:18,070
0,540 900,1650 1650,1860 1860,1950 1950,2310
{} One thing it does
{}它所做的一件事是您现在可以读写控制寄存器。

299
00:08:18,070 --> 00:08:19,960
0,510 960,1140 1140,1230 1230,1620 1620,1890
is you can now read


300
00:08:19,960 --> 00:08:22,240
0,150 150,750 780,900 900,1320 1320,2280
and write the control registers.|
|

301
00:08:23,110 --> 00:08:23,800
0,390
And,
而且，{}也就是，如果您的主管模式，

302
00:08:24,290 --> 00:08:25,970
0,600 720,1020 1020,1170 1170,1530 1530,1680
{} that is, if your


303
00:08:25,970 --> 00:08:27,170
0,540 540,750 750,870 870,1020 1020,1200
supervisor mode,| you can read
|您可以读写SATP，即页表指针，

304
00:08:27,170 --> 00:08:28,720
0,90 90,300 300,1260
and write satp,


305
00:08:29,110 --> 00:08:30,730
0,270 480,870 870,1110 1110,1410 1410,1620
the page table pointer,| this
|这个{stvec-}指针控制陷阱进入内核的位置，

306
00:08:30,730 --> 00:08:32,650
0,390 390,630 630,900 900,1110 1110,1920
{stvec -} pointer which controls


307
00:08:32,740 --> 00:08:34,570
0,540 540,900 900,1140 1140,1230 1230,1830
where traps going the kernel,|
|

308
00:08:34,660 --> 00:08:35,800
0,870


309
00:08:36,080 --> 00:08:37,610
0,210 210,750 750,1020 1140,1440 1440,1530
This register that holds the
该寄存器在{sscatch-}寄存器加上其他几个寄存器中的陷阱期间保存保存程序计数器，

310
00:08:37,610 --> 00:08:38,960
0,420 420,750 750,1050 1050,1290 1290,1350
save program counter during a


311
00:08:38,960 --> 00:08:40,720
0,330 330,390 390,660 660,1500
trap in {sscratch -}


312
00:08:40,920 --> 00:08:42,450
0,480 480,690 690,750 750,930 930,1530
register plus a few others,|
|

313
00:08:42,930 --> 00:08:44,160
0,240 240,810 810,1020 1020,1140 1140,1230
so supervisor could read and
因此管理程序可以读写这些寄存器

314
00:08:44,160 --> 00:08:45,510
0,150 150,330 330,960 960,1140 1140,1350
write these registers| and user
|而用户代码则不能。

315
00:08:45,510 --> 00:08:47,460
0,240 240,360 360,720 1080,1620 1620,1950
code could not.| The only
|唯一的另一件事，主管代码可以做的是，

316
00:08:47,460 --> 00:08:48,870
0,150 150,390 390,990 990,1290 1290,1410
other thing, supervisor code can


317
00:08:48,870 --> 00:08:50,910
0,540 570,1290 1380,1680 1680,1830 1830,2040
do is,| {} it can
|{}它可以使用PTE，

318
00:08:50,910 --> 00:08:53,180
0,780 810,1680 1680,2160
use pte 's,|
|

319
00:08:54,620 --> 00:08:56,990
0,990 1230,1500 1500,1710 1710,1770 1770,2370
{} they have the pte
{}他们设置了PTE U标志。

320
00:08:56,990 --> 00:08:58,260
0,180 180,630 630,1020
u flag set.|
|

321
00:08:59,100 --> 00:08:59,580
0,150 150,270 270,330 330,420 420,480
I don't know if you
我不知道你是否还记得

322
00:08:59,580 --> 00:09:00,810
0,330 330,450 450,660 660,840 840,1230
remember| but there's this pte
|但是在每个页表条目上都有这个PTEU标志被设置或不被设置。

323
00:09:00,810 --> 00:09:02,190
0,210 210,780 900,1110 1110,1320 1320,1380
u flag be set or


324
00:09:02,190 --> 00:09:03,510
0,240 240,450 450,540 540,960 960,1320
not set on each page


325
00:09:03,510 --> 00:09:05,700
0,270 270,720
table entry.|
|

326
00:09:05,870 --> 00:09:07,880
0,210 210,780 780,1200 1350,1770 1770,2010
A flag that has this,
带有此、对不起、{}对不起的旗帜可以使用PTES。

327
00:09:07,880 --> 00:09:10,430
0,450 450,960 1440,2130 2160,2370 2370,2550
sorry, {} sorry, can use


328
00:09:10,430 --> 00:09:11,740
0,1050
ptes.|
|

329
00:09:12,450 --> 00:09:13,890
0,240 240,540 780,1140 1140,1350 1350,1440
{} They don't have the
{}他们没有设置PTE U标志，

330
00:09:13,890 --> 00:09:15,870
0,390 390,750 840,1200 1200,1590 1620,1980
pte u flag set,| if
|如果PTEU标志被设置，

331
00:09:15,870 --> 00:09:17,070
0,120 120,630 630,780 780,1110 1110,1200
the pte u flag is


332
00:09:17,070 --> 00:09:18,240
0,360 360,480 480,720 720,870 870,1170
set,| it means that user
|这意味着用户代码可以使用该页表项，

333
00:09:18,240 --> 00:09:19,290
0,300 300,450 450,630 630,780 780,1050
code can use that page


334
00:09:19,290 --> 00:09:21,180
0,240 240,690 1380,1530 1530,1650 1650,1890
table entry,| if this flag
|如果在页表条目中没有设置该标志，

335
00:09:21,180 --> 00:09:22,050
0,270 270,480 480,540 540,630 630,870
isn't set in a page


336
00:09:22,050 --> 00:09:23,550
0,240 240,480 480,540 540,870 900,1500
table entry,| it means only
|这意味着只有主管模式才能使用它。

337
00:09:23,580 --> 00:09:24,990
0,660 660,900 900,1080 1080,1260 1260,1410
supervisor mode can use it.|
|

338
00:09:25,560 --> 00:09:27,390
0,480 990,1170 1170,1320 1320,1650 1650,1830
{} And you will see
{}你会发现这有点重要，

339
00:09:27,390 --> 00:09:29,040
0,210 210,840 990,1200 1200,1380 1380,1650
that's important a little bit,|
|

340
00:09:29,040 --> 00:09:29,640
0,300
but,
但是，这些确实是主管模式唯一可以做的事情，它不能特别做其他任何事情，

341
00:09:30,420 --> 00:09:31,200
0,300 300,330 330,510 510,600 600,780
these are really the only


342
00:09:31,200 --> 00:09:32,370
0,210 210,300 300,840 840,1050 1050,1170
things that supervisor mode can


343
00:09:32,370 --> 00:09:33,180
0,120 120,210 210,390 390,510 510,810
do it can't do anything


344
00:09:33,180 --> 00:09:34,830
0,210 210,270 270,840 840,1050 1050,1650
else in particular,| for example
|例如，管理模式代码不能只读写任意地址，{}比方说物理地址，

345
00:09:35,280 --> 00:09:37,980
0,270 270,960 960,1470 1470,1950 2010,2700
a supervisor mode code can't


346
00:09:37,980 --> 00:09:39,660
0,450 480,900 900,990 990,1200 1200,1680
just read and write arbitrary


347
00:09:39,660 --> 00:09:40,720
0,960
addresses,


348
00:09:40,810 --> 00:09:42,910
0,450 480,750 750,1110 1110,1710 1710,2100
{} say physical addresses,| {you,know}
|{You，Know}管理程序模式被强制通过页表

349
00:09:43,330 --> 00:09:45,280
0,600 600,1140 1200,1590 1590,1890 1890,1950
supervisor mode is forced to


350
00:09:45,280 --> 00:09:46,360
0,120 120,270 270,360 360,630 630,1080
go through the page table|
|

351
00:09:46,420 --> 00:09:47,650
0,240 240,360 360,540 540,720 720,1230
just like any other code,|
就像任何其他代码一样，|

352
00:09:47,740 --> 00:09:49,240
0,390 390,480 480,570 570,930 930,1500
{} if a virtual address
{}如果虚拟地址不在页面中，则不在{satp-}指向的当前页表中。

353
00:09:49,270 --> 00:09:50,290
0,270 270,360 360,420 420,690 720,1020
isn't in the page isn't


354
00:09:50,290 --> 00:09:51,370
0,90 90,180 180,480 480,750 750,1080
in the current page table


355
00:09:51,370 --> 00:09:52,660
0,330 330,420 420,570 570,930 930,1290
pointed to by {satp -}.|
|

356
00:09:53,050 --> 00:09:54,700
0,570 990,1260 1260,1380 1380,1440 1440,1650
{} Or if it has
{}或者如果它设置了{PTE-}u位标志，

357
00:09:54,700 --> 00:09:55,780
0,60 60,360 360,570 570,780 780,1080
a {pte -} u bit


358
00:09:55,810 --> 00:09:57,580
0,630 630,1110 1140,1380 1380,1650 1650,1770
flags set,| which means it's
|这意味着它是用户{pte-}，

359
00:09:57,580 --> 00:09:58,570
0,90 90,360 360,660 660,810 810,990
the user {pte -},| then
|则管理员模式不能使用该地址，

360
00:09:58,570 --> 00:10:00,640
0,540 540,1020 1020,1650 1650,1860 1860,2070
supervisor mode cannot use that


361
00:10:00,640 --> 00:10:03,130
0,660 900,1140 1140,1320 1530,2160 2280,2490
address,| so we're even in
|所以我们甚至在管理模式下都被限制到任何虚拟地址，

362
00:10:03,130 --> 00:10:05,380
0,630 630,840 840,960 960,1860 1950,2250
supervisor mode were restricted to


363
00:10:05,380 --> 00:10:07,720
0,780 810,1410 1410,2190
whatever virtual address,|
|

364
00:10:07,850 --> 00:10:09,170
0,420 420,840 840,930 930,1170 1170,1320
virtual addresses were set up
在当前页表上设置了虚拟地址。

365
00:10:09,170 --> 00:10:10,490
0,60 60,180 180,600 600,960 960,1320
on the current page table.|
|

366
00:10:11,990 --> 00:10:14,420
0,630 1020,1440 1440,1620 1620,1920 2010,2430
{} And that's it, so
{}就是这样，所以我们就被允许做这些事情，

367
00:10:14,450 --> 00:10:15,260
0,150 150,300 300,480 480,720 720,810
we were just allowed to


368
00:10:15,260 --> 00:10:16,160
0,150 150,360 360,630 630,810 810,900
do these things,| so you
|因此，我们将看到，陷阱代码可以做什么，这是一个重要的约束。

369
00:10:16,160 --> 00:10:17,240
0,90 90,210 210,840
know we'll see,


370
00:10:17,330 --> 00:10:20,300
0,930 1470,1740 1740,2310 2310,2820 2820,2970
as a significant constraint on


371
00:10:20,300 --> 00:10:21,710
0,180 180,540 630,990 990,1290 1290,1410
what the trap code can


372
00:10:21,710 --> 00:10:22,400
0,450
do.|
|

373
00:10:22,760 --> 00:10:24,140
0,570 630,840 840,960 960,1290 1290,1380
{} When we're entering the
{}当我们进入内核的时候，什么都不能做，

374
00:10:24,140 --> 00:10:24,700
0,330
kernel,


375
00:10:25,240 --> 00:10:27,310
0,270 270,390 390,600 600,990 1830,2070
can't do just anything,| going
|预习一下，我将在{gdb--}{}中花大部分时间，

376
00:10:27,310 --> 00:10:28,600
0,90 90,570 570,660 660,930 1170,1290
to preview a bit, I'm


377
00:10:28,600 --> 00:10:30,010
0,510 690,960 960,1170 1170,1230 1230,1410
gonna spend most of this


378
00:10:30,010 --> 00:10:30,940
0,660
lecture


379
00:10:30,970 --> 00:10:32,740
0,210 210,390 390,540 540,1170 1200,1770
in {gdb - -} {},|
|

380
00:10:32,740 --> 00:10:35,080
0,360 360,930 930,1380 1380,1470 1470,2340
actually tracing through the execution|
实际上追踪整个执行过程|

381
00:10:35,560 --> 00:10:37,420
0,390 390,990 990,1380 1380,1680 1680,1860
of a trap entry into
内核中的陷阱条目的返回值{}，

382
00:10:37,420 --> 00:10:39,520
0,90 90,480 480,570 570,1200 1620,2100
the kernel in return {},|
|

383
00:10:39,760 --> 00:10:40,420
0,300 300,420 420,480 480,540 540,660
this can be a lot
这可以是很多细节，以便。

384
00:10:40,420 --> 00:10:43,240
0,60 60,900 1680,1890 1890,2190 2190,2820
of details in order to.|
|

385
00:10:43,240 --> 00:10:44,320
0,810


386
00:10:45,300 --> 00:10:46,980
0,300 300,720 720,930 930,1110 1170,1680
Um, maybe sort of help
嗯，也许对你有点帮助，{}看看海德接下来会发生什么，

387
00:10:46,980 --> 00:10:48,240
0,480 510,990
you, {}


388
00:10:48,960 --> 00:10:51,390
0,360 360,540 540,750 750,1260 1980,2430
see head what's coming,| we're
|我们将{}追踪{shell‘s-}调用以进行写入，

389
00:10:51,390 --> 00:10:52,160
0,150 150,510
gonna be


390
00:10:52,840 --> 00:10:54,940
0,210 210,840 840,1410 1410,2010 2010,2100
{} tracing a {shell's -}


391
00:10:54,940 --> 00:10:57,430
0,570 570,960 960,1290 1320,2010 2220,2490
call to a write,| which
|从贝壳的角度来看

392
00:10:57,430 --> 00:10:58,120
0,120 120,180 180,450 450,630 630,690
from the shell's point of


393
00:10:58,120 --> 00:10:59,140
0,90 90,210 210,480 480,660 660,1020
view| is just a C
|只是作为shell的一部分的C函数调用，

394
00:10:59,140 --> 00:11:00,130
0,360 360,600 600,750 750,930 930,990
function call as part of


395
00:11:00,130 --> 00:11:02,530
0,60 60,630 900,1320 1650,1920 1920,2400
the shell,| {} in fact
|{}Write实际上实现了这一点，{}Write会发出系统调用

396
00:11:02,710 --> 00:11:04,390
0,480 480,750 750,990 990,1440 1500,1680
write makes this, {} write


397
00:11:04,390 --> 00:11:06,100
0,600 600,660 660,990 990,1530 1560,1710
issues a system call| by
|通过发出eCall指令，

398
00:11:06,100 --> 00:11:08,080
0,390 390,660 660,990 990,1710
issuing the ecall instruction,|
|

399
00:11:09,680 --> 00:11:12,050
0,810 1050,1620 1740,2040 2040,2160 2160,2370
which {} switch is another
哪个{}开关是另一个内核管理程序模式，

400
00:11:12,050 --> 00:11:13,970
0,330 330,1230 1230,1470 1470,1620 1620,1920
kernel supervisor mode where that


401
00:11:13,970 --> 00:11:15,590
0,420 420,1170 1170,1350 1350,1440 1440,1620
goes immediately,| that is the
|即第一条指令在内核和管理程序模式中执行，

402
00:11:15,590 --> 00:11:17,990
0,390 390,720 720,1410 1710,1890 1890,2400
very first instruction is executed


403
00:11:17,990 --> 00:11:19,190
0,90 90,150 150,450 450,540 540,1200
in the kernel and supervisor


404
00:11:19,190 --> 00:11:21,230
0,420 600,990 990,1260 1260,1440 1440,2040
mode,| {} is a function
|{}是用汇编语言编写的函数

405
00:11:21,230 --> 00:11:23,540
0,210 210,330 330,1080 1200,2070
written in assembler| called
|已呼叫{}{用户返回}。

406
00:11:23,600 --> 00:11:25,040
0,300 300,660 660,1200
{} {user back}.|
|

407
00:11:26,140 --> 00:11:27,430
0,330 330,600 600,750 750,930 930,1290
And this is in the
这是蹦床的一部分，

408
00:11:27,520 --> 00:11:29,180
0,210 210,270 270,330 330,1350
part of the trampoline,|
|

409
00:11:29,540 --> 00:11:30,440
0,690


410
00:11:33,400 --> 00:11:35,380
0,210 210,510 510,1080 1080,1320 1320,1980
{} in {trampoline.S - -}
{}在内核源代码的{trampoline.S--}中，

411
00:11:35,410 --> 00:11:36,250
0,150 150,210 210,480 480,750 750,840
in the kernel source,| so
|所以第一个被执行的代码，这个用户Beck汇编器函数。

412
00:11:36,250 --> 00:11:37,390
0,150 150,480 480,720 720,990 990,1140
the very first code that's


413
00:11:37,390 --> 00:11:39,460
0,540 540,720 720,990 990,1380 1410,2070
executed, this user beck assembler


414
00:11:39,460 --> 00:11:40,440
0,630
function.|
|

415
00:11:40,620 --> 00:11:43,590
0,510 1320,1650 1650,2310 2430,2640 2640,2970
{} And next, {} that
{}接下来，{}汇编器函数跳转到C代码，

416
00:11:43,590 --> 00:11:44,910
0,390 390,690 690,930 930,1110 1110,1320
assembler function jumps into C


417
00:11:44,910 --> 00:11:46,620
0,330 330,420 420,1110 1170,1410 1410,1710
code,| in particular a function
|特别是{trap.c-}中名为{user trap}的函数。

418
00:11:46,620 --> 00:11:47,960
0,210 210,510 510,1110
called {user trap},


419
00:11:48,260 --> 00:11:49,920
0,630 630,900 900,1410
in {trap.c -}.|
|

420
00:11:50,850 --> 00:11:52,260
0,300 300,540 540,990 990,1230 1230,1410
And now we're getting into
现在我们开始学习C代码，所以事情就容易理解了，

421
00:11:52,260 --> 00:11:54,030
0,180 180,660 660,1080 1140,1650 1650,1770
C code, so things are


422
00:11:54,030 --> 00:11:55,830
0,240 240,510 510,570 570,1230 1410,1800
much easier to understand,| user
|用户陷阱看到，哦，我们正在执行系统调用。

423
00:11:55,830 --> 00:11:57,720
0,240 240,630 630,1080 1140,1530 1530,1890
trap sees oh we're executing


424
00:11:57,720 --> 00:11:58,960
0,60 60,360 360,960
a system call.|
|

425
00:11:58,990 --> 00:11:59,830
0,150 150,210 210,480 480,540 540,840
And it calls a function
它调用一个名为{syscall-}的函数。

426
00:11:59,830 --> 00:12:01,020
0,210 210,420 420,900
called {syscall -}.|
|

427
00:12:02,580 --> 00:12:03,390
0,240 240,450 450,630 630,750 750,810
{} Which looks at the
{}，它查看表中的系统调用号

428
00:12:03,390 --> 00:12:04,230
0,300 300,480 480,720 720,780 780,840
system call number in a


429
00:12:04,230 --> 00:12:06,600
0,510 660,1350 1380,1830 1830,1920 1920,2370
table| and calls the particular
|并调用内核内的特定函数

430
00:12:06,600 --> 00:12:08,340
0,360 360,810 810,870 870,1380 1380,1740
function inside the kernel| that
|它实现了调用我们系统，它将被写入

431
00:12:08,940 --> 00:12:10,290
0,450 450,600 600,900 900,1170 1170,1350
implements that system calling for


432
00:12:10,290 --> 00:12:11,190
0,210 210,360 360,480 480,570 570,900
us it's going to be


433
00:12:11,430 --> 00:12:12,510
0,480 480,600 600,780 780,930 930,1080
write| and write does this
|写这件事如果发生的话，

434
00:12:12,510 --> 00:12:15,990
0,420 420,600 600,1080 1080,1650 2550,3480
business it happens,| to arrange
|要安排写入的任何字节显示在控制台上，请执行以下操作

435
00:12:15,990 --> 00:12:17,460
0,270 270,720 720,1050 1050,1170 1170,1470
for whatever bytes were written


436
00:12:17,460 --> 00:12:19,020
0,210 240,660 660,750 750,810 810,1560
to appear on the console|
|

437
00:12:20,130 --> 00:12:21,750
0,300 300,420 420,570 570,1230 1260,1620
and when it's finished it
当它完成时，它返回到这个系统调用函数

438
00:12:21,750 --> 00:12:23,130
0,360 360,660 690,900 900,990 990,1380
returns back up to this


439
00:12:23,160 --> 00:12:25,290
0,390 390,600 600,1140 1500,1890 1890,2130
system call function| and then
|然后系统调用函数以返回到用户空间，

440
00:12:25,290 --> 00:12:26,670
0,150 150,450 450,600 600,1170 1230,1380
the system call function in


441
00:12:26,670 --> 00:12:27,570
0,180 180,270 270,630 630,810 810,900
order to return back to


442
00:12:27,570 --> 00:12:28,500
0,270 270,510 510,690 690,780 780,930
user space,| because we want
|因为我们想重新开始。

443
00:12:28,500 --> 00:12:29,640
0,90 90,870
to resume.|
|

444
00:12:29,740 --> 00:12:31,540
0,300 300,480 480,600 600,1080 1320,1800
After this {ecall -}, {}
在这个{eCall-}之后，{}有一堆东西，

445
00:12:31,690 --> 00:12:32,890
0,270 270,300 300,510 510,570 570,1200
there's a bunch of stuff,|
|

446
00:12:32,920 --> 00:12:33,820
0,300 300,570 570,660 660,810 810,900
we'll see, that has to
我们拭目以待，那是必须要发生的。

447
00:12:33,820 --> 00:12:34,580
0,450
happen.|
|

448
00:12:34,790 --> 00:12:35,720
0,270 270,360 360,540 540,600 600,930
{} In order to return
{}为了返回用户空间，

449
00:12:35,720 --> 00:12:36,620
0,60 60,330 330,720 720,870 870,900
to user space,| there's a
|有一个单独的函数，名为user{}{陷阱鼠}，

450
00:12:36,620 --> 00:12:38,660
0,390 390,720 720,1020 1020,1800
separate function called user


451
00:12:39,760 --> 00:12:42,340
0,480 540,1050 1080,1770
{} {trap rat},|
|

452
00:12:42,900 --> 00:12:43,920
0,210 210,360 360,540 540,630 630,1020
{} it's written in C,
{}它是用C写的，它在{trap.c-}中，

453
00:12:43,920 --> 00:12:45,360
0,150 150,540 540,780 780,1170 1170,1440
it's in {trap.c -},| that
|这一部分确实会返回到用户空间，

454
00:12:45,900 --> 00:12:47,310
0,630 630,750 750,1140 1140,1230 1230,1410
does the part of this


455
00:12:47,310 --> 00:12:48,870
0,390 390,480 480,720 720,1140 1140,1560
return to user space,| that's
|这在C代码中很方便，

456
00:12:48,870 --> 00:12:49,950
0,510 510,570 570,720 720,840 840,1080
convenient to do in C


457
00:12:49,950 --> 00:12:51,300
0,510 600,810 810,930 930,1200 1200,1350
code,| there's some final things
|有一些最后的事情只能在汇编代码中完成{}，

458
00:12:51,300 --> 00:12:52,020
0,120 120,300 300,420 420,630 630,720
that really can only be


459
00:12:52,020 --> 00:12:54,240
0,180 180,300 300,690 690,1140 1680,2220
done in assembly code {},|
|

460
00:12:55,000 --> 00:12:55,870
0,120 120,360 360,450 450,720 720,870
the code for that is
这方面的代码是在汇编程序期间编写的

461
00:12:55,870 --> 00:12:57,400
0,240 240,390 390,840 840,1140 1170,1530
during an assembler| and again
|在这个蹦床页面中，同样是在一个名为{userret-}的函数中。

462
00:12:57,400 --> 00:12:59,170
0,90 90,210 210,780 780,1350 1530,1770
in this trampoline page in


463
00:12:59,170 --> 00:13:00,400
0,30 30,330 330,570 570,870 870,1230
a function called {userret -}.|
|

464
00:13:03,710 --> 00:13:06,680
0,570 630,900 900,1800 1830,2370 2400,2970
{} The last last assembly
{}必须进行最后的组装工作

465
00:13:06,920 --> 00:13:07,940
0,300 300,540 540,630 630,870 870,1020
stuff has to happen| and
|最后{}{}这个汇编函数出了问题，

466
00:13:07,940 --> 00:13:09,560
0,570 750,1380
finally, {}


467
00:13:10,000 --> 00:13:11,680
0,240 240,420 420,840 840,1230 1230,1680
{} this assembly function issues,|
|

468
00:13:11,680 --> 00:13:13,540
0,210 210,810 810,1380 1380,1530 1530,1860
the machine instruction that returns
返回到用户空间的机器指令

469
00:13:13,540 --> 00:13:15,070
0,210 210,360 360,600 600,1080 1080,1530
back in user space| and
|并在eCall之后恢复执行。

470
00:13:15,250 --> 00:13:16,840
0,600 600,1320
resume execution


471
00:13:18,160 --> 00:13:20,520
0,360 360,450 450,870
after the ecall.|
|

472
00:13:20,770 --> 00:13:22,210
0,300 300,480 480,810 810,960 960,1440
Right, does anybody want to
好的，有没有人想问个问题，

473
00:13:22,210 --> 00:13:23,350
0,180 180,240 240,630 630,810 810,1140
ask a question,| I'm about
|我正要换成用{gdb-}看东西，

474
00:13:23,350 --> 00:13:25,150
0,180 180,450 450,1200 1230,1590 1590,1800
just switch into looking stuff


475
00:13:25,150 --> 00:13:27,460
0,90 90,360 360,810 1710,1950 1950,2310
with {gdb -},| any questions
|关于高级图片有什么问题吗？

476
00:13:27,460 --> 00:13:28,600
0,240 240,420 420,600 600,660 660,1140
about the sort of high-level


477
00:13:28,600 --> 00:13:29,300
0,480
picture?|
|

478
00:13:32,960 --> 00:13:33,980
0,180


479
00:13:36,970 --> 00:13:38,980
0,780 810,1260 1260,1470 1470,1740 1740,2010
Alright I am going to.|
好的，我会的。|

480
00:13:38,980 --> 00:13:40,240
0,270 270,930


481
00:13:40,820 --> 00:13:41,800
0,270 270,390 390,750
Sorry I can't.|
对不起我不能。|

482
00:13:42,270 --> 00:13:44,370
0,870 1200,1410 1410,1500 1500,1830 1830,2100
Um, let me see what
嗯，让我看看{vm.c--}函数在什么模式下运行？

483
00:13:44,370 --> 00:13:45,750
0,270 270,420 420,900 900,1170 1170,1380
mode are {vm.c - -}


484
00:13:45,750 --> 00:13:47,100
0,420 420,900
functions running?|
|

485
00:13:47,690 --> 00:13:49,040
0,480 510,720 720,870 870,1050 1050,1350
{vm.c - - -} functions,
{vm.c-}个函数，其中的所有内容都是内核的一部分，

486
00:13:49,040 --> 00:13:50,180
0,330 330,420 420,660 660,900 900,1140
everything in there is part


487
00:13:50,180 --> 00:13:50,900
0,60 60,120 120,480 480,570 570,720
of the kernel,| and it's
|它正在运行管理模式。

488
00:13:50,900 --> 00:13:52,580
0,210 210,810 810,1200
running supervisor mode.|
|

489
00:13:54,760 --> 00:13:55,760
0,690


490
00:13:56,200 --> 00:13:57,120
0,360 360,420
Got it.|
明白了。|

491
00:13:57,700 --> 00:13:58,340
0,510
Yeah.|
嗯。|

492
00:14:00,440 --> 00:14:02,090
0,450 480,840 840,1050 1050,1410 1410,1650
OK, somebody asked why these
好的，有人问为什么这些函数要这样命名？

493
00:14:02,090 --> 00:14:03,350
0,360 360,450 450,690 690,840 840,1260
functions are named this way?|
|

494
00:14:03,710 --> 00:14:04,760
0,630
Um.|
恩。|

495
00:14:05,960 --> 00:14:06,860
0,300 300,450 450,720 720,840 840,900
{} The naming is a
{}命名有点像灾难

496
00:14:06,860 --> 00:14:08,060
0,150 150,210 210,270 270,900 900,1200
bit of a disaster| and
|明年，我决心让他们变得更理性。

497
00:14:08,060 --> 00:14:09,350
0,120 120,390 390,570 570,690 690,1290
for next year, I'm resolved


498
00:14:09,350 --> 00:14:11,090
0,600 630,900 900,990 990,1140 1140,1740
to make them more rational.|
|

499
00:14:11,780 --> 00:14:12,480
0,450


500
00:14:13,830 --> 00:14:14,880
0,60 60,240 240,330 330,660 660,1050
I think the naming question
我想命名问题可能指的是登记册的名称。

501
00:14:14,880 --> 00:14:16,020
0,150 150,300 300,690 690,870 870,1140
might have referred to the


502
00:14:16,020 --> 00:14:17,400
0,270 270,390 390,480 480,1260 1260,1380
name of the registers| in
|在前一块板上。

503
00:14:17,400 --> 00:14:20,550
0,90 90,870 960,1440 2340,2850 2850,3150
the previous board.| As for
|至于主管，[分析]。有五个人选了这些名字。

504
00:14:20,550 --> 00:14:22,500
0,870
supervisor,


505
00:14:24,180 --> 00:14:26,000
0,1080
[analytics].


506
00:14:26,340 --> 00:14:28,140
0,390 390,660 660,1110 1380,1590 1590,1800
There's five people pick these


507
00:14:28,140 --> 00:14:31,050
0,540 900,1440 2010,2340 2340,2610 2610,2910
names.| {} Somebody's asking don't
|{}有人问[m.c]函数不是直接访问物理内存吗？

508
00:14:31,050 --> 00:14:32,310
0,120 120,270 270,420 420,600 600,1260
be [m dot c] functions


509
00:14:32,310 --> 00:14:34,710
0,450 450,750 750,1290 1380,2010 2070,2400
access physical memory directly?| That's
|这是绝对正确的，他们被允许这样做的原因

510
00:14:34,710 --> 00:14:36,540
0,510 510,1050 1170,1410 1410,1680 1680,1830
absolutely true, the reason why


511
00:14:36,540 --> 00:14:37,380
0,120 120,360 360,450 450,600 600,840
they're allowed to do that|
|

512
00:14:37,380 --> 00:14:38,340
0,300 300,480 480,600 600,690 690,960
though is that the kernel
虽然内核在页表中精心设置了直接的{map‘s-}，

513
00:14:38,340 --> 00:14:40,920
0,840 960,1380 1380,1560 1560,2070 2070,2580
carefully sets up direct {mapping's


514
00:14:40,920 --> 00:14:42,240
0,150 150,300 300,390 390,750 750,1320
-} in the page table,|
|

515
00:14:42,510 --> 00:14:43,890
0,360 360,510 510,720 720,930 930,1380
there's been many many ptes
页表中有很多很多PTE，

516
00:14:43,890 --> 00:14:44,910
0,90 90,180 180,450 450,750 750,1020
in the page table,| which
|这导致{}每当内核试图读取或写入物理地址时，

517
00:14:44,910 --> 00:14:48,030
0,780 1110,1650 1770,2310 2310,2400 2400,3120
cause, {} whenever the kernel


518
00:14:48,420 --> 00:14:49,290
0,240 240,360 360,540 540,540 540,870
tries to read or write


519
00:14:49,290 --> 00:14:50,760
0,210 210,540 540,1050 1050,1140 1140,1470
a physical address,| it actually
|它实际上是由内核页表转换的虚拟地址

520
00:14:50,760 --> 00:14:51,780
0,90 90,150 150,480 480,840 840,1020
is a virtual address that's


521
00:14:51,780 --> 00:14:54,000
0,900 1200,1530 1530,1620 1620,1920 1920,2220
translated by the kernel page


522
00:14:54,000 --> 00:14:55,440
0,360 360,510 510,630 630,840 1080,1440
table| and is a physical
|并且是与发出的虚拟地址相等的物理地址。

523
00:14:55,440 --> 00:14:56,880
0,270 270,450 480,1050 1080,1230 1230,1440
address that's equal to the


524
00:14:56,880 --> 00:14:58,110
0,330 330,630 630,690 690,840 840,1230
virtual address who was issued.|
|

525
00:14:58,760 --> 00:15:00,380
0,390 450,660 660,780 780,1200 1200,1620
So it's like super convenient
所以这就像是内核中的超级方便，

526
00:15:00,380 --> 00:15:01,970
0,60 60,120 120,750 990,1350 1350,1590
in the kernel,| what once
|一旦您使用内核页表，

527
00:15:01,970 --> 00:15:03,200
0,150 150,480 480,570 570,870 870,1230
you're using the kernel page


528
00:15:03,200 --> 00:15:04,610
0,480 510,870 900,1200 1200,1350 1350,1410
table,| this kernel has all
|这个内核有所有这些直接的{mappings-}，

529
00:15:04,610 --> 00:15:06,830
0,210 210,600 600,1050 1050,1410 1650,2220
these direct {mappings -},| but
|但在我们准备好之前，

530
00:15:06,890 --> 00:15:08,700
0,630 630,840 840,1140 1140,1560
until we've set up,|
|

531
00:15:08,940 --> 00:15:11,190
0,300 300,390 390,660 690,1710 2100,2250
{} the current until the
{}当前直到捕获机切换到内核页表，

532
00:15:11,190 --> 00:15:12,390
0,300 300,660 660,780 780,1140 1140,1200
trap machinery has switched to


533
00:15:12,390 --> 00:15:13,920
0,60 60,330 330,600 600,1020 1110,1530
the kernel page table,| none
|这些映射都不可用

534
00:15:13,920 --> 00:15:15,180
0,60 60,240 240,630 630,750 750,1260
of those mappings are available|
|

535
00:15:15,780 --> 00:15:17,760
0,360 360,630 1170,1470 1470,1800 1800,1980
until the kernel trap code
在内核陷阱代码切换到内核页表之前，

536
00:15:17,760 --> 00:15:18,450
0,60 60,330 330,390 390,450 450,690
is switched to the kernel


537
00:15:18,450 --> 00:15:19,410
0,240 240,480 480,570 570,750 750,960
page table,| we're still using
|我们仍在使用用户页表

538
00:15:19,410 --> 00:15:20,370
0,60 60,360 360,600 600,810 810,960
the user page table| which
|对于物理地址，它没有这些方便的{mappings-}。

539
00:15:20,370 --> 00:15:21,750
0,120 120,540 540,630 630,870 870,1380
has none of these convenient


540
00:15:21,750 --> 00:15:24,630
0,390 390,810 1530,1920 1920,2250 2250,2880
{mappings -} for physical addresses.|
|

541
00:15:26,580 --> 00:15:27,620
0,780


542
00:15:29,580 --> 00:15:32,200
0,1020
Okay.|
好吧。|

543
00:15:34,400 --> 00:15:35,240
0,420 420,570 570,630 630,780 780,840
{} Can I ask a
{}我可以问个问题吗？

544
00:15:35,240 --> 00:15:39,020
0,450 900,1530 1980,2520 2550,3270 3270,3780
question?| Please.| Um, so, {}
|请。|嗯，所以{}{}我不知道这可能跟刚才说的不太相关，

545
00:15:40,320 --> 00:15:42,060
0,570 810,1020 1020,1170 1170,1440 1440,1740
{} I don't know this


546
00:15:42,060 --> 00:15:43,770
0,180 180,450 450,690 690,1110 1110,1710
is maybe not exactly relevant


547
00:15:43,770 --> 00:15:44,730
0,90 90,270 270,450 450,660 660,960
to what was just said,|
|

548
00:15:44,730 --> 00:15:46,830
0,270 300,810 1110,1440 1440,1830 1830,2100
but um, {} the read
但是，嗯，{}读写系统调用

549
00:15:46,830 --> 00:15:48,270
0,150 150,390 390,780 780,1140 1140,1440
and write system calls| right
|对，就像那些与内存存储相比是相当昂贵的，

550
00:15:48,300 --> 00:15:50,670
0,240 240,570 570,840 840,1080 1080,2370
like those are pretty expensive


551
00:15:50,670 --> 00:15:52,200
0,450 450,570 570,810 810,870 870,1530
compared to just the memory


552
00:15:52,200 --> 00:15:53,220
0,420 420,660 660,750 750,900 900,1020
store,| because you have to
|因为你必须实际切换模式并来回切换，

553
00:15:53,220 --> 00:15:54,450
0,270 270,600 600,960 960,1080 1080,1230
actually switch mode and go


554
00:15:54,450 --> 00:15:55,860
0,210 210,330 330,660 960,1320 1320,1410
back and forth,| would it
|有没有可能就像，

555
00:15:55,860 --> 00:15:57,420
0,150 150,690 690,840 840,1200 1200,1560
be possible to just like,|
|

556
00:15:57,800 --> 00:15:59,060
0,450 450,570 570,900 900,1140 1140,1260
instead of when when you
而不是当您打开文件而不是取回文件描述符时，

557
00:15:59,060 --> 00:16:00,530
0,330 330,450 450,930 930,1350 1350,1470
open a file instead of


558
00:16:00,530 --> 00:16:02,030
0,330 330,570 570,660 660,960 960,1500
getting back a file descriptor,|
|

559
00:16:02,030 --> 00:16:03,020
0,150 150,330 330,750 750,930 930,990
that you call with a
您可以使用系统调用来调用它来获取页表映射，

560
00:16:03,020 --> 00:16:04,790
0,390 390,870 900,1200 1200,1440 1440,1770
system call to get a


561
00:16:05,240 --> 00:16:07,490
0,810 810,1140 1140,1860 1950,2130 2130,2250
page table mapping,| and then
|然后你只需写到某个地址，

562
00:16:07,490 --> 00:16:08,570
0,120 120,240 240,450 450,870 870,1080
you would just write to


563
00:16:08,570 --> 00:16:10,850
0,330 360,780 780,1560 1770,2010 2010,2280
a certain address,| {} that's
|{}刚刚映射到设备的，

564
00:16:10,850 --> 00:16:13,040
0,300 300,930 930,1110 1110,1380 1380,2190
just mapped to the device,|
|

565
00:16:13,280 --> 00:16:14,060
0,210 210,300 300,450 450,660 660,780
and you can set up
你可以设置这些限制，

566
00:16:14,060 --> 00:16:15,830
0,90 90,810 810,960 960,1260 1290,1770
the restrictions,| so that the
|这样程序就只能写入，就像文件描述符一样

567
00:16:16,370 --> 00:16:17,810
0,510 510,660 660,900 900,1290 1290,1440
program can only write to


568
00:16:17,810 --> 00:16:19,460
0,330 330,750 750,930 930,1320 1350,1650
a, to like a file


569
00:16:19,460 --> 00:16:20,840
0,450 450,630 630,780 780,1230 1230,1380
descriptor| that it's allowed to
|它被允许抛出虚拟页表映射，

570
00:16:20,840 --> 00:16:22,130
0,240 240,480 510,930 930,1080 1080,1290
which is allowed to throw


571
00:16:22,130 --> 00:16:23,810
0,120 120,480 480,900 930,1230 1230,1680
the virtual page table mapping,|
|

572
00:16:23,810 --> 00:16:24,830
0,330 330,450 450,810 810,900 900,1020
instead of jumping to the
而不是跳回内核。

573
00:16:24,830 --> 00:16:26,810
0,450 450,840 1380,1560 1560,1920 1920,1980
kernel back.| Yeah that's a
|是的，这是一个很好的观察

574
00:16:26,810 --> 00:16:29,600
0,240 240,990 1020,1440 1440,2160 2250,2790
good observation| and indeed {}
|事实上，{}许多操作系统都提供这种所谓的内存映射文件访问，

575
00:16:29,630 --> 00:16:31,310
0,270 270,570 570,960 960,1320 1320,1680
many operating systems provide this


576
00:16:31,310 --> 00:16:33,230
0,300 300,690 690,1200 1200,1530 1530,1920
what's called memory mapped file


577
00:16:33,230 --> 00:16:35,320
0,600 600,1020 1200,1770
access,| where indeed
|其中确实与文件内容相对应的地图页

578
00:16:35,400 --> 00:16:36,570
0,120 120,360 360,690 690,780 780,1170
the map pages that correspond


579
00:16:36,570 --> 00:16:38,250
0,60 60,150 150,390 390,1290 1380,1680
to the file contents| into
|进入您的虚拟进入用户虚拟地址空间，

580
00:16:38,250 --> 00:16:39,540
0,210 210,450 450,600 600,1080 1110,1290
the into your virtual into


581
00:16:39,540 --> 00:16:41,610
0,720 810,1320 1320,1560 1560,1950 1950,2070
user virtual address space,| so
|所以你可以直接通过内存读取或写入它们，

582
00:16:41,610 --> 00:16:42,360
0,90 90,210 210,420 420,510 510,750
you can read or write


583
00:16:42,360 --> 00:16:44,550
0,270 330,780 780,930 930,1410 1830,2190
them directly through memory,| in
|事实上，您将在几周内在{}{mmap，lab}中实现此版本。

584
00:16:44,820 --> 00:16:46,110
0,450 450,600 600,720 720,1230 1230,1290
fact you'll be implementing a


585
00:16:46,110 --> 00:16:47,580
0,300 300,390 390,840 840,1170 1170,1470
version of this in the


586
00:16:47,610 --> 00:16:49,140
0,180 180,990 1080,1200 1200,1260 1260,1530
{} {mmap,lab}, in a couple


587
00:16:49,140 --> 00:16:49,960
0,60 60,720
of weeks.|
|

588
00:16:50,010 --> 00:16:50,800
0,570


589
00:16:51,230 --> 00:16:53,270
0,420 420,930 930,1110 1110,1500 1710,2040
And indeed as you imply
事实上，正如你所暗示的那样，它要快得多，

590
00:16:53,270 --> 00:16:54,710
0,240 240,330 330,540 540,780 780,1440
it's a good deal faster,|
|

591
00:16:54,980 --> 00:16:56,330
0,150 150,360 360,900 900,1050 1050,1350
for many programs than calling
对于许多程序来说，而不是调用读取和写入。

592
00:16:56,330 --> 00:16:57,100
0,120 120,270 270,480
read and write.|
|

593
00:16:59,100 --> 00:17:00,480
0,510
Okay.|
好吧。|

594
00:17:02,380 --> 00:17:04,030
0,150 150,240 270,660 660,1500 1500,1650
I am {} switch to
我要{}切换到gdb世界。

595
00:17:04,030 --> 00:17:06,440
0,510 540,1410 1410,2040
the gdb world.|
|

596
00:17:06,970 --> 00:17:08,000
0,780


597
00:17:19,540 --> 00:17:20,680
0,300 300,360 360,510 510,750 750,1140
Alright, at this point, everybody
好的，现在大家都应该，嗯。

598
00:17:20,680 --> 00:17:21,840
0,390 390,810
should, um.|
|

599
00:17:26,200 --> 00:17:28,920
0,450 450,900 900,1440 1440,2040
See my screen share.|
查看我的屏幕共享。|

600
00:17:29,660 --> 00:17:30,640
0,660
Um.|
恩。|

601
00:17:31,210 --> 00:17:32,140
0,150 150,270 270,330 330,630 630,930
We're going to watch an
我们将观看一个名为“写入”的xv6系统。

602
00:17:32,140 --> 00:17:34,150
0,270 270,630 630,1170 1200,1440 1440,2010
xv6 system called the write.|
|

603
00:17:34,770 --> 00:17:36,270
0,510 540,660 660,1080 1080,1410 1410,1500
{} The shell's write of
{}shell对其初始提示符的写入，

604
00:17:36,270 --> 00:17:38,370
0,360 360,630 630,1200 1620,1920 1920,2100
its initial prompt,| {} make
|{}在系统中穿行，

605
00:17:38,370 --> 00:17:39,120
0,120 120,240 240,360 360,450 450,750
its way through the system,|
|

606
00:17:39,120 --> 00:17:40,470
0,90 90,210 210,720 720,840 840,1350
you can see the user
您可以在{sh.c-}{}中看到发起此操作的用户代码。

607
00:17:40,470 --> 00:17:42,480
0,600 600,750 750,1260 1260,1680 1680,2010
code that initiates this in


608
00:17:42,480 --> 00:17:44,460
0,180 180,420 420,690 690,1110 1560,1980
{sh.c - - -} {}.|
|

609
00:17:44,960 --> 00:17:45,920
0,240 240,480 480,690 690,780 780,960
I'm sure that {} was
我确信{}只是在进行{}写入系统调用，

610
00:17:45,920 --> 00:17:46,940
0,180 180,720
just making


611
00:17:47,290 --> 00:17:48,670
0,180 180,300 300,570 570,930 930,1380
{} the write system call,|
|

612
00:17:49,090 --> 00:17:50,710
0,330 330,480 480,810 810,1080 1080,1620
with this dollar sign, prompt
使用此美元符号，提示{}我们启动{}{gdb-}。

613
00:17:51,100 --> 00:17:53,120
0,480 690,900 900,1320 1320,1770
{} we fire up


614
00:17:57,010 --> 00:17:58,540
0,450 450,720 720,1260
{} {gdb -}.|
|

615
00:18:01,300 --> 00:18:02,300
0,780


616
00:18:03,330 --> 00:18:06,510
0,600 750,1230 2070,2340 2340,2580 2580,3180
Excellent, so what actually happens
太好了，那么当用户代码在shell调用write时实际发生了什么呢？

617
00:18:06,510 --> 00:18:08,130
0,270 270,750 750,1320 1320,1530 1530,1620
when user code when the


618
00:18:08,130 --> 00:18:09,900
0,360 360,750 750,1140 1140,1440 1440,1770
shell calls write,| write is
|写只是一个库函数

619
00:18:09,900 --> 00:18:11,490
0,420 420,960 960,1110 1110,1140 1140,1590
just a it's a library


620
00:18:11,490 --> 00:18:12,500
0,360 360,750
function| that's
|这是连接到外壳中的{}部分-}a，{}，

621
00:18:12,640 --> 00:18:14,440
0,600 780,1140 1140,1290 1290,1410 1410,1800
{} part {of's -} a,


622
00:18:15,600 --> 00:18:16,620
0,300 300,540 540,780 780,900 900,1020
{} that's linked into the


623
00:18:16,620 --> 00:18:18,330
0,540 900,1230 1230,1470 1470,1590 1590,1710
shell,| {}  and you can
|{}，您可以在{usys.S-}中看到它的源代码。

624
00:18:18,330 --> 00:18:19,770
0,420 420,600 600,1020 1020,1290 1290,1440
see the source for it


625
00:18:19,770 --> 00:18:22,000
0,450 480,900 900,1050 1050,1890
in {usys.S - -


626
00:18:22,210 --> 00:18:23,660
0,450 510,1290
- -}.|
|

627
00:18:24,660 --> 00:18:25,980
0,240 240,690 750,990 990,1230 1230,1320
So it's this couple of
就是这两条指令，这是Write函数的实现，

628
00:18:25,980 --> 00:18:27,440
0,540 540,900 900,1170
instructions, here's the


629
00:18:27,960 --> 00:18:30,120
0,870 870,960 960,1110 1110,1440 1440,2160
implementation of the write function,|
|

630
00:18:30,390 --> 00:18:31,230
0,150 150,240 240,420 420,510 510,840
that the shell is actually
贝壳实际上在呼唤，

631
00:18:31,230 --> 00:18:33,020
0,450 870,1380
calling,| and
|{}这是一个非常短的函数，

632
00:18:33,480 --> 00:18:34,290
0,300 300,480 480,540 540,600 600,810
{} this is a very


633
00:18:34,290 --> 00:18:36,120
0,180 180,660 780,1110 1110,1410 1410,1830
short function,| all it's doing
|它所做的就是将一个数字{sys_write-}加载到{A7-}中，

634
00:18:36,120 --> 00:18:37,710
0,330 330,660 660,840 840,1050 1050,1590
is loading into {a7 -}


635
00:18:37,710 --> 00:18:39,600
0,120 120,750 780,1200 1200,1590 1590,1890
a number {sys_write -},| it's
|它只是象征性地定义为16，这告诉内核，

636
00:18:39,600 --> 00:18:41,220
0,330 360,1020 1020,1440 1440,1500 1500,1620
just symbolically defined to be


637
00:18:41,220 --> 00:18:42,840
0,630 630,720 720,930 930,1020 1020,1620
sixteen that tells the kernel,|
|

638
00:18:43,350 --> 00:18:44,670
0,480 480,480 480,780 780,1020 1050,1320
{} I want to run
{}我想运行碰巧是Write的第16个系统调用。

639
00:18:44,670 --> 00:18:47,070
0,120 120,1050 1200,1980 1980,2220 2220,2400
the sixteenth system call which


640
00:18:47,070 --> 00:18:48,280
0,300 300,360 360,450 450,930
happens to be write.|
|

641
00:18:48,340 --> 00:18:49,270
0,270 270,450 450,600 600,750 750,930
{} And then this little
{}然后这个小函数使用{eCall-}指令，

642
00:18:49,270 --> 00:18:51,070
0,540 900,1170 1170,1350 1350,1530 1530,1800
function uses the {ecall -}


643
00:18:51,070 --> 00:18:53,080
0,810 1050,1470 1470,1680 1680,1800 1800,2010
instruction,| {} which is what
|{}实际上就是{}将代码放入内核，

644
00:18:53,080 --> 00:18:53,920
0,540
actually


645
00:18:53,980 --> 00:18:55,210
0,360 570,810 810,870 870,1080 1080,1230
{} gets the code into


646
00:18:55,210 --> 00:18:56,650
0,60 60,570 600,840 840,1260 1260,1440
the kernel,| the kernel does
|内核做这件事，然后当内核可以停机时，

647
00:18:56,650 --> 00:18:59,080
0,150 150,720 1140,1830 2010,2280 2280,2430
this thing and then when


648
00:18:59,080 --> 00:18:59,860
0,60 60,270 270,480 480,570 570,780
the kernel can be down,|
|

649
00:18:59,860 --> 00:19:02,380
0,150 150,960 1590,2070 2070,2220 2220,2520
it returns back into user
它返回到用户空间以在eCall之后执行指令，

650
00:19:02,380 --> 00:19:03,730
0,300 300,390 390,810 810,900 900,1350
space to execute the instruction


651
00:19:03,730 --> 00:19:05,350
0,270 270,390 390,960 1110,1500 1500,1620
after the ecall,| which is
|这是返回到外壳的写操作，

652
00:19:05,350 --> 00:19:07,630
0,270 270,690 930,1230 1260,2040 2040,2280
that write that returns back


653
00:19:07,630 --> 00:19:09,520
0,60 60,150 150,780 1380,1800 1800,1890
to the shell,| returns from
|从该写入库函数返回到外壳中。

654
00:19:09,520 --> 00:19:11,170
0,240 240,600 630,1020 1020,1410 1410,1650
that write library function back


655
00:19:11,170 --> 00:19:11,980
0,120 120,210 210,540
into the shell.|
|

656
00:19:12,960 --> 00:19:13,740
0,240 240,390 390,510 510,690 690,780
So what I'd like to
所以我想要做的是展示系统调用的一部分，

657
00:19:13,740 --> 00:19:14,730
0,240 240,360 360,540 540,660 660,990
do in order to show


658
00:19:14,730 --> 00:19:15,570
0,90 90,390 390,600 600,780 780,840
the system call part of


659
00:19:15,570 --> 00:19:16,800
0,300 420,780 780,930 930,1020 1020,1230
this,| I'm going to start
|我将首先在eCall指令上设置一个断点，

660
00:19:16,800 --> 00:19:18,000
0,90 90,300 300,390 390,630 630,1200
by putting a break point


661
00:19:18,420 --> 00:19:21,630
0,330 330,630 660,1440 1470,2250 2700,3210
on that ecall instruction,| {}
|{}我们当然需要知道它的地址。

662
00:19:21,720 --> 00:19:23,040
0,570 840,960 960,1170 1170,1230 1230,1320
and we need to know


663
00:19:23,040 --> 00:19:24,340
0,120 120,450 450,510 510,1080
its address, of course.|
|

664
00:19:24,420 --> 00:19:25,290
0,240 240,360 360,480 480,720 720,870
But we can find that
但我们可以通过查看{sh.asm-}找到答案，

665
00:19:25,290 --> 00:19:26,220
0,150 150,270 270,570 570,720 720,930
out by looking in {sh.asm


666
00:19:26,220 --> 00:19:27,690
0,180 180,450 450,540 540,1170 1170,1470
- - - -},| which
|{xv6-}编译过程产生的，

667
00:19:28,170 --> 00:19:30,690
0,300 300,510 510,1260 1260,1740 1740,2520
{xv6 -} compilation process produces,|
|

668
00:19:31,230 --> 00:19:32,300
0,780


669
00:19:32,420 --> 00:19:33,740
0,390 390,540 540,780 780,1020 1020,1320
{sh.asm - - - -
{sh.asm-}，有{}个汇编代码，带有shell的地址，shell的指令，

670
00:19:33,740 --> 00:19:35,810
0,150 150,420 420,720 720,930 1320,2070
- -}, there's {} assembly


671
00:19:35,810 --> 00:19:38,480
0,270 270,450 450,1410 1710,2310 2340,2670
code with addresses of the,


672
00:19:38,480 --> 00:19:39,320
0,510


673
00:19:40,350 --> 00:19:42,690
0,210 210,1200 1230,1680 1710,1830 1830,2340
the instructions for the shell,|
|

674
00:19:43,050 --> 00:19:43,560
0,60 60,270 270,330 330,480 480,510
I'm going to put a
我将在{eCall-}指令上设置一个断点，

675
00:19:43,560 --> 00:19:44,610
0,270 270,600 600,750 750,900 900,1050
break point on the {ecall


676
00:19:44,610 --> 00:19:47,040
0,330 330,870 870,1020 1020,1320 1770,2430
-} instruction,| which is {}
|即{}d地址{DE6--}。

677
00:19:47,070 --> 00:19:49,230
0,420 450,930 930,1170 1170,1320 1320,2160
d address {de6 - -}.|
|

678
00:19:51,310 --> 00:19:53,320
0,420 420,570 570,900 1200,1530 1530,2010
Actually, I'm gonna actually start
实际上，我要开始运行{xv6-}，

679
00:19:53,320 --> 00:19:54,910
0,270 270,480 480,930 1350,1530 1530,1590
{xv6 -} running,| and I'm
|我希望在执行eCall之前让系统在外壳中崩溃。

680
00:19:54,910 --> 00:19:56,830
0,360 360,720 1050,1530 1530,1620 1620,1920
hoping to have the system


681
00:19:56,830 --> 00:19:59,050
0,540 840,1020 1020,1110 1110,1740 1800,2220
break in the shell just


682
00:19:59,050 --> 00:20:00,520
0,300 300,720 720,1230
before executing ecall.|
|

683
00:20:02,100 --> 00:20:04,740
0,360 390,1050 1200,1770 1830,2460 2490,2640
Alright, excellent, {} now, you
好的，太好了，{}现在你可以从gdb上看到，

684
00:20:04,740 --> 00:20:05,700
0,120 120,330 330,480 480,840 840,960
can see from gdb,| we're
|我们即将{}执行那个eCall。

685
00:20:05,700 --> 00:20:08,400
0,540 540,810 810,1200 2310,2610 2610,2700
about to {} about to


686
00:20:08,400 --> 00:20:09,860
0,390 390,630 630,1080
execute that ecall.|
|

687
00:20:10,330 --> 00:20:13,840
0,450 810,1350 1350,1590 1590,2310 2790,3510
{} Let's just check, {}
{}让我们检查一下，{}我们认为我们在哪里，

688
00:20:14,290 --> 00:20:15,100
0,180 180,270 270,480 480,660 660,810
there we are where we


689
00:20:15,100 --> 00:20:17,050
0,210 210,330 330,780 1140,1860 1860,1950
think we are,| print, we
|打印时，我们可以按要求打印程序计数器{0xde6--}。

690
00:20:17,050 --> 00:20:18,520
0,120 120,390 390,570 570,870 870,1470
can print the program counter


691
00:20:18,730 --> 00:20:20,260
0,570 570,960 960,1290 1290,1440 1440,1530
{0xde6 - -} just what


692
00:20:20,260 --> 00:20:23,560
0,120 120,450 450,780
we asked for.|
|

693
00:20:24,750 --> 00:20:26,910
0,900 1260,1380 1380,1500 1500,1680 1680,2160
Um, we can also print
嗯，我们也可以把所有的32张登记簿都打印出来。

694
00:20:26,910 --> 00:20:29,580
0,360 750,960 960,1380 1380,2520
the all 32 registers.|
|

695
00:20:30,060 --> 00:20:31,680
0,570 750,1170 1200,1410 1410,1470 1470,1620
And {} sum of these
和{}这些值的总和，不管我们不知道它们是什么，我们不在乎它们是什么，

696
00:20:31,680 --> 00:20:33,300
0,660 660,1020 1020,1140 1140,1290 1290,1620
values whatever we don't know


697
00:20:33,300 --> 00:20:34,050
0,120 120,270 270,480 480,600 600,750
we don't care what they


698
00:20:34,050 --> 00:20:36,000
0,360 390,750 750,1410 1410,1830 1830,1950
are,| but a0 a1 and
|但是a0、a1和a2是外壳传递写入的三个参数，

699
00:20:36,000 --> 00:20:38,010
0,720 750,1050 1050,1140 1140,1410 1410,2010
a2 are the three arguments


700
00:20:38,010 --> 00:20:39,510
0,150 150,240 240,540 540,960 990,1500
that the shell passed write,|
|

701
00:20:40,590 --> 00:20:41,520
0,210 210,360 360,810 810,900 900,930
so those arguments are a
所以这些参数是a0中的文件描述符，

702
00:20:41,520 --> 00:20:43,620
0,300 300,780 780,1200 1200,1590 1590,2100
file descriptor to in a0,|
|

703
00:20:44,040 --> 00:20:45,090
0,270 270,450 450,840 840,900 900,1050
{} the pointer to the
{}指向shell要写入的字符缓冲区的指针{A1-}

704
00:20:45,090 --> 00:20:46,740
0,360 360,450 450,1200 1200,1410 1410,1650
buffer of characters the shell


705
00:20:46,740 --> 00:20:47,850
0,240 240,390 390,810 810,990 990,1110
wants to write in {a1


706
00:20:47,850 --> 00:20:49,380
0,540 900,1140 1140,1200 1200,1440 1440,1530
-}| and the number of
|以及它想要在{a2-}中写入的字符数。

707
00:20:49,380 --> 00:20:50,700
0,480 480,570 570,840 840,960 960,1320
characters it wants to write


708
00:20:50,700 --> 00:20:51,860
0,300 300,450 450,870
in {a2 -}.|
|

709
00:20:52,150 --> 00:20:53,230
0,300 300,450 450,570 570,720 720,1080
{} And we can convince
{}我们可以说服自己，我们正在查看的是我们认为正在查看的代码。

710
00:20:53,230 --> 00:20:54,370
0,390 390,480 480,570 570,900 900,1140
ourselves that we're looking at


711
00:20:54,370 --> 00:20:55,360
0,210 240,540 540,660 660,900 900,990
a code we think we're


712
00:20:55,360 --> 00:20:56,300
0,240 240,540
looking at.|
|

713
00:20:56,820 --> 00:20:59,520
0,270 270,540 540,990 990,1470 2010,2700
I'm actually printing out,| {}
我实际上是在打印，|{}该缓冲区中的比特，外壳要写入

714
00:21:00,280 --> 00:21:01,990
0,360 360,960 960,1080 1080,1290 1290,1710
the bites in that buffer,


715
00:21:01,990 --> 00:21:03,160
0,240 240,510 510,750 750,870 870,1170
the shell wants to write|
|

716
00:21:03,160 --> 00:21:04,300
0,120 120,570 570,690 690,780 780,1140
and indeed, it's a dollar
事实上，这是一个美元符号和一个空格，

717
00:21:04,300 --> 00:21:06,520
0,600 780,1050 1050,1110 1110,1650 1650,2220
sign and a space,| so,
|所以，我们在我们，我们希望在的系统调用。

718
00:21:08,210 --> 00:21:09,230
0,240 240,390 390,480 480,750 750,1020
we're at the system call


719
00:21:09,230 --> 00:21:10,280
0,150 150,450 480,690 690,960 960,1050
that we, we hope to


720
00:21:10,280 --> 00:21:10,960
0,180 180,390
be at.|
|

721
00:21:11,350 --> 00:21:12,250
0,270 270,420 420,480 480,780 780,900
One thing to notice is
需要注意的一件事是程序计数器和堆栈指针都在低地址，

722
00:21:12,250 --> 00:21:13,780
0,180 180,420 510,1110 1110,1380 1380,1530
that the program counter and


723
00:21:13,780 --> 00:21:14,980
0,270 270,570 570,810 810,900 900,1200
stack pointer both at low


724
00:21:14,980 --> 00:21:17,020
0,810 930,1470 1470,1710 1710,1950 1950,2040
addresses,| addresses quite close to
|地址非常接近于零，

725
00:21:17,020 --> 00:21:20,560
0,330 330,660 1200,1710 2370,2790 2790,3540
zero,| and {} just reinforces
|而{}恰恰强化了我们的信念，

726
00:21:20,560 --> 00:21:22,030
0,330 330,870 870,1050 1050,1200 1200,1470
our belief,| that we're still
|我们仍然在用户和所有地址都很小的用户地址空间中执行，

727
00:21:22,030 --> 00:21:23,620
0,630 630,990 1020,1380 1380,1530 1530,1590
executing in user and the


728
00:21:23,620 --> 00:21:25,240
0,360 360,720 720,1170 1170,1410 1410,1620
user address space where all


729
00:21:25,240 --> 00:21:26,470
0,90 90,510 510,570 570,810 810,1230
the addresses are quite small,|
|

730
00:21:26,500 --> 00:21:27,040
0,180 180,270 270,390 390,450 450,540
once we get to the
一旦我们到达内核，就会看到地址是，

731
00:21:27,040 --> 00:21:28,420
0,420 420,600 600,750 750,1170 1170,1380
kernel's, see the addresses are,|
|

732
00:21:28,800 --> 00:21:29,550
0,150 150,210 210,420 420,480 480,750
{} the kernel is actually
{}内核在内存中的实际负载要高得多{}。

733
00:21:29,550 --> 00:21:30,660
0,330 330,540 540,720 720,1020 1020,1110
loaded much much higher in


734
00:21:30,660 --> 00:21:32,000
0,390 690,1020
memory {}.|
|

735
00:21:33,310 --> 00:21:34,460
0,930


736
00:21:35,020 --> 00:21:38,410
0,660 780,1320 1590,2610 2790,3090 3090,3390
Okay, {} we, the point
好的，{}我们，系统调用的要点是要切换很多状态，

737
00:21:38,410 --> 00:21:39,490
0,60 60,120 120,420 420,840 840,1080
of the system calls to


738
00:21:39,520 --> 00:21:40,510
0,420 420,750 750,780 780,930 930,990
switch around a lot of


739
00:21:40,510 --> 00:21:41,350
0,420 420,540 540,600 600,660 660,840
state,| one of the most
|必须切换的最重要的状态之一

740
00:21:41,350 --> 00:21:43,090
0,480 480,780 780,870 870,1440 1470,1740
important pieces of state that


741
00:21:43,090 --> 00:21:44,320
0,270 270,360 360,480 480,1080 1080,1230
has to get switched| and
|在它被切换之前，我们不得不接受当前的页表。

742
00:21:44,320 --> 00:21:45,040
0,90 90,180 180,300 300,570 570,720
we have to live with


743
00:21:45,040 --> 00:21:46,660
0,360 360,480 480,1050 1230,1500 1500,1620
before it's switched is the


744
00:21:46,660 --> 00:21:48,020
0,300 300,660 660,1080
current page table.|
|

745
00:21:48,280 --> 00:21:49,030
0,270 270,330 330,540 540,630 630,750
{} Of course we can
{}我们当然可以看{}{satp-}。

746
00:21:49,030 --> 00:21:51,400
0,180 180,420 930,1680 1680,1920 1920,2370
look at {} {satp -}.|
|

747
00:21:52,860 --> 00:21:54,540
0,840 930,1170 1170,1260 1260,1440 1440,1680
But all we get there
但是我们在那里得到的只是物理内存页表中的地址

748
00:21:54,540 --> 00:21:55,530
0,180 180,270 270,600 600,660 660,990
is the address in physical


749
00:21:55,530 --> 00:21:56,790
0,330 330,630 630,900 900,1020 1020,1260
memory page tables| and actually
|并实际告诉我们页表的映射是什么样子，

750
00:21:56,790 --> 00:21:58,110
0,240 240,390 390,690 690,1020 1050,1320
tell us much about what


751
00:21:58,110 --> 00:21:59,430
0,90 90,450 450,840 1080,1230 1230,1320
the mappings are with the


752
00:21:59,430 --> 00:22:01,230
0,240 240,480 480,720 720,1020 1470,1800
page table looks like,| {}
|{}幸好{qemu--}有办法让它打印当前页表

753
00:22:01,260 --> 00:22:04,140
0,630 840,1350 1350,1440 1440,1980 1980,2880
luckily there's a way in


754
00:22:04,170 --> 00:22:05,370
0,390 390,540 540,720 720,1110 1110,1200
{QEMU - -} ask it


755
00:22:05,370 --> 00:22:06,510
0,90 90,480 480,570 570,870 870,1140
to print the current page


756
00:22:06,510 --> 00:22:08,340
0,450 480,660 660,780 780,1140 1290,1830
table| and if I print
|如果我打印control-a，c，我进入{qemu--}监视器或控制台，

757
00:22:08,340 --> 00:22:10,020
0,480 480,1200 1200,1320 1320,1500 1500,1680
control-a c, I get into


758
00:22:10,020 --> 00:22:12,060
0,120 120,420 420,600 600,990 1080,2040
the {QEMU - -} monitor


759
00:22:12,060 --> 00:22:13,740
0,180 180,930 1350,1530 1530,1620 1620,1680
or console,| and if I
|如果我输入info mem，我必须打印完整的页表，

760
00:22:13,740 --> 00:22:15,500
0,180 180,420 420,750 750,1380
then type info mem,


761
00:22:16,060 --> 00:22:17,440
0,300 300,390 390,480 480,930 1170,1380
I had to print the


762
00:22:17,440 --> 00:22:19,840
0,420 420,690 690,1110 1710,2130 2160,2400
complete page table,| {} this
|{}这是一个非常小的页表，只包含6个{mappings-}，

763
00:22:19,840 --> 00:22:20,680
0,90 90,150 150,330 330,630 630,840
is a very small page


764
00:22:20,680 --> 00:22:22,180
0,330 330,420 420,930 930,1170 1170,1500
table that contains only six


765
00:22:22,180 --> 00:22:24,310
0,450 450,870 1470,1710 1710,1950 1950,2130
{mappings -},| of course it's
|当然是外壳的{page，table}。

766
00:22:24,310 --> 00:22:25,780
0,210 210,720 720,810 810,900 900,1470
the {page,table} for the shell.|
|

767
00:22:26,290 --> 00:22:28,810
0,480 480,540 540,750 750,1290 1770,2520
Shell's a pretty small program|
Shell是一个相当小的程序|

768
00:22:29,080 --> 00:22:30,880
0,390 390,570 570,840 840,1260 1260,1800
and these six mappings are
这六个映射是按外壳指令的顺序排列的，

769
00:22:30,880 --> 00:22:32,710
0,90 90,600 810,1080 1080,1410 1410,1830
in order {} the shell's


770
00:22:32,710 --> 00:22:34,020
0,1140
instructions,|
|

771
00:22:34,230 --> 00:22:36,840
0,240 240,750 750,1320 1650,1860 1860,2610
the shell's data, an invalid
外壳的数据，访问{}堆栈{}保护页的无效页，

772
00:22:36,840 --> 00:22:39,000
0,540 540,930 930,1500 1500,1740 1740,2160
page which access the {}


773
00:22:39,500 --> 00:22:40,910
0,510 510,570 570,930 930,1350 1350,1410
stack {} guard page,| in
|以防外壳试图使用过多的堆栈空间

774
00:22:40,910 --> 00:22:41,930
0,210 210,300 300,660 660,930 930,1020
case the shell tries to


775
00:22:41,930 --> 00:22:43,250
0,210 210,330 330,510 510,840 840,1320
use too much stack space|
|

776
00:22:43,400 --> 00:22:44,150
0,210 210,300 300,420 420,600 600,750
and we can see it's
我们可以看到它是无效的

777
00:22:44,150 --> 00:22:46,100
0,510 510,930 960,1380 1380,1710 1710,1950
invalid| because it doesn't have
|因为它没有设置U标志，

778
00:22:46,100 --> 00:22:47,630
0,120 120,420 420,900 900,1260 1290,1530
the u flag set,| over
|在这里，{}在此属性或标志列中，

779
00:22:47,630 --> 00:22:48,500
0,600
here,


780
00:22:48,890 --> 00:22:50,480
0,600 630,750 750,900 900,1500 1500,1590
{} in this attribute or


781
00:22:50,480 --> 00:22:51,620
0,330 330,870
flag column,|
|

782
00:22:52,330 --> 00:22:53,320
0,360 360,630 630,720 720,840 840,990
{} these are all the
{}这些都是PTE下划线标志rw和x，

783
00:22:53,320 --> 00:22:55,270
0,480 480,990 990,1560 1560,1680 1680,1950
pte underscore flags r w


784
00:22:55,270 --> 00:22:56,530
0,120 120,390 390,630 720,960 960,1260
and x,| are just control
|只是控制PTE是否可以被读、写或执行，

785
00:22:56,530 --> 00:22:57,730
0,330 330,540 630,930 930,1050 1050,1200
whether a pte can be


786
00:22:57,730 --> 00:22:59,290
0,360 360,510 510,750 750,840 840,1560
read or written or executed,|
|

787
00:22:59,920 --> 00:23:01,120
0,270 270,450 450,720 720,840 840,1200
the next column is u,|
下一列是u，|

788
00:23:01,120 --> 00:23:02,230
0,90 90,540 600,870 870,930 930,1110
and that's whether or not
这就是是否设置了PTEU标志

789
00:23:02,230 --> 00:23:03,340
0,90 90,510 510,690 690,1020 1020,1110
the pte u flag is


790
00:23:03,340 --> 00:23:04,330
0,270 270,420 420,660 660,870 870,990
set| and user code can
|并且用户代码只能在为其设置了U标志的PTE条目处获得，

791
00:23:04,330 --> 00:23:05,400
0,300 300,480 480,750
only get at


792
00:23:05,480 --> 00:23:07,040
0,570 570,1110 1140,1260 1260,1440 1440,1560
pte entries for which the


793
00:23:07,040 --> 00:23:08,930
0,150 150,450 450,540 540,900 1080,1890
u flag is set,| {}
|{}我不知道下一栏是什么，

794
00:23:12,880 --> 00:23:13,600
0,120 120,330 330,450 450,630 630,720
I don't know what the


795
00:23:13,600 --> 00:23:14,470
0,210 210,540 540,690 690,750 750,870
next column is,| I have
|我不得不承认，下一栏是，

796
00:23:14,470 --> 00:23:15,940
0,120 120,480 810,1170 1170,1410 1410,1470
to admit a, and the


797
00:23:15,940 --> 00:23:16,870
0,150 150,360 360,480 480,810 810,930
next column is a,| for
|是否使用过PTE条目

798
00:23:16,870 --> 00:23:18,610
0,300 300,510 510,990 990,1440 1440,1740
whether the pte entries ever


799
00:23:18,610 --> 00:23:20,320
0,150 150,750 750,1050 1050,1500 1500,1710
been used| and d for
|以及d表示是否曾经针对该地址发出过写入{}。

800
00:23:20,320 --> 00:23:21,540
0,300 300,420 420,960
whether a write


801
00:23:21,890 --> 00:23:23,000
0,360 360,510 510,660 660,780 780,1110
{} has ever been issued


802
00:23:23,000 --> 00:23:24,160
0,120 120,300 300,990
for this address.|
|

803
00:23:28,260 --> 00:23:28,980
0,300 300,450 450,540 540,630 630,720
Okay, so we have this
好的，那么我们有这个小小的{page，table}，

804
00:23:28,980 --> 00:23:30,150
0,240 240,510 510,780 780,870 870,1170
tiny {page,table},| in the last
|顺便说一下，在最后两个页表条目中，

805
00:23:30,150 --> 00:23:31,560
0,210 210,690 690,900 900,1260 1260,1410
two page table entries by


806
00:23:31,560 --> 00:23:32,670
0,90 90,450 450,630 630,840 840,1110
the way,| are way up
|都位于一个巨大的虚拟地址上，

807
00:23:32,670 --> 00:23:36,030
0,360 360,690 720,1650 1890,2430 2430,3360
at an enormous virtual addresses,|
|

808
00:23:36,410 --> 00:23:37,550
0,270 270,570 570,690 690,930 930,1140
{} close to the very
{}非常接近虚拟地址空间的顶部

809
00:23:37,550 --> 00:23:39,050
0,210 210,300 300,480 510,1050 1260,1500
close to the top of


810
00:23:39,050 --> 00:23:40,790
0,210 240,540 540,750 750,1290 1560,1740
the virtual address space| and
|这就是你们在书中读到的这两个，

811
00:23:40,790 --> 00:23:42,800
0,180 180,450 450,780 780,1350 1380,2010
this is these two as


812
00:23:43,190 --> 00:23:43,850
0,210 210,330 330,510 510,570 570,660
you read about in the


813
00:23:43,850 --> 00:23:44,660
0,240 240,270 270,390 390,600 600,810
book,| I will hear much
|我会听到更多关于{trapframe-}的页面，现在是蹦床页面，

814
00:23:44,660 --> 00:23:46,130
0,180 180,570 570,840 870,1200 1200,1470
more about the {trapframe -}


815
00:23:46,130 --> 00:23:48,530
0,600 600,1110 1650,1860 1860,1920 1920,2400
page and now the trampoline


816
00:23:48,530 --> 00:23:49,490
0,300 300,510 510,600 600,720 720,960
page,| as you can see
|正如您可以看到的，它们都没有设置u位，

817
00:23:49,490 --> 00:23:50,860
0,510 510,600 600,1020
neither of them


818
00:23:50,960 --> 00:23:52,250
0,240 240,360 360,600 600,870 870,1290
has the u bit set,|
|

819
00:23:52,520 --> 00:23:54,290
0,450 510,990 1080,1350 1350,1590 1590,1770
so {} user code can't
所以{}用户代码不能访问这两个地址中的任何一个都可以使用这两个地址中的任何一个，

820
00:23:54,290 --> 00:23:55,610
0,180 180,390 390,690 690,780 780,1320
get at either of these


821
00:23:55,640 --> 00:23:56,450
0,210 210,330 330,540 540,630 630,810
can use either of these


822
00:23:56,450 --> 00:23:58,340
0,660 1110,1440 1440,1650 1650,1740 1740,1890
addresses,| but once we enter
|但是一旦我们进入主管模式，我们就可以进入这两个页面。

823
00:23:58,340 --> 00:23:59,450
0,540 540,750 750,840 840,960 960,1110
supervisor mode, we can get


824
00:23:59,450 --> 00:24:00,680
0,120 120,270 270,420 420,1080
at these two pages.|
|

825
00:24:02,790 --> 00:24:03,440
0,90


826
00:24:05,130 --> 00:24:06,040
0,630
Alright.|
好的。|

827
00:24:07,120 --> 00:24:08,620
0,540 720,960 960,1050 1050,1350 1350,1500
Um, when they notice about
嗯，当他们注意到这个页表的时候

828
00:24:08,620 --> 00:24:10,360
0,150 150,420 420,900 1410,1590 1590,1740
this page table| is there's
|内核中的任何东西都没有映射。

829
00:24:10,360 --> 00:24:11,620
0,180 180,570 570,840 840,1170 1170,1260
no mapping for anything in


830
00:24:11,620 --> 00:24:12,500
0,60 60,510
the kernel.|
|

831
00:24:12,610 --> 00:24:14,170
0,300 300,480 480,810 810,1110 1110,1560
There's no physical address mapping,|
没有物理地址映射，|

832
00:24:14,170 --> 00:24:15,220
0,240 240,390 390,810 810,960 960,1050
there's no mapping for the
没有内核数据、内核指令或其他任何东西的映射，

833
00:24:15,220 --> 00:24:17,320
0,420 420,870 900,990 990,1350 1350,2100
kernel's data, the kernel's instructions


834
00:24:17,320 --> 00:24:18,580
0,90 90,390 390,870 870,1080 1080,1260
or anything else,| this is
|这只接受最后两页，

835
00:24:18,580 --> 00:24:20,530
0,690 690,750 750,1110 1350,1800 1800,1950
accepted the last just the


836
00:24:20,530 --> 00:24:22,300
0,210 210,480 480,570 570,1080 1350,1770
very last two pages,| now,
|现在，这是几乎完全专用于用户执行的页表

837
00:24:22,300 --> 00:24:23,080
0,90 90,150 150,210 210,450 450,780
this is the page table


838
00:24:23,080 --> 00:24:24,790
0,300 300,690 690,1260 1260,1410 1410,1710
almost entirely dedicated to user


839
00:24:24,790 --> 00:24:26,560
0,600 780,930 930,1020 1020,1380 1380,1770
execution| and is not directly
|并且对于执行内核并不直接特别有用。

840
00:24:26,560 --> 00:24:28,510
0,450 450,900 1350,1470 1470,1860 1860,1950
particularly useful for executing the


841
00:24:28,510 --> 00:24:29,160
0,360
kernel.|
|

842
00:24:30,410 --> 00:24:32,720
0,120 120,330 1410,1710 1710,1980 1980,2310
All right what's the what's
好的，页面表顶部列出的属性是什么？

843
00:24:32,720 --> 00:24:34,640
0,180 420,1080 1080,1320 1320,1410 1410,1920
the attribute on the on


844
00:24:34,640 --> 00:24:36,560
0,270 840,1170 1170,1440 1440,1770 1770,1920
the page table listing on


845
00:24:36,560 --> 00:24:37,880
0,60 60,540 600,840 840,1170 1170,1320
the top?| I believe this
|我相信这意味着页表曾经是。

846
00:24:37,880 --> 00:24:39,080
0,210 210,300 300,570 570,900 900,1200
means the page tables ever


847
00:24:39,080 --> 00:24:39,900
0,510
been.|
|

848
00:24:40,110 --> 00:24:41,580
0,210 210,450 450,720 720,1290 1320,1470
This page table entry has
该页表项曾经被代码访问过，

849
00:24:41,580 --> 00:24:44,040
0,120 120,330 330,1200 1530,1860 1860,2460
ever been accessed by code,|
|

850
00:24:44,720 --> 00:24:46,610
0,360 690,840 840,1020 1020,1440 1470,1890
{} that is, {} whether
{}就是{}有没有发过地址

851
00:24:46,610 --> 00:24:48,140
0,120 120,390 390,780 780,900 900,1530
it's ever issued an address|
|

852
00:24:48,140 --> 00:24:48,820
0,240
that
就是指{page，table}。

853
00:24:49,120 --> 00:24:50,700
0,360 360,450 450,540 540,990
refers to the {page,table}.|
|

854
00:24:50,970 --> 00:24:51,380
0,60


855
00:24:52,160 --> 00:24:53,510
0,420 720,900 900,960 960,1230 1230,1350
{} And the d is
{}，d是程序是否曾经编写过。

856
00:24:53,510 --> 00:24:55,370
0,270 270,630 780,1200 1200,1380 1380,1860
whether the programs ever written.|
|

857
00:24:57,270 --> 00:24:58,720
0,180 180,300 300,390 390,1170
They've done a store
他们已经通过这个页表条目进行了存储

858
00:24:59,560 --> 00:25:00,940
0,300 300,510 510,780 780,990 990,1380
through this page table entry|
|

859
00:25:01,030 --> 00:25:03,250
0,270 270,510 510,1140 1410,1860 1860,2220
and these are this the
这些都是硬件为了操作系统的方便而维护的

860
00:25:03,250 --> 00:25:05,140
0,300 300,1020 1020,1200 1200,1350 1350,1890
hardware maintains for the convenience


861
00:25:05,140 --> 00:25:06,190
0,60 60,180 180,540 540,930 930,1050
of the operating system| and
|以及比{xv6-}{}更复杂的操作系统。

862
00:25:06,220 --> 00:25:08,170
0,330 330,660 660,840 840,1560 1560,1950
operating systems more sophisticated than


863
00:25:08,170 --> 00:25:10,280
0,240 240,810 1320,1830
{xv6 -} {}.|
|

864
00:25:10,650 --> 00:25:12,420
0,210 210,390 390,510 510,870 870,1770
We need to evict pages
如果页面的物理内存不足，我们需要将其逐出，

865
00:25:12,510 --> 00:25:13,440
0,150 150,270 270,510 510,810 810,930
if they're running short on


866
00:25:13,440 --> 00:25:14,640
0,330 330,660 660,780 780,960 960,1200
physical memory,| they may need
|它们可能需要将一些内存页面写入磁盘。

867
00:25:14,640 --> 00:25:16,530
0,180 180,660 1200,1440 1440,1800 1800,1890
to write some pages of


868
00:25:16,530 --> 00:25:17,880
0,360 360,480 480,1110
memory to disk.|
|

869
00:25:18,040 --> 00:25:20,050
0,420 420,960 990,1560 1560,1650 1650,2010
{} And invalidate the page
{}并使页面条目无效以{释放，提升}物理存储器，

870
00:25:20,050 --> 00:25:21,880
0,510 510,690 1140,1470 1470,1530 1530,1830
entries to {free,up} the physical


871
00:25:21,880 --> 00:25:24,520
0,480 570,1110 1110,1590 1590,2010 2010,2640
memory,| {} and many policies,
|{}和很多策略，你可以想象一个操作系统使用的图片有哪些页面要存在，

872
00:25:24,520 --> 00:25:26,110
0,90 90,180 180,600 600,870 1170,1590
you can imagine a operating


873
00:25:26,110 --> 00:25:27,610
0,270 270,600 600,720 1050,1290 1290,1500
system using the pic which


874
00:25:27,610 --> 00:25:29,230
0,270 270,390 390,900 1050,1500 1500,1620
pages to exist,| now will
|现在我将参考BITS，看看这个页表条目是否曾经被使用过

875
00:25:29,230 --> 00:25:30,640
0,450 450,600 810,1170 1170,1290 1290,1410
consult the bits to see


876
00:25:30,640 --> 00:25:31,930
0,270 270,450 450,690 690,960 960,1290
whether this page table entry


877
00:25:31,930 --> 00:25:33,370
0,150 150,330 330,570 570,720 720,1440
has ever even been used|
|

878
00:25:33,580 --> 00:25:34,840
0,390 390,510 510,750 750,900 900,1260
and it hasn't been used
而且它最近还没有用过或者已经用过了

879
00:25:34,840 --> 00:25:35,860
0,30 30,180 180,330 330,540 540,1020
or have been used recently|
|

880
00:25:35,860 --> 00:25:37,570
0,270 840,1050 1050,1080 1080,1200 1200,1710
then that's a good candidate
那么这是一个很好的驱逐到磁盘的候选对象。

881
00:25:37,570 --> 00:25:39,700
0,570 750,1260 1260,1380 1380,1920
for evicting to disk.|
|

882
00:25:40,470 --> 00:25:42,200
0,390 510,690 690,1440
{} And d
{}和d告诉内核

883
00:25:42,660 --> 00:25:44,790
0,510 510,630 630,1140 1140,1440 1800,2130
tells the kernel| that oh
|这一页实际上是从磁盘读取后写入的，

884
00:25:44,790 --> 00:25:46,110
0,330 480,720 720,810 810,1080 1080,1320
this page has actually been


885
00:25:46,110 --> 00:25:48,030
0,480 1140,1410 1410,1470 1470,1590 1590,1920
written since it was read


886
00:25:48,030 --> 00:25:49,060
0,210 210,810
from disk,|
|

887
00:25:50,780 --> 00:25:52,040
0,420 420,630 630,870 870,1020 1020,1260
xv6 doesn't actually use either
xv6实际上并不使用这两种方法中的任何一种。

888
00:25:52,040 --> 00:25:53,100
0,60 60,450
of these.|
|

889
00:25:55,520 --> 00:25:58,000
0,420 1080,1380 1380,1980
Alright, other questions.|
好的，还有其他问题。|

890
00:26:02,390 --> 00:26:06,050
0,420 450,1230 1260,2130 2610,2970 2970,3660
Alright, let's execute the um.|
好的，我们来执行这个。|

891
00:26:06,950 --> 00:26:08,480
0,330 330,390 390,570 570,990 990,1530
Let me just remind us
让我来提醒我们，我们将在哪里打印出写作的内容，

892
00:26:08,660 --> 00:26:09,380
0,240 240,390 390,480 480,660 660,720
where we are going to


893
00:26:09,380 --> 00:26:10,970
0,270 270,600 600,810 1020,1500 1500,1590
print out the contents of


894
00:26:10,970 --> 00:26:12,050
0,150 150,510 510,630 630,780 780,1080
the write,| {we're,in} the write
|{我们，在}写入库函数，在一个，在shell中，

895
00:26:12,050 --> 00:26:14,760
0,390 390,1020 1410,1950 1950,2370
library function, in a,


896
00:26:16,880 --> 00:26:18,500
0,180 180,240 240,810 1290,1530 1530,1620
in the shell,| and the
|并且程序计数器指向eCall指令，

897
00:26:18,500 --> 00:26:19,700
0,330 330,660 660,780 780,1140 1140,1200
program counter is pointed to


898
00:26:19,700 --> 00:26:20,930
0,120 120,420 420,870 870,960 960,1230
the ecall instruction,| we're about
|我们即将执行eCall指令，

899
00:26:20,930 --> 00:26:22,280
0,60 60,450 450,540 540,840 840,1350
to execute the ecall instruction,|
|

900
00:26:23,000 --> 00:26:24,230
0,300 300,540 540,600 600,840 840,1230
{} still in user space
{}仍在用户空间，但不会持续很长时间，

901
00:26:24,230 --> 00:26:25,370
0,150 150,330 330,480 480,600 600,1140
but won't be for long,|
|

902
00:26:25,550 --> 00:26:26,760
0,750


903
00:26:27,310 --> 00:26:28,900
0,180 180,690 690,780 780,1080 1080,1590
I executed the eco instruction.|
我执行了ECO指令。|

904
00:26:30,380 --> 00:26:31,880
0,330 360,810 960,1200 1200,1440 1440,1500
Okay so first question is
好的，那么第一个问题是我们在哪里。

905
00:26:31,880 --> 00:26:32,960
0,240 240,420 420,720
where are we.|
|

906
00:26:33,440 --> 00:26:36,080
0,480 480,600 600,1080 1590,2100 2460,2640
After the ecall, {} we
在eCall之后，{}我们可以查看程序计数器。

907
00:26:36,080 --> 00:26:36,740
0,120 120,210 210,270 270,330 330,660
can look at the program


908
00:26:36,740 --> 00:26:37,620
0,450
counter.|
|

909
00:26:38,660 --> 00:26:40,010
0,210 210,330 330,900 1050,1260 1260,1350
{We,see} this now used to
{我们，看}现在这是一个非常低的数字{d6}那是非常高的数字，

910
00:26:40,010 --> 00:26:40,850
0,60 60,90 90,270 270,450 450,840
be a very low number


911
00:26:40,850 --> 00:26:42,230
0,300 300,660 660,960 960,1170 1170,1380
{d six} that's very high


912
00:26:42,230 --> 00:26:43,400
0,480 570,690 690,930 930,1020 1020,1170
number,| in fact we look
|事实上，我们看到程序计数器是一个虚拟地址，就像{}指令使用的所有地址一样。

913
00:26:43,400 --> 00:26:44,630
0,60 60,420 480,930 930,1140 1140,1230
at the program counter is


914
00:26:44,630 --> 00:26:46,640
0,30 30,360 360,1140 1230,1860 1860,2010
a virtual address like all


915
00:26:46,640 --> 00:26:47,640
0,480 480,660
addresses that


916
00:26:47,790 --> 00:26:49,520
0,300 300,810 810,1260
{} instructions use.|
|

917
00:26:50,240 --> 00:26:51,170
0,210 210,330 330,570 570,840 840,930
And we can look at
我们可以看看页表，

918
00:26:51,170 --> 00:26:52,880
0,60 60,390 390,930 1260,1590 1590,1710
the page table,| actually let's
|实际上，让我们检查一下页表是什么以确保，

919
00:26:52,880 --> 00:26:53,630
0,180 180,360 360,450 450,510 510,750
just check what the page


920
00:26:53,630 --> 00:26:55,160
0,330 330,810 810,1110 1110,1290 1320,1530
table is just to be


921
00:26:55,160 --> 00:26:56,480
0,390 390,480 480,990
sure,| I'm gonna
|我再问你{qemu-}要我的信息，

922
00:26:56,960 --> 00:26:58,130
0,570 570,720 720,840 840,1020 1020,1170
ask you {QEMU -} for


923
00:26:58,130 --> 00:26:59,930
0,300 300,540 540,1020 1530,1710 1710,1800
info mem again,| it's the
|这是完全相同的页表。

924
00:26:59,930 --> 00:27:01,280
0,210 210,450 450,690 690,1080
very same page table.|
|

925
00:27:02,220 --> 00:27:03,960
0,420 420,750 750,1170 1260,1560 1560,1740
Nothing's changed there,| we'll look
那里什么都没变，|我们将查找新的当前程序计数器，

926
00:27:03,960 --> 00:27:05,970
0,270 270,900 960,1350 1380,1680 1680,2010
up our new current program


927
00:27:05,970 --> 00:27:07,170
0,270 270,570 570,840 840,900 900,1200
counter,| there are the program
|程序计数器在这个蹦床页面开头的{}处，

928
00:27:07,170 --> 00:27:09,000
0,450 660,930 930,1110 1110,1500
counter is at the


929
00:27:09,120 --> 00:27:11,100
0,390 1020,1410 1410,1470 1470,1560 1560,1980
{} right at the beginning


930
00:27:11,100 --> 00:27:12,780
0,90 90,390 390,1020 1020,1470 1470,1680
of this trampoline page,| this
|这在用户内存中映射了一条向上的路。

931
00:27:12,780 --> 00:27:13,620
0,510
mapped


932
00:27:13,770 --> 00:27:14,910
0,210 210,360 360,480 480,780 780,1140
a way up high in


933
00:27:15,660 --> 00:27:16,800
0,180 180,450 450,900
the user memory.|
|

934
00:27:17,460 --> 00:27:19,200
0,360 360,540 540,1140 1320,1620 1620,1740
That's were executing, we can
这是正在执行的，我们可以看到指令在那里。

935
00:27:19,200 --> 00:27:20,520
0,150 150,240 240,1110 1110,1230 1230,1320
see the instructions that are


936
00:27:20,520 --> 00:27:21,320
0,480
there.|
|

937
00:27:21,350 --> 00:27:22,740
0,240 240,330 330,510 510,1200
I'm going to use.|
我要用。|

938
00:27:23,200 --> 00:27:23,720
0,270


939
00:27:24,620 --> 00:27:25,760
0,840
Um.|
恩。|

940
00:27:31,340 --> 00:27:33,050
0,270 270,480 480,540 540,630 630,1710
{} These are the instructions,|
{}这些都是说明书，|

941
00:27:34,020 --> 00:27:36,030
0,510 690,810 810,1050 1050,1290 1290,2010
{} the very first instructions
{}内核在管理程序模式下执行的第一条指令

942
00:27:36,030 --> 00:27:37,470
0,210 210,330 330,810 810,1320 1320,1440
that the kernel executes in


943
00:27:37,470 --> 00:27:39,150
0,570 570,1080 1080,1170 1170,1230 1230,1680
supervisor mode| at the beginning
|在陷阱刚开始的时候

944
00:27:39,150 --> 00:27:40,350
0,300 300,630 630,690 690,750 750,1200
very beginning of a trap|
|

945
00:27:40,560 --> 00:27:41,790
0,240 240,450 450,720 720,1140 1140,1230
and threw some weirdness in
并在GDB中抛出了一些怪异的东西，

946
00:27:41,790 --> 00:27:43,740
0,510 510,690 690,1050 1050,1470 1470,1950
gdb,| we've actually already executed,
|我们实际上已经执行了第一条指令，

947
00:27:43,740 --> 00:27:45,630
0,90 90,360 360,990 1470,1740 1740,1890
the first instruction,| {} at
|{}在本页的开头。

948
00:27:45,630 --> 00:27:46,440
0,90 90,300 300,600 600,660 660,810
the very beginning of this


949
00:27:46,440 --> 00:27:47,360
0,660
page.|
|

950
00:27:47,480 --> 00:27:48,380
0,630


951
00:27:49,050 --> 00:27:50,970
0,540 570,720 720,930 930,1110 1530,1920
And we're about to execute
我们即将执行第二条指令。

952
00:27:50,970 --> 00:27:52,200
0,60 60,390 390,900
the second instruction.|
|

953
00:27:53,560 --> 00:27:54,040
0,150 150,240 240,330 330,390 390,480
We can look at the
我们可以看看登记簿。

954
00:27:54,040 --> 00:27:55,900
0,960
registers.|
|

955
00:27:57,060 --> 00:27:57,630
0,240 240,360 360,420 420,510 510,570
I don't know if you
我不知道你是否还记得这些寄存器值，但是这里什么都没有改变，

956
00:27:57,630 --> 00:27:59,130
0,300 300,510 510,870 870,1290 1290,1500
remember these register values but


957
00:27:59,250 --> 00:28:00,660
0,510 510,660 660,1080 1080,1200 1200,1410
nothing has changed here,| these
|这些与用户程序具有的寄存器内容完全相同，

958
00:28:00,660 --> 00:28:02,100
0,150 150,720 720,810 810,1020 1020,1440
are exactly the same register


959
00:28:02,100 --> 00:28:03,480
0,510 510,630 630,720 720,1020 1020,1380
contents that the user program


960
00:28:03,480 --> 00:28:04,340
0,720
has,|
|

961
00:28:04,470 --> 00:28:05,430
0,420 420,570 570,750 750,840 840,960
had so these are all
有，所以这些都充满了用户的价值，对他们中的许多人来说

962
00:28:05,430 --> 00:28:07,020
0,300 300,570 600,870 870,1440 1440,1590
full of user values for


963
00:28:07,020 --> 00:28:08,040
0,240 240,360 360,660 690,840 840,1020
many of them| are all
|就我们所知它们都是唯一有价值的地点吗，

964
00:28:08,040 --> 00:28:08,670
0,90 90,270 270,420 420,510 510,630
of them for all we


965
00:28:08,670 --> 00:28:10,560
0,360 570,870 870,990 990,1230 1230,1890
know they're the only locations


966
00:28:10,560 --> 00:28:11,730
0,300 300,660 660,840 840,1020 1020,1170
value exists,| so we have
|因此，当我们在这一点上不能实际使用任何寄存器时，我们必须非常小心。

967
00:28:11,730 --> 00:28:12,570
0,90 90,150 150,360 360,720 720,840
to be very careful when


968
00:28:12,570 --> 00:28:14,160
0,90 90,360 360,630 630,1050 1080,1590
we can't actually use any


969
00:28:14,190 --> 00:28:16,040
0,720 720,810 810,990 990,1470
registers at this point.|
|

970
00:28:16,220 --> 00:28:18,260
0,420 420,930 930,1320 1320,1560 1560,2040
Without first saving those registers
而不是先将这些寄存器保存在某个地方以便我们可以恢复它们，

971
00:28:18,260 --> 00:28:19,970
0,570 780,1020 1020,1140 1140,1290 1290,1710
somewhere so we can restore


972
00:28:19,970 --> 00:28:21,380
0,240 420,810 810,1020 1020,1140 1140,1410
them,| because if the kernel
|因为如果内核在这一点上使用这些寄存器中的任何一个，它将被重写。

973
00:28:21,380 --> 00:28:22,160
0,120 120,240 240,540 540,720 720,780
was to use any of


974
00:28:22,160 --> 00:28:23,300
0,210 210,690 690,780 780,930 930,1140
these registers at this point


975
00:28:23,300 --> 00:28:24,940
0,60 60,360 450,1440
it would overwrite.|
|

976
00:28:25,100 --> 00:28:27,770
0,750 1320,1950 1950,2070 2070,2280 2280,2670
Um, whatever the user value
嗯，不管用户价值是多少

977
00:28:27,770 --> 00:28:28,700
0,240 240,420 420,660 660,810 810,930
is| and then if we
|然后如果我们试图恢复用户程序，

978
00:28:28,700 --> 00:28:29,690
0,240 240,330 330,660 660,720 720,990
tried to resume the user


979
00:28:29,690 --> 00:28:30,620
0,330 330,450 450,690 690,750 750,930
program,| we wouldn't be able
|我们就不能用正确的值设置它的寄存器

980
00:28:30,620 --> 00:28:32,000
0,60 60,270 270,390 390,540 540,1380
to set up its registers


981
00:28:32,000 --> 00:28:32,990
0,120 120,180 180,450 450,870 870,990
with the correct values| and
|和用户程序或者只是做一些完全错误的事情。

982
00:28:32,990 --> 00:28:34,820
0,240 750,1020 1020,1320 1320,1350 1350,1830
the user program or just


983
00:28:34,850 --> 00:28:36,280
0,150 150,450 450,750 750,1170
do something totally wrong.|
|

984
00:28:37,500 --> 00:28:40,260
0,660 810,1560 1890,2130 2130,2310 2310,2760
Question?| Yes.| Could you return
有问题吗？|是。|您能回到您之前看到的说明面板上吗？

985
00:28:40,260 --> 00:28:42,480
0,120 120,390 390,1560 1560,2010 2010,2220
to the instructions panel that


986
00:28:42,480 --> 00:28:43,800
0,120 120,300 300,810 840,1020 1020,1320
you had before,| I'm wondering
|我想知道{csrrw--}指令在做什么。

987
00:28:43,800 --> 00:28:46,290
0,180 180,300 300,600 600,1050 1050,2490
what the {csrrw - -}


988
00:28:46,290 --> 00:28:49,520
0,480 480,600 600,990
instruction is doing.|
|

989
00:28:51,070 --> 00:28:52,570
0,420 420,600 600,720 720,1200 1200,1500
The {csrrw - - -},|
{csrrw-}|

990
00:28:52,570 --> 00:28:53,590
0,180 180,360 360,570 570,780 780,1020
OK we'll talk about this,
好的，我们几分钟后再谈，{}

991
00:28:53,590 --> 00:28:55,480
0,450 450,840 840,1050 1050,1260 1260,1890
{} in a few minutes,|
|

992
00:28:56,080 --> 00:28:56,830
0,240 240,360 360,600 600,660 660,750
but the answer to your
但你问题的答案是

993
00:28:56,830 --> 00:28:59,380
0,360 360,480 480,720 720,1350 1350,2550
question is| that instruction swaps
|该指令与特殊临时寄存器的内容交换{a0-}。

994
00:28:59,530 --> 00:29:01,750
0,240 240,1050 1200,1470 1470,1560 1560,2220
{a0 -} with the contents


995
00:29:01,750 --> 00:29:03,940
0,180 180,360 360,990 990,1560 1560,2190
of the special scratch register.|
|

996
00:29:04,780 --> 00:29:07,540
0,540 900,1110 1110,1290 1290,1680 2250,2760
Um, and so in yeah
嗯，所以在是的是的，这就像是超级重要的。

997
00:29:07,960 --> 00:29:09,160
0,480 480,660 660,750 750,930 930,1200
yeah, this is like super


998
00:29:09,160 --> 00:29:10,340
0,570
important.|
|

999
00:29:10,390 --> 00:29:12,700
0,570 1200,1590 1590,1890 1890,1950 1950,2310
And basically answers the question
基本上回答了这样一个问题：如果内核陷阱代码不能使用任何寄存器，它怎么能做任何事情，

1000
00:29:12,700 --> 00:29:14,440
0,120 120,300 300,660 930,1320 1350,1740
how can the this kernel


1001
00:29:14,440 --> 00:29:15,640
0,270 270,510 510,660 660,1080 1080,1200
trap code do anything if


1002
00:29:15,640 --> 00:29:17,020
0,60 60,240 240,420 420,600 600,1380
it can't use any registers,|
|

1003
00:29:17,560 --> 00:29:18,520
0,150 150,360 360,510 510,870 870,960
the answer that question is
这个问题的答案是，出口确实必须执行这一点，

1004
00:29:18,520 --> 00:29:19,660
0,180 180,510 540,930 930,1080 1080,1140
that exit really has to


1005
00:29:19,660 --> 00:29:21,160
0,750 750,1320
execute this,|
|

1006
00:29:21,320 --> 00:29:23,840
0,1020 1020,1410 1410,1620 1620,1920 1920,2520
{csrrw -} {a0 -} sscratch
{csrrw-}{a0-}擦除指令，

1007
00:29:23,840 --> 00:29:27,320
0,750 1080,1620 1620,2520 2520,3030 3030,3480
instruction,| that simultaneously saves a0
|在擦伤时同时保存0

1008
00:29:27,320 --> 00:29:29,270
0,150 150,960 990,1440 1440,1830 1830,1950
when scratch| and happens to
|并且碰巧将Scratch加载到0中。

1009
00:29:29,270 --> 00:29:31,060
0,300 300,870 870,1110 1110,1530
load scratch into a0.|
|

1010
00:29:31,880 --> 00:29:32,840
0,180 180,390 390,540 540,810 810,960
So now the kernel can
因此，现在内核可以在此指令之后使用{a0-}进行任何操作。

1011
00:29:32,840 --> 00:29:34,520
0,750 780,900 900,1230 1230,1350 1350,1680
use {a0 -} for whatever


1012
00:29:34,520 --> 00:29:35,690
0,90 90,390 390,510 690,1020 1020,1170
it wants to after this


1013
00:29:35,690 --> 00:29:36,460
0,480
instruction.|
|

1014
00:29:38,890 --> 00:29:40,800
0,450 480,900 1080,1680
Okay, Thanks.| Yeah.|
好的，谢谢。|嗯。|

1015
00:29:41,710 --> 00:29:43,210
0,420 420,750 780,900 900,1320 1320,1500
Okay so we're currently this
好的，我们目前的地址是{0x3ffffff000-}，

1016
00:29:43,210 --> 00:29:45,220
0,600 600,900 900,1050 1050,1800 1800,2010
addresses {0x3ffffff000 - - -


1017
00:29:45,220 --> 00:29:46,750
0,240 240,750 870,1050 1050,1260 1260,1530
- -},| now this last
|现在这最后一个页面是蹦床页面，我们目前正在蹦床页面中执行

1018
00:29:46,750 --> 00:29:48,160
0,240 240,330 330,420 420,990 990,1410
page is the trampoline page


1019
00:29:48,160 --> 00:29:49,780
0,240 270,390 390,780 780,1320 1380,1620
and we're currently executing in


1020
00:29:49,780 --> 00:29:51,820
0,60 60,660 660,1170 1200,1680 1680,2040
the trampoline page| which contains
|它包含内核陷阱处理代码的第一条指令。

1021
00:29:51,820 --> 00:29:54,370
0,180 270,630 630,960 960,1980 2220,2550
the very first instructions of


1022
00:29:54,370 --> 00:29:56,230
0,90 90,510 510,900 900,1260 1260,1860
the kernel's trap handling code.|
|

1023
00:29:58,000 --> 00:30:00,220
0,510 510,840 840,1140 1140,1470 1470,2220
Ecall doesn't switch page tables
eCall不会切换页表，这是eCall非常重要的一点

1024
00:30:00,400 --> 00:30:01,450
0,330 330,360 360,540 540,930 930,1050
that's a very important thing


1025
00:30:01,450 --> 00:30:02,770
0,270 270,750 750,930 930,1110 1110,1320
about ecall| and what that
|这意味着这些最早的指令必须出现在每个用户页表中。

1026
00:30:02,770 --> 00:30:04,120
0,300 300,420 420,660 720,1080 1080,1350
means is that these very


1027
00:30:04,120 --> 00:30:05,230
0,210 210,660 660,870 870,990 990,1110
first instructions have to be


1028
00:30:05,230 --> 00:30:07,180
0,540 570,870 870,1260 1260,1620 1620,1950
present in every user page


1029
00:30:07,180 --> 00:30:07,940
0,390
table.|
|

1030
00:30:08,080 --> 00:30:09,730
0,450 540,990 990,1260 1260,1440 1440,1650
{} Because ecall doesn't switch
{}因为eCall不切换页表，

1031
00:30:09,730 --> 00:30:10,570
0,240 240,510 510,630 630,780 780,840
page tables,| we need to
|我们需要在用户页表中的某个位置执行内核的第一位

1032
00:30:10,570 --> 00:30:11,980
0,120 120,900 900,1020 1020,1290 1290,1410
be executing the first bit


1033
00:30:11,980 --> 00:30:13,510
0,60 60,150 150,630 840,1440 1440,1530
of the kernel somewhere in


1034
00:30:13,510 --> 00:30:14,560
0,60 60,360 360,630 630,960 960,1050
the user page table| and
|内核仔细地将这个蹦床页面映射到每个用户页表中

1035
00:30:14,560 --> 00:30:16,390
0,120 120,270 270,840 840,1440 1530,1830
it's this trampoline page which


1036
00:30:16,390 --> 00:30:17,590
0,90 90,300 300,660 660,1020 1020,1200
the kernel carefully maps into


1037
00:30:17,590 --> 00:30:20,170
0,270 270,720 810,1200 1200,1650 2250,2580
every user page table| that
|这为内核提供了在陷阱开始时执行的位置

1038
00:30:20,170 --> 00:30:21,340
0,150 150,210 210,540 540,630 630,1170
gives the kernel a place


1039
00:30:21,340 --> 00:30:22,570
0,180 180,660 660,750 750,900 900,1230
to execute at the very


1040
00:30:22,570 --> 00:30:23,470
0,360 360,450 450,510 510,810 810,900
beginning of a trap| when
|当我们仍在使用用户页表时

1041
00:30:23,470 --> 00:30:24,430
0,90 90,300 300,630 630,690 690,960
we're still using the user


1042
00:30:24,430 --> 00:30:25,720
0,270 270,630 870,1080 1080,1170 1170,1290
page table| and the way
|其控制方式是通过{stvec-}寄存器，

1043
00:30:25,720 --> 00:30:27,080
0,210 210,300 300,1110
this is controlled


1044
00:30:27,700 --> 00:30:29,740
0,600 1200,1380 1380,1530 1530,1650 1650,2040
{} is through the {stvec


1045
00:30:29,740 --> 00:30:31,000
0,210 210,630 630,750 750,840 840,1260
-} register,| this is another
|这是另一个特权寄存器

1046
00:30:31,000 --> 00:30:32,320
0,840
privileged


1047
00:30:32,490 --> 00:30:34,110
0,450 450,750 750,1230 1230,1410 1410,1620
register| only readable by the
|仅主管可写者可读

1048
00:30:34,110 --> 00:30:36,270
0,240 240,510 510,630 630,1410 1890,2160
writable by the supervisor| and
|内核在进入用户空间之前设置{stvec-}

1049
00:30:36,270 --> 00:30:37,560
0,60 60,450 450,930 930,1050 1050,1290
the kernel before it entered


1050
00:30:37,560 --> 00:30:38,670
0,240 240,540 540,780 780,900 900,1110
user space set up the


1051
00:30:38,670 --> 00:30:40,170
0,390 390,780 990,1200 1200,1440 1440,1500
{stvec -}| to point to
|指向内核希望陷阱放置的位置。

1052
00:30:40,170 --> 00:30:41,400
0,120 120,480 480,660 660,750 750,1230
the place where the kernel


1053
00:30:41,400 --> 00:30:43,020
0,360 360,810 810,900 900,1380
wanted traps to go.|
|

1054
00:30:43,110 --> 00:30:43,680
0,150 150,270 270,360 360,480 480,570
And so as you can
所以你可以看到内核

1055
00:30:43,680 --> 00:30:45,090
0,240 240,330 330,630 630,780 780,1410
see the kernel| has previously
|之前已将此{stvec-}设置为此{0x3ffffff000-}地址

1056
00:30:45,090 --> 00:30:46,470
0,240 240,390 390,600 600,990 990,1380
set up this {stvec -}


1057
00:30:46,650 --> 00:30:48,390
0,240 240,420 420,750 750,1050 1050,1740
to this {0x3ffffff000 - -


1058
00:30:48,390 --> 00:30:49,920
0,240 240,450 450,900 900,1320 1320,1530
- - -} address| which
|这是蹦床页面的开始。

1059
00:30:49,920 --> 00:30:50,730
0,90 90,150 150,630 630,720 720,810
is the beginning of the


1060
00:30:50,730 --> 00:30:52,080
0,570 570,1080
trampoline page.|
|

1061
00:30:52,360 --> 00:30:53,620
0,300 300,420 420,630 630,1020 1020,1260
And it's this {stvec -}
就是这个{stvec-}寄存器

1062
00:30:53,620 --> 00:30:56,080
0,690 900,1470 1500,1740 1740,2340 2340,2460
register| that its content is
|它的内容就是为什么在{eCall-}之后，

1063
00:30:56,080 --> 00:30:57,250
0,120 120,420 420,720 720,1050 1050,1170
the reason why after the


1064
00:30:57,250 --> 00:30:59,320
0,150 150,660 810,1110 1110,1350 1350,2070
{ecall -},| we ended up
|我们最终在这个特定的地方执行了死刑。

1065
00:30:59,350 --> 00:31:01,750
0,780 870,1020 1020,1200 1200,1710 1710,2400
executing at this particular place.|
|

1066
00:31:05,060 --> 00:31:05,750
0,180 180,360 360,420 420,570 570,690
And finally I just want
最后我只想提醒你们

1067
00:31:05,750 --> 00:31:06,620
0,60 60,420 420,540 540,660 660,870
to remind you that| even
|即使蹦床和陷阱帧页面被映射到用户页表用户地址空间，

1068
00:31:06,620 --> 00:31:07,820
0,120 120,270 270,780 780,870 870,1200
though the trampoline and trap


1069
00:31:07,820 --> 00:31:09,290
0,420 420,780 780,870 870,1260 1260,1470
frame pages are mapped into


1070
00:31:09,290 --> 00:31:10,850
0,120 120,450 450,810 810,1230 1260,1560
the user page table user


1071
00:31:10,850 --> 00:31:13,100
0,240 240,840 1080,1410 1410,1830 1830,2250
address space,| the user code
|用户代码不能写入它们。

1072
00:31:13,100 --> 00:31:14,440
0,480 480,720 720,1050
cannot write them.|
|

1073
00:31:14,580 --> 00:31:16,170
0,450 540,900 900,1020 1020,1500 1500,1590
{} Because the {ptes -}
{}因为他们的{PTES-}没有PTE U标志，

1074
00:31:16,170 --> 00:31:17,340
0,150 150,570 600,870 870,1050 1050,1170
for them don't have the


1075
00:31:17,340 --> 00:31:18,750
0,360 360,720 720,1200 1200,1290 1290,1410
pte u flag,| so they're
|因此，它们受到保护，不受用户代码的影响。

1076
00:31:18,750 --> 00:31:21,380
0,690 1170,1740 1740,1980 1980,2340
protected against user code.|
|

1077
00:31:21,880 --> 00:31:22,840
0,120 120,300 300,420 420,630 630,960
And that's why this trick
这就是为什么这个小把戏是这个小把戏安全的部分原因。

1078
00:31:22,840 --> 00:31:23,410
0,150 150,240 240,450 450,510 510,570
is a part of the


1079
00:31:23,410 --> 00:31:24,280
0,180 180,270 270,450 450,750 750,870
reason why this trick is


1080
00:31:24,280 --> 00:31:25,180
0,660
safe.|
|

1081
00:31:27,120 --> 00:31:28,740
0,630 840,1110 1110,1200 1200,1410 1410,1620
{} I've been sort of
{}我一直在告诉你，假设

1082
00:31:28,740 --> 00:31:30,300
0,300 300,450 450,510 510,1290 1320,1560
telling you in assuming| that
|我们处于主管模式，

1083
00:31:30,300 --> 00:31:31,770
0,150 150,240 240,840 840,1320 1350,1470
we're in supervisor mode,| I
|我不知道有什么方法可以直接找出机器处于什么模式，

1084
00:31:31,770 --> 00:31:32,460
0,120 120,270 270,450 450,600 600,690
don't know any way of


1085
00:31:32,460 --> 00:31:33,870
0,360 360,540 540,780 780,1260 1290,1410
finding out what mode the


1086
00:31:33,870 --> 00:31:36,090
0,360 360,510 510,780 810,1380 1830,2220
machine is in directly,| {}
|{}但我确实观察到程序计数器当前在页面中执行，

1087
00:31:36,330 --> 00:31:37,590
0,270 270,330 330,540 540,1020 1020,1260
but I do observe that


1088
00:31:37,590 --> 00:31:39,180
0,240 270,660 660,1110 1110,1260 1260,1590
the program counter is currently


1089
00:31:39,180 --> 00:31:40,530
0,600 600,720 720,780 780,1290 1290,1350
executing in a page,| the
|没有设置PTE U标志的蹦床页面

1090
00:31:40,530 --> 00:31:42,540
0,480 480,990 1140,1620 1620,1890 1890,2010
trampoline page that doesn't have


1091
00:31:42,540 --> 00:31:44,580
0,90 90,390 390,960 960,1500 1500,2040
a pte u flag set|
|

1092
00:31:44,880 --> 00:31:45,990
0,330 330,450 450,570 570,780 780,1110
and that can only happen
这只能在没有崩溃的情况下发生，如果我们处于管理模式，

1093
00:31:45,990 --> 00:31:47,520
0,240 240,300 300,1050 1140,1410 1410,1530
without a crash, if we


1094
00:31:47,520 --> 00:31:48,750
0,90 90,150 150,810 810,930 960,1230
are in supervisor mode,| so
|所以我从没有坠机的情况下推论

1095
00:31:48,750 --> 00:31:50,340
0,240 300,1110 1110,1260 1260,1350 1350,1590
I deduce from the lack


1096
00:31:50,340 --> 00:31:52,350
0,60 60,150 150,840 1140,1770 1770,2010
of a crash| and the
|以及我们必须处于管理模式的程序计数器的值。

1097
00:31:52,380 --> 00:31:53,490
0,330 330,420 420,480 480,810 810,1110
value of the program counter


1098
00:31:53,490 --> 00:31:54,570
0,120 120,240 240,720 720,960 960,1080
that we must be in


1099
00:31:54,570 --> 00:31:55,840
0,660 660,870
supervisor mode.|
|

1100
00:31:57,790 --> 00:31:58,780
0,450 450,570 570,780 780,930 930,990
How we got here, of
我们是怎么走到这一步的，当然是通过eCall，

1101
00:31:58,780 --> 00:32:01,330
0,660 660,1140 1290,1770 1770,2190 2190,2550
course I through ecall,| ecall
|eCall实际上改变了三件事。

1102
00:32:01,330 --> 00:32:03,340
0,240 240,450 450,870 870,1110 1110,2010
really just changes three things.|
|

1103
00:32:03,640 --> 00:32:04,500
0,600
First,
首先，eCall将模式从用户更改为主管，

1104
00:32:04,780 --> 00:32:06,160
0,330 330,690 690,960 960,1110 1110,1380
ecall changes mode from user


1105
00:32:06,160 --> 00:32:09,610
0,90 90,900 1470,2220 2430,2910 2910,3450
to supervisor,| second ecall saves
|第二eCall将程序计数器寄存器保存在{Sepc-}寄存器中，

1106
00:32:09,610 --> 00:32:11,140
0,90 90,450 450,780 780,1410 1410,1530
the program counter register in


1107
00:32:11,140 --> 00:32:13,060
0,150 150,660 660,1140 1140,1710 1740,1920
the {sepc -} register,| so
|所以我们可以看到它的效果。

1108
00:32:13,060 --> 00:32:13,930
0,60 60,180 180,390 390,510 510,870
we can see the effect


1109
00:32:13,930 --> 00:32:14,800
0,60 60,360
of that.|
|

1110
00:32:14,900 --> 00:32:16,190
0,90 90,240 240,300 300,720 720,1290
I think the program registers
我想程序注册程序计数器，

1111
00:32:16,250 --> 00:32:17,840
0,690 690,930 930,1080 1080,1440 1440,1590
program counter,| it's certainly no
|它当然不再是用户程序计数器，

1112
00:32:17,840 --> 00:32:19,340
0,270 270,390 390,690 690,1020 1020,1500
longer the user program counter,|
|

1113
00:32:19,430 --> 00:32:20,240
0,210 210,300 300,510 510,630 630,810
even though while the other
即使当其他寄存器在，

1114
00:32:20,240 --> 00:32:21,460
0,540 540,900
registers were,|
|

1115
00:32:21,580 --> 00:32:24,310
0,510 840,1080 1080,1620 1920,2340 2340,2730
{} this, this value copied
{}这个，这个值是从{stvec-}复制过来的。{}我们还可以打印，{}保存的

1116
00:32:24,310 --> 00:32:25,580
0,150 150,540 540,990
from {stvec -}.


1117
00:32:26,010 --> 00:32:27,330
0,420 540,810 810,870 870,1020 1020,1320
{} And we can also


1118
00:32:27,330 --> 00:32:28,180
0,600
print,


1119
00:32:28,660 --> 00:32:31,480
0,450 480,600 600,1680 2100,2460 2460,2820
{} the saved,| {} it's
|{}这是主管例外程序的计数器，

1120
00:32:31,480 --> 00:32:34,330
0,150 150,1290 1290,1890 1890,2280 2280,2850
the supervisor exception program counters


1121
00:32:34,330 --> 00:32:35,560
0,150 150,270 270,630 630,930 960,1230
what that stands for,| but
|但这是eCall保存用户程序、程序计数器

1122
00:32:35,560 --> 00:32:36,970
0,120 120,210 210,450 450,810 810,1410
this is where ecall saves


1123
00:32:36,970 --> 00:32:38,620
0,90 90,390 390,780 960,1230 1230,1650
the user program, program counter,|
|

1124
00:32:38,920 --> 00:32:40,180
0,420 630,780 780,930 930,1140 1140,1260
{} and that has a
{}，它具有熟悉的值{0xde6-}

1125
00:32:40,180 --> 00:32:42,250
0,480 480,990 1020,1410 1410,1890 1890,2070
familiar value {0xde6 -}| which
|该地址是eCall指令在用户空间中的地址。

1126
00:32:42,250 --> 00:32:43,840
0,480 570,750 750,1110 1110,1290 1290,1590
is the address in user


1127
00:32:43,840 --> 00:32:46,390
0,660 1230,1620 1620,1740 1740,2040 2040,2550
space of the ecall instruction.|
|

1128
00:32:47,130 --> 00:32:47,850
0,210 210,270 270,390 390,510 510,720
So we got that one
所以我们至少有一个寄存器被eCall存起来了。

1129
00:32:47,850 --> 00:32:49,110
0,450 450,540 540,750 750,990 990,1260
register at least saved away


1130
00:32:49,110 --> 00:32:50,180
0,150 150,750
by ecall.|
|

1131
00:32:50,510 --> 00:32:51,380
0,150 150,240 240,510 510,690 690,870
And the final thing that
你所说的最后一件事是做第三件事，

1132
00:32:51,380 --> 00:32:52,370
0,90 90,330 330,600 600,720 720,990
you call does the third


1133
00:32:52,370 --> 00:32:53,630
0,150 150,210 210,450 450,720 720,1260
thing,| it does is jump
|它确实是跳转到{stvec-}指向的指令。

1134
00:32:53,870 --> 00:32:56,210
0,210 210,330 330,1050 1050,1710 1740,2340
to the instruction that {stvec


1135
00:32:56,210 --> 00:32:58,180
0,270 270,600 600,810
-} points to.|
|

1136
00:33:02,270 --> 00:33:04,480
0,690 1320,1920
Alright, um.|
好的，嗯。|

1137
00:33:04,940 --> 00:33:05,780
0,180 180,300 300,480 480,540 540,840
So what needs to happen
所以现在需要做的是，

1138
00:33:05,780 --> 00:33:06,590
0,270 270,390 390,630 630,750 750,810
now,| {ecall -} down a
|{eCall-}为我们做点工作，

1139
00:33:06,590 --> 00:33:07,370
0,180 180,270 270,360 360,570 570,780
little bit of work for


1140
00:33:07,370 --> 00:33:08,690
0,240 240,480 810,1020 1020,1200 1200,1320
us,| but it turns out
|但事实证明，我们还远没有准备好在内核中实际执行普通的C代码，

1141
00:33:08,690 --> 00:33:09,620
0,60 60,120 120,390 390,600 600,930
we are nowhere near ready


1142
00:33:09,620 --> 00:33:11,090
0,150 150,480 480,900 900,1260 1260,1470
to actually execute ordinary C


1143
00:33:11,090 --> 00:33:12,560
0,240 240,330 330,390 390,900 1260,1470
code in the kernel,| {}
|{}现在要做什么我们需要保存32个用户注册内容，

1144
00:33:12,560 --> 00:33:13,730
0,240 240,390 390,480 480,750 750,1170
what has to happen now


1145
00:33:14,090 --> 00:33:15,140
0,240 240,330 330,480 480,570 570,1050
do we need to save


1146
00:33:15,140 --> 00:33:17,660
0,90 90,630 630,1050 1050,1620 1620,2520
the 32 user register contents,|
|

1147
00:33:17,990 --> 00:33:19,070
0,180 180,270 270,420 420,690 690,1080
so we can later restore
这样我们以后就可以恢复它们了

1148
00:33:19,070 --> 00:33:19,970
0,240 240,390 390,600 600,720 720,900
them| and when we want
|当我们想恢复用户代码时，

1149
00:33:19,970 --> 00:33:21,320
0,60 60,570 570,630 630,900 900,1350
to resume the user code,|
|

1150
00:33:21,920 --> 00:33:22,790
0,240 240,330 330,450 450,540 540,870
now we need to switch
现在我们需要切换到内核页表，

1151
00:33:22,790 --> 00:33:24,110
0,120 120,210 210,630 630,930 930,1320
to the kernel page table,|
|

1152
00:33:24,110 --> 00:33:25,220
0,390 420,780 780,870 870,1020 1020,1110
because currently we use the
因为目前我们使用的是用户页表，

1153
00:33:25,220 --> 00:33:27,140
0,270 270,510 510,930 1290,1770 1770,1920
user page table,| we need
|我们需要创建堆栈或查找堆栈

1154
00:33:27,140 --> 00:33:28,340
0,240 270,540 540,570 570,1110 1110,1200
to create a stack or


1155
00:33:28,340 --> 00:33:29,450
0,240 240,300 300,690 690,840 840,1110
find a stack| and set
|并将堆栈指针寄存器设置为指向内核堆栈，

1156
00:33:29,450 --> 00:33:30,560
0,60 60,360 360,600 600,1020 1020,1110
the stack pointer register to


1157
00:33:30,560 --> 00:33:32,360
0,360 360,450 450,720 810,1260 1260,1800
point to the kernel stack,|
|

1158
00:33:32,360 --> 00:33:32,960
0,150 150,240 240,390 390,540 540,600
so we can run the
所以我们可以运行需要堆栈的C代码

1159
00:33:32,960 --> 00:33:34,430
0,210 210,630 750,990 990,1380 1380,1470
C code which requires a


1160
00:33:34,430 --> 00:33:35,510
0,420 570,780 780,870 870,930 930,1080
stack| and then we need
|然后，我们需要跳到内核中C代码的某个合理位置。

1161
00:33:35,510 --> 00:33:36,620
0,90 90,360 360,690 690,810 810,1110
to actually jump to some


1162
00:33:36,620 --> 00:33:39,050
0,420 420,1080 1950,2160 2160,2220 2220,2430
sensible place in the C


1163
00:33:39,050 --> 00:33:40,280
0,330 330,420 420,480 480,870
code in the kernel.|
|

1164
00:33:40,700 --> 00:33:42,820
0,480 750,1080 1080,1140 1140,1830
Now as an aside,|
现在顺便说一句，|

1165
00:33:43,580 --> 00:33:44,510
0,210 210,270 270,630 630,810 810,930
you know ecall didn't do
您知道eCall没有为我们做任何这些事情{}。

1166
00:33:44,510 --> 00:33:45,530
0,180 180,240 240,420 420,750 750,1020
any of these things for


1167
00:33:45,530 --> 00:33:46,860
0,420 450,1050
us {}.|
|

1168
00:33:47,070 --> 00:33:47,820
0,150 150,270 270,420 420,540 540,750
You know, but you could
您知道，但是您可以让硬件定义{eCall-}来做更多事情。

1169
00:33:47,820 --> 00:33:49,650
0,390 570,930 960,1470 1470,1680 1680,1830
have the hardware could have


1170
00:33:49,650 --> 00:33:50,760
0,480 480,600 600,870 870,930 930,1110
defined {ecall -} to do


1171
00:33:50,760 --> 00:33:52,380
0,240 240,780
much more.|
|

1172
00:33:53,390 --> 00:33:54,590
0,390 390,570 570,630 630,780 780,1200
Many more of these steps
对于我们来说，这些步骤要多得多，而不是把它们留给软件

1173
00:33:54,590 --> 00:33:55,730
0,360 360,510 510,780 780,870 870,1140
for us instead of leaving


1174
00:33:55,730 --> 00:33:56,750
0,120 120,210 210,600 600,690 690,1020
them to software| and as
|正如我们将在软件过程中看到的，这并不是特别简单，

1175
00:33:56,750 --> 00:33:58,550
0,390 390,870 870,1110 1170,1650 1650,1800
we'll see the during the


1176
00:33:58,550 --> 00:34:00,620
0,360 360,510 510,900 900,1380 1380,2070
software, it's not particularly straightforward,|
|

1177
00:34:01,310 --> 00:34:02,270
0,210 210,330 330,450 450,660 660,960
so you should ask yourself
所以你应该问问你自己，为什么eCall不能做更多的工作

1178
00:34:02,270 --> 00:34:03,620
0,390 390,540 540,930 930,1230 1230,1350
why the ecall doesn't do


1179
00:34:03,620 --> 00:34:05,150
0,360 360,450 450,570 570,1020 1050,1530
more of the work| of
|从用户空间进入内核，

1180
00:34:05,180 --> 00:34:06,260
0,270 270,420 420,630 630,930 930,1080
getting from user space into


1181
00:34:06,260 --> 00:34:07,610
0,60 60,540 660,960 960,1110 1110,1350
the kernel,| {you,know} why doesn't
|{您知道}为什么不{}保存他们的用户注册

1182
00:34:07,610 --> 00:34:08,160
0,210
it


1183
00:34:08,220 --> 00:34:10,020
0,360 360,720 720,870 870,1110 1110,1800
{} save their user registers|
|

1184
00:34:10,020 --> 00:34:12,960
0,540 810,1860 1890,2250 2250,2520 2520,2940
or switch page table finders
或者切换页表查找器以指向内核页表

1185
00:34:12,960 --> 00:34:13,680
0,90 90,300 300,390 390,450 450,720
to point to the kernel


1186
00:34:13,680 --> 00:34:16,110
0,300 300,780 780,1350 1440,2100 2100,2430
page table| or automatically set
|或者自动将堆栈指针设置为指向内核堆栈，

1187
00:34:16,110 --> 00:34:17,340
0,180 180,510 510,870 870,960 960,1230
the stack pointer to point


1188
00:34:17,340 --> 00:34:18,760
0,90 90,330 360,630 630,1230
to the kernel stack,|
|

1189
00:34:19,020 --> 00:34:20,400
0,270 270,540 540,810 810,1080 1080,1380
or jump right to kernel
或者直接跳转到内核{C，code}[]

1190
00:34:20,400 --> 00:34:22,320
0,720 750,1230 1230,1560 1560,1680 1680,1920
{C,code} []| rather than having
|而不必经历所有这些{}复杂的汇编代码。

1191
00:34:22,320 --> 00:34:23,190
0,60 60,210 210,390 390,480 480,870
to go through all this


1192
00:34:23,190 --> 00:34:26,640
0,450 660,1260 1260,1650 1650,2070
{} complicated assembly code.|
|

1193
00:34:26,990 --> 00:34:28,490
0,120 120,390 390,690 690,840 840,1500
And there's actually been machines
实际上已经有机器完成了所有这些事情，

1194
00:34:28,490 --> 00:34:29,240
0,150 150,270 270,450 450,660 660,750
that have done all of


1195
00:34:29,240 --> 00:34:30,380
0,210 210,930
these things,|
|

1196
00:34:30,530 --> 00:34:33,860
0,450 450,600 600,1290 1890,2400 2970,3330
{} in hardware {} during
在系统调用期间的硬件{}中的{}，

1197
00:34:33,860 --> 00:34:36,590
0,330 330,870 1980,2190 2190,2520 2520,2730
system calls,| the RISC-V doesn't
|RISC-V不会做任何一件事，

1198
00:34:36,590 --> 00:34:37,310
0,120 120,300 300,360 360,510 510,720
do any of them,| {RISC-V
|{RISC-V-}实际上他们采取的态度是

1199
00:34:37,310 --> 00:34:38,420
0,240 240,480 480,570 570,960 960,1110
-} really the attitude they've


1200
00:34:38,420 --> 00:34:40,100
0,330 330,510 510,630 630,1320 1350,1680
taken is| the ecall does
|eCall做了它可能做的绝对最低要求

1201
00:34:40,100 --> 00:34:42,770
0,270 270,750 750,1470 1470,1770 1770,2670
the absolute minimum that's required


1202
00:34:42,800 --> 00:34:43,820
0,120 120,180 180,300 300,780 780,1020
that it could possibly do|
|

1203
00:34:43,820 --> 00:34:44,780
0,90 90,300 300,600 600,810 810,960
and leave everything else up
而把其他的一切都留给软件。

1204
00:34:44,780 --> 00:34:45,760
0,90 90,660
to software.|
|

1205
00:34:45,860 --> 00:34:46,850
0,180 180,270 270,600 600,720 720,990
And the reason for this
这样做的原因是

1206
00:34:46,850 --> 00:34:48,170
0,150 150,570 600,900 900,1110 1110,1320
is| because the {RISC-V -}
|因为{RISC-V-}设计者希望允许软件具有最大的灵活性，

1207
00:34:48,170 --> 00:34:50,000
0,540 540,720 720,780 780,1170 1170,1830
designers want to allow maximum


1208
00:34:50,000 --> 00:34:52,340
0,930 1020,1350 1350,1560 1560,2280 2280,2340
flexibility to the software,| the
|操作系统程序员可以随心所欲地设计程序操作系统。

1209
00:34:52,340 --> 00:34:54,410
0,450 450,900 900,1620 1620,1710 1710,2070
operating system programmers to design


1210
00:34:54,410 --> 00:34:56,510
0,390 540,1020 1050,1440 1440,1770 1770,2100
the program operating system, however


1211
00:34:56,510 --> 00:34:57,400
0,120 120,570
they like.|
|

1212
00:34:57,540 --> 00:34:59,400
0,480 990,1170 1170,1410 1500,1770 1770,1860
{} And so you can
{}所以你可以想象{xv6-}实际上没有使用这种自由的方式，

1213
00:34:59,400 --> 00:35:01,380
0,390 390,780 780,1110 1110,1590 1680,1980
imagine ways {xv6 -} really


1214
00:35:01,380 --> 00:35:03,030
0,270 270,510 510,690 690,1170 1380,1650
doesn't use this freedom,| {}
|{}但是其他操作系统是这样做的，

1215
00:35:03,030 --> 00:35:04,560
0,270 270,480 480,870 870,1260 1260,1530
but other operating systems do,|
|

1216
00:35:04,590 --> 00:35:07,050
0,240 240,390 390,1350 1380,1620 1890,2460
so some examples of things
因此，我们可以举几个软件可以做的事情的例子，

1217
00:35:07,050 --> 00:35:08,610
0,240 240,390 390,570 570,690 720,1560
that are kind of enabled


1218
00:35:08,640 --> 00:35:09,840
0,150 150,210 210,630 630,720 720,1200
for the software to do,|
|

1219
00:35:10,170 --> 00:35:11,910
0,180 180,600 600,1020 1020,1200 1200,1740
{} because ecall so simple,|
{}因为eCall太简单了，|

1220
00:35:12,300 --> 00:35:13,060
0,480
Um.|
恩。|

1221
00:35:13,270 --> 00:35:13,760
0,120


1222
00:35:14,540 --> 00:35:16,550
0,660 690,990 990,1350 1350,1860 1860,2010
Maybe some operating systems can
也许一些操作系统可以在不切换页表的情况下执行一些陷阱一些系统调用，

1223
00:35:16,550 --> 00:35:19,190
0,450 450,1230 1560,2040 2040,2280 2280,2640
execute some trap some system


1224
00:35:19,190 --> 00:35:21,320
0,330 330,660 660,1080 1080,1440 1440,2130
calls without switching page tables,|
|

1225
00:35:21,470 --> 00:35:23,000
0,210 210,510 510,810 810,1230 1230,1530
the searching page page tables,
搜索页面表，如果eCall强迫你这样做的话会很贵，

1226
00:35:23,000 --> 00:35:24,710
0,660 690,990 990,1230 1230,1620 1620,1710
expensive if ecall forces you


1227
00:35:24,710 --> 00:35:26,270
0,90 90,270 270,510 690,1230 1230,1560
to do it,| now that
|现在这就排除了非常精简的可能性，

1228
00:35:26,270 --> 00:35:27,560
0,270 270,390 390,480 480,1170 1170,1290
rules out the possibility of


1229
00:35:27,560 --> 00:35:30,560
0,450 450,1500 1860,2610 2610,2700 2700,3000
very streamlined,| implementations for some
|一些不切换页表的系统调用的实现。

1230
00:35:30,560 --> 00:35:32,000
0,330 330,840 840,930 930,1170 1170,1440
system calls that don't switch


1231
00:35:32,000 --> 00:35:33,040
0,270 270,870
page tables.|
|

1232
00:35:33,360 --> 00:35:35,910
0,480 1140,1380 1380,1710 1710,2220 2220,2550
Um, some operating systems both
嗯，有些操作系统既有用户操作系统，也有内核操作系统。

1233
00:35:35,910 --> 00:35:37,660
0,420 420,780 780,1440
user and kernel.|
|

1234
00:35:37,760 --> 00:35:39,080
0,360 360,690 690,1080 1080,1230 1230,1320
{} Virtual addresses into a
将{}个虚拟地址放入单个页表

1235
00:35:39,080 --> 00:35:40,220
0,330 330,600 600,870 870,960 960,1140
single page table| and use
|并对用户和内核使用相同的页表

1236
00:35:40,220 --> 00:35:41,420
0,90 90,390 390,720 720,1080 1080,1200
the same page table for


1237
00:35:41,420 --> 00:35:42,500
0,240 240,480 480,570 570,930 930,1080
both user and kernel| and
|因此甚至不必切换页表

1238
00:35:42,500 --> 00:35:43,430
0,270 270,480 480,630 630,810 810,930
therefore don't even have to


1239
00:35:43,430 --> 00:35:45,680
0,300 300,600 600,930 930,1290 1800,2250
switch page tables| ever when
|当在用户和内核之间转换时，

1240
00:35:45,680 --> 00:35:47,300
0,570 570,930 930,1200 1200,1290 1290,1620
transitioning between user and kernel,|
|

1241
00:35:47,930 --> 00:35:48,860
0,150 150,240 240,450 450,810 810,930
and for them also if
对于它们，如果您调用交换机页表

1242
00:35:48,860 --> 00:35:50,030
0,90 90,300 300,570 570,840 840,1170
you call switch page tables|
|

1243
00:35:50,030 --> 00:35:50,450
0,60 60,150 150,270 270,360 360,420
{} would just be a
{}只会是一种浪费，会让事情慢下来。

1244
00:35:50,450 --> 00:35:52,190
0,570 780,900 900,1140 1140,1350 1350,1740
waste and slow things down.|
|

1245
00:35:52,620 --> 00:35:54,990
0,390 510,900 900,1020 1020,1200 1200,2370
{} Maybe in some circumstances,
{}可能在某些情况下，比如{}系统调用，

1246
00:35:55,020 --> 00:35:56,640
0,360 360,720 720,990 990,1050 1050,1620
{} system calls for example,|
|

1247
00:35:57,180 --> 00:35:58,410
0,270 270,780 780,990 990,1140 1140,1230
some registers don't have to
某些寄存器不需要保存

1248
00:35:58,410 --> 00:35:59,910
0,90 90,960 990,1110 1110,1350 1350,1500
be saved| and which ones
|以及哪些必须被拯救，师父，

1249
00:35:59,910 --> 00:36:00,900
0,150 150,240 240,330 330,660 660,990
have to be saved master,|
|

1250
00:36:00,900 --> 00:36:02,160
0,60 60,390 390,450 450,510 510,1260
it depends on the software
这取决于软件或语言和编译器

1251
00:36:02,160 --> 00:36:03,090
0,60 60,180 180,750 750,870 870,930
or the language and the


1252
00:36:03,090 --> 00:36:04,710
0,660 660,900 1200,1440 1440,1500 1500,1620
compiler| but might be able
|但是可以通过节省少于32个寄存器来节省大量时间，

1253
00:36:04,710 --> 00:36:05,160
0,60 60,210 210,240 240,390 390,450
to save a lot of


1254
00:36:05,160 --> 00:36:06,540
0,270 270,420 420,840 840,1230 1230,1380
time by saving fewer than


1255
00:36:06,540 --> 00:36:08,040
0,420 420,1230 1260,1350 1350,1410 1410,1500
32 registers,| so you don't
|所以你不想让eCall强迫你，

1256
00:36:08,040 --> 00:36:08,880
0,210 210,510 510,600 600,780 780,840
want ecall to kind of


1257
00:36:08,880 --> 00:36:09,820
0,360 360,660
force you,|
|

1258
00:36:10,080 --> 00:36:11,550
0,150 150,870 870,1110 1110,1380 1380,1470
{you,don't} necessarily want ecall to
{您，不}不一定希望eCall强制您保存所有寄存器{}。

1259
00:36:11,550 --> 00:36:12,600
0,450 450,540 540,630 630,870 870,1050
force you to save all


1260
00:36:12,600 --> 00:36:14,500
0,90 90,840 1080,1620
the registers {}.|
|

1261
00:36:14,720 --> 00:36:15,920
0,180 180,450 450,690 690,870 870,1200
And finally, maybe no stack
最后，一些简单的系统调用可能根本不需要堆栈，

1262
00:36:15,920 --> 00:36:16,970
0,90 90,300 300,450 450,930 930,1050
at all is required for


1263
00:36:16,970 --> 00:36:18,560
0,210 210,540 540,870 870,1230 1230,1590
some simple system calls,| so
|所以再说一次，非常关心性能的操作系统，

1264
00:36:18,920 --> 00:36:21,410
0,690 1200,1920 1920,2250 2250,2340 2340,2490
again operating systems that care


1265
00:36:21,410 --> 00:36:22,670
0,60 60,270 270,480 480,1110 1110,1260
a lot about performance,| it's
|这很好，eCall不会将任何特定的堆栈策略强加给您。

1266
00:36:22,670 --> 00:36:24,260
0,300 300,390 390,690 690,1020 1020,1590
good, the ecall doesn't force


1267
00:36:24,290 --> 00:36:25,910
0,210 210,660 660,990 990,1440 1440,1620
any particular stack policy on


1268
00:36:25,910 --> 00:36:26,240
0,90
you.|
|

1269
00:36:26,810 --> 00:36:29,180
0,480 1020,1230 1230,1470 1470,1620 1620,2370
{} And again there's many
{}再说一遍，有很多聪明的硬件、软件方案

1270
00:36:29,180 --> 00:36:30,320
0,750
clever


1271
00:36:30,480 --> 00:36:34,020
0,1200 1200,1830 1830,2580 2580,3000 3180,3540
hardware, software schemes| for very
|用于非常精简的高性能系统调用和跟踪

1272
00:36:34,020 --> 00:36:36,720
0,780 780,960 960,1770 1920,2400 2400,2700
streamlined high performance system calls


1273
00:36:36,720 --> 00:36:37,950
0,90 90,630 660,840 840,1080 1080,1230
and tracks| just because the
|仅仅因为这个东西的性能是超级重要的，人们对此非常担心。

1274
00:36:37,950 --> 00:36:39,090
0,420 420,480 480,600 600,840 840,1140
performance of this stuff is


1275
00:36:39,540 --> 00:36:40,920
0,450 450,840 840,930 930,1170 1170,1380
super important and people worry


1276
00:36:40,920 --> 00:36:43,650
0,210 210,360 360,450 450,720 2160,2730
about it a lot.| Okay,
|好的，那么回到xv6和{}{RISC-V-}。

1277
00:36:44,340 --> 00:36:45,600
0,270 270,420 420,510 510,1170 1170,1260
so back to xv6 and


1278
00:36:45,600 --> 00:36:48,240
0,90 90,300 300,960
{} {RISC-V -}.|
|

1279
00:36:48,360 --> 00:36:49,020
0,120 120,300 300,390 390,480 480,660
The first thing we need
我们首先要做的是保存一些寄存器，

1280
00:36:49,020 --> 00:36:49,950
0,60 60,300 300,420 420,750 750,930
to do is save some


1281
00:36:49,950 --> 00:36:51,690
0,600 600,840 870,1050 1050,1170 1170,1740
registers,| we can do hardly
|如果没有几个寄存器，我们几乎不能在{RISC-V-}上做任何事情，

1282
00:36:51,690 --> 00:36:53,370
0,720 840,1020 1020,1080 1080,1320 1320,1680
anything on the {RISC-V -}


1283
00:36:53,370 --> 00:36:56,140
0,300 300,360 360,930 1080,2040
without a few registers,|
|

1284
00:36:56,290 --> 00:36:57,040
0,270 270,390 390,540 540,600 600,750
without being able to use
在不能使用寄存器的情况下，

1285
00:36:57,040 --> 00:36:58,600
0,540 540,690 690,840 840,1050 1050,1560
registers,| so what are options
|那么，保存用户寄存器的选项有哪些呢？

1286
00:36:58,600 --> 00:37:00,480
0,150 150,600 600,840 840,1680
for saving user registers.|
|

1287
00:37:01,130 --> 00:37:02,600
0,300 300,840 930,1110 1110,1290 1290,1470
{} In on some other
{}在其他机器上，我们也许可以

1288
00:37:02,600 --> 00:37:03,650
0,510 510,630 630,780 780,870 870,1050
machine, we might be able


1289
00:37:03,650 --> 00:37:05,090
0,90 90,300 300,780 780,960 960,1440
to| just write the contents
|只需将32个寄存器的内容写入物理内存中方便的位置即可。

1290
00:37:05,090 --> 00:37:06,440
0,90 90,180 180,570 570,1050 1050,1350
of the 32 registers somewhere


1291
00:37:06,440 --> 00:37:08,260
0,570 570,720 720,1050 1050,1560
convenient in physical memory.|
|

1292
00:37:08,400 --> 00:37:09,990
0,450 660,990 990,1200 1200,1410 1410,1590
{} We cant actually really
{}我们不能在{RISC-V-}上真正做到这一点

1293
00:37:09,990 --> 00:37:10,680
0,150 150,300 300,390 390,450 450,690
do that on the {RISC-V


1294
00:37:10,680 --> 00:37:11,980
0,360 360,1050
-}| because
|由于{}主管代码不允许直接访问物理内存，

1295
00:37:12,060 --> 00:37:13,440
0,240 240,690 690,870 870,1050 1050,1380
{} supervisor code isn't allowed


1296
00:37:13,440 --> 00:37:15,000
0,60 60,450 450,780 780,1140 1140,1560
to directly access physical memory,|
|

1297
00:37:15,030 --> 00:37:15,960
0,120 120,300 300,510 510,690 690,930
we can only use what's
我们只能使用页表中的内容，

1298
00:37:15,960 --> 00:37:17,220
0,90 90,150 150,420 420,840 840,1260
in the page table,| there's
|页表中的内容不多。

1299
00:37:17,250 --> 00:37:18,180
0,300 300,510 510,600 600,660 660,930
not much in the page


1300
00:37:18,180 --> 00:37:18,720
0,270
table.|
|

1301
00:37:19,290 --> 00:37:22,680
0,570 1350,1890 1890,2520 2520,2790 3030,3390
{} Another possibility that {xv6
{}{xv6--}做不到的另一种可能性是

1302
00:37:22,680 --> 00:37:24,060
0,120 120,390 390,780 780,1110 1110,1380
- -} doesn't do is|
|

1303
00:37:24,090 --> 00:37:25,950
0,420 420,840 840,930 930,1320 1320,1860
simply setting the {satp -}
只需将{satp-}设置为内核页表

1304
00:37:26,070 --> 00:37:27,840
0,690 780,870 870,1140 1140,1440 1440,1770
to the kernel page table|
|

1305
00:37:27,990 --> 00:37:29,160
0,180 180,300 300,390 390,810 900,1170
and then we could use
然后我们可以使用所有内核{mappings-}

1306
00:37:29,160 --> 00:37:30,180
0,180 180,240 240,510 510,870 870,1020
all the kernel {mappings -}|
|

1307
00:37:30,180 --> 00:37:31,320
0,150 150,300 300,510 510,750 750,1140
and use them maybe to
或许可以用它们来帮助我们保存用户注册表

1308
00:37:31,650 --> 00:37:32,730
0,360 360,480 480,780 780,840 840,1080
help us save the user


1309
00:37:32,730 --> 00:37:35,010
0,840 1200,1560 1560,1770 1770,1890 1890,2280
registers| and that be legal,
|而且这是合法的，主管当然可以更改satp。

1310
00:37:35,010 --> 00:37:36,240
0,90 90,600 600,720 720,990 990,1230
the supervisor can certainly change


1311
00:37:36,240 --> 00:37:37,540
0,510
satp.|
|

1312
00:37:37,950 --> 00:37:39,150
0,480 480,570 570,750 750,1080 1080,1200
However, at this point in
然而，在陷阱处理程序中的这一点，即在开始处，

1313
00:37:39,150 --> 00:37:41,160
0,300 630,960 960,1560 1620,1920 1920,2010
the trap handler namely at


1314
00:37:41,160 --> 00:37:42,750
0,60 60,540 1110,1260 1260,1410 1410,1590
the beginning,| we don't even
|我们甚至不知道内核页表的地址，

1315
00:37:42,750 --> 00:37:43,620
0,120 120,240 240,720 720,810 810,870
know the address of the


1316
00:37:43,620 --> 00:37:45,210
0,300 300,600 600,1020 1110,1410 1410,1590
kernel page table,| {} and
|{}以及您执行以更改{satp-}的指令

1317
00:37:45,210 --> 00:37:47,040
0,690 720,840 840,1590 1590,1680 1680,1830
furthermore the instruction that you


1318
00:37:47,040 --> 00:37:49,410
0,660 750,1020 1020,1560 1560,1920 1920,2370
execute to change {satp -}|
|

1319
00:37:49,590 --> 00:37:51,060
0,660 660,810 810,930 930,1350 1350,1470
require that the address that
要求您加载到{satp-}的地址来自寄存器，

1320
00:37:51,060 --> 00:37:52,290
0,150 150,540 540,720 720,1020 1020,1230
you're loading into {satp -}


1321
00:37:52,290 --> 00:37:53,880
0,300 300,480 480,540 540,1110 1410,1590
come from a register,| so
|所以我们甚至执行指令来改变页表，

1322
00:37:53,880 --> 00:37:55,800
0,210 360,870 870,1320 1320,1410 1410,1920
we even execute the instruction


1323
00:37:55,800 --> 00:37:58,200
0,150 150,900 900,1260 1260,1860 2040,2400
to change page tables,| {}
|{}我们需要一些备用寄存器，以便将新的页表地址放入这些寄存器中，

1324
00:37:58,200 --> 00:38:00,090
0,150 150,330 330,450 450,840 840,1890
we need some spare registers


1325
00:38:00,120 --> 00:38:01,140
0,150 150,420 420,720
in order to


1326
00:38:01,550 --> 00:38:02,420
0,210 210,300 300,420 420,660 660,870
put the new page table


1327
00:38:02,420 --> 00:38:03,530
0,270 270,330 330,540 540,990 990,1110
address in those registers,| so
|因此，我们可以执行{}SATP修改指令。

1328
00:38:03,530 --> 00:38:05,450
0,90 90,270 390,1080 1590,1770 1770,1920
we can execute {} the


1329
00:38:05,450 --> 00:38:08,380
0,510 510,990 990,1560
satp modifying instruction.|
|

1330
00:38:08,920 --> 00:38:09,910
0,360 360,450 450,510 510,780 780,990
Alright, so we really need
好的，我们真的需要保存用户注册表，

1331
00:38:09,910 --> 00:38:12,130
0,420 930,1200 1200,1260 1260,1500 1500,2220
to save the user registers,|
|

1332
00:38:12,400 --> 00:38:15,430
0,450 870,1410 1440,1770 1770,2730 2820,3030
{} there's two parts to
{}对于{xv6--}如何在{RISC-V--}上执行此操作，解决方案分为两个部分。

1333
00:38:15,430 --> 00:38:17,650
0,450 480,1200 1200,1650 1740,1950 1950,2220
the solution for how {xv6


1334
00:38:17,650 --> 00:38:18,820
0,120 120,360 360,630 630,810 810,1170
- -} does this on


1335
00:38:18,910 --> 00:38:20,410
0,150 150,330 330,390 390,780 840,1500
the {RISC-V - -}.| One
|一个是解决方案的一部分，{xv6--}到每个用户地址，每个用户页表映射，这个陷阱帧。

1336
00:38:20,410 --> 00:38:22,240
0,600 780,1230 1230,1290 1290,1350 1350,1830
is part of the solution


1337
00:38:22,240 --> 00:38:23,060
0,210 210,480
is that,


1338
00:38:23,870 --> 00:38:25,760
0,270 270,420 420,930 1380,1620 1620,1890
{xv6 - -} into every


1339
00:38:25,760 --> 00:38:27,350
0,300 300,840 870,1110 1110,1320 1320,1590
user address, every user page


1340
00:38:27,350 --> 00:38:29,210
0,240 240,540 540,840 840,1230 1230,1860
table maps, this trap frame.|
|

1341
00:38:29,840 --> 00:38:32,210
0,390 420,1170 1200,1440 1440,1680 1680,2370
{} Page and every processes
{}页面和跟踪框架页面上的每个进程。

1342
00:38:32,210 --> 00:38:33,900
0,180 180,540 540,780 780,1440
on track frame page.|
|

1343
00:38:34,180 --> 00:38:35,280
0,360 360,780
Um, and.|
嗯，还有。|

1344
00:38:35,820 --> 00:38:37,800
0,270 270,450 450,900 930,1470 1590,1980
Trap frame page {} actually
陷阱框架页面{}实际上包含一些有趣的不同类型的数据，

1345
00:38:37,800 --> 00:38:39,180
0,330 330,480 480,1050 1050,1290 1290,1380
contains some interesting bunch of


1346
00:38:39,180 --> 00:38:40,260
0,210 210,420 420,480 480,810 810,1080
different kinds of data,| but
|但是在这一点上包含的最重要的数据是32个时隙，

1347
00:38:40,470 --> 00:38:41,430
0,330 330,510 510,690 690,780 780,960
at this point the most


1348
00:38:41,430 --> 00:38:43,800
0,360 360,720 720,1440 1440,1830 1830,2370
important data contains is 32


1349
00:38:43,800 --> 00:38:46,650
0,900 1110,1500 1500,2160 2160,2310 2310,2850
slots,| empty slots in memory
|内存中用于保存32个寄存器的空插槽。

1350
00:38:47,100 --> 00:38:48,090
0,150 150,330 330,450 450,900 900,990
in which to save the


1351
00:38:48,090 --> 00:38:50,140
0,480 480,1200 1320,1770
32 registers.| So,
|所以，现在陷阱处理代码中的好消息是我们有了一个映射，

1352
00:38:50,340 --> 00:38:51,420
0,300 300,450 450,630 630,810 810,1080
the good news right now


1353
00:38:51,420 --> 00:38:52,590
0,150 150,390 390,690 690,930 930,1170
in the trap handling code


1354
00:38:52,590 --> 00:38:53,880
0,90 90,270 270,600 600,690 690,1290
is we have a mapping,|
|

1355
00:38:53,880 --> 00:38:54,780
0,180 180,630 630,690 690,840 840,900
we're guaranteed to have a
我们保证之前由内核设置了一个映射

1356
00:38:54,780 --> 00:38:56,220
0,480 810,1140 1140,1230 1230,1350 1350,1440
mapping set up by the


1357
00:38:56,220 --> 00:38:57,870
0,270 270,1020 1080,1260 1260,1350 1350,1650
kernel previously| in the user
|在指向某个位置的用户页表中

1358
00:38:57,870 --> 00:38:59,240
0,270 270,720
page table


1359
00:38:59,300 --> 00:39:00,680
0,330 330,720 720,840 840,900 900,1380
that points to a place|
|

1360
00:39:00,680 --> 00:39:02,570
0,540 780,930 930,1170 1170,1740 1740,1890
where, {} that's prepared for
其中，{}为我们保存此进程、用户注册做好了准备。

1361
00:39:02,570 --> 00:39:04,250
0,150 150,270 270,660 660,870 870,1680
us to save this processes,


1362
00:39:04,280 --> 00:39:05,940
0,360 360,1140
user registers.|
|

1363
00:39:07,740 --> 00:39:09,060
0,270 270,390 390,630 630,930 930,1320
And it's sure it's three
可以肯定的是，它始终是{0x3ffffff000-}虚拟地址。

1364
00:39:09,060 --> 00:39:11,400
0,120 120,600 600,870 870,1170 1170,2340
is always {0x3ffffff000 - -


1365
00:39:11,460 --> 00:39:13,560
0,330 330,630 630,870 870,1470 1590,2100
- - - -} virtual


1366
00:39:13,560 --> 00:39:14,340
0,600
address.|
|

1367
00:39:14,770 --> 00:39:15,730
0,390 510,690 690,780 780,900 900,960
{} If you want to
{}如果你想看看他们在那个陷阱框里到底是什么，

1368
00:39:15,730 --> 00:39:17,290
0,210 210,390 390,750 750,1110 1140,1560
see what they are actually


1369
00:39:17,290 --> 00:39:18,580
0,150 150,330 330,630 630,960 960,1290
in that trap frame,| it's
|这是嗯。

1370
00:39:18,610 --> 00:39:19,500
0,570
um.|
|

1371
00:39:20,540 --> 00:39:22,250
0,420 540,780 780,930 930,1290 1290,1710
What {xv6 - -} puts
{xv6--}放在那里的内容在{proc.h--}中定义

1372
00:39:22,250 --> 00:39:24,560
0,360 360,600 600,1290 1290,1950
there is defined in,


1373
00:39:25,040 --> 00:39:26,000
0,720


1374
00:39:28,990 --> 00:39:30,610
0,330 330,540 540,1080 1080,1320 1320,1620
{proc.h - -}| and start
|开始保理，就在这里，

1375
00:39:30,610 --> 00:39:31,690
0,420 420,570 570,660 660,870 870,1080
factoring which is right here,|
|

1376
00:39:31,690 --> 00:39:33,790
0,120 120,240 240,330 330,1020 1530,2100
so you can see, um.|
所以你可以看到，嗯。|

1377
00:39:34,710 --> 00:39:35,610
0,270 270,570 570,630 630,810 810,900
What's supposed to go in
每个槽里应该放些什么？

1378
00:39:35,610 --> 00:39:37,710
0,180 180,660 690,990 1140,1530 1530,2100
each slot| and there's a
|这里有32个插槽，你需要一个rsp{gp-}，不管是用来保存寄存器的位置，

1379
00:39:37,710 --> 00:39:39,270
0,570 570,1050 1050,1200 1200,1440 1440,1560
32 slots, you need a


1380
00:39:39,270 --> 00:39:40,920
0,390 390,600 600,990 990,1200 1200,1650
ra sp {gp -} whatever


1381
00:39:40,920 --> 00:39:42,480
0,360 360,600 930,1230 1230,1320 1320,1560
which are places to save


1382
00:39:42,480 --> 00:39:43,800
0,450 450,600 600,810 810,1020 1020,1320
registers,| there's also these five
|开头还有这五件事，

1383
00:39:43,800 --> 00:39:45,660
0,300 300,360 360,420 420,1050 1560,1860
things at the beginning,| {}
|{}很快就会派上用场的，

1384
00:39:45,660 --> 00:39:46,740
0,300 300,510 510,780 780,900 900,1080
which will see will come


1385
00:39:46,740 --> 00:39:47,940
0,60 60,330 330,570 570,990 990,1200
in handy very soon,| which
|这些值是内核先前放置在陷阱帧中的时隙中的值。

1386
00:39:47,940 --> 00:39:49,830
0,90 90,1140 1320,1560 1560,1620 1620,1890
are values that the kernel


1387
00:39:49,830 --> 00:39:51,690
0,630 630,1080 1080,1170 1170,1260 1260,1860
previously placed in the slots


1388
00:39:51,690 --> 00:39:53,340
0,120 120,540 570,900 900,1380
in the trap frame.|
|

1389
00:39:53,800 --> 00:39:55,360
0,540 600,870 870,1200 1200,1320 1320,1560
Like, for example this very
例如跟踪帧中的这第一个时隙包含指向内核页表的指针，

1390
00:39:55,360 --> 00:39:56,260
0,240 240,480 480,540 540,600 600,900
first slot in the track


1391
00:39:56,260 --> 00:39:57,700
0,300 510,990 990,1050 1050,1380 1380,1440
frame contains a pointer to


1392
00:39:57,700 --> 00:39:59,170
0,90 90,360 360,630 630,960 1170,1470
the kernel page table,| and
|这将是我们很快要达到的价值。

1393
00:39:59,170 --> 00:39:59,950
0,120 120,240 240,360 360,420 420,780
this will be the value


1394
00:39:59,950 --> 00:40:01,630
0,210 210,780 870,1260 1260,1560 1560,1680
that we're very soon going


1395
00:40:01,630 --> 00:40:02,240
0,240
[].|
|

1396
00:40:02,490 --> 00:40:03,570
0,270 270,360 360,630 630,870 870,1080
{} The trap handling code
{}陷阱处理代码将加载到{satp-}中。

1397
00:40:03,570 --> 00:40:04,350
0,60 60,180 180,240 240,600 600,780
is going to load into


1398
00:40:04,350 --> 00:40:07,280
0,300 300,630 1920,2250 2250,2670
{satp -}.| Okay so,
|好的，那么，怎么说寄存器的一半答案是

1399
00:40:07,600 --> 00:40:08,830
0,420 420,540 540,810 810,1050 1050,1230
half the answer to how


1400
00:40:08,830 --> 00:40:09,790
0,60 60,210 210,300 300,840 840,960
to say the registers is


1401
00:40:09,790 --> 00:40:12,400
0,270 450,990 1080,1530 1530,1950 2100,2610
that| {} kernel is conveniently
|{}内核方便地映射了该陷阱帧和每个用户页表，

1402
00:40:12,400 --> 00:40:14,620
0,480 480,630 630,930 930,1440 2040,2220
mapped this trap frame and


1403
00:40:14,620 --> 00:40:15,730
0,270 270,450 450,690 690,990 990,1110
every user page table,| the
|另一个就是这个，{}个指令，{}个擦除寄存器，我们之前测过的，

1404
00:40:15,730 --> 00:40:17,770
0,240 240,390 390,840 840,840 1230,2040
other is this, {} instructions,


1405
00:40:17,770 --> 00:40:19,480
0,120 120,600 600,1080 1080,1350 1350,1710
{} sscratch register which we


1406
00:40:19,960 --> 00:40:22,150
0,690 690,1230 1650,1920 1920,2010 2010,2190
measured before,| {} so there's
|{}所以有专门的划痕登记簿，由{RISC-V-}提供，

1407
00:40:22,150 --> 00:40:24,160
0,90 90,660 660,1050 1050,1650
the specialist sscratch register,


1408
00:40:24,190 --> 00:40:26,200
0,480 480,720 720,1050 1050,1710 1740,2010
provided by {RISC-V -} for


1409
00:40:26,200 --> 00:40:27,400
0,420 420,540 540,870 870,960 960,1200
exactly the purpose,| we're about
|我们将把它用于{}。

1410
00:40:27,400 --> 00:40:29,050
0,60 60,240 240,360 360,720 1170,1650
to use it for {}.|
|

1411
00:40:30,150 --> 00:40:31,290
0,180 180,600 600,840 840,1080 1080,1140
The kernel went before it
内核在进入用户空间之前就走了

1412
00:40:31,290 --> 00:40:32,370
0,150 150,300 300,570 570,900 900,1080
goes into user space| puts
|在那里放置一个指向陷阱帧的指针，基本上就是指向，放入SATP，

1413
00:40:32,370 --> 00:40:33,180
0,60 60,480 480,660 660,720 720,810
a pointer there to the


1414
00:40:33,180 --> 00:40:34,860
0,390 390,690 690,1110 1110,1320 1320,1680
trap frame basically just point,


1415
00:40:35,230 --> 00:40:37,760
0,390 390,960 1170,1800 1800,2370
puts into satp,| this
|这个地址只是为了方便陷阱处理代码，

1416
00:40:38,370 --> 00:40:40,350
0,270 270,1080 1410,1800 1800,1890 1890,1980
this address just for the


1417
00:40:40,350 --> 00:40:41,610
0,570 570,630 630,690 690,990 990,1260
convenience of the trap handling


1418
00:40:41,610 --> 00:40:43,350
0,450 510,930 930,1380 1380,1530 1530,1740
code,| more importantly though there's
|更重要的是，虽然有一份RISC-V的指令

1419
00:40:43,350 --> 00:40:44,700
0,90 90,600 600,660 660,750 750,1350
an instruction of the RISC-V|
|

1420
00:40:44,850 --> 00:40:45,540
0,240 240,330 330,450 450,510 510,690
that it's going to allow
它将允许我们交换任何寄存器

1421
00:40:45,540 --> 00:40:47,310
0,120 120,270 270,810 810,1050 1050,1770
us to swap any register|
|

1422
00:40:47,550 --> 00:40:48,780
0,150 150,330 330,960 960,1110 1110,1230
and that sscratch which will
以及将保存该寄存器的划痕

1423
00:40:48,780 --> 00:40:50,400
0,390 390,600 600,1200 1200,1380 1380,1620
save that register| as well
|以及将sscatch的{}值加载到我们指定的任何寄存器中。

1424
00:40:50,400 --> 00:40:52,580
0,390 810,1590 1590,1860
as loads {}


1425
00:40:52,860 --> 00:40:54,930
0,390 390,630 630,1260 1530,1770 1770,2070
value of sscratch into whatever


1426
00:40:54,930 --> 00:40:56,420
0,420 420,510 510,1140
register we specified.|
|

1427
00:40:56,620 --> 00:40:58,360
0,270 270,360 360,480 480,900 1200,1740
As you can see, {}
如你所见，{}如果我看一下蹦床代码。

1428
00:40:58,660 --> 00:40:59,530
0,420 420,450 450,690 690,780 780,870
if I look at the


1429
00:40:59,530 --> 00:41:00,940
0,570 570,1140
trampoline code.|
|

1430
00:41:01,860 --> 00:41:03,660
0,630 930,1440 1440,1680 1680,1740 1740,1800
{} We're right at the
{}我们现在就在蹦床代码的开头。

1431
00:41:03,660 --> 00:41:05,280
0,270 270,360 360,870 870,1200 1200,1620
beginning of trampoline code here.|
|

1432
00:41:06,120 --> 00:41:06,930
0,150 150,360 360,570 570,720 720,810
The very first thing it
它做的第一件事是{csrrw-}

1433
00:41:06,930 --> 00:41:07,980
0,330 330,480 480,660 660,900 900,1050
does is this {csrrw -


1434
00:41:07,980 --> 00:41:09,220
0,330 330,960
- -}|
|

1435
00:41:09,550 --> 00:41:10,560
0,690


1436
00:41:11,060 --> 00:41:12,710
0,810 810,1020 1020,1140 1140,1230 1230,1650
instructions,| this is the source
说明，|这是此窗口上此窗口的源，

1437
00:41:12,710 --> 00:41:14,540
0,60 60,270 270,780 1290,1620 1620,1830
of this window over this


1438
00:41:14,540 --> 00:41:15,410
0,240 240,330 330,420 420,660 660,870
window,| we can actually see
|我们可以实际看到{gdb-}在内核中看到的内容

1439
00:41:15,410 --> 00:41:16,490
0,300 300,480 480,750 750,1020 1020,1080
what {gdb -} sees in


1440
00:41:16,490 --> 00:41:17,960
0,60 60,510 690,1020 1020,1170 1170,1470
the kernel| and we've actually
|我们实际上刚刚执行了这个交换指令。

1441
00:41:17,960 --> 00:41:19,520
0,450 480,1230
just executed


1442
00:41:20,030 --> 00:41:21,680
0,240 240,690 690,1350
this swap instruction.|
|

1443
00:41:22,260 --> 00:41:23,340
0,360 360,600 600,720 720,960 960,1080
Let's swap {a0 -} with
让我们将{a0-}与Scratch互换，

1444
00:41:23,340 --> 00:41:24,960
0,660 900,1140 1140,1320 1320,1410 1410,1620
scratch,| in order to see
|为了看看它做了什么，让我们打印出0，

1445
00:41:24,960 --> 00:41:26,100
0,150 150,270 270,600 600,810 810,1140
what it did, let's print


1446
00:41:26,100 --> 00:41:26,800
0,360
out


1447
00:41:27,150 --> 00:41:29,940
0,840 1350,1890 1890,2070 2070,2280 2280,2790
a0,| a0 is now this
|A0现在是这个3F，F，E的零值，它是一个指针。

1448
00:41:30,060 --> 00:41:31,620
0,540 540,810 810,1080 1080,1260 1260,1560
three F F E zero


1449
00:41:31,620 --> 00:41:33,210
0,240 240,900 930,1320 1320,1500 1500,1590
zero zero value which is


1450
00:41:33,210 --> 00:41:34,120
0,60 60,630
a pointer.|
|

1451
00:41:34,680 --> 00:41:35,700
0,180 180,270 270,360 360,660 660,1020
Which is the virtual address
哪一个是陷阱帧的虚拟地址

1452
00:41:35,700 --> 00:41:37,050
0,120 120,240 240,600 600,1050 1170,1350
of the trap frame| which
|它以前在{}Scratch里，但我们刚把它换了。

1453
00:41:37,050 --> 00:41:37,650
0,210 210,270 270,390 390,510 510,600
used to be in {}


1454
00:41:37,650 --> 00:41:38,820
0,420 420,540 540,630 630,780 780,1170
sscratch, but we just swapped


1455
00:41:38,820 --> 00:41:39,360
0,150
it.|
|

1456
00:41:39,590 --> 00:41:40,460
0,180 180,270 270,390 390,510 510,870
And then we can print
然后我们可以把Scratch中的内容打印出来。

1457
00:41:40,460 --> 00:41:42,260
0,270 270,540 540,690 690,1470
out what's in sscratch.|
|

1458
00:41:43,790 --> 00:41:44,720
0,150 150,330 330,630 630,870 870,930
And it's two which is
它是2，这是a0寄存器的旧值，

1459
00:41:44,720 --> 00:41:45,740
0,120 120,390 390,810 810,870 870,1020
the old value of the


1460
00:41:45,740 --> 00:41:47,900
0,450 450,990 990,1260 1260,1740 1740,2160
a0 register,| {of,course} zero held
|{当然，}ZERO保存WRITE函数的第一个参数。

1461
00:41:47,900 --> 00:41:49,700
0,90 90,570 600,1140 1590,1710 1710,1800
the first argument to the


1462
00:41:49,700 --> 00:41:50,780
0,300 300,810
write function.|
|

1463
00:41:50,970 --> 00:41:52,770
0,360 360,570 570,1050 1050,1290 1290,1800
Just file descriptor to which
只是您将shell传递到的文件描述符，

1464
00:41:52,770 --> 00:41:54,360
0,210 600,750 750,840 840,1020 1020,1590
you put the shell passed,|
|

1465
00:41:54,390 --> 00:41:55,320
0,150 150,240 240,570 570,720 720,930
so we saved you {a0
所以我们为您保存了{a0-}，并且我们有一个指向陷阱帧的指针。

1466
00:41:55,320 --> 00:41:57,480
0,570 1140,1710 1710,2010 2010,2100 2100,2160
-} and we have a


1467
00:41:57,480 --> 00:41:58,680
0,270 270,330 330,420 420,750 750,1200
pointer to the trap frame.|
|

1468
00:41:59,630 --> 00:42:00,920
0,360 540,840 840,900 900,1140 1140,1290
{} And it turns out
{}现在我们可以很好地保存寄存器了，

1469
00:42:00,920 --> 00:42:02,210
0,300 300,600 660,900 900,1140 1140,1290
now that we're well on


1470
00:42:02,210 --> 00:42:02,930
0,120 120,360 360,480 480,570 570,720
our way to be able


1471
00:42:02,930 --> 00:42:04,190
0,90 90,330 330,390 390,1110 1110,1260
to save the registers,| in
|事实上，这就是这个蹦床代码中接下来的{}30多条指令

1472
00:42:04,190 --> 00:42:06,050
0,360 720,1260 1260,1440 1440,1620 1620,1860
fact that's what the very


1473
00:42:06,050 --> 00:42:08,960
0,570 780,1320 1590,2040 2040,2250 2250,2910
next {} thirty odd instructions


1474
00:42:08,960 --> 00:42:11,300
0,540 900,1050 1050,1200 1200,1800 1800,2340
due in this trampoline code|
|

1475
00:42:11,420 --> 00:42:14,330
0,240 240,330 330,1440 1860,2400 2400,2910
which is systematically {} sd
它是系统的{}个SD指令，

1476
00:42:14,330 --> 00:42:16,340
0,810 810,900 900,1140 1140,1710
instructions,| you just save
|您只需保存64位安全存储指令

1477
00:42:16,460 --> 00:42:18,560
0,510 510,630 630,1020 1050,1470 1470,2100
64 bit safe store instructions|
|

1478
00:42:18,560 --> 00:42:20,120
0,120 120,420 420,660 660,930 930,1560
to store every single register
要将每个寄存器存储到陷阱帧中的不同偏移量{a0-}

1479
00:42:20,600 --> 00:42:23,330
0,150 150,270 270,900 1320,2370 2400,2730
to a different offset in


1480
00:42:23,330 --> 00:42:24,830
0,60 60,390 390,720 720,960 960,1500
the trap frame {a0 -}|
|

1481
00:42:25,100 --> 00:42:26,720
0,210 210,660 660,900 900,1350 1350,1620
to recall now contains after
要调回的现在包含在交换包含指向陷阱帧的指针之后

1482
00:42:26,720 --> 00:42:28,070
0,60 60,540 540,870 870,960 960,1350
the swap contains a pointer


1483
00:42:28,070 --> 00:42:29,780
0,120 120,390 450,780 780,1230 1440,1710
to the trap frame| that
|这可能会更改此页面的虚拟地址。

1484
00:42:29,780 --> 00:42:30,460
0,480
is


1485
00:42:30,800 --> 00:42:32,720
0,180 180,420 420,630 1230,1680 1680,1920
could change the virtual address


1486
00:42:32,720 --> 00:42:33,880
0,60 60,240 240,810
of this page.|
|

1487
00:42:34,510 --> 00:42:36,400
0,210 210,300 300,480 480,1170 1620,1890
And we're just storing each
我们只是在陷阱帧{}中存储每个注册的不同偏移量。所有的商店都有点无聊，所以我就跳过它们。

1488
00:42:36,400 --> 00:42:37,750
0,450 450,540 540,810 810,1260 1260,1350
registered a different offset in


1489
00:42:37,750 --> 00:42:39,860
0,60 60,330 330,540 1290,1800
the trap frame {}.


1490
00:42:42,130 --> 00:42:42,910
0,180 180,270 270,540 540,600 600,780
All the stores a bit


1491
00:42:42,910 --> 00:42:44,170
0,360 360,540 540,720 720,840 840,1260
boring, so I'm gonna skip


1492
00:42:44,170 --> 00:42:45,160
0,240 240,570
over them.|
|

1493
00:42:45,410 --> 00:42:46,540
0,870
Um.
恩。让我设定一个中断点，再往前走。

1494
00:42:48,640 --> 00:42:49,390
0,240 240,300 300,450 450,510 510,750
Let me set a break


1495
00:42:49,390 --> 00:42:51,960
0,240 240,330 330,720 720,1200
point, go further on.|
|

1496
00:42:55,880 --> 00:42:57,680
0,900 930,1530
{Professor,question?}| Yes.|
{教授，有问题吗？}|是。|

1497
00:42:58,200 --> 00:43:00,660
0,300 300,540 540,1170 1860,2310 2310,2460
How did the address of
当我们用0{交换它}时，陷阱帧的地址怎么会出现在{ssccratch-}中呢？

1498
00:43:00,660 --> 00:43:02,260
0,90 90,480 480,1170
the trap frame


1499
00:43:02,470 --> 00:43:03,880
0,270 270,480 480,720 720,810 810,1410
end up in {sscratch -}


1500
00:43:03,880 --> 00:43:05,140
0,150 150,240 240,660 660,780 780,1260
when we {swapped,it} with a0.|
|

1501
00:43:05,910 --> 00:43:10,110
0,360 360,1260 1290,1380 1380,2130 3540,4200
Okay before the kernel, before
好的，在内核之前，在它之前过渡到用户空间之前，

1502
00:43:10,110 --> 00:43:10,660
0,240
it


1503
00:43:10,800 --> 00:43:13,020
0,510 510,1110 1110,1170 1170,1470 1470,2220
previously transitioned to user space,|
|

1504
00:43:14,120 --> 00:43:16,400
0,840 840,990 990,1890 1980,2100 2100,2280
set {sscratch -} to be
将{ssccratch-}设置为等于{0x3fffffe000-}，则虚拟地址为陷阱帧。

1505
00:43:16,400 --> 00:43:19,160
0,450 450,1200 1410,1800 1800,1950 1950,2760
equal to {0x3fffffe000 - -


1506
00:43:19,160 --> 00:43:20,540
0,120 120,390 390,630 630,1140 1260,1380
- - - -}, the


1507
00:43:20,540 --> 00:43:21,890
0,300 300,690 690,750 750,1050 1050,1350
virtual addresses the trap frame.|
|

1508
00:43:22,730 --> 00:43:23,630
0,330 330,510 510,570 570,780 780,900
So all the time when
因此，当我们在shell中执行用户空间时，

1509
00:43:23,630 --> 00:43:24,530
0,90 90,150 150,570 570,660 660,900
we are executing a user


1510
00:43:24,530 --> 00:43:25,520
0,300 300,360 360,450 450,870 870,990
space in the shell,| {sscratch
|{ssccratch-}具有指向陷阱帧的指针，

1511
00:43:25,520 --> 00:43:26,660
0,360 360,600 600,750 750,1080 1080,1140
-} had this pointer to


1512
00:43:26,660 --> 00:43:28,980
0,90 90,360 360,690 1410,1950
the trap frame,| {}
|{}然后外壳执行eCall，

1513
00:43:29,140 --> 00:43:31,690
0,210 210,780 1230,1530 1530,1770 1770,2550
and then the shell executes


1514
00:43:31,690 --> 00:43:32,560
0,660


1515
00:43:34,430 --> 00:43:37,160
0,1050 1710,2250 2250,2610 2610,2670 2670,2730
ecall,| which jumps to the
|它跳到蹦床的起始处和蹦床的第一个指令，

1516
00:43:37,160 --> 00:43:38,480
0,240 240,330 330,390 390,1230 1230,1320
beginning of the trampoline and


1517
00:43:38,480 --> 00:43:39,560
0,60 60,360 360,600 600,1020 1020,1080
the very first instruction of


1518
00:43:39,560 --> 00:43:40,610
0,60 60,540 540,660 660,810 810,1050
the trampoline,| is this {csrrw
|此{csrrw-}指令是否在暂存上交换a0

1519
00:43:40,610 --> 00:43:42,140
0,150 150,570 600,810 810,1140 1140,1530
- - - -} instruction


1520
00:43:42,140 --> 00:43:43,640
0,150 150,930 930,1320 1320,1440 1440,1500
which swaps a0 on the


1521
00:43:43,640 --> 00:43:45,380
0,750 1260,1380 1380,1500 1500,1650 1650,1740
scratch| and so now the
|所以现在划痕的旧价值，

1522
00:43:45,380 --> 00:43:46,310
0,150 150,360 360,420 420,510 510,930
old value of the scratch,|
|

1523
00:43:46,310 --> 00:43:47,030
0,300 300,390 390,600 600,660 660,720
namely the point of the
也就是说，陷印帧的点现在是0。

1524
00:43:47,030 --> 00:43:48,110
0,330 330,570 570,660 660,900 900,1080
trap frame is now in


1525
00:43:48,110 --> 00:43:48,860
0,480
a0.|
|

1526
00:43:50,190 --> 00:43:51,180
0,180 180,270 270,450 450,540 540,990
Does that answer your question.|
这回答了你的问题吗。|

1527
00:43:53,230 --> 00:43:54,610
0,300 300,510 510,660 660,1050 1050,1380
I guess I'm wondering where
我想我在想在[]的什么地方，

1528
00:43:54,610 --> 00:43:56,500
0,210 210,810 900,1350 1410,1680 1680,1890
in the [],| does this
|在分配进程期间会发生这种情况吗

1529
00:43:56,500 --> 00:43:57,540
0,810
happen


1530
00:43:57,700 --> 00:43:59,440
0,630 630,750 750,1380 1380,1500 1500,1740
during the allocation of the


1531
00:43:59,440 --> 00:44:00,670
0,570 600,810 810,960 960,1080 1080,1230
process| like where do the
|比如划痕登记处住在哪里。

1532
00:44:00,670 --> 00:44:02,830
0,360 360,780 780,1290 1410,1650 1650,2160
scratch register live.| Where does
|这个抓痕在哪里做得很好，它本身就在CPU上。

1533
00:44:02,860 --> 00:44:04,840
0,210 210,360 360,660 660,1290 1290,1980
this well scratch itself lives


1534
00:44:05,080 --> 00:44:06,560
0,270 270,330 330,1020
on the CPU.|
|

1535
00:44:06,620 --> 00:44:07,730
0,150 150,570 570,960 960,1020 1020,1110
The special register in the
CPU中的特殊寄存器。

1536
00:44:07,730 --> 00:44:08,620
0,630
CPU.|
|

1537
00:44:08,970 --> 00:44:10,530
0,360 360,540 540,720 720,1080 1080,1560
Where and the kernel sets
内核设置它的位置，嗯，很好。

1538
00:44:10,530 --> 00:44:13,080
0,240 1200,1740 1770,2280
it, um well.|
|

1539
00:44:14,370 --> 00:44:16,920
0,690 1110,1740 1740,1830 1830,2310 2310,2550
A little bit involved, the
有点牵扯进去，就是它设置的实际位置

1540
00:44:16,980 --> 00:44:18,420
0,510 510,750 750,900 900,1020 1020,1440
actual place where it's set|
|

1541
00:44:18,420 --> 00:44:19,290
0,90 90,210 210,270 270,450 450,870
and what I'm now showing
我现在在右边给你们展示的是

1542
00:44:19,290 --> 00:44:20,370
0,150 150,240 240,300 300,600 600,1080
you on the right here|
|

1543
00:44:20,820 --> 00:44:21,680
0,690
is
是{}内核的代码{}，最后两条指令

1544
00:44:21,940 --> 00:44:23,410
0,450 480,630 630,1260 1260,1380 1380,1470
{} the code that the


1545
00:44:23,410 --> 00:44:25,150
0,390 390,750 750,900 900,1440 1440,1740
kernel {}, the last two


1546
00:44:25,150 --> 00:44:27,910
0,1050 1170,1410 1410,1470 1470,1770 1770,2760
instructions| that the kernel executes
|内核在返回用户空间时执行的。

1547
00:44:27,940 --> 00:44:29,710
0,300 300,660 660,750 750,1020 1020,1770
while returning a user space.|
|

1548
00:44:30,340 --> 00:44:31,690
0,330 330,480 480,660 660,1110 1110,1350
{} And what's happening is
{}现在发生的是它在内核之后做的最后一件事

1549
00:44:31,690 --> 00:44:33,040
0,270 330,540 540,900 900,1230 1230,1350
that the very last thing


1550
00:44:33,040 --> 00:44:34,030
0,120 120,330 330,570 570,630 630,990
it does after the kernel|
|

1551
00:44:34,030 --> 00:44:37,000
0,1170 1380,1830 1830,1920 1920,2190 2190,2970
restores all the user registers
恢复所有用户寄存器，并且它几乎准备好返回到用户空间，

1552
00:44:37,000 --> 00:44:38,530
0,120 120,570 840,1050 1050,1290 1290,1530
and it's just about ready


1553
00:44:38,530 --> 00:44:39,580
0,60 60,330 330,390 390,630 630,1050
to return to user space,|
|

1554
00:44:39,760 --> 00:44:40,750
0,210 210,420 420,600 600,870 870,990
it actually does another one
它实际上又进行了一次这样的掉期交易，

1555
00:44:40,750 --> 00:44:42,460
0,90 90,240 240,1140 1410,1470 1470,1710
of these swaps,| the kernel
|内核被设置为等于陷阱帧，

1556
00:44:42,460 --> 00:44:43,540
0,120 120,390 390,570 570,990 990,1080
is setup {a0 -} to


1557
00:44:43,540 --> 00:44:44,290
0,90 90,300 300,360 360,450 450,750
be equal to the trap


1558
00:44:44,290 --> 00:44:46,960
0,480 990,1470 1470,1860 1860,2190 2190,2670
frame,| {sscratch -} still holds
|{ssccratch-}仍然保存保存的用户a0。

1559
00:44:46,960 --> 00:44:49,340
0,90 90,870 990,1440 1440,2130
the saved user a0.|
|

1560
00:44:49,980 --> 00:44:50,730
0,150 150,210 210,420 420,600 600,750
So the kernel does this
所以内核会进行这种交换，结果是划痕有一个指针

1561
00:44:50,730 --> 00:44:52,290
0,420 420,810 1200,1380 1380,1470 1470,1560
swap which ends up with


1562
00:44:52,290 --> 00:44:53,520
0,150 150,540 540,810 810,900 900,1230
that scratch having a pointer|
|

1563
00:44:53,520 --> 00:44:54,000
0,210
that
{a0-}中的陷阱帧已经接收到，

1564
00:44:54,550 --> 00:44:55,990
0,330 330,690 690,810 810,930 930,1440
trap frame in {a0 -}


1565
00:44:55,990 --> 00:44:57,340
0,270 270,1140
having received,|
|

1566
00:44:57,920 --> 00:44:59,810
0,870 870,990 990,1260 1260,1470 1470,1890
{user,a0} and then this sret
{user，a0}，然后该SRET返回到用户空间，

1567
00:44:59,810 --> 00:45:02,390
0,900 1290,1440 1440,1680 1680,2220 2370,2580
returns to user space,| so
|所以你可能会想，{a0-}怎么会有这样的价值

1568
00:45:02,390 --> 00:45:03,140
0,90 90,210 210,420 420,660 660,750
you may wonder how {a0


1569
00:45:03,140 --> 00:45:04,130
0,390 390,570 570,750 750,840 840,990
-} ever got to have


1570
00:45:04,130 --> 00:45:05,570
0,120 120,570 570,750 750,1020 1020,1440
the value| of the, {}
|的，{}陷阱帧的地址

1571
00:45:06,600 --> 00:45:07,440
0,150 150,390 390,450 450,510 510,840
the address of the trap


1572
00:45:07,440 --> 00:45:09,720
0,600 1080,1380 1380,1590 1590,2070 2070,2280
frame| answer that question is
|回答这个问题是，嗯。

1573
00:45:09,720 --> 00:45:11,200
0,360 540,1230
that, um.|
|

1574
00:45:13,130 --> 00:45:15,050
0,300 300,450 450,1020 1140,1560 1590,1920
We're now looking in {trap.c
我们现在看的是{trap.c--}，

1575
00:45:15,050 --> 00:45:18,470
0,240 240,900 2070,2310 2310,2850 2850,3420
- -},| at this last
|在这最后一个C函数中，它将在输出到用户空间的过程中运行。

1576
00:45:18,470 --> 00:45:20,600
0,420 420,930 930,1080 1080,1680 1800,2130
C function to run on


1577
00:45:20,600 --> 00:45:21,560
0,120 120,660
the way


1578
00:45:21,840 --> 00:45:23,820
0,570 600,750 750,1080 1080,1800
out to user space.|
|

1579
00:45:24,710 --> 00:45:25,730
0,210 210,480 480,660 660,810 810,1020
The last thing this C
这个C函数做的最后一件事是在这里调用这个函数。

1580
00:45:25,730 --> 00:45:27,470
0,360 360,660 660,990 1140,1530 1530,1740
function does is calls this


1581
00:45:27,470 --> 00:45:29,220
0,450 450,1080
function here.|
|

1582
00:45:29,460 --> 00:45:31,590
0,600 1140,1350 1350,1770 1770,2040 2040,2130
Whatever this fn is and
无论此FN是什么，它传递的参数都是陷阱框架和用户页表

1583
00:45:31,590 --> 00:45:33,900
0,150 150,660 660,780 780,1650 2070,2310
the arguments it passes are


1584
00:45:33,900 --> 00:45:35,190
0,150 150,510 510,810 810,1020 1020,1290
the trap frame and the


1585
00:45:35,220 --> 00:45:36,120
0,660
user


1586
00:45:37,210 --> 00:45:39,880
0,360 360,810 1350,1560 1560,2220 2430,2670
page table| and so in
|所以在C代码中，当你调用一个函数时，

1587
00:45:39,880 --> 00:45:41,080
0,240 240,660 660,780 780,990 990,1200
C code, when you call


1588
00:45:41,080 --> 00:45:42,370
0,90 90,600 600,690 690,930 930,1290
a function,| the first argument
|第一个参数进入{a0-}，

1589
00:45:42,370 --> 00:45:44,470
0,210 210,600 600,780 780,1290 1800,2100
goes into {a0 -},| that's
|这基本上就是{a0-}在陷阱帧上保持指针的原因。

1590
00:45:44,470 --> 00:45:46,180
0,360 360,630 630,750 750,1470
basically why {a0 -}


1591
00:45:46,710 --> 00:45:47,400
0,270 270,330 330,570 570,630 630,690
held a pointer at the


1592
00:45:47,400 --> 00:45:48,200
0,300 300,600
trap frame.|
|

1593
00:45:49,120 --> 00:45:50,500
0,120 120,300 300,810 810,960 960,1380
And this function, its value
这个函数，它的值在这里设置为。

1594
00:45:50,500 --> 00:45:51,460
0,90 90,360 360,510 510,840 840,960
is set up here to


1595
00:45:51,460 --> 00:45:52,200
0,450
be.|
|

1596
00:45:52,650 --> 00:45:54,420
0,150 150,360 360,930 930,1380 1380,1770
In that trampoline page towards
在接近末尾的蹦床页面中，我向您展示了代码{}。

1597
00:45:54,420 --> 00:45:55,980
0,150 150,750 930,1170 1170,1470 1470,1560
the end that code I


1598
00:45:55,980 --> 00:45:57,240
0,390 390,600 600,990
showed you {}.|
|

1599
00:45:59,690 --> 00:46:02,080
0,330 330,1050
This code.|
这个代码。|

1600
00:46:02,220 --> 00:46:03,580
0,180 180,840
Is that,
是不是，这是个好答案。

1601
00:46:04,080 --> 00:46:05,360
0,210 210,210 210,360 360,900
that's a good answer.|
|

1602
00:46:06,120 --> 00:46:09,660
0,900 1500,2280 2280,2430 2430,3090 3270,3540
Thanks.| Sorry, I also was
谢谢。|对不起，我也搞不清楚我不确定，

1603
00:46:09,660 --> 00:46:10,980
0,390 390,660 660,960 960,1050 1050,1320
confused about that I was


1604
00:46:11,010 --> 00:46:12,420
0,240 240,750 870,1170 1170,1290 1290,1410
not sure,| so when you
|所以当你开始你的过程时，

1605
00:46:12,420 --> 00:46:13,980
0,420 510,720 720,840 840,1110 1110,1560
start when you start your


1606
00:46:14,010 --> 00:46:15,120
0,840
process,|
|

1607
00:46:15,290 --> 00:46:17,090
0,450 600,1170 1170,1320 1320,1440 1440,1800
and it's good at running
它擅长跑步，然后在某些时候

1608
00:46:17,090 --> 00:46:17,930
0,120 120,240 240,330 330,480 480,840
and then at some point|
|

1609
00:46:17,930 --> 00:46:19,790
0,60 60,600 720,1350 1380,1530 1530,1860
it doesn't equal I guess
我猜这不等于什么

1610
00:46:20,120 --> 00:46:21,000
0,540
or


1611
00:46:21,080 --> 00:46:22,320
0,420 420,600 600,960
something| and then
|那么您是在什么时候调用这个返回函数的呢

1612
00:46:23,390 --> 00:46:25,130
0,420 420,600 600,780 780,1320 1350,1740
when did you call this


1613
00:46:25,130 --> 00:46:27,140
0,390 390,1050 1140,1710 1710,1860 1860,2010
return function| because it should
|因为它应该在eCall之前调用，

1614
00:46:27,140 --> 00:46:28,670
0,210 210,420 420,870 870,1320 1320,1530
have been called before the


1615
00:46:28,670 --> 00:46:29,400
0,480
ecall,|
|

1616
00:46:30,000 --> 00:46:31,620
0,150 150,240 240,720 780,1260 1260,1620
But he didn't return from,
但是他没有回来，{}你之前没有回来，

1617
00:46:32,130 --> 00:46:34,140
0,300 390,870 870,1020 1020,1350 1350,2010
{} you didn't return before,|
|

1618
00:46:34,350 --> 00:46:35,160
0,270 270,420 420,510 510,660 660,810
I I don't know I
我我不知道我不明白你说的{usertrapret--}。

1619
00:46:35,160 --> 00:46:35,940
0,90 90,420 420,510 510,600 600,780
don't understand what you call


1620
00:46:35,940 --> 00:46:38,040
0,450 480,1050 1080,1500 1500,1890
the {usertrapret - -}.|
|

1621
00:46:39,000 --> 00:46:40,380
0,420 450,960 960,1110 1110,1170 1170,1380
Okay, what may be one
好的，这个问题的一个答案可能是

1622
00:46:40,380 --> 00:46:41,640
0,270 270,330 330,510 510,1020 1020,1260
answer to this question is


1623
00:46:41,640 --> 00:46:43,220
0,300 330,630 630,1290
that| the kernel
|内核总是或机器在内核中引导。

1624
00:46:43,650 --> 00:46:46,260
0,1050 1080,1260 1260,1500 1500,1590 1590,2610
always or that the machine


1625
00:46:46,290 --> 00:46:48,450
0,840 840,1260 1440,1620 1620,1710 1710,2160
boots up in the kernel.|
|

1626
00:46:49,850 --> 00:46:51,050
0,390 390,510 510,570 570,810 810,1200
So when the machine starts
因此，当机器在内核中启动时，

1627
00:46:51,050 --> 00:46:53,240
0,60 60,150 150,630 900,1950
in the kernel,| anytime
|任何时候进入用户空间的唯一途径。

1628
00:46:53,650 --> 00:46:54,730
0,240 240,630 630,840 840,930 930,1080
the only way to get


1629
00:46:54,730 --> 00:46:56,360
0,210 210,510 510,1500
into user space.|
|

1630
00:46:56,880 --> 00:46:57,780
0,180 180,240 240,330 330,600 600,900
You know the very first
您知道第一次或从系统调用返回时

1631
00:46:57,780 --> 00:46:59,640
0,540 540,690 690,960 960,1530 1530,1860
time or when returning from


1632
00:46:59,640 --> 00:47:01,740
0,150 150,540 540,1080 1440,1950 1950,2100
a system call| is in
|实际上是执行这个{sret-}指令。

1633
00:47:01,740 --> 00:47:03,450
0,570 600,750 750,1230 1230,1440 1440,1710
fact to execute this {sret


1634
00:47:03,450 --> 00:47:04,480
0,150 150,750
-} instruction.|
|

1635
00:47:05,440 --> 00:47:07,450
0,540 870,1110 1110,1380 1380,1800 1800,2010
That this sret instruction is
这条sret指令就是解决问题的方法

1636
00:47:07,450 --> 00:47:08,260
0,120 120,300 300,450 450,570 570,810
the way| that the {RISC-V
|{RISC-V--}定义为从管理模式转换到用户模式，

1637
00:47:08,260 --> 00:47:10,930
0,540 690,1080 1080,1950 1950,2070 2070,2670
- -} defines to transition


1638
00:47:10,930 --> 00:47:13,210
0,240 240,840 840,1350 1710,1950 1950,2280
from supervisor mode into user


1639
00:47:13,210 --> 00:47:15,880
0,570 1320,1770 1770,1920 1920,2430
mode,| {} and so
|{}因此在任何用户代码执行之前，

1640
00:47:16,070 --> 00:47:17,930
0,1020 1020,1200 1200,1440 1440,1650 1650,1860
before any user code ever


1641
00:47:17,930 --> 00:47:20,080
0,900 1020,1230 1230,1770
executes,| the kernel
|内核执行我在这里展示的代码，

1642
00:47:20,320 --> 00:47:21,490
0,450 450,540 540,750 750,840 840,1170
executes the code I'm showing


1643
00:47:21,490 --> 00:47:23,020
0,120 120,540 540,630 630,1170 1200,1530
you here,| in these these
|在这两个编辑器缓冲区中。

1644
00:47:23,020 --> 00:47:24,580
0,210 210,540 540,1260
two editor buffers.|
|

1645
00:47:24,820 --> 00:47:26,170
0,600 600,840 840,960 960,1110 1110,1350
Let's set up all kinds
让我们设置所有类型的内容，比如ssccratch{stvec-}。

1646
00:47:26,170 --> 00:47:29,170
0,90 90,600 600,1020 1590,2490 2580,3000
of things like sscratch {stvec


1647
00:47:29,170 --> 00:47:30,060
0,450
-}.|
|

1648
00:47:33,200 --> 00:47:34,820
0,360 360,540 540,870 870,1170 1170,1620
Okay I see, thank you.|
好的，我明白了，谢谢。|

1649
00:47:35,270 --> 00:47:36,040
0,390
You're welcome.|
不用谢。|

1650
00:47:36,730 --> 00:47:38,020
0,330 390,510 510,660 660,750 750,1290
{} I have a question,|
{}我有个问题，|

1651
00:47:38,020 --> 00:47:38,740
0,120 120,300 300,450 450,570 570,720
I'm not sure if we
我不确定我们是谈到这个了还是我错过了

1652
00:47:38,740 --> 00:47:40,540
0,330 330,420 420,870 1080,1350 1680,1800
touched on this or I


1653
00:47:40,540 --> 00:47:42,100
0,300 300,480 480,870 1080,1290 1290,1560
missed it,| but {} when
|但是{}当我们在汇编代码中调用eCall指令时，

1654
00:47:42,100 --> 00:47:43,660
0,150 150,480 480,600 600,1020 1020,1560
we call the ecall instruction


1655
00:47:43,660 --> 00:47:45,370
0,90 90,180 180,600 600,960 1560,1710
in the assembly code,| {}
|{}是什么触发蹦床代码启动，

1656
00:47:45,370 --> 00:47:47,110
0,300 300,720 720,780 780,1410 1410,1740
what triggers the trampoline code


1657
00:47:47,110 --> 00:47:48,580
0,60 60,570 660,1020 1170,1320 1320,1470
to start,| like is it
|比如CPU模式是从Supervisor切换过来的吗，对不起是从用户Supervisor切换过来的吗？

1658
00:47:48,580 --> 00:47:50,980
0,90 90,510 510,930 1440,1860 1920,2400
the switch of the CPU


1659
00:47:50,980 --> 00:47:52,990
0,360 360,540 540,1590 1590,1770 1770,2010
mode from supervisor, I'm sorry


1660
00:47:52,990 --> 00:47:54,760
0,210 210,570 570,1260 1260,1440 1440,1770
from user supervisor is something


1661
00:47:54,760 --> 00:47:57,140
0,330 720,1320 1470,2100
else.| Okay, um.|
|好的，嗯。|

1662
00:47:57,990 --> 00:47:59,340
0,300 300,390 390,630 630,750 750,1350
So the code we're executing
所以我们正在执行的代码是这个{eCall-}，

1663
00:47:59,340 --> 00:48:00,860
0,180 180,420 420,600 600,1230
is this {ecall -},|
|

1664
00:48:01,010 --> 00:48:02,270
0,180 180,540 540,990 990,1110 1110,1260
the shell executes it in
外壳在用户空间中执行它

1665
00:48:02,270 --> 00:48:04,040
0,240 240,750 1020,1230 1230,1590 1590,1770
user space| and ecall does
|eCall做了几件事，eCall指令将模式设置为Supervisor。

1666
00:48:04,040 --> 00:48:05,750
0,60 60,330 330,960 1080,1290 1290,1710
a couple things, the ecall


1667
00:48:05,750 --> 00:48:08,000
0,930 1140,1620 1620,1740 1740,2160 2160,2250
instruction sets the mode to


1668
00:48:08,000 --> 00:48:09,120
0,750
supervisor.|
|

1669
00:48:09,400 --> 00:48:12,660
0,600 1230,1470 1470,1890 1890,2610
And the ecall instruction
并且eCall指令{}将程序计数器保存在SERC中

1670
00:48:13,000 --> 00:48:15,040
0,480 510,1140 1140,1230 1230,1590 1590,2040
{} saves the program counter


1671
00:48:15,040 --> 00:48:17,440
0,120 120,960 1320,1890 1890,2070 2070,2400
in sepc| and the ecall
|并且eCall指令将程序计数器设置为等于

1672
00:48:17,440 --> 00:48:19,390
0,630 630,1170 1170,1290 1290,1650 1650,1950
instruction sets the program counter


1673
00:48:19,390 --> 00:48:21,100
0,450 450,1050
equal to|
|

1674
00:48:21,560 --> 00:48:22,970
0,210 210,300 300,660 660,1080 1080,1410
{} the control register called
{}名为{stvec-}的控制寄存器，

1675
00:48:22,970 --> 00:48:25,520
0,420 420,960 1290,1800 1950,2370 2370,2550
{stvec -},| so {stvec -}
|因此，{stvec-}是内核在进入用户空间之前设置的众多内容之一。

1676
00:48:25,520 --> 00:48:26,150
0,90 90,240 240,300 300,360 360,630
is one of the many


1677
00:48:26,150 --> 00:48:27,410
0,300 300,450 450,540 540,900 900,1260
things which the kernel sets


1678
00:48:27,410 --> 00:48:29,060
0,180 180,420 420,690 690,960 960,1650
up before entering user space.|
|

1679
00:48:29,510 --> 00:48:30,360
0,600


1680
00:48:31,750 --> 00:48:32,890
0,180 180,270 270,510 510,870 870,1140
And so here's {stvec -},
这里是{stvec-}，{stvec-}只是内核设置

1681
00:48:32,890 --> 00:48:34,240
0,240 240,420 420,540 540,1200 1230,1350
{stvec -} is just the


1682
00:48:34,240 --> 00:48:35,740
0,240 240,660 660,900 1230,1410 1410,1500
kernel set it| to the
|到蹦床页面的开头

1683
00:48:35,740 --> 00:48:37,600
0,390 390,480 480,540 540,1140 1140,1860
beginning of the trampoline page|
|

1684
00:48:37,630 --> 00:48:38,500
0,150 150,660
that is
这就是这里的地址。

1685
00:48:38,840 --> 00:48:40,200
0,180 180,480 480,1020
this address here.|
|

1686
00:48:40,680 --> 00:48:42,450
0,420 450,690 690,900 900,1230 1230,1770
{} So when ecall happens,
{}所以当eCall发生时，eCall只是将{stvec-}复制到程序计数器中并继续，

1687
00:48:42,450 --> 00:48:44,640
0,330 330,870 1110,1530 1530,1890 1890,2190
ecall just copies {stvec -}


1688
00:48:44,640 --> 00:48:45,690
0,150 150,240 240,540 540,900 900,1050
into the program counter and


1689
00:48:45,690 --> 00:48:48,000
0,630 630,780 780,1290 1860,2040 2040,2310
continues,| but now the program
|但是现在程序计数器正在蹦床页面中执行这个地址。

1690
00:48:48,000 --> 00:48:50,340
0,270 270,390 390,1230 1470,1740 1740,2340
counter is executing this address


1691
00:48:50,340 --> 00:48:51,700
0,90 90,150 150,630 630,1170
in the trampoline page.|
|

1692
00:48:54,500 --> 00:48:55,970
0,390 390,840 840,990 990,1230 1230,1470
That clarifies it, thank you.|
我说清楚了，谢谢。|

1693
00:48:56,990 --> 00:48:57,600
0,330
Okay.|
好吧。|

1694
00:49:00,520 --> 00:49:02,050
0,330 330,570 570,750 750,870 870,1530
I also have a question.|
我还有一个问题。|

1695
00:49:02,620 --> 00:49:05,080
0,630 1320,2250
{} Why,
{}为什么，所以一些寄存器保存在陷阱帧中，

1696
00:49:05,320 --> 00:49:06,730
0,300 300,480 480,630 630,810 810,1410
so some of the registers


1697
00:49:06,730 --> 00:49:08,830
0,300 300,1200 1500,1680 1680,1770 1770,2100
are saved in the trap


1698
00:49:08,830 --> 00:49:11,720
0,630 690,1020 1020,1770 1800,2460
frame,| should not, {}
|不应该，{}也是用户程序可以访问的寄存器，

1699
00:49:11,900 --> 00:49:15,350
0,330 330,1170 1560,2250 2250,3210 3270,3450
are also registers that the


1700
00:49:15,350 --> 00:49:17,030
0,300 300,660 660,810 810,1200 1200,1680
user program had access to,|
|

1701
00:49:17,660 --> 00:49:19,240
0,1110


1702
00:49:19,510 --> 00:49:21,580
0,570 600,870 870,1080 1080,1500 1530,2070
Why, why do we need
为什么，为什么我们要把这个作为内存中的一个新的{}区域

1703
00:49:21,580 --> 00:49:22,740
0,960
to,


1704
00:49:23,190 --> 00:49:24,100
0,660
um,


1705
00:49:24,470 --> 00:49:27,950
0,840 1050,1740 1860,2040 2040,2850 3030,3480
use as a new {}


1706
00:49:27,980 --> 00:49:29,420
0,420 420,540 540,1020 1020,1140 1140,1440
region in memory| and not
|并且不使用程序栈。

1707
00:49:29,420 --> 00:49:32,020
0,210 210,690 810,1440 1440,2370
use the program stack.|
|

1708
00:49:34,660 --> 00:49:36,970
0,510 540,1020 1200,1500 1500,2100 2100,2310
Okay, um, boy, there's maybe
好吧，嗯，伙计，这里可能有两个问题。

1709
00:49:36,970 --> 00:49:38,320
0,180 180,570 570,690 690,900 900,1350
two questions here.| One is,
|一个是，也许我们到底为什么要保存这些寄存器。

1710
00:49:38,940 --> 00:49:39,780
0,420 420,600 600,690 690,750 750,840
maybe why do we have


1711
00:49:39,780 --> 00:49:41,880
0,120 120,1050 1410,1530 1530,2010 2010,2100
to save the registers at


1712
00:49:41,880 --> 00:49:42,680
0,540
all.|
|

1713
00:49:43,700 --> 00:49:44,720
0,420 420,540 540,750 750,930 930,1020
The the reason why the
内核必须保存寄存器的原因

1714
00:49:44,720 --> 00:49:45,500
0,210 210,360 360,480 480,720 720,780
kernel has to save the


1715
00:49:45,500 --> 00:49:47,030
0,660 660,780 780,990 990,1050 1050,1530
registers| is that the kernel
|内核即将运行C代码

1716
00:49:47,090 --> 00:49:48,110
0,270 270,450 450,540 540,750 750,1020
is about to run C


1717
00:49:48,110 --> 00:49:49,320
0,570 570,870
code| that
|它会覆盖那些寄存器

1718
00:49:49,780 --> 00:49:52,630
0,300 300,780 780,1020 1020,1920 2280,2850
it overwrites those registers| {}
|{}如果我们想要正确恢复用户代码，

1719
00:49:52,930 --> 00:49:54,100
0,480 600,780 780,870 870,1020 1020,1170
and if we ever want


1720
00:49:54,100 --> 00:49:55,060
0,90 90,450 450,540 540,750 750,960
to resume the user code


1721
00:49:55,060 --> 00:49:56,170
0,420 420,540 540,690 690,780 780,1110
correctly,| we need to resume
|我们需要恢复它，使其寄存器保持其原始值

1722
00:49:56,170 --> 00:49:57,760
0,120 120,360 360,540 540,1380 1380,1590
it with its registers having


1723
00:49:57,760 --> 00:50:00,130
0,120 120,510 510,1410 1800,2310 2310,2370
their original values| as of
|从eCall开始，让我们执行它，

1724
00:50:00,130 --> 00:50:01,870
0,150 150,330 330,930 960,1200 1230,1740
when the ecall, let's execute


1725
00:50:01,870 --> 00:50:02,890
0,180 390,600 600,690 690,780 780,1020
it,| we have to save
|我们必须保存陷阱帧{}中的所有寄存器，

1726
00:50:02,890 --> 00:50:04,340
0,180 180,270 270,1320
all the registers


1727
00:50:04,850 --> 00:50:06,440
0,150 150,210 210,480 480,1020 1050,1590
in the trap frame {},|
|

1728
00:50:06,980 --> 00:50:08,060
0,180 180,330 330,690 690,960 960,1080
so that later on, we
这样以后，我们就可以恢复它们的所有价值

1729
00:50:08,060 --> 00:50:09,170
0,150 150,660 660,900 900,990 990,1110
can restore all of their


1730
00:50:09,170 --> 00:50:11,640
0,870 1080,1470 1470,1680 1680,2250
values| not just before
|而不仅仅是在恢复用户代码之前。

1731
00:50:11,700 --> 00:50:13,140
0,420 420,510 510,780 780,1230
resuming the user code.|
|

1732
00:50:14,280 --> 00:50:15,030
0,330 330,420 420,570 570,690 690,750
Maybe the other half of
也许你问题的另一半是

1733
00:50:15,030 --> 00:50:16,140
0,120 120,450 450,540 540,750 750,1110
your question is| how come
|为什么它们保存在陷阱框架中，而不是保存在用户堆栈中{}。

1734
00:50:16,140 --> 00:50:17,400
0,150 150,780 810,930 930,990 990,1260
they're saved in the trap


1735
00:50:17,400 --> 00:50:18,270
0,360 360,450 450,690 690,780 780,870
frame and not on the


1736
00:50:18,270 --> 00:50:20,280
0,270 270,870 1140,1770
user stack {}.|
|

1737
00:50:20,580 --> 00:50:21,570
0,300 300,510 510,570 570,870 870,990
The answer to that is
这个问题的答案是，我们甚至不确定用户程序是否有堆栈。

1738
00:50:21,570 --> 00:50:22,560
0,270 270,390 390,570 570,930 930,990
that we're not sure the


1739
00:50:22,560 --> 00:50:23,820
0,210 210,630 630,900 900,1200 1200,1260
user program even has a


1740
00:50:23,820 --> 00:50:24,680
0,600
stack.|
|

1741
00:50:24,820 --> 00:50:26,380
0,240 240,360 360,690 690,1050 1050,1560
There are certainly programming languages
当然，有些编程语言没有堆栈

1742
00:50:26,380 --> 00:50:28,330
0,180 660,990 990,1140 1140,1200 1200,1950
that don't have a stack|
|

1743
00:50:28,810 --> 00:50:30,310
0,420 420,480 480,750 750,1290 1290,1500
and the stack pointer doesn't
堆栈指针没有特别指向任何东西，可能是零值

1744
00:50:30,310 --> 00:50:31,750
0,150 150,210 210,630 630,690 690,1440
point to anything in particular


1745
00:50:31,810 --> 00:50:33,130
0,240 240,360 360,480 480,810 810,1320
might be a value zero|
|

1746
00:50:33,460 --> 00:50:34,900
0,270 270,480 480,840 840,1290 1290,1440
there's also programming languages that
还有一些编程语言，是的，它们有一个堆栈

1747
00:50:34,900 --> 00:50:35,770
0,180 180,300 300,390 390,450 450,870
yeah they have a stack|
|

1748
00:50:35,770 --> 00:50:37,570
0,240 390,870 870,960 960,1200 1200,1800
but it's in a format
但它的格式是，

1749
00:50:37,570 --> 00:50:38,380
0,690
that's,|
|

1750
00:50:38,580 --> 00:50:39,840
0,150 150,240 240,450 450,750 750,1260
you know some weird format,
你知道一些奇怪的格式，内核无法理解，

1751
00:50:39,840 --> 00:50:42,120
0,240 240,510 510,750 750,1620 1980,2280
the kernel doesn't understand,| {}
|{}可能因为编程语言从堆中以小块的形式分配堆栈{}，

1752
00:50:42,120 --> 00:50:43,800
0,180 180,630 630,900 930,1320 1320,1680
maybe because the programming language


1753
00:50:43,800 --> 00:50:46,350
0,570 570,1050 1050,1230 1230,1710 1710,2550
allocates stack in small blocks


1754
00:50:46,780 --> 00:50:47,940
0,300 300,480 480,540 540,1080
{} from the heap,|
|

1755
00:50:48,550 --> 00:50:50,320
0,420 420,480 480,840 840,1290 1290,1770
and the programming language runtime
编程语言运行库理解

1756
00:50:50,320 --> 00:50:52,120
0,510 510,630 630,960 1140,1650 1650,1800
understands| how to use these
|如何将这些小的内存块用作堆栈，

1757
00:50:52,120 --> 00:50:53,200
0,300 300,600 600,660 660,960 960,1080
small blocks of memory as


1758
00:50:53,200 --> 00:50:54,100
0,60 60,450 450,630
a stack,| but
|但是你知道，内核不知道{}。

1759
00:50:54,600 --> 00:50:55,260
0,90 90,150 150,240 240,510 510,660
you know, the kernel has


1760
00:50:55,260 --> 00:50:57,260
0,120 120,600 1290,1740
no idea {}.|
|

1761
00:50:57,610 --> 00:50:59,440
0,300 300,780 1440,1590 1590,1650 1650,1830
So we if we want
因此，如果我们想要能够任意地运行

1762
00:50:59,440 --> 00:50:59,920
0,60 60,120 120,270 270,330 330,480
to be able to run


1763
00:50:59,920 --> 00:51:01,210
0,150 150,210 210,660 660,930 930,1290
sort of arbitrary| user programs
|用多种不同语言编写的用户程序

1764
00:51:01,210 --> 00:51:01,930
0,180 180,240 240,450 450,510 510,720
written in lots of different


1765
00:51:01,930 --> 00:51:03,520
0,570 810,1020 1020,1230 1230,1440 1440,1590
languages| that kernel can't make
|内核不能对用户内存的哪些部分做出任何假设，

1766
00:51:03,520 --> 00:51:06,730
0,210 210,870 870,1320 1620,2640 2640,3210
any assumptions about what parts


1767
00:51:06,730 --> 00:51:08,590
0,360 390,690 690,1200 1200,1320 1320,1860
of user memory,| it's allowed
|它被允许存在或有效，或者被允许读或写。

1768
00:51:08,590 --> 00:51:10,510
0,180 240,1020 1020,1260 1260,1830 1830,1920
to exist or valid or


1769
00:51:10,510 --> 00:51:11,290
0,90 90,420 420,510 510,690 690,780
is allowed to read or


1770
00:51:11,290 --> 00:51:12,080
0,420
write.|
|

1771
00:51:12,220 --> 00:51:13,150
0,330 330,450 450,540 540,780 780,930
And so the kernel has
因此内核必须在某种程度上独立保存它们，存储寄存器。

1772
00:51:13,150 --> 00:51:14,500
0,90 90,180 180,390 390,450 450,1350
to be sort of self-contained


1773
00:51:14,500 --> 00:51:15,640
0,240 240,630 630,780 780,1080 1080,1140
in saving them, storing the


1774
00:51:15,640 --> 00:51:17,080
0,870
registers.|
|

1775
00:51:17,200 --> 00:51:18,550
0,420 420,630 630,810 810,900 900,1350
{} That's why the kernel
{}这就是内核在自己的内存中保存内容的原因

1776
00:51:19,120 --> 00:51:20,590
0,420 420,660 660,810 810,990 990,1470
saves stuff in its own


1777
00:51:20,590 --> 00:51:21,760
0,420 420,510 510,570 570,870 870,1170
memory| and the trap frame
|和陷阱帧，而不是存储在用户存储器中。

1778
00:51:21,760 --> 00:51:22,880
0,270 270,420 420,780
rather than in


1779
00:51:23,040 --> 00:51:23,940
0,270 270,690
user memory.|
|

1780
00:51:24,610 --> 00:51:25,800
0,300 300,570 570,900
Okay, makes sense.|
好的，有道理。|

1781
00:51:29,820 --> 00:51:30,560
0,480
Okay.|
好吧。|

1782
00:51:31,930 --> 00:51:33,120
0,300 300,1020
Anything else.|
还要别的吗。|

1783
00:51:37,400 --> 00:51:38,080
0,480


1784
00:51:40,120 --> 00:51:41,650
0,300 300,420 420,1110 1140,1440 1440,1530
Okay, we're still reading the
好的，我们还在阅读蹦床上代码的{}开头，{}不鼓励。

1785
00:51:41,650 --> 00:51:43,300
0,450 450,780 780,1320
beginning of {}


1786
00:51:44,350 --> 00:51:45,620
0,150 150,210 210,990
of the code


1787
00:51:46,080 --> 00:51:49,780
0,570 840,1800 2040,2370 2370,3450
in trampoline, {} discourages.|
|

1788
00:51:50,370 --> 00:51:51,540
0,570 570,660 660,930 930,1050 1050,1170
Unfortunately we refer to it
不幸的是，我们将其称为User Back和蹦床代码，

1789
00:51:51,540 --> 00:51:55,140
0,420 840,1080 1080,1410 1410,1980 3180,3600
both as user back and


1790
00:51:55,140 --> 00:51:56,760
0,120 120,210 210,720 720,1020 1350,1620
as the trampoline code,| we
|我们刚刚开始执行它

1791
00:51:56,760 --> 00:51:58,320
0,270 270,570 570,1020 1020,1230 1290,1560
barely started executing it| I
|我想我刚刚在这段代码中设置了一个断点{}，

1792
00:51:58,320 --> 00:51:58,920
0,120 120,180 180,420 420,570 570,600
think I just set a


1793
00:51:58,920 --> 00:52:00,120
0,330 330,960
break point


1794
00:52:00,480 --> 00:52:02,320
0,450 450,630 630,810 810,1530
{} in this code,|
|

1795
00:52:02,970 --> 00:52:05,280
0,480 780,1590 1590,1710 1710,1800 1800,2310
{} after all the registers
{}在保存所有寄存器后，

1796
00:52:05,280 --> 00:52:06,540
0,90 90,270 270,900 930,1080 1080,1260
have been saved,| I think
|我想我给这个指令设置了一个断点，

1797
00:52:06,540 --> 00:52:07,560
0,60 60,330 330,720
I set {}


1798
00:52:10,070 --> 00:52:11,060
0,300 300,540 540,720 720,780 780,990
a break point of this


1799
00:52:11,060 --> 00:52:13,970
0,690 1140,1260 1260,1620 1620,2310 2370,2910
instruction,| we'll continue executing skip
|我们将继续执行跳过所有这些保存的所有用户注册的陷阱帧。

1800
00:52:13,970 --> 00:52:14,990
0,210 210,330 330,510 510,930 930,1020
over all these saves of


1801
00:52:14,990 --> 00:52:16,220
0,150 150,270 270,510 510,1140 1140,1230
all the user registers the


1802
00:52:16,220 --> 00:52:18,620
0,270 270,720 1410,1770 1770,1890 1890,2400
trap frame.| Okay and now,
|好的，现在，我们正在执行这条加载指令，

1803
00:52:19,220 --> 00:52:20,960
0,180 180,570 570,720 720,1020 1020,1740
we're executing this load instruction,|
|

1804
00:52:20,960 --> 00:52:23,480
0,180 180,330 330,930 1500,1980 2040,2520
this load instruction is loading
此加载指令正在加载到堆栈指针寄存器

1805
00:52:23,480 --> 00:52:25,430
0,270 270,360 360,810 810,1170 1170,1950
into the stack pointer register|
|

1806
00:52:25,490 --> 00:52:26,360
0,150 150,300 300,420 420,720 720,870
and what is loading as
作为值加载的是第八个插槽。

1807
00:52:26,360 --> 00:52:27,860
0,150 150,810 840,960 960,1200 1200,1500
the value is the eighth


1808
00:52:27,860 --> 00:52:28,960
0,810
slot.|
|

1809
00:52:29,370 --> 00:52:30,810
0,240 240,630 780,1110 1110,1170 1170,1440
In the block of memory
在{a0-}指向的记忆挡路中，

1810
00:52:30,810 --> 00:52:32,310
0,330 330,450 450,630 630,780 780,1500
pointed to by {a0 -},|
|

1811
00:52:32,430 --> 00:52:33,900
0,300 300,660 660,780 780,1080 1080,1470
we remember {a0 -} points,
我们记住{a0-}点，这个陷阱帧到这个虚拟地址的倒数第二页。

1812
00:52:33,900 --> 00:52:36,510
0,300 420,900 900,1380 1800,2100 2100,2610
this trap frame to this


1813
00:52:36,540 --> 00:52:37,940
0,600 600,1230
virtual address


1814
00:52:38,430 --> 00:52:40,040
0,90 90,420 420,750 750,1470
the second last page.|
|

1815
00:52:40,600 --> 00:52:41,590
0,360 360,510 510,570 570,900 900,990
{} And the format of
{}和陷印页面的格式，但陷印框架。

1816
00:52:41,590 --> 00:52:44,830
0,60 60,360 360,1110 2190,2490 2490,3240
the trap page, but the


1817
00:52:44,860 --> 00:52:46,020
0,300 300,930
trap frame.|
|

1818
00:52:46,880 --> 00:52:47,480
0,240 240,300 300,480 480,540 540,600
Here's the front of the
这是陷阱页的首页，

1819
00:52:47,480 --> 00:52:49,400
0,270 270,450 450,780 870,1290 1290,1920
trap page,| my we've conveniently
|我的意思是，我们已经方便地将每个字段标记为其偏移量(以字节为单位)，

1820
00:52:49,400 --> 00:52:51,830
0,420 420,1110 1230,1860 1860,2010 2010,2430
labeled each field with its


1821
00:52:51,830 --> 00:52:53,750
0,510 510,630 630,1260 1620,1770 1770,1920
offset in bytes,| so that
|所以这意味着他们在第八节装车，

1822
00:52:53,750 --> 00:52:54,590
0,210 210,300 300,570 570,660 660,840
means they load in the


1823
00:52:54,890 --> 00:52:55,780
0,660
eighth,|
|

1824
00:52:56,280 --> 00:52:57,360
0,450 450,510 510,660 660,870 870,1080
starting at the eighth byte
从陷阱帧的第八个字节开始意味着我们正在加载内核堆栈指针

1825
00:52:57,360 --> 00:52:58,290
0,60 60,120 120,420 420,690 690,930
of the trap frame means


1826
00:52:58,290 --> 00:53:00,390
0,60 60,570 1200,1320 1320,1740 1740,2100
we're loading the kernel stack


1827
00:53:00,390 --> 00:53:01,620
0,330 330,540 870,1020 1020,1110 1110,1230
pointer| and one of the
|内核在进入用户空间之前设置的事情之一，

1828
00:53:01,620 --> 00:53:02,970
0,240 240,300 300,570 570,990 990,1350
things the kernel sets up


1829
00:53:02,970 --> 00:53:04,710
0,600 600,870 870,1110 1110,1650 1650,1740
before entering user spaces,| it
|它将陷阱帧中的这个槽设置为等于此进程的{}内核堆栈，

1830
00:53:04,710 --> 00:53:06,060
0,420 420,630 630,1140 1140,1290 1290,1350
sets this slot in the


1831
00:53:06,060 --> 00:53:07,620
0,330 330,780 990,1230 1230,1320 1320,1560
trap frame to be equal


1832
00:53:07,620 --> 00:53:09,260
0,90 90,390 390,1440
to this process's


1833
00:53:10,030 --> 00:53:12,100
0,330 330,660 660,1170 1590,1890 1890,2070
{} kernel stack,| so this
|所以这里的这条指令是{}初始化堆栈指针

1834
00:53:12,100 --> 00:53:13,690
0,510 510,660 660,780 780,1200 1200,1590
instruction here is doing is


1835
00:53:13,690 --> 00:53:16,810
0,360 870,1740 1740,2070 2370,2760 2760,3120
{} initializing the stack pointer|
|

1836
00:53:16,810 --> 00:53:17,890
0,120 120,330 330,420 420,510 510,1080
to point to the top
要指向此进程的内核堆栈的顶部，

1837
00:53:17,920 --> 00:53:20,140
0,150 150,420 420,1260 1440,1740 1740,2220
of this process's kernel stack,|
|

1838
00:53:20,380 --> 00:53:20,980
0,150 150,330 330,390 390,510 510,600
is part of what you
是运行用户代码所需执行的操作的一部分。

1839
00:53:20,980 --> 00:53:21,760
0,150 150,240 240,450 450,540 540,780
need to do in order


1840
00:53:21,760 --> 00:53:22,340
0,300
to


1841
00:53:22,880 --> 00:53:24,160
0,150 150,330 330,540 540,1020
to run user code.|
|

1842
00:53:25,930 --> 00:53:27,400
0,390 390,540 540,780 780,1140 1140,1470
Alright, so what's left,| within
好的，那么剩下的，|在到达蹦床代码末尾的几条指令内{}。

1843
00:53:27,400 --> 00:53:28,810
0,60 60,360 360,1020 1020,1170 1170,1410
a few instructions of getting


1844
00:53:28,810 --> 00:53:29,260
0,90 90,180 180,300 300,360 360,450
to the end of the


1845
00:53:29,260 --> 00:53:31,700
0,510 510,1020 1470,2190
trampoline code {}.|
|

1846
00:53:32,220 --> 00:53:34,050
0,120 120,360 360,720 720,1230 1230,1830
We loaded the stack pointer,|
我们加载了堆栈指针，|

1847
00:53:34,650 --> 00:53:35,520
0,210 210,360 360,480 480,630 630,870
so maybe I can print
因此，也许我可以为您打印堆栈指针{请参见}。

1848
00:53:35,520 --> 00:53:36,510
0,90 90,360 360,630 630,840 840,990
the stack pointer for you


1849
00:53:36,540 --> 00:53:37,340
0,510
{and,see}.|
|

1850
00:53:39,160 --> 00:53:40,180
0,210 210,360 360,840
Yeah, this is.|
是的，我是。|

1851
00:53:40,770 --> 00:53:41,700
0,660
Um.
恩。{}好的，这就是内核，

1852
00:53:46,800 --> 00:53:49,410
0,570 570,1110 2040,2310 2310,2490 2490,2610
{} All right, well this


1853
00:53:49,410 --> 00:53:51,150
0,120 120,390 420,1110 1110,1260 1260,1740
is the kernels,| this processes
|此进程的内核堆栈位于高内存上

1854
00:53:51,150 --> 00:53:52,080
0,240 240,600 600,750 750,870 870,930
kernel stack is up on


1855
00:53:52,080 --> 00:53:53,790
0,270 270,840 840,1320 1350,1560 1560,1710
high memory| because {xv6 -
|因为{xv6--}特别对待核[性]，

1856
00:53:53,790 --> 00:53:54,780
0,720
-}


1857
00:53:55,260 --> 00:53:56,220
0,690


1858
00:53:56,830 --> 00:53:59,080
0,420 420,630 630,1380 1470,2100 2100,2250
treat kernel [sex] especially,| so
|这样您就可以在每个内核堆栈下放置一个保护页。

1859
00:53:59,080 --> 00:53:59,770
0,120 120,180 180,300 300,570 570,690
that you can put a


1860
00:53:59,770 --> 00:54:01,120
0,420 420,1020
guard page


1861
00:54:01,240 --> 00:54:02,640
0,240 240,420 420,690 690,1230
under each kernel stack.|
|

1862
00:54:03,810 --> 00:54:05,190
0,360 360,570 570,720 720,900 900,1380
Um, okay, so this load
嗯，好的，那么这个装入tp的东西，

1863
00:54:05,190 --> 00:54:07,470
0,240 240,1080 1680,1890 1890,2130 2130,2280
into tp,| it turns out
|原来因为{RISC-V-}没有直接的路，

1864
00:54:07,470 --> 00:54:10,230
0,390 480,1740 1920,2160 2160,2280 2280,2760
that because there's no direct


1865
00:54:10,230 --> 00:54:11,310
0,150 150,270 270,570 570,960 960,1080
way in {RISC-V -}| to
|为了找出您在多个内核中的哪个内核上运行，

1866
00:54:11,310 --> 00:54:13,110
0,270 270,360 360,600 600,1380 1410,1800
figure out what core which


1867
00:54:13,110 --> 00:54:14,640
0,120 120,390 720,1110 1110,1410 1410,1530
of the multiple cores you're


1868
00:54:14,640 --> 00:54:17,040
0,300 300,690 990,1470 1470,1740 1740,2400
running on,| {} xv6 actually
|{}xv6实际上将称为中心ID的核心编号保存在tp寄存器中。

1869
00:54:17,100 --> 00:54:20,100
0,1470 1470,1620 1620,2100 2100,2700 2730,3000
keeps the core number called


1870
00:54:20,100 --> 00:54:21,630
0,60 60,420 420,990 1110,1440 1440,1530
the heart id in the


1871
00:54:21,630 --> 00:54:23,340
0,570 570,1200 1290,1470 1470,1620 1620,1710
tp register| and this is
|这在内核中的很多地方都有使用，

1872
00:54:23,340 --> 00:54:24,030
0,270 270,330 330,390 390,600 600,690
used in a bunch of


1873
00:54:24,030 --> 00:54:25,200
0,390 390,450 450,540 540,1020 1020,1170
places in the kernel,| for
|举个例子，{}它是机器的一部分，

1874
00:54:25,200 --> 00:54:27,330
0,510 840,1500 1530,1770 1770,2070 2070,2130
example, {} it's part of


1875
00:54:27,330 --> 00:54:29,140
0,90 90,750 750,1230
the machinery,| for
|让内核代码找出当前在该内核上运行的进程。

1876
00:54:29,300 --> 00:54:30,290
0,420 420,600 600,660 660,900 900,990
kernel code to figure out


1877
00:54:30,290 --> 00:54:33,290
0,330 330,1080 1080,1230 1230,1920 2340,3000
what process is currently running


1878
00:54:33,290 --> 00:54:34,400
0,120 120,300 300,780
on that core.|
|

1879
00:54:35,220 --> 00:54:37,320
0,540 1500,1800 1800,1890 1890,1980 1980,2100
{} OK, and if we
{}好的，如果我们执行这个，希望是{}tp或运行在内核0上，这是有意义的

1880
00:54:37,320 --> 00:54:39,900
0,450 450,1020 1020,1710 1710,2220
execute this, hopefully, {}


1881
00:54:41,070 --> 00:54:42,630
0,690 780,1020 1020,1230 1230,1350 1350,1560
tp or running on core


1882
00:54:42,630 --> 00:54:43,530
0,300 300,390 390,480 480,660 660,900
zero and that makes sense|
|

1883
00:54:43,530 --> 00:54:45,120
0,270 270,450 450,1110 1140,1410 1410,1590
because I've configured {QEMU -
因为我已经将{qemu--}配置为

1884
00:54:45,120 --> 00:54:46,380
0,120 120,240 240,540 540,900 900,1260
-} to| only give one
|仅将一个内核分配给xv6或实际上在内核零上运行。

1885
00:54:46,380 --> 00:54:48,900
0,600 1020,1260 1260,2010 2010,2160 2160,2520
core to xv6 or indeed


1886
00:54:48,900 --> 00:54:50,500
0,180 180,270 270,510 510,1050
running on core zero.|
|

1887
00:54:51,830 --> 00:54:54,830
0,540 990,1560 1560,1920 1920,2370 2550,3000
Um, this next thing, {}
嗯，下一件事{}是加载地址，

1888
00:54:55,100 --> 00:54:58,010
0,240 240,870 870,1140 1140,1950 2160,2910
is loading the address of,|
|

1889
00:54:59,620 --> 00:55:01,330
0,330 360,780 780,1110 1170,1620 1620,1710
{} actually the loaded to
{}实际加载到{t0-}。

1890
00:55:01,330 --> 00:55:02,640
0,210 210,960
{t0 -}.|
|

1891
00:55:04,790 --> 00:55:05,860
0,810


1892
00:55:06,180 --> 00:55:09,030
0,270 270,480 480,1050 1050,1890 2310,2850
I think loaded a pointer
我认为加载了指向我们要执行的第一个C函数的指针

1893
00:55:09,030 --> 00:55:12,330
0,750 1980,2310 2310,2670 2670,2880 2880,3300
to the first C function


1894
00:55:12,330 --> 00:55:13,260
0,90 90,180 180,300 300,360 360,930
that we're going to execute|
|

1895
00:55:13,290 --> 00:55:14,370
0,180 180,390 390,630 630,720 720,1080
which is {user -} trap,|
这就是{user-}陷阱，|

1896
00:55:14,370 --> 00:55:14,940
0,120 120,240 240,360 360,480 480,570
so we use that in
所以我们在几条指令中使用它，只需跳到用户陷阱C函数。

1897
00:55:14,940 --> 00:55:16,740
0,60 60,210 210,870 870,1110 1110,1800
a few instructions just jump


1898
00:55:17,370 --> 00:55:18,600
0,210 210,360 360,660 660,960 960,1230
to the user trap C


1899
00:55:18,600 --> 00:55:19,440
0,570
function.|
|

1900
00:55:19,870 --> 00:55:22,060
0,600 1020,1500 1500,1680 1680,1860 1860,2190
{} Load into {t1 -}
{}加载到{T1-}这里，

1901
00:55:22,060 --> 00:55:24,430
0,570 1200,1530 1530,1770 1770,2220 2220,2370
here,| {} is loading the
|{}正在加载{}内核页表的地址，

1902
00:55:24,430 --> 00:55:26,140
0,510 510,660 660,900 900,1410
address of the {}


1903
00:55:27,000 --> 00:55:28,830
0,450 450,750 750,1140 1590,1680 1680,1830
kernel page table,| you can
|您可以打印，即将切换页表，

1904
00:55:28,830 --> 00:55:29,740
0,540
print,


1905
00:55:30,440 --> 00:55:32,060
0,420 420,510 510,780 780,1050 1050,1620
about to switch page tables,|
|

1906
00:55:32,660 --> 00:55:35,060
0,390 390,660 660,1230 1290,1800 1890,2400
turns out the, {} this
原来，{}这个东西，其实不是字面上的内核页表地址，

1907
00:55:35,060 --> 00:55:36,080
0,120 120,360 360,540 540,720 720,1020
thing, it was not actually


1908
00:55:36,080 --> 00:55:37,310
0,420 420,540 540,930 930,1050 1050,1230
literally the address of the


1909
00:55:37,310 --> 00:55:38,330
0,240 240,450 450,720 720,870 870,1020
kernel page table,| it's the
|这是你需要放入{satp-}的东西，

1910
00:55:38,330 --> 00:55:39,170
0,240 240,390 390,570 570,660 660,840
thing you need to put


1911
00:55:39,170 --> 00:55:41,820
0,210 210,570 570,1110 1680,2400
into {satp -},| {}
|{}，即{}具有内核页表的地址，

1912
00:55:42,100 --> 00:55:43,720
0,180 180,330 330,720 1260,1530 1530,1620
which is, {} has the


1913
00:55:43,720 --> 00:55:44,590
0,300 300,360 360,420 420,660 660,870
address of the kernel page


1914
00:55:44,590 --> 00:55:45,880
0,240 240,360 360,720 720,1200 1200,1290
table,| but shifted around with
|但是在设置了一些额外的标志位的情况下进行了移位。

1915
00:55:45,880 --> 00:55:47,140
0,180 180,480 480,720 720,900 900,1260
some extra flag bit set.|
|

1916
00:55:47,760 --> 00:55:48,510
0,270 270,360 360,570 570,660 660,750
But as soon as the
但只要执行{csrrw-}指令

1917
00:55:48,510 --> 00:55:50,970
0,420 420,1050 1290,1860 1860,2310 2310,2460
{csrrw -} instruction executes| will
|将从用户页表、内核页表

1918
00:55:50,970 --> 00:55:52,530
0,420 420,750 750,1080 1080,1320 1320,1560
switch page tables from the


1919
00:55:52,530 --> 00:55:53,670
0,270 270,480 480,780 780,870 870,1140
user page table, the kernel


1920
00:55:53,670 --> 00:55:54,930
0,240 240,540 750,1020 1020,1080 1080,1260
page table,| let me just
|现在让我通过查看当前页表来强调这一点。

1921
00:55:54,930 --> 00:55:55,980
0,510 510,660 660,720 720,990 990,1050
reinforce that by looking at


1922
00:55:55,980 --> 00:55:57,780
0,90 90,360 360,600 600,1110 1320,1800
the current page table right


1923
00:55:57,780 --> 00:55:58,600
0,480
now.|
|

1924
00:55:58,660 --> 00:55:59,890
0,330 330,450 450,690 690,1110 1110,1230
{} We're still executing with
{}我们仍在使用这个非常小的用户页表执行

1925
00:55:59,890 --> 00:56:01,540
0,150 150,360 360,960 1110,1410 1410,1650
this very small user page


1926
00:56:01,540 --> 00:56:03,250
0,510 810,1050 1050,1200 1200,1470 1470,1710
table| and run step by
|并逐步运行以执行加载和{satp-}。

1927
00:56:03,250 --> 00:56:05,650
0,120 120,1020 1170,1680 1710,2220 2220,2400
to execute the load and


1928
00:56:05,650 --> 00:56:06,660
0,360 360,750
{satp -}.|
|

1929
00:56:08,770 --> 00:56:09,700
0,660
Um.|
恩。|

1930
00:56:11,140 --> 00:56:11,920
0,210 210,300 300,450 450,690 690,780
And we'll look again at
我们将再次查看内核页面，

1931
00:56:11,920 --> 00:56:12,730
0,60 60,270 270,480 480,690 690,810
the kernel page,| now we're
|现在我们在{}完全不同的页表中，

1932
00:56:12,730 --> 00:56:14,080
0,90 90,120 120,600 600,1080 1080,1350
at {} completely different page


1933
00:56:14,080 --> 00:56:14,860
0,270 270,420 420,600 600,690 690,780
table right,| this is the
|这是内核页表，

1934
00:56:14,860 --> 00:56:16,720
0,270 270,540 540,930 1470,1770 1770,1860
kernel page table,| then you
|然后你可以看到所有这些不同的内存区域

1935
00:56:16,720 --> 00:56:17,560
0,90 90,210 210,390 390,570 570,840
can see all these different


1936
00:56:17,560 --> 00:56:19,360
0,510 510,630 630,1140 1140,1260 1260,1800
regions of memory| and device
|和设备控制寄存器等，

1937
00:56:19,360 --> 00:56:20,980
0,390 390,840 840,930 930,1380 1410,1620
control registers and whatnot that


1938
00:56:20,980 --> 00:56:22,360
0,270 270,570
the,| {}
|{}{}内核设置在自己的{}大内核页表中，

1939
00:56:22,640 --> 00:56:24,230
0,330 330,930 930,1260 1260,1470 1470,1590
{} kernel sets up in


1940
00:56:24,230 --> 00:56:26,180
0,210 210,840 1050,1320 1320,1650 1650,1950
its own {} big kernel


1941
00:56:26,180 --> 00:56:27,860
0,240 240,480 690,870 870,1080 1110,1680
page table,| so we successfully
|所以我们成功地交换了页表。

1942
00:56:27,860 --> 00:56:29,280
0,300 300,600 600,1230
switch page tables.|
|

1943
00:56:29,740 --> 00:56:30,700
0,300 300,420 420,540 540,750 750,960
And now the kernel page
现在是内核页表，

1944
00:56:30,700 --> 00:56:32,200
0,300 750,990 990,1200 1200,1350 1350,1500
tables,| so we're in pretty
|所以在这一点上我们处于相当好的状态，

1945
00:56:32,200 --> 00:56:33,010
0,150 150,360 360,420 420,600 600,810
good [shape] at this point,|
|

1946
00:56:33,010 --> 00:56:34,090
0,180 180,270 270,360 360,420 420,1080
because we have a stack,|
因为我们有一堆，|

1947
00:56:34,480 --> 00:56:35,740
0,270 270,690 690,810 810,1020 1050,1260
{} we have the kernel
{}我们有内核页表，

1948
00:56:35,740 --> 00:56:36,760
0,270 270,570 570,690 690,840 840,1020
page table,| we can read
|我们可以读到我的内核数据已经准备好在内核中执行C代码了，

1949
00:56:36,760 --> 00:56:38,260
0,120 120,420 420,810 840,990 990,1500
my kernel data were really


1950
00:56:38,500 --> 00:56:40,150
0,420 420,630 630,960 960,1260 1260,1650
pretty much ready to {}


1951
00:56:40,990 --> 00:56:42,130
0,540 540,750 750,1020 1020,1080 1080,1140
execute C code in the


1952
00:56:42,130 --> 00:56:44,830
0,450 1080,1440 1440,1800 1800,2160 2190,2700
kernel,| one puzzle though is,
|但有一个问题是，为什么我们不是坠毁了，

1953
00:56:45,770 --> 00:56:47,330
0,390 390,960 960,1140 1140,1320 1320,1560
how come, we didn't just


1954
00:56:47,330 --> 00:56:49,160
0,870 1230,1530 1530,1620 1620,1740 1740,1830
crash,| after all we are
|毕竟我们是在内存中的某个地方执行，

1955
00:56:49,160 --> 00:56:51,170
0,420 420,780 780,870 870,1620 1650,2010
executing somewhere in memory,| and
|并且程序计数器保存虚拟地址，

1956
00:56:51,170 --> 00:56:52,130
0,90 90,420 420,690 690,900 900,960
the program counter holds a


1957
00:56:52,130 --> 00:56:54,530
0,330 330,1140 1260,1650 1680,1830 1830,2400
virtual address,| if we switch
|如果我们交换页表，

1958
00:56:54,530 --> 00:56:56,080
0,510 510,1410
page tables,|
|

1959
00:56:56,170 --> 00:56:58,030
0,300 300,570 570,900 960,1560 1590,1860
why doesn't that {} just
为什么{}不会造成一些随机的垃圾或者什么都不造成呢

1960
00:56:58,030 --> 00:56:59,410
0,240 240,600 600,900 900,1320 1320,1380
cause some random garbage or


1961
00:56:59,410 --> 00:57:01,330
0,300 300,390 390,900 1410,1800 1800,1920
nothing at all| to be
|要映射到新页表中

1962
00:57:01,330 --> 00:57:02,470
0,360 360,450 450,540 540,780 780,1140
mapped in the new page


1963
00:57:02,470 --> 00:57:04,030
0,570 600,1170 1170,1320 1320,1440 1440,1560
table| underfoot where we were
|在我们行刑的脚下。

1964
00:57:04,030 --> 00:57:04,980
0,690
executing.|
|

1965
00:57:05,470 --> 00:57:06,670
0,180 180,330 330,810 810,900 900,1200
We're not crashing or actually
我们没有崩溃，也没有实际执行这些指令。

1966
00:57:06,670 --> 00:57:08,240
0,330 330,540 540,1320
execute these instructions.|
|

1967
00:57:08,660 --> 00:57:10,220
0,570 660,900 900,1200 1200,1350 1350,1560
{} Any guesses what's going
{}有谁能猜到发生了什么事吗？

1968
00:57:10,220 --> 00:57:10,800
0,270
on.|
|

1969
00:57:13,280 --> 00:57:15,140
0,210 210,510 510,660 660,1230 1560,1860
I think it's because, oh
我想是因为，哦，对不起，

1970
00:57:15,140 --> 00:57:16,980
0,540
sorry,|
|

1971
00:57:17,040 --> 00:57:18,900
0,480 570,960 960,1170 1170,1620 1620,1860
{} because we're still in
{}因为我们还在蹦床代码里

1972
00:57:18,900 --> 00:57:20,250
0,120 120,810 810,1140 1140,1260 1260,1350
the trampoline code| and the
|并且蹦床被映射到用户和内核的相同虚拟地址。

1973
00:57:20,250 --> 00:57:22,560
0,690 690,1050 1050,1890 1890,2010 2010,2310
trampoline is mapped the same


1974
00:57:22,560 --> 00:57:25,050
0,420 420,930 930,1410 1410,2160 2160,2490
virtual address both user and


1975
00:57:25,050 --> 00:57:25,960
0,660
kernel.|
|

1976
00:57:26,260 --> 00:57:28,570
0,210 210,630 630,1200 1560,2010 2010,2310
That's absolutely correct| and say
那是绝对正确的|告诉你，我不知道你是否还记得

1977
00:57:28,630 --> 00:57:29,410
0,510 510,540 540,660 660,720 720,780
you, I don't know if


1978
00:57:29,410 --> 00:57:30,550
0,120 120,540 540,720 720,840 840,1140
you remember| what was mapped
|这里映射的是{user-}页面表中的内容，

1979
00:57:30,550 --> 00:57:31,090
0,150 150,210 210,270 270,480 480,540
here in the {user -}


1980
00:57:31,090 --> 00:57:32,800
0,270 270,630 750,1050 1050,1230 1230,1710
page table,| but this mapping
|但是内核页表末尾的这个映射

1981
00:57:32,800 --> 00:57:33,640
0,450 450,540 540,630 630,750 750,840
here at the end of


1982
00:57:33,640 --> 00:57:34,960
0,90 90,450 450,750 750,1140 1170,1320
the kernel page table| is
|在相同的地方是完全相同的映射，

1983
00:57:34,960 --> 00:57:36,550
0,690 690,780 780,1050 1050,1440 1440,1590
exactly the same mapping in


1984
00:57:36,550 --> 00:57:38,680
0,90 90,450 450,1140 1530,1890 1890,2130
the same place,| {} as
|{}与蹦床贴图一样

1985
00:57:38,680 --> 00:57:40,580
0,420 420,510 510,1020 1020,1590
as the trampoline mapping|
|

1986
00:57:40,840 --> 00:57:41,350
0,150 150,240 240,390 390,450 450,510
at the end of the
在用户页表的末尾，

1987
00:57:41,350 --> 00:57:42,790
0,300 300,570 570,990 1020,1350 1350,1440
user page table,| all the
|所有其他映射都不同。

1988
00:57:42,790 --> 00:57:44,120
0,120 120,510 510,540 540,960
other mappings are different.|
|

1989
00:57:44,480 --> 00:57:45,470
0,300 300,480 480,780 780,900 900,990
But this mapping is the
但是这个映射是一样的，

1990
00:57:45,470 --> 00:57:46,430
0,270 270,420 420,510 510,600 600,960
same,| this is the mapping
|这是保存正在执行的指令的映射，

1991
00:57:46,430 --> 00:57:47,510
0,120 120,330 330,390 390,960 960,1080
that holds the instructions were


1992
00:57:47,510 --> 00:57:48,920
0,540 540,660 660,960 960,1110 1110,1410
executing,| and because it didn't
|因为当我们交换页表时它没有改变，

1993
00:57:48,920 --> 00:57:50,300
0,600 600,780 780,870 870,1110 1110,1380
change when we switch page


1994
00:57:50,300 --> 00:57:53,600
0,570 1500,1800 1800,2070 2070,2490 2490,3300
tables,| we actually continue executing
|我们实际上继续执行，我们仍然在执行相同的指令序列，并且没有崩溃。

1995
00:57:53,600 --> 00:57:54,770
0,150 150,240 240,540 540,1050 1050,1170
and we're still executing the


1996
00:57:54,770 --> 00:57:57,410
0,330 330,690 690,780 780,1680 2070,2640
same sequence of instructions and


1997
00:57:57,410 --> 00:57:58,280
0,180 180,630
not crashing.|
|

1998
00:57:59,140 --> 00:58:01,000
0,330 1080,1440 1440,1530 1530,1740 1740,1860
{} And so that's the
{}这就是蹦床页面的特殊之处，

1999
00:58:01,000 --> 00:58:02,230
0,210 210,330 330,750 750,1020 1020,1230
sort of special thing about


2000
00:58:02,230 --> 00:58:04,510
0,60 60,600 600,1320 1350,1560 1560,2280
the trampoline page,| it's mapped
|它在用户{}页表和内核页表中都有映射

2001
00:58:05,070 --> 00:58:06,780
0,300 300,390 390,450 450,1050 1170,1710
both in the user {}


2002
00:58:07,500 --> 00:58:10,290
0,270 270,660 660,1200 2220,2580 2580,2790
page tables and kernel page


2003
00:58:10,290 --> 00:58:11,490
0,390 660,840 840,900 900,1110 1110,1200
table| and the reason it's
|它被称为蹦床页的原因是，

2004
00:58:11,490 --> 00:58:13,680
0,240 240,300 300,900 900,1620 1710,2190
called a trampoline pages,| because
|因为你可以在上面弹跳

2005
00:58:13,680 --> 00:58:14,910
0,120 120,300 300,420 420,1020 1020,1230
you sort of bounce on


2006
00:58:14,910 --> 00:58:16,710
0,210 900,1380 1380,1440 1440,1620 1620,1800
it| on the way from
|在从用户空间到内核空间的路上。

2007
00:58:16,710 --> 00:58:18,960
0,300 300,960 960,1050 1050,1440 1590,2250
user space to kernel space.|
|

2008
00:58:20,760 --> 00:58:22,290
0,270 270,420 420,660 660,1290 1290,1530
And the next instruction, this
下一条指令，这个JR将要弹跳

2009
00:58:22,290 --> 00:58:23,820
0,450 450,540 540,720 720,840 840,1530
jr were about to bounce|
|

2010
00:58:24,030 --> 00:58:25,740
0,570 570,720 720,780 780,870 870,1710
right out of the trampoline
直接走出蹦床{}进入内核C代码。

2011
00:58:26,100 --> 00:58:27,900
0,240 240,720 750,1050 1050,1260 1260,1800
{} into kernel C code.|
|

2012
00:58:28,430 --> 00:58:29,330
0,240 240,390 390,570 570,660 660,900
And see where we're going,
看看我们要去哪里，JR就像跳到一个子程序，

2013
00:58:29,330 --> 00:58:31,310
0,600 600,690 690,960 960,1170 1500,1980
jr is just like jump


2014
00:58:31,310 --> 00:58:33,050
0,90 90,150 150,1050 1140,1620 1620,1740
to a subroutine,| subroutine this
|由寄存器{t0-}指向的子例程，

2015
00:58:33,050 --> 00:58:34,310
0,330 330,450 450,630 630,1080 1080,1260
point to by register {t0


2016
00:58:34,310 --> 00:58:35,720
0,630
-},|
|

2017
00:58:35,930 --> 00:58:37,070
0,450 450,720 720,810 810,990 990,1140
print t0 to see where
打印t0以查看我们要去哪里。

2018
00:58:37,070 --> 00:58:37,900
0,90 90,540
we're going.|
|

2019
00:58:39,420 --> 00:58:41,200
0,630 630,1470
Um, {maybe,we'll}
嗯，{也许，我们}在那里打印说明。

2020
00:58:42,460 --> 00:58:44,440
0,330 330,1200 1200,1710
print instructions there.|
|

2021
00:58:46,520 --> 00:58:47,390
0,330 330,480 480,690 690,750 750,870
Okay, so these are the
好的，这些就是我们要跳到那里的指令

2022
00:58:47,390 --> 00:58:48,470
0,480 480,540 540,720 720,810 810,1080
instructions were about to jump


2023
00:58:48,470 --> 00:58:50,390
0,270 270,540 540,660 660,930 1350,1920
to there| in the beginning
|在称为用户陷阱的功能开始时，

2024
00:58:50,390 --> 00:58:51,500
0,90 90,150 150,540 540,810 810,1110
of the function called user


2025
00:58:51,500 --> 00:58:52,380
0,600
trap,|
|

2026
00:58:53,560 --> 00:58:55,840
0,360 360,420 420,750 750,1200 1710,2280
user {} trap is just
用户{}陷阱只是一个C函数，

2027
00:58:55,840 --> 00:58:57,360
0,270 270,540 540,1260
a C function,|
|

2028
00:58:57,480 --> 00:58:59,200
0,420 420,690 690,900 900,1350
{defined,in} {trap.c - -}.|
{已定义，在}{trap.c--}中。|

2029
00:59:01,040 --> 00:59:03,020
0,300 300,540 540,1020 1170,1440 1440,1980
Here's user trap, we're about
这是用户陷阱，我们将从汇编代码跳到使用陷阱

2030
00:59:03,020 --> 00:59:04,160
0,150 150,420 420,570 570,960 960,1140
to jump from assembly code


2031
00:59:04,160 --> 00:59:04,940
0,90 90,240 240,300 300,570 570,780
to use a trap| with
|利用具有内核页表的堆栈，

2032
00:59:04,940 --> 00:59:06,050
0,60 60,570 570,780 780,840 840,1110
a stack with a kernel


2033
00:59:06,050 --> 00:59:07,790
0,270 270,720 1170,1470 1470,1680 1680,1740
page table,| {} let me
|{}让我实际执行指令。

2034
00:59:07,790 --> 00:59:09,080
0,300 300,660 660,990
actually do the


2035
00:59:09,890 --> 00:59:11,640
0,600 600,660 660,1470
execute the instruction.|
|

2036
00:59:12,040 --> 00:59:13,600
0,240 240,360 360,510 510,870 870,1560
And I'm gonna turn on,
我要打开，打开C代码的显示

2037
00:59:14,710 --> 00:59:15,800
0,840


2038
00:59:17,520 --> 00:59:18,570
0,270 270,360 360,720 720,810 810,1050
turn on display of C


2039
00:59:18,570 --> 00:59:20,640
0,420 420,840 840,1290 1290,1500 1500,2070
code| and gdb now rescuing
|GDB现在正在拯救C代码。

2040
00:59:20,640 --> 00:59:24,330
0,450 450,900 3180,3420 3420,3570 3570,3690
C code.| Okay, so now
|好的，所以现在我们处在一个更加理智的世界里，

2041
00:59:24,330 --> 00:59:24,780
0,90 90,150 150,180 180,330 330,450
we're in a much more


2042
00:59:24,780 --> 00:59:26,160
0,300 300,660 660,810 810,990 990,1380
sane world,| we're just executing
|我们只是在执行C代码，

2043
00:59:26,160 --> 00:59:27,630
0,240 240,720 960,1230 1230,1410 1410,1470
C code,| {} should be
|{}应该更容易理解一点

2044
00:59:27,630 --> 00:59:28,290
0,30 30,180 180,330 330,570 570,660
a little bit easier to


2045
00:59:28,290 --> 00:59:31,140
0,660 930,1110 1110,1410 1800,2190 2730,2850
understand| and there's {} you
|还有{}你知道的，仍然要花一些时间读写各种有趣的控制寄存器，

2046
00:59:31,140 --> 00:59:32,370
0,180 180,390 390,660 660,810 810,1230
know still spend some time


2047
00:59:32,370 --> 00:59:34,380
0,240 240,330 330,990 990,1560 1560,2010
reading and writing various interesting


2048
00:59:34,560 --> 00:59:37,060
0,420 420,990 990,1230 1770,2190
control registers,| but {}
|但是，{}希望环境比赛道框架中的神秘程度要低得多。

2049
00:59:37,630 --> 00:59:39,190
0,150 150,630 630,1080 1170,1530 1530,1560
the environment is hopefully a


2050
00:59:39,190 --> 00:59:40,780
0,120 120,300 300,570 570,1290 1290,1590
good deal less mysterious than


2051
00:59:40,780 --> 00:59:41,500
0,90 90,330 330,390 390,450 450,720
it was in the track


2052
00:59:41,500 --> 00:59:42,060
0,270
frame.|
|

2053
00:59:43,420 --> 00:59:45,420
0,600
Alright.|
好的。|

2054
00:59:48,140 --> 00:59:49,790
0,270 270,690 690,1050 1050,1200 1200,1650
Any function, any any questions
在这一点上，任何函数，任何问题。

2055
00:59:49,790 --> 00:59:50,640
0,60 60,210 210,510
at this point.|
|

2056
00:59:53,890 --> 00:59:55,510
0,390 390,810 810,1050 1050,1170 1170,1620
Um, I have a question,|
嗯，我有个问题，|

2057
00:59:55,510 --> 00:59:56,740
0,270 270,600 600,750 750,1080 1080,1230
why didn't we see with
为什么我们没有看到gdb，{}eCall是做什么的，

2058
00:59:56,740 --> 00:59:59,860
0,120 120,960 1320,2010 2070,2490 2520,3120
the gdb, {} what ecall


2059
00:59:59,860 --> 01:00:00,720
0,600
does,|
|

2060
01:00:03,010 --> 01:00:04,450
0,210 210,630 690,1050 1050,1140 1140,1440
I I maybe I missed
我，我，也许我错过了，

2061
01:00:04,450 --> 01:00:06,580
0,180 180,450 450,1140 1320,1530 1530,2130
it,| but I I think
|但是我，我想我们已经直接跳到蹦床上了。

2062
01:00:06,580 --> 01:00:08,530
0,450 450,810 810,1410 1410,1770 1770,1950
we've jumped directly into the


2063
01:00:08,530 --> 01:00:09,580
0,750
trampoline.|
|

2064
01:00:11,930 --> 01:00:15,400
0,690 1260,1860 1860,2400 2550,3300
Ecall ecall did jump,
eCall eCall确实跳了，eCall做的是{}，

2065
01:00:16,290 --> 01:00:19,560
0,240 270,810 810,1800 1920,2730 2760,3270
what ecall does is {},|
|

2066
01:00:19,740 --> 01:00:21,870
0,450 630,1110 1110,1410 1410,1890 1890,2130
just switch just changes the
只需切换即可将模式位更改为Supervisor

2067
01:00:21,870 --> 01:00:23,340
0,270 270,420 420,510 510,630 630,1470
mode bit to be supervisor|
|

2068
01:00:23,820 --> 01:00:25,020
0,810
and
而eCall设置得很深，

2069
01:00:25,220 --> 01:00:26,160
0,690


2070
01:00:26,960 --> 01:00:28,640
0,420 420,1050 1050,1440
ecall sets deep,|
|

2071
01:00:29,450 --> 01:00:30,830
0,330 330,660 660,1170 1170,1290 1290,1380
program counter register to be
程序计数器寄存器等于发生的任何情况，

2072
01:00:30,830 --> 01:00:32,840
0,330 330,540 540,900 930,1410 1410,2010
equal to the whatever happens,|
|

2073
01:00:32,870 --> 01:00:34,010
0,330 330,420 420,780 780,1080 1080,1140
whatever the kernel happened to
内核恰好存储在{stvec-}中的任何内容。

2074
01:00:34,010 --> 01:00:36,200
0,390 390,510 510,900 900,1380
store in {stvec -}.|
|

2075
01:00:36,400 --> 01:00:37,930
0,180 180,420 420,660 660,1320 1350,1530
I'll store this value I
我将存储刚刚打印的值{0x3ffffff000-}

2076
01:00:37,930 --> 01:00:39,370
0,210 210,450 450,780 780,1230 1230,1440
just printed {0x3ffffff000 - -


2077
01:00:39,370 --> 01:00:40,570
0,240 240,630 630,810 810,1080 1110,1200
- -}| which is the
|这是蹦床页面内核存储的开始。

2078
01:00:40,570 --> 01:00:41,980
0,270 270,330 330,390 390,840 840,1410
beginning of the trampoline page


2079
01:00:42,490 --> 01:00:43,660
0,330 330,1020
kernel stores.|
|

2080
01:00:43,740 --> 01:00:45,090
0,240 240,630 630,720 720,1110 1110,1350
This number in {stvec -}
在进入用户空间之前在{stvec-}中输入该号码，

2081
01:00:45,090 --> 01:00:47,520
0,300 300,570 570,840 840,1590 2040,2430
before entering user space,| so
|因此，Recall所处的位置就是{stvec-}的程序计数器。

2082
01:00:47,520 --> 01:00:49,440
0,330 360,870 870,1710 1710,1830 1830,1920
where recall goes that is


2083
01:00:49,440 --> 01:00:50,520
0,180 180,330 330,510 510,600 600,1080
where it's just the program


2084
01:00:50,790 --> 01:00:53,700
0,420 420,840 1320,2190 2190,2640
counter to {stvec -}.|
|

2085
01:00:53,820 --> 01:00:54,750
0,180 180,300 300,390 390,840 840,930
Which is the beginning of
这是蹦床页面的开始。

2086
01:00:54,750 --> 01:00:56,040
0,60 60,540 540,1110
the trampoline page.|
|

2087
01:00:58,560 --> 01:01:00,000
0,390 390,570 570,660 660,1140
That answer your question.|
这回答了你的问题。|

2088
01:01:02,240 --> 01:01:05,640
0,720 900,1110 1110,1350 1350,1680
Yes I think so.|
是的我想是的。|

2089
01:01:08,610 --> 01:01:09,570
0,270 270,450 450,600 600,780 780,960
Okay, so now we're in
好的，现在我们在{}用户中，{sertrap-}实际上就像一个蹦床页面

2090
01:01:09,570 --> 01:01:12,510
0,420 450,990 1020,2190 2190,2670 2670,2940
{} user, {sertrap -} are


2091
01:01:12,510 --> 01:01:13,980
0,270 270,540 540,840 900,990 990,1470
actually just like a trampoline


2092
01:01:13,980 --> 01:01:15,800
0,390 390,840 960,1320
page| and {}
|和{}就像蹦床页面上的一些不同种类的陷阱，

2093
01:01:16,580 --> 01:01:18,230
0,690 690,780 780,840 840,1230 1230,1650
just like the trampoline page


2094
01:01:18,230 --> 01:01:19,850
0,720 720,780 780,1110 1110,1260 1260,1620
for a number of different


2095
01:01:19,850 --> 01:01:21,110
0,330 330,390 390,780 780,900 900,1260
kinds of traps,| there system
|有系统调用，也有被零除的例外

2096
01:01:21,110 --> 01:01:23,000
0,570 570,750 750,1380 1380,1530 1530,1890
calls there's exceptions like dividing


2097
01:01:23,000 --> 01:01:24,440
0,150 150,780 780,900 900,1200 1200,1440
by zero| or using a
|或使用{unmap-}虚拟地址

2098
01:01:24,470 --> 01:01:26,360
0,180 180,660 660,960 960,1470 1680,1890
{unmapped -} virtual address| and
|有一台设备中断了

2099
01:01:26,360 --> 01:01:27,560
0,210 210,300 300,720 720,1080 1080,1200
there's a device interrupts| and
|他们都来到这里

2100
01:01:27,560 --> 01:01:29,210
0,90 90,270 270,450 450,900 1170,1650
they all come here| and
|因此{user-}陷阱可以保存和恢复一些硬件状态，

2101
01:01:29,210 --> 01:01:29,940
0,300
so


2102
01:01:30,520 --> 01:01:31,360
0,270 270,330 330,600 600,780 780,840
{user -} trap sort of


2103
01:01:31,360 --> 01:01:33,310
0,390 390,480 480,1110 1110,1560 1590,1950
saves and restores some hardware


2104
01:01:33,310 --> 01:01:34,240
0,240 240,360 360,480 480,720 720,930
state,| but it also needs
|但它也需要审视国家对陷阱原因的看法

2105
01:01:34,240 --> 01:01:35,560
0,210 240,690 690,810 810,900 900,1320
to look at the state


2106
01:01:35,560 --> 01:01:37,840
0,180 180,720 870,1740 2040,2190 2190,2280
at the cause of the


2107
01:01:37,840 --> 01:01:39,610
0,630 660,900 900,1140 1140,1410 1530,1770
trap| to figure out what
|弄清楚如何处理它{}。

2108
01:01:39,610 --> 01:01:41,410
0,90 90,270 270,450 450,780 1230,1800
to do with it {}.|
|

2109
01:01:42,220 --> 01:01:42,940
0,210 210,330 330,420 420,540 540,720
And so we're gonna see
所以当我们在用户陷阱中执行时，我们会看到这两种情况，

2110
01:01:42,940 --> 01:01:44,140
0,210 210,510 510,600 600,750 750,1200
both things as we execute


2111
01:01:44,140 --> 01:01:46,480
0,420 420,780 780,1110 1110,1560 1740,2340
along in user trap,| let
|让我运行一下{user-}陷阱，

2112
01:01:46,480 --> 01:01:47,220
0,60 60,510
me just


2113
01:01:47,290 --> 01:01:48,300
0,690


2114
01:01:49,470 --> 01:01:50,730
0,300 300,600 600,810 810,870 870,1260
run stuff {user -} trap,|
|

2115
01:01:50,730 --> 01:01:53,160
0,180 180,480 1680,2040 2040,2190 2190,2430
let's see, {} the first
让我们看看，{}它在这里做的第一件事是

2116
01:01:53,160 --> 01:01:53,970
0,90 90,180 180,390 390,660 660,810
thing it does here is


2117
01:01:53,970 --> 01:01:56,220
0,270 360,690 810,1500 1500,1740 1740,2250
that| it changes that {stvec
|它改变{stvec-}寄存器，

2118
01:01:56,220 --> 01:01:58,680
0,240 240,990 1170,1860 1920,2100 2100,2460
-} register,| {} it turns
|{}原来{xv6-}处理陷阱的方式不同

2119
01:01:58,680 --> 01:01:59,800
0,120 120,300 300,720
out that the


2120
01:02:00,490 --> 01:02:02,080
0,180 180,600 600,900 900,1200 1200,1590
the way {xv6 -} handles


2121
01:02:02,080 --> 01:02:03,970
0,600 720,1020 1020,1470 1470,1830 1830,1890
traps is different| depending on
|取决于它们是来自用户空间还是来自内核

2122
01:02:03,970 --> 01:02:04,930
0,180 180,330 330,480 480,660 660,960
whether they come from user


2123
01:02:04,930 --> 01:02:06,310
0,540 540,690 690,840 840,900 900,1380
space or from the kernel|
|

2124
01:02:06,640 --> 01:02:07,780
0,240 240,450 450,720 720,840 840,1140
and we've only been talking
我们只讨论了如果用户空间发生陷阱会发生什么，

2125
01:02:07,780 --> 01:02:08,590
0,210 210,360 360,660 660,750 750,810
about what happens if a


2126
01:02:08,590 --> 01:02:10,810
0,540 750,1230 1230,1410 1410,1680 1680,2220
trap occurs from user space,|
|

2127
01:02:10,960 --> 01:02:12,580
0,240 240,270 270,600 600,960 1170,1620
there's a quite different sequence
事件的顺序完全不同，

2128
01:02:12,580 --> 01:02:14,620
0,90 90,780 1170,1590 1590,1740 1740,2040
of events,| {} for traps
|{}对于内核中发生的来自内核的陷阱，

2129
01:02:14,620 --> 01:02:15,670
0,90 90,240 240,390 390,480 480,1050
that come from the kernel


2130
01:02:15,940 --> 01:02:16,990
0,240 240,510 510,840 840,960 960,1050
that occur while in the


2131
01:02:16,990 --> 01:02:18,100
0,270 270,510 510,810 810,990 990,1110
kernel,| because after all, for
|因为毕竟，比如说内核，

2132
01:02:18,100 --> 01:02:19,860
0,450 690,900 900,1440
example the kernel,|
|

2133
01:02:20,120 --> 01:02:20,900
0,60 60,180 180,480 480,720 720,780
I was already using the
我已经在使用内核页表了，

2134
01:02:20,900 --> 01:02:23,330
0,270 270,570 570,1050 1140,1590 2070,2430
kernel page table,| a trap
|当您在内核中时会发生陷阱，您已经有了内核页表，

2135
01:02:23,330 --> 01:02:24,560
0,720 810,990 990,1110 1110,1170 1170,1230
occurs while you're in the


2136
01:02:24,560 --> 01:02:25,460
0,270 270,360 360,570 570,750 750,900
kernel, you already have the


2137
01:02:25,460 --> 01:02:26,360
0,240 240,450 450,720 720,870 870,900
kernel page tables,| there's a
|有一大堆事情是不一定要发生的

2138
01:02:26,360 --> 01:02:27,050
0,210 210,360 360,420 420,600 600,690
whole bunch of stuff that


2139
01:02:27,050 --> 01:02:28,820
0,240 240,420 420,510 510,960 1380,1770
doesn't have to happen| if
|如果陷阱在内核中发生，

2140
01:02:28,820 --> 01:02:30,500
0,60 60,510 810,1230 1230,1590 1590,1680
the trap occurred while in


2141
01:02:30,500 --> 01:02:32,870
0,90 90,510 1020,1320 1320,1500 1500,2370
the kernel,| {} so before
|{}所以在深入了解内核代码之前，

2142
01:02:32,900 --> 01:02:33,830
0,240 240,420 420,780 780,870 870,930
getting much further in the


2143
01:02:33,830 --> 01:02:35,780
0,270 270,750 900,1170 1170,1560 1560,1950
kernel code,| we change {stvec
|我们将{stvec-}更改为指向此{kernelvec-}

2144
01:02:35,780 --> 01:02:36,830
0,450 450,570 570,840 840,900 900,1050
-} to point to this


2145
01:02:36,830 --> 01:02:37,910
0,330 330,540 540,750 750,870 870,1080
{kernelvec -}| which is the
|它是内核陷阱处理程序，

2146
01:02:37,940 --> 01:02:40,370
0,540 600,1020 1020,1680 1770,2340 2340,2430
kernel trap handler,| rather than
|而不是用户陷阱处理程序。

2147
01:02:40,370 --> 01:02:41,520
0,60 60,330 330,570 570,870
the user trap handler.|
|

2148
01:02:43,250 --> 01:02:46,040
0,540 1110,2040 2040,2190 2190,2520 2520,2790
We need for various reasons,|
出于各种原因我们需要，|

2149
01:02:46,040 --> 01:02:46,670
0,90 90,210 210,300 300,540 540,630
we need to figure out
我们需要找出我们正在运行的进程

2150
01:02:46,670 --> 01:02:48,170
0,210 210,660 660,780 780,1230 1410,1500
what process we're running| and
|我们通过调用这个{myproc-}函数来实现这一点

2151
01:02:48,170 --> 01:02:48,920
0,120 120,210 210,360 360,480 480,750
we do that by calling


2152
01:02:48,920 --> 01:02:50,690
0,120 120,360 360,720 720,1200 1650,1770
this {myproc -} function| and
|并且{myproc-}实际上查看由当前核心号、心脏ID

2153
01:02:50,690 --> 01:02:51,650
0,150 150,390 390,660 660,870 870,960
{myproc -} actually looks at


2154
01:02:51,650 --> 01:02:53,060
0,150 150,540 540,1110 1110,1230 1230,1410
an array indexed by the


2155
01:02:53,060 --> 01:02:55,940
0,570 660,1170 1170,1620 1920,2310 2310,2880
current core number, heart id,|
|

2156
01:02:56,180 --> 01:02:57,050
0,210 210,270 270,540 540,660 660,870
do you remember we put
你还记得我们投入了{}tp。

2157
01:02:57,050 --> 01:02:59,180
0,240 270,300 510,1440
in {} tp.|
|

2158
01:02:59,300 --> 01:03:00,950
0,540 900,1110 1110,1230 1230,1380 1380,1650
Um, that's how my part
嗯，这就是我的部分如何计算出当前正在运行的进程。

2159
01:03:00,950 --> 01:03:01,940
0,240 240,330 330,510 510,900 900,990
figures out what process is


2160
01:03:01,940 --> 01:03:02,920
0,330 330,690
currently running.|
|

2161
01:03:07,150 --> 01:03:08,470
0,240 240,450 450,540 540,1140 1140,1320
We need to save that
我们需要拯救那笔救命稻草

2162
01:03:08,470 --> 01:03:10,240
0,360 360,870 900,1410 1410,1650 1650,1770
save| user program counter is
|用户程序计数器还在{Sepc-}中的{}中，

2163
01:03:10,240 --> 01:03:12,670
0,270 270,630 630,1020 1020,1620 1980,2430
still sitting there in {}


2164
01:03:13,660 --> 01:03:16,240
0,180 180,780 780,1230 1290,1860 2130,2580
in {sepc -},| but because
|但是因为当我们在内核中时可能发生的一件事是

2165
01:03:16,240 --> 01:03:17,200
0,150 150,270 270,450 450,600 600,960
one of things that could


2166
01:03:17,200 --> 01:03:18,340
0,600 600,900 900,990 990,1050 1050,1140
happen while we're in the


2167
01:03:18,340 --> 01:03:19,600
0,330 330,480 480,600 600,720 720,1260
kernel is| that we might
|我们可能会切换到另一个过程

2168
01:03:19,600 --> 01:03:21,640
0,450 450,570 570,840 840,1740 1800,2040
switch to another process| and
|而另一个进程可能进入该进程用户空间

2169
01:03:21,640 --> 01:03:23,020
0,150 150,360 360,810 810,1110
that other process might


2170
01:03:23,250 --> 01:03:24,930
0,180 180,600 630,870 870,1380 1380,1680
go into that process user


2171
01:03:24,930 --> 01:03:27,270
0,780 990,1290 1290,1530 1560,1830 1830,2340
space| and that other process
|而另一个进程可能会进行系统调用，

2172
01:03:27,270 --> 01:03:28,040
0,510
might


2173
01:03:28,420 --> 01:03:29,350
0,210 210,240 240,570 570,750 750,930
make a system call,| which
|这使得{Sepc-}被重写，

2174
01:03:29,350 --> 01:03:30,850
0,630 660,990 990,1290 1290,1380 1380,1500
causes {sepc -} to be


2175
01:03:30,850 --> 01:03:32,680
0,540 630,960 960,1140 1140,1380 1380,1830
overwritten,| we have to save
|我们必须保存我们的{Sepc-}和与此过程相关的一些记忆，

2176
01:03:32,710 --> 01:03:35,800
0,630 630,1110 1110,1560 1770,2730 2850,3090
our {sepc -} and some


2177
01:03:35,800 --> 01:03:37,690
0,330 330,810 810,960 960,1140 1140,1890
memories associated with this process,|
|

2178
01:03:37,720 --> 01:03:38,830
0,150 150,210 210,420 420,570 570,1110
so it doesn't get overwritten|
这样它就不会被覆盖|

2179
01:03:39,190 --> 01:03:40,930
0,420 420,930 1110,1440 1440,1590 1590,1740
and yet we use this
但是我们用这个陷阱帧来拯救EPC

2180
01:03:40,930 --> 01:03:43,060
0,300 300,750 750,1020 1050,1590 1590,2130
trap frame to save epc|
|

2181
01:03:43,060 --> 01:03:43,690
0,120 120,270 270,390 390,570 570,630
as well as lots of
还有很多其他的东西，

2182
01:03:43,690 --> 01:03:46,000
0,180 180,660 1080,1560 1680,2100 2100,2310
other stuff,| {} anyway that's
|{}不管怎样，这就是当前代码行正在做的事情。

2183
01:03:46,000 --> 01:03:46,700
0,90 90,570
with this


2184
01:03:47,390 --> 01:03:48,170
0,270 270,450 450,510 510,690 690,780
current line of code is


2185
01:03:48,170 --> 01:03:50,540
0,360 1350,1650 1650,1860 1860,2010 2010,2370
doing.| The next thing happens,
|接下来的事情发生了，我们需要弄清楚，{}我们为什么来这里，

2186
01:03:50,540 --> 01:03:53,300
0,120 120,390 390,1080 1530,2220 2220,2760
we need to figure out,


2187
01:03:56,120 --> 01:03:57,590
0,390 390,690 690,810 810,1140 1140,1470
{} why we came here,|
|

2188
01:03:57,770 --> 01:03:59,270
0,330 330,660 660,1260 1260,1380 1380,1500
the {scause -}, the {RISC-V
{原因-}、{RISC-V-}{原因-}寄存器

2189
01:03:59,270 --> 01:04:01,190
0,330 330,540 540,900 900,1500 1680,1920
-} {scause -} register| has
|根据此陷阱发生的原因，具有不同的数字。

2190
01:04:01,190 --> 01:04:02,300
0,60 60,330 330,600 600,990 990,1110
a different number depending on


2191
01:04:02,300 --> 01:04:04,820
0,390 390,600 600,900 900,1560
why this trap occurred.|
|

2192
01:04:05,340 --> 01:04:06,720
0,300 300,450 450,630 630,690 690,1380
{} Some kind of exception
{}系统调用与设备中断之间的某种异常，

2193
01:04:06,930 --> 01:04:08,640
0,450 450,870 870,1110 1110,1410 1410,1710
versus system call versus device


2194
01:04:08,640 --> 01:04:11,040
0,450 510,1110 1110,1380 1380,2010 2100,2400
interrupt,| value eight means we're
|值8表示我们在这里，我们因为系统调用而陷入陷阱。

2195
01:04:11,040 --> 01:04:12,090
0,450 450,540 540,720 720,750 750,1050
here we took a trap


2196
01:04:12,090 --> 01:04:13,170
0,300 300,360 360,420 420,720 720,1080
because of a system call.|
|

2197
01:04:13,630 --> 01:04:14,700
0,660


2198
01:04:15,430 --> 01:04:17,920
0,390 390,1080 1620,1920 1920,2280 2280,2490
Hopefully, indeed {scause -} eight
希望确实有八个{因为-}它确实有八个{}在这里，因为一个系统调用，

2199
01:04:17,920 --> 01:04:19,090
0,90 90,270 270,390 390,630 630,1170
it does have eight {}


2200
01:04:19,300 --> 01:04:20,290
0,270 270,390 390,600 600,690 690,990
were here because a system


2201
01:04:20,290 --> 01:04:21,880
0,300 810,1230 1260,1410 1410,1470 1470,1590
call,| {} so we're gonna
|{}所以我们将执行此语句。

2202
01:04:21,880 --> 01:04:23,940
0,360 360,870 930,1800
execute this statement.|
|

2203
01:04:24,770 --> 01:04:26,660
0,720 990,1500 1500,1590 1590,1740 1740,1890
{} First thing is if
{}第一件事是，如果某个其他进程被此进程终止，

2204
01:04:26,660 --> 01:04:28,100
0,330 330,660 660,1080 1080,1200 1200,1440
some other process is killed


2205
01:04:28,100 --> 01:04:29,000
0,150 150,570 570,660 660,780 780,900
this process,| we don't want
|我们不想继续，但shell{}并非如此。

2206
01:04:29,000 --> 01:04:30,350
0,60 60,570 570,960 960,1200 1200,1350
to continue but that's not


2207
01:04:30,350 --> 01:04:33,320
0,60 60,300 300,540 540,1080 2430,2970
the case for shell {}.|
|

2208
01:04:33,940 --> 01:04:34,930
0,150 150,480 480,660 660,840 840,990
It turns out that the
原来{RISC-V-}存储在{Sepc-}中的程序计数器

2209
01:04:34,930 --> 01:04:37,450
0,300 300,1080 1380,1800 1860,2190 2190,2520
{RISC-V -} the program counter


2210
01:04:37,450 --> 01:04:39,220
0,120 120,360 360,1050 1050,1230 1230,1770
that gets stored in {sepc


2211
01:04:39,220 --> 01:04:41,320
0,660 750,1290 1440,1590 1590,1950 1950,2100
-}| is the address of
|是导致陷阱的指令的地址。

2212
01:04:41,320 --> 01:04:43,750
0,90 90,930 1050,1380 1380,2340 2340,2430
the instruction that caused the


2213
01:04:43,750 --> 01:04:44,540
0,690
trap.|
|

2214
01:04:45,410 --> 01:04:46,550
0,180 180,390 390,540 540,1050 1050,1140
But when we resume we
但是当我们恢复时，我们想要在{eCall-}之后的下一条指令继续，

2215
01:04:46,550 --> 01:04:47,540
0,210 210,270 270,690 690,840 840,990
want to resume at the


2216
01:04:47,540 --> 01:04:49,760
0,420 420,1050 1140,1860 1890,2040 2040,2220
next instruction after the {ecall


2217
01:04:49,760 --> 01:04:51,740
0,450 840,1050 1050,1380 1380,1590 1710,1980
-},| so therefore we this
|因此，我们将此代码持久化需要返回{}的调用。

2218
01:04:51,740 --> 01:04:53,660
0,660 660,1260 1260,1590 1590,1740 1740,1920
code persistent calls which need


2219
01:04:53,660 --> 01:04:55,600
0,90 90,720 780,1470
to return {}.|
|

2220
01:04:56,080 --> 01:04:57,550
0,300 300,600 600,1140 1140,1320 1320,1470
We add four to the
我们将保存的用户程序计数器加4，

2221
01:04:57,550 --> 01:04:59,620
0,840 900,1170 1170,1470 1470,1890 1890,2070
saved user program counter,| so
|这样我们就可以在下一条指令中继续

2222
01:04:59,620 --> 01:05:00,860
0,120 120,510
that we


2223
01:05:00,910 --> 01:05:02,290
0,420 420,480 480,570 570,870 870,1380
resume in the next instruction|
|

2224
01:05:02,290 --> 01:05:03,760
0,120 120,300 300,480 480,720 720,1470
and don't just {re-execute -}
不要只是{重新执行-}电子呼叫。

2225
01:05:03,940 --> 01:05:05,240
0,180 180,540 540,1050
the {} ecall.|
|

2226
01:05:08,140 --> 01:05:10,240
0,480 480,1050 1110,1560 1560,1770 1770,2100
Alright next, turns out that
好的，接下来，{xv6--}启用中断

2227
01:05:10,450 --> 01:05:13,000
0,300 300,450 450,1050 1170,1980 1980,2550
{xv6 - -} enables interrupts|
|

2228
01:05:13,000 --> 01:05:14,680
0,300 300,690 690,1020 1020,1410 1410,1680
while handling system calls just
在处理系统调用时，仅中断

2229
01:05:14,680 --> 01:05:16,930
0,120 120,840 1170,1530 1710,1920 1920,2250
that interrupts| can be served
|可以更快地提供服务某些系统调用需要很长时间{}。

2230
01:05:16,930 --> 01:05:18,550
0,660 750,990 990,1290 1290,1500 1500,1620
faster some system calls take


2231
01:05:18,550 --> 01:05:20,500
0,60 60,180 180,240 240,720 1260,1950
a lot of time {}.|
|

2232
01:05:21,190 --> 01:05:22,900
0,570 570,930 930,1050 1050,1380 1380,1710
{} Interrupts are always turned
{}中断始终由{RISC-V-}陷阱硬件关闭，

2233
01:05:22,900 --> 01:05:24,670
0,600 660,900 900,1170 1170,1410 1410,1770
off by the {RISC-V -}


2234
01:05:24,670 --> 01:05:27,040
0,360 360,960 1530,1980 2130,2280 2280,2370
trap hardware,| {} and so
|{}，因此我们必须在这一点上显式地重新打开它们。

2235
01:05:27,040 --> 01:05:28,360
0,90 90,180 180,270 270,1050 1080,1320
we have to explicitly turn


2236
01:05:28,360 --> 01:05:29,050
0,90 90,330 330,450 450,540 540,690
them back on at this


2237
01:05:29,050 --> 01:05:29,700
0,330
point.|
|

2238
01:05:30,250 --> 01:05:31,000
0,330 330,390 390,570 570,660 660,750
And the next thing that
接下来发生的事情是我们调用这个{syscall-}函数，

2239
01:05:31,000 --> 01:05:33,280
0,660 1710,1860 1860,1950 1950,2100 2100,2280
happens is we call this


2240
01:05:33,280 --> 01:05:34,480
0,210 210,420 420,840 840,930 930,1200
{syscall -} function,| the job
|{syscall-}的作业刚刚输入在{syscall.c--}中定义的{}。

2241
01:05:34,480 --> 01:05:35,660
0,90 90,330 330,870
of {syscall -}


2242
01:05:36,080 --> 01:05:40,160
0,330 330,690 1350,1950 3090,3690 3690,4080
just entering {} defined in


2243
01:05:40,520 --> 01:05:42,440
0,270 270,390 390,570 570,930
just {syscall.c - -}.|
|

2244
01:05:42,820 --> 01:05:43,840
0,150 150,270 270,660 720,960 960,1020
Here we are what it
这就是它所做的，它查找系统呼叫号

2245
01:05:43,840 --> 01:05:44,560
0,150 150,270 270,360 360,570 570,720
does, is it looks up


2246
01:05:44,560 --> 01:05:45,940
0,90 90,450 450,690 690,1140 1140,1380
the system call number| in
|在页面顶部的这个{}个系统调用表中，

2247
01:05:45,940 --> 01:05:47,260
0,390 390,960
this {}


2248
01:05:47,670 --> 01:05:49,170
0,300 300,660 660,750 750,1110 1110,1500
big table of system calls


2249
01:05:49,170 --> 01:05:50,160
0,420 450,600 600,690 690,930 930,990
about at the top of


2250
01:05:50,160 --> 01:05:53,220
0,90 90,690 1590,2190 2430,2670 2670,3060
the page,| if you remember
|如果您还记得shell编写函数

2251
01:05:53,220 --> 01:05:55,230
0,120 120,780 780,1110 1110,1620 1620,2010
the shells write function| set
|将寄存器{A7-}设置为{}系统调用号即16进行写入，

2252
01:05:55,500 --> 01:05:57,240
0,450 480,720 720,1410 1440,1560 1560,1740
register {a7 -} to {}


2253
01:05:57,240 --> 01:05:58,650
0,90 90,390 390,600 600,900 900,1410
the system call number namely


2254
01:05:58,680 --> 01:06:00,990
0,720 720,900 900,1320 1590,2130 2160,2310
sixteen for write,| {} so
|{}那么{syscall-}的作用是检索保存的{A7-}

2255
01:06:00,990 --> 01:06:01,860
0,120 120,300 300,480 480,690 690,870
what {syscall -} does is


2256
01:06:01,860 --> 01:06:03,780
0,150 150,930 930,1050 1050,1710 1710,1920
it retrieves the saved {a7


2257
01:06:03,780 --> 01:06:05,760
0,600 780,1080 1080,1200 1200,1560 1560,1980
-}| that was saved away
|被蹦床密码保存在陷阱框里的东西，

2258
01:06:05,760 --> 01:06:06,930
0,90 90,150 150,540 540,1020 1050,1170
in the trap frame by


2259
01:06:06,930 --> 01:06:08,420
0,90 90,660 660,1200
the trampoline code,|
|

2260
01:06:09,230 --> 01:06:11,210
0,690 1050,1410 1410,1680 1680,1890 1890,1980
{} and use that to
{}，并使用它来索引此指向函数的指针表

2261
01:06:11,210 --> 01:06:12,860
0,480 480,600 600,750 750,1290 1290,1650
index into this table of


2262
01:06:13,390 --> 01:06:15,070
0,510 510,600 600,1080 1080,1230 1230,1680
pointers to functions| that implement
|来实现每个系统调用。

2263
01:06:15,070 --> 01:06:17,200
0,150 150,510 510,900
each system call.|
|

2264
01:06:17,420 --> 01:06:20,570
0,660 1380,1500 1500,1800 2010,2970 2970,3150
So we're gonna [fish] this
所以我们现在要[钓鱼]这个数字来打印数字，

2265
01:06:20,570 --> 01:06:22,700
0,750 840,1050 1050,1260 1260,1620 1620,2130
number gonna print num now,|
|

2266
01:06:22,790 --> 01:06:24,740
0,300 300,630 810,1320 1320,1560 1560,1950
that's the saved seven indeed
这就是被拯救的7个人，实际上是16个人

2267
01:06:24,740 --> 01:06:27,350
0,900 1020,1290 1290,1620 1620,2310 2400,2610
sixteen| the same sixteen the
|和贝壳原来放在那里的16个一样。

2268
01:06:27,350 --> 01:06:29,580
0,270 270,630 630,870 870,1260
shell originally put there.|
|

2269
01:06:30,530 --> 01:06:31,520
0,720
Um.|
恩。|

2270
01:06:32,610 --> 01:06:35,130
0,270 270,600 600,1290 1410,2010 2010,2520
The system call code indexes
系统调用代码索引调用表，

2271
01:06:35,130 --> 01:06:37,350
0,510 510,870 870,1470 1980,2130 2130,2220
indices calls table,| we can
|我们可以找出哪些函数可以，它是从系统调用表中取出的，

2272
01:06:37,350 --> 01:06:38,670
0,210 210,270 270,480 480,1020 1020,1320
find out what function can,


2273
01:06:39,600 --> 01:06:40,500
0,300 300,570 570,750 750,810 810,900
it got out of the


2274
01:06:40,500 --> 01:06:42,020
0,300 300,540 540,1080
system call table,|
|

2275
01:06:42,380 --> 01:06:43,610
0,210 210,360 360,720 720,960 960,1230
{} by stepping into it,|
{}踩进去，|

2276
01:06:43,700 --> 01:06:44,870
0,360 360,510 510,660 660,780 780,1170
right now we're in write
现在我们正在写，这是正确的。

2277
01:06:44,870 --> 01:06:46,800
0,390 390,630 630,1080 1170,1620
turns this right.| So,
|那么既然{sysfile.c-}

2278
01:06:49,280 --> 01:06:50,690
0,210 210,390 390,690 690,930 930,1410
since {sysfile.c - - -},|
|

2279
01:06:52,560 --> 01:06:54,090
0,270 270,510 510,660 660,960 990,1530
{sys_write -} is the kernel
{sys_write-}是Write系统调用的内核实现。

2280
01:06:54,090 --> 01:06:56,610
0,930 960,1440 1650,1980 1980,2220 2220,2520
implementation of the write system


2281
01:06:56,610 --> 01:06:58,620
0,300 1200,1620 1620,1740 1740,1860 1860,2010
call.| I'm not gonna go
|我就不说了，好像很复杂，

2282
01:06:58,620 --> 01:07:00,060
0,150 150,390 390,510 510,930 960,1440
into this, it's like fairly


2283
01:07:00,060 --> 01:07:01,530
0,510 510,690 690,1020 1020,1170 1170,1470
complicated,| what happens from here
|从这里到外面和里面会发生什么

2284
01:07:01,530 --> 01:07:02,880
0,150 150,480 870,1170 1170,1290 1290,1350
out and in| and the
|而这个系统的实施需要这个讲座，

2285
01:07:02,880 --> 01:07:04,530
0,660 660,720 720,840 840,1110 1110,1650
implementation of this system call


2286
01:07:04,710 --> 01:07:05,730
0,360 360,570 570,750 750,840 840,1020
for this lecture,| I'm only
|我只对进出内核感兴趣，

2287
01:07:05,730 --> 01:07:06,960
0,240 240,630 630,720 720,990 990,1230
really interested in getting into


2288
01:07:06,960 --> 01:07:07,770
0,120 120,240 240,300 300,360 360,810
and out of the kernel,|
|

2289
01:07:08,970 --> 01:07:11,020
0,480 480,630 630,960 960,1770
so I'm going to
所以我要跳过，{}实际的实现系统调用，

2290
01:07:12,100 --> 01:07:13,200
0,810


2291
01:07:14,600 --> 01:07:16,460
0,840 840,1500
step over,


2292
01:07:18,980 --> 01:07:20,180
0,930


2293
01:07:25,860 --> 01:07:27,870
0,660 750,870 870,1110 1110,1710 1710,2010
{} the actual implementation system


2294
01:07:27,870 --> 01:07:29,430
0,300 330,750 750,1080 1080,1230 1230,1560
call,| one thing an interesting
|有一件事值得注意，一件有趣的事是

2295
01:07:29,430 --> 01:07:30,300
0,150 150,240 240,510 510,630 630,870
thing to note is| that
|系统调用需要找到它们的参数

2296
01:07:30,450 --> 01:07:31,680
0,420 420,720 720,990 990,1140 1140,1230
the system calls need to


2297
01:07:31,680 --> 01:07:33,330
0,210 210,360 360,1140 1170,1500 1500,1650
find their arguments| so you
|因此，您可以记住要写入或添加缓冲区指针和另外两个的参数，

2298
01:07:33,330 --> 01:07:34,890
0,360 360,420 420,990 990,1140 1170,1560
remember the arguments to write


2299
01:07:34,890 --> 01:07:36,090
0,210 240,810 810,870 870,930 930,1200
or to add a buffer


2300
01:07:36,090 --> 01:07:37,830
0,480 480,600 600,870 870,1260 1470,1740
pointer and another two,| and
|以及系统{call，code}获取它们的方式

2301
01:07:37,830 --> 01:07:39,240
0,120 120,510 510,750 750,1050 1110,1410
the way that the system


2302
01:07:39,240 --> 01:07:40,350
0,450 450,660 660,810 810,900 900,1110
{call,code} gets at them| is
|就是看着这些一些。

2303
01:07:40,350 --> 01:07:42,090
0,300 300,600 600,780 780,1020 1020,1740
just looking at these some.|
|

2304
01:07:43,430 --> 01:07:46,900
0,690 2580,3030
Well, {}
那么{}看着这个陷阱框，

2305
01:07:47,790 --> 01:07:49,230
0,660 660,720 720,810 810,1110 1110,1440
looking at the trap frame,|
|

2306
01:07:49,560 --> 01:07:50,370
0,240 240,420 420,570 570,690 690,810
so just like we could
所以就像我们可以在陷阱框中寻找{A7-}一样，

2307
01:07:50,370 --> 01:07:51,150
0,180 180,300 300,360 360,600 600,780
look in the trap frame


2308
01:07:51,150 --> 01:07:52,380
0,90 90,210 210,720 840,1110 1110,1230
for {a7 -},| we can
|我们可以寻找{a0-}，这是第一个参数，

2309
01:07:52,380 --> 01:07:53,760
0,120 120,240 240,360 360,1050 1260,1380
look for {a0 -} and


2310
01:07:53,760 --> 01:07:54,900
0,210 210,300 300,600 600,1050 1050,1140
that's the first argument,| we
|我们看看{A1-}，这就是缓冲区指针，

2311
01:07:54,900 --> 01:07:55,830
0,120 120,240 240,300 300,720 720,930
look at {a1 -}, that's


2312
01:07:55,830 --> 01:07:56,820
0,180 180,480 480,750 750,900 900,990
that buffer pointer,| we can
|我们可以看看{a2-}，这是第二个参数，

2313
01:07:56,820 --> 01:07:57,660
0,120 120,240 240,330 330,630 630,840
look at {a2 -} that's


2314
01:07:57,660 --> 01:07:59,310
0,90 90,390 390,840 1050,1320 1320,1650
the second argument,| the number
|{}{}字节数{至，写入}。

2315
01:07:59,310 --> 01:08:00,100
0,210 210,540
of {}


2316
01:08:00,940 --> 01:08:01,920
0,750
{}


2317
01:08:02,440 --> 01:08:03,760
0,540 540,1050
bytes {to,write}.|
|

2318
01:08:05,020 --> 01:08:06,490
0,600 600,870 870,960 960,1170 1170,1470
Okay, so the {system,call} does
好的，那么{system，call}就完成了它的工作

2319
01:08:06,490 --> 01:08:07,840
0,90 90,450 450,540 540,930 960,1350
its job| and then a
|然后，最终返回{sys_write-}。

2320
01:08:07,840 --> 01:08:10,280
0,300 300,630 630,930 930,1920
{sys_write -} finally returns.|
|

2321
01:08:10,920 --> 01:08:11,900
0,660


2322
01:08:13,190 --> 01:08:15,530
0,480 840,1230 1230,1380 1380,1920 1980,2340
And watch what happens,| the
看看会发生什么，|这次任务的原因是，

2323
01:08:15,530 --> 01:08:17,120
0,330 330,450 450,630 630,1290 1290,1590
reason for this assignment here,|
|

2324
01:08:17,120 --> 01:08:18,650
0,90 90,300 300,450 450,600 600,1530
the reason why we're assigning
我们将陷阱帧中的{a0-}赋值的原因是

2325
01:08:19,070 --> 01:08:20,210
0,390 420,630 630,990 990,1080 1080,1140
to {a0 -} in the


2326
01:08:20,210 --> 01:08:22,500
0,360 360,870 1170,1470 1470,1770
trap frame is| that
|这个系统调用的{}都有返回值。

2327
01:08:22,640 --> 01:08:23,870
0,210 210,360 360,870 870,1110 1110,1230
{} this system calls all


2328
01:08:23,870 --> 01:08:25,260
0,120 120,210 210,660 660,1110
have a return value.|
|

2329
01:08:26,030 --> 01:08:27,290
0,330 330,600 600,930 930,1020 1020,1260
Like write returns, the number
与写入返回一样，写入的字节数，

2330
01:08:27,290 --> 01:08:28,970
0,90 90,420 420,810 1020,1470 1470,1680
of bytes written,| {} and
|{}和约定，并针对{RISC-V-}上的C代码

2331
01:08:28,970 --> 01:08:30,260
0,60 60,690 690,900 900,1020 1020,1290
the convention and for C


2332
01:08:30,260 --> 01:08:31,250
0,270 270,360 360,420 420,660 660,990
code on the {RISC-V -}|
|

2333
01:08:31,250 --> 01:08:33,410
0,150 150,420 600,1200 1200,1860 1860,2160
is that return values are
将返回值放入寄存器{a0-}

2334
01:08:33,410 --> 01:08:35,090
0,330 330,420 420,870 870,1080 1080,1680
placed in register {a0 -}|
|

2335
01:08:35,120 --> 01:08:36,440
0,120 120,450 450,810 810,900 900,1320
by whatever function you're calling|
通过您正在调用的任何函数|

2336
01:08:36,800 --> 01:08:38,000
0,240 240,360 360,450 450,1110 1110,1200
and so to simulate a
因此，要模拟返回值，我们只需将返回值放入陷阱帧的{a0-}中

2337
01:08:38,000 --> 01:08:39,470
0,360 360,780 780,900 900,1170 1170,1470
return value, we just stick


2338
01:08:39,470 --> 01:08:40,910
0,90 90,390 390,900 960,1260 1260,1440
the return value in {a0


2339
01:08:40,910 --> 01:08:42,170
0,450 450,510 510,600 600,900 900,1260
-} in the trap frame|
|

2340
01:08:42,560 --> 01:08:43,310
0,180 180,270 270,450 450,630 630,750
and we'll see by and
当我们回到用户空间时，我们将逐渐看到这一点，

2341
01:08:43,310 --> 01:08:44,480
0,360 390,570 570,780 780,900 900,1170
by that when we return


2342
01:08:44,480 --> 01:08:46,640
0,90 90,330 330,1020 1320,1650 1650,2160
to user space,| this a0
|陷阱帧中的该a0时隙被恢复回实际零寄存器

2343
01:08:46,640 --> 01:08:47,750
0,300 300,360 360,450 450,780 780,1110
slot in the trap frame


2344
01:08:47,750 --> 01:08:49,670
0,480 870,1410 1410,1620 1620,1800 1800,1920
is restored back into the


2345
01:08:49,670 --> 01:08:51,590
0,360 360,660 660,1230 1230,1530 1650,1920
actually zero register| and the
|并且shell将{a0-}值视为从WRITE返回的值为{}

2346
01:08:51,590 --> 01:08:53,150
0,270 270,930 930,1140 1140,1260 1260,1560
shell sees that {a0 -}


2347
01:08:53,150 --> 01:08:54,400
0,420 420,810
value as


2348
01:08:55,290 --> 01:08:57,450
0,660 1230,1590 1590,1650 1650,1920 1920,2160
{} as the return value


2349
01:08:57,450 --> 01:09:00,870
0,150 150,630 1140,1830 2730,3180 3180,3420
from write| and execute through
|并通过此执行并打印p{trapframe-}{a0-}，

2350
01:09:00,870 --> 01:09:03,120
0,540 540,720 720,1170 1260,1740 1740,2250
this and print p {trapframe


2351
01:09:03,410 --> 01:09:06,170
0,780 1110,1620 1620,2100 2490,2610 2610,2760
-} {a0 -},| we'll see
|我们会看到值，也就是写返回值，

2352
01:09:06,170 --> 01:09:07,220
0,60 60,390 390,690 690,900 900,1050
the value to what that


2353
01:09:07,220 --> 01:09:08,520
0,270 270,390 390,570 570,1080
means is that write


2354
01:09:08,630 --> 01:09:10,190
0,510 510,840 840,1110 1110,1380 1380,1560
return values too,| saying that
|说它实际上是按照指令写了两个字节。

2355
01:09:10,220 --> 01:09:12,020
0,300 300,600 600,1020 1260,1410 1410,1800
it actually wrote two bytes


2356
01:09:12,020 --> 01:09:13,580
0,300 300,480 480,1230
just as instructed.|
|

2357
01:09:13,980 --> 01:09:14,790
0,300 300,360 360,510 510,690 690,810
Okay, at this point, we're
好的，现在我们又回到了{trap.c--}

2358
01:09:14,790 --> 01:09:15,920
0,300 300,840
back in


2359
01:09:18,800 --> 01:09:20,270
0,360 360,630 630,1050 1050,1230 1230,1470
{trap.c - -}| and {user
|并且{user-}陷阱{}紧接在对sys调用的调用之后，

2360
01:09:20,270 --> 01:09:21,220
0,60 60,810
-} trap


2361
01:09:21,600 --> 01:09:24,000
0,570 930,1590 1590,2010 2010,2100 2100,2400
{} just after the call


2362
01:09:24,000 --> 01:09:25,140
0,60 60,390 390,750 750,900 900,1140
to sys calls,| for now
|就目前而言，使用此p

2363
01:09:25,140 --> 01:09:26,120
0,150 150,600
with this


2364
01:09:26,670 --> 01:09:28,050
0,390 390,780 780,1140 1140,1260 1260,1380
p| which checking if the
|它检查函数是否已终止进程，

2365
01:09:28,050 --> 01:09:29,310
0,300 300,420 420,690 720,1110 1110,1260
func if the process been


2366
01:09:29,310 --> 01:09:30,630
0,480 480,960 990,1110 1110,1200 1200,1320
killed,| because you don't want
|因为你不想恢复行刑已经被杀了，

2367
01:09:30,630 --> 01:09:31,860
0,60 60,300 300,810 810,1020 1020,1230
to resume executing have already


2368
01:09:31,860 --> 01:09:33,260
0,90 90,480 480,600 600,1110
been killed,| of course,
|当然，我们的炮弹没有被杀死。

2369
01:09:33,420 --> 01:09:34,620
0,120 120,450 450,630 630,750 750,1200
our shells not been killed.|
|

2370
01:09:35,790 --> 01:09:38,940
0,510 510,690 690,1260 2490,2670 2670,3150
Skip over this and then,|
跳过这个然后，|

2371
01:09:39,060 --> 01:09:40,060
0,660


2372
01:09:40,570 --> 01:09:41,770
0,300 300,360 360,690 690,1110 1110,1200
{user -} trap calls a
{user-}陷阱调用单独的函数{usertrapret--}

2373
01:09:41,770 --> 01:09:44,020
0,510 510,1200 1200,1500 1500,1890 1890,2250
separate function {usertrapret - -}|
|

2374
01:09:44,050 --> 01:09:45,130
0,180 180,450 450,600 600,840 840,1080
in order to set up
为了设置我之前谈到的所有东西

2375
01:09:45,160 --> 01:09:46,270
0,300 300,420 420,870 870,1020 1020,1110
all the stuff that I


2376
01:09:46,270 --> 01:09:47,830
0,330 330,540 540,1110 1110,1470 1470,1560
talked about previously| whenever I
|每当我在进入用户空间之前说好的时候，

2377
01:09:47,830 --> 01:09:49,570
0,330 480,750 750,1170 1170,1500 1500,1740
said well before entering user


2378
01:09:49,570 --> 01:09:51,310
0,570 570,660 660,960 960,1380 1380,1740
space,| the kernel does blah
|内核确实是胡说八道，{}它是{usertrapret--}。

2379
01:09:51,310 --> 01:09:53,920
0,570 930,1470 1560,1830 1830,2220 2220,2610
blah, {} it's {usertrapret -


2380
01:09:53,920 --> 01:09:54,520
0,300
-}.|
|

2381
01:09:54,700 --> 01:09:56,830
0,300 300,1020 1020,1530 1560,1950 1950,2130
That's responsible for setting all
负责设置所有这些东西。

2382
01:09:56,830 --> 01:09:57,880
0,180 180,510 510,720
that stuff up.|
|

2383
01:10:00,490 --> 01:10:01,090
0,240 240,330 330,390 390,480 480,600
And so we can look
所以我们可以看到所有不同的东西，它确实是这样的，

2384
01:10:01,090 --> 01:10:01,930
0,90 90,240 240,330 330,630 630,840
at all the different things,


2385
01:10:01,930 --> 01:10:04,600
0,90 90,750 930,1650
it does,| {}
|{}它关闭中断

2386
01:10:09,690 --> 01:10:10,960
0,270 270,900


2387
01:10:11,440 --> 01:10:13,870
0,660 660,1020 1020,1380 1380,2190 2280,2430
it turns interrupts off| and
|并且当它们在系统调用期间被打开时现在被关闭，

2388
01:10:13,870 --> 01:10:14,740
0,150 150,240 240,360 360,660 660,870
when they were turned on


2389
01:10:14,740 --> 01:10:15,460
0,120 120,180 180,570 570,660 660,720
for the duration of a


2390
01:10:15,460 --> 01:10:16,990
0,330 330,690 870,1080 1080,1320 1320,1530
system call were turned off


2391
01:10:16,990 --> 01:10:18,220
0,150 150,360 360,510 510,1110 1110,1230
now,| because we're about to
|因为我们即将更改{stvec-}

2392
01:10:18,220 --> 01:10:20,410
0,510 510,630 630,1170 1170,1590 1800,2190
change the {stvec -}| to
|指向用户陷阱处理程序，

2393
01:10:20,410 --> 01:10:23,260
0,450 450,780 780,1260 1530,2550
point to the user


2394
01:10:23,980 --> 01:10:26,380
0,540 540,1140 1530,2070 2070,2280 2280,2400
trap handler,| whereas while we're
|而当我们在内核中时，指向内核陷阱处理程序，

2395
01:10:26,380 --> 01:10:27,220
0,60 60,120 120,420 420,570 570,840
in the kernel was pointing


2396
01:10:27,220 --> 01:10:28,510
0,90 90,240 240,630 630,960 960,1290
to the kernel trap handler,|
|

2397
01:10:28,780 --> 01:10:29,800
0,180 180,270 270,450 450,600 600,1020
so we turn off interrupts,|
所以我们关闭了中断，|

2398
01:10:29,800 --> 01:10:31,840
0,360 420,810 810,930 930,1860 1860,2040
because once we changed {stvec
因为一旦我们将{stvec-}更改为指向用户陷阱处理程序，

2399
01:10:31,840 --> 01:10:32,620
0,360 360,450 450,630 630,690 690,780
-} to point to the


2400
01:10:32,620 --> 01:10:33,760
0,270 270,540 540,810 810,900 900,1140
user trap handler,| we're still
|我们仍然在内核中执行，

2401
01:10:33,760 --> 01:10:35,380
0,420 420,510 510,570 570,1110 1230,1620
executing in the kernel,| and
|如果中断发生，则我们转到用户陷阱处理程序，

2402
01:10:35,410 --> 01:10:37,510
0,150 150,240 240,750 750,1350 1590,2100
if an interruption occur then


2403
01:10:37,510 --> 01:10:38,170
0,90 90,240 240,300 300,390 390,660
we go to the user


2404
01:10:38,170 --> 01:10:39,520
0,300 300,780 840,1080 1080,1200 1200,1350
trap handler,| even though we're
|即使我们在内核中执行

2405
01:10:39,520 --> 01:10:40,960
0,420 420,510 510,570 570,1050 1140,1440
executing in the kernel| and
|由于各种详细原因，{}会导致内核故障。

2406
01:10:40,960 --> 01:10:43,630
0,90 90,630 630,1080 1080,1710 1830,2670
for various detailed reasons, {}


2407
01:10:44,060 --> 01:10:45,560
0,510 510,840 840,1140 1140,1200 1200,1500
that would cause the kernel


2408
01:10:45,560 --> 01:10:46,970
0,120 120,720 960,1170 1170,1230 1230,1410
to malfunction.| So we turn
|因此，我们关闭中断，并在这两个时间之间关闭它们的左侧。

2409
01:10:46,970 --> 01:10:49,250
0,180 180,1020 1170,1710 1770,2040 2040,2280
off interrupts and their left


2410
01:10:49,250 --> 01:10:50,720
0,210 210,390 390,780 780,870 870,1470
off from between the time.|
|

2411
01:10:51,140 --> 01:10:52,160
0,300 300,390 390,600 600,810 810,1020
From the very next line
从我们设置{stvec-}的下一行开始

2412
01:10:52,160 --> 01:10:53,360
0,150 150,300 300,960 960,1080 1080,1200
where we set up the


2413
01:10:53,360 --> 01:10:54,950
0,390 390,810 1050,1350 1350,1530 1530,1590
{stvec -}| to point to
|在最后的{sret-}指令中一直指向蹦床

2414
01:10:54,950 --> 01:10:56,510
0,60 60,750 810,1350 1350,1440 1440,1560
the trampoline all the way


2415
01:10:56,510 --> 01:10:58,370
0,210 210,300 300,1200 1320,1650 1650,1860
through the final {sret -}


2416
01:10:58,370 --> 01:11:00,050
0,750 750,930 930,1320 1320,1410 1410,1680
instruction| that returns to user
|返回到用户空间。

2417
01:11:00,050 --> 01:11:00,860
0,660
space.|
|

2418
01:11:01,220 --> 01:11:02,030
0,210 210,420 420,510 510,660 660,810
It turns out that {sret
原来蹦床最后的{sret-}指令，

2419
01:11:02,030 --> 01:11:02,900
0,150 150,600 600,660 660,750 750,870
-} instruction at the end


2420
01:11:02,900 --> 01:11:05,780
0,60 60,120 120,960 1530,2130 2340,2880
of the trampoline,| {} turns
|{}重新打开中断。

2421
01:11:05,780 --> 01:11:06,940
0,390 390,630 630,840
interrupts back on.|
|

2422
01:11:07,200 --> 01:11:08,250
0,150 150,360 360,660 660,750 750,1050
So the interrupts are on
所以当我们在用户代码中执行时，中断是开启的，

2423
01:11:08,250 --> 01:11:09,630
0,180 180,330 330,870 870,1080 1080,1380
when we're executing in a


2424
01:11:10,650 --> 01:11:11,550
0,300 300,540 540,720 720,810 810,900
user code,| even though we
|即使我们只是把它们关掉。

2425
01:11:11,550 --> 01:11:12,760
0,210 210,390 390,480 480,930
just turn them off.|
|

2426
01:11:13,350 --> 01:11:14,850
0,390 390,630 630,870 870,990 990,1500
The next couple of lines,
接下来的几行，填充我们之前看到的陷印框槽

2427
01:11:14,850 --> 01:11:16,890
0,360 360,900 1020,1290 1290,1680 1680,2040
fill in those trap frame


2428
01:11:16,890 --> 01:11:18,300
0,570 570,690 690,780 780,1020 1020,1410
slots that we saw before|
|

2429
01:11:18,300 --> 01:11:20,280
0,120 120,360 360,1110 1200,1860 1860,1980
that hold various values that
包含对蹦床代码方便{}的各种值。

2430
01:11:20,280 --> 01:11:21,540
0,60 60,960
are convenient


2431
01:11:21,700 --> 01:11:23,260
0,210 210,330 330,420 420,1050 1050,1560
{} for the trampoline code.|
|

2432
01:11:23,290 --> 01:11:25,040
0,420 720,1470
So, {}
所以，{}这里的代码，隐藏{}，一个指针

2433
01:11:25,550 --> 01:11:26,570
0,240 240,450 450,570 570,930 930,1020
the code here, stash {}


2434
01:11:26,570 --> 01:11:27,440
0,210 210,300 300,660 660,750 750,870
away, a pointer| to the
|到陷阱帧中的内核页表，

2435
01:11:27,440 --> 01:11:30,110
0,690 960,1350 1350,1860 2490,2610 2610,2670
kernel page table in the


2436
01:11:30,110 --> 01:11:32,030
0,300 300,750 1080,1320 1320,1620 1620,1920
trap frame,| its stash away
|它隐藏了指向此进程、内核堆栈指针。

2437
01:11:32,030 --> 01:11:34,310
0,90 90,630 630,780 780,1230 1230,2280
a pointer to this processes,


2438
01:11:34,400 --> 01:11:36,040
0,720 720,1350
kernel stack.|
|

2439
01:11:36,940 --> 01:11:37,930
0,300 300,660 660,810 810,900 900,990
{} Stashed away in the
{}藏在陷阱框里。

2440
01:11:37,930 --> 01:11:40,380
0,360 360,1050
trap frame.|
|

2441
01:11:40,890 --> 01:11:42,000
0,480 480,600 600,930 930,1020 1020,1110
{} A pointer to the
{}指向用户陷阱函数的指针，这是蹦床代码在最后跳转到的地方。

2442
01:11:42,000 --> 01:11:43,290
0,300 300,600 600,960 960,1170 1170,1290
user trap function, which is


2443
01:11:43,290 --> 01:11:44,820
0,330 390,510 510,960 960,1230 1230,1530
what the trampoline code jump


2444
01:11:44,820 --> 01:11:46,050
0,270 270,360 360,450 450,750 750,1230
to at the very end.|
|

2445
01:11:47,440 --> 01:11:48,640
0,270 270,780 780,900 900,1080 1080,1200
A stash {} away, the
一个藏身之处，当前的核心编号，

2446
01:11:48,640 --> 01:11:51,370
0,420 420,840 840,1380 1890,2520 2520,2730
current core number,| read from
|从TP寄存器读取，使得蹦床代码可以仅恢复相同的值，

2447
01:11:51,370 --> 01:11:52,810
0,60 60,480 480,990 990,1170 1170,1440
the tp register, so that


2448
01:11:52,810 --> 01:11:53,500
0,360
the


2449
01:11:54,220 --> 01:11:55,750
0,540 540,840 840,960 960,1140 1140,1530
trampoline code can just restore


2450
01:11:55,750 --> 01:11:57,700
0,150 150,360 360,960 1260,1680 1680,1950
that same value,| because user
|因为用户代码可能干扰了它。

2451
01:11:57,700 --> 01:11:58,900
0,270 270,420 420,540 540,1050 1050,1200
code may have disturbed it.|
|

2452
01:12:01,320 --> 01:12:04,050
0,810 960,1470 1680,2370 2370,2580 2580,2730
Question?| Yes.| Why didn't we
有问题吗？|是。|我们为什么不把蹦床上的SECC留下来呢？

2453
01:12:04,050 --> 01:12:05,430
0,300 300,510 510,1230 1230,1320 1320,1380
save the sepc in the


2454
01:12:05,430 --> 01:12:06,260
0,570
trampoline?|
|

2455
01:12:08,370 --> 01:12:09,300
0,180 180,360 360,660
It could have.|
可能是这样的。|

2456
01:12:11,420 --> 01:12:12,830
0,180 180,660 660,1050 1050,1320 1320,1410
{} Yeah that that the
{}是的，{}Sepc可能正在践踏代码

2457
01:12:12,830 --> 01:12:14,000
0,150 150,600 600,750 750,840 840,1170
{} sepc could have been


2458
01:12:14,480 --> 01:12:15,830
0,510 510,690 690,1080 1080,1260 1260,1350
trampling code happens| not to
|而不是将其与其他寄存器一起保存，

2459
01:12:15,830 --> 01:12:16,850
0,360 360,480 510,720 720,840 840,1020
save it along with other


2460
01:12:16,850 --> 01:12:19,070
0,570 960,1380 1470,1920 1920,2070 2070,2220
registers,| we perfectly well could
|我们完全可以修改{xv6-}以保存[]

2461
01:12:19,070 --> 01:12:20,520
0,690 690,1110
modify the


2462
01:12:20,880 --> 01:12:22,440
0,360 360,600 600,840 900,1350 1380,1560
{xv6 -} to save []|
|

2463
01:12:22,440 --> 01:12:23,580
0,180 180,240 240,390 390,660 660,1140
where it is actually saves
它实际上拯救了你。

2464
01:12:23,580 --> 01:12:24,500
0,180
you.|
|

2465
01:12:24,840 --> 01:12:26,560
0,210 210,540 540,1020 1020,1560
{} Probably remember is,
{}可能记得是，只是碰巧保存了一下

2466
01:12:26,900 --> 01:12:28,040
0,270 270,570 570,720 720,1020 1020,1140
just happened to save it|
|

2467
01:12:28,040 --> 01:12:28,820
0,120 120,330 330,390 390,690 690,780
and {user -} trap and
以及蹦床代码中的{user-}陷阱和C代码，而不是汇编代码。

2468
01:12:28,820 --> 01:12:29,870
0,180 180,480 480,840 840,930 930,1050
C code instead of an


2469
01:12:29,870 --> 01:12:31,000
0,390 390,870
assembly code,


2470
01:12:31,680 --> 01:12:33,040
0,150 150,210 210,660 660,1140
in the trampoline code.|
|

2471
01:12:34,950 --> 01:12:36,450
0,480 780,870 870,1050 1050,1230 1230,1500
{} I don't think, I
{}我不认为，我想不出一个好的理由来做这件事。

2472
01:12:36,450 --> 01:12:37,020
0,210 210,330 330,390 390,450 450,570
can't think of a good


2473
01:12:37,020 --> 01:12:37,860
0,240 240,360 360,510 510,630 630,840
reason to do it one


2474
01:12:37,860 --> 01:12:39,060
0,390 390,540 540,660 660,990
way or the other.|
|

2475
01:12:40,240 --> 01:12:42,220
0,330 330,600 600,1200 1230,1560 1560,1980
The user registers really have
用户注册确实需要保存在汇编代码中。

2476
01:12:42,220 --> 01:12:43,450
0,120 120,240 240,930 960,1140 1140,1230
to be saved in the


2477
01:12:43,450 --> 01:12:44,820
0,480 480,1110
assembly code.|
|

2478
01:12:45,300 --> 01:12:46,590
0,390 390,600 600,900 900,1170 1170,1290
Because any C code is
因为据我们所知，任何C代码都有权由编译器生成代码

2479
01:12:46,590 --> 01:12:48,030
0,690 990,1140 1140,1230 1230,1320 1320,1440
entitled for all we know


2480
01:12:48,030 --> 01:12:49,410
0,90 90,570 570,960 960,1230 1230,1380
the compiler generates code| which
|其修改任何用户寄存器，

2481
01:12:49,410 --> 01:12:50,880
0,540 540,1080
modifies any


2482
01:12:51,040 --> 01:12:51,820
0,510


2483
01:12:53,180 --> 01:12:54,980
0,270 270,810 810,1020 1020,1230 1230,1800
user registers,| those user registers
|这些用户寄存器对于在输入C之前将它们保存在汇编代码中非常重要。

2484
01:12:54,980 --> 01:12:56,420
0,150 720,900 900,1200 1200,1260 1260,1440
are pretty important to save


2485
01:12:56,420 --> 01:12:57,650
0,120 120,270 300,720 720,930 930,1230
them in assembly code before


2486
01:12:57,650 --> 01:12:58,960
0,270 270,690
entering C.|
|

2487
01:12:59,160 --> 01:13:00,480
0,120 120,240 240,750 750,960 1170,1320
But the sepc we could
但是我们可以早点或晚点救出来的SECC。

2488
01:13:00,480 --> 01:13:01,950
0,180 180,630 630,990 990,1140 1140,1470
have saved earlier or later.|
|

2489
01:13:04,470 --> 01:13:05,670
0,300 300,480 480,600 600,840 840,1200
Okay, so when {usertrapret -
好的，所以当{usertrapret--}准备陷阱时，

2490
01:13:05,670 --> 01:13:07,380
0,240 240,420 420,570 990,1650 1650,1710
-} sort of preparing the


2491
01:13:07,380 --> 01:13:08,940
0,300 300,420 420,1050 1050,1230 1230,1560
trap,| we prepared the trap
|我们准备了陷阱框架，其中包含下次需要的所有这些值。

2492
01:13:08,940 --> 01:13:10,230
0,450 450,570 570,690 690,870 870,1290
frame with all these values


2493
01:13:10,230 --> 01:13:11,010
0,90 90,210 210,540 540,630 630,780
that are going to be


2494
01:13:11,010 --> 01:13:13,600
0,570 1170,1740 1740,2250
needed next time.|
|

2495
01:13:13,950 --> 01:13:15,150
0,330 330,540 540,570 570,1050 1050,1200
{} There's a transition from
{}有一个从用户空间到内核下一个陷阱的转换。

2496
01:13:15,150 --> 01:13:16,740
0,210 210,450 450,540 540,1110 1170,1590
user space to kernel next


2497
01:13:16,740 --> 01:13:19,440
0,720
trap.|
|

2498
01:13:19,760 --> 01:13:20,870
0,660 660,690 690,900 900,1050 1050,1110
There's a couple things we
我们在{sstatus-}控制寄存器中设置了几项内容，

2499
01:13:20,870 --> 01:13:21,680
0,90 90,390 390,510 510,600 600,810
have set up in the


2500
01:13:21,680 --> 01:13:23,220
0,270 270,1380
{sstatus -}


2501
01:13:23,450 --> 01:13:26,510
0,600 600,1290 1470,2190 2490,2790 2790,3060
control register,| {} it turns
|{}结果是sstatus中的这个spp位，

2502
01:13:26,510 --> 01:13:29,390
0,120 120,510 570,1680 1680,2220 2460,2880
out this spp bit in


2503
01:13:29,390 --> 01:13:32,390
0,660 690,1710 1710,2400 2430,2880 2880,3000
sstatus,| controls whether controls the
|控制是否控制{sret-}返回{}的模式，

2504
01:13:32,390 --> 01:13:34,440
0,960 990,1380
mode that


2505
01:13:34,530 --> 01:13:36,360
0,390 390,810 840,1380 1380,1710 1710,1830
{sret -} return {},| by
|通过清除它，我们只是说下次执行{sret-}时请注意，

2506
01:13:36,360 --> 01:13:37,680
0,450 450,570 570,690 690,870 870,1320
clearing it we're just saying


2507
01:13:37,770 --> 01:13:39,750
0,480 480,690 690,840 840,990 1440,1980
look next time you execute


2508
01:13:40,120 --> 01:13:41,440
0,300 300,690 780,1110 1110,1260 1260,1320
{sret -},| we want to
|我们希望进入用户模式，而不是主管模式

2509
01:13:41,440 --> 01:13:42,640
0,60 60,180 180,540 540,840 840,1200
go to user mode instead


2510
01:13:42,640 --> 01:13:44,980
0,90 90,810 810,1200 1650,2100 2160,2340
of supervisor mode| {} and
|{}此{SPIE-}位控制是否启用中断，

2511
01:13:44,980 --> 01:13:45,790
0,270 270,480 480,690 690,810 810,810
this {spie - - -}


2512
01:13:45,790 --> 01:13:48,080
0,570 840,1470 1470,1950
bit controls whether


2513
01:13:48,620 --> 01:13:51,620
0,390 390,510 510,630 630,1500 2670,3000
interrupts will be enabled,| after
|在我们执行{sret-}之后，然后进入用户空间之后，

2514
01:13:51,620 --> 01:13:53,240
0,120 120,540 540,780 780,990 1230,1620
we execute {sret -} and


2515
01:13:53,360 --> 01:13:54,470
0,390 390,720 720,810 810,930 930,1110
then after we get into


2516
01:13:54,470 --> 01:13:55,760
0,270 270,810 810,990 990,1110 1110,1290
user space,| and we do
|我们确实希望它们能够启用。

2517
01:13:55,760 --> 01:13:56,780
0,210 210,330 330,390 390,480 480,1020
want them to be enabled.|
|

2518
01:13:56,780 --> 01:13:57,540
0,480
So,
所以，我要设置{SPIE-}位

2519
01:13:57,700 --> 01:13:58,810
0,240 240,540 540,720 720,930 930,1110
gonna set that {spie -


2520
01:13:58,810 --> 01:13:59,950
0,180 180,180 180,510 840,1080 1080,1140
- -} bit| and I'm
|我将把这个新的修改状态写入实际硬件状态寄存器。

2521
01:13:59,950 --> 01:14:00,760
0,150 150,240 240,480 480,720 720,810
going to write this new


2522
01:14:00,760 --> 01:14:02,500
0,600 600,1110 1110,1260 1260,1380 1380,1740
modified status into the actual


2523
01:14:02,500 --> 01:14:05,000
0,570 930,1380 1380,1860
hardware status register.|
|

2524
01:14:05,100 --> 01:14:06,040
0,570


2525
01:14:06,590 --> 01:14:07,550
0,210 210,420 420,510 510,750 750,960
It turns out what {sret
它证明了{sret-}是做什么的。

2526
01:14:07,550 --> 01:14:09,380
0,300 300,990
-} does.|
|

2527
01:14:10,450 --> 01:14:11,200
0,120 120,210 210,300 300,660 660,750
You know the sret we're
你知道我们要执行的蹦床代码末尾的sret，

2528
01:14:11,200 --> 01:14:12,010
0,120 120,510 510,690 690,750 750,810
gonna execute write at the


2529
01:14:12,010 --> 01:14:13,120
0,90 90,150 150,210 210,690 690,1110
end of the trampoline code,|
|

2530
01:14:13,120 --> 01:14:14,440
0,120 120,300 300,480 480,630 630,1320
what that {sret -} does
{sret-}做的是，

2531
01:14:14,470 --> 01:14:16,240
0,330 330,810 870,1260 1260,1380 1380,1770
is,| {} sets the program
|{}将程序计数器设置为等于{Sepc-}寄存器，

2532
01:14:16,240 --> 01:14:17,740
0,330 330,690 690,900 1020,1260 1260,1500
counter equal to the {sepc


2533
01:14:17,740 --> 01:14:20,380
0,750 750,1380 2160,2370 2370,2460 2460,2640
-} register,| so we're now
|所以我们现在要设置SERC寄存器

2534
01:14:20,380 --> 01:14:21,250
0,120 120,210 210,450 450,570 570,870
going to set up the


2535
01:14:21,250 --> 01:14:23,440
0,720 720,1260 1260,1350 1350,1800 2040,2190
sepc register| to have the
|以使保存的用户程序计数器。

2536
01:14:23,440 --> 01:14:25,140
0,570 570,1290
saved user


2537
01:14:25,300 --> 01:14:26,460
0,390 390,870
program counter.|
|

2538
01:14:27,170 --> 01:14:28,430
0,210 210,510 510,690 690,780 780,1260
{} Which, if you recall
{}如果你还记得我们最近保存了陷阱帧，

2539
01:14:28,430 --> 01:14:30,350
0,330 540,1170 1170,1620 1620,1680 1680,1920
we recently saved the trap


2540
01:14:30,350 --> 01:14:31,880
0,330 420,630 630,810 810,1080 1080,1530
frame,| that's what's happening here.|
|这就是这里正在发生的事情。|

2541
01:14:33,480 --> 01:14:35,160
0,480 600,960 960,1290 1290,1560 1560,1680
{} You remember also the
{}您还记得陷阱帧{}包含指向内核页表的指针

2542
01:14:35,160 --> 01:14:37,110
0,300 300,1080 1230,1530 1530,1890 1890,1950
trap frame {} contain a


2543
01:14:37,110 --> 01:14:38,760
0,480 480,1290
pointer to


2544
01:14:39,520 --> 01:14:41,410
0,360 360,720 720,1080 1080,1440 1440,1890
a kernel page table| because
|因为蹦床需要换成这样，

2545
01:14:41,440 --> 01:14:42,430
0,90 90,450 450,630 630,690 690,990
the trampoline needs to switch


2546
01:14:42,430 --> 01:14:43,960
0,150 150,360 810,1110 1110,1410 1410,1530
to it,| {} we need
|{}我们需要炮制出特殊的位模式

2547
01:14:43,960 --> 01:14:45,610
0,90 90,390 390,660 660,870 870,1650
to cook up the special


2548
01:14:45,610 --> 01:14:46,540
0,180 180,600 600,690 690,810 810,930
bit pattern| that you need
|您需要写信给{satp-}的操作已在此完成。

2549
01:14:46,540 --> 01:14:48,010
0,120 120,390 390,480 480,660 660,1470
to write to {satp -}


2550
01:14:48,130 --> 01:14:49,600
0,300 300,480 480,1020
has done here.|
|

2551
01:14:50,290 --> 01:14:52,300
0,870
And.|
和。|

2552
01:14:52,740 --> 01:14:55,020
0,210 210,600 900,1200 1230,1620 1620,2280
I'm sorry, we're now preparing
很抱歉，我们现在正在准备一个指向用户页表的指针。

2553
01:14:55,020 --> 01:14:56,250
0,120 120,510 510,630 630,750 750,1230
a pointer to the user


2554
01:14:56,250 --> 01:14:57,460
0,360 360,960
page table.|
|

2555
01:14:57,950 --> 01:14:58,970
0,210 210,330 330,510 510,600 600,1020
Which we need to switch
我们需要在进入用户空间的过程中切换到它。

2556
01:14:58,970 --> 01:14:59,840
0,270 270,390 390,480 480,690 690,870
to on the way into


2557
01:14:59,840 --> 01:15:01,040
0,270 270,1050
user space.|
|

2558
01:15:02,350 --> 01:15:03,490
0,390 390,780 780,930 930,990 990,1140
We're actually going to do
我们实际上要在汇编代码中进行切换，

2559
01:15:03,490 --> 01:15:05,290
0,180 180,600 600,780 780,1230 1230,1800
that switch in assembly code,|
|

2560
01:15:05,320 --> 01:15:06,430
0,360 360,420 420,630 630,720 720,1110
because it has to happen
因为它必须在蹦床上进行，

2561
01:15:06,490 --> 01:15:08,800
0,180 180,240 240,1230 1470,1950 1950,2310
in the trampoline,| because only
|因为只有蹦床中的代码在用户空间和内核空间中都被映射，

2562
01:15:08,800 --> 01:15:10,000
0,330 330,420 420,480 480,1080 1080,1200
code in the trampoline is


2563
01:15:10,000 --> 01:15:10,990
0,300 300,390 390,660 660,900 900,990
mapped in both user and


2564
01:15:10,990 --> 01:15:12,820
0,330 330,990 1380,1620 1620,1710 1710,1830
kernel space,| so we can
|所以我们只能真正交换页表，

2565
01:15:12,820 --> 01:15:13,920
0,270 270,840
only really


2566
01:15:14,280 --> 01:15:15,840
0,360 360,630 630,960 960,1110 1110,1560
switch page tables,| we're executing
|我们在蹦床上执行死刑，

2567
01:15:15,840 --> 01:15:16,770
0,60 60,120 120,690 690,840 840,930
on the trampoline,| but we're
|但我们还没有在蹦床上执行死刑，

2568
01:15:16,770 --> 01:15:18,180
0,330 330,780 780,840 840,900 900,1410
not executing on the trampoline


2569
01:15:18,180 --> 01:15:19,560
0,270 540,900 900,1110 1110,1290 1290,1380
yet,| we're still just in
|我们仍然只是在一个普通的C函数中，

2570
01:15:19,560 --> 01:15:20,760
0,120 120,480 480,720 720,1050 1050,1200
an ordinary C function,| so
|所以我们准备了这个指针

2571
01:15:20,760 --> 01:15:22,980
0,120 120,540 540,690 690,1260 1860,2220
we prepared this pointer| and
|我们将把它作为{a1-}中的第二个参数传递给汇编代码。

2572
01:15:22,980 --> 01:15:23,970
0,90 90,210 210,300 300,810 810,990
we're going to pass it


2573
01:15:23,970 --> 01:15:25,530
0,90 90,180 180,600 600,1140 1230,1560
to the assembly code as


2574
01:15:25,530 --> 01:15:26,730
0,90 90,420 420,930 930,1050 1050,1200
the second argument in {a1


2575
01:15:26,730 --> 01:15:27,500
0,510
-}.|
|

2576
01:15:28,250 --> 01:15:31,520
0,420 2040,2520 2550,2820 2820,3030 3030,3270
{} With this line
{}这里的这一行所做的就是计算地址

2577
01:15:31,520 --> 01:15:33,080
0,210 210,510 510,630 630,840 840,1560
here doing is just calculating


2578
01:15:33,080 --> 01:15:34,610
0,150 150,930 930,1140 1140,1410 1410,1530
the address| of where we
|我们想要跳到蹦床代码末尾的地方

2579
01:15:34,610 --> 01:15:36,420
0,150 150,270 270,660 660,1290
want to jump to


2580
01:15:36,600 --> 01:15:37,110
0,150 150,270 270,390 390,450 450,510
at the end of the


2581
01:15:37,110 --> 01:15:38,820
0,540 540,900 900,1020 1020,1140 1170,1710
trampoline code| and it turns
|原来有一个，我们要用{userret-}

2582
01:15:38,820 --> 01:15:39,480
0,360
out


2583
01:15:40,110 --> 01:15:41,100
0,330 330,750
there's a,


2584
01:15:41,600 --> 01:15:42,680
0,210 210,720 720,870 870,930 930,1080
that we want to go


2585
01:15:42,680 --> 01:15:43,880
0,150 150,540 540,780 780,990 990,1200
with {userret -}| user, that's
|用户，这是将我们带回用户空间的指令地址

2586
01:15:43,880 --> 01:15:45,530
0,90 90,600 600,720 720,870 870,1650
the address of the instructions


2587
01:15:45,530 --> 01:15:46,280
0,120 120,210 210,450 450,540 540,750
that will take us back


2588
01:15:46,280 --> 01:15:48,050
0,60 60,300 300,840 1170,1590 1590,1770
to user space| and this
|这个小公式就算出来了{}。

2589
01:15:48,050 --> 01:15:51,020
0,210 210,1020 1050,1680 1680,2250 2280,2970
little formula works out {}.|
|

2590
01:15:52,500 --> 01:15:55,140
0,510 570,1020 1020,1440 1830,2310 2310,2640
The address the virtual address
该地址是蹦床中对应于该用户RET功能的虚拟地址。

2591
01:15:55,140 --> 01:15:57,240
0,60 60,120 120,960 1170,1440 1440,2100
in the trampoline that corresponds


2592
01:15:57,240 --> 01:15:58,440
0,90 90,270 270,540 540,750 750,1200
to that user ret function.|
|

2593
01:16:02,980 --> 01:16:03,920
0,750
Oops.
哎呀。好的，我们来计算一下它的地址。

2594
01:16:05,930 --> 01:16:07,190
0,420 420,540 540,630 630,1170 1170,1260
Okay, so we calculate the


2595
01:16:07,190 --> 01:16:08,220
0,300 300,390 390,720
address of that.|
|

2596
01:16:09,640 --> 01:16:11,320
0,270 270,480 480,1050 1110,1380 1380,1680
{userret -} function, and then
{userret-}函数，然后这个乱七八糟的，下一行，

2597
01:16:11,350 --> 01:16:13,540
0,390 390,1170 1200,1410 1410,1710 1710,2190
this mess, this next line,|
|

2598
01:16:14,030 --> 01:16:17,690
0,780 780,1290 1290,1500 1500,2280 3210,3660
call uses this fn variable
调用使用此fn变量作为函数指针

2599
01:16:17,690 --> 01:16:18,890
0,150 150,210 210,630 630,1050 1050,1200
as a function pointer| and
|并跳转到{a0-}{a1-}中带有这两个参数的函数。

2600
01:16:18,890 --> 01:16:20,390
0,360 360,420 420,660 660,1230 1230,1500
jumps to that function with


2601
01:16:20,390 --> 01:16:22,400
0,360 360,630 630,1590 1650,1860 1860,2010
these two arguments in {a0


2602
01:16:22,400 --> 01:16:23,960
0,360 360,450 450,1020
-} {a1 -}.|
|

2603
01:16:24,240 --> 01:16:24,960
0,180 180,240 240,330 330,480 480,720
And we can now just
现在我们可以直接去蹦床代码了。

2604
01:16:24,960 --> 01:16:26,220
0,270 270,990
go to


2605
01:16:28,720 --> 01:16:30,180
0,570 570,1230
trampoline code.|
|

2606
01:16:30,880 --> 01:16:32,300
0,690


2607
01:16:33,790 --> 01:16:36,850
0,120 120,660 660,1020 1020,1500 2430,3060
The trampoline code, there's a.|
蹦床密码，有一个。|

2608
01:16:38,820 --> 01:16:39,510
0,120 120,330 330,420 420,600 600,690
Well first we switch to
那么首先我们切换到用户页表，

2609
01:16:39,510 --> 01:16:40,410
0,60 60,270 270,510 510,840 840,900
the user page tables,| I
|我的意思是，实际上执行此命令，我们可以看到页表发生了变化，

2610
01:16:40,410 --> 01:16:41,580
0,210 210,450 450,870 870,1080 1080,1170
mean actually execute this and


2611
01:16:41,580 --> 01:16:42,390
0,90 90,210 210,450 450,540 540,810
we can see the page


2612
01:16:42,390 --> 01:16:44,700
0,360 360,960 1080,1440 1440,1560 1560,2310
tables change,| just for [],
|仅针对[]，{}我们仍然使用巨大的内核页表。

2613
01:16:44,820 --> 01:16:45,960
0,330 330,540 540,810 810,1020 1020,1140
{} we're still using the


2614
01:16:45,960 --> 01:16:48,000
0,420 420,690 690,990 990,1530
giant kernel page table.|
|

2615
01:16:48,400 --> 01:16:49,580
0,780
Um.|
恩。|

2616
01:16:50,750 --> 01:16:51,860
0,180 180,360 360,570 570,840 840,1110
I'm gonna run through {usertrapret
我将快速浏览{usertrapret--}

2617
01:16:51,860 --> 01:16:53,600
0,360 360,540 540,1200 1230,1650 1650,1740
- -} quickly| until we
|直到我们到了它跳到蹦床的地步。

2618
01:16:53,600 --> 01:16:54,170
0,90 90,150 150,240 240,420 420,570
get to the point where


2619
01:16:54,170 --> 01:16:55,580
0,90 90,510 510,570 570,660 660,1410
it jumps to the trampoline.|
|

2620
01:16:57,240 --> 01:16:58,560
0,870
Oh.|
噢。|

2621
01:16:59,200 --> 01:17:00,280
0,270 270,360 360,420 420,510 510,1080
Alright we're in the trampoline.|
好的，我们在蹦床上。|

2622
01:17:01,380 --> 01:17:02,340
0,690
Um.|
恩。|

2623
01:17:07,350 --> 01:17:08,820
0,240 240,840 840,1140 1140,1410 1410,1470
These instructions are about to
这些指令即将在这里开始执行蹦床代码，

2624
01:17:08,820 --> 01:17:10,320
0,210 210,630 630,690 690,1170 1170,1500
start executing the trampoline code


2625
01:17:10,320 --> 01:17:11,100
0,150 150,360 360,540 540,630 630,780
there right here,| we can
|我们现在可以，{}再次，{}什么是打印的页表

2626
01:17:11,100 --> 01:17:14,140
0,480 780,1770 2040,2760
now, {} again,


2627
01:17:14,270 --> 01:17:16,160
0,300 300,750 840,1140 1140,1410 1410,1890
{} what's printed page table|
|

2628
01:17:16,310 --> 01:17:17,210
0,120 120,330 330,420 420,660 660,900
is still the kernel page
仍然是内核页表{}。

2629
01:17:17,210 --> 01:17:19,240
0,390 1350,1740
table {}.|
|

2630
01:17:20,080 --> 01:17:21,070
0,450 450,630 630,720 720,840 840,990
The first thing that's gonna
不过，这里要发生的第一件事是

2631
01:17:21,070 --> 01:17:22,210
0,300 300,480 480,720 720,930 930,1140
happen here though is| that
|蹦床代码将会加载，

2632
01:17:22,210 --> 01:17:23,650
0,480 510,990 990,1200 1200,1290 1290,1440
the trampoline code is going


2633
01:17:23,650 --> 01:17:25,040
0,120 120,630 630,1110
to load the,|
|

2634
01:17:25,070 --> 01:17:26,150
0,300 300,570 570,660 660,750 750,1080
that pointer to the user
指向用户页表{}到SATP寄存器的指针。

2635
01:17:26,150 --> 01:17:28,070
0,330 330,900 1200,1590 1620,1830 1830,1920
page table {} into the


2636
01:17:28,070 --> 01:17:29,380
0,420 420,990
satp register.|
|

2637
01:17:30,000 --> 01:17:31,140
0,270 300,480 480,570 570,840 840,1140
{} So we switch page
{}所以我们现在交换我从他们那里输入的页表。

2638
01:17:31,140 --> 01:17:32,280
0,600 600,660 660,900 900,990 990,1140
tables I typed in from


2639
01:17:32,280 --> 01:17:33,360
0,180 180,810
them now.|
|

2640
01:17:33,500 --> 01:17:34,190
0,120 120,240 240,330 330,330 330,690
We now have a much
我们现在有一个小得多的用户页表，

2641
01:17:34,190 --> 01:17:35,690
0,480 480,720 720,990 990,1320 1320,1500
smaller user page table,| but
|但幸运的是还有蹦床页面地图，

2642
01:17:35,960 --> 01:17:37,880
0,570 810,1290 1290,1410 1410,1470 1470,1920
luckily still with the trampoline


2643
01:17:37,880 --> 01:17:38,930
0,270 270,540 540,750 750,840 840,1050
page map,| so we don't
|这样我们就不会在下一条指令上崩溃。

2644
01:17:38,930 --> 01:17:40,460
0,570 570,690 690,750 750,990 990,1530
crash on the next instruction.|
|

2645
01:17:41,790 --> 01:17:44,310
0,390 1080,1710 1710,1920 1920,2070 2070,2520
{} The next thing happens,
{}接下来会发生什么，这是一个。

2646
01:17:44,310 --> 01:17:45,720
0,150 150,480 480,1050
is this a.|
|

2647
01:17:47,090 --> 01:17:50,540
0,960 1320,1920 2670,3060 3060,3390 3390,3450
{} The I showed you
{}刚才我给大家看的，

2648
01:17:50,540 --> 01:17:51,980
0,90 90,330 330,540 540,960 990,1440
a while ago,| the second
|此代码序列在进入用户空间的过程中做的第二件最后一件事是将擦除与零互换，

2649
01:17:51,980 --> 01:17:53,870
0,450 450,780 780,960 960,1440 1470,1890
last thing that this sequence


2650
01:17:53,870 --> 01:17:54,710
0,60 60,360 360,690 690,780 780,840
of code does on the


2651
01:17:54,710 --> 01:17:57,230
0,120 120,180 180,480 480,1200 1230,2520
way to user spaces swaps


2652
01:17:57,230 --> 01:17:59,120
0,420 420,570 570,1260 1470,1770 1770,1890
scratch with zero,| so we
|所以我们需要设置{ssccratch-}，它是保存的用户{a0-}，

2653
01:17:59,120 --> 01:18:00,470
0,180 180,270 270,600 600,750 750,1350
need to setup {sscratch -},


2654
01:18:00,500 --> 01:18:02,450
0,240 240,960 960,1410 1410,1560 1560,1950
it's saved user {a0 -},|
|

2655
01:18:02,450 --> 01:18:03,110
0,150 150,240 240,420 420,540 540,660
so that when we do
所以当我们交换的时候，

2656
01:18:03,110 --> 01:18:04,600
0,210 210,840
that swap,|
|

2657
01:18:04,690 --> 01:18:05,800
0,300 300,570 570,750 750,870 870,1110
a1 will end up having
A1将最终具有接收到的用户A1变为0，

2658
01:18:05,800 --> 01:18:08,230
0,630 930,1320 1320,1710 1740,2100 2100,2430
received user a1 turns out


2659
01:18:08,260 --> 01:18:09,300
0,510
a0,|
|

2660
01:18:09,470 --> 01:18:10,640
0,300 300,390 390,480 480,810 810,1170
pointer to the trap frame
指向陷阱帧的指针，因为C代码传递的是第一个参数，

2661
01:18:10,640 --> 01:18:12,860
0,510 960,1230 1230,1500 1500,1800 1800,2220
because the C code pass


2662
01:18:12,860 --> 01:18:14,150
0,270 270,420 420,510 510,780 780,1290
that is the first argument,|
|

2663
01:18:14,390 --> 01:18:16,310
0,360 360,960 960,1350 1350,1740 1740,1920
one twelve {a0 -} is
一十二{a0-}是保存的{a0-}的地址

2664
01:18:16,310 --> 01:18:17,690
0,300 360,810 810,900 900,990 990,1380
the address of the saved


2665
01:18:17,690 --> 01:18:19,310
0,90 90,720 1110,1290 1290,1350 1350,1620
{a0 -}| in the trap
|在要加载的陷阱帧中。

2666
01:18:19,310 --> 01:18:20,540
0,390 390,540 540,600 600,870 870,1230
frames going to load that.|
|

2667
01:18:21,170 --> 01:18:22,340
0,180 180,420 420,660 660,810 810,1170
And then into {t0 -}
然后放入{t0-}，然后将其加载到{ssccratch-}。

2668
01:18:22,340 --> 01:18:23,330
0,90 90,270 270,540 540,780 780,990
and then load that into


2669
01:18:23,330 --> 01:18:24,420
0,120 120,930
{sscratch -}.|
|

2670
01:18:24,630 --> 01:18:25,440
0,150 150,300 300,480 480,570 570,810
At this point, we're still
此时，我们仍在运行内核内容和所有寄存器。

2671
01:18:25,440 --> 01:18:26,380
0,240 240,630
running with


2672
01:18:26,940 --> 01:18:28,560
0,540 540,960 960,1080 1080,1290 1290,1620
kernel stuff and all the


2673
01:18:29,260 --> 01:18:30,400
0,840
registers.|
|

2674
01:18:31,230 --> 01:18:33,120
0,240 240,480 480,810 810,1440 1440,1890
The next 32 instructions, though
接下来的32条指令，虽然是从陷阱帧加载出来的

2675
01:18:33,300 --> 01:18:34,980
0,930 930,1170 1170,1260 1260,1320 1320,1680
load out of the trap


2676
01:18:34,980 --> 01:18:36,390
0,360 360,690 720,960 960,1110 1110,1410
frame| which is a0 points
|其为0，将所有保存的用户寄存器从陷阱帧加载到实际寄存器中，{}，

2677
01:18:36,390 --> 01:18:38,520
0,330 690,1470 1470,1770 1770,1860 1860,2130
to load all of the


2678
01:18:38,520 --> 01:18:40,800
0,600 600,870 870,1740 1950,2220 2220,2280
saved user registers out of


2679
01:18:40,800 --> 01:18:41,980
0,60 60,360 360,930
the trap frame,


2680
01:18:43,390 --> 01:18:46,570
0,780 1710,2070 2070,2160 2160,2520 2520,3180
{} into the actual registers,|
|

2681
01:18:46,570 --> 01:18:48,010
0,390 390,780 780,1170 1170,1290 1290,1440
were really close to being
已经接近能够运行用户代码的程度，

2682
01:18:48,010 --> 01:18:49,390
0,210 210,630 900,1080 1080,1290 1290,1380
able to the point where


2683
01:18:49,390 --> 01:18:50,470
0,120 120,240 240,450 450,690 690,1080
we can run user code,|
|

2684
01:18:50,500 --> 01:18:51,550
0,180 180,360 360,420 420,810 810,1050
I'm going to skip over
我将跳过所有这些负载{}。

2685
01:18:51,550 --> 01:18:53,800
0,90 90,270 270,990 1500,2010
all these loads {}.|
|

2686
01:18:56,140 --> 01:18:57,700
0,180 180,750 750,1050 1050,1260 1260,1560
Any questions before we {}
在我们{}接近用户空间之前有任何问题。

2687
01:18:58,790 --> 01:19:00,440
0,300 300,660 660,720 720,990 990,1650
approach closer to user space.|
|

2688
01:19:02,440 --> 01:19:04,000
0,180 180,390 390,630 630,1200 1260,1560
And one quick question,| {}
还有一个简短的问题，|{}为陷阱帧中的值为零，

2689
01:19:04,000 --> 01:19:05,500
0,150 150,240 240,690 690,1230 1320,1500
is the value in the


2690
01:19:05,500 --> 01:19:06,910
0,330 330,600 600,840 840,1140 1140,1410
trap frame is zero,| now
|现在是我们进行的那个系统调用的返回值。

2691
01:19:06,910 --> 01:19:08,410
0,300 360,930 930,1260 1260,1320 1320,1500
the return value of that


2692
01:19:08,410 --> 01:19:09,460
0,330 330,570 570,660 660,780 780,1050
system call that we made.|
|

2693
01:19:11,330 --> 01:19:12,880
0,1170
Um.|
恩。|

2694
01:19:14,800 --> 01:19:16,840
0,510 1050,1200 1200,1320 1320,1650 1650,2040
Yeah yeah, the relay zero
是的，中继零点控制着陷阱帧的这一点，

2695
01:19:16,840 --> 01:19:18,520
0,810 810,1200 1200,1560 1560,1620 1620,1680
holds this point of the


2696
01:19:18,520 --> 01:19:19,940
0,270 270,570 570,750 750,1110
trap frame,| but the
|但是在我们执行完之后，

2697
01:19:20,350 --> 01:19:22,420
0,390 390,570 570,1320 1320,1620 1620,2070
after we execute the,| well
|好的，确定用户保存的当前位置，

2698
01:19:24,480 --> 01:19:27,000
0,510 510,870 900,1170 1170,1770 1770,2520
s, OK the current location


2699
01:19:27,000 --> 01:19:28,640
0,90 90,210 210,630 630,1440
of the user's saved,|
|

2700
01:19:29,120 --> 01:19:31,760
0,660 1680,1980 1980,2070 2070,2310 2310,2640
{} yes I was calling
{}是的，我是在呼叫保存的用户{a0-}

2701
01:19:31,760 --> 01:19:32,750
0,120 120,240 240,540 540,870 870,990
at the user saved {a0


2702
01:19:32,750 --> 01:19:33,950
0,270 270,390 390,450 450,960 1080,1200
-}| but in fact the
|但实际上系统调用返回的内容会覆盖它，

2703
01:19:33,950 --> 01:19:36,200
0,420 420,900 900,1380 1380,1590 1590,2250
system call returns stuff overrode


2704
01:19:36,200 --> 01:19:36,760
0,270
it,|
|

2705
01:19:36,830 --> 01:19:38,090
0,180 180,270 270,720 720,1080 1080,1260
with the return value that
使用我们希望shell在{a0-}中看到的返回值，

2706
01:19:38,090 --> 01:19:39,920
0,180 180,810 1200,1350 1350,1710 1710,1830
we want the shell to


2707
01:19:39,920 --> 01:19:41,720
0,240 240,360 360,540 540,1020 1620,1800
see in {a0 -},| so
|所以我们用2覆盖了a0的当前位置。

2708
01:19:41,720 --> 01:19:42,860
0,90 90,360 360,780 780,870 870,1140
the current location of that


2709
01:19:42,860 --> 01:19:44,330
0,300 300,510 510,720 720,1320 1320,1470
a0 which we overwrote with


2710
01:19:44,330 --> 01:19:45,240
0,660
two.|
|

2711
01:19:45,780 --> 01:19:47,040
0,180 180,270 270,630 630,1020 1020,1260
As the return value is
因为返回值为{sscatch-}指定临时

2712
01:19:47,040 --> 01:19:48,870
0,150 150,750 750,1260 1260,1710 1710,1830
{sscratch -} appoints scratch| and
|希望它等于2，

2713
01:19:48,870 --> 01:19:49,800
0,390 390,510 510,630 630,840 840,930
hope that it's equal to


2714
01:19:49,800 --> 01:19:50,500
0,360
two,|
|

2715
01:19:51,160 --> 01:19:53,380
0,300 300,450 450,660 660,990 1680,2220
it is equal to {}.|
等于{}。|

2716
01:19:55,980 --> 01:19:56,970
0,90 90,240 240,420 420,510 510,990
Does that answer your question?|
这回答了你的问题吗？|

2717
01:19:57,960 --> 01:19:59,400
0,300 300,390 390,510 510,780 930,1440
Yes I think so.| Okay.|
是的我想是的。|好吧。|

2718
01:19:59,460 --> 01:20:01,350
0,270 270,720 720,720 1380,1680 1680,1890
I'm gonna {} skip over
我会{}跳过所有这些加载恢复，

2719
01:20:01,350 --> 01:20:03,940
0,150 150,360 360,1260 1410,2310
all these loads restore,|
|

2720
01:20:04,180 --> 01:20:05,410
0,150 150,450 450,660 660,1110 1110,1230
to save user values out
为了将用户值从陷阱帧保存到寄存器中，

2721
01:20:05,410 --> 01:20:06,190
0,60 60,120 120,450 450,660 660,780
of the trap frame into


2722
01:20:06,190 --> 01:20:08,620
0,90 90,810 1200,1740 2190,2370 2370,2430
the registers,| I'm going to
|我现在要把收银机拿出来。

2723
01:20:08,650 --> 01:20:09,580
0,180 180,330 330,420 420,870 870,930
turn out the registers at


2724
01:20:09,580 --> 01:20:10,940
0,150 150,510
this point.|
|

2725
01:20:11,180 --> 01:20:13,260
0,900 1080,1500 1500,1710
Um, actually not.|
嗯，实际上不是。|

2726
01:20:15,550 --> 01:20:15,860
0,60


2727
01:20:16,620 --> 01:20:18,210
0,300 300,390 390,990 1140,1500 1500,1590
Print the registers I don't
打印寄存器我不知道这些看起来是不是很眼熟，

2728
01:20:18,210 --> 01:20:19,080
0,60 60,120 120,270 270,420 420,870
know if these look familiar,|
|

2729
01:20:19,080 --> 01:20:20,280
0,150 150,270 270,630 630,690 690,1200
but they happen to be
但是它们恰好是同一组用户寄存器，

2730
01:20:20,460 --> 01:20:21,480
0,120 120,570 570,720 720,780 780,1020
the same set of user


2731
01:20:21,480 --> 01:20:22,800
0,510 510,570 570,810 810,1080 1080,1320
registers,| you saw way back
|你在这个练习开始的时候就看到了，

2732
01:20:22,800 --> 01:20:23,640
0,60 60,150 150,570 570,660 660,840
at the beginning of this


2733
01:20:23,640 --> 01:20:26,760
0,810 990,1380 1380,1860 2010,2280 2280,3120
exercise,| for example {a1 -}
|例如{A1-}或堆栈指针在存储器中保持适合于{}个用户堆栈的小值，

2734
01:20:27,260 --> 01:20:29,060
0,330 330,420 420,750 750,1290 1590,1800
or the stack pointer holds


2735
01:20:29,060 --> 01:20:30,590
0,150 150,510 510,900 900,1410 1410,1530
this small value appropriate for


2736
01:20:30,590 --> 01:20:31,550
0,90 90,360 360,690 690,870 870,960
{} user stack low in


2737
01:20:31,550 --> 01:20:32,460
0,600
memory,|
|

2738
01:20:32,860 --> 01:20:34,090
0,270 270,600 600,750 750,930 930,1230
a1 is that buffer
A1是我们向右传递的缓冲区指针

2739
01:20:34,090 --> 01:20:36,190
0,420 420,600 900,1200 1200,1560 1560,2100
pointer that we passed right|
|

2740
01:20:36,520 --> 01:20:37,660
0,450 450,600 600,780 780,1080 1080,1140
to is that number of
为该字节数，

2741
01:20:37,660 --> 01:20:39,640
0,600 870,1500 1500,1800 1800,1890 1890,1980
bytes,| a0, however is the
|然而，A0是未接收到用户值的例外，

2742
01:20:39,640 --> 01:20:41,480
0,480 480,930 960,1620
exception is not


2743
01:20:42,500 --> 01:20:44,570
0,840 930,1260 1260,1710 1710,2010 2010,2070
received user value,| because it
|因为它仍然有指针或陷阱{[]-}。

2744
01:20:44,570 --> 01:20:45,590
0,270 270,450 450,540 540,840 840,1020
still has the pointer or


2745
01:20:45,590 --> 01:20:48,620
0,360 360,570 570,870
trap {[] -}.|
|

2746
01:20:49,100 --> 01:20:50,000
0,270 270,450 450,570 570,690 690,900
But let's look we're about
但让我们看看我们即将执行的

2747
01:20:50,000 --> 01:20:51,040
0,90 90,780
to execute,|
|

2748
01:20:52,830 --> 01:20:55,440
0,540 990,1500 1500,1920 1920,2070 2070,2610
{} rather execute is this
{}宁可执行此{csrrw-}a0划痕，

2749
01:20:55,810 --> 01:20:57,460
0,510 510,720 720,1410
{csrrw - -


2750
01:20:58,090 --> 01:20:59,800
0,360 360,780 780,1230 1230,1620 1620,1710
-} a0 scratch,| right at
|就在蹦床的尽头，就在返回用户空间之前

2751
01:20:59,800 --> 01:21:02,200
0,150 150,570 570,1050 1380,2160 2160,2400
the end of trampoline just


2752
01:21:02,200 --> 01:21:03,400
0,240 240,630 630,690 690,930 930,1200
before returning to user space|
|

2753
01:21:03,400 --> 01:21:04,630
0,120 120,270 270,330 330,750 750,1230
is going to swap a0
将交换a0和Scratch，

2754
01:21:04,630 --> 01:21:07,360
0,90 90,810 1650,2550
and scratch,| scratch
|Scratch确实做到了。

2755
01:21:07,320 --> 01:21:08,600
0,450 450,1140
indeed has.|
|

2756
01:21:12,680 --> 01:21:16,160
0,540 570,840 840,1560
Um, that's scratch.|
嗯，那是刮伤。|

2757
01:21:16,640 --> 01:21:17,600
0,300 300,540 540,720 720,840 840,960
As to which is going
关于哪个将作为该内核指针的返回值a0，

2758
01:21:17,600 --> 01:21:18,710
0,60 60,150 150,240 240,570 570,1110
to be the return value


2759
01:21:18,860 --> 01:21:20,660
0,870 870,1080 1080,1590
a0 as this


2760
01:21:21,130 --> 01:21:23,110
0,630 840,1260 1260,1350 1350,1560 1560,1980
kernel pointer,| and it points
|它指向，指向陷阱框，

2761
01:21:23,110 --> 01:21:25,960
0,330
to,


2762
01:21:26,620 --> 01:21:27,580
0,360 360,420 420,480 480,780 780,960
point to the trap frame,|
|

2763
01:21:27,580 --> 01:21:29,680
0,210 210,600 600,1170 1170,1290 1290,2100
but after executing the {csrrw
但是在执行{csrrw-}指令以交换它们之后，

2764
01:21:29,680 --> 01:21:31,420
0,420 420,870 870,990 990,1380 1380,1740
-} instruction to swap them,|
|

2765
01:21:31,450 --> 01:21:34,780
0,660 660,780 780,1110 1110,1410 2310,3330
hopefully we'll see that a0
希望我们能看到a0包含这个返回值2

2766
01:21:34,840 --> 01:21:35,920
0,300 300,450 450,720 720,990 990,1080
holds this return value of


2767
01:21:35,920 --> 01:21:37,840
0,540 900,1590
two|, and
|，并且{ssccratch-}保存指向陷印帧的指针

2768
01:21:39,390 --> 01:21:42,210
0,270 270,1680 1710,2280 2280,2340 2340,2820
{sscratch -} holds a pointer


2769
01:21:42,210 --> 01:21:43,320
0,90 90,180 180,570 570,930 930,1110
to the trap frame| which
|这是存储器中倒数第二页，

2770
01:21:43,320 --> 01:21:45,510
0,510 1020,1110 1110,1590 1590,1920 1920,2190
is the second last page


2771
01:21:45,510 --> 01:21:48,390
0,90 90,600 990,1650 1950,2130 2130,2880
in memory,| {} and that
|{}，该值将保留在临时位置

2772
01:21:48,390 --> 01:21:49,050
0,210 210,270 270,390 390,450 450,660
value is going to stay


2773
01:21:49,050 --> 01:21:50,040
0,90 90,180 180,630 630,900 900,990
in a scratch| until the
|直到用户程序执行另一个陷阱，并且在该点上。

2774
01:21:50,040 --> 01:21:52,050
0,630 630,1110 1110,1320 1320,1560 1560,2010
user program does another trap


2775
01:21:52,050 --> 01:21:53,300
0,120 120,180 180,390 390,990
and at that point.|
|

2776
01:21:53,560 --> 01:21:54,730
0,210 210,540 540,870 870,1080 1080,1170
The trap handling code, we
在我们不能在陷阱帧上使用{ssccratch-}之前，我们谈到了陷阱处理代码。

2777
01:21:54,730 --> 01:21:56,140
0,210 210,390 390,780 780,1080 1170,1410
talked about, before we won't


2778
01:21:56,140 --> 01:21:56,800
0,60 60,210 210,330 330,570 570,660
be able to use {sscratch


2779
01:21:56,800 --> 01:21:58,270
0,630 630,810 810,900 900,1170 1170,1470
-} at the trap frame.|
|

2780
01:21:59,080 --> 01:22:00,400
0,270 270,360 360,1080
Alright, we're still
好的，我们还在内核中，

2781
01:22:01,370 --> 01:22:03,050
0,210 210,360 360,420 420,930 1320,1680
{} in the kernel,| that
|这是我们在内核中的最后一条指令，

2782
01:22:03,440 --> 01:22:04,550
0,210 210,330 330,600 600,1050 1050,1110
is our last instruction in


2783
01:22:04,550 --> 01:22:06,980
0,60 60,510 1380,1950 2070,2280 2280,2430
the kernel,| {} and when
|{}当我执行这个{sret-}时，

2784
01:22:06,980 --> 01:22:08,240
0,120 120,510 510,690 690,900 900,1260
I execute this {sret -},|
|

2785
01:22:09,280 --> 01:22:11,290
0,360 360,750 750,1320 1530,1920 1920,2010
it will {} switch to
它将{}切换到用户模式，

2786
01:22:11,290 --> 01:22:13,960
0,270 270,1050 1260,1980 2160,2610 2610,2670
user mode,| {} before I
|{}在我这样做之前，让我们先来看看。

2787
01:22:13,960 --> 01:22:14,950
0,120 120,300 300,510 510,660 660,990
do that let's look at.|
|

2788
01:22:17,300 --> 01:22:19,100
0,480 510,930 930,1200 1200,1410 1410,1800
It'll switch user mode, it'll
它将切换用户模式，将{Sepc-}复制到PC，

2789
01:22:19,130 --> 01:22:21,260
0,660 660,1050 1050,1470 1470,1650 1650,2130
copy {sepc -} to PC,|
|

2790
01:22:21,260 --> 01:22:22,820
0,210 210,300 300,1200
because we're still,
因为我们还在，我们还在用蹦床上的电脑执行任务，

2791
01:22:27,060 --> 01:22:28,140
0,180 180,480 480,930 930,1020 1020,1080
we're still executing with the


2792
01:22:28,140 --> 01:22:30,330
0,480 480,840 870,1050 1050,1320 1350,2190
PC that's in the trampoline,|
|

2793
01:22:30,510 --> 01:22:32,820
0,510 570,900 900,1020 1020,1350 1710,2310
so {sret -} gonna switch
因此，{sret-}将用户模式副本{Sepc-}切换到PC。

2794
01:22:32,820 --> 01:22:34,290
0,90 90,360 360,780 780,1170 1170,1470
the user mode copy {sepc


2795
01:22:34,290 --> 01:22:36,320
0,600 600,840 840,1710
-} to PC.|
|

2796
01:22:36,350 --> 01:22:39,110
0,660 1620,1770 1770,1860 1860,2130 2130,2760
{} And then resume executing,
{}然后继续执行，所以我将运行{sret-}。

2797
01:22:39,530 --> 01:22:41,150
0,150 150,210 210,690 930,1410 1410,1620
so I'm gonna run the


2798
01:22:41,150 --> 01:22:42,160
0,270 270,660
{sret -}.|
|

2799
01:22:42,480 --> 01:22:46,200
0,750 990,1770 2520,3240 3240,3360 3360,3720
Boom, I'm now we're back
砰，我现在又回到原点了。

2800
01:22:46,200 --> 01:22:47,080
0,660
at.|
|

2801
01:22:48,640 --> 01:22:49,810
0,270 270,420 420,720 720,960 960,1170
I could address {0xdea -
我可以寻址{0xdea-}，它是一个低位地址

2802
01:22:49,810 --> 01:22:50,860
0,180 180,360 360,750 750,930 930,1050
- - -} which is


2803
01:22:50,860 --> 01:22:52,960
0,180 210,570 570,1200 1350,1950 1950,2100
a low address| likely be
|很可能是用户内存，{}，它是。

2804
01:22:52,960 --> 01:22:54,820
0,240 240,780 930,1380 1380,1590 1590,1860
user memory, {} and it's


2805
01:22:54,820 --> 01:22:55,600
0,420
the.|
|

2806
01:22:55,980 --> 01:22:57,150
0,420 420,660 660,780 780,960 960,1170
Look back in {sh.asm -
回顾{sh.asm-}和地址{0xdea-}。

2807
01:22:57,150 --> 01:22:58,890
0,210 210,330 330,510 510,960 1470,1740
- - - -} and


2808
01:22:58,890 --> 01:23:01,300
0,720 720,930 930,2070
address {0xdea -}.|
|

2809
01:23:01,880 --> 01:23:03,120
0,990


2810
01:23:03,970 --> 01:23:06,400
0,300 300,1200 1560,1740 1740,2190 2190,2430
Is indeed the address of
实际上是写入结束时返回函数的地址。

2811
01:23:06,400 --> 01:23:07,570
0,90 90,480 480,900 900,1050 1050,1170
the return function at the


2812
01:23:07,570 --> 01:23:08,600
0,150 150,240 240,720
end of write.|
|

2813
01:23:09,870 --> 01:23:10,920
0,780
And,
{}{a0-}是这个返回值，它们应该返回。

2814
01:23:12,670 --> 01:23:14,080
0,360 360,540 540,930 930,1050 1050,1410
{} {a0 -} is this


2815
01:23:14,080 --> 01:23:15,100
0,330 330,570 570,750 750,960 960,1020
return value, they're supposed to


2816
01:23:15,100 --> 01:23:16,620
0,90 90,450
be returning.|
|

2817
01:23:16,730 --> 01:23:17,480
0,180 180,270 270,450 450,540 540,750
So we're back in user
所以我们回到了用户空间

2818
01:23:17,480 --> 01:23:19,340
0,630 630,810 810,930 930,1290 1560,1860
space| and we can about
|我们可以执行从写入系统返回到shell的操作。

2819
01:23:19,340 --> 01:23:20,270
0,90 90,210 210,330 330,720 720,930
to do the return back


2820
01:23:20,270 --> 01:23:21,170
0,90 90,180 180,600 600,810 810,900
to the shell from the


2821
01:23:21,170 --> 01:23:22,080
0,180 180,540
write system.|
|

2822
01:23:22,350 --> 01:23:23,520
0,180 180,270 270,480 480,840 840,1170
From the write library function
来自进行系统调用的写入库函数。

2823
01:23:23,520 --> 01:23:24,360
0,90 90,240 240,300 300,570 570,840
that made the system call.|
|

2824
01:23:25,020 --> 01:23:26,820
0,420 420,600 600,1290
OK, any questions?|
好的，有什么问题吗？|

2825
01:23:27,490 --> 01:23:28,100
0,540


2826
01:23:28,880 --> 01:23:30,200
0,270 300,660 660,870 870,990 990,1320
Um, sorry, can you repeat
嗯，对不起，你能再重复一遍吗，在{sret}期间中断发生了什么。

2827
01:23:30,200 --> 01:23:31,730
0,330 330,660 660,1140 1140,1290 1290,1530
again, what happens with the


2828
01:23:31,730 --> 01:23:34,620
0,960 990,1560 1560,2130 2130,2670
interrupt during {sret.|
|

2829
01:23:37,750 --> 01:23:39,820
0,180 180,480 480,660 660,1650 1770,2070
What happened with interrupts.| You,
中断之后发生了什么。|你，你说我们把它们关了，然后又有别的东西把它们打开了。

2830
01:23:39,820 --> 01:23:40,990
0,180 180,360 360,510 510,780 780,1170
you say we are turning


2831
01:23:40,990 --> 01:23:43,030
0,420 450,1020 1140,1500 1500,1680 1680,2040
them off, but then something


2832
01:23:43,030 --> 01:23:44,890
0,420 450,990 990,1110 1110,1410 1410,1860
else turns them back on.|
|

2833
01:23:45,840 --> 01:23:47,320
0,390 390,1110
{sret -},
{sret-}，sret{重新启用-}中断，

2834
01:23:48,190 --> 01:23:50,590
0,570 570,660 660,1140 1140,1830 2220,2400
sret {re-enables -} interrupts,| so
|所以这个{sret-}，也就是我们在内核中以管理模式执行的最后一条指令，

2835
01:23:50,590 --> 01:23:52,300
0,240 240,510 510,840 1200,1320 1320,1710
this {sret -}, the very


2836
01:23:52,300 --> 01:23:53,830
0,240 240,780 780,870 870,960 960,1530
last instruction that we're executing


2837
01:23:53,830 --> 01:23:54,760
0,90 90,630 630,810 810,870 870,930
in supervisor mode in the


2838
01:23:54,760 --> 01:23:57,340
0,510 1500,1950 2010,2280 2280,2490 2490,2580
kernel,| {} I forgot to
|{}刚才我忘了说，

2839
01:23:57,340 --> 01:23:58,120
0,150 150,300 300,510 510,660 660,780
say that just now,| but
|但也将程序计数器设置为等于{Sepc-}

2840
01:23:58,120 --> 01:23:59,350
0,120 120,510 510,690 690,1050 1050,1230
as well as setting the


2841
01:23:59,380 --> 01:24:00,610
0,270 270,570 570,840 840,990 990,1230
program counter equal to the


2842
01:24:00,610 --> 01:24:02,710
0,390 390,990 990,1230 1440,1860 1860,2100
{sepc -}| and socially user
|社交用户模式{sret-}将{重新启用-}中断。

2843
01:24:02,710 --> 01:24:04,210
0,390 660,1050 1050,1230 1230,1350 1350,1500
mode {sret -} is going


2844
01:24:04,210 --> 01:24:05,740
0,210 240,570 570,1230
to {re-enable -}


2845
01:24:06,140 --> 01:24:07,320
0,810
interrupts.|
|

2846
01:24:07,840 --> 01:24:09,430
0,330 330,480 480,720 1260,1530 1530,1590
So that means you know
这意味着你知道，你知道，用户程序可能会运行很长时间，

2847
01:24:09,430 --> 01:24:11,080
0,360 570,810 810,900 900,1350 1350,1650
that's you know user programs


2848
01:24:11,080 --> 01:24:11,680
0,150 150,330 330,390 390,420 420,600
may run for a long


2849
01:24:11,680 --> 01:24:12,490
0,300 300,360 360,450 450,540 540,810
time,| it would be nice
|如果能够接受磁盘中断或其他任何情况就好了，

2850
01:24:12,490 --> 01:24:13,180
0,60 60,150 150,300 300,450 450,690
to be able to take


2851
01:24:13,180 --> 01:24:14,700
0,240 240,600 600,690 690,1140
disk interrupts or whatever,|
|

2852
01:24:15,040 --> 01:24:17,140
0,570 900,1200 1200,1710 1710,1800 1800,2100
while user programs are running.|
当用户程序正在运行时。|

2853
01:24:18,320 --> 01:24:19,700
0,150 150,420 420,690 690,1140
I see, thank you.|
我明白了，谢谢你。|

2854
01:24:20,770 --> 01:24:21,920
0,330 330,960
Other questions?|
还有其他问题吗？|

2855
01:24:25,860 --> 01:24:26,460
0,150
Okay.|
好吧。|

2856
01:24:28,100 --> 01:24:29,210
0,300 300,600 600,810 810,900 900,1110
Okay to, {} to wrap
好的，{}结束{}系统调用，

2857
01:24:29,210 --> 01:24:31,520
0,270 270,660 780,1260 1320,1650 1650,2310
up the {} system calls,|
|

2858
01:24:31,550 --> 01:24:32,660
0,210 210,270 270,540 540,750 750,1110
sort of look like function
看起来有点像函数调用

2859
01:24:32,660 --> 01:24:33,470
0,330 330,450 450,540 540,750 750,810
calls| and are kind of
|它们在某种程度上被认为很像函数调用，

2860
01:24:33,470 --> 01:24:35,000
0,540 540,630 630,900 900,1230 1230,1530
meant to be thought of


2861
01:24:35,000 --> 01:24:36,290
0,60 60,270 270,480 480,780 780,1290
a lot like function calls,|
|

2862
01:24:36,290 --> 01:24:38,300
0,240 510,1080 1080,1380 1500,1800 1800,2010
but {} the user kernel
但是{}用户内核转换比函数调用要复杂得多

2863
01:24:38,300 --> 01:24:40,190
0,540 540,840 930,1200 1200,1320 1320,1890
transitions are much more complex


2864
01:24:40,190 --> 01:24:40,840
0,270
than


2865
01:24:41,000 --> 01:24:42,290
0,240 240,450 450,750 750,1020 1020,1290
{} than function calls| are
|由于隔离的要求有很大的复杂性，

2866
01:24:42,860 --> 01:24:44,330
0,300 300,480 480,600 600,1290 1290,1470
a lot of complexities due


2867
01:24:44,330 --> 01:24:46,460
0,90 90,180 180,960 1200,1500 1500,2130
to the requirement for isolation,|
|

2868
01:24:46,460 --> 01:24:47,510
0,90 90,330 330,510 510,750 750,1050
the kernel just can't trust
内核就是不能信任用户空间中的任何东西。

2869
01:24:47,510 --> 01:24:49,080
0,360 360,480 480,720 720,1350
anything in user space.|
|

2870
01:24:49,330 --> 01:24:51,070
0,210 210,690 960,1230 1230,1650 1650,1740
And also the desire to
并且还希望具有简单且非常快速的硬件机制，

2871
01:24:51,070 --> 01:24:52,810
0,360 510,960 960,1080 1080,1320 1320,1740
have simple and very fast


2872
01:24:52,810 --> 01:24:55,180
0,360 360,1050 1050,1530 1920,2220 2220,2370
hardware mechanisms,| really {} {xv6
|真的{}{xv6--}不太关心性能，

2873
01:24:55,180 --> 01:24:55,990
0,90 90,270 270,450 450,660 660,810
- -} doesn't care that


2874
01:24:55,990 --> 01:24:57,220
0,150 150,390 390,960 960,1110 1110,1230
much about performance,| but in
|但是在一般的操作系统设计者和CPU设计者中，

2875
01:24:57,220 --> 01:24:59,290
0,330 330,720 720,1290 1290,1920 1920,2070
general operating system designers and


2876
01:24:59,290 --> 01:25:01,630
0,270 300,660 660,1380 1560,1890 1890,2340
the CPU designers,| they're very
|他们非常感兴趣的是你能以多快的速度来做陷阱的效率。

2877
01:25:01,630 --> 01:25:02,920
0,540 540,690 690,960 990,1230 1230,1290
interested in the sort of


2878
01:25:02,920 --> 01:25:03,910
0,480 480,570 570,780 780,870 870,990
speed at which you can


2879
01:25:03,910 --> 01:25:06,310
0,510 720,990 990,1620 1620,1710 1710,2400
do a efficiency of traps.|
|

2880
01:25:08,040 --> 01:25:09,630
0,300 300,540 540,750 750,1020 1110,1590
xv6 does it does
Xv6以一种特殊的方式做所有这些事情，

2881
01:25:09,630 --> 01:25:10,290
0,120 120,270 270,510 510,600 600,660
all these things in a


2882
01:25:10,290 --> 01:25:11,910
0,450 450,690 690,1050 1080,1440 1440,1620
particular way,| there's certainly other
|当然还有其他方法可以做到这一点，

2883
01:25:11,910 --> 01:25:13,500
0,240 240,330 330,480 480,750 1200,1590
ways to do them,| a
|几个问题如果你设计问题替代方案，

2884
01:25:13,500 --> 01:25:15,300
0,210 210,1020 1020,1110 1110,1200 1200,1800
few questions if you design


2885
01:25:15,300 --> 01:25:16,950
0,630 630,1230 1230,1350 1350,1470 1470,1650
questions alternatives,| you could think
|你可以想一想，

2886
01:25:16,950 --> 01:25:19,950
0,420 870,1350 1860,2310 2310,2880 2880,3000
about,| {} one is can
|{}一个就是你能不能想办法把硬件方面或者软件方面，

2887
01:25:19,950 --> 01:25:20,790
0,120 120,300 300,360 360,750 750,840
you think of ways to


2888
01:25:20,790 --> 01:25:23,490
0,300 300,900 990,1950 1950,2190 2190,2700
make the hardware or software


2889
01:25:23,490 --> 01:25:25,410
0,690 690,780 780,1350 1350,1620 1620,1920
aspects,| you redesign {xv6 -},
|您重新设计{xv6-}，重新设计{RISC-V-}以使整个序列更简单

2890
01:25:25,410 --> 01:25:27,030
0,420 420,480 480,720 720,1170 1380,1620
redesign the {RISC-V -} to


2891
01:25:27,030 --> 01:25:28,650
0,120 120,270 270,450 450,930 930,1620
make this whole sequence simpler|
|

2892
01:25:29,490 --> 01:25:30,660
0,630 630,840 840,930 930,1110 1110,1170
or could you think of
或者你能想出让整个过程更快的方法吗？

2893
01:25:30,660 --> 01:25:31,680
0,390 390,480 480,720 720,810 810,1020
ways to make the whole


2894
01:25:31,680 --> 01:25:33,080
0,600 630,1170
sequence faster.|
|

2895
01:25:33,640 --> 01:25:34,540
0,420 420,600 600,660 660,840 840,900
Another sort of set of
另一组问题让你保持头脑清醒，

2896
01:25:34,540 --> 01:25:35,590
0,420 420,510 510,720 720,810 810,1050
questions to keep the back


2897
01:25:35,590 --> 01:25:39,100
0,120 120,600 1140,1710 2100,2940 3000,3510
your head,| {} is whether
|{}是恶意程序是否可以滥用这些机制中的任何一个来破坏隔离。

2898
01:25:39,100 --> 01:25:41,260
0,90 90,780 810,1080 1080,1530 1530,2160
or not a malicious programs


2899
01:25:41,260 --> 01:25:42,280
0,150 150,570 570,750 750,810 810,1020
could abuse any of these


2900
01:25:42,280 --> 01:25:43,880
0,780 780,1320
mechanisms to


2901
01:25:45,140 --> 01:25:47,300
0,510 510,1170
break isolation.|
|

2902
01:25:48,090 --> 01:25:49,560
0,540 570,810 810,1110 1140,1410 1410,1470
Alright that is all I
好了，这就是我对这堂课要说的全部内容。

2903
01:25:49,560 --> 01:25:50,190
0,90 90,210 210,360 360,480 480,630
have to say for this


2904
01:25:50,190 --> 01:25:51,930
0,600 630,1140 1170,1470 1470,1590 1590,1740
lecture.| I'm happy to take
|我很乐意回答大家的问题。

2905
01:25:51,930 --> 01:25:52,880
0,600
questions.|
|

2906
01:25:54,650 --> 01:25:55,820
0,240 240,540 540,660 660,810 810,1170
Um, sorry I have another
嗯，对不起，我还有另一个问题。

2907
01:25:55,820 --> 01:25:57,830
0,600 750,1170 1170,1170 1170,1650 1650,2010
question.| Please.| I saw there
|请。|我看到有一个{}{uie-}个注册表，

2908
01:25:57,830 --> 01:25:59,620
0,360 570,1050 1050,1500
is a {}


2909
01:25:59,820 --> 01:26:02,730
0,570 570,1320 1350,1950 1950,2430 2670,2910
{uie -} registers are,| yeah
|是的，我想注册为身份，

2910
01:26:02,730 --> 01:26:04,170
0,360 360,600 600,1080 1080,1230 1230,1440
I think register in as


2911
01:26:04,170 --> 01:26:05,060
0,720
status,|
|

2912
01:26:05,280 --> 01:26:06,480
0,210 210,330 330,630 630,840 840,1200
but we don't use it,|
但是我们不用它，|

2913
01:26:07,320 --> 01:26:08,970
0,180 180,390 390,810 960,1230 1230,1650
we just use, {} {sie
我们只需使用，{}{sie-}，并在用户空间中将其设置为false，

2914
01:26:08,970 --> 01:26:10,200
0,570 600,750 750,870 870,1080 1080,1230
-} and we set it


2915
01:26:10,200 --> 01:26:11,430
0,120 120,570 570,660 660,930 930,1230
to false in user space,|
|

2916
01:26:11,430 --> 01:26:12,580
0,210 210,390 390,540 540,1020
why couldn't we use
为什么我们不能用[你说得对]。

2917
01:26:12,980 --> 01:26:15,710
0,570 630,1230 1230,1650 1650,2010 2040,2730
the [you're right].| UIE gosh,
|天啊，答案是我不知道。

2918
01:26:16,900 --> 01:26:17,980
0,210 210,690 690,810 810,960 960,1080
the answer is gonna be


2919
01:26:17,980 --> 01:26:19,080
0,90 90,270 270,630
I don't know.|
|

2920
01:26:21,640 --> 01:26:23,120
0,720
Um.|
恩。|

2921
01:26:24,720 --> 01:26:26,520
0,330 330,720 720,1230 1230,1620 1620,1800
{} We're yes p what
{}我们是p我们说的是s，我们说的是{spie-]。

2922
01:26:26,520 --> 01:26:27,840
0,120 120,450 480,840 840,1170 1170,1320
we said is s, what


2923
01:26:27,840 --> 01:26:29,100
0,90 90,330 330,480 480,810 810,1260
we said is {SPIE -


2924
01:26:29,100 --> 01:26:30,400
0,360 360,360
- -].|
|

2925
01:26:30,550 --> 01:26:31,900
0,360 360,540 540,930 930,1140 1140,1350
We may actually end up
我们实际上可能最终会设置。

2926
01:26:31,900 --> 01:26:33,260
0,570
setting.|
|

2927
01:26:33,810 --> 01:26:35,070
0,480 510,630 630,750 750,1050 1050,1260
Um I know nothing about
嗯，我对{uie-}一无所知，我猜，

2928
01:26:35,070 --> 01:26:37,410
0,150 150,600 630,1080 1080,1410 1410,2340
{uie -}, I'm gonna guess,|
|

2929
01:26:37,590 --> 01:26:38,850
0,150 150,240 240,660 870,1080 1080,1260
let me see, I'm gonna
让我想想，我要猜猜这里到底发生了什么。

2930
01:26:38,850 --> 01:26:40,410
0,450 450,570 570,720 720,1080 1080,1560
guess that what actually happens


2931
01:26:40,410 --> 01:26:41,580
0,480
here.|
|

2932
01:26:42,510 --> 01:26:43,770
0,300 300,420 420,600 600,1020 1020,1260
{} In this code where
{}在此代码中，我们所在的位置。

2933
01:26:43,770 --> 01:26:44,660
0,450
we're.|
|

2934
01:26:45,800 --> 01:26:49,070
0,1230 2520,2790 2790,2910 2910,3150 3150,3270
Um, OK, so here we
嗯，好的，那么我们现在使用的是一个陷阱{re-we-}

2935
01:26:49,070 --> 01:26:51,170
0,390 390,930 1380,1650 1650,1710 1710,2100
are in use a trap


2936
01:26:51,170 --> 01:26:52,850
0,180 180,330 330,1020 1020,1170 1170,1680
{re-were -}| returning or setting
|返回或设置{spie-}{sstatus-}

2937
01:26:52,910 --> 01:26:54,830
0,420 420,840 840,1170 1170,1170 1170,1920
{SPIE - - -} {sstatus


2938
01:26:54,830 --> 01:26:58,790
0,810 1320,1800 2160,2550 2550,3450 3720,3960
-}| and I believe the
|我相信{sret-}指令会复制这个{spie-}

2939
01:26:58,790 --> 01:27:00,980
0,270 270,450 450,1020 1020,1230 1230,2190
{sret -} instruction will copy


2940
01:27:01,130 --> 01:27:02,360
0,300 300,540 540,990 990,1230 1230,1230
this {SPIE - - -}|
|

2941
01:27:02,810 --> 01:27:04,850
0,150 150,360 360,450 450,930 1110,2040
and this is this previous
这是这个以前的名字，

2942
01:27:04,880 --> 01:27:06,290
0,270 270,330 330,570 570,690 690,1410
name of this,| the supervisor
|管理程序先前中断使能，

2943
01:27:06,290 --> 01:27:09,050
0,600 600,1140 1140,1620 1920,2280 2280,2760
previous interrupt enable,| I suspect
|我怀疑SRET将该位复制到{}，

2944
01:27:09,050 --> 01:27:11,000
0,330 330,870 870,1140 1140,1620
sret copies that bit


2945
01:27:11,320 --> 01:27:13,120
0,630 630,1020 1020,1020
into the {},|
|

2946
01:27:15,120 --> 01:27:16,830
0,300 300,600 600,1020 1020,1590 1590,1710
into whatever controls interrupts and
进入任何控制中断和用户模式，

2947
01:27:16,830 --> 01:27:18,300
0,270 270,540 540,690 690,960 1050,1470
user mode,| which is possibly
|这可能是UIE，SSTATUS的一小部分，

2948
01:27:18,300 --> 01:27:19,660
0,90 90,1110
the uie,


2949
01:27:19,870 --> 01:27:22,300
0,300 330,630 630,1200 2100,2280 2280,2430
bit of sstatus,| as that
|这就是我的猜想。

2950
01:27:22,300 --> 01:27:23,300
0,180 180,780
for guess.|
|

2951
01:27:24,420 --> 01:27:25,900
0,270 270,510 510,780 780,1170
I see, thank you.
我明白了，谢谢你。

