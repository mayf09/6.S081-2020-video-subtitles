1
00:00:00,330 --> 00:00:03,360
0,1260 1260,1440 1440,1590 1590,1710 1710,3030
Yeah we're not so good.|
是啊，我们不是很好。|

2
00:00:06,650 --> 00:00:08,680
0,450 450,600 600,840 840,1440
Good, how about Erica,|
很好，那艾丽卡呢|

3
00:00:08,800 --> 00:00:10,160
0,150 150,270 270,630
{how's -} the
懒惰的实验室对你来说怎么样。

4
00:00:10,630 --> 00:00:11,590
0,240 240,360 360,510 510,630 630,960
{lazy -} lab for you.|
|

5
00:00:12,040 --> 00:00:13,090
0,330 330,330 330,810 810,990 990,1050
{} I also thought it
我也觉得还可以

6
00:00:13,090 --> 00:00:14,530
0,120 120,540 540,840 990,1170 1170,1440
was okay| and {} I
|而且我在复制和复制方面也有问题，

7
00:00:14,530 --> 00:00:15,610
0,240 240,450 450,510 510,900 900,1080
also had a bug with

8
00:00:15,610 --> 00:00:16,810
0,150 150,510 510,600 600,900 900,1200
the copyin and copyout {},|
|

9
00:00:16,810 --> 00:00:18,490
0,240 240,570 870,1080 1080,1230 1230,1680
but I got that result,|
但我拿到了结果，|

10
00:00:18,490 --> 00:00:20,700
0,390 780,1620
so yeah.|
所以是的。|

11
00:00:20,700 --> 00:00:21,600
0,270 270,360 360,510 510,600 600,900
{I,think} is one of those
我想这是那些棘手的案子之一

12
00:00:21,720 --> 00:00:22,650
0,270 270,570 570,660 660,750 750,930
tricky cases| that you might
|当你开始编程的时候，你可能没有想过。

13
00:00:22,650 --> 00:00:23,520
0,180 180,360 360,600 600,750 750,870
not think about when you

14
00:00:23,520 --> 00:00:25,140
0,330 330,900
start programming.|
|

15
00:00:26,390 --> 00:00:27,770
0,240 240,720 720,990 990,1290 1290,1380
But, luckily {usertests -} will
但是，幸运的是，用户测试会为您找到它。

16
00:00:27,770 --> 00:00:29,260
0,210 210,330 330,540 540,720
find it for you.|
|

17
00:00:33,180 --> 00:00:35,440
0,600 930,1770
The, Caroline.|
卡洛琳。|

18
00:00:37,580 --> 00:00:39,050
0,360 360,540 540,840 840,1080 1110,1470
{The,lab} is going good {},|
实验室进行得很顺利，|

19
00:00:39,080 --> 00:00:41,060
0,270 270,660 660,1050 1050,1380 1380,1980
I haven't finished yet actually.|
实际上我还没有做完。|

20
00:00:41,960 --> 00:00:43,910
0,600 1020,1380 1380,1440 1440,1710 1710,1950
{} Okay, I worry about
好吧，我想我担心复印。

21
00:00:43,910 --> 00:00:48,700
0,480 480,690 690,1080 1200,2160
copyin, I guess.| I.|
|我。|

22
00:00:52,560 --> 00:00:54,090
0,210 210,420 420,630 630,1020 1020,1530
How about {} Kendall Garner.|
肯德尔·加纳怎么样。|

23
00:00:55,920 --> 00:00:57,030
0,420 450,720 720,810 810,900 900,1110
I think for the most
我想在很大程度上，

24
00:00:57,030 --> 00:00:59,190
0,360 360,570 1110,1650 1740,1860 1860,2160
part of the,| it was
|对我来说还不算太糟，

25
00:00:59,250 --> 00:01:01,440
0,570 570,750 750,1260 1770,1950 1950,2190
not too bad for me,|
|

26
00:01:01,440 --> 00:01:02,820
0,420 420,510 510,840 840,1170 1170,1380
probably the weirdest coverage was
可能最奇怪的报道是试图找出它何时低于堆栈的界限。

27
00:01:02,820 --> 00:01:04,230
0,480 480,780 780,1140 1140,1260 1260,1410
trying to figure out when

28
00:01:04,230 --> 00:01:06,450
0,120 120,450 570,1200 1230,2070 2070,2220
it went below bounds of

29
00:01:06,450 --> 00:01:07,440
0,120 120,570
the stack.|
|

30
00:01:07,440 --> 00:01:08,340
0,420

31
00:01:08,760 --> 00:01:10,020
0,420 420,930
{} Yeah.|
嗯。|

32
00:01:10,370 --> 00:01:11,270
0,240 240,450 450,540 540,630 630,900
Yeah you do the guard
是的，你基本上是做警卫专页的。

33
00:01:11,270 --> 00:01:12,680
0,300 300,810
page basically.|
|

34
00:01:16,760 --> 00:01:17,820
0,600
Good.|
好的。|

35
00:01:18,810 --> 00:01:21,300
0,600 630,1200 1410,1920 1920,2310 2310,2490
Okay, well it's about time
好了，差不多该开始了。

36
00:01:21,300 --> 00:01:22,660
0,90 90,210 210,720
to get started.|
|

37
00:01:22,820 --> 00:01:25,250
0,690 690,1020 1050,1680 1710,2130 2280,2430
{} So welcome to the
欢迎来到下一堂课，第6季第081节，

38
00:01:25,250 --> 00:01:27,200
0,240 240,930 930,1050 1050,1440 1470,1950
next lecture, in the {6.S081

39
00:01:27,200 --> 00:01:29,090
0,420 540,1050 1050,1230 1230,1500 1500,1890
-},| wherever you are, whatever
|无论你在哪里，不管是什么时区。

40
00:01:29,090 --> 00:01:30,300
0,210 210,570
time zone.|
|

41
00:01:30,300 --> 00:01:31,540
0,720

42
00:01:31,540 --> 00:01:33,400
0,180 180,480 480,810 810,1170 1200,1860
So today's lecture is locks.|
所以今天的课程是锁。|

43
00:01:33,940 --> 00:01:35,860
0,1020 1020,1380 1380,1620 1620,1710 1710,1920
Yeah you probably have seen
是啊，你们可能在以前的课上见过锁，

44
00:01:35,860 --> 00:01:37,870
0,390 390,750 750,1020 1050,1380 1380,2010
locks in {} previous classes,|
|

45
00:01:38,050 --> 00:01:39,880
0,690 690,990 990,1110 1110,1380 1410,1830
{} or at least being
或者至少以这样或那样的方式与他们接触，

46
00:01:39,880 --> 00:01:40,690
0,180 180,420 420,570 570,750 750,810
in touch with them in

47
00:01:40,690 --> 00:01:42,370
0,240 240,450 450,480 480,1440 1440,1680
some way or another,| and
|所以这堂课有点概念性的讲课，

48
00:01:42,370 --> 00:01:43,360
0,180 300,570 570,780 780,840 840,990
so this lecture a little

49
00:01:43,360 --> 00:01:44,890
0,120 120,180 180,270 270,660 660,1530
bit of a conceptual lecture,|
|

50
00:01:44,890 --> 00:01:45,850
0,180 180,540 540,600 600,780 780,960
may overlap a little bit
可能与您以前见过的一些东西有一点重叠

51
00:01:45,850 --> 00:01:47,440
0,120 120,390 390,1020 1260,1470 1470,1590
with some {} things you've

52
00:01:47,440 --> 00:01:49,390
0,150 150,510 510,870 870,1290 1290,1950
seen before| for locks will
|因为锁将更关注内核和操作系统。

53
00:01:49,780 --> 00:01:50,470
0,180 180,210 210,360 360,510 510,690
have a little bit more

54
00:01:50,470 --> 00:01:51,580
0,90 90,270 270,690 690,810 810,1110
of a kernel and OS

55
00:01:51,580 --> 00:01:52,500
0,570
focus.|
|

56
00:01:52,560 --> 00:01:53,730
0,420 420,570 570,840 840,930 930,1170
And that changes a couple
这改变了几件事。

57
00:01:53,730 --> 00:01:54,660
0,390
things.|
|

58
00:01:54,750 --> 00:01:56,970
0,600 660,1170 1170,1470 1470,1680 1680,2220
{} Just to get started,|
只是为了开始，|

59
00:01:57,000 --> 00:01:59,160
0,480 480,810 810,1410 1440,2010 2010,2160
let's remind ourselves why we
让我们提醒自己为什么我们需要锁，

60
00:01:59,160 --> 00:02:01,500
0,270 270,810 900,1440 1920,2250 2250,2340
need locks,| {} {} you
|你知道吗，我想我们的出发点真的是

61
00:02:01,500 --> 00:02:02,400
0,180 180,390 390,570 570,660 660,900
know I guess the starting

62
00:02:02,400 --> 00:02:03,960
0,210 210,300 300,510 510,660 660,1560
point is really that| applications
|应用程序那么，您想要使用多核吗。

63
00:02:05,070 --> 00:02:06,330
0,660 750,990 990,1050 1050,1110 1110,1260
well, want do you use

64
00:02:06,330 --> 00:02:07,680
0,330 330,840
multiple cores.|
|

65
00:02:12,190 --> 00:02:13,120
0,270 270,420 420,480 480,600 600,930
They want to use multiple
他们希望使用多核来获得性能。

66
00:02:13,120 --> 00:02:14,800
0,240 240,300 300,420 420,1110
cores to get performance.|
|

67
00:02:17,040 --> 00:02:18,000
0,180 180,300 300,390 390,480 480,960
And so if an application
因此，如果一个应用程序实际上，

68
00:02:18,000 --> 00:02:20,760
0,480 480,870 870,870 2130,2400 2400,2760
actually,| {} {} want to
|希望在多核上运行

69
00:02:20,760 --> 00:02:22,170
0,480 480,570 570,870 870,1230 1230,1410
run on multiple cores| and
|并且(假设)希望核心是应用程序的一部分可以调用系统调用

70
00:02:22,170 --> 00:02:24,390
0,330 330,600 600,1680 1680,2100 2100,2220
[presumably] wants the cores are

71
00:02:24,390 --> 00:02:25,320
0,240 240,300 300,390 390,810 810,930
part of the application may

72
00:02:25,320 --> 00:02:27,030
0,300 300,540 540,1050 1260,1590 1590,1710
invoke system calls| and so
|因此内核必须能够处理，

73
00:02:27,030 --> 00:02:27,990
0,90 90,420 420,600 600,690 690,960
the kernel must be able

74
00:02:27,990 --> 00:02:29,320
0,120 120,720
to handle,|
|

75
00:02:31,320 --> 00:02:32,220
0,90 90,210 210,510 510,600 600,900
{} was handed {} parallel
被传递给并行系统调用。

76
00:02:32,220 --> 00:02:33,520
0,240 240,660
system calls.|
|

77
00:02:45,440 --> 00:02:46,910
0,480 480,600 600,780 780,1170 1170,1470
{} And that means that
这意味着您知道系统调用在不同的内核上并行运行，

78
00:02:46,910 --> 00:02:48,590
0,120 120,270 270,930 930,1290 1290,1680
you know the system calls

79
00:02:48,590 --> 00:02:50,120
0,270 270,390 390,1020 1020,1230 1230,1530
run in parallel on different

80
00:02:50,120 --> 00:02:53,150
0,510 780,1410 1410,1620 1620,2220 2220,3030
cores,| they may actually access
|它们实际上可以访问共享数据结构。

81
00:02:53,680 --> 00:02:55,500
0,360 360,570 570,1170
shared data structures.|
|

82
00:02:58,360 --> 00:03:00,200
0,120 120,570 570,630 630,1290
The instructions in parallel.|
这些指令是并行的。|

83
00:03:04,390 --> 00:03:05,470
0,300 300,390 390,780 780,990 990,1080
And as you've seen by
正如你现在已经看到的，

84
00:03:05,470 --> 00:03:07,180
0,360 360,690 690,1020 1020,1350 1350,1710
now,| actually {xv6 -} ask
|实际上，xv6要求相当多的共享数据结构。

85
00:03:07,180 --> 00:03:08,740
0,360 360,390 390,720 720,1020 1230,1560
quite a number of shared

86
00:03:08,740 --> 00:03:10,390
0,210 210,750 840,1230 1230,1350 1350,1650
data structures| what's the proc
|PROC的结构是什么

87
00:03:10,390 --> 00:03:13,270
0,660 660,1080 1620,2580 2580,2760 2760,2880
structures| or, {} you know
|或者，你知道的[嘀嗒]

88
00:03:13,300 --> 00:03:16,480
0,480 480,1170 1200,1320 1320,1830 2760,3180
[ticks]| or you know later
|或者稍后我们会看到缓冲区缓存，

89
00:03:16,480 --> 00:03:17,860
0,120 120,540 540,660 660,900 900,1380
we'll see the buffer cache,|

90
00:03:17,860 --> 00:03:18,880
0,60 60,210 210,420 420,810 810,1020
you know there's actually a
您知道，实际上有大量的共享数据结构。

91
00:03:18,880 --> 00:03:20,170
0,240 240,330 330,540 540,750 750,1290
ton of shared data structures.|
|

92
00:03:20,960 --> 00:03:23,090
0,600 600,1170 1170,1650 1770,1950 1950,2130
{} And so if you
因此，如果你有并行访问，你就知道一个数据结构

93
00:03:23,090 --> 00:03:24,590
0,360 360,780 780,1260 1260,1380 1380,1500
have parallel access, you know

94
00:03:24,590 --> 00:03:26,300
0,450 450,780 780,1020 1020,1560 1560,1710
to a data structure| in
|在其中一个核心中写入

95
00:03:26,300 --> 00:03:28,580
0,240 240,330 330,1110 1680,2160 2160,2280
one of the cores are

96
00:03:28,580 --> 00:03:29,150
0,210 210,300 300,390 390,450 450,570
write there| and the other
|并读取其他核心

97
00:03:29,150 --> 00:03:30,920
0,390 390,480 480,720 720,960 1260,1770
cores are read| or {}
|或者您知道，由于共享数据结构，我们基本上锁定以协调这些更新，

98
00:03:30,920 --> 00:03:32,420
0,150 150,270 270,540 540,900 900,1500
you know we basically locks

99
00:03:32,660 --> 00:03:34,130
0,90 90,750 750,930 930,1350 1350,1470
to coordinate these updates due

100
00:03:34,130 --> 00:03:35,240
0,90 90,300 300,540 540,960 960,1110
to shared data structure,| so
|这样读者就能看到一致的观点。

101
00:03:35,240 --> 00:03:37,160
0,390 690,930 930,1290 1290,1500 1500,1920
that on readers see consistent

102
00:03:37,160 --> 00:03:37,880
0,270
view.|
|

103
00:03:38,310 --> 00:03:40,100
0,450 450,600 600,690 690,1260
So we need locks,|
所以我们需要锁，|

104
00:03:41,070 --> 00:03:42,500
0,300 300,930
{you,know} to,|
你知道的，|

105
00:03:43,320 --> 00:03:45,120
0,360 360,750 750,1230
therefore, control sharing,
因此，控制共享，才能正确共享。

106
00:03:45,520 --> 00:03:47,380
0,390 390,720 720,1320
for correct sharing.|
|

107
00:03:52,010 --> 00:03:54,110
0,630 930,1350 1350,1530 1530,1740 1740,2100
Now, now this is sometimes
现在，现在这有时有点(令人沮丧)。

108
00:03:54,110 --> 00:03:54,830
0,270 270,450 450,570 570,660 660,720
a little bit of a

109
00:03:54,830 --> 00:03:55,860
0,480
[bummer].|
|

110
00:03:55,860 --> 00:03:58,080
0,390 390,750 750,1470 1770,2070 2070,2220
{} Because we want these
因为我们想要这些并行访问，

111
00:03:58,080 --> 00:04:01,650
0,300 300,990 1380,1830 1860,2670 2670,3570
parallel access,| we run multiple
|我们在不同的内核上并行运行多个一致的调用，

112
00:04:01,680 --> 00:04:04,440
0,420 420,780 780,1500 1560,2370 2370,2760
consistent calls in parallel on

113
00:04:04,440 --> 00:04:06,450
0,90 90,390 390,900 1260,1740 1770,2010
{} different cores,| {} but
|但不幸的是，如果它们共享数据结构，

114
00:04:06,450 --> 00:04:08,460
0,630 630,1140 1140,1530 1530,1710 1710,2010
unfortunately, {} if they share

115
00:04:08,460 --> 00:04:10,020
0,420 420,990 990,1170 1170,1380 1380,1560
data structures,| {you,know} they need
|你知道他们需要锁

116
00:04:10,020 --> 00:04:11,610
0,480 480,660 660,1080 1080,1230 1230,1590
locks| and locks, {you,know} {serialize
|和锁，你知道基本上序列化操作

117
00:04:11,610 --> 00:04:14,370
0,480 510,1260 1260,2010 2310,2490 2490,2760
-} basically operations| and so
|因此，事实上，它们最终都是锁，可能会限制性能。

118
00:04:14,370 --> 00:04:15,510
0,90 90,420 570,720 720,840 840,1140
in fact they were {locks,in}

119
00:04:15,510 --> 00:04:17,160
0,150 150,330 330,690 690,960 960,1650
the end can limit performance.|
|

120
00:04:27,320 --> 00:04:27,860
0,120 120,240 240,330 330,480 480,540
And so we're sort of
所以我们现在的处境有点棘手，

121
00:04:27,860 --> 00:04:29,390
0,90 90,300 300,570 570,1050 1050,1530
in a tricky situation,| where
|为了准确起见，我们需要锁，

122
00:04:29,390 --> 00:04:30,380
0,90 90,300 300,390 390,840 840,990
you know for correctness, we

123
00:04:30,380 --> 00:04:31,700
0,210 210,690 690,810 810,1050 1050,1320
need locks,| you know, but
|你知道，但就表演而言，它们不是很好。

124
00:04:31,700 --> 00:04:33,290
0,90 90,870 960,1170 1170,1380 1380,1590
for performance, {} they're not

125
00:04:33,290 --> 00:04:34,160
0,300
good.|
|

126
00:04:34,600 --> 00:04:36,070
0,450 480,780 780,900 900,1020 1020,1470
{} But you know there's
但你知道，生活中将会有这样一个事实

127
00:04:36,070 --> 00:04:36,910
0,120 120,180 180,420 420,540 540,840
going to be a fact

128
00:04:36,910 --> 00:04:39,460
0,90 90,510 510,1380 1410,1770 1770,2550
of life| and we'll see
|我们会看看能做些什么。

129
00:04:39,760 --> 00:04:40,750
0,300 300,390 390,600 600,840 840,990
what can do about it.|
|

130
00:04:41,300 --> 00:04:42,170
0,390 390,540 540,660 660,780 780,870
{} But that's sort of
但这是这里最高级别的场景

131
00:04:42,170 --> 00:04:44,030
0,300 300,570 570,960 960,1410 1440,1860
the top level {} scenario

132
00:04:44,030 --> 00:04:45,800
0,450 720,1080 1080,1200 1200,1350 1350,1770
here| and you know maybe
|你知道，也许真的，你知道，带来了这一点，

133
00:04:45,800 --> 00:04:47,810
0,270 270,750 780,1290 1290,1380 1380,2010
just to really you know

134
00:04:47,840 --> 00:04:49,610
0,390 390,780 780,1080 1080,1230 1230,1770
brings {this,point},| why do applications
|为什么应用程序实际上需要多核

135
00:04:49,610 --> 00:04:51,710
0,240 240,450 450,600 960,1680 1680,2100
actually want {} multiple cores|
|

136
00:04:51,920 --> 00:04:52,790
0,180 180,480 480,660 660,810 810,870
and that really has to
这确实与你的技术趋势有关，

137
00:04:52,790 --> 00:04:54,650
0,150 150,510 510,690 690,1350 1350,1860
do with your technology trends,|
|

138
00:04:54,650 --> 00:04:55,520
0,120 120,240 240,450 450,540 540,870
you know over the last
你知道在过去的几十年里。

139
00:04:55,640 --> 00:04:56,900
0,240 240,840
couple decades.|
|

140
00:04:56,900 --> 00:04:57,830
0,240 240,540 540,660 660,750 750,930
{} And you know there's
你知道有一些经典的图表，

141
00:04:57,830 --> 00:04:59,330
0,150 150,210 210,330 330,960 960,1500
sort of this classic graphs,|
|

142
00:04:59,330 --> 00:05:00,110
0,180 180,330 330,390 390,600 600,780
that sort of make these
这在某种程度上说明了这些观点，

143
00:05:00,110 --> 00:05:01,760
0,510 720,960 960,1110 1110,1230 1230,1650
points,| {} so let me
|所以让我调出其中一个，

144
00:05:02,090 --> 00:05:02,990
0,270 270,330 330,510 510,570 570,900
pull up one of them,|
|

145
00:05:02,990 --> 00:05:03,590
0,240 240,270 270,420 420,510 510,600
there's a little bit of
这是一个有点复杂的图表，

146
00:05:03,590 --> 00:05:05,450
0,60 60,570 570,1140 1140,1620 1740,1860
a complicated graph,| {} you
|你知道，在x轴和y轴上，

147
00:05:05,450 --> 00:05:06,840
0,90 90,300 300,960
know there's here's,

148
00:05:06,900 --> 00:05:08,300
0,840
{on,the}

149
00:05:08,720 --> 00:05:10,670
0,240 240,750 750,1140 1140,1620 1620,1950
x axis and y axis,|
|

150
00:05:10,670 --> 00:05:13,040
0,510 570,840 870,1500 1620,2130 2130,2370
there's {you,know} units or different
根据我们看到的是哪条线，有不同的单位或不同类型的单位。

151
00:05:13,040 --> 00:05:14,330
0,180 180,240 240,450 450,870 870,1290
types of units depending on

152
00:05:14,330 --> 00:05:15,500
0,270 270,540 540,630 630,900 900,1170
which line we're looking at.|
|

153
00:05:16,140 --> 00:05:17,070
0,270 270,390 390,450 450,600 600,930
{} But the thing that
但是真正看起来的东西，

154
00:05:17,070 --> 00:05:17,880
0,210 210,450 450,600 600,690 690,810
really look at,| it is
|就是，过去几年发生的事情，

155
00:05:17,880 --> 00:05:20,790
0,270 750,1290 1560,2130 2130,2310 2310,2910
that, {} what has happened

156
00:05:20,820 --> 00:05:22,440
0,480 510,780 780,1020 1020,1230 1230,1620
in the last couple years,|
|

157
00:05:22,440 --> 00:05:24,690
0,570 570,810 810,1380 1380,1620 1620,2250
the last decades is that.|
过去几十年的情况就是这样。|

158
00:05:25,260 --> 00:05:26,250
0,180 180,570 570,720 720,810 810,990
So starting in the two
所以从两千人开始，

159
00:05:26,250 --> 00:05:28,920
0,690 690,1380 1380,1560 1560,1890 1890,2670
thousands,| that the clock frequency
|时钟频率并没有真正增加。

160
00:05:29,220 --> 00:05:30,690
0,330 330,570 570,1020 1020,1140 1140,1470
hasn't really increased any more.|
|

161
00:05:31,320 --> 00:05:33,330
0,660 660,870 870,1260 1260,1470 1470,2010
{} So basically this has
因此，基本上这已经停滞不前，持续不变。

162
00:05:33,630 --> 00:05:34,960
0,780
plateaued,

163
00:05:35,140 --> 00:05:36,560
0,780
constant.|
|

164
00:05:37,000 --> 00:05:39,820
0,570 1050,1800 2070,2220 2220,2310 2310,2820
{} And as a result,
因此，内核的基本单线程性能

165
00:05:39,850 --> 00:05:42,400
0,600 600,1200 1230,1560 1560,2310 2340,2550
basically single thread performance of

166
00:05:42,400 --> 00:05:46,090
0,300 300,930 1230,2100 2460,3120 3120,3690
core| also basically has reached
|也基本达到了极限，你知道高原。

167
00:05:46,090 --> 00:05:47,980
0,450 450,870 900,1290 1290,1380 1380,1890
{} limit {you,know} {} plateau.|
|

168
00:05:52,060 --> 00:05:53,530
0,510 510,960 960,1320 1320,1380 1380,1470
{} And yet on the
然而另一方面，

169
00:05:53,530 --> 00:05:55,060
0,180 180,450 450,810 810,960 960,1530
other hand,| given of cores
考虑到芯数，晶体管的数量在同一时间段内仍在增加，

170
00:05:55,270 --> 00:05:56,200
0,90 90,270 270,330 330,780 780,930
the number of transistors {}

171
00:05:56,200 --> 00:05:57,700
0,390 420,720 720,840 840,1350 1350,1500
still has been increasing over

172
00:05:57,700 --> 00:05:59,230
0,90 90,330 330,570 570,930 1290,1530
the same time period,| so
|因此，如果你喜欢使用晶体管使单个核心运行得更快，

173
00:05:59,230 --> 00:06:00,190
0,90 90,210 210,540 540,780 780,960
if you can like you

174
00:06:00,190 --> 00:06:01,360
0,330 330,840 840,930 930,1110 1110,1170
use transistors to make a

175
00:06:01,360 --> 00:06:02,980
0,390 390,690 690,810 810,1050 1050,1620
single core would run faster,|
|

176
00:06:03,250 --> 00:06:04,510
0,540 540,750 750,840 840,1080 1080,1260
{} yeah the only other
是的，唯一的其他选择基本上必须有多个内核

177
00:06:04,510 --> 00:06:05,740
0,240 240,570 570,840 840,1020 1020,1230
option basically have to have

178
00:06:05,740 --> 00:06:06,790
0,330 330,660 660,810 810,870 870,1050
multiple cores| and you see
|而且你确实看到从二零零一年开始，或者从将近二零零零年开始，

179
00:06:06,790 --> 00:06:08,470
0,360 360,690 690,1050 1050,1200 1200,1680
indeed that starting from {2001,or

180
00:06:08,470 --> 00:06:10,240
0,510 630,840 840,960 960,1200 1200,1770
- -} {from,nearly -} 2000

181
00:06:10,240 --> 00:06:11,230
0,330 330,390 390,600 600,690 690,990
{},| the number of cores
|内核的数量已经减少了。

182
00:06:11,230 --> 00:06:12,240
0,120 120,300 300,630
has gone off.|
|

183
00:06:13,500 --> 00:06:14,490
0,150 150,270 270,420 420,510 510,990
And so there's an application
因此，有一个应用程序需要更高的性能，

184
00:06:14,490 --> 00:06:16,650
0,150 150,300 300,1080 1410,1590 1590,2160
wants more performance,| you know,
|你知道，你可以依靠一个核心，

185
00:06:16,650 --> 00:06:17,970
0,450 480,690 690,960 960,1200 1200,1320
{} you [can] rely on

186
00:06:17,970 --> 00:06:19,290
0,30 30,300 300,660 660,990 990,1320
a single core,| basically half
|基本上有一半是通过利用多个内核来实现的。

187
00:06:19,290 --> 00:06:21,080
0,150 150,570 570,900 900,1350
through exploiting multiple cores.|
|

188
00:06:21,170 --> 00:06:22,100
0,120 120,360 360,540 540,810 810,930
And also, this means if
而且，这意味着如果应用程序是内核密集型或非内核密集型，

189
00:06:22,100 --> 00:06:23,390
0,90 90,660 660,990 990,1080 1080,1290
an application is you know

190
00:06:23,390 --> 00:06:25,460
0,420 420,990 990,1110 1110,1350 1350,2070
kernel intensive or less intensive,|
|

191
00:06:25,460 --> 00:06:28,430
0,90 90,450 450,870 1320,2190 2340,2970
you know a server {}
你知道一台服务器，那就意味着

192
00:06:28,490 --> 00:06:29,450
0,390 390,540 540,750 750,840 840,960
then that means that| the
|操作系统还必须在多核上高效运行。

193
00:06:29,450 --> 00:06:30,500
0,270 270,540 540,750 750,930 930,1050
operating system also has to

194
00:06:30,500 --> 00:06:33,170
0,450 480,1140 1170,1950 1950,2520 2520,2670
be, {} run efficiently on

195
00:06:33,170 --> 00:06:34,360
0,330 330,780
multiple cores.|
|

196
00:06:34,740 --> 00:06:35,970
0,180 180,330 330,420 420,750 750,1230
So that's the main reason,|
所以这是主要原因，|

197
00:06:36,330 --> 00:06:37,950
0,540 540,690 690,990 990,1290 1290,1620
{} you know, we're very
你知道，我们对内核中的并行性非常感兴趣。

198
00:06:37,950 --> 00:06:41,550
0,510 510,1080 1140,1710 1980,2970 2970,3600
interested in {} parallelism within

199
00:06:41,550 --> 00:06:43,100
0,660 660,1050
the kernel.|
|

200
00:06:45,120 --> 00:06:46,840
0,240 240,570 570,780 780,1200
Any questions about this?|
对此有什么问题吗？|

201
00:06:52,020 --> 00:06:53,010
0,210 210,300 300,540 540,660 660,990
Okay, I've assume I I
好的，我假设我我假设你以前看过其中的一些图表，

202
00:06:53,010 --> 00:06:53,850
0,300 300,420 420,540 540,720 720,840
assume that you've seen some

203
00:06:53,850 --> 00:06:55,230
0,60 60,210 210,630 690,1200 1200,1380
of these graphs before,| but
|但这很好地提醒了我们

204
00:06:55,230 --> 00:06:56,580
0,210 240,750 750,840 840,1110 1110,1350
it's good to remind us|
|

205
00:06:56,580 --> 00:06:57,600
0,330 330,390 390,720 720,930 930,1020
what the starting point of
所有讨论的出发点是什么。

206
00:06:57,600 --> 00:06:59,140
0,180 180,720 720,960
{all,the} discussion is.|
|

207
00:07:00,660 --> 00:07:02,080
0,120 120,420 420,840
So why locks.|
那为什么要上锁呢。|

208
00:07:02,960 --> 00:07:04,280
0,240 240,600 600,900 900,990 990,1320
You already hinted at this,|
你已经暗示过这一点了，|

209
00:07:04,280 --> 00:07:07,400
0,90 90,180 180,1080 1290,2070 2460,3120
you know, therefore correctness {},|
你知道，因此是正确的，|

210
00:07:07,400 --> 00:07:09,740
0,570 570,720 720,1260 1290,1710 1710,2340
if we have {you,know} readers
如果有，您就知道读取器和写入器正在访问共享数据结构

211
00:07:09,740 --> 00:07:11,330
0,180 210,810 810,930 930,1350 1350,1590
and writers are accessing shared

212
00:07:11,330 --> 00:07:13,130
0,210 210,750 1110,1590 1590,1680 1680,1800
data structure| and you know
|你知道出了什么问题，

213
00:07:13,130 --> 00:07:14,270
0,90 90,270 270,390 390,570 570,1140
the thing that goes wrong,|
|

214
00:07:14,270 --> 00:07:16,010
0,480 480,1170 1170,1410 1410,1470 1470,1740
is we want to avoid
我们想要避免比赛条件。

215
00:07:16,010 --> 00:07:17,180
0,210 210,870
race conditions.|
|

216
00:07:23,830 --> 00:07:25,000
0,150 150,270 270,510 510,660 660,1170
If you don't have locks,|
如果你没有锁，|

217
00:07:25,150 --> 00:07:25,780
0,150 150,240 240,360 360,540 540,630
you know we run the
你知道我们在冒险，

218
00:07:25,780 --> 00:07:26,920
0,450 480,600 600,750 750,1020 1020,1140
risk,| you know we have
|你知道我们有共享的数据结构，

219
00:07:26,920 --> 00:07:27,850
0,150 150,360 360,750 750,870 870,930
shared data structures,| that we're
|我们会有，我们会有比赛条件

220
00:07:27,850 --> 00:07:30,640
0,120 120,180 180,690 1050,1740 2040,2790
going to have, {} we're

221
00:07:30,850 --> 00:07:33,250
0,420 420,480 480,570 570,1500 1800,2400
going to have race conditions|
|

222
00:07:33,250 --> 00:07:34,600
0,420 600,810 810,990 990,1200 1200,1350
and it turns out that
事实证明，在比赛条件下是相当烦人的，

223
00:07:34,600 --> 00:07:36,790
0,150 150,360 360,780 780,1620 1770,2190
in race conditions are pretty

224
00:07:36,790 --> 00:07:39,490
0,540 630,1140 1500,1740 1740,2280 2280,2700
annoying,| {} so justly first
|所以理所当然地首先对它的实际情况有了一点了解，

225
00:07:39,490 --> 00:07:40,270
0,330 330,390 390,600 600,690 690,780
got a little bit of

226
00:07:40,270 --> 00:07:41,230
0,300 300,360 360,540 540,630 630,960
sense of what it actually

227
00:07:41,230 --> 00:07:43,180
0,390 540,1110 1110,1290 1290,1410 1410,1950
is,| let's look at the
|让我们看一下在xv6中创建争用条件

228
00:07:43,210 --> 00:07:45,280
0,870 870,1350 1380,1470 1470,1680 1680,2070
let's create a race condition

229
00:07:45,280 --> 00:07:46,630
0,120 120,840 840,1110 1110,1290 1290,1350
in xv6| and sort of
|然后看看它到底是怎么表现出来的

230
00:07:46,630 --> 00:07:47,680
0,210 210,390 390,510 510,780 780,1050
see how it actually shows

231
00:07:47,680 --> 00:07:49,090
0,300 300,450 450,690 690,1230 1230,1410
up| and then understand like
|然后才能理解实际发生的事情。

232
00:07:49,090 --> 00:07:50,380
0,330 330,600 600,930
what actually happened.|
|

233
00:07:51,100 --> 00:07:54,500
0,510 840,1020 1020,1680 2070,2910
Alright, so here's {}
好的，这是kalloc.c中的函数kfree。

234
00:07:55,010 --> 00:07:56,540
0,90 90,480 480,690 690,930 930,1530
the function {} {kfree -}

235
00:07:56,600 --> 00:07:58,370
0,450 450,900 900,1290 1290,1500 1500,1770
{} in {kalloc.c - -}.|
|

236
00:07:58,370 --> 00:07:59,090
0,90 90,270 270,510 510,630 630,720
You know this is the
你知道这是一个免费的功能，

237
00:07:59,090 --> 00:08:01,010
0,330 330,480 480,1050 1410,1800 1800,1920
function that frees,| after you
|在你的免费页面之后，它会推入免费列表，

238
00:08:01,010 --> 00:08:02,060
0,240 240,570 570,660 660,900 900,1050
free page, it pushes on

239
00:08:02,060 --> 00:08:03,650
0,90 90,300 300,690 750,990 990,1590
the free list,| there's {}
|那里的内核有一个非常简单的数据结构

240
00:08:03,680 --> 00:08:04,820
0,330 330,510 510,540 540,840 840,1140
kernel has a very simple

241
00:08:04,820 --> 00:08:05,810
0,240 240,600 600,660 660,870 870,990
data structure| to keep the
|保存所有空闲页面的空闲列表。

242
00:08:05,810 --> 00:08:06,620
0,210 210,420 420,510 510,660 660,810
free list of all free

243
00:08:06,620 --> 00:08:07,700
0,570
pages.|
|

244
00:08:07,700 --> 00:08:09,050
0,540 540,690 690,840 840,1020 1020,1350
{} So that when kalloc
所以当卡洛克需要注意的时候，从自由撰稿人那里抓起。

245
00:08:09,050 --> 00:08:10,370
0,180 180,240 240,420 420,990 990,1320
needs to pay attention grabbing

246
00:08:10,370 --> 00:08:11,620
0,90 90,180 180,750
from the freelist.|
|

247
00:08:11,620 --> 00:08:12,700
0,300 300,390 390,540 540,870 870,1080
Next you see here, goes
接下来你在这里看到，分配有一个。

248
00:08:12,700 --> 00:08:17,230
0,1470 1830,2610 2610,2820 2820,3420 3870,4530
{} allocation has one {}.|

249
00:08:17,780 --> 00:08:19,500
0,600 630,1140

250
00:08:19,500 --> 00:08:20,400
0,60 60,270 270,600 600,720 720,900
The memory allocator has one
内存分配器有一个锁kmem锁

251
00:08:20,400 --> 00:08:22,920
0,390 390,780 780,1260 1620,2280 2280,2520
lock kmem lock| and {}
|在这里，它实际上更新了空闲列表

252
00:08:22,920 --> 00:08:24,120
0,330 330,390 390,690 690,1080 1080,1200
here it actually updates the

253
00:08:24,120 --> 00:08:26,670
0,180 180,660 960,1620 1650,2190 2190,2550
free list| {} [{with,in}] page
|[With In]刚刚释放的页面或没有参数的页面。

254
00:08:26,670 --> 00:08:27,780
0,150 150,330 330,480 480,660 660,1110
that just has been freed

255
00:08:27,810 --> 00:08:29,820
0,360 360,720 720,1200 1200,1500
or the argument free.|
|

256
00:08:29,880 --> 00:08:30,510
0,270 270,360 360,480 480,540 540,630
So we're going to do
所以我们要做的就是注释掉这两个Acquisition Release，

257
00:08:30,510 --> 00:08:31,740
0,120 120,450 510,720 720,1020 1020,1230
is like just comment out

258
00:08:31,740 --> 00:08:33,180
0,240 240,870
these two

259
00:08:33,180 --> 00:08:35,640
0,300 300,810 810,960 960,1590 1620,2460
acquire release,| that basically mark
|这基本上标志着你知道获得了锁，

260
00:08:35,640 --> 00:08:37,260
0,90 90,210 210,600 990,1530 1530,1620
you know the acquiring of

261
00:08:37,260 --> 00:08:38,340
0,90 90,420 420,510 510,720 720,1080
the lock,| and then releasing
|然后释放锁，

262
00:08:38,340 --> 00:08:39,450
0,90 90,450 450,540 540,840 840,1110
the lock,| you know and
|你知道，所以这，这段代码

263
00:08:39,450 --> 00:08:41,070
0,90 90,450 450,720 720,1350 1380,1620
so this, this, this, this

264
00:08:41,070 --> 00:08:42,120
0,210 210,300 300,690 690,990 990,1050
piece of code| that's in
|那是在过去的中间，

265
00:08:42,120 --> 00:08:43,560
0,90 90,540 840,1170 1170,1380 1380,1440
the middle that used to

266
00:08:43,560 --> 00:08:45,690
0,450 840,870 870,1470 1470,1830 1830,2130
be,| {} there's not more
|没有更多的东西不再被原子地执行了。

267
00:08:45,690 --> 00:08:47,130
0,90 90,300 300,480 480,960 960,1440
is not being executed anymore

268
00:08:47,130 --> 00:08:48,560
0,210 240,1020
and atomically.|
|

269
00:08:49,350 --> 00:08:50,500
0,600

270
00:08:50,590 --> 00:08:51,740
0,840

271
00:08:54,100 --> 00:08:56,460
0,750 780,1050 1050,1200 1200,1740
So let's do that,|
所以我们就这么做吧，|

272
00:08:56,910 --> 00:08:59,600
0,510 510,1080 1110,1320 1320,2010
{} and then run
然后运行QEMU，

273
00:09:01,500 --> 00:09:03,940
0,300 300,810 840,1230 1230,1830
{QEMU -},| so {compile,it}.|
|所以编译一下吧。|

274
00:09:05,300 --> 00:09:07,130
0,630 720,1200 1200,1290 1290,1530 1530,1830
And before I run it,
在我运行它之前，注意到实际上我们已经启动了

275
00:09:07,160 --> 00:09:08,600
0,180 180,540 570,1020 1020,1290 1290,1440
you know notice actually we

276
00:09:08,600 --> 00:09:11,450
0,180 180,690 780,1260 1260,1800 1800,2850
already booted| and actually {}
|实际上，我们大概已经给Kfree打了几个电话，

277
00:09:11,480 --> 00:09:12,470
0,420 420,510 510,630 630,810 810,990
presumably, we have made some

278
00:09:12,470 --> 00:09:13,730
0,270 270,630 630,900 900,1050 1050,1260
calls probably to {} {kfree

279
00:09:13,730 --> 00:09:15,290
0,420 720,930 930,1350 1350,1440 1440,1560
-},| you probably as you
|你可能就像你知道的那样，所以如果事情看起来运行得很好的话。

280
00:09:15,290 --> 00:09:16,520
0,390 390,600 600,690 690,900 930,1230
know, and so if things

281
00:09:16,520 --> 00:09:17,510
0,120 120,210 210,330 330,630 630,990
seem to be working fine.|
|

282
00:09:18,070 --> 00:09:19,090
0,210 210,420 420,750 750,780 780,1020
So let's run {} {usertests
那么让我们运行用户测试。

283
00:09:19,090 --> 00:09:20,260
0,540
-}.|
|

284
00:09:20,260 --> 00:09:21,100
0,180 180,420 420,540 540,690 690,840
And maybe you know this
也许你知道这种本能，就是想一想这件事

285
00:09:21,100 --> 00:09:22,360
0,360 360,780 780,990 990,1050 1050,1260
instinct to think a little

286
00:09:22,360 --> 00:09:23,110
0,120 120,330 330,510 510,600 600,750
bit about this| and what
|你还能指望什么，这能行得通吗？不行得通。

287
00:09:23,110 --> 00:09:24,220
0,60 60,120 120,630 630,750 750,1110
do you expect, will this

288
00:09:24,250 --> 00:09:25,870
0,630 630,750 750,900 900,1140 1140,1620
work well does not work.|
|

289
00:09:28,920 --> 00:09:30,120
0,390 390,510 510,720 720,840 840,1200
Anybody who tried it out.|
任何试过的人。|

290
00:09:33,070 --> 00:09:34,480
0,300 300,510 510,960 990,1200 1200,1410
{} I think it could
我认为它可能会丢失一些页面，

291
00:09:34,480 --> 00:09:37,060
0,810 840,1260 1260,1500 1500,2160 2160,2580
potentially lose some pages,| but
|但也许不会，

292
00:09:37,330 --> 00:09:39,780
0,450 450,660 660,1170 1260,2010
maybe will not,| because
|因为可能不会出现比赛情况。

293
00:09:39,780 --> 00:09:41,250
0,210 210,750 810,900 900,1110 1110,1470
{} maybe a race condition

294
00:09:41,250 --> 00:09:43,260
0,210 210,720 870,1470 1590,1800 1800,2010
wouldn't occur.| {} Yeah, so
|是的，其中一件事是，我们面临的这些情况可能不会发生，

295
00:09:43,260 --> 00:09:43,920
0,150 150,240 240,300 300,540 540,660
one of the things is

296
00:09:43,920 --> 00:09:45,510
0,180 180,450 450,930 930,1140 1140,1590
that these we face conditions

297
00:09:45,510 --> 00:09:46,290
0,90 90,270 270,420 420,660 660,780
they might not happen,| so
|因此，让我们运行用户测试，看看实际发生了什么。

298
00:09:46,290 --> 00:09:47,340
0,180 180,570 570,630 630,840 840,1050
let's run the {usertests -}

299
00:09:47,340 --> 00:09:48,330
0,90 90,240 240,420 420,540 540,990
and see actually what happens.|
|

300
00:09:50,740 --> 00:09:51,820
0,600

301
00:09:51,820 --> 00:09:53,900
0,570 570,900 900,1500
{So,here,we} started up.|
所以我们从这里开始。|

302
00:09:54,360 --> 00:09:55,560
0,420 420,600 600,660 660,840 840,1200
It'll take a little while,|
这需要一小段时间|

303
00:09:55,560 --> 00:09:56,430
0,120 120,240 240,450 450,810 810,870
as you might complain a
就像你可能会抱怨的那样，

304
00:09:56,430 --> 00:09:57,540
0,210 210,360 360,780 780,900 900,1110
little bit,| because you know,
|因为你知道，跑了很多次，

305
00:09:58,470 --> 00:09:59,920
0,270 270,330 330,540 540,840
runnint a lot of,|
|

306
00:10:00,940 --> 00:10:01,390
0,120 120,150 150,180 180,360 360,450
there are a lot of
我的机器上负载很多，对吗？

307
00:10:01,390 --> 00:10:02,380
0,210 210,270 270,360 360,720 720,990
load on my machine here

308
00:10:02,380 --> 00:10:03,460
0,210 210,270 270,390 390,720 720,1080
correct,| as you probably know
|如您所知，这里的QEMU模拟[三]个内核

309
00:10:03,460 --> 00:10:06,220
0,570 810,1260 1260,1800 1800,2400 2430,2760
the QEMU simulating [three] of

310
00:10:06,310 --> 00:10:07,780
0,390 390,750 750,870 870,1260 1260,1470
cores here| and the discrete
|并且离散的核心可以并行运行。

311
00:10:07,780 --> 00:10:09,100
0,240 240,390 390,600 600,690 690,1320
cores might run in parallel.|
|

312
00:10:10,330 --> 00:10:11,620
0,720

313
00:10:11,830 --> 00:10:13,840
0,900 990,1230 1230,1410 1410,1560 1560,2010
And so far so good,
到目前为止一切顺利，我们开始通过测试了。

314
00:10:14,020 --> 00:10:15,580
0,390 390,660 660,750 750,1050 1050,1560
we're starting to pass tests.|
|

315
00:10:21,470 --> 00:10:22,430
0,240 240,270 270,510 510,600 600,960
That's a little bit slower,|
这有点慢，|

316
00:10:22,430 --> 00:10:23,360
0,210 210,330 330,600 600,870 870,930
because I'm running zoom at
因为我同时运行变焦功能。

317
00:10:23,360 --> 00:10:24,700
0,90 90,300 300,840
the same time.|
|

318
00:10:26,920 --> 00:10:28,420
0,450 450,810 810,870 870,1110 1110,1500
Let's wait a couple more
让我们再等几天，看看会发生什么。

319
00:10:28,420 --> 00:10:29,650
0,120 120,360 360,720 750,1050 1050,1230
and just to see what's

320
00:10:29,650 --> 00:10:30,840
0,240 240,630
going on.|
|

321
00:10:43,070 --> 00:10:45,860
0,720 720,1320 1350,2250
Okay, well {}.|
好吧，好吧。|

322
00:10:46,290 --> 00:10:47,670
0,270 540,750 750,840 840,1230 1230,1380
Let's just go back to
我们还是回去看幻灯片吧

323
00:10:47,670 --> 00:10:49,290
0,330 330,750 750,870 870,1350 1350,1620
the slides| and then we'll
|然后我们一会儿再回来看看

324
00:10:49,290 --> 00:10:50,340
0,210 210,480 480,750 750,840 840,1050
check back in a little

325
00:10:50,340 --> 00:10:51,450
0,240 240,360 360,660 660,840 840,1110
while| and see what actually
|看看实际会发生什么。

326
00:10:51,450 --> 00:10:52,500
0,570
happens.|
|

327
00:10:52,860 --> 00:10:54,600
0,540 720,1170 1170,1320 1320,1440 1440,1740
{} But it was pointed
但是有人指出，在这些比赛条件下可能会出现，可能不会出现，对，

328
00:10:54,600 --> 00:10:55,950
0,300 360,510 510,720 720,930 930,1350
out in these race conditions

329
00:10:55,950 --> 00:10:57,060
0,150 150,450 450,570 570,750 750,1110
may appear, may not appear,

330
00:10:57,090 --> 00:10:58,410
0,240 240,510 510,900 900,1230 1230,1320
right,| because it's always the
|因为总是这样的，每次我们调用kfree时，

331
00:10:58,410 --> 00:11:00,180
0,360 360,960 960,1200 1200,1620 1620,1770
case that every core or

332
00:11:00,180 --> 00:11:01,140
0,150 150,360 360,450 450,690 690,960
every time we call {kfree

333
00:11:01,140 --> 00:11:03,300
0,450 900,1290 1290,1530 1530,1740 1740,2160
-},| {} these two lines
|这两行以原子方式执行，就像它们对锁所做的那样，

334
00:11:03,300 --> 00:11:07,260
0,120 120,780 1050,2040 2940,3810 3840,3960
are executed atomically as they

335
00:11:07,260 --> 00:11:08,370
0,180 180,300 300,750 750,990 990,1110
would have done with the

336
00:11:08,370 --> 00:11:10,530
0,450 600,1110 1110,1290 1290,1440 1440,2160
lock,| then there's no problem,|
那就没有问题了，|

337
00:11:10,530 --> 00:11:11,790
0,90 90,360 360,720 720,960 960,1260
the only problem is if
唯一的问题是，如果我们两个线程同时执行两个进程

338
00:11:11,790 --> 00:11:13,380
0,120 120,420 420,900 1020,1170 1170,1590
we two threads two processes

339
00:11:13,380 --> 00:11:14,460
0,150 150,630 630,720 720,810 810,1080
are executed at the same

340
00:11:14,460 --> 00:11:15,720
0,480 540,690 690,930 930,1170 1170,1260
time| and somebody comes in
|然后就会有人插手进来。

341
00:11:15,720 --> 00:11:16,420
0,390
between.|
|

342
00:11:17,140 --> 00:11:18,850
0,240 240,300 300,600 630,1200 1230,1710
Look at this, actually while
看看这个，实际上在我说话的时候，

343
00:11:18,850 --> 00:11:20,200
0,90 90,570 570,870 870,1050 1050,1350
I'm talking,| we see actually
|我们看到实际上有一种恐慌

344
00:11:20,200 --> 00:11:21,310
0,180 180,300 300,360 360,810 840,1110
there is a panic| and
|所以有一些竞赛情况实际上可能会引起恐慌。

345
00:11:21,310 --> 00:11:22,600
0,240 240,510 510,690 690,900 900,1290
so there's some race condition

346
00:11:22,600 --> 00:11:23,440
0,150 150,300 300,540 540,780 780,840
that can actually cause a

347
00:11:23,440 --> 00:11:24,400
0,480
panic.|
|

348
00:11:24,940 --> 00:11:27,190
0,450 930,1230 1230,1440 1440,1950 1950,2250
{} Rather race conditions that
更确切地说，比赛条件将会出现

349
00:11:27,190 --> 00:11:28,450
0,330 330,630 630,780 780,900 900,1260
will show up| as indeed
|事实上，正如所提到的那样，虽然所提到的

350
00:11:28,450 --> 00:11:31,480
0,300 300,960 960,1440 1800,2670 2700,3030
this as mentioned whereas mentioned|
|

351
00:11:31,480 --> 00:11:32,920
0,600 600,840 840,1050 1050,1170 1170,1440
that will show up as
这将被证明是不够的，

352
00:11:33,070 --> 00:11:34,780
0,360 360,840 960,1140 1140,1320 1320,1710
not enough,| some free pages
|一些免费页面，有些页面丢失了，

353
00:11:34,780 --> 00:11:36,070
0,210 210,330 330,660 660,840 840,1290
where some pages get lost,|
|

354
00:11:36,100 --> 00:11:37,330
0,180 180,570 570,780 780,1020 1020,1230
so basically {usertests -} runs
因此，基本上用户测试直到最后都运行得很好，

355
00:11:37,330 --> 00:11:38,650
0,390 390,600 600,690 690,1020 1020,1320
fine until the very end,|
|

356
00:11:38,770 --> 00:11:41,050
0,480 480,960 960,1440 1500,1980 1980,2280
where complaints saying well you
投诉说你在所有的使用过程中丢失了一些页面，所有的[轮]用户测试。

357
00:11:41,050 --> 00:11:43,120
0,300 300,660 690,1050 1050,1650 1650,2070
lost some pages during all

358
00:11:43,120 --> 00:11:44,470
0,300 300,630 630,720 720,840 840,1350
using, all of the [round]

359
00:11:44,470 --> 00:11:45,200
0,420
usertests.|
|

360
00:11:45,600 --> 00:11:47,550
0,540 840,1050 1050,1380 1380,1590 1590,1950
Okay, so these race conditions
好的，所以这些竞赛条件可以以不同的方式表现出来，

361
00:11:47,550 --> 00:11:48,300
0,120 120,330 330,450 450,510 510,750
can show up in different

362
00:11:48,300 --> 00:11:49,770
0,570 630,840 840,960 960,1140 1140,1470
ways,| {} they may happen,
|它们可能会发生，也可能不会发生。

363
00:11:49,770 --> 00:11:51,000
0,60 60,150 150,390 390,690
they may not happen.|
|

364
00:11:51,120 --> 00:11:53,520
0,510 510,810 810,1110 1110,1470 1770,2400
Clearly something happened here {},|
很明显这里发生了什么事，|

365
00:11:53,760 --> 00:11:55,110
0,330 330,480 480,570 570,1200 1230,1350
let's try to understand you
让我们试着去了解你知道到底是什么，哪里出了问题。

366
00:11:55,110 --> 00:11:57,240
0,90 90,750 750,1260 1260,1710 1710,2130
know what actually, {} what

367
00:11:57,240 --> 00:11:58,300
0,180 180,510
goes wrong.|
|

368
00:12:00,420 --> 00:12:02,940
0,1050 1050,1170 1170,1410 1410,1950
Back to the slides.|
回到幻灯片上。|

369
00:12:06,400 --> 00:12:07,720
0,630 660,960 960,1080 1080,1200 1200,1320
{} So you know the
所以你知道这幅画，你的脑海里应该有这样的画面，

370
00:12:07,720 --> 00:12:08,500
0,300 300,390 390,570 570,720 720,780
picture, you should have in

371
00:12:08,500 --> 00:12:09,640
0,120 120,540 540,690 690,840 840,1140
your head,| like if there's
|就好像只有多个内核在运行。

372
00:12:09,640 --> 00:12:11,770
0,390 630,1080 1080,1560 1590,1920 1920,2130
just multiple cores that were

373
00:12:11,770 --> 00:12:12,800
0,480
running.|
|

374
00:12:13,070 --> 00:12:15,290
0,210 210,390 390,810 810,1410 1740,2220
So your CPU zero,| CPU
所以你的CPU0，|CPU零正在执行指令。

375
00:12:15,290 --> 00:12:17,440
0,300 300,390 390,870 870,1590
zero is executing instructions.|
|

376
00:12:17,470 --> 00:12:18,880
0,180 180,480 480,840 840,990 990,1410
And CPU one is executing
CPU 1正在执行指令。

377
00:12:18,880 --> 00:12:20,120
0,720
instructions.|
|

378
00:12:21,210 --> 00:12:23,880
0,510 540,690 690,960 960,1620 1710,2670
And they're both connected through
它们都通过记忆联系在一起，

379
00:12:24,120 --> 00:12:26,070
0,150 150,630 840,990 990,1410 1440,1950
a memory,| if you're back
|如果你回过头来回想一下[方案]示意图，

380
00:12:26,070 --> 00:12:27,090
0,180 180,420 420,600 600,690 690,1020
think back about the [scheme]

381
00:12:27,090 --> 00:12:28,320
0,630 630,720 720,930 930,1020 1020,1230
schematics,| you know we showed
|你知道我们之前展示过几次，

382
00:12:28,320 --> 00:12:29,700
0,30 30,210 210,420 420,930 1230,1380
a couple times before,| in
|实际上有一个DRAM控制器，

383
00:12:29,700 --> 00:12:31,770
0,180 180,360 360,690 750,1350 1350,2070
fact there's a DRAM controller,|
|

384
00:12:31,770 --> 00:12:33,600
0,120 120,240 240,660 660,1350
you know that actually
你知道，它实际上连接到了DRAM芯片，

385
00:12:33,690 --> 00:12:35,250
0,450 480,960 960,1140 1140,1440 1440,1560
{} connects, {you,know}, to the

386
00:12:35,250 --> 00:12:37,170
0,390 390,900 1200,1710 1710,1830 1830,1920
DRAM chips,| where all the
|所有的[舞台]都生活在那里，

387
00:12:37,170 --> 00:12:38,660
0,420 420,930
[stages] living,|
|

388
00:12:38,800 --> 00:12:40,420
0,510 510,870 870,930 930,1320 1320,1620
or all the memories living.|
或者所有活着的记忆。|

389
00:12:41,370 --> 00:12:42,240
0,180 180,330 330,480 480,630 630,870
I'm gonna make that memory
不管怎样，我会让记忆变得更大一点。

390
00:12:42,240 --> 00:12:43,050
0,30 30,180 180,300 300,570 570,810
a little bit bigger, bigger

391
00:12:43,050 --> 00:12:44,040
0,390
whatever.|
|

392
00:12:46,030 --> 00:12:47,230
0,180 180,300 300,540 540,630 630,1200
Have some place to draw|
有地方可以画画|

393
00:12:47,260 --> 00:12:48,940
0,270 270,420 420,780 780,990 990,1680
and so basically our freelist,
所以基本上我们的自由撰稿人，你知道，生活在记忆中，

394
00:12:49,270 --> 00:12:50,800
0,180 180,360 360,750 750,1080 1080,1530
you know {} lives in,

395
00:12:53,010 --> 00:12:54,780
0,180 180,810 1170,1410 1410,1590 1590,1770
in memory,| and let's say
|假设有一个自由撰稿人名单，上面有两页。

396
00:12:54,780 --> 00:12:55,620
0,210 210,300 300,480 480,750 750,840
there's a {freelist -} with

397
00:12:55,620 --> 00:12:57,260
0,150 150,540 540,750 750,1050
two pages on it.|
|

398
00:12:59,060 --> 00:13:01,640
0,600 600,1290 1290,1890 2340,2460 2460,2580
{} And {} you know
你们都知道，两个CPU大概同时调用kfree。

399
00:13:01,640 --> 00:13:04,790
0,660 660,660 2130,2640 2640,3030 3030,3150
both, {} both {CPUs -}

400
00:13:04,790 --> 00:13:06,860
0,240 240,720 720,1050 1050,1560 1590,2070
gonna call {kfree -} roughly

401
00:13:06,860 --> 00:13:08,300
0,90 90,180 180,420 420,810
at the same time.|
|

402
00:13:13,460 --> 00:13:14,510
0,240 240,390 390,780 780,840 840,1050
Okay, so look a little
好的，再看一下代码，

403
00:13:14,510 --> 00:13:15,440
0,150 150,240 240,330 330,570 570,930
bit at the code, again,|
|

404
00:13:15,440 --> 00:13:16,280
0,210 210,270 270,450 450,690 690,840
just to make sure that
只是为了确保我们脑子里一直在想，

405
00:13:16,280 --> 00:13:17,810
0,540 570,930 1020,1350 1350,1440 1440,1530
we have running in our

406
00:13:17,810 --> 00:13:18,650
0,300 300,450 450,600 600,750 750,840
heads,| so we look at
|所以我们看看Kfree，

407
00:13:18,650 --> 00:13:20,780
0,240 240,750 1140,1710 1710,1830 1830,2130
{kfree -},| {} you know
|你知道传递一些私人助理，物理地址，

408
00:13:20,780 --> 00:13:23,120
0,180 180,690 690,1140 1170,1890 1920,2340
get passing some pa, {}

409
00:13:23,120 --> 00:13:24,830
0,330 330,960 1230,1440 1440,1590 1590,1710
physical address,| {} that we're
|我们要用它来连接到自由撰稿人名单上。

410
00:13:24,830 --> 00:13:26,210
0,150 150,450 450,570 570,960 960,1380
gonna use to actually hook

411
00:13:26,210 --> 00:13:28,130
0,750 900,1200 1200,1290 1290,1470 1470,1920
up into the {freelist -}.|
|

412
00:13:29,000 --> 00:13:31,940
0,600 960,1440 1710,1830 1830,1950 1950,2940
{} So you know CPU
所以你知道CPU0有一个你知道的r，

413
00:13:32,240 --> 00:13:35,750
0,630 630,1350 1470,2250 2490,2970 2970,3510
zero has a {you,know} r,|
|

414
00:13:36,770 --> 00:13:39,470
0,690 690,1200 1650,1860 1860,2340 2340,2700
{} and that's pointing to
这就指向了一些你知道的免费页面

415
00:13:39,470 --> 00:13:42,230
0,420 420,720 720,930 930,1530 2070,2760
some {you,know} free page| and
|也许还有CPU，其中一个有一个，

416
00:13:42,230 --> 00:13:45,440
0,810 1200,1980 2310,2520 2520,2790 2790,3210
{} maybe yeah and CPU,

417
00:13:45,440 --> 00:13:47,020
0,360 360,570 570,1050
one has one,|

418
00:13:47,080 --> 00:13:48,190
0,150 150,420 420,570 570,840 840,1110
we actually use another color
我们实际上使用的是另一种颜色的CPU1。

419
00:13:48,190 --> 00:13:49,660
0,120 120,450 450,900
for CPU one.|
|

420
00:13:49,660 --> 00:13:51,220
0,90 90,330 330,480 480,1050 1050,1560
So {CPU -} knows r
因此CPU知道r总是指向某个页面，

421
00:13:51,640 --> 00:13:53,590
0,450 450,1050 1050,1170 1170,1380 1380,1950
always pointing to some page,|
|

422
00:13:53,590 --> 00:13:54,430
0,120 120,240 240,540 540,660 660,840
you know that we want
你知道我们想和自由职业者挂钩。

423
00:13:54,430 --> 00:13:55,090
0,60 60,210 210,390 390,510 510,660
to hook into the {freelist

424
00:13:55,090 --> 00:13:55,980
0,450
-}.|
|

425
00:13:56,450 --> 00:13:57,600
0,240 240,600
Makes sense?|
合乎道理?|

426
00:13:59,050 --> 00:14:00,010
0,240 240,570 570,690 690,810 810,960
And so you know we're
所以你知道我们正在回顾代码，

427
00:14:00,010 --> 00:14:01,210
0,180 180,420 420,480 480,540 540,1200
looking back at the code,|
|

428
00:14:01,240 --> 00:14:03,130
0,630 1170,1380 1380,1500 1500,1740 1740,1890
you know the first thing
你知道他们做的第一件事就是

429
00:14:03,130 --> 00:14:04,450
0,120 120,540 540,1050 1050,1170 1170,1320
they do is| you know
|您知道，update r->next指针指向指向自由列表的[键]。

430
00:14:04,450 --> 00:14:06,790
0,420 420,570 570,960 960,1290 1290,2340
update {r->next -} pointer to

431
00:14:06,850 --> 00:14:07,810
0,360 360,450 450,570 570,870 870,960
point to the [key] to

432
00:14:07,810 --> 00:14:08,880
0,120 120,270 270,690
the {freelist -}.|
|

433
00:14:09,210 --> 00:14:11,040
0,480 510,840 840,1530 1560,1680 1680,1830
So let's assume you know
假设您知道CPU One首先运行

434
00:14:11,040 --> 00:14:13,290
0,540 540,870 870,1260 1260,1830 1950,2250
that CPU one runs {}

435
00:14:13,290 --> 00:14:15,570
0,540 960,1590 1890,1980 1980,2070 2070,2280
first| and you know what
|你知道它会做什么就是把它的指针

436
00:14:15,570 --> 00:14:16,680
0,180 180,300 300,630 630,930 930,1110
it will do is will

437
00:14:16,680 --> 00:14:18,180
0,240 240,390 390,1050
put its pointer,|
|

438
00:14:18,550 --> 00:14:20,200
0,120 120,240 240,930 1110,1290 1290,1650
you know to the beginning
你知道，在自由撰稿人所指的任何地方，你都知道从一开始就是这样。

439
00:14:20,200 --> 00:14:21,540
0,210 210,690
of the

440
00:14:22,000 --> 00:14:23,890
0,510 540,870 870,1440 1440,1620 1620,1890
{} yeah wherever {freelist -}

441
00:14:23,890 --> 00:14:24,940
0,300 300,510
pointed to.|
|

442
00:14:25,090 --> 00:14:26,950
0,540 540,1050 1050,1290 1290,1590 1590,1860
{} If {you,know} CPU on
如果您知道CPU ON完全同时运行，

443
00:14:26,950 --> 00:14:28,060
0,270 270,720 720,780 780,870 870,1110
runs exactly at the same

444
00:14:28,060 --> 00:14:30,970
0,600 930,1320 1320,2010 2160,2790 2790,2910
time,| {} then, {} you
|然后，你知道，它可以在CPU0执行第二条指令之前运行，

445
00:14:30,970 --> 00:14:31,780
0,300
know,

446
00:14:31,870 --> 00:14:34,990
0,630 810,1140 1140,1530 1530,2040 2070,3120
{} it could run before

447
00:14:35,080 --> 00:14:36,610
0,390 390,720 720,1110 1110,1170 1170,1530
CPU zero executes the second

448
00:14:36,610 --> 00:14:38,320
0,660 960,1170 1170,1260 1260,1500 1500,1710
instruction,| so it actually might
|所以它实际上可能会做同样的事情，

449
00:14:38,320 --> 00:14:39,310
0,90 90,210 210,420 420,720 720,990
do the same thing,| it
|它实际上还可能运行第一条指令

450
00:14:39,310 --> 00:14:40,450
0,210 210,450 450,780 780,960 960,1140
might actually also run that

451
00:14:40,450 --> 00:14:42,880
0,240 240,810 1110,1290 1290,1920
first instruction| and update
|并更新，并将指针更新到[二]，

452
00:14:43,140 --> 00:14:44,240
0,600
{},

453
00:14:51,340 --> 00:14:52,810
0,210 210,750 750,840 840,1140 1140,1470
and update the pointer to

454
00:14:54,030 --> 00:14:56,430
0,390 390,870 1260,1950 1980,2070 2070,2400
[two],| {So,both} r {you,know} one
|所以这两个r，你们知道，1来自CPU 1，1来自CPU 0，

455
00:14:56,430 --> 00:14:57,630
0,120 120,480 480,810 810,1080 1080,1200
from CPU one, and from

456
00:14:57,630 --> 00:14:58,980
0,300 300,570 570,780 780,1140 1140,1350
CPU zero,| one CPU one
|一个CPU指向自由列表的开头

457
00:14:58,980 --> 00:14:59,820
0,150 150,420 420,510 510,570 570,840
are pointing to the beginning

458
00:14:59,820 --> 00:15:00,510
0,90 90,150 150,360 360,570 570,690
of the {freelist -}| and
|而这份名单也指向了自由职业者的开始。

459
00:15:00,510 --> 00:15:01,500
0,180 180,420 420,510 510,720 720,990
the list is also pointing

460
00:15:01,500 --> 00:15:02,760
0,120 120,390 720,1110 1110,1170 1170,1260
to the beginning of the

461
00:15:02,760 --> 00:15:03,780
0,180 180,570
{freelist -}.|
|

462
00:15:03,930 --> 00:15:04,680
0,180 180,360 360,480 480,510 510,750
So now there are two
所以现在有两条剩余的指令在并行执行。

463
00:15:04,680 --> 00:15:05,880
0,360 360,840 840,960 960,1020 1020,1200
remaining instructions that are being

464
00:15:05,880 --> 00:15:07,580
0,510 510,570 570,1140
executed in parallel.|
|

465
00:15:07,730 --> 00:15:08,960
0,210 210,360 360,450 450,750 750,1230
So we go back again,|
所以我们再回去一次，|

466
00:15:09,020 --> 00:15:10,700
0,120 120,300 300,390 390,870 1260,1680
you know the code, the
你知道代码，剩下的指令正在执行

467
00:15:10,700 --> 00:15:12,500
0,420 420,840 840,1020 1020,1230 1230,1800
remaining instruction is being executed|
|

468
00:15:12,500 --> 00:15:13,580
0,150 150,420 420,810 810,930 930,1080
is actually updating the {freelist
实际上正在更新自由列表以指向r。

469
00:15:13,580 --> 00:15:14,630
0,300 300,360 360,570 570,690 690,1050
-} to point to r.|
|

470
00:15:14,900 --> 00:15:16,360
0,960
{You,know}.|
你知道。|

471
00:15:17,040 --> 00:15:18,720
0,270 270,780 960,1350 1350,1440 1440,1680
And so, {} you know
所以，你知道CPU0，1要执行这些指令可能是完全一样的，

472
00:15:19,650 --> 00:15:20,580
0,180 180,480 480,720 720,870 870,930
CPU zero one going to

473
00:15:20,580 --> 00:15:21,660
0,360 360,510 510,870 870,990 990,1080
execute these instructions may be

474
00:15:21,660 --> 00:15:24,060
0,510 510,630 630,1170 1170,2040 2040,2400
exactly the same,| yeah roughly
|是的，大致在同一时间，

475
00:15:24,060 --> 00:15:24,990
0,60 60,120 120,330 330,720 750,930
at the same time,| but
|但是有一个会先走，对吗，

476
00:15:24,990 --> 00:15:25,860
0,150 150,240 240,390 390,510 510,870
one is gonna go first,

477
00:15:25,860 --> 00:15:27,120
0,210 210,330 330,540 540,840 840,1260
correct,| there's only one single
|只有一个共享内存

478
00:15:27,120 --> 00:15:29,010
0,240 240,750 1140,1560 1560,1680 1680,1890
shared memory| and so one
|因此，首先要进行一次更新

479
00:15:29,010 --> 00:15:29,760
0,330 330,420 420,540 540,600 600,750
update is going to go

480
00:15:29,760 --> 00:15:30,870
0,450 510,720 720,810 810,930 930,1110
first| and the other one
|另一个会排在第二位。

481
00:15:30,870 --> 00:15:32,200
0,90 90,240 240,360 360,840
is gonna go second.|
|

482
00:15:32,290 --> 00:15:33,640
0,180 180,330 330,480 480,870 870,1350
So let's say CPU one
那么让我们假设CPU 1先运行。

483
00:15:33,670 --> 00:15:35,180
0,480 480,960
goes first.|
|

484
00:15:35,240 --> 00:15:36,290
0,90 90,270 270,720 720,840 840,1050
I know what will then
我知道接下来会发生什么，

485
00:15:36,290 --> 00:15:37,640
0,330 330,720 750,840 840,1140 1140,1350
happen,| well the CPO what
|好的，首席执行官先说什么，

486
00:15:37,640 --> 00:15:38,690
0,150 150,450 450,630 630,960 960,1050
goes first,| {freelist -} can
|自由列表可以指向它的r，对吧。

487
00:15:38,690 --> 00:15:40,420
0,150 150,480 480,600 600,1170
be pointing to {its,r},

488
00:15:40,420 --> 00:15:41,280
0,330
right.|
|

489
00:15:42,200 --> 00:15:44,210
0,420 420,600 600,900 900,1440 1440,2010
{} And then {CPU,two} runs,
然后CPU 2运行，所以现在CPU实际上运行指令

490
00:15:44,240 --> 00:15:46,220
0,180 180,720 750,1200 1200,1500 1500,1980
so now CPU runs actually

491
00:15:46,220 --> 00:15:48,140
0,690 990,1410 1410,1560 1560,1770 1770,1920
instruction| and so what is
|那么接下来要做的是，

492
00:15:48,140 --> 00:15:49,160
0,120 120,180 180,600 630,870 870,1020
going to do,| it is
|它实际上会将自由列表更新为指向。

493
00:15:49,160 --> 00:15:50,870
0,300 300,360 360,750 780,1440 1500,1710
going to actually update {}

494
00:15:50,870 --> 00:15:53,140
0,210 210,630 990,1170 1170,1740
{freelist -} to point.|
|

495
00:15:55,340 --> 00:15:56,750
0,210 420,630 630,750 750,930 930,1410
So here's a {freelist -}.|
这里有一个自由撰稿人。|

496
00:15:58,000 --> 00:15:59,020
0,300 300,480 480,780 780,810 810,1020
And it's actually {} going
它实际上指向r，他们实际上传入了。

497
00:15:59,020 --> 00:16:00,520
0,390 390,930
point to

498
00:16:00,900 --> 00:16:02,580
0,510 510,660 660,1080 1080,1440 1440,1680
r they actually passed in.|
|

499
00:16:03,230 --> 00:16:04,130
0,150 150,510 510,600 600,750 750,900
And so you know we
所以你知道我们现在有了一个背景，对吗，

500
00:16:04,130 --> 00:16:05,300
0,120 120,180 180,480 480,810 810,1170
have a setting now, correct,|
|

501
00:16:05,300 --> 00:16:07,850
0,570 690,1020 1020,1680 1710,2310 2310,2550
we're we've lost basically one
我们基本上少了一页。

502
00:16:07,850 --> 00:16:08,960
0,630
page.|

503
00:16:08,960 --> 00:16:09,900
0,570

504
00:16:10,880 --> 00:16:12,320
0,570 600,720 720,840 840,1140 1140,1440
Or you know that actually
或者你知道实际上CPU0实际上是免费的，实际上最终根本不在自由列表上，

505
00:16:12,320 --> 00:16:14,510
0,420 420,840 840,1260 1260,1650 1830,2190
CPU zero actually free, actually

506
00:16:14,510 --> 00:16:15,680
0,240 240,390 390,750 750,1020 1020,1170
ended up not being on

507
00:16:15,680 --> 00:16:16,580
0,60 60,240 240,480 480,600 600,900
the {freelist -} at all,|
|

508
00:16:16,970 --> 00:16:18,320
0,270 270,450 450,780 780,870 870,1350
so we lost the page.|
所以我们把那一页弄丢了。|

509
00:16:22,680 --> 00:16:24,120
0,570 570,750 750,930 930,1380 1380,1440
{} And as one you
作为一个你知道坏结果的人，

510
00:16:24,120 --> 00:16:25,920
0,360 390,930 930,1320 1320,1680 1680,1800
know bad particular outcome,| of
|当然，可能会有更多的坏结果，

511
00:16:25,920 --> 00:16:26,790
0,180 180,270 270,390 390,480 480,870
course there could be more

512
00:16:26,790 --> 00:16:28,110
0,270 270,810 810,1080 1080,1200 1200,1320
bad outcomes,| because there could
|因为可能会有更多的CPU实际尝试执行此自由列表，

513
00:16:28,110 --> 00:16:29,310
0,90 90,330 330,570 570,960 960,1200
be more {CPU -} actually

514
00:16:29,310 --> 00:16:30,180
0,300 300,390 390,540 540,690 690,870
trying to do this {freelist

515
00:16:30,180 --> 00:16:32,370
0,510 840,1140 1140,1290 1290,1500 1500,2190
-},| {} they may observe
|他们可能会观察到其中一只[雄性长颈鹿]，

516
00:16:32,370 --> 00:16:33,420
0,300 300,510 510,630 630,720 720,1050
the one of the [male

517
00:16:33,420 --> 00:16:35,430
0,300 300,510 540,960 960,1290 1290,2010
giraffe],| the freelist pointing temporarily
|空闲列表临时指向CPU0的r，

518
00:16:35,430 --> 00:16:37,800
0,180 180,750 750,840 840,1620 1710,2370
to CPU {} zero's r,|
|

519
00:16:38,040 --> 00:16:39,090
0,420 420,600 600,690 690,810 810,1050
{} and so we start
所以我们开始使用它，

520
00:16:39,090 --> 00:16:41,490
0,240 240,750 1020,1620 1620,1950 1950,2400
using that,| while then immediately
|然后立即由第二CPU更新自由列表，

521
00:16:41,490 --> 00:16:43,560
0,90 90,270 270,540 540,1110 1260,2070
the {freelist -} updated by

522
00:16:43,590 --> 00:16:45,420
0,330 360,690 690,1080 1110,1470 1560,1830
a second CPU,| so that
|所以进化出更多的CPU，我们可能实际上会得到更离奇的结果

523
00:16:45,420 --> 00:16:47,010
0,150 150,480 480,1110 1110,1470 1470,1590
more CPU evolved presumably we

524
00:16:47,010 --> 00:16:48,360
0,150 150,420 420,600 600,870 870,1350
could actually get more bizarre

525
00:16:48,360 --> 00:16:49,920
0,420 420,720 780,1140 1140,1230 1230,1560
outcomes| than just the last
|不仅仅是最后一页。

526
00:16:49,920 --> 00:16:50,620
0,420
page.|
|

527
00:16:52,310 --> 00:16:53,700
0,120 120,270 270,420 420,810
Does this make sense?|
这有意义吗？|

528
00:16:55,750 --> 00:16:57,300
0,330 330,1050
Any questions?|
有什么问题吗？|

529
00:17:04,820 --> 00:17:06,740
0,540 750,1350
Okay, um.|
好的，嗯。|

530
00:17:07,220 --> 00:17:08,390
0,180 180,300 300,810 840,1020 1020,1170
So do we, you know
我们也是，你知道，你知道，代码是这样做的，

531
00:17:08,390 --> 00:17:09,650
0,420 420,510 510,900 900,1020 1020,1260
ask you know the code

532
00:17:09,650 --> 00:17:10,880
0,450 450,540 540,660 660,750 750,1230
does,| you know the way
|你知道用一种非常普通的方式来解决这个问题的方法，

533
00:17:10,910 --> 00:17:13,790
0,90 90,360 360,630 630,1710 2010,2880
to address this a way

534
00:17:13,790 --> 00:17:15,140
0,150 150,210 210,600 600,960 960,1350
in a very common way,|
|

535
00:17:15,440 --> 00:17:16,730
0,570 570,780 780,870 870,1140 1140,1290
{} is to address this
就是解决这个问题就是使用锁。

536
00:17:16,730 --> 00:17:18,740
0,540 780,1200 1200,1320 1320,1860 1860,2010
problem is to use a

537
00:17:18,740 --> 00:17:19,660
0,450
lock.|
|

538
00:17:19,970 --> 00:17:20,570
0,210 210,330 330,420 420,570 570,600
So let me talk a
所以让我更详细地谈一下锁的问题。

539
00:17:20,570 --> 00:17:22,370
0,210 210,330 330,540 540,1050 1410,1800
little bit about locks {}

540
00:17:22,370 --> 00:17:23,720
0,240 240,390 390,840
in more detail.|
|

541
00:17:26,860 --> 00:17:29,320
0,180 180,750 1860,2040 2040,2160 2160,2460
So what is the lock
那么什么是锁抽象呢？

542
00:17:29,320 --> 00:17:30,740
0,810
abstraction.|
|

543
00:17:32,480 --> 00:17:33,890
0,570 750,900 900,1080 1080,1170 1170,1410
Well, now it is just
嗯，现在它只是一件物品，

544
00:17:33,890 --> 00:17:35,300
0,120 120,750 750,900 900,1140 1140,1410
an object,| like any other
|与内核中的任何其他类型的对象一样

545
00:17:35,300 --> 00:17:36,920
0,300 600,750 750,1470 1470,1560 1560,1620
sort of object in the

546
00:17:36,920 --> 00:17:39,050
0,600 810,1200 1200,1470 1470,1590 1590,2130
kernel| and anyone else has
|其他任何人都有，实际上有一种叫做结构锁的东西。

547
00:17:39,740 --> 00:17:40,640
0,120 120,330 330,480 480,720 720,900
in fact there's something called

548
00:17:40,640 --> 00:17:41,960
0,270 270,810
struct lock.|
|

549
00:17:41,960 --> 00:17:42,680
0,60 60,150 150,300 300,540 540,720
You know, that has some
你知道，那有一些字段，你知道要维护关于锁的状态，

550
00:17:42,680 --> 00:17:44,630
0,600 990,1110 1110,1230 1230,1530 1560,1950
fields, you know to maintain

551
00:17:44,630 --> 00:17:47,240
0,300 300,540 540,1050 1380,1920 1920,2610
state about locks,| {} and
|它有一个相当简单的API，

552
00:17:47,300 --> 00:17:48,650
0,150 150,330 330,480 510,750 750,1350
it has a pretty straightforward

553
00:17:48,650 --> 00:17:50,360
0,810 810,1050 1050,1170 1170,1470 1470,1710
API,| you know there's {}
|你知道有后天的，

554
00:17:51,190 --> 00:17:52,150
0,570 570,660 660,840 840,930 930,960
acquired,| in fact there are
|事实上，只有两次对此抽象的调用，

555
00:17:52,150 --> 00:17:54,100
0,240 240,420 420,1050 1080,1440 1440,1950
only two calls into this

556
00:17:54,220 --> 00:17:57,240
0,810 1230,1680 1680,2310
abstraction,| {} which
|它需要指向指针的指针才能锁定结构

557
00:17:58,540 --> 00:18:00,100
0,150 150,600 600,780 780,1020 1020,1560
{require -} which takes to

558
00:18:00,490 --> 00:18:02,980
0,90 90,660 660,1200 1200,2010 2040,2490
a pointer to {} lock

559
00:18:02,980 --> 00:18:05,700
0,510 810,1290 1290,1560 1560,2220
struct| and {} release
|和释放，你知道，实际上也需要一个指针锁结构，

560
00:18:06,590 --> 00:18:09,020
0,840 840,960 960,1200 1200,1740
you know that actually

561
00:18:09,020 --> 00:18:10,850
0,990 990,1170 1170,1350 1350,1410 1410,1830
{} also takes a pointer

562
00:18:10,850 --> 00:18:12,950
0,210 210,600 960,1170 1170,1560 1560,2100
lock struct,| to basically update
|要从根本上更新，您知道Lock对象。

563
00:18:12,950 --> 00:18:14,000
0,90 90,180 180,300 300,540 540,1050
you know the lock object.|
|

564
00:18:14,900 --> 00:18:15,980
0,270 270,630 630,750 750,1020 1020,1080
And basically the rule of
基本上锁定规则和这里的规则是，

565
00:18:15,980 --> 00:18:17,330
0,360 360,450 450,690 690,1020 1020,1350
lock and the rule here

566
00:18:17,330 --> 00:18:19,420
0,120 120,510 930,1560
is that {},|
|

567
00:18:20,020 --> 00:18:22,020
0,480 750,1530
the require
要求强制执行以下规则，

568
00:18:23,140 --> 00:18:25,240
0,480 510,1020 1020,1200 1200,1710 1740,2100
{} enforces this {} following

569
00:18:25,240 --> 00:18:27,370
0,180 180,360 360,600 600,1320 1350,2130
rule,| that only one process
|只有一个你知道的进程可以进入或者可以获得锁。

570
00:18:30,940 --> 00:18:32,230
0,210 210,360 360,900 900,1140 1140,1290
{you,know} can enter or can

571
00:18:32,230 --> 00:18:33,680
0,450 450,540 540,930
acquire the lock.|
|

572
00:18:37,950 --> 00:18:39,000
0,210 210,420 420,810 810,990 990,1050
So any particular point of
因此，在任何特定时间点，它们将只是一个能够实际成功获取锁的进程

573
00:18:39,000 --> 00:18:40,140
0,570
time,

574
00:18:40,140 --> 00:18:40,920
0,240 240,480 480,600 600,660 660,780
they're only going to be

575
00:18:40,920 --> 00:18:42,240
0,360 360,810 810,930 930,1020 1020,1320
one process that is able

576
00:18:42,240 --> 00:18:44,010
0,120 120,570 570,1200 1200,1680 1680,1770
to actually successfully acquire the

577
00:18:44,010 --> 00:18:45,600
0,390 720,930 930,990 990,1200 1200,1590
lock| and the other process
|和另一个基本上同时尝试获取锁的进程，

578
00:18:45,600 --> 00:18:46,920
0,120 120,450 450,780 780,1260 1260,1320
that basically {trying,to} acquired {}

579
00:18:46,920 --> 00:18:48,150
0,270 270,330 330,420 420,690 690,1230
lock at the same time,|
|

580
00:18:48,180 --> 00:18:49,350
0,240 240,360 360,780 780,1080 1080,1170
has to wait until the
必须等到第一个进程实际调用Release。

581
00:18:49,350 --> 00:18:51,000
0,330 330,660 660,900 900,1170 1170,1650
first process actually calls release.|
|

582
00:18:52,560 --> 00:18:54,600
0,210 210,330 330,960 990,1800 1920,2040
And so this sequence, you
所以这个序列，你知道指令，

583
00:18:54,600 --> 00:18:56,550
0,240 240,810 810,1740 1740,1860 1860,1950
know the instructions,| you know
|你知道，在获取释放之间，通常被称为临界区。

584
00:18:56,550 --> 00:18:59,790
0,840 1080,1290 1290,1740 1740,2370 2610,3240
between the acquire release, are

585
00:18:59,790 --> 00:19:01,020
0,150 150,360 360,420 420,750 750,1230
often called the critical section.|

586
00:19:07,720 --> 00:19:08,650
0,240 240,480 480,690 690,750 750,930
And one reason is called
被称为临界区的一个原因是

587
00:19:08,650 --> 00:19:09,970
0,60 60,360 360,690 690,900 900,1320
the critical section is because|
|

588
00:19:09,970 --> 00:19:11,110
0,420 420,510 510,660 660,780 780,1140
this is sort of the
这在某种程度上是[]指令一起完成的

589
00:19:11,320 --> 00:19:12,820
0,300 300,450 450,720 720,1110 1110,1500
{} the [] instruction together

590
00:19:12,820 --> 00:19:14,740
0,120 120,360 360,750 780,1470 1560,1920
to do the| {you,know} need
|您知道需要对r进行更新，无论共享数据结构是什么，

591
00:19:14,740 --> 00:19:16,090
0,60 60,210 210,360 360,1140 1140,1350
to do the update to

592
00:19:16,090 --> 00:19:17,560
0,360 360,690 690,930 930,1140 1140,1470
r, whatever shared data structure,|
|

593
00:19:17,560 --> 00:19:18,850
0,240 240,660 660,780 780,900 900,1290
that's protected by the lock
以原子的方式受到锁的保护。

594
00:19:19,090 --> 00:19:20,680
0,150 150,270 270,690 690,1080
in an atomic fashion.|
|

595
00:19:21,090 --> 00:19:22,920
0,300 300,480 480,990 990,1140 1140,1830
{} And ensures that basically,|
并确保基本上，|

596
00:19:23,460 --> 00:19:24,510
0,240 240,390 390,510 510,690 690,1050
{} if you have multiple
如果您在获取版本之间有多条指令，

597
00:19:24,510 --> 00:19:26,100
0,570 570,780 780,1140 1140,1230 1230,1590
instructions in this you know

598
00:19:26,370 --> 00:19:28,320
0,660 660,1050 1050,1500 1500,1770 1770,1950
between acquire release,| but they
|但他们要么一起被处死，要么一个都不处死。

599
00:19:28,320 --> 00:19:31,500
0,510 510,690 690,1380 1680,2340 2520,3180
all are executed all together

600
00:19:31,800 --> 00:19:33,080
0,300 300,750
or none.|
|

601
00:19:33,800 --> 00:19:35,030
0,150 150,360 360,690 690,720 720,1230
So there's never a case,
所以从来没有这种情况，临界区的这些指令是交错的

602
00:19:35,030 --> 00:19:36,590
0,600 600,1110 1110,1200 1200,1260 1260,1560
these instructions in the critical

603
00:19:36,590 --> 00:19:38,870
0,540 630,870 870,1680 1890,2190 2190,2280
section are interleaved| as in
|就像我们在比赛条件下看到的那样

604
00:19:38,870 --> 00:19:39,650
0,120 120,330 330,480 480,570 570,780
the way that we saw

605
00:19:39,650 --> 00:19:41,060
0,90 90,150 150,330 330,780 1260,1410
in the race conditions| and
|实际上，这就是这些比赛条件的原因。

606
00:19:41,060 --> 00:19:42,440
0,300 300,750 750,930 930,1020 1020,1380
actually exactly, that is what

607
00:19:42,440 --> 00:19:44,220
0,360 360,540 540,750 750,1410
boards these race conditions.|
|

608
00:19:48,190 --> 00:19:49,420
0,210 210,540 540,810 810,990 990,1230
Any questions about the lock
关于锁抽象有什么问题吗？

609
00:19:49,420 --> 00:19:50,580
0,600
abstraction?|
|

610
00:19:55,220 --> 00:19:56,720
0,240 240,900
{You,know} programs
你知道程序通常有很多锁，

611
00:19:56,780 --> 00:19:58,860
0,420 420,870 870,1530
{} typically have

612
00:20:00,270 --> 00:20:02,130
0,360 360,900 990,1200 1200,1470 1470,1860
many locks,| in fact we
|事实上，我们的xv6有很多锁。

613
00:20:02,400 --> 00:20:03,300
0,150 150,330 330,540 540,690 690,900
have {xv6 -} has many

614
00:20:03,300 --> 00:20:04,320
0,450
locks.|
|

615
00:20:08,140 --> 00:20:09,250
0,300 300,390 390,660 660,780 780,1110
And the reason to have
有很多锁的原因是

616
00:20:09,250 --> 00:20:10,360
0,270 270,600 600,690 690,990 990,1110
many locks is| because you
|因为您知道即使您知道锁序列化是两个进程的执行，

617
00:20:10,360 --> 00:20:11,290
0,210 210,480 480,660 660,810 810,930
know even though you know

618
00:20:11,290 --> 00:20:14,020
0,540 540,840 1140,1800 1800,2490 2490,2730
the the lock serialize is

619
00:20:14,020 --> 00:20:16,060
0,270 270,840 1020,1110 1110,1290 1290,2040
the execution of two processes,|
|

620
00:20:16,060 --> 00:20:17,830
0,270 270,540 540,1320 1380,1650 1650,1770
{you,know} want to enter the
你知道只有一个人想进入危急关头，

621
00:20:17,830 --> 00:20:19,330
0,300 300,630 630,840 840,1020 1020,1500
critical section only one succeeds,|
|

622
00:20:19,330 --> 00:20:21,520
0,270 270,330 330,510 510,930 1110,2190
and the other one runs
另一个在第一个完成后运行关键部分，

623
00:20:21,520 --> 00:20:22,660
0,120 120,390 390,690 690,1020 1020,1140
that critical section after the

624
00:20:22,660 --> 00:20:25,360
0,210 210,570 720,1770 1770,1830 2190,2700
first one {} it finishes,|
|

625
00:20:25,540 --> 00:20:27,160
0,150 150,360 360,870 870,1080 1080,1620
so there's no true parallelism
所以根本没有真正的平行。

626
00:20:27,160 --> 00:20:28,040
0,120 120,480
at all.|
|

627
00:20:28,500 --> 00:20:29,820
0,240 240,570 660,930 930,1020 1020,1320
{} So if the kernel
因此，如果内核只有一个锁，

628
00:20:29,820 --> 00:20:31,560
0,150 150,390 390,720 720,1260 1290,1740
had only one lock,| which
|这通常被称为大内核锁，

629
00:20:31,560 --> 00:20:32,760
0,210 210,480 480,840 840,990 990,1200
is typically called a big

630
00:20:32,760 --> 00:20:34,710
0,300 300,630 780,1020 1020,1590 1620,1950
kernel lock,| then basically every
|那么基本上每个系统调用，在这个，在内核中，都会被串行化，

631
00:20:34,710 --> 00:20:36,630
0,390 390,930 1260,1530 1530,1710 1710,1920
system call, {} in this,

632
00:20:36,630 --> 00:20:37,650
0,390 390,510 510,570 570,870 870,1020
{} in the kernel, would

633
00:20:37,650 --> 00:20:40,380
0,90 90,780 1590,1890 1890,2250 2250,2730
be serialized,| system called one
|名为One Start的系统会获得一个大的内核锁，

634
00:20:40,440 --> 00:20:42,000
0,570 870,1140 1140,1200 1200,1470 1470,1560
start gets the one the

635
00:20:42,000 --> 00:20:43,590
0,210 210,510 510,1020 1020,1320 1320,1590
big kernel lock,| does whatever
|做它需要做的任何事情，然后释放大的内核锁

636
00:20:43,590 --> 00:20:44,430
0,60 60,270 270,360 360,720 720,840
it needs to do, and

637
00:20:44,430 --> 00:20:45,630
0,330 330,660 660,750 750,930 930,1200
then release the big kernel

638
00:20:45,630 --> 00:20:46,770
0,240 240,330 330,450 450,840 840,1140
lock| and then basically returns
|然后基本上返回用户空间。

639
00:20:46,770 --> 00:20:47,860
0,300 300,720
user space.|
|

640
00:20:48,220 --> 00:20:49,180
0,390 390,510 510,660 660,720 720,960
{} And then the second
然后第二个系统叫做Run，

641
00:20:49,180 --> 00:20:50,590
0,240 240,420 420,480 480,810 1200,1410
system called the run,| so
|所以我们有一个服装应用程序，它运行大量的，并行运行的系统调用，

642
00:20:50,590 --> 00:20:51,970
0,150 150,270 270,360 360,810 810,1380
we have an apparel application,

643
00:20:51,970 --> 00:20:53,110
0,180 180,510 510,870 870,960 960,1140
that runs lots of, runs

644
00:20:53,110 --> 00:20:54,820
0,240 240,450 450,510 510,1170 1200,1710
system calls in parallel,| suddenly
|突然你知道所有的系统调用实际上都是串行运行的，

645
00:20:54,820 --> 00:20:56,290
0,90 90,270 270,660 660,1110 1140,1470
you know all the system

646
00:20:56,290 --> 00:20:57,910
0,300 300,570 570,900 900,1440 1440,1620
calls actually run serially,| if
|如果我们只有一把锁的话。

647
00:20:57,910 --> 00:20:58,960
0,90 90,270 270,480 480,690 690,1050
we had only one lock.|
|

648
00:20:59,880 --> 00:21:01,650
0,240 240,690 750,1230 1230,1380 1380,1770
And so typically your program
所以通常你的程序，你知道，你知道xv6有很多锁，

649
00:21:01,650 --> 00:21:02,670
0,270 270,360 360,450 450,720 720,1020
like, you know {xv6 -}

650
00:21:02,670 --> 00:21:04,170
0,600 600,720 720,840 840,1080 1080,1500
has you know many locks,|
|

651
00:21:04,170 --> 00:21:05,310
0,270 270,360 360,810 810,900 900,1140
because of these, you know
正因为如此，你知道我们可以得到一些并行性。

652
00:21:05,310 --> 00:21:06,360
0,120 120,210 210,360 360,510 510,1050
we can get some parallelism.|
|

653
00:21:09,670 --> 00:21:10,760
0,540
Because,
因为，您知道如果您知道两个系统调用使用两个不同的锁，

654
00:21:13,350 --> 00:21:14,310
0,120 120,210 210,660 690,840 840,960
you know if you know

655
00:21:14,310 --> 00:21:15,810
0,300 300,600 600,840 840,900 900,1500
two system calls for example

656
00:21:15,810 --> 00:21:17,940
0,240 240,420 420,720 720,1260 1560,2130
use two different locks {},|
|

657
00:21:17,970 --> 00:21:18,930
0,510 510,600 600,690 690,870 870,960
then you know they can
那么你就知道他们实际上可以绕着完全平行的方向，

658
00:21:18,930 --> 00:21:21,060
0,210 210,630 720,1080 1080,1530 1530,2130
actually around a completely parallel,|
|

659
00:21:21,270 --> 00:21:23,670
0,360 360,840 840,1260 1260,1920 2010,2400
{} without any {} {you,know}
如果没有任何序列化，

660
00:21:23,670 --> 00:21:26,070
0,630 1020,1530 1530,2070 2070,2160 2160,2400
serialization,| because basically you know
|因为基本上您知道使用不同的锁进行序列化。

661
00:21:26,100 --> 00:21:28,360
0,630 630,900 900,1200 1200,1890
using different locks serialize.|
|

662
00:21:29,790 --> 00:21:30,980
0,630

663
00:21:31,070 --> 00:21:33,120
0,630 810,1500
[Now], um.|
(现在)，嗯。|

664
00:21:34,040 --> 00:21:35,570
0,390 390,810 810,1050 1050,1110 1110,1530
There's a couple of important
有几点很重要，

665
00:21:35,570 --> 00:21:39,560
0,480 810,1710 2070,2820 3060,3780 3780,3990
points,| {} the nobody really
在这个界面上没有什么真正的力量，

666
00:21:39,560 --> 00:21:40,550
0,150 150,270 270,720 720,810 810,990
sort of forces in this

667
00:21:40,550 --> 00:21:41,960
0,720 720,870 870,990 990,1290 1290,1410
interface,| you know that you
|你知道你放在收购释放，

668
00:21:41,960 --> 00:21:43,790
0,210 210,450 450,840 840,1380 1380,1830
put in the acquire release,|
|

669
00:21:43,790 --> 00:21:44,300
0,90 90,180 180,300 300,450 450,510
you know it's up to
你知道，这是由程序决定的。

670
00:21:44,300 --> 00:21:45,410
0,120 120,540 540,630 630,780 780,1110
the program to do so.|
|

671
00:21:46,010 --> 00:21:47,090
0,240 240,390 390,480 480,780 780,1080
{} So if you want
因此，如果您希望特定的代码段是原子代码，

672
00:21:47,090 --> 00:21:47,930
0,60 60,360 360,540 540,600 600,840
a particular piece of code

673
00:21:47,930 --> 00:21:51,260
0,90 90,630 660,1710 1710,2250 2610,3330
to be a atomic,| then
|然后由开发人员实际将这些需要发布。

674
00:21:51,290 --> 00:21:52,280
0,150 150,300 300,390 390,540 540,990
it's up to the developer

675
00:21:52,280 --> 00:21:54,410
0,120 120,690 720,1200 1200,1710 1710,2130
to actually {put,these} require release

676
00:21:54,410 --> 00:21:55,140
0,150
it.|
|

677
00:21:55,230 --> 00:21:57,480
0,210 210,450 450,1050 1050,1440 1470,2250
And there clearly see {},|
从那里可以清楚地看到，|

678
00:21:57,480 --> 00:22:00,120
0,390 390,510 510,1020 1320,1980
you can imagine {},
你可以想象，有一点可能是棘手的，

679
00:22:00,300 --> 00:22:01,560
0,360 360,510 510,540 540,690 690,1260
that there's a little bit

680
00:22:01,560 --> 00:22:02,670
0,150 150,240 240,660 870,1020 1020,1110
can be tricky,| so it's
|因此重要的是要认识到，锁定实际上并不是自动为您完成的，

681
00:22:02,670 --> 00:22:03,750
0,330 330,390 390,840 840,960 960,1080
important to realize that you

682
00:22:03,750 --> 00:22:04,890
0,90 90,270 300,690 690,780 780,1140
know that locking is not

683
00:22:04,890 --> 00:22:06,630
0,270 270,510 510,1110 1110,1410 1410,1740
actually done automatically for you,|
|

684
00:22:06,870 --> 00:22:08,100
0,390 390,630 630,870 870,1050 1050,1230
{} it's all up to
一切都由开发商来决定，

685
00:22:08,100 --> 00:22:09,900
0,600 630,1230 1230,1320 1320,1620 1620,1800
the developer to figure out,|
|

686
00:22:09,900 --> 00:22:12,000
0,300 330,960 960,1290 1290,1650
to associate locks with
要将锁与数据结构相关联，请执行以下操作

687
00:22:12,000 --> 00:22:15,570
0,780 810,1170 1170,1800 2100,3000 3000,3570
{} data structures| and ensuring
|并确保适当的获取释放在那里。

688
00:22:15,570 --> 00:22:18,150
0,300 300,1020 1020,1470 1470,1950 1950,2580
that the appropriate acquire release

689
00:22:18,180 --> 00:22:19,540
0,300 300,480 480,840
{} are there.|
|

690
00:22:23,050 --> 00:22:24,850
0,540 690,930 930,1440 1440,1530 1530,1800
{} So clearly the case,
所以很明显的情况是，看，你知道锁的并行度限制，

691
00:22:24,850 --> 00:22:27,910
0,210 210,300 300,690 780,2220 2580,3060
look you know the locks

692
00:22:27,910 --> 00:22:30,010
0,780 810,1260 1260,1470 1470,2010 2010,2100
{} limit in parallelism,| and
|因此限制了性能，

693
00:22:30,010 --> 00:22:32,620
0,360 360,840 840,1500 1800,2400 2400,2610
therefore limit performance,| {} and
|因此，这就提出了何时锁定的问题。

694
00:22:32,620 --> 00:22:33,730
0,120 120,540 540,720 720,1050 1050,1110
so then this raises the

695
00:22:33,730 --> 00:22:35,540
0,420 420,690 690,810 810,1350
question when to lock.|
|

696
00:22:42,710 --> 00:22:43,820
0,540 600,810 810,930 930,990 990,1110
And I'm going to give
我要给你们一种保守的规则，

697
00:22:43,820 --> 00:22:45,950
0,90 90,270 270,360 360,1530 1530,2130
you sort of {} conservative

698
00:22:45,950 --> 00:22:48,110
0,480 690,1200 1560,1920 1920,2100 2100,2160
rule,| {} but it's a
|但这是一个很好的起点，可以作为思考问题的起点。

699
00:22:48,110 --> 00:22:49,100
0,150 150,420 420,600 600,660 660,990
good one as a starting

700
00:22:49,100 --> 00:22:50,150
0,180 180,270 270,450 450,690 690,1050
point to think about things.|
|

701
00:22:50,680 --> 00:22:52,800
0,330 330,450 450,990 990,1500
So the conservative rule,
所以保守的规则，或者可能的指导方针是更好的，

702
00:22:56,930 --> 00:22:58,910
0,270 270,570 570,1260 1260,1470 1470,1980
or maybe guidelines is better,|
|

703
00:22:58,910 --> 00:22:59,860
0,660

704
00:23:00,090 --> 00:23:01,860
0,240 240,810 990,1170 1170,1470 1470,1770
{} [freezing] is that you
[冻结]是你有两个进程，两个进程访问，一个共享的数据结构。

705
00:23:01,860 --> 00:23:03,660
0,150 150,330 330,1170
have two processes,

706
00:23:05,740 --> 00:23:08,400
0,330 330,1080 1110,1950
two processes access,

707
00:23:09,280 --> 00:23:11,080
0,180 180,360 360,600 600,1230
a shared data structure.|
|

708
00:23:17,130 --> 00:23:18,990
0,210 210,480 480,660 660,1020 1470,1860
And one is, {} one
一个是，其中一个是作家或更新者

709
00:23:18,990 --> 00:23:20,480
0,120 120,240 240,690
of the {them,is}

710
00:23:20,750 --> 00:23:22,100
0,210 210,690 690,900 900,960 960,1350
a writer or an updater|
|

711
00:23:22,100 --> 00:23:24,110
0,270 360,630 630,1170 1650,1770 1770,2010
or so meaning it's actually
或者说，这意味着它实际上已经被修改为共享数据结构。

712
00:23:24,110 --> 00:23:25,310
0,150 150,630 630,720 720,930 930,1200
been modified to share data

713
00:23:25,310 --> 00:23:26,420
0,570
structure.|
|

714
00:23:27,050 --> 00:23:28,820
0,720 930,1230 1230,1350 1350,1440 1440,1770
Then you need to lock
那么您需要锁定该数据结构。

715
00:23:28,820 --> 00:23:30,300
0,120 120,210 210,450 450,930
for that data structure.|
|

716
00:23:40,620 --> 00:23:41,610
0,180 180,360 360,420 420,480 480,990
So this is a conservative
所以这是一条保守的规则，

717
00:23:41,610 --> 00:23:42,630
0,210 360,630 630,720 720,900 900,1020
rule,| sort of like a
|当您在编程时，有点像是一个危险信号

718
00:23:42,630 --> 00:23:44,550
0,240 240,780 840,1080 1080,1260 1260,1920
red flag, when you're programming|
|

719
00:23:44,550 --> 00:23:47,190
0,900 1020,1230 1230,1680 1680,2430 2430,2640
and you have a data
并且您有一个可由多个进程访问的数据结构

720
00:23:47,190 --> 00:23:48,360
0,420 420,540 540,660 660,990 990,1170
structure that is accessed by

721
00:23:48,360 --> 00:23:49,800
0,360 360,990 990,1110 1110,1320 1320,1440
multiple processes| and what could
|什么可能是一位作家呢？

722
00:23:49,800 --> 00:23:50,820
0,90 90,150 150,660 720,870 870,1020
be a writer| at that
|在这一点上，你应该在想，

723
00:23:50,820 --> 00:23:51,960
0,240 240,450 450,660 660,780 780,1140
point you should be thinking,|
|

724
00:23:51,960 --> 00:23:53,130
0,300 300,510 510,570 570,1080 1080,1170
okay, there's a possibility of
好的，有可能有比赛情况，

725
00:23:53,130 --> 00:23:54,510
0,240 240,780 960,1050 1050,1230 1230,1380
race condition,| you want to
|您希望在竞争条件下避免这种情况，

726
00:23:54,510 --> 00:23:55,530
0,360 360,600 600,780 780,840 840,1020
avoid this in a race

727
00:23:55,530 --> 00:23:57,090
0,510 750,1080 1080,1350 1350,1470 1470,1560
condition,| you stick in a
|你把它锁起来，

728
00:23:57,090 --> 00:23:58,320
0,510 540,660 660,990 990,1170 1170,1230
lock,| {} will use a
|将使用锁来保证此争用情况不会发生。

729
00:23:58,320 --> 00:24:00,360
0,390 390,630 630,1230 1260,1920 1920,2040
lock to a guarantee that

730
00:24:00,360 --> 00:24:01,650
0,150 150,330 330,660 660,930 930,1290
this race condition can't happen.|
|

731
00:24:02,450 --> 00:24:04,220
0,420 570,990 990,1080 1080,1230 1230,1770
But you know those rules,
但是你知道那些规则，在某些方面太严格了。

732
00:24:04,310 --> 00:24:05,930
0,570 570,960 1050,1260 1260,1470 1470,1620
{} in some ways too

733
00:24:05,930 --> 00:24:07,060
0,540
strict.|
|

734
00:24:10,890 --> 00:24:12,600
0,240 240,480 480,540 540,990 990,1710
{} There are cases where
在某些情况下，可以处理共享数据结构的这些操作

735
00:24:12,630 --> 00:24:14,520
0,240 240,960 1230,1350 1350,1710 1710,1890
it's OK to process these

736
00:24:14,520 --> 00:24:15,600
0,300 300,360 360,570 570,780 780,1080
actions of shared data structure|
|

737
00:24:15,600 --> 00:24:16,470
0,90 90,300 300,360 360,420 420,870
and one is a writer
其中一个是特别的作家，

738
00:24:16,530 --> 00:24:19,110
0,540 870,1530 1530,1680 1680,2010 2010,2580
in particular,| there are styles
|有一些编程风格称为无锁编程。

739
00:24:19,110 --> 00:24:20,970
0,360 420,1110 1110,1410 1410,1680 1680,1860
of programming called lock free

740
00:24:20,970 --> 00:24:22,180
0,660
programming.|
|

741
00:24:22,610 --> 00:24:24,470
0,210 210,390 390,660 660,1290 1440,1860
{} That actually totally worthy
这实际上是完全值得的，有价值的各种场景确实会发生。

742
00:24:24,620 --> 00:24:26,720
0,660 660,930 930,1470 1470,1800 1800,2100
worthy {kinds,of} scenarios actually do

743
00:24:26,720 --> 00:24:27,920
0,510
happen.|
|

744
00:24:32,310 --> 00:24:33,240
0,300 300,390 390,600 600,660 660,930
Anyway, you want to lock
无论如何，您想锁定自由编程

745
00:24:33,240 --> 00:24:34,320
0,150 150,570 570,660 660,1020 1020,1080
free programming| is basically to
基本上是为了获得更好的性能或更多的并行性。

746
00:24:34,320 --> 00:24:35,880
0,120 120,330 330,1020 1080,1260 1260,1560
get better performance or more

747
00:24:35,880 --> 00:24:37,060
0,540
parallelism.|
|

748
00:24:38,730 --> 00:24:40,260
0,360 360,510 510,840 840,990 990,1530
Lock free program is tricky,|
无锁程序很棘手，|

749
00:24:40,350 --> 00:24:41,850
0,510 510,720 720,990 990,1380 1380,1500
{} even more tricky than
甚至比编程锁更棘手，

750
00:24:41,850 --> 00:24:44,310
0,510 510,1080 1440,2130 2130,2220 2220,2460
programming locks,| and {you,know} we'll
|你知道我们会在本学期末讨论这个问题，

751
00:24:44,310 --> 00:24:45,030
0,240 240,420 420,510 510,600 600,720
talk about it at the

752
00:24:45,030 --> 00:24:45,930
0,120 120,210 210,360 360,810 810,900
end of this semester,| we
|我们将研究一些编程的解锁样式

753
00:24:45,930 --> 00:24:48,210
0,120 150,570 570,990 990,1950 1980,2280
will study some {} lock

754
00:24:48,210 --> 00:24:49,890
0,210 210,750 750,900 900,1110 1110,1680
free styles of the programming|
|

755
00:24:49,890 --> 00:24:52,770
0,270 300,900 900,1620 1650,2160 2160,2880
or particularly {} common in
或者在操作系统内核中特别常见。

756
00:24:52,800 --> 00:24:54,380
0,420 420,660 660,1170
operating system kernels.|
|

757
00:24:54,440 --> 00:24:55,400
0,210 210,360 360,660 660,780 780,960
{} {Basically -}, for this
基本上，对于这堂课，以及本学期的大部分睡觉，

758
00:24:55,400 --> 00:24:57,380
0,570 780,1200 1260,1710 1710,1800 1800,1980
lecture, and most of the

759
00:24:57,380 --> 00:24:58,610
0,180 180,240 240,300 300,840 930,1230
rest of the semester,| we're
|我们会考虑这个案子，

760
00:24:58,610 --> 00:24:59,630
0,120 120,180 180,390 390,690 690,1020
going to be thinking about

761
00:24:59,630 --> 00:25:02,030
0,60 60,480 480,1020 1200,1770 1770,2400
the case,| we're using locks,
|我们用的是锁，你知道是用来控制共享的。

762
00:25:02,030 --> 00:25:05,480
0,210 210,1530 1830,2790 2820,3030 3030,3450
{you,know} to control {} sharing.|
|

763
00:25:06,280 --> 00:25:08,050
0,810 840,1050 1050,1260 1260,1620 1650,1770
And that's hard enough,| you
这已经够难的了，|你知道你只用锁，

764
00:25:08,050 --> 00:25:09,490
0,360 390,750 750,960 960,1170 1170,1440
know you just use locks,|
|

765
00:25:09,490 --> 00:25:10,810
0,90 90,210 210,390 390,1020 1020,1320
its not that straightforward either.|
这也不是那么简单。|

766
00:25:12,520 --> 00:25:14,080
0,540 600,960 960,1170 1170,1380 1380,1560
{} So in one hand,
所以一方面，有点太严格了，

767
00:25:14,080 --> 00:25:15,490
0,30 30,180 180,780 780,870 870,1410
a little bit too strict,|
|

768
00:25:15,760 --> 00:25:17,200
0,510 510,900 900,1110 1110,1380 1380,1440
{} because not always the
因为并不总是你需要的箱子，也有一些箱子要松开。

769
00:25:17,200 --> 00:25:18,430
0,240 240,390 390,810 810,1080 1080,1230
case that you need and

770
00:25:18,430 --> 00:25:19,900
0,210 210,360 360,720 720,870 870,1470
also some cases to loose.|
|

771
00:25:20,230 --> 00:25:21,340
0,600

772
00:25:21,340 --> 00:25:22,780
0,150 150,300 300,540 540,870
If you might just.|
如果你不介意的话。|

773
00:25:23,490 --> 00:25:24,760
0,780

774
00:25:26,200 --> 00:25:27,610
0,180 180,330 330,660 660,1260 1260,1410
You might even lose, you
你甚至可能会输，你想让你真正想要使用锁，

775
00:25:27,610 --> 00:25:28,240
0,150 150,210 210,420 420,540 540,630
want to actually make you

776
00:25:28,240 --> 00:25:29,320
0,150 150,210 210,420 420,870 870,1080
want to use locks,| {you,know}
|你知道要强制执行其他一些属性，

777
00:25:29,320 --> 00:25:31,630
0,240 240,630 630,750 750,1800 1830,2310
to enforce some other properties,|
|

778
00:25:31,630 --> 00:25:32,230
0,120 120,240 240,360 360,510 510,600
like if you look at
比如如果你看一下printf。

779
00:25:32,230 --> 00:25:33,400
0,240 240,510
{printf -}.|
|

780
00:25:34,790 --> 00:25:35,720
0,360

781
00:25:35,750 --> 00:25:36,890
0,210 210,300 300,630 630,660 660,1140
If we pass a string
如果我们将一个字符串传递给printf。

782
00:25:36,890 --> 00:25:38,280
0,150 150,390 390,780
to {printf -}.|
|

783
00:25:38,280 --> 00:25:39,720
0,450 450,570 570,690 690,990 990,1440
{} You know the xv6
您知道xv6内核试图

784
00:25:39,720 --> 00:25:40,890
0,300 300,570 570,720 720,840 840,1170
kernel tries to| at least
|至少您知道让整个字符串自动打印出来。

785
00:25:40,890 --> 00:25:41,940
0,60 60,330 360,570 570,660 660,1050
you know get the whole

786
00:25:41,940 --> 00:25:44,220
0,600 930,1050 1050,1290 1290,1650 1650,2280
string to be printed atomically.|
|

787
00:25:44,760 --> 00:25:46,200
0,660 660,1050 1050,1170 1170,1260 1260,1440
{} And you know there's
而且你知道这里不涉及共享数据结构，

788
00:25:46,200 --> 00:25:47,640
0,120 120,330 330,570 570,870 870,1440
no shared data structure involved,|
|

789
00:25:47,850 --> 00:25:49,680
0,360 360,540 540,660 660,1200 1230,1830
{} but it's still useful
但在这种情况下实际使用锁仍然很有用，

790
00:25:49,680 --> 00:25:50,610
0,120 120,390 390,570 570,630 630,930
to actually use a lock

791
00:25:50,610 --> 00:25:51,930
0,60 60,210 210,540 540,900 900,1320
in that particular case,| because
|因为我们希望输出被序列化。

792
00:25:51,930 --> 00:25:52,710
0,90 90,270 270,390 390,690 690,780
we want the output to

793
00:25:52,710 --> 00:25:53,880
0,90 90,720
be serialized.|
|

794
00:25:54,220 --> 00:25:55,330
0,330 330,660 690,870 870,1050 1050,1110
{} So this rule is
所以这个规则并不完美，

795
00:25:55,330 --> 00:25:56,890
0,480 480,990 990,1380 1380,1470 1470,1560
not perfect,| but it's a
|但这是一个相当好的指导方针。

796
00:25:56,890 --> 00:25:58,460
0,270 270,480 480,990
pretty good guideline.|
|

797
00:26:00,020 --> 00:26:01,910
0,210 210,630 630,870 870,1380 1380,1890
Any questions about this rule?|
对这条规定有什么问题吗？|

798
00:26:04,810 --> 00:26:05,950
0,300 300,450 450,630 630,720 720,1140
{} I had a question
我有一个问题不是关于这个规则的，

799
00:26:05,950 --> 00:26:07,270
0,180 180,420 420,660 660,900 900,1320
not about this rule,| but
|但是有没有可能两个进程同时获取锁呢

800
00:26:07,960 --> 00:26:09,490
0,300 300,450 450,870 870,1200 1290,1530
isn't it possible that two

801
00:26:09,490 --> 00:26:11,020
0,570 570,720 720,1170 1170,1290 1290,1530
processes could acquire the lock

802
00:26:11,020 --> 00:26:12,130
0,90 90,180 180,510 510,930 930,1110
at the same time| and
|因此可以修改结构。

803
00:26:12,130 --> 00:26:13,200
0,450
so

804
00:26:13,470 --> 00:26:14,940
0,150 150,330 330,630 630,930 960,1470
would be able to modify

805
00:26:14,940 --> 00:26:16,280
0,90 90,750
the structure.|
|

806
00:26:16,460 --> 00:26:17,780
0,240 240,450 450,660 660,840 840,1320
Yeah, no so so part
是的，不是的，所以合同锁结构的一部分就是

807
00:26:17,780 --> 00:26:18,980
0,120 120,270 270,420 420,480 480,1200
of the sort of contract

808
00:26:19,130 --> 00:26:20,420
0,240 240,780 780,960 960,1110 1110,1290
lock construction is is that|
|

809
00:26:20,420 --> 00:26:22,850
0,210 210,870 870,1320 1320,1920 1950,2430
it's impossible to a process
一个进程同时获取和锁定是不可能的。

810
00:26:22,850 --> 00:26:23,810
0,90 90,540 540,630 630,900 900,960
to acquire to lock at

811
00:26:23,810 --> 00:26:24,960
0,60 60,270 270,600
the same time.|
|

812
00:26:25,290 --> 00:26:28,440
0,600 630,1170 1170,1530 2460,2940 2940,3150
{} If a rule is
如果规则是曾经有过不，那就永远不会有案子，

813
00:26:28,440 --> 00:26:30,060
0,180 180,450 450,810 810,1080 1080,1620
that there's ever there's no,

814
00:26:30,180 --> 00:26:31,500
0,300 300,510 510,600 600,960 960,1320
there's never a case,| where
|其中两个进程实际获得了锁，可以同时持有锁，

815
00:26:31,500 --> 00:26:33,270
0,510 540,1080 1080,1380 1380,1710 1710,1770
two process actually acquired the

816
00:26:33,270 --> 00:26:35,040
0,330 1110,1260 1260,1470 1470,1530 1530,1770
lock, can hold the lock

817
00:26:35,040 --> 00:26:36,360
0,90 90,150 150,360 360,600 900,1320
at the same time,| {we'll,see}
|我们将在第二节中看到，如何实现这一点，

818
00:26:36,360 --> 00:26:36,990
0,60 60,120 120,390 390,510 510,630
in the second, how to

819
00:26:36,990 --> 00:26:38,790
0,390 390,600 600,1200 1200,1320 1320,1800
implement that,| but the API
|但是API或规范要求是，

820
00:26:38,790 --> 00:26:40,980
0,150 150,210 210,1020 1020,1620 2010,2190
or the specification {require,is},| there's
|在任何给定的时间点或零，只有一个锁持器。

821
00:26:40,980 --> 00:26:42,180
0,180 180,450 450,690 690,1020 1020,1200
only one lock holder at

822
00:26:42,180 --> 00:26:43,200
0,210 210,480 480,690 690,750 750,1020
any given point in time

823
00:26:43,350 --> 00:26:45,000
0,180 180,1230
or zero.|
|

824
00:26:45,090 --> 00:26:46,100
0,450
Yes.|
是。|

825
00:26:49,300 --> 00:26:52,000
0,570 630,1230 1260,1860 2070,2520 2520,2700
{} Okay, so, {} you
好的，你知道，如果我们看到你知道一点编程锁，

826
00:26:52,000 --> 00:26:52,810
0,150 150,270 270,360 360,540 540,810
know if we see you

827
00:26:52,810 --> 00:26:55,390
0,180 180,600 600,1170 1500,2100 2100,2580
know programming lock slightly {},|
|

828
00:26:55,390 --> 00:26:57,100
0,300 300,450 450,900 930,1500 1500,1710
it could be problematic, because
这可能是有问题的，因为这些比赛条件。

829
00:26:57,100 --> 00:26:58,600
0,60 60,210 210,390 390,990
of these race conditions.|

830
00:26:58,600 --> 00:26:59,680
0,540

831
00:26:59,950 --> 00:27:01,870
0,600 600,720 720,990 990,1080 1080,1920
{You,know}, of course the particular
你知道，当然是特殊的比赛条件，我们在自由赛道上看到的

832
00:27:01,870 --> 00:27:02,860
0,210 210,510 510,630 630,720 720,990
race condition, that we looked

833
00:27:02,860 --> 00:27:05,440
0,270 330,1050 1050,1860 1890,2100 2100,2580
at {} {in,the} {kfree -}|
|

834
00:27:05,620 --> 00:27:06,640
0,210 210,390 390,480 480,930 930,1020
or that we created in
或者是我们在[疯狂]中创造的，

835
00:27:06,640 --> 00:27:08,620
0,540 720,900 900,1080 1110,1500 1500,1980
[crazy],| which were easily [spotted]
|在某些方面很容易被发现

836
00:27:08,620 --> 00:27:09,550
0,120 120,330 330,660 660,810 810,930
in some ways| and the
|事实上，你知道如果使用种族检测工具，

837
00:27:09,550 --> 00:27:10,660
0,300 300,390 390,510 510,660 660,1110
fact you know if {use,a}

838
00:27:10,660 --> 00:27:12,370
0,120 120,600 600,1170 1230,1620 1620,1710
race detection tool,| {} it
|它会立即找到它。

839
00:27:12,370 --> 00:27:13,820
0,150 150,540 540,810 810,1050
would immediately find it.|
|

840
00:27:13,820 --> 00:27:15,380
0,540 690,1050 1050,1380 1380,1410 1410,1560
{} But there are more
但还有更棘手的案子，

841
00:27:15,380 --> 00:27:18,110
0,540 540,1170 1470,2100 2310,2550 2550,2730
tricky cases,| {} so you
|所以你可能会想，为什么我们不能让你做锁

842
00:27:18,110 --> 00:27:19,760
0,180 180,870 870,1020 1020,1440 1440,1650
may wonder like why couldn't

843
00:27:19,760 --> 00:27:21,410
0,150 150,330 330,870 900,1440 1440,1650
we like make you make

844
00:27:21,410 --> 00:27:23,690
0,690 1020,1260 1260,1620 1620,1830 1830,2280
locks| or who make locking
|也不知道是谁把锁设为自动的。

845
00:27:23,690 --> 00:27:24,780
0,660
automatic.|
|

846
00:27:31,120 --> 00:27:32,980
0,360 360,600 600,930 930,1260 1500,1860
So you follow this simple
所以你要遵循这个简单的规则，也就是我刚才说的，

847
00:27:32,980 --> 00:27:34,450
0,330 330,510 510,1110 1110,1290 1290,1470
rule, that {I,just,stated},| you know
|你知道，如果我们每次共享数据结构，

848
00:27:34,450 --> 00:27:35,650
0,270 270,420 420,690 690,930 930,1200
then if every we shared

849
00:27:35,650 --> 00:27:37,690
0,240 240,840 1050,1800 1800,1860 1860,2040
data structure,| then you know
|那么您就知道共享数据结构中的操作基本上需要锁定，

850
00:27:37,690 --> 00:27:38,950
0,600 600,660 660,810 810,1020 1020,1260
operations in that shared data

851
00:27:38,950 --> 00:27:41,170
0,300 300,630 630,1170 1170,1560 1590,2220
structure basically require lock,| we
|我们实际上应该把锁和每个操作中的数据结构关联起来，

852
00:27:41,290 --> 00:27:42,340
0,240 240,660 660,720 720,960 960,1050
should associate a lock with

853
00:27:42,340 --> 00:27:43,510
0,120 120,330 330,870 960,1110 1110,1170
the data structure in the

854
00:27:43,510 --> 00:27:46,060
0,240 240,720 720,1230 1230,1560 1980,2550
every operations actually {} {},|
|

855
00:27:48,270 --> 00:27:49,950
0,180 180,420 420,600 600,1230 1230,1680
That is a it's performed
也就是说，它在数据结构上执行，

856
00:27:49,950 --> 00:27:53,340
0,120 120,420 420,1770 2610,3120 3120,3390
on that {} data structure,|
|

857
00:27:53,340 --> 00:27:54,540
0,330 330,690 690,780 780,1080 1080,1200
basically acquire or release the
基本上是获取或释放锁。

858
00:27:54,540 --> 00:27:55,320
0,300
lock.|
|

859
00:27:55,320 --> 00:27:56,370
0,300 480,690 690,810 810,900 900,1050
So one way to think
所以一种方式来考虑它，

860
00:27:56,370 --> 00:27:58,020
0,240 240,300 300,900 1020,1410 1410,1650
about it,| maybe in xv6
|也许在xv6术语中，就像你所知道的每一种结构一样，都有一个锁。

861
00:27:58,020 --> 00:28:00,000
0,390 390,570 570,840 840,1350
terms like every structure

862
00:28:00,430 --> 00:28:02,900
0,750 750,1380 1380,1920
{you,know}, has {a,lock}.|
|

863
00:28:04,440 --> 00:28:06,840
0,1620 1680,1890 1890,2100 2100,2340 2340,2400
And in that lock is
在该锁中是原子获取的，

864
00:28:06,840 --> 00:28:08,310
0,510 510,960 960,1170 1170,1320 1320,1470
atomically acquired,| when we do
|当我们做任何与该结构相关的事情时，

865
00:28:08,310 --> 00:28:09,660
0,330 330,660 660,750 750,900 900,1350
anything related to that struct,|
|

866
00:28:09,750 --> 00:28:10,800
0,360 360,570 570,780 780,990 990,1050
it just turns out to
结果发现它太死板了，

867
00:28:10,800 --> 00:28:11,780
0,360
be

868
00:28:11,780 --> 00:28:12,830
0,120 120,630 720,870 870,990 990,1050
too rigid,| and this is
|这就是为什么您知道锁定不可能真的是原子的原因。

869
00:28:12,830 --> 00:28:14,330
0,480 510,630 630,870 900,1290 1290,1500
why you know locking can

870
00:28:14,330 --> 00:28:16,250
0,270 270,510 510,900 960,1260 1260,1920
not really be {} atomic.|
|

871
00:28:16,800 --> 00:28:19,260
0,900 1230,1380 1380,1500 1500,1890 1890,2460
So we've been operating systems,|
所以我们一直在运行操作系统，|

872
00:28:19,260 --> 00:28:20,400
0,120 120,570 570,750 750,810 810,1140
an example from an operating
来自操作系统的示例如下所示，

873
00:28:20,400 --> 00:28:21,840
0,300 300,390 390,480 480,930 1230,1440
system is the following,| let's
|假设我们有一个类似“重命名”的电话。

874
00:28:21,840 --> 00:28:23,280
0,210 210,420 420,960 990,1110 1110,1440
say we have a call

875
00:28:23,280 --> 00:28:24,620
0,210 210,840
like rename.|
|

876
00:28:25,530 --> 00:28:27,510
0,210 210,570 570,660 660,1500 1830,1980
That moves the filename from
它将文件名从一个目录移动到另一个目录，

877
00:28:27,510 --> 00:28:29,370
0,180 180,840 870,1020 1020,1290 1290,1860
one directory to another directory,|
|

878
00:28:29,490 --> 00:28:30,570
0,240 240,450 450,660 660,810 810,1080
so let's say we have
假设我们有d1x，

879
00:28:30,570 --> 00:28:32,160
0,210 210,510 510,1050
d one x,|
|

880
00:28:32,160 --> 00:28:34,290
0,420 420,600 600,1170 1170,1440 1440,2130
and we rename it to
我们把它重命名为d2y。

881
00:28:34,320 --> 00:28:37,300
0,930 960,1530 1920,2400
d two y.|
|

882
00:28:37,840 --> 00:28:38,560
0,180 180,420 420,540 540,660 660,720
And so we have the
所以我们在目录中有文件名，d1x，

883
00:28:38,560 --> 00:28:39,850
0,270 270,480 480,540 540,630 630,1290
file name in the directory,

884
00:28:39,850 --> 00:28:41,260
0,390 390,630 630,720 720,1050 1050,1410
{} d {one -} x,|
|

885
00:28:41,260 --> 00:28:43,150
0,360 360,810 810,1260 1260,1380 1380,1890
and we rename it to
我们把它重命名为d2Slice y。

886
00:28:43,360 --> 00:28:45,400
0,540 540,780 780,1110 1110,1530
d two slice y.|
|

887
00:28:45,460 --> 00:28:48,010
0,180 180,240 240,750 750,1530 1770,2550
So the way {} truly,
所以真正的方法是，如果我们遵循严格的规则，

888
00:28:48,610 --> 00:28:49,660
0,210 210,300 300,630 630,720 720,1050
if we followed the rigid

889
00:28:49,660 --> 00:28:51,130
0,480 480,660 660,960 990,1380 1380,1470
rule,| like this rule of
|就像这个原子锁定规则，你知道会发生什么。

890
00:28:51,130 --> 00:28:52,510
0,420 420,840 840,960 960,1260 1260,1380
atomic locking {you,know} what would

891
00:28:52,510 --> 00:28:53,740
0,390 390,750
happen is.|
|

892
00:28:53,740 --> 00:28:55,240
0,630 750,870 870,990 990,1290 1290,1500
{} You know that that
你知道，当我们有两个物体时，这条规则就会上升，

893
00:28:55,240 --> 00:28:56,050
0,300 300,420 420,510 510,630 630,810
{rule,up} when we have two

894
00:28:56,050 --> 00:28:57,340
0,510 510,690 690,870 870,1170 1170,1290
objects,| we've d one and
|我们已经做了d1和d2。

895
00:28:57,340 --> 00:28:58,520
0,150 150,600
d two.|
|

896
00:28:58,820 --> 00:28:59,720
0,120 120,330 330,480 480,780 780,900
And so we follow the
所以我们遵循规则，然后基本上是原子规则，

897
00:28:59,720 --> 00:29:01,760
0,270 270,570 570,1230 1230,1740 1740,2040
rule, then basically atomic rule,|
|

898
00:29:01,760 --> 00:29:03,380
0,540 540,720 720,990 990,1170 1170,1620
then we lock d one,
然后我们锁定d-1，你知道，删除x，然后释放d-1的锁。

899
00:29:05,780 --> 00:29:07,540
0,120 120,300 300,690 690,1200
you know erase x,

900
00:29:08,990 --> 00:29:11,680
0,1320 1350,2220
and release

901
00:29:13,000 --> 00:29:15,660
0,390 390,1050 1110,1680 1680,2070
{the,lock} for d one.|
|

902
00:29:17,740 --> 00:29:18,970
0,180 180,900 900,990 990,1110 1110,1230
And then we do the
然后我们做数据的第二部分，

903
00:29:18,970 --> 00:29:20,560
0,270 270,810 840,1020 1020,1500 1500,1590
second part of data,| you
|你知道D2锁D2加y，

904
00:29:20,560 --> 00:29:23,080
0,90 90,660 660,1170 1170,1920
know d2 lock d2

905
00:29:23,400 --> 00:29:24,720
0,690
add

906
00:29:25,150 --> 00:29:27,140
0,270 270,1350
{} y,|
|

907
00:29:27,140 --> 00:29:29,080
0,480 480,1320
and release
释放D2。

908
00:29:29,950 --> 00:29:31,140
0,690
d2.|
|

909
00:29:32,000 --> 00:29:33,460
0,720

910
00:29:33,460 --> 00:29:34,150
0,150 150,240 240,300 300,510 540,690
And then we're done.| So
然后我们就完事了。|所以这将是一种假设的图式

911
00:29:34,150 --> 00:29:35,110
0,150 150,300 300,480 480,750 750,960
this would be the sort

912
00:29:35,110 --> 00:29:39,790
0,120 120,1200 1200,2670 2670,3480 4170,4680
of hypothetical schema| and you
|你可以想象如果我们进行原子锁定会发生什么，

913
00:29:39,790 --> 00:29:41,590
0,690 690,1140 1140,1320 1320,1650 1650,1800
imagine {} would happen if

914
00:29:41,590 --> 00:29:43,360
0,90 90,390 390,780 780,1260
we did atomic locking

915
00:29:43,360 --> 00:29:45,310
0,630 870,1350 1350,1650 1650,1740 1740,1950
in,| {} and the point
|这个例子的重点是会产生错误的结果

916
00:29:45,310 --> 00:29:46,330
0,60 60,240 240,630 630,870 870,1020
of this example is going

917
00:29:46,330 --> 00:29:47,500
0,420 420,600 600,810 810,900 900,1170
to will have the wrong

918
00:29:47,500 --> 00:29:50,200
0,420 780,1170 1170,2100 2100,2610 2610,2700
outcome| and why, why is
|为什么，为什么这是一个有问题的计划，

919
00:29:50,200 --> 00:29:52,360
0,150 150,540 540,1200 1200,1620 1890,2160
this a problematic scheme,| why
为什么这行不通。

920
00:29:52,360 --> 00:29:53,350
0,120 120,270 270,450 450,600 600,990
is this not gonna work.|
|

921
00:30:03,170 --> 00:30:04,760
0,180 180,360 360,660 660,1320 1320,1590
So, think about like the
所以，我们要考虑的就是这个时期。

922
00:30:04,760 --> 00:30:05,390
0,120 120,210 210,330 330,570 570,630
thing to think about is

923
00:30:05,390 --> 00:30:07,180
0,600 630,1230
this period.|
|

924
00:30:08,000 --> 00:30:09,080
0,300 300,510 510,750 750,840 840,1080
So we've done the first
所以我们已经完成了第一步，第一步。

925
00:30:09,080 --> 00:30:10,180
0,630
step,

926
00:30:10,610 --> 00:30:11,880
0,210 210,750
step one.|
|

927
00:30:12,050 --> 00:30:13,460
0,390 390,630 630,870 870,1260 1260,1410
Not done step, step two
还没走完，第二步还没走完。

928
00:30:13,460 --> 00:30:14,440
0,420
yet.|
|

929
00:30:14,630 --> 00:30:16,640
0,630 630,780 780,1110 1110,1470 1470,2010
What could another process observe.|
另一个过程可以观察到什么。|

930
00:30:24,160 --> 00:30:25,340
0,660
Anybody?
有人吗？把它归档就这么走了。

931
00:30:28,950 --> 00:30:30,480
0,540 540,690 690,930 930,1140 1140,1530
File it just be gone.|
|

932
00:30:30,870 --> 00:30:32,430
0,510 510,630 630,750 750,990 990,1560
Yeah you know this there's
是的，你知道在第一步和第二步之间，

933
00:30:32,430 --> 00:30:33,810
0,600 600,840 840,1020 1020,1140 1140,1380
between step one and two,|
|

934
00:30:33,810 --> 00:30:35,520
0,90 90,330 330,570 570,1140
the file doesn't exist.|
该文件不存在。|

935
00:30:41,520 --> 00:30:42,510
0,90 90,300 300,450 450,540 540,990
I mean that is clearly
我的意思是这显然是错误的，

936
00:30:42,510 --> 00:30:44,370
0,540 570,1170 1170,1290 1290,1620 1620,1860
wrong,| because the file does
|因为该文件确实存在，所以它只是被重命名，

937
00:30:44,370 --> 00:30:46,470
0,570 900,1080 1080,1290 1290,1500 1500,2100
exist, it just being renamed,|
|

938
00:30:46,710 --> 00:30:48,240
0,390 390,690 690,1020 1020,1350 1350,1530
{} and never point {}
也从来没有指出过它并不存在，

939
00:30:48,240 --> 00:30:49,410
0,210 210,330 330,420 420,660 660,1170
really that it didn't exist,|
|

940
00:30:50,430 --> 00:30:52,110
0,300 300,510 510,1200 1200,1530 1530,1680
but by implementing it in
但是通过以这种方式实现它，

941
00:30:52,110 --> 00:30:53,580
0,210 210,780 930,1200 1200,1320 1320,1470
this way,| {} it just
|只是看起来该文件可能实际上并不存在，尽管它确实存在。

942
00:30:53,580 --> 00:30:55,290
0,750 750,1050 1050,1170 1170,1500 1500,1710
appears that the file might

943
00:30:55,290 --> 00:30:56,550
0,210 210,450 450,870 870,1080 1080,1260
actually not exist even though

944
00:30:56,550 --> 00:30:57,400
0,60 60,450
it does.|
|

945
00:30:57,800 --> 00:30:59,330
0,330 330,450 450,780 780,1230 1350,1530
So the really right {}
所以真正正确的解决方案是

946
00:30:59,330 --> 00:31:00,440
0,390 390,480 480,750 750,900 900,1110
solution to this is| what
|我们需要的是先锁定d1和d2，

947
00:31:00,440 --> 00:31:01,560
0,90 90,540
we need

948
00:31:03,460 --> 00:31:04,750
0,330 330,450 450,600 600,810 810,1290
is that we actually lock

949
00:31:04,750 --> 00:31:06,160
0,120 120,870
d one,

950
00:31:07,460 --> 00:31:09,230
0,390 390,870 870,1470 1560,1710 1710,1770
and d2 first,| at the
|在重命名开始时，

951
00:31:09,230 --> 00:31:10,760
0,300 300,420 420,1020
beginning of rename,|
|

952
00:31:10,760 --> 00:31:11,920
0,510
then
然后擦除并添加，

953
00:31:11,920 --> 00:31:13,720
0,120 120,600 600,690 690,1200
{erase -} and add,|
|

954
00:31:15,780 --> 00:31:17,920
0,180 180,690 720,1530
and then release
然后解开d1和d2的锁。

955
00:31:18,880 --> 00:31:19,870
0,390 390,480 480,810 810,900 900,990
{} the locks for d

956
00:31:19,870 --> 00:31:20,980
0,480
one

957
00:31:20,980 --> 00:31:22,280
0,330 330,600
{and,d} two.|
|

958
00:31:24,500 --> 00:31:25,840
0,150 150,240 240,420 420,750
So, that makes sense.|
所以，这是有道理的。|

959
00:31:26,870 --> 00:31:28,610
0,150 150,540 540,600 600,1080 1080,1740
So here's an example| where
这里有一个例子|其中我们有一个需要多个锁的[]操作

960
00:31:28,760 --> 00:31:30,290
0,420 420,570 570,690 690,750 750,1530
{} we have an operation

961
00:31:30,410 --> 00:31:32,810
0,840 870,1380 1380,1590 1590,1920 1920,2400
that [] needs multiple locks|
|

962
00:31:32,960 --> 00:31:34,970
0,840 870,1500 1500,1620 1620,1710 1710,2010
and {} and the locks
并且锁不能真正与这两个对象相关联，

963
00:31:34,970 --> 00:31:36,560
0,480 480,720 720,840 840,1440 1440,1590
cannot really be associated with

964
00:31:36,560 --> 00:31:37,850
0,270 270,510 510,990 990,1110 1110,1290
the two objects,| that are
|这些都是这个运算的参数，

965
00:31:37,850 --> 00:31:39,170
0,90 90,480 480,570 570,690 690,1320
the arguments of this operation,|
|

966
00:31:39,590 --> 00:31:40,580
0,360 360,540 540,780 780,840 840,990
{} it has to be
实际上操作本身必须首先需要两个锁，

967
00:31:40,580 --> 00:31:41,570
0,60 60,390 390,570 570,900 900,990
the case that actually the

968
00:31:41,570 --> 00:31:43,730
0,390 390,750 750,1140 1170,1740 1740,2160
operation itself first requires both

969
00:31:44,270 --> 00:31:46,580
0,570 570,1080 1200,1530 1530,1650 1650,2310
locks,| then perform the operations.|
|然后执行操作。|

970
00:31:47,400 --> 00:31:48,660
0,180 180,360 360,780 780,1140 1140,1260
So there's atomic locking is
所以原子锁定不是直接可能的。

971
00:31:48,660 --> 00:31:51,100
0,360 750,1350 1350,1830
not directly possible.|
|

972
00:31:51,250 --> 00:31:52,120
0,180 180,300 300,360 360,450 450,870
There's going to be cases,|
会有案子的，|

973
00:31:52,120 --> 00:31:54,550
0,360 360,720 720,1080 1260,2160 2280,2430
where there's not run to
在没有运行[本地]方案的情况下

974
00:31:54,550 --> 00:31:56,380
0,420 690,1110 1110,1440 1440,1560 1560,1830
the [native] scheme| at least
|至少会遇到一个问题问题。

975
00:31:56,380 --> 00:31:57,700
0,150 150,360 360,570 570,870 870,1320
will run into a problem

976
00:31:57,730 --> 00:31:58,800
0,630
problems.|
|

977
00:32:00,400 --> 00:32:01,980
0,180 180,480 480,630 630,900
Any questions about this?|
对此有什么问题吗？|

978
00:32:07,010 --> 00:32:08,570
0,420 570,870 870,1020 1020,1320 1320,1560
So could we just say
所以我们能不能就这么说，

979
00:32:08,570 --> 00:32:10,400
0,330 360,810 840,1110 1110,1350 1350,1830
that,| {} when we're accessing
|当我们访问数据结构时，

980
00:32:10,400 --> 00:32:11,390
0,60 60,300 300,720 720,840 840,990
a data structure,| we just
|我们只需要访问或者我们必须获取

981
00:32:11,390 --> 00:32:12,830
0,180 180,480 510,1110 1110,1320 1320,1440
have to access or we

982
00:32:12,830 --> 00:32:13,850
0,90 90,180 180,660 660,900 900,1020
have to acquire| all of
|所有锁都与我们一开始需要的所有数据结构相关联。

983
00:32:13,850 --> 00:32:15,800
0,120 120,600 600,1260 1260,1590 1710,1950
the locks associated with all

984
00:32:15,800 --> 00:32:16,850
0,120 120,210 210,420 420,900 900,1050
of the data structures we

985
00:32:16,850 --> 00:32:18,820
0,390 720,930 930,990 990,1500
need at the beginning.|
|

986
00:32:19,120 --> 00:32:20,350
0,240 240,330 330,720 750,1080 1080,1230
That be one,| yeah, so
这就是其中之一|是啊，所以这是一种方法

987
00:32:20,350 --> 00:32:21,520
0,240 240,510 510,660 660,930 930,1170
that's one way doing it|
|

988
00:32:21,520 --> 00:32:22,090
0,120 120,180 180,330 330,480 480,570
and I think that we
我认为我们应该很快就会归结到基本上拥有一个很大的内核锁。

989
00:32:22,090 --> 00:32:25,030
0,210 240,780 780,2190 2520,2670 2670,2940
should quickly will come down

990
00:32:25,030 --> 00:32:25,870
0,90 90,390 390,630 630,690 690,840
to basically having a big

991
00:32:25,870 --> 00:32:27,040
0,300 300,660
kernel lock.|
|

992
00:32:27,380 --> 00:32:29,660
0,1410 1410,1920 1920,2010 2010,2070 2070,2280
Okay.| You're on the risk,
好吧。|你在冒险，基本上不再有平行关系，

993
00:32:29,660 --> 00:32:31,190
0,360 360,450 450,570 570,1050 1050,1530
basically have no parallelism anymore,|
|

994
00:32:31,850 --> 00:32:32,420
0,180 180,300 300,420 420,480 480,570
so you want to do
所以你想做得更好，对吧，

995
00:32:32,420 --> 00:32:34,370
0,240 240,360 360,750 780,1140 1770,1950
better than that right,| and
|我认为这一直是紧张的原因，

996
00:32:34,370 --> 00:32:35,180
0,60 60,210 210,360 360,450 450,810
I think this is always

997
00:32:35,180 --> 00:32:36,170
0,90 90,510 570,750 750,840 840,990
the tension,| you know you
|你知道你可以通过所谓的粗粒度锁定让事情变得简单，

998
00:32:36,170 --> 00:32:37,730
0,90 90,210 210,390 390,930 960,1560
can make things simpler by

999
00:32:37,730 --> 00:32:40,670
0,630 630,900 900,1320 1350,2400 2400,2940
basically what's called coarse-grained locking,|
|

1000
00:32:41,060 --> 00:32:42,200
0,390 390,570 570,930 930,1020 1020,1140
{} but then you know
但之后你就会知道你会输掉那些表演

1001
00:32:42,200 --> 00:32:43,240
0,120 120,630
you're lose

1002
00:32:43,820 --> 00:32:45,350
0,270 270,810 1170,1350 1350,1410 1410,1530
those performance| or you may
|否则你可能会失去表演能力，

1003
00:32:45,350 --> 00:32:46,740
0,270 270,840
lose performance,|
|

1004
00:32:46,740 --> 00:32:47,910
0,300 300,390 390,480 480,810 810,1170
depending if the locks intended
取决于锁是不是有意的。

1005
00:32:47,910 --> 00:32:48,840
0,60 60,360
or not.|
|

1006
00:32:49,730 --> 00:32:51,360
0,840 840,1020
Thank you.|
谢谢。|

1007
00:32:52,700 --> 00:32:54,410
0,330 330,720 750,1080 1080,1590 1590,1710
{} So lock perspective, so
所以从锁的角度来看，对锁有不同的看法。

1008
00:32:54,410 --> 00:32:57,770
0,240 240,660 660,1380 1830,2550 2850,3360
there's different ways to think

1009
00:32:57,770 --> 00:32:59,000
0,180 180,660
about locks.|
|

1010
00:32:59,650 --> 00:33:00,880
0,690

1011
00:33:00,910 --> 00:33:01,810
0,210 210,330 330,570 570,690 690,900
You know, those are three
你知道，这是三个常见的问题，

1012
00:33:01,810 --> 00:33:04,300
0,300 300,780 840,1560 1620,2370 2370,2490
common ones,| and, {} you
|而且，你知道，他们三个都要去

1013
00:33:04,300 --> 00:33:05,380
0,420 450,660 660,810 810,900 900,1080
know go for all three

1014
00:33:05,380 --> 00:33:06,250
0,60 60,240 240,360 360,570 570,870
of them| and just maybe
|也许这会帮助你思考锁的问题

1015
00:33:06,250 --> 00:33:07,510
0,180 180,300 300,570 570,1020 1050,1260
that may help you have

1016
00:33:07,510 --> 00:33:08,440
0,90 90,240 240,450 450,780 780,930
to think about locks| and
|也许其中一个是你的最爱

1017
00:33:08,440 --> 00:33:09,190
0,240 240,420 420,480 480,630 630,750
maybe one of them is

1018
00:33:09,190 --> 00:33:10,450
0,300 300,750 750,1050 1050,1140 1140,1260
your favorite| and you can
|你可以用这句话作为你思考问题的方式，

1019
00:33:10,450 --> 00:33:12,220
0,120 120,300 300,630 1050,1560 1560,1770
use that one {} as

1020
00:33:12,220 --> 00:33:13,240
0,240 240,420 420,510 510,780 780,1020
your way of thinking about

1021
00:33:13,240 --> 00:33:14,230
0,60 60,240 240,390 390,690 690,990
it,| but there's probably helpful
|但是看到他们实际上是以不同的方式来思考锁可能会有所帮助。

1022
00:33:14,230 --> 00:33:15,160
0,120 120,450 450,600 600,720 720,930
to see that they're actually

1023
00:33:15,160 --> 00:33:16,270
0,300 300,510 510,600 600,870 870,1110
different ways of thinking about

1024
00:33:16,270 --> 00:33:17,060
0,390
locks.|
|

1025
00:33:17,530 --> 00:33:19,990
0,780 1560,1800 1800,2070 2070,2130 2130,2460
{} So first of all,|
所以首先，|

1026
00:33:20,080 --> 00:33:20,950
0,150 150,510 510,660 660,750 750,870
{you,know} one way to think
您知道，可以考虑的一种方式是锁定以避免丢失的更新

1027
00:33:20,950 --> 00:33:22,780
0,330 330,540 540,1080 1080,1230 1230,1830
about is actually {} lock

1028
00:33:23,900 --> 00:33:25,300
0,840
avoid

1029
00:33:26,310 --> 00:33:29,700
0,1500 1500,2040 2160,2370 2370,2850
lost updates| or help.|
|或者帮忙。|

1030
00:33:29,840 --> 00:33:31,370
0,300 300,420 420,660 660,960 960,1530
If you use lock correctly,|
如果正确使用锁定，|

1031
00:33:31,370 --> 00:33:32,360
0,90 90,210 210,480 480,690 690,990
you know locks can help
您知道，锁可以帮助避免丢失更新。

1032
00:33:32,360 --> 00:33:35,020
0,660 900,1290 1290,1620 1620,2070
avoiding {} lost updates.|
|

1033
00:33:38,680 --> 00:33:39,730
0,150 150,240 240,330 330,540 540,1050
And if you think about
如果您考虑一下kalloc.c中的早期示例，

1034
00:33:39,790 --> 00:33:42,160
0,1080 1080,1530 1530,2040 2040,2220 2220,2370
{} early example in the

1035
00:33:42,160 --> 00:33:43,540
0,510 510,900 900,1020 1020,1140 1140,1380
{kalloc.c -},| you know the
|您知道，丢失的更新基本上就是丢失了对kfree的一个更新。

1036
00:33:43,540 --> 00:33:45,070
0,300 300,660 660,720 720,1230 1230,1530
lost update is basically {}

1037
00:33:45,280 --> 00:33:47,200
0,480 480,720 720,1110 1110,1440 1440,1920
lose one update to the

1038
00:33:47,890 --> 00:33:49,000
0,240 240,570
{kfree -}.|
|

1039
00:33:49,150 --> 00:33:50,770
0,540 540,750 750,1020 1020,1410 1410,1620
And by putting locks, it
通过设置锁，您知道它实际上并没有丢失更新，

1040
00:33:50,770 --> 00:33:52,090
0,60 60,360 360,690 690,990 1050,1320
you know actually {} didn't

1041
00:33:52,090 --> 00:33:53,770
0,480 540,780 780,990 990,1440 1500,1680
lose {} that update,| so
|所以这是思考这个问题的一种方式，

1042
00:33:53,770 --> 00:33:54,790
0,150 150,390 390,630 630,720 720,1020
that's one way of thinking

1043
00:33:54,790 --> 00:33:55,780
0,240 240,420
about it,|
|

1044
00:33:56,070 --> 00:33:58,260
0,150 150,390 390,930 930,1290 1620,2190
a very low-level way {},|
一种非常低级的方式，|

1045
00:33:58,260 --> 00:33:59,160
0,270 270,360 360,450 450,570 570,900
another way to think about
另一种思考方式是，你知道你可以做锁，

1046
00:33:59,160 --> 00:34:00,090
0,390 390,510 510,630 630,840 840,930
is you know you can

1047
00:34:00,090 --> 00:34:02,580
0,450 480,840 840,1410 1440,1950
make lock,| {} locks
|锁使多步操作成为原子操作。

1048
00:34:03,970 --> 00:34:05,240
0,720
make

1049
00:34:05,720 --> 00:34:07,740
0,300 300,600 600,1440
multi step operations

1050
00:34:10,510 --> 00:34:11,780
0,690
atomic.|
|

1051
00:34:13,700 --> 00:34:14,390
0,180 180,300 300,450 450,600 600,690
And so there's sort of
所以有一种临界区的观点，

1052
00:34:14,390 --> 00:34:15,170
0,60 60,300 300,420 420,480 480,780
the view of {} critical

1053
00:34:15,170 --> 00:34:16,730
0,510 510,840 840,1020 1020,1170 1170,1560
section,| we have {} acquire
|我们用一大堆台阶就锁上了锁

1054
00:34:16,730 --> 00:34:17,810
0,300 300,510 510,540 540,720 720,1080
lock with a whole bunch

1055
00:34:17,840 --> 00:34:21,050
0,60 60,1560 1710,2250 2250,2640 2640,3210
of a steps| or instructions,
|或指令，执行所有指令，

1056
00:34:21,050 --> 00:34:22,760
0,450 450,630 630,1320 1410,1620 1620,1710
executed all instructions,| then {}
|然后被释放，

1057
00:34:22,760 --> 00:34:24,440
0,450 690,990 990,1110 1110,1380 1380,1680
released,| {basically -} whole critical
|基本上整个临界区作为原子操作执行。

1058
00:34:24,440 --> 00:34:26,660
0,540 720,1500 1500,1710 1710,1800 1800,2220
section execute as an atomic

1059
00:34:26,660 --> 00:34:27,780
0,660
operation.|
|

1060
00:34:27,870 --> 00:34:29,370
0,240 240,390 390,510 510,1200 1200,1500
That sort of {} {},|
就是那种，|

1061
00:34:29,460 --> 00:34:31,020
0,480 480,840 840,960 960,1230 1230,1560
{} also a fine way
也是思考锁的一个很好的方式。

1062
00:34:31,020 --> 00:34:32,940
0,510 510,720 720,930 930,1440
to think about locks.|
|

1063
00:34:33,090 --> 00:34:33,990
0,150 150,240 240,300 300,540 540,900
And then the third one,|
然后是第三个，|

1064
00:34:34,410 --> 00:34:35,430
0,480 480,630 630,750 750,900 900,1020
{} you know that may
你知道这可能会有帮助，

1065
00:34:35,430 --> 00:34:37,410
0,120 120,510 510,690 690,960 1260,1980
be helpful,| is that {}
|锁真正的作用是锁帮助维护一个不变量，

1066
00:34:37,440 --> 00:34:39,420
0,420 420,540 540,810 810,1260 1290,1980
really what locks do is

1067
00:34:39,660 --> 00:34:41,380
0,600 600,1200
lock help

1068
00:34:41,640 --> 00:34:44,040
0,480 510,960 960,1050 1050,1770
{} maintain an invariant,|
|

1069
00:34:47,140 --> 00:34:48,550
0,600 600,690 690,930 930,1170 1170,1410
{invariant -} do share data
不变量确实共享您知道它在保护的数据结构。

1070
00:34:48,550 --> 00:34:49,690
0,510 510,750 750,900 900,1020 1020,1140
structure that you know it's

1071
00:34:49,690 --> 00:34:50,900
0,510
protecting.|
|

1072
00:34:51,260 --> 00:34:53,300
0,630 900,1290 1290,1530 1530,1830 1830,2040
And {} what was going
当时的情况是，

1073
00:34:53,300 --> 00:34:56,240
0,270 270,450 450,900 1200,1860 2550,2940
on is that,| {} before
|在获取之前，如果没有锁持有者，您知道不变量成立，

1074
00:34:56,240 --> 00:34:57,680
0,660 690,840 840,1020 1020,1200 1200,1440
acquire, if there's no lock

1075
00:34:57,680 --> 00:34:59,210
0,450 480,570 570,690 690,1080 1080,1530
holder, you know that invariant

1076
00:34:59,210 --> 00:35:01,100
0,570 930,1170 1170,1380 1380,1500 1500,1890
holds,| {} when we acquire
|当我们获得锁并进行一些操作时，

1077
00:35:01,100 --> 00:35:02,300
0,90 90,600 840,1020 1020,1110 1110,1200
the lock and we do

1078
00:35:02,300 --> 00:35:04,310
0,120 120,690 690,870 870,1800 1830,2010
some operations,| then temporarily the
|则可能暂时违反不变量，

1079
00:35:04,310 --> 00:35:07,850
0,510 510,690 690,1260 1470,3000 3360,3540
invariant may be violated,| but
|但是在我们发布的时候，

1080
00:35:07,850 --> 00:35:08,570
0,90 90,180 180,510 510,630 630,720
at the point that we

1081
00:35:08,570 --> 00:35:09,760
0,120 120,240 240,810
do the release,|
|

1082
00:35:13,180 --> 00:35:13,900
0,270 270,420 420,480 480,570 570,720
{} so if you think
所以如果你考虑一下自由职业者的案例，

1083
00:35:13,900 --> 00:35:16,510
0,480 810,1110 1110,1410 1410,2010 2040,2610
about {} r freelist {}

1084
00:35:16,510 --> 00:35:18,040
0,570 810,930 930,1020 1020,1140 1140,1530
case,| you know the invariant
|你知道不变量是你知道空闲指针指向另一个下一个指针

1085
00:35:18,040 --> 00:35:20,380
0,240 240,510 510,1350 1770,1980 1980,2340
is {} {you,know} free pointer

1086
00:35:20,380 --> 00:35:22,420
0,300 300,660 660,1230 1230,1650 1650,2040
points to {} one other

1087
00:35:22,420 --> 00:35:24,100
0,270 270,870 930,1320 1320,1590 1590,1680
next pointer| and all the
|所有的空闲页面都在一个列表上。

1088
00:35:24,100 --> 00:35:25,720
0,360 360,810 810,1410 1410,1560 1560,1620
free pages are on a

1089
00:35:25,720 --> 00:35:26,820
0,330 330,780
single list.|
|

1090
00:35:27,390 --> 00:35:29,910
0,420 420,870 870,1140 1140,1710 1710,2520
{} And that's temporarily violated
在这一点上，这是暂时违反的，

1091
00:35:29,970 --> 00:35:32,160
0,480 480,690 690,780 780,1320 1440,2190
{} at the point {},|
|

1092
00:35:33,950 --> 00:35:35,690
0,300 300,360 360,690 690,810 810,1740
in the middle of the
在自由赛道的中间，

1093
00:35:35,720 --> 00:35:37,370
0,240 240,480 480,810 810,990 990,1650
{kfree -},| because like multiple
因为就像多个指针一样，实际上指向自由列表的开头。

1094
00:35:37,400 --> 00:35:38,360
0,330 330,570 570,810 810,870 870,960
pointers actually point to the

1095
00:35:38,360 --> 00:35:39,840
0,270 270,360 360,570 570,1020
beginning of {freelist -}.|
|

1096
00:35:40,760 --> 00:35:42,350
0,540 660,990 990,1080 1080,1530 1530,1590
And then we established at
然后我们在它的末尾建立了。

1097
00:35:42,350 --> 00:35:43,380
0,120 120,210 210,330 330,510
the end of it.|
|

1098
00:35:43,750 --> 00:35:46,030
0,540 600,840 840,1350 1710,1920 1920,2280
So if we're {freelist -}
所以如果我们是自由职业者，不是那么复杂的变量，

1099
00:35:46,030 --> 00:35:47,860
0,210 210,510 510,810 810,1350 1350,1830
as not so complicated variables,|
|

1100
00:35:47,860 --> 00:35:49,630
0,240 240,720 720,1380 1380,1590 1590,1770
like more complicated shared data
像更复杂的共享数据结构一样，

1101
00:35:49,630 --> 00:35:51,250
0,450 960,1110 1110,1230 1230,1290 1290,1620
structures,| can be a helpful
|可以是一种很有帮助的方式来思考锁到底为您做了什么。

1102
00:35:51,250 --> 00:35:52,810
0,270 270,360 360,750 750,1110 1110,1560
way of thinking actually what

1103
00:35:52,810 --> 00:35:53,920
0,120 120,420 420,540 540,810 810,1110
the lock is doing for

1104
00:35:53,920 --> 00:35:54,560
0,120
you.|
|

1105
00:35:55,330 --> 00:35:56,890
0,540 630,810 810,1170 1170,1470 1470,1560
And so see, even in
所以你看，即使在这三个案例中，

1106
00:35:56,890 --> 00:35:58,480
0,300 720,990 990,1140 1140,1500 1500,1590
this case three case,| you
|你知道所有三种合理视角的锁定视角，

1107
00:35:58,480 --> 00:35:59,920
0,180 180,420 420,630 630,1020 1020,1440
know all three lock perspective

1108
00:35:59,920 --> 00:36:02,800
0,150 150,570 570,1290 1530,2280 2280,2880
for reasonable perspectives,| {} and
|你认识他们中的一个，

1109
00:36:02,830 --> 00:36:04,300
0,510 510,900 900,1140 1140,1380 1380,1470
{} you know one of

1110
00:36:04,300 --> 00:36:05,440
0,330 360,480 480,630
them,| you know
|你知道，它带来了更多的[]，其他的一种，你用它来思考锁。

1111
00:36:05,560 --> 00:36:07,480
0,600 630,1110 1110,1380 1380,1770 1770,1920
{} brings more [] than

1112
00:36:07,480 --> 00:36:08,740
0,600 780,990 990,1050 1050,1140 1140,1260
so, one of the other

1113
00:36:08,740 --> 00:36:10,060
0,330 330,720 720,870 870,1110 1110,1320
ones and you use that

1114
00:36:10,060 --> 00:36:11,410
0,150 150,540 570,1080 1080,1170 1170,1350
as your way to think

1115
00:36:11,410 --> 00:36:12,540
0,210 210,630
about locks.|
|

1116
00:36:14,510 --> 00:36:17,060
0,600 600,1350 1500,2010 2010,2160 2160,2550
Any questions about this point?|
对这一点有什么问题吗？|

1117
00:36:23,560 --> 00:36:25,620
0,540 930,1500
Okay, um.|
好的，嗯。|

1118
00:36:25,620 --> 00:36:26,700
0,150 150,420 420,750 750,930 930,1080
So in our own for
所以在我们自己做几件事，某种程度上，

1119
00:36:26,700 --> 00:36:29,010
0,60 60,300 300,810 870,1320 1320,2310
a couple things {} {},

1120
00:36:29,040 --> 00:36:31,000
0,390 480,540 540,1380
sort of {},|
|

1121
00:36:31,460 --> 00:36:33,410
0,330 330,810 810,1410 1410,1740 1740,1950
in [desirable] properties or that
在[所需]属性中，或者这实际上可能发生在锁中

1122
00:36:33,410 --> 00:36:34,760
0,120 120,360 360,660 660,840 840,1350
can actually happen with locks|
|

1123
00:36:34,850 --> 00:36:36,470
0,480 510,660 660,1140 1140,1350 1350,1620
and you know like locks
你也知道，锁是修复正确性问题的必要条件，避免了争用条件，

1124
00:36:36,470 --> 00:36:38,450
0,180 180,900 930,1530 1530,1710 1710,1980
are a necessary to fix

1125
00:36:38,450 --> 00:36:40,640
0,90 90,450 450,930 1650,2010 2010,2190
{} correctness problem avoids race

1126
00:36:40,640 --> 00:36:42,860
0,570 810,1020 1020,1290 1290,2010 2010,2220
conditions,| but locks themselves in
|但是当不适当的使用时会把自己锁在里面，

1127
00:36:42,860 --> 00:36:45,470
0,330 330,1110 1110,1800 1800,2370 2460,2610
when inappropriate inappropriate used,| can
|也可以介绍自己的一套问题。

1128
00:36:45,470 --> 00:36:46,910
0,240 240,750 750,960 960,1260 1260,1440
also introduce their own set

1129
00:36:46,910 --> 00:36:47,980
0,60 60,720
of problems.|
|

1130
00:36:48,280 --> 00:36:49,000
0,300 300,480 480,510 510,660 660,720
And so I want to
所以我想谈一谈这一点

1131
00:36:49,000 --> 00:36:49,630
0,120 120,150 150,330 330,450 450,630
talk a little bit about

1132
00:36:49,630 --> 00:36:51,190
0,330 750,930 930,1050 1050,1200 1200,1560
that| and so the obvious
|因此，最明显的一个当然是僵局。

1133
00:36:51,190 --> 00:36:52,570
0,270 270,420 420,660 660,780 780,1380
one, of course is deadlock.|
|

1134
00:36:57,240 --> 00:36:58,530
0,360 360,450 450,1050 1050,1140 1140,1290
Yeah for example, you know
是的，举个例子，你知道这个简单的例子，

1135
00:36:58,530 --> 00:37:00,180
0,450 450,780 780,1260 1260,1380 1380,1650
the simple case,| you know
|你知道有点无聊，但值得一想，

1136
00:37:00,180 --> 00:37:01,410
0,180 180,330 330,450 450,810 810,1230
a little bit boring, but

1137
00:37:01,500 --> 00:37:03,240
0,630 630,870 870,1290 1500,1620 1620,1740
worthwhile thinking about,| you know
|你知道做收购，你知道锁定，

1138
00:37:03,240 --> 00:37:04,860
0,210 210,300 300,1080
do an acquire,

1139
00:37:05,390 --> 00:37:07,560
0,180 180,600 900,1650
you know lock,|
|

1140
00:37:07,680 --> 00:37:08,730
0,450 450,570 570,720 720,990 990,1050
and so you start the
所以你开始了关键部分

1141
00:37:08,730 --> 00:37:10,080
0,300 300,930 930,1110 1110,1290 1290,1350
critical section| and in the
|在临界区，你对同一把锁进行另一次获取，

1142
00:37:10,080 --> 00:37:11,730
0,330 330,930 930,1170 1170,1290 1290,1650
critical section, you do another

1143
00:37:11,730 --> 00:37:12,820
0,510
acquire

1144
00:37:13,600 --> 00:37:15,180
0,180 180,270 270,540 540,1050
of the same lock,|
|

1145
00:37:16,930 --> 00:37:18,320
0,240 240,360 360,900
what will happen,
接下来会发生什么，第二次收购能成功吗？

1146
00:37:20,300 --> 00:37:22,010
0,210 210,330 330,630 630,1110 1110,1710
can the second acquire succeed.|
|

1147
00:37:29,640 --> 00:37:31,110
0,510 540,750 750,1170 1170,1290 1290,1470
Well with respect that we've
好吧，恕我直言，我们早些时候已经说过了，

1148
00:37:31,110 --> 00:37:33,000
0,330 330,630 630,1110 1200,1740 1740,1890
given early on {},| you
|你知道这是不允许的，

1149
00:37:33,000 --> 00:37:34,200
0,300 300,510 510,690 690,960 960,1200
know this should be not

1150
00:37:34,200 --> 00:37:35,850
0,390 510,690 690,1110 1110,1290 1380,1650
allowed,| so basically the second
|所以基本上第二次收购必须是挡路，直到第一次收购解锁，

1151
00:37:35,850 --> 00:37:38,130
0,480 480,750 750,1260 1290,1950 2130,2280
acquire must block until the

1152
00:37:38,130 --> 00:37:39,690
0,270 270,780 780,1050 1050,1440 1440,1560
first acquire release lock,| but
|但那是因为你知道这个过程本身，

1153
00:37:39,690 --> 00:37:40,860
0,180 180,480 750,960 960,1050 1050,1170
that was you know the

1154
00:37:40,860 --> 00:37:42,480
0,330 330,810 810,1050 1050,1440 1440,1620
process itself,| so basically this
|所以基本上这会导致僵局。

1155
00:37:42,480 --> 00:37:44,000
0,480 480,540 540,600 600,1110
result in a deadlock.|
|

1156
00:37:46,970 --> 00:37:47,960
0,150 150,360 360,450 450,540 540,990
{You,know}, this is a trivial
你知道，这是一个微不足道的僵局例子

1157
00:37:47,960 --> 00:37:49,550
0,390 390,450 450,510 510,1110 1200,1590
example of {} deadlock| and
|也许现在有趣的是，实际上xv6[文本]出现了僵局，

1158
00:37:49,550 --> 00:37:50,570
0,270 270,390 390,570 570,930 930,1020
maybe now there's interesting in

1159
00:37:50,570 --> 00:37:51,500
0,180 180,330 330,420 420,810 810,930
fact there's a deadlock that

1160
00:37:51,500 --> 00:37:52,820
0,270 270,690 690,1080 1080,1230 1230,1320
{xv6 -} [texts],| you know
|您知道，因为当它发现相同的进程需要再次使用相同的锁时，实际上会导致死机。

1161
00:37:52,820 --> 00:37:54,530
0,300 300,690 1080,1260 1260,1560 1560,1710
because when it sees that

1162
00:37:54,530 --> 00:37:55,670
0,60 60,300 300,660 660,1080 1080,1140
the same process requires the

1163
00:37:55,670 --> 00:37:58,130
0,240 240,450 450,990 1170,2040 2040,2460
same lock again, actually causes

1164
00:37:58,130 --> 00:37:59,180
0,90 90,570
a panic.|
|

1165
00:37:59,330 --> 00:38:01,190
0,390 420,750 750,1050 1050,1470 1470,1860
A more interesting cases are
一个更有趣的情况是当涉及多个锁时，

1166
00:38:01,190 --> 00:38:03,200
0,510 510,1050 1050,1350 1350,1440 1440,2010
when multiple locks are involved,|
|

1167
00:38:03,380 --> 00:38:05,030
0,480 480,630 630,960 1230,1410 1410,1650
{} so let's go to
那么让我们转到前面的例子，

1168
00:38:05,030 --> 00:38:05,880
0,330
our

1169
00:38:05,880 --> 00:38:07,560
0,330 330,1080 1140,1380 1380,1530 1530,1680
previous example,| let's say we
|假设我们有以下内容，

1170
00:38:07,560 --> 00:38:09,840
0,120 120,180 180,810 810,1770
have the following {},|
|

1171
00:38:09,930 --> 00:38:11,480
0,150 150,240 240,480 480,990
we have core one,
我们有核心一号，也许是中央处理器一号，

1172
00:38:11,510 --> 00:38:13,580
0,330 690,930 930,1050 1050,1500
maybe {CPU -} one,|
|

1173
00:38:16,620 --> 00:38:18,140
0,330 330,1050
{we,have} {CPU,two}.|
我们有2号中央处理器。|

1174
00:38:19,970 --> 00:38:21,440
0,270 270,480 480,690 690,1290 1320,1470
And {CPU -} one, you
CPU一，你知道执行重命名你知道的目录，一个x，

1175
00:38:21,440 --> 00:38:24,500
0,150 150,960 1380,1800 1800,2490
know executes {rename -}

1176
00:38:24,620 --> 00:38:27,060
0,240 240,660 660,1320 1350,2010
{you,know} directory, one x,|
|

1177
00:38:27,270 --> 00:38:30,150
0,540 540,1140 1140,1830 1860,2220 2220,2880
to directory two slash y.|
给两个劈开编目录。|

1178
00:38:33,310 --> 00:38:35,350
0,330 330,690 690,1230 1230,1920 1920,2040
And CPU two execute at
和CPU两个同时执行，

1179
00:38:35,350 --> 00:38:36,880
0,90 90,390 390,1020
the same time,|
|

1180
00:38:37,100 --> 00:38:38,780
0,1080
rename
以另一种方式将另一个方向的d2a重命名为d1，你知道实际上是b，

1181
00:38:42,710 --> 00:38:43,520
0,180 180,300 300,480 480,720 720,810
in the other way in

1182
00:38:43,520 --> 00:38:45,590
0,150 150,360 360,1020 1080,1590 1590,2070
the other direction d two

1183
00:38:45,620 --> 00:38:47,940
0,600 1050,1770
a to

1184
00:38:47,940 --> 00:38:49,420
0,300 300,900
d one,

1185
00:38:50,130 --> 00:38:51,240
0,180 180,360 360,480 480,750 750,1110
you know {actually -} b,|
|

1186
00:38:51,540 --> 00:38:52,650
0,240 240,480 510,750 750,840 840,1110
just to make the names
只是为了让名字有所不同，

1187
00:38:52,650 --> 00:38:54,810
0,480 870,1200 1200,1470 1470,1950 1950,2160
different,| so the critical of
|所以这里要观察的关键是，

1188
00:38:54,810 --> 00:38:57,000
0,1170 1320,1530 1530,1590 1590,1920 1920,2190
{} thing to observe here,|
|

1189
00:38:57,000 --> 00:38:59,910
0,210 210,600 960,1470 1470,1980 2100,2910
is that CPU one runs
是CPU 1运行从d1到d2重命名，

1190
00:38:59,940 --> 00:39:01,200
0,450 450,660 660,750 750,1020 1020,1260
renaming from d1 to {d2

1191
00:39:01,200 --> 00:39:02,160
0,480
-},|
|

1192
00:39:02,160 --> 00:39:04,440
0,540 570,1170 1290,1740 1740,2100 2100,2280
and CPU {} two that's
而CPU 2正好相反，不会将D2重命名为D1。

1193
00:39:04,440 --> 00:39:06,120
0,420 420,510 510,960 960,1230 1230,1680
exactly the opposite doesn't renaming

1194
00:39:06,120 --> 00:39:07,900
0,120 120,600 600,720 720,1170
from d2 to d1.|
|

1195
00:39:09,040 --> 00:39:10,450
0,150 150,360 360,960 960,1260 1260,1410
So let's assume that,| we
所以让我们假设，|我们实际上是按照它们的参数顺序获取锁的

1196
00:39:10,450 --> 00:39:11,860
0,270 270,780 780,870 870,1260 1260,1410
actually acquire the locks in

1197
00:39:11,860 --> 00:39:13,090
0,60 60,390 390,450 450,600 600,1230
the order of their arguments|
|

1198
00:39:13,480 --> 00:39:14,410
0,120 120,270 270,480 480,660 660,930
and so what will happen
那么怎样才能认识到这一点呢？

1199
00:39:14,410 --> 00:39:16,360
0,90 90,450 450,780 1260,1770 1770,1950
to recognize that,| {} in
|在这种情况下，您将获得两个锁，

1200
00:39:16,360 --> 00:39:18,010
0,180 180,810 870,1020 1020,1320 1320,1650
this case, you will acquire

1201
00:39:18,010 --> 00:39:19,360
0,270 270,660 660,870 870,1080 1080,1350
both locks,| we know from
|我们从前面的一个例子中知道，这实际上是重要的。

1202
00:39:19,360 --> 00:39:20,470
0,210 210,450 450,840 840,990 990,1110
a previous example that is

1203
00:39:20,470 --> 00:39:22,080
0,360 360,1140
actually important.|
|

1204
00:39:22,080 --> 00:39:23,700
0,270 270,1050
So require
所以要求你知道D1锁。

1205
00:39:24,880 --> 00:39:26,940
0,300 300,510 510,750 750,1500
{you,know} {d1 -} lock.|
|

1206
00:39:28,570 --> 00:39:29,830
0,540 540,630 630,750 750,960 960,1260
And you know let's say
你知道吗，让我们说真的同时运行，

1207
00:39:29,830 --> 00:39:32,650
0,360 360,720 780,1170 1170,1860 2370,2820
really run true concurrent,| so
|所以在这一点上，另一个人可能，

1208
00:39:32,650 --> 00:39:34,180
0,60 60,240 240,630 630,1140 1140,1530
at that point, {the,other} guy

1209
00:39:34,180 --> 00:39:35,560
0,270 270,660 660,810 810,990 990,1380
might,| actually this other CPU
|实际上另一个CPU可能会先获取D2，

1210
00:39:35,560 --> 00:39:37,000
0,240 240,930
might acquire

1211
00:39:37,800 --> 00:39:39,630
0,390 390,750 750,1290 1380,1680 1680,1830
{d2 -} first,| because {you,know}
|因为你知道这是第一次争论。

1212
00:39:39,630 --> 00:39:41,800
0,720 720,1020 1020,1560
it's first argument.|
|

1213
00:39:43,180 --> 00:39:45,250
0,180 180,660 660,900 900,1380 1380,2070
And now {of,course} d2, d1
现在当然是d2，d1想要获得d2，

1214
00:39:45,250 --> 00:39:47,080
0,240 240,720 720,1320
{wants,to} acquired d2,|
|

1215
00:39:48,470 --> 00:39:50,060
0,270 270,480 480,690 690,990 1050,1590
so will try to acquire
所以会尝试获取D2。

1216
00:39:50,060 --> 00:39:51,140
0,660
d2.|
|

1217
00:39:51,260 --> 00:39:52,780
0,210 210,300 300,960
Will it succeed.|
它会成功吗？|

1218
00:39:53,540 --> 00:39:55,070
0,180 180,450 450,870 870,1230 1230,1530
It won't succeed, because the
它不会成功的，因为另一个人，你知道，实际上有锁

1219
00:39:55,070 --> 00:39:56,600
0,180 180,750 870,1050 1050,1260 1260,1530
other guy, you know actually

1220
00:39:56,600 --> 00:39:57,830
0,390 390,480 480,900 930,1080 1080,1230
has the lock| and so
|所以这个人会到此为止，不再继续。

1221
00:39:57,830 --> 00:39:59,300
0,180 180,450 450,600 600,990 990,1470
this guy will stop here

1222
00:39:59,690 --> 00:40:01,500
0,390 390,600 600,690 690,1200
and not to proceed.|
|

1223
00:40:01,560 --> 00:40:02,190
0,150 150,330 330,450 450,510 510,630
Now let's look at the
现在让我们看看另一个CPU，

1224
00:40:02,190 --> 00:40:04,650
0,450 780,1290 1290,1650 1650,2040 2040,2460
other CPU,| CPU two acquire
|CPU2获取了D2，现在已经获取了一个，作为它的第二个参数。

1225
00:40:04,650 --> 00:40:06,300
0,630 630,870 870,1050 1050,1170 1170,1650
d2, it's now been acquired

1226
00:40:06,300 --> 00:40:07,800
0,360 360,510 510,600 600,900 900,1500
one for its second argument.|
|

1227
00:40:08,630 --> 00:40:09,950
0,270 270,450 450,690 690,810 810,1320
He's gonna try to call,
他会试着打电话给Acquisition D1

1228
00:40:10,520 --> 00:40:12,440
0,150 150,300 300,780 810,1380 1380,1920
{} to call acquire d1.|
|

1229
00:40:12,800 --> 00:40:13,790
0,300 300,450 450,630 630,780 780,990
And will it be able
它是否能够继续进行。

1230
00:40:13,790 --> 00:40:15,440
0,90 90,600 780,1170 1170,1530 1530,1650
to proceed.| No, won't be
|不，将无法继续，

1231
00:40:15,440 --> 00:40:17,900
0,180 180,270 270,780 930,1770 2010,2460
able to proceed,| because the
|因为CPU One实际上拥有锁D1。

1232
00:40:18,170 --> 00:40:19,580
0,300 300,720 720,1020 1020,1290 1290,1410
CPU one actually has the

1233
00:40:19,580 --> 00:40:20,920
0,270 270,360 360,480 480,840
lock {} {d1 -}.|
|

1234
00:40:21,040 --> 00:40:22,510
0,240 240,390 390,720 720,1170 1170,1470
And so here we're sometimes
所以我们有时在这里，这被称为致命的拥抱，

1235
00:40:22,510 --> 00:40:23,470
0,120 120,210 210,540 540,570 570,960
this is called a deadly

1236
00:40:23,470 --> 00:40:25,930
0,660 660,810 810,1170 1170,1620 2040,2460
embrace,| you know, {} {}
|你知道，我们是你知道的，

1237
00:40:25,930 --> 00:40:27,850
0,570 570,690 690,1170 1500,1800 1800,1920
we're you know,| because the
|因为我们获得的方式，我们获得的顺序，

1238
00:40:27,850 --> 00:40:29,440
0,330 330,540 540,930 930,1290 1290,1590
way we acquire, the order

1239
00:40:29,440 --> 00:40:30,760
0,90 90,300 300,840 870,1140 1140,1320
in which we,| order which
|获取锁的顺序实际上会导致死锁。

1240
00:40:30,760 --> 00:40:32,290
0,300 300,630 630,990 990,1350 1350,1530
acquire lock results actually in

1241
00:40:32,290 --> 00:40:33,660
0,270 270,990
a deadlock.|
|

1242
00:40:41,050 --> 00:40:42,580
0,300 300,390 390,540 540,960
Does that make sense?|
这说得通吗？|

1243
00:40:42,580 --> 00:40:43,860
0,150 150,750
This example.|
这个例子。|

1244
00:40:45,580 --> 00:40:46,420
0,300 300,390 390,600 600,750 750,840
This is a little bit
这是一个更危险的僵局例子，

1245
00:40:46,420 --> 00:40:47,770
0,180 180,270 270,510 510,840 840,1350
of a more dangerous example

1246
00:40:47,920 --> 00:40:49,120
0,90 90,630 660,900 900,1110 1110,1200
of deadlock,| it's not an
|这不是一个明显的问题

1247
00:40:49,120 --> 00:40:51,610
0,600 630,1590 1890,2040 2040,2130 2130,2490
obvious problem| and the solution
|从某种意义上讲，这个解决方案是合理的、简单的。

1248
00:40:51,610 --> 00:40:53,020
0,240 240,540 870,990 990,1200 1200,1410
turns out in some sense

1249
00:40:53,020 --> 00:40:55,180
0,270 270,840 960,1560
reasonable simple {}.|
|

1250
00:40:56,370 --> 00:40:57,540
0,120 120,510 510,690 690,1050 1050,1170
The solution is that you
解决方案是，你知道如果你有多把锁，

1251
00:40:57,540 --> 00:40:58,320
0,60 60,150 150,270 270,450 450,780
know if you have multiple

1252
00:40:58,320 --> 00:41:00,600
0,540 720,1620 1740,2010 2010,2190 2190,2280
locks,| then you have to
|那你就得订他们的锁。

1253
00:41:00,600 --> 00:41:02,080
0,270 270,390 390,900
order their locks.|
|

1254
00:41:03,930 --> 00:41:06,120
0,510 510,840 840,1650
And full operations
完整操作必须按此顺序获取锁。

1255
00:41:06,120 --> 00:41:07,590
0,420 420,510 510,1050 1050,1350 1350,1470
have to acquire locks in

1256
00:41:07,590 --> 00:41:08,760
0,210 210,630
that order.|
|

1257
00:41:17,410 --> 00:41:18,370
0,390 390,510 510,660 660,690 690,960
So if you're a system
所以如果你是一名系统设计师，

1258
00:41:18,370 --> 00:41:19,690
0,510 510,660 660,810 810,900 900,1320
designer,| you have to decide
|您必须决定您知道所有锁对象的全局顺序是什么

1259
00:41:19,690 --> 00:41:21,640
0,90 90,180 180,390 390,870 1200,1950
you know what the global

1260
00:41:21,640 --> 00:41:23,380
0,420 420,660 660,1200 1200,1470 1470,1740
order is for all lock

1261
00:41:23,380 --> 00:41:25,870
0,660 900,1860 1890,2010 2010,2160 2160,2490
objects| and so for example
例如，在这种情况下，您可能想说d1应该总是在d2之前排序，

1262
00:41:25,870 --> 00:41:26,530
0,60 60,180 180,450 450,570 570,660
in this case where you

1263
00:41:26,530 --> 00:41:27,490
0,150 150,420 420,540 540,750 750,960
may want to say that

1264
00:41:27,490 --> 00:41:29,740
0,150 150,600 600,870 870,1290 1290,2250
{d1 -} should always order

1265
00:41:29,740 --> 00:41:31,480
0,300 300,930 1140,1290 1290,1440 1440,1740
before d2,| and that means
|这就意味着，

1266
00:41:31,480 --> 00:41:33,430
0,450 750,1200 1200,1440 1440,1590 1590,1950
that,| {} when we execute
|当我们执行重命名时，

1267
00:41:33,430 --> 00:41:34,780
0,60 60,660 810,1020 1020,1260 1260,1350
a rename,| the rule of
|生活规则是我们总是先获得号码较少的电话簿，

1268
00:41:34,780 --> 00:41:36,760
0,300 300,750 780,930 930,1350 1350,1980
life is we always acquire

1269
00:41:36,820 --> 00:41:39,520
0,330 360,900 900,1440 1590,2310
{} lower number {}

1270
00:41:39,550 --> 00:41:41,860
0,630 660,1140 1140,1680 1680,2160 2160,2310
{} directories first,| before we
|在我们获得更高级别的电话簿号码之前。

1271
00:41:41,860 --> 00:41:43,930
0,480 480,1140 1140,1380 1380,1770 1770,2070
acquire higher order directory number.|
|

1272
00:41:44,900 --> 00:41:46,730
0,480 690,870 870,1020 1020,1200 1200,1830
{} And that will ensure
这将确保基本上有全球秩序

1273
00:41:46,760 --> 00:41:48,740
0,180 180,780 1020,1410 1410,1650 1650,1980
that basically {} there's global

1274
00:41:48,740 --> 00:41:50,240
0,480 480,1020 1050,1140 1140,1290 1290,1500
order| and you know this
|你知道这个不可能发生的特殊情况。

1275
00:41:50,240 --> 00:41:52,160
0,420 420,870 870,1080 1080,1500 1500,1920
particular case which cannot happen.|
|

1276
00:41:52,710 --> 00:41:53,960
0,690

1277
00:41:53,960 --> 00:41:55,490
0,420 420,540 540,630 630,900 1200,1530
Because you know the lock
因为你知道锁定命令将会是

1278
00:41:55,490 --> 00:41:56,210
0,330 330,420 420,540 540,600 600,720
order is going to be|
|

1279
00:41:56,210 --> 00:41:58,370
0,390 390,840 1050,1350 1350,1860 1890,2160
then for {d1 -} {d2
然后这个家伙的D1和D2

1280
00:41:58,370 --> 00:42:00,110
0,240 240,360 360,540 540,1080 1320,1740
-} for this guy| and
|这个人将获得完全相同的全局顺序的锁，你知道，D1D2

1281
00:42:00,110 --> 00:42:01,550
0,270 270,450 450,660 660,1140 1140,1440
this guy will acquire locks

1282
00:42:01,550 --> 00:42:03,140
0,420 420,510 510,780 780,1170 1170,1590
exactly the same global order,

1283
00:42:03,140 --> 00:42:04,730
0,60 60,210 210,630 630,1260 1440,1590
you know, d1 d2| and
|这样我们就没有致命的防护罩了。

1284
00:42:04,730 --> 00:42:06,500
0,210 210,330 330,540 540,960 1260,1770
then we don't have deadly

1285
00:42:06,500 --> 00:42:07,380
0,480
enbrace.|
|

1286
00:42:09,700 --> 00:42:11,060
0,120 120,210 210,330 330,750
Does that make sense?|
这说得通吗？|

1287
00:42:14,630 --> 00:42:16,420
0,270 270,660 660,840 840,1200
Any questions about this?|
对此有什么问题吗？|

1288
00:42:17,520 --> 00:42:18,500
0,60

1289
00:42:22,180 --> 00:42:23,470
0,150 150,420 420,1080 1080,1140 1140,1290
So this indicates a little
所以这表明有一点问题，

1290
00:42:23,470 --> 00:42:25,870
0,120 120,210 210,870 870,1560 1890,2400
bit of {} problem {},|
|

1291
00:42:25,870 --> 00:42:26,890
0,180 180,390 390,660 660,870 900,1020
even though like, okay let's
即使像这样，好的，让我们来解决这个，你知道这种死锁问题，

1292
00:42:26,890 --> 00:42:27,910
0,210 210,570 600,720 720,870 870,1020
fix this you know this

1293
00:42:27,910 --> 00:42:29,050
0,150 150,210 210,630 630,1020 1020,1140
sort of deadlock problem,| that
|我有全球订单，请注意这个订单是全球订单

1294
00:42:29,050 --> 00:42:30,190
0,90 90,240 240,360 360,690 690,1140
I have in global order,

1295
00:42:30,220 --> 00:42:32,200
0,450 450,1020 1200,1500 1500,1560 1560,1980
notice this order is global|
|

1296
00:42:32,560 --> 00:42:35,110
0,480 900,1500 1680,1950 1950,2160 2160,2550
{} and this is {}
这是一个小问题，

1297
00:42:37,050 --> 00:42:38,370
0,270 300,690 690,750 750,960 960,1320
an issue a little bit,|
|

1298
00:42:38,490 --> 00:42:40,050
0,450 450,750 750,1140 1140,1230 1230,1560
{} when designing a system,
在设计系统时，因为。

1299
00:42:40,050 --> 00:42:42,620
0,390 810,1350 1440,1830 1830,2070
because.| Um, hold on.|
|嗯，等一下。|

1300
00:43:07,510 --> 00:43:08,470
0,180 180,270 270,390 390,600 600,960
So you think about the
所以你可以考虑一下锁的顺序。

1301
00:43:08,470 --> 00:43:10,480
0,150 150,210 210,450 450,1080 1320,2010
sort of lock ordering {}.|
|

1302
00:43:15,050 --> 00:43:15,710
0,150 150,240 240,360 360,570 570,660
You know there has to
你知道一定是全球性的。

1303
00:43:15,710 --> 00:43:17,240
0,120 120,300 300,360 360,900
be sort of global.|
|

1304
00:43:18,030 --> 00:43:19,020
0,360 360,570 570,690 690,780 780,990
And so we have one
所以我们有一个模块，一个m，你知道调用方法[方法]2。

1305
00:43:19,020 --> 00:43:21,510
0,720 1140,1470 1470,1950 1950,2040 2040,2490
module, one m, you know

1306
00:43:21,630 --> 00:43:23,780
0,600 600,1620
calls method

1307
00:43:24,390 --> 00:43:26,960
0,1020 1320,2010
[method] two.|
|

1308
00:43:27,490 --> 00:43:29,060
0,870

1309
00:43:29,440 --> 00:43:31,120
0,450 450,720 750,1410 1440,1530 1530,1680
And the caller, you know
而来电者，你知道，m1g，你知道，实际上可能需要意识到

1310
00:43:31,120 --> 00:43:32,440
0,180 180,420 420,900 930,1050 1050,1320
{m1g - -}, {you,know} might

1311
00:43:32,440 --> 00:43:33,970
0,360 360,630 630,750 750,930 930,1530
actually need to be aware|
|

1312
00:43:33,970 --> 00:43:34,780
0,150 150,390 390,510 510,600 600,810
or could be you need
或者你可能需要意识到锁的功能是什么，

1313
00:43:34,780 --> 00:43:35,980
0,90 90,210 210,660 660,960 960,1200
to be aware actually what

1314
00:43:35,980 --> 00:43:37,960
0,840 1020,1500
locks f,|
|

1315
00:43:37,960 --> 00:43:40,060
0,450 450,540 540,780 780,1290 1410,2100
acquired for one locks m2
购置一把锁供m2使用。

1316
00:43:40,060 --> 00:43:41,220
0,600
uses.|
|

1317
00:43:42,630 --> 00:43:45,510
0,600 750,1320 1500,1950 1950,2700 2730,2880
{} Because {} if you
因为如果你的m2使用一些固定的锁，

1318
00:43:45,510 --> 00:43:47,760
0,240 240,630 630,1650 1680,2040 2040,2250
{m2 -} {} uses some

1319
00:43:47,760 --> 00:43:50,250
0,180 180,750 990,2010 2040,2130 2130,2490
set locks,| then you know
|那你就知道要遵守我们的订锁规则，

1320
00:43:50,310 --> 00:43:51,960
0,420 420,570 570,840 840,1200 1200,1650
follow our lock ordering rule,|
|

1321
00:43:52,110 --> 00:43:53,040
0,270 270,570 570,720 720,780 780,930
{} [just] got to make
[只是]要确保你知道它有没有锁，

1322
00:43:53,040 --> 00:43:54,150
0,390 390,720 720,810 810,900 900,1110
sure that you know if

1323
00:43:54,150 --> 00:43:55,500
0,150 150,330 330,480 480,930 1020,1350
it has some locks,| then
|然后从F和G获取所有锁，

1324
00:43:55,500 --> 00:43:57,390
0,390 390,570 570,1050 1410,1620 1620,1890
acquires all locks from f

1325
00:43:57,390 --> 00:43:58,590
0,120 120,330 330,720 720,1050 1050,1200
and g,| together actually in
|实际上是在某种全球秩序中团结在一起。

1326
00:43:58,590 --> 00:44:00,880
0,540 750,1500 1500,1890
some global order.|
|

1327
00:44:01,270 --> 00:44:02,290
0,150 150,270 270,450 450,660 660,1020
And so that really means
所以这真的意味着这些内部结构，

1328
00:44:02,290 --> 00:44:03,880
0,210 210,390 390,540 540,630 630,1590
that these sort of internals,|
|

1329
00:44:06,600 --> 00:44:08,600
0,570 570,630 630,840 840,1320
internals of {m2 -},
就锁而言，m2的内部部件必须对m1可见。

1330
00:44:08,780 --> 00:44:10,600
0,660 660,1260
{in,terms,of} locks

1331
00:44:15,830 --> 00:44:17,180
0,300 300,420 420,900 900,1170 1170,1350
must be visible to {m1

1332
00:44:17,180 --> 00:44:18,360
0,390
-}.|
|

1333
00:44:21,400 --> 00:44:22,210
0,150 150,360 360,450 450,630 630,810
So that you know and
所以你知道，M1可以确保，

1334
00:44:22,210 --> 00:44:23,470
0,270 270,390 390,720 720,900 900,1260
m1 can ensure that,| actually
|实际上，你知道，以适当的方式调用m2。

1335
00:44:23,470 --> 00:44:25,990
0,90 90,330 420,690 690,1320 1320,2520
you know, {} calls {}

1336
00:44:25,990 --> 00:44:28,120
0,210 210,420 420,630 630,1740 1740,2130
{m2 -} in the appropriate

1337
00:44:28,120 --> 00:44:28,920
0,240
way.|
|

1338
00:44:29,120 --> 00:44:29,960
0,300 300,600 600,690 690,780 780,840
{} And you know in
你知道，在某些方面，这是一种抽象的违反，

1339
00:44:29,960 --> 00:44:30,800
0,150 150,330 330,540 540,660 660,840
some ways, that is kind

1340
00:44:30,800 --> 00:44:35,210
0,330 330,390 390,960 960,1620 3900,4410
of an abstraction violation,| actually
|实际上做得很完美

1341
00:44:35,210 --> 00:44:36,800
0,180 180,270 270,840 840,1080 1080,1590
work out perfectly| and m1
|并且m1知道我们需要知道关于m2是如何实现的任何信息

1342
00:44:36,800 --> 00:44:37,400
0,120 120,210 210,360 360,420 420,600
know we need to know

1343
00:44:37,400 --> 00:44:38,780
0,480 480,750 750,870 870,1260 1260,1380
anything about how m2 was

1344
00:44:38,780 --> 00:44:42,020
0,570 1050,1290 1290,1800 1800,2430 2670,3240
implemented| and unfortunately locks are
|不幸的是，锁是一些内部部件的常见例子，

1345
00:44:42,020 --> 00:44:43,310
0,90 90,450 450,960 960,1020 1020,1290
{} common example of where

1346
00:44:43,310 --> 00:44:45,230
0,180 180,240 240,360 360,1080 1470,1920
some of the internals,| m2
|M2实际上可能会泄露给M1，

1347
00:44:45,230 --> 00:44:46,640
0,300 300,750 750,1080 1080,1260 1260,1410
might actually {leak,out} to {m1

1348
00:44:46,640 --> 00:44:48,410
0,390 600,990 990,1320 1320,1530 1530,1770
-},| because m1 really needs
|因为M1确实需要知道。

1349
00:44:48,410 --> 00:44:49,180
0,90 90,330
to know.|

1350
00:44:49,740 --> 00:44:51,120
0,270 270,450 450,780 960,1290 1290,1380
{} And so when you
所以当你设计一个更大的系统时，

1351
00:44:51,120 --> 00:44:53,400
0,360 360,780 780,990 990,1590 1740,2280
design a bigger system {},|
|

1352
00:44:53,400 --> 00:44:54,540
0,120 120,630 690,870 870,1080 1080,1140
you know, this makes the
你知道，这使得模块化变得更加复杂。

1353
00:44:54,540 --> 00:44:56,130
0,330 330,480 480,630 630,900 900,1590
{modularity - -} more complicated.|
|

1354
00:45:01,730 --> 00:45:03,320
0,390 390,510 510,660 660,930 930,1590
Sorry I was just wondering,
抱歉，我只是想知道，是否需要完整的锁订单

1355
00:45:03,350 --> 00:45:04,280
0,270 270,480 480,570 570,780 780,930
does need to be a

1356
00:45:04,280 --> 00:45:07,160
0,840 1110,1530 1530,2100 2100,2250 2250,2880
complete {} ordering of locks|
|

1357
00:45:07,160 --> 00:45:08,690
0,300 300,570 570,810 810,1020 1020,1530
or can there be some
或者有没有一些锁，可以用任何方式订购。

1358
00:45:09,050 --> 00:45:11,540
0,390 390,570 570,960 1350,1770 2220,2490
locks that are, {} that

1359
00:45:11,540 --> 00:45:13,610
0,150 150,540 570,1050 1050,1260 1260,2070
can be ordered in whatever

1360
00:45:13,640 --> 00:45:16,640
0,600 630,1110 1260,2340 2340,2670 2670,3000
way they.| Yeah, it depends,
|是的，这要看情况，如果f和g你知道的共享任何锁，

1361
00:45:16,640 --> 00:45:17,810
0,180 180,360 360,510 510,630 630,1170
if like f and g

1362
00:45:17,840 --> 00:45:19,370
0,180 180,510 510,690 690,1110 1110,1530
{you,know} share any locks right,|
|

1363
00:45:19,970 --> 00:45:21,590
0,210 210,600 600,720 720,1260 1260,1620
for example if you're looking
例如，如果您正在查看xv6，

1364
00:45:21,590 --> 00:45:24,020
0,180 180,390 390,870 1140,1740 1740,2430
at {xv6 -},| {} there
|有一种锁定顺序的多个[链]，

1365
00:45:24,200 --> 00:45:26,450
0,570 600,900 900,960 960,1380 1380,2250
are sort of multiple [strands]

1366
00:45:26,480 --> 00:45:27,920
0,300 300,570 570,1080 1080,1290 1290,1440
of lock orderings,| because some
|因为有些函数与其他锁无关

1367
00:45:27,920 --> 00:45:28,910
0,390 390,540 540,780 780,840 840,990
functions have nothing to do

1368
00:45:28,910 --> 00:45:29,900
0,120 120,330 330,660 660,780 780,990
with other locks| and you
|你知道他们永远不会一起获得的。

1369
00:45:29,900 --> 00:45:32,270
0,330 330,810 810,1020 1020,1680 1890,2370
know they're never acquired together.|
|

1370
00:45:33,000 --> 00:45:33,960
0,330 330,450 450,600 600,720 720,960
And so if they're never
所以如果他们从来没有一起获得过，

1371
00:45:33,960 --> 00:45:35,700
0,300 300,930 930,1170 1170,1440 1440,1740
acquired together,| just join locks
|如果您愿意，只需连接锁集

1372
00:45:35,700 --> 00:45:37,200
0,270 270,390 390,480 480,900 1230,1500
sets, if you will| and
|然后，只需确保某个特定锁集合中的顺序是全局的

1373
00:45:37,200 --> 00:45:38,130
0,300 300,660 660,750 750,840 840,930
then only you have to

1374
00:45:38,130 --> 00:45:39,210
0,180 180,420 420,570 570,660 660,1080
make sure that the ordering

1375
00:45:39,210 --> 00:45:40,740
0,390 390,660 660,1080 1080,1350 1350,1530
in one particular locks set

1376
00:45:40,740 --> 00:45:43,140
0,90 90,600 870,1380 1470,1950 1950,2400
is global| and the ordering
|并且其它锁集合的排序完全独立于其它排序。

1377
00:45:43,140 --> 00:45:43,950
0,90 90,270 270,510 510,720 720,810
the other locks set is

1378
00:45:43,950 --> 00:45:45,180
0,330 330,810 810,870 870,1020 1020,1230
completely independent of the other

1379
00:45:45,180 --> 00:45:46,100
0,450
ordering.|
|

1380
00:45:47,730 --> 00:45:48,810
0,180 180,450 450,600 600,930 930,1080
So it is correct, that
所以这是正确的，它不一定是全局有序的，

1381
00:45:48,810 --> 00:45:50,100
0,540 540,810 810,1080 1080,1170 1170,1290
it doesn't have to be

1382
00:45:50,100 --> 00:45:51,480
0,60 60,420 420,840 840,1200 1200,1380
{} global ordering,| but like
|但就像所有操作相同共享类型的锁集的函数一样，

1383
00:45:51,510 --> 00:45:53,580
0,240 240,330 330,810 810,1380 1500,2070
all the functions that manipulate

1384
00:45:53,580 --> 00:45:54,840
0,90 90,450 450,870 930,1200 1200,1260
the same share sort of

1385
00:45:54,840 --> 00:45:56,220
0,390 390,720 810,1140 1140,1290 1290,1380
lock set,| they need to
|他们需要就全球秩序达成一致。

1386
00:45:56,220 --> 00:45:57,480
0,330 330,510 510,570 570,900 900,1260
agree on a global order.|
|

1387
00:45:59,130 --> 00:46:00,560
0,390 390,780
Thank you.|
谢谢。|

1388
00:46:04,430 --> 00:46:05,880
0,300 300,870
Okay so.|
好的那么。|

1389
00:46:05,880 --> 00:46:07,950
0,300 300,1020 1260,1440 1440,1650 1650,2070
One in, you know another
一进，你知道另一种挑战，用锁，

1390
00:46:07,950 --> 00:46:09,990
0,180 180,480 660,1020 1020,1860 1950,2040
sort of {} challenge {}

1391
00:46:09,990 --> 00:46:11,880
0,450 450,1020 1080,1260 1260,1650 1650,1890
with locks,| {} we've seen
|我们已经看到了两个挑战，一个是僵局，一个是模块化，

1392
00:46:11,880 --> 00:46:13,260
0,150 150,540 540,750 750,1230 1230,1380
two challenges {one,is} deadlock, one

1393
00:46:13,260 --> 00:46:15,090
0,90 90,300 300,870 1260,1620 1620,1830
is {modularity -},| {} the
|挑战的第二个挑战仅仅是锁与性能的对比。

1394
00:46:15,090 --> 00:46:17,640
0,270 270,1140 1500,1680 1680,2340 2340,2550
second challenge for challenges just

1395
00:46:17,640 --> 00:46:18,740
0,540
locks

1396
00:46:18,740 --> 00:46:20,200
0,900
{versus,performance}.|
|

1397
00:46:24,100 --> 00:46:25,990
0,360 360,480 480,630 630,1260 1500,1890
And you know really hinted
你知道，这真的暗示了几次，

1398
00:46:25,990 --> 00:46:26,800
0,90 90,210 210,270 270,480 480,810
at this a couple times,|
|

1399
00:46:26,800 --> 00:46:28,600
0,120 120,270 270,510 510,1320 1740,1800
but it needs to {},|
但它需要，|

1400
00:46:28,630 --> 00:46:31,270
0,360 360,570 1560,2070 2070,2250 2250,2640
{} is important enough to
是非常重要的，实际上需要强调一下。

1401
00:46:31,300 --> 00:46:32,770
0,360 360,600 600,720 720,1140 1140,1470
actually put some emphasis on.|
|

1402
00:46:33,400 --> 00:46:35,140
0,600 810,1200 1200,1290 1290,1620 1620,1740
{} And so basically we
所以基本上我们想要的是性能，

1403
00:46:35,140 --> 00:46:37,720
0,180 180,300 300,630 660,1800 1830,2580
want to get {} performance,|
|

1404
00:46:37,720 --> 00:46:39,520
0,390 390,600 600,1110 1380,1710 1710,1800
you need to split up
您需要拆分数据结构，

1405
00:46:39,520 --> 00:46:41,590
0,240 240,660 1140,1560 1710,1830 1830,2070
data structures,| so if you
|所以如果你有一个很大的内核锁，

1406
00:46:41,590 --> 00:46:42,880
0,210 210,450 450,630 630,900 900,1290
have one big kernel lock,|
|

1407
00:46:43,150 --> 00:46:44,140
0,270 270,450 450,600 600,900 900,990
{} that will limit your
这将使您的性能仅限于在单个CPU上的基本性能，

1408
00:46:44,140 --> 00:46:45,730
0,510 510,720 720,1080 1080,1530 1530,1590
performance to basically performance on

1409
00:46:45,730 --> 00:46:46,990
0,60 60,330 330,930 1080,1170 1170,1260
a single CPU,| if you
|如果您想要执行，您需要具有多个CPU执行扩展，

1410
00:46:46,990 --> 00:46:49,300
0,330 330,600 600,1170 1170,1830 1980,2310
want to perform, you want

1411
00:46:49,300 --> 00:46:51,310
0,240 240,570 570,1170 1170,1650 1650,2010
that performed scales with numerous

1412
00:46:51,310 --> 00:46:53,140
0,540 750,870 870,1140 1140,1500 1500,1830
CPUs,| you gotta split up.|
|你得分头行动。|

1413
00:46:54,190 --> 00:46:54,940
0,180 180,330 330,390 390,630 630,750
You need to split up
您需要拆分数据结构。

1414
00:46:54,940 --> 00:46:56,320
0,240 240,750
data structures.|
|

1415
00:47:04,910 --> 00:47:07,520
0,750 1050,1500 1500,1950 1980,2160 2160,2610
And best split, you know,
最好分开，你知道，这并不明显

1416
00:47:07,730 --> 00:47:09,120
0,810
{}

1417
00:47:09,320 --> 00:47:10,670
0,150 150,330 330,810 960,1200 1200,1350
it's not obvious| or can
|或者可以是一个挑战，

1418
00:47:10,670 --> 00:47:11,940
0,90 90,180 180,750
be a challenge,|
|

1419
00:47:17,780 --> 00:47:19,100
0,570 570,690 690,810 810,900 900,1320
{} you know, for example
例如，如果您将锁与每个目录相关联，

1420
00:47:19,100 --> 00:47:20,570
0,300 330,690 690,1110 1110,1170 1170,1470
if you associate the lock

1421
00:47:20,570 --> 00:47:21,860
0,120 120,300 300,810 810,990 990,1290
with every directories,| should you
|如果您将锁与每个inode相关联，

1422
00:47:21,860 --> 00:47:22,970
0,450 450,510 510,750 750,870 870,1110
associate the lock with every

1423
00:47:22,970 --> 00:47:24,890
0,120 120,540 900,1530 1530,1800 1800,1920
{inode -},| associated lock with
|是否将锁与每个进程相关联。

1424
00:47:24,890 --> 00:47:26,480
0,180 180,600 600,660 660,1050
every process or not.|
|

1425
00:47:26,480 --> 00:47:28,100
0,270 270,630 630,720 720,810 810,1620
{} Where is it better
哪里更适合以不同的方式拆分数据结构。

1426
00:47:28,100 --> 00:47:29,510
0,300 300,540 540,690 900,1320 1320,1410
to sort of split the

1427
00:47:29,510 --> 00:47:30,590
0,240 240,600 600,720 720,810 810,1080
data structures in a different

1428
00:47:30,590 --> 00:47:31,520
0,330
way.|

1429
00:47:31,930 --> 00:47:34,570
0,600 960,1680 1950,2340 2340,2550 2550,2640
{} And {} if you
如果你改变一下，重新设计锁定规则，

1430
00:47:34,570 --> 00:47:36,010
0,120 120,210 210,720 720,1140 1140,1440
make a change you to

1431
00:47:36,010 --> 00:47:39,700
0,1230 1230,1620 1800,2310 2310,3000 3330,3690
redesign the locking discipline {},|
|

1432
00:47:39,700 --> 00:47:41,170
0,480 570,810 810,990 990,1170 1200,1470
and you've got to make
你必须确保

1433
00:47:41,170 --> 00:47:42,100
0,360 360,540 540,600 600,750 750,930
sure| that you know you're
|你知道你仍然保持着不变量，

1434
00:47:42,100 --> 00:47:43,690
0,210 210,720 720,810 810,1440 1440,1590
still maintain the invariant,| that
|这实际上是内核想要保持的。

1435
00:47:43,690 --> 00:47:45,610
0,420 1080,1170 1170,1500 1500,1740 1740,1920
actually the kernels trying to

1436
00:47:45,610 --> 00:47:46,680
0,600
maintain.|
|

1437
00:47:46,870 --> 00:47:48,370
0,330 330,750 900,1050 1050,1200 1200,1500
{} And if you split
如果你拆开锁，

1438
00:47:48,370 --> 00:47:49,690
0,420 420,930 930,1110 1110,1230 1230,1320
locks,| you also have to
|您还必须重写}代码。

1439
00:47:49,690 --> 00:47:51,200
0,330 330,390 390,900
rewrite} the code.|
|

1440
00:47:51,540 --> 00:47:52,830
0,480 480,660 660,780 780,870 870,1290
You may have to need,
您可能也需要，可能需要编写，可能需要重写代码。

1441
00:47:52,860 --> 00:47:55,020
0,510 510,960 1200,1530 1530,1830 1830,2160
may write, may need to,

1442
00:47:56,360 --> 00:47:57,500
0,150 150,300 300,540 540,780 780,1140
{rewrite - -} code too.|
|

1443
00:48:02,540 --> 00:48:03,710
0,450 450,570 570,660 660,900 900,1170
And so it turns out
所以事实证明，

1444
00:48:03,710 --> 00:48:06,650
0,120 120,840 930,1950 2190,2700 2700,2940
that,| basically {} you should
|基本上你应该重构，你知道你的内核的一部分

1445
00:48:06,650 --> 00:48:09,230
0,780 780,930 930,1140 1140,1140 2340,2580
refactor, you know {} part

1446
00:48:09,230 --> 00:48:10,280
0,90 90,180 180,600 600,840 840,1050
of your kernel| or part
|或您的[]计划的一部分，

1447
00:48:10,280 --> 00:48:11,960
0,60 60,210 210,480 480,1080 1380,1680
of your [] program,| to
|通过拆分数据结构获得更好的表单

1448
00:48:11,960 --> 00:48:13,820
0,210 210,420 420,960 960,1050 1050,1860
get better forms {} by

1449
00:48:13,820 --> 00:48:15,530
0,420 420,660 660,990 990,1260 1260,1710
splitting data structure| or introducing
|或者引入更多的锁，

1450
00:48:15,530 --> 00:48:17,180
0,240 240,810 1080,1410 1410,1530 1530,1650
more locks,| {} you know
|你知道有很多工作要做，

1451
00:48:17,180 --> 00:48:18,200
0,360 360,600 600,810 810,960 960,1020
there's just a lot of

1452
00:48:18,200 --> 00:48:19,070
0,270 270,330 330,420 420,480 480,870
work,| you have to carefully
|你要仔细考虑一下，保持原来想要保持的范围，

1453
00:48:19,070 --> 00:48:20,480
0,210 210,540 540,720 720,1230 1230,1410
think through that maintain the

1454
00:48:20,480 --> 00:48:22,040
0,330 330,450 450,870 870,960 960,1560
range that intended to maintain,|
|

1455
00:48:22,310 --> 00:48:23,270
0,540 540,630 630,720 720,840 840,960
{} you have to be
你必须要写代码

1456
00:48:23,270 --> 00:48:25,880
0,300 300,840 1080,1530 1530,1800 1860,2610
write code| and so generally,
|所以一般说来，这只是一项繁重的工作。

1457
00:48:25,880 --> 00:48:26,630
0,150 150,270 270,450 450,540 540,750
this is just a lot

1458
00:48:26,630 --> 00:48:27,420
0,60 60,420
of work.|
|

1459
00:48:28,020 --> 00:48:29,420
0,150 150,480 480,780
They're not easy.|
它们并不容易。|

1460
00:48:32,500 --> 00:48:33,610
0,300 300,450 450,540 540,720 720,1110
{} And so there's a
所以纽恩的观点有点负面，对吧，

1461
00:48:33,640 --> 00:48:35,170
0,240 240,330 330,450 450,990 1020,1530
little bit of negative new's

1462
00:48:35,170 --> 00:48:36,520
0,300 300,510 510,930 930,1080 1080,1350
point, right,| because you know
|因为你知道我们想要更好的表现，

1463
00:48:37,120 --> 00:48:37,870
0,210 210,360 360,420 420,570 570,750
we want to get better

1464
00:48:37,870 --> 00:48:39,820
0,660 690,990 990,1500 1500,1680 1680,1950
performance,| that suggests {you,know} more
|这说明你知道更多的锁

1465
00:48:39,820 --> 00:48:43,160
0,540 870,1530 1530,2220 2250,2850
locks| {} and {}.|
|和。|

1466
00:48:43,250 --> 00:48:45,440
0,180 180,990 1200,1380 1380,1680 1680,2190
But that is actually a
但这实际上是一项繁重的工作。

1467
00:48:45,530 --> 00:48:46,820
0,270 270,360 360,750
lot of work.|
|

1468
00:48:46,940 --> 00:48:48,320
0,330 330,480 480,630 630,750 750,1380
{} It's sort of general
这是一种普通的食谱，你知道怎么做，

1469
00:48:48,320 --> 00:48:49,500
0,690
recipe,

1470
00:48:49,650 --> 00:48:50,520
0,180 180,330 330,660 660,720 720,870
you know how to go

1471
00:48:50,520 --> 00:48:52,290
0,300 300,690 1050,1320 1320,1680 1680,1770
about this,| is to you
|就是从粗粒度的锁开始，

1472
00:48:52,290 --> 00:48:53,600
0,150 150,780
know start

1473
00:48:53,780 --> 00:48:55,560
0,150 150,450 450,690 690,1200
of {coarse-grained -} locks,|
|

1474
00:49:05,160 --> 00:49:06,480
0,150 150,240 240,840
and they measure.|
他们测量。|

1475
00:49:11,600 --> 00:49:12,620
0,120 120,480 480,720 720,810 810,1020
So whatever run a bunch
所以不管是什么，只要在内核上运行一堆应用程序就行了

1476
00:49:12,620 --> 00:49:13,670
0,90 90,720 720,780 780,990 990,1050
of applications on top of

1477
00:49:13,670 --> 00:49:16,610
0,120 120,780 1020,2100 2100,2670 2670,2940
your kernel| and {} see
|看看您是否真的得到了任何加速，

1478
00:49:16,610 --> 00:49:17,570
0,270 270,390 390,510 510,780 780,960
whether you get actually any

1479
00:49:17,570 --> 00:49:19,130
0,450 450,690 690,900 900,1200 1200,1560
speedup,| if they actually exploit
|如果他们真的利用了多个内核。

1480
00:49:19,130 --> 00:49:20,380
0,300 300,750
multiple cores.|
|

1481
00:49:20,560 --> 00:49:22,090
0,630 660,840 840,960 960,1380 1410,1530
And if they do, you
如果他们这样做了，你知道你基本上就完成了，对吧，

1482
00:49:22,090 --> 00:49:22,720
0,120 120,270 270,450 450,540 540,630
know your {basically -} be

1483
00:49:22,720 --> 00:49:24,250
0,270 300,570 570,960 990,1230 1230,1530
done, right,| that you're locking
|你的锁设计已经足够好了，

1484
00:49:24,250 --> 00:49:26,380
0,330 330,450 450,600 600,990 1740,2130
design is good enough,| if
|如果你不加快速度，

1485
00:49:26,440 --> 00:49:27,460
0,210 210,450 450,570 570,750 750,1020
you don't get speed up,|
|

1486
00:49:27,460 --> 00:49:28,630
0,450 450,570 570,840 840,990 990,1170
basically that means that some
基本上，这意味着某些锁被争用，

1487
00:49:28,630 --> 00:49:30,180
0,240 240,330 330,990
lock is contended,|
|

1488
00:49:33,030 --> 00:49:34,860
0,750 780,1410 1410,1500 1500,1770 1770,1830
multiple processes or trying to
多个进程或尝试获取相同的锁

1489
00:49:34,860 --> 00:49:36,030
0,120 120,210 210,510 510,960 990,1170
get the same lock| and
|因此它们被序列化了

1490
00:49:36,030 --> 00:49:37,500
0,360 360,510 510,660 660,1110 1110,1470
therefore they are {serialized -}|
|

1491
00:49:37,710 --> 00:49:39,090
0,180 180,510 510,630 630,840 840,1380
and therefore you don't get
因此你得不到加速。

1492
00:49:39,090 --> 00:49:40,160
0,240 240,540
speed up.|
|

1493
00:49:40,160 --> 00:49:41,390
0,300 300,780 780,990 990,1140 1140,1230
{} Then you you have
然后你你要重新考虑，然后你要重新设计。

1494
00:49:41,390 --> 00:49:43,100
0,90 90,450 450,900 930,1500 1530,1710
to rethink about, then you

1495
00:49:43,100 --> 00:49:44,960
0,150 150,390 660,1290
need to redesign.|
|

1496
00:49:48,020 --> 00:49:49,280
0,510 540,750 750,840 840,1110 1110,1260
{} But the point is
但重点是，你想要通过这些测量来指导，

1497
00:49:49,280 --> 00:49:49,820
0,120 120,210 210,360 360,420 420,540
that, you want to be

1498
00:49:49,820 --> 00:49:51,560
0,540 570,690 690,960 960,1260 1260,1740
guided, you know by these

1499
00:49:51,890 --> 00:49:54,380
0,750 1140,1740 1740,1800 1800,2070 2070,2490
measurements,| because it maybe {the,case}
|因为这可能是你知道某个模块的情况

1500
00:49:54,380 --> 00:49:56,150
0,270 270,660 660,1170 1170,1410 1410,1770
that {you,know,some} module| that uses
|使用内核粗粒度锁只是不经常并行调用

1501
00:49:56,150 --> 00:49:56,990
0,60 60,300 300,480 480,750 750,840
of cores coarse-grained lock is

1502
00:49:56,990 --> 00:49:58,910
0,210 210,420 420,960 1230,1830 1830,1920
just not called {} in

1503
00:49:58,910 --> 00:50:00,680
0,570 570,930 1020,1230 1230,1680 1680,1770
parallel often| and therefore it
|因此实际上没有必要重新设计，

1504
00:50:00,680 --> 00:50:02,060
0,90 90,270 270,960 960,1110 1110,1380
is not necessary to actually

1505
00:50:02,060 --> 00:50:04,040
0,720 1080,1410 1410,1830 1830,1950 1950,1980
redesign,| since redesign there's a
|自从重新设计以来，有很多工作要做，

1506
00:50:04,040 --> 00:50:05,030
0,180 180,240 240,630 660,780 780,990
lot of work,| you know
|你知道，你知道，这也会使关于代码的推理变得复杂，

1507
00:50:05,030 --> 00:50:06,290
0,330 330,420 420,630 630,780 780,1260
and you know it also

1508
00:50:06,440 --> 00:50:08,000
0,210 210,690 690,780 780,1200 1200,1560
can complicate the reasoning about

1509
00:50:08,000 --> 00:50:09,860
0,510 600,1140 1140,1290 1290,1380 1380,1860
code,| {} you know, then
你知道吗，那你就知道不重新设计是个好主意，

1510
00:50:09,890 --> 00:50:10,550
0,90 90,240 240,450 450,510 510,660
you know it's a good

1511
00:50:10,550 --> 00:50:11,750
0,240 240,480 480,750 750,990 990,1200
idea not actually do that

1512
00:50:11,750 --> 00:50:13,560
0,450 450,660 660,870 870,1440
redesign,| it's not necessary.|
|这不是必须的。|

1513
00:50:14,340 --> 00:50:15,400
0,510

1514
00:50:15,430 --> 00:50:17,290
0,120 120,570 690,1050 1050,1200 1200,1860
And so, {} in general,
因此，一般说来，一条好的形式规则

1515
00:50:17,320 --> 00:50:19,240
0,480 480,600 600,840 840,1470 1470,1920
{} a good rule of

1516
00:50:19,240 --> 00:50:20,350
0,240 240,450 450,660 660,960 960,1110
form| is you start with
|就是从粗粒度的锁开始，

1517
00:50:20,350 --> 00:50:22,510
0,300 300,900 990,1500 1500,1680 1680,2160
coarse-grained locks,| measure when a
|测量何时出现这些锁之一的争用

1518
00:50:22,510 --> 00:50:23,710
0,510 510,630 630,930 930,1110 1110,1200
contention that appears one of

1519
00:50:23,710 --> 00:50:25,270
0,150 150,600 600,780 780,1080 1080,1560
these locks| and then redesign
|然后重新设计系统的这一部分，

1520
00:50:25,270 --> 00:50:26,230
0,210 210,420 420,510 510,600 600,960
that part of the system,|
|

1521
00:50:26,230 --> 00:50:27,190
0,180 180,300 300,420 420,570 570,960
so that you get better,
这样你就会变得更好，更好的并行性。

1522
00:50:27,550 --> 00:50:28,980
0,420 420,930
better parallelism.|
|

1523
00:50:30,740 --> 00:50:32,240
0,120 120,270 270,420 420,750 1230,1500
Does that make sense, any
这说得通吗，到目前为止还有什么问题吗？

1524
00:50:32,240 --> 00:50:33,700
0,390 390,540 540,930
questions so far?|
|

1525
00:50:39,030 --> 00:50:41,490
0,300 300,570 570,750 750,1410 1590,2460
Okay, let's look at {}.|
好，我们来看一下。|

1526
00:50:42,140 --> 00:50:44,390
0,570 570,1380 1380,1530 1530,2040 2040,2250
Well let's look at {xv6
好，让我们看看xv6，您知道一些代码

1527
00:50:44,390 --> 00:50:45,590
0,390 390,540 540,900 930,1050 1050,1200
-} and you know some

1528
00:50:45,590 --> 00:50:47,840
0,480 600,1320 1410,1980 1980,2040 2040,2250
code| to understand a little
|为了稍微了解一下这种锁定在xv6中是如何工作的。

1529
00:50:47,840 --> 00:50:49,220
0,240 240,600 600,780 780,1200 1200,1380
bit how this locking sort

1530
00:50:49,220 --> 00:50:50,630
0,90 90,360 360,630 630,960 990,1410
of works out in practice

1531
00:50:50,630 --> 00:50:52,040
0,90 90,330 330,480 480,1020
the {xv6 - -}.|
|

1532
00:50:53,650 --> 00:50:54,400
0,180 180,330 330,420 420,630 630,750
And so I'm gonna go
所以我要回过头来看一遍。

1533
00:50:54,400 --> 00:50:57,820
0,570 690,1110 1110,1830 2370,2790
back through a {}.|
|

1534
00:50:58,480 --> 00:50:59,620
0,660
{To,the}
对着这个屏幕，我真的很需要这个。

1535
00:51:00,660 --> 00:51:02,730
0,180 180,810 1020,1680 1680,1860 1860,2070
this screen, I really need

1536
00:51:02,730 --> 00:51:03,680
0,450
this.|
|

1537
00:51:03,680 --> 00:51:04,820
0,420 420,510 510,720 720,780 780,1140
And I want to look
我想看看UART，

1538
00:51:04,820 --> 00:51:06,590
0,390 390,570 570,870 870,1290 1290,1770
at {uart -},| because we
|因为我们开始讨论锁在那里的事。

1539
00:51:06,620 --> 00:51:08,270
0,330 330,660 660,900 900,1230 1230,1650
start talking about locking there.|
|

1540
00:51:08,570 --> 00:51:09,880
0,750

1541
00:51:10,240 --> 00:51:11,720
0,960
{On,the},
在周一，我想看得更详细一点。

1542
00:51:13,190 --> 00:51:14,120
0,150 150,630 630,780 780,810 810,930
on Monday and I want

1543
00:51:14,120 --> 00:51:14,660
0,60 60,180 180,240 240,420 420,540
to look a little bit

1544
00:51:14,660 --> 00:51:15,940
0,180 180,240 240,690
more in detail.|
|

1545
00:51:16,390 --> 00:51:17,560
0,480 480,750 750,900 900,1020 1020,1170
And now that we know
现在我们对锁有了更多的了解

1546
00:51:17,560 --> 00:51:18,250
0,30 30,180 180,300 300,480 480,690
a little bit more about

1547
00:51:18,250 --> 00:51:20,080
0,330 330,480 480,630 630,930 930,1830
locks| and then also illustrate
|然后还说明了几个有趣的观点。

1548
00:51:20,080 --> 00:51:21,250
0,30 30,270 270,330 330,690 690,1170
a couple of interesting points.|
|

1549
00:51:22,070 --> 00:51:23,740
0,600

1550
00:51:28,110 --> 00:51:30,150
0,450 450,930 960,1740 1770,1920 1920,2040
So first, {} you know
所以首先，你知道事实证明你想知道，

1551
00:51:30,150 --> 00:51:31,320
0,150 150,390 390,750 750,870 870,1170
it turns out you want

1552
00:51:31,320 --> 00:51:33,480
0,540 870,1170 1200,1410 1410,1740 1740,2160
to know,| what's looking at
|你在看什么，洛克，

1553
00:51:34,390 --> 00:51:36,310
0,1080 1110,1320 1320,1560 1560,1770 1770,1920
lock,| it turns out that
|原来UART实际上只有一个锁，

1554
00:51:36,310 --> 00:51:38,140
0,270 270,840 840,1230 1230,1590 1590,1830
the uart actually has only

1555
00:51:38,140 --> 00:51:39,580
0,270 270,720 930,1200 1200,1320 1320,1440
one lock,| so you can
|所以你可以认为这是一个合理的粗粒度，

1556
00:51:39,580 --> 00:51:40,600
0,150 150,330 330,540 540,660 660,1020
think about this as a

1557
00:51:40,600 --> 00:51:42,880
0,360 360,1290 1350,1800 1800,2220 2220,2280
reasonable coarse-grained,| {} design at
|至少在这一点上为UART进行设计。

1558
00:51:42,880 --> 00:51:44,380
0,150 150,450 450,840 1200,1350 1350,1500
this particular point at least

1559
00:51:44,380 --> 00:51:45,540
0,150 150,330 330,660
for {uart -}.|
|

1560
00:51:45,540 --> 00:51:46,800
0,60 60,150 150,540 540,990 1020,1260
And that particular lock, it
和那个特定的锁，它基本上保护UART传输缓冲区

1561
00:51:46,800 --> 00:51:49,830
0,660 690,1440 1440,2010 2010,2490 2490,3030
protects basically uart transmission buffer|
|

1562
00:51:50,190 --> 00:51:53,040
0,870 900,1260 1260,1860 1860,2430 2460,2850
and write pointer and read
以及写指针和读指针。

1563
00:51:53,070 --> 00:51:54,940
0,150 150,480
{} pointer.|
|

1564
00:51:55,150 --> 00:51:56,320
0,150 150,360 360,480 480,1080 1080,1170
So when we transmit,| you
所以当我们传输的时候，|您知道写指针指向传输缓冲区中的下一个空闲插槽

1565
00:51:56,320 --> 00:51:58,420
0,150 150,570 600,840 840,1470 1710,2100
know the write pointer points

1566
00:51:58,420 --> 00:51:59,530
0,120 120,210 210,420 420,690 690,1110
to the next free slot

1567
00:51:59,530 --> 00:52:01,510
0,300 300,600 630,1050 1050,1590 1800,1980
in the transmission buffer| and
|指针是实际需要传输的下一个时隙。

1568
00:52:01,510 --> 00:52:03,070
0,180 180,600 600,780 780,1200 1230,1560
the pointer is the next

1569
00:52:03,070 --> 00:52:03,910
0,150 150,300 300,570 570,750 750,840
slot, that actually needs to

1570
00:52:03,910 --> 00:52:05,060
0,90 90,660
be transmitted.|
|

1571
00:52:05,200 --> 00:52:07,060
0,330 330,480 480,600 600,1050 1290,1860
Maybe this is our {}
也许这就是我们并行的标准设计。

1572
00:52:07,060 --> 00:52:11,060
0,840 870,1800 1920,2610 2640,3450
standard design for parallelism.|
|

1573
00:52:11,060 --> 00:52:12,920
0,300 300,420 420,660 660,1230 1230,1860
Or for a consumer, {}
或者对于消费者来说，生产者和消费者并行不悖。

1574
00:52:12,950 --> 00:52:14,680
0,270 270,600 600,1140
producer consumer parallelism.|
|

1575
00:52:15,210 --> 00:52:16,260
0,180 180,330 330,510 510,660 660,1050
So let me go back
所以让我回去把它拿出来。

1576
00:52:16,260 --> 00:52:18,240
0,300 780,1470
and {}

1577
00:52:18,330 --> 00:52:20,500
0,300 300,450 450,900 1140,1680
brought it out.| So,
|所以，案例研究UART，

1578
00:52:20,710 --> 00:52:22,240
0,360 360,990
case study

1579
00:52:24,740 --> 00:52:26,120
0,240 240,1080
{uart -},|
|

1580
00:52:27,340 --> 00:52:29,420
0,270 270,420 420,840 840,1530
and there's basically buffer.|
基本上就是缓冲。|

1581
00:52:29,870 --> 00:52:30,980
0,300 300,510 510,570 570,720 720,1110
and there's a read pointer,
这里有一个读指针，还有一个写指针

1582
00:52:30,980 --> 00:52:32,870
0,210 210,300 300,540 540,1170 1500,1890
there's a write pointer| or
|或者写读索引和读索引。

1583
00:52:32,900 --> 00:52:35,150
0,450 480,840 840,1410 1410,1860 1980,2250
write read index and read

1584
00:52:35,150 --> 00:52:36,280
0,600
index.|
|

1585
00:52:37,110 --> 00:52:38,220
0,210 210,390 390,450 450,630 630,1110
This has to go to
这必须转到正在显示的UART，

1586
00:52:38,250 --> 00:52:41,260
0,150 150,720 750,1230 1620,2370
{uart -} being displayed,|
|

1587
00:52:42,820 --> 00:52:44,320
0,330 330,480 480,630 630,840 870,1500
and this is the writer,|
这是作者，|

1588
00:52:46,740 --> 00:52:48,720
0,270 270,780 1080,1560 1590,1800 1800,1980
{printf -} maybe that actually
printf可能这实际上会将字符插入到此缓冲区中。

1589
00:52:48,720 --> 00:52:50,730
0,480 510,960 960,1380 1380,1560 1560,2010
sticks characters into this buffer.|
|

1590
00:52:52,490 --> 00:52:53,580
0,600
Okay?|
好吧?|

1591
00:52:53,840 --> 00:52:54,980
0,330 330,780 780,870 870,990 990,1140
And so you know we
所以你知道我们可以看到的是锁，

1592
00:52:54,980 --> 00:52:55,640
0,120 120,300 300,420 420,570 570,660
can see is that the

1593
00:52:55,640 --> 00:52:57,740
0,600 630,1230 1260,1410 1410,1710 1710,2100
lock,| {} you know lock
|你知道锁有多个角色。

1594
00:52:57,740 --> 00:52:59,220
0,120 120,480 480,1020
has multiple roles.|
|

1595
00:53:03,200 --> 00:53:05,330
0,600 600,1050 1050,1380 1380,1830 1830,2130
One is to basically protect
一个是从根本上保护这个数据结构。

1596
00:53:05,330 --> 00:53:06,720
0,120 120,360 360,870
this data structure.|
|

1597
00:53:11,640 --> 00:53:12,810
0,300 300,510 510,810 810,930 930,1170
This data structure has some
该数据结构具有某种不变性，

1598
00:53:12,810 --> 00:53:14,200
0,690
invariance,|

1599
00:53:14,200 --> 00:53:17,890
0,1110 1110,1410 1440,2040 2040,2610 2790,3690
namely, the read {to,proceed} write,|
即，读以进行写，|

1600
00:53:18,250 --> 00:53:20,710
0,960 990,1470 1470,1860 1860,2250 2250,2460
{} anything between {} R
R W或需要发送的字符之间的任何内容，

1601
00:53:20,710 --> 00:53:22,390
0,660 660,990 990,1380 1380,1530 1530,1680
W or characters that need

1602
00:53:22,390 --> 00:53:24,160
0,60 60,210 210,690 1050,1470 1470,1770
to be sent,| anything between
|W和R之间的任何东西实际上都是[空]槽。

1603
00:53:24,160 --> 00:53:25,390
0,360 360,480 480,840 840,990 990,1230
W and R are things

1604
00:53:25,390 --> 00:53:27,100
0,150 150,630 630,960 960,1170 1170,1710
that actually are [empty] slots.|
|

1605
00:53:27,780 --> 00:53:29,460
0,840 840,930 930,1230 1230,1290 1290,1680
And the locks are basically
这些锁基本上对我们有帮助，

1606
00:53:29,460 --> 00:53:31,740
0,600 600,1050 1050,1830 1860,2040 2040,2280
{help,us},| {} maintain {} that
|保持这个不变量。

1607
00:53:31,740 --> 00:53:32,880
0,630
invariant.|
|

1608
00:53:34,080 --> 00:53:36,940
0,510 540,870 870,1200 1680,2370
So, here are {}
所以，这里又是代码。

1609
00:53:37,170 --> 00:53:38,480
0,270 270,810
code again.|
|

1610
00:53:38,480 --> 00:53:40,400
0,720 780,1470 1500,1740 1740,1830 1830,1920
And let's look at the
让我们来看看收购的情况。

1611
00:53:40,400 --> 00:53:41,780
0,810
acquire.|
|

1612
00:53:41,900 --> 00:53:45,320
0,450 450,1110 1110,1380 2580,3300 3300,3420
So here's uartputc,| and you
这里是uartputc，|你知道uartputc[]做的第一件事，

1613
00:53:45,320 --> 00:53:46,370
0,150 150,240 240,480 480,930 930,1050
know the first thing you

1614
00:53:46,370 --> 00:53:47,120
0,90 90,210 210,420 420,540 540,750
know {uartputc -} {[] -}

1615
00:53:47,120 --> 00:53:48,620
0,480 480,990 990,1080 1080,1230 1230,1500
does,| actually you know grab
|实际上你知道抓住锁，

1616
00:53:48,620 --> 00:53:49,700
0,90 90,570
the lock,|
|

1617
00:53:49,900 --> 00:53:52,510
0,750 750,1140 1140,1530 1530,2160 2310,2610
{} and then {stick -}
然后贴上一个角色，

1618
00:53:52,510 --> 00:53:54,160
0,0 240,930 990,1170 1170,1410 1410,1650
a character,| if there's a
|如果缓冲区中有位置，则将桶字符插入缓冲区

1619
00:53:54,160 --> 00:53:55,420
0,360 360,420 420,480 480,960 990,1260
place in the buffer sticks

1620
00:53:55,420 --> 00:53:56,260
0,60 60,330 330,690 690,780 780,840
the barrel character in the

1621
00:53:56,260 --> 00:53:58,210
0,570 930,1080 1080,1680 1680,1770 1770,1950
buffer| and start you know
|开始打印，然后释放锁，

1622
00:53:58,210 --> 00:54:00,100
0,450 480,900 900,1020 1020,1200 1200,1890
the printing and then releases

1623
00:54:00,190 --> 00:54:01,620
0,390 390,870
{} the

1624
00:54:01,740 --> 00:54:03,690
0,270 270,720 930,1320 1320,1470 1470,1950
{} lock,| so if two
|因此，如果两个进程同时调用uartputc，那么锁定将确保

1625
00:54:03,690 --> 00:54:05,640
0,720 720,810 810,900 900,1290 1290,1950
processes at the same time

1626
00:54:05,880 --> 00:54:07,620
0,600 600,750 750,900 900,1140 1140,1740
call {uartputc - - -},

1627
00:54:07,740 --> 00:54:09,780
0,630 660,870 870,1110 1110,1260 1260,2040
then there's lock will ensure

1628
00:54:09,900 --> 00:54:11,490
0,480 510,810 810,1080 1080,1440 1440,1590
that| {you,know} one character from
|您知道第一个进程中的一个字符出现在第一个槽中

1629
00:54:11,490 --> 00:54:12,420
0,60 60,300 300,660 660,840 840,930
the first process goes in

1630
00:54:12,420 --> 00:54:14,010
0,60 60,300 300,720 750,1110 1110,1590
the first slot| and then
|然后第二个进程的第二个字符进入下一个槽

1631
00:54:14,100 --> 00:54:16,770
0,630 1470,1770 1770,2370 2370,2550 2550,2670
the second character of the

1632
00:54:16,770 --> 00:54:18,150
0,240 240,840 840,1170 1170,1290 1290,1380
second process goes into the

1633
00:54:18,150 --> 00:54:19,560
0,210 210,570 630,930 930,1110 1110,1410
next slot| and they're known
|据说他们碰巧在同一个位置结束了。

1634
00:54:19,560 --> 00:54:20,700
0,120 150,510 510,660 660,960 960,1140
as happened to end up

1635
00:54:20,700 --> 00:54:22,160
0,420 420,510 510,750 750,1140
in the same slot.|
|

1636
00:54:22,680 --> 00:54:23,550
0,240 240,330 330,510 510,630 630,870
Right, so this is a
对，所以这是一个很明显的例子

1637
00:54:23,550 --> 00:54:24,960
0,270 270,720 720,930 930,990 990,1410
clear example| where {} lock
|锁定它可以帮助我们避免竞争情况，

1638
00:54:25,110 --> 00:54:27,360
0,300 300,600 600,780 780,1260 1560,2250
it helps us to {}

1639
00:54:27,780 --> 00:54:28,620
0,630
{}

1640
00:54:29,430 --> 00:54:31,500
0,480 480,540 540,720 720,1260 1320,2070
avoids a race condition,| because
|因为不然的话，你就会知道，

1641
00:54:31,500 --> 00:54:33,280
0,510 510,600 600,750 750,1110
otherwise you know the,|
|

1642
00:54:33,280 --> 00:54:35,020
0,150 150,480 480,870 870,1080 1080,1740
the second process might overwrite
第二个进程可能会覆盖第一个进程的特征，

1643
00:54:35,020 --> 00:54:36,280
0,450 450,540 540,630 630,780 780,1260
{}, you know the first

1644
00:54:36,310 --> 00:54:37,940
0,600 600,1080
process's character,|
|

1645
00:54:38,740 --> 00:54:40,750
0,330 330,540 540,960 1410,1800 1800,2010
that's one part.| Then you
这只是一部分。|然后你去看看。

1646
00:54:40,750 --> 00:54:42,740
0,120 120,360 360,600 630,1440
go look at {}.|
|

1647
00:54:42,960 --> 00:54:43,500
0,150 150,270 270,390 390,510 510,540
And we did that a
我们之前做过一点，

1648
00:54:43,500 --> 00:54:44,340
0,150 150,300 300,630 630,720 720,840
little bit before,| we look
|我们看看START，我们看到更多的事情在发生。

1649
00:54:44,340 --> 00:54:45,510
0,60 60,630 660,990 990,1110 1110,1170
at start, we see a

1650
00:54:45,510 --> 00:54:46,740
0,210 210,390 390,630 630,840 840,1230
couple more things going on.|
|

1651
00:54:47,360 --> 00:54:48,640
0,720

1652
00:54:48,640 --> 00:54:50,140
0,360 360,960
The {}.|
这个。|

1653
00:54:50,140 --> 00:54:51,460
0,300 300,540 540,690 690,1050 1050,1320
{} We see actually that
我们实际上看到的是。

1654
00:54:51,460 --> 00:54:52,580
0,540
the.|
|

1655
00:54:53,220 --> 00:54:54,960
0,480 480,630 630,1200 1200,1290 1290,1740
{} If buffer is not
如果缓冲区不是，您知道。

1656
00:54:54,960 --> 00:54:57,460
0,210 210,870 1260,1890
you know, {}.|
|

1657
00:54:57,460 --> 00:54:58,210
0,90 90,180 180,420 420,510 510,750
If the buffer is not
如果缓冲器不为空，

1658
00:54:58,210 --> 00:55:00,610
0,540 870,1680 1680,1800 1800,2190 2190,2400
empty,| then we know that
|那么我们就知道基本上有一堆人物，

1659
00:55:00,610 --> 00:55:02,530
0,510 510,720 720,750 750,990 990,1920
basically there's a bunch of

1660
00:55:02,560 --> 00:55:04,330
0,510 510,660 660,720 720,1050 1050,1770
characters,| that are being progressed
|正在进行或正在发送的。

1661
00:55:04,630 --> 00:55:06,360
0,450 450,690 690,1170
or being sent.|
|

1662
00:55:06,450 --> 00:55:07,800
0,570 570,720 720,840 840,960 960,1350
And you know the lock,
你知道锁的，你知道，确保我们不会真的覆盖其中的任何一个，

1663
00:55:07,800 --> 00:55:08,580
0,90 90,180 180,360 360,660 660,780
you know, make sure that

1664
00:55:08,580 --> 00:55:10,560
0,120 120,300 300,810 1170,1770 1770,1980
we don't really overwrite any

1665
00:55:10,560 --> 00:55:12,510
0,90 90,600 810,1230 1440,1770 1770,1950
of those,| so anything that's
|所以任何队列末尾的东西，

1666
00:55:12,510 --> 00:55:14,430
0,120 120,300 300,600 1050,1620 1620,1920
sort of the {tail,end} of

1667
00:55:14,430 --> 00:55:16,890
0,390 420,960 960,1200 1200,1950 1950,2460
the queue,| {} is actually
|实际上是由UART本身处理的。

1668
00:55:16,890 --> 00:55:18,540
0,210 210,450 450,1050 1050,1500 1500,1650
a being processed by the

1669
00:55:18,540 --> 00:55:20,300
0,570 870,1500
uart {}

1670
00:55:21,120 --> 00:55:23,500
0,660 810,1470 1500,1860
{} itself.| So,
|所以，尾部在飞行中。

1671
00:55:23,560 --> 00:55:24,960
0,240 240,720
{tailend -}

1672
00:55:26,410 --> 00:55:28,000
0,270 270,510 510,1050
is in flight.|
|

1673
00:55:30,370 --> 00:55:31,510
0,180 180,600 600,780 780,1020 1020,1140
And we make sure that|
我们要确保|

1674
00:55:31,510 --> 00:55:33,850
0,90 90,510 510,990 1260,2040 2040,2340
we basically don't modify or
我们基本上不会通过获取锁来修改或干扰该特定方面。

1675
00:55:33,970 --> 00:55:35,470
0,540 540,630 630,810 810,1140 1140,1500
interfere with that particular aspect

1676
00:55:35,470 --> 00:55:37,640
0,390 420,1110 1110,1200 1200,1620
by grabbing a lock.|
|

1677
00:55:38,060 --> 00:55:39,860
0,210 210,330 330,900 1380,1650 1650,1800
And then finally, {} they're
最后，它们是越来越多的东西

1678
00:55:39,860 --> 00:55:40,910
0,150 150,210 210,390 390,480 480,1050
sort of more and more

1679
00:55:41,000 --> 00:55:43,040
0,390 390,570 570,930 1140,1440 1440,2040
thing| is that the writes
|是对UART寄存器的写入

1680
00:55:43,400 --> 00:55:46,010
0,1050 1050,1590 1590,2370 2400,2550 2550,2610
{} to registers of the

1681
00:55:46,010 --> 00:55:47,720
0,510 510,660 660,870 870,1350 1350,1710
uart| like that THR register,|
|就像THR寄存器一样，|

1682
00:55:47,720 --> 00:55:49,160
0,330 330,510 510,720 720,900 900,1440
which one there's only one,|
哪一个只有一个，|

1683
00:55:49,460 --> 00:55:50,480
0,120 120,210 210,570 570,690 690,1020
you know basically the lock
您知道，基本上锁确保记住刚刚调用的UART start在保持锁的情况下，

1684
00:55:50,480 --> 00:55:52,610
0,750 870,1230 1350,1710 1710,1800 1800,2130
ensures {} remember the uart

1685
00:55:52,610 --> 00:55:54,230
0,240 240,390 390,750 750,930 930,1620
start just called with lock

1686
00:55:54,260 --> 00:55:56,660
0,510 840,1650 1650,1830 1830,2190 2190,2400
held,| assures this is only
确保这只是THR寄存器的一个写入器。

1687
00:55:56,660 --> 00:55:58,250
0,360 360,990 990,1110 1110,1200 1200,1590
one writer to the THR

1688
00:55:58,250 --> 00:55:59,300
0,630
register.|
|

1689
00:55:59,870 --> 00:56:01,550
0,240 240,660 870,1440 1440,1620 1620,1680
And so, another sort of
因此，另一种变体或另一方面，

1690
00:56:01,550 --> 00:56:03,320
0,570 570,690 690,960 960,1350 1350,1770
variant or another aspect,| that
|锁定强制实施的是硬件寄存器具有一个写入器。

1691
00:56:03,320 --> 00:56:05,390
0,120 120,540 540,1200 1230,1860 1860,2070
the locking {} enforces is

1692
00:56:05,390 --> 00:56:07,640
0,390 480,990 990,1680
that hardware registers,

1693
00:56:10,510 --> 00:56:12,040
0,240 240,480 480,990
have one writer.|
|

1694
00:56:16,460 --> 00:56:17,600
0,630
Okay?|
好吧?|

1695
00:56:18,530 --> 00:56:19,940
0,360 360,510 510,720 720,1020 1020,1410
{You,know}, there's one other interesting
你知道吗，还有一件有趣的事，

1696
00:56:19,940 --> 00:56:21,410
0,210 210,390 390,540 540,720 720,1470
thing,| that I want to
|我想稍微谈一谈，

1697
00:56:21,440 --> 00:56:22,730
0,330 330,420 420,690 690,810 810,1290
talk a little bit about,|
|

1698
00:56:23,120 --> 00:56:25,160
0,360 360,630 630,1050 1080,1740 1890,2040
and that is {} you
那就是你知道你，UART刚刚做得对

1699
00:56:25,160 --> 00:56:26,480
0,180 180,780 810,1050 1050,1140 1140,1320
know you, {uart -} just

1700
00:56:26,480 --> 00:56:27,470
0,270 270,540 540,750 750,870 870,990
done correct,| {hardware -} is
|硬件完成后，中断了。

1701
00:56:27,470 --> 00:56:28,940
0,300 300,750 990,1230 1230,1380 1380,1470
done then, {} there was

1702
00:56:28,940 --> 00:56:30,000
0,60 60,630
an interrupt.|
|

1703
00:56:30,170 --> 00:56:32,600
0,840 960,1740 1740,1980 1980,2100 2100,2430
And, {} as you know,|
而且，如你所知，|

1704
00:56:32,600 --> 00:56:34,070
0,180 180,450 450,780 780,1020 1020,1470
we notice before uart start
我们注意到在UART开始之前，

1705
00:56:34,070 --> 00:56:35,210
0,300 300,390 390,570 570,720 720,1140
right,| you know we have
|你知道我们找到打电话的人了，

1706
00:56:36,290 --> 00:56:38,030
0,390 390,960 960,1320 1320,1410 1410,1740
the caller,| it's a caller
|它是调用者获取锁以确保，

1707
00:56:38,030 --> 00:56:39,380
0,90 90,540 540,600 600,1050 1110,1350
to acquire the lock to

1708
00:56:39,380 --> 00:56:42,440
0,780 960,1530 1530,2310 2520,2910 2910,3060
ensure {} that {},| we
|我们不允许多个实体运行到[右]寄存器。

1709
00:56:42,440 --> 00:56:45,080
0,180 180,870 1440,2190 2190,2520 2520,2640
don't multiple entities running to

1710
00:56:45,080 --> 00:56:46,280
0,60 60,300 300,750
the [right] register.|
|

1711
00:56:46,620 --> 00:56:49,260
0,510 720,1020 1020,1440 1710,2190 2220,2640
{} And so {} uart
因此UART中断本身可以与另一个进程并行运行，

1712
00:56:49,260 --> 00:56:51,960
0,360 360,1020 1350,1560 1560,2310 2520,2700
interrupt itself could run in

1713
00:56:51,960 --> 00:56:54,150
0,930 960,1350 1350,1650 1650,2040 2040,2190
parallel with another process,| that's
|这就是所谓的printf，

1714
00:56:54,150 --> 00:56:55,230
0,210 210,390 390,630 630,870 870,1080
called {printf -},| so there's
|所以这里有一些实用的印刷品，

1715
00:56:55,230 --> 00:56:57,030
0,180 180,600 600,840 840,1140 1500,1800
some practical {printf -} {},|
|

1716
00:56:57,030 --> 00:56:58,500
0,210 210,330 330,420 420,810 810,1470
that runs to CPU zero|
它运行到CPU为零|

1717
00:56:58,560 --> 00:57:00,120
0,360 360,540 540,900 900,1260 1260,1560
and on CPU one actually
在CPU上，一个人实际上接受UART中断，

1718
00:57:00,120 --> 00:57:02,010
0,360 360,450 450,780 780,1380 1410,1890
takes the uart interrupt,| because
|因为也许它什么都没做，

1719
00:57:02,010 --> 00:57:03,030
0,240 240,360 360,540 540,900 900,1020
maybe it's doing nothing,| and
|因此，它已经准备好中断任何特定的时间点。

1720
00:57:03,030 --> 00:57:04,050
0,90 90,210 210,420 420,690 690,1020
so it's ready to interrupt

1721
00:57:04,050 --> 00:57:05,250
0,180 180,480 480,660 660,720 720,1200
any particular point of time.|
|

1722
00:57:05,720 --> 00:57:07,310
0,420 420,660 660,1200 1230,1290 1320,1590
And it will {[] -}
它将[]调用uartstart。

1723
00:57:07,310 --> 00:57:08,900
0,270 270,600 600,1050
call {uartstart -}.|
|

1724
00:57:09,080 --> 00:57:09,800
0,150 150,240 240,540 540,600 600,720
And it has to be
它必须是正确的案例，

1725
00:57:09,800 --> 00:57:10,850
0,60 60,420 420,810 810,900 900,1050
the case correct,| you know
|您知道，我们希望确保硬件寄存器中只有一个写入器

1726
00:57:10,850 --> 00:57:11,720
0,150 150,300 300,360 360,720 720,870
we want to ensure that

1727
00:57:11,720 --> 00:57:12,980
0,150 150,210 210,540 540,960 960,1260
there's a single writer into

1728
00:57:12,980 --> 00:57:15,200
0,150 150,450 450,1050 1290,1800 1800,2220
the hardware registers| {} or
|或者为了保护您知道传输缓冲区的实际方差，

1729
00:57:15,200 --> 00:57:16,460
0,120 120,600 600,660 660,810 810,1260
to protect you know the

1730
00:57:16,910 --> 00:57:18,680
0,570 570,840 840,990 990,1320 1350,1770
variance actually of the transmission

1731
00:57:18,680 --> 00:57:20,360
0,420 780,1350 1350,1470 1470,1560 1560,1680
buffer,| {} you know, we
|你知道，我们得弄到一把锁。

1732
00:57:20,360 --> 00:57:21,780
0,270 270,630 630,660 660,1020
{have,to} acquire a lock.|
|

1733
00:57:21,810 --> 00:57:22,440
0,150 150,240 240,390 390,510 510,630
And so it is the
因此情况是xv6实际上会中断，

1734
00:57:22,440 --> 00:57:24,480
0,540 540,930 930,1410 1410,1740 1740,2040
case that {} {xv6 -}

1735
00:57:24,480 --> 00:57:26,730
0,360 360,690 900,1680 1680,1950 1950,2250
actually that interrupts,| you can
|你可以运行下半部分的驱动程序才能真正的并发运行

1736
00:57:26,730 --> 00:57:28,560
0,720 1020,1140 1140,1410 1410,1710 1710,1830
run the bottom half of

1737
00:57:28,560 --> 00:57:30,210
0,90 90,570 570,690 690,1050 1080,1650
the driver can run truly

1738
00:57:30,210 --> 00:57:33,000
0,600 600,960 960,1320 1320,2100 2400,2790
concurrent| on a on different
|在带有驱动程序上半部分的不同处理器上

1739
00:57:33,000 --> 00:57:34,800
0,600 630,1050 1050,1140 1140,1440 1440,1800
processors with the top half

1740
00:57:34,800 --> 00:57:36,360
0,210 210,510 510,990 1200,1470 1470,1560
of the driver| and so
|因此中断功能也需要锁定。

1741
00:57:36,360 --> 00:57:39,360
0,420 420,1590 1590,2130 2400,2760 2760,3000
therefore interrupt functions {} also

1742
00:57:39,360 --> 00:57:40,520
0,390 390,780
require locks.|
|

1743
00:57:40,930 --> 00:57:41,890
0,210 210,450 450,510 510,630 630,960
In fact, in this particular
事实上，在这个特殊的情况下，你知道需要一把锁，

1744
00:57:41,890 --> 00:57:43,990
0,540 690,1200 1200,1290 1290,1500 1770,2100
case {} you know requires

1745
00:57:43,990 --> 00:57:44,830
0,60 60,270 270,540 540,660 660,840
the one lock,| that there's
|在UART中实际上有

1746
00:57:44,830 --> 00:57:46,720
0,300 300,420 420,480 480,990 1020,1890
actually in the uart| and
|然后调用uartstart

1747
00:57:46,750 --> 00:57:47,770
0,150 150,330 330,480 480,510 510,1020
then calls {uartstart - -}|
|

1748
00:57:47,770 --> 00:57:48,940
0,90 90,360 360,750 750,840 840,1170
and then releases the lock.|
然后释放锁。|

1749
00:57:50,720 --> 00:57:51,800
0,240 240,540 540,690 690,930 930,1080
And I'll come back to
稍后我会回到这个问题上来，

1750
00:57:51,800 --> 00:57:53,060
0,180 180,300 300,300 300,840 870,1260
that in a second,| because
|因为实现锁有一点棘手，

1751
00:57:53,060 --> 00:57:53,840
0,150 150,210 210,360 360,480 480,780
there's a little bit {trickiness

1752
00:57:53,840 --> 00:57:56,660
0,450 660,1560 1560,2220 2250,2730 2730,2820
-} {} in implementing a

1753
00:57:56,660 --> 00:57:58,190
0,450 690,810 810,1080 1080,1170 1170,1530
lock,| in such a way
|在这样的方式下，这实际上是正确的。

1754
00:57:58,190 --> 00:57:59,210
0,180 180,330 330,600 600,870 870,1020
that this actually works out

1755
00:57:59,210 --> 00:58:00,220
0,480
correctly.|
|

1756
00:58:00,490 --> 00:58:01,920
0,870
And.|
和。|

1757
00:58:01,920 --> 00:58:03,750
0,150 150,630 1080,1380 1380,1530 1530,1830
And the thing that actually
实际上你应该担心的是，

1758
00:58:03,750 --> 00:58:04,650
0,90 90,240 240,330 330,570 570,900
you should be worried about

1759
00:58:04,650 --> 00:58:07,140
0,180 180,630 930,2040 2040,2280 2280,2490
is that,| {} all actually
|实际上，所有这些都是在一秒钟内谈论的，

1760
00:58:07,140 --> 00:58:07,980
0,210 210,390 390,480 480,540 540,840
talk about in a second,|
|

1761
00:58:08,010 --> 00:58:09,090
0,240 240,360 360,720 720,900 900,1080
let me postpone that until
让我把那件事推迟到我到那里去吧。

1762
00:58:09,090 --> 00:58:10,020
0,60 60,240 240,420
I get there.|
|

1763
00:58:13,040 --> 00:58:14,990
0,210 210,480 480,1050 1050,1290 1440,1950
Okay, so any any questions
好的，有任何关于这个的问题，

1764
00:58:14,990 --> 00:58:16,880
0,270 270,450 450,690 690,1170 1470,1890
about this,| {} a simple
|一个简单的锁使用和UART示例。

1765
00:58:16,880 --> 00:58:20,360
0,690 690,1050 1290,2280 2280,2880 3000,3480
example of lock use and

1766
00:58:20,360 --> 00:58:21,520
0,120 120,630
{uart -}.|
|

1767
00:58:29,640 --> 00:58:31,740
0,390 390,570 570,1230 1710,2010 2010,2100
Okay, let me bring this
好的，让我带上这种，

1768
00:58:31,740 --> 00:58:32,790
0,150 150,270 270,480 480,660 660,1050
kind of {},| let me
让我来谈谈实现锁的问题。

1769
00:58:32,790 --> 00:58:34,140
0,210 210,390 390,840 840,900 900,1350
talk about implementing a lock.|
|

1770
00:58:34,940 --> 00:58:37,160
0,600 1200,1470 1470,1890 1890,2010 2010,2220
{} So {the,spec} is that
因此，规范是只有一个进程可以获取锁，

1771
00:58:37,160 --> 00:58:40,640
0,270 270,990 1200,2400 2520,2940 2940,3480
only one process can acquire

1772
00:58:40,640 --> 00:58:43,010
0,480 600,1170 1170,1380 1380,1890 1920,2370
lock,| there's no more than
|在任何给定的时间点都不会有超过一个的锁具持有者。

1773
00:58:43,010 --> 00:58:44,120
0,300 300,570 570,810 810,930 930,1110
one lock holder at any

1774
00:58:44,120 --> 00:58:45,640
0,240 240,450 450,510 510,990
given point of time.|
|

1775
00:58:45,640 --> 00:58:47,410
0,510 510,1140 1140,1320 1320,1380 1380,1770
And we want to look
我们想要了解和了解

1776
00:58:47,440 --> 00:58:48,940
0,390 390,900 900,1140 1140,1410 1410,1500
and understand| actually how you
|实际上，您是如何以这样一种方式实现锁的，而这种方式实际上是有保证的。

1777
00:58:48,940 --> 00:58:49,840
0,360 360,390 390,630 630,720 720,900
implement a lock in such

1778
00:58:49,840 --> 00:58:50,740
0,90 90,240 240,540 540,840 840,900
a way that actually is

1779
00:58:50,740 --> 00:58:51,900
0,660
guaranteed.|
|

1780
00:58:51,930 --> 00:58:52,800
0,330 330,420 420,660 660,840 840,870
Let me first write a
让我先写一个坏了的锁。

1781
00:58:52,800 --> 00:58:54,160
0,360 360,810
broken lock.|
|

1782
00:58:54,440 --> 00:58:56,120
0,480 480,720 720,870 870,1530 1560,1680
{} So we understand you
所以我们理解你知道挑战或失败会带来什么。

1783
00:58:56,120 --> 00:58:58,160
0,90 90,300 300,480 480,1260 1350,2040
know what the challenges {}

1784
00:58:59,020 --> 00:59:00,800
0,300 300,600 600,1260
or broken acquire.|
|

1785
00:59:05,310 --> 00:59:06,060
0,210 210,360 360,450 450,600 600,750
So that we know what
这样我们就知道什么是真正的挑战是工具的获取。

1786
00:59:06,060 --> 00:59:07,200
0,120 120,510 510,720 720,1050 1050,1140
the challenge is actually an

1787
00:59:07,200 --> 00:59:08,640
0,390 390,960
implement acquire.|
|

1788
00:59:09,610 --> 00:59:11,440
0,510 810,990 990,1230 1230,1470 1470,1830
{} So here's my broken
这是我的坏掉的那个。

1789
00:59:11,440 --> 00:59:13,560
0,450 540,1200
one {}.|
|

1790
00:59:14,320 --> 00:59:16,580
0,180 180,960 960,1560
Well, construct []
嗯，Construct[]获取lock，星l，

1791
00:59:16,900 --> 00:59:20,120
0,630 630,1560 1590,2070 2070,2580
acquires lock, star l,|
|

1792
00:59:20,250 --> 00:59:21,880
0,840

1793
00:59:21,970 --> 00:59:22,840
0,150 150,300 300,480 480,540 540,870
you know what it does,
你知道它是做什么的吗，它是不是跟在后面，

1794
00:59:22,840 --> 00:59:24,070
0,180 180,300 300,840 840,960 960,1230
is it follows,| it has
|它有一个无限循环，而一个，

1795
00:59:24,070 --> 00:59:25,720
0,120 120,570 570,1140
an infinite loop,

1796
00:59:26,170 --> 00:59:27,960
0,600 600,1230
while one,|
|

1797
00:59:28,980 --> 00:59:30,880
0,420 420,630 630,1260
{} {} if
如果l被锁定，零表示没有人拿着它。

1798
00:59:31,260 --> 00:59:33,560
0,900 930,1770
{} l

1799
00:59:33,560 --> 00:59:36,440
0,630 840,1380 1380,1830 1830,2370 2430,2880
is locked zero mean nobody

1800
00:59:36,440 --> 00:59:37,780
0,390 390,750
holding it.|
|

1801
00:59:37,900 --> 00:59:39,280
0,450 450,810 810,870 870,1140 1140,1380
Then, resuming to {caller -}
然后，恢复到呼叫者那里，想必是抓住了锁。

1802
00:59:39,280 --> 00:59:40,510
0,240 240,360 360,690 690,750 750,1230
{presumably -} grabbed the lock.|
|

1803
00:59:40,690 --> 00:59:41,640
0,390
So,
那么，我们把l锁设为1，

1804
00:59:42,700 --> 00:59:44,410
0,570 570,690 690,1140 1140,1530 1530,1710
then we {set,l} lock to

1805
00:59:44,410 --> 00:59:45,660
0,630
one,|
|

1806
00:59:48,320 --> 00:59:49,550
0,690 690,840 840,1020 1020,1110 1110,1230
and you know at that
你知道在这一点上我们拿到了锁，

1807
00:59:49,550 --> 00:59:50,360
0,210 210,300 300,480 480,540 540,810
point we got the lock,|
|

1808
00:59:50,360 --> 00:59:52,070
0,150 150,270 270,390 390,1020 1410,1710
so we can return nothing
这样我们就可以什么都不做了。

1809
00:59:52,070 --> 00:59:53,560
0,90 90,240 240,810
to do anymore.|
|

1810
00:59:53,590 --> 00:59:55,330
0,420 780,1110 1110,1500 1500,1650 1650,1740
And close loop, if we
闭合环路，如果我们没拿到锁，

1811
00:59:55,330 --> 00:59:56,380
0,240 240,360 360,450 450,750 750,1050
didn't get the lock,| because
|因为锁是一把，

1812
00:59:56,380 --> 00:59:57,250
0,150 150,420 420,510 510,750 750,870
the lock was one,| it
|这意味着有其他人在把持，所以我们只要继续旋转就行了。

1813
00:59:57,250 --> 00:59:58,240
0,180 180,450 450,660 660,720 720,990
means somebody else is holding

1814
00:59:58,240 --> 00:59:59,050
0,240 240,360 360,480 480,630 630,810
lock so we just keep

1815
00:59:59,050 --> 01:00:00,040
0,360
spinning.|
|

1816
01:00:01,080 --> 01:00:02,250
0,630 630,690 690,900 900,1110 1110,1170
Waiting to go around the
等待着一遍又一遍地绕着循环

1817
01:00:02,250 --> 01:00:03,210
0,240 240,540 540,630 630,870 870,960
loop over and over and

1818
01:00:03,210 --> 01:00:04,650
0,510 780,990 990,1170 1170,1290 1290,1440
over| until do at some
|直到在某一时刻，你知道持有者锁持有者叫做释放，

1819
01:00:04,650 --> 01:00:06,540
0,480 480,540 540,660 660,1290
point you know the

1820
01:00:06,540 --> 01:00:07,830
0,150 150,420 420,630 630,960 960,1290
{} holder lock holder called

1821
01:00:07,830 --> 01:00:09,180
0,480 480,720 720,840 840,1080 1080,1350
release,| which will set lock
|将lock设置为，将lock设置为零。

1822
01:00:09,180 --> 01:00:11,100
0,300 300,510 780,1620 1620,1740 1740,1920
to, {} to will set

1823
01:00:11,100 --> 01:00:12,300
0,240 240,690
{lock,to} zero.|
|

1824
01:00:14,740 --> 01:00:17,140
0,540 540,690 690,1140 1680,1950 1950,2400
And you know what's wrong
您知道这个特殊实现的问题所在。

1825
01:00:17,140 --> 01:00:19,100
0,150 150,330 330,660 660,1380
with this particular implementation.|
|

1826
01:00:20,870 --> 01:00:23,390
0,150 150,660 750,1470 1530,2100 2100,2520
I think two processes, may
我想有两个进程，可能会读到它没有同时锁定。

1827
01:00:23,390 --> 01:00:25,370
0,360 360,510 510,810 810,1470 1470,1980
read that it's not locked

1828
01:00:25,760 --> 01:00:27,200
0,180 180,270 270,510 510,930
at the same time.|
|

1829
01:00:27,260 --> 01:00:29,260
0,1260
{Yeah,right}.|
是啊，没错。|

1830
01:00:30,040 --> 01:00:31,180
0,210 210,540 540,600 600,780 780,1140
So there's a race condition
所以这里有一个竞赛条件

1831
01:00:31,180 --> 01:00:33,520
0,540 570,1710
here| and
|只是为了确保这里的比赛。

1832
01:00:33,520 --> 01:00:34,840
0,150 150,360 360,630 660,900 900,1320
{} just to make sure

1833
01:00:34,840 --> 01:00:36,700
0,90 90,480 480,810 810,1320
the races right here.|
|

1834
01:00:39,020 --> 01:00:40,730
0,330 330,570 570,690 690,1260 1290,1710
{} We can have basically
我们基本上可以有两个CPU进入，

1835
01:00:40,730 --> 01:00:42,170
0,180 180,390 390,720 720,1020 1020,1440
two {CPUs -} coming in,|
|

1836
01:00:42,230 --> 01:00:43,340
0,120 120,240 240,510 510,810 810,1110
you know we talk time
你知道我们谈的是时间图。

1837
01:00:43,340 --> 01:00:44,580
0,720
diagram.|
|

1838
01:00:44,700 --> 01:00:47,370
0,510 510,600 600,1260 2190,2490 2490,2670
{You,know} CPU one, {CPU -}
你知道CPU 1，CPU 0，CPU 1，

1839
01:00:47,400 --> 01:00:49,700
0,720 720,930 930,1050 1050,1680
zero, {CPU -} one,|
|

1840
01:00:50,600 --> 01:00:52,220
0,150 150,450 480,750 750,1170 1170,1620
you know this statement a,
你知道这句话a，也许这句话b，

1841
01:00:52,550 --> 01:00:54,500
0,300 300,510 510,870 870,1350
maybe this statement b,|
|

1842
01:00:54,500 --> 01:00:56,930
0,840 870,1320 1320,1890 1920,2070 2070,2430
both CPU one you know,
这两个CPU一，你知道，达到语句a，

1843
01:00:57,500 --> 01:01:00,500
0,300 300,720 720,1140 1200,2310 2670,3000
reach statement a,| {} CPU
|CPU0和CPU0，1都达到[Each]语句a，

1844
01:01:00,500 --> 01:01:02,700
0,270 270,450 450,840 840,1650
zero and CPU the,

1845
01:01:02,950 --> 01:01:04,840
0,600 1020,1350 1350,1560 1560,1800 1800,1890
{} zero one {both,reach} {}

1846
01:01:04,840 --> 01:01:05,800
0,150 150,480 480,690 690,840 840,960
[each] statement a,| so they
|所以他们都认为锁定为零

1847
01:01:05,800 --> 01:01:08,500
0,420 420,960 1290,1980 1980,2520 2520,2700
both see {} locked being

1848
01:01:08,500 --> 01:01:10,240
0,630 870,990 990,1320 1320,1500 1500,1740
zero| and then they're both
|然后他们都执行了b。

1849
01:01:10,240 --> 01:01:11,480
0,360 360,690
execute b.|
|

1850
01:01:13,470 --> 01:01:14,610
0,270 270,450 450,690 690,840 840,1140
Alright, so here they see
好的，这里他们看到的是零号锁。

1851
01:01:14,610 --> 01:01:16,200
0,330 330,1110
locked zero.|
|

1852
01:01:17,020 --> 01:01:18,910
0,210 210,450 450,720 720,1020 1020,1890
This guy see locked zero.|
这家伙看到的是零号锁。|

1853
01:01:20,760 --> 01:01:21,960
0,150 150,360 360,510 510,750 750,1200
And so they both executes
因此它们都执行语句B，

1854
01:01:21,960 --> 01:01:23,490
0,210 210,570 570,960 960,1530 1530,1530
{} statement b,| both {}
|两者都已获取锁定

1855
01:01:23,490 --> 01:01:26,880
0,1170 1200,1800 1800,2310 2580,3210 3210,3390
have acquired lock| and {}
|这违反了规范，你知道这个特殊的功能。

1856
01:01:26,880 --> 01:01:29,280
0,330 330,1200 1470,1560 1560,2010 2040,2400
which violated the spec, {you,know}

1857
01:01:29,280 --> 01:01:30,680
0,150 150,480 480,870
this particular function.|
|

1858
01:01:31,670 --> 01:01:32,880
0,120 120,300 300,600
This makes sense?|
这说得通吗？|

1859
01:01:35,740 --> 01:01:36,640
0,180 180,240 240,450 450,780 780,900
So it turns out you
所以事实证明你知道要解决这个问题

1860
01:01:36,640 --> 01:01:38,740
0,90 90,600 990,1380 1380,1530 1530,2100
know to solve this problem|

1861
01:01:38,800 --> 01:01:39,340
0,150 150,330 330,390 390,510 510,540
and sort of get a
并在某种程度上得到一个正确的实现，

1862
01:01:39,340 --> 01:01:40,780
0,360 360,960 960,1050 1050,1080 1080,1440
correct implementation,| there are multiple
|有多种方式可以做到这一点，

1863
01:01:40,780 --> 01:01:41,680
0,150 150,210 210,390 390,690 690,900
ways of going about it,|
|

1864
01:01:41,980 --> 01:01:44,110
0,660 660,750 750,1380 1380,1740 1740,2130
but the most common ways
但最常见的方式基本上依赖于特殊的硬件指令。

1865
01:01:44,110 --> 01:01:45,610
0,120 120,780 780,1260 1260,1440 1440,1500
to rely basically on a

1866
01:01:45,610 --> 01:01:47,240
0,330 330,600 600,1110
special hardware instruction.|
|

1867
01:01:47,620 --> 01:01:49,420
0,570 570,810 810,1050 1050,1560 1560,1800
{} An hardware instruction that
这是一条硬件指令，基本上它所做的就是

1868
01:01:49,420 --> 01:01:51,040
0,390 390,570 570,660 660,1170 1440,1620
basically what it does| and
|然后执行此测试，然后自动设置。

1869
01:01:51,040 --> 01:01:52,690
0,240 240,510 510,1050 1290,1500 1500,1650
does this test and then

1870
01:01:52,690 --> 01:01:54,360
0,390 420,900 900,1140
set {atomically -}.|
|

1871
01:01:54,720 --> 01:01:56,020
0,720

1872
01:01:56,050 --> 01:01:58,300
0,180 180,720 840,1440 1680,2160 2160,2250
And so {} solution to
因此，解决这个问题的方法是硬件测试和SET支持。

1873
01:01:58,300 --> 01:01:59,400
0,450
this

1874
01:01:59,820 --> 01:02:02,060
0,600 630,1020 1020,1650
{} problem is

1875
01:02:03,140 --> 01:02:04,800
0,270 270,1050
{} hardware

1876
01:02:06,360 --> 01:02:07,680
0,720
test

1877
01:02:08,000 --> 01:02:09,680
0,360 360,600 600,1140
and set support.|
|

1878
01:02:16,680 --> 01:02:18,120
0,660 660,960 960,1110 1110,1260 1260,1440
{} And the way {you,can}
你可以这样想，

1879
01:02:18,120 --> 01:02:18,930
0,150 150,390 390,570 570,660 660,810
think about it,| you know
|你知道在RISC-V上，你知道这条指令实际上有原子内存操作交换，

1880
01:02:18,930 --> 01:02:20,880
0,270 270,1080 1170,1410 1410,1830 1860,1950
on the {RISC-V -}, you

1881
01:02:20,880 --> 01:02:22,440
0,90 90,270 270,720 720,1140 1260,1560
know this instruction actually there's

1882
01:02:22,440 --> 01:02:24,960
0,270 330,870 870,1230 1230,1830 1830,2520
the atomic memory operation swap,|
|

1883
01:02:26,680 --> 01:02:27,460
0,210 210,360 360,480 480,660 660,780
{} that would gonna be
会用到的东西。

1884
01:02:27,460 --> 01:02:28,620
0,510
using.|
|

1885
01:02:28,740 --> 01:02:31,170
0,720 780,1800 1800,2070 2070,2250 2250,2430
And basically boils down to
基本上归结为测试和设置，

1886
01:02:31,170 --> 01:02:33,000
0,360 360,540 540,930 960,1770 1770,1830
test and set,| basically the
|基本上是硬件保证，

1887
01:02:33,000 --> 01:02:34,950
0,300 300,420 420,1170 1410,1590 1590,1950
{hardware -} guarantees,| you will
|你们拿着这个，拿着两个论点或者[三个]论点，

1888
01:02:34,980 --> 01:02:36,990
0,450 450,660 660,960 960,1650 1680,2010
you take this, {} takes

1889
01:02:36,990 --> 01:02:38,580
0,150 150,660 660,960 960,1110 1110,1590
two arguments or [three] arguments

1890
01:02:38,580 --> 01:02:39,900
0,210 210,870
and address,|
|

1891
01:02:40,130 --> 01:02:42,560
0,750 750,870 870,1260 1260,1860 2220,2430
{} {} register one {r1
寄存器1 R1和寄存器2

1892
01:02:42,560 --> 01:02:45,830
0,540 870,1080 1080,1500 1500,2040 2460,3270
-} and register two| and
|从本质上讲，硬件所做的就是

1893
01:02:46,010 --> 01:02:47,660
0,660 660,840 840,900 900,1260 1260,1650
essentially what the hardware does,|
|

1894
01:02:47,660 --> 01:02:51,440
0,870 1050,1830 1950,2730 2940,3270 3270,3780
{} conceptually, {} is it
从概念上讲，它是否锁定了地址，如果您愿意的话。

1895
01:02:51,440 --> 01:02:53,100
0,510 510,630 630,1260
locks the address,

1896
01:02:53,500 --> 01:02:54,860
0,150 150,300 300,750
if you will.|
|

1897
01:02:54,980 --> 01:02:55,700
0,120 120,270 270,450 450,600 600,720
We'll talk about that in
我们稍后会在更多的锁定地址中讨论这一点。

1898
01:02:55,700 --> 01:02:56,660
0,30 30,300 300,510 510,630 630,960
a second little bit more

1899
01:02:56,660 --> 01:02:58,200
0,360 360,990
locks address.|
|

1900
01:02:58,200 --> 01:03:00,400
0,570 870,1650
It, um.|
它，嗯。|

1901
01:03:01,290 --> 01:03:02,370
0,150 150,360 360,480 480,540 540,1080
It puts in a temporary
它放入一个临时变量，你知道实际在那个特定地址的值。

1902
01:03:02,370 --> 01:03:03,700
0,750
variable,

1903
01:03:03,910 --> 01:03:05,650
0,180 180,330 330,510 540,1320 1470,1740
you know the value that

1904
01:03:05,650 --> 01:03:06,700
0,300 300,450 450,540 540,660 660,1050
actually is at that particular

1905
01:03:06,700 --> 01:03:07,800
0,540
address.|
|

1906
01:03:09,570 --> 01:03:11,580
0,660 690,1440
And then,
然后，将R1的值增加到地址中。

1907
01:03:13,260 --> 01:03:14,640
0,390 390,480 480,960 960,1200 1200,1380
raise the value of {r1

1908
01:03:14,640 --> 01:03:17,220
0,630 960,1350 1350,1500 1500,2070
-} into the address.|
|

1909
01:03:17,560 --> 01:03:19,450
0,150 150,630 630,1260 1290,1770 1770,1890
And then basically puts the
然后基本上将原始地址处的值放入临时值，

1910
01:03:19,450 --> 01:03:21,010
0,600 600,810 810,1020 1020,1140 1140,1560
value that was at the

1911
01:03:21,400 --> 01:03:23,900
0,600 600,1110 1110,1860
originally address into

1912
01:03:24,380 --> 01:03:27,110
0,1080 1380,1860 1860,2220 2220,2310 2310,2730
temp- temporary value,| that was
|这就是原始值实际上被寻址到R2中

1913
01:03:27,140 --> 01:03:28,670
0,180 480,870 870,1140 1140,1290 1290,1530
the original value was actually

1914
01:03:28,670 --> 01:03:29,720
0,270 270,540 540,780 780,870 870,1050
address actually into {} {r2

1915
01:03:29,720 --> 01:03:31,820
0,480 750,960 960,1050 1050,1470 1470,2100
-}| and then basically unlocks
|然后基本上解锁它返回。

1916
01:03:32,090 --> 01:03:33,300
0,210 210,810
it returns.|
|

1917
01:03:37,220 --> 01:03:39,500
0,600 900,1020 1020,1350 1350,1650 1650,2280
And you know in this
你知道在这把锁里，

1918
01:03:39,500 --> 01:03:41,240
0,390 390,630 630,750 750,1170 1200,1740
lock,| if you will guarantee
|如果你能保证基本上这个测试，

1919
01:03:41,240 --> 01:03:42,620
0,90 90,210 210,600 600,840 840,1380
is that basically this test,|
|

1920
01:03:42,740 --> 01:03:43,790
0,480 480,570 570,900 900,960 960,1050
where the result of the
其中将测试结果返回到R2

1921
01:03:43,790 --> 01:03:44,870
0,240 240,360 360,720 720,960 960,1080
test is returned into {r2

1922
01:03:44,870 --> 01:03:46,850
0,480 750,1110 1110,1200 1200,1620 1650,1980
-}| and the set actually
|而且布景实际上是原子发生的。

1923
01:03:46,850 --> 01:03:49,040
0,510 750,1500 1500,1680
happened {atomically -}.|
|

1924
01:03:49,070 --> 01:03:49,640
0,150 150,240 240,390 390,510 510,570
And so this is a
所以这是一条硬件指令，

1925
01:03:49,640 --> 01:03:51,980
0,300 300,930 960,1290 1290,1800 1800,2340
hardware instruction,| {} most processor
|大多数处理器都有这样的硬件指令。

1926
01:03:51,980 --> 01:03:53,540
0,510 510,600 600,840 840,1320 1320,1560
have an hardware instruction like

1927
01:03:53,540 --> 01:03:54,440
0,420
this.|
|

1928
01:03:54,440 --> 01:03:56,000
0,810 810,1050 1050,1290 1290,1410 1410,1560
{} {} Because it's a
因为这是一种方便的实际实现锁的方式。

1929
01:03:56,000 --> 01:03:57,800
0,540 540,900 900,1080 1080,1410 1410,1800
convenient way to actually implement

1930
01:03:57,800 --> 01:03:58,820
0,540
locks.|
|

1931
01:03:58,820 --> 01:03:59,960
0,600

1932
01:04:00,560 --> 01:04:02,630
0,630 990,1320 1320,1710 1710,1920 1920,2070
{} So basically what we've
所以基本上我们所做的是，

1933
01:04:02,630 --> 01:04:04,280
0,270 270,540 540,750 750,990 990,1650
done is,| like we've reduced
|就像我们已经降低了这个软件锁实现的原子性，

1934
01:04:04,280 --> 01:04:06,020
0,540 540,870 870,1290 1290,1380 1380,1740
the atomicity {} of this

1935
01:04:06,020 --> 01:04:09,860
0,480 1530,2370 2400,3060 3060,3750 3750,3840
{} software lock implementation,| to
|基本上是硬件锁实现。

1936
01:04:09,860 --> 01:04:12,320
0,630 660,810 810,1200 1200,1590 1590,2460
basically a hardware lock implementation.|
|

1937
01:04:13,190 --> 01:04:16,640
0,690 1020,1860 2190,2910
Um, and {}.|
嗯，还有。|

1938
01:04:16,970 --> 01:04:18,470
0,150 150,510 510,960 960,1140 1140,1500
So the processor might implement
因此处理器可能会以非常不同的方式实现这一点，

1939
01:04:18,470 --> 01:04:19,760
0,150 150,450 450,720 720,960 960,1290
this in very different ways,|
|

1940
01:04:19,790 --> 01:04:21,860
0,210 210,870 870,1290 1290,1500 1500,2070
so basically, {} the instruction
所以基本上，指令集本身，

1941
01:04:21,860 --> 01:04:23,180
0,210 210,660 660,1140 1140,1290 1290,1320
set itself,| there's like a
|好像有一份说明书，

1942
01:04:23,180 --> 01:04:24,650
0,720 720,780 780,1050 1050,1260 1260,1470
specification,| it doesn't actually say
|它实际上并没有说明它是如何实现的

1943
01:04:24,650 --> 01:04:26,060
0,180 180,300 300,810 1200,1350 1350,1410
how it's implemented| and it
|而且它非常依赖于实际的实施。

1944
01:04:26,060 --> 01:04:27,410
0,90 90,390 390,1080 1140,1200 1200,1350
is very dependent on the

1945
01:04:27,410 --> 01:04:28,940
0,270 270,990
actual implementation.|

1946
01:04:30,320 --> 01:04:32,200
0,600 600,1290
Obvious dependent
显然取决于记忆系统的确切工作方式。

1947
01:04:34,400 --> 01:04:35,900
0,390 390,690 690,900 900,1230 1230,1500
{} on {how,the} memory system

1948
01:04:35,900 --> 01:04:37,320
0,360 360,870
exactly works.|
|

1949
01:04:44,320 --> 01:04:46,870
0,300 300,360 360,930 1170,1980 1980,2550
So, for example, {} if
例如，如果您知道[]处理器共享单个内存控制器，

1950
01:04:46,870 --> 01:04:47,980
0,120 120,270 270,420 420,720 720,1110
you know the [] processor

1951
01:04:47,980 --> 01:04:49,960
0,240 270,1050 1050,1440 1440,1680 1680,1980
{} {} shared single memory

1952
01:04:49,960 --> 01:04:51,580
0,660 720,840 840,1140 1140,1380 1380,1620
controller,| {} that {read,and} writes
|对存储器进行读写操作，

1953
01:04:51,580 --> 01:04:52,810
0,90 90,540 630,900 900,960 960,1230
to memory,| then the memory
|那么存储器控制器实际上可以支持该操作，

1954
01:04:52,810 --> 01:04:54,220
0,510 510,630 630,900 900,1290 1290,1410
controller can actually support this

1955
01:04:54,220 --> 01:04:58,240
0,540 840,1470 1800,3150 3210,3570 3810,4020
operation,| basically allow you to
|基本上允许你锁定一个特定的地址，

1956
01:04:58,240 --> 01:04:59,440
0,330 330,390 390,450 450,810 810,1200
lock in a particular address,|
|

1957
01:04:59,440 --> 01:05:00,460
0,90 90,180 180,300 300,660 660,1020
you know and then let
你知道，然后让你知道一个处理器做两个操作或三条指令

1958
01:05:00,460 --> 01:05:01,630
0,90 90,210 210,510 510,1020 1020,1170
you know one processor do

1959
01:05:01,630 --> 01:05:03,280
0,210 210,900 900,1020 1020,1320 1320,1650
two operations or three {}

1960
01:05:03,280 --> 01:05:04,750
0,720 960,1080 1080,1170 1170,1380 1380,1470
instructions| and then measure will
|然后测量就会解锁

1961
01:05:04,750 --> 01:05:06,190
0,630 660,870 870,1050 1050,1230 1230,1440
unlock| and so since all
|因此，由于所有处理器的读取或写入都针对该存储器控制器，

1962
01:05:06,190 --> 01:05:08,230
0,480 570,1320 1410,1710 1710,1800 1800,2040
the processors reads or writes

1963
01:05:08,230 --> 01:05:09,310
0,180 180,270 270,420 420,690 690,1080
go for this memory controller,|
|

1964
01:05:09,310 --> 01:05:10,390
0,60 60,300 300,720 720,930 930,1080
the memory controller into the
将内存控制器设置为锁定的顺序。

1965
01:05:10,390 --> 01:05:11,800
0,450 570,660 660,1080
ordering of locking.|
|

1966
01:05:12,290 --> 01:05:15,230
0,360 360,1020 1020,1500 2010,2490 2490,2940
{} If the {} memories
如果该处理器中的存储器位于共享总线上，

1967
01:05:15,230 --> 01:05:16,280
0,360 360,450 450,600 600,990 990,1050
are in this processor are

1968
01:05:16,280 --> 01:05:17,840
0,270 270,360 360,450 450,1020 1020,1560
sitting on a shared bus,|
|

1969
01:05:18,110 --> 01:05:19,580
0,720 720,960 960,1140 1140,1230 1230,1470
{} it's often the bus
通常是总线仲裁器，

1970
01:05:19,580 --> 01:05:21,050
0,630 690,990 990,1110 1110,1350 1350,1470
arbiter,| that can actually do
|才能真正做到这一点，

1971
01:05:21,050 --> 01:05:22,190
0,210 210,420 420,600 600,990 990,1140
that,| where bus arbiter has
|其中总线仲裁器支持基本上以原子方式执行对存储器的操作。

1972
01:05:22,190 --> 01:05:24,560
0,540 540,900 900,1260 1260,1770 1770,2370
support for basically executing to

1973
01:05:24,980 --> 01:05:27,170
0,900 900,1560 1560,1740 1740,1830 1830,2190
memory operations in an atomic

1974
01:05:27,170 --> 01:05:27,940
0,330
way.|
|

1975
01:05:28,340 --> 01:05:30,500
0,450 450,990 990,1140 1140,1680 1950,2160
{} If it's, {} if
如果是，如果处理器有[缓存]，

1976
01:05:30,500 --> 01:05:32,990
0,90 90,450 450,840 840,1560 1950,2490
the processor have [caches] {},|
|

1977
01:05:32,990 --> 01:05:34,610
0,780 810,1080 1080,1290 1290,1440 1440,1620
then, {} it's sort of
然后，它通常是高速缓存一致性协议的一部分，

1978
01:05:34,670 --> 01:05:35,540
0,330 330,510 510,570 570,660 660,870
typically part of the cache

1979
01:05:35,540 --> 01:05:38,750
0,300 300,690 690,1230 1500,2250 2850,3210
coherence protocol,| where {} cache
|其中高速缓存一致性协议将确保

1980
01:05:38,750 --> 01:05:40,460
0,270 270,810 810,1140 1140,1530 1530,1710
coherence protocol will ensure that|
|

1981
01:05:40,460 --> 01:05:41,510
0,210 210,390 390,450 450,900 900,1050
if there's a writer,| you
如果有作家的话，|您知道，保存我们要更新值的特定缓存线，

1982
01:05:41,510 --> 01:05:43,880
0,120 120,390 390,870 870,1440 1740,2370
know that that particular a

1983
01:05:44,780 --> 01:05:46,820
0,450 450,630 630,720 720,1200 1200,2040
cache line that holds a

1984
01:05:46,850 --> 01:05:48,350
0,720 720,900 900,1050 1050,1110 1110,1500
value we want to update,|
|

1985
01:05:48,350 --> 01:05:49,520
0,180 180,300 300,450 480,840 840,1170
ends up in one single
最终在一个单独的高速缓存中结束。

1986
01:05:49,520 --> 01:05:50,460
0,630
cache.|
|

1987
01:05:50,580 --> 01:05:52,530
0,180 180,660 780,1350 1350,1440 1440,1950
And then basically the {processor,is}
然后，处理器基本上锁定了操作的单个高速缓存线。

1988
01:05:52,530 --> 01:05:53,790
0,120 120,360 360,780 810,990 990,1260
kind of lock that single

1989
01:05:53,790 --> 01:05:56,850
0,330 330,600 600,1080 1080,1740 1740,3060
cache line across to operations.|
|

1990
01:05:57,330 --> 01:05:59,070
0,180 180,840 840,1320 1320,1410 1410,1740
So the implementation of this,
所以这个的实施，你知道可以用很多不同的方式来完成，

1991
01:05:59,070 --> 01:05:59,850
0,150 150,390 390,510 510,570 570,780
you know can be done

1992
01:05:59,850 --> 01:06:01,500
0,60 60,270 270,540 540,1020 1080,1650
in many different ways {},|
|

1993
01:06:01,500 --> 01:06:03,570
0,210 210,990 1050,1470 1470,1860 1860,2070
but conceptually the, {} what's
但从概念上讲，到底是怎么回事，

1994
01:06:03,570 --> 01:06:04,350
0,180 180,390 390,540 540,720 720,780
going on,| it's like you
|就像你锁上了地址，

1995
01:06:04,350 --> 01:06:06,030
0,270 270,330 330,870 1170,1560 1560,1680
lock the address,| {} you
|您读取您的原始值，存储在新值中，然后返回您的值。

1996
01:06:06,030 --> 01:06:08,190
0,420 420,540 540,840 840,1410 1740,2160
read your original value, you

1997
01:06:08,340 --> 01:06:09,660
0,360 360,540 540,630 630,810 810,1320
store in the new value

1998
01:06:09,660 --> 01:06:11,240
0,180 180,570 570,780 780,1110
and return your value.|
|

1999
01:06:12,360 --> 01:06:13,620
0,120 120,210 210,330 330,690
Does that make sense?|
这说得通吗？|

2000
01:06:15,820 --> 01:06:17,500
0,570 960,1290 1290,1440 1440,1560 1560,1680
To see how we can
看看我们如何使用这条指令，

2001
01:06:17,500 --> 01:06:19,810
0,240 240,420 420,1080 1740,2070 2070,2310
use that instruction,| {} let's
|让我们实际看看xv6中获取和发布的实现

2002
01:06:19,810 --> 01:06:21,130
0,210 210,390 390,510 510,630 630,1320
actually look at the implementation

2003
01:06:21,130 --> 01:06:24,220
0,450 450,1260 1290,2040 2040,2460 2460,3090
of {} acquiring {and,release} in

2004
01:06:24,250 --> 01:06:25,570
0,240 240,360 360,810 1050,1260 1260,1320
{xv6 - -}| and it
|它还将揭露一些其他有趣的细节。

2005
01:06:25,570 --> 01:06:26,380
0,120 120,450 450,480 480,750 750,810
will expose a couple of

2006
01:06:26,380 --> 01:06:27,900
0,240 240,570 570,1080
other interesting details.|
|

2007
01:06:29,300 --> 01:06:30,420
0,600

2008
01:06:31,800 --> 01:06:33,330
0,180 180,360 360,510 510,840 840,1530
So let me first {}
让我先来介绍一下Spinlock。h，

2009
01:06:33,360 --> 01:06:34,350
0,270 270,420 420,660 660,900 900,990
bring up {spinlock.h - -

2010
01:06:34,350 --> 01:06:36,750
0,600 630,1470 1920,1980 1980,2190 2190,2400
-},| {} it's {spinlock.h -
|它是旋锁的.h，如你所见，它非常简单，

2011
01:06:36,750 --> 01:06:37,920
0,120 120,660 690,990 990,1080 1080,1170
- -}, as you can

2012
01:06:37,920 --> 01:06:38,960
0,480
see,

2013
01:06:39,220 --> 01:06:42,010
0,180 180,420 420,1350 1380,2160 2610,2790
it's pretty straightforward,| {} it
|它有这个[扁平]锁，和我们的伪代码一模一样

2014
01:06:42,010 --> 01:06:43,900
0,270 270,420 420,990 990,1380 1380,1890
has this [flat] lock, exactly

2015
01:06:43,900 --> 01:06:45,160
0,120 120,300 300,480 510,780 780,1260
as in our pseudo code|
|

2016
01:06:45,460 --> 01:06:46,450
0,120 120,240 240,480 480,780 780,990
and then there's two other
然后还有另外两件事需要调试，

2017
01:06:46,450 --> 01:06:47,770
0,210 210,330 330,870 870,1200 1200,1320
things for debugging,| namely the
|即锁的名称

2018
01:06:47,770 --> 01:06:49,510
0,240 240,330 330,450 450,930 1020,1740
name of the lock| and
|和CPU，最后一个，当前实际持有锁的CPU。

2019
01:06:49,510 --> 01:06:51,480
0,300 300,900 900,990 990,1560
the CPU, the last,

2020
01:06:51,480 --> 01:06:52,650
0,90 90,450 450,780 780,900 900,1170
the current CPU that actually

2021
01:06:52,650 --> 01:06:54,020
0,360 360,450 450,840
holding the lock.|
|

2022
01:06:54,170 --> 01:06:55,220
0,390 390,540 540,660 660,750 750,1050
{} And this is mostly
而这主要是打印出调试消息，

2023
01:06:55,220 --> 01:06:56,120
0,120 120,360 360,570 570,630 630,900
to print out the debugging

2024
01:06:56,120 --> 01:06:57,560
0,510 510,630 630,1020 1020,1140 1140,1440
messages,| for example you do
例如，您这样做是为了获得一些相同的CPU。

2025
01:06:57,560 --> 01:06:59,030
0,390 390,1230 1230,1320 1320,1380 1380,1470
to acquire some of the

2026
01:06:59,030 --> 01:07:00,220
0,210 210,660
same CPU.|
|

2027
01:07:01,450 --> 01:07:02,680
0,240 240,480 480,660 660,990 990,1230
{} Okay, so then let's
好的，那么让我们来看看它的实现。

2028
01:07:02,680 --> 01:07:04,420
0,180 180,420 630,1200
look at {}

2029
01:07:05,970 --> 01:07:07,760
0,180 180,1260
the implementation.|
|

2030
01:07:12,020 --> 01:07:13,550
0,690 690,960 960,1080 1080,1260 1260,1530
{} And so let's start
那么让我们从Acquisition开始吧。

2031
01:07:13,550 --> 01:07:15,140
0,180 180,330 330,360 360,1080
out with {acquire -}.|
|

2032
01:07:15,140 --> 01:07:17,330
0,720 1050,1560 1560,1740 1740,2010 2010,2190
{} And let's first look
让我们先来看看这个循环，

2033
01:07:17,330 --> 01:07:19,160
0,90 90,630 660,1290
at this loop,|
|

2034
01:07:19,540 --> 01:07:21,160
0,240 240,420 420,570 570,1080 1080,1620
so this is actually {}
所以这实际上是一种测试和设置循环，

2035
01:07:21,160 --> 01:07:23,020
0,0 810,1230 1230,1440 1440,1530 1530,1860
{} the sort of {test,and}

2036
01:07:23,020 --> 01:07:24,220
0,240 240,510 510,690 690,1020 1020,1200
set loop,| that I just
|就是我刚才谈到的，

2037
01:07:24,220 --> 01:07:25,930
0,270 270,660 930,1260 1260,1500 1500,1710
talked about,| it turns out
|事实证明，在C标准中，

2038
01:07:25,930 --> 01:07:28,120
0,240 240,870 1020,1620
that in {}

2039
01:07:28,360 --> 01:07:30,640
0,930 990,1440 1440,1560 1560,1740 1740,2280
{} {} the C standard,|
|

2040
01:07:30,670 --> 01:07:33,190
0,390 390,1170 1200,2040 2130,2460 2460,2520
actually defines {} one of
实际上定义了这些原子操作之一

2041
01:07:33,190 --> 01:07:35,290
0,150 150,510 510,1200 1230,1740 1740,2100
these atomic operations| and so
|所以C标准实际上有一个功能，

2042
01:07:35,620 --> 01:07:37,930
0,510 1320,1740 1740,1980 1980,2220 2220,2310
C standard actually has a

2043
01:07:37,930 --> 01:07:40,060
0,420 420,960 1260,1530 1530,2040 2040,2130
function,| that {} says you
|也就是说您知道__sync_lock_test_and_set

2044
01:07:40,060 --> 01:07:41,800
0,120 120,450 450,960 990,1650 1650,1740
know {__sync_lock_test_and_set - - -

2045
01:07:41,800 --> 01:07:43,150
0,270 270,390 390,780 780,1290 1290,1350
-}| and basically specifies the
|基本上指定了我刚才描述的行为。

2046
01:07:43,150 --> 01:07:45,130
0,600 600,780 780,1200 1200,1410 1410,1980
behavior that I just described.|
|

2047
01:07:45,700 --> 01:07:47,080
0,180 180,300 300,510 510,1020 1020,1380
And then every processor basically
然后每个处理器基本上都需要实现该行为

2048
01:07:47,080 --> 01:07:50,740
0,750 780,1080 1080,1770 1770,2550 2790,3660
required to implement that behavior|
|

2049
01:07:50,860 --> 01:07:52,360
0,270 270,450 450,660 660,1140 1140,1500
and since most processors have
并且由于大多数处理器具有测试和设置硬件指令的AND匹配，

2050
01:07:52,360 --> 01:07:54,190
0,330 360,1080 1170,1290 1290,1560 1560,1830
and matching of {test,and} set

2051
01:07:54,190 --> 01:07:56,020
0,330 330,990 1230,1440 1440,1560 1560,1830
hardware instruction,| {} this turns
|事实证明，这是(流程)要实现的一个合理而直接的方案，

2052
01:07:56,020 --> 01:07:56,710
0,150 150,210 210,300 300,360 360,690
out to be a reasonable

2053
01:07:56,710 --> 01:07:58,060
0,690 690,870 870,960 960,1290 1290,1350
straightforward for the [process] to

2054
01:07:58,060 --> 01:07:59,260
0,510 540,750 750,900 900,960 960,1200
implement,| then so in fact
|那么事实上，如果我们看看kernel.asm，

2055
01:07:59,260 --> 01:08:00,640
0,90 90,210 210,540 870,1110 1110,1380
if we look at {kernel.asm

2056
01:08:00,640 --> 01:08:01,990
0,180 180,780 780,1080 1080,1200 1200,1350
- -},| we can look
|我们可以查看汇编指令，了解RISC-V处理器的确切功能。

2057
01:08:01,990 --> 01:08:03,400
0,60 60,150 150,600 600,1290 1290,1410
at the assembly instructions and

2058
01:08:03,400 --> 01:08:04,780
0,150 150,810 810,1080 1080,1140 1140,1380
see exactly what the {RISC-V

2059
01:08:04,780 --> 01:08:06,360
0,210 210,690 690,1200
-} processor does.|
|

2060
01:08:08,000 --> 01:08:09,860
0,420 420,1320
Um, so.|
嗯，那么。|

2061
01:08:11,200 --> 01:08:12,970
0,210 210,540 540,750 750,1380 1380,1770
But here is our assembly
但这是我们的装配结构

2062
01:08:12,970 --> 01:08:16,360
0,390 390,1260 1590,2730 2730,2970 2970,3390
structures acquire| and let's here's
|下面是我们的原子交换指令。

2063
01:08:16,360 --> 01:08:17,520
0,600
our

2064
01:08:17,800 --> 01:08:19,960
0,570 570,960 960,1590
atomic swap instruction.|
|

2065
01:08:27,830 --> 01:08:29,240
0,360 360,510 510,630 630,750 750,1410
{} So you can see,|
所以你可以看到，|

2066
01:08:29,270 --> 01:08:30,800
0,990

2067
01:08:30,800 --> 01:08:32,630
0,780 810,930 930,1080 1080,1560 1560,1830
if you know atomic swap,
如果您知道原子交换，基本上称为寄存器a5。

2068
01:08:32,630 --> 01:08:34,880
0,630 630,1050 1050,1470 1560,2100 2100,2250
basically {} called register {a5

2069
01:08:34,880 --> 01:08:38,090
0,360 360,1890 2130,2250 2250,2610 2610,3210
-}| and the input and
|并且输入和输出也以5结束。

2070
01:08:38,090 --> 01:08:39,140
0,300 300,570 570,810 810,960 960,1050
output also ends up in

2071
01:08:39,140 --> 01:08:40,820
0,150 150,630 1020,1320 1320,1470 1470,1680
{a5 -}| and as long
|而且只要把整件事寄到地址

2072
01:08:40,820 --> 01:08:41,270
0,90 90,150 150,300 300,360 360,450
as the whole to the

2073
01:08:41,270 --> 01:08:45,230
0,660 930,1950 1980,2940 2940,3540 3540,3960
address| and {} if it's
|如果不相等，我们就返回

2074
01:08:45,260 --> 01:08:46,600
0,300 300,900
not equal,

2075
01:08:46,630 --> 01:08:50,200
0,1470 1500,2250 2280,2430 2430,3090 3090,3570
we return| and otherwise basically
|否则我们基本上会回到，跳回到，

2076
01:08:50,200 --> 01:08:52,030
0,150 150,270 270,780 930,1410 1410,1830
we go back to {},

2077
01:08:52,420 --> 01:08:54,640
0,330 360,720 720,1200 1320,1830 1830,2220
{} jump back to {},|
|

2078
01:08:55,060 --> 01:08:56,160
0,570

2079
01:08:57,170 --> 01:08:58,010
0,270 270,510 510,600 600,780 780,840
double check I'm saying the
再检查一遍我说的是对的，移动A4[6]，

2080
01:08:58,010 --> 01:09:00,230
0,180 180,360 360,810 1170,1890 1890,2220
right thing here, move {a4

2081
01:09:00,230 --> 01:09:01,780
0,960
in}

2082
01:09:01,940 --> 01:09:03,500
0,420 420,660 660,960 960,1320 1320,1560
[six],| if not equal to
|如果不等于0x20加22。

2083
01:09:03,500 --> 01:09:06,110
0,300 300,690 690,1500 1650,2040 2220,2610
{0x -} twenty plus {22

2084
01:09:06,110 --> 01:09:07,200
0,510
-}.|
|

2085
01:09:07,260 --> 01:09:08,220
0,390 390,600 600,720 720,780 780,960
{} Alright, that's a little
好吧，这有点难计算，

2086
01:09:08,220 --> 01:09:10,140
0,150 150,210 210,810 810,1560 1560,1920
hard to calculate,| but basically
|但基本上在一个案例中，我们扩展到

2087
01:09:10,140 --> 01:09:10,980
0,60 60,180 180,390 390,510 510,840
in one case, we branch

2088
01:09:10,980 --> 01:09:11,970
0,420 510,660 660,750 750,840 840,990
out| and in the other
|在另一种情况下，我们向后分支。

2089
01:09:11,970 --> 01:09:13,600
0,240 240,390 390,660 660,1110
case, we branch back.|
|

2090
01:09:14,270 --> 01:09:15,200
0,210 210,360 360,510 510,630 630,930
So this may be easier
所以这可能更容易看C代码。

2091
01:09:15,200 --> 01:09:16,280
0,300 300,510 510,630 630,870 870,1080
to look at the C

2092
01:09:16,280 --> 01:09:17,300
0,450
code.|
|

2093
01:09:19,580 --> 01:09:20,570
0,150 150,330 330,480 480,810 810,990
So let's go away in
所以让我们离开这里，

2094
01:09:20,570 --> 01:09:22,190
0,270 270,390 390,570 570,1230 1410,1620
here,| so what happens, so
|那么会发生什么呢，所以如果锁没有被持有，

2095
01:09:22,190 --> 01:09:23,270
0,210 210,570 600,780 780,840 840,1080
if the if the lock

2096
01:09:23,270 --> 01:09:25,140
0,360 390,810 810,1320
is not held,|
|

2097
01:09:25,140 --> 01:09:26,160
0,240 240,510 510,720 720,930 930,1020
{} what will be the
l锁的值是多少，

2098
01:09:26,160 --> 01:09:27,600
0,330 330,450 450,630 630,930 930,1440
value of l lock,| well
|嗯，锁定将是零对的。

2099
01:09:27,600 --> 01:09:29,540
0,30 30,360 360,930 1230,1740
lock {will,be} zero right.|
|

2100
01:09:30,180 --> 01:09:31,170
0,240 240,540 540,660 660,840 840,990
And so we call this
所以我们称之为测试和设置，

2101
01:09:31,170 --> 01:09:32,940
0,270 270,750 930,1260 1260,1410 1410,1770
{test,and} set,| what will happen
|将会发生的是，我们将在锁中写一个，返回先前的值。

2102
01:09:32,940 --> 01:09:34,770
0,180 180,360 360,570 570,1230 1380,1830
is we'll write one {}

2103
01:09:34,770 --> 01:09:37,350
0,210 210,690 1560,2190 2190,2280 2280,2580
in lock, return the previous

2104
01:09:37,350 --> 01:09:38,340
0,480
value.|
|

2105
01:09:38,620 --> 01:09:39,820
0,150 150,270 270,360 360,630 630,1200
So if the previous value
所以如果之前的值是零，

2106
01:09:39,820 --> 01:09:42,760
0,210 210,870 1320,1890 1920,2550 2730,2940
is zero,| {} then we're
|那我们就很好了，对吧

2107
01:09:42,760 --> 01:09:43,960
0,360 390,630 630,840 840,990 990,1200
good right,| because that means
|因为这意味着没有人拿着锁

2108
01:09:43,960 --> 01:09:44,950
0,150 150,450 450,600 600,900 900,990
that nobody was holding the

2109
01:09:44,950 --> 01:09:46,450
0,450 450,630 630,810 810,1080 1080,1500
lock| and we fall through
|我们失败了，我们就结束了这个WHILE循环。

2110
01:09:46,450 --> 01:09:47,080
0,120 120,210 210,390 390,510 510,630
and we're done with this

2111
01:09:47,080 --> 01:09:48,100
0,300 300,600
while loop.|
|

2112
01:09:49,740 --> 01:09:50,700
0,150 150,330 330,510 510,690 690,960
Now, let's say the lock
现在，假设锁值为1，

2113
01:09:50,700 --> 01:09:52,590
0,360 360,510 510,960 1140,1530 1560,1890
value was one,| so probably
所以很可能是锁[动作]锁，

2114
01:09:52,590 --> 01:09:55,560
0,1140 1170,1680 1680,1950 1950,2400 2760,2970
the lock [action] lock,| well,
|嗯，这条指令行吗，

2115
01:09:55,560 --> 01:09:57,420
0,270 270,480 480,870 870,1380 1470,1860
will this instruction do,| it
|它会，读取旧值，把它放在正确的一边，

2116
01:09:57,420 --> 01:09:59,340
0,540 600,1410
will {},

2117
01:09:59,340 --> 01:10:01,110
0,480 510,780 780,1020 1020,1500 1500,1770
read the old value, put

2118
01:10:01,110 --> 01:10:03,120
0,180 180,780 780,1020 1020,1380 1380,2010
that {in,the,side} correct,| there's one
|这个箱子里有一个

2119
01:10:03,120 --> 01:10:04,290
0,180 180,360 360,480 480,900 990,1170
{} in this case| and
|然后在那个位置写一个新的。

2120
01:10:04,290 --> 01:10:05,940
0,180 180,510 510,930 990,1260 1260,1650
then write a new one

2121
01:10:05,940 --> 01:10:07,620
0,330 330,540 540,1170
into that location.|
|

2122
01:10:07,790 --> 01:10:09,680
0,780 780,1230 1230,1440 1440,1590 1590,1890
{} And that will change
这不会改变任何事情

2123
01:10:09,680 --> 01:10:11,480
0,480 510,810 810,1020 1020,1110 1110,1800
nothing right,| because it was
|因为它已经被锁上了。

2124
01:10:11,480 --> 01:10:12,780
0,300 300,780
already locked.|
|

2125
01:10:12,810 --> 01:10:14,160
0,540 540,750 750,840 840,1170 1170,1350
And and the function will
函数将返回1，

2126
01:10:14,160 --> 01:10:16,260
0,270 270,720 1050,1740 1740,1890 1890,2100
return one,| indicating that actually
|这表明实际上之前的一些搁置，

2127
01:10:16,260 --> 01:10:17,370
0,240 240,360 360,450 450,750 750,1110
some of the previous hold,|
|

2128
01:10:17,370 --> 01:10:18,810
0,210 210,510 510,720 720,1020 1020,1440
that it was already locked|
它已经被锁上了|

2129
01:10:18,840 --> 01:10:19,860
0,120 120,300 300,360 360,540 540,1020
and so in that case
所以在这种情况下不等于零

2130
01:10:19,920 --> 01:10:21,630
0,210 240,720 720,810 810,1440 1560,1710
is unequal to zero| and
|它会旋转，会一直旋转，直到锁定时才真正恢复到零，

2131
01:10:21,630 --> 01:10:22,890
0,90 90,240 240,750 870,1080 1080,1260
it will spin, will keep

2132
01:10:22,890 --> 01:10:25,170
0,600 690,990 990,1530 1530,1890 1890,2280
spinning {until -} locked actually

2133
01:10:25,170 --> 01:10:28,140
0,240 240,750 1020,1560 1920,2430 2460,2970
set back to {} zero,|
|

2134
01:10:28,590 --> 01:10:29,760
0,420 420,660 660,990 990,1080 1080,1170
[] [level] happened in this
[][级别]在此版本中发生。

2135
01:10:29,760 --> 01:10:30,780
0,510
release.|
|

2136
01:10:32,500 --> 01:10:34,040
0,180 180,480 480,690 690,930
Any questions about this?|
对此有什么问题吗？|

2137
01:10:51,200 --> 01:10:52,540
0,300 300,780
No questions.|
没有问题了。|

2138
01:10:52,810 --> 01:10:54,720
0,450 750,1380
Okay {}.|
好吧。|

2139
01:10:56,070 --> 01:10:57,240
0,180 180,360 360,960 960,1050 1050,1170
So now basically you know
所以现在基本上你知道，让我们看看相应的释放操作，

2140
01:10:57,240 --> 01:10:58,620
0,150 150,300 300,390 390,630 660,1380
let's look at the corresponding

2141
01:10:58,680 --> 01:11:00,080
0,840
{}

2142
01:11:00,170 --> 01:11:01,960
0,240 240,480 480,1260
the release operation,|
|

2143
01:11:01,990 --> 01:11:03,560
0,930
And.|
和。|

2144
01:11:03,560 --> 01:11:04,980
0,840

2145
01:11:07,540 --> 01:11:10,390
0,900 930,1470 1470,1860 1890,2160 2160,2850
And here's {} release operation,|
这是释放行动，|

2146
01:11:10,690 --> 01:11:11,920
0,420 420,510 510,810 810,1140 1140,1230
and if you look at
如果你再看一下内核.asm。

2147
01:11:11,920 --> 01:11:14,140
0,150 150,510 510,1080 1110,1650
the {kernel.asm -} again.|
|

2148
01:11:15,960 --> 01:11:18,420
0,330 330,1200 1290,1710 1710,2160 2160,2460
That instruction,| {} so lets
那个指令，|所以让我们看看释放，可能就在这里释放之后。

2149
01:11:18,420 --> 01:11:19,560
0,150 150,330 330,600 600,900 900,1140
look at release, probably right

2150
01:11:19,560 --> 01:11:21,440
0,390 390,660 660,1380
after, here release.|
|

2151
01:11:22,220 --> 01:11:23,390
0,210 210,330 330,630 630,900 900,1170
So the release actually also
所以这个版本实际上也使用了这个原子交换指令。

2152
01:11:23,390 --> 01:11:25,700
0,450 450,660 660,1110 1110,1620 1650,2310
uses this atomic swap instruction.|
|

2153
01:11:26,680 --> 01:11:27,960
0,720

2154
01:11:27,960 --> 01:11:30,000
0,360 360,600 600,960 960,1590 1620,2040
And putting basically zero into
然后把基本为0的值放入S1。

2155
01:11:30,000 --> 01:11:31,080
0,150 150,510
{s1 -}.|
|

2156
01:11:33,520 --> 01:11:35,290
0,240 240,810 1020,1230 1230,1680 1680,1770
And so this guarantee is
所以这个保证基本上就是这个原子更新，

2157
01:11:35,290 --> 01:11:37,180
0,450 450,660 660,840 840,1320 1320,1890
basically that this atomic update,|
|

2158
01:11:37,180 --> 01:11:39,280
0,90 90,210 210,630 630,1380 1410,2100
you know to l locked
你知道l锁定或lk->锁定，

2159
01:11:39,280 --> 01:11:42,040
0,150 150,210 210,810 1080,2070 2100,2760
or {lk->locked -},| {} writing
|使用原子操作将零写入lk->锁定。

2160
01:11:42,040 --> 01:11:43,630
0,450 450,720 720,870 870,1410 1410,1590
zero into {lk->locked -} using

2161
01:11:43,630 --> 01:11:45,020
0,60 60,390 390,900
{} atomic operation.|
|

2162
01:11:46,080 --> 01:11:47,790
0,450 450,540 540,750 750,1200 1200,1710
Many of you ask why
你们中的许多人会问，为什么不直接使用存储，存储指令来写零呢？

2163
01:11:47,790 --> 01:11:49,800
0,180 180,510 510,960 960,1440
not just use store,

2164
01:11:49,800 --> 01:11:50,880
0,60 60,330 330,720 720,870 870,1080
{} store instruction to actually

2165
01:11:50,880 --> 01:11:52,140
0,240 240,720
write zero.|
|

2166
01:11:52,510 --> 01:11:53,900
0,900

2167
01:11:53,990 --> 01:11:55,440
0,930
Anybody,
有没有人，你能猜猜为什么，为什么那可能行不通吗？

2168
01:11:55,500 --> 01:11:56,130
0,150 150,210 210,330 330,390 390,630
may you want to guess

2169
01:11:56,130 --> 01:11:57,460
0,780
why,

2170
01:11:58,310 --> 01:11:59,390
0,270 270,450 450,480 480,780 780,1080
why that might not work|
|

2171
01:11:59,390 --> 01:12:00,620
0,420 600,720 720,810 810,1080 1080,1230
or what the problem could
或者问题可能是什么。

2172
01:12:00,620 --> 01:12:01,480
0,330
be.|
|

2173
01:12:02,380 --> 01:12:04,240
0,360 360,840 870,1140 1140,1440 1440,1860
Because then some other process
因为然后某个其他进程可能正在将一个写入锁，或者，不，

2174
01:12:04,240 --> 01:12:05,440
0,210 210,300 300,690 690,1080 1080,1200
might be writing one to

2175
01:12:05,440 --> 01:12:07,420
0,120 120,540 540,900 1380,1740
the lock or, no,|
|

2176
01:12:07,760 --> 01:12:09,470
0,270 270,660 660,930 930,1440 1470,1710
or writing another zero but
或者再写一个零，但不可能是这样的，对吧。

2177
01:12:09,470 --> 01:12:10,340
0,180 180,360 360,480 480,570 570,870
that can't be the case,

2178
01:12:10,340 --> 01:12:11,200
0,270
right.|
|

2179
01:12:11,320 --> 01:12:12,340
0,270 270,510 510,630 630,810 810,1020
Yeah, well there could be
是啊，可能会没事的，

2180
01:12:12,340 --> 01:12:12,970
0,150 150,240 240,360 360,510 510,630
okay,| so there could be
|因此可能有两个进程或两个CPU同时写入l锁，

2181
01:12:12,970 --> 01:12:14,320
0,210 210,900 900,1020 1020,1140 1140,1350
two processes or two {CPUs

2182
01:12:14,320 --> 01:12:15,550
0,240 240,660 660,780 780,960 960,1230
-} writing to l lock

2183
01:12:15,550 --> 01:12:16,690
0,90 90,180 180,390 390,750 780,1140
at the same time right,|
|

2184
01:12:17,170 --> 01:12:19,090
0,750 840,1050 1050,1110 1110,1380 1380,1920
{} but I think what
但我认为真正的问题是，

2185
01:12:19,090 --> 01:12:20,380
0,210 210,480 480,840 840,1020 1020,1290
the question really is that,|
|

2186
01:12:20,380 --> 01:12:21,550
0,120 120,330 330,480 480,720 720,1170
you know, for many people
你知道，对很多人来说，我也经常这么想，

2187
01:12:21,550 --> 01:12:22,810
0,360 360,570 570,870 870,1110 1110,1260
and I often assume this

2188
01:12:22,810 --> 01:12:24,100
0,420 540,750 750,960 960,1110 1110,1290
too,| is that you're going
|就是你要做一条存储指令，

2189
01:12:24,100 --> 01:12:25,030
0,60 60,180 180,270 270,570 570,930
to do a single store

2190
01:12:25,030 --> 01:12:25,870
0,420 420,540 540,630 630,780 780,840
instruction,| that is sort of
|这有点像原子操作。

2191
01:12:25,870 --> 01:12:27,540
0,150 150,210 210,600 600,1200
like an atomic operation.|
|

2192
01:12:28,250 --> 01:12:30,110
0,600 840,1050 1050,1200 1200,1500 1500,1860
{} {} There's not always
并不总是这样的，例如，如果你是

2193
01:12:30,110 --> 01:12:31,760
0,90 90,690 720,960 960,1500 1500,1650
the case, for example if

2194
01:12:31,760 --> 01:12:33,350
0,540 750,780 810,1350 1350,1470 1470,1590
you are {}| and it
|这真的取决于架构的实现，

2195
01:12:33,350 --> 01:12:34,850
0,180 180,540 540,780 780,990 990,1500
really depends on the architecture

2196
01:12:34,850 --> 01:12:36,800
0,660 690,960 960,1020 1020,1440 1440,1950
implementation,| like for example if
|例如如果CACHE[]协议工作或高速缓存系统使用高速缓存线工作，

2197
01:12:36,800 --> 01:12:38,420
0,90 90,600 600,1080 1080,1440 1440,1620
the {cache,[]} protocol works or

2198
01:12:38,420 --> 01:12:39,560
0,30 30,330 330,660 660,870 870,1140
{} cache system works using

2199
01:12:39,560 --> 01:12:40,790
0,330 330,600 600,780 780,1020 1020,1230
cache lines,| where cache line
|其中高速缓存线可以大于整数，

2200
01:12:40,790 --> 01:12:41,820
0,540
maybe

2201
01:12:41,820 --> 01:12:43,350
0,150 150,390 390,630 630,1470 1470,1530
{} bigger than integer,| are
通常大于整数，

2202
01:12:43,350 --> 01:12:45,750
0,330 330,540 540,720 720,1260 1620,2400
typically bigger than integer {},|
|

2203
01:12:45,750 --> 01:12:46,860
0,180 180,360 360,570 570,930 930,1110
then really what's happening is,|
那么真正发生的是，|

2204
01:12:46,860 --> 01:12:48,060
0,210 210,300 300,570 570,1050 1050,1200
that the first operation is
第一个操作是加载高速缓存线，

2205
01:12:48,060 --> 01:12:49,200
0,360 360,450 450,750 750,1050 1050,1140
loading the cache line,| and
|然后更新高速缓存线，

2206
01:12:49,200 --> 01:12:50,460
0,150 150,630 630,690 690,990 990,1260
then updating the cache line,|
|

2207
01:12:50,790 --> 01:12:51,540
0,180 180,240 240,570 570,660 660,750
so in fact you know
所以实际上你知道存储指令，基本上里面有两个微操作

2208
01:12:51,540 --> 01:12:52,920
0,90 90,330 330,810 810,1110 1110,1380
{} store instruction, basically has

2209
01:12:52,950 --> 01:12:54,510
0,210 210,630 630,1200 1200,1320 1320,1560
two micro operations in it|
|

2210
01:12:54,690 --> 01:12:56,880
0,780 1380,1830 1830,1950 1950,2100 2100,2190
and you can get the
你可能会得到错误的结果。

2211
01:12:56,880 --> 01:12:57,940
0,180 180,660
wrong result.|
|

2212
01:12:58,990 --> 01:13:02,110
0,480 720,1260 1290,2310 2400,2550 2550,3120
{} So, {} you know
因此，您知道，为了避免必须了解任何硬件实现，

2213
01:13:02,530 --> 01:13:04,030
0,270 270,810 810,900 900,1260 1290,1500
to avoid you know having

2214
01:13:04,030 --> 01:13:05,050
0,90 90,420 420,810 810,930 930,1020
to understand anything of the

2215
01:13:05,050 --> 01:13:06,610
0,300 300,840 840,930 930,1440 1440,1560
hardware implementation,| of exactly and
|以及整数运算是否是原子的

2216
01:13:06,610 --> 01:13:08,380
0,300 300,750 750,1260 1260,1380 1380,1770
whether integer operations are atomic

2217
01:13:08,380 --> 01:13:09,730
0,90 90,480 510,840 840,1170 1170,1350
or not| or writing to
|或者向64位64位存储器值写入原子操作，

2218
01:13:09,730 --> 01:13:12,440
0,540 540,840 1050,1770 1860,2220
64 bit 64 {}

2219
01:13:12,440 --> 01:13:14,060
0,240 240,810 810,1230 1230,1290 1290,1620
bit memory values an atomic

2220
01:13:14,060 --> 01:13:15,530
0,660 810,930 930,1020 1020,1170 1170,1470
operation,| you know we use
|你知道我们使用的是RISC-V行动

2221
01:13:15,530 --> 01:13:18,740
0,420 690,1590 1590,2220 2250,2640 2640,3210
the {} {} {RISC-V -}

2222
01:13:19,070 --> 01:13:20,450
0,480 480,630 630,780 780,1320 1320,1380
operation,| that is guaranteed to
|它可以保证自动执行。

2223
01:13:20,450 --> 01:13:22,060
0,120 120,540 540,930 930,1110
be executed {atomically -}.|
|

2224
01:13:25,020 --> 01:13:26,340
0,120 120,240 240,390 390,750
Does that make sense?|
这说得通吗？|

2225
01:13:28,100 --> 01:13:29,160
0,540
Yes.|
是。|

2226
01:13:30,290 --> 01:13:32,540
0,270 270,570 570,750 750,990 990,2250
Okay, so {} just {},
好的，所以只是，只是为了让你[娱乐]一下，

2227
01:13:33,210 --> 01:13:35,610
0,300 300,510 510,870 870,1560 1620,2400
just for your [amusement] {},|
|

2228
01:13:36,180 --> 01:13:37,230
0,450 450,720 720,810 810,960 960,1050
atomic swap is not the
原子交换不是唯一存在的指令，

2229
01:13:37,230 --> 01:13:39,450
0,240 240,870 900,1350 1350,1860 1890,2220
only instruction that exists {},|
|

2230
01:13:39,450 --> 01:13:40,620
0,120 120,420 420,690 690,900 900,1170
so here's the {RISC-V -}
这是RISC-V手册，

2231
01:13:40,620 --> 01:13:43,350
0,540 870,1500 1500,1980 2010,2640 2640,2730
manual,| {} in lists, {}
|在列表中，所有的原子操作，

2232
01:13:43,350 --> 01:13:44,220
0,180 180,360 360,450 450,540 540,870
whole bunch of the atomic

2233
01:13:44,220 --> 01:13:45,540
0,480 480,660 660,810 810,900 900,1320
operation,| so there's an atomic
|所以有一个原子，或者，有最大最小值，

2234
01:13:45,540 --> 01:13:47,070
0,300 300,420 420,870 870,1260 1260,1530
and, {} atomic or, there's

2235
01:13:47,070 --> 01:13:49,290
0,450 450,870 870,1320 1620,1860 1860,2220
{} max min,| {} they're
|它们都可以在原子操作中读写一个值。

2236
01:13:49,290 --> 01:13:50,940
0,630 630,630
all, {}

2237
01:13:50,940 --> 01:13:51,900
0,300 300,510 510,690 690,870 870,960
{} can {} read or

2238
01:13:51,900 --> 01:13:52,920
0,240 240,270 270,780 780,930 930,1020
write a value in an

2239
01:13:52,920 --> 01:13:54,380
0,390 390,900
atomic operation.|
|

2240
01:13:58,480 --> 01:13:59,560
0,570
Okay?|
好吧?|

2241
01:13:59,890 --> 01:14:00,850
0,150 150,300 300,420 420,450 450,960
Okay so there's a couple
好的，我想指出的是，在这个特定的实现中，还有其他几件事。

2242
01:14:00,970 --> 01:14:01,660
0,210 210,420 420,480 480,630 630,690
other things, I want to

2243
01:14:01,660 --> 01:14:03,130
0,240 240,690 720,1110 1110,1290 1290,1470
point out, {} in this

2244
01:14:03,130 --> 01:14:04,760
0,330 330,1020
particular implementation.|
|

2245
01:14:04,910 --> 01:14:06,140
0,720

2246
01:14:06,420 --> 01:14:08,250
0,840 990,1260 1260,1440 1440,1530 1530,1830
In, {} let me start
在，让我重新开始回去获取。

2247
01:14:08,250 --> 01:14:10,710
0,360 360,510 510,870 870,1350 1740,2460
again go back to acquire.|
|

2248
01:14:12,850 --> 01:14:13,750
0,360 360,510 510,750 750,810 810,900
{} So one of the
因此，Acquisition函数首先要做的一件事是，

2249
01:14:13,750 --> 01:14:16,300
0,180 180,450 450,780 780,1260
first things that the

2250
01:14:16,300 --> 01:14:19,030
0,300 300,570 570,1050 1350,2160 2160,2730
acquire function does,| {} is
|它可以关闭中断。

2251
01:14:19,030 --> 01:14:21,920
0,1140 1170,1500 1500,1800 1830,2430
it turns off interrupts.|
|

2252
01:14:22,900 --> 01:14:24,610
0,570 900,1110 1110,1230 1230,1440 1440,1710
And it's really good to
我真的很高兴能理解为什么会这样

2253
01:14:24,610 --> 01:14:25,810
0,420 420,810 810,1020 1020,1110 1110,1200
understand why that is the

2254
01:14:25,810 --> 01:14:26,770
0,480 480,570 570,720 720,810 810,960
case| and so for now
|现在，我将回到UART示例代码。

2255
01:14:26,770 --> 01:14:27,670
0,240 240,360 360,480 480,780 780,900
I'm gonna go back to

2256
01:14:27,670 --> 01:14:29,680
0,90 90,600 630,1020 1020,1470
{} uart example code.|
|

2257
01:14:29,680 --> 01:14:30,550
0,360 360,480 480,630 630,690 690,870
And you think a little
你可以稍微想一想这一点。

2258
01:14:30,550 --> 01:14:31,800
0,150 150,360 360,750
bit about this.|
|

2259
01:14:31,800 --> 01:14:32,880
0,390 390,600 600,810 810,930 930,1080
{} And so we want
所以我们想要考虑一下这个案子，

2260
01:14:32,880 --> 01:14:34,200
0,240 240,450 450,600 600,690 690,1320
to think about the case,|
|

2261
01:14:34,380 --> 01:14:36,940
0,1020 1050,1950
were {}
被获取实际上可能没有正确实现，

2262
01:14:37,120 --> 01:14:38,980
0,480 480,570 570,1020 1050,1380 1380,1860
acquire is actually maybe incorrectly

2263
01:14:38,980 --> 01:14:40,300
0,450 450,720 720,1020 1020,1200 1200,1320
implemented,| does not turn off
|不关闭中断，

2264
01:14:40,300 --> 01:14:43,060
0,900 1020,1410 1860,2100 2220,2670 2670,2760
interrupts,| so the way to
|所以思考这个问题的方法是，如果我们通过uartputc，

2265
01:14:43,060 --> 01:14:44,050
0,180 180,450 450,660 660,900 900,990
think about this, is if

2266
01:14:44,050 --> 01:14:45,700
0,90 90,240 240,390 390,990 990,1650
we go through {uartputc -},|
|

2267
01:14:46,090 --> 01:14:47,770
0,330 330,930 960,1290 1290,1380 1380,1680
and here let's say uartputc
这里假设uartputc运行，

2268
01:14:48,160 --> 01:14:49,140
0,510
runs,|
|

2269
01:14:49,170 --> 01:14:52,470
0,810 1290,1980 1980,2580 2580,2730 2730,3300
and, {} acquires the lock.|
并且，获得了锁。|

2270
01:14:53,520 --> 01:14:54,780
0,210 210,330 330,540 540,1020 1020,1260
And but does not turn
但不关闭中断，会发生什么。

2271
01:14:54,780 --> 01:14:56,340
0,120 120,690 750,1020 1020,1140 1140,1560
off interrupts, what can happen.|
|

2272
01:15:03,050 --> 01:15:04,220
0,240 240,600 600,630 630,840 840,1170
Give everybody a couple seconds
给大家几秒钟考虑一下，

2273
01:15:04,220 --> 01:15:05,540
0,90 90,240 240,510 510,750 840,1320
to think about it {},|
|

2274
01:15:05,930 --> 01:15:07,040
0,210 210,390 390,540 540,630 630,1110
if you have an idea
如果你有一个想法或者为什么它可能是错误的，比如跳跃。

2275
01:15:07,040 --> 01:15:07,850
0,180 180,480 480,540 540,720 720,810
or why it might be

2276
01:15:07,850 --> 01:15:10,520
0,450 450,1110 1530,2100
wrong, like jumpin.|
|

2277
01:15:18,340 --> 01:15:20,680
0,390 390,1470 1590,1800 1800,1950 1950,2340
{} Perhaps, it could be
或许，它可以被打断，

2278
01:15:20,710 --> 01:15:23,770
0,270 270,810 810,1500 1650,2520 2550,3060
{} interrupted,| because of, {}
|因为，因为这个锁，然后事情就发生了

2279
01:15:24,070 --> 01:15:26,080
0,480 480,570 570,810 840,1590 1860,2010
because of the [lock] and

2280
01:15:26,080 --> 01:15:28,900
0,180 180,990 1260,2160 2400,2640 2640,2820
then something happens| and it
|它还需要打印一些其他的东西，

2281
01:15:28,900 --> 01:15:31,090
0,210 210,330 330,600 600,1380 1530,2190
needs to print something else,|
|

2282
01:15:31,090 --> 01:15:31,900
0,180 180,240 240,570 570,690 690,810
and it tries to do
它试图再做一次uartputc，

2283
01:15:31,900 --> 01:15:33,820
0,420 870,1500
uartputc again,|
|

2284
01:15:33,970 --> 01:15:35,530
0,210 210,540 540,660 660,900 900,1560
{but,the} lock is already taken.|
但是锁已经被拿走了。|

2285
01:15:35,740 --> 01:15:36,700
0,330 330,480 480,540 540,600 600,960
That might be a possible
这可能是一种可能的情况，

2286
01:15:36,700 --> 01:15:38,230
0,480 480,1290 1320,1410 1410,1470 1470,1530
scenario,| {} there is a
对于这一点，有一个更直接的例子。

2287
01:15:38,230 --> 01:15:39,880
0,270 270,420 420,930 960,1530 1530,1650
much more direct example for

2288
01:15:39,880 --> 01:15:40,840
0,420
this.|
|

2289
01:15:40,840 --> 01:15:41,740
0,150 150,390 390,630 630,810 810,900
So let's say {uartputc -
所以我们假设uartputc抓住锁

2290
01:15:41,740 --> 01:15:44,380
0,210 210,750 750,1620 2070,2520 2520,2640
- -} {grab,the,lock}| and uart
|和UART正忙于传输一些字符。

2291
01:15:44,380 --> 01:15:46,690
0,300 300,660 690,1590 1590,1740 1740,2310
were busy transmitting some character.|
|

2292
01:15:47,590 --> 01:15:49,060
0,180 180,720 720,840 840,1020 1020,1470
So what {uart -} done
那么UART做了什么，或者传输字符，它做了什么。

2293
01:15:49,090 --> 01:15:50,500
0,450 450,840 840,1140 1140,1290 1290,1410
or transmitting character, what does

2294
01:15:50,500 --> 01:15:51,440
0,60 60,390
it do.|
|

2295
01:15:53,160 --> 01:15:54,330
0,300 300,570 570,660 660,750 750,1170
If causes {} an interrupt
如果导致中断纠正和UART中断，

2296
01:15:54,330 --> 01:15:57,620
0,420 900,1500 1530,1860 1860,2760
correct and uart interruptions,|
|

2297
01:15:57,940 --> 01:15:59,560
0,330 330,480 480,630 630,1200 1200,1620
what {uart -} interrupted do,|
UART中断做的事情，|

2298
01:16:00,740 --> 01:16:02,300
0,180 180,480 480,540 540,930 930,1560
it grabs the same lock,|
它抓住了同一把锁，|

2299
01:16:02,450 --> 01:16:03,680
0,150 150,300 300,720 720,870 870,1230
you know that the uartputc
你知道uartputc持有权利，

2300
01:16:03,680 --> 01:16:04,940
0,540 600,840 840,960 960,1110 1110,1260
holding right,| so what will
|那么，如果只有一个CPU，这里会发生什么呢

2301
01:16:04,940 --> 01:16:06,590
0,270 270,660 1140,1320 1320,1470 1470,1650
happen here if there's only

2302
01:16:06,590 --> 01:16:08,210
0,210 210,720 990,1260 1260,1410 1410,1620
one CPU| and so there's
|因此，没有其他CPU可以运行此中断。

2303
01:16:08,210 --> 01:16:09,440
0,150 150,360 360,720 720,990 990,1230
no other CPU where this

2304
01:16:09,440 --> 01:16:11,100
0,510 510,630 630,780 780,1140
interrupt could be running.|
|

2305
01:16:12,460 --> 01:16:13,420
0,210 210,300 300,390 390,450 450,960
Well, we have a deadlock
嗯，我们现在陷入僵局了，

2306
01:16:13,450 --> 01:16:15,840
0,210 210,720 990,1800
right,| because the
|因为当前CPU持有作为uartputc的一部分的锁，

2307
01:16:15,840 --> 01:16:17,430
0,270 270,600 600,810 810,1470 1470,1590
current CPU is holding the

2308
01:16:17,430 --> 01:16:18,780
0,510 540,720 720,900 900,1020 1020,1350
lock as part of {uartputc

2309
01:16:18,810 --> 01:16:21,360
0,690 750,1080 1080,1680 1710,1860 1860,2550
-},| then later the interrupt
|然后，后来传来的中断

2310
01:16:21,360 --> 01:16:22,470
0,120 120,390 390,750 900,1050 1050,1110
that came in| and the
|它尝试做的第一件事实际上是获取已经持有的锁。

2311
01:16:22,470 --> 01:16:23,250
0,210 210,360 360,510 510,720 720,780
first thing it tries to

2312
01:16:23,250 --> 01:16:24,000
0,120 120,240 240,420 420,720 720,750
do is actually acquire a

2313
01:16:24,000 --> 01:16:25,640
0,240 240,390 390,690 690,1140
lock has already held.|
|

2314
01:16:25,640 --> 01:16:26,690
0,150 150,420 420,660 660,840 840,1050
In fact, in the case
事实上，在xv6的情况下，您会感到恐慌，

2315
01:16:26,690 --> 01:16:27,980
0,90 90,690 690,780 780,1140 1140,1290
of xv6, you will get

2316
01:16:27,980 --> 01:16:29,240
0,60 60,570 660,1110 1110,1200 1200,1260
a panic,| because you know
|因为您知道相同的CPU实际上正在再次尝试获取相同的锁。

2317
01:16:29,240 --> 01:16:31,040
0,120 120,360 360,1050 1320,1710 1710,1800
the same CPU, {} is

2318
01:16:31,040 --> 01:16:31,940
0,210 210,450 450,510 510,810 810,900
actually trying to acquire the

2319
01:16:31,940 --> 01:16:33,320
0,270 270,480 480,840
same lock again.|
|

2320
01:16:37,460 --> 01:16:39,140
0,510 630,1140 1140,1260 1260,1350 1350,1680
So basically you know what
所以基本上你知道是什么获得了自旋锁，处理了两种不同类型的并发，

2321
01:16:39,170 --> 01:16:41,150
0,840 840,1230 1230,1560 1560,1830 1830,1980
acquires spinlock, deals with sort

2322
01:16:41,150 --> 01:16:42,230
0,90 90,420 420,750 750,990 990,1080
of two different types of

2323
01:16:42,230 --> 01:16:43,880
0,690 810,1290 1290,1440 1440,1590 1590,1650
concurrency,| one they're sort of
|其一，它们是两个不同CPU之间的并发，

2324
01:16:43,880 --> 01:16:45,410
0,420 420,690 690,810 810,1110 1110,1530
concurrency between two different {CPUs

2325
01:16:45,410 --> 01:16:46,700
0,300 570,810 810,870 870,1020 1020,1290
-},| going to make sure
|例如如果中断功能在不同的CPU上运行，

2326
01:16:46,700 --> 01:16:47,810
0,180 180,240 240,600 600,750 750,1110
like for example if the

2327
01:16:47,870 --> 01:16:49,400
0,600 600,990 990,1320 1320,1440 1440,1530
interrupt function runs on a

2328
01:16:49,400 --> 01:16:51,170
0,330 330,840 1020,1230 1230,1620 1620,1770
different CPU,| though basically we're
|虽然基本上我们要提高传输缓冲区。

2329
01:16:51,170 --> 01:16:52,040
0,180 180,300 300,720 720,810 810,870
going to raise on the

2330
01:16:52,040 --> 01:16:53,380
0,450 450,900
transmission buffer.|
|

2331
01:16:53,440 --> 01:16:54,250
0,210 210,390 390,480 480,600 600,810
{} But if they run
但是如果它们在同一个CPU上运行，

2332
01:16:54,250 --> 01:16:55,210
0,90 90,180 180,450 450,900 900,960
in the same CPU,| we're
|我们要确保它仍然是原子的

2333
01:16:55,210 --> 01:16:55,900
0,120 120,180 180,330 330,540 540,690
going to make sure that

2334
01:16:55,900 --> 01:16:57,550
0,120 120,360 360,420 420,930 1320,1650
it's still {atomic -} {}|
|

2335
01:16:57,550 --> 01:16:58,330
0,180 180,360 360,450 450,600 600,780
and that is not being
这没有被中断，因此我们实际上在获取中关闭了中断。

2336
01:16:58,330 --> 01:16:59,770
0,510 510,630 630,1080 1080,1230 1230,1440
interrupted and therefore we actually

2337
01:16:59,770 --> 01:17:00,610
0,210 210,270 270,540 540,600 600,840
turn the {interrupts - -}

2338
01:17:00,610 --> 01:17:02,300
0,300 330,1170
off {in,acquire}.|
|

2339
01:17:03,360 --> 01:17:04,470
0,240 240,360 360,720 720,930 930,1110
And they're only turned on
它们只有在释放结束时才会再次打开，

2340
01:17:04,470 --> 01:17:05,790
0,480 630,900 900,1050 1050,1170 1170,1320
again at the end of

2341
01:17:05,790 --> 01:17:08,310
0,660 990,1740 1740,2160 2160,2250 2250,2520
release,| {} when the walk
|当步行者实际上还没有被释放的时候，

2342
01:17:08,310 --> 01:17:09,690
0,270 270,570 570,750 750,1260 1260,1380
actually hasn't been released,| at
|在这一点上就是再看一遍，

2343
01:17:09,690 --> 01:17:10,890
0,180 180,360 360,480 480,810 810,1200
that point is {see,it} again,|
|

2344
01:17:10,920 --> 01:17:11,550
0,90 90,210 210,330 330,510 510,630
you know to take these
你知道要接受这些打扰，

2345
01:17:11,550 --> 01:17:14,220
0,540 720,1200 1200,1470 1470,1740 1740,2670
interrupts,| because lock actually is
|因为锁实际上不再被释放。

2346
01:17:14,220 --> 01:17:15,480
0,210 210,510 510,870
not released anymore.|
|

2347
01:17:16,190 --> 01:17:17,390
0,300 300,510 510,840 840,990 990,1200
Not acquire holding it, not
不是拿着它，不是再拿着。

2348
01:17:17,390 --> 01:17:18,540
0,240 240,600
held anymore.|
|

2349
01:17:18,940 --> 01:17:20,420
0,270 270,390 390,540 540,870
Does that make sense?|
这说得通吗？|

2350
01:17:28,560 --> 01:17:30,240
0,300 300,450 450,720 720,1320 1350,1680
Okay, there's one more subtle
好的，在这个实现中还有一件更微妙的事情，

2351
01:17:30,240 --> 01:17:32,880
0,360 360,1170 1260,1650 1680,2490 2490,2640
thing in this implementation,| that
|我想说的是，

2352
01:17:32,880 --> 01:17:33,900
0,90 90,300 300,360 360,570 570,1020
I want to talk about,|
|

2353
01:17:34,260 --> 01:17:36,800
0,840 1290,2010
{} and,
而且我们需要处理。

2354
01:17:36,860 --> 01:17:38,660
0,660 1050,1380 1380,1530 1530,1620 1620,1800
{} we need to deal

2355
01:17:38,660 --> 01:17:39,660
0,450
with.|
|

2356
01:17:39,800 --> 01:17:41,120
0,900

2357
01:17:43,200 --> 01:17:45,240
0,150 150,420 420,750 780,1560
And there is {}
还有就是内存排序。

2358
01:17:45,270 --> 01:17:46,880
0,360 360,840
memory ordering.|
|

2359
01:17:53,810 --> 01:17:56,300
0,480 480,1230 1500,2130 2130,2340 2340,2490
So {} {for,example} you think
举个例子，你认为锁是，

2360
01:17:56,300 --> 01:17:58,550
0,570 600,1200 1200,1560 1560,1800 1800,2250
about lock is,| let's say,
|比方说，把它锁在一个地方，

2361
01:17:59,500 --> 01:18:01,900
0,540 540,690 690,1170 1500,1710 1710,2400
acquires its locked to one,|
|

2362
01:18:02,290 --> 01:18:03,610
0,630 660,960 960,1080 1080,1260 1260,1320
{} maybe we have a
也许我们有一个关键的部分，在那里你实际上是x加1

2363
01:18:03,610 --> 01:18:04,870
0,270 270,660 660,750 750,1050 1050,1260
critical section in which you

2364
01:18:04,870 --> 01:18:07,840
0,690 690,900 900,1170 1170,1680 2070,2970
actually x plus one| and
|然后要求释放，你知道的，把锁设为零。

2365
01:18:07,870 --> 01:18:12,220
0,1050 1050,2550 3030,3690 3690,4080 4080,4350
{} {then,require} release {you,know,set} lock

2366
01:18:12,220 --> 01:18:13,060
0,360
zero.|
|

2367
01:18:13,260 --> 01:18:14,160
0,270 270,510 510,690 690,750 750,900
So you sort of think
所以你可以考虑一下教学方案，

2368
01:18:14,160 --> 01:18:15,750
0,210 210,750 750,1110 1110,1350 1350,1590
about instruction scheme,| that's being
它是在特定的CPU上执行的，

2369
01:18:15,750 --> 01:18:17,400
0,510 510,630 630,690 690,1020 1020,1650
executed on a particular CPU,|
|

2370
01:18:17,550 --> 01:18:18,450
0,210 210,360 360,450 450,660 660,900
you know so these are
你知道，这些就是正在执行的指令，对吧。

2371
01:18:18,450 --> 01:18:19,890
0,120 120,570 570,660 660,870 870,1440
the instructions are being executed,

2372
01:18:19,950 --> 01:18:20,780
0,330
right.|
|

2373
01:18:22,110 --> 01:18:23,550
0,420 420,810 810,900 900,1320 1320,1440
Now, if the code were
现在，如果代码仅仅是纯顺序的。

2374
01:18:23,550 --> 01:18:26,160
0,180 180,1050 1110,1350 1350,2070
just purely {} sequential.|
|

2375
01:18:26,800 --> 01:18:30,260
0,1020 1260,2010 2010,2820

2376
01:18:30,490 --> 01:18:34,990
0,270 270,810 810,1860 2160,3090 3570,4500
The compiler or a processor
编译器或处理器体系结构或重新排序指令，

2377
01:18:35,020 --> 01:18:36,790
0,480 480,690 690,1050 1050,1650 1650,1770
architecture or reorder instructions,| you
|你知道，为了获得更好的表现，

2378
01:18:36,790 --> 01:18:37,660
0,240 240,450 450,540 540,660 660,870
know just to get better

2379
01:18:37,660 --> 01:18:41,920
0,690 1020,1710 1830,2670 3000,3780 3780,4260
performance,| for example, {} if
|例如，如果它是顺序流，

2380
01:18:41,920 --> 01:18:43,120
0,120 120,270 270,330 330,780 780,1200
it were a sequential stream,|
|

2381
01:18:43,120 --> 01:18:44,140
0,240 240,330 330,480 480,900 900,1020
would it be okay to
我可以把这份指示移到后面去吗？

2382
01:18:44,140 --> 01:18:46,180
0,330 330,510 510,1170 1200,1350 1350,2040
move this instruction to afterwards.|
|

2383
01:18:49,170 --> 01:18:51,060
0,300 300,480 480,930 930,1140 1140,1890
We don't change the correctness
我们不会改变单一执行流程的正确性。

2384
01:18:51,120 --> 01:18:52,380
0,330 330,510 510,840 840,1140 1140,1260
of the single stream of

2385
01:18:52,380 --> 01:18:53,600
0,630
execution.|
|

2386
01:18:58,180 --> 01:18:59,620
0,150 150,420 420,720 750,1170 1170,1440
{You,know}, not really,| because lock
你知道，不是很清楚，|因为下一个锁是完全独立的，

2387
01:18:59,620 --> 01:19:00,640
0,60 60,300 300,360 360,630 630,1020
the next are totally independent

2388
01:19:00,640 --> 01:19:01,720
0,90 90,210 210,540 540,810 810,1080
of each other,| there's no
|这与此无关，

2389
01:19:02,050 --> 01:19:03,280
0,570 570,720 720,900 900,1110 1110,1230
relation to it,| would be
|如果是顺序执行就完全没问题了，

2390
01:19:03,280 --> 01:19:04,480
0,390 390,720 720,840 840,960 960,1200
perfectly fine if it were

2391
01:19:04,480 --> 01:19:06,460
0,90 90,600 600,1230 1530,1860 1860,1980
a sequential execution,| that the
|在锁定零之后x已经移动了。

2392
01:19:06,460 --> 01:19:08,470
0,330 330,660 660,1020 1020,1350 1350,2010
x has moved after locked

2393
01:19:08,470 --> 01:19:10,500
0,690 1110,1560
{} zero.|
|

2394
01:19:10,620 --> 01:19:11,670
0,330 330,540 540,810 810,930 930,1050
{} So that you know
所以你知道关于单一的，单一的串行执行。

2395
01:19:11,670 --> 01:19:13,080
0,150 150,210 210,810
on the single,

2396
01:19:14,340 --> 01:19:16,620
0,420 420,870 870,1680
single serial execution.|
|

2397
01:19:18,140 --> 01:19:19,600
0,210 210,690
That's okay.|
那好吧。|

2398
01:19:23,500 --> 01:19:25,630
0,330 330,660 660,1080 1080,1530 1530,2130
And effect and effect processors,|
以及效果和效果处理器，|

2399
01:19:25,630 --> 01:19:26,290
0,150 150,300 300,450 450,570 570,660
{you,know} do this all the
你知道一直都在这么做，

2400
01:19:26,290 --> 01:19:27,250
0,480 480,570 570,690 690,840 840,960
time,| you know they do
|你知道他们确实会出人意料地执行任务，

2401
01:19:27,250 --> 01:19:30,070
0,600 600,1050 1050,1500 1920,2310 2310,2820
expectantly execute stuff,| we're expected
|我们应该执行指令

2402
01:19:30,070 --> 01:19:31,540
0,60 60,450 450,1050 1050,1290 1290,1470
to execute instructions| and so
|因此，这基本上会导致这些指令重新排序。

2403
01:19:31,540 --> 01:19:32,740
0,210 210,360 360,780 780,840 840,1200
that can result in basically

2404
01:19:32,740 --> 01:19:34,760
0,180 180,720 720,870 870,1560
these instructions {re-orderings -}.|
|

2405
01:19:34,760 --> 01:19:36,890
0,660 720,1350 1440,1830 1830,2010 2010,2130
{} The compiler, does it
编译器也会这样做，

2406
01:19:36,890 --> 01:19:38,720
0,540 630,840 840,960 960,1710 1710,1830
too,| may be optimized some
|可以优化一些代码路径并且还将重新排序指令，

2407
01:19:38,720 --> 01:19:39,830
0,240 240,570 570,690 690,930 930,1110
code path and also will

2408
01:19:39,830 --> 01:19:41,600
0,330 330,870 870,990 990,1380 1380,1770
reorder instructions,| as long as
|只要你知道结果是相同的串行执行。

2409
01:19:41,630 --> 01:19:42,530
0,90 90,300 300,780 780,840 840,900
you know results in the

2410
01:19:42,530 --> 01:19:44,280
0,300 300,660 660,1200
same serial execution.|
|

2411
01:19:44,710 --> 01:19:46,390
0,180 180,570 570,840 840,1230 1230,1680
But clearly during concurrent execution
但是很明显在并行执行的过程中这是一场灾难，对吧，

2412
01:19:46,390 --> 01:19:48,250
0,360 360,1020 1050,1290 1290,1560 1560,1860
{this,be} disaster, right,| because if
|因为如果获取了锁，

2413
01:19:48,460 --> 01:19:50,380
0,540 540,630 630,1380
lock are acquire,|
|

2414
01:19:51,320 --> 01:19:52,940
0,510 510,660 660,810 810,1050 1050,1620
and this was our release,|
这就是我们的释放，|

2415
01:19:54,180 --> 01:19:55,290
0,150 150,450 450,630 630,750 750,1110
and basically what we've done,|
基本上我们所做的，|

2416
01:19:55,290 --> 01:19:56,130
0,90 90,330 330,450 450,510 510,840
we move {} the critical
我们将临界区移出收购区将是完全不正确的。

2417
01:19:56,130 --> 01:19:58,770
0,360 360,1020 1020,1170 1170,1560 1590,2640
section outside of the the

2418
01:19:58,860 --> 01:20:00,420
0,480 480,810 810,960 960,1140 1170,1560
acquiring region would be totally

2419
01:20:00,420 --> 01:20:01,520
0,510
incorrect.|
|

2420
01:20:01,580 --> 01:20:03,020
0,180 180,360 360,930
So that's wrong,
所以这是错误的，在并发执行中是错误的。

2421
01:20:04,110 --> 01:20:05,940
0,660 660,810 810,870 870,1260 1260,1830
wrong in a concurrent execution.|
|

2422
01:20:12,780 --> 01:20:14,010
0,150 150,480 480,570 570,660 660,1230
And so you know to
所以你知道要禁止或告诉编译器和硬件不要这么做，

2423
01:20:14,040 --> 01:20:15,630
0,780 780,900 900,1140 1140,1200 1200,1590
forbid or tell the compiler

2424
01:20:15,630 --> 01:20:17,190
0,90 90,510 510,1050 1110,1290 1290,1560
and hardware not to do

2425
01:20:17,190 --> 01:20:19,800
0,390 720,1350 1650,2220 2220,2460 2460,2610
this,| {} there's something that's
|有一种叫做记忆栅栏的东西

2426
01:20:19,800 --> 01:20:21,930
0,390 390,930 930,1500 1500,1950 1950,2130
called {} memory fence| or
|或者同步之类的东西，

2427
01:20:21,930 --> 01:20:23,820
0,210 210,360 360,1140 1440,1710 1710,1890
something that synchronize,| {} there's
|说明书上基本上是这样说的，

2428
01:20:23,820 --> 01:20:25,800
0,450 450,780 780,1050 1050,1260 1290,1980
instructions basically says,| like any
|就像在此之前的任何装载或存储一样，

2429
01:20:25,830 --> 01:20:27,150
0,330 330,390 390,750 750,1140 1140,1320
loads or stores before this

2430
01:20:27,150 --> 01:20:29,220
0,510 750,990 990,1140 1140,1680 1680,2070
point,| you are not allowed
|你不允许超过这一点。

2431
01:20:29,220 --> 01:20:30,540
0,60 60,360 360,750 750,900 900,1320
to move beyond this point.|
|

2432
01:20:31,320 --> 01:20:32,700
0,240 240,360 360,780 780,990 990,1380
And so release has this
所以Release有这个，Acquisition有这个

2433
01:20:32,700 --> 01:20:34,860
0,570 570,1170 1170,1590 1590,1770 1770,2160
and {} acquire has this|
|

2434
01:20:35,190 --> 01:20:36,150
0,150 150,300 300,390 390,750 750,960
and so for example, this
举个例子，这个x+，x+1，

2435
01:20:36,150 --> 01:20:37,350
0,210 210,390 390,570 570,750 750,1200
x plus, x plus one,|
|

2436
01:20:37,380 --> 01:20:39,900
0,150 150,330 330,720 1020,1710 1710,2520
if that was {} updated
如果该更新是在获取之后和释放之前更新的，

2437
01:20:39,900 --> 01:20:41,250
0,390 390,510 510,960 960,1050 1050,1350
after the acquire and before

2438
01:20:41,250 --> 01:20:42,480
0,60 60,630 660,870 870,1050 1050,1230
the release,| the x plus
|x+x+1必须留下来

2439
01:20:42,480 --> 01:20:43,980
0,210 210,360 360,630 660,1050 1050,1500
x plus one has {to,stay}|
|

2440
01:20:43,980 --> 01:20:45,690
0,840 870,990 990,1140 1140,1350 1350,1710
before you know this particular
在你知道这个特定的内存同步点之前。

2441
01:20:45,690 --> 01:20:47,320
0,270 270,810 810,1200
memory synchronization point.|
|

2442
01:20:47,410 --> 01:20:48,700
0,300 300,630 630,780 780,1020 1020,1290
And so it will not
所以不会是这样的，

2443
01:20:48,700 --> 01:20:49,570
0,270 270,480 480,600 600,720 720,870
be,| there will be no
|存储器排序不会有问题，

2444
01:20:49,570 --> 01:20:52,240
0,510 720,1410 1410,1800 1800,2310 2340,2670
trouble {} with {} memory

2445
01:20:52,240 --> 01:20:53,620
0,390 690,990 990,1170 1170,1260 1260,1380
ordering,| so this is the
这就是同步到那里的原因，

2446
01:20:53,620 --> 01:20:55,750
0,450 450,930 930,1170 1170,1740 1740,2130
reason why {} synchronizes there,|
|

2447
01:20:55,900 --> 01:20:58,360
0,930 930,1260 1290,1950 1950,2070 2070,2460
{both,in} the release and also
无论是在发布中还是在收购中都有一个。

2448
01:20:58,360 --> 01:20:59,530
0,180 180,420 420,570 570,690 690,1170
there's one in the acquire.|
|

2449
01:21:03,560 --> 01:21:04,840
0,90 90,210 210,360 360,690
Does that make sense?|
这说得通吗？|

2450
01:21:06,230 --> 01:21:07,670
0,180 180,420 420,600 600,690 690,1440
{} I have a question.|
我有个问题要问。|

2451
01:21:08,880 --> 01:21:11,460
0,750 990,1380 1380,1830 2160,2370 2370,2580
{} Is it, is it
是不是，是不是按照惯例，这个(港口)的起点，

2452
01:21:11,460 --> 01:21:14,250
0,210 210,990 990,1350 1350,1530 1530,2790
by convention that the start

2453
01:21:14,280 --> 01:21:15,760
0,930
of

2454
01:21:15,880 --> 01:21:17,240
0,810
{}

2455
01:21:17,300 --> 01:21:19,340
0,330 330,990 1020,1260 1260,1440 1440,2040
the [port],| so I guess
|所以我想我猜编译器可以搞清楚，

2456
01:21:19,370 --> 01:21:21,290
0,540 540,930 930,1080 1230,1410 1410,1920
I guess the the compiler

2457
01:21:21,290 --> 01:21:23,090
0,720 750,1230 1230,1380 1380,1560 1560,1800
could figure out,| that there
|甚至在获取锁之前就有一条指令

2458
01:21:23,090 --> 01:21:25,130
0,240 240,690 690,1380 1380,1920 1920,2040
is an instruction before the

2459
01:21:25,130 --> 01:21:27,050
0,300 300,450 450,870 900,1680 1680,1920
lock is even acquired| and
|在锁被释放后，它也可以被移动。

2460
01:21:27,050 --> 01:21:28,700
0,540 780,990 990,1230 1230,1380 1380,1650
that it can be just

2461
01:21:28,700 --> 01:21:29,750
0,90 90,300 300,600 600,960 960,1050
as well moved after the

2462
01:21:29,750 --> 01:21:32,500
0,270 270,390 390,1110
lock is released.|
|

2463
01:21:32,830 --> 01:21:34,840
0,390 390,630 630,1320 1320,1770 1770,2010
Can that happen, or will
这会发生吗，或者它会遇到屏障，看看这个。

2464
01:21:34,840 --> 01:21:36,670
0,270 300,930 930,1110 1110,1650 1650,1830
it encounter a barrier and

2465
01:21:36,670 --> 01:21:38,410
0,240 240,540 630,1320 1320,1530 1530,1740
see that.| You also you
|你也知道，在这种情况下，以屏障的形式收购，以屏障的形式发布，

2466
01:21:38,410 --> 01:21:39,940
0,180 180,330 330,570 570,870 870,1530
know in this case, {acquire,as}

2467
01:21:39,940 --> 01:21:40,870
0,60 60,480 480,600 600,810 810,930
a barrier and release as

2468
01:21:40,870 --> 01:21:42,100
0,60 60,570 570,750 750,1110 1110,1230
a barrier,| so anything that
|所以锁定在一区之前发生的任何事情都会在那之前发生，

2469
01:21:42,100 --> 01:21:44,350
0,300 300,690 690,1170 1200,1740 1740,2250
happened before locked {in,sector} one

2470
01:21:44,440 --> 01:21:46,000
0,240 240,510 510,840 840,1200 1440,1560
will happen before that,| it
|它永远不会通过那个指令，

2471
01:21:46,000 --> 01:21:47,650
0,120 120,540 540,870 870,1080 1080,1650
will never pass that instruction,|
|

2472
01:21:47,680 --> 01:21:48,790
0,150 150,360 360,450 450,510 510,1110
so this is a barrier,|
这就是屏障，|

2473
01:21:48,910 --> 01:21:49,880
0,60 60,180 180,570
if you will,
如果您愿意的话，这个是屏障一号，这是屏障二号。

2474
01:21:50,390 --> 01:21:52,160
0,270 270,660 660,1260
this barrier one,

2475
01:21:52,250 --> 01:21:53,330
0,150 150,300 300,360 360,750 750,1080
and this is barrier two.|
|

2476
01:21:55,520 --> 01:21:56,480
0,270 270,390 390,510 510,780 780,960
And so it means that
所以这意味着在这里之前的任何指令，都要留在这里，

2477
01:21:56,480 --> 01:21:58,370
0,150 150,540 540,930 930,1470 1500,1890
any instruction before here, stay

2478
01:21:58,370 --> 01:22:01,130
0,450 780,960 960,1470 1470,2160 2580,2760
here,| and instruction between what
|以及在获取和释放两者之间发生的事情之间的指令

2479
01:22:01,130 --> 01:22:02,750
0,300 300,570 570,630 630,1170 1230,1620
happened between the two between

2480
01:22:02,750 --> 01:22:04,700
0,330 330,690 690,840 840,1320 1320,1950
{acquire,and} release| and instruction after
|之后的指示将在释放后保留。

2481
01:22:04,910 --> 01:22:06,530
0,300 300,510 510,1020 1020,1140 1140,1620
will stay after the release.|
|

2482
01:22:07,950 --> 01:22:09,120
0,600
Okay.|
好吧。|

2483
01:22:11,110 --> 01:22:12,180
0,600
Okay?|
好吧?|

2484
01:22:12,550 --> 01:22:14,230
0,210 210,330 330,450 450,750 750,1680
Okay so I'm running {}
好的，我快跑到终点了，

2485
01:22:14,260 --> 01:22:15,910
0,210 210,870 900,1320 1320,1470 1470,1650
{close,to} {the,end},| {} so let
|所以让我来总结一下。

2486
01:22:15,910 --> 01:22:18,250
0,240 240,450 450,960 960,1350 1800,2340
me just actually {} {}

2487
01:22:18,490 --> 01:22:20,080
0,450 450,900
wrapup here.|
|

2488
01:22:27,710 --> 01:22:29,480
0,540 570,1230
So, {}
所以，对于锁，你知道锁对正确性有好处，

2489
01:22:29,480 --> 01:22:31,250
0,90 90,570 600,720 720,1170 1500,1770
to locks, you know locks

2490
01:22:31,250 --> 01:22:32,920
0,60 60,240 240,360 360,960
are good for correctness,|
|

2491
01:22:40,370 --> 01:22:41,270
0,300 300,420 420,570 570,660 660,900
{} but can be bad
但可能会对性能造成不良影响。

2492
01:22:41,270 --> 01:22:42,740
0,120 120,780
for performance.|
|

2493
01:22:47,480 --> 01:22:48,920
0,600 690,990 990,1050 1050,1110 1110,1440
Which sort of a bummer
哪种错误是正确的，

2494
01:22:48,920 --> 01:22:49,910
0,240 240,480 480,570 570,720 720,990
correct,| because we are one
|因为我们是我们真正陷入困境的原因之一

2495
01:22:49,910 --> 01:22:51,470
0,300 300,450 450,1020 1050,1380 1380,1560
reason we actually got into

2496
01:22:51,470 --> 01:22:52,580
0,270 270,360 360,720 720,870 870,1110
locks| is basically to get
|基本上是为了在并行执行过程中纠正错误，

2497
01:22:52,880 --> 01:22:55,160
0,390 390,690 690,1050 1050,1740 1740,2280
correct during parallel execution,| but
|但是锁实际上限制了并行执行。

2498
01:22:55,160 --> 01:22:58,130
0,450 450,660 660,930 930,1440 2250,2970
locks actually limit parallel execution.|
|

2499
01:22:58,850 --> 01:23:01,040
0,420 930,1230 1230,1680 1740,1890 1890,2190
{} That's one and two
这是一个和两个锁使编程复杂化。

2500
01:23:01,040 --> 01:23:02,760
0,330 330,1080
locks complicate

2501
01:23:05,460 --> 01:23:06,980
0,900
programming.|
|

2502
01:23:07,290 --> 01:23:08,610
0,270 270,360 360,780 780,1170 1170,1320
And you will experience that
你会在一些实验室里体验到这一点，

2503
01:23:08,610 --> 01:23:09,420
0,60 60,300 300,390 390,510 510,810
in some of the lab,|
|

2504
01:23:09,420 --> 01:23:10,080
0,120 120,210 210,330 330,420 420,660
that we're going to be
事实上，从现在开始，我们将要做的事情，

2505
01:23:10,080 --> 01:23:11,190
0,300 300,420 420,690 690,810 810,1110
doing, in fact from now

2506
01:23:11,190 --> 01:23:12,570
0,240 240,390 390,750 750,990 990,1380
on,| we'll see lock shown
|我们会看到锁一直在显示，

2507
01:23:12,570 --> 01:23:14,310
0,330 330,450 450,900 1320,1620 1620,1740
all the time,| and that
|这至少会给我们一些思考，

2508
01:23:14,310 --> 01:23:16,320
0,90 90,270 270,480 480,1110 1380,2010
will give us {} least

2509
01:23:16,320 --> 01:23:18,300
0,60 60,330 330,1080 1140,1500 1500,1980
you know {} some thought,|
|

2510
01:23:18,300 --> 01:23:18,720
0,60 60,150 150,240 240,360 360,420
you know it's going to
你知道有必要理解为什么锁在那里

2511
01:23:18,720 --> 01:23:20,250
0,90 90,600 600,690 690,1110 1110,1530
be necessary to understand why

2512
01:23:20,250 --> 01:23:21,480
0,90 90,330 330,390 390,810 810,1230
the locks are there| and
|以及他们保护的是什么。

2513
01:23:21,480 --> 01:23:22,700
0,180 180,300 300,750
what they protect.|
|

2514
01:23:22,700 --> 01:23:23,930
0,510 510,720 720,960 960,1140 1140,1230
{} And there sort of
如果你做并行编程，这是一种内在的，

2515
01:23:23,930 --> 01:23:25,520
0,690 810,1020 1020,1200 1200,1440 1440,1590
inherent, {} if you do

2516
01:23:25,520 --> 01:23:27,590
0,330 330,900 1260,1560 1560,1920 1920,2070
parallel programming,| {} that you
|你需要使用锁。

2517
01:23:27,590 --> 01:23:29,700
0,210 210,300 300,480 480,1620
need to use locks.|
|

2518
01:23:29,880 --> 01:23:31,830
0,480 780,1350 1530,1740 1740,1860 1860,1950
And so you know if
所以你知道如果你想避免锁带来的并发症，

2519
01:23:31,830 --> 01:23:32,610
0,90 90,240 240,300 300,720 720,780
you want to avoid the

2520
01:23:32,610 --> 01:23:34,260
0,630 630,750 750,870 870,1230 1230,1650
complications due to locks,| you
|你知道你可以做几件事，

2521
01:23:34,260 --> 01:23:35,100
0,330 330,390 390,600 600,780 780,840
know a couple things you

2522
01:23:35,100 --> 01:23:36,420
0,120 120,420 450,540 540,810 1050,1320
could do,| you know don't
|你知道不要分享它，你不需要分享。

2523
01:23:36,420 --> 01:23:37,200
0,270 270,330 330,420 420,600 600,780
share it, you don't have

2524
01:23:37,200 --> 01:23:38,100
0,330
to.|
|

2525
01:23:42,860 --> 01:23:43,640
0,210 210,300 300,450 450,570 570,780
If you don't have shared
如果您没有共享数据结构，

2526
01:23:43,640 --> 01:23:45,040
0,210 210,840
data structures,|
|

2527
01:23:46,340 --> 01:23:48,110
0,360 360,570 570,900 900,1260 1260,1770
these race conditions cannot happen,|
这些竞争条件不会发生，|

2528
01:23:48,350 --> 01:23:50,060
0,480 480,630 630,780 780,1350 1350,1710
{} and so there and
所以在那里，所以你，你不需要锁

2529
01:23:50,060 --> 01:23:51,020
0,180 180,540 540,690 690,810 810,960
so you you don't need

2530
01:23:51,020 --> 01:23:52,040
0,480 480,600 600,720 720,870 870,1020
locks| and so you don't
所以你不需要这种复杂的编程。

2531
01:23:52,040 --> 01:23:53,940
0,150 150,300 300,750 750,1350
need this complicated programming.|
|

2532
01:23:54,000 --> 01:23:55,410
0,540 540,780 780,870 870,1020 1020,1410
{} But you know typically
但是你知道，通常你会有一些共享的数据结构，

2533
01:23:55,410 --> 01:23:56,160
0,90 90,210 210,420 420,540 540,750
you will have some shared

2534
01:23:56,160 --> 01:23:57,420
0,210 210,600 600,660 660,780 780,1260
data structures,| you will do,
|你会做的，你会需要锁的

2535
01:23:57,420 --> 01:23:58,920
0,570 600,690 690,810 810,1020 1020,1500
{} you will need locks|
|

2536
01:23:59,100 --> 01:24:00,300
0,360 360,420 420,570 570,780 810,1200
and I think the thing
我认为要做的事情是从粗粒度开始，

2537
01:24:00,300 --> 01:24:01,050
0,90 90,210 210,360 360,630 630,750
to do is start with

2538
01:24:01,050 --> 01:24:02,340
0,270 270,780
{coarse-grained -},|
|

2539
01:24:04,130 --> 01:24:05,840
0,210 210,360 360,720 720,1170
and then move to
然后根据您的测量结果在必要时转向细粒度，

2540
01:24:06,880 --> 01:24:08,830
0,360 360,750 780,1020 1020,1620 1620,1950
{fine-grained -} if necessary based

2541
01:24:08,830 --> 01:24:10,420
0,540 540,720 720,1230 1230,1440 1440,1590
on your measurements,| you want
|你要下定决心确保锁真的[争用]，

2542
01:24:10,420 --> 01:24:11,440
0,60 60,210 210,720 720,810 810,1020
to make determined to make

2543
01:24:11,440 --> 01:24:12,340
0,210 210,300 300,390 390,630 630,900
sure that the lock actually

2544
01:24:12,340 --> 01:24:14,020
0,810 810,1110 1110,1170 1170,1440 1440,1680
[contended],| before you actually start
|在你真正开始重新设计之前。

2545
01:24:14,020 --> 01:24:15,200
0,600
redesigning.|
|

2546
01:24:15,480 --> 01:24:16,770
0,150 150,750 750,870 870,1050 1050,1290
And finally, you know use
最后，你知道，也要使用种族检测器。

2547
01:24:16,770 --> 01:24:18,660
0,270 270,870 870,1290
{a,race} detector too.|
|

2548
01:24:20,460 --> 01:24:21,270
0,120 120,300 300,390 390,540 540,810
And one of these race
这些竞争检测器工具中的一个实际上会发现问题或竞争状况，

2549
01:24:21,270 --> 01:24:23,420
0,360 360,720 720,960 960,1470
detector tools actually finds

2550
01:24:23,760 --> 01:24:25,560
0,180 180,900 960,1410 1410,1620 1620,1800
{} problems {} or race

2551
01:24:25,560 --> 01:24:26,700
0,390 390,630 630,930 930,1080 1080,1140
conditions,| because you put the
|因为你把锁放错了

2552
01:24:26,700 --> 01:24:27,480
0,270 270,330 330,420 420,690 690,780
locks in the wrong| or
|或者您将{Acquisition，and

2553
01:24:27,480 --> 01:24:28,650
0,120 120,270 270,330 330,780 780,1170
you put the {acquire,and| release
|放错地方了

2554
01:24:28,650 --> 01:24:29,490
0,90 90,150 150,420 420,720 720,840
in the wrong place| and
|事实上，你还有比赛。

2555
01:24:29,490 --> 01:24:31,110
0,60 60,540 540,630 630,840 840,1620
in fact you still have

2556
01:24:31,320 --> 01:24:32,500
0,750
races.|
|

2557
01:24:32,770 --> 01:24:33,880
0,450 510,690 690,840 840,930 930,1110
Okay so there's a quick
好了，这里有一个关于锁的快速介绍，

2558
01:24:33,880 --> 01:24:35,380
0,450 450,540 540,1020 1080,1320 1320,1500
introduction to locks,| we're going
|我们将会谈论更多关于锁的话题

2559
01:24:35,380 --> 01:24:36,160
0,60 60,270 270,330 330,660 660,780
to talk a lot more

2560
01:24:36,160 --> 01:24:37,900
0,210 210,510 510,600 600,1320 1350,1740
about locks| in the basically
|在本学期的“睡觉”基础上，

2561
01:24:37,900 --> 01:24:38,320
0,90 90,150 150,300 300,360 360,420
for the rest of the

2562
01:24:38,320 --> 01:24:39,340
0,330 330,450 450,540 540,750 750,1020
semester,| that will show up,|
|它会出现的，|

2563
01:24:39,340 --> 01:24:40,180
0,300 300,480 480,660 660,690 690,840
and we'll talk a little
最后，我们将更多地讨论有关无锁编程的问题

2564
01:24:40,180 --> 01:24:41,080
0,150 150,300 300,510 510,750 750,900
bit more about lock free

2565
01:24:41,080 --> 01:24:42,970
0,510 510,600 600,750 750,1080 1380,1890
programming at the end| and
|看看在内核中是如何做到这一点的。

2566
01:24:43,000 --> 01:24:44,380
0,210 210,360 360,690 690,900 900,1380
see how that's done in

2567
01:24:44,380 --> 01:24:45,360
0,570
kernels.|
|

2568
01:24:45,580 --> 01:24:46,960
0,450 480,720 720,990 990,1080 1080,1380
Okay, so let me stop
好的，让我停在这里，

2569
01:24:46,960 --> 01:24:48,670
0,420 780,960 960,1080 1080,1470 1470,1710
here,| so that anybody who
|所以任何必须去别的地方的人都可以去，

2570
01:24:48,670 --> 01:24:49,630
0,150 150,210 210,450 450,720 720,960
has to go somewhere else

2571
01:24:49,630 --> 01:24:50,710
0,150 150,750 750,900 900,960 960,1080
can go,| but if you
|不过，如果您还有什么问题，请随时提出来。

2572
01:24:50,710 --> 01:24:52,060
0,150 150,330 330,540 540,1020 1020,1350
have any more questions feel

2573
01:24:52,060 --> 01:24:53,230
0,360 390,660 660,870 870,1050 1050,1170
free, please feel free to

2574
01:24:53,230 --> 01:24:54,180
0,270 270,420
ask them.|
|

2575
01:24:54,820 --> 01:24:55,480
0,90 90,180 180,270 270,600 600,660
We have a question in
我们在聊天中有个问题，

2576
01:24:55,480 --> 01:24:57,430
0,120 120,510 780,1320 1530,1830 1830,1950
the chat,| {} isn't the
|击剑指导是不是没有必要，

2577
01:24:57,430 --> 01:24:59,530
0,270 270,840 840,1500 1500,1830 1830,2100
fence instruction unnecessary,| because the
|因为amoswap指令可以具有获取释放顺序。

2578
01:24:59,530 --> 01:25:01,270
0,360 360,750 750,1290 1290,1470 1470,1740
{amoswap -} instruction can have

2579
01:25:01,270 --> 01:25:03,340
0,120 120,570 570,930 930,1470
the acquire release ordering.|
|

2580
01:25:04,060 --> 01:25:06,190
0,300 300,870 900,1320 1320,1710 1740,2130
{} Yeah, {} okay, so
是的，好的，所以好的，所以有两件事，

2581
01:25:06,220 --> 01:25:08,080
0,450 450,930 990,1290 1290,1440 1440,1860
{} okay, so two things,|
|

2582
01:25:08,170 --> 01:25:10,600
0,240 240,1590 1590,1800 1800,2130 2130,2430
{} the {} sync instruction
编译器和硬件的同步指令都在那里。

2583
01:25:10,600 --> 01:25:11,650
0,180 180,510 510,570 570,630 630,1050
there both for the compiler

2584
01:25:11,650 --> 01:25:12,980
0,180 180,300 300,360 360,780
and for the hardware.|
|

2585
01:25:25,000 --> 01:25:26,140
0,180 180,360 360,630 630,930 960,1140
Yeah I'm jumping off {}
是的，我马上就要开始上班了，

2586
01:25:26,140 --> 01:25:27,130
0,120 120,330 330,600 600,870 870,990
to start office hours,| but
|但我认为还有更多的问题在讨论中。

2587
01:25:27,130 --> 01:25:27,820
0,90 90,300 300,450 450,570 570,690
I think there's still more

2588
01:25:27,820 --> 01:25:29,470
0,390 390,450 450,630 630,1530 1530,1650
questions in the.| {How,do} you
|您如何只为编译器做这件事呢？

2589
01:25:29,470 --> 01:25:30,430
0,120 120,210 210,330 330,420 420,960
do it for the compiler

2590
01:25:30,430 --> 01:25:31,420
0,450
only?|
|

2591
01:25:31,480 --> 01:25:34,030
0,780 1080,1890 1890,1980 1980,2310 2310,2550
{} The {} compiler knows
编译器知道正在编译的是哪个体系结构

2592
01:25:34,030 --> 01:25:36,100
0,210 210,690 690,780 780,1320 1830,2070
which architecture is compiling| and
|所以我们会知道它什么时候必须确保合适的栅栏

2593
01:25:36,100 --> 01:25:36,970
0,120 120,300 300,420 420,660 660,870
so we will know when

2594
01:25:36,970 --> 01:25:38,410
0,180 180,450 450,630 630,720 720,1440
it actually has to ensure

2595
01:25:38,410 --> 01:25:40,690
0,150 150,540 540,1080 1350,1920 1920,2280
the appropriate fences| for whatever
|无论运行在哪种体系结构上

2596
01:25:40,690 --> 01:25:41,890
0,540 540,630 630,900 900,1110 1110,1200
architecture is running on| and
|不管是哪种内存一致性模型，它都有。

2597
01:25:41,890 --> 01:25:43,570
0,360 360,630 630,1170 1170,1500 1500,1680
whatever memory consistency model, it

2598
01:25:43,570 --> 01:25:44,400
0,420
has.|
|

2599
01:25:44,740 --> 01:25:45,640
0,240 240,390 390,570 570,690 690,900
So this gets a little
所以这会引起更复杂的讨论

2600
01:25:45,640 --> 01:25:46,960
0,120 120,270 270,720 720,1200 1200,1320
bit more complicated discussion| is
|就是每个硬件都有一个内存模型

2601
01:25:46,960 --> 01:25:47,980
0,150 150,360 360,540 540,600 600,1020
that every piece of hardware

2602
01:25:47,980 --> 01:25:50,590
0,360 360,1080 1080,1320 1320,1830 2160,2610
has a memory model| and
|编译器决定，给定特定架构的内存模型，

2603
01:25:51,040 --> 01:25:53,230
0,90 90,540 540,690 690,1080 1500,2190
the compilers {decide -} {}

2604
01:25:53,230 --> 01:25:54,220
0,150 150,300 300,600 600,720 720,990
you know given the memory

2605
01:25:54,220 --> 01:25:56,080
0,510 600,810 810,960 960,1350 1350,1860
model for that particular architecture,|
|

2606
01:25:56,080 --> 01:25:57,190
0,180 180,630 630,750 750,930 930,1110
what actually can do what
它实际上可以做它不能做的事情。

2607
01:25:57,190 --> 01:25:58,280
0,90 90,420 420,600
it cannot do.|
|

2608
01:25:59,440 --> 01:26:00,550
0,150 150,390 390,630 630,720 720,1110
And I guess my question
我想我的问题是

2609
01:26:00,550 --> 01:26:02,770
0,210 210,600 660,1230 1320,1770 1770,2220
was that| like defense instruction
如果你把amoswap叫做amoswap，

2610
01:26:02,770 --> 01:26:04,690
0,180 180,660 660,1590 1590,1770 1770,1920
only becomes unnecessary, if you

2611
01:26:04,690 --> 01:26:06,460
0,240 240,540 540,1260
call {amoswap -},|
|

2612
01:26:06,610 --> 01:26:09,310
0,840 870,1110 1110,1410 1410,1920 1980,2700
like [dot w dot] release,|
就像[.w.]释放，|

2613
01:26:09,400 --> 01:26:13,240
0,600 1080,2130 2400,3300
{} and {}
就像把同步放进去，然后那里就会同步，

2614
01:26:14,370 --> 01:26:16,740
0,690 720,1050 1050,1230 1230,1770
like putting in the

2615
01:26:16,740 --> 01:26:18,840
0,240 540,1230 1260,1500 1500,1890 1890,2100
the sync and there that

2616
01:26:18,840 --> 01:26:20,550
0,120 120,450 450,690 690,1230 1530,1710
will sync,| but the you
|但是你知道编译器的顺序，然后是。

2617
01:26:20,550 --> 01:26:22,650
0,120 120,270 270,1110 1110,1830 1830,2100
know the compiler ordering and

2618
01:26:22,650 --> 01:26:24,460
0,600 600,1260
then the.|
|

2619
01:26:24,460 --> 01:26:27,010
0,660 870,1500 1530,1920 1920,2370 2370,2550
Yeah.| The memory ordering and
嗯。|内存排序和无序。

2620
01:26:27,010 --> 01:26:29,200
0,300 300,450 450,510 510,1230 1680,2190
the out of ordering.| Yeah.|
|嗯。|

2621
01:26:29,230 --> 01:26:30,760
0,570 570,810 810,870 870,1080 1080,1530
Machinery using the fence instruction
使用栅栏说明的机器也是如此，

2622
01:26:30,760 --> 01:26:32,110
0,150 150,540 540,630 630,870 870,1350
as well,| the fence instructions
|栅栏指令只在您执行[.rl]的情况下是不必要的，

2623
01:26:32,110 --> 01:26:33,550
0,330 330,990 990,1080 1080,1170 1170,1440
only unnecessary in the case

2624
01:26:33,550 --> 01:26:35,230
0,150 150,360 420,750 840,1230 1230,1680
that you do [dot rl],|
|

2625
01:26:35,230 --> 01:26:36,130
0,300 300,480 480,690 690,810 810,900
so it seems like it
所以看起来它不会检测到这一点，

2626
01:26:36,130 --> 01:26:37,510
0,330 330,750 750,1050 1050,1230 1230,1380
wouldn't detect that,| so how
|那么你会怎么做呢，

2627
01:26:37,510 --> 01:26:39,100
0,150 150,300 300,450 450,720 1020,1590
would you do it,| so
|因此编译器在其末端强制排序，

2628
01:26:39,100 --> 01:26:41,620
0,150 150,1110 1350,1920 1920,2040 2040,2520
the compiler enforces the ordering

2629
01:26:41,620 --> 01:26:43,570
0,120 120,330 330,720 1050,1710 1740,1950
on its end,| but you
|但您已经使用[]LIKE进行了介绍。

2630
01:26:43,570 --> 01:26:45,640
0,240 240,600 600,810 960,1560 1800,2070
already cover it using the

2631
01:26:45,640 --> 01:26:48,610
0,390 840,1200 1230,1680 1680,2280 2280,2970
[] like.| Yeah, you {}
|是的，你问得很好，

2632
01:26:48,640 --> 01:26:50,530
0,480 480,600 600,1020 1050,1470 1470,1890
very good question,| {} and
|你知道更复杂的需求实现会是，

2633
01:26:50,530 --> 01:26:52,360
0,120 120,270 300,630 630,1260 1260,1830
you know more sophisticated requirements

2634
01:26:52,360 --> 01:26:54,610
0,570 570,750 750,1110 1110,1800 1860,2250
implementation would be,| {} we
|我们就像是专业的，

2635
01:26:54,610 --> 01:26:57,140
0,450 480,720 750,1470 1470,2190
were like specialized {},|
|

2636
01:26:57,140 --> 01:26:58,880
0,270 270,810 810,1110 1110,1560 1560,1740
{} acquire {and,release} implementation where
获取并发布针对RISC-V实施的实施，

2637
01:26:58,970 --> 01:27:00,140
0,510 510,630 630,810 810,930 930,1170
implementation for {RISC-V -},| we
|我们可能会做比我们做的更复杂的事情，

2638
01:27:00,140 --> 01:27:01,730
0,300 300,450 450,660 660,1350 1350,1590
probably do more sophisticated things

2639
01:27:01,730 --> 01:27:02,960
0,150 150,300 300,660 660,930 930,1230
than we do,| a pretty
|仅仅发布防御指令就是一个相当粗糙的颗粒。

2640
01:27:02,960 --> 01:27:04,280
0,300 300,600 600,780 780,960 960,1320
coarse grain by just issuing

2641
01:27:04,280 --> 01:27:05,680
0,390 390,870
defense instruction.|
|

2642
01:27:05,800 --> 01:27:09,520
0,480 600,1410 1590,2190 2310,3120 3390,3720
Um the, {} the but
嗯，这个，但是有点复杂，

2643
01:27:09,520 --> 01:27:11,770
0,120 120,390 390,1050 1080,1800 1890,2250
it's slightly complicated,| {} yeah,
|是的，所以如果你对这个感兴趣，

2644
01:27:11,770 --> 01:27:14,110
0,540 600,870 870,1770 1800,2160 2160,2340
so if you're interested in

2645
01:27:14,110 --> 01:27:16,690
0,510 540,1170 1380,1860 1860,2190 2190,2580
this,| {} the memory model
|RISC-V的内存模型非常复杂，

2646
01:27:16,690 --> 01:27:18,640
0,180 180,420 420,870 900,1530 1530,1950
for {RISC-V -} is {}

2647
01:27:18,940 --> 01:27:20,500
0,600 600,1170 1170,1380 1380,1470 1470,1560
really complicated,| so if you
|所以如果你看一下操作手册中的非特权指令，

2648
01:27:20,500 --> 01:27:23,200
0,210 210,330 330,1140 1170,1770 1770,2700
look at the instruction manual

2649
01:27:23,200 --> 01:27:25,210
0,450 450,900 930,1410 1410,1920 1920,2010
for the unprivileged instructions,| as
|作为专门介绍内存排序的整章

2650
01:27:25,210 --> 01:27:27,820
0,60 60,270 270,840 1170,2190 2430,2610
a whole chapter dedicated to

2651
01:27:27,820 --> 01:27:29,740
0,420 420,990 990,1440 1470,1830 1830,1920
memory ordering| and tells you
|告诉你在这种情况下编译器应该做什么。

2652
01:27:29,740 --> 01:27:30,370
0,120 120,240 240,420 420,480 480,630
what they have to, put

2653
01:27:30,370 --> 01:27:31,600
0,60 60,420 420,600 600,870
the compiler should do

2654
01:27:31,890 --> 01:27:34,410
0,1380 1380,1650 1650,1800 1800,2100 2100,2520
{} in this particular case.|
|

2655
01:27:37,760 --> 01:27:38,630
0,180 180,330 330,570 570,660 660,870
So you're saying that the
所以你的意思是编译器会注意到这一事实，

2656
01:27:38,630 --> 01:27:40,250
0,510 510,720 720,990 990,1290 1380,1620
compiler would pick up on

2657
01:27:40,250 --> 01:27:41,180
0,120 120,390 390,540 540,630 630,930
the fact,| that we just
|我们只是把汇编指令放在里面，

2658
01:27:41,180 --> 01:27:43,190
0,180 180,480 660,1110 1110,1650 1650,2010
put that assembly instruction inside

2659
01:27:43,190 --> 01:27:44,660
0,60 60,540 570,900 900,1110 1110,1470
of there,| and it wouldn't
|而且它本身不会对任何内存访问进行重新排序。

2660
01:27:44,660 --> 01:27:46,010
0,660 660,870 870,960 960,1050 1050,1350
reorder any of the memory

2661
01:27:46,010 --> 01:27:48,320
0,450 450,660 660,1020 1110,1680 1680,2310
accesses on {its,own}.| Sorry, the
|对不起，同步这个，这个同步库函数是库函数对

2662
01:27:48,650 --> 01:27:51,350
0,840 840,1260 1260,1710 1740,2280 2280,2700
synchronize this, this synchronized library

2663
01:27:51,350 --> 01:27:52,550
0,330 330,420 420,480 480,810 810,1200
function is a library function

2664
01:27:52,640 --> 01:27:53,720
0,270 270,450 450,570 570,630 630,1080
right,| it can be implemented
|它可以通过不同的方式实现。

2665
01:27:53,720 --> 01:27:54,940
0,90 90,390 390,810
in different ways.|
|

2666
01:27:55,030 --> 01:27:56,440
0,600 600,900 900,1020 1020,1080 1080,1410
{} And this is one
这是一个特殊的实现。

2667
01:27:56,440 --> 01:27:58,020
0,360 360,1020
particular implementation.|
|

2668
01:27:58,440 --> 01:27:59,760
0,330 330,570 570,930 930,1200 1200,1320
And the library function is
并且库函数由编译器提供。

2669
01:27:59,760 --> 01:28:01,320
0,330 330,420 420,480 480,1050
provided by the compiler.|
|

2670
01:28:02,610 --> 01:28:03,690
0,270 270,570 570,720 720,870 870,1080
{} But is there like
但是有没有类似于编译器进行优化的选项，

2671
01:28:03,690 --> 01:28:05,010
0,120 120,570 570,690 690,750 750,1320
the option for the compiler

2672
01:28:05,010 --> 01:28:06,840
0,120 120,480 480,1290 1290,1620 1620,1830
to do optimization,| where it
|在那里它自己移动货物和存储。

2673
01:28:06,840 --> 01:28:08,610
0,570 570,1050 1050,1320 1320,1650 1650,1770
itself moves the loads and

2674
01:28:08,610 --> 01:28:10,040
0,330 330,840
stores around.|
|

2675
01:28:10,560 --> 01:28:12,660
0,180 180,630 840,1170 1170,1560 1920,2100
{} Yes, compilers do.| So
是的，编译器需要。|那么你如何在不发出防御指令的情况下防止这种情况发生，

2676
01:28:12,660 --> 01:28:14,040
0,120 120,210 210,390 390,900 900,1380
how do you prevent that

2677
01:28:14,040 --> 01:28:16,530
0,510 510,810 810,1230 1260,2040 2070,2490
without emitting defense instruction,| that's
|令人好奇的是。

2678
01:28:16,530 --> 01:28:18,030
0,300 300,510 510,900 900,1140 1140,1500
curious about.| I guess what
|我想我要说的是，

2679
01:28:18,030 --> 01:28:20,520
0,240 240,600 600,720 720,1320 1710,2490
I'm saying is that {},|
|

2680
01:28:20,800 --> 01:28:22,540
0,210 210,660 660,1200 1260,1650 1650,1740
and maybe {} what I'm
也许我想说的是，基本上，

2681
01:28:22,540 --> 01:28:23,680
0,210 210,300 300,420 420,810 810,1140
saying is that basically the,|

2682
01:28:24,470 --> 01:28:26,720
0,300 300,960 960,1050 1050,1920 1920,2250
this indication the synchronized basically
该指示基本上同步告诉编译器和硬件，

2683
01:28:26,720 --> 01:28:27,650
0,240 240,450 450,510 510,840 840,930
both tells the compiler and

2684
01:28:27,650 --> 01:28:28,820
0,420 420,510 510,570 570,1020 1020,1170
hardware,| but the compiler could
|但是编译器实际上可以以不同的方式实现同步同步，

2685
01:28:28,820 --> 01:28:30,860
0,240 240,570 570,1080 1110,1590 1590,2040
actually implement sync synchronize differently,|
|

2686
01:28:30,860 --> 01:28:31,790
0,180 180,540 540,630 630,720 720,930
it knows that it can't
它知道它不能移动东西，

2687
01:28:31,790 --> 01:28:33,080
0,210 210,420 420,870 1110,1230 1230,1290
move things around,| but it
|但它没有RISC-V上的发布和围栏说明，

2688
01:28:33,080 --> 01:28:34,010
0,240 240,450 450,510 510,810 810,930
doesn't have the issue and

2689
01:28:34,010 --> 01:28:35,060
0,240 240,690 690,780 780,870 870,1050
fence instruction on the {RISC-V

2690
01:28:35,060 --> 01:28:36,560
0,330 330,510 510,1050 1230,1440 1440,1500
-},| it knew that it
|它知道它在RISC-V上以一种特殊的方式运行。

2691
01:28:36,560 --> 01:28:37,550
0,150 150,510 510,600 600,660 660,990
was running in a particular

2692
01:28:37,550 --> 01:28:38,880
0,210 210,330 330,510 510,900
way on {RISC-V -}.|
|

2693
01:28:42,060 --> 01:28:43,830
0,810 840,990 990,1290 1290,1500 1500,1770
{} But isn't the {RISC-V
但是RISC-V内存模型像[宽松]还不够吗

2694
01:28:43,830 --> 01:28:46,080
0,900 930,1380 1380,1800 1800,2040 2040,2250
-} memory model like [loose]

2695
01:28:46,080 --> 01:28:47,190
0,450 450,570 570,840 840,930 930,1110
enough| to where the out
|到了失灵的机器可以重组东西的地方，

2696
01:28:47,190 --> 01:28:49,710
0,90 90,600 690,1500 1500,1800 1800,2520
of order machinery could reorganize

2697
01:28:49,710 --> 01:28:51,510
0,450 450,870 870,1170 1290,1500 1500,1800
stuff,| so you do need
|所以你确实需要像收购一样，这就是拥有的全部意义。

2698
01:28:51,510 --> 01:28:53,260
0,210 210,330 330,1290
like the acquire,

2699
01:28:53,410 --> 01:28:54,580
0,270 480,690 690,750 750,930 930,1170
it's like the whole point

2700
01:28:54,580 --> 01:28:58,880
0,60 60,570 630,3210
of having.| Okay,
|好的，还有更复杂的接口同步同步，

2701
01:28:59,370 --> 01:29:01,410
0,180 180,420 420,960 960,1410 1410,2040
there more complicated interfaces syn-

2702
01:29:01,410 --> 01:29:02,600
0,720
synchronize,|
|

2703
01:29:03,120 --> 01:29:04,680
0,450 450,930 930,1290 1290,1500 1500,1560
{} and which give the
这给了编译器编写者更多的空间，给了程序员更多的自由

2704
01:29:04,680 --> 01:29:06,390
0,360 360,750 750,1320 1320,1560 1560,1710
compiler writer more gives the

2705
01:29:06,510 --> 01:29:07,920
0,510 510,750 750,1140 1140,1290 1290,1410
programmer more freedom| and we'll
|我们将获得编译器，并将编译器部分和处理器部分解耦。

2706
01:29:07,920 --> 01:29:09,750
0,150 150,240 240,810 810,1260 1320,1830
get the compiler and decouple

2707
01:29:09,750 --> 01:29:10,860
0,90 90,510 510,810 810,1020 1020,1110
the compiler part and the

2708
01:29:10,860 --> 01:29:12,160
0,450 450,840
processor part.|
|

2709
01:29:13,000 --> 01:29:13,930
0,360 360,420 420,690 690,780 780,930
So, for example I think
举个例子，我认为有一面旗帜你可以传进去，

2710
01:29:13,930 --> 01:29:15,340
0,180 180,270 270,600 600,750 750,1410
there's a flag you {can,pass,in},|
|

2711
01:29:15,340 --> 01:29:16,090
0,120 120,270 270,360 360,600 600,750
you know to say that
你知道要说有一个一致的同步版本。

2712
01:29:16,090 --> 01:29:18,520
0,150 150,300 300,510 510,1290 1320,2430
there's a release consistent {}

2713
01:29:18,520 --> 01:29:19,700
0,720
synchronize.|
|

2714
01:29:19,970 --> 01:29:21,530
0,810 810,990 990,1140 1140,1320 1320,1560
{} You know I I
你知道我我不知道细节，就在我脑子里，

2715
01:29:21,530 --> 01:29:22,730
0,180 180,480 480,600 600,1020 1020,1200
don't know the details, right

2716
01:29:22,730 --> 01:29:23,990
0,60 60,120 120,300 300,750 750,1260
out of my head {},|
|

2717
01:29:23,990 --> 01:29:24,680
0,150 150,240 240,330 330,510 510,690
but you can look into
但你可以调查一下这个，

2718
01:29:24,680 --> 01:29:26,540
0,420 720,1320 1350,1620 1620,1710 1710,1860
this,| {} this is {}
|这是粗粒度界面

2719
01:29:26,540 --> 01:29:27,860
0,90 90,660 660,1140 1140,1260 1260,1320
the coarse-grained interface| and a
|以及更细粒度的接口，让程序员有更多的控制权。

2720
01:29:27,860 --> 01:29:29,450
0,240 240,750 750,1230 1230,1410 1410,1590
more fine-grained interfaces that give

2721
01:29:29,450 --> 01:29:30,980
0,60 60,450 450,630 630,1050
the programmer more control.|
|

2722
01:29:31,300 --> 01:29:32,360
0,570
Okay,
好的谢谢。

2723
01:29:32,770 --> 01:29:33,860
0,240 240,480
thank you.|
|

2724
01:29:35,660 --> 01:29:37,520
0,330 330,510 510,780 780,930 930,1860
{} I have [a question],|
我有[一个问题]，|

2725
01:29:37,520 --> 01:29:39,740
0,330 330,720 750,1530 1800,2130 2130,2220
one is, {} how do
一个是，您喜欢拥有多个线程和一个处理器吗

2726
01:29:39,740 --> 01:29:42,350
0,240 240,630 630,1140 1170,2070 2100,2610
you like for having multiple

2727
01:29:42,350 --> 01:29:44,600
0,450 450,540 540,960 1020,1830 1860,2250
threads and one processor| do
|争论的方式与我们对多处理器的争论大致相同。

2728
01:29:44,600 --> 01:29:46,100
0,480 480,750 750,1110 1110,1230 1230,1500
argue in roughly the same

2729
01:29:46,100 --> 01:29:47,720
0,300 300,780 810,900 900,1200 1200,1620
way as we did for

2730
01:29:47,780 --> 01:29:50,500
0,780 1020,2280
multiple processors.|
|

2731
01:29:50,920 --> 01:29:54,310
0,2520 2520,2640 2640,2880 2880,3000 3000,3390
Can you repeat that question
你能重复一下那个问题吗？只是为了确认一下。

2732
01:29:54,310 --> 01:29:55,780
0,120 120,180 180,300 300,900
just to make sure.|
|

2733
01:29:56,700 --> 01:29:58,830
0,450 450,1170 1440,1680 1680,1980 2010,2130
So {we,didn't}, I think I
所以我们没有，我想我们并没有真正谈到多线程，

2734
01:29:58,830 --> 01:29:59,790
0,180 180,330 330,420 420,630 630,960
don't think we really talked

2735
01:29:59,790 --> 01:30:02,160
0,300 300,750 750,1410 1410,1920 1950,2370
about multiple threads,| we mostly
|我们主要讨论的是多CPU，

2736
01:30:02,160 --> 01:30:03,870
0,240 240,390 390,780 780,1380 1380,1710
talked about multiple {CPUs -},|
|

2737
01:30:04,140 --> 01:30:07,020
0,540 570,1080 1110,1590 1590,2310 2340,2880
so for multiple threads is
所以对于多线程来说，

2738
01:30:07,020 --> 01:30:08,610
0,630 720,1050 1050,1050 1050,1440 1440,1590
the,| {} I guess the
|我想解决方案与您拥有多个CPU时的解决方案相同，

2739
01:30:08,610 --> 01:30:09,880
0,840
solution

2740
01:30:09,970 --> 01:30:12,580
0,240 240,810 840,1680 1740,2370 2400,2610
the same as for when

2741
01:30:12,580 --> 01:30:13,720
0,120 120,360 360,720 720,1050 1050,1140
you have multiple {CPUs -},|
|

2742
01:30:13,720 --> 01:30:14,860
0,240 240,360 360,810 840,1050 1050,1140
like do you have the
比如，你们在那里有没有同样的论点。

2743
01:30:14,860 --> 01:30:17,320
0,240 240,720 720,1230 1620,2370 2370,2460
same arguments there.| More or
|或多或少至少在概念上是正确的思考方式，

2744
01:30:17,320 --> 01:30:19,510
0,540 570,1140 1170,1590 1590,2070 2070,2190
less {} {at,least} conceptually is

2745
01:30:19,510 --> 01:30:20,170
0,60 60,270 270,390 390,480 480,660
the right way to think

2746
01:30:20,170 --> 01:30:21,850
0,270 270,480 540,1260 1260,1560 1560,1680
about it,| {} so you
|所以你有多个线程，

2747
01:30:21,850 --> 01:30:23,500
0,120 120,480 480,1080 1110,1440 1440,1650
have multiple threads,| but only
|但是只有一个CPU，还是这样

2748
01:30:23,500 --> 01:30:26,110
0,240 240,990 1380,2070 2070,2430 2430,2610
one CPU, {} it's still

2749
01:30:26,110 --> 01:30:26,860
0,60 60,390 390,510 510,600 600,750
the case| that you want
|您希望确保以原子方式执行某些内核代码序列。

2750
01:30:26,860 --> 01:30:28,510
0,60 60,420 420,540 540,930 930,1650
to ensure that certain {}

2751
01:30:28,630 --> 01:30:30,250
0,390 390,630 630,1020 1020,1170 1170,1620
kernel code sequences are executed

2752
01:30:30,250 --> 01:30:31,320
0,420 420,660
{atomically -}.|
|

2753
01:30:31,550 --> 01:30:33,770
0,840 840,1470 1470,1830 1830,2010 2010,2220
{} And so you still
所以你仍然需要有一个临界区的概念。

2754
01:30:33,770 --> 01:30:34,640
0,210 210,330 330,570 570,600 600,870
have to have a notion

2755
01:30:34,640 --> 01:30:36,100
0,60 60,360 360,960
of critical sections.|
|

2756
01:30:36,100 --> 01:30:37,870
0,660 900,1110 1110,1320 1320,1530 1530,1770
{} You might not need
您可能不需要显式锁定或释放，

2757
01:30:37,870 --> 01:30:39,940
0,510 510,840 840,1170 1170,1890 1890,2070
locks or releases explicitly,| but
|但是您确实需要一种打开和关闭中断的方法

2758
01:30:39,940 --> 01:30:40,720
0,90 90,270 270,480 480,570 570,780
you do need a way

2759
01:30:40,720 --> 01:30:42,160
0,300 300,630 630,780 780,1200 1200,1440
of turning on interrupts off

2760
01:30:42,160 --> 01:30:43,150
0,90 90,480 480,570 570,630 630,990
and on| in a particular
|在特定的一段代码中。

2761
01:30:43,150 --> 01:30:44,300
0,180 180,240 240,660
piece of code.|

2762
01:30:44,670 --> 01:30:45,540
0,360 360,510 510,570 570,690 690,870
{} So if you look
因此，如果您查看较旧的操作系统内核，

2763
01:30:45,540 --> 01:30:48,360
0,210 570,1620 1620,2010 2010,2280 2280,2820
at older operating system kernels,|
|

2764
01:30:48,360 --> 01:30:49,830
0,210 210,570 570,870 870,1170 1170,1470
they typically don't have really
它们通常在内核中没有真正的锁定获取，

2765
01:30:49,830 --> 01:30:52,020
0,390 390,1110 1440,1920 1920,2100 2100,2190
locking acquire {} in the

2766
01:30:52,020 --> 01:30:53,340
0,330 330,570 570,690 690,1170 1170,1320
kernel,| because they assume they're
|因为他们认为他们在一个处理器上运行，

2767
01:30:53,340 --> 01:30:54,660
0,240 240,330 330,390 390,690 690,1320
running on a single processor,|
|

2768
01:30:54,810 --> 01:30:55,980
0,270 270,390 390,570 570,840 840,1170
but they do have something
但是他们确实有像锁这样的东西，

2769
01:30:55,980 --> 01:30:57,150
0,180 180,630 630,720 720,870 870,1170
like locks,| you know to
|您知道，基本上要关闭中断，然后打开和关闭中断。

2770
01:30:57,150 --> 01:30:59,130
0,420 420,690 690,930 930,1470 1470,1980
basically turn off interruption and

2771
01:30:59,130 --> 01:31:00,140
0,570
interrupt

2772
01:31:00,400 --> 01:31:01,620
0,240 240,330 330,720
on and off.|
|

2773
01:31:03,460 --> 01:31:05,380
0,540 540,720 720,1200 1500,1770 1770,1920
Okay I see,| {} and
好的，我明白了，|我的另一个问题是，

2774
01:31:05,380 --> 01:31:08,320
0,150 150,420 420,1260 1320,1950 2040,2940
my other question was,| actually
|实际上是在带有UART图片的幻灯片上，缓冲区。

2775
01:31:08,320 --> 01:31:11,260
0,210 210,300 300,840 840,1380 2220,2940
on the slide with the

2776
01:31:11,290 --> 01:31:15,300
0,780 870,1770 1770,2430 2670,3570
uart picture, the buffer.|
|

2777
01:31:15,300 --> 01:31:16,740
0,870

2778
01:31:17,570 --> 01:31:19,430
0,810 840,1050 1050,1230 1230,1680 1680,1860
Yeah, is it, yeah that
是的，是不是，是的，就是那个，是不是一直都是这样的，阅读会像是落后一样，

2779
01:31:19,430 --> 01:31:20,900
0,360 390,660 660,1020 1020,1380 1380,1470
one, is it always the

2780
01:31:20,900 --> 01:31:22,940
0,360 360,780 780,1260 1290,1800 1830,2040
case that the read is

2781
01:31:22,940 --> 01:31:25,220
0,300 300,480 480,900 1170,1770 1770,2280
going to be like lagging

2782
01:31:25,220 --> 01:31:26,930
0,570 600,720 720,900 900,1350 1350,1710
behind,| I didn't understand that.|
|我不明白这一点。|

2783
01:31:27,170 --> 01:31:29,220
0,480 480,690 690,870 870,1560
Yeah, okay so good.|
是啊，好的很好。|

2784
01:31:29,400 --> 01:31:30,120
0,180 180,360 360,540 540,630 630,720
So this goes to the
所以这张照片放到了展示台上，

2785
01:31:30,120 --> 01:31:32,310
0,570 570,960 960,1050 1050,1560 1680,2190
display,| whatever is this basically
|不管这是什么，基本上这是字符序列，

2786
01:31:32,310 --> 01:31:33,030
0,180 180,300 300,390 390,660 660,720
this is the sequence of

2787
01:31:33,030 --> 01:31:33,960
0,450 450,570 570,750 750,810 810,930
characters,| that needs to go
|需要放到展台上。

2788
01:31:33,960 --> 01:31:35,360
0,120 120,210 210,840
to the display.|
|

2789
01:31:36,730 --> 01:31:38,620
0,660 660,990 990,1140 1140,1530 1530,1890
{} And the writer basically
而作家基本上是靠越来越多的人物，对。

2790
01:31:38,620 --> 01:31:39,790
0,60 60,540 540,720 720,810 810,1170
is depending more and more

2791
01:31:39,790 --> 01:31:40,960
0,630
characters,

2792
01:31:41,770 --> 01:31:43,960
0,420 420,630 630,1290 1440,2040 2040,2190
right.| And so, {} so
|所以，所以编剧们走那条路

2793
01:31:43,960 --> 01:31:45,220
0,90 90,450 450,630 630,840 840,1260
the writers going that way|
|

2794
01:31:45,220 --> 01:31:46,810
0,540 540,930 930,1410 1410,1470 1470,1590
and the readers, you know
读者们，你知道，跟随作者的脚步，

2795
01:31:46,810 --> 01:31:48,790
0,540 540,630 630,1170 1530,1800 1800,1980
following the writer,| because you
|因为您不能打印尚未放入缓冲区的字符。

2796
01:31:48,790 --> 01:31:49,780
0,270 270,450 450,480 480,840 840,990
can't print a character that

2797
01:31:49,780 --> 01:31:51,310
0,270 270,840 840,1050 1050,1230 1230,1530
hasn't been put into buffer

2798
01:31:51,310 --> 01:31:52,140
0,300
yet.|
|

2799
01:31:52,260 --> 01:31:54,120
0,630 630,1080 1080,1290 1290,1680 1680,1860
{} And so let's you
让我们来认识一下把东西放到展台上的UART。

2800
01:31:54,120 --> 01:31:57,330
0,180 180,780 930,1440 1890,2580 2580,3210
know the the uart who

2801
01:31:57,330 --> 01:31:58,620
0,240 240,450 450,570 570,660 660,1290
puts things on the display.|
|

2802
01:32:02,340 --> 01:32:04,830
0,150 150,960 1290,1710 1710,2160 2160,2490
You will start basically putting
您将开始将这个插槽中的第一个字符放到显示器上，

2803
01:32:04,830 --> 01:32:06,420
0,330 330,840 840,900 900,1080 1080,1590
first characters in this slot

2804
01:32:06,450 --> 01:32:09,060
0,510 510,600 600,1260 1650,2430 2430,2610
onto the display,| meanwhile {printf
|同时，printf可能会有多个指纹，

2805
01:32:09,060 --> 01:32:10,140
0,150 150,330 330,510 510,720 720,1080
-} could come in multiple

2806
01:32:10,140 --> 01:32:11,460
0,300 300,480 480,900 930,990 990,1320
prints come in,| you know
|你知道他们在这里放了更多的角色，

2807
01:32:11,460 --> 01:32:12,630
0,150 150,360 360,570 570,1020 1020,1170
they put more characters in

2808
01:32:12,630 --> 01:32:13,620
0,360 390,540 540,660 660,780 780,990
here,| so that the right
|所以正确的指针间距站在这里

2809
01:32:13,620 --> 01:32:15,420
0,270 270,600 600,930 930,1410 1680,1800
pointer spacing standing here| and
|然后当显示一个字符时，

2810
01:32:15,420 --> 01:32:16,530
0,90 90,270 270,420 420,690 690,1110
then when there's one character

2811
01:32:16,530 --> 01:32:18,660
0,90 90,780 960,1620 1620,1680 1680,2130
is displayed,| then the uart
|然后，UART将向上移动该指针以显示下一个字符。

2812
01:32:18,660 --> 01:32:19,860
0,120 120,360 360,510 510,690 690,1200
will move up this pointer

2813
01:32:20,340 --> 01:32:21,540
0,120 120,450 450,540 540,750 750,1200
to display the next character.|
|

2814
01:32:22,430 --> 01:32:24,050
0,180 180,540 540,630 630,1020 1020,1620
The uart is always lagging
UART总是有点落后于作家，

2815
01:32:24,050 --> 01:32:26,900
0,90 90,300 300,1290 1410,2250 2280,2850
a little behind the writer,|
|

2816
01:32:26,930 --> 01:32:27,800
0,240 240,420 420,480 480,750 750,870
{until -} the point that
直到它迎头赶上，

2817
01:32:27,800 --> 01:32:29,210
0,90 90,420 420,750 780,1020 1020,1410
it catches up right,| then
|那么其中r和w是相同的，

2818
01:32:29,450 --> 01:32:30,620
0,420 420,660 660,780 780,1050 1050,1170
where r and w are

2819
01:32:30,620 --> 01:32:31,370
0,60 60,450 450,540 540,600 600,750
the same,| and at that
|在这一点上，基本上，这意味着缓冲区中不再有字符。

2820
01:32:31,370 --> 01:32:32,480
0,240 240,570 570,720 720,990 990,1110
point, basically, that means that

2821
01:32:32,480 --> 01:32:33,740
0,180 180,420 420,810 810,1200 1200,1260
there's no character anymore in

2822
01:32:33,740 --> 01:32:34,700
0,90 90,480
the buffer.|
|

2823
01:32:35,920 --> 01:32:37,000
0,270 270,540 540,690 690,900 900,1080
Oh okay I see, that
哦，好的，我明白了，这就说得通多了。

2824
01:32:37,000 --> 01:32:38,500
0,360 360,540 540,1020 1050,1320 1320,1500
makes that makes alot more

2825
01:32:38,500 --> 01:32:39,520
0,300 300,570 570,750 750,840 840,1020
sense.| Okay, thank you so
|好的，非常感谢。

2826
01:32:39,520 --> 01:32:41,380
0,540 900,1380
much.| {You're,welcome}.|
|不用谢。|

2827
01:32:42,850 --> 01:32:44,320
0,240 240,390 390,930
Any more questions?|
还有什么问题吗？|

2828
01:32:48,990 --> 01:32:50,760
0,210 210,390 390,690 690,990 1590,1770
Just us left here.| All
只有我们留在这里。|好的。

2829
01:32:50,760 --> 01:32:52,080
0,300
right.|
|

2830
01:32:53,680 --> 01:32:55,030
0,150 150,240 240,780 1050,1260 1260,1350
All you guys see you
你们等会儿见。

2831
01:32:55,030 --> 01:32:55,947
0,480
later.

