1
00:00:00,330 --> 00:00:03,360
0,1260 1260,1440 1440,1590 1590,1710 1710,3030
Yeah, we're not so good.|
是的，我们不是很好。|

2
00:00:06,650 --> 00:00:08,680
0,450 450,600 600,840 840,1440
Good, how about Erica,|
好的，那 Erica 呢，|

3
00:00:08,800 --> 00:00:10,160
0,150 150,270 270,630
{how's -} the
lazy 实验对你来说怎么样。

4
00:00:10,630 --> 00:00:11,590
0,240 240,360 360,510 510,630 630,960
{lazy -} lab for you.|
|

5
00:00:12,040 --> 00:00:13,090
0,330 330,330 330,810 810,990 990,1050
{} I also thought it
我也觉得还可以，

6
00:00:13,090 --> 00:00:14,530
0,120 120,540 540,840 990,1170 1170,1440
was okay| and {} I
|我也是在 copyin 和 copyout 有 bug ，

7
00:00:14,530 --> 00:00:15,610
0,240 240,450 450,510 510,900 900,1080
also had a bug with

8
00:00:15,610 --> 00:00:16,810
0,150 150,510 510,600 600,900 900,1200
the copyin and copyout {},|
|

9
00:00:16,810 --> 00:00:18,490
0,240 240,570 870,1080 1080,1230 1230,1680
but I got that result,
但我得到了结果，所以，还可以。

10
00:00:18,490 --> 00:00:20,700
0,390 780,1620
so yeah.|
|

11
00:00:20,700 --> 00:00:21,600
0,270 270,360 360,510 510,600 600,900
{I,think,it} is one of those
我想这是一种棘手的情况，

12
00:00:21,720 --> 00:00:22,650
0,270 270,570 570,660 660,750 750,930
tricky cases| that you might
|当你开始编程的时候，可能没有想到。

13
00:00:22,650 --> 00:00:23,520
0,180 180,360 360,600 600,750 750,870
not think about when you

14
00:00:23,520 --> 00:00:25,140
0,330 330,900
start programming.|
|

15
00:00:26,390 --> 00:00:27,770
0,240 240,720 720,990 990,1290 1290,1380
But, luckily {usertests -} will
但是，幸运的是， usertests 会为你找到它。

16
00:00:27,770 --> 00:00:29,260
0,210 210,330 330,540 540,720
find it for you.|
|

17
00:00:33,180 --> 00:00:35,440
0,600 930,1770
The, Caroline.|
Caroline 。|

18
00:00:37,580 --> 00:00:39,050
0,360 360,540 540,840 840,1080 1110,1470
{The,lab} is going good {},|
实验进行得很顺利，|

19
00:00:39,080 --> 00:00:41,060
0,270 270,660 660,1050 1050,1380 1380,1980
I haven't finished yet actually.|
实际上我还没有做完。|

20
00:00:41,960 --> 00:00:43,910
0,600 1020,1380 1380,1440 1440,1710 1710,1950
{} Alright, {} worry about
好的，我想要注意 copyin 。

21
00:00:43,910 --> 00:00:48,700
0,480 480,690 690,1080 1200,2160
copyin, I guess.| Yeah.|
|是的。|

22
00:00:52,560 --> 00:00:54,090
0,210 210,420 420,630 630,1020 1020,1530
How about {} Kendall Garner?|
Kendall Garner 怎么样？|

23
00:00:55,920 --> 00:00:57,030
0,420 450,720 720,810 810,900 900,1110
I think for the most
我想在很大程度上，

24
00:00:57,030 --> 00:00:59,190
0,360 360,570 1110,1650 1740,1860 1860,2160
part of the,| it was
|对我来说不算太糟，

25
00:00:59,250 --> 00:01:01,440
0,570 570,750 750,1260 1770,1950 1950,2190
not too bad for me,|
|

26
00:01:01,440 --> 00:01:02,820
0,420 420,510 510,840 840,1170 1170,1380
probably the weirdest [] was
可能试着解决的最奇怪的[]是，

27
00:01:02,820 --> 00:01:04,230
0,480 480,780 780,1140 1140,1260 1260,1410
trying to figure out| when
|当它低于堆栈的界限。

28
00:01:04,230 --> 00:01:06,450
0,120 120,450 570,1200 1230,2070 2070,2220
it went below bounds of

29
00:01:06,450 --> 00:01:07,440
0,120 120,570
the stack.|
|

30
00:01:07,440 --> 00:01:08,340
0,420

31
00:01:08,760 --> 00:01:10,020
0,420 420,930
{} Yeah,
是的，应该是它到达了守护页。

32
00:01:10,370 --> 00:01:11,270
0,240 240,450 450,540 540,630 630,900
{it -} to the guard

33
00:01:11,270 --> 00:01:12,680
0,300 300,810
page basically.|
|

34
00:01:16,760 --> 00:01:17,820
0,600
Good.|
好的。|

35
00:01:18,810 --> 00:01:21,300
0,600 630,1200 1410,1920 1920,2310 2310,2490
Okay, well it's about time
好的，差不多该开始了。

36
00:01:21,300 --> 00:01:22,660
0,90 90,210 210,720
to get started.|
|

37
00:01:22,820 --> 00:01:25,250
0,690 690,1020 1050,1680 1710,2130 2280,2430
{} So welcome to the
欢迎来到 6.S081 的下一节课，

38
00:01:25,250 --> 00:01:27,200
0,240 240,930 930,1050 1050,1440 1470,1950
next lecture, in the {6.S081

39
00:01:27,200 --> 00:01:29,090
0,420 540,1050 1050,1230 1230,1500 1500,1890
-},| wherever you are, whatever
|无论你在哪里，不管是什么时区。

40
00:01:29,090 --> 00:01:30,300
0,210 210,570
time zone.|
|

41
00:01:30,300 --> 00:01:31,540
0,720

42
00:01:31,540 --> 00:01:33,400
0,180 180,480 480,810 810,1170 1200,1860
So today's lecture is {about,locks}.|
所以，今天的课程是关于锁。|

43
00:01:33,940 --> 00:01:35,860
0,1020 1020,1380 1380,1620 1620,1710 1710,1920
{} You probably have seen
你们可能在之前的课上见过锁，

44
00:01:35,860 --> 00:01:37,870
0,390 390,750 750,1020 1050,1380 1380,2010
locks in {} previous classes,|
|

45
00:01:38,050 --> 00:01:39,880
0,690 690,990 990,1110 1110,1380 1410,1830
{} or at least being
或者至少以这样或那样的方式与它们接触，

46
00:01:39,880 --> 00:01:40,690
0,180 180,420 420,570 570,750 750,810
in touch with them in

47
00:01:40,690 --> 00:01:42,370
0,240 240,450 450,480 480,1440 1440,1680
some way or another,| and
|这节课是有点概念性的课程，

48
00:01:42,370 --> 00:01:43,360
0,180 300,570 570,780 780,840 840,990
so this lecture a little

49
00:01:43,360 --> 00:01:44,890
0,120 120,180 180,270 270,660 660,1530
bit of a conceptual lecture,|
|

50
00:01:44,890 --> 00:01:45,850
0,180 180,540 540,600 600,780 780,960
may overlap a little bit
可能与你之前见过的一些东西有些重叠，

51
00:01:45,850 --> 00:01:47,440
0,120 120,390 390,1020 1260,1470 1470,1590
with some {} things you've

52
00:01:47,440 --> 00:01:49,390
0,150 150,510 510,870 870,1290 1290,1950
seen {before -},| locks will
|锁将更关注内核和操作系统方面。

53
00:01:49,780 --> 00:01:50,470
0,180 180,210 210,360 360,510 510,690
have a little bit more

54
00:01:50,470 --> 00:01:51,580
0,90 90,270 270,690 690,810 810,1110
of {} kernel and OS

55
00:01:51,580 --> 00:01:52,500
0,570
[focus].|
|

56
00:01:52,560 --> 00:01:53,730
0,420 420,570 570,840 840,930 930,1170
And that changes a couple
这改变了几件事情。

57
00:01:53,730 --> 00:01:54,660
0,390
things.|
|

58
00:01:54,750 --> 00:01:56,970
0,600 660,1170 1170,1470 1470,1680 1680,2220
{} Just to get started,|
作为开始，|

59
00:01:57,000 --> 00:01:59,160
0,480 480,810 810,1410 1440,2010 2010,2160
let's remind ourselves why we
让我们提醒自己，为什么需要锁，

60
00:01:59,160 --> 00:02:01,500
0,270 270,810 900,1440 1920,2250 2250,2340
need locks,| { -} you
|我想我们的出发点是，

61
00:02:01,500 --> 00:02:02,400
0,180 180,390 390,570 570,660 660,900
know I guess the starting

62
00:02:02,400 --> 00:02:03,960
0,210 210,300 300,510 510,660 660,1560
point is really that| applications
|应用程序想要使用多个核心。

63
00:02:05,070 --> 00:02:06,330
0,660 750,990 990,1050 1050,1110 1110,1260
well want to {use -}

64
00:02:06,330 --> 00:02:07,680
0,330 330,840
multiple cores.|
|

65
00:02:12,190 --> 00:02:13,120
0,270 270,420 420,480 480,600 600,930
They want to use multiple
它们希望使用多核来获得性能。

66
00:02:13,120 --> 00:02:14,800
0,240 240,300 300,420 420,1110
cores to get performance.|
|

67
00:02:17,040 --> 00:02:18,000
0,180 180,300 300,390 390,480 480,960
And so if an application
所以，如果一个应用程序希望在多个核心上运行，

68
00:02:18,000 --> 00:02:20,760
0,480 480,870 870,870 2130,2400 2400,2760
actually { -} want to

69
00:02:20,760 --> 00:02:22,170
0,480 480,570 570,870 870,1230 1230,1410
run on multiple cores| and
|可能核心是应用程序调用系统调用的一部分，

70
00:02:22,170 --> 00:02:24,390
0,330 330,600 600,1680 1680,2100 2100,2220
[presumably] what's the cores are

71
00:02:24,390 --> 00:02:25,320
0,240 240,300 300,390 390,810 810,930
part of the application may

72
00:02:25,320 --> 00:02:27,030
0,300 300,540 540,1050 1260,1590 1590,1710
invoke system calls| and so
|所以内核必须能够处理，

73
00:02:27,030 --> 00:02:27,990
0,90 90,420 420,600 600,690 690,960
the kernel must be able

74
00:02:27,990 --> 00:02:29,320
0,120 120,720
to handle,|
|

75
00:02:31,320 --> 00:02:32,220
0,90 90,210 210,510 510,600 600,900
{} must handle {} parallel
必须处理并发系统调用。

76
00:02:32,220 --> 00:02:33,520
0,240 240,660
system calls.|
|

77
00:02:45,440 --> 00:02:46,910
0,480 480,600 600,780 780,1170 1170,1470
{} And that means that
这意味着系统调用在不同的核心上并行运行，

78
00:02:46,910 --> 00:02:48,590
0,120 120,270 270,930 930,1290 1290,1680
you know the system calls

79
00:02:48,590 --> 00:02:50,120
0,270 270,390 390,1020 1020,1230 1230,1530
run in parallel on different

80
00:02:50,120 --> 00:02:53,150
0,510 780,1410 1410,1620 1620,2220 2220,3030
cores,| they may actually access
|它们可能并行访问共享数据结构。

81
00:02:53,680 --> 00:02:55,500
0,360 360,570 570,1170
shared data structures,

82
00:02:58,360 --> 00:03:00,200
0,120 120,570 570,630 630,1290
data structures in parallel.|
|

83
00:03:04,390 --> 00:03:05,470
0,300 300,390 390,780 780,990 990,1080
And as you've seen by
就像你们已经在 alloc 看到过的，

84
00:03:05,470 --> 00:03:07,180
0,360 360,690 690,1020 1020,1350 1350,1710
{the,alloc},| actually {xv6 -} ask
|实际上 xv6 有相当多的共享数据结构，

85
00:03:07,180 --> 00:03:08,740
0,360 360,390 390,720 720,1020 1230,1560
quite a number of shared

86
00:03:08,740 --> 00:03:10,390
0,210 210,750 840,1230 1230,1350 1350,1650
data structures| what's the proc
|比如 proc 数据结构或 ticks ，

87
00:03:10,390 --> 00:03:13,270
0,660 660,1080 1620,2580 2580,2760 2760,2880
structures or {} you know

88
00:03:13,300 --> 00:03:16,480
0,480 480,1170 1200,1320 1320,1830 2760,3180
ticks| or you know later
|或者稍后我们会看到缓冲区，

89
00:03:16,480 --> 00:03:17,860
0,120 120,540 540,660 660,900 900,1380
we'll see the buffer cache,|

90
00:03:17,860 --> 00:03:18,880
0,60 60,210 210,420 420,810 810,1020
you know there's actually a
实际上有大量的共享数据结构。

91
00:03:18,880 --> 00:03:20,170
0,240 240,330 330,540 540,750 750,1290
ton of shared data structures.|
|

92
00:03:20,960 --> 00:03:23,090
0,600 600,1170 1170,1650 1770,1950 1950,2130
{} And so if you
所以，如果你并行访问一个数据结构，

93
00:03:23,090 --> 00:03:24,590
0,360 360,780 780,1260 1260,1380 1380,1500
have parallel access you know

94
00:03:24,590 --> 00:03:26,300
0,450 450,780 780,1020 1020,1560 1560,1710
to a data structure| in
|其中一个核心是写入者，

95
00:03:26,300 --> 00:03:28,580
0,240 240,330 330,1110 1680,2160 2160,2280
one of the cores are

96
00:03:28,580 --> 00:03:29,150
0,210 210,300 300,390 390,450 450,570
{writer -}| and the other
|其他是读取者，

97
00:03:29,150 --> 00:03:30,920
0,390 390,480 480,720 720,960 1260,1770
cores are {reader -} {}|
|

98
00:03:30,920 --> 00:03:32,420
0,150 150,270 270,540 540,900 900,1500
you know we basically blocks
我们阻塞来协调更新这些共享数据结构，

99
00:03:32,660 --> 00:03:34,130
0,90 90,750 750,930 930,1350 1350,1470
to coordinate these updates {}

100
00:03:34,130 --> 00:03:35,240
0,90 90,300 300,540 540,960 960,1110
to shared data structure,| so
|这样读取者看到一致的。

101
00:03:35,240 --> 00:03:37,160
0,390 690,930 930,1290 1290,1500 1500,1920
that {} readers see consistent

102
00:03:37,160 --> 00:03:37,880
0,270
view.|
|

103
00:03:38,310 --> 00:03:40,100
0,450 450,600 600,690 690,1260
So we need locks,
所以我们需要锁，来控制共享，保证正确共享。

104
00:03:41,070 --> 00:03:42,500
0,300 300,930
{you,know} to,

105
00:03:43,320 --> 00:03:45,120
0,360 360,750 750,1230
for control sharing,

106
00:03:45,520 --> 00:03:47,380
0,390 390,720 720,1320
for correct sharing.|
|

107
00:03:52,010 --> 00:03:54,110
0,630 930,1350 1350,1530 1530,1740 1740,2100
Now, {} this is {some,sence}
现在，这有点令人沮丧。

108
00:03:54,110 --> 00:03:54,830
0,270 270,450 450,570 570,660 660,720
a little bit of a

109
00:03:54,830 --> 00:03:55,860
0,480
bummer.|
|

110
00:03:55,860 --> 00:03:58,080
0,390 390,750 750,1470 1770,2070 2070,2220
{} Because we want these
因为我们想要并行访问，

111
00:03:58,080 --> 00:04:01,650
0,300 300,990 1380,1830 1860,2670 2670,3570
parallel access,| {we,want,to} run multiple
|我们想在不同的核心上并行运行多个一致的调用，

112
00:04:01,680 --> 00:04:04,440
0,420 420,780 780,1500 1560,2370 2370,2760
consistent calls in parallel on

113
00:04:04,440 --> 00:04:06,450
0,90 90,390 390,900 1260,1740 1770,2010
{} different cores,| {} but
|但不幸的是，如果它们共享数据结构，

114
00:04:06,450 --> 00:04:08,460
0,630 630,1140 1140,1530 1530,1710 1710,2010
unfortunately, {} if they share

115
00:04:08,460 --> 00:04:10,020
0,420 420,990 990,1170 1170,1380 1380,1560
data structures,| {you,know} they need
|它们需要锁，

116
00:04:10,020 --> 00:04:11,610
0,480 480,660 660,1080 1080,1230 1230,1590
locks,| and locks {you,know} {serialize
|而锁序列化操作，

117
00:04:11,610 --> 00:04:14,370
0,480 510,1260 1260,2010 2310,2490 2490,2760
-} basically operations| and so
|所以，实际上，锁最终会限制性能。

118
00:04:14,370 --> 00:04:15,510
0,90 90,420 570,720 720,840 840,1140
in fact you know {locks,in}

119
00:04:15,510 --> 00:04:17,160
0,150 150,330 330,690 690,960 960,1650
the end can limit performance.|
|

120
00:04:27,320 --> 00:04:27,860
0,120 120,240 240,330 330,480 480,540
And so we're sort of
所以我们现在的情况有些微妙，

121
00:04:27,860 --> 00:04:29,390
0,90 90,300 300,570 570,1050 1050,1530
in a tricky situation,| where
|为了正确，我们需要锁，

122
00:04:29,390 --> 00:04:30,380
0,90 90,300 300,390 390,840 840,990
you know for correctness, we

123
00:04:30,380 --> 00:04:31,700
0,210 210,690 690,810 810,1050 1050,1320
need locks,| you know, but
|但对于性能来说，它们不是很好。

124
00:04:31,700 --> 00:04:33,290
0,90 90,870 960,1170 1170,1380 1380,1590
for performance, {} they're not

125
00:04:33,290 --> 00:04:34,160
0,300
good.|
|

126
00:04:34,600 --> 00:04:36,070
0,450 480,780 780,900 900,1020 1020,1470
{} But you know there's
但是，这就是实际情况，

127
00:04:36,070 --> 00:04:36,910
0,120 120,180 180,420 420,540 540,840
going to be a fact

128
00:04:36,910 --> 00:04:39,460
0,90 90,510 510,1380 1410,1770 1770,2550
of life| and we'll see
|我们看看能做些什么。

129
00:04:39,760 --> 00:04:40,750
0,300 300,390 390,600 600,840 840,990
what can do about it.|
|

130
00:04:41,300 --> 00:04:42,170
0,390 390,540 540,660 660,780 780,870
{} But that's sort of
但这是最高级别的场景，

131
00:04:42,170 --> 00:04:44,030
0,300 300,570 570,960 960,1410 1440,1860
the top level {} scenario

132
00:04:44,030 --> 00:04:45,800
0,450 720,1080 1080,1200 1200,1350 1350,1770
here| and you know maybe
|也许带来了这一点，

133
00:04:45,800 --> 00:04:47,810
0,270 270,750 780,1290 1290,1380 1380,2010
just to really you know

134
00:04:47,840 --> 00:04:49,610
0,390 390,780 780,1080 1080,1230 1230,1770
brings {this,point},| why do applications
|为什么应用程序需要多个核心，

135
00:04:49,610 --> 00:04:51,710
0,240 240,450 450,600 960,1680 1680,2100
actually want {} multiple cores|
|

136
00:04:51,920 --> 00:04:52,790
0,180 180,480 480,660 660,810 810,870
and that really has to
这与技术趋势有关，

137
00:04:52,790 --> 00:04:54,650
0,150 150,510 510,690 690,1350 1350,1860
do with {you,know} technology trends,|
|

138
00:04:54,650 --> 00:04:55,520
0,120 120,240 240,450 450,540 540,870
you know over the last
在过去的几十年里，

139
00:04:55,640 --> 00:04:56,900
0,240 240,840
couple decades,|
|

140
00:04:56,900 --> 00:04:57,830
0,240 240,540 540,660 660,750 750,930
{} and you know there's
有一些经典的图表，

141
00:04:57,830 --> 00:04:59,330
0,150 150,210 210,330 330,960 960,1500
sort of this classic graphs,|
|

142
00:04:59,330 --> 00:05:00,110
0,180 180,330 330,390 390,600 600,780
that sort of make these
在某种程度上说明了这些观点，

143
00:05:00,110 --> 00:05:01,760
0,510 720,960 960,1110 1110,1230 1230,1650
points,| {} so let me
|所以，让我调出其中一个，

144
00:05:02,090 --> 00:05:02,990
0,270 270,330 330,510 510,570 570,900
pull up one of them,|
|

145
00:05:02,990 --> 00:05:03,590
0,240 240,270 270,420 420,510 510,600
there's a little bit of
这是一个有点复杂的图表，

146
00:05:03,590 --> 00:05:05,450
0,60 60,570 570,1140 1140,1620 1740,1860
a complicated graph,| {} you
|x 轴上是年份，

147
00:05:05,450 --> 00:05:06,840
0,90 90,300 300,960
know there's years

148
00:05:06,900 --> 00:05:08,300
0,840
{on,the}

149
00:05:08,720 --> 00:05:10,670
0,240 240,750 750,1140 1140,1620 1620,1950
x axis| and y axis,
|而 y 轴上是单位，

150
00:05:10,670 --> 00:05:13,040
0,510 570,840 870,1500 1620,2130 2130,2370
there's {you,know} units| or different
|或者根据我们看哪条线是不同的单位。

151
00:05:13,040 --> 00:05:14,330
0,180 180,240 240,450 450,870 870,1290
types of units depending on

152
00:05:14,330 --> 00:05:15,500
0,270 270,540 540,630 630,900 900,1170
which line we're looking at.|
|

153
00:05:16,140 --> 00:05:17,070
0,270 270,390 390,450 450,600 600,930
{} But the thing that
但是真正的东西是，

154
00:05:17,070 --> 00:05:17,880
0,210 210,450 450,600 600,690 690,810
really look at, it is

155
00:05:17,880 --> 00:05:20,790
0,270 750,1290 1560,2130 2130,2310 2310,2910
that,| {} what has happened
|过去几年发生的事情。

156
00:05:20,820 --> 00:05:22,440
0,480 510,780 780,1020 1020,1230 1230,1620
in the last couple years.|
|

157
00:05:22,440 --> 00:05:24,690
0,570 570,810 810,1380 1380,1620 1620,2250
The last decades is that,|
过去几十年是，|

158
00:05:25,260 --> 00:05:26,250
0,180 180,570 570,720 720,810 810,990
so starting in the two
从 2000 年开始，

159
00:05:26,250 --> 00:05:28,920
0,690 690,1380 1380,1560 1560,1890 1890,2670
thousands,| that the clock frequency
|时钟频率并没有继续增加。

160
00:05:29,220 --> 00:05:30,690
0,330 330,570 570,1020 1020,1140 1140,1470
hasn't really increased any more.|
|

161
00:05:31,320 --> 00:05:33,330
0,660 660,870 870,1260 1260,1470 1470,2010
{} So basically this has
基本上是停滞不前，持续不变的。

162
00:05:33,630 --> 00:05:34,960
0,780
plateaued,

163
00:05:35,140 --> 00:05:36,560
0,780
constant.|
|

164
00:05:37,000 --> 00:05:39,820
0,570 1050,1800 2070,2220 2220,2310 2310,2820
{} And as a result,
所以，核心的单线程性能，

165
00:05:39,850 --> 00:05:42,400
0,600 600,1200 1230,1560 1560,2310 2340,2550
basically single thread performance of

166
00:05:42,400 --> 00:05:46,090
0,300 300,930 1230,2100 2460,3120 3120,3690
core| also basically has reached
|也基本达到了极限，停滞不前。

167
00:05:46,090 --> 00:05:47,980
0,450 450,870 900,1290 1290,1380 1380,1890
{} limit {you,know} {} plateaued.|
|

168
00:05:52,060 --> 00:05:53,530
0,510 510,960 960,1320 1320,1380 1380,1470
{} And yet on the
然而，另一方面，

169
00:05:53,530 --> 00:05:55,060
0,180 180,450 450,810 810,960 960,1530
other hand,| {the,minimum -} cores
|核心的最小晶体管数量还在随时间增长，

170
00:05:55,270 --> 00:05:56,200
0,90 90,270 270,330 330,780 780,930
{of,the} number of transistors {}

171
00:05:56,200 --> 00:05:57,700
0,390 420,720 720,840 840,1350 1350,1500
still has been increasing over

172
00:05:57,700 --> 00:05:59,230
0,90 90,330 330,570 570,930 1290,1530
the same time period,| so
|所以，如果你不能使用晶体管使单个核心运行得更快，

173
00:05:59,230 --> 00:06:00,190
0,90 90,210 210,540 540,780 780,960
if you can't like {you,know}

174
00:06:00,190 --> 00:06:01,360
0,330 330,840 840,930 930,1110 1110,1170
use transistors to make a

175
00:06:01,360 --> 00:06:02,980
0,390 390,690 690,810 810,1050 1050,1620
single core {sort,of} run faster,|
|

176
00:06:03,250 --> 00:06:04,510
0,540 540,750 750,840 840,1080 1080,1260
{} {you,know} the only other
唯一的选择是使用多个内核，

177
00:06:04,510 --> 00:06:05,740
0,240 240,570 570,840 840,1020 1020,1230
option basically have to have

178
00:06:05,740 --> 00:06:06,790
0,330 330,660 660,810 810,870 870,1050
multiple cores| and you see
|你可以看到从 2001 年或 2000 年开始，

179
00:06:06,790 --> 00:06:08,470
0,360 360,690 690,1050 1050,1200 1200,1680
indeed that starting from {2001,or

180
00:06:08,470 --> 00:06:10,240
0,510 630,840 840,960 960,1200 1200,1770
- -} {from,nearly -} 2000

181
00:06:10,240 --> 00:06:11,230
0,330 330,390 390,600 600,690 690,990
{},| the number of cores
|内核的数量越来越多。

182
00:06:11,230 --> 00:06:12,240
0,120 120,300 300,630
has gone up.|
|

183
00:06:13,500 --> 00:06:14,490
0,150 150,270 270,420 420,510 510,990
And so there's an application
所以，应用程序需要更高的性能，

184
00:06:14,490 --> 00:06:16,650
0,150 150,300 300,1080 1410,1590 1590,2160
wants more performance,| you know,
|你不能依赖一个核心，

185
00:06:16,650 --> 00:06:17,970
0,450 480,690 690,960 960,1200 1200,1320
{} you can't rely on

186
00:06:17,970 --> 00:06:19,290
0,30 30,300 300,660 660,990 990,1320
a single core,| basically {have,to}
|而是要使用多个核心。

187
00:06:19,290 --> 00:06:21,080
0,150 150,570 570,900 900,1350
through exploiting multiple cores.|
|

188
00:06:21,170 --> 00:06:22,100
0,120 120,360 360,540 540,810 810,930
And also, this means if
而且，这意味着如果应用程序是内核密集型或非内核密集型，

189
00:06:22,100 --> 00:06:23,390
0,90 90,660 660,990 990,1080 1080,1290
an application is you know

190
00:06:23,390 --> 00:06:25,460
0,420 420,990 990,1110 1110,1350 1350,2070
kernel intensive or less intensive,|
|

191
00:06:25,460 --> 00:06:28,430
0,90 90,450 450,870 1320,2190 2340,2970
you know a server {},|
比如一台服务器，|

192
00:06:28,490 --> 00:06:29,450
0,390 390,540 540,750 750,840 840,960
then that means that the
那就意味着操作系统必须在多核上高效运行。

193
00:06:29,450 --> 00:06:30,500
0,270 270,540 540,750 750,930 930,1050
operating system also has to

194
00:06:30,500 --> 00:06:33,170
0,450 480,1140 1170,1950 1950,2520 2520,2670
be {you,know} run efficiently on

195
00:06:33,170 --> 00:06:34,360
0,330 330,780
multiple cores.|
|

196
00:06:34,740 --> 00:06:35,970
0,180 180,330 330,420 420,750 750,1230
So that's the main reason,|
所以这是主要原因，|

197
00:06:36,330 --> 00:06:37,950
0,540 540,690 690,990 990,1290 1290,1620
{} you know, {we're,sort,of} very
我们对内核中的并行性非常感兴趣。

198
00:06:37,950 --> 00:06:41,550
0,510 510,1080 1140,1710 1980,2970 2970,3600
interested in {} parallelism within

199
00:06:41,550 --> 00:06:43,100
0,660 660,1050
the kernel.|
|

200
00:06:45,120 --> 00:06:46,840
0,240 240,570 570,780 780,1200
Any questions about this?|
对这个有什么问题吗？|

201
00:06:52,020 --> 00:06:53,010
0,210 210,300 300,540 540,660 660,990
Okay, I assume, I I
好的，我猜你们以前看过其中的一些图表，

202
00:06:53,010 --> 00:06:53,850
0,300 300,420 420,540 540,720 720,840
assume that you've seen some

203
00:06:53,850 --> 00:06:55,230
0,60 60,210 210,630 690,1200 1200,1380
of these graphs before,| but
|但这很好地提醒我们，

204
00:06:55,230 --> 00:06:56,580
0,210 240,750 750,840 840,1110 1110,1350
it's good to remind us|
|

205
00:06:56,580 --> 00:06:57,600
0,330 330,390 390,720 720,930 930,1020
what the starting point of
所有讨论的出发点是什么。

206
00:06:57,600 --> 00:06:59,140
0,180 180,720 720,960
{all,the} discussion is.|
|

207
00:07:00,660 --> 00:07:02,080
0,120 120,420 420,840
So why locks,|
那么为什么要使用锁，|

208
00:07:02,960 --> 00:07:04,280
0,240 240,600 600,900 900,990 990,1320
{you,know} already hinted at this,
我们已经提到了，是为了正确性，

209
00:07:04,280 --> 00:07:07,400
0,90 90,180 180,1080 1290,2070 2460,3120
you know, {they're,for} correctness {},|
|

210
00:07:07,400 --> 00:07:09,740
0,570 570,720 720,1260 1290,1710 1710,2340
if we have {you,know} readers
如果我们有读取者和写入者访问共享数据结构，

211
00:07:09,740 --> 00:07:11,330
0,180 210,810 810,930 930,1350 1350,1590
and writers are accessing shared

212
00:07:11,330 --> 00:07:13,130
0,210 210,750 1110,1590 1590,1680 1680,1800
data structure| and you know
|会出现的问题是，

213
00:07:13,130 --> 00:07:14,270
0,90 90,270 270,390 390,570 570,1140
the thing that goes wrong

214
00:07:14,270 --> 00:07:16,010
0,480 480,1170 1170,1410 1410,1470 1470,1740
is,| we want to avoid
|我们想要避免竞态条件。

215
00:07:16,010 --> 00:07:17,180
0,210 210,870
race conditions.|
|

216
00:07:23,830 --> 00:07:25,000
0,150 150,270 270,510 510,660 660,1170
If you don't have locks,|
如果没有锁，|

217
00:07:25,150 --> 00:07:25,780
0,150 150,240 240,360 360,540 540,630
you know we run the
会出现一种风险，

218
00:07:25,780 --> 00:07:26,920
0,450 480,600 600,750 750,1020 1020,1140
risk,| you know we have
|我们有共享的数据结构，

219
00:07:26,920 --> 00:07:27,850
0,150 150,360 360,750 750,870 870,930
shared data structures,| that we're
|我们会有竞态条件，

220
00:07:27,850 --> 00:07:30,640
0,120 120,180 180,690 1050,1740 2040,2790
going to have, {} we're

221
00:07:30,850 --> 00:07:33,250
0,420 420,480 480,570 570,1500 1800,2400
going to have race conditions|
|

222
00:07:33,250 --> 00:07:34,600
0,420 600,810 810,990 990,1200 1200,1350
and it turns out that
竞态条件是相当烦人的，

223
00:07:34,600 --> 00:07:36,790
0,150 150,360 360,780 780,1620 1770,2190
{} race conditions are pretty

224
00:07:36,790 --> 00:07:39,490
0,540 630,1140 1500,1740 1740,2280 2280,2700
annoying,| {} so justly first
|所以，首先对它的情况有了一点了解，

225
00:07:39,490 --> 00:07:40,270
0,330 330,390 390,600 600,690 690,780
got a little bit of

226
00:07:40,270 --> 00:07:41,230
0,300 300,360 360,540 540,630 630,960
sense of what it actually

227
00:07:41,230 --> 00:07:43,180
0,390 540,1110 1110,1290 1290,1410 1410,1950
is,| let's look at the,|
|让我们看一下，|

228
00:07:43,210 --> 00:07:45,280
0,870 870,1350 1380,1470 1470,1680 1680,2070
let's create a race condition
让我们在 xv6 中创造一个竞态条件，

229
00:07:45,280 --> 00:07:46,630
0,120 120,840 840,1110 1110,1290 1290,1350
in xv6| and sort of
|然后看看它是怎么表现出来的，

230
00:07:46,630 --> 00:07:47,680
0,210 210,390 390,510 510,780 780,1050
see how it actually shows

231
00:07:47,680 --> 00:07:49,090
0,300 300,450 450,690 690,1230 1230,1410
up| and then understand like
|然后理解实际发生了什么。

232
00:07:49,090 --> 00:07:50,380
0,330 330,600 600,930
what actually happened.|
|

233
00:07:51,100 --> 00:07:54,500
0,510 840,1020 1020,1680 2070,2910
Alright, so here's {}
好的，这是 kalloc.c 中的函数 kfree 。

234
00:07:55,010 --> 00:07:56,540
0,90 90,480 480,690 690,930 930,1530
the function {} {kfree -}

235
00:07:56,600 --> 00:07:58,370
0,450 450,900 900,1290 1290,1500 1500,1770
{} in {kalloc.c - -}.|
|

236
00:07:58,370 --> 00:07:59,090
0,90 90,270 270,510 510,630 630,720
You know this is the
这是一个函数，释放，

237
00:07:59,090 --> 00:08:01,010
0,330 330,480 480,1050 1410,1800 1800,1920
function that frees,| after you
|在你释放页面之后，它会推入到 free 列表，

238
00:08:01,010 --> 00:08:02,060
0,240 240,570 570,660 660,900 900,1050
free page, it pushes on

239
00:08:02,060 --> 00:08:03,650
0,90 90,300 300,690 750,990 990,1590
the {freelist -},| there's {}
|内核有一个非常简单的数据结构，

240
00:08:03,680 --> 00:08:04,820
0,330 330,510 510,540 540,840 840,1140
kernel has a very simple

241
00:08:04,820 --> 00:08:05,810
0,240 240,600 600,660 660,870 870,990
data structure| to keep the
|使用 freelist 保存所有空闲页表。

242
00:08:05,810 --> 00:08:06,620
0,210 210,420 420,510 510,660 660,810
{freelist -} of all free

243
00:08:06,620 --> 00:08:07,700
0,570
pages.|
|

244
00:08:07,700 --> 00:08:09,050
0,540 540,690 690,840 840,1020 1020,1350
{} So that when kalloc
所以，当 kalloc 需要页面时，它从 freelist 中获取。

245
00:08:09,050 --> 00:08:10,370
0,180 180,240 240,420 420,990 990,1320
needs to page, that grabbing

246
00:08:10,370 --> 00:08:11,620
0,90 90,180 180,750
from the freelist.|
|

247
00:08:11,620 --> 00:08:12,700
0,300 300,390 390,540 540,870 870,1080
This you see here, {you,know}
这里你可以看到， allocation 有一个，

248
00:08:12,700 --> 00:08:17,230
0,1470 1830,2610 2610,2820 2820,3420 3870,4530
the allocation has one {},|

249
00:08:17,780 --> 00:08:19,500
0,600 630,1140

250
00:08:19,500 --> 00:08:20,400
0,60 60,270 270,600 600,720 720,900
the memory allocator has one
内存分配器有一个锁 kmem.lock ，

251
00:08:20,400 --> 00:08:22,920
0,390 390,780 780,1260 1620,2280 2280,2520
lock {kmem.lock -}| and {}
|在这里，它更新了 freelist ，

252
00:08:22,920 --> 00:08:24,120
0,330 330,390 390,690 690,1080 1080,1200
here it actually updates the

253
00:08:24,120 --> 00:08:26,670
0,180 180,660 960,1620 1650,2190 2190,2550
{freelist -}| {} {with,the} page
|使用刚刚释放的页面或者需要释放的参数。

254
00:08:26,670 --> 00:08:27,780
0,150 150,330 330,480 480,660 660,1110
that just has been freed

255
00:08:27,810 --> 00:08:29,820
0,360 360,720 720,1200 1200,1500
or with argument {to,free}.|
|

256
00:08:29,880 --> 00:08:30,510
0,270 270,360 360,480 480,540 540,630
So we're going to do
所以我们要做的是，

257
00:08:30,510 --> 00:08:31,740
0,120 120,450 510,720 720,1020 1020,1230
is| like just comment out
|注释掉这两个 acquire 和 release ，

258
00:08:31,740 --> 00:08:33,180
0,240 240,870
these two

259
00:08:33,180 --> 00:08:35,640
0,300 300,810 810,960 960,1590 1620,2460
acquire release,| that basically mark
|这标志着获得锁，然后释放锁，

260
00:08:35,640 --> 00:08:37,260
0,90 90,210 210,600 990,1530 1530,1620
you know the acquiring of

261
00:08:37,260 --> 00:08:38,340
0,90 90,420 420,510 510,720 720,1080
the lock, and then releasing

262
00:08:38,340 --> 00:08:39,450
0,90 90,450 450,540 540,840 840,1110
the lock,| you know and
|所以这段代码，

263
00:08:39,450 --> 00:08:41,070
0,90 90,450 450,720 720,1350 1380,1620
so this, this, this, this

264
00:08:41,070 --> 00:08:42,120
0,210 210,300 300,690 690,990 990,1050
piece of code| that's in
|之前在中间的这段（代码），

265
00:08:42,120 --> 00:08:43,560
0,90 90,540 840,1170 1170,1380 1380,1440
the middle that used to

266
00:08:43,560 --> 00:08:45,690
0,450 840,870 870,1470 1470,1830 1830,2130
be,| {} there's not more,
|不再是原子地执行了。

267
00:08:45,690 --> 00:08:47,130
0,90 90,300 300,480 480,960 960,1440
is not being executed anymore

268
00:08:47,130 --> 00:08:48,560
0,210 240,1020
at atomically.|
|

269
00:08:49,350 --> 00:08:50,500
0,600

270
00:08:50,590 --> 00:08:51,740
0,840

271
00:08:54,100 --> 00:08:56,460
0,750 780,1050 1050,1200 1200,1740
So let's do that,|
所以我们就这么做，|

272
00:08:56,910 --> 00:08:59,600
0,510 510,1080 1110,1320 1320,2010
{} and then run
然后运行 QEMU ，编译它。

273
00:09:01,500 --> 00:09:03,940
0,300 300,810 840,1230 1230,1830
{QEMU -}, so {compile,it}.|
|

274
00:09:05,300 --> 00:09:07,130
0,630 720,1200 1200,1290 1290,1530 1530,1830
And before I run it,|
在我运行它之前，|

275
00:09:07,160 --> 00:09:08,600
0,180 180,540 570,1020 1020,1290 1290,1440
you know notice actually we
注意到我们已经启动了，

276
00:09:08,600 --> 00:09:11,450
0,180 180,690 780,1260 1260,1800 1800,2850
already booted| and actually {}
|实际上，我们已经有几个 kfree 的调用，

277
00:09:11,480 --> 00:09:12,470
0,420 420,510 510,630 630,810 810,990
presumably we have made some

278
00:09:12,470 --> 00:09:13,730
0,270 270,630 630,900 900,1050 1050,1260
calls probably to {} {kfree

279
00:09:13,730 --> 00:09:15,290
0,420 720,930 930,1350 1350,1440 1440,1560
-},| and probably as you
|像你知道的，

280
00:09:15,290 --> 00:09:16,520
0,390 390,600 600,690 690,900 930,1230
know,| and {so,actually -} things
|实际上事情看起来运行得很好。

281
00:09:16,520 --> 00:09:17,510
0,120 120,210 210,330 330,630 630,990
seem to be working fine.|
|

282
00:09:18,070 --> 00:09:19,090
0,210 210,420 420,750 750,780 780,1020
So let's run {} {usertests
让我们运行 usertests 。

283
00:09:19,090 --> 00:09:20,260
0,540
-}.|
|

284
00:09:20,260 --> 00:09:21,100
0,180 180,420 420,540 540,690 690,840
And maybe you know this
也许要想想这件事，

285
00:09:21,100 --> 00:09:22,360
0,360 360,780 780,990 990,1050 1050,1260
interesting to think a little

286
00:09:22,360 --> 00:09:23,110
0,120 120,330 330,510 510,600 600,750
bit about this| and what
|你期望的是什么，

287
00:09:23,110 --> 00:09:24,220
0,60 60,120 120,630 630,750 750,1110
do you expect,| will this
|这能正常工作，或者不能正常工作。

288
00:09:24,250 --> 00:09:25,870
0,630 630,750 750,900 900,1140 1140,1620
work, will does not work.|
|

289
00:09:28,920 --> 00:09:30,120
0,390 390,510 510,720 720,840 840,1200
Anybody who tried it out.|
有人试过吗。|

290
00:09:33,070 --> 00:09:34,480
0,300 300,510 510,960 990,1200 1200,1410
{} I think it could
我想它可能会丢失一些页面，

291
00:09:34,480 --> 00:09:37,060
0,810 840,1260 1260,1500 1500,2160 2160,2580
potentially lose some pages,| but
|但也可能不会，

292
00:09:37,330 --> 00:09:39,780
0,450 450,660 660,1170 1260,2010
maybe will not,| because
|因为可能竞态条件不会出现。

293
00:09:39,780 --> 00:09:41,250
0,210 210,750 810,900 900,1110 1110,1470
{} maybe a race condition

294
00:09:41,250 --> 00:09:43,260
0,210 210,720 870,1470 1590,1800 1800,2010
wouldn't occur.| {} Yeah, so
|是的，其中一件事是，

295
00:09:43,260 --> 00:09:43,920
0,150 150,240 240,300 300,540 540,660
one of the things is|
|

296
00:09:43,920 --> 00:09:45,510
0,180 180,450 450,930 930,1140 1140,1590
that these we face conditions
我们面临的是这些情况可能不会发生，

297
00:09:45,510 --> 00:09:46,290
0,90 90,270 270,420 420,660 660,780
they might not happen,| so
|所以，让我们运行 usertests ，看看实际会发生什么。

298
00:09:46,290 --> 00:09:47,340
0,180 180,570 570,630 630,840 840,1050
let's run the {usertests -}

299
00:09:47,340 --> 00:09:48,330
0,90 90,240 240,420 420,540 540,990
and see actually what happens.|
|

300
00:09:50,740 --> 00:09:51,820
0,600

301
00:09:51,820 --> 00:09:53,900
0,570 570,900 900,1500
{So,here,we} started up.|
我们从这里开始。|

302
00:09:54,360 --> 00:09:55,560
0,420 420,600 600,660 660,840 840,1200
It'll take a little while,|
这需要一小段时间，|

303
00:09:55,560 --> 00:09:56,430
0,120 120,240 240,450 450,810 810,870
as you might complain a
你可能会抱怨，

304
00:09:56,430 --> 00:09:57,540
0,210 210,360 360,780 780,900 900,1110
little bit,| because you know,
|因为要跑很多，

305
00:09:58,470 --> 00:09:59,920
0,270 270,330 330,540 540,840
run a lot of,|
|

306
00:10:00,940 --> 00:10:01,390
0,120 120,150 150,180 180,360 360,450
there are a lot of
在我的机器上要加载很多，

307
00:10:01,390 --> 00:10:02,380
0,210 210,270 270,360 360,720 720,990
load on my machine here

308
00:10:02,380 --> 00:10:03,460
0,210 210,270 270,390 390,720 720,1080
correct,| {} you probably know
|这里 QEMU 模拟了三个核心，

309
00:10:03,460 --> 00:10:06,220
0,570 810,1260 1260,1800 1800,2400 2430,2760
the QEMU simulating three of

310
00:10:06,310 --> 00:10:07,780
0,390 390,750 750,870 870,1260 1260,1470
cores here| and the discrete
|并且不同的核心可以并行运行。

311
00:10:07,780 --> 00:10:09,100
0,240 240,390 390,600 600,690 690,1320
cores might run in parallel.|
|

312
00:10:10,330 --> 00:10:11,620
0,720

313
00:10:11,830 --> 00:10:13,840
0,900 990,1230 1230,1410 1410,1560 1560,2010
And so far so good,|
到目前为止一切顺利，|

314
00:10:14,020 --> 00:10:15,580
0,390 390,660 660,750 750,1050 1050,1560
we're starting to pass tests.|
我们开始通过测试。|

315
00:10:21,470 --> 00:10:22,430
0,240 240,270 270,510 510,600 600,960
That's a little bit slower,|
这有点慢，|

316
00:10:22,430 --> 00:10:23,360
0,210 210,330 330,600 600,870 870,930
because I'm running zoom at
因为我同时运行了 Zoom 。

317
00:10:23,360 --> 00:10:24,700
0,90 90,300 300,840
the same time.|
|

318
00:10:26,920 --> 00:10:28,420
0,450 450,810 810,870 870,1110 1110,1500
Let's wait a couple more
让我们稍等一下，看看会发生什么。

319
00:10:28,420 --> 00:10:29,650
0,120 120,360 360,720 750,1050 1050,1230
and just to see what's

320
00:10:29,650 --> 00:10:30,840
0,240 240,630
going on.|
|

321
00:10:43,070 --> 00:10:45,860
0,720 720,1320 1350,2250
Okay, well {}.|
好的，好吧。|

322
00:10:46,290 --> 00:10:47,670
0,270 540,750 750,840 840,1230 1230,1380
Let's just go back to
我们还是回去看幻灯片，

323
00:10:47,670 --> 00:10:49,290
0,330 330,750 750,870 870,1350 1350,1620
the slides| and then we'll
|然后我们过一会再回来看看，

324
00:10:49,290 --> 00:10:50,340
0,210 210,480 480,750 750,840 840,1050
check back in a little

325
00:10:50,340 --> 00:10:51,450
0,240 240,360 360,660 660,840 840,1110
while| and see what actually
|看看会发生什么。

326
00:10:51,450 --> 00:10:52,500
0,570
happens.|
|

327
00:10:52,860 --> 00:10:54,600
0,540 720,1170 1170,1320 1320,1440 1440,1740
{} But it was pointed
但是需要指出，

328
00:10:54,600 --> 00:10:55,950
0,300 360,510 510,720 720,930 930,1350
out| {you,know} these race conditions
|这些竞态条件可能会出现，也可能不会出现，

329
00:10:55,950 --> 00:10:57,060
0,150 150,450 450,570 570,750 750,1110
may appear, may not appear,

330
00:10:57,090 --> 00:10:58,410
0,240 240,510 510,900 900,1230 1230,1320
right,| because it's always the
|因为情况可能总是这样，

331
00:10:58,410 --> 00:11:00,180
0,360 360,960 960,1200 1200,1620 1620,1770
case| that every core or
|每个核心或每次我们调用 kfree ，

332
00:11:00,180 --> 00:11:01,140
0,150 150,360 360,450 450,690 690,960
every time we call {kfree

333
00:11:01,140 --> 00:11:03,300
0,450 900,1290 1290,1530 1530,1740 1740,2160
-},| {} these two lines
|这两行（代码）原子地执行，

334
00:11:03,300 --> 00:11:07,260
0,120 120,780 1050,2040 2940,3810 3840,3960
are executed atomically| as they
|就像它们使用了锁那样，

335
00:11:07,260 --> 00:11:08,370
0,180 180,300 300,750 750,990 990,1110
would have done with the

336
00:11:08,370 --> 00:11:10,530
0,450 600,1110 1110,1290 1290,1440 1440,2160
lock,| then there's no problem,|
|那就不会出现问题，|

337
00:11:10,530 --> 00:11:11,790
0,90 90,360 360,720 720,960 960,1260
the only problem is| if
唯一的问题是，|如果两个线程或两个进程同时执行，

338
00:11:11,790 --> 00:11:13,380
0,120 120,420 420,900 1020,1170 1170,1590
{} two threads two processes

339
00:11:13,380 --> 00:11:14,460
0,150 150,630 630,720 720,810 810,1080
are executed at the same

340
00:11:14,460 --> 00:11:15,720
0,480 540,690 690,930 930,1170 1170,1260
time| and somebody comes in
|然后有（代码）在中间执行。

341
00:11:15,720 --> 00:11:16,420
0,390
between.|
|

342
00:11:17,140 --> 00:11:18,850
0,240 240,300 300,600 630,1200 1230,1710
Look at this, actually while
看看这个，在我说话的时候，

343
00:11:18,850 --> 00:11:20,200
0,90 90,570 570,870 870,1050 1050,1350
I'm talking,| we see actually
|我们看到这里有一个 panic ，

344
00:11:20,200 --> 00:11:21,310
0,180 180,300 300,360 360,810 840,1110
there is a panic| and
|所以，有一些竞态条件引起了 panic 。

345
00:11:21,310 --> 00:11:22,600
0,240 240,510 510,690 690,900 900,1290
so there's some race condition

346
00:11:22,600 --> 00:11:23,440
0,150 150,300 300,540 540,780 780,840
that can actually cause a

347
00:11:23,440 --> 00:11:24,400
0,480
panic.|
|

348
00:11:24,940 --> 00:11:27,190
0,450 930,1230 1230,1440 1440,1950 1950,2250
{} Rather race conditions that
更确切地说，竞态条件会出现，

349
00:11:27,190 --> 00:11:28,450
0,330 330,630 630,780 780,900 900,1260
will show up| as indeed
|正如所提到的那样，

350
00:11:28,450 --> 00:11:31,480
0,300 300,960 960,1440 1800,2670 2700,3030
this as mentioned whereas mentioned|
|

351
00:11:31,480 --> 00:11:32,920
0,600 600,840 840,1050 1050,1170 1170,1440
that will show up as
这是不够的，

352
00:11:33,070 --> 00:11:34,780
0,360 360,840 960,1140 1140,1320 1320,1710
[not enough],| some free pages
|一些空闲页面丢失了，

353
00:11:34,780 --> 00:11:36,070
0,210 210,330 330,660 660,840 840,1290
where some pages get lost,|
|

354
00:11:36,100 --> 00:11:37,330
0,180 180,570 570,780 780,1020 1020,1230
so basically {usertests -} runs
基本上 usertest 运行得很好直到最后，

355
00:11:37,330 --> 00:11:38,650
0,390 390,600 600,690 690,1020 1020,1320
fine until the very end,|
|

356
00:11:38,770 --> 00:11:41,050
0,480 480,960 960,1440 1500,1980 1980,2280
where complaints saying well you
抱怨丢失了一些页面，

357
00:11:41,050 --> 00:11:43,120
0,300 300,660 690,1050 1050,1650 1650,2070
lost some pages| during all
|在整个 usertests 中。

358
00:11:43,120 --> 00:11:44,470
0,300 300,630 630,720 720,840 840,1350
user-, all of the [round]

359
00:11:44,470 --> 00:11:45,200
0,420
usertests.|
|

360
00:11:45,600 --> 00:11:47,550
0,540 840,1050 1050,1380 1380,1590 1590,1950
Okay.| So these race conditions
好的。|所以，这些竞态条件可以以不同的方式表现出来，

361
00:11:47,550 --> 00:11:48,300
0,120 120,330 330,450 450,510 510,750
can show up in different

362
00:11:48,300 --> 00:11:49,770
0,570 630,840 840,960 960,1140 1140,1470
ways,| {} they may happen,
|它们可能会发生，也可能不会发生。

363
00:11:49,770 --> 00:11:51,000
0,60 60,150 150,390 390,690
they may not happen.|
|

364
00:11:51,120 --> 00:11:53,520
0,510 510,810 810,1110 1110,1470 1770,2400
Clearly something happened here {},|
很明显这里发生了，|

365
00:11:53,760 --> 00:11:55,110
0,330 330,480 480,570 570,1200 1230,1350
let's try to understand you
让我们试着了解到底哪里出了问题。

366
00:11:55,110 --> 00:11:57,240
0,90 90,750 750,1260 1260,1710 1710,2130
know what actually, {} what

367
00:11:57,240 --> 00:11:58,300
0,180 180,510
goes wrong.|
|

368
00:12:00,420 --> 00:12:02,940
0,1050 1050,1170 1170,1410 1410,1950
Back to the slides.|
回到幻灯片上。|

369
00:12:06,400 --> 00:12:07,720
0,630 660,960 960,1080 1080,1200 1200,1320
{} So you know the
所以，你知道这个应该在脑海中的图片，

370
00:12:07,720 --> 00:12:08,500
0,300 300,390 390,570 570,720 720,780
picture, you should have in

371
00:12:08,500 --> 00:12:09,640
0,120 120,540 540,690 690,840 840,1140
your head,| like if there's
|比如有多个核心在运行。

372
00:12:09,640 --> 00:12:11,770
0,390 630,1080 1080,1560 1590,1920 1920,2130
{} multiple cores that were

373
00:12:11,770 --> 00:12:12,800
0,480
running.|
|

374
00:12:13,070 --> 00:12:15,290
0,210 210,390 390,810 810,1410 1740,2220
So {you,know} {CPU0 -}, {CPU0
所以， CPU0 正在执行指令，

375
00:12:15,290 --> 00:12:17,440
0,300 300,390 390,870 870,1590
-} is executing instructions,|
|

376
00:12:17,470 --> 00:12:18,880
0,180 180,480 480,840 840,990 990,1410
and {CPU1 -} is executing
并且 CPU1 也在执行指令。

377
00:12:18,880 --> 00:12:20,120
0,720
instructions.|
|

378
00:12:21,210 --> 00:12:23,880
0,510 540,690 690,960 960,1620 1710,2670
And they're both connected to
它们都连接到一块内存上，

379
00:12:24,120 --> 00:12:26,070
0,150 150,630 840,990 990,1410 1440,1950
a memory,| if you're back
|如果你回想一下方案示意图，

380
00:12:26,070 --> 00:12:27,090
0,180 180,420 420,600 600,690 690,1020
think back about the scheme

381
00:12:27,090 --> 00:12:28,320
0,630 630,720 720,930 930,1020 1020,1230
schematics,| you know we showed
|我们之前展示过几次，

382
00:12:28,320 --> 00:12:29,700
0,30 30,210 210,420 420,930 1230,1380
a couple times before,| in
|实际上这里有一个 DRAM 控制器，

383
00:12:29,700 --> 00:12:31,770
0,180 180,360 360,690 750,1350 1350,2070
fact there's a DRAM controller,|
|

384
00:12:31,770 --> 00:12:33,600
0,120 120,240 240,660 660,1350
you know that actually
它连接到 DRAM 芯片，

385
00:12:33,690 --> 00:12:35,250
0,450 480,960 960,1140 1140,1440 1440,1560
{} connects {you,know} to the

386
00:12:35,250 --> 00:12:37,170
0,390 390,900 1200,1710 1710,1830 1830,1920
DRAM chips,| where all the
|所有的阶段都在这里，

387
00:12:37,170 --> 00:12:38,660
0,420 420,930
[stages] living,|
|

388
00:12:38,800 --> 00:12:40,420
0,510 510,870 870,930 930,1320 1320,1620
or all the memories living.|
或者所有的内存都在这里。|

389
00:12:41,370 --> 00:12:42,240
0,180 180,330 330,480 480,630 630,870
I'm gonna make that memory
我把内存画得大一点，

390
00:12:42,240 --> 00:12:43,050
0,30 30,180 180,300 300,570 570,810
a little bit bigger, bigger|
|

391
00:12:43,050 --> 00:12:44,040
0,390
whatever
好让我有地方可以画，

392
00:12:46,030 --> 00:12:47,230
0,180 180,300 300,540 540,630 630,1200
have some place to draw|
|

393
00:12:47,260 --> 00:12:48,940
0,270 270,420 420,780 780,990 990,1680
and so basically our freelist,
所以我们的 freelist 在内存中，

394
00:12:49,270 --> 00:12:50,800
0,180 180,360 360,750 750,1080 1080,1530
you know {} lives in,

395
00:12:53,010 --> 00:12:54,780
0,180 180,810 1170,1410 1410,1590 1590,1770
in memory,| and let's say
|我们假设 freelist 上面有两页。

396
00:12:54,780 --> 00:12:55,620
0,210 210,300 300,480 480,750 750,840
there's a {freelist -} with

397
00:12:55,620 --> 00:12:57,260
0,150 150,540 540,750 750,1050
two pages on it.|
|

398
00:12:59,060 --> 00:13:01,640
0,600 600,1290 1290,1890 2340,2460 2460,2580
{} And {} you know
并且两个 CPU 会几乎同时调用 kfree 。

399
00:13:01,640 --> 00:13:04,790
0,660 660,660 2130,2640 2640,3030 3030,3150
both, {} both {CPUs -}

400
00:13:04,790 --> 00:13:06,860
0,240 240,720 720,1050 1050,1560 1590,2070
gonna call {kfree -} roughly

401
00:13:06,860 --> 00:13:08,300
0,90 90,180 180,420 420,810
at the same time.|
|

402
00:13:13,460 --> 00:13:14,510
0,240 240,390 390,780 780,840 840,1050
Okay, so look a little
好的，再看一下代码，

403
00:13:14,510 --> 00:13:15,440
0,150 150,240 240,330 330,570 570,930
bit at the code, again,|
|

404
00:13:15,440 --> 00:13:16,280
0,210 210,270 270,450 450,690 690,840
just to make sure that
确保运行的跟我们想的一样，

405
00:13:16,280 --> 00:13:17,810
0,540 570,930 1020,1350 1350,1440 1440,1530
we have running in our

406
00:13:17,810 --> 00:13:18,650
0,300 300,450 450,600 600,750 750,840
heads,| so we look at
|所以我们看看 kfree ，

407
00:13:18,650 --> 00:13:20,780
0,240 240,750 1140,1710 1710,1830 1830,2130
{kfree -},| {} you know
|它传递了 pa ，物理地址，

408
00:13:20,780 --> 00:13:23,120
0,180 180,690 690,1140 1170,1890 1920,2340
get passing some pa, {}

409
00:13:23,120 --> 00:13:24,830
0,330 330,960 1230,1440 1440,1590 1590,1710
physical address,| {} that we're
|我们要把它放到 freelist 上。

410
00:13:24,830 --> 00:13:26,210
0,150 150,450 450,570 570,960 960,1380
gonna use to actually hook

411
00:13:26,210 --> 00:13:28,130
0,750 900,1200 1200,1290 1290,1470 1470,1920
up into the {freelist -}.|
|

412
00:13:29,000 --> 00:13:31,940
0,600 960,1440 1710,1830 1830,1950 1950,2940
{} So you know {CPU0
CPU0 有一个 R ，

413
00:13:32,240 --> 00:13:35,750
0,630 630,1350 1470,2250 2490,2970 2970,3510
-} has a {you,know} R,|
|

414
00:13:36,770 --> 00:13:39,470
0,690 690,1200 1650,1860 1860,2340 2340,2700
{} and that's pointing to
它指向了一些空闲页面，

415
00:13:39,470 --> 00:13:42,230
0,420 420,720 720,930 930,1530 2070,2760
some {you,know} free page| and
|可能 CPU1 也有一个，

416
00:13:42,230 --> 00:13:45,440
0,810 1200,1980 2310,2520 2520,2790 2790,3210
{} maybe yeah and {CPU1

417
00:13:45,440 --> 00:13:47,020
0,360 360,570 570,1050
-} has one,|

418
00:13:47,080 --> 00:13:48,190
0,150 150,420 420,570 570,840 840,1110
we actually use another color
对 CPU1 ，我们使用另一种颜色。

419
00:13:48,190 --> 00:13:49,660
0,120 120,450 450,900
for {CPU1 -}.|
|

420
00:13:49,660 --> 00:13:51,220
0,90 90,330 330,480 480,1050 1050,1560
So {CPU -} {on,another} R
所以 CPU 另一个 R 总是指向一些页面，

421
00:13:51,640 --> 00:13:53,590
0,450 450,1050 1050,1170 1170,1380 1380,1950
always pointing to some page,|
|

422
00:13:53,590 --> 00:13:54,430
0,120 120,240 240,540 540,660 660,840
you know that we want
我们想放入 freelist 。

423
00:13:54,430 --> 00:13:55,090
0,60 60,210 210,390 390,510 510,660
to hook into the {freelist

424
00:13:55,090 --> 00:13:55,980
0,450
-}.|
|

425
00:13:56,450 --> 00:13:57,600
0,240 240,600
Makes sense?|
能理解吗?|

426
00:13:59,050 --> 00:14:00,010
0,240 240,570 570,690 690,810 810,960
And so you know we're
所以，我们回顾代码，

427
00:14:00,010 --> 00:14:01,210
0,180 180,420 420,480 480,540 540,1200
looking back at the code,|
|

428
00:14:01,240 --> 00:14:03,130
0,630 1170,1380 1380,1500 1500,1740 1740,1890
you know the first thing
所做的第一件事就是，

429
00:14:03,130 --> 00:14:04,450
0,120 120,540 540,1050 1050,1170 1170,1320
they do is| you know
|更新 r->next 指针指向 freelist 。

430
00:14:04,450 --> 00:14:06,790
0,420 420,570 570,960 960,1290 1290,2340
update {r->next -} pointer to

431
00:14:06,850 --> 00:14:07,810
0,360 360,450 450,570 570,870 870,960
point to the k- to

432
00:14:07,810 --> 00:14:08,880
0,120 120,270 270,690
the {freelist -}.|
|

433
00:14:09,210 --> 00:14:11,040
0,480 510,840 840,1530 1560,1680 1680,1830
So let's assume you know
我们假设 CPU1 首先运行，

434
00:14:11,040 --> 00:14:13,290
0,540 540,870 870,1260 1260,1830 1950,2250
that {CPU1 -} runs {}

435
00:14:13,290 --> 00:14:15,570
0,540 960,1590 1890,1980 1980,2070 2070,2280
first| and you know what
|它所做的是，

436
00:14:15,570 --> 00:14:16,680
0,180 180,300 300,630 630,930 930,1110
it will do is| will
|将指针指向开始，

437
00:14:16,680 --> 00:14:18,180
0,240 240,390 390,1050
put its pointer

438
00:14:18,550 --> 00:14:20,200
0,120 120,240 240,930 1110,1290 1290,1650
you know to the beginning

439
00:14:20,200 --> 00:14:21,540
0,210 210,690
of the|
|

440
00:14:22,000 --> 00:14:23,890
0,510 540,870 870,1440 1440,1620 1620,1890
{} {you,know} wherever {freelist -}
指向 freelist 指向的地方。

441
00:14:23,890 --> 00:14:24,940
0,300 300,510
pointed to.|
|

442
00:14:25,090 --> 00:14:26,950
0,540 540,1050 1050,1290 1290,1590 1590,1860
{} If {you,know} {CPU1 -}
CPU1 也在同时运行，

443
00:14:26,950 --> 00:14:28,060
0,270 270,720 720,780 780,870 870,1110
runs exactly at the same

444
00:14:28,060 --> 00:14:30,970
0,600 930,1320 1320,2010 2160,2790 2790,2910
time,| {} then, {} you
|然后，它可以在 CPU0 执行第二条指令之前运行，

445
00:14:30,970 --> 00:14:31,780
0,300
know

446
00:14:31,870 --> 00:14:34,990
0,630 810,1140 1140,1530 1530,2040 2070,3120
{} it could run before

447
00:14:35,080 --> 00:14:36,610
0,390 390,720 720,1110 1110,1170 1170,1530
{CPU0 -} executes the second

448
00:14:36,610 --> 00:14:38,320
0,660 960,1170 1170,1260 1260,1500 1500,1710
instruction,| so it actually might
|所以它可能做同样的事情，

449
00:14:38,320 --> 00:14:39,310
0,90 90,210 210,420 420,720 720,990
do the same thing,| it
|它可能也运行第一条指令，

450
00:14:39,310 --> 00:14:40,450
0,210 210,450 450,780 780,960 960,1140
might actually also run that

451
00:14:40,450 --> 00:14:42,880
0,240 240,810 1110,1290 1290,1920
first instruction| and update
|并且将指针更新为二。

452
00:14:43,140 --> 00:14:44,240
0,600
{}

453
00:14:51,340 --> 00:14:52,810
0,210 210,750 750,840 840,1140 1140,1470
and update the pointer to

454
00:14:54,030 --> 00:14:56,430
0,390 390,870 1260,1950 1980,2070 2070,2400
two.| {So,both} Rs {you,know} one
|所以，两个 R ，一个来自 CPU1 ，一个来自 CPU0 ，

455
00:14:56,430 --> 00:14:57,630
0,120 120,480 480,810 810,1080 1080,1200
from {CPU1 -}, and from

456
00:14:57,630 --> 00:14:58,980
0,300 300,570 570,780 780,1140 1140,1350
CPU zero, {one,from} {CPU1 -}|
|

457
00:14:58,980 --> 00:14:59,820
0,150 150,420 420,510 510,570 570,840
are pointing to the beginning
都指向 freelist 的开头，

458
00:14:59,820 --> 00:15:00,510
0,90 90,150 150,360 360,570 570,690
of the {freelist -}| and
|而 freelist 也指向 freelist 的开头。

459
00:15:00,510 --> 00:15:01,500
0,180 180,420 420,510 510,720 720,990
the freelist is also pointing

460
00:15:01,500 --> 00:15:02,760
0,120 120,390 720,1110 1110,1170 1170,1260
to the beginning of the

461
00:15:02,760 --> 00:15:03,780
0,180 180,570
{freelist -}.|
|

462
00:15:03,930 --> 00:15:04,680
0,180 180,360 360,480 480,510 510,750
So now there are two
所以，现在有两条指令在并行执行。

463
00:15:04,680 --> 00:15:05,880
0,360 360,840 840,960 960,1020 1020,1200
[remaining] instructions that are being

464
00:15:05,880 --> 00:15:07,580
0,510 510,570 570,1140
executed in parallel.|
|

465
00:15:07,730 --> 00:15:08,960
0,210 210,360 360,450 450,750 750,1230
So we go back again,
所以，我们再回到代码，

466
00:15:09,020 --> 00:15:10,700
0,120 120,300 300,390 390,870 1260,1680
you know the code,| the
|剩下的指令正在执行，

467
00:15:10,700 --> 00:15:12,500
0,420 420,840 840,1020 1020,1230 1230,1800
remaining instruction is being executed|
|

468
00:15:12,500 --> 00:15:13,580
0,150 150,420 420,810 810,930 930,1080
is actually updating the {freelist
更新 freelist 指向 r 。

469
00:15:13,580 --> 00:15:14,630
0,300 300,360 360,570 570,690 690,1050
-} to point to r.|
|

470
00:15:14,900 --> 00:15:16,360
0,960

471
00:15:17,040 --> 00:15:18,720
0,270 270,780 960,1350 1350,1440 1440,1680
And so, {} you know
所以， CPU 0 1 要执行这些指令

472
00:15:19,650 --> 00:15:20,580
0,180 180,480 480,720 720,870 870,930
CPU zero one going to

473
00:15:20,580 --> 00:15:21,660
0,360 360,510 510,870 870,990 990,1080
execute these instructions| may be
|可能是完全一样的时间，

474
00:15:21,660 --> 00:15:24,060
0,510 510,630 630,1170 1170,2040 2040,2400
exactly the same, {} roughly

475
00:15:24,060 --> 00:15:24,990
0,60 60,120 120,330 330,720 750,930
at the same time,| but
|但是有一个会先执行，

476
00:15:24,990 --> 00:15:25,860
0,150 150,240 240,390 390,510 510,870
one is gonna go first,

477
00:15:25,860 --> 00:15:27,120
0,210 210,330 330,540 540,840 840,1260
correct,| there's only one single
|这里只有一个共享内存，

478
00:15:27,120 --> 00:15:29,010
0,240 240,750 1140,1560 1560,1680 1680,1890
shared memory| and so one
|所以一个更新先执行，

479
00:15:29,010 --> 00:15:29,760
0,330 330,420 420,540 540,600 600,750
update is going to go

480
00:15:29,760 --> 00:15:30,870
0,450 510,720 720,810 810,930 930,1110
first| and the other one
|另一个更新第二。

481
00:15:30,870 --> 00:15:32,200
0,90 90,240 240,360 360,840
is gonna go second.|
|

482
00:15:32,290 --> 00:15:33,640
0,180 180,330 330,480 480,870 870,1350
So let's say CPU one
我们假设 CPU1 先运行。

483
00:15:33,670 --> 00:15:35,180
0,480 480,960
goes first.|
|

484
00:15:35,240 --> 00:15:36,290
0,90 90,270 270,720 720,840 840,1050
And now what will then
现在接下来会发生什么，

485
00:15:36,290 --> 00:15:37,640
0,330 330,720 750,840 840,1140 1140,1350
happen,| well the CPU what
|好的，首先执行的 CPU ，

486
00:15:37,640 --> 00:15:38,690
0,150 150,450 450,630 630,960 960,1050
goes first,| {freelist -} can
|freelist 会指向它的 R 。

487
00:15:38,690 --> 00:15:40,420
0,150 150,480 480,600 600,1170
be pointing to {its,r},

488
00:15:40,420 --> 00:15:41,280
0,330
right.|
|

489
00:15:42,200 --> 00:15:44,210
0,420 420,600 600,900 900,1440 1440,2010
{} And then {CPU,two} runs,|
然后 CPU2 运行，|

490
00:15:44,240 --> 00:15:46,220
0,180 180,720 750,1200 1200,1500 1500,1980
so now CPU2 runs actually
所以现在 CPU2 运行指令，

491
00:15:46,220 --> 00:15:48,140
0,690 990,1410 1410,1560 1560,1770 1770,1920
instruction| and so what is
|那么接下来要做是什么，

492
00:15:48,140 --> 00:15:49,160
0,120 120,180 180,600 630,870 870,1020
going to do,| it is
|它会更新 freelist 指向。

493
00:15:49,160 --> 00:15:50,870
0,300 300,360 360,750 780,1440 1500,1710
going to actually update {}

494
00:15:50,870 --> 00:15:53,140
0,210 210,630 990,1170 1170,1740
{freelist -} to point.|
|

495
00:15:55,340 --> 00:15:56,750
0,210 420,630 630,750 750,930 930,1410
So here's a {freelist -},|
这是 freelist ，|

496
00:15:58,000 --> 00:15:59,020
0,300 300,480 480,780 780,810 810,1020
and it's actually {} going
它会指向传入的 R 。

497
00:15:59,020 --> 00:16:00,520
0,390 390,930
point to

498
00:16:00,900 --> 00:16:02,580
0,510 510,660 660,1080 1080,1440 1440,1680
R that actually passed in.|
|

499
00:16:03,230 --> 00:16:04,130
0,150 150,510 510,600 600,750 750,900
And so you know we
所以我们现在是一种情况，

500
00:16:04,130 --> 00:16:05,300
0,120 120,180 180,480 480,810 810,1170
have a setting now, correct,|
|

501
00:16:05,300 --> 00:16:07,850
0,570 690,1020 1020,1680 1710,2310 2310,2550
we're, we've lost basically one
我们丢失了一页，

502
00:16:07,850 --> 00:16:08,960
0,630
page,|

503
00:16:08,960 --> 00:16:09,900
0,570

504
00:16:10,880 --> 00:16:12,320
0,570 600,720 720,840 840,1140 1140,1440
R you know that actually
实际上 CPU0 释放的的 R，

505
00:16:12,320 --> 00:16:14,510
0,420 420,840 840,1260 1260,1650 1830,2190
{CPU0 -} actually freed,| actually
|最终不在 freelist 上，

506
00:16:14,510 --> 00:16:15,680
0,240 240,390 390,750 750,1020 1020,1170
ended up not being on

507
00:16:15,680 --> 00:16:16,580
0,60 60,240 240,480 480,600 600,900
the {freelist -} at all,|
|

508
00:16:16,970 --> 00:16:18,320
0,270 270,450 450,780 780,870 870,1350
so we lost the page.|
所以我们丢了那一页。|

509
00:16:22,680 --> 00:16:24,120
0,570 570,750 750,930 930,1380 1380,1440
{} And as one you
一个坏结果出现，

510
00:16:24,120 --> 00:16:25,920
0,360 390,930 930,1320 1320,1680 1680,1800
know bad particular outcome,| of
|当然，可能会有更多的坏结果，

511
00:16:25,920 --> 00:16:26,790
0,180 180,270 270,390 390,480 480,870
course there could be more

512
00:16:26,790 --> 00:16:28,110
0,270 270,810 810,1080 1080,1200 1200,1320
bad outcomes,| because there could
|因为可能有更多的 CPU 尝试执行这个 freelist ，

513
00:16:28,110 --> 00:16:29,310
0,90 90,330 330,570 570,960 960,1200
be more {CPUs -} actually

514
00:16:29,310 --> 00:16:30,180
0,300 300,390 390,540 540,690 690,870
trying to do this {freelist

515
00:16:30,180 --> 00:16:32,370
0,510 840,1140 1140,1290 1290,1500 1500,2190
-},| {} they may observe,|
|它们可能会观察到，|

516
00:16:32,370 --> 00:16:33,420
0,300 300,510 510,630 630,720 720,1050
the one of the might
其中之一可能会观察到，

517
00:16:33,420 --> 00:16:35,430
0,300 300,510 540,960 960,1290 1290,2010
observe,| the freelist pointing temporarily
|freelist 临时指向 CPU0 的 R ，

518
00:16:35,430 --> 00:16:37,800
0,180 180,750 750,840 840,1620 1710,2370
to {CPU0's - -} R,|
|

519
00:16:38,040 --> 00:16:39,090
0,420 420,600 600,690 690,810 810,1050
{} and so we start
所以我们开始使用它，

520
00:16:39,090 --> 00:16:41,490
0,240 240,750 1020,1620 1620,1950 1950,2400
using that,| while then immediately
|然后由第二个 CPU 更新 freelist ，

521
00:16:41,490 --> 00:16:43,560
0,90 90,270 270,540 540,1110 1260,2070
the {freelist -} updated by

522
00:16:43,590 --> 00:16:45,420
0,330 360,690 690,1080 1110,1470 1560,1830
{} second CPU,| so that
|所以如果引入更多 CPU ，

523
00:16:45,420 --> 00:16:47,010
0,150 150,480 480,1110 1110,1470 1470,1590
more CPU evolved,| presumably we
|我们可能会得到更离奇的结果，

524
00:16:47,010 --> 00:16:48,360
0,150 150,420 420,600 600,870 870,1350
could actually get more bizarre

525
00:16:48,360 --> 00:16:49,920
0,420 420,720 780,1140 1140,1230 1230,1560
outcomes| than just the lost
|而不仅是丢失页面。

526
00:16:49,920 --> 00:16:50,620
0,420
page.|
|

527
00:16:52,310 --> 00:16:53,700
0,120 120,270 270,420 420,810
Does this make sense?|
这能理解吗？|

528
00:16:55,750 --> 00:16:57,300
0,330 330,1050
Any questions?|
有什么问题吗？|

529
00:17:04,820 --> 00:17:06,740
0,540 750,1350
Okay {}.|
好的。|

530
00:17:07,220 --> 00:17:08,390
0,180 180,300 300,810 840,1020 1020,1170
So the way you know
所以，代码使用的方法，

531
00:17:08,390 --> 00:17:09,650
0,420 420,510 510,900 900,1020 1020,1260
as you know the code

532
00:17:09,650 --> 00:17:10,880
0,450 450,540 540,660 660,750 750,1230
does,| you know the way
|用来解决这个问题的方法，

533
00:17:10,910 --> 00:17:13,790
0,90 90,360 360,630 630,1710 2010,2880
to address this,| one way
|是一种很常用的方法，

534
00:17:13,790 --> 00:17:15,140
0,150 150,210 210,600 600,960 960,1350
in a very common way,|
|

535
00:17:15,440 --> 00:17:16,730
0,570 570,780 780,870 870,1140 1140,1290
{} is to address this
解决这个问题就是使用锁。

536
00:17:16,730 --> 00:17:18,740
0,540 780,1200 1200,1320 1320,1860 1860,2010
problem is to use a

537
00:17:18,740 --> 00:17:19,660
0,450
lock.|
|

538
00:17:19,970 --> 00:17:20,570
0,210 210,330 330,420 420,570 570,600
So let me talk a
所以，让我详细讨论一下锁的问题。

539
00:17:20,570 --> 00:17:22,370
0,210 210,330 330,540 540,1050 1410,1800
little bit about locks {}

540
00:17:22,370 --> 00:17:23,720
0,240 240,390 390,840
in more detail.|
|

541
00:17:26,860 --> 00:17:29,320
0,180 180,750 1860,2040 2040,2160 2160,2460
So what is the lock
那么什么是锁抽象。

542
00:17:29,320 --> 00:17:30,740
0,810
abstraction.|
|

543
00:17:32,480 --> 00:17:33,890
0,570 750,900 900,1080 1080,1170 1170,1410
Well, now it is just
现在它只是一个对象，

544
00:17:33,890 --> 00:17:35,300
0,120 120,750 750,900 900,1140 1140,1410
an object,| like any other
|与内核中的任何其他类型的对象一样，

545
00:17:35,300 --> 00:17:36,920
0,300 600,750 750,1470 1470,1560 1560,1620
sort of object in the

546
00:17:36,920 --> 00:17:39,050
0,600 810,1200 1200,1470 1470,1590 1590,2130
kernel| and anyone {} has.|
|任何包含。

547
00:17:39,740 --> 00:17:40,640
0,120 120,330 330,480 480,720 720,900
In fact there's something called
实际上，有一个称为锁结构体的东西，

548
00:17:40,640 --> 00:17:41,960
0,270 270,810
struct lock,|
|

549
00:17:41,960 --> 00:17:42,680
0,60 60,150 150,300 300,540 540,720
you know, that has some
它包含一些字段，维护锁的状态，

550
00:17:42,680 --> 00:17:44,630
0,600 990,1110 1110,1230 1230,1530 1560,1950
fields, you know to maintain

551
00:17:44,630 --> 00:17:47,240
0,300 300,540 540,1050 1380,1920 1920,2610
state about locks,| {} and
|它有一个相当简单的 API ，

552
00:17:47,300 --> 00:17:48,650
0,150 150,330 330,480 510,750 750,1350
it has a pretty straightforward

553
00:17:48,650 --> 00:17:50,360
0,810 810,1050 1050,1170 1170,1470 1470,1710
API,| you know there's {}
|有一个 acquire ，

554
00:17:51,190 --> 00:17:52,150
0,570 570,660 660,840 840,930 930,960
acquire,| in fact there are
|实际上，只有两个对此抽象的调用，

555
00:17:52,150 --> 00:17:54,100
0,240 240,420 420,1050 1080,1440 1440,1950
only two calls into this

556
00:17:54,220 --> 00:17:57,240
0,810 1230,1680 1680,2310
abstraction,| {} which
|acquire 使用一个锁结构体的指针，

557
00:17:58,540 --> 00:18:00,100
0,150 150,600 600,780 780,1020 1020,1560
{acquire -} which takes {}

558
00:18:00,490 --> 00:18:02,980
0,90 90,660 660,1200 1200,2010 2040,2490
a pointer to {} lock

559
00:18:02,980 --> 00:18:05,700
0,510 810,1290 1290,1560 1560,2220
struct| and {} release
|release 也使用一个锁结构体的指针，

560
00:18:06,590 --> 00:18:09,020
0,840 840,960 960,1200 1200,1740
you know that actually

561
00:18:09,020 --> 00:18:10,850
0,990 990,1170 1170,1350 1350,1410 1410,1830
{} also takes a pointer

562
00:18:10,850 --> 00:18:12,950
0,210 210,600 960,1170 1170,1560 1560,2100
lock struct,| to basically update
|来更新锁对象。

563
00:18:12,950 --> 00:18:14,000
0,90 90,180 180,300 300,540 540,1050
you know the lock object.|
|

564
00:18:14,900 --> 00:18:15,980
0,270 270,630 630,750 750,1020 1020,1080
And basically the rule of
这里的规则是，

565
00:18:15,980 --> 00:18:17,330
0,360 360,450 450,690 690,1020 1020,1350
[] and the rule here

566
00:18:17,330 --> 00:18:19,420
0,120 120,510 930,1560
is that {},|
|

567
00:18:20,020 --> 00:18:22,020
0,480 750,1530
the acquire
acquire 遵守以下规则，

568
00:18:23,140 --> 00:18:25,240
0,480 510,1020 1020,1200 1200,1710 1740,2100
{} enforces this {} following

569
00:18:25,240 --> 00:18:27,370
0,180 180,360 360,600 600,1320 1350,2130
rule,| that only one process
|只有一个进程可以进入或者获得锁。

570
00:18:30,940 --> 00:18:32,230
0,210 210,360 360,900 900,1140 1140,1290
{you,know} can enter or can

571
00:18:32,230 --> 00:18:33,680
0,450 450,540 540,930
acquire the lock.|
|

572
00:18:37,950 --> 00:18:39,000
0,210 210,420 420,810 810,990 990,1050
So any particular point of
所以，在任何特定时间点，

573
00:18:39,000 --> 00:18:40,140
0,570
time,|
|

574
00:18:40,140 --> 00:18:40,920
0,240 240,480 480,600 600,660 660,780
there's only going to be
只有一个进程

575
00:18:40,920 --> 00:18:42,240
0,360 360,810 810,930 930,1020 1020,1320
one process| that is able
|可以成功获取到锁，

576
00:18:42,240 --> 00:18:44,010
0,120 120,570 570,1200 1200,1680 1680,1770
to actually successfully acquire the

577
00:18:44,010 --> 00:18:45,600
0,390 720,930 930,990 990,1200 1200,1590
lock| {any -} other process
|任何在同一时间获取锁的进程，

578
00:18:45,600 --> 00:18:46,920
0,120 120,450 450,780 780,1260 1260,1320
that basically {trying,to} acquire the

579
00:18:46,920 --> 00:18:48,150
0,270 270,330 330,420 420,690 690,1230
lock at the same time,|
|

580
00:18:48,180 --> 00:18:49,350
0,240 240,360 360,780 780,1080 1080,1170
has to wait until the
必须等到第一个进程调用 release 。

581
00:18:49,350 --> 00:18:51,000
0,330 330,660 660,900 900,1170 1170,1650
first process actually calls release.|
|

582
00:18:52,560 --> 00:18:54,600
0,210 210,330 330,960 990,1800 1920,2040
And so this sequence,| you
所以，这个序列，|这些在 acquire release 之间的指令，

583
00:18:54,600 --> 00:18:56,550
0,240 240,810 810,1740 1740,1860 1860,1950
know the instructions, you know

584
00:18:56,550 --> 00:18:59,790
0,840 1080,1290 1290,1740 1740,2370 2610,3240
between the acquire release,| are
|经常称为临界区间。

585
00:18:59,790 --> 00:19:01,020
0,150 150,360 360,420 420,750 750,1230
often called the critical section.|
|

586
00:19:07,720 --> 00:19:08,650
0,240 240,480 480,690 690,750 750,930
And one reason is called
被称为临界区间的一个原因是

587
00:19:08,650 --> 00:19:09,970
0,60 60,360 360,690 690,900 900,1320
the critical section is| because
|因为这些指令一起执行，

588
00:19:09,970 --> 00:19:11,110
0,420 420,510 510,660 660,780 780,1140
this is sort of the

589
00:19:11,320 --> 00:19:12,820
0,300 300,450 450,720 720,1110 1110,1500
{} the few instruction together

590
00:19:12,820 --> 00:19:14,740
0,120 120,360 360,750 780,1470 1560,1920
to do the| {you,know} need
|需要对 r 进行更新，

591
00:19:14,740 --> 00:19:16,090
0,60 60,210 210,360 360,1140 1140,1350
to do the update to

592
00:19:16,090 --> 00:19:17,560
0,360 360,690 690,930 930,1140 1140,1470
r,| whatever shared data structure,
|由锁保护的任何共享数据结构，

593
00:19:17,560 --> 00:19:18,850
0,240 240,660 660,780 780,900 900,1290
that's protected by the lock|
|

594
00:19:19,090 --> 00:19:20,680
0,150 150,270 270,690 690,1080
in an atomic fashion.|
使用原子地方式。|

595
00:19:21,090 --> 00:19:22,920
0,300 300,480 480,990 990,1140 1140,1830
{} And ensures that basically,|
并且确保，|

596
00:19:23,460 --> 00:19:24,510
0,240 240,390 390,510 510,690 690,1050
{} if you have multiple
如果你在 acquire release 之间有多条指令，

597
00:19:24,510 --> 00:19:26,100
0,570 570,780 780,1140 1140,1230 1230,1590
instructions in this you know

598
00:19:26,370 --> 00:19:28,320
0,660 660,1050 1050,1500 1500,1770 1770,1950
between acquire release,| but they
|但它们要么一起执行，要么一个都不执行。

599
00:19:28,320 --> 00:19:31,500
0,510 510,690 690,1380 1680,2340 2520,3180
all are executed all together

600
00:19:31,800 --> 00:19:33,080
0,300 300,750
or none.|
|

601
00:19:33,800 --> 00:19:35,030
0,150 150,360 360,690 690,720 720,1230
So there's never a case,|
所以，不会出现这种情况，|

602
00:19:35,030 --> 00:19:36,590
0,600 600,1110 1110,1200 1200,1260 1260,1560
these instructions in the critical
临界区的这些指令交错执行，

603
00:19:36,590 --> 00:19:38,870
0,540 630,870 870,1680 1890,2190 2190,2280
section are interleaved| as in
|像我们在竞态条件下看到的那样，

604
00:19:38,870 --> 00:19:39,650
0,120 120,330 330,480 480,570 570,780
the way that we saw

605
00:19:39,650 --> 00:19:41,060
0,90 90,150 150,330 330,780 1260,1410
in the race conditions| and
|实际上，这用来避免竞态条件。

606
00:19:41,060 --> 00:19:42,440
0,300 300,750 750,930 930,1020 1020,1380
actually exactly, that is what

607
00:19:42,440 --> 00:19:44,220
0,360 360,540 540,750 750,1410
avoids these race conditions.|
|

608
00:19:48,190 --> 00:19:49,420
0,210 210,540 540,810 810,990 990,1230
Any questions about the lock
关于锁抽象，有什么问题吗？

609
00:19:49,420 --> 00:19:50,580
0,600
abstraction?|
|

610
00:19:55,220 --> 00:19:56,720
0,240 240,900
{You,know} programs
程序通常有很多锁，

611
00:19:56,780 --> 00:19:58,860
0,420 420,870 870,1530
{} typically have

612
00:20:00,270 --> 00:20:02,130
0,360 360,900 990,1200 1200,1470 1470,1860
many locks,| in fact {the
|实际上 xv6 就有很多锁。

613
00:20:02,400 --> 00:20:03,300
0,150 150,330 330,540 540,690 690,900
-} {xv6 -} has many

614
00:20:03,300 --> 00:20:04,320
0,450
locks.|
|

615
00:20:08,140 --> 00:20:09,250
0,300 300,390 390,660 660,780 780,1110
And the reason to have
有很多锁的原因是，

616
00:20:09,250 --> 00:20:10,360
0,270 270,600 600,690 690,990 990,1110
many locks is| because you
|因为即使，

617
00:20:10,360 --> 00:20:11,290
0,210 210,480 480,660 660,810 810,930
know even though,| you know
|锁可以序列化进程的执行，

618
00:20:11,290 --> 00:20:14,020
0,540 540,840 1140,1800 1800,2490 2490,2730
the the lock {serializes -}

619
00:20:14,020 --> 00:20:16,060
0,270 270,840 1020,1110 1110,1290 1290,2040
the execution| of two processes
|两个进入临界区间的进程，

620
00:20:16,060 --> 00:20:17,830
0,270 270,540 540,1320 1380,1650 1650,1770
{you,know} {what -} enter the

621
00:20:17,830 --> 00:20:19,330
0,300 300,630 630,840 840,1020 1020,1500
critical section,| only one succeeds,|
|只有一个可以成功，

622
00:20:19,330 --> 00:20:21,520
0,270 270,330 330,510 510,930 1110,2190
and the other one runs
另一个在第一个完成后运行临界区间，

623
00:20:21,520 --> 00:20:22,660
0,120 120,390 390,690 690,1020 1020,1140
that critical section after the

624
00:20:22,660 --> 00:20:25,360
0,210 210,570 720,1770 1770,1830 2190,2700
first one { -} finishes,|
|

625
00:20:25,540 --> 00:20:27,160
0,150 150,360 360,870 870,1080 1080,1620
so there's no {sort,of} parallelism
所以这里没有并行。

626
00:20:27,160 --> 00:20:28,040
0,120 120,480
at all.|
|

627
00:20:28,500 --> 00:20:29,820
0,240 240,570 660,930 930,1020 1020,1320
{} So if the kernel
如果内核只有一个锁，

628
00:20:29,820 --> 00:20:31,560
0,150 150,390 390,720 720,1260 1290,1740
had only one lock,| which
|通常称为大内核锁，

629
00:20:31,560 --> 00:20:32,760
0,210 210,480 480,840 840,990 990,1200
is typically called a big

630
00:20:32,760 --> 00:20:34,710
0,300 300,630 780,1020 1020,1590 1620,1950
kernel lock,| then basically every
|那么内核中每个系统调用都会被串行化，

631
00:20:34,710 --> 00:20:36,630
0,390 390,930 1260,1530 1530,1710 1710,1920
system call {} in this,

632
00:20:36,630 --> 00:20:37,650
0,390 390,510 510,570 570,870 870,1020
{} in the kernel, would

633
00:20:37,650 --> 00:20:40,380
0,90 90,780 1590,1890 1890,2250 2250,2730
be serialized,| system call one
|系统调用 1 获取大内核锁，

634
00:20:40,440 --> 00:20:42,000
0,570 870,1140 1140,1200 1200,1470 1470,1560
start gets the one the

635
00:20:42,000 --> 00:20:43,590
0,210 210,510 510,1020 1020,1320 1320,1590
big kernel lock,| does whatever
|做它想做的事情，

636
00:20:43,590 --> 00:20:44,430
0,60 60,270 270,360 360,720 720,840
it needs to do,| and
|然后释放大内核锁，

637
00:20:44,430 --> 00:20:45,630
0,330 330,660 660,750 750,930 930,1200
then release the big kernel

638
00:20:45,630 --> 00:20:46,770
0,240 240,330 330,450 450,840 840,1140
lock| and then basically returns
|然后返回用户空间。

639
00:20:46,770 --> 00:20:47,860
0,300 300,720
user space.|
|

640
00:20:48,220 --> 00:20:49,180
0,390 390,510 510,660 660,720 720,960
{} And then the second
然后第二个系统调用运行，

641
00:20:49,180 --> 00:20:50,590
0,240 240,420 420,480 480,810 1200,1410
system call the run,| so
|所以我们有并行运行的程序，

642
00:20:50,590 --> 00:20:51,970
0,150 150,270 270,360 360,810 810,1380
we have an parellel application,|
|

643
00:20:51,970 --> 00:20:53,110
0,180 180,510 510,870 870,960 960,1140
that runs, lots of runs
并行运行大量的系统调用，

644
00:20:53,110 --> 00:20:54,820
0,240 240,450 450,510 510,1170 1200,1710
system calls in parallel,| suddenly
|突然所有的系统调用都是串行运行的，

645
00:20:54,820 --> 00:20:56,290
0,90 90,270 270,660 660,1110 1140,1470
you know all the system

646
00:20:56,290 --> 00:20:57,910
0,300 300,570 570,900 900,1440 1440,1620
calls actually run serially,| if
|如果我们只有一把锁的话。

647
00:20:57,910 --> 00:20:58,960
0,90 90,270 270,480 480,690 690,1050
we had only one lock.|
|

648
00:20:59,880 --> 00:21:01,650
0,240 240,690 750,1230 1230,1380 1380,1770
And so typically your program
所以通常程序，比如 xv6 有很多锁，

649
00:21:01,650 --> 00:21:02,670
0,270 270,360 360,450 450,720 720,1020
like, you know {xv6 -}

650
00:21:02,670 --> 00:21:04,170
0,600 600,720 720,840 840,1080 1080,1500
has you know many locks,|
|

651
00:21:04,170 --> 00:21:05,310
0,270 270,360 360,810 810,900 900,1140
because of these, you know
因为这样，我们可以得到一些并行性。

652
00:21:05,310 --> 00:21:06,360
0,120 120,210 210,360 360,510 510,1050
we can get some parallelism.|
|

653
00:21:09,670 --> 00:21:10,760
0,540
Because,
因为，如果两个系统调用使用两个不同的锁，

654
00:21:13,350 --> 00:21:14,310
0,120 120,210 210,660 690,840 840,960
you know if you know

655
00:21:14,310 --> 00:21:15,810
0,300 300,600 600,840 840,900 900,1500
two system calls for example

656
00:21:15,810 --> 00:21:17,940
0,240 240,420 420,720 720,1260 1560,2130
use two different locks {},|
|

657
00:21:17,970 --> 00:21:18,930
0,510 510,600 600,690 690,870 870,960
then you know they can
那么它们实际上可以完全并行运行，

658
00:21:18,930 --> 00:21:21,060
0,210 210,630 720,1080 1080,1530 1530,2130
actually run a completely parallel,|
|

659
00:21:21,270 --> 00:21:23,670
0,360 360,840 840,1260 1260,1920 2010,2400
{} without any {} {you,know}
没有任何串行化，

660
00:21:23,670 --> 00:21:26,070
0,630 1020,1530 1530,2070 2070,2160 2160,2400
serialization,| because basically you know
|因为使用不同的锁进行串行化。

661
00:21:26,100 --> 00:21:28,360
0,630 630,900 900,1200 1200,1890
using different locks serialize.|
|

662
00:21:29,790 --> 00:21:30,980
0,630

663
00:21:31,070 --> 00:21:33,120
0,630 810,1500
Now {}.|
现在。|

664
00:21:34,040 --> 00:21:35,570
0,390 390,810 810,1050 1050,1110 1110,1530
There's a couple of important
有几点很重要，

665
00:21:35,570 --> 00:21:39,560
0,480 810,1710 2070,2820 3060,3780 3780,3990
points,| {} the nobody really
|在这个接口中没有什么是强制的，

666
00:21:39,560 --> 00:21:40,550
0,150 150,270 270,720 720,810 810,990
sort of forces in this

667
00:21:40,550 --> 00:21:41,960
0,720 720,870 870,990 990,1290 1290,1410
interface,| you know that you
|你使用 acquire release ，

668
00:21:41,960 --> 00:21:43,790
0,210 210,450 450,840 840,1380 1380,1830
put in the acquire release,|
|

669
00:21:43,790 --> 00:21:44,300
0,90 90,180 180,300 300,450 450,510
you know it's up to
这是由程序决定的。

670
00:21:44,300 --> 00:21:45,410
0,120 120,540 540,630 630,780 780,1110
the program to do so.|
|

671
00:21:46,010 --> 00:21:47,090
0,240 240,390 390,480 480,780 780,1080
{} So if you want
所以，如果你希望代码段是原子的，

672
00:21:47,090 --> 00:21:47,930
0,60 60,360 360,540 540,600 600,840
a particular piece of code

673
00:21:47,930 --> 00:21:51,260
0,90 90,630 660,1710 1710,2250 2610,3330
to be {} atomic,| then
|由开发人员将 acquire release 那里。

674
00:21:51,290 --> 00:21:52,280
0,150 150,300 300,390 390,540 540,990
it's up to the developer

675
00:21:52,280 --> 00:21:54,410
0,120 120,690 720,1200 1200,1710 1710,2130
to actually {put,these} acquire release

676
00:21:54,410 --> 00:21:55,140
0,150
there.|
|

677
00:21:55,230 --> 00:21:57,480
0,210 210,450 450,1050 1050,1440 1470,2250
And there clearly see {},|
从这里可以清楚地看到，|

678
00:21:57,480 --> 00:22:00,120
0,390 390,510 510,1020 1320,1980
you can imagine {},
你可以想象，这需要一些技巧性，

679
00:22:00,300 --> 00:22:01,560
0,360 360,510 510,540 540,690 690,1260
that there's a little bit

680
00:22:01,560 --> 00:22:02,670
0,150 150,240 240,660 870,1020 1020,1110
can be tricky,| so it's
|所以需要认识到，

681
00:22:02,670 --> 00:22:03,750
0,330 330,390 390,840 840,960 960,1080
important to realize that| you
|锁并不是自动为你完成原子化的，

682
00:22:03,750 --> 00:22:04,890
0,90 90,270 300,690 690,780 780,1140
know that locking is not

683
00:22:04,890 --> 00:22:06,630
0,270 270,510 510,1110 1110,1410 1410,1740
actually done automatically for you,|
|

684
00:22:06,870 --> 00:22:08,100
0,390 390,630 630,870 870,1050 1050,1230
{} it's all up to
一切都由开发者决定的，

685
00:22:08,100 --> 00:22:09,900
0,600 630,1230 1230,1320 1320,1620 1620,1800
the developer to figure out,|
|

686
00:22:09,900 --> 00:22:12,000
0,300 330,960 960,1290 1290,1650
to associate locks with
将锁与数据结构关联，

687
00:22:12,000 --> 00:22:15,570
0,780 810,1170 1170,1800 2100,3000 3000,3570
{} data structures| and ensuring
|并确保适当的 acquire release 在那里。

688
00:22:15,570 --> 00:22:18,150
0,300 300,1020 1020,1470 1470,1950 1950,2580
that the appropriate acquire release

689
00:22:18,180 --> 00:22:19,540
0,300 300,480 480,840
{} are there.|
|

690
00:22:23,050 --> 00:22:24,850
0,540 690,930 930,1440 1440,1530 1530,1800
{} So clearly the case,
所以，很明显地情况，锁限制了并行性，

691
00:22:24,850 --> 00:22:27,910
0,210 210,300 300,690 780,2220 2580,3060
like you know the locks

692
00:22:27,910 --> 00:22:30,010
0,780 810,1260 1260,1470 1470,2010 2010,2100
{} limit in parallelism,| and
|并且因此限制了性能，

693
00:22:30,010 --> 00:22:32,620
0,360 360,840 840,1500 1800,2400 2400,2610
therefore limit performance,| {} and
|所以，这就提出了何时使用锁的问题。

694
00:22:32,620 --> 00:22:33,730
0,120 120,540 540,720 720,1050 1050,1110
so then this raises the

695
00:22:33,730 --> 00:22:35,540
0,420 420,690 690,810 810,1350
question when to lock.|
|

696
00:22:42,710 --> 00:22:43,820
0,540 600,810 810,930 930,990 990,1110
And I'm going to give
我要给你们一种保守的规则，

697
00:22:43,820 --> 00:22:45,950
0,90 90,270 270,360 360,1530 1530,2130
you sort of {} conservative

698
00:22:45,950 --> 00:22:48,110
0,480 690,1200 1560,1920 1920,2100 2100,2160
rule,| {} but it's a
|但这是考虑这件事的一个很好的起点。

699
00:22:48,110 --> 00:22:49,100
0,150 150,420 420,600 600,660 660,990
good one as a starting

700
00:22:49,100 --> 00:22:50,150
0,180 180,270 270,450 450,690 690,1050
point to think about things.|
|

701
00:22:50,680 --> 00:22:52,800
0,330 330,450 450,990 990,1500
So the conservative rule,
所以这个保守的规则，或者叫做指导原则更好，

702
00:22:56,930 --> 00:22:58,910
0,270 270,570 570,1260 1260,1470 1470,1980
or maybe guidelines is better,|
|

703
00:22:58,910 --> 00:22:59,860
0,660

704
00:23:00,090 --> 00:23:01,860
0,240 240,810 990,1170 1170,1470 1470,1770
{} [] is that you
[]是你有两个进程，

705
00:23:01,860 --> 00:23:03,660
0,150 150,330 330,1170
have two processes,|
|

706
00:23:05,740 --> 00:23:08,400
0,330 330,1080 1110,1950
two processes access
两个进程访问一个共享数据结构。

707
00:23:09,280 --> 00:23:11,080
0,180 180,360 360,600 600,1230
a shared data structure.|
|

708
00:23:17,130 --> 00:23:18,990
0,210 210,480 480,660 660,1020 1470,1860
And one is, {} one
其中一个是写入者或更新者，

709
00:23:18,990 --> 00:23:20,480
0,120 120,240 240,690
of the {them,is}

710
00:23:20,750 --> 00:23:22,100
0,210 210,690 690,900 900,960 960,1350
a writer or an updater|
|

711
00:23:22,100 --> 00:23:24,110
0,270 360,630 630,1170 1650,1770 1770,2010
{} so meaning it's actually
这意味着它对共享数据结构做修改。

712
00:23:24,110 --> 00:23:25,310
0,150 150,630 630,720 720,930 930,1200
does modify to share data

713
00:23:25,310 --> 00:23:26,420
0,570
structure.|
|

714
00:23:27,050 --> 00:23:28,820
0,720 930,1230 1230,1350 1350,1440 1440,1770
Then you need a lock
那么你需要对这个数据结构使用锁。

715
00:23:28,820 --> 00:23:30,300
0,120 120,210 210,450 450,930
for that data structure.|
|

716
00:23:40,620 --> 00:23:41,610
0,180 180,360 360,420 420,480 480,990
So this is a conservative
所以这是一条保守的规则，

717
00:23:41,610 --> 00:23:42,630
0,210 360,630 630,720 720,900 900,1020
rule,| sort of like a
|像是告警的红旗，

718
00:23:42,630 --> 00:23:44,550
0,240 240,780 840,1080 1080,1260 1260,1920
red flag,| when you're programming
|当你编程时，并且有一个由多个进程访问的数据结构，

719
00:23:44,550 --> 00:23:47,190
0,900 1020,1230 1230,1680 1680,2430 2430,2640
and you have a data

720
00:23:47,190 --> 00:23:48,360
0,420 420,540 540,660 660,990 990,1170
structure that is accessed by

721
00:23:48,360 --> 00:23:49,800
0,360 360,990 990,1110 1110,1320 1320,1440
multiple processes| and what could
|那么什么是写入者，

722
00:23:49,800 --> 00:23:50,820
0,90 90,150 150,660 720,870 870,1020
be a writer| at that
|在这时候，你应该想，

723
00:23:50,820 --> 00:23:51,960
0,240 240,450 450,660 660,780 780,1140
point you should be thinking,|
|

724
00:23:51,960 --> 00:23:53,130
0,300 300,510 510,570 570,1080 1080,1170
okay, there's a possibility of
好的，这里可能有竞态条件，

725
00:23:53,130 --> 00:23:54,510
0,240 240,780 960,1050 1050,1230 1230,1380
race condition,| you want to
|你希望避免这种竞态条件，

726
00:23:54,510 --> 00:23:55,530
0,360 360,600 600,780 780,840 840,1020
avoid this you know race

727
00:23:55,530 --> 00:23:57,090
0,510 750,1080 1080,1350 1350,1470 1470,1560
condition,| you stick in a
|你使用锁，

728
00:23:57,090 --> 00:23:58,320
0,510 540,660 660,990 990,1170 1170,1230
lock,| { -} use a
|使用锁来保证这个竞态条件不会发生。

729
00:23:58,320 --> 00:24:00,360
0,390 390,630 630,1230 1260,1920 1920,2040
lock to {} guarantee that

730
00:24:00,360 --> 00:24:01,650
0,150 150,330 330,660 660,930 930,1290
this race condition can't happen.|
|

731
00:24:02,450 --> 00:24:04,220
0,420 570,990 990,1080 1080,1230 1230,1770
But you know those rules
但是，这些规则在某些方面太严格了。

732
00:24:04,310 --> 00:24:05,930
0,570 570,960 1050,1260 1260,1470 1470,1620
{} in some ways too

733
00:24:05,930 --> 00:24:07,060
0,540
strict.|
|

734
00:24:10,890 --> 00:24:12,600
0,240 240,480 480,540 540,990 990,1710
{} There are cases where
在某些情况下，可以处理共享数据结构的这些操作，

735
00:24:12,630 --> 00:24:14,520
0,240 240,960 1230,1350 1350,1710 1710,1890
it's okay to process these

736
00:24:14,520 --> 00:24:15,600
0,300 300,360 360,570 570,780 780,1080
actions of shared data structure|
|

737
00:24:15,600 --> 00:24:16,470
0,90 90,300 300,360 360,420 420,870
and one is a writer,|
其中一个是写入者，|

738
00:24:16,530 --> 00:24:19,110
0,540 870,1530 1530,1680 1680,2010 2010,2580
in particular, there are styles
特别地是，有一种编程风格称为无锁编程。

739
00:24:19,110 --> 00:24:20,970
0,360 420,1110 1110,1410 1410,1680 1680,1860
of programming called {lock-free -}

740
00:24:20,970 --> 00:24:22,180
0,660
programming.|
|

741
00:24:22,610 --> 00:24:24,470
0,210 210,390 390,660 660,1290 1440,1860
{} That actually totally where
这是各种会发生的情况。

742
00:24:24,620 --> 00:24:26,720
0,660 660,930 930,1470 1470,1800 1800,2100
these {kinds,of} scenarios actually do

743
00:24:26,720 --> 00:24:27,920
0,510
happen.|
|

744
00:24:32,310 --> 00:24:33,240
0,300 300,390 390,600 600,660 660,930
Anyway, you want to {lock-free
无论如何，你想使用无锁编程，

745
00:24:33,240 --> 00:24:34,320
0,150 150,570 570,660 660,1020 1020,1080
-} programming| is basically to
|是为了获得更好的性能或更多的并行性。

746
00:24:34,320 --> 00:24:35,880
0,120 120,330 330,1020 1080,1260 1260,1560
get better performance or more

747
00:24:35,880 --> 00:24:37,060
0,540
parallelism.|
|

748
00:24:38,730 --> 00:24:40,260
0,360 360,510 510,840 840,990 990,1530
Lock free program is tricky,|
无锁编程是很难的，|

749
00:24:40,350 --> 00:24:41,850
0,510 510,720 720,990 990,1380 1380,1500
{} even more tricky {you,know}
甚至比使用锁编程更难，

750
00:24:41,850 --> 00:24:44,310
0,510 510,1080 1440,2130 2130,2220 2220,2460
programming {of,locks},| and {you,know} we'll
|我们会在本学期末讨论这个问题，

751
00:24:44,310 --> 00:24:45,030
0,240 240,420 420,510 510,600 600,720
talk about it at the

752
00:24:45,030 --> 00:24:45,930
0,120 120,210 210,360 360,810 810,900
end of this semester,| we
|我们会研究一些无锁编程风格，

753
00:24:45,930 --> 00:24:48,210
0,120 150,570 570,990 990,1950 1980,2280
will study some {} {lock-free

754
00:24:48,210 --> 00:24:49,890
0,210 210,750 750,900 900,1110 1110,1680
-} styles of the programming|
|

755
00:24:49,890 --> 00:24:52,770
0,270 300,900 900,1620 1650,2160 2160,2880
or particularly {} common in
特别是在操作系统内核中常见的。

756
00:24:52,800 --> 00:24:54,380
0,420 420,660 660,1170
operating system kernels.|
|

757
00:24:54,440 --> 00:24:55,400
0,210 210,360 360,660 660,780 780,960
{} {Basically -}, for this
基本上，对于这节课以及本学期的剩下的大部分课，

758
00:24:55,400 --> 00:24:57,380
0,570 780,1200 1260,1710 1710,1800 1800,1980
lecture and most of the

759
00:24:57,380 --> 00:24:58,610
0,180 180,240 240,300 300,840 930,1230
rest of the semester,| we're
|我们会考虑这种情况，

760
00:24:58,610 --> 00:24:59,630
0,120 120,180 180,390 390,690 690,1020
going to be thinking about

761
00:24:59,630 --> 00:25:02,030
0,60 60,480 480,1020 1200,1770 1770,2400
the case,| we're using locks,
|我们使用锁来控制共享。

762
00:25:02,030 --> 00:25:05,480
0,210 210,1530 1830,2790 2820,3030 3030,3450
{you,know} to control {} sharing.|
|

763
00:25:06,280 --> 00:25:08,050
0,810 840,1050 1050,1260 1260,1620 1650,1770
And that's hard enough,| you
这已经很难了，|只用锁，也不是那么简单的。

764
00:25:08,050 --> 00:25:09,490
0,360 390,750 750,960 960,1170 1170,1440
know you just use locks,

765
00:25:09,490 --> 00:25:10,810
0,90 90,210 210,390 390,1020 1020,1320
its not that straightforward either.|
|

766
00:25:12,520 --> 00:25:14,080
0,540 600,960 960,1170 1170,1380 1380,1560
{} So in one hand,
所以一方面，有点太严格了，

767
00:25:14,080 --> 00:25:15,490
0,30 30,180 180,780 780,870 870,1410
a little bit too strict,|
|

768
00:25:15,760 --> 00:25:17,200
0,510 510,900 900,1110 1110,1380 1380,1440
{} because not always the
因为并不总是所有情况都需要，

769
00:25:17,200 --> 00:25:18,430
0,240 240,390 390,810 810,1080 1080,1230
case that you need| and
|也有一些情况太宽松了。

770
00:25:18,430 --> 00:25:19,900
0,210 210,360 360,720 720,870 870,1470
also some cases too loose.|
|

771
00:25:20,230 --> 00:25:21,340
0,600

772
00:25:21,340 --> 00:25:22,780
0,150 150,300 300,540 540,870
If you might just.|
如果你可能只是。|

773
00:25:23,490 --> 00:25:24,760
0,780

774
00:25:26,200 --> 00:25:27,610
0,180 180,330 330,660 660,1260 1260,1410
You might [] loose,| you
你可能[]宽松，|你想使用锁，

775
00:25:27,610 --> 00:25:28,240
0,150 150,210 210,420 420,540 540,630
want to actually make you

776
00:25:28,240 --> 00:25:29,320
0,150 150,210 210,420 420,870 870,1080
know to use locks,| {you,know}
|来保证一些其他属性，

777
00:25:29,320 --> 00:25:31,630
0,240 240,630 630,750 750,1800 1830,2310
to enforce some other properties,|
|

778
00:25:31,630 --> 00:25:32,230
0,120 120,240 240,360 360,510 510,600
like if you look at
比如你看一下 printf ，

779
00:25:32,230 --> 00:25:33,400
0,240 240,510
{printf -},|
|

780
00:25:34,790 --> 00:25:35,720
0,360

781
00:25:35,750 --> 00:25:36,890
0,210 210,300 300,630 630,660 660,1140
if we pass a string
如果我们将一个字符串传递给 printf ，

782
00:25:36,890 --> 00:25:38,280
0,150 150,390 390,780
to {printf -},|
|

783
00:25:38,280 --> 00:25:39,720
0,450 450,570 570,690 690,990 990,1440
{} you know the xv6
xv6 内核试图，

784
00:25:39,720 --> 00:25:40,890
0,300 300,570 570,720 720,840 840,1170
kernel tries to| at least
|至少让整个字符串原子地打印出来。

785
00:25:40,890 --> 00:25:41,940
0,60 60,330 360,570 570,660 660,1050
you know get the whole

786
00:25:41,940 --> 00:25:44,220
0,600 930,1050 1050,1290 1290,1650 1650,2280
string to be printed atomically.|
|

787
00:25:44,760 --> 00:25:46,200
0,660 660,1050 1050,1170 1170,1260 1260,1440
{} And you know there's
而且你知道这里不涉及共享数据结构，

788
00:25:46,200 --> 00:25:47,640
0,120 120,330 330,570 570,870 870,1440
no shared data structure involved,|
|

789
00:25:47,850 --> 00:25:49,680
0,360 360,540 540,660 660,1200 1230,1830
{} but it's still useful
但在这种情况下使用锁仍然很有用，

790
00:25:49,680 --> 00:25:50,610
0,120 120,390 390,570 570,630 630,930
to actually use a lock

791
00:25:50,610 --> 00:25:51,930
0,60 60,210 210,540 540,900 900,1320
in that particular case,| because
|因为我们希望输出是串行化的。

792
00:25:51,930 --> 00:25:52,710
0,90 90,270 270,390 390,690 690,780
we want the output to

793
00:25:52,710 --> 00:25:53,880
0,90 90,720
be serialized.|
|

794
00:25:54,220 --> 00:25:55,330
0,330 330,660 690,870 870,1050 1050,1110
{} So this rule is
所以这个规则并不完美，

795
00:25:55,330 --> 00:25:56,890
0,480 480,990 990,1380 1380,1470 1470,1560
not perfect,| but it's a
|但它是一个不错的指导原则。

796
00:25:56,890 --> 00:25:58,460
0,270 270,480 480,990
pretty good guideline.|
|

797
00:26:00,020 --> 00:26:01,910
0,210 210,630 630,870 870,1380 1380,1890
Any questions about this rule?|
关于这条规则，有什么问题吗？|

798
00:26:04,810 --> 00:26:05,950
0,300 300,450 450,630 630,720 720,1140
{} I had a question
我有一个问题不是关于这个规则的，

799
00:26:05,950 --> 00:26:07,270
0,180 180,420 420,660 660,900 900,1320
not about this rule,| but
|但是有没有可能两个进程同时获取锁，

800
00:26:07,960 --> 00:26:09,490
0,300 300,450 450,870 870,1200 1290,1530
isn't it possible that two

801
00:26:09,490 --> 00:26:11,020
0,570 570,720 720,1170 1170,1290 1290,1530
processes could acquire the lock

802
00:26:11,020 --> 00:26:12,130
0,90 90,180 180,510 510,930 930,1110
at the same time| and
|因此可以修改数据结构。

803
00:26:12,130 --> 00:26:13,200
0,450
so

804
00:26:13,470 --> 00:26:14,940
0,150 150,330 330,630 630,930 960,1470
would be able to modify

805
00:26:14,940 --> 00:26:16,280
0,90 90,750
the structure.|
|

806
00:26:16,460 --> 00:26:17,780
0,240 240,450 450,660 660,840 840,1320
Yeah, no, so so part
是的，不是，锁的一部分规定是

807
00:26:17,780 --> 00:26:18,980
0,120 120,270 270,420 420,480 480,1200
of the sort of contract

808
00:26:19,130 --> 00:26:20,420
0,240 240,780 780,960 960,1110 1110,1290
lock construction is is that|
|

809
00:26:20,420 --> 00:26:22,850
0,210 210,870 870,1320 1320,1920 1950,2430
it's impossible two {} process
两个进程不能同时获得锁。

810
00:26:22,850 --> 00:26:23,810
0,90 90,540 540,630 630,900 900,960
to acquire a lock at

811
00:26:23,810 --> 00:26:24,960
0,60 60,270 270,600
the same time.|
|

812
00:26:25,290 --> 00:26:28,440
0,600 630,1170 1170,1530 2460,2940 2940,3150
{} If the rule is
这条规则，永远不会有这种情况，

813
00:26:28,440 --> 00:26:30,060
0,180 180,450 450,810 810,1080 1080,1620
that there's ever there's no,

814
00:26:30,180 --> 00:26:31,500
0,300 300,510 510,600 600,960 960,1320
there's never a case,| where
|两个进程可以同时获得锁，

815
00:26:31,500 --> 00:26:33,270
0,510 540,1080 1080,1380 1380,1710 1710,1770
two process actually acquire the

816
00:26:33,270 --> 00:26:35,040
0,330 1110,1260 1260,1470 1470,1530 1530,1770
lock, can hold the lock

817
00:26:35,040 --> 00:26:36,360
0,90 90,150 150,360 360,600 900,1320
at the same time,| {we'll,see}
|我们过一会会看到如何实现它，

818
00:26:36,360 --> 00:26:36,990
0,60 60,120 120,390 390,510 510,630
in the second, how to

819
00:26:36,990 --> 00:26:38,790
0,390 390,600 600,1200 1200,1320 1320,1800
implement that,| but the API
|但是 API 或规范要求是，

820
00:26:38,790 --> 00:26:40,980
0,150 150,210 210,1020 1020,1620 2010,2190
or the specification {require,is},| there's
|在任何给定的时间点，只有一个进程或没有持有锁。

821
00:26:40,980 --> 00:26:42,180
0,180 180,450 450,690 690,1020 1020,1200
only one lock holder at

822
00:26:42,180 --> 00:26:43,200
0,210 210,480 480,690 690,750 750,1020
any given point in time

823
00:26:43,350 --> 00:26:45,000
0,180 180,1230
or zero.|
|

824
00:26:45,090 --> 00:26:46,100
0,450
Yes.|
好的。|

825
00:26:49,300 --> 00:26:52,000
0,570 630,1230 1260,1860 2070,2520 2520,2700
{} Okay, so, {} you
好的，如果我们看一些锁编程，

826
00:26:52,000 --> 00:26:52,810
0,150 150,270 270,360 360,540 540,810
know if we see you

827
00:26:52,810 --> 00:26:55,390
0,180 180,600 600,1170 1500,2100 2100,2580
know programming lock,| slightly {}
|可能产生一些问题，因为这些竞态条件。

828
00:26:55,390 --> 00:26:57,100
0,300 300,450 450,900 930,1500 1500,1710
it could be problematic, because

829
00:26:57,100 --> 00:26:58,600
0,60 60,210 210,390 390,990
of these race conditions.|

830
00:26:58,600 --> 00:26:59,680
0,540

831
00:26:59,950 --> 00:27:01,870
0,600 600,720 720,990 990,1080 1080,1920
{You,know}, of course the particular
当然，那个在 kfree 中的竞态条件，

832
00:27:01,870 --> 00:27:02,860
0,210 210,510 510,630 630,720 720,990
race condition, that we looked

833
00:27:02,860 --> 00:27:05,440
0,270 330,1050 1050,1860 1890,2100 2100,2580
at {} {in,the} {kfree -}|
|

834
00:27:05,620 --> 00:27:06,640
0,210 210,390 390,480 480,930 930,1020
or that we created in
或者是我们在 kfree 中创造的，

835
00:27:06,640 --> 00:27:08,620
0,540 720,900 900,1080 1110,1500 1500,1980
kfree,| which were easily spotted
|使用一些方法很容易发现，

836
00:27:08,620 --> 00:27:09,550
0,120 120,330 330,660 660,810 810,930
in some ways| and the
|实际上，如果使用一个竞态检查工具，

837
00:27:09,550 --> 00:27:10,660
0,300 300,390 390,510 510,660 660,1110
fact you know if {use,a}

838
00:27:10,660 --> 00:27:12,370
0,120 120,600 600,1170 1230,1620 1620,1710
race detection tool,| {} it
|它会立即找到它。

839
00:27:12,370 --> 00:27:13,820
0,150 150,540 540,810 810,1050
would immediately find it.|
|

840
00:27:13,820 --> 00:27:15,380
0,540 690,1050 1050,1380 1380,1410 1410,1560
{} But there are more
但还有更复杂的情况，

841
00:27:15,380 --> 00:27:18,110
0,540 540,1170 1470,2100 2310,2550 2550,2730
tricky cases,| {} so you
|你可能会想，为什么可以这样，

842
00:27:18,110 --> 00:27:19,760
0,180 180,870 870,1020 1020,1440 1440,1650
may wonder like why could

843
00:27:19,760 --> 00:27:21,410
0,150 150,330 330,870 900,1440 1440,1650
use like make,| could make
|可以使加锁使原子的。

844
00:27:21,410 --> 00:27:23,690
0,690 1020,1260 1260,1620 1620,1830 1830,2280
locks or could make locking

845
00:27:23,690 --> 00:27:24,780
0,660
atomic.|
|

846
00:27:31,120 --> 00:27:32,980
0,360 360,600 600,930 930,1260 1500,1860
So you follow this simple
所以，你遵循我刚在说的简单规则，

847
00:27:32,980 --> 00:27:34,450
0,330 330,510 510,1110 1110,1290 1290,1470
rule, that {I,just,stated},| you know
|你知道，如果我们每次共享数据结构，

848
00:27:34,450 --> 00:27:35,650
0,270 270,420 420,690 690,930 930,1200
then if every we shared

849
00:27:35,650 --> 00:27:37,690
0,240 240,840 1050,1800 1800,1860 1860,2040
data structure,| then you know
|那么共享数据结构中的操作就需要锁，

850
00:27:37,690 --> 00:27:38,950
0,600 600,660 660,810 810,1020 1020,1260
operations in that shared data

851
00:27:38,950 --> 00:27:41,170
0,300 300,630 630,1170 1170,1560 1590,2220
structure basically require lock,| we
|我们应该在每个操作中把锁和数据结构关联起来，

852
00:27:41,290 --> 00:27:42,340
0,240 240,660 660,720 720,960 960,1050
should associate a lock with

853
00:27:42,340 --> 00:27:43,510
0,120 120,330 330,870 960,1110 1110,1170
the data structure in the

854
00:27:43,510 --> 00:27:46,060
0,240 240,720 720,1230 1230,1560 1980,2550
every operations,| actually { -}
|

855
00:27:48,270 --> 00:27:49,950
0,180 180,420 420,600 600,1230 1230,1680
that is a it's performed
实际上，它在数据结构上执行，

856
00:27:49,950 --> 00:27:53,340
0,120 120,420 420,1770 2610,3120 3120,3390
on that {} data structure,|
|

857
00:27:53,340 --> 00:27:54,540
0,330 330,690 690,780 780,1080 1080,1200
basically acquire or release the
来获取或释放锁。

858
00:27:54,540 --> 00:27:55,320
0,300
lock.|
|

859
00:27:55,320 --> 00:27:56,370
0,300 480,690 690,810 810,900 900,1050
So one way to think
所以考虑它的一种方式是，

860
00:27:56,370 --> 00:27:58,020
0,240 240,300 300,900 1020,1410 1410,1650
about it maybe,| in xv6
|在 xv6 术语中，每一种数据结构都有一个锁。

861
00:27:58,020 --> 00:28:00,000
0,390 390,570 570,840 840,1350
terms like every structure

862
00:28:00,430 --> 00:28:02,900
0,750 750,1380 1380,1920
{you,know}, has {a,lock}.|
|

863
00:28:04,440 --> 00:28:06,840
0,1620 1680,1890 1890,2100 2100,2340 2340,2400
And in that lock is
在该锁中是原子获取的，

864
00:28:06,840 --> 00:28:08,310
0,510 510,960 960,1170 1170,1320 1320,1470
atomically acquired,| when we do
|当我们做任何与该结构相关的事情时，

865
00:28:08,310 --> 00:28:09,660
0,330 330,660 660,750 750,900 900,1350
anything related to that struct,|
|

866
00:28:09,750 --> 00:28:10,800
0,360 360,570 570,780 780,990 990,1050
it just turns out to
结果发现它太死板了，

867
00:28:10,800 --> 00:28:11,780
0,360
be

868
00:28:11,780 --> 00:28:12,830
0,120 120,630 720,870 870,990 990,1050
too rigid,| and this is
|这就是为什么锁不是真正原子的。

869
00:28:12,830 --> 00:28:14,330
0,480 510,630 630,870 900,1290 1290,1500
why you know locking can

870
00:28:14,330 --> 00:28:16,250
0,270 270,510 510,900 960,1260 1260,1920
not really be {} atomic.|
|

871
00:28:16,800 --> 00:28:19,260
0,900 1230,1380 1380,1500 1500,1890 1890,2460
So in the operating systems,|
所以在运行操作系统中，|

872
00:28:19,260 --> 00:28:20,400
0,120 120,570 570,750 750,810 810,1140
for example from an operating
比如操作系统如下所示，

873
00:28:20,400 --> 00:28:21,840
0,300 300,390 390,480 480,930 1230,1440
system is the following,| let's
|假设我们有一个叫 rename 的调用。

874
00:28:21,840 --> 00:28:23,280
0,210 210,420 420,960 990,1110 1110,1440
say we have a call

875
00:28:23,280 --> 00:28:24,620
0,210 210,840
like rename.|
|

876
00:28:25,530 --> 00:28:27,510
0,210 210,570 570,660 660,1500 1830,1980
That moves the filename from
它将文件名从一个目录移动到另一个目录，

877
00:28:27,510 --> 00:28:29,370
0,180 180,840 870,1020 1020,1290 1290,1860
one directory to another directory,|
|

878
00:28:29,490 --> 00:28:30,570
0,240 240,450 450,660 660,810 810,1080
so let's say we have
假设我们有 d1/x ，

879
00:28:30,570 --> 00:28:32,160
0,210 210,510 510,1050
{d1/x - -},|
|

880
00:28:32,160 --> 00:28:34,290
0,420 420,600 600,1170 1170,1440 1440,2130
and we rename it to
我们把它重命名为 d2/y 。

881
00:28:34,320 --> 00:28:37,300
0,930 960,1530 1920,2400
{d2/y - -}.|
|

882
00:28:37,840 --> 00:28:38,560
0,180 180,420 420,540 540,660 660,720
And so we have the
所以，我们在目录中有文件名 d1/x ，

883
00:28:38,560 --> 00:28:39,850
0,270 270,480 480,540 540,630 630,1290
file name in the directory,

884
00:28:39,850 --> 00:28:41,260
0,390 390,630 630,720 720,1050 1050,1410
{} {d1/x - - -},|
|

885
00:28:41,260 --> 00:28:43,150
0,360 360,810 810,1260 1260,1380 1380,1890
and we rename it to
我们把它重命名为 d2/y 。

886
00:28:43,360 --> 00:28:45,400
0,540 540,780 780,1110 1110,1530
{d2/y - - -}.|
|

887
00:28:45,460 --> 00:28:48,010
0,180 180,240 240,750 750,1530 1770,2550
So the way {} presumably,
所以，如果我们遵循严格的规则，

888
00:28:48,610 --> 00:28:49,660
0,210 210,300 300,630 630,720 720,1050
if we followed the rigid

889
00:28:49,660 --> 00:28:51,130
0,480 480,660 660,960 990,1380 1380,1470
rule,| like this rule of
|比如这个原子锁定规则，会发生什么。

890
00:28:51,130 --> 00:28:52,510
0,420 420,840 840,960 960,1260 1260,1380
atomic locking {you,know} what would

891
00:28:52,510 --> 00:28:53,740
0,390 390,750
happen is.|
|

892
00:28:53,740 --> 00:28:55,240
0,630 750,870 870,990 990,1290 1290,1500
{} You know that that
这条规则，当我们有两个对象，

893
00:28:55,240 --> 00:28:56,050
0,300 300,420 420,510 510,630 630,810
rule when we have two

894
00:28:56,050 --> 00:28:57,340
0,510 510,690 690,870 870,1170 1170,1290
objects,| with {d1 -} and
|d1 和 d2 。

895
00:28:57,340 --> 00:28:58,520
0,150 150,600
{d2 -}.|
|

896
00:28:58,820 --> 00:28:59,720
0,120 120,330 330,480 480,780 780,900
And so we follow the
所以我们遵循规则，原子规则，

897
00:28:59,720 --> 00:29:01,760
0,270 270,570 570,1230 1230,1740 1740,2040
rule, then basically atomic rule,|
|

898
00:29:01,760 --> 00:29:03,380
0,540 540,720 720,990 990,1170 1170,1620
then we lock {d1 -},
我们对 d1 加锁，删除 x ，然后释放 d1 的锁。

899
00:29:05,780 --> 00:29:07,540
0,120 120,300 300,690 690,1200
you know erase x,

900
00:29:08,990 --> 00:29:11,680
0,1320 1350,2220
and release

901
00:29:13,000 --> 00:29:15,660
0,390 390,1050 1110,1680 1680,2070
{the,lock} for {d1 -}.|
|

902
00:29:17,740 --> 00:29:18,970
0,180 180,900 900,990 990,1110 1110,1230
And then we do the
然后，我们做数据的第二部分，

903
00:29:18,970 --> 00:29:20,560
0,270 270,810 840,1020 1020,1500 1500,1590
second part of data,| you
|对 d2 加锁，添加 y ，然后释放 d2 。

904
00:29:20,560 --> 00:29:23,080
0,90 90,660 660,1170 1170,1920
know d2, lock d2,

905
00:29:23,400 --> 00:29:24,720
0,690
add

906
00:29:25,150 --> 00:29:27,140
0,270 270,1350
{} y,

907
00:29:27,140 --> 00:29:29,080
0,480 480,1320
and release

908
00:29:29,950 --> 00:29:31,140
0,690
d2.|
|

909
00:29:32,000 --> 00:29:33,460
0,720

910
00:29:33,460 --> 00:29:34,150
0,150 150,240 240,300 300,510 540,690
And then we're done.| So
然后我们就完成了。|这是一种假设的方案，

911
00:29:34,150 --> 00:29:35,110
0,150 150,300 300,480 480,750 750,960
this would be the sort

912
00:29:35,110 --> 00:29:39,790
0,120 120,1200 1200,2670 2670,3480 4170,4680
of hypothetical schema| and you
|你可以想象如果我们进行原子锁会发生什么，

913
00:29:39,790 --> 00:29:41,590
0,690 690,1140 1140,1320 1320,1650 1650,1800
imagine what would happen if

914
00:29:41,590 --> 00:29:43,360
0,90 90,390 390,780 780,1260
we did atomic locking,|
|

915
00:29:43,360 --> 00:29:45,310
0,630 870,1350 1350,1650 1650,1740 1740,1950
{ -} and the point
这个例子的重点是会产生错误的结果，

916
00:29:45,310 --> 00:29:46,330
0,60 60,240 240,630 630,870 870,1020
of this example is going

917
00:29:46,330 --> 00:29:47,500
0,420 420,600 600,810 810,900 900,1170
to, will have the wrong

918
00:29:47,500 --> 00:29:50,200
0,420 780,1170 1170,2100 2100,2610 2610,2700
outcome| and why, why is
|为什么这是一个有问题的方案，

919
00:29:50,200 --> 00:29:52,360
0,150 150,540 540,1200 1200,1620 1890,2160
this a problematic scheme,| why
为什么这行不通。

920
00:29:52,360 --> 00:29:53,350
0,120 120,270 270,450 450,600 600,990
is this not gonna work.|
|

921
00:30:03,170 --> 00:30:04,760
0,180 180,360 360,660 660,1320 1320,1590
So, think about like the
所以，要考虑的是这个时间。

922
00:30:04,760 --> 00:30:05,390
0,120 120,210 210,330 330,570 570,630
thing to think about is

923
00:30:05,390 --> 00:30:07,180
0,600 630,1230
this period.|
|

924
00:30:08,000 --> 00:30:09,080
0,300 300,510 510,750 750,840 840,1080
So we've done the first
所以我们已经完成了第一步，

925
00:30:09,080 --> 00:30:10,180
0,630
step,

926
00:30:10,610 --> 00:30:11,880
0,210 210,750
step one,|
|

927
00:30:12,050 --> 00:30:13,460
0,390 390,630 630,870 870,1260 1260,1410
not done step, step two
还没有完成第二步。

928
00:30:13,460 --> 00:30:14,440
0,420
yet.|
|

929
00:30:14,630 --> 00:30:16,640
0,630 630,780 780,1110 1110,1470 1470,2010
What could another process observe.|
另一个进程会观察到什么。|

930
00:30:24,160 --> 00:30:25,340
0,660
Anybody?|
有人知道吗？|

931
00:30:28,950 --> 00:30:30,480
0,540 540,690 690,930 930,1140 1140,1530
{The,file} it just be gone.|
文件丢失了。|

932
00:30:30,870 --> 00:30:32,430
0,510 510,630 630,750 750,990 990,1560
Yeah, you know this there's
是的，在第一步和第二步之间，

933
00:30:32,430 --> 00:30:33,810
0,600 600,840 840,1020 1020,1140 1140,1380
between step one and two,|
|

934
00:30:33,810 --> 00:30:35,520
0,90 90,330 330,570 570,1140
the file doesn't exist.|
这个文件不存在。|

935
00:30:41,520 --> 00:30:42,510
0,90 90,300 300,450 450,540 540,990
I mean that is clearly
我的意思是这显然是错误的，

936
00:30:42,510 --> 00:30:44,370
0,540 570,1170 1170,1290 1290,1620 1620,1860
wrong,| because the file does
|因为该文件确实存在，它只是被重命名，

937
00:30:44,370 --> 00:30:46,470
0,570 900,1080 1080,1290 1290,1500 1500,2100
exist, it just being renamed,|
|

938
00:30:46,710 --> 00:30:48,240
0,390 390,690 690,1020 1020,1350 1350,1530
{} and never point {}
应该没有什么时候它不存在，

939
00:30:48,240 --> 00:30:49,410
0,210 210,330 330,420 420,660 660,1170
really that it didn't exist,|
|

940
00:30:50,430 --> 00:30:52,110
0,300 300,510 510,1200 1200,1530 1530,1680
but by implementing it in
但是通过以这种方式实现它，

941
00:30:52,110 --> 00:30:53,580
0,210 210,780 930,1200 1200,1320 1320,1470
this way,| {} it just
|看起来该文件可能并不存在，

942
00:30:53,580 --> 00:30:55,290
0,750 750,1050 1050,1170 1170,1500 1500,1710
appears that the file might

943
00:30:55,290 --> 00:30:56,550
0,210 210,450 450,870 870,1080 1080,1260
actually not exist,| even though
|尽管它确实存在。

944
00:30:56,550 --> 00:30:57,400
0,60 60,450
it does.|
|

945
00:30:57,800 --> 00:30:59,330
0,330 330,450 450,780 780,1230 1350,1530
So the really right {}
所以正确的解决方案是，

946
00:30:59,330 --> 00:31:00,440
0,390 390,480 480,750 750,900 900,1110
solution to this is| what
|我们需要的是，

947
00:31:00,440 --> 00:31:01,560
0,90 90,540
we need

948
00:31:03,460 --> 00:31:04,750
0,330 330,450 450,600 600,810 810,1290
is| that we actually lock
|在重命名开始前，先锁定 d1 和 d2 ，

949
00:31:04,750 --> 00:31:06,160
0,120 120,870
{d1 -}

950
00:31:07,460 --> 00:31:09,230
0,390 390,870 870,1470 1560,1710 1710,1770
and d2 first, at the

951
00:31:09,230 --> 00:31:10,760
0,300 300,420 420,1020
beginning of rename,|
|

952
00:31:10,760 --> 00:31:11,920
0,510
then
然后擦除并添加，

953
00:31:11,920 --> 00:31:13,720
0,120 120,600 600,690 690,1200
{erase -} and add,|
|

954
00:31:15,780 --> 00:31:17,920
0,180 180,690 720,1530
and then release
然后释放 d1 和 d2 的锁。

955
00:31:18,880 --> 00:31:19,870
0,390 390,480 480,810 810,900 900,990
{} the locks for {d1

956
00:31:19,870 --> 00:31:20,980
0,480
-}

957
00:31:20,980 --> 00:31:22,280
0,330 330,600
{and,d2 -}.|
|

958
00:31:24,500 --> 00:31:25,840
0,150 150,240 240,420 420,750
So, that makes sense?|
所以，这能理解吗？|

959
00:31:26,870 --> 00:31:28,610
0,150 150,540 540,600 600,1080 1080,1740
So here's an example| where
所以，这是一个例子，|我们有一个需要多个锁的操作，

960
00:31:28,760 --> 00:31:30,290
0,420 420,570 570,690 690,750 750,1530
{} we have an operation

961
00:31:30,410 --> 00:31:32,810
0,840 870,1380 1380,1590 1590,1920 1920,2400
that acquire needs multiple locks|
|

962
00:31:32,960 --> 00:31:34,970
0,840 870,1500 1500,1620 1620,1710 1710,2010
and {} and the locks
并且锁不能真正地与这两个对象相关联，

963
00:31:34,970 --> 00:31:36,560
0,480 480,720 720,840 840,1440 1440,1590
cannot really be associated with

964
00:31:36,560 --> 00:31:37,850
0,270 270,510 510,990 990,1110 1110,1290
the two objects,| that are
|它们是这个操作的参数，

965
00:31:37,850 --> 00:31:39,170
0,90 90,480 480,570 570,690 690,1320
the arguments of this operation,|
|

966
00:31:39,590 --> 00:31:40,580
0,360 360,540 540,780 780,840 840,990
{} it has to be
实际上操作本身必须首先获取两个锁，

967
00:31:40,580 --> 00:31:41,570
0,60 60,390 390,570 570,900 900,990
the case that actually the

968
00:31:41,570 --> 00:31:43,730
0,390 390,750 750,1140 1170,1740 1740,2160
operation itself first requires both

969
00:31:44,270 --> 00:31:46,580
0,570 570,1080 1200,1530 1530,1650 1650,2310
locks,| then perform the operations.|
|然后执行操作。|

970
00:31:47,400 --> 00:31:48,660
0,180 180,360 360,780 780,1140 1140,1260
So there's atomic locking is
所以原子锁不是直接可能的。

971
00:31:48,660 --> 00:31:51,100
0,360 750,1350 1350,1830
not directly possible.|
|

972
00:31:51,250 --> 00:31:52,120
0,180 180,300 300,360 360,450 450,870
There's going to be cases,|
会有这种情况，|

973
00:31:52,120 --> 00:31:54,550
0,360 360,720 720,1080 1260,2160 2280,2430
where there's not run to
不是运行简单的方案，

974
00:31:54,550 --> 00:31:56,380
0,420 690,1110 1110,1440 1440,1560 1560,1830
the native scheme| at those
|它们会遇到问题。

975
00:31:56,380 --> 00:31:57,700
0,150 150,360 360,570 570,870 870,1320
will run into a problem

976
00:31:57,730 --> 00:31:58,800
0,630
problems.|
|

977
00:32:00,400 --> 00:32:01,980
0,180 180,480 480,630 630,900
Any questions about this?|
对这个有什么问题吗？|

978
00:32:07,010 --> 00:32:08,570
0,420 570,870 870,1020 1020,1320 1320,1560
So could we just say
所以我们能不能这么说，

979
00:32:08,570 --> 00:32:10,400
0,330 360,810 840,1110 1110,1350 1350,1830
that,| {} when we're accessing
|当我们访问数据结构时，

980
00:32:10,400 --> 00:32:11,390
0,60 60,300 300,720 720,840 840,990
a data structure,| we just
|我们需要访问或者我们必须获取

981
00:32:11,390 --> 00:32:12,830
0,180 180,480 510,1110 1110,1320 1320,1440
have to access or we

982
00:32:12,830 --> 00:32:13,850
0,90 90,180 180,660 660,900 900,1020
have to acquire| all of
|所有我们需要的数据结构相关联的锁，

983
00:32:13,850 --> 00:32:15,800
0,120 120,600 600,1260 1260,1590 1710,1950
the locks associated with all

984
00:32:15,800 --> 00:32:16,850
0,120 120,210 210,420 420,900 900,1050
of the data structures we

985
00:32:16,850 --> 00:32:18,820
0,390 720,930 930,990 990,1500
need| at the beginning.|
|在开始的时候。|

986
00:32:19,120 --> 00:32:20,350
0,240 240,330 330,720 750,1080 1080,1230
That be one,| yeah, so
这是其中之一，|是的，这是一种方法，

987
00:32:20,350 --> 00:32:21,520
0,240 240,510 510,660 660,930 930,1170
that's one way doing it|
|

988
00:32:21,520 --> 00:32:22,090
0,120 120,180 180,330 330,480 480,570
and I think that we
我想很快会归结到拥有一个大内核锁。

989
00:32:22,090 --> 00:32:25,030
0,210 240,780 780,2190 2520,2670 2670,2940
should quickly will come down

990
00:32:25,030 --> 00:32:25,870
0,90 90,390 390,630 630,690 690,840
to basically having a big

991
00:32:25,870 --> 00:32:27,040
0,300 300,660
kernel lock.|
|

992
00:32:27,380 --> 00:32:29,660
0,1410 1410,1920 1920,2010 2010,2070 2070,2280
Okay.| You're on the risk,
好的。|你在不会有并发的风险上，

993
00:32:29,660 --> 00:32:31,190
0,360 360,450 450,570 570,1050 1050,1530
basically have no parallelism anymore,|
|

994
00:32:31,850 --> 00:32:32,420
0,180 180,300 300,420 420,480 480,570
so you want to do
所以你想做得更好，

995
00:32:32,420 --> 00:32:34,370
0,240 240,360 360,750 780,1140 1770,1950
better than that right,| and
|我认为这一直是矛盾，

996
00:32:34,370 --> 00:32:35,180
0,60 60,210 210,360 360,450 450,810
I think this is always

997
00:32:35,180 --> 00:32:36,170
0,90 90,510 570,750 750,840 840,990
the tension,| you know you
|你可以使事情变得简单，

998
00:32:36,170 --> 00:32:37,730
0,90 90,210 210,390 390,930 960,1560
can make things simpler| by
|通过使用粗粒度锁，

999
00:32:37,730 --> 00:32:40,670
0,630 630,900 900,1320 1350,2400 2400,2940
basically what's called coarse-grained locking,|
|

1000
00:32:41,060 --> 00:32:42,200
0,390 390,570 570,930 930,1020 1020,1140
{} but then you know
但是你会丢失性能，

1001
00:32:42,200 --> 00:32:43,240
0,120 120,630
you're lose

1002
00:32:43,820 --> 00:32:45,350
0,270 270,810 1170,1350 1350,1410 1410,1530
lose performance| or you may
|或者可能丢失性能，

1003
00:32:45,350 --> 00:32:46,740
0,270 270,840
lose performance,|
|

1004
00:32:46,740 --> 00:32:47,910
0,300 300,390 390,480 480,810 810,1170
depending if the locks intended
取决于锁是不是有意的。

1005
00:32:47,910 --> 00:32:48,840
0,60 60,360
or not.|
|

1006
00:32:49,730 --> 00:32:51,360
0,840 840,1020
{Yeah,thank} you.|
好的，谢谢。|

1007
00:32:52,700 --> 00:32:54,410
0,330 330,720 750,1080 1080,1590 1590,1710
{} So lock perspective, so
从锁的角度来看，这是考虑锁的不同方法。

1008
00:32:54,410 --> 00:32:57,770
0,240 240,660 660,1380 1830,2550 2850,3360
there's different ways to think

1009
00:32:57,770 --> 00:32:59,000
0,180 180,660
about locks.|
|

1010
00:32:59,650 --> 00:33:00,880
0,690

1011
00:33:00,910 --> 00:33:01,810
0,210 210,330 330,570 570,690 690,900
You know, those are three
这有三个常见的问题，

1012
00:33:01,810 --> 00:33:04,300
0,300 300,780 840,1560 1620,2370 2370,2490
common ones,| and {} you
|而且，它们三个都要，

1013
00:33:04,300 --> 00:33:05,380
0,420 450,660 660,810 810,900 900,1080
know go for all three

1014
00:33:05,380 --> 00:33:06,250
0,60 60,240 240,360 360,570 570,870
of them| and just maybe
|也许这会帮助你思考锁的问题，

1015
00:33:06,250 --> 00:33:07,510
0,180 180,300 300,570 570,1020 1050,1260
that may help you {}

1016
00:33:07,510 --> 00:33:08,440
0,90 90,240 240,450 450,780 780,930
to think about locks| and
|也许其中一个是你的最爱，

1017
00:33:08,440 --> 00:33:09,190
0,240 240,420 420,480 480,630 630,750
maybe one of them is

1018
00:33:09,190 --> 00:33:10,450
0,300 300,750 750,1050 1050,1140 1140,1260
your favorite| and you can
|你可以使用它作为你思考问题的方式，

1019
00:33:10,450 --> 00:33:12,220
0,120 120,300 300,630 1050,1560 1560,1770
use that one {} as

1020
00:33:12,220 --> 00:33:13,240
0,240 240,420 420,510 510,780 780,1020
your way of thinking about

1021
00:33:13,240 --> 00:33:14,230
0,60 60,240 240,390 390,690 690,990
it,| but there's probably helpful
|但是，这些可能是有用的，

1022
00:33:14,230 --> 00:33:15,160
0,120 120,450 450,600 600,720 720,930
to see| that they're actually
|它们以不同的方式来思考锁。

1023
00:33:15,160 --> 00:33:16,270
0,300 300,510 510,600 600,870 870,1110
different ways of thinking about

1024
00:33:16,270 --> 00:33:17,060
0,390
locks.|
|

1025
00:33:17,530 --> 00:33:19,990
0,780 1560,1800 1800,2070 2070,2130 2130,2460
{} So first of all,|
首先，|

1026
00:33:20,080 --> 00:33:20,950
0,150 150,510 510,660 660,750 750,870
{you,know} one way to think
可以考虑的一种方式是锁避免丢失更新，

1027
00:33:20,950 --> 00:33:22,780
0,330 330,540 540,1080 1080,1230 1230,1830
about is actually {} lock

1028
00:33:23,900 --> 00:33:25,300
0,840
avoid

1029
00:33:26,310 --> 00:33:29,700
0,1500 1500,2040 2160,2370 2370,2850
lost updates| or help.|
|或者帮助（避免丢失）。|

1030
00:33:29,840 --> 00:33:31,370
0,300 300,420 420,660 660,960 960,1530
If you use lock correctly,|
如果你正确使用锁，|

1031
00:33:31,370 --> 00:33:32,360
0,90 90,210 210,480 480,690 690,990
you know locks can help
锁可以帮助避免丢失更新。

1032
00:33:32,360 --> 00:33:35,020
0,660 900,1290 1290,1620 1620,2070
avoiding {} lost updates.|
|

1033
00:33:38,680 --> 00:33:39,730
0,150 150,240 240,330 330,540 540,1050
And if you think about
如果你考虑一下之前的 kalloc.c 中的示例，

1034
00:33:39,790 --> 00:33:42,160
0,1080 1080,1530 1530,2040 2040,2220 2220,2370
{} early example in the

1035
00:33:42,160 --> 00:33:43,540
0,510 510,900 900,1020 1020,1140 1140,1380
{kalloc.c -},| you know the
|丢失的更新就是丢失了 kfree 的一个更新。

1036
00:33:43,540 --> 00:33:45,070
0,300 300,660 660,720 720,1230 1230,1530
lost update is basically {}

1037
00:33:45,280 --> 00:33:47,200
0,480 480,720 720,1110 1110,1440 1440,1920
lose one update to the

1038
00:33:47,890 --> 00:33:49,000
0,240 240,570
{kfree -}.|
|

1039
00:33:49,150 --> 00:33:50,770
0,540 540,750 750,1020 1020,1410 1410,1620
And by putting locks, it
通过使用锁，它没有丢失更新，

1040
00:33:50,770 --> 00:33:52,090
0,60 60,360 360,690 690,990 1050,1320
you know actually {} didn't

1041
00:33:52,090 --> 00:33:53,770
0,480 540,780 780,990 990,1440 1500,1680
lose {} that update,| so
|所以这是思考这个问题的一种方式，

1042
00:33:53,770 --> 00:33:54,790
0,150 150,390 390,630 630,720 720,1020
that's one way of thinking

1043
00:33:54,790 --> 00:33:55,780
0,240 240,420
about it,|
|

1044
00:33:56,070 --> 00:33:58,260
0,150 150,390 390,930 930,1290 1620,2190
a very low-level way {}.|
一种非常低级的方式。|

1045
00:33:58,260 --> 00:33:59,160
0,270 270,360 360,450 450,570 570,900
Another way to think about
另一种思考方式是，你可以使用锁，

1046
00:33:59,160 --> 00:34:00,090
0,390 390,510 510,630 630,840 840,930
is you know you can

1047
00:34:00,090 --> 00:34:02,580
0,450 480,840 840,1410 1440,1950
make lock,| {} locks
|锁使多步操作成为原子操作。

1048
00:34:03,970 --> 00:34:05,240
0,720
make

1049
00:34:05,720 --> 00:34:07,740
0,300 300,600 600,1440
{multi-step -} operations

1050
00:34:10,510 --> 00:34:11,780
0,690
atomic.|
|

1051
00:34:13,700 --> 00:34:14,390
0,180 180,300 300,450 450,600 600,690
And so there's sort of
所以，有一种临界区间的观点，

1052
00:34:14,390 --> 00:34:15,170
0,60 60,300 300,420 420,480 480,780
the view of {} critical

1053
00:34:15,170 --> 00:34:16,730
0,510 510,840 840,1020 1020,1170 1170,1560
section,| we have {} acquire
|我们使用锁在一系列步骤或指令上，

1054
00:34:16,730 --> 00:34:17,810
0,300 300,510 510,540 540,720 720,1080
lock with a whole bunch

1055
00:34:17,840 --> 00:34:21,050
0,60 60,1560 1710,2250 2250,2640 2640,3210
of a steps or instructions,|
|

1056
00:34:21,050 --> 00:34:22,760
0,450 450,630 630,1320 1410,1620 1620,1710
executed all instructions, then {}
执行所有指令，然后释放，

1057
00:34:22,760 --> 00:34:24,440
0,450 690,990 990,1110 1110,1380 1380,1680
release,| {basically -} whole critical
|整个临界区间作为原子操作执行。

1058
00:34:24,440 --> 00:34:26,660
0,540 720,1500 1500,1710 1710,1800 1800,2220
section execute as an atomic

1059
00:34:26,660 --> 00:34:27,780
0,660
operation.|
|

1060
00:34:27,870 --> 00:34:29,370
0,240 240,390 390,510 510,1200 1200,1500
That sort of { -
这也是思考锁的一个很好的方式。

1061
00:34:29,460 --> 00:34:31,020
0,480 480,840 840,960 960,1230 1230,1560
-} also a fine way

1062
00:34:31,020 --> 00:34:32,940
0,510 510,720 720,930 930,1440
to think about locks.|
|

1063
00:34:33,090 --> 00:34:33,990
0,150 150,240 240,300 300,540 540,900
And then the third one,|
然后是第三个，|

1064
00:34:34,410 --> 00:34:35,430
0,480 480,630 630,750 750,900 900,1020
{} you know that may
这可能会有帮助，

1065
00:34:35,430 --> 00:34:37,410
0,120 120,510 510,690 690,960 1260,1980
be helpful,| is that {}
|锁真正的作用是锁帮助维护一个不变量，

1066
00:34:37,440 --> 00:34:39,420
0,420 420,540 540,810 810,1260 1290,1980
really what locks do is

1067
00:34:39,660 --> 00:34:41,380
0,600 600,1200
lock help

1068
00:34:41,640 --> 00:34:44,040
0,480 510,960 960,1050 1050,1770
{} maintain an invariant,|
|

1069
00:34:47,140 --> 00:34:48,550
0,600 600,690 690,930 930,1170 1170,1410
{invariant -} {} share data
不变量共享它在保护的数据结构。

1070
00:34:48,550 --> 00:34:49,690
0,510 510,750 750,900 900,1020 1020,1140
structure that you know it's

1071
00:34:49,690 --> 00:34:50,900
0,510
protecting.|
|

1072
00:34:51,260 --> 00:34:53,300
0,630 900,1290 1290,1530 1530,1830 1830,2040
And {} what was going
这里发生的是，

1073
00:34:53,300 --> 00:34:56,240
0,270 270,450 450,900 1200,1860 2550,2940
on is that,| {} before
|在 acquire 之前，

1074
00:34:56,240 --> 00:34:57,680
0,660 690,840 840,1020 1020,1200 1200,1440
acquire,| if there's no lock
|如果没有锁持有者，持有不变量，

1075
00:34:57,680 --> 00:34:59,210
0,450 480,570 570,690 690,1080 1080,1530
holder, you know that invariant

1076
00:34:59,210 --> 00:35:01,100
0,570 930,1170 1170,1380 1380,1500 1500,1890
holds,| {} when we acquire
|当我们获得锁，并进行一些操作时，

1077
00:35:01,100 --> 00:35:02,300
0,90 90,600 840,1020 1020,1110 1110,1200
the lock and we do

1078
00:35:02,300 --> 00:35:04,310
0,120 120,690 690,870 870,1800 1830,2010
some operations,| then temporarily the
|那么可能暂时违反不变量，

1079
00:35:04,310 --> 00:35:07,850
0,510 510,690 690,1260 1470,3000 3360,3540
invariant may be violated,| but
|但是在我们使用 release 的时候，

1080
00:35:07,850 --> 00:35:08,570
0,90 90,180 180,510 510,630 630,720
at the point that we

1081
00:35:08,570 --> 00:35:09,760
0,120 120,240 240,810
do the release,|
|

1082
00:35:13,180 --> 00:35:13,900
0,270 270,420 420,480 480,570 570,720
{} so if you think
如果你考虑一下 r freelist 的例子，

1083
00:35:13,900 --> 00:35:16,510
0,480 810,1110 1110,1410 1410,2010 2040,2610
about {} r freelist {}

1084
00:35:16,510 --> 00:35:18,040
0,570 810,930 930,1020 1020,1140 1140,1530
case,| you know the invariant
|不变量是空闲指针指向下一个指针，

1085
00:35:18,040 --> 00:35:20,380
0,240 240,510 510,1350 1770,1980 1980,2340
is {} {you,know} free pointer

1086
00:35:20,380 --> 00:35:22,420
0,300 300,660 660,1230 1230,1650 1650,2040
points to {} one other

1087
00:35:22,420 --> 00:35:24,100
0,270 270,870 930,1320 1320,1590 1590,1680
next pointer| and all the
|并且所有的空闲页面都在一个列表上。

1088
00:35:24,100 --> 00:35:25,720
0,360 360,810 810,1410 1410,1560 1560,1620
free pages are on a

1089
00:35:25,720 --> 00:35:26,820
0,330 330,780
single list.|
|

1090
00:35:27,390 --> 00:35:29,910
0,420 420,870 870,1140 1140,1710 1710,2520
{} And that's temporarily violated
在这一点上，这是暂时违反的，

1091
00:35:29,970 --> 00:35:32,160
0,480 480,690 690,780 780,1320 1440,2190
{} at the point {},|
|

1092
00:35:33,950 --> 00:35:35,690
0,300 300,360 360,690 690,810 810,1740
in the middle of the
在 kfree 中间，

1093
00:35:35,720 --> 00:35:37,370
0,240 240,480 480,810 810,990 990,1650
{kfree -},| because like multiple
|因为多个指针指向 freelist 的开头。

1094
00:35:37,400 --> 00:35:38,360
0,330 330,570 570,810 810,870 870,960
pointers actually point to the

1095
00:35:38,360 --> 00:35:39,840
0,270 270,360 360,570 570,1020
beginning of {freelist -}.|
|

1096
00:35:40,760 --> 00:35:42,350
0,540 660,990 990,1080 1080,1530 1530,1590
And then we [established] at
然后我们在末尾建立。

1097
00:35:42,350 --> 00:35:43,380
0,120 120,210 210,330 330,510
the end of it.|
|

1098
00:35:43,750 --> 00:35:46,030
0,540 600,840 840,1350 1710,1920 1920,2280
So if where {freelist -}
所以如果 freelist 不是那么复杂的变量，

1099
00:35:46,030 --> 00:35:47,860
0,210 210,510 510,810 810,1350 1350,1830
as not so complicated variables,|
|

1100
00:35:47,860 --> 00:35:49,630
0,240 240,720 720,1380 1380,1590 1590,1770
like more complicated shared data
比如更复杂的共享数据结构，

1101
00:35:49,630 --> 00:35:51,250
0,450 960,1110 1110,1230 1230,1290 1290,1620
structures,| can be a helpful
|可以是一种很有帮助的方式，来思考锁到底做了什么。

1102
00:35:51,250 --> 00:35:52,810
0,270 270,360 360,750 750,1110 1110,1560
way of thinking actually what

1103
00:35:52,810 --> 00:35:53,920
0,120 120,420 420,540 540,810 810,1110
the lock is doing for

1104
00:35:53,920 --> 00:35:54,560
0,120
you.|
|

1105
00:35:55,330 --> 00:35:56,890
0,540 630,810 810,1170 1170,1470 1470,1560
And so see, even in
所以，即使在这三个示例中，

1106
00:35:56,890 --> 00:35:58,480
0,300 720,990 990,1140 1140,1500 1500,1590
this case three case,| you
|所有三种锁视角都是合理的，

1107
00:35:58,480 --> 00:35:59,920
0,180 180,420 420,630 630,1020 1020,1440
know all three lock perspective

1108
00:35:59,920 --> 00:36:02,800
0,150 150,570 570,1290 1530,2280 2280,2880
for reasonable perspectives,| {} and
|它们中的一个，带来了更多思考，

1109
00:36:02,830 --> 00:36:04,300
0,510 510,900 900,1140 1140,1380 1380,1470
{} you know one of

1110
00:36:04,300 --> 00:36:05,440
0,330 360,480 480,630
them you know

1111
00:36:05,560 --> 00:36:07,480
0,600 630,1110 1110,1380 1380,1770 1770,1920
{} brings more [review],| then
|然后，另一个用来考虑锁。

1112
00:36:07,480 --> 00:36:08,740
0,600 780,990 990,1050 1050,1140 1140,1260
so, one of the other

1113
00:36:08,740 --> 00:36:10,060
0,330 330,720 720,870 870,1110 1110,1320
ones and you use that

1114
00:36:10,060 --> 00:36:11,410
0,150 150,540 570,1080 1080,1170 1170,1350
as your way to think

1115
00:36:11,410 --> 00:36:12,540
0,210 210,630
about locks.|
|

1116
00:36:14,510 --> 00:36:17,060
0,600 600,1350 1500,2010 2010,2160 2160,2550
Any questions about this point?|
对于这一点，有什么问题吗？|

1117
00:36:23,560 --> 00:36:25,620
0,540 930,1500
Okay {}.|
好的。|

1118
00:36:25,620 --> 00:36:26,700
0,150 150,420 420,750 750,930 930,1080
So in our own for
所以，在我们自己的几件事上，

1119
00:36:26,700 --> 00:36:29,010
0,60 60,300 300,810 870,1320 1320,2310
a couple things { -},

1120
00:36:29,040 --> 00:36:31,000
0,390 480,540 540,1380
sort of {},|
|

1121
00:36:31,460 --> 00:36:33,410
0,330 330,810 810,1410 1410,1740 1740,1950
in [desirable] properties or that
在[所需]属性中，或者使用锁可能发生的事，

1122
00:36:33,410 --> 00:36:34,760
0,120 120,360 360,660 660,840 840,1350
can actually happen with locks|
|

1123
00:36:34,850 --> 00:36:36,470
0,480 510,660 660,1140 1140,1350 1350,1620
and you know like locks
你知道，锁用来修复正确性问题，避免竞态条件，

1124
00:36:36,470 --> 00:36:38,450
0,180 180,900 930,1530 1530,1710 1710,1980
are a necessary to fix

1125
00:36:38,450 --> 00:36:40,640
0,90 90,450 450,930 1650,2010 2010,2190
{} correctness problem avoids race

1126
00:36:40,640 --> 00:36:42,860
0,570 810,1020 1020,1290 1290,2010 2010,2220
conditions,| but locks themselves in
|但是当不适当的使用锁，

1127
00:36:42,860 --> 00:36:45,470
0,330 330,1110 1110,1800 1800,2370 2460,2610
when inappropriate inappropriate used,| can
|也会引入它们自己的一套问题。

1128
00:36:45,470 --> 00:36:46,910
0,240 240,750 750,960 960,1260 1260,1440
also introduce their own set

1129
00:36:46,910 --> 00:36:47,980
0,60 60,720
of problems.|
|

1130
00:36:48,280 --> 00:36:49,000
0,300 300,480 480,510 510,660 660,720
And so I want to
所以我想谈一谈这一点，

1131
00:36:49,000 --> 00:36:49,630
0,120 120,150 150,330 330,450 450,630
talk a little bit about

1132
00:36:49,630 --> 00:36:51,190
0,330 750,930 930,1050 1050,1200 1200,1560
that| and so the obvious
|最明显的一个当然是死锁。

1133
00:36:51,190 --> 00:36:52,570
0,270 270,420 420,660 660,780 780,1380
one, of course is deadlock.|
|

1134
00:36:57,240 --> 00:36:58,530
0,360 360,450 450,1050 1050,1140 1140,1290
{You,know} for example, you know
比如，这个简单的例子，

1135
00:36:58,530 --> 00:37:00,180
0,450 450,780 780,1260 1260,1380 1380,1650
the simple case,| you know
|虽然有点无聊，但值得一想，

1136
00:37:00,180 --> 00:37:01,410
0,180 180,330 330,450 450,810 810,1230
a little bit boring, but

1137
00:37:01,500 --> 00:37:03,240
0,630 630,870 870,1290 1500,1620 1620,1740
worthwhile thinking about,| you know
|你获取锁，

1138
00:37:03,240 --> 00:37:04,860
0,210 210,300 300,1080
do an acquire

1139
00:37:05,390 --> 00:37:07,560
0,180 180,600 900,1650
you know lock,|
|

1140
00:37:07,680 --> 00:37:08,730
0,450 450,570 570,720 720,990 990,1050
and so you start the
你开始了临界区间，

1141
00:37:08,730 --> 00:37:10,080
0,300 300,930 930,1110 1110,1290 1290,1350
critical section| and in the
|在临界区间内，你又一次获取了同一把锁，

1142
00:37:10,080 --> 00:37:11,730
0,330 330,930 930,1170 1170,1290 1290,1650
critical section, you do another

1143
00:37:11,730 --> 00:37:12,820
0,510
acquire

1144
00:37:13,600 --> 00:37:15,180
0,180 180,270 270,540 540,1050
of the same lock,|
|

1145
00:37:16,930 --> 00:37:18,320
0,240 240,360 360,900
what will happen,|
接下来会发生什么，|

1146
00:37:20,300 --> 00:37:22,010
0,210 210,330 330,630 630,1110 1110,1710
can the second acquire succeed?|
第二次获取能成功吗？|

1147
00:37:29,640 --> 00:37:31,110
0,510 540,750 750,1170 1170,1290 1290,1470
Well with respect that we've
好吧，我们早些时候已经说过了，

1148
00:37:31,110 --> 00:37:33,000
0,330 330,630 630,1110 1200,1740 1740,1890
given early on {},| you
|你知道这是不允许的，

1149
00:37:33,000 --> 00:37:34,200
0,300 300,510 510,690 690,960 960,1200
know this should be not

1150
00:37:34,200 --> 00:37:35,850
0,390 510,690 690,1110 1110,1290 1380,1650
allowed,| so basically the second
|所以第二次获取会被阻塞，

1151
00:37:35,850 --> 00:37:38,130
0,480 480,750 750,1260 1290,1950 2130,2280
acquire must block| until the
|直到第一次获取被释放锁，

1152
00:37:38,130 --> 00:37:39,690
0,270 270,780 780,1050 1050,1440 1440,1560
first acquire release lock,| but
|但那是这个进程本身，

1153
00:37:39,690 --> 00:37:40,860
0,180 180,480 750,960 960,1050 1050,1170
that was you know the

1154
00:37:40,860 --> 00:37:42,480
0,330 330,810 810,1050 1050,1440 1440,1620
process itself,| so basically this
|所以这会导致死锁。

1155
00:37:42,480 --> 00:37:44,000
0,480 480,540 540,600 600,1110
result in a deadlock.|
|

1156
00:37:46,970 --> 00:37:47,960
0,150 150,360 360,450 450,540 540,990
{You,know}, this is a trivial
这是一个微不足道的死锁的例子，

1157
00:37:47,960 --> 00:37:49,550
0,390 390,450 450,510 510,1110 1200,1590
example of {} deadlock| and
|或许不是很有趣，

1158
00:37:49,550 --> 00:37:50,570
0,270 270,390 390,570 570,930 930,1020
maybe not that interesting,| in
|如果 xv6 [文本]中有一个死锁，

1159
00:37:50,570 --> 00:37:51,500
0,180 180,330 330,420 420,810 810,930
fact there's a deadlock that

1160
00:37:51,500 --> 00:37:52,820
0,270 270,690 690,1080 1080,1230 1230,1320
{xv6 -} [texts],| you know
|因为当它发现相同的进程再次获取相同的锁时，

1161
00:37:52,820 --> 00:37:54,530
0,300 300,690 1080,1260 1260,1560 1560,1710
because when it sees that

1162
00:37:54,530 --> 00:37:55,670
0,60 60,300 300,660 660,1080 1080,1140
the same process acquire the

1163
00:37:55,670 --> 00:37:58,130
0,240 240,450 450,990 1170,2040 2040,2460
same lock again,| actually causes
|就会引起 panic 。

1164
00:37:58,130 --> 00:37:59,180
0,90 90,570
a panic.|
|

1165
00:37:59,330 --> 00:38:01,190
0,390 420,750 750,1050 1050,1470 1470,1860
A more interesting cases are
一个更有趣的情况是，当涉及多个锁时，

1166
00:38:01,190 --> 00:38:03,200
0,510 510,1050 1050,1350 1350,1440 1440,2010
when multiple locks are involved,|
|

1167
00:38:03,380 --> 00:38:05,030
0,480 480,630 630,960 1230,1410 1410,1650
{} so let's go to
让我们回到前面的例子，

1168
00:38:05,030 --> 00:38:05,880
0,330
our

1169
00:38:05,880 --> 00:38:07,560
0,330 330,1080 1140,1380 1380,1530 1530,1680
previous example,| let's say we
|假设我们有以下内容，

1170
00:38:07,560 --> 00:38:09,840
0,120 120,180 180,810 810,1770
have the following {},|
|

1171
00:38:09,930 --> 00:38:11,480
0,150 150,240 240,480 480,990
we have core one,
我们有核心一号 CPU1 ，

1172
00:38:11,510 --> 00:38:13,580
0,330 690,930 930,1050 1050,1500
maybe {CPU1 - -},|
|

1173
00:38:16,620 --> 00:38:18,140
0,330 330,1050
{we,have} CPU2.|
我们有 CPU2 。|

1174
00:38:19,970 --> 00:38:21,440
0,270 270,480 480,690 690,1290 1320,1470
And {CPU1 - -}, you
CPU1 执行重命名 d1/x 到 d2/y 。

1175
00:38:21,440 --> 00:38:24,500
0,150 150,960 1380,1800 1800,2490
know executes {rename -}

1176
00:38:24,620 --> 00:38:27,060
0,240 240,660 660,1320 1350,2010
{you,know} {d1/x - -}

1177
00:38:27,270 --> 00:38:30,150
0,540 540,1140 1140,1830 1860,2220 2220,2880
to {d2/y - - -}.|
|

1178
00:38:33,310 --> 00:38:35,350
0,330 330,690 690,1230 1230,1920 1920,2040
And {CPU2 -} execute at
并且 CPU2 同时执行，

1179
00:38:35,350 --> 00:38:36,880
0,90 90,390 390,1020
the same time,|
|

1180
00:38:37,100 --> 00:38:38,780
0,1080
rename
以另一种方式重命名，

1181
00:38:42,710 --> 00:38:43,520
0,180 180,300 300,480 480,720 720,810
in the other way,| in
|从另一个方向， d2/a 到 d1/b ，

1182
00:38:43,520 --> 00:38:45,590
0,150 150,360 360,1020 1080,1590 1590,2070
the other direction {d2/a -

1183
00:38:45,620 --> 00:38:47,940
0,600 1050,1770
-} to

1184
00:38:47,940 --> 00:38:49,420
0,300 300,900
{d1 -}

1185
00:38:50,130 --> 00:38:51,240
0,180 180,360 360,480 480,750 750,1110
you know {actually -} b,|
|

1186
00:38:51,540 --> 00:38:52,650
0,240 240,480 510,750 750,840 840,1110
just to make the names
只是为了让名字有所不同。

1187
00:38:52,650 --> 00:38:54,810
0,480 870,1200 1200,1470 1470,1950 1950,2160
different.| So the critical of
|所以这里要注意的关键是，

1188
00:38:54,810 --> 00:38:57,000
0,1170 1320,1530 1530,1590 1590,1920 1920,2190
{} thing to observe here

1189
00:38:57,000 --> 00:38:59,910
0,210 210,600 960,1470 1470,1980 2100,2910
is that| {CPU1 -} runs
|CPU1 运行重命名从 d1 到 d2 ，

1190
00:38:59,940 --> 00:39:01,200
0,450 450,660 660,750 750,1020 1020,1260
rename from d1 to {d2

1191
00:39:01,200 --> 00:39:02,160
0,480
-},|
|

1192
00:39:02,160 --> 00:39:04,440
0,540 570,1170 1290,1740 1740,2100 2100,2280
and {CPU2 - -} that's
而 CPU2 正好相反，

1193
00:39:04,440 --> 00:39:06,120
0,420 420,510 510,960 960,1230 1230,1680
exactly the opposite,| does rename
|执行重命名从 d2 到 d1 。

1194
00:39:06,120 --> 00:39:07,900
0,120 120,600 600,720 720,1170
from d2 to d1.|
|

1195
00:39:09,040 --> 00:39:10,450
0,150 150,360 360,960 960,1260 1260,1410
So let's assume that,| we
所以让我们假设，|我们是按照它们的参数顺序获取锁的，

1196
00:39:10,450 --> 00:39:11,860
0,270 270,780 780,870 870,1260 1260,1410
actually acquire the locks in

1197
00:39:11,860 --> 00:39:13,090
0,60 60,390 390,450 450,600 600,1230
the order of their arguments|
|

1198
00:39:13,480 --> 00:39:14,410
0,120 120,270 270,480 480,660 660,930
and so what will happen
那么会发生什么，

1199
00:39:14,410 --> 00:39:16,360
0,90 90,450 450,780 1260,1770 1770,1950
{correct,is -} that,| {} in
|在这种情况下，你获得两个锁，

1200
00:39:16,360 --> 00:39:18,010
0,180 180,810 870,1020 1020,1320 1320,1650
this case, you will acquire

1201
00:39:18,010 --> 00:39:19,360
0,270 270,660 660,870 870,1080 1080,1350
both locks,| we know from
|我们从前面的一个例子中知道，这上是很重要的。

1202
00:39:19,360 --> 00:39:20,470
0,210 210,450 450,840 840,990 990,1110
a previous example that is

1203
00:39:20,470 --> 00:39:22,080
0,360 360,1140
actually important.|
|

1204
00:39:22,080 --> 00:39:23,700
0,270 270,1050
So acquire
所以获取 d1 锁。

1205
00:39:24,880 --> 00:39:26,940
0,300 300,510 510,750 750,1500
{you,know} {d1 -} lock.|
|

1206
00:39:28,570 --> 00:39:29,830
0,540 540,630 630,750 750,960 960,1260
And you know let's say
假设是真正的同时运行，

1207
00:39:29,830 --> 00:39:32,650
0,360 360,720 780,1170 1170,1860 2370,2820
really run true concurrent,| so
|所以在这一点上，另一个可能，

1208
00:39:32,650 --> 00:39:34,180
0,60 60,240 240,630 630,1140 1140,1530
at that point, {the,other} guy

1209
00:39:34,180 --> 00:39:35,560
0,270 270,660 660,810 810,990 990,1380
might actually,| the other CPU
|另一个 CPU 可能会先获取 d2 ，

1210
00:39:35,560 --> 00:39:37,000
0,240 240,930
might acquire

1211
00:39:37,800 --> 00:39:39,630
0,390 390,750 750,1290 1380,1680 1680,1830
{d2 -} first,| because {you,know}
|因为这是它的第一个参数。

1212
00:39:39,630 --> 00:39:41,800
0,720 720,1020 1020,1560
it's first argument.|
|

1213
00:39:43,180 --> 00:39:45,250
0,180 180,660 660,900 900,1380 1380,2070
And now {of,course} d2, d1
而现在 d1 想要获得 d2 ，

1214
00:39:45,250 --> 00:39:47,080
0,240 240,720 720,1320
{wants,to} acquired d2,|
|

1215
00:39:48,470 --> 00:39:50,060
0,270 270,480 480,690 690,990 1050,1590
so will try to acquire
所以会尝试获取 d2 。

1216
00:39:50,060 --> 00:39:51,140
0,660
d2.|
|

1217
00:39:51,260 --> 00:39:52,780
0,210 210,300 300,960
Will it succeed,|
它会成功吗，|

1218
00:39:53,540 --> 00:39:55,070
0,180 180,450 450,870 870,1230 1230,1530
it won't succeed,| because the
它不会成功，|因为另一个持有这个锁，

1219
00:39:55,070 --> 00:39:56,600
0,180 180,750 870,1050 1050,1260 1260,1530
other guy, you know actually

1220
00:39:56,600 --> 00:39:57,830
0,390 390,480 480,900 930,1080 1080,1230
has the lock| and so
|所以这个会到此为止，不再继续。

1221
00:39:57,830 --> 00:39:59,300
0,180 180,450 450,600 600,990 990,1470
this guy will stop here

1222
00:39:59,690 --> 00:40:01,500
0,390 390,600 600,690 690,1200
and not to proceed.|
|

1223
00:40:01,560 --> 00:40:02,190
0,150 150,330 330,450 450,510 510,630
Now let's look at the
现在让我们看看另一个 CPU ，

1224
00:40:02,190 --> 00:40:04,650
0,450 780,1290 1290,1650 1650,2040 2040,2460
other CPU,| {CPU2 -} acquire
|CPU2 获取了 d2 ，

1225
00:40:04,650 --> 00:40:06,300
0,630 630,870 870,1050 1050,1170 1170,1650
d2,| it's now gone {acquire,d1
|它现在要获取第二个参数 d1 。

1226
00:40:06,300 --> 00:40:07,800
0,360 360,510 510,600 600,900 900,1500
-} for its second argument.|
|

1227
00:40:08,630 --> 00:40:09,950
0,270 270,450 450,690 690,810 810,1320
It's gonna try to call,
它会试着调用 acquire d1 ，

1228
00:40:10,520 --> 00:40:12,440
0,150 150,300 300,780 810,1380 1380,1920
{} to call acquire d1,|
|

1229
00:40:12,800 --> 00:40:13,790
0,300 300,450 450,630 630,780 780,990
and will it be able
它是否能够继续执行。

1230
00:40:13,790 --> 00:40:15,440
0,90 90,600 780,1170 1170,1530 1530,1650
to proceed.| No, won't be
|不，无法继续，

1231
00:40:15,440 --> 00:40:17,900
0,180 180,270 270,780 930,1770 2010,2460
able to proceed,| because the
|因为 CPU1 持有锁 d1 。

1232
00:40:18,170 --> 00:40:19,580
0,300 300,720 720,1020 1020,1290 1290,1410
{CPU1 -} actually has the

1233
00:40:19,580 --> 00:40:20,920
0,270 270,360 360,480 480,840
lock {} {d1 -}.|
|

1234
00:40:21,040 --> 00:40:22,510
0,240 240,390 390,720 720,1170 1170,1470
And so here we're sometimes
所以有时这被称为死锁，

1235
00:40:22,510 --> 00:40:23,470
0,120 120,210 210,540 540,570 570,960
this is called a deadly

1236
00:40:23,470 --> 00:40:25,930
0,660 660,810 810,1170 1170,1620 2040,2460
embrace,| you know, { -}
|因为，

1237
00:40:25,930 --> 00:40:27,850
0,570 570,690 690,1170 1500,1800 1800,1920
where you know,| because the
|因为我们获取锁的方式，获取的顺序，

1238
00:40:27,850 --> 00:40:29,440
0,330 330,540 540,930 930,1290 1290,1590
way we acquire, the order

1239
00:40:29,440 --> 00:40:30,760
0,90 90,300 300,840 870,1140 1140,1320
in which we,| order which
|获取锁的顺序会导致死锁。

1240
00:40:30,760 --> 00:40:32,290
0,300 300,630 630,990 990,1350 1350,1530
acquire lock results actually in

1241
00:40:32,290 --> 00:40:33,660
0,270 270,990
a deadlock.|
|

1242
00:40:41,050 --> 00:40:42,580
0,300 300,390 390,540 540,960
Does that make sense?|
这能理解吗？|

1243
00:40:42,580 --> 00:40:43,860
0,150 150,750
This example.|
这个例子。|

1244
00:40:45,580 --> 00:40:46,420
0,300 300,390 390,600 600,750 750,840
This is a little bit
这是一个更危险的死锁的例子，

1245
00:40:46,420 --> 00:40:47,770
0,180 180,270 270,510 510,840 840,1350
of a more dangerous example

1246
00:40:47,920 --> 00:40:49,120
0,90 90,630 660,900 900,1110 1110,1200
of deadlock,| it's not an
|这不是一个明显的问题，

1247
00:40:49,120 --> 00:40:51,610
0,600 630,1590 1890,2040 2040,2130 2130,2490
obvious problem| and the solution
|这个情况的解决方案是简单的。

1248
00:40:51,610 --> 00:40:53,020
0,240 240,540 870,990 990,1200 1200,1410
turns out in some sense

1249
00:40:53,020 --> 00:40:55,180
0,270 270,840 960,1560
reasonable simple {}.|
|

1250
00:40:56,370 --> 00:40:57,540
0,120 120,510 510,690 690,1050 1050,1170
The solution is that you
解决方案是，如果你有多把锁，

1251
00:40:57,540 --> 00:40:58,320
0,60 60,150 150,270 270,450 450,780
know if you have multiple

1252
00:40:58,320 --> 00:41:00,600
0,540 720,1620 1740,2010 2010,2190 2190,2280
locks,| then you have to
|那你就得对锁排序，

1253
00:41:00,600 --> 00:41:02,080
0,270 270,390 390,900
order their locks,|
|

1254
00:41:03,930 --> 00:41:06,120
0,510 510,840 840,1650
and full operations
所有操作都必须按照这个顺序来获取锁。

1255
00:41:06,120 --> 00:41:07,590
0,420 420,510 510,1050 1050,1350 1350,1470
have to acquire locks in

1256
00:41:07,590 --> 00:41:08,760
0,210 210,630
that order.|
|

1257
00:41:17,410 --> 00:41:18,370
0,390 390,510 510,660 660,690 690,960
So if you're a system
所以如果你是一名系统设计师，

1258
00:41:18,370 --> 00:41:19,690
0,510 510,660 660,810 810,900 900,1320
designer,| you have to decide
|你必须决定所有锁对象的全局顺序，

1259
00:41:19,690 --> 00:41:21,640
0,90 90,180 180,390 390,870 1200,1950
you know what the global

1260
00:41:21,640 --> 00:41:23,380
0,420 420,660 660,1200 1200,1470 1470,1740
order is for all lock

1261
00:41:23,380 --> 00:41:25,870
0,660 900,1860 1890,2010 2010,2160 2160,2490
objects| and so for example
|比如，在这种情况下，

1262
00:41:25,870 --> 00:41:26,530
0,60 60,180 180,450 450,570 570,660
in this case| where you
|你可能会说 d1 应该总是在 d2 之前，

1263
00:41:26,530 --> 00:41:27,490
0,150 150,420 420,540 540,750 750,960
may want to say that

1264
00:41:27,490 --> 00:41:29,740
0,150 150,600 600,870 870,1290 1290,2250
{d1 -} should always order

1265
00:41:29,740 --> 00:41:31,480
0,300 300,930 1140,1290 1290,1440 1440,1740
before d2,| and that means
|这就意味着，

1266
00:41:31,480 --> 00:41:33,430
0,450 750,1200 1200,1440 1440,1590 1590,1950
that,| {} when we execute
|当我们执行重命名时，

1267
00:41:33,430 --> 00:41:34,780
0,60 60,660 810,1020 1020,1260 1260,1350
a rename,| the rule of
|规则是我们总是先获取更小数字的目录，

1268
00:41:34,780 --> 00:41:36,760
0,300 300,750 780,930 930,1350 1350,1980
life is we always acquire

1269
00:41:36,820 --> 00:41:39,520
0,330 360,900 900,1440 1590,2310
{} lower number {}

1270
00:41:39,550 --> 00:41:41,860
0,630 660,1140 1140,1680 1680,2160 2160,2310
{} directories first,| before we
|在获取更高数字的目录之前。

1271
00:41:41,860 --> 00:41:43,930
0,480 480,1140 1140,1380 1380,1770 1770,2070
acquire higher order directory number.|
|

1272
00:41:44,900 --> 00:41:46,730
0,480 690,870 870,1020 1020,1200 1200,1830
{} And that will ensure
这将确保全局顺序，

1273
00:41:46,760 --> 00:41:48,740
0,180 180,780 1020,1410 1410,1650 1650,1980
that basically {} there's global

1274
00:41:48,740 --> 00:41:50,240
0,480 480,1020 1050,1140 1140,1290 1290,1500
order| and you know this
|这种情况就不会发生。

1275
00:41:50,240 --> 00:41:52,160
0,420 420,870 870,1080 1080,1500 1500,1920
particular case which cannot happen.|
|

1276
00:41:52,710 --> 00:41:53,960
0,690

1277
00:41:53,960 --> 00:41:55,490
0,420 420,540 540,630 630,900 1200,1530
Because you know the lock
因为，锁的顺序会是，

1278
00:41:55,490 --> 00:41:56,210
0,330 330,420 420,540 540,600 600,720
order is going to be|
|

1279
00:41:56,210 --> 00:41:58,370
0,390 390,840 1050,1350 1350,1860 1890,2160
then for {d1 -} {d2
对于这个是 d1 d2 ，

1280
00:41:58,370 --> 00:42:00,110
0,240 240,360 360,540 540,1080 1320,1740
-} for this guy| and
|这个也使用相同的顺序获取锁， d1 d2 ，

1281
00:42:00,110 --> 00:42:01,550
0,270 270,450 450,660 660,1140 1140,1440
this guy will acquire locks

1282
00:42:01,550 --> 00:42:03,140
0,420 420,510 510,780 780,1170 1170,1590
exactly the same global order,

1283
00:42:03,140 --> 00:42:04,730
0,60 60,210 210,630 630,1260 1440,1590
you know, d1 d2| and
|这样我们就没有死锁了。

1284
00:42:04,730 --> 00:42:06,500
0,210 210,330 330,540 540,960 1260,1770
then we don't have deadly

1285
00:42:06,500 --> 00:42:07,380
0,480
embrace.|
|

1286
00:42:09,700 --> 00:42:11,060
0,120 120,210 210,330 330,750
Does that make sense?|
这能理解吗？|

1287
00:42:14,630 --> 00:42:16,420
0,270 270,660 660,840 840,1200
Any questions about this?|
对于这个，有什么问题吗？|

1288
00:42:17,520 --> 00:42:18,500
0,60

1289
00:42:22,180 --> 00:42:23,470
0,150 150,420 420,1080 1080,1140 1140,1290
So this indicates a little
所以这表明了一些问题，

1290
00:42:23,470 --> 00:42:25,870
0,120 120,210 210,870 870,1560 1890,2400
bit of {} problem {},|
|

1291
00:42:25,870 --> 00:42:26,890
0,180 180,390 390,660 660,870 900,1020
even though like,| okay let's
即使这样，|好的，让我们来解决这个死锁问题，

1292
00:42:26,890 --> 00:42:27,910
0,210 210,570 600,720 720,870 870,1020
fix this you know this

1293
00:42:27,910 --> 00:42:29,050
0,150 150,210 210,630 630,1020 1020,1140
sort of deadlock problem,| that
|我有全局顺序，请注意这个顺序是全局的，

1294
00:42:29,050 --> 00:42:30,190
0,90 90,240 240,360 360,690 690,1140
I have in global order,

1295
00:42:30,220 --> 00:42:32,200
0,450 450,1020 1200,1500 1500,1560 1560,1980
notice this order is global|
|

1296
00:42:32,560 --> 00:42:35,110
0,480 900,1500 1680,1950 1950,2160 2160,2550
{} and this is {}
这有一个小问题，

1297
00:42:37,050 --> 00:42:38,370
0,270 300,690 690,750 750,960 960,1320
an issue a little bit,|
|

1298
00:42:38,490 --> 00:42:40,050
0,450 450,750 750,1140 1140,1230 1230,1560
{} when designing a system,
在设计系统时，因为。

1299
00:42:40,050 --> 00:42:42,620
0,390 810,1350 1440,1830 1830,2070
because.| {} Hold on.|
|等一下。|

1300
00:43:07,510 --> 00:43:08,470
0,180 180,270 270,390 390,600 600,960
So you think about the
所以考虑一下锁的顺序，

1301
00:43:08,470 --> 00:43:10,480
0,150 150,210 210,450 450,1080 1320,2010
sort of lock ordering, {}|
|

1302
00:43:15,050 --> 00:43:15,710
0,150 150,240 240,360 360,570 570,660
you know there has to
一定是全局的。

1303
00:43:15,710 --> 00:43:17,240
0,120 120,300 300,360 360,900
be sort of global.|
|

1304
00:43:18,030 --> 00:43:19,020
0,360 360,570 570,690 690,780 780,990
And so we have one
所以，如果我们有一个模块 m1 调用方法模块 m2 的方法。

1305
00:43:19,020 --> 00:43:21,510
0,720 1140,1470 1470,1950 1950,2040 2040,2490
module, one m, you know

1306
00:43:21,630 --> 00:43:23,780
0,600 600,1620
calls method

1307
00:43:24,390 --> 00:43:26,960
0,1020 1320,2010
{in,module} two.|
|

1308
00:43:27,490 --> 00:43:29,060
0,870

1309
00:43:29,440 --> 00:43:31,120
0,450 450,720 750,1410 1440,1530 1530,1680
And the caller, you know
那么调用者 m1g ，可能需要注意，

1310
00:43:31,120 --> 00:43:32,440
0,180 180,420 420,900 930,1050 1050,1320
{m1g - -}, {you,know} might

1311
00:43:32,440 --> 00:43:33,970
0,360 360,630 630,750 750,930 930,1530
actually need to be aware|
|

1312
00:43:33,970 --> 00:43:34,780
0,150 150,390 390,510 510,600 600,810
or could be you need
或者你需要注意，

1313
00:43:34,780 --> 00:43:35,980
0,90 90,210 210,660 660,960 960,1200
to be aware| actually what
|在 m2 中 f 获取了哪些锁。

1314
00:43:35,980 --> 00:43:37,960
0,840 1020,1500
locks f

1315
00:43:37,960 --> 00:43:40,060
0,450 450,540 540,780 780,1290 1410,2100
acquire for [one] locks m2

1316
00:43:40,060 --> 00:43:41,220
0,600
uses.|
|

1317
00:43:42,630 --> 00:43:45,510
0,600 750,1320 1500,1950 1950,2700 2730,2880
{} Because {} if {you,know}
因为，如果 m2 使用了一些锁，

1318
00:43:45,510 --> 00:43:47,760
0,240 240,630 630,1650 1680,2040 2040,2250
{m2 -} {} uses some

1319
00:43:47,760 --> 00:43:50,250
0,180 180,750 990,2010 2040,2130 2130,2490
set locks,| then you know
|然后遵守我们的锁规则，

1320
00:43:50,310 --> 00:43:51,960
0,420 420,570 570,840 840,1200 1200,1650
follow our lock ordering rule,|
|

1321
00:43:52,110 --> 00:43:53,040
0,270 270,570 570,720 720,780 780,930
{} [just] got to make
只需要确保如果它有锁，

1322
00:43:53,040 --> 00:43:54,150
0,390 390,720 720,810 810,900 900,1110
sure that you know if

1323
00:43:54,150 --> 00:43:55,500
0,150 150,330 330,480 480,930 1020,1350
it has some locks,| then
|从 f 和 g 获取的所有锁，

1324
00:43:55,500 --> 00:43:57,390
0,390 390,570 570,1050 1410,1620 1620,1890
acquires all locks from f

1325
00:43:57,390 --> 00:43:58,590
0,120 120,330 330,720 720,1050 1050,1200
and g,| together actually in
|是在某种全局顺序中。

1326
00:43:58,590 --> 00:44:00,880
0,540 750,1500 1500,1890
some global order.|
|

1327
00:44:01,270 --> 00:44:02,290
0,150 150,270 270,450 450,660 660,1020
And so that really means
所以这意味着这些内部结构，

1328
00:44:02,290 --> 00:44:03,880
0,210 210,390 390,540 540,630 630,1590
that these sort of internals,|
|

1329
00:44:06,600 --> 00:44:08,600
0,570 570,630 630,840 840,1320
internals of {m2 -},
就锁而言， m2 的内部部件必须对 m1 可见。

1330
00:44:08,780 --> 00:44:10,600
0,660 660,1260
{in,terms,of} locks

1331
00:44:15,830 --> 00:44:17,180
0,300 300,420 420,900 900,1170 1170,1350
must be visible to {m1

1332
00:44:17,180 --> 00:44:18,360
0,390
-}.|
|

1333
00:44:21,400 --> 00:44:22,210
0,150 150,360 360,450 450,630 630,810
So that you know and
所以 m1 可以确保，

1334
00:44:22,210 --> 00:44:23,470
0,270 270,390 390,720 720,900 900,1260
m1 can ensure that,| actually
|以适当的方式调用 m2 。

1335
00:44:23,470 --> 00:44:25,990
0,90 90,330 420,690 690,1320 1320,2520
you know {} calls {}

1336
00:44:25,990 --> 00:44:28,120
0,210 210,420 420,630 630,1740 1740,2130
{m2 -} in the appropriate

1337
00:44:28,120 --> 00:44:28,920
0,240
way.|
|

1338
00:44:29,120 --> 00:44:29,960
0,300 300,600 600,690 690,780 780,840
{} And you know in
在某些方面，这是一种对抽象的违反，

1339
00:44:29,960 --> 00:44:30,800
0,150 150,330 330,540 540,660 660,840
some ways, that is kind

1340
00:44:30,800 --> 00:44:35,210
0,330 330,390 390,960 960,1620 3900,4410
of an abstraction violation,| actually
|实际上做得很好，

1341
00:44:35,210 --> 00:44:36,800
0,180 180,270 270,840 840,1080 1080,1590
work out perfectly| and m1
|m1 不需要知道关于 m2 实现的任何信息，

1342
00:44:36,800 --> 00:44:37,400
0,120 120,210 210,360 360,420 420,600
{doesn't,know} {} need to know

1343
00:44:37,400 --> 00:44:38,780
0,480 480,750 750,870 870,1260 1260,1380
anything about how m2 was

1344
00:44:38,780 --> 00:44:42,020
0,570 1050,1290 1290,1800 1800,2430 2670,3240
implemented| and unfortunately locks are
|不幸的是，锁是一种常见的例子，

1345
00:44:42,020 --> 00:44:43,310
0,90 90,450 450,960 960,1020 1020,1290
{} common example| of where
|m2 要讲内部信息泄露给 m1 ，

1346
00:44:43,310 --> 00:44:45,230
0,180 180,240 240,360 360,1080 1470,1920
some of the internals, m2

1347
00:44:45,230 --> 00:44:46,640
0,300 300,750 750,1080 1080,1260 1260,1410
might actually {leak,out} to {m1

1348
00:44:46,640 --> 00:44:48,410
0,390 600,990 990,1320 1320,1530 1530,1770
-},| because m1 really needs
|因为 m1 确实需要知道。

1349
00:44:48,410 --> 00:44:49,180
0,90 90,330
to know.|

1350
00:44:49,740 --> 00:44:51,120
0,270 270,450 450,780 960,1290 1290,1380
{} And so when you
所以，当你设计一个更大的系统时，

1351
00:44:51,120 --> 00:44:53,400
0,360 360,780 780,990 990,1590 1740,2280
design a bigger system {},|
|

1352
00:44:53,400 --> 00:44:54,540
0,120 120,630 690,870 870,1080 1080,1140
you know, this makes the
这使得模块化变得更加复杂。

1353
00:44:54,540 --> 00:44:56,130
0,330 330,480 480,630 630,900 900,1590
{modularity - -} more complicated.|
|

1354
00:45:01,730 --> 00:45:03,320
0,390 390,510 510,660 660,930 930,1590
{Oh,sorry}, I was just wondering,
抱歉，我想知道，是否需要完整的锁的顺序，

1355
00:45:03,350 --> 00:45:04,280
0,270 270,480 480,570 570,780 780,930
does need to be a

1356
00:45:04,280 --> 00:45:07,160
0,840 1110,1530 1530,2100 2100,2250 2250,2880
complete {} ordering of locks|
|

1357
00:45:07,160 --> 00:45:08,690
0,300 300,570 570,810 810,1020 1020,1530
or can there be some
或者有没有一些锁，

1358
00:45:09,050 --> 00:45:11,540
0,390 390,570 570,960 1350,1770 2220,2490
locks that are,| {} that
|可以用任何方式排序。

1359
00:45:11,540 --> 00:45:13,610
0,150 150,540 570,1050 1050,1260 1260,2070
can be ordered in whatever

1360
00:45:13,640 --> 00:45:16,640
0,600 630,1110 1260,2340 2340,2670 2670,3000
way they.| Yeah, it depends,|
|是的，这要看情况，|

1361
00:45:16,640 --> 00:45:17,810
0,180 180,360 360,510 510,630 630,1170
if like f and g
如果 f 和 g 共享任何锁，

1362
00:45:17,840 --> 00:45:19,370
0,180 180,510 510,690 690,1110 1110,1530
{you,know} share any locks right,|
|

1363
00:45:19,970 --> 00:45:21,590
0,210 210,600 600,720 720,1260 1260,1620
for example if you're looking
比如，如果查看 xv6 ，

1364
00:45:21,590 --> 00:45:24,020
0,180 180,390 390,870 1140,1740 1740,2430
at {xv6 -},| {} there
|它有多个锁顺序链，

1365
00:45:24,200 --> 00:45:26,450
0,570 600,900 900,960 960,1380 1380,2250
are sort of multiple strands

1366
00:45:26,480 --> 00:45:27,920
0,300 300,570 570,1080 1080,1290 1290,1440
of lock orderings,| because some
|因为有些函数与其他锁无关，

1367
00:45:27,920 --> 00:45:28,910
0,390 390,540 540,780 780,840 840,990
functions have nothing to do

1368
00:45:28,910 --> 00:45:29,900
0,120 120,330 330,660 660,780 780,990
with other locks| and you
|它们永远不会一起获得。

1369
00:45:29,900 --> 00:45:32,270
0,330 330,810 810,1020 1020,1680 1890,2370
know they're never acquired together.|
|

1370
00:45:33,000 --> 00:45:33,960
0,330 330,450 450,600 600,720 720,960
And so if they're never
所以如果它们从来没有一起获取，

1371
00:45:33,960 --> 00:45:35,700
0,300 300,930 930,1170 1170,1440 1440,1740
acquire together,| just join locks
|如果您愿意，只需连接锁集，

1372
00:45:35,700 --> 00:45:37,200
0,270 270,390 390,480 480,900 1230,1500
sets, if you will| and
|然后，只需要确保特定锁集合中的顺序是全局的，

1373
00:45:37,200 --> 00:45:38,130
0,300 300,660 660,750 750,840 840,930
then only you have to

1374
00:45:38,130 --> 00:45:39,210
0,180 180,420 420,570 570,660 660,1080
make sure that the ordering

1375
00:45:39,210 --> 00:45:40,740
0,390 390,660 660,1080 1080,1350 1350,1530
in one particular locks set

1376
00:45:40,740 --> 00:45:43,140
0,90 90,600 870,1380 1470,1950 1950,2400
is global| and the ordering
|并且其它锁集合的顺序序完全独立于其它顺序。

1377
00:45:43,140 --> 00:45:43,950
0,90 90,270 270,510 510,720 720,810
the other locks set is

1378
00:45:43,950 --> 00:45:45,180
0,330 330,810 810,870 870,1020 1020,1230
completely independent of the other

1379
00:45:45,180 --> 00:45:46,100
0,450
ordering.|
|

1380
00:45:47,730 --> 00:45:48,810
0,180 180,450 450,600 600,930 930,1080
So it is correct, that
所以这是正确的，不一定是全局顺序，

1381
00:45:48,810 --> 00:45:50,100
0,540 540,810 810,1080 1080,1170 1170,1290
it doesn't have to be

1382
00:45:50,100 --> 00:45:51,480
0,60 60,420 420,840 840,1200 1200,1380
{} global ordering,| but like
|但就像所有操作相同共享类型的锁集的函数，

1383
00:45:51,510 --> 00:45:53,580
0,240 240,330 330,810 810,1380 1500,2070
all the functions that manipulate

1384
00:45:53,580 --> 00:45:54,840
0,90 90,450 450,870 930,1200 1200,1260
the same share sort of

1385
00:45:54,840 --> 00:45:56,220
0,390 390,720 810,1140 1140,1290 1290,1380
lock set,| they need to
|它们需要一致的全局顺序。

1386
00:45:56,220 --> 00:45:57,480
0,330 330,510 510,570 570,900 900,1260
agree on a global order.|
|

1387
00:45:59,130 --> 00:46:00,560
0,390 390,780
Thank you.|
谢谢。|

1388
00:46:04,430 --> 00:46:05,880
0,300 300,870
Okay so.|
好的，那么。|

1389
00:46:05,880 --> 00:46:07,950
0,300 300,1020 1260,1440 1440,1650 1650,2070
One in, you know another
另一种挑战使用锁的挑战，

1390
00:46:07,950 --> 00:46:09,990
0,180 180,480 660,1020 1020,1860 1950,2040
sort of {} challenge {}

1391
00:46:09,990 --> 00:46:11,880
0,450 450,1020 1080,1260 1260,1650 1650,1890
with locks,| {} we've seen
|我们已经看到了两个挑战，

1392
00:46:11,880 --> 00:46:13,260
0,150 150,540 540,750 750,1230 1230,1380
two challenges,| {one,is} deadlock, one
|一个是死锁，一个是模块化，

1393
00:46:13,260 --> 00:46:15,090
0,90 90,300 300,870 1260,1620 1620,1830
is {modularity -},| {} the
|第三个挑战是锁与性能。

1394
00:46:15,090 --> 00:46:17,640
0,270 270,1140 1500,1680 1680,2340 2340,2550
second challenge {or,third} challenge just

1395
00:46:17,640 --> 00:46:18,740
0,540
locks

1396
00:46:18,740 --> 00:46:20,200
0,900
{versus,performance}.|
|

1397
00:46:24,100 --> 00:46:25,990
0,360 360,480 480,630 630,1260 1500,1890
And you know really hinted
我之前暗示了几次，

1398
00:46:25,990 --> 00:46:26,800
0,90 90,210 210,270 270,480 480,810
at this a couple times,|
|

1399
00:46:26,800 --> 00:46:28,600
0,120 120,270 270,510 510,1320 1740,1800
but it needs to {},|
但它需要，|

1400
00:46:28,630 --> 00:46:31,270
0,360 360,570 1560,2070 2070,2250 2250,2640
{} is important enough to
强调一下是非常重要的。

1401
00:46:31,300 --> 00:46:32,770
0,360 360,600 600,720 720,1140 1140,1470
actually put some emphasis on.|
|

1402
00:46:33,400 --> 00:46:35,140
0,600 810,1200 1200,1290 1290,1620 1620,1740
{} And so basically we
所以我们想要性能，

1403
00:46:35,140 --> 00:46:37,720
0,180 180,300 300,630 660,1800 1830,2580
want to get {} performance,|
|

1404
00:46:37,720 --> 00:46:39,520
0,390 390,600 600,1110 1380,1710 1710,1800
you need to split up
你需要拆分数据结构，

1405
00:46:39,520 --> 00:46:41,590
0,240 240,660 1140,1560 1710,1830 1830,2070
data structures,| so if you
|所以如果你有一个大内核锁，

1406
00:46:41,590 --> 00:46:42,880
0,210 210,450 450,630 630,900 900,1290
have one big kernel lock,|
|

1407
00:46:43,150 --> 00:46:44,140
0,270 270,450 450,600 600,900 900,990
{} that will limit your
这将使你的性能限于在单个 CPU 上，

1408
00:46:44,140 --> 00:46:45,730
0,510 510,720 720,1080 1080,1530 1530,1590
performance to basically performance on

1409
00:46:45,730 --> 00:46:46,990
0,60 60,330 330,930 1080,1170 1170,1260
a single CPU,| if you
|如果你想要具有多个 CPU 扩展的性能，

1410
00:46:46,990 --> 00:46:49,300
0,330 330,600 600,1170 1170,1830 1980,2310
want to perform, you want

1411
00:46:49,300 --> 00:46:51,310
0,240 240,570 570,1170 1170,1650 1650,2010
that performed scales with numerous

1412
00:46:51,310 --> 00:46:53,140
0,540 750,870 870,1140 1140,1500 1500,1830
CPUs,| you gotta split up.|
|你就得拆分。|

1413
00:46:54,190 --> 00:46:54,940
0,180 180,330 330,390 390,630 630,750
You need to split up
你需要拆分数据结构。

1414
00:46:54,940 --> 00:46:56,320
0,240 240,750
data structures.|
|

1415
00:47:04,910 --> 00:47:07,520
0,750 1050,1500 1500,1950 1980,2160 2160,2610
And best split, you know,
最好的拆分，它并不明显，

1416
00:47:07,730 --> 00:47:09,120
0,810
{}

1417
00:47:09,320 --> 00:47:10,670
0,150 150,330 330,810 960,1200 1200,1350
it's not obvious| or can
|或者是一个挑战，

1418
00:47:10,670 --> 00:47:11,940
0,90 90,180 180,750
be a challenge,|
|

1419
00:47:17,780 --> 00:47:19,100
0,570 570,690 690,810 810,900 900,1320
{} you know, for example
比如，如果你将锁与每个目录相关联，

1420
00:47:19,100 --> 00:47:20,570
0,300 330,690 690,1110 1110,1170 1170,1470
if you associate the lock

1421
00:47:20,570 --> 00:47:21,860
0,120 120,300 300,810 810,990 990,1290
with every directories,| if you
|如果你将锁与每个 inode 相关联，

1422
00:47:21,860 --> 00:47:22,970
0,450 450,510 510,750 750,870 870,1110
associate the lock with every

1423
00:47:22,970 --> 00:47:24,890
0,120 120,540 900,1530 1530,1800 1800,1920
{inode -},| associated lock with
|是否将锁与每个进程相关联。

1424
00:47:24,890 --> 00:47:26,480
0,180 180,600 600,660 660,1050
every process or not.|
|

1425
00:47:26,480 --> 00:47:28,100
0,270 270,630 630,720 720,810 810,1620
{} Where is the better
哪里是，更适合的以不同的方式拆分数据结构。

1426
00:47:28,100 --> 00:47:29,510
0,300 300,540 540,690 900,1320 1320,1410
to, sort of split the

1427
00:47:29,510 --> 00:47:30,590
0,240 240,600 600,720 720,810 810,1080
data structures in a different

1428
00:47:30,590 --> 00:47:31,520
0,330
way.|

1429
00:47:31,930 --> 00:47:34,570
0,600 960,1680 1950,2340 2340,2550 2550,2640
{} And {} if you
如果你需要修改，

1430
00:47:34,570 --> 00:47:36,010
0,120 120,210 210,720 720,1140 1140,1440
make a change,| {you,know} {sort,of}
|重新设计锁规则，

1431
00:47:36,010 --> 00:47:39,700
0,1230 1230,1620 1800,2310 2310,3000 3330,3690
redesign the locking discipline {},|
|

1432
00:47:39,700 --> 00:47:41,170
0,480 570,810 810,990 990,1170 1200,1470
and you've got to make
你必须确保，

1433
00:47:41,170 --> 00:47:42,100
0,360 360,540 540,600 600,750 750,930
sure| that you know you're
|你仍然保持着不变量，

1434
00:47:42,100 --> 00:47:43,690
0,210 210,720 720,810 810,1440 1440,1590
still maintain the invariant,| that
|是内核想要保持的。

1435
00:47:43,690 --> 00:47:45,610
0,420 1080,1170 1170,1500 1500,1740 1740,1920
actually the kernels trying to

1436
00:47:45,610 --> 00:47:46,680
0,600
maintain.|
|

1437
00:47:46,870 --> 00:47:48,370
0,330 330,750 900,1050 1050,1200 1200,1500
{} And if you split
如果你拆分锁，

1438
00:47:48,370 --> 00:47:49,690
0,420 420,930 930,1110 1110,1230 1230,1320
locks,| you also have to
|你还必须重写代码。

1439
00:47:49,690 --> 00:47:51,200
0,330 330,390 390,900
rewrite the code.|
|

1440
00:47:51,540 --> 00:47:52,830
0,480 480,660 660,780 780,870 870,1290
You may have to need,
你也可能需要重写代码。

1441
00:47:52,860 --> 00:47:55,020
0,510 510,960 1200,1530 1530,1830 1830,2160
may write, may need to,

1442
00:47:56,360 --> 00:47:57,500
0,150 150,300 300,540 540,780 780,1140
{rewrite - -} code too.|
|

1443
00:48:02,540 --> 00:48:03,710
0,450 450,570 570,660 660,900 900,1170
And so it turns out
所以事实证明，

1444
00:48:03,710 --> 00:48:06,650
0,120 120,840 930,1950 2190,2700 2700,2940
that,| basically {} you should
|你应该重构内核的一部分，或者你的程序的一部分，

1445
00:48:06,650 --> 00:48:09,230
0,780 780,930 930,1140 1140,1140 2340,2580
refactor you know {} part

1446
00:48:09,230 --> 00:48:10,280
0,90 90,180 180,600 600,840 840,1050
of your kernel or part

1447
00:48:10,280 --> 00:48:11,960
0,60 60,210 210,480 480,1080 1380,1680
of your [] program,| to
|为了获得更好的性能，

1448
00:48:11,960 --> 00:48:13,820
0,210 210,420 420,960 960,1050 1050,1860
get better performance| {} by
|通过拆分数据结构或引入更多的锁，

1449
00:48:13,820 --> 00:48:15,530
0,420 420,660 660,990 990,1260 1260,1710
splitting data structure or introducing

1450
00:48:15,530 --> 00:48:17,180
0,240 240,810 1080,1410 1410,1530 1530,1650
more locks,| {} you know
|有很多工作要做，

1451
00:48:17,180 --> 00:48:18,200
0,360 360,600 600,810 810,960 960,1020
there's just a lot of

1452
00:48:18,200 --> 00:48:19,070
0,270 270,330 330,420 420,480 480,870
work,| you have to carefully
|你要仔细考虑，想要维持持的范围，

1453
00:48:19,070 --> 00:48:20,480
0,210 210,540 540,720 720,1230 1230,1410
think through, that maintain, the

1454
00:48:20,480 --> 00:48:22,040
0,330 330,450 450,870 870,960 960,1560
range that intended to maintain,|
|

1455
00:48:22,310 --> 00:48:23,270
0,540 540,630 630,720 720,840 840,960
{} you have to []
你必须要写代码，

1456
00:48:23,270 --> 00:48:25,880
0,300 300,840 1080,1530 1530,1800 1860,2610
write code| and so generally
|一般说来，这是一项繁重的工作，

1457
00:48:25,880 --> 00:48:26,630
0,150 150,270 270,450 450,540 540,750
this is just a lot

1458
00:48:26,630 --> 00:48:27,420
0,60 60,420
of work,|
|

1459
00:48:28,020 --> 00:48:29,420
0,150 150,480 480,780
they're not easy.|
它们并不容易。|

1460
00:48:32,500 --> 00:48:33,610
0,300 300,450 450,540 540,720 720,1110
{} And so there's a
所以这是比较负面的观点，

1461
00:48:33,640 --> 00:48:35,170
0,240 240,330 330,450 450,990 1020,1530
little bit of negative view

1462
00:48:35,170 --> 00:48:36,520
0,300 300,510 510,930 930,1080 1080,1350
point, right,| because you know
|因为我们想要更好的性能，

1463
00:48:37,120 --> 00:48:37,870
0,210 210,360 360,420 420,570 570,750
we want to get better

1464
00:48:37,870 --> 00:48:39,820
0,660 690,990 990,1500 1500,1680 1680,1950
performance,| that suggests {you,know} more
|这需要更多的锁。

1465
00:48:39,820 --> 00:48:43,160
0,540 870,1530 1530,2220 2250,2850
locks.| {} And {},
|但这是一项繁重的工作。

1466
00:48:43,250 --> 00:48:45,440
0,180 180,990 1200,1380 1380,1680 1680,2190
but that is actually a

1467
00:48:45,530 --> 00:48:46,820
0,270 270,360 360,750
lot of work.|
|

1468
00:48:46,940 --> 00:48:48,320
0,330 330,480 480,630 630,750 750,1380
{} It's sort of general
对于这个问题，有一种普遍的做法是，

1469
00:48:48,320 --> 00:48:49,500
0,690
recipe,

1470
00:48:49,650 --> 00:48:50,520
0,180 180,330 330,660 660,720 720,870
you know how to go

1471
00:48:50,520 --> 00:48:52,290
0,300 300,690 1050,1320 1320,1680 1680,1770
about this is,| to you
|从粗粒度的锁开始，

1472
00:48:52,290 --> 00:48:53,600
0,150 150,780
know start

1473
00:48:53,780 --> 00:48:55,560
0,150 150,450 450,690 690,1200
of {coarse-grained -} locks,|
|

1474
00:49:05,160 --> 00:49:06,480
0,150 150,240 240,840
and then measure.|
然后测量。|

1475
00:49:11,600 --> 00:49:12,620
0,120 120,480 480,720 720,810 810,1020
So whatever run a bunch
不管是什么应用程序运行在内核上，

1476
00:49:12,620 --> 00:49:13,670
0,90 90,720 720,780 780,990 990,1050
of applications on top of

1477
00:49:13,670 --> 00:49:16,610
0,120 120,780 1020,2100 2100,2670 2670,2940
the kernel| and {} see
|观察是否得到了加速，

1478
00:49:16,610 --> 00:49:17,570
0,270 270,390 390,510 510,780 780,960
whether you get actually any

1479
00:49:17,570 --> 00:49:19,130
0,450 450,690 690,900 900,1200 1200,1560
speedup,| if they actually exploit
|如果它们利用了多个核心。

1480
00:49:19,130 --> 00:49:20,380
0,300 300,750
multiple cores.|
|

1481
00:49:20,560 --> 00:49:22,090
0,630 660,840 840,960 960,1380 1410,1530
And if they do, you
如果它们这样做了，你就完成了，

1482
00:49:22,090 --> 00:49:22,720
0,120 120,270 270,450 450,540 540,630
know you {basically -} be

1483
00:49:22,720 --> 00:49:24,250
0,270 300,570 570,960 990,1230 1230,1530
done, right,| that you're locking
|你的锁设计已经够好了，

1484
00:49:24,250 --> 00:49:26,380
0,330 330,450 450,600 600,990 1740,2130
design is good enough,| if
|如果没有加快速度，

1485
00:49:26,440 --> 00:49:27,460
0,210 210,450 450,570 570,750 750,1020
you don't get speed up,|
|

1486
00:49:27,460 --> 00:49:28,630
0,450 450,570 570,840 840,990 990,1170
basically that means that some
这意味着某些锁被争用，

1487
00:49:28,630 --> 00:49:30,180
0,240 240,330 330,990
lock is contended,|
|

1488
00:49:33,030 --> 00:49:34,860
0,750 780,1410 1410,1500 1500,1770 1770,1830
multiple processes are trying to
多个进程尝试获取相同的锁，

1489
00:49:34,860 --> 00:49:36,030
0,120 120,210 210,510 510,960 990,1170
get the same lock| and
|因此它们被串行化了，

1490
00:49:36,030 --> 00:49:37,500
0,360 360,510 510,660 660,1110 1110,1470
therefore they are {serialized -}|
|

1491
00:49:37,710 --> 00:49:39,090
0,180 180,510 510,630 630,840 840,1380
and therefore you don't get
所以，得不到加速。

1492
00:49:39,090 --> 00:49:40,160
0,240 240,540
speed up.|
|

1493
00:49:40,160 --> 00:49:41,390
0,300 300,780 780,990 990,1140 1140,1230
{} Then {you,know} you have
然后你需要重新考虑，需要重新设计。

1494
00:49:41,390 --> 00:49:43,100
0,90 90,450 450,900 930,1500 1530,1710
to rethink about, then you

1495
00:49:43,100 --> 00:49:44,960
0,150 150,390 660,1290
need to redesign.|
|

1496
00:49:48,020 --> 00:49:49,280
0,510 540,750 750,840 840,1110 1110,1260
{} But the point is
但这里的重点是，

1497
00:49:49,280 --> 00:49:49,820
0,120 120,210 210,360 360,420 420,540
that,| you want to be
|你要以这些测量来指导，

1498
00:49:49,820 --> 00:49:51,560
0,540 570,690 690,960 960,1260 1260,1740
guided you know by these

1499
00:49:51,890 --> 00:49:54,380
0,750 1140,1740 1740,1800 1800,2070 2070,2490
measurements,| because it maybe {the,case}|
|因为可能是这种情况，|

1500
00:49:54,380 --> 00:49:56,150
0,270 270,660 660,1170 1170,1410 1410,1770
that {you,know,some} module that uses
一些使用粗粒度锁的模块不是经常并行调用，

1501
00:49:56,150 --> 00:49:56,990
0,60 60,300 300,480 480,750 750,840
of {} coarse-grained lock is

1502
00:49:56,990 --> 00:49:58,910
0,210 210,420 420,960 1230,1830 1830,1920
just not called {} in

1503
00:49:58,910 --> 00:50:00,680
0,570 570,930 1020,1230 1230,1680 1680,1770
parallel often| and therefore it
|所以，没有必要对它重新设计，

1504
00:50:00,680 --> 00:50:02,060
0,90 90,270 270,960 960,1110 1110,1380
is not necessary to actually

1505
00:50:02,060 --> 00:50:04,040
0,720 1080,1410 1410,1830 1830,1950 1950,1980
redesign,| since redesign there's a
|因为重新设计有很多工作要做，

1506
00:50:04,040 --> 00:50:05,030
0,180 180,240 240,630 660,780 780,990
lot of work,| you know
|这也会使代码的条理变得复杂，

1507
00:50:05,030 --> 00:50:06,290
0,330 330,420 420,630 630,780 780,1260
can, you know it also

1508
00:50:06,440 --> 00:50:08,000
0,210 210,690 690,780 780,1200 1200,1560
can complicate the reasoning about

1509
00:50:08,000 --> 00:50:09,860
0,510 600,1140 1140,1290 1290,1380 1380,1860
code,| {} you know that,
|不重新设计这些是一个更好的选择，

1510
00:50:09,890 --> 00:50:10,550
0,90 90,240 240,450 450,510 510,660
you know it's a good

1511
00:50:10,550 --> 00:50:11,750
0,240 240,480 480,750 750,990 990,1200
idea not actually do that

1512
00:50:11,750 --> 00:50:13,560
0,450 450,660 660,870 870,1440
redesign,| it's not necessary.|
|这不是必须的。|

1513
00:50:14,340 --> 00:50:15,400
0,510

1514
00:50:15,430 --> 00:50:17,290
0,120 120,570 690,1050 1050,1200 1200,1860
And so, {} in general,
所以，一般说来，一条好的规则是，

1515
00:50:17,320 --> 00:50:19,240
0,480 480,600 600,840 840,1470 1470,1920
{} a good rule of

1516
00:50:19,240 --> 00:50:20,350
0,240 240,450 450,660 660,960 960,1110
form is| {you,know} start with
|从粗粒度的锁开始，

1517
00:50:20,350 --> 00:50:22,510
0,300 300,900 990,1500 1500,1680 1680,2160
coarse-grained locks,| measure whether a
|测量这些锁中的一个是否出现争用，

1518
00:50:22,510 --> 00:50:23,710
0,510 510,630 630,930 930,1110 1110,1200
contention that appears one of

1519
00:50:23,710 --> 00:50:25,270
0,150 150,600 600,780 780,1080 1080,1560
these locks| and then redesign
|然后重新设计系统的这一部分，

1520
00:50:25,270 --> 00:50:26,230
0,210 210,420 420,510 510,600 600,960
that part of the system,|
|

1521
00:50:26,230 --> 00:50:27,190
0,180 180,300 300,420 420,570 570,960
so that you get better
你就会得到更好的并行性。

1522
00:50:27,550 --> 00:50:28,980
0,420 420,930
better parallelism.|
|

1523
00:50:30,740 --> 00:50:32,240
0,120 120,270 270,420 420,750 1230,1500
Does that make sense, any
这能理解吗，目前为止有什么问题吗？

1524
00:50:32,240 --> 00:50:33,700
0,390 390,540 540,930
questions so far?|
|

1525
00:50:39,030 --> 00:50:41,490
0,300 300,570 570,750 750,1410 1590,2460
Okay, let's look at {}.|
好的，我们来看一下。|

1526
00:50:42,140 --> 00:50:44,390
0,570 570,1380 1380,1530 1530,2040 2040,2250
Well, let's look at {xv6
好的，让我们看看 xv6 中的一些代码，

1527
00:50:44,390 --> 00:50:45,590
0,390 390,540 540,900 930,1050 1050,1200
-} and you know some

1528
00:50:45,590 --> 00:50:47,840
0,480 600,1320 1410,1980 1980,2040 2040,2250
code| to understand a little
|了解一下，锁在 xv6 中实际是如何工作的。

1529
00:50:47,840 --> 00:50:49,220
0,240 240,600 600,780 780,1200 1200,1380
bit how this locking sort

1530
00:50:49,220 --> 00:50:50,630
0,90 90,360 360,630 630,960 990,1410
of works out in practice

1531
00:50:50,630 --> 00:50:52,040
0,90 90,330 330,480 480,1020
the {xv6 - -}.|
|

1532
00:50:53,650 --> 00:50:54,400
0,180 180,330 330,420 420,630 630,750
And so I'm gonna go
所以，我要回到，

1533
00:50:54,400 --> 00:50:57,820
0,570 690,1110 1110,1830 2370,2790
back to { -},|
|

1534
00:50:58,480 --> 00:50:59,620
0,660
{to,the}
回到这一屏，|

1535
00:51:00,660 --> 00:51:02,730
0,180 180,810 1020,1680 1680,1860 1860,2070
this screen,| I really need
|我需要这个。

1536
00:51:02,730 --> 00:51:03,680
0,450
this.|
|

1537
00:51:03,680 --> 00:51:04,820
0,420 420,510 510,720 720,780 780,1140
And I want to look
我想看看 uart ，

1538
00:51:04,820 --> 00:51:06,590
0,390 390,570 570,870 870,1290 1290,1770
at {uart -},| because we
|因为我们从那里开始讨论锁。

1539
00:51:06,620 --> 00:51:08,270
0,330 330,660 660,900 900,1230 1230,1650
start talking about locking there.|
|

1540
00:51:08,570 --> 00:51:09,880
0,750

1541
00:51:10,240 --> 00:51:11,720
0,960
{On,the},
在周一的时候。

1542
00:51:13,190 --> 00:51:14,120
0,150 150,630 630,780 780,810 810,930
on Monday.| And I want
|我想更详细的看看它。

1543
00:51:14,120 --> 00:51:14,660
0,60 60,180 180,240 240,420 420,540
to look a little bit

1544
00:51:14,660 --> 00:51:15,940
0,180 180,240 240,690
more in detail.|
|

1545
00:51:16,390 --> 00:51:17,560
0,480 480,750 750,900 900,1020 1020,1170
And now that we know
现在我们对锁有了更多的了解，

1546
00:51:17,560 --> 00:51:18,250
0,30 30,180 180,300 300,480 480,690
a little bit more about

1547
00:51:18,250 --> 00:51:20,080
0,330 330,480 480,630 630,930 930,1830
locks| and then also illustrate
|也说明了几个有趣的观点。

1548
00:51:20,080 --> 00:51:21,250
0,30 30,270 270,330 330,690 690,1170
a couple of interesting points.|
|

1549
00:51:22,070 --> 00:51:23,740
0,600

1550
00:51:28,110 --> 00:51:30,150
0,450 450,930 960,1740 1770,1920 1920,2040
So first, {} you know
首先，你想知道，

1551
00:51:30,150 --> 00:51:31,320
0,150 150,390 390,750 750,870 870,1170
it turns out you want

1552
00:51:31,320 --> 00:51:33,480
0,540 870,1170 1200,1410 1410,1740 1740,2160
to know,| what's looking at
|查看锁，

1553
00:51:34,390 --> 00:51:36,310
0,1080 1110,1320 1320,1560 1560,1770 1770,1920
lock,| it turns out that
|UART 只有一个锁，

1554
00:51:36,310 --> 00:51:38,140
0,270 270,840 840,1230 1230,1590 1590,1830
the uart actually has only

1555
00:51:38,140 --> 00:51:39,580
0,270 270,720 930,1200 1200,1320 1320,1440
one lock,| so you can
|你可以认为这是一个可用的粗粒度（锁），

1556
00:51:39,580 --> 00:51:40,600
0,150 150,330 330,540 540,660 660,1020
think about this as a

1557
00:51:40,600 --> 00:51:42,880
0,360 360,1290 1350,1800 1800,2220 2220,2280
reasonable coarse-grained,| {} design at
|在一点上对于 UART 来说。

1558
00:51:42,880 --> 00:51:44,380
0,150 150,450 450,840 1200,1350 1350,1500
this particular point at least

1559
00:51:44,380 --> 00:51:45,540
0,150 150,330 330,660
for {uart -}.|
|

1560
00:51:45,540 --> 00:51:46,800
0,60 60,150 150,540 540,990 1020,1260
And that particular lock, it
这个锁保护 UART 传输缓冲区，

1561
00:51:46,800 --> 00:51:49,830
0,660 690,1440 1440,2010 2010,2490 2490,3030
protects basically uart transmission buffer|
|

1562
00:51:50,190 --> 00:51:53,040
0,870 900,1260 1260,1860 1860,2430 2460,2850
and write pointer and read
以及写指针和读指针。

1563
00:51:53,070 --> 00:51:54,940
0,150 150,480
{} pointer.|
|

1564
00:51:55,150 --> 00:51:56,320
0,150 150,360 360,480 480,1080 1080,1170
So when we transmit,| you
当我们传输的时候，|写指针指向传输缓冲区中的下一个空闲插槽，

1565
00:51:56,320 --> 00:51:58,420
0,150 150,570 600,840 840,1470 1710,2100
know the write pointer points

1566
00:51:58,420 --> 00:51:59,530
0,120 120,210 210,420 420,690 690,1110
to the next free slot

1567
00:51:59,530 --> 00:52:01,510
0,300 300,600 630,1050 1050,1590 1800,1980
in the transmission buffer| and
|而读指针是需要传输的下一个插槽。

1568
00:52:01,510 --> 00:52:03,070
0,180 180,600 600,780 780,1200 1230,1560
the {read,pointer} is the next

1569
00:52:03,070 --> 00:52:03,910
0,150 150,300 300,570 570,750 750,840
slot that actually needs to

1570
00:52:03,910 --> 00:52:05,060
0,90 90,660
be transmitted.|
|

1571
00:52:05,200 --> 00:52:07,060
0,330 330,480 480,600 600,1050 1290,1860
Maybe this is our {}
这就是我们并行的标准设计，

1572
00:52:07,060 --> 00:52:11,060
0,840 870,1800 1920,2610 2640,3450
standard design for parallelism,|
|

1573
00:52:11,060 --> 00:52:12,920
0,300 300,420 420,660 660,1230 1230,1860
or for a consumer, {}
或者是生产者消费者并行性。

1574
00:52:12,950 --> 00:52:14,680
0,270 270,600 600,1140
producer consumer parallelism.|
|

1575
00:52:15,210 --> 00:52:16,260
0,180 180,330 330,510 510,660 660,1050
So let me go back
让我回去，把它拿出来。

1576
00:52:16,260 --> 00:52:18,240
0,300 780,1470
and {}

1577
00:52:18,330 --> 00:52:20,500
0,300 300,450 450,900 1140,1680
brought it out.| So,
|案例研究 UART ，

1578
00:52:20,710 --> 00:52:22,240
0,360 360,990
case study

1579
00:52:24,740 --> 00:52:26,120
0,240 240,1080
{uart -},|
|

1580
00:52:27,340 --> 00:52:29,420
0,270 270,420 420,840 840,1530
and there's basically buffer,|
这是缓冲区，|

1581
00:52:29,870 --> 00:52:30,980
0,300 300,510 510,570 570,720 720,1110
and there's a read pointer,
有一个读指针，一个写指针，

1582
00:52:30,980 --> 00:52:32,870
0,210 210,300 300,540 540,1170 1500,1890
there's a write pointer| or
|或者写索引和读索引。

1583
00:52:32,900 --> 00:52:35,150
0,450 480,840 840,1410 1410,1860 1980,2250
write read index and read

1584
00:52:35,150 --> 00:52:36,280
0,600
index.|
|

1585
00:52:37,110 --> 00:52:38,220
0,210 210,390 390,450 450,630 630,1110
This has to go to
这是连接到用来显示的 UART ，

1586
00:52:38,250 --> 00:52:41,260
0,150 150,720 750,1230 1620,2370
{uart -} being displayed,|
|

1587
00:52:42,820 --> 00:52:44,320
0,330 330,480 480,630 630,840 870,1500
and this is the writer,|
这是写入端，|

1588
00:52:46,740 --> 00:52:48,720
0,270 270,780 1080,1560 1590,1800 1800,1980
{printf -} maybe that actually
可能是 printf ，将字符插入到缓冲区中。

1589
00:52:48,720 --> 00:52:50,730
0,480 510,960 960,1380 1380,1560 1560,2010
sticks characters into this buffer.|
|

1590
00:52:52,490 --> 00:52:53,580
0,600
Okay?|
好的?|

1591
00:52:53,840 --> 00:52:54,980
0,330 330,780 780,870 870,990 990,1140
And so you know we
所以，我们可以看到这个锁有多个作用。

1592
00:52:54,980 --> 00:52:55,640
0,120 120,300 300,420 420,570 570,660
can see is that the

1593
00:52:55,640 --> 00:52:57,740
0,600 630,1230 1260,1410 1410,1710 1710,2100
lock, {} you know lock

1594
00:52:57,740 --> 00:52:59,220
0,120 120,480 480,1020
has multiple roles.|
|

1595
00:53:03,200 --> 00:53:05,330
0,600 600,1050 1050,1380 1380,1830 1830,2130
One is to basically protect
一个是保护这个数据结构，

1596
00:53:05,330 --> 00:53:06,720
0,120 120,360 360,870
this data structure,|
|

1597
00:53:11,640 --> 00:53:12,810
0,300 300,510 510,810 810,930 930,1170
this data structure has some
这个数据结构具有某种不变性，

1598
00:53:12,810 --> 00:53:14,200
0,690
invariance,|

1599
00:53:14,200 --> 00:53:17,890
0,1110 1110,1410 1440,2040 2040,2610 2790,3690
namely, the read {to,[proceed]} write,|
也就是，从读到写，|

1600
00:53:18,250 --> 00:53:20,710
0,960 990,1470 1470,1860 1860,2250 2250,2460
{} anything between {} {R,and}
任何在 R 和 W 之间的字符都是要发送的，

1601
00:53:20,710 --> 00:53:22,390
0,660 660,990 990,1380 1380,1530 1530,1680
W are characters that need

1602
00:53:22,390 --> 00:53:24,160
0,60 60,210 210,690 1050,1470 1470,1770
to be sent,| anything between
|任何在 W 和 R 之间的东西都是空插槽。

1603
00:53:24,160 --> 00:53:25,390
0,360 360,480 480,840 840,990 990,1230
W and R are things

1604
00:53:25,390 --> 00:53:27,100
0,150 150,630 630,960 960,1170 1170,1710
that actually are empty slots.|
|

1605
00:53:27,780 --> 00:53:29,460
0,840 840,930 930,1230 1230,1290 1290,1680
And the locks are basically
这个锁帮助我们维持这个不变量。

1606
00:53:29,460 --> 00:53:31,740
0,600 600,1050 1050,1830 1860,2040 2040,2280
{help,us} {} maintain {} that

1607
00:53:31,740 --> 00:53:32,880
0,630
invariant.|
|

1608
00:53:34,080 --> 00:53:36,940
0,510 540,870 870,1200 1680,2370
So, here are {}
所以，我们回到代码。

1609
00:53:37,170 --> 00:53:38,480
0,270 270,810
code again.|
|

1610
00:53:38,480 --> 00:53:40,400
0,720 780,1470 1500,1740 1740,1830 1830,1920
And let's look at the
让我们看一下 acquire 。

1611
00:53:40,400 --> 00:53:41,780
0,810
acquire.|
|

1612
00:53:41,900 --> 00:53:45,320
0,450 450,1110 1110,1380 2580,3300 3300,3420
So here's uartputc,| and you
这里是 uartputc ，|uartputc 做的第一件事是，

1613
00:53:45,320 --> 00:53:46,370
0,150 150,240 240,480 480,930 930,1050
know the first thing you

1614
00:53:46,370 --> 00:53:47,120
0,90 90,210 210,420 420,540 540,750
know {uartputc -} {[] -}

1615
00:53:47,120 --> 00:53:48,620
0,480 480,990 990,1080 1080,1230 1230,1500
{does,is},| actually you know grab
|获取锁，

1616
00:53:48,620 --> 00:53:49,700
0,90 90,570
the lock,|
|

1617
00:53:49,900 --> 00:53:52,510
0,750 750,1140 1140,1530 1530,2160 2310,2610
{} and then {stick -}
然后插入一个字符，

1618
00:53:52,510 --> 00:53:54,160
0,0 240,930 990,1170 1170,1410 1410,1650
a character,| if there's a
|如果缓冲区中有位置，

1619
00:53:54,160 --> 00:53:55,420
0,360 360,420 420,480 480,960 990,1260
place in the buffer,| sticks
|将字符插入缓冲区，

1620
00:53:55,420 --> 00:53:56,260
0,60 60,330 330,690 690,780 780,840
the [] character in the

1621
00:53:56,260 --> 00:53:58,210
0,570 930,1080 1080,1680 1680,1770 1770,1950
buffer| and start you know
|开始打印，

1622
00:53:58,210 --> 00:54:00,100
0,450 480,900 900,1020 1020,1200 1200,1890
the printing| and then releases
|然后释放锁，

1623
00:54:00,190 --> 00:54:01,620
0,390 390,870
{} the

1624
00:54:01,740 --> 00:54:03,690
0,270 270,720 930,1320 1320,1470 1470,1950
{} lock,| so if two
|所以，如果两个进程同时调用 uartputc ，

1625
00:54:03,690 --> 00:54:05,640
0,720 720,810 810,900 900,1290 1290,1950
processes at the same time

1626
00:54:05,880 --> 00:54:07,620
0,600 600,750 750,900 900,1140 1140,1740
call {uartputc - - -},|
|

1627
00:54:07,740 --> 00:54:09,780
0,630 660,870 870,1110 1110,1260 1260,2040
then there's lock will ensure
那么锁将会确保，

1628
00:54:09,900 --> 00:54:11,490
0,480 510,810 810,1080 1080,1440 1440,1590
that| {you,know} one character from
|第一个进程中的一个字符出现在第一个插槽中，

1629
00:54:11,490 --> 00:54:12,420
0,60 60,300 300,660 660,840 840,930
the first process goes in

1630
00:54:12,420 --> 00:54:14,010
0,60 60,300 300,720 750,1110 1110,1590
the first slot| and then
|然后第二个进程的字符进入下一个插槽，

1631
00:54:14,100 --> 00:54:16,770
0,630 1470,1770 1770,2370 2370,2550 2550,2670
the second character of the

1632
00:54:16,770 --> 00:54:18,150
0,240 240,840 840,1170 1170,1290 1290,1380
second process goes into the

1633
00:54:18,150 --> 00:54:19,560
0,210 210,570 630,930 930,1110 1110,1410
next slot| and they're no
|它们不会最终进入同一个插槽。

1634
00:54:19,560 --> 00:54:20,700
0,120 150,510 510,660 660,960 960,1140
as happened to end up

1635
00:54:20,700 --> 00:54:22,160
0,420 420,510 510,750 750,1140
in the same slot,

1636
00:54:22,680 --> 00:54:23,550
0,240 240,330 330,510 510,630 630,870
right.| So this is a
|所以这是一个明显的例子，

1637
00:54:23,550 --> 00:54:24,960
0,270 270,720 720,930 930,990 990,1410
clear example| where {} lock
|锁可以帮助我们避免竞态条件，

1638
00:54:25,110 --> 00:54:27,360
0,300 300,600 600,780 780,1260 1560,2250
it helps us to {

1639
00:54:27,780 --> 00:54:28,620
0,630
-}

1640
00:54:29,430 --> 00:54:31,500
0,480 480,540 540,720 720,1260 1320,2070
avoids a race condition,| because
|否则，第二个进程可能会

1641
00:54:31,500 --> 00:54:33,280
0,510 510,600 600,750 750,1110
otherwise you know the,

1642
00:54:33,280 --> 00:54:35,020
0,150 150,480 480,870 870,1080 1080,1740
the second process might| overwrite
|覆盖第一个进程的字符，

1643
00:54:35,020 --> 00:54:36,280
0,450 450,540 540,630 630,780 780,1260
{} you know the first

1644
00:54:36,310 --> 00:54:37,940
0,600 600,1080
process's character,|
|

1645
00:54:38,740 --> 00:54:40,750
0,330 330,540 540,960 1410,1800 1800,2010
that's one part.| Then we
这是一部分。|然后，我们看看。

1646
00:54:40,750 --> 00:54:42,740
0,120 120,360 360,600 630,1440
go look at {}.|
|

1647
00:54:42,960 --> 00:54:43,500
0,150 150,270 270,390 390,510 510,540
And we did that a
我们之前看过一点，

1648
00:54:43,500 --> 00:54:44,340
0,150 150,300 300,630 630,720 720,840
little bit before,| we look
|我们查看 start ，

1649
00:54:44,340 --> 00:54:45,510
0,60 60,630 660,990 990,1110 1110,1170
at start,| we see a
|我们看到有更多的事情。

1650
00:54:45,510 --> 00:54:46,740
0,210 210,390 390,630 630,840 840,1230
couple more things going on.|
|

1651
00:54:47,360 --> 00:54:48,640
0,720

1652
00:54:48,640 --> 00:54:50,140
0,360 360,960
The, {}
这个，我们看到，

1653
00:54:50,140 --> 00:54:51,460
0,300 300,540 540,690 690,1050 1050,1320
{} we see actually that

1654
00:54:51,460 --> 00:54:52,580
0,540
the,|
|

1655
00:54:53,220 --> 00:54:54,960
0,480 480,630 630,1200 1200,1290 1290,1740
{} if buffer is not
如果缓冲区不是，

1656
00:54:54,960 --> 00:54:57,460
0,210 210,870 1260,1890
you know, {}|
|

1657
00:54:57,460 --> 00:54:58,210
0,90 90,180 180,420 420,510 510,750
if the buffer is not
如果缓冲器不为空，

1658
00:54:58,210 --> 00:55:00,610
0,540 870,1680 1680,1800 1800,2190 2190,2400
empty,| then we know that
|那么我们知道有一些字符，

1659
00:55:00,610 --> 00:55:02,530
0,510 510,720 720,750 750,990 990,1920
basically there's a bunch of

1660
00:55:02,560 --> 00:55:04,330
0,510 510,660 660,720 720,1050 1050,1770
characters,| that are being progressed
|正在进行或正在发送。

1661
00:55:04,630 --> 00:55:06,360
0,450 450,690 690,1170
or being sent.|
|

1662
00:55:06,450 --> 00:55:07,800
0,570 570,720 720,840 840,960 960,1350
And you know the lock
你知道锁可以确保，

1663
00:55:07,800 --> 00:55:08,580
0,90 90,180 180,360 360,660 660,780
you know make sure that|
|

1664
00:55:08,580 --> 00:55:10,560
0,120 120,300 300,810 1170,1770 1770,1980
we don't really overwrite any
我们不会覆盖其中的任何一个，

1665
00:55:10,560 --> 00:55:12,510
0,90 90,600 810,1230 1440,1770 1770,1950
of those,| so anything that's
|所以任何队列尾端的东西，

1666
00:55:12,510 --> 00:55:14,430
0,120 120,300 300,600 1050,1620 1620,1920
sort of the tailend of

1667
00:55:14,430 --> 00:55:16,890
0,390 420,960 960,1200 1200,1950 1950,2460
the queue,| {} is actually
|是由 UART 本身处理的。

1668
00:55:16,890 --> 00:55:18,540
0,210 210,450 450,1050 1050,1500 1500,1650
{} being processed by the

1669
00:55:18,540 --> 00:55:20,300
0,570 870,1500
uart {}

1670
00:55:21,120 --> 00:55:23,500
0,660 810,1470 1500,1860
{} itself.| So,
|所以，尾端正在处理。

1671
00:55:23,560 --> 00:55:24,960
0,240 240,720
{tailend -}

1672
00:55:26,410 --> 00:55:28,000
0,270 270,510 510,1050
is in flight.|
|

1673
00:55:30,370 --> 00:55:31,510
0,180 180,600 600,780 780,1020 1020,1140
And we make sure that|
我们确保，|

1674
00:55:31,510 --> 00:55:33,850
0,90 90,510 510,990 1260,2040 2040,2340
we basically don't modify or
通过获取锁，我们不会在这个方面修改或干扰。

1675
00:55:33,970 --> 00:55:35,470
0,540 540,630 630,810 810,1140 1140,1500
interfere with that particular aspect

1676
00:55:35,470 --> 00:55:37,640
0,390 420,1110 1110,1200 1200,1620
by grabbing a lock.|
|

1677
00:55:38,060 --> 00:55:39,860
0,210 210,330 330,900 1380,1650 1650,1800
And then finally, {} they're
最后，更多的事情是，

1678
00:55:39,860 --> 00:55:40,910
0,150 150,210 210,390 390,480 480,1050
sort of more and more

1679
00:55:41,000 --> 00:55:43,040
0,390 390,570 570,930 1140,1440 1440,2040
thing is that| the writes
|对 UART 寄存器的写入，

1680
00:55:43,400 --> 00:55:46,010
0,1050 1050,1590 1590,2370 2400,2550 2550,2610
{} to registers of the

1681
00:55:46,010 --> 00:55:47,720
0,510 510,660 660,870 870,1350 1350,1710
uart| like that THR register,|
|比如 THR 寄存器，|

1682
00:55:47,720 --> 00:55:49,160
0,330 330,510 510,720 720,900 900,1440
which one, there's only one
这里只有一个锁确保，

1683
00:55:49,460 --> 00:55:50,480
0,120 120,210 210,570 570,690 690,1020
you know basically the lock

1684
00:55:50,480 --> 00:55:52,610
0,750 870,1230 1350,1710 1710,1800 1800,2130
ensures,| {} remember the {uartstart
|记得 uartstart 在持有锁的情况下调用，

1685
00:55:52,610 --> 00:55:54,230
0,240 240,390 390,750 750,930 930,1620
-} just called with lock

1686
00:55:54,260 --> 00:55:56,660
0,510 840,1650 1650,1830 1830,2190 2190,2400
held,| assures this is only
|确保只有一个写入者到 THR 寄存器。

1687
00:55:56,660 --> 00:55:58,250
0,360 360,990 990,1110 1110,1200 1200,1590
one writer to the THR

1688
00:55:58,250 --> 00:55:59,300
0,630
register.|
|

1689
00:55:59,870 --> 00:56:01,550
0,240 240,660 870,1440 1440,1620 1620,1680
And so another {in,sort} of
所以，另一方面锁确保的是，

1690
00:56:01,550 --> 00:56:03,320
0,570 570,690 690,960 960,1350 1350,1770
variant or another aspect that

1691
00:56:03,320 --> 00:56:05,390
0,120 120,540 540,1200 1230,1860 1860,2070
the locking {} enforces is|
|

1692
00:56:05,390 --> 00:56:07,640
0,390 480,990 990,1680
that hardware registers
硬件寄存器有一个写入者。

1693
00:56:10,510 --> 00:56:12,040
0,240 240,480 480,990
have one writer.|
|

1694
00:56:16,460 --> 00:56:17,600
0,630
Okay?|
好的?|

1695
00:56:18,530 --> 00:56:19,940
0,360 360,510 510,720 720,1020 1020,1410
{You,know}, there's one other interesting
还有一件有趣的事，

1696
00:56:19,940 --> 00:56:21,410
0,210 210,390 390,540 540,720 720,1470
thing,| that I want to
|我想稍微谈一下，

1697
00:56:21,440 --> 00:56:22,730
0,330 330,420 420,690 690,810 810,1290
talk a little bit about,|
|

1698
00:56:23,120 --> 00:56:25,160
0,360 360,630 630,1050 1080,1740 1890,2040
and that is {} you
那就是 UART 硬件完成后，

1699
00:56:25,160 --> 00:56:26,480
0,180 180,780 810,1050 1050,1140 1140,1320
know the {uart -} is

1700
00:56:26,480 --> 00:56:27,470
0,270 270,540 540,750 750,870 870,990
done correct, {hardware -} is

1701
00:56:27,470 --> 00:56:28,940
0,300 300,750 990,1230 1230,1380 1380,1470
done,| then {} there was
|会有一个中断。

1702
00:56:28,940 --> 00:56:30,000
0,60 60,630
an interrupt.|
|

1703
00:56:30,170 --> 00:56:32,600
0,840 960,1740 1740,1980 1980,2100 2100,2430
And, {} as you know,|
如你所知，|

1704
00:56:32,600 --> 00:56:34,070
0,180 180,450 450,780 780,1020 1020,1470
we notice before {uartstart -}
我们注意到在 uartstart 之前，

1705
00:56:34,070 --> 00:56:35,210
0,300 300,390 390,570 570,720 720,1140
right,| you know we have
|我们有调用者，

1706
00:56:36,290 --> 00:56:38,030
0,390 390,960 960,1320 1320,1410 1410,1740
the caller,| it's a caller
|它是获取锁的调用者，

1707
00:56:38,030 --> 00:56:39,380
0,90 90,540 540,600 600,1050 1110,1350
to acquire the lock,| to
|来确保，

1708
00:56:39,380 --> 00:56:42,440
0,780 960,1530 1530,2310 2520,2910 2910,3060
ensure {} that,| {} we
|我们不会有多个[]写入写寄存器。

1709
00:56:42,440 --> 00:56:45,080
0,180 180,870 1440,2190 2190,2520 2520,2640
don't multiple [] writing to

1710
00:56:45,080 --> 00:56:46,280
0,60 60,300 300,750
the write register.|
|

1711
00:56:46,620 --> 00:56:49,260
0,510 720,1020 1020,1440 1710,2190 2220,2640
{} And so {} uart
UART 中断本身可以

1712
00:56:49,260 --> 00:56:51,960
0,360 360,1020 1350,1560 1560,2310 2520,2700
interrupt itself could| run in
|与调用 printf 的其他进程并行运行，

1713
00:56:51,960 --> 00:56:54,150
0,930 960,1350 1350,1650 1650,2040 2040,2190
parallel with another process that's

1714
00:56:54,150 --> 00:56:55,230
0,210 210,390 390,630 630,870 870,1080
called {printf -},| so there's
|所以，有一些实际的 printf 运行在 CPU0 上，

1715
00:56:55,230 --> 00:56:57,030
0,180 180,600 600,840 840,1140 1500,1800
some practical {printf -} {}

1716
00:56:57,030 --> 00:56:58,500
0,210 210,330 330,420 420,810 810,1470
that runs on {CPU0 -},|
|

1717
00:56:58,560 --> 00:57:00,120
0,360 360,540 540,900 900,1260 1260,1560
and on {CPU1 -} actually
而在 CPU1 上接受 UART 中断，

1718
00:57:00,120 --> 00:57:02,010
0,360 360,450 450,780 780,1380 1410,1890
takes the uart interrupt,| because
|因为它什么都没做，

1719
00:57:02,010 --> 00:57:03,030
0,240 240,360 360,540 540,900 900,1020
maybe it's doing nothing,| and
|所以，它可以在任何时间点中断。

1720
00:57:03,030 --> 00:57:04,050
0,90 90,210 210,420 420,690 690,1020
so it's ready to interrupt

1721
00:57:04,050 --> 00:57:05,250
0,180 180,480 480,660 660,720 720,1200
any particular point of time.|
|

1722
00:57:05,720 --> 00:57:07,310
0,420 420,660 660,1200 1230,1290 1320,1590
And it will { -}
它将会调用 uartstart 。

1723
00:57:07,310 --> 00:57:08,900
0,270 270,600 600,1050
call {uartstart -}.|
|

1724
00:57:09,080 --> 00:57:09,800
0,150 150,240 240,540 540,600 600,720
And it has to be
它必须是这种情况，

1725
00:57:09,800 --> 00:57:10,850
0,60 60,420 420,810 810,900 900,1050
the case correct,| you know
|我们希望确保硬件寄存器中只有一个写入者，

1726
00:57:10,850 --> 00:57:11,720
0,150 150,300 300,360 360,720 720,870
we want to ensure that

1727
00:57:11,720 --> 00:57:12,980
0,150 150,210 210,540 540,960 960,1260
there's a single writer into

1728
00:57:12,980 --> 00:57:15,200
0,150 150,450 450,1050 1290,1800 1800,2220
the hardware registers| {} or
|或者保护传输缓冲区的不变性，

1729
00:57:15,200 --> 00:57:16,460
0,120 120,600 600,660 660,810 810,1260
to protect you know the

1730
00:57:16,910 --> 00:57:18,680
0,570 570,840 840,990 990,1320 1350,1770
invariance actually of the transmission

1731
00:57:18,680 --> 00:57:20,360
0,420 780,1350 1350,1470 1470,1560 1560,1680
buffer,| {} you know we
|我们必须获取锁。

1732
00:57:20,360 --> 00:57:21,780
0,270 270,630 630,660 660,1020
{have,to} acquire a lock.|
|

1733
00:57:21,810 --> 00:57:22,440
0,150 150,240 240,390 390,510 510,630
And so it is the
所以，在 xv6 中，

1734
00:57:22,440 --> 00:57:24,480
0,540 540,930 930,1410 1410,1740 1740,2040
case that in {xv6 -},|
|

1735
00:57:24,480 --> 00:57:26,730
0,360 360,690 900,1680 1680,1950 1950,2250
actually that interrupts {you,know} can
中断可以运行驱动的下半部，

1736
00:57:26,730 --> 00:57:28,560
0,720 1020,1140 1140,1410 1410,1710 1710,1830
run the bottom half of

1737
00:57:28,560 --> 00:57:30,210
0,90 90,570 570,690 690,1050 1080,1650
the driver| can run truly
|可以在不同的处理器上真正的同时运行，

1738
00:57:30,210 --> 00:57:33,000
0,600 600,960 960,1320 1320,2100 2400,2790
concurrent on {} on different

1739
00:57:33,000 --> 00:57:34,800
0,600 630,1050 1050,1140 1140,1440 1440,1800
processors| with the top half
|和驱动的上半部一起，

1740
00:57:34,800 --> 00:57:36,360
0,210 210,510 510,990 1200,1470 1470,1560
of the driver| and so
|所以，中断函数也需要锁。

1741
00:57:36,360 --> 00:57:39,360
0,420 420,1590 1590,2130 2400,2760 2760,3000
therefore interrupt functions {} also

1742
00:57:39,360 --> 00:57:40,520
0,390 390,780
require locks.|
|

1743
00:57:40,930 --> 00:57:41,890
0,210 210,450 450,510 510,630 630,960
In fact, in this particular
实际上，在这种情况下，

1744
00:57:41,890 --> 00:57:43,990
0,540 690,1200 1200,1290 1290,1500 1770,2100
case,| {} you know requires
|需要在 UART 中的锁，

1745
00:57:43,990 --> 00:57:44,830
0,60 60,270 270,540 540,660 660,840
the one lock that there's

1746
00:57:44,830 --> 00:57:46,720
0,300 300,420 420,480 480,990 1020,1890
actually in the uart| and
|然后调用 uartstart ，

1747
00:57:46,750 --> 00:57:47,770
0,150 150,330 330,480 480,510 510,1020
then calls {uartstart - -}|
|

1748
00:57:47,770 --> 00:57:48,940
0,90 90,360 360,750 750,840 840,1170
and then releases the lock.|
然后释放锁。|

1749
00:57:50,720 --> 00:57:51,800
0,240 240,540 540,690 690,930 930,1080
And I'll come back to
稍后，我会回到这里，

1750
00:57:51,800 --> 00:57:53,060
0,180 180,300 300,300 300,840 870,1260
that in a second,| because
|因为实现锁比较困难，

1751
00:57:53,060 --> 00:57:53,840
0,150 150,210 210,360 360,480 480,780
there's a little bit {trickiness

1752
00:57:53,840 --> 00:57:56,660
0,450 660,1560 1560,2220 2250,2730 2730,2820
-} {} in implementing a

1753
00:57:56,660 --> 00:57:58,190
0,450 690,810 810,1080 1080,1170 1170,1530
lock,| in such a way
|在这种方式下，这是正确的。

1754
00:57:58,190 --> 00:57:59,210
0,180 180,330 330,600 600,870 870,1020
that this actually works out

1755
00:57:59,210 --> 00:58:00,220
0,480
correctly.|
|

1756
00:58:00,490 --> 00:58:01,920
0,870
And,
你应该担心的事情是，

1757
00:58:01,920 --> 00:58:03,750
0,150 150,630 1080,1380 1380,1530 1530,1830
and the thing that actually

1758
00:58:03,750 --> 00:58:04,650
0,90 90,240 240,330 330,570 570,900
you should be worried about

1759
00:58:04,650 --> 00:58:07,140
0,180 180,630 930,2040 2040,2280 2280,2490
is that,| {} I'll actually
|稍后我会讲一下，

1760
00:58:07,140 --> 00:58:07,980
0,210 210,390 390,480 480,540 540,840
talk about in a second,|
|

1761
00:58:08,010 --> 00:58:09,090
0,240 240,360 360,720 720,900 900,1080
let me postpone that until
等到了那里我再讲。

1762
00:58:09,090 --> 00:58:10,020
0,60 60,240 240,420
I get there.|
|

1763
00:58:13,040 --> 00:58:14,990
0,210 210,480 480,1050 1050,1290 1440,1950
Okay, so any any questions
好的，关于这个，有什么问题，

1764
00:58:14,990 --> 00:58:16,880
0,270 270,450 450,690 690,1170 1470,1890
about this,| {} {sort,of} simple
|一个简单的使用锁和 UART 的例子。

1765
00:58:16,880 --> 00:58:20,360
0,690 690,1050 1290,2280 2280,2880 3000,3480
example of lock use and

1766
00:58:20,360 --> 00:58:21,520
0,120 120,630
{uart -}.|
|

1767
00:58:29,640 --> 00:58:31,740
0,390 390,570 570,1230 1710,2010 2010,2100
Okay, let me that thing
好的，让我来讲一下，

1768
00:58:31,740 --> 00:58:32,790
0,150 150,270 270,480 480,660 660,1050
kind of {},| let me
让我来讲一下实现锁。

1769
00:58:32,790 --> 00:58:34,140
0,210 210,390 390,840 840,900 900,1350
talk about implementing a lock.|
|

1770
00:58:34,940 --> 00:58:37,160
0,600 1200,1470 1470,1890 1890,2010 2010,2220
{} So {the,spec} is that
所以，规范是只有一个进程可以获取锁，

1771
00:58:37,160 --> 00:58:40,640
0,270 270,990 1200,2400 2520,2940 2940,3480
only one process can acquire

1772
00:58:40,640 --> 00:58:43,010
0,480 600,1170 1170,1380 1380,1890 1920,2370
lock,| there's no more than
|在任何时间点锁持有者都不会超过一个。

1773
00:58:43,010 --> 00:58:44,120
0,300 300,570 570,810 810,930 930,1110
one lock holder at any

1774
00:58:44,120 --> 00:58:45,640
0,240 240,450 450,510 510,990
given point of time.|
|

1775
00:58:45,640 --> 00:58:47,410
0,510 510,1140 1140,1320 1320,1380 1380,1770
And we want to look
我们想要了解，

1776
00:58:47,440 --> 00:58:48,940
0,390 390,900 900,1140 1140,1410 1410,1500
and understand| actually how you
|如何实现锁，

1777
00:58:48,940 --> 00:58:49,840
0,360 360,390 390,630 630,720 720,900
implement a lock| in such
|以保证规范的方式。

1778
00:58:49,840 --> 00:58:50,740
0,90 90,240 240,540 540,840 840,900
a way that actually is

1779
00:58:50,740 --> 00:58:51,900
0,660
guaranteed.|
|

1780
00:58:51,930 --> 00:58:52,800
0,330 330,420 420,660 660,840 840,870
Let me first write a
我会先写一个错误的锁，

1781
00:58:52,800 --> 00:58:54,160
0,360 360,810
broken lock,|
|

1782
00:58:54,440 --> 00:58:56,120
0,480 480,720 720,870 870,1530 1560,1680
{} so we understand you
让我们理解这里的挑战是什么，

1783
00:58:56,120 --> 00:58:58,160
0,90 90,300 300,480 480,1260 1350,2040
know what the {challenge,is} {}|
|

1784
00:58:59,020 --> 00:59:00,800
0,300 300,600 600,1260
or broken acquire.|
或者错误的 acquire 。|

1785
00:59:05,310 --> 00:59:06,060
0,210 210,360 360,450 450,600 600,750
So that we know what
这样，我们知道挑战是如何实现 acquire 。

1786
00:59:06,060 --> 00:59:07,200
0,120 120,510 510,720 720,1050 1050,1140
the challenge is actually an

1787
00:59:07,200 --> 00:59:08,640
0,390 390,960
implement acquire.|
|

1788
00:59:09,610 --> 00:59:11,440
0,510 810,990 990,1230 1230,1470 1470,1830
{} So here's my broken
这是我的错误的那个，

1789
00:59:11,440 --> 00:59:13,560
0,450 540,1200
one,| {}
|acquire struct lock *l ，

1790
00:59:14,320 --> 00:59:16,580
0,180 180,960 960,1560
so, struct []

1791
00:59:16,900 --> 00:59:20,120
0,630 630,1560 1590,2070 2070,2580
acquires lock {*l -},|
|

1792
00:59:20,250 --> 00:59:21,880
0,840

1793
00:59:21,970 --> 00:59:22,840
0,150 150,300 300,480 480,540 540,870
you know what it does
它所做是，

1794
00:59:22,840 --> 00:59:24,070
0,180 180,300 300,840 840,960 960,1230
is| it follows, it has
|在它后面，有一个无限循环 while(1) ，

1795
00:59:24,070 --> 00:59:25,720
0,120 120,570 570,1140
an infinite loop

1796
00:59:26,170 --> 00:59:27,960
0,600 600,1230
{while(1) -},|
|

1797
00:59:28,980 --> 00:59:30,880
0,420 420,630 630,1260
{} {you,know} if
如果 l->locked 是零，表示没有人持有它。

1798
00:59:31,260 --> 00:59:33,560
0,900 930,1770
{} l

1799
00:59:33,560 --> 00:59:36,440
0,630 840,1380 1380,1830 1830,2370 2430,2880
is locked {is,zero} mean nobody

1800
00:59:36,440 --> 00:59:37,780
0,390 390,750
holding it.|
|

1801
00:59:37,900 --> 00:59:39,280
0,450 450,810 810,870 870,1140 1140,1380
Then, presumably the {caller -}
然后，调用者应该获取锁，

1802
00:59:39,280 --> 00:59:40,510
0,240 240,360 360,690 690,750 750,1230
{should -} grabbed the lock,|
|

1803
00:59:40,690 --> 00:59:41,640
0,390
so,
那么，我们把 l->locked 设为 1 ，

1804
00:59:42,700 --> 00:59:44,410
0,570 570,690 690,1140 1140,1530 1530,1710
then we {set,l->locked -} to

1805
00:59:44,410 --> 00:59:45,660
0,630
one,|
|

1806
00:59:48,320 --> 00:59:49,550
0,690 690,840 840,1020 1020,1110 1110,1230
and you know at that
在这个时刻我们拿到了锁，

1807
00:59:49,550 --> 00:59:50,360
0,210 210,300 300,480 480,540 540,810
point we got the lock,|
|

1808
00:59:50,360 --> 00:59:52,070
0,150 150,270 270,390 390,1020 1410,1710
so we can return,| nothing
我们可以返回，|什么事情都不用做，

1809
00:59:52,070 --> 00:59:53,560
0,90 90,240 240,810
to do anymore,|
|

1810
00:59:53,590 --> 00:59:55,330
0,420 780,1110 1110,1500 1500,1650 1650,1740
and close loop.| If we
并结束循环。|如果我们没拿到锁，

1811
00:59:55,330 --> 00:59:56,380
0,240 240,360 360,450 450,750 750,1050
didn't get the lock,| because
|因为 locked 是 1 ，

1812
00:59:56,380 --> 00:59:57,250
0,150 150,420 420,510 510,750 750,870
the locked was one,| it
|这意味着有其他人持有锁，

1813
00:59:57,250 --> 00:59:58,240
0,180 180,450 450,660 660,720 720,990
means somebody else is holding

1814
00:59:58,240 --> 00:59:59,050
0,240 240,360 360,480 480,630 630,810
lock,| so we just keep
|我们只需要继续旋转，

1815
00:59:59,050 --> 01:00:00,040
0,360
spinning,|
|

1816
01:00:01,080 --> 01:00:02,250
0,630 630,690 690,900 900,1110 1110,1170
waiting to go around the
等待一遍又一遍地循环，

1817
01:00:02,250 --> 01:00:03,210
0,240 240,540 540,630 630,870 870,960
loop over and over and

1818
01:00:03,210 --> 01:00:04,650
0,510 780,990 990,1170 1170,1290 1290,1440
over| until {} at some
|直到在某一时刻，锁持有者调用 release ，

1819
01:00:04,650 --> 01:00:06,540
0,480 480,540 540,660 660,1290
point you know the

1820
01:00:06,540 --> 01:00:07,830
0,150 150,420 420,630 630,960 960,1290
{} holder, lock holder called

1821
01:00:07,830 --> 01:00:09,180
0,480 480,720 720,840 840,1080 1080,1350
release,| which will set lock
|它会将 locked 设置为零。

1822
01:00:09,180 --> 01:00:11,100
0,300 300,510 780,1620 1620,1740 1740,1920
to, { -} will set

1823
01:00:11,100 --> 01:00:12,300
0,240 240,690
{lock,to} zero.|
|

1824
01:00:14,740 --> 01:00:17,140
0,540 540,690 690,1140 1680,1950 1950,2400
And you know what's wrong
那么这个实现的问题是什么？

1825
01:00:17,140 --> 01:00:19,100
0,150 150,330 330,660 660,1380
with this particular implementation?|
|

1826
01:00:20,870 --> 01:00:23,390
0,150 150,660 750,1470 1530,2100 2100,2520
I think two processes may
我想两个进程可能同时读到它没有被锁。

1827
01:00:23,390 --> 01:00:25,370
0,360 360,510 510,810 810,1470 1470,1980
read that it's not locked

1828
01:00:25,760 --> 01:00:27,200
0,180 180,270 270,510 510,930
at the same time.|
|

1829
01:00:27,260 --> 01:00:29,260
0,1260
{Yeah,right}.|
是的，没错。|

1830
01:00:30,040 --> 01:00:31,180
0,210 210,540 540,600 600,780 780,1140
So there's a race condition
所以，这里有一个竞态条件，

1831
01:00:31,180 --> 01:00:33,520
0,540 570,1710
here| and
|竞态条件在这里。

1832
01:00:33,520 --> 01:00:34,840
0,150 150,360 360,630 660,900 900,1320
{} just to make sure

1833
01:00:34,840 --> 01:00:36,700
0,90 90,480 480,810 810,1320
the races right here.|
|

1834
01:00:39,020 --> 01:00:40,730
0,330 330,570 570,690 690,1260 1290,1710
{} We can have basically
我们可以有两个 CPU 进来。

1835
01:00:40,730 --> 01:00:42,170
0,180 180,390 390,720 720,1020 1020,1440
two {CPUs -} coming in.|
|

1836
01:00:42,230 --> 01:00:43,340
0,120 120,240 240,510 510,810 810,1110
You know we talk time
我们看这个时序图，

1837
01:00:43,340 --> 01:00:44,580
0,720
diagram,|
|

1838
01:00:44,700 --> 01:00:47,370
0,510 510,600 600,1260 2190,2490 2490,2670
{you,know} {CPU1 -}, {CPU0 -
你知道 CPU1 ， CPU0 ， CPU1 ，

1839
01:00:47,400 --> 01:00:49,700
0,720 720,930 930,1050 1050,1680
-}, {CPU1 - -},|
|

1840
01:00:50,600 --> 01:00:52,220
0,150 150,450 480,750 750,1170 1170,1620
you know this statement A,|
这是语句 A，|

1841
01:00:52,550 --> 01:00:54,500
0,300 300,510 510,870 870,1350
maybe this statement B,|
这是语句 B ，|

1842
01:00:54,500 --> 01:00:56,930
0,840 870,1320 1320,1890 1920,2070 2070,2430
both {CPU1 -} you know
CPU1 到达语句 A ，

1843
01:00:57,500 --> 01:01:00,500
0,300 300,720 720,1140 1200,2310 2670,3000
reach statement A,| {} {CPU0
|CPU0 和 CPU1 都到达语句 A ，

1844
01:01:00,500 --> 01:01:02,700
0,270 270,450 450,840 840,1650
-} and CPU the

1845
01:01:02,950 --> 01:01:04,840
0,600 1020,1350 1350,1560 1560,1800 1800,1890
{} zero one both {reach

1846
01:01:04,840 --> 01:01:05,800
0,150 150,480 480,690 690,840 840,960
-} statement A,| so they
|所以，它们都看到 locked 是零，

1847
01:01:05,800 --> 01:01:08,500
0,420 420,960 1290,1980 1980,2520 2520,2700
both see {} locked being

1848
01:01:08,500 --> 01:01:10,240
0,630 870,990 990,1320 1320,1500 1500,1740
zero| and then they're both
|然后，它们都执行了 B 。

1849
01:01:10,240 --> 01:01:11,480
0,360 360,690
execute B.|
|

1850
01:01:13,470 --> 01:01:14,610
0,270 270,450 450,690 690,840 840,1140
Alright, so here they see
好的，这里它们看到 locked 是 0 ，

1851
01:01:14,610 --> 01:01:16,200
0,330 330,1110
locked zero,|
|

1852
01:01:17,020 --> 01:01:18,910
0,210 210,450 450,720 720,1020 1020,1890
this guy see locked zero.|
这个也看到的是 locked 是 0 。|

1853
01:01:20,760 --> 01:01:21,960
0,150 150,360 360,510 510,750 750,1200
And so they both executes
所以，它们都执行语句 B ，

1854
01:01:21,960 --> 01:01:23,490
0,210 210,570 570,960 960,1530 1530,1530
{} statement B,| both {}
|它们都获得了锁，

1855
01:01:23,490 --> 01:01:26,880
0,1170 1200,1800 1800,2310 2580,3210 3210,3390
have acquired lock| and {}
|那么这个函数违反了规范。

1856
01:01:26,880 --> 01:01:29,280
0,330 330,1200 1470,1560 1560,2010 2040,2400
which violated the spec, {you,know}

1857
01:01:29,280 --> 01:01:30,680
0,150 150,480 480,870
this particular function.|
|

1858
01:01:31,670 --> 01:01:32,880
0,120 120,300 300,600
This makes sense?|
这能理解吗？|

1859
01:01:35,740 --> 01:01:36,640
0,180 180,240 240,450 450,780 780,900
So it turns out you
所以，要解决这个问题，

1860
01:01:36,640 --> 01:01:38,740
0,90 90,600 990,1380 1380,1530 1530,2100
know to solve this problem|
|

1861
01:01:38,800 --> 01:01:39,340
0,150 150,330 330,390 390,510 510,540
and sort of get a
并得到一个正确的实现，

1862
01:01:39,340 --> 01:01:40,780
0,360 360,960 960,1050 1050,1080 1080,1440
correct implementation,| there are multiple
|有多种方式可以做到，

1863
01:01:40,780 --> 01:01:41,680
0,150 150,210 210,390 390,690 690,900
ways of going about it,|
|

1864
01:01:41,980 --> 01:01:44,110
0,660 660,750 750,1380 1380,1740 1740,2130
but the most common ways
但最常见的方式是依靠特殊的硬件指令。

1865
01:01:44,110 --> 01:01:45,610
0,120 120,780 780,1260 1260,1440 1440,1500
to rely basically on a

1866
01:01:45,610 --> 01:01:47,240
0,330 330,600 600,1110
special hardware instruction.|
|

1867
01:01:47,620 --> 01:01:49,420
0,570 570,810 810,1050 1050,1560 1560,1800
{} And hardware instruction that
这条硬件指令所做的就是，

1868
01:01:49,420 --> 01:01:51,040
0,390 390,570 570,660 660,1170 1440,1620
basically what it does,| it
|它做这个测试，并原子的设置。

1869
01:01:51,040 --> 01:01:52,690
0,240 240,510 510,1050 1290,1500 1500,1650
does this test and then

1870
01:01:52,690 --> 01:01:54,360
0,390 420,900 900,1140
set {atomically -}.|
|

1871
01:01:54,720 --> 01:01:56,020
0,720

1872
01:01:56,050 --> 01:01:58,300
0,180 180,720 840,1440 1680,2160 2160,2250
And so {} solution to
所以，解决这个问题的方法是

1873
01:01:58,300 --> 01:01:59,400
0,450
this

1874
01:01:59,820 --> 01:02:02,060
0,600 630,1020 1020,1650
{} problem is|
|

1875
01:02:03,140 --> 01:02:04,800
0,270 270,1050
{} hardware
硬件的 testandset 支持。

1876
01:02:06,360 --> 01:02:07,680
0,720
{testandset

1877
01:02:08,000 --> 01:02:09,680
0,360 360,600 600,1140
- -} support.|
|

1878
01:02:16,680 --> 01:02:18,120
0,660 660,960 960,1110 1110,1260 1260,1440
{} And the way {you,can}
你可以这样想，

1879
01:02:18,120 --> 01:02:18,930
0,150 150,390 390,570 570,660 660,810
think about it,| you know
|在 RISC-V 上，

1880
01:02:18,930 --> 01:02:20,880
0,270 270,1080 1170,1410 1410,1830 1860,1950
on the {RISC-V -},| you
|这条指令是 amoswap ，

1881
01:02:20,880 --> 01:02:22,440
0,90 90,270 270,720 720,1140 1260,1560
know this instruction actually there's

1882
01:02:22,440 --> 01:02:24,960
0,270 330,870 870,1230 1230,1830 1830,2520
the {amoswap - - -},|
|

1883
01:02:26,680 --> 01:02:27,460
0,210 210,360 360,480 480,660 660,780
{} that would gonna be
是我们会用到的。

1884
01:02:27,460 --> 01:02:28,620
0,510
using.|
|

1885
01:02:28,740 --> 01:02:31,170
0,720 780,1800 1800,2070 2070,2250 2250,2430
And basically boils down to
基本上可以归结为测试和设置，

1886
01:02:31,170 --> 01:02:33,000
0,360 360,540 540,930 960,1770 1770,1830
test and set,| basically the
|硬件保证，

1887
01:02:33,000 --> 01:02:34,950
0,300 300,420 420,1170 1410,1590 1590,1950
{hardware -} guarantees,| you will
|你使用这三个参数，

1888
01:02:34,980 --> 01:02:36,990
0,450 450,660 660,960 960,1650 1680,2010
{} take this, {} takes

1889
01:02:36,990 --> 01:02:38,580
0,150 150,660 660,960 960,1110 1110,1590
two arguments or three arguments,|
|

1890
01:02:38,580 --> 01:02:39,900
0,210 210,870
{address -},
地址，寄存器一 r1 和寄存器二，

1891
01:02:40,130 --> 01:02:42,560
0,750 750,870 870,1260 1260,1860 2220,2430
{ -} register one {r1
寄存器1 R1和寄存器2

1892
01:02:42,560 --> 01:02:45,830
0,540 870,1080 1080,1500 1500,2040 2460,3270
-} and register two| and
|本质上硬件所做的是，

1893
01:02:46,010 --> 01:02:47,660
0,660 660,840 840,900 900,1260 1260,1650
essentially what the hardware does

1894
01:02:47,660 --> 01:02:51,440
0,870 1050,1830 1950,2730 2940,3270 3270,3780
{} conceptually {} is,| it
|它锁定这个地址，

1895
01:02:51,440 --> 01:02:53,100
0,510 510,630 630,1260
locks the address,|
|

1896
01:02:53,500 --> 01:02:54,860
0,150 150,300 300,750
if you will,
如果你愿意，我们稍后会更多的讨论锁定地址。

1897
01:02:54,980 --> 01:02:55,700
0,120 120,270 270,450 450,600 600,720
we'll talk about that in

1898
01:02:55,700 --> 01:02:56,660
0,30 30,300 300,510 510,630 630,960
a second little bit more

1899
01:02:56,660 --> 01:02:58,200
0,360 360,990
locks address.|
|

1900
01:02:58,200 --> 01:03:00,300
0,570 870,1650
It, {}
它（把值）放入一个临时变量，

1901
01:03:01,290 --> 01:03:02,370
0,150 150,360 360,480 480,540 540,1080
it puts in a temporary

1902
01:03:02,370 --> 01:03:03,700
0,750
variable,|
|

1903
01:03:03,910 --> 01:03:05,650
0,180 180,330 330,510 540,1320 1470,1740
you know the value that
那个地址中的值。

1904
01:03:05,650 --> 01:03:06,700
0,300 300,450 450,540 540,660 660,1050
actually is at that particular

1905
01:03:06,700 --> 01:03:07,800
0,540
address.|
|

1906
01:03:09,570 --> 01:03:11,580
0,660 690,1440
And then,
然后，将 r1 的值放到地址中。

1907
01:03:13,260 --> 01:03:14,640
0,390 390,480 480,960 960,1200 1200,1380
raise the value of {r1

1908
01:03:14,640 --> 01:03:17,220
0,630 960,1350 1350,1500 1500,2070
-} into the address.|
|

1909
01:03:17,560 --> 01:03:19,450
0,150 150,630 630,1260 1290,1770 1770,1890
And then basically puts the
然后把原始地址的值放入，

1910
01:03:19,450 --> 01:03:21,010
0,600 600,810 810,1020 1020,1140 1140,1560
value that was at the

1911
01:03:21,400 --> 01:03:23,900
0,600 600,1110 1110,1860
originally address into,|
|

1912
01:03:24,380 --> 01:03:27,110
0,1080 1380,1860 1860,2220 2220,2310 2310,2730
temp- temporary value, that was
tmp 中的原始值放入 r2 ，

1913
01:03:27,140 --> 01:03:28,670
0,180 480,870 870,1140 1140,1290 1290,1530
the original value was actually

1914
01:03:28,670 --> 01:03:29,720
0,270 270,540 540,780 780,870 870,1050
address actually into {} {r2

1915
01:03:29,720 --> 01:03:31,820
0,480 750,960 960,1050 1050,1470 1470,2100
-}| and then basically unlocks
|然后释放锁，并返回。

1916
01:03:32,090 --> 01:03:33,300
0,210 210,810
and returns.|
|

1917
01:03:37,220 --> 01:03:39,500
0,600 900,1020 1020,1350 1350,1650 1650,2280
And you know in this
在这个锁里，

1918
01:03:39,500 --> 01:03:41,240
0,390 390,630 630,750 750,1170 1200,1740
lock,| {} you will guarantee
|你能保证这个测试，

1919
01:03:41,240 --> 01:03:42,620
0,90 90,210 210,600 600,840 840,1380
is that basically this test,|
|

1920
01:03:42,740 --> 01:03:43,790
0,480 480,570 570,900 900,960 960,1050
where the result of the
测试结果会返回到 r2 ，

1921
01:03:43,790 --> 01:03:44,870
0,240 240,360 360,720 720,960 960,1080
test is returned into {r2

1922
01:03:44,870 --> 01:03:46,850
0,480 750,1110 1110,1200 1200,1620 1650,1980
-}| and the set actually
|而设置是原子发生的。

1923
01:03:46,850 --> 01:03:49,040
0,510 750,1500 1500,1680
happened {atomically -}.|
|

1924
01:03:49,070 --> 01:03:49,640
0,150 150,240 240,390 390,510 510,570
And so this is a
所以这是一条硬件指令，

1925
01:03:49,640 --> 01:03:51,980
0,300 300,930 960,1290 1290,1800 1800,2340
hardware instruction,| {} most processor
|大多数处理器都有这样的硬件指令。

1926
01:03:51,980 --> 01:03:53,540
0,510 510,600 600,840 840,1320 1320,1560
have an hardware instruction like

1927
01:03:53,540 --> 01:03:54,440
0,420
this.|
|

1928
01:03:54,440 --> 01:03:56,000
0,810 810,1050 1050,1290 1290,1410 1410,1560
{ -} Because it's a
因为这是一种方便的实现锁的方法。

1929
01:03:56,000 --> 01:03:57,800
0,540 540,900 900,1080 1080,1410 1410,1800
convenient way to actually implement

1930
01:03:57,800 --> 01:03:58,820
0,540
locks.|
|

1931
01:03:58,820 --> 01:03:59,960
0,600

1932
01:04:00,560 --> 01:04:02,630
0,630 990,1320 1320,1710 1710,1920 1920,2070
{} So basically what we've
所以我们要做的是，

1933
01:04:02,630 --> 01:04:04,280
0,270 270,540 540,750 750,990 990,1650
done is,| like we've reduced
|我们减少软件锁实现原子性，

1934
01:04:04,280 --> 01:04:06,020
0,540 540,870 870,1290 1290,1380 1380,1740
the atomicity {} of this

1935
01:04:06,020 --> 01:04:09,860
0,480 1530,2370 2400,3060 3060,3750 3750,3840
{} software lock implementation,| to
|而是硬件锁实现。

1936
01:04:09,860 --> 01:04:12,320
0,630 660,810 810,1200 1200,1590 1590,2460
basically a hardware lock implementation.|
|

1937
01:04:13,190 --> 01:04:16,640
0,690 1020,1860 2190,2910
{} And {}
处理器可能会使用不同的方式实现这个，

1938
01:04:16,970 --> 01:04:18,470
0,150 150,510 510,960 960,1140 1140,1500
so the processor might implement

1939
01:04:18,470 --> 01:04:19,760
0,150 150,450 450,720 720,960 960,1290
this in very different ways,|
|

1940
01:04:19,790 --> 01:04:21,860
0,210 210,870 870,1290 1290,1500 1500,2070
so basically {} the instruction
所以，指令集本身有一份说明书，

1941
01:04:21,860 --> 01:04:23,180
0,210 210,660 660,1140 1140,1290 1290,1320
set itself, there's like a

1942
01:04:23,180 --> 01:04:24,650
0,720 720,780 780,1050 1050,1260 1260,1470
specification,| it doesn't actually say
|它并没有说明它是如何实现的，

1943
01:04:24,650 --> 01:04:26,060
0,180 180,300 300,810 1200,1350 1350,1410
how it's implemented| and it
|它非常依赖于实际的实现。

1944
01:04:26,060 --> 01:04:27,410
0,90 90,390 390,1080 1140,1200 1200,1350
is very dependent on the

1945
01:04:27,410 --> 01:04:28,940
0,270 270,990
actual implementation.|
|

1946
01:04:30,320 --> 01:04:32,200
0,600 600,1290
Obvious, dependent
显然取决于内存系统的工作方式。

1947
01:04:34,400 --> 01:04:35,900
0,390 390,690 690,900 900,1230 1230,1500
{} on {how,the} memory system

1948
01:04:35,900 --> 01:04:37,320
0,360 360,870
exactly works.|
|

1949
01:04:44,320 --> 01:04:46,870
0,300 300,360 360,930 1170,1980 1980,2550
So, for example, {} if
比如，如果多个处理器共享单个内存控制器，

1950
01:04:46,870 --> 01:04:47,980
0,120 120,270 270,420 420,720 720,1110
you know the multi processor

1951
01:04:47,980 --> 01:04:49,960
0,240 270,1050 1050,1440 1440,1680 1680,1980
{ -} shared single memory

1952
01:04:49,960 --> 01:04:51,580
0,660 720,840 840,1140 1140,1380 1380,1620
controller,| {} that {reads,or} writes
|对内存进行读写，

1953
01:04:51,580 --> 01:04:52,810
0,90 90,540 630,900 900,960 960,1230
to memory,| then the memory
|那么内存控制器可以支持该操作，

1954
01:04:52,810 --> 01:04:54,220
0,510 510,630 630,900 900,1290 1290,1410
controller can actually support this

1955
01:04:54,220 --> 01:04:58,240
0,540 840,1470 1800,3150 3210,3570 3810,4020
operation,| basically allow you to
|允许在一个特定的地址设置锁，

1956
01:04:58,240 --> 01:04:59,440
0,330 330,390 390,450 450,810 810,1200
lock in a particular address,|
|

1957
01:04:59,440 --> 01:05:00,460
0,90 90,180 180,300 300,660 660,1020
you know and then let
然后让一个处理器做两个操作或三条指令，

1958
01:05:00,460 --> 01:05:01,630
0,90 90,210 210,510 510,1020 1020,1170
you know one processor do

1959
01:05:01,630 --> 01:05:03,280
0,210 210,900 900,1020 1020,1320 1320,1650
two operations or three {}

1960
01:05:03,280 --> 01:05:04,750
0,720 960,1080 1080,1170 1170,1380 1380,1470
instructions| and then [] will
|然后解锁，

1961
01:05:04,750 --> 01:05:06,190
0,630 660,870 870,1050 1050,1230 1230,1440
unlock| and so since all
|因为所有处理器的读写都通过这个内存控制器，

1962
01:05:06,190 --> 01:05:08,230
0,480 570,1320 1410,1710 1710,1800 1800,2040
the processors reads or writes

1963
01:05:08,230 --> 01:05:09,310
0,180 180,270 270,420 420,690 690,1080
go for this memory controller,|
|

1964
01:05:09,310 --> 01:05:10,390
0,60 60,300 300,720 720,930 930,1080
the memory controller {can,do} the
内存控制器可以对锁进行排序。

1965
01:05:10,390 --> 01:05:11,800
0,450 570,660 660,1080
ordering of locking.|
|

1966
01:05:12,290 --> 01:05:15,230
0,360 360,1020 1020,1500 2010,2490 2490,2940
{} If the {} memories
如果处理器中的内存位于共享总线上，

1967
01:05:15,230 --> 01:05:16,280
0,360 360,450 450,600 600,990 990,1050
are in this processor are

1968
01:05:16,280 --> 01:05:17,840
0,270 270,360 360,450 450,1020 1020,1560
sitting on a shared bus,|
|

1969
01:05:18,110 --> 01:05:19,580
0,720 720,960 960,1140 1140,1230 1230,1470
{} it's often the bus
通常是总线仲裁器可以做这个，

1970
01:05:19,580 --> 01:05:21,050
0,630 690,990 990,1110 1110,1350 1350,1470
arbiter that can actually do

1971
01:05:21,050 --> 01:05:22,190
0,210 210,420 420,600 600,990 990,1140
that,| where bus arbiter has
|总线仲裁器支持以原子方式执行两条内存操作。

1972
01:05:22,190 --> 01:05:24,560
0,540 540,900 900,1260 1260,1770 1770,2370
support for basically executing two

1973
01:05:24,980 --> 01:05:27,170
0,900 900,1560 1560,1740 1740,1830 1830,2190
memory operations in an atomic

1974
01:05:27,170 --> 01:05:27,940
0,330
way.|
|

1975
01:05:28,340 --> 01:05:30,500
0,450 450,990 990,1140 1140,1680 1950,2160
{} If it's, {} if
如果处理器有缓存，

1976
01:05:30,500 --> 01:05:32,990
0,90 90,450 450,840 840,1560 1950,2490
the processor have caches {},|
|

1977
01:05:32,990 --> 01:05:34,610
0,780 810,1080 1080,1290 1290,1440 1440,1620
then, {} it's sort of
那么它通常是高速缓存一致性协议的一部分，

1978
01:05:34,670 --> 01:05:35,540
0,330 330,510 510,570 570,660 660,870
typically part of the cache

1979
01:05:35,540 --> 01:05:38,750
0,300 300,690 690,1230 1500,2250 2850,3210
coherence protocol,| where {} cache
|高速缓存一致性协议将确保，

1980
01:05:38,750 --> 01:05:40,460
0,270 270,810 810,1140 1140,1530 1530,1710
coherence protocol will ensure that|
|

1981
01:05:40,460 --> 01:05:41,510
0,210 210,390 390,450 450,900 900,1050
if there's a writer,| you
如果有写入者，|缓存行会持有我们要更新的值，

1982
01:05:41,510 --> 01:05:43,880
0,120 120,390 390,870 870,1440 1740,2370
know that that particular {}

1983
01:05:44,780 --> 01:05:46,820
0,450 450,630 630,720 720,1200 1200,2040
cache line that holds a

1984
01:05:46,850 --> 01:05:48,350
0,720 720,900 900,1050 1050,1110 1110,1500
value we want to update,|
|

1985
01:05:48,350 --> 01:05:49,520
0,180 180,300 300,450 480,840 840,1170
ends up in one single
最终在一个单独的高速缓存中，

1986
01:05:49,520 --> 01:05:50,460
0,630
cache,|
|

1987
01:05:50,580 --> 01:05:52,530
0,180 180,660 780,1350 1350,1440 1440,1950
and then basically the {processor,is}
然后，处理器控制有两个操作的单个缓存行的锁。

1988
01:05:52,530 --> 01:05:53,790
0,120 120,360 360,780 810,990 990,1260
control of lock that single

1989
01:05:53,790 --> 01:05:56,850
0,330 330,600 600,1080 1080,1740 1740,3060
cache line across two operations.|
|

1990
01:05:57,330 --> 01:05:59,070
0,180 180,840 840,1320 1320,1410 1410,1740
So the implementation of this,|
所以，这个的实现，|

1991
01:05:59,070 --> 01:05:59,850
0,150 150,390 390,510 510,570 570,780
you know can be done
可以用多种不同的方式来完成，

1992
01:05:59,850 --> 01:06:01,500
0,60 60,270 270,540 540,1020 1080,1650
in many different ways {},|
|

1993
01:06:01,500 --> 01:06:03,570
0,210 210,990 1050,1470 1470,1860 1860,2070
but conceptually the,| {} what's
但理论上来说，|所做的是，你锁定地址，

1994
01:06:03,570 --> 01:06:04,350
0,180 180,390 390,540 540,720 720,780
going on, it's like you

1995
01:06:04,350 --> 01:06:06,030
0,270 270,330 330,870 1170,1560 1560,1680
lock the address,| {} you
|读取原始值，

1996
01:06:06,030 --> 01:06:08,190
0,420 420,540 540,840 840,1410 1740,2160
read your original value,| you
|保存新值，

1997
01:06:08,340 --> 01:06:09,660
0,360 360,540 540,630 630,810 810,1320
store in the new value|
|

1998
01:06:09,660 --> 01:06:11,240
0,180 180,570 570,780 780,1110
and {you,return} your value.|
然后返回值。|

1999
01:06:12,360 --> 01:06:13,620
0,120 120,210 210,330 330,690
Does that make sense?|
这能理解吗？|

2000
01:06:15,820 --> 01:06:17,500
0,570 960,1290 1290,1440 1440,1560 1560,1680
To see how we can
看看我们如何使用这条指令，

2001
01:06:17,500 --> 01:06:19,810
0,240 240,420 420,1080 1740,2070 2070,2310
use that instruction,| {} let's
|让我们看看 xv6 中 acquire 和 release 的实现，

2002
01:06:19,810 --> 01:06:21,130
0,210 210,390 390,510 510,630 630,1320
actually look at the implementation

2003
01:06:21,130 --> 01:06:24,220
0,450 450,1260 1290,2040 2040,2460 2460,3090
of {} acquire {and,release} in

2004
01:06:24,250 --> 01:06:25,570
0,240 240,360 360,810 1050,1260 1260,1320
{xv6 - -}| and it
|它还会揭露一些其他有趣的细节。

2005
01:06:25,570 --> 01:06:26,380
0,120 120,450 450,480 480,750 750,810
will expose a couple of

2006
01:06:26,380 --> 01:06:27,900
0,240 240,570 570,1080
other interesting details.|
|

2007
01:06:29,300 --> 01:06:30,420
0,600

2008
01:06:31,800 --> 01:06:33,330
0,180 180,360 360,510 510,840 840,1530
So let me first {}
让我先来介绍一下 spinlock.h ，

2009
01:06:33,360 --> 01:06:34,350
0,270 270,420 420,660 660,900 900,990
bring up {spinlock.h - -

2010
01:06:34,350 --> 01:06:36,750
0,600 630,1470 1920,1980 1980,2190 2190,2400
-},| { -} {spinlock.h -
|spinlock.h ，如你所见，它非常简单，

2011
01:06:36,750 --> 01:06:37,920
0,120 120,660 690,990 990,1080 1080,1170
- -}, as you can

2012
01:06:37,920 --> 01:06:38,960
0,480
see,

2013
01:06:39,220 --> 01:06:42,010
0,180 180,420 420,1350 1380,2160 2610,2790
it's pretty straightforward,| {} it
|它有这个 locked 标记，和我们的伪代码一样，

2014
01:06:42,010 --> 01:06:43,900
0,270 270,420 420,990 990,1380 1380,1890
has this flag locked, exactly

2015
01:06:43,900 --> 01:06:45,160
0,120 120,300 300,480 510,780 780,1260
as in our pseudo code|
|

2016
01:06:45,460 --> 01:06:46,450
0,120 120,240 240,480 480,780 780,990
and then there's two other
还有其他两个东西用来调试，

2017
01:06:46,450 --> 01:06:47,770
0,210 210,330 330,870 870,1200 1200,1320
things for debugging,| namely the
|即锁的名称，

2018
01:06:47,770 --> 01:06:49,510
0,240 240,330 330,450 450,930 1020,1740
name of the lock| and
|和当前持有锁的 CPU 。

2019
01:06:49,510 --> 01:06:51,480
0,300 300,900 900,990 990,1560
the CPU, the last,

2020
01:06:51,480 --> 01:06:52,650
0,90 90,450 450,780 780,900 900,1170
the current CPU that actually

2021
01:06:52,650 --> 01:06:54,020
0,360 360,450 450,840
holding the lock.|
|

2022
01:06:54,170 --> 01:06:55,220
0,390 390,540 540,660 660,750 750,1050
{} And this is mostly
这主要是打印出调试消息，

2023
01:06:55,220 --> 01:06:56,120
0,120 120,360 360,570 570,630 630,900
to print out the debugging

2024
01:06:56,120 --> 01:06:57,560
0,510 510,630 630,1020 1020,1140 1140,1440
messages,| for example you do
|比如，获取相同的 CPU 。

2025
01:06:57,560 --> 01:06:59,030
0,390 390,1230 1230,1320 1320,1380 1380,1470
to acquire some of the

2026
01:06:59,030 --> 01:07:00,220
0,210 210,660
same CPU.|
|

2027
01:07:01,450 --> 01:07:02,680
0,240 240,480 480,660 660,990 990,1230
{} Okay, so then let's
好的，让我们来看看它的实现。

2028
01:07:02,680 --> 01:07:04,420
0,180 180,420 630,1200
look at {}

2029
01:07:05,970 --> 01:07:07,760
0,180 180,1260
the implementation.|
|

2030
01:07:12,020 --> 01:07:13,550
0,690 690,960 960,1080 1080,1260 1260,1530
{} And so let's start
我们从 acquire 开始。

2031
01:07:13,550 --> 01:07:15,140
0,180 180,330 330,360 360,1080
out with {acquire -}.|
|

2032
01:07:15,140 --> 01:07:17,330
0,720 1050,1560 1560,1740 1740,2010 2010,2190
{} And let's first look
我们先看看这个循环，

2033
01:07:17,330 --> 01:07:19,160
0,90 90,630 660,1290
at this loop,|
|

2034
01:07:19,540 --> 01:07:21,160
0,240 240,420 420,570 570,1080 1080,1620
so this is actually {}
这实际上是一种测试和设置循环，

2035
01:07:21,160 --> 01:07:23,020
0,0 810,1230 1230,1440 1440,1530 1530,1860
{} the sort of {test,and}

2036
01:07:23,020 --> 01:07:24,220
0,240 240,510 510,690 690,1020 1020,1200
set loop,| that I just
|就是我刚才谈到的，

2037
01:07:24,220 --> 01:07:25,930
0,270 270,660 930,1260 1260,1500 1500,1710
talked about,| it turns out
|实际上，在 C 标准中，

2038
01:07:25,930 --> 01:07:28,120
0,240 240,870 1020,1620
that in {

2039
01:07:28,360 --> 01:07:30,640
0,930 990,1440 1440,1560 1560,1740 1740,2280
- -} the C standard,|
|

2040
01:07:30,670 --> 01:07:33,190
0,390 390,1170 1200,2040 2130,2460 2460,2520
actually defines {} one of
定义了这些原子操作之一，

2041
01:07:33,190 --> 01:07:35,290
0,150 150,510 510,1200 1230,1740 1740,2100
these atomic operations| and so
|C 标准种有一个函数，

2042
01:07:35,620 --> 01:07:37,930
0,510 1320,1740 1740,1980 1980,2220 2220,2310
C standard actually has a

2043
01:07:37,930 --> 01:07:40,060
0,420 420,960 1260,1530 1530,2040 2040,2130
function,| that {} says you
|也就是 __sync_lock_test_and_set ，

2044
01:07:40,060 --> 01:07:41,800
0,120 120,450 450,960 990,1650 1650,1740
know {__sync_lock_test_and_set - - -

2045
01:07:41,800 --> 01:07:43,150
0,270 270,390 390,780 780,1290 1290,1350
-}| and basically specifies the
|指定了我刚才描述的行为。

2046
01:07:43,150 --> 01:07:45,130
0,600 600,780 780,1200 1200,1410 1410,1980
behavior that I just described.|
|

2047
01:07:45,700 --> 01:07:47,080
0,180 180,300 300,510 510,1020 1020,1380
And then every processor basically
然后，每个处理器都需要实现该行为，

2048
01:07:47,080 --> 01:07:50,740
0,750 780,1080 1080,1770 1770,2550 2790,3660
required to implement that behavior|
|

2049
01:07:50,860 --> 01:07:52,360
0,270 270,450 450,660 660,1140 1140,1500
and since most processors have
由于大多数处理器具有测试和设置硬件指令，

2050
01:07:52,360 --> 01:07:54,190
0,330 360,1080 1170,1290 1290,1560 1560,1830
and matching of {test,and} set

2051
01:07:54,190 --> 01:07:56,020
0,330 330,990 1230,1440 1440,1560 1560,1830
hardware instruction,| {} this turns
|这是实现[]的一个合理而直接的方案，

2052
01:07:56,020 --> 01:07:56,710
0,150 150,210 210,300 300,360 360,690
out to be a reasonable

2053
01:07:56,710 --> 01:07:58,060
0,690 690,870 870,960 960,1290 1290,1350
straightforward for the [] to

2054
01:07:58,060 --> 01:07:59,260
0,510 540,750 750,900 900,960 960,1200
implement,| then so in fact
|实际上，如果我们看看 kernel.asm ，

2055
01:07:59,260 --> 01:08:00,640
0,90 90,210 210,540 870,1110 1110,1380
if we look at {kernel.asm

2056
01:08:00,640 --> 01:08:01,990
0,180 180,780 780,1080 1080,1200 1200,1350
- -},| we can look
|我们可以查看汇编指令，

2057
01:08:01,990 --> 01:08:03,400
0,60 60,150 150,600 600,1290 1290,1410
at the assembly instructions| and
|了解 RISC-V 处理器的确切功能。

2058
01:08:03,400 --> 01:08:04,780
0,150 150,810 810,1080 1080,1140 1140,1380
see exactly what the {RISC-V

2059
01:08:04,780 --> 01:08:06,360
0,210 210,690 690,1200
-} processor does.|
|

2060
01:08:08,000 --> 01:08:09,860
0,420 420,1320
{} So.|
所以。|

2061
01:08:11,200 --> 01:08:12,970
0,210 210,540 540,750 750,1380 1380,1770
At here is our assembly
这是我们的汇编结构 acquire ，

2062
01:08:12,970 --> 01:08:16,360
0,390 390,1260 1590,2730 2730,2970 2970,3390
structures acquire| and let's here's
|这是 amoswap 指令。

2063
01:08:16,360 --> 01:08:17,520
0,600
our

2064
01:08:17,800 --> 01:08:19,960
0,570 570,960 960,1590
{amoswap -} instruction.|
|

2065
01:08:27,830 --> 01:08:29,240
0,360 360,510 510,630 630,750 750,1410
{} So you can see,|
所以你可以看到，|

2066
01:08:29,270 --> 01:08:30,800
0,990

2067
01:08:30,800 --> 01:08:32,630
0,780 810,930 930,1080 1080,1560 1560,1830
if you know {amoswap -}
amoswap 调用寄存器 a5 ，

2068
01:08:32,630 --> 01:08:34,880
0,630 630,1050 1050,1470 1560,2100 2100,2250
basically {} called register {a5

2069
01:08:34,880 --> 01:08:38,090
0,360 360,1890 2130,2250 2250,2610 2610,3210
-}| and the input and
|并且输入和输出也是 a5 ，

2070
01:08:38,090 --> 01:08:39,140
0,300 300,570 570,810 810,960 960,1050
output also ends up in

2071
01:08:39,140 --> 01:08:40,820
0,150 150,630 1020,1320 1320,1470 1470,1680
{a5 -}| and as long
|与整个地址一样长，

2072
01:08:40,820 --> 01:08:41,270
0,90 90,150 150,300 300,360 360,450
as the whole {[] -}

2073
01:08:41,270 --> 01:08:45,230
0,660 930,1950 1980,2940 2940,3540 3540,3960
address| and {} if it's
|如果不相等，我们就返回，

2074
01:08:45,260 --> 01:08:46,600
0,300 300,900
not equal,

2075
01:08:46,630 --> 01:08:50,200
0,1470 1500,2250 2280,2430 2430,3090 3090,3570
we return| and otherwise basically
|否则我们会回到，

2076
01:08:50,200 --> 01:08:52,030
0,150 150,270 270,780 930,1410 1410,1830
we go back to, {}

2077
01:08:52,420 --> 01:08:54,640
0,330 360,720 720,1200 1320,1830 1830,2220
we jump back to, {}|
|

2078
01:08:55,060 --> 01:08:56,160
0,570

2079
01:08:57,170 --> 01:08:58,010
0,270 270,510 510,600 600,780 780,840
double check I'm saying the
再检查一遍我说的是对的，|

2080
01:08:58,010 --> 01:09:00,230
0,180 180,360 360,810 1170,1890 1890,2220
right thing here,| move {a4
|将 a4 移动到[]，

2081
01:09:00,230 --> 01:09:01,780
0,960
in}

2082
01:09:01,940 --> 01:09:03,500
0,420 420,660 660,960 960,1320 1320,1560
[],| if not equal to
|如果不等于，则到 +0x22 。

2083
01:09:03,500 --> 01:09:06,110
0,300 300,690 690,1500 1650,2040 2220,2610
{0x -} twenty plus {22

2084
01:09:06,110 --> 01:09:07,200
0,510
-}.|
|

2085
01:09:07,260 --> 01:09:08,220
0,390 390,600 600,720 720,780 780,960
{} Alright, that's a little
好吧，这有点难计算，

2086
01:09:08,220 --> 01:09:10,140
0,150 150,210 210,810 810,1560 1560,1920
hard to calculate,| but basically
|但基本上在一种情况下，我们[扩展]，

2087
01:09:10,140 --> 01:09:10,980
0,60 60,180 180,390 390,510 510,840
in one case, we branch

2088
01:09:10,980 --> 01:09:11,970
0,420 510,660 660,750 750,840 840,990
out| and in the other
|在另一种情况下，我们向后分支。

2089
01:09:11,970 --> 01:09:13,600
0,240 240,390 390,660 660,1110
case, we [branch back].|
|

2090
01:09:14,270 --> 01:09:15,200
0,210 210,360 360,510 510,630 630,930
So this may be easier
所以，可能看 C 代码更容易。

2091
01:09:15,200 --> 01:09:16,280
0,300 300,510 510,630 630,870 870,1080
to look at the C

2092
01:09:16,280 --> 01:09:17,300
0,450
code.|
|

2093
01:09:19,580 --> 01:09:20,570
0,150 150,330 330,480 480,810 810,990
So let's go away in
所以让我们到这里，

2094
01:09:20,570 --> 01:09:22,190
0,270 270,390 390,570 570,1230 1410,1620
here,| so what happens,| so
|那么会发生什么呢，|如果锁没有被持有，

2095
01:09:22,190 --> 01:09:23,270
0,210 210,570 600,780 780,840 840,1080
if the if the lock

2096
01:09:23,270 --> 01:09:25,140
0,360 390,810 810,1320
is not held,|
|

2097
01:09:25,140 --> 01:09:26,160
0,240 240,510 510,720 720,930 930,1020
{} what will be the
lk->locked 的值是多少，

2098
01:09:26,160 --> 01:09:27,600
0,330 330,450 450,630 630,930 930,1440
value of l lock,| well
|lk->locked 会是零，

2099
01:09:27,600 --> 01:09:29,540
0,30 30,360 360,930 1230,1740
lk->locked {will,be} zero right,|
|

2100
01:09:30,180 --> 01:09:31,170
0,240 240,540 540,660 660,840 840,990
and so we call this
所以我们称之为测试和设置，

2101
01:09:31,170 --> 01:09:32,940
0,270 270,750 930,1260 1260,1410 1410,1770
{test,and} set,| what will happen
|将会发生的是，我们在 locked 中写入 1 ，

2102
01:09:32,940 --> 01:09:34,770
0,180 180,360 360,570 570,1230 1380,1830
is we'll write one {}

2103
01:09:34,770 --> 01:09:37,350
0,210 210,690 1560,2190 2190,2280 2280,2580
in locked,| {but,return} the previous
|但是返回之前的值。

2104
01:09:37,350 --> 01:09:38,340
0,480
value.|
|

2105
01:09:38,620 --> 01:09:39,820
0,150 150,270 270,360 360,630 630,1200
So if the previous value
所以如果之前的值是零，

2106
01:09:39,820 --> 01:09:42,760
0,210 210,870 1320,1890 1920,2550 2730,2940
is zero,| {} then we're
|那我们就好了，

2107
01:09:42,760 --> 01:09:43,960
0,360 390,630 630,840 840,990 990,1200
good right,| because that means
|因为这意味着没有人拿着锁，

2108
01:09:43,960 --> 01:09:44,950
0,150 150,450 450,600 600,900 900,990
that nobody was holding the

2109
01:09:44,950 --> 01:09:46,450
0,450 450,630 630,810 810,1080 1080,1500
lock| and we fall through
|我们就结束了这个 while 循环。

2110
01:09:46,450 --> 01:09:47,080
0,120 120,210 210,390 390,510 510,630
and we're done with this

2111
01:09:47,080 --> 01:09:48,100
0,300 300,600
while loop.|
|

2112
01:09:49,740 --> 01:09:50,700
0,150 150,330 330,510 510,690 690,960
Now, let's say the lock
现在，我们假设锁的值是 1 ，

2113
01:09:50,700 --> 01:09:52,590
0,360 360,510 510,960 1140,1530 1560,1890
value was one,| so probably
|所以可能锁已经上锁，

2114
01:09:52,590 --> 01:09:55,560
0,1140 1170,1680 1680,1950 1950,2400 2760,2970
the lock actually locked,| well,
|这条指令会做什么，

2115
01:09:55,560 --> 01:09:57,420
0,270 270,480 480,870 870,1380 1470,1860
{what,will} this instruction do,| it
|它会读取旧值，把它放在一边，

2116
01:09:57,420 --> 01:09:59,340
0,540 600,1410
will {}

2117
01:09:59,340 --> 01:10:01,110
0,480 510,780 780,1020 1020,1500 1500,1770
read the old value, put

2118
01:10:01,110 --> 01:10:03,120
0,180 180,780 780,1020 1020,1380 1380,2010
that {in,the,side} correct,| there's one
|在这种情况下，是 1 ，

2119
01:10:03,120 --> 01:10:04,290
0,180 180,360 360,480 480,900 990,1170
{} in this case| and
|然后在那个位置写入一个新的 1 。

2120
01:10:04,290 --> 01:10:05,940
0,180 180,510 510,930 990,1260 1260,1650
then write a new one

2121
01:10:05,940 --> 01:10:07,620
0,330 330,540 540,1170
into that location.|
|

2122
01:10:07,790 --> 01:10:09,680
0,780 780,1230 1230,1440 1440,1590 1590,1890
{} And that will change
这不会改变任何事情，

2123
01:10:09,680 --> 01:10:11,480
0,480 510,810 810,1020 1020,1110 1110,1800
nothing right,| because it was
|因为它已经被锁上了。

2124
01:10:11,480 --> 01:10:12,780
0,300 300,780
already locked.|
|

2125
01:10:12,810 --> 01:10:14,160
0,540 540,750 750,840 840,1170 1170,1350
And and the function will
函数将会返回 1 ，

2126
01:10:14,160 --> 01:10:16,260
0,270 270,720 1050,1740 1740,1890 1890,2100
return one,| indicating that actually
|表明之前的持有，

2127
01:10:16,260 --> 01:10:17,370
0,240 240,360 360,450 450,750 750,1110
some of the previous hold,|
|

2128
01:10:17,370 --> 01:10:18,810
0,210 210,510 510,720 720,1020 1020,1440
that it was already locked|
它已经被锁上了，|

2129
01:10:18,840 --> 01:10:19,860
0,120 120,300 300,360 360,540 540,1020
and so in that case
所以在这种情况下，它不等于零，

2130
01:10:19,920 --> 01:10:21,630
0,210 240,720 720,810 810,1440 1560,1710
it's unequal to zero| and
|它会旋转，一直旋转，|

2131
01:10:21,630 --> 01:10:22,890
0,90 90,240 240,750 870,1080 1080,1260
it will spin, will keep

2132
01:10:22,890 --> 01:10:25,170
0,600 690,990 990,1530 1530,1890 1890,2280
spinning| {until -} locked actually
|直到 locked 重新设置为 0 ，

2133
01:10:25,170 --> 01:10:28,140
0,240 240,750 1020,1560 1920,2430 2460,2970
set back to {} zero,|
|

2134
01:10:28,590 --> 01:10:29,760
0,420 420,660 660,990 990,1080 1080,1170
and presumably happened in this
而这发生在 release 中。

2135
01:10:29,760 --> 01:10:30,780
0,510
release.|
|

2136
01:10:32,500 --> 01:10:34,040
0,180 180,480 480,690 690,930
Any questions about this?|
对于这个，有什么问题吗？|

2137
01:10:51,200 --> 01:10:52,540
0,300 300,780
No questions?|
没有问题？|

2138
01:10:52,810 --> 01:10:54,720
0,450 750,1380
Okay. {}|
好的。|

2139
01:10:56,070 --> 01:10:57,240
0,180 180,360 360,960 960,1050 1050,1170
So now basically you know
所以现在，让我们看看对应的 release 操作，

2140
01:10:57,240 --> 01:10:58,620
0,150 150,300 300,390 390,630 660,1380
let's look at the corresponding

2141
01:10:58,680 --> 01:11:00,080
0,840
{}

2142
01:11:00,170 --> 01:11:01,960
0,240 240,480 480,1260
the release operation,|
|

2143
01:11:01,990 --> 01:11:03,560
0,930
And,
这里是 release 操作，

2144
01:11:03,560 --> 01:11:04,980
0,840
{}

2145
01:11:07,540 --> 01:11:10,390
0,900 930,1470 1470,1860 1890,2160 2160,2850
and here's {} release operation,|
|

2146
01:11:10,690 --> 01:11:11,920
0,420 420,510 510,810 810,1140 1140,1230
and if you look at
如果你再看一下 kernel.asm 。

2147
01:11:11,920 --> 01:11:14,140
0,150 150,510 510,1080 1110,1650
the {kernel.asm -} again.|
|

2148
01:11:15,960 --> 01:11:18,420
0,330 330,1200 1290,1710 1710,2160 2160,2460
That instruction,| {} so lets
那个指令，|所以让我们看看 release ，

2149
01:11:18,420 --> 01:11:19,560
0,150 150,330 330,600 600,900 900,1140
look at release,| probably right
|可能在这里后面，这是 release 。

2150
01:11:19,560 --> 01:11:21,440
0,390 390,660 660,1380
after, here release.|
|

2151
01:11:22,220 --> 01:11:23,390
0,210 210,330 330,630 630,900 900,1170
So the release actually also
所以， release 也使用了这个 amoswap 指令，

2152
01:11:23,390 --> 01:11:25,700
0,450 450,660 660,1110 1110,1620 1650,2310
uses this {amoswap -} instruction,|
|

2153
01:11:26,680 --> 01:11:27,960
0,720

2154
01:11:27,960 --> 01:11:30,000
0,360 360,600 600,960 960,1590 1620,2040
and putting basically zero into
把 0 放入 s1 。

2155
01:11:30,000 --> 01:11:31,080
0,150 150,510
{s1 -}.|
|

2156
01:11:33,520 --> 01:11:35,290
0,240 240,810 1020,1230 1230,1680 1680,1770
And so this guarantee is|
所以这保证的是，|

2157
01:11:35,290 --> 01:11:37,180
0,450 450,660 660,840 840,1320 1320,1890
basically that this atomic update
这个原子更新 lk->locked ，

2158
01:11:37,180 --> 01:11:39,280
0,90 90,210 210,630 630,1380 1410,2100
you know to {l->locked -}

2159
01:11:39,280 --> 01:11:42,040
0,150 150,210 210,810 1080,2070 2100,2760
or {lk->locked -},| {} writing
|使用原子操作将 0 写入 lk->locked 。

2160
01:11:42,040 --> 01:11:43,630
0,450 450,720 720,870 870,1410 1410,1590
zero into {lk->locked -} using

2161
01:11:43,630 --> 01:11:45,020
0,60 60,390 390,900
{} atomic operation.|
|

2162
01:11:46,080 --> 01:11:47,790
0,450 450,540 540,750 750,1200 1200,1710
Many of you ask why
你们中的许多人问到，为什么不直接使用 store ，

2163
01:11:47,790 --> 01:11:49,800
0,180 180,510 510,960 960,1440
not just use store,|
|

2164
01:11:49,800 --> 01:11:50,880
0,60 60,330 330,720 720,870 870,1080
{} store instruction to actually
store 指令来写入 0 。

2165
01:11:50,880 --> 01:11:52,140
0,240 240,720
write zero.|
|

2166
01:11:52,510 --> 01:11:53,900
0,900

2167
01:11:53,990 --> 01:11:55,440
0,930
Anybody,
有没有人，能猜猜为什么，

2168
01:11:55,500 --> 01:11:56,130
0,150 150,210 210,330 330,390 390,630
may you want to guess

2169
01:11:56,130 --> 01:11:57,460
0,780
why,|
|

2170
01:11:58,310 --> 01:11:59,390
0,270 270,450 450,480 480,780 780,1080
why that might not work|
为什么那可能行不通，|

2171
01:11:59,390 --> 01:12:00,620
0,420 600,720 720,810 810,1080 1080,1230
or what the problem could
或者问题可能是什么。

2172
01:12:00,620 --> 01:12:01,480
0,330
be.|
|

2173
01:12:02,380 --> 01:12:04,240
0,360 360,840 870,1140 1140,1440 1440,1860
Because then some other process
因为某个其他进程可能正在将 1 写入锁，或者，

2174
01:12:04,240 --> 01:12:05,440
0,210 210,300 300,690 690,1080 1080,1200
might be writing one to

2175
01:12:05,440 --> 01:12:07,420
0,120 120,540 540,900 1380,1740
the lock or,| no,
|不，或者再写一个 0 ，

2176
01:12:07,760 --> 01:12:09,470
0,270 270,660 660,930 930,1440 1470,1710
or writing another zero,| but
|但不是这样的，对吧。

2177
01:12:09,470 --> 01:12:10,340
0,180 180,360 360,480 480,570 570,870
that can't be the case,

2178
01:12:10,340 --> 01:12:11,200
0,270
right.|
|

2179
01:12:11,320 --> 01:12:12,340
0,270 270,510 510,630 630,810 810,1020
Yeah, well there could be
是啊，可能是对的，

2180
01:12:12,340 --> 01:12:12,970
0,150 150,240 240,360 360,510 510,630
okay,| so there could be
|可能有两个进程或两个 CPU 同时写入 l->locked ，

2181
01:12:12,970 --> 01:12:14,320
0,210 210,900 900,1020 1020,1140 1140,1350
two processes or two {CPUs

2182
01:12:14,320 --> 01:12:15,550
0,240 240,660 660,780 780,960 960,1230
-} writing to {l->locked -}

2183
01:12:15,550 --> 01:12:16,690
0,90 90,180 180,390 390,750 780,1140
at the same time right,|
|

2184
01:12:17,170 --> 01:12:19,090
0,750 840,1050 1050,1110 1110,1380 1380,1920
{} but I think what
但我认为真正的问题是，

2185
01:12:19,090 --> 01:12:20,380
0,210 210,480 480,840 840,1020 1020,1290
the question really is that,|
|

2186
01:12:20,380 --> 01:12:21,550
0,120 120,330 330,480 480,720 720,1170
you know, for many people
对很多人来说，我也经常这么想，

2187
01:12:21,550 --> 01:12:22,810
0,360 360,570 570,870 870,1110 1110,1260
and I often assume this

2188
01:12:22,810 --> 01:12:24,100
0,420 540,750 750,960 960,1110 1110,1290
too,| is that you're going
|就是你要做一条 store 指令，

2189
01:12:24,100 --> 01:12:25,030
0,60 60,180 180,270 270,570 570,930
to do a single store

2190
01:12:25,030 --> 01:12:25,870
0,420 420,540 540,630 630,780 780,840
instruction,| that is sort of
|这是一个原子操作。

2191
01:12:25,870 --> 01:12:27,540
0,150 150,210 210,600 600,1200
like an atomic operation.|
|

2192
01:12:28,250 --> 01:12:30,110
0,600 840,1050 1050,1200 1200,1500 1500,1860
{ -} There's not always
并不总是这样的，

2193
01:12:30,110 --> 01:12:31,760
0,90 90,690 720,960 960,1500 1500,1650
the case,| for example if
|比如，如果你，

2194
01:12:31,760 --> 01:12:33,350
0,540 750,780 810,1350 1350,1470 1470,1590
you are {}| and it
|这取决于架构的实现，

2195
01:12:33,350 --> 01:12:34,850
0,180 180,540 540,780 780,990 990,1500
really depends on the architecture

2196
01:12:34,850 --> 01:12:36,800
0,660 690,960 960,1020 1020,1440 1440,1950
implementation,| like for example if
|比如，如果缓存[]协议工作，

2197
01:12:36,800 --> 01:12:38,420
0,90 90,600 600,1080 1080,1440 1440,1620
the {cache,[]} protocol works| or
|或者缓存系统使用缓存行工作，

2198
01:12:38,420 --> 01:12:39,560
0,30 30,330 330,660 660,870 870,1140
{} cache system works using

2199
01:12:39,560 --> 01:12:40,790
0,330 330,600 600,780 780,1020 1020,1230
cache lines,| where cache line
|其中缓存行可能大于整数，

2200
01:12:40,790 --> 01:12:41,820
0,540
maybe

2201
01:12:41,820 --> 01:12:43,350
0,150 150,390 390,630 630,1470 1470,1530
{} bigger than integer,| are
|通常大于整数，

2202
01:12:43,350 --> 01:12:45,750
0,330 330,540 540,720 720,1260 1620,2400
typically bigger than integer {},|
|

2203
01:12:45,750 --> 01:12:46,860
0,180 180,360 360,570 570,930 930,1110
then really what's happening is,|
那么真正发生的是，|

2204
01:12:46,860 --> 01:12:48,060
0,210 210,300 300,570 570,1050 1050,1200
that the first operation is
第一个操作是加载缓存行，

2205
01:12:48,060 --> 01:12:49,200
0,360 360,450 450,750 750,1050 1050,1140
loading the cache line,| and
|然后是更新缓存行，

2206
01:12:49,200 --> 01:12:50,460
0,150 150,630 630,690 690,990 990,1260
then updating the cache line,|
|

2207
01:12:50,790 --> 01:12:51,540
0,180 180,240 240,570 570,660 660,750
so in fact you know
所以， store 指令里面有两个微操作，

2208
01:12:51,540 --> 01:12:52,920
0,90 90,330 330,810 810,1110 1110,1380
{} store instruction, basically has

2209
01:12:52,950 --> 01:12:54,510
0,210 210,630 630,1200 1200,1320 1320,1560
two micro operations in it|
|

2210
01:12:54,690 --> 01:12:56,880
0,780 1380,1830 1830,1950 1950,2100 2100,2190
and you can get the
你可能会得到错误的结果。

2211
01:12:56,880 --> 01:12:57,940
0,180 180,660
wrong result.|
|

2212
01:12:58,990 --> 01:13:02,110
0,480 720,1260 1290,2310 2400,2550 2550,3120
{} So, {} you know
所以，为了避免必须了解任何硬件实现，

2213
01:13:02,530 --> 01:13:04,030
0,270 270,810 810,900 900,1260 1290,1500
to avoid you know having

2214
01:13:04,030 --> 01:13:05,050
0,90 90,420 420,810 810,930 930,1020
to understand anything of the

2215
01:13:05,050 --> 01:13:06,610
0,300 300,840 840,930 930,1440 1440,1560
hardware implementation,| of exactly and
|以及整数运算是否是原子的，

2216
01:13:06,610 --> 01:13:08,380
0,300 300,750 750,1260 1260,1380 1380,1770
whether integer operations are atomic

2217
01:13:08,380 --> 01:13:09,730
0,90 90,480 510,840 840,1170 1170,1350
or not| or writing to
|或者写入 64 位内存值是原子操作，

2218
01:13:09,730 --> 01:13:12,440
0,540 540,840 1050,1770 1860,2220
64 bit 64 {}

2219
01:13:12,440 --> 01:13:14,060
0,240 240,810 810,1230 1230,1290 1290,1620
bit memory values as atomic

2220
01:13:14,060 --> 01:13:15,530
0,660 810,930 930,1020 1020,1170 1170,1470
operation,| you know we use
|我们使用 RISC-V 操作，

2221
01:13:15,530 --> 01:13:18,740
0,420 690,1590 1590,2220 2250,2640 2640,3210
the { -} {RISC-V -}

2222
01:13:19,070 --> 01:13:20,450
0,480 480,630 630,780 780,1320 1320,1380
operation,| that is guaranteed to
|它可以保证原子执行。

2223
01:13:20,450 --> 01:13:22,060
0,120 120,540 540,930 930,1110
be executed {atomically -}.|
|

2224
01:13:25,020 --> 01:13:26,340
0,120 120,240 240,390 390,750
Does that make sense?|
这能理解吗？|

2225
01:13:28,100 --> 01:13:29,160
0,540
Yes.|
是的。|

2226
01:13:30,290 --> 01:13:32,540
0,270 270,570 570,750 750,990 990,2250
Okay, so {} just {},
好的，为了[扩展]一下，

2227
01:13:33,210 --> 01:13:35,610
0,300 300,510 510,870 870,1560 1620,2400
just for your [amusement] {},|
|

2228
01:13:36,180 --> 01:13:37,230
0,450 450,720 720,810 810,960 960,1050
{amoswap -} is not the
amoswap 不是唯一存在的指令，

2229
01:13:37,230 --> 01:13:39,450
0,240 240,870 900,1350 1350,1860 1890,2220
only instruction that exists {},|
|

2230
01:13:39,450 --> 01:13:40,620
0,120 120,420 420,690 690,900 900,1170
so here's the {RISC-V -}
这是 RISC-V 手册，

2231
01:13:40,620 --> 01:13:43,350
0,540 870,1500 1500,1980 2010,2640 2640,2730
manual,| {} in lists, {}
|在列表中，是所有的原子操作，

2232
01:13:43,350 --> 01:13:44,220
0,180 180,360 360,450 450,540 540,870
whole bunch of the atomic

2233
01:13:44,220 --> 01:13:45,540
0,480 480,660 660,810 810,900 900,1320
operation,| so there's an {amoand
|所以有 AMOAND, AMOOR ，

2234
01:13:45,540 --> 01:13:47,070
0,300 300,420 420,870 870,1260 1260,1530
-}, {} {amoor -},| there's
|还有 AMOMAX, AMOMIN ，

2235
01:13:47,070 --> 01:13:49,290
0,450 450,870 870,1320 1620,1860 1860,2220
{} max min,| {} they're
|它们都可以在原子操作中读写一个值。

2236
01:13:49,290 --> 01:13:50,940
0,630 630,630
all {

2237
01:13:50,940 --> 01:13:51,900
0,300 300,510 510,690 690,870 870,960
-} can {} read or

2238
01:13:51,900 --> 01:13:52,920
0,240 240,270 270,780 780,930 930,1020
write a value in an

2239
01:13:52,920 --> 01:13:54,380
0,390 390,900
atomic operation.|
|

2240
01:13:58,480 --> 01:13:59,560
0,570
Okay?|
好的?|

2241
01:13:59,890 --> 01:14:00,850
0,150 150,300 300,420 420,450 450,960
Okay, so there's a couple
好的，还有其他几件事我想指出，

2242
01:14:00,970 --> 01:14:01,660
0,210 210,420 420,480 480,630 630,690
other things, I want to

2243
01:14:01,660 --> 01:14:03,130
0,240 240,690 720,1110 1110,1290 1290,1470
point out,| {} in this
|在这个实现中。

2244
01:14:03,130 --> 01:14:04,760
0,330 330,1020
particular implementation.|
|

2245
01:14:04,910 --> 01:14:06,140
0,720

2246
01:14:06,420 --> 01:14:08,250
0,840 990,1260 1260,1440 1440,1530 1530,1830
In, {} let me start
让我重新回到 acquire 。

2247
01:14:08,250 --> 01:14:10,710
0,360 360,510 510,870 870,1350 1740,2460
again go back to acquire.|
|

2248
01:14:12,850 --> 01:14:13,750
0,360 360,510 510,750 750,810 810,900
{} So one of the
所以， acquire 函数首先做的是，

2249
01:14:13,750 --> 01:14:16,300
0,180 180,450 450,780 780,1260
first things that the

2250
01:14:16,300 --> 01:14:19,030
0,300 300,570 570,1050 1350,2160 2160,2730
acquire function does {} is|
|

2251
01:14:19,030 --> 01:14:21,920
0,1140 1170,1500 1500,1800 1830,2430
it turns off interrupts.|
它关闭了中断。|

2252
01:14:22,900 --> 01:14:24,610
0,570 900,1110 1110,1230 1230,1440 1440,1710
And it's really good to
最好能理解为什么是这样，

2253
01:14:24,610 --> 01:14:25,810
0,420 420,810 810,1020 1020,1110 1110,1200
understand why that is the

2254
01:14:25,810 --> 01:14:26,770
0,480 480,570 570,720 720,810 810,960
case| and so for now
|现在，我回到 UART 示例代码。

2255
01:14:26,770 --> 01:14:27,670
0,240 240,360 360,480 480,780 780,900
I'm gonna go back to

2256
01:14:27,670 --> 01:14:29,680
0,90 90,600 630,1020 1020,1470
{} uart example code.|
|

2257
01:14:29,680 --> 01:14:30,550
0,360 360,480 480,630 630,690 690,870
And you think a little
你可以稍微想一想这个。

2258
01:14:30,550 --> 01:14:31,800
0,150 150,360 360,750
bit about this.|
|

2259
01:14:31,800 --> 01:14:32,880
0,390 390,600 600,810 810,930 930,1080
{} And so we want
所以我们要考虑一下这个情况，

2260
01:14:32,880 --> 01:14:34,200
0,240 240,450 450,600 600,690 690,1320
to think about the case,|
|

2261
01:14:34,380 --> 01:14:36,940
0,1020 1050,1950
were {}
是 acquire 可能没有正确实现，

2262
01:14:37,120 --> 01:14:38,980
0,480 480,570 570,1020 1050,1380 1380,1860
acquire is actually maybe incorrectly

2263
01:14:38,980 --> 01:14:40,300
0,450 450,720 720,1020 1020,1200 1200,1320
implemented,| does not turn off
|没有关闭中断，

2264
01:14:40,300 --> 01:14:43,060
0,900 1020,1410 1860,2100 2220,2670 2670,2760
interrupts,| so the way to
|所以思考这个问题的方法是，

2265
01:14:43,060 --> 01:14:44,050
0,180 180,450 450,660 660,900 900,990
think about this is| if
|如果我们到 uartputc ，

2266
01:14:44,050 --> 01:14:45,700
0,90 90,240 240,390 390,990 990,1650
we go to {uartputc -},|
|

2267
01:14:46,090 --> 01:14:47,770
0,330 330,930 960,1290 1290,1380 1380,1680
and here let's say uartputc
我们假设 uartputc 运行，

2268
01:14:48,160 --> 01:14:49,140
0,510
runs,|
|

2269
01:14:49,170 --> 01:14:52,470
0,810 1290,1980 1980,2580 2580,2730 2730,3300
and {} acquires the lock,|
并且获得了锁，|

2270
01:14:53,520 --> 01:14:54,780
0,210 210,330 330,540 540,1020 1020,1260
and but does not turn
但是不关闭中断，

2271
01:14:54,780 --> 01:14:56,340
0,120 120,690 750,1020 1020,1140 1140,1560
off interrupts,| what can happen.|
|会发生什么。|

2272
01:15:03,050 --> 01:15:04,220
0,240 240,600 600,630 630,840 840,1170
Give everybody a couple seconds
给大家几秒钟考虑一下，

2273
01:15:04,220 --> 01:15:05,540
0,90 90,240 240,510 510,750 840,1320
to think about it {},|
|

2274
01:15:05,930 --> 01:15:07,040
0,210 210,390 390,540 540,630 630,1110
if you have an idea|
如果你有想法|

2275
01:15:07,040 --> 01:15:07,850
0,180 180,480 480,540 540,720 720,810
or why it might be
或者为什么它可能是错误的，|

2276
01:15:07,850 --> 01:15:10,520
0,450 450,1110 1530,2100
wrong,| like jumpin.|
|可以直接说。|

2277
01:15:18,340 --> 01:15:20,680
0,390 390,1470 1590,1800 1800,1950 1950,2340
{} Perhaps, it could be
或许，它可以被中断，

2278
01:15:20,710 --> 01:15:23,770
0,270 270,810 810,1500 1650,2520 2550,3060
{} interrupted,| because of, {}
|因为这个锁，然后其他事情发生了，

2279
01:15:24,070 --> 01:15:26,080
0,480 480,570 570,810 840,1590 1860,2010
because of the [lock] and

2280
01:15:26,080 --> 01:15:28,900
0,180 180,990 1260,2160 2400,2640 2640,2820
then something happens| and it
|它也需要打印一些其他的东西，

2281
01:15:28,900 --> 01:15:31,090
0,210 210,330 330,600 600,1380 1530,2190
needs to print something else,|
|

2282
01:15:31,090 --> 01:15:31,900
0,180 180,240 240,570 570,690 690,810
and it tries to do
它试图再做一次 uartputc ，

2283
01:15:31,900 --> 01:15:33,820
0,420 870,1500
uartputc again,|
|

2284
01:15:33,970 --> 01:15:35,530
0,210 210,540 540,660 660,900 900,1560
{but,the} lock is already taken.|
但是锁已经被拿走了。|

2285
01:15:35,740 --> 01:15:36,700
0,330 330,480 480,540 540,600 600,960
That might be a possible
这是一种可能的情况，

2286
01:15:36,700 --> 01:15:38,230
0,480 480,1290 1320,1410 1410,1470 1470,1530
scenario,| {} there is a
|有一个更直接的例子。

2287
01:15:38,230 --> 01:15:39,880
0,270 270,420 420,930 960,1530 1530,1650
much more direct example for

2288
01:15:39,880 --> 01:15:40,840
0,420
this.|
|

2289
01:15:40,840 --> 01:15:41,740
0,150 150,390 390,630 630,810 810,900
So let's say {uartputc -
我们假设 uartputc 得到了锁，

2290
01:15:41,740 --> 01:15:44,380
0,210 210,750 750,1620 2070,2520 2520,2640
- -} {grab,the,lock}| and uart
|而 UART 正忙于传输一些字符。

2291
01:15:44,380 --> 01:15:46,690
0,300 300,660 690,1590 1590,1740 1740,2310
were busy transmitting some character.|
|

2292
01:15:47,590 --> 01:15:49,060
0,180 180,720 720,840 840,1020 1020,1470
So when {uart -} done
那么当 UART 完成了传输字符，

2293
01:15:49,090 --> 01:15:50,500
0,450 450,840 840,1140 1140,1290 1290,1410
or transmitting character,| what does
|它要做什么。

2294
01:15:50,500 --> 01:15:51,440
0,60 60,390
it do.|
|

2295
01:15:53,160 --> 01:15:54,330
0,300 300,570 570,660 660,750 750,1170
It causes {} an interrupt
它会导致中断，

2296
01:15:54,330 --> 01:15:57,620
0,420 900,1500 1530,1860 1860,2760
correct| and {uartintr,runs -},|
|并且 uartintr 运行，|

2297
01:15:57,940 --> 01:15:59,560
0,330 330,480 480,630 630,1200 1200,1620
what {uartintr - -} do,|
uartintr 会做什么，|

2298
01:16:00,740 --> 01:16:02,300
0,180 180,480 480,540 540,930 930,1560
it grabs the same lock,|
它获取同一把锁，|

2299
01:16:02,450 --> 01:16:03,680
0,150 150,300 300,720 720,870 870,1230
you know that the uartputc
uartputc 已经持有了，

2300
01:16:03,680 --> 01:16:04,940
0,540 600,840 840,960 960,1110 1110,1260
{is,holding} right,| so what will
|那么，这里会发生什么，

2301
01:16:04,940 --> 01:16:06,590
0,270 270,660 1140,1320 1320,1470 1470,1650
happen here,| if there's only
|如果只有一个 CPU ，

2302
01:16:06,590 --> 01:16:08,210
0,210 210,720 990,1260 1260,1410 1410,1620
one CPU| and so there's
|没有其他 CPU 可以运行这个中断。

2303
01:16:08,210 --> 01:16:09,440
0,150 150,360 360,720 720,990 990,1230
no other CPU where this

2304
01:16:09,440 --> 01:16:11,100
0,510 510,630 630,780 780,1140
interrupt could be running.|
|

2305
01:16:12,460 --> 01:16:13,420
0,210 210,300 300,390 390,450 450,960
Well, we have a deadlock
我们现在死锁了，

2306
01:16:13,450 --> 01:16:15,840
0,210 210,720 990,1800
right,| because the
|因为当前 CPU 持有 uartputc 的锁，

2307
01:16:15,840 --> 01:16:17,430
0,270 270,600 600,810 810,1470 1470,1590
current CPU is holding the

2308
01:16:17,430 --> 01:16:18,780
0,510 540,720 720,900 900,1020 1020,1350
lock as part of {uartputc

2309
01:16:18,810 --> 01:16:21,360
0,690 750,1080 1080,1680 1710,1860 1860,2550
-},| then later the interrupt
|然后，后面传入的中断，

2310
01:16:21,360 --> 01:16:22,470
0,120 120,390 390,750 900,1050 1050,1110
that came in| and the
|它做的第一件事就是，

2311
01:16:22,470 --> 01:16:23,250
0,210 210,360 360,510 510,720 720,780
first thing it tries to

2312
01:16:23,250 --> 01:16:24,000
0,120 120,240 240,420 420,720 720,750
do is| actually acquire a
|获取已经持有的锁。

2313
01:16:24,000 --> 01:16:25,640
0,240 240,390 390,690 690,1140
lock has already held.|
|

2314
01:16:25,640 --> 01:16:26,690
0,150 150,420 420,660 660,840 840,1050
In fact, in the case
实际上，在 xv6 的情况下，你会得到一个 panic ，

2315
01:16:26,690 --> 01:16:27,980
0,90 90,690 690,780 780,1140 1140,1290
of xv6, you will get

2316
01:16:27,980 --> 01:16:29,240
0,60 60,570 660,1110 1110,1200 1200,1260
a panic,| because you know
|因为相同的 CPU ，

2317
01:16:29,240 --> 01:16:31,040
0,120 120,360 360,1050 1320,1710 1710,1800
the same CPU,| {} is
|正在再次尝试获取相同的锁。

2318
01:16:31,040 --> 01:16:31,940
0,210 210,450 450,510 510,810 810,900
actually trying to acquire the

2319
01:16:31,940 --> 01:16:33,320
0,270 270,480 480,840
same lock again.|
|

2320
01:16:37,460 --> 01:16:39,140
0,510 630,1140 1140,1260 1260,1350 1350,1680
So basically you know what
所以，获得自旋锁，

2321
01:16:39,170 --> 01:16:41,150
0,840 840,1230 1230,1560 1560,1830 1830,1980
acquire spinlock,| deals with sort
|处理了两种不同类型的并发，

2322
01:16:41,150 --> 01:16:42,230
0,90 90,420 420,750 750,990 990,1080
of two different types of

2323
01:16:42,230 --> 01:16:43,880
0,690 810,1290 1290,1440 1440,1590 1590,1650
concurrency,| one they're sort of
|其一，它们是两个不同 CPU 之间的并发，

2324
01:16:43,880 --> 01:16:45,410
0,420 420,690 690,810 810,1110 1110,1530
concurrency between two different {CPUs

2325
01:16:45,410 --> 01:16:46,700
0,300 570,810 810,870 870,1020 1020,1290
-},| and {we,get} make sure
|而且我们必须保证，|

2326
01:16:46,700 --> 01:16:47,810
0,180 180,240 240,600 600,750 750,1110
like for example is| the
|中断函数运行在不同的 CPU 上，

2327
01:16:47,870 --> 01:16:49,400
0,600 600,990 990,1320 1320,1440 1440,1530
interrupt function runs on a

2328
01:16:49,400 --> 01:16:51,170
0,330 330,840 1020,1230 1230,1620 1620,1770
different CPU,| {you,know} basically we're
|一般我们不会重新安排传输缓冲区，

2329
01:16:51,170 --> 01:16:52,040
0,180 180,300 300,720 720,810 810,870
don't get arrange on the

2330
01:16:52,040 --> 01:16:53,380
0,450 450,900
transmission buffer,|
|

2331
01:16:53,440 --> 01:16:54,250
0,210 210,390 390,480 480,600 600,810
{} but if they run
但是如果它们在同一个 CPU 上运行，

2332
01:16:54,250 --> 01:16:55,210
0,90 90,180 180,450 450,900 900,960
in the same CPU,| we're
|我们要确保它仍然是原子的，

2333
01:16:55,210 --> 01:16:55,900
0,120 120,180 180,330 330,540 540,690
going to make sure that

2334
01:16:55,900 --> 01:16:57,550
0,120 120,360 360,420 420,930 1320,1650
it's still {atomic -} {}|
|

2335
01:16:57,550 --> 01:16:58,330
0,180 180,360 360,450 450,600 600,780
and that is not being
它不会被中断，

2336
01:16:58,330 --> 01:16:59,770
0,510 510,630 630,1080 1080,1230 1230,1440
interrupted| and therefore we actually
|所以，我们在 acquire 中关闭了中断。

2337
01:16:59,770 --> 01:17:00,610
0,210 210,270 270,540 540,600 600,840
turn the {interrupts - -}

2338
01:17:00,610 --> 01:17:02,300
0,300 330,1170
off {in,acquire}.|
|

2339
01:17:03,360 --> 01:17:04,470
0,240 240,360 360,720 720,930 930,1110
And they're only turned on
它们只有在 release 结束时才会再次打开，

2340
01:17:04,470 --> 01:17:05,790
0,480 630,900 900,1050 1050,1170 1170,1320
again at the end of

2341
01:17:05,790 --> 01:17:08,310
0,660 990,1740 1740,2160 2160,2250 2250,2520
release,| {} when the lock
|当锁被释放的时候，

2342
01:17:08,310 --> 01:17:09,690
0,270 270,570 570,750 750,1260 1260,1380
actually has been released,| at
|在这一点上，再次看到，

2343
01:17:09,690 --> 01:17:10,890
0,180 180,360 360,480 480,810 810,1200
that point is {see,it} again,|
|

2344
01:17:10,920 --> 01:17:11,550
0,90 90,210 210,330 330,510 510,630
you know to take these
接收中断，

2345
01:17:11,550 --> 01:17:14,220
0,540 720,1200 1200,1470 1470,1740 1740,2670
interrupts,| because lock actually is
|因为锁不会再被释放，

2346
01:17:14,220 --> 01:17:15,480
0,210 210,510 510,870
not released anymore,|
|

2347
01:17:16,190 --> 01:17:17,390
0,300 300,510 510,840 840,990 990,1200
not acquire holding it, not
不是 acquire 持有它，不再持有。

2348
01:17:17,390 --> 01:17:18,540
0,240 240,600
held anymore.|
|

2349
01:17:18,940 --> 01:17:20,420
0,270 270,390 390,540 540,870
Does that make sense?|
这能理解吗？|

2350
01:17:28,560 --> 01:17:30,240
0,300 300,450 450,720 720,1320 1350,1680
Okay, there's one more subtle
好的，在这个实现中还有一件更微妙的事情，

2351
01:17:30,240 --> 01:17:32,880
0,360 360,1170 1260,1650 1680,2490 2490,2640
thing in this implementation,| that
|我想说一下，

2352
01:17:32,880 --> 01:17:33,900
0,90 90,300 300,360 360,570 570,1020
I want to talk about,|
|

2353
01:17:34,260 --> 01:17:36,800
0,840 1290,2010
{} and
而且我们需要处理。

2354
01:17:36,860 --> 01:17:38,660
0,660 1050,1380 1380,1530 1530,1620 1620,1800
{} we need to deal

2355
01:17:38,660 --> 01:17:39,660
0,450
with.|
|

2356
01:17:39,800 --> 01:17:41,120
0,900

2357
01:17:43,200 --> 01:17:45,240
0,150 150,420 420,750 780,1560
And that is {}
那就是内存排序。

2358
01:17:45,270 --> 01:17:46,880
0,360 360,840
memory ordering.|
|

2359
01:17:53,810 --> 01:17:56,300
0,480 480,1230 1500,2130 2130,2340 2340,2490
So {} {for,example} you think
比如，你认为锁是，

2360
01:17:56,300 --> 01:17:58,550
0,570 600,1200 1200,1560 1560,1800 1800,2250
about lock is,| let's say,
|比如， acquire locked 是 1 ，

2361
01:17:59,500 --> 01:18:01,900
0,540 540,690 690,1170 1500,1710 1710,2400
acquires its locked to one,|
|

2362
01:18:02,290 --> 01:18:03,610
0,630 660,960 960,1080 1080,1260 1260,1320
{} maybe we have a
也许我们有一个临界区，

2363
01:18:03,610 --> 01:18:04,870
0,270 270,660 660,750 750,1050 1050,1260
critical section,| in which you
|x<-x+1 ，

2364
01:18:04,870 --> 01:18:07,840
0,690 690,900 900,1170 1170,1680 2070,2970
x x plus one| and
|然后， release 将 locked 设置为 0 。

2365
01:18:07,870 --> 01:18:12,220
0,1050 1050,2550 3030,3690 3690,4080 4080,4350
{} {then,acquire} release {you,know,set} locked

2366
01:18:12,220 --> 01:18:13,060
0,360
zero.|
|

2367
01:18:13,260 --> 01:18:14,160
0,270 270,510 510,690 690,750 750,900
So {you,know} sort of think
所以，考虑一下指令方案，

2368
01:18:14,160 --> 01:18:15,750
0,210 210,750 750,1110 1110,1350 1350,1590
about instruction scheme,| that's being
|它是在特定的 CPU 上执行的，

2369
01:18:15,750 --> 01:18:17,400
0,510 510,630 630,690 690,1020 1020,1650
executed on a particular CPU,|
|

2370
01:18:17,550 --> 01:18:18,450
0,210 210,360 360,450 450,660 660,900
you know so these are
这些是正在执行的指令。

2371
01:18:18,450 --> 01:18:19,890
0,120 120,570 570,660 660,870 870,1440
the instructions are being executed,

2372
01:18:19,950 --> 01:18:20,780
0,330
right.|
|

2373
01:18:22,110 --> 01:18:23,550
0,420 420,810 810,900 900,1320 1320,1440
Now, if the code were
现在，如果代码仅仅是顺序的。

2374
01:18:23,550 --> 01:18:26,160
0,180 180,1050 1110,1350 1350,2070
just purely {} sequential.|
|

2375
01:18:26,800 --> 01:18:30,260
0,1020 1260,2010 2010,2820

2376
01:18:30,490 --> 01:18:34,990
0,270 270,810 810,1860 2160,3090 3570,4500
The compiler or the processor
编译器或处理器可能会重新排序指令，

2377
01:18:35,020 --> 01:18:36,790
0,480 480,690 690,1050 1050,1650 1650,1770
could actually reorder instructions,| you
|为了获得更好的性能，

2378
01:18:36,790 --> 01:18:37,660
0,240 240,450 450,540 540,660 660,870
know just to get better

2379
01:18:37,660 --> 01:18:41,920
0,690 1020,1710 1830,2670 3000,3780 3780,4260
performance,| for example, {} if
|比如，如果它是顺序流，

2380
01:18:41,920 --> 01:18:43,120
0,120 120,270 270,330 330,780 780,1200
it were a sequential stream,|
|

2381
01:18:43,120 --> 01:18:44,140
0,240 240,330 330,480 480,900 900,1020
would it be okay to
可以把这个指令移到后面去吗？

2382
01:18:44,140 --> 01:18:46,180
0,330 330,510 510,1170 1200,1350 1350,2040
move this instruction to afterwards.|
|

2383
01:18:49,170 --> 01:18:51,060
0,300 300,480 480,930 930,1140 1140,1890
We don't change the correctness
我们不会改变单一执行流程的正确性。

2384
01:18:51,120 --> 01:18:52,380
0,330 330,510 510,840 840,1140 1140,1260
of the single stream of

2385
01:18:52,380 --> 01:18:53,600
0,630
execution.|
|

2386
01:18:58,180 --> 01:18:59,620
0,150 150,420 420,720 750,1170 1170,1440
{You,know}, not really,| because lock
你知道，不是很清楚，|因为锁是完全独立的，

2387
01:18:59,620 --> 01:19:00,640
0,60 60,300 300,360 360,630 630,1020
the next are totally independent

2388
01:19:00,640 --> 01:19:01,720
0,90 90,210 210,540 540,810 810,1080
of each other,| there's no
|与它无关，

2389
01:19:02,050 --> 01:19:03,280
0,570 570,720 720,900 900,1110 1110,1230
relation to it,| would be
|如果是顺序执行就完全没问题，

2390
01:19:03,280 --> 01:19:04,480
0,390 390,720 720,840 840,960 960,1200
perfectly fine if it were

2391
01:19:04,480 --> 01:19:06,460
0,90 90,600 600,1230 1530,1860 1860,1980
a sequential execution,| that the
|将 x 移动到 locked 0 之后。

2392
01:19:06,460 --> 01:19:08,470
0,330 330,660 660,1020 1020,1350 1350,2010
x has moved after locked

2393
01:19:08,470 --> 01:19:10,500
0,690 1110,1560
{} zero.|
|

2394
01:19:10,620 --> 01:19:11,670
0,330 330,540 540,810 810,930 930,1050
{} So that you know
所以，在单一的串行执行中，

2395
01:19:11,670 --> 01:19:13,080
0,150 150,210 210,810
on the single,

2396
01:19:14,340 --> 01:19:16,620
0,420 420,870 870,1680
single serial execution,|
|

2397
01:19:18,140 --> 01:19:19,600
0,210 210,690
that's okay.|
这是对的。|

2398
01:19:23,500 --> 01:19:25,630
0,330 330,660 660,1080 1080,1530 1530,2130
And {in,fact} and {in,fact} processors
实际上，处理器都是这样做的，

2399
01:19:25,630 --> 01:19:26,290
0,150 150,300 300,450 450,570 570,660
{you,know} do this all the

2400
01:19:26,290 --> 01:19:27,250
0,480 480,570 570,690 690,840 840,960
time,| you know they do
|它们[]地执行任务，

2401
01:19:27,250 --> 01:19:30,070
0,600 600,1050 1050,1500 1920,2310 2310,2820
[] execute stuff,| we're expected
|我们期望执行指令，

2402
01:19:30,070 --> 01:19:31,540
0,60 60,450 450,1050 1050,1290 1290,1470
to execute instructions| and so
|这会导致这些指令重新排序。

2403
01:19:31,540 --> 01:19:32,740
0,210 210,360 360,780 780,840 840,1200
that can result in basically

2404
01:19:32,740 --> 01:19:34,760
0,180 180,720 720,870 870,1560
these instructions {re-orderings -}.|
|

2405
01:19:34,760 --> 01:19:36,890
0,660 720,1350 1440,1830 1830,2010 2010,2130
{} The compiler does it
编译器也会这样做，

2406
01:19:36,890 --> 01:19:38,720
0,540 630,840 840,960 960,1710 1710,1830
too,| may be optimized some
|可能优化一些代码路径，

2407
01:19:38,720 --> 01:19:39,830
0,240 240,570 570,690 690,930 930,1110
code path| and also will
|并且重新排序指令，

2408
01:19:39,830 --> 01:19:41,600
0,330 330,870 870,990 990,1380 1380,1770
reorder instructions,| as long as
|结果是相同的串行执行。

2409
01:19:41,630 --> 01:19:42,530
0,90 90,300 300,780 780,840 840,900
you know results in the

2410
01:19:42,530 --> 01:19:44,280
0,300 300,660 660,1200
same serial execution.|
|

2411
01:19:44,710 --> 01:19:46,390
0,180 180,570 570,840 840,1230 1230,1680
But clearly during concurrent execution
但是，很明显在并行执行的过程中这是一场灾难，

2412
01:19:46,390 --> 01:19:48,250
0,360 360,1020 1050,1290 1290,1560 1560,1860
{this,be} disaster, right,| because if
|因为如果获取了锁，

2413
01:19:48,460 --> 01:19:50,380
0,540 540,630 630,1380
lock are acquire,|
|

2414
01:19:51,320 --> 01:19:52,940
0,510 510,660 660,810 810,1050 1050,1620
and this was our release,|
这是我们的 release ，|

2415
01:19:54,180 --> 01:19:55,290
0,150 150,450 450,630 630,750 750,1110
and basically what we've done,|
我们所做的，|

2416
01:19:55,290 --> 01:19:56,130
0,90 90,330 330,450 450,510 510,840
we move {} the critical
我们将临界区间移出了 acquire 区间，

2417
01:19:56,130 --> 01:19:58,770
0,360 360,1020 1020,1170 1170,1560 1590,2640
section outside of the the

2418
01:19:58,860 --> 01:20:00,420
0,480 480,810 810,960 960,1140 1170,1560
acquire region,| {that,would} be totally
|这完全是错误的。

2419
01:20:00,420 --> 01:20:01,520
0,510
incorrect.|
|

2420
01:20:01,580 --> 01:20:03,020
0,180 180,360 360,930
So that's wrong,
所以，这在并发执行中是错误的。

2421
01:20:04,110 --> 01:20:05,940
0,660 660,810 810,870 870,1260 1260,1830
wrong in a concurrent execution.|
|

2422
01:20:12,780 --> 01:20:14,010
0,150 150,480 480,570 570,660 660,1230
And so you know to
所以，为了禁止或告诉编译器和硬件不要这么做，

2423
01:20:14,040 --> 01:20:15,630
0,780 780,900 900,1140 1140,1200 1200,1590
forbid or tell the compiler

2424
01:20:15,630 --> 01:20:17,190
0,90 90,510 510,1050 1110,1290 1290,1560
and hardware not to do

2425
01:20:17,190 --> 01:20:19,800
0,390 720,1350 1650,2220 2220,2460 2460,2610
this,| {} there's something that's
|有一个叫做内存屏障的东西，

2426
01:20:19,800 --> 01:20:21,930
0,390 390,930 930,1500 1500,1950 1950,2130
called {} memory fence| or
|或者某个 synchronize ，

2427
01:20:21,930 --> 01:20:23,820
0,210 210,360 360,1140 1440,1710 1710,1890
something that synchronize,| {} there's
|这个指令表示，

2428
01:20:23,820 --> 01:20:25,800
0,450 450,780 780,1050 1050,1260 1290,1980
instructions basically says,| like any
|在这个点之前的加载或保存，

2429
01:20:25,830 --> 01:20:27,150
0,330 330,390 390,750 750,1140 1140,1320
loads or stores before this

2430
01:20:27,150 --> 01:20:29,220
0,510 750,990 990,1140 1140,1680 1680,2070
point,| you are not allowed
|不允许移动到这一点之后。

2431
01:20:29,220 --> 01:20:30,540
0,60 60,360 360,750 750,900 900,1320
to move beyond this point.|
|

2432
01:20:31,320 --> 01:20:32,700
0,240 240,360 360,780 780,990 990,1380
And so release has this
所以 release 有这个， acquire 也有这个，

2433
01:20:32,700 --> 01:20:34,860
0,570 570,1170 1170,1590 1590,1770 1770,2160
and {} acquire has this|
|

2434
01:20:35,190 --> 01:20:36,150
0,150 150,300 300,390 390,750 750,960
and so for example, this
比如，这个 x<-x+1 ，

2435
01:20:36,150 --> 01:20:37,350
0,210 210,390 390,570 570,750 750,1200
x plus, x plus one,|
|

2436
01:20:37,380 --> 01:20:39,900
0,150 150,330 330,720 1020,1710 1710,2520
if that was {} updated
如果这个更新是在 acquire 之后和 release 之前，

2437
01:20:39,900 --> 01:20:41,250
0,390 390,510 510,960 960,1050 1050,1350
after the acquire and before

2438
01:20:41,250 --> 01:20:42,480
0,60 60,630 660,870 870,1050 1050,1230
the release,| the x plus
|x<-x+1 必须留在，

2439
01:20:42,480 --> 01:20:43,980
0,210 210,360 360,630 660,1050 1050,1500
x plus one has {to,stay}|
|

2440
01:20:43,980 --> 01:20:45,690
0,840 870,990 990,1140 1140,1350 1350,1710
before you know this particular
这个内存同步点之前。

2441
01:20:45,690 --> 01:20:47,320
0,270 270,810 810,1200
memory synchronization point.|
|

2442
01:20:47,410 --> 01:20:48,700
0,300 300,630 630,780 780,1020 1020,1290
And so it will not
所以不会，

2443
01:20:48,700 --> 01:20:49,570
0,270 270,480 480,600 600,720 720,870
be,| there will be no
|不会有内存重排的问题，

2444
01:20:49,570 --> 01:20:52,240
0,510 720,1410 1410,1800 1800,2310 2340,2670
trouble {} with {} memory

2445
01:20:52,240 --> 01:20:53,620
0,390 690,990 990,1170 1170,1260 1260,1380
ordering,| so this is the
|这就是 __sync_synchronize 在这的原因，

2446
01:20:53,620 --> 01:20:55,750
0,450 450,930 930,1170 1170,1740 1740,2130
reason why {} __sync_synchronize there,|
|

2447
01:20:55,900 --> 01:20:58,360
0,930 930,1260 1290,1950 1950,2070 2070,2460
{both,in} the release and also
无论是在 release 还是在 acquire 。

2448
01:20:58,360 --> 01:20:59,530
0,180 180,420 420,570 570,690 690,1170
there's one in the acquire.|
|

2449
01:21:03,560 --> 01:21:04,840
0,90 90,210 210,360 360,690
Does that make sense?|
这能理解吗？|

2450
01:21:06,230 --> 01:21:07,670
0,180 180,420 420,600 600,690 690,1440
{} I have a question.|
我有一个问题。|

2451
01:21:08,880 --> 01:21:11,460
0,750 990,1380 1380,1830 2160,2370 2370,2580
{} Is it, is it
是不是按照惯例，

2452
01:21:11,460 --> 01:21:14,250
0,210 210,990 990,1350 1350,1530 1530,2790
by convention| that the start
|这个[]的开始，

2453
01:21:14,280 --> 01:21:15,760
0,930
of

2454
01:21:15,880 --> 01:21:17,240
0,810
{}

2455
01:21:17,300 --> 01:21:19,340
0,330 330,990 1020,1260 1260,1440 1440,2040
the [],| so I guess
|所以，我想编译器可以搞清楚，

2456
01:21:19,370 --> 01:21:21,290
0,540 540,930 930,1080 1230,1410 1410,1920
I guess the the compiler

2457
01:21:21,290 --> 01:21:23,090
0,720 750,1230 1230,1380 1380,1560 1560,1800
could figure out,| that there
|在获取锁之前，有一条指令，

2458
01:21:23,090 --> 01:21:25,130
0,240 240,690 690,1380 1380,1920 1920,2040
is an instruction before the

2459
01:21:25,130 --> 01:21:27,050
0,300 300,450 450,870 900,1680 1680,1920
lock is even acquire| and
|它可以被移动到锁释放之后。

2460
01:21:27,050 --> 01:21:28,700
0,540 780,990 990,1230 1230,1380 1380,1650
that it can be just

2461
01:21:28,700 --> 01:21:29,750
0,90 90,300 300,600 600,960 960,1050
as well moved after the

2462
01:21:29,750 --> 01:21:32,500
0,270 270,390 390,1110
lock is released.|
|

2463
01:21:32,830 --> 01:21:34,840
0,390 390,630 630,1320 1320,1770 1770,2010
Can that happen,| or will
这会发生吗，|或者它会遇到屏障。

2464
01:21:34,840 --> 01:21:36,670
0,270 300,930 930,1110 1110,1650 1650,1830
it encounter a barrier and

2465
01:21:36,670 --> 01:21:38,410
0,240 240,540 630,1320 1320,1530 1530,1740
see that.| You {will,see}, you
|在这种情况下，

2466
01:21:38,410 --> 01:21:39,940
0,180 180,330 330,570 570,870 870,1530
know in this case,| {acquire,as}
|acquire 是一个屏障，

2467
01:21:39,940 --> 01:21:40,870
0,60 60,480 480,600 600,810 810,930
a barrier| and release as
|release 也是一个屏障，

2468
01:21:40,870 --> 01:21:42,100
0,60 60,570 570,750 750,1110 1110,1230
a barrier,| so anything that
|所以，任何在 locked 设置为 1 之前发生的事情，

2469
01:21:42,100 --> 01:21:44,350
0,300 300,690 690,1170 1200,1740 1740,2250
happened before locked {is,set,to} one|
|

2470
01:21:44,440 --> 01:21:46,000
0,240 240,510 510,840 840,1200 1440,1560
will happen before that,| it
会在它之前发生，|永远不会超过那个指令，

2471
01:21:46,000 --> 01:21:47,650
0,120 120,540 540,870 870,1080 1080,1650
will never pass that instruction,|
|

2472
01:21:47,680 --> 01:21:48,790
0,150 150,360 360,450 450,510 510,1110
so this is a barrier,|
这就是屏障，|

2473
01:21:48,910 --> 01:21:49,880
0,60 60,180 180,570
if you will,|
如果你愿意的话，|

2474
01:21:50,390 --> 01:21:52,160
0,270 270,660 660,1260
this barrier one,
这个是屏障一，这是屏障二。

2475
01:21:52,250 --> 01:21:53,330
0,150 150,300 300,360 360,750 750,1080
and this is barrier two.|
|

2476
01:21:55,520 --> 01:21:56,480
0,270 270,390 390,510 510,780 780,960
And so it means that
所以，这意味着在这之前的任何指令，留在这里，

2477
01:21:56,480 --> 01:21:58,370
0,150 150,540 540,930 930,1470 1500,1890
any instruction before here, stay

2478
01:21:58,370 --> 01:22:01,130
0,450 780,960 960,1470 1470,2160 2580,2760
here,| any instruction between what
|在之间的指令，会发生在 acquire 和 release 之间，

2479
01:22:01,130 --> 01:22:02,750
0,300 300,570 570,630 630,1170 1230,1620
happened between the two between

2480
01:22:02,750 --> 01:22:04,700
0,330 330,690 690,840 840,1320 1320,1950
{acquire,and} release| and instruction after
|之后的指令，将留在 release 之后。

2481
01:22:04,910 --> 01:22:06,530
0,300 300,510 510,1020 1020,1140 1140,1620
will stay after the release.|
|

2482
01:22:07,950 --> 01:22:09,120
0,600
Okay.|
好的。|

2483
01:22:11,110 --> 01:22:12,180
0,600
Okay?|
好的?|

2484
01:22:12,550 --> 01:22:14,230
0,210 210,330 330,450 450,750 750,1680
Okay so I'm running {}
好的，我的时间快到了，

2485
01:22:14,260 --> 01:22:15,910
0,210 210,870 900,1320 1320,1470 1470,1650
{close,to} {the,end},| {} so let
|所以让我来总结一下。

2486
01:22:15,910 --> 01:22:18,250
0,240 240,450 450,960 960,1350 1800,2340
me just actually {} {}

2487
01:22:18,490 --> 01:22:20,080
0,450 450,900
wrapup here.|
|

2488
01:22:27,710 --> 01:22:29,480
0,540 570,1230
So, {}
所以，对于锁，锁对正确性有好处，

2489
01:22:29,480 --> 01:22:31,250
0,90 90,570 600,720 720,1170 1500,1770
to locks, you know locks

2490
01:22:31,250 --> 01:22:32,920
0,60 60,240 240,360 360,960
are good for correctness,|
|

2491
01:22:40,370 --> 01:22:41,270
0,300 300,420 420,570 570,660 660,900
{} but can be bad
但可能会对性能造成不良影响。

2492
01:22:41,270 --> 01:22:42,740
0,120 120,780
for performance.|
|

2493
01:22:47,480 --> 01:22:48,920
0,600 690,990 990,1050 1050,1110 1110,1440
Which sort of a bummer
这是一种失望的局面，

2494
01:22:48,920 --> 01:22:49,910
0,240 240,480 480,570 570,720 720,990
correct,| because we are one
|因为我们使用锁的一个原因是，

2495
01:22:49,910 --> 01:22:51,470
0,300 300,450 450,1020 1050,1380 1380,1560
reason we actually got into

2496
01:22:51,470 --> 01:22:52,580
0,270 270,360 360,720 720,870 870,1110
locks is| basically to get
|为了在并行执行过程中保持正确，

2497
01:22:52,880 --> 01:22:55,160
0,390 390,690 690,1050 1050,1740 1740,2280
correct during parallel execution,| but
|但是锁实际上限制了并行执行。

2498
01:22:55,160 --> 01:22:58,130
0,450 450,660 660,930 930,1440 2250,2970
locks actually limit parallel execution.|
|

2499
01:22:58,850 --> 01:23:01,040
0,420 930,1230 1230,1680 1740,1890 1890,2190
{} That's one and two
这是一个或两个锁使编程复杂化。

2500
01:23:01,040 --> 01:23:02,760
0,330 330,1080
locks complicate

2501
01:23:05,460 --> 01:23:06,980
0,900
programming.|
|

2502
01:23:07,290 --> 01:23:08,610
0,270 270,360 360,780 780,1170 1170,1320
And you will experience that
你会在一些实验里体验到，

2503
01:23:08,610 --> 01:23:09,420
0,60 60,300 300,390 390,510 510,810
in some of the lab,|
|

2504
01:23:09,420 --> 01:23:10,080
0,120 120,210 210,330 330,420 420,660
that we're going to be
从现在开始，我们将要做的事情，

2505
01:23:10,080 --> 01:23:11,190
0,300 300,420 420,690 690,810 810,1110
doing, in fact from now

2506
01:23:11,190 --> 01:23:12,570
0,240 240,390 390,750 750,990 990,1380
on,| we'll see lock shown
|我们会看到锁一直会出现，

2507
01:23:12,570 --> 01:23:14,310
0,330 330,450 450,900 1320,1620 1620,1740
all the time,| and that
|这至少会给我们一些思考，

2508
01:23:14,310 --> 01:23:16,320
0,90 90,270 270,480 480,1110 1380,2010
will give us {} least

2509
01:23:16,320 --> 01:23:18,300
0,60 60,330 330,1080 1140,1500 1500,1980
you know {} some thought,|
|

2510
01:23:18,300 --> 01:23:18,720
0,60 60,150 150,240 240,360 360,420
you know it's going to
有必要理解为什么锁在那里，

2511
01:23:18,720 --> 01:23:20,250
0,90 90,600 600,690 690,1110 1110,1530
be necessary to understand why

2512
01:23:20,250 --> 01:23:21,480
0,90 90,330 330,390 390,810 810,1230
the locks are there| and
|以及它们保护的是什么。

2513
01:23:21,480 --> 01:23:22,700
0,180 180,300 300,750
what they protect.|
|

2514
01:23:22,700 --> 01:23:23,930
0,510 510,720 720,960 960,1140 1140,1230
{} And there sort of
如果你做并行编程，这是一种内在的，

2515
01:23:23,930 --> 01:23:25,520
0,690 810,1020 1020,1200 1200,1440 1440,1590
inherent, {} if you do

2516
01:23:25,520 --> 01:23:27,590
0,330 330,900 1260,1560 1560,1920 1920,2070
parallel programming,| {} that you
|你需要使用锁。

2517
01:23:27,590 --> 01:23:29,700
0,210 210,300 300,480 480,1620
need to use locks.|
|

2518
01:23:29,880 --> 01:23:31,830
0,480 780,1350 1530,1740 1740,1860 1860,1950
And so you know if
所以，如果你想避免锁带来的复杂性，

2519
01:23:31,830 --> 01:23:32,610
0,90 90,240 240,300 300,720 720,780
you want to avoid the

2520
01:23:32,610 --> 01:23:34,260
0,630 630,750 750,870 870,1230 1230,1650
complications due to locks,| you
|你可以做几件事，

2521
01:23:34,260 --> 01:23:35,100
0,330 330,390 390,600 600,780 780,840
know a couple things you

2522
01:23:35,100 --> 01:23:36,420
0,120 120,420 450,540 540,810 1050,1320
could do,| you know don't
|不要分享它，除非必须这么做。

2523
01:23:36,420 --> 01:23:37,200
0,270 270,330 330,420 420,600 600,780
share it, you don't have

2524
01:23:37,200 --> 01:23:38,100
0,330
to.|
|

2525
01:23:42,860 --> 01:23:43,640
0,210 210,300 300,450 450,570 570,780
If you don't have shared
如果你没有共享数据结构，

2526
01:23:43,640 --> 01:23:45,040
0,210 210,840
data structures,|
|

2527
01:23:46,340 --> 01:23:48,110
0,360 360,570 570,900 900,1260 1260,1770
these race conditions cannot happen,|
这些竞态条件就不会发生，|

2528
01:23:48,350 --> 01:23:50,060
0,480 480,630 630,780 780,1350 1350,1710
{} and so there and
所以这里你不需要锁，

2529
01:23:50,060 --> 01:23:51,020
0,180 180,540 540,690 690,810 810,960
so you you don't need

2530
01:23:51,020 --> 01:23:52,040
0,480 480,600 600,720 720,870 870,1020
locks| and so you don't
|你不需要这种复杂的编程。

2531
01:23:52,040 --> 01:23:53,940
0,150 150,300 300,750 750,1350
need this complicated programming.|
|

2532
01:23:54,000 --> 01:23:55,410
0,540 540,780 780,870 870,1020 1020,1410
{} But you know typically
但是，通常你会有一些共享的数据结构，

2533
01:23:55,410 --> 01:23:56,160
0,90 90,210 210,420 420,540 540,750
you will have some shared

2534
01:23:56,160 --> 01:23:57,420
0,210 210,600 600,660 660,780 780,1260
data structures,| you will do,
|你会需要锁，

2535
01:23:57,420 --> 01:23:58,920
0,570 600,690 690,810 810,1020 1020,1500
{} you will need locks|
|

2536
01:23:59,100 --> 01:24:00,300
0,360 360,420 420,570 570,780 810,1200
and I think the thing
我认为要做的事情是从粗粒度开始，

2537
01:24:00,300 --> 01:24:01,050
0,90 90,210 210,360 360,630 630,750
to do is start with

2538
01:24:01,050 --> 01:24:02,340
0,270 270,780
{coarse-grained -},|
|

2539
01:24:04,130 --> 01:24:05,840
0,210 210,360 360,720 720,1170
and then move to
然后在需要的时候转向细粒度，

2540
01:24:06,880 --> 01:24:08,830
0,360 360,750 780,1020 1020,1620 1620,1950
{fine-grained -} if necessary| based
|基于你的测量，

2541
01:24:08,830 --> 01:24:10,420
0,540 540,720 720,1230 1230,1440 1440,1590
on your measurements,| you want
|你要确保锁真的争用，

2542
01:24:10,420 --> 01:24:11,440
0,60 60,210 210,720 720,810 810,1020
to make determined to make

2543
01:24:11,440 --> 01:24:12,340
0,210 210,300 300,390 390,630 630,900
sure that the lock actually

2544
01:24:12,340 --> 01:24:14,020
0,810 810,1110 1110,1170 1170,1440 1440,1680
contended,| before you actually start
|在你开始重新设计之前。

2545
01:24:14,020 --> 01:24:15,200
0,600
redesigning.|
|

2546
01:24:15,480 --> 01:24:16,770
0,150 150,750 750,870 870,1050 1050,1290
And finally, you know use
最后，也可以使用竞争检测器。

2547
01:24:16,770 --> 01:24:18,660
0,270 270,870 870,1290
{a,race} detector to.|
|

2548
01:24:20,460 --> 01:24:21,270
0,120 120,300 300,390 390,540 540,810
And one of these race
这些竞争检测器工具会发现问题或竞态条件，

2549
01:24:21,270 --> 01:24:23,420
0,360 360,720 720,960 960,1470
detector tools actually finds

2550
01:24:23,760 --> 01:24:25,560
0,180 180,900 960,1410 1410,1620 1620,1800
{} problems {} or race

2551
01:24:25,560 --> 01:24:26,700
0,390 390,630 630,930 930,1080 1080,1140
conditions,| because you put the
|因为你把锁放错了，

2552
01:24:26,700 --> 01:24:27,480
0,270 270,330 330,420 420,690 690,780
locks in the wrong| or
|或者你将 acquire 和 release 放错了，

2553
01:24:27,480 --> 01:24:28,650
0,120 120,270 270,330 330,780 780,1170
you put the {acquire,and} release

2554
01:24:28,650 --> 01:24:29,490
0,90 90,150 150,420 420,720 720,840
in the wrong place| and
|而实际上，你还有竞争。

2555
01:24:29,490 --> 01:24:31,110
0,60 60,540 540,630 630,840 840,1620
in fact you still have

2556
01:24:31,320 --> 01:24:32,500
0,750
races.|
|

2557
01:24:32,770 --> 01:24:33,880
0,450 510,690 690,840 840,930 930,1110
Okay so there's a quick
好的，这是一个关于锁的快速介绍，

2558
01:24:33,880 --> 01:24:35,380
0,450 450,540 540,1020 1080,1320 1320,1500
introduction to locks,| we're going
|我们将会谈论更多关于锁的话题，

2559
01:24:35,380 --> 01:24:36,160
0,60 60,270 270,330 330,660 660,780
to talk a lot more

2560
01:24:36,160 --> 01:24:37,900
0,210 210,510 510,600 600,1320 1350,1740
about locks| in the basically
|在本学期的剩余课程中，

2561
01:24:37,900 --> 01:24:38,320
0,90 90,150 150,300 300,360 360,420
for the rest of the

2562
01:24:38,320 --> 01:24:39,340
0,330 330,450 450,540 540,750 750,1020
semester,| that will show up,|
|它会出现，|

2563
01:24:39,340 --> 01:24:40,180
0,300 300,480 480,660 660,690 690,840
and we'll talk a little
最后，我们将讨论有关无锁编程的问题，

2564
01:24:40,180 --> 01:24:41,080
0,150 150,300 300,510 510,750 750,900
bit more about {lock-free -}

2565
01:24:41,080 --> 01:24:42,970
0,510 510,600 600,750 750,1080 1380,1890
programming at the end| and
|看看在内核中是如何做到这一点的。

2566
01:24:43,000 --> 01:24:44,380
0,210 210,360 360,690 690,900 900,1380
see how that's done in

2567
01:24:44,380 --> 01:24:45,360
0,570
kernels.|
|

2568
01:24:45,580 --> 01:24:46,960
0,450 480,720 720,990 990,1080 1080,1380
Okay, so let me stop
好的，我在这里停止，

2569
01:24:46,960 --> 01:24:48,670
0,420 780,960 960,1080 1080,1470 1470,1710
here,| so that anybody who
|所以，任何必须去别的地方的人可以去，

2570
01:24:48,670 --> 01:24:49,630
0,150 150,210 210,450 450,720 720,960
has to go somewhere else

2571
01:24:49,630 --> 01:24:50,710
0,150 150,750 750,900 900,960 960,1080
can go,| but if you
|但是，如果你还有什么问题，|

2572
01:24:50,710 --> 01:24:52,060
0,150 150,330 330,540 540,1020 1020,1350
have any more questions,| feel
|请随时提出来。

2573
01:24:52,060 --> 01:24:53,230
0,360 390,660 660,870 870,1050 1050,1170
free, please feel free to

2574
01:24:53,230 --> 01:24:54,180
0,270 270,420
ask them.|
|

2575
01:24:54,820 --> 01:24:55,480
0,90 90,180 180,270 270,600 600,660
We have a question in
我们在聊天中有个问题，

2576
01:24:55,480 --> 01:24:57,430
0,120 120,510 780,1320 1530,1830 1830,1950
the chat,| {} isn't the
|fence 指令是不是没有必要，

2577
01:24:57,430 --> 01:24:59,530
0,270 270,840 840,1500 1500,1830 1830,2100
fence instruction unnecessary,| because the
|因为 amoswap 指令可以具有获取释放顺序。

2578
01:24:59,530 --> 01:25:01,270
0,360 360,750 750,1290 1290,1470 1470,1740
{amoswap -} instruction can have

2579
01:25:01,270 --> 01:25:03,340
0,120 120,570 570,930 930,1470
the acquire release ordering.|
|

2580
01:25:04,060 --> 01:25:06,190
0,300 300,870 900,1320 1320,1710 1740,2130
{} Yeah, {} okay, so
是的，好的，所以有两件事，

2581
01:25:06,220 --> 01:25:08,080
0,450 450,930 990,1290 1290,1440 1440,1860
{} okay, so two things,|
|

2582
01:25:08,170 --> 01:25:10,600
0,240 240,1590 1590,1800 1800,2130 2130,2430
{} the {} sync instruction
sync 指令同时为编译器和硬件。

2583
01:25:10,600 --> 01:25:11,650
0,180 180,510 510,570 570,630 630,1050
there both for the compiler

2584
01:25:11,650 --> 01:25:12,980
0,180 180,300 300,360 360,780
and for the hardware.|
|

2585
01:25:25,000 --> 01:25:26,140
0,180 180,360 360,630 630,930 960,1140
Yeah I'm jumping off {}
是的，我马上要超过工作时间了，

2586
01:25:26,140 --> 01:25:27,130
0,120 120,330 330,600 600,870 870,990
to {sort,of} office hours,| but
|但我认为还有更多的问题。

2587
01:25:27,130 --> 01:25:27,820
0,90 90,300 300,450 450,570 570,690
I think there's still more

2588
01:25:27,820 --> 01:25:29,470
0,390 390,450 450,630 630,1530 1530,1650
questions in the.| {How,do} you
|如何只为编译器做这件事呢？

2589
01:25:29,470 --> 01:25:30,430
0,120 120,210 210,330 330,420 420,960
do it for the compiler

2590
01:25:30,430 --> 01:25:31,420
0,450
only?|
|

2591
01:25:31,480 --> 01:25:34,030
0,780 1080,1890 1890,1980 1980,2310 2310,2550
{} The {} compiler knows
编译器知道正在编译的是哪个体系结构，

2592
01:25:34,030 --> 01:25:36,100
0,210 210,690 690,780 780,1320 1830,2070
which architecture is compiling| and
|所以我们知道它什么时候必须确保合适的栅栏，

2593
01:25:36,100 --> 01:25:36,970
0,120 120,300 300,420 420,660 660,870
so we will know when

2594
01:25:36,970 --> 01:25:38,410
0,180 180,450 450,630 630,720 720,1440
it actually has to ensure

2595
01:25:38,410 --> 01:25:40,690
0,150 150,540 540,1080 1350,1920 1920,2280
the appropriate fences| for whatever
|无论运行在哪种体系结构上，

2596
01:25:40,690 --> 01:25:41,890
0,540 540,630 630,900 900,1110 1110,1200
architecture is running on| and
|不管是哪种内存一致性模型。

2597
01:25:41,890 --> 01:25:43,570
0,360 360,630 630,1170 1170,1500 1500,1680
whatever memory consistency model it

2598
01:25:43,570 --> 01:25:44,400
0,420
has.|
|

2599
01:25:44,740 --> 01:25:45,640
0,240 240,390 390,570 570,690 690,900
So this gets a little
所以这会引起更复杂的讨论，

2600
01:25:45,640 --> 01:25:46,960
0,120 120,270 270,720 720,1200 1200,1320
bit more complicated discussion| is
|就是每个硬件都有一个内存模型，

2601
01:25:46,960 --> 01:25:47,980
0,150 150,360 360,540 540,600 600,1020
that every piece of hardware

2602
01:25:47,980 --> 01:25:50,590
0,360 360,1080 1080,1320 1320,1830 2160,2610
has a memory model| and
|编译器决定，

2603
01:25:51,040 --> 01:25:53,230
0,90 90,540 540,690 690,1080 1500,2190
the compilers {decide -} {}|
|

2604
01:25:53,230 --> 01:25:54,220
0,150 150,300 300,600 600,720 720,990
you know given the memory
给特定架构的内存模型，

2605
01:25:54,220 --> 01:25:56,080
0,510 600,810 810,960 960,1350 1350,1860
model for that particular architecture,|
|

2606
01:25:56,080 --> 01:25:57,190
0,180 180,630 630,750 750,930 930,1110
what actually can do what
它可以做什么，不能做什么。

2607
01:25:57,190 --> 01:25:58,280
0,90 90,420 420,600
it cannot do.|
|

2608
01:25:59,440 --> 01:26:00,550
0,150 150,390 390,630 630,720 720,1110
{} I guess my question
我想我的问题是，

2609
01:26:00,550 --> 01:26:02,770
0,210 210,600 660,1230 1320,1770 1770,2220
was that| like {the,fence} instruction
|fence 指令只有在这种情况是没有必要的，

2610
01:26:02,770 --> 01:26:04,690
0,180 180,660 660,1590 1590,1770 1770,1920
only becomes unnecessary,| if you
|如果你调用 amoswap.w.rl ，

2611
01:26:04,690 --> 01:26:06,460
0,240 240,540 540,1260
call {amoswap -}

2612
01:26:06,610 --> 01:26:09,310
0,840 870,1110 1110,1410 1410,1920 1980,2700
like {.w.rl - - -},|
|

2613
01:26:09,400 --> 01:26:13,240
0,600 1080,2130 2400,3300
{} and {}
放在 sync 中，这有一个 sync ，

2614
01:26:14,370 --> 01:26:16,740
0,690 720,1050 1050,1230 1230,1770
like putting in the

2615
01:26:16,740 --> 01:26:18,840
0,240 540,1230 1260,1500 1500,1890 1890,2100
the sync and there that

2616
01:26:18,840 --> 01:26:20,550
0,120 120,450 450,690 690,1230 1530,1710
will sync,| but the you
|但是编译器排序，然后。

2617
01:26:20,550 --> 01:26:22,650
0,120 120,270 270,1110 1110,1830 1830,2100
know the compiler ordering and

2618
01:26:22,650 --> 01:26:24,460
0,600 600,1260
then the.|
|

2619
01:26:24,460 --> 01:26:27,010
0,660 870,1500 1530,1920 1920,2370 2370,2550
Yeah.| The memory ordering and
是的。|内存排序和无序。

2620
01:26:27,010 --> 01:26:29,200
0,300 300,450 450,510 510,1230 1680,2190
the out of ordering.| Yeah.|
|是的。|

2621
01:26:29,230 --> 01:26:30,760
0,570 570,810 810,870 870,1080 1080,1530
Machinery using the fence instruction
机器也使用 fence 指令，

2622
01:26:30,760 --> 01:26:32,110
0,150 150,540 540,630 630,870 870,1350
as well,| the fence instructions
|fence 指令只在执行 .rl 的情况下是没有必要的，

2623
01:26:32,110 --> 01:26:33,550
0,330 330,990 990,1080 1080,1170 1170,1440
only unnecessary in the case

2624
01:26:33,550 --> 01:26:35,230
0,150 150,360 420,750 840,1230 1230,1680
that you do {.rl -},|
|

2625
01:26:35,230 --> 01:26:36,130
0,300 300,480 480,690 690,810 810,900
so it seems like it
看起来它不会检测到这一点，

2626
01:26:36,130 --> 01:26:37,510
0,330 330,750 750,1050 1050,1230 1230,1380
wouldn't detect that,| so how
|那么你怎么做的，

2627
01:26:37,510 --> 01:26:39,100
0,150 150,300 300,450 450,720 1020,1590
would you do it,| so
|所以编译器最终强制排序，

2628
01:26:39,100 --> 01:26:41,620
0,150 150,1110 1350,1920 1920,2040 2040,2520
the compiler enforces the ordering

2629
01:26:41,620 --> 01:26:43,570
0,120 120,330 330,720 1050,1710 1740,1950
on its end,| but you
|但你已经使用[]指令覆盖了它。

2630
01:26:43,570 --> 01:26:45,640
0,240 240,600 600,810 960,1560 1800,2070
already cover it using the

2631
01:26:45,640 --> 01:26:48,610
0,390 840,1200 1230,1680 1680,2280 2280,2970
[] instruction.| Yeah, you {}
|是的，好问题，

2632
01:26:48,640 --> 01:26:50,530
0,480 480,600 600,1020 1050,1470 1470,1890
very good question,| {} and
|更复杂的需求实现会是，

2633
01:26:50,530 --> 01:26:52,360
0,120 120,270 300,630 630,1260 1260,1830
you know more sophisticated requirements

2634
01:26:52,360 --> 01:26:54,610
0,570 570,750 750,1110 1110,1800 1860,2250
implementation would be,| {} we
|比如 RISC-V 专门的 acquire 和 release 实现，

2635
01:26:54,610 --> 01:26:57,140
0,450 480,720 750,1470 1470,2190
were like specialized {}

2636
01:26:57,140 --> 01:26:58,880
0,270 270,810 810,1110 1110,1560 1560,1740
{} acquire {and,release} implementation or

2637
01:26:58,970 --> 01:27:00,140
0,510 510,630 630,810 810,930 930,1170
implementation for {RISC-V -},| {you,know}
|可能比我们做的事情更复杂，

2638
01:27:00,140 --> 01:27:01,730
0,300 300,450 450,660 660,1350 1350,1590
probably do more sophisticated things

2639
01:27:01,730 --> 01:27:02,960
0,150 150,300 300,660 660,930 930,1230
than we do,| {} pretty
|使用 fence 指令是一个粗粒度的实现。

2640
01:27:02,960 --> 01:27:04,280
0,300 300,600 600,780 780,960 960,1320
coarse grain by just issuing

2641
01:27:04,280 --> 01:27:05,680
0,390 390,870
{the,fence} instruction.|
|

2642
01:27:05,800 --> 01:27:09,520
0,480 600,1410 1590,2190 2310,3120 3390,3720
{} The, {} the but
但是这有点复杂，

2643
01:27:09,520 --> 01:27:11,770
0,120 120,390 390,1050 1080,1800 1890,2250
it's slightly complicated,| {} yeah,
|是的，如果你对这个感兴趣，

2644
01:27:11,770 --> 01:27:14,110
0,540 600,870 870,1770 1800,2160 2160,2340
so if you're interested in

2645
01:27:14,110 --> 01:27:16,690
0,510 540,1170 1380,1860 1860,2190 2190,2580
this,| {} the memory model
|RISC-V 的内存模型非常复杂，

2646
01:27:16,690 --> 01:27:18,640
0,180 180,420 420,870 900,1530 1530,1950
for {RISC-V -} is {}

2647
01:27:18,940 --> 01:27:20,500
0,600 600,1170 1170,1380 1380,1470 1470,1560
really complicated,| so if you
|如果你看一下操作手册中的非特权指令，

2648
01:27:20,500 --> 01:27:23,200
0,210 210,330 330,1140 1170,1770 1770,2700
look at the instruction manual

2649
01:27:23,200 --> 01:27:25,210
0,450 450,900 930,1410 1410,1920 1920,2010
for the unprivileged instructions,| there
|有一整章来专门介绍内存排序，

2650
01:27:25,210 --> 01:27:27,820
0,60 60,270 270,840 1170,2190 2430,2610
is whole chapter dedicated to

2651
01:27:27,820 --> 01:27:29,740
0,420 420,990 990,1440 1470,1830 1830,1920
memory ordering| and tells you
|告诉你应该做什么。

2652
01:27:29,740 --> 01:27:30,370
0,120 120,240 240,420 420,480 480,630
what they have to, {}|
|

2653
01:27:30,370 --> 01:27:31,600
0,60 60,420 420,600 600,870
the compiler should do
在特定情况下，编译器应该怎么做。

2654
01:27:31,890 --> 01:27:34,410
0,1380 1380,1650 1650,1800 1800,2100 2100,2520
{} in this particular case.|
|

2655
01:27:37,760 --> 01:27:38,630
0,180 180,330 330,570 570,660 660,870
So you're saying that the
所以，你的意思是编译器会注意到这一事实，

2656
01:27:38,630 --> 01:27:40,250
0,510 510,720 720,990 990,1290 1380,1620
compiler would pick up on

2657
01:27:40,250 --> 01:27:41,180
0,120 120,390 390,540 540,630 630,930
the fact,| that we just
|我们只是把汇编指令放在这里，

2658
01:27:41,180 --> 01:27:43,190
0,180 180,480 660,1110 1110,1650 1650,2010
put that assembly instruction inside

2659
01:27:43,190 --> 01:27:44,660
0,60 60,540 570,900 900,1110 1110,1470
of there,| and it wouldn't
|而且它本身不会对任何内存访问进行重新排序。

2660
01:27:44,660 --> 01:27:46,010
0,660 660,870 870,960 960,1050 1050,1350
reorder any of the memory

2661
01:27:46,010 --> 01:27:48,320
0,450 450,660 660,1020 1110,1680 1680,2310
accesses on {its,own}.| Sorry, the
|抱歉， synchronize ，这个同步库函数是库函数，

2662
01:27:48,650 --> 01:27:51,350
0,840 840,1260 1260,1710 1740,2280 2280,2700
synchronize this, this synchronized library

2663
01:27:51,350 --> 01:27:52,550
0,330 330,420 420,480 480,810 810,1200
function is a library function

2664
01:27:52,640 --> 01:27:53,720
0,270 270,450 450,570 570,630 630,1080
right,| it can be implemented
|它可以通过不同的方式实现。

2665
01:27:53,720 --> 01:27:54,940
0,90 90,390 390,810
in different ways.|
|

2666
01:27:55,030 --> 01:27:56,440
0,600 600,900 900,1020 1020,1080 1080,1410
{} And this is one
这是一种实现。

2667
01:27:56,440 --> 01:27:58,020
0,360 360,1020
particular implementation.|
|

2668
01:27:58,440 --> 01:27:59,760
0,330 330,570 570,930 930,1200 1200,1320
And the library function is
并且库函数由编译器提供。

2669
01:27:59,760 --> 01:28:01,320
0,330 330,420 420,480 480,1050
provided by the compiler.|
|

2670
01:28:02,610 --> 01:28:03,690
0,270 270,570 570,720 720,870 870,1080
{} But is there like
但是编译器有没有进行优化的选项，

2671
01:28:03,690 --> 01:28:05,010
0,120 120,570 570,690 690,750 750,1320
the option for the compiler

2672
01:28:05,010 --> 01:28:06,840
0,120 120,480 480,1290 1290,1620 1620,1830
to do optimization,| where it
|它可以移动加载和存储指令。

2673
01:28:06,840 --> 01:28:08,610
0,570 570,1050 1050,1320 1320,1650 1650,1770
itself moves the loads and

2674
01:28:08,610 --> 01:28:10,040
0,330 330,840
stores around.|
|

2675
01:28:10,560 --> 01:28:12,660
0,180 180,630 840,1170 1170,1560 1920,2100
{} Yes, compilers do.| So
是的，编译器有。|那么如何在不使用 fence 指令时防止这种情况发生，

2676
01:28:12,660 --> 01:28:14,040
0,120 120,210 210,390 390,900 900,1380
how do you prevent that

2677
01:28:14,040 --> 01:28:16,530
0,510 510,810 810,1230 1260,2040 2070,2490
without emitting {the,fence} instruction,| that's
|我想知道这个。

2678
01:28:16,530 --> 01:28:18,030
0,300 300,510 510,900 900,1140 1140,1500
curious about.| I guess what
|我想我说的是，

2679
01:28:18,030 --> 01:28:20,520
0,240 240,600 600,720 720,1320 1710,2490
I'm saying is that {},|
|

2680
01:28:20,800 --> 01:28:22,540
0,210 210,660 660,1200 1260,1650 1650,1740
and maybe {} what I'm
也许我想说的是，

2681
01:28:22,540 --> 01:28:23,680
0,210 210,300 300,420 420,810 810,1140
saying is that basically the,|

2682
01:28:24,470 --> 01:28:26,720
0,300 300,960 960,1050 1050,1920 1920,2250
this indication the synchronized basically
synchronized 告诉编译器和硬件，

2683
01:28:26,720 --> 01:28:27,650
0,240 240,450 450,510 510,840 840,930
both tells the compiler and

2684
01:28:27,650 --> 01:28:28,820
0,420 420,510 510,570 570,1020 1020,1170
hardware,| but the compiler could
|但是编译器可以实现不同的 __sync_synchronize ，

2685
01:28:28,820 --> 01:28:30,860
0,240 240,570 570,1080 1110,1590 1590,2040
actually implement {__sync_synchronize -} differently,|
|

2686
01:28:30,860 --> 01:28:31,790
0,180 180,540 540,630 630,720 720,930
it knows that it can't
它知道它不能移动东西，

2687
01:28:31,790 --> 01:28:33,080
0,210 210,420 420,870 1110,1230 1230,1290
move things around,| but it
|但它没有 RISC-V 上的发布和 fence 指令，

2688
01:28:33,080 --> 01:28:34,010
0,240 240,450 450,510 510,810 810,930
doesn't have the issue and

2689
01:28:34,010 --> 01:28:35,060
0,240 240,690 690,780 780,870 870,1050
fence instruction on the {RISC-V

2690
01:28:35,060 --> 01:28:36,560
0,330 330,510 510,1050 1230,1440 1440,1500
-},| it knew that it
|它知道它以一种特殊的方式在 RISC-V 上运行。

2691
01:28:36,560 --> 01:28:37,550
0,150 150,510 510,600 600,660 660,990
was running in a particular

2692
01:28:37,550 --> 01:28:38,880
0,210 210,330 330,510 510,900
way on {RISC-V -}.|
|

2693
01:28:42,060 --> 01:28:43,830
0,810 840,990 990,1290 1290,1500 1500,1770
{} But isn't the {RISC-V
但是 RISC-V 内存模型还不够吗，

2694
01:28:43,830 --> 01:28:46,080
0,900 930,1380 1380,1800 1800,2040 2040,2250
-} memory model like []

2695
01:28:46,080 --> 01:28:47,190
0,450 450,570 570,840 840,930 930,1110
enough| to where the out
|机器可以重组东西，

2696
01:28:47,190 --> 01:28:49,710
0,90 90,600 690,1500 1500,1800 1800,2520
of order machinery could reorganize

2697
01:28:49,710 --> 01:28:51,510
0,450 450,870 870,1170 1290,1500 1500,1800
stuff,| so {} {do,you} need
|所以你是否需要 acquire ，

2698
01:28:51,510 --> 01:28:53,260
0,210 210,330 330,1290
like the acquire,|
|

2699
01:28:53,410 --> 01:28:54,580
0,270 480,690 690,750 750,930 930,1170
it's like the whole point
整个[点]都有。

2700
01:28:54,580 --> 01:28:58,880
0,60 60,570 630,3210
of having.| Okay,
|好的，还有比 __sync_synchronize 更复杂的接口，

2701
01:28:59,370 --> 01:29:01,410
0,180 180,420 420,960 960,1410 1410,2040
there more complicated interfaces {__sync_synchronize

2702
01:29:01,410 --> 01:29:02,600
0,720
-},|
|

2703
01:29:03,120 --> 01:29:04,680
0,450 450,930 930,1290 1290,1500 1500,1560
{} and which give the
这给了编译器编写者更多的自由，

2704
01:29:04,680 --> 01:29:06,390
0,360 360,750 750,1320 1320,1560 1560,1710
compiler writer more gives the

2705
01:29:06,510 --> 01:29:07,920
0,510 510,750 750,1140 1140,1290 1290,1410
programmer more freedom| and we'll
|我们可以得到编译器，

2706
01:29:07,920 --> 01:29:09,750
0,150 150,240 240,810 810,1260 1320,1830
get the compiler| and decouple
|并将编译器和处理器解耦。

2707
01:29:09,750 --> 01:29:10,860
0,90 90,510 510,810 810,1020 1020,1110
the compiler part and the

2708
01:29:10,860 --> 01:29:12,160
0,450 450,840
processor part.|
|

2709
01:29:13,000 --> 01:29:13,930
0,360 360,420 420,690 690,780 780,930
So, for example I think
比如，我想这里有一个标记可以传入，

2710
01:29:13,930 --> 01:29:15,340
0,180 180,270 270,600 600,750 750,1410
there's a flag you {can,pass,in},|
|

2711
01:29:15,340 --> 01:29:16,090
0,120 120,270 270,360 360,600 600,750
you know to say that
有一个 release 一致性同步。

2712
01:29:16,090 --> 01:29:18,520
0,150 150,300 300,510 510,1290 1320,2430
there's a release consistent {}

2713
01:29:18,520 --> 01:29:19,700
0,720
synchronize.|
|

2714
01:29:19,970 --> 01:29:21,530
0,810 810,990 990,1140 1140,1320 1320,1560
{} You know I I
我不知道细节，

2715
01:29:21,530 --> 01:29:22,730
0,180 180,480 480,600 600,1020 1020,1200
don't know the details,| right
|我不知道，

2716
01:29:22,730 --> 01:29:23,990
0,60 60,120 120,300 300,750 750,1260
out of my head {},|
|

2717
01:29:23,990 --> 01:29:24,680
0,150 150,240 240,330 330,510 510,690
but you can look into
但你可以查一下这个，

2718
01:29:24,680 --> 01:29:26,540
0,420 720,1320 1350,1620 1620,1710 1710,1860
this,| {} this is {}
|这是粗粒度接口，

2719
01:29:26,540 --> 01:29:27,860
0,90 90,660 660,1140 1140,1260 1260,1320
the coarse-grained interface| and a
|更细粒度的接口，让程序员有更多的控制权。

2720
01:29:27,860 --> 01:29:29,450
0,240 240,750 750,1230 1230,1410 1410,1590
more fine-grained interfaces that give

2721
01:29:29,450 --> 01:29:30,980
0,60 60,450 450,630 630,1050
the programmer more control.|
|

2722
01:29:31,300 --> 01:29:32,360
0,570
Okay,
好的，谢谢。

2723
01:29:32,770 --> 01:29:33,860
0,240 240,480
thank you.|
|

2724
01:29:35,660 --> 01:29:37,520
0,330 330,510 510,780 780,930 930,1860
{} I have a question
我有一个问题，

2725
01:29:37,520 --> 01:29:39,740
0,330 330,720 750,1530 1800,2130 2130,2220
what is,| {} how do
|如果有多个线程和一个处理器，

2726
01:29:39,740 --> 01:29:42,350
0,240 240,630 630,1140 1170,2070 2100,2610
you like for having multiple

2727
01:29:42,350 --> 01:29:44,600
0,450 450,540 540,960 1020,1830 1860,2250
threads and one processor| do
|[争论]的方式与我们对多处理器的争论是否相同。

2728
01:29:44,600 --> 01:29:46,100
0,480 480,750 750,1110 1110,1230 1230,1500
argue in roughly the same

2729
01:29:46,100 --> 01:29:47,720
0,300 300,780 810,900 900,1200 1200,1620
way as we did for

2730
01:29:47,780 --> 01:29:50,500
0,780 1020,2280
multiple processors.|
|

2731
01:29:50,920 --> 01:29:54,310
0,2520 2520,2640 2640,2880 2880,3000 3000,3390
Can you repeat that question
你能重复一下问题吗，只是确认一下。

2732
01:29:54,310 --> 01:29:55,780
0,120 120,180 180,300 300,900
just to make sure.|
|

2733
01:29:56,700 --> 01:29:58,830
0,450 450,1170 1440,1680 1680,1980 2010,2130
So {we,didn't},| I think I
所以我们没有，|我想我们并没有谈到多线程，

2734
01:29:58,830 --> 01:29:59,790
0,180 180,330 330,420 420,630 630,960
don't think we really talked

2735
01:29:59,790 --> 01:30:02,160
0,300 300,750 750,1410 1410,1920 1950,2370
about multiple threads,| we mostly
|我们主要讨论的是多 CPU ，

2736
01:30:02,160 --> 01:30:03,870
0,240 240,390 390,780 780,1380 1380,1710
talked about multiple {CPUs -},|
|

2737
01:30:04,140 --> 01:30:07,020
0,540 570,1080 1110,1590 1590,2310 2340,2880
so for multiple threads is
所以对于多线程来说，

2738
01:30:07,020 --> 01:30:08,610
0,630 720,1050 1050,1050 1050,1440 1440,1590
the,| {} I guess the
|我想解决方案与拥有多个 CPU 时的解决方案相同，

2739
01:30:08,610 --> 01:30:09,880
0,840
solution

2740
01:30:09,970 --> 01:30:12,580
0,240 240,810 840,1680 1740,2370 2400,2610
the same as for when

2741
01:30:12,580 --> 01:30:13,720
0,120 120,360 360,720 720,1050 1050,1140
you have multiple {CPUs -},|
|

2742
01:30:13,720 --> 01:30:14,860
0,240 240,360 360,810 840,1050 1050,1140
like do you have the
比如，那里有没有同样的参数。

2743
01:30:14,860 --> 01:30:17,320
0,240 240,720 720,1230 1620,2370 2370,2460
same arguments there.| More or
|或多或少，

2744
01:30:17,320 --> 01:30:19,510
0,540 570,1140 1170,1590 1590,2070 2070,2190
less,| {} {at,least} conceptually is
|至少在理论上是正确的思考方式，

2745
01:30:19,510 --> 01:30:20,170
0,60 60,270 270,390 390,480 480,660
the right way to think

2746
01:30:20,170 --> 01:30:21,850
0,270 270,480 540,1260 1260,1560 1560,1680
about it,| {} so you
|所以你有多个线程，

2747
01:30:21,850 --> 01:30:23,500
0,120 120,480 480,1080 1110,1440 1440,1650
have multiple threads,| but only
|但是只有一个 CPU ，

2748
01:30:23,500 --> 01:30:26,110
0,240 240,990 1380,2070 2070,2430 2430,2610
one CPU,| {} it's still
|还是这样情况，你希望确保，

2749
01:30:26,110 --> 01:30:26,860
0,60 60,390 390,510 510,600 600,750
the case that you want

2750
01:30:26,860 --> 01:30:28,510
0,60 60,420 420,540 540,930 930,1650
to ensure| that certain {}
|以原子方式执行某些内核代码序列。

2751
01:30:28,630 --> 01:30:30,250
0,390 390,630 630,1020 1020,1170 1170,1620
kernel code sequences are executed

2752
01:30:30,250 --> 01:30:31,320
0,420 420,660
{atomically -}.|
|

2753
01:30:31,550 --> 01:30:33,770
0,840 840,1470 1470,1830 1830,2010 2010,2220
{} And so you still
所以，你仍然需要有一个临界区间的概念。

2754
01:30:33,770 --> 01:30:34,640
0,210 210,330 330,570 570,600 600,870
have to have a notion

2755
01:30:34,640 --> 01:30:36,100
0,60 60,360 360,960
of critical sections.|
|

2756
01:30:36,100 --> 01:30:37,870
0,660 900,1110 1110,1320 1320,1530 1530,1770
{} You might not need
你可能不需要显式的锁或释放，

2757
01:30:37,870 --> 01:30:39,940
0,510 510,840 840,1170 1170,1890 1890,2070
locks or releases explicitly,| but
|但是你确实需要一种打开和关闭中断的方法，

2758
01:30:39,940 --> 01:30:40,720
0,90 90,270 270,480 480,570 570,780
you do need a way

2759
01:30:40,720 --> 01:30:42,160
0,300 300,630 630,780 780,1200 1200,1440
of turning on interrupts off

2760
01:30:42,160 --> 01:30:43,150
0,90 90,480 480,570 570,630 630,990
and on| in a particular
|在一段代码中。

2761
01:30:43,150 --> 01:30:44,300
0,180 180,240 240,660
piece of code.|

2762
01:30:44,670 --> 01:30:45,540
0,360 360,510 510,570 570,690 690,870
{} So if you look
所以，如果你查看较旧的操作系统内核，

2763
01:30:45,540 --> 01:30:48,360
0,210 570,1620 1620,2010 2010,2280 2280,2820
at older operating system kernels,|
|

2764
01:30:48,360 --> 01:30:49,830
0,210 210,570 570,870 870,1170 1170,1470
they typically don't have really
它们通常在内核中没有真正的锁获取，

2765
01:30:49,830 --> 01:30:52,020
0,390 390,1110 1440,1920 1920,2100 2100,2190
locking acquire {} in the

2766
01:30:52,020 --> 01:30:53,340
0,330 330,570 570,690 690,1170 1170,1320
kernel,| because they assume they're
|因为它们假设在一个处理器上运行，

2767
01:30:53,340 --> 01:30:54,660
0,240 240,330 330,390 390,690 690,1320
running on a single processor,|
|

2768
01:30:54,810 --> 01:30:55,980
0,270 270,390 390,570 570,840 840,1170
but they do have something
但是它们确实有像锁这样的东西，

2769
01:30:55,980 --> 01:30:57,150
0,180 180,630 630,720 720,870 870,1170
like locks,| you know to
|要打开和关闭中断。

2770
01:30:57,150 --> 01:30:59,130
0,420 420,690 690,930 930,1470 1470,1980
basically turn off interrupt and

2771
01:30:59,130 --> 01:31:00,140
0,570
interrupt

2772
01:31:00,400 --> 01:31:01,620
0,240 240,330 330,720
on and off.|
|

2773
01:31:03,460 --> 01:31:05,380
0,540 540,720 720,1200 1500,1770 1770,1920
Okay I see,| {} and
好的，我明白了，|我的另一个问题是，

2774
01:31:05,380 --> 01:31:08,320
0,150 150,420 420,1260 1320,1950 2040,2940
my other question was,| actually
|在带有 UART 图片和缓冲区的的幻灯片上。

2775
01:31:08,320 --> 01:31:11,260
0,210 210,300 300,840 840,1380 2220,2940
on the slide with the

2776
01:31:11,290 --> 01:31:15,300
0,780 870,1770 1770,2430 2670,3570
uart picture, the buffer.|
|

2777
01:31:15,300 --> 01:31:16,740
0,870

2778
01:31:17,570 --> 01:31:19,430
0,810 840,1050 1050,1230 1230,1680 1680,1860
Yeah, is it,| yeah that
是的，是不是，|是的，就是那个，

2779
01:31:19,430 --> 01:31:20,900
0,360 390,660 660,1020 1020,1380 1380,1470
one,| is it always the
|是不是一直都是这样的，读在后面，

2780
01:31:20,900 --> 01:31:22,940
0,360 360,780 780,1260 1290,1800 1830,2040
case that the read is

2781
01:31:22,940 --> 01:31:25,220
0,300 300,480 480,900 1170,1770 1770,2280
going to be like lagging

2782
01:31:25,220 --> 01:31:26,930
0,570 600,720 720,900 900,1350 1350,1710
behind,| I didn't understand that.|
|我不明白这个。|

2783
01:31:27,170 --> 01:31:29,220
0,480 480,690 690,870 870,1560
Yeah, okay so good.|
是的，好的。|

2784
01:31:29,400 --> 01:31:30,120
0,180 180,360 360,540 540,630 630,720
So this goes to the
所以这个到显示器，

2785
01:31:30,120 --> 01:31:32,310
0,570 570,960 960,1050 1050,1560 1680,2190
display,| whatever is this basically
|这是字符序列，

2786
01:31:32,310 --> 01:31:33,030
0,180 180,300 300,390 390,660 660,720
this is the sequence of

2787
01:31:33,030 --> 01:31:33,960
0,450 450,570 570,750 750,810 810,930
characters,| that needs to go
|要到显示器。

2788
01:31:33,960 --> 01:31:35,360
0,120 120,210 210,840
to the display.|
|

2789
01:31:36,730 --> 01:31:38,620
0,660 660,990 990,1140 1140,1530 1530,1890
{} And the writer basically
写入者增加更多字符，

2790
01:31:38,620 --> 01:31:39,790
0,60 60,540 540,720 720,810 810,1170
{appending -} more and more

2791
01:31:39,790 --> 01:31:40,960
0,630
characters,

2792
01:31:41,770 --> 01:31:43,960
0,420 420,630 630,1290 1440,2040 2040,2190
right.| And so, {} so
|所以，写入者走这条路，

2793
01:31:43,960 --> 01:31:45,220
0,90 90,450 450,630 630,840 840,1260
the writers going that way|
|

2794
01:31:45,220 --> 01:31:46,810
0,540 540,930 930,1410 1410,1470 1470,1590
and the readers, you know
读取者跟随写入者，

2795
01:31:46,810 --> 01:31:48,790
0,540 540,630 630,1170 1530,1800 1800,1980
following the writer,| because you
|因为你不能打印尚未放入缓冲区的字符。

2796
01:31:48,790 --> 01:31:49,780
0,270 270,450 450,480 480,840 840,990
can't print a character that

2797
01:31:49,780 --> 01:31:51,310
0,270 270,840 840,1050 1050,1230 1230,1530
hasn't been put into buffer

2798
01:31:51,310 --> 01:31:52,140
0,300
yet.|
|

2799
01:31:52,260 --> 01:31:54,120
0,630 630,1080 1080,1290 1290,1680 1680,1860
{} And so let's you
UART 把东西给显示器，

2800
01:31:54,120 --> 01:31:57,330
0,180 180,780 930,1440 1890,2580 2580,3210
know the the uart who

2801
01:31:57,330 --> 01:31:58,620
0,240 240,450 450,570 570,660 660,1290
puts things on the display,|
|

2802
01:32:02,340 --> 01:32:04,830
0,150 150,960 1290,1710 1710,2160 2160,2490
{you,know} will start basically putting
开始将这个插槽中的第一个字符放到显示器上，

2803
01:32:04,830 --> 01:32:06,420
0,330 330,840 840,900 900,1080 1080,1590
first characters in this slot

2804
01:32:06,450 --> 01:32:09,060
0,510 510,600 600,1260 1650,2430 2430,2610
onto the display,| meanwhile {printf
|同时， printf 进入，

2805
01:32:09,060 --> 01:32:10,140
0,150 150,330 330,510 510,720 720,1080
-} could come in multiple

2806
01:32:10,140 --> 01:32:11,460
0,300 300,480 480,900 930,990 990,1320
printf come in,| you know
|它们在这里放更多的字符，

2807
01:32:11,460 --> 01:32:12,630
0,150 150,360 360,570 570,1020 1020,1170
they put more characters in

2808
01:32:12,630 --> 01:32:13,620
0,360 390,540 540,660 660,780 780,990
here,| so that the write
|所以写指针在这里，

2809
01:32:13,620 --> 01:32:15,420
0,270 270,600 600,930 930,1410 1680,1800
pointer spacing standing here| and
|然后当显示了一个字符，

2810
01:32:15,420 --> 01:32:16,530
0,90 90,270 270,420 420,690 690,1110
then when there's one character

2811
01:32:16,530 --> 01:32:18,660
0,90 90,780 960,1620 1620,1680 1680,2130
is displayed,| then the uart
|然后 UART 将这个指针向上移动，

2812
01:32:18,660 --> 01:32:19,860
0,120 120,360 360,510 510,690 690,1200
will move up this pointer|
|

2813
01:32:20,340 --> 01:32:21,540
0,120 120,450 450,540 540,750 750,1200
to display the next character.|
以显示下一个字符。|

2814
01:32:22,430 --> 01:32:24,050
0,180 180,540 540,630 630,1020 1020,1620
The uart is always lagging
UART 总是有点落后于写入者，

2815
01:32:24,050 --> 01:32:26,900
0,90 90,300 300,1290 1410,2250 2280,2850
a little behind the writer,|
|

2816
01:32:26,930 --> 01:32:27,800
0,240 240,420 420,480 480,750 750,870
{until -} the point that
直到它赶上，

2817
01:32:27,800 --> 01:32:29,210
0,90 90,420 420,750 780,1020 1020,1410
it catches up right,| then
|然后 r 和 w 相同，

2818
01:32:29,450 --> 01:32:30,620
0,420 420,660 660,780 780,1050 1050,1170
where r and w are

2819
01:32:30,620 --> 01:32:31,370
0,60 60,450 450,540 540,600 600,750
the same,| and at that
|在这一点上，意味着缓冲区中不再有字符。

2820
01:32:31,370 --> 01:32:32,480
0,240 240,570 570,720 720,990 990,1110
point, basically, that means that

2821
01:32:32,480 --> 01:32:33,740
0,180 180,420 420,810 810,1200 1200,1260
there's no character anymore in

2822
01:32:33,740 --> 01:32:34,700
0,90 90,480
the buffer.|
|

2823
01:32:35,920 --> 01:32:37,000
0,270 270,540 540,690 690,900 900,1080
Oh okay I see, that
哦，好的，我明白了。

2824
01:32:37,000 --> 01:32:38,500
0,360 360,540 540,1020 1050,1320 1320,1500
makes, that makes {a,lot} more

2825
01:32:38,500 --> 01:32:39,520
0,300 300,570 570,750 750,840 840,1020
sense.| Okay, thank you so
|好的，非常感谢。

2826
01:32:39,520 --> 01:32:41,380
0,540 900,1380
much.| {You're,welcome}.|
|不用谢。|

2827
01:32:42,850 --> 01:32:44,320
0,240 240,390 390,930
Any more questions?|
还有什么问题吗？|

2828
01:32:48,990 --> 01:32:50,760
0,210 210,390 390,690 690,990 1590,1770
Just us left here.| All
只有我们在这里。|好的。

2829
01:32:50,760 --> 01:32:52,080
0,300
right.|
|

2830
01:32:53,680 --> 01:32:55,030
0,150 150,240 240,780 1050,1260 1260,1350
All you guys, see you
所有人，再见。

2831
01:32:55,030 --> 01:32:55,947
0,480
later.
