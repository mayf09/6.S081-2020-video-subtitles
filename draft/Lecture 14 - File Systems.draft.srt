1
00:00:00,000 --> 00:00:02,820
0,120 120,720 780,2250 2250,2730 2730,2820
I started and everybody could
我开始了，大家能看到我分享的屏幕吗？

2
00:00:02,820 --> 00:00:04,800
0,630 690,930 930,1440
see my screen

3
00:00:04,800 --> 00:00:06,260
0,180 180,270 270,900
that I shared?|
|

4
00:00:06,700 --> 00:00:08,350
0,510 600,780 810,1230 1230,1530 1530,1650
And I hope everybody can
我希望每个人都能听到我说话。

5
00:00:08,350 --> 00:00:09,400
0,180 180,480
hear me.|
|

6
00:00:11,630 --> 00:00:12,820
0,600
{Let,me}.|
让我。|

7
00:00:12,970 --> 00:00:15,300
0,30 30,180 180,630 810,1590
I think {we're,good}.| Okay,
我想是好的。|好的，今天我要讨论一下文件系统，

8
00:00:15,300 --> 00:00:16,890
0,690 870,1140 1140,1200 1200,1380 1380,1590
{} {so,I'm,going} to talk about

9
00:00:16,890 --> 00:00:19,590
0,480 480,720 720,1290 1320,1980 2010,2700
file system today| and {}
|我们会用三节课来讲解文件系统，

10
00:00:19,980 --> 00:00:21,180
0,270 270,330 330,780 780,1080 1080,1200
going to be actually going

11
00:00:21,180 --> 00:00:22,200
0,90 90,360 360,570 570,900 900,1020
to spend three lectures on

12
00:00:22,200 --> 00:00:24,000
0,270 270,900 1110,1650 1650,1740 1740,1800
file systems,| two in the
|两节在 xv6 环境中，一节在 Linux 环境中。

13
00:00:24,000 --> 00:00:26,010
0,510 510,810 810,1380 1380,1800 1800,2010
context of {xv6 -} and

14
00:00:26,010 --> 00:00:27,270
0,270 270,390 390,450 450,1020 1020,1260
one in the context of

15
00:00:27,270 --> 00:00:28,600
0,930
Linux.|
|

16
00:00:28,690 --> 00:00:30,190
0,210 210,660 660,960 960,1140 1140,1500
In fact, this is the
实际上，这是关于 xv6 的最后一个话题，

17
00:00:30,220 --> 00:00:32,530
0,450 450,1020 1350,1710 1710,1950 1950,2310
last topic, {} that we're

18
00:00:32,560 --> 00:00:36,310
0,570 570,2220 2250,2700 2700,3210 3210,3750
covering {} of xv6,| after
|这周过后，我们基本上完成了 xv6 。

19
00:00:36,310 --> 00:00:37,780
0,180 180,480 480,720 720,1110 1110,1470
this week, we're basically done

20
00:00:38,320 --> 00:00:40,020
0,270 270,480 480,750 750,1200
{} with {xv6 -}.|
|

21
00:00:40,230 --> 00:00:42,330
0,450 660,1230 1290,1890 1890,2010 2010,2100
{} So, {} you know
所以，文件系统，你们都知道，并使用它，

22
00:00:42,330 --> 00:00:45,000
0,210 210,870 900,1320 1320,2070
file systems, {} {you,all}

23
00:00:45,090 --> 00:00:46,470
0,330 330,660 660,750 750,960 960,1380
know them, you use them,|
|

24
00:00:46,560 --> 00:00:47,400
0,270 270,420 420,630 630,720 720,840
{} they're one of the
它是操作系统中最面向用户的方面之一，

25
00:00:47,400 --> 00:00:50,280
0,540 720,1050 1050,1260 1260,1860 2220,2880
most sort of {} user

26
00:00:50,280 --> 00:00:52,470
0,870 900,1620 1620,1740 1740,1830 1830,2190
facing aspects of an operating

27
00:00:52,470 --> 00:00:53,850
0,510 510,780 780,1170 1170,1290 1290,1380
system,| in addition to the
|除了 shell 。

28
00:00:53,850 --> 00:00:56,970
0,510 750,1830 1860,2220 2400,2610 2610,3120
shell.| And so, {} we
|所以，我们现在想知道，

29
00:00:56,970 --> 00:00:58,170
0,120 120,180 180,540 540,960 960,1200
want to understand now| and
|而这几节课讲的就是，

30
00:00:58,170 --> 00:00:59,340
0,330 330,480 480,570 570,930 930,1170
the set of lectures actually|
|

31
00:00:59,340 --> 00:01:00,210
0,120 120,240 240,450 450,780 780,870
what it really happens under
文件系统底层到底发生了什么，

32
00:01:00,210 --> 00:01:01,650
0,60 60,600 750,1200 1200,1380 1380,1440
the hoods| and how is
|以及它是如何实现的。

33
00:01:01,650 --> 00:01:02,880
0,90 90,300 300,600 600,690 690,1230
the file system is implemented.|
|

34
00:01:02,880 --> 00:01:03,930
0,270 270,420 420,540 540,600 600,1050
And that's sort of exciting,
这让人兴奋，因为你一直在使用它。

35
00:01:03,930 --> 00:01:05,310
0,270 270,330 330,420 420,900 1110,1380
because you know you use

36
00:01:05,310 --> 00:01:06,360
0,120 120,240 240,300 300,630
them all the time.|
|

37
00:01:06,520 --> 00:01:07,780
0,240 240,570 570,870 870,990 990,1260
And maybe here to start
也许在深入任何细节之前，我们先来问个问题，

38
00:01:07,780 --> 00:01:09,430
0,90 90,210 210,270 270,810 1110,1650
off with a question {}

39
00:01:09,430 --> 00:01:10,570
0,360 360,720 720,840 840,900 900,1140
before diving in any of

40
00:01:10,570 --> 00:01:13,060
0,90 90,750 1110,1680 2100,2280 2280,2490
the details,| I, in one
|在某种程度上，因为你几乎每天都在使用文件系统，

41
00:01:13,060 --> 00:01:15,730
0,840 840,1200 1200,1920 1920,2160 2160,2670
way {you,know}, {since,you,use} file systems

42
00:01:15,730 --> 00:01:17,920
0,270 270,600 600,1170 1260,1860 2070,2190
are almost daily,| {} in
|在某种程度上， xv6 文件系统不同于

43
00:01:17,920 --> 00:01:19,210
0,210 210,480 480,840 840,1080 1080,1290
one {way,is} the {xv6 -}

44
00:01:19,210 --> 00:01:20,290
0,240 240,510 510,870 870,990 990,1080
file system different than| the
|你日常使用的文件系统。

45
00:01:20,290 --> 00:01:21,670
0,270 270,570 570,810 810,960 960,1380
file system that you're using

46
00:01:22,640 --> 00:01:24,200
0,150 150,270 270,1020
in the day-to-day

47
00:01:24,610 --> 00:01:26,060
0,420 420,960
{} work.|
|

48
00:01:26,460 --> 00:01:27,450
0,240 240,390 390,750 750,870 870,990
Maybe I'll collect them to
我会把它们提供给大家，

49
00:01:27,450 --> 00:01:29,300
0,390 390,660 750,1020 1020,1320
people| and see {}
|看看他们是怎么想的。

50
00:01:29,630 --> 00:01:30,560
0,180 180,270 270,540 540,600 600,930
what they think.| For example
|比如 Kendall ， Kendall Garner 。

51
00:01:30,560 --> 00:01:33,780
0,660 1440,1740 1740,2250 2250,2580
Kendall, Kendall Garner, what.|
|

52
00:01:34,700 --> 00:01:35,990
0,150 150,270 270,540 540,840 840,1290
Did you notice anything particular
你有没有注意到 xv6 有什么不同或相似之处？

53
00:01:35,990 --> 00:01:37,010
0,240 240,510 510,780 780,900 900,1020
about {xv6 -} that is

54
00:01:37,010 --> 00:01:38,640
0,360 360,450 450,1110
different or similar.|
|

55
00:01:45,850 --> 00:01:46,810
0,330 330,510 510,750 750,840 840,960
I'm not sure we can
我不确定我们能不能听到你， Kendall 。

56
00:01:46,810 --> 00:01:48,240
0,210 210,330 330,900
hear your, Kendall.|
|

57
00:01:49,500 --> 00:01:51,260
0,300 300,780 780,1170
Here I am.|
我在这里。|

58
00:01:51,320 --> 00:01:53,900
0,510 660,1110 1200,1530 1560,2460
Yeah.| Yeah okay.| Yeah.|
好的。|好的。|好的。|

59
00:01:53,900 --> 00:01:54,740
0,120 120,360 360,420 420,480 480,840
So one of the problems
所以其中一个问题就是大小，

60
00:01:54,740 --> 00:01:56,900
0,300 600,1200 1350,1650 1650,1800 1800,2160
is size| or at least
|或者至少 xv6 支持的文件的大小

61
00:01:56,900 --> 00:01:58,130
0,180 180,420 420,480 480,600 600,1230
the size of the files

62
00:01:58,130 --> 00:01:59,630
0,330 330,540 540,990 990,1380 1380,1500
that {xv6 -} support| are
|比许多其他文件系统小得多，

63
00:01:59,630 --> 00:02:00,860
0,420 420,780 780,960 960,1170 1170,1230
much less than {a,lot} of

64
00:02:00,860 --> 00:02:02,150
0,270 270,480 480,930 930,1200 1200,1290
other file systems,| also the
|另外，有些文件的名称相对较短。

65
00:02:02,150 --> 00:02:03,920
0,690 720,900 900,1080 1080,1470 1470,1770
names for some files are

66
00:02:04,190 --> 00:02:05,560
0,420 420,870
relatively short.|
|

67
00:02:05,590 --> 00:02:08,860
0,840 1080,1500 1500,2220 2460,2760 2850,3270
And another feature, it's more
还有一个功能，更多的是使用[][]，

68
00:02:08,860 --> 00:02:10,720
0,150 150,330 330,630 630,1050 1050,1860
just to use [] [],|
|

69
00:02:10,930 --> 00:02:11,710
0,420 420,480 480,600 600,720 720,780
{it,doesn't},| I don't think it
它没有，|我认为它没有文件系统的写入时复制。

70
00:02:11,710 --> 00:02:12,820
0,180 180,210 210,540 540,690 690,1110
has a {copy-on-write - -}

71
00:02:12,820 --> 00:02:15,220
0,270 270,450 450,1200
for a {file,system}.|
|

72
00:02:15,590 --> 00:02:17,420
0,630 900,1230 1230,1440 1440,1620 1620,1830
Good, in what way is
很好，有什么相似之处。

73
00:02:17,420 --> 00:02:18,440
0,510
similar.|
|

74
00:02:20,120 --> 00:02:22,280
0,240 240,660 660,1140 1410,1710 1710,2160
It's similar in the general
它在总体结构上是相似的，

75
00:02:22,280 --> 00:02:24,500
0,840 870,1230 1230,1350 1350,1800 1800,2220
structure,| so the idea of
|所以有文件名，

76
00:02:24,530 --> 00:02:26,720
0,300 300,930 1200,1620 1620,2070 2070,2190
you have file names,| you
|有 inode ，目录等等。

77
00:02:26,720 --> 00:02:28,580
0,180 180,330 330,510 510,1110 1140,1860
have the {inodes -}, directories,

78
00:02:28,580 --> 00:02:29,700
0,90 90,210 210,510
and all that.|
|

79
00:02:30,360 --> 00:02:31,520
0,630
Yeah,
是的，不错。

80
00:02:31,670 --> 00:02:33,470
0,270 270,570 660,1470 1470,1680 1680,1800
seems good.| {} And how
|那 Adella Yang 呢。

81
00:02:33,470 --> 00:02:35,080
0,360 360,960
about {}

82
00:02:35,350 --> 00:02:37,440
0,600 600,1020 1020,1080 1080,1590
{Adella - -} Yang.|
|

83
00:02:38,790 --> 00:02:40,680
0,900 990,1230 1230,1320 1320,1650 1650,1890
How do you compare {xv6
你如何比较 xv6 文件系统与你使用的文件系统。

84
00:02:40,680 --> 00:02:41,820
0,210 210,630 630,840 840,900 900,1140
-} {file,system} to the file

85
00:02:41,820 --> 00:02:43,420
0,270 270,570 570,1080
system you use.|
|

86
00:02:47,380 --> 00:02:49,300
0,390 390,420 420,810 1290,1800 1800,1920
Sorry, {what,is} that.| {The,question,is} like
抱歉，是什么。|问题是，你会如何，

87
00:02:49,300 --> 00:02:50,560
0,180 180,330 330,990 1020,1140 1140,1260
how would you,| how would
|你如何比较 xv6 文件系统

88
00:02:50,560 --> 00:02:52,090
0,90 90,540 540,750 750,1290 1290,1530
you compare the xv6 file

89
00:02:52,090 --> 00:02:53,800
0,780 810,1080 1080,1200 1200,1440 1440,1710
system| to the file system
|与你在日常生活中使用的文件系统，

90
00:02:53,800 --> 00:02:54,790
0,270 270,480 480,600 600,870 870,990
you might be using in

91
00:02:54,790 --> 00:02:56,590
0,300 300,780 1200,1590 1590,1680 1680,1800
daily life| or on your
|或者在你的笔记本电脑上，

92
00:02:56,590 --> 00:02:58,600
0,540 540,1110 1110,1470 1470,1650 1650,2010
laptop| whatever computer you're using.|
|不管你用的是什么电脑。|

93
00:03:00,700 --> 00:03:03,800
0,930 1380,2550
Any similarities.|
有没有相似之处。|

94
00:03:04,460 --> 00:03:06,290
0,240 240,600 600,1140 1140,1350 1350,1830
Yeah, like the the file
是的，比如文件系统的路径系统，

95
00:03:06,290 --> 00:03:09,680
0,360 360,960 990,1320 1320,1950 2190,3390
system paths {} system,| like
|比如路径和文件系统是分层的。

96
00:03:09,680 --> 00:03:12,320
0,690 780,1710 1710,1950 1950,2490 2490,2640
paths and file system are

97
00:03:12,320 --> 00:03:13,180
0,330
[]

98
00:03:13,180 --> 00:03:15,120
0,1050
hierarchical.|
|

99
00:03:16,060 --> 00:03:17,890
0,420 450,690 690,1260 1260,1440 1440,1830
Yep, that's a good point.|
是的，这是一个很好的观点。|

100
00:03:18,220 --> 00:03:20,020
0,330 330,720 840,1110 1110,1680 1680,1800
Okay, so you know,| so
好的，所以，|所以让我，稍微深入一点，

101
00:03:20,020 --> 00:03:21,700
0,120 120,570 720,1260 1260,1380 1380,1680
let me {}, so dive

102
00:03:21,700 --> 00:03:22,570
0,120 120,180 180,360 360,750 750,870
in a little bit| and
|稍微谈一下文件系统的属性，

103
00:03:22,570 --> 00:03:23,620
0,180 180,390 390,840 840,870 870,1050
sort of talk a little

104
00:03:23,620 --> 00:03:24,610
0,90 90,300 300,690 690,750 750,990
bit about properties of file

105
00:03:24,610 --> 00:03:26,470
0,510 510,600 600,1560 1590,1800 1800,1860
systems,| you know sort of
|有点[突出]，

106
00:03:26,470 --> 00:03:28,540
0,300 300,660 1050,1560 1560,1740 1740,2070
stand out,| {} and one
|有一个我想你刚才在这里提到的，

107
00:03:28,540 --> 00:03:29,620
0,330 330,450 450,660 660,840 840,1080
{I,think} you know you just

108
00:03:29,620 --> 00:03:31,360
0,360 360,1230 1230,1350 1350,1530 1530,1740
mentioned here,| {[] -} is
|是用户友好的命名，

109
00:03:31,360 --> 00:03:33,380
0,330 330,930 960,1560
{} {user-friendly -},

110
00:03:38,730 --> 00:03:40,480
0,210 210,270 270,600 600,1230
{user-friendly - -} names,|
|

111
00:03:40,980 --> 00:03:42,960
0,180 180,750 750,1080 1080,1500 1830,1980
in particular path names, you
特别是路径名，它的层次结构，

112
00:03:42,960 --> 00:03:44,640
0,300 330,600 600,840 840,990 990,1680
know {hierarchy -} to, hierarchy

113
00:03:44,640 --> 00:03:46,110
0,120 120,360 480,750 750,1260 1260,1470
to them,| to help people
|帮助人们组织他们的文件和目录，

114
00:03:46,110 --> 00:03:47,250
0,60 60,510 510,600 600,1020 1020,1140
to organize their files and

115
00:03:47,250 --> 00:03:49,590
0,840 900,1170 1170,1650 1650,2040 2040,2340
directories or folders| whatever term
|无论你想使用什么术语，

116
00:03:49,590 --> 00:03:51,390
0,90 90,210 210,270 270,780 960,1800
you want to use {}|
|

117
00:03:51,810 --> 00:03:53,340
0,570 570,960 960,1140 1140,1260 1260,1530
and it makes it easy
它使人们共享文件更方便，

118
00:03:53,340 --> 00:03:55,410
0,570 570,720 720,1020 1020,1350 1590,2070
for {you,know} people to share

119
00:03:55,410 --> 00:03:56,800
0,780
files|
|

120
00:03:58,850 --> 00:04:00,960
0,270 270,630 630,1500
{you,know} between users
在用户和进程之间。

121
00:04:02,520 --> 00:04:04,540
0,300 300,1320
and processes.|
|

122
00:04:04,830 --> 00:04:06,690
0,390 390,720 750,1140 1140,1380 1380,1860
You can name them with
你可以方便地给它们命名。

123
00:04:06,840 --> 00:04:09,780
0,570 570,690 690,1050 1050,1680 2190,2940
conveniently to remember names. {}|
|

124
00:04:10,390 --> 00:04:12,100
0,240 240,420 420,750 750,990 990,1710
And then probably most importantly,|
然后可能最重要的是，|

125
00:04:12,130 --> 00:04:13,240
0,570 570,660 660,840 840,990 990,1110
prepared at least for all
至少为目前我们在 xv6 中看到的所有子系统做好了准备，

126
00:04:13,240 --> 00:04:15,220
0,870 900,1530 1530,1620 1620,1800 1800,1980
the subsystems, that we've looked

127
00:04:15,220 --> 00:04:16,960
0,150 150,660 900,1140 1140,1380 1380,1740
so far in {xv6 -}|
|

128
00:04:17,020 --> 00:04:18,940
0,270 270,570 570,1350
{and,they} provide persistence,|
它们提供了持久化存储，|

129
00:04:21,770 --> 00:04:24,040
0,540 540,720 720,900 900,1680
{or,sometimes} that's called durability.|
或者有时候被称为耐久性。|

130
00:04:26,440 --> 00:04:27,670
0,330 330,540 540,570 570,1020 1020,1230
With that, I mean like
我的意思是，如果你关掉电脑，

131
00:04:27,670 --> 00:04:28,390
0,180 180,270 270,450 450,630 630,720
if you turn off your

132
00:04:28,390 --> 00:04:29,950
0,630 750,1080 1080,1320 1320,1440 1440,1560
computer,| {} you did some
|你做了一些工作，

133
00:04:29,950 --> 00:04:30,850
0,390 390,510 510,690 690,810 810,900
work,| you turn off your
|关掉了电脑或者笔记本电脑，

134
00:04:30,850 --> 00:04:31,990
0,450 450,690 720,930 930,1050 1050,1140
computer or turn off your

135
00:04:31,990 --> 00:04:34,540
0,600 990,1530 1530,1920 1920,2220 2310,2550
laptop,| {} and then a
|几天后你回来，

136
00:04:34,540 --> 00:04:35,470
0,210 210,420 420,720 720,840 840,930
couple days later you come

137
00:04:35,470 --> 00:04:36,520
0,330 330,420 420,600 600,690 690,1050
back,| you turn your computer
|重新打开电脑，

138
00:04:36,520 --> 00:04:37,840
0,450 570,870 870,990 990,1290 1290,1320
on,| {} the files are
|文件还在那里，

139
00:04:37,840 --> 00:04:38,880
0,210 210,540
still there,|
|

140
00:04:39,030 --> 00:04:41,490
0,510 510,1050 1050,1350 1380,1680 1680,2460
and { -} you continue
你可以继续使用它们工作。

141
00:04:41,520 --> 00:04:43,020
0,540 540,690 690,900
working with them.|
|

142
00:04:43,200 --> 00:04:44,850
0,450 540,900 900,1110 1110,1440 1440,1650
{} Which is different from
这不同于进程，

143
00:04:44,850 --> 00:04:47,280
0,210 210,870 870,1290 1290,2070 2100,2430
like processes| or the thing
|或者目前为止我们看到的资源，

144
00:04:47,280 --> 00:04:48,300
0,120 120,180 180,570 570,690 690,1020
of the resources that we've

145
00:04:48,390 --> 00:04:49,680
0,240 240,360 360,600 600,840 840,1290
seen so far,| which basically
|如果计算机重新启动，它们消失了，

146
00:04:49,680 --> 00:04:50,820
0,90 90,270 270,390 390,720 720,1140
you know the computer reboots,

147
00:04:50,820 --> 00:04:52,620
0,90 90,210 210,420 420,960 1230,1800
you know they're gone {}|
|

148
00:04:52,620 --> 00:04:53,520
0,330 330,480 480,630 630,720 720,900
and you have to start
你必须重新开始，

149
00:04:53,520 --> 00:04:54,750
0,90 90,360 360,510 510,780 780,1230
up again,| but file systems
|但是文件系统可以提供这种持久性。

150
00:04:54,750 --> 00:04:56,800
0,210 210,570 570,840 930,1680
can provide this persistence.|
|

151
00:04:57,060 --> 00:04:59,130
0,240 240,390 390,810 1080,1650 1650,2070
And so they're {} {you,know}
所以它们是，你们所有人都在使用它们，

152
00:05:00,140 --> 00:05:01,220
0,270 270,330 330,480 480,750 750,1080
all of you using them,|
|

153
00:05:01,340 --> 00:05:02,150
0,300 300,510 510,600 600,720 720,810
and what we're gonna be
接下来几节课我们要做的是，

154
00:05:02,150 --> 00:05:02,930
0,270 270,330 330,420 420,600 600,780
doing in the next couple

155
00:05:02,930 --> 00:05:04,400
0,330 330,390 390,660 660,1260 1260,1470
lectures is| actually understanding how
|了解它在内部是如何工作的。

156
00:05:04,400 --> 00:05:06,500
0,120 120,600 630,1080 1080,1650
to actually work internally.|
|

157
00:05:06,650 --> 00:05:08,000
0,270 270,510 540,750 750,870 870,1350
{} And this is interesting
这很有趣，有很多原因。

158
00:05:08,000 --> 00:05:09,260
0,270 270,330 330,570 570,660 660,1260
for a number of reasons.|
|

159
00:05:09,930 --> 00:05:11,160
0,660

160
00:05:18,080 --> 00:05:19,640
0,180 180,1080 1230,1350 1350,1440 1440,1560
{} One you know the
一个是抽象本身，它是有用的。

161
00:05:19,640 --> 00:05:21,100
0,750
abstraction

162
00:05:21,720 --> 00:05:24,240
0,810 840,1080 1080,1260 1260,1920
itself, it's just useful.|
|

163
00:05:27,150 --> 00:05:28,020
0,210 210,300 300,420 420,810 810,870
And so it's interesting to
所以理解幕后很有趣，

164
00:05:28,020 --> 00:05:29,430
0,540 540,690 690,1110 1110,1320 1320,1410
understand under the hood,| it's
|实际上，它的抽象是如何实现的。

165
00:05:29,430 --> 00:05:30,630
0,300 300,450 450,570 570,1080 1080,1200
actually how do abstraction is

166
00:05:30,630 --> 00:05:32,100
0,300 300,900
actually implemented.|
|

167
00:05:32,100 --> 00:05:33,030
0,150 150,360 360,570 570,750 750,930
It turns out there's a
这里面有几个关键的有趣的方面。

168
00:05:33,030 --> 00:05:36,480
0,660 780,1620 1620,2010 2010,2610 2640,3450
couple key interesting aspects.| One
|一个是崩溃安全，

169
00:05:36,720 --> 00:05:39,040
0,690 690,1050 1050,1590
is crash safety,|
|

170
00:05:43,140 --> 00:05:43,740
0,180 180,360 360,420 420,510 510,600
you'd like it to be
它是这种情况，

171
00:05:43,740 --> 00:05:44,700
0,60 60,390 390,690 690,810 810,960
the case| that you know
|比如在文件系统操作期间，

172
00:05:44,700 --> 00:05:46,950
0,600 780,1170 1200,1620 1620,2160 2160,2250
if for example during the

173
00:05:46,950 --> 00:05:49,650
0,240 240,510 510,1380 1380,1950 2250,2700
file system operation,| the {}
|计算机崩溃了，

174
00:05:49,650 --> 00:05:52,410
0,360 360,990 1170,1890 1890,2190 2190,2760
computer crashes,| that after reboot
|在重启后，文件系统仍然保持完好，

175
00:05:52,650 --> 00:05:54,690
0,660 660,900 900,1200 1200,1440 1440,2040
basically file system still intact,|
|

176
00:05:54,690 --> 00:05:56,700
0,60 60,1200 1200,1350 1350,1500 1500,2010
you know all the variants
文件系统的所有变量仍然存在，

177
00:05:56,700 --> 00:05:57,900
0,300 300,420 420,660 660,1020 1020,1200
of the file systems still

178
00:05:57,900 --> 00:05:59,100
0,480 660,900 900,990 990,1110 1110,1200
hold| and that you can
|而且你可以访问你的大部分文件，

179
00:05:59,100 --> 00:06:00,060
0,240 240,390 390,660 660,750 750,960
actually get access to most

180
00:06:00,060 --> 00:06:01,380
0,60 60,180 180,750 990,1230 1230,1320
of your files,| {it,would} be
|这会是一场灾难，

181
00:06:01,380 --> 00:06:02,820
0,60 60,690 690,840 840,1080 1080,1440
a disaster| if the computer
|如果计算机在文件系统操作过程中崩溃，

182
00:06:02,820 --> 00:06:03,660
0,390 390,480 480,540 540,750 750,840
crashed in the middle of

183
00:06:03,660 --> 00:06:05,260
0,300 300,540 540,1230
file system operation,|
|

184
00:06:05,290 --> 00:06:06,610
0,330 330,510 510,900 900,1140 1140,1320
{} you reboot and there's
你重新启动，但是没有了文件系统，

185
00:06:06,610 --> 00:06:08,020
0,210 210,420 420,690 690,1080 1110,1410
no file system anymore,| or
|或者磁盘上的数据结构已损坏，

186
00:06:08,020 --> 00:06:08,860
0,120 120,210 210,330 330,540 540,840
you know the data structure

187
00:06:08,860 --> 00:06:10,060
0,90 90,330 330,480 480,600 600,1200
on disk have been garbled|
|

188
00:06:10,330 --> 00:06:11,920
0,1020
and
你丢失了它们。

189
00:06:11,920 --> 00:06:13,120
0,180 180,450 450,660
you lost them.|
|

190
00:06:13,240 --> 00:06:14,320
0,240 240,390 390,660 660,870 870,1080
And so this actually turns
所以这是一个非常重要的话题，[]

191
00:06:14,320 --> 00:06:15,340
0,90 90,150 150,270 270,420 420,1020
out to be a really

192
00:06:15,430 --> 00:06:17,980
0,540 540,990 990,1560 1830,1950 1950,2550
{} important topic {} and

193
00:06:17,980 --> 00:06:19,810
0,810 1110,1470 1470,1590 1590,1710 1710,1830
involved| and so we're going
|所以我们将在周三讨论这个，

194
00:06:19,810 --> 00:06:21,130
0,120 120,360 360,570 570,1050 1050,1320
to talk about that on

195
00:06:21,130 --> 00:06:22,300
0,420 420,660 660,720 720,1080 1080,1170
Wednesday,| this is basically the
|这是周三课程的主要话题。

196
00:06:22,300 --> 00:06:23,740
0,210 210,540 540,630 630,1050 1050,1440
main topic for Wednesday's lecture.|
|

197
00:06:25,150 --> 00:06:26,460
0,750

198
00:06:26,810 --> 00:06:27,800
0,540 540,720 720,840 840,900 900,990
Then there's sort of a
然后有一个一般性问题，

199
00:06:27,800 --> 00:06:29,960
0,330 330,720 720,1140 1140,1530 1530,2160
general question| about how to
|关于文件系统在磁盘上如何安排。

200
00:06:29,990 --> 00:06:31,680
0,990
layout

201
00:06:31,680 --> 00:06:32,970
0,300 300,450 450,750 750,1110 1110,1290
{} the file system on

202
00:06:32,970 --> 00:06:34,020
0,540
disk.|
|

203
00:06:35,000 --> 00:06:36,260
0,990
{You,know},
你知道，这些文件，这些目录，

204
00:06:36,260 --> 00:06:37,520
0,90 90,690 690,780 780,1170 1170,1260
the files, the files, the

205
00:06:37,520 --> 00:06:39,080
0,810 900,1080 1080,1200 1200,1410 1410,1560
directories,| {} they all have
|它们都必须以某种方式在磁盘上表示，

206
00:06:39,080 --> 00:06:40,400
0,120 120,270 270,840 840,1080 1080,1320
to be represented in some

207
00:06:40,400 --> 00:06:41,570
0,240 240,390 390,480 480,840 840,1170
way on the disk,| because
|因为如果你关机后，再回来，

208
00:06:41,570 --> 00:06:42,830
0,210 210,600 600,990 990,1080 1080,1260
like after if you shut

209
00:06:42,830 --> 00:06:43,760
0,150 150,240 240,600 600,690 690,930
down your computer, come back

210
00:06:43,760 --> 00:06:44,900
0,270 270,330 330,840 840,1020 1020,1140
up,| you know all the
|所有的数据还得在那里，

211
00:06:44,900 --> 00:06:45,920
0,330 330,660 660,840 840,930 930,1020
data still has to be

212
00:06:45,920 --> 00:06:47,060
0,240 240,360 360,480 480,750 750,1140
there| and so there's basically
|所以在这个数据结构上

213
00:06:47,060 --> 00:06:48,830
0,270 270,510 510,780 780,1380 1560,1770
on this data structures| to
|以表示文件系统的数据结构

214
00:06:48,830 --> 00:06:50,100
0,840
represent

215
00:06:50,100 --> 00:06:51,510
0,660 660,870 870,1230 1230,1320 1320,1410
{} the structure of the

216
00:06:51,510 --> 00:06:52,710
0,240 240,570 570,660 660,750 750,1200
file system| or the content
|或者文件系统的内容。

217
00:06:52,710 --> 00:06:54,040
0,60 60,150 150,390 390,810
of the file system.|
|

218
00:06:54,480 --> 00:06:56,070
0,450 450,930 930,1290 1290,1530 1530,1590
In {} {xv6 -},| of
在 xv6 中，|当然表示或数据结构非常简单，

219
00:06:56,070 --> 00:06:58,530
0,270 270,360 360,480 480,1020 1530,2460
course you know that representation

220
00:06:58,530 --> 00:06:59,760
0,120 120,210 210,450 450,780 780,1230
or the data structures used

221
00:06:59,760 --> 00:07:01,560
0,510 540,840 840,1350 1350,1530 1530,1800
are quite simple,| {you,know} just
|只是出于教学上的原因，

222
00:07:01,560 --> 00:07:02,420
0,300
do

223
00:07:02,450 --> 00:07:04,640
0,210 210,870 870,1380 1380,1740 1800,2190
for pedagogical reasons| and real
|而真实的文件系统有更复杂的数据结构，

224
00:07:04,640 --> 00:07:06,650
0,240 240,690 690,960 960,1500 1500,2010
file systems more complex data

225
00:07:06,650 --> 00:07:07,580
0,420 420,540 540,660 660,750 750,930
structures,| but you can just
|但是你可以把它想象成在这个数据结构上。

226
00:07:07,580 --> 00:07:08,510
0,150 150,360 360,540 540,690 690,930
think about this as on

227
00:07:08,510 --> 00:07:10,060
0,210 210,480 480,1020
this data structures.|
|

228
00:07:10,840 --> 00:07:11,500
0,240 240,330 330,450 450,600 600,660
And so we'll see a
所以我们会在今天的课程中看到很多这样的内容。

229
00:07:11,500 --> 00:07:12,790
0,150 150,210 210,570 810,930 930,1290
lot of that in today's

230
00:07:12,790 --> 00:07:15,040
0,510 840,1050 1050,1170 1170,1860 1890,2250
lecture.| And then finally, {}
|最后，让它变得有趣的是性能。

231
00:07:15,040 --> 00:07:17,050
0,270 270,450 450,540 540,1080 1290,2010
what makes it interesting is

232
00:07:17,080 --> 00:07:18,560
0,1050
performance.|
|

233
00:07:20,360 --> 00:07:23,810
0,540 930,1710 1740,2760 2880,3360 3360,3450
{} The devices typically on
您知道在我们的存储设备中存储文件系统的设备通常速度较慢。

234
00:07:23,810 --> 00:07:25,130
0,330 330,450 450,570 570,870 870,1320
which you know file systems

235
00:07:25,130 --> 00:07:26,150
0,60 60,480 480,630 630,720 720,1020
are stored in our storage

236
00:07:26,150 --> 00:07:28,860
0,690 1080,1260 1260,1680 1680,2190
devices are typically slow.|
|

237
00:07:35,930 --> 00:07:37,310
0,240 240,630 630,1110 1110,1230 1230,1380
The meaning example to me
对我来说，读或写挡路的意思例子，

238
00:07:37,310 --> 00:07:38,240
0,120 120,330 330,390 390,840 840,930
to {read,or,write} a block,| you
|您知道，在固态硬盘上，SSD磁盘的速度是1毫秒

239
00:07:38,240 --> 00:07:39,980
0,150 150,570 570,750 750,1290 1290,1740
know on a solid-state disk,

240
00:07:40,070 --> 00:07:41,540
0,390 390,810 960,1110 1110,1290 1290,1470
SSD disk, that's {going -}

241
00:07:41,540 --> 00:07:43,490
0,150 150,510 510,570 570,1350 1620,1950
the order a millisecond| and
|因此，在毫秒内，你可以做大量的工作。

242
00:07:43,490 --> 00:07:44,270
0,150 150,210 210,270 270,510 510,780
so in the {millisecond -},

243
00:07:44,270 --> 00:07:45,350
0,120 120,210 210,360 360,480 480,1080
you can do a ton

244
00:07:45,350 --> 00:07:46,340
0,90 90,510
of work.|
|

245
00:07:46,340 --> 00:07:47,690
0,510 510,720 720,810 810,900 900,1350
{} And so it's important
因此，重要的是，您要尽量避免使用磁盘，

246
00:07:47,690 --> 00:07:49,070
0,240 240,540 540,720 720,780 780,1380
that you're trying to avoid

247
00:07:49,100 --> 00:07:51,140
0,390 390,750 750,840 840,1350 1740,2040
{} going to disk,| we'll
|我们将通过多种方式来了解这一点，

248
00:07:51,140 --> 00:07:52,250
0,180 180,390 390,480 480,870 870,1110
see that in multiple ways,|

249
00:07:52,250 --> 00:07:53,540
0,150 150,300 300,510 510,690 690,1290
so we see that potential,
因此，我们看到所有文件系统都有可能具有某种缓冲区缓存或挡路缓存。

250
00:07:53,810 --> 00:07:55,280
0,480 480,720 720,990 990,1110 1110,1470
all file system will have

251
00:07:55,280 --> 00:07:56,630
0,300 300,390 390,480 480,750 750,1350
something of a buffer cache

252
00:07:56,720 --> 00:07:58,240
0,150 150,240 240,540 540,1080
or a block cache.|
|

253
00:08:01,300 --> 00:08:02,800
0,570 570,1020 1020,1170 1170,1350 1350,1500
{} And you also see
而且您还可以看到无形的附加形式或更多的并发性。

254
00:08:02,800 --> 00:08:05,080
0,90 90,1050 1050,1530 1530,2070 2070,2280
it invisibly additional forms or

255
00:08:05,080 --> 00:08:06,660
0,300 300,960
more concurrency.|
|

256
00:08:06,800 --> 00:08:08,980
0,210 210,960 1080,1590
For example, if
例如，如果您执行路径名查找，

257
00:08:09,440 --> 00:08:10,400
0,240 240,420 420,480 480,750 750,960
you do a path name

258
00:08:10,400 --> 00:08:12,830
0,510 600,750 750,930 930,1800 1830,2430
lookup,| you know, {} then
|您知道，这通常是目录层次结构下行所需的复杂操作，

259
00:08:12,830 --> 00:08:14,660
0,210 210,630 630,870 870,1260 1260,1830
that typically is involved operation

260
00:08:14,660 --> 00:08:16,670
0,480 480,900 900,1020 1020,1440 1440,2010
required descending the directory hierarchy,|
|

261
00:08:16,670 --> 00:08:18,480
0,120 120,510 510,660 690,1260
you looking up blocks
您正在查找目录的块，

262
00:08:18,480 --> 00:08:20,880
0,180 180,1260 1350,2040 2040,2310 2310,2400
for a directory,| find the
|在目录中查找文件名，

263
00:08:20,880 --> 00:08:21,930
0,270 270,450 450,510 510,600 600,1050
file name in the directory,|
|

264
00:08:21,930 --> 00:08:22,770
0,210 210,390 390,540 540,600 600,840
then go through the next
然后检查下一个目录，等等，

265
00:08:22,770 --> 00:08:24,870
0,420 420,720 720,1200 1530,1950 1980,2100
directory, etc etc,| and you
|您想要的情况是，如果一个进程正在进行路径名查找，

266
00:08:24,870 --> 00:08:25,770
0,270 270,330 330,480 480,540 540,900
wanted to be the case

267
00:08:25,770 --> 00:08:27,150
0,180 180,390 390,780 780,1230 1230,1380
that if one process is

268
00:08:27,150 --> 00:08:28,530
0,270 270,540 540,750 750,1110 1110,1380
doing path name lookup,| another
|另一进程可以与执行路径名查找的第一进程并发或并行运行。

269
00:08:28,530 --> 00:08:30,690
0,450 450,690 720,1170 1170,1920 1980,2160
process can run concurrently or

270
00:08:30,690 --> 00:08:32,040
0,60 60,780 810,1020 1020,1110 1110,1350
in parallel with the first

271
00:08:32,040 --> 00:08:33,660
0,360 360,570 570,1140 1140,1440 1440,1620
process doing a path name

272
00:08:33,660 --> 00:08:34,340
0,300
lookup.|
|

273
00:08:34,860 --> 00:08:35,790
0,210 210,330 330,450 450,660 660,930
And so we'll see that
所以我们会看到你知道的那种并发性出现

274
00:08:35,910 --> 00:08:36,960
0,270 270,330 330,840 840,960 960,1050
sort of concurrency you know

275
00:08:36,960 --> 00:08:38,130
0,240 240,540 630,1050 1050,1170 1170,1170
shows up| again is a
|这也是文件系统上下文中的一个大话题。

276
00:08:38,130 --> 00:08:39,510
0,240 240,840 930,1140 1140,1320 1320,1380
big topic {} in the

277
00:08:39,510 --> 00:08:41,200
0,390 390,450 450,690 690,1260
context of file systems.|
|

278
00:08:41,360 --> 00:08:42,460
0,570

279
00:08:42,840 --> 00:08:44,250
0,600 660,870 870,1080 1080,1290 1290,1410
The other reason why it's
有趣的另一个原因是它将成为两个实验的主题。

280
00:08:44,250 --> 00:08:45,450
0,420 420,720 720,990 990,1140 1140,1200
interesting is it's going to

281
00:08:45,450 --> 00:08:46,140
0,60 60,150 150,480 480,570 570,690
be the topic of two

282
00:08:46,140 --> 00:08:47,240
0,510
labs.|
|

283
00:08:47,580 --> 00:08:49,680
0,330 330,450 450,660 660,1320 1500,2100
So we're gonna have {}
我们接下来的实验将完全集中在文件系统上

284
00:08:49,710 --> 00:08:51,360
0,510 510,870 870,1140 1140,1260 1260,1650
next upcoming lab is completely

285
00:08:51,360 --> 00:08:52,860
0,330 330,420 420,660 660,1110 1110,1500
focused on file systems| and
|之后的实验是虚拟内存和文件系统的组合

286
00:08:52,890 --> 00:08:54,060
0,120 120,390 390,660 660,930 930,1170
the lab after that is

287
00:08:54,060 --> 00:08:55,410
0,210 210,690 690,780 780,1050 1050,1350
a combination of virtual memory

288
00:08:55,410 --> 00:08:57,180
0,90 90,300 300,720 720,960 1350,1770
and file systems| and even
|即使是今天或本周的实验室也有一个组件，试图让缓冲区缓存更并行。

289
00:08:57,180 --> 00:08:58,230
0,150 150,420 420,540 540,930 930,1050
the lab for today or

290
00:08:58,230 --> 00:09:00,150
0,180 180,750 750,1200 1200,1290 1290,1920
this week has a component

291
00:09:00,150 --> 00:09:01,920
0,900 1140,1440 1440,1500 1500,1680 1680,1770
to trying to make the

292
00:09:01,920 --> 00:09:03,460
0,210 210,480 480,630 630,1110
buffer cache more parallel.|
|

293
00:09:05,180 --> 00:09:06,950
0,450 870,1050 1050,1230 1230,1350 1350,1770
So that's why it's interesting|
所以这就是为什么它很有趣的原因|

294
00:09:08,360 --> 00:09:09,830
0,510 510,690 690,960 960,1260 1260,1470
and you just you should
你只是你应该开始了解文件系统必须提供什么，

295
00:09:09,830 --> 00:09:11,930
0,180 180,300 300,390 390,1080 1140,2100
get off the ground to

296
00:09:11,990 --> 00:09:13,700
0,720 720,1140 1140,1230 1230,1470 1470,1710
understand what the file system

297
00:09:13,700 --> 00:09:15,230
0,180 180,720 810,1110 1110,1350 1350,1530
must provide,| just let's look
|让我们再来看看基本的文件系统调用，对吧，

298
00:09:15,230 --> 00:09:17,900
0,540 540,690 690,1170 1200,1920 1980,2670
again at the basic {}

299
00:09:17,900 --> 00:09:19,600
0,210 210,480 480,780 780,1290
file system system calls,

300
00:09:19,810 --> 00:09:21,000
0,270 270,720
right,| to
|去。

301
00:09:21,530 --> 00:09:22,780
0,630
the.|
|

302
00:09:26,420 --> 00:09:27,590
0,240 240,360 360,930 930,1050 1050,1170
If you example if {}
如果你举个例子，看看你知道的API，这些文件系统调用，

303
00:09:27,590 --> 00:09:29,600
0,450 450,840 990,1170 1170,1290 1290,2010
looking at you know API,

304
00:09:29,600 --> 00:09:31,220
0,330 330,540 540,780 780,1320 1380,1620
these file system calls,| then
|然后我们可以通过这里有几个有趣的属性，

305
00:09:31,220 --> 00:09:32,180
0,60 60,240 240,510 510,930 930,960
we can through there's a

306
00:09:32,180 --> 00:09:33,500
0,240 240,330 330,690 690,1170 1170,1320
couple of interesting properties,| that
|关于实现，这一定是真实的。

307
00:09:33,500 --> 00:09:34,460
0,270 270,360 360,630 630,900 900,960
must be true about the

308
00:09:34,460 --> 00:09:35,700
0,690
implementation.|
|

309
00:09:35,870 --> 00:09:38,120
0,600 900,1230 1230,1350 1350,2070 2130,2250
{} And so do you
所以你知道文件系统调用，

310
00:09:38,120 --> 00:09:39,710
0,120 120,450 450,690 690,930 930,1590
know the file system calls,|
|

311
00:09:42,810 --> 00:09:44,340
0,300 300,480 480,660 660,990 990,1530
we've seen them early on
我们很早就见过他们，在这个学期

312
00:09:44,520 --> 00:09:46,180
0,480 480,1080
in, {}

313
00:09:46,300 --> 00:09:48,580
0,180 180,240 240,900 990,1650 1680,2280
in the semester| and {}
|你知道，我们已经看过大多数其他Unix系统调用，我们如何实现它，

314
00:09:48,580 --> 00:09:49,270
0,90 90,210 210,420 420,600 600,690
you know we've looked at

315
00:09:49,270 --> 00:09:51,040
0,420 420,840 840,1140 1140,1410 1410,1770
most other Unix system calls

316
00:09:51,040 --> 00:09:51,850
0,120 120,210 210,300 300,660 660,810
how do we implement it,|
|

317
00:09:51,850 --> 00:09:54,130
0,150 150,510 510,600 600,1140 1680,2280
like fork and exec pipes,
就像叉子和执行管道，所有的东西，

318
00:09:54,130 --> 00:09:55,420
0,210 210,330 330,690 780,1110 1110,1290
all that stuff,| and basically
|基本上，这组讲座的重点是如何实现文件系统调用。

319
00:09:55,420 --> 00:09:56,170
0,150 150,300 300,390 390,660 660,750
this set of lectures is

320
00:09:56,170 --> 00:09:57,610
0,240 240,780 780,1110 1110,1350 1350,1440
really focusing on how to

321
00:09:57,610 --> 00:09:59,200
0,420 420,510 510,750 750,1050 1050,1590
implement the file system calls.|
|

322
00:10:00,400 --> 00:10:02,500
0,450 450,450 1590,1920 1920,1980 1980,2100
So, {} first of all,
因此，首先，让我们用一个简单的场景启动应用程序。

323
00:10:02,500 --> 00:10:05,260
0,240 240,960 1710,2430 2430,2580 2580,2760
let's startup applications with a

324
00:10:05,290 --> 00:10:07,400
0,480 480,1380
simple scenario.|
|

325
00:10:08,640 --> 00:10:10,710
0,210 210,870 900,1050 1050,1350 1470,2070
We have you know say
我们让你知道，假设我们创建了一个文件x/y，

326
00:10:10,740 --> 00:10:11,790
0,150 150,420 420,480 480,870 870,1050
we create a file {x/y

327
00:10:11,790 --> 00:10:13,080
0,720
-},|
|

328
00:10:13,080 --> 00:10:15,150
0,390 390,720 750,1350 1440,1860 1860,2070
{} or file y in
或目录x中的文件y。

329
00:10:15,150 --> 00:10:17,200
0,90 90,840 840,1290
the directory {}

330
00:10:19,110 --> 00:10:20,360
0,630
x.|
|

331
00:10:20,780 --> 00:10:21,880
0,630

332
00:10:23,700 --> 00:10:24,720
0,270 270,480 480,570 570,840 840,1020
Yeah, {it -} probably have
是啊，它可能要吐了。

333
00:10:24,720 --> 00:10:25,500
0,240
{to,oops}.|
|

334
00:10:27,740 --> 00:10:30,520
0,1890
Yeah,
是的，在文件x中，我们必须提供一些标志，

335
00:10:34,060 --> 00:10:34,990
0,210 210,330 330,570 570,810 810,930
in the file x, we

336
00:10:34,990 --> 00:10:36,940
0,120 120,420 510,840 840,1170 1170,1950
have to provide some flags,|

337
00:10:36,940 --> 00:10:37,660
0,90 90,210 210,360 360,510 510,720
we don't really care about
我们并不真的在乎他们的旗帜，所以我就忽略他们，

338
00:10:37,660 --> 00:10:38,800
0,240 240,600 600,840 840,1020 1020,1140
their flag, so I'm just

339
00:10:38,800 --> 00:10:40,450
0,120 120,180 180,420 420,810 1470,1650
going to ignore them,| so
|因此，这将创建一个文件，将您知道的文件描述符返回给调用者

340
00:10:40,450 --> 00:10:41,740
0,180 180,390 390,750 750,840 840,1290
this will create a file

341
00:10:41,740 --> 00:10:44,170
0,300 300,360 360,600 600,1290 1620,2430
returns a file descriptor {}

342
00:10:44,170 --> 00:10:45,370
0,150 150,270 270,510 510,600 600,1200
you know to the caller|
|

343
00:10:45,580 --> 00:10:46,960
0,510 510,570 570,1050 1050,1140 1140,1380
and the caller, the user
然后调用者，用户应用程序实际上可以例如通过该文件描述符来写，

344
00:10:46,960 --> 00:10:49,090
0,720 720,1260 1260,1320 1320,1740 1740,2130
application {can,then,actually} for example write,

345
00:10:49,120 --> 00:10:49,960
0,90 90,210 210,360 360,600 600,840
you know through that file

346
00:10:49,960 --> 00:10:51,550
0,720 720,870 870,1110 1110,1380 1380,1590
descriptor,| as we've seen many
|正如我们以前多次看到的，

347
00:10:51,550 --> 00:10:53,560
0,270 270,900 1260,1560 1560,1710 1710,2010
times before,| there's a write
|有写fd的，也许有bc的，你知道有三个字符。

348
00:10:53,560 --> 00:10:56,100
0,210 210,600 600,990 990,2160
{fd -}, maybe abc,

349
00:10:56,270 --> 00:10:58,180
0,210 210,420 420,690 690,1380
you know 3 characters.|
|

350
00:10:58,550 --> 00:11:00,260
0,540 720,930 930,1020 1020,1260 1260,1710
{} And one things, actually
还有一件事，实际上你已经知道了几件事情，我们可以从这两个电话中正确地指出。

351
00:11:00,260 --> 00:11:01,430
0,330 330,600 600,900 900,960 960,1170
you know already a couple

352
00:11:01,430 --> 00:11:03,020
0,150 150,270 270,360 360,750 840,1590
things that we can point

353
00:11:03,020 --> 00:11:05,120
0,360 390,630 630,1530 1530,1680 1680,2100
out right, {from,this} two calls.|
|

354
00:11:05,120 --> 00:11:07,070
0,120 120,270 270,480 480,1080 1080,1950
Is that first of all,
首先是路径名，

355
00:11:07,580 --> 00:11:08,720
0,600
the

356
00:11:10,260 --> 00:11:11,740
0,390 390,1020
path names,|
|

357
00:11:13,910 --> 00:11:14,780
0,330 330,570 570,690 690,780 780,870
let's show up in the
让我们在界面中显示，我们将不得不实现。

358
00:11:14,780 --> 00:11:16,100
0,570 570,870 870,1020 1020,1140 1140,1320
interface and we're going to

359
00:11:16,100 --> 00:11:17,660
0,180 180,330 330,960
have to implement.|
|

360
00:11:17,710 --> 00:11:20,470
0,1440 1440,1590 1590,1710 1710,2280 2310,2760
Names are {hum- -} human
名字是嗡嗡的-人类可以读懂，

361
00:11:20,470 --> 00:11:21,720
0,660
readable,|
|

362
00:11:22,680 --> 00:11:24,270
0,300 300,540 540,1170 1290,1410 1410,1590
they're not numbers, you know
它们不是数字，你知道它们是由用户选择的。

363
00:11:24,270 --> 00:11:25,560
0,150 150,330 330,780 780,990 990,1290
they get selected by the

364
00:11:25,560 --> 00:11:26,760
0,630
user.|
|

365
00:11:29,280 --> 00:11:31,110
0,570 570,1020 1020,1320 1320,1530 1530,1830
{} Another interesting thing here
这里另一个有趣的事情是，在Write系统调用中，

366
00:11:31,110 --> 00:11:32,100
0,150 150,420 420,630 630,750 750,990
is that in the write

367
00:11:32,100 --> 00:11:33,600
0,300 300,840
system call,|
|

368
00:11:33,600 --> 00:11:35,100
0,120 120,420 420,720 720,1350 1380,1500
{} there's no offset as
没有偏移量作为参数，所以偏移量是隐式的。

369
00:11:35,100 --> 00:11:36,440
0,90 90,690
an argument,

370
00:11:36,440 --> 00:11:37,850
0,150 150,240 240,630 630,750 750,1410
so the offset is implicit.|
|

371
00:11:39,350 --> 00:11:40,910
0,150 150,210 210,480 480,750 750,1560
So the file system somewhere
因此某处的文件系统必须存储偏移量，

372
00:11:41,790 --> 00:11:44,400
0,390 390,990 1050,1410 1410,2010
must store the offset,|
|

373
00:11:44,490 --> 00:11:45,270
0,150 150,270 270,420 420,480 480,780
if you do a second
如果你第二次打电话写信，

374
00:11:45,270 --> 00:11:46,470
0,270 270,390 390,690 690,990 990,1200
call to write,| write will
|写入将结束，因为您知道下一组字节将写入该位置4。

375
00:11:46,470 --> 00:11:47,460
0,150 150,330 330,570 570,690 690,990
end up as you know

376
00:11:47,490 --> 00:11:48,450
0,270 270,510 510,630 630,690 690,960
the next set of bytes

377
00:11:48,450 --> 00:11:49,710
0,150 150,420 420,510 510,750 750,1260
will written in that location

378
00:11:49,710 --> 00:11:50,660
0,420
four.|
|

379
00:11:51,080 --> 00:11:52,300
0,630

380
00:11:52,480 --> 00:11:53,350
0,90 90,240 240,390 390,720 720,870
You know, so maybe some
你知道，所以也许有一些我们没怎么看过的更有趣的电话，

381
00:11:53,350 --> 00:11:54,370
0,210 210,480 480,780 780,870 870,1020
more interesting calls that we

382
00:11:54,370 --> 00:11:55,930
0,180 180,540 540,1020 1020,1320 1320,1560
haven't looked at much,| but
|但是例如，您知道xv6和所有Unix文件系统基本上都支持创建链接的调用，

383
00:11:55,930 --> 00:11:57,280
0,120 120,750 780,900 900,1080 1080,1350
for example, you know the

384
00:11:57,370 --> 00:11:58,840
0,240 240,360 360,660 660,1080 1200,1470
{xv6 - -} and all

385
00:11:58,840 --> 00:12:00,490
0,210 210,480 480,870 870,1230 1230,1650
Unix file systems basically support

386
00:12:00,490 --> 00:12:03,430
0,360 360,720 810,1650 1680,2280 2310,2940
calls to create {} links,|
|

387
00:12:04,190 --> 00:12:05,930
0,240 300,570 570,960 960,1530 1560,1740
to have multiple names for
为了使同一文件的同一文件具有多个名称，

388
00:12:05,930 --> 00:12:07,250
0,90 90,450 450,930 930,1260 1260,1320
the same files for the

389
00:12:07,250 --> 00:12:08,720
0,270 270,720 750,900 900,990 990,1470
same file,| so for example
|例如，它可能调用LIKE LINK，基本上为原始文件创建第二个名称，

390
00:12:09,260 --> 00:12:10,760
0,210 210,390 390,900 900,1110 1110,1500
it might call like link

391
00:12:10,760 --> 00:12:13,040
0,270 270,990 1080,1680 1680,1740 1740,2280
that basically creates a second

392
00:12:13,070 --> 00:12:15,890
0,780 1560,1950 1950,2010 2010,2490 2490,2820
name for the original file,|
|

393
00:12:15,890 --> 00:12:17,150
0,180 180,300 300,570 570,870 870,1260
so for example, creates names
例如，为我们之前创建的文件y创建名称z。

394
00:12:17,150 --> 00:12:18,740
0,270 270,450 450,780 810,1140 1140,1590
z for the file y

395
00:12:19,250 --> 00:12:21,200
0,330 330,510 510,840 840,1410 1410,1950
{} that we earlier created.|
|

396
00:12:24,040 --> 00:12:26,120
0,420 480,960 960,1560
So multiple names,
因此，文件系统可能需要在内部跟踪多个名称

397
00:12:32,780 --> 00:12:33,770
0,150 150,360 360,600 600,900 900,990
the file system, probably {internally

398
00:12:33,770 --> 00:12:35,000
0,300 300,480 480,570 570,720 720,1230
-} has to keep track|
|

399
00:12:35,030 --> 00:12:36,140
0,120 120,360 360,510 510,720 720,1110
you know in some way
您知道在某种程度上，多个名称可能指向同一个文件。

400
00:12:36,140 --> 00:12:37,850
0,840 840,1170 1170,1440 1440,1590 1590,1710
that multiple names might be

401
00:12:37,850 --> 00:12:39,260
0,360 360,480 480,540 540,840 840,1410
pointing to the same file.|
|

402
00:12:40,030 --> 00:12:42,730
0,660 930,1260 1260,1470 1470,1890 1890,2700
{} We might actually remove,
我们可能会在文件打开时实际删除或更改名称空间，

403
00:12:43,870 --> 00:12:46,780
0,360 360,840 840,1110 1110,1890 1920,2910
or changed name space, while

404
00:12:46,870 --> 00:12:48,280
0,120 120,450 450,540 540,1110 1140,1410
the file is open,| so
|举个例子，为什么我们可以打电话给

405
00:12:48,280 --> 00:12:49,560
0,90 90,690
for example,

406
00:12:49,800 --> 00:12:51,630
0,480 540,690 690,840 840,1350 1380,1830
why we could call,| user
|用户可能实际上将其称为一个进程，在该进程中，同一进程可能会调用一个链接来删除特定文件。

407
00:12:51,630 --> 00:12:52,470
0,180 180,420 420,660 660,720 720,840
might actually call it a

408
00:12:52,470 --> 00:12:53,520
0,390 390,510 510,570 570,780 780,1050
process where the same process

409
00:12:53,520 --> 00:12:54,870
0,150 150,480 480,630 630,1140 1140,1350
might call a link you

410
00:12:54,870 --> 00:12:56,340
0,180 180,540 540,600 600,990 990,1470
to remove a particular file.|
|

411
00:12:56,980 --> 00:12:58,840
0,570 990,1200 1200,1500 1500,1560 1560,1860
{} In fact you know
事实上，您知道我们删除了之前实际打开的文件x/y，

412
00:12:58,840 --> 00:12:59,860
0,180 180,570 570,660 660,900 900,1020
we removed the file {x/y

413
00:12:59,860 --> 00:13:01,030
0,360 360,540 540,690 690,900 900,1170
-} that we actually open

414
00:13:01,030 --> 00:13:02,170
0,540 540,690 690,780 780,990 990,1140
earlier,| but we still have
|但是我们仍然打开了一个文件描述符

415
00:13:02,170 --> 00:13:03,970
0,90 90,300 300,750 750,1230 1590,1800
a file descriptor open| and
|所以事实上你知道我们仍然可以给它写信，

416
00:13:03,970 --> 00:13:04,900
0,180 180,240 240,720 720,780 780,930
so in fact you know

417
00:13:04,900 --> 00:13:05,740
0,90 90,210 210,510 510,750 750,840
we can still write to

418
00:13:05,740 --> 00:13:06,560
0,300
it,|

419
00:13:07,530 --> 00:13:09,480
0,750 960,1230 1230,1440 1440,1650 1650,1950
{} so we can still
所以我们仍然可以写到fd，你知道，比如字符，不管是d，e和f。

420
00:13:09,480 --> 00:13:11,010
0,270 270,600 600,840 840,1380 1410,1530
write to {fd -}, you

421
00:13:11,010 --> 00:13:12,120
0,120 120,210 210,570 570,630 630,1110
know, for example the character

422
00:13:12,120 --> 00:13:13,800
0,360 360,720 720,1170
whatever d e

423
00:13:14,020 --> 00:13:15,400
0,840
{and,f}.|
|

424
00:13:16,150 --> 00:13:17,200
0,210 210,330 330,630 630,930 930,1050
And it actually worked out
实际上一切都很顺利。

425
00:13:17,200 --> 00:13:18,140
0,390
fine.|
|

426
00:13:18,440 --> 00:13:20,840
0,510 510,780 780,1380 1380,2220 2250,2400
{} So basically while you
所以基本上，虽然您知道使用了文件文件，

427
00:13:20,840 --> 00:13:22,640
0,180 180,540 540,930 930,1020 1020,1800
know file file was used,|
|

428
00:13:22,640 --> 00:13:24,320
0,90 90,390 390,840 840,990 990,1680
the name space that surrounds
它周围的命名空间实际上是可以改变的。

429
00:13:24,320 --> 00:13:26,300
0,360 360,510 510,810 810,1260 1290,1980
it could actually be changed.|
|

430
00:13:27,160 --> 00:13:28,600
0,420 810,1080 1080,1200 1200,1350 1350,1440
And so it has to
所以必须是这样的，

431
00:13:28,600 --> 00:13:29,440
0,120 120,180 180,690 690,750 750,840
be the case,| you know
|你知道，如果你看一下这个，你就会知道一些事情，

432
00:13:29,440 --> 00:13:29,980
0,90 90,180 180,330 330,390 390,540
if you sort of look

433
00:13:29,980 --> 00:13:30,820
0,90 90,420 420,570 570,690 690,840
at this you know sort

434
00:13:30,820 --> 00:13:32,020
0,90 90,390 390,540 540,810 810,1200
of things,| that there's a
|文件系统内部发生了一系列有趣的事情，

435
00:13:32,020 --> 00:13:32,980
0,210 210,270 270,540 540,750 750,960
bunch of interesting things going

436
00:13:32,980 --> 00:13:34,570
0,390 390,870 870,960 960,1230 1230,1590
on internally the file system,|
|

437
00:13:34,840 --> 00:13:36,640
0,90 90,600 810,1140 1140,1410 1410,1800
for example the file system,
例如，文件系统、文件描述符必须关联，

438
00:13:36,850 --> 00:13:38,740
0,270 270,690 690,960 960,1050 1050,1890
file descriptor must be associated,|
|

439
00:13:39,220 --> 00:13:40,570
0,120 120,240 240,930 990,1140 1140,1350
we have some you know
我们有一些你知道的与名字无关的物体，

440
00:13:40,570 --> 00:13:43,480
0,720 1140,1890 1890,2310 2310,2820 2820,2910
object that is independent of

441
00:13:43,480 --> 00:13:45,400
0,90 90,510 870,1290 1290,1410 1410,1920
the name,| actually { -}
|其实是因为你知道即使名字改了，

442
00:13:45,940 --> 00:13:46,990
0,420 420,510 510,660 660,960 960,1050
because you know even if

443
00:13:46,990 --> 00:13:48,280
0,90 90,300 300,810 810,1080 1080,1290
the name changes,| the file
|文件描述符仍然指向或引用相同的文件对象本身。

444
00:13:48,280 --> 00:13:49,660
0,360 360,630 630,1050 1050,1260 1260,1380
descriptor still point or you

445
00:13:49,660 --> 00:13:52,060
0,150 180,810 810,1440 1470,2130 2130,2400
know, { -} references the

446
00:13:52,120 --> 00:13:54,400
0,450 450,840 840,1170 1170,1800
same file object itself.|
|

447
00:13:54,790 --> 00:13:56,620
0,450 690,1020 1020,1320 1380,1560 1560,1830
And, {} so, in fact
所以，事实上，如果你想一想，情况肯定是这样的，

448
00:13:56,620 --> 00:13:57,760
0,180 180,600 600,780 780,990 990,1140
if you think about this,

449
00:13:57,760 --> 00:13:58,360
0,90 90,330 330,420 420,540 540,600
it has to be the

450
00:13:58,360 --> 00:14:00,610
0,300 300,420 420,1080 1350,2010 2040,2250
case,| that basically {} there
|基本上必须在操作系统内存在文件的某些内部表示，

451
00:14:00,610 --> 00:14:02,830
0,210 210,300 300,660 1320,1770 1770,2220
has to be some internal

452
00:14:02,830 --> 00:14:05,650
0,840 840,1440 1560,1680 1680,2280 2400,2820
representation of the file inside

453
00:14:05,650 --> 00:14:06,670
0,60 60,120 120,510 510,840 840,1020
of the operating system,| that's
|这与名称本身无关。

454
00:14:06,670 --> 00:14:08,770
0,570 570,660 660,780 780,1200 1500,2100
independent of the name itself.|
|

455
00:14:10,630 --> 00:14:11,800
0,450 450,570 570,720 720,900 900,1170
{} And so we're looking
所以我们马上就会看到，

456
00:14:11,800 --> 00:14:12,610
0,210 210,300 300,360 360,690 690,810
at in a second,| but
|但我还想在这里说明另一点

457
00:14:12,610 --> 00:14:13,990
0,210 210,630 630,960 960,1320 1320,1380
there's one other point I

458
00:14:13,990 --> 00:14:15,280
0,270 270,330 330,570 570,930 930,1290
wanted to make here| is
|文件系统的目标是实现像我们在这里看到的那样的API

459
00:14:15,610 --> 00:14:16,720
0,300 300,690 690,780 780,870 870,1110
the goal of the file

460
00:14:16,720 --> 00:14:17,890
0,300 300,420 420,510 510,600 600,1170
system is to be implemented

461
00:14:17,890 --> 00:14:19,180
0,120 120,600 600,840 840,930 930,1290
an API like the ones

462
00:14:19,180 --> 00:14:20,320
0,180 180,300 300,600 600,960 960,1140
that we're looking here| which
|它是一种典型的文件系统API。

463
00:14:20,320 --> 00:14:21,250
0,150 150,330 330,510 510,600 600,930
is a sort of typical

464
00:14:21,250 --> 00:14:23,140
0,270 270,660 660,1410
file system API.|
|

465
00:14:23,140 --> 00:14:24,100
0,390 420,570 570,660 660,720 720,960
{You,know}, this is of course
您知道，这当然不是能够访问存储系统的唯一方法

466
00:14:24,100 --> 00:14:25,780
0,180 180,300 300,690 690,1200 1560,1680
not the only way to

467
00:14:25,780 --> 00:14:26,830
0,90 90,270 270,360 360,690 690,1050
be able to storage system|
|

468
00:14:27,070 --> 00:14:28,420
0,510 510,720 720,900 900,1230 1230,1350
or going to store the
或者要把信息存储在这个上面，

469
00:14:28,420 --> 00:14:29,470
0,420 420,540 540,840 840,930 930,1050
information on this,| you know
|您知道，我们可以想象完全不同的API。

470
00:14:29,470 --> 00:14:31,300
0,120 120,240 240,660 660,1500 1500,1830
we could imagine completely different

471
00:14:31,300 --> 00:14:32,480
0,90 90,690
{APIs -}.|
|

472
00:14:32,480 --> 00:14:35,200
0,570 870,1530 1560,2160
{} And {},
举个例子，你知道，也许可以正确使用一个数据库，

473
00:14:35,230 --> 00:14:36,520
0,180 180,660 660,750 750,870 870,1290
for example, you know maybe

474
00:14:36,520 --> 00:14:39,040
0,180 180,810 840,1530 1530,1740 2160,2520
use a database right,| store
|持久存储一些数据，

475
00:14:39,040 --> 00:14:41,080
0,120 120,360 360,1140 1170,1740 1770,2040
some data persistently,| {} but
|但是对数据的访问提供了非常不同的编程或API用户API，

476
00:14:41,080 --> 00:14:43,120
0,240 240,330 330,420 420,1320 1620,2040
access to the data provides

477
00:14:43,120 --> 00:14:45,070
0,240 240,540 540,1200 1200,1500 1500,1950
very different programming or API

478
00:14:45,070 --> 00:14:47,530
0,300 300,900 1110,1860 1890,2190 2190,2460
user API,| than a file
|而不是文件系统。

479
00:14:47,530 --> 00:14:48,580
0,240 240,630
system does.|
|

480
00:14:48,640 --> 00:14:49,840
0,210 210,360 360,630 630,1140 1140,1200
And so just important, to
所以重要的是，要记住你知道，

481
00:14:49,840 --> 00:14:50,980
0,120 120,180 180,480 480,630 630,1140
keep in mind that you

482
00:14:50,980 --> 00:14:53,470
0,450 960,1680 2010,2190 2190,2280 2280,2490
know,| {} you know there's
|您知道，组织存储系统还有其他方法

483
00:14:53,470 --> 00:14:55,240
0,180 180,450 450,660 660,1470 1470,1770
other ways of organizing storage

484
00:14:55,240 --> 00:14:56,470
0,420 420,510 510,780 780,930 930,1230
systems| and where our focus
|我们的重点将放在文件系统上，

485
00:14:56,470 --> 00:14:57,430
0,120 120,240 240,330 330,480 480,960
is going to be on

486
00:14:57,430 --> 00:14:58,750
0,240 240,540 540,690 690,930 930,1320
file system,| which is typically
|其通常由操作系统提供。

487
00:14:58,750 --> 00:15:00,220
0,480 480,630 630,720 720,1050 1050,1470
provided by an operating system.|
|

488
00:15:00,890 --> 00:15:02,810
0,270 270,480 480,930 930,1140 1320,1920
{} And databases are typically
并且数据库通常在文件系统之上实施

489
00:15:02,810 --> 00:15:03,950
0,570 570,630 630,930 930,1050 1050,1140
implemented on top of the

490
00:15:03,950 --> 00:15:05,540
0,270 270,780 780,1020 1020,1350 1350,1590
file system| or [in] most
|或者[在]围绕文件系统的大部分工作中，

491
00:15:05,540 --> 00:15:07,130
0,90 90,480 480,990 1230,1320 1320,1590
of work around the file

492
00:15:07,130 --> 00:15:09,590
0,360 750,1830 1830,2010 2010,2190 2190,2460
system,| you can't have direct
|您不能直接访问该磁盘。

493
00:15:09,590 --> 00:15:11,360
0,360 360,720 780,840 840,1350
access to the disk.|
|

494
00:15:12,750 --> 00:15:13,710
0,180 180,270 270,480 480,630 630,960
We have {} two questions
我们在聊天中有两个问题。

495
00:15:13,710 --> 00:15:15,210
0,90 90,180 180,660 870,1110 1110,1500
in the chat.| {} Yeah.|
|嗯。|

496
00:15:16,780 --> 00:15:17,800
0,420
{Let,me},
让我，(只是)问一些问题。

497
00:15:18,990 --> 00:15:19,980
0,270 270,390 390,450 450,810 810,990
[just] going to ask any

498
00:15:19,980 --> 00:15:21,140
0,660
questions.|

499
00:15:22,090 --> 00:15:23,920
0,330 330,630 630,1200 1200,1290 1290,1830
{} {So,link} increments a reference
因此LINK递增对底层文件描述符的引用，而取消链接递减。

500
00:15:24,160 --> 00:15:25,840
0,150 150,270 270,840 840,1050 1050,1680
to the underlying file descriptor

501
00:15:25,840 --> 00:15:28,540
0,600 600,1350 1350,1950 1950,2400 2430,2700
and unlink decrement.| Yes, that
|是的，这是正确的，我们稍后再详细讨论这个问题。

502
00:15:28,540 --> 00:15:29,890
0,150 150,630 660,1080 1080,1290 1290,1350
is correct, we'll talk a

503
00:15:29,890 --> 00:15:30,730
0,150 150,300 300,510 510,750 750,840
little bit more about it

504
00:15:30,730 --> 00:15:31,600
0,360
later.|
|

505
00:15:31,770 --> 00:15:33,240
0,480 480,810 810,1170 1170,1410 1410,1470
{} Another question here is
这里的另一个问题是关于软链接和硬链接的问题。

506
00:15:33,240 --> 00:15:34,560
0,330 330,450 450,810 810,1080 1080,1320
about a soft links versus

507
00:15:34,560 --> 00:15:38,040
0,270 270,720 750,1380 1770,2610 3000,3480
hard links.| {} I'm going
|今天我要讲的很多，

508
00:15:38,040 --> 00:15:39,090
0,60 60,300 300,510 510,750 750,1050
to talk much about it

509
00:15:39,090 --> 00:15:41,520
0,480 480,1200 1500,2100 2130,2310 2310,2430
today,| { -} but you
|但是您将实现软链接

510
00:15:41,520 --> 00:15:43,080
0,210 210,330 330,810 810,1170 1170,1560
will be implementing soft links|
|

511
00:15:43,080 --> 00:15:45,900
0,660 690,810 810,1410 1500,2400
in the next {}
在即将到来的文件系统实验室的下一篇文章中。

512
00:15:45,990 --> 00:15:47,010
0,180 180,240 240,450 450,750 750,1020
in the file system lab

513
00:15:47,010 --> 00:15:48,340
0,150 150,270 270,750
that is upcoming.|
|

514
00:15:48,640 --> 00:15:50,200
0,270 270,750 750,870 870,1200 1200,1560
So xv6 by itself implements
因此xv6本身实现了硬链接，

515
00:15:50,200 --> 00:15:51,640
0,210 210,630 630,870 870,1020 1020,1440
hard links,| and you implement
|此外，您还实现了软链接。

516
00:15:51,640 --> 00:15:53,080
0,270 270,570 570,810 810,960 960,1440
soft links {} in addition.|
|

517
00:15:55,040 --> 00:15:57,620
0,270 270,930 1110,1410 1410,2010
Any questions, other questions?|
还有问题吗，还有其他问题吗？|

518
00:16:04,490 --> 00:16:06,200
0,150 150,420 420,1020 1020,1170 1170,1710
The link operates on the
该链接在不在文件描述符权限下的信息节点上操作。

519
00:16:06,500 --> 00:16:07,730
0,210 210,660 660,750 750,990 990,1230
{inode - -} not under

520
00:16:07,730 --> 00:16:09,500
0,330 330,420 420,1020 1020,1380 1560,1770
file {descriptor -} right.| That's
|没错，链接项目上的工作，

521
00:16:09,500 --> 00:16:12,980
0,420 450,810 810,3120 3120,3330 3330,3480
correct, link {work,on,the} item,| so
|既然我们去那里，那就让我去吧。

522
00:16:12,980 --> 00:16:14,870
0,120 120,420 720,1110 1110,1740 1740,1890
let me since let's go

523
00:16:14,870 --> 00:16:16,180
0,360 360,690
there.| So
|因此，文件系统结构。

524
00:16:16,330 --> 00:16:18,220
0,420 420,690 690,1260
file system structures.|
|

525
00:16:20,250 --> 00:16:21,270
0,210 210,450 450,780 780,960 960,1020
So what structure does the
那么文件系统维护什么样的结构来实现刚才提到的这个API。

526
00:16:21,270 --> 00:16:23,540
0,270 270,570 570,1230 1230,1680
file system maintain to

527
00:16:23,540 --> 00:16:26,390
0,870 900,1590 1830,2130 2130,2340 2340,2850
implement {} {you,know} this API

528
00:16:26,390 --> 00:16:27,860
0,150 150,360 360,720 930,1260 1260,1470
just talked about.| So first
|所以首先最重要的属性是inode，

529
00:16:27,860 --> 00:16:28,880
0,60 60,300 300,510 510,720 720,1020
of all the most important

530
00:16:28,880 --> 00:16:30,350
0,660 660,810 810,930 930,1050 1050,1470
property is the {inode -},|
|

531
00:16:31,880 --> 00:16:32,960
0,240 240,360 360,570 570,690 690,1080
and so this is the
所以这是一个对象，它代表一个独立于名称的文件，

532
00:16:32,960 --> 00:16:34,700
0,450 450,570 570,1020 1020,1080 1080,1740
object that represents a file

533
00:16:34,790 --> 00:16:36,380
0,330 330,1050 1050,1140 1140,1230 1230,1590
{} independent of the name,|
|

534
00:16:36,530 --> 00:16:38,660
0,420 510,870 870,1620
so file info
因此文件信息与名称无关。

535
00:16:40,620 --> 00:16:42,400
0,510 510,600 600,1200
independent of name.|
|

536
00:16:45,390 --> 00:16:47,010
0,180 180,480 480,570 570,930 990,1620
In fact, you know {the,way}
实际上，您知道如何实际命名inode这个[]inode编号，从字面上看就是一个整数。

537
00:16:47,100 --> 00:16:48,480
0,390 390,660 660,990 990,1200 1200,1380
you name actually {inode -}

538
00:16:48,480 --> 00:16:49,710
0,150 150,420 420,540 540,720 720,1230
this [] {inode -} number

539
00:16:49,890 --> 00:16:52,500
0,450 450,1050 1380,1530 1530,2040
just literally an integer.|
|

540
00:16:52,620 --> 00:16:54,600
0,210 210,300 300,690 690,1410 1410,1980
So the {file,system} internally refers
因此，文件系统在内部按编号引用inode，而不是实际按路径名引用。

541
00:16:54,600 --> 00:16:57,270
0,450 540,990 990,990 990,1740 1980,2670
to {} {inode -} by

542
00:16:57,270 --> 00:16:58,590
0,300 300,600 600,690 690,1170 1170,1320
number instead of actually by

543
00:16:58,590 --> 00:16:59,820
0,720
{path,names}.|
|

544
00:17:00,500 --> 00:17:01,700
0,330 330,450 450,630 630,870 870,1200
And we also know this
而这一点我们也是从这个讨论中知道的，

545
00:17:01,700 --> 00:17:03,440
0,270 270,360 360,540 540,1200 1320,1740
based on this discussion,| that
|您知道inode实际上必须有链接计数，

546
00:17:03,440 --> 00:17:04,430
0,120 120,240 240,450 450,870 870,990
you know {inode -} {}

547
00:17:04,430 --> 00:17:06,410
0,330 330,630 630,1020 1020,1440 1440,1980
must actually have link count,|
|

548
00:17:08,600 --> 00:17:09,650
0,150 150,390 390,810 810,900 900,1050
to keep track of the
为了记录，为了记录名字的数目，

549
00:17:09,650 --> 00:17:12,360
0,420 420,900 1320,2070
number of {},

550
00:17:12,880 --> 00:17:13,510
0,120 120,240 240,450 450,510 510,630
to keep track of the

551
00:17:13,510 --> 00:17:15,280
0,300 300,540 540,1350 1350,1650 1650,1770
number of names,| that are
|指向该特定inode的

552
00:17:15,280 --> 00:17:16,690
0,360 360,660 660,840 840,1320 1320,1410
pointing to that particular {inode

553
00:17:16,690 --> 00:17:18,160
0,390 450,870 870,960 960,1230 1230,1470
-}| and the file should
|并且仅当链接计数不早于此实际达到零时才应删除该文件。

554
00:17:18,160 --> 00:17:19,690
0,180 180,300 300,870 1080,1440 1440,1530
only be deleted when the

555
00:17:19,690 --> 00:17:20,980
0,210 210,450 450,690 690,960 960,1290
link count actually reaches zero

556
00:17:20,980 --> 00:17:22,220
0,240 240,720
no earlier.|
|

557
00:17:22,590 --> 00:17:25,200
0,510 930,1230 1230,1500 1500,1800 1800,2610
It's actually slightly more complicated,|
实际上要稍微复杂一点，|

558
00:17:25,530 --> 00:17:26,970
0,360 360,510 510,720 720,840 840,1440
{} there must be also
还必须存在打开的FD计数，

559
00:17:26,970 --> 00:17:28,360
0,180 180,750
an open

560
00:17:29,170 --> 00:17:30,910
0,210 210,390 390,840 1020,1470 1470,1740
{fd -} count,| number file
|实际必须打开文件的文件描述符数

561
00:17:30,910 --> 00:17:32,230
0,510 510,660 660,960 960,1230 1230,1320
descriptors that actually have to

562
00:17:32,230 --> 00:17:34,330
0,330 330,840 1200,1710 1710,1980 1980,2100
file open| and file can
|只有当这两个值都为零时，才能删除文件。

563
00:17:34,330 --> 00:17:35,830
0,270 270,390 390,930 960,1200 1200,1500
only be deleted when both

564
00:17:35,830 --> 00:17:37,220
0,90 90,360 360,420 420,900
of these are zero.|
|

565
00:17:43,070 --> 00:17:44,300
0,480 480,600 600,810 810,1050 1050,1230
And we also know that
我们也知道，基本上基于你知道的，写入没有偏移量，

566
00:17:44,300 --> 00:17:45,590
0,420 420,780 780,1080 1080,1170 1170,1290
basically based on you know

567
00:17:45,590 --> 00:17:47,780
0,270 300,600 600,780 780,1230 1290,2190
the write have no offset,|
|

568
00:17:47,780 --> 00:17:48,980
0,420 420,600 600,960 960,1080 1080,1200
nor does read,| you know
也没有读到，|您知道，文件描述符必须隐式维护偏移量。

569
00:17:48,980 --> 00:17:50,600
0,150 150,240 240,450 450,870 870,1620
that the file descriptor implicitly

570
00:17:50,840 --> 00:17:52,760
0,660 660,1320
must maintain

571
00:17:53,880 --> 00:17:55,140
0,150 150,660
an offset.|
|

572
00:18:01,950 --> 00:18:03,180
0,720
Okay?|
好吧?|

573
00:18:03,650 --> 00:18:04,790
0,270 270,480 480,630 630,1050 1050,1140
{} And so basically the
因此，基本上，文件系统中的中心实际数据结构是索引节点

574
00:18:04,790 --> 00:18:06,440
0,450 450,720 720,990 990,1470 1470,1650
central really data structure in

575
00:18:06,440 --> 00:18:07,940
0,60 60,330 330,840 960,1260 1260,1500
a file system {} is

576
00:18:07,940 --> 00:18:09,710
0,510 510,660 660,1140 1140,1290 1290,1770
a {inode -}| and then
|然后是实际与进程交互的文件描述符。

577
00:18:09,710 --> 00:18:12,530
0,600 1410,1710 1710,2190 2190,2340 2340,2820
a file descriptor to actually

578
00:18:12,530 --> 00:18:13,320
0,270
{}

579
00:18:13,350 --> 00:18:15,750
0,300 300,1170 1170,1500 1500,1710 1710,2400
{} interact with the processes.|

580
00:18:19,820 --> 00:18:21,200
0,360 360,870
{} So,
因此，即使文件系统在API方面非常相似，

581
00:18:21,350 --> 00:18:23,210
0,570 930,1140 1140,1440 1440,1620 1620,1860
{} even though the file

582
00:18:23,210 --> 00:18:25,190
0,330 330,540 540,810 810,1410 1440,1980
systems are very similar terms

583
00:18:25,190 --> 00:18:26,330
0,180 180,240 240,420 420,1020 1020,1140
short of their API,| you
|你知道它们的实施方式都不同，

584
00:18:26,330 --> 00:18:28,700
0,120 120,330 330,630 630,1260 1680,2370
know they're all implemented differently,|
|

585
00:18:29,090 --> 00:18:32,240
0,1830 2310,2700 2700,2790 2790,2970 2970,3150
but many of them have
但它们中的许多都有一种类似的结构。

586
00:18:32,240 --> 00:18:35,630
0,330 330,840 840,1440 1680,2370 2730,3390
{a,sort,of} similar structure. { -}|
|

587
00:18:40,050 --> 00:18:41,100
0,360 360,540 540,600 600,750 750,1050
And because the file systems
而且因为文件系统相当复杂，

588
00:18:41,100 --> 00:18:42,420
0,60 60,360 360,990 990,1110 1110,1320
are quite complex,| you know
|你知道，这有助于将它们组织成一组典型的层。

589
00:18:42,420 --> 00:18:43,470
0,210 210,660 660,840 840,990 990,1050
just helps to sort of

590
00:18:43,470 --> 00:18:45,450
0,570 570,930 930,1500 1530,1740 1740,1980
organize them in a typically

591
00:18:45,450 --> 00:18:46,650
0,510 510,600 600,900 900,1110 1110,1200
organized in a set of

592
00:18:46,650 --> 00:18:47,720
0,600
layers.|
|

593
00:18:47,750 --> 00:18:49,070
0,540 720,960 960,1170 1170,1230 1230,1320
And you want me to
你想让我考虑一下，

594
00:18:49,070 --> 00:18:49,880
0,150 150,390 390,450 450,600 600,810
think about it,| this is
|这是在最下面，这是磁盘，

595
00:18:49,880 --> 00:18:51,350
0,330 330,420 420,660 660,1170 1200,1470
at the very bottom, there's

596
00:18:51,350 --> 00:18:52,500
0,90 90,630
the disk,|
|

597
00:18:53,120 --> 00:18:54,470
0,240 240,630 630,1050 1050,1140 1140,1350
some storage device that actually
一些实际保存数据的存储设备知道这些数据。

598
00:18:54,470 --> 00:18:56,150
0,630 630,750 750,840 840,1110 1140,1680
holds you know the data.|
|

599
00:18:56,870 --> 00:18:58,520
0,300 300,690 690,1050 1050,1140 1140,1650
And actually provides the persistence
并且实际上提供了持久性和持久性

600
00:18:58,520 --> 00:19:00,770
0,90 90,930 1230,1440 1440,2160 2160,2250
and durability| and typically you
|通常情况下，您知道在它的正上方有一个类似于缓冲区缓存的东西，一个挡路缓存。

601
00:19:00,770 --> 00:19:01,790
0,90 90,270 270,570 570,870 870,1020
know there's something like a

602
00:19:01,790 --> 00:19:03,410
0,270 270,690 690,810 810,1140 1140,1620
buffer cache, a block cache

603
00:19:03,440 --> 00:19:04,940
0,330 330,390 390,870
right, above it.|
|

604
00:19:05,600 --> 00:19:07,430
0,360 360,540 540,870 870,1110 1110,1830
{} So now to avoid
现在为了避免多次访问磁盘，

605
00:19:07,430 --> 00:19:10,040
0,360 360,510 510,1020 1470,1830 1830,2610
going to disk many times,|
|

606
00:19:10,040 --> 00:19:11,300
0,90 90,210 210,360 360,840 840,1260
so we're gonna cash basically
所以我们基本上要把内存中的数据兑换成现金，

607
00:19:11,300 --> 00:19:13,340
0,330 330,1020 1350,1530 1530,1920 1920,2040
data inside in memory,| so
|所以这基本上就是，你知道的记忆。

608
00:19:13,340 --> 00:19:14,030
0,180 180,300 300,420 420,480 480,690
this is going to be

609
00:19:14,030 --> 00:19:15,100
0,570
basically,

610
00:19:15,490 --> 00:19:16,920
0,150 150,300 300,870
you know memory.|
|

611
00:19:20,560 --> 00:19:23,590
0,840 840,990 990,1320 2040,2250 2250,3030
And this is the device.|
这就是那个装置。|

612
00:19:27,980 --> 00:19:29,960
0,360 360,930 930,1110 1110,1590 1620,1980
For persistence, there's something typically
对于持久性，通常会提供一些记录层，

613
00:19:29,960 --> 00:19:31,340
0,270 270,690 690,1170 1200,1290 1290,1380
offer logging layer,| you know
|您知道很多很多具有日志记录形式的文件。

614
00:19:31,340 --> 00:19:32,810
0,420 420,690 690,1080 1080,1200 1200,1470
many many files that have

615
00:19:32,810 --> 00:19:34,480
0,60 60,360 360,480 480,1050
a form of logging.|
|

616
00:19:34,540 --> 00:19:35,890
0,570 570,690 690,780 780,990 990,1350
We're going to talk emotionally
我们周三会感情用事地讨论这个问题，所以我可以跳过这个话题。

617
00:19:35,890 --> 00:19:36,700
0,180 180,240 240,570 570,720 720,810
about it Wednesday, so I

618
00:19:36,700 --> 00:19:38,220
0,120 120,480 480,930
can skip that.|
|

619
00:19:38,220 --> 00:19:39,840
0,600 660,1230 1230,1320 1320,1530 1530,1620
{} Then the top of
则记录的顶部或[]xv6，

620
00:19:39,840 --> 00:19:42,300
0,360 360,870 870,1110 1140,1560 1560,2460
the logging or [] xv6,|
|

621
00:19:42,780 --> 00:19:44,130
0,300 300,420 420,630 630,1080 1080,1350
there's an {icache -} where
有一个iCache，其中inode缓存，

622
00:19:44,130 --> 00:19:45,690
0,120 120,390 390,930 1140,1470 1470,1560
{inode -} cache,| this is
|这主要是为了同步，

623
00:19:45,690 --> 00:19:48,570
0,570 570,1020 1020,1890 2280,2460 2460,2880
mostly for synchronization,| let's also
|我们稍后再谈，

624
00:19:48,570 --> 00:19:49,380
0,240 240,450 450,510 510,690 690,810
talk about a little bit

625
00:19:49,380 --> 00:19:50,340
0,420
later,|
|

626
00:19:54,430 --> 00:19:55,480
0,270 270,360 360,450 450,600 600,1050
so now you know typically
所以现在你知道通常比这个挡路小

627
00:19:55,480 --> 00:19:57,910
0,750 1050,1620 1620,1800 1800,2280 2280,2430
smaller than this block| and
|许多信息节点被打包到一个磁盘挡路中

628
00:19:57,910 --> 00:19:59,080
0,300 300,540 540,690 690,780 780,1170
many {inodes -} are packed

629
00:19:59,080 --> 00:20:00,400
0,240 240,360 360,630 630,870 870,1320
into a single disk block|
|

630
00:20:00,970 --> 00:20:04,030
0,990 990,1920 1920,2130 2130,2400 2400,3060
provides synchronization to those individual
提供与这些单独索引节点的同步，

631
00:20:04,030 --> 00:20:05,860
0,120 120,600 840,1410 1410,1530 1530,1830
{inode -},| {} {you,know} {xv6
|您知道xv6维护iCache，

632
00:20:05,860 --> 00:20:07,760
0,210 210,750 750,870 870,1440
-} maintains {icache -},|
|

633
00:20:08,020 --> 00:20:10,360
0,570 1080,1380 1380,1620 1620,1950 1950,2340
{} and then typically that
通常情况下，您知道它是实现本身的索引节点，

634
00:20:10,360 --> 00:20:11,830
0,90 90,210 210,570 1170,1350 1350,1470
you know were {inode -}

635
00:20:11,830 --> 00:20:13,570
0,120 120,660 660,1320 1320,1410 1410,1740
the implementation itself,| you know
|您知道这种读取和写入字节的范围。

636
00:20:13,570 --> 00:20:15,070
0,360 360,540 540,660 660,1230 1230,1500
that sort of ranges for

637
00:20:15,070 --> 00:20:16,420
0,300 300,870
{read,and} writes

638
00:20:16,860 --> 00:20:18,200
0,810
bytes.|
|

639
00:20:20,610 --> 00:20:21,570
0,120 120,570 570,690 690,900 900,960
And then you know on
你知道最重要的是，我们有名字，

640
00:20:21,570 --> 00:20:23,000
0,300 300,360 360,810
top of that,

641
00:20:23,310 --> 00:20:25,400
0,240 240,690 690,1380
we have names,|
|

642
00:20:26,440 --> 00:20:27,430
0,210 210,510 510,720 720,810 810,990
like path names and file
如路径名和文件描述符操作。

643
00:20:27,430 --> 00:20:29,200
0,420 420,1080
descriptor operations.|
|

644
00:20:29,640 --> 00:20:31,560
0,480 690,1170 1170,1410 1410,1680 1680,1920
{} Anyway, every file system
无论如何，每个文件系统的组织方式都略有不同

645
00:20:31,560 --> 00:20:33,450
0,90 90,450 450,780 780,1500 1530,1890
be slightly differently organized| and
|并且层可能略有不同，

646
00:20:33,450 --> 00:20:34,890
0,360 360,510 510,570 570,960 960,1440
layers may be slightly different,|
|

647
00:20:35,220 --> 00:20:37,560
0,750 990,1710 1710,2040 2040,2130 2130,2340
{} maybe layering is not
也许分层并不总是那么严格，

648
00:20:37,560 --> 00:20:39,300
0,270 270,420 420,990 1140,1470 1470,1740
always that strict,| even {xv6
|即使是xv6，它也不总是超级严格的，

649
00:20:39,300 --> 00:20:40,410
0,240 240,360 360,660 660,900 900,1110
-} it's not always super

650
00:20:40,410 --> 00:20:42,780
0,420 720,1350 1440,1650 1650,1770 1770,2370
strict,| but it is conceptually
|但是从概念上来说，这是一个很好的思考方式。

651
00:20:42,780 --> 00:20:43,980
0,270 300,630 630,780 780,960 960,1200
good way to think about

652
00:20:43,980 --> 00:20:44,940
0,120 120,240 240,510 510,690 690,960
it| and almost all file
|并且几乎所有文件系统在其文件系统中都具有对应于不同片段的组件，

653
00:20:44,940 --> 00:20:46,560
0,390 390,780 780,1410 1410,1470 1470,1620
systems have components in their

654
00:20:46,560 --> 00:20:48,000
0,210 210,660 660,1230 1230,1320 1320,1440
file systems correspond to the

655
00:20:48,000 --> 00:20:49,020
0,270 270,720 720,810 810,900 900,1020
different pieces,| you know the
|您知道缓冲区缓存、日志记录、inode和路径名。

656
00:20:49,020 --> 00:20:50,880
0,240 240,630 630,840 840,1440
buffer cache, the logging,

657
00:20:50,880 --> 00:20:51,840
0,120 120,300 300,420 420,540 540,960
{} to the {inodes -}

658
00:20:52,020 --> 00:20:54,420
0,450 450,750 750,1170 1200,1920
and to {} {path,names}.|

659
00:20:54,600 --> 00:20:56,040
0,240 240,480 570,840 840,1200 1200,1440
And so we basically work
所以我们基本上是通过一点来工作的，

660
00:20:56,040 --> 00:20:57,060
0,120 120,420 420,480 480,660 660,1020
by through a little bit,|
|

661
00:20:57,090 --> 00:20:59,940
0,750 780,1380 1410,1830 1830,2370 2400,2850
{} through these different file
通过这些不同的文件系统层。

662
00:20:59,940 --> 00:21:01,200
0,270 270,780
system layers.|
|

663
00:21:01,980 --> 00:21:02,910
0,360 360,420 420,570 570,630 630,930
Let me talk a little
让我从最底层说起。

664
00:21:02,910 --> 00:21:04,530
0,390 390,600 600,1200 1200,1410 1410,1620
bit of starting with the

665
00:21:04,530 --> 00:21:05,860
0,360 360,780
bottom layer.|
|

666
00:21:10,000 --> 00:21:11,620
0,360 360,630 630,780 780,1050
Just looking at the
只是看看聊天记录。

667
00:21:12,890 --> 00:21:14,390
0,270 270,630 780,1140 1140,1290 1290,1500
{} chat.| {} So let
|因此，让我从存储本身、存储设备开始谈一谈。

668
00:21:14,390 --> 00:21:15,770
0,90 90,360 360,570 570,1080 1110,1380
me start with a talk

669
00:21:15,770 --> 00:21:17,000
0,60 60,240 240,360 360,690 750,1230
a little bit about storage

670
00:21:17,000 --> 00:21:19,020
0,450 450,720 720,1440
itself, storage devices.|
|

671
00:21:22,030 --> 00:21:22,810
0,120 120,330 330,540 540,690 690,780
It turns out there are
原来有很多很多不同类型的存储设备，

672
00:21:22,810 --> 00:21:24,610
0,570 570,810 810,1260 1290,1590 1590,1800
many many, many different types

673
00:21:24,610 --> 00:21:26,980
0,60 60,330 330,1050 1230,1890 1890,2370
of storage devices,| {} in
|在性能差异中，您知道容量、耐用性、

674
00:21:27,010 --> 00:21:29,050
0,150 150,570 570,1050 1050,1230 1230,2040
the difference between {} performance

675
00:21:29,050 --> 00:21:31,900
0,90 90,180 180,1140 1350,2040 2430,2850
you know capacity, {} degree

676
00:21:31,900 --> 00:21:34,270
0,90 90,960 1230,1800 1980,2280 2280,2370
of durability,| {} but you
|但是你知道你知道的两个常见的问题是

677
00:21:34,270 --> 00:21:35,170
0,120 120,300 300,390 390,480 480,900
know two of the common

678
00:21:35,170 --> 00:21:36,730
0,600 600,690 690,870 870,1410 1440,1560
ones you know are| you
|你们可能都很熟悉固态硬盘，

679
00:21:36,730 --> 00:21:37,780
0,120 120,270 270,540 540,660 660,1050
know you're probably all familiar

680
00:21:37,780 --> 00:21:39,370
0,420 420,510 510,900 1140,1440 1440,1590
with you know the {SSD

681
00:21:39,370 --> 00:21:40,400
0,510
-},|
|

682
00:21:41,000 --> 00:21:44,150
0,720 750,960 960,1590 1740,2040 2310,3150
and there maybe you know
在那里，你可能知道，有些人可能只是简单地说选择硬盘或磁盘。

683
00:21:44,300 --> 00:21:45,410
0,240 240,450 450,570 570,930 930,1110
some people may simply mean

684
00:21:45,410 --> 00:21:47,270
0,330 330,660 660,1230 1260,1440 1440,1860
choosing hard disks or magnetic

685
00:21:47,270 --> 00:21:48,260
0,510
disks.|
|

686
00:21:48,540 --> 00:21:50,400
0,690 990,1410 1410,1590 1590,1740 1740,1860
{} And you know they
你知道他们提供了大量的存储空间，

687
00:21:50,400 --> 00:21:52,140
0,570 660,930 930,1140 1140,1230 1230,1740
provide a ton of storage,|
|

688
00:21:52,350 --> 00:21:54,990
0,570 570,840 840,1140 1140,1710 2070,2640
{} in reasonable cost, {}
以合理的价格，以不同的性能，

689
00:21:54,990 --> 00:21:57,510
0,570 570,1080 1080,1500 1530,2160 2160,2520
{in,different} performance,| so SSD have
|因此SSD通常具有数百微秒的量级，在毫秒级的访问时间内，

690
00:21:57,630 --> 00:21:58,770
0,510 510,570 570,660 660,990 990,1140
typically in the order of

691
00:21:58,770 --> 00:22:00,820
0,450 450,540 540,840 840,1500
hundreds of {microseconds -},

692
00:22:00,850 --> 00:22:02,290
0,120 120,180 180,420 420,1020 1050,1440
tn the {milliseconds -} access

693
00:22:02,290 --> 00:22:03,520
0,690
time,|
|

694
00:22:04,110 --> 00:22:05,940
0,540 540,990 990,1440 1440,1590 1590,1830
well magnetic disks {} tend
嗯，对于单个读或写挡路来说，磁盘往往更多的是10毫秒的量级。

695
00:22:05,940 --> 00:22:06,720
0,90 90,330 330,600 600,690 690,780
to be more in the

696
00:22:06,720 --> 00:22:08,740
0,330 330,420 420,660 660,1470
order of ten milliseconds

697
00:22:08,800 --> 00:22:10,540
0,210 210,1020 1020,1200 1200,1290 1290,1740
to individually read or write

698
00:22:10,570 --> 00:22:12,280
0,630 630,1170
a block.|
|

699
00:22:12,940 --> 00:22:15,100
0,450 630,930 930,1650 1650,1770 1770,2160
{} The terminology is actually
这里的术语实际上是微不足道的念力，

700
00:22:15,100 --> 00:22:16,990
0,720 720,1230 1230,1620 1620,1710 1710,1890
slightly confusion here,| you know,
|你知道，术语扇区，也就是用过的积木，

701
00:22:16,990 --> 00:22:19,380
0,570 570,660 660,1200 1200,1830
{} the terms sector,

702
00:22:19,500 --> 00:22:22,360
0,390 420,750 750,1410 1440,2370
that are used blocks,|
|

703
00:22:24,430 --> 00:22:26,380
0,690 750,1050 1050,1320 1320,1410 1410,1950
{} and so in sectors
因此，在通常是历史上最小单位的扇区中，

704
00:22:26,380 --> 00:22:29,200
0,540 540,870 930,1740 1740,2130 2160,2820
typically the historically the smallest

705
00:22:29,200 --> 00:22:32,680
0,480 510,1170 1620,2160 2160,2790 2790,3480
unit,| {} that disk drives
|磁盘可以读取或写入

706
00:22:32,710 --> 00:22:34,570
0,1080 1140,1350 1350,1530 1530,1620 1620,1860
can can read or write

707
00:22:34,570 --> 00:22:36,190
0,240 300,750 750,900 900,1230 1230,1620
in| {} and so you
|所以你通常应该是512个字节，一个普通的数字，

708
00:22:36,190 --> 00:22:37,450
0,150 150,390 390,810 810,1080 1080,1260
should be typically five hundred

709
00:22:37,450 --> 00:22:38,530
0,270 270,570 570,750 750,780 780,1080
twelve bytes just a common

710
00:22:38,530 --> 00:22:39,540
0,420
number,|
|

711
00:22:39,690 --> 00:22:41,040
0,270 270,420 420,780 780,1200 1200,1350
{} the block size is
挡路大小基本上是指挡路基本上是操作系统或文件系统概念或由文件系统定义的地方

712
00:22:41,040 --> 00:22:42,360
0,690 720,900 900,960 960,1230 1230,1320
basically where a block is

713
00:22:42,360 --> 00:22:43,560
0,450 450,510 510,960 960,1110 1110,1200
basically an OS or a

714
00:22:43,560 --> 00:22:45,660
0,270 270,750 870,990 990,1650 1650,2100
file system {} idea or

715
00:22:45,690 --> 00:22:47,130
0,480 480,570 570,660 660,930 930,1440
defined by a file system|
|

716
00:22:47,340 --> 00:22:48,630
0,330 330,600 600,840 840,930 930,1290
and {in,xv6 -} for example
并且在例如xv6中是1024字节，

717
00:22:48,630 --> 00:22:50,670
0,90 90,180 180,1050 1050,1560 1860,2040
it is 1024 bytes,| and
|所以这是两个部分，

718
00:22:50,670 --> 00:22:51,720
0,120 120,270 270,420 420,900 900,1050
so it's two sectors,| so
|因此，通常情况下，挡路会调整一个或多个行业的大小。

719
00:22:51,720 --> 00:22:53,010
0,360 360,450 450,720 720,1110 1110,1290
typically the block sizes one

720
00:22:53,010 --> 00:22:55,120
0,60 60,600 1020,1680
or more sectors.|
|

721
00:22:55,120 --> 00:22:57,490
0,570 960,1650 1650,1950 1950,2250 2250,2370
{} Sometimes people refer to
有时，人们将磁盘上的扇区也称为数据块

722
00:22:57,490 --> 00:22:58,570
0,120 120,450 450,570 570,840 840,1080
the sectors on disk also

723
00:22:58,570 --> 00:22:59,800
0,90 90,660 660,870 870,1110 1110,1230
as blocks| and so you
|所以你知道术语不是特别精确。

724
00:22:59,800 --> 00:23:00,910
0,120 120,270 300,870 870,960 960,1110
know the terminology is not

725
00:23:00,910 --> 00:23:03,800
0,630 630,1410 1680,2430
particularly {} precise.|
|

726
00:23:04,590 --> 00:23:06,330
0,180 180,360 360,1110 1140,1260 1260,1740
So these devices {you,know} basically
所以你知道的这些设备基本上是坐在公交车上，

727
00:23:06,330 --> 00:23:07,740
0,450 600,780 780,960 960,1170 1170,1410
sit you know on some

728
00:23:07,740 --> 00:23:08,840
0,570
bus,|
|

729
00:23:09,060 --> 00:23:10,260
0,630 630,720 720,870 870,960 960,1200
and you know the bus
而且您知道总线连接到CPU是正确的。

730
00:23:10,260 --> 00:23:11,820
0,180 180,750 750,900 900,990 990,1560
is connected to the CPU

731
00:23:11,820 --> 00:23:12,920
0,540
right.|
|

732
00:23:12,950 --> 00:23:14,090
0,270 270,600 630,780 780,960 960,1140
{} I mean there might
我的意思是这里可能有记忆。

733
00:23:14,090 --> 00:23:15,260
0,120 120,570 570,720 720,810 810,1170
be memory on the side

734
00:23:15,260 --> 00:23:16,340
0,510
here.|
|

735
00:23:17,850 --> 00:23:20,370
0,510 510,870 870,1380 1380,1620 1800,2520
Maybe multiple {CPUs -}, {}
可能有多个CPU，在CPU上运行的文件系统中，

736
00:23:20,370 --> 00:23:21,900
0,360 360,690 690,870 870,1170 1170,1530
{in,the} {file,system} that runs on

737
00:23:22,290 --> 00:23:24,270
0,240 240,870 870,1320 1350,1740 1740,1980
the CPU,| {} stores its
|将其内部数据结构存储在内存中

738
00:23:24,270 --> 00:23:26,010
0,420 420,660 660,1080 1080,1170 1170,1740
internal data structures in memory|
|

739
00:23:26,070 --> 00:23:28,500
0,630 630,1020 1020,1320 1320,1920
and basically {reads,and} writes,|
基本上是读写，|

740
00:23:28,500 --> 00:23:33,030
0,660 1020,1500 1650,2070 2070,4020 4290,4530
{} yeah to {} to
是到固态硬盘或硬盘

741
00:23:33,030 --> 00:23:34,320
0,150 150,570 570,780 780,870 870,1290
the SSD or the {hard,disk}|

742
00:23:34,320 --> 00:23:35,370
0,120 120,390 390,600 600,660 660,1050
to actually write a block
真正写挡路或读挡路

743
00:23:35,370 --> 00:23:36,390
0,90 90,240 240,270 270,750 810,1020
or read a block| and
|因此，要实现实际的接口非常简单。

744
00:23:36,390 --> 00:23:38,260
0,120 120,390 390,720 720,1380
so to actually interface

745
00:23:38,260 --> 00:23:40,440
0,450 450,630 630,1080 1080,1620
{} is quite simple.|
|

746
00:23:40,740 --> 00:23:42,390
0,210 210,480 480,900 900,1140 1140,1650
So it's typically just read
所以它通常只是读，你知道，或者用挡路号码写。

747
00:23:42,510 --> 00:23:44,550
0,900 900,1140 1140,1560 1560,1740 1740,2040
{you,know} or write with block

748
00:23:44,550 --> 00:23:45,440
0,360
number.|
|

749
00:23:46,020 --> 00:23:47,130
0,360 360,420 420,600 600,750 750,1110
There's a little bit of
这有点过于简单化了，

750
00:23:47,160 --> 00:23:48,840
0,1020 1020,1170 1170,1380 1380,1440 1440,1680
oversimplification,| but like the core
|但就像界面的核心大体上是这样的，

751
00:23:48,840 --> 00:23:50,130
0,60 60,150 150,570 570,780 780,1290
of the interface is {roughly,that},|
|

752
00:23:50,790 --> 00:23:53,580
0,660 1110,1920 1920,1980 1980,2220 2220,2790
{} internally, of course {SSDs
当然，在内部，固态硬盘和硬盘的工作方式完全不同

753
00:23:53,580 --> 00:23:55,350
0,150 150,600 600,1080 1080,1500 1500,1770
-} and {hard,disk} to work

754
00:23:55,350 --> 00:23:58,110
0,540 540,1110 1110,1410 1410,2160 2250,2760
completely differently| and {} hardware
|而硬件提取的大部分都没有了

755
00:23:58,110 --> 00:24:00,810
0,690 690,1140 1140,1650 1680,2130 2400,2700
extracts mostly away| and {}
|它们通常是某种标准协议，如PCI或PCI Extended，

756
00:24:00,810 --> 00:24:02,310
0,480 480,630 630,930 930,1080 1080,1500
typically they're sort of standard

757
00:24:02,310 --> 00:24:05,280
0,660 660,870 870,1800 2190,2490 2490,2970
protocols like PCI or PCI

758
00:24:05,280 --> 00:24:07,650
0,690 900,1380 1380,1950 1980,2370 2370,2370
{extended -},| {} that's the
|这是处理器或文件系统用户磁盘驱动程序

759
00:24:08,790 --> 00:24:10,020
0,540 540,630 630,720 720,930 930,1230
processor or the file system

760
00:24:10,020 --> 00:24:11,970
0,450 450,840 840,1050 1050,1590 1590,1950
user {disk -} drivers| used
|用于实际与磁盘对话

761
00:24:11,970 --> 00:24:13,650
0,90 90,360 360,810 810,1170 1170,1680
to actually talk to {}

762
00:24:14,000 --> 00:24:15,680
0,630 630,990 1020,1470 1470,1620 1620,1680
disks| and often from the
|通常从磁盘驱动器或您知道的大多数磁盘看起来都是一样的

763
00:24:15,680 --> 00:24:17,990
0,240 240,540 540,870 1080,1920 2160,2310
disk driver or {} you

764
00:24:17,990 --> 00:24:19,880
0,240 270,1140 1140,1560 1560,1680 1680,1890
know most disks {you,know} sort

765
00:24:19,880 --> 00:24:21,590
0,60 60,240 240,330 330,720 870,1710
of look the same| and
|你只需提供一个挡路号码和一些数据就可以读写

766
00:24:21,680 --> 00:24:22,340
0,180 180,270 270,420 420,570 570,660
you can just read and

767
00:24:22,340 --> 00:24:24,020
0,480 540,960 960,1350 1350,1410 1410,1680
write by providing a block

768
00:24:24,020 --> 00:24:25,910
0,330 330,420 420,540 540,1020 1380,1890
number and some data| and
|然后你把它发送给一个写入器来控制寄存器，你知道这个设备

769
00:24:25,910 --> 00:24:28,220
0,570 600,1200 1650,1920 1920,2040 2040,2310
then you send it off

770
00:24:28,220 --> 00:24:29,330
0,180 180,240 240,510 510,690 690,1110
for a writer to control

771
00:24:29,330 --> 00:24:30,830
0,570 570,660 660,780 780,990 990,1500
registers you know the device|
|

772
00:24:30,830 --> 00:24:31,880
0,210 210,270 270,750 750,900 900,1050
and the device will do
这个装置就会发挥它的作用。

773
00:24:31,880 --> 00:24:32,700
0,120 120,480
its job.|
|

774
00:24:33,760 --> 00:24:35,590
0,360 360,570 570,1050 1080,1440 1440,1830
And so this from {}
因此，从文件系统的角度来看，

775
00:24:36,180 --> 00:24:39,330
0,360 360,630 630,1440 1650,2430 2430,3150
file system perspective,| {} although
|虽然你知道磁盘有非常不同的存储设备有非常不同的属性，

776
00:24:39,330 --> 00:24:40,650
0,90 90,240 240,630 720,990 990,1320
you know the the disk

777
00:24:40,650 --> 00:24:41,880
0,180 180,510 510,870 870,1110 1110,1230
have quite storage device have

778
00:24:41,880 --> 00:24:44,760
0,390 390,660 660,1380 1560,2220 2220,2880
quite different properties,| {} they're
|他们实际上是，从司机的角度来看，

779
00:24:44,760 --> 00:24:46,770
0,480 480,840 1200,1740 1740,1920 1920,2010
actually, {[] -} from the

780
00:24:46,770 --> 00:24:48,120
0,300 300,870 900,960 960,1230 1230,1350
driver's perspective,| you know so
|你知道，所以你可以用大致相同的方式编程。

781
00:24:48,120 --> 00:24:49,500
0,120 120,210 210,630 630,960 960,1380
you can program in roughly

782
00:24:49,500 --> 00:24:50,540
0,90 90,300 300,510
the same way.|
|

783
00:24:53,840 --> 00:24:55,130
0,210 210,540 540,720 720,1050 1080,1290
Any questions about that,| I'm
对此有任何疑问，|我不会太多谈论存储设备，

784
00:24:55,130 --> 00:24:56,030
0,120 120,270 270,480 480,690 690,900
not gonna talk much about

785
00:24:56,030 --> 00:24:57,980
0,120 120,420 420,900 900,1380 1740,1950
the storage devices,| so if
|所以如果你有任何问题，现在是问他们的好时机。

786
00:24:57,980 --> 00:24:58,910
0,90 90,240 240,420 420,810 810,930
you have any questions, this

787
00:24:58,910 --> 00:25:00,230
0,90 90,240 240,810 810,1020 1020,1320
is a good time to

788
00:25:00,230 --> 00:25:01,160
0,240 240,390
ask them.|
|

789
00:25:11,240 --> 00:25:12,830
0,360 360,720 720,870 870,960 960,1590
Yes, I have a question,|
是的，我有个问题，|

790
00:25:12,860 --> 00:25:16,600
0,660 1110,1320 1320,2160 2160,3120
is the interface for
是用于调用Read或Write的接口

791
00:25:16,600 --> 00:25:18,820
0,240 240,1050 1080,1500 1500,1650 1650,2220
{} calling read or write

792
00:25:18,850 --> 00:25:20,800
0,510 510,720 720,1080 1080,1710 1710,1950
something| that offers synchronous and
|它提供了同步和异步选项。

793
00:25:20,800 --> 00:25:24,100
0,630 630,1290 1650,2880 2880,3210 3210,3300
asynchronous options.| Yeah, often {this,is}
|是啊，通常都是这样的，

794
00:25:24,100 --> 00:25:24,790
0,90 90,270 270,330 330,540 540,690
the case,| in fact it's
|事实上，它大体上就像是几乎非常类似于

795
00:25:24,790 --> 00:25:26,590
0,450 450,690 690,1050 1050,1410 1410,1800
generally like it's almost very

796
00:25:26,590 --> 00:25:28,360
0,360 360,600 600,1140 1140,1470 1470,1770
similar to| actually, {} basically
|实际上，基本上您可以考虑磁盘的驱动程序

797
00:25:28,360 --> 00:25:28,900
0,60 60,150 150,300 300,480 480,540
you can think about the

798
00:25:28,900 --> 00:25:30,760
0,540 540,810 810,930 930,1380 1650,1860
driver for a disk| in
|以与控制台驱动程序相同的方式

799
00:25:30,760 --> 00:25:31,840
0,60 60,360 360,630 630,960 960,1080
the same way as the

800
00:25:31,840 --> 00:25:34,870
0,330 330,900 1200,1530 1530,2250 2280,3030
console driver| {} where {}
|在CPU或驱动器向设备发出命令的情况下，

801
00:25:35,170 --> 00:25:36,640
0,510 510,870 870,930 930,1020 1020,1470
the CPU or the driver

802
00:25:36,640 --> 00:25:37,870
0,390 390,450 450,870 870,1140 1140,1230
issues a command to the

803
00:25:37,870 --> 00:25:39,760
0,720 900,1380 1380,1560 1560,1830 1830,1890
device,| basically say start to
|基本上说开始读或写

804
00:25:39,760 --> 00:25:41,470
0,420 450,660 660,840 840,1290 1560,1710
read or do write| and
|然后在设备完成后的某个时刻

805
00:25:41,470 --> 00:25:42,280
0,90 90,180 180,330 330,570 570,810
then at some point later

806
00:25:42,280 --> 00:25:43,210
0,180 180,270 270,600 600,690 690,930
when the device is done|
|

807
00:25:43,210 --> 00:25:44,320
0,120 120,210 210,600 600,690 690,1110
and will generate an interrupt
并将生成一个中断，如OK I do to read or I do the write

808
00:25:44,320 --> 00:25:45,190
0,180 180,390 390,570 570,690 690,870
saying like OK I did

809
00:25:45,190 --> 00:25:46,150
0,90 90,510 540,750 750,810 810,960
to read or I did

810
00:25:46,150 --> 00:25:47,440
0,90 90,510 630,840 840,1200 1200,1290
the write| and then you
|然后你就知道这意味着完成了。

811
00:25:47,440 --> 00:25:49,030
0,120 120,390 540,1020 1020,1080 1080,1590
know that indicates the completion.|
|

812
00:25:50,060 --> 00:25:51,290
0,510 510,990 990,1110 1110,1170 1170,1230
{} And you know of
当然，驱动程序因为这个设备比控制台更复杂，

813
00:25:51,290 --> 00:25:53,090
0,180 180,240 240,870 960,1320 1320,1800
course, the driver since this

814
00:25:53,090 --> 00:25:54,890
0,390 390,510 510,660 660,1200 1200,1800
device is more complicated than

815
00:25:54,890 --> 00:25:55,910
0,90 90,690 690,780 780,870 870,1020
the console,| you know it's
|您知道，它的驱动程序比控制台驱动程序要复杂得多

816
00:25:55,910 --> 00:25:57,230
0,240 240,270 270,420 420,600 600,1320
quite a bit more complicated

817
00:25:57,230 --> 00:25:58,550
0,330 330,540 540,600 600,1020 1020,1320
driver than the console driver|
|

818
00:25:58,550 --> 00:25:59,540
0,120 120,210 210,480 480,630 630,990
that we saw in the
我们在上一节课中看到的

819
00:25:59,930 --> 00:26:01,520
0,510 510,900 960,1170 1170,1530 1530,1590
previous lecture| was basically the
|基本上是相同的结构，下半部分上半部分中断，

820
00:26:01,520 --> 00:26:04,070
0,240 240,750 1140,1620 1620,2190 2280,2550
same structure, bottom half top

821
00:26:04,070 --> 00:26:05,960
0,540 750,1530
half interrupts,|
|

822
00:26:05,990 --> 00:26:07,310
0,450 450,780 780,1020 1020,1080 1080,1320
{} and reading or writing
以及读取或写入控制寄存器。

823
00:26:07,310 --> 00:26:08,860
0,120 120,450 450,960
to control registers.|
|

824
00:26:10,850 --> 00:26:12,580
0,420 420,960
Okay, thanks.|
好的，谢谢。|

825
00:26:16,490 --> 00:26:18,080
0,240 240,690 1020,1320 1320,1470 1470,1590
Okay, so {}, so from
好的，那么从文件系统的角度来看，

826
00:26:18,080 --> 00:26:20,120
0,90 90,360 360,600 600,1380 1410,2040
the file system perspective,| the
|思考磁盘的方式非常简单。

827
00:26:20,150 --> 00:26:21,560
0,450 450,600 600,750 750,1200 1230,1410
way to think about the

828
00:26:21,560 --> 00:26:25,400
0,390 390,930 1410,2370 2370,3270
disk is pretty straightforward.|
|

829
00:26:25,400 --> 00:26:27,020
0,390 390,690 690,900 900,1320 1320,1620
{} Since there's a {read,or,write}
由于存在挡路或扇区的读取或写入，

830
00:26:27,020 --> 00:26:29,270
0,180 180,750 930,1110 1110,1710 1890,2250
of block or sectors,| but
|但我们可以想象一下，磁盘基本上是巨大的，你知道的，数据块阵列。

831
00:26:29,270 --> 00:26:30,320
0,120 120,240 240,450 450,690 690,1050
{we,can} just think about {the,disk}

832
00:26:30,320 --> 00:26:32,360
0,150 150,300 300,690 690,1500
{basically - -} gigantic

833
00:26:32,480 --> 00:26:34,120
0,210 210,360 360,1140
you know array

834
00:26:34,760 --> 00:26:36,340
0,360 360,1080
of blocks.|
|

835
00:26:36,340 --> 00:26:37,390
0,210 210,600 600,900 900,990 990,1050
{You,know} starting at you know
你知道从你知道的任何0开始，你知道1，

836
00:26:37,390 --> 00:26:39,100
0,390 390,1080
whatever zero,

837
00:26:39,280 --> 00:26:40,800
0,840
{you,know,one},|
|

838
00:26:40,920 --> 00:26:42,300
0,390 390,630 630,870 870,960 960,1380
and going up to whatever
并增加到任何大小的磁盘。

839
00:26:42,300 --> 00:26:44,060
0,510 510,600 600,1230
{the,size} the {disk,is}.|
|

840
00:26:44,300 --> 00:26:46,430
0,510 510,690 690,1080 1080,1440 1770,2130
{} And basically the file
基本上，文件系统的工作是对所有数据结构进行排序

841
00:26:46,430 --> 00:26:48,350
0,750 750,1410 1440,1650 1650,1770 1770,1920
system's job is to sort

842
00:26:48,350 --> 00:26:49,730
0,90 90,360 360,780 780,1050 1050,1380
of lay out all the

843
00:26:49,730 --> 00:26:51,620
0,270 270,990 1170,1530 1530,1620 1620,1890
data structures| on the disk
|在磁盘上，您可以在重新引导后重新构建文件系统。

844
00:26:51,620 --> 00:26:52,610
0,120 120,180 180,450 450,660 660,990
in a way that you

845
00:26:52,610 --> 00:26:55,100
0,150 150,960 1290,1710 1740,2040 2040,2490
can reconstruct the file system

846
00:26:55,100 --> 00:26:57,060
0,570 570,990 1020,1500
after {} reboot.|
|

847
00:26:57,740 --> 00:26:59,180
0,450 780,1110 1110,1200 1200,1320 1320,1440
And so you know there
所以你知道有不同的方式去做，

848
00:26:59,180 --> 00:26:59,840
0,30 30,270 270,420 420,480 480,660
are different ways of going

849
00:26:59,840 --> 00:27:02,240
0,330 330,660 660,1800 1800,2100 2100,2400
about it,| {} {xv6 -}
|您将看到xv6使用非常简单的布局结构，

850
00:27:02,240 --> 00:27:03,470
0,300 300,630 630,900 900,930 930,1230
you'll see uses a very

851
00:27:03,470 --> 00:27:07,940
0,690 780,1470 1470,2220 2280,3990
simple layout structure,| but,
|但是，对于文件系统的操作方式，[用户]不是很典型，也不是很典型。

852
00:27:07,940 --> 00:27:10,940
0,420 1080,1710 1710,2070 2070,2550 2550,3000
{} but not completely [user]

853
00:27:10,940 --> 00:27:13,850
0,540 690,1170 1260,1890 1920,2190 2190,2910
not pretty typical in {}

854
00:27:13,850 --> 00:27:16,730
0,270 870,1650 1650,2070 2070,2610 2610,2880
or prototypical for how file

855
00:27:16,730 --> 00:27:18,020
0,330 330,810
systems operate.|
|

856
00:27:18,110 --> 00:27:19,640
0,390 390,540 540,960 960,1260 1260,1530
{} So typically the block
因此，通常不使用挡路零

857
00:27:19,640 --> 00:27:21,170
0,330 330,570 570,990 990,1170 1170,1530
zero is generally not used|
|

858
00:27:21,170 --> 00:27:22,160
0,240 240,540 540,780 780,930 930,990
or used actually for the
或实际用于引导扇区以引导操作系统。

859
00:27:22,160 --> 00:27:23,880
0,210 210,780
boot sector,

860
00:27:24,090 --> 00:27:25,440
0,120 120,360 360,450 450,810 810,1350
to boot the operating system.|
|

861
00:27:25,860 --> 00:27:27,080
0,660

862
00:27:27,470 --> 00:27:29,330
0,750 750,1170 1170,1350 1350,1680 1680,1860
Block one is often what's
挡路一号通常是所谓的超级挡路。

863
00:27:29,330 --> 00:27:31,040
0,210 210,240 240,540 540,1170
called a super block.|
|

864
00:27:31,350 --> 00:27:32,730
0,390 390,480 480,780 780,1020 1020,1380
And the super block basically
超级挡路基本上描述了你知道的文件系统，

865
00:27:32,730 --> 00:27:34,170
0,870 870,960 960,1050 1050,1170 1170,1440
describes you know the file

866
00:27:34,170 --> 00:27:35,260
0,450
system,|
|

867
00:27:35,500 --> 00:27:36,460
0,210 210,330 330,480 480,750 750,960
and it may say like
它可能会说，哦，磁盘上有这么多块，它们构成了文件系统，

868
00:27:36,460 --> 00:27:37,750
0,210 210,390 390,510 510,720 720,1290
oh there's so many blocks

869
00:27:37,780 --> 00:27:39,220
0,300 300,600 600,720 720,960 960,1440
on disk and that constitute

870
00:27:39,220 --> 00:27:40,360
0,60 60,300 300,690 810,1080 1080,1140
the file system,| and {we'll
|稍后我们会看到，xv6中包含了更多信息，

871
00:27:40,360 --> 00:27:41,320
0,120 120,270 270,360 360,420 420,960
-} see in a second,

872
00:27:41,320 --> 00:27:42,040
0,240 240,450 450,540 540,570 570,720
{xv6 -} is a little

873
00:27:42,040 --> 00:27:43,120
0,120 120,300 300,780 780,900 900,1080
bit more information in it,|
|

874
00:27:43,120 --> 00:27:44,110
0,360 360,450 450,660 660,900 900,990
as in make most out
就像充分利用文件系统一样。

875
00:27:44,110 --> 00:27:45,380
0,90 90,270 270,780
of file system.|
|

876
00:27:45,410 --> 00:27:47,210
0,150 150,510 510,600 600,1380 1500,1800
For example, in xx6 the
例如，在xx6中，日志从挡路2开始，然后[运行]到挡路32。

877
00:27:47,210 --> 00:27:49,100
0,690 720,1110 1110,1440 1440,1740 1740,1890
{log -} starts at {you,know}

878
00:27:49,100 --> 00:27:51,080
0,60 60,450 450,990 1290,1710 1710,1980
{} block two and [runs]

879
00:27:51,080 --> 00:27:53,260
0,570 600,900 900,1590
into block 32.|
|

880
00:27:55,110 --> 00:27:55,890
0,240 240,390 390,600 600,720 720,780
Yeah, so this is a
是的，这是挡路，

881
00:27:55,890 --> 00:27:57,120
0,600
block,|
|

882
00:27:57,460 --> 00:27:58,090
0,210 210,270 270,450 450,510 510,630
and of course the block
当然，挡路可以有不同的大小

883
00:27:58,090 --> 00:27:59,110
0,150 150,240 240,540 540,930 930,1020
could be different size| and
|事实上，在超级挡路中，

884
00:27:59,110 --> 00:27:59,980
0,120 120,390 390,540 540,600 600,870
in fact in the super

885
00:27:59,980 --> 00:28:00,970
0,300 300,360 360,540 540,840 840,990
block,| it just says like
|上面只写着原木有30个街区长。

886
00:28:00,970 --> 00:28:02,650
0,90 90,420 420,600 600,1050 1410,1680
the log is whatever thirty

887
00:28:02,650 --> 00:28:03,840
0,300 300,690
blocks long.|
|

888
00:28:04,200 --> 00:28:07,680
0,600 810,1740 1770,2490 2730,3270 3270,3480
{} Then, {} {xv6 -}
然后，xv6之后从32存储到基本上挡路45都记对了，

889
00:28:07,680 --> 00:28:09,420
0,300 300,630 660,1140 1140,1380 1380,1740
after that stores from 32

890
00:28:09,420 --> 00:28:12,360
0,570 570,990 990,1470 1470,2490 2520,2940
to basically block 45 remember

891
00:28:12,360 --> 00:28:13,500
0,630
correctly,|
|

892
00:28:14,050 --> 00:28:15,910
0,780 780,960 960,1200 1200,1200 1200,1860
{} it's stores {inodes -}
就像我之前说的，这是商店信息节点，

893
00:28:18,160 --> 00:28:20,560
0,150 150,360 360,930 960,1560 1770,2400
{as,I} said before,| {} multiply
|乘法信息节点被打包成一个单独的，这个挡路我想我注意到了。

894
00:28:20,560 --> 00:28:21,730
0,300 300,390 390,810 810,1080 1080,1170
inodes are packed into a

895
00:28:21,730 --> 00:28:23,950
0,780 810,1590 1620,1800 1800,2160 2160,2220
single, {} this block I

896
00:28:23,950 --> 00:28:25,520
0,270 270,360 360,1110
think I notice.|
|

897
00:28:26,470 --> 00:28:27,730
0,150 150,630 660,810 810,960 960,1260
I believe I don't actually
我想我脑子里不记得了，

898
00:28:27,730 --> 00:28:28,510
0,390 390,510 510,570 570,720 720,780
remember at the top of

899
00:28:28,510 --> 00:28:29,020
0,60 60,240 240,330 330,390 390,510
my head,| but I think
|但我认为它要么是64字节，要么是128字节，我相信是64字节。

900
00:28:29,020 --> 00:28:30,940
0,120 120,300 300,810 810,1290
it's either 64 bytes,

901
00:28:31,920 --> 00:28:34,620
0,450 450,750 750,1170 1230,1650 1860,2700
{or,128 - -}, {I,believe} 64.|
|

902
00:28:34,950 --> 00:28:36,930
0,720 750,1140 1140,1680 1710,1860 1860,1980
And after that you know
在那之后，你知道有一个位图挡路，

903
00:28:36,930 --> 00:28:39,390
0,540 780,1380 1380,1560 1560,1950 1950,2460
there's {} a bitmap block,|
|

904
00:28:39,420 --> 00:28:40,560
0,150 150,390 390,600 600,870 870,1140
it turns out in the
事实证明，我们构建文件系统的详细方式。

905
00:28:40,830 --> 00:28:42,120
0,570 570,840 840,990 990,1170 1170,1290
details way we build the

906
00:28:42,120 --> 00:28:43,320
0,240 240,750
file system.|

907
00:28:43,440 --> 00:28:44,700
0,270 270,540 540,780 780,960 960,1260
This next {bitmap -} block
下一张挡路点阵图的大小是挡路的一倍。

908
00:28:44,700 --> 00:28:46,830
0,300 300,900 990,1290 1290,1500 1500,2130
one block {} in size.|
|

909
00:28:48,680 --> 00:28:50,000
0,270 270,360 360,630 630,1110 1110,1320
And so these basically keep
所以这些基本上记录了实际的数据块，

910
00:28:50,000 --> 00:28:51,770
0,480 480,600 600,1020 1020,1290 1320,1770
track of actually the data

911
00:28:51,770 --> 00:28:52,960
0,660
blocks,|
|

912
00:28:52,960 --> 00:28:53,890
0,150 150,420 420,600 600,810 810,930
{} whether it's free or
不管它是不是免费的，

913
00:28:53,890 --> 00:28:56,170
0,570 930,1110 1110,1440 1440,1830 1830,2280
not,| and after that it's
|在此之后，基本上都是从这里到那里，都是数据块

914
00:28:56,170 --> 00:28:58,270
0,480 630,900 900,1290 1290,1590 1590,2100
all for basically here {to,there},

915
00:28:58,270 --> 00:28:59,500
0,150 150,270 270,540 540,990 1080,1230
it's all data blocks| or
|或实际存储目录的内容、文件或内容的数据块。

916
00:28:59,500 --> 00:29:00,730
0,270 270,600 600,720 720,930 930,1230
data blocks that actually stored

917
00:29:00,730 --> 00:29:02,680
0,510 510,1080 1080,1170 1170,1650 1650,1950
contents, files or contents of

918
00:29:02,680 --> 00:29:03,860
0,750
directories.|
|

919
00:29:05,140 --> 00:29:07,930
0,570 870,1380 1380,1620 1620,2130 2460,2790
{} Often all the {bitmap
通常所有位图块和索引节点块以及记录挡路(有时称为元数据块)，

920
00:29:07,930 --> 00:29:09,550
0,210 210,810 810,1170 1200,1350 1350,1620
-} blocks and {inode -}

921
00:29:09,550 --> 00:29:11,800
0,420 420,630 630,1080 1080,1680 1830,2250
blocks and logging block, often

922
00:29:11,800 --> 00:29:13,510
0,420 420,720 720,870 870,1080 1080,1710
sometimes referred to as metadata

923
00:29:13,510 --> 00:29:14,540
0,570
blocks,|
|

924
00:29:16,940 --> 00:29:18,230
0,210 210,570 570,810 810,1020 1020,1290
they don't actually store actual
它们实际上并不存储实际数据，

925
00:29:18,230 --> 00:29:19,520
0,390 390,570 570,720 720,1200 1200,1290
data,| but they help you
|但它们可以帮助您了解它们存储了文件系统执行其工作所需的元数据信息，

926
00:29:19,520 --> 00:29:20,990
0,180 180,330 330,630 630,840 840,1470
know they store meta information

927
00:29:20,990 --> 00:29:22,040
0,330 330,390 390,660 660,930 930,1050
for the file system to

928
00:29:22,040 --> 00:29:23,320
0,120 120,330 330,780
do its job,|
|

929
00:29:23,350 --> 00:29:25,420
0,750 750,990 990,1410 1410,1530 1530,2070
like {bitmaps -} and inodes.|
例如位图和索引节点。|

930
00:29:26,390 --> 00:29:27,620
0,660

931
00:29:28,580 --> 00:29:30,170
0,210 210,810 960,1200 1200,1380 1380,1590
Any questions so far about
到目前为止对此还有什么问题吗？

932
00:29:30,170 --> 00:29:31,060
0,300
this?|
|

933
00:29:33,160 --> 00:29:34,150
0,270 270,390 390,630 630,690 690,990
{} I have a question
我有一个关于靴子挡路的问题，

934
00:29:34,150 --> 00:29:35,680
0,240 240,330 330,750 750,1290 1290,1530
about the boot block,| does
|它是否包含用于引导操作系统的代码或其他内容。

935
00:29:35,680 --> 00:29:38,380
0,210 210,990 1050,1410 1410,2160 2160,2700
it contain the code for

936
00:29:38,410 --> 00:29:39,670
0,120 120,480 480,810 810,960 960,1260
the operating system to boot

937
00:29:39,670 --> 00:29:41,380
0,210 210,690 690,1290
or something else.|
|

938
00:29:41,500 --> 00:29:44,380
0,1080 1080,1620 1650,2130 2130,2370 2370,2880
Yeah, exactly, it typically contains
是的，没错，它通常包含一个挡路代码，

939
00:29:44,380 --> 00:29:46,630
0,120 120,510 510,1050 1620,1860 1860,2250
you know {} one block

940
00:29:46,630 --> 00:29:48,760
0,390 660,1260 1290,1590 1590,1950 1950,2130
of code,| {} enough for
|足够让操作系统开始运行

941
00:29:48,760 --> 00:29:49,630
0,90 90,420 420,630 630,690 690,870
the operating system to get

942
00:29:49,630 --> 00:29:50,860
0,390 390,540 540,690 690,960 960,1230
going| and then load maybe
|然后，实际上可能会从文件系统本身加载更多的操作系统。

943
00:29:50,860 --> 00:29:52,420
0,570 630,840 840,930 930,1260 1260,1560
more of the operating system

944
00:29:52,420 --> 00:29:53,530
0,270 270,480 480,600 600,810 810,1110
actually from the file system

945
00:29:53,530 --> 00:29:54,480
0,510
itself.|
|

946
00:29:57,810 --> 00:29:59,310
0,330 330,660 930,1170 1170,1320 1320,1500
Thank you.| So does that
谢谢。|那么这是否意味着xv6的代码实际上存储在虚拟磁盘上，

947
00:29:59,310 --> 00:30:00,810
0,210 210,450 450,750 750,1260 1260,1500
mean that the code for

948
00:30:00,810 --> 00:30:02,670
0,600 600,690 690,1020 1020,1500 1500,1860
xv6 is actually stored on

949
00:30:02,700 --> 00:30:04,650
0,180 180,630 630,1200 1230,1710 1740,1950
the virtual disk,| or is
|或者就像是怎么回事。

950
00:30:04,650 --> 00:30:06,330
0,180 180,360 360,750 1170,1410 1410,1680
it like how does {}.|
|

951
00:30:06,330 --> 00:30:07,530
0,540 540,660 660,870 870,960 960,1200
Xv6, you know the way
Xv6，你知道我们处理QEMU的方式，你知道我们有一些[角落]，

952
00:30:07,530 --> 00:30:08,850
0,150 150,390 390,510 510,1140 1140,1320
we do with QEMU, you

953
00:30:08,850 --> 00:30:09,990
0,150 150,270 270,450 450,540 540,1140
know we got some [corners],|
|

954
00:30:10,320 --> 00:30:11,910
0,480 480,1080 1080,1350 1350,1530 1530,1590
{} QEMU actually has a
QEMU实际上有一个标志，您知道DASH内核基本上指向引导内核的位置

955
00:30:11,910 --> 00:30:13,350
0,540 540,630 630,720 720,960 960,1440
flag, you know dash kernel

956
00:30:13,350 --> 00:30:15,510
0,120 120,750 780,1290 1290,1500 1500,2160
that basically points to the

957
00:30:15,780 --> 00:30:17,220
0,480 480,750 750,840 840,1110 1110,1440
where boots the kernel from|
|

958
00:30:17,220 --> 00:30:18,300
0,180 180,570 570,660 660,750 750,1080
and loads, you know that
然后加载到物理内存中，你知道，在一个特定的地址，0，8，0，0，0，0，0，0，0。

959
00:30:18,300 --> 00:30:20,250
0,150 150,180 180,630 630,1110 1110,1950
at a particular address into

960
00:30:20,250 --> 00:30:22,050
0,330 330,780 780,1230 1230,1470 1470,1800
physical memory at 0 eight

961
00:30:22,050 --> 00:30:23,540
0,330 330,540 540,750 750,1170
zero zero zero zero.|
|

962
00:30:23,760 --> 00:30:25,260
0,180 180,450 450,1080 1080,1350 1350,1500
And so basically when we're
所以基本上当我们使用QEMU时，

963
00:30:25,260 --> 00:30:26,340
0,240 240,690 690,780 780,960 960,1080
using QEMU,| the way we
|按照我们使用QEMU的方式，我们真的不必担心引导扇区或类似的事情。

964
00:30:26,340 --> 00:30:27,510
0,210 210,390 390,690 690,990 990,1170
use QEMU, we don't really

965
00:30:27,510 --> 00:30:28,830
0,150 150,240 240,570 570,990 1020,1320
have to worry about boot

966
00:30:28,830 --> 00:30:30,120
0,510 510,570 570,870 870,1050 1050,1290
sectors or anything like that.|
|

967
00:30:31,420 --> 00:30:32,800
0,330 330,450 450,990 990,1200 1200,1380
Okay, so basically like when
好的，所以基本上就像当你运行Q-QEMU时，

968
00:30:32,800 --> 00:30:36,070
0,150 150,450 450,1230 1410,2250 2280,3270
you run Q- {} {QEMU

969
00:30:36,100 --> 00:30:38,740
0,630 660,990 990,1320 1320,1920 2280,2640
-},| you just you just
|你只要你你就像通过命令行一样把程序传进来，

970
00:30:38,740 --> 00:30:39,880
0,330 330,510 510,750 750,1020 1020,1140
pass in like the the

971
00:30:39,880 --> 00:30:42,130
0,810 930,1470 1470,1620 1620,1980 1980,2250
program through the command line,|
|

972
00:30:42,130 --> 00:30:42,970
0,90 90,210 210,390 390,570 570,840
and then it'll just run
然后它就会运行它，

973
00:30:42,970 --> 00:30:43,900
0,240 240,360 360,570 570,750 750,930
that,| it doesn't need to
|它不需要从虚拟磁盘和所有东西中读取它。

974
00:30:43,900 --> 00:30:45,040
0,420 420,570 570,720 720,810 810,1140
read it from the virtual

975
00:30:45,040 --> 00:30:46,960
0,270 270,360 360,960
disk and everything.|
|

976
00:30:46,990 --> 00:30:48,180
0,120 120,270 270,690
That makes sense.|
这事儿可以理解。|

977
00:30:49,650 --> 00:30:50,920
0,720

978
00:30:51,530 --> 00:30:53,240
0,240 240,450 450,720 720,780 780,1710
Okay, so like in the,
好的，就像在，举个例子，

979
00:30:53,980 --> 00:30:55,780
0,210 210,510 540,1260
so {for,example} {},|
|

980
00:30:55,960 --> 00:30:57,250
0,270 270,720 720,930 930,1110 1110,1290
so assuming I know such
所以假设我知道这样的64个字节，

981
00:30:57,250 --> 00:30:59,830
0,1260 1290,1890 1890,2340 2340,2460 2460,2580
{} 64 bytes,| you know
|例如，现在如果您想读取信息节点10，

982
00:30:59,830 --> 00:31:01,000
0,540 540,810 810,930 930,1020 1020,1170
{for,example}, now if you want

983
00:31:01,000 --> 00:31:02,890
0,90 90,540 570,1410 1410,1410 1410,1890
to read {} {inode -}

984
00:31:02,890 --> 00:31:04,160
0,690
ten,|
|

985
00:31:08,540 --> 00:31:11,000
0,810 1140,1350 1350,1500 1500,2130
what do you do.|
你的工作是什么。|

986
00:31:11,550 --> 00:31:12,300
0,240 240,330 330,450 450,660 660,750
How do you read {inode
如何读取信息节点10。

987
00:31:12,300 --> 00:31:13,460
0,180 180,630
-} ten.|
|

988
00:31:18,370 --> 00:31:19,580
0,810
Anybody?|
有人吗？|

989
00:31:22,530 --> 00:31:23,730
0,510 510,840 840,930 930,1050 1050,1200
Which block do {inode -}
信息节点10是哪个挡路？

990
00:31:23,730 --> 00:31:24,920
0,570
{ten,be}.|
|

991
00:31:25,660 --> 00:31:28,090
0,240 240,540 540,1110 1140,1860 2160,2430
You'd need to add, you
您需要添加，获取索引节点编号并将偏移量添加到磁盘中，

992
00:31:28,090 --> 00:31:29,530
0,270 270,390 390,390 390,870 870,1440
take the {inode -} number

993
00:31:29,800 --> 00:31:31,600
0,300 300,540 540,630 630,1170 1170,1800
and add the offset into

994
00:31:31,600 --> 00:31:32,890
0,270 270,630 630,870 870,1080 1080,1290
the disk,| so ten plus
|所以十加三十二。

995
00:31:32,890 --> 00:31:36,060
0,510 990,1350 1350,2130 2190,2640
32.| So 32, right,
|所以是32，对，字面上是加10或者其他的东西。

996
00:31:36,060 --> 00:31:38,100
0,360 360,750 750,1290 1290,1590 1590,2040
and it literally plus ten

997
00:31:38,100 --> 00:31:39,480
0,180 180,420 420,900
or something else.|
|

998
00:31:47,880 --> 00:31:49,650
0,240 240,420 420,660 660,1200 1200,1770
Is it ten divided by
是十除以尺码吗？

999
00:31:49,770 --> 00:31:51,900
0,210 210,1410 1440,1830 1830,1980 1980,2130
the size.| Yeah, it's gonna
|是啊，不管它是什么索引节点号，

1000
00:31:51,900 --> 00:31:53,070
0,360 360,720 720,840 840,1020 1020,1170
be whatever it's gonna be

1001
00:31:53,070 --> 00:31:54,740
0,150 150,330 330,1170
{inode -} number,|
|

1002
00:31:55,090 --> 00:31:56,900
0,330 330,570 570,1260
{inode -} number
信息节点编号乘以，我们以字节为单位，乘以64，

1003
00:31:57,370 --> 00:32:00,460
0,720 1050,1800 1800,2490 2760,3000 3000,3090
{} multiplied times, we do

1004
00:32:00,460 --> 00:32:01,660
0,90 90,180 180,570 570,780 780,1200
it in bytes, {} multiply

1005
00:32:01,660 --> 00:32:03,700
0,240 240,630 660,1530
it by 64,|
|

1006
00:32:03,970 --> 00:32:06,010
0,630 630,1050 1050,1380 1380,1710 1710,2040
divided by [five twenty four],|
除以[524]，|

1007
00:32:08,540 --> 00:32:10,040
0,330 330,510 510,660 660,1200 1200,1500
so {inode -} zero will
因此，信息节点0将最终出现在挡路32中，

1008
00:32:10,040 --> 00:32:12,040
0,210 210,390 390,690 690,1500
end up {in,block} 32,|
|

1009
00:32:12,040 --> 00:32:14,440
0,960 990,1170 1170,1890
{} {inode -}
无论索引节点是524除以64，

1010
00:32:14,690 --> 00:32:17,180
0,870 1020,1620 1620,2070 2070,2340 2340,2490
whatever was five twenty four

1011
00:32:17,180 --> 00:32:19,000
0,330 330,450 450,1230
divided by 64,|
|

1012
00:32:23,640 --> 00:32:26,700
0,2280 2280,2490 2490,2730 2730,2910 2910,3060
{16?,16,that's} about right,| so I
16岁？16岁，差不多吧，|所以我知道十七会在哪里结束，

1013
00:32:26,700 --> 00:32:28,740
0,180 180,870 870,1140 1140,1470 1470,2040
know seventeen where will where

1014
00:32:28,740 --> 00:32:30,140
0,180 180,360 360,510 510,870
will it end up,|
|

1015
00:32:32,960 --> 00:32:34,130
0,210 210,330 330,720 720,900 900,1170
should be in, should {be,ing}
应该在，应该在挡路33对吧。

1016
00:32:34,130 --> 00:32:36,120
0,330 330,540 540,840 870,1230
block {33 -} right.|
|

1017
00:32:37,710 --> 00:32:39,020
0,150 150,240 240,360 360,630
Does that make sense?|
这说得通吗？|

1018
00:32:39,520 --> 00:32:40,990
0,240 270,570 570,930 930,1320 1320,1470
So given unknown number, we
因此，在给定未知数的情况下，我们始终可以在磁盘上找到索引节点实际存储的字节数。

1019
00:32:40,990 --> 00:32:43,060
0,120 120,390 390,930 1020,1500 1500,2070
can always find {} the

1020
00:32:43,090 --> 00:32:44,680
0,330 330,570 570,930 930,1350 1350,1590
bytes on disk where {inode

1021
00:32:44,680 --> 00:32:46,280
0,240 240,600 600,1080
-} actually stored.|
|

1022
00:32:47,370 --> 00:32:48,440
0,630
Okay?|
好吧?|

1023
00:32:50,580 --> 00:32:52,080
0,270 270,750 780,1110 1110,1320 1320,1500
Okay, so then let's look
好的，那么我们来看一下，

1024
00:32:52,080 --> 00:32:54,330
0,120 120,780 1230,1560 1560,1860 1860,2250
at the,| {} what actually
|磁盘索引节点上的实际内容。

1025
00:32:54,330 --> 00:32:56,460
0,360 840,1380 1410,1680 1680,1890 1890,2130
is in on disk {inode

1026
00:32:56,460 --> 00:32:57,420
0,450
-}.|
|

1027
00:33:04,850 --> 00:33:06,200
0,510 510,690 690,1110 1140,1230 1230,1350
So as we know it,|
所以据我们所知，|

1028
00:33:06,200 --> 00:33:08,360
0,720 750,1110 1110,1350 1350,1590 1590,2160
before you'll see there's basically
在此之前，您将看到基本上没有什么数据结构，64字节大小，

1029
00:33:08,360 --> 00:33:10,700
0,210 210,480 480,1050 1260,1830 1830,2340
little data structure, 64 bytes

1030
00:33:10,730 --> 00:33:12,180
0,210 210,900
in size,|
|

1031
00:33:13,760 --> 00:33:15,440
0,570 570,1110 1110,1200 1200,1320 1320,1680
{} and you know typically
你知道，通常有一种类型，我们稍后会谈到，

1032
00:33:15,440 --> 00:33:16,820
0,270 270,330 330,870
has a type,

1033
00:33:16,880 --> 00:33:18,230
0,420 420,660 660,870 870,1020 1020,1350
which we'll talk about it

1034
00:33:18,230 --> 00:33:19,400
0,300 300,480 480,540 540,840 840,1170
later,| but for example type
|而是例如键入文件或目录和链接。

1035
00:33:19,400 --> 00:33:22,340
0,450 450,600 600,1290 1650,2130 2160,2940
file or directory and link.|
|

1036
00:33:23,640 --> 00:33:24,900
0,120 120,210 210,510 510,810 810,1260
You know the link count
您知道跟踪多个名称或指向同一inode的链接计数，

1037
00:33:25,200 --> 00:33:27,690
0,330 330,1110 1110,1860 1890,2430 2430,2490
to track multiple names or

1038
00:33:27,690 --> 00:33:28,620
0,300 300,420 420,510 510,780 780,930
pointing to the same {inode

1039
00:33:28,620 --> 00:33:29,520
0,360
-},|
|

1040
00:33:29,580 --> 00:33:31,880
0,270 270,840 840,1080 1080,1650
{} size in bytes.|
以字节为单位的大小。|

1041
00:33:32,960 --> 00:33:35,660
0,510 510,1080 1080,2010 2010,2280 2280,2700
And then {} {xv6 -}
然后是xv6，您知道在不同的文件中可能会略有不同

1042
00:33:35,660 --> 00:33:36,440
0,90 90,240 240,420 420,600 600,780
you know there can be

1043
00:33:36,440 --> 00:33:37,760
0,330 330,630 630,690 690,960 960,1320
slightly different in different files|
|

1044
00:33:37,760 --> 00:33:39,080
0,90 90,420 420,570 570,660 660,1320
and exactly how the representation
以及具体的表现形式，

1045
00:33:39,080 --> 00:33:40,970
0,300 630,1320 1350,1530 1530,1650 1650,1890
is,| {} but in {xv6
|但是在xv6中有更多的空间，

1046
00:33:40,970 --> 00:33:43,370
0,510 870,1380 1410,2130 2130,2280 2280,2400
-} a little bit more

1047
00:33:43,370 --> 00:33:44,360
0,540
space,|
|

1048
00:33:49,760 --> 00:33:51,170
0,150 150,390 390,720 720,1320 1320,1410
in {xv6 -} basically is
在xv6中，基本上后面跟着多个挡路号码，

1049
00:33:51,170 --> 00:33:52,550
0,540 540,930 930,1080 1080,1320 1320,1380
followed by a number of

1050
00:33:52,550 --> 00:33:53,880
0,300 300,780
block numbers,|
|

1051
00:33:54,120 --> 00:33:55,590
0,480 480,630 630,900 900,1170 1170,1470
{} and so after block
因此，在挡路排名第零位之后，挡路排名第一，

1052
00:33:55,590 --> 00:33:58,680
0,660 690,1500 1770,2160 2160,2430 2430,3090
number zero, block number one,|
|

1053
00:33:59,240 --> 00:34:01,580
0,120 120,450 840,1170 1200,1920 2070,2340
in fact, there were twelve
事实上，有12个这样的人，

1054
00:34:01,580 --> 00:34:03,080
0,120 120,330 330,900
of those guys,|
|

1055
00:34:03,140 --> 00:34:05,270
0,240 240,900 900,1320 1320,1620 1620,2130
these twelve direct block numbers.|
这十二个挡路直拨号码。|

1056
00:34:10,510 --> 00:34:11,470
0,180 180,300 300,600 600,720 720,960
And those direct node block
而那些直接节点挡路编号基本上对应于构成该文件的前12个块。

1057
00:34:11,470 --> 00:34:12,760
0,210 210,510 510,1080 1080,1200 1200,1290
numbers basically correspond to the

1058
00:34:12,760 --> 00:34:15,280
0,690 690,1320 1320,1770 1770,1920 1920,2520
first twelve blocks that constitute

1059
00:34:15,280 --> 00:34:16,440
0,180 180,630
that file.|
|

1060
00:34:16,440 --> 00:34:17,190
0,210 210,270 270,600 600,660 660,750
So, for example if the
例如，如果文件只有两个字节长，

1061
00:34:17,190 --> 00:34:18,420
0,270 270,420 420,750 750,930 930,1230
file was only two bytes

1062
00:34:18,420 --> 00:34:19,650
0,510 570,660 660,840 840,1050 1050,1230
long,| you know there would
|你知道只有一个挡路号码是零

1063
00:34:19,650 --> 00:34:21,990
0,120 120,510 510,1020 1020,2010 2040,2340
be only one a block

1064
00:34:21,990 --> 00:34:24,000
0,180 180,780 1110,1500 1500,1860 1860,2010
number zero| and block number
|而挡路数字为零，即包含挡路的磁盘挡路的挡路编号

1065
00:34:24,000 --> 00:34:25,240
0,300 300,450 450,690
zero is that,

1066
00:34:25,360 --> 00:34:27,160
0,420 450,1080 1080,1380 1380,1650 1650,1800
the block number of the

1067
00:34:27,160 --> 00:34:28,780
0,300 300,600 600,750 750,1500 1500,1620
disk block that contains| you
|您知道该文件的前几个字节。

1068
00:34:28,780 --> 00:34:30,220
0,150 150,300 300,690 720,1110 1110,1440
know the first few bytes

1069
00:34:30,220 --> 00:34:31,620
0,270 330,510 510,930
of that file.|
|

1070
00:34:32,290 --> 00:34:35,110
0,330 330,810 1080,1560 1560,2100 2370,2820
And then there's one indirect
然后还有一个间接的挡路号码，

1071
00:34:35,110 --> 00:34:36,560
0,240 240,930
block number,|
|

1072
00:34:41,570 --> 00:34:43,340
0,510 510,780 780,840 840,1140 1140,1770
basically that's a block number,
基本上这是一个挡路号码，相当于一个挡路，

1073
00:34:44,110 --> 00:34:45,820
0,300 300,900 900,1020 1020,1020 1020,1710
that corresponds to a block,|
|

1074
00:34:46,550 --> 00:34:48,700
0,600 630,870 870,1650
which then itself
那么其本身的挡路是524字节，其保存256个挡路号码。

1075
00:34:49,080 --> 00:34:50,340
0,450 450,540 540,780 780,1080 1080,1260
block is five twenty four

1076
00:34:50,340 --> 00:34:53,140
0,330 330,870 870,1500 1530,2220
bytes which holds {

1077
00:34:53,590 --> 00:34:56,080
0,300 300,1110 1110,1440 1440,1950
-} 256 block numbers.|
|

1078
00:35:01,800 --> 00:35:03,180
0,270 270,450 450,690 690,900 900,1380
So if block number zero,
所以如果挡路是零，对于挡路十一，

1079
00:35:03,180 --> 00:35:04,380
0,210 210,540 540,720 720,1020 1020,1200
{ -} for block number

1080
00:35:04,380 --> 00:35:05,600
0,630
eleven,|
|

1081
00:35:06,250 --> 00:35:07,420
0,660
are
都是挡路直拨号码吗

1082
00:35:08,050 --> 00:35:10,030
0,600 630,1230 1230,1440 1440,1800 1800,1980
all direct block numbers| and
|然后是十二号挡路，你知道，储存在那个间接的挡路里，

1083
00:35:10,030 --> 00:35:11,830
0,180 180,630 630,900 900,1200 1200,1800
so then block number twelve

1084
00:35:11,860 --> 00:35:13,980
0,420 420,840 840,990 990,1380
{you,know} stored in that,

1085
00:35:17,560 --> 00:35:20,200
0,180 180,420 420,900 900,1560 1920,2640
in that indirect block,| basically
|基本上指的是间接的挡路数字。

1086
00:35:20,200 --> 00:35:22,600
0,390 390,660 660,1140 1170,1890 1920,2400
pointed to by the indirect

1087
00:35:22,600 --> 00:35:23,760
0,240 240,630
block number.|
|

1088
00:35:25,900 --> 00:35:27,490
0,150 150,330 330,450 450,1020 1020,1590
And that is basically the
这基本上就是xv6中文件的布局。

1089
00:35:27,820 --> 00:35:31,360
0,1020 1080,1740 1770,1890 1890,2670 2970,3540
layout of the file in

1090
00:35:32,260 --> 00:35:34,080
0,570 570,870 870,1320
{} {xv6 -}.|
|

1091
00:35:35,300 --> 00:35:36,140
0,210 210,300 300,480 480,570 570,840
And so what is the
那么基于此，xv6中的最大文件大小是多少呢？

1092
00:35:36,140 --> 00:35:37,940
0,360 360,630 630,1080 1080,1260 1260,1800
maximum file size in xv6

1093
00:35:37,940 --> 00:35:39,280
0,210 210,300 300,750
based on this.|
|

1094
00:35:45,880 --> 00:35:47,080
0,660
Anybody?|
有人吗？|

1095
00:35:54,240 --> 00:35:56,790
0,60 60,180 180,480 750,1770 1770,2550
It would be 268 times
基本上是268x 1,024字节。

1096
00:35:56,820 --> 00:35:58,140
0,210 210,570 570,780 780,960 960,1320
a thousand twenty four bytes,

1097
00:35:58,140 --> 00:36:00,210
0,450 810,1230 1230,1650 1650,1860 1860,2070
basically.| Yeah we're just two
|是的，我们只有256，加上1212次直达乘以0024

1098
00:36:00,210 --> 00:36:01,720
0,300 300,870
fifty six,

1099
00:36:02,320 --> 00:36:05,900
0,390 390,2940
plus {12,12,direct}

1100
00:36:06,250 --> 00:36:08,110
0,570 570,960 960,1200 1200,1710 1740,1860
times thousand twenty four| and
|然后我们得到以字节为单位的最大文件大小，对吧。

1101
00:36:08,110 --> 00:36:09,130
0,180 180,270 270,450 450,630 630,1020
then we get the maximum

1102
00:36:09,130 --> 00:36:10,720
0,270 270,600 600,690 690,1200 1230,1590
file size in bytes, right.|
|

1103
00:36:12,840 --> 00:36:14,520
0,180 180,390 390,510 510,930
How much is that.|
请问那个多少钱。|

1104
00:36:18,340 --> 00:36:19,400
0,480

1105
00:36:19,460 --> 00:36:20,210
0,240 240,360 360,420 420,630 630,750
Another way of saying it's
换句话说，它基本上是2268千字节，正确。

1106
00:36:20,210 --> 00:36:21,950
0,510 510,720 720,870 870,1260 1260,1740
basically two {268 -} kilobytes,

1107
00:36:21,950 --> 00:36:22,920
0,390
correct.|
|

1108
00:36:24,470 --> 00:36:25,400
0,180 180,270 270,330 330,600 600,930
What can you store {268
您能存储268千字节的内容是什么？

1109
00:36:25,400 --> 00:36:27,380
0,660 690,1380
-} kilobytes.|
|

1110
00:36:30,510 --> 00:36:31,590
0,210 210,330 330,600 600,960 960,1080
Can you store video in
你能在里面存储视频或者一首歌吗。

1111
00:36:31,590 --> 00:36:32,480
0,240
it

1112
00:36:35,330 --> 00:36:36,660
0,240 240,780
{or,a} song.|
|

1113
00:36:39,050 --> 00:36:40,340
0,240 240,390 390,480 480,900 900,1290
If it's a short song,
如果是一首短歌，是的。

1114
00:36:40,340 --> 00:36:43,460
0,360 1830,2310 2310,2520 2520,2760 2760,3120
yes.| Very short song, correct.|
|很短的歌，对。|

1115
00:36:44,060 --> 00:36:45,740
0,210 210,330 330,660 660,1320 1320,1680
{} So these are really
所以这些文件非常小，

1116
00:36:45,740 --> 00:36:47,510
0,330 330,600 600,900 1260,1530 1530,1770
small file size,| real file
|真实的文件系统和大得多的文件大小，

1117
00:36:47,510 --> 00:36:49,190
0,510 510,660 720,1020 1020,1380 1380,1680
systems and much much bigger

1118
00:36:49,190 --> 00:36:50,870
0,240 240,660 930,1170 1170,1320 1320,1680
file size,| so what would
|那么，您将如何处理文件系统表示

1119
00:36:50,870 --> 00:36:52,160
0,90 90,510 510,750 750,990 990,1290
you do to file system

1120
00:36:52,160 --> 00:36:53,840
0,690 690,780 780,960 960,1440 1530,1680
representation| to make this to
|这样做可以让文件变得更多，文件变得更大。

1121
00:36:53,840 --> 00:36:54,950
0,270 270,360 360,720 720,840 840,1110
allow the files to be

1122
00:36:54,950 --> 00:36:55,790
0,240 240,390 390,660 660,720 720,840
much more files to be

1123
00:36:55,790 --> 00:36:56,760
0,180 180,570
much bigger.|
|

1124
00:37:01,560 --> 00:37:03,750
0,240 240,780 780,1380 1380,1530 1530,2190
Could you extend the indirect
你能延长间接的部分吗？

1125
00:37:03,750 --> 00:37:06,600
0,780 1650,2130 2130,2340 2340,2490 2490,2850
portions.| Yeah like for example
|是的，比如说，你可以再来一杯挡路，坐在下面，对吗，

1126
00:37:06,600 --> 00:37:07,620
0,120 120,210 210,450 450,720 720,1020
you could have another block,

1127
00:37:07,620 --> 00:37:08,940
0,270 270,450 450,750 750,1140 1140,1320
seating here below, correct,| which
|这可能是间接的翻倍，

1128
00:37:08,940 --> 00:37:10,760
0,90 90,450 450,870 870,1290
is maybe doubling indirect,|
|

1129
00:37:14,170 --> 00:37:15,400
0,390 390,570 570,660 660,870 870,1230
almost like you know the
就像你知道我们以前看到的那种页表类型的数据结构一样，对吧，

1130
00:37:15,400 --> 00:37:16,420
0,300 300,390 390,480 480,720 720,1020
sort of the page table

1131
00:37:16,420 --> 00:37:17,500
0,270 270,480 480,840 840,990 990,1080
type data structures that we've

1132
00:37:17,500 --> 00:37:18,780
0,180 180,750
seen before,

1133
00:37:19,070 --> 00:37:20,390
0,300 300,480 480,690 690,960 960,1320
right,| then, that double indirect
|那么双间接挡路指向二百五十六个间接挡路号码，

1134
00:37:20,390 --> 00:37:21,590
0,480 480,780 780,930 930,1080 1080,1200
block points to two and

1135
00:37:21,590 --> 00:37:23,240
0,450 450,870 870,1110 1110,1380 1380,1650
fifty-six indirect block numbers,| each
|每一个都指向另一个挡路号码

1136
00:37:23,240 --> 00:37:24,920
0,270 270,540 540,990 1020,1380 1380,1680
which point to another block

1137
00:37:24,920 --> 00:37:26,330
0,300 690,810 810,930 930,1320 1320,1410
number| and so certainly the
|因此，文件大小肯定会最大化，这要大得多。

1138
00:37:26,330 --> 00:37:27,380
0,240 240,510 510,660 660,780 780,1050
file size is going to

1139
00:37:27,410 --> 00:37:28,760
0,540 540,690 690,810 810,1020 1020,1350
maximize this is much bigger.|
|

1140
00:37:29,440 --> 00:37:30,640
0,210 210,630 630,810 810,1020 1020,1200
And basically just turned out
基本上只是对这些数据结构的一种练习，

1141
00:37:30,640 --> 00:37:31,540
0,60 60,240 240,450 450,660 690,900
to be just a sort

1142
00:37:31,540 --> 00:37:33,280
0,60 60,660 660,990 990,1560 1560,1740
of exercise in on those

1143
00:37:33,280 --> 00:37:34,240
0,240 240,600 600,690 690,840 840,960
data structures,| you could pick
|你可以选择这样的结构，比如一棵树，

1144
00:37:34,240 --> 00:37:36,040
0,690 870,1260 1260,1410 1410,1650 1650,1800
a structure like this, like

1145
00:37:36,040 --> 00:37:37,180
0,30 30,570 570,750 750,900 900,1140
a tree,| but there's also
|但也有可能实现为B-Tree或其他复杂的东西。

1146
00:37:37,180 --> 00:37:38,680
0,450 450,570 570,840 840,1110 1110,1500
possible to like maybe implemented

1147
00:37:38,680 --> 00:37:39,910
0,90 90,150 150,360 360,810 810,1230
as {} {B-Tree -} or

1148
00:37:39,940 --> 00:37:41,680
0,330 330,510 510,1170
something other sophisticated.|
|

1149
00:37:41,800 --> 00:37:44,980
0,750 750,990 990,1440 1440,2040 2220,3180
Xv6 something extremely simple {},|
Xv6非常简单的东西，|

1150
00:37:44,980 --> 00:37:47,380
0,120 150,1290 1290,1410 1410,1980 1980,2400
in basically it's modeled after
基本上它是仿照最初的第六版Unix Unix。

1151
00:37:47,380 --> 00:37:48,970
0,150 150,600 600,900 900,1110 1110,1590
the original version six Unix

1152
00:37:49,150 --> 00:37:51,060
0,600
Unix.|
|

1153
00:37:51,120 --> 00:37:52,590
0,870 900,1020 1020,1110 1110,1230 1230,1470
{} But you can make
但你可以让他们制定更复杂的计划，

1154
00:37:52,590 --> 00:37:54,060
0,150 150,300 300,810 810,1290 1320,1470
them more sophisticated schemes,| in
|事实上，在文件系统实验室，

1155
00:37:54,060 --> 00:37:55,580
0,270 270,510 510,870
fact in the

1156
00:37:55,740 --> 00:37:57,600
0,360 360,660 660,1050 1110,1440 1440,1860
file system lab,| you implement
|您可以实现双间接挡路编号来支持更大的文件。

1157
00:37:57,600 --> 00:38:00,060
0,300 300,900 930,1680 1680,2040 2040,2460
double indirect block numbers to

1158
00:38:00,060 --> 00:38:02,000
0,510 510,690 690,960 960,1500
support much bigger files.|
|

1159
00:38:04,260 --> 00:38:05,900
0,180 180,510 510,750 750,1080
Any questions about this?|
对此有什么问题吗？|

1160
00:38:10,530 --> 00:38:12,870
0,450 450,660 660,840 840,1170 1290,2340
Sorry, so is it 256
抱歉，是256个街区吗，

1161
00:38:12,870 --> 00:38:15,930
0,750 750,1140 1140,1560 1590,2100 2490,3060
blocks,| because it's a like
|因为它就像一个整体的挡路。

1162
00:38:15,930 --> 00:38:17,250
0,240 240,540 540,660 660,750 750,1320
one block as a whole.|
|

1163
00:38:18,500 --> 00:38:21,140
0,840 840,900 1170,1980 2100,2340 2340,2640
{} {Indirect -}.| What this
间接的。|这是一个间接的挡路号码，所以这不算，

1164
00:38:21,140 --> 00:38:22,580
0,180 180,270 270,690 690,930 930,1440
is an indirect block number,

1165
00:38:22,640 --> 00:38:23,690
0,150 150,270 270,480 480,870 870,1050
so that doesn't count,| so
|间接挡路中有256个数字，加上12个直接的挡路号码，就是268个。

1166
00:38:23,690 --> 00:38:25,700
0,210 330,1230 1230,1530 1530,1680 1680,2010
there's 256 sitting in this

1167
00:38:25,700 --> 00:38:28,190
0,450 450,900 1080,1470 1470,1950 1950,2490
indirect block plus twelve direct

1168
00:38:28,490 --> 00:38:29,840
0,270 270,750 780,1020 1020,1260 1260,1350
block numbers that makes it

1169
00:38:29,960 --> 00:38:31,200
0,750
268.|
|

1170
00:38:32,620 --> 00:38:33,880
0,420 420,600 600,690 690,960 960,1260
Oh, sorry my question was
哦，对不起，我的问题是为什么是256。

1171
00:38:33,910 --> 00:38:37,390
0,390 390,510 510,840 1350,2940 3120,3480
why is it 256.| Oh,
|哦，因为它可能是挡路的第四个字节。

1172
00:38:37,390 --> 00:38:38,950
0,270 270,510 510,1080 1080,1320 1320,1560
because it's a block number

1173
00:38:38,950 --> 00:38:41,180
0,180 180,690 990,1740
four byte probably.|
|

1174
00:38:43,300 --> 00:38:46,000
0,330 360,1050 1050,1350 1350,1830 2250,2700
So 1024 divided by four
所以1024除以4等于256个条目。

1175
00:38:46,000 --> 00:38:47,800
0,270 270,570 570,750 750,1260
is {256 -} entries.|
|

1176
00:38:47,920 --> 00:38:49,280
0,810
Okay,
好的谢谢。

1177
00:38:49,280 --> 00:38:50,660
0,390 390,720 840,1110 1110,1170 1170,1380
thank you.| Which is also
|这也是有点可笑的常规，

1178
00:38:50,660 --> 00:38:51,830
0,60 60,210 210,330 330,780 780,1170
a little bit ridiculous regular,|
|

1179
00:38:51,830 --> 00:38:53,090
0,240 240,510 510,750 750,870 870,1260
if block number is only
如果挡路号只有四个字节，这能有多大？

1180
00:38:53,090 --> 00:38:54,080
0,210 210,480 480,660 660,780 780,990
four bytes, how big can

1181
00:38:54,080 --> 00:38:55,180
0,240 240,510
this be.|
|

1182
00:39:04,610 --> 00:39:05,780
0,630
Anybody?|
有人吗？|

1183
00:39:16,280 --> 00:39:17,120
0,120 120,360 360,480 480,570 570,840
{} Two to the power
2的32次方右转，右转，

1184
00:39:17,120 --> 00:39:19,400
0,480 480,960 1050,1560
32 right, right,|
|

1185
00:39:19,490 --> 00:39:20,360
0,240 240,420 420,510 510,720 720,870
some things are bigger than
有些事情比这更重要，

1186
00:39:20,360 --> 00:39:22,190
0,330 540,900 900,1290 1320,1740 1740,1830
that,| and so typically you
|通常情况下，人们使用比32位更大的尺寸来存储挡路号码。

1187
00:39:22,190 --> 00:39:24,500
0,120 120,360 360,570 570,1230 1590,2310
know people use larger {

1188
00:39:25,230 --> 00:39:27,660
0,510 540,1230 1230,1800 1830,2160 2160,2430
-} sizes for block numbers

1189
00:39:27,660 --> 00:39:29,180
0,240 240,600 600,990
than 32 bits.|
|

1190
00:39:30,820 --> 00:39:31,900
0,600
Okay?|
好吧?|

1191
00:39:32,080 --> 00:39:33,920
0,180 180,540 540,780 780,1290
Any questions, further questions.|
任何问题，进一步的问题。|

1192
00:39:36,430 --> 00:39:37,900
0,210 210,480 480,540 540,1050 1050,1470
{} {For,the} {} max file
最大文件大小，但您能帮我再解释一遍吗，比如。

1193
00:39:37,900 --> 00:39:40,150
0,660 1080,1290 1290,1500 1500,1920 2010,2250
size, but could you could

1194
00:39:40,150 --> 00:39:42,550
0,120 120,960 1050,1680 1680,1860 1860,2400
you help explain that again

1195
00:39:42,580 --> 00:39:43,460
0,300
like.|
|

1196
00:39:43,550 --> 00:39:46,190
0,450 690,1140 1380,1920 1920,2250 2250,2640
Okay, sure.| Could each block
好的，当然可以。|能不能把每个挡路都放进去，可以把每个挡路都放进去，

1197
00:39:46,190 --> 00:39:48,170
0,270 270,810 1020,1230 1230,1560 1560,1980
in the, could each block

1198
00:39:48,170 --> 00:39:49,240
0,510
in,|
|

1199
00:39:49,670 --> 00:39:51,110
0,270 270,720 720,870 870,1050 1050,1440
that's referenced by the indirect
间接挡路提到的这也可能指向更多的街区，

1200
00:39:51,110 --> 00:39:53,340
0,330 330,570 570,990 990,1680
block could that also

1201
00:39:53,600 --> 00:39:55,400
0,360 390,630 630,780 780,990 990,1800
{} {point,to -} more blocks,|
|

1202
00:39:55,610 --> 00:39:56,810
0,300 300,450 450,600 600,810 810,1200
if that makes sense.| In
如果这有道理的话。|在默认的xv6设计中，情况并非如此，

1203
00:39:56,810 --> 00:39:58,730
0,360 360,540 540,900 900,1350 1350,1920
in the default xv6 design,

1204
00:39:58,820 --> 00:39:59,840
0,210 210,450 450,600 600,660 660,1020
{} that's not the case,|
|

1205
00:39:59,840 --> 00:40:01,370
0,450 450,510 510,840 840,1050 1050,1530
basically a twelve block numbers,
基本上是十二个挡路号码，十二个挡路直拨号码

1206
00:40:01,580 --> 00:40:02,990
0,390 390,720 720,960 960,1260 1260,1410
twelve direct block numbers| and
|还有256%的间接挡路号码，仅此而已。

1207
00:40:03,110 --> 00:40:05,420
0,690 690,1110 1110,1410 1410,1860 2100,2310
256 indirect block numbers and

1208
00:40:05,450 --> 00:40:06,600
0,360 360,690
nothing more.|
|

1209
00:40:06,840 --> 00:40:09,540
0,540 540,1200 1650,2070 2100,2340 2340,2700
{} In in the next
在下一个实验中，您将向信息节点添加一个双重间接挡路，

1210
00:40:09,540 --> 00:40:10,650
0,420 420,600 600,720 720,1020 1020,1110
lab, you'll be adding a

1211
00:40:10,650 --> 00:40:12,000
0,270 270,660 660,990 990,1200 1200,1350
double indirect block to the

1212
00:40:12,000 --> 00:40:13,470
0,150 150,540 900,1050 1050,1260 1260,1470
{inode -},| so you'll take
|所以你要取这些[BNL]11中的一个，然后把它变成一个双重间接的。

1213
00:40:13,470 --> 00:40:14,280
0,180 180,270 270,480 480,690 690,810
one of these {[bnl] -

1214
00:40:14,280 --> 00:40:15,600
0,240 240,630 630,840 840,1080 1080,1320
-} 11's and turn that

1215
00:40:15,600 --> 00:40:17,600
0,360 360,600 630,960 960,1530
into a double indirect.|
|

1216
00:40:17,660 --> 00:40:19,310
0,300 300,480 480,750 750,1290 1290,1650
And that double indirect going
而这个双重间接将指向这一点，

1217
00:40:19,310 --> 00:40:20,420
0,90 90,600
to point

1218
00:40:20,540 --> 00:40:21,980
0,660 690,930 930,1080 1080,1260 1260,1440
to this,| we have to
|我们必须有256%的间接挡路号码，

1219
00:40:21,980 --> 00:40:23,960
0,210 330,1320
have 256

1220
00:40:24,260 --> 00:40:26,120
0,510 510,750 750,1290
indirect block numbers,|
|

1221
00:40:26,880 --> 00:40:28,560
0,240 240,660 660,900 900,1200 1200,1680
which itself then point to
然后，它本身指向块。

1222
00:40:29,190 --> 00:40:30,580
0,900
blocks.|
|

1223
00:40:31,060 --> 00:40:32,320
0,300 300,600 600,840 840,960 960,1260
Now, {the,way} file can be
现在，文件基本上可以放在那里。

1224
00:40:32,350 --> 00:40:34,060
0,750 750,1170
substantially there.|
|

1225
00:40:36,040 --> 00:40:38,820
0,420 420,810 810,1440
Oh okay, thanks.|
哦，好的，谢谢。|

1226
00:40:39,300 --> 00:40:41,610
0,540 930,1200 1200,1650 1650,1860 1860,2310
Okay, so now let's say
好的，现在让我们假设我们要实现read系统调用。

1227
00:40:41,610 --> 00:40:42,480
0,240 240,390 390,450 450,780 780,870
we want to implement the

1228
00:40:42,480 --> 00:40:43,940
0,180 180,450 450,900
read system call.|
|

1229
00:40:44,000 --> 00:40:45,950
0,960 1050,1170 1170,1410 1410,1560 1560,1950
And, {} you know basically
而且，您知道，基本上我们从操作系统引导开始

1230
00:40:45,950 --> 00:40:48,530
0,180 180,480 480,720 720,1830 2250,2580
we start from a operating

1231
00:40:48,530 --> 00:40:50,570
0,240 240,720 930,1260 1260,1590 1590,2040
system boots| wants to read
|要读比方说字节，读8000。

1232
00:40:50,870 --> 00:40:53,000
0,780 780,1050 1050,1650
{} say byte,

1233
00:40:54,040 --> 00:40:55,640
0,1020
read

1234
00:40:55,850 --> 00:40:57,960
0,540 540,1500
{} by

1235
00:40:58,510 --> 00:41:00,320
0,540 540,1170
{} 8000.|
|

1236
00:41:04,320 --> 00:41:06,000
0,210 210,390 390,570 570,1140 1500,1680
Yeah, how would you know,
是啊，你怎么知道，你会读哪种挡路，

1237
00:41:06,000 --> 00:41:07,050
0,180 180,450 450,570 570,690 690,1050
which block would you read,|
|

1238
00:41:09,380 --> 00:41:11,690
0,330 330,840 840,990 990,1710 1740,2310
which block will contain basically
到8000年，挡路基本上会包含这些内容。

1239
00:41:11,690 --> 00:41:13,420
0,300 300,1140
by 8000.|
|

1240
00:41:17,340 --> 00:41:18,420
0,240 240,360 360,450 450,930 930,1080
How would you compute or
你将如何计算或如何查找，

1241
00:41:18,420 --> 00:41:19,380
0,210 210,330 330,480 480,660 660,960
how you would look up,|
|

1242
00:41:19,410 --> 00:41:21,690
0,450 450,600 600,840 840,1440 1890,2280
giving this data structure, this
给这个数据结构，这个非常简单的数据结构，

1243
00:41:21,690 --> 00:41:24,030
0,480 480,750 750,990 990,1710 1710,2340
extremely simple data structure,| how
|你怎么计算实际的挡路数，或者找出包含8000000的挡路数。

1244
00:41:24,030 --> 00:41:24,960
0,120 120,210 210,570 570,660 660,930
would you compute the actually

1245
00:41:24,960 --> 00:41:26,340
0,120 120,390 390,870 930,1140 1140,1380
the block number or find

1246
00:41:26,340 --> 00:41:27,600
0,90 90,360 360,600 600,750 750,1260
the block number that contains

1247
00:41:27,600 --> 00:41:29,380
0,540 540,1260
by 8000.|
|

1248
00:41:36,070 --> 00:41:37,580
0,930
Anybody?|
有人吗？|

1249
00:41:38,670 --> 00:41:40,480
0,180 180,360 360,750
Do you just
你是不是只是减去，比如，首先减去前十二个直接块的字节数。

1250
00:41:40,510 --> 00:41:42,490
0,780 810,1140 1140,1380 1380,1470 1470,1980
subtract, like, first of all

1251
00:41:42,610 --> 00:41:44,260
0,570 570,930 960,1260 1260,1380 1380,1650
subtract the number of bytes

1252
00:41:44,260 --> 00:41:45,490
0,60 60,150 150,420 420,810 810,1230
in the first twelve direct

1253
00:41:45,490 --> 00:41:47,400
0,630 810,1380
blocks.| Hmm.|
|嗯。|

1254
00:41:47,430 --> 00:41:49,110
0,180 180,600 600,1200 1200,1590 1590,1680
And then see what the
然后看看间接块中的偏移量是多少。

1255
00:41:49,110 --> 00:41:50,940
0,480 480,720 720,870 870,1050 1050,1830
offset is in the indirect

1256
00:41:50,940 --> 00:41:52,080
0,660
blocks.|

1257
00:41:52,080 --> 00:41:53,130
0,240 240,480 480,660 660,900 900,1050
Yeah, so okay, so in
是的，所以好的，如果是8000除以1024，

1258
00:41:53,130 --> 00:41:54,480
0,240 240,300 300,1020 1020,1230 1230,1350
case of {8000,just} what we

1259
00:41:54,480 --> 00:41:55,650
0,150 150,330 330,660 660,1080 1080,1170
will do correctly divided by

1260
00:41:55,650 --> 00:41:56,940
0,30 30,390 390,630 630,990 990,1290
{1024 - - -},| because
|因为那是挡路的尺码。

1261
00:41:56,940 --> 00:41:58,460
0,150 150,240 240,510 510,960
that's the block size.|
|

1262
00:42:00,000 --> 00:42:02,790
0,300 300,540 540,1080 1260,2190 2220,2790
And that is {} seven,
一共是七个，对吧。

1263
00:42:02,820 --> 00:42:03,800
0,420
right.|
|

1264
00:42:05,250 --> 00:42:06,660
0,390 390,630 630,810 810,1110 1110,1410
And so that means that
这意味着基本上第七个挡路实际上在这个直接的挡路号码中有第二个条目，

1265
00:42:06,660 --> 00:42:09,480
0,600 600,930 930,1440 1440,2130 2460,2820
basically the seventh block actually

1266
00:42:09,480 --> 00:42:11,490
0,720 870,1050 1050,1380 1380,1800 1800,2010
has the second entry in

1267
00:42:11,490 --> 00:42:13,380
0,300 300,630 630,870 870,1380 1650,1890
this direct block number,| has
|有没有8000000个你知道的挡路号码是正确的。

1268
00:42:13,380 --> 00:42:15,030
0,120 120,420 420,780 780,900 900,1650
the block number that contains

1269
00:42:15,030 --> 00:42:17,200
0,90 90,330 330,630 630,1680
you know by {8000,correct}.|
|

1270
00:42:17,750 --> 00:42:20,240
0,330 330,810 810,1410 1770,2100 2100,2490
So [bn] seven whatever number
所以不管是什么数字，都是挡路的数字，

1271
00:42:20,240 --> 00:42:21,800
0,120 120,600 600,810 810,1230 1260,1560
is there is the block

1272
00:42:21,800 --> 00:42:23,930
0,300 300,480 480,1230 1440,1710 1710,2130
number,| that contains this particular
|它包含这个特定的文件文件，

1273
00:42:23,930 --> 00:42:26,300
0,600 930,1860
file file,|
|

1274
00:42:26,540 --> 00:42:28,910
0,420 420,1710 1710,1920 1920,2220 2220,2370
by {8000,to} actually find out
到8000时才能真正找出那个字节在挡路中的确切位置，

1275
00:42:28,910 --> 00:42:31,640
0,480 480,900 900,1200 1620,2220 2220,2730
exactly where that byte is

1276
00:42:31,670 --> 00:42:32,990
0,600 600,660 660,840 840,1230 1230,1320
inside of that block,| you
|你知道，基本上到1024年，我们要计算8000个交货量，

1277
00:42:32,990 --> 00:42:33,890
0,120 120,540 540,660 660,810 810,900
know basically we have to

1278
00:42:33,890 --> 00:42:35,700
0,420 420,1260
compute 8000

1279
00:42:35,700 --> 00:42:37,000
0,270 270,840
delivery by

1280
00:42:37,260 --> 00:42:38,820
0,120 120,270 270,960
{1024 - -},|
|

1281
00:42:40,690 --> 00:42:42,580
0,690 870,1050 1050,1470 1470,1800 1800,1890
which {} is probably I
我想大概是832。

1282
00:42:42,580 --> 00:42:44,440
0,150 150,270 420,1260
think it's 832.|
|

1283
00:42:46,460 --> 00:42:48,410
0,540 930,1050 1050,1350 1350,1440 1440,1950
Okay, so basically to read
好的，所以基本上要在8000之前阅读，

1284
00:42:48,590 --> 00:42:50,120
0,420 420,630 630,1290 1290,1380 1380,1530
by {8000 -},| you know
|您知道，文件系统会查看索引节点，

1285
00:42:50,120 --> 00:42:51,560
0,120 120,360 360,900 900,1350 1350,1440
the file system looks at

1286
00:42:51,560 --> 00:42:53,900
0,150 150,300 300,810 1530,1800 1800,2340
the {inode -},| takes the
|取字节数除法1024，

1287
00:42:53,930 --> 00:42:56,660
0,300 300,510 510,810 810,1980 2040,2730
byte number divide 1024,| indexes
|进入指数查看是否跌破12，然后直接作为挡路数字

1288
00:42:56,660 --> 00:42:58,000
0,840
into

1289
00:42:58,000 --> 00:42:59,680
0,750 780,1170 1170,1290 1290,1380 1380,1680
see see if it falls

1290
00:42:59,680 --> 00:43:00,760
0,270 270,690 690,840 840,960 960,1080
below twelve then as a

1291
00:43:00,760 --> 00:43:02,860
0,300 300,540 540,1080 1440,1770 1770,2100
direct block number| {} and
|只需从inode获取直接的挡路号码

1292
00:43:02,860 --> 00:43:04,600
0,300 480,1050 1050,1170 1170,1380 1380,1740
just picks up the direct

1293
00:43:04,600 --> 00:43:05,890
0,210 210,510 510,780 780,1140 1140,1290
block number from the {inode

1294
00:43:05,890 --> 00:43:08,080
0,480 690,990 990,1290 1290,1830 2010,2190
-}| read that block and
|读挡路，然后捞出你知道8000byte通过计算8000x除以模块1024and

1295
00:43:08,080 --> 00:43:09,400
0,270 270,660 660,1050 1050,1170 1170,1320
then fishes out you know

1296
00:43:09,400 --> 00:43:12,220
0,960 960,1320 1350,1860 1860,2700 2700,2820
{8000,byte} by computing {8000,divided} by

1297
00:43:12,220 --> 00:43:13,690
0,270 300,660 660,990 990,1200 1200,1470
found by module {1024,and -

1298
00:43:13,690 --> 00:43:15,100
0,180 180,990 990,1110 1110,1230 1230,1410
- -}| so it will
|所以它会给我们832的偏移量

1299
00:43:15,100 --> 00:43:16,000
0,180 180,330 330,450 450,780 780,900
give us an offset of

1300
00:43:16,000 --> 00:43:17,110
0,180 180,420 420,780 780,870 870,1110
{832 - -}| and that's
|这就是8000号文件的位置。

1301
00:43:17,110 --> 00:43:20,710
0,390 660,1410 1410,1980 2250,2970 2970,3600
the {location,for,by -} 8000 that

1302
00:43:20,710 --> 00:43:21,560
0,540
file.|
|

1303
00:43:22,760 --> 00:43:23,940
0,720
Okay?|
好吧?|

1304
00:43:24,690 --> 00:43:25,770
0,150 150,540 540,720 720,810 810,1080
So basically, this is enough
所以基本上，这是足够的信息来得出结论，

1305
00:43:25,770 --> 00:43:27,570
0,750 1110,1200 1200,1500 1500,1620 1620,1800
information to conclude from,| this
|这就好像现在这里有足够的信息来实际实现读、写系统调用，

1306
00:43:27,570 --> 00:43:28,800
0,150 150,330 330,510 510,750 750,1230
is like there's enough information

1307
00:43:28,800 --> 00:43:31,590
0,330 330,720 720,900 900,1530 2160,2790
here now to actually implement

1308
00:43:31,620 --> 00:43:32,970
0,420 420,690 690,960 960,1260 1260,1350
read, write system calls,| at
|至少为了找出哪些磁盘块需要读取或写入，

1309
00:43:32,970 --> 00:43:33,900
0,150 150,240 240,540 540,630 630,930
least to find out which

1310
00:43:33,900 --> 00:43:35,610
0,300 300,810 1080,1470 1470,1530 1530,1710
disk blocks need to be

1311
00:43:35,610 --> 00:43:40,470
0,360 360,810 960,2040 2220,2670 3930,4860
read or written, { -},|
|

1312
00:43:41,100 --> 00:43:42,780
0,240 240,660 660,930 930,1350 1350,1680
in response to {} {read,or}
响应于读或写系统调用。

1313
00:43:42,780 --> 00:43:44,060
0,180 180,420 420,720
write system call.|
|

1314
00:43:46,630 --> 00:43:47,660
0,540
Okay.|
好吧。|

1315
00:43:51,520 --> 00:43:52,120
0,210 210,330 330,420 420,570 570,600
So let me talk a
那么，让我简单地谈一下目录。

1316
00:43:52,120 --> 00:43:53,900
0,180 180,300 300,480 480,1140
little bit about directories.|
|

1317
00:43:56,100 --> 00:43:56,970
0,210 210,300 300,360 360,600 600,870
One of the cool things
您知道，关于文件系统，最酷的事情之一就是

1318
00:43:56,970 --> 00:43:58,200
0,270 270,450 450,540 540,810 810,1230
about you know file systems|
|

1319
00:43:58,200 --> 00:43:59,910
0,180 180,450 450,630 630,780 810,1710
where you have a hierarchical
其中您有一个分层的名称空间

1320
00:44:00,180 --> 00:44:02,580
0,810 810,1290 1290,1980 1980,2310 2310,2400
name space| {} and you
|您可以在文件系统的内部，内部存储用户友好的符号名称。

1321
00:44:02,580 --> 00:44:05,190
0,90 90,600 600,1170 1200,1830 1830,2610
can store store a symbolic

1322
00:44:05,370 --> 00:44:07,080
0,360 360,750 750,1170 1170,1590 1590,1710
user friendly names inside of

1323
00:44:07,080 --> 00:44:07,900
0,300
{

1324
00:44:08,020 --> 00:44:10,360
0,300 300,750 750,840 840,1530 2070,2340
-} inside of the, inside

1325
00:44:10,360 --> 00:44:11,660
0,90 90,150 150,360 360,750
of the file system.|
|

1326
00:44:11,720 --> 00:44:14,210
0,930 1110,1230 1230,1530 1530,1980 1980,2490
And the interesting aspect actually,|
有趣的是，实际上，|

1327
00:44:14,210 --> 00:44:15,710
0,360 360,630 630,690 690,780 780,1500
{} one of the cool
大多数Unix文件系统的一个很酷的设计功能实际上是这样做的，

1328
00:44:15,740 --> 00:44:18,140
0,450 450,840 840,1590 1860,2160 2160,2400
design features with {most,Unix} file

1329
00:44:18,140 --> 00:44:20,380
0,360 360,720 720,930 930,1710
systems actually does,| directory
|目录基本上就是文件，

1330
00:44:20,380 --> 00:44:22,380
0,210 210,840 840,930 930,1440
is basically the file,|
|

1331
00:44:22,380 --> 00:44:23,490
0,390 390,480 480,870 870,990 990,1110
except the file with some
除了文件系统能够理解的具有某种结构的文件。

1332
00:44:23,490 --> 00:44:24,620
0,630
structure,

1333
00:44:28,440 --> 00:44:30,180
0,300 300,510 510,750 750,1020 1020,1740
that the file system understands.|
|

1334
00:44:30,830 --> 00:44:32,300
0,270 270,540 540,780 780,1050 1050,1470
In fact, in {xv6 -}
事实上，在xv6中，您知道结构非常简单，

1335
00:44:32,300 --> 00:44:33,530
0,120 120,240 240,480 480,870 870,1230
you know the structure is

1336
00:44:33,860 --> 00:44:37,400
0,840 840,1440 2370,3000
extremely simple,| every,
|每隔一次，目录由目录项组成。

1337
00:44:37,910 --> 00:44:39,320
0,210 210,540 540,900 900,990 990,1410
the directory consists of directory

1338
00:44:39,320 --> 00:44:40,420
0,600
entries.|
|

1339
00:44:40,690 --> 00:44:42,680
0,330 330,630 630,1260
And every entry
并且每个条目都有固定的格式，

1340
00:44:42,850 --> 00:44:46,180
0,420 420,1080 1200,1830 1830,2430 2640,3330
has {a,fixed} {} format,| namely
|即它在前两个字节中包含索引节点号，

1341
00:44:46,180 --> 00:44:47,590
0,120 120,450 450,630 630,810 810,1410
it contains an inode number

1342
00:44:48,690 --> 00:44:50,880
0,450 450,870 900,1410 1440,1620 1620,2190
in the first two bytes,|
|

1343
00:44:51,860 --> 00:44:54,650
0,570 570,810 810,1380 1380,1860 1890,2790
and it contains a filename
并且它在剩余的14个字节中包含一个文件名

1344
00:44:56,530 --> 00:44:58,720
0,330 330,450 450,1200 1290,1740 1740,2190
in the remaining fourteen bytes|
|

1345
00:44:58,720 --> 00:44:59,620
0,180 180,300 300,390 390,690 690,900
and so the total thing
所以总共是16个字节。

1346
00:44:59,620 --> 00:45:01,040
0,90 90,450 450,900
is sixteen bytes.|
|

1347
00:45:01,860 --> 00:45:03,080
0,690

1348
00:45:03,280 --> 00:45:04,420
0,570
And,
而且，这些信息基本上已经足够了，

1349
00:45:05,170 --> 00:45:07,240
0,300 300,420 420,630 630,1410 1500,2070
this is enough information basically

1350
00:45:07,240 --> 00:45:09,550
0,900 930,1620 1650,1800 1800,2010 2130,2310
for,| {} you know we
|您知道，我们实际上实现了路径名查找。

1351
00:45:09,550 --> 00:45:11,020
0,270 270,600 600,840 840,1020 1020,1470
actually implement path name lookup.|
|

1352
00:45:18,070 --> 00:45:19,060
0,180 180,270 270,600 600,810 810,990
So, for example just to
所以，举个例子，我只是想说清楚，

1353
00:45:19,060 --> 00:45:20,080
0,180 180,300 300,660 660,840 840,1020
make it clear,| let's say
|假设我们想要查找路径名y/x，

1354
00:45:20,080 --> 00:45:21,130
0,150 150,330 330,450 450,810 810,1050
we want to look up

1355
00:45:21,130 --> 00:45:23,220
0,630 660,1020 1020,1560
the path name

1356
00:45:23,250 --> 00:45:26,280
0,480 480,1320 1410,1920 1920,2520
{} {y/x - -},|
|

1357
00:45:26,470 --> 00:45:27,430
0,240 240,420 420,570 570,720 720,960
{} how we go about
我们该怎么做呢？

1358
00:45:27,430 --> 00:45:28,520
0,210 210,540
doing that.|
|

1359
00:45:29,750 --> 00:45:30,770
0,180 180,270 270,840 840,930 930,1020
So {well -}, you know
所以，你知道这个路径名解释，表示

1360
00:45:30,770 --> 00:45:33,320
0,240 240,480 480,630 630,1650 2010,2550
this path name explain, {}

1361
00:45:33,320 --> 00:45:34,430
0,480 480,750 750,870 870,1020 1020,1110
indicates| that we have to
|我们必须从根inode开始。

1362
00:45:34,430 --> 00:45:35,840
0,390 390,510 510,600 600,1020 1020,1410
start at the root inode.|
|

1363
00:45:39,990 --> 00:45:40,680
0,210 210,270 270,480 480,600 600,690
And it turns out that
结果发现，[通过]家伙基本上有一个固定的inode编号

1364
00:45:40,680 --> 00:45:42,060
0,210 210,390 390,570 570,930 930,1380
[through] guy then basically has

1365
00:45:42,060 --> 00:45:43,230
0,120 120,600 600,870 870,930 930,1170
a fixed {} a fixed

1366
00:45:43,230 --> 00:45:44,880
0,90 90,270 270,720 750,1200 1200,1650
{inode -} number| inode number
|信息节点编号具有[预先商定的]固定编号

1367
00:45:44,880 --> 00:45:46,200
0,210 210,300 300,510 510,1020 1050,1320
has a [pre agreed] fixed

1368
00:45:46,200 --> 00:45:47,550
0,570 570,960 960,1080 1080,1170 1170,1350
a number| and in fact
|事实上，在xv6中，这个数字是1。

1369
00:45:47,550 --> 00:45:48,780
0,150 150,480 480,690 690,900 900,1230
in {xv6 -} that number

1370
00:45:48,780 --> 00:45:49,780
0,90 90,480
is one.|
|

1371
00:45:50,520 --> 00:45:51,600
0,150 150,270 270,450 450,570 570,1080
So how can we find
那么我们如何找到根inode编号呢？

1372
00:45:51,630 --> 00:45:52,980
0,240 240,510 510,600 600,810 810,1350
the root {inode -} number.|
|

1373
00:45:56,930 --> 00:45:57,860
0,210 210,450 450,570 570,810 810,930
Now we go back to
现在我们回到之前的照片，

1374
00:45:57,860 --> 00:45:59,750
0,270 270,630 630,1050 1050,1500 1590,1890
our earlier picture right,| yeah
|是的，它是第一名，

1375
00:45:59,750 --> 00:46:01,040
0,270 270,510 510,930 960,1080 1080,1290
it's number one,| you know
|你知道，我们知道信息节点从挡路32开始，

1376
00:46:01,040 --> 00:46:02,150
0,120 120,510 510,840 900,990 990,1110
we know that you know

1377
00:46:02,150 --> 00:46:03,260
0,150 150,330 330,720 720,810 810,1110
{inode -} start at block

1378
00:46:03,260 --> 00:46:04,580
0,570 570,750 750,870 870,1110 1110,1320
32,| so it must be
|所以一定是三点三十分的挡路32

1379
00:46:04,580 --> 00:46:06,110
0,300 300,570 570,1170 1170,1350 1350,1530
thirty block 32| and so
|所以它是16乘以64乘128乘以任何值，

1380
00:46:06,110 --> 00:46:07,670
0,150 150,360 480,840 840,1380 1380,1560
it's the by 16 to

1381
00:46:07,670 --> 00:46:10,010
0,810 1080,1380 1380,2040 2040,2160 2160,2340
whatever by 64 to {128

1382
00:46:10,010 --> 00:46:11,140
0,300 300,660
- -},|
|

1383
00:46:11,140 --> 00:46:12,610
0,180 180,480 480,780 780,1290 1320,1470
in that first block that
在包含根索引节点号第一个挡路中

1384
00:46:12,610 --> 00:46:14,120
0,540 540,930
contains the

1385
00:46:14,120 --> 00:46:15,620
0,660 660,1080 1080,1200 1200,1350 1350,1500
{root,inode} number| and so the
|因此，文件系统只能读取根索引节点号。

1386
00:46:15,620 --> 00:46:16,940
0,420 420,570 570,720 720,1170 1200,1320
{file,system} can just read the

1387
00:46:16,940 --> 00:46:18,260
0,330 330,510 510,870
root inode number.|
|

1388
00:46:18,760 --> 00:46:19,920
0,630
Okay?|
好吧?|

1389
00:46:21,060 --> 00:46:23,190
0,180 180,720 1110,1530 1530,1740 1740,2130
And then basically {the,way} {path,name}
然后基本上按照路径名查找和工作的方式，它只获取块。

1390
00:46:23,190 --> 00:46:24,720
0,450 450,570 570,900 900,1260 1260,1530
lookups and works, it just

1391
00:46:24,720 --> 00:46:26,880
0,630 900,1020 1020,1740
gets the blocks.|
|

1392
00:46:30,890 --> 00:46:32,930
0,960 990,1110 1110,1260 1260,1380 1380,2040
Therefore, you know the name
因此，你知道y这个名字，

1393
00:46:34,660 --> 00:46:35,780
0,540
y,|
|

1394
00:46:37,040 --> 00:46:38,000
0,240 240,390 390,540 540,750 750,960
{} so the file system,
所以文件系统，主要通过到达inode文件inode一的块，

1395
00:46:38,000 --> 00:46:39,680
0,360 360,480 480,1020 1020,1260 1260,1680
basically go through reach the

1396
00:46:39,710 --> 00:46:42,710
0,630 660,870 870,1950 2340,2460 2460,3000
blocks of the {inode -}

1397
00:46:43,160 --> 00:46:45,320
0,690 720,990 990,1050 1050,1710 1920,2160
file {inode -} one {},|
|

1398
00:46:45,320 --> 00:46:46,730
0,390 390,540 540,990 990,1200 1200,1410
one by one and just
一个接一个地，向前看这些块的日期a，看字符串y是否合适。

1399
00:46:46,730 --> 00:46:47,900
0,330 330,570 570,840 840,930 930,1170
looks going forward the date

1400
00:46:47,900 --> 00:46:49,670
0,120 120,330 330,840 1110,1320 1320,1770
of those blocks a whether

1401
00:46:49,670 --> 00:46:51,680
0,240 240,660 660,1050 1050,1590
the string y appeers.|
|

1402
00:46:51,900 --> 00:46:53,130
0,180 180,480 480,660 660,780 780,1230
And how can it find
它如何找到索引节点1的所有块，

1403
00:46:53,160 --> 00:46:54,240
0,240 240,330 330,720 720,840 840,1080
all the blocks of the

1404
00:46:54,240 --> 00:46:55,410
0,120 120,240 240,600 600,900 900,1170
{inode -} one,| well, just
|那么你看，第一个挡路到了零，

1405
00:46:55,410 --> 00:46:57,060
0,240 240,360 360,750 840,1230 1230,1650
look at the, reach the

1406
00:46:57,090 --> 00:46:58,950
0,510 510,930 930,1050 1050,1350 1350,1860
[bn] zero the first block,|
|

1407
00:46:59,370 --> 00:47:00,870
0,120 120,210 210,510 510,840 840,1500
you know sees if {}
你知道，如果x在其中，

1408
00:47:00,870 --> 00:47:02,190
0,420 420,510 510,930 930,1020 1020,1320
x in that,| you know
|你知道如果不是，会读第二个挡路等等，

1409
00:47:02,190 --> 00:47:03,300
0,240 240,570 570,840 840,1020 1020,1110
{if,it's} not, will read the

1410
00:47:03,300 --> 00:47:05,580
0,300 300,720 720,1050 1050,1650 1680,2280
second block, etc etc,| until
|希望在某一时刻，它要么找到它，要么找不到它。

1411
00:47:05,580 --> 00:47:06,960
0,390 390,480 480,630 630,960 960,1380
hopefully at some point either

1412
00:47:06,960 --> 00:47:08,100
0,120 120,420 420,630 630,900 900,1140
it finds it, {or,doesn't} find

1413
00:47:08,100 --> 00:47:08,720
0,210
it.|
|

1414
00:47:10,140 --> 00:47:11,490
0,450 450,570 570,660 660,1020 1020,1350
And if it finds it,
如果它找到了，我们就去找文件x，

1415
00:47:11,490 --> 00:47:13,110
0,120 120,390 390,810 810,1140 1140,1620
{} let's find file x,|
|

1416
00:47:13,950 --> 00:47:15,870
0,450 480,690 690,1440 1470,1800 1800,1920
in the directory was going
在目录中会有这样的inode编号，比如251。

1417
00:47:15,870 --> 00:47:17,010
0,60 60,240 240,420 420,750 750,1140
to have so inode number

1418
00:47:17,010 --> 00:47:18,980
0,240 390,1380
say 251.|
|

1419
00:47:19,010 --> 00:47:19,700
0,150 150,270 270,360 360,480 480,690
And then we can just
然后我们就可以从那里开始了，对吧，

1420
00:47:19,700 --> 00:47:20,930
0,330 330,450 450,810 840,1140 1140,1230
proceed from there, right,| we
|我们可以说这就像，好吧，好吧，

1421
00:47:20,930 --> 00:47:21,950
0,210 210,360 360,480 480,630 630,1020
can say it's like, well

1422
00:47:21,980 --> 00:47:23,270
0,330 330,480 480,780 780,1200 1200,1290
okay, well,| now read you
|现在读到你知道的挡路号码，你知道读到索引节点251，

1423
00:47:23,270 --> 00:47:25,460
0,120 120,420 420,960 1350,1560 1560,2190
know block number, {you,know} read

1424
00:47:27,110 --> 00:47:28,580
0,270 270,930
{inode -}

1425
00:47:29,110 --> 00:47:30,840
0,210 210,510 510,1140
{251 - -},|
|

1426
00:47:31,150 --> 00:47:33,400
0,360 360,870 870,1080 1080,1770
and scan its blocks
扫描它的区块看有没有。

1427
00:47:36,520 --> 00:47:37,820
0,660
for.|
|

1428
00:47:38,130 --> 00:47:39,200
0,570

1429
00:47:39,230 --> 00:47:40,160
0,240 240,510 510,690 690,840 840,930
Okay I just did my
好吧，我只是做错了我的例子，

1430
00:47:40,160 --> 00:47:41,900
0,420 420,780 780,930 930,1080 1080,1740
example wrong,| this was y,
|这是y，它会变成x的挡路。

1431
00:47:42,880 --> 00:47:43,930
0,300 300,420 420,540 540,720 720,1050
and it's going to block

1432
00:47:43,930 --> 00:47:45,200
0,240 240,750
for x.|

1433
00:47:47,080 --> 00:47:47,890
0,330 330,450 450,600 600,720 720,810
And [] was going to
然后[]会找到我们，你知道，所以信息节点号又一次出现了，

1434
00:47:47,890 --> 00:47:48,670
0,210 210,420 420,510 510,600 600,780
find us, you know, so

1435
00:47:48,670 --> 00:47:50,140
0,150 150,540 540,960 960,1140 1140,1470
inode number again,| we'll return
|我们将把它作为路径名查找的结果返回。

1436
00:47:50,140 --> 00:47:51,100
0,300 300,480 480,570 570,900 900,960
that as a result of

1437
00:47:51,100 --> 00:47:52,520
0,90 90,360 360,540 540,930
the path name lookup.|
|

1438
00:47:55,540 --> 00:47:57,220
0,210 210,570 570,780 780,1110
Any questions about this?|
对此有什么问题吗？|

1439
00:48:05,900 --> 00:48:06,740
0,120 120,240 240,450 450,660 660,840
Would you say you.| So,
你觉得你。|所以，这个。

1440
00:48:06,740 --> 00:48:09,980
0,570 600,2160 2670,2910 2910,3090 3090,3240
this.| Yeah, so this is
|是的，这是磁盘中目录的布局，

1441
00:48:09,980 --> 00:48:12,290
0,330 360,930 930,1170 1170,1320 1320,2310
the layout of the directory

1442
00:48:12,290 --> 00:48:14,270
0,540 570,780 780,1380 1620,1890 1890,1980
in the disk,| but is
|但是，元数据块中的某个位置是否有一些位

1443
00:48:14,270 --> 00:48:16,130
0,210 210,540 540,840 840,1500 1560,1860
there some bits somewhere {}

1444
00:48:16,130 --> 00:48:17,570
0,90 90,180 180,660 660,1230 1230,1440
in the metadata blocks| that
|它指示当前对象是目录还是文件。

1445
00:48:17,570 --> 00:48:19,430
0,600 600,1110 1110,1200 1200,1530 1530,1860
indicates whether the current thing

1446
00:48:19,430 --> 00:48:20,360
0,180 180,270 270,720 720,840 840,930
is a directory or a

1447
00:48:20,360 --> 00:48:22,520
0,450 900,1410 1410,1590 1590,1950 1950,2160
file.| Yeah it's actually {in,inode
|是的，它实际上在inode中，

1448
00:48:22,520 --> 00:48:23,990
0,450 720,960 960,1080 1080,1380 1380,1470
-},| so the type of
|因此，信息节点的类型说明了什么是目录或文件，

1449
00:48:23,990 --> 00:48:25,120
0,150 150,270 270,750
the {inode -}

1450
00:48:25,330 --> 00:48:26,530
0,360 360,660 660,690 690,1110 1110,1200
says what's a directory or

1451
00:48:26,530 --> 00:48:27,490
0,390 390,540 540,660 660,750 750,960
file,| so if you do
|因此，如果您确实查找了恰好是文件的AND索引节点，

1452
00:48:27,490 --> 00:48:30,310
0,210 210,420 420,1110 1530,2400 2400,2820
look up on a and

1453
00:48:30,310 --> 00:48:31,300
0,150 150,330 330,480 480,690 690,990
{inode -} that actually happens

1454
00:48:31,300 --> 00:48:32,410
0,60 60,240 240,660 660,870 870,1110
to be {a,file},| then actually
|那么实际上文件系统将返回一个错误。

1455
00:48:32,410 --> 00:48:33,370
0,90 90,300 300,570 570,690 690,960
the file system will return

1456
00:48:33,370 --> 00:48:34,340
0,90 90,450
an error.|
|

1457
00:48:37,260 --> 00:48:39,700
0,270 270,750 1080,1590
I see, thanks.|
我明白了，谢谢。|

1458
00:48:40,890 --> 00:48:42,000
0,660
Okay?|
好吧?|

1459
00:48:44,830 --> 00:48:46,080
0,690

1460
00:48:46,080 --> 00:48:48,630
0,960 1260,1650 1650,1860 1860,2460 2460,2550
Now, clearly this structure is
现在，很明显这种结构并不是特别高效，

1461
00:48:48,630 --> 00:48:51,090
0,270 300,900 900,1260 1260,1860 1950,2460
not a particular efficient {},|
|

1462
00:48:51,090 --> 00:48:51,960
0,90 90,210 210,360 360,570 570,870
you know to actually find
你知道，要真正找到目录名，你必须扫描，

1463
00:48:51,960 --> 00:48:54,090
0,720 750,1320 1320,1890 1890,2010 2010,2130
a directory name, you have

1464
00:48:54,090 --> 00:48:56,250
0,120 120,660 780,1530 1530,1860 1860,2160
to scan,| {} and so
|因此，一个真正的文件系统，您可能会使用更复杂的数据结构，

1465
00:48:56,250 --> 00:48:57,630
0,210 210,420 420,690 690,1170 1170,1380
a real file system, you

1466
00:48:57,630 --> 00:49:00,210
0,720 720,1260 1440,1770 1770,1980 1980,2580
probably would use more sophisticated

1467
00:49:00,210 --> 00:49:01,780
0,510 510,1140
data structures,|
|

1468
00:49:01,780 --> 00:49:03,970
0,210 210,1020 1020,1290 1290,1800 1800,2190
to actually {} make this
实际进行这种查找要比xv6快得多。

1469
00:49:03,970 --> 00:49:05,830
0,300 300,450 450,990 990,1560 1560,1860
lookups much faster than {xv6

1470
00:49:05,830 --> 00:49:07,000
0,240 240,690
-} does.|
|

1471
00:49:08,970 --> 00:49:10,050
0,270 270,510 510,810 810,930 930,1080
{} But, again it's sort
但是，再说一次，这几乎是一个更具设计性的数据结构问题，

1472
00:49:10,050 --> 00:49:11,010
0,90 90,570 570,660 660,810 810,960
of almost you know a

1473
00:49:11,010 --> 00:49:12,570
0,330 330,930 930,1230 1230,1320 1320,1560
more designer question of data

1474
00:49:12,570 --> 00:49:13,740
0,420 420,690 690,780 780,840 840,1170
structures,| then is a question
|然后是操作系统设计的问题。

1475
00:49:13,740 --> 00:49:15,460
0,90 90,420 420,750 750,1200
of operating system design.|
|

1476
00:49:17,230 --> 00:49:18,160
0,270 270,360 360,510 510,690 690,930
And so you could plug
因此您可以插入您最喜欢的数据结构

1477
00:49:18,160 --> 00:49:20,980
0,90 90,360 360,1050 1170,2310 2310,2820
in your favorite data structure|
|

1478
00:49:20,980 --> 00:49:22,000
0,270 270,450 450,570 570,780 780,1020
and turn it into an
并将其转换为THIS数据结构，

1479
00:49:22,000 --> 00:49:23,410
0,180 180,450 450,930 930,1140 1140,1410
this data structure,| and then
|然后希望你能获得更好的表现。

1480
00:49:23,410 --> 00:49:24,160
0,330 330,420 420,540 540,600 600,750
hopefully you're going to get

1481
00:49:24,160 --> 00:49:25,420
0,180 180,810
better performance.|
|

1482
00:49:26,450 --> 00:49:28,250
0,330 330,450 450,1170 1170,1500 1530,1800
But for simplicity and ease
但是为了简单和容易解释，

1483
00:49:28,250 --> 00:49:30,620
0,810 840,1380 1380,1980 1980,2130 2130,2370
explanation,| {you,know} actually is very
|你知道实际上是非常简单的结构。

1484
00:49:30,620 --> 00:49:31,860
0,240 240,660
simple structure.|
|

1485
00:49:37,530 --> 00:49:38,580
0,600
Okay?|
好吧?|

1486
00:49:40,080 --> 00:49:41,010
0,180 180,270 270,420 420,660 660,930
Okay, so what I wanna
好的，接下来我要做的是对此有更具体的感受

1487
00:49:41,010 --> 00:49:42,090
0,90 90,390 390,570 570,720 720,1080
do next is going to

1488
00:49:42,360 --> 00:49:43,140
0,180 180,210 210,360 360,480 480,780
get a little bit more

1489
00:49:43,140 --> 00:49:44,340
0,420 420,720 720,810 810,1080 1080,1200
concrete feel for this| and
|我只想看看在xv6中实际是如何工作的。

1490
00:49:44,340 --> 00:49:45,480
0,180 180,270 270,600 600,930 930,1140
just to see actually how

1491
00:49:45,480 --> 00:49:46,770
0,240 240,450 450,630 630,720 720,1290
things work out in practice

1492
00:49:46,980 --> 00:49:48,690
0,450 450,630 630,930 930,1380 1410,1710
{} in {xv6 -}| and
|这会很有帮助的，你知道，这对下一个实验是有帮助的。

1493
00:49:48,690 --> 00:49:50,070
0,240 240,390 390,510 510,1140 1200,1380
this will be helpful, you

1494
00:49:50,070 --> 00:49:52,290
0,180 180,390 390,720 750,1350 1380,2220
know for the next lab.|
|

1495
00:49:52,910 --> 00:49:54,800
0,690 930,1260 1260,1410 1410,1650 1650,1890
I'm going to look at
我要看一下xv6，

1496
00:49:55,130 --> 00:49:56,960
0,330 330,510 510,630 630,1110 1170,1830
{xv6 -} for {a,second},| {}
|通常的屏幕。

1497
00:49:56,960 --> 00:49:58,620
0,1140
usual

1498
00:49:59,090 --> 00:50:00,540
0,960
screen.|
|

1499
00:50:00,540 --> 00:50:01,640
0,570

1500
00:50:02,520 --> 00:50:03,980
0,420 420,930
{} So,
所以，我要重新启动xv6的第一件事，

1501
00:50:04,010 --> 00:50:04,910
0,150 150,330 330,600 600,720 720,900
the first thing I'm gonna

1502
00:50:04,910 --> 00:50:06,080
0,270 270,510 510,690 690,1080 1080,1170
boot {xv6 -} again,| it's
|它总是而且我确实做到了干净，

1503
00:50:06,080 --> 00:50:08,570
0,690 810,1410 1800,2220 2220,2310 2310,2490
always {} and I did

1504
00:50:08,570 --> 00:50:10,670
0,150 150,840 1080,1650 1650,1980 1980,2100
make clean,| {} and as
|你们可能还记得，或者你们中的许多人都遇到过这样的情况，

1505
00:50:10,670 --> 00:50:12,560
0,120 120,600 600,1320 1320,1530 1530,1890
you probably remember or many

1506
00:50:12,560 --> 00:50:13,340
0,90 90,240 240,390 390,570 570,780
of you have run into

1507
00:50:13,340 --> 00:50:14,180
0,360 360,450 450,540 540,690 690,840
this,| you know you want
|您知道您实际上需要新的文件系统，您必须运行Make Clean，

1508
00:50:14,180 --> 00:50:15,830
0,240 240,420 420,720 720,1200 1410,1650
actually new file system, you

1509
00:50:15,830 --> 00:50:16,820
0,90 90,210 210,420 420,600 600,990
have to run make clean,|
|

1510
00:50:16,820 --> 00:50:18,620
0,360 360,900 930,1110 1110,1350 1350,1800
because then a make qemu
因为这样一来，make QEMU将为您构建一个新的干净文件系统。

1511
00:50:18,620 --> 00:50:19,610
0,150 150,450 450,660 660,750 750,990
will build you a new

1512
00:50:19,610 --> 00:50:20,960
0,300 300,570 570,930
clean file system.|
|

1513
00:50:21,540 --> 00:50:23,310
0,690 780,960 960,1140 1140,1230 1230,1770
{} So here we go.|
所以我们开始吧。|

1514
00:50:25,640 --> 00:50:27,320
0,420 420,600 600,810 810,1380 1380,1680
And we'll see that {xv6
我们将看到xv6已经启动，

1515
00:50:27,320 --> 00:50:30,410
0,480 480,1080 1440,2070 2070,2640 2670,3090
-} {} has started,| but
|但是我首先要指出的是这里，

1516
00:50:30,410 --> 00:50:30,920
0,60 60,210 210,270 270,420 420,510
the thing I want to

1517
00:50:30,920 --> 00:50:33,200
0,210 210,390 390,840 840,1530 1770,2280
point out first is {}

1518
00:50:33,200 --> 00:50:35,480
0,1050 1080,1590 1590,1800 1800,2070 2070,2280
here,| here you'll see there's
|在这里，您将看到有一个调用，基本上是创建一个文件系统，

1519
00:50:35,480 --> 00:50:38,450
0,30 30,750 1170,1950 1950,2460 2460,2970
a call to {} basically

1520
00:50:38,450 --> 00:50:39,500
0,210 210,270 270,540 540,900 900,1050
make a file system,| so
|所以这会产生一个新的磁盘映像，

1521
00:50:39,500 --> 00:50:42,290
0,180 180,480 480,1560 1560,2220 2250,2790
this makes a fresh disk

1522
00:50:42,290 --> 00:50:44,180
0,570 690,1350 1350,1530 1530,1620 1620,1890
image,| {} in a disk
|在磁盘映像中包含我们在命令行中指定的一组文件

1523
00:50:44,180 --> 00:50:45,860
0,330 330,1170 1170,1260 1260,1590 1590,1680
image contains you know a

1524
00:50:45,860 --> 00:50:46,880
0,270 270,330 330,750 750,870 870,1020
bunch of files, that we

1525
00:50:46,880 --> 00:50:48,320
0,480 480,600 600,660 660,990 990,1440
specify on the command line|
|

1526
00:50:49,100 --> 00:50:50,180
0,270 270,450 450,540 540,780 780,1080
and make it fast basically
并使其快速基本建成QEMU文件系统

1527
00:50:50,180 --> 00:50:51,620
0,270 270,420 420,780 780,1080 1080,1440
built {QEMU -} file system|
|

1528
00:50:51,620 --> 00:50:53,240
0,150 150,690 690,1050 1050,1530 1530,1620
that contains those files as
它包含作为文件系统内容的那些文件。

1529
00:50:53,240 --> 00:50:54,170
0,90 90,510 510,600 600,690 690,930
the contents of the file

1530
00:50:54,170 --> 00:50:54,780
0,330
system.|
|

1531
00:50:55,510 --> 00:50:56,500
0,420 420,540 540,630 630,870 870,990
And you can see you
您可以看到xv6，它提供了一些关于文件系统的信息，

1532
00:50:56,500 --> 00:50:57,700
0,210 210,480 480,750 750,1020 1020,1200
know the {xv6 -} which

1533
00:50:57,700 --> 00:50:59,320
0,270 270,600 630,1050 1050,1530 1530,1620
brings out a bit of

1534
00:50:59,320 --> 00:51:01,000
0,570 570,840 840,900 900,1140 1140,1680
information about the file system,|
|

1535
00:51:01,210 --> 00:51:02,320
0,270 270,390 390,720 720,960 960,1110
so it basically says there
所以它基本上说有46个百万街区，

1536
00:51:02,320 --> 00:51:03,850
0,120 120,660 660,900 900,1440 1440,1530
are 46 mega blocks,| you
|你知道的，包括靴式挡路，超级挡路，

1537
00:51:03,850 --> 00:51:04,690
0,90 90,240 240,570 570,630 630,840
know that includes the boot

1538
00:51:04,690 --> 00:51:06,130
0,330 330,390 390,690 690,1350 1350,1440
block, the super block,| the
|30个日志块、39个索引节点块

1539
00:51:06,130 --> 00:51:08,530
0,210 210,1050 1080,1710 1710,1890 1890,2400
{30,log} blocks, 39 inode blocks,|
|

1540
00:51:08,620 --> 00:51:10,540
0,360 360,540 540,750 750,1260 1650,1920
one {bitmap -} block and
一个位图挡路，然后是954个数据块，

1541
00:51:10,540 --> 00:51:12,310
0,180 180,510 510,570 810,990 990,1770
then followed by {954 -}

1542
00:51:12,340 --> 00:51:13,900
0,450 450,930 960,1110 1110,1470 1470,1560
data blocks,| so it's a
|所以这是一个总共只有1000个数据块的很小的文件系统。

1543
00:51:13,900 --> 00:51:15,370
0,420 420,690 690,1020 1020,1140 1140,1470
tiny file system in total

1544
00:51:15,370 --> 00:51:16,840
0,90 90,330 330,630 630,1140
of only thousand blocks.|
|

1545
00:51:17,020 --> 00:51:17,590
0,120 120,270 270,330 330,390 390,570
And one of the things
你们要在实验室里做的一件事是支持更大的文件，

1546
00:51:17,590 --> 00:51:19,270
0,120 120,210 210,360 360,870 1320,1680
you will do in {},

1547
00:51:19,420 --> 00:51:20,860
0,480 690,840 840,960 960,1230 1230,1440
the lab to support bigger

1548
00:51:20,860 --> 00:51:21,910
0,330 330,450 450,660 660,840 840,1050
files,| you also will have
|您还必须使用更大的文件系统。

1549
00:51:21,910 --> 00:51:23,830
0,90 90,330 330,360 360,600 600,1920
to use a much bigger

1550
00:51:23,860 --> 00:51:24,960
0,270 270,600
file system.|
|

1551
00:51:25,830 --> 00:51:27,020
0,660

1552
00:51:27,050 --> 00:51:29,980
0,420 420,540 540,1410 1500,2370
Then I modified {}
然后，我略微修改了xv6，基本上编写或打印了一些东西。

1553
00:51:29,980 --> 00:51:32,050
0,300 300,540 540,1020 1020,1290 1290,2070
{xv6 -} slightly to basically

1554
00:51:32,110 --> 00:51:34,030
0,690 690,840 840,1110 1110,1500 1500,1920
write or print something| whenever
|每当我们给特定的挡路写信的时候。

1555
00:51:34,030 --> 00:51:35,080
0,210 210,450 450,570 570,600 600,1050
we write to a particular

1556
00:51:35,080 --> 00:51:36,200
0,600
block.|
|

1557
00:51:36,290 --> 00:51:37,520
0,630 630,930 930,1050 1050,1200 1200,1230
So {for,example}, we see a
例如，我们看到几个文件系统调用，

1558
00:51:37,520 --> 00:51:38,990
0,450 450,690 690,960 960,1350 1350,1470
couple file system call,| we
|我们在xv6启动时执行了一系列文件系统调用

1559
00:51:38,990 --> 00:51:40,700
0,570 810,1110 1110,1320 1320,1500 1500,1710
had {xv6 -} {when,it} starts

1560
00:51:40,700 --> 00:51:41,870
0,210 210,390 390,450 450,660 660,1170
up does a bunch of

1561
00:51:41,870 --> 00:51:43,580
0,210 210,420 420,900 1080,1290 1290,1710
file system calls| and apparently
|显然还写了挡路[3343 348或32]。

1562
00:51:43,580 --> 00:51:45,380
0,510 540,990 990,1200 1200,1560 1560,1800
wrote block [thirty three forty

1563
00:51:45,380 --> 00:51:46,640
0,300 300,630 630,720 720,810 810,1260
three forty eight or 32].|
|

1564
00:51:47,430 --> 00:51:49,920
0,810 870,1470 1620,1890 1890,2070 2070,2490
{} And we're gonna run
我们要运行的基本上是指挥部

1565
00:51:49,920 --> 00:51:51,420
0,510 510,1050 1050,1170 1170,1260 1260,1500
basically command| and we're just
|我们只需查看该命令写入了哪些挡路号码或该命令的原因

1566
00:51:51,420 --> 00:51:53,880
0,150 150,750 750,1380 1380,1860 1860,2460
gonna see what block numbers

1567
00:51:53,940 --> 00:51:56,700
0,840 840,1110 1110,1650 1950,2430 2460,2760
are being written {} by

1568
00:51:56,700 --> 00:51:59,730
0,150 150,750 1080,1500 1500,1500 2640,3030
that command {} or cause

1569
00:51:59,730 --> 00:52:00,600
0,210 210,540 540,660 660,780 780,870
{of,that} command| and we've been
|我们一直在试图理解这些写作在哪里有意义，

1570
00:52:00,600 --> 00:52:02,490
0,210 210,270 270,990 1050,1380 1380,1890
trying to understand where do

1571
00:52:02,520 --> 00:52:03,510
0,210 210,300 300,510 510,780 780,990
where do those writes make

1572
00:52:03,510 --> 00:52:05,730
0,450 450,720 720,960 990,1500 1500,2220
sense,| when we expect to
|当我们期望看到它们是否真的存在的时候，看看发生了什么

1573
00:52:05,760 --> 00:52:06,630
0,240 240,330 330,420 420,570 570,870
see if they were actually,

1574
00:52:06,630 --> 00:52:07,580
0,390
{}

1575
00:52:08,730 --> 00:52:10,020
0,150 150,540 540,840 840,960 960,1290
to see what is happening|
|

1576
00:52:10,020 --> 00:52:11,220
0,120 120,300 300,390 390,690 690,1200
is what we actually expect.|
才是我们真正期待的。|

1577
00:52:12,110 --> 00:52:12,980
0,210 210,420 420,480 480,810 810,870
{} So I'm going to
所以我要创建一个文件，Echo嗨。

1578
00:52:12,980 --> 00:52:15,110
0,240 240,300 300,930 1320,1980 1980,2130
create a file, { -}

1579
00:52:15,110 --> 00:52:16,640
0,210 210,930
echo hi.|
|

1580
00:52:17,480 --> 00:52:18,290
0,330 330,450 450,570 570,780 780,810
Yeah, I'm gonna create a
是的，我要创建一个文件x。

1581
00:52:18,290 --> 00:52:19,520
0,300 300,720
file x.|
|

1582
00:52:21,310 --> 00:52:23,320
0,630 660,900 900,990 990,1500
And let me actually
让我把它复印一下，这样我就可以描绘这个了，

1583
00:52:26,200 --> 00:52:27,760
0,450 450,630 630,900 900,1170 1170,1560
copy that {a,little} bit over,

1584
00:52:27,760 --> 00:52:28,900
0,150 150,240 240,540
so I can

1585
00:52:31,820 --> 00:52:33,680
0,1050 1050,1440 1470,1680 1680,1800 1800,1860
delineate this,| I'm going to
|我将在几个地方描绘，只是为了帮助理解，

1586
00:52:33,680 --> 00:52:35,030
0,540 540,750 750,810 810,1020 1020,1350
delineate in a couple places

1587
00:52:35,030 --> 00:52:37,490
0,210 210,510 510,870 870,1530 1560,2460
just for help for understanding,|
|

1588
00:52:37,790 --> 00:52:39,540
0,1110

1589
00:52:39,850 --> 00:52:42,220
0,810 810,1170 1170,1860
probably [right] here,|
可能[右]在这里，|

1590
00:52:42,560 --> 00:52:43,960
0,810

1591
00:52:44,990 --> 00:52:47,000
0,450 450,870 870,1440
then probably here.|
那可能就在这里。|

1592
00:52:48,680 --> 00:52:49,820
0,750
Okay.|
好吧。|

1593
00:52:50,240 --> 00:52:51,320
0,270 270,420 420,810 810,870 870,1080
{} It's basically it turns
基本上这里会有几个阶段，

1594
00:52:51,320 --> 00:52:53,000
0,120 120,360 360,510 510,960 1200,1680
out there's gonna be a

1595
00:52:53,000 --> 00:52:54,710
0,270 270,990 990,1260 1260,1560 1560,1710
couple phases here,| one is
|一个是实际创建文件的阶段。

1596
00:52:54,710 --> 00:52:55,970
0,60 60,390 390,510 510,750 750,1260
the phase to actually create

1597
00:52:55,970 --> 00:52:57,200
0,90 90,660
the file.|
|

1598
00:52:57,700 --> 00:52:59,020
0,660

1599
00:52:59,970 --> 00:53:02,940
0,690 720,1470 1650,2040 2040,2730 2850,2970
Then, {} there's write the
然后是写文件，即[Write]hi file，然后再写一次。

1600
00:53:02,940 --> 00:53:05,300
0,480 480,900 900,1200 1200,1740
file namely [write] hi

1601
00:53:06,330 --> 00:53:08,640
0,600 630,750 750,1410 1470,1980 1980,2310
file and then one more

1602
00:53:08,640 --> 00:53:09,720
0,540
write.|
|

1603
00:53:10,260 --> 00:53:11,940
0,570 570,870 870,960 960,1170 1170,1680
Alright, actually the new line,
好的，实际上是新行，放到文件中。

1604
00:53:14,860 --> 00:53:16,180
0,90 90,300 300,390 390,810
{} into the file.|
|

1605
00:53:18,540 --> 00:53:19,380
0,150 150,270 270,450 450,540 540,840
So you look at the
因此，您可以查看ECHO程序，这基本上就是它所做的。

1606
00:53:19,380 --> 00:53:21,360
0,780 810,1410 1410,1560 1560,1680 1680,1980
echo program that is basically

1607
00:53:21,360 --> 00:53:23,360
0,150 150,240 240,690
what it does.|
|

1608
00:53:23,560 --> 00:53:24,740
0,180 180,240 240,690
Pick it up.|
把它捡起来。|

1609
00:53:28,460 --> 00:53:30,440
0,120 120,450 450,570 570,1260
[Just {do,it}] for completeness,|
[只管去做]为了完整性，|

1610
00:53:30,590 --> 00:53:32,320
0,240 240,360 360,1230
write to echo,|
写信给Echo，|

1611
00:53:34,020 --> 00:53:35,730
0,210 210,270 270,360 360,1140 1140,1710
look at his arguments, {writes
看他的参数，将参数写入文件描述符1

1612
00:53:35,730 --> 00:53:38,850
0,30 30,30 1020,1770 2190,2910 2940,3120
-} {} arguments to file

1613
00:53:38,850 --> 00:53:39,900
0,60 60,300 300,810 810,900 900,1050
{descriptor -} one| and then
|然后在()新行的末尾。

1614
00:53:39,900 --> 00:53:40,440
0,90 90,210 210,390 390,450 450,540
at the end of the

1615
00:53:40,440 --> 00:53:42,020
0,540
[]

1616
00:53:42,450 --> 00:53:43,620
0,270 270,600
new line.|
|

1617
00:53:43,620 --> 00:53:44,800
0,690
Okay?|
好吧?|

1618
00:53:44,890 --> 00:53:46,360
0,360 360,480 480,690 690,1080 1080,1470
{} So, these are basically
因此，这些基本上就是每个操作中涉及的磁盘写入序列。

1619
00:53:46,360 --> 00:53:48,250
0,150 150,960 990,1260 1260,1500 1500,1890
the sequences of disk writes

1620
00:53:48,250 --> 00:53:49,780
0,120 120,600 600,690 690,870 870,1530
get involved in each operation.|
|

1621
00:53:50,640 --> 00:53:52,530
0,600 900,1410 1410,1590 1590,1830 1830,1890
And let's go look at
让我们去一个接一个地看一看

1622
00:53:52,530 --> 00:53:53,430
0,150 150,390 390,510 510,780 780,900
them one by one| and
|开始了解发生了什么事。

1623
00:53:53,430 --> 00:53:54,570
0,270 270,330 330,720 720,870 870,1140
start to understand what's going

1624
00:53:54,570 --> 00:53:55,460
0,300
on.|
|

1625
00:53:55,460 --> 00:53:57,500
0,630 630,750 750,990 1140,1590 1590,2040
I'm going to basically maybe
我要做的基本上可能是最简单的事情

1626
00:53:57,500 --> 00:53:59,240
0,450 480,930 930,1110 1110,1260 1260,1740
the easiest thing to do|
|

1627
00:53:59,240 --> 00:54:00,740
0,420 420,750 750,990 1020,1320 1320,1500
actually used to, move this
实际上过去是，把这个搬过去。

1628
00:54:00,740 --> 00:54:01,560
0,540
over.|
|

1629
00:54:04,420 --> 00:54:06,060
0,1140

1630
00:54:07,880 --> 00:54:09,300
0,330 330,840
Okay so,
好的，所以很容易理解发生了什么，

1631
00:54:09,530 --> 00:54:12,800
0,840 1080,1290 1290,2040 2100,2640 2820,3270
{} it's convenient to understand

1632
00:54:12,800 --> 00:54:13,790
0,120 120,330 330,690 690,930 930,990
what's going on,| instead of
|我们不看代码，而是只看这个磁盘布局

1633
00:54:13,790 --> 00:54:14,630
0,270 270,330 330,390 390,750 750,840
looking at the code, we're

1634
00:54:14,630 --> 00:54:15,380
0,210 210,300 300,480 480,630 630,750
going to just look at

1635
00:54:15,380 --> 00:54:18,080
0,390 510,1020 1020,1680 1740,2400 2430,2700
this disk layout| and trying
|并试图弄清楚在这些特殊的行动中可能会发生什么。

1636
00:54:18,080 --> 00:54:19,670
0,60 60,390 390,750 1020,1230 1230,1590
to figure out a what

1637
00:54:19,670 --> 00:54:20,960
0,270 270,420 420,750 750,1170 1170,1290
might be going on in

1638
00:54:20,960 --> 00:54:22,780
0,150 150,600 600,1380
these particular operations.|
|

1639
00:54:25,950 --> 00:54:27,020
0,630

1640
00:54:39,280 --> 00:54:40,520
0,360 360,630
Okay good.|
好的很好。|

1641
00:54:40,520 --> 00:54:41,780
0,720

1642
00:54:42,310 --> 00:54:43,870
0,210 210,360 360,420 420,540 540,1560
So what do we think,
那么我们怎么看，这篇文章是。

1643
00:54:44,110 --> 00:54:46,800
0,870 1290,1560 1560,2160
{} this {write,is}.|
|

1644
00:54:53,210 --> 00:54:54,410
0,360 360,660 660,810 810,930 930,1200
Any idea what this might
知道这到底是什么吗。

1645
00:54:54,410 --> 00:54:55,680
0,330 330,660
actually be.|
|

1646
00:54:56,230 --> 00:54:57,340
0,240 240,600 600,690 690,1020 1020,1110
We're creating a file, so
我们正在创建一个文件，那么我们期望文件系统做什么。

1647
00:54:57,340 --> 00:54:58,690
0,120 120,180 180,270 270,1140 1140,1350
what do we expect file

1648
00:54:58,690 --> 00:55:00,080
0,270 270,360 360,780
system to do.|
|

1649
00:55:00,340 --> 00:55:01,870
0,420 420,720 720,900 900,1080 1080,1530
It writes the {inodes -}
它写入inode条目。

1650
00:55:01,870 --> 00:55:03,000
0,570
entry.|
|

1651
00:55:03,200 --> 00:55:04,340
0,270 270,420 420,600 600,720 720,1140
Yeah, so first thing I
是啊，所以我第一件事就是我才两岁，

1652
00:55:04,340 --> 00:55:06,140
0,270 270,510 510,990 990,1320 1320,1800
was just two,| {} so
|好了，现在是33，我们对挡路33有什么了解？

1653
00:55:06,230 --> 00:55:07,820
0,240 240,450 450,1050 1050,1290 1290,1590
okay so it's {33 -},

1654
00:55:07,820 --> 00:55:08,390
0,150 150,270 270,330 330,450 450,570
so what do we know

1655
00:55:08,390 --> 00:55:09,920
0,210 210,450 450,660 660,990
{about -} block 33.|
|

1656
00:55:10,210 --> 00:55:10,720
0,180 180,240 240,360 360,450 450,510
If we look at the
如果我们看一下磁盘布局图。

1657
00:55:10,720 --> 00:55:12,120
0,210 210,480 480,840
disk layout picture.|
|

1658
00:55:14,130 --> 00:55:16,020
0,240 240,1110 1110,1260 1260,1620 1620,1890
It contains a free {inode
它包含一个空闲信息节点。

1659
00:55:16,020 --> 00:55:17,020
0,480
-}.|
|

1660
00:55:17,020 --> 00:55:18,550
0,510 510,690 690,900 900,1200 1200,1530
Yeah, you know {it,contains} we
是的，你知道它包含我们知道的信息节点1住在32号，对吗，

1661
00:55:18,550 --> 00:55:19,330
0,120 120,270 270,330 330,480 480,780
know that {inode -} one

1662
00:55:19,330 --> 00:55:21,640
0,210 210,270 270,780 780,1230 1560,2310
lives in 32, correct, {},|
|

1663
00:55:21,640 --> 00:55:23,230
0,270 270,630 630,810 810,1230 1230,1590
and so we're whatever {}
所以我们被分配的显然是inode，可能是位于挡路33的inode。

1664
00:55:23,230 --> 00:55:26,470
0,600 600,1530 1830,2820 2820,3030 3030,3240
apparently {} inode that's being

1665
00:55:26,470 --> 00:55:27,640
0,540 540,630 630,960 960,1050 1050,1170
allocated is probably and {inode

1666
00:55:27,640 --> 00:55:28,510
0,150 150,300 300,510 510,600 600,870
-} that lives in block

1667
00:55:28,510 --> 00:55:29,720
0,270 270,720
{33 -}.|
|

1668
00:55:29,870 --> 00:55:31,760
0,480 480,600 600,840 840,1350 1590,1890
Presumably the first write might
假设第一次写入可能只是标记

1669
00:55:31,760 --> 00:55:32,960
0,180 180,300 300,960 960,1080 1080,1200
just be marking| you know
|您知道，此信息节点现在实际上要使用

1670
00:55:32,960 --> 00:55:33,980
0,180 180,330 330,480 480,720 720,1020
that this {inode -} actually

1671
00:55:33,980 --> 00:55:34,520
0,60 60,210 210,360 360,420 420,540
is now going to be

1672
00:55:34,520 --> 00:55:35,630
0,510 570,780 780,900 900,960 960,1110
used| and so I think
|所以我认为xv6的实现方式是使用类型字段，

1673
00:55:35,630 --> 00:55:36,710
0,90 90,330 330,600 600,840 840,1080
the way {xv6 -} does

1674
00:55:36,710 --> 00:55:38,210
0,390 570,780 780,1020 1020,1170 1170,1500
this it uses the type

1675
00:55:38,210 --> 00:55:39,180
0,450
field,|
|

1676
00:55:39,180 --> 00:55:40,320
0,330 330,660 660,780 780,960 960,1140
{} in the {inode -}
在inode中实际指示inode空闲的位置、文件或目录，

1677
00:55:40,320 --> 00:55:41,370
0,120 120,360 360,690 690,960 960,1050
to actually indicate where {inode

1678
00:55:41,370 --> 00:55:43,320
0,300 300,780 810,1290 1290,1470 1470,1950
-} free, file or directory,|
|

1679
00:55:43,350 --> 00:55:44,970
0,150 150,330 330,690 690,1140 1140,1620
so it basically changes from
所以基本上它从免费变成了文件

1680
00:55:45,300 --> 00:55:47,940
0,750 750,1050 1050,1380 1380,1890 1890,2640
{} free to file| and
|并在使用时写入到市场的磁盘。

1681
00:55:48,270 --> 00:55:50,040
0,780 810,1140 1140,1290 1290,1380 1380,1770
{} write to the disk

1682
00:55:50,040 --> 00:55:51,660
0,180 180,630 630,900 900,1110 1110,1620
to market as in use.|
|

1683
00:55:52,960 --> 00:55:54,310
0,420 420,630 630,690 690,780 780,1350
{} What do we think
我们认为第33号的下一次写作是什么。

1684
00:55:54,340 --> 00:55:56,290
0,810 810,1080 1080,1290 1290,1500 1500,1950
next write {33 -} is.|
|

1685
00:56:02,320 --> 00:56:04,180
0,600 600,1290 1290,1410 1410,1680 1680,1860
Actually, populating the {inode -}
实际上，填充inode条目需要信息。

1686
00:56:04,180 --> 00:56:06,240
0,420 420,750 780,1470
entry would like

1687
00:56:06,240 --> 00:56:08,400
0,570 870,1170 1170,1650 1650,1890 1890,2160
info.| Yeah, exactly yeah, indeed
|是的，完全正确，确实填充了一个信息节点信息，

1688
00:56:08,400 --> 00:56:10,200
0,540 540,1080 1080,1200 1200,1620 1680,1800
populating an inode info,| you
|您知道inode可能有诸如将链接计数设置为1之类的条目，对吧。

1689
00:56:10,200 --> 00:56:11,850
0,240 240,390 390,600 600,1320 1320,1650
know {inode -} probably with

1690
00:56:11,850 --> 00:56:13,380
0,450 450,870 900,1200 1200,1320 1320,1530
entries like setting the link

1691
00:56:13,380 --> 00:56:15,960
0,300 300,930 1320,2280 2280,2460 2460,2580
count one and things like

1692
00:56:15,960 --> 00:56:17,080
0,240 270,660
that, right.|
|

1693
00:56:18,210 --> 00:56:19,760
0,960
In,
在，46是什么，我们期望46在32是什么，

1694
00:56:21,230 --> 00:56:22,370
0,210 210,330 330,900 900,1080 1080,1140
what is 46, what do

1695
00:56:22,370 --> 00:56:23,390
0,60 60,360 360,810 810,900 900,1020
we expect 46 to be

1696
00:56:23,390 --> 00:56:24,980
0,180 180,780 810,1050 1050,1290 1290,1590
in 32,| maybe that's there.|
|也许那就在那里。|

1697
00:56:30,300 --> 00:56:33,360
0,360 360,1170 1170,1680 1710,2220 2220,3060
Is 46, the first data,
是46，第一个数据，没有实际的位图位图。

1698
00:56:33,450 --> 00:56:35,160
0,180 180,570 570,1080 1080,1290 1290,1710
{} no actually {bitmap -}

1699
00:56:35,190 --> 00:56:36,520
0,480 480,900
{bitmap -}.|
|

1700
00:56:36,640 --> 00:56:37,840
0,450 450,750 750,930 930,990 990,1200
No, just it's a data
不，这只是一个数据挡路，你说得对，这是第一个数据挡路。

1701
00:56:37,840 --> 00:56:39,160
0,480 510,750 750,900 900,1140 1140,1320
block and you're right it's

1702
00:56:39,160 --> 00:56:40,700
0,120 120,360 360,570 570,1020
the first data block.|
|

1703
00:56:41,260 --> 00:56:42,190
0,150 150,390 390,600 600,840 840,930
So whose data block do
那么你认为这是谁的数据挡路。

1704
00:56:42,190 --> 00:56:43,520
0,60 60,270 270,360 360,750
you think is this.|
|

1705
00:56:45,640 --> 00:56:50,860
0,390 390,840 870,1830 2160,3510 3630,5220
See {} root directory entry.|
请参见根目录条目。|

1706
00:56:51,440 --> 00:56:52,730
0,420 450,690 690,840 840,930 930,1290
Yeah correct, this is this
是的，没错，这大概是用来挡路的，第一锁，根目录，

1707
00:56:52,730 --> 00:56:54,140
0,90 90,510 510,720 720,810 810,1410
is probably used to block,

1708
00:56:54,960 --> 00:56:56,680
0,360 360,960
first lock,

1709
00:56:57,970 --> 00:57:00,600
0,720 750,1140 1140,1350 1350,1890
of the root directory,|
|

1710
00:57:01,040 --> 00:57:03,040
0,480 480,630 630,930 930,1320
{you,know} {inode -} one,
你知道inode 1，对吧。

1711
00:57:03,070 --> 00:57:04,020
0,480
right.|
|

1712
00:57:04,420 --> 00:57:06,100
0,300 300,810 810,1050 1050,1170 1170,1680
And why were we expecting
为什么我们真的要把它写出来，

1713
00:57:06,100 --> 00:57:07,300
0,240 240,810 810,990 990,1050 1050,1200
to actually that to be

1714
00:57:07,300 --> 00:57:08,280
0,420
written,|
|

1715
00:57:09,180 --> 00:57:13,050
0,270 270,420 420,1050 1980,3120 3120,3870
what has.| Because because we're,
什么发生了。|因为因为我们正在创建类似于中的x，所以我们将一个新文件x添加到当前目录中，

1716
00:57:13,940 --> 00:57:16,280
0,810 1080,1290 1290,1710 1710,1890 1890,2340
{} we're creating like x

1717
00:57:16,280 --> 00:57:17,440
0,600
in,

1718
00:57:17,620 --> 00:57:18,940
0,480 480,750 750,840 840,1020 1020,1320
we're adding a new file

1719
00:57:18,940 --> 00:57:20,020
0,210 210,300 300,510 510,750 750,1080
x to the current directory,|
|

1720
00:57:20,020 --> 00:57:20,920
0,150 150,390 390,510 510,750 780,900
so adding it to the
因此，将其添加到文件层次结构中。

1721
00:57:20,920 --> 00:57:23,320
0,300 300,930 1020,1680 1800,2220 2220,2400
file hierarchy.| Yeah, exactly, so
|是的，没错，所以我们有我们已经做过了

1722
00:57:23,320 --> 00:57:24,700
0,600 630,810 810,990 990,1200 1200,1380
we have we've done this|
|

1723
00:57:24,700 --> 00:57:26,920
0,90 90,1590
and {we,just}
我们刚刚在根目录中添加了一个条目，

1724
00:57:26,950 --> 00:57:29,230
0,450 480,600 600,1050 1050,1590 1620,2280
added an entry to the

1725
00:57:29,320 --> 00:57:31,240
0,330 330,780 780,1230 1230,1530 1530,1920
root directory,| namely entry x
|即具有我们分配的任何索引节点的条目x，

1726
00:57:31,240 --> 00:57:32,620
0,330 330,840 840,1020 1020,1200 1200,1380
with whatever {inode -} we

1727
00:57:32,620 --> 00:57:35,140
0,690 780,990 990,1440 1440,1890 1980,2520
allocated,| you know the step,
|你知道那一步，前面两步。

1728
00:57:35,170 --> 00:57:36,560
0,150 150,420 420,870
two steps before.|
|

1729
00:57:37,250 --> 00:57:38,500
0,120 120,240 240,360 360,720
Does that make sense?|
这说得通吗？|

1730
00:57:40,030 --> 00:57:40,690
0,120 120,240 240,300 300,450 450,660
So what do we think
那么我们认为第32号写的是什么呢？

1731
00:57:40,690 --> 00:57:41,500
0,120 120,420 420,540 540,630 630,810
is write {32 - -}

1732
00:57:41,500 --> 00:57:42,380
0,330
is.|
|

1733
00:57:47,190 --> 00:57:48,540
0,150 150,420 420,750 750,1080 1080,1350
To block 32, well, the
到了挡路32，那么现在要做的就是回去看看磁盘布局图。

1734
00:57:48,540 --> 00:57:49,170
0,180 180,240 240,360 360,480 480,630
thing to do is go

1735
00:57:49,170 --> 00:57:49,890
0,300 300,390 390,510 510,600 600,720
back and look at the

1736
00:57:49,890 --> 00:57:51,600
0,240 240,570 570,1110
disk layout picture.|
|

1737
00:57:51,630 --> 00:57:53,010
0,210 210,390 390,510 510,780 780,1380
And one is block 32.|
一个是挡路32。|

1738
00:57:55,490 --> 00:57:56,960
0,270 270,450 450,540 540,810 810,1470
I know the one probably.|
我可能认识那个人。|

1739
00:57:57,790 --> 00:57:59,800
0,480 480,1020 1140,1350 1350,1560 1560,2010
Yeah, well it will include
是的，它将包括信息节点一号，

1740
00:57:59,800 --> 00:58:01,240
0,270 270,690 750,1200 1200,1350 1350,1440
inode one,| includes all the
|包括所有其他正确的索引节点，

1741
00:58:01,240 --> 00:58:02,260
0,300 300,420 420,570 570,690 690,1020
other {inodes -} {} correct,|
|

1742
00:58:02,260 --> 00:58:03,430
0,330 330,600 600,660 660,1050 1050,1170
because nine is smaller than
因为九比挡路小，

1743
00:58:03,430 --> 00:58:04,480
0,60 60,360 360,510 510,750 750,1050
a block,| but it will
|但它将包括inode 1。

1744
00:58:04,480 --> 00:58:06,180
0,420 420,750 750,1170
include inode one.|
|

1745
00:58:06,210 --> 00:58:06,870
0,210 210,300 300,360 360,540 540,660
Why do you think it's
你为什么认为它会被写成

1746
00:58:06,870 --> 00:58:07,950
0,120 120,180 180,300 300,660 810,1080
going to be written| what
|信息节点中可能发生了哪些更改

1747
00:58:07,980 --> 00:58:09,330
0,300 300,480 480,570 570,1260 1260,1350
what might have changed in

1748
00:58:09,330 --> 00:58:10,680
0,120 120,270 270,540 540,690 720,1350
the {inode -}| that requires
|这要求inode实际写入磁盘。

1749
00:58:10,680 --> 00:58:11,730
0,120 120,270 270,480 480,810 810,1050
that the inode actually written

1750
00:58:11,730 --> 00:58:12,700
0,90 90,480
to disk.|
|

1751
00:58:13,390 --> 00:58:16,030
0,840 1020,1440 1440,1710 1710,2100 2130,2640
Size.| Yeah, {the,size} change exactly,|
尺码。|是的，大小完全改变了，|

1752
00:58:16,030 --> 00:58:17,530
0,360 360,690 690,960 960,1230 1230,1500
size change because we grew
大小改变是因为我们将目录正确地增加了16个字节，直接存储条目x。

1753
00:58:17,530 --> 00:58:19,330
0,90 90,600 600,810 810,1350 1380,1800
the directory correct by sixteen

1754
00:58:19,330 --> 00:58:21,370
0,330 330,870 900,1290 1290,1620 1620,2040
bytes directly store entry x.|
|

1755
00:58:24,220 --> 00:58:26,500
0,300 300,480 480,690 690,1350 1410,2280
Then there's one more a
然后还有一个写到34

1756
00:58:26,530 --> 00:58:28,900
0,270 270,390 390,600 600,1230 1500,2370
write to {34 -}| and
|我暂且不提这件事，

1757
00:58:28,900 --> 00:58:30,400
0,630 690,900 900,1080 1080,1230 1230,1500
{} I'll leave that hanging

1758
00:58:30,400 --> 00:58:32,800
0,150 150,210 210,720 780,1530 1920,2400
for a second,| {} basically
|基本上，我们再次更新x的inode，

1759
00:58:32,800 --> 00:58:34,760
0,240 240,810 810,1440
we're updating {}

1760
00:58:34,820 --> 00:58:35,780
0,240 240,450 450,570 570,780 780,960
{inode -} for x one

1761
00:58:35,780 --> 00:58:38,270
0,180 180,690 720,1500 1860,2100 2100,2490
more time,| {} even through
|即使什么都没有，实际上还写了些什么。

1762
00:58:38,300 --> 00:58:39,800
0,270 270,750 750,930 930,1140 1140,1500
nothing actually what's written yet.|
|

1763
00:58:40,190 --> 00:58:41,320
0,600

1764
00:58:41,540 --> 00:58:42,800
0,750
Okay?|
好吧?|

1765
00:58:44,380 --> 00:58:45,490
0,120 120,300 300,390 390,630 630,1110
So that's the first phase,|
所以这是第一阶段，|

1766
00:58:45,520 --> 00:58:46,390
0,150 150,330 330,510 510,720 720,870
so let's now look at
现在我们来看第二个，

1767
00:58:46,390 --> 00:58:49,120
0,810 900,1500 1920,2040 2040,2520 2550,2730
the second,| you know so
|你知道，所以有创造，

1768
00:58:49,120 --> 00:58:50,440
0,270 270,780 780,960 960,1140 1140,1320
there's creation,| now let's look
|现在我们来看一下第二阶段

1769
00:58:50,440 --> 00:58:51,910
0,450 450,570 570,840 840,1320 1320,1470
at the second phase| or
|或者在第一次写入时，将hi写到文件x。

1770
00:58:51,910 --> 00:58:52,960
0,90 90,360 360,810 810,900 900,1050
the first write you know

1771
00:58:52,990 --> 00:58:54,310
0,330 330,360 360,630 630,780 780,1320
write {} hi to file

1772
00:58:54,490 --> 00:58:55,480
0,540
x.|
|

1773
00:58:57,470 --> 00:58:58,580
0,300 300,450 450,510 510,630 630,1110
Well, what do we think
嗯，我们觉得怎么样？

1774
00:58:58,610 --> 00:59:00,780
0,1200
45.|
|

1775
00:59:01,910 --> 00:59:05,120
0,2250 2370,2880 2880,3000 3000,3030 3030,3210
Yeah yeah it's the {bitmap
是的，是的，是位图，

1776
00:59:05,120 --> 00:59:06,260
0,240 240,420 420,690 690,870 870,1140
-},| so remember what happened
|记住这里发生的事情是，文件系统是否扫描位图挡路

1777
00:59:06,260 --> 00:59:07,550
0,60 60,270 270,720 720,930 930,1290
to here is does that

1778
00:59:08,200 --> 00:59:09,910
0,180 180,870 900,1260 1260,1620 1620,1710
file system {} scan the

1779
00:59:09,910 --> 00:59:12,010
0,180 180,390 390,930 1350,1680 1680,2100
{bitmap -} block| to find
|为了找到没有使用过的挡路，

1780
00:59:12,010 --> 00:59:13,030
0,210 210,510 510,630 630,780 780,1020
a block that was not

1781
00:59:13,030 --> 00:59:15,490
0,540 660,780 780,1140 1140,1770 1770,2460
used,| so find it zero
|所以找到0，然后将该位设置为1，你知道的

1782
00:59:15,760 --> 00:59:18,190
0,480 480,1020 1020,1470 1980,2310 2310,2430
and then {} set that

1783
00:59:18,190 --> 00:59:19,360
0,420 420,510 510,600 600,720 720,1170
bit, you know to one|
|

1784
00:59:19,360 --> 00:59:20,680
0,120 120,540 540,660 660,870 870,1320
to indicate that that particular
以表明该特定挡路现在正在使用中。

1785
00:59:20,680 --> 00:59:22,210
0,390 390,600 600,810 810,990 990,1530
block now is in use.|
|

1786
00:59:22,890 --> 00:59:24,030
0,240 240,480 480,630 630,750 750,1140
{} And so it wrote
所以它写道：45 to disk[]更新了大图挡路。

1787
00:59:24,030 --> 00:59:25,830
0,60 60,240 240,870 870,1260 1290,1800
you know 45 to {}

1788
00:59:25,830 --> 00:59:27,450
0,210 210,600 600,1110 1110,1560 1560,1620
to disk [] updated the

1789
00:59:27,450 --> 00:59:28,740
0,180 180,420 420,780
{bigmap -} block.|
|

1790
00:59:30,180 --> 00:59:31,500
0,330 330,600 600,720 720,840 840,1320
What block do you think
你觉得位图分配器选了什么挡路。

1791
00:59:31,530 --> 00:59:33,480
0,420 450,630 630,780 780,1440 1440,1950
the {bitmap -} allocator picked.|
|

1792
00:59:36,690 --> 00:59:39,780
0,1380 1440,2070 2100,2490 2490,2820 2820,3090
[595]?| Yeah, most likely, correct,
[595]？|是的，很有可能，没错，因为紧接着我们就看到你写给595年的信，

1793
00:59:39,780 --> 00:59:41,010
0,330 330,600 600,960 960,1110 1110,1230
because right after it we

1794
00:59:41,010 --> 00:59:41,910
0,120 120,270 270,510 510,630 630,900
see your write to five

1795
00:59:41,910 --> 00:59:43,280
0,240 240,750
ninety five,|

1796
00:59:43,280 --> 00:59:45,590
0,270 270,630 660,1200 1200,1860 1920,2310
{} and presumably the block
并且大概还有分配给文件x的挡路。

1797
00:59:45,590 --> 00:59:46,490
0,90 90,210 210,720 720,810 810,900
that was allocated to the

1798
00:59:46,490 --> 00:59:47,720
0,330 330,750
file x.|
|

1799
00:59:47,720 --> 00:59:48,560
0,120 120,270 270,630 630,720 720,840
And so basically in the
因此基本上在inode中是正确的，

1800
00:59:48,560 --> 00:59:50,240
0,120 120,390 390,720 750,1470 1470,1680
{inode -} correct,| {file,x} now
|现在在[bn]零的文件x将有数字595。

1801
00:59:50,240 --> 00:59:51,740
0,210 210,510 510,1080 1110,1320 1320,1500
in [bn] zero will have

1802
00:59:51,740 --> 00:59:53,510
0,90 90,360 360,570 570,1320 1320,1770
the number five ninety five.|
|

1803
00:59:54,640 --> 00:59:57,310
0,600 900,1680 1680,2010 2010,2430 2430,2670
And, {} and basically what
基本上，第一个字节是什么，

1804
00:59:57,310 --> 00:59:58,660
0,180 180,330 330,480 480,810 810,1350
will be the first byte,|
|

1805
00:59:58,990 --> 00:59:59,770
0,240 240,330 330,630 630,720 720,780
what's the value of the
写完这个之后，挡路595的第一个字节的值是多少。

1806
00:59:59,770 --> 01:00:01,390
0,270 270,720 750,1050 1050,1380 1380,1620
first byte of block five

1807
01:00:01,390 --> 01:00:02,560
0,240 240,660
ninety five,

1808
01:00:03,250 --> 01:00:04,740
0,330 330,480 480,870
After this write.|
|

1809
01:00:05,560 --> 01:00:08,140
0,1230 1260,1650 1650,2070 2340,2460 2460,2580
H.| H, yeah.| {} What
H.|啊，是的。|我们认为第二个写的是什么，这一个。

1810
01:00:08,140 --> 01:00:08,860
0,60 60,150 150,330 330,420 420,720
do we think the second

1811
01:00:08,860 --> 01:00:10,000
0,240 240,570
write is,

1812
01:00:11,650 --> 01:00:12,820
0,210 210,660
this one.|
|

1813
01:00:14,030 --> 01:00:15,200
0,690
i.|
我..。|

1814
01:00:15,200 --> 01:00:17,960
0,330 330,1020 1740,2070 2070,2250 2250,2760
Yes, i right, there's every
是的，我是对的，每一个回声你都知道有一个角色一个角色。

1815
01:00:18,260 --> 01:00:20,180
0,810 840,1380 1380,1530 1530,1620 1620,1920
echoed {} you know there's

1816
01:00:20,180 --> 01:00:21,640
0,60 60,360 360,480 480,930
a character by character.|
|

1817
01:00:21,940 --> 01:00:22,690
0,240 240,390 390,450 450,570 570,750
Okay, what do we think
好的，我们认为这个33号字是什么。

1818
01:00:22,690 --> 01:00:24,160
0,360 390,630 630,840 840,1050 1050,1470
this write {33 -} is.|
|

1819
01:00:28,500 --> 01:00:30,510
0,510 510,600 600,900 900,1230 1680,2010
Updating the size again.| Yeah,
再次更新大小。|是的，同样是inode的大小，

1820
01:00:30,510 --> 01:00:31,380
0,300 300,390 390,690 690,750 750,870
again the size of the

1821
01:00:31,380 --> 01:00:32,670
0,120 120,510 510,810 810,1110 1110,1290
{inode -},| that's because now
|这是因为现在它有两个字节。

1822
01:00:32,670 --> 01:00:33,480
0,120 120,270 270,390 390,690 690,810
it has two bytes in

1823
01:00:33,480 --> 01:00:34,280
0,240
it.|
|

1824
01:00:34,760 --> 01:00:36,100
0,210 210,270 270,420 420,780
Does it make sense?|
这有意义吗？|

1825
01:00:37,740 --> 01:00:39,960
0,330 330,1110 1110,1470 1470,1830 1830,2220
{} Question, five ninety five
问题是，595年看起来在盘中的位置很高，

1826
01:00:39,960 --> 01:00:42,690
0,660 900,1290 1290,2010 2040,2460 2460,2730
seems very high up in

1827
01:00:42,690 --> 01:00:44,790
0,270 300,900 1170,1500 1500,1860 1860,2100
the disk,| that because there's
|那是因为那里目前生活着其他的东西

1828
01:00:44,790 --> 01:00:46,590
0,570 600,960 960,1110 1110,1500 1500,1800
other stuff that's currently living

1829
01:00:46,590 --> 01:00:47,670
0,180 180,420 420,510 510,810 810,1080
there| like the kernel boot
|比如内核引导代码和其他已经启动的东西。

1830
01:00:47,670 --> 01:00:49,080
0,390 390,570 570,1080 1080,1320 1320,1410
code and other things that

1831
01:00:49,080 --> 01:00:50,340
0,120 120,330 330,480 480,870 930,1260
have already been start.| Well,
|嗯，是的，我们可以回到这个屏幕，

1832
01:00:50,340 --> 01:00:51,750
0,180 180,480 480,720 720,1140 1140,1410
yeah we can go back

1833
01:00:51,750 --> 01:00:52,980
0,120 120,510 540,660 660,1140 1140,1230
to the this screen,| we
|我们可以看看make fs做了什么，对吧，

1834
01:00:52,980 --> 01:00:53,730
0,90 90,270 270,360 360,540 540,750
can look at what make

1835
01:00:53,730 --> 01:00:55,530
0,540 540,840 870,1200 1200,1470 1500,1800
fs did, right,| so make
|所以让文件系统在那里存储一大堆文件，

1836
01:00:55,530 --> 01:00:56,460
0,330 330,450 450,480 480,720 720,930
fs stored a whole bunch

1837
01:00:56,460 --> 01:00:58,000
0,330 390,780 780,1140
of files there,|
|

1838
01:00:58,410 --> 01:00:59,670
0,210 210,300 300,720 720,870 870,1260
in the files that before
在我们实际创建文件x之前的文件中。

1839
01:00:59,670 --> 01:01:01,050
0,120 120,330 330,630 630,900 900,1380
we actually created file x.|
|

1840
01:01:01,800 --> 01:01:03,210
0,660 690,750 750,960 960,1080 1080,1410
And in fact we've created
事实上，我们创造了所有这些人。

1841
01:01:03,210 --> 01:01:04,660
0,210 210,420 420,960
all these guys.|
|

1842
01:01:05,540 --> 01:01:06,560
0,420 420,600 600,660 660,810 810,1020
And so it was only
所以只有很大一部分磁盘已经被文件填满了，

1843
01:01:06,560 --> 01:01:07,220
0,60 60,240 240,510 510,570 570,660
a good chunk of the

1844
01:01:07,220 --> 01:01:08,870
0,270 270,360 360,630 630,1080 1110,1650
disk is already filled by

1845
01:01:08,870 --> 01:01:10,550
0,150 150,600 600,870 930,1140 1140,1680
the files,| the for blocks
|for块相当数量的块，基本上已被该组文件使用。

1846
01:01:10,790 --> 01:01:12,470
0,30 240,930 930,1170 1170,1260 1260,1680
a good number of blocks

1847
01:01:12,470 --> 01:01:14,630
0,450 450,1050 1050,1410 1410,1710 1710,2160
already used basically by the

1848
01:01:14,630 --> 01:01:15,800
0,180 180,240 240,720
set of files.|
|

1849
01:01:18,660 --> 01:01:19,920
0,660
{Got,it}.|
明白了。|

1850
01:01:20,800 --> 01:01:22,510
0,390 390,690 690,1140 1140,1380 1380,1710
{} Would it write down
会不会写下挡路五九五跟，

1851
01:01:22,510 --> 01:01:24,340
0,300 300,840 840,1170 1170,1410 1410,1830
that block five ninety five

1852
01:01:24,370 --> 01:01:26,680
0,660 720,1320 1320,1770
is related to,|
|

1853
01:01:26,680 --> 01:01:28,090
0,510 510,660 660,930 960,1110 1110,1410
that to that I know
这是我在上一次的时候知道的，就像是在第三次写到那个的时候。

1854
01:01:28,090 --> 01:01:30,250
0,540 540,750 750,1380 1410,1770 1770,2160
during the last, like during

1855
01:01:30,250 --> 01:01:32,500
0,420 720,1230 1230,1590 1590,1950 1950,2250
the write three to that.|
|

1856
01:01:32,530 --> 01:01:35,260
0,720 900,1650 1650,1950 1950,2130 2130,2730
Yeah, exactly correct,| so there's
是的，完全正确，|所以有三个可能发生的事情都是正确的，

1857
01:01:35,260 --> 01:01:36,400
0,240 240,570 570,810 810,1080 1080,1140
write through three probably a

1858
01:01:36,400 --> 01:01:37,630
0,210 210,270 270,480 480,810 900,1230
bunch of things happened correct,|
|

1859
01:01:37,630 --> 01:01:39,420
0,120 120,480 480,630 630,1200
the size got updated.|
尺码更新了。|

1860
01:01:40,640 --> 01:01:42,440
0,600 600,660 660,840 840,1260 1260,1800
And you know bn zero
你知道BN 0和BN 1，我们是最新的，

1861
01:01:42,440 --> 01:01:44,320
0,180 180,570 570,1080
and bn one,

1862
01:01:44,320 --> 01:01:46,030
0,240 240,690 720,930 930,1500 1500,1710
we're updated,| we're certainly bn
|我们确定BN 0是正确的，包含五百九十五个

1863
01:01:46,030 --> 01:01:47,620
0,510 570,750 750,1200 1200,1440 1440,1590
zero is updated correct, to

1864
01:01:47,620 --> 01:01:48,790
0,360 360,600 600,780 780,1080 1080,1170
contain five ninety five| and
|并且这两条信息都被更新索引节点，然后通过该写入被写入磁盘。

1865
01:01:48,790 --> 01:01:50,620
0,240 240,450 450,540 540,1200 1560,1830
both pieces of information are

1866
01:01:50,620 --> 01:01:52,090
0,510 510,690 690,1020 1020,1200 1200,1470
updated {inode -} then written

1867
01:01:52,090 --> 01:01:53,650
0,450 450,690 690,1110 1140,1380 1380,1560
to the disk by this

1868
01:01:53,650 --> 01:01:54,520
0,390
write.|
|

1869
01:01:59,340 --> 01:02:00,560
0,150 150,270 270,630
That makes sense?|
这事儿可以理解?|

1870
01:02:01,580 --> 01:02:03,680
0,450 570,870 870,1110 1110,1620
Yeah yeah, thank you.|
好的好的，谢谢。|

1871
01:02:04,430 --> 01:02:05,750
0,240 240,330 330,540 540,1170 1200,1320
Good, so that's {} you
很好，这就是磁盘布局的本质

1872
01:02:05,750 --> 01:02:06,770
0,120 120,270 270,360 360,510 510,1020
know sort of the essence

1873
01:02:07,130 --> 01:02:09,830
0,600 600,870 870,1440 1830,2250 2250,2700
of disk layout| and hopefully
|希望你能很好地理解是什么让这件事成为现实

1874
01:02:09,830 --> 01:02:10,700
0,330 330,450 450,540 540,720 720,870
you have a pretty good

1875
01:02:10,700 --> 01:02:13,730
0,510 510,810 2130,2400 2400,2640 2640,3030
understanding of what goes on

1876
01:02:14,090 --> 01:02:15,530
0,600 660,840 840,960 960,1350 1350,1440
to make this work| and
|所以现在我们将更详细地看一下代码，

1877
01:02:15,530 --> 01:02:16,550
0,180 180,330 330,750 750,810 810,1020
so it's going to look

1878
01:02:16,550 --> 01:02:17,270
0,90 90,240 240,360 360,630 630,720
a little bit more in

1879
01:02:17,270 --> 01:02:19,190
0,450 450,870 870,1050 1050,1320 1380,1920
detail now at the code,|
|

1880
01:02:19,310 --> 01:02:21,770
0,690 690,1230 1230,1500 1500,2040 2040,2460
{} to see actually {}
实际上看到的东西很少，多一个层次的细节。

1881
01:02:22,260 --> 01:02:24,260
0,390 390,1470
things little,

1882
01:02:24,620 --> 01:02:25,640
0,150 150,420 420,690 690,960 960,1020
{} one more level of

1883
01:02:25,640 --> 01:02:26,660
0,480
detail.|

1884
01:02:26,830 --> 01:02:28,360
0,420 420,900
Okay, so
好的，重新分配信息节点后的第一件事，

1885
01:02:28,520 --> 01:02:30,230
0,120 120,360 360,810 840,1140 1140,1710
the first thing since reallocated

1886
01:02:30,230 --> 01:02:31,280
0,150 150,330 330,570 570,870 870,1050
{inode -},| let's first look
|我们先来看看到底是怎么，怎么发生的，

1887
01:02:31,280 --> 01:02:33,890
0,120 120,600 600,1170 1590,1950 1950,2610
at actually { -} how,

1888
01:02:33,890 --> 01:02:36,500
0,420 780,990 990,1170 1170,1680 2130,2610
{} how that happened {},|
|

1889
01:02:36,500 --> 01:02:38,750
0,510 720,870 870,1170 1170,1950 1980,2250
so in {sysfile -}, let's
因此，在sysfile中，让我们看一下[]。

1890
01:02:38,750 --> 01:02:39,740
0,570
see

1891
01:02:39,740 --> 01:02:40,900
0,630
[].|
|

1892
01:02:43,940 --> 01:02:45,620
0,180 180,480 480,660 660,1110
So here're all the
这里是与文件系统调用相关的所有调用，

1893
01:02:46,010 --> 01:02:47,390
0,420 420,780 780,870 870,1110 1110,1380
calls related to file system

1894
01:02:47,390 --> 01:02:48,410
0,390 390,540 540,630 630,870 870,1020
calls,| so the first thing
|因此，当它刚刚开放时，实际上发生的第一件事是，

1895
01:02:48,410 --> 01:02:49,400
0,150 150,420 420,750 750,900 900,990
that actually happens when it

1896
01:02:49,400 --> 01:02:50,660
0,150 150,360 360,900 900,1170 1170,1260
was just open,| because we're
|因为我们要创建一个文件。

1897
01:02:50,660 --> 01:02:51,800
0,120 120,180 180,450 450,510 510,1140
going to create a file.|
|

1898
01:02:52,440 --> 01:02:54,180
0,330 330,810 930,1260 1260,1620 1620,1740
{} Since {} open will
因为open将调用create，所以这里是create。

1899
01:02:54,180 --> 01:02:55,780
0,390 390,1080
call create,

1900
01:02:59,570 --> 01:03:01,400
0,540 540,1290
here's create.|
|

1901
01:03:01,520 --> 01:03:03,110
0,600 630,1200 1200,1350 1350,1530 1530,1590
{} Create will look at
Create稍后将看到这一点，将路径名解析为基本上最后一个目录，

1902
01:03:03,110 --> 01:03:05,300
0,210 210,750 1140,1800 1800,1860 1860,2190
this later, resolves the path

1903
01:03:05,300 --> 01:03:07,400
0,420 450,780 780,1260 1260,1440 1440,2100
name to basically the last

1904
01:03:07,580 --> 01:03:08,920
0,810
directory,|
|

1905
01:03:08,920 --> 01:03:11,350
0,390 390,1500 1530,2220 2220,2310 2310,2430
walks the directory and then
遍历目录，然后查找并真正关心这一点

1906
01:03:11,350 --> 01:03:12,640
0,240 240,450 450,750 780,1020 1020,1290
does look up and really

1907
01:03:12,640 --> 01:03:14,590
0,210 210,450 450,810 1290,1770 1770,1950
care about that| {} just
|只是想看看文件是否已经存在，

1908
01:03:14,590 --> 01:03:15,190
0,60 60,210 210,300 300,360 360,600
to see if the file

1909
01:03:15,190 --> 01:03:16,150
0,270 270,660 660,780 780,870 870,960
already exists,| and if the
|如果文件存在，你知道你可能转错了方向。

1910
01:03:16,150 --> 01:03:17,350
0,240 240,690 690,810 810,930 930,1200
file exists, you know maybe

1911
01:03:17,350 --> 01:03:19,800
0,120 120,390 390,930
you're {turn,an} error.|
|

1912
01:03:19,830 --> 01:03:21,360
0,510 570,930 930,990 990,1350 1350,1530
And then it calls {inode
然后它调用inode allocation

1913
01:03:21,360 --> 01:03:23,130
0,120 120,720 750,990 990,1350 1440,1770
-} allocate| and so this
|这就是为文件x分配该inode的调用。

1914
01:03:23,130 --> 01:03:24,600
0,180 180,690 720,1200 1200,1380 1380,1470
is the call that is

1915
01:03:24,600 --> 01:03:26,070
0,120 120,210 210,660 660,870 870,1470
going to allocate this {inode

1916
01:03:26,070 --> 01:03:28,320
0,270 270,870 1230,1950
-} for {}

1917
01:03:28,320 --> 01:03:29,760
0,150 150,480 480,960
the file x.|
|

1918
01:03:29,850 --> 01:03:31,050
0,180 180,420 420,660 660,1050 1050,1200
So let's look out it's
所以让我们当心这会是fs.c。

1919
01:03:31,050 --> 01:03:32,940
0,210 210,780 810,1110 1110,1350 1350,1890
gonna be {fs.c - -}.|
|

1920
01:03:37,840 --> 01:03:39,580
0,240 240,480 480,660 660,1110 1110,1740
And here is {ialloc -},|
这是Ialloc，|

1921
01:03:39,610 --> 01:03:41,500
0,570 570,870 870,1350 1350,1770 1770,1890
like most xv6 code, you
就像大多数xv6代码一样，您知道它非常简单，

1922
01:03:41,500 --> 01:03:42,940
0,90 90,210 210,570 660,930 930,1440
know it's just very simple,|
|

1923
01:03:42,940 --> 01:03:44,820
0,180 180,330 330,720 720,1320
but not particularly efficient.|
但效率不是特别高。|

1924
01:03:44,880 --> 01:03:45,960
0,420 420,750 750,870 870,1020 1020,1080
{} And so what it
因此，它所做的基本上是针对所有可能的索引节点编号，

1925
01:03:45,960 --> 01:03:48,060
0,360 360,900 900,1200 1230,1620 1620,2100
does, basically it goes for

1926
01:03:48,090 --> 01:03:50,490
0,270 270,390 390,660 660,1290 1530,2400
all the inode numbers possible,|
|

1927
01:03:51,090 --> 01:03:52,500
0,510 510,660 660,930 930,1080 1080,1410
{} from one to whatever
从1到任意最大信息节点数

1928
01:03:52,500 --> 01:03:53,280
0,60 60,420 420,660 660,780 780,780
the maximum number of {inode

1929
01:03:53,280 --> 01:03:54,720
0,360 360,540 540,660 660,990 1020,1440
-}| that as a possible
|在这个特定的文件系统上，

1930
01:03:54,720 --> 01:03:56,880
0,90 90,240 240,1380 1380,1620 1620,2160
on this particular file system,|
|

1931
01:03:57,120 --> 01:04:00,600
0,240 240,390 390,930 1890,3000
and then reach block,
然后到达挡路，获取该信息节点编号，

1932
01:04:00,720 --> 01:04:01,530
0,270 270,420 420,570 570,660 660,810
{} for that {inode -}

1933
01:04:01,530 --> 01:04:02,700
0,330 330,510 510,570 570,900 900,1170
number,| so, for example starts
|例如，以REACH开头，您知道挡路包含一个编号为1的信息节点

1934
01:04:02,700 --> 01:04:04,350
0,90 90,600 990,1470 1470,1560 1560,1650
with one, reach, you know

1935
01:04:04,350 --> 01:04:05,400
0,120 120,480 480,870 870,1050 1050,1050
the block contains an inode

1936
01:04:05,400 --> 01:04:08,940
0,360 360,870 1260,2010 2010,3000
number one| and {}
|和，然后查看该信息节点编号是否可用

1937
01:04:09,220 --> 01:04:11,050
0,600 690,1020 1020,1260 1260,1680 1680,1830
and, {} then sees if

1938
01:04:11,050 --> 01:04:13,060
0,240 240,330 330,540 540,1710 1770,2010
that {inode -} number is

1939
01:04:13,060 --> 01:04:14,740
0,420 420,840 870,1080 1080,1260 1260,1680
free| and if it's not,
|如果它不是，如果它是免费的，

1940
01:04:14,770 --> 01:04:16,630
0,210 210,300 300,450 450,900 1200,1860
if it is free,| then
|然后它会说要归档，

1941
01:04:16,630 --> 01:04:18,280
0,0 0,630 630,840 840,1020 1020,1650
{} it says it to

1942
01:04:18,610 --> 01:04:20,290
0,450 450,1020 1020,1200 1200,1530 1530,1680
{} file,| and that way
|通过这种方式将其标记为已分配并将其写入磁盘，

1943
01:04:20,290 --> 01:04:23,230
0,420 420,720 750,1380 1380,2190 2520,2940
marks it as allocated and

1944
01:04:23,230 --> 01:04:24,220
0,210 210,270 270,360 360,780 810,990
writes it to disk,| and
|这个LOG_WRITE，您实际上打印了我有的语句，我实际上放入LOG_WRITE，

1945
01:04:24,220 --> 01:04:25,720
0,270 270,600 600,1020 1020,1140 1140,1500
this {log_write -}, you actually

1946
01:04:25,720 --> 01:04:27,550
0,240 240,570 570,720 720,1170 1500,1830
print statements I had, I

1947
01:04:27,550 --> 01:04:29,530
0,240 240,570 570,960 960,1380 1680,1980
put actually {log_write -},| so
|因此LOG_WRITE是我们看到第一次写入，

1948
01:04:29,530 --> 01:04:31,060
0,420 420,690 690,1110
that {log_write -}

1949
01:04:33,080 --> 01:04:34,760
0,750 810,1020 1020,1140 1140,1410 1410,1680
{} was the first write

1950
01:04:34,760 --> 01:04:36,710
0,150 150,390 390,900 1230,1710 1710,1950
that we've seen,| {} in
|在我们执行文件系统操作的写入序列中。

1951
01:04:36,710 --> 01:04:38,060
0,510 510,870 870,960 960,1230 1230,1350
that sequence of writes that

1952
01:04:38,060 --> 01:04:39,080
0,90 90,420
we did

1953
01:04:39,500 --> 01:04:41,240
0,420 420,630 630,900 900,1380 1410,1740
what file system do.| {Does,this}
|这有意义吗？

1954
01:04:41,240 --> 01:04:42,300
0,150 150,510
make sense?|
|

1955
01:04:47,880 --> 01:04:50,640
0,240 240,930 1050,1890 2430,2580 2580,2760
So interesting, {} so it's
非常有趣，所以这基本上是一系列事件

1956
01:04:50,640 --> 01:04:51,630
0,300 300,450 450,540 540,630 630,990
basically sort of the sequence

1957
01:04:51,630 --> 01:04:52,710
0,150 150,480 480,750 750,930 930,1080
of events| that get you
|这会让您第一次写入磁盘，

1958
01:04:52,710 --> 01:04:54,630
0,150 150,270 270,870 900,1800 1800,1920
to the first write to

1959
01:04:54,630 --> 01:04:56,910
0,90 90,540 960,1290 1290,1740 1740,2280
the disk,| {} interesting question
|当然，有趣的问题是，如果多个进程同时调用create会发生什么情况，

1960
01:04:56,910 --> 01:04:57,960
0,90 90,600
of course,

1961
01:04:58,200 --> 01:05:00,300
0,210 210,630 630,960 960,1200 1200,2100
{} what happens if multiple

1962
01:05:00,750 --> 01:05:04,560
0,1410 1650,2490 2640,3360 3360,3720 3720,3810
processes are calling create at

1963
01:05:04,560 --> 01:05:05,820
0,60 60,240 240,600 630,990 990,1260
the same time,| {} multi
|可以并行运行的多核机器，

1964
01:05:05,820 --> 01:05:07,350
0,210 210,960 960,1050 1050,1140 1140,1530
core machine that can be

1965
01:05:07,710 --> 01:05:09,630
0,930 930,1050 1050,1680 1710,1800 1800,1920
running in parallel,| you know
|你知道，几乎同时下来，所有的人都会到达Ialloc，

1966
01:05:09,630 --> 01:05:11,490
0,240 240,810 810,1290 1290,1650 1650,1860
coming down and all get

1967
01:05:11,490 --> 01:05:12,510
0,60 60,240 240,660 660,930 930,1020
to {ialloc -} roughly at

1968
01:05:12,510 --> 01:05:13,950
0,60 60,300 300,840 1170,1290 1290,1440
the same time,| and then
|然后他们要说的就是面包，

1969
01:05:13,950 --> 01:05:15,330
0,300 300,480 480,630 630,1200 1200,1380
all they're gonna call they're

1970
01:05:15,330 --> 01:05:17,100
0,150 150,360 360,570 570,960 1530,1770
gonna call {bread -},| so
|所以有一些故事，或者说这些写是如何彼此不干扰的。

1971
01:05:17,100 --> 01:05:18,720
0,210 210,300 300,540 540,1200
there has some story

1972
01:05:18,720 --> 01:05:21,570
0,180 180,900 1170,1980 1980,2490 2490,2850
or how is these writes

1973
01:05:21,570 --> 01:05:22,830
0,210 210,600 600,750 750,900 900,1260
don't interfere with each other.|
|

1974
01:05:23,700 --> 01:05:25,110
0,330 330,480 480,690 690,1140 1140,1410
Yeah it's really worthwhile looking
是啊，这真的很值得一看，

1975
01:05:25,110 --> 01:05:27,090
0,510 960,1440 1440,1710 1710,1770 1770,1980
into,| {} because in some
|因为在某种意义上，你知道这实际上是你目前正在做的实验的最后一部分，

1976
01:05:27,090 --> 01:05:27,990
0,360 360,450 450,570 570,780 780,900
sense, you know this is

1977
01:05:27,990 --> 01:05:29,550
0,360 360,870 900,1140 1140,1230 1230,1560
actually the part of the

1978
01:05:30,030 --> 01:05:31,560
0,750 750,930 930,990 990,1320 1320,1530
last part of this lab

1979
01:05:31,560 --> 01:05:33,420
0,90 90,210 210,600 600,930 1410,1860
that you're currently doing {},|
|

1980
01:05:33,420 --> 01:05:34,380
0,210 210,330 330,630 630,870 870,960
so it gets into the
所以它会进入缓冲区高速缓存。

1981
01:05:34,380 --> 01:05:35,480
0,210 210,660
buffer cache.|
|

1982
01:05:37,940 --> 01:05:39,260
0,570 570,750 750,1050 1050,1200 1200,1320
{} So let's look at
那么让我们来看看面包，

1983
01:05:39,260 --> 01:05:41,120
0,210 210,750 1320,1500 1500,1680 1680,1860
{bread -},| so on {bread
|所以在面包上，它做的第一件事实际上就是bget

1984
01:05:41,120 --> 01:05:42,350
0,510 540,840 840,930 930,1140 1140,1230
-} more the first thing

1985
01:05:42,350 --> 01:05:43,370
0,90 90,330 330,600 600,720 720,1020
it does actually it's called

1986
01:05:43,370 --> 01:05:45,470
0,150 150,600 630,1140 1140,1560 1620,2100
{bget -}| and so basically
|因此基本上可以在缓冲区高速缓存中获得一个槽。

1987
01:05:45,470 --> 01:05:47,330
0,180 180,660 660,900 900,1680 1710,1860
{bget -} a slot in

1988
01:05:47,330 --> 01:05:48,660
0,90 90,360 360,870
the buffer cache.|
|

1989
01:05:48,660 --> 01:05:50,430
0,240 240,390 390,480 480,1140 1440,1770
Let's look at the {bget
让我们看一小会儿bget，

1990
01:05:50,430 --> 01:05:51,990
0,210 210,450 450,690 690,900 900,1560
-} for a little while,|
|

1991
01:05:51,990 --> 01:05:53,130
0,210 210,360 360,480 480,840 840,1140
because there's a reasonable tricky
因为有一个合理而棘手的代码。

1992
01:05:53,130 --> 01:05:54,080
0,390
code.|
|

1993
01:05:55,700 --> 01:05:57,080
0,690
And,
那么，这里的前几行是怎么回事。

1994
01:05:58,460 --> 01:05:59,210
0,150 150,300 300,480 480,690 690,750
so what's going on in

1995
01:05:59,210 --> 01:06:01,040
0,90 90,660 840,1140 1140,1410 1410,1830
the first couple lines here.|
|

1996
01:06:03,810 --> 01:06:04,740
0,180 180,540 540,720 720,810 810,930
I imagine some of you
我想你们中的一些人已经看过了这段代码的相当详细的内容

1997
01:06:04,740 --> 01:06:05,790
0,360 360,630 630,690 690,810 810,1050
already looked at this code

1998
01:06:05,790 --> 01:06:06,720
0,180 180,210 210,330 330,390 390,930
quite a bit of detail|
|

1999
01:06:06,720 --> 01:06:07,770
0,150 150,360 360,420 420,600 600,1050
as part of this lab,
作为本实验的一部分，[锁定]挡路。

2000
01:06:08,510 --> 01:06:10,080
0,150 150,480 480,990
the [locking] block.|
|

2001
01:06:10,170 --> 01:06:11,040
0,180 180,300 300,480 480,690 690,870
{} So what's going on
那么这里到底是怎么回事。

2002
01:06:11,040 --> 01:06:12,000
0,360
here.|
|

2003
01:06:18,480 --> 01:06:20,760
0,420 450,930 930,1440 1440,1890 1920,2280
{} It blocks the linked
它阻塞链表并检查是否有任何

2004
01:06:20,760 --> 01:06:22,860
0,330 330,480 480,1020 1050,1500 1530,2100
list and check if any

2005
01:06:22,860 --> 01:06:24,690
0,120 120,450 600,1140 1350,1710 1710,1830
of the,| {} things in
|储藏室里的东西和我们要找的一样。

2006
01:06:24,690 --> 01:06:27,330
0,390 450,1050 1050,1320 1320,2070 2400,2640
the cache are maching with

2007
01:06:27,330 --> 01:06:28,980
0,180 180,330 330,660 660,1140
what we're looking for.|
|

2008
01:06:28,980 --> 01:06:31,260
0,600 630,1410 1440,2010 2010,2160 2160,2280
Yeah, so basically this is
是的，所以基本上这就是藏身之处，

2009
01:06:31,260 --> 01:06:33,300
0,90 90,510 510,660 660,1260 1530,2040
the cache,| in action {}
|在行动中，我们要找的是无论挡路号码是多少，挡路号码是33

2010
01:06:33,300 --> 01:06:34,530
0,150 150,510 510,810 810,1140 1140,1230
we're looking for whatever the

2011
01:06:34,530 --> 01:06:36,510
0,330 330,870 870,870 1560,1800 1800,1980
block number, {} block number

2012
01:06:36,510 --> 01:06:38,730
0,450 450,900 1230,1710 1710,1830 1830,2220
{33 -}| and we're basically
|我们基本上是在看缓存里是否已经有编号33的挡路了。

2013
01:06:38,730 --> 01:06:40,380
0,630 630,870 870,960 960,1290 1290,1650
seeing if the cache already

2014
01:06:40,380 --> 01:06:41,790
0,390 390,660 660,840 840,1110 1110,1410
has {block -} number 33.|
|

2015
01:06:43,040 --> 01:06:45,440
0,540 720,1650 1830,2070 2070,2310 2310,2400
And and if that is
如果是这样的话，它就会增加裁判数量

2016
01:06:45,440 --> 01:06:46,940
0,90 90,750 990,1170 1170,1440 1440,1500
the case, it bumps the

2017
01:06:46,940 --> 01:06:50,510
0,240 240,810 900,1530 1650,2490 2850,3570
ref count up| and {}
|然后释放bcache锁，

2018
01:06:50,510 --> 01:06:51,470
0,180 180,390 390,750 750,840 840,960
and then release the {bcache

2019
01:06:51,470 --> 01:06:52,940
0,270 270,660 690,870 870,990 990,1470
-} lock,| because we're done
|因为我们已经完成了对缓存本身的调查，

2020
01:06:52,970 --> 01:06:54,980
0,360 360,480 480,780 780,1410 1710,2010
looking into cache itself,| we
|我们知道它在那里，我们知道那里有一个特定挡路的缓冲区，

2021
01:06:54,980 --> 01:06:56,750
0,150 150,300 300,900 1230,1590 1590,1770
know it's there we know

2022
01:06:56,750 --> 01:06:58,130
0,150 150,300 300,360 360,900 930,1380
that there's a buff- buffer

2023
01:06:58,130 --> 01:06:59,390
0,120 120,240 240,570 570,840 840,1260
for that particular block, there,|
|

2024
01:06:59,630 --> 01:07:01,820
0,480 480,1080 1110,1770 1770,2040 2040,2190
{} and, {} and then
然后，实际上发生的下一步是有点有趣的。

2025
01:07:01,820 --> 01:07:02,690
0,60 60,300 300,540 540,660 660,870
the next step that actually

2026
01:07:02,690 --> 01:07:04,220
0,600 870,1080 1080,1290 1290,1440 1440,1530
happens {} is sort of

2027
01:07:04,220 --> 01:07:05,260
0,600
interesting.|
|

2028
01:07:06,490 --> 01:07:08,680
0,450 450,960 990,1620 1650,1950 1950,2190
Next step, the block cache
下一步，挡路缓存基本上会尝试锁定缓冲区。

2029
01:07:08,680 --> 01:07:10,480
0,390 390,720 720,1050 1080,1770 1770,1800
basically tries to get a

2030
01:07:10,480 --> 01:07:13,340
0,630 1020,1740 1770,1920 1920,2370
lock on the buffer.|
|

2031
01:07:13,660 --> 01:07:15,730
0,630 1050,1440 1440,1560 1560,1740 1740,2070
So, {} so what happens
那么，如果多个进程同时调用bget，

2032
01:07:15,730 --> 01:07:17,440
0,120 120,300 300,1110
if like multiple

2033
01:07:17,560 --> 01:07:18,880
0,630 630,720 720,810 810,1080 1080,1320
processes at the same time

2034
01:07:18,880 --> 01:07:21,100
0,270 270,480 480,870 900,1530 1860,2220
called {bget -},| well one
|其中一个会获得bcache锁，对吧。

2035
01:07:21,100 --> 01:07:21,970
0,90 90,540 570,690 690,810 810,870
of them is going to

2036
01:07:21,970 --> 01:07:23,020
0,150 150,210 210,360 360,630 630,1050
get the {bcache -} lock,

2037
01:07:23,050 --> 01:07:24,040
0,450
right.|
|

2038
01:07:24,350 --> 01:07:25,670
0,120 120,270 270,330 330,660 660,1320
It's going to scan the
它将扫描缓冲区缓存，

2039
01:07:25,940 --> 01:07:27,500
0,300 300,810 840,1020 1020,1170 1170,1560
buffer cache,| and so nobody
|因此，没有人可以在此特定点实际修改缓冲区缓存。

2040
01:07:27,500 --> 01:07:28,520
0,120 120,330 330,720 720,810 810,1020
can actually modify the buffer

2041
01:07:28,520 --> 01:07:29,840
0,240 240,300 300,450 450,840 840,1320
cache in this particular point.|
|

2042
01:07:30,420 --> 01:07:32,430
0,480 510,750 750,1410 1440,1740 1740,2010
Find if the block number
找出挡路号码是否在那里，以及挡路号码是否在那里，

2043
01:07:32,430 --> 01:07:33,180
0,120 120,420 420,540 540,660 660,750
is there and if the

2044
01:07:33,180 --> 01:07:35,130
0,240 240,450 450,570 570,1140 1350,1950
block number is there {},|
|

2045
01:07:35,130 --> 01:07:36,540
0,360 360,660 660,750 750,930 930,1410
it bumps the ref count,|
它会增加裁判数量，|

2046
01:07:36,600 --> 01:07:38,460
0,210 210,750 750,870 870,1440 1440,1860
{} indicating that basically it
这表明基本上它有一个引用，你知道，这个特别的锁

2047
01:07:38,490 --> 01:07:39,660
0,270 270,360 360,990 990,1080 1080,1170
has a reference, you know

2048
01:07:39,660 --> 01:07:41,320
0,210 210,600 600,1200
to this, {}

2049
01:07:41,320 --> 01:07:42,340
0,240 240,540 540,780 780,870 870,1020
this particular lock| and then
|然后释放BCACHE锁。

2050
01:07:42,340 --> 01:07:44,530
0,630 660,1290 1320,1500 1500,1770 1770,2190
releases the {bcache -} lock.|
|

2051
01:07:44,800 --> 01:07:45,430
0,180 180,300 300,420 420,570 570,630
So if there were a
因此，如果有第二个进程在等待，

2052
01:07:45,430 --> 01:07:47,840
0,330 330,990 1020,1860
second process waiting,|

2053
01:07:47,960 --> 01:07:50,150
0,870 870,1050 1050,1170 1170,1440 1440,2190
{} all to also scan
都是为了也扫描这个缓存，它可能实际上不需要马上锁定，对，

2054
01:07:50,150 --> 01:07:51,920
0,210 210,480 480,900 900,1410 1530,1770
the {} this cache, it

2055
01:07:51,920 --> 01:07:53,000
0,150 150,330 330,540 540,990 990,1080
might not actually require to

2056
01:07:53,000 --> 01:07:54,800
0,330 330,480 480,840 870,1260 1650,1800
lock right away, right,| in
|其实可能是第二次扫描的过程，一个也想扫描一下这个挡路33。

2057
01:07:54,800 --> 01:07:55,430
0,240 240,360 360,510 510,570 570,630
fact it might be a

2058
01:07:55,430 --> 01:07:57,050
0,330 330,780 780,990 990,1440 1440,1620
second process of scanning for

2059
01:07:57,050 --> 01:07:58,160
0,240 240,510 510,660 660,720 720,1110
one also want to scan

2060
01:07:58,160 --> 01:07:59,630
0,120 120,270 270,780 780,930 930,1470
for this block {33 -}.|
|

2061
01:08:00,140 --> 01:08:01,760
0,570 600,780 780,870 870,1260 1260,1620
And it will also get
它还将使您知道基本上引用是增加引用计数，

2062
01:08:01,760 --> 01:08:02,990
0,150 150,330 330,720 720,810 810,1230
you know basically a reference

2063
01:08:02,990 --> 01:08:05,180
0,450 450,840 840,1290 1560,1800 1800,2190
to {} be {} bump

2064
01:08:05,180 --> 01:08:07,010
0,90 90,450 450,960 1230,1590 1590,1830
the reference count,| {} to
|到两三个人，不管是什么

2065
01:08:07,010 --> 01:08:08,660
0,540 750,930 930,1170 1170,1560 1560,1650
two or three whatever it

2066
01:08:08,660 --> 01:08:10,190
0,450 660,900 900,1350 1350,1440 1440,1530
is| and then you know
|然后你知道他们两个都会试着叫“获取睡眠”

2067
01:08:10,190 --> 01:08:11,060
0,270 270,330 330,510 510,630 630,870
both of them will try

2068
01:08:11,060 --> 01:08:12,800
0,120 120,390 390,810 810,1290
to call acquire sleep,|
|

2069
01:08:13,200 --> 01:08:14,580
0,300 300,450 450,780 780,1110 1110,1380
on that particular buffer buffer
在该特定缓冲器缓冲器33上。

2070
01:08:14,580 --> 01:08:15,780
0,270 270,630
{33 -}.|
|

2071
01:08:16,120 --> 01:08:17,380
0,270 270,630 630,990 990,1080 1080,1260
And acquire sleep, it's just
并获得睡眠，这基本上是另一种类型的锁，

2072
01:08:17,380 --> 01:08:19,030
0,360 360,780 780,1050 1050,1170 1170,1650
basically another type of lock,|
|

2073
01:08:19,210 --> 01:08:20,860
0,570 570,1020 1020,1200 1200,1320 1320,1650
{} we call them sleep
我们称它们为睡眠锁，稍后我们会讨论，

2074
01:08:20,860 --> 01:08:22,630
0,540 720,1050 1050,1350 1350,1530 1530,1770
locks and we'll talk about

2075
01:08:22,630 --> 01:08:25,480
0,150 150,180 180,660 870,1650 1980,2850
in a second,| but basically
|但基本上，您知道这会获得缓冲区上的锁，

2076
01:08:25,480 --> 01:08:27,100
0,120 120,540 540,780 780,1560 1560,1620
you know this acquires the

2077
01:08:27,100 --> 01:08:28,930
0,600 630,840 840,960 960,1470 1650,1830
lock on the buffer,| so
|所以两个进程中的一个将获得缓冲器33的锁。

2078
01:08:28,930 --> 01:08:30,130
0,270 270,360 360,450 450,630 630,1200
one of the two processes

2079
01:08:30,130 --> 01:08:31,480
0,180 180,390 390,840
will get the,

2080
01:08:31,480 --> 01:08:32,620
0,270 270,420 420,750 750,870 870,1140
{} the lock of buffer

2081
01:08:32,620 --> 01:08:33,900
0,270 270,720
{33 -}.|
|

2082
01:08:33,900 --> 01:08:36,390
0,660 660,930 930,1560 1590,2220 2220,2490
And will proceed and that
并将继续进行，这将返回，并从[通过动议]，

2083
01:08:36,390 --> 01:08:38,430
0,120 120,210 210,900 1200,1890 1890,2040
will be returned and go

2084
01:08:38,430 --> 01:08:40,260
0,150 150,390 390,660 660,1440 1710,1830
from [going through motions],| you
|你知道，就像扫描挡路33，看看是否有真正空闲的信息节点。

2085
01:08:40,260 --> 01:08:41,520
0,210 240,480 480,840 840,990 990,1260
know like scanning that block

2086
01:08:41,520 --> 01:08:42,450
0,210 210,540 540,660 660,810 810,930
{33 -} to see if

2087
01:08:42,450 --> 01:08:43,320
0,180 180,300 300,420 420,690 690,870
there is {inode -} that

2088
01:08:43,320 --> 01:08:44,700
0,420 420,540 540,900
actually is free.|
|

2089
01:08:45,580 --> 01:08:47,230
0,210 210,300 300,630 630,1320 1440,1650
And the other process will
另一个过程就是在这里休眠，

2090
01:08:47,230 --> 01:08:48,220
0,210 210,300 300,720 720,840 840,990
just be sitting in the

2091
01:08:48,220 --> 01:08:49,570
0,360 360,720 720,1140 1140,1260 1260,1350
{acquiresleep -} here,| you know
|你知道，要等到第一个过程及其所有操作都完成了。

2092
01:08:49,570 --> 01:08:52,120
0,480 480,900 900,1440 1740,2190 2190,2550
waiting until the first process

2093
01:08:52,120 --> 01:08:53,080
0,120 120,480 480,660 660,840 840,960
is done with all its

2094
01:08:53,080 --> 01:08:54,280
0,810
operations.|
|

2095
01:08:58,380 --> 01:08:59,920
0,180 180,540 540,720 720,1020
Any questions about this?|
对此有什么问题吗？|

2096
01:09:01,970 --> 01:09:03,740
0,690 720,900 900,1050 1050,1140 1140,1770
{} I have a question,|
我有个问题，|

2097
01:09:05,440 --> 01:09:07,900
0,840 930,1410 1410,1590 1590,1920 1920,2460
{} while the ref count
虽然挡路的参考计数不是零，

2098
01:09:07,930 --> 01:09:09,790
0,360 360,510 510,1170 1200,1590 1590,1860
of a block is not

2099
01:09:09,790 --> 01:09:12,310
0,600 600,1050 1050,1680 1680,2220 2220,2520
zero,| can anything important about
|挡路有没有什么重要的改变，

2100
01:09:12,310 --> 01:09:15,010
0,210 210,600 630,1560 1590,2370 2370,2700
that block change,| because something
|因为在释放bcache和获取挡路锁之间可能会发生一些事情。

2101
01:09:15,010 --> 01:09:16,810
0,210 210,750 750,1170 1170,1320 1320,1800
can happen between the release

2102
01:09:16,810 --> 01:09:18,640
0,150 150,330 330,600 600,1350
of the {bcache -}

2103
01:09:18,640 --> 01:09:20,980
0,540 780,1710 1710,1830 1830,2160 2160,2340
and acquiring the lock of

2104
01:09:20,980 --> 01:09:22,080
0,120 120,570
the block.|
|

2105
01:09:22,600 --> 01:09:24,910
0,330 330,780 780,1710 1710,1830 1830,2310
Yeah actually the the protocol,
是的，实际上是协议，好的，所以我想在这里说明几点，

2106
01:09:24,910 --> 01:09:25,930
0,180 180,330 330,510 510,720 750,1020
okay, so there's a couple

2107
01:09:25,930 --> 01:09:26,500
0,210 210,240 240,360 360,420 420,570
points I want to make

2108
01:09:26,500 --> 01:09:29,170
0,510 510,780 780,1200 1200,1950 1950,2670
here,| the protocol basically, {}
|XV6基本上遵循的协议是对于对BCACHE本身的任何修改，

2109
01:09:29,260 --> 01:09:30,970
0,660 660,960 960,1170 1170,1530 1530,1710
{} {xv6 -} follows is

2110
01:09:30,970 --> 01:09:32,290
0,360 360,540 540,660 660,1200 1200,1320
that for any modification to

2111
01:09:32,290 --> 01:09:33,880
0,240 240,510 510,1260 1320,1470 1470,1590
the bcache itself,| you need
|您需要持有bcache锁。

2112
01:09:33,880 --> 01:09:35,050
0,60 60,300 300,450 450,720 720,1170
to hold the bcache lock.|
|

2113
01:09:36,180 --> 01:09:37,680
0,300 300,450 450,1020 1020,1260 1260,1500
For any modification to this
对于此挡路33的任何修改，

2114
01:09:37,680 --> 01:09:38,970
0,300 300,510 510,1020 1050,1170 1170,1290
block {33 -},| you need
|你需要握住挡路33号的睡眠锁。

2115
01:09:38,970 --> 01:09:40,050
0,60 60,330 330,390 390,690 690,1080
to hold the sleep {lock

2116
01:09:40,080 --> 01:09:41,640
0,420 420,660 660,990
-} block 33.|
|

2117
01:09:41,790 --> 01:09:42,960
0,420 420,540 540,690 690,840 840,1170
And so at any particular
所以在任何特定的时间点，

2118
01:09:42,960 --> 01:09:45,150
0,180 180,240 240,840 1140,1920 1920,2190
point in time,| {} so
|因此在发布后，b引用计数大于零。

2119
01:09:45,180 --> 01:09:48,660
0,420 420,570 570,1200 1590,2550 2670,3480
after the release {} b

2120
01:09:48,660 --> 01:09:51,360
0,210 210,510 510,1080 1110,2100 2250,2700
ref count is a larger

2121
01:09:51,360 --> 01:09:53,280
0,120 120,720 1050,1620 1650,1800 1800,1920
than zero| and there will
|并且不会对缓冲器高速缓存进行修改，

2122
01:09:53,280 --> 01:09:55,050
0,150 150,540 540,1470 1560,1710 1710,1770
be no modification to the

2123
01:09:55,050 --> 01:09:56,580
0,240 240,720 960,1200 1200,1410 1410,1530
buffer cache,| buffer cache will
|缓冲器高速缓存将只驱逐实际具有引用计数零的东西，

2124
01:09:56,580 --> 01:09:57,920
0,420 420,930
only evict

2125
01:09:57,920 --> 01:09:59,150
0,420 420,750 750,870 870,1110 1110,1230
or things that actually have

2126
01:09:59,150 --> 01:10:00,530
0,90 90,270 270,510 510,840 840,1380
the ref count zero,| never
|从来不会有大于零的裁判数。

2127
01:10:00,530 --> 01:10:01,400
0,210 210,390 390,450 450,630 630,870
that has a ref count

2128
01:10:01,400 --> 01:10:03,290
0,480 510,840 840,1080 1080,1350 1380,1890
of something bigger than zero.|
|

2129
01:10:04,120 --> 01:10:04,840
0,180 180,330 330,450 450,630 630,720
And so we know for
所以我们可以肯定的是，这个挡路基本上这个缓冲区在BCACHE本身是不会被触及的，

2130
01:10:04,840 --> 01:10:06,340
0,300 300,420 420,570 570,930 930,1500
sure that this block basically

2131
01:10:06,340 --> 01:10:08,020
0,210 210,570 570,1080 1080,1170 1170,1680
this buffer won't be touched

2132
01:10:08,020 --> 01:10:09,760
0,180 180,360 360,660 660,1230 1530,1740
in the bcache itself,| {you,know}
|你知道其他进程可能正在查找，

2133
01:10:09,760 --> 01:10:11,020
0,300 300,720 720,930 930,990 990,1260
other processes might be looking

2134
01:10:11,020 --> 01:10:12,760
0,330 330,1110 1110,1350 1350,1440 1440,1740
up,| {} might be looking
|可能正在查找bcache中的条目，

2135
01:10:12,760 --> 01:10:14,260
0,360 420,600 600,1110 1110,1290 1290,1500
up the entry in the

2136
01:10:14,260 --> 01:10:16,450
0,510 750,1530 1530,1770 1770,2040 2040,2190
bcache,| but it won't be
|但它不会从bcache中删除，对吧。

2137
01:10:16,450 --> 01:10:18,360
0,630 630,810 810,990 990,1500
removed from the bcache,

2138
01:10:19,710 --> 01:10:20,700
0,510
right.|
|

2139
01:10:21,160 --> 01:10:22,990
0,330 330,990 990,1200 1200,1680 1680,1830
{Yeah,make,sense}.| And this lock that
是啊，说得通。|而这个休眠锁上的第二个锁实际上是保护缓冲区内容的锁，

2140
01:10:22,990 --> 01:10:23,950
0,270 270,450 450,510 510,630 630,960
second lock at this sleep

2141
01:10:23,950 --> 01:10:25,330
0,240 240,360 360,600 600,1020 1020,1380
lock is really what protects

2142
01:10:25,330 --> 01:10:26,770
0,120 120,720 720,900 900,990 990,1440
the content of the buffer,|
|

2143
01:10:27,440 --> 01:10:29,240
0,390 390,990 990,1140 1140,1410 1410,1800
{} ensuring that only one
确保实际只有一个进程在读取或写入缓冲区

2144
01:10:29,240 --> 01:10:30,860
0,420 420,720 720,930 930,1320 1320,1620
process actually will be reading

2145
01:10:30,860 --> 01:10:32,360
0,90 90,450 450,510 510,990 1290,1500
or writing the buffer| at
|在任何特定的时间点。

2146
01:10:32,360 --> 01:10:33,410
0,180 180,510 510,690 690,750 750,1050
any particular point of time.|
|

2147
01:10:36,060 --> 01:10:39,180
0,600 780,990 990,1530 1530,2040 2490,3120
And it's important, correct,| that
这是很重要的，正确的，|那个(它可以说)，如果像这样说不坏，那就不好了

2148
01:10:39,920 --> 01:10:42,080
0,390 390,870 1110,1530 1530,1680 1680,2160
[{can,it} say], would be bad

2149
01:10:42,080 --> 01:10:43,640
0,390 420,600 600,900 900,1470 1470,1560
if like say wouldn't be

2150
01:10:43,640 --> 01:10:44,810
0,300 300,390 390,660 660,870 870,1170
bad| if block {33 -}
|如果挡路33在不同的槽中在缓存中出现了两次。

2151
01:10:44,810 --> 01:10:45,590
0,210 210,330 330,420 420,480 480,780
ended up in the cache

2152
01:10:45,590 --> 01:10:46,640
0,600
twice

2153
01:10:48,940 --> 01:10:50,440
0,150 150,420 420,930
in different slots.|
|

2154
01:10:53,100 --> 01:10:54,090
0,420 420,630 630,780 780,840 840,990
Yeah, because then he could
是啊，因为那样他就能掌握正确的信息了，对吧。

2155
01:10:54,090 --> 01:10:55,830
0,210 210,330 330,720 720,1350 1350,1740
have the correct information, right.|
|

2156
01:10:56,720 --> 01:10:58,100
0,450 450,780 780,840 840,1200 1200,1380
Yeah correctly,| for example let's
是啊，没错，|例如，假设进程1写入索引节点19

2157
01:10:58,100 --> 01:10:59,450
0,180 180,510 510,810 810,1200 1200,1350
say process one writes {inode

2158
01:10:59,450 --> 01:11:02,480
0,570 930,1530 1800,2880 2880,2970 2970,3030
-} {} nineteen| and the
|而另一个进程写入索引节点20，正确，

2159
01:11:02,480 --> 01:11:03,620
0,180 180,510 510,810 810,960 960,1140
other process writes {inode -}

2160
01:11:03,620 --> 01:11:05,120
0,480 480,900 900,1170 1170,1320 1320,1500
twenty, correct,| and so if
|因此，如果它们都获得了表示的缓冲区的句柄，

2161
01:11:05,120 --> 01:11:06,170
0,120 120,480 480,630 630,690 690,1050
they both get a handle

2162
01:11:06,170 --> 01:11:08,000
0,180 180,270 270,840 1110,1650 1650,1830
on the buffer for that

2163
01:11:08,000 --> 01:11:09,350
0,600 600,690 690,840 840,1110 1110,1350
represents,| you know the the
|你知道挡路33可能会更新信息节点18，

2164
01:11:09,380 --> 01:11:11,570
0,630 630,870 870,1320 1620,1890 1890,2190
block {33 -} {} one

2165
01:11:11,570 --> 01:11:13,310
0,540 570,1050 1050,1110 1110,1260 1260,1740
might update {inode -} eighteen,|
|

2166
01:11:13,310 --> 01:11:15,230
0,690 690,900 900,1530 1530,1680 1680,1920
{the,other} in nineteen,| the first
另一个是19年，|第一个可能是安排的，它是十八个回到圆盘上的，

2167
01:11:15,230 --> 01:11:16,820
0,150 150,390 390,660 660,1170 1170,1590
one maybe arrange, its eighteen

2168
01:11:16,820 --> 01:11:18,020
0,270 270,360 360,450 450,780 810,1200
back to the disk,| then
|然后修改十九号的人写回十九号，

2169
01:11:18,020 --> 01:11:19,580
0,240 270,720 720,840 840,1230
the guy that does

2170
01:11:19,670 --> 01:11:21,740
0,630 630,1080 1080,1320 1320,1710 1710,2070
modified nineteen write nineteen back,|
|

2171
01:11:21,860 --> 01:11:23,720
0,240 240,900 900,1380 1380,1530 1530,1860
will overwrite changes at eighteen
会覆盖十八个月所做的更改，对吧，

2172
01:11:23,720 --> 01:11:25,220
0,390 420,840 930,1140 1140,1290 1290,1500
made, right,| that were made
|是为索引节点18制作的。

2173
01:11:25,220 --> 01:11:26,660
0,120 120,270 270,900
for inode eighteen.|
|

2174
01:11:26,690 --> 01:11:28,220
0,120 120,210 210,390 390,930 1380,1530
And so that's terrible,| so
所以这太可怕了，|因此，挡路号码只能在缓冲区缓存中恰好出现一次。

2175
01:11:28,220 --> 01:11:28,850
0,60 60,360 360,450 450,540 540,630
it has to be the

2176
01:11:28,850 --> 01:11:31,760
0,630 900,1440 1440,1740 1740,2100 2100,2910
case that the block number

2177
01:11:31,790 --> 01:11:33,170
0,510 510,960 960,1050 1050,1140 1140,1380
only appears in the buffer

2178
01:11:33,170 --> 01:11:35,340
0,270 300,630 630,1170 1170,1740
cache only exactly once.|
|

2179
01:11:38,380 --> 01:11:39,670
0,180 180,300 300,420 420,930 930,1290
And there's an invariant correct,|
而且有一个不变的正确答案，|

2180
01:11:39,670 --> 01:11:41,260
0,150 150,420 420,1350 1350,1530 1530,1590
you know you sort of
你知道，在做这件事的同时，你需要维护一个挡路缓存实验室，

2181
01:11:41,260 --> 01:11:42,910
0,210 210,510 570,1290 1290,1530 1530,1650
have to maintain while you're

2182
01:11:42,910 --> 01:11:45,040
0,270 270,540 540,1080 1230,1740 1740,2130
doing this a block cache

2183
01:11:45,040 --> 01:11:47,680
0,630 660,930 930,1290 1290,1650 1650,2640
lab,| {} locking lab in
|把实验室锁在本周的实验室里。

2184
01:11:47,860 --> 01:11:49,300
0,390 390,600 600,990
this week's lab.|
|

2185
01:11:50,140 --> 01:11:51,070
0,240 240,360 360,480 480,810 810,930
Does that make sense, {that
这有意义吗，那个变种。

2186
01:11:51,070 --> 01:11:52,280
0,120 120,600
-} variant.|
|

2187
01:11:54,220 --> 01:11:56,080
0,150 150,360 360,630 630,1410 1410,1860
Yeah, I guess tangential question
是的，我想这是个离题的问题，

2188
01:11:56,080 --> 01:11:57,820
0,120 120,570 930,1200 1200,1500 1500,1740
to this,| there might be
|可能有一些块有多个引用

2189
01:11:57,820 --> 01:11:59,380
0,300 300,690 690,870 870,1110 1110,1560
some blocks that have multiple

2190
01:11:59,380 --> 01:12:01,750
0,540 540,690 690,990 1590,1770 1770,2370
references to them| and then
|然后可能其中一个过程就是接触到这个挡路

2191
01:12:01,780 --> 01:12:03,580
0,540 540,750 750,840 840,930 930,1800
maybe one of the processes

2192
01:12:03,580 --> 01:12:05,620
0,240 240,930 1140,1290 1290,1740 1740,2040
that has is touching this

2193
01:12:05,620 --> 01:12:08,350
0,510 810,1410 1410,1560 1560,2130 2160,2730
block| flushes the cache by
|通过强制写入磁盘来刷新高速缓存，

2194
01:12:08,380 --> 01:12:09,430
0,420 420,570 570,810 810,930 930,1050
forcing a write to the

2195
01:12:09,430 --> 01:12:12,130
0,540 540,1410 1410,2100 2100,2280 2280,2700
disk,| what happens to what
|其他人看到的东西会发生什么。

2196
01:12:12,310 --> 01:12:14,040
0,420 420,690 690,1200
everyone else sees.|
|

2197
01:12:14,070 --> 01:12:17,180
0,450 450,1440 1470,1500 1710,2430
Well as I did,
就像我做的那样，如果写，好的，那么第一个过程在某个点上完成了，

2198
01:12:17,440 --> 01:12:18,670
0,420 420,540 540,840 840,1080 1080,1230
if the write, okay so

2199
01:12:18,670 --> 01:12:19,840
0,180 180,390 390,690 690,780 780,1170
the first process is done

2200
01:12:19,840 --> 01:12:20,980
0,150 150,300 300,600 600,900 900,1140
at some point,| we'll call
|不管它叫什么，我们都会叫它Release[]，

2201
01:12:20,980 --> 01:12:23,590
0,780 810,1410 1590,1800 1800,2430 2430,2610
release {} [] whatever it's

2202
01:12:23,860 --> 01:12:25,630
0,360 360,780 810,1140 1170,1650 1650,1770
called,| {} so basically you
|所以基本上你可以在最后想一想，当它完成的第一个过程是读写那个挡路33时，

2203
01:12:25,630 --> 01:12:27,820
0,90 90,240 240,660 1050,1710 2040,2190
can think about {} at

2204
01:12:27,820 --> 01:12:29,050
0,120 120,360 360,810 810,1020 1020,1230
the end when the first

2205
01:12:29,050 --> 01:12:30,310
0,360 360,600 600,720 720,990 990,1260
process done with it's reading

2206
01:12:30,310 --> 01:12:31,330
0,120 120,450 450,540 540,750 750,1020
and writing to that block

2207
01:12:31,330 --> 01:12:33,040
0,240 240,690 960,1080 1080,1440 1440,1710
{33 -},| I call brelse
|我调用带缓冲区的Brelse Release。

2208
01:12:33,040 --> 01:12:34,540
0,390 390,510 510,600 600,1110
release with a buffer.|
|

2209
01:12:34,540 --> 01:12:36,880
0,510 510,780 780,960 960,1530 1560,2340
And that will actually decrease
这实际上会减少引用计数。

2210
01:12:36,880 --> 01:12:38,460
0,90 90,450 450,990
the reference count.|

2211
01:12:38,460 --> 01:12:40,260
0,450 450,750 750,1170 1170,1590 1620,1800
Well release sleep lock, and
解开睡眠锁，也就是说，如果有人在等，

2212
01:12:40,260 --> 01:12:41,430
0,150 150,390 390,540 540,750 750,1170
that means that if anybody

2213
01:12:41,430 --> 01:12:42,660
0,150 150,570 570,720 720,900 900,1230
was waiting,| any other processes
|任何其他进程都在等待该特定缓冲区

2214
01:12:42,660 --> 01:12:43,980
0,120 120,480 480,630 630,810 810,1320
was waiting for that particular

2215
01:12:43,980 --> 01:12:45,540
0,510 750,1110 1110,1230 1230,1440 1440,1560
buffer| and will now be
|并且现在将能够获得缓冲区上的休眠锁

2216
01:12:45,540 --> 01:12:46,920
0,180 180,240 240,450 450,780 810,1380
able to get the {sleep

2217
01:12:46,920 --> 01:12:48,150
0,180 180,450 450,600 600,720 720,1230
-} lock on the buffer|
|

2218
01:12:48,390 --> 01:12:50,700
0,780 780,990 990,1500 1530,1860 1860,2310
and go read {} it
再去看一下就会看到预览图，比你改的要好，对不对。

2219
01:12:50,700 --> 01:12:52,770
0,240 240,1020 1260,1590 1590,1710 1710,2070
will observe {} the preview

2220
01:12:52,770 --> 01:12:54,720
0,210 210,330 330,930 930,1560
than you make changes,

2221
01:12:54,810 --> 01:12:55,980
0,240 240,330 330,510 510,720 720,1170
right.| So if two processes
|因此如果两个进程都返回到都位于挡路43中的更新索引节点18和1919，

2222
01:12:55,980 --> 01:12:57,270
0,90 90,450 450,540 540,840 840,1290
were returning to the update

2223
01:12:57,270 --> 01:12:58,980
0,90 90,240 240,660 660,750 750,1710
{inode -} eighteen and {1919,that}

2224
01:12:58,980 --> 01:13:00,030
0,150 150,480 480,690 690,780 780,1050
all both live in block

2225
01:13:00,030 --> 01:13:01,710
0,630 900,1230 1230,1350 1350,1440 1440,1680
43,| then if the first
|那么如果第一个过程完成了，

2226
01:13:01,710 --> 01:13:03,450
0,330 330,420 420,870 960,1170 1170,1740
process is done,| it changes
|它改变了18个是可见的

2227
01:13:03,450 --> 01:13:06,510
0,360 360,450 450,1110 1470,2370 2370,3060
eighteen are visible| {} and
|所以下一个，所以下一个人实际上会分配[]inode 19，

2228
01:13:06,510 --> 01:13:08,160
0,300 300,540 540,750 750,1140 1260,1650
{} so the next {}

2229
01:13:08,160 --> 01:13:09,090
0,300 300,420 420,540 540,750 750,930
and so the next guy

2230
01:13:09,090 --> 01:13:10,500
0,150 150,360 360,840 840,1050 1050,1410
will actually allocate [] {inode

2231
01:13:10,500 --> 01:13:12,390
0,120 120,840 870,1290 1290,1620 1620,1890
-} 19,| because actually eighteen
|因为现在实际上十八号已经被标记为档案了。

2232
01:13:12,390 --> 01:13:13,410
0,120 120,480 480,630 630,720 720,1020
is marked as a file

2233
01:13:13,410 --> 01:13:14,100
0,270
now.|
|

2234
01:13:14,820 --> 01:13:16,680
0,150 150,480 480,1110 1110,1260 1260,1860
{} Anybody afterwards will observe
事后任何人都会观察到这些变化。

2235
01:13:16,680 --> 01:13:17,880
0,90 90,690
the changes.|
|

2236
01:13:20,400 --> 01:13:21,480
0,180 180,540
Makes sense?|
合乎道理?|

2237
01:13:23,220 --> 01:13:25,340
0,510 900,1380
Yes, thanks.|
好的，谢谢。|

2238
01:13:25,550 --> 01:13:26,300
0,120 120,210 210,270 270,570 570,750
And this is exactly what
而这正是我们所希望的情况，

2239
01:13:26,300 --> 01:13:27,350
0,120 120,390 390,510 510,630 630,1050
we hoped would be {the,case},|
|

2240
01:13:28,400 --> 01:13:29,960
0,630 660,900 900,1230 1230,1470 1470,1560
if one process creates an
如果一个进程创建索引节点或创建文件，

2241
01:13:29,960 --> 01:13:31,520
0,150 150,360 360,960 960,1380 1380,1560
{inode -} {or,creates,a} file,| then
|那么这个过程，后面的过程确实读了，你应该观察那个文件。

2242
01:13:31,520 --> 01:13:33,440
0,450 690,1170 1170,1410 1410,1740 1740,1920
the process, later process does

2243
01:13:33,440 --> 01:13:34,820
0,360 360,690 690,870 870,1230 1230,1380
read, you should observe that

2244
01:13:34,820 --> 01:13:35,700
0,420
file.|
|

2245
01:13:37,650 --> 01:13:39,740
0,270 270,630 630,630
Okay, then, {}
好的，那么，因为一个更小的细节，

2246
01:13:40,090 --> 01:13:42,370
0,300 300,540 540,900 900,1470 1470,2280
because one more smaller detail,|
|

2247
01:13:42,400 --> 01:13:43,570
0,630 660,810 810,900 900,990 990,1170
{} as you can see
正如您在代码中看到的，

2248
01:13:43,570 --> 01:13:44,440
0,150 150,210 210,300 300,600 600,870
here in the code,| in
|在该进程中实际上对缓冲区进行了休眠锁定

2249
01:13:44,440 --> 01:13:45,660
0,630
the

2250
01:13:45,690 --> 01:13:47,670
0,420 420,780 780,1080 1080,1140 1140,1980
process actually takes a sleeplock

2251
01:13:47,670 --> 01:13:48,990
0,150 150,210 210,660 870,1200 1200,1320
on the buffer| and so
|所以睡眠锁与普通锁或旋转锁略有不同，

2252
01:13:48,990 --> 01:13:50,010
0,90 90,360 360,540 540,660 660,1020
the sleep lock is slightly

2253
01:13:50,010 --> 01:13:52,890
0,360 360,840 1110,1740 1770,2580 2580,2880
different than a regular or

2254
01:13:52,950 --> 01:13:54,810
0,270 270,540 540,990 1200,1530 1530,1860
a spin lock,| let's look
|让我们来看一下睡眠锁。

2255
01:13:54,810 --> 01:13:55,560
0,120 120,390 390,630 630,720 720,750
at sleep lock for a

2256
01:13:55,560 --> 01:13:56,620
0,540
second.|
|

2257
01:13:57,050 --> 01:13:58,400
0,690 690,840 840,1050 1050,1260 1260,1350
And you see what it
你会看到它是什么。

2258
01:13:58,400 --> 01:13:59,320
0,420
is.|
|

2259
01:13:59,350 --> 01:14:00,220
0,240 240,300 300,390 390,480 480,870
So we need to acquire
所以我们需要拿到斯莱普洛克。

2260
01:14:00,220 --> 01:14:01,600
0,750
sleeplock.|
|

2261
01:14:02,040 --> 01:14:04,320
0,1080 1080,1470 1470,1650 1650,1740 1740,2280
Yeah, and when it does,|
是的，当它发生的时候，|

2262
01:14:04,350 --> 01:14:05,760
0,150 150,930 930,1080 1080,1170 1170,1410
it requires you know some
它要求您知道某些字段基本上需要自旋锁定，即与休眠锁定相关联，

2263
01:14:05,760 --> 01:14:08,700
0,480 930,2130 2130,2490 2490,2550 2550,2940
field basically requires a spin

2264
01:14:08,700 --> 01:14:09,990
0,360 360,480 480,570 570,1140 1140,1290
lock, that is associated with

2265
01:14:09,990 --> 01:14:12,450
0,360 360,750 1170,1710 2010,2190 2190,2460
sleep lock,| if the lock
|如果锁真的被锁住了，好的，旋转锁就被锁住了，

2266
01:14:12,450 --> 01:14:13,940
0,90 90,420 420,1020
is actually held,

2267
01:14:14,170 --> 01:14:15,100
0,240 240,360 360,630 630,840 840,930
okay, the spin lock is

2268
01:14:15,100 --> 01:14:18,100
0,420 420,960 1230,1950 1950,2790 2970,3000
held,| then, { - -}
|那么，如果锁真的被锁住了，

2269
01:14:18,100 --> 01:14:19,060
0,330 330,450 450,630 630,720 720,960
if the lock is actually

2270
01:14:19,060 --> 01:14:20,650
0,390 390,870 930,1140 1140,1290 1290,1590
held,| so okay, let me
|好的，让我先看看h文件，h文件包含一个锁定的字段，

2271
01:14:22,110 --> 01:14:23,430
0,450 450,720 720,930 930,1200 1200,1320
first see h file, the

2272
01:14:23,430 --> 01:14:24,810
0,150 150,420 420,930 930,1080 1080,1380
h file contains a locked

2273
01:14:24,810 --> 01:14:25,900
0,510
field,|
|

2274
01:14:25,900 --> 01:14:28,180
0,780 930,1680
{} and,
然后，就这样了。

2275
01:14:30,380 --> 01:14:31,880
0,270 270,390 390,600 600,870
{} and that's it.|
|

2276
01:14:33,800 --> 01:14:35,680
0,300 300,420 420,1230
And so basically.|
所以基本上。|

2277
01:14:36,230 --> 01:14:37,200
0,480

2278
01:14:38,110 --> 01:14:40,120
0,360 360,570 570,780 780,1320 1320,2010
That was the spin lock.|
那是自旋锁。|

2279
01:14:40,150 --> 01:14:42,680
0,330 330,570 570,900 900,1290
Yeah, we're spin lock.|
是的，我们是自旋锁定。|

2280
01:14:46,000 --> 01:14:48,240
0,510 960,1650
Oh, {}
哦，是的，有个旋转锁。

2281
01:14:50,110 --> 01:14:51,490
0,270 270,480 480,540 540,780 780,1380
yeah there's a spin lock.|
|

2282
01:14:53,000 --> 01:14:54,280
0,690

2283
01:14:55,280 --> 01:14:56,620
0,450 450,690
Good good.
很好。抱歉，嗯，如果真的锁住了，

2284
01:15:01,020 --> 01:15:03,720
0,390 1200,1770 2130,2280 2280,2460 2460,2700
Sorry, um, and then if

2285
01:15:03,720 --> 01:15:04,860
0,120 120,360 360,450 450,690 690,1140
the lock is actually held,|
|

2286
01:15:05,010 --> 01:15:06,000
0,300 300,570 570,660 660,900 900,990
sleep lock is held it
睡眠锁被持有，它实际上进入睡眠状态。

2287
01:15:06,000 --> 01:15:07,500
0,180 180,420 420,510 510,960
actually goes to sleep.|
|

2288
01:15:08,160 --> 01:15:10,140
0,150 150,420 420,840 840,1380
So it deschedules itself.|
所以它会自行排定日程。|

2289
01:15:10,140 --> 01:15:12,630
0,690 690,1260 1680,2190 2190,2400 2400,2490
{} And why, why do
为什么，你认为为什么我们对这些缓冲器使用休眠锁而不是旋转锁，

2290
01:15:12,630 --> 01:15:13,770
0,150 150,420 420,570 570,750 750,1140
you think for these buffers

2291
01:15:13,770 --> 01:15:15,660
0,210 210,420 420,780 780,1440 1560,1890
are we {using -} sleep

2292
01:15:15,660 --> 01:15:16,980
0,270 270,540 540,630 630,840 840,1320
locks instead of spin locks,|
|

2293
01:15:17,820 --> 01:15:19,110
0,120 120,240 240,810 810,1020 1020,1290
{because -} indirectly we're using
因为我们间接地使用自旋锁来实现休眠锁，

2294
01:15:19,110 --> 01:15:20,340
0,240 240,450 450,510 510,930 930,1230
spin locks to implement sleep

2295
01:15:20,340 --> 01:15:21,960
0,450 720,1020 1020,1200 1200,1410 1410,1620
locks,| but why not just
|但是为什么不直接用普通的呢？

2296
01:15:21,960 --> 01:15:23,500
0,360 390,930
use regular.|
|

2297
01:15:26,760 --> 01:15:28,560
0,570 570,840 840,1560 1560,1740 1740,1800
Because disk operations take a
因为磁盘操作需要很长时间。

2298
01:15:28,560 --> 01:15:29,740
0,210 210,630
long time.|
|

2299
01:15:29,740 --> 01:15:32,110
0,540 570,900 900,1260 1260,1800 2010,2370
Yeah, there's multiple reasons {},|
是啊，原因有很多，|

2300
01:15:32,110 --> 01:15:32,980
0,210 210,270 270,480 480,570 570,870
there's all kinds of rules
在旋转锁上有各种各样的规则正确的限制，

2301
01:15:32,980 --> 01:15:36,130
0,210 210,750 750,2130 2460,2790 2790,3150
correct restrictions on a on

2302
01:15:36,130 --> 01:15:37,870
0,630 660,930 930,1350 1440,1680 1680,1740
a spin locks,| what is
|自旋锁的限制之一是什么。

2303
01:15:37,870 --> 01:15:38,980
0,180 180,270 270,420 420,960 960,1110
one of the restrictions on

2304
01:15:38,980 --> 01:15:40,160
0,210 210,720
spin locks.|
|

2305
01:15:43,990 --> 01:15:45,190
0,210 210,450 450,540 540,780 780,1200
Well, what do.| Interrupts have
那你要做什么。|中断必须关闭。

2306
01:15:45,190 --> 01:15:46,660
0,90 90,240 240,810 1140,1350 1350,1470
to be off.| Yeah, they
|是啊，他们会关掉干扰，对。

2307
01:15:46,660 --> 01:15:48,500
0,210 210,570 570,840 840,1260
turn interrupts off, right.|
|

2308
01:15:48,830 --> 01:15:50,810
0,330 330,570 570,720 720,1590 1740,1980
And so we were we
所以我们是在拿着缓冲器的情况下开始这项行动的，

2309
01:15:50,810 --> 01:15:53,540
0,390 390,570 570,1350 1710,2250 2250,2730
started this operation while holding

2310
01:15:53,540 --> 01:15:55,400
0,90 90,660 960,1530 1530,1800 1800,1860
a buffer,| while holding a
|同时保持缓冲器上的自旋锁

2311
01:15:55,400 --> 01:15:56,330
0,240 240,480 480,570 570,630 630,930
spin lock on the buffer|
|

2312
01:15:56,330 --> 01:15:57,200
0,120 120,270 270,390 390,540 540,870
and then we would never
然后我们就再也听不到光盘的消息了。

2313
01:15:57,200 --> 01:15:58,700
0,330 330,540 540,630 630,1110
hear from the disk.|
|

2314
01:15:58,700 --> 01:16:00,170
0,180 180,510 510,810 810,1170 1170,1470
Well, maybe another core here,|
嗯，也许这里还有另一个核心，|

2315
01:16:00,170 --> 01:16:01,160
0,390 390,540 540,660 660,810 810,990
but if we had only
但如果我们只有一个核心，我们永远不会收到它的消息，对吗？

2316
01:16:01,160 --> 01:16:02,030
0,180 180,540 540,630 630,750 750,870
one core and we would

2317
01:16:02,030 --> 01:16:03,290
0,210 210,420 420,630 630,810 930,1260
never hear from it, right.|
|

2318
01:16:05,320 --> 01:16:06,730
0,330 330,480 480,930 1170,1320 1320,1410
And for more, for the
更重要的是，出于同样的原因，

2319
01:16:06,730 --> 01:16:07,840
0,210 210,630 630,840 840,960 960,1110
same reasons,| you know you're
|你知道你拿着旋转锁是不允许睡觉的。

2320
01:16:07,840 --> 01:16:08,500
0,180 180,390 390,450 450,570 570,660
not allowed to go to

2321
01:16:08,500 --> 01:16:09,910
0,390 390,780 780,1080 1080,1170 1170,1410
sleep, while holding a spin

2322
01:16:09,910 --> 01:16:10,760
0,390
lock.|
|

2323
01:16:10,930 --> 01:16:12,310
0,360 360,660 660,810 810,1260 1260,1380
{} And so therefore we
因此，我们有了这些睡眠锁，这是一种长期的锁，

2324
01:16:12,310 --> 01:16:14,110
0,240 240,720 780,1350 1350,1650 1650,1800
have these sleep locks that

2325
01:16:14,110 --> 01:16:15,490
0,30 30,210 210,330 330,1050 1050,1380
are sort of long-term locks,|
|

2326
01:16:15,490 --> 01:16:18,700
0,90 90,240 240,660 1050,2850 2880,3210
if you will for for
如果您愿意为该特定用例提供支持的话。

2327
01:16:18,700 --> 01:16:20,280
0,180 180,510 510,660 660,1110
that particular use case.|
|

2328
01:16:20,310 --> 01:16:21,540
0,300 300,390 390,480 480,600 600,1230
So that we can hold
所以我们可以拿着锁睡眠锁的优点之一

2329
01:16:21,780 --> 01:16:24,780
0,870 1020,1440 1440,2040 2700,2940 2940,3000
{} locks {} one of

2330
01:16:24,780 --> 01:16:25,950
0,60 60,480 480,570 570,810 810,1170
the advantages of sleep locks|
|

2331
01:16:25,950 --> 01:16:26,610
0,120 120,210 210,330 330,540 540,660
that we can hold them
我们可以让他们跨越干扰，

2332
01:16:26,610 --> 01:16:28,920
0,360 360,960 1230,1770 1770,2040 2040,2310
across interrupts,| hold because disk
|保留是因为磁盘操作，我们可以长时间保留它们。

2333
01:16:28,920 --> 01:16:30,000
0,570 570,720 720,810 810,990 990,1080
operations, we can hold them

2334
01:16:30,000 --> 01:16:30,960
0,150 150,330 330,570 570,630 630,960
for long periods of time.|
|

2335
01:16:32,010 --> 01:16:33,690
0,150 150,240 240,630 630,1350 1380,1680
And we're not if we're
如果我们在等那把锁，我们就不会了，

2336
01:16:33,690 --> 01:16:35,340
0,510 510,720 720,870 870,1200 1200,1650
waiting on that lock,| {we,also}
|我们也不会让CPU保持忙碌，也不会花费在CPU上，

2337
01:16:35,340 --> 01:16:37,410
0,360 360,960 1230,1590 1590,1680 1680,2070
not {} keeping the CPU

2338
01:16:37,410 --> 01:16:38,490
0,330 330,510 510,930 930,1020 1020,1080
busy or spending on the

2339
01:16:38,490 --> 01:16:40,320
0,600 660,960 960,1320 1320,1740 1740,1830
CPU,| we're basically releasing the
|我们基本上是通过调用睡眠来释放CPU。

2340
01:16:40,320 --> 01:16:42,560
0,420 420,600 600,1110 1110,1770
CPU by calling sleep.|
|

2341
01:16:43,530 --> 01:16:44,780
0,120 120,210 210,330 330,660
Does that make sense?|
这说得通吗？|

2342
01:16:49,580 --> 01:16:51,140
0,240 240,540 540,690 690,990
Any questions about this?|
对此有什么问题吗？|

2343
01:16:56,490 --> 01:16:59,160
0,1230 1410,1950 1950,2220 2220,2310 2310,2670
Okay, let's look at one
好的，我们再来看一件事，

2344
01:16:59,160 --> 01:17:02,250
0,480 480,1230 1260,1680 1680,2400 2610,3090
more {} thing,| {} which
|这就是Brelse。

2345
01:17:02,250 --> 01:17:03,700
0,960
is

2346
01:17:06,160 --> 01:17:07,900
0,540 540,600 600,1200
{brelse - -}.|
|

2347
01:17:08,190 --> 01:17:09,570
0,510 510,660 660,720 720,930 930,1380
{} So we looked already
所以我们已经看了一点，你基本上会打开休眠锁定，

2348
01:17:09,570 --> 01:17:10,620
0,60 60,270 270,600 600,690 690,1050
a little bit, you basically

2349
01:17:10,620 --> 01:17:11,910
0,120 120,300 300,570 570,840 840,1290
would {brelse -} does releases

2350
01:17:11,910 --> 01:17:13,560
0,120 120,390 390,840 870,1230 1230,1650
the sleep lock,| then acquires
|然后获取bcache锁，递减引用计数

2351
01:17:13,560 --> 01:17:15,270
0,180 180,480 480,840 840,1350 1350,1710
the bcache lock, decrement reference

2352
01:17:15,270 --> 01:17:16,560
0,300 300,390 390,720 720,840 840,1290
count| to indicate that one
|以指示一个进程对此特定缓冲区不再感兴趣。

2353
01:17:16,560 --> 01:17:17,970
0,390 390,510 510,690 690,1020 1020,1410
process is not interested anymore,

2354
01:17:17,970 --> 01:17:19,500
0,90 90,270 270,570 570,1020
in this particular buffer.|
|

2355
01:17:19,590 --> 01:17:21,030
0,210 210,450 450,720 720,1170 1170,1440
And then, if a if
然后，如果引用计数为零，

2356
01:17:21,030 --> 01:17:22,170
0,90 90,270 270,450 450,510 510,1140
the ref count is zero,|
|

2357
01:17:22,440 --> 01:17:25,740
0,720 720,1470 1710,2100 2100,2490 2520,3300
{} the, {} it manipulates
这个，它稍微操作一下缓冲区列表，

2358
01:17:25,740 --> 01:17:28,460
0,840 1320,2190
the {}

2359
01:17:28,460 --> 01:17:29,480
0,420 420,480 480,780 780,840 840,1020
list of buffers a little

2360
01:17:29,480 --> 01:17:30,200
0,210 210,420 420,510 510,600 600,720
bit,| what does it do
|它在这里做什么。

2361
01:17:30,200 --> 01:17:31,280
0,540
here.|
|

2362
01:17:38,220 --> 01:17:40,540
0,240 240,990 990,1620
It inserts the
它将b插入到[]列表中b头之后的位置。

2363
01:17:40,540 --> 01:17:42,880
0,330 330,750 750,1500 1620,1830 1830,2340
{} b into the position

2364
01:17:42,880 --> 01:17:46,150
0,810 1140,1860 1890,2460 2640,3150 3150,3270
after b head, inside of

2365
01:17:46,150 --> 01:17:48,340
0,330 360,1200 1320,1680 1680,2070 2070,2190
the []list.| Yeah, where does
|是啊，基本上是什么意思，那是什么意思。

2366
01:17:48,340 --> 01:17:49,330
0,90 90,450 450,690 690,870 870,990
it basically go, what does

2367
01:17:49,330 --> 01:17:50,500
0,180 180,720
that mean.|
|

2368
01:17:52,340 --> 01:17:53,300
0,180 180,360 360,480 480,750 750,960
So let's go back up
那么让我们正确地返回，让我们来看看。

2369
01:17:53,300 --> 01:17:55,460
0,450 450,660 660,960 960,1260 1620,2160
correctly, let's look at {}.|
|

2370
01:17:56,640 --> 01:17:58,040
0,120 120,390 390,810
It was {}
它是最近使用过的。

2371
01:17:58,130 --> 01:18:01,610
0,720 720,1320 1320,1950 2010,2670 2850,3480
most recently used.| Yeah, basically
|是的，基本上移到了最近使用的缓冲区的位置，对。

2372
01:18:01,610 --> 01:18:02,780
0,300 300,570 570,690 690,1110 1110,1170
moves into the position of

2373
01:18:02,780 --> 01:18:04,250
0,90 90,390 390,810 810,1080 1080,1470
the most recently used buffer,

2374
01:18:04,280 --> 01:18:05,220
0,360
right.|
|

2375
01:18:05,340 --> 01:18:06,870
0,150 150,270 270,390 390,1260 1260,1530
And this is important, because
这一点很重要，因为当，当我们在挡路缓存中找不到挡路的时候。

2376
01:18:06,870 --> 01:18:09,900
0,570 870,1680 2040,2400 2400,2550 2550,3030
when, {} when we cannot

2377
01:18:09,900 --> 01:18:11,310
0,510 660,840 840,1230 1230,1320 1320,1410
find the block in the

2378
01:18:11,310 --> 01:18:12,600
0,300 300,840
block cache.|
|

2379
01:18:12,770 --> 01:18:14,780
0,750 990,1290 1290,1440 1440,1530 1530,2010
Then we need to fix
那么我们需要修理一些东西来腾出空间，对吧。

2380
01:18:14,810 --> 01:18:16,490
0,480 480,570 570,750 750,1260 1290,1680
something to make space, right.|
|

2381
01:18:17,280 --> 01:18:18,630
0,750 780,1080 1080,1170 1170,1290 1290,1350
And so we're going to
所以我们要边走边看挡路

2382
01:18:18,630 --> 01:18:19,590
0,180 180,360 360,420 420,780 780,960
go through the block as

2383
01:18:19,590 --> 01:18:20,730
0,90 90,330 330,630 630,780 780,1140
we go| and we basically
|我们基本上从最近使用的一个开始。

2384
01:18:20,730 --> 01:18:22,770
0,360 360,480 480,1500 1500,1830 1830,2040
start from most recently used

2385
01:18:22,770 --> 01:18:24,680
0,330
one.|

2386
01:18:24,800 --> 01:18:26,120
0,150 150,390 390,600 600,840 840,1320
And think that one first.|
先想一想这一点。|

2387
01:18:27,540 --> 01:18:29,220
0,390 390,630 630,870 870,1350 1350,1680
{} And so we just
因此，我们使用缓冲区的可能性很小，它实际上已将其逐出。

2388
01:18:29,220 --> 01:18:30,540
0,180 180,240 240,630 630,870 900,1320
used the buffer as very

2389
01:18:30,540 --> 01:18:32,460
0,600 600,780 780,870 870,1350 1350,1920
unlikely, that it actually evicted.|
|

2390
01:18:33,540 --> 01:18:34,500
0,540 540,630 630,750 750,810 810,960
Why is that a good
为什么这是个好政策。

2391
01:18:34,500 --> 01:18:35,580
0,600
policy.|
|

2392
01:18:41,610 --> 01:18:44,070
0,630 630,1080 1080,1500 1500,1830 1860,2460
Generally systems obey a temporal
通常情况下，系统服从时间局部性。

2393
01:18:44,070 --> 01:18:46,530
0,690 1110,1650 1710,1950 1950,2190 2190,2460
locality.| Yeah right, so if
|是的，如果挡路是最近用过的，

2394
01:18:46,530 --> 01:18:48,570
0,90 90,390 390,660 1050,1590 1590,2040
the block is recently used,|
|

2395
01:18:48,570 --> 01:18:49,920
0,240 240,600 600,660 660,900 900,1350
it's probably a good indicator
这可能是一个很好的迹象，表明它实际上可能会很快再次被使用。

2396
01:18:49,920 --> 01:18:50,700
0,150 150,210 210,420 420,630 630,780
that it might actually be

2397
01:18:50,700 --> 01:18:52,300
0,240 240,570 570,1080
used again quickly.|
|

2398
01:18:52,390 --> 01:18:53,410
0,270 270,450 450,750 750,810 810,1020
And so it's a good
所以不把它赶出去是个好主意。

2399
01:18:53,410 --> 01:18:54,640
0,330 330,600 600,660 660,990 990,1230
idea not to evict it.|
|

2400
01:18:55,320 --> 01:18:57,030
0,120 120,600 600,960 960,1350 1350,1710
You wanna and it's generally
您想要，通常情况下，即使您有本地缓存位置

2401
01:18:57,030 --> 01:18:58,290
0,180 180,240 240,600 600,840 840,1260
sort of if you even

2402
01:18:58,620 --> 01:19:00,960
0,210 210,510 510,1290 1590,2070 2070,2340
you have locality cache locality|
|

2403
01:19:00,960 --> 01:19:02,010
0,300 300,390 390,660 660,810 810,1050
and the block that is
还有你知道最近最少用到的挡路

2404
01:19:02,010 --> 01:19:05,070
0,120 120,510 630,1500 1590,2790 2790,3060
you know least recently used|
|

2405
01:19:05,070 --> 01:19:06,360
0,330 330,420 420,1050 1050,1140 1140,1290
probably the block that is
可能也是未来最有可能使用的挡路

2406
01:19:06,360 --> 01:19:07,710
0,210 210,540 540,930 930,1050 1050,1350
also most likely to be

2407
01:19:07,710 --> 01:19:09,300
0,300 300,360 360,420 420,960 1110,1590
used in the future| and
|因此，这是一个很好的驱逐。

2408
01:19:09,300 --> 01:19:10,080
0,120 120,360 360,420 420,570 570,780
so that's a good one

2409
01:19:10,080 --> 01:19:11,000
0,90 90,480
to evict.|
|

2410
01:19:12,220 --> 01:19:13,520
0,120 120,210 210,360 360,690
Does that make sense?|
这说得通吗？|

2411
01:19:18,160 --> 01:19:20,260
0,570 810,1560
Okay {}.|
好吧。|

2412
01:19:21,920 --> 01:19:23,990
0,600 660,1380 1410,1650 1650,1890 1890,2070
So, {} let me go
所以，让我回到我的幻灯片上来，

2413
01:19:23,990 --> 01:19:25,280
0,300 300,420 420,720 750,1110 1110,1290
back to my slides here,|
|

2414
01:19:25,280 --> 01:19:27,180
0,450 660,1320
so {},
所以，bcache代码中有一点小偏差，

2415
01:19:27,440 --> 01:19:28,310
0,270 270,420 420,480 480,690 690,870
so there's a little bit

2416
01:19:28,310 --> 01:19:31,310
0,270 270,960 1140,1770 1770,2670 2670,3000
of a slight excursion in

2417
01:19:31,310 --> 01:19:32,420
0,510
the

2418
01:19:32,800 --> 01:19:35,620
0,300 300,1020 1380,1950
{bcache -} code,|
|

2419
01:19:35,770 --> 01:19:38,040
0,480 480,660 660,990 990,1680
or the block cache.|
或者挡路的缓存。|

2420
01:19:40,200 --> 01:19:41,340
0,210 210,270 270,480 480,780 780,1140
There's a couple interesting things
在这一点上有几件有趣的事情需要纠正，

2421
01:19:41,340 --> 01:19:42,270
0,120 120,180 180,540 540,780 780,930
at the point at to

2422
01:19:42,270 --> 01:19:43,230
0,450 450,510 510,630 630,810 810,960
correct,| you know there's this
|你知道有一个不变量，那就是内存中只有一份挡路的副本。

2423
01:19:43,230 --> 01:19:45,150
0,660 660,810 810,1020 1020,1260 1260,1920
invariant that there's only one

2424
01:19:45,330 --> 01:19:46,660
0,810
copy

2425
01:19:47,020 --> 01:19:48,820
0,240 240,600 600,1290
of {a,block,in} memory.|
|

2426
01:19:50,840 --> 01:19:52,250
0,180 180,300 300,390 390,810 810,1410
And as an important variant
作为挡路缓存必须维护的重要变量，

2427
01:19:52,280 --> 01:19:53,660
0,240 330,660 660,750 750,1230 1230,1380
that must be maintained by

2428
01:19:53,660 --> 01:19:54,920
0,360 360,600 600,750 750,1080 1080,1260
block cache,| it has these
|它有这些睡眠锁，和我们以前见过的不同类型的锁，

2429
01:19:54,920 --> 01:19:56,510
0,390 390,870 900,1140 1140,1410 1410,1590
sleep locks, are different types

2430
01:19:56,510 --> 01:19:57,890
0,90 90,630 630,960 960,1140 1140,1380
of locks than the ones

2431
01:19:57,890 --> 01:19:59,720
0,90 90,270 270,450 450,1050 1620,1830
that we've seen before,| that
|它可以跨越实现LRU的IO操作，

2432
01:19:59,720 --> 01:20:01,820
0,90 90,450 450,810 810,1590 1920,2100
can span IO operations that

2433
01:20:01,820 --> 01:20:03,320
0,540 540,660 660,960 960,1110 1110,1500
implements you know {LRU -},|
|

2434
01:20:03,350 --> 01:20:05,630
0,360 360,750 750,1170 1170,1620 1620,2280
least recently catching replacement policy,|
最近最少捕获替换策略，|

2435
01:20:05,840 --> 01:20:07,610
0,270 270,330 330,570 570,1560 1590,1770
need to have these two
需要有这两个级别的锁定，

2436
01:20:07,610 --> 01:20:09,300
0,450 450,630 630,1170
levels of locking,|
|

2437
01:20:09,540 --> 01:20:11,220
0,990
to,
在其实现中，为了基本上保护BCACHE内部数据结构的一级，

2438
01:20:11,370 --> 01:20:13,440
0,600 900,1050 1050,1200 1200,1800 1800,2070
{} in its implementation, one

2439
01:20:13,440 --> 01:20:14,730
0,330 330,540 540,900 900,1230 1230,1290
level to basically protect the

2440
01:20:14,730 --> 01:20:16,560
0,150 150,510 510,960 960,1200 1200,1830
{bcache -} internal data structures,|
|

2441
01:20:16,860 --> 01:20:17,730
0,180 180,300 300,540 540,780 780,870
and then one level of
然后通过休眠锁定进行一级锁定，以实际锁定各个缓冲区。

2442
01:20:17,730 --> 01:20:19,050
0,390 390,600 600,900 900,1200 1200,1320
locking through sleep locks to

2443
01:20:19,050 --> 01:20:22,140
0,540 570,1380 1380,2160 2160,2670
actually lock individual buffers.|
|

2444
01:20:24,010 --> 01:20:25,140
0,630

2445
01:20:26,570 --> 01:20:27,940
0,240 240,330 330,450 450,840
Does that make sense?|
这说得通吗？|

2446
01:20:29,230 --> 01:20:30,920
0,480 510,1140
Okay, {}.|
好的，..。|

2447
01:20:32,200 --> 01:20:33,280
0,150 150,270 270,720 750,990 990,1080
I'm going to run out
我的时间快用完了，所以让我停在这里，

2448
01:20:33,280 --> 01:20:34,810
0,60 60,330 330,450 450,870 870,1530
of time, so let me

2449
01:20:34,810 --> 01:20:36,700
0,330 330,780 1080,1530 1530,1650 1650,1890
stop here,| {} you know
|你知道很快总结了我们到目前为止所看到的

2450
01:20:36,820 --> 01:20:38,560
0,330 330,960 960,1080 1080,1560 1560,1740
quickly summarized what we've seen

2451
01:20:38,560 --> 01:20:39,400
0,150 150,420 420,600 600,690 690,840
so far| and we're going
|我们将于周三前往，我们将真正关注撞车安全问题，

2452
01:20:39,400 --> 01:20:40,240
0,390 390,510 510,600 600,720 720,840
Wednesday and we're going to

2453
01:20:40,270 --> 01:20:42,970
0,450 450,690 690,1080 1080,1800 2130,2700
focus really on crash safety,|
|

2454
01:20:43,210 --> 01:20:44,620
0,210 210,720 720,810 810,1020 1050,1410
so basically you know file
基本上，您知道文件系统在此数据结构上。

2455
01:20:44,620 --> 01:20:45,940
0,420 510,690 690,900 900,1080 1080,1320
system is on this data

2456
01:20:45,940 --> 01:20:46,920
0,630
structure.|
|

2457
01:20:47,410 --> 01:20:48,610
0,540 540,840 840,900 900,960 960,1200
Basically, most of the lecture
基本上，今天演讲的大部分时间，我们都集中在此数据结构上的布局

2458
01:20:48,610 --> 01:20:50,050
0,270 270,570 570,1080 1080,1320 1320,1440
today, we're focusing on the

2459
01:20:50,050 --> 01:20:51,520
0,630 660,870 870,1050 1080,1260 1260,1470
layout of the on this

2460
01:20:51,520 --> 01:20:53,620
0,300 300,720 750,1080 1320,1560 1710,2100
data structure| of the {xv6
|对于xv6，您知道磁盘上的这个数据结构

2461
01:20:53,620 --> 01:20:55,870
0,630 780,1050 1050,1350 1350,1620 1620,2250
-} {you,know} this data structure

2462
01:20:55,930 --> 01:20:57,640
0,390 390,780 780,1380 1410,1530 1530,1710
on disk| and you know
|你知道我们看到xv6有一个非常简单的。

2463
01:20:57,640 --> 01:20:58,720
0,330 330,600 600,870 870,1050 1050,1080
{we,saw} {xv6 -} has a

2464
01:20:58,720 --> 01:21:00,180
0,270 270,570 570,990
very simple one.|
|

2465
01:21:04,480 --> 01:21:05,680
0,330 330,450 450,540 540,990 990,1200
But you can imagine like
但是你可以想象一下，你知道要实现更复杂的

2466
01:21:05,680 --> 01:21:07,300
0,60 60,150 150,570 570,780 780,1620
you know implementing more complicated

2467
01:21:07,300 --> 01:21:08,530
0,300 630,900 900,960 960,1110 1110,1230
one| and the other thing
|我们花了很多时间研究的另一件事是这个挡路的藏品，

2468
01:21:08,530 --> 01:21:09,640
0,120 120,360 360,720 720,840 840,1110
that we spend much time

2469
01:21:09,640 --> 01:21:10,540
0,240 240,390 390,510 510,660 660,900
looking at is this block

2470
01:21:10,540 --> 01:21:11,860
0,300 300,510 510,660 660,1170 1170,1320
cache,| which is crucial for
|这对性能至关重要，

2471
01:21:11,860 --> 01:21:14,050
0,660 900,1200 1200,1470 1470,1590 1590,2190
performance,| because reading and writing
|因为通常对盘的读取和写入实际上是昂贵的，

2472
01:21:14,050 --> 01:21:15,460
0,480 480,660 660,990 990,1110 1110,1410
typically to disk is actually

2473
01:21:15,460 --> 01:21:16,960
0,690 720,810 810,1170 1170,1350 1350,1500
expensive,| you know we're there
|你知道我们在那里有几百微秒到几毫秒的时间

2474
01:21:16,960 --> 01:21:18,370
0,360 390,750 750,810 810,1080 1080,1410
for hundreds of {microseconds -}

2475
01:21:18,370 --> 01:21:20,290
0,120 120,960 1170,1590 1590,1650 1650,1920
to milliseconds| and the block
|挡路缓存基本上可以确保，如果最近从磁盘读取了挡路，

2476
01:21:20,290 --> 01:21:22,660
0,240 240,570 570,1080 1080,1380 1740,2370
cache basically ensures that, you

2477
01:21:22,780 --> 01:21:23,800
0,270 270,540 540,600 600,900 900,1020
know if a block was

2478
01:21:23,800 --> 01:21:25,450
0,660 690,1110 1110,1200 1200,1290 1290,1650
recently read from the disk,|
|

2479
01:21:25,450 --> 01:21:26,590
0,360 360,570 570,780 780,990 990,1140
we're actually not reading it
我们实际上不会再从磁盘中读取它。

2480
01:21:26,590 --> 01:21:27,840
0,330 330,540 540,600 600,990
again from the disk.|
|

2481
01:21:28,620 --> 01:21:30,750
0,480 510,660 660,960 990,1620 1710,2130
Okay, and then Wednesday, {}
好的，然后是周三，我要谈的是撞车安全，

2482
01:21:30,750 --> 01:21:31,560
0,120 120,240 240,300 300,450 450,810
I'm going to talk about

2483
01:21:31,620 --> 01:21:33,080
0,450 450,840
crash safety,|
|

2484
01:21:33,890 --> 01:21:36,230
0,330 330,540 540,690 690,990 1350,2340
{} which is a fascinating
这是文件系统设计的另一个吸引人的方面，

2485
01:21:36,440 --> 01:21:38,060
0,360 360,600 600,1230 1260,1380 1380,1620
{} other aspect of file

2486
01:21:38,060 --> 01:21:39,290
0,270 270,660 660,750 750,1050 1050,1230
system design,| in fact we'll
|事实上，我们将花两堂课来讲解撞车安全问题。

2487
01:21:39,290 --> 01:21:40,580
0,270 270,480 480,870 870,990 990,1290
spend two lectures on crash

2488
01:21:40,580 --> 01:21:41,660
0,540
safety.|
|

2489
01:21:41,660 --> 01:21:43,220
0,300 300,630 630,720 720,1110 1110,1560
We'll see a logging design
我们将在周三看到一个很慢的伐木设计

2490
01:21:43,220 --> 01:21:44,570
0,240 240,570 570,750 750,1260 1260,1350
on Wednesday that's slow| and
|下周我们将了解Linuxext3是如何进行日志记录的

2491
01:21:44,570 --> 01:21:45,500
0,150 150,360 360,600 600,750 750,930
then next week we'll look

2492
01:21:45,500 --> 01:21:47,390
0,180 180,660 660,1080 1080,1530 1530,1890
at how Linux {ext3 -}

2493
01:21:47,390 --> 01:21:48,920
0,480 480,960 1080,1350 1350,1440 1440,1530
does logging| which is a
|这是一个更快的方案。

2494
01:21:48,920 --> 01:21:50,920
0,210 210,390 390,1050 1050,1410
much more faster scheme.|
|

2495
01:21:51,620 --> 01:21:52,280
0,180 180,330 330,390 390,480 480,660
{} If you have any
如果你有任何其他问题要问，我很乐意回答，

2496
01:21:52,280 --> 01:21:53,750
0,210 210,570 570,750 750,1320 1320,1470
other questions feel [] to

2497
01:21:53,750 --> 01:21:55,460
0,240 240,780 810,1200 1200,1380 1380,1710
hang around and I'm happy

2498
01:21:55,460 --> 01:21:57,140
0,300 300,600 600,900 900,1590 1590,1680
to answer them,| otherwise you
|否则你知道，周三见。

2499
01:21:57,140 --> 01:21:57,940
0,240
know,

2500
01:21:58,000 --> 01:21:59,700
0,390 390,540 540,1080
see you Wednesday.|
|

2501
01:22:02,160 --> 01:22:03,880
0,300 300,480 480,840
Alright, thank you.|
好的，谢谢。|

2502
01:22:04,370 --> 01:22:05,810
0,420 480,690 690,900 900,990 990,1440
{} I have a question
我有一个关于Brelse的问题。

2503
01:22:05,810 --> 01:22:08,140
0,600 600,840 840,1830
about {brelse -}.|
|

2504
01:22:08,330 --> 01:22:09,380
0,480
Yes.|
是。|

2505
01:22:09,640 --> 01:22:12,190
0,450 450,1110 1170,1650 1650,2100 2100,2550
{} So it seems like
所以它看起来就像是释放了块锁

2506
01:22:12,250 --> 01:22:15,460
0,360 360,990 990,1380 1380,2340 2460,3210
it releases the blocks lock|
|

2507
01:22:15,520 --> 01:22:18,310
0,210 210,510 510,900 930,1380 1650,2790
and after that it modifies
在此之后，它修改参考计数。

2508
01:22:18,490 --> 01:22:20,720
0,210 210,480 480,1110 1230,1830
the ref count.| Um.|
|恩。|

2509
01:22:21,180 --> 01:22:23,340
0,510 510,660 660,840 840,1470 1710,2160
Why is that OK.| Yeah,
为什么这样可以。|是啊，问得好。

2510
01:22:23,370 --> 01:22:24,460
0,570
{good,question}.|
|

2511
01:22:25,580 --> 01:22:26,750
0,180 180,330 330,390 390,510 510,1170
So what do we, know
所以我们，知道，你知道，所以假设我们确实释放了睡眠锁，

2512
01:22:26,930 --> 01:22:27,980
0,240 240,510 510,660 660,900 900,1050
you know, so let's say

2513
01:22:27,980 --> 01:22:29,000
0,150 150,330 330,630 630,720 720,1020
we do release the sleep

2514
01:22:29,000 --> 01:22:30,290
0,510 570,870 870,1020 1020,1170 1170,1290
lock,| {} so if some
|所以如果其他人或其他程序真的在等待，

2515
01:22:30,290 --> 01:22:32,360
0,180 180,780 1410,1740 1740,1860 1860,2070
other guy or some other

2516
01:22:32,360 --> 01:22:34,490
0,390 390,900 900,1350 1350,1560 1560,2130
process actually {}  was waiting,|
|

2517
01:22:34,490 --> 01:22:35,870
0,210 210,420 420,600 600,1050 1050,1380
or what doing acquire sleep
或者做什么来获得睡眠锁，

2518
01:22:35,870 --> 01:22:37,010
0,390 420,720 720,900 900,1020 1020,1140
lock,| {} what does that
|这是什么意思，关于裁判数量。

2519
01:22:37,010 --> 01:22:38,180
0,240 240,450 450,540 540,720 720,1170
mean about the ref count.|
|

2520
01:22:41,300 --> 01:22:44,320
0,420 420,570 570,1290 1320,2340
That it was zero.|
它是零。|

2521
01:22:45,230 --> 01:22:47,630
0,1140 1140,1470 1470,1590 1590,1950 1950,2400
No correct, so if n
不正确，因此如果n个进程正在等待缓冲区。

2522
01:22:47,630 --> 01:22:49,730
0,570 570,690 690,1080 1080,1620 1620,2100
processes are waiting for a

2523
01:22:49,730 --> 01:22:53,360
0,600 750,2370 2490,2730 2730,3120
buffer.| {Oh,okay}, [check out].|
|哦，好的，[结账]。|

2524
01:22:54,390 --> 01:22:56,670
0,270 270,630 660,870 870,1500 1740,2280
There was a {at,least} one.|
至少有一个。|

2525
01:22:57,290 --> 01:22:58,580
0,330 330,570 570,810 810,1080 1080,1290
Yeah, more than one, correct,|
是的，不止一个，对吧，|

2526
01:22:58,580 --> 01:22:59,750
0,60 60,300 300,600 600,750 750,1170
if ten process you're waiting
如果您正在等待10个进程，则引用可以是10个。

2527
01:22:59,750 --> 01:23:00,500
0,120 120,210 210,390 390,630 630,750
in, the reference can be

2528
01:23:00,500 --> 01:23:01,460
0,360
ten.|
|

2529
01:23:01,640 --> 01:23:03,320
0,540 570,1170
Yeah, okay.|
好的，好的。|

2530
01:23:03,380 --> 01:23:06,140
0,480 480,1110 1320,2190 2190,2370 2370,2760
And so, {} is this
那么，这是唯一的一行代码吗

2531
01:23:06,140 --> 01:23:07,190
0,330 330,540 540,780 780,990 990,1050
only this only line of

2532
01:23:07,190 --> 01:23:08,090
0,270 270,390 390,480 480,810 810,900
code| what it does is
|它所做的基本上就是更新一个人的裁判计数

2533
01:23:08,090 --> 01:23:09,380
0,390 390,510 510,960 960,1050 1050,1290
basically it updates the ref

2534
01:23:09,380 --> 01:23:10,760
0,270 270,390 390,570 570,870 870,1380
count for just one guy|
|

2535
01:23:10,790 --> 01:23:11,870
0,120 120,210 210,450 450,900 900,1080
which is one process that
这是一个实际执行发布的进程

2536
01:23:11,870 --> 01:23:13,010
0,240 240,390 390,450 450,990 990,1140
actually did the release| and
|并且它将REF_REF计数减少到1。

2537
01:23:13,010 --> 01:23:14,270
0,210 210,630 630,690 690,1020 1020,1260
it reduces the ref ref

2538
01:23:14,270 --> 01:23:16,160
0,240 240,600 630,960 960,1350
count to by one.|
|

2539
01:23:16,490 --> 01:23:17,990
0,480 660,870 870,1080 1080,1350 1350,1500
And if other people were
如果其他人在等待，而且从来没有裁判次数肯定不是零的话就行了，

2540
01:23:17,990 --> 01:23:20,120
0,510 630,780 780,1440 1470,1860 1860,2130
waiting and never {ref,count} was

2541
01:23:20,120 --> 01:23:21,380
0,330 330,570 570,960 960,1110 1110,1260
definitely not zero will do,|
|

2542
01:23:21,380 --> 01:23:22,610
0,210 210,390 390,690 690,1080 1080,1230
it will never execute this
它永远不会执行此代码。

2543
01:23:22,610 --> 01:23:23,460
0,360
code.|
|

2544
01:23:25,640 --> 01:23:28,130
0,510 540,1140 1500,1890 1890,1890 1890,2490
OK?| OK, OK I see,
好的?|好的，好的，我明白了，我我想我明白了。

2545
01:23:28,160 --> 01:23:29,390
0,150 150,360 360,900 900,990 990,1230
I I think I see

2546
01:23:29,390 --> 01:23:30,380
0,420
okay.|
|

2547
01:23:30,380 --> 01:23:32,360
0,570 660,1050 1050,1380 1380,1620 1620,1980
A rather question was why
一个颇有问题的问题是，为什么两个比特对于索引节点号来说是足够的。

2548
01:23:32,360 --> 01:23:34,120
0,600 660,1200
is {}

2549
01:23:34,460 --> 01:23:37,010
0,720 720,1020 1020,1710 1980,2340 2340,2550
{why,is} two bits to by

2550
01:23:37,010 --> 01:23:39,500
0,540 540,840 840,1170 1170,1650 1650,2490
enough for {inode -} number.|
|

2551
01:23:39,590 --> 01:23:41,420
0,300 300,840
It's not,
它不是，它小得离谱，对吧，

2552
01:23:41,450 --> 01:23:43,310
0,210 210,600 630,1110 1110,1500 1500,1860
it's {} ridiculously small, correct,|
|

2553
01:23:43,520 --> 01:23:45,020
0,780 780,870 870,1110 1110,1380 1380,1500
because how many inodes can
因为您可以拥有多少个索引节点。

2554
01:23:45,020 --> 01:23:46,160
0,90 90,450
you have.|
|

2555
01:23:46,800 --> 01:23:48,330
0,510 600,930 930,1080 1080,1200 1200,1530
{} Two to the power
2的8次方。

2556
01:23:48,330 --> 01:23:49,520
0,180 180,690
of eight.|
|

2557
01:23:49,520 --> 01:23:52,850
0,480 510,900 900,2070 2250,2880 2880,3330
Yeah, yeah yeah yeah, whatever
是啊，随便两个字节。

2558
01:23:52,850 --> 01:23:56,240
0,150 150,480 720,1770 1770,2010 2790,3390
two byte.| Sixteen bit.| Sixteen
十六位。|一万六千|三百一十三个，三万二千个伊诺德。

2559
01:23:56,570 --> 01:23:58,310
0,780 810,1140 1140,1290 1290,1560 1560,1740
thirteen, thirty two thousand {inodes

2560
01:23:58,310 --> 01:23:59,220
0,330
-}.|
|

2561
01:23:59,540 --> 01:24:00,290
0,180 180,210 210,420 420,420 420,750
That's a lot {inode -}
对于20世纪60年代或60年代和70年代来说，这是一个很大的inode，

2562
01:24:00,290 --> 01:24:02,150
0,570 570,870 870,1590 1620,1770 1770,1860
for nineteen sixties or the

2563
01:24:02,150 --> 01:24:03,650
0,330 330,450 450,1050 1080,1320 1320,1500
sixties and seventies,| {} but
|但对今天来说肯定是不够的。

2564
01:24:03,650 --> 01:24:04,910
0,330 330,510 510,750 750,870 870,1260
certainly would not be sufficient

2565
01:24:04,910 --> 01:24:05,920
0,90 90,450
for today.|
|

2566
01:24:06,700 --> 01:24:08,440
0,450 450,720 720,1230 1260,1560 1560,1740
And so, {} today's file
因此，今天的文件系统使用更大的数字或更多的位。

2567
01:24:08,440 --> 01:24:09,760
0,360 360,540 540,570 570,840 840,1320
systems use a bigger number

2568
01:24:09,880 --> 01:24:11,680
0,240 240,480 480,810 810,1230
or {} more bits.|
|

2569
01:24:12,140 --> 01:24:13,380
0,720
Okay.|
好吧。|

2570
01:24:13,380 --> 01:24:14,400
0,90 90,420 420,720 720,900 900,1020
I see I guess my
我明白了，我想我的问题是关于xv6的架构，

2571
01:24:14,400 --> 01:24:16,770
0,240 240,570 690,870 870,1380 1560,2370
question was in the architecture

2572
01:24:16,770 --> 01:24:18,800
0,180 180,270 270,660 660,1440
that we have for

2573
01:24:18,860 --> 01:24:20,840
0,420 420,900 900,1380
{xv6 -} {},|
|

2574
01:24:20,930 --> 01:24:23,480
0,660 780,1200 1200,1560 1590,2280 2280,2550
the those two sixteen bit
这两个16位的信息节点就像他们在哪里做的一样，

2575
01:24:23,480 --> 01:24:26,150
0,450 480,1200 1680,1920 1920,2400 2400,2670
for inodes like where where

2576
01:24:26,150 --> 01:24:28,340
0,360 360,510 510,930 1170,1680 1950,2190
else do they,| {} where
|我们还能在哪里看到这个数字出现。

2577
01:24:28,340 --> 01:24:28,940
0,150 150,270 270,360 360,450 450,600
else can we see this

2578
01:24:28,940 --> 01:24:30,020
0,570
number

2579
01:24:30,020 --> 01:24:31,180
0,300 300,660
show up.|
|

2580
01:24:31,490 --> 01:24:33,080
0,480 480,690 690,1140 1140,1200 1200,1590
{} Well the the one
两个字节的那个实际上在磁盘上，而不是两个字节。

2581
01:24:33,080 --> 01:24:35,090
0,120 120,510 510,900 900,1560 1770,2010
that is two bytes is

2582
01:24:35,090 --> 01:24:36,980
0,300 300,1200 1200,1620 1620,1770 1770,1890
really on disk than it

2583
01:24:36,980 --> 01:24:38,360
0,180 180,330 330,840
is two bytes.|
|

2584
01:24:38,420 --> 01:24:41,390
0,630 630,960 960,1920 1920,2430 2460,2970
{} Any number in {}
当它位于寄存器或内存中时，编译时输入的任何数字。

2585
01:24:41,870 --> 01:24:43,820
0,390 390,480 480,1200 1200,1590 1590,1950
when it's compiled when it's

2586
01:24:43,820 --> 01:24:45,080
0,240 240,330 330,420 420,990 990,1260
sitting in a register or

2587
01:24:45,080 --> 01:24:46,580
0,240 240,360 360,960
sit in memory.|
|

2588
01:24:46,580 --> 01:24:49,130
0,1050 1110,1770 1770,1950 1950,2190 2190,2550
{} The disk inode is,|
盘索引节点是，|

2589
01:24:49,160 --> 01:24:51,740
0,720 960,1680 1680,1770 1770,2010
{} look at it,
你看，让我看看，

2590
01:24:54,040 --> 01:24:56,020
0,300 300,810 810,1470
{} let's see,|
|

2591
01:24:56,170 --> 01:24:57,790
0,180 180,510 510,690 690,1230 1260,1620
so this disk inode as
因此，正如我们之前所说的，这个磁盘索引节点实际上是，

2592
01:24:57,790 --> 01:24:59,590
0,120 120,300 300,780 780,1260 1260,1800
we said before actually the,|
|

2593
01:25:03,900 --> 01:25:05,130
0,240 240,300 300,750 750,840 840,1230
use a directory {entry -}
使用我们所说的在[短]内的目录项

2594
01:25:05,130 --> 01:25:06,360
0,300 330,450 450,630 630,750 750,1230
where we say is inside

2595
01:25:06,360 --> 01:25:07,680
0,480 510,630 630,930 930,1170 1170,1320
[short]| and others there's two
|而另一些则是两个字节的十六位，

2596
01:25:07,680 --> 01:25:09,400
0,330 330,750 750,1200
byte sixteen bits,|
|

2597
01:25:09,520 --> 01:25:11,980
0,510 510,750 750,1410 1410,2250 2250,2460
{} the in-memory representation of
索引节点的内存中表示形式。

2598
01:25:11,980 --> 01:25:13,340
0,120 120,240 240,810
an {inode -}.|
|

2599
01:25:13,540 --> 01:25:16,660
0,1110 1140,1980 1980,2370 2370,2700 2700,3120
{} {You,know}, okay, that's in,
你知道，好的，这是在，你在内存中表示一个索引节点，

2600
01:25:18,910 --> 01:25:20,710
0,270 270,510 510,1050 1050,1710 1710,1800
you're doing in-memory representation of

2601
01:25:20,710 --> 01:25:21,940
0,300 300,690
an inode,|
|

2602
01:25:21,940 --> 01:25:24,520
0,300 300,660 660,1080 1080,1650 1680,2580
that actually number is {
这个数字实际上是整数

2603
01:25:25,400 --> 01:25:27,620
0,720 720,1440 1440,1980 1980,2100 2100,2220
-} integer| and you know
|你知道我们编译C代码的方式

2604
01:25:27,620 --> 01:25:29,750
0,90 90,300 300,450 450,1170 1470,2130
the way we compile {C,code}|
|

2605
01:25:29,750 --> 01:25:30,950
0,120 120,360 360,810 810,1140 1140,1200
and integer {} happens to
而整数恰好是四个字节。

2606
01:25:30,950 --> 01:25:32,240
0,150 150,360 360,810
be four bytes.|
|

2607
01:25:34,480 --> 01:25:36,700
0,600 630,1170 1170,1440 1440,1860 1890,2220
Okay, okay I see, thank
好的，好的，我明白了，谢谢，非常感谢。

2608
01:25:36,700 --> 01:25:38,050
0,540 570,750 750,810 810,960 960,1350
you, thank you so much.
