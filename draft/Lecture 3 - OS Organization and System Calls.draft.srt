1
00:00:07,260 --> 00:00:08,310
0,420 480,720 720,750 750,990 990,1050
Yeah, am I loud and
我说话清楚吗？

2
00:00:08,310 --> 00:00:09,360
0,480
clear?|

3
00:00:09,710 --> 00:00:12,920
0,1200 1560,1830 1830,2130 2520,2940 2940,3210
Yeah.| Okay, great.| {} So
是的。|好的，很好。|大家下午好，傍晚好，早上好，晚上好，

4
00:00:12,920 --> 00:00:14,180
0,210 210,630 630,750 750,900 900,1260
good afternoon or good evening

5
00:00:14,180 --> 00:00:15,380
0,180 180,330 330,720 720,990 1020,1200
or good morning or good

6
00:00:15,380 --> 00:00:18,290
0,210 210,480 480,630 630,1080 2250,2910
night,| wherever you are.| Let's
|不管你在哪里。|让我们开始学习 6.S081 的第三节课，

7
00:00:18,290 --> 00:00:20,660
0,270 270,570 570,720 720,1140 2160,2370
get started on the third

8
00:00:20,660 --> 00:00:22,550
0,360 360,840 840,1080 1080,1470 1470,1890
lecture in {6.S081 -},| which
|它是关于操作系统结构的。

9
00:00:22,550 --> 00:00:23,420
0,60 60,180 180,240 240,390 390,870
is going to be about

10
00:00:23,420 --> 00:00:25,200
0,390 390,540 540,1230
{OS -} organization.|

11
00:00:25,400 --> 00:00:27,040
0,480 510,1050
And, {
今天我要讲的主题分为四个内容，

12
00:00:27,040 --> 00:00:29,530
0,60 60,690 960,1200 1200,1920 1920,2490
-} topics for today are

13
00:00:29,800 --> 00:00:31,040
0,630
{}

14
00:00:32,170 --> 00:00:33,970
0,900 1140,1530 1530,1620 1620,1680 1680,1800
four things that I want

15
00:00:33,970 --> 00:00:35,080
0,60 60,360 360,630 630,930 930,1110
to touch on.| One is
|第一个是隔离，

16
00:00:35,080 --> 00:00:36,480
0,840
isolation,|
|

17
00:00:36,510 --> 00:00:37,800
0,240 240,390 390,750 750,870 870,1290
which you'll see is the
这是由操作系统结构设计目标驱动的。

18
00:00:38,220 --> 00:00:41,340
0,720 720,1110 1110,1680 1950,2640 2640,3120
driving design goal for OS

19
00:00:41,340 --> 00:00:42,960
0,810 990,1230 1230,1380 1380,1410 1410,1620
organization.| I'll talk a little
|我会讲一下内核模式和用户模式，

20
00:00:42,960 --> 00:00:44,820
0,120 120,540 600,1260 1260,1500 1530,1860
bit about kernel and user

21
00:00:44,820 --> 00:00:45,920
0,540
mode,|
|

22
00:00:47,380 --> 00:00:49,240
0,180 180,270 270,600 600,960 960,1860
that's a way of isolating
这是内核或操作系统与用户程序隔离的一种方式。

23
00:00:49,240 --> 00:00:50,440
0,90 90,630 630,1020 1020,1110 1110,1200
the kernel from or the

24
00:00:50,440 --> 00:00:52,930
0,360 360,750 750,1200 1230,1620 1620,2490
operating system from user applications.|
|

25
00:00:53,400 --> 00:00:54,330
0,300 300,480 480,570 570,750 750,930
{} Then we'll talk about
然后我们讨论一下系统调用，

26
00:00:54,330 --> 00:00:55,740
0,300 300,930
system calls,|
|

27
00:00:55,800 --> 00:00:57,540
0,180 180,300 300,390 390,990 1020,1740
which is a way for
它是用户程序访问内核的一种方式。

28
00:00:57,900 --> 00:01:00,390
0,510 510,1320 1320,1530 1530,1890 1890,2490
user applications to basically transition

29
00:01:00,390 --> 00:01:02,010
0,270 270,360 360,930 1020,1410 1410,1620
into the kernel,| {} so
|让用户程序可以访问服务，

30
00:01:02,010 --> 00:01:03,180
0,120 120,240 240,450 450,540 540,1170
they can ask for services|
|

31
00:01:03,360 --> 00:01:04,230
0,270 270,360 360,570 570,660 660,870
and we look a little
而且我们研究一下在 xv6 中是怎样实现这种[简单]形式的。

32
00:01:04,230 --> 00:01:06,150
0,180 180,360 360,510 510,1020 1020,1920
bit how there's always instantiated

33
00:01:06,150 --> 00:01:07,830
0,120 120,180 180,510 510,1080 1170,1680
in a [simple] form {}

34
00:01:07,830 --> 00:01:10,020
0,450 450,660 660,1650 1680,1980 2010,2190
inside of xv6.| So that
|这些就是今天的重点。

35
00:01:10,020 --> 00:01:11,400
0,180 180,450 480,840 840,1080 1080,1380
is the point {for,today -}.|
|

36
00:01:12,160 --> 00:01:14,980
0,600 1350,2010 2190,2400 2400,2610 2610,2820
{} And you're still rethought
你还记得，

37
00:01:14,980 --> 00:01:17,830
0,210 480,1320 1320,1800 1830,2730 2730,2850
of,| remind you where we
|回忆一下第一节课的内容。

38
00:01:17,830 --> 00:01:20,830
0,1650 1770,2100 2100,2190 2190,2490 2490,3000
were after the first lecture.|
|

39
00:01:21,370 --> 00:01:22,690
0,300 300,510 540,1050 1050,1170 1170,1320
{} The picture in your
你脑海中的画面，

40
00:01:22,690 --> 00:01:23,680
0,390 390,510 510,660 660,810 810,990
head, that you should have

41
00:01:23,680 --> 00:01:24,850
0,60 60,180 180,420 420,690 990,1170
in your head| is you
|这里有一些进程，

42
00:01:24,850 --> 00:01:26,620
0,120 120,480 720,930 930,1620 1620,1770
know there are processes,| like
|比如 shell echo 或其他东西，比如 find ，

43
00:01:26,620 --> 00:01:29,560
0,90 90,750 1020,1590 1590,2430
the shell, like echo,

44
00:01:29,590 --> 00:01:30,920
0,750
{}

45
00:01:30,920 --> 00:01:33,080
0,420 450,630 630,720 720,1260 1380,2160
or you know whatever {}

46
00:01:34,300 --> 00:01:35,680
0,480 480,1020 1020,1140 1140,1290 1290,1380
find,| whatever they're some of
|无论你实现的任何程序，

47
00:01:35,680 --> 00:01:37,030
0,60 60,630 630,750 750,930 930,1350
the utilities that you {implemented

48
00:01:37,030 --> 00:01:38,440
0,270 690,900 900,1080 1080,1320 1320,1410
-},| {} they're running on
|它们运行在操作系统之上。

49
00:01:38,440 --> 00:01:40,810
0,630 720,1320 1320,1380 1380,1770 1770,2370
top of an operating system.|
|

50
00:01:42,520 --> 00:01:43,690
0,450 480,540 540,750 750,810 810,1170
And you know the operating
操作系统对硬件资源进行抽象，

51
00:01:43,690 --> 00:01:44,770
0,330 330,420 420,900 900,990 990,1080
system {abstracts -}, you know

52
00:01:44,770 --> 00:01:46,270
0,150 150,240 240,300 300,690 690,1500
some of the hardware resources,|
|

53
00:01:46,810 --> 00:01:48,850
0,390 390,450 450,1020 1050,1260 1260,2040
like {} disk or CPU,|
比如磁盘或 CPU ，|

54
00:01:49,330 --> 00:01:51,340
0,540 570,1140 1140,1260 1260,1710 1710,2010
and basically the interface between
操作系统和 shell 之间的接口通常与系统调用接口有关，

55
00:01:51,340 --> 00:01:53,260
0,90 90,450 450,960 960,1410 1440,1920
the operating systems and shells

56
00:01:53,260 --> 00:01:54,400
0,510 510,840 840,960 960,1080 1080,1140
typically referred to as a

57
00:01:54,400 --> 00:01:56,350
0,240 240,420 420,990 1140,1830 1830,1950
system call interface,| interface that
|我们考虑的接口是 Unix 接口。

58
00:01:56,350 --> 00:01:57,700
0,120 120,270 270,510 510,870 1080,1350
we've been looking at is

59
00:01:57,700 --> 00:01:59,440
0,360 360,720 720,1350
{} Unix interface.|
|

60
00:02:01,680 --> 00:02:03,180
0,450 450,690 690,870 870,960 960,1500
And here what we see
这里我们要看的是，

61
00:02:05,020 --> 00:02:06,670
0,810 870,1080 1080,1200 1200,1320 1320,1650
is,| {} so that was
|你们差不多都用过 Unix 接口，

62
00:02:06,760 --> 00:02:08,530
0,570 570,660 660,870 870,1380 1410,1770
roughly you know actually with

63
00:02:08,530 --> 00:02:10,150
0,210 210,450 450,1140 1170,1470 1470,1620
that Unix interface,| you've been
|在实验一 util 实验中，

64
00:02:10,150 --> 00:02:11,650
0,240 240,630 630,810 810,1080 1080,1500
playing around in lab one,

65
00:02:11,920 --> 00:02:13,750
0,480 480,1080 1080,1170 1170,1560 1560,1830
{} where in util lab,|
|

66
00:02:13,750 --> 00:02:15,070
0,600 600,690 690,840 840,1050 1050,1320
{you,used} you know the system
你使用系统调用接口或 Unix API 实现不同的应用程序。

67
00:02:15,070 --> 00:02:16,930
0,120 120,720 720,870 870,1230 1230,1860
call interface or Unix API

68
00:02:16,930 --> 00:02:18,100
0,120 120,390 390,750 750,1020 1020,1170
to actually implement different sets

69
00:02:18,100 --> 00:02:19,340
0,90 90,900
of applications.|
|

70
00:02:19,450 --> 00:02:21,520
0,240 240,660 720,1080 1080,1620 1710,2070
And so lab one {},
所以实验一 util 实验使用的是这张图片中的这一部分。

71
00:02:21,520 --> 00:02:22,780
0,330 330,480 480,570 570,870 870,1260
util lab is mostly focused

72
00:02:22,780 --> 00:02:25,060
0,420 600,1800 1800,1950 1950,2070 2070,2280
on using you know this

73
00:02:25,060 --> 00:02:26,120
0,510
part

74
00:02:26,120 --> 00:02:27,800
0,660 660,780 780,990 990,1410 1410,1680
{} of the design picture

75
00:02:27,800 --> 00:02:29,180
0,390 540,930 930,1110 1110,1260 1260,1380
here.| And what we're going
|我们现在要做的是，

76
00:02:29,180 --> 00:02:30,770
0,120 120,270 270,600 600,1110 1110,1590
to be doing now,| in
|在第一节课或这节课以及后面的课程中，

77
00:02:30,770 --> 00:02:32,120
0,150 150,420 420,930 930,1140 1140,1350
this first lecture or this

78
00:02:32,120 --> 00:02:33,740
0,330 330,450 450,750 750,1230 1230,1620
lecture and many subsequent lectures,|
|

79
00:02:33,830 --> 00:02:35,900
0,390 390,690 690,1140 1380,1710 1710,2070
we really look actually how
我们研究这些接口是怎样实现的。

80
00:02:35,900 --> 00:02:37,790
0,270 330,870 870,960 960,1260 1260,1890
the interface is actually implemented.|
|

81
00:02:38,260 --> 00:02:39,220
0,240 240,300 300,540 540,810 810,960
And in fact almost all
实际上，这学期的大部分课程，

82
00:02:39,220 --> 00:02:40,120
0,90 90,180 180,630 630,840 840,900
of the semester,| we'll be
|我们花实验弄清楚怎样实现接口，

83
00:02:40,120 --> 00:02:42,640
0,570 600,1230 1230,1680 1710,2160 2160,2520
spending time on {} figuring

84
00:02:42,640 --> 00:02:43,870
0,300 300,540 540,750 750,870 870,1230
out actually how to implement

85
00:02:43,870 --> 00:02:45,220
0,630 720,930 930,1050 1050,1200 1200,1350
interface| and so this is
|这节课将是这类课程的第一节课。

86
00:02:45,220 --> 00:02:46,090
0,120 120,180 180,300 300,420 420,870
going to be the first

87
00:02:46,090 --> 00:02:47,380
0,480 630,870 870,1050 1050,1230 1230,1290
lecture of that kind of

88
00:02:47,380 --> 00:02:48,540
0,660
style.|
|

89
00:02:48,600 --> 00:02:50,880
0,510 660,1020 1020,1740 1770,2190 2190,2280
And, {} fortunately, {} you
幸运的是，你们通过邮件提了一些很好的问题，

90
00:02:50,880 --> 00:02:51,630
0,150 150,270 300,540 540,630 630,750
know a lot of you

91
00:02:51,630 --> 00:02:53,820
0,420 420,780 780,1020 1020,1650 1890,2190
asking really great questions over

92
00:02:53,820 --> 00:02:56,640
0,630 810,1590 1920,2400 2400,2610 2610,2820
email| or submitted a great
|或者在网站上提交了很好的问题，

93
00:02:56,640 --> 00:02:58,320
0,360 360,450 450,510 510,1080 1290,1680
questions to the website {},|
|

94
00:02:58,320 --> 00:02:59,670
0,180 180,300 300,630 630,750 750,1350
and we won't be able
我们不会直接讲很多细节，

95
00:02:59,910 --> 00:03:01,500
0,420 450,900 900,1140 1140,1380 1380,1590
to go into great amount

96
00:03:01,500 --> 00:03:02,550
0,60 60,450 450,780 780,930 930,1050
of detail immediately| in this
|在这些深入操作系统课程中的第一节课上，

97
00:03:02,550 --> 00:03:03,720
0,150 150,240 240,630 630,990 990,1170
sort of first lecture that

98
00:03:03,720 --> 00:03:04,920
0,240 240,390 390,900 900,1110 1110,1200
types an inside look of

99
00:03:04,920 --> 00:03:06,240
0,120 120,450 450,840 1050,1260 1260,1320
the operating system,| so we're
|我们会涉及不同的东西，

100
00:03:06,240 --> 00:03:07,260
0,120 120,180 180,390 390,750 750,1020
going to touch on different

101
00:03:07,260 --> 00:03:09,000
0,450 540,1050 1050,1320 1320,1620 1620,1740
things,| but many things will
|但是很多东西会在后面的课程中变得更清楚，

102
00:03:09,000 --> 00:03:11,280
0,330 330,780 780,1530 1680,2130 2130,2280
become more clear {} in

103
00:03:11,280 --> 00:03:12,630
0,450 450,810 810,1170 1170,1290 1290,1350
subsequent lectures,| we're going to
|我们会更深入地研究。

104
00:03:12,630 --> 00:03:14,220
0,330 330,570 570,780 780,1320
explore in more depth.|
|

105
00:03:14,520 --> 00:03:16,620
0,390 390,690 720,1440 1470,1950 1950,2100
{} But nevertheless {} if
尽管如此，如果有什么东西不清楚，可以随意打断并提问。

106
00:03:16,620 --> 00:03:18,840
0,390 390,630 630,1440 1560,2040 2040,2220
there's something unclear, feel free

107
00:03:18,840 --> 00:03:20,130
0,120 120,630 630,720 720,990 990,1290
to interrupt and ask a

108
00:03:20,130 --> 00:03:21,200
0,510
question.|
|

109
00:03:22,020 --> 00:03:23,370
0,300 300,660 660,870 870,1050 1050,1350
And maybe just to start
或许在继续之前，我先问一些问题，

110
00:03:23,370 --> 00:03:25,500
0,390 570,1350 1350,1680 1680,1950 1950,2130
off before actually going any

111
00:03:25,500 --> 00:03:27,330
0,600 720,1200 1200,1560 1560,1650 1650,1830
further, {} let me ask

112
00:03:27,330 --> 00:03:28,500
0,120 120,180 180,600 600,960 960,1170
you a question| and sort
|提问并回答，

113
00:03:28,500 --> 00:03:29,880
0,300 300,540 540,840 900,1260 1260,1380
of get the question and

114
00:03:29,880 --> 00:03:32,010
0,330 330,660 660,1110 1530,1860 1860,2130
answering [hopefully going]| and ask
|问题是在 util 实验中你学到的最有趣的事情是什么。

115
00:03:32,010 --> 00:03:33,480
0,270 270,480 480,870 870,990 990,1470
you like what is the

116
00:03:33,480 --> 00:03:34,710
0,300 300,600 600,870 870,1050 1050,1230
most interesting thing that you've

117
00:03:34,710 --> 00:03:37,230
0,390 390,750 750,1230 1620,2070 2070,2520
learned from the util lab.|
|

118
00:03:37,600 --> 00:03:39,280
0,540 720,900 900,1230 1230,1410 1410,1680
And I'll start by answering
首先，我会自己回答这个问题，

119
00:03:39,280 --> 00:03:41,290
0,90 90,360 360,990 990,1590 1710,2010
that question myself,| {} one
|在编写完成 util 实验后，令我惊讶的一件事是，

120
00:03:41,290 --> 00:03:42,310
0,60 60,150 150,360 360,510 510,1020
of the things that surprise

121
00:03:42,310 --> 00:03:44,320
0,420 420,1050 1050,1440 1440,1740 1740,2010
me after writing or doing

122
00:03:44,320 --> 00:03:45,460
0,90 90,390 390,690 690,810 810,1140
the util lab is| that
|我比之前更多地使用 xargs ，

123
00:03:45,730 --> 00:03:47,860
0,660 780,1260 1260,1530 1530,2040 2040,2130
{} I use xargs a

124
00:03:47,860 --> 00:03:49,060
0,210 210,540 540,960 960,1140 1140,1200
lot more frequently than I

125
00:03:49,060 --> 00:03:50,380
0,180 180,240 240,540 540,780 780,1320
used to do,| and another
|与 xargs 做相同事情的其他方法，一些命令，

126
00:03:50,410 --> 00:03:51,580
0,450 450,540 540,720 720,1080 1080,1170
way of doing basically the

127
00:03:51,580 --> 00:03:52,870
0,270 270,420 420,570 570,750 750,1290
same thing as {xargs -}

128
00:03:52,870 --> 00:03:56,380
0,480 750,990 990,1050 1050,1620 2430,3510
{} set of commands| and
|在做了 xargs 实验之后，

129
00:03:56,410 --> 00:03:58,240
0,390 390,600 600,840 840,1320 1380,1830
after actually doing the {xargs,lab},|
|

130
00:03:58,240 --> 00:03:59,320
0,270 270,510 510,630 630,960 960,1080
{[] - -} xargs has
以这种方式使用 xargs 更方便，

131
00:03:59,320 --> 00:04:00,550
0,240 240,360 360,810 810,870 870,1230
much more convenient to actually

132
00:04:00,550 --> 00:04:01,300
0,150 150,240 240,330 330,510 510,750
use it in that way,|

133
00:04:01,390 --> 00:04:02,710
0,300 300,600 660,990 990,1170 1170,1320
and so since then I've
我成为一名 xargs 更积极的用户，

134
00:04:02,710 --> 00:04:04,420
0,120 120,180 180,420 420,810 1110,1710
been a much more aggressive

135
00:04:04,420 --> 00:04:06,340
0,510 540,870 960,1080 1080,1560 1620,1920
user of {} xargs| and
|我很想知道你们的体验是什么。

136
00:04:06,400 --> 00:04:07,570
0,270 270,390 390,990 990,1080 1080,1170
I'm just wondering you know

137
00:04:07,570 --> 00:04:09,120
0,240 240,750 780,1350
what they {you,know},

138
00:04:09,240 --> 00:04:10,800
0,150 150,210 210,600 600,1350 1350,1560
what the experience has been

139
00:04:10,800 --> 00:04:12,570
0,120 120,300 300,390 390,720 1530,1770
for some of you.| So
|所以，我会点名，

140
00:04:12,570 --> 00:04:13,710
0,300 300,660 660,930 930,1080 1080,1140
maybe I'll call out a

141
00:04:13,710 --> 00:04:15,990
0,300 300,990 990,1590 1740,2190 2190,2280
few names| and maybe you
|你可以关闭静音回答问题，

142
00:04:15,990 --> 00:04:17,730
0,210 210,600 600,690 690,1350 1350,1740
can unmute your microphone and

143
00:04:17,730 --> 00:04:18,450
0,120 120,240 240,390 390,720 720,720
answer,| {[] - -} {}
|说一下你关于 util 实验的体验。

144
00:04:19,560 --> 00:04:20,310
0,210 210,360 360,420 420,600 600,750
and say a little bit

145
00:04:20,310 --> 00:04:22,050
0,420 420,570 570,1020 1020,1200 1200,1740
about your experience with util

146
00:04:22,050 --> 00:04:22,840
0,360
lab.|
|

147
00:04:23,320 --> 00:04:25,450
0,690 690,930 930,1080 1080,1740 1770,2130
{} So let me pick
我来挑几个人， Andrew You 。

148
00:04:25,450 --> 00:04:27,430
0,120 120,690 720,1200 1230,1620 1620,1980
some people, {} Andrew you.|
|

149
00:04:33,100 --> 00:04:34,690
0,210 210,540 540,660 660,900 900,1590
{Andrew -}, are your online
Andrew ，你在线吗？

150
00:04:34,780 --> 00:04:36,970
0,840 1110,1380 1380,1440 1440,1710 1710,2190
listening?| Um, the most interesting
|对我来说最有趣的东西是管道，还有如何编写并发程序。

151
00:04:36,970 --> 00:04:37,780
0,180 180,330 330,480 480,630 630,810
thing for me was just

152
00:04:37,780 --> 00:04:39,430
0,90 90,780 1290,1440 1440,1560 1560,1650
the pipes and how to

153
00:04:39,430 --> 00:04:41,300
0,240 240,630 630,1350
write concurrent programs.|
|

154
00:04:42,750 --> 00:04:43,650
0,180 180,300 300,510 510,750 750,900
Have you done any sort
你之前编写过管道编程吗，或者是第一次。

155
00:04:43,650 --> 00:04:45,060
0,60 60,270 270,720 720,1200 1200,1410
of pipe programming before, {or,it}

156
00:04:45,060 --> 00:04:46,080
0,120 120,180 180,450 450,660 660,1020
was the first.| {No,I} haven't
|不，我没有，我见过并发编程，但是没有见过操作系统管道。

157
00:04:46,230 --> 00:04:47,490
0,330 330,540 540,630 630,780 780,1260
{I,like} seen the all concurrent

158
00:04:47,490 --> 00:04:48,450
0,300 300,510 510,570 570,750 750,960
stuff, but I haven't seen

159
00:04:48,450 --> 00:04:50,460
0,420 420,660 660,990 990,1440
OS level pipes before.|
|

160
00:04:51,660 --> 00:04:54,080
0,300 300,930 930,1350 1350,1890
How about Elizabeth Weeks?|
Elizabeth Weeks ，你觉得怎么样？|

161
00:04:55,360 --> 00:04:56,890
0,570 570,810 810,1080 1080,1200 1200,1530
Yeah, I'd agree with that,
是的，我同意这一点，我也发现操作系统管道非常有趣，

162
00:04:56,890 --> 00:04:58,480
0,240 240,690 690,960 960,1080 1080,1590
I also thought that the

163
00:04:58,780 --> 00:05:00,370
0,360 360,690 690,750 750,1050 1050,1590
OS pipes are super interesting|

164
00:05:00,370 --> 00:05:01,870
0,180 180,330 330,480 480,1020 1020,1500
and like the primes {}
而且质数实验也很酷，

165
00:05:02,500 --> 00:05:04,900
0,570 570,1290 1290,1860 1890,2280 2280,2400
example specifically was cool| to
|理解我需要关闭当前管道，

166
00:05:04,930 --> 00:05:05,830
0,240 240,300 300,570 570,810 810,900
kind of figure out and

167
00:05:05,830 --> 00:05:06,910
0,390 390,660 660,720 720,990 990,1080
realized that I needed to

168
00:05:06,910 --> 00:05:08,410
0,360 360,660 660,1080 1080,1230 1230,1500
close certain pipes| and just
|它们之间有某种关联。

169
00:05:08,410 --> 00:05:09,760
0,360 780,960 960,1080 1080,1260 1260,1350
like are they kind of

170
00:05:09,760 --> 00:05:11,600
0,360 360,480 480,630 630,990
related to each other.|
|

171
00:05:11,780 --> 00:05:13,070
0,210 210,660 660,870 870,1080 1080,1290
Yeah, probably you did find
是的，可能你会发现质数管道比你想象的要难，

172
00:05:13,070 --> 00:05:14,270
0,90 90,510 510,750 750,1170 1170,1200
the pipes of primes are

173
00:05:14,270 --> 00:05:15,380
0,30 30,180 180,270 270,720 750,1110
a little bit harder than

174
00:05:15,380 --> 00:05:16,520
0,570
{}

175
00:05:16,520 --> 00:05:18,500
0,60 60,210 210,330 330,960 1710,1980
you might {} thought,| this
|每次我都会感到意外，要想做对需要一些技巧。

176
00:05:18,500 --> 00:05:19,940
0,480 480,630 630,810 810,1140 1140,1440
surprises me every time a

177
00:05:19,940 --> 00:05:20,990
0,270 270,390 390,690 690,810 810,1050
little bit tricky to get

178
00:05:20,990 --> 00:05:21,900
0,360
right.|
|

179
00:05:23,330 --> 00:05:24,860
0,480 480,1020
Jessica She.|
Jessica She.|

180
00:05:26,300 --> 00:05:28,100
0,600 630,780 780,1080 1080,1590 1620,1800
Um, I also thought the
我也觉得质数实验非常有趣。

181
00:05:28,100 --> 00:05:30,320
0,450 450,1080 1080,1230 1230,1500 1500,2220
primes exercise was most interesting.|
|

182
00:05:32,000 --> 00:05:33,140
0,540
Good,
好的，它有没有花了你很长时间或者觉得还好。

183
00:05:33,140 --> 00:05:33,710
0,210 210,300 300,450 450,540 540,570
did it take you a

184
00:05:33,710 --> 00:05:34,610
0,210 210,270 270,600 600,780 780,900
lot of time or was

185
00:05:34,610 --> 00:05:36,220
0,270 270,480 480,600 600,990
there not too bad.|
|

186
00:05:36,560 --> 00:05:39,800
0,870 1470,1680 1680,1980 1980,2640
Um, it took me
嗯，在我意识到我的实现不是并发的之后，它花了我更多时间，

187
00:05:39,800 --> 00:05:41,390
0,540 540,900 900,1140 1140,1230 1230,1590
more time after I realized

188
00:05:41,390 --> 00:05:42,920
0,90 90,420 420,990 990,1230 1230,1530
my initial implementation wasn't actually

189
00:05:42,920 --> 00:05:44,210
0,600 600,690 690,840 840,1200 1200,1290
concurrent,| so it's interesting to
|所以思考这之间有什么不同是很有趣的。

190
00:05:44,210 --> 00:05:45,770
0,180 180,510 510,810 1110,1470 1470,1560
think about like what the

191
00:05:45,770 --> 00:05:47,380
0,450 450,600 600,1080
differences are there.|
|

192
00:05:48,500 --> 00:05:50,940
0,300 300,900 930,1320 1320,1890
How about Robert Murphy?|
Robert Murphy 呢？|

193
00:05:53,970 --> 00:05:55,860
0,210 210,360 360,540 540,1230 1350,1890
Yeah, I think that the
好的，我想我的体验是，

194
00:05:56,660 --> 00:05:58,100
0,180 180,570 570,690 690,960 960,1440
my experience was really just,|
|

195
00:05:59,740 --> 00:06:01,090
0,150 150,390 390,510 510,900 900,1350
I found it really challenging
我发现用它设置的原始方法编程很有挑战性，

196
00:06:01,090 --> 00:06:02,770
0,60 60,630 630,930 930,1170 1170,1680
to program in in the

197
00:06:02,800 --> 00:06:04,030
0,750 750,900 900,960 960,1080 1080,1230
original way it was set

198
00:06:04,030 --> 00:06:04,840
0,150 150,240 240,330 330,510 510,810
up,| so I actually created
|所以我创建了很多很多围绕它们的帮助函数，

199
00:06:04,840 --> 00:06:06,040
0,180 180,390 390,540 540,810 810,1200
a bunch of helper functions

200
00:06:06,040 --> 00:06:07,960
0,210 210,480 480,780 780,1320 1350,1920
that wrapped around things {},|
|

201
00:06:08,290 --> 00:06:09,580
0,450 480,930 990,1020 1020,1200 1200,1290
so that's I guess what
这就是我所做的。

202
00:06:09,580 --> 00:06:10,380
0,90 90,300
I did.|
|

203
00:06:13,730 --> 00:06:15,290
0,570 570,750 750,960 960,1410 1410,1560
{Okay,Any} {} might have sort
好的，还有人有什么想法吗？

204
00:06:15,290 --> 00:06:16,660
0,210 240,780
of any

205
00:06:16,660 --> 00:06:18,700
0,180 180,270 270,870 1320,1740 1740,2040
piece of wisdom.| {Amanda -},
|Amanda ，说吧。

206
00:06:18,910 --> 00:06:20,770
0,540 1080,1470 1470,1470 1470,1800 1800,1860
{go,ahead}.| I I kind of
|我发现它很酷，

207
00:06:20,770 --> 00:06:21,550
0,210 210,270 270,420 420,660 660,780
liked it and found it

208
00:06:21,550 --> 00:06:24,640
0,720 720,930 930,1410 1410,1830 2490,3090
surprising such cool| that {stdin
|就是标准输入和标准输出只是文件描述符 0 和 1 。

209
00:06:24,640 --> 00:06:26,230
0,120 120,780 780,1020 1020,1170 1170,1590
-} {stdout -} are just

210
00:06:26,260 --> 00:06:28,180
0,480 480,900 900,1470 1500,1830 1830,1920
file descriptors themselves zero and

211
00:06:28,180 --> 00:06:29,960
0,300
one.|
|

212
00:06:30,140 --> 00:06:32,510
0,330 330,990 1110,1620 1620,2100 2100,2370
Good [], yeah xv6 doesn't
好的。 xv6 没有隐藏这个，

213
00:06:32,510 --> 00:06:33,290
0,180 180,330 330,540 540,690 690,780
hide that from you at

214
00:06:33,290 --> 00:06:34,550
0,360 450,690 690,960 960,1140 1140,1260
all,| {} {actually -} in
|实际上在 C 标准库中，它会封装成接口，

215
00:06:34,550 --> 00:06:36,350
0,240 240,630 630,990 990,1680 1680,1800
a normal C library that

216
00:06:36,350 --> 00:06:37,490
0,270 270,390 390,660 660,810 810,1140
will be wrapped up in

217
00:06:38,000 --> 00:06:39,830
0,600 600,870 870,1350 1590,1740 1740,1830
a, in a, in an

218
00:06:39,830 --> 00:06:42,140
0,450 450,1050 1380,1890 1890,2070 2070,2310
interface,| but {xv6 -} doesn't
|但是 xv6 没有对你隐藏它，

219
00:06:42,140 --> 00:06:43,190
0,510 510,660 660,750 750,870 870,1050
{hide,it,for,you},| but in the end,
|最终，它会归结为文件描述符 0 和 1 ，

220
00:06:43,190 --> 00:06:44,420
0,60 60,330 330,570 570,870 870,1230
it boils down indeed to

221
00:06:44,510 --> 00:06:45,860
0,330 330,480 480,690 690,1020 1020,1350
know just file descriptor zero

222
00:06:45,860 --> 00:06:46,910
0,270 420,630 630,810 810,900 900,1050
one| and two I guess
|还有 2 ，用来表示标准错误。

223
00:06:46,910 --> 00:06:48,060
0,120 120,390 390,690
for standard error.|
|

224
00:06:49,330 --> 00:06:50,400
0,510
Good,
好的， Alexandra 。

225
00:06:51,910 --> 00:06:53,280
0,870
Alexandra.|
|

226
00:06:53,900 --> 00:06:56,540
0,510 540,690 690,1260 1290,2130 2340,2640
Um, I guess, {} one
我想，让我意外的一件事也是来自质数问题，

227
00:06:56,540 --> 00:06:57,860
0,210 210,300 300,420 420,780 780,1320
thing I was surprised about

228
00:06:57,890 --> 00:06:59,120
0,330 330,540 540,780 780,1080 1080,1230
{} was also from the

229
00:06:59,120 --> 00:07:01,520
0,510 510,1920
primes problem,|
|

230
00:07:02,920 --> 00:07:04,300
0,270 270,600 600,810 810,1200 1200,1380
I had this bug that
有一个 bug 我花了很长时间，

231
00:07:04,300 --> 00:07:06,520
0,300 300,930 960,1440 1440,1860 1860,2220
I spent hours on| and
|就是我没有意识到，

232
00:07:06,520 --> 00:07:07,570
0,150 150,390 390,630 630,930 930,1050
the thing was that I

233
00:07:07,570 --> 00:07:09,070
0,240 240,750 750,960 960,1350 1350,1500
didn't realize that| actually they
|当你打开一个管道，然后调用 fork ，

234
00:07:09,070 --> 00:07:12,860
0,630 750,1290 1290,1470 1470,3300
were whenever you were

235
00:07:14,080 --> 00:07:15,550
0,480 480,660 660,1050 1050,1260 1260,1470
opening a pipe and then

236
00:07:15,550 --> 00:07:17,890
0,390 420,810 810,1230 1230,1860 1860,2340
for- like calling fork,| then
|然后这个管道就会有四个末端，

237
00:07:17,980 --> 00:07:19,870
0,540 540,690 690,870 870,1050 1050,1890
basically there would be four

238
00:07:20,260 --> 00:07:21,970
0,330 330,1050 1050,1140 1140,1320 1320,1710
{} ends to the pipe,|
|

239
00:07:21,970 --> 00:07:23,860
0,630 630,930 930,1350 1350,1560 1560,1890
because that pipe is kind
因为管道既连接子进程又连接父进程，

240
00:07:23,860 --> 00:07:25,510
0,420 540,900 900,1260 1260,1560 1560,1650
of {} goes both to

241
00:07:25,510 --> 00:07:27,130
0,240 240,630 630,1230 1230,1500 1500,1620
the child process and the

242
00:07:27,130 --> 00:07:28,960
0,360 360,480 480,780 780,1410
process the parent process,|

243
00:07:29,080 --> 00:07:30,040
0,300 300,450 450,540 540,690 690,960
and but I was only
但是我只关掉了其中的两个。

244
00:07:30,040 --> 00:07:33,000
0,510 510,660 660,870 870,1470
closing two of those.|
|

245
00:07:33,030 --> 00:07:34,860
0,210 210,450 450,660 660,1140 1500,1830
So, yeah, that was.| {Yeah,a}
所以，就是这样。|是的，一个普遍的问题。

246
00:07:34,860 --> 00:07:37,530
0,480 510,810 810,1260 2070,2310 2310,2670
common common problem.| It made
|它有道理，但是因为某些原因，

247
00:07:37,530 --> 00:07:39,300
0,600 600,810 810,1050 1050,1380 1380,1770
sense, but for some reason,|
|

248
00:07:39,300 --> 00:07:41,700
0,720 870,1470 1470,1590 1590,2040 2040,2400
because especially the textbook says
因为，特别是书上写到当你使用 fork ，所有打开的文件描述符都会被复制，

249
00:07:41,700 --> 00:07:44,550
0,420 480,1470 1470,1650 1650,2520 2550,2850
that when you fork, {}

250
00:07:44,550 --> 00:07:45,780
0,240 240,390 390,630 630,1020 1020,1230
all of the open file

251
00:07:45,780 --> 00:07:47,760
0,480 480,690 690,1350 1650,1860 1860,1980
descriptors get copied,| but I
|但是我没有想到这个。

252
00:07:47,760 --> 00:07:53,520
0,210 210,540 1710,5190 5190,5370 5370,5760
don't think {it,that.}| {The,only,way,get} actually
|熟悉它们的方法就是用它编程，实际使用它。

253
00:07:53,520 --> 00:07:54,870
0,300 300,660 660,930 930,1290 1290,1350
really familiar with actually the

254
00:07:54,870 --> 00:07:56,340
0,420 420,540 540,780
program with it,

255
00:07:56,940 --> 00:07:58,620
0,600 600,810
experience it.|
|

256
00:07:58,880 --> 00:08:00,410
0,150 150,480 870,1200 1200,1320 1320,1530
Good good, well, I hope
很好，我希望你们喜欢这个实验，

257
00:08:00,410 --> 00:08:01,910
0,90 90,360 360,450 450,900 990,1500
you enjoyed the lab {}|
|

258
00:08:01,910 --> 00:08:02,690
0,300 300,450 450,540 540,750 750,780
and yeah, of course I
当然，我也希望你们喜欢后面的实验。

259
00:08:02,690 --> 00:08:03,860
0,180 180,360 360,600 600,690 690,1170
hope you enjoy the subsequent

260
00:08:03,860 --> 00:08:05,240
0,270 270,630 780,990 990,1080 1080,1380
labs too.| So the lecture
|所以今天的讲座，某种意义上是

261
00:08:05,240 --> 00:08:06,170
0,90 90,360 360,420 420,630 630,930
for today, in some sense

262
00:08:06,170 --> 00:08:07,760
0,90 90,480 480,630 630,1020 1080,1590
is really you know partially|
|

263
00:08:07,760 --> 00:08:08,690
0,150 150,420 420,660 660,750 750,930
to help you to get
帮助你开始 syscall 实验，如果你还没有开始的话，

264
00:08:08,690 --> 00:08:12,110
0,300 300,1110 1410,2250 2430,2940 2940,3420
going on the syscall lab

265
00:08:12,230 --> 00:08:13,550
0,120 120,240 240,600 600,870 870,1320
if you haven't already started|
|

266
00:08:13,610 --> 00:08:15,020
0,180 180,300 300,750 870,1230 1230,1410
and so again, {} you
还有，你可以随时打断我并提问。

267
00:08:15,020 --> 00:08:16,100
0,150 150,330 330,480 480,960 960,1080
feel free to interrupt and

268
00:08:16,100 --> 00:08:17,200
0,240 240,780
ask questions.|
|

269
00:08:17,560 --> 00:08:18,700
0,510 540,750 750,810 810,1020 1020,1140
Okay, so the first thing
好的，我想做的第一件事是，讨论一下隔离性。

270
00:08:18,700 --> 00:08:20,440
0,60 60,210 210,270 270,780 960,1740
I want to do a

271
00:08:20,860 --> 00:08:22,080
0,690
is,

272
00:08:22,080 --> 00:08:23,520
0,540 570,780 780,840 840,1080 1080,1440
{} talk a little bit

273
00:08:23,520 --> 00:08:26,310
0,450 450,1200 1680,2220 2220,2670 2670,2790
about isolation.| {} And you
|为什么它重要，为什么我们这么关心。

274
00:08:26,310 --> 00:08:27,810
0,90 90,330 330,450 450,1050 1050,1500
know why it's important and

275
00:08:27,810 --> 00:08:29,370
0,510 510,900 900,1080 1080,1470 1500,1560
why we might care {}.|
|

276
00:08:29,550 --> 00:08:30,810
0,300 300,390 390,660 660,1110 1110,1260
{You,know} the basic stories are
基本的描述是很简单的，

277
00:08:30,810 --> 00:08:32,580
0,90 90,390 390,1020 1230,1590 1590,1770
a reasonable simple,| we have
|我们有很多程序在这里，比如 shell echo find ，

278
00:08:32,580 --> 00:08:33,900
0,360 360,900 900,1110 1110,1200 1200,1320
multiple applications here, we got

279
00:08:33,900 --> 00:08:35,580
0,90 90,600 690,1080 1080,1200 1200,1680
the shell echo [] find|
|

280
00:08:35,790 --> 00:08:37,080
0,240 240,330 330,480 480,990 990,1290
and it'll be [create] correct,|
是由我们创建的，|

281
00:08:37,080 --> 00:08:37,860
0,210 210,330 330,420 420,510 510,780
if you had a bug
如果在 shell 或质数程序中有一个 bug ，

282
00:08:37,860 --> 00:08:38,970
0,120 120,210 210,660 660,990 1020,1110
in the shell or for

283
00:08:38,970 --> 00:08:40,500
0,390 390,480 480,570 570,930 930,1530
example in your primes program,|
|

284
00:08:40,710 --> 00:08:42,090
0,330 330,510 510,780 780,1050 1050,1380
{} that actually didn't affect
它不会影响其他应用，

285
00:08:42,090 --> 00:08:43,410
0,150 150,270 270,330 330,540 540,1320
any of the other applications,|
|

286
00:08:43,440 --> 00:08:44,670
0,600 600,660 660,780 780,900 900,1230
particularly it would be bad
特别是如果影响了 shell ，事情会变得很坏，

287
00:08:44,670 --> 00:08:45,600
0,60 60,420 420,510 510,600 600,930
for example if it affected

288
00:08:45,600 --> 00:08:46,650
0,90 90,450 450,660 660,960 960,1050
the shell,| because probably the
|因为如果某些东西破坏， shell 可能会杀掉程序。

289
00:08:46,650 --> 00:08:48,210
0,330 330,600 600,990 990,1110 1110,1560
shell you're using to actually

290
00:08:48,210 --> 00:08:49,230
0,60 60,240 240,480 480,570 570,1020
you know kill the program,

291
00:08:49,230 --> 00:08:50,500
0,90 90,360 360,570 570,870
if something goes bad.|
|

292
00:08:50,960 --> 00:08:52,580
0,210 210,330 330,630 630,750 750,1620
So you want a strong
所以你希望在不同的应用之间存在强隔离。

293
00:08:52,610 --> 00:08:55,370
0,630 630,990 990,1290 1650,2010 2010,2760
isolation between these different applications.|
|

294
00:08:55,900 --> 00:08:57,490
0,240 240,780 780,840 840,1200 1230,1590
{} Similarly you know the
类似的，操作系统为所有应用程序提供服务，

295
00:08:57,490 --> 00:08:58,510
0,510 510,630 630,750 750,810 840,1020
OS is sort of a

296
00:08:58,510 --> 00:09:00,550
0,600 720,960 960,1080 1080,1200 1200,2040
servant for all the applications,|
|

297
00:09:00,730 --> 00:09:01,900
0,570 570,720 720,840 840,990 990,1170
{} and you would like
你希望是这种情况，

298
00:09:01,900 --> 00:09:02,560
0,60 60,150 150,240 240,330 330,660
it to be the case,|
|

299
00:09:02,560 --> 00:09:03,820
0,240 240,360 360,510 510,1170 1200,1260
that you know if you
如果你在 util 某个程序中引入一个 bug ，

300
00:09:03,820 --> 00:09:05,020
0,510 510,630 630,840 840,900 900,1200
know you make a bug

301
00:09:05,020 --> 00:09:06,040
0,210 210,420 420,540 540,690 690,1020
in one of your util

302
00:09:06,040 --> 00:09:07,270
0,450 450,600 600,810 810,870 870,1230
programs,| that actually the operating
|但是操作系统不会崩溃，

303
00:09:07,270 --> 00:09:09,130
0,270 270,540 540,990 1410,1530 1530,1860
system doesn't crash,| {for,example,you} pass
|比如你传入一些奇怪的参数给操作系统，

304
00:09:09,130 --> 00:09:10,390
0,150 150,480 480,870 870,1020 1020,1260
some strange argument to the

305
00:09:10,390 --> 00:09:12,250
0,510 510,990 1200,1620 1620,1800 1800,1860
operating system,| {you,know} should be
|也应该是这种情况，操作系统可以很好地处理。

306
00:09:12,250 --> 00:09:13,090
0,60 60,300 300,420 420,540 540,840
the case that the operating

307
00:09:13,090 --> 00:09:14,680
0,300 300,630 630,810 810,1170
system handles that well.|
|

308
00:09:14,710 --> 00:09:15,760
0,210 210,330 330,780 810,960 960,1050
And so again we would
所以，我们也希望应用程序和操作系统之间有强隔离。

309
00:09:15,760 --> 00:09:16,930
0,150 150,210 210,450 450,750 750,1170
like to be there strong

310
00:09:16,930 --> 00:09:20,880
0,630 630,1320 1350,1890 2820,3390
isolation between { -}

311
00:09:20,880 --> 00:09:22,920
0,210 210,1050 1050,1500 1500,1650 1650,2040
the applications and the operating

312
00:09:22,920 --> 00:09:24,240
0,270 270,810
system itself.|
|

313
00:09:24,390 --> 00:09:25,770
0,420 540,810 810,1110 1110,1260 1260,1380
{} And one way to
一种思考方式是，

314
00:09:25,770 --> 00:09:26,580
0,180 180,420 420,540 540,600 600,810
think about this a little

315
00:09:26,580 --> 00:09:27,810
0,180 180,360 360,450 450,930 990,1230
bit is| to say is
|问我们自己，如果没有操作系统会发生什么。

316
00:09:27,810 --> 00:09:29,610
0,270 270,570 570,630 630,1200 1350,1800
ask ourselves the question, what

317
00:09:29,610 --> 00:09:31,470
0,450 450,900 900,1020 1020,1200 1200,1860
would happen if there's actually

318
00:09:31,620 --> 00:09:33,330
0,390 390,780 780,1200 1230,1560 1560,1710
no operating system.| So you
|考虑某种 strawman 设计。

319
00:09:33,330 --> 00:09:34,680
0,270 270,630 630,810 810,1140 1140,1350
know consider some {strawman -}

320
00:09:34,680 --> 00:09:36,520
0,720 750,1350
design, design,|
|

321
00:09:40,010 --> 00:09:41,460
0,870
where
就是没有操作系统，

322
00:09:41,670 --> 00:09:42,900
0,180 180,270 270,420 420,750 750,1230
there is no operating system,|
|

323
00:09:45,400 --> 00:09:46,300
0,300 300,450 450,540 540,660 660,900
or you could think about
或者你可以把操作系统当成 [] ，就是一个库，

324
00:09:46,300 --> 00:09:47,380
0,90 90,270 270,570 600,990 990,1080
it as the {operating,system} is

325
00:09:47,380 --> 00:09:48,790
0,150 150,510 510,1020 1020,1230 1230,1410
{[] - -}, just being

326
00:09:48,790 --> 00:09:49,810
0,60 60,600 630,780 780,870 870,1020
a library,| you know sort
|从 python 的角度考虑，

327
00:09:49,810 --> 00:09:50,770
0,60 60,390 390,630 630,870 870,960
of thinking about {} in

328
00:09:50,770 --> 00:09:52,900
0,330 330,420 420,1020 1350,1920 1920,2130
terms of python,| maybe just
|使用 import os ，而 import os 会加载整个操作系统到应用程序，

329
00:09:52,900 --> 00:09:54,460
0,480 480,570 570,960 960,1440 1440,1560
import {os -}, and {import,os

330
00:09:54,460 --> 00:09:55,810
0,300 300,510 510,900 900,1260 1260,1350
- -} basically loads the

331
00:09:55,810 --> 00:09:57,550
0,540 540,930 930,1320 1320,1650 1650,1740
whole operating system inside of

332
00:09:57,550 --> 00:09:59,470
0,150 150,900 1050,1320 1320,1530 1530,1920
your application| and that's then
|这就是你使用的编程接口。

333
00:09:59,470 --> 00:10:01,030
0,90 90,510 510,930 930,1050 1050,1560
the programming interface you use.|
|

334
00:10:01,670 --> 00:10:02,780
0,240 240,480 540,750 750,900 900,1110
And so you think about
你可以这样想，

335
00:10:02,780 --> 00:10:04,160
0,420 630,930 930,1050 1050,1290 1290,1380
that sort of way of

336
00:10:04,160 --> 00:10:05,210
0,420 420,600 600,780 780,900 900,1050
thinking,| so let's say we
|这里我们有一个 shell ，

337
00:10:05,210 --> 00:10:06,560
0,180 180,270 270,630 630,1260 1260,1350
have to shell here,| you
|可能它包含系统库，

338
00:10:06,560 --> 00:10:07,940
0,90 90,360 360,480 480,870 870,1380
know, maybe it includes the

339
00:10:07,970 --> 00:10:11,090
0,780 1110,1830 1860,1950 1950,2580 2760,3120
library for the OS| and
|我们还有其他应用程序 echo ，

340
00:10:11,090 --> 00:10:12,500
0,540 600,900 900,1080 1080,1200 1200,1410
maybe we have some other

341
00:10:12,500 --> 00:10:14,300
0,630 630,1320
application echo,|
|

342
00:10:14,490 --> 00:10:16,140
0,450 450,660 660,1050 1080,1590 1590,1650
{} and then basically you
这些应用程序，如果没有操作系统，就需要访问硬件，

343
00:10:16,140 --> 00:10:18,360
0,120 120,600 630,870 870,1740 2040,2220
know these these applications if

344
00:10:18,360 --> 00:10:20,310
0,180 180,450 450,870 870,1410 1410,1950
there's no operating system really

345
00:10:20,520 --> 00:10:21,960
0,480 480,930 930,1290 1290,1380 1380,1440
would directly interact with the

346
00:10:21,960 --> 00:10:22,980
0,540
hardware,|
|

347
00:10:23,190 --> 00:10:24,390
0,210 210,750 750,810 810,990 990,1200
for example, you know they
比如，它们会看到，这里有一个 CPU ，这里还有一个 CPU ，

348
00:10:24,390 --> 00:10:25,650
0,180 180,450 450,930 960,1020 1020,1260
would actually see you know

349
00:10:25,650 --> 00:10:27,270
0,240 240,300 300,690 690,1170 1230,1620
there's a CPU core, there's

350
00:10:27,270 --> 00:10:28,840
0,240 240,630 630,1050
another CPU core,|
|

351
00:10:28,840 --> 00:10:30,190
0,510 510,960 960,1020 1020,1110 1110,1350
{} and you know maybe
这里有一个磁盘，它们直接访问磁盘，

352
00:10:30,190 --> 00:10:31,300
0,150 150,210 210,750 780,990 990,1110
there's a disk and then

353
00:10:31,300 --> 00:10:32,320
0,120 120,480 480,840 840,930 930,1020
they interact directly with the

354
00:10:32,320 --> 00:10:33,610
0,270 270,660 660,750 750,960 960,1290
disk blocks| and maybe there's
|这里有一个内存，它们直接访问内存。

355
00:10:33,610 --> 00:10:34,870
0,510 510,660 660,720 720,840 840,1260
memory and they were directly

356
00:10:34,870 --> 00:10:35,860
0,390 390,480 480,570 570,900 900,990
interact with the memory of

357
00:10:35,860 --> 00:10:36,920
0,90 90,510
the machine.|
|

358
00:10:37,370 --> 00:10:38,660
0,360 360,540 540,630 630,990 990,1290
{} And so there's no
所以在应用程序和硬件之间没有抽象层，

359
00:10:38,660 --> 00:10:41,060
0,420 420,1110 1140,1680 1680,2130 2130,2400
layer between, no abstraction layer

360
00:10:41,060 --> 00:10:43,370
0,330 330,690 690,810 810,1620 1710,2310
between basically the applications {}

361
00:10:43,370 --> 00:10:45,470
0,180 180,240 240,810 1050,1620 1830,2100
and the hardware| and it
|事实证明，在隔离方面，这不是一个好的设计。

362
00:10:45,470 --> 00:10:46,730
0,300 300,570 570,810 810,990 990,1260
turns out that it's just

363
00:10:46,730 --> 00:10:48,290
0,300 300,450 450,540 540,870 870,1560
not such a great design

364
00:10:48,410 --> 00:10:51,340
0,510 510,1320 1440,1830 1830,2430
{} for {} isolation.|
|

365
00:10:51,550 --> 00:10:52,360
0,210 210,300 300,390 390,630 630,810
And you can see how
你可以看到隔离是怎么被打破的，

366
00:10:52,360 --> 00:10:54,520
0,510 510,720 720,900 900,1440 1650,2160
isolation might be broken,| let's
|我们假设，操作系统的一个目标是可以运行多个应用程序，

367
00:10:54,520 --> 00:10:56,050
0,450 450,510 510,990 990,1410 1410,1530
assume for example that you

368
00:10:56,050 --> 00:10:57,250
0,390 540,780 780,840 840,930 930,1200
know one of the goal

369
00:10:57,250 --> 00:10:58,300
0,210 210,300 300,390 390,660 660,1050
[] from the operating system

370
00:10:58,300 --> 00:11:00,610
0,180 180,570 570,990 990,1860 2010,2310
is run multiple applications| and
|所以肯定会有这种情况，

371
00:11:00,610 --> 00:11:01,660
0,390 420,660 660,870 870,960 960,1050
so there has to be

372
00:11:01,660 --> 00:11:02,710
0,90 90,450 450,600 600,990 990,1050
the case| that once in
|每隔一段时间，它从一个应用程序切换到另一个应用程序，

373
00:11:02,710 --> 00:11:04,300
0,570 570,720 720,840 840,1380 1410,1590
{a,while}, it will switch from

374
00:11:04,300 --> 00:11:05,860
0,180 180,720 720,810 810,1080 1080,1560
one application to another application,|
|

375
00:11:05,920 --> 00:11:07,090
0,210 210,510 510,690 690,990 990,1170
let's say the hardware has
假设硬件只有一个 CPU ，

376
00:11:07,090 --> 00:11:09,100
0,240 240,720 750,1530 1710,1890 1890,2010
only one CPU| and so
|所以我们在一个 CPU 上运行 shell ，周期地 [] ，

377
00:11:09,100 --> 00:11:10,360
0,120 120,570 570,660 660,960 960,1260
we're running the shell say

378
00:11:10,360 --> 00:11:11,860
0,150 150,330 330,900 1170,1410 1410,1500
about one CPU {[] -}

379
00:11:11,860 --> 00:11:13,480
0,120 120,750 750,870 870,1110 1110,1620
are periodically| in other applications
|让其他应用程序也可以运行。

380
00:11:13,480 --> 00:11:14,170
0,120 120,210 210,390 390,510 510,690
should be able to run

381
00:11:14,170 --> 00:11:14,860
0,330
to.|
|

382
00:11:15,500 --> 00:11:16,580
0,300 300,390 390,510 510,660 660,1080
Well, we have no operating
如果没有操作系统为我们做这个，

383
00:11:16,580 --> 00:11:19,100
0,600 900,1230 1230,1560 1560,1890 2100,2520
system {to,do} for us,| then
|shell 就必须每隔一段时间放弃 CPU ，

384
00:11:19,100 --> 00:11:20,120
0,60 60,300 300,630 630,780 780,1020
the shell basically has to

385
00:11:20,120 --> 00:11:21,290
0,210 210,480 510,660 660,810 810,1170
give up, you know the

386
00:11:21,650 --> 00:11:22,880
0,480 480,720 720,780 780,810 810,1230
CPU once in a while,|
|

387
00:11:24,220 --> 00:11:24,760
0,180 180,300 300,360 360,480 480,540
and sort of be a
做一个好人，表示我已经运行一会了，现在你可以运行了，

388
00:11:24,760 --> 00:11:26,830
0,300 300,840 870,1380 1380,1500 1500,2070
nice person and say well

389
00:11:26,830 --> 00:11:27,490
0,180 180,360 360,450 450,480 480,660
I've run for a little

390
00:11:27,490 --> 00:11:28,720
0,570 570,750 750,870 870,930 930,1230
while you get a chance

391
00:11:28,720 --> 00:11:29,860
0,60 60,360 480,690 690,840 840,1140
to run| and there's something
|这就是所谓的协作式调度。

392
00:11:29,860 --> 00:11:31,680
0,120 120,360 360,840 840,1320
just called cooperative scheduling.|
|

393
00:11:31,830 --> 00:11:33,300
0,600 870,1050 1050,1200 1200,1350 1350,1470
{} But it's not so
但是这对于隔离来说并不好，

394
00:11:33,300 --> 00:11:35,160
0,270 270,390 390,1080 1260,1470 1470,1860
great for isolation,| for example,
|比如，如果 shell 中有一个无限循环，

395
00:11:35,160 --> 00:11:37,080
0,540 540,1170 1170,1440 1440,1800 1800,1920
what if some function in

396
00:11:37,080 --> 00:11:38,370
0,90 90,510 510,690 690,780 780,1290
the shell has an infinite

397
00:11:38,370 --> 00:11:39,840
0,360 540,900 900,1290 1290,1380 1380,1470
loop,| and therefore it will
|因此它永远不会放弃 CPU ，

398
00:11:39,840 --> 00:11:41,040
0,480 510,840 840,1020 1020,1140 1140,1200
never actually give up the

399
00:11:41,040 --> 00:11:41,960
0,450
CPU,|
|

400
00:11:41,960 --> 00:11:43,160
0,120 120,240 240,450 450,840 870,1200
and then, no other {you,know}
然后，没有其他应用程序可以运行，包括关闭 shell 的应用程序。

401
00:11:43,160 --> 00:11:45,260
0,540 540,690 690,1080 1140,1710 1710,2100
applications could run including maybe

402
00:11:45,260 --> 00:11:46,640
0,90 90,570 570,660 660,1020 1020,1380
the application that would stop

403
00:11:46,640 --> 00:11:48,420
0,90 90,630 810,930 930,1290
or kill the shell.|
|

404
00:11:48,550 --> 00:11:50,230
0,240 240,630 750,1050 1050,1200 1200,1680
And so, {} we basically
所以，我们没有任何形式的强制复用。

405
00:11:50,230 --> 00:11:51,280
0,330 330,630 630,810 810,990 990,1050
don't get any sort of

406
00:11:51,280 --> 00:11:54,000
0,390 390,630 630,1380 1380,2010
form of enforced multiplexing,|
|

407
00:11:54,090 --> 00:11:55,290
0,450 450,720 720,840 840,1020 1020,1200
that's something that we'd like
这是我们需要的，

408
00:11:55,290 --> 00:11:57,150
0,60 60,480 510,930 1170,1620 1620,1860
to have| where no matter
|无论应用程序在做什么，它必须强制每隔一段时间放弃 CPU ，

409
00:11:57,150 --> 00:11:58,980
0,180 180,270 270,810 810,1410 1620,1830
what the application does, it

410
00:11:58,980 --> 00:11:59,880
0,120 120,240 240,660 660,750 750,900
will be forced to give

411
00:11:59,880 --> 00:12:00,870
0,180 180,240 240,690 690,930 930,990
up the CPU once in

412
00:12:00,870 --> 00:12:02,310
0,60 60,600 630,990 990,1200 1200,1440
a while,| that's what other
|让其他应用程序可以运行。

413
00:12:02,310 --> 00:12:03,780
0,570 570,840 840,990
applications go on.|
|

414
00:12:04,730 --> 00:12:06,140
0,720 720,960 960,1050 1050,1200 1200,1410
Similarly, if you think about
同样的，如果你考虑这个 strawman 设计，

415
00:12:06,140 --> 00:12:08,240
0,120 120,450 450,540 540,1230 1470,2100
this {strawman -} design {},|
|

416
00:12:08,420 --> 00:12:09,830
0,90 90,240 240,630 630,1080 1110,1410
you know we have there's
这里有一个物理内存，

417
00:12:09,830 --> 00:12:11,210
0,150 150,480 480,960 990,1260 1260,1380
a physical memory right| and
|我画的这张图，

418
00:12:11,210 --> 00:12:12,650
0,420 420,630 660,990 990,1050 1050,1440
all I drew a picture

419
00:12:12,650 --> 00:12:14,240
0,600 600,750 750,900 900,1350 1350,1590
here,| so the application sitting
|应用程序位于硬件之上，

420
00:12:14,240 --> 00:12:14,720
0,90 90,150 150,360 360,420 420,480
on the top of the

421
00:12:14,720 --> 00:12:16,880
0,540 630,1170 1260,1470 1470,1860 1890,2160
hardware,| but you know there's
|这是物理内存，代码文本和程序数据在物理内存中，

422
00:12:16,880 --> 00:12:18,920
0,270 270,750 750,1050 1050,1380 1380,2040
physical memory and basically {the,text}

423
00:12:18,920 --> 00:12:20,030
0,120 120,180 180,780 780,990 990,1110
in the code and the

424
00:12:20,030 --> 00:12:21,530
0,360 360,480 480,660 660,1260 1260,1500
data for these applications actually

425
00:12:21,530 --> 00:12:22,910
0,390 390,480 480,540 540,840 840,1380
sits in the physical memory,|

426
00:12:22,910 --> 00:12:24,200
0,90 90,180 180,390 390,870
it's a usual memory.|
这是一个常用的内存。|

427
00:12:24,740 --> 00:12:25,850
0,180 180,450 450,600 600,750 750,1110
And {here's -} {maybe -}
这里是 shell 使用的部分，

428
00:12:25,850 --> 00:12:27,200
0,90 90,300 300,750
you know the

429
00:12:27,200 --> 00:12:28,340
0,270 270,330 330,630 630,930 930,1140
part of physical memory, that's

430
00:12:28,340 --> 00:12:29,900
0,270 270,390 390,510 510,960 1350,1560
used by the shell,| there's
|这里是 echo 使用的部分。

431
00:12:29,900 --> 00:12:31,070
0,300 300,540 540,750 750,810 810,1170
maybe a part of {}

432
00:12:31,070 --> 00:12:32,570
0,300 300,570 570,720 720,960 960,1500
physical memory that's used by

433
00:12:32,780 --> 00:12:34,360
0,390 390,1020
echo application.|
|

434
00:12:34,760 --> 00:12:36,230
0,270 270,390 390,510 510,990 990,1470
And so you're going to,
所以你会再次看到，

435
00:12:36,440 --> 00:12:37,760
0,450 450,690 690,840 840,960 960,1320
again what was see here,|
|

436
00:12:37,760 --> 00:12:39,860
0,300 330,600 600,750 750,1380 1410,2100
if you'd like simply simplistically
如果像这么简单，

437
00:12:39,860 --> 00:12:41,540
0,210 210,660 810,1170 1170,1380 1380,1680
like this,| {} there sure
|这两块内存之间没有界限，

438
00:12:41,540 --> 00:12:44,990
0,720 720,1530 1740,2610 2610,3240 3240,3450
no {} boundary between these

439
00:12:44,990 --> 00:12:47,270
0,180 180,750 1140,1290 1290,1830 1830,2280
two guys,| for example if
|比如 echo 保存数据到属于 shell 的 1000 地址，

440
00:12:47,420 --> 00:12:48,740
0,150 150,900
{you,know} echo

441
00:12:49,110 --> 00:12:51,000
0,420 420,600 600,1230 1230,1440 1440,1890
store to location, for example

442
00:12:51,000 --> 00:12:53,970
0,630 900,1530 1920,2370 2370,2550 2550,2970
belongs to shell like location

443
00:12:53,970 --> 00:12:55,560
0,90 90,570 570,840 840,1200 1200,1590
at 1000| and writes value
|并写入值 x ，

444
00:12:55,560 --> 00:12:57,420
0,420 870,960 960,1080 1080,1410 1410,1860
there, you know, whatever x,|
|

445
00:12:57,780 --> 00:12:59,400
0,390 390,660 660,750 750,930 930,1620
{} then you just overwrite
然后你就翻盖了 shell 的物理内存。

446
00:12:59,400 --> 00:13:00,840
0,90 90,390 390,780 780,930 930,1440
the physical memory of the

447
00:13:00,870 --> 00:13:02,320
0,480 480,990
shell memory.|
|

448
00:13:02,380 --> 00:13:03,130
0,150 150,270 270,510 510,630 630,750
And so that you know
这是非常错误的，

449
00:13:03,130 --> 00:13:04,960
0,150 150,420 420,1110 1140,1560 1560,1830
be pretty undesirable,| because then
|因为产生了一个 bug ， echo 渗透到 shell 中，

450
00:13:04,960 --> 00:13:06,100
0,120 120,450 450,540 540,630 630,1140
a bug, you know echo

451
00:13:06,100 --> 00:13:07,330
0,120 120,390 390,900 900,1140 1140,1230
could actually percolate into the

452
00:13:07,330 --> 00:13:08,860
0,570 750,1200 1200,1290 1290,1410 1410,1530
shell| and you know it's
|调试这类东西会非常困难，

453
00:13:08,860 --> 00:13:09,790
0,150 150,210 210,480 480,810 810,930
gonna be very tricky to

454
00:13:09,790 --> 00:13:10,840
0,360 360,480 480,600 600,690 690,1050
debug that kind of stuff.|
|

455
00:13:10,870 --> 00:13:12,550
0,150 150,300 300,690 690,1170 1290,1680
So this basically again gives
这给我们的是非强隔离。

456
00:13:12,550 --> 00:13:15,120
0,240 240,870 960,1410 1410,2070
like no strong isolation.|
|

457
00:13:15,350 --> 00:13:17,140
0,270 270,390 390,750 750,1230
What we like is
我们想要的是内存隔离，

458
00:13:17,590 --> 00:13:19,120
0,510 540,660 660,1080 1080,1200 1200,1530
{} to have {you,know} memory

459
00:13:19,120 --> 00:13:21,370
0,570 570,870 870,1110 1290,1620 1620,2250
isolation,| so that one application
|让一个应用程序不会覆盖另一个应用程序的内存。

460
00:13:21,370 --> 00:13:24,340
0,390 390,1050 1080,1470 1470,2340 2580,2970
cannot overwrite [] {} memory

461
00:13:24,340 --> 00:13:25,820
0,90 90,360 360,960
of another application.|
|

462
00:13:26,220 --> 00:13:28,380
0,540 1050,1620
Um, and,
所以需要操作系统的一个原因是，

463
00:13:28,640 --> 00:13:30,320
0,150 150,420 690,840 840,960 960,1680
and so you know {},

464
00:13:30,410 --> 00:13:32,450
0,540 540,1050 1170,1380 1380,1740 1740,2040
one reason a main probably

465
00:13:32,450 --> 00:13:33,620
0,60 60,510 510,750 750,870 870,1170
the main reason to actually

466
00:13:33,620 --> 00:13:35,060
0,180 180,270 270,660 660,1170 1260,1440
have an operating system is|
|

467
00:13:35,060 --> 00:13:37,490
0,420 420,540 540,1290 1320,1770 1770,2430
basically to enforce both {multiplexing
在复用的同时，有强隔离性。

468
00:13:37,490 --> 00:13:40,190
0,300 540,990 990,1500 1530,2310 2370,2700
-}, {} in enforce strong

469
00:13:40,190 --> 00:13:41,600
0,300 300,900
memory isolation.|
|

470
00:13:41,600 --> 00:13:42,380
0,120 120,210 210,450 450,720 720,780
If you didn't have an
如果不使用操作系统

471
00:13:42,380 --> 00:13:43,730
0,330 330,720 720,870 870,990 990,1350
operating system| and the applications
|并且应用程序直接访问硬件，

472
00:13:43,730 --> 00:13:44,900
0,90 90,540 540,960 960,1110 1110,1170
are directly interacting with the

473
00:13:44,900 --> 00:13:46,370
0,600 630,900 900,990 990,1260 1260,1470
hardware| would be very hard
|是很难达到（隔离）的要求的。

474
00:13:46,370 --> 00:13:47,540
0,60 60,450
to {achieve,that}.|
|

475
00:13:48,030 --> 00:13:49,980
0,540 600,840 840,1290 1290,1380 1380,1950
So this design of basically
所以这种将操作系统作为库的设计并不是一种很常见的设计，

476
00:13:49,980 --> 00:13:51,480
0,420 420,690 690,780 780,840 840,1500
operating system as a library

477
00:13:51,540 --> 00:13:52,680
0,240 240,510 510,570 570,810 810,1140
is not a very common

478
00:13:52,680 --> 00:13:54,060
0,450 450,600 600,810 810,1200 1200,1380
design,| you may see some
|你可能在一些实时系统中看到，因为它们的应用程序都是可信任的，

479
00:13:54,060 --> 00:13:56,430
0,390 390,1080 1110,1410 1410,1830 1830,2370
real-time systems where basically applications

480
00:13:56,430 --> 00:13:58,140
0,390 390,510 510,840 1110,1470 1470,1710
trust each other,| {} but
|但是在大多数其他操作系统中，

481
00:13:58,140 --> 00:14:00,000
0,120 120,480 480,870 870,1260 1260,1860
in most other operating systems,|
|

482
00:14:00,090 --> 00:14:01,110
0,180 180,270 270,630 630,720 720,1020
you know there's an operating
有操作系统来保证这种隔离。

483
00:14:01,110 --> 00:14:02,550
0,270 270,450 450,690 690,1140 1140,1440
system that really enforce you

484
00:14:02,550 --> 00:14:03,720
0,90 90,240 240,390 390,540 540,1170
know that kind of isolation.|
|

485
00:14:05,460 --> 00:14:06,750
0,510 540,690 690,960 990,1260 1260,1290
So if we look a
所以如果我们现在从这个角度看 Unix 接口，

486
00:14:06,750 --> 00:14:08,190
0,210 210,330 330,930 1200,1380 1380,1440
little bit now, at the

487
00:14:08,190 --> 00:14:10,050
0,360 360,810 810,990 990,1140 1140,1860
Unix interface from this perspective,|
|

488
00:14:14,350 --> 00:14:15,670
0,360 360,510 510,1020 1020,1260 1260,1320
then we see that the
我们会看到这些接口是精心设计的，

489
00:14:15,670 --> 00:14:17,860
0,450 450,750 750,870 870,1380 1380,2190
interface actually is carefully designed,|
|

490
00:14:18,650 --> 00:14:20,540
0,270 270,420 420,810 810,930 930,1890
so that actually is feasible
可以方便地实现复用和物理内存方面的强隔离，

491
00:14:20,840 --> 00:14:24,740
0,570 570,1440 1440,1980 1980,2820 3090,3900
to implement that enforced a

492
00:14:24,740 --> 00:14:26,750
0,780 780,1140 1140,1380 1380,1440 1440,2010
isolation in terms of multiplexing,

493
00:14:26,750 --> 00:14:28,070
0,270 270,510 510,570 570,840 840,1320
in terms of physical memory|
|

494
00:14:28,490 --> 00:14:30,020
0,270 270,390 390,630 630,1260 1260,1530
and the way that's done
使用的方法就是这些接口抽象了硬件资源，

495
00:14:30,020 --> 00:14:31,880
0,360 510,720 720,1050 1230,1500 1500,1860
is that the {} interface

496
00:14:31,880 --> 00:14:34,300
0,240 240,1200 1230,1350 1350,1980
basically abstracts the hardware,

497
00:14:37,380 --> 00:14:39,200
0,450 450,1260
hardware resources,|
|

498
00:14:40,940 --> 00:14:42,260
0,150 150,270 270,810 930,1140 1140,1320
in a way that then
在某种程度上，更简单地，或者并不简单，

499
00:14:42,260 --> 00:14:43,310
0,90 90,270 270,390 420,870 870,1050
it makes it easy to

500
00:14:43,310 --> 00:14:45,350
0,360 360,1050 1080,1290 1290,1500 1530,2040
actually do or not easier,|
|

501
00:14:45,350 --> 00:14:47,060
0,180 180,360 360,450 450,1140 1350,1710
it makes it possible to
它让提供强隔离成为可能。

502
00:14:47,060 --> 00:14:48,110
0,270 270,750 750,810 810,930 930,1050
{} provide you know the

503
00:14:48,110 --> 00:14:50,000
0,660 660,1320
strong isolation.|
|

504
00:14:50,280 --> 00:14:51,870
0,420 660,1020 1020,1140 1140,1290 1290,1590
{} And you know maybe
我来举几个例子，

505
00:14:51,870 --> 00:14:52,470
0,60 60,150 150,300 300,420 420,600
you should give you some

506
00:14:52,470 --> 00:14:55,800
0,690 810,1560 1770,2340 2370,3030 3030,3330
examples,| {} so processes we've
|比如我们之前看到的由 fork 创建的进程，

507
00:14:55,800 --> 00:14:56,790
0,390 390,600 600,810 810,930 930,990
seen like things that are

508
00:14:56,790 --> 00:14:58,440
0,360 360,570 570,1140
created by fork,|
|

509
00:14:59,780 --> 00:15:01,580
0,90 90,180 180,360 360,870 1050,1800
you know they're not, literally
它们不是真正的 CPU ，

510
00:15:01,580 --> 00:15:03,350
0,60 60,750 810,1140 1140,1440 1440,1770
a CPU, right,| {I,mean} {that's
|我的意思是它们对应 CPU ，由 CPU 来运行计算，

511
00:15:03,350 --> 00:15:05,090
0,420 420,600 600,1260 1260,1530 1530,1740
-} a correspond to what

512
00:15:05,090 --> 00:15:06,320
0,90 90,780 780,870 870,960 960,1230
a CPU and it allows

513
00:15:06,320 --> 00:15:08,360
0,90 90,180 180,450 450,1170 1560,2040
you to run computation,| but
|但是因为应用程序不能直接访问 CPU ，而是通过进程抽象，

514
00:15:08,390 --> 00:15:09,800
0,240 240,750 750,840 840,990 990,1410
{you,know} because you know they're

515
00:15:09,800 --> 00:15:11,810
0,270 300,720 720,1140 1140,1500 1500,2010
the applications cannot directly interact

516
00:15:11,810 --> 00:15:12,980
0,150 150,360 360,720 720,840 840,1170
with the CPU, but only

517
00:15:12,980 --> 00:15:14,810
0,150 150,300 300,690 690,1380 1650,1830
for this process abstraction,| the
|使得幕后的内核可以在进程之间切换。

518
00:15:14,810 --> 00:15:16,070
0,660 690,870 870,930 930,1200 1200,1260
kernel sort of behind the

519
00:15:16,070 --> 00:15:17,990
0,750 780,1020 1020,1110 1110,1530 1530,1920
scenes {you,know} can switch between

520
00:15:17,990 --> 00:15:19,160
0,750
processes.|
|

521
00:15:20,280 --> 00:15:22,410
0,180 180,450 450,510 510,1080 1470,2130
So instead of having direct
不是直接操纵 CPU 或将 CPU 分配给应用程序，

522
00:15:22,410 --> 00:15:24,960
0,510 510,630 630,1500 1620,2280 2280,2550
CPU to manipulate or given

523
00:15:24,960 --> 00:15:26,910
0,90 90,180 180,870 990,1590 1590,1950
to the application,| {operation,system} provides
|操作系统提供进程作为对 CPU 的抽象，

524
00:15:26,910 --> 00:15:29,220
0,780 960,1140 1140,1620 1620,1860 1860,2310
processes that abstract {a,way} to

525
00:15:29,250 --> 00:15:30,540
0,240 240,570 570,990 990,1110 1110,1290
the CPU itself,| so that
|所以操作系统可以复用一个或多个 CPU 到多个应用程序。

526
00:15:30,540 --> 00:15:32,580
0,360 360,570 570,930 930,1320 1320,2040
actually the operating system multiplex

527
00:15:32,610 --> 00:15:34,290
0,180 180,600 600,1140 1140,1290 1290,1680
and one CPU or multiple

528
00:15:34,290 --> 00:15:36,460
0,450 450,660 660,1020 1020,1800
CPUs among multiple applications.|
|

529
00:15:37,200 --> 00:15:38,100
0,420 420,480 480,570 570,720 720,900
Similarly, if you think about
同样，如果你考虑 exec ， exec 提供一个内存镜像，

530
00:15:38,100 --> 00:15:39,240
0,540
exec,

531
00:15:39,970 --> 00:15:42,190
0,810 810,1170 1170,1260 1260,1680 1680,2220
exec provides a memory image,

532
00:15:42,950 --> 00:15:46,130
0,630 630,1320 1620,2220 2610,3060 3060,3180
{} and {}.| Amanda, yeah,
|Amanda ，好的，说出你的问题。

533
00:15:46,130 --> 00:15:47,480
0,150 150,510 570,900 900,990 990,1350
go ahead, ask your question.|
|

534
00:15:47,930 --> 00:15:49,910
0,210 210,570 570,960 960,1710 1710,1980
One question about processes {sort,of}
一个关于进程是 CPU 的抽象的问题，

535
00:15:49,910 --> 00:15:53,510
0,390 600,1860 1860,2010 2010,3060 3360,3600
like abstracting the CPU,| is
|是一个进程使用 CPU 的一部分，另一个进程使用另一部分，

536
00:15:53,510 --> 00:15:54,580
0,150 150,510
it that

537
00:15:55,070 --> 00:15:57,170
0,450 450,1110 1110,1740 1740,2010 2010,2100
one process uses part of

538
00:15:57,170 --> 00:15:59,330
0,120 120,930 1200,1440 1440,1770 1770,2160
the CPU and another process

539
00:15:59,330 --> 00:16:01,790
0,330 330,1170 1290,1770 1770,2130 2130,2460
uses a more {} different

540
00:16:01,790 --> 00:16:02,840
0,210 210,270 270,450 450,900 900,1050
part of that CPU| or
|或者如果是多核的，使用不同的 CPU ，

541
00:16:02,840 --> 00:16:04,220
0,120 120,480 480,930 930,1200 1200,1380
a different CPU if it's

542
00:16:04,220 --> 00:16:05,720
0,150 150,180 180,540 540,1080 1350,1500
like a {multi-core -}| or
|或者你所说的进程而不是 CPU 是什么意思。

543
00:16:05,720 --> 00:16:07,070
0,330 750,1110 1110,1170 1170,1230 1230,1350
like what do you mean

544
00:16:07,070 --> 00:16:08,330
0,150 150,750 750,1080 1080,1170 1170,1260
by processes instead of the

545
00:16:08,330 --> 00:16:09,860
0,570 690,1110 1110,1290 1290,1440 1440,1530
CPU.| Yeah, okay, so I
|好的，我的意思是一个 CPU 抽象成一个进程，

546
00:16:09,860 --> 00:16:12,650
0,450 450,990 990,1320 1320,2160 2160,2790
really mean one CPU abstracted

547
00:16:12,650 --> 00:16:14,000
0,330 330,660 660,720 720,1080 1080,1350
away into a process,| so
|好的，你可以这样想，

548
00:16:14,000 --> 00:16:14,630
0,150 150,300 300,390 390,540 540,630
okay so the way to

549
00:16:14,630 --> 00:16:16,070
0,150 150,480 480,600 600,930 1110,1440
think about is the {},|
|

550
00:16:16,100 --> 00:16:18,020
0,240 240,510 510,1050 1200,1770 1770,1920
the {RISC-V -} core or
我们在实验中使用的 RISC-V 处理器实际上有四个核，

551
00:16:18,020 --> 00:16:19,250
0,210 210,420 420,930 930,1080 1080,1230
{RISC-V -} processor that we're

552
00:16:19,250 --> 00:16:21,560
0,540 540,930 1170,1290 1290,1770 1830,2310
using in the lab actually

553
00:16:21,560 --> 00:16:22,660
0,300 300,810
four cores,|
|

554
00:16:22,930 --> 00:16:23,980
0,360 360,690 690,780 780,930 930,1050
{} and so you can
你可以同时运行四个进程，每个核一个进程，

555
00:16:23,980 --> 00:16:26,260
0,210 210,810 810,1470 1470,2130 2130,2280
run four processes concurrently or

556
00:16:26,260 --> 00:16:28,060
0,90 90,690 750,1290 1290,1680 1680,1800
in parallel, one process on

557
00:16:28,060 --> 00:16:29,200
0,150 150,600
each core,|
|

558
00:16:29,260 --> 00:16:30,400
0,270 270,420 420,540 540,840 840,1140
and what the operating system
操作系统说做的就是，

559
00:16:30,400 --> 00:16:31,270
0,270 270,450 450,630 630,750 750,870
does is,| let's say you
|比如你有八个或七个应用程序，

560
00:16:31,270 --> 00:16:32,770
0,180 210,540 540,1110 1110,1200 1200,1500
have eight applications or seven

561
00:16:32,770 --> 00:16:34,570
0,780 1020,1140 1140,1260 1260,1440 1440,1800
applications,| it will take some
|它会使用一些核，并通过时间复用，在不同的进程上，

562
00:16:34,570 --> 00:16:36,640
0,540 600,750 750,1440 1440,1740 1740,2070
core and multiplex it, time

563
00:16:36,640 --> 00:16:38,590
0,600 600,810 840,1230 1230,1470 1470,1950
multiplex it between different processes,|
|

564
00:16:38,590 --> 00:16:39,730
0,150 150,240 240,750 780,960 960,1140
so for example it will
比如它会运行一个应用程序进程 100 微秒，

565
00:16:39,730 --> 00:16:41,530
0,420 660,810 810,1200 1200,1410 1410,1800
run you one application process

566
00:16:41,530 --> 00:16:43,100
0,1140
{for,100,milliseconds},|
|

567
00:16:43,100 --> 00:16:45,740
0,180 180,810 1140,1890 1890,2220 2220,2640
then stop, unload that process
然后停止，从 CPU 或内核中卸载进程，

568
00:16:45,740 --> 00:16:47,180
0,150 150,270 270,570 570,1260 1290,1440
out of the CPU or

569
00:16:47,180 --> 00:16:48,980
0,180 180,240 240,330 330,1170 1200,1800
out of the core,| loading
|加载下一个应用程序进程，并运行 100 毫秒，

570
00:16:48,980 --> 00:16:51,320
0,120 120,660 780,1560 1560,2250 2250,2340
the next {} application, or

571
00:16:51,320 --> 00:16:52,550
0,60 60,300 300,780 810,990 990,1230
the next process that runs

572
00:16:52,550 --> 00:16:54,290
0,180 180,360 360,510 510,1290 1500,1740
out for 100 milliseconds| and
|它保证没有应用程序或进程运行超过 100 毫秒。

573
00:16:54,290 --> 00:16:55,520
0,90 90,240 240,840 840,1020 1020,1230
it just enforces that no

574
00:16:55,520 --> 00:16:56,690
0,510 510,660 660,900 900,1020 1020,1170
application can run or no

575
00:16:56,690 --> 00:16:57,800
0,270 270,420 420,630 630,960 960,1110
process can run longer than

576
00:16:57,800 --> 00:16:59,140
0,60 60,270 270,990
a hundred milliseconds.|
|

577
00:16:59,260 --> 00:17:00,400
0,240 240,390 390,870 870,990 990,1140
We'll see exactly how this
我们将会在后面的课程中看到这是如何实现的，

578
00:17:00,400 --> 00:17:01,240
0,240 240,450 450,570 570,630 630,840
was done in a couple

579
00:17:01,240 --> 00:17:02,380
0,540 660,840 840,960 960,1080 1080,1140
lectures,| but that's sort of
|但这就是它的基本思想。

580
00:17:02,380 --> 00:17:03,800
0,60 60,390 390,840
the basic idea.|
|

581
00:17:04,200 --> 00:17:06,390
0,330 330,510 510,990 990,1740 1740,2190
Okay, but multiple processes cannot
好的，但是多个进程不能同时使用相同的 CPU 。

582
00:17:06,390 --> 00:17:07,680
0,240 240,360 360,780 780,1170 1170,1290
use the same CPU at

583
00:17:07,680 --> 00:17:10,530
0,90 90,300 300,660 870,2220 2580,2850
the same time.| {No,it's,time,multiplexing}.| You
|是的，它是时间复用的。|你运行一个一段时间，然后再运行下一个一段时间。

584
00:17:10,530 --> 00:17:12,090
0,810 810,960 960,1020 1020,1410 1410,1560
{run,one} for a while then

585
00:17:12,090 --> 00:17:12,870
0,120 120,330 330,450 450,660 660,780
{you,run} the next one for

586
00:17:12,870 --> 00:17:13,780
0,60 60,420
a while.|
|

587
00:17:14,050 --> 00:17:15,460
0,330 330,540 540,750
Alright, thank you.|
好的，谢谢。|

588
00:17:16,130 --> 00:17:17,540
0,240 240,660 840,1020 1020,1290 1290,1410
Okay, so a one way
好的，所以考虑 exec 的一种方式是，它是对内存的抽象。

589
00:17:17,540 --> 00:17:18,830
0,120 120,270 270,510 510,1020 1050,1290
to think about exec is

590
00:17:18,830 --> 00:17:21,650
0,180 180,510 510,930 930,1470 1830,2820
that it's a {} abstracts

591
00:17:21,710 --> 00:17:23,040
0,750
memory.|
|

592
00:17:28,400 --> 00:17:29,330
0,240 240,330 330,660 660,780 780,930
So, for example if you
比如你想，

593
00:17:29,330 --> 00:17:31,400
0,150 150,690 840,1650 1710,1830 1830,2070
think about,| {} the exec
|exec 系统调用使用一个文件名，

594
00:17:31,400 --> 00:17:32,540
0,300 300,690 690,780 780,900 900,1140
system call you know takes

595
00:17:32,540 --> 00:17:33,590
0,60 60,330 330,720 720,780 780,1050
a file name,| you know
|在那个文件中是一个程序镜像，

596
00:17:33,590 --> 00:17:34,850
0,420 420,570 570,810 810,1170 1170,1260
and in that file is

597
00:17:34,850 --> 00:17:37,010
0,330 330,450 450,960 960,1560 1830,2160
basically the memory image of

598
00:17:37,010 --> 00:17:39,500
0,270 270,750 750,1080 1380,2040 2310,2490
a program,| stored text, so
|保存了 text , global data ，这些组成了应用程序的内存，

599
00:17:39,500 --> 00:17:41,930
0,300 300,690 720,1110 1110,1680 1800,2430
it's a global data {}

600
00:17:41,930 --> 00:17:44,390
0,510 630,1020 1020,1350 1350,1920 1920,2460
in, {} that forms the

601
00:17:44,390 --> 00:17:47,450
0,660 840,1650 1650,1770 1770,2490 2820,3060
memory of the application,| now
|应用程序可以增加内存，

602
00:17:47,450 --> 00:17:49,280
0,420 540,1110 1110,1260 1260,1680 1680,1830
the application can grow its

603
00:17:49,280 --> 00:17:50,540
0,390 390,450 450,810 810,960 960,1260
memory,| for example by calling
|比如通过调用 sbrk ，扩展其数据段，

604
00:17:50,540 --> 00:17:53,450
0,210 210,660 840,1440 1440,2340 2430,2910
{sbrk -} {} and extend

605
00:17:53,450 --> 00:17:55,220
0,270 270,840 840,990 990,1230 1230,1770
{there,by} extending its data segment,|
|

606
00:17:55,280 --> 00:17:56,840
0,510 510,750 750,1020 1020,1290 1290,1560
but it doesn't really have
但是实际上对物理内存没有直接影响，

607
00:17:56,840 --> 00:17:58,220
0,60 60,450 450,900 900,1020 1020,1380
a direct aspects to physical

608
00:17:58,220 --> 00:17:59,600
0,330 360,510 510,810 810,1080 1080,1380
memory,| you know you can't
|你不能要求访问物理内存 1k 或 2k ，

609
00:17:59,600 --> 00:18:01,010
0,180 180,510 510,810 810,1320 1320,1410
just ask I want you

610
00:18:01,010 --> 00:18:01,880
0,390
know

611
00:18:02,150 --> 00:18:04,370
0,690 690,870 870,1170 1170,1890 1890,2220
addresses into physical memory, {1k

612
00:18:04,370 --> 00:18:06,590
0,330 330,660 660,1020 1140,1560 1770,2220
-} {to,2k -},| {} there's
|没有方法可以做到这个，

613
00:18:06,590 --> 00:18:07,670
0,330 330,570 570,690 690,930 930,1080
no way of getting at

614
00:18:07,670 --> 00:18:08,780
0,210 270,420 420,750 750,840 840,1110
that| and again the reason
|再次强调，没有方法做到这个的原因是，

615
00:18:08,780 --> 00:18:09,770
0,270 270,450 450,750 750,900 900,990
there's no way that you

616
00:18:09,770 --> 00:18:10,880
0,120 120,300 300,390 390,720 930,1110
can get at that is|
|

617
00:18:10,880 --> 00:18:12,050
0,240 240,330 330,660 660,960 960,1170
because the operating system needs
因为操作系统提供内存隔离，

618
00:18:12,050 --> 00:18:13,490
0,300 300,510 510,630 630,1140 1140,1440
to want to provide memory

619
00:18:13,490 --> 00:18:15,020
0,660 750,960 960,1140 1140,1350 1350,1530
isolation| and therefore what's being
|因此控制了应用程序和物理硬件之间的交互。

620
00:18:15,020 --> 00:18:18,740
0,780 1170,2070 2070,2880 3030,3630 3630,3720
controlled intermediate intermediate between the

621
00:18:18,740 --> 00:18:20,390
0,690 690,840 840,900 900,1200 1200,1650
applications and the physical hardware.|
|

622
00:18:20,780 --> 00:18:21,860
0,150 150,510 510,630 630,930 930,1080
And exec is a sort
exec 系统调用，展示了不能直接访问内存。

623
00:18:21,860 --> 00:18:22,910
0,60 60,120 120,450 450,750 750,1050
of a system call that

624
00:18:23,210 --> 00:18:25,100
0,120 120,360 390,1110 1170,1470 1470,1890
you know captures or shows

625
00:18:25,100 --> 00:18:27,470
0,240 240,600 600,960 960,1560 1740,2370
that there's no direct access

626
00:18:27,470 --> 00:18:30,500
0,600 1050,1800 2070,2490 2490,2880 2880,3030
to memory.| Another example, this
|另一个例子是文件，

627
00:18:30,500 --> 00:18:31,860
0,120 120,270 270,960
is like files,|
|

628
00:18:33,020 --> 00:18:34,610
0,240 240,600 600,930 930,1380 1380,1590
the files basically abstract away
文件是对磁盘块的抽象，

629
00:18:34,610 --> 00:18:35,880
0,210 210,810
disk blocks,|

630
00:18:41,660 --> 00:18:43,400
0,390 390,840 840,1080 1080,1170 1170,1740
instead of reading or writing
而不是直接读写计算机磁盘的磁盘块，

631
00:18:43,430 --> 00:18:45,080
0,420 420,600 600,870 870,1260 1260,1650
{} the disk blocks of

632
00:18:45,080 --> 00:18:47,030
0,810 810,1140 1140,1500 1500,1860 1860,1950
the disk, that's attached to

633
00:18:47,030 --> 00:18:48,890
0,90 90,690 870,1320 1320,1530 1530,1860
your computer,| {} that actually
|实际上，这在 Unix 上是不允许的，

634
00:18:48,890 --> 00:18:50,030
0,180 180,360 360,630 630,720 720,1140
just not allowed in Unix,|
|

635
00:18:50,030 --> 00:18:51,080
0,150 150,270 270,360 360,720 720,1050
you know the only way
你访问存储系统的唯一方法就是通过文件，

636
00:18:51,080 --> 00:18:52,730
0,90 90,600 600,1110 1110,1260 1260,1650
to interact with the storage

637
00:18:52,730 --> 00:18:54,230
0,450 510,690 690,870 870,1380 1380,1500
system is through files,| and
|你可以读写文件，它提供了很方便的抽象，命名文件等等，

638
00:18:54,230 --> 00:18:54,920
0,90 90,210 210,390 390,450 450,690
you can read or write

639
00:18:54,920 --> 00:18:56,900
0,570 600,990 990,1020 1020,1470 1470,1980
files, provide a convenient abstraction,

640
00:18:56,900 --> 00:18:58,670
0,120 120,330 330,690 690,1290 1380,1770
you can name files, etc

641
00:18:58,670 --> 00:19:00,410
0,750 870,1140 1140,1290 1290,1410 1410,1740
etc,| but then the operating
|然后操作系统自己决定如何对文件到磁盘块做映射，

642
00:19:00,410 --> 00:19:02,180
0,540 570,750 750,1380 1380,1560 1560,1770
system in itself can actually

643
00:19:02,180 --> 00:19:03,680
0,450 450,690 690,810 810,1320 1320,1500
decide how to map those

644
00:19:03,680 --> 00:19:05,750
0,420 420,930 1140,1590 1590,1920 1920,2070
files to disk blocks| and
|保证磁盘块只会出现在一个文件中，

645
00:19:05,750 --> 00:19:07,010
0,150 150,540 540,720 720,1200 1200,1260
make sure for example of

646
00:19:07,010 --> 00:19:08,510
0,210 210,660 720,1110 1110,1380 1380,1500
disk block only shows up

647
00:19:08,510 --> 00:19:09,680
0,90 90,360 360,750 780,930 930,1170
in one file| and that
|保证用户 a 不能读写用户 b 的文件。

648
00:19:09,680 --> 00:19:11,000
0,90 90,330 330,510 510,960 960,1320
you know user a cannot

649
00:19:11,000 --> 00:19:13,070
0,480 480,570 570,840 870,1800 1800,2070
actually you know {manipulate,to} {read,or}

650
00:19:13,070 --> 00:19:14,840
0,450 570,810 810,930 930,1320 1320,1770
write {you,know} the files of

651
00:19:15,110 --> 00:19:16,460
0,330 330,690 690,1080
{} user b,|
|

652
00:19:16,520 --> 00:19:17,840
0,360 360,540 540,1020 1140,1230 1230,1320
{} and again you know
你知道文件抽象接口提供了强隔离，

653
00:19:17,840 --> 00:19:19,190
0,330 330,480 480,690 690,1080 1110,1350
this, you know that sort

654
00:19:19,190 --> 00:19:21,110
0,60 60,870 900,1500 1500,1650 1650,1920
of interface that the file

655
00:19:21,110 --> 00:19:22,490
0,480 480,1050 1050,1170 1170,1320 1320,1380
abstraction allows that sort of

656
00:19:22,490 --> 00:19:25,430
0,480 480,1230 1440,2190 2190,2490 2490,2940
strong isolation| between different users
|在不同用户之间，或者相同用户的不同进程之间。

657
00:19:25,430 --> 00:19:27,410
0,510 540,1140 1140,1680 1680,1890 1890,1980
and different processes of the

658
00:19:27,410 --> 00:19:28,460
0,300 300,570
same user.|
|

659
00:19:29,370 --> 00:19:30,330
0,210 210,300 300,390 390,690 690,960
As you can see,| that
如你所见，|在某些方面， Unix 接口，比如在 util 实验中使用的，

660
00:19:30,330 --> 00:19:31,530
0,300 300,510 510,990 1020,1110 1110,1200
in some ways you know

661
00:19:31,530 --> 00:19:32,820
0,180 180,480 480,660 660,1110 1110,1290
the system call interface {}

662
00:19:32,850 --> 00:19:35,160
0,300 300,750 750,1050 1050,1680 1680,2310
Unix interface giving programming {with,you,know,in}

663
00:19:35,160 --> 00:19:36,510
0,90 90,510 510,810 900,1290 1290,1350
the util lab,| seems to
|是经过精心设计的，以一种方式对资源进行抽象，

664
00:19:36,510 --> 00:19:37,890
0,90 90,240 240,300 300,720 720,1380
be sort of carefully designed

665
00:19:38,130 --> 00:19:39,660
0,360 360,840 840,930 930,1380 1380,1530
to abstract the resources in

666
00:19:39,660 --> 00:19:40,950
0,570 600,840 840,1050 1050,1170 1170,1290
way,| so that you know
|操作系统或接口可以对多个进程复用资源，并提供强隔离。

667
00:19:40,950 --> 00:19:42,690
0,90 90,480 480,990 990,1080 1080,1740
the operating system, the implementation

668
00:19:42,690 --> 00:19:43,950
0,90 90,180 180,720 780,1020 1020,1260
of the interface can actually

669
00:19:43,950 --> 00:19:46,440
0,690 990,1110 1110,1620 1620,1950 1950,2490
multiply the resource of multiple

670
00:19:46,440 --> 00:19:48,900
0,840 840,1050 1050,1410 1410,2100 2100,2460
applications and provide strong strong

671
00:19:48,900 --> 00:19:49,900
0,570
isolation.|
|

672
00:19:54,120 --> 00:19:55,800
0,180 180,510 510,720 720,1050
Any questions about that?|
这个有什么问题吗？|

673
00:19:56,040 --> 00:19:56,580
0,90 90,180 180,210 210,480 480,540
We have a question in
我们在聊天中有一个问题，

674
00:19:56,580 --> 00:19:57,810
0,60 60,330 330,420 420,1110 1110,1230
the chat,| that says do
|问题是是否更复杂的内核会试着重新调度同一个核的进程，以减少缓存缺失。

675
00:19:57,810 --> 00:19:59,130
0,240 240,660 660,1050 1050,1200 1200,1320
more complex kernels try to

676
00:19:59,130 --> 00:20:00,810
0,510 510,1170 1170,1290 1290,1380 1380,1680
reschedule processes on the same

677
00:20:00,810 --> 00:20:02,460
0,360 360,510 510,810 810,1140 1140,1650
core to reduce cache misses.|
|

678
00:20:02,730 --> 00:20:05,460
0,240 240,1320 1320,2010 2010,2520 2520,2730
Oh, yeah, there there's something
是的，有一个叫做缓存亲和性的东西，

679
00:20:05,460 --> 00:20:07,890
0,180 180,420 420,1170 1170,1170 2010,2430
called cache affinity { -},|
|

680
00:20:07,890 --> 00:20:09,180
0,120 120,210 210,360 360,840 840,1290
you know this conversion in
现代操作系统中的这种转换非常复杂，

681
00:20:09,180 --> 00:20:10,770
0,240 240,780 780,1080 1080,1500 1500,1590
a modern operating systems are

682
00:20:10,800 --> 00:20:13,080
0,420 420,1200 1470,1800 1800,2190 2190,2280
very sophisticated| and indeed you
|试着避免缓存缺失或类似的事情来优化性能。

683
00:20:13,080 --> 00:20:14,100
0,120 120,330 330,390 390,720 720,1020
know trying to avoid cache

684
00:20:14,100 --> 00:20:15,420
0,480 480,690 690,870 870,1020 1020,1320
misses and things like that

685
00:20:15,420 --> 00:20:17,070
0,180 180,300 300,900 900,960 960,1650
and to optimise the performance.|
|

686
00:20:17,550 --> 00:20:19,020
0,300 300,420 420,990 990,1260 1260,1470
And you will see some
你会在本学期晚些时候看到其中一些，

687
00:20:19,020 --> 00:20:19,980
0,90 90,240 240,480 480,870 870,960
of them much later in

688
00:20:19,980 --> 00:20:21,330
0,90 90,840 840,1050 1050,1110 1110,1350
the semester| where we are
|那里我们会讨论高性能网络，

689
00:20:21,330 --> 00:20:22,350
0,120 120,180 180,300 300,690 690,1020
going to be talking about

690
00:20:22,470 --> 00:20:24,120
0,180 180,570 570,1110
high performence networking,|
|

691
00:20:24,180 --> 00:20:25,440
0,270 270,600 600,840 840,930 930,1260
{} will show up there.|
它们也会出现在那里。|

692
00:20:26,260 --> 00:20:28,360
0,390 390,780 780,930 930,1380 1620,2100
Another question from chat,| {where,in}
聊天中的另一个问题，|在 xv6 中，哪里可以看到操作系统复用进程。

693
00:20:28,360 --> 00:20:29,230
0,180 180,300 300,600 600,780 780,870
{xv6 - -} can we

694
00:20:29,230 --> 00:20:30,760
0,210 210,360 360,510 510,870 870,1530
see how the OS multiplex

695
00:20:30,760 --> 00:20:35,080
0,870 1140,3750 3750,3810 3810,4080 4080,4320
{processes -}.| There's a couple
|有一些相关的文件，但是 proc.c 可能是最相关的那个，

696
00:20:35,080 --> 00:20:36,520
0,630 630,750 750,840 840,1290 1290,1440
files that are relevant, but

697
00:20:36,520 --> 00:20:37,660
0,240 240,390 390,750 780,900 900,1140
{proc.c - -} is probably

698
00:20:37,660 --> 00:20:39,430
0,60 60,210 210,570 570,930 1170,1770
the most relevant one {},|
|

699
00:20:39,460 --> 00:20:40,600
0,270 270,480 480,660 660,750 750,1140
this will be a topic
这将是两三周后课程的主题，

700
00:20:40,600 --> 00:20:42,010
0,150 150,690 690,1080 1080,1260 1260,1410
of lecture in like two

701
00:20:42,010 --> 00:20:43,060
0,60 60,240 240,660
or three weeks,|
|

702
00:20:43,060 --> 00:20:43,840
0,300 300,420 420,540 540,600 600,780
and we're going to go
我们将深入细节，展示复用是如何发生的。

703
00:20:43,840 --> 00:20:44,890
0,120 120,420 420,600 600,660 660,1050
in great amount of detail

704
00:20:44,890 --> 00:20:45,940
0,90 90,300 300,840 840,960 960,1050
and show exactly how the

705
00:20:45,940 --> 00:20:47,420
0,510 510,990
multiplex happens.|
|

706
00:20:48,420 --> 00:20:49,050
0,120 120,300 300,420 420,510 510,630
So one way to think
所以你可以把这节课当成是很多不同部分的简介，

707
00:20:49,050 --> 00:20:49,830
0,150 150,300 300,600 600,630 630,780
about this lecture a little

708
00:20:49,830 --> 00:20:50,640
0,90 90,150 150,240 240,720 720,810
bit of an introduction to

709
00:20:50,640 --> 00:20:51,750
0,60 60,210 210,270 270,540 540,1110
a lot of different pieces|
|

710
00:20:51,780 --> 00:20:53,250
0,570 600,1020 1020,1110 1110,1200 1200,1470
and {} you know because
因为我们必须从某个地方开始。

711
00:20:53,250 --> 00:20:54,210
0,90 90,210 210,270 270,510 510,960
we've got to start somewhere.|
|

712
00:20:56,500 --> 00:20:57,600
0,540
Okay,
好的，让我们回到之前的图片，

713
00:20:57,850 --> 00:21:00,190
0,1170 1590,1800 1800,1890 1890,2160 2160,2340
so we go back into

714
00:21:00,190 --> 00:21:02,020
0,360 390,1140 1140,1620 1620,1830 1830,1830
this picture here, that I

715
00:21:02,020 --> 00:21:03,970
0,600 600,630 630,1110 1140,1710 1710,1950
showed a little while ago,|
|

716
00:21:03,970 --> 00:21:05,200
0,180 180,300 300,480 480,690 690,1230
currently we have this {}
当前我们有 shell 在运行，有 echo 在运行，

717
00:21:05,290 --> 00:21:06,760
0,420 420,660 660,750 750,1110 1110,1470
shell running, the echo running,|
|

718
00:21:06,760 --> 00:21:08,050
0,270 300,510 510,660 660,960 1080,1290
um, not that picture, this
不是那张图，是这张，在这边，

719
00:21:08,050 --> 00:21:08,880
0,330
picture

720
00:21:08,880 --> 00:21:10,020
0,210 210,270 270,420 420,810 960,1140
here on this side,| we've
|我们有操作系统，有应用程序运行，

721
00:21:10,020 --> 00:21:11,040
0,150 150,240 240,540 540,870 870,1020
got the operating system, we

722
00:21:11,040 --> 00:21:13,140
0,120 120,210 210,750 750,1230 1530,2100
have the applications running| and
|我们应该考虑的一件事是，

723
00:21:13,200 --> 00:21:14,190
0,330 330,570 570,750 750,900 900,990
one thing we should be

724
00:21:14,190 --> 00:21:15,510
0,300 300,600 600,780 780,1020 1020,1320
worried about this were that|
|

725
00:21:15,510 --> 00:21:17,130
0,120 120,480 480,960 960,1200 1200,1620
the operating system should be
操作系统应该是防御性的。

726
00:21:19,080 --> 00:21:20,400
0,210 210,300 300,450 450,570 570,1320
{} it should be defensive.|
|

727
00:21:23,160 --> 00:21:24,420
0,270 270,330 330,480 480,540 540,1260
This is sort of {an,important},
当你做内核开发时，这是一种重要的思维模式，

728
00:21:24,630 --> 00:21:25,950
0,120 120,870 900,990 990,1140 1140,1320
a mindset you know that

729
00:21:25,950 --> 00:21:26,820
0,270 270,390 390,480 480,630 630,870
you have to get used

730
00:21:26,820 --> 00:21:28,620
0,180 180,900 900,1320 1320,1500 1500,1800
to once you doing kernel

731
00:21:28,620 --> 00:21:31,290
0,570 930,1500 1560,1770 1770,2070 2070,2670
development,| {} the operating system
|操作系统必须确保任何东西都能正常运行，

732
00:21:31,410 --> 00:21:33,720
0,360 360,420 420,1170 1410,2010 2040,2310
has to ensure {} that

733
00:21:33,720 --> 00:21:35,010
0,420 420,510 510,720 720,990 990,1290
everything you know everything works

734
00:21:35,010 --> 00:21:37,080
0,330 330,540 540,1020 1170,1650 1650,2070
out| and so {} it
|所以它必须设置一些东西，防止应用程序破坏操作系统。

735
00:21:37,080 --> 00:21:37,890
0,180 180,270 270,450 450,600 600,810
has to set up things

736
00:21:37,890 --> 00:21:38,760
0,180 180,360 360,630 630,750 750,870
up, so that you know

737
00:21:38,760 --> 00:21:40,500
0,90 90,600 720,1200 1200,1620 1620,1740
an app cannot crash the

738
00:21:40,500 --> 00:21:41,660
0,330 330,750
operating system.|
|

739
00:21:45,670 --> 00:21:46,750
0,180 180,330 330,450 450,630 630,1080
It would be too bad|
以下情况是很糟糕的，|

740
00:21:46,750 --> 00:21:48,700
0,120 120,210 210,1050 1230,1560 1560,1950
if an application, {} that
如果一个应用程序，因为意外或恶意传递错误参数给操作系统，

741
00:21:48,700 --> 00:21:50,470
0,150 150,360 360,900 900,1050 1050,1770
either by accident or maliciously

742
00:21:50,470 --> 00:21:52,360
0,570 630,870 870,1170 1170,1590 1590,1890
passers are tricky heartened bad

743
00:21:52,360 --> 00:21:54,310
0,480 480,930 930,1050 1050,1380 1380,1950
argument to the operating system|
|

744
00:21:54,400 --> 00:21:55,510
0,180 180,270 270,480 480,870 870,1110
and the operating system would
而导致操作系统崩溃，

745
00:21:55,510 --> 00:21:56,860
0,480 480,600 600,930 930,1200 1200,1350
crash,| that basically means for
|这意味着拒绝服务所有其他应用程序。

746
00:21:56,860 --> 00:21:58,540
0,390 390,900 900,1260 1260,1470 1470,1680
denial servers for every other

747
00:21:58,540 --> 00:21:59,620
0,600
application.|
|

748
00:21:59,710 --> 00:22:01,180
0,210 210,630 690,930 930,1230 1230,1470
{} So the operating system
所以操作系统必须以一种方式编写，

749
00:22:01,180 --> 00:22:01,840
0,120 120,180 180,300 300,570 570,660
has to be written in

750
00:22:01,840 --> 00:22:03,040
0,120 120,450 450,660 660,1050 1050,1200
a way| that it can
|让它可以处理恶意应用程序。

751
00:22:03,040 --> 00:22:05,800
0,450 450,600 600,1230 1260,1890 1890,2760
deal and handle malicious applications.|
|

752
00:22:06,400 --> 00:22:08,260
0,180 180,840 930,1290 1290,1710 1710,1860
In particular, another concern is
特别是，另一个要考虑是应用程序不能打破它的隔离。

753
00:22:08,260 --> 00:22:09,550
0,120 120,210 210,930 930,1080 1080,1290
that the application should not

754
00:22:09,550 --> 00:22:10,780
0,120 120,660
be able

755
00:22:10,780 --> 00:22:12,820
0,660 660,990 990,1440
cannot break out

756
00:22:12,910 --> 00:22:14,460
0,150 150,270 270,960
of its isolation,|
|

757
00:22:21,230 --> 00:22:22,250
0,30 60,360 360,450 450,840 840,1020
{ -} the application might
应用程序可能完全是恶意的，或许由攻击者编写的，

758
00:22:22,250 --> 00:22:24,620
0,540 570,1320 1320,1740 1740,2070 2070,2370
be definitely malicious, maybe written

759
00:22:24,620 --> 00:22:27,350
0,600 870,1260 1260,1950 2040,2610 2610,2730
by an attacker| and the
|攻击者可以想打破应用程序，获得内核控制权，

760
00:22:27,350 --> 00:22:29,030
0,480 480,1170 1170,1380 1380,1560 1560,1680
attacker probably would like to

761
00:22:29,030 --> 00:22:31,010
0,390 390,570 570,690 690,1080 1080,1980
break out of the application

762
00:22:31,010 --> 00:22:32,210
0,330 330,420 420,570 570,1020 1020,1200
{for,example} and take control over

763
00:22:32,210 --> 00:22:33,500
0,90 90,630 780,1050 1050,1230 1230,1290
the kernel,| and once you
|一旦控制了内核，你就可以做任何事情，

764
00:22:33,500 --> 00:22:34,550
0,120 120,420 420,540 540,630 630,1050
have control over the kernel,

765
00:22:34,550 --> 00:22:35,660
0,330 330,570 570,660 660,750 750,1110
then you can do anything,|
|

766
00:22:35,660 --> 00:22:37,130
0,390 600,720 720,1050 1050,1320 1320,1470
because the kernel is in
因为内核控制着所有硬件资源。

767
00:22:37,130 --> 00:22:38,210
0,420 420,510 510,660 660,720 720,1080
control of all the hardware

768
00:22:38,210 --> 00:22:39,260
0,690
resources.|
|

769
00:22:39,320 --> 00:22:40,370
0,330 330,420 420,510 510,840 840,1050
And so the operating system
所以操作系统必须编写成防御性的，

770
00:22:40,370 --> 00:22:40,940
0,120 120,180 180,330 330,480 480,570
has to be able to

771
00:22:40,940 --> 00:22:41,660
0,180 180,330 330,390 390,510 510,720
[], has to be written

772
00:22:41,660 --> 00:22:43,940
0,900 1110,1650 1650,1740 1740,1830 1830,2280
defensively,| {} you know to
|防止出现这种事情。

773
00:22:43,940 --> 00:22:45,980
0,780 810,1320 1320,1530 1530,1620 1620,2040
avoid those kinds of things.|
|

774
00:22:46,640 --> 00:22:47,780
0,270 270,510 510,720 750,1050 1050,1140
{ -} This turns out
实现这个目标是很有技巧的，

775
00:22:47,780 --> 00:22:49,220
0,60 60,150 150,420 420,930 960,1440
to be very tricky to

776
00:22:49,250 --> 00:22:51,020
0,330 330,540 540,930 1140,1650 1650,1770
actually get right,| {} {you,know},
|实际上，在 Linux 中，仍然有偶发的 bug ，

777
00:22:51,020 --> 00:22:52,340
0,120 120,360 360,750 750,1230 1230,1320
in fact in Linux, you

778
00:22:52,340 --> 00:22:54,710
0,120 120,300 300,990 1260,1890 1890,2370
know they're still periodic bugs,|
|

779
00:22:54,710 --> 00:22:56,030
0,90 90,150 150,480 480,780 780,1320
you know kernel bugs or
内核 bug ，这些 bug 允许应用程序打破隔离，并获得控制权。

780
00:22:56,030 --> 00:22:57,500
0,270 270,360 360,600 600,1260 1320,1470
bugs that actually allow an

781
00:22:57,500 --> 00:23:00,380
0,540 540,1290 1290,1740 1740,1980 2520,2880
applications exploited or to break

782
00:23:00,380 --> 00:23:01,940
0,180 180,270 270,420 420,990 990,1560
out of this isolation domain

783
00:23:02,000 --> 00:23:03,760
0,300 300,840 840,1350
and take control.|
|

784
00:23:03,980 --> 00:23:05,180
0,450 480,690 690,840 840,1020 1020,1200
{} But it's just a
但是这是一个持续性的问题，我们要尽可能的做好这项工作。

785
00:23:05,330 --> 00:23:06,800
0,390 390,900 900,1200 1200,1320 1320,1470
continuous concern and we'd like

786
00:23:06,800 --> 00:23:07,550
0,60 60,210 210,330 330,480 480,750
to do a good job

787
00:23:07,550 --> 00:23:08,680
0,90 90,570
as possible.|
|

788
00:23:08,800 --> 00:23:09,910
0,240 240,390 390,600 600,690 690,1110
And this is the mindset
这就是你开发内核时要有的思维模式，

789
00:23:09,910 --> 00:23:10,960
0,120 120,210 210,300 300,690 690,1050
you have to have, when

790
00:23:10,960 --> 00:23:12,160
0,150 150,540 540,630 630,960 960,1200
you're developing a kernel,| that
|实际的应用程序可能是恶意的。

791
00:23:12,280 --> 00:23:16,450
0,540 540,1140 1140,2280 3150,3570 3570,4170
actually applications are perhaps malicious.|
|

792
00:23:17,260 --> 00:23:19,390
0,600 840,1080 1080,1410 1410,1620 1620,2130
{You,know}, this means that means
这意味着在应用程序和操作系统之间必须有强隔离。

793
00:23:19,390 --> 00:23:20,590
0,240 240,390 390,450 450,570 570,1200
it has to be strong

794
00:23:20,590 --> 00:23:22,040
0,900
isolation

795
00:23:26,640 --> 00:23:28,460
0,570 570,660 660,1290
between the apps

796
00:23:31,500 --> 00:23:32,840
0,240 240,840
and OS.|
|

797
00:23:34,470 --> 00:23:36,060
0,180 180,300 300,780 780,990 1140,1590
If the OS {you,know} need
如果操作系统需要是防御性的，需要处于可防御的位置，

798
00:23:36,060 --> 00:23:37,980
0,120 120,240 240,930 930,1470 1500,1920
to be defensive and needs

799
00:23:37,980 --> 00:23:38,640
0,60 60,150 150,240 240,300 300,660
to be in a position

800
00:23:38,640 --> 00:23:39,900
0,150 150,270 270,360 360,930 990,1260
that can be defensive,| there
|在应用程序之间必须有一道坚固的屏障，

801
00:23:39,900 --> 00:23:40,920
0,150 150,210 210,390 390,510 510,1020
has to be a strong

802
00:23:40,920 --> 00:23:42,360
0,270 270,540 540,600 600,1320 1320,1440
wall between the applications,| so
|让操作系统可以真正执行它想执行的任何策略。

803
00:23:42,360 --> 00:23:43,380
0,180 180,330 330,600 600,900 900,1020
that the operating system can

804
00:23:43,380 --> 00:23:45,720
0,270 270,960 1170,1740 1740,2220 2220,2340
actually enforce whatever policies it

805
00:23:45,720 --> 00:23:47,040
0,240 240,300 300,930
wants to enforce.|
|

806
00:23:47,530 --> 00:23:49,000
0,270 270,450 450,570 570,990 990,1470
And this is typically done,
这通常，实现强隔离的常用方法是硬件支持。

807
00:23:49,300 --> 00:23:50,740
0,210 210,510 510,900 900,960 960,1440
the typical approach to achieving

808
00:23:50,740 --> 00:23:53,200
0,150 150,690 690,1530 1680,2160 2160,2460
this strong isolation is using

809
00:23:53,200 --> 00:23:54,540
0,300 300,780
hardware support.|
|

810
00:23:57,880 --> 00:23:58,510
0,150 150,240 240,390 390,450 450,630
And we get a little
在这节课中，我们稍微了解一下，

811
00:23:58,510 --> 00:23:59,410
0,120 120,180 180,570 570,630 630,900
bit of flavor of that

812
00:23:59,410 --> 00:24:00,400
0,90 90,450 450,750 750,870 870,990
in this lecture,| but we'll
|但是我们在后面的课程中会深入更多细节。

813
00:24:00,400 --> 00:24:01,060
0,90 90,330 330,450 450,570 570,660
come back to it in

814
00:24:01,060 --> 00:24:02,170
0,210 210,330 330,630 630,720 720,1110
much more detail in subsequent

815
00:24:02,170 --> 00:24:04,210
0,330 330,570 750,1290 1620,1890 1890,2040
lectures.| And two, {} two
|有两种方式的硬件支持，

816
00:24:04,210 --> 00:24:06,040
0,300 300,360 360,480 480,1050 1200,1830
parts of the hardware support,|
|

817
00:24:06,310 --> 00:24:08,110
0,720 840,1200 1200,1440 1440,1590 1590,1800
one is something that's called
一种称为用户内核模式， /kernel 模式，

818
00:24:08,110 --> 00:24:09,620
0,270 270,570 570,1020
user kernel mode,

819
00:24:10,280 --> 00:24:12,060
0,480 480,780 780,1200
slash kernel mode,|
|

820
00:24:12,500 --> 00:24:13,550
0,210 210,450 450,720 720,810 810,1050
in {RISC-V -} is called
在 RISC-V 中称为管理者模式，但是是一种东西。

821
00:24:13,550 --> 00:24:14,900
0,570 570,990 990,1110 1110,1260 1260,1350
supervised mode, but it's the

822
00:24:14,900 --> 00:24:16,120
0,210 210,660
same thing.|
|

823
00:24:16,260 --> 00:24:18,300
0,450 450,690 690,1170 1200,1650 1650,2040
{} And then page tables,
另一种是页表，虚拟内存。

824
00:24:18,300 --> 00:24:19,700
0,390 390,840
virtual memory.|
|

825
00:24:24,240 --> 00:24:26,550
0,210 210,690 690,1590 1770,2160 2160,2310
So all processors, {} sort
所有处理器，想要运行多应用程序操作系统的处理器，

826
00:24:26,550 --> 00:24:28,860
0,60 60,600 600,990 990,1620 1920,2310
of all series processors, {}

827
00:24:28,860 --> 00:24:30,630
0,330 330,510 510,960 960,1140 1140,1770
that are intended to run

828
00:24:30,630 --> 00:24:32,700
0,120 120,480 480,900 900,1200 1200,2070
an operating system multiple applications|
|

829
00:24:32,910 --> 00:24:35,370
0,270 270,660 660,1320 1320,2190 2190,2460
{} have support for user
都支持用户内核模式和虚拟内存，

830
00:24:35,370 --> 00:24:36,660
0,270 270,570 570,690 690,960 960,1290
kernel mode and virtual memory,|
|

831
00:24:36,690 --> 00:24:37,410
0,60 60,240 240,390 390,600 600,720
you know it might be
它可能表现或实现有些许不同，

832
00:24:37,410 --> 00:24:38,940
0,390 390,780 780,870 870,1350 1350,1530
{manifested -} were implemented in

833
00:24:38,940 --> 00:24:40,710
0,270 300,690 690,960 960,1440 1470,1770
a slightly different ways,| but
|

834
00:24:40,710 --> 00:24:42,680
0,480 480,1020 1020,1440
basically {all,processors} {have,it}.|
但是基本上所有处理器都有它。|

835
00:24:43,160 --> 00:24:44,600
0,480 570,780 780,990 990,1230 1230,1440
{} And our {RISC-V -}
我们在课程中使用的 RISC-V 处理器也有支持。

836
00:24:44,600 --> 00:24:45,920
0,540 540,720 720,900 900,1230 1230,1320
processor that we're using in

837
00:24:45,920 --> 00:24:48,470
0,360 600,1200 1230,1980 1980,2160 2160,2550
this class has that support

838
00:24:48,470 --> 00:24:49,320
0,300
too.|
|

839
00:24:49,440 --> 00:24:50,250
0,180 180,510 510,570 570,780 780,810
So let me talk a
所以，我来讲一下，

840
00:24:50,250 --> 00:24:51,150
0,210 210,600 630,720 720,840 840,900
little bit,| I'm going to
|我会先讲一下用户模式，内核模式，

841
00:24:51,150 --> 00:24:51,810
0,120 120,150 150,330 330,450 450,660
talk a little bit about

842
00:24:51,810 --> 00:24:53,520
0,240 240,660 780,1140 1140,1350 1350,1710
user mode, kernel mode first|
|

843
00:24:53,520 --> 00:24:54,000
0,90 90,240 240,330 330,480 480,480
and then we'll talk a
然后讲一下虚拟内存。

844
00:24:54,000 --> 00:24:55,230
0,240 240,390 390,600 600,870 870,1230
little bit about virtual memory,|
|

845
00:24:55,760 --> 00:24:57,200
0,300 300,660 660,1140 1140,1200 1200,1440
{} and mostly at the
主要从宏观角度，

846
00:24:57,230 --> 00:25:00,020
0,420 420,840 960,1890 2250,2640 2640,2790
highest level possible,| because there's
|因为这里面有很多重要的细节，

847
00:25:00,020 --> 00:25:01,310
0,60 60,300 300,390 390,780 780,1290
a lot of important details,|
|

848
00:25:01,310 --> 00:25:02,030
0,210 210,330 330,510 510,600 600,720
but I won't be able
但这节课并不能包含这些。

849
00:25:02,030 --> 00:25:02,780
0,60 60,270 270,510 510,600 600,750
to cover those in this

850
00:25:02,780 --> 00:25:03,660
0,300
lecture.|
|

851
00:25:04,840 --> 00:25:05,830
0,210 210,360 360,570 570,750 750,990
So let's first talk about
我们先来讨论一下用户内核模式，

852
00:25:05,830 --> 00:25:07,340
0,240 240,510 510,930
user kernel mode,|
|

853
00:25:14,600 --> 00:25:15,980
0,330 330,720 720,930 930,1050 1050,1380
and basically what it means
基本上就是处理器有两种操作模式，

854
00:25:15,980 --> 00:25:17,090
0,120 120,300 300,390 390,780 780,1110
is that the processor has

855
00:25:17,090 --> 00:25:19,100
0,270 270,870 870,960 960,1680 1770,2010
two modes of operation| and
|一种是用户模式，另一种是内核模式。

856
00:25:19,100 --> 00:25:20,570
0,300 300,390 390,750 750,1170 1290,1470
one is user mode and

857
00:25:20,570 --> 00:25:21,680
0,90 90,240 240,390 390,480 480,1110
the other one is {kernel,mode}.|
|

858
00:25:22,350 --> 00:25:24,120
0,510 510,870 870,1290 1290,1440 1440,1770
And when running in kernel
当运行在内核模式， CPU 可以执行特权指令，

859
00:25:24,120 --> 00:25:25,100
0,420
mode,

860
00:25:25,420 --> 00:25:27,730
0,390 390,1200 1230,1470 1470,1920 1920,2310
the CPU can execute privileged

861
00:25:27,730 --> 00:25:29,000
0,750
instructions,|
|

862
00:25:35,510 --> 00:25:36,890
0,210 210,420 420,480 480,990 990,1380
[] back to the second
[]回到第二[]。

863
00:25:36,890 --> 00:25:38,540
0,330 420,1050 1050,1260 1260,1380 1380,1650
[].| When running in user
|当运行在用户模式， CPU 只能执行非特权指令。

864
00:25:38,540 --> 00:25:39,620
0,480
mode,

865
00:25:39,710 --> 00:25:41,840
0,480 480,600 600,1080 1080,1560 1560,2130
CPU can only execute in

866
00:25:41,840 --> 00:25:43,600
0,450 450,1140
unprivileged instructions.|
|

867
00:25:49,980 --> 00:25:51,240
0,180 180,600 600,660 660,1140 1140,1260
And {unprivileged -} instructions, the
非特权指令，你已经很熟悉了，

868
00:25:51,240 --> 00:25:52,650
0,330 330,510 510,690 690,1110 1110,1410
instructions you're well familiar with,|
|

869
00:25:52,680 --> 00:25:53,730
0,90 90,330 330,600 600,870 870,1050
you know, think about like
比如 add sub ，对两个寄存器做加法或减法，

870
00:25:53,730 --> 00:25:56,490
0,600 630,1290 1830,2160 2160,2580 2610,2760
add sub, adding two two

871
00:25:56,490 --> 00:25:58,200
0,360 360,990 990,1050 1050,1170 1170,1710
registers together, you know subtracting

872
00:25:58,200 --> 00:25:59,370
0,120 120,660 660,840 840,960 960,1170
two register,| so it's really
|所以这是很普通的，还有程序调用 jr ，所有分支指令，

873
00:25:59,370 --> 00:26:02,010
0,570 570,750 750,1050 1350,1920 1920,2640
[basic], you know procedure calls

874
00:26:02,280 --> 00:26:03,900
0,240 240,1140 1170,1380 1380,1500 1500,1620
{you,know} jr, all that kind

875
00:26:03,900 --> 00:26:05,850
0,60 60,360 360,1200 1410,1830 1830,1950
of stuff branches,| those are
|这些都是非特权指令，任何用户程序都可以执行。

876
00:26:05,850 --> 00:26:06,820
0,540
all

877
00:26:07,420 --> 00:26:09,100
0,450 450,630 630,960 960,1500 1500,1680
{} {unprivileged -} instructions, that

878
00:26:09,100 --> 00:26:10,480
0,330 330,600 600,1050 1050,1140 1140,1380
any user application is allowed

879
00:26:10,480 --> 00:26:11,660
0,90 90,600
to execute.|
|

880
00:26:11,970 --> 00:26:14,220
0,570 570,960 960,1350 1530,2010 2010,2250
Privileged instructions are instructions that
特权指令是引入直接操作硬件的指令，

881
00:26:14,280 --> 00:26:17,550
0,690 750,990 990,1650 1650,2280 2580,3270
basically are involved in {}

882
00:26:17,580 --> 00:26:19,290
0,540 540,600 600,960 960,1650 1650,1710
manipulating the hardware directly,| you
|设置保护或类似的东西，

883
00:26:19,290 --> 00:26:21,330
0,150 150,450 450,570 570,1320 1560,2040
know setting up protections and

884
00:26:21,330 --> 00:26:22,110
0,180 180,330 330,570 570,690 690,780
things like that,| so for
|比如配置页表寄存器，我们后面会谈到，

885
00:26:22,110 --> 00:26:23,190
0,360 360,630 630,750 750,780 780,1080
example setting up a page

886
00:26:23,190 --> 00:26:24,520
0,360 360,840
table register,

887
00:26:27,470 --> 00:26:28,730
0,210 210,330 330,540 540,780 780,1260
which we'll talk about later,|
|

888
00:26:28,850 --> 00:26:31,600
0,330 330,1170 1410,2070
{} or {},
或者设置禁止时钟中断。

889
00:26:31,840 --> 00:26:33,760
0,120 120,420 780,1110 1110,1320 1320,1920
you know setting the disabling

890
00:26:33,760 --> 00:26:35,200
0,300 300,870
clock interrupts.|
|

891
00:26:39,350 --> 00:26:40,010
0,150 150,270 270,330 330,450 450,660
So there are all kinds
所以，处理器中有各种类型的状态，

892
00:26:40,010 --> 00:26:41,000
0,90 90,300 300,360 360,870 870,990
of sort of state on

893
00:26:41,000 --> 00:26:42,740
0,60 60,840 1110,1290 1290,1380 1380,1740
the processor,| that the operating
|操作系统使用操作这些状态，

894
00:26:42,740 --> 00:26:44,960
0,480 480,930 930,1020 1020,1500 1620,2220
system intended to use and

895
00:26:44,960 --> 00:26:46,520
0,600 600,780 780,1260 1260,1380 1380,1560
manipulating that state| you know
|都是由特权指令完成的。

896
00:26:46,520 --> 00:26:49,040
0,660 660,1770 1770,1980 1980,2100 2100,2520
completely {} done, for privileged

897
00:26:49,040 --> 00:26:50,160
0,690
instructions.|
|

898
00:26:50,360 --> 00:26:51,200
0,120 120,270 270,330 330,660 660,840
And so, for example when
所以当用户程序试图执行特权指令，

899
00:26:51,200 --> 00:26:52,970
0,60 60,360 360,1050 1110,1680 1680,1770
a user application tries to

900
00:26:52,970 --> 00:26:54,800
0,270 270,750 750,780 780,1170 1170,1830
actually execute a privilege instruction,|
|

901
00:26:55,280 --> 00:26:57,020
0,300 300,690 690,1020 1050,1440 1440,1740
{} then the processor rules
处理器规则不会执行，因为特权指令在用户模式下是不允许的，

902
00:26:57,020 --> 00:26:58,490
0,300 300,840 870,1290 1290,1410 1410,1470
won't execute, because if {privileged

903
00:26:58,490 --> 00:27:00,140
0,270 270,990 990,1320 1320,1500 1500,1650
-} instruction {in,user,mode -} is

904
00:27:00,140 --> 00:27:02,060
0,690 930,1200 1200,1560 1560,1710 1710,1920
disallowed| and basically that will
|这会引起控制从用户模式到内核模式，

905
00:27:02,240 --> 00:27:04,670
0,810 810,900 900,1170 1200,1740 1740,2430
result in the transfer control

906
00:27:04,760 --> 00:27:06,170
0,270 270,540 540,990 990,1200 1200,1410
from user space from user

907
00:27:06,170 --> 00:27:07,100
0,210 210,300 300,570 570,840 840,930
mode to kernel mode,| so
|让操作系统获得控制权，

908
00:27:07,100 --> 00:27:08,150
0,150 150,330 330,480 480,780 780,1050
that then the operating system

909
00:27:08,150 --> 00:27:09,260
0,150 150,390 390,540 540,1020 1020,1110
can actually take control| and
|如果应用程序有问题，就可以杀掉它。

910
00:27:09,260 --> 00:27:09,980
0,210 210,300 300,390 390,630 630,720
maybe {[] -} kill the

911
00:27:09,980 --> 00:27:12,260
0,630 630,870 870,990 990,1830
application because of misbehaving.|
|

912
00:27:12,970 --> 00:27:14,680
0,390 900,1230 1230,1290 1290,1590 1590,1710
To get a little bit
为了进一步理解特权指令和非特权指令的不同，

913
00:27:14,680 --> 00:27:16,630
0,120 120,630 1050,1380 1380,1650 1650,1950
of sense, {} the difference

914
00:27:16,630 --> 00:27:17,830
0,360 360,420 420,660 660,810 810,1200
between the two and privileged

915
00:27:17,830 --> 00:27:20,350
0,120 120,600 600,1230 1560,2250 2280,2520
and unprivileged instructions,| {} let
|让我切换一下显示内容。

916
00:27:20,350 --> 00:27:22,390
0,90 90,690 840,1380 1380,1500 1500,2040
me switch display for second.|
|

917
00:27:22,920 --> 00:27:23,970
0,330 330,600 600,690 690,810 810,1050
And here on the right
这里右边显示的是一个文档， RISC-V 特权架构文档，

918
00:27:23,970 --> 00:27:25,470
0,480 510,600 600,720 720,930 930,1500
side, you have a display

919
00:27:25,590 --> 00:27:26,880
0,330 330,420 420,480 480,1140 1170,1290
{} is a document, you

920
00:27:26,880 --> 00:27:30,240
0,480 570,990 990,1590 2010,2610 2610,3360
know {the,RISC-V -} privileged architecture

921
00:27:30,270 --> 00:27:32,940
0,810 1260,1560 1560,1710 1710,2130 2130,2670
document| and that document contains
|这个文档包含所有特权指令，

922
00:27:32,940 --> 00:27:34,380
0,150 150,240 240,540 540,1170 1170,1440
all the privileged instructions,| it's
|在网站（6.S081 课程主页）的 References 页面有它的链接，

923
00:27:34,380 --> 00:27:36,690
0,300 300,480 480,540 540,1200 1560,2310
linked from the website, {}

924
00:27:36,690 --> 00:27:39,360
0,510 510,990 1020,1500 1500,2010 2190,2670
under the References page| and
|在接下来的几周或几乎一个月内，

925
00:27:39,360 --> 00:27:41,100
0,390 390,840 930,1350 1350,1680 1680,1740
in the next couple of

926
00:27:41,100 --> 00:27:43,800
0,570 630,1110 1110,1500 1800,2250 2250,2700
weeks {} or almost months,|
|

927
00:27:43,830 --> 00:27:44,910
0,270 270,390 390,540 540,780 780,1080
{you,know}, you will be playing
你会用到这里看到的所有特权指令，

928
00:27:44,910 --> 00:27:46,380
0,540 540,720 720,930 930,1260 1260,1470
around you know all these

929
00:27:46,380 --> 00:27:47,970
0,330 330,900 900,1110 1110,1200 1200,1590
privileged instructions, that you know

930
00:27:48,420 --> 00:27:50,070
0,270 270,540 810,1200 1200,1500 1530,1650
{} are shown here| and
|事实上，它们中的大多数会在下节课中出现，包含大量细节。

931
00:27:50,070 --> 00:27:51,360
0,60 60,390 450,840 840,930 930,1290
in fact many of them

932
00:27:51,360 --> 00:27:53,130
0,360 450,810 810,960 960,1500 1530,1770
will show up and some

933
00:27:53,130 --> 00:27:53,820
0,90 90,240 240,390 390,510 510,690
of them [want] to show

934
00:27:53,820 --> 00:27:54,720
0,120 120,210 210,300 300,540 540,900
up in the next lecture

935
00:27:54,720 --> 00:27:55,380
0,90 90,180 180,420 420,600 600,660
in the great amount of

936
00:27:55,380 --> 00:27:56,020
0,420
detail.|
|

937
00:27:56,280 --> 00:27:57,660
0,360 390,600 600,930 930,1140 1140,1380
{} But usually think about
可以这样想，

938
00:27:57,660 --> 00:27:59,370
0,240 240,660 750,1110 1110,1410 1410,1710
this as| there are privileged
|用户程序不能执行特权指令，

939
00:27:59,370 --> 00:28:01,050
0,720 720,840 840,1080 1080,1560 1560,1680
instructions that user applications should

940
00:28:01,050 --> 00:28:02,160
0,180 180,270 270,420 420,480 480,1110
not be able to execute|
|

941
00:28:02,370 --> 00:28:03,420
0,270 270,600 600,750 750,960 960,1050
and those can only be
它们指令在内核模式下执行。

942
00:28:03,420 --> 00:28:05,000
0,450 450,510 510,810 810,1050
executed in kernel mode.|
|

943
00:28:05,790 --> 00:28:08,160
0,210 210,480 480,960 960,1620 1920,2370
So that's one aspect of
所以，这是硬件支持强隔离的一个方面。

944
00:28:08,160 --> 00:28:08,880
0,90 90,210 210,390 390,660 660,720
you know this sort of

945
00:28:08,880 --> 00:28:10,800
0,360 360,810 810,930 930,1200 1200,1920
hardware support for strong isolation.|
|

946
00:28:11,350 --> 00:28:13,030
0,630 660,900 900,1170 1170,1230 1230,1680
{} Yeah, Amanda, go ahead.|
好的， Amanda ，请继续。|

947
00:28:13,750 --> 00:28:15,310
0,240 240,630 630,870 870,1260 1260,1560
Just a quick question,| like,
一个小问题，|比如我想的是如果内核模式允许或不允许，

948
00:28:15,820 --> 00:28:17,800
0,300 450,1140 1170,1380 1380,1500 1500,1980
{} the what I'm imagining

949
00:28:17,800 --> 00:28:18,760
0,120 120,270 270,510 510,660 660,960
in my head is something

950
00:28:18,760 --> 00:28:20,920
0,270 270,540 540,990 990,1410 1410,2160
like if kernel mode allow

951
00:28:20,950 --> 00:28:23,200
0,480 480,960 960,1110 1110,1590 1830,2250
else don't,| like what, who
|那么谁运行的检查代码，判断是否是内核模式，

952
00:28:23,200 --> 00:28:24,910
0,360 480,930 930,1170 1170,1560 1560,1710
is running that code and

953
00:28:24,910 --> 00:28:26,110
0,390 390,570 570,720 720,990 990,1200
checking if it's kernel mode|
|

954
00:28:26,110 --> 00:28:26,920
0,120 120,270 270,360 360,540 540,810
and how do they know
它们如何知道处于内核模式，是有一个标志或者其他东西吗？

955
00:28:26,920 --> 00:28:28,060
0,180 180,330 330,450 450,810 810,1140
if it's in kernel mode,

956
00:28:28,210 --> 00:28:29,560
0,300 300,390 390,750 750,840 840,1350
like a flag or something?|
|

957
00:28:29,770 --> 00:28:31,150
0,360 360,510 510,900 900,1290 1290,1380
Yeah, so basically {flag,in} the
是的，一般在处理器中有一个标志，

958
00:28:31,150 --> 00:28:33,880
0,570 840,1590 1590,1890 1890,2310 2310,2730
processor,| literally there's a bit
|在处理器中有一个标志位，用户模式使用 1 ，

959
00:28:33,910 --> 00:28:35,440
0,240 240,390 390,960 960,1200 1200,1530
in the processor, that's just

960
00:28:35,440 --> 00:28:36,850
0,90 90,300 300,900 900,1350 1350,1410
you know user mode you

961
00:28:36,850 --> 00:28:38,640
0,240 270,660 660,900 930,1350
know one is saying,|
|

962
00:28:38,640 --> 00:28:40,410
0,660 720,1050 1050,1350 1350,1500 1500,1770
{} typically one is usual
一般 1 是用户模式， 0 是内核模式。

963
00:28:40,410 --> 00:28:41,760
0,240 240,630 630,750 750,1020 1020,1350
mode, zero is kernel mode.|
|

964
00:28:42,360 --> 00:28:43,530
0,450 450,570 570,690 690,780 780,1170
And so when the processor
所以当处理器解码指令时，检查操作码，

965
00:28:43,530 --> 00:28:45,600
0,390 390,450 450,1170 1500,2010 2010,2070
decodes an instruction, looks at

966
00:28:45,600 --> 00:28:46,890
0,90 90,300 300,720 810,1200 1200,1290
the {opcode -}| if the
|如果操作码是特权指令，并且那个位设置为 1 ，就会拒绝指定该指令。

967
00:28:46,890 --> 00:28:47,820
0,180 180,420 420,540 540,600 600,930
{opcode -} is a privilege

968
00:28:47,820 --> 00:28:50,190
0,750 750,1350 1350,1830 1980,2280 2280,2370
instruction and the bit is

969
00:28:50,190 --> 00:28:51,300
0,180 180,240 240,750 780,990 990,1110
set to one and will

970
00:28:51,300 --> 00:28:53,480
0,540 540,1050 1050,1200 1200,1650
deny executing that instruction.|
|

971
00:28:54,400 --> 00:28:56,260
0,390 390,630 630,780 780,1380
{You,know} divided by zero,
比如除零指令，就不允许执行。

972
00:28:56,320 --> 00:28:57,520
0,390 390,570 570,780 780,840 840,1200
you're not allowed to do

973
00:28:58,180 --> 00:28:59,200
0,450
that.|
|

974
00:28:59,200 --> 00:28:59,950
0,150 150,240 240,420 420,600 600,750
{Okay,but} if that bit has
好的，但是如果那一位以某种方式改变，

975
00:28:59,950 --> 00:29:01,570
0,570 570,660 660,900 900,1200 1200,1620
changed in some way| you
|就可以覆盖用来控制的那一位。

976
00:29:01,570 --> 00:29:02,950
0,150 150,390 390,630 630,810 810,1380
were just able to overwrite

977
00:29:02,950 --> 00:29:04,690
0,240 240,570 570,1020 1260,1650 1650,1740
that bit then that's the

978
00:29:04,690 --> 00:29:06,340
0,240 240,420 420,1140 1320,1500 1500,1650
only thing controlling.| Yeah, so
|是的，你认为可以覆盖那一位的指令，

979
00:29:06,340 --> 00:29:07,900
0,510 510,570 570,690 690,1080 1080,1560
what do you think what

980
00:29:07,930 --> 00:29:09,700
0,570 570,690 690,1110 1110,1500 1500,1770
instruction that overwrites a bit|
|

981
00:29:09,700 --> 00:29:11,050
0,120 120,300 300,510 510,870 870,1350
is that a privileged instruction
它是特权指令还是非特权指令。

982
00:29:11,050 --> 00:29:12,660
0,630 630,1110
{or,unprivileged} instruction.|
|

983
00:29:19,440 --> 00:29:20,880
0,120 120,240 240,270 270,870
Is there a question.|
有什么问题吗。|

984
00:29:22,970 --> 00:29:25,820
0,780 780,1170 1500,2160 2340,2700 2700,2850
Clearly the instruction sets the
设置那一位的指令当然是特权指令，

985
00:29:25,820 --> 00:29:27,560
0,330 360,690 690,840 840,1200 1200,1740
bit must be privileged instruction,|
|

986
00:29:27,560 --> 00:29:29,120
0,240 240,300 300,600 600,1230 1320,1560
because the user application should
因为用户程序不允许把那一位设置为内核模式，

987
00:29:29,120 --> 00:29:29,960
0,180 180,300 300,540 540,630 630,840
not be able to set

988
00:29:29,960 --> 00:29:31,070
0,60 60,390 390,510 510,810 810,1110
the bit to kernel mode,

989
00:29:31,070 --> 00:29:32,450
0,300 300,390 390,1080 1080,1200 1200,1380
correct| and then be able
|让它能够执行所有特权指令。

990
00:29:32,450 --> 00:29:34,310
0,150 150,420 420,1530 1530,1680 1680,1860
to actually run all kinds

991
00:29:34,310 --> 00:29:35,720
0,60 60,390 390,990
of privileged instructions,|
|

992
00:29:36,000 --> 00:29:36,630
0,150 150,240 240,390 390,540 540,630
and so that bit is
所以那一位是受保护的。

993
00:29:36,630 --> 00:29:37,780
0,600
protected.|
|

994
00:29:39,200 --> 00:29:40,560
0,120 120,210 210,360 360,720
Does that make sense?|
理解了吗？|

995
00:29:40,770 --> 00:29:42,320
0,480 600,990
Okay, yeah.|
好的，是的。|

996
00:29:44,130 --> 00:29:46,110
0,450 510,870 870,1170 1170,1560 1560,1980
{} Okay good,| so, {}
好的，|这就是用户内核模式，或者宏观的用户内核模式，

997
00:29:46,140 --> 00:29:46,860
0,150 150,300 300,450 450,510 510,720
so that's {user -} kernel

998
00:29:46,860 --> 00:29:48,270
0,360 360,480 480,570 570,900 1260,1410
mode or at least the

999
00:29:48,270 --> 00:29:50,130
0,270 270,810 1050,1410 1410,1620 1620,1860
top view user kernel mode,|
|

1000
00:29:50,160 --> 00:29:51,360
0,450 450,570 570,660 660,870 870,1200
turns out to {RISC-V -}
RISC-V 还有第三种模式，就是你们问到的，称为机器模式，

1001
00:29:51,360 --> 00:29:52,800
0,330 330,630 840,1230 1230,1320 1320,1440
has a number of, you

1002
00:29:52,800 --> 00:29:54,270
0,300 300,630 630,900 900,1110 1140,1470
asked about, have a third

1003
00:29:54,270 --> 00:29:56,490
0,330 330,540 540,870 870,1260 1650,2220
mode called machine mode,| we're
|我们可以忽略它，

1004
00:29:56,580 --> 00:29:57,630
0,210 210,480 480,600 600,660 660,1050
we're mostly going to ignore

1005
00:29:57,630 --> 00:29:58,920
0,420 450,810 810,930 930,1020 1020,1290
that| and so I'm not
|我不准备讲它，

1006
00:29:58,920 --> 00:30:00,510
0,240 240,390 390,690 690,900 930,1590
going say about it,| basically
|就是多了一级，有三级特权而不是两级。

1007
00:30:00,510 --> 00:30:01,620
0,90 90,480 480,720 720,900 900,1110
has one more level, because

1008
00:30:01,620 --> 00:30:03,030
0,330 330,540 540,810 810,900 900,1410
basically three levels of privilege

1009
00:30:03,030 --> 00:30:04,050
0,330 330,420 420,660 660,930 930,1020
instead of two levels of

1010
00:30:04,050 --> 00:30:05,060
0,300 390,690
privileges {}.|
|

1011
00:30:05,290 --> 00:30:06,740
0,150 150,420 420,570 570,870
{Amir -}, go ahead.|
Amir ，继续。|

1012
00:30:07,860 --> 00:30:09,180
0,330 330,450 450,660 660,1170 1170,1320
Alright, so I'm wondering with
好的，我想知道关于安全方面，

1013
00:30:09,180 --> 00:30:11,760
0,480 480,660 660,1260 1260,1650 1980,2580
respect to security,| if all
|如果所有用户代码通过内核，目的是为了安全，

1014
00:30:11,790 --> 00:30:13,200
0,390 390,780 780,1050 1050,1230 1230,1410
user code does go through

1015
00:30:13,200 --> 00:30:14,280
0,90 90,450 450,540 540,960 960,1080
the kernel, the intent is

1016
00:30:14,280 --> 00:30:15,780
0,180 180,420 420,510 510,990 1350,1500
that things are secure,| but
|但是有没有一种方式，

1017
00:30:15,780 --> 00:30:17,370
0,150 150,330 330,450 450,780 780,1590
is there a way,| for
|计算机的用户可以完全绕过操作系统。

1018
00:30:17,940 --> 00:30:19,380
0,510 510,690 690,1140 1140,1320 1320,1440
{} a user of the

1019
00:30:19,380 --> 00:30:22,950
0,750 1110,1320 1320,2550 2730,3150 3150,3570
computer to completely go around

1020
00:30:22,950 --> 00:30:24,640
0,120 120,570 570,1050
the operating system.|
|

1021
00:30:25,180 --> 00:30:27,100
0,330 330,540 540,960 1440,1620 1620,1920
No, not really, at least
不，不是，至少如果做的很小心，不会出现，

1022
00:30:27,100 --> 00:30:30,240
0,840 870,1440 1440,1950 1950,2550
if done carefully, not,|
|

1023
00:30:32,700 --> 00:30:34,170
0,210 210,510 510,1200 1200,1320 1320,1470
and if possible, you know
如果可能，出现一种情况，

1024
00:30:34,170 --> 00:30:34,980
0,180 180,360 360,450 450,510 510,810
that might be the case,|
|

1025
00:30:34,980 --> 00:30:36,450
0,270 270,450 450,930 930,1110 1110,1470
that some programs have additional
一些程序具有过多的操作系统相关的权限，

1026
00:30:36,450 --> 00:30:38,760
0,720 1080,1620 1620,1860 1860,1950 1950,2310
privileges {} that the operating

1027
00:30:38,760 --> 00:30:41,100
0,240 240,960 990,1830
system will respect,|
|

1028
00:30:41,100 --> 00:30:42,300
0,390 390,510 510,690 690,1110 1110,1200
{} but those privileges are
但是这些权限没有给每个用户，

1029
00:30:42,300 --> 00:30:43,500
0,210 210,420 420,510 510,750 750,1200
not given to every user|
|

1030
00:30:43,860 --> 00:30:45,360
0,150 150,570 570,630 630,1080 1080,1500
you know {} only root
只有 root 用户拥有特定权限，

1031
00:30:45,360 --> 00:30:47,220
0,300 300,540 540,750 750,1440 1740,1860
user has certain privileges,| that
|可以执行对安全敏感的操作。

1032
00:30:47,220 --> 00:30:48,630
0,300 300,420 420,510 510,990 1140,1410
allow you to do {}

1033
00:30:48,630 --> 00:30:52,260
0,450 450,870 870,1590 2610,2850 2850,3630
security sensitive operations.| {What,about} BIOS,
|那么 BIOS 呢， BIOS 是发生在操作系统之前还是之后。

1034
00:30:52,290 --> 00:30:54,660
0,270 270,1020 1050,1590 1620,1980 1980,2370
does BIOS {} happened before

1035
00:30:54,660 --> 00:30:56,790
0,480 480,870 870,1260 1260,1830 1860,2130
OS or after.| Yeah, so
|是的， BIOS 是同计算机一起的一个软件，

1036
00:30:56,790 --> 00:30:59,100
0,720 750,1230 1230,1380 1380,1560 1560,2310
the BIOS, this is a

1037
00:30:59,520 --> 00:31:01,050
0,300 300,360 360,840 840,960 960,1530
piece of software that basically

1038
00:31:01,050 --> 00:31:02,730
0,240 240,540 540,810 810,1110 1110,1680
{} comes with the computer,|
|

1039
00:31:02,970 --> 00:31:04,800
0,330 330,900 900,1110 1110,1530 1530,1830
{} and {} that's booted
它首先启动，并启动操作系统，

1040
00:31:04,800 --> 00:31:06,600
0,510 540,990 1020,1140 1140,1470 1470,1800
first and the BIOS basically

1041
00:31:06,600 --> 00:31:08,340
0,240 240,330 330,660 660,1170 1440,1740
boots the operating system {},|
|

1042
00:31:08,340 --> 00:31:09,240
0,120 120,210 210,540 540,660 660,900
so the BIOS is a
所以 BIOS 是一段可信任的代码，是正确的，没有恶意的。

1043
00:31:09,300 --> 00:31:11,140
0,330 330,510 510,630 630,1050
trusted piece of code,

1044
00:31:11,450 --> 00:31:12,740
0,150 150,330 330,420 420,930 960,1290
and better be correct and

1045
00:31:12,740 --> 00:31:14,720
0,210 210,570 570,930 930,1470
better be not malicious.|
|

1046
00:31:16,920 --> 00:31:18,500
0,360 360,600 600,690 690,1080
{Noah -}, go ahead.|
Noah ，继续。|

1047
00:31:19,320 --> 00:31:20,880
0,300 300,630 630,870 870,1050 1050,1560
{} Yeah, so you mentioned
是的，你提到设置内核模式标志位的指令是特权指令，

1048
00:31:20,880 --> 00:31:22,440
0,240 240,870 900,1050 1050,1170 1170,1560
that the, you know the

1049
00:31:22,470 --> 00:31:24,540
0,300 330,960 960,1230 1230,1740 1740,2070
{} instruction to set the

1050
00:31:24,690 --> 00:31:25,950
0,240 240,360 360,690 690,990 990,1260
{} the kernel mode bit

1051
00:31:25,950 --> 00:31:27,840
0,150 150,240 240,690 690,1380 1650,1890
is a privileged instruction,| how
|那么用户程序怎么能，让内核执行任何内核指令，

1052
00:31:27,840 --> 00:31:29,700
0,180 180,690 690,990 990,1560 1590,1860
would a user program ever,

1053
00:31:29,700 --> 00:31:31,020
0,210 210,330 330,540 540,1170 1230,1320
then be able to, you

1054
00:31:31,020 --> 00:31:33,660
0,480 570,1200 1200,1800 1920,2190 2190,2640
know get like {you,know} essentially

1055
00:31:33,660 --> 00:31:35,010
0,300 300,390 390,780 780,1200 1200,1350
have the kernel, execute any

1056
00:31:35,010 --> 00:31:37,260
0,330 330,990 990,1290 1530,1860 1860,2250
kernel instructions,| if like the
|比如获得内核模式的指令就是一个特权指令，

1057
00:31:37,290 --> 00:31:38,970
0,330 330,870 870,990 990,1410 1410,1680
very instructions to access kernel

1058
00:31:38,970 --> 00:31:40,500
0,330 540,780 780,1110 1110,1170 1170,1530
mode is itself a privileged

1059
00:31:40,500 --> 00:31:41,490
0,450 450,480 480,660 660,750 750,990
instruction,| I guess it seems
|我猜应该有一个直接的[]让用户可以修改那个位。

1060
00:31:41,490 --> 00:31:43,290
0,150 150,480 510,1260 1260,1350 1350,1800
like there's immediately a []

1061
00:31:43,290 --> 00:31:45,240
0,210 210,480 480,900 930,1500 1530,1950
for user program ever changing

1062
00:31:45,240 --> 00:31:46,060
0,450
{that,bit}.|
|

1063
00:31:46,060 --> 00:31:48,280
0,360 390,1260 1260,1470 1470,1890 1890,2220
Yeah, yeah that's correct and
是的，这是正确的，这就是我们想要的方式，

1064
00:31:48,280 --> 00:31:49,270
0,360 360,720 720,780 780,900 900,990
that's exactly the way we

1065
00:31:49,270 --> 00:31:51,100
0,240 240,390 390,750 1110,1650 1650,1830
want, that's correct,| {} so
|所以可以这样考虑，虽然不完全是 RISC-V 的工作方式，

1066
00:31:51,100 --> 00:31:51,910
0,180 180,300 300,390 390,540 540,810
one way to think about

1067
00:31:51,910 --> 00:31:52,930
0,240 240,480 480,720 720,810 810,1020
it, and this is not

1068
00:31:52,930 --> 00:31:54,190
0,330 330,450 450,540 540,840 840,1260
exactly how it works on

1069
00:31:54,190 --> 00:31:55,180
0,60 60,270 270,570 570,690 690,990
the {RISC-V -},| but if
|但是如果你在用户空间执行特权指令，试着执行特权指令……

1070
00:31:55,180 --> 00:31:57,580
0,480 690,1320 1320,1470 1470,1890 1890,2400
you execute a privilege instruction

1071
00:31:57,580 --> 00:31:58,570
0,90 90,330 330,600 600,720 720,990
in user space will try

1072
00:31:58,570 --> 00:31:59,980
0,90 90,690 690,840 840,1320 1320,1410
to execute a privileged the

1073
00:31:59,980 --> 00:32:01,460
0,540 540,900
instruction u-.|
|

1074
00:33:08,190 --> 00:33:09,900
0,300 300,570 570,960 960,1350 1350,1710
I'm back, sorry about that,
我回来了，不好意思，我的 zoom 客户端崩溃了。

1075
00:33:09,930 --> 00:33:12,090
0,120 120,480 480,660 660,1140 1590,2160
{} look like my zoom

1076
00:33:12,090 --> 00:33:15,700
0,720 840,2010 2160,2760 2760,3090
client crashed on me.|
|

1077
00:33:17,430 --> 00:33:18,480
0,120 120,690 690,810 810,900 900,1050
I apologize for that I
抱歉，我也不知道怎么回事，但是发生了。

1078
00:33:18,480 --> 00:33:20,370
0,180 180,360 360,540 540,1200 1440,1890
don't really know why, but

1079
00:33:20,370 --> 00:33:21,420
0,60 60,420
it did.|
|

1080
00:33:21,570 --> 00:33:23,000
0,900

1081
00:33:25,600 --> 00:33:26,800
0,210 210,510 510,690 690,780 780,1200
Can everybody hear me again.|
大家能听到我说话吗。|

1082
00:33:27,860 --> 00:33:29,360
0,300 300,420 420,690 1050,1230 1230,1500
Yep, you're good.| All good.|
是的，好的。|好的。|

1083
00:33:29,660 --> 00:33:30,760
0,180 180,510
All right.|
好的。|

1084
00:33:31,460 --> 00:33:34,880
0,570 630,960 960,1260 1260,1320 1320,3420
Well there's somewhere a bug.|
好的，某个地方有个 bug 。|

1085
00:33:35,240 --> 00:33:39,830
0,1200 1530,2310 2340,3000 3000,3840 3840,4590
Okay, {} back to {},
好的，回到硬件支持的第二部分，

1086
00:33:42,060 --> 00:33:43,980
0,270 270,540 540,1050 1140,1710 1740,1920
back to a second piece

1087
00:33:43,980 --> 00:33:45,510
0,90 90,270 270,360 360,900 1290,1530
of {hardware -} support| and
|几乎所有 CPU 都提供了， CPU 提供的虚拟内存。

1088
00:33:45,510 --> 00:33:47,100
0,210 210,480 480,660 660,1020 1020,1590
which almost all CPU provide

1089
00:33:47,370 --> 00:33:49,290
0,390 390,660 660,990 990,1530 1530,1920
{} witch {} {CPUs -}

1090
00:33:49,980 --> 00:33:51,820
0,660 660,930 930,1290
provide virtual memory.|
|

1091
00:34:02,890 --> 00:34:03,670
0,240 240,360 360,420 420,570 570,780
I'm going to talk about
周三我会讲到更多细节，

1092
00:34:03,670 --> 00:34:05,170
0,180 180,330 330,900 900,1050 1050,1500
this on Wednesday in much

1093
00:34:05,170 --> 00:34:08,260
0,270 330,1710 1860,2460 2460,2910 2910,3090
more detail,| but basically the
|但是基本上，处理器有一个叫做页表的东西。

1094
00:34:08,260 --> 00:34:09,430
0,360 360,480 480,930 930,1020 1020,1170
processor have something you know

1095
00:34:09,430 --> 00:34:10,300
0,210 210,330 330,570 570,600 600,870
what it's called a page

1096
00:34:10,300 --> 00:34:11,340
0,480
table.|
|

1097
00:34:12,180 --> 00:34:13,230
0,270 270,630 630,870 870,990 990,1050
And you've seen this a
你们应该已经在 6.004 中看到了，

1098
00:34:13,230 --> 00:34:14,550
0,210 210,390 390,480 480,960 960,1320
little bit I think {6.004

1099
00:34:14,550 --> 00:34:16,350
0,510 540,720 720,960 960,1380 1380,1800
-},| the page table, basically
|页表就是将虚拟地址映射到物理地址。

1100
00:34:16,350 --> 00:34:18,560
0,510 510,960 960,1620
maps virtual addresses

1101
00:34:21,560 --> 00:34:23,320
0,270 270,630 630,1200
to physical addresses.|
|

1102
00:34:25,360 --> 00:34:26,440
0,150 150,210 210,510 510,930 930,1080
And the basic idea is
基本思想是给每个进程提供自己的页表。

1103
00:34:26,440 --> 00:34:28,280
0,90 90,270 270,600 600,1260
to give every process

1104
00:34:28,660 --> 00:34:30,420
0,240 240,420 420,690 690,1140
its own page table.|
|

1105
00:34:34,310 --> 00:34:36,050
0,300 300,480 480,1080 1470,1650 1650,1740
In this way, you know
使用这种方式，进程只能使用，

1106
00:34:36,050 --> 00:34:37,080
0,360
the,

1107
00:34:38,130 --> 00:34:39,540
0,330 330,720 720,870 870,1110 1110,1410
the process can actually only

1108
00:34:39,540 --> 00:34:40,980
0,450 450,780 780,1080 1080,1380 1380,1440
use| whereas only allowed to
|只能访问它的页表中显示的物理内存，

1109
00:34:40,980 --> 00:34:42,120
0,330 330,540 540,750 750,810 810,1140
access that piece of physical

1110
00:34:42,120 --> 00:34:43,380
0,480 480,630 630,840 840,1110 1110,1260
memory that actually shows up

1111
00:34:43,380 --> 00:34:44,880
0,120 120,240 240,480 480,900 1290,1500
in its page table| and
|如果操作系统设置每个进程使用不相交的物理内存，

1112
00:34:44,880 --> 00:34:45,570
0,150 150,240 240,360 360,540 540,690
so if you set up

1113
00:34:45,570 --> 00:34:46,470
0,150 150,240 240,360 360,540 540,900
if the {operating -} system

1114
00:34:46,470 --> 00:34:47,490
0,240 240,300 300,540 540,870 870,1020
sets the page tables up

1115
00:34:47,490 --> 00:34:49,560
0,90 90,210 210,720 810,1440 1440,2070
in a way that {}

1116
00:34:49,560 --> 00:34:51,450
0,390 390,600 600,960 960,1140 1140,1890
every {} process has disjoint

1117
00:34:51,540 --> 00:34:53,190
0,480 480,990 1020,1260 1260,1320 1320,1650
physical memory,| then a process
|那么进程甚至不能访问其他进程的物理内存，

1118
00:34:53,190 --> 00:34:55,080
0,240 240,450 450,1050 1200,1590 1590,1890
can't even access somebody else's

1119
00:34:55,080 --> 00:34:56,370
0,300 300,690 720,960 960,1080 1080,1290
physical memory,| because it's not
|因为那些（地址）甚至不在它的页表中，

1120
00:34:56,370 --> 00:34:57,660
0,300 300,420 420,660 660,1140 1170,1290
{even,in} it's page tables,| so
|所以，不能创建或写一个地址，

1121
00:34:57,660 --> 00:34:58,920
0,150 150,690 690,960 960,1200 1200,1260
there's no way even to

1122
00:34:58,920 --> 00:35:00,450
0,240 240,330 330,720 720,960 1080,1530
create an address or write

1123
00:35:00,450 --> 00:35:01,710
0,270 270,360 360,900 930,1170 1170,1260
down an address| that will
|允许进程访问其他进程的物理内存。

1124
00:35:01,710 --> 00:35:03,090
0,330 330,420 420,840 840,990 990,1380
allow a process to access

1125
00:35:03,090 --> 00:35:05,360
0,360 360,900 1020,1560 1560,1950
somebody else's physical memory.|
|

1126
00:35:05,390 --> 00:35:06,110
0,180 180,240 240,450 450,630 630,720
And so this gives a
所以，这提供了强内存隔离。

1127
00:35:06,110 --> 00:35:08,180
0,510 510,810 810,1440
strong memory isolation.|
|

1128
00:35:09,950 --> 00:35:12,770
0,510 510,780 780,1380 1470,2310 2310,2820
Basically page table defines view
页表定义了内存布局，

1129
00:35:12,770 --> 00:35:15,530
0,240 240,810 810,1050 1050,1680 1710,2760
on memory,| and every application,
|每个应用程序，每个用户进程有自己的内存布局，相互独立。

1130
00:35:15,530 --> 00:35:16,760
0,120 120,420 420,780 780,1020 1050,1230
every user process has its

1131
00:35:16,760 --> 00:35:19,040
0,360 360,840 840,1050 1050,1440 1680,2280
own view of memory, independent

1132
00:35:19,040 --> 00:35:20,080
0,90 90,240 240,540
of each other.|
|

1133
00:35:20,220 --> 00:35:21,120
0,180 180,300 300,480 480,630 630,900
And this gives us very
这提供了很强的内存隔离。

1134
00:35:21,120 --> 00:35:23,580
0,600 660,1260 1260,1890
strong memory isolation.|
|

1135
00:35:24,320 --> 00:35:25,580
0,210 210,540 600,1050 1050,1200 1200,1260
And so now what we
所以现在我们可以做，

1136
00:35:25,580 --> 00:35:26,150
0,120 120,300 300,420 420,480 480,570
can do,| if we can
|如果我们用这种方式思考，

1137
00:35:26,150 --> 00:35:26,780
0,150 150,210 210,390 390,570 570,630
think a little bit in

1138
00:35:26,780 --> 00:35:28,700
0,180 180,720 900,1500 1500,1650 1650,1920
this way,| then we can
|那么我们可以重新画出之前的这张图，

1139
00:35:29,420 --> 00:35:30,830
0,570 570,690 690,1020 1020,1110 1110,1410
redraw the picture a little

1140
00:35:30,830 --> 00:35:32,360
0,150 150,810 870,1140 1140,1470 1470,1530
bit earlier| and because we're
|因为我们这样思考，

1141
00:35:32,360 --> 00:35:33,410
0,240 240,390 390,510 510,630 630,1050
thinking about these as follows,|
|

1142
00:35:33,410 --> 00:35:34,920
0,240 240,360 360,450 450,1020
you have the box,
你有一个盒子， ls 在它里面，

1143
00:35:35,570 --> 00:35:37,220
0,540 540,810 810,1290 1290,1560 1560,1650
{} and ls sits in

1144
00:35:37,220 --> 00:35:38,720
0,150 150,660 750,1230 1230,1380 1380,1500
that box| and we have
|我们有另一个盒子，而 echo 在这个盒子里，

1145
00:35:38,720 --> 00:35:40,490
0,120 120,180 180,690 720,1170 1500,1770
{another -} box, you know,

1146
00:35:41,210 --> 00:35:42,290
0,300 300,600 600,810 810,900 900,1080
{} echo sits in that

1147
00:35:42,290 --> 00:35:43,260
0,480
box,|
|

1148
00:35:43,740 --> 00:35:45,120
0,150 150,240 240,570 570,960 960,1380
in a box basically has
每个盒子包含地址，虚拟地址，

1149
00:35:45,120 --> 00:35:46,620
0,120 120,600 600,960 960,1200 1200,1500
an address virtual address| range
|从 0 到某个数值， 2 的多少次方，

1150
00:35:46,620 --> 00:35:48,240
0,240 240,390 390,840 840,1170 1170,1620
starting from zero to whatever

1151
00:35:48,240 --> 00:35:49,380
0,240 240,660 660,930 930,1050 1050,1140
some number two to the

1152
00:35:49,380 --> 00:35:51,570
0,360 360,750 750,960 1110,1770 1770,2190
power whatever the number is,|
|

1153
00:35:51,690 --> 00:35:53,430
0,480 480,900 930,1290 1290,1560 1560,1740
{} in {RISC-V -} which
在 RISC-V 中，我们将在周三讨论。

1154
00:35:53,430 --> 00:35:55,320
0,120 120,300 300,600 600,1410 1410,1890
we'll talk about on Wednesday.|
|

1155
00:35:55,500 --> 00:35:56,880
0,210 210,810 1080,1170 1170,1290 1290,1380
And similarly you know the
同样地， echo 的地址范围也是到 2^x 。

1156
00:35:56,880 --> 00:35:58,440
0,300 300,690 690,1080 1080,1410 1410,1560
address range for echo is

1157
00:35:58,440 --> 00:36:00,090
0,90 90,240 240,720 720,1260 1290,1650
to know something wherever same

1158
00:36:00,090 --> 00:36:01,800
0,510 510,900 900,1380
{two,to} power x.|
|

1159
00:36:02,080 --> 00:36:04,210
0,150 150,540 690,1200 1200,1560 1560,2130
And so {} ls has
所以 ls 有内存位置 0 ， echo 也有位置 0 ，

1160
00:36:04,240 --> 00:36:06,100
0,300 300,660 660,1320 1350,1710 1710,1860
memory location zero, echo has

1161
00:36:06,100 --> 00:36:07,390
0,60 60,540 540,690 690,810 810,1290
a location like {} zero,|
|

1162
00:36:07,420 --> 00:36:08,830
0,120 120,360 360,780 780,1200 1200,1410
and usually completely {separated -},|
通常是完全分开的，|

1163
00:36:08,920 --> 00:36:10,120
0,390 390,480 480,570 570,900 900,1200
and if the operating system
如果操作系统将虚拟地址 0 映射到不同部分的物理内存，

1164
00:36:10,120 --> 00:36:11,740
0,360 360,630 660,1020 1020,1320 1320,1620
maps those virtual addresses zero

1165
00:36:11,740 --> 00:36:12,790
0,120 120,420 420,630 630,690 690,1050
to different pieces of physical

1166
00:36:12,790 --> 00:36:15,430
0,630 960,1470 1470,1890 1890,2250 2250,2640
addresses,| then basically ls cannot
|那么 ls 不能访问 echo 的内存， echo 也不能访问 ls 的内存。

1167
00:36:15,430 --> 00:36:16,780
0,300 300,630 630,990 990,1080 1080,1350
access echo's memory and echo

1168
00:36:16,780 --> 00:36:18,740
0,420 420,1200 1200,1560
cannot {access,ls's} memory.|
|

1169
00:36:19,040 --> 00:36:20,690
0,150 150,720 720,810 810,1170 1170,1650
And similarly the kernel actually
类似地，内核位于下方，

1170
00:36:20,990 --> 00:36:21,860
0,150 150,270 270,390 390,540 540,870
you know {sits -} below

1171
00:36:21,860 --> 00:36:23,480
0,270 690,900 900,1290 1290,1470 1470,1620
it,| it also has his
|它也有自己的，至少在 xv6 中，有自己的地址范围，独立于应用程序。

1172
00:36:23,480 --> 00:36:24,440
0,360 360,450 450,630 630,840 840,960
own at least {in,xv6 -

1173
00:36:24,440 --> 00:36:25,910
0,360 360,510 510,660 660,1080 1110,1470
-} has his own address

1174
00:36:25,910 --> 00:36:27,710
0,540 600,990 990,1560 1560,1680 1680,1800
range, {} independent of the

1175
00:36:27,710 --> 00:36:29,000
0,870
applications.|
|

1176
00:36:29,090 --> 00:36:30,290
0,510 510,600 600,720 720,900 900,1200
And we could think about
我们可以考虑用户内核模式，它位于边界之间，

1177
00:36:30,290 --> 00:36:31,910
0,90 90,360 360,660 660,1140 1380,1620
the user kernel mode, sort

1178
00:36:31,910 --> 00:36:33,410
0,60 60,480 480,720 720,1350 1380,1500
of sitting in between you

1179
00:36:33,410 --> 00:36:35,150
0,120 120,240 240,930 960,1440 1440,1740
know the boundary,| you know
|在用户空间运行的东西运行在用户模式，

1180
00:36:35,180 --> 00:36:37,010
0,270 270,420 420,690 690,1140 1560,1830
things that actually run in

1181
00:36:37,010 --> 00:36:38,870
0,210 210,660 690,1110 1110,1350 1350,1860
user space running user mode,|
|

1182
00:36:41,020 --> 00:36:41,740
0,150 150,360 360,480 480,630 630,720
and things that sit in
位于内核的东西运行在内核模式。

1183
00:36:41,740 --> 00:36:43,180
0,60 60,570 570,810 810,1110 1110,1440
the kernel running kernel mode.|
|

1184
00:36:47,580 --> 00:36:48,120
0,120 120,240 240,360 360,420 420,540
And that's sort of the
这种图中，你应该知道操作系统位于内核模式，

1185
00:36:48,120 --> 00:36:49,830
0,720 720,960 960,1170 1170,1380 1380,1710
picture that you should actually

1186
00:36:49,830 --> 00:36:50,940
0,210 210,630 630,720 720,870 870,1110
know OS, you know sits

1187
00:36:50,940 --> 00:36:51,960
0,390 420,540 540,690 690,960 960,1020
there, you know sitting in

1188
00:36:51,960 --> 00:36:53,490
0,300 300,690 1110,1290 1290,1440 1440,1530
kernel mode,| so this is
|所以，这张图片应该出现在你的脑海中。

1189
00:36:53,490 --> 00:36:55,140
0,60 60,1020 1020,1170 1170,1560 1560,1650
the picture should happen in

1190
00:36:55,140 --> 00:36:56,100
0,90 90,450
your head.|
|

1191
00:36:56,550 --> 00:36:58,080
0,270 270,450 450,840 840,1050 1050,1530
Now, as described so far
到目前为止，这张图片有点太严格了，

1192
00:36:58,200 --> 00:36:58,890
0,210 210,450 450,510 510,540 540,690
this picture is a little

1193
00:36:58,890 --> 00:37:00,180
0,180 180,330 330,840 930,1110 1110,1290
bit too strict,| you know
|我们把所有东西都放在一个盒子里，

1194
00:37:00,180 --> 00:37:01,230
0,150 150,480 480,570 570,900 900,1050
we have {} basically put

1195
00:37:01,230 --> 00:37:02,490
0,270 270,360 360,420 420,930 1050,1260
everything in a box,| but
|但是没有办法使控制权从一个盒子转移到另一个盒子。

1196
00:37:02,490 --> 00:37:03,360
0,120 120,240 240,480 480,630 630,870
there's no way for one

1197
00:37:03,360 --> 00:37:04,680
0,360 360,480 480,870 870,1230 1230,1320
box to transfer control to

1198
00:37:04,680 --> 00:37:05,900
0,300 300,780
another box.|
|

1199
00:37:05,900 --> 00:37:07,190
0,390 390,600 600,810 810,900 900,1290
Clearly, that needs to happen,|
当然，我们需要它发生，|

1200
00:37:07,220 --> 00:37:08,780
0,450 450,540 540,930 930,1470 1470,1560
because for example ls, you
因为，比如 ls 可以想要调用 read 系统调用或 write 系统调用，

1201
00:37:08,780 --> 00:37:10,070
0,90 90,420 420,630 630,750 750,1290
know probably wants to call

1202
00:37:10,400 --> 00:37:12,140
0,120 120,300 300,720 780,1440 1440,1740
you know read read system

1203
00:37:12,140 --> 00:37:13,060
0,420
call

1204
00:37:13,250 --> 00:37:15,080
0,240 240,510 510,780 780,1290
or write system call,|
|

1205
00:37:15,080 --> 00:37:16,280
0,180 180,570 570,720 720,870 870,1200
or maybe you know whatever
或者 shell 想要调用 fork 或 exec ，

1206
00:37:16,280 --> 00:37:17,390
0,90 90,510 510,660 660,750 750,1110
the shell want to call

1207
00:37:17,390 --> 00:37:19,100
0,540 570,810 810,900 900,1350 1560,1710
fork or {} exec| and
|所以需要一种方法，让应用程序以协调的方式将控制权转移到内核，

1208
00:37:19,100 --> 00:37:19,760
0,90 90,210 210,450 450,510 510,660
so there has to be

1209
00:37:19,760 --> 00:37:22,190
0,630 690,1470 1500,1650 1650,2340 2340,2430
way for an application or

1210
00:37:22,190 --> 00:37:24,260
0,270 270,780 780,900 900,1440 1440,2070
user application to transfer control

1211
00:37:24,260 --> 00:37:26,120
0,120 120,180 180,840 840,1320 1590,1860
in a coordinated manner {}

1212
00:37:26,120 --> 00:37:28,190
0,660 690,900 900,1020 1020,1530 1800,2070
to {} the kernel,| so
|让内核可以提供服务。

1213
00:37:28,190 --> 00:37:29,300
0,210 210,510 510,600 600,840 840,1110
the kernel can actually provide

1214
00:37:29,300 --> 00:37:30,400
0,720
services.|
|

1215
00:37:30,940 --> 00:37:33,280
0,480 840,1110 1110,1620 1860,2130 2130,2340
{} And so, {} there's
所以，有一种方案，

1216
00:37:33,280 --> 00:37:34,870
0,60 60,660 660,1200 1200,1260 1260,1590
a plan,| basically in addition
|除了我之前讨论过的这两种硬件支持，

1217
00:37:34,870 --> 00:37:36,010
0,120 120,420 540,720 720,900 900,1140
to this, {} two pieces

1218
00:37:36,010 --> 00:37:37,060
0,60 60,330 330,690 690,810 810,1050
of hardware support, I talked

1219
00:37:37,060 --> 00:37:38,980
0,120 120,480 1320,1560 1560,1800 1800,1920
so far, talked about so

1220
00:37:38,980 --> 00:37:41,170
0,480 540,870 870,1020 1020,1710 2010,2190
far,| is a way of
|有一种控制方法进入内核。

1221
00:37:41,170 --> 00:37:43,090
0,270 420,990 990,1320 1320,1530 1530,1920
{} controlled way of entering

1222
00:37:43,090 --> 00:37:44,100
0,60 60,570
the kernel.|
|

1223
00:37:49,450 --> 00:37:50,710
0,240 240,450 450,660 660,990 990,1260
It turns out actually {RISV-V
在 RISC-V 中，有一个这样的指令，称为 ecall 指令。

1224
00:37:50,710 --> 00:37:52,510
0,540 660,960 960,1230 1230,1410 1410,1800
-} {} there is an

1225
00:37:52,540 --> 00:37:54,880
0,750 870,1410 1410,1650 1650,2070 2130,2340
instruction, {} for this, it's

1226
00:37:54,880 --> 00:37:56,470
0,180 180,240 240,420 420,840 840,1590
called the {ecall -} instruction.|
|

1227
00:37:58,000 --> 00:37:59,380
0,180 180,480 480,1020 1020,1170 1170,1380
And ecall instruction, it takes
ecall 指令接受一个参数，一个数字，

1228
00:37:59,380 --> 00:38:01,380
0,210 210,810 840,990 990,1500
one argument a number,|
|

1229
00:38:02,210 --> 00:38:03,020
0,180 180,300 300,420 420,570 570,810
and so when a user
所以当用户程序想要将控制权转移到内核，

1230
00:38:03,020 --> 00:38:04,850
0,870 1080,1320 1320,1500 1500,1740 1740,1830
application {} that wants to

1231
00:38:04,850 --> 00:38:06,530
0,390 390,780 780,990 990,1080 1080,1680
transfer control into the kernel,|
|

1232
00:38:06,560 --> 00:38:08,420
0,480 480,810 810,990 990,1230 1230,1860
basically call the ecall instruction
调用 ecall 指令，使用数字，比如 2 3 4 5 ，

1233
00:38:08,420 --> 00:38:09,680
0,210 210,660 660,840 840,1200 1200,1260
with numbers like two or

1234
00:38:09,680 --> 00:38:11,120
0,240 240,330 330,630 630,1140 1260,1440
three or four five| and
|这个数字就是应用程序想要访问的系统调用编号。

1235
00:38:11,120 --> 00:38:12,500
0,120 120,420 420,990 1050,1290 1290,1380
that number basically is the

1236
00:38:12,500 --> 00:38:13,980
0,360 360,600 600,1050
system call number

1237
00:38:14,970 --> 00:38:16,020
0,210 210,300 300,810 810,990 990,1050
that the application wants to

1238
00:38:16,020 --> 00:38:17,080
0,510
invoke.|
|

1239
00:38:21,740 --> 00:38:23,000
0,270 270,600 600,960 960,1110 1110,1260
And then basically what that
这个指令做的是，

1240
00:38:23,000 --> 00:38:24,470
0,480 480,660 660,1080 1080,1410 1410,1470
does| and actually enters the
|进入内核中的一个由内核控制的特定位置，

1241
00:38:24,470 --> 00:38:26,540
0,450 450,570 570,600 600,1230 1230,2070
kernel at a particular {}

1242
00:38:26,570 --> 00:38:28,970
0,810 930,1350 1350,1770 1770,2310 2310,2400
point, a particular location in

1243
00:38:28,970 --> 00:38:30,410
0,60 60,300 300,930 930,1380 1380,1440
the ker- {}, in the

1244
00:38:30,410 --> 00:38:31,790
0,450 480,750 750,1170 1170,1290 1290,1380
kernel that's controlled by the

1245
00:38:31,790 --> 00:38:33,680
0,420 1170,1320 1320,1410 1410,1680 1680,1890
kernel,| as we'll see you
|我们会在后面的一些课程中在 xv6 中看到。

1246
00:38:33,680 --> 00:38:34,970
0,90 90,240 240,390 390,930 990,1290
in {xv6 - -} {}

1247
00:38:34,970 --> 00:38:37,370
0,270 270,750 750,990 990,1500 1590,2400
in some later lectures {}.|
|

1248
00:38:37,370 --> 00:38:38,240
0,90 90,180 180,360 360,780 780,870
You know there's basically a
有一个单独的系统调用入口位置，

1249
00:38:38,240 --> 00:38:40,760
0,720 750,1230 1230,1710 1710,2010 2010,2520
single system call entry point,|
|

1250
00:38:41,200 --> 00:38:43,570
0,630 720,1530 1530,1800 1800,2070 2070,2370
and, {} and every time
每次应用程序调用 ecall ，应用程序进入内核的特定位置。

1251
00:38:43,570 --> 00:38:45,010
0,90 90,570 570,780 780,900 900,1440
an application calls {ecall -}

1252
00:38:45,130 --> 00:38:46,450
0,330 330,390 390,930 930,1230 1230,1320
and the application enters the

1253
00:38:46,450 --> 00:38:48,140
0,330 330,480 480,810 810,1200
kernel that particular point.|
|

1254
00:38:48,600 --> 00:38:50,400
0,150 150,690 720,1290
So, one {},
所以，一种思考方式是，

1255
00:38:50,400 --> 00:38:51,030
0,90 90,240 240,360 360,480 480,630
so one way to think

1256
00:38:51,030 --> 00:38:52,380
0,210 210,390 390,510 510,930 1140,1350
about this is that| if
|如果你调用 fork ，在用户空间调用 fork ，

1257
00:38:52,380 --> 00:38:53,780
0,90 90,240 240,840
you have fork,

1258
00:38:53,900 --> 00:38:55,040
0,120 120,300 300,810 810,900 900,1140
you know fork, you know

1259
00:38:55,790 --> 00:38:57,350
0,450 450,840 870,1170 1170,1470 1470,1560
call in user space,| for
|比如 shell 或 prime 程序调用 fork ，

1260
00:38:57,350 --> 00:38:58,580
0,360 360,420 420,840 840,1020 1020,1230
example the shell or your

1261
00:38:58,580 --> 00:39:00,950
0,390 420,1110 1110,1350 1350,1800 2100,2370
prime program called fork,| well
|不论什么调用 fork ，实际上没有直接调用操作系统内核对应的函数，

1262
00:39:00,950 --> 00:39:02,210
0,360 360,690 690,930 930,1050 1050,1260
whatever calls {fork -}, doesn't

1263
00:39:02,210 --> 00:39:03,770
0,240 240,660 660,780 780,1230 1230,1560
really call the operating system

1264
00:39:03,770 --> 00:39:06,050
0,540 780,960 960,1560 1560,2010 2010,2280
directly, the corresponding function in

1265
00:39:06,050 --> 00:39:07,790
0,60 60,510 630,1350 1530,1680 1680,1740
the kernel,| instead you know
|而是调用 ecall ，使用 fork 的系统调用编号，

1266
00:39:07,790 --> 00:39:08,900
0,180 180,420 420,780 780,900 900,1110
what it does it actually

1267
00:39:08,900 --> 00:39:10,440
0,330 330,480 480,1050
calls the ecall

1268
00:39:11,740 --> 00:39:13,930
0,540 540,630 630,810 810,1230 1470,2190
with you know the number

1269
00:39:13,930 --> 00:39:15,360
0,330 330,990
for fork,|
|

1270
00:39:17,080 --> 00:39:18,760
0,180 180,720 900,1200 1200,1410 1410,1680
and then that actually jumps
然后进入内核。

1271
00:39:18,760 --> 00:39:20,220
0,180 180,270 270,930
into the kernel.|
|

1272
00:39:20,700 --> 00:39:21,690
0,300 300,510 510,600 600,690 690,990
So this is a kernel
所以这是一次内核转换，

1273
00:39:21,690 --> 00:39:22,940
0,690
transition,|
|

1274
00:39:23,060 --> 00:39:24,260
0,180 180,420 420,510 510,810 810,1200
and here's the user side,
这是用户侧，这是内核侧，

1275
00:39:24,260 --> 00:39:26,120
0,270 270,330 330,660 660,1170 1650,1860
here's a kernel side| and
|在内核侧，有一个函数 syscall 在 syscall.c 中，

1276
00:39:26,120 --> 00:39:28,160
0,510 510,900 900,1170 1200,1500 1500,2040
then on the kernel site,

1277
00:39:28,190 --> 00:39:29,180
0,150 150,270 270,510 510,690 690,990
you know there's a function

1278
00:39:29,180 --> 00:39:30,830
0,210 210,390 390,930 1140,1260 1260,1650
called {syscall -} in {syscall.c

1279
00:39:30,830 --> 00:39:33,290
0,480 660,930 930,1080 1080,2160 2160,2460
-}| and then basically every
|每次系统调用都会到这个特定的系统调用函数，

1280
00:39:33,290 --> 00:39:34,550
0,330 330,600 600,720 720,930 930,1260
system call will end up

1281
00:39:34,580 --> 00:39:35,720
0,120 120,300 300,630 630,930 930,1140
at that particular system call

1282
00:39:35,720 --> 00:39:37,250
0,510 690,870 870,960 960,1290 1290,1530
function| and the system call
|系统调用查找数字，然后决定传递给寄存器 a0 的数字，

1283
00:39:37,250 --> 00:39:38,330
0,120 120,300 300,390 390,480 480,1080
will look at the number

1284
00:39:38,480 --> 00:39:39,560
0,150 150,270 270,810 870,990 990,1080
and then decide and the

1285
00:39:39,560 --> 00:39:41,120
0,270 270,510 510,900 900,1020 1020,1560
number actually passed in register,

1286
00:39:41,120 --> 00:39:42,260
0,150 150,300 300,420 420,540 540,1140
I think it's {a0 -},|
|

1287
00:39:42,690 --> 00:39:44,640
0,510 510,1110 1260,1590 1590,1740 1740,1950
{} and system call {}
系统调用查找那个寄存器 a0 ，查看是哪个数字，

1288
00:39:44,640 --> 00:39:45,870
0,180 180,270 270,450 450,990 990,1230
look at that register look

1289
00:39:45,870 --> 00:39:47,310
0,90 90,900 990,1230 1230,1350 1350,1440
at a0, see what the

1290
00:39:47,310 --> 00:39:48,300
0,360 360,570 570,690 690,900 900,990
number is| and then for
|然后调用比如 fork 系统调用。

1291
00:39:48,300 --> 00:39:49,590
0,330 330,570 570,660 660,990 990,1290
example called the fork system

1292
00:39:49,590 --> 00:39:50,380
0,300
call.|
|

1293
00:39:52,670 --> 00:39:53,870
0,360 360,570 570,870 870,1080 1080,1200
{} And so just to
为了理解清楚，

1294
00:39:53,870 --> 00:39:55,070
0,270 270,810 810,900 900,1080 1080,1200
make clear,| so this is
|这里是用户和内核的硬边界，

1295
00:39:55,070 --> 00:39:56,570
0,210 210,540 540,1110 1110,1440 1440,1500
this hard boundary between the

1296
00:39:56,570 --> 00:39:58,340
0,330 330,420 420,870 1020,1500 1650,1770
user and kernel,| so the
|用户不能直接调用这个 fork ，

1297
00:39:58,340 --> 00:40:00,600
0,300 300,1020 1080,1770
user cannot call

1298
00:40:00,600 --> 00:40:03,060
0,120 120,450 810,1410 1440,1830 1830,2460
you know this fork directly,|
|

1299
00:40:03,240 --> 00:40:04,410
0,150 150,240 240,360 360,810 810,1170
you know the only way
用户程序调用 fork 的唯一方法是通过 ecall 指令。

1300
00:40:04,410 --> 00:40:06,900
0,510 510,960 960,1080 1080,1590 1620,2490
user application can actually invoke

1301
00:40:06,900 --> 00:40:08,520
0,150 150,420 420,690 690,1290 1410,1620
this system call fork is

1302
00:40:08,520 --> 00:40:10,110
0,240 240,510 510,780 780,1050 1050,1590
actually through the ecall instruction.|
|

1303
00:40:12,570 --> 00:40:13,620
0,150 150,240 240,300 300,420 420,1050
And so we have another,
所以我们有另一个，有另一个系统调用，比如 write ，

1304
00:40:13,650 --> 00:40:14,740
0,540
{}

1305
00:40:18,830 --> 00:40:20,270
0,210 210,300 300,450 450,960 960,1440
if we have another {}

1306
00:40:22,390 --> 00:40:23,890
0,390 390,720 720,990 990,1320 1320,1500
{} another system call, let's

1307
00:40:23,890 --> 00:40:25,260
0,270 270,810
say write,|
|

1308
00:40:27,720 --> 00:40:28,920
0,180 180,300 300,540 540,1050 1080,1200
it does something similar, you
它也是类似的， write 系统调用不能直接调用内核中的 write 代码，

1309
00:40:28,920 --> 00:40:30,780
0,90 90,210 210,720 960,1560 1560,1860
know the write {} system

1310
00:40:30,780 --> 00:40:32,100
0,240 240,600 600,1110 1140,1230 1230,1320
called cannot call you know

1311
00:40:32,100 --> 00:40:33,930
0,300 300,840 840,930 930,1260 1290,1830
the write you know code

1312
00:40:33,930 --> 00:40:35,760
0,390 390,540 540,600 600,1110 1140,1830
directly into the kernel,| instead,
|而是调用包装函数，

1313
00:40:35,970 --> 00:40:37,020
0,300 300,510 510,570 570,930 930,1050
{} what it does, it

1314
00:40:37,020 --> 00:40:39,270
0,330 330,540 540,1590 1590,1890 1890,2250
calls what's these little wrappers

1315
00:40:39,270 --> 00:40:41,160
0,60 60,480 720,1380
are called, {}|
|

1316
00:40:41,160 --> 00:40:42,210
0,330 330,540 540,840 840,930 930,1050
system call [stops] and will
系统调用[停止]并调用 ecall ，

1317
00:40:42,210 --> 00:40:43,680
0,300 300,420 420,960
call {ecall -}|
|

1318
00:40:44,560 --> 00:40:45,790
0,120 120,450 450,660 660,1050 1050,1230
and function called write that
函数 write ，执行 ecall 指令使用参数 sys_write ，表示 write 系统调用，

1319
00:40:45,790 --> 00:40:47,890
0,240 240,690 690,990 990,1920 1920,2100
actually executes ecall instruction with

1320
00:40:47,890 --> 00:40:49,210
0,150 150,720 720,810 810,960 960,1320
the argument you know {sys_write

1321
00:40:49,210 --> 00:40:50,280
0,480
-}

1322
00:40:50,430 --> 00:40:51,930
0,150 150,720 720,990 990,1230 1230,1500
to indicate the write system

1323
00:40:51,930 --> 00:40:54,390
0,450 630,810 810,1380 1410,2010 2010,2460
call| and again transfer control
|将控制权给 syscall ，然后 syscall 可以分配到 write 系统调用。

1324
00:40:54,390 --> 00:40:56,850
0,120 120,870 1200,1410 1410,1710 1710,2460
to syscall and then syscall

1325
00:40:57,430 --> 00:41:00,430
0,300 300,720 720,1350 1500,2520 2520,3000
{} can actually {demultiplex -}

1326
00:41:00,430 --> 00:41:01,450
0,150 150,270 270,480 480,720 720,1020
into the write system call.|
|

1327
00:41:01,690 --> 00:41:03,460
0,360 360,420 420,870 870,1470 1500,1770
There are two questions, please
这里有两个问题，请继续（提问）。

1328
00:41:03,460 --> 00:41:04,480
0,120 120,480
go ahead.|
|

1329
00:41:09,910 --> 00:41:10,810
0,180 180,480 480,720 720,840 840,900
{So,I} think my hands up
我想我们都举手了。

1330
00:41:10,810 --> 00:41:11,860
0,90 90,480
{both -}.|
|

1331
00:41:12,660 --> 00:41:14,580
0,480 480,930 930,1050 1050,1200 1200,1920
Okay, I can go ahead.|
好的，我可以先提问。|

1332
00:41:15,640 --> 00:41:16,990
0,390 450,600 600,960 960,1050 1050,1350
Oh, the question I had
我的问题是，怎样或在哪里检查，

1333
00:41:16,990 --> 00:41:19,330
0,510 570,1080 1440,1830 1830,2220 2220,2340
was, {} how does or

1334
00:41:19,330 --> 00:41:21,190
0,330 330,540 540,660 660,1170 1170,1860
where does the kernel check,|
|

1335
00:41:21,940 --> 00:41:24,460
0,660 1020,1560 1560,1710 1710,2130 2130,2520
{} for, for example fork
比如 fork 或 write ，它们是否允许，

1336
00:41:24,460 --> 00:41:26,110
0,270 270,930 1170,1410 1410,1500 1500,1650
or write, if it is

1337
00:41:26,110 --> 00:41:28,360
0,360 360,450 450,930 1410,1920 1980,2250
allowed or not,| {} right
|目前，你只是调用 ecall ，使用系统调用编号，

1338
00:41:28,360 --> 00:41:29,530
0,210 210,330 330,570 570,930 930,1170
now, you're just passing in

1339
00:41:29,530 --> 00:41:30,580
0,270 270,360 360,540 570,840 840,1050
like you know you're just

1340
00:41:30,580 --> 00:41:31,930
0,450 450,630 630,1050 1050,1200 1200,1350
calling {ecall -} and the

1341
00:41:31,930 --> 00:41:34,120
0,330 330,600 600,1080 1110,1710 1770,2190
system call number,| but where
|但是内核在哪里决定程序可以调用特定的内核系统调用。

1342
00:41:34,120 --> 00:41:35,920
0,240 240,390 390,840 840,1350 1350,1800
does the kernel basically decide

1343
00:41:35,920 --> 00:41:37,840
0,300 300,480 480,1140 1230,1740 1740,1920
whether this application should be

1344
00:41:37,840 --> 00:41:39,640
0,180 180,330 330,900 900,1050 1050,1800
able to invoke this particular

1345
00:41:39,670 --> 00:41:41,400
0,810 810,1350
kernel syscall.|
|

1346
00:41:41,430 --> 00:41:42,690
0,330 330,480 480,720 720,930 930,1260
Yeah, so a great question,|
是的，这是个好问题，|

1347
00:41:42,690 --> 00:41:44,430
0,300 300,540 540,1170 1170,1260 1260,1740
so in principle you know
理论上，在内核侧，我们真正运行 fork 的这边，

1348
00:41:44,430 --> 00:41:45,570
0,120 120,180 180,480 480,750 750,1140
on the kernel side correct

1349
00:41:45,570 --> 00:41:47,160
0,270 270,450 450,750 750,1230 1230,1590
when we actually fork call

1350
00:41:47,160 --> 00:41:48,180
0,570
runs,|
|

1351
00:41:48,240 --> 00:41:49,320
0,180 180,330 330,420 420,840 840,1080
{} it can implement any
它可以实现任何想要的安全检查，

1352
00:41:49,320 --> 00:41:50,700
0,360 360,570 570,660 660,1170 1230,1380
secure check it wants,| you
|可以检查系统调用的参数，

1353
00:41:50,700 --> 00:41:51,930
0,240 240,390 390,450 450,570 570,1230
could look at the arguments

1354
00:41:51,960 --> 00:41:53,550
0,270 270,360 360,660 660,1170 1440,1590
in the system call| and
|决定应用程序是否允许执行系统调用 fork ，

1355
00:41:53,550 --> 00:41:55,140
0,360 360,630 630,990 990,1080 1080,1590
decide whether actually the application

1356
00:41:55,140 --> 00:41:56,640
0,540 540,660 660,1020 1020,1080 1080,1500
should be allowed to execute

1357
00:41:56,640 --> 00:41:58,410
0,90 90,450 450,690 690,1140 1320,1770
the system call fork,| now
|在 Unix 中，任何应用程序都可以调用 fork ，

1358
00:41:58,740 --> 00:42:00,570
0,660 660,900 960,1470 1470,1650 1650,1830
{in,user} in Unix, {} any

1359
00:42:00,570 --> 00:42:01,980
0,420 420,540 540,720 720,930 930,1410
application can actually call fork,|
|

1360
00:42:02,160 --> 00:42:03,660
0,420 420,600 600,750 750,1050 1050,1500
but let's say take write,
让我们来讨论 write ，

1361
00:42:03,960 --> 00:42:05,130
0,120 120,300 300,750 780,960 960,1170
you know write,| you need
|write 需要检查，传给 write 的地址是否属于应用程序，

1362
00:42:05,130 --> 00:42:06,960
0,90 90,390 390,990 1260,1710 1710,1830
to check whether, {} the

1363
00:42:06,960 --> 00:42:08,280
0,690 690,780 780,1050 1050,1230 1230,1320
implantation of write needs to

1364
00:42:08,280 --> 00:42:09,720
0,300 300,660 660,810 810,1260 1260,1440
check whether the address that

1365
00:42:09,720 --> 00:42:11,790
0,120 120,360 360,810 810,1590 1620,2070
is actually passed into write

1366
00:42:12,090 --> 00:42:13,980
0,630 630,990 1020,1710 1710,1830 1830,1890
actually is part of the

1367
00:42:13,980 --> 00:42:15,400
0,270 270,1110
user applications,|
|

1368
00:42:15,460 --> 00:42:16,630
0,390 390,660 660,810 810,1050 1050,1170
{} and so that you
内核不能写数据到不属于该应用程序的地方，

1369
00:42:16,630 --> 00:42:17,560
0,180 180,450 450,690 690,750 750,930
know the kernel is not

1370
00:42:17,560 --> 00:42:21,370
0,510 780,1320 1320,2070 2070,2250 3240,3810
correct to writing a data

1371
00:42:21,370 --> 00:42:22,270
0,120 120,360 360,630 630,720 720,900
from somewhere else it actually

1372
00:42:22,270 --> 00:42:23,650
0,270 270,630 630,720 720,810 810,1380
doesn't belong to the application,|
|

1373
00:42:25,610 --> 00:42:27,480
0,210 210,690 720,1260
There more {}
还有更多线索，请提问。

1374
00:42:27,510 --> 00:42:28,830
0,480 480,570 570,660 660,870 870,1320
hints, you know, please ask.|
|

1375
00:42:30,260 --> 00:42:31,190
0,390 390,570 570,750 750,870 870,930
{} Yeah I had a
是的，我有一个问题，

1376
00:42:31,190 --> 00:42:33,470
0,150 150,750 1200,1620 1620,1890 1890,2280
quick question,| so how did
|内核如何夺回从用户程序夺回控制权，

1377
00:42:33,500 --> 00:42:36,110
0,480 870,1410 1410,1830 1830,2130 2130,2610
the kernel seize back control

1378
00:42:36,110 --> 00:42:37,610
0,150 150,240 240,510 510,1350 1380,1500
from a user application,| in
|在用户程序是恶意的或处于无限循环的情况下。

1379
00:42:37,610 --> 00:42:39,020
0,90 90,390 390,870 1110,1230 1230,1410
the case where the user

1380
00:42:39,020 --> 00:42:41,090
0,540 540,630 630,960 960,1650 1650,2070
application is acting maliciously or

1381
00:42:41,180 --> 00:42:42,680
0,210 210,300 300,690 690,1110
in an infinite loop.|
|

1382
00:42:42,680 --> 00:42:44,300
0,780 780,960 960,1230 1230,1500 1500,1620
Yeah, so the way the
是的，这种情况的方法是，

1383
00:42:44,300 --> 00:42:45,920
0,360 360,450 450,870 870,1170 1200,1620
plan for that| and again
|我们会在后面几周讨论更多的细节，

1384
00:42:45,920 --> 00:42:46,460
0,60 60,180 180,240 240,390 390,540
we're going to talk about

1385
00:42:46,460 --> 00:42:47,120
0,60 60,210 210,300 300,600 600,660
in much more detail in

1386
00:42:47,120 --> 00:42:48,440
0,60 60,270 270,570 780,990 990,1320
a couple weeks,| {} is
|方法是内核对硬件编程设置一个定时器，

1387
00:42:48,440 --> 00:42:50,540
0,360 360,870 900,1350 1350,1650 1650,2100
that the kernel actually programs

1388
00:42:50,540 --> 00:42:52,280
0,60 60,420 420,1080 1410,1680 1680,1740
the hardware to set a

1389
00:42:52,280 --> 00:42:53,340
0,600
timer,|
|

1390
00:42:53,460 --> 00:42:55,500
0,690 690,1410 1410,1500 1500,1830 1830,2040
and after the timer goes
在定时器结束后，会触发从用户空间切换到内核模式，

1391
00:42:55,500 --> 00:42:57,600
0,420 660,1050 1050,1380 1380,1530 1530,2100
off, {} that will cause

1392
00:42:57,600 --> 00:42:59,190
0,420 420,930 930,1080 1080,1320 1320,1590
a transfer from user space

1393
00:42:59,190 --> 00:43:00,240
0,90 90,390 390,690 780,930 930,1050
to kernel mode,| at that
|在这个时间点，内核重新获得控制权，

1394
00:43:00,240 --> 00:43:01,290
0,210 210,270 270,570 570,690 690,1050
point the kernel is back

1395
00:43:01,290 --> 00:43:02,760
0,90 90,660 960,1260 1260,1410 1410,1470
in control| and then the
|然后内核可以重新调度 CPU 给其他进程。

1396
00:43:02,760 --> 00:43:04,770
0,270 270,480 480,1230 1320,1860 1860,2010
kernel can reschedule {} the

1397
00:43:04,770 --> 00:43:07,100
0,390 390,480 480,990 1050,1770
CPU to another process.|
|

1398
00:43:07,590 --> 00:43:09,090
0,450 630,900 900,1170 1170,1380 1380,1500
Okay make sense, thank you.|
好的，理解了，谢谢。|

1399
00:43:09,760 --> 00:43:11,260
0,210 210,360 360,510 510,930 930,1500
Yeah, we'll see the exact
是的，我们会在一段时间之后看到具体细节。

1400
00:43:11,260 --> 00:43:13,270
0,600 600,690 690,870 870,1470 1470,2010
details you know we'll see

1401
00:43:13,270 --> 00:43:14,740
0,360 360,540 540,930
a little while.|
|

1402
00:43:15,200 --> 00:43:16,960
0,120 120,210 210,720 720,1230
You have more questions?|
还有问题吗？|

1403
00:43:18,690 --> 00:43:19,650
0,330 330,510 510,630 630,720 720,960
Yeah, so this is more
是的，有一个高层次的问题，

1404
00:43:19,650 --> 00:43:20,940
0,90 90,210 210,690 690,1140 1140,1290
of a high-level question,| but
|为什么设计者使用 C 语言来实现操作系统。

1405
00:43:20,940 --> 00:43:24,240
0,360 360,1290 1320,2070 2160,3090 3090,3300
what drives the designers of

1406
00:43:24,240 --> 00:43:26,730
0,270 270,900 900,1410 1410,2340 2340,2490
an operating systems implementation to

1407
00:43:26,730 --> 00:43:28,170
0,300 300,390 390,810 810,1050 1050,1440
use a language like C.|
|

1408
00:43:29,120 --> 00:43:31,730
0,480 660,1320 1320,1860 1860,2100 2220,2610
{Um -}, okay, so great
好的，好问题，

1409
00:43:31,730 --> 00:43:34,940
0,420 600,1140 2460,2940 2940,3120 3120,3210
question,| {} C gives you
|C 语音给了你控制硬件的能力，

1410
00:43:34,940 --> 00:43:36,230
0,30 30,180 180,240 240,960 1050,1290
a lot of control {}

1411
00:43:36,230 --> 00:43:39,710
0,1020 1020,1560 1920,2940 2970,3480 3480,3480
over hardware| and so {}
|比如，你可以对定时器编程，

1412
00:43:40,790 --> 00:43:41,900
0,210 210,750 750,840 840,960 960,1110
for example, you know you

1413
00:43:41,900 --> 00:43:42,860
0,150 150,270 270,600 600,660 660,960
need to program the timer

1414
00:43:42,860 --> 00:43:45,620
0,360 690,1560 1560,2070 2070,2430 2430,2760
chip| {} and in C
|在 C 语言中，很容易做到，

1415
00:43:45,620 --> 00:43:47,030
0,240 240,330 330,960 990,1290 1290,1410
that is actually easy to

1416
00:43:47,030 --> 00:43:48,230
0,420 450,930 930,1020 1020,1140 1140,1200
do,| because you get a
|因为你可以控制任何硬件资源，

1417
00:43:48,230 --> 00:43:50,060
0,210 210,330 330,780 780,1260 1260,1830
lot of low-level control over

1418
00:43:50,300 --> 00:43:52,460
0,420 420,750 750,1320 1350,1740 1770,2160
any hardware resource| and partly
|部分原因是你可以转换任何东西，

1419
00:43:52,460 --> 00:43:53,900
0,240 240,390 390,510 510,1140
because you can cast

1420
00:43:53,900 --> 00:43:56,510
0,390 390,480 480,1020 1380,2160 2160,2610
anything to anything,| {} and,
|所以， C 语言是非常方便的编程语言，

1421
00:43:56,540 --> 00:43:57,800
0,150 150,360 360,690 690,990 990,1260
{} so {C,is} basically very

1422
00:43:57,800 --> 00:43:59,900
0,870 960,1530 1530,1860 1860,1980 1980,2100
convenient programming language,| if you
|如果你需要底层编程，特别是与硬件交互。

1423
00:43:59,900 --> 00:44:00,920
0,150 150,240 240,390 390,600 600,1020
have to move very low-level

1424
00:44:00,920 --> 00:44:03,260
0,540 600,1320 1320,1740 1740,1860 1860,2340
programming particularly interacting with hardware.|
|

1425
00:44:06,620 --> 00:44:07,550
0,210 210,420 420,600 600,690 690,930
It doesn't mean you can't
这并不意味着你不能使用别的语言，

1426
00:44:07,550 --> 00:44:08,660
0,90 90,210 210,300 300,510 510,1110
do it in other languages,|
|

1427
00:44:08,720 --> 00:44:09,860
0,240 240,390 390,540 540,600 600,1140
{} but this is historically
但这是历史上 C 语言成功的原因。

1428
00:44:09,860 --> 00:44:10,880
0,90 90,300 300,480 480,840 840,1020
the reason why C has

1429
00:44:10,880 --> 00:44:12,280
0,90 90,810
been successful.|
|

1430
00:44:12,940 --> 00:44:14,540
0,150 150,450 450,960
I see, thanks.|
我明白了，谢谢。|

1431
00:44:15,230 --> 00:44:16,490
0,300 300,390 390,840 840,1020 1020,1260
Why {} C so much
为什么 C 比 C++ 更流行，仅仅是历史原因吗，

1432
00:44:16,490 --> 00:44:18,470
0,240 240,840 840,1500 1530,1740 1740,1980
more popular than C plus

1433
00:44:18,470 --> 00:44:20,390
0,330 330,660 660,840 840,1380 1380,1920
plus only for historic reasons,|
|

1434
00:44:20,420 --> 00:44:21,560
0,240 240,480 480,720 720,1050 1050,1140
in like these kinds of
比如那些应用程序，

1435
00:44:21,560 --> 00:44:24,500
0,1020 1260,1680 1680,1950 1950,2100 2100,2940
applications| or {} is there
|或者其他原因，比如大多数操作系统没有采用 C++ 。

1436
00:44:24,800 --> 00:44:26,510
0,270 270,510 510,1020 1020,1350 1350,1710
any other reason that like,

1437
00:44:26,540 --> 00:44:27,890
0,330 360,600 600,900 900,960 960,1350
no like most of OS

1438
00:44:27,890 --> 00:44:29,630
0,480 510,900 900,1380 1380,1530 1530,1740
don't have adopted C plus

1439
00:44:29,630 --> 00:44:30,440
0,450
plus.|
|

1440
00:44:30,590 --> 00:44:31,760
0,210 210,360 360,600 600,870 870,1170
Yeah, so most operating system,|
是的，大多数操作系统，|

1441
00:44:31,760 --> 00:44:32,900
0,330 330,570 570,630 630,810 810,1140
there are I think operating
我相信使用 C++ 编写操作系统是完全可能的，

1442
00:44:32,900 --> 00:44:33,920
0,330 330,570 570,630 630,810 810,1020
systems written in C plus

1443
00:44:33,920 --> 00:44:36,110
0,390 450,1050 1050,1680 1830,2130 2130,2190
plus totally possible,| probably the
|可能大多数不是使用 C++ 编写，

1444
00:44:36,110 --> 00:44:37,250
0,300 300,540 540,930 930,1050 1050,1140
most ones that you know

1445
00:44:37,250 --> 00:44:38,600
0,180 180,750 750,870 870,1140 1140,1350
you know are not written

1446
00:44:38,600 --> 00:44:39,960
0,60 60,240 240,450 450,900
in C plus plus,|
|

1447
00:44:40,020 --> 00:44:41,430
0,540 540,780 780,840 840,1110 1110,1410
{} and the very reason
Linux 使用 C 而不是 C++ 的原因，

1448
00:44:41,430 --> 00:44:43,680
0,330 510,1020 1020,1170 1170,1560 1590,2250
for {} you know Linux

1449
00:44:43,680 --> 00:44:45,060
0,120 120,480 480,930 960,1200 1200,1380
is mostly C or no

1450
00:44:45,060 --> 00:44:46,290
0,180 180,360 360,630 630,900 900,1230
C plus plus,| {I,think} partially
|我想部分是因为 Linus 不喜欢 C++ 。

1451
00:44:46,290 --> 00:44:47,640
0,390 390,720 720,930 930,1170 1170,1350
because Linus just doesn't like

1452
00:44:47,640 --> 00:44:48,900
0,150 150,360 360,780
C plus plus.|
|

1453
00:44:54,640 --> 00:44:56,080
0,210 210,330 330,840
Any other questions?|
还有其他问题吗？|

1454
00:45:04,300 --> 00:45:05,720
0,300 300,870
Okay so,
好的，所以在这个角度来看，

1455
00:45:05,720 --> 00:45:06,350
0,90 90,180 180,360 360,570 570,630
so in this view of

1456
00:45:06,350 --> 00:45:08,990
0,120 120,510 540,1830 2010,2160 2160,2640
the world,| were you know
|我们有一种方式将控制权转移到内核，使用系统调用，使用 ecall 指令，

1457
00:45:09,020 --> 00:45:09,710
0,120 120,240 240,300 300,600 600,690
we have a way of

1458
00:45:09,710 --> 00:45:12,110
0,420 420,960 960,1620 1800,2220 2220,2400
transferring control into {} the

1459
00:45:12,110 --> 00:45:14,120
0,330 330,780 780,1260 1260,1590 1590,2010
operating system using system calls

1460
00:45:14,120 --> 00:45:16,790
0,210 210,690 690,1350 1680,2220 2220,2670
or ecall instruction| {} and
|内核负责实现真正的函数，

1461
00:45:17,000 --> 00:45:18,770
0,150 150,720 720,870 870,1080 1080,1770
the kernel is now responsible

1462
00:45:18,770 --> 00:45:21,650
0,660 900,1680 1680,2130 2130,2460 2490,2880
for implementing actually the actual

1463
00:45:21,650 --> 00:45:24,620
0,660 840,1200 1230,2010 2010,2460 2550,2970
functions| and ensuring {} checking
|确保检查参数或类似的事情，

1464
00:45:24,620 --> 00:45:25,820
0,540 540,630 630,810 810,930 930,1200
arguments and things like that|
|

1465
00:45:25,820 --> 00:45:26,720
0,60 60,210 210,510 510,750 750,900
to make sure that you
保证不会被骗而做一些坏事，

1466
00:45:26,720 --> 00:45:27,740
0,150 150,480
know that

1467
00:45:27,890 --> 00:45:29,090
0,330 330,570 570,720 720,900 900,1200
{} it's not being tricked

1468
00:45:29,090 --> 00:45:30,200
0,60 60,420 420,690 690,870 870,1110
or something, {} doing something

1469
00:45:30,200 --> 00:45:31,520
0,480 750,1020 1020,1110 1110,1170 1170,1320
badly| and so in this
|从这种角度看，内核有时候称为可信任计算基础，

1470
00:45:31,520 --> 00:45:32,870
0,270 270,360 360,450 450,960 1110,1350
view of the world {}

1471
00:45:32,870 --> 00:45:34,460
0,240 240,540 540,600 600,1020 1020,1590
the kernel is sometimes called

1472
00:45:37,200 --> 00:45:38,040
0,150 150,240 240,390 390,480 480,840
you know, it's the trusted

1473
00:45:38,040 --> 00:45:39,400
0,360 360,840
computing base,|
|

1474
00:45:46,920 --> 00:45:48,660
0,510 510,810 810,960 960,1410 1410,1740
sometimes called in security terms
有时在安全术语中称为 TCB 。

1475
00:45:48,660 --> 00:45:50,120
0,90 90,900
the TCB.|
|

1476
00:45:51,680 --> 00:45:53,600
0,570 720,1530 1530,1590 1590,1740 1740,1920
And basically you know what
可信任计算基础意思是，它必须正确，必须没有 bug 。

1477
00:45:53,600 --> 00:45:54,680
0,120 120,210 210,750 750,840 840,1080
does it mean to be

1478
00:45:54,680 --> 00:45:56,120
0,90 90,390 390,720 720,960 960,1440
the trusted computing base, well

1479
00:45:56,210 --> 00:45:57,710
0,180 180,360 360,450 450,870 1080,1500
it must be correct, kernel

1480
00:45:57,710 --> 00:45:59,180
0,210 210,330 330,480 480,960
must have no bug.|

1481
00:46:05,690 --> 00:46:06,560
0,300 300,420 420,600 600,660 660,870
Because if there's a bug
因为如果内核中有 bug ，

1482
00:46:06,560 --> 00:46:07,670
0,90 90,150 150,750 780,900 900,1110
in the kernel,| you know
|需要考虑这种方式，

1483
00:46:07,670 --> 00:46:08,570
0,120 120,270 270,390 390,570 570,900
the way to think about

1484
00:46:08,570 --> 00:46:09,830
0,150 150,330 330,630 630,690 690,1260
this stuff,| maybe an attacker
|可能攻击者会利用那个 bug ，使 bug 变成一个漏洞。

1485
00:46:09,830 --> 00:46:12,170
0,180 180,480 480,1440 1590,2160 2160,2340
is able to {} to

1486
00:46:12,170 --> 00:46:13,670
0,90 90,270 270,750 810,1290 1290,1500
take the bug and turn

1487
00:46:13,670 --> 00:46:14,810
0,60 60,270 270,480 480,570 570,1140
the bug into an exploit.|
|

1488
00:46:15,320 --> 00:46:16,910
0,570 570,750 750,900 900,1140 1140,1590
And you know that exploit
那个漏洞可能允许特定攻击者打破隔离，或者控制内核。

1489
00:46:16,910 --> 00:46:18,230
0,270 270,360 360,840 840,960 960,1320
may be allowed {} particular

1490
00:46:18,230 --> 00:46:19,700
0,510 510,900 900,1230 1230,1350 1350,1470
attacker to break out of

1491
00:46:19,700 --> 00:46:21,890
0,690 810,1230 1230,1500 1500,1680 1680,2190
isolation or maybe take control

1492
00:46:21,890 --> 00:46:23,220
0,240 240,330 330,810
over the kernel.|
|

1493
00:46:23,220 --> 00:46:24,360
0,270 270,360 360,480 480,720 720,1140
And so it's really important
这很重要，内核必须尽可能没有 bug 。

1494
00:46:24,360 --> 00:46:25,080
0,180 180,300 300,390 390,450 450,720
that you know the kernel

1495
00:46:25,080 --> 00:46:26,190
0,420 420,660 660,870 870,930 930,1110
really, it has to have

1496
00:46:26,190 --> 00:46:27,360
0,90 90,300 300,540 540,660 660,1170
as few bugs as possible.|
|

1497
00:46:29,620 --> 00:46:31,510
0,660 660,720 720,1350 1380,1560 1560,1890
Basically the kernel, you must
内核必须将用户程序当成是恶意的。

1498
00:46:31,540 --> 00:46:32,840
0,630
treat,

1499
00:46:35,440 --> 00:46:37,400
0,240 240,540 540,840 840,1350
must treat user apps,

1500
00:46:37,760 --> 00:46:39,840
0,660 660,750 750,1530
application of processes

1501
00:46:41,790 --> 00:46:43,220
0,210 210,870
as malicious.|
|

1502
00:46:47,210 --> 00:46:49,190
0,510 510,570 570,780 780,1440 1470,1980
Basically {as,I} said before, []
就像我之前说的，内核设计者必须有安全思维模式，

1503
00:46:49,190 --> 00:46:50,480
0,60 60,420 420,900 900,1110 1110,1290
the kernel designer should have

1504
00:46:50,480 --> 00:46:52,970
0,300 300,750 750,1470 1680,2340 2340,2490
a security mindset,| {} you
|在编写和实现内核代码的时候。

1505
00:46:52,970 --> 00:46:54,530
0,90 90,390 390,780 780,930 930,1560
know when writing and implementing

1506
00:46:54,530 --> 00:46:55,940
0,240 240,570 570,930
{} kernel code.|
|

1507
00:46:56,060 --> 00:46:58,700
0,480 570,1260 1260,1320 1710,2220 2220,2640
In {} in its heart
达成这个目标的关键是没有 bug ，

1508
00:46:58,700 --> 00:46:59,960
0,60 60,330 330,480 480,900 930,1260
to achieve this goal is

1509
00:46:59,960 --> 00:47:01,100
0,270 270,450 450,840 840,1020 1020,1140
have no bugs,| if the
|如果操作系统非常庞大，那不是那么简单的，

1510
00:47:01,100 --> 00:47:03,350
0,330 330,690 690,1650 1650,1860 1860,2250
operating system gigantic and big,

1511
00:47:03,530 --> 00:47:05,360
0,480 480,660 660,810 810,1440 1440,1830
it's not that straightforward| and
|几乎所有操作系统，用户广泛使用的，

1512
00:47:05,360 --> 00:47:07,010
0,390 390,630 630,990 990,1530 1530,1650
almost every operating system, you

1513
00:47:07,010 --> 00:47:09,020
0,180 180,390 870,1680 1680,1740 1740,2010
know the user is widely

1514
00:47:09,020 --> 00:47:10,580
0,510 720,1200 1200,1470 1470,1530 1530,1560
used,| {} once in a
|有时也会有安全性 bug ，它们随着时间得到修复，

1515
00:47:10,580 --> 00:47:11,870
0,390 390,660 660,900 900,930 930,1290
while actually has a security

1516
00:47:11,870 --> 00:47:14,360
0,390 450,960 1170,1710 1710,1890 1890,2490
bug and they get fixed

1517
00:47:14,360 --> 00:47:16,480
0,480 480,840 840,1020 1020,1620
over time,| but basically
|但是不论怎样，总会在某个时刻出现新的漏洞，

1518
00:47:16,540 --> 00:47:18,100
0,180 180,390 390,810 900,1170 1170,1560
no matter what, there's always

1519
00:47:18,100 --> 00:47:19,270
0,60 60,330 330,840 840,990 990,1170
a new exploit at some

1520
00:47:19,270 --> 00:47:21,730
0,450 480,1080 1080,1170 1170,1470 2010,2460
point down the line| and
|后面你会看到为什么保证所有东西正确是如此困难，

1521
00:47:21,730 --> 00:47:23,200
0,120 120,360 360,510 510,930 930,1470
you will see later {why,it's}

1522
00:47:23,200 --> 00:47:23,920
0,60 60,390 390,480 480,630 630,720
so tricky to get it

1523
00:47:23,920 --> 00:47:25,540
0,450 450,570 570,960 1080,1410 1410,1620
all at right,| {} but
|但是，你要理解内核必须做这些困难的事情，

1524
00:47:25,540 --> 00:47:26,830
0,150 150,270 270,660 870,1200 1200,1290
you know the sort of

1525
00:47:26,830 --> 00:47:28,660
0,630 630,990
understandable like

1526
00:47:28,660 --> 00:47:29,500
0,180 180,240 240,600 600,780 780,840
in the kernel has to

1527
00:47:29,500 --> 00:47:31,420
0,120 120,510 510,990 1290,1830 1830,1920
do tricky stuff,| {} it
|它要操作硬件，而且必须很小心地检查，

1528
00:47:31,420 --> 00:47:33,460
0,150 150,240 240,720 720,1380 1530,2040
has to manipulate hardware {},

1529
00:47:33,460 --> 00:47:34,150
0,180 180,330 330,390 390,480 480,690
it has to be very

1530
00:47:34,150 --> 00:47:35,800
0,420 420,510 510,750 750,1410 1470,1650
careful in it's checking,| it's
|很容易犯一个小错误，造成出现 bug 。

1531
00:47:35,800 --> 00:47:36,940
0,510 510,840 840,930 930,1080 1080,1140
very easy to make a

1532
00:47:36,940 --> 00:47:38,860
0,330 330,690 690,990 1140,1770 1770,1920
small slip up and you

1533
00:47:38,860 --> 00:47:40,280
0,240 240,510 510,630 630,990
know have a bug.|
|

1534
00:47:42,160 --> 00:47:43,440
0,270 270,780
And so,
所以一个显而易见的问题是，什么应该运行在内核模式，

1535
00:47:44,490 --> 00:47:45,700
0,720
{}

1536
00:47:47,140 --> 00:47:49,090
0,120 120,390 390,960 1320,1530 1530,1950
an instant question is then

1537
00:47:49,150 --> 00:47:50,740
0,360 360,510 510,1080 1110,1290 1290,1590
what should run in kernel

1538
00:47:50,740 --> 00:47:51,820
0,360 390,630 630,750 750,990 990,1080
mode,| because it's really the
|因为在内核模式中的内核代码是敏感代码，是可信任计算基础。

1539
00:47:51,820 --> 00:47:53,350
0,420 420,780 780,1170 1170,1290 1290,1530
kernel code actually is in

1540
00:47:53,350 --> 00:47:55,360
0,360 360,780 930,1350 1350,1530 1530,2010
kernel mode that is the

1541
00:47:56,200 --> 00:47:57,640
0,600 600,900 930,1110 1110,1350 1350,1440
sensitive code right, that is

1542
00:47:57,640 --> 00:47:59,320
0,90 90,450 450,840 840,1260
the trusted computing base.|
|

1543
00:47:59,350 --> 00:48:02,290
0,450 810,1230 1290,1650 1650,2250 2550,2940
{} And one answer to
这个问题的一种答案是，

1544
00:48:02,290 --> 00:48:04,420
0,450 480,1080 1080,1440 1440,1680 1680,2130
that question is| like, well
|我们有用户内核边界，这边是用户，这边是内核，

1545
00:48:04,510 --> 00:48:05,770
0,210 210,330 330,540 540,840 840,1260
you know we have our

1546
00:48:06,650 --> 00:48:08,300
0,420 420,690 690,1230 1230,1380 1380,1650
user kernel boundary, so here's

1547
00:48:08,300 --> 00:48:10,760
0,330 330,570 570,1230 1290,1860
user, here's kernel,| and
|用户程序运行，而这里是运行在内核模式的程序，

1548
00:48:10,760 --> 00:48:14,120
0,480 840,1470 1470,2430 2430,3000 3000,3360
{} user applications running, and

1549
00:48:14,120 --> 00:48:16,010
0,600 600,930 1080,1260 1260,1680 1680,1890
here is the program running

1550
00:48:16,010 --> 00:48:17,540
0,90 90,360 360,720 780,1140 1140,1530
in kernel mode,| one option
|一种选择是将整个操作系统置于内核模式，

1551
00:48:17,540 --> 00:48:18,740
0,180 180,270 270,510 510,600 600,1200
is to stick the whole

1552
00:48:18,740 --> 00:48:20,360
0,390 390,780 780,990 990,1290 1290,1620
operating system in kernel mode,|

1553
00:48:20,860 --> 00:48:22,960
0,120 120,840 930,1770 1770,1860 1860,2100
for example, {} in most
比如，在大多数 Unix 操作系统中，整个 Unix 实现运行在内核模式。

1554
00:48:22,960 --> 00:48:24,880
0,270 270,630 630,1200 1200,1320 1320,1920
Unix operating systems, the whole

1555
00:48:24,910 --> 00:48:26,890
0,390 390,1080 1080,1380 1380,1560 1560,1980
Unix implementation runs {} inside

1556
00:48:26,890 --> 00:48:28,210
0,60 60,330 330,690 900,1140 1140,1320
of kernel mode.| So you
|在 xv6 中，所有操作系统服务都在内核模式，

1557
00:48:28,210 --> 00:48:30,370
0,300 300,420 420,1230 1260,1740 1740,2160
have in xv6, all the

1558
00:48:30,400 --> 00:48:33,040
0,810 810,1080 1080,1680 1680,2010 2010,2640
operating system services are basically

1559
00:48:33,040 --> 00:48:35,280
0,900 1110,1470 1470,1800
in kernel mode,|
|

1560
00:48:35,310 --> 00:48:36,900
0,120 120,240 240,330 330,720 720,1590
and this is called monolithic
这被称为宏内核设计。

1561
00:48:39,860 --> 00:48:41,300
0,360 360,900
kernel design.|
|

1562
00:48:47,550 --> 00:48:49,220
0,450 450,540 540,630 630,1080
And you know there,
可以从几方面考虑这个设计，

1563
00:48:49,220 --> 00:48:51,050
0,180 180,510 1290,1590 1590,1830 1830,1830
there's a couple things are

1564
00:48:51,050 --> 00:48:52,040
0,90 90,210 210,330 330,480 480,990
the way to think {about,it},|
|

1565
00:48:52,100 --> 00:48:54,740
0,570 960,1470 1470,1890 1890,2400 2400,2640
{} one it's probably not
一方面它可能对减少 bug 不友好，

1566
00:48:54,740 --> 00:48:56,090
0,120 120,300 300,480 480,870 900,1350
so good for bugs, right,|
|

1567
00:48:56,660 --> 00:48:58,000
0,720

1568
00:48:58,910 --> 00:49:00,440
0,360 360,690 690,1200 1230,1410 1410,1530
because any bug you know
因为任何宏内核设计的 bug 可能成为漏洞，这是不好的，

1569
00:49:00,440 --> 00:49:01,520
0,180 180,270 270,510 510,960 960,1080
that you might have in

1570
00:49:01,520 --> 00:49:03,650
0,60 60,540 540,1200 1350,1800 1800,2130
{} monolithic design, might actually

1571
00:49:03,650 --> 00:49:05,630
0,240 240,690 690,1080 1110,1800 1800,1980
turn into an exploit and

1572
00:49:05,630 --> 00:49:07,430
0,330 330,780 1200,1410 1410,1560 1560,1800
{that,would,be} bad,| {} so we
|我们有一个很大的操作系统在内核中，

1573
00:49:07,430 --> 00:49:08,900
0,150 150,210 210,630 660,1080 1080,1470
have a large operating system

1574
00:49:08,900 --> 00:49:10,160
0,270 270,660 660,750 750,810 810,1260
running inside of the kernel,|
|

1575
00:49:10,160 --> 00:49:11,240
0,240 240,660 660,900 900,1020 1020,1080
it's likely they're going to
可能会有更多 bug ，

1576
00:49:11,240 --> 00:49:12,290
0,60 60,300 300,660 660,810 840,1050
be more bugs,| but any
|统计数据表明每千行代码都会有一些 bug ，

1577
00:49:12,290 --> 00:49:13,550
0,600 600,750 750,840 840,1020 1020,1260
statistics that could look up

1578
00:49:13,550 --> 00:49:14,840
0,60 60,300 300,450 450,990 990,1290
it says like every few

1579
00:49:14,840 --> 00:49:15,920
0,300 300,540 540,600 600,960 960,1080
thousand lines of code will

1580
00:49:15,920 --> 00:49:17,270
0,480 630,750 750,870 870,1080 1080,1350
have you know some small

1581
00:49:17,270 --> 00:49:18,440
0,270 270,360 360,810
number of bugs,|
|

1582
00:49:18,470 --> 00:49:19,010
0,150 150,240 240,330 330,420 420,540
and so if you have
所以如果你有很多行代码在内核中，

1583
00:49:19,010 --> 00:49:19,850
0,180 180,390 390,570 570,780 780,840
many, many more lines of

1584
00:49:19,850 --> 00:49:20,810
0,360 360,570 570,630 630,690 690,960
code running in the kernel

1585
00:49:20,810 --> 00:49:22,250
0,360 450,600 600,690 690,810 810,1440
block,| you know the probability
|出现严重 bug 的可能性就会变高，

1586
00:49:22,250 --> 00:49:23,480
0,150 150,540 540,660 660,780 780,1230
the chance that you have

1587
00:49:23,870 --> 00:49:26,660
0,690 690,1020 1020,1650 1680,2040 2040,2790
{} and the serious bug

1588
00:49:26,660 --> 00:49:27,410
0,180 180,300 300,330 330,510 510,750
goes up a little bit|
|

1589
00:49:27,500 --> 00:49:29,210
0,210 210,540 630,1440 1440,1680 1680,1710
and so downside for {monolithic
所以宏内核设计的缺点是，从安全角度来说，有很多代码在内核中。

1590
00:49:29,210 --> 00:49:30,620
0,480 480,780 780,1200 1200,1350 1350,1410
-} kernel design from {}

1591
00:49:30,620 --> 00:49:31,970
0,330 330,810 810,960 960,1290 1290,1350
security perspective is there's a

1592
00:49:31,970 --> 00:49:33,650
0,270 270,330 330,780 810,1200 1590,1680
lot of code in the

1593
00:49:33,650 --> 00:49:34,540
0,420
kernel.|
|

1594
00:49:34,900 --> 00:49:37,390
0,420 570,900 900,1200 1200,1680 1860,2490
{} The plus though is|
好的方面是，|

1595
00:49:37,390 --> 00:49:38,920
0,120 120,510 810,1320 1320,1410 1410,1530
you know typically if you
操作系统包含所有不同的部分，

1596
00:49:38,920 --> 00:49:40,090
0,210 210,450 450,510 510,840 840,1170
think about an operating system

1597
00:49:40,090 --> 00:49:41,110
0,420 420,540 540,720 720,780 780,1020
contains all kinds of different

1598
00:49:41,110 --> 00:49:42,070
0,480 480,570 570,660 660,750 750,960
pieces,| you know you might
|可能包含文件系统，可能包含虚拟内存，可能包含进程，

1599
00:49:42,070 --> 00:49:43,330
0,120 120,210 210,510 510,750 750,1260
have {} file system piece,

1600
00:49:43,630 --> 00:49:44,560
0,210 210,390 390,540 540,630 630,930
you might have the virtual

1601
00:49:44,560 --> 00:49:45,780
0,360 360,840
memory piece,

1602
00:49:45,780 --> 00:49:48,120
0,510 510,660 660,960 960,1380 1410,2340
{} you might have processes|
|

1603
00:49:48,900 --> 00:49:49,410
0,150 150,270 270,360 360,390 390,510
and so there are all
在操作系统中有实现特定功能的不同的子模块。

1604
00:49:49,410 --> 00:49:50,940
0,180 180,420 420,690 690,1200 1200,1530
kinds of sub modules inside

1605
00:49:50,940 --> 00:49:51,990
0,90 90,240 240,570 570,900 900,1050
of the operating system that

1606
00:49:51,990 --> 00:49:53,980
0,420 420,780 780,1440
implement particular functionality.|
|

1607
00:49:54,100 --> 00:49:55,240
0,300 300,480 540,780 780,1020 1020,1140
And the plus side of
好的方面是，这些不同的子模块可以紧密结合，

1608
00:49:55,240 --> 00:49:56,020
0,330 330,450 450,600 600,720 720,780
that is there's going to

1609
00:49:56,020 --> 00:49:57,780
0,90 90,420 420,1170
be tight integration,

1610
00:49:57,900 --> 00:50:00,030
0,780 1200,1560 1560,1710 1710,1980 1980,2130
possible between these different sub

1611
00:50:00,030 --> 00:50:01,680
0,600 750,930 930,1110 1110,1350 1350,1650
modules,| if they're all sitting
|它们都在一个程序中，这种联系会带来很好的性能。

1612
00:50:01,680 --> 00:50:03,160
0,90 90,180 180,420 420,900
in the same program

1613
00:50:03,440 --> 00:50:05,000
0,360 360,540 540,930 930,1260 1260,1560
and that connection leads to

1614
00:50:05,000 --> 00:50:06,440
0,270 270,960
great performance.|
|

1615
00:50:11,250 --> 00:50:12,330
0,330 330,780 780,840 840,930 930,1080
An example, if you look
举个例子，如果你查看 Linux 操作系统，它达到了很好的性能。

1616
00:50:12,330 --> 00:50:13,620
0,120 120,180 180,480 480,780 780,1290
at {} operating system Linux,

1617
00:50:14,040 --> 00:50:16,080
0,210 210,630 630,1290 1320,1740 1740,2040
it actually achieves a very

1618
00:50:16,080 --> 00:50:17,540
0,330 330,990
impressive performance.|
|

1619
00:50:17,540 --> 00:50:18,860
0,240 240,390 390,510 510,690 690,1320
{} And so there's one,
还有另外一种设计，

1620
00:50:18,890 --> 00:50:20,920
0,630 630,870 870,1500
{} one design,

1621
00:50:20,920 --> 00:50:22,930
0,360 360,720 720,1380 1410,1710 1710,2010
{} another design| which basically
|主要目标是减少内核中的代码，就是所谓的微内核设计。

1622
00:50:22,930 --> 00:50:24,520
0,570 570,810 810,1290 1290,1350 1350,1590
focuses on reducing the amount

1623
00:50:24,520 --> 00:50:25,600
0,60 60,330 330,480 480,540 540,1080
of code in the kernel

1624
00:50:25,840 --> 00:50:27,520
0,480 480,720 720,1170 1170,1440 1440,1680
is what's called micro kernel

1625
00:50:27,520 --> 00:50:28,520
0,450
design.|
|

1626
00:50:35,100 --> 00:50:36,450
0,150 150,240 240,450 450,1080 1170,1350
And in this design, your
在这种设计中，目标是在内核模式中运行尽量少的代码，

1627
00:50:36,450 --> 00:50:37,410
0,210 210,300 300,630 630,750 750,960
goal is actually to run

1628
00:50:37,410 --> 00:50:39,540
0,150 150,1110 1110,1380 1380,1500 1500,2130
as fewer lines as possible

1629
00:50:39,540 --> 00:50:41,100
0,150 150,450 450,870 1170,1440 1440,1560
in kernel mode| and for
|比如，有一些东西在内核中，

1630
00:50:41,100 --> 00:50:42,780
0,330 330,480 480,780 810,1380 1380,1680
example there is something in

1631
00:50:42,780 --> 00:50:43,940
0,600
kernel,|
|

1632
00:50:44,210 --> 00:50:45,230
0,240 240,360 360,420 420,780 780,1020
{} but the kernel has
但是内核中包含很少的组件，

1633
00:50:45,230 --> 00:50:48,230
0,270 270,1020 1020,2100 2220,2670 2670,3000
very few {} components {in,it},|
|

1634
00:50:48,230 --> 00:50:49,610
0,210 210,540 540,960 960,1170 1170,1380
so general typically has some
一般包含某种形式的 IPC 或消息传递，

1635
00:50:49,610 --> 00:50:51,560
0,540 570,780 810,1500 1500,1620 1620,1950
form of IPC or message

1636
00:50:51,560 --> 00:50:52,660
0,570
passing,|
|

1637
00:50:53,030 --> 00:50:54,680
0,150 150,390 390,540 540,810 1200,1650
a little bit of VM
少量的虚拟内存支持，基本上，只有页表相关的东西，

1638
00:50:54,680 --> 00:50:56,660
0,510 510,810 810,1410
support very minimal,

1639
00:50:56,890 --> 00:50:58,750
0,600 600,960 960,1140 1140,1740 1740,1860
basically, only thing necessary for

1640
00:50:58,750 --> 00:51:00,700
0,270 270,900 1050,1260 1260,1800 1800,1950
page tables| and something to
|一些复用不同 CPU 的东西，复用代码。

1641
00:51:00,700 --> 00:51:04,540
0,900 1260,2070 2160,2730 2730,3330
multiplex {} different CPUs,

1642
00:51:04,850 --> 00:51:05,780
0,210 210,300 300,360 360,870 870,930
so {some -} {multiplexing -}

1643
00:51:05,780 --> 00:51:06,820
0,480
code.|
|

1644
00:51:09,610 --> 00:51:10,990
0,480 480,870 870,960 960,1260 1260,1380
But generally the goal is
但是通常的目标是使操作系统 bug 处于内核之外。

1645
00:51:10,990 --> 00:51:12,430
0,210 210,630 630,810 810,1290 1320,1440
to run the bug of

1646
00:51:12,430 --> 00:51:14,050
0,150 150,600 600,1020 1050,1530 1530,1620
the opening system outside of

1647
00:51:14,050 --> 00:51:15,040
0,60 60,450
the kernel.|
|

1648
00:51:15,040 --> 00:51:16,300
0,120 120,330 330,750 750,1110 1110,1260
And so {for,example} again, as
比如，我们在这里有边界，

1649
00:51:16,300 --> 00:51:18,310
0,180 180,420 420,810 840,1530 1530,2010
we have our boundary here,|
|

1650
00:51:18,610 --> 00:51:19,750
0,330 330,570 570,750 750,1020 1020,1140
{} what we'll do is
我们要做的是把内核的其他部分当作普通用户程序，

1651
00:51:19,750 --> 00:51:22,150
0,570 600,990 990,1260 1260,1860 2100,2400
actually we'll run other parts

1652
00:51:22,150 --> 00:51:23,380
0,60 60,150 150,510 510,660 660,1230
of the kernel as user

1653
00:51:23,380 --> 00:51:25,480
0,360 360,600 600,1320 1350,1500 1500,2100
normal user applications,| for example
|比如，你可能有一个用户进程，

1654
00:51:25,570 --> 00:51:27,420
0,210 210,450 450,990
you might have,

1655
00:51:34,380 --> 00:51:35,370
0,270 270,420 420,630 630,750 750,990
you might have a user

1656
00:51:35,370 --> 00:51:37,950
0,660 810,1230 1230,1650 2100,2340 2340,2580
process,| but still it's not
|不是我想要的（颜色），但没关系，

1657
00:51:37,950 --> 00:51:39,570
0,300 300,390 390,720 720,1140 1470,1620
intended, but doesn't matter,| you
|我做的是文件服务器，

1658
00:51:39,570 --> 00:51:40,350
0,60 60,150 150,240 240,390 390,780
know what I just did

1659
00:51:40,940 --> 00:51:42,220
0,240 240,720
file server,|
|

1660
00:51:42,280 --> 00:51:43,660
0,540 540,870 870,1080 1080,1290 1290,1380
and so and then the
文件服务器只是在普通用户空间，

1661
00:51:43,660 --> 00:51:44,530
0,240 240,450 450,510 510,750 750,870
file server is just in

1662
00:51:44,530 --> 00:51:46,280
0,450 450,690 690,1230
regular user space,|
|

1663
00:51:46,610 --> 00:51:48,380
0,330 330,840 840,1380 1410,1560 1560,1770
user space, kernel,| so even
用户空间，内核，|尽管我意外使用了红色来画图，我希望是使用黑色，

1664
00:51:48,380 --> 00:51:49,670
0,210 210,270 270,720 720,1080 1080,1290
though I drew a by

1665
00:51:49,670 --> 00:51:51,410
0,360 360,450 450,840 990,1410 1410,1740
accident in red, I intended

1666
00:51:51,410 --> 00:51:53,240
0,450 450,900 1080,1350 1350,1440 1440,1830
to {draw,in,black},| {} the {file,system}
|文件系统就像用户程序，比如 echo shell ，

1667
00:51:53,240 --> 00:51:54,290
0,60 60,300 300,600 600,780 780,1050
{} might running a user

1668
00:51:54,290 --> 00:51:57,380
0,660 660,1290 1590,2430
application like echo,

1669
00:51:57,380 --> 00:51:58,850
0,60 60,360 360,450 450,1170 1200,1470
you know the shell,| they're
|它们都运行在用户空间，

1670
00:51:58,850 --> 00:52:00,050
0,270 270,510 510,600 600,840 840,1200
all run in user space|
|

1671
00:52:00,050 --> 00:52:01,070
0,120 120,300 300,480 480,630 630,1020
and we might have other
我们可能有其他的用户程序，

1672
00:52:01,100 --> 00:52:02,960
0,540 540,930 930,1260 1530,1800 1800,1860
user applications| like parts of
|比如部分虚拟内存系统在用户模式运行普通用户程序。

1673
00:52:02,960 --> 00:52:04,160
0,60 60,360 360,750 780,990 990,1200
the VM system might actually

1674
00:52:04,160 --> 00:52:05,900
0,180 180,420 420,840 840,1050 1050,1740
run the regular user application

1675
00:52:06,900 --> 00:52:09,800
0,600 720,1320 1500,2040 2040,2340
in {} user mode.|
|

1676
00:52:09,920 --> 00:52:10,520
0,150 150,240 240,390 390,480 480,600
And so this is sort
所以这是一种不错的设计，

1677
00:52:10,520 --> 00:52:11,450
0,90 90,120 120,330 330,690 690,930
of a nice design correct,|
|

1678
00:52:11,450 --> 00:52:13,100
0,420 690,900 900,1200 1200,1260 1260,1650
because the amount of code
因为内核中的代码量可能很少。

1679
00:52:13,100 --> 00:52:14,150
0,120 120,540 540,750 750,990 990,1050
that presumably that's in the

1680
00:52:14,150 --> 00:52:16,240
0,600 810,990 990,1560
kernel is small.|
|

1681
00:52:18,820 --> 00:52:21,400
0,180 180,840 1200,1620 1620,2010 2010,2580
It's small and small means,
很少意味着更少的 bug 。

1682
00:52:21,430 --> 00:52:23,440
0,570 570,930 930,1440
hopefully fewer bugs.|
|

1683
00:52:28,060 --> 00:52:30,010
0,510 540,810 810,1440 1500,1680 1680,1950
The one issue, of course
一个问题是，当然我们需要安排 shell 可以访问文件系统，

1684
00:52:30,010 --> 00:52:31,270
0,180 180,480 480,630 630,720 720,1260
like we have to arrange

1685
00:52:31,270 --> 00:52:32,230
0,180 180,240 240,570 570,690 690,960
that the shell can talk

1686
00:52:32,230 --> 00:52:33,610
0,120 120,210 210,480 480,810 810,1380
to the file system,| {for,example},
|比如， shell 调用 exec ，必许有一种方式访问文件系统，

1687
00:52:33,610 --> 00:52:35,500
0,150 150,420 420,720 720,1260 1380,1890
the shell calls exec and

1688
00:52:35,500 --> 00:52:36,040
0,120 120,270 270,330 330,450 450,540
there has to be a

1689
00:52:36,040 --> 00:52:37,090
0,210 210,330 330,840 840,960 960,1050
way of getting to the

1690
00:52:37,090 --> 00:52:38,710
0,240 240,600 900,1080 1080,1260 1260,1620
file system| and so typically
|通常工作方式是， shell 通过 IPC 系统发送一个消息给内核，

1691
00:52:38,710 --> 00:52:39,550
0,120 120,270 270,420 420,720 720,840
the way that works is

1692
00:52:39,550 --> 00:52:41,080
0,300 480,660 660,1200 1200,1350 1350,1530
that the shell will send

1693
00:52:41,080 --> 00:52:42,790
0,60 60,720 840,1200 1200,1290 1290,1710
a message through the IPC

1694
00:52:42,790 --> 00:52:43,840
0,600
system

1695
00:52:44,040 --> 00:52:45,660
0,150 150,210 210,810 1260,1350 1350,1620
to the kernel,| the kernel
|内核查看，知道需要访问文件系统，发送给文件系统，

1696
00:52:45,660 --> 00:52:46,170
0,90 90,270 270,360 360,420 420,510
will look at it and

1697
00:52:46,170 --> 00:52:46,950
0,150 150,300 300,600 600,660 660,780
say like oh you know

1698
00:52:46,950 --> 00:52:47,670
0,120 120,180 180,540 540,630 630,720
this is intended for the

1699
00:52:47,670 --> 00:52:48,780
0,270 270,660 660,780 780,840 840,1110
file system, so the file

1700
00:52:48,780 --> 00:52:49,980
0,360 360,660 660,810 810,930 930,1200
system sent to the file

1701
00:52:49,980 --> 00:52:51,000
0,480
system,|
|

1702
00:52:51,590 --> 00:52:53,060
0,120 120,360 360,630 630,900 900,1470
the file system {does,for} work,
文件系统工作，返回一条消息，

1703
00:52:53,640 --> 00:52:54,480
0,120 120,300 300,540 540,570 570,840
you know sends a message

1704
00:52:54,480 --> 00:52:56,430
0,570 930,1200 1200,1470 1470,1680 1680,1950
back| saying you know, here's
|表明这是 exec 系统调用的结果，

1705
00:52:56,430 --> 00:52:57,840
0,60 60,540 540,720 720,1140 1140,1410
the results of your exec

1706
00:52:57,840 --> 00:52:59,580
0,270 270,810 900,1170 1170,1560 1560,1740
system call| and then {you,know}
|然会发回给 shell 。

1707
00:52:59,580 --> 00:53:00,570
0,210 210,270 270,510 510,720 720,990
send it back to the

1708
00:53:00,570 --> 00:53:01,500
0,390
shell.|
|

1709
00:53:01,830 --> 00:53:03,750
0,210 210,600 810,1380 1410,1680 1680,1920
And so, {} these are
所以，这通常是使用消息实现的，

1710
00:53:03,750 --> 00:53:06,270
0,510 510,1020 1020,1230 1230,1800 2130,2520
typically implemented using messages {},|
|

1711
00:53:06,270 --> 00:53:08,340
0,210 210,570 600,900 900,1470 1500,2070
and so for any interaction
所以对于任何与文件服务的交互，

1712
00:53:08,340 --> 00:53:09,840
0,150 150,240 240,510 510,1080 1140,1500
with the file server,| now
|现在必须跳入内核，跳出内核，再跳入内核，再跳出内核。

1713
00:53:09,840 --> 00:53:11,340
0,150 150,300 300,570 690,1230 1230,1500
you have to jump once

1714
00:53:11,340 --> 00:53:12,540
0,150 150,210 210,690 720,990 990,1200
into the kernel, once out

1715
00:53:12,540 --> 00:53:13,770
0,60 60,150 150,630 660,960 960,1230
of the kernel, once into

1716
00:53:13,770 --> 00:53:14,760
0,90 90,510 540,780 780,930 930,990
the kernel, once out of

1717
00:53:14,760 --> 00:53:15,700
0,90 90,480
the kernel.|
|

1718
00:53:15,730 --> 00:53:16,570
0,180 180,270 270,540 540,720 720,840
If you compare that with
与前面的设计比较，

1719
00:53:16,570 --> 00:53:18,610
0,60 60,450 450,990 1380,1590 1590,2040
the previous design,| like if
|访问文件系统，有一次系统调用跳入，一次跳出。

1720
00:53:18,610 --> 00:53:19,570
0,210 210,540 540,720 720,780 780,960
this guy wants to talk

1721
00:53:19,570 --> 00:53:20,710
0,60 60,150 150,420 420,960 990,1140
to the file system, it's

1722
00:53:20,710 --> 00:53:22,150
0,180 180,480 480,660 660,1110 1230,1440
one system call in and

1723
00:53:22,150 --> 00:53:23,830
0,300 300,720 720,1050 1050,1350 1350,1680
one basically call back out.|
|

1724
00:53:24,320 --> 00:53:25,490
0,150 150,360 360,810 810,960 960,1170
So you double the number
所以系统调用次数翻了一番。

1725
00:53:25,490 --> 00:53:28,100
0,630 900,1350 1410,1800 1800,2040 2040,2610
of {} system called entries.|
|

1726
00:53:28,860 --> 00:53:31,440
0,150 150,510 960,1530 1770,2250 2250,2580
And so {} one typical
所以微内核方式的一个典型的问题或挑战是如何获得高性能。

1727
00:53:31,440 --> 00:53:33,300
0,600 600,780 780,1260 1260,1440 1440,1860
problem or challenge which offers

1728
00:53:33,300 --> 00:53:35,190
0,90 90,420 420,690 690,1440 1650,1890
the micro kernel approaches {}

1729
00:53:35,190 --> 00:53:36,360
0,210 210,600 600,780 780,840 840,1170
is actually how to achieve

1730
00:53:36,360 --> 00:53:37,660
0,150 150,870
good performance.|
|

1731
00:53:37,890 --> 00:53:38,490
0,120 120,210 210,330 330,540 540,600
And they have sort of
它由两部分组成，

1732
00:53:38,490 --> 00:53:40,160
0,180 180,720 720,870 870,1110
two components to it,|
|

1733
00:53:40,700 --> 00:53:41,980
0,720
one
一个是在用户模式和内核之间来回切换来完成事情，

1734
00:53:42,180 --> 00:53:43,560
0,510 510,630 630,720 720,960 960,1380
{} you know just jumping

1735
00:53:43,560 --> 00:53:45,120
0,210 210,300 300,810 840,1290 1290,1560
back and forth between user

1736
00:53:45,120 --> 00:53:46,230
0,240 240,330 330,600 600,990 990,1110
mode and kernel mode to

1737
00:53:46,230 --> 00:53:47,640
0,210 210,390 390,600 600,960 1290,1410
actually get something done| and
|第二是，因为不同的部分彼此隔离，没有紧密结合，

1738
00:53:47,640 --> 00:53:49,380
0,60 60,360 360,630 630,930 990,1740
the second part is because

1739
00:53:49,380 --> 00:53:50,460
0,90 90,210 210,450 480,810 810,1080
you know the different pieces

1740
00:53:50,460 --> 00:53:51,960
0,120 120,390 390,900 900,1380 1380,1500
are really well isolated from

1741
00:53:51,960 --> 00:53:53,460
0,120 120,480 510,690 690,960 960,1500
each other, a tight integration

1742
00:53:53,460 --> 00:53:55,220
0,150 150,660 750,870 870,1140
is less,| you know,
|使得安排更复杂，

1743
00:53:55,220 --> 00:53:56,900
0,240 240,810 810,870 870,1410 1410,1680
more complicated to arrange than,|
|

1744
00:53:56,900 --> 00:53:57,860
0,60 60,360 360,420 420,480 480,960
for example in the monolithic
比如在宏内核中，每个部分都可以，

1745
00:53:57,860 --> 00:53:59,750
0,300 300,450 450,990 1020,1560 1560,1890
kernel where basically everybody can|
|

1746
00:54:00,020 --> 00:54:01,280
0,570 570,630 630,900 900,1200 1200,1260
{for,example} the file system {}
比如文件系统，虚拟内存系统可以很容易地共享页缓存，

1747
00:54:01,280 --> 00:54:02,210
0,60 60,330 330,570 570,810 810,930
the virtual memory system can

1748
00:54:02,210 --> 00:54:04,610
0,480 540,1140 1140,1620 1620,1920 1920,2400
easily share a page cache,|
|

1749
00:54:04,730 --> 00:54:05,900
0,300 300,330 330,480 480,570 570,1170
which a little bit harder
这在微内核设计中是比较难的，

1750
00:54:05,900 --> 00:54:06,710
0,90 90,450 450,510 510,570 570,810
to achieve in the micro

1751
00:54:06,710 --> 00:54:07,850
0,240 240,660 660,750 750,1050 1050,1140
kernel design| and therefore it's
|因此，有时它更难获得高性能。

1752
00:54:07,850 --> 00:54:09,830
0,450 450,630 630,1230 1410,1740 1770,1980
sometimes more difficult to get

1753
00:54:09,830 --> 00:54:11,060
0,150 150,870
high performance.|
|

1754
00:54:12,170 --> 00:54:14,630
0,210 210,360 360,1290 1380,1980 1980,2460
Now these distinctions between micro
这些是微内核和宏内核高层次的区别，

1755
00:54:14,630 --> 00:54:16,850
0,150 150,720 720,1050 1050,1620 1650,2220
and monolithic very high-level,| so
|在实践中，两种内核设计都有应用，

1756
00:54:16,850 --> 00:54:18,950
0,210 210,840 1080,1770 1770,2010 2010,2100
in practice both types of

1757
00:54:18,950 --> 00:54:22,040
0,270 270,870 870,1080 1080,1440 1740,3090
kernel designs show up,| most
|因为历史原因，大多数桌面操作系统是宏内核系统。

1758
00:54:22,040 --> 00:54:24,350
0,510 510,870 870,1440 1440,1740 1740,2310
desktop operating systems are typically

1759
00:54:24,350 --> 00:54:26,360
0,480 480,570 570,1230 1320,1890 1890,2010
monolithic {} systems, mostly for

1760
00:54:26,360 --> 00:54:27,840
0,480 480,1050
historical reasons.|
|

1761
00:54:27,840 --> 00:54:29,670
0,600 720,1020 1020,1140 1140,1710 1740,1830
A lot of the if
很多，如果你运行密集型，操作系统密集型应用程序，

1762
00:54:29,670 --> 00:54:31,650
0,120 120,600 630,900 990,1380 1380,1980
you run {} very intense

1763
00:54:31,650 --> 00:54:33,300
0,90 90,210 210,570 570,930 930,1650
you know OS intense applications|
|

1764
00:54:33,300 --> 00:54:34,140
0,150 150,450 450,510 510,600 600,840
for example in the data
比如数据中心，它们一般运行在宏内核，

1765
00:54:34,140 --> 00:54:35,400
0,390 390,540 540,900 900,1140 1140,1260
center, they typically run on

1766
00:54:35,400 --> 00:54:38,490
0,480 510,1200 1200,1680 2010,2370 2400,3090
a monolithic kernel,| {} mostly
|主要是因为 Linux 提供了良好的性能，

1767
00:54:38,490 --> 00:54:40,140
0,270 270,810 810,1080 1080,1440 1440,1650
because {for,example} Linux provides great

1768
00:54:40,140 --> 00:54:42,720
0,690 840,1230 1230,1680 1680,2250 2250,2580
performance,| but many {} {for,example}
|但是很多嵌入式系统比如 Minix 或 seL4 ，

1769
00:54:42,720 --> 00:54:45,480
0,510 510,1200 1380,2160 2160,2670 2670,2760
embedded [systems] like Minix or

1770
00:54:45,480 --> 00:54:48,570
0,1380 1500,2580 2580,2850 2850,3030 3030,3090
{seL4 -},| {those,all} tend to
|它们往往是微内核设计。

1771
00:54:48,570 --> 00:54:50,490
0,390 420,780 780,1110 1110,1320 1320,1920
be a micro kernel designs.|
|

1772
00:54:51,490 --> 00:54:52,330
0,150 150,240 240,450 450,780 780,840
And so both designs are
两种设计都很流行，

1773
00:54:52,330 --> 00:54:54,250
0,600 870,1440 1440,1590 1590,1680 1680,1920
popular,| {} you could probably
|你可以从头开始设计一个新的操作系统，

1774
00:54:54,250 --> 00:54:55,600
0,270 270,300 300,660 660,1170 1170,1350
start a new operation {system,from}

1775
00:54:55,600 --> 00:54:58,000
0,630 870,1200 1200,1410 1410,1890 1890,2400
scratch,| {} you probably start
|你可以从一个微内核设计开始。

1776
00:54:58,000 --> 00:55:00,400
0,600 600,1110 1140,1590 1590,1950 1950,2400
with, {} you know {}

1777
00:55:00,610 --> 00:55:01,780
0,480 480,600 600,870 870,1020 1020,1170
you may start with a

1778
00:55:01,780 --> 00:55:03,300
0,270 270,510 510,1050
micro kernel design.|
|

1779
00:55:03,300 --> 00:55:04,890
0,540 780,1170 1170,1290 1290,1530 1530,1590
And once you have a
一旦你有一个像 Linux 的宏内核设计，

1780
00:55:04,890 --> 00:55:06,360
0,420 420,840 840,1050 1050,1140 1140,1470
monolithic design like for example

1781
00:55:06,360 --> 00:55:07,860
0,480 630,930 930,1050 1050,1110 1110,1500
Linux,| it's going to be
|重写成微内核设计会有很多工作要做，

1782
00:55:07,920 --> 00:55:08,820
0,210 210,360 360,450 450,780 780,900
would be a ton of

1783
00:55:08,820 --> 00:55:10,020
0,330 330,450 450,870 870,1080 1080,1200
work to rewrite anything to

1784
00:55:10,020 --> 00:55:11,430
0,60 60,450 450,720 720,1170 1170,1410
{} micro kernel design,| as
|可能不利于[激励]，

1785
00:55:11,430 --> 00:55:13,020
0,570 630,930 930,1380 1380,1500 1500,1590
maybe not conducive to the

1786
00:55:13,020 --> 00:55:14,490
0,690 690,930 930,1230 1230,1380 1380,1470
[incentives],| people probably want to
|人们更想花时间来增加新功能，而不是重新设计内核。

1787
00:55:14,490 --> 00:55:16,020
0,240 300,660 660,1020 1020,1410 1410,1530
spend rather time implementing new

1788
00:55:16,020 --> 00:55:19,680
0,540 690,1020 1020,1530 1740,2280 2640,3660
features than actually { -}

1789
00:55:19,770 --> 00:55:21,540
0,840 840,930 930,1380
restructuring the kernel.|
|

1790
00:55:22,190 --> 00:55:23,750
0,510 720,930 930,1110 1110,1200 1200,1560
{} So, these are {sort,of}
这是两种主要的设计，

1791
00:55:23,750 --> 00:55:26,630
0,60 60,360 360,1050 1080,1800 1890,2880
{} two main designs {},|
|

1792
00:55:26,630 --> 00:55:27,980
0,150 150,360 360,690 690,1230 1230,1350
as you know xv6 is
如你所知， xv6 是宏内核设计，是经典 Unix 系统所采用的，

1793
00:55:27,980 --> 00:55:30,170
0,600 840,1140 1140,1260 1260,1770 1770,2190
{} falls into monolithic design,

1794
00:55:30,170 --> 00:55:31,790
0,90 90,360 360,750 750,1170 1170,1620
is most classic Unix systems

1795
00:55:31,790 --> 00:55:33,350
0,360 600,1170 1170,1410 1410,1470 1470,1560
do,| but later in the
|但是在本学期晚些时候，我们会讨论更多微内核设计的细节。

1796
00:55:33,350 --> 00:55:35,030
0,690 780,1170 1170,1440 1440,1620 1620,1680
semester, {} we'll talk a

1797
00:55:35,030 --> 00:55:36,290
0,270 270,450 450,510 510,960 960,1260
lot more in detail about

1798
00:55:36,290 --> 00:55:37,640
0,180 180,300 300,660 720,1080 1080,1350
some of the micro kernel

1799
00:55:37,640 --> 00:55:38,560
0,570
designs.|
|

1800
00:55:40,180 --> 00:55:41,440
0,240 240,540 540,720 720,1050 1050,1260
Any questions about this, because
还有什么问题吗，因为这是邮件问题中的热门话题。

1801
00:55:41,440 --> 00:55:42,400
0,120 120,300 300,360 360,600 600,960
this was a hot topic

1802
00:55:42,400 --> 00:55:43,520
0,150 150,540
in the,

1803
00:55:43,810 --> 00:55:45,660
0,150 150,270 270,660 660,1320
in the email questions.|
|

1804
00:55:54,630 --> 00:55:55,760
0,630
Okay.|
好的。|

1805
00:55:56,060 --> 00:55:57,770
0,510 540,810 810,990 990,1230 1230,1710
{} Okay, let me switch
好的，让我转换一下，

1806
00:55:57,800 --> 00:55:58,880
0,300 300,510 510,840 870,960 960,1080
a little bit,| I'm going
|我会转到一些代码，看看这些在 xv6 中是如何运行的。

1807
00:55:58,880 --> 00:56:00,260
0,270 300,630 630,720 720,870 870,1380
to switch to some code

1808
00:56:00,290 --> 00:56:01,760
0,360 360,630 630,990 990,1170 1170,1470
and see how this plays

1809
00:56:01,760 --> 00:56:03,980
0,360 360,960 990,1500 1500,1740 1740,2220
out in {} {xv6 -}.|
|

1810
00:56:05,930 --> 00:56:08,120
0,720 750,990 990,1410 1410,1800 1980,2190
{} So here's {} two
这里有两个窗口。

1811
00:56:08,120 --> 00:56:09,460
0,870
windows.|
|

1812
00:56:09,840 --> 00:56:12,390
0,780 1020,2190 2190,2220 2220,2460 2460,2550
{} {You,know} emacs, {you -}
在 emacs 窗口，是 proc 结构体，

1813
00:56:12,390 --> 00:56:13,410
0,210 210,540 540,690 690,750 750,1020
know with like the proc

1814
00:56:13,410 --> 00:56:15,510
0,600 990,1680 1680,1860 1860,1920 1920,2100
structure,| {} and the first
|我首先做的是，查看一下代码库，

1815
00:56:15,510 --> 00:56:16,530
0,90 90,180 180,360 360,630 630,1020
thing I wanna do is,

1816
00:56:16,860 --> 00:56:18,480
0,780 780,1020 1080,1440 1440,1470 1470,1620
{} {you,know} look a little

1817
00:56:18,480 --> 00:56:19,470
0,120 120,180 180,240 240,480 480,990
bit at the code base,|
|

1818
00:56:19,500 --> 00:56:20,670
0,270 270,390 390,630 630,990 990,1170
{} you've probably already done
你们可能已经做过了，

1819
00:56:20,670 --> 00:56:21,750
0,330 390,690 690,780 780,930 930,1080
this,| but you see that
|你可以看到代码分为三个部分，一个是 kernel 。

1820
00:56:21,750 --> 00:56:23,130
0,60 60,330 330,450 450,1110 1110,1380
the code is organized around

1821
00:56:23,130 --> 00:56:26,010
0,690 810,1920 1920,2040 2040,2400 2460,2880
three {} in three parts,

1822
00:56:26,010 --> 00:56:27,420
0,270 270,330 330,870
one to kernel.|
|

1823
00:56:27,700 --> 00:56:29,170
0,540 540,720 720,1110 1110,1200 1200,1470
And you know the kernel
kernel 包含了所有的内核文件，

1824
00:56:29,170 --> 00:56:31,450
0,180 180,510 510,900 900,1380 1380,2280
that basically includes all the

1825
00:56:31,510 --> 00:56:33,940
0,420 420,1020 1620,1920 1920,2160 2160,2430
kernel files,| {xv6 -} being
|xv6 是宏内核，所有这些程序编译成一个二进制文件 kernel ，

1826
00:56:33,940 --> 00:56:36,520
0,330 330,750 750,1290 1440,2010 2010,2580
a monolithic kernel, basically all

1827
00:56:36,580 --> 00:56:38,620
0,450 480,1110 1110,1320 1320,1860 1860,2040
these programs are compiled into

1828
00:56:38,620 --> 00:56:39,670
0,120 120,390 390,840 840,990 990,1050
a single binary called the

1829
00:56:39,670 --> 00:56:40,990
0,540 540,630 630,840 840,1110 1110,1320
kernel| and that's actually what
|那就是运行在内核模式的部分。

1830
00:56:40,990 --> 00:56:42,220
0,60 60,480 480,600 600,900 900,1230
{you,know} run in kernel mode.|
|

1831
00:56:43,350 --> 00:56:45,000
0,630 750,900 900,1350 1380,1530 1530,1650
{} And then you know
然后有 user 部分，这些就是运行在用户模式的程序。

1832
00:56:45,000 --> 00:56:46,470
0,270 270,750 750,900 900,1080 1080,1470
there's user and those are

1833
00:56:46,500 --> 00:56:47,670
0,420 420,510 510,900 900,1020 1020,1170
basically the programs that run

1834
00:56:47,670 --> 00:56:48,810
0,60 60,330 330,720 750,990 990,1140
the user mode.| And this
|这也是为什么一个叫做 kernel ，另一个叫做 user 。

1835
00:56:48,810 --> 00:56:49,710
0,90 90,390 390,540 540,690 690,900
is why, you know one

1836
00:56:49,710 --> 00:56:50,400
0,60 60,270 270,540 540,630 630,690
is called kernel and the

1837
00:56:50,400 --> 00:56:51,880
0,150 150,390 390,630 630,960
other called {} user.|
|

1838
00:56:52,080 --> 00:56:53,070
0,120 120,270 270,390 390,630 630,990
And then there's one more
然后，还有一个程序叫做 mkfs ，

1839
00:56:53,070 --> 00:56:54,300
0,390 390,540 540,720 720,840 840,1230
program called {mkfs - -},|
|

1840
00:56:54,810 --> 00:56:56,790
0,300 300,480 480,750 750,1200 1560,1980
{} which actually builds {}
它会构建一个空文件系统镜像，保存在磁盘上，

1841
00:56:56,790 --> 00:56:58,230
0,60 60,390 390,630 630,900 900,1440
an empty file system image,

1842
00:56:58,350 --> 00:56:59,700
0,270 270,480 480,960 960,1050 1050,1350
{you,know} that we are stored

1843
00:56:59,700 --> 00:57:01,110
0,120 120,540 900,1140 1140,1290 1290,1410
on disk,| {} so that
|让我们可以从一个空文件系统开始。

1844
00:57:01,110 --> 00:57:02,070
0,60 60,180 180,540 660,870 870,960
we can get off the

1845
00:57:02,070 --> 00:57:03,990
0,480 480,840 840,1200 1200,1680 1680,1920
ground with an empty file

1846
00:57:03,990 --> 00:57:04,760
0,360
system.|
|

1847
00:57:09,160 --> 00:57:11,260
0,240 240,690 840,1590 1620,1860 1860,2100
Okay, so before, so {you,know}
好的，在继续之前，再次切换到，

1848
00:57:11,260 --> 00:57:13,060
0,300 300,660 660,1110 1110,1680 1680,1800
switch back again to,| I
|我想说一下内核是如何编译的。

1849
00:57:13,060 --> 00:57:13,600
0,150 150,210 210,270 270,360 360,540
want to say a little

1850
00:57:13,600 --> 00:57:14,620
0,150 150,360 360,510 510,690 720,1020
bit about how the kernel

1851
00:57:14,620 --> 00:57:15,920
0,90 90,780
is compiled.|
|

1852
00:57:16,130 --> 00:57:17,600
0,480 480,720 720,840 840,1200 1200,1470
{ -} You've probably seen
你可能已经看到这个，没有注意它，但理解它是很重要的。

1853
00:57:17,600 --> 00:57:18,650
0,300 300,420 420,600 600,810 810,1050
this, you might not really

1854
00:57:18,650 --> 00:57:20,840
0,180 180,630 630,840 1140,1800 1800,2190
have realized it, {} it's

1855
00:57:20,840 --> 00:57:22,460
0,360 360,420 420,1050
important to understand.|
|

1856
00:57:22,460 --> 00:57:24,650
0,510 690,1230 1260,1470 1470,1530 1530,2190
{} So when the kernel,
所以当 kernel ， kernel 的结构，

1857
00:57:25,300 --> 00:57:26,650
0,150 150,630 630,690 690,750 750,1350
the construction of the kernel,|
|

1858
00:57:26,680 --> 00:57:28,540
0,120 120,390 390,750 750,1230 1290,1860
the {makefile -} basically takes
makefile 选取 C 文件中的一个，比如 proc.c ，

1859
00:57:28,540 --> 00:57:29,980
0,330 330,420 420,600 600,840 840,1440
one of these C files

1860
00:57:29,980 --> 00:57:31,760
0,150 150,450 450,690 690,1140
like {proc.c - -},|
|

1861
00:57:31,950 --> 00:57:33,120
0,120 120,240 240,900 900,990 990,1170
you know invokes you know
调用 GCC 编译器生成文件 proc.S ，

1862
00:57:33,120 --> 00:57:36,030
0,510 690,1470 1470,1650 1650,2220 2220,2910
the GCC, the GCC compiler

1863
00:57:36,150 --> 00:57:38,640
0,690 840,1650 1650,1830 1830,2220 2220,2490
that generates a file called

1864
00:57:38,640 --> 00:57:40,200
0,330 330,510 540,1140
{proc.S - -},|
|

1865
00:57:40,200 --> 00:57:41,700
0,210 210,420 420,540 540,690 690,1500
that goes through the assembler,|
再通过汇编器，|

1866
00:57:44,780 --> 00:57:46,160
0,180 180,420 420,570 570,1050 1050,1380
and this is basically {RISC-V
这个是 RISC-V 汇编代码，

1867
00:57:46,160 --> 00:57:47,760
0,330 330,960
-} assembly,|
|

1868
00:57:49,360 --> 00:57:50,680
0,180 180,330 330,540 540,1170 1170,1320
and then actually produces a
然后产生一个文件 proc.o ，这是汇编程序的二进制版本，

1869
00:57:50,680 --> 00:57:52,930
0,480 480,810 810,1560 1770,1920 1920,2250
file {proc.o -} and basically

1870
00:57:52,930 --> 00:57:53,980
0,240 240,360 360,480 480,600 600,1050
that's you know the binary

1871
00:57:53,980 --> 00:57:56,220
0,480 480,630 630,690 690,1200
version of the assembler,|
|

1872
00:57:57,140 --> 00:57:58,100
0,420 420,540 540,630 630,780 780,960
and you know the {makefile
makefile 对 kernel 中的文件执行这个规则，

1873
00:57:58,100 --> 00:57:59,480
0,180 180,330 330,510 510,1230 1260,1380
-} does this rule, you

1874
00:57:59,480 --> 00:58:00,470
0,120 120,570 570,870 870,930 930,990
know part files in the

1875
00:58:00,470 --> 00:58:02,930
0,480 480,600 600,1230 1230,1800 1890,2460
kernel,| so {for,example} {} pipe,
|比如，另一个， pipe ，也是同样的流程，

1876
00:58:03,380 --> 00:58:05,210
0,330 330,780 1020,1110 1110,1470 1500,1830
another one you know, same

1877
00:58:05,210 --> 00:58:07,640
0,600 600,1380 1380,1830 1830,2160 2160,2430
story,| GCC compiles to {pipe.S
|GCC 将其编译成 pipe.S ，再通过汇编器我们得到 pipe.o 。

1878
00:58:07,640 --> 00:58:08,920
0,300 300,780
- -},

1879
00:58:09,230 --> 00:58:10,370
0,510 510,600 600,750 750,930 930,1140
and you know go to

1880
00:58:10,370 --> 00:58:12,110
0,330 330,1170 1170,1500 1500,1590 1590,1740
through assembler and we get

1881
00:58:12,110 --> 00:58:13,640
0,60 60,330 330,990
a {pipe.o -}.|
|

1882
00:58:14,080 --> 00:58:15,820
0,180 180,600 600,900 900,1050 1050,1740
And basically then the loader,
然后加载器使用所有不同文件生成的 .o 文件，

1883
00:58:17,010 --> 00:58:18,240
0,210 210,420 420,660 660,810 810,1230
it takes all these .o

1884
00:58:18,240 --> 00:58:19,320
0,570
files,

1885
00:58:19,460 --> 00:58:21,320
0,270 270,510 510,600 600,1110 1290,1860
from all the different files|
|

1886
00:58:21,320 --> 00:58:23,270
0,360 540,900 900,990 990,1620 1800,1950
and links them together and
将它们链接在一起，生成 kernel 。

1887
00:58:23,270 --> 00:58:25,900
0,720 900,1590 1590,1680 1680,2100
produces produces a kernel,|
|

1888
00:58:28,480 --> 00:58:29,230
0,150 150,270 270,390 390,660 660,750
and that was actually you
就是我们要运行的东西。

1889
00:58:29,230 --> 00:58:30,660
0,150 150,330 330,420 420,810
know what we run.|
|

1890
00:58:30,880 --> 00:58:32,200
0,600 780,900 900,1020 1020,1200 1200,1320
And you know for your
为了方便， makefile 也生成一个文件 kernel.asm ，

1891
00:58:32,200 --> 00:58:33,310
0,660 660,750 750,840 840,930 930,1110
convenience, you know the {makefile

1892
00:58:33,310 --> 00:58:34,660
0,330 330,600 600,990 990,1080 1080,1350
-} also produces a file

1893
00:58:34,660 --> 00:58:36,620
0,240 240,570 570,810 810,1410
called {kernel.asm - -},|
|

1894
00:58:39,110 --> 00:58:42,020
0,270 270,870 900,1560 1590,2190 2190,2910
that has the complete kernel
它包含所有 kernel 反汇编代码，

1895
00:58:42,350 --> 00:58:45,080
0,870 900,1890 1920,2490 2490,2640 2640,2730
{} disassembled| and you can
|你可以查看它，在有内核 bug 的时候提供帮助，

1896
00:58:45,080 --> 00:58:46,220
0,150 150,330 330,420 420,720 720,1140
just look at it and

1897
00:58:46,220 --> 00:58:47,300
0,60 60,180 180,390 390,750 750,1080
you know that helps later

1898
00:58:47,300 --> 00:58:48,290
0,270 270,510 510,600 600,690 690,990
on when you have kernel

1899
00:58:48,290 --> 00:58:49,040
0,270 270,360 360,480 480,690 690,750
bugs| and it's easy to
|可以很容易看到 bug 发生时的指令。

1900
00:58:49,040 --> 00:58:51,740
0,240 240,510 510,1140 1500,2190 2190,2700
see which instruction was executed

1901
00:58:51,740 --> 00:58:52,400
0,60 60,150 150,420 420,510 510,660
to the point you got

1902
00:58:52,400 --> 00:58:53,760
0,360 420,930
the bug.|
|

1903
00:58:53,820 --> 00:58:55,020
0,210 210,300 300,750 750,900 900,1200
As an example if I,
比如，这是 kernel.asm ，我们可以看到这是内核汇编指令。

1904
00:58:57,060 --> 00:58:59,400
0,120 120,810 840,1230 1230,1500 1530,2340
{} here {kernel.asm - -},

1905
00:59:00,000 --> 00:59:02,100
0,390 390,540 540,1020 1020,1470 1470,2100
{} we see here's the

1906
00:59:02,340 --> 00:59:04,110
0,360 360,990 1020,1560 1560,1680 1680,1770
kernel file {} {assembly -

1907
00:59:04,110 --> 00:59:05,640
0,210 210,1020
-} instructions.|
|

1908
00:59:05,640 --> 00:59:07,650
0,1140 1230,1500 1500,1650 1650,1740 1740,2010
And one thing you know,
你需要知道一件事情，第一条指令位于地址 80000000 ，

1909
00:59:07,650 --> 00:59:08,550
0,240 240,600 600,690 690,810 810,900
for example is that the

1910
00:59:08,550 --> 00:59:11,010
0,480 930,1170 1170,1830 1830,1980 1980,2460
first {} instruction is located

1911
00:59:11,010 --> 00:59:12,240
0,150 150,330 330,750 750,990 990,1230
at this address eight zero

1912
00:59:12,240 --> 00:59:14,430
0,240 240,510 510,720 720,1380 1680,2190
zero zero zero zero {}|
|

1913
00:59:14,430 --> 00:59:15,990
0,420 420,570 570,750 750,1320 1350,1560
and that is whatever {auipc
它是 auipc 指令， RISC-V 指令。

1914
00:59:15,990 --> 00:59:17,550
0,150 150,540 540,1050 1050,1290 1290,1560
- -} instruction {RISC-V -}

1915
00:59:17,550 --> 00:59:18,520
0,480
instruction.|
|

1916
00:59:20,710 --> 00:59:22,060
0,750
And,
有人知道这些是什么吗，

1917
00:59:22,550 --> 00:59:23,870
0,420 420,630 630,750 750,900 900,1320
anybody knows what this is,|
|

1918
00:59:23,960 --> 00:59:25,280
0,390 390,720 720,900 900,1110 1110,1320
zero zero eight one one
0000a117, 83010113, 6505 。

1919
00:59:25,280 --> 00:59:26,510
0,330 330,540 540,750 750,900 900,1230
seven, or eight three one

1920
00:59:26,510 --> 00:59:27,980
0,300 300,540 540,810 810,930 930,1470
three, six five o five.|
|

1921
00:59:34,730 --> 00:59:35,720
0,420 420,540 540,690 690,870 870,990
Anyone want to answer that
有人想回答这个问题吗？

1922
00:59:35,720 --> 00:59:36,880
0,570
question?|
|

1923
00:59:36,880 --> 00:59:38,830
0,360 360,1050 1110,1530 1530,1890 1890,1950
That's the hex version of
那是右边汇编指令的十六进制版本？

1924
00:59:38,830 --> 00:59:40,060
0,90 90,570 570,1080 1080,1140 1140,1230
the assembly instructions on the

1925
00:59:40,060 --> 00:59:41,040
0,330
right?|
|

1926
00:59:41,040 --> 00:59:42,690
0,420 420,810 810,1050 1200,1380 1380,1650
Yeah exactly,| so what here
是的，完全正确，|所以 0000a117 是与文本的 auipc 相同的东西，

1927
00:59:42,690 --> 00:59:44,010
0,180 180,570 570,810 810,1200 1200,1320
on the zero zero eight

1928
00:59:44,010 --> 00:59:45,210
0,180 180,360 360,660 660,780 780,1200
one one seven is exactly

1929
00:59:45,210 --> 00:59:47,520
0,90 90,360 360,750 750,1440 1590,2310
the same thing as symbolic

1930
00:59:47,520 --> 00:59:48,600
0,150 150,240 240,360 360,750 750,1080
you know the textual version

1931
00:59:48,600 --> 00:59:49,580
0,120 120,420
of that

1932
00:59:49,580 --> 00:59:50,810
0,210 210,360 360,900 960,1110 1110,1230
{auipc - -}| and so
|所以这是实际指令的二进制编码。

1933
00:59:50,810 --> 00:59:52,490
0,360 360,540 540,660 660,990 1020,1680
basically this is the binary

1934
00:59:52,490 --> 00:59:54,710
0,720 900,1170 1170,1290 1290,1620 1620,2220
encoding of the actual instruction.|
|

1935
00:59:56,150 --> 00:59:57,440
0,300 300,480 480,750 750,1140 1140,1290
So, and every instruction has
所以，每个指令都有二进制编码，

1936
00:59:57,440 --> 00:59:59,180
0,60 60,390 390,1020 1260,1650 1650,1740
a binary encoding| and you
|kernel.asm 文件显示了这些二进制编码。

1937
00:59:59,180 --> 01:00:00,050
0,120 120,300 300,630 630,720 720,870
know the {kernel.asm - -

1938
01:00:00,050 --> 01:00:01,340
0,210 210,510 510,720 720,1050 1050,1290
-} file actually shows those

1939
01:00:01,340 --> 01:00:02,840
0,330 330,1020
binary encodings.|
|

1940
01:00:03,600 --> 01:00:04,650
0,150 150,240 240,300 300,600 600,1050
And this is sometimes convenient,|
这有时是很方便的，|

1941
01:00:04,650 --> 01:00:05,850
0,150 150,210 210,390 390,540 540,1200
when you look at GDB,
当你查看 GDB ，想知道实际发生了什么，

1942
01:00:05,850 --> 01:00:06,510
0,210 210,300 300,450 450,510 510,660
and you want to know

1943
01:00:06,510 --> 01:00:07,830
0,180 180,450 450,510 510,750 750,1320
what actually is going on,|
|

1944
01:00:07,830 --> 01:00:08,580
0,120 120,210 210,360 360,660 660,750
you can see actually the
你就可以看到二进制编码。

1945
01:00:08,580 --> 01:00:10,060
0,330 330,720 720,1020
binary encoding is.|
|

1946
01:00:12,060 --> 01:00:13,240
0,690
Okay.|
好的。|

1947
01:00:13,610 --> 01:00:15,110
0,240 240,360 360,810 870,1230 1230,1500
Okay, so then when we
好的，当我们运行 xv6 ，我要运行，

1948
01:00:15,110 --> 01:00:16,910
0,630 840,1170 1170,1560 1560,1680 1680,1800
run {xv6 -}, I'm going

1949
01:00:16,910 --> 01:00:17,960
0,60 60,210 210,690 690,900 900,1050
to run inside,| actually let
|让我先在没有 GDB 的情况下运行。

1950
01:00:17,960 --> 01:00:19,490
0,90 90,300 300,510 510,780 900,1530
me first run it without

1951
01:00:19,490 --> 01:00:20,620
0,570
GDB.|
|

1952
01:00:20,650 --> 01:00:21,940
0,570 570,660 660,930 930,1260 1260,1290
{} You know compile a
你知道编译很多东西，然后调用 QEMU 。

1953
01:00:21,940 --> 01:00:22,990
0,210 210,270 270,630 630,750 750,1050
bunch of stuff and then

1954
01:00:22,990 --> 01:00:25,820
0,810 1020,1620 1650,2280
invokes {} QEMU,|
|

1955
01:00:25,910 --> 01:00:27,050
0,360 360,510 510,630 630,780 780,1140
and this is a basically
这是一个 C 程序，用来模拟 RISC-V 处理器。

1956
01:00:27,050 --> 01:00:29,810
0,300 300,930 1260,1560 1560,2040 2040,2760
C program, {} that simulates

1957
01:00:29,810 --> 01:00:31,550
0,180 180,660 660,930 930,1170 1170,1740
or emulates {RISC-V -} processor.|
|

1958
01:00:32,180 --> 01:00:33,080
0,210 210,300 300,510 510,810 810,900
You can see here in
你可以在这里看到 -kernel 标志，传递了内核，

1959
01:00:33,080 --> 01:00:34,670
0,90 90,300 300,660 660,1140 1170,1590
the dash kernel flag, actually

1960
01:00:34,670 --> 01:00:36,380
0,360 360,480 480,1170
passes the kernel,|
|

1961
01:00:36,380 --> 01:00:38,810
0,390 390,570 570,900 900,1980 2010,2430
{} and as a program
作为一个可以在 QEMU 中运行的程序，

1962
01:00:38,810 --> 01:00:40,130
0,150 150,240 240,750 780,1230 1230,1320
can be run inside of

1963
01:00:40,130 --> 01:00:43,010
0,690 1050,1620 1620,1920 1920,2280 2280,2880
QEMU| and {QEMU -} and
|QEMU 和 内核约定任何程序的起始点是地址 80000000 。

1964
01:00:43,010 --> 01:00:45,110
0,120 120,420 420,990 990,1470 1470,2100
the kernel agreed basically the

1965
01:00:45,140 --> 01:00:46,910
0,480 480,810 810,930 930,1110 1110,1770
starting place for any program

1966
01:00:47,000 --> 01:00:48,170
0,180 180,360 360,810 810,930 930,1170
is to address eight zero

1967
01:00:48,170 --> 01:00:49,560
0,240 240,510 510,930
zero zero zero.|
|

1968
01:00:50,120 --> 01:00:50,810
0,120 120,210 210,420 420,600 600,690
And we see that we
我们可以看到我们传递了很多标志给 QEMU ，

1969
01:00:50,810 --> 01:00:51,770
0,240 240,270 270,510 510,630 630,960
passed a couple of flags

1970
01:00:51,770 --> 01:00:52,730
0,60 60,450 450,570 570,870 870,960
in QEMU,| it's just you
|m ，是虚拟机拥有的内存量，这个 RISC-V 机器，

1971
01:00:52,730 --> 01:00:54,260
0,120 120,450 450,750 750,900 1260,1530
know, m, that's an amount

1972
01:00:54,260 --> 01:00:56,240
0,60 60,600 630,930 930,1410 1440,1980
of memory that the machine

1973
01:00:56,240 --> 01:00:58,070
0,180 180,510 510,840 840,1290 1590,1830
this virtual machine has, this

1974
01:00:58,070 --> 01:01:00,140
0,330 330,540 540,780 780,1260 1530,2070
virtual {RISC-V -} machine {},|
|

1975
01:01:00,140 --> 01:01:01,190
0,180 180,540 540,750 750,870 870,1050
it passes in how many
传递多少个 CPU 核，传递给这个机器，

1976
01:01:01,190 --> 01:01:03,170
0,90 90,420 420,570 570,1050 1350,1980
of cores there are a

1977
01:01:03,230 --> 01:01:05,240
0,420 420,690 690,990 1080,1890 1890,2010
passes in the machine,| the
|磁盘包含文件 fs.img 。

1978
01:01:05,240 --> 01:01:06,920
0,270 270,780 870,1110 1110,1320 1320,1680
disk drive {} which contains

1979
01:01:06,920 --> 01:01:08,510
0,180 180,600 630,930 930,1110 1110,1590
the file {fs.img - -}.|
|

1980
01:01:08,880 --> 01:01:09,630
0,90 90,210 210,540 540,570 570,750
And so basically a bunch
所以设置了很多东西让 QEMU 像一台真正的计算机。

1981
01:01:09,630 --> 01:01:10,710
0,60 60,360 360,660 660,900 900,1080
of things are set up

1982
01:01:10,710 --> 01:01:11,820
0,90 90,450 450,660 660,840 840,1110
to make {} {QEMU -}

1983
01:01:11,820 --> 01:01:12,930
0,300 300,480 480,540 540,690 690,1110
behaves like a real computer.|
|

1984
01:01:14,620 --> 01:01:16,090
0,120 120,210 210,480 480,990 1200,1470
And so one way when
所以你考虑 QEMU 的一种方式是，

1985
01:01:16,090 --> 01:01:17,200
0,120 120,270 270,450 450,720 720,1110
you think about {QEMU -},|
|

1986
01:01:17,320 --> 01:01:18,760
0,300 300,420 420,750 750,1140 1140,1440
really you should not think
不要把它想成是一个 C 程序，

1987
01:01:18,760 --> 01:01:20,110
0,210 210,300 300,480 480,810 990,1350
about it as a C

1988
01:01:20,110 --> 01:01:21,160
0,480 480,720 720,810 810,930 930,1050
program,| really the way you
|而是想成像下面这样，

1989
01:01:21,160 --> 01:01:22,750
0,120 120,300 300,570 570,780 1050,1590
should think about it is

1990
01:01:22,750 --> 01:01:24,060
0,150 150,840
as follows,|
|

1991
01:01:24,640 --> 01:01:26,290
0,690 870,1080 1080,1200 1200,1350 1350,1650
{} you should think about
把它想成这个，一块真正的电路板。

1992
01:01:26,290 --> 01:01:27,720
0,150 150,900
it as

1993
01:01:27,720 --> 01:01:28,940
0,660
{}

1994
01:01:30,890 --> 01:01:32,280
0,330 330,780
as this,

1995
01:01:32,460 --> 01:01:35,520
0,810 810,1050 1050,1590 1740,2490
namely, a real board.|
|

1996
01:01:35,680 --> 01:01:36,670
0,270 270,420 420,480 480,810 810,990
{} So, for example there
比如，左边这个是一块 RISC-V 电路板，

1997
01:01:36,670 --> 01:01:37,420
0,90 90,180 180,570 570,660 660,750
on the left you know

1998
01:01:37,420 --> 01:01:38,890
0,210 210,360 360,720 900,1170 1170,1470
this is a {RISC-V -}

1999
01:01:38,890 --> 01:01:40,660
0,450 690,1170 1170,1500 1500,1560 1560,1770
board,| {} actually the {RISC-V
|实际上，这块 RISC-V 电路板在我的办公室里，

2000
01:01:40,660 --> 01:01:41,380
0,210 210,390 390,480 480,660 660,720
-} board that sits in

2001
01:01:41,380 --> 01:01:43,660
0,120 120,690 1110,1830 1830,2160 2160,2280
my office| and it can
|它可以启动 xv6 。

2002
01:01:43,660 --> 01:01:44,950
0,480 510,720 720,960 960,1020 1020,1290
boot {} more or less

2003
01:01:44,950 --> 01:01:46,140
0,120 120,240 240,780
{xv6 - -}.|
|

2004
01:01:46,310 --> 01:01:47,780
0,300 300,420 420,600 600,870 870,1470
And so when you're running
所以当你在 QEMU 上运行你的内核，

2005
01:01:47,780 --> 01:01:49,580
0,120 120,210 210,1050 1260,1560 1560,1800
you know QEMU {} with

2006
01:01:49,580 --> 01:01:50,540
0,180 180,600 600,720 720,810 810,960
your kernel,| you should think
|你应该想成是运行在这块板上。

2007
01:01:50,540 --> 01:01:51,770
0,270 270,360 360,570 570,870 870,1230
about it that actually running

2008
01:01:51,770 --> 01:01:53,300
0,120 120,330 330,510 510,1020
it on this board.|
|

2009
01:01:53,360 --> 01:01:54,410
0,270 270,330 330,570 570,690 690,1050
And you know the board
这块板有开关按钮，

2010
01:01:54,410 --> 01:01:56,270
0,510 510,660 660,990 990,1200 1200,1860
has been on off button,|
|

2011
01:01:56,420 --> 01:01:58,490
0,630 720,1080 1080,1380 1380,1680 1740,2070
{} here's actually to {RISC-V
这里是 RISC-V 处理器，

2012
01:01:58,490 --> 01:02:01,130
0,480 510,1470 1860,2400 2400,2520 2520,2640
-} processor,| {} you know
|这里有外设空间，比如其中之一是以太网接口。

2013
01:02:01,130 --> 01:02:03,620
0,360 360,810 810,1020 1020,1890 2190,2490
there's room for peripherals, for

2014
01:02:03,620 --> 01:02:05,360
0,300 300,480 480,540 540,1020 1230,1740
example one of these connectors

2015
01:02:05,360 --> 01:02:06,920
0,120 120,180 180,570 570,900 930,1560
is a connector for Ethernet,|
|

2016
01:02:07,480 --> 01:02:09,520
0,660 660,1140 1140,1260 1260,1470 1470,2040
{} one is that {PCIe
一个是 PCIe 插槽，

2017
01:02:09,520 --> 01:02:11,470
0,390 390,1020 1020,1380 1380,1620 1620,1950
-} slots,| {} there's some
|板上有 RAM 芯片，我不知道在哪里，但确实有。

2018
01:02:11,470 --> 01:02:13,930
0,300 300,690 690,1020 1020,1650 1890,2460
RAM chips on the board,

2019
01:02:13,930 --> 01:02:14,860
0,30 30,210 210,570 570,690 690,930
I don't exactly know where

2020
01:02:14,860 --> 01:02:15,910
0,90 90,390 390,540 540,690 690,1050
they are, but there are.|
|

2021
01:02:16,480 --> 01:02:17,890
0,510 750,1020 1020,1140 1140,1290 1290,1410
{} And so this is
所以这是你编程的计算机硬件资源，

2022
01:02:17,890 --> 01:02:19,300
0,180 180,270 270,930 960,1320 1320,1410
sort of, {} that's the

2023
01:02:19,300 --> 01:02:21,250
0,570 570,960 960,1020 1020,1560 1560,1950
physical hardware, the computer actually

2024
01:02:21,250 --> 01:02:23,140
0,540 540,780 780,1290 1320,1560 1560,1890
actually you're programming,| so {xv6
|所以 xv6 管理这块板，这是你脑海中通常会有的图像。

2025
01:02:23,140 --> 01:02:25,340
0,420 450,1050 1050,1230 1230,1680
-} managers this board,

2026
01:02:25,610 --> 01:02:27,110
0,480 480,630 630,900 900,1200 1200,1500
{} and that's the picture

2027
01:02:27,110 --> 01:02:28,190
0,300 300,480 480,540 540,720 720,1080
usually have in your head.|
|

2028
01:02:29,010 --> 01:02:30,240
0,420 480,690 690,900 900,990 990,1230
And in fact if you
实际上，如果你放大，你可以找到内部的所有文档。

2029
01:02:30,240 --> 01:02:31,700
0,510 510,960
zoom in,

2030
01:02:31,700 --> 01:02:32,450
0,210 210,330 330,540 540,690 690,750
you can find all the

2031
01:02:32,450 --> 01:02:34,250
0,720 720,840 840,1200 1200,1440 1440,1800
documentation of what actually sits

2032
01:02:34,250 --> 01:02:35,760
0,480 480,570 570,1020
inside of this.|
|

2033
01:02:35,790 --> 01:02:37,620
0,630 630,1020 1020,1410 1410,1500 1500,1830
{} And inside of this,
这个内部， RISC-V 处理器内部，

2034
01:02:37,620 --> 01:02:39,060
0,120 120,840 840,990 990,1350 1350,1440
you know the inside of

2035
01:02:39,060 --> 01:02:41,490
0,180 180,510 510,1050 1260,1950 2100,2430
this {RISC-V -} processor,| the
|RISC-V 处理器结构显示在这张图片上。

2036
01:02:41,550 --> 01:02:42,960
0,690 690,870 870,960 960,1140 1140,1410
schema for the {RISC-V -}

2037
01:02:42,960 --> 01:02:44,460
0,480 480,1020 1020,1290 1290,1350 1350,1500
processor is shown in this

2038
01:02:44,460 --> 01:02:45,580
0,270 270,630
picture here.|
|

2039
01:02:45,730 --> 01:02:47,170
0,600 600,990 990,1110 1110,1260 1260,1440
{} And you know see
这里可以看到有多个内核，实际上是四核，

2040
01:02:47,170 --> 01:02:48,160
0,210 210,270 270,750 750,870 870,990
here for example there are

2041
01:02:48,190 --> 01:02:49,740
0,420 420,1050
multiple cores,

2042
01:02:49,740 --> 01:02:51,600
0,150 150,390 390,780 780,1350
in fact, four cores,|
|

2043
01:02:51,600 --> 01:02:53,430
0,690 690,810 810,960 960,1350 1350,1830
{} you know there's a
有一个 l2 缓存，

2044
01:02:53,580 --> 01:02:55,680
0,510 510,1230 1470,1800 1800,2040 2040,2100
l2 cache,| {} there's a
|有一个到 DRAM 的接口，

2045
01:02:55,680 --> 01:02:58,170
0,450 450,540 540,870 870,1350 1710,2490
connector to {DRAM -} {},|
|

2046
01:02:58,200 --> 01:02:59,310
0,120 120,300 300,840 840,900 900,1110
you know there's a bunch
有多种方式可以连接到外部世界，

2047
01:02:59,310 --> 01:03:00,120
0,90 90,360 360,450 450,690 690,810
of ways to connect to

2048
01:03:00,120 --> 01:03:01,470
0,120 120,450 450,900 900,1050 1050,1350
the outside world,| so {for,example}
|比如，这个是 UART0 ，

2049
01:03:01,470 --> 01:03:03,390
0,270 270,630 630,1200 1500,1650 1650,1920
here {UART0 -}| and {UART0
|UART0 连接着，一端是键盘，另一端是显示器。

2050
01:03:03,390 --> 01:03:05,070
0,360 360,480 480,780 780,1320 1440,1680
-} is actually connected on

2051
01:03:05,070 --> 01:03:06,990
0,270 270,660 930,1200 1200,1290 1290,1920
one end to the keyboard

2052
01:03:07,020 --> 01:03:07,860
0,210 210,300 300,420 420,630 630,840
and to the other end

2053
01:03:07,860 --> 01:03:09,240
0,120 120,210 210,930
to the display.|
|

2054
01:03:09,300 --> 01:03:10,740
0,690 780,1050 1050,1170 1170,1320 1320,1440
{} And you know there
这里有让时钟运行的方法，

2055
01:03:10,740 --> 01:03:11,850
0,30 30,150 150,450 450,570 570,1110
are some ways to actually

2056
01:03:11,850 --> 01:03:15,390
0,510 870,1500 1530,2610 2850,3330 3330,3540
{} clock's going,| I'll talk
|后面我会讲到更多细节，

2057
01:03:15,390 --> 01:03:16,440
0,240 240,360 360,570 570,690 690,1050
about in much more detail

2058
01:03:16,440 --> 01:03:17,970
0,540 630,1080 1080,1290 1290,1410 1410,1530
later,| but these are all
|但是这些是 xv6 或你要修改的东西与真实硬件交互的组件。

2059
01:03:17,970 --> 01:03:19,380
0,90 90,720 720,870 870,1350 1350,1410
the components that basically you

2060
01:03:19,380 --> 01:03:20,970
0,180 180,510 510,810 810,1230 1230,1590
know the {xv6 -} or

2061
01:03:21,000 --> 01:03:21,690
0,300 300,390 390,480 480,570 570,690
things that you will be

2062
01:03:21,690 --> 01:03:23,550
0,690 750,960 960,1410 1410,1650 1770,1860
modifying to interact with the

2063
01:03:23,550 --> 01:03:24,660
0,210 210,450 450,660
real {hardware -}.|
|

2064
01:03:24,910 --> 01:03:26,560
0,330 330,450 450,750 750,1050
And in fact the
事实上，计算机系统或计算机板与 QEMU 模拟的非常相似，

2065
01:03:26,900 --> 01:03:28,220
0,360 360,750 750,870 870,960 960,1320
computer system or the computer

2066
01:03:28,220 --> 01:03:30,290
0,360 360,510 510,960 960,1230 1410,2070
board that actually is emulated

2067
01:03:30,290 --> 01:03:32,390
0,480 510,750 750,1260 1440,1830 1830,2100
by {QEMU -} is pretty

2068
01:03:32,390 --> 01:03:34,310
0,660 660,750 750,1020 1350,1770 1770,1920
close,| you know minus some
|除了 SiFive 制造的电路板的上的一些小细节。

2069
01:03:34,310 --> 01:03:36,380
0,300 300,870 870,1020 1020,1230 1230,2070
small details to this particular

2070
01:03:36,380 --> 01:03:37,580
0,360 360,720 750,900 900,990 990,1200
computer board which is made

2071
01:03:37,580 --> 01:03:38,940
0,180 180,870
by SiFive.|
|

2072
01:03:39,450 --> 01:03:41,520
0,420 1020,1590 1590,1650 1650,1890 1890,2070
And unfortunately I can't tell
遗憾的是，我不能坐在办公室里展示真实的东西，

2073
01:03:41,520 --> 01:03:42,750
0,60 60,210 210,420 420,810 810,1230
you the real thing I

2074
01:03:42,750 --> 01:03:44,070
0,330 330,570 570,630 630,750 750,1320
just sit in my office,|
|

2075
01:03:44,070 --> 01:03:44,970
0,150 150,480 510,660 660,750 750,900
you know and I haven't
自从三月，我就没有去过我的办公室了，可能积了很多灰尘，

2076
01:03:44,970 --> 01:03:45,750
0,180 180,240 240,360 360,630 630,780
been in my office since

2077
01:03:45,750 --> 01:03:47,370
0,540 780,1080 1080,1410 1410,1470 1470,1620
March, probably collecting a lot

2078
01:03:47,370 --> 01:03:49,860
0,90 90,540 1230,1740 1890,2100 2100,2490
of dust,| but it's important
|但是记住这点很重要，当你运行 QEMU ，你就像运行在真正的硬件上。

2079
01:03:49,860 --> 01:03:50,790
0,60 60,240 240,300 300,420 420,930
to keep in your head

2080
01:03:50,790 --> 01:03:52,380
0,240 240,360 360,600 600,1230 1380,1590
when you're running QEMU, you're

2081
01:03:52,380 --> 01:03:54,390
0,540 570,1200 1200,1380 1380,1530 1530,2010
running basically on real hardware.|
|

2082
01:03:55,000 --> 01:03:55,900
0,240 240,420 420,720 720,780 780,900
And just happens to be
只是能够使用软件。

2083
01:03:55,900 --> 01:03:57,360
0,180 180,450 450,930
able to software.|
|

2084
01:04:02,620 --> 01:04:03,940
0,120 120,240 240,390 390,810
Does that make sense,
能理解吗，这里的[]。

2085
01:04:04,810 --> 01:04:06,440
0,420 420,660 660,1080
[] {sit,in} here.|
|

2086
01:04:11,560 --> 01:04:12,550
0,180 180,570 570,660 660,840 840,990
So let me say a
让我来多讲一点，

2087
01:04:12,550 --> 01:04:13,540
0,180 180,330 330,540 540,810 810,990
little bit more about it,|
|

2088
01:04:13,570 --> 01:04:14,440
0,180 180,330 330,480 480,570 570,870
so what does it mean
QEMU 模拟 RISC-V 处理器是什么意思。

2089
01:04:14,440 --> 01:04:16,900
0,120 120,450 450,1020 1020,1890
for {QEMU -} emulate

2090
01:04:20,420 --> 01:04:22,340
0,180 180,420 420,720 720,1260
the {RISC-V -} processor.|
|

2091
01:04:24,940 --> 01:04:26,320
0,480 510,1110 1110,1200 1200,1290 1290,1380
Well, literally you know if
如果你考虑它，像我说的， QEMU 是一个开源的 C 程序，

2092
01:04:26,320 --> 01:04:27,520
0,120 120,270 270,540 540,960 1080,1200
you think about it, you

2093
01:04:27,520 --> 01:04:28,870
0,270 420,570 570,660 660,1140 1140,1350
know as I said {you,know}

2094
01:04:28,870 --> 01:04:30,190
0,600 600,780 780,1110 1110,1230 1230,1320
QEMU C program it's an

2095
01:04:30,190 --> 01:04:31,510
0,240 240,630 660,900 900,1230 1230,1320
open source C program,| it's
|它是一个很大的程序，你可以下载或 clone 它。

2096
01:04:31,510 --> 01:04:32,530
0,30 30,330 330,840 840,900 900,1020
a big program, you can

2097
01:04:32,530 --> 01:04:34,480
0,180 180,450 900,1500 1500,1710 1710,1950
actually just download it or

2098
01:04:34,600 --> 01:04:36,020
0,300 300,570 570,810
get clone it.|
|

2099
01:04:36,020 --> 01:04:37,730
0,120 120,300 300,1080 1080,1410 1410,1710
{} But internally into C
但是 C 代码内部是一个 for 循环，一个无限 for 循环，

2100
01:04:37,730 --> 01:04:39,440
0,0 0,570 570,960 960,1290 1290,1710
{} is basically for loop,

2101
01:04:39,940 --> 01:04:41,580
0,150 150,360 360,690 690,1050
an infinite for loop,|
|

2102
01:04:42,220 --> 01:04:43,360
0,150 150,450 450,630 630,870 870,1140
that basically does nothing else
它只是读指令， RISC-V 指令，读取 4 或 8 个字节，

2103
01:04:43,360 --> 01:04:45,180
0,300 330,1230
than {read,instruction},

2104
01:04:48,730 --> 01:04:50,860
0,390 390,630 630,1140 1170,1680 1680,2130
{RISC-V -} instruction basically reads

2105
01:04:51,700 --> 01:04:53,140
0,330 330,660 660,810 810,960 960,1440
four byte or eight bytes,|
|

2106
01:04:53,530 --> 01:04:55,870
0,330 330,1200 1320,1920 1920,2190 2190,2340
{} and basically looks at
检查指令的比特位并对其进行解码，弄清操作码是什么。

2107
01:04:55,870 --> 01:04:57,400
0,270 270,690 690,840 840,990 990,1530
the bits in that instruction

2108
01:04:57,400 --> 01:04:58,820
0,180 180,630 630,870
and decodes them,

2109
01:04:58,850 --> 01:05:00,230
0,450 450,600 600,780 780,930 930,1380
figures out what the opcode

2110
01:05:00,230 --> 01:05:01,060
0,240
is.|
|

2111
01:05:03,620 --> 01:05:04,700
0,240 240,390 390,690 690,960 960,1080
And we saw that for
我们看到了一些指令，在 .asm 文件中的指令的二进制版本，

2112
01:05:04,700 --> 01:05:05,630
0,150 150,240 240,330 330,840 840,930
some of the instructions, the

2113
01:05:05,630 --> 01:05:07,220
0,450 450,810 810,930 930,1110 1110,1590
binary version of those instructions

2114
01:05:07,220 --> 01:05:08,840
0,120 120,300 300,900 900,1200 1200,1620
in the {.asm -} file,|
|

2115
01:05:09,260 --> 01:05:10,700
0,270 270,660 660,750 750,1320 1320,1440
so decodes the instruction, so
解码指令，比如这是一条 add 指令， sub 指令，

2116
01:05:10,700 --> 01:05:11,660
0,60 60,420 420,720 720,840 840,960
for example, maybe it will

2117
01:05:11,660 --> 01:05:12,560
0,360 360,480 480,600 600,690 690,900
decide this is an add

2118
01:05:12,560 --> 01:05:13,640
0,570
instruction,

2119
01:05:14,240 --> 01:05:16,280
0,270 270,840 1020,1650 1650,1860 1860,2040
sub instruction, {RISC-V -} sub

2120
01:05:16,280 --> 01:05:17,810
0,450 450,540 540,660 660,1200 1350,1530
instruction,| and then basically it
|然后它在软件中执行指令。

2121
01:05:17,810 --> 01:05:19,460
0,450 450,600 600,1080
executes the instruction

2122
01:05:21,850 --> 01:05:23,220
0,30 90,270 270,780
{in -} software.|
|

2123
01:05:25,240 --> 01:05:26,650
0,570 570,750 750,870 870,1050 1050,1410
And you know that basically
这就是它所做的，在每个核心上运行这个循环。

2124
01:05:26,650 --> 01:05:27,520
0,90 90,240 240,390 390,450 450,870
is all what it does,

2125
01:05:27,610 --> 01:05:28,840
0,180 180,390 390,900 930,1020 1020,1230
for every core, you know

2126
01:05:28,840 --> 01:05:30,860
0,390 390,600 600,1080 1080,1470
runs this particular loop.|
|

2127
01:05:31,010 --> 01:05:32,510
0,390 390,750 750,1050 1080,1170 1170,1500
In addition sort of doing,
除了做这些，这个循环还需要维护一些状态，维护所有寄存器状态。

2128
01:05:32,510 --> 01:05:33,200
0,180 180,390 390,450 450,600 600,690
this loop {} have to

2129
01:05:33,200 --> 01:05:34,910
0,270 270,420 420,870 870,1380 1380,1710
maintain some states maintain state

2130
01:05:34,910 --> 01:05:36,380
0,120 120,210 210,300 300,870
for all the registers.|
|

2131
01:05:37,020 --> 01:05:39,090
0,210 210,330 330,960 990,1290 1290,2070
So it has C decoration
所以它有 C 风格的寄存器， x0 x1 等等。

2132
01:05:39,090 --> 01:05:40,770
0,420 420,660 690,900 900,1320 1320,1680
for like {x0 -} register

2133
01:05:40,770 --> 01:05:43,260
0,480 510,720 720,1230 1380,1980
zero, {x1 -} etc.|
|

2134
01:05:44,280 --> 01:05:45,210
0,210 210,330 330,660 660,810 810,930
And so basically when it
所以当它执行指令时，

2135
01:05:45,210 --> 01:05:47,250
0,390 390,1050 1050,1500 1500,1590 1590,2040
executes instruction| {for,example}, the instruction
|指令比如是 add a0, 1 到 7 ，然后存入 a0 ，

2136
01:05:47,250 --> 01:05:49,800
0,150 150,390 390,930 1230,1830
is like whatever add

2137
01:05:50,000 --> 01:05:52,520
0,120 120,570 720,1020 1020,1890 1920,2520
you know {a0 -} {you,know}

2138
01:05:53,730 --> 01:05:54,930
0,300 300,420 420,780 780,870 870,1200
one to seven and storage

2139
01:05:54,930 --> 01:05:56,430
0,90 90,210 210,810 900,1410 1410,1500
in {a0 -},| basically it
|它获取常数 7 和 1 ，把它们加起来并放入 a0 ，比如存入 7 。

2140
01:05:56,430 --> 01:05:57,780
0,180 180,240 240,630 630,930 930,1350
takes a constant seven one,

2141
01:05:57,780 --> 01:05:58,740
0,150 150,300 300,600 600,690 690,960
add them up and sticks

2142
01:05:58,740 --> 01:06:00,040
0,210 210,300 300,780
into {a0 -},

2143
01:06:00,280 --> 01:06:01,600
0,90 90,480 480,810 810,1080 1080,1320
for example stores seven {in,it}.|
|

2144
01:06:02,190 --> 01:06:03,150
0,120 120,330 330,720 720,780 780,960
And then executes the next
然后执行下一条指令，并继续执行。

2145
01:06:03,150 --> 01:06:04,320
0,510 540,630 630,720 720,900 900,1170
instruction and it keeps going

2146
01:06:04,320 --> 01:06:05,440
0,240 240,510
keeps going.|
|

2147
01:06:05,900 --> 01:06:07,730
0,150 150,510 510,780 780,1260 1260,1830
In addition to basically emulating
除了模拟所有非特权指令，它也模拟所有特权指令。

2148
01:06:07,730 --> 01:06:09,380
0,120 120,540 540,780 780,870 870,1650
or [correctly] all the {}

2149
01:06:09,380 --> 01:06:11,450
0,420 420,1110 1200,1380 1380,1620 1620,2070
unprivileged instructions, it also emulates

2150
01:06:11,450 --> 01:06:13,180
0,120 120,210 210,600 600,1230
all the privileged instructions.|
|

2151
01:06:13,380 --> 01:06:14,700
0,270 270,510 510,600 600,780 780,1320
So that is in essence
这就是 QEMU 实质上所做的，

2152
01:06:14,730 --> 01:06:17,040
0,270 270,540 540,960 960,1470 1680,2310
{} what QEMU does {

2153
01:06:17,040 --> 01:06:18,210
0,360 390,570 570,780 780,1050 1050,1170
-},| the best picture for
|对你来说，脑海中最好的图像是运行在一个真正的 RISC-V 处理器上，

2154
01:06:18,210 --> 01:06:19,110
0,210 210,330 330,480 480,660 660,900
you to have your head

2155
01:06:19,110 --> 01:06:20,100
0,180 180,300 300,600 600,750 750,990
is the basically you're running

2156
01:06:20,100 --> 01:06:21,240
0,120 120,210 210,480 480,930 930,1140
on a real physical {RISC-V

2157
01:06:21,240 --> 01:06:22,580
0,270 270,780
-} processor,|
|

2158
01:06:22,610 --> 01:06:23,420
0,210 210,300 300,510 510,630 630,810
like the ones you have
像你可能已经做过的，你们中许多人在 6.004 课程实现的那个。

2159
01:06:23,420 --> 01:06:24,620
0,420 420,510 510,720 840,1110 1110,1200
probably, you know many of

2160
01:06:24,620 --> 01:06:25,760
0,120 120,600 600,840 840,1020 1020,1140
you implemented [one] after the

2161
01:06:25,760 --> 01:06:27,520
0,870 870,1170
{6.004 -}.|
|

2162
01:06:30,310 --> 01:06:31,960
0,240 240,570 570,750 750,1110
Any questions about this?|
关于这个，有什么问题吗？|

2163
01:06:32,770 --> 01:06:34,180
0,420 450,780 780,1140 1140,1260 1260,1410
Um, hi, yeah I was
是的，我想知道，它有没有采用什么硬件技巧，比如指令重叠或其他的。

2164
01:06:34,180 --> 01:06:36,010
0,510 600,840 840,960 960,1290 1290,1830
wondering, if it does any

2165
01:06:36,040 --> 01:06:38,500
0,570 570,1230 1320,1590 1590,1860 1860,2460
hardware tricks, so like overlapping

2166
01:06:38,500 --> 01:06:40,620
0,720 720,840 840,1650
instructions or anything.|
|

2167
01:06:41,000 --> 01:06:43,370
0,210 210,630 660,1620 1650,2040 2040,2370
Um {no -}, {} it
没有，它运行在一个真正的处理器上，

2168
01:06:43,370 --> 01:06:44,390
0,210 210,330 330,390 390,600 600,1020
runs on a real processor

2169
01:06:44,390 --> 01:06:45,560
0,330 330,450 450,780 780,960 960,1170
below it correct,| when you
|当你运行 QEMU ，它可能运行在 x86 处理器上，

2170
01:06:45,560 --> 01:06:47,000
0,330 330,600 600,1020 1020,1200 1200,1440
run {QEMU -}, it runs

2171
01:06:47,000 --> 01:06:48,770
0,390 390,510 510,600 600,1170 1170,1770
probably on an x86 processor,|
|

2172
01:06:49,340 --> 01:06:50,900
0,180 180,720 720,1170 1170,1440 1440,1560
that x86 processor does all
那个 x86 处理器做了所有技巧，指令流水线或其他的，

2173
01:06:50,900 --> 01:06:52,790
0,180 180,240 240,750 930,1260 1260,1890
kinds of tricks, to pipeline

2174
01:06:52,790 --> 01:06:54,050
0,540 540,630 630,810 810,960 960,1260
instructions and things like that

2175
01:06:54,200 --> 01:06:55,460
0,270 270,630 750,1020 1020,1170 1170,1260
right,| so the way to
|所以应该只是把 QEMU 当成一个 C 程序。

2176
01:06:55,460 --> 01:06:57,620
0,150 150,360 360,1170 1170,1620
think about {QEMU,just,a,C} program.|
|

2177
01:07:00,580 --> 01:07:02,380
0,240 240,570 570,780 780,1170
Makes sense, thank you.|
理解了，谢谢。|

2178
01:07:08,350 --> 01:07:10,060
0,270 270,630 630,960 960,1440 1440,1710
What about multi threading,| so
那么关于多线程呢，|如果 QEMU 支持四核还是只支持一核，

2179
01:07:10,060 --> 01:07:12,160
0,150 150,480 660,1170 1170,1350 1380,2100
if the {} the QEMU

2180
01:07:12,160 --> 01:07:13,930
0,600 600,720 720,990 990,1410 1410,1770
supports you said four cores

2181
01:07:13,930 --> 01:07:14,980
0,150 150,360 360,510 510,750 750,1050
or does it only support

2182
01:07:14,980 --> 01:07:16,780
0,390 690,930 930,1410 1410,1560 1560,1800
one| and it's in that
|在这种情况下，它是否真正支持多线程。

2183
01:07:16,780 --> 01:07:18,070
0,300 300,510 510,630 630,870 870,1290
case, does it have actually

2184
01:07:18,070 --> 01:07:19,960
0,390 390,750 750,1020 1020,1290
multiple threads running it.|
|

2185
01:07:20,020 --> 01:07:21,850
0,390 390,720 720,1320 1320,1440 1440,1830
Yeah, so actually the QEMU
是的，我们在 Athena 上使用的或是你下载的 QEMU ，

2186
01:07:21,850 --> 01:07:23,620
0,150 150,270 270,480 480,840 840,1770
that we use on Athena,

2187
01:07:23,620 --> 01:07:24,400
0,210 210,300 300,510 510,600 600,780
and were probably the ones

2188
01:07:24,400 --> 01:07:26,230
0,90 90,180 180,420 420,1050 1380,1830
that you actually download {},|
|

2189
01:07:26,230 --> 01:07:28,330
0,570 570,930 930,1110 1110,1500 1500,2100
they will use multiple threads
它们内部会使用多线程， QEMU 使用它获得并行能力，

2190
01:07:28,510 --> 01:07:30,250
0,600 600,750 750,1170 1170,1560 1560,1740
internally, so QEMU internally use

2191
01:07:30,250 --> 01:07:31,660
0,150 150,270 270,420 420,1020 1020,1410
it to get parallelism,| so
|实际上，模拟的四核就是并行模拟的。

2192
01:07:31,780 --> 01:07:34,210
0,210 210,690 840,1560 1560,1950 1950,2430
in fact these four cores

2193
01:07:34,210 --> 01:07:35,410
0,150 150,180 180,420 420,1050 1050,1200
that are being emulated are

2194
01:07:35,440 --> 01:07:37,420
0,330 330,870 870,960 960,1560
being emulated in parallel.|
|

2195
01:07:40,040 --> 01:07:40,760
0,210 210,330 330,480 480,660 660,720
And we'll see that in
我们将在后面的实验中看到，这是如何发挥作用的。

2196
01:07:40,760 --> 01:07:41,870
0,150 150,240 240,330 330,630 630,1110
one of the labs later,

2197
01:07:41,990 --> 01:07:43,850
0,600 840,1050 1050,1200 1200,1500 1500,1860
how how that plays out.|
|

2198
01:07:44,530 --> 01:07:45,760
0,180 180,390 390,930 930,1110 1110,1230
{} So definitely there's a
所以，这些核心之间肯定是有真正的并行的。

2199
01:07:45,760 --> 01:07:47,260
0,180 180,690 690,930 930,1170 1260,1500
real parallelism going on between

2200
01:07:47,260 --> 01:07:48,500
0,90 90,330 330,750
the different cores.|
|

2201
01:07:54,090 --> 01:07:55,820
0,570 600,1200
Okay, {}
好的，我会查看 xv6 ，

2202
01:07:55,820 --> 01:07:56,870
0,120 120,240 240,600 630,990 990,1050
so I'm gonna do a

2203
01:07:56,870 --> 01:07:59,870
0,180 180,360 360,510 510,1950 2400,3000
little bit of {} walking

2204
01:07:59,870 --> 01:08:02,420
0,420 420,1410 1620,1950 1950,2280 2280,2550
through { -} {xv6 -}|
|

2205
01:08:02,420 --> 01:08:02,990
0,90 90,210 210,240 240,450 450,570
to get a little bit
来了解一下它的结构是什么样的，

2206
01:08:02,990 --> 01:08:03,890
0,90 90,360 360,480 480,570 570,900
of sense what the layout

2207
01:08:03,890 --> 01:08:05,140
0,90 90,180 180,420 420,780
of the [land] is,|
|

2208
01:08:05,140 --> 01:08:06,850
0,390 390,690 960,1170 1170,1410 1410,1710
{} in in later lecture
在后面的课程中，我们会知道更多细节。

2209
01:08:06,850 --> 01:08:07,510
0,210 210,300 300,450 450,600 600,660
again, we're gonna go in

2210
01:08:07,510 --> 01:08:08,800
0,180 180,300 300,750
much more detail.|
|

2211
01:08:08,830 --> 01:08:09,700
0,300 300,420 420,510 510,630 630,870
{} So I'm going to
所以我启动 QEMU ，并支持 GDB ，

2212
01:08:09,730 --> 01:08:11,470
0,480 480,690 690,1080 1110,1590 1590,1740
fire up {} QEMU and

2213
01:08:11,470 --> 01:08:13,360
0,210 210,690 900,1170 1170,1500 1500,1890
{ - -} with GDB

2214
01:08:13,360 --> 01:08:15,520
0,570 570,900 900,1440 1440,1650 1650,2160
supports,| basically QEMU has inside
|QEMU 内部支持 GDB 服务器。

2215
01:08:15,520 --> 01:08:17,500
0,90 90,390 390,780 780,1440
of a GDB server.|
|

2216
01:08:17,560 --> 01:08:19,270
0,630 630,1080 1080,1230 1230,1320 1320,1710
{} And so it started
它启动了，等待 GDB 连接。

2217
01:08:19,270 --> 01:08:20,740
0,300 300,450 450,750 750,960 960,1470
up and then just wait,

2218
01:08:20,740 --> 01:08:22,390
0,90 90,210 210,750 750,1200 1230,1650
you know for {} GDB

2219
01:08:22,390 --> 01:08:23,480
0,90 90,570
to connect

2220
01:08:23,600 --> 01:08:25,430
0,180 180,630 780,1290 1410,1770 1770,1830
to that.| I'm going to
|在我的电脑上运行 risc64-linux-gnu-gdb 。

2221
01:08:25,430 --> 01:08:26,870
0,300 300,600 600,810 810,960 960,1440
start here on my computer,

2222
01:08:26,870 --> 01:08:28,400
0,180 180,330 330,630 630,900 900,1530
this is a {risc64-linux-gun-gdb -

2223
01:08:28,400 --> 01:08:30,120
0,300 300,540 540,1170
- - -}.|
|

2224
01:08:30,120 --> 01:08:31,440
0,450 480,720 720,810 810,930 930,1320
On some of your machines,
在你们的电脑上，可能是 multi-arch 或其他东西，

2225
01:08:31,440 --> 01:08:33,210
0,270 270,510 510,810 810,1320 1320,1770
might be {multi-arch -} or

2226
01:08:33,210 --> 01:08:35,130
0,240 240,720 960,1470 1470,1800 1800,1920
something else,| but basically the
|但是是为 RISC-V 64 编译的 GDB 。

2227
01:08:35,130 --> 01:08:36,930
0,390 390,870 870,990 990,1230 1230,1800
GDB compiled for {risc64 -},

2228
01:08:37,140 --> 01:08:38,560
0,240 240,480 480,720 720,960
{RISC-V -} {64 -}.|
|

2229
01:08:39,580 --> 01:08:41,500
0,720 1170,1530 1530,1620 1620,1800 1800,1920
And {} I'm gonna set
我在入口处设置断点，

2230
01:08:41,500 --> 01:08:43,120
0,150 150,360 360,750 750,1080 1110,1620
the break point at entry,|
|

2231
01:08:43,120 --> 01:08:44,470
0,210 210,450 450,690 690,1230 1230,1350
because that's the first we
因为我们知道这是实际工作时跳到的第一条指令。

2232
01:08:44,470 --> 01:08:45,310
0,150 150,210 210,450 450,750 750,840
know it has roughly the

2233
01:08:45,310 --> 01:08:48,070
0,240 240,870 1260,1830 1830,2340 2340,2760
first instruction that actually working

2234
01:08:48,070 --> 01:08:49,390
0,150 150,270 270,600 780,1110 1110,1320
is going to jump to.|
|

2235
01:08:50,050 --> 01:08:51,070
0,120 120,300 300,360 360,600 600,1020
I set the break point,
我设置断点并运行，

2236
01:08:51,100 --> 01:08:53,800
0,630 1050,1650 1650,2310 2310,2430 2430,2700
run| and basically {} doesn't
|不是准确地在 8000 处中断，而是在 0a 处，

2237
01:08:53,800 --> 01:08:55,180
0,240 240,510 510,1050 1050,1290 1290,1380
actually break exactly at eight

2238
01:08:55,180 --> 01:08:56,620
0,240 240,450 450,810 810,1050 1050,1440
zero zero zero but zero

2239
01:08:56,620 --> 01:08:57,880
0,390 570,930 930,1020 1020,1110 1110,1260
a| and if we look
|我们查看右边，

2240
01:08:57,880 --> 01:08:59,290
0,300 300,390 390,480 480,870 1170,1410
here on the right,| {you,know}
|看到 0a 是读取控制系统寄存器 mhartid ，并加载它的值到 a1 中。

2241
01:08:59,290 --> 01:09:00,760
0,120 120,270 270,360 360,690 690,1470
we see that {zero,a} is

2242
01:09:01,090 --> 01:09:03,460
0,630 660,990 990,1380 1380,1860
a right reading the

2243
01:09:03,960 --> 01:09:06,510
0,450 450,720 720,1470 1650,2100 2100,2550
control system register, {mhartid -}

2244
01:09:06,750 --> 01:09:08,250
0,300 300,570 570,720 720,1170 1170,1500
and loading that value into

2245
01:09:08,250 --> 01:09:09,320
0,150 150,510
{a1 -}.|
|

2246
01:09:09,700 --> 01:09:11,590
0,150 150,270 270,570 570,1200 1200,1890
And so basically QEMU simulates
所以 QEMU 模拟指令，执行指令，然后继续下一条指令。

2247
01:09:11,590 --> 01:09:12,670
0,240 240,780 780,900 900,960 960,1080
the instruction, then we can

2248
01:09:12,670 --> 01:09:14,110
0,390 390,1080 1080,1230 1230,1320 1320,1440
execute instruction, then we go

2249
01:09:14,110 --> 01:09:15,520
0,120 120,210 210,420 420,900
to the next instruction.|
|

2250
01:09:16,800 --> 01:09:19,530
0,570 930,1590 1590,2040 2190,2610 2610,2730
{} {In,basically}, this address eight
这个地址 8000 就是一个 QEMU 指定的地址，

2251
01:09:19,530 --> 01:09:20,640
0,210 210,450 450,840 840,960 960,1110
zero zero zero it's just

2252
01:09:20,640 --> 01:09:22,350
0,330 330,690 690,840 840,1110 1230,1710
basically something that was agreed

2253
01:09:22,350 --> 01:09:25,260
0,450 480,600 600,810 810,1980 2340,2910
on, you know {} by

2254
01:09:25,260 --> 01:09:27,030
0,540 540,720 720,1140 1140,1590 1590,1770
QEMU or QEMU told,| you
|表明，如果你想使用 QEMU ，跳转到的第一条指令是那个地址。

2255
01:09:27,030 --> 01:09:28,470
0,90 90,600 720,1170 1170,1320 1320,1440
know basically says, {} you

2256
01:09:28,470 --> 01:09:29,760
0,150 150,210 210,480 480,1170 1170,1290
want to use QEMU, the

2257
01:09:29,760 --> 01:09:30,660
0,210 210,600 600,690 690,810 810,900
first instruction we're going to

2258
01:09:30,660 --> 01:09:31,740
0,240 240,360 360,720 720,810 810,1080
jump to is at that

2259
01:09:31,740 --> 01:09:33,080
0,360 360,900
particular location.|
|

2260
01:09:33,170 --> 01:09:35,780
0,180 180,300 300,900 1080,1890 2220,2610
And we basically arranged for
我们安排内核加载器加载 kernel 程序，

2261
01:09:35,780 --> 01:09:37,540
0,210 240,600 600,1200
the kernel loader

2262
01:09:38,260 --> 01:09:40,180
0,660 690,1350 1350,1410 1410,1770 1770,1920
to load the kernel that

2263
01:09:40,180 --> 01:09:41,410
0,390 390,570 570,780 780,870 870,1230
program,| so there's a file
|有一个文件 kernel.ld ，指明内核应该如何加载，

2264
01:09:41,410 --> 01:09:43,960
0,300 300,900 1320,1470 1470,1770 1770,2550
{kernel.ld -} that basically specifies

2265
01:09:43,960 --> 01:09:45,190
0,270 270,390 390,930 930,1110 1110,1230
how the kernel should be

2266
01:09:45,190 --> 01:09:46,870
0,570 810,960 960,1080 1080,1260 1260,1680
loaded,| and you see here
|你可以在这里看到，内核使用的第一个地址就是 QEMU 指定的那个地址。

2267
01:09:46,870 --> 01:09:48,760
0,150 150,660 660,870 870,1410 1410,1890
that basically the first address

2268
01:09:48,760 --> 01:09:49,630
0,180 180,240 240,630 630,720 720,870
that the kernel is going

2269
01:09:49,630 --> 01:09:50,740
0,60 60,450 450,570 570,900 900,1110
to use is actually that

2270
01:09:50,740 --> 01:09:52,060
0,330 330,660 660,750 750,1050 1050,1320
particular address, the [] {QEMU

2271
01:09:52,060 --> 01:09:53,200
0,90 90,690
-} specified.|
|

2272
01:09:54,120 --> 01:09:54,810
0,240 240,300 300,450 450,540 540,690
This is how we get
我们就是这样开始的。

2273
01:09:54,810 --> 01:09:56,080
0,120 120,180 180,570
off the ground.|
|

2274
01:09:58,440 --> 01:09:59,610
0,330 330,450 450,570 570,690 690,1170
{} Does that make sense?|
能理解吗？|

2275
01:10:04,800 --> 01:10:05,820
0,540
Okay,

2276
01:10:05,820 --> 01:10:07,410
0,540 780,1020 1020,1200 1200,1410 1410,1590
{} we see also that
我们可以在这里看到， GDB 显示了指令的二进制编码。

2277
01:10:07,410 --> 01:10:09,120
0,300 300,570 570,1020 1020,1500 1500,1710
here, actually GDB shows the

2278
01:10:09,120 --> 01:10:10,950
0,360 360,780 780,930 930,1050 1050,1830
binary encoding of the instructions.|
|

2279
01:10:11,650 --> 01:10:12,550
0,300 300,450 450,540 540,690 690,900
And so we see that
我们可以看到，我猜 csrr 是四字节指令， addi 是两字节指令。

2280
01:10:12,550 --> 01:10:13,720
0,390 390,450 450,720 720,930 930,1170
basically I guess the {csrr

2281
01:10:13,720 --> 01:10:15,440
0,1170
-}

2282
01:10:15,750 --> 01:10:17,120
0,540 540,810
{ -}

2283
01:10:17,330 --> 01:10:18,680
0,240 240,390 390,1050 1050,1200 1200,1350
four byte instruction and {addi

2284
01:10:18,680 --> 01:10:19,880
0,270 270,360 360,510 510,720 720,1200
-} is two byte instruction.|
|

2285
01:10:22,090 --> 01:10:24,760
0,540 570,1200 1560,1890 1890,2160 2160,2670
Okay, I'm going to see,
好的，我要看一下，实际上是从 entry.S 开始的，

2286
01:10:24,790 --> 01:10:27,010
0,480 480,690 690,990 1110,1920 1920,2220
basically so actually basically start

2287
01:10:27,010 --> 01:10:29,350
0,120 120,360 360,600 600,990 1350,2340
at {entry.S - -} {},|
|

2288
01:10:29,350 --> 01:10:30,610
0,270 270,450 450,930 930,1050 1050,1260
with no paging with no
没有分页，没有隔离，实际上开始于机器模式，

2289
01:10:30,610 --> 01:10:31,660
0,630 630,720 720,780 780,960 960,1050
isolation and in fact we

2290
01:10:31,660 --> 01:10:33,040
0,330 330,510 510,930
started M mode,|
|

2291
01:10:33,260 --> 01:10:35,600
0,660 1170,1590 1590,1920 1920,2010 2010,2340
{} xv6 jumps as quickly
xv6 尽快跳转到内核模式或者 RISC-V 中说的管理者模式，

2292
01:10:35,600 --> 01:10:38,270
0,60 60,540 540,900 900,2040 2340,2670
as possible to a kernel

2293
01:10:38,270 --> 01:10:39,380
0,240 240,300 300,810 810,1050 1050,1110
mode or supervisor mode {}

2294
01:10:39,380 --> 01:10:40,910
0,390 390,600 600,1020 1200,1410 1410,1530
{that,called,in} {RISC-V -},| I'm just
|我在 main 设置一个断点，它运行在管理者模式，

2295
01:10:40,910 --> 01:10:41,540
0,120 120,180 180,330 330,360 360,630
going to set a break

2296
01:10:41,540 --> 01:10:43,250
0,390 390,510 510,1050 1290,1500 1500,1710
point at main {}, which

2297
01:10:43,250 --> 01:10:44,570
0,210 210,480 480,540 540,1050 1050,1320
actually runs in supervisor mode,|
|

2298
01:10:44,630 --> 01:10:46,040
0,120 120,240 240,420 420,900
I'm gonna run there,
我运行到这里，然后达到 main 中的第一条指令，

2299
01:10:46,350 --> 01:10:47,370
0,180 180,390 390,450 450,660 660,1020
and then I get to

2300
01:10:47,370 --> 01:10:48,840
0,180 180,450 450,870 870,990 990,1470
the first instruction of main,|
|

2301
01:10:48,960 --> 01:10:49,960
0,450
so,
所以，让我来显示这个，这是 main ，

2302
01:10:50,740 --> 01:10:52,120
0,210 210,420 420,690 690,1110 1110,1380
let me show this here's

2303
01:10:52,120 --> 01:10:53,260
0,600
main,|
|

2304
01:10:53,260 --> 01:10:55,040
0,540 600,1200

2305
01:10:55,040 --> 01:10:56,600
0,360 420,660 660,840 840,930 930,1560
{} I'd like to run
我想在这种布局下运行 GDB ，分离模式。

2306
01:10:57,200 --> 01:10:58,610
0,510 510,570 570,750 750,1110 1110,1410
GDB in this layout, split

2307
01:10:58,610 --> 01:10:59,600
0,450
mode.|
|

2308
01:11:02,290 --> 01:11:03,010
0,150 150,300 300,390 390,630 630,720
So you can see in
所以你可以在 GDB 中看到，接下来执行哪条指令，

2309
01:11:03,010 --> 01:11:04,390
0,450 450,960 960,1080 1080,1290 1290,1380
GDB actually and what the

2310
01:11:04,390 --> 01:11:06,070
0,210 210,660 660,840 840,1110 1110,1680
next instruction is being executed,|
|

2311
01:11:06,070 --> 01:11:06,670
0,120 120,240 240,360 360,540 540,600
so you see, there's a
你可以看到，有一个断点在那个指令处。

2312
01:11:06,670 --> 01:11:08,020
0,240 240,690 720,840 840,1020 1020,1350
break point at that particular

2313
01:11:08,020 --> 01:11:09,260
0,660
instruction.|
|

2314
01:11:09,260 --> 01:11:11,300
0,300 300,540 540,690 690,1140 1350,2040
{} Since this is run,
因为 QEMU 使用单 CPU 运行，使 GDB 更简单，

2315
01:11:11,860 --> 01:11:13,630
0,570 900,1200 1200,1380 1380,1500 1500,1770
{} {QEMU -} with one

2316
01:11:13,630 --> 01:11:15,190
0,690 750,990 990,1140 1140,1320 1320,1560
CPU, {} just makes it

2317
01:11:15,190 --> 01:11:15,970
0,60 60,480 480,510 510,660 660,780
{} GDB a little bit

2318
01:11:15,970 --> 01:11:17,620
0,510 750,1050 1050,1260 1260,1440 1440,1650
easier,| so there's now only
|所以只有一个核心活跃， QEMU 只模拟了一个核心，

2319
01:11:17,620 --> 01:11:19,400
0,330 330,750 750,1260
one core active,

2320
01:11:19,460 --> 01:11:20,930
0,270 270,450 450,870 870,1290 1290,1470
{} so QEMU emulates only

2321
01:11:20,930 --> 01:11:22,610
0,180 180,480 480,930 1260,1680 1680,1680
one single core| and I
|我可以单步运行，我可以运行到下一条指令，

2322
01:11:22,610 --> 01:11:24,620
0,240 240,780 780,1080 1080,1440 1590,2010
can step through that, so

2323
01:11:24,710 --> 01:11:25,520
0,30 300,420 420,600 600,750 750,810
I can go to the

2324
01:11:25,520 --> 01:11:27,650
0,210 210,990 990,1680 1770,2070 2070,2130
next instruction| and calls a
|调用函数 consoleinit ，它所做的就是你所想的，设置 console 。

2325
01:11:27,650 --> 01:11:28,880
0,300 300,480 480,840 840,990 990,1230
function called {consoleinit - -}

2326
01:11:29,060 --> 01:11:30,290
0,420 420,630 630,990 990,1140 1140,1230
which does exactly what you

2327
01:11:30,290 --> 01:11:31,340
0,330 330,420 420,720 720,810 810,1050
imagine it does, it actually

2328
01:11:31,340 --> 01:11:32,820
0,240 240,330 330,420 420,1020
sets up the console.|
|

2329
01:11:32,940 --> 01:11:33,960
0,300 300,420 420,690 690,840 840,1020
And so once we set
一旦我们设置好 console ，就能打印东西，

2330
01:11:33,960 --> 01:11:34,770
0,90 90,150 150,570 570,690 690,810
up the console, we can

2331
01:11:34,770 --> 01:11:36,540
0,540 570,990 990,1140 1140,1380 1440,1770
actually print to it| and
|所以，随后你会看到新的一行，看到 xv6 booting 。

2332
01:11:36,540 --> 01:11:37,980
0,390 690,960 960,1230 1230,1320 1320,1440
so you'll see in a

2333
01:11:37,980 --> 01:11:38,970
0,330 330,570 570,720 720,750 750,990
second we'll get a new

2334
01:11:38,970 --> 01:11:40,920
0,600 810,990 990,1080 1080,1440 1680,1950
line and we get xv6

2335
01:11:40,920 --> 01:11:41,800
0,360
booting.|
|

2336
01:11:42,220 --> 01:11:43,690
0,390 390,750 840,1200 1200,1260 1260,1470
Okay, so there's a whole
好的，还有一些代码用来设置，

2337
01:11:43,690 --> 01:11:46,420
0,180 180,240 240,990 1050,1800 2280,2730
bunch of additional {} code

2338
01:11:46,420 --> 01:11:47,290
0,90 90,330 330,510 510,810 810,870
to set things up,| you
|

2339
01:11:47,290 --> 01:11:48,580
0,120 120,420 420,750
know there's {}
有设置页面分配器，

2340
01:11:48,580 --> 01:11:50,140
0,300 300,420 420,510 510,780 780,1560
setting up the page allocator,|
|

2341
01:11:50,290 --> 01:11:52,810
0,360 360,990 990,2010 2010,2340 2340,2520
setting up virtual memory which
设置虚拟内存，我会在周三讨论，

2342
01:11:52,810 --> 01:11:54,040
0,60 60,270 270,480 480,570 570,1230
I'll talk about on Wednesday,|
|

2343
01:11:54,190 --> 01:11:56,140
0,540 540,810 810,1290 1290,1560 1560,1950
loading actually starting turning paging
加载启用页面，我也会在周三讨论，

2344
01:11:56,140 --> 01:11:56,980
0,210 210,390 390,390 390,660 660,840
on, which I also talked

2345
01:11:56,980 --> 01:11:59,230
0,180 180,270 270,930 1320,1860 1890,2250
about on Wednesday,| {} setting
|设置初始进程，或设置进程表，

2346
01:11:59,230 --> 01:12:00,760
0,120 120,210 210,750 750,1380 1380,1530
up the initial process or

2347
01:12:00,760 --> 01:12:02,860
0,270 270,360 360,720 720,1380 1710,2100
setting the process table {},|
|

2348
01:12:02,860 --> 01:12:04,330
0,300 300,420 420,960 1020,1200 1200,1470
setting up code due to
根据内核位置设置代码，

2349
01:12:04,330 --> 01:12:05,200
0,120 120,390 390,480 480,570 570,870
the use of the kernel

2350
01:12:05,200 --> 01:12:06,340
0,690
position,|
|

2351
01:12:06,340 --> 01:12:08,410
0,540 600,930 930,1080 1080,1500 1710,2070
{} setting up the interrupt
设置中断控制 plic ，我们会在讨论中断的时候讨论，

2352
01:12:08,410 --> 01:12:10,300
0,450 450,540 540,1080 1380,1680 1680,1890
control the plic, we'll talk

2353
01:12:10,300 --> 01:12:11,140
0,240 240,420 420,480 480,690 690,840
about when we talk about

2354
01:12:11,140 --> 01:12:12,190
0,450 450,570 570,720 720,780 780,1050
interrupts,| but this is one
|但它是，我们使用中断访问磁盘，使用中断访问 console ，

2355
01:12:12,190 --> 01:12:13,380
0,360 360,570
thing {like,that},

2356
01:12:13,380 --> 01:12:14,520
0,510 510,630 630,690 690,810 810,1140
we're going to be using

2357
01:12:14,520 --> 01:12:15,720
0,420 450,810 810,1050 1050,1110 1110,1200
to basically talk to the

2358
01:12:15,720 --> 01:12:17,160
0,450 450,570 570,840 840,990 990,1440
disk, we talked to the

2359
01:12:17,520 --> 01:12:19,770
0,450 450,660 660,1230 1620,1950 1950,2250
console using interrupts,| {} setup
|设置文件系统，分配 buffer 缓存，

2360
01:12:19,770 --> 01:12:21,630
0,90 90,360 360,1050 1290,1770 1770,1860
the file system allocates {}

2361
01:12:21,630 --> 01:12:25,470
0,540 540,1140 2610,3360 3360,3480 3480,3840
buffer cache,| initialize the inode
|初始化 inode 缓存，初始化文件系统，初始化磁盘，

2362
01:12:25,470 --> 01:12:27,270
0,420 420,990 990,1050 1050,1350 1350,1800
cache, initialize the file system,

2363
01:12:27,270 --> 01:12:28,960
0,600 600,750 750,1260
initialize the disk,|
|

2364
01:12:29,050 --> 01:12:30,940
0,150 150,420 420,1110 1320,1590 1590,1890
and then basically once all
一旦设置好所有东西，当操作系统运行时，

2365
01:12:30,940 --> 01:12:31,630
0,150 150,210 210,450 450,480 480,690
sort of things are set

2366
01:12:31,630 --> 01:12:32,500
0,360 390,570 570,630 630,810 810,870
up, you know when the

2367
01:12:32,500 --> 01:12:33,820
0,210 210,480 480,570 570,1050 1170,1320
operating system is running,| it's
|可以开始运行第一个进程， userinit 进程。

2368
01:12:33,820 --> 01:12:34,600
0,120 120,180 180,480 480,690 690,780
going to start running the

2369
01:12:34,600 --> 01:12:36,130
0,270 270,900 1110,1260 1260,1380 1380,1530
first process and this is

2370
01:12:36,130 --> 01:12:37,720
0,330 330,660 660,780 780,1050
the {userinit - -}.|
|

2371
01:12:37,890 --> 01:12:38,940
0,570 630,780 780,810 810,960 960,1050
So there's a little bit
这里比较有意思，所以我要转到 userinit ，

2372
01:12:38,940 --> 01:12:40,140
0,90 90,660 900,1020 1020,1080 1080,1200
of interesting, so I'm going

2373
01:12:40,140 --> 01:12:40,950
0,60 60,240 240,360 360,660 660,810
to go to {userinit -

2374
01:12:40,950 --> 01:12:42,390
0,240 300,870 870,990 990,1080 1080,1440
-}| {} for a second
|稍等，我会单步运行到那里。

2375
01:12:42,390 --> 01:12:42,900
0,90 90,210 210,300 300,450 450,510
and then I'm going to

2376
01:12:42,900 --> 01:12:44,240
0,210 210,510 510,780
single step there.|
|

2377
01:12:46,040 --> 01:12:48,170
0,330 330,660 660,1500 1500,1740 1740,2130
{} Before continue, any questions
在继续之前，关于这些有什么问题吗？

2378
01:12:48,170 --> 01:12:49,240
0,180 180,570
about this?|
|

2379
01:12:54,180 --> 01:12:55,500
0,180 180,390 390,450 450,1020 1020,1320
Is there a specific order
调用这些设置函数有特定顺序吗？

2380
01:12:55,500 --> 01:12:57,240
0,90 90,660 690,960 960,1320 1320,1740
in which the {set,up} functions

2381
01:12:57,240 --> 01:12:59,010
0,180 180,270 270,360 360,810 1170,1770
need to be called?| Yes,
|是的，一些函数必须在其他函数之后运行，它们比较特别，

2382
01:13:00,210 --> 01:13:01,530
0,480 480,780 780,990 990,1080 1080,1320
some function must be run

2383
01:13:01,530 --> 01:13:03,450
0,240 240,480 480,1050 1050,1440 1770,1920
after other functions and {}

2384
01:13:03,450 --> 01:13:04,920
0,270 270,420 420,900 900,1080 1080,1470
they're in particular in there,|
|

2385
01:13:05,370 --> 01:13:06,330
0,210 210,270 270,390 390,600 600,960
some of them doesn't matter,
其中一些无关紧要，但是有一些在其他之后运行是很重要的。

2386
01:13:06,330 --> 01:13:07,260
0,210 210,420 420,480 480,690 690,930
but few of them it's

2387
01:13:07,260 --> 01:13:08,310
0,330 330,450 450,540 540,780 780,1050
important that they run after

2388
01:13:08,310 --> 01:13:09,260
0,150 150,570
other ones.|
|

2389
01:13:11,370 --> 01:13:12,420
0,480
{Good,point}.|
好问题。|

2390
01:13:12,840 --> 01:13:14,550
0,360 360,1020 1200,1410 1410,1500 1500,1710
Okay, {} let me go
好的，让我们转到 userinit ，

2391
01:13:14,550 --> 01:13:15,780
0,540
to

2392
01:13:16,910 --> 01:13:18,440
0,480 480,600 600,1080 1080,1230 1230,1530
{} so {userinit - -},|
|

2393
01:13:19,290 --> 01:13:20,190
0,150 150,450 450,720 720,840 840,900
and basically {userinit - -}
基本上 userinit 有一些胶水代码，组织代码，

2394
01:13:20,190 --> 01:13:21,000
0,120 120,180 180,420 420,570 570,810
there's a little bit of

2395
01:13:21,000 --> 01:13:23,370
0,510 510,990 990,1680 1680,1980 1980,2370
glue code, organization code| to
|利用所有[基础设施]，让第一个进程启动。

2396
01:13:23,520 --> 01:13:24,810
0,210 210,630 630,750 750,930 930,1290
take advantage of all the

2397
01:13:24,840 --> 01:13:27,240
0,540 540,990 990,1650 1650,1890 1980,2400
general [infrastructure] [] have basically

2398
01:13:27,240 --> 01:13:28,200
0,150 150,240 240,540 540,870 870,960
get the first process of

2399
01:13:28,200 --> 01:13:29,220
0,90 90,540
the ground.|
|

2400
01:13:29,440 --> 01:13:31,060
0,330 330,720 720,930 930,1170 1170,1620
{} {You,know,xv6 -} needs some
xv6 需要一些镜像，我们不能真正运行文件系统或 exec ，

2401
01:13:31,090 --> 01:13:32,440
0,480 480,780 780,1020 1020,1260 1260,1350
image, we can't run the

2402
01:13:32,440 --> 01:13:34,600
0,240 240,510 510,750 750,1110 1500,2160
file system really yet, or

2403
01:13:34,600 --> 01:13:36,970
0,240 240,840 1110,1740 1740,2190 2190,2370
do exec,| {} and so
|所以 xv6 需要一些小的程序来启动，

2404
01:13:36,970 --> 01:13:38,350
0,360 360,660 660,900 900,1200 1200,1380
{xv6 -} server small little

2405
01:13:38,350 --> 01:13:39,400
0,390 390,600 630,870 870,990 990,1050
program to get off the

2406
01:13:39,400 --> 01:13:40,630
0,390 480,660 660,780 780,1050 1050,1230
ground| and that small little
|这个小程序就是 initcode ，

2407
01:13:40,630 --> 01:13:43,980
0,630 900,2190 2190,2460 2460,2910
program is {initcode -},|
|

2408
01:13:44,100 --> 01:13:45,240
0,270 270,330 330,690 690,1020 1020,1140
{} the binary version of
这个程序的二进制版本已经静态链接或声明在内核中，

2409
01:13:45,240 --> 01:13:47,370
0,180 180,510 510,600 600,1200 1470,2130
that program is actually linked

2410
01:13:47,370 --> 01:13:49,110
0,330 360,930 930,1470 1470,1680 1680,1740
or declared statically into the

2411
01:13:49,110 --> 01:13:50,100
0,450
kernel,|
|

2412
01:13:50,100 --> 01:13:51,990
0,90 90,450 450,690 690,1080 1080,1890
in fact, that code corresponds
事实上，这些代码对应这个用户程序，

2413
01:13:54,300 --> 01:13:56,340
0,690 750,1080 1080,1380 1380,1830 1830,2040
to a this particular user

2414
01:13:56,340 --> 01:13:57,580
0,690
program,|
|

2415
01:14:00,290 --> 01:14:01,910
0,330 330,480 480,1290 1290,1530 1530,1620
{} it's {} it's a
它是一个由汇编代码写成的程序，

2416
01:14:01,910 --> 01:14:03,530
0,240 240,600 600,780 780,840 840,1620
little program written in assembly|
|

2417
01:14:03,740 --> 01:14:05,510
0,420 420,810 810,1260 1260,1650 1650,1770
and basically it loads the
基本上，它加载地址 init 到 a0 ，

2418
01:14:05,510 --> 01:14:07,580
0,390 390,600 600,930 1080,1860 1860,2070
address {init -} into {a0

2419
01:14:07,580 --> 01:14:09,020
0,510 510,630 630,930 930,1020 1020,1440
-},| it loads the address
|加载地址 argv 到 a1 ，

2420
01:14:09,020 --> 01:14:10,250
0,90 90,240 240,750 750,1110 1110,1230
{argv - -} into {a1

2421
01:14:10,250 --> 01:14:11,930
0,480 900,1050 1050,1200 1200,1290 1290,1680
-}| and then it loads
|然后加载 exec 的系统调用编号到 a7 ，

2422
01:14:11,930 --> 01:14:13,340
0,120 120,480 480,600 600,990 1050,1410
the number for this exec

2423
01:14:13,340 --> 01:14:15,080
0,300 300,570 570,780 780,1530 1590,1740
system call into a7| and
|然后看这里，它调用 ecall 。

2424
01:14:15,080 --> 01:14:16,490
0,480 600,870 870,930 930,990 990,1410
then look at the here

2425
01:14:16,700 --> 01:14:18,060
0,150 150,390 390,540 540,960
that calls {ecall -}.|
|

2426
01:14:18,490 --> 01:14:19,540
0,150 150,450 450,630 630,810 810,1050
So basically what it does
它说做的是，

2427
01:14:19,540 --> 01:14:21,790
0,210 210,690 690,930 930,1710 2040,2250
is| running three instructions and
|执行三条指令，再执行第四条指令，将控制权转移回操作系统，

2428
01:14:21,790 --> 01:14:23,050
0,210 210,420 420,540 540,780 780,1260
then running the fourth instructions

2429
01:14:23,050 --> 01:14:24,940
0,150 150,510 510,1050 1050,1350 1350,1890
which basically transfer back control

2430
01:14:24,940 --> 01:14:27,000
0,540 750,1500
to the,

2431
01:14:28,430 --> 01:14:30,620
0,360 360,750 750,1020 1020,1560 1800,2190
back control to the operating

2432
01:14:30,620 --> 01:14:31,760
0,330 360,660 660,990 990,1050 1050,1140
system,| so generally if I
|如果我在 syscall 设置一个断点，并继续执行，

2433
01:14:31,760 --> 01:14:33,650
0,150 150,210 210,480 480,930 1350,1890
set a break point in

2434
01:14:33,740 --> 01:14:35,140
0,720
syscall,

2435
01:14:35,290 --> 01:14:36,520
0,330 330,450 450,540 540,780 780,1230
{} and now keep running,|
|

2436
01:14:36,520 --> 01:14:38,020
0,120 120,630 630,720 720,1140 1170,1500
then basically you know {userinit
然后 userinit 会创建初始进程，进入用户空间，

2437
01:14:38,020 --> 01:14:39,370
0,120 120,480 480,600 600,750 750,1350
- -}, you know will

2438
01:14:39,950 --> 01:14:41,450
0,330 330,420 420,750 750,1350 1350,1500
create the initial process and

2439
01:14:41,450 --> 01:14:43,610
0,270 270,330 330,600 600,1170 1590,2160
return to user space,| run
|执行这三条指令或四条指令，再返回内核空间。

2440
01:14:43,610 --> 01:14:45,770
0,120 120,390 390,1260 1620,1950 1950,2160
the three instructions or four

2441
01:14:45,770 --> 01:14:47,060
0,420 420,540 540,810 810,930 930,1290
instruction, and basically come back

2442
01:14:47,060 --> 01:14:48,700
0,360 360,660 660,1200
into kernel space.|
|

2443
01:14:49,040 --> 01:14:49,760
0,150 150,420 420,540 540,600 600,720
So basically this is the
所以，这是 xv6 中用户程序运行的第一个系统调用，

2444
01:14:49,760 --> 01:14:51,800
0,360 360,660 660,1110 1110,1530 1740,2040
first system call that any

2445
01:14:51,800 --> 01:14:53,510
0,450 450,1050 1050,1170 1170,1470 1470,1710
user application in {xv6 -}

2446
01:14:53,510 --> 01:14:54,470
0,390 420,570 570,720 720,840 840,960
runs,| so let's see what
|让我们看看会发生什么，所以继续，我们到达 syscall 。

2447
01:14:54,470 --> 01:14:56,660
0,540 840,990 990,1200 1200,1620
happens {} at right,

2448
01:14:57,090 --> 01:14:59,520
0,600 990,1530 1530,2160 2160,2310 2310,2430
so, {} continue and we

2449
01:14:59,520 --> 01:15:01,220
0,210 210,420 420,570 570,1140
actually got to syscall.|
|

2450
01:15:01,220 --> 01:15:02,120
0,420

2451
01:15:04,540 --> 01:15:05,560
0,240 240,420 420,540 540,630 630,1020
{} So look at syscall,
我们可以查看 syscall ，它是最下面的一个函数。

2452
01:15:05,560 --> 01:15:06,310
0,90 90,180 180,330 330,450 450,750
we can look at it,

2453
01:15:06,700 --> 01:15:07,720
0,510 510,570 570,900 900,960 960,1020
it's a function at the

2454
01:15:07,720 --> 01:15:08,840
0,570
bottom.|
|

2455
01:15:09,340 --> 01:15:10,390
0,240 240,360 360,570 570,870 870,1050
And so we're back into
现在我们回到内核空间了，我们看看 syscall 到底发生了什么，

2456
01:15:10,390 --> 01:15:12,370
0,270 270,600 600,1110 1410,1890 1890,1980
kernel space now, and we're

2457
01:15:12,370 --> 01:15:13,390
0,120 120,240 240,690 690,930 930,1020
going to walk through and

2458
01:15:13,390 --> 01:15:14,950
0,180 180,420 420,570 570,1020 1020,1560
see actually what happens exactly

2459
01:15:14,950 --> 01:15:17,200
0,450 810,1020 1020,1410 1410,2040 2070,2250
in {} syscall,| so I'm
|我会单步运行，看看它里面的过程，

2460
01:15:17,200 --> 01:15:18,190
0,210 240,510 510,780 780,810 810,990
gonna single step a little

2461
01:15:18,190 --> 01:15:19,100
0,360
bit,

2462
01:15:19,190 --> 01:15:20,240
0,540 540,630 630,810 810,990 990,1050
{} it looks about the

2463
01:15:20,240 --> 01:15:22,490
0,600 840,1020 1020,1530 1530,1920 1920,2250
[current] the processes within it,|
|

2464
01:15:22,490 --> 01:15:23,930
0,90 90,210 210,660 870,1170 1170,1440
you know that pulls out
它拿出使用的系统调用编号，

2465
01:15:23,930 --> 01:15:25,460
0,360 510,900 900,1110 1110,1350 1350,1530
the system call number, that's

2466
01:15:25,460 --> 01:15:26,330
0,360 360,540 540,630 630,750 750,870
used,| so we can now
|我们现在可以打印 num ，它的值是 7 。

2467
01:15:26,330 --> 01:15:27,720
0,390 390,870
print num,

2468
01:15:27,910 --> 01:15:29,290
0,420 420,570 570,720 720,930 930,1380
and let's see that's 7.|
|

2469
01:15:29,980 --> 01:15:31,030
0,180 180,330 330,420 420,660 660,1050
And if we look at,
如果我们查看 kernel 里的 syscall.h ，

2470
01:15:34,160 --> 01:15:36,650
0,420 420,1170 1650,1830 1830,1920 1920,2490
{ -} one of kernel's

2471
01:15:36,650 --> 01:15:38,540
0,150 150,510 510,840 840,1410
is {syscall.h - -},|
|

2472
01:15:38,660 --> 01:15:39,890
0,210 210,690 690,840 840,930 930,1230
that declares all the system
里面定义了所有系统调用编号，

2473
01:15:39,890 --> 01:15:41,390
0,240 240,720 720,1080 1080,1290 1290,1500
call numbers| and we see
|我们可以看到 7 是系统调用 exec 。

2474
01:15:41,390 --> 01:15:43,280
0,510 510,810 810,930 930,1530 1560,1890
7 that is indeed system

2475
01:15:43,280 --> 01:15:44,540
0,300 300,750
call exec.|
|

2476
01:15:44,940 --> 01:15:45,900
0,150 150,240 240,570 570,720 720,960
And so basically this tells
这告诉内核，某些用户程序调用 ecall 指令，

2477
01:15:45,900 --> 01:15:48,120
0,60 60,480 480,990 1080,1470 1470,2220
the kernel, some user application,

2478
01:15:48,510 --> 01:15:50,550
0,630 660,990 990,1080 1080,1350 1350,2040
{} called the ecall instruction|
|

2479
01:15:50,550 --> 01:15:52,200
0,660 780,960 960,1050 1050,1530 1530,1650
and with the intention of
想要调用，想要运行 exec 系统调用。

2480
01:15:52,200 --> 01:15:54,480
0,300 300,450 450,750 750,1320 1530,2280
calling this system call for

2481
01:15:54,510 --> 01:15:55,600
0,570
{}

2482
01:15:58,150 --> 01:15:58,960
0,150 150,210 210,510 510,600 600,810
with the intention of running

2483
01:15:58,960 --> 01:16:00,480
0,60 60,390 390,630 630,990
the exec system call.|
|

2484
01:16:00,900 --> 01:16:01,890
0,240 240,360 360,660 660,750 750,990
And so we can single
我们可以再单步执行几步，

2485
01:16:01,890 --> 01:16:03,030
0,240 240,270 270,420 420,540 540,1140
step a little bit further,|
|

2486
01:16:03,120 --> 01:16:03,750
0,150 150,330 330,450 450,570 570,630
{} we go to the
我们到下一步，这一行执行 syscall ，

2487
01:16:03,750 --> 01:16:04,920
0,480 510,810 810,960 960,1050 1050,1170
next thing, this is the

2488
01:16:04,920 --> 01:16:06,090
0,300 300,420 420,810 810,870 870,1170
line that executes a system

2489
01:16:06,090 --> 01:16:07,350
0,330 330,450 450,630 630,780 780,1260
call,| so let's go there,
|让我们到那里，可以看到 num 作为一个数组的索引，

2490
01:16:07,860 --> 01:16:09,030
0,150 150,270 270,420 420,540 540,1170
and you see that basically

2491
01:16:09,270 --> 01:16:10,380
0,180 180,510 510,630 630,1020 1020,1110
the num is used to

2492
01:16:10,380 --> 01:16:12,000
0,390 390,720 720,810 810,1410 1410,1620
index into an array| and
|这个数组有很多函数指针，

2493
01:16:12,000 --> 01:16:12,810
0,330 330,480 480,540 540,720 720,810
array there's a bunch of

2494
01:16:12,810 --> 01:16:15,570
0,360 360,1020 1410,2070 2100,2490 2490,2760
function pointers| and [] the
|[包括] SYS_exec 入口，指向 sys_exec 函数，

2495
01:16:15,570 --> 01:16:17,700
0,960 990,1560 1560,1620 1620,1770 1770,2130
SYS_exec entry, you know points

2496
01:16:17,700 --> 01:16:20,400
0,540 870,1320 1320,1860 1890,2430 2460,2700
to {sys_exec -} function,| so
|所以我们单步运行到这里。

2497
01:16:20,400 --> 01:16:21,150
0,90 90,210 210,270 270,510 510,750
we're going to single step

2498
01:16:21,150 --> 01:16:22,260
0,270 270,690
into this.|
|

2499
01:16:22,920 --> 01:16:24,780
0,780 810,1260 1260,1530 1530,1710 1710,1860
And {} we see that
我们看到我们在 sys_exec ，它在 sysfile 文件中。

2500
01:16:24,780 --> 01:16:26,280
0,180 180,450 450,630 630,900 930,1500
we're actually at the sys_exec,

2501
01:16:29,540 --> 01:16:30,800
0,330 330,630 630,870 870,1020 1020,1260
{} so this is in

2502
01:16:30,800 --> 01:16:32,420
0,270 270,990
{sysfile -}.|
|

2503
01:16:32,810 --> 01:16:33,620
0,300 300,390 390,510 510,750 750,810
{You,know} we can move it
我们可以在这个窗口中移动多一点，

2504
01:16:33,620 --> 01:16:35,120
0,60 60,240 240,360 360,810 1320,1500
a little bit more in

2505
01:16:35,120 --> 01:16:36,770
0,60 60,360 360,1080 1410,1560 1560,1650
a bigger window| and we
|我们可以在这里看到，系统调用。

2506
01:16:36,770 --> 01:16:38,380
0,360 360,1050
basically see

2507
01:16:38,380 --> 01:16:40,220
0,1200
here,

2508
01:16:40,220 --> 01:16:41,580
0,270 270,750
system call.|
|

2509
01:16:41,670 --> 01:16:42,660
0,270 270,480 480,540 540,810 810,990
{} And the first thing
首先，它从用户空间获取参数，

2510
01:16:42,660 --> 01:16:43,920
0,120 120,270 270,570 570,1020 1050,1260
that you see actually it

2511
01:16:43,920 --> 01:16:45,510
0,270 270,630 630,1170 1170,1350 1350,1590
actually gets arguments from user

2512
01:16:45,510 --> 01:16:46,530
0,390 390,600 600,690 690,930 930,1020
space,| so it gets the
|它获取路径名，

2513
01:16:46,530 --> 01:16:47,840
0,330 330,780
path name,|
|

2514
01:16:47,840 --> 01:16:49,160
0,90 90,150 150,600 810,1260 1260,1320
so we want jump a
我们跳的更远一些，

2515
01:16:49,160 --> 01:16:50,640
0,180 180,300 300,930
little bit further,|
|

2516
01:16:50,970 --> 01:16:54,340
0,780 780,1440 1560,2820
{um,memset -} {},
memset ，为参数分配空间，将所有参数从用户空间复制到内核空间，

2517
01:16:57,200 --> 01:16:59,480
0,390 390,1050 1140,1530 1530,1710 1710,2280
basically allocates space for arguments,

2518
01:16:59,480 --> 01:17:00,350
0,90 90,300 330,660 660,780 780,870
you know copys all the

2519
01:17:00,350 --> 01:17:01,430
0,390 390,510 510,750 750,990 990,1080
arguments from user space to

2520
01:17:01,430 --> 01:17:03,110
0,240 240,660 660,1200 1200,1410 1410,1680
kernel space,| we'll look down
|我们会在后面几周看到更多细节，

2521
01:17:03,110 --> 01:17:04,340
0,120 120,420 420,630 630,690 690,1230
in great amount of detail

2522
01:17:04,340 --> 01:17:05,420
0,90 90,180 180,420 420,690 690,1080
in a couple weeks,| so
|现在不用过多考虑它。

2523
01:17:05,420 --> 01:17:06,140
0,180 180,360 360,510 510,630 630,720
don't worry about it too

2524
01:17:06,140 --> 01:17:07,180
0,180 180,480
much yet.|
|

2525
01:17:07,210 --> 01:17:08,470
0,270 270,660 660,810 810,960 960,1260
But basically there's some code
基本上是有一些代码将参数从用户空间移动到内核空间，

2526
01:17:08,470 --> 01:17:10,450
0,390 660,1200 1200,1680 1680,1800 1800,1980
to move arguments {} user

2527
01:17:10,450 --> 01:17:11,590
0,240 240,300 300,540 540,1050 1050,1140
space to kernel space,| you
|从用户地址空间到内核地址空间。

2528
01:17:11,590 --> 01:17:12,610
0,90 90,240 240,300 300,630 630,1020
know from the kernel from

2529
01:17:12,610 --> 01:17:13,630
0,60 60,360 360,600 600,840 840,1020
the user address space to

2530
01:17:13,630 --> 01:17:15,120
0,270 270,480 480,900
kernel address space.|
|

2531
01:17:15,120 --> 01:17:15,840
0,150 150,210 210,300 300,510 510,720
And if we now look
我们查看 path ，你可以打印 path ，

2532
01:17:15,840 --> 01:17:16,920
0,180 180,660 660,750 750,870 870,1080
at path, you can print

2533
01:17:16,920 --> 01:17:19,020
0,60 60,630 780,1380 1830,1980 1980,2100
the path hopefully,| you will
|你会看到这是一个字符串，

2534
01:17:19,020 --> 01:17:20,370
0,240 240,660 660,1050 1050,1170 1170,1350
see actually that you know

2535
01:17:20,370 --> 01:17:22,200
0,330 330,450 450,720 750,1350 1380,1830
that is a string| and
|你会看到那个小 init 程序所做的，

2536
01:17:22,200 --> 01:17:24,150
0,90 90,450 450,630 630,1170 1350,1950
you'll see that basically what

2537
01:17:24,150 --> 01:17:25,680
0,210 210,450 450,660 660,1170 1170,1530
that little init code program

2538
01:17:25,680 --> 01:17:27,840
0,450 630,840 840,1170 1170,1500 1530,2160
does| is trying to exec
|试图 exec init 程序，这是另一个程序了。

2539
01:17:27,870 --> 01:17:29,340
0,90 90,240 240,510 540,930 960,1470
you know the init program

2540
01:17:29,880 --> 01:17:31,650
0,120 120,210 210,420 420,960 1020,1770
which is yet another program.|
|

2541
01:17:31,650 --> 01:17:32,640
0,180 180,390 390,540 540,630 630,990
So let's look at that
所以，让我们看一下这里发生了什么。

2542
01:17:32,640 --> 01:17:33,840
0,150 150,540 540,660 660,750 750,1200
for seconds just to see

2543
01:17:34,440 --> 01:17:35,760
0,150 150,360 360,780
what that is.|
|

2544
01:17:38,140 --> 01:17:39,130
0,210 210,570 570,690 690,810 810,990
So here we have {init
这里是 init ， init 基本上是为用户空间设置一些东西，

2545
01:17:39,130 --> 01:17:40,080
0,330
-},

2546
01:17:40,080 --> 01:17:41,070
0,90 90,270 270,360 360,690 690,990
and {init -} basically sets

2547
01:17:41,070 --> 01:17:42,060
0,120 120,210 210,450 450,810 810,990
up a couple things use

2548
01:17:42,060 --> 01:17:43,830
0,120 120,390 390,930 1320,1680 1680,1770
for user space,| opens the
|打开 console ， console 的文件描述符，复制几次，调用 fork ，

2549
01:17:43,830 --> 01:17:45,210
0,510 510,600 600,840 840,1230 1230,1380
console, the file descriptor for

2550
01:17:45,210 --> 01:17:46,830
0,60 60,720 750,1050 1050,1380 1500,1620
the console, dup it a

2551
01:17:46,830 --> 01:17:48,060
0,210 210,780
couple times,

2552
01:17:48,060 --> 01:17:49,440
0,270 270,810
calls fork,|
|

2553
01:17:49,440 --> 01:17:50,730
0,510 510,840 840,930 930,1170 1170,1290
and basically the first thing
基本上第一件事情是，它创建一个进程，然后 exec shell ，

2554
01:17:50,730 --> 01:17:52,050
0,90 90,390 390,840 840,990 990,1320
it does, actually it starts

2555
01:17:52,050 --> 01:17:53,640
0,480 510,750 750,780 780,930 930,1590
to create a new process

2556
01:17:53,910 --> 01:17:55,470
0,510 510,750 750,1020 1020,1230 1230,1560
and will exec the shell

2557
01:17:55,470 --> 01:17:56,480
0,480
shell,|
|

2558
01:17:56,480 --> 01:17:57,800
0,180 180,360 360,540 540,1110 1170,1320
and so this will in
最后 shell 可以运行。

2559
01:17:57,800 --> 01:17:59,300
0,90 90,300 300,720 720,1410 1410,1500
the end, result as the

2560
01:17:59,300 --> 01:18:00,720
0,270 270,480 480,840
shell being run.|
|

2561
01:18:01,030 --> 01:18:01,810
0,150 150,210 210,510 510,600 600,780
So, for example if I
如果我继续，可能会再次中断，在 exec ，

2562
01:18:01,810 --> 01:18:03,160
0,180 180,750 750,840 840,1110 1110,1350
would continue I probably break

2563
01:18:03,160 --> 01:18:04,330
0,330 330,420 420,630 630,1080 1080,1170
again, it says exec,| and
|查看它的参数，实际上 exec 是在 exec shell 。

2564
01:18:04,330 --> 01:18:05,020
0,120 120,180 180,480 480,570 570,690
if I look at the

2565
01:18:05,020 --> 01:18:06,130
0,450 450,510 510,630 630,900 900,1110
arguments I will see that

2566
01:18:06,130 --> 01:18:08,260
0,510 690,1290 1320,1590 1590,1920 1920,2130
actually the exec system call

2567
01:18:08,260 --> 01:18:10,360
0,120 120,270 270,810 810,1290 1410,2100
is being called to execs

2568
01:18:10,360 --> 01:18:11,400
0,150 150,540
the shell.|
|

2569
01:18:11,520 --> 01:18:12,300
0,150 150,330 330,390 390,690 690,780
And once you exec the
一旦 exec shell ，让我们先这样做，

2570
01:18:12,300 --> 01:18:13,500
0,480 510,600 600,750 750,1050 1050,1200
shell, you know, let's do

2571
01:18:13,500 --> 01:18:14,580
0,510
that,|
|

2572
01:18:14,580 --> 01:18:16,050
0,630 660,930 930,1170 1170,1230 1230,1470
then we'll do a couple
然后会调用更多系统调用，某个时刻你会看到。

2573
01:18:16,050 --> 01:18:17,550
0,240 240,510 510,990 1080,1380 1380,1500
more system calls and at

2574
01:18:17,550 --> 01:18:18,660
0,150 150,420 420,570 570,780 780,1110
some point you'll see that.|
|

2575
01:18:19,880 --> 01:18:22,010
0,450 450,570 570,660 660,1230 1560,2130
Well, let me do continue,
好的，让我继续，然后 shell 就运行了。

2576
01:18:22,010 --> 01:18:23,030
0,150 150,480 480,570 570,810 810,1020
then basically the shell starts

2577
01:18:23,030 --> 01:18:24,000
0,360
running.|
|

2578
01:18:24,930 --> 01:18:25,470
0,180 180,270 270,390 390,480 480,540
So it gives you a
所以，这给了你一些感觉， xv6 是如何开始的，

2579
01:18:25,470 --> 01:18:26,820
0,210 210,420 420,570 570,1200 1230,1350
little bit of sense, you

2580
01:18:26,820 --> 01:18:28,170
0,120 120,390 390,810 810,1110 1110,1350
know actually how {xv6 -}

2581
01:18:28,170 --> 01:18:29,730
0,210 210,450 450,510 510,1110 1350,1560
gets off the ground {},|
|

2582
01:18:29,730 --> 01:18:30,960
0,120 120,450 450,780 780,1020 1020,1230
the first shell actually gets
第一个 shell 运行，

2583
01:18:30,960 --> 01:18:32,400
0,600 780,930 930,1020 1020,1230 1230,1440
run| and we saw this
|我们看到第一个系统调用是如何发生的。

2584
01:18:32,400 --> 01:18:33,780
0,150 150,240 240,930 960,1230 1230,1380
sort of a little bit

2585
01:18:33,780 --> 01:18:34,890
0,120 120,180 180,690 690,930 930,1110
of an overview about how

2586
01:18:34,890 --> 01:18:36,150
0,120 120,600 600,900 900,990 990,1260
the first when the first

2587
01:18:36,150 --> 01:18:37,840
0,240 240,480 480,780 780,1230
system call actually happened.|
|

2588
01:18:38,180 --> 01:18:39,260
0,210 210,420 420,720 720,960 960,1080
We haven't really looked at
我们没有深入了解系统调用是如何进入退出的，

2589
01:18:39,260 --> 01:18:40,880
0,270 270,570 570,1230 1230,1470 1470,1620
the dive machinery for these

2590
01:18:40,880 --> 01:18:41,930
0,270 270,570 570,780 780,900 900,1050
system calls how to get

2591
01:18:41,930 --> 01:18:42,530
0,210 210,330 330,480 480,540 540,600
in and out of the

2592
01:18:42,530 --> 01:18:43,820
0,540 750,960 960,1080 1080,1140 1140,1290
kernel,| we're going to talk
|我们会在后面几周的课程中讨论更多细节，

2593
01:18:43,820 --> 01:18:45,050
0,330 330,450 450,510 510,780 780,1230
about in a couple weeks

2594
01:18:45,080 --> 01:18:46,280
0,360 360,510 510,780 780,1140 1140,1200
or two weeks in {}

2595
01:18:46,280 --> 01:18:47,420
0,480 480,690 690,900 900,1080 1080,1140
lecture in great amount of

2596
01:18:47,420 --> 01:18:48,560
0,540 570,810 810,930 930,990 990,1140
detail,| but this is sort
|但是这对于 syscall 实验已经足够了，

2597
01:18:48,560 --> 01:18:49,730
0,60 60,630 780,990 990,1080 1080,1170
of enough for you to

2598
01:18:49,730 --> 01:18:50,990
0,510 510,840 840,1020 1020,1080 1080,1260
understand actually how to do

2599
01:18:50,990 --> 01:18:52,520
0,480 510,870 870,1320 1350,1440 1440,1530
the syscall lab,| you know
|这是我们这周布置的实验。

2600
01:18:52,520 --> 01:18:53,870
0,180 180,360 360,690 690,1140 1170,1350
that we assigned for this

2601
01:18:53,870 --> 01:18:54,560
0,360
week.|
|

2602
01:18:54,590 --> 01:18:55,970
0,570 570,840 840,960 960,1140 1140,1380
{} And so these are
所以这些是你们要了解的部分。

2603
01:18:55,970 --> 01:18:56,840
0,60 60,390 390,600 600,750 750,870
the pieces, you will be

2604
01:18:56,840 --> 01:18:58,100
0,450 450,750
interacting with.|
|

2605
01:18:59,120 --> 01:19:00,650
0,180 180,780 810,1200 1200,1320 1320,1530
Any questions before I wrap
在我结束之前，有什么问题吗，因为我们快没有时间了。

2606
01:19:00,650 --> 01:19:01,910
0,330 330,660 660,900 900,1200 1200,1260
up, because we're almost out

2607
01:19:01,910 --> 01:19:02,920
0,90 90,480
of time.|
|

2608
01:19:08,330 --> 01:19:09,470
0,210 210,390 390,480 480,750 750,1140
You're free to fire away.|
你可以随意提问。|

2609
01:19:15,680 --> 01:19:16,640
0,180 180,330 330,600 600,720 720,960
Are we going to do
我们有关于网络的东西吗，比如网络的实验。

2610
01:19:16,640 --> 01:19:19,370
0,600 600,1140 1140,1740 2010,2640 2640,2730
anything with {} networks, so

2611
01:19:19,370 --> 01:19:22,130
0,150 150,810 810,1320 1320,2040 2460,2760
like networking and labs.| Yes,
|是的，最后一个实验是实现一个网络驱动，

2612
01:19:22,130 --> 01:19:23,600
0,150 150,450 450,750 750,1080 1080,1470
the last lab is {}

2613
01:19:23,600 --> 01:19:25,130
0,210 210,600 600,630 630,930 930,1530
you implement a network driver,|
|

2614
01:19:25,620 --> 01:19:26,280
0,90 90,210 210,300 300,420 420,660
and so you will write
你需要写一些代码与硬件交互，

2615
01:19:26,280 --> 01:19:27,390
0,60 60,330 330,450 450,900 900,1110
the code that interacts with

2616
01:19:27,390 --> 01:19:28,290
0,150 150,600 600,690 690,780 780,900
the hardware| and you have
|你需要操作网卡网络驱动的寄存器，

2617
01:19:28,290 --> 01:19:31,050
0,90 90,570 570,1530 1980,2610 2610,2760
to manipulate the registers from

2618
01:19:31,050 --> 01:19:33,510
0,90 90,390 390,960 1320,2190 2280,2460
the network driver for the

2619
01:19:33,510 --> 01:19:35,310
0,270 270,780 1170,1350 1350,1500 1500,1800
network card,| {} that basically
|网卡连接在 RISC-V 板上，

2620
01:19:35,310 --> 01:19:36,720
0,540 540,660 660,990 990,1200 1200,1410
connects {you,know} to this {RISC-V

2621
01:19:36,720 --> 01:19:37,680
0,240 240,660 660,750 750,840 840,960
-} board,| you know you
|你可以看到它是一根电缆，插入以太网控制器，

2622
01:19:37,680 --> 01:19:38,550
0,210 210,420 420,480 480,600 600,870
saw that it was a

2623
01:19:38,550 --> 01:19:39,810
0,390 390,720 720,810 810,1140 1140,1260
block basically to plugin an

2624
01:19:39,810 --> 01:19:42,030
0,390 390,930 960,1170 1170,1650 2010,2220
Ethernet control, a cable,| so
|这里有一个以太网卡，你需要对它编程，

2625
01:19:42,030 --> 01:19:44,120
0,180 180,300 300,1230 1230,1650
there's an Ethernet card,

2626
01:19:44,240 --> 01:19:45,050
0,420 420,510 510,630 630,750 750,810
and so you're going to

2627
01:19:45,050 --> 01:19:46,250
0,90 90,540 540,690 690,1050 1050,1200
be programming that card,| you're
|你可以真正地通过互联网发送一些包。

2628
01:19:46,250 --> 01:19:48,140
0,630 660,1140 1140,1350 1350,1470 1470,1890
gonna actually send some packets

2629
01:19:48,140 --> 01:19:49,500
0,300 300,390 390,810
across the Internet.|
|

2630
01:19:51,680 --> 01:19:53,330
0,420 450,960 1260,1410 1410,1560 1560,1650
Great, thanks.| Yeah, it's the
好的，谢谢。|是的，那是最后一个实验。

2631
01:19:53,330 --> 01:19:54,500
0,240 240,660
last lab.|
|

2632
01:19:58,160 --> 01:19:59,600
0,210 210,330 330,900
Any other questions?|
还有别的问题吗？|

2633
01:20:04,250 --> 01:20:04,940
0,150 150,270 270,390 390,510 510,690
We're gonna, let me wrap
让我来结束一下，

2634
01:20:04,940 --> 01:20:06,050
0,150 150,390 390,600 600,840 840,1110
up here,| I think the
|我想 syscall 实验，因为我们没有深入很多细节，希望它不会太难，

2635
01:20:06,050 --> 01:20:08,330
0,300 300,480 480,720 720,1320 1620,2280
{syscall -} lab itself {},

2636
01:20:08,810 --> 01:20:10,040
0,360 360,540 540,780 780,960 960,1230
because we're not really going

2637
01:20:10,040 --> 01:20:11,540
0,270 270,450 450,510 510,1050 1050,1500
great amount of detail, hopefully

2638
01:20:11,540 --> 01:20:12,680
0,210 210,330 330,450 450,870 900,1140
shouldn't be too bad,| it
|它可能比 util 实验简单，

2639
01:20:12,680 --> 01:20:13,640
0,180 180,270 270,630 630,810 810,960
might be easier than the

2640
01:20:13,640 --> 01:20:14,940
0,360 360,810
util lab,|
|

2641
01:20:14,940 --> 01:20:16,980
0,540 720,1230 1230,1500 1500,1710 1710,2040
{} labs, next lab, however
下一个实验可能比较难，

2642
01:20:16,980 --> 01:20:18,480
0,180 180,300 300,480 480,990 1230,1500
might be more difficult,| so
|所以想让所有实验正确是比较困难的，

2643
01:20:18,480 --> 01:20:19,200
0,150 150,330 330,480 480,540 540,720
it's always hard to get

2644
01:20:19,200 --> 01:20:20,580
0,120 120,240 240,600 600,900 900,1380
all these labs right,| but
|但是 syscall 实验不会太难，

2645
01:20:20,580 --> 01:20:21,810
0,240 240,570 570,900 900,990 990,1230
this {syscall,lab} hopefully it shouldn't

2646
01:20:21,810 --> 01:20:24,180
0,600 840,1050 1050,1470 1470,1680 2010,2370
be too difficult,| but please
|但是不要太晚开始，要早点开始，

2647
01:20:24,180 --> 01:20:25,530
0,210 210,600 600,810 810,1020 1020,1350
don't start don't wait until

2648
01:20:25,530 --> 01:20:27,000
0,90 90,270 270,780 810,1200 1200,1470
the night before, get going

2649
01:20:27,000 --> 01:20:28,200
0,480 660,840 840,990 990,1080 1080,1200
early,| so that if you're
|如果你遇到疑难的 bug ，我们可以帮助你，

2650
01:20:28,200 --> 01:20:29,640
0,270 270,450 450,810 810,1230 1230,1440
running some obscure bug, that

2651
01:20:29,640 --> 01:20:30,420
0,90 90,210 210,420 420,630 630,780
we can actually help you

2652
01:20:30,420 --> 01:20:31,950
0,300 360,570 570,750 750,1050 1050,1530
out| and make sure that
|确保你的程序可以正常工作。

2653
01:20:32,160 --> 01:20:33,360
0,180 180,540 540,780 780,870 870,1200
your program works {[] -}.|
|

2654
01:20:35,270 --> 01:20:38,120
0,180 180,630 930,1530 1530,2190 2370,2850
With that, {} I'll sign
就是这些，我要退出了，周三见。

2655
01:20:38,120 --> 01:20:39,200
0,390 390,630 630,780 780,930 930,1080
off and I'll see you

2656
01:20:39,200 --> 01:20:40,440
0,120 120,630
in Wednesday.
