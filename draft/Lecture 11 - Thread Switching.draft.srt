1
00:00:00,030 --> 00:00:02,160
0,330 330,540 540,900
Anyone hear me?|

2
00:00:02,860 --> 00:00:05,170
0,570 990,1230 1230,1470 1500,1890 1920,2310
{I,can,you}.| Thank you, alright {}.|

3
00:00:06,500 --> 00:00:07,820
0,360 360,480 480,570 570,960 960,1320
I'd like to spend today's

4
00:00:07,820 --> 00:00:10,760
0,720 960,1290 1290,1590 2100,2700 2700,2940
lecture talking about threads| and

5
00:00:10,760 --> 00:00:11,900
0,240 240,480 480,600 600,900 900,1140
how {xv6 - -} does

6
00:00:11,900 --> 00:00:14,030
0,270 270,780 1080,1560 1560,1740 1740,2130
thread switching,| this is a

7
00:00:14,060 --> 00:00:15,140
0,210 210,390 420,630 630,780 780,1080
sort of one of the

8
00:00:15,170 --> 00:00:17,030
0,240 240,330 330,930 1020,1440 1530,1860
under the hood {} lectures

9
00:00:17,030 --> 00:00:18,260
0,90 90,390 390,510 510,840 840,1230
{about -} {[xv6] -},| we've

10
00:00:18,920 --> 00:00:20,060
0,240 240,540 540,840 840,1050 1050,1140
had lectures before about how

11
00:00:20,060 --> 00:00:21,830
0,60 60,390 390,780 780,1500 1500,1770
the system calls interrupts, page

12
00:00:21,830 --> 00:00:23,990
0,360 360,450 450,840 840,1290 1680,2160
tables and locks work| and

13
00:00:24,110 --> 00:00:25,220
0,570 570,660 660,780 780,840 840,1110
today we're going to talk

14
00:00:25,220 --> 00:00:27,380
0,660 1440,1680 1680,1860 1860,1950 1950,2160
about how does the {xv6

15
00:00:27,380 --> 00:00:29,480
0,270 270,720 720,990 990,1320 1320,2100
-} switches among different processes

16
00:00:29,510 --> 00:00:30,160
0,300
now.|

17
00:00:30,590 --> 00:00:31,920
0,600

18
00:00:32,040 --> 00:00:33,000
0,210 210,600 600,720 720,870 870,960
The reason for this the

19
00:00:33,000 --> 00:00:34,110
0,330 330,540 540,780 780,870 870,1110
highest level reason for this,|

20
00:00:34,110 --> 00:00:35,130
0,120 120,300 300,660 660,870 870,1020
is that people like their

21
00:00:35,130 --> 00:00:36,180
0,570 570,690 690,780 780,960 960,1050
computer| to be able to

22
00:00:36,180 --> 00:00:37,560
0,150 150,360 360,450 450,660 660,1380
do more than one task

23
00:00:37,590 --> 00:00:39,840
0,600 600,690 690,930 930,1500 1950,2250
at the same time,| so

24
00:00:39,840 --> 00:00:40,860
0,90 90,480 480,720 720,840 840,1020
the reason might be that

25
00:00:40,860 --> 00:00:42,600
0,150 150,540 540,870 870,1470 1470,1740
you're supporting time sharing,| like

26
00:00:42,870 --> 00:00:44,490
0,120 120,420 420,870 870,1200 1200,1620
{Athena -} allows many users

27
00:00:44,490 --> 00:00:45,240
0,90 90,420 420,480 480,540 540,750
to login at the same

28
00:00:45,240 --> 00:00:46,110
0,300 300,390 390,540 540,720 720,870
time| and they know they

29
00:00:46,110 --> 00:00:48,030
0,120 120,270 270,450 450,1200 1500,1920
can all run processes| or

30
00:00:48,030 --> 00:00:49,530
0,210 210,330 330,600 600,840 840,1500
even a single user machine

31
00:00:49,560 --> 00:00:51,040
0,150 150,300 300,420 420,1110
or even your iPhone,|

32
00:00:51,040 --> 00:00:52,510
0,630 660,810 810,960 960,1200 1200,1470
{} you may run many

33
00:00:52,510 --> 00:00:54,370
0,330 330,930 930,1110 1200,1770 1770,1860
different processes| and expect the

34
00:00:54,370 --> 00:00:55,810
0,420 420,750 870,1170 1170,1350 1350,1440
computer to do all the

35
00:00:55,810 --> 00:00:56,680
0,240 240,360 360,630 630,720 720,870
things you ask of it,|

36
00:00:56,680 --> 00:00:57,980
0,210 210,360 360,570 570,810
not just one thing.|

37
00:00:58,360 --> 00:00:59,680
0,390

38
00:01:00,260 --> 00:01:02,450
0,480 480,1050 1050,1170 1170,1680 1860,2190
Another reason that people like

39
00:01:02,450 --> 00:01:03,860
0,90 90,420 420,780 780,1230 1230,1410
to support multiple tasks is|

40
00:01:03,860 --> 00:01:05,630
0,480 540,780 780,1020 1020,1260 1260,1770
because it can ease program

41
00:01:05,630 --> 00:01:08,090
0,720 840,1470 1470,1560 1560,2100 2100,2460
structure,| threads in particular today's

42
00:01:08,090 --> 00:01:10,520
0,600 720,1380 1380,1620 1620,2160 2160,2430
topic,| {} are sometimes used

43
00:01:10,520 --> 00:01:11,510
0,120 120,210 210,540 540,690 690,990
as a way| to help

44
00:01:11,510 --> 00:01:14,030
0,420 420,510 510,720 720,1830 1920,2520
people, to help programmers put

45
00:01:14,030 --> 00:01:15,320
0,300 300,390 390,900 900,1110 1110,1290
together a program in a

46
00:01:15,320 --> 00:01:16,970
0,210 210,300 300,870 870,1290 1290,1650
sort of simple elegant way,|

47
00:01:17,000 --> 00:01:18,650
0,120 120,420 420,1140 1290,1560 1560,1650
to reduce complexity,| and you

48
00:01:18,650 --> 00:01:19,670
0,210 210,390 390,480 480,960 960,1020
actually saw an example of

49
00:01:19,670 --> 00:01:20,780
0,240 240,330 330,420 420,720 720,1110
this in the first lab

50
00:01:20,780 --> 00:01:22,010
0,120 120,210 210,510 510,810 810,1230
with the prime number sieve,|

51
00:01:22,010 --> 00:01:24,350
0,390 570,1440 1440,1620 1620,1920 1920,2340
which didn't use threads exactly

52
00:01:24,350 --> 00:01:26,240
0,120 120,420 420,810 810,1710 1710,1890
but use multiple processes,| in

53
00:01:26,240 --> 00:01:28,220
0,210 210,300 300,660 660,1380 1620,1980
order to help structure {}

54
00:01:28,220 --> 00:01:29,840
0,600 690,960 960,1080 1080,1350 1350,1620
this {} your prime number

55
00:01:29,840 --> 00:01:31,370
0,360 360,750 750,840 840,1380 1380,1530
sieve software| and arguably it's

56
00:01:31,370 --> 00:01:33,620
0,180 180,240 240,330 330,1020 1710,2250
sort of a more convenient

57
00:01:33,620 --> 00:01:34,850
0,60 60,510 510,570 570,960 960,1230
or elegant or simpler way|

58
00:01:34,850 --> 00:01:35,500
0,330
to

59
00:01:35,590 --> 00:01:36,850
0,180 180,360 360,540 540,720 720,1260
{} to write that software.|

60
00:01:37,620 --> 00:01:39,150
0,300 480,690 690,1020 1020,1320 1320,1530
And the final reason why

61
00:01:39,150 --> 00:01:41,340
0,330 330,540 540,1260 1260,1770 1770,2190
people use threads is,| to

62
00:01:41,610 --> 00:01:43,500
0,360 360,900 900,1410 1410,1620 1620,1890
get parallel speedup from multi

63
00:01:43,500 --> 00:01:46,170
0,210 210,960 1200,1710 1950,2190 2190,2670
core machines,| so it's common

64
00:01:46,170 --> 00:01:48,120
0,330 510,960 960,1110 1110,1230 1230,1950
to break up your program

65
00:01:48,120 --> 00:01:49,410
0,90 90,180 180,450 450,660 690,1290
in a way,| that {}

66
00:01:49,890 --> 00:01:52,320
0,390 390,1140 1140,1590 1680,2070 2070,2430
using threads to allow different

67
00:01:52,320 --> 00:01:53,730
0,510 510,630 630,690 690,930 930,1410
parts of the same program

68
00:01:53,730 --> 00:01:55,110
0,120 120,270 270,420 420,690 690,1380
to run on different cores,|

69
00:01:55,110 --> 00:01:56,940
0,240 330,660 660,780 780,1050 1260,1830
and if you can maybe

70
00:01:56,940 --> 00:01:57,840
0,120 120,240 240,660 660,780 780,900
if you're lucky,| if you

71
00:01:57,840 --> 00:01:59,370
0,300 390,870 870,990 990,1380 1380,1530
can split your program up

72
00:01:59,370 --> 00:02:00,720
0,90 90,390 390,660 690,1020 1020,1350
to run on four threads

73
00:02:00,720 --> 00:02:02,160
0,150 150,390 390,990 1020,1290 1290,1440
on four cores,| you might

74
00:02:02,160 --> 00:02:02,760
0,120 120,270 270,360 360,510 510,600
be able to get a

75
00:02:02,760 --> 00:02:04,170
0,390 390,480 480,780 780,1170 1170,1410
factor of four speed up

76
00:02:04,170 --> 00:02:05,720
0,180 180,540 540,660 660,1200
how fast it runs.|

77
00:02:05,720 --> 00:02:06,660
0,390

78
00:02:06,780 --> 00:02:07,740
0,210 210,510 510,630 630,750 750,960
And indeed, you can view

79
00:02:07,740 --> 00:02:09,930
0,90 90,600 600,1080 1080,1590 1890,2190
the xv6 kernel as a

80
00:02:09,930 --> 00:02:12,520
0,480 480,900 900,1380 1380,1920
multi core parallel program.|

81
00:02:12,700 --> 00:02:15,370
0,450 1350,1590 1590,1980 1980,2370 2370,2670
So what threads are, is

82
00:02:15,370 --> 00:02:18,760
0,120 120,1110 1260,1740 1830,2430 2430,3390
an abstraction to simplify programming,|

83
00:02:18,940 --> 00:02:20,080
0,330 330,570 570,690 690,810 810,1140
{} when you have many

84
00:02:20,080 --> 00:02:21,130
0,570 570,720 720,810 810,960 960,1050
tasks,| when you want to

85
00:02:21,130 --> 00:02:23,380
0,330 330,660 660,1470 1500,1950 1980,2250
juggle many tasks,| so what

86
00:02:23,380 --> 00:02:24,430
0,30 30,360 360,630 630,840 840,1050
a thread is is {},|

87
00:02:24,670 --> 00:02:25,510
0,330 330,450 450,570 570,780 780,840
{} you can think of

88
00:02:25,510 --> 00:02:26,830
0,90 90,540 540,840 840,1080 1080,1320
a thread as just being

89
00:02:26,860 --> 00:02:29,080
0,210 210,780 780,1470 1470,2100 2100,2220
a single serial execution,| if

90
00:02:29,080 --> 00:02:30,040
0,90 90,300 300,510 510,570 570,960
you just write a program

91
00:02:30,040 --> 00:02:30,970
0,90 90,240 240,450 450,630 630,930
that does one thing after

92
00:02:30,970 --> 00:02:31,960
0,420 420,540 540,630 630,810 810,990
another,| and you run that

93
00:02:31,960 --> 00:02:34,360
0,600 870,1500 1590,2040 2160,2310 2310,2400
program,| {} that you know

94
00:02:34,360 --> 00:02:35,260
0,210 210,300 300,480 480,570 570,900
you can view the program

95
00:02:35,260 --> 00:02:36,280
0,120 120,180 180,360 360,450 450,1020
as a sort of single

96
00:02:36,280 --> 00:02:37,920
0,420 420,510 510,1290
thread of control.|

97
00:02:38,290 --> 00:02:40,630
0,540 1050,1650 1830,2160 2160,2280 2280,2340
So, {} this is a

98
00:02:40,630 --> 00:02:42,440
0,360 360,1200
loose definition.|

99
00:02:44,160 --> 00:02:45,930
0,390 390,540 540,780 780,1200 1560,1770
Because there's many different sort

100
00:02:45,930 --> 00:02:46,980
0,90 90,630 630,690 690,810 810,1050
of flavors of what people

101
00:02:46,980 --> 00:02:49,440
0,150 150,300 300,810 810,1140 2190,2460
mean by threads,| but we'll

102
00:02:49,440 --> 00:02:52,110
0,150 150,270 270,1260 1620,1920 1920,2670
say it's one {} serial

103
00:02:52,110 --> 00:02:54,270
0,810 1140,1560 1590,1830 1830,2010 2010,2160
execution,| so it's what you

104
00:02:54,270 --> 00:02:56,740
0,330 330,570 570,1020 1110,1950
get if you {}

105
00:02:56,800 --> 00:02:59,080
0,600 600,690 690,1410 1440,2190 2190,2280
fire up one CPU and

106
00:02:59,080 --> 00:03:00,520
0,360 420,660 660,870 870,1290 1290,1440
{have,it},| {you,know} just execute one

107
00:03:00,520 --> 00:03:01,750
0,450 450,720 720,1050 1050,1140 1140,1230
instruction after another in the

108
00:03:01,750 --> 00:03:03,340
0,450 450,810
ordinary way.|

109
00:03:04,270 --> 00:03:05,460
0,570

110
00:03:05,580 --> 00:03:06,540
0,240 240,510 510,720 720,900 900,960
We often talk about {}

111
00:03:06,540 --> 00:03:08,130
0,270 270,480 480,1230 1260,1470 1470,1590
thread having state,| because it's

112
00:03:08,130 --> 00:03:08,940
0,150 150,210 210,450 450,690 690,810
going to turn out,| we're

113
00:03:08,940 --> 00:03:09,720
0,150 150,240 240,390 390,450 450,780
going to want to save

114
00:03:09,720 --> 00:03:10,950
0,300 300,390 390,690 690,1110 1110,1230
away {} thread state| and

115
00:03:10,950 --> 00:03:13,890
0,330 330,420 420,810 1830,2400 2430,2940
restore it later,| and so

116
00:03:14,190 --> 00:03:14,880
0,240 240,390 390,480 480,570 570,690
the right way to think

117
00:03:14,880 --> 00:03:15,720
0,150 150,210 210,450 450,750 750,840
about {} thread state,| for

118
00:03:15,720 --> 00:03:17,310
0,150 180,480 480,900 1020,1470 1470,1590
the most part {} the

119
00:03:17,310 --> 00:03:19,110
0,180 180,1020 1020,1410 1410,1740 1740,1800
most important part,| perhaps of

120
00:03:19,110 --> 00:03:20,160
0,60 60,360 360,750 750,870 870,1050
the thread state is its

121
00:03:20,160 --> 00:03:22,170
0,480 480,960 1260,1740 1740,1890 1890,2010
program counter,| because it's an

122
00:03:22,170 --> 00:03:23,430
0,660 660,750 750,960 960,1020 1020,1260
execution, we care a lot

123
00:03:23,430 --> 00:03:24,690
0,240 240,630 630,780 780,1110 1140,1260
about where is it in

124
00:03:24,690 --> 00:03:26,490
0,120 120,840 1020,1260 1260,1410 1410,1800
its execution| and what address

125
00:03:26,490 --> 00:03:29,220
0,150 150,300 300,750 750,1470 2520,2730
is it executing instructions,| but

126
00:03:29,220 --> 00:03:30,160
0,480
also

127
00:03:30,360 --> 00:03:31,560
0,300 300,480 480,720 720,930 930,1200
we care about the rest

128
00:03:31,560 --> 00:03:33,090
0,90 90,150 150,960 960,1350 1350,1530
of the microprocessor state,| that's

129
00:03:33,090 --> 00:03:34,860
0,390 390,480 480,960 960,1110 1110,1770
required to support this execution|

130
00:03:35,100 --> 00:03:36,300
0,270 270,420 420,600 600,810 810,1200
and so that means it's.|

131
00:03:38,520 --> 00:03:39,690
0,240 270,810 810,870 870,930 930,1170
The state of a thread

132
00:03:39,690 --> 00:03:41,130
0,330 330,450 450,1260 1260,1380 1380,1440
includes the registers that the

133
00:03:41,130 --> 00:03:42,960
0,450 450,750 750,840 840,1110 1110,1830
compiler uses to hold variables|

134
00:03:43,200 --> 00:03:45,240
0,390 390,720 720,1140 1140,1410 1770,2040
and also because the just

135
00:03:45,240 --> 00:03:46,290
0,90 90,180 180,270 270,630 630,1050
the way the compiler generates

136
00:03:46,290 --> 00:03:48,480
0,780 840,1140 1140,1410 1410,1830 1830,2190
code,| {} thread state includes

137
00:03:48,480 --> 00:03:49,760
0,60 60,720
a stack,|

138
00:03:49,970 --> 00:03:51,890
0,270 270,600 1110,1410 1410,1620 1650,1920
{} so typically if each

139
00:03:51,890 --> 00:03:53,150
0,300 300,480 480,630 630,900 900,1260
thread has its own stack|

140
00:03:53,150 --> 00:03:54,770
0,540 540,600 600,1050 1050,1230 1230,1620
dedicated to executing that {thread,and}

141
00:03:54,770 --> 00:03:56,810
0,90 90,510 510,1320 1500,1710 1710,2040
the stack records,| the record

142
00:03:56,810 --> 00:03:59,180
0,90 90,480 480,1320
of function calls,|

143
00:03:59,960 --> 00:04:01,910
0,210 210,480 480,840 1200,1860 1860,1950
{} that the reflect the

144
00:04:01,910 --> 00:04:03,290
0,330 330,630 630,720 720,780 780,1380
current point in the execution

145
00:04:03,290 --> 00:04:05,060
0,390 480,780 780,1200
of that thread.|

146
00:04:05,630 --> 00:04:06,650
0,210 210,330 330,450 450,540 540,1020
And so what a threading

147
00:04:06,650 --> 00:04:08,570
0,420 420,690 690,810 810,1020 1020,1920
system {xv6 - -} includes

148
00:04:08,780 --> 00:04:10,130
0,210 210,540 540,840 840,1200 1200,1350
a threading system inside it,|

149
00:04:10,160 --> 00:04:11,510
0,360 360,420 420,720 720,1050 1050,1350
what a threading system does|

150
00:04:11,510 --> 00:04:15,380
0,210 270,1080 1080,1890 1950,3210 3240,3870
is manage this interleave, automate

151
00:04:15,380 --> 00:04:18,200
0,120 120,1170 1170,1380 1380,1890 1890,2820
the interleaving of multiple threads,|

152
00:04:18,410 --> 00:04:18,980
0,210 210,300 300,450 450,510 510,570
you would like to be

153
00:04:18,980 --> 00:04:20,600
0,150 150,240 240,630 630,870 1140,1620
able to fire up two

154
00:04:20,600 --> 00:04:22,400
0,450 450,1230 1230,1320 1320,1380 1380,1800
or 400 or a thousand

155
00:04:22,400 --> 00:04:23,960
0,420 420,540 540,870 1020,1260 1260,1560
threads| and {} the threading

156
00:04:23,960 --> 00:04:26,720
0,1140 1170,1800 1800,2100 2100,2310 2310,2760
system figure out how to

157
00:04:27,120 --> 00:04:28,380
0,270 270,600 600,720 720,930 930,1260
{} juggle all those threads|

158
00:04:28,380 --> 00:04:29,070
0,90 90,360 360,480 480,630 630,690
and cause them all to

159
00:04:29,070 --> 00:04:30,270
0,180 180,690 690,900 900,1080 1080,1200
make progress and all to

160
00:04:30,270 --> 00:04:31,340
0,510
execute.|

161
00:04:32,030 --> 00:04:35,930
0,480 1710,2040 2040,2460 2730,3360 3570,3900
{} There's really {} two

162
00:04:35,930 --> 00:04:37,280
0,300 300,990 990,1140 1140,1200 1200,1350
main strategy,| so we want

163
00:04:37,280 --> 00:04:38,980
0,60 60,1110
to interleave,|

164
00:04:39,210 --> 00:04:40,650
0,570 630,810 810,900 900,1140 1140,1440
{} this is gonna be

165
00:04:40,650 --> 00:04:41,580
0,300
{}

166
00:04:42,620 --> 00:04:43,700
0,210 210,570 570,810 810,960 960,1080
big topic,| here's how to

167
00:04:43,700 --> 00:04:48,170
0,420 420,1290 1710,2310 2310,3090 3540,4470
interleave threads, many threads,| one

168
00:04:48,170 --> 00:04:49,340
0,150 150,270 270,720 720,780 780,1170
way to interleave the execution

169
00:04:49,340 --> 00:04:50,180
0,60 60,270 270,660 660,750 750,840
of many threads| is to

170
00:04:50,180 --> 00:04:53,200
0,120 120,540 540,1200 1200,1740
have multiple {CPUs -}.|

171
00:04:55,070 --> 00:04:56,960
0,360 360,990 1110,1530 1530,1590 1590,1890
Maybe as on a multi

172
00:04:56,960 --> 00:04:59,390
0,240 240,930 1530,1740 1740,1980 2010,2430
core processor| and then each

173
00:04:59,390 --> 00:05:00,470
0,480 480,660 660,840 840,960 960,1080
CPU can run its own

174
00:05:00,470 --> 00:05:01,190
0,300 300,420 420,540 540,600 600,720
thread,| so if you have

175
00:05:01,190 --> 00:05:02,660
0,210 210,780 780,960 1140,1410 1410,1470
four CPUs,| {} there's an

176
00:05:02,660 --> 00:05:05,120
0,540 540,720 720,840 840,1290 2070,2460
obvious way to run four

177
00:05:05,120 --> 00:05:06,140
0,420 420,510 510,600 600,780 780,1020
threads,| is to run one

178
00:05:06,140 --> 00:05:07,310
0,270 270,360 360,930 930,1020 1020,1170
thread per CPU,| and then

179
00:05:07,310 --> 00:05:08,840
0,210 210,540 540,1140 1140,1380 1380,1530
each thread automatically gets its

180
00:05:08,840 --> 00:05:11,180
0,360 510,1170 1170,1530 1530,2190 2190,2340
own program counter registers,| that

181
00:05:11,180 --> 00:05:12,800
0,480 510,630 630,930 930,1200 1200,1620
is the program counter register

182
00:05:12,800 --> 00:05:14,690
0,60 60,570 570,900 1260,1470 1470,1890
is associated with the CPU

183
00:05:14,690 --> 00:05:16,010
0,120 120,390 390,630 990,1260 1260,1320
is running on,| but if

184
00:05:16,010 --> 00:05:17,120
0,60 60,180 180,360 360,990 990,1110
you have four CPUs and

185
00:05:17,120 --> 00:05:18,440
0,60 60,150 150,210 210,660 660,1320
you have a thousand threads,|

186
00:05:18,590 --> 00:05:20,860
0,1350
then

187
00:05:20,860 --> 00:05:22,660
0,420 930,1170 1170,1230 1230,1410 1410,1800
{} you know how using

188
00:05:22,660 --> 00:05:24,580
0,270 270,600 600,1170 1170,1650 1710,1920
one corporate thread,| {} is

189
00:05:24,580 --> 00:05:25,570
0,180 180,300 300,390 390,690 720,990
not going to be enough

190
00:05:25,570 --> 00:05:27,040
0,120 120,240 240,750 960,1110 1110,1470
of an answer.| And so

191
00:05:27,040 --> 00:05:29,080
0,240 270,600 600,1170 1200,1890 1890,2040
the other main strategy that

192
00:05:29,080 --> 00:05:30,300
0,120 120,660
we'll see,|

193
00:05:30,620 --> 00:05:31,760
0,360 360,570
indeed the

194
00:05:31,760 --> 00:05:33,170
0,510 510,690 690,1200 1200,1260 1260,1410
topic of most of this

195
00:05:33,170 --> 00:05:36,350
0,450 660,1110 1140,1860 1890,2160 2160,3180
lecture| is how each CPU

196
00:05:36,410 --> 00:05:39,050
0,240 240,360 360,450 450,1590 1830,2640
is going to switch among

197
00:05:39,050 --> 00:05:41,780
0,420 1320,2310 2340,2550 2550,2670 2670,2730
different threads,| so if I

198
00:05:41,780 --> 00:05:42,590
0,90 90,270 270,690 690,780 780,810
have one CPU and a

199
00:05:42,590 --> 00:05:44,900
0,390 390,990 1080,2040 2070,2220 2220,2310
thousand threads,| we're going to

200
00:05:44,900 --> 00:05:47,210
0,300 300,420 420,1050 1050,1740 1740,2310
see how xv6 builds switching

201
00:05:47,210 --> 00:05:48,950
0,600 840,1050 1050,1350 1350,1560 1560,1740
system,| that allows {xv6 -}

202
00:05:48,950 --> 00:05:49,820
0,60 60,210 210,450 450,720 720,870
to run one thread for

203
00:05:49,820 --> 00:05:51,350
0,30 30,480 480,570 570,750 750,1530
a while| and then switch

204
00:05:51,380 --> 00:05:52,850
0,150 150,540 540,960 960,1080 1080,1470
and set aside| and save

205
00:05:52,850 --> 00:05:53,600
0,90 90,360 360,420 420,570 570,750
the state of that one

206
00:05:53,600 --> 00:05:55,460
0,300 300,450 540,1050 1050,1170 1170,1860
thread| and switch to executing

207
00:05:55,460 --> 00:05:56,240
0,150 150,420 420,660 660,750 750,780
a second thread for a

208
00:05:56,240 --> 00:05:57,140
0,300 300,420 420,570 570,630 630,900
while| and then a third

209
00:05:57,140 --> 00:05:58,190
0,270 270,390 390,600 600,810 810,1050
thread and so forth,| until

210
00:05:58,190 --> 00:05:59,510
0,210 330,930 930,990 990,1200 1200,1320
it's executed a little bit

211
00:05:59,510 --> 00:06:00,500
0,60 60,270 270,570 570,660 660,990
of each thread,| and then

212
00:06:00,740 --> 00:06:02,570
0,450 450,690 690,930 960,1350 1350,1830
go back and execute more

213
00:06:02,570 --> 00:06:03,590
0,120 120,480 540,660 660,750 750,1020
of the of the first

214
00:06:03,590 --> 00:06:04,660
0,210 210,330 330,540 540,750
thread and so on.|

215
00:06:05,030 --> 00:06:06,080
0,510

216
00:06:06,170 --> 00:06:07,490
0,180 180,210 210,510 510,930 930,1320
And {indeed -}, {xv6 -}

217
00:06:07,520 --> 00:06:09,290
0,330 330,570 570,870 870,1170 1170,1770
like most operating system,| combines

218
00:06:09,290 --> 00:06:11,300
0,210 210,570 570,990 1290,1620 1620,2010
the {xv6 -} will run

219
00:06:11,390 --> 00:06:12,920
0,630 630,840 840,1080 1080,1170 1170,1530
threads on all the cores

220
00:06:12,920 --> 00:06:13,910
0,150 150,210 210,720 720,810 810,990
that are available| and each

221
00:06:13,910 --> 00:06:16,820
0,360 360,600 600,1380 1740,2250 2250,2910
core will switch among threads,|

222
00:06:17,030 --> 00:06:18,590
0,270 270,420 420,750 750,990 1020,1560
because there's typical {},| typically

223
00:06:18,830 --> 00:06:20,300
0,270 270,510 510,930 930,1080 1080,1470
although not always there's typically

224
00:06:20,300 --> 00:06:21,500
0,210 210,390 390,960 960,1110 1110,1200
many more threads than there

225
00:06:21,500 --> 00:06:23,440
0,390 570,1140 1140,1530
are {CPUs -}.|

226
00:06:23,440 --> 00:06:24,480
0,450

227
00:06:24,780 --> 00:06:27,900
0,1230 1230,2340 2580,2760 2760,2850 2850,3120
One {} of the many

228
00:06:27,900 --> 00:06:29,700
0,420 420,510 510,990 1020,1320 1320,1800
ways in which a different

229
00:06:29,970 --> 00:06:32,070
0,450 450,1320 1350,1500 1500,2010 2010,2100
threading systems| or instances of

230
00:06:32,070 --> 00:06:34,020
0,360 360,1020 1020,1500 1590,1860 1860,1950
threading systems differ is in

231
00:06:34,020 --> 00:06:35,010
0,240 240,300 300,480 480,600 600,990
whether or not they share

232
00:06:35,010 --> 00:06:36,960
0,570
memory.|

233
00:06:36,960 --> 00:06:38,400
0,180 180,330 330,510 510,840
So this is {}

234
00:06:39,590 --> 00:06:42,000
0,870 1230,1890
important {}

235
00:06:42,760 --> 00:06:45,040
0,600 1080,1620
point {}.|

236
00:06:45,040 --> 00:06:46,930
0,420 420,1140 1140,1260 1260,1500 1560,1890
One possibility is that you

237
00:06:46,930 --> 00:06:48,040
0,90 90,300 300,390 390,810 810,1110
could have a single address

238
00:06:48,040 --> 00:06:50,050
0,600 630,780 780,1080 1080,1410 1410,2010
space with many threads executing

239
00:06:50,050 --> 00:06:51,040
0,60 60,240 240,510 510,870 870,990
in that address space| and

240
00:06:51,040 --> 00:06:51,970
0,120 120,240 240,510 510,660 660,930
then they see each other's

241
00:06:51,970 --> 00:06:53,920
0,840 1020,1230 1230,1410 1410,1620 1620,1950
changes,| if one of the

242
00:06:54,340 --> 00:06:56,290
0,420 420,960 960,1110 1110,1440 1440,1950
threads sharing some memory modifies

243
00:06:56,290 --> 00:06:57,730
0,150 150,660 660,990 1020,1290 1290,1440
{} variable,| then the other

244
00:06:57,730 --> 00:06:58,750
0,210 210,450 450,600 600,900 900,1020
thread sharing that memory will

245
00:06:58,750 --> 00:07:01,280
0,210 210,300 300,1020
see the modification.|

246
00:07:01,430 --> 00:07:02,000
0,210 210,330 330,450 450,510 510,570
And so it's in the

247
00:07:02,000 --> 00:07:03,440
0,510 510,600 600,930 930,1200 1200,1440
context of threads running| and

248
00:07:03,590 --> 00:07:04,880
0,600 600,930 930,1050 1050,1140 1140,1290
sharing memory that we need

249
00:07:04,880 --> 00:07:06,410
0,180 180,450 450,600 600,1200 1200,1530
things like the locks| that

250
00:07:06,890 --> 00:07:08,030
0,390 390,630 630,720 720,810 810,1140
you saw in the last

251
00:07:08,030 --> 00:07:09,760
0,360
lecture.|

252
00:07:10,330 --> 00:07:12,880
0,570 570,1140 1140,2010 2040,2220 2220,2550
{Xv6 -} kernel is shared

253
00:07:12,880 --> 00:07:14,590
0,630 870,1200 1200,1410 1410,1590 1590,1710
memory,| {} so {xv6 -

254
00:07:14,590 --> 00:07:15,700
0,600
-}

255
00:07:15,760 --> 00:07:18,340
0,390 420,720 720,1080 1410,1890
{} there's a {},

256
00:07:18,340 --> 00:07:19,480
0,480 480,540 540,750 750,810 810,1140
supports the notion of kernel

257
00:07:19,480 --> 00:07:21,010
0,330 330,480 480,660 660,990 990,1530
threads,| there's one kernel thread

258
00:07:21,160 --> 00:07:23,620
0,840 870,1470 1470,1620 1620,2130 2130,2460
per process that executes system

259
00:07:23,620 --> 00:07:25,060
0,300 300,390 390,540 540,1050 1200,1440
calls for that process,| all

260
00:07:25,060 --> 00:07:26,890
0,180 180,450 450,780 780,1440 1440,1830
those kernel threads share kernel

261
00:07:26,890 --> 00:07:29,890
0,630 1350,1710 1830,2460 2460,2730 2730,3000
memory,| so xv6 kernel threads

262
00:07:29,890 --> 00:07:32,080
0,180 180,420 420,840
do share memory.|

263
00:07:34,400 --> 00:07:35,900
0,930
And,

264
00:07:36,690 --> 00:07:37,500
0,330 330,450 450,510 510,660 660,810
{} on the other hand

265
00:07:37,650 --> 00:07:39,090
0,750 750,930 930,1170 1170,1350 1350,1440
xv6,| that's another kind of

266
00:07:39,090 --> 00:07:41,610
0,330 330,600 600,930 930,1770 1860,2520
threads, each user process essentially

267
00:07:41,610 --> 00:07:42,510
0,180 180,240 240,570 570,810 810,900
has a single thread of

268
00:07:42,510 --> 00:07:44,130
0,510 510,660 660,1170 1170,1260 1260,1620
control,| that executes the user

269
00:07:44,130 --> 00:07:46,560
0,660 660,750 750,960 960,1740 1950,2430
instructions for that process,| and

270
00:07:46,650 --> 00:07:47,700
0,420 420,480 480,690 690,780 780,1050
indeed a lot of the

271
00:07:48,210 --> 00:07:50,280
0,390 390,630 630,1290 1320,1710 1710,2070
{} {xv6 -} kernel threading

272
00:07:50,280 --> 00:07:52,470
0,780 780,990 990,1560 1560,1680 1680,2190
machinery| is ultimately in support

273
00:07:52,470 --> 00:07:54,330
0,270 360,600 600,780 780,1200 1320,1860
of being able to support

274
00:07:54,330 --> 00:07:55,950
0,150 150,510 510,660 660,1080 1200,1620
and switch them on many

275
00:07:55,950 --> 00:07:58,050
0,270 270,990 1020,1260 1260,1500 1500,2100
user processes,| each user process

276
00:07:58,170 --> 00:07:59,190
0,330 330,360 360,840 840,960 960,1020
has a memory and a

277
00:07:59,190 --> 00:08:00,450
0,570 570,840 840,960 960,1200 1200,1260
single thread that runs in

278
00:08:00,450 --> 00:08:04,040
0,180 180,630 840,1350 1440,2640
that memory,| so xv6

279
00:08:04,040 --> 00:08:06,300
0,510 510,1710
user processes,|

280
00:08:11,160 --> 00:08:13,110
0,240 240,1110 1140,1290 1290,1560 1560,1950
each process has one thread|

281
00:08:13,110 --> 00:08:15,390
0,120 120,390 420,750 750,1380 1440,2280
and so there's no sharing

282
00:08:15,390 --> 00:08:18,840
0,90 90,510 510,1080 1080,2010 2640,3450
of memory among threads| within

283
00:08:18,840 --> 00:08:20,520
0,180 180,570 570,1020 1020,1260 1260,1680
a single xv6 user process,|

284
00:08:20,520 --> 00:08:21,240
0,60 60,210 210,270 270,390 390,720
{because -} you get multiple

285
00:08:21,240 --> 00:08:22,860
0,600 600,810 1170,1410 1410,1470 1470,1620
processes,| but each of those

286
00:08:22,860 --> 00:08:24,660
0,840 870,990 990,1080 1080,1410 1410,1800
processes is an address space

287
00:08:24,660 --> 00:08:27,870
0,240 240,300 300,600 600,1110 2340,3210
with a single thread processes,|

288
00:08:27,900 --> 00:08:29,310
0,150 150,600 600,780 780,960 960,1410
in xv6, don't share memory.|

289
00:08:29,790 --> 00:08:31,920
0,300 300,600 600,810 810,1620 1650,2130
In other more sophisticated operating

290
00:08:31,920 --> 00:08:34,880
0,480 480,600 600,900 900,1590
systems,| for example Linux,|

291
00:08:35,110 --> 00:08:38,260
0,600 600,930 930,1440 1860,2520
Linux user level {}

292
00:08:38,260 --> 00:08:41,710
0,510 510,1380 2070,2850 2850,3360 3360,3450
does allow multiple threads in

293
00:08:41,710 --> 00:08:43,180
0,60 60,600 600,720 720,780 780,1470
a process| and the processes

294
00:08:43,180 --> 00:08:44,830
0,120 120,360 360,960 990,1590 1590,1650
and those threads share the

295
00:08:44,830 --> 00:08:46,750
0,480 480,810 810,1020 1020,1290 1290,1920
memory of that single process|

296
00:08:47,380 --> 00:08:48,310
0,180 180,360 360,600 600,870 870,930
and that's super cool if

297
00:08:48,310 --> 00:08:49,000
0,90 90,210 210,270 270,450 450,690
you want to write user

298
00:08:49,000 --> 00:08:51,610
0,240 240,780 780,930 1800,2400 2400,2610
level programs| that use level

299
00:08:51,610 --> 00:08:53,890
0,480 480,1110 1110,1290 1440,1860 1860,2280
parallel programs that get {speed,up}

300
00:08:53,890 --> 00:08:55,540
0,120 120,450 450,1050 1170,1470 1470,1650
from multiple cores| {} better

301
00:08:55,540 --> 00:08:56,980
0,360 360,510 510,570 570,1110 1230,1440
requires sort of another,| it

302
00:08:57,250 --> 00:08:58,360
0,600 600,840 840,990 990,1050 1050,1110
uses a lot of the

303
00:08:58,360 --> 00:08:59,500
0,210 210,510 510,930 930,1020 1020,1140
same basic techniques,| we're going

304
00:08:59,500 --> 00:09:00,790
0,270 300,510 510,720 720,1080 1080,1290
to talk about today,| but

305
00:09:01,000 --> 00:09:02,260
0,300 300,570 570,690 690,1050 1050,1260
{} there's a certain amount

306
00:09:02,260 --> 00:09:03,910
0,150 150,840 840,960 960,1530 1530,1650
more sophistication in Linux| to

307
00:09:03,910 --> 00:09:05,000
0,150 150,480
get it

308
00:09:05,000 --> 00:09:06,200
0,240 240,480 480,750 750,840 840,1200
{} keep track of multiple

309
00:09:06,200 --> 00:09:08,060
0,480 480,810 810,1530 1560,1800 1800,1860
threads per process instead of

310
00:09:08,060 --> 00:09:09,200
0,210 210,540
just one.|

311
00:09:12,250 --> 00:09:14,320
0,420 420,930 1170,1500 1500,1860 1860,2070
Okay, I'm at a sort

312
00:09:14,320 --> 00:09:15,220
0,60 60,240 240,630 630,720 720,900
of high level I just

313
00:09:15,220 --> 00:09:16,780
0,120 120,180 180,750 750,1080 1080,1560
want to mention that there's

314
00:09:16,810 --> 00:09:19,270
0,300 300,1080 1080,1320 1320,2280 2310,2460
other ways to support the

315
00:09:19,270 --> 00:09:21,160
0,660 660,750 750,1170 1170,1770 1770,1890
interviewing of multiple tasks on

316
00:09:21,160 --> 00:09:23,350
0,30 30,390 390,990 1350,1740 1950,2190
a single computer a and

317
00:09:23,350 --> 00:09:23,980
0,90 90,210 210,330 330,390 390,630
we're not going to talk

318
00:09:23,980 --> 00:09:25,990
0,270 270,960 1050,1320 1320,1410 1410,2010
about them, if you're curious

319
00:09:26,020 --> 00:09:27,280
0,450 450,600 600,780 780,1020 1020,1260
you can look up things

320
00:09:27,280 --> 00:09:29,530
0,240 270,600 600,930 930,1740 1740,2250
like event driven programming or

321
00:09:29,560 --> 00:09:32,350
0,540 540,1350 1500,1980 2250,2670 2670,2790
state machines and these are

322
00:09:32,350 --> 00:09:34,690
0,420 420,810 810,1680 1710,2010 2010,2340
non thread techniques to share

323
00:09:34,690 --> 00:09:36,730
0,420 420,870 870,1350 1380,1740 1740,2040
one computer among many different

324
00:09:36,730 --> 00:09:39,400
0,630 750,990 990,1230 1230,1560 2490,2670
tasks, it turns out you

325
00:09:39,400 --> 00:09:40,510
0,210 210,420 420,630 630,810 810,1110
know sort of on the

326
00:09:40,750 --> 00:09:43,060
0,720 720,930 930,1380 1380,1980 1980,2310
spectrum of different schemes for

327
00:09:43,090 --> 00:09:44,290
0,390 390,720 720,1050 1050,1140 1140,1200
supporting multiple tasks on a

328
00:09:44,290 --> 00:09:45,940
0,480 570,930 930,1050 1050,1440 1440,1650
computer threads are not very

329
00:09:45,940 --> 00:09:47,500
0,630 660,840 840,990 990,1200 1200,1560
efficient, there's a more efficient

330
00:09:47,500 --> 00:09:50,080
0,630 1200,1590 1590,1890 1890,2010 2010,2580
schemes but threads are usually

331
00:09:50,080 --> 00:09:52,060
0,90 90,390 390,930 930,1590 1620,1980
the most convenient way most

332
00:09:52,060 --> 00:09:54,670
0,510 510,900 900,1440 1620,2400 2460,2610
programmer friendly way, um to

333
00:09:54,670 --> 00:09:57,220
0,360 360,660 660,1080 1410,1770 1770,2550
support lots of different tasks.

334
00:09:59,770 --> 00:10:01,580
0,480 660,1230
Okay, I'm.

335
00:10:02,030 --> 00:10:03,710
0,240 240,330 330,720 720,1080 1260,1680
There's a couple of um

336
00:10:03,860 --> 00:10:04,970
0,750 750,840 840,900 900,1020 1020,1110
challenges that we're gonna have

337
00:10:04,970 --> 00:10:06,140
0,90 90,390 390,870 900,1050 1050,1170
to bite off if we

338
00:10:06,140 --> 00:10:07,880
0,180 180,360 420,1200 1230,1350 1350,1740
want to implement a threading

339
00:10:07,880 --> 00:10:09,000
0,540
system.

340
00:10:09,790 --> 00:10:11,220
0,570
HMM.

341
00:10:12,590 --> 00:10:14,390
0,690 1050,1230 1230,1410 1410,1500 1500,1800
The so this is just

342
00:10:14,390 --> 00:10:16,320
0,240 240,480 480,1410
high level challenges.

343
00:10:21,110 --> 00:10:22,360
0,630
I'm.

344
00:10:22,880 --> 00:10:23,960
0,390 390,570 570,720 720,780 780,1080
One is as I mentioned

345
00:10:23,960 --> 00:10:26,240
0,390 390,600 600,690 690,1350 1860,2280
before, how to actually implement

346
00:10:26,240 --> 00:10:27,760
0,90 90,960
the switching.

347
00:10:27,930 --> 00:10:30,020
0,240 240,480 480,780 870,1500
For inter league, um.

348
00:10:30,170 --> 00:10:31,490
0,150 150,570 570,690 690,1110 1110,1320
The switching that allows us

349
00:10:31,490 --> 00:10:33,700
0,240 360,1650
to interleave.

350
00:10:35,140 --> 00:10:37,030
0,180 180,870 870,960 960,1350 1350,1890
The execution of multiple threads,

351
00:10:37,570 --> 00:10:40,560
0,420 540,810 810,1440 1560,2250
um, and this um.

352
00:10:40,560 --> 00:10:41,670
0,210 210,270 270,690 690,990 990,1110
Sort of broad name for

353
00:10:41,670 --> 00:10:43,680
0,150 150,600 600,810 810,1410 1410,2010
this process of switching deciding

354
00:10:43,680 --> 00:10:44,580
0,270 270,390 390,450 450,690 690,900
I'm going to leave off

355
00:10:44,580 --> 00:10:46,800
0,450 510,990 990,1140 1140,1500 1890,2220
one thread and start another

356
00:10:46,800 --> 00:10:48,600
0,390 540,780 780,960 960,1170 1170,1800
thread, it's often called scheduling.

357
00:10:51,520 --> 00:10:53,230
0,690 720,870 870,1110 1110,1440 1440,1710
And we'll see that X

358
00:10:53,230 --> 00:10:54,580
0,300 300,570 570,1110 1110,1290 1290,1350
six indie types as an

359
00:10:54,730 --> 00:10:55,990
0,480 480,690 690,750 750,1080 1080,1260
actual piece of code, that's

360
00:10:55,990 --> 00:10:57,430
0,90 90,660 660,930 930,1110 1110,1440
the scheduler indeed has multiple

361
00:10:57,430 --> 00:10:59,830
0,510 510,750 750,900 900,1320 2100,2400
schedulers one per core, but

362
00:10:59,830 --> 00:11:02,020
0,90 90,420 420,960 960,1170 1710,2190
the general idea of how

363
00:11:02,020 --> 00:11:03,460
0,90 90,180 180,810 810,990 990,1440
do you drive the decision

364
00:11:03,460 --> 00:11:04,210
0,90 90,360 360,480 480,630 630,750
to switch from one to

365
00:11:04,210 --> 00:11:05,170
0,450 450,570 570,660 660,900 900,960
another, how to pick the

366
00:11:05,170 --> 00:11:07,180
0,270 270,570 570,690 690,1140 1830,2010
next thread to run its

367
00:11:07,180 --> 00:11:08,600
0,150 150,600
called scheduling.

368
00:11:10,120 --> 00:11:12,280
0,570 1020,1470 1470,1860 1860,1980 1980,2160
Um, another question is if

369
00:11:12,280 --> 00:11:13,480
0,90 90,210 210,270 270,780 780,1200
you want to actually implement

370
00:11:13,480 --> 00:11:14,440
0,90 90,450 450,570 570,720 720,960
the switch from one thread

371
00:11:14,440 --> 00:11:15,130
0,90 90,360 360,450 450,600 600,690
to another, you need to

372
00:11:15,130 --> 00:11:17,260
0,660 660,840 840,1620 1800,2040 2040,2130
save and restore so we

373
00:11:17,260 --> 00:11:18,850
0,150 150,240 240,960 990,1380 1380,1590
need to decide what needs

374
00:11:18,850 --> 00:11:21,310
0,90 90,210 210,990 1320,1800 2190,2460
to be saved and we

375
00:11:21,310 --> 00:11:22,460
0,90 90,180 180,510 510,660
are to save it.

376
00:11:22,900 --> 00:11:24,430
0,720 1080,1230 1230,1410 1410,1470 1470,1530
When it needs to be

377
00:11:24,430 --> 00:11:25,360
0,270 270,360 360,510 510,720 720,930
saved when we leave off

378
00:11:25,360 --> 00:11:27,070
0,360 360,570 570,900 900,990 990,1710
executing one thread and restored

379
00:11:27,070 --> 00:11:28,810
0,450 660,1080 1080,1230 1230,1350 1350,1740
when we want to resume

380
00:11:28,810 --> 00:11:30,190
0,450 450,630 630,900 900,1020 1110,1380
executing that thread at some

381
00:11:30,190 --> 00:11:32,620
0,240 240,630 990,1290 1560,2040 2040,2430
later time, a final question

382
00:11:32,620 --> 00:11:33,340
0,120 120,330 330,390 390,510 510,720
is what to do about

383
00:11:33,340 --> 00:11:36,160
0,390 390,660 660,1530
compute bound threads.

384
00:11:37,960 --> 00:11:39,280
0,720
D.

385
00:11:40,090 --> 00:11:42,280
0,270 270,330 330,420 420,1470 1650,2190
Many of the options a

386
00:11:42,370 --> 00:11:43,270
0,180 180,240 240,300 300,450 450,900
many of the most straightforward

387
00:11:43,270 --> 00:11:45,430
0,300 300,420 420,660 660,1230 1500,2160
options for thread switching involve

388
00:11:45,430 --> 00:11:46,930
0,120 120,480 480,510 510,1260 1260,1500
the threads are voluntarily saying

389
00:11:46,930 --> 00:11:47,530
0,150 150,210 210,330 330,390 390,600
well I'm going to save

390
00:11:47,530 --> 00:11:48,760
0,120 120,270 270,840 840,1050 1050,1230
Wei, my state and sort

391
00:11:48,760 --> 00:11:50,620
0,120 330,660 660,1170 1200,1590 1590,1860
of run another let another

392
00:11:50,620 --> 00:11:52,270
0,270 270,420 420,780 840,1380 1410,1650
thread be run, but what

393
00:11:52,270 --> 00:11:52,870
0,60 60,180 180,270 270,360 360,600
do we have a user

394
00:11:52,870 --> 00:11:54,610
0,360 360,720 750,1200 1200,1350 1350,1740
program that's doing some long

395
00:11:54,610 --> 00:11:56,560
0,660 660,1440 1440,1590 1590,1770 1770,1950
running calculation that might take

396
00:11:56,560 --> 00:11:58,600
0,720 870,1620 1620,1830 1830,1920 1920,2040
hours, um, it's not going

397
00:11:58,600 --> 00:12:00,190
0,60 60,150 150,540 540,900 900,1590
to be particularly thinking about

398
00:12:00,190 --> 00:12:01,240
0,240 240,360 360,570 570,780 840,1050
now, be time to good

399
00:12:01,240 --> 00:12:02,110
0,180 180,270 270,390 390,660 660,870
time to let something else

400
00:12:02,110 --> 00:12:05,020
0,450 660,1110 1260,1770 1770,2100 2100,2910
run so it's most convenient

401
00:12:05,530 --> 00:12:06,340
0,150 150,360 360,570 570,750 750,810
to have some way of

402
00:12:06,340 --> 00:12:08,620
0,540 540,630 630,1290 1290,1770 1770,2280
sort of automatically revoking control

403
00:12:08,620 --> 00:12:10,300
0,360 450,720 720,1080 1080,1320 1320,1680
from some long running compute

404
00:12:10,300 --> 00:12:12,490
0,210 210,960 1140,1710 1740,2070 2070,2190
bound process, I'm setting it

405
00:12:12,490 --> 00:12:13,900
0,510 510,720 780,1020 1020,1290 1290,1410
aside and maybe running it

406
00:12:13,900 --> 00:12:14,520
0,360
later.

407
00:12:16,780 --> 00:12:17,830
0,660 660,780 780,840 840,960 960,1050
Alright, so I'm going to

408
00:12:17,830 --> 00:12:19,600
0,240 240,510 510,1020 1020,1410 1410,1770
talk about these I'm actually

409
00:12:19,600 --> 00:12:21,070
0,120 120,180 180,390 390,960 1320,1470
going to talk about, um,

410
00:12:21,070 --> 00:12:22,480
0,120 120,630 630,1020 1050,1320 1320,1410
the machinery for dealing with

411
00:12:22,480 --> 00:12:26,440
0,420 420,630 630,1290 1560,2370
compute bound threads first.

412
00:12:27,220 --> 00:12:28,560
0,780
And.

413
00:12:28,740 --> 00:12:29,910
0,450 450,540 540,780 780,870 870,1170
Scheme for that is something

414
00:12:29,910 --> 00:12:32,460
0,840 870,1260 1260,1380 1380,1950
you've come up before.

415
00:12:32,520 --> 00:12:34,640
0,360 360,750 750,1590
That's timer interrupts.

416
00:12:38,340 --> 00:12:40,400
0,330 390,570 570,900 900,1470
And the idea here.

417
00:12:40,610 --> 00:12:42,230
0,210 210,540 570,960 960,1170 1170,1620
Is that there's a um

418
00:12:42,500 --> 00:12:44,030
0,180 180,420 420,480 480,1110 1140,1530
a piece of hardware on

419
00:12:44,180 --> 00:12:46,040
0,420 450,1080 1080,1200 1200,1350 1350,1860
each CPU on each core

420
00:12:46,280 --> 00:12:49,640
0,270 270,750 750,1650 1770,2790 2820,3360
that generates periodic interrupts, um

421
00:12:49,850 --> 00:12:51,440
0,420 420,750 780,1140 1140,1440 1440,1590
and the X six or

422
00:12:51,440 --> 00:12:52,850
0,150 150,450 450,720 720,930 930,1410
any operating system really arranges

423
00:12:52,850 --> 00:12:54,380
0,360 390,540 540,840 840,1170 1170,1530
to have those interrupts delivered

424
00:12:54,380 --> 00:12:55,880
0,60 60,150 150,540 540,810 1080,1500
to the kernel, so even

425
00:12:55,880 --> 00:12:57,110
0,240 270,450 450,840 840,960 960,1230
if we're running at user

426
00:12:57,110 --> 00:12:58,520
0,300 300,450 450,660 660,1140 1140,1410
level and some loop that's

427
00:12:58,520 --> 00:12:59,810
0,90 90,360 420,960 960,1050 1050,1290
you know computing the first

428
00:12:59,810 --> 00:13:03,170
0,690 720,1080 1080,1140 1140,1830 1920,3360
billion digits of pi, nevertheless

429
00:13:03,470 --> 00:13:05,300
0,420 420,630 660,1080 1080,1500 1500,1830
as a timer interrupts go

430
00:13:05,300 --> 00:13:06,200
0,180 180,240 240,390 390,660 660,900
off at some point, maybe

431
00:13:06,200 --> 00:13:08,840
0,180 180,360 360,1230 1440,2250 2250,2640
every ten milliseconds and transfer

432
00:13:08,840 --> 00:13:10,220
0,360 360,690 690,900 900,1140 1140,1380
control from that user level

433
00:13:10,220 --> 00:13:12,260
0,600 690,1110 1110,1350 1350,1740 1740,2040
code into the interrupt handler

434
00:13:12,260 --> 00:13:13,190
0,60 60,150 150,510 600,720 720,930
in the kernel, and so

435
00:13:13,310 --> 00:13:15,830
0,270 270,570 1020,1620 1620,2070 2070,2520
that's the first step in

436
00:13:15,890 --> 00:13:17,300
0,240 240,630 630,840 840,1020 1020,1410
the kernel, being able to

437
00:13:17,330 --> 00:13:19,190
0,480 480,990 990,1080 1080,1440 1440,1860
gain control to switch among

438
00:13:19,190 --> 00:13:21,530
0,420 420,810 810,1110 1110,1920 1920,2340
different user level processes, user

439
00:13:21,530 --> 00:13:23,420
0,270 270,840 1050,1530 1530,1680 1680,1890
level threads, even if those

440
00:13:23,420 --> 00:13:25,820
0,180 180,420 420,990 1110,1530 1530,2400
user level threads aren't cooperative.

441
00:13:26,900 --> 00:13:30,620
0,480 2280,2760 2820,2940 2940,3270 3270,3720
Um, and the basic scheme

442
00:13:30,620 --> 00:13:32,240
0,180 180,480 930,1110 1110,1230 1230,1620
is that in the interrupt

443
00:13:32,240 --> 00:13:33,260
0,480 480,660 660,720 720,870 870,1020
handler, so we're gonna have

444
00:13:33,260 --> 00:13:35,420
0,360 390,840 840,1620
a kernel handler.

445
00:13:35,450 --> 00:13:37,520
0,360 360,480 480,660 660,1470
Um, for these interrupts.

446
00:13:38,170 --> 00:13:40,200
0,600 600,780 780,1470
And we'll see.

447
00:13:40,500 --> 00:13:43,230
0,450 450,840 900,1320 1320,2040 2370,2730
That a kernel handler, a

448
00:13:43,260 --> 00:13:45,090
0,1110 1170,1410 1410,1530 1530,1620 1620,1830
yields, this is the sort

449
00:13:45,090 --> 00:13:46,320
0,120 270,840 840,930 930,1110 1110,1230
of name for this it

450
00:13:46,320 --> 00:13:49,260
0,690
yields.

451
00:13:49,290 --> 00:13:51,900
0,300 300,720 720,1410 1560,1740 1740,2610
The colonel handler or voluntarily

452
00:13:51,900 --> 00:13:53,130
0,420 420,510 510,930 930,1140 1140,1230
yields, the CPU back to

453
00:13:53,130 --> 00:13:54,480
0,120 120,600 600,870 870,960 960,1350
the schedule until the schedule

454
00:13:54,480 --> 00:13:55,650
0,300 360,600 600,690 690,870 870,1170
look, you can let something

455
00:13:55,650 --> 00:13:57,020
0,240 240,480 480,750
else run now.

456
00:13:58,240 --> 00:13:59,620
0,210 210,360 360,930 930,1080 1080,1380
And this yielding is really

457
00:13:59,620 --> 00:14:01,920
0,420 420,810 810,1320
a form of.

458
00:14:01,980 --> 00:14:04,830
0,420 420,1080 1080,1320 1830,2340 2460,2850
Thread switch that, um saves

459
00:14:04,830 --> 00:14:05,550
0,210 210,330 330,600 600,660 660,720
away, the state of the

460
00:14:05,550 --> 00:14:07,050
0,240 240,780 930,1350 1350,1410 1410,1500
current thread so it can

461
00:14:07,050 --> 00:14:10,650
0,90 90,480 480,870 3270,3510 3510,3600
be restored later as we'll

462
00:14:10,650 --> 00:14:12,390
0,330 330,960 990,1230 1230,1590 1590,1740
see the full story here

463
00:14:12,390 --> 00:14:13,140
0,240 240,330 330,510 510,540 540,750
actually you've seen a lot

464
00:14:13,140 --> 00:14:13,920
0,90 90,150 150,330 330,630 630,780
of the full story here

465
00:14:13,920 --> 00:14:15,360
0,210 210,300 300,660 660,750 750,1440
because it involves an interrupt

466
00:14:16,050 --> 00:14:16,920
0,150 150,210 210,420 420,570 570,870
what you already know about

467
00:14:16,920 --> 00:14:18,330
0,60 60,240 240,480 480,720 720,1410
the full story some complex

468
00:14:18,330 --> 00:14:19,560
0,240 420,690 690,930 930,1140 1140,1230
but the basic idea is

469
00:14:19,560 --> 00:14:21,630
0,150 150,210 210,570 570,1080 1440,2070
that a timer interrupt gives

470
00:14:21,630 --> 00:14:22,650
0,270 270,330 330,420 420,870 870,1020
control to the kernel and

471
00:14:22,650 --> 00:14:25,020
0,60 60,600 690,1530 1530,2220 2250,2370
the kernel voluntarily yields the

472
00:14:25,020 --> 00:14:27,780
0,540 1800,2010 2010,2100 2100,2640 2640,2760
CPU, this is called as

473
00:14:27,780 --> 00:14:30,120
0,150 150,420 420,810 960,1710 1710,2340
a piece of terminology preemptive

474
00:14:30,120 --> 00:14:31,220
0,780
scheduling.

475
00:14:32,680 --> 00:14:33,960
0,690
I'm.

476
00:14:38,980 --> 00:14:40,510
0,540 540,810 810,1020 1020,1170 1170,1530
Um, and what that means

477
00:14:40,510 --> 00:14:42,460
0,180 180,480 630,750 750,1320 1320,1950
is that the preemptive means

478
00:14:42,460 --> 00:14:43,780
0,180 180,420
is that.

479
00:14:43,780 --> 00:14:45,100
0,300 300,420 420,750 780,1140 1140,1320
Even if the code that's

480
00:14:45,100 --> 00:14:46,360
0,240 240,630
running doesn't.

481
00:14:46,360 --> 00:14:48,310
0,210 210,480 480,750 750,1380 1710,1950
It doesn't want to you

482
00:14:48,310 --> 00:14:50,350
0,330 360,750 960,1710 1710,1950 1950,2040
know doesn't explicitly yield the

483
00:14:50,350 --> 00:14:52,150
0,660 810,1020 1020,1350 1350,1710 1710,1800
CPU, the timer interrupt is

484
00:14:52,150 --> 00:14:53,500
0,150 150,240 240,450 450,840 840,1350
going to take control away

485
00:14:53,710 --> 00:14:55,060
0,630 630,750 750,870 870,930 930,1350
and we're going to yield

486
00:14:55,060 --> 00:14:56,110
0,270 270,510 510,600 600,690 690,1050
for it and the opposite

487
00:14:56,110 --> 00:14:58,600
0,60 60,570 570,1230 1770,2400 2400,2490
of preemptive scheduling might be

488
00:14:58,600 --> 00:14:59,560
0,450
called.

489
00:15:00,230 --> 00:15:02,760
0,420 420,690 690,1350 1350,1920
Um, maybe voluntary scheduling.

490
00:15:05,040 --> 00:15:06,150
0,180 180,270 270,630 630,810 810,1110
And the interesting thing is

491
00:15:06,150 --> 00:15:08,220
0,180 180,480 810,1170 1170,1920 1920,2070
that the the implementation in

492
00:15:08,220 --> 00:15:10,020
0,540 540,900 900,1110 1110,1440 1440,1800
x86 and other operating systems

493
00:15:10,020 --> 00:15:11,580
0,90 90,570 570,1200 1200,1350 1350,1560
of preemptive scheduling is this

494
00:15:11,580 --> 00:15:13,320
0,270 270,870 870,1350 1350,1590 1590,1740
time interrupt forcibly takes away

495
00:15:13,320 --> 00:15:15,030
0,90 90,780 1080,1530 1530,1650 1650,1710
the CPU and then the

496
00:15:15,030 --> 00:15:17,850
0,630 660,1200 1200,1410 1410,1470 1470,2820
kernel basically does a voluntary

497
00:15:18,090 --> 00:15:19,920
0,750 750,1140 1140,1440 1440,1710 1710,1830
yield thread thread switch on

498
00:15:19,920 --> 00:15:21,760
0,390 390,480 480,630 630,1380
behalf of that process.

499
00:15:22,120 --> 00:15:23,520
0,30 240,840
I am.

500
00:15:24,100 --> 00:15:28,390
0,630 930,1440 1860,2640 3450,4110 4110,4290
Now I'm another just piece

501
00:15:28,390 --> 00:15:30,370
0,240 600,1440 1440,1560 1560,1800 1800,1980
of terminology that comes up

502
00:15:30,370 --> 00:15:31,780
0,360 360,480 480,720 750,1350 1350,1410
here is that while the

503
00:15:31,780 --> 00:15:34,120
0,390 390,1110 1410,1830 1860,2100 2100,2340
threads running, um, there's a

504
00:15:34,150 --> 00:15:35,280
0,300 300,570
need to.

505
00:15:35,430 --> 00:15:38,040
0,300 300,1200 1560,1920 1980,2490 2490,2610
A distinguish a systems that

506
00:15:38,040 --> 00:15:39,480
0,450 450,750 750,1140 1140,1260 1260,1440
distinguish between threads that are

507
00:15:39,510 --> 00:15:41,670
0,750 750,1230 1230,1650 1650,1830 1830,2160
currently actually running on some

508
00:15:41,670 --> 00:15:44,640
0,840 960,1680 1860,2550 2550,2700 2700,2970
CPU Vs threads that would

509
00:15:44,640 --> 00:15:46,620
0,420 420,600 600,1260 1380,1650 1680,1980
like to run but aren't

510
00:15:46,620 --> 00:15:48,330
0,480 480,810 810,930 930,1110 1110,1710
currently running on any CPU,

511
00:15:48,330 --> 00:15:49,740
0,120 120,360 660,870 870,1290 1290,1410
but you could run if

512
00:15:49,740 --> 00:15:51,930
0,60 60,480 480,810 810,1410 1650,2190
a CPU became free Vs

513
00:15:51,930 --> 00:15:53,670
0,480 480,810 930,1290 1290,1530 1530,1740
threads that actually don't want

514
00:15:53,670 --> 00:15:54,960
0,60 60,390 390,630 630,780 780,1290
to run because they're waiting

515
00:15:54,960 --> 00:15:56,370
0,180 180,630 630,750 750,1230 1260,1410
for io or waiting for

516
00:15:56,370 --> 00:15:58,380
0,180 180,780 930,1650
some event, um.

517
00:15:58,600 --> 00:16:00,700
0,210 210,750 750,1350 1500,2010 2010,2100
And unfortunately, this distinction is

518
00:16:00,700 --> 00:16:03,640
0,240 240,480 480,1080 2280,2580 2580,2940
often called state even though

519
00:16:04,060 --> 00:16:04,810
0,150 150,390 390,630 630,690 690,750
the full state of the

520
00:16:04,810 --> 00:16:05,680
0,210 210,300 300,540 540,720 720,870
thread is actually much more

521
00:16:05,680 --> 00:16:08,460
0,540 540,870 1110,1860
complicated than that.

522
00:16:09,830 --> 00:16:10,730
0,270 270,480 480,660 660,780 780,900
Um, since this is going

523
00:16:10,730 --> 00:16:11,920
0,90 90,270 270,660
to come up.

524
00:16:12,420 --> 00:16:13,590
0,120 120,300 300,570 630,870 870,1170
I just want a list

525
00:16:13,590 --> 00:16:14,400
0,90 90,120 120,360 360,420 420,810
out a couple of states

526
00:16:14,400 --> 00:16:16,160
0,120 120,240 240,360 360,900
that will be seeing.

527
00:16:16,370 --> 00:16:17,630
0,240 240,570 570,630 630,1050 1050,1260
And these are states that

528
00:16:17,990 --> 00:16:20,090
0,570 570,810 810,1320 1320,1710 1740,2100
X actually maintains there's a

529
00:16:20,090 --> 00:16:21,500
0,240 240,510 510,840 840,1020 1020,1410
state called running which means

530
00:16:21,860 --> 00:16:23,300
0,120 120,360 360,810 810,930 930,1440
it's actually executing on some

531
00:16:23,480 --> 00:16:25,160
0,570 570,720 720,1140 1140,1320 1320,1680
Koran, some CPU right now

532
00:16:25,370 --> 00:16:27,940
0,1020 1050,1530 1530,2100
there's Ron abot.

533
00:16:29,970 --> 00:16:31,290
0,180 180,300 300,480 480,870 870,1320
Which means not currently executing

534
00:16:31,290 --> 00:16:33,000
0,360 360,630 960,1290 1290,1350 1350,1710
anywhere but just a saved

535
00:16:33,000 --> 00:16:34,770
0,450 930,1380 1380,1470 1470,1650 1650,1770
state, but would like to

536
00:16:34,770 --> 00:16:36,030
0,330 330,450 450,600 600,720 720,1260
run as soon as possible

537
00:16:36,360 --> 00:16:37,350
0,360 360,570 570,630 630,840 840,990
and then it turns out

538
00:16:37,350 --> 00:16:39,420
0,240 240,780 780,1140 1140,1530 1560,2070
there's a state which won't

539
00:16:39,420 --> 00:16:40,440
0,120 120,240 240,450 450,780 780,1020
come out much today but

540
00:16:40,740 --> 00:16:41,580
0,120 120,240 240,390 390,690 690,840
will come up next week

541
00:16:41,580 --> 00:16:43,590
0,210 210,720 840,1230 1440,1830 1830,2010
called sleeping just means the

542
00:16:43,590 --> 00:16:44,790
0,270 270,570 570,690 690,870 870,1200
threads waiting for some io

543
00:16:44,790 --> 00:16:46,440
0,480 690,1020 1110,1380 1380,1560 1560,1650
event and only wants to

544
00:16:46,440 --> 00:16:47,640
0,150 150,540 540,660 660,930 930,1200
run after the io event

545
00:16:47,640 --> 00:16:49,140
0,480 660,870 870,1110 1110,1230 1230,1500
occurs, so today we're mostly

546
00:16:49,140 --> 00:16:50,670
0,420 420,660 750,1080 1080,1230 1230,1530
concerned with running and reasonable

547
00:16:50,670 --> 00:16:52,710
0,750 750,1080 1110,1410 1410,1590 1590,2040
threads and what this preemptive

548
00:16:52,710 --> 00:16:54,240
0,390 390,900 900,1050 1050,1200 1200,1530
switch does what this timer

549
00:16:54,240 --> 00:16:55,560
0,300 300,810 810,900 900,960 960,1320
interrupt does and the yield

550
00:16:55,560 --> 00:16:57,060
0,90 90,570 600,1050 1050,1140 1140,1500
is basically convert a running

551
00:16:57,060 --> 00:16:58,860
0,600 630,930 930,1200 1200,1380 1380,1800
thread whatever thread was interrupted

552
00:16:58,860 --> 00:17:00,780
0,120 120,210 210,780 900,1530 1530,1920
by the timer into a

553
00:17:00,810 --> 00:17:02,160
0,510 510,990
vulnerable thread.

554
00:17:02,160 --> 00:17:03,210
0,180 180,300 300,390 390,600 600,1050
That is a thread that's

555
00:17:03,300 --> 00:17:05,520
0,300 300,930 930,1080 1500,2040 2040,2220
by yielding or converting that

556
00:17:05,520 --> 00:17:06,330
0,210 210,360 360,420 420,660 660,810
thread into a thread, that's

557
00:17:06,330 --> 00:17:07,380
0,180 180,420 420,600 600,810 810,1050
not running right now but

558
00:17:07,500 --> 00:17:08,910
0,270 270,480 480,750 750,990 990,1410
would actually like to clearly

559
00:17:08,910 --> 00:17:10,020
0,240 240,360 390,660 660,990 990,1110
because it was running at

560
00:17:10,020 --> 00:17:11,580
0,120 120,330 330,510 930,1170 1200,1560
the time of a timer

561
00:17:11,580 --> 00:17:12,480
0,480
interrupt.

562
00:17:14,220 --> 00:17:16,890
0,360 360,720 750,1410 1980,2370 2370,2670
Okay so I'm running thread

563
00:17:16,890 --> 00:17:19,170
0,360 360,690 690,1230 1230,2010 2010,2280
its program counter registers are

564
00:17:19,200 --> 00:17:21,480
0,450 480,720 720,810 810,1980 2160,2280
actually in the CPU, you

565
00:17:21,480 --> 00:17:22,680
0,120 120,240 240,330 330,660 660,1200
know in the hardware registers

566
00:17:22,680 --> 00:17:24,150
0,60 60,150 150,720 720,900 900,1470
of the CPU, that's executing

567
00:17:24,150 --> 00:17:26,520
0,270 540,990 1080,1590 1590,2010 2010,2370
it, um a reasonable thread

568
00:17:26,520 --> 00:17:28,380
0,390 420,660 660,1350
though has no.

569
00:17:28,470 --> 00:17:29,460
0,150 150,540 540,810 810,930 930,990
It's not doesn't have a

570
00:17:29,460 --> 00:17:31,770
0,360 360,990 990,1140 1140,1380 2160,2310
CPU associated with it and

571
00:17:31,770 --> 00:17:33,270
0,300 300,420 420,630 630,720 720,1500
therefore we need to save

572
00:17:33,270 --> 00:17:35,190
0,180 180,450 450,870 870,1410 1590,1920
for every reasonable state, we

573
00:17:35,190 --> 00:17:38,910
0,180 180,270 270,1380 2070,2970 2970,3720
need to save whatever CPU

574
00:17:38,910 --> 00:17:40,860
0,600 600,1020 1050,1380 1380,1470 1470,1950
state whatever state the CPU

575
00:17:40,860 --> 00:17:43,620
0,210 210,930 1080,1560 1650,2190 2190,2760
was keeping a when that.

576
00:17:44,220 --> 00:17:45,900
0,330 330,690 690,870 870,1320 1500,1680
A thread was running, so

577
00:17:45,900 --> 00:17:46,560
0,60 60,180 180,270 270,570 570,660
we need to copy the

578
00:17:46,560 --> 00:17:48,060
0,450 450,1170 1170,1320 1320,1380 1380,1500
CPU contents, you know which

579
00:17:48,060 --> 00:17:48,990
0,90 90,330 330,660 660,780 780,930
is not Ram, but just

580
00:17:48,990 --> 00:17:50,970
0,540 540,900 1050,1470 1470,1920 1920,1980
registers really I'm from the

581
00:17:50,970 --> 00:17:53,460
0,810 900,1320 1320,1680 1680,2310 2340,2490
CPU into memory somewhere to

582
00:17:53,460 --> 00:17:55,260
0,330 330,720 780,960 960,1200 1620,1800
save them when we turn

583
00:17:55,260 --> 00:17:56,100
0,60 60,300 300,480 480,720 720,840
to thread from running to

584
00:17:56,100 --> 00:17:57,480
0,450 540,720 720,1080 1080,1230 1230,1380
rubble and again this is

585
00:17:57,480 --> 00:17:59,310
0,300 450,1260 1260,1440 1440,1740 1740,1830
the basically the state we

586
00:17:59,310 --> 00:18:01,380
0,120 120,570 600,1290 1290,1650 1650,2070
have to explicitly save yours

587
00:18:01,410 --> 00:18:02,820
0,330 330,420 420,960
just the state.

588
00:18:03,030 --> 00:18:04,230
0,150 150,690 690,1050 1050,1110 1110,1200
The executing state of the

589
00:18:04,230 --> 00:18:06,600
0,420 420,630 630,750 750,1020 1980,2370
CPU, which is the program

590
00:18:06,600 --> 00:18:08,180
0,480 480,660 660,990
counter and um.

591
00:18:09,080 --> 00:18:11,240
0,990 1170,1410 1410,1830 1830,1950 1950,2160
Registers and CPU, so these

592
00:18:11,240 --> 00:18:12,700
0,150 150,210 210,300 300,930
need to be saved.

593
00:18:13,000 --> 00:18:14,740
0,270 270,600 600,870 1290,1680 1680,1740
Only convert a run a

594
00:18:14,740 --> 00:18:16,870
0,240 780,1170 1170,1350 1350,1830 1830,2130
ball when some scheduler finally

595
00:18:16,870 --> 00:18:18,910
0,600 600,750 750,1500 1530,1710 1710,2040
decides to run a reasonable

596
00:18:18,910 --> 00:18:20,860
0,570 780,1260 1260,1620 1650,1890 1890,1950
thread, then as part of

597
00:18:20,860 --> 00:18:21,760
0,60 60,240 240,630 630,690 690,900
the many steps in getting

598
00:18:21,760 --> 00:18:23,290
0,150 150,450 450,750 750,1350 1380,1530
that thread going again and

599
00:18:23,290 --> 00:18:25,660
0,390 390,600 810,1500 1920,2250 2250,2370
resuming it we're going to

600
00:18:25,660 --> 00:18:27,010
0,210 210,450 450,690 720,1080 1080,1350
see that the program count

601
00:18:27,010 --> 00:18:29,110
0,90 90,750 780,1110 1110,1380 1380,2100
the saved program counter registers

602
00:18:29,110 --> 00:18:30,760
0,90 90,540 540,960 960,1320 1320,1650
are copied back into the

603
00:18:31,480 --> 00:18:32,980
0,720 720,1170
CPU 's.

604
00:18:32,980 --> 00:18:34,300
0,390 390,840 840,900 900,960 960,1320
Actual register on the CPU

605
00:18:34,300 --> 00:18:35,350
0,150 150,240 240,600 600,930 930,1050
that the scheduler decides to

606
00:18:35,350 --> 00:18:36,480
0,210 210,270 270,480
run it on.

607
00:18:38,910 --> 00:18:40,260
0,630
Alright.

608
00:18:40,500 --> 00:18:42,960
0,210 210,510 510,720 720,1590 1590,2460
Any questions about these terminology.

609
00:18:49,880 --> 00:18:51,200
0,420 420,510 510,840 870,1110 1110,1320
Alright, I'm gonna I'm now

610
00:18:51,200 --> 00:18:52,310
0,210 210,270 270,540 540,810 810,1110
sort of talk about a

611
00:18:52,760 --> 00:18:53,930
0,360 360,420 420,810 810,990 990,1170
sort of more ex v,

612
00:18:53,930 --> 00:18:56,210
0,720 750,1230 1230,1470 1470,1560 1560,2280
six oriented view of things.

613
00:18:57,760 --> 00:18:59,230
0,330 330,420 420,600 600,1170 1350,1470
Um, I'm gonna draw a

614
00:18:59,230 --> 00:19:00,880
0,330 330,780 780,1110 1110,1290 1290,1650
two pictures really of a

615
00:19:01,180 --> 00:19:02,590
0,690 690,810 810,1080 1080,1320 1320,1410
threads and X six are

616
00:19:02,590 --> 00:19:03,820
0,180 180,240 240,720 720,1140 1140,1230
kind of simplified picture in

617
00:19:03,820 --> 00:19:05,800
0,210 210,540 540,1020 1020,1500 1650,1980
a more detailed picture so

618
00:19:05,800 --> 00:19:08,440
0,120 120,570 570,720 720,1440 1950,2640
as usually the user, um.

619
00:19:08,940 --> 00:19:10,200
0,390 390,540 540,930 930,1050 1050,1260
Stuff up here and the

620
00:19:10,230 --> 00:19:12,460
0,510 510,750 750,1230
colonel down here.

621
00:19:12,860 --> 00:19:14,040
0,570
HMM.

622
00:19:14,040 --> 00:19:15,990
0,210 210,390 390,510 510,1080 1290,1950
We might be running multiple

623
00:19:15,990 --> 00:19:18,450
0,840 1050,1290 1290,1560 1560,1950 1950,2460
processes at user level, maybe

624
00:19:18,630 --> 00:19:20,610
0,210 210,300 300,570 570,960 960,1980
you know the c compiler

625
00:19:20,610 --> 00:19:23,160
0,390 510,1440 1440,1530 1530,1620 1620,2550
and ls and a shell,

626
00:19:23,520 --> 00:19:25,140
0,690 930,1290 1290,1440 1440,1530 1530,1620
um, they may or may

627
00:19:25,140 --> 00:19:26,430
0,270 270,600 690,930 930,1170 1170,1290
not be all wanting to

628
00:19:26,430 --> 00:19:27,420
0,120 120,210 210,270 270,510 510,990
run at the same time.

629
00:19:28,260 --> 00:19:31,050
0,360 690,1290 1290,1620 1620,2100 2490,2790
I'm at user level, each

630
00:19:31,050 --> 00:19:33,400
0,120 120,720 750,1890
of these processes.

631
00:19:33,490 --> 00:19:34,780
0,750
I'm.

632
00:19:34,870 --> 00:19:37,800
0,1140 1650,2310
Has a.

633
00:19:38,400 --> 00:19:39,570
0,180 180,240 240,330 330,510 510,1170
You know it has memory,

634
00:19:39,690 --> 00:19:42,360
0,600 720,1020 1020,1200 1200,2220 2250,2670
um, and of particular interest

635
00:19:42,360 --> 00:19:43,380
0,90 90,480 510,810 810,870 870,1020
to us, each of these

636
00:19:43,380 --> 00:19:45,510
0,480 480,690 690,840 840,1290 1290,2130
processes has a user stack.

637
00:19:46,840 --> 00:19:48,880
0,420 450,870 900,1380 1380,1530 1530,2040
Um, and while it's running

638
00:19:48,880 --> 00:19:51,310
0,90 90,300 300,1350 2070,2340 2340,2430
it has registers in the

639
00:19:51,310 --> 00:19:53,650
0,270 270,810 810,1350 1350,1740 1950,2340
risk five hardware, so PC

640
00:19:53,650 --> 00:19:55,120
0,240 240,960
plus registers.

641
00:19:55,590 --> 00:19:57,900
0,330 330,540 750,1500 1500,1860 1860,2310
Alright, so while programs running

642
00:19:57,900 --> 00:19:59,430
0,120 120,270 270,840 870,1470 1470,1530
you know there's essentially a

643
00:19:59,430 --> 00:20:01,140
0,270 270,330 330,750 750,1230 1260,1710
thread of control that's running

644
00:20:01,140 --> 00:20:03,420
0,180 180,420 420,780 1620,1950 1980,2280
at user level and the

645
00:20:03,420 --> 00:20:04,020
0,120 120,180 180,300 300,360 360,600
way I'm going to talk

646
00:20:04,020 --> 00:20:05,370
0,240 240,420 420,690 690,930 930,1350
about it is as if

647
00:20:05,400 --> 00:20:07,830
0,570 900,1110 1110,1230 1230,1680 1680,2430
a there's a user thread

648
00:20:07,860 --> 00:20:10,320
0,480 1170,1650 1650,1770 1770,2100 2160,2460
that consists of the user,

649
00:20:10,320 --> 00:20:12,060
0,330 330,570 570,1050 1050,1410 1410,1740
stack user memory user program

650
00:20:12,060 --> 00:20:14,040
0,300 300,540 540,1230 1470,1860 1860,1980
counter user registers if the

651
00:20:14,040 --> 00:20:15,360
0,300 300,480 480,540 540,870 870,1320
program makes a system callers

652
00:20:15,360 --> 00:20:17,670
0,720 720,1050 1530,2100 2100,2250 2250,2310
interrupted and goes into the

653
00:20:17,670 --> 00:20:18,660
0,570
kernel.

654
00:20:19,020 --> 00:20:20,790
0,480 780,1110 1110,1230 1230,1410 1410,1770
Um, then this stuff saved

655
00:20:20,790 --> 00:20:22,470
0,210 210,360 660,900 900,1320 1320,1680
away in this program's trap

656
00:20:22,470 --> 00:20:26,460
0,540 1170,1590 1680,2520 2610,3570 3570,3990
frame and a kernel v

657
00:20:26,460 --> 00:20:29,670
0,450 450,990 990,1590 2490,2850 2850,3210
kernel thread for this program

658
00:20:29,670 --> 00:20:31,920
0,120 120,900 990,1290 1290,1680 1740,2250
is activated and so now

659
00:20:31,920 --> 00:20:33,210
0,180 180,300 300,630 690,1080 1080,1290
this is the trap frame

660
00:20:33,210 --> 00:20:35,970
0,210 210,960 1860,2250 2250,2550 2550,2760
hold saved user stuff after

661
00:20:35,970 --> 00:20:36,630
0,90 90,390 390,450 450,570 570,660
we saved a way the

662
00:20:36,630 --> 00:20:38,700
0,330 330,660 660,960 960,1290 1290,2070
user peace program counter registers

663
00:20:38,850 --> 00:20:41,040
0,870 930,1050 1050,1530 1530,1650 1650,2190
then we switch the CPU

664
00:20:41,040 --> 00:20:42,510
0,150 150,420 420,480 480,840 840,1470
to using the kernel stack.

665
00:20:43,290 --> 00:20:44,480
0,660
I'm.

666
00:20:45,520 --> 00:20:46,510
0,330 390,660 660,720 720,840 840,990
And you know we don't

667
00:20:46,510 --> 00:20:48,070
0,120 120,210 210,570 570,1080 1080,1560
need to restore registers, because,

668
00:20:48,550 --> 00:20:50,960
0,540 960,1320 1320,1740
um through the.

669
00:20:50,960 --> 00:20:52,580
0,150 150,720 720,1050 1050,1200 1200,1620
The kernel thread for process

670
00:20:52,580 --> 00:20:54,170
0,390 480,870 870,1320 1320,1410 1410,1590
isn't really running, it has

671
00:20:54,170 --> 00:20:56,720
0,180 180,360 360,690 690,1170 2100,2550
no real safe state when

672
00:20:56,720 --> 00:20:57,880
0,60 60,660
the user.

673
00:20:57,880 --> 00:20:59,560
0,420 420,540 540,1080 1110,1290 1290,1680
Thread is running a instead

674
00:20:59,560 --> 00:21:00,700
0,150 150,330 330,390 390,660 750,1140
it's sort of the kernel

675
00:21:00,700 --> 00:21:01,990
0,180 180,270 270,450 450,540 540,1290
thread is kind of activated

676
00:21:01,990 --> 00:21:03,130
0,150 150,300 300,960 990,1050 1050,1140
on its stack for the

677
00:21:03,130 --> 00:21:05,590
0,270 270,600 600,1170 1350,1770 2190,2460
first time in a in

678
00:21:05,590 --> 00:21:07,960
0,180 210,900 900,1170 1170,1620 1860,2370
the trampoline and a user

679
00:21:07,960 --> 00:21:09,280
0,330 330,840
trap code.

680
00:21:09,770 --> 00:21:11,160
0,450
HMM.

681
00:21:11,940 --> 00:21:12,960
0,330 330,480 480,630 630,690 690,1020
Um, and then the kernel

682
00:21:12,960 --> 00:21:14,250
0,270 270,420 420,480 480,750 750,1290
runs for a while, maybe

683
00:21:14,310 --> 00:21:15,540
0,360 360,420 420,750 750,1110 1110,1230
running a system call or

684
00:21:15,540 --> 00:21:17,250
0,390 390,780 780,1170 1170,1440 1440,1710
interrupt handler whatever it maybe

685
00:21:18,150 --> 00:21:20,520
0,690 720,1830 1860,2130 2130,2280 2280,2370
and sometimes a it is

686
00:21:20,520 --> 00:21:21,630
0,60 60,330 330,540 540,960 960,1110
a system called particular will

687
00:21:21,630 --> 00:21:23,070
0,210 210,510 510,1110 1110,1290 1290,1440
just simply return from this

688
00:21:23,070 --> 00:21:24,630
0,330 330,660 660,750 750,1080 1230,1560
point back to the same

689
00:21:24,630 --> 00:21:26,670
0,510 510,810 1350,1740 1740,1800 1800,2040
process and return to user

690
00:21:26,670 --> 00:21:29,340
0,270 270,450 450,1290 1440,2010 2040,2670
space will restore this program's

691
00:21:29,340 --> 00:21:31,380
0,300 300,600 600,1350 1380,1920 1920,2040
program counter registers, but it

692
00:21:31,380 --> 00:21:32,580
0,180 180,480 480,630 630,780 780,1200
could also be that instead

693
00:21:32,580 --> 00:21:34,740
0,240 720,1080 1080,1740
of simply returning.

694
00:21:34,890 --> 00:21:35,850
0,270 270,390 390,570 570,840 840,960
A for one reason or

695
00:21:35,850 --> 00:21:36,690
0,330 330,480 480,690 690,750 750,840
another, maybe because it was

696
00:21:36,690 --> 00:21:38,130
0,60 60,480 480,900 1020,1260 1260,1440
a timer interrupt, we're actually

697
00:21:38,130 --> 00:21:39,330
0,120 120,180 180,780 780,930 930,1200
going to switch to another

698
00:21:39,330 --> 00:21:41,340
0,570 570,900 990,1290 1290,1560 1560,2010
process and the very high-level

699
00:21:41,340 --> 00:21:42,270
0,210 210,300 300,570 570,690 690,930
view of that is that

700
00:21:43,110 --> 00:21:45,750
0,300 300,840 960,1380 1380,1830 1830,2640
if the FCC scheduler decides

701
00:21:45,810 --> 00:21:47,760
0,420 480,870 870,1050 1050,1230 1230,1950
a switch from this process

702
00:21:47,790 --> 00:21:49,920
0,90 90,150 150,390 390,1140 1800,2130
to a different process, what

703
00:21:49,920 --> 00:21:50,850
0,120 120,390 390,480 480,660 660,930
the first thing that really

704
00:21:50,850 --> 00:21:52,290
0,480 480,630 630,900 960,1320 1320,1440
happens is that we're going

705
00:21:52,290 --> 00:21:54,810
0,90 90,690 690,1260 1260,2250 2280,2520
to switch kernel threads from

706
00:21:54,810 --> 00:21:56,640
0,270 270,810 810,1110 1110,1590 1620,1830
this processes, kernel thread to

707
00:21:56,640 --> 00:21:58,260
0,120 120,330 330,840 840,1140 1140,1620
the other processes kernel thread,

708
00:21:58,350 --> 00:21:59,520
0,240 240,360 360,480 480,660 660,1170
and then the other processes

709
00:21:59,520 --> 00:22:00,780
0,270 270,600 600,720 720,1020 1020,1260
kernel foot will turn back

710
00:22:00,780 --> 00:22:02,550
0,90 90,390 390,750 750,1080 1230,1770
to user space, so supposing

711
00:22:02,550 --> 00:22:03,630
0,180 180,300 300,480 480,930 930,1080
that the c compiler c

712
00:22:03,630 --> 00:22:04,950
0,240 240,360 360,540 540,630 630,1320
needs to read the disk

713
00:22:05,070 --> 00:22:06,180
0,600 600,780 780,870 870,990 990,1110
a and so it's going

714
00:22:06,180 --> 00:22:08,160
0,60 60,330 330,390 390,1200 1680,1980
to yield the CPU while

715
00:22:08,160 --> 00:22:09,270
0,630 630,720 720,930 930,1020 1020,1110
sleeping to wait for the

716
00:22:09,270 --> 00:22:11,310
0,420 420,480 480,960 1140,1530 1530,2040
discrete to complete, maybe ls

717
00:22:11,310 --> 00:22:12,600
0,240 240,330 330,930 930,1050 1050,1290
wants to execute and is

718
00:22:12,600 --> 00:22:14,240
0,180 180,570 570,1110
in reasonable state.

719
00:22:14,610 --> 00:22:16,260
0,360 360,450 450,930 930,1320 1320,1650
What the ex schedule, maybe

720
00:22:16,320 --> 00:22:17,850
0,240 240,540 540,690 690,930 1080,1530
they do is that well,

721
00:22:18,180 --> 00:22:19,470
0,180 180,510 540,990 990,1140 1140,1290
um, if ls is in

722
00:22:19,470 --> 00:22:21,060
0,360 360,810 810,960 960,1290 1290,1590
reasonable state that means it

723
00:22:21,060 --> 00:22:22,380
0,390 390,630 630,1020 1020,1140 1140,1320
left off somewhere and its

724
00:22:22,380 --> 00:22:24,510
0,630 690,840 840,1200 1200,1680 1680,2130
state was saved away possibly

725
00:22:24,510 --> 00:22:26,100
0,180 180,240 240,720 720,1230 1410,1590
by a timer interrupt and

726
00:22:26,100 --> 00:22:27,480
0,210 210,870 870,990 990,1260 1260,1380
so ls will actually have

727
00:22:27,480 --> 00:22:29,010
0,90 90,780 810,1170 1170,1410 1410,1530
a saved trap frame with

728
00:22:29,010 --> 00:22:31,560
0,270 270,1410 1410,1620 1620,1770 1770,2550
user registers and its own

729
00:22:31,650 --> 00:22:34,140
0,510 510,1230 1500,1980 2040,2250 2250,2490
kernel stack, um, and as

730
00:22:34,140 --> 00:22:35,130
0,60 60,360 360,540 540,600 600,990
it turns out a seed

731
00:22:35,130 --> 00:22:36,620
0,360 360,630 630,1050
set of um.

732
00:22:37,820 --> 00:22:39,860
0,300 330,900 900,1470 1470,1950 1950,2040
A kernel registers associated with

733
00:22:39,860 --> 00:22:41,750
0,90 90,510 510,1050 1080,1710 1740,1890
the kernel thread which is

734
00:22:41,750 --> 00:22:42,440
0,120 120,180 180,330 330,600 600,690
going to be called the

735
00:22:42,440 --> 00:22:45,380
0,840 1080,1500 1740,2070 2100,2550 2550,2940
context, so if X switches

736
00:22:45,380 --> 00:22:47,330
0,150 150,210 210,960 990,1410 1410,1950
from the compiler kernel thread

737
00:22:47,450 --> 00:22:48,980
0,150 150,510 510,660 660,960 960,1530
to ls is kernel thread.

738
00:22:49,500 --> 00:22:51,660
0,600 840,1200 1200,1440 1440,1560 1560,2160
I'm actually six will save

739
00:22:51,660 --> 00:22:54,090
0,270 270,450 450,1050 1050,2040 2130,2430
away the kernel registers in

740
00:22:54,090 --> 00:22:56,610
0,60 60,630 630,1050 1110,1560 2040,2520
a context with a seat,

741
00:22:56,610 --> 00:22:59,580
0,270 300,900 900,1170 1170,1530
the compilers kernel thread.

742
00:22:59,760 --> 00:23:01,500
0,540 540,630 630,780 780,1110 1110,1740
Switch to the ls thread

743
00:23:02,730 --> 00:23:05,370
0,1080 1350,1800 1800,1980 1980,2040 2040,2640
complex scheme which I'll describe

744
00:23:05,400 --> 00:23:07,050
0,270 270,450 450,600 600,1050 1350,1650
a little bit later we'll

745
00:23:07,050 --> 00:23:10,180
0,870 1680,2130 2130,2670
restore ls is.

746
00:23:10,180 --> 00:23:12,220
0,390 390,720 720,1380 1380,1560 1560,2040
Kernel thread registers from the

747
00:23:12,310 --> 00:23:14,080
0,630 630,870 870,1410 1410,1560 1560,1770
previously safe context from one

748
00:23:14,080 --> 00:23:16,330
0,570 570,900 900,1200 1200,1590 1920,2250
ls last left off, maybe

749
00:23:16,330 --> 00:23:17,800
0,330 330,420 420,780 780,1080 1080,1470
ls will finish whatever system

750
00:23:17,800 --> 00:23:19,840
0,390 390,840 840,1710 1710,1830 1830,2040
called was executing you know

751
00:23:20,170 --> 00:23:23,080
0,840 1110,1440 1560,2010 2010,2430 2520,2910
on the ls is kernel

752
00:23:23,080 --> 00:23:25,240
0,270 270,720 1080,1650 1650,1800 1800,2160
thread stack, and then return

753
00:23:25,240 --> 00:23:26,620
0,180 180,270 270,750 750,1050 1050,1380
back to ls system called

754
00:23:26,620 --> 00:23:27,850
0,150 150,270 270,690 690,840 840,1230
on the way to return

755
00:23:27,850 --> 00:23:28,690
0,90 90,330 330,630 630,720 720,840
to user space that will

756
00:23:28,690 --> 00:23:30,980
0,420 420,630 630,1200 1200,1920
restore these previously saved.

757
00:23:30,980 --> 00:23:33,650
0,450 450,990 990,1230 1230,1830 2460,2670
User registers for less and

758
00:23:33,650 --> 00:23:35,990
0,210 210,810 900,1410 1410,2010 2040,2340
then resume executing ls so.

759
00:23:37,070 --> 00:23:38,930
0,540 720,1230 1230,1410 1410,1500 1500,1860
Um, there's bunch of details

760
00:23:38,930 --> 00:23:39,980
0,150 150,330 330,420 420,630 630,1050
here which we'll talk about

761
00:23:39,980 --> 00:23:41,900
0,300 450,870 1110,1380 1380,1470 1470,1920
but um, maybe the main

762
00:23:41,900 --> 00:23:43,550
0,330 330,600 600,690 690,900 930,1650
point here is that whenever

763
00:23:43,550 --> 00:23:45,410
0,90 90,330 330,450 450,1140 1170,1860
in ex v six se

764
00:23:45,410 --> 00:23:47,390
0,510 510,840 840,900 900,1470 1500,1980
direct user to user context

765
00:23:47,390 --> 00:23:49,220
0,540 540,690 690,780 780,1350 1620,1830
switches when we're switching from

766
00:23:49,220 --> 00:23:51,140
0,300 300,720 720,780 780,1110 1110,1920
one process to another always

767
00:23:51,350 --> 00:23:53,380
0,600 840,1170 1170,1410 1410,1560
I'm the sort of.

768
00:23:53,830 --> 00:23:55,600
0,270 270,930 930,1020 1020,1260 1260,1770
A strategy by which X

769
00:23:55,600 --> 00:23:57,430
0,420 420,540 540,960 960,1350 1350,1830
switches from executing one process

770
00:23:57,430 --> 00:23:59,410
0,120 120,390 390,1050 1260,1680 1740,1980
to another process is you

771
00:23:59,410 --> 00:24:00,670
0,210 210,330 330,390 390,810 810,1260
jump in the kernel saves

772
00:24:00,670 --> 00:24:02,470
0,150 150,630 630,900 900,1320 1320,1800
a process day run this

773
00:24:02,500 --> 00:24:04,570
0,660 660,960 960,1410 1410,1950 1950,2070
processes, kernel thread switch to

774
00:24:04,570 --> 00:24:06,550
0,120 150,450 450,810 1140,1560 1560,1980
the kernel thread another process

775
00:24:06,550 --> 00:24:08,140
0,150 150,690 690,1170 1170,1260 1260,1590
that suspended itself and then

776
00:24:08,290 --> 00:24:10,000
0,600 600,690 690,1050 1050,1290 1290,1710
return and restore user register,

777
00:24:10,000 --> 00:24:11,410
0,180 180,300 300,660 660,840 840,1410
so it's always this indirect

778
00:24:11,410 --> 00:24:13,450
0,690 1020,1290 1290,1470 1470,1680 1680,2040
strategy actually even more indirect

779
00:24:13,450 --> 00:24:15,790
0,150 150,540 810,1200 1200,1740 1740,2340
than this ata threats which

780
00:24:15,910 --> 00:24:16,810
0,150 150,240 240,420 420,780 780,900
where the net effect is

781
00:24:16,810 --> 00:24:18,130
0,120 120,360 360,510 510,1020 1020,1320
to switch from one user

782
00:24:18,130 --> 00:24:19,120
0,660
process.

783
00:24:19,120 --> 00:24:20,880
0,120 120,360 360,600 600,1260
To another user preference.

784
00:24:23,310 --> 00:24:25,320
0,510 570,990 990,1170 1170,1290 1290,2010
A question about this diagram

785
00:24:25,800 --> 00:24:27,140
0,210 210,600
or anything.

786
00:24:29,260 --> 00:24:31,540
0,750 750,990 990,1710 1710,1890 1890,2280
Switched the schedule that happens

787
00:24:31,540 --> 00:24:32,890
0,120 120,510 510,810 810,990 990,1350
in between those two right

788
00:24:33,220 --> 00:24:35,830
0,840 900,1200 1200,1710 2250,2550 2550,2610
yep, all right, let me

789
00:24:35,830 --> 00:24:36,850
0,180 180,330 330,420 420,870 870,1020
talk about the schedule or

790
00:24:37,120 --> 00:24:38,770
0,330 330,690 690,990 990,1080 1080,1650
the real picture is actually

791
00:24:38,800 --> 00:24:41,290
0,600 630,1410 1410,1590 1590,2130 2130,2490
a significantly more complex than

792
00:24:41,980 --> 00:24:42,980
0,420
that.

793
00:24:43,070 --> 00:24:44,390
0,210 210,270 270,360 360,870 870,1320
This is a medium or

794
00:24:44,390 --> 00:24:45,440
0,450
a.

795
00:24:46,690 --> 00:24:47,890
0,210 210,300 300,480 480,720 720,1200
Gonna be more full diagram,

796
00:24:47,890 --> 00:24:48,700
0,120 120,210 210,300 300,390 390,810
let's say we have process

797
00:24:48,700 --> 00:24:50,020
0,630
one.

798
00:24:51,060 --> 00:24:53,340
0,300 300,390 390,1110 1110,1260 1410,2280
Which is executing a process

799
00:24:53,340 --> 00:24:56,250
0,450 450,1140 1230,1680 2130,2790 2790,2910
to which a miserable but

800
00:24:56,250 --> 00:24:58,440
0,150 150,510 510,900 1770,2100 2100,2190
not currently running now the

801
00:24:58,440 --> 00:24:59,670
0,390 390,630 630,690 690,1110 1110,1230
additional layer of details, we

802
00:24:59,670 --> 00:25:01,770
0,180 180,300 300,690 690,1620 1650,2100
actually have multiple cores, a

803
00:25:01,980 --> 00:25:03,270
0,750 750,900 900,1080 1080,1200 1200,1290
x86 let's say we have

804
00:25:03,270 --> 00:25:04,800
0,210 210,780 780,1110 1170,1320 1320,1530
two cores so that means

805
00:25:04,800 --> 00:25:06,960
0,390 480,660 660,720 720,1530 1530,2160
that at the hardware level.

806
00:25:07,680 --> 00:25:10,800
0,780 960,1290 1290,1770 1800,2490 2490,3120
Um, we have CPU zero

807
00:25:10,800 --> 00:25:11,340
0,120 120,240 240,390 390,450 450,540
which is one of the

808
00:25:11,340 --> 00:25:14,370
0,1020 1320,1980 2040,2460 2460,2610 2610,3030
cores and let's say CPU

809
00:25:14,370 --> 00:25:15,340
0,480
one.

810
00:25:20,030 --> 00:25:21,380
0,180 180,240 240,450 450,810 810,1350
And the more full story

811
00:25:21,380 --> 00:25:23,030
0,330 330,600 600,720 720,1020 1020,1650
about how we get from

812
00:25:23,210 --> 00:25:25,120
0,390 390,1320
a executing.

813
00:25:25,150 --> 00:25:27,520
0,270 270,660 660,1470 1500,2190 2220,2370
A user space two in

814
00:25:27,520 --> 00:25:29,470
0,240 240,1170 1170,1680 1680,1770 1770,1950
one process executing in user

815
00:25:29,470 --> 00:25:31,450
0,450 450,690 690,1230 1440,1860 1860,1980
space in another vulnerable but

816
00:25:31,450 --> 00:25:33,460
0,210 210,420 420,660 660,1230 1440,2010
not yet running process, um,

817
00:25:33,880 --> 00:25:34,990
0,330 330,570 570,780 780,870 870,1110
the first part is about

818
00:25:34,990 --> 00:25:36,430
0,60 60,510 510,1020 1050,1170 1170,1440
the same as I talked

819
00:25:36,430 --> 00:25:37,810
0,480 630,900 900,1050 1050,1290 1290,1380
about and may say a

820
00:25:37,810 --> 00:25:40,220
0,450 450,1050 1050,1980
timer interrupt forces.

821
00:25:40,390 --> 00:25:42,070
0,300 300,720 720,1230 1230,1440 1440,1680
A transfer control from the

822
00:25:42,100 --> 00:25:43,870
0,270 270,870 870,930 930,1440 1500,1770
user processes the kernel, the

823
00:25:43,870 --> 00:25:46,900
0,570 570,990 2220,2700 2700,2790 2790,3030
trampoline code saves the user

824
00:25:46,900 --> 00:25:48,490
0,630 630,780 780,1140 1140,1470 1470,1590
registers the trap frame for

825
00:25:48,490 --> 00:25:51,320
0,420 420,990
process one.

826
00:25:51,530 --> 00:25:54,180
0,180 180,330 330,1350 1470,2100
And then executes a.

827
00:25:54,180 --> 00:25:55,740
0,270 270,360 360,720 720,1140 1170,1560
Use a trap which figures

828
00:25:55,740 --> 00:25:56,220
0,90 90,180 180,240 240,360 360,480
out what to do with

829
00:25:56,220 --> 00:25:57,720
0,120 120,600 600,720 720,1410 1410,1500
this trap or interrupt you

830
00:25:57,720 --> 00:25:59,100
0,120 120,450 450,990 1020,1260 1260,1380
know system call let's say

831
00:25:59,100 --> 00:26:00,810
0,210 450,840 990,1260 1260,1650 1650,1710
as a so for a

832
00:26:00,810 --> 00:26:03,060
0,150 150,390 390,510 510,1290 1530,2250
little while we're executing ordinary

833
00:26:03,060 --> 00:26:05,730
0,360 360,660 660,1380 1500,2580 2580,2670
colonel c code on the

834
00:26:05,730 --> 00:26:07,830
0,420 420,900 900,1020 1020,1500 1500,2100
kernel, stack of process one.

835
00:26:10,240 --> 00:26:11,710
0,390 390,570 570,930 930,1350 1350,1470
Let's say process one the

836
00:26:11,710 --> 00:26:13,300
0,270 270,570 570,960 960,1170 1170,1590
kernel code process once decides

837
00:26:13,300 --> 00:26:14,410
0,120 120,390 390,480 480,1020 1020,1110
it wants to yield the

838
00:26:14,410 --> 00:26:16,870
0,840 1710,2070 2070,2220 2220,2280 2280,2460
CPU, it has a bunch

839
00:26:16,870 --> 00:26:17,770
0,90 90,450 450,600 600,720 720,900
of things which will see

840
00:26:17,770 --> 00:26:19,870
0,60 60,480 480,810 840,1290 1740,2100
the details of a that

841
00:26:19,870 --> 00:26:20,620
0,150 150,300 300,360 360,450 450,750
end up in a call

842
00:26:20,620 --> 00:26:22,700
0,120 120,450 450,840 840,1650
to this routine switch.

843
00:26:22,730 --> 00:26:24,350
0,330 330,480 480,870 1440,1560 1560,1620
Just sort of one of

844
00:26:24,350 --> 00:26:25,550
0,60 60,510 510,990 990,1080 1080,1200
the central routines in this

845
00:26:25,550 --> 00:26:28,540
0,510 600,1110 1110,1590 1590,2430
story switch saves away.

846
00:26:28,700 --> 00:26:31,250
0,270 270,480 480,1200 1200,1440 1440,2550
Um, this context that registers

847
00:26:31,280 --> 00:26:32,630
0,270 270,420 510,960 960,1170 1170,1350
for the kernel thread that's

848
00:26:32,630 --> 00:26:33,830
0,270 270,390 390,930 930,1110 1110,1200
running in context one so

849
00:26:33,830 --> 00:26:35,450
0,300 330,720 720,960 960,1050 1050,1620
there's two sets of registers

850
00:26:35,450 --> 00:26:36,980
0,90 90,330 330,1170 1170,1230 1230,1530
the user registers the trap

851
00:26:36,980 --> 00:26:38,020
0,480
frame.

852
00:26:38,020 --> 00:26:39,430
0,150 150,420 420,690 690,1260 1260,1410
The kernel thread registers in

853
00:26:39,430 --> 00:26:40,960
0,180 210,1020
the context.

854
00:26:41,510 --> 00:26:43,880
0,330 900,1440 1440,1710 1710,2070 2070,2370
A switch doesn't actually switch

855
00:26:43,880 --> 00:26:46,130
0,480 480,990 1050,1680 1680,2100 2100,2250
switches from one content from

856
00:26:46,130 --> 00:26:47,450
0,240 240,540 540,690 690,1110 1110,1320
one thread to another, but

857
00:26:47,450 --> 00:26:49,820
0,180 180,840 1080,1350 1350,1830 1830,2370
in fact the way X

858
00:26:49,820 --> 00:26:52,190
0,90 90,780 930,1200 1230,1740 1740,2370
is designed, the only place

859
00:26:52,190 --> 00:26:55,250
0,240 240,630 1470,1950 1950,2700 2730,3060
that a user thread, sorry

860
00:26:55,250 --> 00:26:56,240
0,60 60,390 390,690 690,900 900,990
the kernel thread running on

861
00:26:56,240 --> 00:26:57,560
0,60 60,540 540,690 690,1020 1020,1320
a CPU can switch to

862
00:26:57,680 --> 00:26:59,210
0,240 240,450 450,690 690,780 780,1530
is what's called the scheduler

863
00:26:59,210 --> 00:27:01,240
0,390 390,510 510,750 750,1500
thread for that CPU.

864
00:27:01,240 --> 00:27:02,320
0,510
I'm.

865
00:27:02,910 --> 00:27:04,110
0,240 240,330 330,540 540,720 720,1200
So we can't even switch

866
00:27:04,110 --> 00:27:06,060
0,390 390,510 510,750 750,1440 1680,1950
directly to another process can

867
00:27:06,060 --> 00:27:07,440
0,120 120,540 540,690 690,900 900,1380
only switch to the scheduler

868
00:27:07,440 --> 00:27:09,150
0,240 240,390 390,600 600,990 1020,1710
thread, so there's a um.

869
00:27:10,360 --> 00:27:14,500
0,150 150,870 870,1380 1380,2310 2790,4140
The complete thread apparatus dedicated

870
00:27:14,500 --> 00:27:16,030
0,90 90,180 180,840 840,990 990,1530
to the scheduler for CPU

871
00:27:16,030 --> 00:27:17,170
0,480 510,720 720,840 840,1050 1050,1140
zero since we're running on

872
00:27:17,170 --> 00:27:18,610
0,660 660,900 900,1200 1200,1320 1320,1440
cpus, this switch is going

873
00:27:18,610 --> 00:27:20,380
0,60 60,450 450,960 1380,1590 1590,1770
to switch to a the

874
00:27:20,380 --> 00:27:22,600
0,900 900,1680
previously saved.

875
00:27:22,720 --> 00:27:25,390
0,840 840,990 990,1290 1380,2100 2100,2670
Registers for the scheduler thread,

876
00:27:25,420 --> 00:27:27,340
0,210 210,510 510,1170 1170,1260 1260,1920
so let's schedule a zero.

877
00:27:27,980 --> 00:27:29,200
0,660
I'm.

878
00:27:29,650 --> 00:27:32,080
0,360 1050,1350 1350,1440 1440,2220 2250,2430
And in the scheduler for

879
00:27:32,080 --> 00:27:34,600
0,420 420,990 1020,1710 1710,2130 2310,2520
CPU zero switch will by

880
00:27:34,600 --> 00:27:36,760
0,390 390,570 570,1500 1500,1740 1740,2160
restoring these registers since registers

881
00:27:36,760 --> 00:27:38,440
0,270 270,360 360,750 750,1230 1380,1680
include the stack pointer a

882
00:27:38,440 --> 00:27:39,910
0,180 180,600 600,750 750,1200 1230,1470
the return from switch as

883
00:27:39,940 --> 00:27:42,460
0,510 690,930 930,1260 1260,1950 1950,2520
c well now actually, um.

884
00:27:43,750 --> 00:27:47,350
0,600 600,930 930,1740 2190,2820 2850,3600
Return up to the um.

885
00:27:47,830 --> 00:27:50,020
0,930 960,1650
Scheduler function.

886
00:27:52,420 --> 00:27:53,920
0,570 600,1110 1110,1230 1230,1380 1380,1500
On {CPU's -} are and

887
00:27:53,920 --> 00:27:55,720
0,780 780,870 870,1260 1260,1470 1560,1800
schedule a function will do

888
00:27:55,720 --> 00:27:57,550
0,150 150,690 690,930 930,1290 1290,1830
some cleanup to finish putting

889
00:27:57,610 --> 00:27:58,990
0,330 330,480 480,540 540,1020 1110,1380
process one to sleep then

890
00:27:58,990 --> 00:28:00,730
0,210 210,510 510,690 690,840 840,1740
it'll look in the process,

891
00:28:00,790 --> 00:28:02,020
0,180 180,570 570,690 690,900 900,1230
a table for another process,

892
00:28:02,020 --> 00:28:04,210
0,330 330,480 480,750 750,1380 1620,2190
run a reasonable process, and

893
00:28:04,390 --> 00:28:06,620
0,540 540,660 660,1200 1200,1740
if it finds one.

894
00:28:07,160 --> 00:28:08,210
0,210 210,360 360,660 720,990 990,1050
And so we've sort of

895
00:28:08,210 --> 00:28:09,530
0,210 210,540 540,900 900,1050 1050,1320
gone down here and up

896
00:28:09,530 --> 00:28:11,090
0,210 210,300 300,1020 1140,1470 1470,1560
into the scheduler, if the

897
00:28:11,090 --> 00:28:12,410
0,360 360,660 660,870 870,1200 1200,1320
scheduler finds another process to

898
00:28:12,410 --> 00:28:14,750
0,210 210,300 300,600 600,1410 2010,2340
run or even finds process,

899
00:28:14,750 --> 00:28:15,890
0,180 180,450 450,840 840,960 960,1140
one is reasonable and still

900
00:28:15,890 --> 00:28:16,820
0,180 180,270 270,540 540,690 690,930
wants to run a fine

901
00:28:16,820 --> 00:28:18,200
0,360 360,540 540,840 840,1020 1050,1380
process, one nothing else nothing

902
00:28:18,200 --> 00:28:19,970
0,240 240,450 450,540 540,810 1650,1770
else wants to run but

903
00:28:19,970 --> 00:28:21,110
0,60 60,210 210,450 450,540 540,1140
in any case, the scheduler

904
00:28:21,110 --> 00:28:23,090
0,150 150,660 660,1380 1410,1830 1830,1980
will call switch again to

905
00:28:23,090 --> 00:28:26,510
0,840 870,2010 2430,2610 2610,2880 2880,3420
switch contexts to say process

906
00:28:26,510 --> 00:28:27,460
0,510
two.

907
00:28:27,960 --> 00:28:28,890
0,150 150,240 240,570 570,750 750,930
In the process which will

908
00:28:28,890 --> 00:28:31,110
0,690 690,840 840,1020 1020,1650 1650,2220
save its own registers again

909
00:28:31,110 --> 00:28:33,020
0,120 120,300 300,480 480,1380
in its own context.

910
00:28:33,020 --> 00:28:34,460
0,180 180,420 420,540 540,540 540,1440
Um, they'll be a previously

911
00:28:34,460 --> 00:28:35,780
0,840
saved.

912
00:28:35,870 --> 00:28:37,730
0,630 630,810 810,1020 1020,1440 1440,1860
Context too from whenever process

913
00:28:37,730 --> 00:28:39,680
0,210 210,540 540,990 1170,1560 1560,1950
to left off that those

914
00:28:39,680 --> 00:28:40,970
0,180 180,510 510,600 600,1170 1170,1290
this set of registers will

915
00:28:40,970 --> 00:28:42,440
0,150 150,900
be restored.

916
00:28:42,440 --> 00:28:43,820
0,780 780,960 960,1110 1110,1230 1230,1380
Process two will have made

917
00:28:43,820 --> 00:28:45,800
0,60 60,750 750,1050 1050,1170 1170,1980
a previous call to switch.

918
00:28:46,790 --> 00:28:48,100
0,660
I'm.

919
00:28:48,100 --> 00:28:49,120
0,150 150,390 390,480 480,570 570,1020
To switch to the scheduler

920
00:28:49,120 --> 00:28:50,380
0,330 330,540 540,630 630,1020 1020,1260
thread just like process, one

921
00:28:50,380 --> 00:28:51,550
0,180 180,330 330,450 450,780 780,1170
did when it left off

922
00:28:51,730 --> 00:28:53,110
0,270 270,510 510,540 540,900 900,1380
that called a social return

923
00:28:53,110 --> 00:28:54,640
0,90 90,960
to whatever.

924
00:28:54,860 --> 00:28:56,510
0,450 450,750 750,870 870,1290 1290,1650
System call or interrupt process,

925
00:28:56,510 --> 00:28:58,220
0,270 270,420 420,870 1050,1500 1500,1710
two is n when that's

926
00:28:58,220 --> 00:28:59,570
0,690 810,1020 1020,1140 1140,1260 1260,1350
finished, there will be a

927
00:28:59,570 --> 00:29:01,700
0,810 810,1350 1350,1710 1710,1980 1980,2130
previously saved trap frame for

928
00:29:01,700 --> 00:29:03,470
0,420 420,810 1020,1230 1230,1350 1350,1770
process two that will continue

929
00:29:03,470 --> 00:29:05,120
0,120 120,750 750,960 960,1110 1110,1650
their registers, also be restored

930
00:29:05,120 --> 00:29:07,310
0,300 480,900 1320,1830 1830,2040 2040,2190
or a return back up

931
00:29:07,310 --> 00:29:08,720
0,150 150,390 390,1050
into user space.

932
00:29:09,050 --> 00:29:11,810
0,240 1380,1650 1650,1710 1710,2340 2640,2760
And there's a complete a

933
00:29:11,810 --> 00:29:15,080
0,510 540,1200 1200,1830 1890,2610 2610,3270
separate schedule or a thread

934
00:29:15,080 --> 00:29:16,190
0,180 180,330 330,840 840,1020 1020,1110
for each CPU, so, they'll

935
00:29:16,190 --> 00:29:19,400
0,420 420,660 660,1680 2010,2760
also be saved, um.

936
00:29:19,700 --> 00:29:21,710
0,690 690,930 930,1050 1050,1590 1590,2010
Context for the scheduler thread

937
00:29:21,710 --> 00:29:24,590
0,210 210,630 630,1230 1500,2250 2340,2880
for CPU, one, um and

938
00:29:24,620 --> 00:29:26,540
0,300 300,840 840,1410
a scheduler loop.

939
00:29:27,820 --> 00:29:29,080
0,270 270,390 390,840 840,1140 1140,1260
Running on schedule one and

940
00:29:29,080 --> 00:29:30,790
0,390 390,1170 1170,1230 1230,1320 1320,1710
whatever process you know process

941
00:29:30,790 --> 00:29:32,170
0,210 210,270 270,720 930,1170 1170,1380
three or something is running

942
00:29:32,170 --> 00:29:33,490
0,90 90,480 480,780 780,990 990,1320
on CPU one when it

943
00:29:33,490 --> 00:29:34,300
0,420 420,510 510,630 630,720 720,810
decides to give up the

944
00:29:34,300 --> 00:29:37,120
0,450 450,630 630,1170 1170,1920 2400,2820
CPU, it'll switch into a

945
00:29:37,510 --> 00:29:40,090
0,870 1110,1620 1620,1800 1800,2250 2370,2580
scheduler thread for it for

946
00:29:40,090 --> 00:29:42,020
0,660 690,1320
its CPU.

947
00:29:43,800 --> 00:29:45,210
0,270 270,420 420,660 660,1050 1050,1410
Alright, there's a question where

948
00:29:45,210 --> 00:29:48,360
0,120 120,930 930,1770 2100,2700 2880,3150
the context stored, um, it

949
00:29:48,360 --> 00:29:50,220
0,480 480,780 780,1050 1050,1350 1350,1860
turns out that for the.

950
00:29:50,780 --> 00:29:52,370
0,540 540,660 660,780 780,1140 1140,1590
Operations, I've been talking about

951
00:29:52,550 --> 00:29:55,730
0,480 480,1590 1650,1890 1890,2700 2700,3180
the saved fact always the.

952
00:29:57,250 --> 00:30:00,190
0,270 270,360 360,990 990,2070 2280,2940
For a thread switch, um.

953
00:30:01,030 --> 00:30:03,400
0,510 510,1350 1350,1530 1530,1920 1920,2370
These contexts, these saved register

954
00:30:03,400 --> 00:30:04,600
0,330 330,420 420,690 690,1050 1050,1200
sets for kernel threads are

955
00:30:04,600 --> 00:30:06,610
0,120 120,210 210,660 660,1260 1590,2010
in the process structure so

956
00:30:06,610 --> 00:30:07,960
0,330 330,570 570,870 870,1200 1200,1350
any given kernel thread can

957
00:30:07,960 --> 00:30:09,790
0,450 780,1020 1020,1500 1500,1740 1740,1830
only have one set of

958
00:30:09,790 --> 00:30:12,380
0,750 750,1110 1110,2100
saved colonel registers.

959
00:30:12,380 --> 00:30:14,180
0,300 300,540 540,810 810,1230 1500,1800
Because each thread is only

960
00:30:14,180 --> 00:30:15,770
0,450 450,780 780,1080 1080,1500 1500,1590
executing a single place and

961
00:30:15,770 --> 00:30:17,810
0,150 150,960 1140,1410 1410,1500 1500,2040
its context kind of reflects

962
00:30:17,810 --> 00:30:19,190
0,330 330,930 930,1050 1050,1140 1140,1380
that place that it was

963
00:30:19,190 --> 00:30:20,690
0,540 540,690 690,810 810,1080 1080,1500
executing on it left off

964
00:30:20,690 --> 00:30:22,070
0,480 480,720 720,810 810,900 900,1380
a thread is a single

965
00:30:22,460 --> 00:30:23,600
0,420 420,510 510,960 960,1140 1140,1140
threat of control so a

966
00:30:23,600 --> 00:30:25,430
0,570 690,1230 1230,1410 1410,1620 1620,1830
thread really only needs one

967
00:30:25,430 --> 00:30:27,530
0,810 870,1050 1050,1140 1140,1920 1950,2100
context full of registers, so

968
00:30:27,530 --> 00:30:28,580
0,90 90,180 180,240 240,600 600,1050
it's in the process structures,

969
00:30:28,580 --> 00:30:30,280
0,270 270,900
p arrow.

970
00:30:31,510 --> 00:30:33,760
0,630 630,930 930,1680
Mhm dpr context.

971
00:30:35,310 --> 00:30:36,810
0,240 240,300 300,840 840,990 990,1500
And the scheduler, each scheduler

972
00:30:36,810 --> 00:30:38,670
0,270 270,450 450,630 630,1260 1320,1860
thread has its own context

973
00:30:38,670 --> 00:30:39,900
0,150 150,420 420,840 840,960 960,1230
which actually not in the

974
00:30:40,230 --> 00:30:41,790
0,300 300,360 360,900 900,1470 1470,1560
there's no process associated with

975
00:30:41,790 --> 00:30:43,980
0,390 570,1170 1170,1590 1830,2100 2100,2190
this scheduler thread, this is

976
00:30:43,980 --> 00:30:45,080
0,510
actually.

977
00:30:45,080 --> 00:30:46,280
0,120 120,600 600,690 690,1110 1110,1200
A {scheduler's -} context is

978
00:30:46,280 --> 00:30:47,680
0,390 390,780 1020,1200
stored in a.

979
00:30:47,680 --> 00:30:50,710
0,630 630,1590 1890,2220 2220,2460 2460,3030
Destruct CPU for that core.

980
00:30:51,480 --> 00:30:52,320
0,180 180,270 270,600 600,660 660,840
There's an array of these

981
00:30:52,320 --> 00:30:53,700
0,330 330,390 390,1020 1050,1260 1260,1380
{CPU's -} trucks one per

982
00:30:53,700 --> 00:30:54,810
0,420 420,510 510,720 720,930 930,1110
core, each one as a

983
00:30:55,080 --> 00:30:56,400
0,780
context.

984
00:30:58,210 --> 00:30:59,380
0,390 390,690 690,840 840,1050 1050,1170
A question why can't we

985
00:30:59,380 --> 00:31:00,730
0,450 450,690 690,1230 1230,1290 1290,1350
include the registers in the

986
00:31:00,730 --> 00:31:02,200
0,300 300,510 510,600 600,690 690,1470
trap frame for the process,

987
00:31:02,230 --> 00:31:04,330
0,450 480,720 720,1260 1560,1920 1920,2100
um that is, um, you

988
00:31:04,330 --> 00:31:05,640
0,90 90,480 480,720
know actually the.

989
00:31:06,940 --> 00:31:08,290
0,240 240,660 660,900 900,1020 1020,1350
Those registers could be stored

990
00:31:08,290 --> 00:31:09,040
0,60 60,120 120,450 450,600 600,750
in the trap rain which

991
00:31:09,040 --> 00:31:10,750
0,330 450,1020 1020,1200 1200,1380 1380,1710
made because there's only one

992
00:31:10,750 --> 00:31:12,340
0,360 360,660 660,1020
safe set of.

993
00:31:12,340 --> 00:31:15,040
0,330 330,690 690,1710 1920,2220 2220,2700
Kernel thread registers for process,

994
00:31:15,040 --> 00:31:15,820
0,90 90,270 270,570 570,690 690,780
we could save them in

995
00:31:15,820 --> 00:31:17,710
0,210 210,480 480,1230 1410,1710 1710,1890
any data structure for which

996
00:31:17,710 --> 00:31:20,410
0,180 180,990 1140,1740 1740,1890 2280,2700
there's one element of instance

997
00:31:20,410 --> 00:31:22,030
0,90 90,240 240,450 450,930 930,1620
of that data structure process,

998
00:31:22,270 --> 00:31:24,550
0,480 480,660 660,1500 1500,2130 2130,2280
there's one struck process, there's

999
00:31:24,550 --> 00:31:25,780
0,240 240,600 600,900 900,1110 1110,1230
one struck trap frame for

1000
00:31:25,780 --> 00:31:27,340
0,600 720,1050 1050,1230 1230,1500 1500,1560
process, we could store the

1001
00:31:27,340 --> 00:31:28,450
0,390 390,450 450,540 540,780 780,1110
registers in the trap frame.

1002
00:31:29,130 --> 00:31:30,220
0,570
I'm.

1003
00:31:31,730 --> 00:31:32,750
0,150 150,540 540,750 750,930 930,1020
I mean just sort of

1004
00:31:32,750 --> 00:31:33,720
0,390
for.

1005
00:31:33,720 --> 00:31:35,310
0,360 360,1020 1020,1110 1110,1500 1500,1590
Maybe simplicity or clarity of

1006
00:31:35,310 --> 00:31:36,720
0,420 420,540 540,840 840,1350 1350,1410
code, the trap frame I

1007
00:31:36,720 --> 00:31:37,640
0,330
think.

1008
00:31:37,640 --> 00:31:40,280
0,510 510,1140 1140,1890 2010,2400 2400,2640
Entirely consists of data that's

1009
00:31:40,280 --> 00:31:41,810
0,330 330,660 690,1110 1110,1230 1230,1530
needed when entering and leaving

1010
00:31:41,810 --> 00:31:43,060
0,90 90,690
the colonel.

1011
00:31:43,060 --> 00:31:45,010
0,360 510,720 720,960 960,1620 1620,1950
And the struck context is

1012
00:31:45,730 --> 00:31:46,840
0,510 510,630 630,720 720,1020 1020,1110
consists of the stuff that

1013
00:31:46,840 --> 00:31:47,470
0,120 120,180 180,270 270,540 540,630
needs to be saved and

1014
00:31:47,470 --> 00:31:49,180
0,450 450,780 780,1290 1290,1530 1530,1710
restored when switching to and

1015
00:31:49,180 --> 00:31:51,190
0,510 570,1050 1050,1260 1320,1650 1650,2010
from between the kernel thread

1016
00:31:51,190 --> 00:31:53,120
0,150 150,360 480,960 960,1350
and the scheduler thread.

1017
00:31:54,640 --> 00:31:55,870
0,240 240,600 600,720 720,990 990,1230
Okay question is yield something

1018
00:31:55,870 --> 00:31:56,860
0,150 150,420 420,540 540,630 630,990
that's called by the user

1019
00:31:56,860 --> 00:31:57,670
0,60 60,120 120,480 480,690 690,810
of the colonel's called by

1020
00:31:57,670 --> 00:31:58,800
0,90 90,540
the kernel.

1021
00:31:59,060 --> 00:32:00,890
0,300 300,630 660,1110 1110,1500 1500,1830
So the user threads, there's

1022
00:32:00,890 --> 00:32:01,880
0,270 270,420 420,450 450,780 780,990
not really a direct way

1023
00:32:01,880 --> 00:32:03,050
0,240 240,540 540,750 750,870 870,1170
in X six four user

1024
00:32:03,050 --> 00:32:05,870
0,390 390,660 810,1260 1260,1740 1980,2820
threads to talk about I'm

1025
00:32:06,080 --> 00:32:08,240
0,600 600,660 660,1230 1230,1320 1320,2160
yielding the CPU or switching

1026
00:32:08,480 --> 00:32:10,160
0,390 390,750 780,1230 1230,1530 1530,1680
a that it's done by

1027
00:32:10,160 --> 00:32:12,320
0,90 90,660 690,900 900,1050 1050,2160
the kernel kind of transparently.

1028
00:32:13,210 --> 00:32:14,110
0,120 120,240 240,540 540,810 810,900
You know it points in

1029
00:32:14,110 --> 00:32:15,130
0,240 240,330 330,390 390,660 660,1020
time when the colonel feels

1030
00:32:15,130 --> 00:32:16,510
0,210 360,570 570,810 810,930 930,1380
that it needs to happen

1031
00:32:16,810 --> 00:32:18,850
0,150 150,330 330,1110 1650,1980 1980,2040
if their threads there are

1032
00:32:18,850 --> 00:32:20,280
0,450 450,840
sometimes when.

1033
00:32:21,190 --> 00:32:22,960
0,330 330,570 570,810 810,990 990,1770
You can sort of guess

1034
00:32:22,960 --> 00:32:24,490
0,210 210,750 750,810 810,1140 1140,1530
that probably a certain system

1035
00:32:24,490 --> 00:32:25,960
0,570 600,960 960,1290 1290,1380 1380,1470
call will result in a

1036
00:32:25,960 --> 00:32:28,690
0,540 540,870 1560,1830 1830,1950 1950,2730
yield like if a process

1037
00:32:28,720 --> 00:32:29,710
0,210 210,360 360,780 780,900 900,990
does a read on a

1038
00:32:29,710 --> 00:32:31,150
0,420 420,570 570,690 690,1230 1230,1440
pipe where it knows that

1039
00:32:31,150 --> 00:32:32,200
0,210 210,540 540,660 660,960 960,1050
really nothing is waiting to

1040
00:32:32,200 --> 00:32:33,190
0,120 120,300 300,360 360,510 510,990
be read in that pipe,

1041
00:32:33,400 --> 00:32:34,660
0,630 660,840 840,930 930,1140 1140,1260
um, then the read will

1042
00:32:34,660 --> 00:32:35,780
0,630
block.

1043
00:32:35,870 --> 00:32:36,920
0,150 150,240 240,750 750,840 840,1050
You can predict the reed

1044
00:32:36,920 --> 00:32:38,390
0,450 450,540 540,720 720,1020 1050,1470
block and that the colonel

1045
00:32:38,390 --> 00:32:39,300
0,300
role.

1046
00:32:39,300 --> 00:32:40,860
0,330 330,540 540,780 780,1320 1320,1560
Run some other process while

1047
00:32:40,860 --> 00:32:42,180
0,240 450,840 840,960 960,1230 1230,1320
we're waiting for data to

1048
00:32:42,180 --> 00:32:43,540
0,270 270,360 360,420 420,750
appear in the pipe.

1049
00:32:44,800 --> 00:32:46,360
0,450 720,930 930,1020 1020,1380 1380,1560
Um, so the times when

1050
00:32:46,360 --> 00:32:47,350
0,420 420,540 540,840 840,900 900,990
yield is called in the

1051
00:32:47,350 --> 00:32:48,640
0,450 450,630 630,840 840,1050 1050,1290
kernel, there's really two main

1052
00:32:48,640 --> 00:32:49,750
0,300 300,510 510,810 840,1050 1050,1110
times, one is if a

1053
00:32:49,750 --> 00:32:52,210
0,600 720,1080 1080,1290 1290,1890 2130,2460
timer interrupt goes off a

1054
00:32:52,240 --> 00:32:54,760
0,300 300,600 600,1410 1620,2190 2220,2520
kernel always yields you know

1055
00:32:54,760 --> 00:32:55,560
0,360
just.

1056
00:32:55,560 --> 00:32:57,400
0,450 450,540 540,900 900,1200
On the theory that.

1057
00:32:57,640 --> 00:32:59,800
0,390 390,750 750,1110 1140,1890 1890,2160
Um, we should interleave the

1058
00:32:59,800 --> 00:33:02,140
0,600 600,900 1230,1770 2070,2250 2250,2340
execution of of all the

1059
00:33:02,140 --> 00:33:03,190
0,360 360,480 480,660 660,720 720,1050
process that want to run

1060
00:33:03,190 --> 00:33:04,940
0,270 270,690 690,1350
on timer interrupt.

1061
00:33:05,180 --> 00:33:08,000
0,1320 1590,1890 1890,2130 2130,2460 2460,2820
Periods so time runner also

1062
00:33:08,000 --> 00:33:10,040
0,270 270,570 570,1020 1410,1650 1650,2040
always calls yield and whenever

1063
00:33:10,040 --> 00:33:11,420
0,90 90,780 780,870 870,1140 1140,1380
a process a system calls

1064
00:33:11,420 --> 00:33:13,910
0,570 840,1110 1110,1860 1950,2400 2400,2490
waiting for io waiting for

1065
00:33:13,910 --> 00:33:14,630
0,90 90,180 180,390 390,480 480,720
you to type the next

1066
00:33:14,630 --> 00:33:16,190
0,570 570,900 900,1020 1020,1440 1440,1560
keystroke does a read of

1067
00:33:16,190 --> 00:33:17,330
0,150 150,720 720,810 810,900 900,1140
the console and you haven't

1068
00:33:17,330 --> 00:33:19,430
0,240 240,450 450,780 1080,1800 1800,2100
typed key yet than the.

1069
00:33:20,620 --> 00:33:21,790
0,150 150,660 660,780 780,1020 1020,1170
The machinery to wait for

1070
00:33:21,790 --> 00:33:24,280
0,810 870,1290 1320,1710 1710,2280 2280,2490
io, a calls yields called

1071
00:33:24,280 --> 00:33:25,420
0,120 120,900
from sleep.

1072
00:33:25,420 --> 00:33:26,350
0,300 300,390 390,570 570,720 720,930
Something, we'll talk about next

1073
00:33:26,350 --> 00:33:27,280
0,300
week.

1074
00:33:29,200 --> 00:33:30,760
0,600
Alright.

1075
00:33:31,540 --> 00:33:33,760
0,1230 1230,1410 1410,1650 1650,1860 1860,2220
Okay so you want another

1076
00:33:33,760 --> 00:33:35,620
0,630 660,1260
question, yes.

1077
00:33:35,700 --> 00:33:36,930
0,480 480,720 720,870 870,1050 1050,1230
Oh, if it is a

1078
00:33:36,930 --> 00:33:38,670
0,600 630,1110 1110,1470 1470,1650 1650,1740
sleep isn't gonna do the

1079
00:33:38,670 --> 00:33:40,500
0,390 390,690 690,1350 1410,1650 1650,1830
same thing roughly there's gonna

1080
00:33:40,500 --> 00:33:42,660
0,120 120,600 960,1230 1230,1620 1620,2160
be some a system called

1081
00:33:42,690 --> 00:33:44,040
0,480 480,690 690,990 990,1050 1050,1350
there's gonna save the trap

1082
00:33:44,040 --> 00:33:47,280
0,480 750,1260 1530,2070 2190,2790 2820,3240
frame and a then basically

1083
00:33:47,280 --> 00:33:48,840
0,60 60,240 240,570 570,900 1290,1560
the same picture but it's

1084
00:33:48,840 --> 00:33:51,000
0,540 840,1230 1260,1650
just a then.

1085
00:33:51,000 --> 00:33:53,280
0,300 300,570 570,960 1230,1770 1890,2280
The thing that made the

1086
00:33:53,280 --> 00:33:54,600
0,570 570,690 690,870 870,960 960,1320
process go into the kernel

1087
00:33:54,600 --> 00:33:55,800
0,330 330,420 420,720 720,810 810,1200
without a timer and trapped

1088
00:33:55,800 --> 00:33:56,740
0,360
bud.

1089
00:33:56,870 --> 00:33:57,900
0,480
I'm.

1090
00:33:57,900 --> 00:34:01,890
0,1740 2580,2910 2910,3120 3120,3240 3240,3990
Yeah yeah, so the process

1091
00:34:01,920 --> 00:34:03,210
0,240 240,420 420,540 540,870 870,1290
make there's a read system

1092
00:34:03,210 --> 00:34:04,020
0,300 300,390 390,540 540,690 690,810
call and that's why it's

1093
00:34:04,020 --> 00:34:05,300
0,90 90,150 150,690
in the kernel.

1094
00:34:05,330 --> 00:34:07,670
0,630 930,1110 1110,1740 1740,2250 2250,2340
And the read requires the

1095
00:34:07,670 --> 00:34:08,810
0,330 330,480 480,810 810,990 990,1140
process to wait for the

1096
00:34:08,810 --> 00:34:09,980
0,690
disk.

1097
00:34:10,010 --> 00:34:11,210
0,120 120,300 300,510 510,780 780,1200
To do to finish reading

1098
00:34:11,210 --> 00:34:12,230
0,240 240,390 390,630 630,720 720,1020
or to wait for data

1099
00:34:12,230 --> 00:34:13,220
0,180 180,510 510,600 600,630 630,990
to appear on a pipe

1100
00:34:13,310 --> 00:34:14,660
0,210 210,630 690,870 870,1290 1290,1350
then actually the diagram is

1101
00:34:14,660 --> 00:34:16,310
0,480 480,570 570,990 990,1110 1110,1650
exactly the same as this,

1102
00:34:16,400 --> 00:34:18,180
0,390 480,1230
the no.

1103
00:34:18,510 --> 00:34:19,290
0,210 210,270 270,510 510,690 690,780
And the colonel with a

1104
00:34:19,290 --> 00:34:21,090
0,270 270,810 810,1050 1050,1620 1650,1800
system called trap frame all

1105
00:34:21,090 --> 00:34:22,500
0,150 150,450 450,660 660,1110 1110,1410
the saved user register, execute

1106
00:34:22,500 --> 00:34:23,310
0,90 90,360 360,510 510,570 570,810
the system called the system

1107
00:34:23,310 --> 00:34:24,840
0,270 270,660 690,1050 1140,1470 1470,1530
whole rely a need to

1108
00:34:24,840 --> 00:34:25,530
0,150 150,240 240,330 330,600 600,690
wait for the disk to

1109
00:34:25,530 --> 00:34:28,080
0,240 240,480 480,1020 1950,2130 2130,2550
finish reading something the system

1110
00:34:28,080 --> 00:34:29,400
0,210 210,480 480,570 570,750 750,1320
call code will call sleep

1111
00:34:29,400 --> 00:34:31,770
0,630 750,990 990,1110 1110,1440 1440,2370
which ends up coding switch.

1112
00:34:32,180 --> 00:34:35,480
0,510 780,1470 1470,1770 1770,1980 1980,3300
Which saves away the kernels

1113
00:34:35,600 --> 00:34:37,520
0,600 600,1200 1200,1290 1290,1380 1380,1920
thread registers in the process

1114
00:34:37,520 --> 00:34:40,550
0,630 930,1590 1590,1710 1710,2250 2550,3030
context switches to this currency

1115
00:34:40,550 --> 00:34:41,540
0,150 150,540 540,630 630,810 810,990
few scheduled to let some

1116
00:34:41,540 --> 00:34:43,580
0,240 240,540 540,1140 1170,1830 1830,2040
other thread run, while this

1117
00:34:43,580 --> 00:34:44,900
0,420 420,810 810,1140 1140,1230 1230,1320
thread is waiting for the

1118
00:34:44,900 --> 00:34:46,560
0,390 390,480 480,1080
discrete to finish.

1119
00:34:46,590 --> 00:34:47,850
0,420 540,990 990,1080 1080,1200 1200,1260
So everything we're going to

1120
00:34:47,850 --> 00:34:49,320
0,240 240,480 480,840 870,1350 1350,1470
talk about now except for

1121
00:34:49,320 --> 00:34:51,810
0,90 90,510 510,1200 1650,2220 2250,2490
the timer interrupt, um is

1122
00:34:51,810 --> 00:34:53,550
0,360 360,570 570,660 660,1290 1290,1740
pretty much the same if

1123
00:34:53,880 --> 00:34:54,870
0,300 300,540 540,720 720,840 840,990
what's going on is we're

1124
00:34:54,870 --> 00:34:55,740
0,90 90,120 120,480 480,810 810,870
in a system called the

1125
00:34:55,740 --> 00:34:57,330
0,360 360,930 960,1230 1230,1320 1320,1590
system call needs to wait

1126
00:34:57,330 --> 00:34:58,830
0,120 120,360 420,600 600,1140 1350,1500
for some for io and

1127
00:34:58,830 --> 00:35:00,320
0,120 120,240 240,330 330,870
give up the CPU.

1128
00:35:01,040 --> 00:35:02,080
0,480
Yeah.

1129
00:35:02,250 --> 00:35:03,780
0,330 330,420 420,780 780,900 900,1530
For the purposes of today's

1130
00:35:03,780 --> 00:35:05,310
0,450 450,660 750,930 930,1440 1440,1530
discussion, the two situations are

1131
00:35:05,310 --> 00:35:06,720
0,270 270,780
almost identical.

1132
00:35:07,560 --> 00:35:08,680
0,600
Shoot.

1133
00:35:08,970 --> 00:35:10,170
0,330 330,480 480,630 630,1020 1020,1200
Okay, so the question does

1134
00:35:10,170 --> 00:35:11,460
0,240 240,450 450,810 810,1200 1200,1290
each per CPU schedule has

1135
00:35:11,460 --> 00:35:13,590
0,120 120,240 240,630 630,1560 1830,2130
its own stack, yes there's

1136
00:35:13,590 --> 00:35:15,560
0,450 450,1440
a stack.

1137
00:35:15,870 --> 00:35:17,260
0,870
I'm.

1138
00:35:18,600 --> 00:35:21,030
0,330 330,1110 1110,1530 1830,2310 2310,2430
This scheduler a stack for

1139
00:35:21,030 --> 00:35:22,900
0,210 210,750 750,1320
this separate stack.

1140
00:35:23,730 --> 00:35:26,250
0,540 540,1260 1590,2070 2070,2160 2160,2520
A four scheduled for CPU

1141
00:35:26,250 --> 00:35:27,120
0,270
one.

1142
00:35:27,630 --> 00:35:28,760
0,570
HMM.

1143
00:35:31,920 --> 00:35:33,570
0,270 270,630 630,1080 1080,1200 1200,1650
Yeah, and indeed the stacks

1144
00:35:33,570 --> 00:35:35,010
0,90 90,240 240,450 450,690 690,1440
for this guy's also setup.

1145
00:35:36,300 --> 00:35:38,040
0,300 300,570 600,990 990,1200 1200,1740
In fact, all this stuff

1146
00:35:38,070 --> 00:35:39,510
0,150 150,210 210,330 330,1320 1320,1440
you know the context and

1147
00:35:39,510 --> 00:35:41,160
0,90 90,690 690,780 780,840 840,1650
the stacks with a scheduler

1148
00:35:41,160 --> 00:35:42,600
0,750 750,870 870,1170 1170,1350 1350,1440
threads are set up in

1149
00:35:42,600 --> 00:35:43,860
0,180 180,630 630,960 960,1140 1140,1260
a different way than for

1150
00:35:43,860 --> 00:35:46,420
0,300 300,1200
user processes.

1151
00:35:46,450 --> 00:35:47,530
0,270 270,540 540,660 660,780 780,1080
They're set up at boot

1152
00:35:47,530 --> 00:35:49,450
0,600 750,1140 1140,1230 1230,1500 1500,1920
time, if you poke around

1153
00:35:49,450 --> 00:35:51,550
0,240 630,1350 1350,1710 1710,2010 2010,2100
and start dot s or

1154
00:35:51,550 --> 00:35:53,950
0,300 300,540 540,1110 1830,2250 2250,2400
start dot c dot s

1155
00:35:53,950 --> 00:35:54,970
0,270 270,390 390,720 720,930 930,1020
probably you'll see some of

1156
00:35:54,970 --> 00:35:57,940
0,90 90,750 930,1350 1380,2010 2040,2970
the setup for each course

1157
00:35:57,940 --> 00:35:59,770
0,630 630,1080 1080,1290 1290,1500 1620,1830
scheduler thread there's a place

1158
00:35:59,770 --> 00:36:00,880
0,120 120,750
with stack.

1159
00:36:01,000 --> 00:36:02,290
0,330 330,630 630,780 780,900 900,1290
Very early in the assembly

1160
00:36:02,290 --> 00:36:03,850
0,240 240,450 450,780 810,1350 1350,1560
code during boot where the

1161
00:36:03,850 --> 00:36:05,080
0,450 450,570 570,840 840,1020 1020,1230
stack is set up for

1162
00:36:05,080 --> 00:36:06,760
0,600 630,1140 1140,1260 1260,1470 1470,1680
each CPU and it's on

1163
00:36:06,760 --> 00:36:08,140
0,210 210,540 540,720 720,1230 1230,1380
that stack, {that's -} a

1164
00:36:08,140 --> 00:36:10,150
0,420 420,810 810,1320 1500,1830 1830,2010
CPU boots on and then

1165
00:36:10,150 --> 00:36:11,880
0,300 300,420 420,870 870,1170
runs its scheduler thread.

1166
00:36:15,590 --> 00:36:17,600
0,630 690,1290
Okay, I'm.

1167
00:36:18,930 --> 00:36:20,430
0,270 270,540 540,750 750,870 870,1500
A one piece of jargon

1168
00:36:20,430 --> 00:36:21,960
0,630 780,1020 1020,1230 1230,1350 1350,1530
a when people talk about

1169
00:36:21,960 --> 00:36:24,220
0,780 810,1740
context switch.

1170
00:36:24,840 --> 00:36:27,360
0,360 360,540 540,930 930,1530 1560,2520
Um, they're talking about usually.

1171
00:36:28,720 --> 00:36:30,120
0,810
I'm.

1172
00:36:30,590 --> 00:36:32,870
0,840 870,1560 1560,1650 1650,2100 2100,2280
This act of switching from

1173
00:36:32,870 --> 00:36:34,220
0,270 270,780 780,900 900,1200 1200,1350
one thread to another by

1174
00:36:34,220 --> 00:36:35,630
0,450 450,690 690,870 870,960 960,1410
saving one set of register

1175
00:36:35,630 --> 00:36:37,040
0,510 510,630 630,720 720,930 930,1410
sets for the old thread

1176
00:36:37,220 --> 00:36:39,500
0,270 270,870 900,1440 1440,1680 1680,2280
and restoring previously saved registers

1177
00:36:39,500 --> 00:36:40,460
0,120 120,210 210,480 480,570 570,960
for the threads were switching

1178
00:36:40,460 --> 00:36:42,500
0,270 1140,1350 1350,1560 1560,1890 1890,2040
to that's what's usually meant

1179
00:36:42,500 --> 00:36:44,300
0,150 150,570 570,750 750,1170 1170,1800
by context which also sometimes

1180
00:36:44,300 --> 00:36:46,010
0,150 150,540 540,630 630,720 720,1710
it's applied to the complete.

1181
00:36:47,100 --> 00:36:48,300
0,600 600,720 720,900 900,1080 1080,1200
Dance that goes on when

1182
00:36:48,300 --> 00:36:49,860
0,360 360,510 510,690 690,960 960,1560
switching from one user process

1183
00:36:49,890 --> 00:36:51,090
0,90 90,390 390,480 480,1080 1080,1200
to another and occasionally you'll

1184
00:36:51,090 --> 00:36:52,770
0,150 150,630 630,810 810,1200 1200,1680
see context which apply to

1185
00:36:52,890 --> 00:36:54,810
0,750 750,1140 1140,1410 1410,1500 1500,1920
switching between user and kernel,

1186
00:36:54,930 --> 00:36:56,250
0,180 300,750 750,900 900,1020 1020,1320
but for us we mostly

1187
00:36:56,250 --> 00:36:57,680
0,180 180,330 420,810
mean it, um.

1188
00:36:58,260 --> 00:36:59,640
0,360 420,810 810,960 960,1110 1110,1380
A switching from one kernel

1189
00:36:59,640 --> 00:37:00,700
0,480
thread.

1190
00:37:01,300 --> 00:37:02,580
0,330 330,660
Typically true.

1191
00:37:02,860 --> 00:37:04,600
0,450 450,480 480,810
Schedule a threat.

1192
00:37:04,980 --> 00:37:07,200
0,480 990,1350 1350,1650 1860,2160 2160,2220
I'm just some pieces of

1193
00:37:07,200 --> 00:37:09,740
0,930
information.

1194
00:37:10,100 --> 00:37:12,830
0,420 870,1140 1140,1890 1980,2370 2490,2730
The utter insanity to keep

1195
00:37:12,830 --> 00:37:15,140
0,60 60,600 780,1290 1440,1950 1950,2310
in mind I'm every core

1196
00:37:15,140 --> 00:37:16,040
0,210 210,360 360,630 630,810 810,900
just does one thing at

1197
00:37:16,040 --> 00:37:17,990
0,60 60,540 570,930 930,1590 1620,1950
a time each core you

1198
00:37:17,990 --> 00:37:19,100
0,90 90,210 210,570 570,750 750,1110
know is either is just.

1199
00:37:19,520 --> 00:37:20,870
0,240 240,570 570,1080 1080,1200 1200,1350
Running one thread at any

1200
00:37:20,870 --> 00:37:22,190
0,180 180,450 450,600 600,930 930,1320
given time, it's either running

1201
00:37:22,190 --> 00:37:24,410
0,570 570,1560 1560,1800 1800,1860 1860,2220
some processes use a thread

1202
00:37:24,410 --> 00:37:26,510
0,180 180,600 600,960 960,1290 1320,2100
some process kernel thread or

1203
00:37:26,510 --> 00:37:28,370
0,240 240,570 570,1050 1050,1380 1680,1860
that course scheduler thread, so

1204
00:37:28,370 --> 00:37:29,150
0,90 90,240 240,450 450,720 720,780
at any given time the

1205
00:37:29,150 --> 00:37:30,560
0,540 540,690 690,870 870,1050 1050,1410
corridor is not doing multiple

1206
00:37:30,560 --> 00:37:31,550
0,270 270,420 420,570 570,750 750,990
things, it's just doing one

1207
00:37:31,550 --> 00:37:33,140
0,300 300,810 810,930 930,1080 1080,1590
thing and it's this switching

1208
00:37:33,140 --> 00:37:33,920
0,120 120,270 270,330 330,690 690,780
that sort of creates the

1209
00:37:33,920 --> 00:37:37,340
0,780 780,1230 1500,2100 2100,2820 3030,3420
illusion of multiple threads running

1210
00:37:37,340 --> 00:37:38,810
0,150 150,450 450,1170 1170,1320 1320,1470
at different times on that

1211
00:37:38,810 --> 00:37:41,240
0,390 810,1980
core, similarly.

1212
00:37:41,660 --> 00:37:44,440
0,600 930,1350 1350,2220
Um, each thread.

1213
00:37:44,560 --> 00:37:47,500
0,660 1140,1590 1590,1800 2310,2460 2460,2940
Is running on is either

1214
00:37:47,500 --> 00:37:50,320
0,360 360,810 1320,1860 1860,2130 2130,2820
running on exactly one core

1215
00:37:50,740 --> 00:37:52,780
0,630 1050,1290 1290,1560 1560,1740 1740,2040
or its state has been

1216
00:37:52,780 --> 00:37:54,250
0,330 330,450 450,600 600,1350 1350,1470
state has been saved and

1217
00:37:54,250 --> 00:37:55,570
0,150 150,540 540,780 780,990 990,1320
we switched away from it.

1218
00:37:56,280 --> 00:37:58,020
0,360 360,780 990,1170 1170,1560 1560,1740
So, so a thread just

1219
00:37:58,020 --> 00:37:59,010
0,60 60,150 150,480 480,720 720,990
to be clear thread never

1220
00:37:59,010 --> 00:37:59,970
0,240 240,360 360,630 630,750 750,960
runs on more than one

1221
00:37:59,970 --> 00:38:01,140
0,300 300,600 600,690 690,930 930,1170
core thread is either running

1222
00:38:01,140 --> 00:38:02,490
0,120 120,330 330,510 510,1020 1050,1350
on just one core or

1223
00:38:02,490 --> 00:38:03,510
0,120 120,360 360,570 570,660 660,1020
it's not running at all,

1224
00:38:03,540 --> 00:38:05,310
0,420 450,630 630,1020 1020,1350 1350,1770
as a safe state somewhere.

1225
00:38:06,610 --> 00:38:08,950
0,510 870,1590 1590,2010 2010,2160 2160,2340
Um, another interesting thing about

1226
00:38:08,950 --> 00:38:10,690
0,90 90,660 660,1200 1230,1470 1470,1740
the x86 setup is that

1227
00:38:10,780 --> 00:38:14,080
0,330 330,1350 1350,1500 1500,2190 2310,3300
these contexts that hold saved.

1228
00:38:14,640 --> 00:38:18,120
0,810 840,1590 1590,2550 2790,3150 3150,3480
Kernel thread registers, they're always

1229
00:38:18,120 --> 00:38:19,290
0,360 360,480 480,600 600,1020 1020,1170
produced by a call to

1230
00:38:19,290 --> 00:38:21,990
0,990 1380,1920 2160,2400 2400,2490 2490,2700
switch a and so these

1231
00:38:21,990 --> 00:38:25,290
0,510 510,990 1290,1890 1890,2610 2610,3300
contexts basically always refer to

1232
00:38:25,500 --> 00:38:27,210
0,390 390,780 780,900 900,1020 1020,1710
the state of the thread

1233
00:38:27,240 --> 00:38:29,100
0,420 420,480 480,690 690,1410 1410,1860
as it was executing inside

1234
00:38:29,100 --> 00:38:30,840
0,60 60,360 360,450 450,1320
a call to switch.

1235
00:38:30,930 --> 00:38:32,500
0,540
I'm.

1236
00:38:33,240 --> 00:38:34,410
0,540 570,720 720,810 810,960 960,1170
And you know the way

1237
00:38:34,410 --> 00:38:35,400
0,150 150,330 330,540 540,720 720,990
we'll see that come up

1238
00:38:35,400 --> 00:38:37,560
0,150 150,420 510,750 750,1170 1650,2160
is that when we switch

1239
00:38:37,560 --> 00:38:38,760
0,120 120,390 390,750 750,1050 1050,1200
from one to another and

1240
00:38:38,760 --> 00:38:40,200
0,660 660,750 750,1140 1140,1380 1380,1440
restore the target {thread's -}

1241
00:38:40,200 --> 00:38:41,850
0,750 900,1110 1110,1440 1440,1560 1560,1650
context, the first thing it

1242
00:38:41,850 --> 00:38:43,080
0,120 120,360 360,540 540,1050 1050,1230
will do is return from

1243
00:38:43,080 --> 00:38:45,240
0,180 180,900 900,1260 1260,1380 1380,2160
a previous call to switch

1244
00:38:45,390 --> 00:38:47,130
0,240 240,810 810,960 960,1410 1410,1740
these contexts are always save

1245
00:38:47,130 --> 00:38:48,240
0,570
state.

1246
00:38:48,270 --> 00:38:49,470
0,360 390,660 660,750 750,990 990,1200
In as it is in

1247
00:38:49,470 --> 00:38:50,720
0,690
switch.

1248
00:38:52,490 --> 00:38:53,760
0,690
Okay.

1249
00:38:54,150 --> 00:38:55,440
0,540
HMMM.

1250
00:38:56,060 --> 00:38:57,470
0,180 180,330 330,780 780,1080 1080,1410
Any more questions about the.

1251
00:38:58,610 --> 00:39:00,960
0,660 660,1080 1080,1710
Diagram level situation.

1252
00:39:05,240 --> 00:39:06,470
0,240 240,420 420,570 570,660 660,1230
A I have a question,

1253
00:39:06,740 --> 00:39:07,970
0,180 180,360 360,750 750,900 900,1230
you are using the term

1254
00:39:07,970 --> 00:39:09,230
0,300 300,450 450,540 540,930 930,1260
credit all the time, but

1255
00:39:09,260 --> 00:39:10,160
0,120 120,360 360,480 480,600 600,900
it seems to me like

1256
00:39:10,160 --> 00:39:11,780
0,210 210,1050 1050,1320 1320,1470 1470,1620
our implementation for aix v

1257
00:39:11,780 --> 00:39:14,390
0,720 1080,1380 1380,2040 2040,2280 2280,2610
six a process is if

1258
00:39:14,510 --> 00:39:16,100
0,150 150,480 480,810 810,1200 1350,1590
there's only one thread, so

1259
00:39:16,100 --> 00:39:17,540
0,120 120,510 510,660 660,1140 1140,1440
it couldn't be possible that

1260
00:39:17,540 --> 00:39:19,100
0,270 270,660 660,810 810,1080 1080,1560
one process could have multiple

1261
00:39:19,100 --> 00:39:20,720
0,360 360,750 1080,1260 1260,1320 1320,1620
threads or am I wrong

1262
00:39:20,720 --> 00:39:21,560
0,330
here.

1263
00:39:21,740 --> 00:39:23,760
0,210 210,420 420,600 600,1470
In aix v six.

1264
00:39:23,760 --> 00:39:25,280
0,210 210,870
Right now.

1265
00:39:26,030 --> 00:39:28,400
0,300 300,750 750,1140 1560,2130 2130,2370
There's definitely some confusing things

1266
00:39:28,400 --> 00:39:29,090
0,180 180,270 270,390 390,540 540,690
about the way we use

1267
00:39:29,090 --> 00:39:30,440
0,120 120,480 480,780 810,1020 1050,1350
the words here in aix

1268
00:39:30,440 --> 00:39:32,000
0,150 150,1020
v six.

1269
00:39:32,260 --> 00:39:34,720
0,480 600,870 870,1890
Um, a process.

1270
00:39:35,400 --> 00:39:36,720
0,810
I'm.

1271
00:39:38,470 --> 00:39:41,620
0,870 1140,1680 1680,1830 1830,2520 2520,3150
A process is either executing

1272
00:39:41,620 --> 00:39:44,830
0,1140 1470,1590 1590,1890 1890,2310 2460,3210
instructions, a user level or

1273
00:39:45,460 --> 00:39:48,340
0,360 360,870 870,2340 2610,2790 2790,2880
it's executing instructions in the

1274
00:39:48,340 --> 00:39:49,600
0,660
kernel.

1275
00:39:49,780 --> 00:39:51,200
0,660
OR.

1276
00:39:51,700 --> 00:39:52,900
0,210 210,390 390,870 870,960 960,1200
It's not executed at all

1277
00:39:52,900 --> 00:39:53,740
0,90 90,240 240,540 540,690 690,840
and its state has been

1278
00:39:53,740 --> 00:39:56,020
0,390 390,930 930,1170 1170,1470 1470,2280
saved away into this combination

1279
00:39:56,020 --> 00:39:58,570
0,600 630,780 780,1740 1980,2430 2430,2550
of a context and a

1280
00:39:58,570 --> 00:39:59,920
0,360 360,870
trap frame.

1281
00:40:00,300 --> 00:40:01,420
0,540
I'm.

1282
00:40:02,300 --> 00:40:03,920
0,360 360,540 540,660 660,930 930,1620
So that's the actual situation,

1283
00:40:03,980 --> 00:40:04,610
0,240 240,390 390,450 450,570 570,630
now what you want to

1284
00:40:04,610 --> 00:40:06,140
0,360 360,960
call that.

1285
00:40:06,140 --> 00:40:07,600
0,780
I'm.

1286
00:40:09,060 --> 00:40:10,050
0,180 180,540 540,600 600,870 870,990
You call it what you

1287
00:40:10,050 --> 00:40:11,700
0,690 750,990 990,1260 1260,1470 1470,1650
like, I I don't know

1288
00:40:11,700 --> 00:40:12,900
0,90 90,180 180,540 540,1080 1080,1200
of a simple explanation for

1289
00:40:12,900 --> 00:40:14,910
0,180 180,1050 1260,1410 1410,1860 1860,2010
this structure, um, we've been

1290
00:40:14,910 --> 00:40:16,110
0,450 450,570 570,720 720,840 840,1200
calling it I've been calling

1291
00:40:16,110 --> 00:40:18,480
0,210 480,870 870,1020 1020,1770 1950,2370
it I've been saying that

1292
00:40:18,510 --> 00:40:20,640
0,270 270,720 720,930 930,1140 1140,2130
each process has two threads.

1293
00:40:21,100 --> 00:40:23,240
0,210 210,510 510,780 780,1560
A user level thread.

1294
00:40:23,580 --> 00:40:24,930
0,180 180,240 240,570 570,810 810,1350
And a kernel level thread

1295
00:40:25,080 --> 00:40:26,400
0,180 180,360 360,420 420,1110 1110,1320
and that's a process there's

1296
00:40:26,400 --> 00:40:27,660
0,210 210,690 690,810 810,870 870,1260
this restriction that a process

1297
00:40:27,660 --> 00:40:29,250
0,150 150,570 570,840 1050,1200 1200,1590
is only X is either

1298
00:40:29,250 --> 00:40:30,660
0,510 510,600 600,690 690,1170 1200,1410
executing in the kernel in

1299
00:40:30,660 --> 00:40:33,030
0,90 90,390 390,1110 1200,1950 1950,2370
the user space or executing

1300
00:40:33,030 --> 00:40:34,320
0,60 60,150 150,510 510,810 840,1290
in the kernel inner interrupter

1301
00:40:34,320 --> 00:40:36,240
0,330 330,750 1110,1260 1260,1470 1470,1920
system called but never booked.

1302
00:40:38,680 --> 00:40:41,050
0,390 420,570 570,750 750,1140 1170,2370
Hmm that makes sense, yeah

1303
00:40:41,050 --> 00:40:43,210
0,450 450,1050 1050,1140 1140,1560 1560,2160
I apologize for the complexity

1304
00:40:43,210 --> 00:40:45,040
0,90 90,570
of this.

1305
00:40:47,540 --> 00:40:48,620
0,570
Okay.

1306
00:40:48,710 --> 00:40:49,910
0,390 420,660 660,840 840,930 930,1200
Okay, so let me switch

1307
00:40:49,910 --> 00:40:51,140
0,90 90,780 780,960 960,1080 1080,1230
to code, looking at the

1308
00:40:51,140 --> 00:40:52,820
0,270 270,480 480,1080
X six code.

1309
00:41:01,130 --> 00:41:03,590
0,690 1200,1560 1560,1680 1680,2370 2370,2460
Um, right, so first of

1310
00:41:03,590 --> 00:41:04,820
0,660
all.

1311
00:41:10,090 --> 00:41:12,670
0,780 810,990 990,1170 1170,1980 2130,2580
Um I just wanna just

1312
00:41:13,180 --> 00:41:14,560
0,840 840,1020 1020,1080 1080,1140 1140,1380
show some of the stuff

1313
00:41:14,560 --> 00:41:15,580
0,90 90,180 180,540 540,960 960,1020
we've been talking about I'm

1314
00:41:15,580 --> 00:41:16,480
0,120 120,180 180,390 390,510 510,900
going to look at the.

1315
00:41:17,060 --> 00:41:18,460
0,810
I'm.

1316
00:41:19,250 --> 00:41:20,880
0,450 450,1050
Process structure.

1317
00:41:20,970 --> 00:41:21,720
0,210 210,300 300,420 420,660 660,750
And we can see in

1318
00:41:21,720 --> 00:41:22,650
0,90 90,420 420,720 720,780 780,930
the process structure, a lot

1319
00:41:22,650 --> 00:41:23,250
0,60 60,180 180,390 390,510 510,600
of the things we've been

1320
00:41:23,250 --> 00:41:25,830
0,330 330,630 1140,1680 1890,2370 2370,2580
talking about I'm just for

1321
00:41:25,830 --> 00:41:27,940
0,420 420,690 690,960 960,1530
review, there's the um.

1322
00:41:30,760 --> 00:41:32,830
0,180 180,810 930,1230 1260,1770 1770,2070
A frame that saves the.

1323
00:41:33,480 --> 00:41:35,560
0,300 300,570 570,1500
User level registers.

1324
00:41:36,440 --> 00:41:39,680
0,900 930,1290 1290,2190 2190,2670
There's a context here.

1325
00:41:40,480 --> 00:41:43,210
0,270 270,780 780,1020 1800,2430 2430,2730
That saves the kernel thread

1326
00:41:43,210 --> 00:41:44,860
0,600 600,780 780,1260 1260,1380 1380,1650
registers, we switch to the

1327
00:41:44,890 --> 00:41:46,520
0,540 540,1110
scheduler thread.

1328
00:41:46,580 --> 00:41:47,780
0,330 330,630
There's a.

1329
00:41:47,870 --> 00:41:50,090
0,750 1140,1500 1500,1590 1590,1770 1770,2220
A pointer to this process

1330
00:41:50,090 --> 00:41:51,560
0,300 330,720 720,1230 1230,1380 1380,1470
is kernel stack, which is

1331
00:41:51,560 --> 00:41:53,810
0,390 660,1350 1350,1620 1620,1650 1650,2250
where function calls are saved

1332
00:41:53,960 --> 00:41:54,980
0,300 300,390 390,840 840,930 930,1020
while we're executing in the

1333
00:41:54,980 --> 00:41:56,020
0,510
kernel.

1334
00:41:56,560 --> 00:41:58,780
0,390 630,960 960,1140 1140,1590 1590,2220
Um, there's this state variable

1335
00:41:58,780 --> 00:42:01,390
0,480 510,1410 1410,1710 1710,1950 1950,2610
which records whether this process

1336
00:42:01,390 --> 00:42:03,550
0,630 690,1500 1500,1680 1680,2100 2100,2160
is running or rubble or

1337
00:42:03,550 --> 00:42:05,380
0,570 570,780 810,1140 1140,1680 1680,1830
sleeping or not allocated at

1338
00:42:05,380 --> 00:42:06,320
0,420
all.

1339
00:42:06,550 --> 00:42:08,800
0,570 660,810 810,960 960,1650
Um, and then finally.

1340
00:42:09,120 --> 00:42:10,530
0,240 240,450 450,540 540,1080 1080,1410
Um, there's a lock that

1341
00:42:10,650 --> 00:42:12,060
0,510 510,810 810,1140 1140,1290 1290,1410
protects various things as we'll

1342
00:42:12,060 --> 00:42:14,220
0,600 660,1440
see, um.

1343
00:42:14,330 --> 00:42:15,620
0,750
I'm.

1344
00:42:15,710 --> 00:42:17,540
0,150 150,480 480,720
For now it.

1345
00:42:17,690 --> 00:42:18,830
0,150 150,330 330,660 660,810 810,1140
We can observe that at

1346
00:42:18,830 --> 00:42:21,350
0,240 240,900 1500,1830 1830,2400 2400,2520
least protects a changes to

1347
00:42:21,350 --> 00:42:23,810
0,150 150,630 630,1320 2130,2340 2340,2460
the state variable so that

1348
00:42:23,810 --> 00:42:26,060
0,120 120,780 1590,1800 1800,2160 2160,2250
for example to schedule a

1349
00:42:26,060 --> 00:42:27,500
0,300 300,510 510,690 690,900 930,1440
threats, don't try to grab

1350
00:42:27,500 --> 00:42:28,760
0,150 150,480 480,960 960,1080 1080,1260
a reasonable process and run

1351
00:42:28,760 --> 00:42:29,720
0,210 210,300 300,390 390,630 630,960
it at the same time.

1352
00:42:30,300 --> 00:42:31,260
0,360 360,450 450,510 510,720 720,960
One of the many things

1353
00:42:31,260 --> 00:42:32,280
0,150 150,360 360,600 600,720 720,1020
this lock does is prevent

1354
00:42:32,280 --> 00:42:33,660
0,150 150,300 300,690
that from happening.

1355
00:42:35,280 --> 00:42:36,240
0,270 270,480 480,780 780,960 960,960
I'm gonna run a um,

1356
00:42:36,930 --> 00:42:38,820
0,420 450,870 870,1200 1200,1620 1620,1890
a simple demo program for

1357
00:42:38,820 --> 00:42:41,200
0,270 510,630 630,1200 1200,1860
you to spin program.

1358
00:42:41,460 --> 00:42:43,140
0,750 780,960 960,1230 1230,1320 1320,1680
Um, I'm using it mostly

1359
00:42:43,140 --> 00:42:45,330
0,360 390,540 540,1320 1320,1620 1830,2190
just to drive the sort

1360
00:42:45,330 --> 00:42:47,220
0,60 60,390 390,630 660,1260 1260,1890
of create a predictable situation

1361
00:42:47,220 --> 00:42:48,810
0,90 90,540 780,1140 1140,1440 1440,1590
in which we switch from

1362
00:42:48,810 --> 00:42:50,310
0,150 150,390 390,510 510,900 1080,1500
one thread to another, but

1363
00:42:50,310 --> 00:42:52,530
0,240 240,1020 1200,1470 1470,1980 1980,2220
this is this program spin

1364
00:42:52,530 --> 00:42:54,960
0,480 990,1530 1530,1710 1710,2310 2310,2430
program creates two processes and

1365
00:42:54,960 --> 00:42:56,850
0,90 90,630 630,900 900,1350 1350,1890
the processes both compute forever.

1366
00:42:57,320 --> 00:43:00,120
0,150 150,450 450,1260 1620,2250
You call fork here.

1367
00:43:00,320 --> 00:43:02,330
0,180 180,300 300,390 390,1080 1350,2010
I make a child, um,

1368
00:43:02,420 --> 00:43:05,360
0,300 300,810 900,1770 2100,2430 2430,2940
and then forever, both children

1369
00:43:05,360 --> 00:43:06,860
0,270 270,780 780,1080 1110,1410 1410,1500
both children just sit in

1370
00:43:06,860 --> 00:43:08,240
0,210 210,450 450,570 570,1020 1020,1380
this loop and everyone's mail

1371
00:43:08,240 --> 00:43:09,260
0,210 210,270 270,750 750,930 930,1020
print a character just so

1372
00:43:09,260 --> 00:43:10,130
0,120 120,300 330,540 540,660 660,870
we can see they're making

1373
00:43:10,130 --> 00:43:12,350
0,630 870,1440 1710,1890 1890,2040 2040,2220
progress, but they don't print

1374
00:43:12,350 --> 00:43:14,660
0,360 360,570 570,990 990,1320 1740,2310
characters very often, and they

1375
00:43:14,660 --> 00:43:16,790
0,690 720,930 930,1110 1260,1980 1980,2130
never sort of intentionally give

1376
00:43:16,790 --> 00:43:18,050
0,120 120,210 210,780 810,1050 1050,1260
up the CPU, so what

1377
00:43:18,050 --> 00:43:19,100
0,90 90,270 270,390 390,540 540,1050
we have here is to

1378
00:43:19,610 --> 00:43:21,620
0,510 510,660 660,960 960,1140 1140,2010
essentially to compute bound processes

1379
00:43:21,740 --> 00:43:22,820
0,390 390,510 510,720 720,840 840,1080
and in order for both

1380
00:43:22,820 --> 00:43:23,480
0,60 60,210 210,360 360,570 570,660
of them to run, I'm

1381
00:43:23,480 --> 00:43:24,320
0,150 150,360 360,480 480,660 660,840
gonna run them on a

1382
00:43:24,320 --> 00:43:26,340
0,570 570,1620
single CPU.

1383
00:43:26,780 --> 00:43:28,460
0,540 750,1020 1020,1140 1140,1560 1560,1680
A X B six that

1384
00:43:28,460 --> 00:43:29,990
0,240 240,450 450,660 660,1200 1260,1530
is only one core and

1385
00:43:29,990 --> 00:43:30,650
0,150 150,240 240,390 390,510 510,660
so in order for both

1386
00:43:30,650 --> 00:43:31,880
0,60 60,150 150,240 240,840 960,1230
of them to execute you

1387
00:43:31,880 --> 00:43:32,450
0,150 150,300 300,420 420,480 480,570
know it's going to be

1388
00:43:32,450 --> 00:43:34,820
0,630 630,1170 1350,1800
necessary to um.

1389
00:43:35,110 --> 00:43:37,990
0,510 630,1260 2250,2670 2670,2730 2730,2880
To switching between the two

1390
00:43:37,990 --> 00:43:39,480
0,810
processes.

1391
00:43:40,440 --> 00:43:42,500
0,240 240,360 360,810 810,1410
Let me fire up.

1392
00:43:42,960 --> 00:43:45,120
0,360 390,900 900,1620 1650,1890 1890,2160
A spin program under G

1393
00:43:45,120 --> 00:43:46,180
0,480
B.

1394
00:43:49,760 --> 00:43:50,900
0,540
I'm.

1395
00:43:51,020 --> 00:43:51,950
0,270 270,330 330,570 570,840 840,930
Around the spin program and

1396
00:43:51,950 --> 00:43:53,180
0,90 90,210 210,420 420,570 570,1230
you can see it's printing

1397
00:43:53,210 --> 00:43:55,400
0,330 330,450 450,780 1260,1560 1560,2190
one of the two processes

1398
00:43:55,400 --> 00:43:56,930
0,480 480,870 870,1320 1320,1440 1440,1530
prints forward slash and the

1399
00:43:56,930 --> 00:43:58,520
0,180 180,630 630,1020 1020,1470 1470,1590
other prints backward slash and

1400
00:43:58,520 --> 00:43:59,660
0,90 90,210 210,450 450,630 750,1140
you can see that every

1401
00:43:59,660 --> 00:44:01,640
0,270 270,330 330,840 1080,1800 1800,1980
once in awhile A X

1402
00:44:01,640 --> 00:44:03,050
0,120 120,480 480,630 630,1020 1020,1410
B six is switching between

1403
00:44:03,050 --> 00:44:03,740
0,120 120,240 240,390 390,480 480,690
them and only has one

1404
00:44:03,740 --> 00:44:05,060
0,510 540,660 660,780 780,870 870,1320
core the way I've configured

1405
00:44:05,060 --> 00:44:06,800
0,210 420,990 1080,1380 1380,1560 1560,1740
it so we see a

1406
00:44:06,920 --> 00:44:08,960
0,240 240,330 330,990 990,1560 1560,2040
bunch of forward slashes printing

1407
00:44:08,960 --> 00:44:10,670
0,120 120,540 660,1260 1260,1320 1320,1710
and then apparently a timer

1408
00:44:10,670 --> 00:44:12,590
0,330 330,630 630,810 810,1440 1470,1920
interrupt, most go off a

1409
00:44:12,860 --> 00:44:14,660
0,720 720,810 810,1080 1080,1680 1680,1800
switch, the one CPU to

1410
00:44:14,660 --> 00:44:15,740
0,90 90,240 240,750 750,840 840,1080
the other process and then

1411
00:44:16,070 --> 00:44:17,090
0,540 540,660 660,810 810,960 960,1020
prints the other kind of

1412
00:44:17,090 --> 00:44:18,200
0,360 360,450 450,480 480,840 900,1110
slash for a while, so

1413
00:44:18,200 --> 00:44:19,010
0,120 120,180 180,330 330,390 390,810
what I want to observe

1414
00:44:19,010 --> 00:44:20,660
0,390 420,510 510,1080 1080,1350 1350,1650
is the timer going off

1415
00:44:20,810 --> 00:44:21,320
0,150 150,210 210,330 330,480 480,510
so I'm gonna put a

1416
00:44:21,320 --> 00:44:22,660
0,360 360,1020
break point.

1417
00:44:23,580 --> 00:44:25,140
0,330 330,1050
And trap.

1418
00:44:26,940 --> 00:44:29,070
0,300 300,360 360,960 960,1320 1440,2130
And in particular at line

1419
00:44:29,070 --> 00:44:30,920
0,240 240,570 570,1290
two seven entrap.

1420
00:44:35,060 --> 00:44:38,840
0,690 690,1020 1020,1470 1920,2520 2790,3780
Um, which is a code

1421
00:44:39,020 --> 00:44:40,220
0,570
in.

1422
00:44:40,490 --> 00:44:41,920
0,780
I'm.

1423
00:44:42,840 --> 00:44:45,240
0,450 450,630 630,1020 1020,1740 2100,2400
Trap in dev {inter's -}

1424
00:44:45,240 --> 00:44:48,090
0,390 480,1110 1140,2370 2370,2580 2580,2850
at a recognizes that um

1425
00:44:48,090 --> 00:44:49,530
0,210 210,480 480,1230 1230,1350 1350,1440
we're an interrupt and the

1426
00:44:49,530 --> 00:44:51,060
0,450 450,750 780,1320 1320,1440 1440,1530
interrupt was caused by a

1427
00:44:51,060 --> 00:44:52,540
0,420 420,990
timer interrupt.

1428
00:44:53,430 --> 00:44:54,900
0,630 900,1170 1170,1260 1260,1440 1440,1470
Um, so I put a

1429
00:44:54,900 --> 00:44:57,870
0,210 210,480 480,1140 1140,2190 2610,2970
break point here at trap

1430
00:44:57,870 --> 00:45:00,300
0,240 240,1080 1380,1590 1590,2010 2010,2430
dot c two seven and

1431
00:45:00,420 --> 00:45:03,300
0,900 1170,2460 2460,2520 2520,2790 2790,2880
continue boom, the trap I

1432
00:45:03,300 --> 00:45:04,830
0,420 420,570 570,780 780,1200 1200,1530
triggers right away because timer

1433
00:45:04,830 --> 00:45:06,390
0,270 270,330 330,570 570,1020 1320,1560
apps are pretty frequent and

1434
00:45:06,390 --> 00:45:07,290
0,90 90,180 180,360 360,510 510,900
we can tell from where

1435
00:45:07,290 --> 00:45:08,700
0,210 210,600 600,780 780,1080 1080,1410
that indeed when user trap

1436
00:45:08,700 --> 00:45:09,690
0,150 150,300 300,390 390,810 810,990
and use a trap has

1437
00:45:09,690 --> 00:45:12,240
0,420 420,690 690,1170 1710,2010 2010,2550
called dev inter to handle

1438
00:45:12,240 --> 00:45:13,360
0,150 150,690
this interrupt.

1439
00:45:13,480 --> 00:45:15,910
0,270 270,810 1020,1440 1440,2040 2040,2430
I wanna take finish to

1440
00:45:15,970 --> 00:45:17,140
0,300 300,450 450,540 540,750 750,1170
get out of debt interest

1441
00:45:17,140 --> 00:45:18,400
0,270 270,450 450,660 660,750 750,1260
back into use a trap.

1442
00:45:18,940 --> 00:45:20,160
0,660
I'm.

1443
00:45:20,420 --> 00:45:21,230
0,210 210,270 270,480 480,540 540,810
Because, in fact we don't.

1444
00:45:22,640 --> 00:45:23,900
0,240 240,420 420,720 720,870 870,1260
The code endeavor into overtime

1445
00:45:23,900 --> 00:45:25,250
0,120 120,300 300,630 630,900 900,1350
or no says almost nothing.

1446
00:45:27,340 --> 00:45:28,780
0,450 450,660 660,750 750,1080 1080,1440
However, once we're back at

1447
00:45:28,840 --> 00:45:30,180
0,750
um.

1448
00:45:32,680 --> 00:45:35,260
0,630 960,1380 1380,2130
A user trap.

1449
00:45:36,200 --> 00:45:37,370
0,240 240,390 390,540 540,900 900,1170
Um, we can see that

1450
00:45:37,910 --> 00:45:39,440
0,510 660,870 870,1080 1080,1260 1260,1530
from a this line here

1451
00:45:39,440 --> 00:45:41,000
0,240 480,960 960,1140 1140,1410 1410,1560
that we just returned from

1452
00:45:41,000 --> 00:45:43,780
0,210 210,630
deb enter.

1453
00:45:47,860 --> 00:45:51,340
0,360 1770,2160 2610,3060 3060,3210 3210,3480
And the interesting thing about

1454
00:45:51,340 --> 00:45:53,600
0,240 240,450 450,930 990,1590
this is that um.

1455
00:45:54,340 --> 00:45:55,420
0,300 300,540 540,660 660,990 990,1080
Um what we're about to

1456
00:45:55,420 --> 00:45:57,640
0,600 1110,1260 1260,1650 1650,2040 2040,2220
do, I'm looking forward we're

1457
00:45:57,640 --> 00:45:59,020
0,390 390,480 480,660 660,870 870,1380
currently at this line here

1458
00:45:59,140 --> 00:46:01,390
0,600 660,900 900,1200 1200,1650 1650,2250
and we're looking forward to

1459
00:46:01,420 --> 00:46:03,010
0,240 240,450 450,690 690,780 780,1590
a this called the yield.

1460
00:46:03,730 --> 00:46:06,010
0,510 570,1170 1170,1290 1290,1740 1740,2280
When Devin to return to

1461
00:46:06,040 --> 00:46:07,300
0,150 150,240 240,600 600,780 780,1260
you can see from this,

1462
00:46:07,450 --> 00:46:08,980
0,390 390,450 450,960 960,1170 1170,1530
um, you return is two

1463
00:46:08,980 --> 00:46:10,330
0,150 510,780 780,960 960,1290 1290,1350
to two is basically the

1464
00:46:10,330 --> 00:46:11,710
0,360 360,810 990,1200 1200,1260 1260,1380
device number and we're going

1465
00:46:11,710 --> 00:46:12,820
0,60 60,270 270,540 660,990 990,1110
to see that by and

1466
00:46:12,820 --> 00:46:15,370
0,630 660,1140 1500,1740 1740,2070 2070,2550
by a because which devices

1467
00:46:15,370 --> 00:46:18,010
0,510 1110,1650 1950,2280 2280,2520 2520,2640
to a user, perhaps going

1468
00:46:18,010 --> 00:46:19,740
0,60 60,300 300,810 810,1290
to call yield twitchell.

1469
00:46:19,770 --> 00:46:21,180
0,240 240,360 360,960 960,1080 1080,1410
Go to CPU and allows

1470
00:46:21,180 --> 00:46:23,070
0,330 330,450 450,1140 1590,1710 1710,1890
pushing the process, you'll see

1471
00:46:23,070 --> 00:46:24,390
0,150 150,240 240,270 270,630 840,1320
that in a moment, meantime

1472
00:46:24,390 --> 00:46:25,710
0,390 390,660 660,750 750,1050 1050,1320
let's look at what was

1473
00:46:25,710 --> 00:46:27,540
0,570 570,1200 1200,1350 1350,1440 1440,1830
currently executing when the interrupt

1474
00:46:27,540 --> 00:46:29,190
0,420 600,990 990,1260 1260,1350 1350,1650
happened, I'm going to print

1475
00:46:29,190 --> 00:46:30,320
0,630
p.

1476
00:46:31,010 --> 00:46:32,660
0,270 270,420 420,900 1020,1320 1320,1650
Um the variable p holds

1477
00:46:32,660 --> 00:46:34,310
0,180 630,930 930,1020 1020,1230 1260,1650
a pointer to the current

1478
00:46:34,310 --> 00:46:36,520
0,570 570,1080 1080,1650
processes struck proc.

1479
00:46:36,810 --> 00:46:38,140
0,750
I'm.

1480
00:46:38,890 --> 00:46:40,030
0,330 330,390 390,750 750,900 900,1140
Okay, the question what makes

1481
00:46:40,030 --> 00:46:42,790
0,210 210,780 780,1200 1200,1740 2190,2760
each processes kernel thread different.

1482
00:46:43,260 --> 00:46:46,110
0,480 480,1530 1890,2130 2130,2220 2220,2850
Every process has a separate

1483
00:46:46,110 --> 00:46:47,780
0,480 480,1200
kernel thread.

1484
00:46:47,930 --> 00:46:50,090
0,450 450,690 690,1080 1080,1830 1830,2160
There's really two things that

1485
00:46:50,090 --> 00:46:52,490
0,990 990,1260 1260,1770 1770,2130 2130,2400
differentiate different processes kernel threat

1486
00:46:52,490 --> 00:46:53,240
0,180 180,390 390,480 480,630 630,750
because more than one could

1487
00:46:53,240 --> 00:46:55,670
0,90 90,690 690,1020 1500,1770 1770,2430
be executing on different cores.

1488
00:46:57,650 --> 00:46:58,910
0,300 300,420 420,840 840,1050 1050,1260
One is indeed that every

1489
00:46:58,910 --> 00:47:00,980
0,780 930,1140 1140,1200 1200,1530 1530,2070
process has a separate kernel

1490
00:47:01,400 --> 00:47:02,840
0,540 540,630 630,810 810,1020 1020,1440
stack and that's what's pointed

1491
00:47:02,840 --> 00:47:04,610
0,120 120,270 270,570 990,1380 1380,1770
to by that case stack

1492
00:47:04,610 --> 00:47:06,710
0,450 450,540 540,900 900,1380 1860,2100
element of struck proc and

1493
00:47:06,710 --> 00:47:08,680
0,120 120,390 390,780 780,1440
the other is that.

1494
00:47:09,530 --> 00:47:11,040
0,900
I'm.

1495
00:47:13,490 --> 00:47:16,600
0,510 810,1500 1500,2190
Um, early in.

1496
00:47:16,600 --> 00:47:17,890
0,240 240,540 540,930 930,1080 1080,1290
When user trap which is

1497
00:47:17,890 --> 00:47:18,730
0,60 60,120 120,240 240,570 570,840
you know the c code

1498
00:47:18,730 --> 00:47:20,140
0,120 120,870
is called.

1499
00:47:20,380 --> 00:47:22,210
0,270 270,450 450,1020 1020,1440 1440,1830
A bi trampoline, um, interrupt

1500
00:47:22,210 --> 00:47:24,340
0,510
occurs.

1501
00:47:25,640 --> 00:47:26,780
0,180 180,360 360,840 840,960 960,1140
We can tell by this

1502
00:47:26,780 --> 00:47:28,700
0,270 270,420 420,630 630,1380
call them by any.

1503
00:47:28,700 --> 00:47:30,320
0,270 270,570 570,930 930,1200 1290,1620
Any kernel code can tell

1504
00:47:30,320 --> 00:47:32,270
0,150 150,480 480,720 720,1230 1260,1950
by calling my proc what

1505
00:47:32,270 --> 00:47:34,700
0,540 780,1560 1560,1710 1710,2070 2130,2430
the processes is running on

1506
00:47:34,700 --> 00:47:36,620
0,90 90,480 480,1350
the current CPU.

1507
00:47:36,620 --> 00:47:37,550
0,180 180,360 360,600 600,720 720,930
And that's another thing that

1508
00:47:37,550 --> 00:47:39,860
0,1110 1110,1740
differentiates a.

1509
00:47:40,500 --> 00:47:42,750
0,120 120,600 600,960 1710,1890 1890,2250
That allows each that allows

1510
00:47:42,750 --> 00:47:43,890
0,300 300,510 510,600 600,750 750,1140
kernel code to tell what

1511
00:47:43,890 --> 00:47:45,420
0,690 690,870 870,1140 1140,1290 1380,1530
process it's part of that

1512
00:47:45,420 --> 00:47:47,160
0,180 180,720 720,1260 1260,1530 1530,1740
is which processes kernel thread

1513
00:47:47,160 --> 00:47:48,540
0,150 150,690 690,1110 1110,1230 1230,1380
is executing and what my

1514
00:47:48,540 --> 00:47:49,620
0,330 330,390 390,570 570,900 900,1080
product I'll just basically use

1515
00:47:49,620 --> 00:47:50,940
0,120 120,540 540,1020 1020,1200 1200,1320
the teepee register which you

1516
00:47:50,940 --> 00:47:53,460
0,120 120,690 1140,1800 2010,2250 2250,2520
may recall, um is set

1517
00:47:53,460 --> 00:47:55,200
0,150 150,240 240,930 930,1230 1320,1740
up to contain the current

1518
00:47:55,410 --> 00:47:56,500
0,720
corps.

1519
00:47:56,500 --> 00:47:58,300
0,510 510,960 960,1080 1080,1350 1350,1800
Heart ID or core number,

1520
00:47:58,360 --> 00:47:59,500
0,240 240,450 450,660 660,780 780,1140
it uses that to index

1521
00:47:59,500 --> 00:48:01,000
0,210 210,270 270,810 810,900 900,1500
into an array of structures

1522
00:48:01,000 --> 00:48:02,950
0,180 570,1050 1050,1260 1260,1470 1470,1950
that say for each core

1523
00:48:02,980 --> 00:48:04,840
0,120 120,210 210,660 660,1290 1320,1860
that the scheduler sets whenever

1524
00:48:04,840 --> 00:48:06,940
0,60 60,450 450,1020 1020,1290 1560,2100
it switches processes to indicate

1525
00:48:06,940 --> 00:48:08,230
0,120 120,270 270,480 480,840 840,1290
for each core which process

1526
00:48:08,230 --> 00:48:09,490
0,120 120,480 480,660 660,840 840,1260
is running on that core.

1527
00:48:10,660 --> 00:48:12,160
0,420 540,810 810,960 960,1170 1170,1500
Um, and so that's how

1528
00:48:12,220 --> 00:48:14,360
0,270 270,690 690,780 780,1500
different kernels are differentiated.

1529
00:48:15,730 --> 00:48:16,420
0,270 270,420 420,450 450,570 570,690
Okay so I was going

1530
00:48:16,420 --> 00:48:17,650
0,60 60,150 150,330 330,510 510,1230
to use that p value,

1531
00:48:17,710 --> 00:48:20,050
0,750 1170,1890 1890,1980 1980,2160 2160,2340
the name and that p

1532
00:48:20,050 --> 00:48:20,860
0,240 240,300 300,480 480,540 540,810
value to figure out what

1533
00:48:20,860 --> 00:48:22,600
0,510 510,660 660,1050 1050,1440 1440,1740
process is running {66 -}

1534
00:48:22,600 --> 00:48:23,560
0,450 450,510 510,720 720,840 840,960
remembers the name it's that

1535
00:48:23,560 --> 00:48:25,990
0,390 390,1080 1110,1530 1560,2160 2160,2430
spin process just exactly as

1536
00:48:25,990 --> 00:48:28,150
0,690 930,1530 1590,1830 1830,1950 1950,2160
expected a there were two

1537
00:48:28,150 --> 00:48:29,620
0,90 90,570 840,1080 1080,1350 1350,1470
of them I think with

1538
00:48:29,620 --> 00:48:31,570
0,480 480,960 960,1200 1200,1350 1350,1950
process IDs three and four.

1539
00:48:32,150 --> 00:48:33,380
0,630
Oops.

1540
00:48:34,680 --> 00:48:36,000
0,330 330,450 450,720 720,1110 1110,1320
Um, we're currently executed again

1541
00:48:36,000 --> 00:48:37,890
0,420 420,750 750,1260 1440,1650 1650,1890
process ID three so after

1542
00:48:37,890 --> 00:48:39,090
0,60 60,360 360,510 510,1110 1110,1200
the switch we'd expect to

1543
00:48:39,090 --> 00:48:40,080
0,180 180,450
be in.

1544
00:48:40,110 --> 00:48:41,820
0,450 450,780 780,1290 1320,1470 1470,1710
Process ID for the other

1545
00:48:41,820 --> 00:48:44,730
0,330 330,1080 1350,2040 2490,2730 2730,2910
spin process, um, how come

1546
00:48:44,730 --> 00:48:45,390
0,120 120,240 240,480 480,570 570,660
we can look at the

1547
00:48:45,390 --> 00:48:47,610
0,720 750,1350 1350,2070 2070,2160 2160,2220
saved user registers in the

1548
00:48:47,610 --> 00:48:49,100
0,360 360,780
trap frame.

1549
00:48:54,600 --> 00:48:55,740
0,210 210,420 420,540 540,660 660,1140
And these are the 32

1550
00:48:55,740 --> 00:48:59,400
0,1170 1200,1500 1500,1890 2040,2970 2970,3660
registers that a trampoline code

1551
00:48:59,430 --> 00:49:01,110
0,510 510,600 600,1110 1170,1380 1380,1680
saves a way to save

1552
00:49:01,110 --> 00:49:02,610
0,90 90,390 390,780 1020,1410 1410,1500
the user state there's the

1553
00:49:02,610 --> 00:49:05,490
0,780 1620,1950 1950,2280 2280,2550 2550,2880
user are a return address,

1554
00:49:05,490 --> 00:49:08,130
0,420 420,630 630,1050 1050,1620 2100,2640
register user stack pointer, a

1555
00:49:08,520 --> 00:49:10,410
0,330 330,630 630,1050 1050,1200 1590,1890
user program counter at X

1556
00:49:10,410 --> 00:49:11,960
0,660
62.

1557
00:49:12,050 --> 00:49:13,490
0,210 210,510 510,690 690,1110 1110,1440
Um, these are familiar things

1558
00:49:13,490 --> 00:49:14,930
0,330 330,750 750,840 840,1110 1110,1440
from when we looked at.

1559
00:49:15,530 --> 00:49:17,080
0,1050
Traps.

1560
00:49:17,290 --> 00:49:18,250
0,270 300,570 570,720 720,870 870,960
And you may be the

1561
00:49:18,250 --> 00:49:20,170
0,270 270,750 750,1080 1080,1380 1560,1920
most interest is that um.

1562
00:49:23,290 --> 00:49:24,370
0,150 150,390 390,630 630,960 960,1080
The trap frame saves the

1563
00:49:24,370 --> 00:49:26,020
0,630 660,1020 1020,1380 1380,1500 1500,1650
user program counter and that

1564
00:49:26,020 --> 00:49:28,990
0,270 270,1020 2070,2220 2220,2310 2310,2970
value 62, if we cared.

1565
00:49:29,740 --> 00:49:31,100
0,780
I'm.

1566
00:49:31,630 --> 00:49:33,280
0,210 210,360 360,630 630,1260 1530,1650
We can look in the

1567
00:49:33,280 --> 00:49:35,050
0,540 540,1020 1020,1170 1170,1500 1500,1770
assembly code for spin dot

1568
00:49:35,050 --> 00:49:36,200
0,570
c.

1569
00:49:36,540 --> 00:49:37,700
0,690
Oops.

1570
00:49:37,850 --> 00:49:39,020
0,180 180,510 510,720 720,900 900,1170
She spent A S I'm

1571
00:49:39,020 --> 00:49:40,840
0,210 210,300 300,1140
look for 62.

1572
00:49:41,100 --> 00:49:42,090
0,300 300,420 420,540 540,720 720,990
Now we can see that

1573
00:49:42,300 --> 00:49:44,760
0,510 870,1110 1110,1590 1590,1890 1890,2460
owes a interrupt timer, interrupt

1574
00:49:44,760 --> 00:49:46,890
0,300 300,570 570,780 780,1200 1200,2130
occurred during this add instruction

1575
00:49:46,980 --> 00:49:49,740
0,330 330,660 1170,1650 1650,2130 2130,2760
in that infinite loop in

1576
00:49:49,860 --> 00:49:51,450
0,630 840,1020 1020,1320 1320,1470 1470,1590
spin, so it's not too

1577
00:49:51,450 --> 00:49:52,460
0,450
surprising.

1578
00:49:55,390 --> 00:49:58,450
0,450 450,750 750,1050 1050,1890 2400,3060
Okay, so back to a

1579
00:49:59,110 --> 00:50:00,940
0,420 420,1140 1170,1500 1500,1590 1590,1830
trap code seven or just

1580
00:50:00,940 --> 00:50:02,680
0,690 840,1110 1110,1230 1230,1320 1320,1740
returned, I'm going to take

1581
00:50:02,710 --> 00:50:04,420
0,390 420,810 810,900 900,1050 1050,1710
a step a few times

1582
00:50:04,420 --> 00:50:06,220
0,330 330,720 900,1350 1350,1620 1620,1800
to um get us to

1583
00:50:06,220 --> 00:50:07,260
0,480
z.

1584
00:50:07,640 --> 00:50:09,040
0,630
HMM.

1585
00:50:09,130 --> 00:50:10,870
0,540 540,690 690,990 990,1290 1320,1740
Just being about to execute

1586
00:50:10,870 --> 00:50:12,260
0,150 150,720
this yield.

1587
00:50:12,260 --> 00:50:13,160
0,270 270,600 600,660 660,840 840,900
And yield is sort of

1588
00:50:13,160 --> 00:50:14,000
0,60 60,330 330,630 630,720 720,840
the first step in the

1589
00:50:14,000 --> 00:50:15,620
0,480 480,630 990,1440 1440,1530 1530,1620
process of giving up the

1590
00:50:15,620 --> 00:50:17,090
0,420 420,810 810,870 870,960 960,1470
CPU switching to the scheduler,

1591
00:50:17,090 --> 00:50:18,800
0,270 270,330 330,870 900,1170 1170,1710
letting the scheduler choose another

1592
00:50:19,190 --> 00:50:20,840
0,300 300,540 540,630 630,1140 1140,1650
kernel thread in process run.

1593
00:50:22,510 --> 00:50:23,860
0,720
HMM.

1594
00:50:24,240 --> 00:50:26,070
0,480 480,600 600,1140 1170,1530 1530,1830
Alright, so let's actually step

1595
00:50:26,070 --> 00:50:28,710
0,150 150,930 1410,1590 1590,1740 1740,2640
into yield, now we're yields

1596
00:50:28,860 --> 00:50:30,080
0,600
a.

1597
00:50:30,110 --> 00:50:30,980
0,120 120,180 180,270 270,330 330,870
If you have a question.

1598
00:50:31,580 --> 00:50:32,540
0,330
NO.

1599
00:50:43,450 --> 00:50:47,500
0,510 540,720 720,1290 2610,3390
Okay, we're yield a.

1600
00:50:47,500 --> 00:50:48,520
0,540 540,720 720,750 750,960 960,1020
Yoda's just a couple of

1601
00:50:48,520 --> 00:50:52,180
0,660 660,1230 1260,1980 2550,3480 3480,3660
things it a acquires, the

1602
00:50:52,180 --> 00:50:54,790
0,510 690,870 870,1140 1140,2190 2220,2610
lock for this process because

1603
00:50:54,790 --> 00:50:55,390
0,120 120,330 330,390 390,510 510,600
it's about to make a

1604
00:50:55,390 --> 00:50:56,440
0,270 270,360 360,780 780,870 870,1050
bunch of changes to this

1605
00:50:56,440 --> 00:50:58,060
0,630 630,960 960,1140 1140,1380 1380,1620
process, and it doesn't want

1606
00:50:58,060 --> 00:51:00,160
0,270 270,900 1080,1590 1590,1740 1740,2100
any other and in fact

1607
00:51:00,430 --> 00:51:01,240
0,360 360,420 420,600 600,720 720,810
until it gives up the

1608
00:51:01,240 --> 00:51:02,140
0,300 300,390 390,690 690,750 750,900
lock, the state of this

1609
00:51:02,140 --> 00:51:03,250
0,480 480,600 600,750 750,960 960,1110
process will be sort of

1610
00:51:03,340 --> 00:51:06,100
0,1110 1200,1920 1920,2070 2070,2460 2460,2760
inconsistent like for example, it's

1611
00:51:06,250 --> 00:51:07,600
0,360 360,660 660,750 750,1260 1260,1350
about yield is about to

1612
00:51:07,600 --> 00:51:08,530
0,330 330,420 420,780 780,870 870,930
change the state of the

1613
00:51:08,530 --> 00:51:09,460
0,420 420,570 570,750 750,840 840,930
process to run a Bill

1614
00:51:09,460 --> 00:51:11,680
0,630 1080,1320 1350,1500 1500,1620 1620,2220
which would you know indicates

1615
00:51:11,680 --> 00:51:12,420
0,330
that.

1616
00:51:12,420 --> 00:51:13,710
0,60 60,480 480,600 600,930 930,1290
The process is not running,

1617
00:51:13,710 --> 00:51:15,330
0,180 180,300 300,570 570,930 1230,1620
but would like to, but

1618
00:51:15,330 --> 00:51:17,550
0,120 120,510 510,720 720,1230 1800,2220
this process is running right,

1619
00:51:17,640 --> 00:51:18,390
0,180 180,300 300,450 450,690 690,750
I mean we're running the

1620
00:51:18,390 --> 00:51:19,650
0,360 360,570 570,900 900,1110 1110,1260
process right now that's what's

1621
00:51:19,650 --> 00:51:20,910
0,510 510,630 630,690 690,990 990,1260
executing is the kernel thread

1622
00:51:20,910 --> 00:51:22,530
0,120 120,270 270,960 1110,1350 1350,1620
for this process and so

1623
00:51:22,530 --> 00:51:23,640
0,360 360,690 690,750 750,840 840,1110
the one of the many

1624
00:51:23,640 --> 00:51:24,780
0,210 210,300 300,630 630,840 840,1140
things that acquire this lock

1625
00:51:24,780 --> 00:51:26,550
0,360 360,750 1110,1410 1410,1680 1680,1770
does is a makes it

1626
00:51:26,550 --> 00:51:27,750
0,180 180,510 600,930 930,1080 1080,1200
so that even though we

1627
00:51:27,750 --> 00:51:28,740
0,210 210,450 450,510 510,750 750,990
just changed the state run

1628
00:51:28,740 --> 00:51:30,640
0,330 360,900 900,1470
double no other.

1629
00:51:30,640 --> 00:51:32,350
0,480 480,990 990,1290 1290,1470 1470,1710
Course scheduling thread will look

1630
00:51:32,350 --> 00:51:34,690
0,90 90,270 270,1080 1230,1980 2040,2340
at this process and because

1631
00:51:34,690 --> 00:51:36,760
0,90 90,660 870,1530 1590,1950 1950,2070
of lock and see that

1632
00:51:36,760 --> 00:51:37,660
0,150 150,480 480,570 570,720 720,900
it's reasonable and try to

1633
00:51:37,660 --> 00:51:39,040
0,210 210,360 630,990 990,1110 1110,1380
run it while we're still

1634
00:51:39,040 --> 00:51:40,000
0,270 270,390 390,480 480,630 630,960
running it on this course

1635
00:51:40,030 --> 00:51:41,200
0,210 210,300 300,330 330,900 900,1170
would be a disaster right

1636
00:51:41,200 --> 00:51:43,900
0,240 240,330 330,630 630,1410 1950,2700
running the same process onto

1637
00:51:43,900 --> 00:51:45,640
0,240 240,870 900,1200 1200,1560 1560,1740
different cores, now process has

1638
00:51:45,640 --> 00:51:47,740
0,210 210,480 480,1140 1410,1950 1950,2100
only one stack so that

1639
00:51:47,740 --> 00:51:48,940
0,210 210,390 390,600 600,870 870,1200
means like two different cores

1640
00:51:48,940 --> 00:51:50,380
0,360 390,810 810,1110 1110,1350 1350,1440
are calling several teams on

1641
00:51:50,380 --> 00:51:51,670
0,60 60,330 330,690 690,900 900,1290
the same stack, which is

1642
00:51:52,510 --> 00:51:53,920
0,330 330,390 390,780 780,870 870,1410
just a recipe for disaster.

1643
00:51:54,680 --> 00:51:56,390
0,390 900,1200 1200,1320 1320,1440 1440,1710
A we take a walk

1644
00:51:56,390 --> 00:51:58,780
0,360
out.

1645
00:51:59,380 --> 00:52:01,480
0,660 930,1290 1290,1710 1710,1830 1830,2100
We yield changes the state

1646
00:52:01,480 --> 00:52:03,430
0,150 150,360 360,420 420,840 1260,1950
to run a bow, um.

1647
00:52:04,130 --> 00:52:05,030
0,300 300,420 420,570 570,810 810,900
And what this means is

1648
00:52:05,030 --> 00:52:06,400
0,270 390,510 510,780
that you know.

1649
00:52:06,400 --> 00:52:08,290
0,210 210,720 720,990 990,1350 1350,1890
We finally given up the.

1650
00:52:09,450 --> 00:52:10,780
0,690
I'm.

1651
00:52:11,960 --> 00:52:13,130
0,270 270,420 420,720 720,1050 1050,1170
When we finally yield the

1652
00:52:13,130 --> 00:52:14,150
0,420 420,510 510,780 780,930 930,1020
CPU and get up and

1653
00:52:14,150 --> 00:52:15,650
0,330 330,450 450,900 900,1320 1320,1500
switch the scheduler process, this

1654
00:52:15,650 --> 00:52:16,490
0,270 270,390 390,540 540,780 780,840
state will be left in

1655
00:52:16,490 --> 00:52:17,690
0,180 180,510 510,960 960,1080 1080,1200
this renewable state so that

1656
00:52:17,690 --> 00:52:19,220
0,60 60,300 300,480 480,1020 1290,1530
it will run again because

1657
00:52:19,220 --> 00:52:19,880
0,240 240,300 300,450 450,600 600,660
after all this was a

1658
00:52:19,880 --> 00:52:21,800
0,450 450,870 870,1080 1200,1860 1860,1920
timer interrupt that interrupted a

1659
00:52:21,800 --> 00:52:23,090
0,270 270,510 510,750 750,1170 1170,1290
running user level process that

1660
00:52:23,090 --> 00:52:24,590
0,180 180,390 390,480 480,1020 1020,1500
would like to continue computing.

1661
00:52:25,790 --> 00:52:27,140
0,300 300,450 450,630 630,1020 1020,1350
We're gonna leave instate renewable

1662
00:52:27,140 --> 00:52:27,770
0,150 150,240 240,300 300,480 480,630
so that it will run

1663
00:52:27,770 --> 00:52:29,450
0,330 330,750 780,1140 1140,1560 1590,1680
again as soon as the

1664
00:52:29,450 --> 00:52:31,080
0,390 390,870 870,990
scheduler decides to.

1665
00:52:33,290 --> 00:52:36,680
0,660 1290,1470 1470,2070 2640,3240 3270,3390
Um, and then um the

1666
00:52:36,680 --> 00:52:38,300
0,150 150,330 330,570 570,990
only other thing that.

1667
00:52:40,380 --> 00:52:41,740
0,540
AW.

1668
00:52:44,090 --> 00:52:45,440
0,390 390,660 660,900 900,1140 1140,1350
A yield does is call

1669
00:52:45,440 --> 00:52:47,300
0,150 150,660 660,1170
this scheduler function.

1670
00:52:48,580 --> 00:52:49,360
0,240 240,300 300,570 570,690 690,780
Kind of step into the

1671
00:52:49,360 --> 00:52:50,940
0,420 420,1020
scheduler function.

1672
00:52:51,210 --> 00:52:52,680
0,450 450,660 660,930 930,1230 1230,1470
I'll show this whole thing

1673
00:52:52,680 --> 00:52:53,820
0,510
here.

1674
00:53:01,470 --> 00:53:04,050
0,360 1560,2010 2010,2100 2100,2400 2400,2580
A schedule is something does

1675
00:53:04,050 --> 00:53:04,830
0,300 300,540 540,630 630,750 750,780
almost nothing, it has a

1676
00:53:04,830 --> 00:53:06,270
0,150 150,240 240,960 1050,1380 1380,1440
bunch of checks a it

1677
00:53:06,270 --> 00:53:07,500
0,150 150,750 750,990 990,1140 1140,1230
does a whole bunch of

1678
00:53:07,500 --> 00:53:09,480
0,450 450,1020 1020,1140 1140,1860 1860,1980
sanity checks and panics and

1679
00:53:09,480 --> 00:53:10,560
0,120 120,450 450,540 540,810 810,1080
the reason for that is

1680
00:53:10,560 --> 00:53:12,940
0,390 390,660
actually that.

1681
00:53:13,550 --> 00:53:15,950
0,360 360,1200 1200,1350 1350,2160 2160,2400
This code in x86 over

1682
00:53:15,950 --> 00:53:18,020
0,510 540,870 870,1020 1020,1440 1440,2070
its many your lifetime had

1683
00:53:18,320 --> 00:53:20,270
0,420 420,720 720,810 810,1440 1590,1950
been among the most bug

1684
00:53:20,270 --> 00:53:22,400
0,570 690,870 870,1020 1020,1260 1260,2130
prone and have most surprises

1685
00:53:22,940 --> 00:53:25,160
0,540 570,1350 1350,1890 1890,2040 2040,2220
I'm unhappy surprises, so there's

1686
00:53:25,160 --> 00:53:26,400
0,60 60,390 390,720
a lot of.

1687
00:53:27,000 --> 00:53:28,650
0,540 540,900 900,1050 1050,1470 1470,1650
Sanity checks and panics here

1688
00:53:28,650 --> 00:53:29,780
0,450
because.

1689
00:53:30,820 --> 00:53:32,620
0,180 180,360 360,720 720,1260 1260,1800
Because there's often bugs associated

1690
00:53:32,620 --> 00:53:33,820
0,90 90,210 210,630
with this code.

1691
00:53:35,650 --> 00:53:37,660
0,270 270,360 360,1320 1350,1710 1710,2010
Alright, I'm gonna skip over

1692
00:53:37,660 --> 00:53:41,980
0,810 1830,2430 2430,2880 2880,3180 3780,4320
these sanity checks and a

1693
00:53:42,130 --> 00:53:44,060
0,660 660,810 810,1380
proceed to z.

1694
00:53:44,060 --> 00:53:45,540
0,810
I'm.

1695
00:53:46,850 --> 00:53:48,110
0,330 330,390 390,870 870,1020 1020,1260
Called a switch, this called

1696
00:53:48,110 --> 00:53:48,890
0,120 120,390 390,510 510,660 660,780
us which is where the

1697
00:53:48,890 --> 00:53:49,850
0,210 210,480 480,780 780,900 900,960
real action happens, this is

1698
00:53:49,850 --> 00:53:50,660
0,180 180,270 270,570 570,660 660,810
called the switch is going

1699
00:53:50,660 --> 00:53:52,730
0,150 360,870 870,1230 1230,1410 1410,2070
to save away the current.

1700
00:53:53,730 --> 00:53:56,730
0,510 510,990 990,1980 1980,2490 2520,3000
Kernel threads registers in PR

1701
00:53:56,730 --> 00:53:58,080
0,600 600,780 780,870 870,960 960,1350
context which is the current

1702
00:53:58,080 --> 00:54:00,720
0,990 1080,1500 1500,1710 1710,1950 1950,2640
processes saved kernel thread context,

1703
00:54:00,750 --> 00:54:03,330
0,270 270,390 390,450 450,1200 1890,2580
save set of registers, c

1704
00:54:03,330 --> 00:54:05,010
0,240 240,780 780,1080 1080,1290 1290,1680
arrow context, c is the.

1705
00:54:05,520 --> 00:54:07,890
0,330 330,450 450,960 960,1890 1920,2370
Pointer to this corps struck

1706
00:54:07,890 --> 00:54:11,070
0,870 1200,1800 1890,2400 2400,2790 2790,3180
CPU, I'm struck CPU has.

1707
00:54:11,690 --> 00:54:14,030
0,810 810,900 900,1140 1140,1890 1890,2340
Context to save registers of

1708
00:54:14,180 --> 00:54:16,550
0,450 450,1260 1290,1830 1830,2310 2310,2370
this corps scheduler threats, we're

1709
00:54:16,550 --> 00:54:17,540
0,120 120,210 210,300 300,750 750,990
going to be switching from

1710
00:54:17,540 --> 00:54:18,860
0,240 240,600 600,750 840,1200 1200,1320
this threat and saving this

1711
00:54:18,860 --> 00:54:20,990
0,240 240,690 780,1590 1590,1710 1710,2130
thread state restoring the threat

1712
00:54:20,990 --> 00:54:24,410
0,450 450,900 1380,2430 2460,3150 3150,3420
state of discourse scheduler and

1713
00:54:24,830 --> 00:54:26,330
0,630 630,720 720,1260 1260,1350 1350,1500
continuing the execution of this

1714
00:54:26,330 --> 00:54:30,320
0,810 840,1500 1710,2730 2850,3660
scores course scheduler thread.

1715
00:54:32,760 --> 00:54:34,200
0,330 330,540 540,750 750,1080 1080,1440
Okay, so let's see what

1716
00:54:34,200 --> 00:54:35,280
0,420
um.

1717
00:54:36,250 --> 00:54:37,660
0,300 300,570 570,690 690,1080 1080,1410
Um, let's take a quick

1718
00:54:37,750 --> 00:54:41,080
0,840 1140,1770 1860,2430 2460,3240 3240,3330
preview at the context that

1719
00:54:41,080 --> 00:54:42,010
0,90 90,210 210,300 300,390 390,930
we're going to be switching

1720
00:54:42,010 --> 00:54:43,750
0,540 1020,1290 1290,1440 1440,1560 1560,1740
to and I can get

1721
00:54:43,750 --> 00:54:45,220
0,270 270,510 510,660 660,930
that turns out that.

1722
00:54:45,860 --> 00:54:47,810
0,360 360,720 720,1020 1020,1440 1440,1950
Can't actually print cl context,

1723
00:54:47,810 --> 00:54:48,410
0,90 90,150 150,390 390,450 450,600
but I happen to know

1724
00:54:48,410 --> 00:54:51,230
0,120 120,780 1050,1830 1830,2070 2070,2820
that c prints to CPU

1725
00:54:51,230 --> 00:54:53,480
0,1110 1200,1650 1710,1950 1950,2100 2100,2250
zero just because we're on

1726
00:54:53,480 --> 00:54:54,740
0,150 150,510 510,660 660,1080 1080,1260
the zero with core there's

1727
00:54:54,740 --> 00:54:56,780
0,120 120,330 330,810 1080,1890 1890,2040
only one core and I

1728
00:54:56,780 --> 00:54:58,800
0,120 120,330 330,450 450,1170
can print its context.

1729
00:54:59,740 --> 00:55:00,960
0,660
I'm.

1730
00:55:00,960 --> 00:55:02,250
0,240 240,660 660,840 840,930 930,1290
And so this is the

1731
00:55:02,370 --> 00:55:05,790
0,450 780,1980 2010,2910 2910,3150 3150,3420
um saved registers from this

1732
00:55:05,790 --> 00:55:09,100
0,810 1230,1650 1650,2250 2250,2820
course, a scheduler threat.

1733
00:55:09,100 --> 00:55:10,200
0,510
I'm.

1734
00:55:10,560 --> 00:55:11,790
0,210 210,360 360,870 870,1140 1140,1230
And of particular interest is

1735
00:55:11,790 --> 00:55:13,110
0,150 150,420 420,720 720,1200 1200,1320
the are a because the

1736
00:55:13,110 --> 00:55:15,210
0,210 210,300 300,1230 1260,1710 1710,2100
are a register I is

1737
00:55:15,210 --> 00:55:16,600
0,840
where.

1738
00:55:16,600 --> 00:55:18,460
0,60 60,360 360,750 750,1290 1740,1860
The current function call is

1739
00:55:18,460 --> 00:55:19,330
0,120 120,180 180,540 540,690 690,870
going to return to so

1740
00:55:19,330 --> 00:55:19,990
0,150 150,270 270,330 330,540 540,660
we're going to switch the

1741
00:55:19,990 --> 00:55:21,130
0,390 390,780 780,930 930,1050 1050,1140
scheduler threatened it's going to

1742
00:55:21,130 --> 00:55:23,170
0,150 150,270 270,900 1170,1710 1710,2040
do a return and return

1743
00:55:23,170 --> 00:55:24,900
0,90 90,300 300,900
to that array.

1744
00:55:24,930 --> 00:55:26,800
0,660 750,1020 1020,1260
And um my.

1745
00:55:27,040 --> 00:55:28,330
0,240 240,360 360,690 750,1230 1230,1290
Um, we can find out

1746
00:55:28,330 --> 00:55:29,680
0,120 120,570 750,900 900,1050 1050,1350
where that where that return

1747
00:55:29,680 --> 00:55:31,660
0,450 450,570 570,900 900,1200 1500,1980
addresses by looking in current

1748
00:55:31,660 --> 00:55:33,100
0,270 270,840
day Sam.

1749
00:55:35,000 --> 00:55:36,600
0,480 480,750 750,1050
Actually that's a.

1750
00:55:43,800 --> 00:55:44,820
0,270 270,630 630,780 780,900 900,1020
Um, and as you can

1751
00:55:44,820 --> 00:55:45,930
0,210 210,420 420,570 570,870 870,1110
see this X slash I

1752
00:55:45,930 --> 00:55:47,910
0,90 90,180 180,1110 1110,1830 1830,1980
you know prints instructions that

1753
00:55:47,910 --> 00:55:48,870
0,120 120,150 150,420 420,840 840,960
at a certain address, but

1754
00:55:48,870 --> 00:55:50,160
0,90 90,330 330,570 570,720 720,1290
it also prints the label.

1755
00:55:52,170 --> 00:55:53,130
0,180 180,450 480,810 810,870 870,960
Of the name of the

1756
00:55:53,130 --> 00:55:54,390
0,330 330,450 450,630 630,1140 1140,1260
function that those instructions are

1757
00:55:54,390 --> 00:55:55,200
0,90 90,210 210,510 510,630 630,810
in it so we're going

1758
00:55:55,200 --> 00:55:57,330
0,90 90,210 210,900 1320,1740 1740,2130
to be returning to schedule

1759
00:55:57,330 --> 00:55:59,100
0,90 90,300 300,420 420,810 1290,1770
a bye and bye, that's

1760
00:55:59,100 --> 00:56:00,540
0,450 750,900 900,1020 1020,1350 1350,1440
just you know as you

1761
00:56:00,540 --> 00:56:01,800
0,120 120,810
might expect.

1762
00:56:05,040 --> 00:56:06,280
0,420
Okay.

1763
00:56:07,100 --> 00:56:08,660
0,900
I'm.

1764
00:56:11,120 --> 00:56:11,930
0,90 90,300 300,450 450,750 750,810
I want to look at

1765
00:56:11,930 --> 00:56:13,760
0,270 300,990 990,1290 1290,1620 1620,1830
what switch actually does about

1766
00:56:13,760 --> 00:56:15,320
0,60 60,240 240,960
to call switch.

1767
00:56:15,380 --> 00:56:16,640
0,720
I'm.

1768
00:56:18,910 --> 00:56:19,540
0,90 90,180 180,330 330,360 360,630
So I put a break

1769
00:56:19,540 --> 00:56:20,380
0,210 210,330 330,600 600,690 690,840
point on switch and putting

1770
00:56:20,380 --> 00:56:21,190
0,60 60,270 270,450 450,660 660,810
a break point because there's

1771
00:56:21,190 --> 00:56:22,330
0,60 60,240 240,330 330,690 690,1140
a bunch of setup code

1772
00:56:22,540 --> 00:56:24,520
0,450 450,990 990,1350
that pulls the.

1773
00:56:24,520 --> 00:56:25,750
0,390 390,450 450,1080 1080,1170 1170,1230
Values of context out of

1774
00:56:25,750 --> 00:56:27,430
0,210 210,960 960,1140 1140,1470 1470,1680
those structures, I'll skip over

1775
00:56:27,430 --> 00:56:28,220
0,150
it.

1776
00:56:28,820 --> 00:56:31,460
0,270 270,450 450,1080 1260,2100
Okay, so now, um.

1777
00:56:31,520 --> 00:56:32,180
0,150 150,180 180,390 390,570 570,660
When a break point and

1778
00:56:32,180 --> 00:56:34,420
0,690 1050,1620
switch the.

1779
00:56:34,420 --> 00:56:35,440
0,300 300,570 570,780 780,930 930,1020
GDP won't show us the

1780
00:56:35,440 --> 00:56:36,910
0,810 810,1080 1080,1200 1200,1320 1320,1470
instructions but we can look

1781
00:56:36,910 --> 00:56:38,890
0,90 90,390 390,660 660,1230 1710,1980
and switch {dot's -} to

1782
00:56:38,920 --> 00:56:39,790
0,240 240,300 300,360 360,780 780,870
look at the instructions were

1783
00:56:39,790 --> 00:56:41,320
0,240 240,330 330,900
about to execute.

1784
00:56:41,350 --> 00:56:42,040
0,270 270,360 360,420 420,510 510,690
So as you can see

1785
00:56:42,040 --> 00:56:42,760
0,120 120,210 210,270 270,480 480,720
we're on the very first

1786
00:56:42,760 --> 00:56:44,200
0,450 450,540 540,1050 1050,1200 1200,1440
instruction, the store of a

1787
00:56:44,200 --> 00:56:46,690
0,570 600,1170 1770,1980 1980,2100 2100,2490
ray to um the address

1788
00:56:46,690 --> 00:56:48,340
0,360 360,510 510,930 960,1140 1140,1650
pointed to by a zero

1789
00:56:48,640 --> 00:56:49,630
0,330 330,450 450,840 840,930 930,990
you may remember in the

1790
00:56:49,630 --> 00:56:51,490
0,450 450,570 570,1260 1260,1530 1620,1860
call to switch that the

1791
00:56:51,490 --> 00:56:53,440
0,270 270,780 780,1350 1380,1590 1590,1950
first argument was the current

1792
00:56:53,440 --> 00:56:54,580
0,240 240,300 300,990 990,1080 1080,1140
{thread's -} context and the

1793
00:56:54,580 --> 00:56:56,360
0,390 390,780 780,990 990,1260
second argument was the.

1794
00:56:56,530 --> 00:56:57,520
0,480 480,570 570,660 660,930 930,990
Context of the thread, we're

1795
00:56:57,520 --> 00:56:59,110
0,450 450,870 900,1050 1050,1230 1230,1590
switching to the two arguments

1796
00:56:59,110 --> 00:57:00,070
0,300 300,420 420,780 780,900 900,960
going a zero and a

1797
00:57:00,070 --> 00:57:01,840
0,540 930,1380 1380,1470 1470,1530 1530,1770
one and so the reason

1798
00:57:01,840 --> 00:57:02,500
0,120 120,210 210,360 360,480 480,660
why we see all these

1799
00:57:02,500 --> 00:57:05,350
0,840 870,1470 1770,2220 2220,2730 2730,2850
stores through register a0 is

1800
00:57:05,350 --> 00:57:06,550
0,240 240,360 360,720 720,1140 1140,1200
because we're storing away a

1801
00:57:06,550 --> 00:57:08,230
0,210 210,270 270,1140 1230,1590 1590,1680
bunch of registers in the

1802
00:57:08,230 --> 00:57:09,490
0,360 360,510 510,660 660,900 900,1260
memory that a zero points

1803
00:57:09,490 --> 00:57:10,420
0,180 180,360 360,540 540,690 690,930
to that is in the

1804
00:57:10,510 --> 00:57:12,340
0,690 690,810 810,1050 1500,1770 1770,1830
context of the threat, we're

1805
00:57:12,340 --> 00:57:13,840
0,360 360,660 960,1080 1080,1170 1170,1500
switching from and the loads

1806
00:57:13,840 --> 00:57:15,850
0,690 990,1200 1200,1560 1560,1620 1620,2010
load from address a one

1807
00:57:15,850 --> 00:57:17,320
0,480 750,990 990,1050 1050,1350 1350,1470
because that's a pointer to

1808
00:57:17,320 --> 00:57:18,850
0,300 630,1080 1080,1140 1140,1230 1230,1530
the context of the thread,

1809
00:57:18,850 --> 00:57:20,180
0,90 90,450 450,870
we're switching to.

1810
00:57:26,740 --> 00:57:30,370
0,480 720,1320 2610,3240 3270,3450 3450,3630
Okay, a thread, you know

1811
00:57:30,910 --> 00:57:34,150
0,510 840,1470 1560,1860 1860,2700 2790,3240
a switch saves registers loads

1812
00:57:34,150 --> 00:57:35,680
0,720 720,900 900,1020 1020,1320 1320,1530
registers from the target threats

1813
00:57:35,680 --> 00:57:38,230
0,420 420,510 510,660 660,1320 1830,2550
context and then return and

1814
00:57:38,260 --> 00:57:39,190
0,210 210,360 360,450 450,780 780,930
that's why the IRA was

1815
00:57:39,190 --> 00:57:40,030
0,360 360,540 540,660 660,780 780,840
interesting because it's going to

1816
00:57:40,030 --> 00:57:41,110
0,480 480,630 630,720 720,960 960,1080
return to the place that

1817
00:57:41,110 --> 00:57:42,460
0,270 270,630 630,810 810,1140 1140,1350
already pointed you namely into

1818
00:57:42,460 --> 00:57:45,700
0,720 1830,2130 2130,2430 2730,2910 2910,3240
schedule alright, so one question

1819
00:57:45,700 --> 00:57:47,260
0,330 360,780 780,900 900,1320 1320,1560
is you may notice here

1820
00:57:47,260 --> 00:57:48,790
0,180 360,720 720,1050 1050,1410 1410,1530
that while switch saves a

1821
00:57:48,790 --> 00:57:50,170
0,930 930,1020 1020,1080 1080,1290 1290,1380
raspy and a bunch of

1822
00:57:50,170 --> 00:57:51,820
0,240 240,870 900,1320 1320,1470 1470,1650
s registers one that does

1823
00:57:51,820 --> 00:57:53,470
0,300 300,960 1020,1200 1200,1320 1320,1650
not save is the program

1824
00:57:53,470 --> 00:57:54,160
0,390
counter.

1825
00:57:54,360 --> 00:57:55,140
0,210 210,360 360,450 450,720 720,780
A there's no mention of

1826
00:57:55,140 --> 00:57:57,150
0,60 60,450 450,750 750,1140 1500,2010
the program counter here, um,

1827
00:57:57,660 --> 00:57:59,280
0,270 270,600 600,750 750,1050
so why is that.

1828
00:58:04,650 --> 00:58:06,030
0,300 300,480 480,600 600,1170 1170,1380
Um, is it because the

1829
00:58:06,030 --> 00:58:08,490
0,450 450,900 900,1440 1470,1890 1890,2460
program counter is a updated

1830
00:58:08,490 --> 00:58:09,840
0,270 270,480 480,600 600,990 990,1350
with like the function calls

1831
00:58:09,840 --> 00:58:12,690
0,540 1140,1830 1830,2190 2190,2730 2730,2850
anyway, yeah it's it's the

1832
00:58:12,690 --> 00:58:14,100
0,330 330,600 600,780 780,1080 1080,1410
program counter, there's no actual

1833
00:58:14,100 --> 00:58:15,540
0,540 540,930 930,990 990,1080 1080,1440
information value in the program

1834
00:58:15,540 --> 00:58:17,040
0,300 300,480 480,1050 1080,1200 1200,1500
counter, we know that we're

1835
00:58:17,040 --> 00:58:18,630
0,480 480,660 660,1140 1170,1410 1410,1590
executing right now is in

1836
00:58:18,630 --> 00:58:19,960
0,870
switch.

1837
00:58:19,990 --> 00:58:21,160
0,330 360,540 540,660 660,750 750,1170
Right, so there'd be no

1838
00:58:21,160 --> 00:58:22,450
0,450 450,540 540,870 870,960 960,1290
point in saving the program

1839
00:58:22,450 --> 00:58:23,530
0,330 330,750 750,840 840,990 990,1080
counter because it has an

1840
00:58:23,530 --> 00:58:26,290
0,600 600,1050 1050,1440 1440,2100 2430,2760
extremely predictable value namely this

1841
00:58:26,290 --> 00:58:27,670
0,750 750,870 870,1110 1110,1200 1200,1380
instruction, the address of this

1842
00:58:27,670 --> 00:58:30,430
0,420 420,510 510,1230 2220,2640 2640,2760
instruction and switch what we

1843
00:58:30,430 --> 00:58:31,720
0,270 270,570 570,930 930,1050 1050,1290
really care about is where

1844
00:58:31,720 --> 00:58:33,640
0,150 150,270 270,660 660,1350 1650,1920
we we're called from because

1845
00:58:33,640 --> 00:58:34,600
0,120 120,210 210,540 540,870 870,960
when we switch back to

1846
00:58:34,600 --> 00:58:35,920
0,240 240,810
this thread.

1847
00:58:35,980 --> 00:58:37,420
0,210 210,390 390,450 450,870 870,1440
We want to continue executing

1848
00:58:37,420 --> 00:58:38,920
0,210 240,690 690,1140 1140,1380 1380,1500
out whatever points which was

1849
00:58:38,920 --> 00:58:40,210
0,360 360,660 810,990 990,1140 1140,1290
called from and it's a

1850
00:58:40,210 --> 00:58:42,640
0,450 450,600 600,1500 1740,1980 1980,2430
ray that holds the address

1851
00:58:42,640 --> 00:58:43,900
0,120 120,240 240,840 840,990 990,1260
of the instruction that switch

1852
00:58:43,900 --> 00:58:45,260
0,150 150,480 480,840
was called from.

1853
00:58:45,320 --> 00:58:46,850
0,300 300,450 450,690 690,840 840,1530
Um, so it's a ray

1854
00:58:47,030 --> 00:58:48,590
0,270 270,480 480,810 810,1080 1080,1560
that's being saved away here

1855
00:58:48,980 --> 00:58:50,480
0,450 510,690 690,990 990,1380 1380,1500
a and a is the

1856
00:58:50,480 --> 00:58:51,440
0,240 240,300 300,510 510,630 630,960
point at which will be.

1857
00:58:53,910 --> 00:58:55,760
0,600 600,720 720,1230
Executing out again.

1858
00:58:55,790 --> 00:58:56,690
0,180 180,420 420,690 690,810 810,900
Let's switch return so we

1859
00:58:56,690 --> 00:58:57,650
0,270 270,540 540,720 720,810 810,960
even print that we can

1860
00:58:57,650 --> 00:58:58,700
0,390
print.

1861
00:58:58,930 --> 00:59:01,720
0,1110 1530,2190
Alright, um.

1862
00:59:03,740 --> 00:59:04,550
0,150 150,270 270,480 480,630 630,810
We can print our a

1863
00:59:04,550 --> 00:59:05,390
0,240 240,390 390,480 480,600 600,840
and you know we haven't

1864
00:59:05,390 --> 00:59:07,010
0,300 300,630 630,960 960,1290 1380,1620
actually switched threads yet you

1865
00:59:07,010 --> 00:59:08,060
0,300 300,390 390,690 690,870 870,1050
remember we came here from

1866
00:59:08,060 --> 00:59:10,220
0,120 120,600 600,1200 1650,1950 1950,2160
this sketch function, um, so

1867
00:59:10,220 --> 00:59:12,140
0,900 1170,1410 1410,1500 1500,1620 1620,1920
arrays as you might expect

1868
00:59:12,140 --> 00:59:13,040
0,90 90,330 330,540 540,690 690,900
the pointer back into this

1869
00:59:13,040 --> 00:59:15,620
0,240 240,600 1920,2160 2160,2460 2460,2580
said function, another question is

1870
00:59:15,620 --> 00:59:17,630
0,210 210,420 420,1170 1200,1500 1500,2010
how come switch only saves

1871
00:59:17,630 --> 00:59:19,520
0,570 570,1170 1170,1230 1230,1590 1590,1890
fourteen registers I counted them,

1872
00:59:19,550 --> 00:59:20,900
0,90 90,240 240,570 570,690 690,1350
it only saves and restores

1873
00:59:20,930 --> 00:59:23,150
0,330 330,1110 1800,2010 2010,2100 2100,2220
fourteen registers even though the

1874
00:59:23,150 --> 00:59:25,520
0,270 270,630 630,870 870,1590 1590,2370
risk five has 32 registers

1875
00:59:25,520 --> 00:59:27,120
0,510 510,660 660,930 930,1230
available for the um.

1876
00:59:27,470 --> 00:59:28,610
0,270 270,510 510,630 630,840 840,1140
Or use it for code

1877
00:59:28,610 --> 00:59:29,820
0,120 120,690
to use.

1878
00:59:29,820 --> 00:59:31,280
0,930
WHY.

1879
00:59:31,740 --> 00:59:33,030
0,240 240,450 450,690 690,780 780,1290
Why only half the registers

1880
00:59:33,030 --> 00:59:34,650
0,60 60,360 750,1050 1050,1290 1290,1620
are sealed well when switch

1881
00:59:34,650 --> 00:59:35,940
0,180 180,630 630,720 720,930 930,1290
was called, it was called

1882
00:59:35,940 --> 00:59:37,140
0,90 90,120 120,510 510,1020 1020,1200
as a normal function, so

1883
00:59:37,140 --> 00:59:39,120
0,360 360,690 690,1050 1050,1380 1380,1980
whoever called switch already assumed

1884
00:59:39,120 --> 00:59:40,560
0,120 120,420 420,660 660,1080 1080,1440
will switch might modify those

1885
00:59:40,560 --> 00:59:42,180
0,150 150,540 540,990 990,1380 1380,1620
so that that function already

1886
00:59:42,180 --> 00:59:43,440
0,390 390,780
saved that.

1887
00:59:43,440 --> 00:59:45,270
0,240 240,450 450,1050 1080,1470 1470,1830
On its stack meaning that

1888
00:59:45,300 --> 00:59:47,040
0,360 360,570 570,720 720,1200 1380,1740
like when we jump from

1889
00:59:47,040 --> 00:59:49,020
0,510 510,630 630,750 750,1440 1680,1980
one to the other, um

1890
00:59:49,020 --> 00:59:50,700
0,270 270,480 480,720 720,1140 1140,1680
that one's gonna self restore

1891
00:59:50,700 --> 00:59:54,030
0,540 780,1260 1290,2250 2250,2640 2640,3330
its a color safe registers,

1892
00:59:54,090 --> 00:59:56,220
0,450 450,900 900,1260 1260,1440 1440,2130
that's exactly right, this switches

1893
00:59:56,220 --> 00:59:58,110
0,300 330,870 870,1020 1020,1320 1320,1890
are called from c code,

1894
00:59:58,170 --> 00:59:59,820
0,300 300,930 1050,1350 1350,1440 1440,1650
we know that the c

1895
00:59:59,820 --> 01:00:03,060
0,1230 1350,2550 2550,2820 2820,2880 2880,3240
compiler saves on the current

1896
01:00:03,060 --> 01:00:06,270
0,990 1080,1530 1530,1800 1800,2700 2700,3210
stack, um, any caller saved

1897
01:00:06,270 --> 01:00:08,340
0,690 690,840 840,1350 1500,1950 1950,2070
registers that have values in

1898
01:00:08,340 --> 01:00:09,240
0,120 120,450 450,720 720,780 780,900
them ethical {pilar's -} going

1899
01:00:09,240 --> 01:00:10,500
0,90 90,330 330,780
to need later.

1900
01:00:10,590 --> 01:00:12,630
0,420 600,870 870,1140 1140,1680 1680,2040
Um, and those caller saved

1901
01:00:12,630 --> 01:00:16,350
0,540 540,1080 1260,2100 2400,3000 3090,3720
registers actually include I think

1902
01:00:16,350 --> 01:00:17,480
0,450
there's.

1903
01:00:17,600 --> 01:00:19,820
0,1080 1410,1860 1860,1950 1950,2100 2100,2220
Eighteen depending on how you

1904
01:00:19,820 --> 01:00:20,900
0,270 270,420 420,600 600,810 810,1080
count them there's somewhere between

1905
01:00:20,900 --> 01:00:23,030
0,420 420,540 540,1170 1200,1680 1680,2130
fifteen and eighteen caller saved

1906
01:00:23,030 --> 01:00:26,060
0,990 1950,2220 2220,2400 2400,2880 2880,3030
registers so the registers we

1907
01:00:26,060 --> 01:00:27,650
0,270 270,870 1050,1380 1380,1500 1500,1590
see here are all the

1908
01:00:27,650 --> 01:00:29,750
0,510 510,690 690,1140 1140,1530 1530,2100
registers that aren't color saved

1909
01:00:29,750 --> 01:00:31,220
0,90 90,210 210,300 300,930 1050,1470
and that the compiler doesn't

1910
01:00:31,220 --> 01:00:32,990
0,360 360,450 450,930 960,1170 1170,1770
promise to save but nevertheless

1911
01:00:32,990 --> 01:00:35,120
0,180 180,750 1140,1710
may hold, um.

1912
01:00:35,180 --> 01:00:36,710
0,750 750,840 840,930 930,1380 1380,1530
Values that are needed by

1913
01:00:36,710 --> 01:00:37,940
0,120 120,480 480,930 960,1140 1140,1230
the calling function, so we

1914
01:00:37,940 --> 01:00:38,750
0,60 60,240 240,330 330,720 720,810
all need to save the

1915
01:00:38,750 --> 01:00:41,480
0,840 840,1350 1350,2190 2340,2640 2640,2730
kali saved registers when we're

1916
01:00:41,480 --> 01:00:43,120
0,360 360,1050
switching threads.

1917
01:00:45,830 --> 01:00:47,740
0,600 630,1320
Okay, I'm.

1918
01:00:48,340 --> 01:00:49,270
0,360 360,600 600,720 720,780 780,930
A final thing I want

1919
01:00:49,270 --> 01:00:51,010
0,60 60,480 480,1020 1020,1560 1620,1740
to print is the we

1920
01:00:51,010 --> 01:00:52,270
0,360 360,720 720,870 870,1170 1170,1260
do save and restore the

1921
01:00:52,270 --> 01:00:53,740
0,270 270,690 810,1020 1020,1230 1230,1470
stack pointer, the current stack

1922
01:00:53,740 --> 01:00:54,880
0,360 360,600 600,780 780,1050 1050,1140
pointer, it's like hard to

1923
01:00:54,880 --> 01:00:55,810
0,240 240,420 420,540 540,810 810,930
tell from this value, what

1924
01:00:55,810 --> 01:00:56,920
0,150 150,420 420,600 600,870 900,1110
that means but it's the

1925
01:00:56,920 --> 01:00:58,780
0,300 300,690 690,1080 1380,1500 1500,1860
kernel stack of the current

1926
01:00:58,780 --> 01:01:01,060
0,570 570,960 1980,2070 2070,2190 2190,2280
process which I don't know

1927
01:01:01,060 --> 01:01:01,960
0,90 90,180 180,600 600,720 720,900
if you recall but is

1928
01:01:01,960 --> 01:01:03,820
0,660 660,1080 1080,1680 1680,1770 1770,1860
allocated is mapped by the

1929
01:01:03,820 --> 01:01:04,900
0,270 270,540 540,810 810,870 870,1080
virtual memory system at high

1930
01:01:04,900 --> 01:01:05,800
0,480
memory.

1931
01:01:06,180 --> 01:01:07,340
0,660
Hush.

1932
01:01:07,340 --> 01:01:13,010
0,300 300,660 1950,2430 5040,5250 5250,5670
Okay, so um okay, so

1933
01:01:13,010 --> 01:01:14,210
0,480 510,660 660,720 720,960 960,1200
we're going to save away

1934
01:01:14,210 --> 01:01:15,800
0,240 240,480 480,990 990,1140 1140,1590
the current registers and restore

1935
01:01:15,800 --> 01:01:17,660
0,660 660,1290
registers from.

1936
01:01:17,660 --> 01:01:20,240
0,270 300,900 900,1230 1230,1800 2010,2580
A scheduler threads context, um

1937
01:01:20,240 --> 01:01:21,710
0,0 0,240 240,390 390,810 1050,1470
I don't want to execute

1938
01:01:21,710 --> 01:01:22,940
0,180 180,420 420,630 630,720 720,1230
every single one of these

1939
01:01:22,940 --> 01:01:23,900
0,390 390,450 450,720 720,870 870,960
loads in store so I'm

1940
01:01:23,900 --> 01:01:26,600
0,150 150,600 600,1290 1680,2070 2100,2700
gonna step over I'm all

1941
01:01:26,630 --> 01:01:28,220
0,150 150,600 600,1200 1200,1290 1290,1590
the fourteen loads, the fourteen

1942
01:01:28,220 --> 01:01:29,360
0,390 390,450 450,510 510,870 870,1140
stores in the fourteen loads

1943
01:01:29,360 --> 01:01:31,160
0,120 120,330 660,1140 1140,1650 1650,1800
going to proceed directly to

1944
01:01:31,160 --> 01:01:33,200
0,450 720,1080 1080,1740 1740,1890 1890,2040
the return instructions, OK so

1945
01:01:33,200 --> 01:01:34,700
0,180 210,780 780,1050 1050,1140 1140,1500
we executed everything in switch

1946
01:01:34,700 --> 01:01:37,640
0,480 480,570 570,1200 1470,2130 2250,2940
except the return, um before

1947
01:01:37,640 --> 01:01:38,810
0,300 300,450 450,540 540,1050 1050,1170
we do the return will

1948
01:01:38,810 --> 01:01:40,640
0,330 570,870 870,960 960,1350 1350,1830
just print the interesting registers

1949
01:01:40,640 --> 01:01:41,570
0,360 360,450 450,660 660,780 780,930
again to see where we

1950
01:01:41,570 --> 01:01:44,330
0,180 210,570 660,1110 1110,1650 2040,2760
are so stack pointer, um.

1951
01:01:44,720 --> 01:01:46,130
0,540 540,810 810,990 990,1080 1080,1410
Now it has a different

1952
01:01:46,130 --> 01:01:47,960
0,480 690,1110 1110,1320 1320,1530 1530,1830
value stack pointer, now points

1953
01:01:47,960 --> 01:01:50,240
0,150 150,300 300,810 810,1710
into this stack zero.

1954
01:01:50,360 --> 01:01:51,410
0,360 360,420 420,810 810,930 930,1050
Area in memory, and this

1955
01:01:51,410 --> 01:01:53,060
0,90 90,570 600,840 1050,1470 1470,1650
is actually the place it

1956
01:01:53,060 --> 01:01:54,560
0,570 570,960 960,1290 1290,1410 1410,1500
very very early in the

1957
01:01:54,560 --> 01:01:56,840
0,240 240,1020 1080,1590 1590,2010 2010,2280
boot sequence where start {dot's

1958
01:01:56,840 --> 01:01:58,760
0,540 570,1200 1200,1320 1320,1770 1770,1920
-} puts the stack so

1959
01:01:58,760 --> 01:02:00,170
0,180 180,480 630,960 960,1050 1050,1410
it may call the very

1960
01:02:00,170 --> 01:02:02,060
0,390 390,600 600,1140 1440,1650 1650,1890
first c function, so actually

1961
01:02:02,060 --> 01:02:03,170
0,270 270,360 360,450 450,810 810,1110
back on the original boot

1962
01:02:03,170 --> 01:02:04,910
0,480 510,660 660,840 840,1350 1350,1740
stack for this CPU which

1963
01:02:04,910 --> 01:02:06,530
0,360 630,1200 1200,1290 1290,1410 1410,1620
just happens to be where

1964
01:02:06,530 --> 01:02:08,920
0,60 60,540 540,1290
the scheduler runs.

1965
01:02:10,500 --> 01:02:13,110
0,600 630,1290 1530,1680 1680,2010 2010,2610
Okay, I'm the program counter

1966
01:02:13,350 --> 01:02:15,030
0,660 660,1110 1110,1260 1260,1320 1320,1680
after interesting we're in switch

1967
01:02:15,030 --> 01:02:16,260
0,180 180,300 300,450 450,840 840,1230
because we haven't returned yet

1968
01:02:16,350 --> 01:02:18,750
0,840 1260,1830 1860,2010 2010,2130 2130,2400
and um the um {re-register

1969
01:02:18,750 --> 01:02:21,240
0,780 900,1620 1620,1980 1980,2040 2040,2490
-} now points the scheduler

1970
01:02:21,240 --> 01:02:23,070
0,240 240,420 420,1050 1380,1620 1620,1830
because we've loaded a we've

1971
01:02:23,070 --> 01:02:26,100
0,720 720,1080 1410,1920 1920,2430 2520,3030
restored the register set previously

1972
01:02:26,100 --> 01:02:27,450
0,270 270,390 390,480 480,900 900,1350
saved by the scheduler threat.

1973
01:02:28,990 --> 01:02:30,400
0,210 210,480 480,630 630,870 870,1410
And indeed, we're really now

1974
01:02:30,490 --> 01:02:31,660
0,300 300,360 360,840 840,1050 1050,1170
in the scheduler thread if

1975
01:02:31,660 --> 01:02:33,460
0,90 90,240 240,330 330,870 1230,1800
I were on where the

1976
01:02:33,460 --> 01:02:34,750
0,330 330,480 480,660 660,990 990,1290
where now looks totally different

1977
01:02:34,750 --> 01:02:35,440
0,120 120,180 180,480 480,570 570,690
from the last time we

1978
01:02:35,440 --> 01:02:37,240
0,240 240,360 360,480 480,1020 1140,1800
ran it were now indeed

1979
01:02:37,240 --> 01:02:38,500
0,120 120,360 360,480 480,1020 1020,1260
a call to switch, but

1980
01:02:38,560 --> 01:02:39,850
0,660 660,840 840,930 930,1020 1020,1290
now we're in a call

1981
01:02:39,850 --> 01:02:41,140
0,180 180,570 570,720 720,1020 1020,1290
from switch to switch the

1982
01:02:41,140 --> 01:02:43,090
0,600 600,1140 1290,1530 1530,1710 1710,1950
scheduler made at some point

1983
01:02:43,090 --> 01:02:44,680
0,90 90,150 150,900 1200,1530 1530,1590
in the past and the

1984
01:02:44,680 --> 01:02:46,000
0,360 360,540 540,750 750,1110 1110,1320
schedule was run long ago

1985
01:02:46,000 --> 01:02:47,920
0,300 300,750 990,1500 1500,1830 1830,1920
during boot was called as

1986
01:02:47,920 --> 01:02:48,940
0,120 120,450 450,600 600,720 720,1020
the last thing that mane

1987
01:02:48,940 --> 01:02:50,860
0,420 570,990 990,1050 1050,1290 1290,1920
did during the boot process.

1988
01:02:53,310 --> 01:02:54,210
0,210 210,270 270,540 540,810 810,900
So I'm gonna ask you

1989
01:02:54,210 --> 01:02:56,190
0,270 270,750 750,840 840,1350 1350,1980
one instruction to return from

1990
01:02:56,490 --> 01:02:59,040
0,900 900,1170 1170,1380 1380,2010
switch now into scheduler.

1991
01:02:59,890 --> 01:03:00,610
0,240 240,390 390,480 480,570 570,720
So now we're in this

1992
01:03:00,610 --> 01:03:02,590
0,270 270,960 1500,1650 1650,1740 1740,1980
course scheduler with the full

1993
01:03:02,590 --> 01:03:04,000
0,660
code.

1994
01:03:08,320 --> 01:03:09,460
0,330 330,540 540,630 630,690 690,1140
So this is the scheduler

1995
01:03:09,460 --> 01:03:11,480
0,450 750,1350
code, um.

1996
01:03:11,480 --> 01:03:12,890
0,240 240,510 510,720 720,1230 1230,1410
This function called scheduler, now

1997
01:03:12,890 --> 01:03:14,090
0,120 120,540 540,630 630,720 720,1200
we're executing in the scheduler

1998
01:03:14,090 --> 01:03:15,950
0,630 690,930 930,1110 1110,1200 1200,1860
thread, um for the CPU

1999
01:03:16,280 --> 01:03:17,570
0,450 480,720 720,1140 1140,1200 1200,1290
and we're just at the

2000
01:03:17,570 --> 01:03:20,090
0,480 600,810 810,1140 1140,1920 2220,2520
point we just returned from

2001
01:03:20,090 --> 01:03:23,060
0,690 1440,1980 1980,2310 2310,2430 2430,2970
a previous call to switch

2002
01:03:23,060 --> 01:03:24,320
0,240 240,630 630,810 810,870 870,1260
the scheduler made a while

2003
01:03:24,320 --> 01:03:26,240
0,600 930,1260 1260,1320 1320,1830 1830,1920
ago when it decided it

2004
01:03:26,240 --> 01:03:27,440
0,120 120,240 240,300 300,750 750,1200
was going to start running

2005
01:03:27,440 --> 01:03:28,760
0,300 300,930 930,990 990,1080 1080,1320
that process, you know p

2006
01:03:28,760 --> 01:03:29,870
0,300 300,630 630,870 870,1020 1020,1110
ID three which was the

2007
01:03:29,870 --> 01:03:32,180
0,360 360,1080 1260,1530 1530,1650 1650,2310
spin process that was interrupted,

2008
01:03:32,750 --> 01:03:35,390
0,510 630,1110 1260,1470 1470,1740 1740,2640
so now it's this switch

2009
01:03:36,080 --> 01:03:37,700
0,330 330,600 600,990 990,1230 1230,1620
prices ID three that's spin

2010
01:03:37,700 --> 01:03:39,020
0,330 330,810 810,990 990,1140 1140,1320
called switch but it's not

2011
01:03:39,020 --> 01:03:40,550
0,270 270,480 480,810 810,1020 1020,1530
switch that switch this returning

2012
01:03:40,550 --> 01:03:41,810
0,240 240,390 390,630 630,960 960,1260
last which hasn't returned yet

2013
01:03:42,080 --> 01:03:44,390
0,240 240,420 420,810 810,1440 1980,2310
is still saved away in

2014
01:03:44,390 --> 01:03:45,140
0,420
a.

2015
01:03:45,490 --> 01:03:47,530
0,390 390,840 840,1320 1320,1920 1920,2040
Process ID three stack and

2016
01:03:47,530 --> 01:03:49,420
0,780 810,1080 1080,1440 1440,1590 1590,1890
context just return from this

2017
01:03:49,450 --> 01:03:51,280
0,390 390,660 660,720 720,1320
earlier called a switch.

2018
01:03:53,160 --> 01:03:54,120
0,390 390,510 510,600 600,840 840,960
Alright, so the stuff that

2019
01:03:54,120 --> 01:03:55,530
0,360 360,510 510,570 570,660 660,1410
happens here in the scheduler,

2020
01:03:55,740 --> 01:03:59,250
0,570 1680,2340 2370,3120 3120,3330 3330,3510
um were stopped running this

2021
01:03:59,250 --> 01:04:01,290
0,570 570,720 720,1230 1290,1830 1860,2040
process and so, um, you

2022
01:04:01,290 --> 01:04:02,820
0,150 150,270 300,930 930,1380 1410,1530
want to forget about the

2023
01:04:02,820 --> 01:04:05,070
0,450 450,780 780,900 900,1350 2130,2250
various things we did in

2024
01:04:05,070 --> 01:04:06,210
0,90 90,540 540,720 750,990 990,1140
the process of running this

2025
01:04:06,210 --> 01:04:07,650
0,420 420,480 480,630 630,690 690,1440
process, we want to forget

2026
01:04:07,920 --> 01:04:09,600
0,180 180,570 570,870 870,1140 1140,1680
the cl proc equals zero

2027
01:04:09,660 --> 01:04:11,070
0,480 480,660 660,750 750,840 840,1410
basically means that we're forgetting

2028
01:04:11,070 --> 01:04:11,760
0,240
that.

2029
01:04:11,970 --> 01:04:13,230
0,270 270,690 690,840 840,1110 1110,1260
Um, we're no longer running

2030
01:04:13,230 --> 01:04:14,310
0,120 120,480 480,570 570,720 720,1080
this process in this course,

2031
01:04:14,310 --> 01:04:15,030
0,150 150,240 240,390 390,540 540,720
so we don't want to

2032
01:04:15,750 --> 01:04:17,340
0,420 420,780 780,900 900,1380 1380,1590
have anybody be confused about

2033
01:04:17,340 --> 01:04:18,450
0,330 360,510 510,570 570,810 810,1110
that, let me set this.

2034
01:04:19,000 --> 01:04:21,220
0,390 390,990 1170,1770 1770,2100 2100,2220
Per core proc pointer to

2035
01:04:21,220 --> 01:04:22,640
0,420 420,810
zero instead.

2036
01:04:22,640 --> 01:04:24,410
0,180 180,840 1260,1470 1470,1650 1650,1770
This process, the next thing

2037
01:04:24,410 --> 01:04:26,000
0,90 90,420 420,570 570,810 930,1590
that happens is that you

2038
01:04:26,240 --> 01:04:28,160
0,510 510,1380
remember yield.

2039
01:04:28,160 --> 01:04:29,360
0,540 540,630 630,900 900,990 990,1200
Acquired the lock for this

2040
01:04:29,360 --> 01:04:31,010
0,900 960,1170 1170,1230 1230,1410 1410,1650
process because it didn't want

2041
01:04:31,010 --> 01:04:32,420
0,270 270,450 450,840 840,1290 1290,1410
any other course schedule or

2042
01:04:32,420 --> 01:04:33,320
0,60 60,240 240,300 300,450 450,900
to look at this process

2043
01:04:33,320 --> 01:04:35,180
0,90 90,330 330,570 570,900 1440,1860
and maybe run it until

2044
01:04:35,180 --> 01:04:36,950
0,90 90,510 510,630 630,1530 1560,1770
the process was completely put

2045
01:04:36,950 --> 01:04:38,940
0,90 90,1020
to sleep.

2046
01:04:39,290 --> 01:04:40,640
0,240 240,480 480,1020 1020,1110 1110,1350
We've now completed the switch

2047
01:04:40,640 --> 01:04:42,350
0,240 240,420 420,570 570,1290 1500,1710
away from this process, so

2048
01:04:42,350 --> 01:04:43,520
0,90 90,240 240,570 570,690 690,1170
we can release the lock

2049
01:04:43,910 --> 01:04:45,200
0,210 210,480 510,960 960,1110 1110,1290
on the process that just

2050
01:04:45,200 --> 01:04:46,140
0,510
yielded.

2051
01:04:46,880 --> 01:04:49,130
0,330 330,450 450,1050 1860,2100 2100,2250
That's the release at this

2052
01:04:49,130 --> 01:04:52,400
0,450 1350,1890 2250,2760 2760,3150 3150,3270
point a we're still in

2053
01:04:52,400 --> 01:04:53,360
0,60 60,510 510,660 660,780 780,960
the scheduler, if there was

2054
01:04:53,360 --> 01:04:55,070
0,270 270,810 870,1140 1140,1320 1320,1710
another core at this point,

2055
01:04:55,070 --> 01:04:57,290
0,390 390,660 660,1020 1020,1620 1650,2220
some other course scheduler could

2056
01:04:57,290 --> 01:04:59,120
0,600 600,840 840,1440 1440,1650 1650,1830
find that process because it's

2057
01:04:59,120 --> 01:05:00,700
0,480 480,690 690,900 900,1050
reasonable and run it.

2058
01:05:00,700 --> 01:05:02,170
0,120 120,270 270,660 660,1140 1170,1470
But that's okay because we've

2059
01:05:02,170 --> 01:05:04,510
0,510 510,1020 1020,1170 1170,2040 2070,2340
completely saved its registers were

2060
01:05:04,510 --> 01:05:05,980
0,240 240,510 510,1020 1020,1140 1140,1470
no longer executing on its

2061
01:05:05,980 --> 01:05:08,200
0,330 330,1050 1050,1560 1560,1920 1980,2220
that processes stack because now

2062
01:05:08,200 --> 01:05:09,680
0,480 480,630 630,900
executing on the.

2063
01:05:10,040 --> 01:05:12,050
0,390 420,600 600,990 990,1470 1470,2010
Um, this course scheduler stack,

2064
01:05:12,290 --> 01:05:13,250
0,240 240,330 330,570 570,870 870,960
so it's actually fine if

2065
01:05:13,250 --> 01:05:14,810
0,150 150,300 300,750 900,1440 1440,1560
some other core decides to

2066
01:05:14,810 --> 01:05:16,300
0,180 180,330 330,1020
run that process.

2067
01:05:16,840 --> 01:05:18,010
0,300 300,420 420,840 840,1020 1020,1170
Okay but there's no other

2068
01:05:18,010 --> 01:05:19,780
0,420 420,750 1020,1230 1230,1440 1440,1770
course so that doesn't actually

2069
01:05:19,780 --> 01:05:22,960
0,300 300,390 390,540 540,1260
happen in this demonstration.

2070
01:05:24,970 --> 01:05:26,180
0,630
I'm.

2071
01:05:26,440 --> 01:05:27,820
0,330 330,510 510,990 1020,1320 1320,1380
Actually want to spend a

2072
01:05:27,820 --> 01:05:29,740
0,570 630,1020 1020,1290 1290,1470 1470,1920
moment talking about the PR

2073
01:05:29,740 --> 01:05:31,240
0,600 660,780 780,930 930,1080 1080,1500
lock a little bit more

2074
01:05:31,510 --> 01:05:34,150
0,570 1170,1950 1950,2160 2160,2400 2400,2640
a PR lock actually does

2075
01:05:34,150 --> 01:05:37,620
0,300 720,1080 1080,1170 1170,2040
a couple of things.

2076
01:05:39,120 --> 01:05:40,520
0,150 150,420 420,810
It does really.

2077
01:05:40,580 --> 01:05:41,600
0,270 270,660 660,750 750,810 810,1020
Two things from the point

2078
01:05:41,600 --> 01:05:43,040
0,60 60,150 150,210 210,870 900,1440
of view of scheduling, one

2079
01:05:43,040 --> 01:05:45,290
0,150 150,570 600,1260 1260,1350 1350,2250
is that yielding the CPU,

2080
01:05:45,650 --> 01:05:47,510
0,180 180,690 690,1230 1230,1770 1770,1860
a involves multiple steps we

2081
01:05:47,510 --> 01:05:48,410
0,90 90,240 240,480 480,540 540,900
have to set the state

2082
01:05:48,410 --> 01:05:49,670
0,270 300,570 570,960 960,1200 1200,1260
to run up change the

2083
01:05:49,670 --> 01:05:50,930
0,210 210,390 390,630 630,720 720,1260
state from running to rubble,

2084
01:05:51,080 --> 01:05:53,630
0,390 390,1080 1080,1170 1170,2190 2280,2550
we save the registers in

2085
01:05:53,630 --> 01:05:55,910
0,150 150,600 600,1140 1140,1830 1920,2280
the yielding processes context, now

2086
01:05:55,910 --> 01:05:57,140
0,90 90,180 180,300 300,780 780,1230
we have to stop using

2087
01:05:57,140 --> 01:05:59,030
0,90 90,480 480,1020 1020,1590 1620,1890
the yielding processes stack there's

2088
01:05:59,030 --> 01:06:01,010
0,150 150,510 510,810 810,1590 1590,1980
at least three steps which

2089
01:06:01,010 --> 01:06:03,980
0,300 300,900 1500,2070 2280,2670 2670,2970
take time, um, in order

2090
01:06:03,980 --> 01:06:05,780
0,480 720,1110 1110,1380 1380,1500 1500,1800
to do all the steps

2091
01:06:05,780 --> 01:06:07,640
0,600 600,750 750,1200 1200,1290 1290,1860
required to yield the CPU

2092
01:06:07,910 --> 01:06:08,660
0,210 210,300 300,540 540,630 630,750
and so one of the

2093
01:06:08,660 --> 01:06:10,280
0,300 300,480 480,780 780,1440 1470,1620
things that lock does as

2094
01:06:10,280 --> 01:06:11,510
0,60 60,480 480,630 630,960 990,1230
I mentioned is prevent any

2095
01:06:11,510 --> 01:06:13,280
0,180 180,510 510,1110 1170,1470 1470,1770
other course scheduler from looking

2096
01:06:13,280 --> 01:06:14,450
0,90 90,180 180,660 660,900 900,1170
at our process until all

2097
01:06:14,450 --> 01:06:16,190
0,240 240,960 990,1080 1080,1620 1620,1740
three steps have completed so

2098
01:06:16,190 --> 01:06:17,720
0,180 210,450 450,570 570,960 960,1530
the lock is basically making

2099
01:06:18,020 --> 01:06:19,860
0,390 390,870 870,1560
those steps atomic.

2100
01:06:19,860 --> 01:06:20,940
0,90 90,330 330,510 510,990 990,1080
They either all happened from

2101
01:06:20,940 --> 01:06:21,600
0,90 90,270 270,330 330,480 480,660
the point of view of

2102
01:06:21,630 --> 01:06:24,120
0,210 210,1050 1170,1860 1980,2430 2430,2490
other corps, um, none of

2103
01:06:24,120 --> 01:06:25,340
0,210 210,780
them happened.

2104
01:06:26,160 --> 01:06:27,480
0,360 480,780 780,900 900,990 990,1320
Um, it's going to turn

2105
01:06:27,480 --> 01:06:29,010
0,330 330,660 660,840 840,960 960,1530
out also when we start

2106
01:06:29,010 --> 01:06:30,990
0,210 210,300 300,1020 1260,1740 1860,1980
running a process that the

2107
01:06:30,990 --> 01:06:32,580
0,390 390,660 660,900 930,1200 1200,1590
PR lock is going to

2108
01:06:32,610 --> 01:06:35,490
0,210 210,480 480,1380 1380,2220 2250,2880
have a similar protective function,

2109
01:06:36,750 --> 01:06:37,890
0,360 360,510 510,690 690,1050 1050,1140
we're going to set the

2110
01:06:37,890 --> 01:06:38,850
0,300 300,360 360,450 450,840 840,960
state of a process to

2111
01:06:38,850 --> 01:06:40,200
0,360 360,480 480,600 600,900 900,1350
running when we start executing

2112
01:06:40,200 --> 01:06:41,100
0,60 60,600 600,690 690,780 780,900
a process and we're going

2113
01:06:41,100 --> 01:06:43,110
0,60 60,360 360,810 870,1800 1800,2010
to move its registers from

2114
01:06:43,110 --> 01:06:44,790
0,300 300,750 750,1380 1380,1560 1560,1680
its process context into the

2115
01:06:44,790 --> 01:06:48,030
0,240 240,600 600,1470 1530,2220 2610,3240
risk five registers, um, but.

2116
01:06:48,820 --> 01:06:50,350
0,240 240,390 390,870 870,1020 1020,1530
If an interrupt should happen

2117
01:06:50,350 --> 01:06:51,190
0,150 150,240 240,540 540,630 630,840
in the middle of that

2118
01:06:51,190 --> 01:06:52,630
0,720 720,840 840,1230 1230,1350 1350,1440
process, the interrupt going to

2119
01:06:52,630 --> 01:06:53,500
0,240 240,330 330,720 720,810 810,870
see the process in a

2120
01:06:53,500 --> 01:06:55,060
0,300 300,720 720,1020 1050,1440 1440,1560
weird state like maybe in

2121
01:06:55,060 --> 01:06:56,560
0,60 60,510 510,690 690,1080 1080,1500
the state of Mark running

2122
01:06:56,560 --> 01:06:58,960
0,240 270,870 870,1110 1110,1920 2070,2400
but hasn't yet finished moving

2123
01:06:58,960 --> 01:07:00,490
0,180 180,720 720,810 810,900 900,1530
its registers from the context

2124
01:07:00,490 --> 01:07:01,960
0,150 150,240 240,510 510,750 750,1470
into the risk five registers

2125
01:07:02,170 --> 01:07:02,710
0,210 210,330 330,420 420,480 480,540
and that would be a

2126
01:07:02,710 --> 01:07:04,450
0,540 540,690 690,960 990,1380 1380,1740
disaster, if a timer interrupt

2127
01:07:04,450 --> 01:07:05,500
0,300 300,540 540,720 720,840 840,1050
happened then because we might

2128
01:07:05,500 --> 01:07:07,000
0,330 330,570 570,720 720,870 870,1500
switch away from that process

2129
01:07:07,210 --> 01:07:08,800
0,720 720,810 810,1050 1050,1440 1440,1590
before it had restored its

2130
01:07:08,800 --> 01:07:11,160
0,1080
registers.

2131
01:07:11,220 --> 01:07:12,270
0,300 300,660 660,810 810,960 960,1050
And switching away from that

2132
01:07:12,270 --> 01:07:14,220
0,420 420,570 570,1410 1440,1740 1770,1950
process would save now an

2133
01:07:14,220 --> 01:07:16,440
0,660 660,810 810,1170 1170,2010 2010,2220
initialized with five registers into

2134
01:07:16,440 --> 01:07:19,470
0,90 90,960 1080,1560 1560,2250 2340,3030
the context processes context overwriting

2135
01:07:19,470 --> 01:07:21,690
0,180 180,390 390,1050 1470,1830 1830,2220
its real registers, so indeed

2136
01:07:21,690 --> 01:07:23,250
0,120 120,480 510,1050 1050,1110 1110,1560
we want starting a process

2137
01:07:23,250 --> 01:07:25,620
0,150 150,690 690,1140 1170,1740 1740,2370
to also be effectively atomic.

2138
01:07:26,430 --> 01:07:27,600
0,420 510,780 780,840 840,990 990,1170
Um, and in this case

2139
01:07:27,600 --> 01:07:29,310
0,390 390,510 510,930 930,1320 1320,1710
holding a lock holding PR

2140
01:07:29,310 --> 01:07:31,230
0,360 360,1020 1050,1590 1590,1860 1860,1920
lock across switching to a

2141
01:07:31,230 --> 01:07:33,630
0,840 1560,1740 1740,1920 1920,2040 2040,2400
process as well as preventing

2142
01:07:33,630 --> 01:07:34,650
0,180 180,600 600,720 720,960 960,1020
other cores from looking at

2143
01:07:34,650 --> 01:07:35,910
0,150 150,570 570,840 840,1110 1110,1260
that process also turns off

2144
01:07:35,910 --> 01:07:38,490
0,780 1110,1650 1650,1710 1710,2250 2250,2580
interrupts for the duration of

2145
01:07:38,760 --> 01:07:40,290
0,540 540,750 750,1020 1050,1140 1140,1530
spy ring up of switching

2146
01:07:40,290 --> 01:07:42,000
0,60 60,270 270,810 900,1350 1350,1710
to that thread which prevents

2147
01:07:42,000 --> 01:07:43,470
0,60 60,480 480,1020 1020,1230 1230,1470
a timer interrupt from ever

2148
01:07:43,470 --> 01:07:45,570
0,450 450,540 540,1200 1200,1590 1650,2100
seeing a process that's only

2149
01:07:45,570 --> 01:07:48,030
0,990 1290,1560 1560,1770 1770,2280 2280,2460
midway through being switched to.

2150
01:07:49,510 --> 01:07:50,640
0,60
Yeah.

2151
01:07:51,320 --> 01:07:52,360
0,480
Okay.

2152
01:07:53,670 --> 01:07:54,780
0,690 720,870 870,990 990,1050 1050,1110
Um, so we're in the

2153
01:07:54,780 --> 01:07:56,940
0,690 990,1350 1350,1710 1710,1920 1920,2160
scheduler, we're executing this loop

2154
01:07:56,940 --> 01:07:58,080
0,60 60,150 150,630 630,930 930,1140
in the {scheduler's -} loop

2155
01:07:58,080 --> 01:07:59,040
0,60 60,150 150,600 600,720 720,960
in the schedule that looks

2156
01:07:59,040 --> 01:08:00,090
0,60 60,270 270,360 360,810 810,1050
at all the process isn't

2157
01:08:00,090 --> 01:08:00,990
0,330 330,420 420,660 660,810 810,900
turned to find one to

2158
01:08:00,990 --> 01:08:03,330
0,510 870,1500 1710,2010 2010,2130 2130,2340
run and in this case,

2159
01:08:03,330 --> 01:08:04,590
0,90 90,300 300,480 480,720 720,1260
we know there's another process

2160
01:08:04,590 --> 01:08:06,300
0,780 810,1170
because um.

2161
01:08:06,590 --> 01:08:08,150
0,330 330,510 510,870 870,1170 1170,1560
There's that other spin process

2162
01:08:08,150 --> 01:08:10,790
0,120 120,300 300,720 1020,1410 1920,2640
that we've worked, um but

2163
01:08:11,090 --> 01:08:12,050
0,240 240,300 300,450 450,510 510,960
there's a lot of process

2164
01:08:12,050 --> 01:08:14,360
0,210 210,330 330,1020 1410,1920 2040,2310
lots to examine I'm going

2165
01:08:14,360 --> 01:08:15,440
0,60 60,450 450,690 690,780 780,1080
to skip over the actual

2166
01:08:15,440 --> 01:08:17,690
0,540 570,1350 1350,1470 1470,1830 1860,2250
process scanning of the process

2167
01:08:17,690 --> 01:08:19,340
0,540 630,960 960,1050 1050,1440 1440,1650
table and go direct to

2168
01:08:19,370 --> 01:08:20,860
0,150 150,420 420,510 510,1020
the point of which.

2169
01:08:20,860 --> 01:08:22,000
0,150 150,540 540,900 900,960 960,1140
The scheduler finds the next

2170
01:08:22,000 --> 01:08:22,810
0,390 390,510 510,570 570,690 690,810
process so I'm gonna put

2171
01:08:22,810 --> 01:08:24,380
0,60 60,330 330,870
a break point.

2172
01:08:24,380 --> 01:08:25,660
0,660
I'm.

2173
01:08:26,320 --> 01:08:28,270
0,750 930,1200 1200,1380 1380,1680 1680,1950
At line four seventy four

2174
01:08:28,270 --> 01:08:29,260
0,180 180,300 300,600 600,930 930,990
where it's actually found a

2175
01:08:29,260 --> 01:08:30,880
0,150 150,690
new processor.

2176
01:08:31,920 --> 01:08:33,180
0,180 180,390 390,510 510,930 1050,1260
But here we are a

2177
01:08:33,180 --> 01:08:35,850
0,120 120,930 1890,2220 2220,2310 2310,2670
the schedulers scan the process

2178
01:08:35,850 --> 01:08:37,260
0,330 330,510 510,810 810,1050 1050,1410
table and found another process

2179
01:08:37,260 --> 01:08:38,280
0,90 90,480
to run.

2180
01:08:38,840 --> 01:08:40,670
0,330 330,660 1140,1440 1440,1680 1680,1830
Um, and um, it's going

2181
01:08:40,670 --> 01:08:41,990
0,270 300,510 510,660 660,990 990,1320
to cause that process run

2182
01:08:41,990 --> 01:08:43,010
0,390 390,510 510,690 690,750 750,1020
you can see a line

2183
01:08:43,010 --> 01:08:44,780
0,210 210,660 660,810 1020,1620 1620,1770
for 68 it acquired that

2184
01:08:44,780 --> 01:08:46,340
0,570 570,1020 1050,1230 1230,1410 1410,1560
processes lock, so now it's

2185
01:08:46,340 --> 01:08:48,140
0,570 570,780 810,1320 1320,1410 1410,1800
entitled to do the various

2186
01:08:48,140 --> 01:08:49,460
0,390 390,480 480,930 930,1020 1020,1320
steps were required to switch

2187
01:08:49,460 --> 01:08:52,130
0,120 120,300 300,1050 1470,1950 2220,2670
to that process in line

2188
01:08:52,130 --> 01:08:53,360
0,210 210,840 840,930 930,1140 1140,1230
for 73 it set the

2189
01:08:53,360 --> 01:08:54,860
0,420 420,510 510,810 810,930 930,1500
process of state to running.

2190
01:08:55,440 --> 01:08:56,370
0,120 120,300 300,420 420,630 630,930
It's now at four seventy

2191
01:08:56,370 --> 01:08:57,600
0,180 180,270 270,390 390,480 480,1230
four we're going to record

2192
01:08:57,600 --> 01:08:59,760
0,120 120,210 210,660 660,1410 1440,2160
in the CPU structure which

2193
01:08:59,760 --> 01:09:01,680
0,540 540,660 660,1110 1110,1200 1200,1920
process the CPU is executing

2194
01:09:02,730 --> 01:09:04,860
0,570 630,960 960,1170 1170,1860 1860,2130
and then call switch to

2195
01:09:04,860 --> 01:09:07,110
0,930 960,1080 1080,1560 1560,2130 2130,2250
save the schedulers registers and

2196
01:09:07,110 --> 01:09:10,440
0,780 1200,1650 1680,2160 2160,2730 2730,3330
restore a target processor's registers

2197
01:09:10,500 --> 01:09:11,130
0,180 180,240 240,330 330,480 480,630
so you can see what

2198
01:09:11,130 --> 01:09:12,480
0,360 360,420 420,900 900,1020 1020,1350
process is found by looking

2199
01:09:12,480 --> 01:09:15,060
0,210 1020,1260 1290,1500 1500,2040 2040,2580
at a new process named

2200
01:09:15,150 --> 01:09:17,040
0,600 600,720 720,1440
surprisingly its spin.

2201
01:09:17,590 --> 01:09:18,520
0,240 240,360 360,660 660,840 840,930
Um, it's process, ID is

2202
01:09:18,520 --> 01:09:19,900
0,150 150,810 1020,1170 1170,1290 1290,1380
now for you to be

2203
01:09:19,900 --> 01:09:21,670
0,270 270,780 810,1080 1080,1290 1290,1770
running three now working for

2204
01:09:21,850 --> 01:09:23,500
0,1080
um.

2205
01:09:23,960 --> 01:09:24,830
0,240 240,390 390,600 600,780 780,870
Um, we've already set the

2206
01:09:24,830 --> 01:09:26,580
0,240 240,360 360,750 750,1080
state to running so.

2207
01:09:26,580 --> 01:09:27,780
0,660
I'm.

2208
01:09:29,420 --> 01:09:31,790
0,570 570,660 660,930 930,1290 1800,2370
Just the states running, um.

2209
01:09:32,550 --> 01:09:33,840
0,270 270,390 390,540 540,990 990,1290
We can see where this

2210
01:09:33,840 --> 01:09:34,860
0,270 270,390 390,540 540,600 600,1020
thread is going to switch

2211
01:09:34,860 --> 01:09:35,940
0,540 570,720 720,780 780,990 990,1080
to in the call to

2212
01:09:35,940 --> 01:09:38,800
0,330 330,600 600,810 810,1830
switch line for 75.

2213
01:09:39,020 --> 01:09:40,940
0,690 1080,1170 1170,1320 1320,1860 1860,1920
I'm in this context he

2214
01:09:40,940 --> 01:09:43,640
0,300 300,1110 1530,1860 2010,2250 2250,2700
saved registers, um, so where

2215
01:09:43,640 --> 01:09:45,470
0,120 120,240 240,960 1500,1710 1710,1830
is the array, we're going

2216
01:09:45,470 --> 01:09:47,300
0,60 60,330 330,810 810,1050 1080,1830
to call switch but switch

2217
01:09:47,300 --> 01:09:49,340
0,120 120,270 270,660 660,840 840,2040
as we know it returns

2218
01:09:49,520 --> 01:09:50,900
0,300 300,390 390,810 810,900 900,1380
when it returns it returns

2219
01:09:50,900 --> 01:09:52,430
0,90 90,180 180,840 840,1140 1140,1530
to the restored our a

2220
01:09:52,550 --> 01:09:53,690
0,240 240,360 360,630 630,870 870,1140
so we really care about

2221
01:09:53,690 --> 01:09:55,490
0,390 600,1230 1230,1410 1410,1560 1560,1800
is where is it that

2222
01:09:55,790 --> 01:09:57,080
0,390 390,630 630,750 750,1170 1170,1290
a are a points to

2223
01:09:57,080 --> 01:09:58,250
0,300 300,420 420,690 690,870 870,1170
we can find that out

2224
01:09:58,250 --> 01:09:59,240
0,570
by.

2225
01:10:00,740 --> 01:10:01,840
0,570
Oops.

2226
01:10:02,100 --> 01:10:04,290
0,600 630,930 930,1170 1170,1560 1560,2190
I'm using X slash I.

2227
01:10:07,440 --> 01:10:08,460
0,180 180,270 270,390 390,450 450,1020
Um, it's going to return

2228
01:10:08,460 --> 01:10:09,630
0,150 150,390 390,780 780,960 960,1170
a {re-points -} to some

2229
01:10:09,630 --> 01:10:11,100
0,240 240,870 900,1140 1140,1350 1350,1470
point instead that's not too

2230
01:10:11,100 --> 01:10:13,500
0,540 540,930 990,1830 1830,2130 2130,2400
surprising since presumably that other

2231
01:10:13,500 --> 01:10:16,320
0,390 390,1170
spin process.

2232
01:10:16,410 --> 01:10:17,490
0,150 150,840 840,930 930,1020 1020,1080
Was suspended due to a

2233
01:10:17,490 --> 01:10:18,690
0,330 330,720 720,930 930,1080 1080,1200
timer interrupt which, as we

2234
01:10:18,690 --> 01:10:20,440
0,330 360,600 600,1170
know called sketch.

2235
01:10:20,940 --> 01:10:22,900
0,270 270,450 450,990
What's called switch.

2236
01:10:26,450 --> 01:10:29,300
0,570 1020,1710 2280,2580 2580,2640 2640,2850
Alright I'm about to call

2237
01:10:29,300 --> 01:10:30,290
0,450 450,570 570,630 630,840 840,990
switch, let me just bring

2238
01:10:30,290 --> 01:10:31,730
0,120 120,360 360,630 630,870 870,1440
up the switch code again.

2239
01:10:34,050 --> 01:10:35,600
0,870
I'm.

2240
01:10:38,660 --> 01:10:40,790
0,480 480,780 780,1200 1200,1320 1320,2130
Actually enter switch were still.

2241
01:10:41,390 --> 01:10:42,470
0,240 240,660 660,900 900,990 990,1080
Um, where shows that were

2242
01:10:42,470 --> 01:10:43,700
0,330 330,420 420,510 510,1140 1140,1230
still in the {scheduler's -}

2243
01:10:43,700 --> 01:10:45,060
0,750
context.

2244
01:10:45,060 --> 01:10:46,320
0,660
I'm.

2245
01:10:46,940 --> 01:10:48,950
0,210 210,390 390,840 1140,1560 1560,2010
I want to again execute

2246
01:10:48,950 --> 01:10:49,970
0,210 210,300 300,480 480,930 930,1020
all of the instructions to

2247
01:10:49,970 --> 01:10:51,080
0,270 270,390 390,570 570,960 960,1110
switch this time switching from

2248
01:10:51,080 --> 01:10:52,760
0,60 60,660 660,810 810,1290 1380,1680
the scheduler to the new

2249
01:10:52,760 --> 01:10:54,140
0,900
process.

2250
01:10:54,400 --> 01:10:55,780
0,120 120,390 390,540 540,630 630,1380
We skip over the 28

2251
01:10:55,810 --> 01:10:57,720
0,480 480,570 570,1440
stores and loads.

2252
01:10:58,850 --> 01:11:00,220
0,540
HMM.

2253
01:11:00,460 --> 01:11:02,650
0,840 870,1290 1290,1860 1860,2070 2070,2190
Just convince ourselves that we

2254
01:11:02,650 --> 01:11:03,760
0,210 210,450 450,690 690,780 780,1110
are actually about to return

2255
01:11:03,760 --> 01:11:04,900
0,90 90,540 540,690 690,900 900,1140
to sketch, so now since

2256
01:11:04,900 --> 01:11:05,800
0,240 330,510 510,570 570,810 810,900
we're about to return to

2257
01:11:05,800 --> 01:11:07,270
0,540 540,660 660,840 840,1290 1290,1470
schedule and not schedule a

2258
01:11:07,390 --> 01:11:08,740
0,240 240,480 480,630 630,1080 1170,1350
we must now be in

2259
01:11:08,740 --> 01:11:10,300
0,300 330,870 870,1140 1140,1440 1440,1560
a processes, kernel thread and

2260
01:11:10,300 --> 01:11:12,740
0,150 150,720
no longer.

2261
01:11:12,980 --> 01:11:14,570
0,150 150,510 510,570 570,960 960,1590
The schedule of threatened indeed

2262
01:11:14,570 --> 01:11:15,050
0,90 90,210 210,330 330,420 420,480
if we look at the

2263
01:11:15,050 --> 01:11:16,820
0,270 270,1020 1140,1440 1440,1650 1650,1770
back trace we had a

2264
01:11:16,820 --> 01:11:18,470
0,330 330,690 690,1290 1320,1470 1470,1650
user trap call that must

2265
01:11:18,470 --> 01:11:19,790
0,90 90,180 180,210 210,630 630,1320
have been a timer interrupt

2266
01:11:19,880 --> 01:11:21,080
0,210 210,480 480,540 540,720 780,1200
from long you know sometime

2267
01:11:21,080 --> 01:11:23,030
0,60 60,120 120,780 1230,1560 1560,1950
in the past, um that

2268
01:11:23,450 --> 01:11:24,470
0,180 180,330 330,540 540,750 750,1020
as we've seen called yield

2269
01:11:24,470 --> 01:11:25,370
0,90 90,390 390,540 540,600 600,900
and scared but it was

2270
01:11:25,370 --> 01:11:26,480
0,90 90,390 390,720 720,840 840,1110
the timer interrupted the other

2271
01:11:26,480 --> 01:11:28,400
0,570 570,990 1380,1800 1800,1860 1860,1920
process now not in the

2272
01:11:28,400 --> 01:11:30,110
0,450 450,570 570,810 840,1440 1440,1710
process that we originally looked

2273
01:11:30,110 --> 01:11:30,680
0,150
at.

2274
01:11:35,600 --> 01:11:39,320
0,570 600,1200 1620,1890 1890,2850 2910,3720
Okay, um, any questions about

2275
01:11:39,380 --> 01:11:40,700
0,180 180,330 330,420 420,840 870,1320
I think I'm gonna leave

2276
01:11:40,700 --> 01:11:42,140
0,570 600,990 990,1110 1110,1200 1200,1440
off stepping through the code

2277
01:11:42,140 --> 01:11:44,570
0,60 60,240 240,870 1440,2040 2040,2430
at this point, any questions

2278
01:11:44,570 --> 01:11:46,820
0,600 1470,1710 1710,1770 1770,1830 1830,2250
about any of the material

2279
01:11:46,820 --> 01:11:47,880
0,150 150,510
we've seen.

2280
01:11:49,790 --> 01:11:51,620
0,270 270,660 660,1260 1260,1410 1410,1830
Oh, sorry if it was

2281
01:11:51,650 --> 01:11:53,540
0,240 240,390 390,900 900,1200 1200,1890
a for example this caio,

2282
01:11:53,810 --> 01:11:55,430
0,180 180,660 690,870 870,1080 1080,1620
um, then we would see

2283
01:11:55,640 --> 01:11:58,310
0,240 240,840 1290,2070 2070,2310 2310,2670
a that array would point

2284
01:11:58,310 --> 01:12:01,370
0,510 510,990 1410,2190 2190,2610 2610,3060
somewhere to like sleeve or

2285
01:12:01,400 --> 01:12:03,240
0,480 480,690 690,1020 1020,1380
something like that, right.

2286
01:12:03,360 --> 01:12:06,740
0,1650 1830,2880
Um, yes.

2287
01:12:07,040 --> 01:12:08,300
0,810
Well.

2288
01:12:08,340 --> 01:12:09,810
0,570 570,750 750,960 960,1080 1080,1470
We see that the where

2289
01:12:09,810 --> 01:12:11,460
0,90 90,300 300,660 660,780 780,1650
at this point would include

2290
01:12:11,490 --> 01:12:13,950
0,450 450,840 840,1110 1110,1770 1770,2460
some system call implementation functions

2291
01:12:13,950 --> 01:12:14,880
0,90 90,120 120,360 360,420 420,930
and a call to sleep

2292
01:12:14,910 --> 01:12:16,260
0,240 240,360 360,720 720,810 810,1350
as it happens I think.

2293
01:12:17,080 --> 01:12:19,000
0,150 150,600 600,810 1200,1530 1530,1920
Hi, this is you're basically

2294
01:12:19,000 --> 01:12:21,520
0,300 300,660 660,1230 1410,2070 2310,2520
answering questions, yes, um, if

2295
01:12:21,520 --> 01:12:23,560
0,150 150,300 300,720 1080,1440 1440,2040
we had just left off

2296
01:12:23,650 --> 01:12:25,240
0,540 540,750 750,1200 1200,1410 1410,1590
executing this process for some

2297
01:12:25,240 --> 01:12:26,080
0,210 210,360 360,450 450,510 510,840
reason other than the timer

2298
01:12:26,080 --> 01:12:28,360
0,570 840,1470 1500,1890 1890,2130 2130,2280
interrupt a switch would be

2299
01:12:28,360 --> 01:12:30,400
0,450 450,930 930,1200 1500,1710 1710,2040
basically returning to some system

2300
01:12:30,400 --> 01:12:31,990
0,270 270,570 570,990 990,1230 1230,1590
call code instead of to

2301
01:12:32,230 --> 01:12:33,250
0,450 450,570 570,660 660,960 960,1020
scale as it happens I

2302
01:12:33,250 --> 01:12:34,720
0,180 180,510 570,750 750,1020 1020,1470
think sleep may call skit

2303
01:12:34,720 --> 01:12:35,800
0,360 360,600
so um.

2304
01:12:36,400 --> 01:12:37,480
0,570
HMM.

2305
01:12:37,750 --> 01:12:38,680
0,270 270,450 450,690 690,780 780,930
The back trace would look

2306
01:12:38,680 --> 01:12:39,790
0,270 270,420 420,570 570,840 840,1110
different what just happened include

2307
01:12:39,790 --> 01:12:41,770
0,420 510,630 630,1050 1440,1680 1680,1980
sketch, but yes I've chosen

2308
01:12:41,770 --> 01:12:43,480
0,180 180,420 420,840 840,1170
just one way of.

2309
01:12:43,650 --> 01:12:44,920
0,180 180,330 330,750
You know just.

2310
01:12:44,950 --> 01:12:46,120
0,240 240,480 480,570 570,930 930,1170
One way of switching between

2311
01:12:46,120 --> 01:12:47,320
0,600 600,720 720,840 840,1080 1080,1200
processes due to time or

2312
01:12:47,320 --> 01:12:49,420
0,660
UPS.

2313
01:12:49,700 --> 01:12:50,930
0,120 120,240 240,450 450,660 660,1230
But you also get switches

2314
01:12:50,930 --> 01:12:52,340
0,120 120,330 330,690 750,1080 1080,1410
to wait for user io

2315
01:12:52,370 --> 01:12:53,570
0,300 300,420 420,570 570,1110 1110,1200
wait for other processes to

2316
01:12:53,570 --> 01:12:54,650
0,180 180,510 510,720 750,960 960,1080
do things like write to

2317
01:12:54,650 --> 01:12:55,560
0,60 60,450
a pipe.

2318
01:12:58,380 --> 01:12:59,820
0,390 390,600 600,780 780,1140 1170,1440
OK, one thing to you

2319
01:12:59,820 --> 01:13:01,980
0,330 330,900 900,1110 1110,1440 1650,2160
probably noticed is that a

2320
01:13:02,190 --> 01:13:04,940
0,960 960,1290 1290,2220
scheduler called switch.

2321
01:13:04,940 --> 01:13:06,320
0,480 510,660 660,870 870,960 960,1380
And we're about to return

2322
01:13:06,320 --> 01:13:08,960
0,180 180,600 600,1140 1410,1980 2370,2640
from switch here but we're

2323
01:13:08,960 --> 01:13:10,460
0,660 660,960 960,1110 1110,1230 1230,1500
returning really from a different

2324
01:13:10,460 --> 01:13:11,660
0,240 240,330 330,900 900,1080 1080,1200
call to switch than them

2325
01:13:11,660 --> 01:13:12,830
0,90 90,180 180,570 570,660 660,1170
on the schedule are made

2326
01:13:12,950 --> 01:13:13,940
0,240 240,570 570,720 720,780 780,990
were returning from a call

2327
01:13:13,940 --> 01:13:15,170
0,90 90,450 450,600 600,780 780,1230
to switch that this process

2328
01:13:15,170 --> 01:13:16,160
0,180 180,210 210,420 420,690 690,990
made a long time ago.

2329
01:13:18,110 --> 01:13:19,160
0,480
SO.

2330
01:13:19,250 --> 01:13:20,450
0,150 150,270 270,420 420,630 630,1200
You know, this is potentially

2331
01:13:20,450 --> 01:13:21,530
0,30 30,180 180,300 300,840 840,1080
a little bit confusing, but.

2332
01:13:22,470 --> 01:13:23,040
0,120 120,210 210,390 390,450 450,570
You know, this is how

2333
01:13:23,040 --> 01:13:23,880
0,90 90,420 420,480 480,570 570,840
the guts of a thread

2334
01:13:23,880 --> 01:13:25,300
0,360 360,780
switch work.

2335
01:13:25,730 --> 01:13:26,990
0,480 480,630 630,720 720,1140 1140,1260
Another thing to notice is

2336
01:13:26,990 --> 01:13:28,850
0,330 870,1110 1110,1440 1440,1530 1530,1860
that the code we're looking

2337
01:13:28,850 --> 01:13:29,810
0,150 150,270 270,570 570,810 810,960
at this switch code, this

2338
01:13:29,810 --> 01:13:31,670
0,120 120,330 330,420 420,1110 1140,1860
is really the heart of

2339
01:13:31,730 --> 01:13:33,600
0,630 630,1260
thread switching.

2340
01:13:33,600 --> 01:13:34,950
0,300 420,840 840,1110 1110,1230 1230,1350
And really all you have

2341
01:13:34,950 --> 01:13:36,210
0,90 90,240 240,330 330,720 720,1260
to do to switch switch

2342
01:13:36,210 --> 01:13:39,000
0,600 600,1110 1620,2100 2100,2700 2700,2790
threads is save registers and

2343
01:13:39,000 --> 01:13:41,310
0,480 480,1470 1560,1800 1800,2160 2160,2310
restore registers now threads have

2344
01:13:41,310 --> 01:13:42,210
0,30 30,270 270,450 450,810 810,900
a lot more state than

2345
01:13:42,210 --> 01:13:44,130
0,210 210,690 690,780 780,930 930,1920
just registers they have variables

2346
01:13:44,130 --> 01:13:45,540
0,330 360,750 750,840 840,900 900,1410
and stuff in the heap

2347
01:13:45,540 --> 01:13:47,490
0,150 150,270 270,450 450,1200 1320,1950
and who knows what I'm

2348
01:13:47,580 --> 01:13:49,710
0,600 600,810 810,1020 1020,1770 1860,2130
all that other state is

2349
01:13:49,710 --> 01:13:51,510
0,870 1050,1410 1410,1620 1620,1740 1740,1800
in-memory and isn't going to

2350
01:13:51,510 --> 01:13:53,040
0,120 120,870 870,1020 1020,1200 1200,1530
be disturbed, we've done nothing

2351
01:13:53,040 --> 01:13:54,620
0,90 90,1020
to disturb.

2352
01:13:54,620 --> 01:13:56,750
0,450 450,540 540,810 810,1350 1350,2130
Any of these threads stacks,

2353
01:13:56,750 --> 01:13:59,240
0,120 120,630 630,1050 1200,1560 1560,2490
for example or peep values,

2354
01:14:00,320 --> 01:14:01,940
0,240 240,570 600,1350 1350,1470 1470,1620
so the registers in the

2355
01:14:01,940 --> 01:14:03,380
0,780 780,840 840,1080 1080,1200 1200,1440
microprocessor are really the only

2356
01:14:03,380 --> 01:14:05,060
0,180 180,270 270,750 750,1320 1350,1680
kind of volatile state that

2357
01:14:05,270 --> 01:14:06,290
0,360 360,570 570,630 630,720 720,1020
actually needs to be saved

2358
01:14:06,290 --> 01:14:07,040
0,90 90,480 480,570 570,690 690,750
and restored to do a

2359
01:14:07,040 --> 01:14:08,540
0,270 270,690 720,1170 1170,1230 1230,1500
thread switch all the stuffs

2360
01:14:08,540 --> 01:14:10,280
0,60 60,720 810,1260 1260,1350 1350,1740
in memory stack, for example

2361
01:14:10,280 --> 01:14:11,450
0,120 120,480 480,570 570,660 660,1170
will still be in memory

2362
01:14:11,450 --> 01:14:13,310
0,360 390,1350 1440,1680 1680,1800 1800,1860
on undisturbed and so it

2363
01:14:13,310 --> 01:14:14,360
0,180 180,300 300,390 390,450 450,1050
doesn't have to be explicitly

2364
01:14:14,360 --> 01:14:15,900
0,450 450,540 540,1260
saved and restored.

2365
01:14:16,380 --> 01:14:17,190
0,150 150,270 270,420 420,720 720,810
Now we're only saving and

2366
01:14:17,190 --> 01:14:19,200
0,330 330,660 690,1530 1530,1620 1620,2010
restoring this microprocessor, the CPU

2367
01:14:19,200 --> 01:14:20,610
0,630 780,1080 1080,1170 1170,1320 1320,1410
registers because we want to

2368
01:14:20,610 --> 01:14:22,770
0,660 660,1110 1110,1500 1500,2070 2070,2160
reuse those very registers in

2369
01:14:22,770 --> 01:14:23,790
0,60 60,660 660,810 810,900 900,1020
the CPU for the new

2370
01:14:23,790 --> 01:14:25,800
0,540 540,660 690,1260 1260,1620 1620,2010
threat and overwrite whatever values

2371
01:14:25,800 --> 01:14:28,360
0,120 120,690 1050,1470 1500,2010
they have a so.

2372
01:14:28,650 --> 01:14:29,940
0,510 510,1020 1020,1110 1110,1200 1200,1290
Register, that's why we have

2373
01:14:29,940 --> 01:14:31,050
0,90 90,420 420,600 600,810 810,1110
to see the old threads

2374
01:14:31,050 --> 01:14:32,480
0,750
registers.

2375
01:14:32,970 --> 01:14:34,800
0,210 210,420 420,900 930,1470 1500,1830
Um, what about, um, other

2376
01:14:34,800 --> 01:14:36,270
0,660 660,1020 1050,1260 1260,1320 1320,1470
processors stay so I don't

2377
01:14:36,270 --> 01:14:37,590
0,180 180,360 360,660 660,810 810,1320
know the risk by processor

2378
01:14:37,590 --> 01:14:39,330
0,180 180,360 360,720 720,1080 1080,1740
that we're using has other

2379
01:14:39,360 --> 01:14:40,500
0,510 510,660 660,720 720,930 930,1140
flags but I know like

2380
01:14:40,500 --> 01:14:42,330
0,210 210,1020 1020,1350 1350,1650 1650,1830
some x86, Intel chips have

2381
01:14:42,330 --> 01:14:44,130
0,390 600,990 990,1080 1080,1500 1500,1800
like like the floating point

2382
01:14:44,130 --> 01:14:45,840
0,330 330,840 840,990 990,1350 1350,1710
unit state and like things

2383
01:14:45,840 --> 01:14:47,610
0,210 210,780 780,930 930,1380 1590,1770
like that do we do

2384
01:14:47,610 --> 01:14:48,540
0,90 90,270 270,450 450,630 630,930
we just not have that

2385
01:14:48,540 --> 01:14:50,560
0,450
response.

2386
01:14:50,620 --> 01:14:51,910
0,300 300,600 600,780 780,900 900,1290
Your point's very well taken

2387
01:14:51,910 --> 01:14:54,550
0,180 210,510 510,1440 1440,1650 1650,2640
on other microprocessors like x86

2388
01:14:54,550 --> 01:14:56,680
0,360 360,1620
the details.

2389
01:14:56,770 --> 01:14:58,600
0,690 690,1320 1320,1560 1560,1650 1650,1830
A switching are a bit

2390
01:14:58,600 --> 01:15:00,430
0,360 360,990 1110,1500 1500,1590 1590,1830
different because they have different

2391
01:15:00,430 --> 01:15:03,220
0,480 480,540 540,780 780,1260 2400,2790
registers in different state and

2392
01:15:03,220 --> 01:15:04,180
0,90 90,180 180,570 570,810 810,960
so the code this is

2393
01:15:04,180 --> 01:15:05,830
0,390 390,720 720,990 990,1290 1290,1650
very very risk five dependent

2394
01:15:05,830 --> 01:15:08,290
0,540 540,1020 1140,1470 1470,1950 1950,2460
code and the switch routine

2395
01:15:08,290 --> 01:15:11,120
0,390 720,960 960,1350 1530,2370
for some other processor.

2396
01:15:11,210 --> 01:15:12,230
0,240 240,330 330,540 540,840 840,1020
Might look quite different like

2397
01:15:12,230 --> 01:15:13,610
0,390 390,540 540,660 660,780 780,1380
indeed might have to save

2398
01:15:13,820 --> 01:15:15,590
0,330 330,540 540,1230 1440,1680 1680,1770
floating point registers now at

2399
01:15:15,590 --> 01:15:16,940
0,180 180,450 450,750 750,1020 1020,1350
risk five actually uses the.

2400
01:15:17,530 --> 01:15:19,540
0,360 360,690 690,1560
General purpose register.

2401
01:15:20,220 --> 01:15:21,930
0,600 1050,1350 1350,1470 1470,1590 1590,1710
Actually I'm not sure what

2402
01:15:21,930 --> 01:15:22,860
0,90 90,240 240,360 360,630 630,930
it does for floating point

2403
01:15:22,950 --> 01:15:24,540
0,750 840,990 990,1200 1200,1440 1440,1590
but the kernel doesn't use

2404
01:15:24,540 --> 01:15:25,350
0,270 270,480 480,570 570,630 630,810
floating point so it doesn't

2405
01:15:25,350 --> 01:15:26,100
0,120 120,210 210,420 420,600 600,750
have to worry about it,

2406
01:15:27,300 --> 01:15:28,410
0,360 360,480 480,600 600,690 690,1110
but yeah this is totally

2407
01:15:28,410 --> 01:15:30,100
0,720 720,1140
microprocessor dependent.

2408
01:15:31,710 --> 01:15:33,150
0,240 240,600 600,900 900,1080 1080,1440
A question about the timer

2409
01:15:33,150 --> 01:15:34,620
0,720
interrupts.

2410
01:15:34,680 --> 01:15:35,970
0,240 240,420 420,750 750,990 990,1290
So it sounds like the

2411
01:15:35,970 --> 01:15:37,320
0,90 90,630 630,840 840,1080 1080,1350
the core of all of

2412
01:15:37,320 --> 01:15:38,360
0,450
this.

2413
01:15:38,360 --> 01:15:40,160
0,660 660,1260 1260,1500 1500,1650 1650,1800
Scheduling working is that there

2414
01:15:40,160 --> 01:15:41,390
0,150 150,240 240,300 300,570 570,1230
will be a timer interrupt

2415
01:15:41,750 --> 01:15:43,160
0,240 240,480 480,960 960,1050 1050,1410
a what happens in cases

2416
01:15:43,160 --> 01:15:46,070
0,300 300,660 810,1860 2100,2730 2730,2910
where that malfunctions there is

2417
01:15:46,070 --> 01:15:46,700
0,120 120,180 180,270 270,330 330,630
going to be a timer

2418
01:15:46,700 --> 01:15:47,800
0,600
Internet.

2419
01:15:49,070 --> 01:15:52,720
0,630 960,1740 2100,2940
Um, so the.

2420
01:15:52,810 --> 01:15:55,150
0,120 120,270 270,270 960,1530 1830,2340
I know oh so, um

2421
01:15:55,180 --> 01:15:56,590
0,270 270,600 600,780 780,1260 1260,1410
okay, so the reasoning for

2422
01:15:56,590 --> 01:15:59,140
0,240 240,690 810,1800 1800,2370 2370,2550
how come preemptive scheduling of

2423
01:15:59,140 --> 01:16:01,380
0,360 360,930 930,1740
user processes works.

2424
01:16:01,410 --> 01:16:03,780
0,390 390,600 600,930 1440,1860 1860,2370
Um is that user processes

2425
01:16:03,780 --> 01:16:05,500
0,540 540,1170
execute wiz.

2426
01:16:05,740 --> 01:16:07,930
0,450 450,660 660,900 900,1770 1830,2190
Interrupts turned on always actually

2427
01:16:07,930 --> 01:16:10,570
0,270 270,750 1110,1710 1710,1950 2220,2640
six just ensures that interrupts

2428
01:16:10,570 --> 01:16:12,250
0,150 150,840 870,1260 1260,1590 1590,1680
are enabled before returning to

2429
01:16:12,250 --> 01:16:13,390
0,240 240,750 750,870 870,1020 1020,1140
user space and that means

2430
01:16:13,390 --> 01:16:14,680
0,120 120,180 180,510 510,960 990,1290
that a timer interrupt can

2431
01:16:14,680 --> 01:16:16,060
0,480 570,750 750,870 870,1290 1290,1380
happen if you're executing in

2432
01:16:16,060 --> 01:16:18,550
0,270 270,750 1140,1620 1740,2160 2160,2490
user space, so there's nothing

2433
01:16:18,550 --> 01:16:20,440
0,120 120,420 420,1290 1620,1770 1770,1890
a user process, if one

2434
01:16:20,440 --> 01:16:21,250
0,240 240,450 450,570 570,750 750,810
user space that I'm a

2435
01:16:21,250 --> 01:16:22,760
0,270 270,450 450,630 630,990
narrow just will happen.

2436
01:16:22,820 --> 01:16:24,020
0,180 180,360 360,420 420,630 630,1200
A when the time comes

2437
01:16:24,200 --> 01:16:25,520
0,360 360,750 750,810 810,870 870,1320
little trickier in the kernel,

2438
01:16:25,610 --> 01:16:26,840
0,180 180,420 420,810 810,1050 1050,1230
the kernel sometimes turns off

2439
01:16:26,840 --> 01:16:28,250
0,480 480,750 750,990 990,1080 1080,1410
interrupts like when you acquire

2440
01:16:28,250 --> 01:16:29,480
0,60 60,600 720,840 840,1170 1170,1230
a lock the interrupts are

2441
01:16:29,480 --> 01:16:30,170
0,120 120,180 180,240 240,480 480,690
going to be turned off

2442
01:16:30,170 --> 01:16:31,910
0,210 210,330 330,660 660,840 1200,1740
until you release it so

2443
01:16:32,150 --> 01:16:33,640
0,960
um.

2444
01:16:34,600 --> 01:16:36,490
0,450 450,930 1350,1590 1590,1740 1740,1890
Um, so if there were

2445
01:16:36,490 --> 01:16:38,110
0,600 600,900 900,990 990,1050 1050,1620
some bugs in the kernel,

2446
01:16:39,040 --> 01:16:40,000
0,210 210,270 270,540 540,780 780,960
if the kernel turned off

2447
01:16:40,000 --> 01:16:41,500
0,570 570,840 840,1110 1110,1380 1380,1500
interrupts and never turn them

2448
01:16:41,500 --> 01:16:43,840
0,300 300,840 1260,1650 1650,1800 2010,2340
back on and the code

2449
01:16:43,840 --> 01:16:44,890
0,60 60,120 120,450 450,840 840,1050
in the kernel never gave

2450
01:16:44,890 --> 01:16:46,630
0,120 120,210 210,1020 1080,1470 1470,1740
up the CPU never called

2451
01:16:46,630 --> 01:16:48,070
0,660 660,870 870,960 960,1050 1050,1440
sleeper gave up the CPU

2452
01:16:48,070 --> 01:16:49,960
0,180 180,360 360,570 570,960 1440,1890
for any other reason, then

2453
01:16:49,960 --> 01:16:52,450
0,720 900,1500 1500,1890 1890,2250 2250,2490
indeed a timer interrupt would

2454
01:16:52,450 --> 01:16:53,950
0,600 600,960 960,1110 1110,1260 1260,1500
occur and that would mean

2455
01:16:53,950 --> 01:16:54,740
0,360
that.

2456
01:16:55,470 --> 01:16:56,940
0,240 240,510 510,780 780,1290 1320,1470
This kernel code, may you

2457
01:16:56,940 --> 01:16:57,920
0,270
know.

2458
01:16:58,890 --> 01:16:59,850
0,240 240,570 570,720 720,870 870,960
We would never give the

2459
01:16:59,850 --> 01:17:01,640
0,450 450,570 570,660 660,1230
CPU but in fact.

2460
01:17:01,670 --> 01:17:02,480
0,330 330,480 480,600 600,690 690,810
A as far as we

2461
01:17:02,480 --> 01:17:05,030
0,510 810,1170 1170,1830 1920,2280 2280,2550
know xc six zero xc

2462
01:17:05,030 --> 01:17:06,680
0,300 300,420 420,690 900,1380 1380,1650
six so that a it

2463
01:17:06,680 --> 01:17:08,150
0,330 330,570 570,960 960,1230 1230,1470
always turns interrupts back on

2464
01:17:08,150 --> 01:17:09,060
0,360
or.

2465
01:17:09,900 --> 01:17:11,310
0,150 150,300 330,510 510,690 690,1410
You know if there's kodak's

2466
01:17:11,310 --> 01:17:12,840
0,90 90,300 300,570 570,1200 1290,1530
it turns off interrupts it

2467
01:17:12,840 --> 01:17:14,250
0,180 180,480 480,600 600,870 870,1410
either turns them back on

2468
01:17:14,280 --> 01:17:15,640
0,180 180,420 420,780
and so, um.

2469
01:17:16,240 --> 01:17:17,500
0,330 330,630 630,780 780,960 960,1260
Timer interrupt can then occur

2470
01:17:17,500 --> 01:17:18,280
0,60 60,120 120,570 570,690 690,780
in the kernel, and we

2471
01:17:18,280 --> 01:17:19,300
0,210 210,540 540,750 750,900 900,1020
can switch away from this

2472
01:17:19,300 --> 01:17:21,490
0,270 270,720 870,1620 1830,2100 2100,2190
kernel thread or um the

2473
01:17:21,490 --> 01:17:22,600
0,240 240,570 570,750 750,840 840,1110
code returns back to user

2474
01:17:22,600 --> 01:17:24,370
0,750 780,1020 1020,1290 1290,1560 1560,1770
space kernel code turns back

2475
01:17:24,370 --> 01:17:26,020
0,90 90,330 330,780 810,990 990,1650
to user space, we believe

2476
01:17:26,080 --> 01:17:27,340
0,270 270,450 450,510 510,1170 1170,1260
there's never a situation in

2477
01:17:27,340 --> 01:17:29,200
0,210 210,540 540,1020 1200,1530 1530,1860
which kernel code will simply

2478
01:17:29,200 --> 01:17:31,300
0,780 990,1200 1200,1560 1560,1800 1800,2100
loop with interrupts turned off

2479
01:17:31,300 --> 01:17:32,360
0,600
forever.

2480
01:17:33,990 --> 01:17:35,280
0,90 90,390 450,810 810,1140 1140,1290
I got my question was

2481
01:17:35,280 --> 01:17:36,420
0,180 180,510 510,810 840,1020 1020,1140
more about like so I

2482
01:17:36,420 --> 01:17:37,620
0,240 240,420 420,900 900,960 960,1200
assume the interrupts are actually

2483
01:17:37,620 --> 01:17:38,490
0,240 240,420 420,570 570,780 780,870
coming from some piece of

2484
01:17:38,490 --> 01:17:40,140
0,600 840,1080 1080,1200 1200,1470 1470,1650
hardware, what if that piece

2485
01:17:40,140 --> 01:17:42,580
0,90 90,510 510,1350 1380,1830
of hardware malfunctions, no.

2486
01:17:45,330 --> 01:17:46,740
0,90 90,420 840,1080 1080,1350 1350,1410
I mean your computer is

2487
01:17:46,740 --> 01:17:47,520
0,360 360,480 480,600 600,720 720,780
broken, you should buy a

2488
01:17:47,520 --> 01:17:48,500
0,120 120,270
new one.

2489
01:17:50,560 --> 01:17:52,450
0,360 450,540 540,1530 1530,1680 1680,1890
Okay, I mean that's a

2490
01:17:52,450 --> 01:17:53,860
0,270 270,630 630,930 960,1080 1080,1410
valid question for me there's

2491
01:17:54,070 --> 01:17:56,080
0,210 210,420 630,1020 1020,1380 1380,2010
you know 10 billion transistors

2492
01:17:56,080 --> 01:17:57,880
0,60 60,180 180,660 660,1110 1170,1800
in your computer, and indeed

2493
01:17:58,000 --> 01:17:59,760
0,630 630,690 690,1230
sometimes the harder.

2494
01:17:59,970 --> 01:18:00,930
0,330 330,480 480,630 630,870 870,960
Just like has bugs in

2495
01:18:00,930 --> 01:18:02,220
0,120 120,240 240,690
it but that's.

2496
01:18:02,490 --> 01:18:04,880
0,630 630,810 810,1410 1410,1800
Beyond our reach for.

2497
01:18:05,220 --> 01:18:06,540
0,210 210,420 480,900 900,1020 1020,1320
I mean, if you add

2498
01:18:06,540 --> 01:18:07,380
0,210 210,300 300,510 510,750 750,840
one and one and the

2499
01:18:07,380 --> 01:18:09,460
0,330 330,600 600,960 960,1350
computer says three then.

2500
01:18:10,690 --> 01:18:12,160
0,360 360,510 510,630 630,840 840,1470
You just have deep problems

2501
01:18:12,160 --> 01:18:13,750
0,210 570,1110 1110,1320 1320,1500 1500,1590
that x86 can't help you

2502
01:18:13,750 --> 01:18:14,900
0,360
with.

2503
01:18:16,710 --> 01:18:17,910
0,270 270,420 420,870 870,1020 1020,1200
So we're assuming that the

2504
01:18:17,910 --> 01:18:19,380
0,330 330,990
computer works.

2505
01:18:20,370 --> 01:18:21,780
0,360 360,540 540,870 870,1020 1020,1410
The only time when that.

2506
01:18:23,030 --> 01:18:25,580
0,240 240,1320 1440,1710 1800,2490 2490,2550
When software mean there are

2507
01:18:25,580 --> 01:18:26,480
0,240 240,330 330,630 630,810 810,900
times when software tries to

2508
01:18:26,480 --> 01:18:28,100
0,450 450,570 570,870 870,1110 1110,1620
compensate for hardware level errors

2509
01:18:28,100 --> 01:18:29,660
0,330 390,660 660,750 750,1200 1200,1560
like if you're sending packets

2510
01:18:29,660 --> 01:18:31,520
0,270 270,360 360,1080 1440,1680 1680,1860
across the network, you always

2511
01:18:31,520 --> 01:18:33,240
0,150 150,210 210,1200
send a checksum.

2512
01:18:33,240 --> 01:18:34,710
0,210 210,420 420,720 720,960 990,1470
So that if the network

2513
01:18:34,710 --> 01:18:37,590
0,750 930,1350 1350,1410 1410,1710 2010,2880
hardware flips a bit malfunctions

2514
01:18:37,590 --> 01:18:38,730
0,300 300,360 360,630 630,930 990,1140
flips a bit then you

2515
01:18:38,730 --> 01:18:40,260
0,240 480,810 810,990 990,1230 1260,1530
can correct that but for

2516
01:18:40,260 --> 01:18:42,100
0,210 210,540 540,630 630,1080
stuff inside the computer.

2517
01:18:42,100 --> 01:18:43,540
0,180 180,450 450,720 720,1080 1260,1440
People tend not to it's

2518
01:18:43,540 --> 01:18:44,340
0,300
just.

2519
01:18:45,740 --> 01:18:47,340
0,210 210,570 570,900
People basically don't.

2520
01:18:47,890 --> 01:18:48,760
0,270 270,330 330,480 480,540 540,870
Try to make the software

2521
01:18:48,760 --> 01:18:50,880
0,540 540,660 660,1020 1020,1530
compensate for hardware errors.

2522
01:18:54,170 --> 01:18:55,340
0,270 270,390 390,570 570,660 660,1170
Oh I have a question

2523
01:18:55,340 --> 01:18:57,530
0,690 720,840 840,990 990,1320 1800,2190
why I was like in

2524
01:18:57,560 --> 01:19:00,410
0,630 630,1020 1050,1710 1710,2160 2220,2850
trampling dot ascendance which we

2525
01:19:00,440 --> 01:19:02,570
0,390 390,720 720,1260 1290,1590 1590,2130
write the code in assembly

2526
01:19:02,570 --> 01:19:03,860
0,150 150,330 330,780 810,1080 1080,1290
is that why is that

2527
01:19:03,860 --> 01:19:05,150
0,600 600,750 750,990 990,1110 1110,1290
because we want to make

2528
01:19:05,150 --> 01:19:07,700
0,300 300,630 1020,1800 1800,2280 2280,2550
sure that exactly this thing

2529
01:19:07,700 --> 01:19:09,840
0,750 930,1140 1140,1230 1230,1710
happening so we cannot.

2530
01:19:10,180 --> 01:19:11,140
0,120 120,300 300,660 660,810 810,960
You can write and see

2531
01:19:11,140 --> 01:19:13,440
0,630 990,1200 1200,1440 1440,1740
because we just need.

2532
01:19:13,440 --> 01:19:15,180
0,120 120,540 540,870 1080,1320 1320,1740
It feels like those exact

2533
01:19:15,180 --> 01:19:17,140
0,270 270,390 390,690 690,1320
things to happen basically.

2534
01:19:17,390 --> 01:19:18,860
0,840
I'm.

2535
01:19:19,530 --> 01:19:22,300
0,510 510,1170 1320,2010
Yeah yeah, um.

2536
01:19:22,800 --> 01:19:23,700
0,210 210,480 480,600 600,750 750,900
Yes, certainly we want this

2537
01:19:23,700 --> 01:19:26,460
0,360 360,690 690,990 1770,2070 2340,2760
exact sequence to come in

2538
01:19:26,460 --> 01:19:29,370
0,360 360,960 1920,2190 2190,2730 2730,2910
and see it it's very

2539
01:19:29,370 --> 01:19:30,180
0,150 150,240 240,480 480,660 660,810
hard to talk about things

2540
01:19:30,180 --> 01:19:31,830
0,180 180,450 450,780 780,930 930,1650
like our a and c.

2541
01:19:32,380 --> 01:19:33,940
0,1050
RSP.

2542
01:19:34,120 --> 01:19:35,470
0,480 540,960 960,1110 1110,1200 1200,1350
Um, certainly there's no way

2543
01:19:35,470 --> 01:19:37,060
0,270 270,360 360,600 600,1230 1230,1590
within the c language to.

2544
01:19:37,660 --> 01:19:39,100
0,270 270,720 720,1050 1050,1140 1140,1440
Talk about changing the stack

2545
01:19:39,100 --> 01:19:40,300
0,570
pointer.

2546
01:19:40,840 --> 01:19:42,660
0,180 180,360 360,570 570,1290
With a {re-register. -}

2547
01:19:42,660 --> 01:19:43,860
0,150 150,600 600,660 660,990 990,1200
So these are things that.

2548
01:19:45,340 --> 01:19:46,840
0,210 210,450 450,900 1170,1290 1290,1500
Just can't be you can't

2549
01:19:46,840 --> 01:19:48,760
0,270 270,480 480,750 990,1410 1410,1920
say it in ordinary see

2550
01:19:49,270 --> 01:19:50,290
0,480 510,630 630,780 780,900 900,1020
I'm the only way you

2551
01:19:50,290 --> 01:19:51,100
0,120 120,270 270,390 390,480 480,810
can see it in c

2552
01:19:51,100 --> 01:19:53,140
0,330 360,750 750,960 960,1530 1560,2040
is there, there is possible

2553
01:19:53,140 --> 01:19:53,890
0,90 90,390 390,510 510,690 690,750
in c to sort of

2554
01:19:53,890 --> 01:19:56,410
0,570 750,1230 1230,2130 2130,2280 2280,2520
embed assembly instructions in c

2555
01:19:56,410 --> 01:19:57,820
0,510 930,1140 1140,1230 1230,1320 1320,1410
code, so we could have

2556
01:19:57,820 --> 01:20:00,070
0,150 150,480 480,960 960,1320 1320,2250
just embedded these assembly instructions

2557
01:20:00,100 --> 01:20:01,060
0,60 60,120 120,330 330,660 660,960
in the c function better.

2558
01:20:01,730 --> 01:20:02,480
0,150 150,360 360,450 450,540 540,750
Would amount to the same

2559
01:20:02,480 --> 01:20:03,360
0,270
thing.

2560
01:20:03,510 --> 01:20:04,980
0,450 450,810 810,930 930,1380 1380,1470
We're basically we're operating at

2561
01:20:04,980 --> 01:20:07,080
0,60 60,480 480,1530
a level below.

2562
01:20:07,140 --> 01:20:08,430
0,360 360,780 780,960 960,1050 1050,1290
Below see so we can't

2563
01:20:08,430 --> 01:20:09,420
0,330
really.

2564
01:20:09,820 --> 01:20:11,080
0,210 210,480 480,630 630,840 840,1260
Can't believe you see here.

2565
01:20:13,950 --> 01:20:15,030
0,150 150,330 330,420 420,750 750,1080
I have a question about

2566
01:20:15,030 --> 01:20:17,280
0,150 150,540 630,1170 1170,1650 1650,2250
when a thread finishes executing

2567
01:20:17,280 --> 01:20:18,570
0,120 120,570 570,810 810,1230 1230,1290
and assuming that happens in

2568
01:20:18,570 --> 01:20:19,590
0,90 90,390 390,720 720,900 900,1020
the user space when we

2569
01:20:19,590 --> 01:20:21,180
0,300 300,450 450,990 990,1290 1290,1590
call the exact day, I'm

2570
01:20:21,180 --> 01:20:22,220
0,450
sorry.

2571
01:20:22,220 --> 01:20:25,640
0,510 510,960 960,1380 2010,2730 2970,3420
Accept system call and um

2572
01:20:25,700 --> 01:20:27,620
0,360 360,870 870,1140 1140,1260 1260,1920
that also ends the process,

2573
01:20:27,980 --> 01:20:29,030
0,150 150,420 420,510 510,900 900,1050
the thread I'm assuming in

2574
01:20:29,030 --> 01:20:30,830
0,90 90,420 420,1080 1170,1530 1530,1800
the kernel space, but if

2575
01:20:30,830 --> 01:20:33,260
0,510 630,1170 1170,2010
the thread ends.

2576
01:20:33,260 --> 01:20:34,940
0,540 570,1110 1110,1200 1200,1380 1380,1680
Within before a new time

2577
01:20:34,940 --> 01:20:37,130
0,450 450,1170 1230,1470 1470,1620 1620,2190
interrupt happens, does it still

2578
01:20:37,130 --> 01:20:39,300
0,120 120,1410
look like.

2579
01:20:39,570 --> 01:20:41,310
0,180 180,990 1020,1200 1200,1290 1290,1740
Is this like the CPU

2580
01:20:41,310 --> 01:20:42,720
0,270 270,750 750,870 870,1140 1140,1410
still acquired by that thread

2581
01:20:42,720 --> 01:20:44,220
0,150 150,750 780,1050 1050,1260 1260,1500
or dewey and that thread

2582
01:20:44,220 --> 01:20:45,060
0,120 120,360 360,420 420,600 600,840
and start a new one

2583
01:20:45,060 --> 01:20:46,380
0,300 300,390 390,540 540,810 810,1320
before the new time interrupt,

2584
01:20:46,560 --> 01:20:48,240
0,300 300,900
oh yeah.

2585
01:20:48,240 --> 01:20:49,400
0,600
I'm.

2586
01:20:49,460 --> 01:20:53,060
0,480 480,1170 1800,2520 2670,3300 3300,3600
The thread a thread yields

2587
01:20:53,060 --> 01:20:54,540
0,120 120,870
the CPU.

2588
01:20:54,820 --> 01:20:56,530
0,120 120,270 270,780 1050,1440 1440,1710
There's the exit exit yields,

2589
01:20:56,530 --> 01:20:57,730
0,90 90,630 660,810 810,990 990,1200
the CPU so there's actually

2590
01:20:57,730 --> 01:20:59,920
0,360 360,960 960,1140 1860,2100 2100,2190
many points that even though

2591
01:20:59,920 --> 01:21:01,060
0,120 120,300 300,630 630,750 750,1140
I've been driving this discussion

2592
01:21:01,060 --> 01:21:02,110
0,90 90,150 150,510 510,900 900,1050
with a timer interrupt, in

2593
01:21:02,110 --> 01:21:03,380
0,720
fact.

2594
01:21:04,300 --> 01:21:06,070
0,150 150,720 750,1110 1110,1320 1320,1770
In almost almost all cases

2595
01:21:06,070 --> 01:21:07,840
0,450 450,690 690,960 960,1500 1500,1770
where xp six switches between

2596
01:21:07,840 --> 01:21:08,740
0,360 360,480 480,690 690,810 810,900
threads, it's not due to

2597
01:21:08,740 --> 01:21:12,430
0,360 360,930 1020,1410 1410,2190 3390,3690
timer interrupts it's because some

2598
01:21:12,430 --> 01:21:13,960
0,300 300,600 600,900 900,1020 1020,1530
system calls waiting for something

2599
01:21:13,960 --> 01:21:16,720
0,210 210,1260 1440,1740 1830,2190 2430,2760
or decides that it needs

2600
01:21:16,720 --> 01:21:17,740
0,90 90,240 240,360 360,450 450,1020
to give up the CPU

2601
01:21:17,770 --> 01:21:19,660
0,180 180,330 330,570 570,1170 1320,1890
and so for example exit

2602
01:21:19,930 --> 01:21:21,430
0,300 300,600 600,1020 1020,1140 1140,1500
does various things and then

2603
01:21:21,430 --> 01:21:23,050
0,240 240,900 1170,1320 1320,1500 1500,1620
calls yield to go, the

2604
01:21:23,050 --> 01:21:24,240
0,540 540,690
CPU and.

2605
01:21:24,240 --> 01:21:25,460
0,150 150,360 360,630
It does that.

2606
01:21:25,490 --> 01:21:26,900
0,270 270,420 420,750 750,1200 1200,1410
There's really nothing does that

2607
01:21:26,900 --> 01:21:28,430
0,630 630,690 690,990 990,1230 1230,1530
independently of whether there's timer

2608
01:21:28,430 --> 01:21:29,420
0,510
interrupt.

2609
01:21:31,730 --> 01:21:32,840
0,570
Yes.

2610
01:21:37,740 --> 01:21:40,110
0,240 240,420 420,810 840,1530 2100,2370
All right, the um time

2611
01:21:40,110 --> 01:21:40,890
0,90 90,210 210,300 300,480 480,780
is up for this lecture

2612
01:21:40,890 --> 01:21:42,180
0,60 60,210 210,510 720,1110 1110,1290
I think I'll continue some

2613
01:21:42,180 --> 01:21:44,190
0,60 60,180 180,960 1350,1830 1830,2010
of this discussion next week

2614
01:21:44,190 --> 01:21:45,330
0,120 120,240 240,570 570,810 840,1140
but I'm happy to take

2615
01:21:45,330 --> 01:21:47,670
0,180 180,1110 1560,1740 1740,2040 2220,2340
more questions right now if

2616
01:21:47,670 --> 01:21:48,820
0,210 210,390 390,540
people have them.

2617
01:21:52,150 --> 01:21:53,770
0,420 420,600 600,720 720,1050 1050,1620
So let's say the operating

2618
01:21:53,770 --> 01:21:55,880
0,390 390,1050 1050,1560
system actually, um.

2619
01:21:56,320 --> 01:21:57,580
0,90 90,510 510,840 840,1020 1020,1260
I takes on a the

2620
01:21:57,580 --> 01:22:00,400
0,450 450,1290 1320,1860 1890,2550 2640,2820
thread implementation so so for

2621
01:22:00,400 --> 01:22:01,750
0,420 420,540 540,690 690,840 840,1350
example you want to run

2622
01:22:01,840 --> 01:22:03,790
0,570 570,960 960,1170 1170,1260 1260,1950
multiple threads of a process

2623
01:22:03,790 --> 01:22:05,710
0,540 690,1140 1140,1620 1620,1770 1770,1920
on multiple {CPU's -} like

2624
01:22:05,710 --> 01:22:06,730
0,150 150,390 390,510 510,630 630,1020
that has to be handled

2625
01:22:06,730 --> 01:22:07,960
0,120 120,330 330,750 750,960 960,1230
by the o's that cannot

2626
01:22:07,960 --> 01:22:09,160
0,270 270,450 450,840 840,930 930,1200
just be handled in user

2627
01:22:09,160 --> 01:22:10,990
0,360 360,780 1200,1440 1440,1620 1620,1830
space right, how does that

2628
01:22:10,990 --> 01:22:12,130
0,180 180,240 240,600 600,960 960,1140
kind of switching work is

2629
01:22:12,130 --> 01:22:14,020
0,420 450,870 870,1200 1200,1440 1440,1890
each, each thread now becomes

2630
01:22:14,020 --> 01:22:15,130
0,90 90,330 330,420 420,510 510,1110
the same as a process

2631
01:22:15,130 --> 01:22:16,120
0,210 210,360 360,750 750,900 900,990
like is always going to

2632
01:22:16,120 --> 01:22:18,280
0,330 330,540 540,870 870,1440 1440,2160
loop through all existing threads

2633
01:22:18,400 --> 01:22:19,780
0,1050
or.

2634
01:22:19,900 --> 01:22:21,010
0,240 240,420 420,600 600,840 840,1110
You know cause like each

2635
01:22:21,010 --> 01:22:22,630
0,480 480,630 630,900 900,1260 1260,1620
CPU will still switch between

2636
01:22:22,630 --> 01:22:23,860
0,270 270,390 390,540 540,1080 1080,1230
even if one processes, give

2637
01:22:23,860 --> 01:22:24,940
0,150 150,360 360,750 750,900 900,1080
me eight cores like it's

2638
01:22:24,940 --> 01:22:26,440
0,180 180,390 390,840 840,1260 1260,1500
still gonna switch switch each

2639
01:22:26,440 --> 01:22:28,330
0,120 120,210 210,660 660,1230 1380,1890
of the CPS between those

2640
01:22:28,330 --> 01:22:29,260
0,180 180,330 330,630 630,690 690,930
and a couple of other

2641
01:22:29,260 --> 01:22:31,360
0,810 1290,1560 1560,1890 1890,2010 2010,2100
processes and also we don't

2642
01:22:31,360 --> 01:22:33,550
0,180 180,330 330,660 660,1410 1560,2190
want to really switch between

2643
01:22:33,550 --> 01:22:34,540
0,210 210,360 360,450 450,630 630,990
one and the other thread

2644
01:22:34,540 --> 01:22:36,340
0,150 150,240 240,570 570,1230 1590,1800
on the same CPU or

2645
01:22:36,340 --> 01:22:38,220
0,540 570,690 690,840 840,1200
dewey I don't know.

2646
01:22:38,640 --> 01:22:41,180
0,600 660,1020 1020,1020
Wait, can a.

2647
01:22:41,300 --> 01:22:42,650
0,750 780,1080 1080,1200 1200,1290 1290,1350
I'm not sure what the

2648
01:22:42,650 --> 01:22:44,600
0,360 360,630 1230,1470 1470,1680 1680,1950
question is yeah I guess

2649
01:22:44,600 --> 01:22:45,410
0,120 120,330 330,510 510,600 600,810
I guess, can you just

2650
01:22:45,410 --> 01:22:47,030
0,540 540,870 870,1170 1170,1440 1440,1620
explain more like how does

2651
01:22:47,030 --> 01:22:49,100
0,240 240,750 1350,1830 1830,1980 1980,2070
that happen sorry, how does

2652
01:22:49,100 --> 01:22:52,010
0,180 180,510 1170,1950 2340,2820 2820,2910
what happened, um, let's say

2653
01:22:52,010 --> 01:22:53,180
0,120 120,300 300,690 690,1020 1020,1170
we have multiple threads per

2654
01:22:53,180 --> 01:22:54,500
0,570 570,810 810,1020 1020,1140 1140,1320
process so that they can

2655
01:22:54,500 --> 01:22:55,430
0,150 150,270 270,390 390,660 660,930
and they can run on

2656
01:22:55,430 --> 01:22:57,170
0,390 390,840 840,1110 1230,1590 1590,1740
different {gpu's -} like how

2657
01:22:57,170 --> 01:22:58,220
0,510 510,630 630,780 780,960 960,1050
do we go, how do

2658
01:22:58,220 --> 01:22:59,990
0,60 60,150 150,420 420,660 1260,1770
you go about their clinics,

2659
01:22:59,990 --> 01:23:02,150
0,120 120,540 540,1320 1320,1710 1740,2160
for example supports a multiple

2660
01:23:02,150 --> 01:23:04,640
0,780 810,990 990,1500 1500,1830 2130,2490
threads per process and in

2661
01:23:04,640 --> 01:23:06,900
0,360 360,480 480,1470
Linux, the implementation.

2662
01:23:06,960 --> 01:23:09,000
0,420 420,870 870,930 930,1380 1380,2040
Yeah it's a complex implementation,

2663
01:23:09,000 --> 01:23:10,380
0,180 180,420 420,750 840,1290 1290,1380
but maybe the simplest way

2664
01:23:10,380 --> 01:23:11,430
0,60 60,450 450,600 600,750 750,1050
to explain it is that

2665
01:23:11,910 --> 01:23:13,880
0,600 840,1470
um each.

2666
01:23:13,880 --> 01:23:14,930
0,270 270,480 480,780 780,900 900,1050
Um, it's almost as if

2667
01:23:14,930 --> 01:23:16,760
0,360 360,810 810,930 930,1620 1650,1830
each thread in Linux is

2668
01:23:16,760 --> 01:23:18,780
0,90 90,480 480,1470
a complete process.

2669
01:23:19,200 --> 01:23:21,480
0,480 660,1200 1500,1680 1680,2190 2190,2280
And the the threads of

2670
01:23:21,480 --> 01:23:22,920
0,120 120,690 900,1170 1170,1320 1320,1440
a given what we would

2671
01:23:22,920 --> 01:23:23,850
0,210 210,300 300,690 690,780 780,930
call the threads of a

2672
01:23:23,850 --> 01:23:26,550
0,420 420,1200 1230,1740 1740,2280 2280,2700
particular process are essentially separate

2673
01:23:26,550 --> 01:23:28,620
0,750 780,1110 1110,1590 1590,1680 1680,2070
processes that share the same

2674
01:23:28,620 --> 01:23:29,760
0,690
memory.

2675
01:23:30,040 --> 01:23:30,880
0,180 180,510 510,600 600,720 720,840
So Linux has sort of

2676
01:23:30,910 --> 01:23:32,740
0,630 630,780 780,870 870,1350 1350,1830
separated out the notion of

2677
01:23:32,920 --> 01:23:34,690
0,510 510,780 780,870 870,1590 1590,1770
a thread of execution from

2678
01:23:34,690 --> 01:23:36,640
0,300 300,840 840,1140 1710,1830 1830,1950
address space and you know

2679
01:23:36,640 --> 01:23:37,820
0,300 630,900
you can.

2680
01:23:38,180 --> 01:23:39,740
0,240 240,390 390,960 960,1170 1380,1560
Have them separately, and if

2681
01:23:39,740 --> 01:23:40,520
0,90 90,270 270,390 390,720 720,780
you make two threads in

2682
01:23:40,520 --> 01:23:41,810
0,150 150,630 630,720 720,1080 1080,1290
one process, it basically makes

2683
01:23:41,810 --> 01:23:43,370
0,150 150,990 1020,1140 1140,1380 1380,1560
two processes that share one

2684
01:23:43,370 --> 01:23:45,110
0,300 300,990 1320,1440 1440,1590 1590,1740
address space, and then from

2685
01:23:45,110 --> 01:23:46,580
0,210 210,600 600,690 690,1200 1200,1470
then on the scheduling is

2686
01:23:46,610 --> 01:23:49,070
0,480 480,1380 1890,2190 2190,2340 2340,2460
not unlike what ex v

2687
01:23:49,070 --> 01:23:51,320
0,270 270,780 810,990 990,1410 1410,2250
six does for individual processes.

2688
01:23:51,740 --> 01:23:53,600
0,450 480,660 660,1260 1380,1680 1680,1860
Icy and then, um, is

2689
01:23:53,600 --> 01:23:55,370
0,240 240,930 930,1260 1290,1680 1680,1770
there anything like does the

2690
01:23:55,370 --> 01:23:57,020
0,270 270,480 480,600 600,1200 1200,1650
user have to specify like

2691
01:23:57,290 --> 01:23:58,730
0,270 270,750 750,1050 1050,1350 1350,1440
okay pin, each thread to

2692
01:23:58,730 --> 01:24:01,790
0,60 60,780 1080,1800 1800,2790 2820,3060
a CPU a or how

2693
01:24:01,790 --> 01:24:02,990
0,210 210,450 450,810 810,1020 1020,1200
does the o's make sure

2694
01:24:02,990 --> 01:24:03,980
0,210 210,540 540,810 810,900 900,990
that different threads of the

2695
01:24:03,980 --> 01:24:05,000
0,210 210,510 510,720 720,930 930,1020
same process, don't run on

2696
01:24:05,000 --> 01:24:05,930
0,60 60,330 330,570 570,780 780,930
the same core because that's

2697
01:24:05,930 --> 01:24:07,400
0,180 180,360 450,900 900,990 990,1470
kind of defeating the purpose

2698
01:24:07,430 --> 01:24:08,360
0,180 180,480 480,630 630,900 900,930
or not I guess I

2699
01:24:08,360 --> 01:24:09,160
0,120 120,330
don't know.

2700
01:24:09,160 --> 01:24:11,050
0,180 180,570 570,810 810,1320 1530,1890
Um the the um, it's

2701
01:24:11,050 --> 01:24:12,400
0,240 240,510 510,960 990,1170 1170,1350
actually just like it's much

2702
01:24:12,400 --> 01:24:14,050
0,150 150,420 420,810 810,1230 1230,1650
like xp six namely the

2703
01:24:14,530 --> 01:24:15,820
0,750
um.

2704
01:24:15,820 --> 01:24:17,200
0,180 180,240 240,510 510,750 750,1380
You know there's four cores

2705
01:24:17,200 --> 01:24:18,640
0,330
and.

2706
01:24:18,670 --> 01:24:19,840
0,450 450,540 540,690 690,960 960,1170
Linux will just find four

2707
01:24:19,840 --> 01:24:20,650
0,330 330,420 420,540 540,600 600,810
things for one of those

2708
01:24:20,650 --> 01:24:23,410
0,210 210,960 1350,1680 1680,2190 2670,2760
four cores, they maybe, um,

2709
01:24:23,410 --> 01:24:25,270
0,750 750,930 930,1290 1500,1710 1710,1860
you know if there's not

2710
01:24:25,270 --> 01:24:26,140
0,150 150,360 360,540 540,660 660,870
much going on then maybe

2711
01:24:26,140 --> 01:24:27,340
0,120 120,300 300,540 540,1080 1080,1200
they'll be four threads of

2712
01:24:27,340 --> 01:24:29,220
0,90 90,480 480,1440
the same process.

2713
01:24:29,370 --> 01:24:30,660
0,300 300,420 420,810 840,1020 1020,1290
Or if there's a hundred

2714
01:24:30,660 --> 01:24:31,920
0,300 300,600 600,720 720,870 870,1260
users logged in on athena

2715
01:24:31,920 --> 01:24:34,530
0,510 510,720 720,1170 1290,2070 2070,2610
machine, maybe it's one thread

2716
01:24:34,530 --> 01:24:36,930
0,390 390,840 840,1260 1260,1530 1530,2400
each from multiple different processes,

2717
01:24:36,930 --> 01:24:37,780
0,60 60,300
you know.

2718
01:24:39,060 --> 01:24:40,650
0,360 360,570 570,690 690,870 870,1590
There's not any one answer

2719
01:24:40,710 --> 01:24:42,750
0,540 810,1200 1200,1440 1440,1740 1740,2040
or the kernel, basically find

2720
01:24:42,750 --> 01:24:43,620
0,300 300,420 420,540 540,750 750,870
something for each core to

2721
01:24:43,620 --> 01:24:44,760
0,270 270,390 390,750 780,960 960,1140
do and then that court

2722
01:24:44,760 --> 01:24:46,920
0,180 180,390 390,570 1740,2040 2040,2160
does that thing okay that

2723
01:24:46,920 --> 01:24:48,120
0,210 210,660
makes sense.

2724
01:24:48,520 --> 01:24:49,810
0,240 240,780 900,1050 1050,1140 1140,1290
You can you know if

2725
01:24:49,810 --> 01:24:51,340
0,330 960,1200 1200,1320 1320,1470 1470,1530
you're if you want to

2726
01:24:51,340 --> 01:24:52,360
0,90 90,360 360,780 780,930 930,1020
do careful measurements, there is

2727
01:24:52,360 --> 01:24:53,380
0,60 60,180 180,300 300,660 660,1020
a way to pin threads

2728
01:24:53,380 --> 01:24:55,030
0,90 90,600 600,840 1170,1410 1410,1650
to cores, but people only

2729
01:24:55,030 --> 01:24:56,320
0,180 180,330 330,480 480,750 1080,1290
do it when they're up

2730
01:24:56,320 --> 01:24:57,940
0,90 90,390 390,1170
to something strange.

2731
01:25:00,540 --> 01:25:02,250
0,360 360,540 540,900 900,1050 1080,1710
So you share the virtual

2732
01:25:02,250 --> 01:25:03,480
0,660
table.

2733
01:25:03,930 --> 01:25:05,670
0,300 300,450 450,720 720,1350 1560,1740
Just a great memory, so

2734
01:25:05,670 --> 01:25:06,840
0,150 150,390 390,810 810,1110 1110,1170
they say they have the

2735
01:25:06,840 --> 01:25:10,020
0,540 600,930 930,1560 1800,2460 2460,3180
same page table, those friends,

2736
01:25:10,140 --> 01:25:13,200
0,1380 1380,2430 2430,2670 2670,2910 2910,3060
yeah yeah, if you're on

2737
01:25:13,200 --> 01:25:14,340
0,360 360,450 450,570 570,960 960,1140
Linux, if you create two

2738
01:25:14,340 --> 01:25:15,690
0,390 390,450 450,630 630,1170 1170,1350
threads in one process, then

2739
01:25:15,690 --> 01:25:16,680
0,90 90,180 180,360 360,510 510,990
you have these two threads.

2740
01:25:19,080 --> 01:25:19,620
0,90 90,210 210,270 270,360 360,540
I don't know if they

2741
01:25:19,620 --> 01:25:22,620
0,180 210,930 930,1890 1950,2100 2100,3000
like literally share the exact

2742
01:25:22,650 --> 01:25:24,210
0,390 390,750 750,1110 1110,1260 1260,1560
same page table or whether

2743
01:25:24,210 --> 01:25:26,100
0,180 180,420 420,990 1020,1230 1230,1890
their page tables are identical

2744
01:25:26,520 --> 01:25:27,920
0,390 390,450 450,570 570,810
one or the other.

2745
01:25:28,620 --> 01:25:29,700
0,240 240,420 420,510 510,840 840,1080
Is there a reason why

2746
01:25:29,700 --> 01:25:30,510
0,150 150,330 330,570 570,660 660,810
they would have to be

2747
01:25:30,510 --> 01:25:33,240
0,540 780,1350 1710,2190 2400,2580 2580,2730
separate ever, um, if you

2748
01:25:33,240 --> 01:25:35,280
0,510 510,810 810,1170 1170,1500
manually math memory, or.

2749
01:25:36,540 --> 01:25:37,680
0,300 300,450 450,720 720,900 900,1140
I I don't know enough

2750
01:25:37,680 --> 01:25:40,200
0,120 120,300 300,990 1020,1770 1920,2520
to know whether I'm which

2751
01:25:40,200 --> 01:25:42,100
0,360 360,690 690,1440
which Linux does.

2752
01:25:44,320 --> 01:25:45,580
0,300 300,450 450,570 570,810 810,1260
Okay I have another question

2753
01:25:45,580 --> 01:25:47,860
0,480 480,570 570,900 900,1500 1530,2280
about a small detail, um,

2754
01:25:48,130 --> 01:25:50,050
0,690 720,1320 1320,1620 1620,1770 1770,1920
so basically like from my

2755
01:25:50,050 --> 01:25:52,030
0,630 630,810 810,930 930,1140 1140,1980
understanding when you call switch,

2756
01:25:52,450 --> 01:25:54,250
0,420 420,780 780,1200 1200,1440 1440,1800
um, you switch from one

2757
01:25:54,250 --> 01:25:56,050
0,390 390,840 840,1230 1230,1380 1380,1800
call to switch to another,

2758
01:25:56,080 --> 01:25:56,980
0,240 240,390 390,630 630,810 810,900
so the first time you

2759
01:25:56,980 --> 01:25:58,150
0,180 180,660 690,870 870,1080 1080,1170
call switch, you have to

2760
01:25:58,150 --> 01:26:00,880
0,210 210,780 960,1710 1710,2370 2370,2730
like karna artificially create a

2761
01:26:01,000 --> 01:26:02,680
0,300 300,840 840,1080 1110,1380 1380,1680
other endpoint to come back

2762
01:26:02,680 --> 01:26:04,420
0,150 150,630 750,1380
to right, yes.

2763
01:26:04,510 --> 01:26:05,650
0,180 180,240 240,450 450,660 660,1140
Because you can't just randomly

2764
01:26:05,650 --> 01:26:06,520
0,240 240,360 360,480 480,690 690,870
jump in to write any

2765
01:26:06,520 --> 01:26:08,640
0,510 780,1560
code yes.

2766
01:26:09,750 --> 01:26:10,590
0,270 270,390 390,450 450,540 540,840
You want to know where

2767
01:26:10,590 --> 01:26:11,640
0,390
that.

2768
01:26:11,860 --> 01:26:13,920
0,330 330,570 570,1500
We're that fake.

2769
01:26:14,930 --> 01:26:16,370
0,240 240,420 420,960 960,1080 1080,1440
Where that context was cooked

2770
01:26:16,370 --> 01:26:18,680
0,420 1380,1650 1650,1980 1980,2190 2190,2310
up probably somewhere where the

2771
01:26:18,680 --> 01:26:21,320
0,810 1350,2010 2010,2160 2160,2610 2610,2640
processes created I guess I

2772
01:26:21,320 --> 01:26:23,300
0,240 240,840 840,1260 1260,1620 1620,1980
know yeah yeah, maybe user

2773
01:26:23,300 --> 01:26:24,640
0,120 120,870
in that.

2774
01:26:24,820 --> 01:26:26,980
0,480 1020,1290 1290,1560 1560,1800 1800,2160
Or not using a wok

2775
01:26:26,980 --> 01:26:28,280
0,780
proc.

2776
01:26:31,030 --> 01:26:34,060
0,810 840,1530 1890,2310 2310,2700 2700,3030
Don't know, forget something called

2777
01:26:34,060 --> 01:26:36,580
0,840 870,1620 1620,2190 2190,2430 2430,2520
fork trappers, yeah look at

2778
01:26:36,580 --> 01:26:38,830
0,330 360,1020 1020,1560 1740,2040 2040,2250
this yeah we got four

2779
01:26:38,830 --> 01:26:40,180
0,420 420,630 630,780 780,870 870,1350
credit okay so an Alex

2780
01:26:40,180 --> 01:26:41,920
0,450 450,600 600,690 690,1050 1050,1740
proc which is called both

2781
01:26:42,130 --> 01:26:43,600
0,270 270,360 360,780 780,1080 1080,1470
for the very first process

2782
01:26:43,600 --> 01:26:45,100
0,90 90,600 600,990 990,1350 1350,1500
at boot time and by

2783
01:26:45,100 --> 01:26:48,160
0,690 900,1440 1680,2310 2310,2610 2610,3060
fork, I'm Alex rocks sets

2784
01:26:48,160 --> 01:26:49,690
0,330 330,450 450,960 960,1470 1470,1530
up the critical elements of

2785
01:26:49,690 --> 01:26:51,400
0,90 90,930 990,1290 1290,1410 1410,1710
the context for the new

2786
01:26:51,400 --> 01:26:53,040
0,1320
processes.

2787
01:26:53,770 --> 01:26:55,090
0,210 210,360 810,1020 1020,1230 1230,1320
Um, it, it sets up

2788
01:26:55,090 --> 01:26:56,530
0,60 60,150 150,630 630,1230 1290,1440
the new processes context, it

2789
01:26:56,530 --> 01:26:57,400
0,180 180,360 360,540 540,690 690,870
actually doesn't matter what most

2790
01:26:57,400 --> 01:26:59,230
0,60 60,150 150,630 630,960 1410,1830
of the registers are a

2791
01:26:59,260 --> 01:26:59,950
0,150 150,210 210,390 390,540 540,690
but it doesn't matter what

2792
01:26:59,950 --> 01:27:01,240
0,270 270,450 450,870 870,1140 1140,1290
our a is because that's

2793
01:27:01,240 --> 01:27:02,800
0,240 330,450 450,960 960,1110 1110,1560
where the switch the very

2794
01:27:02,800 --> 01:27:04,180
0,360 360,750 750,840 840,960 960,1380
first switch and that process

2795
01:27:04,180 --> 01:27:04,930
0,180 180,330 330,420 420,690 690,750
is going to return to

2796
01:27:04,930 --> 01:27:07,240
0,150 150,780
a re-.

2797
01:27:07,450 --> 01:27:08,650
0,270 270,450 450,870 870,1050 1050,1200
And that process is going

2798
01:27:08,650 --> 01:27:09,370
0,90 90,330 330,420 420,600 600,720
to need to use its

2799
01:27:09,370 --> 01:27:11,080
0,150 150,750 780,960 960,1560 1560,1710
own stack so rns be

2800
01:27:11,080 --> 01:27:12,420
0,90 90,780
a setup.

2801
01:27:12,510 --> 01:27:15,060
0,120 120,840 900,1590 1860,2340 2340,2550
A faked essentially so the

2802
01:27:15,060 --> 01:27:16,800
0,300 300,660 660,1200 1200,1320 1320,1740
very first switched or process

2803
01:27:16,800 --> 01:27:17,980
0,630
works.

2804
01:27:18,130 --> 01:27:19,720
0,450 450,780 780,960 960,1080 1080,1590
So, so if I understand

2805
01:27:19,720 --> 01:27:21,040
0,120 120,690 690,900 900,1020 1020,1320
this correctly when this switch

2806
01:27:21,040 --> 01:27:23,320
0,180 180,630 630,1110 1410,1740 1740,2280
will happen then it'll basically

2807
01:27:23,320 --> 01:27:25,390
0,450 480,870 870,1380 1380,1560 1560,2070
just start executing the first

2808
01:27:25,390 --> 01:27:27,070
0,540 540,870 870,990 990,1200 1200,1680
instruction inside of the fork

2809
01:27:27,070 --> 01:27:28,690
0,420 480,780 780,990 990,1200 1200,1620
red as if for credit

2810
01:27:28,690 --> 01:27:30,190
0,330 330,690 690,1020 1020,1110 1110,1500
just called switch and return

2811
01:27:30,190 --> 01:27:33,130
0,270 720,1530 1530,2190 2190,2310 2310,2940
from yeah yeah, the return

2812
01:27:33,130 --> 01:27:34,600
0,180 180,720 720,1080 1140,1350 1350,1470
from switch is gonna be

2813
01:27:34,600 --> 01:27:35,680
0,120 120,540 540,660 660,750 750,1080
a jump to the beginning

2814
01:27:35,680 --> 01:27:36,880
0,90 90,330 330,690
of for credit.

2815
01:27:37,330 --> 01:27:38,560
0,630
Right.

2816
01:27:39,020 --> 01:27:40,340
0,780
Interesting.

2817
01:27:40,370 --> 01:27:41,870
0,180 180,300 300,600 600,1260 1260,1500
Do we ever call for

2818
01:27:41,870 --> 01:27:43,490
0,480 720,960 960,1110 1110,1260 1260,1620
cred or is it always

2819
01:27:43,490 --> 01:27:44,780
0,390 570,600 690,930 930,1050 1050,1290
happens I think it always

2820
01:27:44,780 --> 01:27:46,220
0,360 360,540 540,870 1080,1170 1170,1440
happens like this I don't

2821
01:27:46,220 --> 01:27:47,810
0,210 210,630 630,900 900,1350 1350,1590
think anything ever calls for

2822
01:27:47,810 --> 01:27:49,820
0,270 270,450 450,900 1050,1530
courage for real it's.

2823
01:27:50,160 --> 01:27:52,800
0,1440 1500,1800 1800,1920 1920,2130 2130,2640
Just yeah it's only executed

2824
01:27:52,800 --> 01:27:54,180
0,60 60,240 240,510 510,840 840,1380
in this weird way from.

2825
01:27:55,950 --> 01:27:57,300
0,240 240,420 420,810 810,930 930,1350
First timer process is run.

2826
01:27:58,510 --> 01:27:59,800
0,240 240,330 330,600 600,810 810,1290
It is really its job

2827
01:27:59,800 --> 01:28:01,960
0,210 210,540 900,1320 1320,1470 1470,2160
is to release the lock,

2828
01:28:02,860 --> 01:28:04,870
0,360 360,840 840,1320 1470,1770 1770,2010
the scheduler took and then

2829
01:28:04,870 --> 01:28:06,520
0,630 660,780 780,1050 1080,1320 1320,1650
return and then this user

2830
01:28:06,520 --> 01:28:07,600
0,390 390,570 570,630 630,960 960,1080
trap red, of course, is

2831
01:28:07,600 --> 01:28:09,440
0,390 390,1290
also fake.

2832
01:28:09,500 --> 01:28:11,000
0,300 300,780
That it's.

2833
01:28:11,340 --> 01:28:13,020
0,270 270,780 780,900 900,1290 1380,1680
It's yeah it's like it's

2834
01:28:13,020 --> 01:28:14,190
0,300 300,540 540,960 960,1110 1110,1170
as if returning from a

2835
01:28:14,190 --> 01:28:15,780
0,420 420,840 840,900 900,1290 1290,1590
trap except the trap frame

2836
01:28:15,780 --> 01:28:18,390
0,390 420,1020 1020,1560 1980,2250 2400,2610
is faked also to to

2837
01:28:18,390 --> 01:28:19,740
0,270 300,870 870,1140 1140,1230 1230,1350
have like jump to the

2838
01:28:19,740 --> 01:28:21,660
0,330 330,930 930,1110 1110,1230
first instruction in the.

2839
01:28:21,660 --> 01:28:24,000
0,630 750,1230 1320,1830
User write code.

2840
01:28:24,760 --> 01:28:26,080
0,300 300,450 450,570 570,900 900,1320
Oh, but the trap frame,

2841
01:28:26,110 --> 01:28:27,430
0,390 390,690 690,780 780,1110 1110,1320
it's again the same like

2842
01:28:27,430 --> 01:28:28,360
0,90 90,180 180,330 330,450 450,930
you don't need to initialize

2843
01:28:28,360 --> 01:28:29,710
0,180 180,750 750,960 960,1140 1140,1350
any registers because it's like

2844
01:28:29,710 --> 01:28:31,180
0,360 390,720 720,1050 1050,1170 1170,1470
well we're going to the

2845
01:28:31,210 --> 01:28:33,100
0,720 720,990 1020,1440 1440,1710 1710,1890
beginning so you don't need

2846
01:28:33,100 --> 01:28:34,690
0,60 60,420 420,870 1230,1500 1500,1590
to assume anything, yeah the

2847
01:28:34,690 --> 01:28:36,220
0,450 450,870 870,990 990,1260 1260,1530
program counter I think is

2848
01:28:36,220 --> 01:28:37,340
0,480
a.

2849
01:28:37,400 --> 01:28:38,570
0,270 270,480 720,1050 1050,1110 1110,1170
Yeah, he needs to be

2850
01:28:38,570 --> 01:28:40,550
0,450 450,540 540,1350 1770,1830 1830,1980
initialized to zero I don't

2851
01:28:40,550 --> 01:28:42,020
0,120 120,330 330,960
know what else.

2852
01:28:42,320 --> 01:28:43,700
0,150 150,360 360,660 660,960 960,1380
You made me maybe it.

2853
01:28:46,440 --> 01:28:47,760
0,210 210,480 480,630 630,870 900,1320
They probably if we call

2854
01:28:47,760 --> 01:28:49,200
0,210 210,420 420,750 750,1110 1230,1440
them it doesn't right because

2855
01:28:49,200 --> 01:28:50,100
0,180 180,270 270,480 480,630 630,900
if we already do the

2856
01:28:50,250 --> 01:28:51,360
0,480 480,660 660,930 930,1050 1050,1110
call then that's going to

2857
01:28:51,360 --> 01:28:53,160
0,300 300,390 390,780 780,1230 1410,1800
set the program counter, yeah,

2858
01:28:53,160 --> 01:28:54,840
0,180 180,570 570,1080 1080,1320 1320,1680
so here's this only happens

2859
01:28:54,840 --> 01:28:57,390
0,330 330,900 900,1650 1650,1950 1950,2550
okaz fork copies four copies,

2860
01:28:57,390 --> 01:28:58,840
0,90 90,420 420,900
the program counter.

2861
01:28:58,840 --> 01:29:00,790
0,150 150,450 450,780 780,1320 1740,1950
The user program counter and

2862
01:29:00,790 --> 01:29:01,720
0,120 120,270 270,480 480,810 810,930
so the only time when

2863
01:29:01,720 --> 01:29:02,470
0,90 90,210 210,360 360,450 450,750
we're not doing it for

2864
01:29:02,470 --> 01:29:03,280
0,120 120,240 240,330 330,570 570,810
is for the very first

2865
01:29:03,280 --> 01:29:05,350
0,390 390,810 960,1410 1410,1560 1560,2070
process where it's like explicitly

2866
01:29:05,350 --> 01:29:07,060
0,480 480,1140
deceptive oh.

2867
01:29:07,310 --> 01:29:08,480
0,150 150,420 420,720 720,870 870,1170
And stack pointer, oh yeah

2868
01:29:08,510 --> 01:29:09,290
0,240 240,390 390,480 480,570 570,780
also needs to be set

2869
01:29:09,290 --> 01:29:10,040
0,270
up.

2870
01:29:11,130 --> 01:29:12,540
0,420 420,660 660,870 870,1110 1110,1410
Oh yeah, cause it's that

2871
01:29:12,540 --> 01:29:14,370
0,630 630,900 900,1110 1110,1560 1560,1830
CPC that's not PC, that's

2872
01:29:14,370 --> 01:29:15,240
0,90 90,300 300,480 480,690 690,870
the one that's gonna get

2873
01:29:15,240 --> 01:29:17,370
0,480 480,600 600,840 840,1410 1410,2130
swapped by the trap trampoline

2874
01:29:17,610 --> 01:29:18,800
0,720
yes.

2875
01:29:19,660 --> 01:29:21,160
0,420 420,540 540,960
Oh I see.

2876
01:29:21,820 --> 01:29:22,870
0,240 240,360 360,630 630,930 930,1050
Because the real piece is

2877
01:29:22,870 --> 01:29:24,250
0,300 300,510 510,690 690,900 900,1380
actually gonna be in trap

2878
01:29:24,280 --> 01:29:26,470
0,270 270,630 630,1260 1740,2010 2010,2190
like inside traveling, but then

2879
01:29:26,470 --> 01:29:27,370
0,120 120,300 300,600 600,780 780,900
we're gonna switch it to

2880
01:29:27,370 --> 01:29:28,720
0,330 330,450 450,810
jump to there.

2881
01:29:29,220 --> 01:29:31,220
0,1260
Yeah.

2882
01:29:32,870 --> 01:29:33,950
0,330 330,510 510,570 570,780 780,1080
Um, can I just ask

2883
01:29:33,950 --> 01:29:34,940
0,330 330,480 480,570 570,690 690,990
like can you go back

2884
01:29:34,940 --> 01:29:37,140
0,120 120,630 690,1080 1080,1650
to the UK proc.

2885
01:29:42,940 --> 01:29:45,370
0,780 1020,1380 1380,1590 1590,1920 1920,2430
A I think there's a.

2886
01:29:45,960 --> 01:29:47,310
0,180 180,390 390,870 900,1110 1110,1350
Oh no sorry a four

2887
01:29:47,310 --> 01:29:49,590
0,420 690,1080 1080,1230 1230,1860 1950,2280
credit oz is something there,

2888
01:29:49,590 --> 01:29:50,730
0,150 150,630 630,750 750,1020 1020,1140
that happens I think for

2889
01:29:50,730 --> 01:29:53,960
0,120 120,750 1020,1710 1710,2190
the first process only.

2890
01:29:53,960 --> 01:29:55,700
0,330 330,660 660,1200 1260,1590 1590,1740
Um, what's this for a

2891
01:29:55,700 --> 01:29:57,890
0,690 690,1230 1560,1710 1710,1980 1980,2190
first call I wasn't really

2892
01:29:57,890 --> 01:29:59,390
0,180 180,390 390,1080 1200,1380 1380,1500
sure what happened, let's see

2893
01:29:59,390 --> 01:30:01,940
0,90 90,420 420,1050 2160,2310 2310,2550
the file system, the file

2894
01:30:01,940 --> 01:30:03,620
0,450 450,840 840,900 900,990 990,1680
system needs to be initialized

2895
01:30:03,620 --> 01:30:05,180
0,180 180,330 330,930 930,1110 1110,1560
and in particular some stuff

2896
01:30:05,180 --> 01:30:06,230
0,240 240,330 330,480 480,780 780,1050
needs to be read off

2897
01:30:06,230 --> 01:30:07,610
0,120 120,840 960,1110 1110,1320 1320,1380
the disk in order to

2898
01:30:07,610 --> 01:30:08,960
0,120 120,240 240,480 480,840 840,1350
get the file system going.

2899
01:30:09,520 --> 01:30:12,010
0,600 990,1770 1950,2220 2220,2370 2370,2490
I'm like there's this thing

2900
01:30:12,010 --> 01:30:13,180
0,150 150,210 210,570 570,930 930,1170
called the super block which

2901
01:30:13,180 --> 01:30:14,620
0,660 660,930 930,1080 1080,1200 1200,1440
describes how big the file

2902
01:30:14,620 --> 01:30:15,910
0,360 360,660 660,990 990,1200 1200,1290
system are isn't where the

2903
01:30:15,910 --> 01:30:16,870
0,360 360,660 660,780 780,870 870,960
various things are in the

2904
01:30:16,870 --> 01:30:18,190
0,240 240,690 750,870 870,1020 1020,1320
file system and there's also

2905
01:30:18,190 --> 01:30:20,050
0,270 390,900 900,1290 1290,1710 1710,1860
a crash recovery log that

2906
01:30:20,050 --> 01:30:21,320
0,240 240,360 360,750
needs to be.

2907
01:30:21,320 --> 01:30:24,560
0,810 930,1110 1110,1350 1350,1590 2760,3240
Replayed in order to recover

2908
01:30:24,560 --> 01:30:26,090
0,150 150,570 570,960 960,1440 1440,1530
from a previous crash, if

2909
01:30:26,090 --> 01:30:29,210
0,90 90,300 300,510 1680,2490 2970,3120
there was one but in

2910
01:30:29,210 --> 01:30:30,380
0,270 270,600 630,870 870,1110 1110,1170
order to do anything in

2911
01:30:30,380 --> 01:30:31,310
0,60 60,330 330,660 660,780 780,930
the file system, you need

2912
01:30:31,310 --> 01:30:32,300
0,60 60,150 150,300 300,450 450,990
to be able to wait

2913
01:30:32,330 --> 01:30:35,060
0,750 780,1410 1440,2040 2040,2160 2160,2730
for disk operations to complete,

2914
01:30:35,060 --> 01:30:35,990
0,240 240,330 330,570 570,780 780,930
but the way ex v

2915
01:30:35,990 --> 01:30:37,760
0,210 210,780 1020,1350 1350,1620 1620,1770
six works, you really can

2916
01:30:37,760 --> 01:30:39,170
0,450 450,780 780,870 870,1110 1110,1410
only execute the file system

2917
01:30:39,170 --> 01:30:40,400
0,330 360,510 510,570 570,1140 1140,1230
code in the context of

2918
01:30:40,400 --> 01:30:41,740
0,90 90,1020
a process.

2919
01:30:42,110 --> 01:30:43,970
0,720 930,1110 1110,1350 1350,1590 1620,1860
Um, in order to like

2920
01:30:43,970 --> 01:30:45,770
0,180 180,330 330,960 1350,1650 1650,1800
wait for io and so

2921
01:30:45,770 --> 01:30:47,750
0,480 480,810 1020,1830 1830,1890 1890,1980
therefore the initialization of the

2922
01:30:47,750 --> 01:30:48,650
0,240 240,540 540,690 690,780 780,900
file system has to be

2923
01:30:48,650 --> 01:30:50,450
0,690 690,1170 1170,1320 1320,1650 1650,1800
deferred until the first time

2924
01:30:50,450 --> 01:30:51,650
0,120 120,240 240,300 300,750 750,1200
we have a process running.

2925
01:30:53,140 --> 01:30:55,060
0,420 930,1140 1140,1590 1590,1710 1710,1920
And that occurs in the

2926
01:30:55,060 --> 01:30:56,530
0,300 300,570 570,1050 1050,1200 1200,1470
very first process in fourth

2927
01:30:56,530 --> 01:30:57,740
0,270
grade.

2928
01:31:00,350 --> 01:31:01,640
0,270 270,720
I see.

2929
01:31:01,640 --> 01:31:02,600
0,180 180,240 240,570 570,750 750,960
And I'm guessing we'll learn

2930
01:31:02,600 --> 01:31:05,140
0,150 150,420 420,840 1320,1950
more about this later.

2931
01:31:05,320 --> 01:31:06,970
0,600 720,990 990,1170 1170,1290 1290,1650
Yeah, not about this horrible

2932
01:31:06,970 --> 01:31:09,100
0,480 480,1260 1260,1530 1530,1770 1770,2130
mess about how file systems

2933
01:31:09,100 --> 01:31:12,880
0,1290 1950,2460 2850,3330 3360,3540 3540,3780
work right okay well, thank

2934
01:31:12,880 --> 01:31:13,870
0,150 150,330 330,540 540,660 660,990
you, I'm sorry for holding

2935
01:31:13,870 --> 01:31:16,180
0,570 600,780 780,1230
on so long.

2936
01:31:16,920 --> 01:31:18,900
0,660 660,1080 1080,1260 1260,1410 1410,1980
Thanks for all the answers.

2937
01:31:21,840 --> 01:31:23,370
0,420 420,540 540,870 870,1320 1320,1530
Sorry it's not even that

2938
01:31:23,370 --> 01:31:25,530
0,540 540,870 870,1350 1350,1890 1950,2160
process, when this thing is

2939
01:31:25,530 --> 01:31:26,503
0,870
executed.
