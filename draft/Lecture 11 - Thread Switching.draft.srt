1
00:00:00,030 --> 00:00:02,160
0,330 330,540 540,900
Anyone hear me?|
有人听到我说话吗？|

2
00:00:02,860 --> 00:00:05,170
0,570 990,1230 1230,1470 1500,1890 1920,2310
{I,can,hear,you}.| Thank you, alright {}.|
我能听见你说话。|谢谢你，好的。|

3
00:00:06,500 --> 00:00:07,820
0,360 360,480 480,570 570,960 960,1320
I'd like to spend today's
我想用今天的讲座来讨论一下线程

4
00:00:07,820 --> 00:00:10,760
0,720 960,1290 1290,1590 2100,2700 2700,2940
lecture talking about threads| and
|以及xv6如何进行线程切换，

5
00:00:10,760 --> 00:00:11,900
0,240 240,480 480,600 600,900 900,1140
how {xv6 - -} does

6
00:00:11,900 --> 00:00:14,030
0,270 270,780 1080,1560 1560,1740 1740,2130
thread switching,| this is a
|这是一种关于[xv6]的幕后讲座，

7
00:00:14,060 --> 00:00:15,140
0,210 210,390 420,630 630,780 780,1080
sort of one of the

8
00:00:15,170 --> 00:00:17,030
0,240 240,330 330,930 1020,1440 1530,1860
under the hood {} lectures

9
00:00:17,030 --> 00:00:18,260
0,90 90,390 390,510 510,840 840,1230
{about -} {[xv6] -},| we've
|我们以前讲过关于系统调用中断、页表和锁是如何工作的

10
00:00:18,920 --> 00:00:20,060
0,240 240,540 540,840 840,1050 1050,1140
had lectures before about how

11
00:00:20,060 --> 00:00:21,830
0,60 60,390 390,780 780,1500 1500,1770
the system calls interrupts, page

12
00:00:21,830 --> 00:00:23,990
0,360 360,450 450,840 840,1290 1680,2160
tables and locks work| and
|今天我们将讨论xv6是如何在不同进程之间切换的。

13
00:00:24,110 --> 00:00:25,220
0,570 570,660 660,780 780,840 840,1110
today we're going to talk

14
00:00:25,220 --> 00:00:27,380
0,660 1440,1680 1680,1860 1860,1950 1950,2160
about how does the {xv6

15
00:00:27,380 --> 00:00:29,480
0,270 270,720 720,990 990,1320 1320,2100
-} switches among different processes

16
00:00:29,510 --> 00:00:30,160
0,300
now.|
|

17
00:00:30,590 --> 00:00:31,920
0,600

18
00:00:32,040 --> 00:00:33,000
0,210 210,600 600,720 720,870 870,960
The reason for this the
这是最高层次的原因，

19
00:00:33,000 --> 00:00:34,110
0,330 330,540 540,780 780,870 870,1110
highest level reason for this,|
|

20
00:00:34,110 --> 00:00:35,130
0,120 120,300 300,660 660,870 870,1020
is that people like their
是因为人们喜欢他们的电脑

21
00:00:35,130 --> 00:00:36,180
0,570 570,690 690,780 780,960 960,1050
computer| to be able to
|为了能够同时完成多项任务，

22
00:00:36,180 --> 00:00:37,560
0,150 150,360 360,450 450,660 660,1380
do more than one task

23
00:00:37,590 --> 00:00:39,840
0,600 600,690 690,930 930,1500 1950,2250
at the same time,| so
|所以原因可能是你支持分时，

24
00:00:39,840 --> 00:00:40,860
0,90 90,480 480,720 720,840 840,1020
the reason might be that

25
00:00:40,860 --> 00:00:42,600
0,150 150,540 540,870 870,1470 1470,1740
you're supporting time sharing,| like
|与雅典娜一样，允许多个用户同时登录

26
00:00:42,870 --> 00:00:44,490
0,120 120,420 420,870 870,1200 1200,1620
{Athena -} allows many users

27
00:00:44,490 --> 00:00:45,240
0,90 90,420 420,480 480,540 540,750
to login at the same

28
00:00:45,240 --> 00:00:46,110
0,300 300,390 390,540 540,720 720,870
time| and they know they
|他们知道他们都可以运行进程

29
00:00:46,110 --> 00:00:48,030
0,120 120,270 270,450 450,1200 1500,1920
can all run processes| or
|甚至是一台单用户机器，甚至是你的iPhone，

30
00:00:48,030 --> 00:00:49,530
0,210 210,330 330,600 600,840 840,1500
even a single user machine

31
00:00:49,560 --> 00:00:51,040
0,150 150,300 300,420 420,1110
or even your iPhone,|
|

32
00:00:51,040 --> 00:00:52,510
0,630 660,810 810,960 960,1200 1200,1470
{} you may run many
您可以运行许多不同的进程

33
00:00:52,510 --> 00:00:54,370
0,330 330,930 930,1110 1200,1770 1770,1860
different processes| and expect the
|并期望计算机能做你要求它做的所有事情，

34
00:00:54,370 --> 00:00:55,810
0,420 420,750 870,1170 1170,1350 1350,1440
computer to do all the

35
00:00:55,810 --> 00:00:56,680
0,240 240,360 360,630 630,720 720,870
things you ask of it,|
|

36
00:00:56,680 --> 00:00:57,980
0,210 210,360 360,570 570,810
not just one thing.|
不只是一件事。|

37
00:00:58,360 --> 00:00:59,680
0,390

38
00:01:00,260 --> 00:01:02,450
0,480 480,1050 1050,1170 1170,1680 1860,2190
Another reason that people like
人们喜欢支持多个任务的另一个原因是

39
00:01:02,450 --> 00:01:03,860
0,90 90,420 420,780 780,1230 1230,1410
to support multiple tasks is|
|

40
00:01:03,860 --> 00:01:05,630
0,480 540,780 780,1020 1020,1260 1260,1770
because it can ease program
因为它可以简化程序结构，

41
00:01:05,630 --> 00:01:08,090
0,720 840,1470 1470,1560 1560,2100 2100,2460
structure,| threads in particular today's
|特别是今天的话题，

42
00:01:08,090 --> 00:01:10,520
0,600 720,1380 1380,1620 1620,2160 2160,2430
topic,| {} are sometimes used
|有时被用来作为一种方式

43
00:01:10,520 --> 00:01:11,510
0,120 120,210 210,540 540,690 690,990
as a way| to help
|为了帮助人们，帮助程序员以一种简单优雅的方式把程序组合在一起，

44
00:01:11,510 --> 00:01:14,030
0,420 420,510 510,720 720,1830 1920,2520
people, to help programmers put

45
00:01:14,030 --> 00:01:15,320
0,300 300,390 390,900 900,1110 1110,1290
together a program in a

46
00:01:15,320 --> 00:01:16,970
0,210 210,300 300,870 870,1290 1290,1650
sort of simple elegant way,|
|

47
00:01:17,000 --> 00:01:18,650
0,120 120,420 420,1140 1290,1560 1560,1650
to reduce complexity,| and you
为了降低复杂性，|你实际上在第一个实验中看到了一个素数筛子的例子，

48
00:01:18,650 --> 00:01:19,670
0,210 210,390 390,480 480,960 960,1020
actually saw an example of

49
00:01:19,670 --> 00:01:20,780
0,240 240,330 330,420 420,720 720,1110
this in the first lab

50
00:01:20,780 --> 00:01:22,010
0,120 120,210 210,510 510,810 810,1230
with the prime number sieve,|
|

51
00:01:22,010 --> 00:01:24,350
0,390 570,1440 1440,1620 1620,1920 1920,2340
which didn't use threads exactly
它不完全使用线程，但使用多个进程，

52
00:01:24,350 --> 00:01:26,240
0,120 120,420 420,810 810,1710 1710,1890
but use multiple processes,| in
|为了帮助您构建素数筛选软件

53
00:01:26,240 --> 00:01:28,220
0,210 210,300 300,660 660,1380 1620,1980
order to help structure {}

54
00:01:28,220 --> 00:01:29,840
0,600 690,960 960,1080 1080,1350 1350,1620
this {} your prime number

55
00:01:29,840 --> 00:01:31,370
0,360 360,750 750,840 840,1380 1380,1530
sieve software| and arguably it's
|可以说，这是一种更方便、更优雅或更简单的方式

56
00:01:31,370 --> 00:01:33,620
0,180 180,240 240,330 330,1020 1710,2250
sort of a more convenient

57
00:01:33,620 --> 00:01:34,850
0,60 60,510 510,570 570,960 960,1230
or elegant or simpler way|
|

58
00:01:34,850 --> 00:01:35,500
0,330
to
去写那个软件。

59
00:01:35,590 --> 00:01:36,850
0,180 180,360 360,540 540,720 720,1260
{} to write that software.|
|

60
00:01:37,620 --> 00:01:39,150
0,300 480,690 690,1020 1020,1320 1320,1530
And the final reason why
人们使用线程的最后一个原因是，

61
00:01:39,150 --> 00:01:41,340
0,330 330,540 540,1260 1260,1770 1770,2190
people use threads is,| to
|为了从多核机器获得并行加速比，

62
00:01:41,610 --> 00:01:43,500
0,360 360,900 900,1410 1410,1620 1620,1890
get parallel speedup from multi

63
00:01:43,500 --> 00:01:46,170
0,210 210,960 1200,1710 1950,2190 2190,2670
core machines,| so it's common
|所以在某种程度上分解你的程序是很常见的，

64
00:01:46,170 --> 00:01:48,120
0,330 510,960 960,1110 1110,1230 1230,1950
to break up your program

65
00:01:48,120 --> 00:01:49,410
0,90 90,180 180,450 450,660 690,1290
in a way,| that {}
|使用线程允许同一程序的不同部分在不同的内核上运行，

66
00:01:49,890 --> 00:01:52,320
0,390 390,1140 1140,1590 1680,2070 2070,2430
using threads to allow different

67
00:01:52,320 --> 00:01:53,730
0,510 510,630 630,690 690,930 930,1410
parts of the same program

68
00:01:53,730 --> 00:01:55,110
0,120 120,270 270,420 420,690 690,1380
to run on different cores,|
|

69
00:01:55,110 --> 00:01:56,940
0,240 330,660 660,780 780,1050 1260,1830
and if you can maybe
如果你可以，也许如果你幸运的话，

70
00:01:56,940 --> 00:01:57,840
0,120 120,240 240,660 660,780 780,900
if you're lucky,| if you
|如果您可以将您程序拆分为在四个核心的四个线程上运行，

71
00:01:57,840 --> 00:01:59,370
0,300 390,870 870,990 990,1380 1380,1530
can split your program up

72
00:01:59,370 --> 00:02:00,720
0,90 90,390 390,660 690,1020 1020,1350
to run on four threads

73
00:02:00,720 --> 00:02:02,160
0,150 150,390 390,990 1020,1290 1290,1440
on four cores,| you might
|你也许可以把它的速度提高到原来的四倍。

74
00:02:02,160 --> 00:02:02,760
0,120 120,270 270,360 360,510 510,600
be able to get a

75
00:02:02,760 --> 00:02:04,170
0,390 390,480 480,780 780,1170 1170,1410
factor of four speed up

76
00:02:04,170 --> 00:02:05,720
0,180 180,540 540,660 660,1200
how fast it runs.|
|

77
00:02:05,720 --> 00:02:06,660
0,390

78
00:02:06,780 --> 00:02:07,740
0,210 210,510 510,630 630,750 750,960
And indeed, you can view
实际上，您可以将xv6内核视为一个多核并行程序。

79
00:02:07,740 --> 00:02:09,930
0,90 90,600 600,1080 1080,1590 1890,2190
the xv6 kernel as a

80
00:02:09,930 --> 00:02:12,520
0,480 480,900 900,1380 1380,1920
multi core parallel program.|

81
00:02:12,700 --> 00:02:15,370
0,450 1350,1590 1590,1980 1980,2370 2370,2670
So what threads are, is
那么线程是什么，是一种简化编程的抽象，

82
00:02:15,370 --> 00:02:18,760
0,120 120,1110 1260,1740 1830,2430 2430,3390
an abstraction to simplify programming,|
|

83
00:02:18,940 --> 00:02:20,080
0,330 330,570 570,690 690,810 810,1140
{} when you have many
当你有很多任务时，

84
00:02:20,080 --> 00:02:21,130
0,570 570,720 720,810 810,960 960,1050
tasks,| when you want to
|当您想要同时处理多项任务时，

85
00:02:21,130 --> 00:02:23,380
0,330 330,660 660,1470 1500,1950 1980,2250
juggle many tasks,| so what
|所以线是什么，

86
00:02:23,380 --> 00:02:24,430
0,30 30,360 360,630 630,840 840,1050
a thread is is {},|
|

87
00:02:24,670 --> 00:02:25,510
0,330 330,450 450,570 570,780 780,840
{} you can think of
你可以把一个线程想象成一个单一的串行执行，

88
00:02:25,510 --> 00:02:26,830
0,90 90,540 540,840 840,1080 1080,1320
a thread as just being

89
00:02:26,860 --> 00:02:29,080
0,210 210,780 780,1470 1470,2100 2100,2220
a single serial execution,| if
|如果你只是写一个程序，做一件又一件事情，

90
00:02:29,080 --> 00:02:30,040
0,90 90,300 300,510 510,570 570,960
you just write a program

91
00:02:30,040 --> 00:02:30,970
0,90 90,240 240,450 450,630 630,930
that does one thing after

92
00:02:30,970 --> 00:02:31,960
0,420 420,540 540,630 630,810 810,990
another,| and you run that
|如果你运行这个程序，

93
00:02:31,960 --> 00:02:34,360
0,600 870,1500 1590,2040 2160,2310 2310,2400
program,| {} that you know
|你知道你可以把这个程序看作是一种单一的控制线程。

94
00:02:34,360 --> 00:02:35,260
0,210 210,300 300,480 480,570 570,900
you can view the program

95
00:02:35,260 --> 00:02:36,280
0,120 120,180 180,360 360,450 450,1020
as a sort of single

96
00:02:36,280 --> 00:02:37,920
0,420 420,510 510,1290
thread of control.|
|

97
00:02:38,290 --> 00:02:40,630
0,540 1050,1650 1830,2160 2160,2280 2280,2340
So, {} this is a
所以，这是一个宽泛的定义。

98
00:02:40,630 --> 00:02:42,440
0,360 360,1200
loose definition.|
|

99
00:02:44,160 --> 00:02:45,930
0,390 390,540 540,780 780,1200 1560,1770
Because there's many different sort
因为人们所说的线有很多不同的味道，

100
00:02:45,930 --> 00:02:46,980
0,90 90,630 630,690 690,810 810,1050
of flavors of what people

101
00:02:46,980 --> 00:02:49,440
0,150 150,300 300,810 810,1140 2190,2460
mean by threads,| but we'll
|但我们会说这是一次连环行刑

102
00:02:49,440 --> 00:02:52,110
0,150 150,270 270,1260 1620,1920 1920,2670
say it's one {} serial

103
00:02:52,110 --> 00:02:54,270
0,810 1140,1560 1590,1830 1830,2010 2010,2160
execution,| so it's what you
|因此，如果您启动一个CPU并拥有它，

104
00:02:54,270 --> 00:02:56,740
0,330 330,570 570,1020 1110,1950
get if you {}

105
00:02:56,800 --> 00:02:59,080
0,600 600,690 690,1410 1440,2190 2190,2280
fire up one CPU and

106
00:02:59,080 --> 00:03:00,520
0,360 420,660 660,870 870,1290 1290,1440
{have,it},| {you,know} just execute one
|你知道，只是用普通的方式一条接一条地执行指令。

107
00:03:00,520 --> 00:03:01,750
0,450 450,720 720,1050 1050,1140 1140,1230
instruction after another in the

108
00:03:01,750 --> 00:03:03,340
0,450 450,810
ordinary way.|
|

109
00:03:04,270 --> 00:03:05,460
0,570

110
00:03:05,580 --> 00:03:06,540
0,240 240,510 510,720 720,900 900,960
We often talk about {}
我们经常谈到线程有状态，

111
00:03:06,540 --> 00:03:08,130
0,270 270,480 480,1230 1260,1470 1470,1590
thread having state,| because it's
|因为结果会是，

112
00:03:08,130 --> 00:03:08,940
0,150 150,210 210,450 450,690 690,810
going to turn out,| we're
|我们会想要保存线程状态

113
00:03:08,940 --> 00:03:09,720
0,150 150,240 240,390 390,450 450,780
going to want to save

114
00:03:09,720 --> 00:03:10,950
0,300 300,390 390,690 690,1110 1110,1230
away {} thread state| and
|稍后再进行修复，

115
00:03:10,950 --> 00:03:13,890
0,330 330,420 420,810 1830,2400 2430,2940
restore it later,| and so
|因此思考线程状态的正确方式是，

116
00:03:14,190 --> 00:03:14,880
0,240 240,390 390,480 480,570 570,690
the right way to think

117
00:03:14,880 --> 00:03:15,720
0,150 150,210 210,450 450,750 750,840
about {} thread state,| for
|在很大程度上，这是最重要的部分，

118
00:03:15,720 --> 00:03:17,310
0,150 180,480 480,900 1020,1470 1470,1590
the most part {} the

119
00:03:17,310 --> 00:03:19,110
0,180 180,1020 1020,1410 1410,1740 1740,1800
most important part,| perhaps of
|线程状态的可能是其程序计数器，

120
00:03:19,110 --> 00:03:20,160
0,60 60,360 360,750 750,870 870,1050
the thread state is its

121
00:03:20,160 --> 00:03:22,170
0,480 480,960 1260,1740 1740,1890 1890,2010
program counter,| because it's an
|因为它是行刑，所以我们很关心它在行刑中处于什么位置

122
00:03:22,170 --> 00:03:23,430
0,660 660,750 750,960 960,1020 1020,1260
execution, we care a lot

123
00:03:23,430 --> 00:03:24,690
0,240 240,630 630,780 780,1110 1140,1260
about where is it in

124
00:03:24,690 --> 00:03:26,490
0,120 120,840 1020,1260 1260,1410 1410,1800
its execution| and what address
|它执行指令的地址是什么，

125
00:03:26,490 --> 00:03:29,220
0,150 150,300 300,750 750,1470 2520,2730
is it executing instructions,| but
|但我们也关心微处理器状态的睡觉，

126
00:03:29,220 --> 00:03:30,160
0,480
also

127
00:03:30,360 --> 00:03:31,560
0,300 300,480 480,720 720,930 930,1200
we care about the rest

128
00:03:31,560 --> 00:03:33,090
0,90 90,150 150,960 960,1350 1350,1530
of the microprocessor state,| that's
|这是支持此执行所必需的

129
00:03:33,090 --> 00:03:34,860
0,390 390,480 480,960 960,1110 1110,1770
required to support this execution|
|

130
00:03:35,100 --> 00:03:36,300
0,270 270,420 420,600 600,810 810,1200
and so that means it's.|
所以这意味着它是。|

131
00:03:38,520 --> 00:03:39,690
0,240 270,810 810,870 870,930 930,1170
The state of a thread
线程的状态包括编译器用来保存变量的寄存器

132
00:03:39,690 --> 00:03:41,130
0,330 330,450 450,1260 1260,1380 1380,1440
includes the registers that the

133
00:03:41,130 --> 00:03:42,960
0,450 450,750 750,840 840,1110 1110,1830
compiler uses to hold variables|
|

134
00:03:43,200 --> 00:03:45,240
0,390 390,720 720,1140 1140,1410 1770,2040
and also because the just
还因为编译器生成代码的方式，

135
00:03:45,240 --> 00:03:46,290
0,90 90,180 180,270 270,630 630,1050
the way the compiler generates

136
00:03:46,290 --> 00:03:48,480
0,780 840,1140 1140,1410 1410,1830 1830,2190
code,| {} thread state includes
|线程状态包括堆栈，

137
00:03:48,480 --> 00:03:49,760
0,60 60,720
a stack,|
|

138
00:03:49,970 --> 00:03:51,890
0,270 270,600 1110,1410 1410,1620 1650,1920
{} so typically if each
因此通常情况下，如果每个线程都有自己的堆栈

139
00:03:51,890 --> 00:03:53,150
0,300 300,480 480,630 630,900 900,1260
thread has its own stack|
|

140
00:03:53,150 --> 00:03:54,770
0,540 540,600 600,1050 1050,1230 1230,1620
dedicated to executing that {thread,and}
专用于执行该线程和堆栈记录，

141
00:03:54,770 --> 00:03:56,810
0,90 90,510 510,1320 1500,1710 1710,2040
the stack records,| the record
|函数调用的记录，

142
00:03:56,810 --> 00:03:59,180
0,90 90,480 480,1320
of function calls,|
|

143
00:03:59,960 --> 00:04:01,910
0,210 210,480 480,840 1200,1860 1860,1950
{} that the reflect the
反映该线程执行中的当前点。

144
00:04:01,910 --> 00:04:03,290
0,330 330,630 630,720 720,780 780,1380
current point in the execution

145
00:04:03,290 --> 00:04:05,060
0,390 480,780 780,1200
of that thread.|
|

146
00:04:05,630 --> 00:04:06,650
0,210 210,330 330,450 450,540 540,1020
And so what a threading
因此，穿线系统xv6在其内部包括穿线系统，

147
00:04:06,650 --> 00:04:08,570
0,420 420,690 690,810 810,1020 1020,1920
system {xv6 - -} includes

148
00:04:08,780 --> 00:04:10,130
0,210 210,540 540,840 840,1200 1200,1350
a threading system inside it,|
|

149
00:04:10,160 --> 00:04:11,510
0,360 360,420 420,720 720,1050 1050,1350
what a threading system does|
线程系统的作用是什么|

150
00:04:11,510 --> 00:04:15,380
0,210 270,1080 1080,1890 1950,3210 3240,3870
is manage this interleave, automate
是管理该交织、自动执行多个线程交织，

151
00:04:15,380 --> 00:04:18,200
0,120 120,1170 1170,1380 1380,1890 1890,2820
the interleaving of multiple threads,|
|

152
00:04:18,410 --> 00:04:18,980
0,210 210,300 300,450 450,510 510,570
you would like to be
您希望能够启动两个、400个或1000个线程

153
00:04:18,980 --> 00:04:20,600
0,150 150,240 240,630 630,870 1140,1620
able to fire up two

154
00:04:20,600 --> 00:04:22,400
0,450 450,1230 1230,1320 1320,1380 1380,1800
or 400 or a thousand

155
00:04:22,400 --> 00:04:23,960
0,420 420,540 540,870 1020,1260 1260,1560
threads| and {} the threading
|线程系统会计算出如何处理所有这些线程

156
00:04:23,960 --> 00:04:26,720
0,1140 1170,1800 1800,2100 2100,2310 2310,2760
system figure out how to

157
00:04:27,120 --> 00:04:28,380
0,270 270,600 600,720 720,930 930,1260
{} juggle all those threads|
|

158
00:04:28,380 --> 00:04:29,070
0,90 90,360 360,480 480,630 630,690
and cause them all to
并使他们所有人都取得进步，所有人都被执行。

159
00:04:29,070 --> 00:04:30,270
0,180 180,690 690,900 900,1080 1080,1200
make progress and all to

160
00:04:30,270 --> 00:04:31,340
0,510
execute.|

161
00:04:32,030 --> 00:04:35,930
0,480 1710,2040 2040,2460 2730,3360 3570,3900
{} There's really {} two
实际上有两个主要的策略，

162
00:04:35,930 --> 00:04:37,280
0,300 300,990 990,1140 1140,1200 1200,1350
main strategy,| so we want
|所以我们想要交错，

163
00:04:37,280 --> 00:04:38,980
0,60 60,1110
to interleave,|
|

164
00:04:39,210 --> 00:04:40,650
0,570 630,810 810,900 900,1140 1140,1440
{} this is gonna be
这会是个大话题

165
00:04:40,650 --> 00:04:41,580
0,300
{}

166
00:04:42,620 --> 00:04:43,700
0,210 210,570 570,810 810,960 960,1080
big topic,| here's how to
|下面是如何交错线程，许多线程，

167
00:04:43,700 --> 00:04:48,170
0,420 420,1290 1710,2310 2310,3090 3540,4470
interleave threads, many threads,| one
|交错执行多个线程的一种方法

168
00:04:48,170 --> 00:04:49,340
0,150 150,270 270,720 720,780 780,1170
way to interleave the execution

169
00:04:49,340 --> 00:04:50,180
0,60 60,270 270,660 660,750 750,840
of many threads| is to
|就是拥有多个CPU。

170
00:04:50,180 --> 00:04:53,200
0,120 120,540 540,1200 1200,1740
have multiple {CPUs -}.|
|

171
00:04:55,070 --> 00:04:56,960
0,360 360,990 1110,1530 1530,1590 1590,1890
Maybe as on a multi
也许就像在多核处理器上一样

172
00:04:56,960 --> 00:04:59,390
0,240 240,930 1530,1740 1740,1980 2010,2430
core processor| and then each
|然后每个CPU可以运行自己的线程，

173
00:04:59,390 --> 00:05:00,470
0,480 480,660 660,840 840,960 960,1080
CPU can run its own

174
00:05:00,470 --> 00:05:01,190
0,300 300,420 420,540 540,600 600,720
thread,| so if you have
|所以如果你有四个CPU，

175
00:05:01,190 --> 00:05:02,660
0,210 210,780 780,960 1140,1410 1410,1470
four CPUs,| {} there's an
|有一种明显的方式可以运行四个线程，

176
00:05:02,660 --> 00:05:05,120
0,540 540,720 720,840 840,1290 2070,2460
obvious way to run four

177
00:05:05,120 --> 00:05:06,140
0,420 420,510 510,600 600,780 780,1020
threads,| is to run one
|是在每个CPU上运行一个线程，

178
00:05:06,140 --> 00:05:07,310
0,270 270,360 360,930 930,1020 1020,1170
thread per CPU,| and then
|然后每个线程自动获得其自己的程序计数器寄存器，

179
00:05:07,310 --> 00:05:08,840
0,210 210,540 540,1140 1140,1380 1380,1530
each thread automatically gets its

180
00:05:08,840 --> 00:05:11,180
0,360 510,1170 1170,1530 1530,2190 2190,2340
own program counter registers,| that
|即程序计数器寄存器与正在运行的CPU相关联，

181
00:05:11,180 --> 00:05:12,800
0,480 510,630 630,930 930,1200 1200,1620
is the program counter register

182
00:05:12,800 --> 00:05:14,690
0,60 60,570 570,900 1260,1470 1470,1890
is associated with the CPU

183
00:05:14,690 --> 00:05:16,010
0,120 120,390 390,630 990,1260 1260,1320
is running on,| but if
|但是如果你有四个CPU和一千个线程，

184
00:05:16,010 --> 00:05:17,120
0,60 60,180 180,360 360,990 990,1110
you have four CPUs and

185
00:05:17,120 --> 00:05:18,440
0,60 60,150 150,210 210,660 660,1320
you have a thousand threads,|
|

186
00:05:18,590 --> 00:05:20,860
0,1350
then
那么你就知道如何使用一个公司的帖子，

187
00:05:20,860 --> 00:05:22,660
0,420 930,1170 1170,1230 1230,1410 1410,1800
{} you know how using

188
00:05:22,660 --> 00:05:24,580
0,270 270,600 600,1170 1170,1650 1710,1920
one corporate thread,| {} is
|不会是一个足够的答案。

189
00:05:24,580 --> 00:05:25,570
0,180 180,300 300,390 390,690 720,990
not going to be enough

190
00:05:25,570 --> 00:05:27,040
0,120 120,240 240,750 960,1110 1110,1470
of an answer.| And so
|所以我们将要看到的另一个主要策略是，

191
00:05:27,040 --> 00:05:29,080
0,240 270,600 600,1170 1200,1890 1890,2040
the other main strategy that

192
00:05:29,080 --> 00:05:30,300
0,120 120,660
we'll see,|
|

193
00:05:30,620 --> 00:05:31,760
0,360 360,570
indeed the
的确，这堂课的大部分内容都是围绕这一主题展开的。

194
00:05:31,760 --> 00:05:33,170
0,510 510,690 690,1200 1200,1260 1260,1410
topic of most of this

195
00:05:33,170 --> 00:05:36,350
0,450 660,1110 1140,1860 1890,2160 2160,3180
lecture| is how each CPU
|是每个CPU将如何在不同线程之间切换，

196
00:05:36,410 --> 00:05:39,050
0,240 240,360 360,450 450,1590 1830,2640
is going to switch among

197
00:05:39,050 --> 00:05:41,780
0,420 1320,2310 2340,2550 2550,2670 2670,2730
different threads,| so if I
|所以如果我有一个CPU和一千个线程，

198
00:05:41,780 --> 00:05:42,590
0,90 90,270 270,690 690,780 780,810
have one CPU and a

199
00:05:42,590 --> 00:05:44,900
0,390 390,990 1080,2040 2070,2220 2220,2310
thousand threads,| we're going to
|我们来看看xv6是如何构建交换系统的，

200
00:05:44,900 --> 00:05:47,210
0,300 300,420 420,1050 1050,1740 1740,2310
see how xv6 builds switching

201
00:05:47,210 --> 00:05:48,950
0,600 840,1050 1050,1350 1350,1560 1560,1740
system,| that allows {xv6 -}
|这允许xv6在一段时间内运行一个线程。

202
00:05:48,950 --> 00:05:49,820
0,60 60,210 210,450 450,720 720,870
to run one thread for

203
00:05:49,820 --> 00:05:51,350
0,30 30,480 480,570 570,750 750,1530
a while| and then switch
|然后交换并留在一边

204
00:05:51,380 --> 00:05:52,850
0,150 150,540 540,960 960,1080 1080,1470
and set aside| and save
|并保存该线程的状态

205
00:05:52,850 --> 00:05:53,600
0,90 90,360 360,420 420,570 570,750
the state of that one

206
00:05:53,600 --> 00:05:55,460
0,300 300,450 540,1050 1050,1170 1170,1860
thread| and switch to executing
|并暂时切换到执行第二个线程

207
00:05:55,460 --> 00:05:56,240
0,150 150,420 420,660 660,750 750,780
a second thread for a

208
00:05:56,240 --> 00:05:57,140
0,300 300,420 420,570 570,630 630,900
while| and then a third
|然后是第三条线，以此类推，

209
00:05:57,140 --> 00:05:58,190
0,270 270,390 390,600 600,810 810,1050
thread and so forth,| until
|直到它执行了每个线程的一小部分，

210
00:05:58,190 --> 00:05:59,510
0,210 330,930 930,990 990,1200 1200,1320
it's executed a little bit

211
00:05:59,510 --> 00:06:00,500
0,60 60,270 270,570 570,660 660,990
of each thread,| and then
|然后返回并执行更多第一线程的，依此类推。

212
00:06:00,740 --> 00:06:02,570
0,450 450,690 690,930 960,1350 1350,1830
go back and execute more

213
00:06:02,570 --> 00:06:03,590
0,120 120,480 540,660 660,750 750,1020
of the of the first

214
00:06:03,590 --> 00:06:04,660
0,210 210,330 330,540 540,750
thread and so on.|
|

215
00:06:05,030 --> 00:06:06,080
0,510

216
00:06:06,170 --> 00:06:07,490
0,180 180,210 210,510 510,930 930,1320
And {indeed -}, {xv6 -}
事实上，xv6和大多数操作系统一样，

217
00:06:07,520 --> 00:06:09,290
0,330 330,570 570,870 870,1170 1170,1770
like most operating system,| combines
|组合xv6将在所有可用内核上运行线程

218
00:06:09,290 --> 00:06:11,300
0,210 210,570 570,990 1290,1620 1620,2010
the {xv6 -} will run

219
00:06:11,390 --> 00:06:12,920
0,630 630,840 840,1080 1080,1170 1170,1530
threads on all the cores

220
00:06:12,920 --> 00:06:13,910
0,150 150,210 210,720 720,810 810,990
that are available| and each
|并且每个核心将在线程之间切换，

221
00:06:13,910 --> 00:06:16,820
0,360 360,600 600,1380 1740,2250 2250,2910
core will switch among threads,|
|

222
00:06:17,030 --> 00:06:18,590
0,270 270,420 420,750 750,990 1020,1560
because there's typical {},| typically
因为有典型的，|通常情况下(尽管并非总是如此)，线程数量通常比CPU数量多得多。

223
00:06:18,830 --> 00:06:20,300
0,270 270,510 510,930 930,1080 1080,1470
although not always there's typically

224
00:06:20,300 --> 00:06:21,500
0,210 210,390 390,960 960,1110 1110,1200
many more threads than there

225
00:06:21,500 --> 00:06:23,440
0,390 570,1140 1140,1530
are {CPUs -}.|
|

226
00:06:23,440 --> 00:06:24,480
0,450

227
00:06:24,780 --> 00:06:27,900
0,1230 1230,2340 2580,2760 2760,2850 2850,3120
One {} of the many
不同的线程系统的众多方式之一

228
00:06:27,900 --> 00:06:29,700
0,420 420,510 510,990 1020,1320 1320,1800
ways in which a different

229
00:06:29,970 --> 00:06:32,070
0,450 450,1320 1350,1500 1500,2010 2010,2100
threading systems| or instances of
|或者线程系统的实例的不同之处在于它们是否共享内存。

230
00:06:32,070 --> 00:06:34,020
0,360 360,1020 1020,1500 1590,1860 1860,1950
threading systems differ is in

231
00:06:34,020 --> 00:06:35,010
0,240 240,300 300,480 480,600 600,990
whether or not they share

232
00:06:35,010 --> 00:06:36,960
0,570
memory.|
|

233
00:06:36,960 --> 00:06:38,400
0,180 180,330 330,510 510,840
So this is {}
所以这一点很重要。

234
00:06:39,590 --> 00:06:42,000
0,870 1230,1890
important {}

235
00:06:42,760 --> 00:06:45,040
0,600 1080,1620
point {}.|
|

236
00:06:45,040 --> 00:06:46,930
0,420 420,1140 1140,1260 1260,1500 1560,1890
One possibility is that you
一种可能性是，您可以有一个地址空间，其中有许多线程在该地址空间中执行

237
00:06:46,930 --> 00:06:48,040
0,90 90,300 300,390 390,810 810,1110
could have a single address

238
00:06:48,040 --> 00:06:50,050
0,600 630,780 780,1080 1080,1410 1410,2010
space with many threads executing

239
00:06:50,050 --> 00:06:51,040
0,60 60,240 240,510 510,870 870,990
in that address space| and
|然后他们看到彼此的变化，

240
00:06:51,040 --> 00:06:51,970
0,120 120,240 240,510 510,660 660,930
then they see each other's

241
00:06:51,970 --> 00:06:53,920
0,840 1020,1230 1230,1410 1410,1620 1620,1950
changes,| if one of the
|如果共享一些存储器的线程之一修改变量，

242
00:06:54,340 --> 00:06:56,290
0,420 420,960 960,1110 1110,1440 1440,1950
threads sharing some memory modifies

243
00:06:56,290 --> 00:06:57,730
0,150 150,660 660,990 1020,1290 1290,1440
{} variable,| then the other
则共享该内存的另一个线程将看到修改。

244
00:06:57,730 --> 00:06:58,750
0,210 210,450 450,600 600,900 900,1020
thread sharing that memory will

245
00:06:58,750 --> 00:07:01,280
0,210 210,300 300,1020
see the modification.|
|

246
00:07:01,430 --> 00:07:02,000
0,210 210,330 330,450 450,510 510,570
And so it's in the
所以它是在线程运行的上下文中

247
00:07:02,000 --> 00:07:03,440
0,510 510,600 600,930 930,1200 1200,1440
context of threads running| and
|共享我们需要的内存，比如锁

248
00:07:03,590 --> 00:07:04,880
0,600 600,930 930,1050 1050,1140 1140,1290
sharing memory that we need

249
00:07:04,880 --> 00:07:06,410
0,180 180,450 450,600 600,1200 1200,1530
things like the locks| that
|你在上一节课上看到的。

250
00:07:06,890 --> 00:07:08,030
0,390 390,630 630,720 720,810 810,1140
you saw in the last

251
00:07:08,030 --> 00:07:09,760
0,360
lecture.|
|

252
00:07:10,330 --> 00:07:12,880
0,570 570,1140 1140,2010 2040,2220 2220,2550
{Xv6 -} kernel is shared
Xv6内核是共享内存，

253
00:07:12,880 --> 00:07:14,590
0,630 870,1200 1200,1410 1410,1590 1590,1710
memory,| {} so {xv6 -
|所以xv6有一个，支持内核线程的概念，

254
00:07:14,590 --> 00:07:15,700
0,600
-}

255
00:07:15,760 --> 00:07:18,340
0,390 420,720 720,1080 1410,1890
{} there's a {},

256
00:07:18,340 --> 00:07:19,480
0,480 480,540 540,750 750,810 810,1140
supports the notion of kernel

257
00:07:19,480 --> 00:07:21,010
0,330 330,480 480,660 660,990 990,1530
threads,| there's one kernel thread
|每个进程有一个内核线程来执行该进程的系统调用，

258
00:07:21,160 --> 00:07:23,620
0,840 870,1470 1470,1620 1620,2130 2130,2460
per process that executes system

259
00:07:23,620 --> 00:07:25,060
0,300 300,390 390,540 540,1050 1200,1440
calls for that process,| all
|所有这些内核线程共享内核存储器，

260
00:07:25,060 --> 00:07:26,890
0,180 180,450 450,780 780,1440 1440,1830
those kernel threads share kernel

261
00:07:26,890 --> 00:07:29,890
0,630 1350,1710 1830,2460 2460,2730 2730,3000
memory,| so xv6 kernel threads
|所以xv6内核线程确实共享内存。

262
00:07:29,890 --> 00:07:32,080
0,180 180,420 420,840
do share memory.|
|

263
00:07:34,400 --> 00:07:35,900
0,930
And,
另一方面，xv6，

264
00:07:36,690 --> 00:07:37,500
0,330 330,450 450,510 510,660 660,810
{} on the other hand

265
00:07:37,650 --> 00:07:39,090
0,750 750,930 930,1170 1170,1350 1350,1440
xv6,| that's another kind of
|这是另一种线程，每个用户进程基本上都有一个控制线程，

266
00:07:39,090 --> 00:07:41,610
0,330 330,600 600,930 930,1770 1860,2520
threads, each user process essentially

267
00:07:41,610 --> 00:07:42,510
0,180 180,240 240,570 570,810 810,900
has a single thread of

268
00:07:42,510 --> 00:07:44,130
0,510 510,660 660,1170 1170,1260 1260,1620
control,| that executes the user
|其执行该进程的用户指令，

269
00:07:44,130 --> 00:07:46,560
0,660 660,750 750,960 960,1740 1950,2430
instructions for that process,| and
|而且确实有很多xv6内核线程化机器。

270
00:07:46,650 --> 00:07:47,700
0,420 420,480 480,690 690,780 780,1050
indeed a lot of the

271
00:07:48,210 --> 00:07:50,280
0,390 390,630 630,1290 1320,1710 1710,2070
{} {xv6 -} kernel threading

272
00:07:50,280 --> 00:07:52,470
0,780 780,990 990,1560 1560,1680 1680,2190
machinery| is ultimately in support
|最终支持能够在许多用户进程上支持和切换它们，

273
00:07:52,470 --> 00:07:54,330
0,270 360,600 600,780 780,1200 1320,1860
of being able to support

274
00:07:54,330 --> 00:07:55,950
0,150 150,510 510,660 660,1080 1200,1620
and switch them on many

275
00:07:55,950 --> 00:07:58,050
0,270 270,990 1020,1260 1260,1500 1500,2100
user processes,| each user process
|每个用户进程具有存储器和在该存储器中运行的单个线程，

276
00:07:58,170 --> 00:07:59,190
0,330 330,360 360,840 840,960 960,1020
has a memory and a

277
00:07:59,190 --> 00:08:00,450
0,570 570,840 840,960 960,1200 1200,1260
single thread that runs in

278
00:08:00,450 --> 00:08:04,040
0,180 180,630 840,1350 1440,2640
that memory,| so xv6
|因此xv6用户进程，

279
00:08:04,040 --> 00:08:06,300
0,510 510,1710
user processes,|
|

280
00:08:11,160 --> 00:08:13,110
0,240 240,1110 1140,1290 1290,1560 1560,1950
each process has one thread|
每个进程都有一个线程|

281
00:08:13,110 --> 00:08:15,390
0,120 120,390 420,750 750,1380 1440,2280
and so there's no sharing
因此线程之间不会共享内存

282
00:08:15,390 --> 00:08:18,840
0,90 90,510 510,1080 1080,2010 2640,3450
of memory among threads| within
|在单个xv6用户进程内，

283
00:08:18,840 --> 00:08:20,520
0,180 180,570 570,1020 1020,1260 1260,1680
a single xv6 user process,|
|

284
00:08:20,520 --> 00:08:21,240
0,60 60,210 210,270 270,390 390,720
{because -} you get multiple
因为你有多个进程，

285
00:08:21,240 --> 00:08:22,860
0,600 600,810 1170,1410 1410,1470 1470,1620
processes,| but each of those
|但是这些进程中的每一个都是具有单线程进程的地址空间，

286
00:08:22,860 --> 00:08:24,660
0,840 870,990 990,1080 1080,1410 1410,1800
processes is an address space

287
00:08:24,660 --> 00:08:27,870
0,240 240,300 300,600 600,1110 2340,3210
with a single thread processes,|
|

288
00:08:27,900 --> 00:08:29,310
0,150 150,600 600,780 780,960 960,1410
in xv6, don't share memory.|
在xv6中，不要共享内存。|

289
00:08:29,790 --> 00:08:31,920
0,300 300,600 600,810 810,1620 1650,2130
In other more sophisticated operating
在其他更复杂的操作系统中，

290
00:08:31,920 --> 00:08:34,880
0,480 480,600 600,900 900,1590
systems,| for example Linux,|
|例如Linux，|

291
00:08:35,110 --> 00:08:38,260
0,600 600,930 930,1440 1860,2520
Linux user level {}
Linux用户级别确实允许在一个进程中有多个线程

292
00:08:38,260 --> 00:08:41,710
0,510 510,1380 2070,2850 2850,3360 3360,3450
does allow multiple threads in

293
00:08:41,710 --> 00:08:43,180
0,60 60,600 600,720 720,780 780,1470
a process| and the processes
|并且这些进程和那些线程共享该单个进程的内存

294
00:08:43,180 --> 00:08:44,830
0,120 120,360 360,960 990,1590 1590,1650
and those threads share the

295
00:08:44,830 --> 00:08:46,750
0,480 480,810 810,1020 1020,1290 1290,1920
memory of that single process|
|

296
00:08:47,380 --> 00:08:48,310
0,180 180,360 360,600 600,870 870,930
and that's super cool if
如果你想编写用户级别的程序，这是非常酷的

297
00:08:48,310 --> 00:08:49,000
0,90 90,210 210,270 270,450 450,690
you want to write user

298
00:08:49,000 --> 00:08:51,610
0,240 240,780 780,930 1800,2400 2400,2610
level programs| that use level
|使用可从多核获得加速级别并行程序

299
00:08:51,610 --> 00:08:53,890
0,480 480,1110 1110,1290 1440,1860 1860,2280
parallel programs that get {speed,up}

300
00:08:53,890 --> 00:08:55,540
0,120 120,450 450,1050 1170,1470 1470,1650
from multiple cores| {} better
|更好的需要另一种，

301
00:08:55,540 --> 00:08:56,980
0,360 360,510 510,570 570,1110 1230,1440
requires sort of another,| it
|它使用了很多相同的基本技术，

302
00:08:57,250 --> 00:08:58,360
0,600 600,840 840,990 990,1050 1050,1110
uses a lot of the

303
00:08:58,360 --> 00:08:59,500
0,210 210,510 510,930 930,1020 1020,1140
same basic techniques,| we're going
|我们今天要讨论的是，

304
00:08:59,500 --> 00:09:00,790
0,270 300,510 510,720 720,1080 1080,1290
to talk about today,| but
|但是Linux有一定程度的复杂性

305
00:09:01,000 --> 00:09:02,260
0,300 300,570 570,690 690,1050 1050,1260
{} there's a certain amount

306
00:09:02,260 --> 00:09:03,910
0,150 150,840 840,960 960,1530 1530,1650
more sophistication in Linux| to
|要获得它，请跟踪每个进程的多个线程，而不是只跟踪一个线程。

307
00:09:03,910 --> 00:09:05,000
0,150 150,480
get it

308
00:09:05,000 --> 00:09:06,200
0,240 240,480 480,750 750,840 840,1200
{} keep track of multiple

309
00:09:06,200 --> 00:09:08,060
0,480 480,810 810,1530 1560,1800 1800,1860
threads per process instead of

310
00:09:08,060 --> 00:09:09,200
0,210 210,540
just one.|
|

311
00:09:12,250 --> 00:09:14,320
0,420 420,930 1170,1500 1500,1860 1860,2070
Okay, {} at a sort
好的，在某种程度上，我只想提一下，

312
00:09:14,320 --> 00:09:15,220
0,60 60,240 240,630 630,720 720,900
of high level, I just

313
00:09:15,220 --> 00:09:16,780
0,120 120,180 180,750 750,1080 1080,1560
want to mention,| that there's
|还有其他方法可以支持在一台计算机上交错执行多个任务

314
00:09:16,810 --> 00:09:19,270
0,300 300,1080 1080,1320 1320,2280 2310,2460
other ways to support the

315
00:09:19,270 --> 00:09:21,160
0,660 660,750 750,1170 1170,1770 1770,1890
interleaving of multiple tasks on

316
00:09:21,160 --> 00:09:23,350
0,30 30,390 390,990 1350,1740 1950,2190
a single computer| {} and
|我们不会谈论他们，

317
00:09:23,350 --> 00:09:23,980
0,90 90,210 210,330 330,390 390,630
we're not going to talk

318
00:09:23,980 --> 00:09:25,990
0,270 270,960 1050,1320 1320,1410 1410,2010
about them,| if you're curious
|如果您很好奇，可以查找事件驱动编程之类的内容

319
00:09:26,020 --> 00:09:27,280
0,450 450,600 600,780 780,1020 1020,1260
you can look up things

320
00:09:27,280 --> 00:09:29,530
0,240 270,600 600,930 930,1740 1740,2250
like {event-driven -} programming| or
或状态机

321
00:09:29,560 --> 00:09:32,350
0,540 540,1350 1500,1980 2250,2670 2670,2790
state machines| and these are
|并且这些是在许多不同任务之间共享一台计算机的非线程技术，

322
00:09:32,350 --> 00:09:34,690
0,420 420,810 810,1680 1710,2010 2010,2340
{non-thread -} techniques to share

323
00:09:34,690 --> 00:09:36,730
0,420 420,870 870,1350 1380,1740 1740,2040
one computer among many different

324
00:09:36,730 --> 00:09:39,400
0,630 750,990 990,1230 1230,1560 2490,2670
tasks,| it turns out you
|事实证明，你知道不同方案的[光谱]

325
00:09:39,400 --> 00:09:40,510
0,210 210,420 420,630 630,810 810,1110
know sort of on the

326
00:09:40,750 --> 00:09:43,060
0,720 720,930 930,1380 1380,1980 1980,2310
[spectrum] of different schemes| for
|为了支持计算机上的多个任务，

327
00:09:43,090 --> 00:09:44,290
0,390 390,720 720,1050 1050,1140 1140,1200
supporting multiple tasks on a

328
00:09:44,290 --> 00:09:45,940
0,480 570,930 930,1050 1050,1440 1440,1650
computer,| threads are not very
|线程效率不是很高，

329
00:09:45,940 --> 00:09:47,500
0,630 660,840 840,990 990,1200 1200,1560
efficient,| there's a more efficient
|有一个更有效的方案，

330
00:09:47,500 --> 00:09:50,080
0,630 1200,1590 1590,1890 1890,2010 2010,2580
schemes,| but threads are usually
|但是线程通常是最方便的方式，

331
00:09:50,080 --> 00:09:52,060
0,90 90,390 390,930 930,1590 1620,1980
the most convenient way,| most
|最适合程序员的方式，

332
00:09:52,060 --> 00:09:54,670
0,510 510,900 900,1440 1620,2400 2460,2610
programmer friendly way,| {} to
|来支持许多不同的任务。

333
00:09:54,670 --> 00:09:57,220
0,360 360,660 660,1080 1410,1770 1770,2550
support lots of different tasks.|
|

334
00:09:59,770 --> 00:10:01,580
0,480 660,1230
Okay {},
好的，这里有几个挑战，

335
00:10:02,030 --> 00:10:03,710
0,240 240,330 330,720 720,1080 1260,1680
there's a couple of {}

336
00:10:03,860 --> 00:10:04,970
0,750 750,840 840,900 900,1020 1020,1110
challenges,| that we're gonna have
|如果我们想要实现线程化系统，我们将不得不咬紧牙关。

337
00:10:04,970 --> 00:10:06,140
0,90 90,390 390,870 900,1050 1050,1170
to bite off if we

338
00:10:06,140 --> 00:10:07,880
0,180 180,360 420,1200 1230,1350 1350,1740
want to implement a threading

339
00:10:07,880 --> 00:10:09,000
0,540
system.|
|

340
00:10:09,790 --> 00:10:11,220
0,570

341
00:10:12,590 --> 00:10:14,390
0,690 1050,1230 1230,1410 1410,1500 1500,1800
The, so this is just
所以这只是高水平的挑战。

342
00:10:14,390 --> 00:10:16,320
0,240 240,480 480,1410
high level challenges.|
|

343
00:10:21,110 --> 00:10:22,360
0,630

344
00:10:22,880 --> 00:10:23,960
0,390 390,570 570,720 720,780 780,1080
One is as I mentioned
一个是我之前提到的，

345
00:10:23,960 --> 00:10:26,240
0,390 390,600 600,690 690,1350 1860,2280
before,| how to actually implement
|如何真正实现交织的切换，允许我们交织多线程执行的切换，

346
00:10:26,240 --> 00:10:27,760
0,90 90,960
the switching

347
00:10:27,930 --> 00:10:30,020
0,240 240,480 480,780 870,1500
for {interleave -} {},

348
00:10:30,170 --> 00:10:31,490
0,150 150,570 570,690 690,1110 1110,1320
the switching that allows us

349
00:10:31,490 --> 00:10:33,700
0,240 360,1650
to interleave

350
00:10:35,140 --> 00:10:37,030
0,180 180,870 870,960 960,1350 1350,1890
the execution of multiple threads,|
|

351
00:10:37,570 --> 00:10:40,560
0,420 540,810 810,1440 1560,2250
{} and this {}
这个切换决定过程的这个[宽泛的]名称，

352
00:10:40,560 --> 00:10:41,670
0,210 210,270 270,690 690,990 990,1110
sort of [broad] name for

353
00:10:41,670 --> 00:10:43,680
0,150 150,600 600,810 810,1410 1410,2010
this process of switching deciding,|
|

354
00:10:43,680 --> 00:10:44,580
0,270 270,390 390,450 450,690 690,900
I'm going to leave off
我要去掉一条线索

355
00:10:44,580 --> 00:10:46,800
0,450 510,990 990,1140 1140,1500 1890,2220
one thread| and {start,executing} another
|并开始执行另一个线程，

356
00:10:46,800 --> 00:10:48,600
0,390 540,780 780,960 960,1170 1170,1800
thread,| it's often called scheduling.|
|这通常被称为日程安排。|

357
00:10:51,520 --> 00:10:53,230
0,690 720,870 870,1110 1110,1440 1440,1710
And we'll see that {xv6
我们将看到xv6[检测]是一段实际的代码，

358
00:10:53,230 --> 00:10:54,580
0,300 300,570 570,1110 1110,1290 1290,1350
-} {[detects] -} as an

359
00:10:54,730 --> 00:10:55,990
0,480 480,690 690,750 750,1080 1080,1260
actual piece of code,| that's
|这就是说，调度器确实有多个调度器，每个内核一个调度器，

360
00:10:55,990 --> 00:10:57,430
0,90 90,660 660,930 930,1110 1110,1440
the scheduler indeed has multiple

361
00:10:57,430 --> 00:10:59,830
0,510 510,750 750,900 900,1320 2100,2400
schedulers one per core,| but
|但是关于你如何决定从一个人换到另一个人的总体想法是，

362
00:10:59,830 --> 00:11:02,020
0,90 90,420 420,960 960,1170 1710,2190
the general idea of how

363
00:11:02,020 --> 00:11:03,460
0,90 90,180 180,810 810,990 990,1440
do you drive the decision

364
00:11:03,460 --> 00:11:04,210
0,90 90,360 360,480 480,630 630,750
to switch from one to

365
00:11:04,210 --> 00:11:05,170
0,450 450,570 570,660 660,900 900,960
another,| how to pick the
|如何选择要运行的下一个线程，这叫做调度。

366
00:11:05,170 --> 00:11:07,180
0,270 270,570 570,690 690,1140 1830,2010
next thread to run, its

367
00:11:07,180 --> 00:11:08,600
0,150 150,600
called scheduling.|
|

368
00:11:10,120 --> 00:11:12,280
0,570 1020,1470 1470,1860 1860,1980 1980,2160
{} Another question is, if
另一个问题是，如果您想要真正实现从一个线程到另一个线程的切换，

369
00:11:12,280 --> 00:11:13,480
0,90 90,210 210,270 270,780 780,1200
you want to actually implement

370
00:11:13,480 --> 00:11:14,440
0,90 90,450 450,570 570,720 720,960
the switch from one thread

371
00:11:14,440 --> 00:11:15,130
0,90 90,360 360,450 450,600 600,690
to another,| you need to
|您需要保存和恢复，

372
00:11:15,130 --> 00:11:17,260
0,660 660,840 840,1620 1800,2040 2040,2130
save and restore,| so we
|所以我们需要决定需要拯救什么，我们要拯救它，

373
00:11:17,260 --> 00:11:18,850
0,150 150,240 240,960 990,1380 1380,1590
need to decide what needs

374
00:11:18,850 --> 00:11:21,310
0,90 90,210 210,990 1320,1800 2190,2460
to be saved and we

375
00:11:21,310 --> 00:11:22,460
0,90 90,180 180,510 510,660
are to save it,|
|

376
00:11:22,900 --> 00:11:24,430
0,720 1080,1230 1230,1410 1410,1470 1470,1530
when it needs to be
当它需要保存时，

377
00:11:24,430 --> 00:11:25,360
0,270 270,360 360,510 510,720 720,930
saved,| when we leave off
|当我们停止执行一个线程时

378
00:11:25,360 --> 00:11:27,070
0,360 360,570 570,900 900,990 990,1710
executing one thread| and restored
|并在稍后我们想要恢复执行该线程时恢复，

379
00:11:27,070 --> 00:11:28,810
0,450 660,1080 1080,1230 1230,1350 1350,1740
when we want to resume

380
00:11:28,810 --> 00:11:30,190
0,450 450,630 630,900 900,1020 1110,1380
executing that thread at some

381
00:11:30,190 --> 00:11:32,620
0,240 240,630 990,1290 1560,2040 2040,2430
later time,| and final question
|最后一个问题是如何处理计算受限的线程。

382
00:11:32,620 --> 00:11:33,340
0,120 120,330 330,390 390,510 510,720
is what to do about

383
00:11:33,340 --> 00:11:36,160
0,390 390,660 660,1530
compute bound threads.|
|

384
00:11:37,960 --> 00:11:39,280
0,720
The,
这个，很多选择，

385
00:11:40,090 --> 00:11:42,280
0,270 270,330 330,420 420,1470 1650,2190
many of the options {},|
|

386
00:11:42,370 --> 00:11:43,270
0,180 180,240 240,300 300,450 450,900
many of the most straightforward
线程切换的许多最简单的选项

387
00:11:43,270 --> 00:11:45,430
0,300 300,420 420,660 660,1230 1500,2160
options for thread switching| involve
|牵涉到的帖子都是自愿说的

388
00:11:45,430 --> 00:11:46,930
0,120 120,480 480,510 510,1260 1260,1500
the threads are voluntarily saying|
|

389
00:11:46,930 --> 00:11:47,530
0,150 150,210 210,330 330,390 390,600
well I'm going to save
我要拯救我的州

390
00:11:47,530 --> 00:11:48,760
0,120 120,270 270,840 840,1050 1050,1230
away my state| and sort
|然后运行另一个线程，让另一个线程运行，

391
00:11:48,760 --> 00:11:50,620
0,120 330,660 660,1170 1200,1590 1590,1860
of run another, let another

392
00:11:50,620 --> 00:11:52,270
0,270 270,420 420,780 840,1380 1410,1650
thread be run,| but what
|但是我们有一个用户程序来做一些长期运行的计算吗，

393
00:11:52,270 --> 00:11:52,870
0,60 60,180 180,270 270,360 360,600
do we have a user

394
00:11:52,870 --> 00:11:54,610
0,360 360,720 750,1200 1200,1350 1350,1740
program that's doing some long

395
00:11:54,610 --> 00:11:56,560
0,660 660,1440 1440,1590 1590,1770 1770,1950
running calculation,| that might take
|那可能需要几个小时

396
00:11:56,560 --> 00:11:58,600
0,720 870,1620 1620,1830 1830,1920 1920,2040
hours,| {} it's not going
|它不会特别考虑，

397
00:11:58,600 --> 00:12:00,190
0,60 60,150 150,540 540,900 900,1590
to be particularly thinking about,|
|

398
00:12:00,190 --> 00:12:01,240
0,240 240,360 360,570 570,780 840,1050
now be time to good
现在是时候让别的东西运行了，

399
00:12:01,240 --> 00:12:02,110
0,180 180,270 270,390 390,660 660,870
time to let something else

400
00:12:02,110 --> 00:12:05,020
0,450 660,1110 1260,1770 1770,2100 2100,2910
run,| so it's most convenient
所以最方便是通过某种方式自动撤销控制

401
00:12:05,530 --> 00:12:06,340
0,150 150,360 360,570 570,750 750,810
to have some way of

402
00:12:06,340 --> 00:12:08,620
0,540 540,630 630,1290 1290,1770 1770,2280
sort of automatically revoking control|
|

403
00:12:08,620 --> 00:12:10,300
0,360 450,720 720,1080 1080,1320 1320,1680
from some long running compute
从一些长时间运行的计算绑定进程，

404
00:12:10,300 --> 00:12:12,490
0,210 210,960 1140,1710 1740,2070 2070,2190
bound process,| {} setting it
|把它放在一边，也许以后再运行。

405
00:12:12,490 --> 00:12:13,900
0,510 510,720 780,1020 1020,1290 1290,1410
aside and maybe running it

406
00:12:13,900 --> 00:12:14,520
0,360
later.|
|

407
00:12:16,780 --> 00:12:17,830
0,660 660,780 780,840 840,960 960,1050
Alright, so I'm going to
好的，我要谈谈这些，

408
00:12:17,830 --> 00:12:19,600
0,240 240,510 510,1020 1020,1410 1410,1770
talk about these,| I'm actually
|实际上，我要先谈谈处理计算受限线程的机制。

409
00:12:19,600 --> 00:12:21,070
0,120 120,180 180,390 390,960 1320,1470
going to talk about {}

410
00:12:21,070 --> 00:12:22,480
0,120 120,630 630,1020 1050,1320 1320,1410
the machinery for dealing with

411
00:12:22,480 --> 00:12:26,440
0,420 420,630 630,1290 1560,2370
compute bound threads first.|
|

412
00:12:27,220 --> 00:12:28,560
0,780
And,
而且，这是你以前想过的方案，

413
00:12:28,740 --> 00:12:29,910
0,450 450,540 540,780 780,870 870,1170
scheme for that is something

414
00:12:29,910 --> 00:12:32,460
0,840 870,1260 1260,1380 1380,1950
you've come up before,|
|

415
00:12:32,520 --> 00:12:34,640
0,360 360,750 750,1590
that's timer interrupts.|
那是计时器中断。|

416
00:12:38,340 --> 00:12:40,400
0,330 390,570 570,900 900,1470
And the idea here,
这里的想法是，每个核心的每个CPU上都有一个，一块硬件，

417
00:12:40,610 --> 00:12:42,230
0,210 210,540 570,960 960,1170 1170,1620
is that there's a {},

418
00:12:42,500 --> 00:12:44,030
0,180 180,420 420,480 480,1110 1140,1530
a piece of hardware on

419
00:12:44,180 --> 00:12:46,040
0,420 450,1080 1080,1200 1200,1350 1350,1860
each CPU on each core,|
|

420
00:12:46,280 --> 00:12:49,640
0,270 270,750 750,1650 1770,2790 2820,3360
that generates periodic interrupts {},|
它会产生周期性的中断，|

421
00:12:49,850 --> 00:12:51,440
0,420 420,750 780,1140 1140,1440 1440,1590
and the {xv6 -} or
并且xv6或任何操作系统确实安排将这些中断传送到内核，

422
00:12:51,440 --> 00:12:52,850
0,150 150,450 450,720 720,930 930,1410
any operating system really arranges

423
00:12:52,850 --> 00:12:54,380
0,360 390,540 540,840 840,1170 1170,1530
to have those interrupts delivered

424
00:12:54,380 --> 00:12:55,880
0,60 60,150 150,540 540,810 1080,1500
to the kernel,| so even
|因此，即使我们在用户级别运行

425
00:12:55,880 --> 00:12:57,110
0,240 270,450 450,840 840,960 960,1230
if we're running at user

426
00:12:57,110 --> 00:12:58,520
0,300 300,450 450,660 660,1140 1140,1410
level| and some loop that's
|还有一些循环，你知道，这是计算圆周率的前10亿位，

427
00:12:58,520 --> 00:12:59,810
0,90 90,360 420,960 960,1050 1050,1290
you know computing the first

428
00:12:59,810 --> 00:13:03,170
0,690 720,1080 1080,1140 1140,1830 1920,3360
billion digits of pi,| nevertheless
|尽管如此，计时器中断还是会在某个时间点发生，可能是每10毫秒一次

429
00:13:03,470 --> 00:13:05,300
0,420 420,630 660,1080 1080,1500 1500,1830
{} the timer interrupts go

430
00:13:05,300 --> 00:13:06,200
0,180 180,240 240,390 390,660 660,900
off at some point maybe

431
00:13:06,200 --> 00:13:08,840
0,180 180,360 360,1230 1440,2250 2250,2640
every ten milliseconds| and transfer
|并将控制从该用户级代码转移到内核中的中断处理程序，

432
00:13:08,840 --> 00:13:10,220
0,360 360,690 690,900 900,1140 1140,1380
control from that user level

433
00:13:10,220 --> 00:13:12,260
0,600 690,1110 1110,1350 1350,1740 1740,2040
code into the interrupt handler

434
00:13:12,260 --> 00:13:13,190
0,60 60,150 150,510 600,720 720,930
in the kernel,| and so
|这是内核的第一步，

435
00:13:13,310 --> 00:13:15,830
0,270 270,570 1020,1620 1620,2070 2070,2520
that's the first step in

436
00:13:15,890 --> 00:13:17,300
0,240 240,630 630,840 840,1020 1020,1410
the kernel,| being able to
|能够获得在不同用户级进程之间切换的控制权，

437
00:13:17,330 --> 00:13:19,190
0,480 480,990 990,1080 1080,1440 1440,1860
gain control to switch among

438
00:13:19,190 --> 00:13:21,530
0,420 420,810 810,1110 1110,1920 1920,2340
different user level processes,| user
|用户级线程，

439
00:13:21,530 --> 00:13:23,420
0,270 270,840 1050,1530 1530,1680 1680,1890
level threads,| even if those
|即使那些用户级线程不是协作的。

440
00:13:23,420 --> 00:13:25,820
0,180 180,420 420,990 1110,1530 1530,2400
user level threads aren't cooperative.|
|

441
00:13:26,900 --> 00:13:30,620
0,480 2280,2760 2820,2940 2940,3270 3270,3720
{} And the basic scheme
基本方案是在中断处理器中，

442
00:13:30,620 --> 00:13:32,240
0,180 180,480 930,1110 1110,1230 1230,1620
is that in the interrupt

443
00:13:32,240 --> 00:13:33,260
0,480 480,660 660,720 720,870 870,1020
handler,| so we're gonna have
|所以我们会让你知道内核处理程序来处理这些中断。

444
00:13:33,260 --> 00:13:35,420
0,360 390,840 840,1620
{you,know} kernel handler

445
00:13:35,450 --> 00:13:37,520
0,360 360,480 480,660 660,1470
{} for these interrupts.|
|

446
00:13:38,170 --> 00:13:40,200
0,600 600,780 780,1470
And we'll see,|
我们将拭目以待，|

447
00:13:40,500 --> 00:13:43,230
0,450 450,840 900,1320 1320,2040 2370,2730
that a kernel handler {}
内核处理程序产生的，

448
00:13:43,260 --> 00:13:45,090
0,1110 1170,1410 1410,1530 1530,1620 1620,1830
yields,| this is the sort
|这就是它所产生的那种名字，

449
00:13:45,090 --> 00:13:46,320
0,120 270,840 840,930 930,1110 1110,1230
of name for this it

450
00:13:46,320 --> 00:13:49,260
0,690
yields,|
|

451
00:13:49,290 --> 00:13:51,900
0,300 300,720 720,1410 1560,1740 1740,2610
the kernel handler {sort,of} voluntarily
内核处理程序在某种程度上自愿将CPU交还给调度

452
00:13:51,900 --> 00:13:53,130
0,420 420,510 510,930 930,1140 1140,1230
yields the CPU back to

453
00:13:53,130 --> 00:13:54,480
0,120 120,600 600,870 870,960 960,1350
the schedule| until the schedule
|在时间表显示之前，您现在可以让其他事情运行。

454
00:13:54,480 --> 00:13:55,650
0,300 360,600 600,690 690,870 870,1170
look, you can let something

455
00:13:55,650 --> 00:13:57,020
0,240 240,480 480,750
else run now.|
|

456
00:13:58,240 --> 00:13:59,620
0,210 210,360 360,930 930,1080 1080,1380
And this yielding is really
而这种屈服实际上是一种线程切换的形式，

457
00:13:59,620 --> 00:14:01,920
0,420 420,810 810,1320
a form of

458
00:14:01,980 --> 00:14:04,830
0,420 420,1080 1080,1320 1830,2340 2460,2850
thread switch,| that {} saves
|这保存了当前线程的状态，

459
00:14:04,830 --> 00:14:05,550
0,210 210,330 330,600 600,660 660,720
away the state of the

460
00:14:05,550 --> 00:14:07,050
0,240 240,780 930,1350 1350,1410 1410,1500
current thread,| so it can
|这样以后就可以恢复了，

461
00:14:07,050 --> 00:14:10,650
0,90 90,480 480,870 3270,3510 3510,3600
be restored later,| as we'll
|正如我们将在这里看到的完整故事，

462
00:14:10,650 --> 00:14:12,390
0,330 330,960 990,1230 1230,1590 1590,1740
see the full story here,|
|

463
00:14:12,390 --> 00:14:13,140
0,240 240,330 330,510 510,540 540,750
actually you've seen a lot
实际上你已经在这里看到了很多完整的故事，

464
00:14:13,140 --> 00:14:13,920
0,90 90,150 150,330 330,630 630,780
of the full story here,|
|

465
00:14:13,920 --> 00:14:15,360
0,210 210,300 300,660 660,750 750,1440
because it involves an interrupt,|
因为它涉及到中断，|

466
00:14:16,050 --> 00:14:16,920
0,150 150,210 210,420 420,570 570,870
what you already know about
你已经知道的关于整个故事的内容有些复杂，

467
00:14:16,920 --> 00:14:18,330
0,60 60,240 240,480 480,720 720,1410
the full story some complex,|
|

468
00:14:18,330 --> 00:14:19,560
0,240 420,690 690,930 930,1140 1140,1230
but the basic idea is
但是基本的想法是定时器中断

469
00:14:19,560 --> 00:14:21,630
0,150 150,210 210,570 570,1080 1440,2070
that a timer interrupt| gives
|将控制权交给内核

470
00:14:21,630 --> 00:14:22,650
0,270 270,330 330,420 420,870 870,1020
control to the kernel| and
|并且内核自动产生CPU，

471
00:14:22,650 --> 00:14:25,020
0,60 60,600 690,1530 1530,2220 2250,2370
the kernel voluntarily yields the

472
00:14:25,020 --> 00:14:27,780
0,540 1800,2010 2010,2100 2100,2640 2640,2760
CPU,| this is called as
|这被称为抢占调度这一术语。

473
00:14:27,780 --> 00:14:30,120
0,150 150,420 420,810 960,1710 1710,2340
a piece of terminology preemptive

474
00:14:30,120 --> 00:14:31,220
0,780
scheduling.|
|

475
00:14:32,680 --> 00:14:33,960
0,690

476
00:14:38,980 --> 00:14:40,510
0,540 540,810 810,1020 1020,1170 1170,1530
{} And what that means
这意味着先发制人意味着

477
00:14:40,510 --> 00:14:42,460
0,180 180,480 630,750 750,1320 1320,1950
is that the preemptive means|

478
00:14:42,460 --> 00:14:43,780
0,180 180,420
is that,
那就是，即使正在运行的代码没有，

479
00:14:43,780 --> 00:14:45,100
0,300 300,420 420,750 780,1140 1140,1320
even if the code that's

480
00:14:45,100 --> 00:14:46,360
0,240 240,630
running doesn't,|
|

481
00:14:46,360 --> 00:14:48,310
0,210 210,480 480,750 750,1380 1710,1950
it doesn't want to you
它不想让您知道它不会显式地产生CPU，

482
00:14:48,310 --> 00:14:50,350
0,330 360,750 960,1710 1710,1950 1950,2040
know doesn't explicitly yield the

483
00:14:50,350 --> 00:14:52,150
0,660 810,1020 1020,1350 1350,1710 1710,1800
CPU,| the timer interrupt is
|定时器中断将会夺走控制权

484
00:14:52,150 --> 00:14:53,500
0,150 150,240 240,450 450,840 840,1350
going to take control away|
|

485
00:14:53,710 --> 00:14:55,060
0,630 630,750 750,870 870,930 930,1350
and we're going to yield
我们要向它屈服

486
00:14:55,060 --> 00:14:56,110
0,270 270,510 510,600 600,690 690,1050
for it| and the opposite
|先发制人计划的反义词可能被称为自愿计划。

487
00:14:56,110 --> 00:14:58,600
0,60 60,570 570,1230 1770,2400 2400,2490
of preemptive scheduling might be

488
00:14:58,600 --> 00:14:59,560
0,450
called,

489
00:15:00,230 --> 00:15:02,760
0,420 420,690 690,1350 1350,1920
{} maybe voluntary scheduling.|
|

490
00:15:05,040 --> 00:15:06,150
0,180 180,270 270,630 630,810 810,1110
And the interesting thing is
有趣的是，

491
00:15:06,150 --> 00:15:08,220
0,180 180,480 810,1170 1170,1920 1920,2070
that| the the implementation in
|抢占式调度在xv6等操作系统中的实现

492
00:15:08,220 --> 00:15:10,020
0,540 540,900 900,1110 1110,1440 1440,1800
xv6 and other operating systems

493
00:15:10,020 --> 00:15:11,580
0,90 90,570 570,1200 1200,1350 1350,1560
of preemptive scheduling| is this
|这次中断是不是强行拿走了CPU

494
00:15:11,580 --> 00:15:13,320
0,270 270,870 870,1350 1350,1590 1590,1740
time interrupt forcibly takes away

495
00:15:13,320 --> 00:15:15,030
0,90 90,780 1080,1530 1530,1650 1650,1710
the CPU| and then the
|然后内核基本上代表该进程进行自愿让位线程切换。

496
00:15:15,030 --> 00:15:17,850
0,630 660,1200 1200,1410 1410,1470 1470,2820
kernel basically does a voluntary

497
00:15:18,090 --> 00:15:19,920
0,750 750,1140 1140,1440 1440,1710 1710,1830
yield thread thread switch on

498
00:15:19,920 --> 00:15:21,760
0,390 390,480 480,630 630,1380
behalf of that process.|
|

499
00:15:22,120 --> 00:15:23,520
0,30 240,840

500
00:15:24,100 --> 00:15:28,390
0,630 930,1440 1860,2640 3450,4110 4110,4290
Now, {} another just piece
现在，这里出现的另一个术语

501
00:15:28,390 --> 00:15:30,370
0,240 600,1440 1440,1560 1560,1800 1800,1980
of terminology that comes up

502
00:15:30,370 --> 00:15:31,780
0,360 360,480 480,720 750,1350 1350,1410
here| is that while the
|当线程运行时，

503
00:15:31,780 --> 00:15:34,120
0,390 390,1110 1410,1830 1860,2100 2100,2340
threads running {},| there's {}
|有必要区分，

504
00:15:34,150 --> 00:15:35,280
0,300 300,570
need to

505
00:15:35,430 --> 00:15:38,040
0,300 300,1200 1560,1920 1980,2490 2490,2610
{} distinguish {},| systems that
|区分当前在某些CPU上实际运行的线程的系统

506
00:15:38,040 --> 00:15:39,480
0,450 450,750 750,1140 1140,1260 1260,1440
distinguish between threads that are

507
00:15:39,510 --> 00:15:41,670
0,750 750,1230 1230,1650 1650,1830 1830,2160
currently actually running on some

508
00:15:41,670 --> 00:15:44,640
0,840 960,1680 1860,2550 2550,2700 2700,2970
CPU| versus threads that would
|与想要运行但当前没有在任何CPU上运行的线程相比，

509
00:15:44,640 --> 00:15:46,620
0,420 420,600 600,1260 1380,1650 1680,1980
like to run, but aren't

510
00:15:46,620 --> 00:15:48,330
0,480 480,810 810,930 930,1110 1110,1710
currently running on any CPU,|
|

511
00:15:48,330 --> 00:15:49,740
0,120 120,360 660,870 870,1290 1290,1410
but {you,know} could run if
但是你知道如果CPU空闲就可以运行

512
00:15:49,740 --> 00:15:51,930
0,60 60,480 480,810 810,1410 1650,2190
a CPU became free| versus
|而不是那些实际上不想运行的线程，

513
00:15:51,930 --> 00:15:53,670
0,480 480,810 930,1290 1290,1530 1530,1740
threads that actually don't want

514
00:15:53,670 --> 00:15:54,960
0,60 60,390 390,630 630,780 780,1290
to run,| because they're waiting
|因为他们在等待IO

515
00:15:54,960 --> 00:15:56,370
0,180 180,630 630,750 750,1230 1260,1410
for IO| or waiting for
|或者在等待什么活动。

516
00:15:56,370 --> 00:15:58,380
0,180 180,780 930,1650
some event {}.|
|

517
00:15:58,600 --> 00:16:00,700
0,210 210,750 750,1350 1500,2010 2010,2100
And unfortunately, this distinction is
不幸的是，这种区别通常被称为国家，

518
00:16:00,700 --> 00:16:03,640
0,240 240,480 480,1080 2280,2580 2580,2940
often called state,| even though
|即使线程的完整状态实际上要比这复杂得多。

519
00:16:04,060 --> 00:16:04,810
0,150 150,390 390,630 630,690 690,750
the full state of the

520
00:16:04,810 --> 00:16:05,680
0,210 210,300 300,540 540,720 720,870
thread is actually much more

521
00:16:05,680 --> 00:16:08,460
0,540 540,870 1110,1860
complicated than that.|
|

522
00:16:09,830 --> 00:16:10,730
0,270 270,480 480,660 660,780 780,900
{} Since this is going
既然这件事要提出来，我只想列出几个州的名单，

523
00:16:10,730 --> 00:16:11,920
0,90 90,270 270,660
to come up,

524
00:16:12,420 --> 00:16:13,590
0,120 120,300 300,570 630,870 870,1170
I just want a list

525
00:16:13,590 --> 00:16:14,400
0,90 90,120 120,360 360,420 420,810
out a couple of states

526
00:16:14,400 --> 00:16:16,160
0,120 120,240 240,360 360,900
that will be seeing,|
|

527
00:16:16,370 --> 00:16:17,630
0,240 240,570 570,630 630,1050 1050,1260
and these are states that
这些是xv6保持的状态，

528
00:16:17,990 --> 00:16:20,090
0,570 570,810 810,1320 1320,1710 1740,2100
{xv6 -} maintains,| there's a
|有一种状态叫做奔跑，

529
00:16:20,090 --> 00:16:21,500
0,240 240,510 510,840 840,1020 1020,1410
state called running,| which means
|这意味着它现在实际上是在某个核心、某个CPU上执行，

530
00:16:21,860 --> 00:16:23,300
0,120 120,360 360,810 810,930 930,1440
it's actually executing on some

531
00:16:23,480 --> 00:16:25,160
0,570 570,720 720,1140 1140,1320 1320,1680
core, some CPU right now,|
|

532
00:16:25,370 --> 00:16:27,940
0,1020 1050,1530 1530,2100
there's {runnable -},
这里有Runnable，这意味着目前没有在任何地方执行，

533
00:16:29,970 --> 00:16:31,290
0,180 180,300 300,480 480,870 870,1320
which means not currently executing

534
00:16:31,290 --> 00:16:33,000
0,360 360,630 960,1290 1290,1350 1350,1710
anywhere,| but just a saved
|但这只是一个被拯救的状态，

535
00:16:33,000 --> 00:16:34,770
0,450 930,1380 1380,1470 1470,1650 1650,1770
state,| but would like to
|但是想尽快跑

536
00:16:34,770 --> 00:16:36,030
0,330 330,450 450,600 600,720 720,1260
run as soon as possible|
|

537
00:16:36,360 --> 00:16:37,350
0,360 360,570 570,630 630,840 840,990
and then it turns out
后来发现有一个州，

538
00:16:37,350 --> 00:16:39,420
0,240 240,780 780,1140 1140,1530 1560,2070
there's a state,| which won't
|今天不会有太多的报道，

539
00:16:39,420 --> 00:16:40,440
0,120 120,240 240,450 450,780 780,1020
come out much today,| but
|但是下周我们会讲到“睡眠”，

540
00:16:40,740 --> 00:16:41,580
0,120 120,240 240,390 390,690 690,840
will come up next week

541
00:16:41,580 --> 00:16:43,590
0,210 210,720 840,1230 1440,1830 1830,2010
called sleeping,| just means the
|仅表示等待某个IO事件的线程

542
00:16:43,590 --> 00:16:44,790
0,270 270,570 570,690 690,870 870,1200
threads waiting for some IO

543
00:16:44,790 --> 00:16:46,440
0,480 690,1020 1110,1380 1380,1560 1560,1650
event| and only wants to
|并且只想在IO事件发生之后运行，

544
00:16:46,440 --> 00:16:47,640
0,150 150,540 540,660 660,930 930,1200
run after the IO event

545
00:16:47,640 --> 00:16:49,140
0,480 660,870 870,1110 1110,1230 1230,1500
occurs,| so today we're mostly
|所以今天我们主要关注的是正在运行的线程和可运行的线程

546
00:16:49,140 --> 00:16:50,670
0,420 420,660 750,1080 1080,1230 1230,1530
concerned with running and runnable

547
00:16:50,670 --> 00:16:52,710
0,750 750,1080 1110,1410 1410,1590 1590,2040
threads| and what this preemptive
|这个抢先开关做了什么，这个计时器中断做了什么，并产生了

548
00:16:52,710 --> 00:16:54,240
0,390 390,900 900,1050 1050,1200 1200,1530
switch does what this timer

549
00:16:54,240 --> 00:16:55,560
0,300 300,810 810,900 900,960 960,1320
interrupt does and the yield|
|

550
00:16:55,560 --> 00:16:57,060
0,90 90,570 600,1050 1050,1140 1140,1500
is basically convert a running
基本上就是将正在运行的线程转换为易受攻击的线程，无论定时器中断的是什么线程。

551
00:16:57,060 --> 00:16:58,860
0,600 630,930 930,1200 1200,1380 1380,1800
thread whatever thread was interrupted

552
00:16:58,860 --> 00:17:00,780
0,120 120,210 210,780 900,1530 1530,1920
by the timer into a

553
00:17:00,810 --> 00:17:02,160
0,510 510,990
vulnerable thread.|

554
00:17:02,160 --> 00:17:03,210
0,180 180,300 300,390 390,600 600,1050
That is a thread that's
这是一条通过屈服的线

555
00:17:03,300 --> 00:17:05,520
0,300 300,930 930,1080 1500,2040 2040,2220
by yielding| or converting that
|或者把那个线程转换成一个现在没有运行的线程，

556
00:17:05,520 --> 00:17:06,330
0,210 210,360 360,420 420,660 660,810
thread into a thread, that's

557
00:17:06,330 --> 00:17:07,380
0,180 180,420 420,600 600,810 810,1050
not running right now,| but
|但实际上想清楚的是，

558
00:17:07,500 --> 00:17:08,910
0,270 270,480 480,750 750,990 990,1410
would actually like to clearly,|
|

559
00:17:08,910 --> 00:17:10,020
0,240 240,360 390,660 660,990 990,1110
because it was running at
因为它在计时器中断时正在运行。

560
00:17:10,020 --> 00:17:11,580
0,120 120,330 330,510 930,1170 1200,1560
the time of a timer

561
00:17:11,580 --> 00:17:12,480
0,480
interrupt.|
|

562
00:17:14,220 --> 00:17:16,890
0,360 360,720 750,1410 1980,2370 2370,2670
Okay so, {} running thread
好的，那么，运行的线程它的程序计数器寄存器实际上在CPU中，

563
00:17:16,890 --> 00:17:19,170
0,360 360,690 690,1230 1230,2010 2010,2280
its program counter registers are

564
00:17:19,200 --> 00:17:21,480
0,450 480,720 720,810 810,1980 2160,2280
actually in the CPU,| you
|你知道，在执行它的CPU的硬件寄存器中，

565
00:17:21,480 --> 00:17:22,680
0,120 120,240 240,330 330,660 660,1200
know in the hardware registers

566
00:17:22,680 --> 00:17:24,150
0,60 60,150 150,720 720,900 900,1470
of the CPU that's executing

567
00:17:24,150 --> 00:17:26,520
0,270 540,990 1080,1590 1590,2010 2010,2370
it,| {} a runnable thread
|可运行线程虽然没有，

568
00:17:26,520 --> 00:17:28,380
0,390 420,660 660,1350
though has no,|
|

569
00:17:28,470 --> 00:17:29,460
0,150 150,540 540,810 810,930 930,990
it's not doesn't have a
它不是没有与之关联的CPU

570
00:17:29,460 --> 00:17:31,770
0,360 360,990 990,1140 1140,1380 2160,2310
CPU associated with it| and
|因此，我们需要为每个可运行的状态进行保存，

571
00:17:31,770 --> 00:17:33,270
0,300 300,420 420,630 630,720 720,1500
therefore we need to save

572
00:17:33,270 --> 00:17:35,190
0,180 180,450 450,870 870,1410 1590,1920
for every runnable state,| we
|我们需要保存任何CPU状态，无论该线程运行时CPU保持什么状态，

573
00:17:35,190 --> 00:17:38,910
0,180 180,270 270,1380 2070,2970 2970,3720
need to save whatever CPU

574
00:17:38,910 --> 00:17:40,860
0,600 600,1020 1050,1380 1380,1470 1470,1950
state, whatever state the CPU

575
00:17:40,860 --> 00:17:43,620
0,210 210,930 1080,1560 1650,2190 2190,2760
was keeping {} when that

576
00:17:44,220 --> 00:17:45,900
0,330 330,690 690,870 870,1320 1500,1680
{} thread was running,| so
|所以我们需要复制CPU的内容，

577
00:17:45,900 --> 00:17:46,560
0,60 60,180 180,270 270,570 570,660
we need to copy the

578
00:17:46,560 --> 00:17:48,060
0,450 450,1170 1170,1320 1320,1380 1380,1500
CPU contents,| you know which
|你知道哪一个不是RAM，而是真正的寄存器，

579
00:17:48,060 --> 00:17:48,990
0,90 90,330 330,660 660,780 780,930
is not RAM, but just

580
00:17:48,990 --> 00:17:50,970
0,540 540,900 1050,1470 1470,1920 1920,1980
registers really,| {} from the
|从CPU传输到内存中的某个地方以保存它们，

581
00:17:50,970 --> 00:17:53,460
0,810 900,1320 1320,1680 1680,2310 2340,2490
CPU into memory somewhere to

582
00:17:53,460 --> 00:17:55,260
0,330 330,720 780,960 960,1200 1620,1800
save them,| when we turn
|当我们将线程从Running转向Runnable时

583
00:17:55,260 --> 00:17:56,100
0,60 60,300 300,480 480,720 720,840
to thread from running to

584
00:17:56,100 --> 00:17:57,480
0,450 540,720 720,1080 1080,1230 1230,1380
runnable| and again this is
|再说一次，这基本上就是我们必须明确保存你们的状态，也就是这个状态。

585
00:17:57,480 --> 00:17:59,310
0,300 450,1260 1260,1440 1440,1740 1740,1830
the basically the state we

586
00:17:59,310 --> 00:18:01,380
0,120 120,570 600,1290 1290,1650 1650,2070
have to explicitly save yours

587
00:18:01,410 --> 00:18:02,820
0,330 330,420 420,960
just the state.|
|

588
00:18:03,030 --> 00:18:04,230
0,150 150,690 690,1050 1050,1110 1110,1200
The executing state of the
CPU的执行状态，即程序计数器和寄存器

589
00:18:04,230 --> 00:18:06,600
0,420 420,630 630,750 750,1020 1980,2370
CPU, which is the program

590
00:18:06,600 --> 00:18:08,180
0,480 480,660 660,990
counter and {}

591
00:18:09,080 --> 00:18:11,240
0,990 1170,1410 1410,1830 1830,1950 1950,2160
registers| and CPU, so these
|和CPU，所以这些都需要保存。

592
00:18:11,240 --> 00:18:12,700
0,150 150,210 210,300 300,930
need to be saved.|
|

593
00:18:13,000 --> 00:18:14,740
0,270 270,600 600,870 1290,1680 1680,1740
Only convert a thread {runnable
仅将线程转换为可运行的，

594
00:18:14,740 --> 00:18:16,870
0,240 780,1170 1170,1350 1350,1830 1830,2130
-},| when some scheduler finally
|当某个调度器最终决定运行可运行线程时，

595
00:18:16,870 --> 00:18:18,910
0,600 600,750 750,1500 1530,1710 1710,2040
decides to run a runnable

596
00:18:18,910 --> 00:18:20,860
0,570 780,1260 1260,1620 1650,1890 1890,1950
thread,| then as part of
|那么作为使该线程再次运行并恢复它的许多步骤的一部分，

597
00:18:20,860 --> 00:18:21,760
0,60 60,240 240,630 630,690 690,900
the many steps in getting

598
00:18:21,760 --> 00:18:23,290
0,150 150,450 450,750 750,1350 1380,1530
that thread going again and

599
00:18:23,290 --> 00:18:25,660
0,390 390,600 810,1500 1920,2250 2250,2370
resuming it,| we're going to
|我们会看到程序计数器，

600
00:18:25,660 --> 00:18:27,010
0,210 210,450 450,690 720,1080 1080,1350
see that the program counter,|
|

601
00:18:27,010 --> 00:18:29,110
0,90 90,750 780,1110 1110,1380 1380,2100
the saved program counter registers
保存的程序计数器寄存器被复制回CPU在CPU上的实际寄存器

602
00:18:29,110 --> 00:18:30,760
0,90 90,540 540,960 960,1320 1320,1650
are copied back into the

603
00:18:31,480 --> 00:18:32,980
0,720 720,1170
{CPU's -}

604
00:18:32,980 --> 00:18:34,300
0,390 390,840 840,900 900,960 960,1320
actual register on the CPU|
|

605
00:18:34,300 --> 00:18:35,350
0,150 150,240 240,600 600,930 930,1050
that the scheduler decides to
调度程序决定在其上运行它。

606
00:18:35,350 --> 00:18:36,480
0,210 210,270 270,480
run it on.|
|

607
00:18:38,910 --> 00:18:40,260
0,630
Alright.
好的。有关这些术语的任何问题。

608
00:18:40,500 --> 00:18:42,960
0,210 210,510 510,720 720,1590 1590,2460
Any questions about these terminology.|
|

609
00:18:49,880 --> 00:18:51,200
0,420 420,510 510,840 870,1110 1110,1320
Alright, I'm gonna, {} now
好的，我现在要说的是一种更面向xv6的观点。

610
00:18:51,200 --> 00:18:52,310
0,210 210,270 270,540 540,810 810,1110
sort of talk about a

611
00:18:52,760 --> 00:18:53,930
0,360 360,420 420,810 810,990 990,1170
sort of more {xv6 -

612
00:18:53,930 --> 00:18:56,210
0,720 750,1230 1230,1470 1470,1560 1560,2280
-} [oriented] view of things.|
|

613
00:18:57,760 --> 00:18:59,230
0,330 330,420 420,600 600,1170 1350,1470
{} I'm gonna draw {}
我要画两幅画，真的，

614
00:18:59,230 --> 00:19:00,880
0,330 330,780 780,1110 1110,1290 1290,1650
two pictures, really,| of {}
|的线程和XV6是一种简化的图片和更详细的图片，

615
00:19:01,180 --> 00:19:02,590
0,690 690,810 810,1080 1080,1320 1320,1410
threads and {xv6 -} are

616
00:19:02,590 --> 00:19:03,820
0,180 180,240 240,720 720,1140 1140,1230
kind of simplified picture and

617
00:19:03,820 --> 00:19:05,800
0,210 210,540 540,1020 1020,1500 1650,1980
a more detailed picture,| so
|所以就像通常用户在这里的东西一样

618
00:19:05,800 --> 00:19:08,440
0,120 120,570 570,720 720,1440 1950,2640
as usually the user {}

619
00:19:08,940 --> 00:19:10,200
0,390 390,540 540,930 930,1050 1050,1260
stuff up here| and the
|还有下面的内核。

620
00:19:10,230 --> 00:19:12,460
0,510 510,750 750,1230
kernel down here.|
|

621
00:19:12,860 --> 00:19:14,040
0,570

622
00:19:14,040 --> 00:19:15,990
0,210 210,390 390,510 510,1080 1290,1950
We might be running multiple
我们可能在用户级别运行多个进程，

623
00:19:15,990 --> 00:19:18,450
0,840 1050,1290 1290,1560 1560,1950 1950,2460
processes at user level,| maybe
|也许您知道C编译器、ls和shell，

624
00:19:18,630 --> 00:19:20,610
0,210 210,300 300,570 570,960 960,1980
you know the C compiler

625
00:19:20,610 --> 00:19:23,160
0,390 510,1440 1440,1530 1530,1620 1620,2550
and ls and a shell,|
|

626
00:19:23,520 --> 00:19:25,140
0,690 930,1290 1290,1440 1440,1530 1530,1620
{} they may or may
他们可能想也可能不想同时跑步，

627
00:19:25,140 --> 00:19:26,430
0,270 270,600 690,930 930,1170 1170,1290
not be all wanting to

628
00:19:26,430 --> 00:19:27,420
0,120 120,210 210,270 270,510 510,990
run at the same time,|
|

629
00:19:28,260 --> 00:19:31,050
0,360 690,1290 1290,1620 1620,2100 2490,2790
{} at user level, each
在用户级别，这些进程中的每个进程都具有

630
00:19:31,050 --> 00:19:33,400
0,120 120,720 750,1890
of these processes

631
00:19:33,490 --> 00:19:34,780
0,750
{}

632
00:19:34,870 --> 00:19:37,800
0,1140 1650,2310
has {},|
|

633
00:19:38,400 --> 00:19:39,570
0,180 180,240 240,330 330,510 510,1170
you know it has memory,|
你知道它有记忆，|

634
00:19:39,690 --> 00:19:42,360
0,600 720,1020 1020,1200 1200,2220 2250,2670
{} and of particular interest
我们特别感兴趣的是，

635
00:19:42,360 --> 00:19:43,380
0,90 90,480 510,810 810,870 870,1020
to us,| each of these
|这些进程中的每一个都具有用户堆栈，

636
00:19:43,380 --> 00:19:45,510
0,480 480,690 690,840 840,1290 1290,2130
processes has a user stack,|

637
00:19:46,840 --> 00:19:48,880
0,420 450,870 900,1380 1380,1530 1530,2040
{} and while it's running
当它运行时，它在RISC-V硬件中有寄存器，

638
00:19:48,880 --> 00:19:51,310
0,90 90,300 300,1350 2070,2340 2340,2430
it has registers in the

639
00:19:51,310 --> 00:19:53,650
0,270 270,810 810,1350 1350,1740 1950,2340
{RISC-V -} hardware,| so PC
|所以PC PLUS寄存器。

640
00:19:53,650 --> 00:19:55,120
0,240 240,960
plus registers.|
|

641
00:19:55,590 --> 00:19:57,900
0,330 330,540 750,1500 1500,1860 1860,2310
Alright, so while programs running
好的，当程序运行时，你知道本质上有一个在用户级别运行的控制线程

642
00:19:57,900 --> 00:19:59,430
0,120 120,270 270,840 870,1470 1470,1530
you know there's essentially a

643
00:19:59,430 --> 00:20:01,140
0,270 270,330 330,750 750,1230 1260,1710
thread of control that's running

644
00:20:01,140 --> 00:20:03,420
0,180 180,420 420,780 1620,1950 1980,2280
at user level| and the
|我要说的是，

645
00:20:03,420 --> 00:20:04,020
0,120 120,180 180,300 300,360 360,600
way I'm going to talk

646
00:20:04,020 --> 00:20:05,370
0,240 240,420 420,690 690,930 930,1350
about it is,| as if
|好像存在由用户堆栈用户存储器用户程序计数器用户寄存器组成的用户线程，

647
00:20:05,400 --> 00:20:07,830
0,570 900,1110 1110,1230 1230,1680 1680,2430
{} there's a user thread

648
00:20:07,860 --> 00:20:10,320
0,480 1170,1650 1650,1770 1770,2100 2160,2460
that consists of the user

649
00:20:10,320 --> 00:20:12,060
0,330 330,570 570,1050 1050,1410 1410,1740
stack user memory user program

650
00:20:12,060 --> 00:20:14,040
0,300 300,540 540,1230 1470,1860 1860,1980
counter user registers,| if the
|如果程序使系统调用者中断

651
00:20:14,040 --> 00:20:15,360
0,300 300,480 480,540 540,870 870,1320
program makes a system callers

652
00:20:15,360 --> 00:20:17,670
0,720 720,1050 1530,2100 2100,2250 2250,2310
interrupted| and goes into the
|然后进入内核，

653
00:20:17,670 --> 00:20:18,660
0,570
kernel,|
|

654
00:20:19,020 --> 00:20:20,790
0,480 780,1110 1110,1230 1230,1410 1410,1770
{} then this stuff saved
然后这些东西被保存在这个程序的陷阱框中

655
00:20:20,790 --> 00:20:22,470
0,210 210,360 660,900 900,1320 1320,1680
away in this program's {trapframe

656
00:20:22,470 --> 00:20:26,460
0,540 1170,1590 1680,2520 2610,3570 3570,3990
-}| and a kernel, the
|和内核，则该程序的内核线程被激活

657
00:20:26,460 --> 00:20:29,670
0,450 450,990 990,1590 2490,2850 2850,3210
kernel thread for this program

658
00:20:29,670 --> 00:20:31,920
0,120 120,900 990,1290 1290,1680 1740,2250
is activated| and so now
|现在，这是保存的用户内容的陷阱帧

659
00:20:31,920 --> 00:20:33,210
0,180 180,300 300,630 690,1080 1080,1290
this is the {trapframe -}

660
00:20:33,210 --> 00:20:35,970
0,210 210,960 1860,2250 2250,2550 2550,2760
hold saved user stuff| after
|在我们保存了用户和平程序计数器注册的方式之后，

661
00:20:35,970 --> 00:20:36,630
0,90 90,390 390,450 450,570 570,660
we saved a way the

662
00:20:36,630 --> 00:20:38,700
0,330 330,660 660,960 960,1290 1290,2070
user peace program counter registers,|
|

663
00:20:38,850 --> 00:20:41,040
0,870 930,1050 1050,1530 1530,1650 1650,2190
then we switch the CPU
然后，我们将CPU切换到使用内核堆栈。

664
00:20:41,040 --> 00:20:42,510
0,150 150,420 420,480 480,840 840,1470
to using the kernel stack.|
|

665
00:20:43,290 --> 00:20:44,480
0,660

666
00:20:45,520 --> 00:20:46,510
0,330 390,660 660,720 720,840 840,990
And you know we don't
你知道我们不需要恢复登记表，

667
00:20:46,510 --> 00:20:48,070
0,120 120,210 210,570 570,1080 1080,1560
need to restore registers,| because,
|因为，通过进程的内核线程并没有真正运行，

668
00:20:48,550 --> 00:20:50,960
0,540 960,1320 1320,1740
{} through the

669
00:20:50,960 --> 00:20:52,580
0,150 150,720 720,1050 1050,1200 1200,1620
the kernel thread for process

670
00:20:52,580 --> 00:20:54,170
0,390 480,870 870,1320 1320,1410 1410,1590
isn't really running,| it has
|当用户线程正在运行时，它没有实际的保存状态

671
00:20:54,170 --> 00:20:56,720
0,180 180,360 360,690 690,1170 2100,2550
no real save state when

672
00:20:56,720 --> 00:20:57,880
0,60 60,660
the user

673
00:20:57,880 --> 00:20:59,560
0,420 420,540 540,1080 1110,1290 1290,1680
thread is running| {} instead
|取而代之的是，它的内核线程在其堆栈上处于某种激活状态

674
00:20:59,560 --> 00:21:00,700
0,150 150,330 330,390 390,660 750,1140
it's sort of the kernel

675
00:21:00,700 --> 00:21:01,990
0,180 180,270 270,450 450,540 540,1290
thread is kind of activated

676
00:21:01,990 --> 00:21:03,130
0,150 150,300 300,960 990,1050 1050,1140
on its stack| for the
|第一次在蹦床和一个用户陷阱代码。

677
00:21:03,130 --> 00:21:05,590
0,270 270,600 600,1170 1350,1770 2190,2460
first time in {} in

678
00:21:05,590 --> 00:21:07,960
0,180 210,900 900,1170 1170,1620 1860,2370
the trampoline and a user

679
00:21:07,960 --> 00:21:09,280
0,330 330,840
trap code.|
|

680
00:21:09,770 --> 00:21:11,160
0,450

681
00:21:11,940 --> 00:21:12,960
0,330 330,480 480,630 630,690 690,1020
{} And then the kernel
然后内核运行一段时间，

682
00:21:12,960 --> 00:21:14,250
0,270 270,420 420,480 480,750 750,1290
runs for a while,| maybe
|也许运行系统调用或中断处理程序，不管它是什么

683
00:21:14,310 --> 00:21:15,540
0,360 360,420 420,750 750,1110 1110,1230
running a system call or

684
00:21:15,540 --> 00:21:17,250
0,390 390,780 780,1170 1170,1440 1440,1710
interrupt handler whatever it maybe|
|

685
00:21:18,150 --> 00:21:20,520
0,690 720,1830 1860,2130 2130,2280 2280,2370
and sometimes {} it is
有时，这是一个称为“特殊”的系统，它只是简单地从这一点返回到相同的过程

686
00:21:20,520 --> 00:21:21,630
0,60 60,330 330,540 540,960 960,1110
a system called particular will

687
00:21:21,630 --> 00:21:23,070
0,210 210,510 510,1110 1110,1290 1290,1440
just simply return from this

688
00:21:23,070 --> 00:21:24,630
0,330 330,660 660,750 750,1080 1230,1560
point back to the same

689
00:21:24,630 --> 00:21:26,670
0,510 510,810 1350,1740 1740,1800 1800,2040
process| and return to user
|并且返回到用户空间将恢复该程序的程序计数器寄存器，

690
00:21:26,670 --> 00:21:29,340
0,270 270,450 450,1290 1440,2010 2040,2670
space will restore this program's

691
00:21:29,340 --> 00:21:31,380
0,300 300,600 600,1350 1380,1920 1920,2040
program counter registers,| but it
|但也可能不是出于这样或那样的原因简单地返回，

692
00:21:31,380 --> 00:21:32,580
0,180 180,480 480,630 630,780 780,1200
could also be that instead

693
00:21:32,580 --> 00:21:34,740
0,240 720,1080 1080,1740
of simply returning

694
00:21:34,890 --> 00:21:35,850
0,270 270,390 390,570 570,840 840,960
{} for one reason or

695
00:21:35,850 --> 00:21:36,690
0,330 330,480 480,690 690,750 750,840
another,| maybe because it was
|可能是因为这是个定时器中断，

696
00:21:36,690 --> 00:21:38,130
0,60 60,480 480,900 1020,1260 1260,1440
a timer interrupt,| we're actually
|我们实际上要切换到另一个过程

697
00:21:38,130 --> 00:21:39,330
0,120 120,180 180,780 780,930 930,1200
going to switch to another

698
00:21:39,330 --> 00:21:41,340
0,570 570,900 990,1290 1290,1560 1560,2010
process| and the very high-level
|最高层次的观点是，

699
00:21:41,340 --> 00:21:42,270
0,210 210,300 300,570 570,690 690,930
view of that is that|
|

700
00:21:43,110 --> 00:21:45,750
0,300 300,840 960,1380 1380,1830 1830,2640
if the xv6 scheduler decides
如果xv6调度器决定从该进程切换到不同进程，

701
00:21:45,810 --> 00:21:47,760
0,420 480,870 870,1050 1050,1230 1230,1950
{} switch from this process

702
00:21:47,790 --> 00:21:49,920
0,90 90,150 150,390 390,1140 1800,2130
to a different process,| what
|真正发生的第一件事是什么

703
00:21:49,920 --> 00:21:50,850
0,120 120,390 390,480 480,660 660,930
the first thing that really

704
00:21:50,850 --> 00:21:52,290
0,480 480,630 630,900 960,1320 1320,1440
happens| is that we're going
|我们要切换内核线程

705
00:21:52,290 --> 00:21:54,810
0,90 90,690 690,1260 1260,2250 2280,2520
to switch kernel threads| from
|从这个进程的内核线程到另一个进程的内核线程，

706
00:21:54,810 --> 00:21:56,640
0,270 270,810 810,1110 1110,1590 1620,1830
this processe's kernel thread to

707
00:21:56,640 --> 00:21:58,260
0,120 120,330 330,840 840,1140 1140,1620
the other process's kernel thread,|
|

708
00:21:58,350 --> 00:21:59,520
0,240 240,360 360,480 480,660 660,1170
and then the other processes
然后其他进程内核线程将返回到用户空间，

709
00:21:59,520 --> 00:22:00,780
0,270 270,600 600,720 720,1020 1020,1260
kernel thread will turn back

710
00:22:00,780 --> 00:22:02,550
0,90 90,390 390,750 750,1080 1230,1770
to user space,| so supposing
|所以假设C编译器[C]需要读取磁盘

711
00:22:02,550 --> 00:22:03,630
0,180 180,300 300,480 480,930 930,1080
that the C compiler [C]

712
00:22:03,630 --> 00:22:04,950
0,240 240,360 360,540 540,630 630,1320
needs to read the disk|
|

713
00:22:05,070 --> 00:22:06,180
0,600 600,780 780,870 870,990 990,1110
{} and so it's going
因此它将产生CPU

714
00:22:06,180 --> 00:22:08,160
0,60 60,330 330,390 390,1200 1680,1980
to yield the CPU| while
在休眠以等待磁盘完成时，

715
00:22:08,160 --> 00:22:09,270
0,630 630,720 720,930 930,1020 1020,1110
sleeping to wait for the

716
00:22:09,270 --> 00:22:11,310
0,420 420,480 480,960 1140,1530 1530,2040
disk to complete,| maybe ls
|也许ls想要执行并且处于Runnable状态，xv6调度器可能做的是，

717
00:22:11,310 --> 00:22:12,600
0,240 240,330 330,930 930,1050 1050,1290
wants to execute and is

718
00:22:12,600 --> 00:22:14,240
0,180 180,570 570,1110
in runnable state,

719
00:22:14,610 --> 00:22:16,260
0,360 360,450 450,930 930,1320 1320,1650
what the xv6 scheduler, maybe

720
00:22:16,320 --> 00:22:17,850
0,240 240,540 540,690 690,930 1080,1530
they do is that,| well,
|嗯，如果ls处于可运行状态，

721
00:22:18,180 --> 00:22:19,470
0,180 180,510 540,990 990,1140 1140,1290
{} if ls is in

722
00:22:19,470 --> 00:22:21,060
0,360 360,810 810,960 960,1290 1290,1590
runnable state,| that means it
|这意味着它在某个地方停了下来。

723
00:22:21,060 --> 00:22:22,380
0,390 390,630 630,1020 1020,1140 1140,1320
left off somewhere| and its
|可能通过定时器中断保存了它的状态

724
00:22:22,380 --> 00:22:24,510
0,630 690,840 840,1200 1200,1680 1680,2130
state was saved away possibly

725
00:22:24,510 --> 00:22:26,100
0,180 180,240 240,720 720,1230 1410,1590
by a timer interrupt| and
|因此LS实际上将具有具有用户寄存器和其自己的内核堆栈的保存的陷阱帧，

726
00:22:26,100 --> 00:22:27,480
0,210 210,870 870,990 990,1260 1260,1380
so ls will actually have

727
00:22:27,480 --> 00:22:29,010
0,90 90,780 810,1170 1170,1410 1410,1530
a saved {trapframe -} with

728
00:22:29,010 --> 00:22:31,560
0,270 270,1410 1410,1620 1620,1770 1770,2550
user registers and its own

729
00:22:31,650 --> 00:22:34,140
0,510 510,1230 1500,1980 2040,2250 2250,2490
kernel stack,| {} and as
|结果是，与内核线程相关联的一组内核寄存器[种子]

730
00:22:34,140 --> 00:22:35,130
0,60 60,360 360,540 540,600 600,990
it turns out a [seed]

731
00:22:35,130 --> 00:22:36,620
0,360 360,630 630,1050
set of {}

732
00:22:37,820 --> 00:22:39,860
0,300 330,900 900,1470 1470,1950 1950,2040
{} kernel registers associated with

733
00:22:39,860 --> 00:22:41,750
0,90 90,510 510,1050 1080,1710 1740,1890
the kernel thread| which is
|这将被称为上下文，

734
00:22:41,750 --> 00:22:42,440
0,120 120,180 180,330 330,600 600,690
going to be called the

735
00:22:42,440 --> 00:22:45,380
0,840 1080,1500 1740,2070 2100,2550 2550,2940
context,| so if xv6 switches
|因此，如果xv6从编译器内核线程切换到ls的内核线程，

736
00:22:45,380 --> 00:22:47,330
0,150 150,210 210,960 990,1410 1410,1950
from the compiler kernel thread

737
00:22:47,450 --> 00:22:48,980
0,150 150,510 510,660 660,960 960,1530
to {ls's -} kernel thread,|
|

738
00:22:49,500 --> 00:22:51,660
0,600 840,1200 1200,1440 1440,1560 1560,2160
{} {xv6 -} will save
xv6将保存上下文中的内核寄存器

739
00:22:51,660 --> 00:22:54,090
0,270 270,450 450,1050 1050,2040 2130,2430
away the kernel registers in

740
00:22:54,090 --> 00:22:56,610
0,60 60,630 630,1050 1110,1560 2040,2520
a context| with a [seat]
|利用[席位]编译器内核线程切换到LS线程，

741
00:22:56,610 --> 00:22:59,580
0,270 300,900 900,1170 1170,1530
the compilers kernel thread

742
00:22:59,760 --> 00:23:01,500
0,540 540,630 630,780 780,1110 1110,1740
switch to the ls thread,|
|

743
00:23:02,730 --> 00:23:05,370
0,1080 1350,1800 1800,1980 1980,2040 2040,2640
complex scheme which I'll describe
复杂的方案，我稍后会描述，

744
00:23:05,400 --> 00:23:07,050
0,270 270,450 450,600 600,1050 1350,1650
a little bit later,| we'll
|我们将从先前保存的上下文恢复ls is，从上一次停止的ls恢复内核线程寄存器，

745
00:23:07,050 --> 00:23:10,180
0,870 1680,2130 2130,2670
restore ls is,

746
00:23:10,180 --> 00:23:12,220
0,390 390,720 720,1380 1380,1560 1560,2040
kernel thread registers from the

747
00:23:12,310 --> 00:23:14,080
0,630 630,870 870,1410 1410,1560 1560,1770
previously save context from one

748
00:23:14,080 --> 00:23:16,330
0,570 570,900 900,1200 1200,1590 1920,2250
ls last left off,| maybe
|也许ls会完成被称为正在执行的任何系统，

749
00:23:16,330 --> 00:23:17,800
0,330 330,420 420,780 780,1080 1080,1470
ls will finish whatever system

750
00:23:17,800 --> 00:23:19,840
0,390 390,840 840,1710 1710,1830 1830,2040
called was executing,| you know
|你知道在ls的内核线程堆栈上，

751
00:23:20,170 --> 00:23:23,080
0,840 1110,1440 1560,2010 2010,2430 2520,2910
on the {ls's -} kernel

752
00:23:23,080 --> 00:23:25,240
0,270 270,720 1080,1650 1650,1800 1800,2160
thread stack,| and then return
|然后返回到调用的LS系统，

753
00:23:25,240 --> 00:23:26,620
0,180 180,270 270,750 750,1050 1050,1380
back to ls system called,|
|

754
00:23:26,620 --> 00:23:27,850
0,150 150,270 270,690 690,840 840,1230
on the way to return
在返回用户空间的路上

755
00:23:27,850 --> 00:23:28,690
0,90 90,330 330,630 630,720 720,840
to user space| that will
|，它将为ls恢复这些以前保存的用户寄存器。

756
00:23:28,690 --> 00:23:30,980
0,420 420,630 630,1200 1200,1920
restore these previously saved

757
00:23:30,980 --> 00:23:33,650
0,450 450,990 990,1230 1230,1830 2460,2670
user registers for ls| and
|然后继续执行ls。

758
00:23:33,650 --> 00:23:35,990
0,210 210,810 900,1410 1410,2010 2040,2340
then resume executing ls.| So,
|所以，这里有一堆我们将要讨论的细节，

759
00:23:37,070 --> 00:23:38,930
0,540 720,1230 1230,1410 1410,1500 1500,1860
{} there's bunch of details

760
00:23:38,930 --> 00:23:39,980
0,150 150,330 330,420 420,630 630,1050
here which we'll talk about,|
|

761
00:23:39,980 --> 00:23:41,900
0,300 450,870 1110,1380 1380,1470 1470,1920
but {} maybe the main
但也许这里的重点是

762
00:23:41,900 --> 00:23:43,550
0,330 330,600 600,690 690,900 930,1650
point here is that| whenever
|每当在xv6中看到直接用户到用户上下文切换时，

763
00:23:43,550 --> 00:23:45,410
0,90 90,330 330,450 450,1140 1170,1860
in {xv6 - -} see

764
00:23:45,410 --> 00:23:47,390
0,510 510,840 840,900 900,1470 1500,1980
direct user to user context

765
00:23:47,390 --> 00:23:49,220
0,540 540,690 690,780 780,1350 1620,1830
switches,| when we're switching from
|当我们从一个过程切换到另一个过程时，

766
00:23:49,220 --> 00:23:51,140
0,300 300,720 720,780 780,1110 1110,1920
one process to another,| always
|始终采用xv6从执行一个进程切换到另一个进程的策略

767
00:23:51,350 --> 00:23:53,380
0,600 840,1170 1170,1410 1410,1560
{} the sort of

768
00:23:53,830 --> 00:23:55,600
0,270 270,930 930,1020 1020,1260 1260,1770
{} strategy by which xv6

769
00:23:55,600 --> 00:23:57,430
0,420 420,540 540,960 960,1350 1350,1830
switches from executing one process

770
00:23:57,430 --> 00:23:59,410
0,120 120,390 390,1050 1260,1680 1740,1980
to another process| is you
|您是否跳入内核，保存进程状态，运行此进程的内核线程

771
00:23:59,410 --> 00:24:00,670
0,210 210,330 330,390 390,810 810,1260
jump in the kernel saves

772
00:24:00,670 --> 00:24:02,470
0,150 150,630 630,900 900,1320 1320,1800
the process state run this

773
00:24:02,500 --> 00:24:04,570
0,660 660,960 960,1410 1410,1950 1950,2070
process's kernel thread| switch to
|切换到内核线程另一个挂起自身的进程

774
00:24:04,570 --> 00:24:06,550
0,120 150,450 450,810 1140,1560 1560,1980
the kernel thread another process

775
00:24:06,550 --> 00:24:08,140
0,150 150,690 690,1170 1170,1260 1260,1590
that suspended itself| and then
|然后返回并恢复用户注册，

776
00:24:08,290 --> 00:24:10,000
0,600 600,690 690,1050 1050,1290 1290,1710
return and restore user register,|
|

777
00:24:10,000 --> 00:24:11,410
0,180 180,300 300,660 660,840 840,1410
so it's always this indirect
所以一直都是这种间接的策略，

778
00:24:11,410 --> 00:24:13,450
0,690 1020,1290 1290,1470 1470,1680 1680,2040
strategy,| actually even more indirect
|实际上比这更间接的是，

779
00:24:13,450 --> 00:24:15,790
0,150 150,540 810,1200 1200,1740 1740,2340
than this to threads swhich,|
|

780
00:24:15,910 --> 00:24:16,810
0,150 150,240 240,420 420,780 780,900
where the net effect is
其中净效果是从一个用户进程切换到另一个用户进程。

781
00:24:16,810 --> 00:24:18,130
0,120 120,360 360,510 510,1020 1020,1320
to switch from one user

782
00:24:18,130 --> 00:24:19,120
0,660
process

783
00:24:19,120 --> 00:24:20,880
0,120 120,360 360,600 600,1260
to another user process.|
|

784
00:24:23,310 --> 00:24:25,320
0,510 570,990 990,1170 1170,1290 1290,2010
{} Question about this diagram
关于这张图有什么问题吗？

785
00:24:25,800 --> 00:24:27,140
0,210 210,600
or anything?|
|

786
00:24:29,260 --> 00:24:31,540
0,750 750,990 990,1710 1710,1890 1890,2280
Switched the scheduler, that happens
切换了调度程序，这发生在这两个之间，对。

787
00:24:31,540 --> 00:24:32,890
0,120 120,510 510,810 810,990 990,1350
in between those two, right.|
|

788
00:24:33,220 --> 00:24:35,830
0,840 900,1200 1200,1710 2250,2550 2550,2610
Yep, all right, let me
是的，好的，让我来谈谈日程安排，

789
00:24:35,830 --> 00:24:36,850
0,180 180,330 330,420 420,870 870,1020
talk about the scheduler,| so
因此，实际情况实际上要比这复杂得多。

790
00:24:37,120 --> 00:24:38,770
0,330 330,690 690,990 990,1080 1080,1650
the real picture is actually

791
00:24:38,800 --> 00:24:41,290
0,600 630,1410 1410,1590 1590,2130 2130,2490
a significantly more complex than

792
00:24:41,980 --> 00:24:42,980
0,420
that.|
|

793
00:24:43,070 --> 00:24:44,390
0,210 210,270 270,360 360,870 870,1320
This is a [medium] or,|
这是[中号]或者，|

794
00:24:44,390 --> 00:24:45,440
0,450

795
00:24:46,690 --> 00:24:47,890
0,210 210,300 300,480 480,720 720,1200
gonna be more full diagram,|
会有更完整的图表，|

796
00:24:47,890 --> 00:24:48,700
0,120 120,210 210,300 300,390 390,810
let's say we have process
假设我们有进程一，

797
00:24:48,700 --> 00:24:50,020
0,630
one,|
|

798
00:24:51,060 --> 00:24:53,340
0,300 300,390 390,1110 1110,1260 1410,2280
which is executing {} process
它正在执行可运行但当前未运行的进程2，

799
00:24:53,340 --> 00:24:56,250
0,450 450,1140 1230,1680 2130,2790 2790,2910
two which {} {is,runnable}, but

800
00:24:56,250 --> 00:24:58,440
0,150 150,510 510,900 1770,2100 2100,2190
not currently running,| now the
|现在是额外的一层细节，

801
00:24:58,440 --> 00:24:59,670
0,390 390,630 630,690 690,1110 1110,1230
additional layer of details,| we
|我们实际上有多个内核，

802
00:24:59,670 --> 00:25:01,770
0,180 180,300 300,690 690,1620 1650,2100
actually have multiple cores {},|
|

803
00:25:01,980 --> 00:25:03,270
0,750 750,900 900,1080 1080,1200 1200,1290
xv6 let's say we have
假设我们有两个内核，

804
00:25:03,270 --> 00:25:04,800
0,210 210,780 780,1110 1170,1320 1320,1530
two cores,| so that means
|所以这意味着在硬件层面上，

805
00:25:04,800 --> 00:25:06,960
0,390 480,660 660,720 720,1530 1530,2160
that at the hardware level,|
|

806
00:25:07,680 --> 00:25:10,800
0,780 960,1290 1290,1770 1800,2490 2490,3120
{} we have CPU zero
我们有零CPU，它是核心之一

807
00:25:10,800 --> 00:25:11,340
0,120 120,240 240,390 390,450 450,540
which is one of the

808
00:25:11,340 --> 00:25:14,370
0,1020 1320,1980 2040,2460 2460,2610 2610,3030
cores| and let's say CPU
|比方说CPU 1。

809
00:25:14,370 --> 00:25:15,340
0,480
one.|
|

810
00:25:20,030 --> 00:25:21,380
0,180 180,240 240,450 450,810 810,1350
And the more full story
更完整的故事是关于我们如何从执行用户空间到，

811
00:25:21,380 --> 00:25:23,030
0,330 330,600 600,720 720,1020 1020,1650
about how we get from

812
00:25:23,210 --> 00:25:25,120
0,390 390,1320
{} executing

813
00:25:25,150 --> 00:25:27,520
0,270 270,660 660,1470 1500,2190 2220,2370
{} user space to,| in
|在用户空间中执行的另一个可运行但尚未运行的进程中的一个进程中，

814
00:25:27,520 --> 00:25:29,470
0,240 240,1170 1170,1680 1680,1770 1770,1950
one process executing in user

815
00:25:29,470 --> 00:25:31,450
0,450 450,690 690,1230 1440,1860 1860,1980
space in another runnable but

816
00:25:31,450 --> 00:25:33,460
0,210 210,420 420,660 660,1230 1440,2010
not yet running process {},|
|

817
00:25:33,880 --> 00:25:34,990
0,330 330,570 570,780 780,870 870,1110
the first part is about
第一部分与我所说的大致相同。

818
00:25:34,990 --> 00:25:36,430
0,60 60,510 510,1020 1050,1170 1170,1440
the same as I talked

819
00:25:36,430 --> 00:25:37,810
0,480 630,900 900,1050 1050,1290 1290,1380
about| and may say a
|并且可以说定时器中断强制将控制从用户进程转移到内核，

820
00:25:37,810 --> 00:25:40,220
0,450 450,1050 1050,1980
timer interrupt forces

821
00:25:40,390 --> 00:25:42,070
0,300 300,720 720,1230 1230,1440 1440,1680
{} transfer control from the

822
00:25:42,100 --> 00:25:43,870
0,270 270,870 870,930 930,1440 1500,1770
user process {into,the} kernel,| the
|蹦床代码为进程一保存用户注册陷印框，

823
00:25:43,870 --> 00:25:46,900
0,570 570,990 2220,2700 2700,2790 2790,3030
trampoline code saves the user

824
00:25:46,900 --> 00:25:48,490
0,630 630,780 780,1140 1140,1470 1470,1590
registers the {trapframe -} for

825
00:25:48,490 --> 00:25:51,320
0,420 420,990
process one,|
|

826
00:25:51,530 --> 00:25:54,180
0,180 180,330 330,1350 1470,2100
and then executes {}
然后执行用户陷阱

827
00:25:54,180 --> 00:25:55,740
0,270 270,360 360,720 720,1140 1170,1560
{user -} trap| which figures
|它知道该怎么处理这个陷阱

828
00:25:55,740 --> 00:25:56,220
0,90 90,180 180,240 240,360 360,480
out what to do with

829
00:25:56,220 --> 00:25:57,720
0,120 120,600 600,720 720,1410 1410,1500
this trap| or interrupt you
|或者中断你知道的系统调用，

830
00:25:57,720 --> 00:25:59,100
0,120 120,450 450,990 1020,1260 1260,1380
know system call,| let's say
|我们说作为一个，

831
00:25:59,100 --> 00:26:00,810
0,210 450,840 990,1260 1260,1650 1650,1710
as a,| so for a
|所以有一小段时间，我们在进程1的内核堆栈上执行普通的内核C代码。

832
00:26:00,810 --> 00:26:03,060
0,150 150,390 390,510 510,1290 1530,2250
little while we're executing ordinary

833
00:26:03,060 --> 00:26:05,730
0,360 360,660 660,1380 1500,2580 2580,2670
kernel C code on the

834
00:26:05,730 --> 00:26:07,830
0,420 420,900 900,1020 1020,1500 1500,2100
kernel stack of process one.|
|

835
00:26:10,240 --> 00:26:11,710
0,390 390,570 570,930 930,1350 1350,1470
Let's say process one the
假设进程1内核代码进程一旦决定要让出CPU，

836
00:26:11,710 --> 00:26:13,300
0,270 270,570 570,960 960,1170 1170,1590
kernel code process once decides

837
00:26:13,300 --> 00:26:14,410
0,120 120,390 390,480 480,1020 1020,1110
it wants to yield the

838
00:26:14,410 --> 00:26:16,870
0,840 1710,2070 2070,2220 2220,2280 2280,2460
CPU,| it has a bunch
|它有一堆东西，可以看到细节，

839
00:26:16,870 --> 00:26:17,770
0,90 90,450 450,600 600,720 720,900
of things which will see

840
00:26:17,770 --> 00:26:19,870
0,60 60,480 480,810 840,1290 1740,2100
the details of,| {} that
|最终调用这个例程开关，这是这个故事中的一个中心例程，

841
00:26:19,870 --> 00:26:20,620
0,150 150,300 300,360 360,450 450,750
end up in a call

842
00:26:20,620 --> 00:26:22,700
0,120 120,450 450,840 840,1650
to this routine switch,

843
00:26:22,730 --> 00:26:24,350
0,330 330,480 480,870 1440,1560 1560,1620
just sort of one of

844
00:26:24,350 --> 00:26:25,550
0,60 60,510 510,990 990,1080 1080,1200
the central routines in this

845
00:26:25,550 --> 00:26:28,540
0,510 600,1110 1110,1590 1590,2430
story,| switch saves away
|Switch保存为在上下文1中运行的内核线程注册的上下文，

846
00:26:28,700 --> 00:26:31,250
0,270 270,480 480,1200 1200,1440 1440,2550
{} this context that registers

847
00:26:31,280 --> 00:26:32,630
0,270 270,420 510,960 960,1170 1170,1350
for the kernel thread that's

848
00:26:32,630 --> 00:26:33,830
0,270 270,390 390,930 930,1110 1110,1200
running in context one,| so
|所以有两组用户注册的寄存器，

849
00:26:33,830 --> 00:26:35,450
0,300 330,720 720,960 960,1050 1050,1620
there's two sets of registers

850
00:26:35,450 --> 00:26:36,980
0,90 90,330 330,1170 1170,1230 1230,1530
the user registers,| the {trapframe
|陷阱帧时，内核线程在上下文中注册。

851
00:26:36,980 --> 00:26:38,020
0,480
-},

852
00:26:38,020 --> 00:26:39,430
0,150 150,420 420,690 690,1260 1260,1410
the kernel thread registers in

853
00:26:39,430 --> 00:26:40,960
0,180 210,1020
the context.|
|

854
00:26:41,510 --> 00:26:43,880
0,330 900,1440 1440,1710 1710,2070 2070,2370
{} Switch doesn't actually switch
Switch实际上不会将一个内容从一个线程切换到另一个线程，

855
00:26:43,880 --> 00:26:46,130
0,480 480,990 1050,1680 1680,2100 2100,2250
switches from one content from

856
00:26:46,130 --> 00:26:47,450
0,240 240,540 540,690 690,1110 1110,1320
one thread to another,| but
|但实际上xv6的设计方式，

857
00:26:47,450 --> 00:26:49,820
0,180 180,840 1080,1350 1350,1830 1830,2370
in fact the way xv6

858
00:26:49,820 --> 00:26:52,190
0,90 90,780 930,1200 1230,1740 1740,2370
is designed,| the only place
|用户线程，抱歉，在CPU上运行的内核线程可以切换到的唯一位置

859
00:26:52,190 --> 00:26:55,250
0,240 240,630 1470,1950 1950,2700 2730,3060
that a user thread, sorry

860
00:26:55,250 --> 00:26:56,240
0,60 60,390 390,690 690,900 900,990
the kernel thread running on

861
00:26:56,240 --> 00:26:57,560
0,60 60,540 540,690 690,1020 1020,1320
a CPU can switch to|
|

862
00:26:57,680 --> 00:26:59,210
0,240 240,450 450,690 690,780 780,1530
is what's called the scheduler
就是所谓的那个CPU的调度程序线程。

863
00:26:59,210 --> 00:27:01,240
0,390 390,510 510,750 750,1500
thread for that CPU.|
|

864
00:27:01,240 --> 00:27:02,320
0,510

865
00:27:02,910 --> 00:27:04,110
0,240 240,330 330,540 540,720 720,1200
So we can't even switch
所以我们甚至不能直接切换到另一个过程，

866
00:27:04,110 --> 00:27:06,060
0,390 390,510 510,750 750,1440 1680,1950
directly to another process,| can
|只能切换到调度程序线程，

867
00:27:06,060 --> 00:27:07,440
0,120 120,540 540,690 690,900 900,1380
only switch to the scheduler

868
00:27:07,440 --> 00:27:09,150
0,240 240,390 390,600 600,990 1020,1710
thread,| so there's a {},|
|所以有一个，|

869
00:27:10,360 --> 00:27:14,500
0,150 150,870 870,1380 1380,2310 2790,4140
the complete thread [apparatus] dedicated
专用于CPU 0的调度器的完整线程[装置]，

870
00:27:14,500 --> 00:27:16,030
0,90 90,180 180,840 840,990 990,1530
to the scheduler for CPU

871
00:27:16,030 --> 00:27:17,170
0,480 510,720 720,840 840,1050 1050,1140
zero,| since we're running on
|由于我们使用的是CPU，

872
00:27:17,170 --> 00:27:18,610
0,660 660,900 900,1200 1200,1320 1320,1440
CPUs,| this switch is going
该开关将切换到调度器线程的先前保存的寄存器，

873
00:27:18,610 --> 00:27:20,380
0,60 60,450 450,960 1380,1590 1590,1770
to switch to {} the

874
00:27:20,380 --> 00:27:22,600
0,900 900,1680
previously saved

875
00:27:22,720 --> 00:27:25,390
0,840 840,990 990,1290 1380,2100 2100,2670
registers for the scheduler thread,|
|

876
00:27:25,420 --> 00:27:27,340
0,210 210,510 510,1170 1170,1260 1260,1920
so let's schedule {} zero.|
所以我们把时间表定为零。|

877
00:27:27,980 --> 00:27:29,200
0,660

878
00:27:29,650 --> 00:27:32,080
0,360 1050,1350 1350,1440 1440,2220 2250,2430
And in the scheduler for
并在调度器中进行CPU零位切换，

879
00:27:32,080 --> 00:27:34,600
0,420 420,990 1020,1710 1710,2130 2310,2520
CPU zero switch will,| by
|通过恢复这些寄存器，

880
00:27:34,600 --> 00:27:36,760
0,390 390,570 570,1500 1500,1740 1740,2160
restoring these registers,| since registers
|由于寄存器包括堆栈指针，

881
00:27:36,760 --> 00:27:38,440
0,270 270,360 360,750 750,1230 1380,1680
include the stack pointer {},|
|

882
00:27:38,440 --> 00:27:39,910
0,180 180,600 600,750 750,1200 1230,1470
the return from switch as
正如我们将看到的，从Switch返回，

883
00:27:39,940 --> 00:27:42,460
0,510 690,930 930,1260 1260,1950 1950,2520
{we'll,see},| well now actually {}
|现在实际上返回到CPU0上的调度器函数，

884
00:27:43,750 --> 00:27:47,350
0,600 600,930 930,1740 2190,2820 2850,3600
return up to the {}

885
00:27:47,830 --> 00:27:50,020
0,930 960,1650
scheduler function

886
00:27:52,420 --> 00:27:53,920
0,570 600,1110 1110,1230 1230,1380 1380,1500
on CPU zero,| {} and
|并且调度功能将进行一些清理以完成使进程1进入休眠状态，

887
00:27:53,920 --> 00:27:55,720
0,780 780,870 870,1260 1260,1470 1560,1800
schedule {} function will do

888
00:27:55,720 --> 00:27:57,550
0,150 150,690 690,930 930,1290 1290,1830
some cleanup to finish putting

889
00:27:57,610 --> 00:27:58,990
0,330 330,480 480,540 540,1020 1110,1380
process one to sleep,| then
|然后它将在进程表中查找另一个进程，

890
00:27:58,990 --> 00:28:00,730
0,210 210,510 510,690 690,840 840,1740
it'll look in the process

891
00:28:00,790 --> 00:28:02,020
0,180 180,570 570,690 690,900 900,1230
{} table for another process,|
|

892
00:28:02,020 --> 00:28:04,210
0,330 330,480 480,750 750,1380 1620,2190
run a runnable process, and
运行一个可运行的进程，如果它找到了一个进程。

893
00:28:04,390 --> 00:28:06,620
0,540 540,660 660,1200 1200,1740
if it finds one.|
|

894
00:28:07,160 --> 00:28:08,210
0,210 210,360 360,660 720,990 990,1050
And so we've sort of
所以我们在这里往下走，然后往上走到调度器里，

895
00:28:08,210 --> 00:28:09,530
0,210 210,540 540,900 900,1050 1050,1320
gone down here and up

896
00:28:09,530 --> 00:28:11,090
0,210 210,300 300,1020 1140,1470 1470,1560
into the scheduler,| if the
|如果调度程序找到另一个要运行的进程

897
00:28:11,090 --> 00:28:12,410
0,360 360,660 660,870 870,1200 1200,1320
scheduler finds another process to

898
00:28:12,410 --> 00:28:14,750
0,210 210,300 300,600 600,1410 2010,2340
run| or even finds process
|或者甚至发现进程1是可运行的，并且仍然想要运行查找进程1

899
00:28:14,750 --> 00:28:15,890
0,180 180,450 450,840 840,960 960,1140
one is runnable and still

900
00:28:15,890 --> 00:28:16,820
0,180 180,270 270,540 540,690 690,930
wants to run a find

901
00:28:16,820 --> 00:28:18,200
0,360 360,540 540,840 840,1020 1050,1380
process one| nothing else nothing
|没有别的，没有别的想要跑的，

902
00:28:18,200 --> 00:28:19,970
0,240 240,450 450,540 540,810 1650,1770
else wants to run,| but
|但不管怎样，

903
00:28:19,970 --> 00:28:21,110
0,60 60,210 210,450 450,540 540,1140
in any case,| the scheduler
|调度器将再次呼叫交换机，

904
00:28:21,110 --> 00:28:23,090
0,150 150,660 660,1380 1410,1830 1830,1980
will call switch again,| to
|将上下文切换到进程2。

905
00:28:23,090 --> 00:28:26,510
0,840 870,2010 2430,2610 2610,2880 2880,3420
switch contexts to say process

906
00:28:26,510 --> 00:28:27,460
0,510
two.|
|

907
00:28:27,960 --> 00:28:28,890
0,150 150,240 240,570 570,750 750,930
in the process swhich will
在将在其自己的上下文中再次保存其自己的寄存器的过程S中，

908
00:28:28,890 --> 00:28:31,110
0,690 690,840 840,1020 1020,1650 1650,2220
save its own registers again

909
00:28:31,110 --> 00:28:33,020
0,120 120,300 300,480 480,1380
in its own context,|
|

910
00:28:33,020 --> 00:28:34,460
0,180 180,420 420,540 540,540 540,1440
{} they'll be a previously
它们也将是以前保存的上下文，

911
00:28:34,460 --> 00:28:35,780
0,840
saved

912
00:28:35,870 --> 00:28:37,730
0,630 630,810 810,1020 1020,1440 1440,1860
context too,| from whenever process
|从进程2停止时开始

913
00:28:37,730 --> 00:28:39,680
0,210 210,540 540,990 1170,1560 1560,1950
two left off| that those
|这组寄存器将被恢复，进程2将先前调用交换机，

914
00:28:39,680 --> 00:28:40,970
0,180 180,510 510,600 600,1170 1170,1290
this set of registers will

915
00:28:40,970 --> 00:28:42,440
0,150 150,900
be restored,

916
00:28:42,440 --> 00:28:43,820
0,780 780,960 960,1110 1110,1230 1230,1380
process two will have made

917
00:28:43,820 --> 00:28:45,800
0,60 60,750 750,1050 1050,1170 1170,1980
a previous call to switch,|
|

918
00:28:46,790 --> 00:28:48,100
0,660

919
00:28:48,100 --> 00:28:49,120
0,150 150,390 390,480 480,570 570,1020
to switch to the scheduler
要像进程一样切换到调度程序线程，请执行以下操作

920
00:28:49,120 --> 00:28:50,380
0,330 330,540 540,630 630,1020 1020,1260
thread just like process one

921
00:28:50,380 --> 00:28:51,550
0,180 180,330 330,450 450,780 780,1170
did| when it left off,|
|当它停下来的时候，|

922
00:28:51,730 --> 00:28:53,110
0,270 270,510 510,540 540,900 900,1380
that called a switch return
呼叫交换机返回到任何系统调用或中断进程二结束

923
00:28:53,110 --> 00:28:54,640
0,90 90,960
to whatever

924
00:28:54,860 --> 00:28:56,510
0,450 450,750 750,870 870,1290 1290,1650
system call or interrupt process

925
00:28:56,510 --> 00:28:58,220
0,270 270,420 420,870 1050,1500 1500,1710
two is end| when that's
|完成后，将会有一个先前保存的用于进程2的陷帧，

926
00:28:58,220 --> 00:28:59,570
0,690 810,1020 1020,1140 1140,1260 1260,1350
finished, there will be a

927
00:28:59,570 --> 00:29:01,700
0,810 810,1350 1350,1710 1710,1980 1980,2130
previously saved {trapframe -} for

928
00:29:01,700 --> 00:29:03,470
0,420 420,810 1020,1230 1230,1350 1350,1770
process two,| that will contain
|它将包含用户寄存器，

929
00:29:03,470 --> 00:29:05,120
0,120 120,750 750,960 960,1110 1110,1650
user registers,| also be restored
|也可以恢复或返回到用户空间。

930
00:29:05,120 --> 00:29:07,310
0,300 480,900 1320,1830 1830,2040 2040,2190
or a return back up

931
00:29:07,310 --> 00:29:08,720
0,150 150,390 390,1050
into user space.|
|

932
00:29:09,050 --> 00:29:11,810
0,240 1380,1650 1650,1710 1710,2340 2640,2760
And there's a complete, a
每个CPU都有一个完整的、单独的调度程序线程，

933
00:29:11,810 --> 00:29:15,080
0,510 540,1200 1200,1830 1890,2610 2610,3270
separate scheduler {} {} thread

934
00:29:15,080 --> 00:29:16,190
0,180 180,330 330,840 840,1020 1020,1110
for each CPU,| so, they'll
|因此，它们也将被保存，CPU 1的调度程序线程的上下文，

935
00:29:16,190 --> 00:29:19,400
0,420 420,660 660,1680 2010,2760
also be saved {},

936
00:29:19,700 --> 00:29:21,710
0,690 690,930 930,1050 1050,1590 1590,2010
context for the scheduler thread

937
00:29:21,710 --> 00:29:24,590
0,210 210,630 630,1230 1500,2250 2340,2880
for CPU one,| {} and
|以及在调度器1上运行的调度器循环

938
00:29:24,620 --> 00:29:26,540
0,300 300,840 840,1410
a scheduler loop

939
00:29:27,820 --> 00:29:29,080
0,270 270,390 390,840 840,1140 1140,1260
running on scheduler one| and
|您所知道的任何进程，进程3或更多进程都在CPU 1上运行

940
00:29:29,080 --> 00:29:30,790
0,390 390,1170 1170,1230 1230,1320 1320,1710
whatever process you know process

941
00:29:30,790 --> 00:29:32,170
0,210 210,270 270,720 930,1170 1170,1380
three or something is running

942
00:29:32,170 --> 00:29:33,490
0,90 90,480 480,780 780,990 990,1320
on CPU one| when it
|当它决定放弃CPU时，

943
00:29:33,490 --> 00:29:34,300
0,420 420,510 510,630 630,720 720,810
decides to give up the

944
00:29:34,300 --> 00:29:37,120
0,450 450,630 630,1170 1170,1920 2400,2820
CPU,| it'll switch into a
|它将为其CPU切换为调度程序线程。

945
00:29:37,510 --> 00:29:40,090
0,870 1110,1620 1620,1800 1800,2250 2370,2580
scheduler thread for it for

946
00:29:40,090 --> 00:29:42,020
0,660 690,1320
its CPU.|
|

947
00:29:43,800 --> 00:29:45,210
0,270 270,420 420,660 660,1050 1050,1410
Alright, there's a question where
好的，这里有一个问题，上下文存储在哪里，

948
00:29:45,210 --> 00:29:48,360
0,120 120,930 930,1770 2100,2700 2880,3150
the context stored,| {} it
|事实证明，对于手术来说，

949
00:29:48,360 --> 00:29:50,220
0,480 480,780 780,1050 1050,1350 1350,1860
turns out that for the

950
00:29:50,780 --> 00:29:52,370
0,540 540,660 660,780 780,1140 1140,1590
operations,| I've been talking about
|我一直在说被拯救的事实上总是，

951
00:29:52,550 --> 00:29:55,730
0,480 480,1590 1650,1890 1890,2700 2700,3180
the saved {in,fact} always the,|
|

952
00:29:57,250 --> 00:30:00,190
0,270 270,360 360,990 990,2070 2280,2940
for a thread switch {},|
对于线程切换，|

953
00:30:01,030 --> 00:30:03,400
0,510 510,1350 1350,1530 1530,1920 1920,2370
these contexts, these saved register
这些上下文，这些为内核线程保存的寄存器集

954
00:30:03,400 --> 00:30:04,600
0,330 330,420 420,690 690,1050 1050,1200
sets for kernel threads| are
|在流程结构中，

955
00:30:04,600 --> 00:30:06,610
0,120 120,210 210,660 660,1260 1590,2010
in the process structure,| so
|因此，任何给定的内核线程只能有一组保存的内核寄存器。

956
00:30:06,610 --> 00:30:07,960
0,330 330,570 570,870 870,1200 1200,1350
any given kernel thread can

957
00:30:07,960 --> 00:30:09,790
0,450 780,1020 1020,1500 1500,1740 1740,1830
only have one set of

958
00:30:09,790 --> 00:30:12,380
0,750 750,1110 1110,2100
saved kernel registers.|
|

959
00:30:12,380 --> 00:30:14,180
0,300 300,540 540,810 810,1230 1500,1800
Because each thread is only
因为每个线程仅执行单个位置

960
00:30:14,180 --> 00:30:15,770
0,450 450,780 780,1080 1080,1500 1500,1590
executing a single place| and
|它的上下文在某种程度上反映了它在其上执行的位置

961
00:30:15,770 --> 00:30:17,810
0,150 150,960 1140,1410 1410,1500 1500,2040
its context kind of reflects

962
00:30:17,810 --> 00:30:19,190
0,330 330,930 930,1050 1050,1140 1140,1380
that place that it was

963
00:30:19,190 --> 00:30:20,690
0,540 540,690 690,810 810,1080 1080,1500
executing on it left off|
|

964
00:30:20,690 --> 00:30:22,070
0,480 480,720 720,810 810,900 900,1380
a thread is a single
线程是控制的单个线程，

965
00:30:22,460 --> 00:30:23,600
0,420 420,510 510,960 960,1140 1140,1140
thread of control,| so a
|所以一个线程实际上只需要一个充满寄存器的上下文，

966
00:30:23,600 --> 00:30:25,430
0,570 690,1230 1230,1410 1410,1620 1620,1830
thread really only needs one

967
00:30:25,430 --> 00:30:27,530
0,810 870,1050 1050,1140 1140,1920 1950,2100
context full of registers,| so
|所以它在过程结构p箭头，p->上下文中。

968
00:30:27,530 --> 00:30:28,580
0,90 90,180 180,240 240,600 600,1050
it's in the process structures

969
00:30:28,580 --> 00:30:30,280
0,270 270,900
p arrow,

970
00:30:31,510 --> 00:30:33,760
0,630 630,930 930,1680
{} {p->context -}.|
|

971
00:30:35,310 --> 00:30:36,810
0,240 240,300 300,840 840,990 990,1500
And the scheduler, each scheduler
和调度器，每个调度器线程都有自己的上下文

972
00:30:36,810 --> 00:30:38,670
0,270 270,450 450,630 630,1260 1320,1860
thread has its own context|
|

973
00:30:38,670 --> 00:30:39,900
0,150 150,420 420,840 840,960 960,1230
which actually not in the,|
实际上不是在，|

974
00:30:40,230 --> 00:30:41,790
0,300 300,360 360,900 900,1470 1470,1560
there's no process associated with
没有与此调度程序线程关联的进程，

975
00:30:41,790 --> 00:30:43,980
0,390 570,1170 1170,1590 1830,2100 2100,2190
this scheduler thread,| this is
|这实际上是调度器的上下文存储在该核心的结构CPU中。

976
00:30:43,980 --> 00:30:45,080
0,510
actually

977
00:30:45,080 --> 00:30:46,280
0,120 120,600 600,690 690,1110 1110,1200
{} {scheduler's -} context is

978
00:30:46,280 --> 00:30:47,680
0,390 390,780 1020,1200
stored in {}

979
00:30:47,680 --> 00:30:50,710
0,630 630,1590 1890,2220 2220,2460 2460,3030
{the,struct} CPU for that core.|
|

980
00:30:51,480 --> 00:30:52,320
0,180 180,270 270,600 600,660 660,840
There's an array of these
有一组这些CPU的结构，每个核心一个，

981
00:30:52,320 --> 00:30:53,700
0,330 330,390 390,1020 1050,1260 1260,1380
{CPU's -} struct one per

982
00:30:53,700 --> 00:30:54,810
0,420 420,510 510,720 720,930 930,1110
core,| each one as a
|每一个都作为一个上下文。

983
00:30:55,080 --> 00:30:56,400
0,780
context.|
|

984
00:30:58,210 --> 00:30:59,380
0,390 390,690 690,840 840,1050 1050,1170
{} Question why can't we
问为什么我们不能将寄存器包括在进程的陷阱帧中，

985
00:30:59,380 --> 00:31:00,730
0,450 450,690 690,1230 1230,1290 1290,1350
include the registers in the

986
00:31:00,730 --> 00:31:02,200
0,300 300,510 510,600 600,690 690,1470
{trapframe -} for the process,|
|

987
00:31:02,230 --> 00:31:04,330
0,450 480,720 720,1260 1560,1920 1920,2100
{} that is, {} you
也就是说，您知道这些寄存器实际上可以存储在陷阱帧中

988
00:31:04,330 --> 00:31:05,640
0,90 90,480 480,720
know actually the

989
00:31:06,940 --> 00:31:08,290
0,240 240,660 660,900 900,1020 1020,1350
those registers could be stored

990
00:31:08,290 --> 00:31:09,040
0,60 60,120 120,450 450,600 600,750
in the {trapframe -}| which
|这是因为只有一个内核线程寄存器的存储集，

991
00:31:09,040 --> 00:31:10,750
0,330 450,1020 1020,1200 1200,1380 1380,1710
made because there's only one

992
00:31:10,750 --> 00:31:12,340
0,360 360,660 660,1020
save set of

993
00:31:12,340 --> 00:31:15,040
0,330 330,690 690,1710 1920,2220 2220,2700
kernel thread registers,| for process,
|对于过程，我们可以将它们保存在任何数据结构中

994
00:31:15,040 --> 00:31:15,820
0,90 90,270 270,570 570,690 690,780
we could save them in

995
00:31:15,820 --> 00:31:17,710
0,210 210,480 480,1230 1410,1710 1710,1890
any data structure| for which
|其中存在数据结构化过程实例的一个元素，

996
00:31:17,710 --> 00:31:20,410
0,180 180,990 1140,1740 1740,1890 2280,2700
there's one element of instance

997
00:31:20,410 --> 00:31:22,030
0,90 90,240 240,450 450,930 930,1620
of that data structure process,|
|

998
00:31:22,270 --> 00:31:24,550
0,480 480,660 660,1500 1500,2130 2130,2280
there's one struct process,| there's
只有一个结构进程，|有一个用于进程的结构陷阱框架，

999
00:31:24,550 --> 00:31:25,780
0,240 240,600 600,900 900,1110 1110,1230
one struct {trapframe -} for

1000
00:31:25,780 --> 00:31:27,340
0,600 720,1050 1050,1230 1230,1500 1500,1560
process,| we could store the
|我们可以将寄存器存储在陷阱框中。

1001
00:31:27,340 --> 00:31:28,450
0,390 390,450 450,540 540,780 780,1110
registers in the {trapframe -}.|
|

1002
00:31:29,130 --> 00:31:30,220
0,570

1003
00:31:31,730 --> 00:31:32,750
0,150 150,540 540,750 750,930 930,1020
I mean just sort of
我是说，只是为了，

1004
00:31:32,750 --> 00:31:33,720
0,390
for,|
|

1005
00:31:33,720 --> 00:31:35,310
0,360 360,1020 1020,1110 1110,1500 1500,1590
maybe simplicity or clarity of
可能是代码的简单性或清晰性，我认为是陷阱框架。

1006
00:31:35,310 --> 00:31:36,720
0,420 420,540 540,840 840,1350 1350,1410
code, the {trapframe -} I

1007
00:31:36,720 --> 00:31:37,640
0,330
think.|
|

1008
00:31:37,640 --> 00:31:40,280
0,510 510,1140 1140,1890 2010,2400 2400,2640
Entirely consists of data, that's
完全由进入和离开内核时需要的数据组成。

1009
00:31:40,280 --> 00:31:41,810
0,330 330,660 690,1110 1110,1230 1230,1530
needed when entering and leaving

1010
00:31:41,810 --> 00:31:43,060
0,90 90,690
the kernel.|
|

1011
00:31:43,060 --> 00:31:45,010
0,360 510,720 720,960 960,1620 1620,1950
And the struct context is
结构上下文由需要保存和恢复的内容组成，

1012
00:31:45,730 --> 00:31:46,840
0,510 510,630 630,720 720,1020 1020,1110
consists of the stuff that

1013
00:31:46,840 --> 00:31:47,470
0,120 120,180 180,270 270,540 540,630
needs to be saved and

1014
00:31:47,470 --> 00:31:49,180
0,450 450,780 780,1290 1290,1530 1530,1710
restored,| when switching to and
|当在内核线程和调度器线程之间来回切换时。

1015
00:31:49,180 --> 00:31:51,190
0,510 570,1050 1050,1260 1320,1650 1650,2010
from between the kernel thread

1016
00:31:51,190 --> 00:31:53,120
0,150 150,360 480,960 960,1350
and the scheduler thread.|
|

1017
00:31:54,640 --> 00:31:55,870
0,240 240,600 600,720 720,990 990,1230
Okay question is, yield something
好的问题是，产生由内核用户调用的东西，由内核调用的东西，

1018
00:31:55,870 --> 00:31:56,860
0,150 150,420 420,540 540,630 630,990
that's called by the user

1019
00:31:56,860 --> 00:31:57,670
0,60 60,120 120,480 480,690 690,810
of the kernel, called by

1020
00:31:57,670 --> 00:31:58,800
0,90 90,540
the kernel,|
|

1021
00:31:59,060 --> 00:32:00,890
0,300 300,630 660,1110 1110,1500 1500,1830
So the user threads, there's
所以用户线程，在xv6中没有真正直接的方式

1022
00:32:00,890 --> 00:32:01,880
0,270 270,420 420,450 450,780 780,990
not really a direct way

1023
00:32:01,880 --> 00:32:03,050
0,240 240,540 540,750 750,870 870,1170
in {xv6 -}| for user
|供用户线程讨论，从而产生CPU或切换已完成的任务

1024
00:32:03,050 --> 00:32:05,870
0,390 390,660 810,1260 1260,1740 1980,2820
threads to talk about {},

1025
00:32:06,080 --> 00:32:08,240
0,600 600,660 660,1230 1230,1320 1320,2160
yielding the CPU or switching

1026
00:32:08,480 --> 00:32:10,160
0,390 390,750 780,1230 1230,1530 1530,1680
{} that it's done| by
|通过内核这种透明的方式，

1027
00:32:10,160 --> 00:32:12,320
0,90 90,660 690,900 900,1050 1050,2160
the kernel kind of transparently,|
|

1028
00:32:13,210 --> 00:32:14,110
0,120 120,240 240,540 540,810 810,900
you know it points in
你知道它会在内核觉得有必要发生的时候出现，

1029
00:32:14,110 --> 00:32:15,130
0,240 240,330 330,390 390,660 660,1020
time when the kernel feels

1030
00:32:15,130 --> 00:32:16,510
0,210 360,570 570,810 810,930 930,1380
that it needs to happen,|
|

1031
00:32:16,810 --> 00:32:18,850
0,150 150,330 330,1110 1650,1980 1980,2040
if their threads there are
如果它们的线条有时在那里，

1032
00:32:18,850 --> 00:32:20,280
0,450 450,840
sometimes when,|

1033
00:32:21,190 --> 00:32:22,960
0,330 330,570 570,810 810,990 990,1770
you can sort of guess
您可以在某种程度上猜测，某个系统调用可能会导致收益，

1034
00:32:22,960 --> 00:32:24,490
0,210 210,750 750,810 810,1140 1140,1530
that probably a certain system

1035
00:32:24,490 --> 00:32:25,960
0,570 600,960 960,1290 1290,1380 1380,1470
call will result in {}

1036
00:32:25,960 --> 00:32:28,690
0,540 540,870 1560,1830 1830,1950 1950,2730
yield,| like if a process
|例如，如果进程在管道上进行读取，

1037
00:32:28,720 --> 00:32:29,710
0,210 210,360 360,780 780,900 900,990
does a read on a

1038
00:32:29,710 --> 00:32:31,150
0,420 420,570 570,690 690,1230 1230,1440
pipe,| where it knows that
|在那里它知道在该管道中真的没有等待读取的东西，

1039
00:32:31,150 --> 00:32:32,200
0,210 210,540 540,660 660,960 960,1050
really nothing is waiting to

1040
00:32:32,200 --> 00:32:33,190
0,120 120,300 300,360 360,510 510,990
be read in that pipe,|
|

1041
00:32:33,400 --> 00:32:34,660
0,630 660,840 840,930 930,1140 1140,1260
{} then the read will
那么读书人就会去挡路，

1042
00:32:34,660 --> 00:32:35,780
0,630
block,|
|

1043
00:32:35,870 --> 00:32:36,920
0,150 150,240 240,750 750,840 840,1050
you can predict the read
你可以预测挡路的阅读量

1044
00:32:36,920 --> 00:32:38,390
0,450 450,540 540,720 720,1020 1050,1470
block| and that the kernel
|内核将运行其他进程，

1045
00:32:38,390 --> 00:32:39,300
0,300
will

1046
00:32:39,300 --> 00:32:40,860
0,330 330,540 540,780 780,1320 1320,1560
run some other process,| while
|当我们等待数据出现在管道中时，

1047
00:32:40,860 --> 00:32:42,180
0,240 450,840 840,960 960,1230 1230,1320
we're waiting for data to

1048
00:32:42,180 --> 00:32:43,540
0,270 270,360 360,420 420,750
appear in the pipe,|
|

1049
00:32:44,800 --> 00:32:46,360
0,450 720,930 930,1020 1020,1380 1380,1560
{} so the times when
所以在内核中调用产量的时间，

1050
00:32:46,360 --> 00:32:47,350
0,420 420,540 540,840 840,900 900,990
yield is called in the

1051
00:32:47,350 --> 00:32:48,640
0,450 450,630 630,840 840,1050 1050,1290
kernel,| there's really two main
|实际上有两个主要的时间，

1052
00:32:48,640 --> 00:32:49,750
0,300 300,510 510,810 840,1050 1050,1110
times,| one is if a
|一种是如果计时器中断停止，内核总是让步，

1053
00:32:49,750 --> 00:32:52,210
0,600 720,1080 1080,1290 1290,1890 2130,2460
timer interrupt goes off {},

1054
00:32:52,240 --> 00:32:54,760
0,300 300,600 600,1410 1620,2190 2220,2520
kernel always yields,| you know
|你知道，仅仅基于这样的理论，

1055
00:32:54,760 --> 00:32:55,560
0,360
just

1056
00:32:55,560 --> 00:32:57,400
0,450 450,540 540,900 900,1200
on the theory that,|
|

1057
00:32:57,640 --> 00:32:59,800
0,390 390,750 750,1110 1140,1890 1890,2160
{} we should interleave the
我们应该交错执行所有想要在定时器中断周期上运行的进程，

1058
00:32:59,800 --> 00:33:02,140
0,600 600,900 1230,1770 2070,2250 2250,2340
execution of of all the

1059
00:33:02,140 --> 00:33:03,190
0,360 360,480 480,660 660,720 720,1050
process that want to run

1060
00:33:03,190 --> 00:33:04,940
0,270 270,690 690,1350
on timer interrupt

1061
00:33:05,180 --> 00:33:08,000
0,1320 1590,1890 1890,2130 2130,2460 2460,2820
periods,| so timer interrupt also
|因此定时器中断也总是调用Year

1062
00:33:08,000 --> 00:33:10,040
0,270 270,570 570,1020 1410,1650 1650,2040
always calls yield| and whenever
|每当进程系统调用等待IO时，

1063
00:33:10,040 --> 00:33:11,420
0,90 90,780 780,870 870,1140 1140,1380
a process {} system calls

1064
00:33:11,420 --> 00:33:13,910
0,570 840,1110 1110,1860 1950,2400 2400,2490
waiting for IO,| waiting for
|等待你输入下一次击键，

1065
00:33:13,910 --> 00:33:14,630
0,90 90,180 180,390 390,480 480,720
you to type the next

1066
00:33:14,630 --> 00:33:16,190
0,570 570,900 900,1020 1020,1440 1440,1560
keystroke,| does a read of
|读取控制台，但您尚未键入密钥，

1067
00:33:16,190 --> 00:33:17,330
0,150 150,720 720,810 810,900 900,1140
the console and you haven't

1068
00:33:17,330 --> 00:33:19,430
0,240 240,450 450,780 1080,1800 1800,2100
typed key yet,| then the
|然后等待IO调用的机器产生，从睡眠中调用，

1069
00:33:20,620 --> 00:33:21,790
0,150 150,660 660,780 780,1020 1020,1170
the machinery to wait for

1070
00:33:21,790 --> 00:33:24,280
0,810 870,1290 1320,1710 1710,2280 2280,2490
IO {} calls yields, called

1071
00:33:24,280 --> 00:33:25,420
0,120 120,900
from sleep,|
|

1072
00:33:25,420 --> 00:33:26,350
0,300 300,390 390,570 570,720 720,930
something, we'll talk about next
一些事，我们下周再谈。

1073
00:33:26,350 --> 00:33:27,280
0,300
week.|
|

1074
00:33:29,200 --> 00:33:30,760
0,600
Alright.
好的。好的那么。

1075
00:33:31,540 --> 00:33:33,760
0,1230 1230,1410 1410,1650 1650,1860 1860,2220
Okay so.| I have another
|我还有一个问题。

1076
00:33:33,760 --> 00:33:35,620
0,630 660,1260
question.| Yes.|
|是。|

1077
00:33:35,700 --> 00:33:36,930
0,480 480,720 720,870 870,1050 1050,1230
Oh, if it is a
哦，如果是睡觉的话，

1078
00:33:36,930 --> 00:33:38,670
0,600 630,1110 1110,1470 1470,1650 1650,1740
sleep,| {is,it} gonna do the
|它是否会做大致相同的事情，所以会是一些系统调用，

1079
00:33:38,670 --> 00:33:40,500
0,390 390,690 690,1350 1410,1650 1650,1830
same thing roughly {so,it's} gonna

1080
00:33:40,500 --> 00:33:42,660
0,120 120,600 960,1230 1230,1620 1620,2160
be some {} system call,|
|

1081
00:33:42,690 --> 00:33:44,040
0,480 480,690 690,990 990,1050 1050,1350
there's gonna save the {trapframe
那里将会拯救陷井

1082
00:33:44,040 --> 00:33:47,280
0,480 750,1260 1530,2070 2190,2790 2820,3240
-}| and {} then basically
|然后基本上是一样的(图片)，

1083
00:33:47,280 --> 00:33:48,840
0,60 60,240 240,570 570,900 1290,1560
the same [picture],| but it's
|但这只是一个

1084
00:33:48,840 --> 00:33:51,000
0,540 840,1230 1260,1650
just a,| then
|然后，使进程在没有计时器中断的情况下进入内核的东西，

1085
00:33:51,000 --> 00:33:53,280
0,300 300,570 570,960 1230,1770 1890,2280
the thing that made the

1086
00:33:53,280 --> 00:33:54,600
0,570 570,690 690,870 870,960 960,1320
process go into the kernel

1087
00:33:54,600 --> 00:33:55,800
0,330 330,420 420,720 720,810 810,1200
without a timer {interrupt -},|
|

1088
00:33:55,800 --> 00:33:56,740
0,360
but,
但是，这一过程是自己的决定。

1089
00:33:56,870 --> 00:33:57,900
0,480
{the,process's,own,decision}.|
|

1090
00:33:57,900 --> 00:34:01,890
0,1740 2580,2910 2910,3120 3120,3240 3240,3990
{Yeah -}, so the process
是的，所以这个过程使得有一个读取系统调用

1091
00:34:01,920 --> 00:34:03,210
0,240 240,420 420,540 540,870 870,1290
make there's a read system

1092
00:34:03,210 --> 00:34:04,020
0,300 300,390 390,540 540,690 690,810
call| and that's why it's
|这就是为什么它在内核中，

1093
00:34:04,020 --> 00:34:05,300
0,90 90,150 150,690
in the kernel,|
|

1094
00:34:05,330 --> 00:34:07,670
0,630 930,1110 1110,1740 1740,2250 2250,2340
and the read requires the
并且读取需要该过程等待盘，

1095
00:34:07,670 --> 00:34:08,810
0,330 330,480 480,810 810,990 990,1140
process to wait for the

1096
00:34:08,810 --> 00:34:09,980
0,690
disk,|
|

1097
00:34:10,010 --> 00:34:11,210
0,120 120,300 300,510 510,780 780,1200
to do to finish reading|
为读完书而做的事|

1098
00:34:11,210 --> 00:34:12,230
0,240 240,390 390,630 630,720 720,1020
or to wait for data
或者等待数据出现在管道上，

1099
00:34:12,230 --> 00:34:13,220
0,180 180,510 510,600 600,630 630,990
to appear on a pipe,|
|

1100
00:34:13,310 --> 00:34:14,660
0,210 210,630 690,870 870,1290 1290,1350
then actually the diagram is
那么实际上这个图跟这个是一模一样的，

1101
00:34:14,660 --> 00:34:16,310
0,480 480,570 570,990 990,1110 1110,1650
exactly the same as this,

1102
00:34:16,400 --> 00:34:18,180
0,390 480,1230
the {},|
|

1103
00:34:18,510 --> 00:34:19,290
0,210 210,270 270,510 510,690 690,780
and the kernel with a
内核中有一个叫做Trapframe的系统，

1104
00:34:19,290 --> 00:34:21,090
0,270 270,810 810,1050 1050,1620 1650,1800
system called {trapframe -},| all
|所有保存的用户寄存器，

1105
00:34:21,090 --> 00:34:22,500
0,150 150,450 450,660 660,1110 1110,1410
the saved user register,| execute
|执行系统称为系统整体依赖，

1106
00:34:22,500 --> 00:34:23,310
0,90 90,360 360,510 510,570 570,810
the system called the system

1107
00:34:23,310 --> 00:34:24,840
0,270 270,660 690,1050 1140,1470 1470,1530
whole rely,| {} need to
|需要等待磁盘完成读取某些内容，

1108
00:34:24,840 --> 00:34:25,530
0,150 150,240 240,330 330,600 600,690
wait for the disk to

1109
00:34:25,530 --> 00:34:28,080
0,240 240,480 480,1020 1950,2130 2130,2550
finish reading something,| the system
|系统调用代码将调用睡眠，睡眠结束编码开关，

1110
00:34:28,080 --> 00:34:29,400
0,210 210,480 480,570 570,750 750,1320
call code will call sleep

1111
00:34:29,400 --> 00:34:31,770
0,630 750,990 990,1110 1110,1440 1440,2370
which ends up coding switch,|
|

1112
00:34:32,180 --> 00:34:35,480
0,510 780,1470 1470,1770 1770,1980 1980,3300
which saves away the kernel
这将保存进程上下文中的内核线程寄存器

1113
00:34:35,600 --> 00:34:37,520
0,600 600,1200 1200,1290 1290,1380 1380,1920
thread registers in the process

1114
00:34:37,520 --> 00:34:40,550
0,630 930,1590 1590,1710 1710,2250 2550,3030
context| switches to this current
|切换到该当前CPU调度器，

1115
00:34:40,550 --> 00:34:41,540
0,150 150,540 540,630 630,810 810,990
CPU scheduler,| to let some
|为了让其他线程运行，

1116
00:34:41,540 --> 00:34:43,580
0,240 240,540 540,1140 1170,1830 1830,2040
other thread run,| while this
而此线程正在等待离散进程完成。

1117
00:34:43,580 --> 00:34:44,900
0,420 420,810 810,1140 1140,1230 1230,1320
thread is waiting for the

1118
00:34:44,900 --> 00:34:46,560
0,390 390,480 480,1080
discrete to finish.|
|

1119
00:34:46,590 --> 00:34:47,850
0,420 540,990 990,1080 1080,1200 1200,1260
So everything we're going to
所以我们现在要谈论的一切，

1120
00:34:47,850 --> 00:34:49,320
0,240 240,480 480,840 870,1350 1350,1470
talk about now,| except for
|除了定时器中断之外，几乎都是一样的

1121
00:34:49,320 --> 00:34:51,810
0,90 90,510 510,1200 1650,2220 2250,2490
the timer interrupt, {} is

1122
00:34:51,810 --> 00:34:53,550
0,360 360,570 570,660 660,1290 1290,1740
pretty much the same| if
|如果发生的情况是我们在一个叫做，

1123
00:34:53,880 --> 00:34:54,870
0,300 300,540 540,720 720,840 840,990
what's going on is we're

1124
00:34:54,870 --> 00:34:55,740
0,90 90,120 120,480 480,810 810,870
in a system called,| the
|系统调用需要等待一些IO

1125
00:34:55,740 --> 00:34:57,330
0,360 360,930 960,1230 1230,1320 1320,1590
system call needs to wait

1126
00:34:57,330 --> 00:34:58,830
0,120 120,360 420,600 600,1140 1350,1500
for some for IO| and
|并放弃CPU，

1127
00:34:58,830 --> 00:35:00,320
0,120 120,240 240,330 330,870
give up the CPU,|
|

1128
00:35:01,040 --> 00:35:02,080
0,480

1129
00:35:02,250 --> 00:35:03,780
0,330 330,420 420,780 780,900 900,1530
for the purposes of today's
为了今天的讨论，

1130
00:35:03,780 --> 00:35:05,310
0,450 450,660 750,930 930,1440 1440,1530
discussion,| the two situations are
|这两种情况几乎是一样的。

1131
00:35:05,310 --> 00:35:06,720
0,270 270,780
almost identical.|
|

1132
00:35:07,560 --> 00:35:08,680
0,600

1133
00:35:08,970 --> 00:35:10,170
0,330 330,480 480,630 630,1020 1020,1200
Okay, so the question does
好的，问题是每个CPU调度器都有自己的堆栈。

1134
00:35:10,170 --> 00:35:11,460
0,240 240,450 450,810 810,1200 1200,1290
each per CPU scheduler has

1135
00:35:11,460 --> 00:35:13,590
0,120 120,240 240,630 630,1560 1830,2130
its own stack.| Yes there's
|是的，有一堆，

1136
00:35:13,590 --> 00:35:15,560
0,450 450,1440
a stack,|
|

1137
00:35:15,870 --> 00:35:17,260
0,870

1138
00:35:18,600 --> 00:35:21,030
0,330 330,1110 1110,1530 1830,2310 2310,2430
this scheduler {} stack for
该单独堆栈的该调度器堆栈，

1139
00:35:21,030 --> 00:35:22,900
0,210 210,750 750,1320
this separate stack,|
|

1140
00:35:23,730 --> 00:35:26,250
0,540 540,1260 1590,2070 2070,2160 2160,2520
{} for scheduler for CPU
用于CPU 1的调度程序。

1141
00:35:26,250 --> 00:35:27,120
0,270
one.|
|

1142
00:35:27,630 --> 00:35:28,760
0,570

1143
00:35:31,920 --> 00:35:33,570
0,270 270,630 630,1080 1080,1200 1200,1650
Yeah, and indeed the stacks
是啊，事实上这家伙的烟囱也是设置好的，

1144
00:35:33,570 --> 00:35:35,010
0,90 90,240 240,450 450,690 690,1440
for this guy's also setup,|
|

1145
00:35:36,300 --> 00:35:38,040
0,300 300,570 600,990 990,1200 1200,1740
in fact, all this stuff
事实上，所有这些东西您都知道上下文和带有调度程序线程的堆栈

1146
00:35:38,070 --> 00:35:39,510
0,150 150,210 210,330 330,1320 1320,1440
you know the context and

1147
00:35:39,510 --> 00:35:41,160
0,90 90,690 690,780 780,840 840,1650
the stacks with a scheduler

1148
00:35:41,160 --> 00:35:42,600
0,750 750,870 870,1170 1170,1350 1350,1440
threads| are set up in
|的设置方式与用户进程的设置方式不同。

1149
00:35:42,600 --> 00:35:43,860
0,180 180,630 630,960 960,1140 1140,1260
a different way than for

1150
00:35:43,860 --> 00:35:46,420
0,300 300,1200
user process's.|
|

1151
00:35:46,450 --> 00:35:47,530
0,270 270,540 540,660 660,780 780,1080
They're set up at boot
它们是在引导时设置的，

1152
00:35:47,530 --> 00:35:49,450
0,600 750,1140 1140,1230 1230,1500 1500,1920
time,| if you poke around
|如果您四处查看并启动.s或start.c，

1153
00:35:49,450 --> 00:35:51,550
0,240 630,1350 1350,1710 1710,2010 2010,2100
and {start.S - -} or

1154
00:35:51,550 --> 00:35:53,950
0,300 300,540 540,1110 1830,2250 2250,2400
{start.c - -},| {start.S -}
|您可能会看到每个内核的调度程序线程的一些设置，

1155
00:35:53,950 --> 00:35:54,970
0,270 270,390 390,720 720,930 930,1020
probably you'll see some of

1156
00:35:54,970 --> 00:35:57,940
0,90 90,750 930,1350 1380,2010 2040,2970
the setup for each core's

1157
00:35:57,940 --> 00:35:59,770
0,630 630,1080 1080,1290 1290,1500 1620,1830
scheduler thread,| there's a place
|在引导期间汇编代码中有一个堆栈的位置非常早，

1158
00:35:59,770 --> 00:36:00,880
0,120 120,750
with stack

1159
00:36:01,000 --> 00:36:02,290
0,330 330,630 630,780 780,900 900,1290
very early in the assembly

1160
00:36:02,290 --> 00:36:03,850
0,240 240,450 450,780 810,1350 1350,1560
code during boot,| where the
|其中为每个CPU设置堆栈

1161
00:36:03,850 --> 00:36:05,080
0,450 450,570 570,840 840,1020 1020,1230
stack is set up for

1162
00:36:05,080 --> 00:36:06,760
0,600 630,1140 1140,1260 1260,1470 1470,1680
each CPU| and it's on
|它在那个堆栈上，这是一个CPU引导

1163
00:36:06,760 --> 00:36:08,140
0,210 210,540 540,720 720,1230 1230,1380
that stack, {that's -} a

1164
00:36:08,140 --> 00:36:10,150
0,420 420,810 810,1320 1500,1830 1830,2010
CPU boots on| and then
|然后运行其调度程序线程。

1165
00:36:10,150 --> 00:36:11,880
0,300 300,420 420,870 870,1170
runs its scheduler thread.|
|

1166
00:36:15,590 --> 00:36:17,600
0,630 690,1290
Okay, um.|
好的，嗯。|

1167
00:36:18,930 --> 00:36:20,430
0,270 270,540 540,750 750,870 870,1500
{} One piece of jargon
一条行话A当人们谈论上下文切换时，

1168
00:36:20,430 --> 00:36:21,960
0,630 780,1020 1020,1230 1230,1350 1350,1530
a when people talk about

1169
00:36:21,960 --> 00:36:24,220
0,780 810,1740
context switch,|
|

1170
00:36:24,840 --> 00:36:27,360
0,360 360,540 540,930 930,1530 1560,2520
{} they're talking about usually
他们谈论的通常是这种转换行为

1171
00:36:28,720 --> 00:36:30,120
0,810
{}

1172
00:36:30,590 --> 00:36:32,870
0,840 870,1560 1560,1650 1650,2100 2100,2280
this act of switching| from
|通过为旧线程保存一组寄存器集从一个线程转移到另一个线程

1173
00:36:32,870 --> 00:36:34,220
0,270 270,780 780,900 900,1200 1200,1350
one thread to another by

1174
00:36:34,220 --> 00:36:35,630
0,450 450,690 690,870 870,960 960,1410
saving one set of register

1175
00:36:35,630 --> 00:36:37,040
0,510 510,630 630,720 720,930 930,1410
sets for the old thread|
|

1176
00:36:37,220 --> 00:36:39,500
0,270 270,870 900,1440 1440,1680 1680,2280
and restoring previously saved registers
并且为切换到的线程恢复先前保存的寄存器，

1177
00:36:39,500 --> 00:36:40,460
0,120 120,210 210,480 480,570 570,960
for the threads were switching

1178
00:36:40,460 --> 00:36:42,500
0,270 1140,1350 1350,1560 1560,1890 1890,2040
to,| that's what's usually meant
|这通常就是上下文的意思，

1179
00:36:42,500 --> 00:36:44,300
0,150 150,570 570,750 750,1170 1170,1800
by context,| which also sometimes
|有时它也适用于完整的[舞蹈]

1180
00:36:44,300 --> 00:36:46,010
0,150 150,540 540,630 630,720 720,1710
it's applied to the complete

1181
00:36:47,100 --> 00:36:48,300
0,600 600,720 720,900 900,1080 1080,1200
[dance]| that goes on when
|这在从一个用户进程切换到另一个用户进程时会发生，偶尔您会看到适用于的上下文，

1182
00:36:48,300 --> 00:36:49,860
0,360 360,510 510,690 690,960 960,1560
switching from one user process

1183
00:36:49,890 --> 00:36:51,090
0,90 90,390 390,480 480,1080 1080,1200
to another and occasionally you'll

1184
00:36:51,090 --> 00:36:52,770
0,150 150,630 630,810 810,1200 1200,1680
see context which apply to,|
|

1185
00:36:52,890 --> 00:36:54,810
0,750 750,1140 1140,1410 1410,1500 1500,1920
switching between user and kernel,|
在用户和内核之间切换，|

1186
00:36:54,930 --> 00:36:56,250
0,180 300,750 750,900 900,1020 1020,1320
but for us we mostly
但对我们来说，我们大多是认真的，

1187
00:36:56,250 --> 00:36:57,680
0,180 180,330 420,810
mean it {},|
|

1188
00:36:58,260 --> 00:36:59,640
0,360 420,810 810,960 960,1110 1110,1380
{} switching from one kernel
通常从一个内核线程切换到调度器线程。

1189
00:36:59,640 --> 00:37:00,700
0,480
thread

1190
00:37:01,300 --> 00:37:02,580
0,330 330,660
typically to

1191
00:37:02,860 --> 00:37:04,600
0,450 450,480 480,810
{scheduler -} thread.|
|

1192
00:37:04,980 --> 00:37:07,200
0,480 990,1350 1350,1650 1860,2160 2160,2220
{} Just some pieces of
只是一些信息，

1193
00:37:07,200 --> 00:37:09,740
0,930
information,|
|

1194
00:37:10,100 --> 00:37:12,830
0,420 870,1140 1140,1890 1980,2370 2490,2730
the [] [] to keep
要牢记的[][]，

1195
00:37:12,830 --> 00:37:15,140
0,60 60,600 780,1290 1440,1950 1950,2310
in mind,| {} every core
|每个核心一次只做一件事，

1196
00:37:15,140 --> 00:37:16,040
0,210 210,360 360,630 630,810 810,900
just does one thing at

1197
00:37:16,040 --> 00:37:17,990
0,60 60,540 570,930 930,1590 1620,1950
a time,| each core you
|您所知道的每个内核要么在任何给定时间只运行一个线程，

1198
00:37:17,990 --> 00:37:19,100
0,90 90,210 210,570 570,750 750,1110
know is either is just

1199
00:37:19,520 --> 00:37:20,870
0,240 240,570 570,1080 1080,1200 1200,1350
running one thread at any

1200
00:37:20,870 --> 00:37:22,190
0,180 180,450 450,600 600,930 930,1320
given time,| it's either running
|它要么正在运行一些进程、用户线程、一些进程内核线程

1201
00:37:22,190 --> 00:37:24,410
0,570 570,1560 1560,1800 1800,1860 1860,2220
some processes {user -} thread

1202
00:37:24,410 --> 00:37:26,510
0,180 180,600 600,960 960,1290 1320,2100
some process kernel thread| or
|或该核心的调度程序线程，

1203
00:37:26,510 --> 00:37:28,370
0,240 240,570 570,1050 1050,1380 1680,1860
that core's scheduler thread,| so
所以在任何给定的时间，核心都不会做多件事，

1204
00:37:28,370 --> 00:37:29,150
0,90 90,240 240,450 450,720 720,780
at any given time the

1205
00:37:29,150 --> 00:37:30,560
0,540 540,690 690,870 870,1050 1050,1410
core is not doing multiple

1206
00:37:30,560 --> 00:37:31,550
0,270 270,420 420,570 570,750 750,990
things,| it's just doing one
|它只是在做一件事

1207
00:37:31,550 --> 00:37:33,140
0,300 300,810 810,930 930,1080 1080,1590
thing| and it's this switching
|正是这种切换在某种程度上创造了多个线程在该核心上不同时间运行的错觉，

1208
00:37:33,140 --> 00:37:33,920
0,120 120,270 270,330 330,690 690,780
that sort of creates the

1209
00:37:33,920 --> 00:37:37,340
0,780 780,1230 1500,2100 2100,2820 3030,3420
illusion of multiple threads running

1210
00:37:37,340 --> 00:37:38,810
0,150 150,450 450,1170 1170,1320 1320,1470
at different times on that

1211
00:37:38,810 --> 00:37:41,240
0,390 810,1980
core,| similarly,
|类似地，每个线程都在运行，

1212
00:37:41,660 --> 00:37:44,440
0,600 930,1350 1350,2220
{} each thread

1213
00:37:44,560 --> 00:37:47,500
0,660 1140,1590 1590,1800 2310,2460 2460,2940
is running on,| is either
|要么只在一个内核上运行

1214
00:37:47,500 --> 00:37:50,320
0,360 360,810 1320,1860 1860,2130 2130,2820
running on exactly one core|
|

1215
00:37:50,740 --> 00:37:52,780
0,630 1050,1290 1290,1560 1560,1740 1740,2040
or its state has been
或其状态为已保存状态

1216
00:37:52,780 --> 00:37:54,250
0,330 330,450 450,600 600,1350 1350,1470
state has been saved| and
|然后我们就离开了它。

1217
00:37:54,250 --> 00:37:55,570
0,150 150,540 540,780 780,990 990,1320
we switched away from it.|
|

1218
00:37:56,280 --> 00:37:58,020
0,360 360,780 990,1170 1170,1560 1560,1740
So, so a thread just
所以说，一个线程从来不会在一个以上的内核上运行，

1219
00:37:58,020 --> 00:37:59,010
0,60 60,150 150,480 480,720 720,990
to be clear thread never

1220
00:37:59,010 --> 00:37:59,970
0,240 240,360 360,630 630,750 750,960
runs on more than one

1221
00:37:59,970 --> 00:38:01,140
0,300 300,600 600,690 690,930 930,1170
core,| thread is either running
|线程要么只在一个内核上运行，要么根本没有运行，

1222
00:38:01,140 --> 00:38:02,490
0,120 120,330 330,510 510,1020 1050,1350
on just one core or

1223
00:38:02,490 --> 00:38:03,510
0,120 120,360 360,570 570,660 660,1020
it's not running at all,|
|

1224
00:38:03,540 --> 00:38:05,310
0,420 450,630 630,1020 1020,1350 1350,1770
as a save state somewhere.|
作为某处的保存状态。|

1225
00:38:06,610 --> 00:38:08,950
0,510 870,1590 1590,2010 2010,2160 2160,2340
{} Another interesting thing about
关于xv6设置的另一个有趣的事情是

1226
00:38:08,950 --> 00:38:10,690
0,90 90,660 660,1200 1230,1470 1470,1740
the xv6 setup is that|
|

1227
00:38:10,780 --> 00:38:14,080
0,330 330,1350 1350,1500 1500,2190 2310,3300
these contexts that hold saved
保存保存的内核线程寄存器的这些上下文，

1228
00:38:14,640 --> 00:38:18,120
0,810 840,1590 1590,2550 2790,3150 3150,3480
Kernel thread registers,| they're always
|它们总是由呼叫交换机产生

1229
00:38:18,120 --> 00:38:19,290
0,360 360,480 480,600 600,1020 1020,1170
produced by a call to

1230
00:38:19,290 --> 00:38:21,990
0,990 1380,1920 2160,2400 2400,2490 2490,2700
switch| {} and so these
|因此，这些上下文基本上总是指线程的状态

1231
00:38:21,990 --> 00:38:25,290
0,510 510,990 1290,1890 1890,2610 2610,3300
contexts basically always refer to

1232
00:38:25,500 --> 00:38:27,210
0,390 390,780 780,900 900,1020 1020,1710
the state of the thread|
|

1233
00:38:27,240 --> 00:38:29,100
0,420 420,480 480,690 690,1410 1410,1860
as it was executing inside
因为它是在对Switch的调用中执行的。

1234
00:38:29,100 --> 00:38:30,840
0,60 60,360 360,450 450,1320
a call to switch.|
|

1235
00:38:30,930 --> 00:38:32,500
0,540

1236
00:38:33,240 --> 00:38:34,410
0,540 570,720 720,810 810,960 960,1170
And you know the way
你知道我们会看到这一点出现的方式是

1237
00:38:34,410 --> 00:38:35,400
0,150 150,330 330,540 540,720 720,990
we'll see that come up

1238
00:38:35,400 --> 00:38:37,560
0,150 150,420 510,750 750,1170 1650,2160
is that| when we switch
|当我们从一个切换到另一个并恢复目标线程的上下文时，

1239
00:38:37,560 --> 00:38:38,760
0,120 120,390 390,750 750,1050 1050,1200
from one to another and

1240
00:38:38,760 --> 00:38:40,200
0,660 660,750 750,1140 1140,1380 1380,1440
restore the target {thread's -}

1241
00:38:40,200 --> 00:38:41,850
0,750 900,1110 1110,1440 1440,1560 1560,1650
context,| the first thing it
|它要做的第一件事是从上一个调用返回

1242
00:38:41,850 --> 00:38:43,080
0,120 120,360 360,540 540,1050 1050,1230
will do is return from

1243
00:38:43,080 --> 00:38:45,240
0,180 180,900 900,1260 1260,1380 1380,2160
a previous call| to switch
|为了切换这些上下文始终处于保存状态，

1244
00:38:45,390 --> 00:38:47,130
0,240 240,810 810,960 960,1410 1410,1740
these contexts are always save

1245
00:38:47,130 --> 00:38:48,240
0,570
state,|
|

1246
00:38:48,270 --> 00:38:49,470
0,360 390,660 660,750 750,990 990,1200
in as it is in
就像它在交换机里一样。

1247
00:38:49,470 --> 00:38:50,720
0,690
switch.|
|

1248
00:38:52,490 --> 00:38:53,760
0,690
Okay.|
好吧。|

1249
00:38:54,150 --> 00:38:55,440
0,540

1250
00:38:56,060 --> 00:38:57,470
0,180 180,330 330,780 780,1080 1080,1410
Any more questions about the
关于图表级别的情况还有什么问题吗？

1251
00:38:58,610 --> 00:39:00,960
0,660 660,1080 1080,1710
diagram level situation?|
|

1252
00:39:05,240 --> 00:39:06,470
0,240 240,420 420,570 570,660 660,1230
{} I have a question,
我有个问题，你一直在用“线”这个词，

1253
00:39:06,740 --> 00:39:07,970
0,180 180,360 360,750 750,900 900,1230
you are using the term

1254
00:39:07,970 --> 00:39:09,230
0,300 300,450 450,540 540,930 930,1260
thread all the time,| but
|但在我看来，我们对xv6的实现

1255
00:39:09,260 --> 00:39:10,160
0,120 120,360 360,480 480,600 600,900
it seems to me like

1256
00:39:10,160 --> 00:39:11,780
0,210 210,1050 1050,1320 1320,1470 1470,1620
our implementation for {xv6 -

1257
00:39:11,780 --> 00:39:14,390
0,720 1080,1380 1380,2040 2040,2280 2280,2610
-},| {} process is if
|如果只有一个线程，

1258
00:39:14,510 --> 00:39:16,100
0,150 150,480 480,810 810,1200 1350,1590
there's only one thread,| so
|所以有没有可能一个进程可以有多个线程

1259
00:39:16,100 --> 00:39:17,540
0,120 120,510 510,660 660,1140 1140,1440
it {could,it} be possible that

1260
00:39:17,540 --> 00:39:19,100
0,270 270,660 660,810 810,1080 1080,1560
one process could have multiple

1261
00:39:19,100 --> 00:39:20,720
0,360 360,750 1080,1260 1260,1320 1320,1620
threads| or am I wrong
|还是我说错了。

1262
00:39:20,720 --> 00:39:21,560
0,330
here.|
|

1263
00:39:21,740 --> 00:39:23,760
0,210 210,420 420,600 600,1470
In {xv6 - -},
在xv6中，现在。

1264
00:39:23,760 --> 00:39:25,280
0,210 210,870
right now.|
|

1265
00:39:26,030 --> 00:39:28,400
0,300 300,750 750,1140 1560,2130 2130,2370
There's definitely some confusing things
我们在这里用词的方式肯定有一些令人困惑的地方，

1266
00:39:28,400 --> 00:39:29,090
0,180 180,270 270,390 390,540 540,690
about the way we use

1267
00:39:29,090 --> 00:39:30,440
0,120 120,480 480,780 810,1020 1050,1350
the words here,| in {xv6
|在xv6中，有一个进程，

1268
00:39:30,440 --> 00:39:32,000
0,150 150,1020
- -},

1269
00:39:32,260 --> 00:39:34,720
0,480 600,870 870,1890
{} a process,|
|

1270
00:39:35,400 --> 00:39:36,720
0,810

1271
00:39:38,470 --> 00:39:41,620
0,870 1140,1680 1680,1830 1830,2520 2520,3150
a process is either executing
进程正在执行用户级别的指令

1272
00:39:41,620 --> 00:39:44,830
0,1140 1470,1590 1590,1890 1890,2310 2460,3210
instructions {} user level| or
|或者它正在执行内核中的指令

1273
00:39:45,460 --> 00:39:48,340
0,360 360,870 870,2340 2610,2790 2790,2880
it's executing instructions in the

1274
00:39:48,340 --> 00:39:49,600
0,660
kernel|
|

1275
00:39:49,780 --> 00:39:51,200
0,660
or
或者根本不执行

1276
00:39:51,700 --> 00:39:52,900
0,210 210,390 390,870 870,960 960,1200
it's not executed at all|
|

1277
00:39:52,900 --> 00:39:53,740
0,90 90,240 240,540 540,690 690,840
and its state has been
并且它的状态被保存到上下文和陷阱帧的组合中。

1278
00:39:53,740 --> 00:39:56,020
0,390 390,930 930,1170 1170,1470 1470,2280
saved away into this combination

1279
00:39:56,020 --> 00:39:58,570
0,600 630,780 780,1740 1980,2430 2430,2550
of {} context and {}

1280
00:39:58,570 --> 00:39:59,920
0,360 360,870
{trapframe -}.|
|

1281
00:40:00,300 --> 00:40:01,420
0,540

1282
00:40:02,300 --> 00:40:03,920
0,360 360,540 540,660 660,930 930,1620
So that's the actual situation,|
所以这就是实际情况，|

1283
00:40:03,980 --> 00:40:04,610
0,240 240,390 390,450 450,570 570,630
now what you want to
现在你想说的是，

1284
00:40:04,610 --> 00:40:06,140
0,360 360,960
call that,|
|

1285
00:40:06,140 --> 00:40:07,600
0,780

1286
00:40:09,060 --> 00:40:10,050
0,180 180,540 540,600 600,870 870,990
you call it what you
你想怎么叫都行，

1287
00:40:10,050 --> 00:40:11,700
0,690 750,990 990,1260 1260,1470 1470,1650
like,| I I don't know
|我不知道对这个结构有什么简单的解释，

1288
00:40:11,700 --> 00:40:12,900
0,90 90,180 180,540 540,1080 1080,1200
of a simple explanation for

1289
00:40:12,900 --> 00:40:14,910
0,180 180,1050 1260,1410 1410,1860 1860,2010
this structure,| {} we've been
|我们一直在叫它我一直在叫它，

1290
00:40:14,910 --> 00:40:16,110
0,450 450,570 570,720 720,840 840,1200
calling it I've been calling

1291
00:40:16,110 --> 00:40:18,480
0,210 480,870 870,1020 1020,1770 1950,2370
it,| I've been saying that
|我一直在说，每个进程都有两个线程，

1292
00:40:18,510 --> 00:40:20,640
0,270 270,720 720,930 930,1140 1140,2130
each process has two threads,|
|

1293
00:40:21,100 --> 00:40:23,240
0,210 210,510 510,780 780,1560
a user level thread,
用户级线程和内核级线程

1294
00:40:23,580 --> 00:40:24,930
0,180 180,240 240,570 570,810 810,1350
and a kernel level thread|

1295
00:40:25,080 --> 00:40:26,400
0,180 180,360 360,420 420,1110 1110,1320
and that's a process there's
这是一个过程，有这样的限制

1296
00:40:26,400 --> 00:40:27,660
0,210 210,690 690,810 810,870 870,1260
this restriction| that a process
|进程只有x是

1297
00:40:27,660 --> 00:40:29,250
0,150 150,570 570,840 1050,1200 1200,1590
is only x is| either
|或者在用户空间的内核中执行，或者在内核中执行，中断间系统调用，

1298
00:40:29,250 --> 00:40:30,660
0,510 510,600 600,690 690,1170 1200,1410
executing in the kernel in

1299
00:40:30,660 --> 00:40:33,030
0,90 90,390 390,1110 1200,1950 1950,2370
the user space or executing

1300
00:40:33,030 --> 00:40:34,320
0,60 60,150 150,510 510,810 840,1290
in the kernel, inter- interrupt

1301
00:40:34,320 --> 00:40:36,240
0,330 330,750 1110,1260 1260,1470 1470,1920
system call,| but never both.|
|但不能两个都有。|

1302
00:40:38,680 --> 00:40:41,050
0,390 420,570 570,750 750,1140 1170,2370
{} That makes sense.| Yeah,
这事儿可以理解。|是的，我为这件事的复杂性道歉。

1303
00:40:41,050 --> 00:40:43,210
0,450 450,1050 1050,1140 1140,1560 1560,2160
I apologize for the complexity

1304
00:40:43,210 --> 00:40:45,040
0,90 90,570
of this.|
|

1305
00:40:47,540 --> 00:40:48,620
0,570
Okay.|
好吧。|

1306
00:40:48,710 --> 00:40:49,910
0,390 420,660 660,840 840,930 930,1200
Okay, so let me switch
好的，那么让我切换到代码，

1307
00:40:49,910 --> 00:40:51,140
0,90 90,780 780,960 960,1080 1080,1230
to code,| looking at the
|请看xv6代码。

1308
00:40:51,140 --> 00:40:52,820
0,270 270,480 480,1080
{xv6 -} code.|
|

1309
00:41:01,130 --> 00:41:03,590
0,690 1200,1560 1560,1680 1680,2370 2370,2460
{} Right, so first of
好的，那么首先，

1310
00:41:03,590 --> 00:41:04,820
0,660
all,|
|

1311
00:41:10,090 --> 00:41:12,670
0,780 810,990 990,1170 1170,1980 2130,2580
{} I just wanna just
我只想展示一些我们一直在谈论的东西，

1312
00:41:13,180 --> 00:41:14,560
0,840 840,1020 1020,1080 1080,1140 1140,1380
show some of the stuff

1313
00:41:14,560 --> 00:41:15,580
0,90 90,180 180,540 540,960 960,1020
we've been talking about,| I'm
|我来看一下流程结构。

1314
00:41:15,580 --> 00:41:16,480
0,120 120,180 180,390 390,510 510,900
going to look at the

1315
00:41:17,060 --> 00:41:18,460
0,810
{}

1316
00:41:19,250 --> 00:41:20,880
0,450 450,1050
process structure.|
|

1317
00:41:20,970 --> 00:41:21,720
0,210 210,300 300,420 420,660 660,750
And we can see in
我们可以在过程结构中看到，我们一直在谈论的很多事情，

1318
00:41:21,720 --> 00:41:22,650
0,90 90,420 420,720 720,780 780,930
the process structure, a lot

1319
00:41:22,650 --> 00:41:23,250
0,60 60,180 180,390 390,510 510,600
of the things we've been

1320
00:41:23,250 --> 00:41:25,830
0,330 330,630 1140,1680 1890,2370 2370,2580
talking about,| {} just for
|只是为了复习一下，这里有，

1321
00:41:25,830 --> 00:41:27,940
0,420 420,690 690,960 960,1530
review, there's the {},|
|

1322
00:41:30,760 --> 00:41:32,830
0,180 180,810 930,1230 1260,1770 1770,2070
{trapframe -} that saves the
保存用户级寄存器的陷阱帧。

1323
00:41:33,480 --> 00:41:35,560
0,300 300,570 570,1500
user level registers.|
|

1324
00:41:36,440 --> 00:41:39,680
0,900 930,1290 1290,2190 2190,2670
There's a context here,
这里有一个上下文，它保存内核线程寄存器，

1325
00:41:40,480 --> 00:41:43,210
0,270 270,780 780,1020 1800,2430 2430,2730
that saves the kernel thread

1326
00:41:43,210 --> 00:41:44,860
0,600 600,780 780,1260 1260,1380 1380,1650
registers,| we switch to the
|我们切换到调度程序线程。

1327
00:41:44,890 --> 00:41:46,520
0,540 540,1110
scheduler thread.|
|

1328
00:41:46,580 --> 00:41:47,780
0,330 330,630
There's a
有一个指向此进程的指针是内核堆栈，

1329
00:41:47,870 --> 00:41:50,090
0,750 1140,1500 1500,1590 1590,1770 1770,2220
{} pointer to this process

1330
00:41:50,090 --> 00:41:51,560
0,300 330,720 720,1230 1230,1380 1380,1470
is kernel stack,| which is
|这是我们在内核中执行时保存函数调用的位置。

1331
00:41:51,560 --> 00:41:53,810
0,390 660,1350 1350,1620 1620,1650 1650,2250
where function calls are saved

1332
00:41:53,960 --> 00:41:54,980
0,300 300,390 390,840 840,930 930,1020
while we're executing in the

1333
00:41:54,980 --> 00:41:56,020
0,510
kernel.|
|

1334
00:41:56,560 --> 00:41:58,780
0,390 630,960 960,1140 1140,1590 1590,2220
{} There's the state variable,|
这是状态变量，|

1335
00:41:58,780 --> 00:42:01,390
0,480 510,1410 1410,1710 1710,1950 1950,2610
which records whether this process
它记录该进程是否正在运行、是否可运行、是否处于休眠状态或根本没有分配。

1336
00:42:01,390 --> 00:42:03,550
0,630 690,1500 1500,1680 1680,2100 2100,2160
is running or runnable or

1337
00:42:03,550 --> 00:42:05,380
0,570 570,780 810,1140 1140,1680 1680,1830
sleeping or not allocated at

1338
00:42:05,380 --> 00:42:06,320
0,420
all.|
|

1339
00:42:06,550 --> 00:42:08,800
0,570 660,810 810,960 960,1650
{} And then finally,
最后，正如我们将要看到的，这里有一个保护各种东西的锁，

1340
00:42:09,120 --> 00:42:10,530
0,240 240,450 450,540 540,1080 1080,1410
{} there's a lock that

1341
00:42:10,650 --> 00:42:12,060
0,510 510,810 810,1140 1140,1290 1290,1410
protects various things as we'll

1342
00:42:12,060 --> 00:42:14,220
0,600 660,1440
see {},|
|

1343
00:42:14,330 --> 00:42:15,620
0,750

1344
00:42:15,710 --> 00:42:17,540
0,150 150,480 480,720
for now {},
目前，我们可以观察到，至少可以保护对状态变量的更改。

1345
00:42:17,690 --> 00:42:18,830
0,150 150,330 330,660 660,810 810,1140
we can observe that at

1346
00:42:18,830 --> 00:42:21,350
0,240 240,900 1500,1830 1830,2400 2400,2520
least protects {} changes to

1347
00:42:21,350 --> 00:42:23,810
0,150 150,630 630,1320 2130,2340 2340,2460
the state variable.| So that
|例如，为了调度线程，

1348
00:42:23,810 --> 00:42:26,060
0,120 120,780 1590,1800 1800,2160 2160,2250
for example to schedule {}

1349
00:42:26,060 --> 00:42:27,500
0,300 300,510 510,690 690,900 930,1440
threads,| don't try to grab
|不要试图获取一个可运行的进程并同时运行它。

1350
00:42:27,500 --> 00:42:28,760
0,150 150,480 480,960 960,1080 1080,1260
a runnable process and run

1351
00:42:28,760 --> 00:42:29,720
0,210 210,300 300,390 390,630 630,960
it at the same time.|
|

1352
00:42:30,300 --> 00:42:31,260
0,360 360,450 450,510 510,720 720,960
One of the many things
这个锁做的众多事情之一就是防止这种情况发生。

1353
00:42:31,260 --> 00:42:32,280
0,150 150,360 360,600 600,720 720,1020
this lock does is prevent

1354
00:42:32,280 --> 00:42:33,660
0,150 150,300 300,690
that from happening.|
|

1355
00:42:35,280 --> 00:42:36,240
0,270 270,480 480,780 780,960 960,960
I'm gonna run a {},
我要为你们运行一个简单的演示程序，旋转程序。

1356
00:42:36,930 --> 00:42:38,820
0,420 450,870 870,1200 1200,1620 1620,1890
a simple demo program for

1357
00:42:38,820 --> 00:42:41,200
0,270 510,630 630,1200 1200,1860
you, the spin program.|
|

1358
00:42:41,460 --> 00:42:43,140
0,750 780,960 960,1230 1230,1320 1320,1680
{} I'm using it mostly
我主要是用它来推动创造一种可预测的情况

1359
00:42:43,140 --> 00:42:45,330
0,360 390,540 540,1320 1320,1620 1830,2190
just to drive the sort

1360
00:42:45,330 --> 00:42:47,220
0,60 60,390 390,630 660,1260 1260,1890
of create a predictable situation|
|

1361
00:42:47,220 --> 00:42:48,810
0,90 90,540 780,1140 1140,1440 1440,1590
in which we switch from
我们从一个线程切换到另一个线程，

1362
00:42:48,810 --> 00:42:50,310
0,150 150,390 390,510 510,900 1080,1500
one thread to another,| but
|但这就是这个程序，SPIN程序创建了两个进程

1363
00:42:50,310 --> 00:42:52,530
0,240 240,1020 1200,1470 1470,1980 1980,2220
this is this program, spin

1364
00:42:52,530 --> 00:42:54,960
0,480 990,1530 1530,1710 1710,2310 2310,2430
program creates two processes| and
|而且这两个过程都是永远计算的。

1365
00:42:54,960 --> 00:42:56,850
0,90 90,630 630,900 900,1350 1350,1890
the processes both compute forever.|
|

1366
00:42:57,320 --> 00:43:00,120
0,150 150,450 450,1260 1620,2250
{You,know} call fork here,|
你知道这是Call Fork，|

1367
00:43:00,320 --> 00:43:02,330
0,180 180,300 300,390 390,1080 1350,2010
I make a child {}|
我创造了一个孩子|

1368
00:43:02,420 --> 00:43:05,360
0,300 300,810 900,1770 2100,2430 2430,2940
and then forever, both children
然后永远，两个孩子都坐在这个循环里

1369
00:43:05,360 --> 00:43:06,860
0,270 270,780 780,1080 1110,1410 1410,1500
both children just sit in

1370
00:43:06,860 --> 00:43:08,240
0,210 210,450 450,570 570,1020 1020,1380
this loop| and everyone's while
|而每个人在打印一个字符的时候，

1371
00:43:08,240 --> 00:43:09,260
0,210 210,270 270,750 750,930 930,1020
print a character just,| so
|所以我们可以看到他们正在取得进展，

1372
00:43:09,260 --> 00:43:10,130
0,120 120,300 330,540 540,660 660,870
we can see they're making

1373
00:43:10,130 --> 00:43:12,350
0,630 870,1440 1710,1890 1890,2040 2040,2220
progress,| but they don't print
|但是他们不经常打印字符，

1374
00:43:12,350 --> 00:43:14,660
0,360 360,570 570,990 990,1320 1740,2310
characters very often,| and they
|而且他们从来不会故意放弃CPU，

1375
00:43:14,660 --> 00:43:16,790
0,690 720,930 930,1110 1260,1980 1980,2130
never sort of intentionally give

1376
00:43:16,790 --> 00:43:18,050
0,120 120,210 210,780 810,1050 1050,1260
up the CPU,| so what
|所以我们这里有两个，基本上是两个受计算限制的过程

1377
00:43:18,050 --> 00:43:19,100
0,90 90,270 270,390 390,540 540,1050
we have here is two,

1378
00:43:19,610 --> 00:43:21,620
0,510 510,660 660,960 960,1140 1140,2010
essentially two compute bound processes|

1379
00:43:21,740 --> 00:43:22,820
0,390 390,510 510,720 720,840 840,1080
and in order for both
为了让他们两个都跑起来，

1380
00:43:22,820 --> 00:43:23,480
0,60 60,210 210,360 360,570 570,660
of them to run,| I'm
|我将在单个CPU上运行它们，

1381
00:43:23,480 --> 00:43:24,320
0,150 150,360 360,480 480,660 660,840
gonna run them on a

1382
00:43:24,320 --> 00:43:26,340
0,570 570,1620
single CPU,|
|

1383
00:43:26,780 --> 00:43:28,460
0,540 750,1020 1020,1140 1140,1560 1560,1680
{} {xv6 - -} that
只有一个核心的xv6

1384
00:43:28,460 --> 00:43:29,990
0,240 240,450 450,660 660,1200 1260,1530
is only one core| and
|所以为了让他们两个都能执行，

1385
00:43:29,990 --> 00:43:30,650
0,150 150,240 240,390 390,510 510,660
so in order for both

1386
00:43:30,650 --> 00:43:31,880
0,60 60,150 150,240 240,840 960,1230
of them to execute,| you
|您知道有必要在这两个进程之间切换。

1387
00:43:31,880 --> 00:43:32,450
0,150 150,300 300,420 420,480 480,570
know it's going to be

1388
00:43:32,450 --> 00:43:34,820
0,630 630,1170 1350,1800
necessary to {}

1389
00:43:35,110 --> 00:43:37,990
0,510 630,1260 2250,2670 2670,2730 2730,2880
to switching between the two

1390
00:43:37,990 --> 00:43:39,480
0,810
processes.|
|

1391
00:43:40,440 --> 00:43:42,500
0,240 240,360 360,810 810,1410
Let me fire up,|
让我兴奋起来，|

1392
00:43:42,960 --> 00:43:45,120
0,360 390,900 900,1620 1650,1890 1890,2160
{} spin program under {gdb
GDB下的Spin程序。

1393
00:43:45,120 --> 00:43:46,180
0,480
-}.|
|

1394
00:43:49,760 --> 00:43:50,900
0,540

1395
00:43:51,020 --> 00:43:51,950
0,270 270,330 330,570 570,840 840,930
Around the spin program and
在旋转程序周围，你可以看到它正在打印，

1396
00:43:51,950 --> 00:43:53,180
0,90 90,210 210,420 420,570 570,1230
you can see it's printing,|
|

1397
00:43:53,210 --> 00:43:55,400
0,330 330,450 450,780 1260,1560 1560,2190
one of the two processes
两个进程之一打印转发劈开

1398
00:43:55,400 --> 00:43:56,930
0,480 480,870 870,1320 1320,1440 1440,1530
prints forward slash| and the
|另一张向后印劈开

1399
00:43:56,930 --> 00:43:58,520
0,180 180,630 630,1020 1020,1470 1470,1590
other prints backward slash| and
|你可以看到，每隔一段时间，

1400
00:43:58,520 --> 00:43:59,660
0,90 90,210 210,450 450,630 750,1140
you can see that every

1401
00:43:59,660 --> 00:44:01,640
0,270 270,330 330,840 1080,1800 1800,1980
once in {a,while},| {} {xv6
|xv6正在它们之间切换

1402
00:44:01,640 --> 00:44:03,050
0,120 120,480 480,630 630,1020 1020,1410
- -} is switching between

1403
00:44:03,050 --> 00:44:03,740
0,120 120,240 240,390 390,480 480,690
them| and only has one
|而且只有一个核心，就像我配置的那样，

1404
00:44:03,740 --> 00:44:05,060
0,510 540,660 660,780 780,870 870,1320
core the way I've configured

1405
00:44:05,060 --> 00:44:06,800
0,210 420,990 1080,1380 1380,1560 1560,1740
it,| so we see a
|所以我们看到一堆正斜杠打印

1406
00:44:06,920 --> 00:44:08,960
0,240 240,330 330,990 990,1560 1560,2040
bunch of forward slashes printing|
|

1407
00:44:08,960 --> 00:44:10,670
0,120 120,540 660,1260 1260,1320 1320,1710
and then apparently a timer
然后很明显是计时器中断，

1408
00:44:10,670 --> 00:44:12,590
0,330 330,630 630,810 810,1440 1470,1920
interrupt,| most go off {}
|大多数关闭开关，将一个CPU连接到另一个进程

1409
00:44:12,860 --> 00:44:14,660
0,720 720,810 810,1080 1080,1680 1680,1800
switch, the one CPU to

1410
00:44:14,660 --> 00:44:15,740
0,90 90,240 240,750 750,840 840,1080
the other process| and then
|然后打印另一种劈开一段时间，

1411
00:44:16,070 --> 00:44:17,090
0,540 540,660 660,810 810,960 960,1020
prints the other kind of

1412
00:44:17,090 --> 00:44:18,200
0,360 360,450 450,480 480,840 900,1110
slash for a while,| so
|所以我想要观察的是计时器开始计时，

1413
00:44:18,200 --> 00:44:19,010
0,120 120,180 180,330 330,390 390,810
what I want to observe

1414
00:44:19,010 --> 00:44:20,660
0,390 420,510 510,1080 1080,1350 1350,1650
is the timer going off,|
|

1415
00:44:20,810 --> 00:44:21,320
0,150 150,210 210,330 330,480 480,510
so I'm gonna put a
所以我要在陷阱里放一个断点，

1416
00:44:21,320 --> 00:44:22,660
0,360 360,1020
break point

1417
00:44:23,580 --> 00:44:25,140
0,330 330,1050
in trap,|
|

1418
00:44:26,940 --> 00:44:29,070
0,300 300,360 360,960 960,1320 1440,2130
and in particular at line
尤其是在陷阱中的线207处，

1419
00:44:29,070 --> 00:44:30,920
0,240 240,570 570,1290
{207 -} {in,trap},|
|

1420
00:44:35,060 --> 00:44:38,840
0,690 690,1020 1020,1470 1920,2520 2790,3780
{} which is a code
这是devintr中陷阱中的代码，

1421
00:44:39,020 --> 00:44:40,220
0,570
in

1422
00:44:40,490 --> 00:44:41,920
0,780

1423
00:44:42,840 --> 00:44:45,240
0,450 450,630 630,1020 1020,1740 2100,2400
trap in {devintr - -},|
|

1424
00:44:45,240 --> 00:44:48,090
0,390 480,1110 1140,2370 2370,2580 2580,2850
that {} recognizes that {}
意识到我们被打断了

1425
00:44:48,090 --> 00:44:49,530
0,210 210,480 480,1230 1230,1350 1350,1440
we're in interrupt| and the
|并且该中断是由定时器中断引起的。

1426
00:44:49,530 --> 00:44:51,060
0,450 450,750 780,1320 1320,1440 1440,1530
interrupt was caused by a

1427
00:44:51,060 --> 00:44:52,540
0,420 420,990
timer interrupt.|
|

1428
00:44:53,430 --> 00:44:54,900
0,630 900,1170 1170,1260 1260,1440 1440,1470
{} So I put a
所以我在这里设置了一个断点，在陷阱c 207处

1429
00:44:54,900 --> 00:44:57,870
0,210 210,480 480,1140 1140,2190 2610,2970
{breakpoint -} here, at {trap.c

1430
00:44:57,870 --> 00:45:00,300
0,240 240,1080 1380,1590 1590,2010 2010,2430
- -} {207 -}| and
|继续引爆我马上触发的陷阱，

1431
00:45:00,420 --> 00:45:03,300
0,900 1170,2460 2460,2520 2520,2790 2790,2880
continue boom the trap I

1432
00:45:03,300 --> 00:45:04,830
0,420 420,570 570,780 780,1200 1200,1530
triggers right away,| because timer
|因为计时器应用相当频繁

1433
00:45:04,830 --> 00:45:06,390
0,270 270,330 330,570 570,1020 1320,1560
apps are pretty frequent| and
|当用户陷入陷阱时，我们可以从哪里得知这一点

1434
00:45:06,390 --> 00:45:07,290
0,90 90,180 180,360 360,510 510,900
we can tell from where

1435
00:45:07,290 --> 00:45:08,700
0,210 210,600 600,780 780,1080 1080,1410
that indeed when user trap|
|

1436
00:45:08,700 --> 00:45:09,690
0,150 150,300 300,390 390,810 810,990
and {user -} trap has
并且用户陷阱已经调用devintr来处理此中断。

1437
00:45:09,690 --> 00:45:12,240
0,420 420,690 690,1170 1710,2010 2010,2550
called {devintr -} to handle

1438
00:45:12,240 --> 00:45:13,360
0,150 150,690
this interrupt.|
|

1439
00:45:13,480 --> 00:45:15,910
0,270 270,810 1020,1440 1440,2040 2040,2430
I wanna take finish to
我想用Finish离开Devintr，回到用户陷阱中。

1440
00:45:15,970 --> 00:45:17,140
0,300 300,450 450,540 540,750 750,1170
get out of {devintr -}

1441
00:45:17,140 --> 00:45:18,400
0,270 270,450 450,660 660,750 750,1260
back into {user -} trap.|
|

1442
00:45:18,940 --> 00:45:20,160
0,660

1443
00:45:20,420 --> 00:45:21,230
0,210 210,270 270,480 480,540 540,810
Because, in fact we don't,|
因为，事实上我们没有，|

1444
00:45:22,640 --> 00:45:23,900
0,240 240,420 420,720 720,870 870,1260
the code devintr [into timer]
代码转换成计时器，或者你知道的，几乎什么也没说。

1445
00:45:23,900 --> 00:45:25,250
0,120 120,300 300,630 630,900 900,1350
or {you,know} says almost nothing.|
|

1446
00:45:27,340 --> 00:45:28,780
0,450 450,660 660,750 750,1080 1080,1440
However, once we're back at
然而，一旦我们回到用户陷阱，

1447
00:45:28,840 --> 00:45:30,180
0,750
{}

1448
00:45:32,680 --> 00:45:35,260
0,630 960,1380 1380,2130
in user trap,|
|

1449
00:45:36,200 --> 00:45:37,370
0,240 240,390 390,540 540,900 900,1170
{} we can see that
我们可以从这条线上看到，

1450
00:45:37,910 --> 00:45:39,440
0,510 660,870 870,1080 1080,1260 1260,1530
from {} this line here,|
|

1451
00:45:39,440 --> 00:45:41,000
0,240 480,960 960,1140 1140,1410 1410,1560
that we just returned from
我们刚从迪金特回来。

1452
00:45:41,000 --> 00:45:43,780
0,210 210,630
{devintr -}.|
|

1453
00:45:47,860 --> 00:45:51,340
0,360 1770,2160 2610,3060 3060,3210 3210,3480
And the interesting thing about
有趣的是，

1454
00:45:51,340 --> 00:45:53,600
0,240 240,450 450,930 990,1590
this is that {},|
|

1455
00:45:54,340 --> 00:45:55,420
0,300 300,540 540,660 660,990 990,1080
{} what we're about to
我们接下来要做的是，

1456
00:45:55,420 --> 00:45:57,640
0,600 1110,1260 1260,1650 1650,2040 2040,2220
do,| I'm looking forward we're
|我期待着我们现在在这条线上

1457
00:45:57,640 --> 00:45:59,020
0,390 390,480 480,660 660,870 870,1380
currently at this line here|
|

1458
00:45:59,140 --> 00:46:01,390
0,600 660,900 900,1200 1200,1650 1650,2250
and we're looking forward to
我们期待着这个被称为“收益”的项目，

1459
00:46:01,420 --> 00:46:03,010
0,240 240,450 450,690 690,780 780,1590
{} this called the yield,|
|

1460
00:46:03,730 --> 00:46:06,010
0,510 570,1170 1170,1290 1290,1740 1740,2280
when {devintr -} return to
当魔王回来的时候，你可以从这里看到，

1461
00:46:06,040 --> 00:46:07,300
0,150 150,240 240,600 600,780 780,1260
you can see from this,|
|

1462
00:46:07,450 --> 00:46:08,980
0,390 390,450 450,960 960,1170 1170,1530
{} you return is two,|
你返回的是两个人，|

1463
00:46:08,980 --> 00:46:10,330
0,150 510,780 780,960 960,1290 1290,1350
{} two is basically the
二基本上是设备号

1464
00:46:10,330 --> 00:46:11,710
0,360 360,810 990,1200 1200,1260 1260,1380
device number| and we're going
|我们很快就会看到这一点，

1465
00:46:11,710 --> 00:46:12,820
0,60 60,270 270,540 660,990 990,1110
to see that by and

1466
00:46:12,820 --> 00:46:15,370
0,630 660,1140 1500,1740 1740,2070 2070,2550
by,| {} because which devices
|因为哪些设备到用户陷阱将呼叫让步，

1467
00:46:15,370 --> 00:46:18,010
0,510 1110,1650 1950,2280 2280,2520 2520,2640
to {} user traps going

1468
00:46:18,010 --> 00:46:19,740
0,60 60,300 300,810 810,1290
to call yield,| which
|它去往CPU并允许推动进程，

1469
00:46:19,770 --> 00:46:21,180
0,240 240,360 360,960 960,1080 1080,1410
go to CPU and allows

1470
00:46:21,180 --> 00:46:23,070
0,330 330,450 450,1140 1590,1710 1710,1890
pushing the process,| you'll see
你很快就会看到这一点，

1471
00:46:23,070 --> 00:46:24,390
0,150 150,240 240,270 270,630 840,1320
that in a moment,| meantime
|同时，让我们看看中断发生时当前正在执行的是什么。

1472
00:46:24,390 --> 00:46:25,710
0,390 390,660 660,750 750,1050 1050,1320
let's look at what was

1473
00:46:25,710 --> 00:46:27,540
0,570 570,1200 1200,1350 1350,1440 1440,1830
currently executing when the interrupt

1474
00:46:27,540 --> 00:46:29,190
0,420 600,990 990,1260 1260,1350 1350,1650
happened.| I'm going to print
|我要打印p，

1475
00:46:29,190 --> 00:46:30,320
0,630
p,|
|

1476
00:46:31,010 --> 00:46:32,660
0,270 270,420 420,900 1020,1320 1320,1650
{} the variable p holds
变量p保存指向当前进程结构proc的指针。

1477
00:46:32,660 --> 00:46:34,310
0,180 630,930 930,1020 1020,1230 1260,1650
a pointer to the current

1478
00:46:34,310 --> 00:46:36,520
0,570 570,1080 1080,1650
processes struct proc.|
|

1479
00:46:36,810 --> 00:46:38,140
0,750

1480
00:46:38,890 --> 00:46:40,030
0,330 330,390 390,750 750,900 900,1140
Okay, the question what makes
好的，问题是是什么让每个进程的内核线程不同。

1481
00:46:40,030 --> 00:46:42,790
0,210 210,780 780,1200 1200,1740 2190,2760
each processes kernel thread different.|
|

1482
00:46:43,260 --> 00:46:46,110
0,480 480,1530 1890,2130 2130,2220 2220,2850
Every process has a separate
每个进程都有单独的内核线程，

1483
00:46:46,110 --> 00:46:47,780
0,480 480,1200
kernel thread,|
|

1484
00:46:47,930 --> 00:46:50,090
0,450 450,690 690,1080 1080,1830 1830,2160
there's really two things that
确实有两件事可以区分不同的进程内核线程，

1485
00:46:50,090 --> 00:46:52,490
0,990 990,1260 1260,1770 1770,2130 2130,2400
differentiate different processes kernel thread,|
|

1486
00:46:52,490 --> 00:46:53,240
0,180 180,390 390,480 480,630 630,750
because more than one could
因为可能不止一个在不同的内核上执行。

1487
00:46:53,240 --> 00:46:55,670
0,90 90,690 690,1020 1500,1770 1770,2430
be executing on different cores.|
|

1488
00:46:57,650 --> 00:46:58,910
0,300 300,420 420,840 840,1050 1050,1260
One is indeed that every
其一确实是每个进程都有单独的内核堆栈

1489
00:46:58,910 --> 00:47:00,980
0,780 930,1140 1140,1200 1200,1530 1530,2070
process has a separate kernel

1490
00:47:01,400 --> 00:47:02,840
0,540 540,630 630,810 810,1020 1020,1440
stack| and that's what's pointed
|这就是struct proc的kstack元素所指向的

1491
00:47:02,840 --> 00:47:04,610
0,120 120,270 270,570 990,1380 1380,1770
to by that {kstack -}

1492
00:47:04,610 --> 00:47:06,710
0,450 450,540 540,900 900,1380 1860,2100
element of struct proc| and
|另一个是，

1493
00:47:06,710 --> 00:47:08,680
0,120 120,390 390,780 780,1440
the other is that,|
|

1494
00:47:09,530 --> 00:47:11,040
0,900

1495
00:47:13,490 --> 00:47:16,600
0,510 810,1500 1500,2190
{} early in,
早些时候，当用户陷入陷阱时，你知道，当中断发生时，蹦床会调用C代码。

1496
00:47:16,600 --> 00:47:17,890
0,240 240,540 540,930 930,1080 1080,1290
when user trap which is

1497
00:47:17,890 --> 00:47:18,730
0,60 60,120 120,240 240,570 570,840
you know the C code

1498
00:47:18,730 --> 00:47:20,140
0,120 120,870
is called,

1499
00:47:20,380 --> 00:47:22,210
0,270 270,450 450,1020 1020,1440 1440,1830
{} by trampoline, when interrupt

1500
00:47:22,210 --> 00:47:24,340
0,510
occurs.|
|

1501
00:47:25,640 --> 00:47:26,780
0,180 180,360 360,840 840,960 960,1140
We can tell by this
我们可以通过这个调用他们，任何，任何内核代码，

1502
00:47:26,780 --> 00:47:28,700
0,270 270,420 420,630 630,1380
call them by any,

1503
00:47:28,700 --> 00:47:30,320
0,270 270,570 570,930 930,1200 1290,1620
any kernel code,| can tell
|可以通过调用myproc来判断当前CPU上正在运行哪些进程。

1504
00:47:30,320 --> 00:47:32,270
0,150 150,480 480,720 720,1230 1260,1950
by calling {myproc -} what

1505
00:47:32,270 --> 00:47:34,700
0,540 780,1560 1560,1710 1710,2070 2130,2430
the processes is running on

1506
00:47:34,700 --> 00:47:36,620
0,90 90,480 480,1350
the current CPU.|
|

1507
00:47:36,620 --> 00:47:37,550
0,180 180,360 360,600 600,720 720,930
And that's another thing that
这是另一个与众不同的地方，

1508
00:47:37,550 --> 00:47:39,860
0,1110 1110,1740
differentiates {},|
|

1509
00:47:40,500 --> 00:47:42,750
0,120 120,600 600,960 1710,1890 1890,2250
that allows each that allows
这允许每个允许内核代码告诉

1510
00:47:42,750 --> 00:47:43,890
0,300 300,510 510,600 600,750 750,1140
kernel code to tell| what
|它是哪个进程的一部分，即内核线程正在执行哪些进程

1511
00:47:43,890 --> 00:47:45,420
0,690 690,870 870,1140 1140,1290 1380,1530
process it's part of that

1512
00:47:45,420 --> 00:47:47,160
0,180 180,720 720,1260 1260,1530 1530,1740
is which processes kernel thread

1513
00:47:47,160 --> 00:47:48,540
0,150 150,690 690,1110 1110,1230 1230,1380
is executing| and what {myproc
|而myproc基本上使用的是tp寄存器。

1514
00:47:48,540 --> 00:47:49,620
0,330 330,390 390,570 570,900 900,1080
-} {} does basically use

1515
00:47:49,620 --> 00:47:50,940
0,120 120,540 540,1020 1020,1200 1200,1320
the tp register| which you
|您可能还记得，设置为包含当前核心HARID或核心编号，

1516
00:47:50,940 --> 00:47:53,460
0,120 120,690 1140,1800 2010,2250 2250,2520
may recall, {} is set

1517
00:47:53,460 --> 00:47:55,200
0,150 150,240 240,930 930,1230 1320,1740
up to contain the current

1518
00:47:55,410 --> 00:47:56,500
0,720
cores

1519
00:47:56,500 --> 00:47:58,300
0,510 510,960 960,1080 1080,1350 1350,1800
{hartid -} or core number,|
|

1520
00:47:58,360 --> 00:47:59,500
0,240 240,450 450,660 660,780 780,1140
it uses that to index
它使用它来索引到一个结构数组中，

1521
00:47:59,500 --> 00:48:01,000
0,210 210,270 270,810 810,900 900,1500
into an array of structures,|
|

1522
00:48:01,000 --> 00:48:02,950
0,180 570,1050 1050,1260 1260,1470 1470,1950
that say for each core
也就是说，对于调度器设置的每个内核

1523
00:48:02,980 --> 00:48:04,840
0,120 120,210 210,660 660,1290 1320,1860
that the scheduler sets| whenever
|每当它切换进程以指示每个内核

1524
00:48:04,840 --> 00:48:06,940
0,60 60,450 450,1020 1020,1290 1560,2100
it switches processes to indicate

1525
00:48:06,940 --> 00:48:08,230
0,120 120,270 270,480 480,840 840,1290
for each core| which process
|哪个进程在该核心上运行。

1526
00:48:08,230 --> 00:48:09,490
0,120 120,480 480,660 660,840 840,1260
is running on that core.|
|

1527
00:48:10,660 --> 00:48:12,160
0,420 540,810 810,960 960,1170 1170,1500
{} And so that's how
这就是不同内核的区别。

1528
00:48:12,220 --> 00:48:14,360
0,270 270,690 690,780 780,1500
different kernels are differentiated.|
|

1529
00:48:15,730 --> 00:48:16,420
0,270 270,420 420,450 450,570 570,690
Okay, so I was going
好的，我打算用这个p值，

1530
00:48:16,420 --> 00:48:17,650
0,60 60,150 150,330 330,510 510,1230
to use that p value,|
|

1531
00:48:17,710 --> 00:48:20,050
0,750 1170,1890 1890,1980 1980,2160 2160,2340
the name and that p
名称和p值以确定哪个进程正在运行，

1532
00:48:20,050 --> 00:48:20,860
0,240 240,300 300,480 480,540 540,810
value to figure out what

1533
00:48:20,860 --> 00:48:22,600
0,510 510,660 660,1050 1050,1440 1440,1740
process is running,| {xv6 -}
|Xv6记住的名字就是旋转过程，就像预期的那样，

1534
00:48:22,600 --> 00:48:23,560
0,450 450,510 510,720 720,840 840,960
remembers the name it's that

1535
00:48:23,560 --> 00:48:25,990
0,390 390,1080 1110,1530 1560,2160 2160,2430
spin process just exactly as

1536
00:48:25,990 --> 00:48:28,150
0,690 930,1530 1590,1830 1830,1950 1950,2160
expected,| {} there were two
|我想有两个进程ID分别为3和4。

1537
00:48:28,150 --> 00:48:29,620
0,90 90,570 840,1080 1080,1350 1350,1470
of them, I think with

1538
00:48:29,620 --> 00:48:31,570
0,480 480,960 960,1200 1200,1350 1350,1950
process ids three and four.|
|

1539
00:48:32,150 --> 00:48:33,380
0,630
Oops.|
哎呀。|

1540
00:48:34,680 --> 00:48:36,000
0,330 330,450 450,720 720,1110 1110,1320
{} We're currently executed again
我们现在再次执行ID为3的进程，

1541
00:48:36,000 --> 00:48:37,890
0,420 420,750 750,1260 1440,1650 1650,1890
process id three,| so after
|所以在切换之后，我们应该在进程id 4中，

1542
00:48:37,890 --> 00:48:39,090
0,60 60,360 360,510 510,1110 1110,1200
the switch we'd expect to

1543
00:48:39,090 --> 00:48:40,080
0,180 180,450
be in

1544
00:48:40,110 --> 00:48:41,820
0,450 450,780 780,1290 1320,1470 1470,1710
process id four,| the other
|另一个旋转过程，

1545
00:48:41,820 --> 00:48:44,730
0,330 330,1080 1350,2040 2490,2730 2730,2910
spin process,| {} how {can,we}
|我们如何才能查看陷印框中保存的用户寄存器。

1546
00:48:44,730 --> 00:48:45,390
0,120 120,240 240,480 480,570 570,660
we can look at the

1547
00:48:45,390 --> 00:48:47,610
0,720 750,1350 1350,2070 2070,2160 2160,2220
saved user registers in the

1548
00:48:47,610 --> 00:48:49,100
0,360 360,780
{trapframe -}.|
|

1549
00:48:54,600 --> 00:48:55,740
0,210 210,420 420,540 540,660 660,1140
And these are the 32
这些是蹦床代码保存用户状态的方式保存的32个寄存器，

1550
00:48:55,740 --> 00:48:59,400
0,1170 1200,1500 1500,1890 2040,2970 2970,3660
registers that a trampoline code

1551
00:48:59,430 --> 00:49:01,110
0,510 510,600 600,1110 1170,1380 1380,1680
saves a way to save

1552
00:49:01,110 --> 00:49:02,610
0,90 90,390 390,780 1020,1410 1410,1500
the user state,| there's the
存在用户RA返回地址寄存器用户堆栈指针，

1553
00:49:02,610 --> 00:49:05,490
0,780 1620,1950 1950,2280 2280,2550 2550,2880
user {ra -} return address

1554
00:49:05,490 --> 00:49:08,130
0,420 420,630 630,1050 1050,1620 2100,2640
register user stack pointer {},|
|

1555
00:49:08,520 --> 00:49:10,410
0,330 330,630 630,1050 1050,1200 1590,1890
user program counter at hex
祸不单行62处的用户程序计数器。

1556
00:49:10,410 --> 00:49:11,960
0,660
62.|
|

1557
00:49:12,050 --> 00:49:13,490
0,210 210,510 510,690 690,1110 1110,1440
{} These are familiar things
这些都是我们在观察陷阱时熟悉的东西。

1558
00:49:13,490 --> 00:49:14,930
0,330 330,750 750,840 840,1110 1110,1440
from when we looked at

1559
00:49:15,530 --> 00:49:17,080
0,1050
traps.|
|

1560
00:49:17,290 --> 00:49:18,250
0,270 300,570 570,720 720,870 870,960
And you may be the
你可能最感兴趣的是，

1561
00:49:18,250 --> 00:49:20,170
0,270 270,750 750,1080 1080,1380 1560,1920
most interest is that {},|
|

1562
00:49:23,290 --> 00:49:24,370
0,150 150,390 390,630 630,960 960,1080
the {trapframe -} saves the
陷阱帧保存用户程序计数器和该值62，

1563
00:49:24,370 --> 00:49:26,020
0,630 660,1020 1020,1380 1380,1500 1500,1650
user program counter and that

1564
00:49:26,020 --> 00:49:28,990
0,270 270,1020 2070,2220 2220,2310 2310,2970
value 62,| if we cared,
|如果我们关心，我们可以查看spin.c的汇编代码。

1565
00:49:29,740 --> 00:49:31,100
0,780
{}

1566
00:49:31,630 --> 00:49:33,280
0,210 210,360 360,630 630,1260 1530,1650
we can look in the

1567
00:49:33,280 --> 00:49:35,050
0,540 540,1020 1020,1170 1170,1500 1500,1770
assembly code for {spin.c -

1568
00:49:35,050 --> 00:49:36,200
0,570
-}.|
|

1569
00:49:36,540 --> 00:49:37,700
0,690
Oops,
哎呀，Spin.asm找62

1570
00:49:37,850 --> 00:49:39,020
0,180 180,510 510,720 720,900 900,1170
{} {spin.asm - - -}

1571
00:49:39,020 --> 00:49:40,840
0,210 210,300 300,1140
look for 62,|
|

1572
00:49:41,100 --> 00:49:42,090
0,300 300,420 420,540 540,720 720,990
now we can see that
现在我们可以看到，它欠一个中断定时器，

1573
00:49:42,300 --> 00:49:44,760
0,510 870,1110 1110,1590 1590,1890 1890,2460
owes a interrupt timer,| interrupt
|在自旋无限循环中的该加法指令期间发生中断，

1574
00:49:44,760 --> 00:49:46,890
0,300 300,570 570,780 780,1200 1200,2130
occurred during this add instruction

1575
00:49:46,980 --> 00:49:49,740
0,330 330,660 1170,1650 1650,2130 2130,2760
in that infinite loop in

1576
00:49:49,860 --> 00:49:51,450
0,630 840,1020 1020,1320 1320,1470 1470,1590
spin,| so it's not too
|所以这并不太令人惊讶。

1577
00:49:51,450 --> 00:49:52,460
0,450
surprising.|
|

1578
00:49:55,390 --> 00:49:58,450
0,450 450,750 750,1050 1050,1890 2400,3060
Okay, so back to a
好了，回到刚刚返回的陷阱代码[7]，

1579
00:49:59,110 --> 00:50:00,940
0,420 420,1140 1170,1500 1500,1590 1590,1830
trap code [seven] {} just

1580
00:50:00,940 --> 00:50:02,680
0,690 840,1110 1110,1230 1230,1320 1320,1740
returned,| I'm going to take
|我要走几步把我们带到，

1581
00:50:02,710 --> 00:50:04,420
0,390 420,810 810,900 900,1050 1050,1710
{} step a few times

1582
00:50:04,420 --> 00:50:06,220
0,330 330,720 900,1350 1350,1620 1620,1800
to {} get us to

1583
00:50:06,220 --> 00:50:07,260
0,480
the,|
|

1584
00:50:07,640 --> 00:50:09,040
0,630

1585
00:50:09,130 --> 00:50:10,870
0,540 540,690 690,990 990,1290 1320,1740
just being about to execute
就在即将执行这一收益率的时候。

1586
00:50:10,870 --> 00:50:12,260
0,150 150,720
this yield.|
|

1587
00:50:12,260 --> 00:50:13,160
0,270 270,600 600,660 660,840 840,900
And yield is sort of
而产量在某种程度上是这个过程的第一步

1588
00:50:13,160 --> 00:50:14,000
0,60 60,330 330,630 630,720 720,840
the first step in the

1589
00:50:14,000 --> 00:50:15,620
0,480 480,630 990,1440 1440,1530 1530,1620
process| of giving up the
|放弃CPU切换到调度器，

1590
00:50:15,620 --> 00:50:17,090
0,420 420,810 810,870 870,960 960,1470
CPU switching to the scheduler,|
|

1591
00:50:17,090 --> 00:50:18,800
0,270 270,330 330,870 900,1170 1170,1710
letting the scheduler choose another
让调度器选择进程中的另一个内核线程来运行。

1592
00:50:19,190 --> 00:50:20,840
0,300 300,540 540,630 630,1140 1140,1650
kernel thread in process {to,run}.|
|

1593
00:50:22,510 --> 00:50:23,860
0,720

1594
00:50:24,240 --> 00:50:26,070
0,480 480,600 600,1140 1170,1530 1530,1830
Alright, so let's actually step
好的，那么让我们真正进入屈服阶段，

1595
00:50:26,070 --> 00:50:28,710
0,150 150,930 1410,1590 1590,1740 1740,2640
into yield,| now we're yields.|
|现在我们是屈服了。|

1596
00:50:28,860 --> 00:50:30,080
0,600

1597
00:50:30,110 --> 00:50:30,980
0,120 120,180 180,270 270,330 330,870
If you have a question.|
如果你有问题的话。|

1598
00:50:31,580 --> 00:50:32,540
0,330
NO.|
不是的。|

1599
00:50:43,450 --> 00:50:47,500
0,510 540,720 720,1290 2610,3390
Okay, we're yield {},|
好的，我们投降了，|

1600
00:50:47,500 --> 00:50:48,520
0,540 540,720 720,750 750,960 960,1020
yield does a couple of
屈服做了几件事，

1601
00:50:48,520 --> 00:50:52,180
0,660 660,1230 1260,1980 2550,3480 3480,3660
things,| it a acquires the
|它获得该进程的锁，

1602
00:50:52,180 --> 00:50:54,790
0,510 690,870 870,1140 1140,2190 2220,2610
lock for this process,| because
|因为它即将对这个过程进行一系列的改变，

1603
00:50:54,790 --> 00:50:55,390
0,120 120,330 330,390 390,510 510,600
it's about to make a

1604
00:50:55,390 --> 00:50:56,440
0,270 270,360 360,780 780,870 870,1050
bunch of changes to this

1605
00:50:56,440 --> 00:50:58,060
0,630 630,960 960,1140 1140,1380 1380,1620
process,| and it doesn't want
|而且它不想要任何其他的

1606
00:50:58,060 --> 00:51:00,160
0,270 270,900 1080,1590 1590,1740 1740,2100
any other| and in fact
|事实上，在它放弃锁之前，这个过程的状态会有点不一致

1607
00:51:00,430 --> 00:51:01,240
0,360 360,420 420,600 600,720 720,810
until it gives up the

1608
00:51:01,240 --> 00:51:02,140
0,300 300,390 390,690 690,750 750,900
lock, the state of this

1609
00:51:02,140 --> 00:51:03,250
0,480 480,600 600,750 750,960 960,1110
process will be sort of

1610
00:51:03,340 --> 00:51:06,100
0,1110 1200,1920 1920,2070 2070,2460 2460,2760
inconsistent| like for example, it's
|例如，这是关于收益率，即将流程的状态更改为可运行，

1611
00:51:06,250 --> 00:51:07,600
0,360 360,660 660,750 750,1260 1260,1350
about yield is about to

1612
00:51:07,600 --> 00:51:08,530
0,330 330,420 420,780 780,870 870,930
change the state of the

1613
00:51:08,530 --> 00:51:09,460
0,420 420,570 570,750 750,840 840,930
process to {runnable - -},|
|

1614
00:51:09,460 --> 00:51:11,680
0,630 1080,1320 1350,1500 1500,1620 1620,2220
which would you know indicates
你会知道这表明，

1615
00:51:11,680 --> 00:51:12,420
0,330
that,|
|

1616
00:51:12,420 --> 00:51:13,710
0,60 60,480 480,600 600,930 930,1290
the process is not running,
该进程未在运行，但希望，

1617
00:51:13,710 --> 00:51:15,330
0,180 180,300 300,570 570,930 1230,1620
but would like to,| but
|但是这个过程运行正常，

1618
00:51:15,330 --> 00:51:17,550
0,120 120,510 510,720 720,1230 1800,2220
this process is running right,|
|

1619
00:51:17,640 --> 00:51:18,390
0,180 180,300 300,450 450,690 690,750
I mean we're running the
我是说我们现在正在运行程序，

1620
00:51:18,390 --> 00:51:19,650
0,360 360,570 570,900 900,1110 1110,1260
process right now,| that's what's
|这就是正在执行的是该进程的内核线程

1621
00:51:19,650 --> 00:51:20,910
0,510 510,630 630,690 690,990 990,1260
executing is the kernel thread

1622
00:51:20,910 --> 00:51:22,530
0,120 120,270 270,960 1110,1350 1350,1620
for this process| and so
|所以获得这个锁所做的众多事情之一就是，

1623
00:51:22,530 --> 00:51:23,640
0,360 360,690 690,750 750,840 840,1110
the one of the many

1624
00:51:23,640 --> 00:51:24,780
0,210 210,300 300,630 630,840 840,1140
things that acquire this lock

1625
00:51:24,780 --> 00:51:26,550
0,360 360,750 1110,1410 1410,1680 1680,1770
does is,| {} makes it
|所以即使我们刚刚改变了可运行的状态，

1626
00:51:26,550 --> 00:51:27,750
0,180 180,510 600,930 930,1080 1080,1200
so that even though we

1627
00:51:27,750 --> 00:51:28,740
0,210 210,450 450,510 510,750 750,990
just changed the state {runnable

1628
00:51:28,740 --> 00:51:30,640
0,330 360,900 900,1470
-},| no other
|没有其他内核调度线程会查看此进程

1629
00:51:30,640 --> 00:51:32,350
0,480 480,990 990,1290 1290,1470 1470,1710
cores scheduling thread will look

1630
00:51:32,350 --> 00:51:34,690
0,90 90,270 270,1080 1230,1980 2040,2340
at this process| and because
|因为锁住了

1631
00:51:34,690 --> 00:51:36,760
0,90 90,660 870,1530 1590,1950 1950,2070
of lock| and see that
|确保它是可运行的，并尝试运行它

1632
00:51:36,760 --> 00:51:37,660
0,150 150,480 480,570 570,720 720,900
it's runnable and try to

1633
00:51:37,660 --> 00:51:39,040
0,210 210,360 630,990 990,1110 1110,1380
run it| while we're still
|当我们还在这个核心上运行它将会是一场灾难，对吧，

1634
00:51:39,040 --> 00:51:40,000
0,270 270,390 390,480 480,630 630,960
running it on this core

1635
00:51:40,030 --> 00:51:41,200
0,210 210,300 300,330 330,900 900,1170
would be a disaster right,|
|

1636
00:51:41,200 --> 00:51:43,900
0,240 240,330 330,630 630,1410 1950,2700
running the same process onto
在不同的内核上运行相同的进程，

1637
00:51:43,900 --> 00:51:45,640
0,240 240,870 900,1200 1200,1560 1560,1740
different cores,| {you,know} process has
|您知道进程只有一个堆栈，

1638
00:51:45,640 --> 00:51:47,740
0,210 210,480 480,1140 1410,1950 1950,2100
only one stack,| so that
这意味着就像两个不同的内核在同一堆栈上调用[子例程]，

1639
00:51:47,740 --> 00:51:48,940
0,210 210,390 390,600 600,870 870,1200
means like two different cores

1640
00:51:48,940 --> 00:51:50,380
0,360 390,810 810,1110 1110,1350 1350,1440
are calling {[subroutines] -} on

1641
00:51:50,380 --> 00:51:51,670
0,60 60,330 330,690 690,900 900,1290
the same stack,| which is
|这只是一个灾难的秘诀。

1642
00:51:52,510 --> 00:51:53,920
0,330 330,390 390,780 780,870 870,1410
just a recipe for disaster.|
|

1643
00:51:54,680 --> 00:51:56,390
0,390 900,1200 1200,1320 1320,1440 1440,1710
So we take the lock
所以我们把锁拿出来，

1644
00:51:56,390 --> 00:51:58,780
0,360
out,|
|

1645
00:51:59,380 --> 00:52:01,480
0,660 930,1290 1290,1710 1710,1830 1830,2100
we, yield changes the state
我们，让位于可运行状态。

1646
00:52:01,480 --> 00:52:03,430
0,150 150,360 360,420 420,840 1260,1950
to {runnable - -} {}.|
|

1647
00:52:04,130 --> 00:52:05,030
0,300 300,420 420,570 570,810 810,900
And what this means is
这意味着，

1648
00:52:05,030 --> 00:52:06,400
0,270 390,510 510,780
that,| you know
|你知道我们终于放弃了。

1649
00:52:06,400 --> 00:52:08,290
0,210 210,720 720,990 990,1350 1350,1890
we finally given up the.|
|

1650
00:52:09,450 --> 00:52:10,780
0,690

1651
00:52:11,960 --> 00:52:13,130
0,270 270,420 420,720 720,1050 1050,1170
When we finally yield the
当我们最终放弃CPU时

1652
00:52:13,130 --> 00:52:14,150
0,420 420,510 510,780 780,930 930,1020
CPU| and get up and
|并启动并切换调度程序进程，

1653
00:52:14,150 --> 00:52:15,650
0,330 330,450 450,900 900,1320 1320,1500
switch the scheduler process,| this
|该状态将保持在该可运行状态，

1654
00:52:15,650 --> 00:52:16,490
0,270 270,390 390,540 540,780 780,840
state will be left in

1655
00:52:16,490 --> 00:52:17,690
0,180 180,510 510,960 960,1080 1080,1200
this runnable state,| so that
|这样它就会再次运行，

1656
00:52:17,690 --> 00:52:19,220
0,60 60,300 300,480 480,1020 1290,1530
it will run again,| because
|因为毕竟这是一个计时器中断，

1657
00:52:19,220 --> 00:52:19,880
0,240 240,300 300,450 450,600 600,660
after all this was a

1658
00:52:19,880 --> 00:52:21,800
0,450 450,870 870,1080 1200,1860 1860,1920
timer interrupt,| that interrupted a
|这中断了正在运行的用户级进程，

1659
00:52:21,800 --> 00:52:23,090
0,270 270,510 510,750 750,1170 1170,1290
running user level process,| that
|想要继续计算的人。

1660
00:52:23,090 --> 00:52:24,590
0,180 180,390 390,480 480,1020 1020,1500
would like to continue computing.|
|

1661
00:52:25,790 --> 00:52:27,140
0,300 300,450 450,630 630,1020 1020,1350
We're gonna leave state runnable,|
我们要离开州政府，|

1662
00:52:27,140 --> 00:52:27,770
0,150 150,240 240,300 300,480 480,630
so that it will run
这样，一旦调度程序决定，它就会再次运行。

1663
00:52:27,770 --> 00:52:29,450
0,330 330,750 780,1140 1140,1560 1590,1680
again, as soon as the

1664
00:52:29,450 --> 00:52:31,080
0,390 390,870 870,990
scheduler decides to.|
|

1665
00:52:33,290 --> 00:52:36,680
0,660 1290,1470 1470,2070 2640,3240 3270,3390
{} And then um the
然后，嗯，唯一的另一件事是，

1666
00:52:36,680 --> 00:52:38,300
0,150 150,330 330,570 570,990
only other thing that,|
|

1667
00:52:40,380 --> 00:52:41,740
0,540

1668
00:52:44,090 --> 00:52:45,440
0,390 390,660 660,900 900,1140 1140,1350
{} yield does is call
Year所做的就是调用此调度程序函数。

1669
00:52:45,440 --> 00:52:47,300
0,150 150,660 660,1170
this scheduler function.|
|

1670
00:52:48,580 --> 00:52:49,360
0,240 240,300 300,570 570,690 690,780
{So,I'm,going} to step into the
因此，我将单步执行调度程序功能。

1671
00:52:49,360 --> 00:52:50,940
0,420 420,1020
scheduler function.|
|

1672
00:52:51,210 --> 00:52:52,680
0,450 450,660 660,930 930,1230 1230,1470
I'll show this whole thing
我会在这里展示整个过程。

1673
00:52:52,680 --> 00:52:53,820
0,510
here.|
|

1674
00:53:01,470 --> 00:53:04,050
0,360 1560,2010 2010,2100 2100,2400 2400,2580
{} {This,scheduler} is something does
这个调度程序几乎什么都不做，

1675
00:53:04,050 --> 00:53:04,830
0,300 300,540 540,630 630,750 750,780
almost nothing,| it has a
|它有一堆支票，

1676
00:53:04,830 --> 00:53:06,270
0,150 150,240 240,960 1050,1380 1380,1440
bunch of checks,| {} it
|它做了一大堆[理智的]检查和恐慌

1677
00:53:06,270 --> 00:53:07,500
0,150 150,750 750,990 990,1140 1140,1230
does a whole bunch of

1678
00:53:07,500 --> 00:53:09,480
0,450 450,1020 1020,1140 1140,1860 1860,1980
[sanity] checks and panics| and
|其原因实际上是，

1679
00:53:09,480 --> 00:53:10,560
0,120 120,450 450,540 540,810 810,1080
the reason for that is

1680
00:53:10,560 --> 00:53:12,940
0,390 390,660
actually that,|
|

1681
00:53:13,550 --> 00:53:15,950
0,360 360,1200 1200,1350 1350,2160 2160,2400
this code in xv6 over
xv6中的这段代码在您的生命周期中一直是最容易出错的代码之一。

1682
00:53:15,950 --> 00:53:18,020
0,510 540,870 870,1020 1020,1440 1440,2070
its many your lifetime had

1683
00:53:18,320 --> 00:53:20,270
0,420 420,720 720,810 810,1440 1590,1950
been among the most bug

1684
00:53:20,270 --> 00:53:22,400
0,570 690,870 870,1020 1020,1260 1260,2130
[prone]| and have most surprises
|有最多的惊喜和不愉快的惊喜，

1685
00:53:22,940 --> 00:53:25,160
0,540 570,1350 1350,1890 1890,2040 2040,2220
{} unhappy surprises,| so there's
|所以这里有很多理智的检查和恐慌，

1686
00:53:25,160 --> 00:53:26,400
0,60 60,390 390,720
a lot of

1687
00:53:27,000 --> 00:53:28,650
0,540 540,900 900,1050 1050,1470 1470,1650
sanity checks and panics here,|
|

1688
00:53:28,650 --> 00:53:29,780
0,450
because,
因为，因为经常会有与此代码相关的错误。

1689
00:53:30,820 --> 00:53:32,620
0,180 180,360 360,720 720,1260 1260,1800
because there's often bugs associated

1690
00:53:32,620 --> 00:53:33,820
0,90 90,210 210,630
with this code.|
|

1691
00:53:35,650 --> 00:53:37,660
0,270 270,360 360,1320 1350,1710 1710,2010
Alright, I'm gonna skip over
好的，我会跳过这些理智检查

1692
00:53:37,660 --> 00:53:41,980
0,810 1830,2430 2430,2880 2880,3180 3780,4320
these sanity checks| and {}
|然后继续往前走，

1693
00:53:42,130 --> 00:53:44,060
0,660 660,810 810,1380
proceed to the,|
|

1694
00:53:44,060 --> 00:53:45,540
0,810

1695
00:53:46,850 --> 00:53:48,110
0,330 330,390 390,870 870,1020 1020,1260
called to switch, this called
调用Switch，这个调用Switch才是真正的动作发生的地方，

1696
00:53:48,110 --> 00:53:48,890
0,120 120,390 390,510 510,660 660,780
to switch is where the

1697
00:53:48,890 --> 00:53:49,850
0,210 210,480 480,780 780,900 900,960
real action happens,| this is
|这称为开关将保存p->内容中的当前内核线程寄存器，

1698
00:53:49,850 --> 00:53:50,660
0,180 180,270 270,570 570,660 660,810
called the switch is going

1699
00:53:50,660 --> 00:53:52,730
0,150 360,870 870,1230 1230,1410 1410,2070
to save away the current

1700
00:53:53,730 --> 00:53:56,730
0,510 510,990 990,1980 1980,2490 2520,3000
kernel threads registers in {p->content

1701
00:53:56,730 --> 00:53:58,080
0,600 600,780 780,870 870,960 960,1350
-},| which is the current
|该寄存器是当前进程保存的内核线程上下文寄存器集，

1702
00:53:58,080 --> 00:54:00,720
0,990 1080,1500 1500,1710 1710,1950 1950,2640
processes saved kernel thread context

1703
00:54:00,750 --> 00:54:03,330
0,270 270,390 390,450 450,1200 1890,2580
save set of registers,| c
|c箭头上下文，c是指向此核心的结构CPU的指针，

1704
00:54:03,330 --> 00:54:05,010
0,240 240,780 780,1080 1080,1290 1290,1680
arrow context, c is the

1705
00:54:05,520 --> 00:54:07,890
0,330 330,450 450,960 960,1890 1920,2370
pointer to this core's struct

1706
00:54:07,890 --> 00:54:11,070
0,870 1200,1800 1890,2400 2400,2790 2790,3180
cpu,| {} struct cpu has
|结构CPU具有保存该核的调度程序线程的寄存器的上下文，

1707
00:54:11,690 --> 00:54:14,030
0,810 810,900 900,1140 1140,1890 1890,2340
context to save registers of

1708
00:54:14,180 --> 00:54:16,550
0,450 450,1260 1290,1830 1830,2310 2310,2370
this core's scheduler threads,| we're
|我们将从这个帖子切换

1709
00:54:16,550 --> 00:54:17,540
0,120 120,210 210,300 300,750 750,990
going to be switching from

1710
00:54:17,540 --> 00:54:18,860
0,240 240,600 600,750 840,1200 1200,1320
this thread| and saving this
|并保存该线程状态以恢复该核的调度器的线程状态

1711
00:54:18,860 --> 00:54:20,990
0,240 240,690 780,1590 1590,1710 1710,2130
thread state restoring the thread

1712
00:54:20,990 --> 00:54:24,410
0,450 450,900 1380,2430 2460,3150 3150,3420
state of {this,core's} scheduler| and
|并继续执行该核的核的调度器线程。

1713
00:54:24,830 --> 00:54:26,330
0,630 630,720 720,1260 1260,1350 1350,1500
continuing the execution of this

1714
00:54:26,330 --> 00:54:30,320
0,810 840,1500 1710,2730 2850,3660
core's core's scheduler thread.|
|

1715
00:54:32,760 --> 00:54:34,200
0,330 330,540 540,750 750,1080 1080,1440
Okay, so let's see what,|
好的，让我们看看是什么，|

1716
00:54:34,200 --> 00:54:35,280
0,420

1717
00:54:36,250 --> 00:54:37,660
0,300 300,570 570,690 690,1080 1080,1410
{} let's take a quick
让我们快速预览一下上下文

1718
00:54:37,750 --> 00:54:41,080
0,840 1140,1770 1860,2430 2460,3240 3240,3330
preview at the context| that
|我们将切换到

1719
00:54:41,080 --> 00:54:42,010
0,90 90,210 210,300 300,390 390,930
we're going to be switching

1720
00:54:42,010 --> 00:54:43,750
0,540 1020,1290 1290,1440 1440,1560 1560,1740
to| and I can get
我可以得出结论，

1721
00:54:43,750 --> 00:54:45,220
0,270 270,510 510,660 660,930
that turns out that,|
|

1722
00:54:45,860 --> 00:54:47,810
0,360 360,720 720,1020 1020,1440 1440,1950
can't actually print {c->context -},|
无法实际打印c->上下文，|

1723
00:54:47,810 --> 00:54:48,410
0,90 90,150 150,390 390,450 450,600
but I happen to know
但我碰巧知道c打印到零CPU，

1724
00:54:48,410 --> 00:54:51,230
0,120 120,780 1050,1830 1830,2070 2070,2820
that c prints to cpus

1725
00:54:51,230 --> 00:54:53,480
0,1110 1200,1650 1710,1950 1950,2100 2100,2250
zero,| just because we're on
|就因为我们和核心在零度线上，

1726
00:54:53,480 --> 00:54:54,740
0,150 150,510 510,660 660,1080 1080,1260
the zero with core,| there's
|只有一个核心，

1727
00:54:54,740 --> 00:54:56,780
0,120 120,330 330,810 1080,1890 1890,2040
only one core,| and I
|我可以打印它的上下文。

1728
00:54:56,780 --> 00:54:58,800
0,120 120,330 330,450 450,1170
can print its context.|
|

1729
00:54:59,740 --> 00:55:00,960
0,660

1730
00:55:00,960 --> 00:55:02,250
0,240 240,660 660,840 840,930 930,1290
And so this is the
这就是这个内核的调度器线程中保存的寄存器。

1731
00:55:02,370 --> 00:55:05,790
0,450 780,1980 2010,2910 2910,3150 3150,3420
{} saved registers from this

1732
00:55:05,790 --> 00:55:09,100
0,810 1230,1650 1650,2250 2250,2820
core's, {} scheduler thread.|
|

1733
00:55:09,100 --> 00:55:10,200
0,510

1734
00:55:10,560 --> 00:55:11,790
0,210 210,360 360,870 870,1140 1140,1230
And of particular interest is
特别令人感兴趣的是RA，

1735
00:55:11,790 --> 00:55:13,110
0,150 150,420 420,720 720,1200 1200,1320
the {ra -},| because the
|因为RA寄存器i在那里，

1736
00:55:13,110 --> 00:55:15,210
0,210 210,300 300,1230 1260,1710 1710,2100
{ra -} register I is

1737
00:55:15,210 --> 00:55:16,600
0,840
where,|
|

1738
00:55:16,600 --> 00:55:18,460
0,60 60,360 360,750 750,1290 1740,1860
the current function call is
当前函数调用将返回到，

1739
00:55:18,460 --> 00:55:19,330
0,120 120,180 180,540 540,690 690,870
going to return to,| so
|所以我们要切换调度程序线程，

1740
00:55:19,330 --> 00:55:19,990
0,150 150,270 270,330 330,540 540,660
we're going to switch the

1741
00:55:19,990 --> 00:55:21,130
0,390 390,780 780,930 930,1050 1050,1140
scheduler thread,| it's going to
|它会返回，再返回到那个RA。

1742
00:55:21,130 --> 00:55:23,170
0,150 150,270 270,900 1170,1710 1710,2040
do {} return and return

1743
00:55:23,170 --> 00:55:24,900
0,90 90,300 300,900
to that ra.|
|

1744
00:55:24,930 --> 00:55:26,800
0,660 750,1020 1020,1260
And {} my,
我的天，我们可以通过在kernel.asm中查找来找到那个返回地址的位置。

1745
00:55:27,040 --> 00:55:28,330
0,240 240,360 360,690 750,1230 1230,1290
{} we can find out

1746
00:55:28,330 --> 00:55:29,680
0,120 120,570 750,900 900,1050 1050,1350
where that where that return

1747
00:55:29,680 --> 00:55:31,660
0,450 450,570 570,900 900,1200 1500,1980
address by looking in {kernel.asm

1748
00:55:31,660 --> 00:55:33,100
0,270 270,840
- -}.|
|

1749
00:55:35,000 --> 00:55:36,600
0,480 480,750 750,1050
Actually that's {}.|
实际上那是。|

1750
00:55:43,800 --> 00:55:44,820
0,270 270,630 630,780 780,900 900,1020
{} And as you can
正如你看到的这个x/i，

1751
00:55:44,820 --> 00:55:45,930
0,210 210,420 420,570 570,870 870,1110
see this {x/i - -},|
|

1752
00:55:45,930 --> 00:55:47,910
0,90 90,180 180,1110 1110,1830 1830,1980
you know prints instructions that
你知道在某个地址打印指令，

1753
00:55:47,910 --> 00:55:48,870
0,120 120,150 150,420 420,840 840,960
at a certain address,| but
|但它还会打印函数名称的标签

1754
00:55:48,870 --> 00:55:50,160
0,90 90,330 330,570 570,720 720,1290
it also prints the label

1755
00:55:52,170 --> 00:55:53,130
0,180 180,450 480,810 810,870 870,960
of the name of the

1756
00:55:53,130 --> 00:55:54,390
0,330 330,450 450,630 630,1140 1140,1260
function| that those instructions are
|那些指令都在里面，

1757
00:55:54,390 --> 00:55:55,200
0,90 90,210 210,510 510,630 630,810
in it,| so we're going
|所以我们很快就会回到日程表上，

1758
00:55:55,200 --> 00:55:57,330
0,90 90,210 210,900 1320,1740 1740,2130
to be returning to scheduler

1759
00:55:57,330 --> 00:55:59,100
0,90 90,300 300,420 420,810 1290,1770
{} by and by,| that's
|这只是你所知道的，正如你可能预期的那样。

1760
00:55:59,100 --> 00:56:00,540
0,450 750,900 900,1020 1020,1350 1350,1440
just you know as you

1761
00:56:00,540 --> 00:56:01,800
0,120 120,810
might expect.|
|

1762
00:56:05,040 --> 00:56:06,280
0,420
Okay.|
好吧。|

1763
00:56:07,100 --> 00:56:08,660
0,900

1764
00:56:11,120 --> 00:56:11,930
0,90 90,300 300,450 450,750 750,810
I want to look at
我想看看交换机对呼叫交换机的实际作用。

1765
00:56:11,930 --> 00:56:13,760
0,270 300,990 990,1290 1290,1620 1620,1830
what switch actually does about

1766
00:56:13,760 --> 00:56:15,320
0,60 60,240 240,960
to call switch.|
|

1767
00:56:15,380 --> 00:56:16,640
0,720

1768
00:56:18,910 --> 00:56:19,540
0,90 90,180 180,330 330,360 360,630
So I put a {breakpoint
所以我在开关上设置了断点

1769
00:56:19,540 --> 00:56:20,380
0,210 210,330 330,600 600,690 690,840
-} on switch| and putting
|并设置断点，

1770
00:56:20,380 --> 00:56:21,190
0,60 60,270 270,450 450,660 660,810
a {breakpoint -},| because there's
|因为有一堆设置代码

1771
00:56:21,190 --> 00:56:22,330
0,60 60,240 240,330 330,690 690,1140
a bunch of setup code|
|

1772
00:56:22,540 --> 00:56:24,520
0,450 450,990 990,1350
that pulls the
将上下文的价值从这些结构中提取出来，

1773
00:56:24,520 --> 00:56:25,750
0,390 390,450 450,1080 1080,1170 1170,1230
values of context out of

1774
00:56:25,750 --> 00:56:27,430
0,210 210,960 960,1140 1140,1470 1470,1680
those structures,| I'll skip over
|我会跳过它。

1775
00:56:27,430 --> 00:56:28,220
0,150
it.|
|

1776
00:56:28,820 --> 00:56:31,460
0,270 270,450 450,1080 1260,2100
Okay, so now {},|
好的，那么现在，|

1777
00:56:31,520 --> 00:56:32,180
0,150 150,180 180,390 390,570 570,660
when a {breakpoint -} and
当断点和开关时，

1778
00:56:32,180 --> 00:56:34,420
0,690 1050,1620
switch,| the
|GDB不会给我们看说明，

1779
00:56:34,420 --> 00:56:35,440
0,300 300,570 570,780 780,930 930,1020
gdb won't show us the

1780
00:56:35,440 --> 00:56:36,910
0,810 810,1080 1080,1200 1200,1320 1320,1470
instructions,| but we can look
|但是我们可以查看Switch.S来查看即将执行的指令。

1781
00:56:36,910 --> 00:56:38,890
0,90 90,390 390,660 660,1230 1710,1980
at {switch.S - -} to

1782
00:56:38,920 --> 00:56:39,790
0,240 240,300 300,360 360,780 780,870
look at the instructions were

1783
00:56:39,790 --> 00:56:41,320
0,240 240,330 330,900
about to execute.|
|

1784
00:56:41,350 --> 00:56:42,040
0,270 270,360 360,420 420,510 510,690
So as you can see
所以如你所见，我们正在执行第一条指令，

1785
00:56:42,040 --> 00:56:42,760
0,120 120,210 210,270 270,480 480,720
we're on the very first

1786
00:56:42,760 --> 00:56:44,200
0,450 450,540 540,1050 1050,1200 1200,1440
instruction,| the store of {}
|将RA存储到由A0指向的地址，

1787
00:56:44,200 --> 00:56:46,690
0,570 600,1170 1770,1980 1980,2100 2100,2490
ra to {} the address

1788
00:56:46,690 --> 00:56:48,340
0,360 360,510 510,930 960,1140 1140,1650
pointed to by {a0 -},|
|

1789
00:56:48,640 --> 00:56:49,630
0,330 330,450 450,840 840,930 930,990
you may remember in the
你可能还记得在呼叫切换中，

1790
00:56:49,630 --> 00:56:51,490
0,450 450,570 570,1260 1260,1530 1620,1860
call to switch,| that the
|第一个参数是当前线程的上下文

1791
00:56:51,490 --> 00:56:53,440
0,270 270,780 780,1350 1380,1590 1590,1950
first argument was the current

1792
00:56:53,440 --> 00:56:54,580
0,240 240,300 300,990 990,1080 1080,1140
{thread's -} context| and the
|第二个参数是我们要切换到的线程的上下文，

1793
00:56:54,580 --> 00:56:56,360
0,390 390,780 780,990 990,1260
second argument was the

1794
00:56:56,530 --> 00:56:57,520
0,480 480,570 570,660 660,930 930,990
context of the thread we're

1795
00:56:57,520 --> 00:56:59,110
0,450 450,870 900,1050 1050,1230 1230,1590
switching to,| the two arguments
|两个参数分别为0和a1

1796
00:56:59,110 --> 00:57:00,070
0,300 300,420 420,780 780,900 900,960
going {a0 -} and {a1

1797
00:57:00,070 --> 00:57:01,840
0,540 930,1380 1380,1470 1470,1530 1530,1770
-}| and so the reason
|所以我们通过寄存器a0看到所有这些存储的原因

1798
00:57:01,840 --> 00:57:02,500
0,120 120,210 210,360 360,480 480,660
why we see all these

1799
00:57:02,500 --> 00:57:05,350
0,840 870,1470 1770,2220 2220,2730 2730,2850
stores through register a0| is
|是因为我们在内存中存储了一堆寄存器

1800
00:57:05,350 --> 00:57:06,550
0,240 240,360 360,720 720,1140 1140,1200
because we're storing away a

1801
00:57:06,550 --> 00:57:08,230
0,210 210,270 270,1140 1230,1590 1590,1680
bunch of registers in the

1802
00:57:08,230 --> 00:57:09,490
0,360 360,510 510,660 660,900 900,1260
memory| that {a0 -}  points
|a0指向的是在我们要切换的线程的上下文中

1803
00:57:09,490 --> 00:57:10,420
0,180 180,360 360,540 540,690 690,930
to that is in the

1804
00:57:10,510 --> 00:57:12,340
0,690 690,810 810,1050 1500,1770 1770,1830
context of the thread we're

1805
00:57:12,340 --> 00:57:13,840
0,360 360,660 960,1080 1080,1170 1170,1500
switching from| and the loads
|并且负载从地址A1加载，

1806
00:57:13,840 --> 00:57:15,850
0,690 990,1200 1200,1560 1560,1620 1620,2010
load from address {a1 -},|
|

1807
00:57:15,850 --> 00:57:17,320
0,480 750,990 990,1050 1050,1350 1350,1470
because that's a pointer to
因为这是指向线程上下文的指针，所以我们要切换到。

1808
00:57:17,320 --> 00:57:18,850
0,300 630,1080 1080,1140 1140,1230 1230,1530
the context of the thread,

1809
00:57:18,850 --> 00:57:20,180
0,90 90,450 450,870
we're switching to.|

1810
00:57:26,740 --> 00:57:30,370
0,480 720,1320 2610,3240 3270,3450 3450,3630
Okay, {} thread, you know,
好的，线程，你知道，Switch保存寄存器，从目标线程的上下文加载寄存器，然后返回

1811
00:57:30,910 --> 00:57:34,150
0,510 840,1470 1560,1860 1860,2700 2790,3240
{} switch saves registers, loads

1812
00:57:34,150 --> 00:57:35,680
0,720 720,900 900,1020 1020,1320 1320,1530
registers from the target thread's

1813
00:57:35,680 --> 00:57:38,230
0,420 420,510 510,660 660,1320 1830,2550
context and then return| and
|这就是为什么RA很有趣的原因，

1814
00:57:38,260 --> 00:57:39,190
0,210 210,360 360,450 450,780 780,930
that's why the ra was

1815
00:57:39,190 --> 00:57:40,030
0,360 360,540 540,660 660,780 780,840
interesting,| because it's going to
|因为它将返回ra指向您的位置，即进入调度程序。

1816
00:57:40,030 --> 00:57:41,110
0,480 480,630 630,720 720,960 960,1080
return to the place that

1817
00:57:41,110 --> 00:57:42,460
0,270 270,630 630,810 810,1140 1140,1350
ra pointed you namely into

1818
00:57:42,460 --> 00:57:45,700
0,720 1830,2130 2130,2430 2730,2910 2910,3240
scheduler.| Alright, so one question
|好的，这里有一个问题，你可能会注意到，虽然交换机保存了Ra，sp和一堆[s]寄存器，

1819
00:57:45,700 --> 00:57:47,260
0,330 360,780 780,900 900,1320 1320,1560
is you may notice here

1820
00:57:47,260 --> 00:57:48,790
0,180 360,720 720,1050 1050,1410 1410,1530
that while switch saves {}

1821
00:57:48,790 --> 00:57:50,170
0,930 930,1020 1020,1080 1080,1290 1290,1380
{ra,sp} and a bunch of

1822
00:57:50,170 --> 00:57:51,820
0,240 240,870 900,1320 1320,1470 1470,1650
[s] registers,| one that does
|不保存的是程序计数器，

1823
00:57:51,820 --> 00:57:53,470
0,300 300,960 1020,1200 1200,1320 1320,1650
not save is the program

1824
00:57:53,470 --> 00:57:54,160
0,390
counter,|
|

1825
00:57:54,360 --> 00:57:55,140
0,210 210,360 360,450 450,720 720,780
{} there's no mention of
这里没有提到程序计数器，

1826
00:57:55,140 --> 00:57:57,150
0,60 60,450 450,750 750,1140 1500,2010
the program counter here {},|
|

1827
00:57:57,660 --> 00:57:59,280
0,270 270,600 600,750 750,1050
so why is that.|
那为什么呢。|

1828
00:58:04,650 --> 00:58:06,030
0,300 300,480 480,600 600,1170 1170,1380
{} Is it because the
是不是因为程序计数器无论如何都是用LIKE函数调用更新的。

1829
00:58:06,030 --> 00:58:08,490
0,450 450,900 900,1440 1470,1890 1890,2460
program counter is a updated

1830
00:58:08,490 --> 00:58:09,840
0,270 270,480 480,600 600,990 990,1350
with like the function calls

1831
00:58:09,840 --> 00:58:12,690
0,540 1140,1830 1830,2190 2190,2730 2730,2850
anyway.| Yeah it's it's the
|是的，是程序计数器，程序计数器里没有实际的信息值，

1832
00:58:12,690 --> 00:58:14,100
0,330 330,600 600,780 780,1080 1080,1410
program counter, there's no actual

1833
00:58:14,100 --> 00:58:15,540
0,540 540,930 930,990 990,1080 1080,1440
information value in the program

1834
00:58:15,540 --> 00:58:17,040
0,300 300,480 480,1050 1080,1200 1200,1500
counter,| we know that we're
|我们知道我们现在正在执行的是切换，对吧。

1835
00:58:17,040 --> 00:58:18,630
0,480 480,660 660,1140 1170,1410 1410,1590
executing right now is in

1836
00:58:18,630 --> 00:58:19,960
0,870
switch,

1837
00:58:19,990 --> 00:58:21,160
0,330 360,540 540,660 660,750 750,1170
right.| So there be no
|因此没有必要保存程序计数器，

1838
00:58:21,160 --> 00:58:22,450
0,450 450,540 540,870 870,960 960,1290
point in saving the program

1839
00:58:22,450 --> 00:58:23,530
0,330 330,750 750,840 840,990 990,1080
counter,| because it has an
|因为它有一个非常可预测的值，也就是这条指令，

1840
00:58:23,530 --> 00:58:26,290
0,600 600,1050 1050,1440 1440,2100 2430,2760
extremely predictable value namely this

1841
00:58:26,290 --> 00:58:27,670
0,750 750,870 870,1110 1110,1200 1200,1380
instruction,| the address of this
|此指令和开关的地址

1842
00:58:27,670 --> 00:58:30,430
0,420 420,510 510,1230 2220,2640 2640,2760
instruction and switch| what we
|我们真正关心的是我们从哪里被召唤，

1843
00:58:30,430 --> 00:58:31,720
0,270 270,570 570,930 930,1050 1050,1290
really care about is where

1844
00:58:31,720 --> 00:58:33,640
0,150 150,270 270,660 660,1350 1650,1920
we we're called from,| because
|因为当我们切换回这个线程时，

1845
00:58:33,640 --> 00:58:34,600
0,120 120,210 210,540 540,870 870,960
when we switch back to

1846
00:58:34,600 --> 00:58:35,920
0,240 240,810
this thread,|
|

1847
00:58:35,980 --> 00:58:37,420
0,210 210,390 390,450 450,870 870,1440
we want to continue executing
我们希望继续执行从哪里调用的任何点

1848
00:58:37,420 --> 00:58:38,920
0,210 240,690 690,1140 1140,1380 1380,1500
out whatever points swhich was

1849
00:58:38,920 --> 00:58:40,210
0,360 360,660 810,990 990,1140 1140,1290
called from| and it's {}
|它是ra，它保存从其调用开关的指令的地址。

1850
00:58:40,210 --> 00:58:42,640
0,450 450,600 600,1500 1740,1980 1980,2430
ra that holds the address

1851
00:58:42,640 --> 00:58:43,900
0,120 120,240 240,840 840,990 990,1260
of the instruction that switch

1852
00:58:43,900 --> 00:58:45,260
0,150 150,480 480,840
was called from.|
|

1853
00:58:45,320 --> 00:58:46,850
0,300 300,450 450,690 690,840 840,1530
{} So it's {} ra,
所以它是RA，它正被保存在这里，

1854
00:58:47,030 --> 00:58:48,590
0,270 270,480 480,810 810,1080 1080,1560
that's being saved away here,|
|

1855
00:58:48,980 --> 00:58:50,480
0,450 510,690 690,990 990,1380 1380,1500
{} and ra is the
而ra是将再次执行的点。

1856
00:58:50,480 --> 00:58:51,440
0,240 240,300 300,510 510,630 630,960
point at which will be

1857
00:58:53,910 --> 00:58:55,760
0,600 600,720 720,1230
executing out again.|
|

1858
00:58:55,790 --> 00:58:56,690
0,180 180,420 420,690 690,810 810,900
Let's switch return, so we
让我们切换回车，这样我们甚至可以打印我们可以打印的内容，

1859
00:58:56,690 --> 00:58:57,650
0,270 270,540 540,720 720,810 810,960
even print that we can

1860
00:58:57,650 --> 00:58:58,700
0,390
print,|
|

1861
00:58:58,930 --> 00:59:01,720
0,1110 1530,2190
ra, oops.|
拉，哎呀。|

1862
00:59:03,740 --> 00:59:04,550
0,150 150,270 270,480 480,630 630,810
We can print {ra -}
我们可以打印ra，您知道我们实际上还没有切换线程，

1863
00:59:04,550 --> 00:59:05,390
0,240 240,390 390,480 480,600 600,840
and you know we haven't

1864
00:59:05,390 --> 00:59:07,010
0,300 300,630 630,960 960,1290 1380,1620
actually switched threads yet,| you
|你还记得我们是从这个预定的活动来的吗，

1865
00:59:07,010 --> 00:59:08,060
0,300 300,390 390,690 690,870 870,1050
remember we came here from

1866
00:59:08,060 --> 00:59:10,220
0,120 120,600 600,1200 1650,1950 1950,2160
this sched function,| {} so
|因此，正如您可能预期的那样，指针返回到此调度函数，

1867
00:59:10,220 --> 00:59:12,140
0,900 1170,1410 1410,1500 1500,1620 1620,1920
ra as you might expect

1868
00:59:12,140 --> 00:59:13,040
0,90 90,330 330,540 540,690 690,900
the pointer back into this

1869
00:59:13,040 --> 00:59:15,620
0,240 240,600 1920,2160 2160,2460 2460,2580
sched function,| another question is
|另一个问题是，为什么Switch只保存了14个寄存器，我数了一下，

1870
00:59:15,620 --> 00:59:17,630
0,210 210,420 420,1170 1200,1500 1500,2010
how come switch only saves

1871
00:59:17,630 --> 00:59:19,520
0,570 570,1170 1170,1230 1230,1590 1590,1890
fourteen registers I counted them,|
|

1872
00:59:19,550 --> 00:59:20,900
0,90 90,240 240,570 570,690 690,1350
it only saves and restores
即使RISC-V有32个寄存器，它也只保存和恢复14个寄存器

1873
00:59:20,930 --> 00:59:23,150
0,330 330,1110 1800,2010 2010,2100 2100,2220
fourteen registers even though the

1874
00:59:23,150 --> 00:59:25,520
0,270 270,630 630,870 870,1590 1590,2370
{RISC-V -} has 32 registers|
|

1875
00:59:25,520 --> 00:59:27,120
0,510 510,660 660,930 930,1230
available for the {}
可用于或将其用于要使用的代码。

1876
00:59:27,470 --> 00:59:28,610
0,270 270,510 510,630 630,840 840,1140
or use it for code

1877
00:59:28,610 --> 00:59:29,820
0,120 120,690
to use.|
|

1878
00:59:29,820 --> 00:59:31,280
0,930
Why?|
为什么？|

1879
00:59:31,740 --> 00:59:33,030
0,240 240,450 450,690 690,780 780,1290
Why only half the registers
为什么只保存了一半的寄存器？

1880
00:59:33,030 --> 00:59:34,650
0,60 60,360 750,1050 1050,1290 1290,1620
are saved?| Well when switch
|当调用Switch时，它是作为正常函数调用的，

1881
00:59:34,650 --> 00:59:35,940
0,180 180,630 630,720 720,930 930,1290
was called, it was called

1882
00:59:35,940 --> 00:59:37,140
0,90 90,120 120,510 510,1020 1020,1200
as a normal function,| so
|因此，任何呼叫Switch的人都已经假设会进行Switch，可能会修改这些内容，

1883
00:59:37,140 --> 00:59:39,120
0,360 360,690 690,1050 1050,1380 1380,1980
whoever called switch already assumed

1884
00:59:39,120 --> 00:59:40,560
0,120 120,420 420,660 660,1080 1080,1440
will switch might modify those,|
|

1885
00:59:40,560 --> 00:59:42,180
0,150 150,540 540,990 990,1380 1380,1620
so that that function already
以便该函数已将其保存在其堆栈中，

1886
00:59:42,180 --> 00:59:43,440
0,390 390,780
saved that

1887
00:59:43,440 --> 00:59:45,270
0,240 240,450 450,1050 1080,1470 1470,1830
on its stack,| meaning that
|这意味着就像当我们从一个跳到另一个的时候，

1888
00:59:45,300 --> 00:59:47,040
0,360 360,570 570,720 720,1200 1380,1740
like when we jump from

1889
00:59:47,040 --> 00:59:49,020
0,510 510,630 630,750 750,1440 1680,1980
one to the other {},|

1890
00:59:49,020 --> 00:59:50,700
0,270 270,480 480,720 720,1140 1140,1680
that one's gonna self restore
它会自动恢复呼叫者保存寄存器。

1891
00:59:50,700 --> 00:59:54,030
0,540 780,1260 1290,2250 2250,2640 2640,3330
its {} caller save registers.|
|

1892
00:59:54,090 --> 00:59:56,220
0,450 450,900 900,1260 1260,1440 1440,2130
That's exactly right, this switches
完全正确，这个开关是从C代码调用的，

1893
00:59:56,220 --> 00:59:58,110
0,300 330,870 870,1020 1020,1320 1320,1890
are called from C code,|
|

1894
00:59:58,170 --> 00:59:59,820
0,300 300,930 1050,1350 1350,1440 1440,1650
we know that the C
我们知道C编译器保存在当前堆栈上，

1895
00:59:59,820 --> 01:00:03,060
0,1230 1350,2550 2550,2820 2820,2880 2880,3240
compiler saves on the current

1896
01:00:03,060 --> 01:00:06,270
0,990 1080,1530 1530,1800 1800,2700 2700,3210
stack,| {} any caller saved
|任何调用者保存其中有值的寄存器，

1897
01:00:06,270 --> 01:00:08,340
0,690 690,840 840,1350 1500,1950 1950,2070
registers that have values in

1898
01:00:08,340 --> 01:00:09,240
0,120 120,450 450,720 720,780 780,900
them,| {that,the} {compiler's -} going
|编译器稍后会用到的。

1899
01:00:09,240 --> 01:00:10,500
0,90 90,330 330,780
to need later.|
|

1900
01:00:10,590 --> 01:00:12,630
0,420 600,870 870,1140 1140,1680 1680,2040
{} And those caller saved
并且那些呼叫者保存的寄存器实际上包括，

1901
01:00:12,630 --> 01:00:16,350
0,540 540,1080 1260,2100 2400,3000 3090,3720
registers actually include,| I think
|我想有十八个，

1902
01:00:16,350 --> 01:00:17,480
0,450
there's

1903
01:00:17,600 --> 01:00:19,820
0,1080 1410,1860 1860,1950 1950,2100 2100,2220
eighteen,| depending on how you
|这取决于你如何计算它们，

1904
01:00:19,820 --> 01:00:20,900
0,270 270,420 420,600 600,810 810,1080
count them,| there's somewhere between
|有15到18个来电者保存的登记簿，

1905
01:00:20,900 --> 01:00:23,030
0,420 420,540 540,1170 1200,1680 1680,2130
fifteen and eighteen caller saved

1906
01:00:23,030 --> 01:00:26,060
0,990 1950,2220 2220,2400 2400,2880 2880,3030
registers,| so the registers we
|所以我们在这里看到的寄存器是所有不是调用者保存的寄存器

1907
01:00:26,060 --> 01:00:27,650
0,270 270,870 1050,1380 1380,1500 1500,1590
see here are all the

1908
01:00:27,650 --> 01:00:29,750
0,510 510,690 690,1140 1140,1530 1530,2100
registers that aren't caller saved|
|

1909
01:00:29,750 --> 01:00:31,220
0,90 90,210 210,300 300,930 1050,1470
and that the compiler [does]
并且编译器[确实]承诺保存，

1910
01:00:31,220 --> 01:00:32,990
0,360 360,450 450,930 960,1170 1170,1770
promise to save,| but nevertheless
|但是仍然可以保存调用函数所需的值，

1911
01:00:32,990 --> 01:00:35,120
0,180 180,750 1140,1710
may hold {}

1912
01:00:35,180 --> 01:00:36,710
0,750 750,840 840,930 930,1380 1380,1530
values that are needed by

1913
01:00:36,710 --> 01:00:37,940
0,120 120,480 480,930 960,1140 1140,1230
the calling function,| so we
|所以当我们切换线程时，我们都需要保存被调用者保存的寄存器。

1914
01:00:37,940 --> 01:00:38,750
0,60 60,240 240,330 330,720 720,810
all need to save the

1915
01:00:38,750 --> 01:00:41,480
0,840 840,1350 1350,2190 2340,2640 2640,2730
callee saved registers when we're

1916
01:00:41,480 --> 01:00:43,120
0,360 360,1050
switching threads.|
|

1917
01:00:45,830 --> 01:00:47,740
0,600 630,1320
Okay {}.|
好吧。|

1918
01:00:48,340 --> 01:00:49,270
0,360 360,600 600,720 720,780 780,930
{} Final thing I want
我想打印的最后一件事是，

1919
01:00:49,270 --> 01:00:51,010
0,60 60,480 480,1020 1020,1560 1620,1740
to print is the,| we
|我们确实保存和恢复了堆栈指针，

1920
01:00:51,010 --> 01:00:52,270
0,360 360,720 720,870 870,1170 1170,1260
do save and restore the

1921
01:00:52,270 --> 01:00:53,740
0,270 270,690 810,1020 1020,1230 1230,1470
stack pointer,| the current stack
|当前堆栈指针，从这个值很难判断，

1922
01:00:53,740 --> 01:00:54,880
0,360 360,600 600,780 780,1050 1050,1140
pointer, it's like hard to

1923
01:00:54,880 --> 01:00:55,810
0,240 240,420 420,540 540,810 810,930
tell from this value,| what
|这意味着什么，但它是当前进程的内核堆栈，

1924
01:00:55,810 --> 01:00:56,920
0,150 150,420 420,600 600,870 900,1110
that means but it's the

1925
01:00:56,920 --> 01:00:58,780
0,300 300,690 690,1080 1380,1500 1500,1860
kernel stack of the current

1926
01:00:58,780 --> 01:01:01,060
0,570 570,960 1980,2070 2070,2190 2190,2280
process,| which I don't know
|我不知道你是否还记得，

1927
01:01:01,060 --> 01:01:01,960
0,90 90,180 180,600 600,720 720,900
if you recall,| but is
|但是被分配的是由高存储器的虚拟存储器系统映射的。

1928
01:01:01,960 --> 01:01:03,820
0,660 660,1080 1080,1680 1680,1770 1770,1860
allocated is mapped by the

1929
01:01:03,820 --> 01:01:04,900
0,270 270,540 540,810 810,870 870,1080
virtual memory system at high

1930
01:01:04,900 --> 01:01:05,800
0,480
memory.|
|

1931
01:01:06,180 --> 01:01:07,340
0,660

1932
01:01:07,340 --> 01:01:13,010
0,300 300,660 1950,2430 5040,5250 5250,5670
Okay, so, {} okay, so
好的，所以，好的，我们要保存当前的寄存器，并从调度程序线程的上下文中恢复寄存器，

1933
01:01:13,010 --> 01:01:14,210
0,480 510,660 660,720 720,960 960,1200
we're going to save away

1934
01:01:14,210 --> 01:01:15,800
0,240 240,480 480,990 990,1140 1140,1590
the current registers and restore

1935
01:01:15,800 --> 01:01:17,660
0,660 660,1290
registers from

1936
01:01:17,660 --> 01:01:20,240
0,270 300,900 900,1230 1230,1800 2010,2580
{} scheduler thread's context {},|
|

1937
01:01:20,240 --> 01:01:21,710
0,0 0,240 240,390 390,810 1050,1470
I don't want to execute
我不想执行这些加载或存储中的每一个，

1938
01:01:21,710 --> 01:01:22,940
0,180 180,420 420,630 630,720 720,1230
every single one of these

1939
01:01:22,940 --> 01:01:23,900
0,390 390,450 450,720 720,870 870,960
loads or store,| so I'm
|所以我要走过去，

1940
01:01:23,900 --> 01:01:26,600
0,150 150,600 600,1290 1680,2070 2100,2700
gonna step over,| {} all
|这十四箱货，就是那十四箱货，和十四箱货，

1941
01:01:26,630 --> 01:01:28,220
0,150 150,600 600,1200 1200,1290 1290,1590
the fourteen loads, the fourteen

1942
01:01:28,220 --> 01:01:29,360
0,390 390,450 450,510 510,870 870,1140
stores, and the fourteen loads,|
|

1943
01:01:29,360 --> 01:01:31,160
0,120 120,330 660,1140 1140,1650 1650,1800
going to proceed directly to
直接转到退货说明。

1944
01:01:31,160 --> 01:01:33,200
0,450 720,1080 1080,1740 1740,1890 1890,2040
the return instructions.| Okay, so
|好的，所以我们执行了Switch中的所有操作，除了回车，

1945
01:01:33,200 --> 01:01:34,700
0,180 210,780 780,1050 1050,1140 1140,1500
we executed everything in switch

1946
01:01:34,700 --> 01:01:37,640
0,480 480,570 570,1200 1470,2130 2250,2940
except the return,| {} before
|在我们返回之前，我们只需再次打印感兴趣的寄存器，

1947
01:01:37,640 --> 01:01:38,810
0,300 300,450 450,540 540,1050 1050,1170
we do the return, we'll

1948
01:01:38,810 --> 01:01:40,640
0,330 570,870 870,960 960,1350 1350,1830
just print the interesting registers

1949
01:01:40,640 --> 01:01:41,570
0,360 360,450 450,660 660,780 780,930
again,| to see where we
|看看我们在哪里。

1950
01:01:41,570 --> 01:01:44,330
0,180 210,570 660,1110 1110,1650 2040,2760
are.| So stack pointer {},
|所以堆栈指针，现在它有一个不同的值，

1951
01:01:44,720 --> 01:01:46,130
0,540 540,810 810,990 990,1080 1080,1410
now it has a different

1952
01:01:46,130 --> 01:01:47,960
0,480 690,1110 1110,1320 1320,1530 1530,1830
value,| stack pointer now points
|堆栈指针现在指向存储器中的该堆栈零区域，

1953
01:01:47,960 --> 01:01:50,240
0,150 150,300 300,810 810,1710
into this stack zero

1954
01:01:50,360 --> 01:01:51,410
0,360 360,420 420,810 810,930 930,1050
area in memory,| and this
|这实际上是它在引导序列中非常非常早的位置

1955
01:01:51,410 --> 01:01:53,060
0,90 90,570 600,840 1050,1470 1470,1650
is actually the place it

1956
01:01:53,060 --> 01:01:54,560
0,570 570,960 960,1290 1290,1410 1410,1500
very very early in the

1957
01:01:54,560 --> 01:01:56,840
0,240 240,1020 1080,1590 1590,2010 2010,2280
boot sequence| where {start.S -
|其中star.S放置堆栈，以便它可以调用第一个C函数，

1958
01:01:56,840 --> 01:01:58,760
0,540 570,1200 1200,1320 1320,1770 1770,1920
-} puts the stack so

1959
01:01:58,760 --> 01:02:00,170
0,180 180,480 630,960 960,1050 1050,1410
it may call the very

1960
01:02:00,170 --> 01:02:02,060
0,390 390,600 600,1140 1440,1650 1650,1890
first C function,| so actually
|所以实际上回到了这个CPU的原始引导堆栈

1961
01:02:02,060 --> 01:02:03,170
0,270 270,360 360,450 450,810 810,1110
back on the original boot

1962
01:02:03,170 --> 01:02:04,910
0,480 510,660 660,840 840,1350 1350,1740
stack for this CPU| which
|它恰好就是调度程序运行的地方。

1963
01:02:04,910 --> 01:02:06,530
0,360 630,1200 1200,1290 1290,1410 1410,1620
just happens to be where

1964
01:02:06,530 --> 01:02:08,920
0,60 60,540 540,1290
the scheduler runs.|
|

1965
01:02:10,500 --> 01:02:13,110
0,600 630,1290 1530,1680 1680,2010 2010,2610
Okay, {} the program counter
好的，有趣后的节目计数器，

1966
01:02:13,350 --> 01:02:15,030
0,660 660,1110 1110,1260 1260,1320 1320,1680
after interesting,| we're in switch
我们正在调换，因为我们还没有回来

1967
01:02:15,030 --> 01:02:16,260
0,180 180,300 300,450 450,840 840,1230
because we haven't returned yet|
|

1968
01:02:16,350 --> 01:02:18,750
0,840 1260,1830 1860,2010 2010,2130 2130,2400
and {} the {} ra
并且RA寄存器现在指向调度器，

1969
01:02:18,750 --> 01:02:21,240
0,780 900,1620 1620,1980 1980,2040 2040,2490
register now points the scheduler,|
|

1970
01:02:21,240 --> 01:02:23,070
0,240 240,420 420,1050 1380,1620 1620,1830
because we've loaded, {} we've
因为我们已经加载，所以我们已经恢复了之前由调度程序线程保存的寄存器集。

1971
01:02:23,070 --> 01:02:26,100
0,720 720,1080 1410,1920 1920,2430 2520,3030
restored the register set previously

1972
01:02:26,100 --> 01:02:27,450
0,270 270,390 390,480 480,900 900,1350
saved by the scheduler thread.|
|

1973
01:02:28,990 --> 01:02:30,400
0,210 210,480 480,630 630,870 870,1410
And indeed, we're really now
事实上，我们现在真的在调度程序线程中，

1974
01:02:30,490 --> 01:02:31,660
0,300 300,360 360,840 840,1050 1050,1170
in the scheduler thread,| if
|如果我现在的位置和我们上次跑步的地方完全不同，

1975
01:02:31,660 --> 01:02:33,460
0,90 90,240 240,330 330,870 1230,1800
I were on where the

1976
01:02:33,460 --> 01:02:34,750
0,330 330,480 480,660 660,990 990,1290
where now looks totally different

1977
01:02:34,750 --> 01:02:35,440
0,120 120,180 180,480 480,570 570,690
from the last time we

1978
01:02:35,440 --> 01:02:37,240
0,240 240,360 360,480 480,1020 1140,1800
ran,| it were now indeed
|现在确实是呼叫切换，

1979
01:02:37,240 --> 01:02:38,500
0,120 120,360 360,480 480,1020 1020,1260
a call to switch,| but
|但是现在我们接到了Switch的呼叫，要切换过去某个时间所做的调度程序

1980
01:02:38,560 --> 01:02:39,850
0,660 660,840 840,930 930,1020 1020,1290
now we're in a call

1981
01:02:39,850 --> 01:02:41,140
0,180 180,570 570,720 720,1020 1020,1290
from switch to switch the

1982
01:02:41,140 --> 01:02:43,090
0,600 600,1140 1290,1530 1530,1710 1710,1950
scheduler made at some point

1983
01:02:43,090 --> 01:02:44,680
0,90 90,150 150,900 1200,1530 1530,1590
in the past| and the
|并且调度程序很久以前就在引导期间运行了

1984
01:02:44,680 --> 01:02:46,000
0,360 360,540 540,750 750,1110 1110,1320
scheduler was run long ago

1985
01:02:46,000 --> 01:02:47,920
0,300 300,750 990,1500 1500,1830 1830,1920
during boot| was called as
|被调用为[]在引导过程中所做的最后一件事。

1986
01:02:47,920 --> 01:02:48,940
0,120 120,450 450,600 600,720 720,1020
the last thing that []

1987
01:02:48,940 --> 01:02:50,860
0,420 570,990 990,1050 1050,1290 1290,1920
did during the boot process.|
|

1988
01:02:53,310 --> 01:02:54,210
0,210 210,270 270,540 540,810 810,900
So I'm gonna ask you
因此，我将要求您执行一条指令，从Switch Now返回到Scheduler。

1989
01:02:54,210 --> 01:02:56,190
0,270 270,750 750,840 840,1350 1350,1980
one instruction to return from

1990
01:02:56,490 --> 01:02:59,040
0,900 900,1170 1170,1380 1380,2010
switch now into scheduler.|
|

1991
01:02:59,890 --> 01:03:00,610
0,240 240,390 390,480 480,570 570,720
So now we're in this
现在我们在这个内核的调度器中，看看完整的代码，

1992
01:03:00,610 --> 01:03:02,590
0,270 270,960 1500,1650 1650,1740 1740,1980
core's scheduler, look the full

1993
01:03:02,590 --> 01:03:04,000
0,660
code,|
|

1994
01:03:08,320 --> 01:03:09,460
0,330 330,540 540,630 630,690 690,1140
so this is the scheduler
这就是计划程序代码，

1995
01:03:09,460 --> 01:03:11,480
0,450 750,1350
code {},|
|

1996
01:03:11,480 --> 01:03:12,890
0,240 240,510 510,720 720,1230 1230,1410
this function called scheduler,| now
该功能称为调度器，|现在我们在调度程序线程中执行，

1997
01:03:12,890 --> 01:03:14,090
0,120 120,540 540,630 630,720 720,1200
we're executing in the scheduler

1998
01:03:14,090 --> 01:03:15,950
0,630 690,930 930,1110 1110,1200 1200,1860
thread,| {} for the CPU
|对于CPU，我们刚刚从上一次对Switch的调用中返回

1999
01:03:16,280 --> 01:03:17,570
0,450 480,720 720,1140 1140,1200 1200,1290
and we're just at the

2000
01:03:17,570 --> 01:03:20,090
0,480 600,810 810,1140 1140,1920 2220,2520
point we just returned from

2001
01:03:20,090 --> 01:03:23,060
0,690 1440,1980 1980,2310 2310,2430 2430,2970
a previous call to switch|
|

2002
01:03:23,060 --> 01:03:24,320
0,240 240,630 630,810 810,870 870,1260
the scheduler made a while
调度员不久前做的，

2003
01:03:24,320 --> 01:03:26,240
0,600 930,1260 1260,1320 1320,1830 1830,1920
ago,| when it decided it
|当它决定要开始运行这一过程时，

2004
01:03:26,240 --> 01:03:27,440
0,120 120,240 240,300 300,750 750,1200
was going to start running

2005
01:03:27,440 --> 01:03:28,760
0,300 300,930 930,990 990,1080 1080,1320
that process,| you know {pid
|你知道PID 3，它是被中断的旋转过程，

2006
01:03:28,760 --> 01:03:29,870
0,300 300,630 630,870 870,1020 1020,1110
-} three which was the

2007
01:03:29,870 --> 01:03:32,180
0,360 360,1080 1260,1530 1530,1650 1650,2310
spin process that was interrupted,|
|

2008
01:03:32,750 --> 01:03:35,390
0,510 630,1110 1260,1470 1470,1740 1740,2640
so now it's this switch
所以现在是这个id为3的切换过程，

2009
01:03:36,080 --> 01:03:37,700
0,330 330,600 600,990 990,1230 1230,1620
process id three,| that's spin
|这是称为Switch自旋，但这次返回的不是Switch

2010
01:03:37,700 --> 01:03:39,020
0,330 330,810 810,990 990,1140 1140,1320
called switch but it's not

2011
01:03:39,020 --> 01:03:40,550
0,270 270,480 480,810 810,1020 1020,1530
switch that switch this returning|
|

2012
01:03:40,550 --> 01:03:41,810
0,240 240,390 390,630 630,960 960,1260
last which hasn't returned yet|
最后一个还没有回来的|

2013
01:03:42,080 --> 01:03:44,390
0,240 240,420 420,810 810,1440 1980,2310
is still saved away in
仍保存在进程id 3堆栈和上下文中。

2014
01:03:44,390 --> 01:03:45,140
0,420
{}

2015
01:03:45,490 --> 01:03:47,530
0,390 390,840 840,1320 1320,1920 1920,2040
process id three stack and

2016
01:03:47,530 --> 01:03:49,420
0,780 810,1080 1080,1440 1440,1590 1590,1890
context| just return from this
|只要从早先称为Switch的地方返回即可。

2017
01:03:49,450 --> 01:03:51,280
0,390 390,660 660,720 720,1320
earlier called {} switch.|
|

2018
01:03:53,160 --> 01:03:54,120
0,390 390,510 510,600 600,840 840,960
Alright, so the stuff that
好的，那么在调度器中发生的事情，

2019
01:03:54,120 --> 01:03:55,530
0,360 360,510 510,570 570,660 660,1410
happens here in the scheduler,|
|

2020
01:03:55,740 --> 01:03:59,250
0,570 1680,2340 2370,3120 3120,3330 3330,3510
{} were stopped running this
已停止运行此进程

2021
01:03:59,250 --> 01:04:01,290
0,570 570,720 720,1230 1290,1830 1860,2040
process| and so {} you
|所以你想忘掉我们在这个过程中所做的各种事情

2022
01:04:01,290 --> 01:04:02,820
0,150 150,270 300,930 930,1380 1410,1530
want to forget about the

2023
01:04:02,820 --> 01:04:05,070
0,450 450,780 780,900 900,1350 2130,2250
various things we did in

2024
01:04:05,070 --> 01:04:06,210
0,90 90,540 540,720 750,990 990,1140
the process of| running this
|运行此进程时，我们希望忽略c->proc等于零，

2025
01:04:06,210 --> 01:04:07,650
0,420 420,480 480,630 630,690 690,1440
process, we want to forget

2026
01:04:07,920 --> 01:04:09,600
0,180 180,570 570,870 870,1140 1140,1680
the {c->proc -} equals zero,|
|

2027
01:04:09,660 --> 01:04:11,070
0,480 480,660 660,750 750,840 840,1410
basically means that we're forgetting
基本上意味着我们忘了这一点。

2028
01:04:11,070 --> 01:04:11,760
0,240
that.|
|

2029
01:04:11,970 --> 01:04:13,230
0,270 270,690 690,840 840,1110 1110,1260
{} We're no longer running
我们不再在这个核心中运行这个过程，

2030
01:04:13,230 --> 01:04:14,310
0,120 120,480 480,570 570,720 720,1080
this process in this core's,|
|

2031
01:04:14,310 --> 01:04:15,030
0,150 150,240 240,390 390,540 540,720
so we don't want to
所以我们不想让任何人对此感到困惑，

2032
01:04:15,750 --> 01:04:17,340
0,420 420,780 780,900 900,1380 1380,1590
have anybody be confused about

2033
01:04:17,340 --> 01:04:18,450
0,330 360,510 510,570 570,810 810,1110
that,| let me set this
|让我将此每个核心进程指针设置为零，而不是此进程，

2034
01:04:19,000 --> 01:04:21,220
0,390 390,990 1170,1770 1770,2100 2100,2220
per core proc pointer to

2035
01:04:21,220 --> 01:04:22,640
0,420 420,810
zero instead

2036
01:04:22,640 --> 01:04:24,410
0,180 180,840 1260,1470 1470,1650 1650,1770
this process,| the next thing
|接下来发生的事情就是你记得屈服，

2037
01:04:24,410 --> 01:04:26,000
0,90 90,420 420,570 570,810 930,1590
that happens is that you

2038
01:04:26,240 --> 01:04:28,160
0,510 510,1380
remember yield,|
|

2039
01:04:28,160 --> 01:04:29,360
0,540 540,630 630,900 900,990 990,1200
acquired the lock for this
获取了此进程的锁，

2040
01:04:29,360 --> 01:04:31,010
0,900 960,1170 1170,1230 1230,1410 1410,1650
process,| because it didn't want
|因为它不想要任何其他内核的调度器

2041
01:04:31,010 --> 01:04:32,420
0,270 270,450 450,840 840,1290 1290,1410
any other core's scheduler| or
|或者查看这个过程并可能运行它

2042
01:04:32,420 --> 01:04:33,320
0,60 60,240 240,300 300,450 450,900
to look at this process

2043
01:04:33,320 --> 01:04:35,180
0,90 90,330 330,570 570,900 1440,1860
and maybe run it| until
直到整个过程完全进入休眠状态。

2044
01:04:35,180 --> 01:04:36,950
0,90 90,510 510,630 630,1530 1560,1770
the process was completely put

2045
01:04:36,950 --> 01:04:38,940
0,90 90,1020
to sleep.|
|

2046
01:04:39,290 --> 01:04:40,640
0,240 240,480 480,1020 1020,1110 1110,1350
We've now completed the switch
我们现在已经完成了从这个过程的切换，

2047
01:04:40,640 --> 01:04:42,350
0,240 240,420 420,570 570,1290 1500,1710
away from this process,| so
|这样我们就可以释放对刚刚屈服的进程的锁定。

2048
01:04:42,350 --> 01:04:43,520
0,90 90,240 240,570 570,690 690,1170
we can release the lock

2049
01:04:43,910 --> 01:04:45,200
0,210 210,480 510,960 960,1110 1110,1290
on the process that just

2050
01:04:45,200 --> 01:04:46,140
0,510
yielded.|
|

2051
01:04:46,880 --> 01:04:49,130
0,330 330,450 450,1050 1860,2100 2100,2250
That's the release, at this
这就是发布，在这一点上，我们还在计划中，

2052
01:04:49,130 --> 01:04:52,400
0,450 1350,1890 2250,2760 2760,3150 3150,3270
point, {} we're still in

2053
01:04:52,400 --> 01:04:53,360
0,60 60,510 510,660 660,780 780,960
the scheduler,| if there was
|如果在这一点上还有另一个核心，

2054
01:04:53,360 --> 01:04:55,070
0,270 270,810 870,1140 1140,1320 1320,1710
another core at this point,|
|

2055
01:04:55,070 --> 01:04:57,290
0,390 390,660 660,1020 1020,1620 1650,2220
some other core's scheduler could
其他内核调度器可以找到该进程，

2056
01:04:57,290 --> 01:04:59,120
0,600 600,840 840,1440 1440,1650 1650,1830
find that process,| because it's
|因为它是可运行的，运行它。

2057
01:04:59,120 --> 01:05:00,700
0,480 480,690 690,900 900,1050
runnable and run it.|
|

2058
01:05:00,700 --> 01:05:02,170
0,120 120,270 270,660 660,1140 1170,1470
But that's okay,| because we've
不过，没关系，|因为我们已经完全保存了它的寄存器不再在其进程堆栈上执行，

2059
01:05:02,170 --> 01:05:04,510
0,510 510,1020 1020,1170 1170,2040 2070,2340
completely saved its registers were

2060
01:05:04,510 --> 01:05:05,980
0,240 240,510 510,1020 1020,1140 1140,1470
no longer executing on its

2061
01:05:05,980 --> 01:05:08,200
0,330 330,1050 1050,1560 1560,1920 1980,2220
that processes stack,| because now
|因为现在在这个核心的调度程序堆栈上执行，

2062
01:05:08,200 --> 01:05:09,680
0,480 480,630 630,900
executing on the

2063
01:05:10,040 --> 01:05:12,050
0,390 420,600 600,990 990,1470 1470,2010
{} this core's scheduler stack,|
|

2064
01:05:12,290 --> 01:05:13,250
0,240 240,330 330,570 570,870 870,960
so it's actually fine if
因此，如果其他内核决定运行该进程，实际上也没什么问题。

2065
01:05:13,250 --> 01:05:14,810
0,150 150,300 300,750 900,1440 1440,1560
some other core decides to

2066
01:05:14,810 --> 01:05:16,300
0,180 180,330 330,1020
run that process.|
|

2067
01:05:16,840 --> 01:05:18,010
0,300 300,420 420,840 840,1020 1020,1170
Okay, but there's no other
好的，但是没有其他的核心，所以在这个演示中并没有发生这种情况。

2068
01:05:18,010 --> 01:05:19,780
0,420 420,750 1020,1230 1230,1440 1440,1770
core, so that doesn't actually

2069
01:05:19,780 --> 01:05:22,960
0,300 300,390 390,540 540,1260
happen in this demonstration.|
|

2070
01:05:24,970 --> 01:05:26,180
0,630

2071
01:05:26,440 --> 01:05:27,820
0,330 330,510 510,990 1020,1320 1320,1380
Actually, {I,want} to spend a
实际上，我想花点时间再谈一下p->锁，

2072
01:05:27,820 --> 01:05:29,740
0,570 630,1020 1020,1290 1290,1470 1470,1920
moment talking about the {p->lock

2073
01:05:29,740 --> 01:05:31,240
0,600 660,780 780,930 930,1080 1080,1500
-} a little bit more,|
|

2074
01:05:31,510 --> 01:05:34,150
0,570 1170,1950 1950,2160 2160,2400 2400,2640
{} {p->lock -} actually does
p->lock实际上做了几件事。

2075
01:05:34,150 --> 01:05:37,620
0,300 720,1080 1080,1170 1170,2040
a couple of things.|
|

2076
01:05:39,120 --> 01:05:40,520
0,150 150,420 420,810
It does really
从日程安排的角度来看，它实际上做了两件事，

2077
01:05:40,580 --> 01:05:41,600
0,270 270,660 660,750 750,810 810,1020
two things from the point

2078
01:05:41,600 --> 01:05:43,040
0,60 60,150 150,210 210,870 900,1440
of view of scheduling,| one
|其一是产生CPU，

2079
01:05:43,040 --> 01:05:45,290
0,150 150,570 600,1260 1260,1350 1350,2250
is that yielding the CPU,|
|

2080
01:05:45,650 --> 01:05:47,510
0,180 180,690 690,1230 1230,1770 1770,1860
{} involves multiple steps we
涉及我们必须设置状态的多个步骤

2081
01:05:47,510 --> 01:05:48,410
0,90 90,240 240,480 480,540 540,900
have to set the state|
|

2082
01:05:48,410 --> 01:05:49,670
0,270 300,570 570,960 960,1200 1200,1260
to run up change the
要运行，请将状态从Running更改为Runnable，

2083
01:05:49,670 --> 01:05:50,930
0,210 210,390 390,630 630,720 720,1260
state from running to runnable,|
|

2084
01:05:51,080 --> 01:05:53,630
0,390 390,1080 1080,1170 1170,2190 2280,2550
we save the registers in
我们将寄存器保存在屈服进程上下文中，

2085
01:05:53,630 --> 01:05:55,910
0,150 150,600 600,1140 1140,1830 1920,2280
the yielding processes context,| now
|现在我们必须停止使用屈服进程堆栈，

2086
01:05:55,910 --> 01:05:57,140
0,90 90,180 180,300 300,780 780,1230
we have to stop using

2087
01:05:57,140 --> 01:05:59,030
0,90 90,480 480,1020 1020,1590 1620,1890
the yielding processes stack,| there's
|至少有三个步骤需要时间，

2088
01:05:59,030 --> 01:06:01,010
0,150 150,510 510,810 810,1590 1590,1980
at least three steps which

2089
01:06:01,010 --> 01:06:03,980
0,300 300,900 1500,2070 2280,2670 2670,2970
take time,| {} in order
|为了完成产生CPU所需的所有步骤

2090
01:06:03,980 --> 01:06:05,780
0,480 720,1110 1110,1380 1380,1500 1500,1800
to do all the steps

2091
01:06:05,780 --> 01:06:07,640
0,600 600,750 750,1200 1200,1290 1290,1860
required to yield the CPU|
|

2092
01:06:07,910 --> 01:06:08,660
0,210 210,300 300,540 540,630 630,750
and so one of the
所以锁做的一件事就是

2093
01:06:08,660 --> 01:06:10,280
0,300 300,480 480,780 780,1440 1470,1620
things that lock does| as
|正如我提到的，它阻止任何其他内核调度器查看我们的进程

2094
01:06:10,280 --> 01:06:11,510
0,60 60,480 480,630 630,960 990,1230
I mentioned is prevent any

2095
01:06:11,510 --> 01:06:13,280
0,180 180,510 510,1110 1170,1470 1470,1770
other core scheduler from looking

2096
01:06:13,280 --> 01:06:14,450
0,90 90,180 180,660 660,900 900,1170
at our process| until all
|在所有三个步骤都完成之前，

2097
01:06:14,450 --> 01:06:16,190
0,240 240,960 990,1080 1080,1620 1620,1740
three steps have completed,| so
|所以锁基本上是把这些步骤变成原子的，

2098
01:06:16,190 --> 01:06:17,720
0,180 210,450 450,570 570,960 960,1530
the lock is basically making

2099
01:06:18,020 --> 01:06:19,860
0,390 390,870 870,1560
those steps atomic,|
|

2100
01:06:19,860 --> 01:06:20,940
0,90 90,330 330,510 510,990 990,1080
they either all happened from
它们要么都是从其他核心的角度发生的，

2101
01:06:20,940 --> 01:06:21,600
0,90 90,270 270,330 330,480 480,660
the point of view of

2102
01:06:21,630 --> 01:06:24,120
0,210 210,1050 1170,1860 1980,2430 2430,2490
other cores,| or none of
|或者他们都没发生过。

2103
01:06:24,120 --> 01:06:25,340
0,210 210,780
them happened.|
|

2104
01:06:26,160 --> 01:06:27,480
0,360 480,780 780,900 900,990 990,1320
{} It's going to turn
当我们开始运行一个进程时，结果也会是这样的

2105
01:06:27,480 --> 01:06:29,010
0,330 330,660 660,840 840,960 960,1530
out also when we start

2106
01:06:29,010 --> 01:06:30,990
0,210 210,300 300,1020 1260,1740 1860,1980
running a process| that the
|p->锁将具有类似的保护功能，

2107
01:06:30,990 --> 01:06:32,580
0,390 390,660 660,900 930,1200 1200,1590
{p->lock -} is going to

2108
01:06:32,610 --> 01:06:35,490
0,210 210,480 480,1380 1380,2220 2250,2880
have a similar protective function,|
|

2109
01:06:36,750 --> 01:06:37,890
0,360 360,510 510,690 690,1050 1050,1140
we're going to set the
我们将进程的状态设置为Running

2110
01:06:37,890 --> 01:06:38,850
0,300 300,360 360,450 450,840 840,960
state of a process to

2111
01:06:38,850 --> 01:06:40,200
0,360 360,480 480,600 600,900 900,1350
running| when we start executing
|当我们开始执行进程时

2112
01:06:40,200 --> 01:06:41,100
0,60 60,600 600,690 690,780 780,900
a process| and we're going
|我们将把它的寄存器从它的进程上下文移到RISC-V寄存器中，

2113
01:06:41,100 --> 01:06:43,110
0,60 60,360 360,810 870,1800 1800,2010
to move its registers from

2114
01:06:43,110 --> 01:06:44,790
0,300 300,750 750,1380 1380,1560 1560,1680
its process context into the

2115
01:06:44,790 --> 01:06:48,030
0,240 240,600 600,1470 1530,2220 2610,3240
{RISC-V -} registers,| {} but,
|但是，如果中断发生在该过程的中间，

2116
01:06:48,820 --> 01:06:50,350
0,240 240,390 390,870 870,1020 1020,1530
if an interrupt should happen

2117
01:06:50,350 --> 01:06:51,190
0,150 150,240 240,540 540,630 630,840
in the middle of that

2118
01:06:51,190 --> 01:06:52,630
0,720 720,840 840,1230 1230,1350 1350,1440
process,| the interrupt going to
|中断将看到进程处于一种奇怪的状态

2119
01:06:52,630 --> 01:06:53,500
0,240 240,330 330,720 720,810 810,870
see the process in a

2120
01:06:53,500 --> 01:06:55,060
0,300 300,720 720,1020 1050,1440 1440,1560
weird state| like maybe in
|就像在马克·瑞恩的状态下，

2121
01:06:55,060 --> 01:06:56,560
0,60 60,510 510,690 690,1080 1080,1500
the state of mark running,|

2122
01:06:56,560 --> 01:06:58,960
0,240 270,870 870,1110 1110,1920 2070,2400
but hasn't yet finished moving
但是尚未完成将其寄存器从上下文移动到RISC-V寄存器，

2123
01:06:58,960 --> 01:07:00,490
0,180 180,720 720,810 810,900 900,1530
its registers from the context

2124
01:07:00,490 --> 01:07:01,960
0,150 150,240 240,510 510,750 750,1470
into the {RISC-V -} registers,|
|

2125
01:07:02,170 --> 01:07:02,710
0,210 210,330 330,420 420,480 480,540
and that would be a
那将是一场灾难，

2126
01:07:02,710 --> 01:07:04,450
0,540 540,690 690,960 990,1380 1380,1740
disaster,| if a timer interrupt
|如果随后发生定时器中断，

2127
01:07:04,450 --> 01:07:05,500
0,300 300,540 540,720 720,840 840,1050
happened then,| because we might
|因为我们可能会在它恢复它的寄存器之前离开这个过程。

2128
01:07:05,500 --> 01:07:07,000
0,330 330,570 570,720 720,870 870,1500
switch away from that process

2129
01:07:07,210 --> 01:07:08,800
0,720 720,810 810,1050 1050,1440 1440,1590
before it had restored its

2130
01:07:08,800 --> 01:07:11,160
0,1080
registers.|
|

2131
01:07:11,220 --> 01:07:12,270
0,300 300,660 660,810 810,960 960,1050
And switching away from that
从这个过程中转换出来将会节省，

2132
01:07:12,270 --> 01:07:14,220
0,420 420,570 570,1410 1440,1740 1770,1950
process would save,| now an
|现在初始化的RISC-V注册到上下文处理上下文中，

2133
01:07:14,220 --> 01:07:16,440
0,660 660,810 810,1170 1170,2010 2010,2220
initialized {RISC-V -} registers into

2134
01:07:16,440 --> 01:07:19,470
0,90 90,960 1080,1560 1560,2250 2340,3030
the context processes context,| overwriting
|覆盖它的真实寄存器。

2135
01:07:19,470 --> 01:07:21,690
0,180 180,390 390,1050 1470,1830 1830,2220
its real registers.| So indeed
|因此，事实上，我们希望启动一个过程也是有效的原子过程，

2136
01:07:21,690 --> 01:07:23,250
0,120 120,480 510,1050 1050,1110 1110,1560
we want starting a process

2137
01:07:23,250 --> 01:07:25,620
0,150 150,690 690,1140 1170,1740 1740,2370
to also be effectively atomic,|
|

2138
01:07:26,430 --> 01:07:27,600
0,420 510,780 780,840 840,990 990,1170
{} and in this case
在这种情况下，持有持有p->锁的锁

2139
01:07:27,600 --> 01:07:29,310
0,390 390,510 510,930 930,1320 1320,1710
holding a lock holding {p->lock

2140
01:07:29,310 --> 01:07:31,230
0,360 360,1020 1050,1590 1590,1860 1860,1920
-}| across switching to a
|切换到某个进程，并防止其他内核查看该进程

2141
01:07:31,230 --> 01:07:33,630
0,840 1560,1740 1740,1920 1920,2040 2040,2400
process as well as preventing

2142
01:07:33,630 --> 01:07:34,650
0,180 180,600 600,720 720,960 960,1020
other cores from looking at

2143
01:07:34,650 --> 01:07:35,910
0,150 150,570 570,840 840,1110 1110,1260
that process| also turns off
|还会在切换到该线程的[触发]持续时间内关闭中断

2144
01:07:35,910 --> 01:07:38,490
0,780 1110,1650 1650,1710 1710,2250 2250,2580
interrupts for the duration of

2145
01:07:38,760 --> 01:07:40,290
0,540 540,750 750,1020 1050,1140 1140,1530
{[firing] -} up of switching

2146
01:07:40,290 --> 01:07:42,000
0,60 60,270 270,810 900,1350 1350,1710
to that thread| which prevents
|这防止了定时器中断看到进程，

2147
01:07:42,000 --> 01:07:43,470
0,60 60,480 480,1020 1020,1230 1230,1470
a timer interrupt from ever

2148
01:07:43,470 --> 01:07:45,570
0,450 450,540 540,1200 1200,1590 1650,2100
seeing a process,| that's only
|这只是切换到一半的过程。

2149
01:07:45,570 --> 01:07:48,030
0,990 1290,1560 1560,1770 1770,2280 2280,2460
midway through being switched to.|
|

2150
01:07:49,510 --> 01:07:50,640
0,60

2151
01:07:51,320 --> 01:07:52,360
0,480
Okay.|
好吧。|

2152
01:07:53,670 --> 01:07:54,780
0,690 720,870 870,990 990,1050 1050,1110
{} So we're in the
所以我们在日程表里，

2153
01:07:54,780 --> 01:07:56,940
0,690 990,1350 1350,1710 1710,1920 1920,2160
scheduler,| we're executing this loop
|我们在调度器的调度器循环中执行这个循环，

2154
01:07:56,940 --> 01:07:58,080
0,60 60,150 150,630 630,930 930,1140
in the {scheduler's -} loop

2155
01:07:58,080 --> 01:07:59,040
0,60 60,150 150,600 600,720 720,960
in the scheduler,| that looks
|它依次查看所有进程以找到一个要运行的进程

2156
01:07:59,040 --> 01:08:00,090
0,60 60,270 270,360 360,810 810,1050
at all the process in

2157
01:08:00,090 --> 01:08:00,990
0,330 330,420 420,660 660,810 810,900
turn to find one to

2158
01:08:00,990 --> 01:08:03,330
0,510 870,1500 1710,2010 2010,2130 2130,2340
run| and in this case,
|在这种情况下，我们知道还有另一个过程，

2159
01:08:03,330 --> 01:08:04,590
0,90 90,300 300,480 480,720 720,1260
we know there's another process,|
|

2160
01:08:04,590 --> 01:08:06,300
0,780 810,1170
because {},
因为，还有另一个我们已经分叉的旋转过程，

2161
01:08:06,590 --> 01:08:08,150
0,330 330,510 510,870 870,1170 1170,1560
there's that other spin process

2162
01:08:08,150 --> 01:08:10,790
0,120 120,300 300,720 1020,1410 1920,2640
that we've forked,| {} but
|但是有很多工序要检查，

2163
01:08:11,090 --> 01:08:12,050
0,240 240,300 300,450 450,510 510,960
there's a lot of process

2164
01:08:12,050 --> 01:08:14,360
0,210 210,330 330,1020 1410,1920 2040,2310
lots to examine,| I'm going
|我将跳过工艺表的实际进程扫描

2165
01:08:14,360 --> 01:08:15,440
0,60 60,450 450,690 690,780 780,1080
to skip over the actual

2166
01:08:15,440 --> 01:08:17,690
0,540 570,1350 1350,1470 1470,1830 1860,2250
process scanning of the process

2167
01:08:17,690 --> 01:08:19,340
0,540 630,960 960,1050 1050,1440 1440,1650
table| and go direct to
|并且直接进行到调度器找到下一个进程的点，

2168
01:08:19,370 --> 01:08:20,860
0,150 150,420 420,510 510,1020
the point of which,

2169
01:08:20,860 --> 01:08:22,000
0,150 150,540 540,900 900,960 960,1140
the scheduler finds the next

2170
01:08:22,000 --> 01:08:22,810
0,390 390,510 510,570 570,690 690,810
process,| so I'm gonna put
|所以我要把断点放在第474行，

2171
01:08:22,810 --> 01:08:24,380
0,60 60,330 330,870
a {breakpoint -}

2172
01:08:24,380 --> 01:08:25,660
0,660
{}

2173
01:08:26,320 --> 01:08:28,270
0,750 930,1200 1200,1380 1380,1680 1680,1950
at line four seventy four,|
|

2174
01:08:28,270 --> 01:08:29,260
0,180 180,300 300,600 600,930 930,990
where it's actually found a
在那里它实际上找到了一个要运行的新进程。

2175
01:08:29,260 --> 01:08:30,880
0,150 150,690
new {process,to,run}.|
|

2176
01:08:31,920 --> 01:08:33,180
0,180 180,390 390,510 510,930 1050,1260
But here we are, {}
但是在这里，调度程序扫描进程表并找到另一个要运行的进程。

2177
01:08:33,180 --> 01:08:35,850
0,120 120,930 1890,2220 2220,2310 2310,2670
the schedulers scan the process

2178
01:08:35,850 --> 01:08:37,260
0,330 330,510 510,810 810,1050 1050,1410
table and found another process

2179
01:08:37,260 --> 01:08:38,280
0,90 90,480
to run.|
|

2180
01:08:38,840 --> 01:08:40,670
0,330 330,660 1140,1440 1440,1680 1680,1830
{} And {} it's going
它会将该进程称为运行，

2181
01:08:40,670 --> 01:08:41,990
0,270 300,510 510,660 660,990 990,1320
to call that process run,|
|

2182
01:08:41,990 --> 01:08:43,010
0,390 390,510 510,690 690,750 750,1020
you can see a line
你可以看到一条468线，

2183
01:08:43,010 --> 01:08:44,780
0,210 210,660 660,810 1020,1620 1620,1770
{468 -},| it acquired that
|它获得了进程锁定，

2184
01:08:44,780 --> 01:08:46,340
0,570 570,1020 1050,1230 1230,1410 1410,1560
processes lock,| so now it's
|所以现在它有权做不同的步骤

2185
01:08:46,340 --> 01:08:48,140
0,570 570,780 810,1320 1320,1410 1410,1800
entitled to do the various

2186
01:08:48,140 --> 01:08:49,460
0,390 390,480 480,930 930,1020 1020,1320
steps| were required to switch
|都需要切换到那个过程，

2187
01:08:49,460 --> 01:08:52,130
0,120 120,300 300,1050 1470,1950 2220,2670
to that process,| in line
|在第473行，它将状态过程设置为运行，

2188
01:08:52,130 --> 01:08:53,360
0,210 210,840 840,930 930,1140 1140,1230
{473 -}, it set the

2189
01:08:53,360 --> 01:08:54,860
0,420 420,510 510,810 810,930 930,1500
process of state to running,|
|

2190
01:08:55,440 --> 01:08:56,370
0,120 120,300 300,420 420,630 630,930
it's now at {474 -
现在是474，

2191
01:08:56,370 --> 01:08:57,600
0,180 180,270 270,390 390,480 480,1230
-},| we're going to record
|我们将在CPU结构中记录CPU正在执行的进程

2192
01:08:57,600 --> 01:08:59,760
0,120 120,210 210,660 660,1410 1440,2160
in the CPU structure which

2193
01:08:59,760 --> 01:09:01,680
0,540 540,660 660,1110 1110,1200 1200,1920
process the CPU is executing|
|

2194
01:09:02,730 --> 01:09:04,860
0,570 630,960 960,1170 1170,1860 1860,2130
and then call switch to
然后调用Switch来保存调度程序的寄存器

2195
01:09:04,860 --> 01:09:07,110
0,930 960,1080 1080,1560 1560,2130 2130,2250
save the scheduler's registers| and
|并恢复目标处理器的寄存器，

2196
01:09:07,110 --> 01:09:10,440
0,780 1200,1650 1680,2160 2160,2730 2730,3330
restore the target processor's registers,|
|

2197
01:09:10,500 --> 01:09:11,130
0,180 180,240 240,330 330,480 480,630
so you can see what
这样你就可以看到找到了什么进程

2198
01:09:11,130 --> 01:09:12,480
0,360 360,420 420,900 900,1020 1020,1350
process is found| by looking
|通过查看新的进程名称，

2199
01:09:12,480 --> 01:09:15,060
0,210 1020,1260 1290,1500 1500,2040 2040,2580
at a new process name,|

2200
01:09:15,150 --> 01:09:17,040
0,600 600,720 720,1440
surprisingly its spin,|
令人惊讶的是它的旋转，|

2201
01:09:17,590 --> 01:09:18,520
0,240 240,360 360,660 660,840 840,930
{} it's process id is
它的进程ID现在是4，

2202
01:09:18,520 --> 01:09:19,900
0,150 150,810 1020,1170 1170,1290 1290,1380
now four,| used to be
|以前是3号现在是4号。

2203
01:09:19,900 --> 01:09:21,670
0,270 270,780 810,1080 1080,1290 1290,1770
running three now running four.|
|

2204
01:09:21,850 --> 01:09:23,500
0,1080

2205
01:09:23,960 --> 01:09:24,830
0,240 240,390 390,600 600,780 780,870
{} We've already set the
我们已经将状态设置为Running，

2206
01:09:24,830 --> 01:09:26,580
0,240 240,360 360,750 750,1080
state to running,| so
|所以只有各州在运行。

2207
01:09:26,580 --> 01:09:27,780
0,660
{}

2208
01:09:29,420 --> 01:09:31,790
0,570 570,660 660,930 930,1290 1800,2370
just the states running {}.|
|

2209
01:09:32,550 --> 01:09:33,840
0,270 270,390 390,540 540,990 990,1290
We can see where this
我们可以看到这个线程将切换到哪里

2210
01:09:33,840 --> 01:09:34,860
0,270 270,390 390,540 540,600 600,1020
thread is going to switch

2211
01:09:34,860 --> 01:09:35,940
0,540 570,720 720,780 780,990 990,1080
to| in the call to
|在交换线路475的呼叫中，

2212
01:09:35,940 --> 01:09:38,800
0,330 330,600 600,810 810,1830
switch line {475 -},|
|

2213
01:09:39,020 --> 01:09:40,940
0,690 1080,1170 1170,1320 1320,1860 1860,1920
{} print this context the
打印该上下文中保存的寄存器，

2214
01:09:40,940 --> 01:09:43,640
0,300 300,1110 1530,1860 2010,2250 2250,2700
saved registers,| {} so where
|那么RA在哪里呢，

2215
01:09:43,640 --> 01:09:45,470
0,120 120,240 240,960 1500,1710 1710,1830
is the ra,| we're going
|我们要打电话给交换机，

2216
01:09:45,470 --> 01:09:47,300
0,60 60,330 330,810 810,1050 1080,1830
to call switch,| but switch
|但是按照我们所知的那样切换，

2217
01:09:47,300 --> 01:09:49,340
0,120 120,270 270,660 660,840 840,2040
as we know it returns,|
|

2218
01:09:49,520 --> 01:09:50,900
0,300 300,390 390,810 810,900 900,1380
when it returns it returns
当它返回时，它返回到恢复的RA，

2219
01:09:50,900 --> 01:09:52,430
0,90 90,180 180,840 840,1140 1140,1530
to the restored {ra -},|
|

2220
01:09:52,550 --> 01:09:53,690
0,240 240,360 360,630 630,870 870,1140
so we really care about
所以我们真正关心的是RA指向哪里，

2221
01:09:53,690 --> 01:09:55,490
0,390 600,1230 1230,1410 1410,1560 1560,1800
is where is it that

2222
01:09:55,790 --> 01:09:57,080
0,390 390,630 630,750 750,1170 1170,1290
a {ra -} points to,|
|

2223
01:09:57,080 --> 01:09:58,250
0,300 300,420 420,690 690,870 870,1170
we can find that out
我们可以通过以下方式找出答案。

2224
01:09:58,250 --> 01:09:59,240
0,570
by.|
|

2225
01:10:00,740 --> 01:10:01,840
0,570
Oops.|
哎呀。|

2226
01:10:02,100 --> 01:10:04,290
0,600 630,930 930,1170 1170,1560 1560,2190
{} Using {x/i - -},|
使用x/i，|

2227
01:10:07,440 --> 01:10:08,460
0,180 180,270 270,390 390,450 450,1020
{} it's going to return
它将把ra点返回到某个点，

2228
01:10:08,460 --> 01:10:09,630
0,150 150,390 390,780 780,960 960,1170
ra {points -} to some

2229
01:10:09,630 --> 01:10:11,100
0,240 240,870 900,1140 1140,1350 1350,1470
point instead,| that's not too
|这并不太令人惊讶，

2230
01:10:11,100 --> 01:10:13,500
0,540 540,930 990,1830 1830,2130 2130,2400
surprising,| since presumably that other
|由于假设另一自旋进程由于定时器中断而挂起，

2231
01:10:13,500 --> 01:10:16,320
0,390 390,1170
spin process

2232
01:10:16,410 --> 01:10:17,490
0,150 150,840 840,930 930,1020 1020,1080
was suspended due to a

2233
01:10:17,490 --> 01:10:18,690
0,330 330,720 720,930 930,1080 1080,1200
timer interrupt,| which as we
|我们知道这叫做Sched，也就是所谓的Switch。

2234
01:10:18,690 --> 01:10:20,440
0,330 360,600 600,1170
know called sched,

2235
01:10:20,940 --> 01:10:22,900
0,270 270,450 450,990
what's called switch.|
|

2236
01:10:26,450 --> 01:10:29,300
0,570 1020,1710 2280,2580 2580,2640 2640,2850
Alright, so about to call
好了，现在要呼叫Switch了，让我再调一遍Switch代码。

2237
01:10:29,300 --> 01:10:30,290
0,450 450,570 570,630 630,840 840,990
switch, let me just bring

2238
01:10:30,290 --> 01:10:31,730
0,120 120,360 360,630 630,870 870,1440
up the switch code again.|
|

2239
01:10:34,050 --> 01:10:35,600
0,870

2240
01:10:38,660 --> 01:10:40,790
0,480 480,780 780,1200 1200,1320 1320,2130
Actually enter switch were still,|
实际上进入开关是静止的，|

2241
01:10:41,390 --> 01:10:42,470
0,240 240,660 660,900 900,990 990,1080
{} where shows that were
其中仍在调度器上下文中的节目。

2242
01:10:42,470 --> 01:10:43,700
0,330 330,420 420,510 510,1140 1140,1230
still in the {scheduler's -}

2243
01:10:43,700 --> 01:10:45,060
0,750
context.|
|

2244
01:10:45,060 --> 01:10:46,320
0,660

2245
01:10:46,940 --> 01:10:48,950
0,210 210,390 390,840 1140,1560 1560,2010
I want to again execute
这次我想再次执行所有切换指令，

2246
01:10:48,950 --> 01:10:49,970
0,210 210,300 300,480 480,930 930,1020
all of the instructions to

2247
01:10:49,970 --> 01:10:51,080
0,270 270,390 390,570 570,960 960,1110
switch this time,| switching from
|从调度程序切换到新进程。

2248
01:10:51,080 --> 01:10:52,760
0,60 60,660 660,810 810,1290 1380,1680
the scheduler to the new

2249
01:10:52,760 --> 01:10:54,140
0,900
process.|
|

2250
01:10:54,400 --> 01:10:55,780
0,120 120,390 390,540 540,630 630,1380
We skip over the 28
我们跳过28家商店和货物。

2251
01:10:55,810 --> 01:10:57,720
0,480 480,570 570,1440
stores and loads.|
|

2252
01:10:58,850 --> 01:11:00,220
0,540

2253
01:11:00,460 --> 01:11:02,650
0,840 870,1290 1290,1860 1860,2070 2070,2190
Just convince ourselves that we
只要说服我们自己，我们真的要回到Sched了，

2254
01:11:02,650 --> 01:11:03,760
0,210 210,450 450,690 690,780 780,1110
are actually about to return

2255
01:11:03,760 --> 01:11:04,900
0,90 90,540 540,690 690,900 900,1140
to sched,| so now since
|现在既然我们要返回到Sched而不是Scheder，

2256
01:11:04,900 --> 01:11:05,800
0,240 330,510 510,570 570,810 810,900
we're about to return to

2257
01:11:05,800 --> 01:11:07,270
0,540 540,660 660,840 840,1290 1290,1470
sched and not scheduler {},|
|

2258
01:11:07,390 --> 01:11:08,740
0,240 240,480 480,630 630,1080 1170,1350
we must now be in
我们现在必须在进程的内核线程中，而不再是。

2259
01:11:08,740 --> 01:11:10,300
0,300 330,870 870,1140 1140,1440 1440,1560
a process's kernel thread and

2260
01:11:10,300 --> 01:11:12,740
0,150 150,720
no longer.|
|

2261
01:11:12,980 --> 01:11:14,570
0,150 150,510 510,570 570,960 960,1590
The scheduler of {thread,in} indeed
事实上，如果我们查看回溯，就会发现线程的调度器，

2262
01:11:14,570 --> 01:11:15,050
0,90 90,210 210,330 330,420 420,480
if we look at the

2263
01:11:15,050 --> 01:11:16,820
0,270 270,1020 1140,1440 1440,1650 1650,1770
{backtrace -},| we had a
|我们有一个用户陷阱呼叫，一定是定时器中断，

2264
01:11:16,820 --> 01:11:18,470
0,330 330,690 690,1290 1320,1470 1470,1650
user trap call that must

2265
01:11:18,470 --> 01:11:19,790
0,90 90,180 180,210 210,630 630,1320
have been a timer interrupt,|
|

2266
01:11:19,880 --> 01:11:21,080
0,210 210,480 480,540 540,720 780,1200
from long you know sometime
很久以前，你知道，在过去的某个时候，

2267
01:11:21,080 --> 01:11:23,030
0,60 60,120 120,780 1230,1560 1560,1950
in the past,| {} that
|正如我们所看到的，它被称为Year和Sched，

2268
01:11:23,450 --> 01:11:24,470
0,180 180,330 330,540 540,750 750,1020
as we've seen called yield

2269
01:11:24,470 --> 01:11:25,370
0,90 90,390 390,540 540,600 600,900
and sched,| but it was
|但现在是计时器打断了另一个进程，

2270
01:11:25,370 --> 01:11:26,480
0,90 90,390 390,720 720,840 840,1110
the timer interrupted the other

2271
01:11:26,480 --> 01:11:28,400
0,570 570,990 1380,1800 1800,1860 1860,1920
process now,| not in the
|不是在我们最初观察的过程中。

2272
01:11:28,400 --> 01:11:30,110
0,450 450,570 570,810 840,1440 1440,1710
process that we originally looked

2273
01:11:30,110 --> 01:11:30,680
0,150
at.|
|

2274
01:11:35,600 --> 01:11:39,320
0,570 600,1200 1620,1890 1890,2850 2910,3720
Okay, {} any questions about,|
好的，有什么问题吗，|

2275
01:11:39,380 --> 01:11:40,700
0,180 180,330 330,420 420,840 870,1320
I think I'm gonna leave
我想在这一点上我不再一步步介绍代码了，

2276
01:11:40,700 --> 01:11:42,140
0,570 600,990 990,1110 1110,1200 1200,1440
off stepping through the code

2277
01:11:42,140 --> 01:11:44,570
0,60 60,240 240,870 1440,2040 2040,2430
at this point,| any questions
|关于我们看过的任何材料的任何问题。

2278
01:11:44,570 --> 01:11:46,820
0,600 1470,1710 1710,1770 1770,1830 1830,2250
about any of the material

2279
01:11:46,820 --> 01:11:47,880
0,150 150,510
we've seen.|
|

2280
01:11:49,790 --> 01:11:51,620
0,270 270,660 660,1260 1260,1410 1410,1830
Oh, sorry if it was
哦，对不起，如果它是一个例子，比如这个[]，

2281
01:11:51,650 --> 01:11:53,540
0,240 240,390 390,900 900,1200 1200,1890
a for example this [],|
|

2282
01:11:53,810 --> 01:11:55,430
0,180 180,660 690,870 870,1080 1080,1620
{} then we would see
然后我们会看到ra会指向某个地方

2283
01:11:55,640 --> 01:11:58,310
0,240 240,840 1290,2070 2070,2310 2310,2670
{} that ra would point

2284
01:11:58,310 --> 01:12:01,370
0,510 510,990 1410,2190 2190,2610 2610,3060
somewhere to| like [sleep] or
|像[睡觉]之类的，对。

2285
01:12:01,400 --> 01:12:03,240
0,480 480,690 690,1020 1020,1380
something like that, right.|
|

2286
01:12:03,360 --> 01:12:06,740
0,1650 1830,2880
Um, yes.|
嗯，是的。|

2287
01:12:07,040 --> 01:12:08,300
0,810
Well,
好的，我们看到在这一点上

2288
01:12:08,340 --> 01:12:09,810
0,570 570,750 750,960 960,1080 1080,1470
we see that the where

2289
01:12:09,810 --> 01:12:11,460
0,90 90,300 300,660 660,780 780,1650
at this point| would include
|将包括一些系统调用实现函数

2290
01:12:11,490 --> 01:12:13,950
0,450 450,840 840,1110 1110,1770 1770,2460
some system call implementation functions|

2291
01:12:13,950 --> 01:12:14,880
0,90 90,120 120,360 360,420 420,930
and a call to sleep,|
呼唤你入睡，|

2292
01:12:14,910 --> 01:12:16,260
0,240 240,360 360,720 720,810 810,1350
as it happens I think,
碰巧我认为，这基本上是你在回答问题。

2293
01:12:17,080 --> 01:12:19,000
0,150 150,600 600,810 1200,1530 1530,1920
{} this is you're basically

2294
01:12:19,000 --> 01:12:21,520
0,300 300,660 660,1230 1410,2070 2310,2520
answering questions.| Yes, {} if
|是的，如果我们只是因为定时器中断以外的某种原因而停止执行此进程，

2295
01:12:21,520 --> 01:12:23,560
0,150 150,300 300,720 1080,1440 1440,2040
we had just left off

2296
01:12:23,650 --> 01:12:25,240
0,540 540,750 750,1200 1200,1410 1410,1590
executing this process for some

2297
01:12:25,240 --> 01:12:26,080
0,210 210,360 360,450 450,510 510,840
reason other than the timer

2298
01:12:26,080 --> 01:12:28,360
0,570 840,1470 1500,1890 1890,2130 2130,2280
interrupt,| {} switch would be
|交换机将基本上返回到某些系统调用代码，而不是返回到调度，

2299
01:12:28,360 --> 01:12:30,400
0,450 450,930 930,1200 1500,1710 1710,2040
basically returning to some system

2300
01:12:30,400 --> 01:12:31,990
0,270 270,570 570,990 990,1230 1230,1590
call code instead of to

2301
01:12:32,230 --> 01:12:33,250
0,450 450,570 570,660 660,960 960,1020
sched,| as it happens I
|碰巧我认为睡眠可以称为Sched，所以。

2302
01:12:33,250 --> 01:12:34,720
0,180 180,510 570,750 750,1020 1020,1470
think sleep may call sched,

2303
01:12:34,720 --> 01:12:35,800
0,360 360,600
so {}.|
|

2304
01:12:36,400 --> 01:12:37,480
0,570

2305
01:12:37,750 --> 01:12:38,680
0,270 270,450 450,690 690,780 780,930
The {backtrace -} would look
回溯看起来会有所不同，刚才发生的事情包括Sched，

2306
01:12:38,680 --> 01:12:39,790
0,270 270,420 420,570 570,840 840,1110
different, what just happened include

2307
01:12:39,790 --> 01:12:41,770
0,420 510,630 630,1050 1440,1680 1680,1980
sched,| but yes I've chosen
|不过，是的，我只选择了一种方式，

2308
01:12:41,770 --> 01:12:43,480
0,180 180,420 420,840 840,1170
just one way of,|
|

2309
01:12:43,650 --> 01:12:44,920
0,180 180,330 330,750
you know just
您知道，由于计时器中断，只有一种方法可以在进程之间切换。

2310
01:12:44,950 --> 01:12:46,120
0,240 240,480 480,570 570,930 930,1170
one way of switching between

2311
01:12:46,120 --> 01:12:47,320
0,600 600,720 720,840 840,1080 1080,1200
processes due to timer {interrupts

2312
01:12:47,320 --> 01:12:49,420
0,660
-}.|
|

2313
01:12:49,700 --> 01:12:50,930
0,120 120,240 240,450 450,660 660,1230
But you also get switches
但是您也可以让交换机等待用户IO，

2314
01:12:50,930 --> 01:12:52,340
0,120 120,330 330,690 750,1080 1080,1410
to wait for user IO,|
|

2315
01:12:52,370 --> 01:12:53,570
0,300 300,420 420,570 570,1110 1110,1200
wait for other processes to
等待其他进程执行诸如写入管道之类的操作。

2316
01:12:53,570 --> 01:12:54,650
0,180 180,510 510,720 750,960 960,1080
do things like write to

2317
01:12:54,650 --> 01:12:55,560
0,60 60,450
{} pipe.|
|

2318
01:12:58,380 --> 01:12:59,820
0,390 390,600 600,780 780,1140 1170,1440
OK, one thing to you
好的，有一件事你可能会注意到

2319
01:12:59,820 --> 01:13:01,980
0,330 330,900 900,1110 1110,1440 1650,2160
probably noticed is| that {}
|名为Switch的调度程序，

2320
01:13:02,190 --> 01:13:04,940
0,960 960,1290 1290,2220
scheduler called switch,|
|

2321
01:13:04,940 --> 01:13:06,320
0,480 510,660 660,870 870,960 960,1380
and we're about to return
我们马上就要从这里的开关回来了，

2322
01:13:06,320 --> 01:13:08,960
0,180 180,600 600,1140 1410,1980 2370,2640
from switch here,| but we're
|但是我们真的是从一个不同的电话中返回到Switch

2323
01:13:08,960 --> 01:13:10,460
0,660 660,960 960,1110 1110,1230 1230,1500
returning really from a different

2324
01:13:10,460 --> 01:13:11,660
0,240 240,330 330,900 900,1080 1080,1200
call to switch| than them
|比它们在调度器上的时间更长，

2325
01:13:11,660 --> 01:13:12,830
0,90 90,180 180,570 570,660 660,1170
on the scheduler are made,|
|

2326
01:13:12,950 --> 01:13:13,940
0,240 240,570 570,720 720,780 780,990
were returning from a call
我们是从这个过程很久以前打来的电话转接回来的。

2327
01:13:13,940 --> 01:13:15,170
0,90 90,450 450,600 600,780 780,1230
to switch that this process

2328
01:13:15,170 --> 01:13:16,160
0,180 180,210 210,420 420,690 690,990
made a long time ago.|
|

2329
01:13:18,110 --> 01:13:19,160
0,480
So,
所以，你知道，这可能有点令人困惑，

2330
01:13:19,250 --> 01:13:20,450
0,150 150,270 270,420 420,630 630,1200
you know, this is potentially

2331
01:13:20,450 --> 01:13:21,530
0,30 30,180 180,300 300,840 840,1080
a little bit confusing,| but,
|但是，你知道，这就是线程切换的[毅力]工作原理。

2332
01:13:22,470 --> 01:13:23,040
0,120 120,210 210,390 390,450 450,570
you know, this is how

2333
01:13:23,040 --> 01:13:23,880
0,90 90,420 420,480 480,570 570,840
the [guts] of a thread

2334
01:13:23,880 --> 01:13:25,300
0,360 360,780
switch work.|
|

2335
01:13:25,730 --> 01:13:26,990
0,480 480,630 630,720 720,1140 1140,1260
Another thing to notice is
另一件需要注意的事情是，我们正在查看的代码，

2336
01:13:26,990 --> 01:13:28,850
0,330 870,1110 1110,1440 1440,1530 1530,1860
that the code we're looking

2337
01:13:28,850 --> 01:13:29,810
0,150 150,270 270,570 570,810 810,960
at,| this switch code, this
|这个切换代码，这真的是线程切换的核心。

2338
01:13:29,810 --> 01:13:31,670
0,120 120,330 330,420 420,1110 1140,1860
is really the heart of

2339
01:13:31,730 --> 01:13:33,600
0,630 630,1260
thread switching.|
|

2340
01:13:33,600 --> 01:13:34,950
0,300 420,840 840,1110 1110,1230 1230,1350
And really all you have
实际上，您要做的就是切换线程

2341
01:13:34,950 --> 01:13:36,210
0,90 90,240 240,330 330,720 720,1260
to do to switch switch

2342
01:13:36,210 --> 01:13:39,000
0,600 600,1110 1620,2100 2100,2700 2700,2790
threads| is save registers and
|是保存寄存器和恢复寄存器，

2343
01:13:39,000 --> 01:13:41,310
0,480 480,1470 1560,1800 1800,2160 2160,2310
restore registers,| now threads have
|现在线程有比寄存器多得多的状态，

2344
01:13:41,310 --> 01:13:42,210
0,30 30,270 270,450 450,810 810,900
a lot more state than

2345
01:13:42,210 --> 01:13:44,130
0,210 210,690 690,780 780,930 930,1920
just registers,| they have variables
|他们堆里有变量和东西，谁知道是什么，

2346
01:13:44,130 --> 01:13:45,540
0,330 360,750 750,840 840,900 900,1410
and stuff in the heap

2347
01:13:45,540 --> 01:13:47,490
0,150 150,270 270,450 450,1200 1320,1950
and who knows what {},|
|

2348
01:13:47,580 --> 01:13:49,710
0,600 600,810 810,1020 1020,1770 1860,2130
all that other state is
所有其他状态都在内存中，不会受到干扰，

2349
01:13:49,710 --> 01:13:51,510
0,870 1050,1410 1410,1620 1620,1740 1740,1800
in-memory and isn't going to

2350
01:13:51,510 --> 01:13:53,040
0,120 120,870 870,1020 1020,1200 1200,1530
be disturbed,| we've done nothing
|我们没有做任何干扰这些线程堆栈的事情，

2351
01:13:53,040 --> 01:13:54,620
0,90 90,1020
to disturb

2352
01:13:54,620 --> 01:13:56,750
0,450 450,540 540,810 810,1350 1350,2130
any of these threads stacks,|
|

2353
01:13:56,750 --> 01:13:59,240
0,120 120,630 630,1050 1200,1560 1560,2490
for example or heap values,|
例如或堆值，|

2354
01:14:00,320 --> 01:14:01,940
0,240 240,570 600,1350 1350,1470 1470,1620
so the registers in the
所以微处理器中的寄存器实际上是唯一一种易失性状态，

2355
01:14:01,940 --> 01:14:03,380
0,780 780,840 840,1080 1080,1200 1200,1440
microprocessor are really the only

2356
01:14:03,380 --> 01:14:05,060
0,180 180,270 270,750 750,1320 1350,1680
kind of volatile state,| that
|实际上需要保存和恢复才能进行线程切换，

2357
01:14:05,270 --> 01:14:06,290
0,360 360,570 570,630 630,720 720,1020
actually needs to be saved

2358
01:14:06,290 --> 01:14:07,040
0,90 90,480 480,570 570,690 690,750
and restored to do a

2359
01:14:07,040 --> 01:14:08,540
0,270 270,690 720,1170 1170,1230 1230,1500
thread switch,| all the stuffs
|例如，存储器堆栈中的所有内容，

2360
01:14:08,540 --> 01:14:10,280
0,60 60,720 810,1260 1260,1350 1350,1740
in memory stack for example,|
|

2361
01:14:10,280 --> 01:14:11,450
0,120 120,480 480,570 570,660 660,1170
will still be in memory
仍会在记忆中原封不动地留在你的记忆里

2362
01:14:11,450 --> 01:14:13,310
0,360 390,1350 1440,1680 1680,1800 1800,1860
on undisturbed| and so it
|因此，它不需要显式保存和恢复。

2363
01:14:13,310 --> 01:14:14,360
0,180 180,300 300,390 390,450 450,1050
doesn't have to be explicitly

2364
01:14:14,360 --> 01:14:15,900
0,450 450,540 540,1260
saved and restored.|
|

2365
01:14:16,380 --> 01:14:17,190
0,150 150,270 270,420 420,720 720,810
Now we're only saving and
现在我们只保存和恢复这个微处理器，CPU寄存器，

2366
01:14:17,190 --> 01:14:19,200
0,330 330,660 690,1530 1530,1620 1620,2010
restoring this microprocessor, the CPU

2367
01:14:19,200 --> 01:14:20,610
0,630 780,1080 1080,1170 1170,1320 1320,1410
registers,| because we want to
|因为我们希望为新线程重用CPU中的那些寄存器

2368
01:14:20,610 --> 01:14:22,770
0,660 660,1110 1110,1500 1500,2070 2070,2160
reuse those very registers in

2369
01:14:22,770 --> 01:14:23,790
0,60 60,660 660,810 810,900 900,1020
the CPU for the new

2370
01:14:23,790 --> 01:14:25,800
0,540 540,660 690,1260 1260,1620 1620,2010
thread| and overwrite whatever values
|并覆盖它们拥有的任何值。

2371
01:14:25,800 --> 01:14:28,360
0,120 120,690 1050,1470 1500,2010
they have.| {} So,
所以，注册，这就是为什么我们必须保存旧线程的寄存器。

2372
01:14:28,650 --> 01:14:29,940
0,510 510,1020 1020,1110 1110,1200 1200,1290
register, that's why we have

2373
01:14:29,940 --> 01:14:31,050
0,90 90,420 420,600 600,810 810,1110
to save the old thread's

2374
01:14:31,050 --> 01:14:32,480
0,750
registers.|
|

2375
01:14:32,970 --> 01:14:34,800
0,210 210,420 420,900 930,1470 1500,1830
{} What about, {} other
那么，其他处理器说，

2376
01:14:34,800 --> 01:14:36,270
0,660 660,1020 1050,1260 1260,1320 1320,1470
processors state,| so I don't
|所以我不知道我们使用的RISC-V处理器有其他标志，

2377
01:14:36,270 --> 01:14:37,590
0,180 180,360 360,660 660,810 810,1320
know the {RISC-V -} processor

2378
01:14:37,590 --> 01:14:39,330
0,180 180,360 360,720 720,1080 1080,1740
that we're using has other

2379
01:14:39,360 --> 01:14:40,500
0,510 510,660 660,720 720,930 930,1140
flags,| but I know like
|但我知道有些x86英特尔芯片有浮点单元状态

2380
01:14:40,500 --> 01:14:42,330
0,210 210,1020 1020,1350 1350,1650 1650,1830
some x86 Intel chips have

2381
01:14:42,330 --> 01:14:44,130
0,390 600,990 990,1080 1080,1500 1500,1800
like like the floating point

2382
01:14:44,130 --> 01:14:45,840
0,330 330,840 840,990 990,1350 1350,1710
unit state| and like things
|诸如此类的事情，

2383
01:14:45,840 --> 01:14:47,610
0,210 210,780 780,930 930,1380 1590,1770
like that,| do we do
|我们有吗？我们只是在RISC-V中没有这个。

2384
01:14:47,610 --> 01:14:48,540
0,90 90,270 270,450 450,630 630,930
we just not have that

2385
01:14:48,540 --> 01:14:50,560
0,450
{in,RISC-V}.|
|

2386
01:14:50,620 --> 01:14:51,910
0,300 300,600 600,780 780,900 900,1290
Your point's very well taken
你的观点在其他微处理器如x86上得到了很好的理解，

2387
01:14:51,910 --> 01:14:54,550
0,180 210,510 510,1440 1440,1650 1650,2640
on other microprocessors like x86,|
|

2388
01:14:54,550 --> 01:14:56,680
0,360 360,1620
the details
细节切换略有不同，

2389
01:14:56,770 --> 01:14:58,600
0,690 690,1320 1320,1560 1560,1650 1650,1830
{} switching are a bit

2390
01:14:58,600 --> 01:15:00,430
0,360 360,990 1110,1500 1500,1590 1590,1830
different,| because they have different
|因为它们在不同的状态下具有不同的寄存器

2391
01:15:00,430 --> 01:15:03,220
0,480 480,540 540,780 780,1260 2400,2790
registers in different state| and
|所以代码这是非常依赖于RISC-V的代码

2392
01:15:03,220 --> 01:15:04,180
0,90 90,180 180,570 570,810 810,960
so the code this is

2393
01:15:04,180 --> 01:15:05,830
0,390 390,720 720,990 990,1290 1290,1650
very very {RISC-V -} dependent

2394
01:15:05,830 --> 01:15:08,290
0,540 540,1020 1140,1470 1470,1950 1950,2460
code| and the switch routine
|并且用于某些其他处理器的切换例程可能看起来完全不同，

2395
01:15:08,290 --> 01:15:11,120
0,390 720,960 960,1350 1530,2370
for some other processor

2396
01:15:11,210 --> 01:15:12,230
0,240 240,330 330,540 540,840 840,1020
might look quite different,| like
|例如确实可能必须保存浮点寄存器，

2397
01:15:12,230 --> 01:15:13,610
0,390 390,540 540,660 660,780 780,1380
indeed might have to save

2398
01:15:13,820 --> 01:15:15,590
0,330 330,540 540,1230 1440,1680 1680,1770
floating point registers,| now at
|现在RISC-V实际上使用的是通用寄存器。

2399
01:15:15,590 --> 01:15:16,940
0,180 180,450 450,750 750,1020 1020,1350
{RISC-V -} actually uses the

2400
01:15:17,530 --> 01:15:19,540
0,360 360,690 690,1560
general purpose register.|
|

2401
01:15:20,220 --> 01:15:21,930
0,600 1050,1350 1350,1470 1470,1590 1590,1710
Actually I'm not sure what
实际上我不确定它对浮点数有什么作用，

2402
01:15:21,930 --> 01:15:22,860
0,90 90,240 240,360 360,630 630,930
it does for floating point,|
|

2403
01:15:22,950 --> 01:15:24,540
0,750 840,990 990,1200 1200,1440 1440,1590
but the kernel doesn't use
但是内核不使用浮点，所以不用担心，

2404
01:15:24,540 --> 01:15:25,350
0,270 270,480 480,570 570,630 630,810
floating point, so it doesn't

2405
01:15:25,350 --> 01:15:26,100
0,120 120,210 210,420 420,600 600,750
have to worry about it,|
|

2406
01:15:27,300 --> 01:15:28,410
0,360 360,480 480,600 600,690 690,1110
but yeah this is totally
但是，是的，这完全依赖于微处理器。

2407
01:15:28,410 --> 01:15:30,100
0,720 720,1140
microprocessor dependent.|
|

2408
01:15:31,710 --> 01:15:33,150
0,240 240,600 600,900 900,1080 1080,1440
A question about the timer
有关计时器的问题被打断。

2409
01:15:33,150 --> 01:15:34,620
0,720
interrupts.|
|

2410
01:15:34,680 --> 01:15:35,970
0,240 240,420 420,750 750,990 990,1290
So it sounds like the
所以这听起来像是所有日程安排工作的核心

2411
01:15:35,970 --> 01:15:37,320
0,90 90,630 630,840 840,1080 1080,1350
the core of all of

2412
01:15:37,320 --> 01:15:38,360
0,450
this

2413
01:15:38,360 --> 01:15:40,160
0,660 660,1260 1260,1500 1500,1650 1650,1800
scheduling working| is that there
|会有一个定时器中断，

2414
01:15:40,160 --> 01:15:41,390
0,150 150,240 240,300 300,570 570,1230
will be a timer interrupt,|
|

2415
01:15:41,750 --> 01:15:43,160
0,240 240,480 480,960 960,1050 1050,1410
{} what happens in cases
在这种(故障)情况下会发生什么。

2416
01:15:43,160 --> 01:15:46,070
0,300 300,660 810,1860 2100,2730 2730,2910
where that [malfunctions].| There is
|将会有一个定时器中断。

2417
01:15:46,070 --> 01:15:46,700
0,120 120,180 180,270 270,330 330,630
going to be a timer

2418
01:15:46,700 --> 01:15:47,800
0,600
interrupt.|
|

2419
01:15:49,070 --> 01:15:52,720
0,630 960,1740 2100,2940
{} So the,
所以，我知道是这样的，

2420
01:15:52,810 --> 01:15:55,150
0,120 120,270 270,270 960,1530 1830,2340
I know {} so {},|
|

2421
01:15:55,180 --> 01:15:56,590
0,270 270,600 600,780 780,1260 1260,1410
okay, so the reasoning for
好的，那么用户进程的抢占式调度是如何起作用的推理，

2422
01:15:56,590 --> 01:15:59,140
0,240 240,690 810,1800 1800,2370 2370,2550
how come preemptive scheduling of

2423
01:15:59,140 --> 01:16:01,380
0,360 360,930 930,1740
user process's works,|
|

2424
01:16:01,410 --> 01:16:03,780
0,390 390,600 600,930 1440,1860 1860,2370
{} is that user processes
用户进程总是在打开中断的情况下执行，

2425
01:16:03,780 --> 01:16:05,500
0,540 540,1170
execute with

2426
01:16:05,740 --> 01:16:07,930
0,450 450,660 660,900 900,1770 1830,2190
interrupts turned on always,| {xv6
|xv6只是确保在返回用户空间之前启用中断

2427
01:16:07,930 --> 01:16:10,570
0,270 270,750 1110,1710 1710,1950 2220,2640
-} just ensures that interrupts

2428
01:16:10,570 --> 01:16:12,250
0,150 150,840 870,1260 1260,1590 1590,1680
are enabled before returning to

2429
01:16:12,250 --> 01:16:13,390
0,240 240,750 750,870 870,1020 1020,1140
user space| and that means
|这意味着如果您在用户空间中执行，可能会发生计时器中断，

2430
01:16:13,390 --> 01:16:14,680
0,120 120,180 180,510 510,960 990,1290
that a timer interrupt can

2431
01:16:14,680 --> 01:16:16,060
0,480 570,750 750,870 870,1290 1290,1380
happen if you're executing in

2432
01:16:16,060 --> 01:16:18,550
0,270 270,750 1140,1620 1740,2160 2160,2490
user space,| so there's nothing
|所以没有用户进程，如果一个用户空间计时器中断就会发生，

2433
01:16:18,550 --> 01:16:20,440
0,120 120,420 420,1290 1620,1770 1770,1890
a user process, if one

2434
01:16:20,440 --> 01:16:21,250
0,240 240,450 450,570 570,750 750,810
user space that {timer -}

2435
01:16:21,250 --> 01:16:22,760
0,270 270,450 450,630 630,990
interrupt just will happen,|
|

2436
01:16:22,820 --> 01:16:24,020
0,180 180,360 360,420 420,630 630,1200
{} when the time comes.|
当时机成熟的时候。|

2437
01:16:24,200 --> 01:16:25,520
0,360 360,750 750,810 810,870 870,1320
{So,little} trickier in the kernel,|
所以在内核中有一点微妙之处，|

2438
01:16:25,610 --> 01:16:26,840
0,180 180,420 420,810 810,1050 1050,1230
the kernel sometimes turns off
内核有时会关闭中断，

2439
01:16:26,840 --> 01:16:28,250
0,480 480,750 750,990 990,1080 1080,1410
interrupts,| like when you acquire
|就像当你拿到一把锁的时候，

2440
01:16:28,250 --> 01:16:29,480
0,60 60,600 720,840 840,1170 1170,1230
a lock,| the interrupts are
|中断将被关闭，

2441
01:16:29,480 --> 01:16:30,170
0,120 120,180 180,240 240,480 480,690
going to be turned off,|
|

2442
01:16:30,170 --> 01:16:31,910
0,210 210,330 330,660 660,840 1200,1740
until you release it.| So.|
直到你释放它。|所以。|

2443
01:16:32,150 --> 01:16:33,640
0,960

2444
01:16:34,600 --> 01:16:36,490
0,450 450,930 1350,1590 1590,1740 1740,1890
{} So if there were
所以如果内核中有一些错误，

2445
01:16:36,490 --> 01:16:38,110
0,600 600,900 900,990 990,1050 1050,1620
some bugs in the kernel,|
|

2446
01:16:39,040 --> 01:16:40,000
0,210 210,270 270,540 540,780 780,960
if the kernel turned off
如果内核关闭中断

2447
01:16:40,000 --> 01:16:41,500
0,570 570,840 840,1110 1110,1380 1380,1500
interrupts| and never turn them
|永远不要再打开它们

2448
01:16:41,500 --> 01:16:43,840
0,300 300,840 1260,1650 1650,1800 2010,2340
back on| and the code
|内核中的代码从未放弃CPU

2449
01:16:43,840 --> 01:16:44,890
0,60 60,120 120,450 450,840 840,1050
in the kernel never gave

2450
01:16:44,890 --> 01:16:46,630
0,120 120,210 210,1020 1080,1470 1470,1740
up the CPU| never called
从来没有叫过休眠，因为任何其他原因放弃了CPU，

2451
01:16:46,630 --> 01:16:48,070
0,660 660,870 870,960 960,1050 1050,1440
sleep, gave up the CPU

2452
01:16:48,070 --> 01:16:49,960
0,180 180,360 360,570 570,960 1440,1890
for any other reason,| then
|那么确实会发生计时器中断

2453
01:16:49,960 --> 01:16:52,450
0,720 900,1500 1500,1890 1890,2250 2250,2490
indeed a timer interrupt would

2454
01:16:52,450 --> 01:16:53,950
0,600 600,960 960,1110 1110,1260 1260,1500
occur| and that would mean
|这将意味着，这个内核代码，可能你知道，永远不会给CPU，

2455
01:16:53,950 --> 01:16:54,740
0,360
that,

2456
01:16:55,470 --> 01:16:56,940
0,240 240,510 510,780 780,1290 1320,1470
this kernel code, may you

2457
01:16:56,940 --> 01:16:57,920
0,270
know,

2458
01:16:58,890 --> 01:16:59,850
0,240 240,570 570,720 720,870 870,960
{} would never give the

2459
01:16:59,850 --> 01:17:01,640
0,450 450,570 570,660 660,1230
CPU,| but in fact,
|但事实上，据我们所知，xv6就是xv6，

2460
01:17:01,670 --> 01:17:02,480
0,330 330,480 480,600 600,690 690,810
{} as far as we

2461
01:17:02,480 --> 01:17:05,030
0,510 810,1170 1170,1830 1920,2280 2280,2550
know {xv6 -} [is] {xv6

2462
01:17:05,030 --> 01:17:06,680
0,300 300,420 420,690 900,1380 1380,1650
-},| so that {} it
|所以它总是重新打开中断，

2463
01:17:06,680 --> 01:17:08,150
0,330 330,570 570,960 960,1230 1230,1470
always turns interrupts back on,|
|

2464
01:17:08,150 --> 01:17:09,060
0,360
or
或者你知道，如果xv6中有代码，它就会关闭中断，

2465
01:17:09,900 --> 01:17:11,310
0,150 150,300 330,510 510,690 690,1410
you know, if there's {code,in,xv6},

2466
01:17:11,310 --> 01:17:12,840
0,90 90,300 300,570 570,1200 1290,1530
it turns off interrupts,| it
|它要么让他们重新振作起来

2467
01:17:12,840 --> 01:17:14,250
0,180 180,480 480,600 600,870 870,1410
either turns them back on|
|

2468
01:17:14,280 --> 01:17:15,640
0,180 180,420 420,780
and so {}
因此定时器中断然后可以在内核中发生，

2469
01:17:16,240 --> 01:17:17,500
0,330 330,630 630,780 780,960 960,1260
timer interrupt can then occur

2470
01:17:17,500 --> 01:17:18,280
0,60 60,120 120,570 570,690 690,780
in the kernel,| and we
|我们可以从这个内核线程切换

2471
01:17:18,280 --> 01:17:19,300
0,210 210,540 540,750 750,900 900,1020
can switch away from this

2472
01:17:19,300 --> 01:17:21,490
0,270 270,720 870,1620 1830,2100 2100,2190
kernel thread| or {} the
|或者代码返回到用户空间，

2473
01:17:21,490 --> 01:17:22,600
0,240 240,570 570,750 750,840 840,1110
code returns back to user

2474
01:17:22,600 --> 01:17:24,370
0,750 780,1020 1020,1290 1290,1560 1560,1770
space,| kernel code turns back
|内核代码返回到用户空间，

2475
01:17:24,370 --> 01:17:26,020
0,90 90,330 330,780 810,990 990,1650
to user space,| we believe
|我们认为，内核代码永远不会在中断关闭的情况下简单地循环。

2476
01:17:26,080 --> 01:17:27,340
0,270 270,450 450,510 510,1170 1170,1260
there's never a situation in

2477
01:17:27,340 --> 01:17:29,200
0,210 210,540 540,1020 1200,1530 1530,1860
which kernel code will simply

2478
01:17:29,200 --> 01:17:31,300
0,780 990,1200 1200,1560 1560,1800 1800,2100
loop with interrupts turned off

2479
01:17:31,300 --> 01:17:32,360
0,600
forever.|
|

2480
01:17:33,990 --> 01:17:35,280
0,90 90,390 450,810 810,1140 1140,1290
I got, my question was
我得到了，我的问题更多的是关于，

2481
01:17:35,280 --> 01:17:36,420
0,180 180,510 510,810 840,1020 1020,1140
more about like,| so I
|所以我假设中断实际上来自某个硬件，

2482
01:17:36,420 --> 01:17:37,620
0,240 240,420 420,900 900,960 960,1200
assume the interrupts are actually

2483
01:17:37,620 --> 01:17:38,490
0,240 240,420 420,570 570,780 780,870
coming from some piece of

2484
01:17:38,490 --> 01:17:40,140
0,600 840,1080 1080,1200 1200,1470 1470,1650
hardware,| what if that piece
|如果那个硬件[故障]。

2485
01:17:40,140 --> 01:17:42,580
0,90 90,510 510,1350 1380,1830
of hardware [malfunctions].| No.|
|不是的。|

2486
01:17:45,330 --> 01:17:46,740
0,90 90,420 840,1080 1080,1350 1350,1410
It's {all,right}, your computer is
没关系，你的电脑坏了，你应该买一台新的。

2487
01:17:46,740 --> 01:17:47,520
0,360 360,480 480,600 600,720 720,780
broken, you should buy a

2488
01:17:47,520 --> 01:17:48,500
0,120 120,270
new one.|
|

2489
01:17:50,560 --> 01:17:52,450
0,360 450,540 540,1530 1530,1680 1680,1890
Okay.| I mean that's a
好吧。|我是说，这是一个合理的问题，

2490
01:17:52,450 --> 01:17:53,860
0,270 270,630 630,930 960,1080 1080,1410
valid question for,| {} there's
|你知道你的电脑里有100亿个晶体管，

2491
01:17:54,070 --> 01:17:56,080
0,210 210,420 630,1020 1020,1380 1380,2010
you know 10 billion transistors

2492
01:17:56,080 --> 01:17:57,880
0,60 60,180 180,660 660,1110 1170,1800
in your computer,| and indeed
|的确，有时硬件就像有漏洞一样，但这超出了我们的能力范围。

2493
01:17:58,000 --> 01:17:59,760
0,630 630,690 690,1230
sometimes the hardware

2494
01:17:59,970 --> 01:18:00,930
0,330 330,480 480,630 630,870 870,960
just like has bugs in

2495
01:18:00,930 --> 01:18:02,220
0,120 120,240 240,690
it, but that's

2496
01:18:02,490 --> 01:18:04,880
0,630 630,810 810,1410 1410,1800
beyond our reach for.|
|

2497
01:18:05,220 --> 01:18:06,540
0,210 210,420 480,900 900,1020 1020,1320
I mean, if you add
我是说，如果你把一加一，电脑就会说三，

2498
01:18:06,540 --> 01:18:07,380
0,210 210,300 300,510 510,750 750,840
one and one and the

2499
01:18:07,380 --> 01:18:09,460
0,330 330,600 600,960 960,1350
computer says three,| then
|那么您就会遇到xv6无法帮助您解决的深层次问题。

2500
01:18:10,690 --> 01:18:12,160
0,360 360,510 510,630 630,840 840,1470
you just have deep problems

2501
01:18:12,160 --> 01:18:13,750
0,210 570,1110 1110,1320 1320,1500 1500,1590
that xv6 can't help you

2502
01:18:13,750 --> 01:18:14,900
0,360
with.|
|

2503
01:18:16,710 --> 01:18:17,910
0,270 270,420 420,870 870,1020 1020,1200
So we're assuming that the
所以我们假设计算机可以工作。

2504
01:18:17,910 --> 01:18:19,380
0,330 330,990
computer works.|
|

2505
01:18:20,370 --> 01:18:21,780
0,360 360,540 540,870 870,1020 1020,1410
The only time when that,|
唯一的一次是，|

2506
01:18:23,030 --> 01:18:25,580
0,240 240,1320 1440,1710 1800,2490 2490,2550
when software mean,| there are
当软件意味着，|有时软件试图补偿硬件级错误，

2507
01:18:25,580 --> 01:18:26,480
0,240 240,330 330,630 630,810 810,900
times when software tries to

2508
01:18:26,480 --> 01:18:28,100
0,450 450,570 570,870 870,1110 1110,1620
compensate for hardware level errors,|
|

2509
01:18:28,100 --> 01:18:29,660
0,330 390,660 660,750 750,1200 1200,1560
like if you're sending packets
例如，如果您要通过网络发送数据包，

2510
01:18:29,660 --> 01:18:31,520
0,270 270,360 360,1080 1440,1680 1680,1860
across the network,| you always
|你总是发送校验和，

2511
01:18:31,520 --> 01:18:33,240
0,150 150,210 210,1200
send a checksum,|
|

2512
01:18:33,240 --> 01:18:34,710
0,210 210,420 420,720 720,960 990,1470
so that if the network
因此如果网络硬件翻转一点，故障就会翻转一点，

2513
01:18:34,710 --> 01:18:37,590
0,750 930,1350 1350,1410 1410,1710 2010,2880
hardware flips a bit malfunctions

2514
01:18:37,590 --> 01:18:38,730
0,300 300,360 360,630 630,930 990,1140
flips a bit,| then you
|那么你就可以纠正这一点，

2515
01:18:38,730 --> 01:18:40,260
0,240 480,810 810,990 990,1230 1260,1530
can correct that,| but for
|但是对于电脑里的东西，

2516
01:18:40,260 --> 01:18:42,100
0,210 210,540 540,630 630,1080
stuff inside the computer,|
|

2517
01:18:42,100 --> 01:18:43,540
0,180 180,450 450,720 720,1080 1260,1440
people tend not to,| it's
人们往往不会，|只是，人们基本上不会试图让软件来补偿硬件错误。

2518
01:18:43,540 --> 01:18:44,340
0,300
just,

2519
01:18:45,740 --> 01:18:47,340
0,210 210,570 570,900
people basically don't

2520
01:18:47,890 --> 01:18:48,760
0,270 270,330 330,480 480,540 540,870
try to make the software

2521
01:18:48,760 --> 01:18:50,880
0,540 540,660 660,1020 1020,1530
compensate for hardware errors.|
|

2522
01:18:54,170 --> 01:18:55,340
0,270 270,390 390,570 570,660 660,1170
Oh, I have a question,
哦，我有个问题，为什么我会像是在践踏圆点，

2523
01:18:55,340 --> 01:18:57,530
0,690 720,840 840,990 990,1320 1800,2190
why I was like in

2524
01:18:57,560 --> 01:19:00,410
0,630 630,1020 1050,1710 1710,2160 2220,2850
trampling dot actually swhich,| we
|我们用汇编语言编写代码，

2525
01:19:00,440 --> 01:19:02,570
0,390 390,720 720,1260 1290,1590 1590,2130
write the code in assembly,|
|

2526
01:19:02,570 --> 01:19:03,860
0,150 150,330 330,780 810,1080 1080,1290
is that why,| is that
这就是为什么|是不是因为我们想要确保这件事的发生，

2527
01:19:03,860 --> 01:19:05,150
0,600 600,750 750,990 990,1110 1110,1290
because we want to make

2528
01:19:05,150 --> 01:19:07,700
0,300 300,630 1020,1800 1800,2280 2280,2550
sure that exactly this thing

2529
01:19:07,700 --> 01:19:09,840
0,750 930,1140 1140,1230 1230,1710
happening,| so we cannot,
|所以我们不能，你不能用C写，

2530
01:19:10,180 --> 01:19:11,140
0,120 120,300 300,660 660,810 810,960
you cann't write in C,|
|

2531
01:19:11,140 --> 01:19:13,440
0,630 990,1200 1200,1440 1440,1740
because we just need
因为我们只是需要它，感觉这些事情基本上都会发生。

2532
01:19:13,440 --> 01:19:15,180
0,120 120,540 540,870 1080,1320 1320,1740
it feels like those exact

2533
01:19:15,180 --> 01:19:17,140
0,270 270,390 390,690 690,1320
things to happen basically.|
|

2534
01:19:17,390 --> 01:19:18,860
0,840

2535
01:19:19,530 --> 01:19:22,300
0,510 510,1170 1320,2010
Yeah yeah, um.|
是啊，是啊，嗯。|

2536
01:19:22,800 --> 01:19:23,700
0,210 210,480 480,600 600,750 750,900
Yes, certainly we want this
是的，我们当然希望这个确切的顺序发生，

2537
01:19:23,700 --> 01:19:26,460
0,360 360,690 690,990 1770,2070 2340,2760
exact sequence to {happen -},|
|

2538
01:19:26,460 --> 01:19:29,370
0,360 360,960 1920,2190 2190,2730 2730,2910
and C it it's very
C它很难谈论像ra这样的事情

2539
01:19:29,370 --> 01:19:30,180
0,150 150,240 240,480 480,660 660,810
hard to talk about things

2540
01:19:30,180 --> 01:19:31,830
0,180 180,450 450,780 780,930 930,1650
like {ra -}| and see
|当然，在C语言中，没有办法谈论改变堆栈指针，

2541
01:19:32,380 --> 01:19:33,940
0,1050
{or,sp}

2542
01:19:34,120 --> 01:19:35,470
0,480 540,960 960,1110 1110,1200 1200,1350
{} certainly there's no way

2543
01:19:35,470 --> 01:19:37,060
0,270 270,360 360,600 600,1230 1230,1590
within the C language to

2544
01:19:37,660 --> 01:19:39,100
0,270 270,720 720,1050 1050,1140 1140,1440
talk about changing the stack

2545
01:19:39,100 --> 01:19:40,300
0,570
pointer,|
|

2546
01:19:40,840 --> 01:19:42,660
0,180 180,360 360,570 570,1290
with {ra -} register,|
利用RA寄存器，|

2547
01:19:42,660 --> 01:19:43,860
0,150 150,600 600,660 660,990 990,1200
so these are things that,
所以这些东西，不可能是你在普通的C中看不到的，

2548
01:19:45,340 --> 01:19:46,840
0,210 210,450 450,900 1170,1290 1290,1500
just can't be you can't

2549
01:19:46,840 --> 01:19:48,760
0,270 270,480 480,750 990,1410 1410,1920
see it in ordinary C,|
|

2550
01:19:49,270 --> 01:19:50,290
0,480 510,630 630,780 780,900 900,1020
{} the only way you
你能在C中看到它的唯一方式，

2551
01:19:50,290 --> 01:19:51,100
0,120 120,270 270,390 390,480 480,810
can see it in C,|
|

2552
01:19:51,100 --> 01:19:53,140
0,330 360,750 750,960 960,1530 1560,2040
is there, there is possible
如果有，那么在C语言中就有可能在C代码中嵌入汇编语言指令，

2553
01:19:53,140 --> 01:19:53,890
0,90 90,390 390,510 510,690 690,750
in C to sort of

2554
01:19:53,890 --> 01:19:56,410
0,570 750,1230 1230,2130 2130,2280 2280,2520
embed assembly instructions in C

2555
01:19:56,410 --> 01:19:57,820
0,510 930,1140 1140,1230 1230,1320 1320,1410
code,| so we could have
|所以我们可以把这些汇编指令嵌入到C函数中，

2556
01:19:57,820 --> 01:20:00,070
0,150 150,480 480,960 960,1320 1320,2250
just embedded these assembly instructions

2557
01:20:00,100 --> 01:20:01,060
0,60 60,120 120,330 330,660 660,960
in the C function,| but,
|但是，这就等同于一件事了。

2558
01:20:01,730 --> 01:20:02,480
0,150 150,360 360,450 450,540 540,750
would amount to the same

2559
01:20:02,480 --> 01:20:03,360
0,270
thing.|
|

2560
01:20:03,510 --> 01:20:04,980
0,450 450,810 810,930 930,1380 1380,1470
We're basically we're operating at
我们基本上是在低于摄氏度的水平下运作，

2561
01:20:04,980 --> 01:20:07,080
0,60 60,480 480,1530
a level below

2562
01:20:07,140 --> 01:20:08,430
0,360 360,780 780,960 960,1050 1050,1290
below C,| so we can't
|所以我们在这里不能真的用到C。

2563
01:20:08,430 --> 01:20:09,420
0,330
really

2564
01:20:09,820 --> 01:20:11,080
0,210 210,480 480,630 630,840 840,1260
can't really use C here.|
|

2565
01:20:13,950 --> 01:20:15,030
0,150 150,330 330,420 420,750 750,1080
I have a question,| about
我有个问题，|关于线程完成执行的时间

2566
01:20:15,030 --> 01:20:17,280
0,150 150,540 630,1170 1170,1650 1650,2250
when a thread finishes executing|
|

2567
01:20:17,280 --> 01:20:18,570
0,120 120,570 570,810 810,1230 1230,1290
and assuming that happens in
假设这发生在用户空间

2568
01:20:18,570 --> 01:20:19,590
0,90 90,390 390,720 720,900 900,1020
the user space| when we
|当我们呼叫执行人员时，我很抱歉，执行系统呼叫

2569
01:20:19,590 --> 01:20:21,180
0,300 300,450 450,990 990,1290 1290,1590
call the exec {}, I'm

2570
01:20:21,180 --> 01:20:22,220
0,450
sorry,

2571
01:20:22,220 --> 01:20:25,640
0,510 510,960 960,1380 2010,2730 2970,3420
exec system call| and {}
|这也结束了进程，线程假设在内核空间中，

2572
01:20:25,700 --> 01:20:27,620
0,360 360,870 870,1140 1140,1260 1260,1920
that also ends the process,

2573
01:20:27,980 --> 01:20:29,030
0,150 150,420 420,510 510,900 900,1050
the thread {} assuming in

2574
01:20:29,030 --> 01:20:30,830
0,90 90,420 420,1080 1170,1530 1530,1800
the kernel space,| but if
|但是如果线程在新的定时器中断发生之前在内结束，

2575
01:20:30,830 --> 01:20:33,260
0,510 630,1170 1170,2010
the thread ends

2576
01:20:33,260 --> 01:20:34,940
0,540 570,1110 1110,1200 1200,1380 1380,1680
within before a new timer

2577
01:20:34,940 --> 01:20:37,130
0,450 450,1170 1230,1470 1470,1620 1620,2190
interrupt happens,| does it still
|它看起来还像是，

2578
01:20:37,130 --> 01:20:39,300
0,120 120,1410
look like,|
|

2579
01:20:39,570 --> 01:20:41,310
0,180 180,990 1020,1200 1200,1290 1290,1740
is this like the CPU
这就像CPU还在被那个线程获取吗

2580
01:20:41,310 --> 01:20:42,720
0,270 270,750 750,870 870,1140 1140,1410
still acquired by that thread|
|

2581
01:20:42,720 --> 01:20:44,220
0,150 150,750 780,1050 1050,1260 1260,1500
or {do,we} and that thread
或者我们是不是把那条线索放在一起，开始一条新的

2582
01:20:44,220 --> 01:20:45,060
0,120 120,360 360,420 420,600 600,840
and start a new one|
|

2583
01:20:45,060 --> 01:20:46,380
0,300 300,390 390,540 540,810 810,1320
before the new timer interrupt.|
在新的定时器中断之前。|

2584
01:20:46,560 --> 01:20:48,240
0,300 300,900
Oh yeah,|
哦，是的,|

2585
01:20:48,240 --> 01:20:49,400
0,600

2586
01:20:49,460 --> 01:20:53,060
0,480 480,1170 1800,2520 2670,3300 3300,3600
the thread, the  thread yields
线程，线程产生CPU，

2587
01:20:53,060 --> 01:20:54,540
0,120 120,870
the CPU,|
|

2588
01:20:54,820 --> 01:20:56,530
0,120 120,270 270,780 1050,1440 1440,1710
there's the exec exec yields
有一个exec exec产生CPU，

2589
01:20:56,530 --> 01:20:57,730
0,90 90,630 660,810 810,990 990,1200
the CPU,| so there's actually
|所以实际上有很多要点，

2590
01:20:57,730 --> 01:20:59,920
0,360 360,960 960,1140 1860,2100 2100,2190
many points,| that even though
|即使我一直在用计时器中断来推动这场讨论，

2591
01:20:59,920 --> 01:21:01,060
0,120 120,300 300,630 630,750 750,1140
I've been driving this discussion

2592
01:21:01,060 --> 01:21:02,110
0,90 90,150 150,510 510,900 900,1050
with a timer interrupt,| in
|事实上，在几乎所有的情况下，

2593
01:21:02,110 --> 01:21:03,380
0,720
fact,

2594
01:21:04,300 --> 01:21:06,070
0,150 150,720 750,1110 1110,1320 1320,1770
in almost almost all cases|
|

2595
01:21:06,070 --> 01:21:07,840
0,450 450,690 690,960 960,1500 1500,1770
where {xv6 -} switches between
在xv6在线程之间切换的情况下，

2596
01:21:07,840 --> 01:21:08,740
0,360 360,480 480,690 690,810 810,900
threads,| it's not due to
|这不是由于计时器中断，

2597
01:21:08,740 --> 01:21:12,430
0,360 360,930 1020,1410 1410,2190 3390,3690
timer interrupts,| it's because some
|这是因为有些系统调用在等待某些东西

2598
01:21:12,430 --> 01:21:13,960
0,300 300,600 600,900 900,1020 1020,1530
system calls waiting for something|
|

2599
01:21:13,960 --> 01:21:16,720
0,210 210,1260 1440,1740 1830,2190 2430,2760
or decides that it needs
或者决定需要放弃CPU

2600
01:21:16,720 --> 01:21:17,740
0,90 90,240 240,360 360,450 450,1020
to give up the CPU|
|

2601
01:21:17,770 --> 01:21:19,660
0,180 180,330 330,570 570,1170 1320,1890
and so for example exec
例如，EXEC执行各种操作，然后调用YELD来放弃CPU

2602
01:21:19,930 --> 01:21:21,430
0,300 300,600 600,1020 1020,1140 1140,1500
does various things and then

2603
01:21:21,430 --> 01:21:23,050
0,240 240,900 1170,1320 1320,1500 1500,1620
calls yield to {give,up} the

2604
01:21:23,050 --> 01:21:24,240
0,540 540,690
CPU| and
|它就是这么做的。

2605
01:21:24,240 --> 01:21:25,460
0,150 150,360 360,630
it does that.|
|

2606
01:21:25,490 --> 01:21:26,900
0,270 270,420 420,750 750,1200 1200,1410
There's really nothing does that
实际上，无论是否有计时器中断，都无法做到这一点。

2607
01:21:26,900 --> 01:21:28,430
0,630 630,690 690,990 990,1230 1230,1530
independently of whether there's timer

2608
01:21:28,430 --> 01:21:29,420
0,510
interrupt.|
|

2609
01:21:31,730 --> 01:21:32,840
0,570
Yes.|
是。|

2610
01:21:37,740 --> 01:21:40,110
0,240 240,420 420,810 840,1530 2100,2370
All right, the {} time
好了，这堂课的时间到了，

2611
01:21:40,110 --> 01:21:40,890
0,90 90,210 210,300 300,480 480,780
is up for this lecture,|
|

2612
01:21:40,890 --> 01:21:42,180
0,60 60,210 210,510 720,1110 1110,1290
I think I'll continue some
我想下周我会继续讨论这个问题，

2613
01:21:42,180 --> 01:21:44,190
0,60 60,180 180,960 1350,1830 1830,2010
of this discussion next week,|
|

2614
01:21:44,190 --> 01:21:45,330
0,120 120,240 240,570 570,810 840,1140
but I'm happy to take
但是我现在很乐意回答更多的问题，如果人们有问题的话。

2615
01:21:45,330 --> 01:21:47,670
0,180 180,1110 1560,1740 1740,2040 2220,2340
more questions right now, if

2616
01:21:47,670 --> 01:21:48,820
0,210 210,390 390,540
people have them.|
|

2617
01:21:52,150 --> 01:21:53,770
0,420 420,600 600,720 720,1050 1050,1620
So let's say the operating
那么让我们说操作系统实际上，

2618
01:21:53,770 --> 01:21:55,880
0,390 390,1050 1050,1560
system actually {},|
|

2619
01:21:56,320 --> 01:21:57,580
0,90 90,510 510,840 840,1020 1020,1260
I takes on a the
我采用了线程实现，

2620
01:21:57,580 --> 01:22:00,400
0,450 450,1290 1320,1860 1890,2550 2640,2820
thread implementation,| so so for
例如，您希望在多个CPU上运行一个进程的多个线程，

2621
01:22:00,400 --> 01:22:01,750
0,420 420,540 540,690 690,840 840,1350
example you want to run

2622
01:22:01,840 --> 01:22:03,790
0,570 570,960 960,1170 1170,1260 1260,1950
multiple threads of a process

2623
01:22:03,790 --> 01:22:05,710
0,540 690,1140 1140,1620 1620,1770 1770,1920
on multiple {CPUs -},| like
|这必须由操作系统来处理，

2624
01:22:05,710 --> 01:22:06,730
0,150 150,390 390,510 510,630 630,1020
that has to be handled

2625
01:22:06,730 --> 01:22:07,960
0,120 120,330 330,750 750,960 960,1230
by the OS,| that cannot
|这不能只在用户空间中正确处理。

2626
01:22:07,960 --> 01:22:09,160
0,270 270,450 450,840 840,930 930,1200
just be handled in user

2627
01:22:09,160 --> 01:22:10,990
0,360 360,780 1200,1440 1440,1620 1620,1830
space right.| How does that
|那种开关是怎么工作的？

2628
01:22:10,990 --> 01:22:12,130
0,180 180,240 240,600 600,960 960,1140
kind of switching work| is
|是每个线程，现在每个线程都变成了一个进程，

2629
01:22:12,130 --> 01:22:14,020
0,420 450,870 870,1200 1200,1440 1440,1890
each, each thread now becomes

2630
01:22:14,020 --> 01:22:15,130
0,90 90,330 330,420 420,510 510,1110
the same as a process,|
|

2631
01:22:15,130 --> 01:22:16,120
0,210 210,360 360,750 750,900 900,990
like is always going to
LIKE总是循环遍历所有现有线程

2632
01:22:16,120 --> 01:22:18,280
0,330 330,540 540,870 870,1440 1440,2160
loop through all existing threads|
|

2633
01:22:18,400 --> 01:22:19,780
0,1050
or
或者您知道，因为每个CPU仍然会在两个CPU之间切换，

2634
01:22:19,900 --> 01:22:21,010
0,240 240,420 420,600 600,840 840,1110
you know cause like each

2635
01:22:21,010 --> 01:22:22,630
0,480 480,630 630,900 900,1260 1260,1620
CPU will still switch between,|
|

2636
01:22:22,630 --> 01:22:23,860
0,270 270,390 390,540 540,1080 1080,1230
even if one process give
即使一个进程提供八个内核，

2637
01:22:23,860 --> 01:22:24,940
0,150 150,360 360,750 750,900 900,1080
{} eight cores,| like it's
|就像它还会在两个CPU之间切换

2638
01:22:24,940 --> 01:22:26,440
0,180 180,390 390,840 840,1260 1260,1500
still gonna switch switch each

2639
01:22:26,440 --> 01:22:28,330
0,120 120,210 210,660 660,1230 1380,1890
of the CPUs between those|
|

2640
01:22:28,330 --> 01:22:29,260
0,180 180,330 330,630 630,690 690,930
and a couple of other
以及其他几个过程

2641
01:22:29,260 --> 01:22:31,360
0,810 1290,1560 1560,1890 1890,2010 2010,2100
processes| and also we don't
|而且我们也不想在同一个CPU上的一个线程和另一个线程之间进行真正的切换，

2642
01:22:31,360 --> 01:22:33,550
0,180 180,330 330,660 660,1410 1560,2190
want to really switch between

2643
01:22:33,550 --> 01:22:34,540
0,210 210,360 360,450 450,630 630,990
one and the other thread

2644
01:22:34,540 --> 01:22:36,340
0,150 150,240 240,570 570,1230 1590,1800
on the same CPU or

2645
01:22:36,340 --> 01:22:38,220
0,540 570,690 690,840 840,1200
{do,we},| I don't know.|
|我不知道。|

2646
01:22:38,640 --> 01:22:41,180
0,600 660,1020 1020,1020
Wait, can I.|
等等，我能不能。|

2647
01:22:41,300 --> 01:22:42,650
0,750 780,1080 1080,1200 1200,1290 1290,1350
I'm not sure what the
我不确定问题是什么。

2648
01:22:42,650 --> 01:22:44,600
0,360 360,630 1230,1470 1470,1680 1680,1950
question is.| Yeah I guess
|是的，我想我想，你能解释一下这是怎么发生的吗？

2649
01:22:44,600 --> 01:22:45,410
0,120 120,330 330,510 510,600 600,810
I guess, can you just

2650
01:22:45,410 --> 01:22:47,030
0,540 540,870 870,1170 1170,1440 1440,1620
explain more like how does

2651
01:22:47,030 --> 01:22:49,100
0,240 240,750 1350,1830 1830,1980 1980,2070
that happen.| Sorry, how does
|抱歉，发生的事是怎么回事。

2652
01:22:49,100 --> 01:22:52,010
0,180 180,510 1170,1950 2340,2820 2820,2910
what happened.| {} Let's say
|假设每个进程有多个线程，

2653
01:22:52,010 --> 01:22:53,180
0,120 120,300 300,690 690,1020 1020,1170
we have multiple threads per

2654
01:22:53,180 --> 01:22:54,500
0,570 570,810 810,1020 1020,1140 1140,1320
process,| so that they can
|这样它们就可以在不同的CPU上运行，

2655
01:22:54,500 --> 01:22:55,430
0,150 150,270 270,390 390,660 660,930
and they can run on

2656
01:22:55,430 --> 01:22:57,170
0,390 390,840 840,1110 1230,1590 1590,1740
different {CPUs -},| like how
|比如我们怎么去，你怎么去那里。

2657
01:22:57,170 --> 01:22:58,220
0,510 510,630 630,780 780,960 960,1050
do we go, how do

2658
01:22:58,220 --> 01:22:59,990
0,60 60,150 150,420 420,660 1260,1770
you go about there.| {So,Linux},
|例如，Linux支持每个进程多个线程

2659
01:22:59,990 --> 01:23:02,150
0,120 120,540 540,1320 1320,1710 1740,2160
for example supports {} multiple

2660
01:23:02,150 --> 01:23:04,640
0,780 810,990 990,1500 1500,1830 2130,2490
threads per process| and in
|在Linux中，实现

2661
01:23:04,640 --> 01:23:06,900
0,360 360,480 480,1470
Linux, the implementation,|
|

2662
01:23:06,960 --> 01:23:09,000
0,420 420,870 870,930 930,1380 1380,2040
yeah it's a complex implementation,|
是的，这是一个复杂的实现，|

2663
01:23:09,000 --> 01:23:10,380
0,180 180,420 420,750 840,1290 1290,1380
but maybe the simplest way
但也许最简单的解释是，

2664
01:23:10,380 --> 01:23:11,430
0,60 60,450 450,600 600,750 750,1050
to explain it is that,|
|

2665
01:23:11,910 --> 01:23:13,880
0,600 840,1470
{} each,
每一个，几乎就像Linux中的每个线程都是一个完整的进程，

2666
01:23:13,880 --> 01:23:14,930
0,270 270,480 480,780 780,900 900,1050
{} it's almost as if

2667
01:23:14,930 --> 01:23:16,760
0,360 360,810 810,930 930,1620 1650,1830
each thread in Linux is

2668
01:23:16,760 --> 01:23:18,780
0,90 90,480 480,1470
a complete process,|
|

2669
01:23:19,200 --> 01:23:21,480
0,480 660,1200 1500,1680 1680,2190 2190,2280
and the the threads of
以及给定进程的线程，我们称之为特定进程的线程

2670
01:23:21,480 --> 01:23:22,920
0,120 120,690 900,1170 1170,1320 1320,1440
a given, what we would

2671
01:23:22,920 --> 01:23:23,850
0,210 210,300 300,690 690,780 780,930
call the threads of a

2672
01:23:23,850 --> 01:23:26,550
0,420 420,1200 1230,1740 1740,2280 2280,2700
particular process| are essentially separate
|本质上是共享相同存储器的独立进程，

2673
01:23:26,550 --> 01:23:28,620
0,750 780,1110 1110,1590 1590,1680 1680,2070
processes that share the same

2674
01:23:28,620 --> 01:23:29,760
0,690
memory,|
|

2675
01:23:30,040 --> 01:23:30,880
0,180 180,510 510,600 600,720 720,840
so Linux has sort of
所以Linux在某种程度上将执行线程的概念从地址空间中分离出来

2676
01:23:30,910 --> 01:23:32,740
0,630 630,780 780,870 870,1350 1350,1830
separated out the notion of

2677
01:23:32,920 --> 01:23:34,690
0,510 510,780 780,870 870,1590 1590,1770
{} thread of execution from

2678
01:23:34,690 --> 01:23:36,640
0,300 300,840 840,1140 1710,1830 1830,1950
address space| and you know
|你知道你可以把它们分开吃，

2679
01:23:36,640 --> 01:23:37,820
0,300 630,900
you can

2680
01:23:38,180 --> 01:23:39,740
0,240 240,390 390,960 960,1170 1380,1560
have them separately,| and if
|如果您在一个进程中制作两个线程，

2681
01:23:39,740 --> 01:23:40,520
0,90 90,270 270,390 390,720 720,780
you make two threads in

2682
01:23:40,520 --> 01:23:41,810
0,150 150,630 630,720 720,1080 1080,1290
one process,| it basically makes
|它基本上使两个进程共享一个地址空间，

2683
01:23:41,810 --> 01:23:43,370
0,150 150,990 1020,1140 1140,1380 1380,1560
two processes that share one

2684
01:23:43,370 --> 01:23:45,110
0,300 300,990 1320,1440 1440,1590 1590,1740
address space,| and then from
|然后，从那时起，调度与xv6对各个进程所做的没有什么不同。

2685
01:23:45,110 --> 01:23:46,580
0,210 210,600 600,690 690,1200 1200,1470
then on, the scheduling is

2686
01:23:46,610 --> 01:23:49,070
0,480 480,1380 1890,2190 2190,2340 2340,2460
not unlike what {xv6 -

2687
01:23:49,070 --> 01:23:51,320
0,270 270,780 810,990 990,1410 1410,2250
-} does for individual processes.|
|

2688
01:23:51,740 --> 01:23:53,600
0,450 480,660 660,1260 1380,1680 1680,1860
{I,see} and then,| {} is
我明白了，然后，|有没有什么类似的东西，比如用户必须指定，好的，每个线程都要固定到一个CPU上

2689
01:23:53,600 --> 01:23:55,370
0,240 240,930 930,1260 1290,1680 1680,1770
there anything like does the

2690
01:23:55,370 --> 01:23:57,020
0,270 270,480 480,600 600,1200 1200,1650
user have to specify like,

2691
01:23:57,290 --> 01:23:58,730
0,270 270,750 750,1050 1050,1350 1350,1440
okay [pin] each thread to

2692
01:23:58,730 --> 01:24:01,790
0,60 60,780 1080,1800 1800,2790 2820,3060
a CPU| {} or how
|或者操作系统如何确保同一进程的不同线程不在同一内核上运行，

2693
01:24:01,790 --> 01:24:02,990
0,210 210,450 450,810 810,1020 1020,1200
does the OS make sure

2694
01:24:02,990 --> 01:24:03,980
0,210 210,540 540,810 810,900 900,990
that different threads of the

2695
01:24:03,980 --> 01:24:05,000
0,210 210,510 510,720 720,930 930,1020
same process don't run on

2696
01:24:05,000 --> 01:24:05,930
0,60 60,330 330,570 570,780 780,930
the same core,| because that's
|因为我想这是不是有违目的，

2697
01:24:05,930 --> 01:24:07,400
0,180 180,360 450,900 900,990 990,1470
kind of defeating the purpose

2698
01:24:07,430 --> 01:24:08,360
0,180 180,480 480,630 630,900 900,930
or not I guess,| I
|我不知道。

2699
01:24:08,360 --> 01:24:09,160
0,120 120,330
don't know.|

2700
01:24:09,160 --> 01:24:11,050
0,180 180,570 570,810 810,1320 1530,1890
{} The the, {} it's
这个，其实跟xv6很像，就是，

2701
01:24:11,050 --> 01:24:12,400
0,240 240,510 510,960 990,1170 1170,1350
actually just like it's much

2702
01:24:12,400 --> 01:24:14,050
0,150 150,420 420,810 810,1230 1230,1650
like {xv6 -}, namely the,|
|

2703
01:24:14,530 --> 01:24:15,820
0,750

2704
01:24:15,820 --> 01:24:17,200
0,180 180,240 240,510 510,750 750,1380
you know there's four cores
你知道有四个核心，Linux只会为这四个核心中的一个找到四个东西，

2705
01:24:17,200 --> 01:24:18,640
0,330
and

2706
01:24:18,670 --> 01:24:19,840
0,450 450,540 540,690 690,960 960,1170
Linux will just find four

2707
01:24:19,840 --> 01:24:20,650
0,330 330,420 420,540 540,600 600,810
things for one of those

2708
01:24:20,650 --> 01:24:23,410
0,210 210,960 1350,1680 1680,2190 2670,2760
four cores,| they maybe, {}
|他们可能，你知道，如果没有太多的事情发生，那么他们可能会是同一进程的四个线程，

2709
01:24:23,410 --> 01:24:25,270
0,750 750,930 930,1290 1500,1710 1710,1860
you know if there's not

2710
01:24:25,270 --> 01:24:26,140
0,150 150,360 360,540 540,660 660,870
much going on then maybe

2711
01:24:26,140 --> 01:24:27,340
0,120 120,300 300,540 540,1080 1080,1200
they'll be four threads of

2712
01:24:27,340 --> 01:24:29,220
0,90 90,480 480,1440
the same process,|
|

2713
01:24:29,370 --> 01:24:30,660
0,300 300,420 420,810 840,1020 1020,1290
or if there's a hundred
或者如果有一百个用户登录到雅典娜机器，

2714
01:24:30,660 --> 01:24:31,920
0,300 300,600 600,720 720,870 870,1260
users logged in on Athena

2715
01:24:31,920 --> 01:24:34,530
0,510 510,720 720,1170 1290,2070 2070,2610
machine,| maybe it's one thread
|也许它是一个线程，每个线程来自多个不同的进程，你知道。

2716
01:24:34,530 --> 01:24:36,930
0,390 390,840 840,1260 1260,1530 1530,2400
each from multiple different processes,

2717
01:24:36,930 --> 01:24:37,780
0,60 60,300
you know.|
|

2718
01:24:39,060 --> 01:24:40,650
0,360 360,570 570,690 690,870 870,1590
There's not any one answer|
没有一个答案|

2719
01:24:40,710 --> 01:24:42,750
0,540 810,1200 1200,1440 1440,1740 1740,2040
or the kernelod basically find
或者内核程序基本上为每个内核找到要做的事情

2720
01:24:42,750 --> 01:24:43,620
0,300 300,420 420,540 540,750 750,870
something for each core to

2721
01:24:43,620 --> 01:24:44,760
0,270 270,390 390,750 780,960 960,1140
do| and then that core
|然后那个核心做那件事。

2722
01:24:44,760 --> 01:24:46,920
0,180 180,390 390,570 1740,2040 2040,2160
does that thing.| Okay, that
|好的，这就说得通了。

2723
01:24:46,920 --> 01:24:48,120
0,210 210,660
makes sense.|
|

2724
01:24:48,520 --> 01:24:49,810
0,240 240,780 900,1050 1050,1140 1140,1290
You can, you know if
你可以，你知道如果你想仔细测量，

2725
01:24:49,810 --> 01:24:51,340
0,330 960,1200 1200,1320 1320,1470 1470,1530
you're if you want to

2726
01:24:51,340 --> 01:24:52,360
0,90 90,360 360,780 780,930 930,1020
do careful measurements,| there is
|有一种方法可以将线程固定在内核上，

2727
01:24:52,360 --> 01:24:53,380
0,60 60,180 180,300 300,660 660,1020
a way to pin threads

2728
01:24:53,380 --> 01:24:55,030
0,90 90,600 600,840 1170,1410 1410,1650
to cores,| but people only
|但是人们只有在做一些奇怪的事情时才会这么做。

2729
01:24:55,030 --> 01:24:56,320
0,180 180,330 330,480 480,750 1080,1290
do it when they're up

2730
01:24:56,320 --> 01:24:57,940
0,90 90,390 390,1170
to something strange.|
|

2731
01:25:00,540 --> 01:25:02,250
0,360 360,540 540,900 900,1050 1080,1710
So you share the virtual
所以您共享虚拟表，只共享[]内存，

2732
01:25:02,250 --> 01:25:03,480
0,660
table,

2733
01:25:03,930 --> 01:25:05,670
0,300 300,450 450,720 720,1350 1560,1740
just {} [] memory,| so
|所以他们说他们有相同的页表，那些线程。

2734
01:25:05,670 --> 01:25:06,840
0,150 150,390 390,810 810,1110 1110,1170
they say they have the

2735
01:25:06,840 --> 01:25:10,020
0,540 600,930 930,1560 1800,2460 2460,3180
same page table, those threads.|
|

2736
01:25:10,140 --> 01:25:13,200
0,1380 1380,2430 2430,2670 2670,2910 2910,3060
Yeah yeah, if you're on
是的，如果你在Linux上，如果你在一个进程中创建两个线程，

2737
01:25:13,200 --> 01:25:14,340
0,360 360,450 450,570 570,960 960,1140
Linux, if you create two

2738
01:25:14,340 --> 01:25:15,690
0,390 390,450 450,630 630,1170 1170,1350
threads in one process,| then
|然后你就有了这两条线。

2739
01:25:15,690 --> 01:25:16,680
0,90 90,180 180,360 360,510 510,990
you have these two threads.|
|

2740
01:25:19,080 --> 01:25:19,620
0,90 90,210 210,270 270,360 360,540
I don't know if they
我不知道他们是否真的喜欢共享完全相同的页表

2741
01:25:19,620 --> 01:25:22,620
0,180 210,930 930,1890 1950,2100 2100,3000
like literally share the exact

2742
01:25:22,650 --> 01:25:24,210
0,390 390,750 750,1110 1110,1260 1260,1560
same page table| or whether
|或者它们的页表是否相同，一个或另一个。

2743
01:25:24,210 --> 01:25:26,100
0,180 180,420 420,990 1020,1230 1230,1890
their page tables are identical,

2744
01:25:26,520 --> 01:25:27,920
0,390 390,450 450,570 570,810
one or the other.|
|

2745
01:25:28,620 --> 01:25:29,700
0,240 240,420 420,510 510,840 840,1080
Is there a reason why
有没有理由让他们永远分开，

2746
01:25:29,700 --> 01:25:30,510
0,150 150,330 330,570 570,660 660,810
they would have to be

2747
01:25:30,510 --> 01:25:33,240
0,540 780,1350 1710,2190 2400,2580 2580,2730
separate, ever,| {} if you
|如果您手动映射内存，或者。

2748
01:25:33,240 --> 01:25:35,280
0,510 510,810 810,1170 1170,1500
manually map memory, or.|
|

2749
01:25:36,540 --> 01:25:37,680
0,300 300,450 450,720 720,900 900,1140
I I don't know enough
我我知道的还不够多，不知道哪种Linux是这样做的。

2750
01:25:37,680 --> 01:25:40,200
0,120 120,300 300,990 1020,1770 1920,2520
to know whether {} which

2751
01:25:40,200 --> 01:25:42,100
0,360 360,690 690,1440
which Linux does.|
|

2752
01:25:44,320 --> 01:25:45,580
0,300 300,450 450,570 570,810 810,1260
Okay, I have another question
好的，我还有一个关于一个小细节的问题，

2753
01:25:45,580 --> 01:25:47,860
0,480 480,570 570,900 900,1500 1530,2280
about a small detail {},|
|

2754
01:25:48,130 --> 01:25:50,050
0,690 720,1320 1320,1620 1620,1770 1770,1920
so basically like from my
根据我的理解，基本上就是当你打电话给Switch时，

2755
01:25:50,050 --> 01:25:52,030
0,630 630,810 810,930 930,1140 1140,1980
understanding when you call switch,|
|

2756
01:25:52,450 --> 01:25:54,250
0,420 420,780 780,1200 1200,1440 1440,1800
{} you switch from one
你从一个呼叫切换到另一个呼叫，

2757
01:25:54,250 --> 01:25:56,050
0,390 390,840 840,1230 1230,1380 1380,1800
call to switch to another,|
|

2758
01:25:56,080 --> 01:25:56,980
0,240 240,390 390,630 630,810 810,900
so the first time you
所以当你第一次打电话给Switch时，

2759
01:25:56,980 --> 01:25:58,150
0,180 180,660 690,870 870,1080 1080,1170
call switch,| you have to
|您必须类似于人为地创建其他端点才能回到正确的位置。

2760
01:25:58,150 --> 01:26:00,880
0,210 210,780 960,1710 1710,2370 2370,2730
like {kind,of} artificially create {}

2761
01:26:01,000 --> 01:26:02,680
0,300 300,840 840,1080 1110,1380 1380,1680
other endpoint to come back

2762
01:26:02,680 --> 01:26:04,420
0,150 150,630 750,1380
to right.| Yes.|
|是。|

2763
01:26:04,510 --> 01:26:05,650
0,180 180,240 240,450 450,660 660,1140
Because you can't just randomly
因为你不能随便跳进去写任何代码。

2764
01:26:05,650 --> 01:26:06,520
0,240 240,360 360,480 480,690 690,870
jump in to write any

2765
01:26:06,520 --> 01:26:08,640
0,510 780,1560
code.| Yes,
|是的，你想知道那个在哪里，

2766
01:26:09,750 --> 01:26:10,590
0,270 270,390 390,450 450,540 540,840
you want to know where

2767
01:26:10,590 --> 01:26:11,640
0,390
that,|
|

2768
01:26:11,860 --> 01:26:13,920
0,330 330,570 570,1500
where that [fake],
在哪里[假的]，在哪里上下文是被炮制出来的。

2769
01:26:14,930 --> 01:26:16,370
0,240 240,420 420,960 960,1080 1080,1440
where that context was cooked

2770
01:26:16,370 --> 01:26:18,680
0,420 1380,1650 1650,1980 1980,2190 2190,2310
up.| Probably somewhere where the
|可能是在某个过程产生的地方，

2771
01:26:18,680 --> 01:26:21,320
0,810 1350,2010 2010,2160 2160,2610 2610,2640
processes created,| I guess I
|我想我不知道。

2772
01:26:21,320 --> 01:26:23,300
0,240 240,840 840,1260 1260,1620 1620,1980
{don't,know}.| Yeah yeah, maybe user
|是的是的，可能是用户在其中，或者没有使用[a]锁进程。

2773
01:26:23,300 --> 01:26:24,640
0,120 120,870
in that,

2774
01:26:24,820 --> 01:26:26,980
0,480 1020,1290 1290,1560 1560,1800 1800,2160
or not using [a] lock

2775
01:26:26,980 --> 01:26:28,280
0,780
proc.|
|

2776
01:26:31,030 --> 01:26:34,060
0,810 840,1530 1890,2310 2310,2700 2700,3030
Don't know.| There's something called
我也不知道。|有一种叫叉子陷阱的东西。

2777
01:26:34,060 --> 01:26:36,580
0,840 870,1620 1620,2190 2190,2430 2430,2520
fork {trap,or,something}.| Yeah, look at
|是的，看这个，是的，我们有叉子，

2778
01:26:36,580 --> 01:26:38,830
0,330 360,1020 1020,1560 1740,2040 2040,2250
this, yeah we got {forkret

2779
01:26:38,830 --> 01:26:40,180
0,420 420,630 630,780 780,870 870,1350
-},| okay so an alloc
|好的，在引导时为第一个进程调用的alloc进程

2780
01:26:40,180 --> 01:26:41,920
0,450 450,600 600,690 690,1050 1050,1740
proc which is called both

2781
01:26:42,130 --> 01:26:43,600
0,270 270,360 360,780 780,1080 1080,1470
for the very first process

2782
01:26:43,600 --> 01:26:45,100
0,90 90,600 600,990 990,1350 1350,1500
at boot time| and by
并且通过分叉分配过程为新进程设置上下文的关键元素，

2783
01:26:45,100 --> 01:26:48,160
0,690 900,1440 1680,2310 2310,2610 2610,3060
fork {} alloc proc sets

2784
01:26:48,160 --> 01:26:49,690
0,330 330,450 450,960 960,1470 1470,1530
up the critical elements of

2785
01:26:49,690 --> 01:26:51,400
0,90 90,930 990,1290 1290,1410 1410,1710
the context for the new

2786
01:26:51,400 --> 01:26:53,040
0,1320
processes,|
|

2787
01:26:53,770 --> 01:26:55,090
0,210 210,360 810,1020 1020,1230 1230,1320
{} it, it sets up
它，它设置了新进程的上下文，

2788
01:26:55,090 --> 01:26:56,530
0,60 60,150 150,630 630,1230 1290,1440
the new process's context,| it
|实际上，大多数寄存器是什么并不重要，

2789
01:26:56,530 --> 01:26:57,400
0,180 180,360 360,540 540,690 690,870
actually doesn't matter what most

2790
01:26:57,400 --> 01:26:59,230
0,60 60,150 150,630 630,960 1410,1830
of the registers are {},|
|

2791
01:26:59,260 --> 01:26:59,950
0,150 150,210 210,390 390,540 540,690
but it does matter what
但重要的是拉是什么，

2792
01:26:59,950 --> 01:27:01,240
0,270 270,450 450,870 870,1140 1140,1290
{ra -} is,| because that's
|因为这就是开关，第一个开关，这个过程会返回到ra。

2793
01:27:01,240 --> 01:27:02,800
0,240 330,450 450,960 960,1110 1110,1560
where the switch the very

2794
01:27:02,800 --> 01:27:04,180
0,360 360,750 750,840 840,960 960,1380
first switch and that process

2795
01:27:04,180 --> 01:27:04,930
0,180 180,330 330,420 420,690 690,750
is going to return to

2796
01:27:04,930 --> 01:27:07,240
0,150 150,780
{ra -}.|
|

2797
01:27:07,450 --> 01:27:08,650
0,270 270,450 450,870 870,1050 1050,1200
And that process is going
这个过程需要使用它自己的堆栈，

2798
01:27:08,650 --> 01:27:09,370
0,90 90,330 330,420 420,600 600,720
to need to use its

2799
01:27:09,370 --> 01:27:11,080
0,150 150,750 780,960 960,1560 1560,1710
own stack,| so {ra,and} sp
|所以RA和SP设置基本上是伪造的，

2800
01:27:11,080 --> 01:27:12,420
0,90 90,780
{} setup,

2801
01:27:12,510 --> 01:27:15,060
0,120 120,840 900,1590 1860,2340 2340,2550
{} faked essentially,| so the
|因此，第一个切换或进程是有效的。

2802
01:27:15,060 --> 01:27:16,800
0,300 300,660 660,1200 1200,1320 1320,1740
very first switched or process

2803
01:27:16,800 --> 01:27:17,980
0,630
works.|
|

2804
01:27:18,130 --> 01:27:19,720
0,450 450,780 780,960 960,1080 1080,1590
So, so if I understand
所以，如果我理解正确的话，

2805
01:27:19,720 --> 01:27:21,040
0,120 120,690 690,900 900,1020 1020,1320
this correctly,| when this switch
|当这种切换发生时，它基本上只会开始执行分叉内部的第一条指令，

2806
01:27:21,040 --> 01:27:23,320
0,180 180,630 630,1110 1410,1740 1740,2280
will happen then it'll basically

2807
01:27:23,320 --> 01:27:25,390
0,450 480,870 870,1380 1380,1560 1560,2070
just start executing the first

2808
01:27:25,390 --> 01:27:27,070
0,540 540,870 870,990 990,1200 1200,1680
instruction inside of the {forkret

2809
01:27:27,070 --> 01:27:28,690
0,420 480,780 780,990 990,1200 1200,1620
-},| as if {forkret -}
|好像叉子刚叫了开关，又回来了。

2810
01:27:28,690 --> 01:27:30,190
0,330 330,690 690,1020 1020,1110 1110,1500
just called switch and return

2811
01:27:30,190 --> 01:27:33,130
0,270 720,1530 1530,2190 2190,2310 2310,2940
from.| Yeah yeah, the return
|是啊，是啊，从Switch回来就是跳到Forkret的开头。

2812
01:27:33,130 --> 01:27:34,600
0,180 180,720 720,1080 1140,1350 1350,1470
from switch is gonna be

2813
01:27:34,600 --> 01:27:35,680
0,120 120,540 540,660 660,750 750,1080
a jump to the beginning

2814
01:27:35,680 --> 01:27:36,880
0,90 90,330 330,690
of {forkret -}.|
|

2815
01:27:37,330 --> 01:27:38,560
0,630
Right,
对，有意思，

2816
01:27:39,020 --> 01:27:40,340
0,780
interesting,|
|

2817
01:27:40,370 --> 01:27:41,870
0,180 180,300 300,600 600,1260 1260,1500
do we ever call {forkret
我们有没有叫过福克雷特，还是总是这样，

2818
01:27:41,870 --> 01:27:43,490
0,480 720,960 960,1110 1110,1260 1260,1620
-} or is it always

2819
01:27:43,490 --> 01:27:44,780
0,390 570,600 690,930 930,1050 1050,1290
happens,| I think it always
|我想事情总是这样发生的。

2820
01:27:44,780 --> 01:27:46,220
0,360 360,540 540,870 1080,1170 1170,1440
happens like this.| I don't
|我不认为有什么东西是真的叫叉子，

2821
01:27:46,220 --> 01:27:47,810
0,210 210,630 630,900 900,1350 1350,1590
think anything ever calls {forkret

2822
01:27:47,810 --> 01:27:49,820
0,270 270,450 450,900 1050,1530
-} for real,| because
|因为，是的，它只有在第一个计时器进程运行时才以这种奇怪的方式执行。

2823
01:27:50,160 --> 01:27:52,800
0,1440 1500,1800 1800,1920 1920,2130 2130,2640
just, yeah it's only executed

2824
01:27:52,800 --> 01:27:54,180
0,60 60,240 240,510 510,840 840,1380
in this weird way from

2825
01:27:55,950 --> 01:27:57,300
0,240 240,420 420,810 810,930 930,1350
first timer process is run.|
|

2826
01:27:58,510 --> 01:27:59,800
0,240 240,330 330,600 600,810 810,1290
It is really its job
它的工作实际上是释放调度程序占用的锁

2827
01:27:59,800 --> 01:28:01,960
0,210 210,540 900,1320 1320,1470 1470,2160
is to release the lock

2828
01:28:02,860 --> 01:28:04,870
0,360 360,840 840,1320 1470,1770 1770,2010
the scheduler took| and then
|然后返回，然后这个usertrapret，当然，也是假的。

2829
01:28:04,870 --> 01:28:06,520
0,630 660,780 780,1050 1080,1320 1320,1650
return and then this {usertrapret

2830
01:28:06,520 --> 01:28:07,600
0,390 390,570 570,630 630,960 960,1080
- -}, of course, is

2831
01:28:07,600 --> 01:28:09,440
0,390 390,1290
also fake.|
|

2832
01:28:09,500 --> 01:28:11,000
0,300 300,780
That it's,
它是，它是的它就像是从陷阱里回来的，只是陷阱框是假的，

2833
01:28:11,340 --> 01:28:13,020
0,270 270,780 780,900 900,1290 1380,1680
it's yeah it's like it's

2834
01:28:13,020 --> 01:28:14,190
0,300 300,540 540,960 960,1110 1110,1170
as if returning from a

2835
01:28:14,190 --> 01:28:15,780
0,420 420,840 840,900 900,1290 1290,1590
trap except the {trapframe -}

2836
01:28:15,780 --> 01:28:18,390
0,390 420,1020 1020,1560 1980,2250 2400,2610
is faked,| also to to
|还可以像跳转到用户(右)代码中的第一条指令。

2837
01:28:18,390 --> 01:28:19,740
0,270 300,870 870,1140 1140,1230 1230,1350
have like jump to the

2838
01:28:19,740 --> 01:28:21,660
0,330 330,930 930,1110 1110,1230
first instruction in the

2839
01:28:21,660 --> 01:28:24,000
0,630 750,1230 1320,1830
user (Right) code.|
|

2840
01:28:24,760 --> 01:28:26,080
0,300 300,450 450,570 570,900 900,1320
Oh, but the {trapframe -},
哦，但是陷阱帧，它又是一样的，就像你不需要初始化任何寄存器一样，

2841
01:28:26,110 --> 01:28:27,430
0,390 390,690 690,780 780,1110 1110,1320
it's again the same like

2842
01:28:27,430 --> 01:28:28,360
0,90 90,180 180,330 330,450 450,930
you don't need to initialize

2843
01:28:28,360 --> 01:28:29,710
0,180 180,750 750,960 960,1140 1140,1350
any registers,| because it's like
|因为这就像是我们要从头开始，

2844
01:28:29,710 --> 01:28:31,180
0,360 390,720 720,1050 1050,1170 1170,1470
well we're going to the

2845
01:28:31,210 --> 01:28:33,100
0,720 720,990 1020,1440 1440,1710 1710,1890
beginning,| so you don't need
|所以你不需要假设任何事。

2846
01:28:33,100 --> 01:28:34,690
0,60 60,420 420,870 1230,1500 1500,1590
to assume anything.| Yeah, the
|是的，我想那个节目柜台是。

2847
01:28:34,690 --> 01:28:36,220
0,450 450,870 870,990 990,1260 1260,1530
program counter I think is

2848
01:28:36,220 --> 01:28:37,340
0,480
a.|
|

2849
01:28:37,400 --> 01:28:38,570
0,270 270,480 720,1050 1050,1110 1110,1170
Yeah.| It needs to be
嗯。|需要将其初始化为零，

2850
01:28:38,570 --> 01:28:40,550
0,450 450,540 540,1350 1770,1830 1830,1980
initialized to zero,| I don't
|我不知道还有什么

2851
01:28:40,550 --> 01:28:42,020
0,120 120,330 330,960
know what else,|
|

2852
01:28:42,320 --> 01:28:43,700
0,150 150,360 360,660 660,960 960,1380
you {maybe -} maybe it.|
你也许是吧。|

2853
01:28:46,440 --> 01:28:47,760
0,210 210,480 480,630 630,870 900,1320
They probably if we call
他们可能如果我们叫他们是不对的，

2854
01:28:47,760 --> 01:28:49,200
0,210 210,420 420,750 750,1110 1230,1440
them it doesn't right,| because
|因为如果我们已经进行了调用，那么就会设置程序计数器。

2855
01:28:49,200 --> 01:28:50,100
0,180 180,270 270,480 480,630 630,900
if we already do the

2856
01:28:50,250 --> 01:28:51,360
0,480 480,660 660,930 930,1050 1050,1110
call then that's going to

2857
01:28:51,360 --> 01:28:53,160
0,300 300,390 390,780 780,1230 1410,1800
set the program counter.| Yeah,
|是的，之所以会发生这种情况，是因为分叉复制分叉副本、程序计数器、用户程序计数器

2858
01:28:53,160 --> 01:28:54,840
0,180 180,570 570,1080 1080,1320 1320,1680
so here's this only happens

2859
01:28:54,840 --> 01:28:57,390
0,330 330,900 900,1650 1650,1950 1950,2550
because fork copies fork copies,

2860
01:28:57,390 --> 01:28:58,840
0,90 90,420 420,900
the program counter,

2861
01:28:58,840 --> 01:29:00,790
0,150 150,450 450,780 780,1320 1740,1950
the user program counter| and
|所以我们唯一不做叉子的时候，

2862
01:29:00,790 --> 01:29:01,720
0,120 120,270 270,480 480,810 810,930
so the only time when

2863
01:29:01,720 --> 01:29:02,470
0,90 90,210 210,360 360,450 450,750
we're not doing it fork,|
|

2864
01:29:02,470 --> 01:29:03,280
0,120 120,240 240,330 330,570 570,810
is for the very first
是为了第一个过程

2865
01:29:03,280 --> 01:29:05,350
0,390 390,810 960,1410 1410,1560 1560,2070
process| where it's like explicitly
|在那里它就像是明显的欺骗性的。

2866
01:29:05,350 --> 01:29:07,060
0,480 480,1140
deceptive.| Oh.|
|噢。|

2867
01:29:07,310 --> 01:29:08,480
0,150 150,420 420,720 720,870 870,1170
And stack pointer.| Oh yeah.|
和堆栈指针。|哦，是的。|

2868
01:29:08,510 --> 01:29:09,290
0,240 240,390 390,480 480,570 570,780
Also needs to be set
也需要设置。

2869
01:29:09,290 --> 01:29:10,040
0,270
up.|
|

2870
01:29:11,130 --> 01:29:12,540
0,420 420,660 660,870 870,1110 1110,1410
Oh yeah, because it's that
哦，是的，因为那个EPC不是PC，

2871
01:29:12,540 --> 01:29:14,370
0,630 630,900 900,1110 1110,1560 1560,1830
EPC that's not PC,| that's
|那就是那个要被陷阱蹦床换掉的。

2872
01:29:14,370 --> 01:29:15,240
0,90 90,300 300,480 480,690 690,870
the one that's gonna get

2873
01:29:15,240 --> 01:29:17,370
0,480 480,600 600,840 840,1410 1410,2130
swapped by the trap trampoline.|
|

2874
01:29:17,610 --> 01:29:18,800
0,720
Yes.|
是。|

2875
01:29:19,660 --> 01:29:21,160
0,420 420,540 540,960
Oh, I see.|
哦，我明白了。|

2876
01:29:21,820 --> 01:29:22,870
0,240 240,360 360,630 630,930 930,1050
Because the real piece is
因为真正的作品实际上会像在内部旅行一样落入圈套，

2877
01:29:22,870 --> 01:29:24,250
0,300 300,510 510,690 690,900 900,1380
actually gonna be in trap

2878
01:29:24,280 --> 01:29:26,470
0,270 270,630 630,1260 1740,2010 2010,2190
like inside traveling,| but then
|但是我们要把它换成跳到那里。

2879
01:29:26,470 --> 01:29:27,370
0,120 120,300 300,600 600,780 780,900
we're gonna switch it to

2880
01:29:27,370 --> 01:29:28,720
0,330 330,450 450,810
jump to there.|
|

2881
01:29:29,220 --> 01:29:31,220
0,1260
Yeah.|
嗯。|

2882
01:29:32,870 --> 01:29:33,950
0,330 330,510 510,570 570,780 780,1080
{} Can I just ask
我能不能问一下你能不能回到分配程序。

2883
01:29:33,950 --> 01:29:34,940
0,330 330,480 480,570 570,690 690,990
like can you go back

2884
01:29:34,940 --> 01:29:37,140
0,120 120,630 690,1080 1080,1650
to the alloc proc.|
|

2885
01:29:42,940 --> 01:29:45,370
0,780 1020,1380 1380,1590 1590,1920 1920,2430
{} I think there's {},|
我觉得有，|

2886
01:29:45,960 --> 01:29:47,310
0,180 180,390 390,870 900,1110 1110,1350
oh no sorry, {} {forkret
哦，不，对不起，叉子那里有点东西，我想那只是第一道工序的事。

2887
01:29:47,310 --> 01:29:49,590
0,420 690,1080 1080,1230 1230,1860 1950,2280
-} there is something there,

2888
01:29:49,590 --> 01:29:50,730
0,150 150,630 630,750 750,1020 1020,1140
that happens I think for

2889
01:29:50,730 --> 01:29:53,960
0,120 120,750 1020,1710 1710,2190
the first process only.|
|

2890
01:29:53,960 --> 01:29:55,700
0,330 330,660 660,1200 1260,1590 1590,1740
{} What's this for a
第一个电话是怎么回事，我不太确定发生了什么事。

2891
01:29:55,700 --> 01:29:57,890
0,690 690,1230 1560,1710 1710,1980 1980,2190
first call, I wasn't really

2892
01:29:57,890 --> 01:29:59,390
0,180 180,390 390,1080 1200,1380 1380,1500
sure what happened.| Let's see,
|我们看看，文件系统，文件系统需要初始化

2893
01:29:59,390 --> 01:30:01,940
0,90 90,420 420,1050 2160,2310 2310,2550
the file system, the file

2894
01:30:01,940 --> 01:30:03,620
0,450 450,840 840,900 900,990 990,1680
system needs to be initialized|
|

2895
01:30:03,620 --> 01:30:05,180
0,180 180,330 330,930 930,1110 1110,1560
and in particular some stuff
特别是一些内容需要从磁盘上读取

2896
01:30:05,180 --> 01:30:06,230
0,240 240,330 330,480 480,780 780,1050
needs to be read off

2897
01:30:06,230 --> 01:30:07,610
0,120 120,840 960,1110 1110,1320 1320,1380
the disk| in order to
|为了使文件系统运行，

2898
01:30:07,610 --> 01:30:08,960
0,120 120,240 240,480 480,840 840,1350
get the file system going,|
|

2899
01:30:09,520 --> 01:30:12,010
0,600 990,1770 1950,2220 2220,2370 2370,2490
{} like there's this thing
比如有一种叫做超级挡路的东西，用来描述文件系统有多大，

2900
01:30:12,010 --> 01:30:13,180
0,150 150,210 210,570 570,930 930,1170
called the super block which

2901
01:30:13,180 --> 01:30:14,620
0,660 660,930 930,1080 1080,1200 1200,1440
describes how big the file

2902
01:30:14,620 --> 01:30:15,910
0,360 360,660 660,990 990,1200 1200,1290
system are,| and where the
|以及文件系统中各种内容的位置

2903
01:30:15,910 --> 01:30:16,870
0,360 360,660 660,780 780,870 870,960
various things are in the

2904
01:30:16,870 --> 01:30:18,190
0,240 240,690 750,870 870,1020 1020,1320
file system| and there's also
|还有一个需要重播的崩溃恢复日志

2905
01:30:18,190 --> 01:30:20,050
0,270 390,900 900,1290 1290,1710 1710,1860
a crash recovery log that

2906
01:30:20,050 --> 01:30:21,320
0,240 240,360 360,750
needs to be

2907
01:30:21,320 --> 01:30:24,560
0,810 930,1110 1110,1350 1350,1590 2760,3240
replayed| in order to recover
|以便从之前的坠机中恢复过来，如果有的话。

2908
01:30:24,560 --> 01:30:26,090
0,150 150,570 570,960 960,1440 1440,1530
from a previous crash, if

2909
01:30:26,090 --> 01:30:29,210
0,90 90,300 300,510 1680,2490 2970,3120
there was one.| But in
|但是为了在文件系统中执行任何操作，

2910
01:30:29,210 --> 01:30:30,380
0,270 270,600 630,870 870,1110 1110,1170
order to do anything in

2911
01:30:30,380 --> 01:30:31,310
0,60 60,330 330,660 660,780 780,930
the file system,| you need
|您需要能够等待磁盘操作完成，

2912
01:30:31,310 --> 01:30:32,300
0,60 60,150 150,300 300,450 450,990
to be able to wait

2913
01:30:32,330 --> 01:30:35,060
0,750 780,1410 1440,2040 2040,2160 2160,2730
for disk operations to complete,|
|

2914
01:30:35,060 --> 01:30:35,990
0,240 240,330 330,570 570,780 780,930
but the way {xv6 -
但是xv6的工作方式，

2915
01:30:35,990 --> 01:30:37,760
0,210 210,780 1020,1350 1350,1620 1620,1770
-} works,| you really can
|您实际上只能在进程的上下文中执行文件系统代码，

2916
01:30:37,760 --> 01:30:39,170
0,450 450,780 780,870 870,1110 1110,1410
only execute the file system

2917
01:30:39,170 --> 01:30:40,400
0,330 360,510 510,570 570,1140 1140,1230
code in the context of

2918
01:30:40,400 --> 01:30:41,740
0,90 90,1020
{} process,|
|

2919
01:30:42,110 --> 01:30:43,970
0,720 930,1110 1110,1350 1350,1590 1620,1860
{} in order to like
为了像等待IO一样

2920
01:30:43,970 --> 01:30:45,770
0,180 180,330 330,960 1350,1650 1650,1800
wait for IO| and so
|因此必须推迟文件系统的初始化

2921
01:30:45,770 --> 01:30:47,750
0,480 480,810 1020,1830 1830,1890 1890,1980
therefore the initialization of the

2922
01:30:47,750 --> 01:30:48,650
0,240 240,540 540,690 690,780 780,900
file system has to be

2923
01:30:48,650 --> 01:30:50,450
0,690 690,1170 1170,1320 1320,1650 1650,1800
deferred| until the first time
|直到我们第一次有一个进程在运行。

2924
01:30:50,450 --> 01:30:51,650
0,120 120,240 240,300 300,750 750,1200
we have a process running.|
|

2925
01:30:53,140 --> 01:30:55,060
0,420 930,1140 1140,1590 1590,1710 1710,1920
And that occurs in the
这发生在福克雷特的第一个过程中。

2926
01:30:55,060 --> 01:30:56,530
0,300 300,570 570,1050 1050,1200 1200,1470
very first process in {forkret

2927
01:30:56,530 --> 01:30:57,740
0,270
-}.|
|

2928
01:31:00,350 --> 01:31:01,640
0,270 270,720
I see.|
我明白了。|

2929
01:31:01,640 --> 01:31:02,600
0,180 180,240 240,570 570,750 750,960
And I'm guessing we'll learn
我猜我们稍后会对此有更多了解。

2930
01:31:02,600 --> 01:31:05,140
0,150 150,420 420,840 1320,1950
more about this later.|
|

2931
01:31:05,320 --> 01:31:06,970
0,600 720,990 990,1170 1170,1290 1290,1650
Yeah, not about this horrible
是的，不是关于这个可怕的烂摊子，而是关于文件系统是如何工作的。

2932
01:31:06,970 --> 01:31:09,100
0,480 480,1260 1260,1530 1530,1770 1770,2130
mess, {but,about} how file systems

2933
01:31:09,100 --> 01:31:12,880
0,1290 1950,2460 2850,3330 3360,3540 3540,3780
work.| {All,right} okay well, thank
|好的，好的，谢谢你，

2934
01:31:12,880 --> 01:31:13,870
0,150 150,330 330,540 540,660 660,990
you,| I'm sorry for holding
|很抱歉让您久等了。

2935
01:31:13,870 --> 01:31:16,180
0,570 600,780 780,1230
on so long.|
|

2936
01:31:16,920 --> 01:31:18,900
0,660 660,1080 1080,1260 1260,1410 1410,1980
Thanks for all the answers.|
谢谢你所有的回答。|

2937
01:31:21,840 --> 01:31:23,370
0,420 420,540 540,870 870,1320 1320,1530
Sorry, it's not even that
抱歉，甚至不是那个过程，当这个东西被执行的时候.

2938
01:31:23,370 --> 01:31:25,530
0,540 540,870 870,1350 1350,1890 1950,2160
process, when this thing is

2939
01:31:25,530 --> 01:31:26,503
0,870
{executed,...}.

