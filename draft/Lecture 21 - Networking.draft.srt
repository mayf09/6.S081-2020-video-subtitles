1
00:00:06,110 --> 00:00:08,840
0,810 870,1590 1590,2130 2130,2430 2430,2730
Alright, hello everyone, welcome back
好的，大家好，欢迎从感恩节回来。

2
00:00:08,840 --> 00:00:10,180
0,300 300,810
from {}

3
00:00:10,780 --> 00:00:12,260
0,930
Thanksgiving.|
|

4
00:00:12,590 --> 00:00:15,020
0,570 600,990 990,1200 1200,1560
Can anyone hear me?|
有人能听到我说话吗？|

5
00:00:15,390 --> 00:00:17,850
0,810 1140,1560 1890,2220 2220,2400 2400,2460
{Yep,good}.| Good, alright, today I
是的。|好的，今天我想谈谈网络，

6
00:00:17,850 --> 00:00:20,100
0,150 150,210 210,450 450,960 990,2250
want to talk about networking|
|

7
00:00:20,370 --> 00:00:21,270
0,210 210,390 390,480 480,780 780,900
and how it relates to
以及它与操作系统的关系。

8
00:00:21,270 --> 00:00:23,300
0,360 360,1110
operating systems.|
|

9
00:00:23,840 --> 00:00:24,890
0,360 360,600 600,780 780,840 840,1050
And a lot of this
这节课大部分是为最后一个实验的准备，

10
00:00:24,890 --> 00:00:27,500
0,630 660,1110 1410,2070
is a {

11
00:00:27,780 --> 00:00:31,020
0,330 330,780 780,1950 1980,2790 2820,3240
-} geared towards lab, last

12
00:00:31,020 --> 00:00:33,210
0,750 780,1020 1020,1200 1200,1740 1800,2190
lab,| which you actually build
|你可以构建一个网络接口驱动程序，

13
00:00:33,210 --> 00:00:34,680
0,360 420,930
some {}

14
00:00:35,320 --> 00:00:37,780
0,300 330,660 660,1020 1020,1500 1860,2460
{} network interface driver, {}|
|

15
00:00:37,810 --> 00:00:39,260
0,330 330,420 420,930
some of this
其中一些考虑的是

16
00:00:39,380 --> 00:00:40,790
0,330 330,480 480,840 840,1350 1350,1410
care for general understanding of|
|

17
00:00:40,790 --> 00:00:43,040
0,330 330,450 450,810 810,1650
how the network software
网络软件如何在操作系统中设置，

18
00:00:43,550 --> 00:00:45,230
0,630 630,690 690,1170 1170,1290 1290,1680
typically {} setup in operating

19
00:00:45,230 --> 00:00:47,450
0,690 990,1440 1590,1980 1980,2100 2100,2220
systems| and then we're going
|然后我们将讨论今天的关于活锁的论文，

20
00:00:47,450 --> 00:00:48,740
0,240 300,420 420,690 690,930 960,1290
to talk about the today's

21
00:00:48,740 --> 00:00:50,060
0,300 300,420 420,660 660,990 1020,1320
paper on live lock| which
|它描述了一个在网络堆栈设计中的有趣的危险。

22
00:00:50,090 --> 00:00:53,620
0,570 570,780 1110,1620 1620,2190
illustrates a interesting danger

23
00:00:54,340 --> 00:00:56,460
0,210 210,600 600,960 960,1650
in network stack design.|
|

24
00:00:56,460 --> 00:00:58,260
0,330 330,660 690,930 930,1290 1350,1800
So, first let me set
所以，首先让我画几张关于网络的图，

25
00:00:58,260 --> 00:01:00,570
0,90 90,390 390,930 960,1830 1830,2310
the general {} scene by

26
00:01:00,780 --> 00:01:03,210
0,1110 1110,1170 1170,1350 1350,1710 1710,2430
drawing a few network pictures,|
|

27
00:01:05,060 --> 00:01:06,470
0,360 360,420 420,690 690,1110 1110,1410
network of course connects different
网络可以连接不同的主机，

28
00:01:06,470 --> 00:01:10,520
0,690 1260,1710 2010,2670 2700,3450
hosts,| at {} there's
|可以通过两种方式查看连接是否正在发生。

29
00:01:10,520 --> 00:01:13,540
0,330 390,780 780,1680 1710,2280
{kind,of} two ways {}

30
00:01:13,630 --> 00:01:14,410
0,150 150,360 360,450 450,570 570,780
in which you can view

31
00:01:14,410 --> 00:01:16,690
0,90 90,570 570,720 720,1230 1260,2280
the connections is occurring.| One
|第一，对于附近的主机，

32
00:01:16,690 --> 00:01:18,730
0,90 90,240 240,1020 1080,1470 1500,2040
is that in for nearby

33
00:01:18,730 --> 00:01:20,290
0,450 450,570 570,690 690,990 990,1560
hosts,| they are often connected
|它们通常连接到相同的网络。

34
00:01:20,290 --> 00:01:22,210
0,210 210,450 450,630 1110,1320 1320,1920
to what you what's essentially

35
00:01:22,240 --> 00:01:24,640
0,390 450,930 930,1500 1530,2040 2130,2400
a same network.| So there
|可能是一个以太网，

36
00:01:24,640 --> 00:01:25,930
0,90 90,210 210,270 270,630 660,1290
may be a single Ethernet,|
|

37
00:01:27,030 --> 00:01:28,020
0,420 420,570 570,780 780,930 930,990
{} and maybe this is
或者一个交换机或电缆，

38
00:01:28,020 --> 00:01:29,160
0,90 90,510 510,600 600,630 630,1140
a switch or a cable|
|

39
00:01:29,340 --> 00:01:30,030
0,210 210,300 300,450 450,570 570,690
and you might have a
可能有一堆主机连接到这个以太网，

40
00:01:30,030 --> 00:01:31,650
0,270 270,360 360,900 930,1560 1560,1620
bunch of hosts connected to

41
00:01:31,650 --> 00:01:34,400
0,390 420,690 720,1410
this, this Ethernet,|
|

42
00:01:34,400 --> 00:01:37,550
0,180 180,630 630,1080 1110,1770 1920,3150
where hosts are maybe laptops
主机可能是笔记本或服务器，

43
00:01:37,550 --> 00:01:40,250
0,270 270,1350 2130,2460 2460,2610 2610,2700
or servers| or as it
|或者是路由器，

44
00:01:40,250 --> 00:01:41,840
0,120 120,360 360,510 510,1140 1170,1590
will {run -} routers, {}|
|

45
00:01:42,470 --> 00:01:44,940
0,360 600,1080 1080,1890
and { -}
网络软件的设计方式是，

46
00:01:45,430 --> 00:01:48,340
0,660 840,1320 1320,1680 1680,2040 2040,2910
the way network software designed

47
00:01:48,430 --> 00:01:50,260
0,570 600,1260 1260,1470 1470,1560 1560,1830
is| to kind of try
|为了尽可能地忽略

48
00:01:50,260 --> 00:01:51,940
0,120 120,960 1170,1350 1350,1560 1560,1680
to ignore as much as

49
00:01:51,940 --> 00:01:53,470
0,420 420,540 540,990 990,1050 1050,1530
possible| the details of exactly
|网络连接主机的具体细节，

50
00:01:53,470 --> 00:01:54,580
0,180 180,360 360,720 720,990 990,1110
what this network is that

51
00:01:54,580 --> 00:01:56,410
0,420 420,780 810,1380 1380,1620 1620,1830
directly {} attaches hosts,| might
|可能是一根电缆，

52
00:01:56,410 --> 00:01:58,060
0,90 90,150 150,420 420,1020 1260,1650
be a single cable, {}|
|

53
00:01:58,060 --> 00:01:59,860
0,450 450,570 570,990 990,1080 1080,1800
which is probably the case
可能在今天的论文发表的时候就是这样的，

54
00:02:00,100 --> 00:02:02,260
0,720 1110,1260 1260,1350 1350,1770 1770,2160
{} at the time today's

55
00:02:02,260 --> 00:02:03,670
0,330 330,510 510,840 1020,1260 1260,1410
paper was written,| this might
|这也可能是以太网交换机，

56
00:02:03,670 --> 00:02:05,290
0,120 120,240 240,570 570,1230 1350,1620
be an Ethernet switch,| this
|或者可能是 WiFi 无线局域网，

57
00:02:05,290 --> 00:02:06,070
0,210 210,330 330,510 510,690 690,780
might be some sort of

58
00:02:06,070 --> 00:02:08,440
0,900 900,1530 1530,1920 1920,2010 2010,2370
WiFi wireless Lan,| and these
|这些甚至根本不是线，而是无线链路。

59
00:02:09,100 --> 00:02:10,240
0,300 300,510 510,690 690,1050 1050,1140
these things aren't wires at

60
00:02:10,240 --> 00:02:11,920
0,240 240,390 390,690 690,1020 1020,1680
all, but rather radio links.|
|

61
00:02:12,010 --> 00:02:13,760
0,420 480,1080
{} but,
但是，在很大程度上，

62
00:02:13,790 --> 00:02:15,050
0,270 270,330 330,600 600,840 840,1260
for the most part| these
|这些本地连接的差异是，

63
00:02:15,140 --> 00:02:17,150
0,540 570,900 900,1470 1470,1770 1800,2010
{} these differences in sort

64
00:02:17,150 --> 00:02:18,200
0,60 60,570 570,690 690,810 810,1050
of exactly what the local

65
00:02:18,200 --> 00:02:19,880
0,630 630,1020 1050,1410 1410,1590 1590,1680
connectivity is| a kind of
|在网络堆栈中，一种在很低的级别。

66
00:02:20,000 --> 00:02:21,800
0,390 390,810 810,1110 1110,1320 1500,1800
totally papered over at pretty

67
00:02:21,800 --> 00:02:23,570
0,240 240,720 1140,1530 1560,1680 1680,1770
low level, {} in the

68
00:02:23,570 --> 00:02:24,860
0,390 390,900
networking stack.|
|

69
00:02:25,170 --> 00:02:26,440
0,570

70
00:02:26,620 --> 00:02:27,880
0,360 360,780 810,1050 1050,1170 1170,1260
And so on each of
在这些主机上，

71
00:02:27,880 --> 00:02:29,140
0,150 150,480 480,630 630,840 840,1260
these hosts,| there may be
|可能有不同的应用程序，

72
00:02:29,140 --> 00:02:31,090
0,270 270,960 960,1200 1200,1470 1470,1950
different applications,| maybe there's a
|可能这里有一个网络浏览器，

73
00:02:31,300 --> 00:02:33,460
0,360 360,870 870,1590 1590,1800 1800,2160
web browser here| and {}
|这里有一个 http 服务器，

74
00:02:33,550 --> 00:02:36,020
0,210 210,360 360,1920
you know http

75
00:02:36,140 --> 00:02:37,220
0,510 510,630 630,900 900,990 990,1080
server over here| and they
|它们通过这个网络进行交互。

76
00:02:37,220 --> 00:02:37,970
0,180 180,270 270,510 510,630 630,750
need to talk to each

77
00:02:37,970 --> 00:02:40,490
0,330 360,840 840,1200 1200,1530 1860,2520
other across this {} network.|
|

78
00:02:41,160 --> 00:02:43,170
0,510 810,1560 1560,1680 1680,1950 1950,2010
{You,know} there's a limit to
你可以建立一个局域网的规模是有限制的，

79
00:02:43,170 --> 00:02:44,520
0,330 330,840 840,960 960,1080 1080,1350
how big you can build

80
00:02:44,520 --> 00:02:46,560
0,60 60,810 810,1140 1140,1440 1440,2040
a single local area network,|
|

81
00:02:46,590 --> 00:02:47,580
0,390
so,
它的缩写是 LAN 局域网，

82
00:02:47,800 --> 00:02:49,420
0,210 210,330 330,540 540,900 990,1620
{you,know} for which the abbreviation

83
00:02:49,420 --> 00:02:51,670
0,150 150,660 660,1380 1560,2010 2010,2250
is usually LAN local area

84
00:02:51,670 --> 00:02:54,820
0,660 1590,2010 2220,2610 2760,3030 3030,3150
network| and the way to
|考虑这个问题的方法是，

85
00:02:54,820 --> 00:02:55,690
0,210 210,390 390,480 480,750 750,870
think about it maybe is|
|

86
00:02:55,690 --> 00:02:57,280
0,120 120,240 270,690 690,900 900,1590
that a local area network
一个局域网可以大到，

87
00:02:57,280 --> 00:02:58,570
0,180 180,300 300,450 450,840 840,1290
can be as large as|
|

88
00:02:58,630 --> 00:02:59,710
0,330 330,720 720,810 810,990 990,1080
a network in which it
在网络中的所有主机，

89
00:02:59,710 --> 00:03:00,760
0,240 240,570 570,750 750,960 960,1050
makes sense for all the

90
00:03:00,760 --> 00:03:01,600
0,390 390,450 450,540 540,720 720,840
host| to be able to
|能够收到彼此的数据包，

91
00:03:01,600 --> 00:03:02,620
0,270 270,510 510,600 600,780 780,1020
see all of each other's

92
00:03:02,620 --> 00:03:05,470
0,780 960,1380 1440,1710 1710,2070 2190,2850
packets,| {} that is {}
|有时主机想要向所有本地主机广播，

93
00:03:05,860 --> 00:03:07,270
0,510 510,810 810,990 990,1200 1230,1410
sometimes hosts need to want

94
00:03:07,270 --> 00:03:09,340
0,90 90,1260 1290,1650 1650,1980 1980,2070
to broadcast to all of

95
00:03:09,340 --> 00:03:10,900
0,150 150,420 420,1110 1350,1500 1500,1560
the local hosts,| you know
|这对十几个、二十个、五十个甚至一百个主机都很有效，

96
00:03:10,900 --> 00:03:11,740
0,150 150,330 330,690 690,810 810,840
that works fine with a

97
00:03:11,740 --> 00:03:13,690
0,540 540,930 990,1500 1500,1590 1590,1950
dozen or twenty or fifty

98
00:03:13,690 --> 00:03:14,530
0,60 60,300 300,480 480,540 540,840
or maybe even a hundred

99
00:03:14,530 --> 00:03:16,540
0,390 390,630 1110,1260 1260,1530 1530,2010
hosts,| but you can't really
|但是你不能简单地建立一个网络，

100
00:03:17,350 --> 00:03:19,330
0,450 450,810 810,1290 1290,1800 1800,1980
easily build single networks| where
|在那里所有的主机都可以直接交互，

101
00:03:19,330 --> 00:03:20,050
0,120 120,210 210,450 450,600 600,720
all the hosts can more

102
00:03:20,050 --> 00:03:21,040
0,30 30,240 240,630 630,900 900,990
or less directly talk to

103
00:03:21,040 --> 00:03:22,840
0,120 120,450 870,1110 1110,1380 1380,1800
each other,| {} with more
|比如说超过几百个主机。

104
00:03:22,870 --> 00:03:23,740
0,480
than,

105
00:03:23,890 --> 00:03:25,240
0,270 270,270 270,480 480,840 840,1350
say a few hundred hosts.|
|

106
00:03:25,450 --> 00:03:26,580
0,570

107
00:03:26,890 --> 00:03:28,360
0,330 540,750 750,840 840,1050 1050,1470
And so to deal with
所以，更大的互联网的构建方式是，

108
00:03:28,510 --> 00:03:30,130
0,450 480,750 750,900 900,1260 1260,1620
the way the larger Internet

109
00:03:30,130 --> 00:03:32,140
0,120 120,870 900,1260 1260,1560 1620,2010
is constructed is| that there's
|有很多这样的局域网，

110
00:03:32,140 --> 00:03:34,660
0,60 60,540 540,1140 1740,2010 2010,2520
a number of these individual

111
00:03:34,660 --> 00:03:36,760
0,1050 1410,1710 1710,1800 1800,2010 2010,2100
LANs,| may be one of
|可能是在麻省理工，

112
00:03:36,760 --> 00:03:38,240
0,990
MIT,|
|

113
00:03:38,270 --> 00:03:39,470
0,240 240,450 450,690 690,990 990,1200
you know, maybe one at
也可能在哈佛，

114
00:03:39,470 --> 00:03:43,160
0,1050 1440,2160 2280,2610 2610,3000 3000,3690
Harvard,| {} maybe one faraway
|也可能是在遥远的斯坦福。

115
00:03:43,160 --> 00:03:46,600
0,570 1830,2940
at Stanford.|
|

116
00:03:46,880 --> 00:03:49,550
0,540 780,1140 1350,2130 2130,2430 2430,2670
And, {} there's some sort
在它们之间有某种连接，

117
00:03:49,550 --> 00:03:51,170
0,60 60,780 780,1170 1170,1320 1320,1620
of connectivity between them| which
|你可以把它想象成路由器，

118
00:03:51,200 --> 00:03:51,980
0,150 150,270 270,480 480,570 570,780
you can think of as

119
00:03:52,010 --> 00:03:53,300
0,660 660,930 930,1050 1050,1200 1200,1290
routers,| so there might be
|所以这里可能有一台路由器，

120
00:03:53,300 --> 00:03:55,400
0,90 90,660 720,1140 1170,1800 1800,2100
a router,| that's plugged into
|在麻省理工的局域网里，

121
00:03:55,400 --> 00:03:57,230
0,210 210,870 870,1140 1140,1380 1380,1830
the MIT local area network,|
|

122
00:03:57,230 --> 00:03:59,060
0,270 300,780 780,990 990,1560 1560,1830
and also has perhaps a
也可能有一个长的连接到哈佛的网络，

123
00:03:59,090 --> 00:04:01,280
0,390 390,750 750,1170 1380,1710 1950,2190
longer link to {} the

124
00:04:01,280 --> 00:04:02,280
0,540
{

125
00:04:02,860 --> 00:04:05,260
0,390 1170,1320 1320,1440 1440,1890 1890,2400
-} to the Harvard network|
|

126
00:04:05,320 --> 00:04:06,190
0,360 360,480 480,660 660,810 810,870
and in fact there's a
实际上，有一个由路由器组成的网络，

127
00:04:06,190 --> 00:04:07,510
0,360 360,450 450,870 870,1050 1050,1320
network of routers,| which is
|它是互联网的主干，

128
00:04:07,510 --> 00:04:08,650
0,420 420,480 480,930 930,990 990,1140
essentially the backbone of the

129
00:04:08,650 --> 00:04:12,130
0,510 900,1560 1560,2310 2400,3090 3300,3480
Internet| including long-distance router to
|包括远程路由器到路由器的链路，

130
00:04:12,130 --> 00:04:13,600
0,360 360,870 960,1230 1230,1320 1320,1470
router links,| so there might
|在全国范围内可能会有更长的链路，

131
00:04:13,600 --> 00:04:14,800
0,150 150,240 240,630 630,870 870,1200
be a longer link across

132
00:04:14,800 --> 00:04:15,820
0,90 90,450 450,600 600,780 780,1020
the country| and maybe this
|可能这台路由器在斯坦福的某个局域网，

133
00:04:15,820 --> 00:04:17,260
0,300 300,420 420,720 720,930 930,1440
router is plugged into the

134
00:04:18,950 --> 00:04:20,330
0,600 600,870 870,1020 1020,1290 1290,1380
some local area network at

135
00:04:20,330 --> 00:04:21,590
0,570 660,900 900,1050 1050,1170 1170,1260
Stanford| and then we have
|我们的主机有更精细的任务，

136
00:04:21,590 --> 00:04:22,430
0,420 420,480 480,570 570,690 690,840
host which have this sort

137
00:04:22,430 --> 00:04:23,820
0,270 330,750
of {}

138
00:04:25,290 --> 00:04:26,640
0,240 240,720 720,1080 1080,1140 1140,1350
more elaborate task| in which
|我们希望麻省理工的主机，

139
00:04:26,640 --> 00:04:27,420
0,120 120,270 270,330 330,690 690,780
we want to host at

140
00:04:27,420 --> 00:04:28,410
0,570 570,660 660,750 750,930 930,990
MIT| to be able to
|能够与斯坦福主机的路由器交互，

141
00:04:28,410 --> 00:04:29,340
0,270 270,390 390,450 450,840 840,930
talk to a sequence of

142
00:04:29,340 --> 00:04:31,860
0,660 960,1530 1530,2160 2160,2430 2430,2520
routers to a host of

143
00:04:31,860 --> 00:04:33,210
0,510 510,720 780,1020 1020,1080 1080,1350
Stanford| and this is called
|这就是所谓的路由，

144
00:04:33,210 --> 00:04:34,200
0,540 540,690 690,780 780,930 930,990
routing,| so we need to
|所以麻省理工的主机需要一种方法

145
00:04:34,200 --> 00:04:35,910
0,210 210,450 600,1110 1110,1410 1410,1710
have a way for host

146
00:04:35,910 --> 00:04:38,160
0,120 120,810 960,1140 1140,2070 2100,2250
at MIT| to address to
|寻址斯坦福的主机，

147
00:04:38,160 --> 00:04:40,530
0,690 810,1050 1050,1530 1530,1830 1830,2370
name {} individual host Stanford|
|

148
00:04:40,770 --> 00:04:41,880
0,540 540,630 630,810 810,990 990,1110
and we need some way
我们需要一些方法，

149
00:04:41,880 --> 00:04:44,700
0,240 480,780 780,1080 1230,2220 2220,2820
to,| so that routers near
|麻省理工附近的路由器可以查看麻省理工发出的数据包，

150
00:04:44,730 --> 00:04:47,220
0,630 780,1050 1050,1620 1650,2040 2130,2490
MIT can look at a

151
00:04:47,220 --> 00:04:48,480
0,390 390,630 630,750 750,1170 1170,1260
packet sent by MIT| and
|找出这是发往哈佛的数据包，

152
00:04:48,480 --> 00:04:49,770
0,150 150,480 630,900 900,960 960,1290
say oh that's a packet

153
00:04:49,770 --> 00:04:51,900
0,600 630,990 990,1740 1740,1830 1830,2130
for for Harvard,| a packet
|或是发往斯坦福的包，

154
00:04:51,900 --> 00:04:53,250
0,90 90,720 720,840 840,1170 1170,1350
for Stanford,| a packet that
|或者是发往日本某个地方的包，

155
00:04:53,490 --> 00:04:54,540
0,480 480,570 570,660 660,960 960,1050
needs to go somewhere in

156
00:04:54,540 --> 00:04:55,980
0,570 570,810 840,1020 1020,1200 1200,1440
Japan| or who knows what.|
|或者其他什么地方。|

157
00:04:57,480 --> 00:04:59,820
0,450 870,1500 1740,2070 2070,2130 2130,2340
So, {} from the point
那么从网络协议的角度来讲，

158
00:04:59,820 --> 00:05:01,050
0,60 60,150 150,210 210,510 510,1230
of view of network protocols,|
|

159
00:05:01,080 --> 00:05:03,660
0,480 480,1380 1410,2010
this local, {
这个本地通信是由以太网协议负责，

160
00:05:04,250 --> 00:05:06,080
0,390 390,570 570,810 810,1500 1500,1830
-} this local communication is

161
00:05:06,110 --> 00:05:08,060
0,360 360,660 660,840 840,1500 1530,1950
taken care of by {}

162
00:05:08,120 --> 00:05:11,360
0,450 450,1380 1530,1920 1950,2190 2190,3240
Ethernet protocols,| and this long-distance
|而这种远程通信在上层的，

163
00:05:11,480 --> 00:05:12,890
0,690 690,780 780,1050 1050,1110 1110,1410
communication is sort of layered

164
00:05:12,890 --> 00:05:13,640
0,120 120,360 360,450 450,630 630,750
on top of that| and
|由 IP 或互联网协议来负责，

165
00:05:13,640 --> 00:05:15,830
0,300 300,570 570,690 690,1110 1170,2190
taken care of by IP

166
00:05:15,830 --> 00:05:17,690
0,270 270,630 630,1470 1500,1740 1740,1860
or Internet protocols,| that know
|它知道如何路由到远程主机。

167
00:05:17,690 --> 00:05:18,640
0,150 150,420
how to

168
00:05:19,110 --> 00:05:20,640
0,420 420,600 600,870 870,1410 1410,1530
route over long distances to

169
00:05:20,640 --> 00:05:22,120
0,360 360,960
distant hosts.|
|

170
00:05:23,560 --> 00:05:24,520
0,390 540,720 720,780 780,930 930,960
Okay, this is what {}
好的，这就是网络大概的样子，

171
00:05:24,520 --> 00:05:25,660
0,270 270,510 510,840 840,1080 1080,1140
network looks like in a

172
00:05:25,660 --> 00:05:28,600
0,630 960,1650 2280,2550 2550,2790 2790,2940
nutshell.| I'm would now want
|现在我想讨论一下数据包里的东西，

173
00:05:28,600 --> 00:05:31,120
0,60 60,360 360,810 810,1260 2070,2520
to talk about the what's

174
00:05:31,120 --> 00:05:32,820
0,1170
inside

175
00:05:32,820 --> 00:05:34,200
0,630 630,810 810,960 960,1290 1290,1380
packets,| that move across an
|它在以太网上移动或在更大的互联网上移动，

176
00:05:34,200 --> 00:05:36,000
0,480 480,570 570,780 780,1500 1680,1800
Ethernet or move across the

177
00:05:36,000 --> 00:05:38,190
0,390 390,990 1050,1680 1770,2100 2100,2190
larger Internet,| {} with an
|着眼于最终讨论主机中的软件，

178
00:05:38,190 --> 00:05:39,600
0,150 150,330 330,930 930,1230 1230,1410
eye to eventually talking about

179
00:05:39,600 --> 00:05:41,970
0,90 90,510 510,840 1290,1770 1950,2370
the software that in {}

180
00:05:42,550 --> 00:05:44,200
0,600 600,780 780,960 960,1050 1050,1650
hosts,| that has to process
|主机和路由器必须处理这些包。

181
00:05:44,200 --> 00:05:46,060
0,270 270,450 450,960 1200,1770 1770,1860
hosts and routers has to

182
00:05:46,060 --> 00:05:48,550
0,570 570,780 780,1440 2160,2400 2400,2490
process those packets.| So let
|所以，让我从最底层开始，

183
00:05:48,550 --> 00:05:49,390
0,60 60,270 270,360 360,450 450,840
me start with the lowest

184
00:05:49,390 --> 00:05:51,970
0,420 660,1230 1650,2190 2190,2370 2370,2580
level| and talk about what's
|讨论以太网数据包中的内容。

185
00:05:51,970 --> 00:05:54,580
0,540 570,840 840,1230 1230,1740 2190,2610
inside an Ethernet packet.| So,
|所以，当两台主机，

186
00:05:54,610 --> 00:05:55,720
0,510 510,690 690,960 960,1050 1050,1110
when two hosts,| that are
|它们连接到同一电缆、同一 WiFi 网络或同一以太网，

187
00:05:55,720 --> 00:05:56,920
0,270 270,690 690,1050 1050,1110 1110,1200
quite nearby attached to the

188
00:05:56,920 --> 00:05:58,540
0,330 330,930 930,1020 1020,1260 1260,1620
same cable or same WiFi

189
00:05:58,540 --> 00:05:59,830
0,450 450,510 510,780 780,990 990,1290
network or same {Ethernet -}|
|

190
00:05:59,890 --> 00:06:00,790
0,330 330,390 390,660 660,750 750,900
want to talk to each
想要相互通信，

191
00:06:00,790 --> 00:06:02,760
0,360
other,|
|

192
00:06:02,760 --> 00:06:04,410
0,390 390,570 570,660 660,1170 1170,1650
the sort of lowest level
一种最底层的协议，

193
00:06:04,470 --> 00:06:05,860
0,780
protocol,|
|

194
00:06:06,090 --> 00:06:07,860
0,240 240,600 630,1230 1260,1500 1500,1770
{} which allows two hosts
允许同一个局域网上两台主机相互通信的是以太网协议，

195
00:06:07,860 --> 00:06:08,550
0,60 60,150 150,360 360,600 600,690
on the same LAN to

196
00:06:08,550 --> 00:06:09,240
0,240 240,330 330,420 420,570 570,690
talk to each other is

197
00:06:09,240 --> 00:06:11,130
0,90 90,510 510,1080 1140,1530 1590,1890
the Ethernet protocol| and you
|你可以想象一台主机，

198
00:06:11,130 --> 00:06:13,110
0,120 120,510 510,870 1050,1470 1680,1980
can think of {} one

199
00:06:13,110 --> 00:06:15,880
0,810 1170,1500 1500,1980
host,| host 1
|主机 1 通过以太网发送一个帧到主机 2 ，

200
00:06:15,910 --> 00:06:17,160
0,720
{}

201
00:06:17,470 --> 00:06:20,110
0,870 1470,1860 1860,2340 2340,2550 2550,2640
sending a frame over the

202
00:06:20,110 --> 00:06:21,580
0,390 390,510 510,1050 1050,1140 1140,1470
over the Ethernet to host

203
00:06:21,580 --> 00:06:22,700
0,480
2,|
|

204
00:06:22,700 --> 00:06:23,720
0,150 150,330 330,420 420,780 780,1020
what's called an Ethernet frame,|
即所谓的以太网帧，|

205
00:06:23,720 --> 00:06:24,620
0,150 150,240 240,360 360,570 570,900
which is the Ethernet work
它是在以太网工作的数据包，

206
00:06:24,620 --> 00:06:26,180
0,150 150,600 840,1140 1140,1350 1380,1560
for packet {}| and it's
|它是一串字节，

207
00:06:26,180 --> 00:06:28,430
0,330 360,810 810,1050 1200,2100 2100,2250
a series of bytes| that
|通过以太网从一台主机发送到另一台主机，

208
00:06:28,430 --> 00:06:30,540
0,90 90,660
are sent

209
00:06:31,000 --> 00:06:32,260
0,240 240,360 360,810 960,1140 1140,1260
over the Ethernet from one

210
00:06:32,260 --> 00:06:33,640
0,240 240,360 360,750 750,990 1020,1380
host to another| and what
|而以太网协议所做的是

211
00:06:33,640 --> 00:06:35,080
0,90 90,540 540,990 990,1320 1320,1440
the ethernet protocol does is|
|

212
00:06:35,080 --> 00:06:37,030
0,210 240,870 870,1140 1140,1800 1800,1950
have just enough information in
在其中包含足够的信息

213
00:06:37,030 --> 00:06:39,610
0,300 570,1110 1590,2220 2220,2340 2340,2580
it| to allow the two
|让两个主机知道在与谁交互，

214
00:06:39,610 --> 00:06:42,700
0,750 810,1350 1890,2550 2550,2760 2760,3090
hosts to realize who's talking

215
00:06:42,700 --> 00:06:43,690
0,120 120,240 240,480 480,630 630,990
to each other| and cause
|并且使主机能够识别寻址到它们的数据包。

216
00:06:43,690 --> 00:06:44,410
0,90 90,420 420,480 480,570 570,720
the host to be able

217
00:06:44,410 --> 00:06:46,090
0,120 120,1020 1020,1470 1470,1590 1590,1680
to recognize packets that are

218
00:06:46,090 --> 00:06:48,400
0,450 450,510 510,990 1350,1860
addressed to them {}.|
|

219
00:06:48,550 --> 00:06:49,480
0,180 180,270 270,420 420,510 510,930
And so what an Ethernet
所以以太网报头看起来是什么样子，

220
00:06:49,480 --> 00:06:50,830
0,330 330,660 660,930 1020,1200 1200,1350
header looks,| so the way
|以太网处理这个问题的方式是，

221
00:06:50,830 --> 00:06:52,540
0,300 540,1080 1080,1350 1350,1440 1440,1710
that Ethernet deals with this

222
00:06:52,540 --> 00:06:53,830
0,120 120,300 300,570 570,900 900,1290
is| that every Ethernet packet
|每个以太网数据包的开头都有一个报头，

223
00:06:53,920 --> 00:06:56,530
0,480 480,570 570,660 660,1470 1800,2610
has at the beginning {}

224
00:06:57,270 --> 00:06:58,700
0,270 270,870
a header,|
|

225
00:06:59,030 --> 00:07:01,120
0,180 180,420 420,660 660,1560
that has three fields,
它有三个字段，以及一些以太网有效载荷，

226
00:07:01,380 --> 00:07:03,180
0,510 540,930 930,1080 1080,1380 1410,1800
{} followed by some Ethernet

227
00:07:03,180 --> 00:07:04,400
0,750
payload,|
|

228
00:07:06,790 --> 00:07:07,630
0,330 330,450 450,660 660,750 750,840
{} and what's in the
报头有两个以太网地址，

229
00:07:07,630 --> 00:07:11,140
0,420 420,900 1470,2040 2040,2760 2940,3510
header is two {} Ethernet

230
00:07:11,140 --> 00:07:12,340
0,690 690,780 780,930 930,1080 1080,1200
addresses,| we'll call them the
|我们称它们为目的地址和源地址，

231
00:07:12,340 --> 00:07:14,590
0,690 690,1350 1500,1800 1800,1890 1890,2250
destination address and the source

232
00:07:14,590 --> 00:07:16,930
0,600 690,1110 1110,1800 1830,1950 1950,2340
address| and also the type
|还有数据包的类型，

233
00:07:16,930 --> 00:07:18,280
0,120 120,210 210,750 990,1290 1290,1350
of the packet,| each of
|每个地址只是一个 48 位的数字，

234
00:07:18,280 --> 00:07:19,780
0,180 180,900 900,1080 1080,1200 1230,1500
these addresses is {} just

235
00:07:19,780 --> 00:07:21,520
0,90 90,600 600,780 780,1290
a 48 bit number,|
|

236
00:07:21,550 --> 00:07:23,740
0,210 210,390 390,930 930,2040 2040,2190
{} that uniquely identifies a
唯一地标识特定的网卡，

237
00:07:23,740 --> 00:07:25,840
0,600 600,990 990,1440 1440,1740 1740,2100
particular network interface card really,|
|

238
00:07:26,770 --> 00:07:28,810
0,330 330,570 570,870 870,1530 1590,2040
and this type field is
这个类型字段向接收主机表示应该如何处理这个包，

239
00:07:28,810 --> 00:07:29,560
0,120 120,180 180,570 570,660 660,750
going to indicate to the

240
00:07:29,560 --> 00:07:31,330
0,570 570,960 990,1350 1350,1470 1470,1770
recipient host| what it's supposed
|它如何处理数据包，

241
00:07:31,330 --> 00:07:32,200
0,90 90,210 210,360 360,510 510,870
to do with that packet|
|

242
00:07:32,200 --> 00:07:33,100
0,90 90,180 180,360 360,600 600,900
and what that really means
它的实际意义是，

243
00:07:33,100 --> 00:07:34,990
0,120 120,360 360,750 750,1050 1050,1890
is| what higher level protocol
|以哪种更高级别的协议检查和处理这个以太网数据包的有效载荷。

244
00:07:35,110 --> 00:07:38,320
0,390 390,960 960,1950 2010,2280 2280,3210
{} should examine and process

245
00:07:38,350 --> 00:07:39,850
0,210 210,810 810,870 870,1110 1110,1500
the payload of that Ethernet

246
00:07:39,850 --> 00:07:40,580
0,360
packet.|
|

247
00:07:41,220 --> 00:07:43,830
0,420 1470,1740 1740,2220 2280,2520 2520,2610
{} So, these, these are
这些位通常被设置为分块通过线路，

248
00:07:43,830 --> 00:07:45,750
0,180 180,270 270,930 990,1530 1530,1920
bits that go are typically

249
00:07:45,750 --> 00:07:46,470
0,180 180,240 240,360 360,630 630,720
set to go over the

250
00:07:46,470 --> 00:07:48,960
0,690 750,1170 1530,2010
wire, {} piece,|
|

251
00:07:49,110 --> 00:07:50,730
0,360 360,540 540,990 990,1200 1200,1620
48 plus 48 plus 16
48 加 48 加 16 位报头，

252
00:07:50,730 --> 00:07:51,990
0,210 210,270 270,750 870,1140 1140,1260
bits of header| and then
|然后是有效载荷，

253
00:07:51,990 --> 00:07:54,630
0,360 360,600 600,1290 1920,2310 2310,2640
however much payload| and not
|并且对于软件来说是不可见的，

254
00:07:54,630 --> 00:07:56,040
0,210 210,660 660,750 750,840 840,1410
really visible to the software,|
|

255
00:07:56,040 --> 00:07:57,210
0,240 480,660 660,930 930,1080 1080,1170
but {} there's going to
但是在包的开头会有一些东西，

256
00:07:57,210 --> 00:07:58,410
0,120 120,570 570,660 660,750 750,1200
be something at the beginning

257
00:07:58,410 --> 00:07:59,910
0,120 120,210 210,750 930,1230 1230,1500
of the packet,| {} that's
|由硬件在非常低的级别上识别，

258
00:07:59,910 --> 00:08:01,350
0,780 780,870 870,930 930,1230 1230,1440
recognized at a very low

259
00:08:01,350 --> 00:08:02,430
0,240 240,390 390,480 480,900 900,1080
level by the hardware| that
|表示数据包的开始，

260
00:08:02,430 --> 00:08:03,630
0,660 660,720 720,1050 1050,1110 1110,1200
signifies the start of a

261
00:08:03,630 --> 00:08:06,120
0,420 1440,1860 1860,1920 1920,2280 2280,2490
packet| and the receiving host
|而接收主机需要知道包结束，

262
00:08:06,120 --> 00:08:06,960
0,180 180,330 330,420 420,510 510,840
needs to know the packet

263
00:08:06,960 --> 00:08:07,950
0,510 510,630 630,810 810,930 930,990
ends,| so there's going to
|所以在结束会有另一个特殊的位模式，

264
00:08:07,950 --> 00:08:11,100
0,150 150,750 900,1320 2100,2880 2880,3150
be another {} special bit

265
00:08:11,100 --> 00:08:11,940
0,330 330,420 420,570 570,750 750,840
pattern at the end,| that
|表示数据包的结束。

266
00:08:11,940 --> 00:08:12,900
0,510 510,630 630,810 810,870 870,960
signifies the end of the

267
00:08:12,900 --> 00:08:13,680
0,390
packet.|
|

268
00:08:14,250 --> 00:08:16,110
0,780 780,1110 1110,1380 1380,1500 1500,1860
These two begin and end
这两个开始和结束标志永远不会被软件看到，

269
00:08:16,110 --> 00:08:17,280
0,540 540,630 630,900 900,1080 1080,1170
flags are never seen by

270
00:08:17,280 --> 00:08:18,750
0,90 90,450 450,870 870,960 960,1470
the software,| but the rest,
|但是剩下的以太网帧

271
00:08:20,290 --> 00:08:21,250
0,150 150,330 330,390 390,570 570,960
the rest of this Ethernet

272
00:08:21,250 --> 00:08:23,050
0,540 750,960 960,1350 1350,1590 1590,1800
frame| is delivered by the
|到 H2 的网卡是由软件完成的。

273
00:08:23,050 --> 00:08:24,430
0,330 330,720 720,960 960,1080 1080,1380
network interface card that Nic

274
00:08:24,430 --> 00:08:25,870
0,120 120,360 360,750 870,1290 1290,1440
at {H2 -} {} by

275
00:08:25,870 --> 00:08:27,000
0,60 60,570
the software.|
|

276
00:08:27,160 --> 00:08:29,740
0,420 1620,1800 1800,1950 1950,2460 2460,2580
{} If you've looked at
如果你看这门课的最后的实验，

277
00:08:29,740 --> 00:08:31,330
0,420 540,1020 1020,1380 1380,1530 1530,1590
the final lab for the

278
00:08:31,330 --> 00:08:33,520
0,690 1380,1590 1590,1830 1830,2040 2040,2190
course,| you'll see that the
|你会看到我们给你的软件包含了一些新文件，

279
00:08:33,520 --> 00:08:34,900
0,360 360,480 480,660 660,960 960,1380
software we give you includes

280
00:08:34,900 --> 00:08:35,770
0,60 60,270 270,330 330,420 420,870
a bunch of new files,|
|

281
00:08:35,770 --> 00:08:37,720
0,540 570,1110 1110,1440 1440,1710 1710,1950
including {kernel/net.h - - -
包括 kernel/net.h ，

282
00:08:37,720 --> 00:08:39,250
0,420 450,840 840,1230 1230,1260 1260,1530
-}| which contains a whole
|包含了用于不同网络协议的报头的一整套定义，

283
00:08:39,250 --> 00:08:42,940
0,420 420,840 840,1890 1890,2400
bunch of definitions of

284
00:08:43,120 --> 00:08:45,010
0,510 510,1080 1080,1260 1260,1590 1590,1890
packet headers for different network

285
00:08:45,010 --> 00:08:47,020
0,720 1260,1650 1650,1740 1740,1920 1920,2010
protocols,| and so this is
|这是直接取自我们给你的 net.h 文件的内容，

286
00:08:47,020 --> 00:08:48,730
0,360 390,720 720,930 930,1500 1500,1710
just text taken directly from

287
00:08:48,730 --> 00:08:49,630
0,150 150,330 330,510 510,660 660,900
{} {net.h - -} file

288
00:08:49,630 --> 00:08:50,980
0,120 120,300 300,540 810,1170 1170,1350
we give you| {} and
|它包括对以太网报头的布局的描述，

289
00:08:50,980 --> 00:08:52,360
0,90 90,960
it includes

290
00:08:52,770 --> 00:08:54,570
0,870 870,900 900,1110 1110,1710 1710,1800
{ - -} description of

291
00:08:54,570 --> 00:08:56,370
0,360 390,990 990,1110 1110,1230 1230,1800
the layout of the Ethernet

292
00:08:56,610 --> 00:08:58,710
0,510 570,1050 1050,1320 1320,1440 1440,2100
header,| and this this software
|我们给你的软件使用这个结构体定义，

293
00:08:58,710 --> 00:08:59,820
0,90 90,240 240,360 360,630 660,1110
we give you actually uses

294
00:08:59,820 --> 00:09:01,530
0,360 360,630 630,810 810,1140 1140,1710
literally uses this struct definition,|
|

295
00:09:01,650 --> 00:09:03,960
0,210 210,420 420,600 780,1530 1770,2310
in order to parse incoming
用来解析传入的以太网数据包，

296
00:09:03,960 --> 00:09:05,610
0,330 330,900 1170,1350 1350,1470 1470,1650
Ethernet packets| is to pick
|从报头中获取目的地址和类型字段，

297
00:09:05,610 --> 00:09:07,800
0,390 390,480 480,1050 1350,1860 1890,2190
apart the head to get

298
00:09:07,800 --> 00:09:10,140
0,330 450,1260 1260,1380 1380,2040 2070,2340
the destination and type,| then
|然后也使用这个结构体来格式化包。

299
00:09:10,140 --> 00:09:11,460
0,270 270,660 660,810 810,1200 1200,1320
also uses this structure to

300
00:09:11,460 --> 00:09:13,350
0,390 390,1110 1410,1560 1560,1620 1620,1890
format packets.| So the host
|所以，主机实际上负责

301
00:09:13,350 --> 00:09:14,490
0,90 90,300 300,390 390,870 870,1140
is really in charge of|
|

302
00:09:14,980 --> 00:09:16,270
0,300 300,360 360,930 930,1140 1140,1290
sort of setting up and
设置和解析以太网使用的报头。

303
00:09:16,270 --> 00:09:19,180
0,480 480,630 630,1170 1590,2190 2550,2910
parsing this header, {} that's

304
00:09:19,180 --> 00:09:20,560
0,240 240,390 390,900
used by Ethernet.|
|

305
00:09:22,360 --> 00:09:24,900
0,210 210,690 690,1020 1320,1980
Any questions about {}
关于以太网数据包有什么问题吗？

306
00:09:24,930 --> 00:09:26,620
0,480 480,1170
Ethernet packets?|
|

307
00:09:32,070 --> 00:09:33,540
0,390 390,660 660,780 780,840 840,1470
Yeah, I have a question.|
是的，我有个问题。|

308
00:09:33,570 --> 00:09:36,340
0,540 570,1140 1260,1620 1620,2220
Please.| Is is the
请。|您提到的位模式，

309
00:09:36,340 --> 00:09:37,480
0,240 240,600 600,720 720,1020 1020,1140
bit pattern you mentioned| that
|硬件使用它来确定数据包的开始和结束，

310
00:09:37,480 --> 00:09:39,790
0,90 90,930 1200,1770 1770,1890 1890,2310
the hardware uses to determine

311
00:09:39,790 --> 00:09:40,510
0,90 90,360 360,480 480,630 630,720
the start and end of

312
00:09:40,510 --> 00:09:42,910
0,90 90,510 510,1140 1140,1800 1890,2400
a packet| similar to the
|类似于实验中的 eop ，

313
00:09:42,940 --> 00:09:45,500
0,990 1350,1530 1530,1620 1620,2040
eop in the lab,|
|

314
00:09:46,850 --> 00:09:48,140
0,330 330,450 450,900 900,1080 1080,1290
which is a end of
也就是数据包的结束。

315
00:09:48,140 --> 00:09:49,740
0,630
packet.|
|

316
00:09:49,740 --> 00:09:51,460
0,1110
No,
不， eop 是一个独立机制，

317
00:09:52,200 --> 00:09:53,610
0,300 300,480 480,600 600,1200 1200,1410
no, the {eop -} is

318
00:09:53,610 --> 00:09:56,970
0,900 900,1860 1890,2520 2520,2970 2970,3360
a separate mechanism| between the
|在驱动程序和网卡之间，以帮助它们进行通信。

319
00:09:57,000 --> 00:09:58,980
0,810 810,990 990,1080 1080,1650 1770,1980
driver and the NIC to

320
00:09:58,980 --> 00:10:00,740
0,210 210,450 450,1320
help them communicate.|
|

321
00:10:00,770 --> 00:10:02,990
0,630 900,1350 1350,1620 1680,2100 2100,2220
{} This is, there's some
有一些电路方案，

322
00:10:02,990 --> 00:10:05,000
0,570 570,1110 1110,1290 1290,1740 1740,2010
electrical schemes,| some low level
|一些底层的电或光信号方案

323
00:10:05,000 --> 00:10:07,580
0,510 510,600 600,1350 1440,2040 2040,2580
electrical or optical signaling scheme|
|

324
00:10:07,580 --> 00:10:10,370
0,300 510,1050 1050,1800 1830,2340 2340,2790
to transmit bits over Ethernet
用于在以太网电缆上传输位，

325
00:10:10,370 --> 00:10:12,710
0,870 1050,1410 1410,1590 1590,2160 2160,2340
cables,| and these flags have
|这些标志必须，

326
00:10:12,710 --> 00:10:14,640
0,120 120,330 330,540 540,1290
to do with the,|
|

327
00:10:14,640 --> 00:10:15,980
0,630
typically,
通常，这种电信号模式在数据包中是非法的，

328
00:10:16,340 --> 00:10:19,280
0,1050 1410,2160 2160,2340 2340,2520 2520,2940
electrical patterns that would not

329
00:10:19,280 --> 00:10:21,470
0,270 270,960 1140,1710 1710,1770 1770,2190
be legal inside a packet|
|

330
00:10:22,310 --> 00:10:23,870
0,390 390,540 540,870 1110,1290 1290,1560
{} and so {you,know} one
所以，一种方案是，

331
00:10:23,870 --> 00:10:25,670
0,540 540,930 930,1350 1350,1740 1740,1800
scheme is to| instead of
|除了在线路上只发送 0 或 1 的位，

332
00:10:25,670 --> 00:10:27,200
0,210 210,630 660,990 990,1260 1260,1530
just sending zero one bits

333
00:10:27,200 --> 00:10:28,730
0,210 210,300 300,840 960,1380 1380,1530
over the wire,| you can
|你可以发送两个信号序列，

334
00:10:28,730 --> 00:10:30,560
0,540 540,690 690,840 840,1230
send you could send

335
00:10:31,540 --> 00:10:33,670
0,270 270,840 840,960 960,1230 1230,2130
{} sequences of two signals,|
|

336
00:10:33,910 --> 00:10:35,620
0,210 210,420 420,630 630,1080 1080,1710
so there's four different symbols
所以有四种不同的符号，

337
00:10:35,620 --> 00:10:38,140
0,720 930,1380 1680,2220 2220,2310 2310,2520
possible| with sequences of two
|有两个不同的电压水平的序列或别的什么，

338
00:10:38,140 --> 00:10:42,550
0,570 990,1650 2370,3390 3420,4050 4050,4410
different {} electrical voltage levels

339
00:10:42,550 --> 00:10:44,320
0,60 60,480 480,930 930,1230 1410,1770
or something| and have two
|四种信号中的两种表示 0 或 1 位，

340
00:10:44,320 --> 00:10:45,580
0,90 90,180 180,390 390,840 840,1260
of the four possible symbols

341
00:10:45,580 --> 00:10:47,350
0,360 360,690 690,750 750,1080 1080,1770
indicate 0 or 1 bits|
|

342
00:10:47,350 --> 00:10:48,010
0,120 120,210 210,510 510,570 570,660
in the body of the
在数据包的主体中，

343
00:10:48,010 --> 00:10:49,600
0,480 600,810 810,930 930,1020 1020,1590
packet| and have the remaining
|而使用其余的两种来表示开始和结束。

344
00:10:49,600 --> 00:10:52,030
0,660 780,1440 1440,1830 1830,1980 1980,2430
two indicate begin and end.|
|

345
00:10:52,440 --> 00:10:53,190
0,150 150,300 300,360 360,690 690,750
That was in fact a
实际上，这就是几年前用过的方案，

346
00:10:53,190 --> 00:10:54,120
0,270 270,360 360,510 510,720 720,930
scheme that was used years

347
00:10:54,120 --> 00:10:55,530
0,540 600,870 870,1110 1110,1260 1260,1410
ago,| scheme much like that
|几年前以太网就使用过类似的方案，

348
00:10:55,530 --> 00:10:56,820
0,150 150,330 330,510 510,810 840,1290
was used years ago Ethernet,|
|

349
00:10:56,910 --> 00:10:57,840
0,150 150,330 330,630 630,750 750,930
I don't actually know how
我不知道它现在是怎么工作的。

350
00:10:57,840 --> 00:10:59,160
0,90 90,390 390,750
it works now.|
|

351
00:11:02,010 --> 00:11:04,460
0,540 1020,1830
Okay, {}
好的，关于这些地址需要知道的是

352
00:11:04,520 --> 00:11:06,140
0,510 510,600 600,900 900,1200 1200,1620
something to know about these

353
00:11:06,170 --> 00:11:08,180
0,810 810,1020 1020,1290 1320,1800 1800,2010
addresses is that| what these
|这些 48 位地址是什么，

354
00:11:08,180 --> 00:11:10,100
0,60 60,540 540,660 660,1440 1500,1920
are 48 bit addresses,| the
|48 位的原因是，

355
00:11:10,340 --> 00:11:11,540
0,360 360,450 450,510 510,930 930,1200
reason for the 48 bits

356
00:11:11,540 --> 00:11:12,890
0,120 120,360 360,1050 1050,1290 1290,1350
is that| they wanted to
|想要确保有足够的位，

357
00:11:12,890 --> 00:11:13,730
0,180 180,360 360,600 600,720 720,840
make sure that there was

358
00:11:13,730 --> 00:11:15,080
0,240 240,960 990,1140 1140,1200 1200,1350
enough bits| to be able
|能够为曾经制造的每个不同的网卡提供唯一的地址，

359
00:11:15,080 --> 00:11:16,840
0,90 90,240 240,390 480,1260
to give a unique

360
00:11:16,840 --> 00:11:19,090
0,270 270,870 1080,1500 1500,1920 1920,2250
{} {address,to} every different NIC

361
00:11:19,090 --> 00:11:21,280
0,210 210,1170 1620,1920 1920,2070 2070,2190
ever manufactured.| {} So there's
|所以有大量的地址，

362
00:11:21,280 --> 00:11:22,360
0,30 30,360 360,570 570,660 660,1080
a vast number of possible

363
00:11:22,360 --> 00:11:24,520
0,660 810,1080 1080,1560 1560,2100 2100,2160
addresses,| the internal structure of
|这 48 位地址的内部结构是

364
00:11:24,520 --> 00:11:26,020
0,300 300,750 750,870 870,1380 1380,1500
these 48 bit addresses is

365
00:11:26,020 --> 00:11:27,790
0,150 150,240 240,930 990,1680 1680,1770
that| the first half, the
|前半部分的 24 位是制造商编号，

366
00:11:27,790 --> 00:11:29,770
0,240 240,780 780,1290 1740,1920 1920,1980
first 24 bits is a

367
00:11:29,770 --> 00:11:32,590
0,900 900,1380 1410,1980 2010,2430 2430,2820
manufacturer number| and there's every
|每个网卡制造商都有自己的制造商编号，

368
00:11:32,590 --> 00:11:35,320
0,1020 1050,1440 1440,1830 1830,2250 2250,2730
manufacturer network interface cards NICs

369
00:11:35,350 --> 00:11:37,090
0,330 330,480 480,720 720,1410 1410,1740
has its own manufacturer number,|
|

370
00:11:37,090 --> 00:11:38,200
0,150 150,300 300,390 390,720 720,1110
so that's the first 24
这就是前 24 位，

371
00:11:38,200 --> 00:11:39,970
0,420 660,960 960,1020 1020,1320 1320,1770
bits,| and the second 24
|第二部分 24 位是

372
00:11:39,970 --> 00:11:42,250
0,210 210,330 330,660 1290,1560 1560,2280
bits is| just any number
|由制造商分配的任意唯一数字，

373
00:11:42,310 --> 00:11:43,480
0,150 150,270 270,540 540,900 900,1170
can be any unique number

374
00:11:43,480 --> 00:11:45,340
0,330 330,450 450,540 540,1260 1260,1860
assigned by the manufacturers,| manufacturers
|制造商通常按升序分配它们，

375
00:11:45,340 --> 00:11:46,660
0,360 360,660 660,810 810,990 990,1320
typically assign them in just

376
00:11:46,690 --> 00:11:48,430
0,540 540,990 990,1140 1140,1260 1260,1740
ascending orders,| if you buy
|如果你购买 6 个网卡，

377
00:11:48,790 --> 00:11:49,990
0,240 240,420 420,690 690,750 750,1200
you know half a dozen

378
00:11:49,990 --> 00:11:52,030
0,300 300,690 690,1290 1650,1950 1950,2040
network interface cards,| {} the
|每个网卡已经编程为自己的地址，

379
00:11:52,030 --> 00:11:54,040
0,270 270,660 660,1170 1470,1710 1710,2010
network interface card, each network

380
00:11:54,040 --> 00:11:55,600
0,360 360,600 600,780 780,1260 1260,1560
interface card has programmed into

381
00:11:55,600 --> 00:11:57,100
0,240 240,450 450,1050 1170,1410 1410,1500
its own address,| and if
|如果你看一下地址，

382
00:11:57,100 --> 00:11:58,120
0,120 120,360 360,480 480,600 600,1020
you look at the address,|
|

383
00:11:58,120 --> 00:11:59,620
0,120 120,390 390,630 870,1080 1080,1500
you'll see that the {high,bits}
你会发现它们高位是相同的，

384
00:11:59,620 --> 00:12:00,580
0,60 60,150 150,600 600,720 720,960
are the same| for these
|这些你从同一制造商购买的 6 个网卡，

385
00:12:00,580 --> 00:12:02,020
0,450 450,810 810,900 900,1200 1230,1440
six cards you bought from

386
00:12:02,020 --> 00:12:03,490
0,60 60,240 240,960 990,1350 1350,1470
the same manufacturer,| but the
|而低 24 位可能是 6 个连续的编号。

387
00:12:03,490 --> 00:12:05,200
0,390 390,870 870,1380 1380,1620 1620,1710
low {} 24 bits are

388
00:12:05,200 --> 00:12:08,680
0,600 630,1350 1530,2340 2340,3240
probably six sequential numbers.|
|

389
00:12:09,060 --> 00:12:11,640
0,420 810,1260 1830,2130 2130,2520 2520,2580
{} So these addresses are
所以这些地址是唯一的，

390
00:12:11,640 --> 00:12:14,550
0,720 1170,1620 1860,2460 2490,2700 2700,2910
unique,| but {} what they're
|但他们没有帮助定位目的主机，

391
00:12:14,550 --> 00:12:16,710
0,390 390,990 990,1230 1230,1560 1560,2160
not helpful in is locating

392
00:12:16,710 --> 00:12:18,120
0,60 60,690 690,1140 1170,1320 1320,1410
the destination host,| so if
|所以，如果你知道正在交互的主机位于同一局域网上，

393
00:12:18,120 --> 00:12:18,870
0,120 120,330 330,420 420,630 630,750
you know the host you're

394
00:12:18,870 --> 00:12:19,800
0,330 330,600 600,720 720,840 840,930
talking about is on the

395
00:12:19,800 --> 00:12:21,180
0,390 390,660 660,900 900,1230 1230,1380
same local area network,| as
|你可以使用以太网地址，

396
00:12:21,180 --> 00:12:23,010
0,270 420,960 960,1110 1110,1350 1350,1830
you you can use {}

397
00:12:23,600 --> 00:12:25,400
0,660 660,1050 1050,1290 1380,1710 1710,1800
Ethernet address| and it's on
|并且它位于相同的局域网上。

398
00:12:25,400 --> 00:12:26,900
0,90 90,540 600,990 990,1170 1170,1500
the same local area network.|
|

399
00:12:26,900 --> 00:12:27,950
0,150 150,240 240,360 360,930 930,1050
So we'll be listening for
所以我们会监听它自己地址的包，

400
00:12:27,950 --> 00:12:29,300
0,360 360,480 480,630 630,780 780,1350
packet with his own address,|
|

401
00:12:29,840 --> 00:12:30,530
0,240 240,330 330,420 420,660 660,690
but if the hosts are
但如果主机想与国家另一边的交互，

402
00:12:30,530 --> 00:12:31,190
0,180 180,240 240,480 480,570 570,660
trying to talk to {}

403
00:12:31,190 --> 00:12:31,760
0,60 60,180 180,300 300,510 510,570
on the other side of

404
00:12:31,760 --> 00:12:32,990
0,90 90,690 810,1050 1050,1170 1170,1230
the country,| you have to
|你必须使用不同的方案，

405
00:12:32,990 --> 00:12:34,040
0,150 150,210 210,450 450,900 900,1050
use a different scheme,| and
|这就是 IP 的相关内容，

406
00:12:34,190 --> 00:12:35,210
0,240 240,390 390,750 750,870 870,1020
that's what's IP is all

407
00:12:35,210 --> 00:12:36,350
0,300 570,720 720,900 900,1080 1080,1140
about,| I'll talk about in
|我稍后会谈到。

408
00:12:36,350 --> 00:12:37,160
0,60 60,300
a bit.|
|

409
00:12:37,660 --> 00:12:38,760
0,540

410
00:12:38,970 --> 00:12:40,680
0,330 330,630
Okay, so
好的，这就是这些包的样子，

411
00:12:40,680 --> 00:12:41,910
0,150 150,240 240,480 480,840 870,1230
this is what {} these

412
00:12:41,910 --> 00:12:43,260
0,420 420,630 630,900 930,1200 1200,1350
packets look like,| you can
|你可以使用 tcpdump 查看运行中的以太网包，

413
00:12:43,260 --> 00:12:45,810
0,630 660,1140 1140,1320 1320,1710 1710,2550
actually look at Ethernet packets

414
00:12:46,890 --> 00:12:48,600
0,240 240,780 780,1050 1050,1170 1170,1710
in action using the {tcpdump

415
00:12:48,600 --> 00:12:50,700
0,480 540,1050 1050,1410 1710,1950 1950,2100
-} program| and {} you're
|我们鼓励你这样做，

416
00:12:50,700 --> 00:12:51,600
0,360 360,450 450,600 600,810 810,900
encouraged to do this,| you
|你可能需要在实验中用到。

417
00:12:51,600 --> 00:12:52,500
0,270 270,480 480,540 540,690 690,900
probably need to do this

418
00:12:52,500 --> 00:12:53,550
0,90 90,300 300,360 360,450 450,1050
as part of the lab.|
|

419
00:12:53,580 --> 00:12:55,170
0,540 540,780 780,870 870,1200 1200,1590
And this is actually {
这是来自实验的 tcpdump 的输出，

420
00:12:55,470 --> 00:12:56,440
0,510
-

421
00:12:57,380 --> 00:12:59,000
0,480 510,630 630,930 930,1020 1020,1620
-} the output of {tcpdump

422
00:12:59,000 --> 00:13:01,370
0,270 270,720 720,840 840,1560 1740,2370
-} from the lab {},|
|

423
00:13:01,640 --> 00:13:03,470
0,300 300,630 630,1320 1320,1440 1440,1830
and what tcpdump is telling
tcpdump 在这里告诉我们一系列事情，

424
00:13:03,470 --> 00:13:05,420
0,180 180,660 1200,1500 1530,1890 1890,1950
us here was telling us

425
00:13:05,420 --> 00:13:06,110
0,60 60,180 180,360 360,450 450,690
a whole bunch of things,|
|

426
00:13:06,110 --> 00:13:06,920
0,150 150,390 390,600 600,720 720,810
this first part is the
第一部分是数据包到达的时间。

427
00:13:06,920 --> 00:13:08,390
0,420 420,480 480,660 660,720 720,1470
time at which the packet

428
00:13:08,600 --> 00:13:10,180
0,1110
arrived,|
|

429
00:13:10,600 --> 00:13:11,230
0,180 180,270 270,420 420,540 540,630
if you like you can
如果你愿意，可以在你的笔记本电脑上试一下，

430
00:13:11,230 --> 00:13:12,820
0,180 180,630 690,840 840,960 960,1590
try this on your laptops,|
|

431
00:13:12,820 --> 00:13:14,080
0,120 120,240 240,600 600,1020 1020,1260
if you install {tcpdump -},|
如果安装了 tcpdump ，|

432
00:13:14,350 --> 00:13:16,060
0,720 990,1350 1350,1410 1410,1650 1650,1710
{} and the rest of
第一行的其余部分是一种人类可读的说明，

433
00:13:16,060 --> 00:13:17,980
0,90 90,450 450,840 840,1260 1470,1920
the first line is a

434
00:13:17,980 --> 00:13:20,620
0,210 210,300 330,1200 1200,2010 2040,2640
sort of human readable {}

435
00:13:21,360 --> 00:13:22,530
0,720 720,780 780,930 930,1110 1110,1170
interpretation| of what kind of
|说明这是一种什么样的数据包，

436
00:13:22,530 --> 00:13:24,360
0,360 360,570 570,1080 1350,1650 1650,1830
packet that is| and then
|然后接下来的三行或这里的部分是

437
00:13:24,360 --> 00:13:26,040
0,210 210,480 480,660 660,1560 1560,1680
these next three lines or

438
00:13:26,040 --> 00:13:28,680
0,300 600,1020 1020,1710 1950,2400 2460,2640
the part here is| a
|接收到的数据包的十六进制，

439
00:13:28,680 --> 00:13:31,050
0,390 390,840 870,1080 1080,1380 1650,2370
hex dump of the {}

440
00:13:31,860 --> 00:13:33,690
0,150 150,240 240,660 660,1170 1320,1830
of the received packet| and
|你可以看到，

441
00:13:33,810 --> 00:13:35,160
0,270 270,390 390,1020 1080,1230 1230,1350
you can see,| we can
|我们可以跟随以太网报头，

442
00:13:35,160 --> 00:13:37,080
0,300 300,720 720,1290 1290,1470 1470,1920
actually follow along with the

443
00:13:37,710 --> 00:13:40,470
0,540 540,1020 1110,1680 1710,2100 2100,2760
Ethernet header,| there's these first
|前 48 位或 6 个字节是广播地址，全是 f ，

444
00:13:40,710 --> 00:13:42,510
0,510 510,1140 1140,1410 1410,1470 1470,1800
{} 48 bits or six

445
00:13:42,510 --> 00:13:45,030
0,660 1020,1170 1170,1230 1230,2070 2070,2520
bytes is a broadcast address,

446
00:13:45,030 --> 00:13:46,740
0,360 360,1020 1050,1200 1200,1500 1500,1710
all fs| and all fs
|全是 f 的以太网地址是广播到本地网络上的所有主机（的地址）。

447
00:13:46,740 --> 00:13:48,390
0,420 420,750 750,870 870,1560 1560,1650
Ethernet address is broadcast to

448
00:13:48,390 --> 00:13:49,740
0,240 240,330 330,930 1050,1260 1260,1350
all the hosts on the

449
00:13:49,740 --> 00:13:51,240
0,240 240,750
local network.|
|

450
00:13:51,240 --> 00:13:54,000
0,90 90,570 600,1080 1080,1650 2040,2760
The next 48 bits is
接下来的 48 位是发送主机的以太网地址，

451
00:13:54,120 --> 00:13:57,060
0,240 240,750 750,1620 1830,2370 2370,2940
the sending hosts Ethernet address|
|

452
00:13:57,060 --> 00:13:58,340
0,570
which
我们不能告诉你高位的含义，

453
00:13:58,400 --> 00:14:00,140
0,660 960,1140 1140,1200 1200,1320 1320,1740
{} you know we can't

454
00:14:00,350 --> 00:14:02,300
0,630 630,870 870,1140 1140,1470 1470,1950
necessarily tell anything about although

455
00:14:02,630 --> 00:14:04,400
0,210 210,300 300,570 570,1200 1410,1770
{} the high bits mean,|
|

456
00:14:04,550 --> 00:14:05,720
0,180 180,390 390,540 540,660 660,1170
in fact, this was generated
实际上，这是我们在 QEMU 中由 xv6 生成的，

457
00:14:05,720 --> 00:14:07,760
0,510 870,1260 1260,1440 1440,1740 1770,2040
by {xv6 -} we're under

458
00:14:07,760 --> 00:14:09,050
0,270 270,540 540,720 720,1020 1020,1290
{QEMU -},| so no real
|所以没有真正的网卡，

459
00:14:09,050 --> 00:14:10,580
0,240 240,390 390,960 1020,1260 1260,1530
NIC was involved,| so it's
|所以它实际上不是一个制造商编号，而是 QEMU 编造的。

460
00:14:10,580 --> 00:14:12,500
0,240 270,780 780,840 840,1590 1590,1920
not actually a manufacturer number

461
00:14:12,500 --> 00:14:14,420
0,480 480,1170 1170,1350 1350,1680 1680,1920
appears something that {QEMU -}

462
00:14:14,420 --> 00:14:15,360
0,270 270,480
makes up.|
|

463
00:14:15,650 --> 00:14:17,210
0,420 780,990 990,1140 1140,1260 1260,1560
{} And then the next
然后接下来的 16 位，接下来的 2 个字节是类型，

464
00:14:17,210 --> 00:14:19,070
0,570 570,990 990,1080 1080,1530 1650,1860
16 bits, the next two

465
00:14:19,070 --> 00:14:21,060
0,540 540,690 690,810 810,1440
bytes is the type,|
|

466
00:14:21,060 --> 00:14:22,080
0,120 120,240 240,690 690,960 960,1020
it's the Ethernet type of
它是数据包的以太网类型，

467
00:14:22,080 --> 00:14:23,010
0,90 90,450 450,540 540,720 720,930
the packet,| in this case,
|在这种情况下，它是 0806 ，是一个叫做 ARP 的协议，

468
00:14:23,010 --> 00:14:24,450
0,390 420,690 720,1110 1110,1230 1230,1440
it's {} {0806 - -

469
00:14:24,450 --> 00:14:25,800
0,570 780,990 990,1200 1200,1290 1290,1350
-} {} which is a

470
00:14:25,800 --> 00:14:27,960
0,510 510,840 840,1560 1920,2100 2100,2160
protocol called ARP,| which I'll
|我稍后会谈到这一点。

471
00:14:27,960 --> 00:14:29,070
0,240 240,420 420,540 540,570 570,1110
talk about in a moment.|
|

472
00:14:29,600 --> 00:14:30,760
0,360

473
00:14:30,790 --> 00:14:31,780
0,420 450,570 570,780 780,840 840,990
And the rest of this
其余的东西就是一个 ARP 包的有效载荷，

474
00:14:31,780 --> 00:14:33,180
0,330 330,840
stuff is,

475
00:14:33,400 --> 00:14:35,350
0,210 210,330 330,1380 1500,1830 1830,1950
is the payload of an

476
00:14:35,350 --> 00:14:37,720
0,300 300,930 1230,1830
ARP packet {},|
|

477
00:14:37,840 --> 00:14:38,710
0,120 120,240 240,420 420,630 630,870
we shall also talk about.|
我们也会讲到。|

478
00:14:39,660 --> 00:14:40,710
0,210 210,570 570,780 780,960 960,1050
Any questions about what were
关于我们在这里看到的，有没有什么问题？

479
00:14:40,710 --> 00:14:42,300
0,570 690,900 900,1140 1140,1290 1290,1590
{} we're looking at here?|
|

480
00:14:44,740 --> 00:14:45,910
0,150 150,420 420,630 630,960 960,1170
This well worth trying out
这很值得在你的计算机上试一下，

481
00:14:45,910 --> 00:14:46,960
0,90 90,240 240,330 330,870 930,1050
on your own computer,| if
|如果你想了解网络。

482
00:14:46,960 --> 00:14:48,540
0,120 120,240 240,450 450,1020
you care about networks.|
|

483
00:14:50,000 --> 00:14:53,090
0,660 690,1020 1290,1830 2010,2640 2640,3090
Okay, so the next protocol
好的，下一个与实验相关的协议，

484
00:14:53,090 --> 00:14:54,590
0,240 240,510 570,1230 1230,1350 1350,1500
that's of relevance to the

485
00:14:54,590 --> 00:14:57,020
0,540 540,870 900,1500 1500,1710 1710,2430
lab| and communication over Ethernet
|通过以太网通信的称为 ARP 。

486
00:14:57,200 --> 00:14:59,500
0,150 150,390 390,810
is called arp.|
|

487
00:14:59,500 --> 00:15:00,610
0,240 240,360 360,450 450,840 840,1110
So at the Ethernet level,|
所以，在以太网级别，|

488
00:15:00,610 --> 00:15:01,900
0,180 180,510 510,690 690,810 810,1290
every host has a 48
每台主机都有一个 48 位以太网地址，

489
00:15:01,900 --> 00:15:04,840
0,450 450,1110 1650,1890 1920,2190 2190,2940
Ethernet address,| but for communicating
|但要在互联网上通信，

490
00:15:04,840 --> 00:15:06,070
0,240 240,420 420,870 870,960 960,1230
over the Internet,| it turns
|你需要使用 32 位互联网地址，

491
00:15:06,070 --> 00:15:07,120
0,270 330,570 570,750 750,810 810,1050
out you need to use

492
00:15:07,120 --> 00:15:09,580
0,540 540,1200 1200,1560 1590,2040 2040,2460
a 32 bit Internet address|
|

493
00:15:09,580 --> 00:15:11,200
0,90 90,150 150,450 450,1020 1110,1620
and the reason why Internet
互联网地址不同的原因是，

494
00:15:11,200 --> 00:15:12,580
0,420 420,510 510,930 930,1110 1110,1380
addresses are different is that|
|

495
00:15:13,000 --> 00:15:15,310
0,420 450,930 930,1110 1140,1680 1680,2310
Internet addresses have internal structure
互联网地址的内部结构有 32 位，

496
00:15:15,370 --> 00:15:17,680
0,390 390,870 870,1440 1440,1740 2130,2310
in a 32 bit,| the
|主机 32 位互联网地址，

497
00:15:17,680 --> 00:15:19,690
0,540 540,1020 1020,1200 1200,1560 1560,2010
hosts 32 bit Internet address,|
|

498
00:15:19,870 --> 00:15:21,550
0,210 210,540 540,1020 1080,1440 1440,1680
the high bits are full
高位都是各种线索，

499
00:15:21,550 --> 00:15:22,870
0,90 90,240 240,480 480,570 570,1320
of all kinds of hints|
|

500
00:15:22,900 --> 00:15:24,970
0,570 600,1290 1290,1380 1380,1500 1500,2070
about where in the entire
这个数据包需要去互联网的哪里。

501
00:15:24,970 --> 00:15:26,620
0,540 570,930 930,1290 1290,1560 1560,1650
Internet this packet needs to

502
00:15:26,620 --> 00:15:27,380
0,420
go.|
|

503
00:15:27,380 --> 00:15:28,070
0,210 210,300 300,390 390,510 510,690
And so you can think
所以你可以认为互联网地址是一个高位的网络号，

504
00:15:28,070 --> 00:15:29,090
0,60 60,180 180,570 570,930 930,1020
of an Internet address as

505
00:15:29,090 --> 00:15:30,170
0,270 270,390 390,630 630,900 900,1080
having a high bits a

506
00:15:30,170 --> 00:15:31,880
0,480 480,960 1320,1500 1500,1680 1680,1710
network number,| it's actually a
|实际上要比这复杂一点，

507
00:15:31,880 --> 00:15:32,810
0,150 150,300 300,690 690,780 780,930
little more complex than that,|
|

508
00:15:32,810 --> 00:15:33,800
0,90 90,210 210,600 600,660 660,990
but it's essentially a network
但它本质上是一个网络编号，

509
00:15:33,800 --> 00:15:34,910
0,270 270,450 450,900 900,990 990,1110
number,| every network in the
|互联网中的每个网络都有一个不同的编号，

510
00:15:34,910 --> 00:15:36,800
0,420 690,960 960,1020 1020,1470 1470,1890
Internet has a distinct number|
|

511
00:15:36,800 --> 00:15:38,600
0,360 360,870 870,1200 1200,1320 1320,1800
and routers look at these
路由器查看这些高位和互联网地址，

512
00:15:38,630 --> 00:15:39,470
0,90 90,390 390,660 660,780 780,840
the high bits and the

513
00:15:39,470 --> 00:15:41,720
0,390 390,870 900,1110 1110,1710 1740,2250
Internet address| to decide which
|用来确定需要将数据包转发到哪个路由器或互联网，

514
00:15:41,720 --> 00:15:43,040
0,480 480,600 600,690 690,1140 1140,1320
router and the Internet this

515
00:15:43,040 --> 00:15:44,180
0,330 330,510 510,570 570,690 690,1140
packet needs to be forwarded

516
00:15:44,180 --> 00:15:45,500
0,270 720,990 990,1110 1110,1230 1230,1320
to| {} and then the
|然后互联网地址 IP 地址中的 32 个低位是，

517
00:15:45,500 --> 00:15:47,090
0,270 270,780 780,960 960,1110 1110,1590
low bits in a 32

518
00:15:47,090 --> 00:15:49,280
0,150 150,660 690,1380 1410,1800 1800,2190
bit {} Internet Internet address

519
00:15:49,280 --> 00:15:51,680
0,330 330,870 1050,1590 1620,1950 1950,2400
IP address are| the number
|我们想要在本地网络中交互的主机编号。

520
00:15:51,680 --> 00:15:53,420
0,90 90,420 570,750 750,1110 1140,1740
of that of the host

521
00:15:53,420 --> 00:15:54,410
0,150 150,300 300,360 360,660 660,990
we want to talk to
我们想通过它的本地网络与之交谈。

522
00:15:54,440 --> 00:15:56,700
0,930 990,1260 1260,1530 1530,2100
on its local network.|
|

523
00:15:56,730 --> 00:15:57,840
0,570

524
00:15:57,900 --> 00:15:58,950
0,210 210,360 360,420 420,750 750,1050
But when a packet finally
但是当数据包最终到达时，

525
00:15:58,950 --> 00:16:01,900
0,870 1440,1770 1770,2340
arrives { -},|
|

526
00:16:01,990 --> 00:16:03,520
0,300 300,570 570,780 780,1200 1200,1530
and when the Internet packet
当互联网数据包到达以太网时，

527
00:16:03,520 --> 00:16:05,590
0,510 510,750 1050,1620 1710,1920 1920,2070
arrives at Ethernet,| we need
|我们需要方法在给出的 32 位 IP 地址上，

528
00:16:05,590 --> 00:16:06,940
0,210 210,480 480,960 960,1170 1170,1350
some way to give in

529
00:16:06,940 --> 00:16:09,040
0,210 240,870 870,1080 1080,1470 1470,2100
on 32 bit IP address,|
|

530
00:16:09,190 --> 00:16:10,900
0,570 570,750 750,870 870,1500 1500,1710
figure out the 48 bit
找出那个主机的 48 位以太网地址。

531
00:16:11,020 --> 00:16:13,270
0,510 510,1200 1230,1350 1350,1560 1560,2250
Ethernet address of that host.|
|

532
00:16:14,510 --> 00:16:17,030
0,660 840,1080 1080,1560 1830,2070 2070,2520
And the way the Internet
互联网这样做的方法是使用动态解析协议，

533
00:16:17,030 --> 00:16:18,110
0,330 330,420 420,630 630,930 930,1080
chooses to do that is

534
00:16:18,110 --> 00:16:19,760
0,120 120,270 270,420 480,1170 1170,1650
to have a dynamic resolution

535
00:16:19,760 --> 00:16:22,040
0,780 990,1380 1380,1470 1470,1830 1830,2280
protocol,| kind of request response
|一种称为 ARP 的请求响应协议，用于地址解析协议，

536
00:16:22,040 --> 00:16:24,290
0,450 450,810 810,1230 1230,1530 1560,2250
protocol called ARP, for address

537
00:16:24,290 --> 00:16:26,150
0,720 720,1380 1530,1680 1680,1740 1740,1860
resolution protocol| and the way
|考虑这一点的方法是，

538
00:16:26,150 --> 00:16:26,960
0,120 120,300 300,540 540,660 660,810
to think about it is

539
00:16:26,960 --> 00:16:29,690
0,240 630,1110 1200,1710 1710,2250 2280,2730
that| {} when a IP
|当 IP 数据包到达路由器时，

540
00:16:29,690 --> 00:16:30,980
0,330 330,660 660,720 720,780 780,1290
packet arrives at a router|
|

541
00:16:30,980 --> 00:16:31,900
0,210 210,540
or its
或者它需要由主机发送，

542
00:16:31,900 --> 00:16:32,710
0,210 210,300 300,390 390,660 660,810
needs to be sent by

543
00:16:32,710 --> 00:16:34,510
0,60 60,750 810,1320 1350,1500 1500,1800
a host| to a host
|发往同一局域网上的主机，

544
00:16:34,510 --> 00:16:35,290
0,180 180,450 450,540 540,690 690,780
that's known to be on

545
00:16:35,290 --> 00:16:36,700
0,90 90,300 300,840 900,1230 1230,1410
the same LAN local area

546
00:16:36,700 --> 00:16:40,570
0,480 660,1170 1170,1800 1830,2520 2550,3870
network,| the sender first broadcasts
|发送者首先在局域网上广播一个 ARP 数据包，

547
00:16:40,570 --> 00:16:42,250
0,180 180,390 390,990 1140,1380 1380,1680
on that LAN, an ARP

548
00:16:42,250 --> 00:16:44,110
0,570 690,1020 1020,1260 1290,1770 1770,1860
packet,| that's a request that
|请求谁拥有这个 IP 地址，

549
00:16:44,110 --> 00:16:46,300
0,480 510,900 900,1410 1440,1770 1770,2190
says whoever has whoever owns

550
00:16:46,300 --> 00:16:48,640
0,180 180,540 540,1020 1110,1560 1560,2340
this IP address,| please respond
|请回复你的 48 位以太网地址，

551
00:16:48,670 --> 00:16:50,530
0,180 180,360 360,990 990,1320 1320,1860
with your 48 Ethernet address|
|

552
00:16:50,590 --> 00:16:52,330
0,450 450,810 810,960 960,1350 1350,1740
and assuming that host exists
如果主机存在并打开，

553
00:16:52,330 --> 00:16:54,070
0,150 150,420 420,840 1380,1590 1590,1740
is turned on,| it will
|它将使用 ARP 响应数据包进行响应。

554
00:16:54,070 --> 00:16:56,410
0,600 600,1140 1200,1380 1380,1800 1830,2340
respond with an ARP response

555
00:16:56,410 --> 00:16:57,180
0,390
packet.|
|

556
00:16:57,510 --> 00:16:59,310
0,450 780,1080 1140,1650 1650,1740 1740,1800
{} And this is the
这是 ARP 数据包的格式，

557
00:16:59,310 --> 00:17:00,630
0,540 540,600 600,660 660,1170 1200,1320
format of the packet of

558
00:17:00,630 --> 00:17:02,070
0,90 90,300 300,690 870,1260 1260,1440
an ARP packet,| the way
|它实际显示的方式是在以太网数据包内部，

559
00:17:02,070 --> 00:17:03,900
0,330 630,930 930,1290 1290,1560 1560,1830
it actually shows up is

560
00:17:03,900 --> 00:17:06,120
0,510 510,600 630,1110 1110,1470 1680,2220
inside an Ethernet packet| and
|所以你实际上会看到的是，

561
00:17:06,120 --> 00:17:07,170
0,300 300,480 480,600 600,690 690,1050
so what you would actually

562
00:17:07,170 --> 00:17:09,210
0,750 1050,1260 1260,1350 1350,1740 1740,2040
see| and the network is
|网络首先是 48 位以太网报头，

563
00:17:09,240 --> 00:17:11,490
0,600 600,690 690,1170 1170,1650 2010,2250
first the Ethernet header,| which
|有 48 位源地址，

564
00:17:11,490 --> 00:17:13,350
0,240 240,510 570,1320 1320,1470 1470,1860
has the 48 bit source

565
00:17:13,350 --> 00:17:15,090
0,450 450,570 570,990 990,1140 1140,1740
field,| {} 48 bit destination
|48 位目的地址，

566
00:17:15,090 --> 00:17:16,240
0,720
field,|
|

567
00:17:16,240 --> 00:17:18,550
0,240 240,870 870,1410 1410,1950 2130,2310
its destination source type,| so
它的目的源类型，|这就是以太网报头。

568
00:17:18,550 --> 00:17:19,720
0,90 90,150 150,240 240,690 690,1170
this is the Ethernet header.|
|

569
00:17:20,850 --> 00:17:23,220
0,360 360,540 540,930 1410,1860 2190,2370
{} And then, {} from
然后，从以太网的角度来看，

570
00:17:23,220 --> 00:17:24,390
0,60 60,360 360,570 570,660 660,1170
the Ethernet point of view,|
|

571
00:17:24,630 --> 00:17:26,280
0,150 150,330 330,450 450,1140 1290,1650
the rest is payload {},|
其余的是有效载荷，|

572
00:17:26,280 --> 00:17:28,620
0,180 180,750 1320,1530 1530,1890 1950,2340
but actually in the Ethernet
但其实以太网有效载荷是 ARP 数据包，

573
00:17:28,620 --> 00:17:30,210
0,300 300,510 510,750 750,1170 1200,1590
payload is ARP packet,| which
|它具有这些字段，

574
00:17:30,210 --> 00:17:33,600
0,780 810,1290 1290,2250
has these fields,|
|

575
00:17:33,630 --> 00:17:35,010
0,360 360,570 570,900 900,1110 1110,1380
boom boom boom right after
紧跟在以太网报头之后。

576
00:17:35,010 --> 00:17:36,240
0,150 150,750
the Ethernet

577
00:17:36,380 --> 00:17:37,790
0,360 360,810 960,1200 1200,1290 1290,1410
{} header.| And the way
|而接收主机知道数据包的方式是，

578
00:17:37,790 --> 00:17:38,990
0,120 120,540 540,810 810,1110 1110,1200
the receiving host knows on

579
00:17:38,990 --> 00:17:40,400
0,240 240,660 750,1050 1050,1170 1170,1410
our packet is| by looking
|通过查看这个类型字段，

580
00:17:40,400 --> 00:17:41,840
0,90 90,300 300,630 630,1200 1290,1440
at this type field,| and
|如果是 0806 ，

581
00:17:41,840 --> 00:17:43,040
0,90 90,450 450,840 840,960 960,1200
if it's {0806 - -

582
00:17:43,040 --> 00:17:46,100
0,660 930,1410 1410,1800 1950,2490 2490,3060
-},| that's the agreed on
|那就是 ARP 的以太网协议编号，

583
00:17:46,220 --> 00:17:47,540
0,270 270,390 390,780 780,1140 1140,1320
Ethernet {} protocol number for

584
00:17:47,540 --> 00:17:49,010
0,450 660,870 870,990 990,1080 1080,1470
ARP| and then the receiving
|然后接收主机软件知道，

585
00:17:49,010 --> 00:17:49,970
0,210 210,510 510,660 660,870 870,960
host software would know| to
|将这个包交给 ARP 协议处理代码。

586
00:17:49,970 --> 00:17:51,320
0,240 240,390 390,780 780,930 930,1350
hand this packet to its

587
00:17:51,890 --> 00:17:52,860
0,540
ARP

588
00:17:52,890 --> 00:17:55,420
0,240 270,720 720,1470 1500,2040
{} protocol processing code.|
|

589
00:17:55,960 --> 00:17:58,030
0,450 450,570 570,960 960,1740 1830,2070
What's in these packets| and
这些包里有什么，|这里有一些东西，

590
00:17:58,030 --> 00:17:58,810
0,150 150,210 210,360 360,480 480,780
there's a bunch of junk

591
00:17:58,810 --> 00:18:00,070
0,270 270,420 420,840 840,1170 1170,1260
here| that basically amounts to
|表示我有一个互联网地址，

592
00:18:00,070 --> 00:18:02,860
0,690 930,1470 1470,1740 1740,2340 2370,2790
saying I have an Internet

593
00:18:02,890 --> 00:18:04,280
0,870
address,|
|

594
00:18:04,280 --> 00:18:05,000
0,150 150,330 330,390 390,630 630,720
I want to turn it
我想把它变成以太网地址，

595
00:18:05,000 --> 00:18:06,830
0,210 210,330 330,720 720,1530 1560,1830
into an Ethernet address,| please
|如果你拥有这个互联网地址，请回复，

596
00:18:06,830 --> 00:18:08,510
0,570 570,720 720,900 900,1380 1470,1680
respond if you own this

597
00:18:08,510 --> 00:18:11,300
0,330 330,810 1230,1680 1950,2250 2250,2790
Internet address,| {} and then,
|然后，这些字段保存互联网和以太网地址，

598
00:18:11,720 --> 00:18:12,820
0,570
{}

599
00:18:13,050 --> 00:18:16,000
0,540 540,1350 1380,1980 1980,2370
these fields hold the

600
00:18:16,210 --> 00:18:19,780
0,690 750,990 1020,1770 1800,2640 3000,3570
Internet and Ethernet addresses {},|
|

601
00:18:19,960 --> 00:18:21,490
0,210 210,780 780,1050 1050,1140 1140,1530
of whatever host is sending
由这个 ARP 数据包的主机发送的，

602
00:18:21,490 --> 00:18:22,420
0,180 180,360 360,600 600,750 750,930
this ARP packet| and that's
|这可以计算出[]用来构建动态列表，

603
00:18:22,420 --> 00:18:23,350
0,180 180,300 300,660 660,840 840,930
enough to figure out the

604
00:18:23,350 --> 00:18:25,480
0,600 660,1050 1050,1170 1170,1500 1500,2130
[] whose to build dynamically

605
00:18:25,480 --> 00:18:28,240
0,750 1800,2130 2310,2550 2550,2670 2670,2760
tables,| that tell them the
|告诉它们以太网和 IP 地址之间的对应关系。

606
00:18:28,240 --> 00:18:30,220
0,810 810,1080 1110,1590 1590,1710 1710,1980
correspondence between Ethernet and IP

607
00:18:30,220 --> 00:18:31,360
0,720
addresses.|
|

608
00:18:32,600 --> 00:18:34,910
0,660 990,1560 1560,1680 1680,1830 1830,2310
{} Again, we can use
同样，我们可以使用 tcpdump 来查看这些数据包经过，

609
00:18:34,940 --> 00:18:36,560
0,330 330,840 840,1170 1170,1350 1350,1620
{} {tcpdump -} in order

610
00:18:36,560 --> 00:18:38,750
0,630 810,1230 1230,1650 1650,1830 1830,2190
to {} see these packets

611
00:18:38,750 --> 00:18:41,420
0,120 120,600
go by,|
|

612
00:18:41,420 --> 00:18:42,500
0,300 300,570 570,660 660,900 900,1080
highly likely to see them
如果你运行 tcpdump ，很可能会看到它们，

613
00:18:42,500 --> 00:18:43,700
0,150 150,270 270,450 450,870 870,1200
if you run {tcpdump -},|
|

614
00:18:43,910 --> 00:18:47,390
0,1140 1260,1950 2250,2940 2970,3090 3090,3480
here's {} again a {tcpdump
这又是一个来自实验的 tcpdump ，

615
00:18:47,390 --> 00:18:49,580
0,330 330,510 510,930 930,1680 1800,2190
-} that taken from the

616
00:18:49,610 --> 00:18:52,040
0,960 1560,1740 1740,1980 1980,2130 2130,2430
lab,| it turns out that
|在实验里，

617
00:18:52,490 --> 00:18:53,750
0,120 120,240 240,630 630,990 990,1260
in the lab,| you know
|xv6 最终会与模拟的以太网协议交互，

618
00:18:53,840 --> 00:18:55,640
0,330 330,480 480,630 630,1260 1530,1800
your {xv6 - -} will

619
00:18:55,640 --> 00:18:58,940
0,180 180,420 450,1320 1620,2160 2340,3300
end up talking a simulated

620
00:18:58,940 --> 00:19:01,040
0,330 330,510 510,1020 1080,1440 1440,2100
to, but talking Ethernet protocol|
|

621
00:19:01,310 --> 00:19:03,410
0,330 330,660 660,960 960,1470 1470,2100
and sending IP packets through
通过模拟以太网协议发送 IP 数据包，

622
00:19:03,470 --> 00:19:05,420
0,690 720,960 960,1050 1050,1590 1590,1950
Ethernet through a simulated Ethernet

623
00:19:05,420 --> 00:19:07,430
0,480 540,810 810,1170 1170,1740 1740,2010
protocol,| with whatever host you're
|在你运行 QEMU 的任何主机上运行。

624
00:19:07,430 --> 00:19:08,660
0,330 330,630 630,750 750,900 900,1230
running {QEMU -} {on -}.|
|

625
00:19:09,390 --> 00:19:10,620
0,210 210,480 510,930 930,1020 1020,1230
And so when you want
所以，你可以看到这些 ARP 报文，

626
00:19:10,800 --> 00:19:11,790
0,300 330,630 630,720 720,870 870,990
you'll actually be able to

627
00:19:11,790 --> 00:19:14,070
0,540 540,930 990,1230 1230,1830 1830,2280
see these ARP exchanges,| between
|在 xv6 和你们的主机之间，

628
00:19:14,070 --> 00:19:15,780
0,210 210,360 360,1050 1320,1530 1530,1710
{xv6 - -} and your

629
00:19:15,780 --> 00:19:17,520
0,660 810,1440 1440,1530 1530,1650 1650,1740
host| and so what we're
|我们在这里看到的是

630
00:19:17,520 --> 00:19:20,520
0,300 300,750 750,1230 1860,2250 2430,3000
seeing here is| {} my
|我的主机想知道我的 xv6 的 IP 地址，

631
00:19:20,520 --> 00:19:23,310
0,870 1050,1620 1710,2310 2310,2640 2640,2790
host {} wants knows the

632
00:19:23,310 --> 00:19:24,540
0,420 420,780 780,870 870,1020 1020,1230
IP address of my {xv6

633
00:19:24,540 --> 00:19:26,310
0,150 150,750 870,1260 1290,1590 1590,1770
- -}| and wants to
|想要知道它在 QEMU 模拟的局域网中的以太网地址。

634
00:19:26,610 --> 00:19:27,720
0,300 300,420 420,690 690,810 810,1110
wants to figure out its

635
00:19:27,750 --> 00:19:29,640
0,480 480,1050 1050,1230 1230,1380 1380,1890
Ethernet address on the LAN

636
00:19:29,640 --> 00:19:31,740
0,150 150,420 420,660 660,1500 1620,2100
that {QEMU -} simulates.| And
|第二个包是我的 xv6 ，

637
00:19:31,830 --> 00:19:33,880
0,330 330,690 690,1140 1170,1590
this second packet is

638
00:19:33,940 --> 00:19:35,800
0,270 270,570 570,720 720,1410 1620,1860
my {xv6 - -}| and
|你可以看到生成的代码是我的 xv6 看到了这个请求，

639
00:19:35,800 --> 00:19:36,640
0,150 150,240 240,420 420,510 510,840
you can see the code

640
00:19:36,640 --> 00:19:37,960
0,270 270,750 750,870 870,1080 1080,1320
that generates is my {xv6

641
00:19:37,960 --> 00:19:39,220
0,150 150,660 660,780 780,1110 1110,1260
- -} has seen this

642
00:19:39,220 --> 00:19:41,680
0,600 810,1800 1800,1980 2070,2310 2310,2460
request,| realize that it's the
|意识到它是请求中 IP 地址的所有者，

643
00:19:41,680 --> 00:19:42,910
0,360 360,420 420,540 540,930 930,1230
owner of the IP address

644
00:19:42,910 --> 00:19:44,050
0,60 60,120 120,750 900,1050 1050,1140
in the request| and is
|并且正在发回响应，

645
00:19:44,050 --> 00:19:46,390
0,270 270,450 450,540 540,1290 1770,2340
sending back the response,| {tcpdump
|tcpdump 可以很好地解析出 ARP 数据包中的字段，

646
00:19:46,390 --> 00:19:48,100
0,180 180,330 330,810 810,1350 1350,1710
-} is nicely parsed out

647
00:19:48,130 --> 00:19:49,090
0,120 120,570 570,660 660,750 750,960
the fields in the ARP

648
00:19:49,090 --> 00:19:50,290
0,210 210,390 390,660 660,780 780,1200
packet| and printed them here,|
|并打印在这里，|

649
00:19:50,710 --> 00:19:51,660
0,540

650
00:19:52,020 --> 00:19:53,280
0,180 180,270 270,600 660,1140 1140,1260
and I think this is
我想这是发送者的 IP 地址，

651
00:19:53,280 --> 00:19:56,250
0,120 120,1050 1050,1380 1410,2040 2040,2970
the {sender's -} IP address,|
|

652
00:19:56,760 --> 00:19:58,470
0,600 720,960 960,1080 1080,1230 1230,1710
and this is the {},|
这是，|

653
00:19:58,530 --> 00:19:59,620
0,480
sorry,
抱歉，这是发送者的 IP 地址，

654
00:20:00,340 --> 00:20:01,570
0,420 420,510 510,630 630,990 990,1230
this is the sender's IP

655
00:20:01,570 --> 00:20:03,820
0,450 450,870 870,990 990,1350 1740,2250
address,| this is the {}
|这是发送者感兴趣的 IP 地址，

656
00:20:03,820 --> 00:20:04,960
0,330 330,600 600,750 750,840 840,1140
IP address that the sender

657
00:20:04,960 --> 00:20:06,880
0,120 120,630 630,1050 1440,1680 1680,1920
is interested in| and those
|这些东西大概会放在这里和这里，

658
00:20:06,880 --> 00:20:08,920
0,210 240,1020 1020,1380 1380,1920 1920,2040
would presumably going here and

659
00:20:08,920 --> 00:20:11,620
0,540 600,1290 1350,2040 2100,2550 2550,2700
here| {} and this is
|这是一个响应，

660
00:20:11,620 --> 00:20:14,060
0,120 120,1200 1260,1950
a response {}|
|

661
00:20:15,430 --> 00:20:17,360
0,390 390,600 600,900 900,1410
{} with the {}
是具有这个 IP 地址的所有者的以太网地址，

662
00:20:17,990 --> 00:20:20,600
0,480 480,1020 1020,1650 1950,2160 2160,2610
Ethernet address of the owner

663
00:20:20,600 --> 00:20:21,770
0,180 180,330 330,660 660,1020 1020,1170
of this IP address,| and
|并且这个以太网地址可能最终在这个字段中，

664
00:20:21,770 --> 00:20:22,960
0,630
this

665
00:20:22,960 --> 00:20:26,240
0,330 330,750 750,1200 1260,2220
{} Ethernet address probably

666
00:20:27,140 --> 00:20:27,890
0,210 210,300 300,480 480,570 570,750
end up being in this

667
00:20:27,890 --> 00:20:29,240
0,420 540,870 870,960 960,1080 1080,1350
field,| and if we're clever
|如果我们足够聪明，

668
00:20:29,240 --> 00:20:30,200
0,210 210,300 300,450 450,630 630,960
enough,| we can pick apart
|我们可以把这些数据包拆开，看看其中的一些字段，

669
00:20:30,200 --> 00:20:31,400
0,180 180,660 660,780 780,1020 1020,1200
these packets and see some

670
00:20:31,400 --> 00:20:33,050
0,60 60,270 270,810 1020,1470 1470,1650
of these fields,| {} as
|如我们所知，这个部分是以太网报头，

671
00:20:33,050 --> 00:20:35,240
0,120 120,450 450,870 870,1620
we know, this part

672
00:20:35,410 --> 00:20:38,240
0,900 1290,1680 1680,2220
{} is the

673
00:20:38,520 --> 00:20:41,010
0,420 420,990 1020,1860 1890,2130 2130,2490
Ethernet header,| destination Ethernet address,
|目的以太网地址，源以太网地址和数据包类型 0806 ，

674
00:20:41,010 --> 00:20:43,180
0,270 270,600 600,990 990,1320
source Ethernet address and

675
00:20:43,300 --> 00:20:44,920
0,270 270,810 840,1290 1290,1440 1440,1620
packet type {0806 - -

676
00:20:44,920 --> 00:20:46,900
0,570 900,1380
-} {},|
|

677
00:20:47,020 --> 00:20:48,960
0,390 390,1410
working backwards,|
向后看，|

678
00:20:49,300 --> 00:20:52,510
0,480 540,1290 1290,1650 1650,2160 2610,3210
{} this is the tip
这是 tip 字段，

679
00:20:52,510 --> 00:20:53,650
0,330 330,450 450,540 540,690 690,1140
field,| which is the IP
|它是发送者想要查找以太网地址的 IP 地址，

680
00:20:53,650 --> 00:20:55,240
0,360 360,480 480,570 570,1050 1050,1590
address that the sender wants

681
00:20:55,240 --> 00:20:56,470
0,120 120,330 330,420 420,840 840,1230
to find the Ethernet address

682
00:20:56,470 --> 00:20:58,810
0,330 390,840 1440,1620 1620,1980 2100,2340
for| and if you pick
|如果你把这个拆开，

683
00:20:58,810 --> 00:21:00,460
0,150 150,510 510,660 660,1050 1050,1650
this apart,| there's one byte,
|这里有一个字节，每个 IP 地址有四个字段，

684
00:21:01,010 --> 00:21:01,850
0,270 270,450 450,690 690,750 750,840
{} for each of the

685
00:21:01,850 --> 00:21:04,250
0,480 480,1560 1800,1980 1980,2100 2100,2400
four fields of the IP

686
00:21:04,250 --> 00:21:06,650
0,690 720,1020 1020,1470 1770,2160 2160,2400
address,| sorry, it's really looking
|抱歉，它是在找 10.0.2.15 ，

687
00:21:06,650 --> 00:21:08,540
0,120 120,540 540,960 960,1170 1170,1890
for {10.0.2.15 - - -},|
|

688
00:21:08,570 --> 00:21:10,520
0,390 390,660 690,990 990,1560 1560,1950
this is 10 hex, 0
这是十六进制 10 ，十六进制 0 ，十六进制 2 ，十六进制 15 ，

689
00:21:10,520 --> 00:21:12,590
0,420 420,630 630,1050 1050,1500 1500,2070
hex, 2 hex, 15 hex|
|

690
00:21:13,970 --> 00:21:15,740
0,240 240,420 420,810 810,1350
and then there's the
然后是目标以太网地址，它是未知的，

691
00:21:16,340 --> 00:21:18,260
0,600 600,780 870,1170 1170,1740 1740,1920
targets {} Ethernet address which

692
00:21:18,260 --> 00:21:20,000
0,240 270,540 540,1050 1260,1620 1620,1740
is not known| {} and
|然后是发送者的 IP 地址 10.0.2.2 ，

693
00:21:20,000 --> 00:21:21,020
0,150 150,240 240,600 600,690 690,1020
then the {sender's -} IP

694
00:21:21,020 --> 00:21:22,820
0,420 420,810 810,1140 1140,1350 1350,1800
address {10.0.2.2 - - -}|
|

695
00:21:22,940 --> 00:21:25,790
0,600 870,990 990,1950 1980,2310 2310,2850
and the senders Ethernet address|
发送者的以太网地址，|

696
00:21:25,790 --> 00:21:26,780
0,150 150,330 510,720 720,810 810,990
and a bunch of other
这里还有一堆东西在说，

697
00:21:26,780 --> 00:21:28,400
0,300 300,540 540,900 900,1110
junk here saying that|
|

698
00:21:28,600 --> 00:21:30,160
0,180 180,540 540,630 660,1260 1260,1560
we're interested in Ethernet and
我们对以太网和 IP 地址格式感兴趣。

699
00:21:30,160 --> 00:21:32,360
0,600 630,990 990,1590
IP address formats.|
|

700
00:21:33,220 --> 00:21:35,560
0,450 780,1350 1350,1590 1590,2130 2130,2340
And there's this request, this
并且这是请求，这是回应，

701
00:21:35,560 --> 00:21:38,050
0,600 1290,1470 1470,1800 1800,1980 1980,2490
response,| any questions about ARP?|
|关于 ARP ，有什么问题吗？|

702
00:21:39,440 --> 00:21:43,160
0,780 810,1050 1050,1500 1530,2280 2760,3720
Um, yeah question { -},|
嗯，是的，有个问题，|

703
00:21:43,370 --> 00:21:45,110
0,360 360,540 540,720 720,1500 1500,1740
why is it necessary for
为什么发送者需要包括它的 IP 地址，

704
00:21:45,110 --> 00:21:47,330
0,90 90,690 690,1110 1110,1710 1710,2220
the sender to include its

705
00:21:47,540 --> 00:21:49,940
0,660 660,1260 1260,1440 1440,1680 1890,2400
IP address,| if it if
|如果它已经包含在数据包中的以太网地址，

706
00:21:49,970 --> 00:21:52,670
0,540 600,990 990,1410 1410,2040 2490,2700
it's Ethernet addresses already {}

707
00:21:52,670 --> 00:21:54,080
0,480 480,570 570,660 660,1140 1140,1410
included in the packet,| like
|想要响应它，

708
00:21:54,290 --> 00:21:55,700
0,330 330,930 930,1050 1050,1140 1140,1410
to respond to it,| wouldn't
|那么接收者是不是只需要使用那个地址？

709
00:21:55,700 --> 00:21:58,490
0,420 600,1050 1050,1560 1950,2580 2580,2790
it wouldn't the receiver only

710
00:21:58,490 --> 00:22:00,620
0,300 300,510 510,660 660,1170 1830,2130
need using that address.| Yeah,
|是的，我不知道为什么里面会有这些东西，

711
00:22:00,620 --> 00:22:01,370
0,150 150,270 270,360 360,600 600,750
I don't know why that

712
00:22:01,370 --> 00:22:02,330
0,120 120,270 270,600 600,690 690,960
all this stuff's in there,|
|

713
00:22:02,480 --> 00:22:03,560
0,330 330,420 420,660 660,960 960,1080
{} I think if you
我想如果你想的话，

714
00:22:03,560 --> 00:22:04,580
0,300 300,420 420,570 570,690 690,1020
wanted to,| you could strip
|你可以把这件事做得更简单，

715
00:22:04,580 --> 00:22:05,600
0,150 150,420 420,630 630,660 660,1020
this down quite a bit,|
|

716
00:22:05,630 --> 00:22:07,760
0,450 1170,1530 1530,1680 1680,1860 1860,2130
{} you know like that,
比如，发送，

717
00:22:08,420 --> 00:22:10,640
0,480 480,780 1440,1770 1800,2100 2100,2220
sent,| well, okay, maybe the
|好吧，也许答案是，

718
00:22:10,640 --> 00:22:12,740
0,270 270,420 420,690 720,1590
answer is that| this
|这个协议被设计成在网络上使用而不是在以太网，

719
00:22:12,740 --> 00:22:14,810
0,750 750,1170 1170,1860 1860,1950 1950,2070
protocol was designed to be

720
00:22:14,810 --> 00:22:17,240
0,630 630,1200 1500,1980 1980,2280 2280,2430
usable on networks other than

721
00:22:17,270 --> 00:22:18,950
0,570 630,840 840,1290 1440,1590 1590,1680
Ethernet| and so it was
|所以它被设计成相当独立的，

722
00:22:18,950 --> 00:22:20,990
0,330 330,390 390,510 510,840 840,2040
designed to be fairly self-contained,|
|

723
00:22:21,630 --> 00:22:23,040
0,240 240,390 390,510 510,750 750,1410
so that it didn't depend
所以它不依赖于其他任何东西，

724
00:22:23,040 --> 00:22:25,320
0,210 210,900 900,1140 1140,1620
on anything in the,

725
00:22:25,560 --> 00:22:26,970
0,180 180,450 450,540 540,840 840,1410
didn't depend on anything else|
|

726
00:22:27,060 --> 00:22:29,340
0,240 240,810 1350,1620 1620,1860 1860,2280
and therefore the ARP header
所以， ARP 报头具有以太网地址的复制，

727
00:22:29,340 --> 00:22:30,150
0,180 180,240 240,630 630,690 690,810
has a copy of the

728
00:22:30,150 --> 00:22:32,130
0,450 450,1050 1140,1380 1380,1500 1500,1980
Ethernet addresses,| that in fact
|事实上，如果你通过以太网发送 ARP ，

729
00:22:32,160 --> 00:22:33,120
0,150 150,270 270,480 480,630 630,960
if you know you're sending

730
00:22:33,120 --> 00:22:34,740
0,270 270,480 480,990 1050,1200 1200,1620
ARP over Ethernet,| the Ethernet
|以太网数据包还要包含所有的以太网地址，

731
00:22:34,740 --> 00:22:36,180
0,390 450,900 900,1200 1200,1320 1320,1440
packet also has all the

732
00:22:36,180 --> 00:22:37,290
0,390 390,780 780,900 900,1020 1020,1110
Ethernet address,| as you can
|正如你在这里看到的，

733
00:22:37,290 --> 00:22:40,420
0,180 180,660 930,1620 1980,2670
see here,| {} so,
|所以，在以太网上运行 ARP 是多余的，

734
00:22:40,840 --> 00:22:42,220
0,180 180,630 630,690 690,1080 1110,1380
it's redundant to be running

735
00:22:42,220 --> 00:22:43,630
0,150 150,240 240,330 330,990 1200,1410
{ARP -} over Ethernet,| but
|但如果你在其他地方运行 ARP ，

736
00:22:43,630 --> 00:22:44,470
0,330 330,450 450,570 570,630 630,840
maybe if you are running

737
00:22:44,470 --> 00:22:46,720
0,240 240,360 360,660 660,1230 1650,2250
ARP over something else {},|
|

738
00:22:47,110 --> 00:22:48,340
0,180 180,390 390,600 600,1050 1050,1230
you'll need these fields,| because
你需要这些字段，|因为可能还有其他数据包格式，

739
00:22:48,340 --> 00:22:49,900
0,300 300,630 630,840 840,1170 1170,1560
maybe something else packet format,|
|

740
00:22:49,900 --> 00:22:51,340
0,270 270,570 570,930
doesn't have the,
没有包括这些地址。

741
00:22:51,430 --> 00:22:53,140
0,240 240,570 570,870 870,1020 1020,1710
doesn't already include these addresses.|
|

742
00:22:53,350 --> 00:22:54,970
0,600 600,960 960,1200 1200,1470 1470,1620
I see, okay, thank you.|
我明白了，好的，谢谢。|

743
00:22:57,020 --> 00:22:58,070
0,300 300,570 570,750 750,870 870,1050
Oh, sorry, what is that
哦，抱歉，右边那部分是什么？

744
00:22:58,070 --> 00:22:59,990
0,480 510,870 870,990 990,1380 1380,1920
part on the right versions,

745
00:23:00,020 --> 00:23:02,270
0,210 210,630 1290,1710 1710,1950 1950,2250
are you.| Okay, this, this
|好的，这个，这不是很有趣，

746
00:23:02,270 --> 00:23:03,320
0,120 120,330 330,660 660,900 900,1050
is not interesting yet,| but
|但这是这些字节的 ASCII 码解释，

747
00:23:03,320 --> 00:23:05,560
0,210 210,510 600,1770
this is ASCII

748
00:23:05,900 --> 00:23:08,400
0,810 810,900 900,1170 1170,2010
interpretation of these bytes,|
|

749
00:23:08,650 --> 00:23:10,580
0,480 750,1320
so, well,
这个点对应没有 ASCII 码的字节，

750
00:23:10,920 --> 00:23:13,020
0,150 150,390 540,1140 1140,1350 1350,2100
the {} dot here corresponds

751
00:23:13,020 --> 00:23:15,260
0,390 1110,1290 1290,1650
to you know

752
00:23:15,260 --> 00:23:17,060
0,150 150,510 780,1290 1290,1650 1650,1800
{ -} a byte that

753
00:23:17,060 --> 00:23:19,100
0,180 180,420 420,840 840,1530 1680,2040
has no ASCII equivalent,| and
|我猜这个可能是 52 或 55 ，

754
00:23:19,100 --> 00:23:20,780
0,1020 1020,1140 1140,1290 1290,1590 1590,1680
this I guess somewhere in

755
00:23:20,780 --> 00:23:22,640
0,450 450,1110 1110,1230 1230,1500 1500,1860
here, 52 or {55 -}

756
00:23:22,640 --> 00:23:25,340
0,570 840,1500 1500,1800 1800,2400 2400,2700
probably,| 52 probably {R -}
|在 ASCII 码中， 52 可能是 R ， 55 可能是 U ，

757
00:23:25,340 --> 00:23:27,350
0,600 600,930 930,1020 1020,1380 1380,2010
and 55 is probably U

758
00:23:27,950 --> 00:23:29,300
0,150 150,720 960,1140 1140,1260 1260,1350
in ASCII,| so this would
|所以，这会更有趣，

759
00:23:29,300 --> 00:23:30,350
0,120 120,330 330,750 750,960 960,1050
be more interesting| when we
|当我们开始发送包含 ASCII 文本的数据包时，

760
00:23:30,350 --> 00:23:32,390
0,300 300,840 1350,1800 1800,1890 1890,2040
start sending packets that have

761
00:23:32,390 --> 00:23:33,650
0,480 480,780 780,1050 1050,1140 1140,1260
actual ASCII text in them,|
|

762
00:23:33,650 --> 00:23:34,840
0,270 270,600
rather than
而不是二进制字段。

763
00:23:35,120 --> 00:23:37,190
0,660 840,1230 1260,1620 1620,1800 1800,2070
binary fields.| Okay I see,
|好的，我明白了，谢谢。

764
00:23:37,190 --> 00:23:39,780
0,330 330,1200 1560,2070
thank you.| Yes.|
|好的。|

765
00:23:40,970 --> 00:23:41,870
0,300 300,420 420,540 540,810 810,900
Okay, and I'm showing you
好的，我给你看这个，

766
00:23:41,870 --> 00:23:42,800
0,150 150,390 390,510 510,750 750,930
this,| because you'll see these
|因为你会在实验里看到这些包。

767
00:23:42,800 --> 00:23:44,440
0,450 450,510 510,600 600,1110
packets in the lab.|
|

768
00:23:47,830 --> 00:23:49,620
0,570 630,1140
Okay, {}
好吧，有件事我想。

769
00:23:50,820 --> 00:23:52,230
0,480 510,780 780,990 990,1080 1080,1410
actually, there's something I wanted

770
00:23:52,230 --> 00:23:54,060
0,210 210,750
to {}.|
|

771
00:23:54,690 --> 00:23:56,280
0,660

772
00:23:57,100 --> 00:24:01,180
0,330 1740,3360
Well, there's
好的，我有件事想确认一下，

773
00:24:01,210 --> 00:24:01,900
0,300 300,330 330,450 450,510 510,690
something I want to make

774
00:24:01,900 --> 00:24:03,130
0,360 360,480 480,600 600,720 720,1230
sure,| that you are caught
|你能从这个讨论中获得，

775
00:24:03,370 --> 00:24:04,810
0,120 120,630 630,750 750,1230 1230,1440
{} in this discussion| and
|这是嵌套协议和嵌套报头的格式化数据包的[习惯]，

776
00:24:04,810 --> 00:24:07,750
0,480 480,720 750,1650 1650,2100 2550,2940
that's the [habit] in {}

777
00:24:08,170 --> 00:24:11,860
0,630 630,1560 1620,2010 2040,2730 2730,3690
formatting packets of nesting protocols

778
00:24:11,860 --> 00:24:15,400
0,480 510,1350 1350,2010 2010,2370 3150,3540
and nesting headers,| so so,
|所以我们刚才看到一个数据包，以太网报头和以太网有效载荷，

779
00:24:15,430 --> 00:24:16,780
0,570 570,660 660,870 870,1020 1020,1350
what we just saw was

780
00:24:16,780 --> 00:24:19,000
0,180 210,690 690,1080 1080,1560 1560,2220
a packet that Ethernet header

781
00:24:19,630 --> 00:24:21,100
0,300 300,630 630,1140 1140,1200 1200,1470
and Ethernet payload,| the first
|以太网有效负载的第一部分是 ARP 报头，

782
00:24:21,100 --> 00:24:22,420
0,180 180,240 240,300 300,780 780,1320
part of the Ethernet payload

783
00:24:22,420 --> 00:24:23,800
0,570 660,930 930,1050 1050,1170 1170,1380
was you know an {ARP,header

784
00:24:23,800 --> 00:24:25,040
0,690
-},|
|

785
00:24:25,040 --> 00:24:25,910
0,180 180,300 300,390 390,690 690,870
and as it happens {ARP
剩下的部分是 ARP 有效载荷，

786
00:24:25,910 --> 00:24:28,130
0,240 240,420 420,780 780,1380 1770,2220
-} {you,know} remaining payload,| but
|但是还有其他的，

787
00:24:28,160 --> 00:24:29,540
0,240 240,390 390,990 1050,1230 1230,1380
there are other,| what we'll
|我们稍后会看到更复杂的结构，

788
00:24:29,540 --> 00:24:30,470
0,210 210,300 300,360 360,780 780,930
see in a moment is

789
00:24:30,470 --> 00:24:31,850
0,240 240,360 360,870 870,1320 1320,1380
much more complicated structures {},|
|

790
00:24:31,850 --> 00:24:33,020
0,150 150,240 240,360 360,720 720,1170
which {in -} Ethernet packet
在以太网数据包中包含 IP 数据包，

791
00:24:33,140 --> 00:24:34,910
0,420 420,810 810,900 900,1290 1290,1770
that contains an IP packet|
|

792
00:24:35,120 --> 00:24:36,950
0,480 480,900 900,990 990,1320 1320,1830
and inside the IP packet
在 IP 包内部是 UDP 包，

793
00:24:36,980 --> 00:24:38,450
0,330 330,420 420,570 570,1320 1320,1470
is a UDP packet| and
|UDP 是另一种可以在 IP 上运行的协议，

794
00:24:38,450 --> 00:24:40,790
0,690 1050,1500 1500,1590 1590,1860 1860,2340
so UDP is another protocol

795
00:24:40,790 --> 00:24:41,480
0,90 90,180 180,270 270,480 480,690
that you can run over

796
00:24:41,480 --> 00:24:42,860
0,600 660,990 990,1140 1140,1290 1290,1380
IP,| {} so there's a
|所以这里有一个 UDP 报头，

797
00:24:42,860 --> 00:24:45,110
0,150 150,570 570,1230 1530,1710 1710,2250
{UDP -} header,| it also,|
|它也是，|

798
00:24:48,220 --> 00:24:49,480
0,150 150,390 390,660 660,1170 1170,1260
you know not necessarily have
不一定要理解这些首字母缩写，

799
00:24:49,480 --> 00:24:50,830
0,90 90,540 540,690 690,1140 1140,1350
to understand these acronyms yet,|
|

800
00:24:50,830 --> 00:24:52,660
0,210 810,960 960,1110 1110,1350 1350,1830
but as {UDP -} header,|
但作为 UDP 报头，|

801
00:24:52,690 --> 00:24:53,920
0,210 210,330 330,600 600,900 900,1230
a {UDP -} packet also
UDP 数据包也包含报头和有效载荷，

802
00:24:53,920 --> 00:24:55,180
0,180 180,780 780,1110 1110,1200 1200,1260
has a header and a

803
00:24:55,180 --> 00:24:57,850
0,720 870,1500 1500,1830 1890,2340 2340,2670
payload| {} and there's times
|有时会在 UDP 中携带另一个协议，

804
00:24:57,850 --> 00:24:58,900
0,210 210,420 420,480 480,780 780,1050
when used to carry another

805
00:24:58,900 --> 00:25:00,190
0,420 420,870 870,960 960,1080 1080,1290
protocol inside {UDP - -},|
|

806
00:25:00,190 --> 00:25:01,810
0,210 210,450 450,780 780,930 930,1620
so for example the domain
比如域名系统，

807
00:25:01,810 --> 00:25:03,280
0,300 300,990
name system,|
|

808
00:25:03,280 --> 00:25:05,440
0,360 360,720 720,1200 1200,2100 2100,2160
has yet another format of
包含另一种适合在 UDP 内部的数据包格式定义，

809
00:25:05,440 --> 00:25:07,060
0,390 390,840 840,990 990,1230 1230,1620
packet define that fits inside

810
00:25:07,060 --> 00:25:07,990
0,60 60,450 450,600 600,750 750,930
{UDP -},| so what you
|所以你看到的是，

811
00:25:07,990 --> 00:25:10,480
0,330 330,480 480,750 1920,2340 2340,2490
see is| that hosts are
|主机发送数据包将构建一个数据包，

812
00:25:10,480 --> 00:25:12,190
0,420 420,930 930,1140 1140,1620 1620,1710
sending packets will build up

813
00:25:12,190 --> 00:25:13,900
0,90 90,600 690,960 960,1350 1350,1710
a packet,| the DNS software
|DNS 软件会说我想通过 UDP 发送数据包，

814
00:25:13,900 --> 00:25:14,500
0,90 90,270 270,390 390,540 540,600
will say I want to

815
00:25:14,500 --> 00:25:15,460
0,240 240,270 270,630 630,840 840,960
send a packet over {UDP

816
00:25:15,460 --> 00:25:16,620
0,150 150,690
- -},|
|

817
00:25:16,650 --> 00:25:18,210
0,420 420,810 810,960 960,1470 1470,1560
{the,UDP} software will prepare the
UDP 软件会准备 UDP 报头，

818
00:25:18,210 --> 00:25:19,980
0,90 90,420 420,1020 1140,1470 1470,1770
{UDP -} header,| we send
|我们通过 IP 发送，

819
00:25:19,980 --> 00:25:21,660
0,180 180,390 390,840 840,990 990,1680
that over IP,| the IP
|IP 软件会添加 IP 报头，

820
00:25:21,660 --> 00:25:22,770
0,420 420,570 570,750 750,1050 1050,1110
software will {prepend -} an

821
00:25:22,770 --> 00:25:24,870
0,450 450,930 1020,1230 1230,1740 1740,2100
IP header,| the Ethernet software
|以太网软件会添加以太网报头，

822
00:25:24,870 --> 00:25:26,430
0,150 150,330 330,780 840,1350 1350,1560
will {prepend -} Ethernet header,|
|

823
00:25:26,430 --> 00:25:28,200
0,120 120,540 540,840 840,1020 1020,1770
and gradually build up packets
并在发送时逐渐在软件中建立数据包。

824
00:25:28,650 --> 00:25:30,390
0,390 540,720 720,990 1020,1560 1560,1740
in in that software when

825
00:25:30,390 --> 00:25:31,800
0,150 150,510 510,720 720,1110 1110,1410
it's sending.| And similarly when
|类似地，当系统接收到数据包时，

826
00:25:31,920 --> 00:25:34,140
0,420 420,690 690,1140 1140,1800 2040,2220
{} system receives packets,| it
|它首先获得整个数据包，

827
00:25:34,140 --> 00:25:35,220
0,210 210,360 360,450 450,630 630,1080
first gets the whole packet,|
|

828
00:25:35,220 --> 00:25:37,740
0,1080 1110,1230 1230,1590 1590,2010
inspects the first header
检查第一个报头，注意到是以太网，

829
00:25:37,740 --> 00:25:38,910
0,90 90,390 390,810 810,990 990,1170
and notice Ethernet,| because it
|因为它从以太网卡接收数据，

830
00:25:38,910 --> 00:25:40,410
0,330 330,420 420,660 690,1110 1110,1500
receives it from Ethernet NIC,|
|

831
00:25:40,980 --> 00:25:42,810
0,510 510,990 990,1440 1440,1650 1650,1830
checksum validity, strips off this
校验有效性，去除这个报头，

832
00:25:42,810 --> 00:25:43,890
0,450 540,780 780,930 930,990 990,1080
header| to look at the
|查看下一个报头，

833
00:25:43,890 --> 00:25:45,180
0,270 270,630 930,1080 1080,1200 1200,1290
next header,| there will be
|这里总有一个类型，

834
00:25:45,180 --> 00:25:47,340
0,90 90,630 630,1050 1080,1230 1230,2160
a type this you always

835
00:25:47,430 --> 00:25:49,290
0,450 450,840 840,1440 1440,1710 1800,1860
a type field| or in
|或者在这种情况下，有一个协议字段，

836
00:25:49,320 --> 00:25:51,150
0,360 360,540 540,600 600,1200 1200,1830
this case, the protocol field,|
|

837
00:25:52,210 --> 00:25:53,920
0,150 150,390 390,480 480,1140 1170,1710
that tells the software what
告诉软件在以太网报头之后希望发生什么。

838
00:25:53,920 --> 00:25:55,810
0,120 120,840 990,1350 1350,1440 1440,1890
to expect after the Ethernet

839
00:25:55,810 --> 00:25:56,700
0,330
header.|
|

840
00:25:56,730 --> 00:25:57,870
0,450 480,600 600,780 780,870 870,1140
{} So there's a type
所以，有一个类型字段表示 IP 或 ARP ，

841
00:25:57,870 --> 00:25:59,370
0,180 180,300 300,660 660,1140 1140,1500
field that indicates IP versus

842
00:25:59,370 --> 00:26:01,110
0,510 750,990 990,1290 1290,1380 1380,1740
ARP,| so this the software
|所以，软件将查看每个报头，

843
00:26:01,110 --> 00:26:03,630
0,150 630,1530 1530,1650 1650,1800 1800,2520
will look at each header,|
|

844
00:26:03,780 --> 00:26:06,510
0,660 660,960 1800,2310 2310,2400 2400,2730
validate it, strip it off,
验证它，剥离它，获取下一个报头，

845
00:26:06,510 --> 00:26:08,360
0,360 360,450 450,750 750,1380
revealing the next header,|
|

846
00:26:08,360 --> 00:26:09,360
0,180 180,420
you know
检查报头，解释它，理解它，再把它去掉，

847
00:26:09,360 --> 00:26:10,440
0,180 180,390 390,570 570,660 660,1080
check that header, {} interpret

848
00:26:10,440 --> 00:26:11,130
0,150 150,390 390,480 480,570 570,690
it, figure out what it

849
00:26:11,130 --> 00:26:12,540
0,330 330,600 600,660 660,990 1020,1410
means, strip it off,| revealing
|暴露出下一层，并将其传递给下一层软件。

850
00:26:12,540 --> 00:26:13,500
0,90 90,330 330,540 540,870 870,960
the next and hand it

851
00:26:13,500 --> 00:26:14,250
0,150 150,240 240,330 330,570 570,750
on to the next layer

852
00:26:14,250 --> 00:26:16,920
0,60 60,540 1230,1650 2070,2610 2610,2670
of software.| I'll talk a
|我会更多地讨论这一点，

853
00:26:16,920 --> 00:26:17,880
0,120 120,270 270,510 510,780 780,960
bit more about this,| but
|但这是一种看待嵌套数据报头的通用方式。

854
00:26:18,540 --> 00:26:19,560
0,420 420,600 600,750 750,930 930,1020
this is a sort of

855
00:26:19,560 --> 00:26:21,690
0,930 960,1350 1350,1440 1440,1770 1770,2130
universal way of looking at

856
00:26:22,110 --> 00:26:25,480
0,570 1020,2100 2400,2820
{} nested packet

857
00:26:25,480 --> 00:26:26,680
0,660
headers.|
|

858
00:26:31,370 --> 00:26:32,750
0,300 300,450 450,540 540,930 930,1380
Alright, so the Ethernet packet,
好的，以太网数据包，以太网报头，

859
00:26:32,840 --> 00:26:35,870
0,180 180,510 510,1020 1260,1950 2850,3030
the Ethernet header,| {} is
|足以将数据包发送到局域网上的主机，

860
00:26:35,870 --> 00:26:37,310
0,270 270,360 360,840 870,1170 1170,1440
enough to get {} packet

861
00:26:37,310 --> 00:26:39,440
0,120 120,210 210,690 720,1320 1620,2130
to a host on {}

862
00:26:40,120 --> 00:26:42,640
0,390 390,600 600,1260 1290,1830 2250,2520
local area network { -},|
|

863
00:26:42,640 --> 00:26:44,200
0,240 240,720 720,1080 1230,1470 1470,1560
when especially when and if
特别是当你想在本地发送 IP 数据包时，

864
00:26:44,200 --> 00:26:44,740
0,120 120,270 270,330 330,480 480,540
you want to send an

865
00:26:44,740 --> 00:26:47,170
0,330 330,720 720,1380 1710,2280 2280,2430
IP packet locally,| {} you
|你可以使用 ARP ，

866
00:26:47,170 --> 00:26:48,700
0,120 120,300 300,750 750,990 1140,1530
can use ARP,| but {}
|但 IP 是更通用的，

867
00:26:48,700 --> 00:26:50,110
0,390 390,570 570,1020 1050,1260 1260,1410
IP is used much more

868
00:26:50,110 --> 00:26:51,760
0,420 420,840 840,1080
generally,| IP that
|IP 是一种协议层，

869
00:26:51,760 --> 00:26:53,020
0,390 480,720 720,810 810,1200 1200,1260
a sort of layer of

870
00:26:53,020 --> 00:26:54,970
0,120 120,810 810,1020 1140,1710 1710,1950
the protocol,| that helps you
|帮助你将数据包传送到互联网的任何位置，

871
00:26:54,970 --> 00:26:56,020
0,270 270,330 330,630 630,960 960,1050
deliver a packet anywhere in

872
00:26:56,020 --> 00:26:57,550
0,120 120,630 630,960 960,1200 1200,1530
the Internet,| based on IP
|基于 IP 地址。

873
00:26:57,550 --> 00:26:58,800
0,660
addresses.|
|

874
00:26:59,150 --> 00:27:00,830
0,420 840,1230 1230,1380 1380,1590 1590,1680
{} And so this is
所以，这是 IP 数据包的格式，

875
00:27:00,830 --> 00:27:02,540
0,90 90,840 1140,1290 1290,1350 1350,1710
the format of an IP

876
00:27:02,540 --> 00:27:04,040
0,360 360,750 750,1110 1110,1260 1260,1500
packet,| again taken you can
|再次，你可以在我们给你的 net.h 源码中找到它，

877
00:27:04,220 --> 00:27:05,810
0,510 510,630 630,960 990,1350 1350,1590
find it in {net.h -

878
00:27:05,810 --> 00:27:06,650
0,270 270,360 360,420 420,750 750,840
-} at the source we

879
00:27:06,650 --> 00:27:08,810
0,150 150,390 720,1170 1560,1920 1920,2160
give you| {} and over
|通过以太网[]，

880
00:27:08,810 --> 00:27:10,370
0,420 420,540 540,1020 1080,1440 1440,1560
Ethernet {[] -},| {} the
|你可以看到，这是，

881
00:27:10,370 --> 00:27:11,600
0,120 120,270 270,510 510,810 810,1230
way you see, this is,|
|

882
00:27:11,630 --> 00:27:12,640
0,480

883
00:27:12,700 --> 00:27:14,260
0,150 150,240 240,630 630,1110 1110,1560
in an Ethernet packet with
在以太网数据包中，有目的地址、源地址和类型，

884
00:27:14,380 --> 00:27:17,860
0,450 450,1710 1740,2670 2700,3060 3060,3480
a destination source and type

885
00:27:17,860 --> 00:27:19,820
0,510 720,1350
of {},|
|

886
00:27:20,720 --> 00:27:22,700
0,480 480,780 780,1080 1080,1560 1560,1980
Ethernet type equals {0800 -
以太网类型等于 0800 ，

887
00:27:22,820 --> 00:27:24,620
0,390 390,1080 1320,1590 1590,1710 1710,1800
- -}| and then the
|然后是 IP 报头，以及 IP 有效载荷，

888
00:27:24,620 --> 00:27:26,160
0,420 420,1020
IP header,

889
00:27:27,260 --> 00:27:29,180
0,150 150,330 330,720 720,1440
and then IP payload,|
|

890
00:27:33,280 --> 00:27:35,260
0,1140 1140,1350 1350,1620 1620,1650 1650,1980
when you send a packet
当你将数据包发送到远程网络时，

891
00:27:35,260 --> 00:27:36,670
0,120 120,300 300,720 720,1290 1290,1410
to a distant network,| {you,know}
|在世界的另一边的网络，

892
00:27:36,670 --> 00:27:37,420
0,120 120,180 180,420 420,690 690,750
on the other side of

893
00:27:37,420 --> 00:27:38,920
0,90 90,600 630,780 780,1230 1230,1500
the world,| the IP header
|IP 报头传递，

894
00:27:38,920 --> 00:27:42,280
0,240 240,690 690,1440 2370,2910 2940,3360
gets passed along,| this Ethernet
|在离开本地以太网后，以太网报头被剥离，

895
00:27:42,280 --> 00:27:43,570
0,180 180,360 360,750 750,1050 1050,1290
header gets stripped off after

896
00:27:43,570 --> 00:27:46,120
0,90 90,660 690,840 840,1500 1740,2550
you leave the local Ethernet,|
|

897
00:27:46,150 --> 00:27:47,260
0,600 600,630 630,780 780,930 930,1110
maybe a new one gets
也许在路由数据包的每一跳上都会放上一个新的，

898
00:27:47,260 --> 00:27:48,500
0,270 270,570 570,780
put on it

899
00:27:48,500 --> 00:27:50,000
0,120 120,330 330,900 960,1260 1260,1500
for each hop that your

900
00:27:50,000 --> 00:27:51,470
0,330 330,450 450,930 990,1320 1320,1470
packet is routed,| but the
|但是 IP 报头保持不变，

901
00:27:51,470 --> 00:27:52,880
0,360 360,570 570,900 900,1320 1320,1410
IP header stays basically the

902
00:27:52,880 --> 00:27:54,680
0,570 900,1110 1110,1380 1380,1590 1590,1800
same,| the whole way from
|从你的计算机上的原始源主机，

903
00:27:54,680 --> 00:27:56,690
0,330 660,1140 1140,1260 1260,1590 1590,2010
the [] the original source

904
00:27:56,690 --> 00:27:59,120
0,570 660,1140 1140,1680 1890,2340 2340,2430
host {in,your} computer,| all the
|一直到目的主机，

905
00:27:59,120 --> 00:28:00,290
0,120 120,240 240,300 300,900 900,1170
way to the destination host,|
|

906
00:28:00,290 --> 00:28:01,260
0,540
this
这个报头具有全局意义，

907
00:28:01,260 --> 00:28:03,810
0,330 330,690 750,1290 1290,2100 2100,2550
header has global significance,| {where,as}
|而以太网报头仅用于单个局域网，

908
00:28:03,810 --> 00:28:05,190
0,60 60,480 480,930 960,1140 1140,1380
the Ethernet header is really

909
00:28:05,190 --> 00:28:08,020
0,240 240,570 570,720 720,1290
only used for each,

910
00:28:08,210 --> 00:28:09,350
0,330 330,390 390,660 660,930 930,1140
for a single local area

911
00:28:09,350 --> 00:28:10,460
0,510 690,840 840,930 930,1050 1050,1110
network,| so there has to
|所以，这里必须有足够的信息

912
00:28:10,460 --> 00:28:11,540
0,90 90,300 300,810 810,990 990,1080
be enough information here| to
|将数据包一路传送到互联网的另一端。

913
00:28:11,540 --> 00:28:12,410
0,300 300,360 360,630 630,810 810,870
carry a packet all the

914
00:28:12,410 --> 00:28:14,000
0,270 270,630 870,1110 1110,1350 1350,1590
way to the far side

915
00:28:14,000 --> 00:28:15,440
0,60 60,150 150,600 870,1260 1260,1440
of the Internet.| And the
|对于我们的目的来说，关键字段是，

916
00:28:15,440 --> 00:28:17,400
0,510 510,1500
critical fields

917
00:28:17,780 --> 00:28:20,020
0,270 270,570 570,1170 1170,1530
for our purposes| really
|这个数据包格式中的三个非常有趣的字段，

918
00:28:20,100 --> 00:28:21,660
0,390 390,660 660,1020 1020,1500 1500,1560
three very interesting fields in

919
00:28:21,660 --> 00:28:24,390
0,180 180,600 960,1230 1230,1740 2220,2730
this packet {} format {},|
|

920
00:28:25,610 --> 00:28:27,890
0,450 510,1590 1590,1980 1980,2160 2160,2280
the destination field, which is
目的地址字段，是主机的 32 位 IP 地址，

921
00:28:27,890 --> 00:28:29,720
0,90 90,540 540,720 720,1050 1050,1830
the 32 bit IP address

922
00:28:29,750 --> 00:28:31,310
0,210 210,330 330,990 1290,1500 1500,1560
of the host,| that we
|我们将数据包发送到，

923
00:28:31,310 --> 00:28:32,060
0,150 150,210 210,390 390,480 480,750
want to send the packet

924
00:28:32,060 --> 00:28:33,110
0,150 150,330 330,840 840,900 900,1050
to,| in particular in its
|特别是在它的高位，

925
00:28:33,110 --> 00:28:33,980
0,210 210,540 540,690 690,810 810,870
high bits,| it's going to
|其中包含网络编号，用于帮助路由器，

926
00:28:33,980 --> 00:28:35,990
0,330 660,1410 1410,1770 1770,1860 1860,2010
have network numbers in it

927
00:28:35,990 --> 00:28:37,790
0,180 180,420 420,1080 1350,1650 1650,1800
that'll help routers| and when
|当数据包被递送时，

928
00:28:37,790 --> 00:28:38,900
0,60 60,270 270,390 390,870 870,1110
the packet is delivered,| this
|这个 p 协议字段告诉目的地主机如何处理数据包，

929
00:28:38,900 --> 00:28:41,390
0,570 870,1350 1350,1860 2160,2280 2280,2490
p protocol field will tell

930
00:28:41,390 --> 00:28:43,400
0,90 90,660 660,1110 1440,1680 1680,2010
the destination host {} what

931
00:28:43,400 --> 00:28:44,270
0,90 90,210 210,360 360,450 450,870
to do with the packet,|
|

932
00:28:44,540 --> 00:28:45,380
0,390 390,540 540,630 630,690 690,840
{you,know} what to do with
在它剥离 IP 报头之后下一步该如何处理。

933
00:28:45,380 --> 00:28:46,820
0,60 60,390 390,660 660,780 1020,1440
it next after it strips

934
00:28:46,820 --> 00:28:50,880
0,150 150,270 270,570 570,930
off the IP header.|
|

935
00:28:51,590 --> 00:28:53,660
0,210 210,270 270,390 390,1050 1050,2070
If you ever seen a
如果你见过麻省理工的 IP 地址，

936
00:28:53,870 --> 00:28:57,080
0,780 780,1200 1200,1980 1980,2370
MIT IP address {},|
|

937
00:28:57,350 --> 00:28:59,600
0,540 540,750 750,1530 1530,1800 2100,2250
{} you'll see, well there's
你会看到有几个不同的，

938
00:28:59,600 --> 00:29:00,740
0,60 60,300 300,540 540,870 870,1140
a couple different ones,| but
|但是如果你看到互联网地址以 18 开头，

939
00:29:00,770 --> 00:29:02,210
0,180 180,570 570,690 690,930 930,1440
for example if you see

940
00:29:02,390 --> 00:29:03,600
0,660
{

941
00:29:04,810 --> 00:29:06,280
0,450 450,810 810,1050 1050,1320 1320,1470
-} Internet address starting with

942
00:29:06,280 --> 00:29:09,380
0,780 990,1440 1530,2490
18,| {} this
|在过去的几年里，事情发生了变化，

943
00:29:09,530 --> 00:29:10,430
0,180 180,390 390,570 570,660 660,900
{} the things have actually

944
00:29:10,430 --> 00:29:11,390
0,390 390,450 450,540 540,750 750,960
changed in the last couple

945
00:29:11,390 --> 00:29:13,160
0,300 300,510 570,930 1170,1650 1650,1770
years,| but {} this for
|但在很长一段时间里，这是麻省理工的网络编号，

946
00:29:13,160 --> 00:29:14,840
0,60 60,390 390,1110 1140,1410 1410,1680
a long time {} was

947
00:29:14,840 --> 00:29:17,570
0,210 450,1200 1200,1680 1680,2190 2220,2730
the network number of MIT|
|

948
00:29:17,570 --> 00:29:19,250
0,120 120,300 300,750 750,1080 1080,1680
and so most hosted MIT
所以，大多数托管麻省理工的 IP 地址的高位字节是 18 ，

949
00:29:19,280 --> 00:29:20,810
0,210 210,360 390,870 870,1350 1350,1530
would have IP addresses whose

950
00:29:20,810 --> 00:29:22,910
0,270 270,810 840,1080 1080,1650 1860,2100
high byte was 18| and
|世界各地的路由器都会有一张表，

951
00:29:22,910 --> 00:29:24,050
0,330 330,480 480,720 720,840 840,1140
routers all over the world

952
00:29:24,050 --> 00:29:25,130
0,90 90,270 270,420 420,900 900,1080
would have some table,| they'd
|它们会查到 18 ，

953
00:29:25,130 --> 00:29:26,090
0,180 180,330 330,720 720,840 840,960
look up 18| and say
|然后说，我知道如何路由这个数据包到麻省理工又近一步。

954
00:29:26,090 --> 00:29:27,200
0,420 540,810 810,900 900,1020 1020,1110
aha I know how to

955
00:29:27,200 --> 00:29:28,520
0,210 210,390 390,780 810,1050 1050,1320
route this packet one step

956
00:29:28,520 --> 00:29:30,060
0,420 420,510 510,1110
closer to MIT.|
|

957
00:29:32,080 --> 00:29:33,120
0,510

958
00:29:34,490 --> 00:29:35,600
0,360 360,540 540,780 780,990 990,1110
So let me {}, let
所以，让我再次展示 tcpdump 的输出，

959
00:29:35,600 --> 00:29:37,370
0,90 90,480 480,750 750,1230 1260,1770
me show you again {tcpdump

960
00:29:37,370 --> 00:29:40,140
0,450 480,1260 1320,2280
-} output {},|
|

961
00:29:40,350 --> 00:29:41,460
0,330 330,600 600,870 870,1020 1020,1110
again actually taken from the
同样取自实验，其中包括 IP 报头。

962
00:29:41,460 --> 00:29:43,760
0,510 540,660 660,1830
lab, that includes

963
00:29:45,420 --> 00:29:50,700
0,990 1650,2280 2280,2700 4290,4530 4530,5280
{} IP header.| Okay, so
|好的，我们可以解析这个数据包，

964
00:29:50,730 --> 00:29:51,860
0,600
{}

965
00:29:52,820 --> 00:29:53,930
0,120 120,210 210,510 510,660 660,1110
we can parse this packet,|
|

966
00:29:54,350 --> 00:29:55,670
0,780 780,840 840,960 960,1170 1170,1320
because it was sent over
因为它是通过以太网发送的，

967
00:29:55,670 --> 00:29:57,650
0,450 510,1140 1140,1440 1440,1860 1860,1980
the Ethernet,| it starts with
|它以以太网报头开始。

968
00:29:57,650 --> 00:29:59,160
0,150 150,510 510,960
an Ethernet header.|
|

969
00:30:04,390 --> 00:30:05,840
0,780

970
00:30:06,240 --> 00:30:08,480
0,390 390,720 720,1140 1140,1530
It actually one {},|
它是一，|

971
00:30:08,720 --> 00:30:09,290
0,90 90,240 240,330 330,480 480,570
I think it's kind of
我认为这些 tcpdump 是有问题的，

972
00:30:09,290 --> 00:30:10,790
0,300 300,420 420,630 630,1140 1140,1500
wrong with these {tcpdump -}|
|

973
00:30:10,880 --> 00:30:12,020
0,150 150,540 540,990 990,1080 1080,1140
with these packets that are
这些生成的包，

974
00:30:12,020 --> 00:30:13,580
0,630 630,960
generated and,|
|

975
00:30:14,870 --> 00:30:16,070
0,360 360,480 480,720 720,1050 1050,1200
now that I'm seeing it,
现在我看它，我不确定问题出在哪里，

976
00:30:16,070 --> 00:30:16,670
0,120 120,270 270,420 420,510 510,600
I'm not sure what the

977
00:30:16,670 --> 00:30:19,130
0,360 360,630 780,1590 1680,2190 2190,2460
problem is,| {} they should
|它们不应该开头，

978
00:30:19,130 --> 00:30:20,360
0,180 180,600 600,720 720,930 930,1230
not start with all,| these
|以太网报头不应该以全部 f 开始，

979
00:30:20,360 --> 00:30:21,830
0,390 390,780 780,1080 1080,1350 1350,1470
Ethernet headers shouldn't start with

980
00:30:21,830 --> 00:30:23,500
0,240 240,630
all fs,|
|

981
00:30:23,500 --> 00:30:25,480
0,600 600,1230 1440,1650 1650,1890 1890,1980
{because,it's,broadcast} address,| that cause the
因为它是广播地址，|这会导致数据包到达每台主机，

982
00:30:25,480 --> 00:30:26,260
0,270 270,330 330,420 420,540 540,780
packet to go to every

983
00:30:26,260 --> 00:30:27,970
0,660 960,1170 1170,1320 1320,1500 1500,1710
host| and you would not
|你不会看到在两台单独的主机之间发送的数据包，

984
00:30:27,970 --> 00:30:29,050
0,270 270,510 510,630 630,720 720,1080
see that for a packet

985
00:30:29,050 --> 00:30:30,790
0,270 270,660 660,840 840,1320 1320,1740
sent between two individual hosts|
|

986
00:30:30,790 --> 00:30:31,810
0,150 150,300 300,480 480,840 870,1020
as this one is on
因为这台主机位于真实网络上，

987
00:30:31,810 --> 00:30:33,190
0,90 90,300 300,750 930,1200 1200,1380
a real network,| there's something
|在 QEMU 的网络实验中我的解决方案中有些东西有点滑稽，

988
00:30:33,190 --> 00:30:34,660
0,300 300,540 540,750 750,870 870,1470
funny going on with my

989
00:30:35,260 --> 00:30:36,430
0,240 240,720 720,780 780,840 840,1170
{} solution to the network

990
00:30:36,430 --> 00:30:38,170
0,330 330,510 510,750 750,1110 1410,1740
lab with {QEMU -},| anyway
|不管怎样，我们有以太网目的地址、以太网源地址，

991
00:30:38,170 --> 00:30:39,880
0,90 90,180 180,420 810,1200 1200,1710
we have the Ethernet destination

992
00:30:39,880 --> 00:30:42,000
0,450 450,780 780,1560
address, Ethernet source

993
00:30:42,420 --> 00:30:44,850
0,810 1050,1530 1530,1650 1650,2040 2040,2430
address| and the Ethernet type
|而以太网类型是 0800 ，

994
00:30:44,850 --> 00:30:46,080
0,120 120,450 450,720 720,900 900,1230
is {0800 - - -}|
|

995
00:30:46,080 --> 00:30:47,160
0,510
is
表示剩余的字节是 IP 数据包，

996
00:30:47,460 --> 00:30:49,500
0,270 270,480 480,690 750,1560 1560,2040
means that the remaining bytes

997
00:30:49,500 --> 00:30:52,360
0,330 360,750 750,1200
are IP packet,|
|

998
00:30:52,360 --> 00:30:54,140
0,510 510,960
{the,IP} packet
IP 数据包报头长度我认为是 20 字节，

999
00:30:54,140 --> 00:30:55,220
0,300 300,540 540,780 780,870 870,1080
{} header length I think

1000
00:30:55,220 --> 00:30:57,680
0,360 360,810 840,1140 1140,1830
it's {} 20 bytes,|
|

1001
00:30:58,320 --> 00:31:00,690
0,900 1050,1290 1290,1440 1440,1620 1620,2370
{} [] find the end,|
找到结尾，|

1002
00:31:01,480 --> 00:31:03,380
0,240 240,1410
two fifteen,|
二，十五，|

1003
00:31:05,670 --> 00:31:06,810
0,240 240,660 660,870 870,930 930,1140
so this must be the
所以这一定是 IP 报头的结尾。

1004
00:31:06,810 --> 00:31:08,280
0,390 390,480 480,600 600,1020 1020,1470
end of the IP header.|
|

1005
00:31:10,900 --> 00:31:12,040
0,600

1006
00:31:12,420 --> 00:31:13,980
0,360 420,840 840,1230 1230,1410 1410,1560
And working backwards, because these
往回看一下，因为这些是我们真正关心的字段，

1007
00:31:13,980 --> 00:31:14,700
0,60 60,150 150,450 450,510 510,720
are the fields, we really

1008
00:31:14,700 --> 00:31:16,890
0,270 270,660 960,1230 1230,1470 1470,2190
care about,| {} the destination
|目的 IP 字段是， a 是 10 ， 10.0.2.2 ，

1009
00:31:16,890 --> 00:31:19,200
0,450 450,990 990,1440
IP field is

1010
00:31:19,290 --> 00:31:20,940
0,270 270,420 420,750 750,1140 1140,1650
a is 10, {10.0.2.2 -

1011
00:31:20,940 --> 00:31:22,460
0,300 300,870
- -},|
|

1012
00:31:22,490 --> 00:31:23,760
0,690

1013
00:31:23,970 --> 00:31:25,380
0,390 390,510 510,630 630,990 990,1410
which is I think the,|
我认为，|

1014
00:31:25,680 --> 00:31:27,300
0,270 270,660 660,960 960,1080 1080,1620
in {QEMU's - -} funny
在 QEMU 中，有趣的模拟网络是

1015
00:31:27,330 --> 00:31:29,400
0,570 570,930 930,1140 1140,1410
simulated network is| the
|我运行 QEMU 的真实计算机的地址，

1016
00:31:29,400 --> 00:31:30,900
0,480 480,600 600,810 810,1080 1080,1500
address of the real computer

1017
00:31:30,900 --> 00:31:32,940
0,300 330,570 570,1080 1080,1410 1620,2040
I'm running QEMU on {},|
|

1018
00:31:32,940 --> 00:31:33,930
0,150 150,270 270,600 600,840 840,990
and then before that is
在这之前是 IP 源地址，是 10.0.2.15，

1019
00:31:33,930 --> 00:31:36,330
0,360 390,1140 1230,1710 1710,2190 2190,2400
this IP source address, which

1020
00:31:36,330 --> 00:31:39,270
0,300 300,690 690,1140 1140,1740 1830,2940
is {10.0.2.15 - - -},|
|

1021
00:31:39,480 --> 00:31:40,780
0,780

1022
00:31:41,130 --> 00:31:42,240
0,240 240,360 360,450 450,870 870,1110
which is the sender, which
是发送方，是 QEMU 的地址，

1023
00:31:42,240 --> 00:31:44,100
0,390 420,720 720,1110 1110,1350 1350,1860
is {QEMU's - -} address|
|

1024
00:31:44,100 --> 00:31:45,260
0,210 210,570
for the,
是 QEMU 内运行的 xv6 的地址，

1025
00:31:45,380 --> 00:31:46,520
0,210 210,390 390,510 510,750 750,1140
for {xv6 - -} basically

1026
00:31:46,520 --> 00:31:48,590
0,210 210,660 660,1050 1320,1620 1620,2070
running inside QEMU| and then
|然后在这之前的这些东西，

1027
00:31:48,740 --> 00:31:50,540
0,270 270,510 510,810 810,1200 1260,1800
this stuff before this, {}

1028
00:31:50,750 --> 00:31:51,830
0,240 240,420 420,600 600,900 900,1080
all this other stuff,| there's
|有一个 16 位的校验和，

1029
00:31:51,830 --> 00:31:54,380
0,90 90,810 810,1080 1080,1920
a sixteen bit checksum,|
|

1030
00:31:54,380 --> 00:31:55,790
0,240 240,630 630,780 780,1350 1350,1410
{} which your software is
你的软件应该检查它，

1031
00:31:55,790 --> 00:31:57,320
0,240 240,330 330,840 960,1200 1200,1530
supposed to check| to realize
|意识到数据包已经损坏，应该丢弃，

1032
00:31:57,320 --> 00:31:57,980
0,120 120,150 150,450 450,540 540,660
that a packet has been

1033
00:31:57,980 --> 00:31:59,690
0,540 540,660 660,810 810,900 900,1710
corrupted and should be discarded,|
|

1034
00:31:59,900 --> 00:32:02,150
0,360 360,840 930,1710 1830,2190 2190,2250
that's this checksum,| theres {}
这就是校验和，|这里有一个字节，

1035
00:32:02,150 --> 00:32:03,500
0,270 270,780
one byte,|
|

1036
00:32:04,000 --> 00:32:05,560
0,360 360,540 540,810 810,1020 1020,1560
alright, mess something up here.|
好的，这里的东西乱了。|

1037
00:32:07,670 --> 00:32:09,020
0,300 300,480 480,900 930,1230 1230,1350
Oh, this is, this is
哦，抱歉，这是 16 位校验和，

1038
00:32:09,020 --> 00:32:10,700
0,510 510,750 750,960 960,1050 1050,1680
16, sorry, this is 16

1039
00:32:10,700 --> 00:32:13,740
0,270 270,960 1200,1590 1590,2460
bit checksum,| this 11
|这个 11 是协议号，这一点特别重要，

1040
00:32:14,150 --> 00:32:16,370
0,660 870,1020 1020,1560 1560,2040 2070,2220
is the protocol number, which

1041
00:32:16,370 --> 00:32:18,080
0,120 120,540 540,960 1020,1410 1410,1710
is particularly important,| 11 hex
|十六进制 11 是 16 加 1 或者 17 ，

1042
00:32:18,080 --> 00:32:19,160
0,90 90,510 510,720 720,960 960,1080
is 16 plus 1 or

1043
00:32:19,160 --> 00:32:20,700
0,990
17,|
|

1044
00:32:20,820 --> 00:32:21,810
0,270 270,450 450,630 630,780 780,990
so that means that this
意味着这是一个 UDP 数据包，

1045
00:32:21,810 --> 00:32:23,940
0,150 150,420 570,750 750,1530
is a UDP packet,|
|

1046
00:32:24,200 --> 00:32:26,750
0,480 480,630 630,840 840,1470 1800,2550
based on that protocol field.|
基于协议字段。|

1047
00:32:28,160 --> 00:32:28,940
0,180 180,330 330,480 480,630 630,780
And then all this other
然后所有这些东西，我们并不关心，

1048
00:32:28,940 --> 00:32:29,630
0,180 180,240 240,360 360,510 510,690
stuff we don't really care

1049
00:32:29,630 --> 00:32:30,440
0,210 210,360 360,570 570,660 660,810
about,| as things like the
|比如数据包的长度。

1050
00:32:30,440 --> 00:32:33,020
0,300 300,390 390,480 480,1140
length of the packet.|
|

1051
00:32:35,020 --> 00:32:37,780
0,150 150,480 480,870 1320,1860 1860,2760
Any questions about IP headers?|
关于 IP 报头，有什么问题吗？|

1052
00:32:43,560 --> 00:32:45,220
0,480 630,1080
Alright, {}
好的，再说一遍，这里的关键是，

1053
00:32:45,440 --> 00:32:46,700
0,330 330,420 420,750 750,1080 1080,1260
again the critical stuff is|
|

1054
00:32:46,700 --> 00:32:48,500
0,300 600,1020 1020,1230 1230,1560 1560,1800
the IP header has the
IP 报头具有 IP 地址的源地址和目的地址，

1055
00:32:48,530 --> 00:32:50,360
0,630 630,1290 1320,1440 1440,1500 1500,1830
IP address of the source

1056
00:32:50,360 --> 00:32:52,610
0,750 840,1230 1230,1380 1380,1830 1830,2250
{and,destination},| and this protocol field
|而这个协议字段告诉目的主机网络堆栈，

1057
00:32:52,610 --> 00:32:53,630
0,120 120,240 240,330 330,750 750,1020
is going to tell the

1058
00:32:54,260 --> 00:32:56,810
0,810 810,1440 1440,1860 1860,2310 2310,2550
destination host's networking stack,| that
|这个分组应该由 UDP 软件处理，

1059
00:32:57,050 --> 00:32:58,670
0,510 510,900 900,1050 1050,1140 1140,1620
this packet should be processed

1060
00:32:58,670 --> 00:33:00,020
0,120 120,360 360,450 450,810 810,1350
by {} {UDP -} software,|
|

1061
00:33:01,390 --> 00:33:03,320
0,180 180,240 240,450 450,1350
which I'll talk about
我现在会谈到这一点。

1062
00:33:03,410 --> 00:33:04,500
0,240 240,510
right now.|
|

1063
00:33:05,040 --> 00:33:07,290
0,420 450,720 720,1110 1710,2040 2040,2250
Okay, the {}, this this
好的，这个 IP 报头，

1064
00:33:07,290 --> 00:33:09,020
0,450 450,1020
IP header,|
|

1065
00:33:09,420 --> 00:33:10,740
0,180 180,840 900,1020 1020,1230 1230,1320
it's enough to get a
它足以将数据包发送到互联网上的任何主机，

1066
00:33:10,740 --> 00:33:12,120
0,420 420,510 510,720 720,1260 1260,1380
packet to any host on

1067
00:33:12,120 --> 00:33:14,250
0,120 120,750 1530,1860 1860,1950 1950,2130
the Internet,| but we want
|但我们想做得更好，

1068
00:33:14,250 --> 00:33:15,150
0,60 60,210 210,510 510,660 660,900
to do better than that,|
|

1069
00:33:15,150 --> 00:33:16,770
0,210 210,780 780,1050 1050,1380 1380,1620
every host was running lots
每台主机都在运行很多需要使用网络的不同程序，

1070
00:33:16,770 --> 00:33:17,700
0,90 90,270 270,330 330,570 570,930
and lots of different programs

1071
00:33:17,700 --> 00:33:18,390
0,120 120,330 330,420 420,600 600,690
that need to use the

1072
00:33:18,390 --> 00:33:20,490
0,510 510,1260 1380,1770 1770,1860 1860,2100
network,| they need to send
|它们需要在网络中发送和接收数据包，

1073
00:33:20,490 --> 00:33:21,420
0,90 90,420 420,810 810,870 870,930
and receive packets in the

1074
00:33:21,420 --> 00:33:22,470
0,300 300,390 390,510 510,600 600,1050
network| and so we need
|所以我们需要一种不在 IP 字段中的方法，

1075
00:33:22,500 --> 00:33:23,730
0,330 330,570 570,780 780,1140 1140,1230
a way that's not in

1076
00:33:23,730 --> 00:33:25,440
0,150 150,420 930,1110 1110,1320 1320,1710
the {}, it's not included

1077
00:33:25,440 --> 00:33:26,670
0,90 90,180 180,510 510,900 960,1230
in the IP field,| in
|为了决定哪个应用程序需要，

1078
00:33:26,670 --> 00:33:28,500
0,270 270,360 360,690 690,960 960,1830
order to decide which application

1079
00:33:30,030 --> 00:33:32,340
0,510 510,960 1080,1440 1440,2100 2100,2310
needs to,| which application on
|应该将包移交给目标主机上的哪个应用程序。

1080
00:33:32,340 --> 00:33:34,020
0,90 90,450 450,990 1020,1320 1320,1680
the target host its package

1081
00:33:34,020 --> 00:33:34,920
0,120 120,180 180,300 300,630 630,900
ought to be handed off

1082
00:33:34,920 --> 00:33:35,500
0,210
to.|
|

1083
00:33:36,830 --> 00:33:39,230
0,390 720,1440 1440,1710 1740,2190 2190,2400
And there's a couple of
有几个协议可以完成这项工作，

1084
00:33:39,230 --> 00:33:41,120
0,720 720,900 1200,1470 1470,1680 1680,1890
protocols that {} do that

1085
00:33:41,120 --> 00:33:42,050
0,420 420,690 690,750 750,840 840,930
job,| one of them is
|一个是相当复杂的 TCP ，

1086
00:33:42,050 --> 00:33:46,440
0,1020 1350,1890 2340,2730 2730,3450
TCP {} quite complex,|
|

1087
00:33:46,630 --> 00:33:48,190
0,450 450,630 630,960 960,1080 1080,1560
{} and {other,is} {UDP -}.|
还有其他是 UDP 。|

1088
00:33:48,220 --> 00:33:49,390
0,450 450,510 510,810 810,990 990,1170
TCP is actually what's used
TCP 主要用于 web 之类的东西，

1089
00:33:49,390 --> 00:33:50,500
0,510 510,660 660,870 870,990 990,1110
mostly for things like the

1090
00:33:50,500 --> 00:33:52,210
0,660 690,990 1140,1560 1560,1650 1650,1710
web| and TCP is a
|TCP 是一种非常复杂的协议，

1091
00:33:52,210 --> 00:33:54,060
0,210 210,630 630,1080 1080,1320
very complex protocol,| that
|它不仅帮助将数据包传送到正确的应用程序，

1092
00:33:54,060 --> 00:33:55,860
0,420 420,1020 1050,1350 1350,1470 1470,1800
not only helps your packet

1093
00:33:55,860 --> 00:33:56,610
0,120 120,450 450,510 510,600 600,750
be delivered to the right

1094
00:33:56,610 --> 00:33:58,350
0,660 690,1050 1050,1290 1290,1470 1470,1740
application,| but also has a
|还有许多东西，比如序列号，

1095
00:33:58,350 --> 00:33:59,940
0,390 390,630 630,990 990,1140 1140,1590
lot of things, like sequence

1096
00:33:59,940 --> 00:34:01,860
0,450 450,570 570,930 960,1230 1410,1920
numbers,| in order to detect
|为了检测丢失的包并重新发送它们，

1097
00:34:01,860 --> 00:34:04,080
0,300 300,870 870,1110 1320,1650 1650,2220
lost packets and {re-transmit -}

1098
00:34:04,080 --> 00:34:05,580
0,330 360,720 720,900 900,1350 1350,1500
them,| make sure packets or
|确保包或数据按顺序而且不间断地传送，

1099
00:34:05,610 --> 00:34:07,590
0,390 390,570 570,1110 1230,1530 1530,1980
data is delivered in order

1100
00:34:07,590 --> 00:34:09,240
0,90 90,450 450,1020 1020,1320 1410,1650
and without gaps,| if in
|防止出现什么问题。

1101
00:34:09,240 --> 00:34:10,920
0,240 240,510 510,750 750,1140 1440,1680
case anything goes wrong.| {UDP
|UDP 是一种简单得多的协议，

1102
00:34:10,920 --> 00:34:12,120
0,300 300,390 390,450 450,810 810,1200
-} is a much simpler

1103
00:34:12,120 --> 00:34:15,240
0,660 780,1200 1590,1920 1920,2160 2160,3120
protocol,| {} that just delivers,|
|它只是传递，|

1104
00:34:15,420 --> 00:34:16,680
0,180 180,360 360,450 450,900 900,1260
{} sort of best effort
尽力而为的传递包到特定应用，

1105
00:34:16,680 --> 00:34:17,940
0,510 510,570 570,660 660,1140 1140,1260
delivery of a packet to

1106
00:34:17,940 --> 00:34:20,160
0,60 60,450 450,1080 1080,1320 1650,2220
a particular application,| but {}
|但是，没有任何纠错，

1107
00:34:20,760 --> 00:34:22,770
0,390 390,690 690,930 930,1680 1680,2010
without any error correction| or
|或者没有任何其他东西，

1108
00:34:22,770 --> 00:34:23,420
0,300
{}

1109
00:34:25,150 --> 00:34:27,220
0,330 330,600 600,900 900,1350 1620,2070
basically without anything else {},|
|

1110
00:34:27,280 --> 00:34:29,530
0,390 390,660 660,990 1020,1440 1440,2250
for us, the critical fields
对我们来说，关键字段是这两个端口号，

1111
00:34:29,590 --> 00:34:31,420
0,390 390,630 630,780 780,1170 1170,1830
are these two port numbers|
|

1112
00:34:31,570 --> 00:34:32,560
0,210 210,270 270,540 540,840 840,990
and the game here is
这里的游戏是，

1113
00:34:32,560 --> 00:34:34,930
0,270 300,750 750,900 900,1860 1890,2370
that,| when your application wants
|当你的应用程序想要发送或接收数据包时，

1114
00:34:34,930 --> 00:34:37,270
0,120 120,390 390,450 450,1320 1650,2340
to send or receive packets,|
|

1115
00:34:37,330 --> 00:34:38,620
0,270 270,600 600,870 900,1080 1080,1290
it uses the what's called
它使用所谓的套接字 API ，

1116
00:34:38,620 --> 00:34:40,620
0,90 90,690 690,1500
the sockets API,|
|

1117
00:34:41,080 --> 00:34:42,360
0,660

1118
00:34:43,280 --> 00:34:44,300
0,360 360,510 510,750 750,840 840,1020
on {Unix -} at any
在 Unix 上，

1119
00:34:44,300 --> 00:34:45,220
0,300
way,|
|

1120
00:34:45,370 --> 00:34:46,120
0,210 210,330 330,450 450,540 540,750
and this is a set
这是一组系统调用，

1121
00:34:46,120 --> 00:34:48,190
0,90 90,420 420,990 1020,1980 1980,2070
of system calls| {where,by} a
|其中进程说，

1122
00:34:48,190 --> 00:34:49,480
0,510 510,720 720,870 870,1110 1110,1290
process can say,| look I'm
|我对寻址到特定端口的数据包感兴趣，

1123
00:34:49,480 --> 00:34:51,430
0,360 360,420 420,1080 1110,1830 1830,1950
interested in packets addressed to

1124
00:34:51,430 --> 00:34:53,020
0,120 120,750 750,1230 1230,1350 1350,1590
a particular port| and it'll
|它会说感兴趣的端口号，

1125
00:34:53,020 --> 00:34:55,870
0,480 1530,1710 1710,1980 1980,2370 2370,2850
say what port numbers interested,|
|

1126
00:34:55,870 --> 00:34:56,800
0,420
sorry,
抱歉，特定的包，

1127
00:34:56,800 --> 00:34:58,510
0,600 600,930 930,1350 1350,1530 1530,1710
packets with particular,| I want
|我要接收具有特定目的端口的数据包，

1128
00:34:58,510 --> 00:34:59,500
0,60 60,450 450,810 810,930 930,990
to receive packets with a

1129
00:34:59,500 --> 00:35:02,140
0,450 450,1170 1170,1590 1800,2340 2400,2640
particular destination port| and the
|操作系统进行系统调用，

1130
00:35:02,140 --> 00:35:02,980
0,360 360,540 540,660 660,810 810,840
operating {system -} make a

1131
00:35:02,980 --> 00:35:04,300
0,300 300,630 630,780
system call,| it
|它在操作系统中设置，返回一个文件描述符，

1132
00:35:05,170 --> 00:35:06,040
0,330 330,540 540,720 720,810 810,870
set this up in the

1133
00:35:06,040 --> 00:35:07,090
0,330 330,630 630,750 750,1020 1020,1050
operating system, will return a

1134
00:35:07,090 --> 00:35:09,850
0,330 330,1110 1290,2010 2250,2580 2580,2760
file descriptor,| {} and every
|每次数据包到达应用程序请求的端口，

1135
00:35:09,850 --> 00:35:11,140
0,120 120,210 210,570 570,1170 1170,1290
time a packet arrives with

1136
00:35:11,140 --> 00:35:12,640
0,180 180,570 570,750 750,1230 1230,1500
the port the application asks

1137
00:35:12,640 --> 00:35:14,560
0,450 780,1260 1290,1470 1470,1770 1770,1920
for,| {} that packet will
|这个数据包将出现在文件描述符上，

1138
00:35:14,560 --> 00:35:16,510
0,720 750,960 960,1050 1050,1260 1260,1950
appear on the file descriptor|
|

1139
00:35:16,510 --> 00:35:17,680
0,150 150,210 210,780 780,960 960,1170
and the application can read
应用程序就可以读取它。

1140
00:35:17,680 --> 00:35:18,480
0,270
it.|
|

1141
00:35:18,920 --> 00:35:22,130
0,420 780,1320 2070,2640 2640,2970 2970,3210
{} And {} the these
这两个端口实际上是两种端口，

1142
00:35:22,130 --> 00:35:23,480
0,420 420,510 510,720 720,990 990,1350
ports are really two kinds

1143
00:35:23,480 --> 00:35:26,810
0,330 630,1290 1290,1860 1890,2610 2610,3330
of ports,| {} {some,are} well-known
|一些是知名端口号，

1144
00:35:26,810 --> 00:35:28,310
0,300 300,690 690,960 1110,1500 1500,1500
port numbers,| like {} I
|比如端口号 53 是 DNS 名称服务器的官方知名普遍同意的端口号，

1145
00:35:28,310 --> 00:35:30,760
0,480 510,840 840,1890
think port 53

1146
00:35:30,760 --> 00:35:32,780
0,300 300,420 420,1440
is the official

1147
00:35:32,930 --> 00:35:35,240
0,450 450,1140 1170,1740 1740,2040 2040,2310
{well-known -} universally agreed port

1148
00:35:35,240 --> 00:35:37,190
0,270 270,660 810,1080 1080,1680 1680,1950
number for a DNS name

1149
00:35:37,190 --> 00:35:38,240
0,420 420,600 600,690 690,870 870,1050
server,| so if you want
|所以，如果你要向 DNS 名称服务器发送请求，

1150
00:35:38,240 --> 00:35:39,110
0,60 60,330 330,450 450,780 780,870
to send a request to

1151
00:35:39,110 --> 00:35:40,520
0,60 60,450 450,600 600,1050 1170,1410
a DNS name server,| you
|你可以通过 dport 53 发送 UDP 包，

1152
00:35:40,520 --> 00:35:41,660
0,90 90,420 420,570 570,810 810,1140
can send into {UDP -}

1153
00:35:41,660 --> 00:35:44,030
0,420 510,1110 1110,1350 1350,1650 1650,2370
packet addressed {dport -} 53,|
|

1154
00:35:44,450 --> 00:35:45,620
0,330 330,390 390,570 570,660 660,1170
there's a bunch of other
还有许多其他知名的端口，

1155
00:35:46,290 --> 00:35:48,540
0,120 120,660 660,1140 1140,1470 1650,2250
{} well-known ports| for commonly
|可以提供普遍可用的服务，使用普遍同意的编号，

1156
00:35:48,540 --> 00:35:51,900
0,360 360,1170 1860,2370 2460,3090 3090,3360
available services with universally agreed

1157
00:35:51,900 --> 00:35:53,850
0,150 150,870 870,1080 1080,1530 1710,1950
on numbers| and then the
|然后剩余的 16 位端口号空间，

1158
00:35:53,850 --> 00:35:55,890
0,450 450,1380 1440,1890 1890,1950 1950,2040
{remainings -} remain of the

1159
00:35:55,890 --> 00:35:58,260
0,480 480,810 1140,1410 1410,1680 1680,2370
16 bit port number space,|
|

1160
00:35:58,380 --> 00:36:00,600
0,510 510,930 960,1530 1530,2010 2040,2220
{} is used for the
用于匿名客户端支持，

1161
00:36:00,600 --> 00:36:02,490
0,180 180,240 240,840 840,1380 1380,1890
sort of anonymous client ends

1162
00:36:02,490 --> 00:36:05,080
0,570 570,750 750,930 1500,2130
support,| so if {}
|所以，如果我想要向 DNS 服务器发送数据包，

1163
00:36:05,260 --> 00:36:06,010
0,270 270,420 420,480 480,690 690,750
I want to send a

1164
00:36:06,010 --> 00:36:07,420
0,360 360,450 450,510 510,930 930,1410
packet to a DNS server,|
|

1165
00:36:07,750 --> 00:36:08,860
0,390 390,600 600,870 870,990 990,1110
it's {dport -} will be
它的 dport 是 53 ，

1166
00:36:08,860 --> 00:36:10,120
0,570 570,810 810,930 930,1050 1050,1260
53, right,| but its {sport
|但它的 sport 是我这边随机选择的数字，

1167
00:36:10,120 --> 00:36:11,470
0,330 330,510 510,780 810,1080 1080,1350
-} will be a more

1168
00:36:11,470 --> 00:36:13,120
0,60 60,270 270,750 750,1140 1140,1650
or less randomly chosen number

1169
00:36:13,120 --> 00:36:15,250
0,180 180,540 540,1230 1440,1950 1950,2130
for my end,| so that
|所以，它与我的应用程序的套接字相关联，

1170
00:36:15,250 --> 00:36:17,590
0,540 810,1590 1590,1680 1680,1740 1740,2340
when that will be associated

1171
00:36:17,590 --> 00:36:20,020
0,120 120,300 300,1440 1470,2160 2220,2430
with my application's socket,| so
|所以，当 DNS 服务器发送回复时，

1172
00:36:20,020 --> 00:36:20,890
0,90 90,240 240,300 300,660 660,870
that when the DNS server

1173
00:36:20,890 --> 00:36:22,240
0,300 300,330 330,930 1050,1260 1260,1350
sends a reply,| it will
|将对其进行寻址，

1174
00:36:22,240 --> 00:36:24,610
0,90 90,750 990,1200 1380,2130 2130,2370
be addressed,| the DNS server
|DNS 服务器会将请求源端口复制到回复的目的端口字段中，

1175
00:36:24,610 --> 00:36:26,560
0,210 360,990 990,1110 1110,1650 1650,1950
will copy the request source

1176
00:36:26,560 --> 00:36:29,080
0,480 660,1080 1080,1320 1350,2190 2190,2520
port into the destination port

1177
00:36:29,080 --> 00:36:30,370
0,330 330,420 420,480 480,1020 1020,1290
field of the reply,| sent
|并将其发回我的机器，

1178
00:36:30,370 --> 00:36:31,690
0,120 120,360 360,450 450,570 570,1320
it back to my machine|
|

1179
00:36:31,930 --> 00:36:32,980
0,240 240,360 360,690 690,810 810,1050
and my machine will use
我的机器将使用这个端口号

1180
00:36:32,980 --> 00:36:34,540
0,210 210,480 480,840 840,1140
this port number| to
|来确定哪个应用程序应该得到响应。

1181
00:36:35,190 --> 00:36:38,010
0,630 630,1050 1080,1560 1560,2490 2580,2820
figure out which application {}

1182
00:36:38,010 --> 00:36:39,460
0,180 180,330 330,420 420,900
should get the reply.|
|

1183
00:36:41,270 --> 00:36:42,320
0,240 240,420 420,480 480,690 690,1050
Okay, so the main function
好的，这里的主要功能是拥有这两个端口号，

1184
00:36:42,320 --> 00:36:43,880
0,420 630,1110 1110,1200 1200,1380 1380,1560
here is to have these

1185
00:36:43,880 --> 00:36:45,350
0,120 120,390 390,1020 1080,1320 1320,1470
two port numbers,| {} in
|为了分发，

1186
00:36:45,350 --> 00:36:48,290
0,270 270,870 1890,2310 2310,2850 2850,2940
order to {} handout,| be
|可以在这台机器上分发各个应用程序的数据包。

1187
00:36:48,290 --> 00:36:49,310
0,120 120,210 210,420 420,540 540,1020
able to {handout -} packets

1188
00:36:49,310 --> 00:36:52,580
0,510 510,1770 2100,2670
individual applications {}

1189
00:36:52,700 --> 00:36:54,320
0,270 270,450 450,1110
on this machine.|
|

1190
00:36:55,900 --> 00:36:56,860
0,270 360,570 570,690 690,750 750,960
So, feel free to ask
所以，请随意提问。

1191
00:36:56,860 --> 00:37:00,130
0,660 1770,2250 2520,2700 2700,2790 2790,3270
questions.| {} I have {tcpdump
|我也有 UDP 的 tcpdump 输出，

1192
00:37:00,130 --> 00:37:02,080
0,270 270,750 750,1170
-} output for

1193
00:37:03,210 --> 00:37:05,040
0,690 690,1200
UDP also,|
|

1194
00:37:05,070 --> 00:37:07,470
0,450 450,750 750,870 870,960 960,2400
again taken from the lab.|
也是从实验里拿来的。|

1195
00:37:08,160 --> 00:37:09,480
0,480 480,660 660,990 990,1110 1110,1320
{} So again we have
同样，我们有一个以太网报头，

1196
00:37:09,480 --> 00:37:10,600
0,510
a

1197
00:37:10,810 --> 00:37:12,880
0,450 510,930 930,1530
{} Ethernet header,|
|

1198
00:37:12,880 --> 00:37:14,740
0,1170
and
20 字节的 IP 报头可能在这里结束，

1199
00:37:14,740 --> 00:37:17,080
0,510 510,990 1080,1920 1920,2160 2160,2340
20 bytes IP header which

1200
00:37:17,080 --> 00:37:19,540
0,330 330,630 630,1110 1380,1740 1740,2460
probably ends here,| {} 11
|11 是 IP 协议号 17 ，也就是 UDP ，

1201
00:37:19,540 --> 00:37:20,600
0,540
is

1202
00:37:20,920 --> 00:37:23,140
0,360 360,750 750,1710 1950,2100 2100,2220
IP protocol 17 which is

1203
00:37:23,140 --> 00:37:23,980
0,90 90,240 240,570 570,720 720,840
{UDP - -},| so the
|所以接收主机知道用 UDP 软件来处理它，

1204
00:37:23,980 --> 00:37:25,480
0,480 480,900 900,1020 1020,1230 1230,1500
receiving host will know to

1205
00:37:25,660 --> 00:37:27,040
0,690 690,840 840,960 960,1230 1230,1380
process it with its {UDP

1206
00:37:27,040 --> 00:37:28,280
0,720
-}

1207
00:37:28,280 --> 00:37:29,620
0,720
software,|
|

1208
00:37:29,840 --> 00:37:33,100
0,570 630,990 990,1920 1920,2670
{} the next {}
接下来的 8 个字节是这里显示的 UDP 报头。

1209
00:37:33,100 --> 00:37:34,980
0,360 360,1260
8 bytes

1210
00:37:36,110 --> 00:37:37,700
0,450 450,720 750,930 930,1260 1260,1590
are the {UDP -} header

1211
00:37:37,700 --> 00:37:38,900
0,210 210,300 300,510 510,750 750,1200
which is shown right here.|
|

1212
00:37:39,740 --> 00:37:41,200
0,240 240,900
And so
那么谁知道这些端口号是什么？

1213
00:37:41,550 --> 00:37:42,450
0,210 210,420 420,510 510,690 690,900
who knows what these port

1214
00:37:42,450 --> 00:37:43,780
0,270 270,750
numbers are?|
|

1215
00:37:45,170 --> 00:37:46,040
0,120 120,270 270,420 420,690 690,870
I mean,| {you,know} this, this
我是说，|这是一个由实验软件生成的数据包，

1216
00:37:46,040 --> 00:37:48,740
0,510 720,1620 1620,1950 1980,2550 2550,2700
is unfortunately a packet is

1217
00:37:48,740 --> 00:37:51,290
0,630 630,1170 1500,1680 1680,1980 1980,2550
generated by the lab software|
|

1218
00:37:51,290 --> 00:37:53,800
0,390 390,780
without any,
任何特殊的号码，

1219
00:37:54,850 --> 00:37:56,350
0,330 330,840 840,1200 1200,1350 1350,1500
any special numbers| and so
|这是恰巧选择的端口号，

1220
00:37:56,350 --> 00:37:57,220
0,180 180,300 300,420 420,630 630,870
this is the port numbers

1221
00:37:57,220 --> 00:37:59,230
0,90 90,330 330,420 420,1050 1710,2010
that happened to choose,| this
|这一定是包的长度，

1222
00:37:59,230 --> 00:37:59,950
0,180 180,240 240,360 360,630 630,720
must be the length of

1223
00:37:59,950 --> 00:38:01,690
0,90 90,570 570,900 900,1200 1200,1740
the packet,| {1b -} is
|1b 是二十多，

1224
00:38:01,960 --> 00:38:04,630
0,420 420,990 1320,1710 1710,1980 1980,2670
twenty something| and {this,is} my,
|这是我的，这是我们的软件，

1225
00:38:04,690 --> 00:38:06,600
0,570 570,660 660,1140 1140,1440
this our software for,|
|

1226
00:38:07,000 --> 00:38:08,740
0,570 570,1170 1170,1260 1260,1410 1410,1740
UDP {in,xv6} is so lame,|
xv6 中的 UDP 还很差劲，|

1227
00:38:08,740 --> 00:38:10,300
0,180 180,330 330,660 900,1320 1320,1560
that it {} doesn't fill
它没有填写校验和字段，

1228
00:38:10,300 --> 00:38:12,070
0,150 150,240 240,660 660,1170 1470,1770
in the checksum field,| but
|这就是报头。

1229
00:38:12,070 --> 00:38:13,300
0,120 120,180 180,270 270,720
this is the header.|
|

1230
00:38:13,610 --> 00:38:15,110
0,180 180,420 630,1170 1170,1290 1290,1500
And then after the {UDP
然后在 UDP 报头之后是 UDP 包的有效载荷，

1231
00:38:15,110 --> 00:38:16,520
0,330 330,720 720,840 840,1350 1350,1410
-} {header,is} the payload of

1232
00:38:16,520 --> 00:38:17,810
0,120 120,240 240,540 540,960 1110,1290
the {UDP -} packet| and
|在这种情况下，应用程序正在发送 ASCII 文本，

1233
00:38:17,810 --> 00:38:19,610
0,90 90,390 390,960 1050,1320 1320,1800
in this case, the application

1234
00:38:19,610 --> 00:38:21,200
0,90 90,390 390,840 840,1410 1440,1590
is sending ASCII text| and
|而 ASCII 文本就在这里。

1235
00:38:21,200 --> 00:38:22,460
0,240 240,600 600,900 900,1020 1020,1260
that ASCII text is right

1236
00:38:22,460 --> 00:38:23,460
0,480
here.|
|

1237
00:38:24,580 --> 00:38:25,740
0,570

1238
00:38:26,890 --> 00:38:27,670
0,180 180,360 360,420 420,480 480,780
So this is {ASCII -}
所以，这是在 UDP 数据包中 ASCII 文本，

1239
00:38:27,670 --> 00:38:29,560
0,840 900,1170 1170,1470 1470,1590 1590,1890
text place inside {UDP -}

1240
00:38:29,560 --> 00:38:31,150
0,420 420,690 690,1080 1080,1170 1170,1590
packet,| place inside an IP
|在 IP 数据包中，

1241
00:38:31,150 --> 00:38:32,590
0,450 450,690 690,960 960,1080 1080,1440
packet,| place inside an Ethernet
|又在以太网数据包中，

1242
00:38:32,590 --> 00:38:33,700
0,420
packet,|
|

1243
00:38:35,390 --> 00:38:38,180
0,330 330,810 840,1410 1410,1800
sent over simulated Ethernet.|
通过模拟以太网发送。|

1244
00:38:42,260 --> 00:38:43,730
0,540 690,990 990,1110 1110,1350 1350,1470
Sorry, {} I just had
抱歉，我有个问题，

1245
00:38:43,730 --> 00:38:44,840
0,90 90,510 510,690 690,930 930,1110
a question,| so when when
|当你说给某人寄数据包的时候，

1246
00:38:44,840 --> 00:38:46,400
0,450 480,810 810,960 960,1320 1350,1560
you when you said when

1247
00:38:46,400 --> 00:38:47,330
0,150 150,330 330,390 390,810 810,930
you send a packet to

1248
00:38:47,330 --> 00:38:49,040
0,480 510,660 660,1020 1020,1260 1260,1710
someone,| you don't know their
|你不知道它们的以太网地址，

1249
00:38:49,400 --> 00:38:52,460
0,840 1020,1200 1200,1560 1980,2730 2760,3060
Ethernet {} like address,| so
|那么是否只是将它发送到你的路由器，

1250
00:38:52,460 --> 00:38:53,330
0,60 60,180 180,540 540,750 750,870
do you just send it

1251
00:38:53,330 --> 00:38:55,610
0,120 120,420 420,1170 1290,2160 2160,2280
to your router,| then the
|然后路由器通过计算得出。

1252
00:38:55,610 --> 00:38:58,790
0,570 690,1170 1170,1380 1380,1530 2310,3180
router figures out from.| If
|对于大多数在互联网上发送到其他地方的数据包，

1253
00:38:58,850 --> 00:39:01,040
0,540 540,1110 1110,1470 1470,1920 1920,2190
if for most packets sent

1254
00:39:01,040 --> 00:39:02,400
0,300 300,1050
somewhere else

1255
00:39:02,520 --> 00:39:04,410
0,150 150,240 240,900 1290,1680 1680,1890
on the Internet,| {} let's
|让我们看看，

1256
00:39:04,410 --> 00:39:05,220
0,210
see,|
|

1257
00:39:07,070 --> 00:39:08,330
0,300 300,780 780,870 870,1020 1020,1260
your host if you send
如果你将数据包发送到特定的 IP 地址，

1258
00:39:08,330 --> 00:39:09,470
0,60 60,570 570,690 690,780 780,1140
a packet to a particular

1259
00:39:09,470 --> 00:39:11,510
0,270 270,870 960,1380 1380,1680 1680,2040
IP address,| your host software
|你的主机软件将查看目标地址，

1260
00:39:11,510 --> 00:39:12,710
0,150 150,480 480,540 540,630 630,1200
will look at the destination

1261
00:39:12,710 --> 00:39:14,360
0,570 600,750 750,1050 1050,1290 1320,1650
address| to figure out if
|确定目标主机是否与你在同一局域网上，

1262
00:39:14,360 --> 00:39:16,130
0,120 120,570 570,1170 1320,1620 1620,1770
the target host is on

1263
00:39:16,130 --> 00:39:17,750
0,90 90,750 750,1080 1080,1320 1320,1620
the same local area network

1264
00:39:17,750 --> 00:39:18,830
0,120 120,300 300,660 780,990 990,1080
as you are,| and if
|如果是，它将使用 ARP 将 IP 地址转换为以太网地址，

1265
00:39:18,830 --> 00:39:20,560
0,120 120,630 780,1230
it is, it'll

1266
00:39:20,560 --> 00:39:22,300
0,360 360,900 1080,1230 1230,1650 1650,1740
use ARP to translate the

1267
00:39:22,300 --> 00:39:23,620
0,300 300,690 690,870 870,990 990,1320
IP address into an Ethernet

1268
00:39:23,620 --> 00:39:24,610
0,390 390,480 480,660 660,900 900,990
address,| and then send the
|然后通过以太网将数据包发送到目标主机，

1269
00:39:24,610 --> 00:39:26,230
0,390 750,990 990,1080 1080,1530 1530,1620
packet over the Ethernet to

1270
00:39:26,230 --> 00:39:27,740
0,90 90,420 420,990
the target host,|
|

1271
00:39:28,080 --> 00:39:29,280
0,150 150,270 270,420 420,960 960,1200
so that's what happens in
所以在这种情况下，

1272
00:39:29,280 --> 00:39:30,300
0,60 60,450 450,750 750,810 810,1020
the special case| in which
|目标主机在同一网络中。

1273
00:39:30,300 --> 00:39:31,560
0,180 210,600 600,870 870,1080 1080,1260
the target host is on

1274
00:39:31,560 --> 00:39:32,880
0,60 60,240 240,720 990,1260 1260,1320
the same network.| In the
|在更一般的情况下，

1275
00:39:32,880 --> 00:39:33,930
0,120 120,390 390,630 630,780 780,1050
more general case,| we're sending
|我们将数据包发送到全国各地的互联网上的其他地方，

1276
00:39:33,930 --> 00:39:35,010
0,120 120,480 480,570 570,870 870,1080
the packet to somewhere else

1277
00:39:35,010 --> 00:39:36,570
0,60 60,150 150,600 840,1470 1470,1560
on the Internet across the

1278
00:39:36,570 --> 00:39:39,660
0,480 1410,1860 1860,2430 2430,2520 2520,3090
country,| you'll send the packet
|你将把数据包发送到同一局域网上的路由器，

1279
00:39:39,660 --> 00:39:42,240
0,690 1500,2010 2010,2400 2400,2490 2490,2580
to a router on the

1280
00:39:42,240 --> 00:39:43,680
0,210 210,480 480,750 750,1260 1260,1440
same local area network,| that
|那个路由器将查看目的 IP 地址，

1281
00:39:43,680 --> 00:39:44,520
0,360 360,480 480,660 660,750 750,840
router will look at the

1282
00:39:44,520 --> 00:39:46,380
0,630 630,1410
destination IP

1283
00:39:46,700 --> 00:39:48,530
0,990 1140,1260 1260,1410 1410,1500 1500,1830
address| to pick the next
|选择下一台路由器，

1284
00:39:48,530 --> 00:39:50,930
0,660 690,780 780,1230 1560,2130 2130,2400
router| to decide which router
|以确定对于数据包连接到哪台路由器，

1285
00:39:50,930 --> 00:39:52,130
0,150 150,600 600,780 780,990 990,1200
it's attached to it for

1286
00:39:52,130 --> 00:39:53,270
0,90 90,390 390,570 570,720 720,1140
the packet to| and packet
|数据包的逐跳通过路由器，

1287
00:39:53,540 --> 00:39:54,620
0,330 330,540 540,660 660,930 930,1080
go hop by hop through

1288
00:39:54,620 --> 00:39:56,660
0,750 1020,1320 1320,1620 1620,1710 1710,2040
routers,| getting closer and closer
|离目标越来越近。

1289
00:39:56,660 --> 00:39:57,740
0,60 60,150 150,540
to the target.|
|

1290
00:39:58,150 --> 00:39:59,660
0,120 120,360 360,450 450,930
{Does,that} answer your question?|
这回答了你的问题吗？|

1291
00:39:59,720 --> 00:40:01,010
0,300 300,450 450,600 600,1020 1020,1290
OK, I see,| yes, thank
好的，我明白了，|是的，非常感谢。

1292
00:40:01,010 --> 00:40:02,450
0,90 90,240 240,660 720,1260 1260,1440
you so much.| Someone asked
|有人问数据的长度是否有限制，

1293
00:40:02,450 --> 00:40:03,110
0,90 90,210 210,300 300,570 570,660
if there's a limit to

1294
00:40:03,110 --> 00:40:03,980
0,90 90,330 330,420 420,480 480,870
the length of the packet,|
|

1295
00:40:04,160 --> 00:40:05,150
0,240 240,330 330,570 570,660 660,990
and the answer is yes,|
答案是肯定的，|

1296
00:40:05,150 --> 00:40:06,260
0,120 120,240 390,660 660,780 780,1110
there's a couple of different
有几个不同的限制，

1297
00:40:06,260 --> 00:40:09,320
0,570 1290,1680 1680,2130 2160,2580 2580,3060
limits,| every network every underlying
|每个底层网络技术，

1298
00:40:09,320 --> 00:40:11,450
0,300 300,960 960,1230 1230,1740 1740,2130
network technology,| like Ethernet, {}
|比如以太网，但还有其他东西，

1299
00:40:11,450 --> 00:40:12,710
0,120 120,300 300,780 840,1140 1140,1260
there are other things,| that
|比如以太网，有它自己的最大数据包长度，

1300
00:40:12,710 --> 00:40:14,660
0,60 60,330 330,780 1410,1800 1800,1950
are like Ethernet has its

1301
00:40:14,660 --> 00:40:17,780
0,750 960,1860 1860,2280 2280,2790 2790,3120
own maximum packet length,| so,
|所以，当今天的论文写的时候，

1302
00:40:18,110 --> 00:40:19,580
0,270 270,780 780,1050 1050,1320 1320,1470
{} when today's paper was

1303
00:40:19,580 --> 00:40:20,750
0,180 180,240 240,600 600,900 900,1170
written,| the maximum packet length
|以太网上的最大数据包长度是 1500 字节，

1304
00:40:20,750 --> 00:40:22,220
0,390 510,780 780,1020 1020,1170 1170,1470
was on Ethernet was {1500

1305
00:40:22,220 --> 00:40:24,590
0,300 300,870 1320,1590 1590,1800 1800,2370
-} bytes,| I think modern
|我认为现代以太网允许 9000 或 10000 字节的数据包，

1306
00:40:24,620 --> 00:40:26,510
0,240 240,780 810,1290 1290,1710 1710,1890
{Ethernet's -} allow packets up

1307
00:40:26,510 --> 00:40:29,450
0,150 150,600 600,1590 1590,1830 1830,2940
to around {9000,or} {10,000,bytes -},|
|

1308
00:40:30,320 --> 00:40:32,000
0,240 240,420 420,690 690,870 870,1680
but that's about the highest
但这是我听说过的最大数据包大小。

1309
00:40:32,000 --> 00:40:33,350
0,390 390,690 690,960 960,1110 1110,1350
maximum packet size, I've heard

1310
00:40:33,350 --> 00:40:35,150
0,210 210,420 420,540 540,1170 1470,1800
of.| And the reason, {}|
|这个原因，|

1311
00:40:35,150 --> 00:40:36,260
0,180 180,240 240,510 510,840 840,1110
there's a couple reasons why
你不希望无限长的单个包有几个原因，

1312
00:40:36,260 --> 00:40:38,060
0,390 570,900 900,1170 1320,1590 1590,1800
you wouldn't want sort of

1313
00:40:38,240 --> 00:40:40,730
0,660 660,1110 1110,1470 1470,2070 2100,2490
infinitely long single packets,| one
|其中之一是，

1314
00:40:40,730 --> 00:40:42,140
0,90 90,210 210,330 330,540 900,1410
of them is that| the
|你通过线路发送这些数据包，

1315
00:40:42,290 --> 00:40:44,450
0,750 750,930 1140,1410 1410,2010 2010,2160
packets are you sending these

1316
00:40:44,450 --> 00:40:45,860
0,360 360,600 600,1140 1140,1260 1260,1410
packets over wires,| that could
|可能会相当长，而且会受到噪音和干扰的影响，

1317
00:40:45,860 --> 00:40:47,510
0,90 90,420 420,840 840,990 990,1650
be quite long and subject

1318
00:40:47,510 --> 00:40:50,600
0,210 210,570 570,690 690,1590 2670,3090
to noise and interference| and
|所以，当你发送数据包时，可能会出现位损坏，

1319
00:40:50,600 --> 00:40:51,530
0,90 90,210 210,330 330,510 510,930
so you do get corruption

1320
00:40:51,530 --> 00:40:52,850
0,120 120,660 660,930 930,1050 1050,1320
of bits when you're sending

1321
00:40:52,850 --> 00:40:54,620
0,780 960,1350
packets {},|
|

1322
00:40:54,710 --> 00:40:56,660
0,510 510,1050 1050,1380 1380,1860 1860,1950
basically, every network technology is
基本上，每种网络技术都是某种校验和或纠错码，

1323
00:40:56,660 --> 00:40:58,070
0,120 120,270 270,480 690,1290 1290,1410
some kind of checksum or

1324
00:40:58,070 --> 00:40:59,150
0,150 150,510 510,810 810,900 900,1080
error correcting code| that goes
|伴随着每个数据包，

1325
00:40:59,150 --> 00:41:00,890
0,390 390,510 510,690 690,1140 1170,1740
along with every packet,| but
|但是校验和和纠错码仅能

1326
00:41:01,010 --> 00:41:02,120
0,390 390,660 660,870 870,960 960,1110
{} {checksums -} and error

1327
00:41:02,120 --> 00:41:03,560
0,330 330,600 600,690 690,930 930,1440
correcting codes are only capable|
|

1328
00:41:03,560 --> 00:41:06,230
0,90 90,630 630,1170 1170,1800 1890,2670
of reliably detecting errors {}
可靠地检测一定数量的位上的错误，

1329
00:41:06,320 --> 00:41:07,550
0,390 390,480 480,840 840,1140 1140,1230
over a certain number of

1330
00:41:07,550 --> 00:41:09,200
0,390 390,900 1080,1410 1410,1530 1530,1650
bits,| which and so as
|随着位数的增加，

1331
00:41:09,200 --> 00:41:09,860
0,90 90,330 330,390 390,600 600,660
you increase the number of

1332
00:41:09,860 --> 00:41:11,510
0,360 360,600 630,1440 1440,1530 1530,1650
bits,| the probability of an
|出现不常见错误的概率会越来越高，

1333
00:41:11,540 --> 00:41:13,550
0,690 810,1350 1380,1710 1710,1890 1890,2010
uncommon error goes up and

1334
00:41:13,550 --> 00:41:15,440
0,330 690,1050 1050,1170 1170,1350 1350,1890
up| and so that limits
|所以，这限制了，

1335
00:41:15,440 --> 00:41:17,150
0,270 300,570 570,960 960,1260 1260,1710
the,| for reasonable size checksum
|对于合理大小的校验和，比如 16 位或 32 位，

1336
00:41:17,150 --> 00:41:18,890
0,330 420,1020 1020,1050 1050,1440 1440,1740
like 16 or 32 bits,|
|

1337
00:41:18,890 --> 00:41:20,540
0,180 180,480 480,570 570,1200
that limits the maximum
它限制了数据包的最大大小。

1338
00:41:20,540 --> 00:41:22,180
0,450 450,540 540,600 600,1050
size of a packet.|
|

1339
00:41:22,980 --> 00:41:24,180
0,210 210,270 270,450 450,930 930,1200
And the other limitation is
另一个限制是，

1340
00:41:24,180 --> 00:41:26,520
0,270 1200,1620 1620,1800 1800,2010 2010,2340
that,| if you send huge
|如果你发送巨大的数据包，

1341
00:41:26,520 --> 00:41:28,460
0,600 600,780 780,1050 1050,1350
packets,| that means that
|这意味着主机中的所有路由器都必须有巨大的数据包缓冲区，

1342
00:41:28,610 --> 00:41:29,780
0,210 210,360 360,780 780,870 870,1170
all the routers in host

1343
00:41:29,780 --> 00:41:31,730
0,270 270,420 420,660 960,1260 1260,1950
{of,all} have to have huge

1344
00:41:31,760 --> 00:41:33,650
0,360 360,1020 1020,1110 1110,1260 1260,1890
packet buffers| to be prepared
|才能准备好接收巨大的数据包，

1345
00:41:33,650 --> 00:41:36,380
0,90 90,450 450,690 690,1320 1890,2730
to receive huge packets| and
|这开始变得非常昂贵，

1346
00:41:36,890 --> 00:41:38,960
0,510 510,810 810,900 900,1080 1470,2070
that starts to get an

1347
00:41:38,960 --> 00:41:42,120
0,360 360,1260 1290,1830
really expensive,| because
|因为很难有可变长度的缓冲区，

1348
00:41:42,180 --> 00:41:43,560
0,450 450,810 810,870 870,990 990,1380
it's difficult to have variable

1349
00:41:43,560 --> 00:41:44,970
0,270 270,720 720,810 810,1020 1020,1410
length buffers,| is most convenient
|所以最方便的是只有单一长度的缓冲区，

1350
00:41:44,970 --> 00:41:46,080
0,60 60,240 240,660 690,810 810,1110
to have just a single

1351
00:41:46,080 --> 00:41:48,660
0,210 210,300 300,750 2220,2400 2400,2580
length of buffer| and that
|这样效果最好，

1352
00:41:48,660 --> 00:41:49,770
0,240 240,570 570,660 660,750 750,1110
works best,| if the maximum
|如果最大数据包长度不是太大。

1353
00:41:49,770 --> 00:41:51,180
0,300 300,510 510,840
packet length isn't

1354
00:41:51,180 --> 00:41:52,540
0,150 150,840
too enormous.|
|

1355
00:41:52,860 --> 00:41:53,880
0,330 330,540 540,660 660,750 750,1020
Anyway, so for you think
不管怎样，对于你来说，

1356
00:41:53,880 --> 00:41:55,820
0,390 900,1290
for {},|
|

1357
00:41:55,820 --> 00:41:57,530
0,150 150,570 570,1050 1080,1380 1380,1710
so Ethernet has {1500 -}
所以以太网有 1500 , 9000 字节限制，

1358
00:41:57,530 --> 00:41:59,500
0,360 810,1260
{ -}

1359
00:42:00,050 --> 00:42:02,420
0,780 780,1140 1260,1500 1500,2130 2160,2370
{9000,bytes} limit,| in addition you
|此外，对于所有 IP 协议都具有 16 位的长度字段，

1360
00:42:02,420 --> 00:42:03,170
0,90 90,210 210,270 270,450 450,750
know for all these IP

1361
00:42:03,170 --> 00:42:04,760
0,510 510,690 690,1020 1020,1350 1350,1590
protocols have length fields which

1362
00:42:04,760 --> 00:42:07,160
0,540 750,1260 1260,1590 1590,1950 2100,2400
are 16 bits,| so even
|所以，即使你愿意让以太网有更大的数据包大小，

1363
00:42:07,160 --> 00:42:07,850
0,90 90,180 180,270 270,630 630,690
if you are willing to

1364
00:42:07,850 --> 00:42:09,200
0,240 240,630 630,750 750,1050 1050,1350
have Ethernet have larger packet

1365
00:42:09,200 --> 00:42:10,460
0,240 240,600 600,1020 1020,1200 1200,1260
size,| IP itself has a
|IP 本身也有最大数据包大小 64 千字节。

1366
00:42:10,460 --> 00:42:12,220
0,150 150,300 300,720 720,1200
kind of [] in

1367
00:42:12,220 --> 00:42:14,680
0,480 480,780 780,1110 1110,1290 1860,2460
maximum packet size is 64

1368
00:42:14,680 --> 00:42:15,960
0,750
kilobytes.|
|

1369
00:42:19,250 --> 00:42:22,720
0,570 840,1500
Okay {}.|
好的。|

1370
00:42:25,310 --> 00:42:27,050
0,450 690,1200 1260,1470 1470,1620 1620,1740
Okay, good, so much for
好的，对 UDP 来说挺多了。

1371
00:42:27,050 --> 00:42:28,180
0,120 120,570
{UDP -}.|
|

1372
00:42:28,410 --> 00:42:29,790
0,420 690,870 870,1140 1140,1260 1260,1380
{} And hopefully when you
希望当你完成实验后，

1373
00:42:29,790 --> 00:42:31,110
0,210 210,330 330,600 600,720 720,1320
finish the lab,| you'll see
|你会看到非常类似的输出，

1374
00:42:31,380 --> 00:42:33,180
0,510 510,750 750,1020 1020,1230 1230,1800
output very much like this,|
|

1375
00:42:33,700 --> 00:42:34,660
0,480

1376
00:42:34,750 --> 00:42:36,070
0,180 180,690 690,810 810,1140 1140,1320
in particular, the message from
具体地说，来自 xv6 的消息，

1377
00:42:36,070 --> 00:42:38,620
0,330 330,840 1080,1800 1920,2040 2040,2550
{xv6 -}| and a message
|以及来自你正在运行的 QEMU 的主机的消息。

1378
00:42:38,800 --> 00:42:40,300
0,150 150,750 780,1050 1050,1230 1230,1500
of reply back from the

1379
00:42:40,570 --> 00:42:41,950
0,570 570,660 660,750 750,1110 1140,1380
host that you're running running

1380
00:42:41,950 --> 00:42:43,400
0,210 210,570
{QEMU -}.|
|

1381
00:42:44,800 --> 00:42:45,700
0,150 150,480 480,750 750,810 810,900
In fact, actually at the
事实上，在实验的最后，

1382
00:42:45,700 --> 00:42:46,960
0,120 120,180 180,270 270,780 810,1260
end of the lab,| you'll
|你将使用，

1383
00:42:46,960 --> 00:42:48,820
0,870 900,1260
use {},|
|

1384
00:42:48,850 --> 00:42:50,140
0,210 210,600 600,780 780,1110 1110,1290
{} you'll run software which
你将运行我们提供的软件，

1385
00:42:50,140 --> 00:42:51,340
0,90 90,480 480,630 630,810 870,1200
we provide| which will actually
|软件将向 Google 的 DNS 服务器发送 DNS 查询，

1386
00:42:51,340 --> 00:42:53,020
0,300 300,450 480,1110 1110,1560 1560,1680
send a DNS query to

1387
00:42:53,020 --> 00:42:55,690
0,390 390,750 750,1530 2160,2520 2520,2670
Google's DNS servers| and get
|把回应拿回我们的软件，并打印响应，

1388
00:42:55,690 --> 00:42:57,340
0,90 90,510 510,900 1020,1200 1200,1650
the response back our software,

1389
00:42:57,520 --> 00:42:59,980
0,270 270,810 810,990 1410,1950 1950,2460
print response,| {} your software
|你的软件将完成以太网级设备驱动程序交互。

1390
00:42:59,980 --> 00:43:00,960
0,150 150,480
will {}

1391
00:43:00,960 --> 00:43:02,340
0,360 360,480 480,690 690,840 870,1380
done the sort of Ethernet

1392
00:43:02,340 --> 00:43:05,260
0,510 900,1230 1230,1530 1530,2340
level device driver interactions.|
|

1393
00:43:07,750 --> 00:43:09,700
0,420 480,960 990,1170 1170,1590 1620,1950
Alright, {} so that's {}
好的，这就是关于网络上的数据包报头和协议的事。

1394
00:43:09,700 --> 00:43:11,470
0,300 300,390 390,750 750,1410 1440,1770
story for packet headers and

1395
00:43:11,530 --> 00:43:13,660
0,480 480,540 540,600 600,1110 1770,2130
protocols on the wire.| So
|所以，与这些数据包格式对应的是，

1396
00:43:13,660 --> 00:43:16,270
0,1170 1170,1290 1290,1530 1530,1890 1890,2610
corresponding to these packet formats

1397
00:43:16,510 --> 00:43:19,360
0,540 930,2340 2370,2580 2580,2730 2730,2850
{is -},| let's call the
|让我们查看在主机上运行的网络软件堆栈，

1398
00:43:19,360 --> 00:43:21,850
0,600 600,960 1080,1560 1590,2130 2130,2490
stack of a network software

1399
00:43:21,850 --> 00:43:22,930
0,150 150,390 390,450 450,540 540,1080
that runs on the host,|
|

1400
00:43:22,960 --> 00:43:24,600
0,270 720,1230
so, {}
所以，如果你想一想主机里有什么，

1401
00:43:24,710 --> 00:43:25,610
0,180 180,270 270,420 420,690 690,900
if you think about what's

1402
00:43:25,610 --> 00:43:28,580
0,330 330,660 660,750 750,1410 2460,2970
sitting inside the host| and
|从现在开始，

1403
00:43:29,060 --> 00:43:30,350
0,690 690,870 870,1050 1050,1170 1170,1290
{you,know} from now on,| I'm
|我要说的主要是一些典型的软件安排，

1404
00:43:30,350 --> 00:43:31,790
0,570 570,720 720,1050 1050,1260 1260,1440
talking I mostly talk about

1405
00:43:31,790 --> 00:43:33,620
0,150 150,300 300,960 960,1410 1410,1830
sort of typical software arrangements,|
|

1406
00:43:33,620 --> 00:43:34,580
0,150 150,300 300,540 540,690 690,960
there's all kinds of different
人们构建网络软件有不同的方法，

1407
00:43:34,580 --> 00:43:36,470
0,240 240,540 540,1020 1020,1320 1320,1890
ways people structured network software,|
|

1408
00:43:36,800 --> 00:43:39,320
0,630 1140,1620 1620,2070
{} and {}
和我要说的有点不同，

1409
00:43:39,320 --> 00:43:40,850
0,210 210,720 720,1080 1080,1410 1410,1530
it's somewhat quite different from

1410
00:43:40,850 --> 00:43:41,780
0,150 150,210 210,360 360,600 600,930
what I'm gonna talk about,|
|

1411
00:43:41,900 --> 00:43:42,710
0,180 180,330 330,390 390,570 570,810
I'm going to talk about
我要讨论一下，

1412
00:43:42,710 --> 00:43:45,710
0,180 180,510 2160,2580 2580,2790 2790,3000
kind of,| what I think
|我认为至少是一种标准的方法。

1413
00:43:45,710 --> 00:43:46,730
0,210 210,300 300,510 510,720 720,1020
is at least as a

1414
00:43:46,730 --> 00:43:48,200
0,180 180,240 240,630 630,1200 1200,1470
sort of standard approach.| So
|让我们假设运行的是 Linux 或者是 xv6 ，

1415
00:43:48,320 --> 00:43:49,730
0,360 360,600 600,690 690,900 900,1410
let's assume we're running Linux,

1416
00:43:49,730 --> 00:43:50,900
0,120 120,360 360,510 510,660 660,1170
or maybe {xv6 - -},|
|

1417
00:43:51,110 --> 00:43:52,250
0,480 630,930 930,990 990,1080 1080,1140
{} now we have a
现在我们有一堆应用程序，

1418
00:43:52,250 --> 00:43:53,960
0,180 180,240 240,1110 1110,1410 1410,1710
bunch of applications,| maybe a
|可能是网络浏览器，

1419
00:43:53,990 --> 00:43:55,860
0,450 450,1380
web browser,|
|

1420
00:43:56,070 --> 00:43:58,170
0,810 1230,1410 1410,1650 1650,1830 1830,2100
{ -} it {maybe -}
也可能是 DNS 服务器，

1421
00:43:58,170 --> 00:44:01,000
0,630 810,1290 1290,2280
a DNS server,|
|

1422
00:44:01,940 --> 00:44:02,900
0,330 330,480 480,720 720,900 900,960
who knows what bunch of
谁知道是什么样的应用程序，

1423
00:44:02,900 --> 00:44:05,660
0,900 1170,1890 2040,2340 2340,2520 2520,2760
applications,| {} they all use
|它们都使用套接字 API ，

1424
00:44:05,660 --> 00:44:07,430
0,90 90,690 690,1440 1440,1560 1560,1770
the sockets API| to open
|来打开套接字层中的文件描述符，

1425
00:44:07,430 --> 00:44:09,290
0,150 150,510 510,1230 1230,1470 1470,1860
up file descriptors in the

1426
00:44:09,350 --> 00:44:11,120
0,720 720,1200 1230,1440 1440,1650 1650,1770
sockets layer,| so there's going
|所以在内核里会有这样的东西，

1427
00:44:11,120 --> 00:44:12,320
0,60 60,180 180,720
to be this,

1428
00:44:12,320 --> 00:44:14,160
0,540 540,630 630,1170
inside the kernel,|
|

1429
00:44:15,260 --> 00:44:16,420
0,600

1430
00:44:16,700 --> 00:44:17,720
0,240 240,450 450,510 510,840 840,1020
a layer of software called
称为套接字层的软件层，

1431
00:44:17,720 --> 00:44:20,150
0,90 90,540 540,930 1080,1650 1950,2430
the sockets layer| that {}
|它记住表，

1432
00:44:20,180 --> 00:44:21,980
0,540 540,690 690,1170 1170,1320 1320,1800
remember has tables,| that remembers
|它记住对应的文件描述符，

1433
00:44:21,980 --> 00:44:24,230
0,60 60,810 810,1050 1050,1380 1380,2250
the correspondence between file descriptors,|
|

1434
00:44:24,260 --> 00:44:25,430
0,330 330,420 420,900 900,1080 1080,1170
which the applications read or
应用程序用来读取，

1435
00:44:25,430 --> 00:44:28,250
0,360 360,780 1560,2130 2130,2490 2490,2820
write| and {UDP -} port
|UDP 端口号或 TCP 端口号，

1436
00:44:28,250 --> 00:44:30,080
0,360 360,450 450,1020 1020,1290 1290,1830
numbers or TCP port numbers|
|

1437
00:44:30,080 --> 00:44:32,000
0,240 240,690 930,1170 1170,1440 1440,1920
which is for the, {}
是这些文件描述符引用的端点，

1438
00:44:33,160 --> 00:44:34,390
0,150 150,300 300,450 450,1050 1050,1230
the sort of endpoints of

1439
00:44:34,450 --> 00:44:36,340
0,810 810,900 900,1080 1080,1350 1350,1890
conversations that these file descriptors

1440
00:44:36,340 --> 00:44:37,420
0,300 300,480 510,690 690,780 780,1080
refer to,| so the socket
|所以，套接字层有关于端口号的文件描述符表，

1441
00:44:37,420 --> 00:44:39,520
0,240 240,390 390,690 1590,2040 2040,2100
layer has these tables of

1442
00:44:39,520 --> 00:44:41,110
0,180 180,660 660,750 750,1020 1020,1590
file descriptors on port numbers|
|

1443
00:44:41,110 --> 00:44:42,490
0,150 150,390 390,720 720,1170 1170,1380
and it also typically has
并且它通常还具有已到达的数据包队列，

1444
00:44:42,490 --> 00:44:44,240
0,150 180,1140
a queue

1445
00:44:44,390 --> 00:44:45,830
0,390 420,780 780,1230 1230,1320 1320,1440
{} of packets that have

1446
00:44:45,830 --> 00:44:47,690
0,660 660,750 750,870 870,1500 1650,1860
arrived| and are waiting to
|并等待每个套接字或文件描述符读取。

1447
00:44:47,690 --> 00:44:49,520
0,150 150,600 600,840 840,1170 1170,1830
be read by each socket

1448
00:44:49,550 --> 00:44:51,000
0,150 150,450 450,1080
or file descriptor.|
|

1449
00:44:54,580 --> 00:44:55,720
0,180 180,390 390,720 720,810 810,1140
And the software we provide
我们提供的软件是一个非常原始的套接字层，

1450
00:44:55,720 --> 00:44:57,610
0,300 390,660 660,720 720,1080 1350,1890
you as a very primitive

1451
00:44:57,610 --> 00:44:59,940
0,450 450,990 1230,1740
sockets layer {},|
|

1452
00:45:00,200 --> 00:45:02,210
0,570 570,1050 1080,1440 1440,1620 1620,2010
underneath that are gonna be
在它下面是 UDP 和 TCP 协议层。

1453
00:45:02,600 --> 00:45:03,940
0,690
{}

1454
00:45:04,370 --> 00:45:06,080
0,240 240,390 390,570 570,1110 1110,1710
the {UDP - -} and

1455
00:45:07,120 --> 00:45:09,020
0,510 510,1350
TCP protocol

1456
00:45:09,020 --> 00:45:10,460
0,900
layers.|
|

1457
00:45:12,210 --> 00:45:14,940
0,480 1170,1620 1620,2040 2040,2460 2460,2730
{} UDP has almost nothing
UDP 几乎什么都没发生，

1458
00:45:14,940 --> 00:45:16,230
0,270 270,480 480,540 540,1050 1080,1290
going on,| it basically looks
|它查看传入的数据包，

1459
00:45:16,230 --> 00:45:17,790
0,90 90,420 420,930 930,1470 1470,1560
at incoming packets,| extracts the
|提取目的端口号，

1460
00:45:17,790 --> 00:45:19,260
0,510 510,750 750,1020 1020,1110 1110,1470
destination port number| and hands
|并将数据包传递给套接字层，

1461
00:45:19,260 --> 00:45:19,980
0,60 60,390 390,540 540,630 630,720
the packet off to the

1462
00:45:19,980 --> 00:45:21,570
0,360 360,660 660,960 1230,1410 1410,1590
socket layer to,| so that
|所以有效载荷在正确的文件描述符入站队列上排队。

1463
00:45:21,570 --> 00:45:22,980
0,450 450,570 570,1020 1020,1170 1170,1410
payload is queued on the

1464
00:45:23,190 --> 00:45:25,740
0,810 810,1170 1170,1770 1770,2190 2190,2550
correct file descriptors incoming queue.|
|

1465
00:45:27,060 --> 00:45:28,560
0,660 660,930 930,1050 1050,1290 1290,1500
TCP actually is much more
TCP 实际上要复杂得多，

1466
00:45:28,560 --> 00:45:30,300
0,630 630,780 810,1230 1230,1590 1590,1740
complex,| it keeps state for
|它保持每个 TCP 连接状态，

1467
00:45:30,300 --> 00:45:31,860
0,240 240,750 750,1320 1320,1410 1410,1560
each TCP connection,| and it
|它会记住所有序列号和数据包，

1468
00:45:31,920 --> 00:45:33,480
0,690 690,840 840,1050 1050,1110 1110,1560
remembers all kinds of sequence

1469
00:45:33,480 --> 00:45:35,160
0,420 420,510 510,960 960,1230 1290,1680
numbers and packets| that haven't
|那些没有确认和需要重发的，

1470
00:45:35,160 --> 00:45:36,360
0,120 120,780 780,870 870,1110 1110,1200
been acknowledged and need to

1471
00:45:36,360 --> 00:45:38,130
0,150 150,990 1230,1380 1380,1470 1470,1770
be retransmitted| to the huge
|以及 TCP 的大量状态和所谓的协议控制块，

1472
00:45:38,130 --> 00:45:39,150
0,210 210,270 270,660 660,780 780,1020
amount of state and what's

1473
00:45:39,150 --> 00:45:40,000
0,240 240,480
called {}

1474
00:45:40,000 --> 00:45:42,610
0,630 990,1440 1440,1740 1740,1860 1860,2610
protocol control block of TCP|
|

1475
00:45:43,060 --> 00:45:44,860
0,510 510,930 930,1140 1140,1560 1560,1800
and virtually no state in
而在 UDP 层中没有状态。

1476
00:45:44,860 --> 00:45:46,800
0,270 690,990 990,1410
the UDP layer.|
|

1477
00:45:46,800 --> 00:45:48,120
0,330 330,420 420,540 540,750 750,1320
These are often called transport
这些通常称为传输层， UDP 和 TCP ，

1478
00:45:48,120 --> 00:45:49,650
0,450 450,540 540,810 810,930 930,1530
layers, {UDP -} and TCP|
|

1479
00:45:51,030 --> 00:45:52,110
0,270 270,420 420,780 780,930 930,1080
and we provide you with
我们为你提供一个简单的 UDP 层，

1480
00:45:52,110 --> 00:45:53,580
0,210 210,570 570,900 900,1170 1170,1470
a simple UDP layer,| but
|而不是 TCP 层，

1481
00:45:53,670 --> 00:45:56,220
0,600 630,720 720,1200 1200,1680 1800,2550
not a TCP layer {},|
|

1482
00:45:56,760 --> 00:45:58,650
0,510 510,1020 1020,1110 1110,1710 1710,1890
underneath TCP and UDP is
在 TCP 和 UDP 下面是 IP 层，

1483
00:45:58,650 --> 00:45:59,460
0,330
{

1484
00:45:59,970 --> 00:46:01,460
0,840
-}

1485
00:46:01,970 --> 00:46:03,500
0,540 540,1080
IP layer,|
|

1486
00:46:04,520 --> 00:46:06,800
0,540 990,1260 1260,1650
{} which is
这是相当简单的，

1487
00:46:07,160 --> 00:46:09,560
0,450 450,810 960,1380 1380,1950 2070,2400
{} often fairly simple {},|
|

1488
00:46:09,560 --> 00:46:10,640
0,150 150,390 390,450 450,570 570,1080
and kind of in parallel
与 IP 层并行，

1489
00:46:10,640 --> 00:46:11,630
0,90 90,210 210,570 570,930 930,990
with the IP layer,| I'm
|我不确定否应该画在同一层面或下一层面，

1490
00:46:11,630 --> 00:46:12,500
0,180 180,330 330,540 540,540 540,870
not sure whether I should

1491
00:46:12,500 --> 00:46:13,640
0,240 240,330 330,420 420,750 750,1140
draw on the same level

1492
00:46:13,640 --> 00:46:15,700
0,420 420,660 840,1500
{or,underneath} it, {}|
|

1493
00:46:15,820 --> 00:46:17,580
0,180 180,300 300,510 510,1290
is the ARP layer,|
那就是 ARP 层，|

1494
00:46:17,940 --> 00:46:19,710
0,360 360,510 510,1260 1320,1620 1620,1770
under them both, {} we
在它们下面，我们可以认为是以太网层，

1495
00:46:19,710 --> 00:46:20,310
0,120 120,330 330,420 420,540 540,600
can think of as an

1496
00:46:20,340 --> 00:46:21,930
0,330 330,750 750,870 870,1140 1140,1590
Ethernet layer,| but it's really
|但实际上不会有单独的以太网层，

1497
00:46:21,930 --> 00:46:23,610
0,180 180,510 600,1140 1140,1290 1290,1680
there's not typically a separate

1498
00:46:23,610 --> 00:46:25,980
0,360 360,750 780,1260 1260,1500 1950,2370
Ethernet layer,| typically there's one
|通常在最低层有一个或多个网卡驱动程序，

1499
00:46:25,980 --> 00:46:27,880
0,90 90,300 300,510 510,1410
or more NIC drivers

1500
00:46:28,740 --> 00:46:30,040
0,690
{}

1501
00:46:30,330 --> 00:46:31,920
0,210 210,330 330,690 690,1110 1110,1590
at the lowest layer| and
|并且这些设备与实际的网络接口硬件通信，

1502
00:46:31,950 --> 00:46:33,930
0,420 420,870 870,1530 1590,1830 1830,1980
these talk to {} the

1503
00:46:33,930 --> 00:46:35,240
0,720
actual

1504
00:46:35,400 --> 00:46:37,770
0,330 330,900 1020,1350 1350,1680 1680,2370
{} NIC network interface hardware,|
|

1505
00:46:37,800 --> 00:46:39,600
0,390 390,780 780,960 960,1050 1050,1800
which itself has a connection
它本身有与局域网的连接，

1506
00:46:39,690 --> 00:46:42,060
0,720 720,870 870,1290 1710,2160 2160,2370
of to the local area

1507
00:46:42,060 --> 00:46:43,340
0,540 540,780
network,| or
|或任何连接的网络，

1508
00:46:44,480 --> 00:46:45,620
0,180 180,510 510,690 690,750 750,1140
{} whatever kind of network

1509
00:46:45,740 --> 00:46:47,160
0,870
attached,|
|

1510
00:46:47,710 --> 00:46:49,180
0,330 600,1020 1110,1350 1350,1410 1410,1470
{} and sort of at
在这个层面上，

1511
00:46:49,180 --> 00:46:50,350
0,240 240,540 540,720 720,1050 1050,1170
this level,| what happens is
|发生的情况是数据包到达网络，

1512
00:46:50,350 --> 00:46:52,240
0,90 90,420 420,1530 1560,1800 1800,1890
the packet arrives of the

1513
00:46:52,240 --> 00:46:54,640
0,750 750,1080 1080,1680 1920,2190 2190,2400
network,| the NIC you know
|网卡会把它从网络上拉下来，

1514
00:46:54,790 --> 00:46:55,900
0,240 240,330 330,450 450,540 540,1110
pulls it off the network,|
|

1515
00:46:56,890 --> 00:46:57,940
0,630 630,720 720,870 870,960 960,1050
hands it off to the
把它交给驱动，

1516
00:46:57,940 --> 00:46:59,770
0,540 540,660 660,720 720,1230 1260,1830
driver| and the driver essentially
|并且驱动将数据包向上推送到网络堆栈，

1517
00:46:59,770 --> 00:47:01,540
0,480 480,570 570,1080 1230,1470 1470,1770
pushes the network the {packet

1518
00:47:01,540 --> 00:47:03,160
0,120 150,360 360,480 480,960 960,1620
-} up the networking stack,|
|

1519
00:47:03,310 --> 00:47:04,780
0,540 630,1050 1050,1200 1200,1410 1410,1470
{} at each layer in
在堆栈中的每一层，

1520
00:47:04,780 --> 00:47:05,950
0,60 60,450 450,720 720,810 810,1170
the stack,| the you know
|这一层的报头，

1521
00:47:06,250 --> 00:47:08,140
0,270 270,540 540,630 630,1290
that {layer's -} header,|
|

1522
00:47:08,140 --> 00:47:09,220
0,120 120,330 330,450 450,810 810,1080
you know the IP layer
IP 层会查看 IP 报头，

1523
00:47:09,220 --> 00:47:10,570
0,150 150,360 360,450 450,720 720,1350
will look the IP header,|
|

1524
00:47:11,200 --> 00:47:13,000
0,720 720,810 810,1260 1260,1560 1560,1800
verify the headers, stripped off
验证报头，从报头剥离出 UDP ，

1525
00:47:13,000 --> 00:47:15,460
0,210 210,1050 1290,1920 1920,2070 2070,2460
header UDP,| UDP will figure
|UDP 将找出文件描述符，

1526
00:47:15,460 --> 00:47:17,980
0,330 540,720 720,930 930,1530 1950,2520
out what file descriptor,| queue
|找出数据并放到队列中，

1527
00:47:17,980 --> 00:47:19,000
0,60 60,270 270,570 570,810 810,1020
the data on and add

1528
00:47:19,000 --> 00:47:20,320
0,90 90,150 150,330 330,720 960,1320
it to that queue, {}|
|

1529
00:47:20,320 --> 00:47:21,190
0,120 120,420 420,630 630,780 780,870
so packets come in and
数据包进入并解析，

1530
00:47:21,190 --> 00:47:22,630
0,120 120,780 780,1050 1050,1380 1380,1440
are parsed| and headers are
|报头在向上的过程中被剥离。

1531
00:47:22,630 --> 00:47:23,560
0,300 300,360 360,450 450,600 600,930
stripped on the way up.|
|

1532
00:47:23,770 --> 00:47:25,420
0,210 210,330 330,420 690,1350 1350,1650
And when an application sends
当应用程序发送数据包时，

1533
00:47:25,420 --> 00:47:26,830
0,60 60,510 600,810 810,1230 1230,1410
a packet,| the reverse thing
|会发生相反的事情，

1534
00:47:26,830 --> 00:47:28,060
0,420 420,540 540,630 630,990 990,1230
happens,| as the packet moves
|随着分组在各层中向下移动，

1535
00:47:28,060 --> 00:47:29,860
0,450 450,630 630,750 750,1320 1380,1800
down through the layers,| more
|越来越多的报头被添加上，

1536
00:47:29,860 --> 00:47:31,330
0,90 90,270 270,810 840,1170 1170,1470
and more headers are added

1537
00:47:31,330 --> 00:47:32,110
0,270 270,480 480,600 600,720 720,780
on,| until you get to
|直到你到达最底层，

1538
00:47:32,110 --> 00:47:33,130
0,90 90,390 390,750 750,840 840,1020
the bottom layer| and then
|然后数据包交给网卡进行传输。

1539
00:47:33,130 --> 00:47:35,080
0,210 450,960 960,1410 1410,1560 1560,1950
the packets handed the NIC

1540
00:47:35,110 --> 00:47:36,520
0,390 390,1050
for transmission.|
|

1541
00:47:41,910 --> 00:47:43,600
0,240 240,300 300,750 750,1050
So, of course the
所以，当然软件，

1542
00:47:43,820 --> 00:47:46,190
0,1140 1350,1770 1770,1890 1890,2130 2130,2370
software,| the way people think
|人们思考和设计网络软件的方式，

1543
00:47:46,190 --> 00:47:47,960
0,240 240,330 330,750 750,1110 1110,1770
about and design network software|
|

1544
00:47:47,960 --> 00:47:49,490
0,90 90,180 300,720 720,900 900,1530
and the kernel is typically
内核通常由数局包内协议的嵌套来驱动。

1545
00:47:49,700 --> 00:47:52,040
0,660 660,900 900,1260 1290,2160 2160,2340
driven by the nesting of

1546
00:47:52,040 --> 00:47:53,990
0,210 240,840 840,1170 1170,1230 1230,1950
the protocols inside the packets.|
|

1547
00:47:56,060 --> 00:47:57,560
0,210 210,600 600,780 780,930 930,1500
Any questions about this structure?|
对这个结构，有什么问题吗？|

1548
00:48:03,420 --> 00:48:04,890
0,150 150,330 330,510 510,1050 1050,1470
It's actually one important thing|
实际上，有一个重要的事情，|

1549
00:48:04,890 --> 00:48:05,910
0,120 120,390 420,600 600,690 690,1020
that I kind of left
我留在这里，它在旁边，

1550
00:48:05,910 --> 00:48:06,750
0,180 180,330 330,450 450,750 750,840
out here, that sits on

1551
00:48:06,750 --> 00:48:09,960
0,90 90,600 750,1410 1590,2070 2070,3210
the side,| {} there's buffers,
|这里有缓冲区，所有都通过这里，

1552
00:48:10,520 --> 00:48:12,560
0,300 300,540 540,990 990,1770 1770,2040
{} there's packet buffers all

1553
00:48:12,560 --> 00:48:13,670
0,270 270,540 540,690 690,750 750,1110
through this,| when a packet
|当一个包到达时，它被复制到包缓冲器中，

1554
00:48:13,670 --> 00:48:16,100
0,540 540,840 1530,1980 1980,2220 2220,2430
arrives, it's copied into a

1555
00:48:16,190 --> 00:48:18,950
0,360 360,900 1200,2010 2220,2340 2340,2760
packet buffer| and the packet
|数据包缓冲器在堆栈中上下发送，

1556
00:48:18,950 --> 00:48:20,270
0,510 510,660 750,1110 1110,1230 1230,1320
buffers are sent up and

1557
00:48:20,270 --> 00:48:21,050
0,180 180,270 270,570 570,660 660,780
down the stack| and there's
|而且通常有相当多的数据包缓冲器，

1558
00:48:21,050 --> 00:48:22,160
0,240 240,510 510,570 570,750 750,1110
often quite a few packet

1559
00:48:22,160 --> 00:48:24,320
0,600 780,1050 1050,1260 1260,1800 1800,2160
buffers,| there's often queues between
|这些层之间经常有队列，

1560
00:48:24,320 --> 00:48:25,250
0,180 180,480 480,600 600,870 870,930
these layers,| there's certainly a
|这里肯定有队列，

1561
00:48:25,250 --> 00:48:27,260
0,300 300,840 1110,1620 1620,1920 1920,2010
queue here,| packets waiting to
|数据包等待应用程序处理，

1562
00:48:27,260 --> 00:48:30,230
0,120 120,840 1110,1620 1620,2520 2760,2970
be processed by applications,| and
|这里是链表缓冲区，

1563
00:48:30,230 --> 00:48:31,670
0,150 150,240 240,390 390,630 780,1440
this will be a linked

1564
00:48:31,670 --> 00:48:34,100
0,510 720,1050 1050,1890 1980,2280 2280,2430
list of buffers,| {} and
|所以这里有一个缓冲区分配器，

1565
00:48:34,100 --> 00:48:35,690
0,90 90,270 270,450 450,780 780,1590
so there's a buffer allocator,|
|

1566
00:48:35,690 --> 00:48:38,060
0,540 1290,1710 1740,1980 1980,2280 2280,2370
that's a buffer scheme and
这是一个缓冲区方案和一个缓冲区分配器，

1567
00:48:38,060 --> 00:48:39,680
0,30 30,300 300,780 780,1170 1200,1620
a buffer allocator,| that's used
|在整个堆栈中使用，

1568
00:48:39,680 --> 00:48:41,510
0,390 390,510 510,960 1230,1710 1710,1830
throughout the stack,| and in
|在软件中，我们给出了一个缓冲区方案，叫做 MBUF ，

1569
00:48:41,510 --> 00:48:42,920
0,60 60,390 390,870 900,1110 1110,1410
the software, we give you

1570
00:48:43,130 --> 00:48:45,710
0,480 1260,1770 1770,2160 2160,2280 2280,2580
a buffer scheme is called,

1571
00:48:45,710 --> 00:48:46,760
0,150 150,870
{MBUFs -},|
|

1572
00:48:47,010 --> 00:48:47,790
0,150 150,270 270,420 420,480 480,780
so it's kind of {}
它是一种 MBUF 方案，

1573
00:48:48,670 --> 00:48:50,240
0,300 300,1050
{MBUF -}

1574
00:48:51,510 --> 00:48:53,970
0,540 1020,1470 1470,1920 2070,2370 2370,2460
{} scheme,| that's not a
|这不是一个层，而是所有这些层都在使用。

1575
00:48:53,970 --> 00:48:55,200
0,450 450,600 600,720 720,1080 1080,1230
layer, but is used all

1576
00:48:55,200 --> 00:48:57,000
0,330 330,510 510,1020
throughout these layers.|
|

1577
00:48:59,400 --> 00:49:00,900
0,450 780,930 930,1020 1020,1140 1140,1500
Okay, this is the layering
好的，这是典型的网络堆栈分层图。

1578
00:49:00,900 --> 00:49:03,900
0,780 810,1290 1350,1740 1740,2040 2040,3000
diagram of typical network stack.|
|

1579
00:49:04,490 --> 00:49:07,310
0,390 1140,1380 1380,1620 1620,2280 2670,2820
{} For this paper, it's
对于论文来说，理解控制流是如何工作的很重要，

1580
00:49:07,310 --> 00:49:08,540
0,240 240,600 600,660 660,1110 1110,1230
actually important to understand how

1581
00:49:08,540 --> 00:49:09,980
0,90 90,540 540,840 840,1260 1260,1440
the control flow works,| which
|这可能与图中的有所不同。

1582
00:49:09,980 --> 00:49:12,200
0,240 480,1830 1830,1950 1950,2100 2100,2220
is maybe a little bit

1583
00:49:12,200 --> 00:49:13,130
0,360 360,510 510,720 720,780 780,930
different from what's in that

1584
00:49:13,130 --> 00:49:15,220
0,570
diagram.|
|

1585
00:49:16,550 --> 00:49:18,230
0,450 450,630 630,810 810,1170 1170,1680
One thing to know about
关于网络堆栈，需要了解的一件事是，

1586
00:49:18,230 --> 00:49:20,720
0,450 450,960 960,1380 1380,1920 1920,2490
networks stacks,| there's typically multiple
|通常有多个独立的参与者，

1587
00:49:20,750 --> 00:49:23,570
0,810 810,1680 1710,1920 1920,2370 2370,2820
independent actors,| that process packets
|处理数据包并接受输入，

1588
00:49:23,570 --> 00:49:25,220
0,120 120,330 330,900 1020,1440 1440,1650
and take input,| think about
|考虑这些数据包并产生输出，

1589
00:49:25,220 --> 00:49:26,900
0,210 210,660 660,810 810,1140 1140,1680
those packets and produce output|
|

1590
00:49:26,990 --> 00:49:29,900
0,540 540,690 690,1050 1050,1800 2430,2910
and for various reasons, these
由于各种原因，这些不同的参与者是分离的，

1591
00:49:29,900 --> 00:49:32,000
0,300 300,810 810,1110 1170,1980 1980,2100
different actors are decoupled,| so
|所以它们可以并发运行，并具有连接它们的数据包队列。

1592
00:49:32,000 --> 00:49:33,410
0,150 150,300 300,510 510,1230 1230,1410
they can run concurrently and

1593
00:49:33,410 --> 00:49:35,570
0,270 300,810 810,1470 1500,1980 1980,2160
have packet queues connecting them.|
|

1594
00:49:36,180 --> 00:49:38,160
0,390 600,780 780,930 930,1500 1500,1980
{} So that's extremely important
所以从论文的角度来看，这是非常重要的，

1595
00:49:38,160 --> 00:49:38,820
0,120 120,210 210,420 420,480 480,660
from the point of view

1596
00:49:38,820 --> 00:49:40,740
0,180 180,660 780,1320 1410,1830 1830,1920
this paper,| so within the
|所以在内核中，

1597
00:49:40,740 --> 00:49:41,900
0,600
kernel,|
|

1598
00:49:41,930 --> 00:49:42,950
0,330 330,510 510,630 630,750 750,1020
so again, we have a
同样，我们有一个网卡，

1599
00:49:43,520 --> 00:49:45,620
0,300 300,720 720,1320 1650,1950 1950,2100
network interface card,| and then
|然后我们有内核，

1600
00:49:45,620 --> 00:49:47,040
0,90 90,180 180,240 240,780
we have the kernel,|
|

1601
00:49:48,190 --> 00:49:52,750
0,540 1740,2370 2940,3630 3630,4140 4140,4560
{} the classic arrangement here
经典安排是让网卡以某种方式获取数据包，

1602
00:49:52,900 --> 00:49:55,090
0,240 240,630 780,1260 1290,2040 2070,2190
is for the NIC to

1603
00:49:55,090 --> 00:49:57,700
0,360 360,570 570,1410 1440,2040
somehow get packets {},|
|

1604
00:49:58,090 --> 00:49:58,990
0,300 300,420 420,660 660,810 810,900
for the NIC when it
对于网卡，当它接收到数据包时会生成中断，

1605
00:49:58,990 --> 00:50:00,490
0,330 330,390 390,840 870,1110 1110,1500
receives a packet to generate

1606
00:50:00,490 --> 00:50:03,790
0,120 120,780 1590,2010 2190,2850 2850,3300
an interrupt| and there's this
|这里有一个中断例程，

1607
00:50:04,120 --> 00:50:05,300
0,780
interrupt

1608
00:50:05,760 --> 00:50:08,070
0,900 1260,1410 1410,1590 1590,2070 2070,2310
routine,| that gets triggered whenever
|当中断来时就会触发，

1609
00:50:08,070 --> 00:50:09,060
0,180 180,240 240,750 750,870 870,990
there's an interrupt| and the
|中断例程的任务是从网卡中获取数据包。

1610
00:50:09,060 --> 00:50:10,440
0,330 330,390 390,450 450,870 870,1380
job of the interrupt routine

1611
00:50:10,740 --> 00:50:12,600
0,300 300,630 780,1320 1320,1470 1470,1860
is to get the packet

1612
00:50:12,600 --> 00:50:14,840
0,150 150,240 240,630
from the NIC.|
|

1613
00:50:14,990 --> 00:50:15,860
0,210 210,480 480,600 600,750 750,870
And because we don't want
因为我们不想专门拿出 CPU 时间

1614
00:50:15,860 --> 00:50:17,630
0,60 60,540 540,960 960,1410 1410,1770
to dedicate CPU time| to
|用于完成数据包的处理，

1615
00:50:17,930 --> 00:50:19,100
0,510 510,600 600,1020 1020,1080 1080,1170
completing the processing of the

1616
00:50:19,100 --> 00:50:21,920
0,360 360,870 1740,2100 2100,2520 2520,2820
packet now,| the interrupt routine
|中断例程通常仅将数据包附加到队列，

1617
00:50:21,920 --> 00:50:24,230
0,390 390,780 990,1650 1650,1740 1740,2310
typically just appends the packet

1618
00:50:24,800 --> 00:50:26,450
0,180 180,270 270,570 570,690 690,1650
to a queue of packets,|
|

1619
00:50:26,600 --> 00:50:29,090
0,780 1110,1440 1440,1770 1770,2370 2370,2490
{} for later processing, and
以便稍后处理，然后返回，

1620
00:50:29,090 --> 00:50:30,560
0,150 150,630 660,1080 1080,1380 1380,1470
then return,| so does the
|所以，所需的最少工作是

1621
00:50:30,560 --> 00:50:33,420
0,360 360,900 1620,2310
minimum work {}

1622
00:50:33,850 --> 00:50:35,170
0,570 570,690 690,960 960,1050 1050,1320
required| to get the packet
|从网卡获取数据包并将其放入队列中，

1623
00:50:35,170 --> 00:50:35,980
0,150 150,240 240,480 480,660 660,810
from the NIC and put

1624
00:50:35,980 --> 00:50:37,060
0,90 90,180 180,270 270,630 720,1080
it in a queue| and
|我们要转移到传统的网络堆栈中的原因，

1625
00:50:37,060 --> 00:50:37,900
0,150 150,450 450,570 570,690 690,840
the reason why we want

1626
00:50:37,900 --> 00:50:39,490
0,90 90,900 900,1110 1110,1230 1290,1590
to transfer in the sort

1627
00:50:39,490 --> 00:50:40,180
0,150
of

1628
00:50:40,210 --> 00:50:41,920
0,450 450,720 720,1170 1290,1560 1560,1710
traditional network stack,| we want
|我们希望快速将数据包从网卡中移出并移入这个软件队列，

1629
00:50:41,920 --> 00:50:43,390
0,120 390,750 750,990 990,1110 1110,1470
to quickly move the packet

1630
00:50:43,390 --> 00:50:44,440
0,150 150,240 240,360 360,780 840,1050
out of the NIC and

1631
00:50:44,440 --> 00:50:45,700
0,240 240,390 390,840 840,1140 1140,1260
into this software queue| is
|因为网卡通常只有非常有限的用于数据包队列的内存，

1632
00:50:45,700 --> 00:50:46,930
0,180 360,750 750,1050 1050,1170 1170,1230
the NIC typically have a

1633
00:50:46,930 --> 00:50:48,280
0,270 270,660 660,900 900,960 960,1350
very limited amount of memory

1634
00:50:48,280 --> 00:50:50,140
0,120 120,420 420,1020 1050,1770 1770,1860
for {queue,in} packets,| whereas in
|而在主内存，计算机的 RAM 中，

1635
00:50:50,140 --> 00:50:51,430
0,90 90,360 360,840 840,960 960,1290
the main memory, the RAM

1636
00:50:51,430 --> 00:50:52,360
0,60 60,150 150,600 600,750 750,930
of the computer,| we might
|我们可能有千兆字节的内存，

1637
00:50:52,360 --> 00:50:53,980
0,120 120,600 600,690 690,1200 1440,1620
have gigabytes of memory,| so
|所以这里有大得多的空间，

1638
00:50:53,980 --> 00:50:55,780
0,270 270,420 420,780 780,1110 1320,1800
far more space here,| so
|所以，网卡，

1639
00:50:55,870 --> 00:50:57,400
0,270 270,570 870,1260 1260,1350 1350,1530
the NIC,| so if there's
|所以，如果出现数据包突发，

1640
00:50:57,400 --> 00:50:58,240
0,60 60,330 330,390 390,750 750,840
a burst of packets| and
|网卡可能没有空间对它们进行排队，

1641
00:50:58,240 --> 00:50:59,440
0,150 150,270 270,720 870,1110 1110,1200
NIC may actually run out

1642
00:50:59,440 --> 00:51:00,460
0,60 60,420 420,510 510,750 750,1020
of space to queue them,|
|

1643
00:51:00,970 --> 00:51:02,110
0,330 330,510 510,600 600,960 960,1140
{} so we copy them
所以，我们将它们复制到这里的队列，

1644
00:51:02,110 --> 00:51:03,480
0,180 180,390 390,690 690,930
this queue here| to
|以避免网卡空间不足。

1645
00:51:03,780 --> 00:51:04,680
0,330 330,390 390,600 600,810 810,900
avoid the NIC running out

1646
00:51:04,680 --> 00:51:06,660
0,60 60,660
of space.|
|

1647
00:51:06,720 --> 00:51:08,460
0,180 180,540 630,1290 1290,1650 1650,1740
And then separately perhaps in
然后可能在单独的线程中，

1648
00:51:08,460 --> 00:51:10,980
0,30 30,420 420,960 990,1710 1740,2520
a separate thread,| there's {}
|这里有我所说的 IP 处理线程，

1649
00:51:12,550 --> 00:51:13,780
0,120 120,540 540,570 570,750 750,1230
{} what I call the

1650
00:51:13,810 --> 00:51:17,720
0,810 810,1470 1470,2190 2580,3270
IP processing thread {},|
|

1651
00:51:18,700 --> 00:51:19,630
0,270 270,660 660,750 750,900 900,930
and sometimes it's not a
有时它不是一个线程，

1652
00:51:19,630 --> 00:51:21,010
0,480 480,870 870,990 990,1260 1260,1380
thread,| sometimes it's sort of
|有时它是一种不同的实体，

1653
00:51:21,010 --> 00:51:22,720
0,420 450,810 810,900 900,1380 1410,1710
different kind of entity,| but
|但它的基本工作是读取这些传入队列的数据包，

1654
00:51:22,720 --> 00:51:24,220
0,120 120,510 510,900 900,1110 1110,1500
its basic job is to

1655
00:51:24,370 --> 00:51:27,340
0,450 1080,1710 1710,2550 2580,2790 2790,2970
{} read packets of these

1656
00:51:27,340 --> 00:51:28,720
0,360 360,750 750,840 840,1110 1140,1380
incoming queues| and there may
|而且可能有多个网卡，

1657
00:51:28,720 --> 00:51:30,850
0,120 120,540 540,1290 1500,2010 2010,2130
be multiple NICs,| {} you
|将数据包追加到这些队列，

1658
00:51:30,850 --> 00:51:31,900
0,120 120,450 450,810 810,870 870,1050
know appending packet to these

1659
00:51:31,900 --> 00:51:33,910
0,570 720,990 990,1380 1380,1650 1650,2010
queues,| so IP thread runs,|
|所以 IP 线程运行，|

1660
00:51:33,910 --> 00:51:35,710
0,150 300,1110 1110,1230 1230,1680 1680,1800
it looks at packets that
它会查看在这里排队的数据包，

1661
00:51:35,710 --> 00:51:37,630
0,240 390,930 930,1230 1230,1530 1530,1920
are queued here| and decides
|并决定如何处理它们。

1662
00:51:37,630 --> 00:51:38,590
0,120 120,210 210,360 360,720 720,960
what to do with them.|
|

1663
00:51:38,650 --> 00:51:40,030
0,390 390,960 960,1050 1050,1170 1170,1380
One possibility is to send
一种可能是通过 UDP 将它们向上发送到套接字层，

1664
00:51:40,030 --> 00:51:42,370
0,120 120,570 750,1320 1320,1440 1440,2340
them up through {UDP -}

1665
00:51:43,100 --> 00:51:44,400
0,720
{

1666
00:51:45,580 --> 00:51:46,870
0,270 270,480 480,600 600,1050 1050,1290
-} into the sockets layer|
|

1667
00:51:46,870 --> 00:51:48,400
0,90 90,210 210,870 960,1410 1410,1530
to be queued waiting for
排队等待某个应用程序，

1668
00:51:48,400 --> 00:51:50,440
0,150 150,900 1050,1500 1500,1890 1890,2040
some application| and typically this
|通常在这里只是一个函数调用，

1669
00:51:50,440 --> 00:51:51,940
0,240 270,600 600,720 720,900 1020,1500
will just be a function

1670
00:51:51,940 --> 00:51:53,830
0,300 300,570 570,870 870,1140 1380,1890
calls here| within the context
|在这个线程的上下文中。

1671
00:51:53,830 --> 00:51:56,100
0,60 60,240 240,720
of this thread.|
|

1672
00:51:56,880 --> 00:51:58,200
0,300 300,990 990,1110 1110,1230 1230,1320
Another possibility,| and this is
另一种可能，|这也是论文关心的可能性是，

1673
00:51:58,200 --> 00:51:59,580
0,180 300,750 750,840 840,1110 1110,1380
the possibility the paper cares

1674
00:51:59,580 --> 00:52:00,780
0,210 210,480 480,600 600,810 900,1200
most about is that| this
|这个主机是一台路由器，

1675
00:52:00,780 --> 00:52:02,040
0,270 270,360 360,600 600,690 690,1260
host is actually a router|
|

1676
00:52:02,220 --> 00:52:03,750
0,150 150,540 780,1170 1170,1230 1230,1530
and it's packets are coming
它的数据包从一个网卡进入，

1677
00:52:03,750 --> 00:52:05,040
0,90 90,420 420,780 780,930 930,1290
in one NIC| and routed
|然后从一个或多个其他网卡路由出去，

1678
00:52:05,040 --> 00:52:06,060
0,300 300,510 510,600 600,780 780,1020
out one or more other

1679
00:52:06,060 --> 00:52:08,000
0,600 720,1470
NICs,| because
|因为在普通操作系统上构建路由器是很常见的，比如 Linux ，

1680
00:52:08,120 --> 00:52:09,260
0,210 210,480 480,780 780,870 870,1140
it's very common to build

1681
00:52:09,260 --> 00:52:11,870
0,480 480,630 630,750 750,1530 1980,2610
routers out of ordinary operating

1682
00:52:11,870 --> 00:52:13,010
0,360 360,510 510,870 870,1020 1020,1140
systems, like Linux,| if you
|如果你购买 WiFi 盒子或有线调制解调路由器或其他设备，

1683
00:52:13,010 --> 00:52:14,420
0,120 120,240 240,690 690,1110 1110,1410
buy a WiFi box now

1684
00:52:14,420 --> 00:52:15,860
0,150 150,210 210,720 720,1050 1050,1440
or a cable modem router

1685
00:52:15,860 --> 00:52:18,080
0,90 90,540 1140,1500 1500,1710 1710,2220
or something,| {} it's extremely
|它很有可能在内部运行 Linux ，

1686
00:52:18,080 --> 00:52:19,520
0,300 300,360 360,540 540,960 990,1440
likely to be running Linux

1687
00:52:19,520 --> 00:52:21,020
0,750 810,1050 1050,1140 1140,1410 1410,1500
internally| and to use the
|并使用标准 Linux 堆栈，

1688
00:52:21,020 --> 00:52:22,730
0,450 450,780 780,1200 1200,1410 1410,1710
standard Linux stack,| which has
|它有完整的路由实现，

1689
00:52:22,730 --> 00:52:25,250
0,60 60,660 660,990 990,1770 2160,2520
a complete router implementation {},|
|

1690
00:52:25,250 --> 00:52:26,180
0,90 90,450 450,720 720,810 810,930
it's highly likely to be
它很可能使用标准 Linux 堆栈来进行路由。

1691
00:52:26,180 --> 00:52:27,320
0,300 300,660
using that

1692
00:52:27,320 --> 00:52:30,050
0,510 510,810 810,1290 2400,2520 2520,2730
standard Linux stack in order

1693
00:52:30,050 --> 00:52:31,560
0,60 60,240 240,390 390,810
to do its routing.|
|

1694
00:52:31,590 --> 00:52:33,030
0,360 450,720 720,870 870,1200 1200,1440
So if the IP thread
所以，如果 IP 线程查看目标 IP 地址，

1695
00:52:33,030 --> 00:52:34,200
0,240 240,300 300,360 360,930 930,1170
looks at the destination IP

1696
00:52:34,200 --> 00:52:35,430
0,300 300,390 390,810 810,1050 1050,1230
address| and decides I should
|决定我应该把这个发送出去，

1697
00:52:35,430 --> 00:52:37,050
0,300 300,480 480,930 1140,1440 1440,1620
send this out,| I should
|我应该把这个包从另一个网络接口转发出去，

1698
00:52:37,050 --> 00:52:38,400
0,330 330,510 510,900 900,1080 1170,1350
forward this packet out you

1699
00:52:38,400 --> 00:52:40,890
0,390 600,810 810,1320 1380,1770 1770,2490
know out another network interface,|
|

1700
00:52:42,900 --> 00:52:44,280
0,330 330,600 600,690 690,1170 1170,1380
it'll add the packet to
它会将数据包添加到这个传出接口的传出数据包队列中，

1701
00:52:44,280 --> 00:52:46,230
0,90 90,360 360,630 630,1080 1080,1950
a queue of outgoing packets

1702
00:52:46,350 --> 00:52:48,510
0,210 210,420 420,900 900,1650 1710,2160
for this outgoing interface| and
|几乎可以肯定的是，

1703
00:52:48,540 --> 00:52:50,130
0,270 270,720 720,1290 1290,1440 1440,1590
there's almost certainly,| so this
|这是一个接收中断， RX 表示接收，

1704
00:52:50,130 --> 00:52:52,000
0,90 90,150 150,660 660,1380
is a receive interrupt,

1705
00:52:52,000 --> 00:52:53,500
0,150 150,420 420,690 690,810 810,1500
{} {RX -} for receive,|
|

1706
00:52:53,950 --> 00:52:55,840
0,510 810,1050 1050,1470 1470,1650 1650,1890
{} there's usually some sort
传出网卡通常有某种传输中断方案，

1707
00:52:55,840 --> 00:52:57,400
0,90 90,990
of transmit

1708
00:52:57,580 --> 00:53:00,000
0,360 360,1020 1050,1860
{} interrupt scheme

1709
00:53:02,190 --> 00:53:03,720
0,360 360,480 480,600 600,1020 1020,1530
{} for the outgoing NIC,|
|

1710
00:53:04,770 --> 00:53:06,900
0,450 870,1350 1350,1680 1710,1980 1980,2130
{} that and NIC will
网卡将会中断，

1711
00:53:06,900 --> 00:53:08,760
0,420 420,750 750,900 900,1590 1590,1860
interrupt,| whenever it's finished sending
|每当发送完一个数据包，

1712
00:53:08,760 --> 00:53:09,840
0,210 210,540 540,660 660,780 780,1080
one packet| and is ready
|并准备好接收更多数据包时，

1713
00:53:09,840 --> 00:53:11,580
0,90 90,240 240,810 840,1050 1050,1740
to be handed more packets,|
|

1714
00:53:12,810 --> 00:53:14,700
0,210 210,600 600,1170 1350,1590 1590,1890
these outgoing interrupts may also
这些传出中断也很重要。

1715
00:53:14,700 --> 00:53:15,660
0,90 90,510
be important.|
|

1716
00:53:16,390 --> 00:53:19,690
0,390 600,1020 1620,1980 2370,2820 2820,3300
{} And the point here
这里的重点是，

1717
00:53:19,720 --> 00:53:20,680
0,210 210,330 330,480 480,570 570,960
is that,| there's a bunch
|这里有一堆并发的实体，

1718
00:53:20,680 --> 00:53:23,620
0,150 150,870 870,1770 1800,2580 2610,2940
of concurrent entities,| {} there's
|有各种不同方式的独立调度，

1719
00:53:23,620 --> 00:53:25,210
0,150 150,210 210,960 960,1500 1500,1590
sort of separately scheduled in

1720
00:53:25,210 --> 00:53:27,190
0,360 360,630 630,1140 1200,1530 1530,1980
various different ways,| these interrupts
|这些中断由网卡触发，

1721
00:53:27,190 --> 00:53:28,510
0,90 90,510 510,630 630,780 780,1320
are triggered by the NICs|
|

1722
00:53:28,540 --> 00:53:30,010
0,420 420,540 540,960 960,1080 1080,1470
asking for interrupts when packets
当数据包到达或发送是，发生中断，

1723
00:53:30,010 --> 00:53:31,090
0,450 450,480 480,660 660,990 990,1080
arrive or when packets have

1724
00:53:31,090 --> 00:53:33,580
0,90 90,570 840,1470 1470,2010 2010,2490
been sent,| this thread maybe
|这个线程可能是我们在 xv6 中拥有的内核线程，

1725
00:53:33,580 --> 00:53:34,640
0,600
{}

1726
00:53:35,330 --> 00:53:36,440
0,270 270,600 600,900 900,1020 1020,1110
a kernel thread like we

1727
00:53:36,440 --> 00:53:38,480
0,210 210,330 330,1230 1260,1800 1890,2040
have in xv6,| {} in
|在单个处理器中，

1728
00:53:38,480 --> 00:53:40,730
0,180 180,420 420,1170 1170,1950 2010,2250
a uniq processor,| as was
|比如在今天论文中的情况，

1729
00:53:40,730 --> 00:53:42,170
0,90 90,480 480,630 630,960 960,1440
the case with today's paper,|
|

1730
00:53:42,470 --> 00:53:43,880
0,420 420,720 720,960 960,1320 1320,1410
this thread can't run at
这个线程不能同时运行，

1731
00:53:43,880 --> 00:53:45,110
0,90 90,330 330,600 600,720 720,1230
the same time,| as interrupt,
|中断有绝对优先级，

1732
00:53:45,110 --> 00:53:47,060
0,540 540,930 930,1530 1560,1920 1920,1950
interrupt absolute priority,| on a
|在多核计算机上，可能会有更多的并行性，

1733
00:53:47,060 --> 00:53:48,860
0,240 240,420 420,1140 1440,1650 1650,1800
{multi-core -} machine, {} there

1734
00:53:48,860 --> 00:53:50,630
0,120 120,240 240,420 420,1200 1410,1770
may be more parallelism| and
|然后，重要的是应用程序要能够读取数据包，

1735
00:53:50,630 --> 00:53:52,160
0,210 210,390 390,780 780,930 930,1530
then it's important that applications

1736
00:53:52,160 --> 00:53:52,880
0,60 60,150 150,330 330,480 480,720
to be able to read

1737
00:53:52,880 --> 00:53:54,800
0,60 60,630 840,1170 1170,1320 1320,1920
the packets,| {} the applications
|应用程序是另一个独立调度的实体，

1738
00:53:54,800 --> 00:53:57,440
0,150 150,420 420,1050 1500,2130 2130,2640
are yet another independently scheduled

1739
00:53:57,440 --> 00:53:59,460
0,780
entities,|
|

1740
00:53:59,660 --> 00:54:01,490
0,210 210,420 420,600 600,1410 1710,1830
{} that we'd like to
我们希望得到机会在 CPU 上执行。

1741
00:54:01,490 --> 00:54:03,530
0,150 150,270 270,750 840,1320 1470,2040
get the chance {} executing

1742
00:54:03,530 --> 00:54:04,900
0,90 90,180 180,690
on the CPU.|
|

1743
00:54:06,240 --> 00:54:07,500
0,450 750,1020 1020,1080 1080,1170 1170,1260
So these are all the
所以这些是在调度游戏中的所有玩家。

1744
00:54:07,500 --> 00:54:10,340
0,660 660,840 840,1230
players in the,

1745
00:54:11,880 --> 00:54:13,350
0,180 180,660 660,840 840,930 930,1470
and that's in the scheduling

1746
00:54:13,350 --> 00:54:14,900
0,270 270,930
game essentially.|
|

1747
00:54:15,280 --> 00:54:16,300
0,450

1748
00:54:17,970 --> 00:54:20,240
0,600 870,1260 1260,1500 1500,1770
{} One thing that
有一件经常出现的事是缓冲区，

1749
00:54:20,270 --> 00:54:21,890
0,390 390,510 510,570 570,990 990,1620
comes up a lot is

1750
00:54:21,950 --> 00:54:24,230
0,270 270,1050 1080,1320 1320,1800 2130,2280
{} buffering,| so there's a
|所以这里有三个队列，

1751
00:54:24,230 --> 00:54:26,870
0,720 720,1380 1380,1710 1740,2190 2190,2640
three queues here,| by buffering,
|通过缓冲，我指的是，

1752
00:54:26,870 --> 00:54:28,700
0,90 90,540 690,1230 1230,1770 1770,1830
I mean,| these structures in
|这些结构附加输入数据包，

1753
00:54:28,700 --> 00:54:31,520
0,390 420,960 960,1440 1440,1830 1830,2820
which one append, it appends

1754
00:54:31,550 --> 00:54:32,810
0,210 210,540 540,960 960,1080 1080,1260
{} input packets| and some
|并且一些其他实体轮询队列前面的数据包，

1755
00:54:32,810 --> 00:54:35,210
0,210 210,780 930,1740 1740,2160 2160,2400
other entity polls packets of

1756
00:54:35,210 --> 00:54:36,470
0,240 240,660 660,720 720,840 840,1260
the front of the queue,|
|

1757
00:54:36,830 --> 00:54:38,450
0,360 360,600 600,870 870,960 960,1620
{} these queues are pervasive
这些队列在网络系统中无处不在。

1758
00:54:38,450 --> 00:54:40,120
0,150 150,540 540,1290
in networking systems.|
|

1759
00:54:40,150 --> 00:54:41,260
0,540

1760
00:54:41,490 --> 00:54:43,020
0,450 450,780 780,1080 1080,1230 1230,1530
{} One reason for them
其中一个原因是

1761
00:54:43,200 --> 00:54:44,700
0,300 300,420 420,630 630,1200 1200,1500
is| to allow temporary to
|为了应对临时性的突发，

1762
00:54:44,940 --> 00:54:47,190
0,360 360,420 420,990 990,1680 1800,2250
cope {} temporary bursts,| this
|这个 IP 线程可能只能以每秒多少的速度处理数据包，

1763
00:54:47,190 --> 00:54:48,330
0,360 360,600 600,840 840,960 960,1140
IP thread maybe can only

1764
00:54:48,330 --> 00:54:49,800
0,390 390,840 840,960 960,1320 1320,1470
process packets at however any

1765
00:54:49,800 --> 00:54:51,750
0,120 120,720 960,1350 1350,1440 1440,1950
per second,| but the NIC
|但是网卡可能能够更快地传送数据包，

1766
00:54:51,750 --> 00:54:53,130
0,240 240,390 390,780 870,1020 1020,1380
may be able to deliver

1767
00:54:53,130 --> 00:54:55,110
0,360 360,570 570,690 690,1290 1470,1980
packets much more quickly| and
|所以这里可能会有一些临时的数据包突发，

1768
00:54:55,110 --> 00:54:55,590
0,90 90,180 180,300 300,420 420,480
so there may be a

1769
00:54:55,590 --> 00:54:57,030
0,300 360,690 690,750 750,1140 1140,1440
little sort of temporary burst

1770
00:54:57,030 --> 00:54:58,200
0,60 60,630 660,930 930,1080 1080,1170
of packets,| we'd like to
|我们希望有一个地方存放它们，

1771
00:54:58,200 --> 00:54:59,340
0,150 150,390 390,450 450,810 810,1140
have somewhere to put them|
|

1772
00:54:59,670 --> 00:55:01,800
0,600 870,1380 1380,1500 1500,1710 1710,2130
{} waiting for the IP
等待 IP 线程开始处理，

1773
00:55:01,800 --> 00:55:02,610
0,300 300,390 390,510 510,750 750,810
thread to get around to

1774
00:55:02,610 --> 00:55:04,530
0,630 720,840 840,1140 1470,1650 1650,1920
processing| and so that's one
|这是队列的一种用途，

1775
00:55:04,530 --> 00:55:05,780
0,180 180,240 240,930
use of queues,|
|

1776
00:55:06,160 --> 00:55:07,900
0,330 450,690 690,780 780,1140 1140,1740
{} on the output side,|
在输出端，|

1777
00:55:08,260 --> 00:55:09,520
0,390 390,690 690,870 870,960 960,1260
{} another use of queues
我们希望使用队列的另一种方式，

1778
00:55:09,520 --> 00:55:11,710
0,120 120,300 300,540 540,810 1320,2190
as we'd like to,| especially
|特别是如果数据包突发，

1779
00:55:11,710 --> 00:55:12,760
0,60 60,420 420,510 510,930 930,1050
if packets are bursting,| we'd
|我们希望能够在这里存放一些数据包，

1780
00:55:12,760 --> 00:55:13,570
0,150 150,210 210,300 300,480 480,810
like to be able to

1781
00:55:13,600 --> 00:55:14,590
0,510 510,660 660,720 720,930 930,990
stack up a bunch of

1782
00:55:14,590 --> 00:55:16,390
0,480 480,960 1110,1560 1560,1680 1680,1800
packets here,| ready for the
|准备网卡发送，

1783
00:55:16,390 --> 00:55:17,290
0,180 180,300 300,630 630,690 690,900
NIC to send,| to keep
|保持输出网卡忙，

1784
00:55:17,290 --> 00:55:19,330
0,120 120,450 720,870 870,1500 1710,2040
the NIC to output NIC

1785
00:55:19,330 --> 00:55:21,790
0,480 690,1350 1470,2130 2130,2400 2400,2460
busy,| {} because depending on
|因为根据速度的不同，

1786
00:55:21,790 --> 00:55:22,540
0,60 60,360 360,450 450,690 690,750
the speed of things,| it
|它很重要，

1787
00:55:22,540 --> 00:55:23,740
0,120 120,210 210,450 450,870 870,1200
may be quite important| to
|能够在这里以 100% 利用网络。

1788
00:55:23,890 --> 00:55:24,790
0,210 210,360 360,420 420,780 780,900
be able to hunt to

1789
00:55:24,790 --> 00:55:26,770
0,570 570,960 960,1530 1530,1650 1650,1980
utilize {100% -} of the

1790
00:55:27,100 --> 00:55:28,600
0,720 720,1050
network here.|
|

1791
00:55:29,120 --> 00:55:30,200
0,480

1792
00:55:30,840 --> 00:55:31,800
0,180 180,270 270,450 450,750 750,960
And the other reason for
另一个原因是，

1793
00:55:31,800 --> 00:55:32,680
0,180
it,|
|

1794
00:55:33,120 --> 00:55:34,560
0,420 420,510 510,780 780,1080 1080,1440
maybe the same reason stated
也许与排队的原因不同，

1795
00:55:34,560 --> 00:55:36,120
0,420 420,540 540,750 750,1140 1140,1560
differently for having queues is|
|

1796
00:55:36,120 --> 00:55:37,140
0,90 90,180 180,330 330,420 420,1020
to be able to structure
能够将软件组织成单独调度的独立部分，

1797
00:55:37,140 --> 00:55:40,020
0,690 900,1350 1350,2040 2040,2730 2730,2880
software into independent parts that

1798
00:55:40,020 --> 00:55:42,750
0,60 60,570 570,1320 1890,2190 2190,2730
are scheduled separately,| wouldn't necessarily
|不需要 IP 线程或应用程序

1799
00:55:42,750 --> 00:55:44,100
0,180 180,240 240,450 450,780 810,1350
want to have our IP

1800
00:55:44,100 --> 00:55:46,110
0,300 300,390 390,540 540,1470 1560,2010
thread or the application| know
|知道必须进行的其他事情，

1801
00:55:46,110 --> 00:55:47,400
0,390 390,540 540,810 810,1170 1170,1290
about the other things that

1802
00:55:47,400 --> 00:55:48,420
0,150 150,270 270,450 450,780 780,1020
have to go on,| like
|比如中断处理，

1803
00:55:48,420 --> 00:55:50,970
0,390 390,960 1200,1470 1470,1770 2100,2550
interrupt processing,| so the IP
|所以 IP 线程是一种传统的网络系统，

1804
00:55:50,970 --> 00:55:52,380
0,270 270,750 780,1020 1020,1140 1140,1410
thread is sort of a

1805
00:55:52,560 --> 00:55:55,290
0,480 750,1320 1320,1740 2040,2520 2520,2730
traditional networking system,| it doesn't
|它不需要知道中断何时发生或应用程序何时运行，

1806
00:55:55,290 --> 00:55:57,380
0,570 570,1140
necessarily know

1807
00:55:58,390 --> 00:56:00,970
0,900 1140,1620 1620,2130 2130,2220 2220,2580
when interrupts happen or when

1808
00:56:00,970 --> 00:56:03,250
0,690 690,930 930,1440 1830,2130 2130,2280
applications run,| although we'll see
|虽然我们将在这篇论文中看到，

1809
00:56:03,250 --> 00:56:04,630
0,60 60,210 210,630 630,870 1200,1380
in this paper,| that there
|在那里有一点了解可能是有好处的。

1810
00:56:04,630 --> 00:56:05,830
0,120 120,240 240,870 870,990 990,1200
may be advantages to having

1811
00:56:05,830 --> 00:56:06,610
0,60 60,240 240,330 330,390 390,780
a little bit of knowledge

1812
00:56:06,610 --> 00:56:07,460
0,300
there.|
|

1813
00:56:11,260 --> 00:56:14,110
0,420 420,630 630,1110 1440,2430 2430,2850
Questions about this scheduling control
对于这个调度控制图，有什么问题吗？

1814
00:56:14,110 --> 00:56:15,300
0,570
diagram?|
|

1815
00:56:19,620 --> 00:56:21,270
0,360 450,510 510,660 660,960 990,1650
Oh, I have a question,|
哦，我有个问题，|

1816
00:56:21,300 --> 00:56:22,860
0,570 600,810 810,900 900,1260 1260,1560
so can the same NIC
同一个网卡能不能同时用于发送和接收？

1817
00:56:22,860 --> 00:56:25,290
0,210 210,360 360,930 1440,1890 1890,2430
now be used for both

1818
00:56:25,290 --> 00:56:29,160
0,600 600,750 750,1290 3360,3720 3720,3870
transmitting and receiving?| {It,can,,so} my
|它可以，实际上我的笔记本电脑只有一个网卡，

1819
00:56:29,160 --> 00:56:30,570
0,540 540,810 810,1020 1020,1140 1140,1410
laptop really only has one

1820
00:56:30,570 --> 00:56:32,820
0,600 600,870 1320,1800 1800,2160 2160,2250
interface| and it connected to
|它连接到 WiFi ，

1821
00:56:32,820 --> 00:56:34,230
0,780 810,990 990,1050 1050,1380 1380,1410
WiFi,| when it receives a
|当它收到一个数据包，

1822
00:56:34,230 --> 00:56:36,030
0,450 450,810 990,1200 1200,1350 1350,1800
packet,| this on my laptop,|
|在我的笔记本电脑上，|

1823
00:56:36,030 --> 00:56:36,720
0,150 150,300 300,390 390,630 630,690
this NIC is actually a
这个网卡是一个 WiFi 无线电接口，

1824
00:56:36,720 --> 00:56:37,940
0,780
WiFi

1825
00:56:38,260 --> 00:56:41,500
0,450 450,1050 1200,1650 1650,2820 3090,3240
radio interface,| packets arrive and
|数据包在同一网卡上到达和传出。

1826
00:56:41,500 --> 00:56:42,190
0,150 150,300 300,360 360,450 450,690
go out on the same

1827
00:56:42,190 --> 00:56:45,610
0,360 750,810 1350,1740 1740,2430 2460,3420
NIC.| {} The {two,NIC} situation
|两个网卡的情况用于路由器，

1828
00:56:46,170 --> 00:56:47,850
0,150 150,540 540,690 690,810 810,1680
is certainly used for routers,|
|

1829
00:56:48,150 --> 00:56:51,420
0,480 600,810 810,1230 1230,2310 2340,3270
{} so your home WiFi,|
所以你家里的 WiFi ，|

1830
00:56:51,420 --> 00:56:52,500
0,60 60,150 150,330 330,810 810,1080
I don't know, maybe I
我不知道，也许我有 WiFi 和有线，

1831
00:56:52,500 --> 00:56:53,940
0,240 240,660 660,780 780,1320 1320,1440
have WiFi and cable| and
|还有一个路由器盒子，它有两个网卡，

1832
00:56:53,940 --> 00:56:56,100
0,150 150,270 270,600 600,1320 1410,2160
there's a router box {},

1833
00:56:56,310 --> 00:56:58,170
0,270 270,660 660,870 870,1470 1500,1860
that has two NICs,| one
|一个连接到我的电缆调制解调器，

1834
00:56:58,170 --> 00:56:59,940
0,390 510,1260
is the

1835
00:56:59,940 --> 00:57:01,200
0,180 180,570 570,690 690,930 930,1260
its connection to my cable

1836
00:57:01,200 --> 00:57:02,160
0,300 300,480 480,660 660,750 750,960
modem,| which leaves the rest
|剩下的是互联网，

1837
00:57:02,160 --> 00:57:02,940
0,60 60,150 150,600 600,690 690,780
of the Internet| and the
|还有一个是我的 WiFi 接口，

1838
00:57:02,940 --> 00:57:04,800
0,150 150,360 360,510 510,870 930,1860
other one is my WiFi

1839
00:57:05,840 --> 00:57:07,610
0,930 1140,1290 1290,1470 1470,1590 1590,1770
Interface,| so that the little
|所以这个小盒子，

1840
00:57:07,610 --> 00:57:08,920
0,510 510,720
box,| that
|电缆调制解调器发送，

1841
00:57:09,140 --> 00:57:10,790
0,330 330,660 660,960 960,1350 1350,1650
the cable modem cable []

1842
00:57:10,790 --> 00:57:12,020
0,240 240,390 390,510 510,630 630,1230
sent me| as a router
|作为一个路由器有两个网络接口。

1843
00:57:12,110 --> 00:57:15,680
0,150 150,330 330,630 630,1350 3240,3570
with two network interfaces.| And
|实际上很多服务器也有多个接口，

1844
00:57:15,770 --> 00:57:16,580
0,270 270,510 510,540 540,720 720,810
there's actually a lot of

1845
00:57:16,580 --> 00:57:19,340
0,570 570,720 720,1470 1530,2220 2220,2760
servers have multiple interfaces also,|
|

1846
00:57:20,360 --> 00:57:21,620
0,630 630,840 840,930 930,1020 1020,1260
especially ones that are web
尤其是那些 web 服务器，

1847
00:57:21,620 --> 00:57:23,000
0,450 450,630 750,1170 1170,1320 1320,1380
servers,| that you want to
|你想要与外部世界交互，

1848
00:57:23,000 --> 00:57:24,560
0,240 240,330 330,420 420,810 810,1560
talk to the outside world,|
|

1849
00:57:25,270 --> 00:57:26,380
0,240 240,360 360,690 690,840 840,1110
well, {} one {interface -}
一个接口发送到你的私有敏感数据库机器或其他什么，

1850
00:57:26,380 --> 00:57:28,120
0,330 330,570 570,1110
sent your private

1851
00:57:28,120 --> 00:57:30,670
0,480 480,1200 1200,1830 1830,1920 1920,2550
sensitive database machine or something|
|

1852
00:57:31,030 --> 00:57:32,500
0,210 210,270 270,600 600,960 960,1470
on a totally separate network
在具有另一个网络接口的完全独立的网络上，

1853
00:57:32,890 --> 00:57:35,620
0,240 240,720 930,1230 1230,1830 2220,2730
with another network interface,| this
|这种安排是相当常见的。

1854
00:57:35,620 --> 00:57:37,540
0,690 690,750 750,900 900,1170 1710,1920
arrangement is pretty common.| {So,the}
|所以，有多个网卡的原则是

1855
00:57:37,540 --> 00:57:39,190
0,600 600,690 690,990 990,1350 1350,1650
criteria for having multiple NICs

1856
00:57:39,190 --> 00:57:40,930
0,180 180,570 660,1440 1440,1530 1530,1740
is| just wanting to talk
|想与不同的网络通信。

1857
00:57:40,930 --> 00:57:42,660
0,90 90,360 360,930 930,1260
to different networks then.|
|

1858
00:57:42,880 --> 00:57:44,740
0,780 780,1560 1560,1650 1650,1800 1800,1860
Yeah, if you want to
是的，如果你想与不同的网络通信，

1859
00:57:44,740 --> 00:57:46,120
0,150 150,210 210,450 450,1080 1170,1380
talk to different networks,| then
|那么你有多个网卡，是的。

1860
00:57:46,120 --> 00:57:47,440
0,150 150,300 300,600 600,960 960,1320
you have multiple NICs, yes.|
|

1861
00:57:52,070 --> 00:57:53,210
0,330 330,390 390,810 810,1020 1020,1140
Alright, I wanna as I
好的，像我所说的，

1862
00:57:53,210 --> 00:57:54,410
0,630 630,840 840,870 870,1050 1050,1200
said,| talk a little bit
|多谈一点关于网卡的事情，

1863
00:57:54,410 --> 00:57:57,470
0,300 300,750 750,1020 1560,2820 2820,3060
more about {} NICs,| what
|网卡在数据包到达时如何处理它们，

1864
00:57:57,470 --> 00:57:58,520
0,270 270,420 420,540 540,930 930,1050
NICs do with packets when

1865
00:57:58,520 --> 00:57:59,270
0,60 60,390 390,480 480,600 600,750
they arrive,| and this is
|这与实验有关系。

1866
00:57:59,270 --> 00:58:01,940
0,930 930,1800 1890,2430 2430,2520 2520,2670
a special relevance to the

1867
00:58:01,940 --> 00:58:06,620
0,810 960,1530 2580,3060 3060,4050 4050,4680
lab.| { -} You {}
|网卡内部是什么样子，

1868
00:58:06,830 --> 00:58:08,390
0,150 150,420 420,990 990,1290 1290,1560
you know what NIC looks

1869
00:58:08,390 --> 00:58:09,980
0,210 210,960
like internally,|
|

1870
00:58:09,980 --> 00:58:11,240
0,630

1871
00:58:11,330 --> 00:58:12,770
0,270 270,330 330,480 480,630 630,1440
you know it's got a
它有一根电缆或无线电从外面的世界通向那里，

1872
00:58:12,770 --> 00:58:14,720
0,450 450,900 900,1170 1170,1650 1650,1950
cable leading {or,a} radio leading

1873
00:58:14,720 --> 00:58:16,280
0,120 120,450 780,1080 1080,1170 1170,1560
to the from the outside

1874
00:58:16,280 --> 00:58:18,470
0,510 660,1050 1290,1920 1920,2010 2010,2190
world,| {} you know it
|当电子进来的时候，它查看它们，

1875
00:58:18,470 --> 00:58:19,670
0,270 270,330 330,990 990,1080 1080,1200
looks at electrons as they

1876
00:58:19,670 --> 00:58:20,960
0,240 240,480 480,750 780,1020 1020,1290
come in| and sort of
|把它们变成数据包。

1877
00:58:21,110 --> 00:58:22,840
0,300 300,390 390,570 570,1320
turns them into packets.|
|

1878
00:58:23,020 --> 00:58:24,670
0,360 840,1200 1200,1380 1380,1560 1560,1650
{} And then there's the
然后这里是主机，

1879
00:58:24,670 --> 00:58:26,680
0,810 840,1410 1500,1680 1680,1950 1950,2010
host,| {} and there's the
|主机里面有某种驱动软件，

1880
00:58:26,680 --> 00:58:27,820
0,330 330,480 480,690 690,750 750,1140
host some sort of driver

1881
00:58:27,820 --> 00:58:29,950
0,510 510,660 660,810 1290,1650 1800,2130
software in it,| {} and
|不管怎样，

1882
00:58:29,980 --> 00:58:31,660
0,390 390,570 570,660 660,1200 1290,1680
one way or another,| you
|我们需要将在网卡中解码的数据包放入内存，

1883
00:58:31,660 --> 00:58:32,410
0,90 90,210 210,420 420,540 540,750
know we need to get

1884
00:58:32,410 --> 00:58:34,240
0,510 510,930 930,1230 1230,1740 1740,1830
a packet that's decoded in

1885
00:58:34,240 --> 00:58:36,730
0,120 120,600 660,1200 1200,1890 2130,2490
the NIC into memory {}|
|

1886
00:58:36,730 --> 00:58:39,100
0,300 300,630 630,1050 1050,1920
where the IP software
其中 IP 软件和主机可以解析这个数据包，

1887
00:58:39,100 --> 00:58:40,480
0,90 90,150 150,660 660,1050 1080,1380
and the host can parse

1888
00:58:40,480 --> 00:58:42,160
0,150 150,480 1200,1410 1410,1500 1500,1680
that packet| and so there's
|所以这些年来设计了很多不同的方案，

1889
00:58:42,160 --> 00:58:43,180
0,90 90,240 240,330 330,600 600,1020
a lot of different schemes

1890
00:58:43,180 --> 00:58:44,680
0,210 210,750 750,900 900,990 990,1500
been designed over the years,|
|

1891
00:58:44,710 --> 00:58:46,640
0,270 270,720 720,1380
the paper scheme
论文的方案是网卡具有很多内存，

1892
00:58:46,640 --> 00:58:47,810
0,210 210,450 480,720 720,960 960,1170
is that the NIC has

1893
00:58:47,810 --> 00:58:49,760
0,390 390,630 630,780 840,1470 1470,1950
a lot of internal memory,|
|

1894
00:58:49,760 --> 00:58:51,770
0,90 90,240 240,660 660,1380 1680,2010
and as packets arrive,| the
当数据包到达时，|唯一立即发生的事情是

1895
00:58:51,770 --> 00:58:52,740
0,420
only,

1896
00:58:52,740 --> 00:58:53,730
0,120 120,300 300,720 720,870 870,990
the only immediate thing that

1897
00:58:53,730 --> 00:58:54,990
0,390 390,540 540,690 690,930 930,1260
happens is| that NIC puts
|网卡将数据包放入自己的缓冲存储器中，

1898
00:58:54,990 --> 00:58:56,160
0,120 120,510 510,720 720,780 780,1170
{you,know} lays down the packets

1899
00:58:56,160 --> 00:58:57,510
0,90 90,270 270,480 480,780 780,1350
in its own buffer memory,|
|

1900
00:58:58,090 --> 00:58:59,260
0,390 390,600
that's it.|
就是这样。|

1901
00:58:59,880 --> 00:59:01,820
0,180 180,810 810,1050 1050,1350
And interrupts the {}
并且中断主机，

1902
00:59:02,320 --> 00:59:03,970
0,270 270,690 690,780 780,1350 1380,1650
host {} the host| and
|网卡有一个内部的数据包队列和一堆内存，

1903
00:59:03,970 --> 00:59:05,170
0,120 120,360 360,480 480,870 930,1200
said that the NIC has

1904
00:59:05,170 --> 00:59:07,060
0,90 90,570 570,1260 1290,1410 1410,1890
an internal queue of packets

1905
00:59:07,060 --> 00:59:07,930
0,90 90,150 150,360 360,450 450,870
and a bunch of memory|
|

1906
00:59:07,990 --> 00:59:09,580
0,330 330,540 540,690 690,870 870,1590
and then in the interrupt
然后在中断，在主机驱动程序中，

1907
00:59:09,760 --> 00:59:11,920
0,330 330,570 600,1290 1290,1860 1950,2160
in the host driver,| the
|主机驱动中有一个循环，

1908
00:59:11,920 --> 00:59:12,850
0,180 180,390 390,570 570,630 630,930
host driver has a loop

1909
00:59:12,850 --> 00:59:13,840
0,120 120,300 330,450 450,660 660,990
in it,| the host driver
|主机驱动程序会与它们交互，

1910
00:59:13,870 --> 00:59:14,500
0,120 120,360 360,420 420,540 540,630
will talk to them,| they
|它们可以说任何缓冲的数据包，

1911
00:59:14,500 --> 00:59:15,340
0,120 120,390 390,510 510,660 660,840
can say you know any

1912
00:59:15,340 --> 00:59:16,900
0,510 510,1020 1140,1380 1380,1470 1470,1560
packets buffered,| and if it
|如果是这样，

1913
00:59:16,900 --> 00:59:18,580
0,540 840,1170 1170,1260 1260,1530 1530,1680
does,| now the host has
|主机有一个循环，

1914
00:59:18,580 --> 00:59:19,630
0,300 300,690 690,780 780,870 870,1050
a loop,| that will just
|它会逐个字节或逐个字地复制，

1915
00:59:19,630 --> 00:59:21,010
0,390 390,480 480,720 780,930 930,1380
copy you know by byte

1916
00:59:21,010 --> 00:59:22,260
0,90 90,270 270,420 420,840
or word by word,|
|

1917
00:59:22,260 --> 00:59:24,300
0,300 300,480 480,990 1170,1650 1650,2040
copy this packet into the
将这个数据包复制到主机的内存中，

1918
00:59:24,780 --> 00:59:26,400
0,840 840,930 930,1020 1020,1470 1470,1620
memory of the host| and
|并附加到主机内部的队列中，

1919
00:59:26,400 --> 00:59:28,410
0,510 510,630 630,720 720,1350 1710,2010
appended to a queue {}

1920
00:59:28,410 --> 00:59:30,090
0,390 390,480 480,990 1200,1380 1380,1680
inside the host,| so that's
|所以这就是论文中网卡的运作方式，

1921
00:59:30,090 --> 00:59:32,790
0,150 150,420 840,1590 1590,1980 1980,2700
how the paper's NIC works,|
|

1922
00:59:33,180 --> 00:59:34,880
0,420 420,1050
the drivers
驱动程序负责执行从网卡内存复制到主机内存。

1923
00:59:34,910 --> 00:59:36,110
0,210 210,720 720,840 840,1110 1110,1200
is responsible for doing the

1924
00:59:36,110 --> 00:59:37,670
0,360 360,510 510,780 780,1290 1350,1560
copy from NIC memory to

1925
00:59:37,670 --> 00:59:39,820
0,300 300,660
host memory.|
|

1926
00:59:39,880 --> 00:59:40,360
0,150 150,270 270,300 300,420 420,480
That made a lot of
这在 30 年前很有意义，

1927
00:59:40,360 --> 00:59:42,340
0,240 240,480 480,690 690,1080 1350,1980
sense 30 years ago {},|
|

1928
00:59:42,880 --> 00:59:44,080
0,330 330,510 510,630 630,930 930,1200
today though it turns out
今天，在 CPU 中复制的循环

1929
00:59:44,080 --> 00:59:45,880
0,360 570,1140 1140,1230 1230,1290 1290,1800
that loops in the CPU

1930
00:59:45,880 --> 00:59:48,700
0,150 150,1020 1200,1830 2130,2460 2640,2820
that copy,| {} that you
|与外部硬件或在总线上的硬件交互非常非常慢，

1931
00:59:48,700 --> 00:59:50,140
0,180 210,510 510,600 600,990 990,1440
know talk to external hardware

1932
00:59:50,140 --> 00:59:51,490
0,120 120,540 540,810 810,930 930,1350
or hardware sitting on buses

1933
00:59:51,490 --> 00:59:52,720
0,240 270,570 570,780 780,1080 1080,1230
are very very slow,| this
|在微处理器设计的宏观方案中，

1934
00:59:52,720 --> 00:59:54,910
0,360 360,450 1290,1500 1500,1680 1890,2190
sort of you know in

1935
00:59:54,910 --> 00:59:57,730
0,210 210,600 600,1140 1140,1500 2010,2820
the grand scheme of microprocessor

1936
00:59:57,730 --> 01:00:00,220
0,510 540,990 990,1740 1740,2070 2070,2490
design,| this distance here between
|CPU 和外部设备之间的距离，

1937
01:00:00,220 --> 01:00:03,520
0,300 330,1260 1290,1740 2190,2430 2790,3300
the CPU and an external

1938
01:00:03,520 --> 01:00:04,660
0,630 660,840 840,930 930,1050 1050,1140
device,| even if it's on
|即使它在同一台计算机上，

1939
01:00:04,660 --> 01:00:05,740
0,90 90,750
the same

1940
01:00:06,000 --> 01:00:07,560
0,810 1050,1230 1230,1290 1290,1350 1350,1560
computer,| this is a very
|这是一段非常远的距离，

1941
01:00:07,560 --> 01:00:09,930
0,210 210,570 570,990 1110,1620 1680,2370
long distance| and each conversation
|今天的每一次交互都需要很长的时间，

1942
01:00:09,930 --> 01:00:11,580
0,540 570,810 810,870 870,1140 1140,1650
today takes a long time|
|

1943
01:00:11,610 --> 01:00:12,900
0,60 60,420 420,870 870,1110 1110,1290
to reach back for chit
互相交互，

1944
01:00:12,900 --> 01:00:14,010
0,330 330,570 660,870 870,960 960,1110
chat| and so you don't
|所以你不想有太多的字节交互，

1945
01:00:14,010 --> 01:00:14,610
0,120 120,180 180,300 300,360 360,600
want to have a lot

1946
01:00:14,610 --> 01:00:16,100
0,120 120,900
of byte

1947
01:00:16,430 --> 01:00:18,860
0,180 180,870 1350,1620 1620,1920 1980,2430
{} interaction,| {} so people
|所以人们不再设计这样的高速接口了。

1948
01:00:18,920 --> 01:00:21,140
0,570 570,1050 1050,1530 1530,2070 2070,2220
don't design high-speed interfaces like

1949
01:00:21,140 --> 01:00:23,580
0,210 210,660
this anymore.|
|

1950
01:00:24,420 --> 01:00:25,500
0,240 240,300 300,510 510,630 630,1080
So a much more modern
所以一个更现代的安排看起来是这样的，

1951
01:00:25,500 --> 01:00:27,600
0,870
arrangement

1952
01:00:27,780 --> 01:00:29,250
0,240 240,390 390,870 960,1140 1140,1470
looks like this,| so now
|所以，现在我要讨论一种安排，

1953
01:00:29,250 --> 01:00:30,380
0,180 180,540
I'm gonna

1954
01:00:30,690 --> 01:00:32,130
0,330 330,480 480,570 570,1050 1050,1440
talk about an arrangement| which
|在 E1000 网卡上的一种安排，

1955
01:00:32,340 --> 01:00:33,990
0,300 300,630 630,930 930,1230 1230,1650
{} shows up in the

1956
01:00:34,640 --> 01:00:37,100
0,510 540,870 870,1350 1350,1890
{} {E1000 -} NIC,|
|

1957
01:00:38,230 --> 01:00:40,120
0,270 270,450 450,1260
which you'll use
你将在实验中使用或模拟它。

1958
01:00:40,450 --> 01:00:42,460
0,420 420,510 510,1140 1230,1380 1380,2010
in the lab or simulation

1959
01:00:42,460 --> 01:00:43,820
0,90 90,300 300,810
of it.| So,
|所以， E1000 网卡的工作方式，

1960
01:00:43,820 --> 01:00:44,900
0,150 150,240 240,330 330,480 480,1080
{you,know} the way the {E1000,NIC,works

1961
01:00:44,900 --> 01:00:46,380
0,960
-},|
|

1962
01:00:47,110 --> 01:00:48,160
0,240 240,390 390,510 510,960 960,1050
so has this wire and
有这根电线，它查着电子，

1963
01:00:48,160 --> 01:00:49,240
0,150 150,330 330,420 420,480 480,1080
it's looking at the electrons,|
|

1964
01:00:49,240 --> 01:00:51,580
0,210 300,990 990,1080 1080,1620 1620,2340
but as the packets arrive,|
但当数据包到达时，|

1965
01:00:51,610 --> 01:00:55,240
0,630 630,1260 1710,2250 2250,2730 3180,3630
the NIC writes them,| NIC
网卡写入它们，|网卡没有显著的内部缓冲，

1966
01:00:56,450 --> 01:00:58,190
0,390 390,660 660,810 810,1320 1320,1740
doesn't really have significant internal

1967
01:00:58,190 --> 01:00:59,030
0,420 420,600 600,660 660,780 780,840
buffering,| although it has a
|尽管它有一点，

1968
01:00:59,030 --> 01:01:00,440
0,210 210,450
little bit,|
|

1969
01:01:00,440 --> 01:01:01,730
0,150 150,420 420,810 810,900 900,1290
it actually copies the packets
它将数据包直接复制到主机内存中，

1970
01:01:01,730 --> 01:01:03,260
0,450 450,630 630,960 960,1260 1260,1530
directly into host memory| where
|在那里，它们在主机内存中，

1971
01:01:03,260 --> 01:01:04,400
0,300 300,390 390,810 810,1020 1020,1140
they'll be sitting there in

1972
01:01:04,400 --> 01:01:05,960
0,300 300,720 750,1350 1350,1470 1470,1560
host memory,| waiting for the
|等待驱动把已经复制好的它们取走，

1973
01:01:05,960 --> 01:01:06,950
0,330 330,420 420,660 660,780 780,990
driver to pick them up

1974
01:01:07,010 --> 01:01:09,050
0,240 240,330 330,810 810,1350 1620,2040
sort of already copied {},|
|

1975
01:01:09,140 --> 01:01:09,980
0,210 210,360 360,540 540,660 660,840
but that means that NIC
但这意味着网卡必须知道它应该将每个数据包放在哪里，

1976
01:01:09,980 --> 01:01:11,600
0,180 180,270 270,540 540,1080 1080,1620
has to know where memory

1977
01:01:11,600 --> 01:01:12,980
0,150 150,330 330,600 600,810 810,1380
it should put each packet,|
|

1978
01:01:13,070 --> 01:01:15,600
0,690 1470,1920
{} so,
所以， E1000 网卡的工作方式是

1979
01:01:15,920 --> 01:01:17,060
0,330 390,600 600,750 750,1020 1020,1140
{} the way that {E1000,NIC,works

1980
01:01:17,060 --> 01:01:19,850
0,1920 1920,2070 2070,2220 2220,2310 2310,2790
-} is| that the host
|主机软件格式化所谓的环，

1981
01:01:19,850 --> 01:01:22,700
0,780 1290,1740 1770,2550 2550,2700 2700,2850
software {} formats up what's

1982
01:01:22,700 --> 01:01:26,140
0,360 390,1560 1560,2070 2070,2970
called rings,| DMA rings,
|DMA 环，一个数据包指针，

1983
01:01:26,140 --> 01:01:28,090
0,120 120,600 600,1230 1260,1560 1560,1950
a packet pointers,| so DMA
|所以 DMA 环是指向数据包缓冲区的指针数组。

1984
01:01:28,090 --> 01:01:29,860
0,150 150,270 270,540 540,750 900,1770
ring is just an array

1985
01:01:30,840 --> 01:01:33,240
0,480 510,1920
of pointers

1986
01:01:34,370 --> 01:01:35,680
0,690
{}

1987
01:01:36,260 --> 01:01:38,680
0,630 630,1080 1080,1920
to packet buffers.|
|

1988
01:01:40,120 --> 01:01:41,360
0,300 300,630
So the
所以，当主机驱动程序初始化时，

1989
01:01:41,360 --> 01:01:42,650
0,420 450,750 750,1020 1020,1170 1170,1290
host host driver when it's

1990
01:01:42,650 --> 01:01:44,120
0,540 540,600 600,870 870,990 990,1470
initialized,| the card will allocate
|网卡分配比如 16 1500 字节数据包缓冲区，

1991
01:01:44,120 --> 01:01:46,760
0,330 330,630 630,810 810,1710 2130,2640
however many say 16 {1500

1992
01:01:46,760 --> 01:01:48,710
0,360 360,630 630,930 930,1530 1590,1950
-} byte packet buffers| will
|创建一个由 15 个或 16 个指针组成的数组，

1993
01:01:48,710 --> 01:01:50,600
0,480 480,690 720,1290 1290,1380 1380,1890
create an array of 15

1994
01:01:50,600 --> 01:01:52,250
0,570 570,660 660,1080 1080,1500 1500,1650
pointers or 16 pointers| and
|并使这些指针指向那里，

1995
01:01:53,390 --> 01:01:54,350
0,240 240,420 420,720 720,900 900,960
make these pointers point to

1996
01:01:54,350 --> 01:01:55,400
0,210 210,300 300,420 420,630 630,1050
there| and then it'll tell
|然后它会在配置时告诉网卡，

1997
01:01:55,400 --> 01:01:57,740
0,150 150,510 660,1140 1140,1920 1920,2340
the NIC in configuration time,|
|

1998
01:01:57,770 --> 01:01:58,740
0,510
look,
看，这是环，

1999
01:01:58,740 --> 01:02:01,060
0,510 750,1320 1320,1680
{} here's the

2000
01:02:01,060 --> 01:02:02,920
0,960 1170,1350 1350,1470 1470,1530 1530,1860
ring,| so this is called
|所以这叫 DMA 环，

2001
01:02:02,920 --> 01:02:05,960
0,450 450,1080 1410,2370
DMA ring,| because
|因为在你走出终点之后，

2002
01:02:06,660 --> 01:02:07,620
0,390 390,510 510,690 690,840 840,960
after you've gone off the

2003
01:02:07,620 --> 01:02:08,430
0,210 210,300 300,540 540,750 750,810
end,| you start back at
|你又回到了起点。

2004
01:02:08,430 --> 01:02:10,020
0,90 90,600
the beginning.|
|

2005
01:02:10,170 --> 01:02:11,250
0,270 270,360 360,690 690,990 990,1080
{} The drivers software will
驱动程序软件会告诉网卡，

2006
01:02:11,250 --> 01:02:12,360
0,180 180,270 270,570 570,870 870,1110
tell the NIC,| here's a
|这里有一个指针指向 RAM 中的地址， DMA 环，

2007
01:02:12,360 --> 01:02:13,740
0,510 510,630 630,1050 1050,1140 1140,1380
pointer the address in my

2008
01:02:13,740 --> 01:02:15,780
0,360 360,480 480,660 660,1140 1680,2040
RAM of the ring, {DMA

2009
01:02:15,780 --> 01:02:17,250
0,240 240,690 810,1080 1080,1410 1410,1470
-} ring,| you're supposed to
|你可以用来寄存进来的数据包，

2010
01:02:17,250 --> 01:02:19,380
0,270 270,330 330,1080 1290,1650 1650,2130
use the deposit incoming packets,|
|

2011
01:02:19,380 --> 01:02:20,850
0,120 120,180 180,480 480,1080 1140,1470
when a packet arrives,| the
当数据包到达时，|网卡会记住下一个环条目，

2012
01:02:20,850 --> 01:02:23,640
0,300 300,660 660,1530 2010,2400 2400,2790
NIC actually remember {} which

2013
01:02:23,640 --> 01:02:25,320
0,270 270,930 1080,1260 1260,1380 1380,1680
ring entry is the next

2014
01:02:25,320 --> 01:02:26,420
0,570
one,|
|

2015
01:02:27,960 --> 01:02:29,440
0,120 120,240 240,330 330,810
it is a little
这是一个指针到这里，

2016
01:02:29,500 --> 01:02:30,730
0,330 330,540 540,870 870,1170 1170,1230
pointer here,| that allows it
|这允许它记住下一个条目，

2017
01:02:30,730 --> 01:02:32,680
0,90 90,660 1260,1380 1380,1710 1710,1950
to remember the next entry,|
|

2018
01:02:32,680 --> 01:02:33,400
0,90 90,210 210,360 360,720 720,720
that it [should] DMA {},|
它[应该] DMA ，|

2019
01:02:33,400 --> 01:02:34,480
0,390 390,600 600,720 720,780 780,1080
packet into when a packet
当数据包到达时，

2020
01:02:34,480 --> 01:02:36,130
0,660 750,1020 1020,1200 1200,1320 1320,1650
arrives,| the NIC will fetch
|网卡从这里提取指针，

2021
01:02:36,130 --> 01:02:37,360
0,120 120,540 540,720 720,810 810,1230
the pointer out of this,|
|

2022
01:02:38,020 --> 01:02:39,580
0,570 570,750 750,1050 1050,1350 1350,1560
fetch this buffer pointer out
从主机 RAM 中获取缓冲区指针，

2023
01:02:39,580 --> 01:02:42,160
0,60 60,150 150,510 540,1170 2010,2580
of the host RAM,| copy
|将数据包字节复制到这个缓冲区中，

2024
01:02:42,160 --> 01:02:44,170
0,300 540,1110 1110,1620 1620,1830 1830,2010
the packet bytes into this

2025
01:02:44,170 --> 01:02:46,480
0,570 780,960 960,1110 1110,1800 1800,2310
buffer| and then advance its
|然后推进其内部索引到这里，

2026
01:02:46,860 --> 01:02:48,180
0,780
internal

2027
01:02:48,210 --> 01:02:49,440
0,570 570,810 810,900 900,1140 1140,1230
index here,| to point to
|指向下一个环的槽，

2028
01:02:49,440 --> 01:02:51,300
0,90 90,660 690,930 930,1470 1530,1860
the next ring slot,| which
|我们将在下一个包中使用它。

2029
01:02:51,300 --> 01:02:52,020
0,120 120,330 330,420 420,480 480,720
we'll use for the next

2030
01:02:52,020 --> 01:02:52,980
0,330
packet.|
|

2031
01:02:53,510 --> 01:02:55,520
0,120 120,270 270,330 330,1080 1560,2010
And there's a similar, {}|
还有一个类似的，|

2032
01:02:55,790 --> 01:02:56,720
0,240 240,360 360,480 480,660 660,930
so this will be {RX
所以这是 RX 环，

2033
01:02:56,720 --> 01:02:58,120
0,300 300,810
-} ring,|
|

2034
01:02:58,120 --> 01:02:59,650
0,120 120,750 780,1020 1020,1110 1110,1530
to receive,| there's a similar
为了接收，|驱动程序设置了一个类似的环，

2035
01:02:59,650 --> 01:03:00,850
0,210 210,360 360,450 450,780 780,1200
ring that the driver sets

2036
01:03:00,850 --> 01:03:02,680
0,330 750,1200
up {}|
|

2037
01:03:03,120 --> 01:03:05,020
0,150 150,420 420,540 540,1380
in which the driver
驱动程序可以放入数据包，

2038
01:03:05,020 --> 01:03:06,740
0,300 300,1200
puts packets,|
|

2039
01:03:06,770 --> 01:03:08,330
0,150 150,240 240,810 810,1110 1140,1560
that it wants the NIC
它想让网卡发送，

2040
01:03:08,330 --> 01:03:09,920
0,810 810,960 960,1140 1140,1350 1350,1590
{to,send},| so the NIC also
|所以，网卡还有一个指向 TX 环的指针。

2041
01:03:09,920 --> 01:03:10,760
0,120 120,210 210,510 510,630 630,840
has a pointer to the

2042
01:03:11,300 --> 01:03:12,840
0,510 510,780
TX ring.|
|

2043
01:03:14,090 --> 01:03:15,500
0,210 210,420 420,660 660,960 960,1410
So you'll learn, your job
所以你会学到，你在实验的工作是

2044
01:03:15,500 --> 01:03:16,520
0,60 60,180 180,510 510,630 630,1020
in the lab is| basically
|编写处理这些环的驱动软件。

2045
01:03:16,520 --> 01:03:18,560
0,120 120,450 450,750 960,1410 1410,2040
to write the driver software

2046
01:03:18,560 --> 01:03:21,100
0,390 690,1020 1020,1260 1260,2010
that handle these rings.|
|

2047
01:03:22,560 --> 01:03:23,880
0,210 210,570 570,750 750,870 870,1320
Any questions about this arrangement?|
对于这个安排，有什么问题吗？|

2048
01:03:29,040 --> 01:03:31,590
0,1140 1140,1440 1440,1710 1710,2130 2160,2550
Yeah, how does the {E1000
是的， E1000 与生产级别的网卡相比，

2049
01:03:31,590 --> 01:03:34,220
0,840 960,1590 1590,2130
-} compare with

2050
01:03:34,310 --> 01:03:36,080
0,210 210,900 900,1290 1290,1590 1590,1770
{} production level NICs| that
|可能在高性能环境中使用的。

2051
01:03:36,080 --> 01:03:36,980
0,150 150,300 300,570 570,690 690,900
may be used in high

2052
01:03:36,980 --> 01:03:39,830
0,540 540,1350 1380,1980 1980,2100 2100,2850
performance environments.| {Well,when} the {E1000,came}
|当 E1000 出现时，

2053
01:03:39,830 --> 01:03:42,260
0,300 330,450 450,930 990,1350 1380,2430
out,| it was the absolute
|它绝对是最好的网卡，

2054
01:03:42,530 --> 01:03:44,840
0,510 510,810 810,1410 2010,2190 2190,2310
best NIC available| and it
|它是在生产环境中使用的网卡，

2055
01:03:44,840 --> 01:03:45,830
0,420 420,510 510,720 720,840 840,990
was the NIC that was

2056
01:03:45,830 --> 01:03:47,340
0,540 540,1020
used in

2057
01:03:48,370 --> 01:03:50,230
0,510 510,840 840,1530 1560,1680 1680,1860
serious production environments,| but that
|但那是很多年前的事了，

2058
01:03:50,230 --> 01:03:51,400
0,270 270,390 390,690 690,870 870,1170
was {} many years ago,|
|

2059
01:03:51,460 --> 01:03:54,100
0,600 600,1170 1200,1770
modern NICs {}
现代网卡更聪明，

2060
01:03:54,100 --> 01:03:55,600
0,150 150,510 510,570 570,720 720,1500
are quite a bit clever,|
|

2061
01:03:55,960 --> 01:03:57,180
0,570
the
变化不大的是这个 DMA 环结构，

2062
01:03:57,300 --> 01:03:59,370
0,240 240,720 720,1320 1320,1650 1650,2070
what hasn't changed that much

2063
01:03:59,370 --> 01:04:01,380
0,180 180,450 450,960 960,1260 1260,2010
is this DMA ring structure,|
|

2064
01:04:01,770 --> 01:04:03,720
0,180 180,630 630,1020 1020,1140 1140,1950
you're still find that NICs
你仍会发现网卡使用 DMA 传输数据包，

2065
01:04:03,840 --> 01:04:04,860
0,120 120,300 300,600 600,720 720,1020
to use DMA to deliver

2066
01:04:04,860 --> 01:04:06,270
0,720 720,840 840,930 930,1110 1110,1410
packets| and the way they
|它们找到递送数据包的地方的方式，

2067
01:04:06,420 --> 01:04:07,410
0,360 360,450 450,690 690,780 780,990
find the place to deliver

2068
01:04:07,410 --> 01:04:09,870
0,90 90,600 600,870 870,1440 1650,2460
the packets| by these rings
|通过缓冲区指针环。

2069
01:04:09,870 --> 01:04:12,960
0,420 510,1170 1170,1710 1890,2220 2220,3090
of buffer pointers.| The main
|有几件事是现代网卡更聪明的，

2070
01:04:12,990 --> 01:04:13,800
0,180 180,240 240,480 480,690 690,810
there's a couple things that

2071
01:04:13,800 --> 01:04:16,160
0,120 570,840 840,1350 1350,1830
are that modern NICs

2072
01:04:16,240 --> 01:04:17,980
0,330 330,660 660,1050 1170,1470 1470,1740
more clever about,| {} one
|一个是现代的网卡，

2073
01:04:17,980 --> 01:04:19,030
0,120 120,300 300,660 660,930 930,1050
is that modern NICs,| you
|你可以给它们设置很多很多的队列，

2074
01:04:19,030 --> 01:04:19,750
0,120 120,330 330,480 480,600 600,720
can set them up with

2075
01:04:19,750 --> 01:04:22,480
0,330 330,750 750,1680 2340,2550 2550,2730
many many queues,| {} the
|我认为 E1000 只有单个接收队列，

2076
01:04:22,480 --> 01:04:23,740
0,630 630,780 780,900 900,960 960,1260
{E1000,I,think} just as a single

2077
01:04:23,740 --> 01:04:25,330
0,360 360,660 780,1200 1230,1470 1470,1590
receive queue,| but you can
|但是你可以告诉现代网卡，

2078
01:04:25,330 --> 01:04:26,470
0,270 270,300 300,600 600,780 780,1140
tell a modern NIC,| look,
|我想让你把我的数据包分成 32 个不同的传入队列，

2079
01:04:26,500 --> 01:04:28,270
0,450 450,570 870,1260 1260,1560 1560,1770
you know I I want

2080
01:04:28,270 --> 01:04:29,440
0,120 120,240 240,600 600,750 750,1170
you to split my packets

2081
01:04:29,440 --> 01:04:31,270
0,120 120,450 450,900 900,1380 1380,1830
up into 32 different incoming

2082
01:04:31,270 --> 01:04:32,980
0,750 780,1050 1080,1500 1500,1620 1620,1710
queues| and here's how to
|这里是如何为每个数据包做出决定，

2083
01:04:32,980 --> 01:04:34,840
0,720 720,840 840,1020 1020,1500 1620,1860
decide for each packet,| look
|查看这个字段，

2084
01:04:34,840 --> 01:04:35,890
0,60 60,270 270,780 780,870 870,1050
at this field| and use
|并使用这个字段选择数据包 DMA 环，

2085
01:04:35,890 --> 01:04:38,500
0,300 300,600 780,1620 1620,2190
that to choose which

2086
01:04:38,560 --> 01:04:40,480
0,690 720,1170 1170,1260 1260,1710 1710,1920
ring DMA the packet to,|
|

2087
01:04:40,990 --> 01:04:42,160
0,300 300,450 450,480 480,930 930,1170
and there's a whole bunch
有很多聪明的方式让人们使用这种能力，

2088
01:04:42,160 --> 01:04:44,170
0,90 90,810 840,1290 1290,1470 1680,2010
of clever ways that people

2089
01:04:44,170 --> 01:04:45,820
0,210 210,390 390,1050 1050,1320 1410,1650
use that capability| like if
|比如，如果你有多个虚拟机，

2090
01:04:45,820 --> 01:04:47,290
0,90 90,180 180,570 570,870 870,1470
you have multiple virtual machines,|
|

2091
01:04:47,290 --> 01:04:48,370
0,210 210,630 630,750 750,840 840,1080
your Amazon and you're running
你的亚马逊，并且你正在运行多个客户虚拟机，

2092
01:04:48,370 --> 01:04:51,250
0,540 1020,1470 1470,1830 1830,2490 2610,2880
many guest virtual machines,| you
|你可以使用这个能力，

2093
01:04:51,250 --> 01:04:52,810
0,270 270,480 480,630 630,1320 1320,1560
may use that capability| to
|将每个数据包定向到与虚拟机对应的队列，

2094
01:04:52,960 --> 01:04:55,060
0,360 360,540 630,1350 1350,1560 1560,2100
sort of direct each packet

2095
01:04:55,120 --> 01:04:56,650
0,210 210,330 330,780 780,1410 1410,1530
to the queue corresponding to

2096
01:04:56,650 --> 01:04:58,600
0,120 120,480 480,1290 1590,1740 1740,1950
the virtual machine,| that that
|那个数据包应该被读（的虚拟机）。

2097
01:04:58,600 --> 01:04:59,800
0,360 360,480 480,600 600,840 840,1200
packet should be read by.|
|

2098
01:05:01,210 --> 01:05:02,380
0,420 420,570 570,630 630,870 870,1170
Another way in which modern
另一种现代网卡更聪明的方式，

2099
01:05:02,380 --> 01:05:03,520
0,300 300,450 450,780 780,930 930,1140
NICs more clever| as {they'll
|它们在网卡上执行一些 TCP 处理，

2100
01:05:03,520 --> 01:05:04,900
0,90 90,270 270,750 750,990 990,1380
-} do some of the

2101
01:05:05,230 --> 01:05:07,300
0,750 750,1290 1290,1530 1530,1650 1650,2070
TCP processing on the NIC,|
|

2102
01:05:07,330 --> 01:05:10,150
0,450 690,960 1320,1650 1650,2100 2100,2820
like maybe typically checksum calculations
我想最多的可能是通常的校验和计算。

2103
01:05:10,150 --> 01:05:11,340
0,120 120,690
the most

2104
01:05:11,820 --> 01:05:13,260
0,30 390,840
I think.|
|

2105
01:05:13,620 --> 01:05:15,500
0,360 360,660 840,1230
Anyway, yeah,| so,
无论如何，是的，|现代网卡类似 E1000 ，但是更多。

2106
01:05:16,400 --> 01:05:17,870
0,300 300,570 570,750 750,870 870,1470
modern NICs like the {E1000,but}

2107
01:05:17,870 --> 01:05:19,420
0,420
more.|
|

2108
01:05:20,340 --> 01:05:21,600
0,180 180,750
Okay, thanks.|
好的，谢谢。|

2109
01:05:23,320 --> 01:05:25,390
0,420 480,960 960,1380 1770,1920 1920,2070
Oh, sorry good.| Oh, yeah,
哦，抱歉，好的。|哦，是的，我想问一下，

2110
01:05:25,390 --> 01:05:26,440
0,240 240,420 420,600 600,750 750,1050
I just wanted to ask,|
|

2111
01:05:26,440 --> 01:05:27,700
0,300 300,540 540,810 810,1170 1170,1260
so in our scheme in
在我们实验的方案中，

2112
01:05:27,700 --> 01:05:29,770
0,120 120,600 690,1410 1440,1920 1920,2070
the lab,| {} there, there
|在 IP 层和驱动之间没有队列，是吗？

2113
01:05:29,770 --> 01:05:30,920
0,150 150,600
is no

2114
01:05:30,920 --> 01:05:33,110
0,540 540,870 870,1020 1020,1500 1500,2190
queue between the IP layer

2115
01:05:33,410 --> 01:05:36,200
0,210 210,300 300,1020 1110,1890 2190,2790
and the driver, right?| Yeah
|是的，实验网络堆栈被精简到绝对最小，

2116
01:05:36,200 --> 01:05:38,150
0,240 240,780 780,1110 1110,1440 1440,1950
the lab network stack is

2117
01:05:39,410 --> 01:05:41,180
0,480 480,930 930,990 990,1110 1140,1770
stripped down to the absolute

2118
01:05:41,180 --> 01:05:43,550
0,450 630,1350 1350,1800 1800,1890 1890,2370
minimum,| {} simpler in structure
|结构比真正的网络堆栈更简单。

2119
01:05:43,550 --> 01:05:44,990
0,150 150,240 240,600 600,1020 1020,1440
than a real networks stack.|
|

2120
01:05:45,720 --> 01:05:47,580
0,150 150,330 330,600 600,1440 1530,1860
But this is worse in
但就性能而言，这是否更糟糕？

2121
01:05:47,580 --> 01:05:50,130
0,270 270,870 930,2130 2220,2460 2460,2550
terms of performance?| Oh, I
|哦，我不知道，我从来没有在现实生活中运行过它，

2122
01:05:50,130 --> 01:05:52,260
0,180 180,480 1290,1500 1500,1950 1950,2130
don't know, I've never run

2123
01:05:52,260 --> 01:05:53,100
0,120 120,270 270,450 450,720 720,840
it in real life,| I'm
|我敢肯定，我们肯定没有注意性能，

2124
01:05:53,100 --> 01:05:55,980
0,570 840,1290 1320,2010 2370,2610 2610,2880
sure they've certainly we paid

2125
01:05:55,980 --> 01:05:58,410
0,540 540,960 960,1050 1050,1950 2220,2430
zero attention to performance,| when
|当编写网络实验时，

2126
01:05:58,410 --> 01:05:59,910
0,300 300,690 690,1350 1350,1440 1440,1500
writing lab networks,| so it
|所以如果有高性能是令人惊讶的，

2127
01:05:59,910 --> 01:06:01,230
0,120 120,240 240,810 810,900 1140,1320
would be surprising if this

2128
01:06:01,230 --> 01:06:03,480
0,690 1500,1680 1680,1980 1980,2100 2100,2250
performance,| but mostly it's not
|但大多数情况下，这不是性能限制的问题，

2129
01:06:03,480 --> 01:06:05,040
0,30 30,300 300,360 360,870 870,1560
a question of performances limitations,|
|

2130
01:06:05,040 --> 01:06:07,350
0,120 150,570 570,1110 1260,1980 1980,2310
it doesn't do {95% -}
它不能达到你需要的 95% 的网络堆栈，

2131
01:06:07,350 --> 01:06:08,130
0,60 60,180 180,270 270,420 420,780
of what you need network

2132
01:06:08,130 --> 01:06:09,640
0,270 270,360 360,600 630,1020
stack to do,| like
|比如处理多个网卡或使用 TCP 。

2133
01:06:10,040 --> 01:06:12,380
0,180 180,510 510,870 870,1260 1260,2340
{} handle multiple NICs or

2134
01:06:13,170 --> 01:06:15,200
0,390 390,1050
have TCP.|
|

2135
01:06:15,320 --> 01:06:17,210
0,450 570,960 1080,1410 1410,1530 1530,1890
Right, right,| okay I see,
对，对，|好的，我明白了，谢谢。

2136
01:06:17,240 --> 01:06:18,500
0,240 240,630
thank you.|
|

2137
01:06:20,000 --> 01:06:21,220
0,570

2138
01:06:21,220 --> 01:06:23,460
0,360 360,630 660,960 960,1590
Um, sorry, {} so,
嗯，抱歉，对于整个系统有没有硬件变动，

2139
01:06:23,460 --> 01:06:24,810
0,390 390,540 540,720 720,1110 1110,1350
{} were there any like

2140
01:06:24,810 --> 01:06:28,320
0,390 390,1050 1050,1920 2160,2820 3240,3510
hardware changes to {} the

2141
01:06:28,320 --> 01:06:30,570
0,630 990,1620 1620,1740 1740,1830 1830,2250
overall system,| that were needed
|需要让网卡可以直接访问内存，

2142
01:06:30,570 --> 01:06:32,550
0,510 510,990 990,1200 1200,1830 1860,1980
to enable like NICs to

2143
01:06:32,550 --> 01:06:35,010
0,300 300,870 1260,1590 1590,2250 2280,2460
have direct memory access,| like
|像上一张图那样，

2144
01:06:35,010 --> 01:06:37,110
0,60 60,150 150,510 510,1050 1530,2100
in the previous picture {},|
|

2145
01:06:37,380 --> 01:06:38,850
0,480 480,780 780,1230 1230,1380 1380,1470
was everything needed through the
是否所有内容都通过 CPU ，

2146
01:06:38,850 --> 01:06:41,250
0,600 600,1170 1170,1560 1620,1980 1980,2400
CPU| or could NICs also
|或者网卡是否也可以直接到达内存。

2147
01:06:41,370 --> 01:06:43,410
0,510 510,660 660,990 990,1560 1800,2040
reached the {that,memory} directly.| In
|在我之前展示的那张图片中，

2148
01:06:43,410 --> 01:06:44,610
0,240 240,540 540,630 630,870 870,1200
that picture I showed before,|
|

2149
01:06:44,610 --> 01:06:45,630
0,180 180,300 300,450 450,780 780,1020
{you,know} the NIC doesn't reach
网卡访问不到内存。

2150
01:06:45,630 --> 01:06:47,820
0,120 120,420 420,510 510,840
the memory at all,

2151
01:06:48,060 --> 01:06:52,050
0,630 660,1200 1800,2490 3060,3660 3660,3990
the.| Okay.| {} I actually
|好的。|我实际上不知道，

2152
01:06:52,050 --> 01:06:53,520
0,330 330,630 630,690 690,900 930,1470
don't know,| I mean the
|我的意思是，

2153
01:06:53,580 --> 01:06:55,200
0,570 600,1050 1080,1320 1320,1410 1410,1620
the,| {} maybe the most
|也许最重要的问题是，

2154
01:06:55,200 --> 01:06:57,000
0,390 390,900 900,1110 1110,1470 1470,1800
important question is| how virtual
|虚拟内存转换是否以及如何工作，

2155
01:06:57,000 --> 01:06:58,590
0,390 390,810 810,900 900,1230 1230,1590
memory whether and how virtual

2156
01:06:58,590 --> 01:07:01,530
0,570 870,1530 1530,2130 2160,2520 2520,2940
memory translation works,| when NIC
|当网卡要使用引用主机内存的地址时，

2157
01:07:01,860 --> 01:07:03,030
0,270 270,390 390,690 690,780 780,1170
wants to use an address

2158
01:07:03,030 --> 01:07:04,290
0,120 120,450 450,570 570,810 810,1260
that refers to host memory|
|

2159
01:07:04,380 --> 01:07:06,090
0,450 780,1050 1050,1260 1260,1590 1590,1710
and I don't actually know
我不知道它是怎么工作的，

2160
01:07:06,090 --> 01:07:07,560
0,150 150,360 360,1140 1200,1320 1320,1470
how that works,| I don't
|我不知道它是怎么工作的，

2161
01:07:07,560 --> 01:07:09,540
0,60 60,150 150,330 330,870 1560,1980
know how that works,| I
|我猜这里有一个转换，

2162
01:07:10,040 --> 01:07:12,800
0,30 60,780 780,1380 1380,1740 1770,2760
I suspect there's a translation,|
|

2163
01:07:12,950 --> 01:07:14,150
0,420 420,570 600,930 930,1020 1020,1200
you know NIC is really
网卡实际在总线上，

2164
01:07:14,150 --> 01:07:16,190
0,270 270,390 390,660 780,1620 1680,2040
sitting on a bus,| that's
|它连接到，

2165
01:07:16,190 --> 01:07:18,060
0,600 600,930
connected with,|
|

2166
01:07:18,390 --> 01:07:19,380
0,150 150,270 270,450 450,630 630,990
you know through some fairly
通过一些智能的硅连接到 DRAM 系统，

2167
01:07:19,380 --> 01:07:21,840
0,660 660,1320 1320,1470 1470,1860 2310,2460
intelligent silicon to the to

2168
01:07:21,840 --> 01:07:23,460
0,90 90,540 540,1050 1200,1530 1530,1620
the DRAM system| and I
|我相信在现代机器中，

2169
01:07:23,460 --> 01:07:24,540
0,270 270,360 360,660 660,990 990,1080
believe in modern machines,| you
|你可以在网卡内设置转换表，

2170
01:07:24,540 --> 01:07:26,280
0,120 120,480 480,1020 1020,1380 1380,1740
can setup translation tables within

2171
01:07:26,280 --> 01:07:29,850
0,420 1440,1740 1740,2010 2010,2550 2970,3570
NIC,| could use virtual addresses|
|可以使用虚拟地址，|

2172
01:07:29,850 --> 01:07:31,380
0,150 180,600 600,720 720,780 780,1530
or addresses that are translated
或者由这个位于它和 RAM 之间的硬件转换的地址，

2173
01:07:32,630 --> 01:07:33,920
0,420 420,570 570,930 930,1050 1050,1290
by this hardware that sits

2174
01:07:33,920 --> 01:07:35,660
0,330 330,450 450,570 570,990 1440,1740
between it and RAM {},|
|

2175
01:07:35,660 --> 01:07:36,350
0,150 150,270 270,360 360,480 480,690
and that could be very
在某些情况下，这可能是非常有价值的。

2176
01:07:36,350 --> 01:07:38,500
0,510 510,630 630,780 780,1620
valuable for some situations.|
|

2177
01:07:38,590 --> 01:07:41,480
0,450 660,1170 1170,1470 1470,2220
{} The other thing,|
另一件事，|

2178
01:07:41,780 --> 01:07:43,520
0,120 120,360 840,1440 1440,1590 1590,1740
I mean another thing that
我是说，我意识到的另一件事是，

2179
01:07:43,520 --> 01:07:44,630
0,90 90,450 450,630 630,810 810,1110
I'm aware of is that,|
|

2180
01:07:46,340 --> 01:07:47,180
0,270 270,390 390,600 600,720 720,840
if the NIC is going
如果网卡要写入一些内存或读取一些内存，

2181
01:07:47,180 --> 01:07:48,140
0,60 60,270 270,450 450,840 840,960
to write some memory or

2182
01:07:48,140 --> 01:07:49,190
0,210 210,360 360,810 810,990 990,1050
read some memory| and the
|并且内存被高速缓存在 CPU 上，

2183
01:07:49,190 --> 01:07:51,530
0,360 360,540 540,1530 1680,2220 2220,2340
memory is cached on the

2184
01:07:51,530 --> 01:07:53,020
0,930
CPU,|
|

2185
01:07:53,880 --> 01:07:54,870
0,330 330,480 480,570 570,750 750,990
you, you know you want
你想让网卡读取，

2186
01:07:54,870 --> 01:07:56,490
0,120 120,390 390,570 570,1140 1140,1620
the NIC to read,| if,
|如果软件只是写入一个数据包缓冲区，

2187
01:07:56,580 --> 01:07:58,260
0,240 240,360 360,720 720,1080 1110,1680
if the software just wrote

2188
01:07:58,350 --> 01:07:59,730
0,120 120,450 450,900 900,1110 1110,1380
a packet buffer,| but the
|但是 CPU 没有，

2189
01:08:00,300 --> 01:08:01,900
0,480 480,1050
CPU hasn't,|
|

2190
01:08:01,990 --> 01:08:03,910
0,210 210,540 540,660 660,960 960,1920
the CPU is merely cached
CPU 只是缓存了写，

2191
01:08:04,480 --> 01:08:05,800
0,270 270,420 420,780 780,990 990,1320
{} the write,| because after
|因为在之后，所有内存被写回，

2192
01:08:05,800 --> 01:08:07,960
0,450 960,1200 1200,1500 1500,1890 1890,2160
all, {} most memories write

2193
01:08:07,960 --> 01:08:10,840
0,690 930,1470 1890,2580 2580,2760 2760,2880
back,| {} that means that
|这意味着内存的最新版本

2194
01:08:10,840 --> 01:08:12,340
0,150 150,600 600,1140 1140,1440 1440,1500
the real latest version of

2195
01:08:12,340 --> 01:08:13,090
0,150 150,390 390,450 450,690 690,750
that memory| is sitting in
|位于 CPU 缓存中，而不是在 RAM 中，

2196
01:08:13,090 --> 01:08:14,140
0,60 60,450 450,750 750,960 960,1050
the CPU cache not in

2197
01:08:14,140 --> 01:08:15,250
0,390 390,480 480,540 540,720 720,1110
RAM| and in that case,|
|在这种情况下，|

2198
01:08:15,370 --> 01:08:16,420
0,330 330,600 600,720 720,960 960,1050
we'd like the NIC to
我们希望它读取 CPU 缓存，而不是 RAM ，

2199
01:08:16,420 --> 01:08:18,310
0,120 120,510 510,630 630,1140 1140,1890
be reading the CPU cache,

2200
01:08:18,370 --> 01:08:19,240
0,270 270,360 360,660 660,810 810,870
not the RAM,| if it
|如果它执行 DMA ，

2201
01:08:19,240 --> 01:08:22,150
0,240 240,840 1350,1770 1890,2220 2250,2910
does DMA| {} and certainly
|当然，在英特尔的机器上，也可能在其他机器上，

2202
01:08:22,150 --> 01:08:23,590
0,90 90,420 420,900 900,1080 1080,1440
on Intel machines and probably

2203
01:08:23,590 --> 01:08:25,180
0,120 120,630 720,1110 1110,1230 1230,1590
on others,| there's some fairly
|有一些相当复杂的机制，

2204
01:08:25,180 --> 01:08:26,710
0,390 390,990 990,1170 1170,1350 1380,1530
elaborate machinery,| so that if
|如果网卡读取一些内存，

2205
01:08:26,710 --> 01:08:28,510
0,120 120,480 900,1170 1170,1320 1320,1800
the NIC read some memory,|
|

2206
01:08:28,510 --> 01:08:30,160
0,480 480,630 630,1140 1170,1470 1470,1650
but the latest copy that
但是内存的最新副本位于 CPU 缓存中，

2207
01:08:30,160 --> 01:08:31,750
0,480 480,690 690,780 780,1140 1140,1590
memories in the CPU cache,|
|

2208
01:08:31,750 --> 01:08:33,160
0,420 420,510 510,960 960,1290 1290,1410
it's the CPU cache that
CPU 缓存将产生数据，而不是 RAM 。

2209
01:08:33,160 --> 01:08:34,510
0,150 150,510 510,600 600,960 1140,1350
will produce the data and

2210
01:08:34,510 --> 01:08:35,440
0,300 300,570
not RAM.|
|

2211
01:08:37,150 --> 01:08:39,190
0,720 1110,1530 1530,1740 1740,1980 1980,2040
Okay.| Yeah, that's actually a
好的。|是的，那实际上是一种设施，

2212
01:08:39,190 --> 01:08:41,680
0,420 420,510 510,750 1470,1830 1830,2490
facility,| you can some clever
|一些聪明的软件来获得高性能，

2213
01:08:41,680 --> 01:08:43,180
0,480 480,900 900,1080 1080,1290 1290,1500
software uses to get high

2214
01:08:43,180 --> 01:08:45,520
0,810 1290,1590 1590,1770 1770,1980 2010,2340
performance,| that is to have
|也就是说，对于写入也会发生这种情况，

2215
01:08:45,520 --> 01:08:46,870
0,90 90,420 420,480 480,1050 1140,1350
the effect of having this

2216
01:08:46,870 --> 01:08:48,430
0,240 240,390 390,750 750,1200 1320,1560
happens for writes also,| that
|网卡直接在高速缓存中写入高速缓存线，

2217
01:08:48,430 --> 01:08:49,870
0,90 90,330 330,540 570,990 990,1440
the NIC will essentially directly

2218
01:08:49,870 --> 01:08:50,890
0,240 240,600 600,870 870,930 930,1020
write cache lines in the

2219
01:08:50,890 --> 01:08:53,350
0,630 1050,1410 1410,1890 1980,2130 2130,2460
cache,| where it's the CPU
|CPU 可以非常快速地获取数据。

2220
01:08:53,350 --> 01:08:54,130
0,180 180,360 360,480 480,570 570,780
can get at the data

2221
01:08:54,130 --> 01:08:55,240
0,180 180,540
very quickly.|
|

2222
01:08:57,220 --> 01:08:59,590
0,1410 1410,1830 1830,2040 2040,2190 2190,2370
{Thank,you}.| Simple, but their real
谢谢。|简单，但它们在现实生活却相当复杂。

2223
01:08:59,590 --> 01:09:01,240
0,360 360,750
life it's

2224
01:09:01,480 --> 01:09:02,820
0,240 240,810
pretty involved.|
|

2225
01:09:03,940 --> 01:09:05,640
0,270 270,690 690,1080
Other questions about,
还有别的问题吗？

2226
01:09:07,770 --> 01:09:09,060
0,270 270,690
about anything?|
|

2227
01:09:12,190 --> 01:09:14,770
0,450 750,1320 2250,2400 2400,2490 2490,2580
Okay, {} I'd like to
好的，我现在想换个话题看今天的论文。

2228
01:09:14,770 --> 01:09:16,390
0,270 270,570 570,840 840,1260 1260,1620
switch gears now to today's

2229
01:09:16,390 --> 01:09:19,360
0,570 960,1500
paper {}.|
|

2230
01:09:19,390 --> 01:09:20,830
0,510 540,720 720,900 900,1110 1110,1440
And I'm just gonna like,|
我只想说，|

2231
01:09:20,830 --> 01:09:22,480
0,450 450,600 600,990 990,1320 1320,1650
because we've already talked about
因为我们已经讨论了很多这篇论文的背景，

2232
01:09:22,480 --> 01:09:24,100
0,300 450,780 780,870 1350,1470 1470,1620
the sort of a lot

2233
01:09:24,100 --> 01:09:24,880
0,60 60,120 120,600 600,660 660,780
of the background of this

2234
01:09:24,880 --> 01:09:25,570
0,270 270,360 360,510 510,630 630,690
paper,| I'm just going to
|我要直接转到论文中的第一个图，

2235
01:09:25,570 --> 01:09:27,940
0,90 90,900 1290,1500 1500,1620 1620,2370
go directly to the first

2236
01:09:27,940 --> 01:09:32,800
0,540 690,1230 3780,4170 4200,4650 4650,4860
graph paper| and essentially to
|为了推动对论文图表的讨论，

2237
01:09:32,920 --> 01:09:34,600
0,420 420,900 900,1380 1380,1560 1560,1680
drive the discussion of of

2238
01:09:34,600 --> 01:09:37,960
0,420 780,1170 1170,1740 2430,2910 3090,3360
the paper's graphs| and so
|我们现在看到的是路由器的性能图，

2239
01:09:37,960 --> 01:09:38,770
0,90 90,150 150,420 420,600 600,810
what we're looking at here

2240
01:09:38,770 --> 01:09:40,090
0,150 150,420 450,900 900,1140 1140,1320
is the performance graph for

2241
01:09:40,090 --> 01:09:42,340
0,480 1050,1500 1590,1830 1830,1950 1950,2250
router,| on on the x
|在 x 轴上，

2242
01:09:42,340 --> 01:09:43,480
0,450 450,690 690,810 810,1020 1020,1140
axis,| there's a router with
|这里有一个带有两个网卡的路由器，

2243
01:09:43,480 --> 01:09:45,100
0,630 630,930 930,1230 1230,1380 1380,1620
{two,NICs},| its job is to
|它的工作从一个网卡接口数据包，

2244
01:09:45,130 --> 01:09:46,120
0,330 330,450 450,540 540,750 750,990
packet receive in one NIC|
|

2245
01:09:46,120 --> 01:09:47,050
0,90 90,180 180,420 420,510 510,930
and it's supposed to just
并把它们从另一个网卡发送出去。

2246
01:09:47,230 --> 01:09:47,980
0,270 270,360 360,480 480,570 570,750
send them out the other

2247
01:09:47,980 --> 01:09:50,680
0,630 690,1170 1710,2130 2130,2370 2370,2700
NIC.| {} The x axis
|x 轴是到达率，

2248
01:09:50,680 --> 01:09:52,180
0,150 150,270 270,780 780,1260 1290,1500
is the arrival rate,| which
|数据包到达输入网卡，

2249
01:09:52,180 --> 01:09:53,740
0,660 690,1050 1050,1110 1110,1200 1200,1560
packets arrive at the input

2250
01:09:53,740 --> 01:09:54,460
0,420
NIC,|
|

2251
01:09:55,150 --> 01:09:56,200
0,240 240,330 330,510 510,870 870,1050
and the y axis is
y 轴输出率，

2252
01:09:56,200 --> 01:09:57,340
0,270 300,690 690,870 870,930 930,1140
the output rate| at which
|观察到数据包离开输出网卡，

2253
01:09:57,340 --> 01:09:59,290
0,360 360,540 540,1290 1290,1440 1440,1950
packets are observed to leave

2254
01:09:59,320 --> 01:10:02,830
0,180 180,600 600,960 2190,2940 3210,3510
the output NIC| and {}
|我们关心的线是，

2255
01:10:02,830 --> 01:10:03,910
0,240 240,510 510,570 570,810 810,1080
the line we care about

2256
01:10:03,910 --> 01:10:06,900
0,1020 1080,1380 1380,1830 1890,2580
is| is the {}
|是填充的圆，向上然后向下。

2257
01:10:07,900 --> 01:10:09,970
0,720 720,1320 1320,1500 1500,1680 1680,2070
filled circles which goes up

2258
01:10:10,300 --> 01:10:12,120
0,240 240,810
then down.|
|

2259
01:10:12,180 --> 01:10:15,750
0,720 2130,2370 2370,2640 2640,2940 3120,3570
So even without knowing anything
所以即使对这里发生的事情一无所知，

2260
01:10:15,750 --> 01:10:16,770
0,240 240,420 420,660 660,870 870,1020
about what's going on here,|
|

2261
01:10:16,770 --> 01:10:17,310
0,90 90,180 180,330 330,390 390,540
we can look at this
我们可以看看这张图，

2262
01:10:17,310 --> 01:10:18,150
0,330 330,420 420,510 510,630 630,840
graph| and we can ask
|我们可以问问自己，

2263
01:10:18,150 --> 01:10:19,620
0,330 330,930 960,1260 1260,1410 1410,1470
ourselves,| gosh, why does it
|为什么它上升，为什么它下降，

2264
01:10:19,620 --> 01:10:20,860
0,150 150,690
go up,

2265
01:10:20,860 --> 01:10:22,000
0,120 120,240 240,330 330,420 420,1140
why does it go down,|
|

2266
01:10:22,180 --> 01:10:24,160
0,240 240,660 1170,1410 1410,1740 1740,1980
you know what's special about
这一点有什么特别之处，这是一个拐点，

2267
01:10:24,160 --> 01:10:26,110
0,180 180,510 510,840 840,1050 1050,1950
this point, that's an inflection,|
|

2268
01:10:26,620 --> 01:10:27,820
0,90 90,420 630,960 960,1110 1110,1200
you know what is it
是什么决定了它上升的速度或者下降的速度。

2269
01:10:27,820 --> 01:10:28,810
0,120 120,480 480,600 600,930 930,990
that governs how fast it

2270
01:10:28,810 --> 01:10:29,830
0,210 210,450 450,540 540,630 630,1020
goes up or how fast

2271
01:10:29,830 --> 01:10:31,140
0,60 60,240 240,600
it goes down.|
|

2272
01:10:32,760 --> 01:10:33,930
0,120 120,300 300,420 420,690 690,1170
So even with zero knowledge,|
所以即使是零知识，|

2273
01:10:33,930 --> 01:10:34,770
0,180 300,600 600,660 660,750 750,840
we kind of have a
我们也有很好的线索知道该问什么问题，

2274
01:10:34,770 --> 01:10:36,090
0,210 210,510 510,720 720,870 870,1320
good clue about what questions

2275
01:10:36,090 --> 01:10:37,530
0,120 120,690 990,1200 1200,1320 1320,1440
to ask,| so why does
|那么为什么它会上升，

2276
01:10:37,530 --> 01:10:38,540
0,60 60,210 210,570
it go up,|
|

2277
01:10:41,540 --> 01:10:42,500
0,120 120,210 210,360 360,630 630,960
why does it {go,up -}?|
为什么它会上升？|

2278
01:10:48,510 --> 01:10:49,170
0,150 150,270 270,300 300,480 480,660
It's not a very deep
这不是一个很深奥的问题。

2279
01:10:49,170 --> 01:10:50,160
0,420
question.|
|

2280
01:10:54,170 --> 01:10:55,670
0,330 330,510 510,870 960,1380 1380,1500
They go up, sorry, go
它们上去，对不起，请继续。

2281
01:10:55,670 --> 01:10:57,470
0,300 630,1050 1230,1410 1410,1650 1650,1800
ahead.| Oh, I guess when
|哦，我想直到它饱和时，

2282
01:10:57,470 --> 01:10:58,680
0,300 300,630
they're like,

2283
01:10:58,680 --> 01:11:00,960
0,360 360,480 480,660 660,1740 2070,2280
until it gets saturated,| you
|你可以处理更多的输入包并生成更多的输出包。

2284
01:11:00,960 --> 01:11:03,960
0,390 540,1560 1560,1920 1920,2250 2250,3000
can process more input packets

2285
01:11:04,230 --> 01:11:06,180
0,420 420,780 780,900 900,1200 1200,1950
and produce more output packets.|
|

2286
01:11:06,330 --> 01:11:08,490
0,930 960,1530 1530,1830 1830,2100 2100,2160
Absolutely, until something starts to
当然，在事情开始出错之前，

2287
01:11:08,490 --> 01:11:10,860
0,150 150,720 1680,1890 1890,2070 2070,2370
go wrong,| for every packet
|对于进入的每个包，路由器只是将它转发出去，

2288
01:11:10,860 --> 01:11:11,700
0,90 90,300 300,510 510,600 600,840
that comes in, the router

2289
01:11:11,700 --> 01:11:13,290
0,180 180,540 540,630 630,1050 1110,1590
just forwards it out,| so
|所以，直到事情出了问题，

2290
01:11:13,650 --> 01:11:14,700
0,120 120,360 420,720 720,930 930,1050
you know until things go

2291
01:11:14,700 --> 01:11:16,140
0,270 270,390 390,840 840,1320 1320,1440
wrong,| if packets arrive at
|如果数据包以每秒 2000 个的速度到达，

2292
01:11:16,140 --> 01:11:17,610
0,810 810,900 900,1230 1230,1410 1410,1470
{2000,packets} a second,| well, it
|它只是将每个输入数据包复制到输出，

2293
01:11:17,610 --> 01:11:18,960
0,180 180,570 570,780 780,1050 1050,1350
just copies every input packet

2294
01:11:18,960 --> 01:11:19,800
0,60 60,180 180,570 570,690 690,840
to the output| and that
|这意味着输出速率正好等于输入速率，

2295
01:11:19,800 --> 01:11:21,240
0,390 390,630 720,960 960,1290 1290,1440
means that the output rate

2296
01:11:21,240 --> 01:11:22,110
0,120 120,270 300,660 660,750 750,870
is just equal to the

2297
01:11:22,110 --> 01:11:23,180
0,360 360,630
input rate,|
|

2298
01:11:23,180 --> 01:11:23,960
0,180 180,330 330,390 390,540 540,780
so this is why y
所以这是为什么 y 等于 x ，

2299
01:11:23,960 --> 01:11:25,640
0,330 330,1200
equals x,|
|

2300
01:11:25,890 --> 01:11:27,300
0,360 360,600 600,900 900,1200 1200,1410
because every input packet gets
因为每个输入包都被发送出去，

2301
01:11:27,300 --> 01:11:28,230
0,240 240,510 510,600 600,720 720,930
sent out,| so it's y
|所以有一段时间 y 等于 x 。

2302
01:11:28,230 --> 01:11:29,980
0,300 300,750 750,1200
equals x {for,a,while}.|
|

2303
01:11:30,130 --> 01:11:30,820
0,240 240,360 360,480 480,600 600,690
And so why does it
那么为什么它停止上升？

2304
01:11:30,820 --> 01:11:32,580
0,630 630,900 900,1140
stop going up?|
|

2305
01:11:39,620 --> 01:11:41,600
0,360 360,570 570,1200 1350,1740 1740,1980
Isn't this the one thing
这是不是他们在论文上提到的一件事，

2306
01:11:41,600 --> 01:11:42,590
0,120 120,480 480,570 570,660 660,990
they mentioned in the paper

2307
01:11:42,590 --> 01:11:46,200
0,600 1890,3030
about,| the
|它们无法以需要的速率处理中断。

2308
01:11:47,000 --> 01:11:49,940
0,300 300,870 870,1860 1920,2580 2580,2940
they're being interrupts that can't

2309
01:11:49,940 --> 01:11:52,130
0,420 420,1200 1200,1470 1470,1620 1620,2190
be processed at the necessary

2310
01:11:52,130 --> 01:11:53,930
0,390 810,1380 1380,1500 1500,1710 1710,1800
rate.| That's the answer to
|这是它为什么会下降的问题的答案。

2311
01:11:53,930 --> 01:11:55,220
0,60 60,690
the question,

2312
01:11:55,220 --> 01:11:56,390
0,210 210,360 360,420 420,510 510,1170
why does it go down.|
|

2313
01:11:58,600 --> 01:11:59,590
0,150 150,420 420,510 510,810 810,990
My question is why does
我的问题是，为什么它停止上升，是什么，

2314
01:11:59,590 --> 01:12:01,930
0,480 510,1140 1140,1410 1410,1890 1980,2340
it stop going up, what

2315
01:12:01,930 --> 01:12:02,860
0,180 180,360 360,540 540,720 720,930
is it,| that could this
|这个线在设计良好的系统中，

2316
01:12:02,860 --> 01:12:04,000
0,300 300,390 390,480 480,720 720,1140
line in a well designed

2317
01:12:04,000 --> 01:12:05,320
0,420 450,870 870,990 990,1110 1110,1320
system,| supposing that they hadn't
|如果他们没有搞乱设计的话，

2318
01:12:05,320 --> 01:12:06,920
0,240 240,390 390,450 450,990
messed up the design,

2319
01:12:07,140 --> 01:12:08,190
0,420 450,630 630,720 720,930 930,1050
right,| you and I would
|你和我会设计一个没有问题的系统，

2320
01:12:08,190 --> 01:12:09,210
0,270 270,330 330,660 660,780 780,1020
design a system that didn't

2321
01:12:09,210 --> 01:12:11,940
0,210 210,1050 1140,1680 1830,2250 2250,2730
have problems, right,| would our
|我们的系统会不会跟上这条线，继续往上走。

2322
01:12:11,940 --> 01:12:13,320
0,540 570,780 780,870 870,1170 1170,1380
system with the line, just

2323
01:12:13,320 --> 01:12:14,640
0,180 180,450 450,690
keep going up.|
|

2324
01:12:18,720 --> 01:12:21,000
0,510 510,840 840,1260 1260,2160 2160,2280
I guess not,| because at
我想不会，|因为在某一时刻，数据包到达的速率将会，

2325
01:12:21,000 --> 01:12:23,640
0,270 270,1050 1050,1680 2100,2550 2550,2640
some point the rate at

2326
01:12:23,640 --> 01:12:25,360
0,480 480,1260
which packets

2327
01:12:25,530 --> 01:12:27,260
0,540 540,1230
come will,|
|

2328
01:12:27,590 --> 01:12:28,780
0,630

2329
01:12:28,980 --> 01:12:31,560
0,750 750,1020 1020,1260 1260,1830 1830,2580
if you can process packets
如果你可以足够快地处理数据包，

2330
01:12:31,860 --> 01:12:34,080
0,390 390,810 810,1350 1380,1920 1920,2220
fast enough,| then at some
|那么在某一点上，

2331
01:12:34,080 --> 01:12:37,620
0,690 1080,1800 2130,2610 2730,3420 3420,3540
point,| {} the bottleneck will
|瓶颈将是数据包到达的速率。

2332
01:12:37,620 --> 01:12:38,370
0,120 120,240 240,450 450,540 540,750
be the rate at which

2333
01:12:38,370 --> 01:12:41,130
0,390 390,930 1560,2070 2070,2340 2340,2760
packets arrived.| That's right, this
|对，我们现在说的这个系统是有一些限制，

2334
01:12:41,130 --> 01:12:42,450
0,420 420,540 540,810 810,990 990,1320
system we're talking about has

2335
01:12:42,480 --> 01:12:44,520
0,210 210,930 1080,1440 1440,1500 1500,2040
has some sort of limits,|
|

2336
01:12:44,520 --> 01:12:45,720
0,270 480,660 660,960 960,1020 1020,1200
{you,know} the CPU is not
你知道 CPU 不是无限快的，

2337
01:12:45,750 --> 01:12:48,570
0,540 540,1080 1080,1440 1440,2250 2430,2820
infinitely fast,| CPU executes, however
|无论 CPU 每秒执行多少条指令，不会更多，

2338
01:12:48,570 --> 01:12:49,830
0,150 150,690 690,780 780,1140 1140,1260
many instructions per second and

2339
01:12:49,830 --> 01:12:51,750
0,150 150,540 810,1260 1410,1800 1800,1920
no more,| so usually these
|所以通常这些数据包必须被处理，

2340
01:12:51,750 --> 01:12:53,220
0,300 300,570 570,660 660,780 780,1470
packets has to be processed,|
|

2341
01:12:53,220 --> 01:12:54,630
0,150 150,630 630,1170 1170,1320 1320,1410
the IP software has to
IP 软件必须查看报头并检查校验值，

2342
01:12:54,630 --> 01:12:55,650
0,180 180,270 270,330 330,870 870,1020
look at the header and

2343
01:12:55,650 --> 01:12:57,090
0,240 240,360 360,720 720,1170 1170,1440
check the {checksum -}| and
|并查找目地的址和它使用的表，

2344
01:12:57,090 --> 01:12:58,800
0,240 240,420 420,720 750,1290 1290,1710
look up the destination addresses

2345
01:12:58,800 --> 01:13:00,030
0,120 120,390 390,720 720,810 810,1230
and table whatever it takes,|
|

2346
01:13:00,060 --> 01:13:01,590
0,510 510,570 570,1050 1050,1140 1140,1530
hundreds or thousands of CPU
每个数据包需要数百或数千个 CPU 周期。

2347
01:13:01,590 --> 01:13:04,460
0,480 480,870 870,1470
cycles per packet.|
|

2348
01:13:04,810 --> 01:13:06,370
0,390 450,840 870,1020 1020,1290 1290,1560
And so we can never
所以我们不能指望这个线永远会上升，

2349
01:13:06,370 --> 01:13:07,630
0,300 300,720 720,870 870,1170 1170,1260
never expect these lines to

2350
01:13:07,630 --> 01:13:08,500
0,120 120,270 270,360 360,750 750,870
go up| and definitely it
|它肯定会在某个地方停下来，

2351
01:13:08,500 --> 01:13:11,890
0,240 240,570 570,1140 2160,2550 2940,3390
must stop somewhere, right| and
|我们可以确定，

2352
01:13:11,980 --> 01:13:13,120
0,300 300,540 570,780 780,840 840,1140
we can sort of tell

2353
01:13:13,120 --> 01:13:14,290
0,330 570,690 690,780 780,930 930,1170
what,| we can make some
|我们可以猜测，

2354
01:13:14,290 --> 01:13:15,640
0,690 690,840 840,990 990,1260 1260,1350
guesses,| on this system that
|这个系统最高可达 5000 ，但不会更多，

2355
01:13:15,640 --> 01:13:16,960
0,180 180,270 270,360 360,1140 1140,1320
goes up to {5000,and} no

2356
01:13:16,960 --> 01:13:18,880
0,510 840,1260 1350,1560 1560,1710 1710,1920
more,| {} and what that
|这向我们表明，

2357
01:13:18,880 --> 01:13:20,140
0,780
basically

2358
01:13:20,290 --> 01:13:21,640
0,630 630,810 810,1080 1080,1200 1200,1350
suggests to us is that|
|

2359
01:13:21,640 --> 01:13:23,230
0,60 60,210 210,480 480,1170 1170,1590
it takes about {200,microseconds -}
在这台计算机上处理每个数据包大约需要 200 微秒，

2360
01:13:23,230 --> 01:13:24,880
0,150 150,390 390,900 900,1140 1200,1650
on this computer to process

2361
01:13:24,880 --> 01:13:26,080
0,180 180,690
each packet,

2362
01:13:26,360 --> 01:13:28,220
0,180 180,420 420,660 840,1380 1380,1860
right,| that's what this point,|
|这就是这一点，|

2363
01:13:28,220 --> 01:13:29,600
0,120 540,840 840,930 930,990 990,1380
the fact that the inflection
拐点在这里意味着

2364
01:13:29,600 --> 01:13:31,610
0,210 210,300 300,510 510,930 930,2010
point is here means| suggests
|处理包的总成本大约是 200 微秒的 CPU 时间。

2365
01:13:31,640 --> 01:13:32,570
0,150 150,240 240,570 570,870 870,930
that the total cost of

2366
01:13:32,570 --> 01:13:34,820
0,420 420,750 750,840 840,1320 1710,2250
processing package is around {200,microseconds

2367
01:13:34,820 --> 01:13:36,780
0,360 360,780 780,1140
-} CPU time.|
|

2368
01:13:37,510 --> 01:13:39,340
0,120 120,240 240,660 660,900 1650,1830
It's a guess,| but it's
这是个猜测，|但很可能接近正确，

2369
01:13:39,340 --> 01:13:40,150
0,300 300,360 360,450 450,690 690,810
likely to be close to

2370
01:13:40,150 --> 01:13:41,470
0,480 570,780 780,840 840,1110 1110,1320
correct| and so there's no
|所以我们不可能得到，

2371
01:13:41,470 --> 01:13:42,340
0,300 300,420 420,540 540,750 810,870
way we could get,| you
|也许我们可以把软件做得更有效率一些，

2372
01:13:42,340 --> 01:13:43,060
0,120 120,390 390,480 480,600 600,720
know maybe we could make

2373
01:13:43,060 --> 01:13:43,960
0,90 90,450 450,480 480,690 690,900
the software a little more

2374
01:13:43,960 --> 01:13:45,460
0,510 510,660 660,840 840,1230 1230,1500
efficiently,| we could reduce that
|我们可以将其降低到每个包 150 微秒，

2375
01:13:45,460 --> 01:13:47,260
0,240 300,1080 1080,1380 1380,1680 1680,1800
to 150 {microseconds -} per

2376
01:13:47,260 --> 01:13:49,090
0,480 480,540 540,1110 1110,1320 1590,1830
packet or something,| and so
|所以也许我们可以把拐点往上移一点，

2377
01:13:49,090 --> 01:13:49,810
0,240 240,330 330,480 480,630 630,720
maybe we could move the

2378
01:13:49,810 --> 01:13:51,040
0,450 450,660 660,810 810,870 870,1230
inflection point up a bit,|
|

2379
01:13:51,070 --> 01:13:53,110
0,270 420,630 630,900 900,1440 1440,2040
but we're certainly faced with
但是我们确实面临着一些点，

2380
01:13:53,540 --> 01:13:55,160
0,450 450,870 870,930 930,1380 1410,1620
some point,| at which well
|就是这个系统可以处理的数据包的数量。

2381
01:13:55,160 --> 01:13:57,080
0,270 270,510 510,630 630,1080 1080,1920
that's just how many packets

2382
01:13:57,200 --> 01:13:58,670
0,150 150,330 330,660 660,810 810,1470
of this system can process.|
|

2383
01:14:00,760 --> 01:14:02,100
0,480
{You,know},
这并不一定是这里正在发生的事情，

2384
01:14:02,250 --> 01:14:03,420
0,510
{}

2385
01:14:03,570 --> 01:14:05,130
0,180 180,360 360,1080 1080,1320 1320,1560
that's not necessarily what's going

2386
01:14:05,130 --> 01:14:06,330
0,210 210,540 570,750 750,1110 1110,1200
on here,| it happens to
|这是这里会发生的事情，

2387
01:14:06,330 --> 01:14:07,200
0,90 90,270 270,510 510,690 690,870
be what's going on here,|
|

2388
01:14:07,200 --> 01:14:08,670
0,120 120,750 750,1050 1080,1380 1380,1470
but it's not written in
但它不是写在[]上，

2389
01:14:08,670 --> 01:14:11,980
0,630 1470,1710 1710,2190 2220,2760
[],| in fact the,
|事实上，还有其他瓶颈可能是限制，

2390
01:14:11,980 --> 01:14:13,600
0,360 360,660 660,1140 1140,1260 1260,1620
there's other bottlenecks that could

2391
01:14:13,600 --> 01:14:15,430
0,510 540,720 720,1080 1140,1440 1440,1830
be the limit,| other than
|除了 CPU 时间，

2392
01:14:15,670 --> 01:14:16,840
0,120 120,540 540,780 780,960 960,1170
{} CPU time,| which are
|值得考虑的最明显的是网速，

2393
01:14:16,870 --> 01:14:18,760
0,210 210,810 960,1200 1200,1440 1440,1890
worth considering the most obvious

2394
01:14:18,760 --> 01:14:19,570
0,150 150,240 240,660 660,720 720,810
is the speed of the

2395
01:14:19,570 --> 01:14:20,650
0,450 450,540 540,840 840,960 960,1080
network,| the network they were
|它们使用的网络仅以每秒 10 兆比特的速度运行，

2396
01:14:20,650 --> 01:14:21,850
0,300 300,540 540,630 630,930 930,1200
using ran at only ten

2397
01:14:21,850 --> 01:14:23,260
0,480 480,570 570,960 960,1140 1140,1410
megabits per second,| that's just
|这就是低级网络硬件发送比特的速度，

2398
01:14:23,260 --> 01:14:24,940
0,150 150,720 720,930
how fast the

2399
01:14:25,090 --> 01:14:26,640
0,390 390,510 510,930
low {level -}

2400
01:14:27,120 --> 01:14:29,790
0,600 600,1290 1350,1650 1650,2280 2520,2670
networking hardware sent bits| and
|所以，每秒传输的位永远不会超过一万，一千万位。

2401
01:14:29,790 --> 01:14:31,110
0,120 120,240 240,570 570,1140 1140,1320
so can never transmit more

2402
01:14:31,110 --> 01:14:32,490
0,120 120,300 300,690 690,900 900,1380
than ten thousand ten million

2403
01:14:33,040 --> 01:14:35,640
0,360 360,450 450,1020 1500,2010
bits per second {}.|
|

2404
01:14:35,730 --> 01:14:36,930
0,150 150,420 540,810 810,930 930,1200
And so that may also
所以，这也可能构成一个限制，

2405
01:14:36,930 --> 01:14:38,100
0,510 510,570 570,900 960,1080 1080,1170
constitute a limit| and so
|所以我们考虑，

2406
01:14:38,100 --> 01:14:39,390
0,90 90,450 450,660 660,1080 1080,1290
we're thinking about| whether maybe
|这是否真的是决定这个 5000 的原因。

2407
01:14:39,390 --> 01:14:41,160
0,270 270,630 630,840 840,1560 1590,1770
that's actually what's determining this

2408
01:14:41,160 --> 01:14:43,280
0,720
5000.|
|

2409
01:14:44,260 --> 01:14:45,320
0,420

2410
01:14:45,590 --> 01:14:46,550
0,150 150,330 330,630 630,720 720,960
I don't {}, the paper
我不知道，论文上说的不够，

2411
01:14:46,550 --> 01:14:47,930
0,180 180,510 510,840 840,1290 1290,1380
doesn't quite say enough| to
|知道是 CPU 还是网卡是这里的限制因素，

2412
01:14:47,930 --> 01:14:49,610
0,450 690,960 960,1110 1110,1560 1560,1680
know whether it's, whether it's

2413
01:14:49,610 --> 01:14:51,170
0,570 570,720 720,840 840,1230 1380,1560
CPU or the NIC is

2414
01:14:51,170 --> 01:14:53,180
0,120 120,420 420,810 810,1200 1740,2010
the limiting factor here,| but
|但事实是，它们的 10 兆网络，

2415
01:14:53,180 --> 01:14:54,560
0,90 90,420 420,570 570,990 1020,1380
the fact is with with

2416
01:14:54,560 --> 01:14:57,350
0,540 660,990 990,1410 1410,1950 2610,2790
their ten megabit network,| if
|如果你发送小数据包，

2417
01:14:57,350 --> 01:14:59,840
0,180 180,720 720,1080 1080,1770 2160,2490
you send small packets, {}|
|

2418
01:14:59,840 --> 01:15:02,360
0,180 390,900 1140,1470 1470,1920 1920,2520
it's the ten megabits translates
那就是 10 兆比特转换成某些东西，

2419
01:15:02,360 --> 01:15:03,500
0,180 180,570 570,840 840,1080 1080,1140
into something,| like ten or
|比如每秒 10000 或 15000 个数据包，

2420
01:15:03,500 --> 01:15:05,720
0,1230 1230,1350 1350,1710
{15,000,packets} per second,|
|

2421
01:15:05,780 --> 01:15:07,040
0,300 300,450 450,810 810,1020 1020,1260
that's the limit that the
这是网线对输入速率的限制，

2422
01:15:07,550 --> 01:15:10,280
0,840 840,1590 2070,2310 2310,2490 2490,2730
networking cable puts on the

2423
01:15:10,490 --> 01:15:12,620
0,630 1050,1560 1620,1860 1860,1950 1950,2130
input rate| and so this
|所以，这远远低于网络所能达到的每秒 10000 或 15000 个数据包，

2424
01:15:12,620 --> 01:15:14,760
0,120 120,540 540,1140 1140,1560
is well under {}

2425
01:15:15,050 --> 01:15:16,850
0,360 390,660 660,720 720,1710 1710,1800
the ten or {15,000,packets} per

2426
01:15:16,850 --> 01:15:17,930
0,360 360,480 480,570 570,960 960,1080
second,| that the network is
|这个网络的能力，

2427
01:15:17,930 --> 01:15:19,280
0,450 450,570 570,720 720,1050 1050,1350
capable of,| so almost certainly,|
|所以，几乎可以肯定的是，|

2428
01:15:19,280 --> 01:15:20,030
0,150 150,360 360,540 540,630 630,750
the limit has to do
限制与 CPU 或内存或其他因素有关，

2429
01:15:20,030 --> 01:15:21,830
0,270 420,1230 1230,1320 1320,1740 1740,1800
with CPU or memory or

2430
01:15:21,830 --> 01:15:23,580
0,330 330,450 450,690 690,1110
something| and not the,
|而不是网络本身。

2431
01:15:23,780 --> 01:15:25,360
0,270 270,330 330,630 630,1080
not the network itself.|
|

2432
01:15:26,400 --> 01:15:29,220
0,570
Okay.|
好的。|

2433
01:15:30,050 --> 01:15:31,580
0,240 240,420 420,720 720,840 840,1530
What we'd love to see,
我们希望在一个设计良好的路由器中看到的是，

2434
01:15:31,730 --> 01:15:33,020
0,180 180,360 360,570 570,870 870,1290
in a well designed router

2435
01:15:33,020 --> 01:15:35,990
0,180 180,540 1770,2100 2100,2400 2400,2970
is that| it can actually
|它需要 200 微秒，

2436
01:15:35,990 --> 01:15:37,340
0,150 150,270 270,420 420,690 690,1350
you know it takes {200,microseconds

2437
01:15:37,340 --> 01:15:38,570
0,330 330,450 450,720 720,780 780,1230
-}| to forward the packet
|来转发数据包，处理数据包，

2438
01:15:38,660 --> 01:15:39,950
0,150 150,510 510,570 570,930 960,1290
to process a packet,| what
|我们希望看到的是，

2439
01:15:39,950 --> 01:15:40,700
0,120 120,300 300,390 390,630 630,750
we'd like to see is|
|

2440
01:15:40,700 --> 01:15:41,660
0,150 150,240 240,570 570,690 690,960
that the thing the router
无论如何，路由器实际上每秒可以转发 5000 个数据包，

2441
01:15:41,660 --> 01:15:43,610
0,90 90,360 360,960 960,1860 1860,1950
can actually forward {5000,packets} per

2442
01:15:43,610 --> 01:15:45,170
0,540 600,840 840,1050 1050,1350 1350,1560
second, no matter what,| even
|即使负荷很高，

2443
01:15:45,170 --> 01:15:46,070
0,90 90,180 180,450 450,570 570,900
if the load is high,|
|

2444
01:15:46,220 --> 01:15:47,720
0,240 240,540 540,1050 1050,1380 1380,1500
so what we'd like to
所以我们想要的是这条线。

2445
01:15:47,720 --> 01:15:50,270
0,720 750,900 900,1530 1560,2040 2040,2550
succeed is this line here.|
|

2446
01:15:51,240 --> 01:15:53,280
0,450 810,1080 1080,1410
{} There's a
这里有一个输出速率与输入速率相匹配，

2447
01:15:53,310 --> 01:15:54,540
0,420 420,540 540,870 870,960 960,1230
output rate matches the input

2448
01:15:54,540 --> 01:15:55,410
0,210 210,450 450,600 600,780 780,870
rate| until you get up
|直到你达到系统的容量，

2449
01:15:55,410 --> 01:15:56,760
0,120 120,330 330,1020 1020,1140 1140,1350
to the capacity of the

2450
01:15:56,760 --> 01:15:59,400
0,690 1320,1470 1470,1740 1770,2550 2550,2640
system,| you know {5000,packets} per
|每秒 5000 个数据包，

2451
01:15:59,400 --> 01:16:00,210
0,270 270,360 360,510 510,630 630,810
second| and then it just
|然后它继续以每秒 5000 个数据包的速度转发，

2452
01:16:00,210 --> 01:16:02,460
0,390 390,690 960,1320 1320,2160 2160,2250
continues to forward {5000,packets} per

2453
01:16:02,460 --> 01:16:04,920
0,390 390,750 840,1350 1350,1950 1950,2460
second| and presumably drops discards
|很可能丢弃其他的。

2454
01:16:04,920 --> 01:16:07,020
0,90 90,630
the rest.|
|

2455
01:16:08,540 --> 01:16:09,980
0,180 180,360 360,600 1050,1320 1320,1440
So this is what we'd
这就是我们想要设计的东西，

2456
01:16:09,980 --> 01:16:11,060
0,180 180,270 270,810 810,930 930,1080
like to design,| but what
|但实际发生的情况远比这更糟糕，

2457
01:16:11,060 --> 01:16:12,230
0,270 270,480 480,570 570,900 900,1170
actually happened is much worse

2458
01:16:12,230 --> 01:16:13,700
0,120 120,480 810,1170 1170,1350 1350,1470
than that,| {} as you
|当你将速率提高到 5000 以上时，

2459
01:16:13,700 --> 01:16:16,340
0,420 420,510 510,780 780,1080 1080,2640
increase the rate beyond 5000,|
|

2460
01:16:16,340 --> 01:16:17,570
0,360 360,420 420,750 750,900 900,1230
{the,number} of packets that []
转发的数据包数量将降至 0 。

2461
01:16:17,570 --> 01:16:18,650
0,90 90,450 450,600 600,810 810,1080
the forward goes down towards

2462
01:16:18,650 --> 01:16:19,620
0,390
0.|
|

2463
01:16:20,790 --> 01:16:21,510
0,180 180,300 300,390 390,540 540,720
So why is this line
那么为什么这条线往下走，

2464
01:16:21,510 --> 01:16:23,160
0,90 90,570 840,1200 1200,1500 1500,1650
go down,| somebody mentioned this
|之前有人提到过。

2465
01:16:23,160 --> 01:16:24,200
0,450
before.|
|

2466
01:16:35,220 --> 01:16:36,340
0,240 240,540
Well, the,
好的，作者想出了一个原因，

2467
01:16:36,340 --> 01:16:37,940
0,330 330,660 720,990
there's a {}

2468
01:16:38,200 --> 01:16:40,750
0,330 330,450 450,570 570,1350 2250,2550
reason that the authors figured

2469
01:16:40,750 --> 01:16:42,310
0,270 270,450 450,780 840,1410 1410,1560
out is that| as you
|当你提高输入速率时，

2470
01:16:42,310 --> 01:16:43,480
0,300 300,420 420,780 780,1020 1020,1170
increase the input rate,| each
|每个输入数据包都会生成中断，

2471
01:16:43,480 --> 01:16:45,160
0,90 90,360 360,720 720,1260 1260,1680
of these input packets generates

2472
01:16:45,160 --> 01:16:46,640
0,150 180,990
an interrupt,|
|

2473
01:16:47,300 --> 01:16:49,160
0,450 540,780 780,1380 1380,1590 1590,1860
and the interrupts take time,|
而中断使用时间，|

2474
01:16:49,160 --> 01:16:50,270
0,240 240,360 360,480 480,810 810,1110
actually on their system interrupts
实际上在它们的系统上，中断是相当昂贵的，

2475
01:16:50,270 --> 01:16:51,440
0,60 60,270 270,810 810,1050 1050,1170
are quite expensive,| because they
|因为它们涉及

2476
01:16:51,440 --> 01:16:53,870
0,660 1020,1350 1530,1980 1980,2070 2070,2430
involve| {} copying a packet
|将数据包从网卡复制到主内存中，

2477
01:16:53,900 --> 01:16:55,160
0,360 360,450 450,570 570,840 840,1260
off of the network interface

2478
01:16:55,160 --> 01:16:56,630
0,480 510,690 690,900 900,1080 1080,1470
card and into main memory|
|

2479
01:16:56,630 --> 01:16:57,650
0,270 300,450 450,480 480,720 720,1020
which took a long time,|
这花了很长时间，|

2480
01:16:57,650 --> 01:16:58,790
0,180 180,270 270,690 690,840 840,1140
because the CPU was doing,|
因为 CPU 正在做，|

2481
01:16:59,420 --> 01:17:01,430
0,210 210,480 510,1020 1290,1590 1740,2010
{} so each, so we
所以我们知道数据包以每秒 10000 个的速度到达，

2482
01:17:01,430 --> 01:17:02,810
0,360 360,540 540,960 960,1260 1260,1380
know with packets arriving at

2483
01:17:02,810 --> 01:17:04,100
0,510 510,750 750,840 840,1080 1080,1290
{10,000,per} second,| we certainly can't
|我们当然不能转发 10000 个，

2484
01:17:04,100 --> 01:17:06,740
0,330 330,1530 1710,2040 2040,2460 2490,2640
forward 10,000,| {and,that} means the
|这意味着我们最多只能希望转发 5000 ，

2485
01:17:06,740 --> 01:17:07,640
0,300 300,360 360,480 480,690 690,900
best we can hope for

2486
01:17:07,640 --> 01:17:09,440
0,120 120,210 210,630 630,930 930,1800
is to forward 5000,| and
|然后简单地丢弃剩下的 5000 ，

2487
01:17:09,470 --> 01:17:11,330
0,390 390,1230 1260,1410 1410,1620 1620,1860
simply discard the {other,5000 -},|
|

2488
01:17:11,330 --> 01:17:13,670
0,570 570,690 690,1320 1500,2010 2010,2340
but in fact {the,extra} 5000
但实际上额外的 5000 个包，

2489
01:17:13,670 --> 01:17:16,460
0,1020 1020,1290 1290,1830 1890,2220 2220,2790
packets,| each generated very expensive
|每个包都会产生非常昂贵的中断，

2490
01:17:16,460 --> 01:17:18,740
0,540 1230,1440 1440,1620 1620,1800 1800,2280
interrupt,| so for each additional
|所以，对于每秒 5000 个以上的额外数据包，

2491
01:17:18,740 --> 01:17:21,380
0,360 360,570 570,1530 1530,2190
{packet,over} 5000 per second,|
|

2492
01:17:21,440 --> 01:17:22,820
0,150 150,360 360,780 780,1260 1260,1380
{} we're generating more and
我们产生了越来越昂贵的中断，

2493
01:17:22,820 --> 01:17:24,560
0,240 240,810 810,1380 1380,1560 1560,1740
more expensive interrupts,| which have
|它们有优先权，

2494
01:17:24,560 --> 01:17:26,630
0,870 900,1080 1080,1560 1560,1800 1800,2070
priority,| like interrupts boy whatever
|中断不管你在做什么，

2495
01:17:26,630 --> 01:17:28,460
0,90 90,540 720,990 990,1740 1740,1830
you're doing,| it stops the
|它会停止机器，接受中断，

2496
01:17:28,460 --> 01:17:30,120
0,300 300,540 540,600 600,1170
machine, takes the interrupt,|
|

2497
01:17:32,170 --> 01:17:33,850
0,510 510,600 600,960 960,1080 1080,1680
because the machine is essentially
因为机器优先考虑这些中断，

2498
01:17:33,850 --> 01:17:35,680
0,240 240,750 750,960 960,1530 1560,1830
giving priority these interrupts,| that
|这意味着每秒每个额外的数据包

2499
01:17:35,680 --> 01:17:37,120
0,210 210,600 600,990 990,1350 1350,1440
means every additional packet per

2500
01:17:37,120 --> 01:17:39,130
0,600 690,930 930,1320 1320,1770 1770,2010
second| is taking CPU time
|占用转发代码的 CPU 时间，

2501
01:17:39,130 --> 01:17:41,770
0,660 660,1350 1710,1980 1980,2130 2130,2640
away from {} the forwarding

2502
01:17:41,770 --> 01:17:42,880
0,570
code,|
|

2503
01:17:42,880 --> 01:17:43,800
0,360

2504
01:17:43,890 --> 01:17:45,330
0,480 480,810 810,1110 1110,1380 1380,1440
until finally {100% -} of
直到最终 100% 的 CPU 时间在输入中断例程中用完，

2505
01:17:45,330 --> 01:17:46,320
0,90 90,420 420,660 660,750 750,990
the CPU time is used

2506
01:17:46,320 --> 01:17:47,460
0,180 210,360 360,450 450,780 780,1140
up in the input interrupt

2507
01:17:47,460 --> 01:17:49,440
0,420 510,900 900,1140 1140,1620 1620,1980
routine| and no CPU time
|并且没有 CPU 时间可以用在转发数据的线程上。

2508
01:17:49,440 --> 01:17:51,600
0,120 120,720 1290,1560 1560,1650 1650,2160
is used in the thread

2509
01:17:51,600 --> 01:17:53,080
0,240
that

2510
01:17:53,080 --> 01:17:54,600
0,330 330,930
forwards packets.|
|

2511
01:17:56,730 --> 01:17:57,870
0,120 120,360 360,750 750,840 840,1140
Is everyone happy with this
大家对这个解释满意吗？

2512
01:17:57,870 --> 01:17:59,100
0,600
explanation?|
|

2513
01:18:02,690 --> 01:18:05,570
0,180 180,420 420,780 780,1470 2220,2880
And this going down, {}
这个下降，就是所谓的中断活锁。

2514
01:18:07,060 --> 01:18:09,580
0,180 180,900 1230,1680 1680,1920 1920,2520
it's called interrupt live lock.|
|

2515
01:18:11,660 --> 01:18:12,860
0,150 150,390 390,540 870,1050 1050,1200
The fact that this line
这条线下降，而不是直线，

2516
01:18:12,860 --> 01:18:14,210
0,150 150,690 720,990 990,1050 1050,1350
goes down instead of saying

2517
01:18:14,240 --> 01:18:15,830
0,270 270,540 540,780 780,1050 1050,1590
string [],| what people mean
|人们所说的中断活锁，

2518
01:18:15,830 --> 01:18:18,860
0,390 600,1140 1140,1290 1290,1740 2790,3030
by interrupt live lock| and
|这是一个在许多系统中都会发生的现象，

2519
01:18:18,860 --> 01:18:20,750
0,510 510,870 870,990 990,1710 1710,1890
it's actually a phenomenon that

2520
01:18:20,750 --> 01:18:23,120
0,990 1290,1740
occurs {}

2521
01:18:23,180 --> 01:18:25,850
0,180 180,480 480,1440 1830,2160 2400,2670
in many systems,| I mean
|我的意思是驱动它的东西是，

2522
01:18:25,850 --> 01:18:26,810
0,180 180,570 570,630 630,780 780,960
the sort of thing that's

2523
01:18:26,810 --> 01:18:27,800
0,360 360,480 480,600 600,750 750,990
driving it is| that there's
|这里有两个不同的任务，

2524
01:18:27,800 --> 01:18:30,050
0,180 180,690 690,1620 1830,2010 2010,2250
two separate tasks,| like the
|比如输入中断任务和转发任务，

2525
01:18:30,110 --> 01:18:31,580
0,420 420,720 720,1290 1290,1380 1380,1470
input interrupt task and the

2526
01:18:31,580 --> 01:18:33,170
0,480 480,1080 1110,1260 1260,1470 1470,1590
forwarding task,| and because of
|并且由于调度问题，

2527
01:18:33,170 --> 01:18:36,960
0,90 90,1230 1410,2340
a scheduling problem,|
|

2528
01:18:37,230 --> 01:18:39,150
0,420 450,1050 1050,1590 1590,1680 1680,1920
{} essentially priority is given
优先考虑输入任务，

2529
01:18:39,150 --> 01:18:40,320
0,90 90,210 210,570 570,990 990,1170
to the input task,| which
|会使包处理任务饥饿，

2530
01:18:40,320 --> 01:18:43,320
0,120 120,990 1170,1470 1920,2460 2460,3000
can starve {} packet processing

2531
01:18:43,320 --> 01:18:45,030
0,480 750,930 930,1140 1140,1350 1380,1710
task,| in pretty much any
|在几乎任何具有多个独立任务

2532
01:18:45,030 --> 01:18:48,270
0,630 960,1140 1140,1620 1680,2730 2730,3240
system that has multiple independent

2533
01:18:48,270 --> 01:18:50,280
0,930 1050,1290 1290,1470 1470,1530 1530,2010
tasks| or sort of sequence
|或一系列独立任务的系统中，

2534
01:18:50,280 --> 01:18:51,660
0,90 90,510 510,1110 1110,1230 1230,1380
of independent tasks,| that need
|这需要对每个输入完成操作，

2535
01:18:51,660 --> 01:18:52,440
0,90 90,180 180,510 510,630 630,780
to be done to each

2536
01:18:52,440 --> 01:18:53,790
0,510 630,960 960,1050 1050,1200 1200,1350
input| and in which the
|而输入率不一定是可控的，

2537
01:18:53,790 --> 01:18:55,620
0,450 450,750 870,1200 1200,1710 1710,1830
input rate can't necessarily be

2538
01:18:55,620 --> 01:18:56,740
0,690
controlled,|
|

2539
01:18:56,800 --> 01:18:58,300
0,390 390,780 780,930 930,1200 1320,1500
many systems like that will
许多这样的系统都会显示活锁，

2540
01:18:58,300 --> 01:18:59,830
0,510 510,930 930,1170 1170,1440 1440,1530
exhibit exhibit live lock,| if
|如果太过用力。

2541
01:18:59,830 --> 01:19:00,940
0,120 120,330 330,450 450,600 600,1110
you push them too hard.|
|

2542
01:19:01,540 --> 01:19:02,540
0,510

2543
01:19:03,220 --> 01:19:04,120
0,270 270,360 360,450 450,630 630,900
And you can get live
你会遇到活锁，可能因为多种资源，不仅是使用 CPU，

2544
01:19:04,120 --> 01:19:06,430
0,420 1110,1440 1440,1500 1500,1770 1770,2310
lock due to many resources

2545
01:19:06,430 --> 01:19:07,600
0,210 210,390 390,810 810,1020 1020,1170
not just CPU,| but it
|它可能是网卡，

2546
01:19:07,600 --> 01:19:09,130
0,240 240,480 480,780 870,1230 1230,1530
could be that the NIC,|
|

2547
01:19:09,130 --> 01:19:10,900
0,90 90,300 330,900 900,1080 1080,1770
you know NIC {DMAs -}
网卡 DMA 耗尽了 RAM 周期来执行 DMA ，

2548
01:19:11,530 --> 01:19:13,570
0,450 450,870 900,1350 1350,1950 1950,2040
uses up RAM cycles to

2549
01:19:13,570 --> 01:19:14,980
0,120 120,240 240,690 690,1080 1170,1410
do the {DMAs -}| and
|如果网卡正在使用 RAM ，

2550
01:19:14,980 --> 01:19:16,180
0,60 60,180 180,630 660,930 930,1200
if the NIC is using

2551
01:19:16,180 --> 01:19:17,530
0,90 90,540 570,660 660,1050 1050,1350
the RAM,| the CPU can't
|CPU 就不能使用 RAM ，

2552
01:19:17,530 --> 01:19:18,640
0,150 150,240 240,570 630,840 840,1110
use the RAM,| so another
|所以另一种获得活锁的方法，

2553
01:19:18,640 --> 01:19:19,930
0,270 270,360 360,570 570,870 870,1290
way to get live lock,|
|

2554
01:19:20,020 --> 01:19:20,980
0,330 330,450 450,540 540,660 660,960
even if you have lots
即使你有很多 CPU 时间，

2555
01:19:20,980 --> 01:19:22,780
0,60 60,480 480,900 1200,1500 1500,1800
of CPU time,| you know
|一些其他的设计，你也可能会得到活锁，

2556
01:19:22,870 --> 01:19:24,190
0,360 390,630 630,960 960,1050 1050,1320
some other design, you might

2557
01:19:24,190 --> 01:19:26,050
0,480 480,720 720,840 840,1290 1560,1860
{live,lock},| because the NIC is
|由于网卡正在耗尽 RAM 资源，

2558
01:19:26,050 --> 01:19:27,220
0,360 360,720
using up

2559
01:19:29,120 --> 01:19:31,550
0,390 420,870 870,1410 1410,1860 1860,2430
{} RAM resources, RAM performance

2560
01:19:31,550 --> 01:19:33,440
0,480 480,600 600,690 690,1200 1650,1890
resources,| so the CPU was
|所以 CPU 使用 RAM 的能力变差。

2561
01:19:33,440 --> 01:19:34,250
0,240 240,450 450,540 540,720 720,810
less able to use the

2562
01:19:34,250 --> 01:19:37,100
0,390 1860,2190 2190,2430 2430,2640 2640,2850
RAM.| Anyway, this line going
|不管怎样，这条线下降就是他们所说的活锁。

2563
01:19:37,100 --> 01:19:38,660
0,330 330,690 1080,1320 1320,1410 1410,1560
down is what they mean

2564
01:19:38,660 --> 01:19:40,100
0,150 150,930
by {live,lock}.|
|

2565
01:19:40,310 --> 01:19:41,630
0,240 240,330 330,690 690,870 870,1320
You may ask what happens
你可能会问，多余的数据包会发生什么情况，

2566
01:19:41,630 --> 01:19:43,910
0,90 90,210 210,600 600,1380 1800,2280
to the extra packets {}|
|

2567
01:19:44,150 --> 01:19:45,650
0,270 270,360 360,510 510,1110 1110,1500
and if you recall the
如果你回想一下他们的软件结构，

2568
01:19:45,980 --> 01:19:48,830
0,1170 1170,1320 1320,2010 2040,2700 2700,2850
structure of their software,| was
|它们有网卡，处理接收中断，

2569
01:19:48,830 --> 01:19:49,880
0,120 120,240 240,330 330,480 480,1050
that they had been NIC

2570
01:19:50,660 --> 01:19:52,340
0,270 270,480 480,900 900,1560 1560,1680
{} that basically feeds the

2571
01:19:52,340 --> 01:19:54,000
0,420 420,1080
receive interrupt,|
|

2572
01:19:54,000 --> 01:19:56,340
0,390 390,780 780,1440 1620,2160 2160,2340
received interrupt software copies each
接收中断软件复制每个数据包到一个队列，

2573
01:19:56,340 --> 01:19:58,460
0,420 420,660 660,750 750,1500
packet into a queue,|
|

2574
01:19:58,610 --> 01:20:00,080
0,150 150,300 300,690 720,1230 1230,1470
and then there's some sort
然后有某个网络线程，

2575
01:20:00,080 --> 01:20:02,740
0,330 660,1230 1230,2010
of network thread,|
|

2576
01:20:02,950 --> 01:20:04,220
0,420

2577
01:20:04,220 --> 01:20:05,210
0,150 150,360 360,720 720,900 900,990
that pulls packets off the
将数据包从队列中拉出，

2578
01:20:05,210 --> 01:20:07,820
0,450 1140,1590 1620,2160 2160,2430 2430,2610
queue,| the exact place where
|数据包丢失的确切位置就在这里。

2579
01:20:07,820 --> 01:20:10,250
0,390 390,480 480,1110 1140,1590 2130,2430
packets are lost are right

2580
01:20:10,250 --> 01:20:11,380
0,630
here.|
|

2581
01:20:11,410 --> 01:20:12,250
0,180 180,300 300,360 360,720 720,840
What's going to happen is
接下来会发生的是中断例程，

2582
01:20:12,250 --> 01:20:14,590
0,120 120,210 210,630 630,1260 1710,2340
that the interrupt routine {},|
|

2583
01:20:14,980 --> 01:20:16,150
0,390 390,510 510,660 660,900 900,1170
once we get down here
一旦因为活锁，下降到这里，

2584
01:20:16,150 --> 01:20:19,960
0,210 210,1770 1830,2520 2520,3180 3630,3810
with serious live lock,| the
|中断例程将填充这个队列，

2585
01:20:19,960 --> 01:20:20,770
0,300 300,540 540,630 630,750 750,810
interrupt routine is going to

2586
01:20:20,770 --> 01:20:21,700
0,240 240,420 420,660 660,810 810,930
fill this queue,| there's going
|这里会有最大队列长度，

2587
01:20:21,700 --> 01:20:22,720
0,60 60,120 120,300 300,750 750,1020
to be some maximum queue

2588
01:20:22,720 --> 01:20:23,800
0,270 270,540 540,630 630,870 870,1080
length here,| you know, at
|至少所有的内存，但可能要少得多。

2589
01:20:23,800 --> 01:20:25,240
0,360 360,480 480,600 600,1170 1200,1440
least all the RAM, but

2590
01:20:25,240 --> 01:20:27,400
0,240 240,480 480,1170
probably much less.|
|

2591
01:20:27,550 --> 01:20:29,020
0,330 420,660 660,990 990,1350 1350,1470
And the interrupt routine is
中断例程从网卡上拉出一个数据包，

2592
01:20:29,020 --> 01:20:29,830
0,120 120,240 240,450 450,510 510,810
going to pull a packet

2593
01:20:29,830 --> 01:20:30,610
0,120 120,240 240,480 480,600 600,780
off the NIC| and see
|看到这个队列已经达到了允许的长度，

2594
01:20:30,610 --> 01:20:32,620
0,180 180,360 360,960 1620,1830 1830,2010
that this queue {} is

2595
01:20:32,620 --> 01:20:33,640
0,360 360,480 480,750 750,870 870,1020
already as long as it's

2596
01:20:33,640 --> 01:20:34,630
0,300 300,390 390,690 690,810 810,990
allowed to be| and the
|中断例程将丢弃数据包，

2597
01:20:34,840 --> 01:20:36,070
0,360 360,630 630,720 720,1170 1170,1230
interrupt routine will discard the

2598
01:20:36,070 --> 01:20:37,870
0,450 780,1170 1320,1560 1560,1620 1620,1800
packet,| but then of course
|当然在那之后，

2599
01:20:37,870 --> 01:20:38,920
0,420 420,660 660,810 810,960 960,1050
immediately after that,| there'll be
|还会有另一次中断，

2600
01:20:38,920 --> 01:20:40,460
0,330 330,930
another interrupt,|
|

2601
01:20:41,200 --> 01:20:42,160
0,420

2602
01:20:42,220 --> 01:20:43,630
0,540 540,630 630,1020 1020,1200 1200,1410
{the,interrupt,routine} will again {discard -}
中断例程将再次丢弃下一个数据包，

2603
01:20:43,630 --> 01:20:45,400
0,60 60,270 270,630 630,1320 1350,1770
the next packet,| because the
|因为网络线程总是被中断，并且永远不允许运行。

2604
01:20:45,460 --> 01:20:48,430
0,360 360,630 630,1110 2070,2400 2400,2970
network thread is always interrupted

2605
01:20:48,430 --> 01:20:49,330
0,120 120,300 300,570 570,660 660,900
and never allowed to run.|
|

2606
01:20:52,040 --> 01:20:53,940
0,480 480,660 660,780 780,1320
Questions about this diagram?|
关于这张图，有什么问题吗？|

2607
01:20:57,840 --> 01:20:59,190
0,210 210,270 270,360 360,600 600,1350
This is the most important
这是论文中最重要的图。

2608
01:20:59,820 --> 01:21:01,340
0,360 360,420 420,510 510,900
diagram in the paper.|
|

2609
01:21:05,100 --> 01:21:08,040
0,300 300,600 960,2250 2370,2760 2760,2940
Alright, well we've basically run
好的，我们快没时间了，

2610
01:21:08,040 --> 01:21:08,760
0,120 120,180 180,450 450,630 630,720
out of time,| so I'll
|所以我会试着把这个问题的答案压缩到一分钟内，

2611
01:21:08,760 --> 01:21:10,920
0,150 150,240 240,900 900,1200 1560,2160
try to compress the answer

2612
01:21:10,920 --> 01:21:12,540
0,180 180,390 390,960 1200,1560 1560,1620
to this problem into a

2613
01:21:12,540 --> 01:21:13,480
0,390
minute,|
|

2614
01:21:15,100 --> 01:21:16,570
0,150 150,390 390,720 720,750 750,1470
the authors proposed a solution,|
作者提出了一个解决方案，|

2615
01:21:17,120 --> 01:21:18,260
0,180 180,300 300,480 480,960 960,1140
{} the most immediately good
关于这个解决方案最直接的好消息是，

2616
01:21:18,260 --> 01:21:19,400
0,210 210,390 390,480 480,990 990,1140
news about the solution is|
|

2617
01:21:19,400 --> 01:21:20,840
0,240 330,720 720,810 810,930 930,1440
that this is the performance
这是他们的解决方案的性能，

2618
01:21:20,840 --> 01:21:22,190
0,90 90,240 240,720 840,1050 1050,1350
of their solution,| that is
|也就是说，输入率上升到 5000 ，

2619
01:21:22,190 --> 01:21:23,240
0,90 90,360 360,570 570,780 780,1050
the input rate goes up

2620
01:21:23,240 --> 01:21:25,310
0,630 630,720 720,810 810,1950 1950,2070
{to -} the 5000,| {and,then}
|然后是平坦的 5000 ，无论输入率是多少。

2621
01:21:25,310 --> 01:21:27,560
0,150 150,570 570,1770 1770,1860 1860,2250
its flat {5000,regardless} of input

2622
01:21:27,560 --> 01:21:30,650
0,420 2490,2670 2670,2820 2820,2910 2910,3090
rate.| So this is sort
|所以这是一条完美的非活锁性能线，

2623
01:21:30,650 --> 01:21:32,280
0,60 60,240 270,1050
of a perfect

2624
01:21:32,280 --> 01:21:35,070
0,630 630,930 930,1440 1560,2280 2280,2790
non live lock performance line,|
|

2625
01:21:35,650 --> 01:21:36,310
0,120 120,330 330,450 450,600 600,660
of course it's going to
当然会是平坦的，

2626
01:21:36,310 --> 01:21:38,020
0,150 150,480 480,1110 1500,1590 1590,1710
be flat,| because you can
|因为你每秒只能处理 5000 个数据包，

2627
01:21:38,020 --> 01:21:40,570
0,120 120,750 1020,2040 2040,2130 2130,2550
only process {5000,packets} per second,|
|

2628
01:21:41,350 --> 01:21:42,490
0,180 180,420 420,480 480,570 570,1140
the speed of the CPU|
CPU 的速度，|

2629
01:21:43,120 --> 01:21:44,200
0,240 240,420 420,630 630,810 810,1080
and the way they get
他们得到这个的方式，

2630
01:21:44,200 --> 01:21:45,640
0,510 540,660 660,1050 1050,1260 1260,1440
this,| they still have this
|他们仍然有这个网络线程，

2631
01:21:45,640 --> 01:21:47,240
0,420 420,990
network thread,|
|

2632
01:21:48,270 --> 01:21:49,460
0,630

2633
01:21:49,460 --> 01:21:50,360
0,180 180,270 270,630 630,780 780,900
and they still have an
而且他们仍然有一个中断例程。

2634
01:21:50,360 --> 01:21:52,020
0,390 390,1080
interrupt routine.|
|

2635
01:21:53,880 --> 01:21:55,500
0,450

2636
01:21:55,940 --> 01:21:57,260
0,480 480,600 600,870 870,1140 1140,1320
So the very first time
所以，当第一次网卡中断时，运行中断例程，

2637
01:21:57,260 --> 01:21:59,990
0,90 90,300 300,1170 1500,1920 2190,2730
the NIC interrupts {} run

2638
01:21:59,990 --> 01:22:00,800
0,60 60,390 390,630 630,720 720,810
the interrupt routine,| but the
|但是中断例程不从网卡复制数据包，

2639
01:22:00,800 --> 01:22:02,540
0,360 360,600 600,780 780,1380 1410,1740
interrupt routine does not copy

2640
01:22:02,540 --> 01:22:03,920
0,390 390,540 540,660 660,990 1050,1380
packets off the NIC,| it
|它唤醒网络线程，

2641
01:22:03,920 --> 01:22:05,480
0,480 480,630 630,720 720,1080 1080,1560
wakes up the network thread|
|

2642
01:22:05,660 --> 01:22:08,150
0,150 150,360 1020,1680 1680,2220 2250,2490
and then leaves interrupts on
然后使网卡上的中断处于禁用状态，

2643
01:22:08,150 --> 01:22:09,410
0,90 90,390 390,1050 1050,1170 1170,1260
the NIC disabled,| so we'll
|所以我们不会再被中断，

2644
01:22:09,410 --> 01:22:11,690
0,180 180,480 480,750 750,1470 1650,2280
get no more interrupts {},|
|

2645
01:22:11,930 --> 01:22:13,580
0,390 390,510 510,930 930,1290 1290,1650
{wake,up} the networking {thread,and} then
唤醒网络线程，然后中断例程返回，

2646
01:22:13,640 --> 01:22:15,230
0,120 120,420 420,930 1020,1170 1170,1590
the interrupt routine will return,|
|

2647
01:22:15,230 --> 01:22:16,430
0,150 150,300 300,750 750,810 810,1200
so now interrupts of {this,NIC}
所以现在这个网卡中断关闭，

2648
01:22:16,430 --> 01:22:18,710
0,390 390,960 1530,1770 1770,2160 2160,2280
turned off,| the network thread
|网络线程有一个循环，

2649
01:22:18,710 --> 01:22:20,260
0,330 330,480 480,540 540,1200
basically has a loop,|
|

2650
01:22:21,030 --> 01:22:22,680
0,600

2651
01:22:23,780 --> 01:22:26,330
0,750 960,1500 1830,2040 2040,2400 2400,2550
that {} {you,know} check the
它检查网卡，

2652
01:22:26,330 --> 01:22:27,710
0,360 360,600 600,960 960,1050 1050,1380
NIC,| {you,know} pull a few
|从网卡中提取几个数据包，

2653
01:22:27,710 --> 01:22:29,240
0,1080
packets

2654
01:22:30,560 --> 01:22:32,080
0,240 240,330 330,870
from the NIC,|
|

2655
01:22:34,040 --> 01:22:35,150
0,600 600,690 690,870 870,1020 1020,1110
5, I think is what
5 个，我想这是他们最终使用的，

2656
01:22:35,150 --> 01:22:36,350
0,120 120,300 300,390 390,870 960,1200
they ended up using| and
|然后处理这些数据包。

2657
01:22:36,350 --> 01:22:38,620
0,210 210,690 690,930 930,1680
then process those packets.|
|

2658
01:22:40,240 --> 01:22:42,730
0,600 810,1260 1260,1710 2190,2370 2370,2490
{} And then if there
如果没有的话，

2659
01:22:42,730 --> 01:22:45,010
0,120 120,780 1170,1380 1380,1770 1980,2280
were none,| if this {}
|如果这个检查，

2660
01:22:45,190 --> 01:22:46,810
0,270 270,600 600,840 840,1290 1290,1620
{you,know} check,| then it's this
|这个网络线程从网卡读取数据包，

2661
01:22:46,810 --> 01:22:48,070
0,450 450,720 720,900 900,1020 1020,1260
network thread {you,know} that reads

2662
01:22:48,070 --> 01:22:49,330
0,360 360,510 510,630 630,1020 1050,1260
packets off the NIC,| not
|而不是中断例程，

2663
01:22:49,330 --> 01:22:51,070
0,90 90,600 1050,1410 1410,1560 1560,1740
the {interrupt,routine},| {} if there
|如果没有等待的数据包，

2664
01:22:51,070 --> 01:22:53,280
0,420 420,630 630,1050 1050,1620
none, no packets waiting,|
|

2665
01:22:53,280 --> 01:22:55,460
0,180 180,750 750,1530
it enables interrupts,
它会启用中断，然后进入休眠状态，

2666
01:22:59,870 --> 01:23:01,370
0,210 210,570 570,840 840,930 930,1500
and then goes to sleep,|
|

2667
01:23:03,630 --> 01:23:05,370
0,300 300,540 540,660 660,1020 1020,1740
{} because it's enabled interrupts,|
因为它启用了中断，|

2668
01:23:05,790 --> 01:23:08,010
0,600 900,1230 1230,1350 1350,1650 1650,2220
{} next time packet arrives,|
下次数据包到达时，|

2669
01:23:08,010 --> 01:23:09,030
0,120 120,270 270,630 630,780 780,1020
{interrupt -} routine will wake
中断例程将唤醒这个线程，

2670
01:23:09,030 --> 01:23:10,530
0,180 180,390 390,930 1170,1410 1410,1500
up this thread| and {}
|从睡眠中醒来，回到循环的开端。

2671
01:23:10,530 --> 01:23:11,250
0,150 150,240 240,330 330,600 600,720
come out of sleep and

2672
01:23:11,250 --> 01:23:11,970
0,90 90,300 300,390 390,480 480,720
go back to the top

2673
01:23:11,970 --> 01:23:13,350
0,90 90,540 660,930 930,1140 1140,1380
of loop.| So this is,
|这就是他们解决方案的结构，

2674
01:23:13,380 --> 01:23:14,460
0,180 180,450 450,540 540,990 990,1080
this is the structure of

2675
01:23:14,460 --> 01:23:16,860
0,150 150,630 1170,1650 1890,2280 2280,2400
their solution| and one way
|看待这个的一种方式是，

2676
01:23:16,860 --> 01:23:18,080
0,60 60,270 270,810
to view this

2677
01:23:18,080 --> 01:23:18,920
0,120 120,270 270,420 420,720 720,840
is,| that they turn an
|他们将中断方案转变为轮询方案，

2678
01:23:18,950 --> 01:23:21,410
0,810 990,1680 1710,1920 1920,1980 1980,2460
interrupt scheme into a polling

2679
01:23:21,410 --> 01:23:23,030
0,570 810,990 990,1140 1140,1320 1320,1620
scheme,| that is under high
|在高负荷的情况下，

2680
01:23:23,030 --> 01:23:24,280
0,660
load,|
|

2681
01:23:24,280 --> 01:23:25,120
0,60 60,360 360,570 570,630 630,840
they just sit in this
它们只是在这个循环里，

2682
01:23:25,120 --> 01:23:26,180
0,540
loop,|
|

2683
01:23:26,300 --> 01:23:27,980
0,240 240,510 510,750 750,1140 1140,1680
and they read packet process,
它们在中断关闭的情况下读取包并处理，读取包并处理，

2684
01:23:27,980 --> 01:23:29,930
0,240 240,540 540,1050 1410,1620 1620,1950
read packet process, with interrupts

2685
01:23:29,930 --> 01:23:31,660
0,270 270,660 690,870 870,1110
turned off,| so they
|因为中断是关闭的，

2686
01:23:31,830 --> 01:23:33,280
0,240 240,840
{ -}

2687
01:23:33,550 --> 01:23:34,780
0,270 270,840 840,900 900,1110 1110,1230
since interrupts are turned off,|
|

2688
01:23:34,780 --> 01:23:35,920
0,90 90,420 420,570 570,720 720,1140
they never get this effect,|
所以永远不会有这个效果，|

2689
01:23:35,920 --> 01:23:37,390
0,120 120,180 180,570 570,1020 1020,1470
where the interrupts steal time
中断从主线程窃取时间，

2690
01:23:37,390 --> 01:23:38,920
0,180 180,240 240,450 450,900 1170,1530
from the main thread,| whereas
|而在低负载下，它们启用中断，

2691
01:23:38,920 --> 01:23:40,630
0,180 180,480 480,1050 1080,1260 1260,1710
under low load, they enable

2692
01:23:40,630 --> 01:23:41,840
0,690
interrupts,|
|

2693
01:23:41,840 --> 01:23:43,040
0,420 570,780 780,870 870,870 870,1200
and may be a while
在数据包到达之前可能需要一段时间，

2694
01:23:43,040 --> 01:23:44,540
0,270 270,660 660,1170 1230,1350 1350,1500
until packets arrive,| but they'll
|但是，它们会立即被中断例程唤醒，

2695
01:23:44,540 --> 01:23:45,710
0,150 150,450 450,780 900,1050 1050,1170
be woken up by the

2696
01:23:45,710 --> 01:23:46,940
0,330 330,600 600,1080 1080,1170 1170,1230
interrupt routine immediately| if a
|如果一个数据包到达。

2697
01:23:46,940 --> 01:23:48,360
0,270 270,510 510,750
packet does arrive.|
|

2698
01:23:50,440 --> 01:23:51,040
0,180 180,330 330,420 420,510 510,600
And that's all I have
这就是我要说的全部。

2699
01:23:51,040 --> 01:23:52,220
0,90 90,510
to say.|
|

2700
01:23:53,370 --> 01:23:58,380
0,180 180,930 2850,3120 3120,3630 3630,5010
Any questions?| {I,have} a question,|
有什么问题吗？|我有个问题，|

2701
01:23:59,200 --> 01:24:01,570
0,420 420,690 690,1260 1470,1950 1950,2370
is that loop looking at
这个循环是查看所有设备，

2702
01:24:01,570 --> 01:24:02,950
0,180 180,330 330,570 570,1170 1170,1380
all of the devices| or
|还是只查看生成中断的设备？

2703
01:24:02,950 --> 01:24:04,660
0,270 270,360 360,630 630,840 840,1710
only the one that generated

2704
01:24:04,720 --> 01:24:06,240
0,180 180,810
the interrupt?|
|

2705
01:24:07,420 --> 01:24:09,880
0,210 210,420 420,870 870,1830
If there's multiple NICs,|
如果有多个网卡，|

2706
01:24:10,250 --> 01:24:11,520
0,630
so
这是一个好问题，

2707
01:24:12,360 --> 01:24:13,680
0,510 540,720 720,780 780,930 930,1320
{} that's a good question,|
|

2708
01:24:14,460 --> 01:24:16,140
0,420 420,570 570,720 720,1110 1110,1680
{} if there's multiple NICs,
如果有多个网卡，这个循环，

2709
01:24:16,170 --> 01:24:18,150
0,330 330,960 1290,1530 1530,1710 1710,1980
the loop,| I don't actually
|我其实不知道循环是如何工作的，

2710
01:24:18,150 --> 01:24:18,990
0,90 90,210 210,450 510,720 720,840
know how the how the

2711
01:24:18,990 --> 01:24:21,540
0,270 270,510 1590,1770 1770,2130 2130,2550
loop works,| a very reasonable
|一个非常合理的设计是让这个网络线程跟踪，

2712
01:24:21,540 --> 01:24:23,160
0,570 570,780 780,930 930,1170 1170,1620
design is for this network

2713
01:24:23,160 --> 01:24:25,290
0,510 510,600 600,960 960,1560 1590,2130
thread to keep track of,|
|

2714
01:24:26,370 --> 01:24:28,620
0,300 330,930 960,1560 1620,2070 2070,2250
for every NIC whether it's
对于每个网卡，无论是中断模式还是轮询模式，

2715
01:24:28,620 --> 01:24:30,300
0,120 120,690 690,1050 1050,1200 1200,1680
an interrupting mode or polling

2716
01:24:30,300 --> 01:24:31,160
0,600
mode,|
|

2717
01:24:33,410 --> 01:24:34,820
0,600 840,1020 1020,1140 1140,1230 1230,1410
{} and then it will
然后它只会，

2718
01:24:34,820 --> 01:24:36,200
0,780
only,|
|

2719
01:24:36,530 --> 01:24:38,000
0,780
actually,
实际上，因为中断例程不再从网卡读取数据包，

2720
01:24:39,500 --> 01:24:40,790
0,360 360,450 450,780 780,1110 1110,1290
because the interrupt routines no

2721
01:24:40,790 --> 01:24:42,350
0,360 360,930 930,1050 1050,1170 1170,1560
longer {read,packet} from the NIC,|
|

2722
01:24:42,410 --> 01:24:43,610
0,240 240,570 570,720 720,930 930,1200
that means the loop probably
这意味着在这一点上循环可能会检查每个网卡，

2723
01:24:43,610 --> 01:24:45,170
0,390 390,750 750,1320 1320,1380 1380,1560
checks every interface at this

2724
01:24:45,170 --> 01:24:46,200
0,540
point,|
|

2725
01:24:46,200 --> 01:24:47,790
0,300 300,600 600,840 840,1110 1110,1590
every probably checks every NIC
在这一点上，可能检查每个网卡，

2726
01:24:48,370 --> 01:24:49,980
0,180 180,360 360,750 750,990
at this point,| then
|然后拉出，

2727
01:24:49,980 --> 01:24:51,420
0,210 210,420 480,750 750,930 930,1440
pulls up,| for every NIC,
|对于每个网卡，它都有几个数据包，

2728
01:24:51,980 --> 01:24:53,270
0,150 150,330 330,390 390,600 600,1290
it has a few packets,|
|

2729
01:24:53,270 --> 01:24:54,500
0,360 570,720 720,900 900,1080 1080,1230
packet if that NIC has
如果网卡有数据包在等待，

2730
01:24:54,500 --> 01:24:56,960
0,570 570,1170 1830,2130 2130,2220 2220,2460
packets waiting,| loop will pull
|循环将从网卡中取出几个并对其进行处理，

2731
01:24:56,960 --> 01:24:57,770
0,90 90,450 450,600 600,690 690,810
a few out of the

2732
01:24:57,770 --> 01:24:59,690
0,210 210,330 330,810 810,1140 1650,1920
NIC and process them| and
|如果所有的网卡都没有，

2733
01:24:59,690 --> 01:25:01,160
0,180 210,450 450,1170 1170,1320 1320,1470
then if none of the

2734
01:25:01,160 --> 01:25:03,360
0,720 750,990 990,1680
NICs had anything,|
|

2735
01:25:04,170 --> 01:25:05,070
0,300 300,420 420,660 660,810 810,900
if you checked all the
如果你检查了所有网卡，

2736
01:25:05,070 --> 01:25:05,850
0,210 210,360 360,570 570,660 660,780
NICs| and none of them
|但没有任何数据包在等待，

2737
01:25:05,850 --> 01:25:07,600
0,90 90,270 270,660 660,1140
at any packets waiting,|
|

2738
01:25:07,600 --> 01:25:08,800
0,120 120,300 300,450 450,840 840,1200
the loop will enable interrupts
这个循环将在所有网卡上启用中断，然后休眠，

2739
01:25:08,800 --> 01:25:10,540
0,120 120,330 330,450 450,1560 1560,1740
on all the NICs and

2740
01:25:10,540 --> 01:25:11,560
0,570
sleep,|
|

2741
01:25:11,560 --> 01:25:12,970
0,150 150,390 390,810 810,1290 1290,1410
and any NIC interrupts will
任何网卡中断都会唤醒它，

2742
01:25:12,970 --> 01:25:14,040
0,210 210,300 300,450
wake it up,|
|

2743
01:25:14,940 --> 01:25:16,340
0,210 210,330 330,870
that's my guess.|
这是我的猜测。|

2744
01:25:16,510 --> 01:25:19,820
0,330 330,690 720,1470 2100,2760
Okay, yeah, sounds reasonable.|
好的，听起来很合理。|

2745
01:25:21,500 --> 01:25:22,340
0,330 330,450 450,570 570,630 630,840
{} I had a quick
我有一个简短的问题，

2746
01:25:22,340 --> 01:25:24,410
0,330 330,600 600,1140 1590,1890 1890,2070
question then,| so how did
|当循环运行时，

2747
01:25:24,410 --> 01:25:26,180
0,450 480,1080 1080,1440 1440,1560 1560,1770
the, so while the loop

2748
01:25:26,180 --> 01:25:27,620
0,180 180,480 480,750 750,930 930,1440
is running,| how do packets
|数据包是如何进入要拉取的队列的，

2749
01:25:27,620 --> 01:25:30,560
0,750 780,1350 1380,1860 1860,2280 2310,2940
actually get into the queues

2750
01:25:30,740 --> 01:25:32,360
0,150 150,360 360,900 990,1350 1350,1620
to be pulled,| I felt
|我觉得一次只有一个。

2751
01:25:32,360 --> 01:25:33,470
0,240 630,780 780,900 900,1020 1020,1110
like there would only be

2752
01:25:33,470 --> 01:25:35,060
0,240 240,390 390,420 420,930
one at a time.|
|

2753
01:25:35,550 --> 01:25:37,100
0,510 510,930
Initially the,
数据包最初在网卡内部的私有内存中排队，

2754
01:25:37,580 --> 01:25:39,650
0,540 540,630 630,1080 1080,1350 1380,2070
initially the packets are queued

2755
01:25:39,740 --> 01:25:40,850
0,540 540,630 630,840 840,930 930,1110
inside the NIC in its

2756
01:25:40,850 --> 01:25:42,560
0,150 150,540 540,1110
own private memory,|
|

2757
01:25:43,500 --> 01:25:45,210
0,270 270,540 540,1200 1410,1590 1590,1710
then this loop,| you know
然后这个循环，|当它回到循环的开端时，

2758
01:25:45,210 --> 01:25:46,050
0,180 180,330 450,630 630,690 690,840
when it when it goes

2759
01:25:46,050 --> 01:25:46,740
0,210 210,270 270,360 360,630 630,690
back to the top of

2760
01:25:46,740 --> 01:25:48,000
0,90 90,630 690,960 960,1170 1170,1260
the loop,| it'll look at
|它查看每个网卡，

2761
01:25:48,000 --> 01:25:49,740
0,540 570,1230
each NIC,|
|

2762
01:25:50,120 --> 01:25:51,380
0,270 390,750 750,1050 1050,1140 1140,1260
and actually talk to the
并与网卡硬件通信，

2763
01:25:51,380 --> 01:25:53,060
0,210 210,960 1020,1200 1200,1590 1590,1680
NIC hardware| and asked do
|询问内存里有没有什么输入包在等待，

2764
01:25:53,060 --> 01:25:54,350
0,120 120,240 240,450 450,870 870,1290
you have any input packets

2765
01:25:54,350 --> 01:25:55,880
0,300 300,390 390,540 540,990 1380,1530
waiting in your memory,| and
|如果是这样，

2766
01:25:55,880 --> 01:25:56,840
0,90 90,150 150,450 450,690 690,960
if it does,| then this
|那么这个循环将在 RAM 中分配一个数据包缓冲区，

2767
01:25:56,840 --> 01:25:57,940
0,360 360,540
loop will,

2768
01:25:57,940 --> 01:25:59,440
0,330 540,660 660,1170 1170,1200 1200,1500
will {you,know} allocate a packet

2769
01:25:59,440 --> 01:26:02,680
0,360 360,450 450,1080 1650,2460 2700,3240
buffer in RAM| and copy
|并将数据包中的字节从网卡复制到数据包缓冲区，

2770
01:26:02,680 --> 01:26:03,910
0,120 120,630 630,720 720,810 810,1230
the bytes of the packet

2771
01:26:03,910 --> 01:26:05,280
0,150 150,210 210,330 330,810
out of the NIC

2772
01:26:06,060 --> 01:26:07,170
0,90 90,420 420,780 780,870 870,1110
{to,the} packet buffer| and then
|然后处理那个数据缓冲区。

2773
01:26:07,170 --> 01:26:08,800
0,420 420,570 570,870 870,1200
process that packet buffer.|
|

2774
01:26:08,800 --> 01:26:10,090
0,180 180,300 300,510 510,930 960,1290
So it can copy more
所以，它可以复制多个数据包。

2775
01:26:10,090 --> 01:26:11,470
0,120 120,420 420,840 900,1260 1260,1380
than one packet.| Yeah, I
|是的，我想它们是以 5 个一组的，

2776
01:26:11,470 --> 01:26:13,180
0,120 120,750 990,1530 1530,1620 1620,1710
think they do it in

2777
01:26:13,180 --> 01:26:14,530
0,300 300,390 390,990 990,1080 1080,1350
groups of 5,| in order
|为了，

2778
01:26:14,530 --> 01:26:15,400
0,300
to,|
|

2779
01:26:15,400 --> 01:26:16,300
0,300 300,390 390,540 540,600 600,900
even if there's a hundred
即使这里有一百个包在等待，

2780
01:26:16,300 --> 01:26:17,470
0,330 330,630 630,900 900,990 990,1170
packets waiting here,| it would
|它只处理接下来的 5 个，

2781
01:26:17,560 --> 01:26:18,820
0,300 300,630 630,690 690,900 900,1260
just process the next 5,|
|

2782
01:26:18,820 --> 01:26:19,780
0,90 90,330 330,390 390,540 540,960
in order to be fair
以便在输入网卡之间保持公平，从而避免饥饿。

2783
01:26:19,780 --> 01:26:21,700
0,240 240,600 600,1050 1050,1200 1200,1920
among input NICs to avoid

2784
01:26:22,520 --> 01:26:25,340
0,540 1470,1620 1620,1800 1800,2250 2250,2820
starving.| But this requires increasing
|但这可能可能需要增加网卡的内存容量，是吗？

2785
01:26:25,340 --> 01:26:26,630
0,120 120,480 480,1080 1080,1140 1140,1290
the memory capacity of the

2786
01:26:26,630 --> 01:26:30,560
0,420 480,810 930,1560 2340,3210
NIC, right, possibly?| Well,
|嗯，我不知道，

2787
01:26:33,170 --> 01:26:34,520
0,240 240,390 390,780
I don't know,|
|

2788
01:26:34,550 --> 01:26:35,690
0,150 150,270 270,330 330,450 450,1140
I don't know how much,|
我不知道多少，|

2789
01:26:36,490 --> 01:26:37,210
0,150 150,360 360,510 510,600 600,720
the NIC might have had
网卡可能有相当数量的，

2790
01:26:37,210 --> 01:26:38,980
0,60 60,510 510,870 870,1320
a reasonable amount of,|
|

2791
01:26:40,180 --> 01:26:42,970
0,420 420,630 630,1020 1320,1800 1800,2790
the thing is this interrupt,|
这个中断的问题是，|

2792
01:26:43,000 --> 01:26:45,040
0,270 270,510 510,840 840,1050 1050,2040
{you,know} this live lock phenomenon
这个活锁现象，在这个点以下，可能是在中断，

2793
01:26:45,310 --> 01:26:47,410
0,690 690,930 930,1440 1710,1830 1830,2100
below this point where probably

2794
01:26:47,410 --> 01:26:48,740
0,750
interrupting,|
|

2795
01:26:50,300 --> 01:26:51,600
0,630
and,
如果数据包到达，

2796
01:26:51,690 --> 01:26:53,640
0,180 180,240 240,540 540,1650 1830,1950
if a packet arrives,| the
|网络线程将立即被唤醒，

2797
01:26:53,640 --> 01:26:55,350
0,300 300,510 510,600 600,900 900,1710
network thread will almost immediately

2798
01:26:55,350 --> 01:26:56,280
0,150 150,450 450,630 630,720 720,930
be woken up| and pull
|并将数据包拉出，

2799
01:26:56,280 --> 01:26:58,260
0,60 60,480 960,1530 1530,1770 1770,1980
the packet out,| over here
|在这里，在这个机器中，

2800
01:26:58,260 --> 01:26:59,340
0,90 90,300 300,750 750,900 900,1080
in this machine,| where too
|有太多的数据包到达，

2801
01:26:59,340 --> 01:27:01,180
0,180 180,570 570,630 630,1260
many packets are arriving,|
|

2802
01:27:01,420 --> 01:27:03,220
0,570 870,1320 1350,1560 1560,1710 1710,1800
{} and this loop is
这个循环在轮询，而不是中断，

2803
01:27:03,220 --> 01:27:06,180
0,420 420,660 660,750 750,1350
polling instead of interrupting,|
|

2804
01:27:06,240 --> 01:27:07,380
0,420 420,480 480,630 630,720 720,1140
packets are gonna be lost,
数据包会丢失，我们知道，

2805
01:27:07,380 --> 01:27:08,400
0,90 90,270 270,480 480,780 780,1020
we just know that,| because
|因为不同，

2806
01:27:08,400 --> 01:27:11,610
0,180 180,1080 1170,1500 1500,1890 2130,3210
the difference,| you know this
|这个输入率和输出率之间的差别，

2807
01:27:11,610 --> 01:27:13,500
0,510 510,1380
difference between

2808
01:27:13,590 --> 01:27:15,240
0,180 180,660 660,840 840,1260 1260,1650
the {} the input rate

2809
01:27:15,480 --> 01:27:17,310
0,180 180,270 270,690 690,990 1200,1830
and the output rate,| this
|这都是丢弃的数据包，

2810
01:27:17,340 --> 01:27:20,580
0,150 150,330 330,690 690,1440
is all dropped packets,|
|

2811
01:27:22,740 --> 01:27:25,480
0,630 1260,2130
{} adding,
增加，我不认为增加，

2812
01:27:25,510 --> 01:27:27,100
0,120 120,450 450,720 720,1140 1140,1590
I don't think adding,| because
|因为这些数据包无论如何都会被丢弃，

2813
01:27:27,100 --> 01:27:27,820
0,180 180,510 510,510 510,660 660,720
these packets are going to

2814
01:27:27,820 --> 01:27:29,950
0,60 60,390 390,1050 1410,1800 1800,2130
be dropped anyway,| adding buffering
|增加网卡缓冲区可能不会有太大帮助。

2815
01:27:29,950 --> 01:27:30,760
0,90 90,150 150,300 300,570 570,810
to the NIC doesn't probably

2816
01:27:30,760 --> 01:27:32,620
0,210 210,510 510,690 690,1290
doesn't help very much.|
|

2817
01:27:32,680 --> 01:27:33,910
0,210 210,450 450,690 720,750 780,1230
I I don't I don't
我不，我不认为网卡，

2818
01:27:34,000 --> 01:27:35,780
0,450 450,570 570,630 630,1170
think it's a NIC,|
|

2819
01:27:37,920 --> 01:27:38,760
0,180 180,330 330,510 510,600 600,840
it's not clear that NIC
目前还不清楚网卡需要更多的缓冲区。

2820
01:27:38,760 --> 01:27:40,360
0,240 240,510 510,960
needs more than

2821
01:27:40,480 --> 01:27:41,740
0,120 120,420 420,660 660,720 720,1260
{} small amount of buffering.|
|

2822
01:27:42,800 --> 01:27:44,450
0,480 480,930 930,1140 1140,1440 1470,1650
Yeah, that makes sense,| yeah,
是的，有道理，|是的，你只需要达到饱和所需的量就行了。

2823
01:27:44,450 --> 01:27:45,470
0,150 150,390 390,600 600,840 840,1020
you only need as much

2824
01:27:45,470 --> 01:27:46,340
0,120 120,210 210,330 330,630 690,870
as it would need to

2825
01:27:46,340 --> 01:27:49,500
0,300 300,600 660,1020 1020,1620
take to get saturated.|
|

2826
01:27:49,530 --> 01:27:50,130
0,120 120,180 180,270 270,480 480,600
{So,you} know I think in
所以，我想在他们的设计中，

2827
01:27:50,130 --> 01:27:51,180
0,150 150,540 540,630 630,780 780,1050
their design,| they would pull
|它们会拉出 5 个包，

2828
01:27:51,180 --> 01:27:52,650
0,300 300,660 660,780 780,930 930,1470
5 packets,| of the quota
|配额是 5 个包，

2829
01:27:52,650 --> 01:27:53,850
0,180 180,420 420,990 990,1080 1080,1200
was 5 packets| and so
|所以网卡需要 5 个数据包缓冲，

2830
01:27:53,850 --> 01:27:54,960
0,90 90,330 330,630 630,870 870,1110
the NICs centainly needs 5

2831
01:27:54,960 --> 01:27:56,940
0,300 300,360 360,930 1500,1770 1770,1980
packets of buffering,| that makes
|这是有道理的，但是可能，

2832
01:27:56,940 --> 01:27:58,440
0,300 300,510 510,960
sense, but probably,|
|

2833
01:27:58,620 --> 01:28:00,180
0,330 660,990 990,1170 1170,1470 1470,1560
anyway, it's not clear that
无论如何，还不清楚比这更多是否会更好。

2834
01:28:00,180 --> 01:28:01,020
0,180 180,330 330,540 540,690 690,840
more than that would be

2835
01:28:01,020 --> 01:28:02,420
0,210 210,780
very beneficial.|
|

2836
01:28:02,780 --> 01:28:04,460
0,420 420,540 540,960 960,1110 1110,1680
Really, the purpose of buffering
实际上，缓冲区的目的是吸收瞬时突发，

2837
01:28:05,020 --> 01:28:08,380
0,270 270,390 390,1260 1290,2340 2370,3360
is to absorb transient bursts,|
|

2838
01:28:09,150 --> 01:28:11,820
0,600 1710,2130 2130,2370 2370,2490 2490,2670
{} whole packets is long
整个数据包足够长让软件可以继续读取，

2839
01:28:11,820 --> 01:28:12,870
0,330 330,480 480,570 570,960 960,1050
enough that the software can

2840
01:28:12,870 --> 01:28:13,800
0,120 120,330 330,420 420,720 720,930
get along to reading,| but
|但在这种情况下，我们不谈论瞬变现象，

2841
01:28:13,800 --> 01:28:15,150
0,90 90,270 270,540 540,720 720,1350
we're not talking about transient

2842
01:28:15,360 --> 01:28:16,590
0,510 510,600 600,720 720,1170 1170,1230
anything in this situation,| we're
|我们谈论的是持续性超载。

2843
01:28:16,590 --> 01:28:18,840
0,240 240,480 480,1080 1080,1800
talking about persistent overload.|
|

2844
01:28:18,990 --> 01:28:20,600
0,600 660,870 870,990
So there's that,|
所以就是这样，|

2845
01:28:20,630 --> 01:28:21,530
0,180 180,330 330,480 480,660 660,900
so that means there's not
这就意味着来提供大量的缓冲没有更多功能。

2846
01:28:21,530 --> 01:28:22,790
0,240 240,480 480,990 990,1170 1170,1260
really much function for a

2847
01:28:22,790 --> 01:28:23,960
0,180 180,240 240,600
lot of buffering.|
|

2848
01:28:24,790 --> 01:28:26,600
0,240 240,630
{Yeah,make} sense.|
是的，理解了。|

2849
01:28:28,300 --> 01:28:29,560
0,480 540,690 690,870 870,990 990,1260
{} I think my question
我想我的问题与此有关，

2850
01:28:29,560 --> 01:28:31,090
0,150 150,690 690,780 780,1170 1170,1530
is related to that,| it's,
|如果这里打开中断和关闭中断之间的区别是，

2851
01:28:31,270 --> 01:28:33,310
0,420 420,810 960,1110 1110,1470 1470,2040
so if the difference between

2852
01:28:33,610 --> 01:28:35,050
0,480 480,690 690,780 780,870 870,1440
interrupts on and {interrupts -}

2853
01:28:35,080 --> 01:28:36,660
0,300 300,750 750,1140
off here is

2854
01:28:36,660 --> 01:28:37,740
0,390
that,|
|

2855
01:28:37,740 --> 01:28:38,280
0,180 180,300 300,360 360,450 450,540
it's going to be the
它会是一样的，

2856
01:28:38,280 --> 01:28:39,990
0,210 210,510 540,870 870,1260 1350,1710
same,| but like it's still
|但它仍然会把东西放在队列上，

2857
01:28:39,990 --> 01:28:41,130
0,120 120,180 180,390 390,810 810,1140
going to be putting things

2858
01:28:41,130 --> 01:28:42,180
0,120 120,210 210,510 510,690 690,1050
on the queue,| if it's
|如果它能做到的话，

2859
01:28:42,210 --> 01:28:43,840
0,360 360,630 630,960
able to,| but
|但它不会发出中断，

2860
01:28:43,840 --> 01:28:45,490
0,300 300,660 660,930 930,1260 1290,1650
it will just not issue

2861
01:28:45,490 --> 01:28:47,050
0,120 120,630 630,930 960,1200 1200,1560
an interrupt,| but if there's
|但如果队列上没有位置，

2862
01:28:47,050 --> 01:28:48,250
0,390 480,780 780,900 900,960 960,1200
no place on the queue,|
|

2863
01:28:48,250 --> 01:28:49,200
0,420
then
那么它就会丢弃。

2864
01:28:49,260 --> 01:28:51,570
0,300 300,510 510,1080 1410,1560 1560,2310
it {will,just} drop.| The interrupt,
|这个新方案中的中断例程从不查看数据包。

2865
01:28:51,660 --> 01:28:52,860
0,180 180,540 540,930 930,1050 1050,1200
the interrupt routine in this

2866
01:28:52,860 --> 01:28:54,870
0,150 150,810 990,1650 1650,1890 1890,2010
new scheme never looks at

2867
01:28:54,870 --> 01:28:56,240
0,810
packets.|
|

2868
01:28:56,270 --> 01:28:57,740
0,330 330,660 660,840 840,1050 1050,1470
Oh yes,| I mean like,
哦，是的，|我是说，你说过，

2869
01:28:57,770 --> 01:28:59,360
0,360 360,570 570,990
{} you said,|
|

2870
01:28:59,420 --> 01:29:01,010
0,240 240,510 510,780 780,900 900,1590
you turn off the interrupts
你关闭了网卡的中断，对吧。

2871
01:29:01,010 --> 01:29:03,520
0,690 810,1020 1020,1530 1560,1950
for the NIC, right.|
|

2872
01:29:03,640 --> 01:29:04,810
0,270 270,420 420,720 720,870 870,1170
Yeah, so this what happens
是的，这里中断处理程序中发生的事情是，

2873
01:29:04,810 --> 01:29:06,100
0,60 60,150 150,480 480,960 960,1290
in the interrupt handler is,|
|

2874
01:29:06,100 --> 01:29:08,080
0,180 210,1470
it disables
它禁用这个网卡上的中断，

2875
01:29:10,210 --> 01:29:12,220
0,570 600,1110 1110,1260 1260,1470 1470,2010
{} interrupts on this NIC|
|

2876
01:29:12,640 --> 01:29:14,080
0,270 270,480 480,840 840,1260 1260,1440
and then wakes up the
然后唤醒网络线程，

2877
01:29:14,080 --> 01:29:15,520
0,360 360,900
network thread,|
|

2878
01:29:16,000 --> 01:29:17,660
0,360 360,540 540,600 600,1110
that's all it does,
这就是它所做的一切，然后返回。

2879
01:29:18,460 --> 01:29:19,860
0,810
{then,returns}.|
|

2880
01:29:19,860 --> 01:29:21,060
0,450 480,570 570,780 780,870 870,1200
Right, I guess my question
好的，我想我的问题是当中断禁用时，

2881
01:29:21,060 --> 01:29:22,260
0,150 150,450 450,630 630,1050 1050,1200
is when the interrupt here

2882
01:29:22,260 --> 01:29:24,690
0,810 810,1470 1500,1980 1980,2190 2190,2430
disabled,| {can,the} NICs still put
|网卡是否仍然可以将数据包放在自己的缓冲区中？

2883
01:29:24,690 --> 01:29:27,000
0,480 480,600 600,1050 1080,1620 1620,2310
packets on its own buffer?|
|

2884
01:29:27,030 --> 01:29:28,710
0,450 450,600 600,780 780,900 900,1680
Yes, the NIC is self-contained,|
是的，网卡是独立的，|

2885
01:29:29,760 --> 01:29:31,530
0,210 210,570 570,780 780,1140 1140,1770
so it has internal buffering,|
所以它有内部缓冲，|

2886
01:29:31,800 --> 01:29:33,570
0,510 510,570 570,930 1140,1680 1680,1770
whether or not, regardless of
无论是否启用或禁用中断，

2887
01:29:33,570 --> 01:29:34,590
0,210 210,540 540,630 630,960 960,1020
whether interrupts are enabled or

2888
01:29:34,590 --> 01:29:36,540
0,660 1020,1200 1200,1560 1560,1830 1830,1950
disabled,| the only, all that
|当数据包到达时，唯一发生的事情是，

2889
01:29:36,540 --> 01:29:37,980
0,330 330,450 450,510 510,840 840,1440
happens when a packet arrives

2890
01:29:38,010 --> 01:29:40,800
0,270 270,510 510,930 1350,1920 2040,2790
is| the NIC {} adds
|网卡将数据包附加到它的数据包队列上，

2891
01:29:41,220 --> 01:29:42,450
0,420 420,510 510,930 930,1110 1110,1230
appends the packet to {}

2892
01:29:43,120 --> 01:29:44,590
0,150 150,510 510,1110 1110,1290 1290,1470
its {queue,of} packets| in its
|在它自己的内部内存中，

2893
01:29:44,590 --> 01:29:46,030
0,240 240,660 660,1140 1170,1350 1350,1440
own internal memory,| that's all
|这就是数据包到达时发生的所有事情。

2894
01:29:46,030 --> 01:29:46,900
0,120 120,300 300,690 690,810 810,870
that ever happens when a

2895
01:29:46,900 --> 01:29:48,340
0,270 270,930
packet arrives.|
|

2896
01:29:48,720 --> 01:29:50,520
0,150 150,630 630,750 750,1350 1410,1800
So whenever the NIC, in
所以当网卡，在本论文的网卡中，

2897
01:29:50,610 --> 01:29:52,770
0,330 330,780 780,1290 1290,1680 1680,2160
this paper's NIC,| different designs
|不同的设计是非常不同的，

2898
01:29:52,770 --> 01:29:54,120
0,30 30,360 360,720 720,900 1020,1350
are very different,| but for
|但对于这个论文，

2899
01:29:54,120 --> 01:29:56,310
0,180 180,600 600,870 870,1290 1380,2190
this paper,| their NIC never
|他们的网卡从未进行过 DMA ，

2900
01:29:56,340 --> 01:29:57,690
0,210 210,450 450,660 660,960 960,1350
did {DMA -},| never reached
|也从未接触过主机内存，

2901
01:29:57,690 --> 01:29:59,370
0,300 300,480 480,870 870,1170 1170,1680
out and touched host memory

2902
01:29:59,400 --> 01:30:00,280
0,390
ever,|
|

2903
01:30:01,170 --> 01:30:02,910
0,510 570,900 900,990 990,1440 1440,1740
it kept an internal queue
它在自己的内存中保留了一个内部队列，

2904
01:30:02,910 --> 01:30:03,780
0,90 90,210 210,390 390,750 750,870
in its own memory| and
|如果主机愿意，可以读出数据包。

2905
01:30:03,780 --> 01:30:04,950
0,60 60,450 450,630 630,840 840,1170
the hosts could read packets

2906
01:30:04,950 --> 01:30:05,700
0,150 150,240 240,330 330,630 630,750
out if it wanted to.|
|

2907
01:30:07,140 --> 01:30:08,550
0,540 570,690 690,1080 1170,1320 1320,1410
Okay, I see,| and if
好的，我明白了，|如果没有内存的话，那么。

2908
01:30:08,550 --> 01:30:11,310
0,270 270,630 630,1320 1350,1860 1920,2760
there's no memory, then.| Drop.|
|丢弃。|

2909
01:30:11,700 --> 01:30:13,830
0,330 330,690 840,1170 1170,1380 1380,2130
Okay.| So in this design,|
好的。|所以在这个设计中，|

2910
01:30:14,220 --> 01:30:15,810
0,150 150,570 570,720 720,1230 1230,1590
if packets are these extra
如果数据包是这些多余的数据包，

2911
01:30:15,810 --> 01:30:17,820
0,720 840,960 960,1290 1290,1440 1440,2010
packets,| the place they're dropped
|它们被丢弃的位置是在网卡内，

2912
01:30:17,820 --> 01:30:20,310
0,690 1020,1560 1590,2100 2100,2190 2190,2490
is is inside the NIC,|
|

2913
01:30:20,310 --> 01:30:21,720
0,240 240,540 540,900 930,1110 1110,1410
what'll happen is a packet
发生的是数据包或[]，

2914
01:30:21,720 --> 01:30:23,600
0,210 210,330 330,570
or {[] -},|
|

2915
01:30:23,630 --> 01:30:25,190
0,150 150,270 270,390 390,870 870,1560
if we're an overload situation,|
如果我们处于过载状态，|

2916
01:30:25,310 --> 01:30:26,240
0,180 180,270 270,540 540,780 780,930
then the NICs queue will
那么网卡队列将总是或几乎总是满的，

2917
01:30:26,240 --> 01:30:28,520
0,120 120,570 570,1440 1740,1920 1920,2280
be full always or almost

2918
01:30:28,520 --> 01:30:29,330
0,420 420,540 540,630 630,750 750,810
always,| and so when a
|所以，当数据包到达时，

2919
01:30:29,330 --> 01:30:30,470
0,300 300,660 660,720 720,930 930,1140
packet arrives,| the NICs queue
|网卡队列将是满的，

2920
01:30:30,470 --> 01:30:31,760
0,120 120,540 540,660 660,1080 1140,1290
will typically be full,| it
|它将丢弃，

2921
01:30:31,760 --> 01:30:32,870
0,120 120,480 480,600 600,990 990,1110
will drop,| the NIC will
|网卡将丢弃数据包，

2922
01:30:32,870 --> 01:30:34,820
0,270 270,360 360,720 810,1470 1470,1950
drop the packet| without wasting
|而不会浪费机器上的任何 CPU 时间。

2923
01:30:34,820 --> 01:30:36,080
0,300 300,690 690,960 960,1050 1050,1260
any CPU time on the

2924
01:30:36,080 --> 01:30:37,180
0,600
machine.|
|

2925
01:30:38,020 --> 01:30:39,970
0,270 270,1290 1290,1620 1620,1740 1740,1950
Okay, yeah.| That the fact
好的，好的。|事实上，它可以在不消耗 CPU 时间的情况下丢弃，

2926
01:30:39,970 --> 01:30:41,350
0,120 120,210 210,300 300,870 990,1380
that it can drop without

2927
01:30:41,350 --> 01:30:42,910
0,330 330,510 510,900 900,1170 1170,1560
burning up CPU time here,|
|

2928
01:30:43,120 --> 01:30:44,770
0,510 510,900 900,1050 1050,1140 1140,1650
is one way of explaining
是解释它如何避免活锁的一种方式。

2929
01:30:44,770 --> 01:30:47,260
0,180 180,360 360,1200 1380,1980 1980,2490
how they avoid live locks.|
|

2930
01:30:48,250 --> 01:30:49,810
0,450 480,780 780,1230 1260,1440 1440,1560
Right, right, okay, thank you
好的，好的，非常感谢。

2931
01:30:49,810 --> 01:30:51,040
0,120 120,660
so much.|
|

2932
01:30:55,660 --> 01:30:56,800
0,60 60,180 180,240 240,450 450,1140
I had a quick question,|
我有一个简短的问题，|

2933
01:30:56,980 --> 01:30:58,030
0,420 420,660 660,870 870,990 990,1050
will there ever be a
会不会有这样一种情况，

2934
01:30:58,030 --> 01:31:00,540
0,960 960,1080 1080,1800
scenario,| in which
|在这种情况下， CPU 会拉出几个数据包，

2935
01:31:00,730 --> 01:31:03,310
0,810 810,1800 1800,2280 2280,2370 2370,2580
{the,CPU} will pull a few

2936
01:31:03,310 --> 01:31:05,590
0,810 1020,1290 1290,1470 1470,1740 1740,2280
packets,| but the like internal
|但是内部软件队列都是满的。

2937
01:31:05,590 --> 01:31:07,120
0,480 480,870 870,1020 1020,1260 1260,1530
software queues are all like

2938
01:31:07,120 --> 01:31:08,240
0,540
full.|
|

2939
01:31:08,730 --> 01:31:10,040
0,690
{Oh,sure}.|
哦，当然。|

2940
01:31:10,620 --> 01:31:12,300
0,210 210,390 390,600 600,840 840,1680
Yeah, there's some other bottleneck,|
是的，还有其他一些瓶颈，|

2941
01:31:12,630 --> 01:31:16,770
0,570 1020,1200 1200,1770 2130,3570 3900,4140
so for example suppose these
比如，假设这些传入数据包，

2942
01:31:16,770 --> 01:31:17,940
0,330 330,750 750,960 960,1050 1050,1170
incoming packets,| some of them
|其中一些需要传送到套接字上的某个应用程序，

2943
01:31:17,940 --> 01:31:19,110
0,180 180,240 240,360 360,930 930,1170
need to be delivered to

2944
01:31:19,110 --> 01:31:20,660
0,180 180,960
some application

2945
01:31:20,660 --> 01:31:22,250
0,270 270,330 330,810 1260,1410 1410,1590
on a socket,| if that
|如果那个应用程序读取数据包速度不够快，

2946
01:31:22,250 --> 01:31:24,080
0,480 480,690 690,990 990,1470 1470,1830
application isn't reading packets fast

2947
01:31:24,080 --> 01:31:25,080
0,450
enough,|
|

2948
01:31:25,400 --> 01:31:28,760
0,600 630,1170 1230,1890 1890,2550 2550,3360
then {} the socket buffer
那么套接字缓存导致，

2949
01:31:29,300 --> 01:31:30,500
0,540 540,720 720,870 870,960 960,1200
leading to| you know that
|那个应用程序正在读取的套接字缓冲区将被填满，

2950
01:31:30,890 --> 01:31:32,630
0,300 330,1050 1050,1170 1170,1290 1290,1740
that application should be reading

2951
01:31:32,660 --> 01:31:34,190
0,210 210,420 420,900 930,1140 1140,1530
will get full| and then
|然后数据包可能在网络线程中丢弃，

2952
01:31:34,220 --> 01:31:36,290
0,510 510,630 630,750 750,1380 1860,2070
packets may be dropped in

2953
01:31:36,290 --> 01:31:39,100
0,90 90,630 630,1200 1710,2280
the networking thread {},|
|

2954
01:31:39,250 --> 01:31:41,560
0,270 270,510 510,750 870,1620 2040,2310
and that can also lead
这也可能导致活锁，

2955
01:31:41,560 --> 01:31:43,870
0,120 120,480 480,1050 1560,1980 1980,2310
to live lock,| because now
|因为现在因为我们有相同的，

2956
01:31:43,870 --> 01:31:44,800
0,210 210,300 300,450 450,510 510,930
because we have the same,|
|

2957
01:31:44,800 --> 01:31:46,120
0,450 450,720 720,960 960,1110 1110,1320
the reason live lock comes
活动锁出现的原因是，

2958
01:31:46,120 --> 01:31:47,560
0,240 240,360 360,540 630,870 870,1440
up is that| we expanded
|我们扩展了资源处理数据包，后来被丢弃，

2959
01:31:47,560 --> 01:31:49,820
0,630 630,1110 1110,1170 1170,1650
resources processing a packet

2960
01:31:49,820 --> 01:31:51,770
0,150 150,390 390,690 690,1620 1740,1950
that was later dropped,| so
|所以这是白费力气。

2961
01:31:51,770 --> 01:31:53,520
0,60 60,210 210,750 750,1170
it was wasted effort.|
|

2962
01:31:53,670 --> 01:31:54,960
0,390 450,630 630,750 750,1230 1230,1290
{} If the application is
如果应用程序没有读取它的，

2963
01:31:54,960 --> 01:31:56,740
0,210 210,510 510,870 870,1170
not reading it's,| well,
|好的，我们可以获得活锁的一种方法是，

2964
01:31:56,770 --> 01:31:57,700
0,330 330,480 480,630 630,720 720,930
one way we can get

2965
01:31:57,700 --> 01:32:00,550
0,240 240,510 510,1050 1260,1800 2430,2850
live lock is| {} as
|随着负载的增加，

2966
01:32:00,550 --> 01:32:01,600
0,120 120,360 360,600 600,780 780,1050
the load goes up,| maybe
|也许我们使用 100% 的时间在网络线程上，

2967
01:32:01,600 --> 01:32:02,290
0,120 120,240 240,330 330,630 630,690
we end up spending a

2968
01:32:02,290 --> 01:32:03,670
0,360 360,720 720,780 780,900 900,1380
{100% -} of our time

2969
01:32:03,670 --> 01:32:05,660
0,120 120,210 210,780 780,1410
in the networking thread,|
|

2970
01:32:05,960 --> 01:32:07,370
0,330 330,900 900,1260 1260,1320 1320,1410
leaving {0% -} of the
为应该读取数据包的应用程序留出 0% 的时间，

2971
01:32:07,370 --> 01:32:08,840
0,360 360,510 510,840 840,1410 1410,1470
time for whatever application is

2972
01:32:08,840 --> 01:32:09,680
0,240 240,330 330,450 450,750 750,840
supposed to be reading the

2973
01:32:09,680 --> 01:32:11,270
0,600 630,780 780,900 900,1050 1080,1590
packets| and then we'll again
|然后我们会再次得到活锁。

2974
01:32:11,270 --> 01:32:12,720
0,210 210,480 480,900
get live lock.|
|

2975
01:32:13,080 --> 01:32:14,850
0,510 1260,1440 1440,1530 1530,1650 1650,1770
{} But it won't be
但它不是中断活锁，

2976
01:32:14,850 --> 01:32:16,440
0,390 390,600 600,930 930,1050 1050,1590
interrupt live lock,| {it,will} be
|它是网络处理活锁或其他什么，

2977
01:32:16,770 --> 01:32:18,360
0,540 540,1050 1050,1320 1320,1560 1560,1590
network processing live lock or

2978
01:32:18,360 --> 01:32:20,430
0,450 540,1140 1230,1560 1560,1830 1830,2070
something,| {} the paper actually
|这个论文有关于这方面的描述，

2979
01:32:20,430 --> 01:32:22,500
0,120 120,150 150,750 750,1170 1410,2070
has a story for that,|
|

2980
01:32:24,210 --> 01:32:25,830
0,390 420,720 720,780 780,1110 1110,1620
{} somewhere in section six,|
在第六部分的某个地方，|

2981
01:32:25,980 --> 01:32:27,450
0,270 270,540 540,780 780,900 900,1470
they talk about the network,|
他们谈到了网络，|

2982
01:32:27,480 --> 01:32:29,070
0,300 300,900 900,1050 1050,1260 1260,1590
if packets are being delivered
如果数据包被递送到本地应用，

2983
01:32:29,070 --> 01:32:31,200
0,120 120,240 240,870 870,1620 1830,2130
to a local application,| the
|网络线程将查看那个应用的套接字队列，

2984
01:32:31,200 --> 01:32:32,370
0,360 360,600 600,840 840,1110 1110,1170
network thread would look at

2985
01:32:32,370 --> 01:32:33,820
0,90 90,570 570,990
the socket queue

2986
01:32:33,820 --> 01:32:35,140
0,180 180,390 390,990 990,1200 1200,1320
for that application,| and if
|如果它变长了，

2987
01:32:35,140 --> 01:32:36,820
0,120 120,270 270,570 570,1260 1440,1680
it was getting long,| it
|它会关闭中断，

2988
01:32:36,820 --> 01:32:38,620
0,300 330,960 960,1140 1140,1560 1560,1800
would turn off interrupt would

2989
01:32:38,620 --> 01:32:40,120
0,210 210,360 360,810 810,1170 1170,1500
turn off interrupts| and stop
|并停止从网络接口拉出数据包，

2990
01:32:40,120 --> 01:32:41,440
0,300 300,660 660,840 840,930 930,1320
pulling packets off the network

2991
01:32:41,440 --> 01:32:42,610
0,510 510,750 750,810 810,990 990,1170
interface| until the queue got
|直到队列变短。

2992
01:32:42,610 --> 01:32:43,520
0,450
shorter.|
|

2993
01:32:43,740 --> 01:32:46,200
0,450 900,1230 1290,1890 2040,2280 2280,2460
{} And and so that
这意味着网络线程将停止运行，

2994
01:32:46,200 --> 01:32:47,190
0,180 180,300 300,690 690,870 870,990
means that network thread would

2995
01:32:47,190 --> 01:32:48,240
0,270 300,690 690,840 840,960 960,1050
stop running| and give the
|给应用程序一个运行和处理数据包的机会，

2996
01:32:48,240 --> 01:32:49,350
0,510 510,510 510,810 810,930 930,1110
application a chance to run

2997
01:32:49,350 --> 01:32:50,880
0,240 240,600 600,660 660,1290 1350,1530
and process the packets,| so
|所以你可以在任何阶段得到活锁，

2998
01:32:50,880 --> 01:32:52,380
0,240 240,450 450,780 810,1200 1200,1500
you can get live lock

2999
01:32:52,380 --> 01:32:55,320
0,240 240,1290 1980,2160 2160,2370 2370,2940
like situations at any stage,|
|

3000
01:32:55,320 --> 01:32:56,220
0,90 90,210 210,420 420,810 810,900
if you're not careful in
如果你在多阶段处理方案中不小心的话。

3001
01:32:56,220 --> 01:32:59,420
0,300 300,1500 1620,2340 2340,2760
a multistage process scheme.|
|

3002
01:33:00,010 --> 01:33:01,180
0,330 330,420 420,600 600,780 780,1170
OK, {} that makes sense,
好的，有道理，谢谢。

3003
01:33:01,180 --> 01:33:03,380
0,270 270,600
thank you.|
|

3004
01:33:04,820 --> 01:33:07,430
0,360 360,750 900,1470 1470,1770 2220,2610
Thank you.| Thank you.| Welcome.
谢谢。|谢谢。|不客气。
