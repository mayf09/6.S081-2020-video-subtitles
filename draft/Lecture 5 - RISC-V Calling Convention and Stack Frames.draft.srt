1
00:00:00,810 --> 00:00:02,860
0,1830
Yep.|
好的。|

2
00:00:05,770 --> 00:00:07,510
0,300 300,690 1080,1410 1410,1590 1590,1740
Hey buddy, people hear what
嘿，大家能听到我说话吗？

3
00:00:07,510 --> 00:00:09,190
0,90 90,450 450,810 1080,1320 1320,1680
I'm saying.| {} You're good,
|很好，能听到。

4
00:00:09,670 --> 00:00:13,060
0,540 1350,2190 2760,3090 3090,3270 3270,3390
good.| Awesome, I just want
|好的，我想像上周一样开始，

5
00:00:13,060 --> 00:00:14,440
0,60 60,180 180,630 630,1020 1020,1380
to get started with similar

6
00:00:14,440 --> 00:00:15,340
0,90 90,480 480,630 630,780 780,900
to last week| where we
|上周，我们问了一些 util 实验的问题，

7
00:00:15,340 --> 00:00:17,710
0,270 270,390 390,1140 1410,2010 2160,2370
asked you about, {} the

8
00:00:17,710 --> 00:00:18,760
0,360 360,690 690,780 780,900 900,1050
util lab,| I just want
|我想先问一下 syscall 实验的情况，

9
00:00:18,760 --> 00:00:19,690
0,60 60,180 180,510 510,630 630,930
to get started by asking

10
00:00:19,690 --> 00:00:20,560
0,60 60,210 210,300 300,510 510,870
a little bit about syscall

11
00:00:20,560 --> 00:00:22,030
0,360 360,570 570,720 720,870 870,1470
lab,| since that was due
|因为那是周四到期的。

12
00:00:22,330 --> 00:00:24,140
0,630 660,1560
on Thursday.|
|

13
00:00:24,520 --> 00:00:26,140
0,360 360,450 450,810 810,1050 1050,1620
So if anybody just has
所以如果有人在实验中发现什么特别有趣的东西

14
00:00:26,320 --> 00:00:28,150
0,300 300,570 570,1170 1170,1710 1710,1830
like something particularly interesting, they

15
00:00:28,150 --> 00:00:29,350
0,240 240,450 450,570 570,1050 1050,1200
found about the lab| or
|或者发现一个难缠的 bug ，

16
00:00:29,350 --> 00:00:30,430
0,60 60,450 450,750 750,870 870,1080
a nasty bug that they

17
00:00:30,430 --> 00:00:32,080
0,600 600,870 1020,1320 1320,1380 1380,1650
found| or just a silly
|或者只是犯了一个愚蠢的错误，

18
00:00:32,080 --> 00:00:33,340
0,420 420,540 540,840 840,1140 1140,1260
mistake they made,| anything you
|关于 syscall 实验，任何你想分享的都可以。

19
00:00:33,340 --> 00:00:34,150
0,150 150,210 210,480 480,720 720,810
want to share about the

20
00:00:34,150 --> 00:00:35,540
0,390 390,720 720,840 840,1140
syscall lab to be，

21
00:00:35,780 --> 00:00:36,900
0,180 180,240 240,630
[that'd be great.]|
|

22
00:00:38,450 --> 00:00:40,370
0,300 300,660 660,1200 1200,1290 1290,1920
I somehow managed to delete
不知道什么原因，我删除了 fork 中需要通过 mask 复制的部分，

23
00:00:40,370 --> 00:00:42,890
0,120 120,630 630,990 990,1560 1650,2520
the part from {} where

24
00:00:42,920 --> 00:00:44,240
0,300 300,840 840,1020 1020,1140 1140,1320
from fork where you have

25
00:00:44,240 --> 00:00:45,470
0,120 120,510 510,720 720,780 780,1230
to copy over the mask,|
|

26
00:00:45,470 --> 00:00:46,460
0,120 120,210 210,360 360,540 540,990
so I had that working
我让它工作，然后我修改了其他东西，然后我测试它，

27
00:00:46,460 --> 00:00:47,360
0,150 150,270 270,360 360,630 630,900
and then I change something

28
00:00:47,360 --> 00:00:48,470
0,390 390,510 510,660 660,720 720,1110
else and then I tested

29
00:00:48,470 --> 00:00:49,860
0,600 600,1020
it for.|
|

30
00:00:50,200 --> 00:00:51,400
0,360 360,660 660,750 750,930 930,1200
Your audio is like cutting
你好像掉线了。

31
00:00:51,400 --> 00:00:53,260
0,480 480,660 660,750 750,1080 1110,1860
out.| Oh, it is sorry,
|哦，抱歉，你能听到我说话吗？

32
00:00:53,970 --> 00:00:54,880
0,180 180,300 300,690
you hear me.|
|

33
00:00:58,060 --> 00:00:59,020
0,180 180,420 420,690
I hear you.|
我听到了。|

34
00:00:59,380 --> 00:01:02,710
0,360 390,900 1440,2100 2730,3120 3120,3330
Oh, okay.| {} Yeah I
好的。|我想是的。

35
00:01:02,710 --> 00:01:03,560
0,540
guess.|
|

36
00:01:03,680 --> 00:01:06,110
0,480 480,1050 1050,1230 1230,1830 1830,2430
So basically I deleted somehow
基本上我以某种方式删除了 mask 的复制，

37
00:01:06,140 --> 00:01:07,490
0,270 270,630 630,750 750,840 840,1350
the copy of the mask|
|

38
00:01:07,490 --> 00:01:09,650
0,120 120,510 630,1200 1230,1530 1530,2160
and then my my fork
然后我的 fork 就不能用了，

39
00:01:09,680 --> 00:01:11,690
0,450 450,690 690,1230 1440,1800 1800,2010
didn't work anymore,| so then
|所以我想，之前还是好的，现在怎么不能用了，

40
00:01:11,690 --> 00:01:12,380
0,60 60,180 180,360 360,570 570,690
I was just like I

41
00:01:12,380 --> 00:01:13,400
0,270 270,540 540,720 720,900 900,1020
did that, how does it

42
00:01:13,400 --> 00:01:14,930
0,210 210,600 840,1170 1170,1470 1470,1530
not work,| so spend a
|我花了很多时间去找问题。

43
00:01:14,930 --> 00:01:16,250
0,210 210,300 300,570 570,990 990,1320
lot of time figuring out.

44
00:01:16,620 --> 00:01:18,000
0,270 270,360 360,630 630,960 990,1380
What I did wrong.| And
|我意识到我把那行删除了。

45
00:01:18,060 --> 00:01:19,470
0,180 180,720 720,780 780,1020 1020,1410
I realized I just deleted

46
00:01:19,470 --> 00:01:20,760
0,180 180,390 390,540 540,930
that line from the.|
|

47
00:01:22,820 --> 00:01:24,230
0,150 150,450 450,660 660,930 930,1410
Is anybody having trouble hearing
有没有人听不到 Luca ，还是只有我这边。

48
00:01:24,230 --> 00:01:25,250
0,390 390,480 480,660 660,780 780,1020
Luca, is that on my

49
00:01:25,250 --> 00:01:25,880
0,390
end.|
|

50
00:01:26,290 --> 00:01:27,130
0,150 150,330 330,480 480,630 630,840
I think its on your
我想只是你那边。

51
00:01:27,130 --> 00:01:27,640
0,240
end.|
|

52
00:01:28,000 --> 00:01:29,160
0,510 510,600 600,900
Yeah I'm fine.|
是的，我这边是好的。|

53
00:01:32,290 --> 00:01:33,250
0,210 210,450 450,570 570,720 720,960
This must be on my
那一定是我这边的问题。

54
00:01:33,250 --> 00:01:34,300
0,360
end.|
|

55
00:01:56,320 --> 00:01:57,520
0,300 300,510 510,780 780,960 960,1200
Sorry, maybe that'll work better
抱歉，现在应该好了。

56
00:01:57,520 --> 00:01:59,280
0,450
now.|
|

57
00:02:02,760 --> 00:02:03,630
0,150 150,240 240,390 390,480 480,870
Can you hear me now,
现在能听到我说话吗？好的。

58
00:02:04,800 --> 00:02:07,260
0,390 390,1530 1530,1560 1710,2010 2010,2460
okay great.| I was worried
|我还担心我这边。

59
00:02:07,260 --> 00:02:08,550
0,300 300,480 480,570 570,900 900,1290
that I was just talking.|
|

60
00:02:08,550 --> 00:02:10,500
0,510 510,870 1470,1770 1770,1860 1860,1950
No, no, seems to be
不，好像是我这边的问题。

61
00:02:10,500 --> 00:02:12,260
0,120 120,330 330,630 900,1500
on my end.| Alright.|
|好的。|

62
00:02:16,870 --> 00:02:19,270
0,900 1620,1770 1770,2040 2040,2280 2280,2400
Awesome, will anybody else have
好的，还有人想分享关于 syscall 的任何事情吗？

63
00:02:19,270 --> 00:02:20,110
0,240 240,390 390,540 540,630 630,840
anything they'd like to share

64
00:02:20,110 --> 00:02:21,850
0,300 300,630 660,930 930,1230 1230,1740
about you of {syscall -}.|
|

65
00:02:24,190 --> 00:02:27,010
0,390 390,1080 1080,1800 1800,2220 2640,2820
Anything particularly interesting,| or was
有什么特别有趣的，|或者实验太难了，

66
00:02:27,010 --> 00:02:28,930
0,90 90,510 540,1080 1080,1680 1680,1920
the lab absolutely horrendous| and
|你觉得我们应该把它从课程中删掉，再也不做了。

67
00:02:28,930 --> 00:02:29,560
0,90 90,240 240,330 330,480 480,630
you think we should cut

68
00:02:29,560 --> 00:02:30,700
0,90 90,240 240,300 300,390 390,1140
it out of the class,

69
00:02:31,120 --> 00:02:32,400
0,390 390,510 510,600 600,990
never do it again.|
|

70
00:02:33,430 --> 00:02:36,610
0,180 180,390 390,570 570,1110 2370,3180
{} I have something, apparently
我有一些东西，概括来说，事情的顺序很重要，

71
00:02:36,610 --> 00:02:39,100
0,630 630,990 990,1110 1110,1770 1800,2490
the order of things matters

72
00:02:39,130 --> 00:02:40,480
0,120 120,180 180,270 270,690 690,1350
which is a general statement,|
|

73
00:02:40,780 --> 00:02:43,570
0,540 540,1410 1500,1830 1830,2370 2370,2790
{} so I tried to
我试着理解 syscall 函数内的代码，

74
00:02:43,600 --> 00:02:47,080
0,960 1170,1440 1440,1830 1830,2850 2850,3480
determine the mass computation inside

75
00:02:47,080 --> 00:02:48,720
0,210 210,480 480,780 780,1380
the {syscall -} function.|
|

76
00:02:48,980 --> 00:02:51,050
0,630 630,1200 1200,1530 1530,1680 1680,2070
Before determining whether I actually
在理解之前，我需要先做 tracing 。

77
00:02:51,050 --> 00:02:52,400
0,360 360,480 480,690 690,780 780,1350
needed to do the tracing.|
|

78
00:02:53,100 --> 00:02:54,960
0,240 240,960 1020,1410 1410,1530 1530,1860
And so all the {syscall
所有系统调用都能正确跟踪，除了 trace call 。

79
00:02:54,960 --> 00:02:57,540
0,720 750,960 960,1320 1320,2010 2010,2580
-} we're getting correctly traced

80
00:02:57,570 --> 00:02:59,500
0,690 720,930 930,1200 1200,1650
except that trace call.|
|

81
00:02:59,560 --> 00:03:01,390
0,150 150,300 300,750 780,1260 1260,1830
And I was really getting
这件事让我心烦意乱，

82
00:03:01,420 --> 00:03:03,100
0,600 600,780 780,1080 1080,1410 1410,1680
disturbed by that,| until I
|直到 David 指出，

83
00:03:03,100 --> 00:03:03,940
0,180 180,240 240,420 420,720 720,840
think it was David who

84
00:03:03,940 --> 00:03:04,780
0,360 360,540 540,630 630,750 750,840
pointed out,| you know you
|你知道，应该在 trace 之后进行计算。

85
00:03:04,780 --> 00:03:06,340
0,120 120,240 240,300 300,900 900,1560
should do the computation after

86
00:03:06,860 --> 00:03:08,990
0,180 180,510 660,1200 1680,2010 2010,2130
[you should trace] just like

87
00:03:08,990 --> 00:03:10,300
0,420 630,840 840,1050
{} that's fun.|
|

88
00:03:10,790 --> 00:03:11,540
0,480
Alright.
好的，很高兴你能找到这一点。

89
00:03:13,150 --> 00:03:14,020
0,330 330,570 570,630 630,690 690,870
I'm glad you were able

90
00:03:14,020 --> 00:03:16,420
0,120 120,390 390,750 1200,2160 2160,2400
to catch that.| Yeah order
|是的，顺序确实很重要，

91
00:03:16,420 --> 00:03:18,460
0,210 210,630 660,1650 1650,1770 1770,2040
does matter,| especially for page
|特别是对页表来说，你们会发现，顺序在那里也很重要，

92
00:03:18,460 --> 00:03:19,780
0,600 600,780 780,1080 1080,1140 1140,1320
tables, you'll find I think

93
00:03:19,780 --> 00:03:21,640
0,150 150,810 1020,1530 1530,1740 1740,1860
that order matters there as

94
00:03:21,640 --> 00:03:23,080
0,480 480,660 660,1050 1050,1350 1350,1440
well| and generally throughout the
|而且贯穿整个课程，

95
00:03:23,080 --> 00:03:23,920
0,720
class,

96
00:03:24,090 --> 00:03:25,170
0,240 240,630 630,720 720,840 840,1080
paying attention to the order
注意事物的顺序很重要。

97
00:03:25,170 --> 00:03:26,220
0,90 90,360 360,450 450,540 540,1050
of things will be important.|
|

98
00:03:28,140 --> 00:03:29,370
0,150 150,390 390,480 480,780 780,1230
It's good to not overwrite
最好不要覆盖页表中的内容。

99
00:03:29,370 --> 00:03:30,640
0,270 270,360 360,570 570,990
things in page table.|
|

100
00:03:31,630 --> 00:03:33,580
0,150 150,960 1050,1380 1380,1680 1680,1950
I also had something which
我也有一些东西，事实上我现在仍然对此感到困惑。

101
00:03:33,580 --> 00:03:34,920
0,150 150,630 630,1110
I'm actually still

102
00:03:34,950 --> 00:03:38,100
0,480 480,1020 1170,1980 2010,2610 2610,3150
confused about.| {} Well I
|我在调试内核代码时用了很多 print 语句。

103
00:03:38,370 --> 00:03:39,750
0,390 390,450 450,660 660,900 900,1380
had a lot of debugging

104
00:03:39,750 --> 00:03:41,490
0,690 690,1080 1080,1170 1170,1290 1290,1740
print statements in the kernel

105
00:03:41,490 --> 00:03:44,700
0,510 1380,2040 2070,2400 2400,2910 2910,3210
code.| I then ran that
|然后我把所有的位都设置好，运行 trace ，

106
00:03:44,700 --> 00:03:46,350
0,750 750,1080 1080,1320 1320,1530 1530,1650
trace thing with all of

107
00:03:46,350 --> 00:03:48,120
0,180 180,510 510,1170 1260,1560 1560,1770
the bits set,| {} so
|基本上跟踪了所有的系统调用。

108
00:03:48,120 --> 00:03:50,310
0,390 390,1230 1530,1710 1710,1830 1830,2190
basically tracing all the system

109
00:03:50,310 --> 00:03:51,400
0,540
calls.|
|

110
00:03:51,520 --> 00:03:52,540
0,810
And,
我看到了内核中很多 print 语句的跟踪，然后。

111
00:03:52,870 --> 00:03:55,300
0,240 240,600 600,780 780,2250 2250,2430
I think I saw a

112
00:03:55,300 --> 00:03:57,550
0,270 270,900 1110,1830 1830,2130 2130,2250
lot of tracing for the

113
00:03:57,550 --> 00:03:59,200
0,270 270,960 960,1140 1140,1260 1260,1650
print statements in the kernel,

114
00:03:59,200 --> 00:04:00,240
0,180 180,660
and then.|
|

115
00:04:00,410 --> 00:04:02,390
0,570 780,990 990,1170 1170,1290 1290,1980
Because and then I assumed
然后我假设我的 print 程序读取和写入控制台，

116
00:04:02,390 --> 00:04:04,430
0,390 390,720 720,1260 1290,1650 1650,2040
that my print my print

117
00:04:04,430 --> 00:04:05,960
0,570 570,1380
apps were

118
00:04:06,260 --> 00:04:08,000
0,390 390,780 780,1020 1020,1200 1200,1740
trying to read and write

119
00:04:08,120 --> 00:04:09,980
0,150 150,270 270,990 1020,1590 1590,1860
to the console,| but that
|确实会写入控制台，

120
00:04:09,980 --> 00:04:11,030
0,150 150,360 360,450 450,570 570,1050
do write to the console,|
|

121
00:04:11,030 --> 00:04:13,160
0,210 210,750 870,1170 1170,1380 1380,2130
but then I was wondering
但我想知道是为什么。

122
00:04:13,670 --> 00:04:15,560
0,360 360,570 570,1170 1440,1710 1710,1890
why are we.| I guess,
|我想，我困惑的是，为什么可以在内核中使用 printf 。

123
00:04:15,560 --> 00:04:16,700
0,120 120,300 300,720 720,870 870,1140
I'm just confused why we're

124
00:04:16,700 --> 00:04:18,320
0,420 420,540 540,1050 1050,1410 1410,1620
able to use {printf -}

125
00:04:18,320 --> 00:04:21,280
0,90 90,210 210,870
in the kernel.|
|

126
00:04:22,670 --> 00:04:23,990
0,300 300,420 420,660 660,960 960,1320
Yeah I'm not I haven't
我最近没有看过 printf 的代码，

127
00:04:23,990 --> 00:04:25,520
0,240 240,330 330,660 690,960 960,1530
looked at the {printf -}

128
00:04:25,550 --> 00:04:27,260
0,720 720,1290 1290,1440 1440,1530 1530,1710
code recently,| but I think
|但是我想有一个 printf.c 文件，

129
00:04:27,260 --> 00:04:28,560
0,150 150,240 240,1020
there's a file

130
00:04:28,630 --> 00:04:29,860
0,210 210,570 570,720 720,930 930,1230
{} {printf.c - - -}|
|

131
00:04:29,860 --> 00:04:30,730
0,150 150,330 330,420 420,540 540,870
you might be a look
你可以自己看一下。

132
00:04:30,730 --> 00:04:31,630
0,180 180,330 330,420 420,630 630,900
at if you want to.|
|

133
00:04:32,160 --> 00:04:32,920
0,510
Um,
嗯，这里发生了什么，

134
00:04:34,430 --> 00:04:35,750
0,600 600,750 750,900 900,1140 1140,1320
here what was going on

135
00:04:35,750 --> 00:04:36,350
0,240 240,330 330,390 390,540 540,600
there,| so I think the
|我认为 printf 函数是在那里实现的。

136
00:04:36,350 --> 00:04:37,280
0,210 210,300 300,660 660,840 840,930
{printf -} function should be

137
00:04:37,280 --> 00:04:38,620
0,540 540,660 660,990
[implemented in there].|
|

138
00:04:39,530 --> 00:04:39,940
0,240

139
00:04:41,120 --> 00:04:42,110
0,240 240,450 450,630 630,900 900,990
At least our version of
至少我们的版本是这样的，

140
00:04:42,110 --> 00:04:43,430
0,210 420,750 750,870 870,1020 1020,1320
it,| I don't know perhaps
|我不知道，或许其他工作人员可能知道是怎么回事。

141
00:04:43,430 --> 00:04:44,420
0,150 150,270 270,660
one of the

142
00:04:44,650 --> 00:04:45,250
0,210 210,240 240,450 450,510 510,600
what are some of the

143
00:04:45,250 --> 00:04:46,600
0,210 210,420 420,750 750,930 930,1350
other core staff might know

144
00:04:47,370 --> 00:04:48,420
0,240 240,540 540,750
what's going on.|
|

145
00:04:49,270 --> 00:04:50,800
0,240 240,750 810,1350 1350,1470 1470,1530
And the printf in the
在跟踪的时候，内核中的 printf 不应该出现，

146
00:04:50,800 --> 00:04:52,720
0,330 330,690 690,930 930,1320 1320,1920
kernel shouldn't show up as

147
00:04:52,750 --> 00:04:54,490
0,240 240,780 780,1230 1260,1620 1620,1740
your traces,| because {printf -}
|因为内核中的 printf 不做任何系统调用。

148
00:04:54,490 --> 00:04:55,510
0,120 120,210 210,480 480,750 750,1020
in the kernel doesn't call

149
00:04:55,510 --> 00:04:56,860
0,180 180,480 480,1020
any system calls.|
|

150
00:04:58,000 --> 00:04:59,890
0,660 660,930 930,1110 1110,1350 1350,1890
Yeah that's what I thought,|
是的，我也是这么想的，|

151
00:04:59,890 --> 00:05:02,710
0,780 1080,1320 1320,1950 2190,2460 2460,2820
maybe that maybe the tracing
也许 tracing 不是从那里来的。

152
00:05:02,710 --> 00:05:04,120
0,150 150,360 360,540 540,990
was not from that.|
|

153
00:05:04,680 --> 00:05:05,580
0,390 390,480 480,630 630,780 780,900
Yeah I don't think it
是的，我不认为它来自内核中的 printf 。

154
00:05:05,580 --> 00:05:06,480
0,120 120,270 270,390 390,780 780,900
is from your printf in

155
00:05:06,480 --> 00:05:07,400
0,60 60,600
the kernel.|
|

156
00:05:08,240 --> 00:05:09,560
0,720
Okay.|
好的。|

157
00:05:12,370 --> 00:05:15,460
0,840 990,1620 2190,2490 2490,2880 2880,3090
OK, well unless anybody has
好的，除非还有人对 syscall 有别的评论，

158
00:05:15,460 --> 00:05:18,040
0,180 180,600 630,1320 1320,1890 1890,2580
any other burning comments about

159
00:05:18,040 --> 00:05:19,360
0,450 450,540 540,870 870,990 990,1320
syscall,| I think we can
|我想我们可以开始今天的讲座了。

160
00:05:19,630 --> 00:05:22,300
0,660 660,1140 1140,1590 1770,2430 2430,2670
get started with lecture for

161
00:05:22,300 --> 00:05:24,190
0,510 990,1380 1380,1470 1470,1830 1830,1890
today.| I'll be talking a
|我将谈谈 C 语言转换为汇编语言的过程和处理器，

162
00:05:24,190 --> 00:05:29,410
0,240 240,480 510,1380 2400,3300 4050,5220
little bit about the process

163
00:05:29,410 --> 00:05:31,750
0,570 570,1110 1110,1380 1380,1560 1560,2340
of converting C to assembly

164
00:05:31,750 --> 00:05:33,100
0,120 120,960 960,1050 1050,1200 1200,1350
and processors,| and this is
|今天更多是一个实用的讲座，

165
00:05:33,100 --> 00:05:35,110
0,390 420,480 480,1080 1080,1620 1620,2010
more of a practical lecture

166
00:05:35,110 --> 00:05:36,130
0,270 270,360 360,480 480,780 780,1020
today| or at least that's
|至少这是我们的目标。

167
00:05:36,130 --> 00:05:37,270
0,150 150,510 510,750 750,870 870,1140
the aim,| so the goal
|我们的目标是让你们熟悉 RISC-V ，

168
00:05:37,270 --> 00:05:39,040
0,360 360,840 1050,1410 1410,1620 1620,1770
here is to get you

169
00:05:39,040 --> 00:05:41,380
0,480 480,1560 1560,2160
all familiarized with

170
00:05:41,450 --> 00:05:44,450
0,690 900,1350 1350,2100 2100,2220 2220,3000
{} {RISC-V, -}| the processor,
|熟悉它的处理器、汇编语言和调用约定。

171
00:05:44,450 --> 00:05:46,790
0,120 120,600 600,1410 1410,1920 1920,2340
the assembly language and calling

172
00:05:46,790 --> 00:05:49,340
0,960 960,1320 1320,1590 1590,2070 2310,2550
conventions for {RISC-V. - -}|
|

173
00:05:49,340 --> 00:05:50,600
0,180 180,300 300,420 420,510 510,1260
And this will be important,|
这是非常重要的，|

174
00:05:50,600 --> 00:05:52,520
0,420 660,1050 1050,1230 1230,1530 1530,1920
in not not super important
虽然对页表来说不是特别重要，

175
00:05:52,520 --> 00:05:54,560
0,150 150,420 420,870 870,1320 1320,2040
for page table,| but certainly
|但是对于这周布置的的 traps 实验来说是这样的。

176
00:05:54,560 --> 00:05:56,030
0,420 420,510 510,930 930,1260 1260,1470
for the traps lab which

177
00:05:56,030 --> 00:05:57,620
0,480 540,780 780,900 900,1320 1320,1590
is will be assigned later

178
00:05:57,620 --> 00:05:58,610
0,210 210,480 480,630 630,780 780,990
this week,| this will be
|对于调试和实现都是必不可少的，

179
00:05:58,610 --> 00:06:01,700
0,540 540,990 1110,2130 2130,2490 2490,3090
essential for debugging and implementing

180
00:06:01,700 --> 00:06:03,080
0,270 270,480 480,600 600,720 720,1380
things,| because you'll be working
|因为你将直接使用 trap frame 和堆栈之类的东西，

181
00:06:03,140 --> 00:06:05,300
0,330 330,900 900,1350 1350,1650 1650,2160
quite intimately with trap frame

182
00:06:05,300 --> 00:06:06,740
0,210 210,690 720,990 990,1230 1230,1440
and stack and things like

183
00:06:06,740 --> 00:06:08,450
0,420 750,1020 1020,1260 1260,1500 1500,1710
that,| so that's the that's
|所以这就是今天的目标。

184
00:06:08,450 --> 00:06:09,140
0,150 150,210 210,300 300,570 570,690
kind of the goal for

185
00:06:09,140 --> 00:06:10,300
0,390 390,900
today.| And,
|我的第一个目标是，

186
00:06:10,760 --> 00:06:12,860
0,360 360,720 720,1080 1080,1530 1530,2100
my first aim was to,|
|

187
00:06:12,950 --> 00:06:13,820
0,300 300,510 510,570 570,660 660,870
this might be a little
这是对 6.004 课程的一点回顾，

188
00:06:13,820 --> 00:06:15,860
0,180 180,450 450,1050 1050,1770 1770,2040
bit of review from {6.004

189
00:06:15,860 --> 00:06:18,110
0,300 300,450 450,1170 1170,1800 1890,2250
- - -}| or any
|或者你学过的任何其他计算机体系结构课程。

190
00:06:18,110 --> 00:06:20,390
0,330 330,660 660,1230 1230,1650 1650,2280
other computer architecture theme classes

191
00:06:20,390 --> 00:06:21,200
0,150 150,270 270,390 390,510 510,810
that you may have taken

192
00:06:21,200 --> 00:06:22,580
0,90 90,210 210,750 840,1260 1260,1380
in the past,| but I
|我只想简单回顾一下，

193
00:06:22,580 --> 00:06:24,080
0,210 210,390 390,870 900,1140 1140,1500
just want to go over

194
00:06:24,080 --> 00:06:26,390
0,540 540,780 780,1110 1230,2160 2190,2310
briefly kind of see| the
|C 语言是如何转换成汇编语言的，

195
00:06:26,390 --> 00:06:28,370
0,240 240,1230 1350,1650 1650,1770 1770,1980
C language, how we get

196
00:06:28,370 --> 00:06:30,590
0,120 120,1200 1380,1740 1740,1950 1950,2220
to assembly| and I'm maybe
|还有一点处理器相关的知识。

197
00:06:30,590 --> 00:06:32,420
0,60 60,360 360,630 630,1080 1080,1830
a little bit about processor.|
|

198
00:06:32,420 --> 00:06:33,160
0,450
So,
当然，在这节课的整个过程中，

199
00:06:33,700 --> 00:06:35,260
0,660 660,750 750,1020 1050,1260 1260,1560
throughout, and then of course

200
00:06:35,260 --> 00:06:36,550
0,270 270,390 390,810 810,1050 1050,1290
throughout this lecture,| feel free
|如果你有任何问题，可以随时打断我并提问。

201
00:06:36,550 --> 00:06:38,350
0,120 120,930 1020,1380 1380,1530 1530,1800
to interrupt {} with any

202
00:06:38,350 --> 00:06:39,860
0,450 450,600 600,750 750,1260
questions that you have.|
|

203
00:06:41,050 --> 00:06:42,580
0,600 690,1200 1200,1290 1290,1410 1410,1530
So, {} you know, we
你知道，在 C 程序中，一般都有 main 函数。

204
00:06:42,580 --> 00:06:44,380
0,150 150,300 300,900 900,1200 1200,1800
have our normal main functions

205
00:06:44,380 --> 00:06:45,620
0,150 150,960
in C.|
|

206
00:06:45,700 --> 00:06:47,260
0,120 120,330 330,480 480,750 750,1560
You know they do something,
它们会做一些事情，也许是打印一些东西，然后退出。

207
00:06:47,260 --> 00:06:49,380
0,240 240,390 390,720 720,1800
maybe they print something,

208
00:06:49,800 --> 00:06:52,340
0,810 900,1140 1140,1290 1290,2130
{} then they exit.|
|

209
00:06:53,680 --> 00:06:55,240
0,210 210,360 360,600 600,1170 1200,1560
And this all looks {}
这些看起来都很好，

210
00:06:55,240 --> 00:06:56,620
0,240 240,420 420,810 810,1170 1170,1380
well and good,| but as
|但正如你们从 6.004 知道的，

211
00:06:56,620 --> 00:06:58,390
0,210 210,330 330,900 1110,1440 1440,1770
any of you are aware

212
00:06:58,390 --> 00:06:59,410
0,150 150,360 360,600 600,720 720,1020
from {6.004, - - -}|
|

213
00:06:59,410 --> 00:07:02,530
0,630 630,930 930,1470 1470,2580 2790,3120
processors don't actually understand the
处理器实际上并不理解 C 语言，

214
00:07:02,530 --> 00:07:04,690
0,210 210,750 750,1140 1140,1560 1560,2160
C language,| rather they understand
|它们理解的是我们称为汇编的东西，

215
00:07:04,690 --> 00:07:06,520
0,210 210,360 360,900 990,1260 1260,1830
what we call a assembly|
|

216
00:07:06,520 --> 00:07:08,230
0,360 360,600 600,1170 1170,1290 1290,1710
or more specifically they understand
或者更具体地说，它们理解的是汇编的二进制编码，

217
00:07:08,230 --> 00:07:09,880
0,60 60,510 510,930 930,1110 1110,1650
the binary encoding of assembly,|
|

218
00:07:10,150 --> 00:07:11,320
0,240 240,450 450,720 720,1020 1020,1170
and so this here I've
这里我在照片中圈出来的

219
00:07:11,320 --> 00:07:13,390
0,750 900,1290 1290,1830 1830,1980 1980,2070
circled a picture of| an
|是 SiFive 板上真正的 RISC-V 处理器。

220
00:07:13,390 --> 00:07:15,250
0,390 390,630 630,960 960,1650 1650,1860
actual {RISC-V -} processor from

221
00:07:15,250 --> 00:07:17,230
0,60 60,360 360,690 690,1170 1260,1980
a {SiFive -} board,| and
|而且当我们说处理器是 RISC-V 时，

222
00:07:17,860 --> 00:07:19,270
0,300 300,450 450,690 690,810 810,1410
when we say a processor

223
00:07:19,270 --> 00:07:20,650
0,120 120,420 420,870 870,1110 1110,1380
is {RISC-V, -}| that means
|意思是它可以理解 RISC-V 指令集，

224
00:07:20,650 --> 00:07:22,450
0,180 180,330 330,1170 1170,1410 1410,1800
that it understands the {RISC-V

225
00:07:22,450 --> 00:07:25,390
0,570 570,1200 1200,1530 1770,2460 2490,2940
-} instruction set,| so every
|每个处理器都有关联的 ISA 或指令。

226
00:07:25,390 --> 00:07:28,060
0,750 750,930 930,1050 1050,1830 1830,2670
processor has an associated ISA

227
00:07:28,060 --> 00:07:30,700
0,660 900,1260 1260,2400
or {} instruction.|
|

228
00:07:31,010 --> 00:07:32,150
0,180 180,420 420,660 660,750 750,1140
And that's kind of the
那就是一套指令集。

229
00:07:32,150 --> 00:07:33,980
0,300 300,390 390,1650
set of instructions,|
|

230
00:07:34,890 --> 00:07:36,240
0,480 480,780 780,1080 1080,1170 1170,1350
that makes sense to that
对处理器来说是可以理解的，

231
00:07:36,240 --> 00:07:38,550
0,630 630,1080 1140,1560 1560,2130 2130,2310
processor,| so every instruction has
|每条指令都有相关的二进制编码或操作码。

232
00:07:38,550 --> 00:07:40,800
0,120 120,780 780,1440 1440,2100 2100,2250
an associated binary encoding or

233
00:07:40,800 --> 00:07:42,080
0,60 60,270 270,780
an op code.|
|

234
00:07:42,480 --> 00:07:44,280
0,180 180,330 330,420 420,1440 1470,1800
And when a processor is
当处理器运行时，

235
00:07:44,280 --> 00:07:45,690
0,480 480,660 660,780 780,1260 1260,1410
running| and it sees a
|会看到一种特殊的编码，然后知道该怎么做。

236
00:07:45,690 --> 00:07:47,790
0,690 690,1350 1350,1530 1530,1890 1890,2100
particular encoding, it knows what

237
00:07:47,790 --> 00:07:49,600
0,60 60,450 750,1050 1050,1530
to do.| And so,
|所以，你知道这块板上的处理器理解 RISC-V 汇编，

238
00:07:50,240 --> 00:07:51,590
0,150 150,240 240,450 450,1200 1200,1350
you know this processor on

239
00:07:51,590 --> 00:07:54,230
0,240 240,600 600,1230 1230,1620 1620,2640
this board happens to understand

240
00:07:54,350 --> 00:07:56,480
0,510 510,930 930,1260 1260,1800 1800,2130
the {RISC-V -} assembly| which
|汇编从 C 代码编译而来，

241
00:07:56,480 --> 00:07:58,100
0,450 480,780 780,990 990,1440 1440,1620
is what C code is

242
00:07:58,100 --> 00:07:59,600
0,570 570,810 810,960 960,1080 1080,1500
compiled to,| so the general
|所以让 C 代码真正在处理器上运行的一般过程是，

243
00:07:59,600 --> 00:08:01,550
0,510 510,630 630,1140 1200,1620 1620,1950
process of getting C code

244
00:08:01,550 --> 00:08:02,750
0,90 90,480 480,840 840,1050 1050,1200
to actually run on your

245
00:08:02,750 --> 00:08:04,460
0,810 870,1170 1170,1290 1290,1590 1590,1710
processor is,| we start with
|编写 C 代码，然后编程成汇编语言，

246
00:08:04,460 --> 00:08:06,200
0,510 570,810 810,990 990,1590 1590,1740
C, it gets compiled to

247
00:08:06,200 --> 00:08:07,910
0,750 750,900 900,1050 1050,1230 1230,1710
assembly,| and there's some linking
|这之间还发生了一些链接之类的事情，

248
00:08:07,910 --> 00:08:09,230
0,150 150,360 360,540 540,840 840,1320
and things like that happened

249
00:08:09,230 --> 00:08:10,550
0,330 330,420 420,720 720,900 900,1320
between this step| but that's
|不过我们不是一门编译器课程，

250
00:08:10,760 --> 00:08:13,160
0,720 720,840 840,1290 1290,1890 1950,2400
{we,are,not} a compiler class,| so
|然后汇编语言会被翻译成二进制。

251
00:08:13,160 --> 00:08:14,720
0,120 120,330 330,420 420,1050 1050,1560
and then the assembly will

252
00:08:14,720 --> 00:08:16,900
0,300 300,630 630,1020 1020,1950
{} then be translated

253
00:08:16,950 --> 00:08:18,750
0,420 420,1170 1170,1350 1350,1560 1560,1800
into binary,| and so this
|这就是我们看到的 obj 或 .o 文件。

254
00:08:18,750 --> 00:08:21,400
0,330 330,930 990,2370
is the object

255
00:08:21,860 --> 00:08:25,340
0,750 780,1260 1260,1560 1560,2670
or {.o -} files

256
00:08:25,450 --> 00:08:26,620
0,210 210,360 360,660 660,990 990,1170
that you see.| so if
|如果你在运行 make qemu 之后注意过实验目录中的内容，

257
00:08:26,620 --> 00:08:28,480
0,150 150,390 390,570 570,1200 1200,1860
you've ever paid attention to

258
00:08:29,260 --> 00:08:31,180
0,420 420,1080 1080,1260 1260,1620 1620,1920
what's inside of your lab

259
00:08:31,180 --> 00:08:32,980
0,630 630,960 960,1170 1170,1440 1440,1800
directory after you run {make,qemu},|
|

260
00:08:32,980 --> 00:08:34,390
0,450 450,720 720,1020 1020,1110 1110,1410
{} you'll see a bunch
你会看到很多 .o 文件散落在各处，

261
00:08:34,390 --> 00:08:36,160
0,150 150,630 630,1050 1050,1350 1350,1770
of .o files lying around|
|

262
00:08:36,250 --> 00:08:37,150
0,210 210,420 420,450 450,540 540,900
and those are the actual
这些就是处理器能够理解的目标文件。

263
00:08:37,150 --> 00:08:39,370
0,360 360,750 750,990 990,1350 1410,2220
object files that the processor

264
00:08:39,370 --> 00:08:40,340
0,780
understands.|
|

265
00:08:41,030 --> 00:08:42,320
0,180 180,330 330,780 780,1140 1140,1290
And the asm files, you've
你们也看到了 asm 文件，

266
00:08:42,320 --> 00:08:43,760
0,330 330,750 780,1110 1110,1230 1230,1440
also seen,| {} you haven't
|你还没有写过任何汇编代码，但是如果你回想 syscall ，

267
00:08:43,760 --> 00:08:45,860
0,240 240,480 480,750 750,1260 1410,2100
really written any, but if

268
00:08:45,860 --> 00:08:47,690
0,210 210,660 660,810 810,1350 1350,1830
you recall from syscall,| {usys.pl
|usys.pl 文件被编译成 usys.S ，

269
00:08:47,690 --> 00:08:49,370
0,270 270,690 690,840 840,1560 1560,1680
- -} is compiled to

270
00:08:49,370 --> 00:08:51,500
0,120 120,570 570,1200 1230,1770 1770,2130
a file called {usys.S, -

271
00:08:51,500 --> 00:08:53,090
0,480 540,810 810,990 990,1380 1380,1590
-}| and so {.S -}
|而 .S 文件就是汇编，

272
00:08:53,090 --> 00:08:56,420
0,930 1170,2010 2220,2700 2700,3180 3180,3330
files are assembly language,| and
|所以你肯定已经到了一些 RISC-V 汇编

273
00:08:56,420 --> 00:08:58,160
0,120 120,390 390,1050 1140,1380 1380,1740
so you've seen you've certainly

274
00:08:58,160 --> 00:08:59,570
0,300 300,480 480,690 690,930 930,1410
seen some {RISC-V -} assembly|
|

275
00:08:59,570 --> 00:09:00,470
0,120 120,210 210,330 330,510 510,900
and if you took {6.004,
如果你学过 6.004 ，

276
00:09:00,470 --> 00:09:02,510
0,510 570,750 750,1110 1110,1680 1680,2040
-}| I believe you've also
|我相信你也看到过很多汇编代码。

277
00:09:02,510 --> 00:09:03,380
0,240 240,330 330,450 450,750 750,870
seen a good amount of

278
00:09:03,380 --> 00:09:04,840
0,480 510,1230
assembly language.|
|

279
00:09:05,480 --> 00:09:07,820
0,210 210,720 720,1200 1290,1620 1620,2340
An assembly looks in general
一般来说，汇编看起来比 C 语言的结构化程度要低得多，

280
00:09:07,820 --> 00:09:09,650
0,390 420,780 780,1080 1080,1650 1650,1830
{} much less structured than

281
00:09:09,650 --> 00:09:10,910
0,450 450,660 660,870 870,1050 1050,1260
C,| so you'll just see
|你会看到一行接一行的指令，

282
00:09:10,910 --> 00:09:12,770
0,450 450,720 720,1080 1080,1320 1320,1860
line after line after line

283
00:09:12,920 --> 00:09:15,290
0,600 630,1560 1560,1860 1860,1980 1980,2370
of instructions,| you'll see simple
|你会看到一些简单的东西，比如 add mult 等。

284
00:09:15,290 --> 00:09:18,230
0,270 270,510 540,1410 1650,1890 1890,2940
things like add {} mult

285
00:09:19,440 --> 00:09:21,510
0,960 960,1170 1170,1440 1440,1890 1890,2070
etc, and so on and

286
00:09:21,510 --> 00:09:22,770
0,270 270,690 690,840 840,960 960,1260
so forth,| and this doesn't
|它也没有好的控制流，没有循环语句，

287
00:09:22,770 --> 00:09:26,130
0,450 450,1050 1320,2340 2340,2850 2850,3360
have no nice control flow,

288
00:09:26,130 --> 00:09:27,990
0,180 180,360 360,1290 1320,1590 1590,1860
there's no loops,| there are
|有函数，但不是 C 语言那种函数，

289
00:09:27,990 --> 00:09:29,070
0,540 540,660 660,870 870,990 990,1080
functions but not in the

290
00:09:29,070 --> 00:09:30,540
0,300 300,420 420,570 570,810 810,1470
sense that you might remember

291
00:09:30,540 --> 00:09:32,220
0,180 180,600 600,780 780,1020 1020,1680
from C,| we see labels
|我们看到的是标签，而不是真正的函数定义。

292
00:09:32,220 --> 00:09:34,020
0,210 210,750 750,870 870,1290 1290,1800
as opposed to true function

293
00:09:34,020 --> 00:09:35,360
0,1080
definitions.|
|

294
00:09:35,440 --> 00:09:35,960
0,60

295
00:09:36,500 --> 00:09:37,970
0,180 180,240 240,750 750,930 930,1470
And the assembly, so it's
汇编语言，是一种低级语言，

296
00:09:37,970 --> 00:09:39,080
0,30 30,330 330,630 630,1020 1020,1110
a much lower language| and
|还有很多其他语言可以编译成汇编语言，

297
00:09:39,080 --> 00:09:39,860
0,90 90,210 210,450 450,510 510,780
there are plenty of other

298
00:09:39,860 --> 00:09:41,390
0,450 450,570 570,690 690,1020 1020,1530
languages that are also compiled

299
00:09:41,390 --> 00:09:43,460
0,90 90,690 690,1230 1290,1890 1920,2070
to assembly,| so, {} the
|比如，同样的过程也适用于 C++ 。

300
00:09:43,460 --> 00:09:45,470
0,360 360,780 780,1110 1110,1500 1500,2010
same process holds true for

301
00:09:45,470 --> 00:09:47,600
0,300 300,510 510,750 750,1050 1050,2130
things like {C++. - -}|
|

302
00:09:47,780 --> 00:09:49,020
0,960
Um,
嗯，你知道任何一种编译语言，

303
00:09:49,600 --> 00:09:50,920
0,120 120,390 390,660 660,900 900,1320
you know any any language

304
00:09:50,920 --> 00:09:52,810
0,240 240,990 990,1350 1350,1590 1590,1890
that's compiled| will go to
|最终生成相同的汇编语言。

305
00:09:52,810 --> 00:09:54,370
0,90 90,660 660,1110 1110,1440 1440,1560
the same assembly language at

306
00:09:54,370 --> 00:09:55,240
0,90 90,750
the base.|
|

307
00:09:56,700 --> 00:09:57,420
0,510
And,
这就是运行的基本过程，

308
00:09:58,080 --> 00:09:59,850
0,600 870,1080 1080,1500 1500,1710 1710,1770
{} so that's kind of

309
00:09:59,850 --> 00:10:01,470
0,120 120,570 570,1110 1110,1230 1230,1620
the basic process of| getting
|计算机真正理解我们编写的 C 代码，

310
00:10:01,470 --> 00:10:04,140
0,480 480,1170 1170,1320 1320,1680 1680,2670
our computer to actually understand

311
00:10:04,380 --> 00:10:05,610
0,270 270,540 540,900 900,1080 1080,1230
the C code that we're

312
00:10:05,610 --> 00:10:07,620
0,600 810,1050 1050,1230 1230,1650 1650,2010
writing,| but you'll notice that
|但要注意，我们指的是 RISC-V 汇编。

313
00:10:07,650 --> 00:10:09,690
0,360 360,540 540,690 690,1320 1320,2040
{} we've been referring to

314
00:10:10,110 --> 00:10:12,020
0,360 360,720 720,1680
{} {RISC-V -}

315
00:10:12,330 --> 00:10:14,640
0,1050 1290,1770 1770,1860 1860,2190 2190,2310
assembly.| Throughout the course and
|在整个课程中，处理器都是 RISC-V ，

316
00:10:14,640 --> 00:10:16,110
0,90 90,660 660,780 780,1050 1050,1470
the processor is {RISC-V -}|
|

317
00:10:16,110 --> 00:10:18,090
0,120 120,390 390,1110 1260,1920 1920,1980
and that's because, {} it
这很重要是因为有许多不同类型的汇编，

318
00:10:18,240 --> 00:10:19,380
0,240 240,600 600,750 750,900 900,1140
it's important because there's many

319
00:10:19,380 --> 00:10:20,940
0,330 330,570 570,660 660,1170 1170,1560
different kinds of assembly,| so
|你可能不会自己使用 RISC-V ，

320
00:10:20,940 --> 00:10:23,010
0,180 180,930 930,1230 1230,1500 1500,2070
it's unlikely that you're using

321
00:10:23,010 --> 00:10:24,340
0,330 330,1110
{RISC-V -}

322
00:10:24,550 --> 00:10:26,350
0,810 810,960 960,1290 1320,1680 1680,1800
yourself,| like you're not going
|比如你不会在上面运行 Linux ，

323
00:10:26,350 --> 00:10:27,430
0,60 60,270 270,540 540,870 870,1080
to be running Linux on

324
00:10:27,430 --> 00:10:30,070
0,240 330,930 930,1950 1950,2280 2280,2640
it,| {} instead most modern
|相反，大多数现代计算机在 x86 上运行，或者有时候看到的 x86-64 。

325
00:10:30,070 --> 00:10:32,050
0,750 750,930 930,1380 1380,1770 1770,1980
computers will run on what's

326
00:10:32,050 --> 00:10:34,570
0,270 270,1320 1350,1860 1860,2160 2160,2520
called x86 or you'll sometimes

327
00:10:34,570 --> 00:10:36,520
0,120 120,270 270,1020 1020,1380 1380,1950
see is {x86-64. - -}|
|

328
00:10:37,720 --> 00:10:39,250
0,360 360,690 690,1170 1170,1410 1410,1530
And this is this is
这是一个不同的 ISA ，不同的指令集，

329
00:10:39,250 --> 00:10:41,320
0,120 120,540 540,1410 1680,2010 2010,2070
a different ISA, this is

330
00:10:41,320 --> 00:10:42,490
0,90 90,420 420,870 870,1050 1050,1170
a different instruction set,| it
|它看起来与 RISC-V 很像，

331
00:10:42,490 --> 00:10:43,720
0,210 210,480 480,870 870,960 960,1230
looks pretty similar to {RISC-V

332
00:10:43,720 --> 00:10:45,040
0,480 510,840 840,1050 1050,1140 1140,1320
-},| but this is what
|但这是你经常在个人电脑上看到的。

333
00:10:45,040 --> 00:10:46,570
0,150 150,510 510,1200 1230,1410 1410,1530
you see in kind of

334
00:10:46,570 --> 00:10:48,600
0,240 240,630 630,1230 1230,1770
your personal computers often.|
|

335
00:10:51,760 --> 00:10:53,680
0,300 300,420 420,570 570,1500 1530,1920
So if you use {}
所以，如果你使用英特尔处理器，

336
00:10:53,680 --> 00:10:56,500
0,300 300,1140 1140,1410 1410,1860 1860,2820
an Intel| so Intel {CPU's
|英特尔 CPU 实现了 x86 ，还有 AMD 。

337
00:10:56,500 --> 00:10:58,780
0,150 150,660 660,1770 2010,2160 2160,2280
-} implement x86 and I

338
00:10:58,780 --> 00:11:00,240
0,450 450,1260
believe AMD

339
00:11:00,380 --> 00:11:04,010
0,420 420,840 1710,2430 2940,3180 3180,3630
also do.| And [this is]
|这是两者之间相对重要的区别，

340
00:11:04,130 --> 00:11:05,040
0,450

341
00:11:05,100 --> 00:11:07,590
0,630 630,1500 1500,2070 2070,2400 2400,2490
relatively important distinction between the

342
00:11:07,590 --> 00:11:08,550
0,210 210,330 330,600 600,840 840,960
two,| they're not quite as
|它们并不像看起来那么类似，

343
00:11:08,550 --> 00:11:10,050
0,420 420,570 570,690 690,930 930,1500
similar as they may look

344
00:11:10,080 --> 00:11:12,420
0,510 510,1170 1320,1800 1800,2100 2100,2340
at first| and that comes
|这归结于一个事实， RISC-V 是我们所说的 RISC ，

345
00:11:12,420 --> 00:11:13,530
0,240 240,330 330,480 480,810 810,1110
down to the fact that

346
00:11:13,530 --> 00:11:14,730
0,330 330,780 780,900 900,1080 1080,1200
{RISC-V -} is what we

347
00:11:14,730 --> 00:11:17,250
0,690 900,1380 1380,1680 1830,2400 2400,2520
call as a RISC,| the
|RISC-V 的 RISC 部分指的是精简指令集。

348
00:11:17,250 --> 00:11:18,660
0,360 360,570 570,690 690,990 990,1410
RISC part of {RISC-V -}

349
00:11:18,660 --> 00:11:21,660
0,570 570,1170 1380,1740 1740,2370 2370,3000
refers to a reduced instruction

350
00:11:21,660 --> 00:11:22,260
0,330
set.|
|

351
00:11:22,710 --> 00:11:25,440
0,630 660,1140 1170,1860 1860,2220 2220,2730
And {} {x86-64 - -}
而 x86-64 是所谓的 CISC 或复杂指令集。

352
00:11:25,440 --> 00:11:27,300
0,300 300,510 510,1050 1050,1200 1200,1860
is what's called a {CISC

353
00:11:27,300 --> 00:11:30,660
0,600 630,1530 1650,1950 1950,2640 2640,3360
-} or {} complex instructions.|
|

354
00:11:34,570 --> 00:11:37,180
0,750 900,1140 1140,1230 1230,1800 1800,2610
And there's a couple of
这里有几个关键的不同之处，

355
00:11:37,180 --> 00:11:38,860
0,210 210,780 780,1080 1080,1440 1440,1680
key differences here,| one is
|其中之一就是 x86-64 中存在的指令数量，

356
00:11:38,860 --> 00:11:40,270
0,240 240,300 300,690 690,780 780,1410
just the number of instructions

357
00:11:40,270 --> 00:11:42,070
0,150 150,270 270,780 780,1140 1140,1800
that are present in {x86-64

358
00:11:42,070 --> 00:11:43,120
0,300 300,570 570,690 690,930 930,1050
- -},| in fact one
|事实上，创建 RISC-V 的动机之一就是

359
00:11:43,120 --> 00:11:45,640
0,120 120,240 240,510 510,1620 1650,2520
of the big motivations for

360
00:11:45,640 --> 00:11:48,670
0,720 780,1470 1500,2340 2340,2610 2610,3030
writing, {} for for making

361
00:11:48,670 --> 00:11:51,880
0,240 240,780 900,1560 1560,2280 2490,3210
{RISC-V -} was| how many
|我们实际上有多少指令。

362
00:11:51,880 --> 00:11:54,220
0,180 180,870 870,1410 1410,1740 1740,2340
{} instructions we actually have.|
|

363
00:11:54,940 --> 00:11:56,290
0,180 180,390 390,570 570,840 840,1350
{} In the {} Intel
在英特尔手册里，有三本完整的书可供参考。

364
00:11:56,320 --> 00:11:58,060
0,240 240,300 300,1080 1170,1530 1530,1740
kind of handbook, so for

365
00:11:58,060 --> 00:12:00,760
0,660 660,1080 1080,1500 1500,1950 1950,2700
reference, there's three full books,|
|

366
00:12:02,150 --> 00:12:05,450
0,690 750,1710 1710,1890 1890,2670 2670,3300
that encompass the ISA and
包括 ISA 和一些统计数据，

367
00:12:05,600 --> 00:12:08,180
0,330 330,1170 1170,1350 1350,1620 1620,2580
some statistics,| I think there's
|新的指令仍然以每月三个指令的速度增加。

368
00:12:08,270 --> 00:12:10,610
0,810 810,1500 1500,1650 1650,1800 1800,2340
new instructions have been added

369
00:12:10,610 --> 00:12:14,060
0,600 810,1140 1140,1650 1680,2610 2820,3450
at a rate of three

370
00:12:14,060 --> 00:12:15,720
0,1530
instructions

371
00:12:15,940 --> 00:12:17,720
0,720 750,990 990,1620
{} per month.|
|

372
00:12:18,720 --> 00:12:20,850
0,750 780,1410 1410,1680 1680,1980 1980,2130
Since {x86-64 - -} was
自从 x86-64 发布，它最早是在七十年代发布的，

373
00:12:20,850 --> 00:12:23,220
0,570 570,660 660,1350 1410,1830 1830,2370
added, it was first published

374
00:12:23,220 --> 00:12:24,780
0,180 180,270 270,810 810,1170 1170,1560
in the seventies,| so I
|大概有 15000 多条指令在 x86-64 中。

375
00:12:24,780 --> 00:12:26,580
0,630 630,870 870,1080 1080,1440 1440,1800
believe there's like north of

376
00:12:26,880 --> 00:12:29,660
0,420 420,1470 1470,2580
{} 15,000 instructions

377
00:12:31,330 --> 00:12:33,360
0,450 450,960 960,1260 1260,1800
in {x86-64. - -}|
|

378
00:12:34,240 --> 00:12:35,500
0,450 450,690 690,1050 1050,1170 1170,1260
And {RISC-V -} on the
而 RISC-V 则相反，

379
00:12:35,500 --> 00:12:37,460
0,270 270,900 1080,1710
other hand, {}|
|

380
00:12:37,570 --> 00:12:38,860
0,180 180,630 630,750 750,990 990,1290
the assembly for {RISC-V -}
RISC-V 的程序集可以包含在两个文档中。

381
00:12:38,860 --> 00:12:40,240
0,120 120,210 210,600 600,1080 1080,1380
can be nicely contained within

382
00:12:40,240 --> 00:12:42,200
0,210 210,930 930,1080 1080,1440
two documents.| And so,
|某种程度上，

383
00:12:42,640 --> 00:12:43,750
0,270 270,480 480,540 540,870 870,1110
a kind of going off

384
00:12:43,750 --> 00:12:45,490
0,120 120,570 660,960 960,1230 1230,1740
of that,| we don't expect
|在这门课上，我们不需要你们记住 RISC-V 的每一条指令，

385
00:12:45,490 --> 00:12:47,050
0,450 450,600 600,750 750,1200 1200,1560
you in this course to

386
00:12:47,050 --> 00:12:49,390
0,900 900,1170 1170,1680 1680,1950 1950,2340
memorize every single {RISC-V -}

387
00:12:49,390 --> 00:12:51,640
0,840 900,1470 1470,1620 1620,1830 1830,2250
instruction,| but if you are
|但是如果你感兴趣，

388
00:12:51,640 --> 00:12:53,020
0,690 690,840 840,990 990,1200 1200,1380
interested| or you ever find
|或者发现哪条指令自己不清楚，

389
00:12:53,020 --> 00:12:54,190
0,360 360,810 810,900 900,1080 1080,1170
yourself confused by what a

390
00:12:54,190 --> 00:12:57,250
0,450 450,1260 1650,2130 2130,2340 2340,3060
specific instruction is or does,|
|

391
00:12:57,550 --> 00:12:58,660
0,360 360,690 690,840 840,930 930,1110
if you go to the
如果你访问课程网站，

392
00:12:58,660 --> 00:13:00,610
0,360 360,1050 1290,1620 1620,1740 1740,1950
course website| and we look
|我们可以在 references 菜单下看到，

393
00:13:00,610 --> 00:13:02,840
0,480 480,870 870,1470 1470,2100
under the references tab,|
|

394
00:13:03,460 --> 00:13:04,780
0,420 420,690 690,1050 1050,1140 1140,1320
under {RISC-V -} we give
在 RISC-V 下，我们提供了特权指令和非特权指令集的链接，

395
00:13:04,780 --> 00:13:06,040
0,150 150,270 270,660 660,930 930,1260
you the links to both

396
00:13:06,040 --> 00:13:09,550
0,270 270,1140 1230,1890 1890,2940 2940,3510
the privileged and unprivileged instruction

397
00:13:09,550 --> 00:13:11,260
0,510 750,1170 1170,1410 1410,1530 1530,1710
sets,| so this is kind
|这个文档给出了很多关于 ISA 的信息，

398
00:13:11,260 --> 00:13:12,840
0,120 120,240 240,1290
of the document

399
00:13:12,870 --> 00:13:14,850
0,630 1110,1500 1500,1620 1620,1680 1680,1980
that gives you a whole


400
00:13:14,850 --> 00:13:16,020
0,270 270,360 360,870 870,1080 1080,1170
bunch of information about the

401
00:13:16,020 --> 00:13:17,520
0,690 780,1020 1020,1170 1170,1380 1380,1500
ISA,| but you'll note that
|但是注意，这个有 240 页，这个有 135 页，

402
00:13:17,520 --> 00:13:20,340
0,240 240,420 420,690 690,1710 1710,2820
like this is 240 pages,

403
00:13:20,490 --> 00:13:22,800
0,510 510,690 690,750 840,1890 1890,2310
and this is 135 pages,|
|

404
00:13:22,800 --> 00:13:25,200
0,120 120,240 240,1080 1080,1710 1710,2400
so it's significantly significantly smaller
所以它比 x86 指令集小得多，

405
00:13:25,230 --> 00:13:28,290
0,780 810,1320 1320,1500 1500,2430 2460,3060
than {} the x86 instruction

406
00:13:28,290 --> 00:13:29,550
0,300 330,600 600,750 750,900 900,1260
set,| that's one of the
|这是 RISC-V 的优点之一，

407
00:13:29,550 --> 00:13:31,500
0,300 300,600 600,1140
nice things about,

408
00:13:31,860 --> 00:13:34,500
0,420 420,660 660,1200 1470,2220 2400,2640
about {RISC-V -},| so we
|因此，在 RISC-V 中，我们的指令更少，

409
00:13:34,500 --> 00:13:35,620
0,900
have

410
00:13:36,120 --> 00:13:37,560
0,210 210,450 450,810 810,930 930,1440
in {RISC-V -} we have

411
00:13:37,560 --> 00:13:40,350
0,660 720,1230 1230,2400 2400,2610 2610,2790
{} fewer instructions| and not
|而且指令更简单。

412
00:13:40,350 --> 00:13:41,720
0,270 270,810
only that,

413
00:13:42,050 --> 00:13:43,960
0,180 180,840 840,960 960,1680
the instructions are simpler.|
|

414
00:13:44,340 --> 00:13:45,360
0,810
So,
所以，我的意思是，

415
00:13:45,860 --> 00:13:46,940
0,270 270,330 330,570 570,720 720,1080
what I mean by that

416
00:13:46,940 --> 00:13:47,940
0,150 150,600
is that,|
|

417
00:13:48,800 --> 00:13:51,320
0,270 270,390 390,660 660,1740 2010,2520
there are many instructions in
在 x86-64 中有许多指令，

418
00:13:51,320 --> 00:13:53,000
0,630 630,930 930,1110 1110,1260 1260,1680
{x86-64 - -} by,| {for,example},
|比如，有 add mul sub 等。

419
00:13:53,000 --> 00:13:54,080
0,150 150,480 480,570 570,870 870,1080
that referring to something like

420
00:13:54,080 --> 00:13:56,450
0,270 270,360 360,840 840,1350 1470,2370
add or mul sub. {}|
|

421
00:13:57,020 --> 00:13:58,370
0,150 150,660 660,960 960,1140 1140,1350
In {x86-64 - -} there's
在 x86-64 中，有很多指令不仅做一件事，

422
00:13:58,370 --> 00:14:00,050
0,270 270,390 390,1110 1110,1350 1350,1680
plenty of instructions, that do

423
00:14:00,050 --> 00:14:01,490
0,300 300,450 450,750 750,1140 1140,1440
more than one thing,| so
|它们会执行一些复杂的操作，然后给出结果，

424
00:14:01,490 --> 00:14:04,250
0,300 300,780 780,1080 1080,2220 2280,2760
they perform some complicated {}

425
00:14:04,250 --> 00:14:05,900
0,390 390,510 510,1410 1410,1500 1500,1650
set of operations and then

426
00:14:05,900 --> 00:14:07,580
0,240 240,720 750,990 990,1530 1530,1680
gets you the result| and
|而 RISC-V 则不同，指令的范围往往较小，

427
00:14:07,580 --> 00:14:09,350
0,330 330,1290 1290,1380 1380,1620 1620,1770
that's not the case with

428
00:14:09,350 --> 00:14:11,690
0,240 240,630 810,1380 1380,1620 1620,2340
{RISC-V -} {RISC-V -} instructions

429
00:14:11,690 --> 00:14:13,040
0,270 270,390 390,750 750,1260 1260,1350
tend to be smaller in

430
00:14:13,040 --> 00:14:14,150
0,450 450,570 570,660 660,750 750,1110
scope,| and so they take
|比 x86-64 用更小的周期来运行每条指令，

431
00:14:14,240 --> 00:14:15,740
0,330 330,570 570,1020 1020,1170 1170,1500
{} less cycles to run

432
00:14:15,740 --> 00:14:17,990
0,240 240,1080 1170,1530 1530,1740 1740,2250
each instruction then maybe {x86-64

433
00:14:17,990 --> 00:14:19,340
0,270 270,540 540,870 960,1170 1170,1350
- -} is| and this
|这只是设计者选择的一种权衡。

434
00:14:19,340 --> 00:14:20,390
0,90 90,300 300,390 390,900 900,1050
is just a trade-off that

435
00:14:20,390 --> 00:14:22,220
0,90 90,720 720,1050 1050,1530 1560,1830
the designers chose to chose

436
00:14:22,220 --> 00:14:24,980
0,60 60,780 1050,1560 1590,1800 1800,2460
to undertake.| {} There's nothing
|没有什么规范的理由，

437
00:14:25,520 --> 00:14:26,840
0,210 210,360 360,480 480,690 690,1320
or you know there's no

438
00:14:28,320 --> 00:14:30,510
0,870 870,1320 1320,1620 1620,1740 1740,2190
canonical reason| why I reduced
|为什么精简指令集比复杂指令集好，

439
00:14:30,510 --> 00:14:32,820
0,600 600,1050 1050,1230 1230,1680 1680,2310
instruction set is better than

440
00:14:32,850 --> 00:14:34,980
0,150 150,630 750,930 930,1530 1530,2130
you know a complex induction

441
00:14:34,980 --> 00:14:36,750
0,810 810,1110 1110,1320 1320,1560 1560,1770
instruction set,| they each have
|它们各有其用途，

442
00:14:36,750 --> 00:14:39,390
0,210 210,600 600,1440 2280,2460 2460,2640
their own uses, and so

443
00:14:39,390 --> 00:14:40,260
0,90 90,180 180,390 390,720 720,870
on and so forth| and
|与 x86 相比， RISC-V 还有一个很酷的地方，就是它是开源的，

444
00:14:40,260 --> 00:14:41,850
0,600 600,930 930,1080 1080,1350 1350,1590
another cool thing about {RISC-V

445
00:14:41,850 --> 00:14:44,400
0,390 390,570 570,1050 1050,1440 1680,2550
-} as opposed to x86

446
00:14:44,400 --> 00:14:45,720
0,210 210,630 750,1020 1020,1170 1170,1320
is that, {} this is

447
00:14:45,720 --> 00:14:47,160
0,240 240,930
open source,|
|

448
00:14:47,740 --> 00:14:50,470
0,750 930,1140 1140,1260 1260,1800 2250,2730
so one of the only
是市面上仅有的开源指令集之一，

449
00:14:50,470 --> 00:14:53,080
0,360 360,1230 1260,1890 1890,2400 2400,2610
open source instruction sets on

450
00:14:53,080 --> 00:14:54,130
0,60 60,540 540,690 690,810 810,1050
the market,| so that means
|这意味着任何人都可以为 RISC-V 开发电路板，

451
00:14:54,130 --> 00:14:55,690
0,450 450,630 630,1050 1050,1140 1140,1560
anybody can develop a board

452
00:14:55,690 --> 00:14:57,520
0,180 180,450 450,990 1170,1680 1680,1830
for {RISC-V -}| {} and
|它来自加州大学伯克利分校的一个研究项目，

453
00:14:57,520 --> 00:14:58,570
0,540 540,780 780,870 870,960 960,1050
it came out of a

454
00:14:58,570 --> 00:15:01,570
0,450 450,1110 1110,1830 1950,2490 2490,3000
research project from UC Berkeley|
|

455
00:15:01,570 --> 00:15:02,500
0,180 180,330 330,660 660,840 840,930
and so that's kind of
这就是 RISC-V 开始的地方，

456
00:15:02,500 --> 00:15:04,270
0,300 300,480 480,780 780,1350 1440,1770
where was RISC-V started| and
|从那时起，它得到了很多公司的支持，

457
00:15:04,270 --> 00:15:05,260
0,210 210,390 390,540 540,690 690,990
since then it's been picked

458
00:15:05,260 --> 00:15:06,460
0,150 150,270 270,780 780,1080 1080,1200
up and supported by a

459
00:15:06,460 --> 00:15:08,260
0,300 300,390 390,1350 1500,1680 1680,1800
number of companies,| {} you
|你可以在网上找到这个列表，

460
00:15:08,260 --> 00:15:09,640
0,150 150,450 450,510 510,780 780,1380
can find the list online,|
|

461
00:15:09,640 --> 00:15:10,540
0,120 120,300 300,570 570,810 810,900
but yeah there's tons of
确实有很多大公司对支持开放指令集感兴趣。

462
00:15:10,540 --> 00:15:11,770
0,150 150,540 540,690 690,780 780,1230
big companies that are interested

463
00:15:11,770 --> 00:15:13,270
0,90 90,510 510,630 630,1080 1200,1500
in supporting an open {}

464
00:15:13,270 --> 00:15:14,500
0,660 660,1020
instruction set.|
|

465
00:15:14,990 --> 00:15:16,400
0,180 180,750 780,990 990,1140 1140,1410
And actually I think quite
事实上，最近 SiFive 开了一场发布会，

466
00:15:16,400 --> 00:15:17,810
0,450 450,570 570,780 780,870 870,1410
recently there was an announcement

467
00:15:17,810 --> 00:15:19,820
0,360 360,840 840,1260 1260,1650 1650,2010
made by {SiFive -}| who
|他们是 RISC-V 处理器的首屈一指的电路板制造商，

468
00:15:19,820 --> 00:15:20,820
0,660
are

469
00:15:21,150 --> 00:15:22,740
0,390 390,480 480,600 600,1290 1290,1590
sort of the premier board

470
00:15:22,740 --> 00:15:25,110
0,810 810,930 930,1170 1170,1470 1470,2370
manufacturer for {RISC-V -} processors,|
|

471
00:15:25,260 --> 00:15:27,150
0,360 360,540 540,930 930,1260 1260,1890
that they will be {}
他们将发布一款适用于个人电脑的电路板，

472
00:15:27,150 --> 00:15:30,180
0,840 840,1470 1650,2280 2280,2610 2610,3030
releasing a board for personal

473
00:15:30,180 --> 00:15:32,280
0,600 600,900 900,1140 1140,1830 1830,2100
computers| that should extensively a
|该板将采用 RISC-V 处理器，为了在个人电脑上运行 Linux ，

474
00:15:32,280 --> 00:15:34,170
0,390 390,1020 1020,1530 1530,1650 1650,1890
RISC-V processor designed to run

475
00:15:34,170 --> 00:15:36,060
0,300 300,450 450,780 780,1410 1680,1890
Linux for personal computers| and
|我记得是在过去一两周开的发布会。

476
00:15:36,060 --> 00:15:37,680
0,90 90,450 450,930 960,1230 1230,1620
I think that's been released

477
00:15:37,680 --> 00:15:38,580
0,90 90,180 180,570 570,780 780,900
in the last week or

478
00:15:38,580 --> 00:15:40,230
0,300 300,750 750,1200 1200,1470 1470,1650
two, the announcement about it.|
|

479
00:15:40,530 --> 00:15:41,670
0,360 360,630 630,780 780,1020 1020,1140
{} So if you're if
如果你很好奇，如果你发现自己，

480
00:15:41,670 --> 00:15:43,410
0,120 120,630 630,750 750,1140 1380,1740
you're curious if your find

481
00:15:43,410 --> 00:15:45,000
0,390 390,450 450,570 570,1380 1380,1590
yourself| you know absolutely I
|你知道，我在完成 6.S081 之后，很想使用 RISC-V ，

482
00:15:45,000 --> 00:15:46,080
0,210 210,270 270,510 510,750 750,1080
want to use {RISC-V -}

483
00:15:46,080 --> 00:15:47,580
0,360 360,450 450,840 840,1290 1290,1500
after I finish {6.S081 -

484
00:15:47,580 --> 00:15:49,410
0,510 540,1230 1230,1380 1380,1590 1590,1830
 -},| hopefully by that time
|希望到那时候有处理器可用，

485
00:15:49,410 --> 00:15:50,850
0,120 120,240 240,570 570,780 780,1440
there will be a processor

486
00:15:50,850 --> 00:15:51,900
0,480 480,600 600,690 690,840 840,1050
available| that you can run
|可以在自己的计算机上运行 Linux 。

487
00:15:51,900 --> 00:15:53,520
0,300 300,750 750,900 900,1050 1050,1620
Linux on your own computer.|
|

488
00:15:55,080 --> 00:15:56,340
0,330 330,630 630,720 720,840 840,1260
But even in your day-to-day
但是即使在日常生活中，

489
00:15:56,340 --> 00:15:58,440
0,480 480,600 600,900 900,1560 1590,2100
lives,| you're most likely using
|你也很可能使用了精简指令集，可能你没有意识到这一点，

490
00:15:58,440 --> 00:16:00,480
0,390 390,960 960,1350 1350,1860 1860,2040
reduced instruction set even if

491
00:16:00,480 --> 00:16:01,920
0,120 120,330 330,780 780,930 930,1440
you don't realize it,| so
|所以 ARM 指令集， A R M ，

492
00:16:01,980 --> 00:16:03,580
0,690 690,1290
the {}

493
00:16:03,740 --> 00:16:05,810
0,270 270,810 810,1230 1230,1830 1860,2070
ARM assembly, so that's A

494
00:16:05,810 --> 00:16:06,980
0,420 420,900
R M,|
|

495
00:16:07,000 --> 00:16:08,860
0,360 360,510 510,1140 1140,1440 1440,1860
this is also a reduced
也是精简指令集。

496
00:16:08,860 --> 00:16:10,100
0,510 510,990
instruction set。|
|

497
00:16:11,030 --> 00:16:14,510
0,570 570,1050 1050,1740 1740,2640 2640,3480
And ARM is implemented by
高通公司实现的 ARM 是骁龙系列处理器。


498
00:16:14,540 --> 00:16:15,800
0,1050
Qualcomm,

499
00:16:16,030 --> 00:16:17,740
0,420 420,510 510,1200 1200,1590 1590,1710
the the snapdragon series of


500
00:16:17,740 --> 00:16:19,810
0,1050 1320,1590 1590,1740 1740,1890 1890,2070
processors.| So if you have
|所以，如果你有一部安卓手机，很可能运行的是精简指令集。

501
00:16:19,810 --> 00:16:21,360
0,120 120,630 630,1320
an android phone,

502
00:16:22,740 --> 00:16:26,260
0,690 690,1620 1950,2460 2460,3300
you are most likely

503
00:16:26,790 --> 00:16:29,430
0,630 630,870 870,1440 1440,2160 2160,2640
running a reduced instruction set.|
|

504
00:16:30,200 --> 00:16:31,190
0,270 270,480 480,570 570,720 720,990
And even if you're using
即使你用的是 iOS ，我忘了叫什么，

505
00:16:31,190 --> 00:16:34,370
0,810 960,2520 2520,2610 2610,3000 3030,3180
ios, ios I think I

506
00:16:34,370 --> 00:16:35,150
0,270 270,390 390,480 480,660 660,780
forget what the name of

507
00:16:35,150 --> 00:16:36,800
0,390 390,540 540,900 900,1140 1140,1650
it,| but Apple has some
|但是苹果也有一些版本的 ARM ，

508
00:16:37,980 --> 00:16:40,320
0,270 270,540 540,1230 1230,1980 1980,2340
has some version of ARM,|
|

509
00:16:40,320 --> 00:16:41,670
0,270 270,600 600,1080 1080,1200 1200,1350
they also implement in their
他们也在自己的处理器上实现了，

510
00:16:41,670 --> 00:16:43,770
0,180 180,1110 1140,1500 1500,1740 1740,2100
own processors| that runs on
|这些处理器运行在 iPad iPhone 和多数苹果的移动设备上，

511
00:16:43,770 --> 00:16:46,890
0,840 840,1680 1680,2190 2190,2640 2730,3120
ipads iphones and most mobile

512
00:16:46,890 --> 00:16:49,290
0,210 210,840 1050,1410 1410,1980 1980,2400
Apple devices,| so reduced instruction
|所以精简指令集随处可见，

513
00:16:49,290 --> 00:16:50,430
0,270 270,450 450,780 780,960 960,1140
sets are present all over

514
00:16:50,430 --> 00:16:51,210
0,120 120,450 450,570 570,660 660,780
the place,| and if you're
|如果你在现实世界中寻找 RISC-V ，

515
00:16:51,210 --> 00:16:53,100
0,330 330,930 960,1290 1290,1560 1560,1890
looking for a {RISC-V -}

516
00:16:53,100 --> 00:16:54,440
0,90 90,180 180,450 450,1080
in the real world,|
|

517
00:16:54,870 --> 00:16:56,010
0,390 390,510 510,600 600,1020 1020,1140
{} you know outside of
你知道，在 QEMU 之外，

518
00:16:56,010 --> 00:16:57,460
0,210 210,510 510,720 720,1170
your {QEMU, - -}|
|

519
00:16:58,170 --> 00:16:59,100
0,240 240,330 330,540 540,630 630,930
you'll be able to find
你可以在集成设备中找到它。

520
00:16:59,100 --> 00:17:03,120
0,450 450,1080 1320,2370 2490,3090 3090,4020
that in like integrated devices.|
|

521
00:17:03,890 --> 00:17:05,570
0,360 360,570 570,780 780,1380 1410,1680
So it is present, it's
所以它是存在的，虽然不想 x86-64 那样广泛，

522
00:17:05,570 --> 00:17:07,130
0,270 270,660 660,1110 1110,1350 1350,1560
not as certainly not as

523
00:17:07,130 --> 00:17:09,290
0,720 720,960 960,1290 1290,1500 1500,2160
ubiquitous as something like {x86-64

524
00:17:09,290 --> 00:17:11,810
0,330 330,780 840,1230 1230,1980 1980,2520
- -}| but it's um.|
|但它是。|

525
00:17:12,540 --> 00:17:14,040
0,360 360,840 870,1230 1230,1350 1350,1500
Yes I yes I think
是的，就像 Luca 刚才说的，苹果正在将 Mac 转向 ARM 。


526
00:17:14,040 --> 00:17:15,900
0,300 300,750 780,1080 1080,1590 1590,1860
Apple is as Lucas just

527
00:17:15,900 --> 00:17:16,920
0,240 240,330 330,540 540,840 840,1020
said I think Apple is

528
00:17:16,920 --> 00:17:17,720
0,540
moving

529
00:17:17,740 --> 00:17:19,390
0,600 600,930 930,1260 1260,1350 1350,1650
Mac to ARM.| I believe
|我相信情况也是如此，

530
00:17:19,390 --> 00:17:20,950
0,210 210,450 450,570 570,1020 1170,1560
that's also the case,| there's
|去年确实有一股精简指令集的热潮。

531
00:17:20,950 --> 00:17:22,000
0,240 240,390 390,690 690,930 930,1050
been in last {year's -}

532
00:17:22,000 --> 00:17:23,290
0,300 300,390 390,480 480,810 810,1290
definitely been a push towards

533
00:17:23,290 --> 00:17:25,660
0,330 330,840 840,1350 1380,2070
reduced instruction sets {}.|
|

534
00:17:25,960 --> 00:17:27,790
0,600 630,960 960,1350 1350,1650 1650,1830
Given given how big the
英特尔指令集为什么这么大？

535
00:17:27,790 --> 00:17:29,530
0,360 360,840 840,990 990,1500 1530,1740
Intel ISA has gotten. {}|
|

536
00:17:29,530 --> 00:17:30,610
0,120 120,210 210,480 480,690 690,1080
And the reason why Intel
英特尔指令集这么大的原因是，

537
00:17:30,610 --> 00:17:31,690
0,390 390,510 510,720 720,960 960,1080
ISA is so big is

538
00:17:31,690 --> 00:17:33,910
0,240 240,660 840,1440 1470,1830 1830,2220
because| they're {} very concerned
|因为他们非常关心向后兼容性。

539
00:17:33,910 --> 00:17:35,800
0,120 120,510 510,1320 1320,1710 1710,1890
with backwards compatibility.| So if
|所以如果你写了。

540
00:17:35,800 --> 00:17:36,760
0,150 150,660
you write.|
|

541
00:17:36,870 --> 00:17:38,880
0,270 270,390 390,870 870,1350 1350,2010
{} A modern Intel processor
一个现代英特尔处理器

542
00:17:38,880 --> 00:17:41,100
0,180 180,630 630,750 750,1140 1140,2220
can run the same instructions|
|

543
00:17:41,130 --> 00:17:42,990
0,570 600,990 990,1380 1380,1770 1770,1860
that Intel code from you
也可以运行三十四年前编写的指令，

544
00:17:42,990 --> 00:17:45,270
0,210 330,1200 1200,1440 1440,1770 1770,2280
know {30,40} years ago was

545
00:17:45,300 --> 00:17:46,380
0,180 180,420 420,570 780,990 990,1080
was written,| it so they
|他们不弃用任何指令，以保证向后兼容性，

546
00:17:46,380 --> 00:17:48,300
0,300 300,510 510,1110 1110,1290 1290,1920
don't really deprecate any instructions

547
00:17:48,300 --> 00:17:49,440
0,90 90,180 180,300 300,750 750,1140
so that they maintain backwards

548
00:17:49,440 --> 00:17:51,240
0,840 960,1260 1260,1440 1440,1680 1680,1800
compatibility,| that {RISC-V -} is
|RISC-V 更现代，所以不需要考虑这个。

549
00:17:51,240 --> 00:17:52,770
0,180 180,780 1140,1290 1290,1410 1410,1530
more modern, so it's not

550
00:17:52,770 --> 00:17:53,730
0,90 90,330 330,570 570,870 870,960
a worry {RISC-V -} is.|
|

551
00:17:53,730 --> 00:17:55,740
0,450 450,600 600,1050 1110,1770 1770,2010
Also if we jump back
如果我们回到那些手册，

552
00:17:55,740 --> 00:17:58,050
0,90 90,330 330,1260 1440,2040 2040,2310
to those manuals,| {RISC-V -}
|RISC-V 的独特之处是它的指令是分开的，

553
00:17:58,050 --> 00:17:59,130
0,150 150,600 600,750 750,900 900,1080
is unique in that it's

554
00:17:59,130 --> 00:18:00,740
0,690 690,810 810,1410
divided,| we have
|所有的 RISC-V 处理器都有基本整型指令集。

555
00:18:01,010 --> 00:18:02,450
0,390 390,600 600,720 720,990 990,1440
what's called the base integer

556
00:18:02,450 --> 00:18:04,280
0,600 600,900 900,1290 1290,1590 1590,1830
instruction set which all {RISC-V

557
00:18:04,280 --> 00:18:07,080
0,300 300,1320 1800,2370
-} processors, um.|
|

558
00:18:07,340 --> 00:18:08,750
0,180 180,300 300,510 510,930 930,1410
If we have fifteen.| Gabriel
如果我们有。|Gabriel 在聊天中问道，

559
00:18:08,750 --> 00:18:09,530
0,330 330,420 420,510 510,690 690,780
asks in the chat,| if
|如果有 15000 条指令，几乎不可能有效地使用它们，

560
00:18:09,530 --> 00:18:11,210
0,90 90,180 180,840 840,1440 1440,1680
we have 15,000 instructions, it

561
00:18:11,210 --> 00:18:13,100
0,360 360,900 900,960 960,1380 1380,1890
nearly impossible to efficiently pipeline

562
00:18:13,100 --> 00:18:14,270
0,300 480,840 840,900 900,1020 1020,1170
them,| why do we need
|那么为什么需要这么多。

563
00:18:14,270 --> 00:18:15,710
0,120 120,390 840,1170 1170,1260 1260,1440
so many.| Like I was
|就像我说的，需要这么多指令，是出于向后兼容的原因，

564
00:18:15,710 --> 00:18:16,670
0,270 270,360 360,600 600,720 720,960
saying we need so many

565
00:18:16,670 --> 00:18:18,530
0,120 120,510 510,1170 1170,1680 1680,1860
for backwards compatibility reasons,| it's
|这是由你自己决定的，你是否认为这是非常重要的。

566
00:18:18,530 --> 00:18:19,550
0,150 150,270 270,420 420,510 510,1020
up to you to decide

567
00:18:19,550 --> 00:18:20,700
0,60 60,210 210,540 540,900
you know whether you

568
00:18:20,660 --> 00:18:22,340
0,30 60,600 600,870 870,1290 1290,1680
{} think that's super important.|
|

569
00:18:22,340 --> 00:18:23,870
0,120 120,420 420,480 480,720 720,1530
But many of those instructions
但是我想很多指令被简单的指令所[]，

570
00:18:23,900 --> 00:18:24,560
0,180 180,300 300,360 360,570 570,660
I think a ton of

571
00:18:24,560 --> 00:18:25,760
0,120 120,240 240,510 510,990
them are also {[]

572
00:18:25,860 --> 00:18:27,750
0,330 330,510 510,750 750,1290 1290,1890
- -} by simply instructions|
|

573
00:18:27,750 --> 00:18:29,220
0,240 240,300 300,480 480,930 1080,1470
which are their own kind
这是它们特有的东西。

574
00:18:29,220 --> 00:18:30,870
0,60 60,480 480,870 870,990 990,1650
of special class of things.|
|

575
00:18:31,850 --> 00:18:33,710
0,480 510,690 690,1110 1200,1500 1500,1860
{} You won't I I
我从没见过

576
00:18:33,710 --> 00:18:35,330
0,420 420,690 690,900 900,1230 1230,1620
I've never seen| Intel assembly
|英特尔汇编代码能充分利用这 15000 条指令，

577
00:18:35,330 --> 00:18:36,770
0,240 240,330 330,540 540,840 840,1440
code that makes full uses

578
00:18:36,800 --> 00:18:37,880
0,300 300,690 690,870 870,990 990,1080
full usage out of the

579
00:18:37,880 --> 00:18:39,680
0,630 630,1200 1200,1320 1320,1650 1650,1800
15,000 instructions,| but mostly this
|这主要是出于向后兼容的需要，并且保持简单。

580
00:18:39,680 --> 00:18:41,000
0,270 270,480 480,780 960,1290 1290,1320
comes from a from a

581
00:18:41,000 --> 00:18:42,500
0,240 240,330 330,690 690,1350 1350,1500
need for backwards compatibility and

582
00:18:42,500 --> 00:18:43,200
0,450
simply.|
|

583
00:18:43,520 --> 00:18:44,660
0,330 570,840 840,870 870,990 990,1140
But like I was saying
就像我说的， RISC-V 有一个基本整型指令集，

584
00:18:44,660 --> 00:18:46,160
0,150 150,390 390,690 690,1260 1290,1500
the {RISC-V -} has a

585
00:18:46,160 --> 00:18:47,510
0,240 240,420 420,540 540,900 900,1350
what's called the base integer

586
00:18:47,510 --> 00:18:48,740
0,570 570,1020
instruction set,|
|

587
00:18:49,030 --> 00:18:51,160
0,810 840,1140 1140,1740 1740,1980 1980,2130
which {} contains all of
它包含所有正常的加法、乘法运算，

588
00:18:51,160 --> 00:18:54,340
0,420 450,1260 1260,1530 1530,2340 2370,3180
the normal add multiply things,|
|

589
00:18:54,400 --> 00:18:56,230
0,480 480,630 630,930 930,1590 1590,1830
{} and then processors can
然后处理器可以选择实现其他模块，

590
00:18:56,230 --> 00:18:57,640
0,390 390,480 480,960 960,1050 1050,1410
choose to implement a number

591
00:18:57,640 --> 00:18:58,990
0,90 90,360 360,990 990,1200 1200,1350
of other modules,| which you
|你可以在这边看到，

592
00:18:58,990 --> 00:19:00,130
0,150 150,390 390,750 750,810 810,1140
can see along the side

593
00:19:00,130 --> 00:19:01,330
0,270 270,420 420,660 660,1140 1140,1200
here,| it's probably impossible to
|可能你在屏幕上看不清楚，

594
00:19:01,330 --> 00:19:03,220
0,360 870,1080 1080,1230 1230,1650 1650,1890
read on your screen,| but
|举个例子，如果你希望处理器

595
00:19:03,220 --> 00:19:04,420
0,120 120,750 750,900 900,1020 1020,1200
for example if you want

596
00:19:04,420 --> 00:19:06,700
0,90 90,990 1050,1500 1500,1740 1770,2280
a processor,| {you,know} that supports
|支持单精度浮点型标准扩展，

597
00:19:06,700 --> 00:19:08,320
0,300 300,750 750,900 900,1170 1170,1620
standard extension for single precision

598
00:19:08,320 --> 00:19:10,000
0,360 360,960 1080,1410 1410,1530 1530,1680
floating point,| then you can
|你就可以包含 F 模块。

599
00:19:10,000 --> 00:19:11,500
0,330 330,420 420,660 660,1260
include the F module.|
|

600
00:19:11,960 --> 00:19:13,220
0,300 300,450 450,690 690,840 840,1260
And this makes it easier
这使得 RISC-V 更容易支持向后兼容，

601
00:19:13,220 --> 00:19:14,480
0,120 120,330 330,570 570,690 690,1260
for {RISC-V -} to support

602
00:19:14,660 --> 00:19:18,140
0,1020 1020,1770 1770,2550 2610,3030 3030,3480
backwards compatibility,| because if, {}
|因为你可以指出包含和支持哪些模块，

603
00:19:18,170 --> 00:19:19,490
0,180 180,300 300,540 540,960 960,1320
you can just say what

604
00:19:19,490 --> 00:19:20,690
0,210 210,360 360,930 930,1080 1080,1200
set of modules do I

605
00:19:20,690 --> 00:19:23,060
0,570 570,720 720,1320 1470,2160 2190,2370
include and support| and the
|而编译器可以选择。

606
00:19:23,060 --> 00:19:25,000
0,570 570,750 750,1230 1230,1650
compiler can choose.| Then,
|然后，编译器告诉我它支持这些模块，

607
00:19:25,060 --> 00:19:26,680
0,420 420,840 840,960 960,1200 1200,1620
{} compiler can say okay,

608
00:19:26,680 --> 00:19:28,240
0,60 60,360 510,960 960,1470 1470,1560
you know this processor is

609
00:19:28,240 --> 00:19:29,260
0,270 270,390 390,480 480,810 810,1020
telling me it supports these

610
00:19:29,260 --> 00:19:30,310
0,510 510,600 600,660 660,780 780,1050
modules,| so I can only
|所以我可以用这些模块编译这段代码。

611
00:19:30,310 --> 00:19:31,480
0,450 450,570 570,870 870,990 990,1170
compile this code with these

612
00:19:31,480 --> 00:19:32,300
0,630
modules.|
|

613
00:19:33,760 --> 00:19:35,800
0,390 390,570 570,990 990,1800 1830,2040
Okay, {Bibik -} says| it
好的， Bibik 说，|似乎使用 x86 而不是 RISC-V 处理器的唯一优势是

614
00:19:35,800 --> 00:19:36,850
0,270 270,390 390,480 480,690 690,1050
seems that the only advantage

615
00:19:36,850 --> 00:19:38,230
0,90 90,360 360,1080 1080,1290 1290,1380
of using x86 instead of

616
00:19:38,230 --> 00:19:39,310
0,210 210,450 450,930 930,990 990,1080
{RISC-V -} processor| is the
|可以获得更好的性能，

617
00:19:39,310 --> 00:19:40,180
0,180 180,240 240,660 660,780 780,870
kind of performance you can

618
00:19:40,180 --> 00:19:42,220
0,300 450,990 990,1110 1110,1530 1740,2040
get,| however, that performance comes
|然而，这种性能是以巨大的成本、复杂度和潜在的安全性为代价的，

619
00:19:42,220 --> 00:19:43,390
0,90 90,330 330,750 750,1080 1080,1170
as a massive cost and

620
00:19:43,390 --> 00:19:45,550
0,540 540,690 690,1020 1020,1740 1800,2160
complexity and potential security,| my
|我的问题是为什么我们还在使用 x86 ，

621
00:19:45,550 --> 00:19:46,450
0,390 390,540 540,720 720,810 810,900
question is why are we

622
00:19:46,450 --> 00:19:48,100
0,210 210,510 510,1260 1260,1560 1560,1650
still using x86,| instead of
|而不是转向 RISC-V 。

623
00:19:48,100 --> 00:19:49,120
0,270 270,330 330,600 600,810 810,1020
moving to something like {RISC-V

624
00:19:49,120 --> 00:19:49,820
0,360
 -}.|
 |

625
00:19:49,970 --> 00:19:52,130
0,570 840,1290 1290,1380 1380,1530 1530,2160
{} Well, {} a big
好的，一个宽泛的答案是，世界运行在 x86 之上，

626
00:19:52,160 --> 00:19:53,210
0,330 330,570 570,690 690,960 960,1050
answer that the world is

627
00:19:53,210 --> 00:19:55,970
0,300 300,480 480,1350 1380,2310 2490,2760
run on x86,| for I
|我也没有一个更好的答案。

628
00:19:55,970 --> 00:19:57,170
0,210 210,510 510,750 750,900 900,1200
I don't have a great

629
00:19:57,170 --> 00:19:58,910
0,330 330,540 540,990 1200,1530 1530,1740
answer for why.| {RISC-V -}
|RISC-V 是相当现代的，

630
00:19:58,910 --> 00:20:00,540
0,120 120,330 330,750 750,1170
is pretty modern too.|
|

631
00:20:00,740 --> 00:20:02,750
0,570 720,1470 1470,1830 1830,1950 1950,2010
So the world as a
世界几乎都运行在 x86 上，

632
00:20:02,750 --> 00:20:04,460
0,330 330,570 570,870 870,1320 1320,1710
whole pretty much runs on

633
00:20:04,460 --> 00:20:06,170
0,750 750,930 930,1080 1080,1260 1260,1710
x86,| so if you suddenly
|如果突然把处理器转换为 RISC-V ，

634
00:20:06,170 --> 00:20:10,340
0,540 960,1710 1710,2280 2640,3780 3780,4170
start converting your processors to

635
00:20:10,340 --> 00:20:12,110
0,330 330,840 840,1350 1350,1650 1650,1770
{RISC-V -},| you run the
|你会冒着失去对一些重要事情支持的风险。

636
00:20:12,110 --> 00:20:13,540
0,390 390,570 570,1170
risk of, {}

637
00:20:14,080 --> 00:20:15,730
0,120 120,450 480,990 990,1500 1500,1650
you know losing support for

638
00:20:15,730 --> 00:20:17,320
0,90 90,330 330,450 450,1020 1020,1590
a bunch of important things,|
|

639
00:20:17,380 --> 00:20:19,060
0,480 480,690 690,960 960,1200 1200,1680
also there are like Intel
另外，英特尔在他们的处理器中也做了一些有趣的事情，

640
00:20:19,060 --> 00:20:21,310
0,330 330,630 630,1260 1260,1770 1770,2250
does do interesting things within

641
00:20:21,310 --> 00:20:24,580
0,210 210,1110 1200,1830 1830,2370 2370,3270
their processors,| like security wise,
|比如在安全方面，有 enclave ，

642
00:20:24,610 --> 00:20:26,470
0,330 330,630 630,1350 1350,1470 1470,1860
there are enclaves on Intel

643
00:20:26,470 --> 00:20:28,540
0,840 840,960 960,1170 1170,1410 1410,2070
processors| and there's things that
|而且近年来他们一直在做一些事情，

644
00:20:28,780 --> 00:20:30,070
0,330 330,420 420,780 780,930 930,1290
they've been doing in recent

645
00:20:30,070 --> 00:20:31,510
0,360 360,480 480,900 930,1080 1080,1440
years| to try to try
|试图提供额外的安全性，

646
00:20:31,510 --> 00:20:33,130
0,270 270,510 510,690 690,1260 1290,1620
and give you extra added

647
00:20:33,130 --> 00:20:35,500
0,810 1020,1710 1740,2010 2010,2130 2130,2370
security| and some of those
|英特尔确实实现了一些指令，

648
00:20:35,500 --> 00:20:37,240
0,570 570,720 720,1050 1050,1260 1260,1740
instructions that Intel does implement|
|

649
00:20:37,240 --> 00:20:39,100
0,240 240,420 420,750 750,1440 1560,1860
which are hyper specific can
这些指令对某些特定的计算是非常有效的。

650
00:20:39,100 --> 00:20:41,260
0,210 210,510 510,1080 1080,1500 1500,2160
be really efficient for certain,

651
00:20:41,530 --> 00:20:43,080
0,330 330,1410
{} computations.|
|

652
00:20:43,250 --> 00:20:44,150
0,360 360,510 510,630 630,750 750,900
{} And so they have
所以他们有这么多指令，

653
00:20:44,150 --> 00:20:45,860
0,180 180,360 360,990 990,1260 1260,1710
so many instructions,| there's often
|你知道，多数情况下，一种情况对应一条指令，

654
00:20:45,860 --> 00:20:46,620
0,90 90,510
you know,

655
00:20:46,740 --> 00:20:48,180
0,210 210,630 630,1200 1200,1380 1380,1440
a perfect instruction for a

656
00:20:48,180 --> 00:20:49,530
0,690 690,840 840,990 990,1140 1140,1350
situation| that may be more
|这可能比 RISC-V 更有效。

657
00:20:49,530 --> 00:20:50,680
0,540 540,900
efficient than

658
00:20:50,870 --> 00:20:52,670
0,450 450,870 870,1290 1290,1590 1590,1800
then what exists within {RISC-V

659
00:20:52,670 --> 00:20:54,830
0,450 540,1140 1140,1440 1440,1770 1770,2160
-},| but a more practical
|但一个更实际的答案是，

660
00:20:54,830 --> 00:20:55,730
0,300 300,390 390,510 510,660 660,900
answer is| at {RISC-V -}
|RISC-V 相对较新，

661
00:20:55,730 --> 00:20:56,840
0,90 90,600 600,900 900,1020 1020,1110
is relatively new| and we
|还没有真正为个人电脑制造的处理器，

662
00:20:56,840 --> 00:20:58,340
0,150 150,480 600,780 780,1230 1230,1500
just don't know, nobody's really

663
00:20:58,340 --> 00:21:00,350
0,360 360,990 990,1140 1140,1470 1470,2010
making processors for personal computers,|
|

664
00:21:00,350 --> 00:21:02,150
0,90 90,270 270,510 690,1350 1350,1800
I think the SiFive announcement
SiFive 的发布会是最近举办的，

665
00:21:02,150 --> 00:21:04,490
0,330 330,690 690,1110 1290,1920 1950,2340
is super recent,| {} and
|他们可以说是第一批这样做的人。

666
00:21:04,520 --> 00:21:05,660
0,420 420,600 600,690 690,810 810,1140
they're kind of the first

667
00:21:05,660 --> 00:21:06,650
0,270 270,360 360,480 480,750 750,990
people to be doing that.|
|

668
00:21:06,650 --> 00:21:08,150
0,300 330,480 480,570 570,990 990,1500
so on a practical level,
所以在实践上，不能运行所有为英特尔设计的软件，

669
00:21:08,820 --> 00:21:10,560
0,540 540,780 780,1020 1020,1620 1620,1740
that and the inability to

670
00:21:10,560 --> 00:21:11,730
0,180 180,300 300,390 390,840 840,1170
run all the software design

671
00:21:11,730 --> 00:21:14,070
0,180 180,690 1200,1800 1860,2070 2070,2340
for Intel| is is my
|这是我最好的答案。

672
00:21:14,070 --> 00:21:15,340
0,330 330,900
best answer.|
|

673
00:21:16,210 --> 00:21:19,210
0,690 1170,1470 1470,1860 2310,2640 2640,3000
So we've been now chatting
我们现在讲一下汇编，

674
00:21:19,210 --> 00:21:20,710
0,60 60,270 270,570 570,960 960,1500
a little bit about assembly,|
|

675
00:21:20,710 --> 00:21:21,970
0,120 120,180 180,390 390,690 690,1260
so I just wanted to
我想先看一些实际的汇编代码。

676
00:21:22,090 --> 00:21:23,800
0,690 720,1050 1050,1110 1110,1470 1470,1710
{} take a look at

677
00:21:23,800 --> 00:21:26,420
0,360 360,840 840,1290 1290,1890
some actual assembly code.|
|

678
00:21:26,600 --> 00:21:30,320
0,330 330,900 900,1530 1530,2250 3300,3720
So here is the C
这是一段 C 代码，

679
00:21:30,320 --> 00:21:31,730
0,360 360,510 510,810 810,1260 1260,1410
code for what's below,| so
|有一个简单的函数，一个累加器，

680
00:21:31,730 --> 00:21:32,930
0,150 150,270 270,330 330,690 690,1200
this is a simple function

681
00:21:32,930 --> 00:21:34,610
0,90 90,270 270,360 360,1170 1260,1680
that has an accumulator,| we
|我们从 0 循环到 n ，

682
00:21:34,610 --> 00:21:36,440
0,420 420,900 900,1230 1230,1350 1350,1830
loop from zero to n|
|

683
00:21:36,440 --> 00:21:38,390
0,660 750,1260 1260,1560 1560,1770 1770,1950
and we sum up all
然后将 0 到 n 的所有数字加起来，

684
00:21:38,390 --> 00:21:40,400
0,150 150,870 870,1470 1500,1830 1830,2010
the numbers from {} from

685
00:21:40,400 --> 00:21:41,300
0,300 300,390 390,660
zero to n,|
|

686
00:21:41,960 --> 00:21:43,550
0,240 240,390 390,720 720,900 900,1590
and then return that value.|
然后返回这个值。|

687
00:21:43,760 --> 00:21:46,280
0,690 690,1440 1440,1590 1590,2040 2040,2520
And at its simplest level,
这是最简单的级别，最简单的汇编代码，

688
00:21:46,280 --> 00:21:47,450
0,180 180,300 300,450 450,930 930,1170
this is the easiest kind

689
00:21:47,450 --> 00:21:48,980
0,90 90,690 690,960 960,1170 1170,1530
of assembly,| you can get
|你可以编译这段程序，

690
00:21:48,980 --> 00:21:50,510
0,150 150,270 270,780 780,990 990,1530
out of compiling that program,|
|

691
00:21:50,720 --> 00:21:53,390
0,360 360,660 660,1230 1230,1680 1710,2670
if you actually go into
如果你真的编写了 C 代码，并编译它，

692
00:21:53,390 --> 00:21:54,770
0,390 390,570 570,1110 1110,1260 1260,1380
your own computer and you

693
00:21:54,770 --> 00:21:55,850
0,240 240,330 330,600 600,960 960,1080
write the C code and

694
00:21:55,850 --> 00:21:56,930
0,90 90,270 270,390 390,840 840,1080
you try to compile it,|
|

695
00:21:56,930 --> 00:21:57,710
0,120 120,270 270,480 480,660 660,780
you will end up with
你可能会得到一些看起来完全不同的东西。

696
00:21:57,710 --> 00:22:00,020
0,540 720,1050 1050,1380 1380,1830 1860,2310
something that likely looks quite

697
00:22:00,020 --> 00:22:01,160
0,450
different.|
|

698
00:22:01,420 --> 00:22:02,260
0,150 150,390 390,600 600,750 750,840
And that's true for a
这是正确的，有不同的原因，

699
00:22:02,260 --> 00:22:03,580
0,420 420,540 540,1020 1020,1140 1140,1320
variety of reasons,| we have
|我们会看到其中一些原因，还有一些是特定编译器的，

700
00:22:03,580 --> 00:22:04,630
0,450 450,600 600,690 690,840 840,1050
a some of which we'll

701
00:22:04,630 --> 00:22:05,350
0,210 210,360 360,480 480,630 630,720
get to and some of

702
00:22:05,350 --> 00:22:07,570
0,240 240,330 330,750 750,1410 1740,2220
which are compiler specific,| so
|现代编译器进行了大量的优化，

703
00:22:07,570 --> 00:22:10,300
0,420 420,1080 1080,1470 1470,2190 2280,2730
modern compilers make a large

704
00:22:10,300 --> 00:22:12,080
0,270 270,360 360,1290 1290,1680
number of optimization {},|
|

705
00:22:13,510 --> 00:22:14,860
0,300 300,480 480,690 690,840 840,1350
With it when they compile
当使用编译器将 C 编译成汇编时，

706
00:22:14,860 --> 00:22:16,150
0,180 180,420 420,570 570,1140 1140,1290
your C to assembly,| and
|所以你的汇编指令看起来可能会不同，

707
00:22:16,150 --> 00:22:17,500
0,150 150,330 330,690 690,1230 1230,1350
so your assembly instructions may

708
00:22:17,500 --> 00:22:19,870
0,210 210,660 780,1140 1140,1920 1980,2370
look different,| for instance while
|例如，当你在 gdb 中调试时，

709
00:22:19,870 --> 00:22:21,280
0,180 180,750 750,900 900,1050 1050,1410
you're debugging in {gdb, -}|
|

710
00:22:21,280 --> 00:22:22,360
0,120 120,270 270,480 480,810 810,1080
you may come across something
可能会遇到一些东西告诉你某个变量已经被优化，

711
00:22:22,360 --> 00:22:23,230
0,120 120,390 390,540 540,690 690,870
that tells you that it's

712
00:22:23,230 --> 00:22:25,300
0,420 420,930 930,1110 1110,1350 1350,2070
some variable has been optimized

713
00:22:25,300 --> 00:22:26,770
0,450 750,990 990,1140 1140,1350 1350,1470
out,| and that means that
|意思是编译器决定不需要该变量，

714
00:22:26,770 --> 00:22:28,150
0,90 90,600 600,1080 1080,1200 1200,1380
the compiler decided it didn't

715
00:22:28,150 --> 00:22:30,250
0,210 210,390 390,1110 1260,1860 1860,2100
need that variable {}| and
|因此，这个变量会从程序中消失。

716
00:22:30,250 --> 00:22:32,440
0,270 270,660 660,990 1020,1620 1620,2190
so that'll be gone effectively

717
00:22:32,440 --> 00:22:34,270
0,180 180,270 270,930 1170,1470 1470,1830
from the program,| but yeah
|这是很直接的，我们把 a0 中的值移动到 t0 ，

718
00:22:34,270 --> 00:22:35,290
0,150 150,480 510,690 690,810 810,1020
and it's at its most

719
00:22:35,290 --> 00:22:36,380
0,870
straightforward,

720
00:22:36,970 --> 00:22:39,520
0,240 240,960 1080,1740 1770,2280 2280,2550
we're moving {} value that's

721
00:22:39,520 --> 00:22:40,510
0,150 150,300 300,660 660,750 750,990
in {a0 -} the {t0

722
00:22:40,510 --> 00:22:42,280
0,720 750,1050 1050,1380 1380,1470 1470,1770
-},| we're setting {a0 -}
|我们把 a0 设置为 0 ，

723
00:22:42,280 --> 00:22:44,080
0,60 60,660 660,870 870,1380 1530,1800
to zero| and then we
|然后把 t0 中的内容加到 a0 上，

724
00:22:44,080 --> 00:22:46,390
0,540 960,1290 1290,1800 1860,2160 2160,2310
are just adding what's in

725
00:22:46,390 --> 00:22:47,890
0,210 210,600 600,780 780,900 900,1500
{t0 -} to {a0 -},|
|

726
00:22:47,890 --> 00:22:48,880
0,180 180,420 420,870 870,960 960,990
for every iteration of a
对循环中的每次迭代，直到 t0 变为 0 。

727
00:22:48,880 --> 00:22:50,920
0,480 510,1080 1080,1260 1260,1710 1710,2040
loop until {t0 -} reaches

728
00:22:50,920 --> 00:22:51,520
0,420
zero.|
|

729
00:22:52,500 --> 00:22:53,370
0,150 150,330 330,450 450,630 630,870
And that's all that's going
这就是这段代码的意思。

730
00:22:53,370 --> 00:22:54,630
0,150 150,240 240,360 360,690 720,1260
on in this piece.| Amir,
|Amir, 你举手了。

731
00:22:54,630 --> 00:22:55,580
0,150 150,360 360,780
your hands raised.|
|

732
00:22:57,460 --> 00:22:59,080
0,120 120,450 450,870 870,1230 1230,1620
I was wondering what {.section
我想知道 .section .text .global 是做什么的。

733
00:22:59,080 --> 00:23:01,540
0,810 840,1140 1140,1710 1770,2130 2130,2460
-} {.text -} {.global -}

734
00:23:01,540 --> 00:23:02,400
0,360
do.|
|

735
00:23:02,420 --> 00:23:03,770
0,270 270,720 720,990 990,1170 1170,1350
A global means that you
global 表示你可以从其他文件中包含这个，

736
00:23:03,770 --> 00:23:05,120
0,360 360,870 870,1050 1050,1170 1170,1350
can include this from other

737
00:23:05,120 --> 00:23:07,280
0,690 930,1500 1500,1710 1710,1830 1830,2160
files,| so if we actually
|如果我们去看，看一下 defs.h 。

738
00:23:07,280 --> 00:23:10,820
0,300 300,1380 1710,2430 2460,2700 2700,3540
hop into, {} let's see

739
00:23:11,630 --> 00:23:13,660
0,300 300,570 570,1230
{defs.h - -}.|
|

740
00:23:14,220 --> 00:23:15,270
0,240 240,360 360,450 450,810 810,1050
This is the file that
这是你后面会非常熟悉的文件，

741
00:23:15,270 --> 00:23:17,580
0,540 1080,1650 1650,2010 2010,2190 2190,2310
you're {} will, if you

742
00:23:17,580 --> 00:23:18,720
0,210 210,540 540,660 660,810 810,1140
aren't already, you will become

743
00:23:18,720 --> 00:23:20,970
0,240 240,660 660,1020 1020,1410 1410,2250
quite familiar with,| this includes
|包含内核中可能使用的所有函数

744
00:23:20,970 --> 00:23:22,380
0,480 480,690 690,780 780,870 870,1410
basically all of the functions

745
00:23:22,380 --> 00:23:23,370
0,270 270,330 330,750 750,870 870,990
within the kernel that you

746
00:23:23,370 --> 00:23:24,480
0,150 150,330 330,390 390,510 510,1110
may want to be using|
|

747
00:23:24,870 --> 00:23:27,510
0,750 780,1230 1230,1620 1620,2280 2430,2640
and {} within here you
在这里，我们可以看到，

748
00:23:27,510 --> 00:23:28,470
0,210 210,330 330,480 480,720 720,960
know we can see that,|
|

749
00:23:28,470 --> 00:23:29,440
0,150 150,750
in my
在我的文件中，已经包含了这些函数的定义，

750
00:23:29,610 --> 00:23:31,440
0,270 270,810 810,990 990,1620 1620,1830
my file, I've included the

751
00:23:31,440 --> 00:23:33,600
0,690 690,780 780,990 990,1770 1920,2160
definitions to these functions,| and
|这样， .global 保证这些函数可以从其他地方调用，

752
00:23:33,600 --> 00:23:35,700
0,150 150,390 390,1290 1290,1590 1590,2100
so that .global makes sure

753
00:23:35,700 --> 00:23:36,800
0,450
that,

754
00:23:37,080 --> 00:23:38,760
0,540 540,780 780,1110 1110,1290 1290,1680
{} that these these functions

755
00:23:38,760 --> 00:23:40,200
0,120 120,510 540,1020 1020,1170 1170,1440
can be called from other

756
00:23:40,200 --> 00:23:42,570
0,750 1020,1380 1380,1650 1650,2130 2130,2370
places| and {.text -} just
|而 .text 表示这是代码。

757
00:23:42,570 --> 00:23:43,740
0,240 240,360 360,480 480,960
says this is code.|
|

758
00:23:44,220 --> 00:23:46,020
0,330 330,510 510,630 630,1110 1110,1800
So if you recall from
如果你回想一下书中的图 3.4 ，

759
00:23:46,020 --> 00:23:48,000
0,510 510,780 780,1170 1170,1800 1800,1980
figure {3.4 - -} in

760
00:23:48,000 --> 00:23:49,020
0,90 90,720
the book,|
|

761
00:23:49,300 --> 00:23:50,890
0,540 540,720 720,1230 1230,1440 1440,1590
{} so that's if we
我们去看那本书，

762
00:23:50,890 --> 00:23:52,820
0,780 810,1710
go to

763
00:23:53,430 --> 00:23:54,640
0,150 150,1080
the book,|
|

764
00:23:56,380 --> 00:23:58,390
0,240 240,360 360,690 690,1350 1530,2010
and we go into page
我们进入页表进程地址空间，

765
00:23:58,390 --> 00:24:01,360
0,1200 1230,1650 1650,1950 1950,2400 2580,2970
tables process address space,| so
|在这张图中，这和 text 是一样的，表示代码。

766
00:24:01,360 --> 00:24:03,550
0,270 270,900 930,1140 1140,1320 1320,2190
in here in this diagram,

767
00:24:03,730 --> 00:24:05,350
0,360 360,510 510,810 810,1200 1500,1620
that's the same thing is

768
00:24:05,350 --> 00:24:06,640
0,390 390,510 510,690 690,870 870,1290
text, so just means code.|
|

769
00:24:09,440 --> 00:24:11,630
0,150 150,360 360,450 450,810 1290,2190
That answer your question?| Thanks.|
这回答了你的问题吗？|谢谢。|

770
00:24:14,810 --> 00:24:15,740
0,240 240,420 420,630 630,720 720,930
And so if we want
如果我们想运行，嗯。

771
00:24:15,740 --> 00:24:17,560
0,60 60,750 780,1440
to run, um.|
|

772
00:24:17,670 --> 00:24:18,600
0,270 270,420 420,570 570,750 750,930
Let's say we have some
我们有一些汇编代码，

773
00:24:18,600 --> 00:24:20,640
0,930 990,1350 1350,1440 1440,1680 1680,2040
assembly,| also if you ever
|如果你发现自己对内核代码感兴趣，

774
00:24:20,640 --> 00:24:23,520
0,300 300,930 1050,1890 1890,2610 2640,2880
find yourself interested in what

775
00:24:23,520 --> 00:24:25,410
0,120 120,570 570,870 870,1380 1620,1890
the kernel looks like,| we
|我们可以进入，编译后你可以查看 kernel/kernel.asm 文件。

776
00:24:25,410 --> 00:24:27,450
0,330 330,780 780,1350 1350,1740 1740,2040
can go inside the, after

777
00:24:27,450 --> 00:24:29,250
0,120 120,840 990,1320 1320,1650 1650,1800
you compile you can look

778
00:24:29,250 --> 00:24:30,750
0,90 90,210 210,660 660,1080 1080,1500
in the file {kernel/kernel.asm -

779
00:24:30,750 --> 00:24:32,500
0,360 360,600 600,1080
- - -}.|
|

780
00:24:32,800 --> 00:24:33,910
0,360 360,570 570,690 690,810 810,1110
And this is the full
这是 xv6 内核的完整汇编代码，

781
00:24:33,910 --> 00:24:37,360
0,210 210,570 1590,2550 2580,3300 3330,3450
kind of assembly for the

782
00:24:37,360 --> 00:24:38,200
0,540
kernel

783
00:24:38,980 --> 00:24:40,330
0,450 450,600 600,750 750,870 870,1350
{} of {xv6 - -},|
|

784
00:24:40,330 --> 00:24:41,680
0,330 330,540 540,660 660,900 900,1350
and each of these numbers
左边的每个数字都是一个标签，

785
00:24:41,680 --> 00:24:43,660
0,150 150,270 270,600 600,1140 1410,1980
on the left here is

786
00:24:43,660 --> 00:24:45,070
0,120 120,750 750,960 960,1230 1230,1410
a label| that tells you
|告诉你这个指令在内存中的位置，

787
00:24:45,070 --> 00:24:46,780
0,360 360,510 510,960 960,1230 1230,1710
where in memory, this in

788
00:24:46,900 --> 00:24:48,790
0,210 210,690 690,840 840,1260 1590,1890
this instruction will be| and
|这是很有用的。

789
00:24:48,790 --> 00:24:49,870
0,120 120,240 240,450 450,810 810,1080
that will come in quite

790
00:24:49,870 --> 00:24:50,680
0,420
handy.|
|

791
00:24:50,670 --> 00:24:51,870
0,210 210,330 330,630 630,720 720,1200
And so here is the
所以，这就是实际的，

792
00:24:52,380 --> 00:24:54,000
0,330 330,450 450,930 930,1440
here's the actual, {}|
|

793
00:24:54,840 --> 00:24:56,130
0,180 180,270 270,540 540,930 930,1290
use the actual assembly code
使用实际的汇编代码，你可以看到函数的标签以及声明，

794
00:24:56,130 --> 00:24:56,850
0,90 90,210 210,330 330,570 570,720
and you can see the

795
00:24:56,850 --> 00:24:59,280
0,720 720,840 840,960 960,2010 2250,2430
labels for the functions and

796
00:24:59,280 --> 00:25:00,360
0,270 270,630 630,750 750,930 930,1080
whether declared,| so this is
|这在我们调试代码时是非常有用的，

797
00:25:00,360 --> 00:25:02,190
0,210 210,390 390,840 1260,1680 1680,1830
this is, {} can be

798
00:25:02,190 --> 00:25:03,510
0,270 270,480 480,990 990,1200 1200,1320
really really useful as we're

799
00:25:03,510 --> 00:25:04,980
0,420 420,870 870,1020 1020,1350 1350,1470
debugging code| and hopefully I'll
|稍后我将展示这一点。

800
00:25:04,980 --> 00:25:05,850
0,90 90,240 240,330 330,570 570,870
be able to show that

801
00:25:06,150 --> 00:25:07,180
0,180 180,240 240,750
in a second.|
|

802
00:25:07,540 --> 00:25:09,460
0,360 360,480 480,990 1260,1620 1620,1920
But for now we'll jump
但是现在我们回到第一个函数 sum_to ，

803
00:25:09,460 --> 00:25:11,530
0,360 360,990 990,1290 1290,1590 1590,2070
back to this first function,

804
00:25:11,530 --> 00:25:13,180
0,300 300,840 1020,1320 1320,1440 1440,1650
{sum_to -}| and we'll just
|我们看看如何在 gdb 中调试，

805
00:25:13,180 --> 00:25:14,920
0,330 330,600 600,780 780,1110 1110,1740
see how we can examine

806
00:25:14,920 --> 00:25:16,750
0,420 450,1020 1020,1110 1110,1380 1380,1830
that inside of {gdb -},|
|

807
00:25:16,780 --> 00:25:19,330
0,630 1650,1950 1950,2040 2040,2280 2280,2550
{} so the first step
第一步，这里我有两个窗口，

808
00:25:19,330 --> 00:25:20,320
0,240 240,360 360,480 480,600 600,990
is I have my two

809
00:25:20,320 --> 00:25:22,510
0,480 480,1140 1350,1770 1770,1860 1860,2190
windows here.| What's the difference
|.asm 和 .S 文件有什么不同？

810
00:25:22,510 --> 00:25:24,880
0,300 330,510 510,1350 1350,2160
between .asm .S files?|
|

811
00:25:25,170 --> 00:25:26,220
0,810
Um,
嗯，我也不是很确定，

812
00:25:27,150 --> 00:25:29,310
0,300 300,360 360,600 600,1080 1320,2160
not a hundred percent certain,|
|

813
00:25:29,430 --> 00:25:31,110
0,360 360,810 810,1350 1350,1470 1470,1680
they're both assembly,| I think
它们都是汇编，|我想 .asm 文件包含了许多 .S 文件没有包含的额外注释，

814
00:25:31,110 --> 00:25:32,700
0,210 210,540 540,930 930,1320 1320,1590
the {.asm - -} file

815
00:25:32,700 --> 00:25:33,810
0,360 360,420 420,690 690,780 780,1110
includes a bunch of extra

816
00:25:33,810 --> 00:25:35,490
0,690 690,930 930,1140 1140,1590 1590,1680
annotations that aren't included in

817
00:25:35,490 --> 00:25:37,080
0,300 300,630 900,1140 1140,1470 1470,1590
{.S -},| so usually when
|通常情况下，你把 C 代码编译成 .S 时，

818
00:25:37,080 --> 00:25:38,490
0,180 180,630 630,780 780,990 990,1410
you compile your c code

819
00:25:38,490 --> 00:25:39,400
0,540
to

820
00:25:39,940 --> 00:25:40,990
0,480 480,630 630,750 750,900 900,1050
{.S -},| you'll end up
|你会得到一些不包含行号的汇编代码，

821
00:25:40,990 --> 00:25:42,700
0,120 120,810 900,1140 1140,1410 1410,1710
with something that doesn't include

822
00:25:42,700 --> 00:25:43,930
0,240 240,480 480,720 720,1110 1110,1230
all those line numbers and

823
00:25:43,930 --> 00:25:45,140
0,210 210,390 390,660 660,990
things like that.| So,
|如果你想知道如何获得 .asm 文件，

824
00:25:45,630 --> 00:25:46,560
0,150 150,270 270,600 600,780 780,930
if you're curious about how

825
00:25:46,560 --> 00:25:47,700
0,90 90,360 360,660 660,870 870,1140
we get {asm -} file,|
|

826
00:25:47,700 --> 00:25:48,780
0,90 90,210 210,300 300,540 540,1080
I think the {makefile -}
我想 makefile 会告诉你获得它的准确步骤。

827
00:25:49,050 --> 00:25:50,460
0,510 540,720 720,930 930,1290 1290,1410
{} will tell you the

828
00:25:50,460 --> 00:25:51,520
0,360 360,930
exact steps

829
00:25:51,630 --> 00:25:53,460
0,390 390,480 480,660 660,900
used to get that.|
|

830
00:25:55,960 --> 00:25:57,790
0,150 150,720 900,1260 1260,1740 1740,1830
And so if we're in
我们回到终端，我们有两个窗口，

831
00:25:57,790 --> 00:25:58,570
0,90 90,450 450,540 540,690 690,780
our terminal, we have our

832
00:25:58,570 --> 00:26:00,790
0,630 630,930 930,1200 1200,1890 2010,2220
two {} two windows,| so
|首先要做的当然是启动并运行 QEMU 。

833
00:26:00,790 --> 00:26:01,690
0,90 90,360 360,480 480,540 540,900
the first thing to do

834
00:26:01,690 --> 00:26:04,360
0,210 210,300 300,780 780,1320 1830,2670
is of course {} get

835
00:26:04,360 --> 00:26:06,360
0,600 600,780 780,900 900,1440
QEMU up and running.|
|

836
00:26:06,630 --> 00:26:08,120
0,450 450,960
So gdb,
在 gdb 模式下启动，

837
00:26:08,460 --> 00:26:10,110
0,600 600,960 960,1080 1080,1380 1380,1650
started within {gdb -} mode,|
|

838
00:26:10,110 --> 00:26:11,850
0,120 120,300 300,810 810,1170 1170,1740
so now we're frozen here
现在我们卡在这里，然后我们启动 gdb 。

839
00:26:11,880 --> 00:26:12,870
0,270 270,390 390,480 480,600 600,990
and then we can start

840
00:26:12,870 --> 00:26:14,000
0,600
gdb,|
|

841
00:26:15,990 --> 00:26:17,640
0,210 210,630 630,900 900,1200 1200,1650
and what what what what
就像 Frans 教授上周展示的那样。

842
00:26:18,090 --> 00:26:20,220
0,450 450,810 810,1260 1260,1650 1650,2130
professor Frans showed last week.|
|

843
00:26:20,550 --> 00:26:21,750
0,450 450,780 780,900 900,1050 1050,1200
{} Which I think some
我想有些人会很兴奋，

844
00:26:21,750 --> 00:26:23,490
0,210 210,660 690,1230 1230,1350 1350,1740
people were excited,| you typed
|输入 tui enable ，会出现一个窗口，

845
00:26:23,490 --> 00:26:25,170
0,510 510,1080 1080,1230 1230,1440 1440,1680
UI, enable you get this

846
00:26:25,170 --> 00:26:26,910
0,510 570,1110 1110,1290 1290,1410 1410,1740
nice window| which is empty
|现在是空的，但在你调试时会很有用，

847
00:26:26,910 --> 00:26:27,840
0,150 150,420 420,600 600,720 720,930
for now but will come

848
00:26:27,840 --> 00:26:29,580
0,360 420,870 870,1440 1440,1620 1620,1740
in quite useful as you're

849
00:26:29,580 --> 00:26:31,260
0,570 810,1170 1170,1290 1290,1440 1440,1680
debugging,| so we can set
|我们可以设置一个断点，

850
00:26:31,260 --> 00:26:32,610
0,90 90,360 360,750 750,1230 1230,1350
a break point| and I
|应该注意到这些代码都在内核中，没有一个在用户空间，

851
00:26:32,610 --> 00:26:33,810
0,210 210,450 450,690 690,900 900,1200
should note that all this

852
00:26:33,810 --> 00:26:35,460
0,570 570,870 870,1170 1170,1560 1560,1650
code is living inside the

853
00:26:35,460 --> 00:26:36,330
0,330 330,510 510,570 570,720 720,870
kernel, none of this is

854
00:26:36,330 --> 00:26:37,680
0,120 120,360 360,840 1110,1290 1290,1350
in user space,| so we
|所以我们设置断点时没有什么烦人的问题，

855
00:26:37,680 --> 00:26:38,370
0,210 210,330 330,480 480,570 570,690
don't have any of those

856
00:26:38,370 --> 00:26:40,170
0,330 330,810 810,1050 1050,1290 1290,1800
annoying problems setting break points,|
|

857
00:26:40,410 --> 00:26:41,010
0,180 180,240 240,360 360,540 540,600
so I can set a
我可以在函数 sum_to 设置一个断点，然后继续运行。

858
00:26:41,010 --> 00:26:43,110
0,300 300,810 1080,1500 1530,1650 1650,2100
break point in the function

859
00:26:43,110 --> 00:26:44,940
0,300 300,870 1140,1470 1470,1650 1650,1830
{sum_to -} and then just

860
00:26:44,940 --> 00:26:46,160
0,360 360,900
continue running.|
|

861
00:26:47,300 --> 00:26:50,000
0,510 510,750 750,1290 2010,2220 2220,2700
Run that function and now,
现在运行该函数，你在 tui 中看到的第一个窗口是源码窗口，

862
00:26:50,000 --> 00:26:52,010
0,480 480,1140 1320,1500 1500,1800 1800,2010
{} so the first window

863
00:26:52,010 --> 00:26:53,120
0,120 120,300 300,630 630,810 810,1110
that you see in {tui

864
00:26:53,120 --> 00:26:55,880
0,360 360,1050 1050,1560 1620,2220 2220,2760
-} is the source window.|
|

865
00:26:57,270 --> 00:26:58,800
0,360 360,870 930,1140 1140,1440 1440,1530
{} Yes, as David is
是的，像 David 说的， kernel.asm 左边的数字是非常有用的，

866
00:26:58,800 --> 00:27:00,360
0,300 300,840 840,1140 1140,1440 1440,1560
saying those those numbers on

867
00:27:00,360 --> 00:27:01,380
0,120 120,420 420,510 510,810 810,1020
the left of kernel {.asm

868
00:27:01,380 --> 00:27:03,060
0,90 90,270 270,630 630,1110 1200,1680
- - -} are really

869
00:27:03,060 --> 00:27:05,730
0,480 480,780 780,1620 1650,2280 2280,2670
useful| when you're debugging things
|当你调试的时候，你得到一个地址，它会告诉你，

870
00:27:05,730 --> 00:27:07,020
0,120 120,240 240,420 420,510 510,1290
and you get an address

871
00:27:07,500 --> 00:27:08,370
0,300 300,510 510,630 630,720 720,870
it'll tell you,| so you
|所以你可以看到，

872
00:27:08,370 --> 00:27:10,080
0,150 150,360 360,930 960,1380 1380,1710
can see now,| even here
|我们可以在 gdb 中看到 PC ，即程序计数器，

873
00:27:10,080 --> 00:27:10,800
0,120 120,270 270,480 480,630 630,720
we can see that the

874
00:27:10,800 --> 00:27:12,270
0,480 480,570 570,1050 1050,1320 1320,1470
programs of PC here in

875
00:27:12,270 --> 00:27:13,200
0,150 150,660
{gdb -},

876
00:27:13,420 --> 00:27:14,800
0,270 270,360 360,690 690,1140 1140,1380
is the program counter,| so
|我们可以看这个地址，以 800 开头的，

877
00:27:14,800 --> 00:27:15,910
0,150 150,300 300,450 450,660 660,1110
we can see this address

878
00:27:15,910 --> 00:27:17,320
0,180 180,450 450,1020 1020,1260 1260,1410
eight zero zero so on

879
00:27:17,320 --> 00:27:18,460
0,120 120,330 330,900
and so forth.|
|

880
00:27:18,540 --> 00:27:20,370
0,390 390,660 660,810 810,1200 1200,1830
{} If we go into
如果我们查看 kernel.asm ，并查找那个地址，

881
00:27:20,370 --> 00:27:21,660
0,360 360,540 540,660 660,840 840,1290
{kernel.asm - - - -}

882
00:27:21,870 --> 00:27:22,950
0,210 210,330 330,720 720,870 870,1080
and we search for that

883
00:27:22,950 --> 00:27:25,020
0,480 480,1290 1320,1560 1560,1770 1770,2070
specific address,| we can see
|我们可以看到它在，

884
00:27:25,020 --> 00:27:26,140
0,180 180,390 390,870
that it's the,|
|

885
00:27:26,860 --> 00:27:28,540
0,630 690,1080 1080,1290 1290,1440 1440,1680
um, it comes up twice
嗯，它出现了两次，因为函数调用，

886
00:27:28,540 --> 00:27:29,950
0,210 210,300 300,660 660,1080 1200,1410
because the function call,| but
|我们看这里，这就是那个地址，它是 sum_to 的开头。

887
00:27:29,950 --> 00:27:31,000
0,180 180,300 300,540 540,870 870,1050
if we look here, this

888
00:27:31,000 --> 00:27:32,470
0,60 60,270 270,1050 1140,1380 1380,1470
is that address, it's the

889
00:27:32,470 --> 00:27:33,370
0,270 270,390 390,480 480,720 720,900
top of the {sum_to -}

890
00:27:33,370 --> 00:27:34,240
0,600
function.|
|

891
00:27:34,760 --> 00:27:36,170
0,360 360,570 570,750 750,1170 1170,1410
So if you see any
所以如果你在任何时候看到这些东西，

892
00:27:36,170 --> 00:27:37,070
0,300 300,450 450,570 570,780 780,900
time you see one of

893
00:27:37,070 --> 00:27:39,050
0,510 540,1230 1410,1590 1590,1680 1680,1980
these,| um all the kernel
|所有内核地址都是 0x8000 这样的数字。

894
00:27:39,050 --> 00:27:40,640
0,420 420,570 570,720 720,1080 1080,1590
addresses will look something like

895
00:27:40,670 --> 00:27:42,080
0,210 210,540 540,930 930,1140 1140,1410
a {0x8000 - - -

896
00:27:42,080 --> 00:27:43,480
0,270 270,960
 - -}
 
897
00:27:43,650 --> 00:27:45,340
0,510 540,780 780,1530
{} some numbers.|
|

898
00:27:46,240 --> 00:27:48,730
0,960 960,1890 1890,2040 2040,2190 2190,2490
Those addresses you can jump
这些地址你可以直接跳转到 kernel.asm ，

899
00:27:48,730 --> 00:27:50,410
0,330 330,690 690,1020 1020,1560 1560,1680
straight into {kernel.asm -}| and
|并找到发生问题的那一行，

900
00:27:50,410 --> 00:27:52,570
0,300 300,390 390,1020 1110,1950 1950,2160
find the exact line of

901
00:27:52,570 --> 00:27:53,710
0,390 390,570 570,660 660,1020 1020,1140
assembly where the problem is

902
00:27:53,710 --> 00:27:54,670
0,480 480,600 600,720 720,840 840,960
occurring,| and then you can
|然后可以在相应地设置断点，

903
00:27:54,670 --> 00:27:56,050
0,180 180,300 300,510 510,750 750,1380
set your break points accordingly,|
|

904
00:27:56,410 --> 00:27:58,120
0,360 360,450 450,870 1050,1350 1350,1710
but for now, {} the
现在 tui 的顶部窗口是源码窗口，

905
00:27:58,120 --> 00:28:00,100
0,330 330,810 810,1020 1020,1650 1650,1980
top window in tui is

906
00:28:00,100 --> 00:28:01,750
0,600 600,750 750,900 900,1290 1320,1650
source,| and if we want
|如果我们想要查看汇编，可以在 gdb 中输入 layout asm ，

907
00:28:01,750 --> 00:28:03,790
0,180 180,420 420,840 1230,1890 1890,2040
to look at specifically the

908
00:28:03,790 --> 00:28:05,500
0,480 480,600 600,690 690,900 900,1710
assembly we can do layout

909
00:28:05,950 --> 00:28:08,230
0,390 390,1290 1290,1440 1440,1800 2100,2280
in gdb asm,| {} and
|这会给我们所有的汇编指令，

910
00:28:08,230 --> 00:28:09,520
0,480 480,660 660,990 990,1200 1200,1290
that'll give us all of

911
00:28:09,520 --> 00:28:11,920
0,90 90,540 540,1350 1620,2100 2190,2400
the assembly instructions and {},|
|

912
00:28:11,920 --> 00:28:13,060
0,150 150,270 270,840 840,1080 1080,1140
we can also look at
如果我们输入 layout reg 还可以查看寄存器，

913
00:28:13,060 --> 00:28:14,200
0,120 120,720 720,810 810,900 900,1140
the registers if we type

914
00:28:14,200 --> 00:28:15,910
0,330 330,630 630,720 720,990 990,1710
layout reg,| we'll get assembly
|我们得到汇编和寄存器，

915
00:28:16,180 --> 00:28:18,070
0,390 390,1200 1440,1650 1650,1770 1770,1890
and registers| and if you
|如果你要浏览什么东西，

916
00:28:18,070 --> 00:28:19,660
0,180 180,630 630,1110 1110,1260 1260,1590
find yourself what to scroll

917
00:28:19,660 --> 00:28:20,820
0,240 240,930
through things,|
|

918
00:28:21,410 --> 00:28:22,220
0,240 240,360 360,450 450,570 570,810
now that we have three
现在我们有三个窗口，需要指定聚焦在哪个窗口，

919
00:28:22,220 --> 00:28:23,420
0,420 420,480 480,600 600,690 690,1200
windows, we need to specify

920
00:28:23,420 --> 00:28:24,470
0,210 210,360 360,480 480,930 930,1050
which one is focused,| so
|如果我想查看所有的寄存器，输入 focus reg 。

921
00:28:24,470 --> 00:28:25,100
0,90 90,150 150,330 330,390 390,630
if I want to look

922
00:28:25,100 --> 00:28:26,120
0,150 150,270 270,330 330,900 900,1020
for all the registers, I'm

923
00:28:26,120 --> 00:28:27,640
0,120 120,180 180,600 600,1140
going to focus reg.|
|

924
00:28:28,000 --> 00:28:29,170
0,210 210,480 480,660 660,1050 1050,1170
And now my focus is
现在我聚焦在了寄存器窗口，

925
00:28:29,170 --> 00:28:30,400
0,150 150,240 240,690 690,1050 1050,1230
on the register window| so
|这时移动箭头键或者滚动，就可以在那个窗口滚动了。

926
00:28:30,400 --> 00:28:30,920
0,270
I

927
00:28:31,420 --> 00:28:32,680
0,390 390,480 480,750 750,1170 1170,1260
move the arrow keys or

928
00:28:32,680 --> 00:28:34,510
0,630 720,990 990,1230 1230,1620 1620,1830
scroll you'll start scrolling that

929
00:28:34,510 --> 00:28:35,160
0,450
window.|
|

930
00:28:35,660 --> 00:28:37,010
0,300 300,420 420,570 570,960 960,1350
Now we can focus on
现在，我们聚焦在汇编窗口。

931
00:28:37,520 --> 00:28:38,980
0,180 180,630 630,1290
the assembly window.|
|

932
00:28:39,580 --> 00:28:40,480
0,240 240,420 420,510 510,780 780,900
And once we're here, we
我们到了这里，就可以看到所有的东西，

933
00:28:40,480 --> 00:28:41,230
0,120 120,360 360,540 540,630 630,750
can see all of the

934
00:28:41,230 --> 00:28:43,300
0,570 810,1410 1410,1620 1620,1860 1860,2070
things,| {} so let's see,
|让我们看看，我们可以在寄存器窗口中看到，

935
00:28:43,300 --> 00:28:44,350
0,120 120,270 270,690 690,960 960,1050
we can see in the

936
00:28:44,350 --> 00:28:46,180
0,660 660,1170 1170,1590 1590,1680 1680,1830
registry register window,| we can
|我们可以看到 t0 包含这个值，

937
00:28:46,180 --> 00:28:47,530
0,150 150,330 330,480 480,930 930,1350
see that {t0 -} contains

938
00:28:47,530 --> 00:28:49,060
0,240 240,960 1020,1320 1320,1410 1410,1530
this value,| we can see
|可以看到 a0 包含这个值。

939
00:28:49,060 --> 00:28:51,250
0,180 180,780 780,1230 1230,1470 1470,2190
that a0 contains this value.|
|

940
00:28:51,840 --> 00:28:53,340
0,450 450,750 750,900 900,1230 1230,1500
And as we step through
当我们单步执行汇编时，可以看到，

941
00:28:53,340 --> 00:28:55,140
0,150 150,780 780,900 900,1140 1140,1800
the assembly, we can watch,|
|

942
00:28:55,170 --> 00:28:57,810
0,360 360,960 1050,1830 1980,2250 2250,2640
say OK, {} {t0 -}
t0 刚刚得到了 a0 的值，也就是 5 ，

943
00:28:57,810 --> 00:28:58,890
0,300 300,540 540,630 630,960 960,1080
just got the value of

944
00:28:58,890 --> 00:29:00,240
0,480 480,630 630,870 870,1260 1260,1350
a0 which was five,| and
|它也高亮显示了发生改变的寄存器。

945
00:29:00,240 --> 00:29:02,100
0,330 330,660 660,1320 1320,1380 1380,1860
it's nicely highlighted the register

946
00:29:02,100 --> 00:29:03,240
0,240 240,960
that's changed.|
|

947
00:29:03,280 --> 00:29:04,810
0,630 750,1110 1110,1200 1200,1320 1320,1530
Here and we can just,
这里我们可以，如果按下 enter 键，会得到最近执行的命令，

948
00:29:04,810 --> 00:29:06,130
0,270 300,780 780,1050 1050,1140 1140,1320
keep remember if we push

949
00:29:06,130 --> 00:29:08,020
0,390 390,510 510,720 720,1230 1320,1890
enter we get the most

950
00:29:08,020 --> 00:29:09,880
0,450 450,990 990,1620 1620,1740 1740,1860
recently executed instructions,| so we
|我们继续，将 a0 设置为 0 ，

951
00:29:09,880 --> 00:29:11,680
0,240 240,450 450,1080 1110,1560 1560,1800
can go through, we set

952
00:29:11,680 --> 00:29:13,150
0,150 150,390 390,510 510,1200 1350,1470
{a0 -} to zero| and
|现在我们可以看到这个循环和其中一些值，

953
00:29:13,150 --> 00:29:13,870
0,180 180,300 300,420 420,570 570,720
now we can just kind

954
00:29:13,870 --> 00:29:15,220
0,60 60,360 360,870 870,1050 1050,1350
of watch ourselves go through

955
00:29:15,220 --> 00:29:17,740
0,210 210,1020 1230,1710
this loop and

956
00:29:17,890 --> 00:29:20,170
0,330 330,480 480,570 570,1380 2130,2280
some of the values,| and
|这就像是一个完整的[]函数。

957
00:29:20,170 --> 00:29:21,190
0,270 270,420 420,540 540,690 690,1020
then this is like a

958
00:29:21,190 --> 00:29:23,100
0,510 540,690 690,1110 1110,1650
complete {you,know} [] function.|
|

959
00:29:23,630 --> 00:29:26,720
0,360 360,1110 1350,1890 2760,2970 2970,3090
Then continue and live our
我们继续，

960
00:29:26,720 --> 00:29:27,590
0,330 330,450 450,540 540,660 660,870
lives| and if you're ever
|如果你想知道设置了什么断点，

961
00:29:27,590 --> 00:29:30,530
0,510 510,1230 2100,2520 2520,2790 2790,2940
curious about what kind of

962
00:29:30,530 --> 00:29:31,820
0,300 300,690 690,870 870,1170 1170,1290
break points you've set| or
|或者忘记了你在做什么，

963
00:29:31,820 --> 00:29:32,990
0,120 120,390 390,750 750,960 960,1170
you lose track of what

964
00:29:32,990 --> 00:29:34,370
0,150 150,270 270,810 990,1260 1260,1380
you were doing,| if you
|输入 info break 或 breakpoints ，

965
00:29:34,370 --> 00:29:37,040
0,270 270,1050 1230,1470 1470,2160 2370,2670
type info {} break or

966
00:29:37,040 --> 00:29:38,990
0,240 240,900 1020,1350 1350,1500 1500,1950
{breakpoints -},| you can see
|就可以看到代码中设置的所有断点，

967
00:29:38,990 --> 00:29:39,860
0,240 240,330 330,420 420,660 660,870
all of the break points

968
00:29:39,860 --> 00:29:40,550
0,90 90,240 240,450 450,540 540,690
that you set in your

969
00:29:40,550 --> 00:29:42,380
0,570 840,1380 1380,1620 1620,1740 1740,1830
code,| and {} you can
|你甚至可以看到，这个断点已经命中了一次，

970
00:29:42,380 --> 00:29:43,520
0,240 240,600 600,780 780,960 960,1140
even see okay, this break

971
00:29:43,520 --> 00:29:44,510
0,210 210,360 360,630 630,780 780,990
point has already been hit

972
00:29:44,510 --> 00:29:46,010
0,270 270,900 1110,1260 1260,1350 1350,1500
one time| and you get
|这样你就能得到很多有用的信息。

973
00:29:46,010 --> 00:29:48,140
0,210 210,300 300,630 630,1500 1680,2130
lots of useful information doing

974
00:29:48,140 --> 00:29:48,800
0,420
that.|
|

975
00:29:49,410 --> 00:29:50,910
0,480 480,990 990,1260 1260,1410 1410,1500
If you don't want to
如果你不想使用寄存器窗口，但需要查看寄存器，

976
00:29:50,910 --> 00:29:52,080
0,180 180,240 240,690 690,1080 1080,1170
have the register window, but

977
00:29:52,080 --> 00:29:53,130
0,120 120,450 450,630 630,720 720,1050
you do want to look

978
00:29:53,130 --> 00:29:55,410
0,180 180,270 270,1260 1380,1650 1650,2280
at the registers,| {} info
|输入 info reg 或 info registers 或 i registers

979
00:29:55,410 --> 00:29:57,450
0,600 630,990 990,1230 1230,1890 1890,2040
reg or info registers or

980
00:29:57,450 --> 00:29:58,620
0,360 360,660 660,840 840,1050 1050,1170
i registers| or any of
|任何一个都可以调出寄存器窗口。

981
00:29:58,620 --> 00:30:00,880
0,360 420,1200 1200,2010
the numerous gdb

982
00:30:00,980 --> 00:30:02,960
0,510 510,870 870,1380 1380,1770 1770,1980
{} {shortenings -} will bring

983
00:30:02,960 --> 00:30:04,130
0,150 150,240 240,570 570,900 900,1170
up the register window {}.|
|

984
00:30:05,900 --> 00:30:07,910
0,960 1350,1620 1620,1770 1770,1830 1830,2010
So with that is there
那么，有关于 gdb 的问题吗？

985
00:30:07,910 --> 00:30:09,050
0,180 180,300 300,420 420,630 630,1140
any are there any questions

986
00:30:09,050 --> 00:30:11,480
0,390 390,1350 1590,1950 1950,2370 2370,2430
about gdb?| Simple ones, I
|简单的问题，我知道已经有很多关于它的[]了，

987
00:30:11,480 --> 00:30:13,280
0,150 150,330 330,720 1020,1530 1560,1800
know it's been, {} there's

988
00:30:13,280 --> 00:30:14,480
0,330 360,660 660,750 750,1020 1020,1200
been lots of post some

989
00:30:14,480 --> 00:30:16,310
0,360 360,690 690,840 840,1200 1500,1830
[] about it,| so now's
|所以现在可以问一些简单的问题。

990
00:30:16,310 --> 00:30:17,000
0,60 60,180 180,420 420,510 510,690
a good time to just

991
00:30:17,000 --> 00:30:19,220
0,480 660,930 930,1380 1380,1980 2010,2220
ask some straightforward,| well I'll
|我会展示更多 gdb 的用法。

992
00:30:19,220 --> 00:30:21,230
0,120 120,480 480,1080 1320,1860 1860,2010
be showing more usage as

993
00:30:21,230 --> 00:30:22,940
0,660 870,1170 1170,1500 1500,1590 1590,1710
gdb.| What command did you
|你使用什么命令打开多个窗口？

994
00:30:22,940 --> 00:30:24,020
0,240 240,330 330,630 630,690 690,1080
use to open the multiple

995
00:30:24,020 --> 00:30:25,220
0,480 480,630 630,780 780,1020 1020,1200
windows?| So I use {tmux
|我使用的是 tmux ，

996
00:30:25,220 --> 00:30:26,510
0,510 600,840 840,900 900,1050 1050,1290
-},| so I can show
|我可以从头开始演示，

997
00:30:26,510 --> 00:30:28,730
0,210 210,420 420,1290 1410,2040 2040,2220
just from scratch,| {} if
|在这里，我打开一个新的终端，只有一个空白的终端。

998
00:30:28,730 --> 00:30:30,140
0,180 180,510 510,960 960,1140 1140,1410
we go here, I open

999
00:30:30,140 --> 00:30:31,730
0,60 60,210 210,900 1110,1320 1320,1590
a new terminal, so here's

1000
00:30:31,730 --> 00:30:33,080
0,150 150,210 210,540 540,1110
just a blank terminal.|
|

1001
00:30:33,730 --> 00:30:35,170
0,210 210,330 330,780 780,1290 1290,1440
If you type tmux and
如果你输入 tmux ，在 Athena 上也是可用的。

1002
00:30:35,170 --> 00:30:36,580
0,120 120,240 240,720 720,900 900,1410
this is available on Athena.|
|

1003
00:30:37,150 --> 00:30:38,100
0,690
Um,
嗯，我一会再回答下一个问题，

1004
00:30:40,110 --> 00:30:41,430
0,420 420,750 750,810 810,990 990,1320
I'll answer the next question

1005
00:30:41,430 --> 00:30:42,660
0,90 90,150 150,570 750,990 990,1230
in a second,| so now
|现在我在 tmux ，你可以从底部的绿色状态栏看出来，

1006
00:30:42,660 --> 00:30:43,530
0,150 150,270 270,630 630,750 750,870
I'm in tmux, which you

1007
00:30:43,530 --> 00:30:45,240
0,120 120,420 420,660 660,1260 1260,1710
can tell by this green

1008
00:30:45,240 --> 00:30:47,310
0,390 390,510 510,600 600,1230 1410,2070
bar at the bottom| and
|在 tmux 中，有几种方式可以创建多个窗口，

1009
00:30:47,310 --> 00:30:48,810
0,150 150,300 300,690 690,1080 1080,1500
if you want to get

1010
00:30:48,810 --> 00:30:49,680
0,240 240,390 390,450 450,690 690,870
so there's a couple ways

1011
00:30:49,680 --> 00:30:50,580
0,60 60,150 150,270 270,600 600,900
you can do multiple windows

1012
00:30:50,580 --> 00:30:52,230
0,120 120,570 600,840 840,1230 1290,1650
in {} {tmux -}, {}|
|

1013
00:30:52,230 --> 00:30:53,220
0,240 240,750
if you're,
你可以输入 control-b c ，

1014
00:30:53,300 --> 00:30:55,040
0,300 300,420 420,540 540,990 1230,1740
so you can type control-b

1015
00:30:55,040 --> 00:30:57,230
0,630 630,1110 1260,1590 1590,2010 2010,2190
c| and {} I know
|如果你习惯使用 emacs ，对此会很熟悉，

1016
00:30:57,230 --> 00:30:58,580
0,210 210,870 870,1020 1020,1170 1170,1350
that sometimes if you're used

1017
00:30:58,580 --> 00:30:59,570
0,60 60,300 300,720 720,870 870,990
to using emacs that will

1018
00:30:59,570 --> 00:31:00,440
0,180 180,210 210,390 390,480 480,870
make a lot of sense,|
|

1019
00:31:00,440 --> 00:31:03,170
0,330 510,1920 1920,2370 2370,2520 2520,2730
but normal people who don't
但是对于不使用 emacs 的人，

1020
00:31:03,170 --> 00:31:05,840
0,150 150,780 840,1530 1560,2010 2010,2670
use emacs| that's hitting control
|就是先按下 control 键，然后按下 b ，然后单独按下 c ，

1021
00:31:05,840 --> 00:31:07,190
0,90 90,300 300,840 840,1080 1080,1350
and then b and then

1022
00:31:07,190 --> 00:31:08,480
0,390 390,780 780,930 930,1050 1050,1290
hitting c on its own

1023
00:31:08,480 --> 00:31:09,950
0,330 330,780 840,1170 1170,1290 1290,1470
{afterwords -},| that will get
|这会打开第二个窗口，

1024
00:31:09,950 --> 00:31:11,180
0,150 150,240 240,600 600,1050 1050,1230
you a second window| which
|然后，你可以使用 control-b p 或

1025
00:31:11,180 --> 00:31:12,590
0,120 120,240 240,420 420,900 900,1410
you can then navigate between

1026
00:31:12,590 --> 00:31:13,910
0,150 150,660 660,990 990,1140 1140,1320
with control b and then

1027
00:31:13,910 --> 00:31:16,070
0,570 630,1170 1170,1320 1320,1470 1620,2160
p,| control b and n
|control-b n 在它们之间切换，

1028
00:31:16,280 --> 00:31:17,750
0,210 210,390 390,900 900,1020 1020,1470
to go previous and next.|
|

1029
00:31:17,810 --> 00:31:18,980
0,270 270,420 420,720 720,870 870,1170
Yeah and David just posted
是的， David 刚刚贴出了 tmux 的 cheatsheet ，这很有用，

1030
00:31:18,980 --> 00:31:20,120
0,150 150,450 450,720 720,960 960,1140
that tmux {cheatsheet -} which

1031
00:31:20,120 --> 00:31:21,740
0,210 210,810 1230,1440 1440,1530 1530,1620
is useful| and if you
|如果你想拆分窗口，

1032
00:31:21,740 --> 00:31:22,850
0,180 180,240 240,600 600,690 690,1110
want to split the windows,|
|

1033
00:31:22,850 --> 00:31:23,990
0,90 90,240 240,420 420,870 870,1140
I think it's control b
使用 control-b % 会垂直拆分窗口，

1034
00:31:23,990 --> 00:31:25,370
0,90 90,360 390,510 510,960 960,1380
and then the percent sign

1035
00:31:25,370 --> 00:31:27,380
0,120 120,450 450,900 1110,1770
will split them, um,

1036
00:31:27,900 --> 00:31:30,270
0,900 900,1110 1110,1710 1770,2190 2190,2370
vertically,| and then sign a
|使用 control-b " 会水平拆分窗口，

1037
00:31:30,270 --> 00:31:31,950
0,390 390,780 780,1110 1110,1380 1380,1680
double control b and double

1038
00:31:31,950 --> 00:31:34,060
0,510 510,930 930,1320 1320,1860
quote will split them

1039
00:31:34,090 --> 00:31:36,370
0,270 270,960 1710,2010 2010,2100 2100,2280
{} horizontally,| and so that's
|这就是我如何得到它们的。

1040
00:31:36,370 --> 00:31:37,180
0,120 120,210 210,360 360,450 450,810
how we get them.| If
|如果我们处于这种状态，可以使用 control-b o 在窗口之间切换。

1041
00:31:37,180 --> 00:31:37,870
0,150 150,240 240,390 390,600 600,690
we're in this state, we

1042
00:31:37,870 --> 00:31:39,460
0,150 150,300 300,630 630,1080 1260,1590
can use control b and

1043
00:31:39,460 --> 00:31:41,500
0,510 660,870 870,1110 1110,1470 1470,2040
o to jump between our

1044
00:31:41,620 --> 00:31:44,440
0,750 1320,1500 1500,2190 2490,2730 2730,2820
windows,| so that's that's how
|这就是我有多个窗口的方法。

1045
00:31:44,440 --> 00:31:45,790
0,90 90,330 330,720 720,1230 1230,1350
I got multiple windows.| Yeah
|是的，[]。

1046
00:31:45,790 --> 00:31:47,680
0,60 60,180 180,540 720,1620
{[] - - -}.|
|

1047
00:31:47,970 --> 00:31:49,770
0,210 210,660 690,930 930,1200 1200,1800
And then {Ahmed -} asked
Ahmed 问，为什么显示汇编地址，而不是 C 行号。

1048
00:31:49,770 --> 00:31:51,720
0,360 360,630 630,1050 1050,1440 1440,1950
why is displaying assembly addresses

1049
00:31:51,720 --> 00:31:53,010
0,420 420,780 780,840 840,1050 1050,1290
again instead of C line

1050
00:31:53,010 --> 00:31:55,950
0,600 660,1050 1050,1560 1590,2280 2280,2940
numbers.| {} So because the
|因为函数。

1051
00:31:55,950 --> 00:31:57,060
0,840
function.|
|

1052
00:31:58,010 --> 00:31:59,060
0,210 210,300 300,390 390,750 750,1050
So if we go back
如果我们回到汇编函数，

1053
00:31:59,060 --> 00:32:01,250
0,330 330,780 810,1230 1230,1860 1920,2190
to the assembly function,| this
|这完全是由汇编语言实现的，而不是用 C ，

1054
00:32:01,250 --> 00:32:02,930
0,120 120,540 540,1050 1050,1140 1140,1680
is implemented entirely in assembly

1055
00:32:02,930 --> 00:32:03,740
0,180 180,360 360,480 480,660 660,810
and not at all in

1056
00:32:03,740 --> 00:32:04,970
0,480 600,870 870,960 960,1050 1050,1230
C| and so there just
|所以没有与此相关的 C 行号。

1057
00:32:04,970 --> 00:32:06,500
0,300 300,540 540,1110 1110,1320 1320,1530
aren't any associated C line

1058
00:32:06,500 --> 00:32:07,660
0,390 390,510 510,990
numbers for this.|
|

1059
00:32:07,850 --> 00:32:10,940
0,630 1140,1590 1590,1740 1740,2130 2130,3090
{} If we were to
如果我们要设置断点，

1060
00:32:10,940 --> 00:32:13,070
0,300 300,390 390,750 750,1470 1620,2130
set a break point,| so
|如果你输入 delete ，可以删除所有断点，

1061
00:32:13,250 --> 00:32:14,120
0,180 180,270 270,420 420,480 480,870
if you {type -} delete

1062
00:32:14,120 --> 00:32:14,780
0,60 60,150 150,420 420,540 540,660
you will delete all your

1063
00:32:14,780 --> 00:32:17,030
0,210 210,780 1200,1680 1680,1860 1890,2250
break points,| so I cleared
|我删除旧断点，现在在 demo_1 中设置一个断点，

1064
00:32:17,030 --> 00:32:17,840
0,60 60,300 300,570 570,750 750,810
the old one if I

1065
00:32:17,840 --> 00:32:19,400
0,240 240,750 750,780 780,1140 1140,1560
now set a break point

1066
00:32:19,400 --> 00:32:20,840
0,300 330,690 690,1110 1110,1230 1230,1440
in demo one,| so that's
|这是一个 C 断点，然后继续运行，

1067
00:32:20,840 --> 00:32:22,310
0,90 90,390 390,630 630,1020 1290,1470
a C break point and

1068
00:32:22,310 --> 00:32:25,190
0,870 1350,1560 1560,1740 1740,2370 2430,2880
continue and run this,| now
|现在，我输入 layout split ，会得到 C 和汇编窗口。

1069
00:32:25,190 --> 00:32:26,120
0,150 150,240 240,420 420,780 780,930
if I go here and

1070
00:32:26,120 --> 00:32:27,770
0,240 240,630 630,1140 1170,1470 1470,1650
type layout split I'll get

1071
00:32:27,770 --> 00:32:29,300
0,90 90,510 510,750 750,870 870,1530
the C and the assembly.|
|

1072
00:32:29,970 --> 00:32:31,020
0,360 360,570 570,660 660,780 780,1050
Um, or if I just
如果我只想要 C 源码窗口，可以使用 layout source ，然后就只有 C 。

1073
00:32:31,020 --> 00:32:32,040
0,240 240,330 330,540 540,930 930,1020
want to C source, I

1074
00:32:32,040 --> 00:32:33,090
0,120 120,240 240,570 570,930 930,1050
can do layout source and

1075
00:32:33,090 --> 00:32:33,990
0,120 120,330 330,480 480,570 570,900
I'll just get to C.|
|

1076
00:32:35,440 --> 00:32:36,640
0,210 210,600 600,840 840,1050 1050,1200
So that's {} that's what's
这就是正在发生的事，

1077
00:32:36,640 --> 00:32:38,170
0,240 240,450 450,540 540,780 780,1530
going on,| it's just a
|基于这个事实，

1078
00:32:38,170 --> 00:32:39,190
0,330 330,450 450,570 570,870 870,1020
quirk of the fact| that
|它没有关联的 C 代码，所以看不到 C 行号。

1079
00:32:39,190 --> 00:32:40,630
0,150 150,450 450,660 660,1260 1260,1440
this doesn't have associated C

1080
00:32:40,630 --> 00:32:41,410
0,270 270,390 390,480 480,600 600,780
code and so we don't

1081
00:32:41,410 --> 00:32:43,100
0,180 180,450 450,660 660,1170
see C line numbers.|
|

1082
00:32:46,270 --> 00:32:47,950
0,240 240,720 720,900 900,1020 1020,1680
Any other any other questions
关于 gdb tmux ，还有别的问题吗？

1083
00:32:47,980 --> 00:32:49,900
0,480 480,600 600,750 750,1470 1530,1920
about {gdb - -} {tmux

1084
00:32:49,900 --> 00:32:50,960
0,870
-},


1085
00:32:51,400 --> 00:32:52,720
0,420 420,780 780,960 960,1050 1050,1320
and that sort of thing.|
|

1086
00:32:53,080 --> 00:32:54,370
0,330 330,780 780,1110 1110,1230 1230,1290
So layout split is the
所以 layout split 用来

1087
00:32:54,370 --> 00:32:55,360
0,240 240,420 420,510 510,840 840,990
one that you use to|
|调出 C 源码和汇编窗口，是吗。

1088
00:32:55,360 --> 00:32:56,980
0,270 270,510 510,840 840,1230 1230,1620
bring up this extra window

1089
00:32:56,980 --> 00:32:58,420
0,180 180,330 330,750 750,840 840,1440
of the source and assembling

1090
00:32:58,420 --> 00:33:00,130
0,210 210,780 780,1200 1200,1440 1440,1710
so {on,right}.| Yes yes, so
|是的，如果你使用 layout split ，可以得到源码和汇编窗口，

1091
00:33:00,130 --> 00:33:02,680
0,630 630,1020 1530,1800 1800,2190 2190,2550
layout if {you,do} layout split

1092
00:33:02,680 --> 00:33:04,240
0,360 360,570 570,840 870,1380 1380,1560
that'll get you source and

1093
00:33:04,240 --> 00:33:05,830
0,600 600,990 990,1350 1350,1440 1440,1590
assembly,| layout source will get
|使用 layout source 只得到源码窗口，

1094
00:33:05,830 --> 00:33:07,330
0,90 90,330 330,900 900,1410 1410,1500
you just source,| asm will
|使用 layout asm 则只有汇编窗口。

1095
00:33:07,330 --> 00:33:08,920
0,150 150,240 240,450 450,1080 1200,1590
get you just assembly.| And
|寄存器是单独的，你可以输入 layout reg ，

1096
00:33:08,920 --> 00:33:10,090
0,90 90,690 690,780 780,960 960,1170
the registers are their own

1097
00:33:10,090 --> 00:33:11,260
0,210 210,450 450,540 540,810 810,1170
thing where you type layout,

1098
00:33:11,260 --> 00:33:12,860
0,480 480,600 600,900 900,1380
reg I think.| Yeah,
|是的，这会调出寄存器，

1099
00:33:13,070 --> 00:33:13,880
0,180 180,330 330,570 570,720 720,810
that will bring up the

1100
00:33:13,880 --> 00:33:16,790
0,660 660,960 1380,2340 2340,2640 2640,2910
registers,| but unfortunately I don't
|但是，我不知道有什么方法

1101
00:33:16,790 --> 00:33:17,750
0,390 390,480 480,570 570,810 810,960
know of a way| to
|可以同时调出寄存器、汇编和 C 源码。

1102
00:33:17,750 --> 00:33:18,580
0,510
get

1103
00:33:18,750 --> 00:33:20,190
0,120 120,540 540,690 690,1260 1260,1440
to register the assembly and

1104
00:33:20,190 --> 00:33:21,060
0,60 60,270 270,600 600,780 780,870
the C code all at

1105
00:33:21,060 --> 00:33:22,230
0,60 60,330 330,720 720,1080 1080,1170
the same time| outside of
|除了在 layout split 状态下使用 info reg 。

1106
00:33:22,230 --> 00:33:24,180
0,360 360,1170 1170,1320 1320,1650 1650,1950
using {info,reg} with layout split.|
|

1107
00:33:24,990 --> 00:33:26,910
0,180 180,360 360,420 420,960 1410,1920
I have a question, so
我有一个问题，当我们在行中设置断点。

1108
00:33:26,940 --> 00:33:28,200
0,390 390,510 510,720 720,900 900,1260
when we set the back

1109
00:33:28,200 --> 00:33:30,150
0,300 300,720 720,990 1020,1620 1620,1950
{breakpoint -} at line right.|
|

1110
00:33:30,180 --> 00:33:30,980
0,510
Um,|
嗯，|

1111
00:33:31,090 --> 00:33:33,340
0,360 360,960 960,1170 1170,1860 1890,2250
it displays the address of
这种情况下，断点添加到类似 0x80006354 这样的地址，

1112
00:33:33,340 --> 00:33:34,960
0,600 630,930 930,1110 1110,1290 1290,1620
the like in this case

1113
00:33:34,960 --> 00:33:36,040
0,270 270,570 570,720 720,990 990,1080
{breakpoint -} to add to

1114
00:33:36,040 --> 00:33:38,290
0,720 750,990 990,1470 1530,1950 1950,2250
{0x80006354 - - - -},|
|

1115
00:33:39,250 --> 00:33:41,110
0,450 540,810 810,1410 1410,1650 1650,1860
what any instruction might have
指令可能有多个， C 中的代码行可能有多个指令，

1116
00:33:41,110 --> 00:33:44,170
0,840 960,1500 1530,2040 2100,2970 2970,3060
multiple {}, any line of

1117
00:33:44,170 --> 00:33:45,550
0,300 300,420 420,720 720,1200 1200,1380
code in C might have

1118
00:33:45,550 --> 00:33:47,650
0,420 420,1350 1410,1680 1680,1920 1920,2100
multiple instructions,| so which one
|那么显示的是哪一个？

1119
00:33:47,650 --> 00:33:49,750
0,570 600,1020 1020,1440 1560,1890 1890,2100
does {} show.| {I,think,it} shows
|我想显示的是第一个。

1120
00:33:49,750 --> 00:33:50,720
0,90 90,360 360,570
the first one.|
|

1121
00:33:51,510 --> 00:33:53,790
0,330 330,1140 1230,1530 1530,1950 1950,2280
And it's {tu- -}, for
对启动 tui 有问题的人，

1122
00:33:53,790 --> 00:33:54,870
0,90 90,360 360,450 450,720 720,1080
the person who asked to

1123
00:33:54,870 --> 00:33:57,180
0,360 360,1290 1470,1800 1800,2130 2130,2310
start {tui -},| it's I
|我想命令应该是 tui enable 而不是 enable tui ，不好意思。

1124
00:33:57,180 --> 00:33:58,890
0,150 150,270 270,810 810,1380 1410,1710
think it's tui enable, not

1125
00:33:58,890 --> 00:34:00,800
0,390 390,510 510,900 900,1320
enabled {tui -}, sorry.|
|

1126
00:34:01,070 --> 00:34:04,800
0,180 180,300 300,840 2460,3510
And I think yeah.|
我想是的。|

1127
00:34:05,570 --> 00:34:06,000
0,60
Yeah.|
是的。|

1128
00:34:08,450 --> 00:34:10,520
0,690 720,1260 1260,1650 1650,1920 1920,2070
{} Yeah again there's a
是的，再提一下，这里有一些 gdb 和 tmux 的 cheatsheet ，

1129
00:34:10,520 --> 00:34:12,050
0,450 450,750 750,1050 1050,1290 1290,1530
hundred {cheatsheets -} out here

1130
00:34:12,050 --> 00:34:14,450
0,330 330,1050 1200,1590 1590,2100 2100,2400
for gdb and for tmux,|
|

1131
00:34:14,450 --> 00:34:15,140
0,90 90,360 360,480 480,540 540,690
as well so if you
如果你发现自己不会用，可以看一下。

1132
00:34:15,140 --> 00:34:16,760
0,270 270,450 450,810 810,1230 1290,1620
ever find yourself lost.| I
|gdb 还有自己的内置手册，叫做 apropos ，

1133
00:34:16,760 --> 00:34:18,260
0,330 360,690 690,1020 1020,1290 1290,1500
t-, {gdb -} even has

1134
00:34:18,260 --> 00:34:19,780
0,120 120,450 450,1320
its own inbuilt

1135
00:34:19,770 --> 00:34:22,350
0,720 1440,1920 1920,2130 2130,2370 2370,2580
{} it's own thing called

1136
00:34:22,350 --> 00:34:24,060
0,630 630,1050 1200,1440 1440,1590 1590,1710
apropos {},| so if you
|如果你输入 apropos tui ，

1137
00:34:24,060 --> 00:34:26,490
0,210 210,360 360,1050 1050,1650 1650,2430
look for apropos {tui -},|
|

1138
00:34:26,520 --> 00:34:28,080
0,420 420,780 780,1050 1050,1320 1320,1560
it'll actually show you all
它会显示所有相关的 tui 命令。

1139
00:34:28,080 --> 00:34:30,450
0,150 150,420 420,1500 1530,2100 2100,2370
of the commands that {}

1140
00:34:30,450 --> 00:34:32,160
0,690 690,840 840,1530
involve {tui -}.|
|

1141
00:34:33,310 --> 00:34:35,350
0,630 690,1440 1440,1440 1620,1920 1920,2040
So yeah, {} this can
是的，这可能非常有用，但也有点令人不知所措。

1142
00:34:35,350 --> 00:34:36,580
0,120 120,390 390,900 900,1050 1050,1230
be quite useful, but it

1143
00:34:36,580 --> 00:34:37,390
0,120 120,390 390,510 510,600 600,810
can also be a little

1144
00:34:37,390 --> 00:34:39,720
0,210 210,1020 1230,2070
bit overwhelming {}.|
|

1145
00:34:39,820 --> 00:34:40,930
0,210 210,330 330,450 450,630 630,1110
If you do apropos -v
如果你使用 apropos -v ，它会给你提供更多信息。

1146
00:34:40,930 --> 00:34:42,040
0,450 450,690 690,810 810,990 990,1110
that it will give you

1147
00:34:42,040 --> 00:34:43,780
0,210 210,540 540,1110 1110,1230 1230,1740
even more information I think.|
|

1148
00:34:44,610 --> 00:34:46,900
0,630 1020,1050 1080,1680 1680,2190
Um I don't remember,
嗯，我不记得了，我不经常使用它。

1149
00:34:47,360 --> 00:34:48,410
0,240 240,600 600,810 810,960 960,1050
I I don't use it

1150
00:34:48,410 --> 00:34:49,820
0,300 300,750 750,900 900,1290 1290,1410
often myself.| But if you
|但是如果你要查找或忘记了 gdb 中输入命令的确切方式，

1151
00:34:49,820 --> 00:34:51,320
0,270 270,720 870,1140 1140,1230 1230,1500
do find or if you

1152
00:34:51,320 --> 00:34:52,250
0,300 300,360 360,750 750,840 840,930
forget the exact way to

1153
00:34:52,250 --> 00:34:53,870
0,210 210,300 300,810 810,1230 1230,1620
type the command in gdb|
|

1154
00:34:53,870 --> 00:34:54,470
0,90 90,180 180,360 360,480 480,600
and you don't feel like
而且你不想使用谷歌，

1155
00:34:54,470 --> 00:34:56,390
0,390 390,480 480,1050 1050,1050 1380,1920
google| and {apropos's -} will
|apropos 能够找到你要找的东西，

1156
00:34:56,390 --> 00:34:57,770
0,240 240,930 930,1080 1080,1260 1260,1380
will often be able to

1157
00:34:57,770 --> 00:34:59,000
0,270 270,690 690,810 810,930 930,1230
find exactly what you're looking

1158
00:34:59,000 --> 00:34:59,960
0,300 300,420 420,780 780,900 900,960
for,| in addition to a
|还包括很多关联的东西。

1159
00:34:59,960 --> 00:35:00,860
0,180 180,390 390,480 480,750 750,900
whole bunch of stuff you

1160
00:35:00,860 --> 00:35:01,840
0,90 90,390 390,660
are looking for.|
|

1161
00:35:02,240 --> 00:35:03,120
0,480

1162
00:35:04,260 --> 00:35:05,670
0,390 390,600 600,1110 1110,1200 1200,1410
Yeah, so this is actually
是的，所以这是非常有用的， gdb 也有很好的文档。

1163
00:35:05,670 --> 00:35:07,290
0,240 240,450 450,990 990,1110 1110,1620
quite useful, gdb is extremely

1164
00:35:07,290 --> 00:35:08,910
0,210 210,750 750,870 870,1140 1170,1620
well documented as well,| so
|所以，如果发现自己不会使用，你知道的，谷歌是你的朋友。

1165
00:35:09,150 --> 00:35:10,590
0,390 780,900 900,1170 1170,1260 1260,1440
um, yeah, if you ever

1166
00:35:10,590 --> 00:35:12,630
0,180 180,510 510,990 1530,1710 1710,2040
find yourself lost, you know,

1167
00:35:12,930 --> 00:35:14,380
0,480 480,540 540,660 660,1050
google is your friend.|
|

1168
00:35:15,070 --> 00:35:16,240
0,810

1169
00:35:16,800 --> 00:35:18,000
0,210 210,360 360,480 480,990 990,1200
So now that we've kind
现在我们来看汇编和 RISC-V 以及相关的东西，

1170
00:35:18,000 --> 00:35:20,220
0,90 90,240 240,810 810,1680 1680,2220
of been over assembly and

1171
00:35:20,220 --> 00:35:22,050
0,390 390,660 660,1320 1320,1650 1650,1830
and {RISC-V -} and these

1172
00:35:22,050 --> 00:35:23,190
0,180 180,270 270,690 750,990 990,1140
sort of things,| I want
|我想深入讲解一下细节，

1173
00:35:23,190 --> 00:35:23,910
0,60 60,300 300,360 360,540 540,720
to dive a little bit

1174
00:35:23,910 --> 00:35:26,430
0,330 330,510 510,630 630,1590 1830,2520
more into the specifics| of
|你们在随后的实验中会用到，

1175
00:35:26,430 --> 00:35:28,020
0,300 300,990 990,1230 1230,1440 1440,1590
what you you really need

1176
00:35:28,020 --> 00:35:30,090
0,90 90,450 450,840 840,1260 1560,2070
to know for the lab

1177
00:35:30,090 --> 00:35:32,250
0,330 330,720 900,1170 1170,1650 1650,2160
coming up| and also it'll
|另外，这也是对文档的一个回顾，

1178
00:35:32,250 --> 00:35:32,820
0,90 90,150 150,330 330,450 450,570
be a little bit of

1179
00:35:32,820 --> 00:35:34,050
0,330 330,510 510,600 600,1080 1080,1230
review from the document| that
|当然，我想勤奋的同学已经读过一遍了。

1180
00:35:34,050 --> 00:35:36,300
0,210 210,810 810,1200 1200,1620 1620,2250
you've of course, diligent students

1181
00:35:36,720 --> 00:35:38,760
0,390 390,870 900,1710
read through thoroughly

1182
00:35:38,890 --> 00:35:41,200
0,720 720,1050 1050,1740 1740,1890 1890,2310
{} in preparation for this

1183
00:35:41,200 --> 00:35:42,240
0,510
lecture.|
|

1184
00:35:42,700 --> 00:35:45,160
0,630 1200,1680 1680,1860 1860,2040 2040,2460
Um, so yeah, this table
是的，这张表你们很熟悉，

1185
00:35:45,160 --> 00:35:46,270
0,150 150,240 240,570 570,870 870,1110
will of course be a

1186
00:35:46,270 --> 00:35:47,860
0,450 450,840 840,960 960,1110 1110,1590
wildly familiar to you all|
|

1187
00:35:47,860 --> 00:35:50,500
0,630 660,1290 1710,2160 2160,2460 2460,2640
and {} from from both
从 6.004 或你们自己读的资料中，

1188
00:35:50,500 --> 00:35:51,670
0,330 330,720 720,870 870,1020 1020,1170
{6.004 -} and from what

1189
00:35:51,670 --> 00:35:53,230
0,210 210,600 690,1140 1140,1320 1320,1560
you've read,| and this is
|这是寄存器表，

1190
00:35:53,230 --> 00:35:55,060
0,90 90,600 600,810 810,1440 1440,1830
the table of registers| and
|寄存器是 CPU 上处理器周围预设的很小的位置，

1191
00:35:55,150 --> 00:35:59,200
0,900 900,1560 1590,2190 2220,3540 3540,4050
registers are little locations on

1192
00:35:59,200 --> 00:36:02,110
0,240 240,1140 1200,1920 1920,2010 2010,2910
the CPU around the processor

1193
00:36:02,640 --> 00:36:04,710
0,990 990,1290 1290,1410 1410,1620 1620,2070
predefined| that it can use
|它可以存储值，这很重要，

1194
00:36:04,710 --> 00:36:06,870
0,270 270,750 750,1470 1620,2010 2010,2160
to store values and this

1195
00:36:06,870 --> 00:36:09,600
0,90 90,540 540,1110 1140,1770 1770,2730
is important,| because assembly operations
|因为汇编操作，如果你记得汇编代码，

1196
00:36:09,600 --> 00:36:10,590
0,420 420,540 540,810 810,930 930,990
if we remember from the

1197
00:36:10,590 --> 00:36:12,600
0,330 330,750 900,1170 1170,1560 1590,2010
assembly code,| the {} assembly
|汇编不是在内存上操作，而是在寄存器上操作，

1198
00:36:12,600 --> 00:36:14,250
0,330 330,840 840,1110 1110,1500 1500,1650
doesn't operate on memory, it

1199
00:36:14,250 --> 00:36:15,750
0,480 480,630 630,1110 1110,1320 1320,1500
operates on register,| so when
|所以我们做加法、减法时，是在寄存器上操作。

1200
00:36:15,750 --> 00:36:16,650
0,120 120,330 330,690 690,810 810,900
we do add when we

1201
00:36:16,650 --> 00:36:18,990
0,120 120,750 840,1140 1140,1830 1830,2340
do subtract we're operating on

1202
00:36:18,990 --> 00:36:20,820
0,720 810,1590
registers {}.|
|

1203
00:36:21,000 --> 00:36:22,050
0,210 210,390 390,570 570,690 690,1050
And so what you often
所以你经常看到一种编写汇编的模式，

1204
00:36:22,050 --> 00:36:24,210
0,420 420,630 630,720 720,1380 1410,2160
see as the pattern for

1205
00:36:24,240 --> 00:36:25,860
0,510 510,1080 1080,1230 1230,1350 1350,1620
writing assembly| is will have
|有一个 load ，将一些值加载到寄存器中。

1206
00:36:25,860 --> 00:36:27,270
0,240 240,510 510,660 660,720 720,1410
some kind of a load,

1207
00:36:27,510 --> 00:36:30,060
0,300 300,600 600,1170 1170,1530 1530,2550
so we'll load some value

1208
00:36:30,550 --> 00:36:32,360
0,360 360,630 630,780 780,1530
{} to a register.|
|

1209
00:36:33,030 --> 00:36:34,560
0,690 720,960 960,1290 1290,1440 1440,1530
And that value can be
这个值可以来自内存，也可以来自另一个寄存器。

1210
00:36:34,560 --> 00:36:35,550
0,150 150,660 660,810 810,900 900,990
from memory, or it can

1211
00:36:35,550 --> 00:36:37,600
0,120 120,300 300,1050 1050,1770
be from another register.|
|

1212
00:36:38,340 --> 00:36:39,930
0,540 540,1020 1020,1350 1350,1530 1530,1590
And, {} and here {}
这里泛指加载，而不是 load 指令。

1213
00:36:39,930 --> 00:36:40,950
0,270 270,360 360,600 600,690 690,1020
referring to load in general,

1214
00:36:40,950 --> 00:36:43,020
0,180 180,270 270,480 480,1050 1200,2070
not the load instruction {}.|
|

1215
00:36:43,420 --> 00:36:45,060
0,240 240,450 450,630 630,1380
And then we'll operate,
然后我们会操作，在寄存器上执行一些操作，

1216
00:36:45,780 --> 00:36:47,970
0,240 240,630 630,1050 1050,1230 1230,2190
so we'll perform some operation

1217
00:36:48,090 --> 00:36:49,680
0,510 510,600 600,1320 1320,1470 1470,1590
on the register,| and then
|如果我们关心返回地址之外的操作结果，

1218
00:36:49,680 --> 00:36:50,520
0,120 120,240 240,510 510,750 750,840
if we care about the

1219
00:36:50,520 --> 00:36:52,170
0,330 330,390 390,600 600,1200 1200,1650
result of that operation outside

1220
00:36:52,170 --> 00:36:54,150
0,90 90,450 450,930 1110,1560 1560,1980
the return address,| we will,
|我们可以把寄存器的值存储到某个地方，

1221
00:36:54,150 --> 00:36:54,940
0,540

1222
00:36:55,000 --> 00:36:58,570
0,240 240,1200 1230,1800 1830,2820 2820,3570
we'll store that register to

1223
00:36:58,690 --> 00:36:59,600
0,690
somewhere,


1224
00:37:00,590 --> 00:37:01,460
0,180 180,390 390,510 510,720 720,870
to some {locate -},| they
|将寄存器的值存储到内存中某个位置或另一个寄存器。

1225
00:37:01,460 --> 00:37:02,810
0,180 180,420 420,600 600,1110 1110,1350
will store that register to

1226
00:37:02,810 --> 00:37:06,080
0,210 210,1050 1350,1770 1770,2580 2580,3270
some location in memory or

1227
00:37:06,920 --> 00:37:09,050
0,180 180,510 510,1080 1290,1500 1500,2130
to another register| and that's
|这就是通常的操作过程，

1228
00:37:09,050 --> 00:37:10,580
0,720 720,810 810,960 960,1170 1170,1530
generally the way things work|
|

1229
00:37:10,580 --> 00:37:12,560
0,660 660,1170 1170,1230 1230,1380 1380,1980
and registers are the absolute
寄存器是执行任何计算或访问任何值的最快方式，

1230
00:37:12,560 --> 00:37:14,330
0,480 480,660 660,720 720,1320 1410,1770
fastest way to perform any

1231
00:37:14,330 --> 00:37:16,010
0,180 180,240 240,1080 1170,1500 1500,1680
sort of calculation {} or

1232
00:37:16,010 --> 00:37:17,420
0,60 60,600 600,810 810,1290 1290,1410
to access any value| and
|这就是为什么使用它们很重要，

1233
00:37:17,420 --> 00:37:20,000
0,210 210,720 1500,1710 1710,2310 2310,2580
that's why it's important to

1234
00:37:20,000 --> 00:37:21,680
0,240 240,540 540,660 660,1020 1020,1680
use them| and also why
|也是我们更应该使用寄存器而不是内存的原因，

1235
00:37:21,770 --> 00:37:24,230
0,300 300,810 810,1170 1170,1890 1890,2460
we prefer using registers overusing

1236
00:37:24,230 --> 00:37:25,520
0,360 360,600 600,720 720,870 870,1290
memory,| so if you remember
|如果你们记得文档中，我们调用函数时，

1237
00:37:25,520 --> 00:37:27,440
0,390 510,810 810,1380 1470,1770 1770,1920
from the reading when we

1238
00:37:27,440 --> 00:37:28,730
0,330 330,900 900,990 990,1140 1140,1290
call functions| so you can
|可以看到，寄存器从 a0 到 a7 。

1239
00:37:28,730 --> 00:37:30,410
0,240 240,570 570,750 750,1440 1440,1680
see here that registers {a0

1240
00:37:30,410 --> 00:37:31,780
0,360 360,480 480,1080
-} to seven.|
|

1241
00:37:32,450 --> 00:37:34,670
0,630 1440,1620 1620,1980 1980,2100 2100,2220
And in general when we
一般来说，当我们谈到寄存器时，会使用它们的 ABI 名称来指代它们，

1242
00:37:34,670 --> 00:37:37,310
0,240 240,510 510,1170 1170,1740 1950,2640
speak about registers we we

1243
00:37:37,310 --> 00:37:38,780
0,360 390,780 780,1230 1230,1320 1320,1470
will be referring to them

1244
00:37:38,780 --> 00:37:40,610
0,180 180,390 390,780 780,1230 1260,1830
by their ABI name {},|
|

1245
00:37:40,820 --> 00:37:42,560
0,750 750,990 990,1140 1140,1560 1560,1740
not only is it less
不仅减少了混淆，也是一个标准，

1246
00:37:42,560 --> 00:37:43,760
0,420 420,540 540,750 750,810 810,1200
confusing, it's just a standard|
|

1247
00:37:43,760 --> 00:37:44,540
0,120 120,240 240,510 510,630 630,780
and it's also the way
也是你编写汇编代码的方式，

1248
00:37:44,540 --> 00:37:45,920
0,120 120,300 300,480 480,900 900,1380
that you'll write assembly code,|
|

1249
00:37:45,950 --> 00:37:47,400
0,540 570,1320
{} this,
这个，这些实际的数字并不是特别重要，

1250
00:37:47,530 --> 00:37:49,030
0,150 150,390 480,810 810,1050 1050,1500
you know, these these actual

1251
00:37:49,030 --> 00:37:50,920
0,510 510,600 600,840 840,1230 1230,1890
numbers are not super important,|
|

1252
00:37:50,980 --> 00:37:52,630
0,570 570,930 930,1350 1350,1560 1560,1650
the only case where it
唯一有意义的情况是对于 RISC-V 指令的压缩版本，

1253
00:37:52,630 --> 00:37:55,390
0,300 300,840 840,1560 1590,2520 2550,2760
does matter is for the

1254
00:37:55,390 --> 00:37:57,310
0,570 570,930 930,1050 1050,1350 1350,1920
compressed version of {RISC-V -}

1255
00:37:57,310 --> 00:37:59,080
0,1050 1050,1350 1350,1530 1530,1650 1650,1770
instructions| and if you want
|如果你想了解更多，可以查看文档，

1256
00:37:59,080 --> 00:38:00,130
0,60 60,210 210,390 390,690 690,1050
to know more about that,

1257
00:38:00,190 --> 00:38:01,780
0,630 660,1170 1170,1320 1320,1380 1380,1590
{} feel free to read

1258
00:38:01,780 --> 00:38:02,770
0,150 150,420 420,570 570,630 630,990
up about it,| the basic
|基本思想是 RISC-V ，普通指令是 64 位，

1259
00:38:02,770 --> 00:38:04,510
0,630 630,810 810,1020 1020,1260 1260,1740
idea is that {RISC-V -},

1260
00:38:04,890 --> 00:38:06,810
0,360 360,690 690,1200 1200,1320 1320,1920
{} normal instructions are 64

1261
00:38:06,810 --> 00:38:08,100
0,420 420,690 690,900 900,1200 1200,1290
bits,| but there's also a
|但是也有一个压缩版本，指令是 16 位，

1262
00:38:08,100 --> 00:38:09,720
0,450 450,840 840,1050 1050,1530 1530,1620
compressed version, which instructions are

1263
00:38:09,720 --> 00:38:11,370
0,510 510,930 1110,1320 1320,1410 1410,1650
sixteen bits| and we use
|我们使用的寄存器更少，这种情况下，使用的寄存器是 8 到 15 ，

1264
00:38:11,370 --> 00:38:13,290
0,300 300,1050 1170,1410 1410,1500 1500,1920
less registers and the registers

1265
00:38:13,290 --> 00:38:14,580
0,150 150,390 390,480 480,720 720,1290
we use in that case

1266
00:38:14,610 --> 00:38:17,430
0,1170 1260,1620 1620,2040 2040,2610 2610,2820
are eight through fifteen,| those
|这些是我们可以使用的寄存器。

1267
00:38:17,430 --> 00:38:18,150
0,60 60,150 150,510 510,660 660,720
are the registers that are

1268
00:38:18,150 --> 00:38:19,500
0,420 420,570 570,900 1020,1290 1290,1350
available to us.| So I
|有人提问，为什么这个 s1 寄存器 x9 ，

1269
00:38:19,500 --> 00:38:20,610
0,210 210,540 540,660 660,750 750,1110
think somebody had a question

1270
00:38:20,610 --> 00:38:22,410
0,600 660,1170 1170,1320 1320,1590 1590,1800
about why is this {s1

1271
00:38:22,410 --> 00:38:24,360
0,330 330,1050 1050,1290 1290,1710 1710,1950
-} register {x9 -},| why
|为什么它与其他所有寄存器分开？

1272
00:38:24,360 --> 00:38:26,280
0,210 210,540 780,1110 1110,1740 1740,1920
is it, {} separated from

1273
00:38:26,280 --> 00:38:27,210
0,150 150,270 270,420 420,720 720,930
all of the {other's -}

1274
00:38:27,210 --> 00:38:29,340
0,750 840,1470 1500,1710 1710,2010 2010,2130
registers?| And my guess is
|我猜是这样，

1275
00:38:29,340 --> 00:38:31,440
0,180 180,450 450,750 1110,1650
that that's why {},|
|

1276
00:38:31,800 --> 00:38:32,940
0,330 330,450 450,840 840,960 960,1140
that we separated from all
我们把它与其他分开，因为它在压缩指令模式下是可用的，

1277
00:38:32,940 --> 00:38:34,050
0,120 120,300 300,540 540,900 900,1110
the other ones because it's

1278
00:38:34,050 --> 00:38:37,050
0,810 810,1290 1320,1950 1950,2490 2490,3000
available in compressed instruction mode,|
|

1279
00:38:37,080 --> 00:38:38,670
0,780 780,960 960,1110 1110,1230 1230,1590
whereas {s2 -} to eleven
而 s2 到 s11 不是。

1280
00:38:38,670 --> 00:38:39,260
0,90 90,450
or not.|
|

1281
00:38:40,220 --> 00:38:41,090
0,150 150,240 240,420 420,540 540,870
And so that's the idea,
这是我的想法，它是一个压缩指令寄存器，

1282
00:38:41,180 --> 00:38:42,590
0,480 480,780 780,840 840,1290 1290,1410
that's that's a compress,| but
|但是在寄存器之外，将通过它们的 ABI 名称来引用，

1283
00:38:42,590 --> 00:38:44,330
0,330 330,390 390,720 780,1500 1500,1740
outside of that register will

1284
00:38:44,330 --> 00:38:45,940
0,510 510,930 930,1380
be referred to

1285
00:38:46,020 --> 00:38:48,210
0,450 480,1170 1260,1710 1710,2010 2040,2190
by their ABI name| and
|a0 到 a7 用于函数变量，

1286
00:38:48,210 --> 00:38:49,560
0,270 270,780 780,870 870,1020 1020,1350
so a0 to {a7 -}

1287
00:38:49,560 --> 00:38:51,180
0,150 150,420 420,600 600,960 960,1620
are used for function arguments,|
|

1288
00:38:51,270 --> 00:38:51,900
0,330 330,390 390,480 480,570 570,630
but if we have a
但是如果有一个函数接受的参数数量，

1289
00:38:51,900 --> 00:38:53,670
0,360 360,510 510,750 750,1170 1170,1770
function that takes| more than
|超过可以访问的寄存器数 8 个，

1290
00:38:53,850 --> 00:38:55,200
0,270 270,480 480,990 990,1140 1140,1350
the eight arguments that those

1291
00:38:55,200 --> 00:38:57,030
0,600 600,780 780,900 900,1380 1380,1830
registers give us access to,|
|

1292
00:38:57,470 --> 00:38:58,580
0,450 450,630 630,840 840,930 930,1110
we do need to use
我们就需要内存，

1293
00:38:58,580 --> 00:39:00,080
0,420 420,570 570,930 930,1290 1320,1500
memory| but that's {}, this
|但这在某种程度上也说明了一个事实，

1294
00:39:00,080 --> 00:39:00,980
0,90 90,270 270,330 330,420 420,900
is kind of an illustration

1295
00:39:00,980 --> 00:39:01,550
0,90 90,150 150,390 390,480 480,570
of the fact| that we
|当我们可以使用寄存器时，就不使用内存。

1296
00:39:01,550 --> 00:39:02,570
0,240 240,420 420,480 480,660 660,1020
don't want to use memory

1297
00:39:02,570 --> 00:39:03,920
0,90 90,180 180,480 480,630 630,1350
when we can use registers.|
|

1298
00:39:04,100 --> 00:39:05,570
0,300 300,480 480,930 960,1140 1140,1470
{} We only we only
我们只在必须的时候使用内存。

1299
00:39:05,570 --> 00:39:07,250
0,570 660,870 870,1290 1290,1440 1440,1680
use a memory, we have

1300
00:39:07,250 --> 00:39:08,320
0,240
to.|
|

1301
00:39:08,790 --> 00:39:10,320
0,210 210,450 450,840 840,1230 1230,1530
And this, this column here,
这一栏， saver 栏，

1302
00:39:10,320 --> 00:39:12,360
0,90 90,510 510,1170 1350,1830 1860,2040
the saver column,| {} this
|也是非常重要的，

1303
00:39:12,360 --> 00:39:14,220
0,120 120,600 600,1290 1290,1710 1710,1860
is also extremely important| when
|在我们讨论调用者（caller）和被调用者（callee）保存寄存器时，

1304
00:39:14,220 --> 00:39:16,260
0,120 120,600 600,1170 1170,1620 1620,2040
we're discussing registers caller versus

1305
00:39:16,260 --> 00:39:17,720
0,450 450,1140
callee saved.|
|

1306
00:39:17,760 --> 00:39:20,940
0,510 510,1140 1590,2220 2220,2640 2640,3180
And {} the terms are
这两个属于我也经常混淆，

1307
00:39:21,060 --> 00:39:23,940
0,570 570,1110 1110,1800 1830,2550 2550,2880
I confuse them regularly,| caller
|caller 和 callee 只有一个字母的区别，

1308
00:39:23,940 --> 00:39:25,080
0,120 120,480 480,660 660,870 870,1140
and callee, the only differ

1309
00:39:25,080 --> 00:39:27,360
0,150 150,390 390,870 930,1710 1710,2280
by one letter,| the easiest
|记住它们最简单的方法是，

1310
00:39:27,360 --> 00:39:28,890
0,270 270,630 840,1170 1170,1470 1470,1530
way that I've found to

1311
00:39:28,890 --> 00:39:31,110
0,390 390,660 660,810 810,1260 1320,2220
remember them is| that caller
|调用者保存寄存器在函数调用期间不会保留，

1312
00:39:31,110 --> 00:39:34,240
0,540 540,1500 1530,2070 2070,2910
saved registers are not

1313
00:39:34,410 --> 00:39:35,640
0,1020
preserved,

1314
00:39:37,360 --> 00:39:38,740
0,300 300,1230
{} across

1315
00:39:39,830 --> 00:39:41,040
0,150 150,510 510,1020
a function call,|
|

1316
00:39:42,190 --> 00:39:45,580
0,720 1020,1500 1500,2010 2010,2370 2370,3390
so and callee saved registers
而被调用者保存寄存器会保留。

1317
00:39:46,800 --> 00:39:48,100
0,330 330,1050
are preserved.|
|

1318
00:39:49,580 --> 00:39:51,200
0,270 270,360 360,720 720,900 900,1620
What I mean by this,
我的意思是，

1319
00:39:52,120 --> 00:39:53,180
0,180 180,780
is that,|
|

1320
00:39:54,500 --> 00:39:57,290
0,690 690,960 960,1500 1500,1860 1860,2790
{} a caller saved register
调用者保存寄存器可以被函数重写，

1321
00:39:57,350 --> 00:40:00,920
0,450 450,720 720,1800 1830,2640 2670,3570
can be overwritten by the

1322
00:40:00,950 --> 00:40:02,240
0,510 510,690 690,960 960,1140 1140,1290
function,| so let's say I
|比如我有函数 a 调用函数 b ，

1323
00:40:02,240 --> 00:40:03,650
0,150 150,510 510,840 840,1080 1080,1410
have function a which calls

1324
00:40:03,650 --> 00:40:05,900
0,390 390,720 1050,1470 1470,1980 1980,2250
function b,| any registers being
|函数 a 使用的任何寄存器都是调用者保存的。

1325
00:40:05,900 --> 00:40:07,310
0,420 420,570 570,1020 1020,1260 1260,1410
used by function a that

1326
00:40:07,310 --> 00:40:08,860
0,120 120,690 690,1380
are caller saved.|
|

1327
00:40:08,880 --> 00:40:10,680
0,540 540,750 750,1200 1200,1500 1500,1800
Call {} function b can
调用函数 b 可以在其被调用时覆盖，

1328
00:40:10,680 --> 00:40:12,240
0,600 600,780 780,840 840,1050 1050,1560
overwrite when it gets called,|
|

1329
00:40:12,420 --> 00:40:13,350
0,300 300,420 420,600 600,660 660,930
and I think a good
我想返回地址（Return address）就是一个很好的例子。

1330
00:40:13,350 --> 00:40:15,090
0,600 600,750 750,1170 1200,1620 1620,1740
illustration of this is the

1331
00:40:15,090 --> 00:40:16,340
0,360 360,990
return address.|
|

1332
00:40:16,320 --> 00:40:17,670
0,780 780,960 960,1080 1080,1230 1230,1350
Because you know you can
你可以看到返回地址是调用者保存的。

1333
00:40:17,670 --> 00:40:19,050
0,210 210,360 360,450 450,840 840,1380
see that the return addresses

1334
00:40:19,050 --> 00:40:20,300
0,420 420,1050
caller saved.|
|

1335
00:40:21,170 --> 00:40:23,150
0,330 330,540 540,1020 1020,1500 1530,1980
And that's important because every
这一点很重要，因为每个函数都需要使用返回地址，

1336
00:40:23,150 --> 00:40:24,860
0,690 690,1170 1170,1260 1260,1620 1620,1710
function needs to use the

1337
00:40:24,860 --> 00:40:26,900
0,270 270,780 870,1560 1590,1860 1860,2040
return address,| so when a
|因此，当 a 调用 b 时，能够覆盖返回地址中的值是很重要的，

1338
00:40:26,900 --> 00:40:28,460
0,360 360,690 690,900 900,1350 1350,1560
calls b it's important that

1339
00:40:28,460 --> 00:40:31,010
0,270 270,390 390,810 810,1350 1380,2550
be be able to overwrite

1340
00:40:31,040 --> 00:40:32,030
0,180 180,570 570,630 630,720 720,990
the value in the return

1341
00:40:32,030 --> 00:40:33,560
0,450 480,810 810,990 990,1170 1170,1530
address,| hence why its caller
|这就是为什么它是调用者保存的。

1342
00:40:33,560 --> 00:40:34,240
0,570
saved.|
|

1343
00:40:34,340 --> 00:40:36,830
0,330 330,780 780,1170 1170,2100 2130,2490
And callee saved registers {}
而被调用者保存寄存器只是我们使用的约定，

1344
00:40:36,830 --> 00:40:38,360
0,180 180,390 390,540 540,960 960,1530
are just {} are convention

1345
00:40:38,360 --> 00:40:40,370
0,150 150,300 300,1080 1260,1860 1860,2010
that we use,| {} the
|所以，帧指针（frame pointer, s0/fp）非常重要。

1346
00:40:40,370 --> 00:40:41,990
0,300 300,720 720,870 870,1470 1470,1620
frame pointer is important for

1347
00:40:41,990 --> 00:40:43,060
0,270 270,810
that reason.|
|

1348
00:40:43,030 --> 00:40:45,430
0,810 1110,1470 1470,1800 1800,2070 2070,2400
{} And those are preserved
这些寄存器在函数调用之间保留，

1349
00:40:45,430 --> 00:40:46,930
0,270 270,630 630,900 900,1080 1080,1500
across function calls,| so basically
|所以对于调用者保存寄存器，

1350
00:40:46,930 --> 00:40:48,250
0,180 180,600 600,720 720,810 810,1320
any register that is caller

1351
00:40:48,250 --> 00:40:49,810
0,600 750,990 990,1350 1350,1470 1470,1560
saved,| the function that is
|进行调用的函数需要考虑这些寄存器，

1352
00:40:49,810 --> 00:40:50,950
0,390 390,480 480,780 780,1020 1020,1140
making the call needs to

1353
00:40:50,950 --> 00:40:52,840
0,240 240,510 510,750 750,1440 1590,1890
worry about those registers,| and
|如果是被调用者保存的，

1354
00:40:52,840 --> 00:40:54,070
0,90 90,240 240,540 540,690 690,1230
if they're callee {} saved,|
|

1355
00:40:54,070 --> 00:40:55,150
0,120 120,480 480,570 570,720 720,1080
the function that is being
则被调用的函数需要考虑如何保存这些寄存器的值。

1356
00:40:55,150 --> 00:40:56,890
0,540 600,1020 1020,1140 1140,1410 1410,1740
called needs to worry about

1357
00:40:56,890 --> 00:40:58,240
0,480 480,540 540,960 960,1080 1080,1350
preserving the value in those

1358
00:40:58,240 --> 00:40:59,020
0,690
registers.|
|

1359
00:40:59,830 --> 00:41:01,210
0,210 210,540 540,600 600,900 990,1380
And again, you know I
你知道，我经常混淆这两个，

1360
00:41:01,210 --> 00:41:03,280
0,390 480,1140 1140,1560 1560,1680 1680,2070
I regularly confuse the two|
|

1361
00:41:03,280 --> 00:41:05,240
0,420 420,660 660,1110 1110,1680
and find myself returning
可以回到这张表，看看它们是怎么用的。

1362
00:41:05,230 --> 00:41:07,220
0,240 240,420 420,1080
to this table,

1363
00:41:07,590 --> 00:41:09,660
0,660 810,1320 1320,1680 1680,1890 1890,2070
to remind myself about what

1364
00:41:09,660 --> 00:41:12,560
0,120 120,540 1500,2130 2130,2610
they do.| And so,
|如果你记得读过的内容，

1365
00:41:12,670 --> 00:41:13,840
0,180 180,300 300,660 930,1080 1080,1170
You know you if you

1366
00:41:13,840 --> 00:41:15,190
0,270 270,420 420,510 510,1020 1050,1350
remember from the reading,| all
|所有这些寄存器都是 64 位的，

1367
00:41:15,190 --> 00:41:17,320
0,90 90,270 270,1050 1050,1410 1410,2130
of these registers are 64

1368
00:41:17,320 --> 00:41:18,760
0,420 420,960 960,1080 1080,1200 1200,1440
bits wide,| so they have
|所以，它们有 64 个位置可以放东西，

1369
00:41:18,760 --> 00:41:20,320
0,630 630,1020 1020,1230 1230,1380 1380,1560
64 places where we can

1370
00:41:20,320 --> 00:41:23,260
0,240 240,780 930,2040 2190,2460 2460,2940
put things| and the various
|基于调用约定，各种类型数据适用于 64 位，

1371
00:41:23,260 --> 00:41:24,730
0,300 300,780 780,900 900,1350 1350,1470
data types are made to

1372
00:41:24,730 --> 00:41:26,710
0,300 300,570 570,810 810,1440 1440,1980
fit into those 64 bits

1373
00:41:26,800 --> 00:41:28,660
0,810 810,930 930,1020 1020,1350 1350,1860
based on the calling convention,|
|

1374
00:41:28,660 --> 00:41:29,200
0,180 180,300 300,390 390,480 480,540
so if we have a
所以如果我们有一个 32 位整数，

1375
00:41:29,200 --> 00:41:31,180
0,420 420,540 540,1200 1290,1680 1680,1980
32 bit integer,| {} depending
|根据它是不是扩展的，

1376
00:41:31,180 --> 00:41:32,230
0,90 90,270 270,750 750,990 990,1050
on how it's whether or

1377
00:41:32,230 --> 00:41:33,940
0,180 180,330 330,510 510,1320 1380,1710
not it's an extended,| {you,know}
|我们可以在它前面添加 0 或 1 ，

1378
00:41:33,940 --> 00:41:34,930
0,150 150,360 360,540 540,900 900,990
will either add zeros or

1379
00:41:34,930 --> 00:41:36,040
0,510 510,720 720,810 810,1050 1050,1110
ones to the front of

1380
00:41:36,040 --> 00:41:37,330
0,180 180,450 450,780 810,1200 1200,1290
that integer,| {} {} in
|以便将其设置为 64 位放入这些寄存器。

1381
00:41:37,330 --> 00:41:38,290
0,180 180,240 240,390 390,450 450,960
order to make it 64

1382
00:41:38,290 --> 00:41:39,100
0,240 240,330 330,540 540,630 630,810
bits to put in these

1383
00:41:39,100 --> 00:41:39,920
0,660
registers.|
|

1384
00:41:40,480 --> 00:41:41,860
0,270 270,570 570,720 720,930 930,1380
So before we move on,|
在我们继续之前，|

1385
00:41:41,950 --> 00:41:43,720
0,390 390,540 540,900 900,1200 1200,1770
{} does anybody have questions
有没有关于寄存器或相关的问题。

1386
00:41:43,720 --> 00:41:46,760
0,600 750,1950 1950,2400 2400,2790
about registers or {}

1387
00:41:46,810 --> 00:41:48,240
0,540 540,630 630,780 780,1200
things of that nature.|
|

1388
00:41:52,940 --> 00:41:53,420
0,390

1389
00:41:55,140 --> 00:41:55,700
0,330

1390
00:41:56,000 --> 00:41:56,480
0,330

1391
00:41:57,950 --> 00:41:59,360
0,150 150,510 510,660 660,750 750,1410
{} I have a question,|
我有一个问题，|

1392
00:41:59,360 --> 00:42:01,400
0,240 240,750 780,1290 1290,1800 1890,2040
can you have a-, can
能把一个返回值放在 a1 中吗？

1393
00:42:01,400 --> 00:42:02,540
0,120 120,360 360,420 420,750 750,1140
you put a return value

1394
00:42:02,540 --> 00:42:04,080
0,270 270,510 510,1230
in {a1 -}.|
|

1395
00:42:04,790 --> 00:42:06,050
0,450 510,930 930,1050 1050,1110 1110,1260
{} Yes, that's a good
是的，这是个好问题。

1396
00:42:06,050 --> 00:42:08,750
0,450 450,1170 1650,2100 2130,2250 2250,2700
question.| So, {} I think
|我想理论上是可以的，

1397
00:42:08,750 --> 00:42:11,720
0,570 600,1770 1830,2340 2370,2610 2610,2970
{in,theory} you can,| the reason
|原因是，比如 a0 到 a1 是，

1398
00:42:11,720 --> 00:42:13,400
0,750 780,990 990,1260 1260,1380 1380,1680
why we say {a0 -}

1399
00:42:13,400 --> 00:42:15,080
0,180 180,210 210,870 1020,1560 1560,1680
to {a1 -} is| if
|如果函数返回 128 位的长整型，

1400
00:42:15,080 --> 00:42:16,250
0,90 90,450 450,780 780,840 840,1170
a function returns a long

1401
00:42:16,250 --> 00:42:18,770
0,510 690,1050 1050,1140 1230,2190 2190,2520
long which is 128 bits,|
|

1402
00:42:18,770 --> 00:42:20,210
0,420 420,630 630,780 780,1260 1260,1440
so if you remember from
如果你记得，如果一个函数参数是 100 ，超过一个指针字（pointer-word）长。

1403
00:42:20,210 --> 00:42:21,800
0,120 120,660 870,1170 1170,1260 1260,1590
the reading if a function

1404
00:42:21,800 --> 00:42:23,120
0,630 630,720 720,780 780,1170 1170,1320
argument is a hundred is

1405
00:42:23,120 --> 00:42:24,800
0,240 240,510 510,870 870,1440
more than a pointer-word.|
|

1406
00:42:24,880 --> 00:42:26,140
0,240 240,510 750,990 990,1080 1080,1260
We're {}, when we refer
当我们说字（word）时，是 64 位，

1407
00:42:26,140 --> 00:42:27,130
0,270 270,420 420,660 660,750 750,990
to word sign, we're saying

1408
00:42:27,130 --> 00:42:28,720
0,510 510,930 1080,1350 1350,1500 1500,1590
64 bits,| so if we
|所以如果我们有两倍于指针字大小的东西，

1409
00:42:28,720 --> 00:42:29,920
0,150 150,480 480,630 630,810 810,1200
have something that is twice

1410
00:42:29,920 --> 00:42:30,970
0,90 90,420 420,510 510,630 630,1050
the size of a {pointer-word

1411
00:42:30,970 --> 00:42:31,660
0,420
-},|
|

1412
00:42:32,350 --> 00:42:33,970
0,510 630,960 960,1140 1140,1350 1350,1620
{} we can put that
我们可以把它放入寄存器对中，

1413
00:42:33,970 --> 00:42:35,650
0,90 90,210 210,660 660,1200 1350,1680
in a register pair| and
|因此同样的约定也适用于返回地址，

1414
00:42:35,650 --> 00:42:37,420
0,630 690,840 840,1140 1140,1530 1530,1770
so the same convention holds

1415
00:42:37,420 --> 00:42:38,920
0,240 240,360 360,690 690,1170 1170,1500
true for return addresses| where
|如果我们有一个指针字两倍大小的东西，

1416
00:42:38,920 --> 00:42:40,090
0,150 150,240 240,420 420,780 780,1170
if we have something that's

1417
00:42:40,150 --> 00:42:41,680
0,210 210,570 570,780 780,1170 1200,1530
the size of {} twice

1418
00:42:41,680 --> 00:42:42,910
0,330 330,450 450,810 840,1080 1080,1230
{pointer-word - -},| we can
|可以把它放在 a0 和 a1 中，并作为返回地址。

1419
00:42:42,910 --> 00:42:43,900
0,240 240,360 360,480 480,630 630,990
stick that in {a0 -}

1420
00:42:43,900 --> 00:42:45,040
0,270 270,390 390,780 780,990 990,1140
and {a1 -} and use

1421
00:42:45,040 --> 00:42:46,240
0,150 150,300 300,420 420,720 720,1200
that as the return address,|
|

1422
00:42:46,330 --> 00:42:47,170
0,210 210,390 390,510 510,630 630,840
I think you'll run into
我想如果你只往 a1 里写入，可能会遇到问题。

1423
00:42:47,170 --> 00:42:48,280
0,390 390,480 480,690 690,960 960,1110
problems if you only try

1424
00:42:48,280 --> 00:42:48,970
0,90 90,240 240,510 510,600 600,690
to put something in {a1

1425
00:42:48,970 --> 00:42:49,520
0,300
-}.|
|

1426
00:42:49,880 --> 00:42:52,180
0,300 300,630 630,1170
Makes sense, thanks.|
理解了，谢谢。|

1427
00:42:55,040 --> 00:42:58,280
0,420 420,1110 1110,1290 1290,1950 2040,3240
{} Why are the registers
为什么寄存器不是连续的，

1428
00:42:58,280 --> 00:43:00,470
0,330 330,510 510,1230 1230,1710 1860,2190
not like continuous,| so why
|为什么 a0 和 a1 是分开的？

1429
00:43:00,470 --> 00:43:01,580
0,180 180,450 450,600 600,960 960,1110
is like {a0 -} and

1430
00:43:01,580 --> 00:43:04,080
0,600 780,1590 1590,2280
one separate from?|
|

1431
00:43:04,680 --> 00:43:06,030
0,330 330,450 450,720 720,1140 1140,1350
Sorry no that's a bad
抱歉，这不是一个好例子，

1432
00:43:06,030 --> 00:43:07,920
0,450 450,720 720,1020 1020,1620 1650,1890
example,| that's why is {s1
|为什么 s1 和 s2 是分开的，

1433
00:43:07,920 --> 00:43:09,960
0,480 480,960 960,1170 1170,1530 1530,2040
-} separate from s2,| why
|为什么 a 在它们中间，这有什么意义吗？

1434
00:43:09,960 --> 00:43:11,280
0,150 150,450 450,630 630,1080 1110,1320
the a in between like

1435
00:43:11,280 --> 00:43:12,210
0,120 120,360 360,570 570,840 840,930
is there any point in

1436
00:43:12,210 --> 00:43:12,860
0,330
that.|
|

1437
00:43:13,180 --> 00:43:14,860
0,210 210,570 600,1140 1200,1320 1320,1680
Yeah, so, {} I mentioned
是的，我之前提到，

1438
00:43:14,860 --> 00:43:16,300
0,150 150,540 540,1050 1050,1260 1260,1440
this briefly earlier,| but there
|这只是一个猜测，我不是很确定，

1439
00:43:16,300 --> 00:43:18,220
0,180 180,600 630,1470 1590,1830 1830,1920
is a compressed, this is

1440
00:43:18,220 --> 00:43:19,210
0,90 90,510 510,540 540,900 900,990
a guess I don't I

1441
00:43:19,210 --> 00:43:20,680
0,210 210,360 360,480 480,870 1020,1470
don't know for sure,| but
|有一个压缩版本的 RISC-V 指令，

1442
00:43:20,680 --> 00:43:22,870
0,240 240,330 330,900 900,1560 1560,2190
there's a compressed version of

1443
00:43:22,900 --> 00:43:25,690
0,300 300,600 600,1020 1020,1860 2100,2790
the {RISC-V -} instructions| which
|它的大小是 16 位，而不是 64 位。

1444
00:43:25,690 --> 00:43:27,010
0,180 180,600 600,810 810,930 930,1320
are 16 bits in size

1445
00:43:27,010 --> 00:43:28,720
0,150 150,570 570,660 660,1440
as opposed to 64.|
|

1446
00:43:28,920 --> 00:43:31,440
0,1110 1500,1920 1920,2070 2070,2280 2280,2520
And you would use that
你可以用它来使代码在内存中占用更少的空间，

1447
00:43:31,440 --> 00:43:32,700
0,60 60,540 570,930 960,1140 1140,1260
to try to make your

1448
00:43:32,700 --> 00:43:33,660
0,240 240,450 450,570 570,870 870,960
code takes less space in

1449
00:43:33,660 --> 00:43:35,910
0,510 750,1410 1530,1830 1830,1950 1950,2250
memory,| and when you use
|当你使用 16 位指令时，只能访问寄存器 8 到 15 位，

1450
00:43:35,910 --> 00:43:37,590
0,240 240,690 690,870 870,1500 1500,1680
those 16 bit instructions, you

1451
00:43:37,590 --> 00:43:40,050
0,330 330,750 750,1500 1500,1650 1650,2460
only have accesses to registers

1452
00:43:40,260 --> 00:43:42,480
0,360 360,720 720,1590 1740,2070 2070,2220
8 through 15,| so I
|所以我认为 s1 与 s2 到 s11 分开，

1453
00:43:42,480 --> 00:43:44,190
0,390 390,660 660,960 960,1110 1110,1710
think {s1 -} is separate

1454
00:43:44,190 --> 00:43:45,750
0,360 360,600 600,750 750,900 900,1560
from {s2 -} to eleven,|
|

1455
00:43:45,870 --> 00:43:47,370
0,720 720,1050 1050,1260 1260,1320 1320,1500
because they want to make
是因为他们想要明确，

1456
00:43:47,370 --> 00:43:48,660
0,90 90,420 420,600 600,750 750,1290
it clear,| that {s1 -}
|s1 在压缩指令模式下可用，而 s2 到 s11 则不可用。

1457
00:43:48,720 --> 00:43:50,190
0,270 270,840 840,990 990,1320 1320,1470
is available to you in

1458
00:43:50,190 --> 00:43:52,060
0,210 240,720 720,1230 1230,1680
the compressed instruction mode,

1459
00:43:52,070 --> 00:43:53,630
0,510 510,660 660,780 780,1110 1110,1560
whereas two to eleven aren't.|
|

1460
00:43:54,500 --> 00:43:56,450
0,690 960,1170 1170,1260 1260,1830 1830,1950
{} And the reason you
我不知道他们为什么选择 x ， x8 到 x15 ，

1461
00:43:56,450 --> 00:43:57,050
0,90 90,180 180,330 330,390 390,600
know I don't know why

1462
00:43:57,050 --> 00:43:58,180
0,120 120,480 480,1020
they picked x,

1463
00:43:58,440 --> 00:44:00,960
0,240 240,600 600,1680 1800,2280 2280,2520
{x8 -} {to,15},| but I
|但我相信，只要看一些代码，

1464
00:44:00,960 --> 00:44:02,490
0,510 510,750 750,1080 1080,1470 1470,1530
suspect that just looked at

1465
00:44:02,490 --> 00:44:03,180
0,30 30,240 240,300 300,600 600,690
a bunch of code| and
|就会发现这些是最常用的寄存器。

1466
00:44:03,180 --> 00:44:03,840
0,90 90,300 300,390 390,600 600,660
we're like {} these are

1467
00:44:03,840 --> 00:44:05,400
0,60 60,360 360,720 720,900 900,1560
the most commonly used registers.|
|

1468
00:44:09,620 --> 00:44:10,540
0,660

1469
00:44:17,140 --> 00:44:18,540
0,270 270,480 480,1170
Any other questions?|
还有其他问题吗？|

1470
00:44:20,840 --> 00:44:22,490
0,270 270,420 420,450 450,960 1050,1650
I had a question {}.|
我有一个问题。|

1471
00:44:23,630 --> 00:44:25,640
0,630 630,780 780,1230 1230,1890 1890,2010
Besides the frame pointer, the
除了帧指针、栈指针，

1472
00:44:25,640 --> 00:44:27,980
0,450 450,780 780,900 900,1320 1500,2340
stack pointer at all,| I
|我不知道为什么我们需要更多的被调用者保存寄存器。

1473
00:44:28,010 --> 00:44:29,090
0,360 360,480 480,720 720,870 870,1080
don't know why we would

1474
00:44:29,090 --> 00:44:32,120
0,360 360,720 720,1290 1470,2280 2280,3030
need more callee saved registers.|
|

1475
00:44:32,460 --> 00:44:33,870
0,450 450,600 600,750 750,1230 1230,1410
But we do have like
但我们确实有很多这样的寄存器。

1476
00:44:33,870 --> 00:44:34,840
0,90 90,390 390,480 480,720
a bunch of them.|
|

1477
00:44:35,420 --> 00:44:37,730
0,870 870,870 960,1350 1350,1650 1650,2310
Yeah, {} the {s1 -}
是的， s1 到 s11 只是为了，

1478
00:44:37,730 --> 00:44:39,740
0,600 600,1320 1320,1620 1620,1740 1740,2010
to elevens those are just

1479
00:44:39,740 --> 00:44:40,880
0,330 330,390 390,690 690,930 930,1140
for,| I believe use their
|我相信只是为了让编译器或程序员有使用它们的自由，

1480
00:44:40,880 --> 00:44:42,890
0,510 510,630 630,720 720,1440 1500,2010
freedom for the compiler or

1481
00:44:42,890 --> 00:44:44,960
0,90 90,630 630,780 780,1230 1470,2070
the programmer to use,| {}
|在某些情况下，你可能想要，

1482
00:44:45,170 --> 00:44:45,920
0,210 210,450 450,600 600,660 660,750
so there may be there

1483
00:44:45,920 --> 00:44:47,000
0,90 90,360 360,720 720,930 930,1080
are certain cases where you

1484
00:44:47,000 --> 00:44:48,560
0,390 600,810 810,990 990,1050 1050,1560
want,| you want to guarantee
|想要保证在函数之后仍然有一些东西存在

1485
00:44:48,560 --> 00:44:50,090
0,180 180,540 540,660 660,900 900,1530
that something is still around

1486
00:44:50,390 --> 00:44:52,790
0,510 540,1380 1530,1890 1890,2040 2040,2400
{} after after your function,|
|

1487
00:44:52,790 --> 00:44:55,250
0,600 630,1140 1140,1800 1800,2010 2010,2460
call the compiler can choose
可以调用编译器选择使用 s1 到 s11 来做。

1488
00:44:55,250 --> 00:44:57,020
0,150 150,600 600,840 840,1530 1560,1770
to use {s1 -} to

1489
00:44:57,020 --> 00:44:58,440
0,540 540,690 690,870 870,1200
eleven to do that.|
|

1490
00:44:58,760 --> 00:44:59,680
0,660
Um,
嗯，我现在没有一个具体的例子来说明，

1491
00:45:00,190 --> 00:45:01,870
0,180 180,450 450,660 660,1080 1380,1680
I don't have like on

1492
00:45:01,870 --> 00:45:03,340
0,300 300,360 360,900 900,1380 1380,1470
hand, a specific example of

1493
00:45:03,340 --> 00:45:05,320
0,210 210,450 450,1110 1230,1740 1740,1980
where that's useful,| but, {}
|但是，我肯定它会出现的，

1494
00:45:05,320 --> 00:45:06,640
0,360 360,600 600,690 690,930 930,1320
I'm sure it shows up,|
|

1495
00:45:07,330 --> 00:45:08,980
0,570 630,960 960,1050 1050,1410 1410,1650
where having a callee saved
具有被调用者保存值是很重要的。


1496
00:45:08,980 --> 00:45:10,220
0,360 360,450 450,960
value is important.|
|

1497
00:45:14,390 --> 00:45:15,890
0,210 210,360 360,420 420,900 900,1500
But these are basically basically
这些基本上是程序员或编译器选择使用 s1 到 s11 。

1498
00:45:15,890 --> 00:45:17,060
0,120 120,540 540,630 630,1080 1080,1170
a programmer or {compiler's -}

1499
00:45:17,060 --> 00:45:18,710
0,300 300,420 420,810 1020,1470 1470,1650
choice to use {s1 -}

1500
00:45:18,710 --> 00:45:19,500
0,90 90,510
to eleven.|
|

1501
00:45:21,040 --> 00:45:21,440
0,330

1502
00:45:22,420 --> 00:45:23,710
0,300 300,480 480,720 720,840 840,1290
I should note that these
我要提醒一下，这些浮点寄存器，浮点算数，

1503
00:45:23,710 --> 00:45:25,540
0,390 390,720 720,1230 1230,1410 1410,1830
floating point registers their floating

1504
00:45:25,540 --> 00:45:27,920
0,270 270,990 1260,1500 1500,1500
point, arithmetic, {} {}|
|

1505
00:45:28,480 --> 00:45:29,410
0,240 240,420 420,540 540,690 690,930
as far as I'm aware,
据我所知，你们在这节课上不会看到它们，

1506
00:45:29,410 --> 00:45:30,190
0,120 120,360 360,540 540,690 690,780
you won't see them in

1507
00:45:30,190 --> 00:45:32,140
0,180 180,900 1170,1470 1470,1710 1710,1950
this class,| {} and so
|所以不需要担心它们。

1508
00:45:32,140 --> 00:45:33,190
0,360 360,600 600,810 810,930 930,1050
you don't really need to

1509
00:45:33,190 --> 00:45:34,020
0,210 210,360 360,600
worry about them.|
|

1510
00:45:37,100 --> 00:45:37,500
0,270

1511
00:45:38,550 --> 00:45:40,290
0,570 750,1140 1140,1260 1260,1350 1350,1740
Okay, {} so we started
好的，我们开始讨论一下函数调用，

1512
00:45:40,290 --> 00:45:43,110
0,570 570,720 720,1050 1050,1530 1590,2820
talking a little bit about

1513
00:45:43,430 --> 00:45:46,910
0,390 390,810 810,1710 2010,2910 2940,3480
{} function calls,| and {}
|有了这些，我想开始讨论堆栈。

1514
00:45:47,210 --> 00:45:48,140
0,240 240,360 360,660 660,720 720,930
so with that I want

1515
00:45:48,140 --> 00:45:50,380
0,300 330,810 810,1080 1080,1980
to move us into

1516
00:45:50,610 --> 00:45:53,820
0,1020 1020,1410 1410,1530 1530,2100 2250,3210
discussion of the stack {}.|
|

1517
00:45:54,390 --> 00:45:56,000
0,270 270,510 510,1290
So this is
这就是我们要讨论的堆栈，

1518
00:45:56,600 --> 00:45:58,640
0,240 240,870 1020,1470 1470,1830 1830,2040
This is we're talking about

1519
00:45:58,640 --> 00:46:00,820
0,120 120,780 1200,1920
the stack,| and
|堆栈，就像你以前看到的那样，

1520
00:46:01,100 --> 00:46:02,660
0,150 150,720 720,960 960,1380 1380,1560
the stacked, {} if you've

1521
00:46:02,660 --> 00:46:05,180
0,270 270,570 600,1290 1290,1950 1980,2520
seen it like before,| the
|它之所以重要是因为，

1522
00:46:05,210 --> 00:46:06,590
0,690 690,870 870,960 960,1260 1260,1380
reason why the stack is

1523
00:46:06,590 --> 00:46:08,960
0,630 630,1140 1260,1470 1470,1860 1890,2370
important is| it's what keeps
|它使函数保持组织和正常运行，

1524
00:46:08,960 --> 00:46:10,820
0,240 240,1080
our functions

1525
00:46:11,200 --> 00:46:13,660
0,990 990,1350 1350,1830 1860,2310 2310,2460
organized and sane,| and it's
|它允许函数工作，允许函数返回，

1526
00:46:13,660 --> 00:46:15,220
0,150 150,840 870,1020 1020,1320 1320,1560
what allows {} what makes

1527
00:46:15,220 --> 00:46:17,560
0,420 420,900 1380,1590 1590,1770 1770,2340
functions work, it's what makes

1528
00:46:17,560 --> 00:46:19,480
0,480 480,930 930,1080 1080,1260 1260,1920
return work| and it's also
|这也是我们经常编写保存寄存器之类的代码。

1529
00:46:19,630 --> 00:46:21,340
0,750 750,1170 1170,1290 1290,1440 1440,1710
where often we will find

1530
00:46:21,340 --> 00:46:24,400
0,690 690,1290 1290,1680 1680,2520 2640,3060
ourselves saving our registers and

1531
00:46:24,400 --> 00:46:25,500
0,300 300,480 480,750
things like that.|
|

1532
00:46:26,330 --> 00:46:27,400
0,720
Um.|
嗯。|

1533
00:46:27,740 --> 00:46:28,240
0,360

1534
00:46:29,440 --> 00:46:30,400
0,720
So,
在这里，我给出了堆栈的一个非常简单的布局，

1535
00:46:31,720 --> 00:46:34,180
0,570 570,1020 1020,1590 1590,1890 1920,2460
here, I've given just a

1536
00:46:34,240 --> 00:46:38,020
0,450 450,1740 2370,3270 3270,3420 3420,3780
pretty simple layout of what

1537
00:46:38,020 --> 00:46:39,700
0,60 60,510 510,840 840,1290 1320,1680
the stack looks like,| and
|而且这里的每个框都是我们所说的栈帧。

1538
00:46:39,700 --> 00:46:41,980
0,120 120,510 510,660 660,1500 1530,2280
so each of these boxes

1539
00:46:41,980 --> 00:46:43,750
0,570 600,960 960,1140 1140,1260 1260,1770
here is what we refer

1540
00:46:43,750 --> 00:46:47,680
0,690 990,1890 1890,2370 2370,3300 3630,3930
to as a stack {}

1541
00:46:47,680 --> 00:46:48,360
0,420
frame.|
|

1542
00:46:49,070 --> 00:46:51,380
0,540 570,900 900,1500 1500,1650 1650,2310
And every time we get
每次我们得到栈帧，都是由函数调用生成的。

1543
00:46:52,070 --> 00:46:53,870
0,330 330,660 660,870 870,1470 1470,1800
{}, which are generated by

1544
00:46:53,870 --> 00:46:55,040
0,360 360,990
function calls.|
|

1545
00:46:59,890 --> 00:47:02,440
0,630 1530,1980 1980,2220 2220,2310 2310,2550
{} Every time we call
每次我们调用一个函数，

1546
00:47:02,440 --> 00:47:04,840
0,90 90,750 780,1170 1170,1920 1950,2400
a function| that function makes
|该函数都会为自己创建栈帧，

1547
00:47:04,840 --> 00:47:06,790
0,150 150,900 930,1260 1260,1530 1530,1950
for itself its own stack

1548
00:47:06,790 --> 00:47:09,790
0,570 720,1500 1500,1770 1770,2280 2280,3000
frame| and {} which it
|并通过移动栈指针来使用它，

1549
00:47:09,790 --> 00:47:11,650
0,390 390,900 900,1320 1320,1560 1560,1860
uses itself and does that

1550
00:47:11,650 --> 00:47:13,810
0,270 270,690 690,1380 1530,1800 1800,2160
by moving around the stack

1551
00:47:13,810 --> 00:47:15,670
0,540 720,1140 1140,1470 1470,1560 1560,1860
pointer,| so here's the stack
|这个是栈指针，

1552
00:47:15,670 --> 00:47:17,740
0,660 690,1110 1110,1320 1320,1620 1620,2070
pointer,| and this is {}
|记住这些是很重要的。

1553
00:47:17,740 --> 00:47:19,630
0,570 570,810 810,1170 1170,1260 1260,1890
it's very important to remember.|
|

1554
00:47:19,780 --> 00:47:21,120
0,390 390,1230
With stacks,
对于栈，我们从高地址开始，然后向下扩展到低地址，

1555
00:47:21,740 --> 00:47:24,500
0,270 270,1170 1200,1440 1440,1740 1740,2760
we start from high addresses

1556
00:47:24,830 --> 00:47:27,080
0,210 210,360 360,780 780,2070
and we grow downwards.

1557
00:47:27,210 --> 00:47:29,310
0,780 810,1290 1290,1860 1860,1980 1980,2100
Too low addresses,| so the
|所以栈总是向下扩展。

1558
00:47:29,310 --> 00:47:31,640
0,420 420,900 900,1380 1410,2160
stack grows down always.|
|

1559
00:47:31,860 --> 00:47:33,570
0,330 330,540 540,1050 1170,1560 1560,1710
{} And so you'll see
所以你会看到栈指针的运算通常是通过减法来完成的，

1560
00:47:33,570 --> 00:47:35,040
0,150 150,390 390,930 930,1140 1140,1470
that the arithmetic for stack

1561
00:47:35,040 --> 00:47:37,260
0,270 270,1140 1140,1530 1560,1980 1980,2220
{pointer -} is usually done

1562
00:47:37,260 --> 00:47:38,820
0,360 360,1110 1110,1320 1320,1500 1500,1560
via subtraction,| we want to
|我们要在汇编中创建一个新的栈帧，

1563
00:47:38,820 --> 00:47:39,960
0,270 270,300 300,510 510,840 840,1140
make a new stack frame

1564
00:47:40,330 --> 00:47:41,710
0,210 210,690 690,810 810,1110 1110,1380
in assemblies,| the stack grows
|栈就向下扩展。

1565
00:47:41,710 --> 00:47:42,920
0,720
downwards.|
|

1566
00:47:43,380 --> 00:47:45,150
0,240 240,630 630,1020 1020,1230 1230,1770
And stack frames for function
函数栈帧包含寄存器、局部变量，

1567
00:47:45,150 --> 00:47:48,780
0,810 990,1350 1350,2160 2160,2430 2430,3630
contain {I,see} registers local variables,|
|

1568
00:47:48,930 --> 00:47:50,760
0,540 540,960 960,1200 1200,1710 1710,1830
{} also like I was
就像我说的，

1569
00:47:50,760 --> 00:47:52,080
0,270 270,660 660,840 840,1080 1080,1320
saying,| if you run out
|如果参数寄存器用完了，额外的参数就会出现在栈上，

1570
00:47:52,080 --> 00:47:54,690
0,420 450,690 690,1170 1170,2070 2100,2610
of {} argument registers additional

1571
00:47:54,690 --> 00:47:55,680
0,480 480,570 570,750 750,870 870,990
arguments will show up on

1572
00:47:55,680 --> 00:47:56,940
0,90 90,510 690,870 870,960 960,1260
the stack,| and so not
|栈帧不一定是相同大小，

1573
00:47:56,940 --> 00:47:58,050
0,270 270,540 540,780 780,870 870,1110
as stack frames are not

1574
00:47:58,050 --> 00:47:59,460
0,180 180,240 240,510 510,1080 1200,1410
all the same size {},|
|

1575
00:47:59,460 --> 00:48:00,210
0,270 270,390 390,480 480,660 660,750
even though they are in
尽管在这张图中它们是相同的，但事实并非如此，

1576
00:48:00,210 --> 00:48:01,380
0,120 120,750 750,930 930,1080 1080,1170
this diagram, that's not the

1577
00:48:01,380 --> 00:48:03,090
0,600 630,1020 1020,1350 1350,1470 1470,1710
case,| different functions have different
|不同函数具有不同数量的局部变量，

1578
00:48:03,090 --> 00:48:05,340
0,300 300,630 630,930 930,1830 1830,2250
numbers of local variables| different
|不同的寄存器等，

1579
00:48:05,520 --> 00:48:07,410
0,780 1080,1440 1440,1590 1590,1710 1710,1890
registers so on and so

1580
00:48:07,410 --> 00:48:08,880
0,570 660,900 900,1020 1020,1260 1260,1470
forth,| and so stack frames
|因此栈帧具有不同的大小，

1581
00:48:08,880 --> 00:48:10,110
0,90 90,210 210,480 480,1020 1020,1230
will be different sizes.| But
|但是有两件事是可以确定的，

1582
00:48:10,110 --> 00:48:11,220
0,120 120,420 420,840 840,960 960,1110
the two things that you

1583
00:48:11,220 --> 00:48:12,800
0,120 120,660 660,990 990,1350
can definitely count on,|
|

1584
00:48:12,820 --> 00:48:14,380
0,300 300,390 390,990 990,1140 1140,1560
which are important is that
这很重要，返回地址总是在第一个，

1585
00:48:14,500 --> 00:48:15,970
0,390 390,570 570,930 930,1350 1350,1470
{} the return address will

1586
00:48:15,970 --> 00:48:17,260
0,270 270,570 570,720 720,840 900,1290
always be on the first

1587
00:48:17,260 --> 00:48:18,880
0,390 390,630 630,720 720,990 990,1620
thing| and the frame pointer,
|并且，帧指针，前一帧帧指针

1588
00:48:19,120 --> 00:48:20,560
0,270 270,360 360,810 810,1170 1170,1440
{} the previous frames frame

1589
00:48:20,560 --> 00:48:22,060
0,390 390,540 540,1050 1050,1380 1380,1500
pointer| is also going to
|也会出现在栈中可预测位置，

1590
00:48:22,060 --> 00:48:22,990
0,210 210,300 300,420 420,510 510,930
show up on the stack

1591
00:48:23,080 --> 00:48:25,570
0,360 360,420 420,930 930,1620 1890,2490
at a predictable location,| so
|两个重要的寄存器，这个是 sp ，

1592
00:48:25,600 --> 00:48:26,520
0,660

1593
00:48:26,690 --> 00:48:28,460
0,150 150,450 450,900 900,1380 1380,1770
the two important registers here

1594
00:48:28,460 --> 00:48:30,080
0,870 870,1230 1230,1350 1350,1470 1470,1620
{are,sp},| which you know as
|正如我们讨论的，这是栈的底部。

1595
00:48:30,080 --> 00:48:31,970
0,120 120,660 660,900 900,1350 1350,1890
we discussed is used for,

1596
00:48:32,000 --> 00:48:33,230
0,330 330,540 540,840 840,930 930,1230
{} this is the bottom

1597
00:48:33,230 --> 00:48:34,280
0,60 60,150 150,750
of the stack.|
|

1598
00:48:35,780 --> 00:48:37,520
0,480 480,660 690,1410 1410,1620 1620,1740
Or {} generally you know
或者说是栈所在的位置，

1599
00:48:37,520 --> 00:48:38,480
0,120 120,240 240,750 750,870 870,960
it's the location of the

1600
00:48:38,480 --> 00:48:40,550
0,510 720,1050 1050,1320 1320,1950 1950,2070
stack,| and then fp is
|fp 也是重要的寄存器，指向当前帧的顶部。

1601
00:48:40,550 --> 00:48:43,120
0,180 180,780 840,1740
are also important

1602
00:48:43,310 --> 00:48:45,050
0,660 660,840 840,1050 1050,1440 1440,1740
register and this points to

1603
00:48:45,050 --> 00:48:47,480
0,90 90,810 840,1440 1440,2250
the top of current

1604
00:48:48,760 --> 00:48:49,720
0,720
frame.|
|

1605
00:48:50,790 --> 00:48:52,410
0,210 210,420 420,480 480,990 990,1620
And this is important,| because
这一点很重要，|因为这意味着返回地址和前一 fp

1606
00:48:52,440 --> 00:48:53,730
0,390 390,660 660,780 780,900 900,1290
that means that the return

1607
00:48:53,730 --> 00:48:56,220
0,660 690,1170 1170,1260 1260,1770 1770,2490
address and the previous fp|
|

1608
00:48:56,250 --> 00:48:57,480
0,240 240,780 780,1020 1020,1170 1170,1230
will always be at a
将始终位于当前帧指针的固定位置。

1609
00:48:57,480 --> 00:49:00,930
0,570 600,1890 2070,2760 2760,2910 2910,3450
fixed location from the current

1610
00:49:00,930 --> 00:49:02,060
0,330 330,840
frame pointer.|
|

1611
00:49:02,400 --> 00:49:04,110
0,180 180,390 390,870 870,1380 1410,1710
So that means that if
这意味着如果我想找到返回地址，

1612
00:49:04,110 --> 00:49:05,040
0,90 90,300 300,420 420,780 780,930
I want to find my

1613
00:49:05,040 --> 00:49:06,210
0,300 300,750 750,900 900,990 990,1170
return address| or I want
|或者想找到上一帧，

1614
00:49:06,210 --> 00:49:07,650
0,90 90,360 360,450 450,870 870,1440
to find the previous frame,|
|

1615
00:49:07,890 --> 00:49:09,060
0,150 150,330 330,810 810,1080 1080,1170
I can always get to
我总是可以通过查看当前帧指针来获得这些值，

1616
00:49:09,060 --> 00:49:11,550
0,390 390,1170 1170,1590 1620,2130 2130,2490
those values by looking at

1617
00:49:11,550 --> 00:49:13,980
0,120 120,540 540,870 870,1380 2100,2430
the current frame pointer| and
|我们之所以存储前一个帧指针，

1618
00:49:13,980 --> 00:49:15,030
0,90 90,390 390,600 600,750 750,1050
the reason why we store

1619
00:49:15,030 --> 00:49:16,800
0,90 90,540 540,810 810,1500 1560,1770
the previous frame pointer is|
|

1620
00:49:16,800 --> 00:49:18,600
0,180 180,630 630,960 960,1470 1500,1800
to allow us to jump
是为了可以向后跳转，

1621
00:49:18,600 --> 00:49:19,800
0,300 300,450 450,630 630,810 810,1200
back,| so once this function
|一旦这个函数返回，我们可以把它移动到 fp ，

1622
00:49:19,800 --> 00:49:21,630
0,630 720,1020 1020,1200 1200,1530 1530,1830
returns we can move this

1623
00:49:21,630 --> 00:49:23,280
0,330 330,1050 1080,1350 1350,1560 1560,1650
into fp| and all of
|然后，

1624
00:49:23,280 --> 00:49:25,200
0,90 90,510 510,990 990,1560 1650,1920
a sudden| fp again will
|fp 从指向这个栈帧，到指向这个栈帧。

1625
00:49:25,200 --> 00:49:26,610
0,240 240,390 390,780 780,900 900,1410
go from pointing to this,

1626
00:49:26,610 --> 00:49:28,060
0,240 240,570 570,1170
this stack frame,

1627
00:49:28,110 --> 00:49:29,430
0,360 360,660 660,1020 1020,1110 1110,1320
to now pointing to this

1628
00:49:29,430 --> 00:49:31,140
0,300 300,660 1020,1290 1290,1500 1500,1710
stack frame.| So we use
|所以，我们使用帧指针来操作栈帧，

1629
00:49:31,140 --> 00:49:32,880
0,120 120,420 420,870 870,1080 1080,1740
the frame pointer to manipulate

1630
00:49:32,880 --> 00:49:34,470
0,210 210,570 570,1170 1170,1410 1410,1590
our stack frames| and make
|并确保始终指向函数对应的栈帧。

1631
00:49:34,470 --> 00:49:35,610
0,240 240,330 330,720 720,1020 1020,1140
sure we're always going to

1632
00:49:35,610 --> 00:49:39,510
0,360 360,1350 1680,2340 2460,2940 2970,3900
one corresponding to the correct

1633
00:49:39,510 --> 00:49:40,400
0,600
function.|
|

1634
00:49:41,040 --> 00:49:41,970
0,180 180,450 450,690 690,870 870,930
And that's that's kind of
这就是栈的工作方式，

1635
00:49:41,970 --> 00:49:43,500
0,150 150,480 960,1200 1200,1440 1440,1530
how things how things are

1636
00:49:43,500 --> 00:49:46,530
0,420 540,1590 1680,2190 2190,2580 2580,3030
done| and the these pieces
|栈的这部分是使用汇编语言实现的，

1637
00:49:46,530 --> 00:49:47,700
0,210 210,300 300,1050
of the stack

1638
00:49:47,920 --> 00:49:49,300
0,300 300,510 510,570 570,720 720,1380
{} need to be created

1639
00:49:49,300 --> 00:49:52,120
0,690 720,1530 1620,1860 1860,1980 1980,2820
by assembly| and so everything's
|你读到的调用约定文档中的所有内容，

1640
00:49:52,120 --> 00:49:54,070
0,360 360,450 450,630 630,1020 1020,1950
everything in that calling conventions

1641
00:49:54,100 --> 00:49:56,230
0,930 930,1080 1080,1320 1320,1530 1530,2130
document that you read about|
|

1642
00:49:56,260 --> 00:49:59,950
0,600 600,1350 1350,2280 2280,2970 3150,3690
that's all enforced by effectively
都是由编译器实施的，

1643
00:49:59,950 --> 00:50:01,090
0,180 180,300 300,900 900,1050 1050,1140
by the compiler,| so the
|编译器遵循调用约定，生成栈帧，

1644
00:50:01,090 --> 00:50:03,730
0,630 630,1290 1290,1830 1890,2160 2160,2640
compiler adheres to the calling

1645
00:50:03,730 --> 00:50:06,220
0,840 900,1380 1380,1680 1680,1920 1920,2490
convention and it's what generates

1646
00:50:06,220 --> 00:50:07,540
0,120 120,480 480,750 750,870 870,1320
the stack frame,| it generates
|生成汇编代码，保证栈帧正确，

1647
00:50:07,540 --> 00:50:09,310
0,120 120,600 600,1110 1170,1470 1470,1770
the assembly code that makes

1648
00:50:09,310 --> 00:50:10,900
0,150 150,480 480,840 840,1080 1080,1590
our stack frames look correct,|
|

1649
00:50:11,080 --> 00:50:13,000
0,390 390,1050 1170,1530 1530,1620 1620,1920
so often at the top
所以通常在函数的开头，你会看到所谓的函数序言。

1650
00:50:13,000 --> 00:50:14,170
0,120 120,240 240,780 780,960 960,1170
of a function, you'll see

1651
00:50:14,170 --> 00:50:16,940
0,270 270,840 1110,1560 1560,2520
what's called a function

1652
00:50:17,100 --> 00:50:18,760
0,510 570,1470
{} prologue.|
|

1653
00:50:21,300 --> 00:50:22,590
0,510 510,870 870,1020 1020,1170 1170,1290
And then there will be
然后是函数体，

1654
00:50:22,590 --> 00:50:24,180
0,120 120,450 450,570 570,660 660,1590
the body of the function|
|

1655
00:50:24,450 --> 00:50:25,710
0,180 180,360 360,480 480,690 690,1260
and then there will be
然后是一个函数尾声。

1656
00:50:26,110 --> 00:50:28,720
0,210 210,1230 1470,2100 2100,2430 2430,2610
an epilogue that shows up

1657
00:50:28,720 --> 00:50:30,040
0,300 300,690 750,1020 1020,1200 1200,1320
after that,| so this is
|这就是汇编函数通常看起来的样子，

1658
00:50:30,040 --> 00:50:31,180
0,300 300,450 450,900
kind of like,

1659
00:50:32,010 --> 00:50:34,620
0,360 360,780 810,1020 1020,1890
when {} an assembly

1660
00:50:35,230 --> 00:50:37,240
0,720 720,870 870,1200 1200,1440 1440,2010
function will often look like.|
|

1661
00:50:37,360 --> 00:50:38,350
0,360 360,480 480,690 690,750 750,990
And we'll take a look
我们现在来看一下，

1662
00:50:38,350 --> 00:50:41,560
0,570 750,1260 1380,1800 2550,3000 3000,3210
at,| {} now, so here
|这里我有另一个函数 sum_then_double ，

1663
00:50:41,560 --> 00:50:43,480
0,120 120,240 240,600 600,1200 1620,1920
I have another function {sum_then_double

1664
00:50:43,480 --> 00:50:45,370
0,180 180,450 450,1350 1350,1680 1680,1890
-},| so you'll note that
|注意， sum_to 没有这些东西，

1665
00:50:45,370 --> 00:50:46,630
0,330 330,720 720,840 840,990 990,1260
{[] - -} that {some_to

1666
00:50:46,630 --> 00:50:48,610
0,420 420,720 720,1260 1380,1890 1890,1980
-} not have any of

1667
00:50:48,610 --> 00:50:50,170
0,240 240,660 660,840 840,1230 1380,1560
these things| that it it
|一个真正的函数应该有的，

1668
00:50:50,170 --> 00:50:50,950
0,330 330,450 450,540 540,690 690,780
should if it was a

1669
00:50:50,950 --> 00:50:52,720
0,390 390,990 1110,1350 1350,1500 1500,1770
proper function| and this works
|它也是可用的，因为足够简单，

1670
00:50:52,720 --> 00:50:54,220
0,390 390,660 660,810 810,1140 1140,1500
fine because it's simple enough,|
|

1671
00:50:54,220 --> 00:50:55,090
0,240 240,360 360,570 570,780 780,870
so it does all of
它的所有计算都是在 a0 上进行的，

1672
00:50:55,090 --> 00:50:57,100
0,150 150,1050 1050,1410 1410,1560 1560,2010
its computations on {a0 -}|
|

1673
00:50:57,100 --> 00:50:58,220
0,150 150,270 270,510 510,780
and so things are,
所以是好的，我们把它称为叶子函数，

1674
00:50:58,200 --> 00:50:59,400
0,420 420,510 510,900 900,1080 1080,1200
things are good and we're

1675
00:50:59,400 --> 00:51:00,510
0,210 210,510 510,660 660,960 960,1110
also not it's a it's

1676
00:51:00,510 --> 00:51:02,070
0,90 90,300 300,870 1080,1560 1560,1560
a leaf function,| so, {}
|如果你看到叶子函数这个术语，

1677
00:51:02,460 --> 00:51:03,450
0,180 180,390 390,660 660,840 840,990
you'll see if you've seen

1678
00:51:03,450 --> 00:51:04,530
0,60 60,300 300,510 510,900 900,1080
the term leaf function| that's
|它是一个不调用另一个函数的函数，

1679
00:51:04,530 --> 00:51:05,580
0,60 60,390 390,510 510,840 840,1050
a function that doesn't call

1680
00:51:05,580 --> 00:51:07,860
0,330 330,930 1320,1650 1650,1800 1800,2280
another function,| and the functions
|这种函数的特殊之处是，

1681
00:51:07,860 --> 00:51:09,390
0,90 90,660 660,810 810,1050 1050,1530
are special in that| they
|它们不需要考虑保存自己的返回地址，

1682
00:51:09,630 --> 00:51:12,060
0,480 480,930 930,1470 1470,1920 1920,2430
don't need to worry about

1683
00:51:12,060 --> 00:51:14,310
0,750 750,1230 1350,1710 1710,1860 1860,2250
saving {} their own return

1684
00:51:14,310 --> 00:51:16,530
0,810 810,1200 1200,1680 1680,1980 1980,2220
address| or saving really any
|或者保存任何调用者保存寄存器。

1685
00:51:16,530 --> 00:51:18,360
0,90 90,180 180,600 600,990 990,1830
of the caller saved registers.|
|

1686
00:51:18,650 --> 00:51:21,680
0,1380 1650,1950 1950,2310 2310,2850 2880,3030
Because they're going to they're
因为它们不会进行另一个函数调用，

1687
00:51:21,680 --> 00:51:22,520
0,180 180,300 300,360 360,570 570,840
not going to make another

1688
00:51:22,520 --> 00:51:23,570
0,390 390,630 630,780 780,870 870,1050
function call,| so they don't
|所以它们不需要那么小心。

1689
00:51:23,570 --> 00:51:25,160
0,180 180,270 270,600 690,1080 1080,1590
have to be as careful,|
|

1690
00:51:25,400 --> 00:51:27,110
0,540 540,1050 1050,1320 1320,1440 1440,1710
{sum_then_double -} on the other
另一方面， some_then_double 不是叶子函数，

1691
00:51:27,110 --> 00:51:28,550
0,540 570,870 870,1170 1170,1230 1230,1440
hand is not a leaf

1692
00:51:28,550 --> 00:51:29,840
0,510 510,690 690,840 840,1020 1020,1290
function,| so you can see
|你可以在这里看到，它调用了 sum_to 。

1693
00:51:29,840 --> 00:51:32,180
0,480 480,600 600,1320 1470,2010 2010,2340
here, it calls {} {sum_to

1694
00:51:32,180 --> 00:51:32,980
0,540
-}.|
|

1695
00:51:33,530 --> 00:51:35,120
0,270 270,630 690,1050 1050,1350 1350,1590
And so it does need
所以它需要包含函数序言，

1696
00:51:35,120 --> 00:51:37,340
0,120 120,720 720,1140 1230,1680 1680,2220
to include that that prologue,|
|

1697
00:51:37,340 --> 00:51:38,360
0,120 120,240 240,390 390,660 660,1020
and so we see here
这里我们可以看到，从栈指针减去 16 ，

1698
00:51:38,360 --> 00:51:40,940
0,510 600,900 900,1020 1020,1770 1770,2580
that we are subtracting 16

1699
00:51:40,940 --> 00:51:42,770
0,450 450,570 570,930 930,1500 1530,1830
from the stack pointer,| so
|我们在栈上腾出空间，

1700
00:51:42,770 --> 00:51:44,270
0,180 180,540 540,1050 1050,1260 1260,1500
we're making space on our

1701
00:51:44,270 --> 00:51:46,640
0,510 720,1110 1110,1770 1770,1890 1890,2370
stack,| we're storing the return
|我们将 sum_then_double 的返回地址存储在栈中，

1702
00:51:46,640 --> 00:51:49,190
0,570 570,750 750,1350 1350,1950 2130,2550
address for {some_then_double -} on

1703
00:51:49,190 --> 00:51:50,660
0,90 90,660 780,1080 1080,1350 1350,1470
the stack,| and then we
|然后调用 sum_to ，

1704
00:51:50,660 --> 00:51:51,710
0,270 270,390 390,690 690,780 780,1050
make our call to {sum_to

1705
00:51:51,710 --> 00:51:53,180
0,390 630,870 870,1110 1110,1350 1350,1470
-},| and after that all
|在此之后，函数所做的全部工作就是调用 sum_to 。

1706
00:51:53,180 --> 00:51:54,350
0,420 420,750 750,990 990,1080 1080,1170
this function does is it

1707
00:51:54,350 --> 00:51:55,670
0,270 270,510 510,870 870,1020 1020,1320
calls {sum_to -}| and then
|然后将 sum_to 返回的结果加倍，

1708
00:51:55,670 --> 00:51:58,060
0,450 450,540 540,1200 1350,2130
doubles the result, {}

1709
00:51:58,080 --> 00:51:59,700
0,480 480,570 570,1020 1020,1410 1410,1620
doubles the result turn by

1710
00:51:59,700 --> 00:52:01,320
0,300 300,720 900,1200 1200,1470 1470,1620
{sum_to -},| and here you
|这里你可以看到函数尾声，

1711
00:52:01,320 --> 00:52:03,210
0,150 150,600 600,1080 1110,1740 1740,1890
can see the epilogue,| so
|我们将返回地址加载回 ra ，

1712
00:52:03,210 --> 00:52:04,240
0,150 150,810
we load

1713
00:52:04,820 --> 00:52:06,620
0,330 330,660 660,1080 1080,1440 1440,1800
the return address back in

1714
00:52:06,680 --> 00:52:09,020
0,360 360,660 660,1290 1380,1950 1950,2340
to {ra -}| and {}
|并删除栈帧，然后跳出函数。

1715
00:52:09,020 --> 00:52:10,520
0,420 420,660 660,960 960,1410 1410,1500
delete our stack frame and

1716
00:52:10,520 --> 00:52:11,870
0,240 240,810 900,1140 1140,1230 1230,1350
then jump out of the

1717
00:52:11,870 --> 00:52:12,640
0,540
function.|
|

1718
00:52:12,670 --> 00:52:13,320
0,450

1719
00:52:13,850 --> 00:52:14,720
0,180 180,330 330,480 480,630 630,870
And so we can run
我们可以运行它来确保达到预期的效果。

1720
00:52:14,720 --> 00:52:16,250
0,420 780,1080 1080,1260 1260,1440 1440,1530
that to make sure it

1721
00:52:16,250 --> 00:52:17,690
0,210 210,360 360,540 540,660 660,1440
does what we would expect.|
|

1722
00:52:18,890 --> 00:52:19,580
0,60

1723
00:52:20,870 --> 00:52:22,620
0,270 270,1140
Go here.|
在这里。|

1724
00:52:24,160 --> 00:52:26,110
0,930 1140,1440 1440,1680 1680,1860 1860,1950
We {can,run}, so if we
我们可以运行，如果我们运行 demo1 ，

1725
00:52:26,110 --> 00:52:27,910
0,210 210,540 540,1170 1200,1530 1530,1800
run {demo2 -} or demo1|
|

1726
00:52:27,910 --> 00:52:28,660
0,120 120,270 270,330 330,660 660,750
we got the result of
我们得到了总和为 15 的结果，

1727
00:52:28,660 --> 00:52:30,400
0,810 840,1170 1170,1230 1230,1620 1620,1740
fifteen for the sum,| and
|我会演示 demo2 ，调用 sum_then_double ，

1728
00:52:30,400 --> 00:52:31,210
0,120 120,300 300,390 390,510 510,810
I'll tell you that {demo2

1729
00:52:31,210 --> 00:52:32,890
0,360 360,720 720,1080 1170,1500 1500,1680
-} just, {} just call

1730
00:52:32,890 --> 00:52:34,840
0,420 420,840 840,990 990,1620 1680,1950
{some_then_double -}| and indeed you
|它就是把 sum_to 返回的结果加倍。

1731
00:52:34,840 --> 00:52:37,360
0,120 120,240 240,930 960,1860 1860,2520
know it happily doubles the

1732
00:52:37,570 --> 00:52:39,580
0,510 510,1050 1050,1200 1200,1500 1500,2010
sum returned by {sum_to -}.|
|

1733
00:52:40,600 --> 00:52:42,550
0,360 630,1110 1110,1470 1470,1830 1830,1950
And so a question I
所以我有一个问题，

1734
00:52:42,550 --> 00:52:46,240
0,360 360,840 840,1590 2460,3090 3090,3690
have for anybody| what happens
|如果我们删除这个函数序言和函数尾声，会发生什么，

1735
00:52:46,240 --> 00:52:49,840
0,330 330,990 1020,1950 2070,2610 2610,3600
if we delete this prologue

1736
00:52:50,200 --> 00:52:52,540
0,390 390,930 1050,1440 1440,2070 2070,2340
and epilogue,| what happens if
|如果我们在 sum_then_double 这样操作，会发生什么。

1737
00:52:52,540 --> 00:52:54,370
0,180 180,450 450,690 690,1260 1470,1830
we just have this as

1738
00:52:54,370 --> 00:52:56,020
0,150 150,720 720,1200 1200,1530 1530,1650
our function, {sum_then_double -}.| Can
|有人能预测会发生什么吗？

1739
00:52:56,020 --> 00:52:57,010
0,270 270,660 660,810 810,930 930,990
anybody predict what's going to

1740
00:52:57,010 --> 00:52:57,700
0,450
happen.|
|

1741
00:53:01,590 --> 00:53:02,550
0,150 150,360 360,570 570,810 810,960
I mean one thing is
我的意思是， sum_then_double 不知道它应该返回的返回地址，

1742
00:53:02,550 --> 00:53:04,650
0,210 210,450 450,1080 1080,1410 1410,2100
that {sum_then_double -} wouldn't know

1743
00:53:05,110 --> 00:53:06,580
0,330 330,630 630,1020 1020,1230 1260,1470
the return address that it

1744
00:53:06,580 --> 00:53:08,500
0,270 270,720 720,1140 1350,1560 1560,1920
should return to,| so upon
|因此，在调用 sum_to 时，将覆盖 sum_then_double 的返回地址，

1745
00:53:08,500 --> 00:53:10,680
0,570 570,990 990,1650
calling {sum_to -},

1746
00:53:10,870 --> 00:53:12,040
0,300 300,480 480,600 600,1080 1080,1170
that's going to override the

1747
00:53:12,040 --> 00:53:13,720
0,390 390,900 900,1050 1050,1260 1260,1680
return address to be {sum_then_double's

1748
00:53:13,720 --> 00:53:14,830
0,450 450,570 570,660 660,870 870,1110
-},| at the end of
|在 sum_then_double 的末尾，它不会返回到最初的调用者。

1749
00:53:15,500 --> 00:53:16,940
0,240 240,840 900,1110 1110,1260 1260,1440
{sum_then_double -}, it's not going

1750
00:53:16,940 --> 00:53:18,020
0,90 90,420 420,540 540,780 780,1080
to return to its original

1751
00:53:18,020 --> 00:53:18,500
0,240
caller.|
|

1752
00:53:19,330 --> 00:53:21,280
0,450 450,1050 1140,1680 1680,1770 1770,1950
Yeah exactly and we can
是的，没错。我们可以看看发生了什么。

1753
00:53:21,280 --> 00:53:23,620
0,540 750,1110 1110,1380 1380,1560 1560,2340
see that that's what happens.|
|

1754
00:53:23,650 --> 00:53:27,460
0,1020 1890,2370 2370,2790 2790,3240 3330,3810
Again, so if we exit
我们退出这个，退出这个，

1755
00:53:27,460 --> 00:53:29,440
0,150 150,270 270,1170 1200,1650 1650,1980
out of this and exit

1756
00:53:29,440 --> 00:53:31,510
0,120 120,180 180,960 1740,1890 1890,2070
out of this| and we
|我们现在用损坏的函数重新编译。

1757
00:53:31,510 --> 00:53:33,070
0,150 150,870 870,1140 1140,1440 1440,1560
{re-compile -} with now with

1758
00:53:33,070 --> 00:53:35,340
0,180 180,600 600,1290
our broken function.|
|

1759
00:53:35,650 --> 00:53:36,580
0,180 180,360 360,600 600,660 660,930
We can take a look
我们可以看看到底会发生什么，

1760
00:53:36,580 --> 00:53:37,810
0,90 90,510 510,690 690,900 900,1230
at exactly what's gonna happen,|
|

1761
00:53:37,810 --> 00:53:39,640
0,210 210,360 360,750 750,1320 1500,1830
so we can actually set
我们可以在 sum_then_double 设置中断，

1762
00:53:39,640 --> 00:53:40,990
0,150 150,420 420,840 840,960 960,1350
our break point for {sum_then_double

1763
00:53:40,990 --> 00:53:42,500
0,660
-}.|
|

1764
00:53:42,830 --> 00:53:43,760
0,570

1765
00:53:45,290 --> 00:53:47,930
0,660 690,1020 1020,1410 1440,1740 1740,2640
And set up {tui -}
设置 tui 并让它继续运行，

1766
00:53:48,260 --> 00:53:49,400
0,240 240,390 390,480 480,990 990,1140
and let it continue,| so
|现在我们运行 demo2 ，

1767
00:53:49,400 --> 00:53:50,870
0,150 150,420 420,720 720,1080 1080,1470
we now run {demo2 -},|
|

1768
00:53:50,870 --> 00:53:52,760
0,390 390,540 540,750 750,1230 1230,1890
okay we're at {sum_then_double -}.|
好的，我们在 sum_then_double 。|

1769
00:53:53,280 --> 00:53:55,080
0,750 930,1380 1380,1530 1530,1710 1710,1800
And again, this is an
同样的，这里只有一个汇编函数，

1770
00:53:55,080 --> 00:53:57,180
0,480 480,750 750,1290 1290,1770 1800,2100
assembly only function,| so we're
|所以我们在汇编中查看它，

1771
00:53:57,180 --> 00:53:57,810
0,120 120,180 180,360 360,420 420,630
going to want to look

1772
00:53:57,810 --> 00:53:59,970
0,180 180,360 390,810 840,1680 1800,2160
at it in assembly,| so
|我们输入 layout asm ， layout reg ，

1773
00:53:59,970 --> 00:54:03,060
0,540 540,1170 1170,1500 1500,2400 2640,3090
we'll do {layout,asm} layout reg,|
|

1774
00:54:03,060 --> 00:54:04,350
0,210 210,390 390,960 960,1170 1170,1290
because it's important what's in
因为这种情况下，寄存器的内容也很重要。

1775
00:54:04,350 --> 00:54:05,670
0,90 90,600 600,690 690,840 840,1320
the registers in this case.|
|

1776
00:54:06,620 --> 00:54:07,400
0,210 210,360 360,510 510,690 690,780
And you'll see that {gdb
你将看到 gdb 中有很多信息，

1777
00:54:07,400 --> 00:54:08,570
0,420 420,660 660,720 720,900 900,1170
-} knows a whole bunch

1778
00:54:08,570 --> 00:54:10,550
0,60 60,390 390,1110 1320,1740 1740,1980
of extra information| and so
|我们可以看到，

1779
00:54:10,550 --> 00:54:12,000
0,120 120,300 300,600 600,1020
we can see that,

1780
00:54:13,770 --> 00:54:15,420
0,720 960,1170 1170,1290 1290,1440 1440,1650
{} you can see that,|
|

1781
00:54:15,420 --> 00:54:16,800
0,90 90,510 510,1140 1140,1260 1260,1380
ra {currently -}, so the
ra 当前，返回地址指向 demo2 加 18 ，

1782
00:54:16,800 --> 00:54:18,360
0,330 330,600 600,1080 1080,1440 1440,1560
return address, currently points to

1783
00:54:18,360 --> 00:54:21,000
0,390 390,1050 1080,1590 1620,1920 1920,2640
{demo2 -} the plus eighteen,|
|

1784
00:54:21,060 --> 00:54:22,140
0,600
so,
这表示进入函数 demo2 。

1785
00:54:22,580 --> 00:54:23,870
0,180 180,480 480,930 930,1170 1170,1290
it points effectively into the

1786
00:54:23,870 --> 00:54:25,280
0,450 450,780 780,1140
function {demo2 -}.|
|

1787
00:54:26,180 --> 00:54:28,130
0,210 210,720 780,1110 1110,1290 1290,1950
And now we can run,|
现在我们可以运行，|

1788
00:54:28,160 --> 00:54:29,780
0,630 960,1140 1140,1260 1260,1470 1470,1620
{} we can just kind
我们可以单步检查函数，看看会发生什么。

1789
00:54:29,780 --> 00:54:30,950
0,60 60,360 360,570 570,720 720,1170
of step through our function

1790
00:54:30,950 --> 00:54:32,720
0,180 180,510 510,780 780,1260
and see what happens.|
|

1791
00:54:32,900 --> 00:54:35,660
0,720 1050,1500 1500,1860 1860,2130 2130,2760
{} We've called {sum_to -}|
我们调用了 sum_to ，|

1792
00:54:35,690 --> 00:54:37,190
0,360 360,930 930,1080 1080,1230 1230,1500
and immediately we can see
可以看到返回地址被 sum_to 覆盖，

1793
00:54:37,190 --> 00:54:39,320
0,150 150,240 240,600 600,1320 1350,2130
that the return address was

1794
00:54:39,320 --> 00:54:41,000
0,630 630,870 870,1200 1200,1560 1560,1680
overwritten by {sum_to -},| to
|现在指向 sum_then_double 加 4 ，

1795
00:54:41,000 --> 00:54:42,500
0,240 240,600 600,810 810,1050 1050,1500
now point to {sum_then_double -}

1796
00:54:42,500 --> 00:54:44,210
0,270 270,660 810,1200 1200,1410 1410,1710
plus four,| which makes sense,
|这是对的，就是我们期望的。

1797
00:54:44,210 --> 00:54:44,900
0,90 90,180 180,390 390,510 510,690
you know that's what we

1798
00:54:44,900 --> 00:54:46,340
0,510 600,960 960,1050 1050,1170 1170,1440
expect,| if we go back
|如果返回我们的代码，

1799
00:54:46,340 --> 00:54:47,480
0,240 240,360 360,720 720,810 810,1140
into our code,| we call
|调用 sum_to ， sum_to 应该返回到这里。

1800
00:54:47,480 --> 00:54:48,950
0,300 300,780 840,1110 1110,1230 1230,1470
{sum_to -} and so {sum_to

1801
00:54:48,950 --> 00:54:50,900
0,240 240,480 480,1050 1230,1620 1620,1950
-} should return to {}

1802
00:54:50,930 --> 00:54:52,340
0,480
here.|
|

1803
00:54:52,750 --> 00:54:54,460
0,150 150,660 690,1050 1050,1320 1320,1710
And now we can step
现在我们可以单步，

1804
00:54:54,460 --> 00:54:57,310
0,750 1170,1650 1650,1920 1920,2280 2280,2850
through you know so on

1805
00:54:57,370 --> 00:54:59,080
0,450 480,1470
up| and
|然后我们再回到。

1806
00:54:59,280 --> 00:55:01,020
0,270 270,390 390,570 570,960 960,1740
then we get back into.|
|

1807
00:55:03,550 --> 00:55:04,940
0,390
Oops,
糟糕，出错了。

1808
00:55:05,410 --> 00:55:09,120
0,540 840,1350 1350,1980
the wrong s.|
|

1809
00:55:14,490 --> 00:55:15,720
0,300 300,480 480,750 750,870 870,1230
Okay, so now we're here|
好的，我们现在在这里，|

1810
00:55:15,720 --> 00:55:17,040
0,90 90,330 330,510 510,960 960,1320
and now when {sum_then_double -}
当 sum_then_double 返回时，就像 Amir 说的，

1811
00:55:17,040 --> 00:55:19,260
0,600 1050,1320 1320,1800 1800,1950 1950,2220
returns as exactly as Amir

1812
00:55:19,260 --> 00:55:21,840
0,330 330,690 1560,1890 1890,2400 2400,2580
pointed out| its return, it
|它没有恢复自己的返回地址，

1813
00:55:21,840 --> 00:55:23,130
0,210 210,450 450,930 930,1050 1050,1290
has not restored its own

1814
00:55:23,130 --> 00:55:25,260
0,360 360,960 1080,1380 1380,1890 1890,2130
return address| and instead its
|而是它的返回地址仍然是 sum_to 使用的，

1815
00:55:25,260 --> 00:55:26,220
0,270 270,570 570,660 660,900 900,960
return address is still the

1816
00:55:26,220 --> 00:55:27,750
0,240 240,390 390,570 570,1020 1020,1530
one that was used by

1817
00:55:27,990 --> 00:55:28,880
0,540

1818
00:55:29,230 --> 00:55:31,090
0,510 510,1020 1080,1410 1410,1680 1680,1860
{sum_to -},| and so we
|所以我们会进入一个无限循环，

1819
00:55:31,090 --> 00:55:33,100
0,390 420,960 960,1470 1470,1590 1590,2010
will get into an infinite

1820
00:55:33,100 --> 00:55:35,350
0,540 570,840 840,990 990,1620 1650,2250
loop| where we just keep
|一遍又一遍地重复这个过程，

1821
00:55:35,350 --> 00:55:36,940
0,480 480,900 900,1290 1290,1380 1380,1590
doing this over and over

1822
00:55:36,940 --> 00:55:38,200
0,120 120,330 330,780 990,1170 1170,1260
and over again| and we'll
|永远不会结束。

1823
00:55:38,200 --> 00:55:39,840
0,240 240,780 780,960 960,1170
never terminate from it.|
|

1824
00:55:39,900 --> 00:55:41,010
0,180 180,300 300,540 540,690 690,1110
And so this is I
我想这很好地说明了，

1825
00:55:41,220 --> 00:55:42,150
0,510 510,630 630,690 690,780 780,930
think this is a good

1826
00:55:42,150 --> 00:55:43,890
0,660 660,810 810,1050 1050,1260 1260,1740
illustration of| why it's important
|为什么跟踪调用者保存和被调用者保存寄存器很重要，

1827
00:55:43,890 --> 00:55:44,910
0,120 120,390 390,720 720,810 810,1020
to keep track of our

1828
00:55:44,910 --> 00:55:47,520
0,540 540,960 960,1380 1380,1770 1770,2610
caller versus callee saved registers|
|

1829
00:55:47,730 --> 00:55:49,020
0,240 240,570 570,720 720,990 990,1290
and hopefully this also shows|
这也展示了|

1830
00:55:49,020 --> 00:55:50,790
0,90 90,240 240,540 1050,1560 1560,1770
that you can use kind
可以使用 gdb 来调试这类问题，

1831
00:55:50,790 --> 00:55:52,590
0,90 90,600 600,960 960,1230 1230,1800
of gdb to {debug -}

1832
00:55:53,000 --> 00:55:54,680
0,300 300,600 600,1050 1200,1470 1470,1680
these sorts of these sorts

1833
00:55:54,680 --> 00:55:56,450
0,90 90,510 510,630 630,1050 1110,1770
of problems,| so let's restore
|让我们恢复之前的代码。

1834
00:55:56,450 --> 00:55:57,600
0,120 120,210 210,870
what we had.|
|

1835
00:55:58,190 --> 00:55:59,900
0,330 330,510 510,810 810,1410 1410,1710
I will go into some
我将使用其他一些演示代码来讲解。

1836
00:55:59,900 --> 00:56:02,540
0,270 270,990 1260,1890 1890,2220 2220,2640
other demos to talk about

1837
00:56:04,370 --> 00:56:06,800
0,150 150,840 870,1320 1410,2010 2010,2430
to illustrate {}.| Somebody ask
|有人问，我们为什么要减去 16 ？

1838
00:56:06,800 --> 00:56:08,750
0,240 240,570 570,780 780,1290 1290,1950
why are we subtracting 16.|
|

1839
00:56:08,780 --> 00:56:10,640
0,510 510,900 900,1140 1140,1560 1560,1860
That's to put space to
这是为了给栈帧腾出空间，

1840
00:56:10,670 --> 00:56:12,860
0,270 270,390 390,660 660,990 1260,2190
get our stack frame,| so
|所以从栈指针中减去 16 ,

1841
00:56:12,920 --> 00:56:14,960
0,510 510,750 750,1380 1380,1830 1830,2040
this is subtracting 16 from

1842
00:56:14,960 --> 00:56:16,310
0,90 90,450 450,1020 1050,1230 1230,1350
the stack pointer,| so it's
|它在内存中向下移动。

1843
00:56:16,310 --> 00:56:17,510
0,300 300,390 390,720 720,1140 1140,1200
moving it down basically in

1844
00:56:17,510 --> 00:56:18,380
0,570
memory.|
|

1845
00:56:18,520 --> 00:56:20,560
0,720 1050,1560 1560,1650 1650,1950 1950,2040
{} Moving it down so
将其向下移动，以便我们有空间容纳自己的栈帧，

1846
00:56:20,560 --> 00:56:21,550
0,180 180,240 240,420 420,600 600,990
that we now have space

1847
00:56:21,550 --> 00:56:22,660
0,150 150,270 270,480 480,750 750,1110
for our own stack frame,|
|

1848
00:56:22,660 --> 00:56:23,560
0,120 120,210 210,360 360,630 630,900
then we can stick stuff
然后我们就可以把东西放在那里。

1849
00:56:23,560 --> 00:56:24,200
0,270
there.|
|

1850
00:56:24,360 --> 00:56:25,920
0,180 180,480 480,480 480,1350 1350,1560
So because {} at this
因为这时候，我们不想覆盖栈指针上的东西，

1851
00:56:25,920 --> 00:56:27,090
0,240 240,300 300,780 780,1080 1080,1170
point, in fact that we

1852
00:56:27,090 --> 00:56:28,230
0,210 210,330 330,390 390,870 870,1140
don't want to override what's

1853
00:56:28,230 --> 00:56:30,300
0,180 180,270 270,570 570,1050 1500,2070
at the stack pointer,| {}
|

1854
00:56:30,300 --> 00:56:31,980
0,330 330,600 600,1080 1140,1380 1380,1680
why not 4 I is
为什么不是 4 ，

1855
00:56:31,980 --> 00:56:33,480
0,480 510,1020
just {}

1856
00:56:33,790 --> 00:56:35,540
0,300 300,1560
well 4,|
|

1857
00:56:36,890 --> 00:56:38,180
0,180 180,330 330,390 390,570 570,1290
we need to do 16
我们需要 16 ，因为指令是 64 位。

1858
00:56:38,180 --> 00:56:41,300
0,360 360,870 870,1170 1170,2370
because instructions are 64.|
|

1859
00:56:42,560 --> 00:56:44,780
0,630 1620,1770 1770,1920 1920,2130 2130,2220
{} Yeah I guess I
是的，我想实际上不一定需要 16 ，

1860
00:56:44,780 --> 00:56:46,430
0,150 150,270 270,720 810,1200 1230,1650
guess we wouldn't don't actually

1861
00:56:46,430 --> 00:56:48,560
0,510 510,600 600,780 780,1620 1680,2130
need to do 16,| but
|但通常你会看到，

1862
00:56:48,560 --> 00:56:50,300
0,240 240,840 840,1140 1140,1320 1320,1740
that's generally what you'll see

1863
00:56:51,060 --> 00:56:52,830
0,570 630,1170 1170,1560 1560,1680 1680,1770
{} generally just see,| I
|我想不能使用 4 ，因为需要 8 ，

1864
00:56:52,830 --> 00:56:54,900
0,210 210,360 360,1170 1350,1860 1860,2070
don't think yeah you, you

1865
00:56:54,900 --> 00:56:56,130
0,330 330,450 450,690 690,840 840,1230
can't you can't do 4

1866
00:56:56,130 --> 00:56:57,920
0,780 810,930 930,1140 1140,1620
because you need 8.|
|

1867
00:56:58,070 --> 00:56:59,030
0,330 330,570 570,780 780,900 900,960
{So,4} doesn't work, but I
不能使用 4 ，但我想你可以使用指令大小，

1868
00:56:59,030 --> 00:57:01,910
0,150 150,240 240,330 330,960 2190,2880
think you could do the

1869
00:57:01,910 --> 00:57:03,100
0,480 480,1020
instruction size,|
|

1870
00:57:03,320 --> 00:57:03,980
0,150 150,240 240,510 510,570 570,660
and the size of the
而寄存器大小是 64 位，

1871
00:57:03,980 --> 00:57:06,590
0,720 720,1110 1110,1200 1200,1980 2280,2610
register registers are 64,| yeah,
|那么为什么通常看到 16 是因为，

1872
00:57:06,590 --> 00:57:07,760
0,150 150,300 300,480 480,630 630,1170
and then so the convention

1873
00:57:07,760 --> 00:57:09,290
0,240 240,390 390,720 720,960 960,1530
why you usually see 16

1874
00:57:09,290 --> 00:57:10,250
0,120 120,330 330,420 420,630 720,960
is because| if we jump
|如果我们回到文档，通常有返回地址和帧指针，

1875
00:57:10,250 --> 00:57:11,870
0,240 240,330 330,420 420,1050 1140,1620
back to our document, usually

1876
00:57:11,870 --> 00:57:13,160
0,240 240,420 420,480 480,780 780,1290
we have the return address

1877
00:57:13,160 --> 00:57:15,140
0,270 270,480 480,750 750,1200 1440,1980
and the frame pointer {},|
|

1878
00:57:15,140 --> 00:57:16,190
0,210 210,360 360,570 570,780 780,1050
we're not doing that here
我们在这里不这样做，因为不是非常小心地处理我们的汇编。

1879
00:57:16,190 --> 00:57:17,060
0,630
because

1880
00:57:17,460 --> 00:57:18,560
0,180 180,510 510,900
or being {}

1881
00:57:19,040 --> 00:57:20,600
0,330 330,570 570,1020 1020,1260 1260,1560
[not super careful] with our

1882
00:57:20,600 --> 00:57:21,520
0,600
assembly.|
|

1883
00:57:22,240 --> 00:57:23,470
0,180 180,750 750,900 900,1110 1110,1230
So normally, if we if
所以通常情况下，如果我们看内部，

1884
00:57:23,470 --> 00:57:25,660
0,90 90,330 330,630 630,1170 1770,2190
we look in,| {} I'm
|我肯定，

1885
00:57:25,660 --> 00:57:26,350
0,150 150,300 300,390 390,570 570,690
sure,| if we look in
|如果我们看内核，就会明白这一点。

1886
00:57:26,350 --> 00:57:27,520
0,360 360,480 480,840 840,990 990,1170
kernel at this and we'll

1887
00:57:27,520 --> 00:57:28,240
0,510
see.|
|

1888
00:57:29,010 --> 00:57:29,910
0,330 330,510 510,630 630,780 780,900
Yeah, so we look in
我们查看内核数据，发现它也是 16 ，

1889
00:57:29,910 --> 00:57:32,190
0,330 330,810 1770,1980 1980,2130 2130,2280
kernel data we see it's

1890
00:57:32,190 --> 00:57:33,780
0,480 480,960 960,1080 1080,1230 1230,1590
also 16,| this is generally
|这通常是编译器处理后看到的。

1891
00:57:33,780 --> 00:57:34,470
0,150 150,300 300,480 480,600 600,690
what you'll see with the

1892
00:57:34,470 --> 00:57:35,240
0,570
compiler.|
|

1893
00:57:37,970 --> 00:57:41,690
0,780 1170,1710 1800,2820 3150,3540 3540,3720
Um, OK, so now we
好的，现在我们可以。

1894
00:57:41,690 --> 00:57:42,520
0,540
can.|
|

1895
00:57:44,000 --> 00:57:45,560
0,390 390,960
After this.|
在这之后。|

1896
00:57:46,680 --> 00:57:48,600
0,180 180,450 450,600 600,1260 1710,1920
We fix our function and
我们修复函数，现在看一些 C 代码。

1897
00:57:48,600 --> 00:57:49,410
0,300 300,390 390,540 540,720 720,810
now we can look at

1898
00:57:49,410 --> 00:57:50,720
0,180 180,420 420,1080
some C code.|
|

1899
00:57:54,650 --> 00:57:56,420
0,330 330,450 450,720 720,840 840,1770
Alright, so here we have
好的，现在我们有 demo4 ，

1900
00:57:56,450 --> 00:57:58,670
0,810 810,1320 1320,1740 1740,1950 1950,2220
{demo4 -}| which is just
|它基本上就是 main 函数的复制，

1901
00:57:58,670 --> 00:58:00,460
0,720 750,1470
basically, {}

1902
00:58:00,690 --> 00:58:01,710
0,180 180,540 540,630 630,720 720,1020
a copy of {} main

1903
00:58:01,710 --> 00:58:04,080
0,510 510,660 660,1020 1050,1890 1890,2370
function,| like a imitation of
|是对 main 函数的模拟，

1904
00:58:04,080 --> 00:58:06,720
0,120 120,450 450,1140 1320,2130 2400,2640
the main function,| so we
|我们有 args ，它是一个字符串数组，

1905
00:58:06,720 --> 00:58:09,240
0,540 570,1170 1200,2040 2100,2280 2280,2520
have our args, {} which

1906
00:58:09,240 --> 00:58:10,620
0,90 90,210 210,450 450,540 540,1380
is an array of strings|
|

1907
00:58:10,740 --> 00:58:12,390
0,450 450,570 570,990 990,1320 1320,1650
and we have {dummymain -}|
我们有 dummymain ，|

1908
00:58:12,390 --> 00:58:14,550
0,180 180,870 1140,1770 1770,2070 2070,2160
which takes a number of
它接收一些参数和参数字符串，

1909
00:58:14,550 --> 00:58:16,800
0,780 780,1110 1110,1230 1230,1740 1740,2250
arguments and the arguments string|
|

1910
00:58:16,800 --> 00:58:18,180
0,390 390,630 630,870 870,1110 1110,1380
and just print it out,
然后打印出来。

1911
00:58:18,360 --> 00:58:19,660
0,390 390,720 720,1110
{} for us.|
|

1912
00:58:20,130 --> 00:58:21,150
0,180 180,270 270,480 480,600 600,1020
And so that's all that's
这就是所有的，都很简单，

1913
00:58:21,240 --> 00:58:22,830
0,360 360,510 510,660 660,1050 1050,1590
that's all that's happening here

1914
00:58:22,950 --> 00:58:25,380
0,90 90,330 330,1440 1680,2220 2220,2430
is pretty straightforward,| {} if
|如果我们在 dummymain 中设置断点，

1915
00:58:25,380 --> 00:58:27,060
0,120 120,600 630,810 810,1200 1200,1680
we set a break point

1916
00:58:27,060 --> 00:58:29,900
0,600 720,1290 1290,1950
in {dummymain -},|
|

1917
00:58:31,380 --> 00:58:35,200
0,510 510,840 840,1710 2250,2790
then hop over, let.|
然后跳过来。|

1918
00:58:35,620 --> 00:58:38,050
0,420 420,750 750,960 960,1830 1890,2430
Okay, we'll just continue and
好的，我们继续，运行 demo4 ，

1919
00:58:38,290 --> 00:58:40,210
0,360 360,660 660,1170 1200,1530 1530,1920
we start this run {demo4

1920
00:58:40,210 --> 00:58:41,950
0,630 750,1140 1140,1290 1290,1440 1440,1740
-},| okay so we now
|现在我们到了 dummymain 。

1921
00:58:41,950 --> 00:58:42,860
0,120 120,720
we hit

1922
00:58:42,890 --> 00:58:44,480
0,480 480,690 690,810 810,1290
{} {dummymain - -}.|
|

1923
00:58:45,080 --> 00:58:45,950
0,180 180,300 300,390 390,750 750,870
And there's a couple of
有几件重要的事要记住，

1924
00:58:45,950 --> 00:58:50,570
0,780 780,1620 1650,2550 2790,3780 3780,4620
important things to remember about,|
|

1925
00:58:51,560 --> 00:58:52,700
0,240 240,420 720,930 930,1050 1050,1140
{} {} that you can
你可以使用 gdb 来显示栈帧，

1926
00:58:52,700 --> 00:58:54,020
0,180 180,540 540,750 750,1050 1050,1320
use gdb for regarding stack

1927
00:58:54,020 --> 00:58:55,550
0,390 570,840 840,960 960,1080 1080,1530
frames,| so if we type
|我们输入 i ，也就是 info ，

1928
00:58:55,550 --> 00:58:58,340
0,1050 1050,1230 1230,1470 1470,2340 2430,2790
{i,so} again, that's info, {}|
|

1929
00:58:58,340 --> 00:58:59,690
0,120 120,210 210,480 480,480 480,1350
if we type i frame,
如果我们输入 i frame ，可以看到很多关于当前栈帧的信息，

1930
00:58:59,810 --> 00:59:00,650
0,180 180,300 300,540 540,660 660,840
we can see a whole

1931
00:59:00,650 --> 00:59:03,320
0,300 300,870 900,1350 1350,2160 2160,2670
bunch of useful information about

1932
00:59:03,320 --> 00:59:05,060
0,90 90,600 600,930 930,1320 1470,1740
the current stack frame,| so
|可以看到，我们在栈级别 0 ，

1933
00:59:05,060 --> 00:59:05,750
0,90 90,240 240,450 450,600 600,690
we can see we're at

1934
00:59:05,750 --> 00:59:07,430
0,360 360,600 600,1020 1020,1320 1320,1680
stack level zero,| level zero
|级别 0 意味着它[]在调用栈下面，

1935
00:59:07,430 --> 00:59:09,260
0,570 660,990 990,1410 1440,1680 1680,1830
means it's {[] -} is

1936
00:59:09,260 --> 00:59:10,550
0,450 450,570 570,660 660,930 930,1290
down in the call stack|
|

1937
00:59:10,550 --> 00:59:12,500
0,150 150,270 270,450 450,990 1500,1950
that we can go and
我们可以转到，而且帧在这个地址。

1938
00:59:12,500 --> 00:59:13,910
0,120 120,780 810,1020 1020,1200 1200,1410
the frame is at this

1939
00:59:13,910 --> 00:59:14,860
0,840
address.|
|

1940
00:59:15,570 --> 00:59:17,610
0,270 270,690 690,1380 1470,1920 1920,2040
The program counter which is
程序计数器也没问题，一切都很好，

1941
00:59:17,610 --> 00:59:18,570
0,270 270,480 480,660 660,840 840,960
okay, that's all well and

1942
00:59:18,570 --> 00:59:19,980
0,570 630,870 870,960 960,1020 1020,1410
good,| we have a safe
|我们有一个安全的程序计数器，

1943
00:59:19,980 --> 00:59:22,200
0,420 420,810 810,930 930,1470 1650,2220
program counter as well,| and
|如果我们使用这个地址跳转到 kernel.asm 。

1944
00:59:22,200 --> 00:59:23,580
0,270 270,540 570,900 900,1020 1020,1380
if we again if we

1945
00:59:23,610 --> 00:59:25,410
0,240 240,390 390,1080 1350,1560 1560,1800
take this address and we

1946
00:59:25,410 --> 00:59:28,680
0,510 540,1440 1590,2430 2580,2790 2790,3270
jump into {kernel.asm - -}.|
|

1947
00:59:29,850 --> 00:59:31,410
0,210 210,570 570,690 690,900 900,1560
We search for that address,|
我们搜索那个地址，|

1948
00:59:31,470 --> 00:59:34,380
0,330 330,510 510,1530 1740,2370 2550,2910
we can indeed that {}
我们可以在 demo4 中找到那个地址，

1949
00:59:34,380 --> 00:59:37,360
0,390 390,1320 1320,2070 2070,2610
that addresses inside of

1950
00:59:38,360 --> 00:59:40,340
0,840 840,1170 1170,1500 1500,1830 1830,1980
inside of {demo4 -},| which
|这正是我们希望程序返回的地址，

1951
00:59:40,340 --> 00:59:42,050
0,150 150,540 540,750 750,930 930,1710
is exactly where we expect

1952
00:59:42,080 --> 00:59:44,420
0,510 510,1110 1110,1470 1470,1890 1890,2340
the program to return to|
|

1953
00:59:44,690 --> 00:59:46,400
0,750 750,810 810,1020 1020,1530 1530,1710
and it was called by
它是由这个地址的帧调用的，

1954
00:59:46,400 --> 00:59:48,140
0,120 120,600 600,720 720,960 960,1740
a frame at this address|
|

1955
00:59:48,170 --> 00:59:50,360
0,570 570,960 960,1590 1620,1950 1950,2190
source language C,| that's that's
源代码 C ，|很高兴知道这一点，

1956
00:59:50,360 --> 00:59:52,130
0,540 660,1050 1050,1380 1380,1590 1590,1770
nice to know| and then
|然后我们有参数列表，也是从这个地址开始的，

1957
00:59:52,130 --> 00:59:53,720
0,120 120,540 540,660 660,1140 1140,1590
we have the argument list

1958
00:59:53,720 --> 00:59:56,030
0,360 360,720 720,1050 1050,1740 1860,2310
also starts this address, {}|
|

1959
00:59:56,030 --> 00:59:57,410
0,90 90,540 540,930 1020,1200 1200,1380
of course, {} in this
当然，本例中我们的大部分参数都在寄存器中，

1960
00:59:57,410 --> 00:59:58,420
0,570
case,

1961
00:59:58,580 --> 00:59:59,210
0,150 150,270 270,450 450,510 510,630
we have most of our

1962
00:59:59,210 --> 01:00:01,940
0,630 660,1020 1020,1860 1980,2610 2610,2730
arguments in registers| {} and
|我们甚至可以看到 args 是什么，

1963
01:00:01,940 --> 01:00:03,050
0,120 120,240 240,390 390,690 690,1110
then we can even see

1964
01:00:03,050 --> 01:00:05,390
0,360 360,720 720,1020 1020,1260 1260,2340
what args are,| we argc
|argc 是 3 ， argv 是这个地址。

1965
01:00:05,650 --> 01:00:08,200
0,690 690,1230 1230,1800 1800,2040 2040,2550
is three and {argv -}

1966
01:00:08,200 --> 01:00:09,620
0,330 330,540 540,1290
is this address.|
|

1967
01:00:10,440 --> 01:00:11,700
0,450 570,900 900,990 990,1200 1200,1260
And if we want a
如果我们想要更深入研究一些东西，

1968
01:00:11,700 --> 01:00:14,010
0,390 390,1200 1230,1830 1830,2220 2220,2310
more in-depth examine things| we
|可以使用 info args 命令，

1969
01:00:14,010 --> 01:00:15,420
0,180 180,450 450,570 570,870 870,1410
can look at things like

1970
01:00:15,480 --> 01:00:17,000
0,240 240,690 690,1350
{} info args,|
|

1971
01:00:17,680 --> 01:00:19,210
0,300 300,450 450,750 750,930 930,1530
which will tell us information
它告诉我们有关函数参数的信息，我们可以查看，

1972
01:00:19,210 --> 01:00:20,230
0,210 210,360 360,810 810,900 900,1020
about the arguments to the

1973
01:00:20,230 --> 01:00:23,080
0,750 960,1350 1350,1830 1830,2190 2190,2850
function, we can look at,|
|

1974
01:00:23,200 --> 01:00:25,420
0,420 420,570 570,780 780,1680 1920,2220
{} but more importantly we
但更重要的是，我们可以输入 backtrace 或 bt ，

1975
01:00:25,420 --> 01:00:26,830
0,300 300,810 810,900 900,1140 1140,1410
can type we type {backtrace

1976
01:00:26,830 --> 01:00:29,140
0,690 900,1290 1290,1800 1800,2130 2130,2310
 -} or bt works as

1977
01:00:29,140 --> 01:00:31,270
0,510 720,1230 1230,1530 1530,1710 1710,2130
well,| we get a full
|我们得到了整个栈帧的 backtrace ，

1978
01:00:31,270 --> 01:00:33,790
0,780 780,1320 1350,1740 1740,1920 1920,2520
backtrace of all of the

1979
01:00:33,820 --> 01:00:35,770
0,840 870,1290 1290,1440 1440,1860 1860,1950
stacks,| {} {} all of
|调用栈中的所有栈帧，

1980
01:00:35,770 --> 01:00:37,600
0,90 90,450 450,1080 1140,1710 1710,1830
the stack frames from the

1981
01:00:37,600 --> 01:00:38,710
0,240 240,570 570,840 840,1020 1020,1110
call stack,| so you can
|你可以在这里看到一些问题，

1982
01:00:38,710 --> 01:00:40,630
0,480 480,840 840,1290 1290,1530 1530,1920
see something questionable happen here,|
|

1983
01:00:40,630 --> 01:00:41,590
0,240 240,390 390,540 540,900 900,960
that's when we invoke a
当我们调用系统调用时，

1984
01:00:41,590 --> 01:00:43,870
0,390 390,870 1260,1680 1800,2190 2190,2280
system call,| {} then we
|然后我们到达 usertrap 函数，

1985
01:00:43,870 --> 01:00:45,130
0,150 150,210 210,300 300,660 660,1260
get to the {usertrap -}

1986
01:00:45,130 --> 01:00:46,360
0,510 540,750 750,840 840,960 960,1230
function,| then to the {syscall
|然后是 syscall 函数，

1987
01:00:46,360 --> 01:00:48,340
0,360 360,1170 1230,1590 1590,1710 1710,1980
-} function,| then to {sys_demo
|然后是 sys_demo ，然后是 demo4 。

1988
01:00:48,340 --> 01:00:50,710
0,780 840,1200 1200,1290 1290,1650 1650,2370
-} then to {demo4 -}.|
|

1989
01:00:51,510 --> 01:00:52,860
0,210 210,390 390,930 930,1050 1050,1350
And then finally to {dummymain
然后转到 dummymain ，

1990
01:00:52,860 --> 01:00:54,810
0,480 1350,1560 1560,1650 1650,1740 1740,1950
-}| and if we want
|如果我们想更深入研究这些栈中的一个，

1991
01:00:54,810 --> 01:00:56,340
0,180 180,1080 1080,1290 1290,1380 1380,1530
to investigate any of these

1992
01:00:56,340 --> 01:00:58,620
0,330 330,780 900,1530 1530,2010 2010,2280
stack frames more in-depth,| we
|我们可以使用 frame 再加上一个数字，

1993
01:00:58,650 --> 01:01:00,300
0,180 180,540 540,1170 1170,1380 1380,1650
can do frame and then

1994
01:01:00,300 --> 01:01:02,460
0,390 390,1110 1350,1560 1560,1800 1800,2160
whatever number {} is along

1995
01:01:02,460 --> 01:01:03,570
0,90 90,480 480,780 780,900 900,1110
the side here,| so let's
|比如我想看看当 syscall 调用时栈帧是什么，

1996
01:01:03,570 --> 01:01:04,230
0,150 150,240 240,420 420,480 480,660
say I want to look

1997
01:01:04,230 --> 01:01:05,130
0,60 60,240 240,390 390,540 540,900
at what was my stack

1998
01:01:05,130 --> 01:01:07,350
0,540 600,1080 1080,1350 1350,1860 1860,2220
frame when {syscall -} called,|
|

1999
01:01:07,350 --> 01:01:08,670
0,150 150,240 240,360 360,720 720,1320
{I,can} go to frame three,|
我可以查看第 3 帧，|

2000
01:01:08,940 --> 01:01:10,440
0,150 150,270 270,570 570,1080 1110,1500
and so now, {} inside
现在，在 gdb 里面，我正在查看栈帧，

2001
01:01:10,440 --> 01:01:11,400
0,60 60,210 210,510 510,690 690,960
of {gdb -}, I'm looking

2002
01:01:11,400 --> 01:01:12,330
0,120 120,330 330,600 600,780 780,930
at that stack frame,| so
|我输入 info frame ，可以得到这个。

2003
01:01:12,330 --> 01:01:14,130
0,180 180,480 480,810 810,1350 1410,1800
I type info frame I

2004
01:01:14,130 --> 01:01:15,120
0,120 120,300 300,780
can get this.|
|

2005
01:01:15,700 --> 01:01:16,390
0,240 240,450 450,510 510,630 630,690
And here we get a
这里我们得到了更多信息，

2006
01:01:16,390 --> 01:01:17,980
0,210 210,630 750,1110 1110,1290 1290,1590
lot more a lot more

2007
01:01:17,980 --> 01:01:19,210
0,660 660,780 780,930 930,990 990,1230
information| we have a bunch
|有很多保存寄存器。

2008
01:01:19,210 --> 01:01:21,300
0,90 90,480 480,1770
of saves registers.|
|

2009
01:01:21,410 --> 01:01:23,870
0,780 1020,1230 1230,1770 1770,2040 2040,2460
Um, we have some local
我们有一些局部变量，

2010
01:01:23,870 --> 01:01:25,760
0,1200 1200,1290 1290,1500 1500,1680 1680,1890
variables,| we don't have any
|这个函数没有任何参数，

2011
01:01:25,760 --> 01:01:27,800
0,600 600,690 690,900 900,1680 1770,2040
arguments to this function,| we
|我们可看到程序计数器应该跳回到哪里，

2012
01:01:27,800 --> 01:01:28,880
0,120 120,390 390,630 630,720 720,1080
can see where the program

2013
01:01:28,880 --> 01:01:30,260
0,510 510,750 750,1050 1050,1140 1140,1380
counter were supposed to jump

2014
01:01:30,260 --> 01:01:32,030
0,300 300,780 900,1260 1260,1500 1500,1770
back to,| {} all kinds
|诸如此类的东西，

2015
01:01:32,030 --> 01:01:32,840
0,60 60,360 360,540 540,720 720,810
of things like that,| so
|所以，如果你在调试东西，这是非常有用的。

2016
01:01:32,840 --> 01:01:34,100
0,150 150,240 240,540 540,840 840,1260
this is super super useful

2017
01:01:34,100 --> 01:01:35,780
0,390 480,780 780,900 900,1410 1410,1680
for if you're debugging things,|
|

2018
01:01:35,780 --> 01:01:36,500
0,90 90,180 180,420 420,570 570,720
and in fact it's so
事实上，它非常有用，

2019
01:01:36,500 --> 01:01:38,540
0,630 660,900 900,1140 1140,1260 1260,2040
useful,| we make you implement
|我们让你自己实现的版本，远不如 gdb 告诉你的那样深入。

2020
01:01:39,020 --> 01:01:41,630
0,240 240,480 480,1170 1230,2190 2190,2610
your own version, nowhere near

2021
01:01:41,630 --> 01:01:42,560
0,240 240,330 330,630 630,720 720,930
as in depth as what

2022
01:01:42,560 --> 01:01:44,810
0,360 360,720 720,1020 1170,1530 1530,2250
gdb tells you,| but we're
|我们在下一个实验中的练习之一，

2023
01:01:44,960 --> 01:01:46,100
0,240 240,330 330,420 420,990 990,1140
one of the exercises on

2024
01:01:46,100 --> 01:01:47,210
0,90 90,360 360,720 720,930 930,1110
the next lab| will be
|是实现你自己的 backtrace helper 函数，

2025
01:01:47,210 --> 01:01:48,950
0,150 150,660 660,840 840,1230 1290,1740
to implement your own {backtrace

2026
01:01:48,950 --> 01:01:50,960
0,630 660,1020 1020,1530 1530,1740 1740,2010
-} helper function,| for use
|以便在实验内调试时使用。

2027
01:01:50,960 --> 01:01:52,610
0,330 330,900 900,1230 1230,1560 1560,1650
when debugging things inside the

2028
01:01:52,610 --> 01:01:53,500
0,390
lab.|
|

2029
01:01:54,110 --> 01:01:55,250
0,210 210,330 330,570 570,780 780,1140
And so back {backtrace -}
因此 backtrace 非常有用，

2030
01:01:55,250 --> 01:01:56,990
0,120 120,630 630,900 900,1440 1530,1740
{} is quite useful,| and
|如果我们输入 frame 0 ，就会返回到刚才的位置。

2031
01:01:56,990 --> 01:01:57,770
0,150 150,270 270,330 330,570 570,780
then if we type frame

2032
01:01:57,770 --> 01:01:59,240
0,480 480,570 570,720 720,990 990,1470
zero, we go back to

2033
01:01:59,270 --> 01:02:00,740
0,420 420,570 570,870 870,1380 1380,1470
where we were supposed to

2034
01:02:00,740 --> 01:02:01,240
0,240
be.|
|

2035
01:02:02,900 --> 01:02:04,220
0,510 690,870 870,990 990,1200 1200,1320
And if we want to
如果我们想要调查，

2036
01:02:04,220 --> 01:02:05,780
0,450 450,570 570,780 780,1170 1170,1560
investigate,| you probably noticed it's
|你可能注意到这不是很有帮助，

2037
01:02:05,780 --> 01:02:07,070
0,210 210,570 570,1110 1110,1170 1170,1290
not super helpful,| you know
|argv 是字符串数组形式的字符串，

2038
01:02:07,070 --> 01:02:08,390
0,210 210,450 450,600 600,690 690,1320
{argv -} is a string

2039
01:02:08,540 --> 01:02:09,950
0,780 780,990 990,1080 1080,1320 1320,1410
{} as an array of

2040
01:02:09,950 --> 01:02:11,180
0,510 510,690 690,900 900,1020 1020,1230
strings| and so we just
|而且我们只拿到了地址，

2041
01:02:11,180 --> 01:02:12,080
0,150 150,270 270,570 570,720 720,900
got a ref, we just

2042
01:02:12,080 --> 01:02:14,060
0,180 180,540 540,960 960,1620 1680,1980
get {} an address,| for
|如果我们想看看地址里面是什么，

2043
01:02:14,060 --> 01:02:16,250
0,300 300,540 540,960 960,1650 1920,2190
where that's actually stored and

2044
01:02:16,250 --> 01:02:16,940
0,150 150,210 210,390 390,450 450,690
if we want to look

2045
01:02:16,940 --> 01:02:17,720
0,90 90,390 390,510 510,630 630,780
at what's in there,| there's
|有几种方法可以做到，

2046
01:02:17,720 --> 01:02:18,620
0,60 60,300 300,540 540,600 600,900
a couple ways of doing

2047
01:02:18,620 --> 01:02:21,170
0,510 630,1230 1350,1470 1470,2100 2100,2550
this,| {} the easiest is
|最简单的是，输入 print ， p 表示打印，

2048
01:02:21,200 --> 01:02:22,430
0,390 390,570 570,660 660,930 930,1230
{} if we type print,

2049
01:02:22,430 --> 01:02:24,440
0,420 420,540 540,720 720,1290 1620,2010
p is for print,| and
|然后我们间接引用该地址，

2050
01:02:24,440 --> 01:02:27,350
0,300 300,570 570,1080 1110,2280 2280,2910
then if we {dereference -}

2051
01:02:27,350 --> 01:02:28,370
0,150 150,570 570,660 660,810 810,1020
the address,| so we go
|我们看看地址那里是什么，

2052
01:02:28,370 --> 01:02:29,780
0,210 210,300 300,540 540,690 870,1410
look at what's at address,|
|

2053
01:02:29,930 --> 01:02:32,390
0,420 420,930 1110,1650 1800,2310 2310,2460
we do that and, {}|
我们这样做，|

2054
01:02:32,390 --> 01:02:33,140
0,120 120,240 240,450 450,570 570,750
you know, as you would
你知道，正如预期的，我们得到了该数组的第一个元素，

2055
01:02:33,140 --> 01:02:34,000
0,690
expect,

2056
01:02:34,720 --> 01:02:36,040
0,210 210,360 360,480 480,810 810,1320
we get the first element

2057
01:02:36,040 --> 01:02:37,810
0,150 150,360 360,780 780,1350 1440,1770
of that array,| because when
|因为当它试图打印字符串时，

2058
01:02:37,810 --> 01:02:38,830
0,120 120,510 510,630 630,930 930,1020
it tries to print a

2059
01:02:38,830 --> 01:02:40,780
0,450 450,720 720,1080 1080,1620 1620,1950
string,| it'll go {as,C} says,
|就像 C 语言里，它会一直运行，直到遇到空字符，

2060
01:02:40,780 --> 01:02:41,740
0,150 150,300 300,720 720,780 780,960
it'll go until it hits

2061
01:02:41,740 --> 01:02:43,450
0,120 120,330 330,1110 1290,1620 1620,1710
the null character,| so we
|所以我们得到 foo ，它是数组中的第一个元素，

2062
01:02:43,450 --> 01:02:44,290
0,210 210,480 480,660 660,750 750,840
get foo which is the

2063
01:02:44,290 --> 01:02:45,190
0,240 240,480 480,540 540,630 630,900
first element in that array,|
|

2064
01:02:45,190 --> 01:02:45,730
0,120 120,240 240,330 330,480 480,540
and if we want to
如果我们想要得到更多，可以加上一个长度，

2065
01:02:45,730 --> 01:02:47,950
0,120 120,420 420,1140 1200,1530 1530,2220
get more things we can

2066
01:02:47,980 --> 01:02:49,270
0,330 330,450 450,570 570,1080 1110,1290
put in the length,| so
|如果我们输入 @ ，然后一个数字，

2067
01:02:49,270 --> 01:02:49,880
0,120 120,210 210,360
if we do

2068
01:02:50,520 --> 01:02:51,300
0,150 150,240 240,300 300,630 630,780
@ then a number,| it'll
|它会上升到某个索引，

2069
01:02:51,300 --> 01:02:52,020
0,150 150,270 270,390 390,450 450,720
go up to a certain

2070
01:02:52,020 --> 01:02:53,580
0,720 900,1080 1080,1260 1260,1380 1380,1560
index,| so then we can
|然后我们可以看到这两个字符串，

2071
01:02:53,580 --> 01:02:54,870
0,330 330,600 600,720 720,810 810,1290
see both of the strings

2072
01:02:54,870 --> 01:02:58,230
0,540 930,1950 2310,2850 2850,3240 3240,3360
here| and again gdb is
|同样， gdb 非常聪明，

2073
01:02:58,230 --> 01:02:59,760
0,270 270,660 660,1050 1170,1410 1410,1530
quite smart,| so we can
|我们甚至可以用 argc 打印整个参数数组。

2074
01:02:59,760 --> 01:03:02,460
0,750 1590,1890 1890,2250 2250,2580 2580,2700
even use {argc -} to

2075
01:03:02,460 --> 01:03:03,900
0,300 300,510 510,570 570,1050 1050,1440
print out the whole argument

2076
01:03:03,900 --> 01:03:04,600
0,420
array.|
|

2077
01:03:05,590 --> 01:03:06,370
0,210 210,360 360,540 540,600 600,780
And so all of that
所有的信息对你来说都是可用的，

2078
01:03:06,370 --> 01:03:08,890
0,1170 1200,1410 1410,1950 1950,2070 2070,2520
information is available to you,|
|

2079
01:03:09,130 --> 01:03:11,650
0,600 600,1170 1320,1830 1830,2340 2340,2520
you {}, however you want
不管你想得到什么， gdb 是很有用的工具。

2080
01:03:11,650 --> 01:03:12,520
0,90 90,240 240,420 420,660 660,870
to get it, so {gdb

2081
01:03:12,520 --> 01:03:15,430
0,60 60,210 210,840 1770,2550 2550,2910
-} the {superpower,tool}.| Why does
|为什么 gdb ，不好意思，

2082
01:03:15,430 --> 01:03:17,260
0,930 990,1350 1350,1560 1560,1710 1710,1830
gdb sorry,| why does the
|为什么编译器有时候会优化 argc 和 argv ，

2083
01:03:17,260 --> 01:03:20,050
0,540 540,1080 1080,1800 1800,2160 2460,2790
compiler sometimes optimize out {argc

2084
01:03:20,050 --> 01:03:22,060
0,600 630,1470 1470,1620 1620,1800 1800,2010
- -} and {argv -

2085
01:03:22,060 --> 01:03:23,140
0,300 300,510 510,690 690,1020 1020,1080
-},| that has happened to
|之前发生过这样的事。

2086
01:03:23,140 --> 01:03:25,300
0,150 150,690 1200,1830 1830,1980 1980,2160
be before.| Yeah that just
|这意味着编译器找到了一种更有效的方法，

2087
01:03:25,300 --> 01:03:26,620
0,240 240,360 360,450 450,990 990,1320
means that the compiler found

2088
01:03:26,620 --> 01:03:27,820
0,60 60,390 390,810 810,1200 1200,1200
a more efficient way,| {}
|很可能只是去掉了变量，并进行所有操作，

2089
01:03:28,000 --> 01:03:29,140
0,600 600,690 690,840 840,1050 1050,1140
likely it just got rid

2090
01:03:29,140 --> 01:03:30,010
0,90 90,180 180,540 540,660 660,870
of the variable and it's

2091
01:03:30,010 --> 01:03:31,570
0,270 270,480 480,540 540,660 660,1560
doing all of its operations,|
|

2092
01:03:31,810 --> 01:03:34,030
0,510 540,1230 1230,1290 1290,1770 1800,2220
{} directly you know []
你知道[]寄存器可能在 a0 上执行所有操作，

2093
01:03:34,030 --> 01:03:35,140
0,330 330,570 570,690 690,900 900,1110
register might be doing all

2094
01:03:35,140 --> 01:03:36,070
0,60 60,150 150,660 660,810 810,930
of its operations on {a0

2095
01:03:36,070 --> 01:03:37,560
0,420 420,540 540,1230
-},| for example,
|比如，它可能只是对返回地址进行所有计算。

2096
01:03:37,610 --> 01:03:38,540
0,300 300,420 420,630 630,810 810,930
{} it might just be

2097
01:03:38,540 --> 01:03:39,890
0,300 300,450 450,600 600,1230 1230,1350
doing all the computations on

2098
01:03:39,890 --> 01:03:41,000
0,90 90,390 390,930
the return address.|
|

2099
01:03:41,120 --> 01:03:42,170
0,210 210,420 420,750 750,870 870,1050
It's pretty common to see
这很常见，

2100
01:03:42,170 --> 01:03:43,520
0,300 300,510 510,810 810,1020 1020,1350
something like that,| if you
|如果它是一个非必须的变量。

2101
01:03:43,520 --> 01:03:45,470
0,510 1050,1290 1290,1410 1410,1470 1470,1950
{} if it's a variable

2102
01:03:45,470 --> 01:03:46,460
0,240 240,630 630,750 750,900 900,990
that's not you know a

2103
01:03:46,460 --> 01:03:47,460
0,300 300,750
hundred percent

2104
01:03:47,500 --> 01:03:50,080
0,1050 1290,1560 1560,1800 1800,2100 2340,2580
necessary.| {} If you know
|我们不能控制编译器，

2105
01:03:50,080 --> 01:03:51,130
0,120 120,330 330,690 690,840 840,1050
we don't let we don't

2106
01:03:51,130 --> 01:03:52,000
0,150 150,270 270,660 660,810 810,870
give you control over the

2107
01:03:52,000 --> 01:03:53,020
0,480 480,600 600,720 720,810 810,1020
compiler,| but if you ever
|但是如果你在平时发现这个，

2108
01:03:53,020 --> 01:03:54,310
0,240 240,390 390,480 480,630 630,1290
find that in your day-to-day,|
|

2109
01:03:54,460 --> 01:03:56,170
0,270 270,420 420,840 840,1350 1350,1710
you can try setting the
你可以尝试将编译器的优化标志设置为零，

2110
01:03:56,170 --> 01:03:58,480
0,900 900,1500 1500,1680 1680,1770 1770,2310
optimization flag for the compiler

2111
01:03:58,480 --> 01:04:00,640
0,120 120,810 1050,1470 1470,1830 1830,2160
to zero,| {} but even
|但即使这样，编译器仍会做一定程度的优化。

2112
01:04:00,640 --> 01:04:01,930
0,480 510,630 630,780 780,870 870,1290
then you know the compiler

2113
01:04:01,930 --> 01:04:03,160
0,120 120,450 660,780 780,900 900,1230
will do will do it,

2114
01:04:03,190 --> 01:04:03,940
0,120 120,270 270,480 480,690 690,750
we'll do some level of

2115
01:04:03,940 --> 01:04:04,880
0,720
optimization.|
|

2116
01:04:05,550 --> 01:04:06,930
0,300 300,720 720,960 960,1260 1260,1380
{Bibic, -} your hand is
Bibic 你举手了。

2117
01:04:06,930 --> 01:04:07,500
0,390
raised.|
|

2118
01:04:08,310 --> 01:04:12,180
0,1260 1530,2160 2160,2580 2610,3270 3270,3870
Yeah what's the address, besides
是的，在 $1 和 $2 后面的地址是什么，就是在 foo 或 bar 之前的，

2119
01:04:12,180 --> 01:04:13,830
0,450 450,870 870,1170 1170,1260 1260,1650
that {$1 -} or {$2

2120
01:04:13,830 --> 01:04:15,180
0,270 270,390 390,570 570,870 870,1350
2} you know like before

2121
01:04:15,180 --> 01:04:17,580
0,420 690,840 840,1200 1440,1770 1770,2400
foo or bar.| {} Dollar,
|美元符号，你说这个吗？

2122
01:04:17,670 --> 01:04:18,620
0,510
this?|
|

2123
01:04:18,870 --> 01:04:20,520
0,390 390,540 540,750 750,930 930,1650
Yeah, so what's that address
是的，那个地址就是 foo 所在的地址。

2124
01:04:20,610 --> 01:04:22,230
0,360 360,690 690,840 840,1170 1170,1620
is that the address where

2125
01:04:22,260 --> 01:04:23,340
0,450 450,900
foo is.|
|

2126
01:04:23,640 --> 01:04:24,700
0,450 450,810
Probably yes.|
可能是吧。|

2127
01:04:25,990 --> 01:04:27,790
0,540 540,720 720,1020 1020,1380 1380,1800
But then {argv -} points
但是，然后 argv 指向其他地址，它们不应该是相同的。

2128
01:04:27,790 --> 01:04:29,350
0,150 150,360 360,600 600,930 930,1560
to some other address shouldn't

2129
01:04:29,350 --> 01:04:30,660
0,270 270,390 390,480 480,810
those be the same.|
|

2130
01:04:32,080 --> 01:04:33,190
0,270 270,540 540,750 750,990 990,1110
So {argv - -} is
所以 argv 在这个栈上，

2131
01:04:33,190 --> 01:04:36,400
0,180 180,510 510,1620 1950,2850
on this stack,| and
|如果你看这些地址，

2132
01:04:36,550 --> 01:04:37,810
0,210 210,660 690,870 870,960 960,1260
you know, so the reason

2133
01:04:37,810 --> 01:04:39,070
0,540 570,810 810,990 990,1170 1170,1260
why, if you look at

2134
01:04:39,070 --> 01:04:40,390
0,240 240,840 840,990 990,1140 1140,1320
these addresses,| we can see
|我们可以看到它们在内核中，就在 8000 。

2135
01:04:40,390 --> 01:04:41,440
0,150 150,300 300,420 420,480 480,1050
that they're in the kernel,

2136
01:04:41,710 --> 01:04:43,090
0,420 420,690 690,870 870,1200 1200,1380
{} just by the {8000

2137
01:04:43,090 --> 01:04:44,640
0,210 210,690 690,1260
- - -}.|
|

2138
01:04:44,760 --> 01:04:46,500
0,420 420,720 720,960 960,1290 1290,1740
Um, which makes sense because
这是有道理的，因为我们静态声明，

2139
01:04:46,500 --> 01:04:49,200
0,360 960,1590 1590,2160 2160,2400 2400,2700
we declared statically right,| so
|所以在示例程序中，如果我走到这里，它们会在这里声明。

2140
01:04:49,200 --> 01:04:50,220
0,180 180,630 630,720 720,840 840,1020
in demos, if I go

2141
01:04:50,220 --> 01:04:51,780
0,360 360,480 480,930 930,1320
here they're declared here.|
|

2142
01:04:52,000 --> 01:04:53,020
0,210 210,300 300,450 450,870 870,1020
And so they're basically they're
所以它们位于内核的某个地方，

2143
01:04:53,020 --> 01:04:54,460
0,300 300,690 690,810 810,870 870,1440
sitting somewhere in the kernel|
|

2144
01:04:54,820 --> 01:04:56,590
0,180 180,330 330,510 510,1110 1110,1770
and they're all [] stars
它们都是星号标记的， argc 或 argv 是一系列的间接引用，


2145
01:04:56,860 --> 01:04:58,990
0,660 660,840 840,1560 1800,2010 2010,2130
argc or argv is an

2146
01:04:58,990 --> 01:05:00,250
0,300 300,390 390,690 690,1140 1140,1260
array of [] stars| and
|所以我想每个元素都指向自己的字符串，

2147
01:05:00,250 --> 01:05:01,660
0,180 180,240 240,690 690,900 900,1410
so I imagined each element

2148
01:05:01,980 --> 01:05:03,280
0,240 240,660 660,1110
{} points to

2149
01:05:04,320 --> 01:05:06,870
0,390 390,780 1110,1860 1860,2190 2190,2550
points to {its,own} string right,|
|

2150
01:05:07,020 --> 01:05:08,280
0,360 750,870 870,960 960,1170 1170,1260
so it's an array of
它是一个指针数组。

2151
01:05:08,280 --> 01:05:09,080
0,600
pointers.|
|

2152
01:05:10,420 --> 01:05:11,080
0,120 120,390
I see.|
我明白了。|

2153
01:05:11,510 --> 01:05:12,000
0,270

2154
01:05:17,060 --> 01:05:19,700
0,360 360,630 630,750 750,1290
{[] - - -}|
[]|

2155
01:05:24,700 --> 01:05:25,780
0,180 180,600 600,720 720,780 780,1080
I also have a question
我也有一个问题，

2156
01:05:25,780 --> 01:05:27,820
0,240 240,660 690,960 960,1380 1440,2040
about this,| {} the {$3
|$3 版本的数组具有，

2157
01:05:27,820 --> 01:05:29,040
0,330 330,720 720,900
-} version of

2158
01:05:29,250 --> 01:05:32,160
0,630 630,1290 1860,2610 2610,2820 2820,2910
the array has| if I
|如果看这些地址， 

2159
01:05:32,160 --> 01:05:34,080
0,390 390,510 510,720 720,1530 1770,1920
look at these addresses| the
|第一个后缀是 38 ，

2160
01:05:34,080 --> 01:05:35,060
0,240 240,360 360,660
first one is

2161
01:05:35,180 --> 01:05:38,000
0,690 690,870 870,1710 1980,2130 2490,2820
suffixed by 38,| the second
|第二个后缀是 40 ，

2162
01:05:38,000 --> 01:05:39,500
0,120 120,210 210,660 660,840 840,1500
one is suffixed by 40|
|

2163
01:05:39,650 --> 01:05:40,820
0,90 90,210 210,480 480,630 630,1170
and the third one is
第三个是 48 。

2164
01:05:40,970 --> 01:05:42,380
0,1110
48.|
|

2165
01:05:42,500 --> 01:05:44,570
0,300 300,750 750,1050 1050,1710 1710,2070
Which is not uniform, even
这不是统一的，虽然三个参数的长度都是三个，

2166
01:05:44,570 --> 01:05:46,100
0,390 390,510 510,840 840,960 960,1530
though the length of each

2167
01:05:46,130 --> 01:05:48,290
0,60 60,210 210,480 480,1320 1950,2160
of the three arguments is

2168
01:05:48,290 --> 01:05:50,270
0,420 930,1170 1170,1620 1620,1830 1830,1980
three,| so why, why are
|所以为什么它们是不同的。

2169
01:05:50,270 --> 01:05:53,120
0,90 90,630 870,1560 1740,2490 2490,2850
they different.| Um, not in
|嗯，我也不是百分百确定，

2170
01:05:53,150 --> 01:05:54,290
0,120 120,270 270,300 300,570 570,1140
I'm not a hundred percent

2171
01:05:54,380 --> 01:05:55,790
0,690 690,900 900,1170 1170,1290 1290,1410
certain,| my guess is that
|我猜是为了对齐数据。

2172
01:05:55,790 --> 01:05:57,110
0,180 180,270 270,390 390,900 900,1320
this is an attempt to

2173
01:05:57,110 --> 01:05:58,500
0,450 450,1170
align things.|
|

2174
01:05:58,700 --> 01:05:59,720
0,720
Um,
让它们保持合理的位置，

2175
01:06:00,050 --> 01:06:02,060
0,330 330,840 1320,1470 1470,1680 1680,2010
right, so to get them

2176
01:06:02,060 --> 01:06:05,000
0,150 150,270 270,1110 1320,2040 2550,2940
on a reasonable alignment,| it
|有人指出它们用十六进制表示是对齐的。

2177
01:06:05,000 --> 01:06:06,410
0,180 180,630 630,690 690,1110 1110,1410
is uniform in {hex,as}, people

2178
01:06:06,410 --> 01:06:07,340
0,60 60,360 360,690
are pointing out.|
|

2179
01:06:08,430 --> 01:06:13,470
0,420 1620,2310 2310,2910 2970,4860 4860,5040
Oh yeah, yeah yeah see
好的，理解了，谢谢。

2180
01:06:13,470 --> 01:06:16,260
0,120 120,540 930,1320 1320,1950 2400,2790
it now right, thanks.| So
|所以有时候你看到东西放在那里很奇怪，

2181
01:06:16,260 --> 01:06:17,460
0,120 120,540 540,690 690,870 870,1200
you'll sometimes see where strange

2182
01:06:17,460 --> 01:06:19,590
0,240 240,660 690,990 990,1170 1170,2130
things are laid out strangely|
|

2183
01:06:19,650 --> 01:06:20,520
0,270 270,420 420,600 600,660 660,870
where there might be two
可能是两个东西有不同的偏移量，

2184
01:06:20,520 --> 01:06:22,200
0,450 450,810 810,1080 1080,1590 1590,1680
things as strange offsets| and
|因为并不是所有的东西都是相同大小的。

2185
01:06:22,200 --> 01:06:23,550
0,210 210,600 600,840 840,1020 1020,1350
that's just because not everything

2186
01:06:23,550 --> 01:06:25,740
0,240 570,1290 1290,1380 1380,1650 1650,2190
is naturally the same sized.|
|

2187
01:06:26,300 --> 01:06:29,740
0,1770 2040,2280 2280,2490 2490,3210
Okay, any other questions.|
好的，还有其他问题吗？|

2188
01:06:30,900 --> 01:06:31,380
0,390

2189
01:06:36,450 --> 01:06:36,820
0,210

2190
01:06:37,230 --> 01:06:39,510
0,570 660,1500 1500,1620 1620,1740 1740,2280
Okay, {} we can skip
好的，我们可以跳过第五个 demo 。

2191
01:06:39,510 --> 01:06:41,060
0,150 150,630 630,1110
the fifth demo.|
|

2192
01:06:41,150 --> 01:06:43,370
0,630 660,900 900,1230 1230,1740 1740,2220
And so another useful function
gdb 的另一个有用的功能是，

2193
01:06:43,370 --> 01:06:46,250
0,180 180,360 360,810 810,1470 1470,2880
that we get from gdb,|
|

2194
01:06:46,460 --> 01:06:49,220
0,810 1260,2040 2040,2160 2160,2490 2490,2760
{} instead of just break
不仅有断点，还有观察点，

2195
01:06:49,220 --> 01:06:51,230
0,630 690,1110 1110,1260 1260,1710 1710,2010
points, {} they're also watch


2196
01:06:51,230 --> 01:06:52,400
0,450 450,600 600,720 720,840 840,1170
points| and we can also
|并且我们还可以设置有条件的断点。

2197
01:06:52,400 --> 01:06:55,010
0,630 810,1140 1140,1770 1770,2010 2010,2610
set a conditional break points.|
|

2198
01:06:55,250 --> 01:06:56,360
0,630
So,
我简单介绍一下。

2199
01:06:57,770 --> 01:06:59,660
0,600 600,960 960,1530 1530,1710 1710,1890
I'll just briefly go over

2200
01:06:59,660 --> 01:07:01,000
0,540
that.|
|

2201
01:07:02,160 --> 01:07:04,470
0,630 630,900 900,1620 1920,2160 2160,2310
Run {demo6 -} so we
运行 demo6 以便我们可以在函数中设置，

2202
01:07:04,470 --> 01:07:06,840
0,270 270,960 1170,1710 1710,1890 1890,2370
can set inside this function,|
|

2203
01:07:06,840 --> 01:07:08,070
0,120 120,510 510,990 990,1110 1110,1230
we can watch so we
我们可以设置观察点，

2204
01:07:08,070 --> 01:07:09,330
0,120 120,270 270,330 330,630 630,1260
can set a watch point,|
|

2205
01:07:09,540 --> 01:07:11,370
0,660 840,1020 1020,1290 1290,1590 1590,1830
{} I think here you'll
我想在这里你可以看到。

2206
01:07:11,370 --> 01:07:13,360
0,540 840,1350
see {}.|
|

2207
01:07:15,680 --> 01:07:16,670
0,210 210,390 390,660 660,840 840,990
Yeah, so here you'll see
向 Luke 所说的，一些东西被优化了，

2208
01:07:16,670 --> 01:07:19,130
0,840 930,1500 1500,1680 1680,2070 2070,2460
what Luke was talking about

2209
01:07:19,130 --> 01:07:20,720
0,630 840,1140 1140,1290 1290,1440 1440,1590
where {} we see that

2210
01:07:20,720 --> 01:07:22,460
0,330 330,510 510,720 720,1320 1320,1740
some has been optimized out,|
|

2211
01:07:22,670 --> 01:07:24,170
0,510 510,810 810,990 990,1230 1230,1500
likely because it's just being
可能是因为它只是零或别的什么。

2212
01:07:24,680 --> 01:07:25,920
0,30 30,480 480,600 600,960
a zero or something.|
|

2213
01:07:27,060 --> 01:07:27,990
0,240 240,360 360,600 600,810 810,930
We can look even at
我们可以看一下这个汇编，

2214
01:07:27,990 --> 01:07:29,280
0,150 150,630 630,780 780,1050 1050,1290
the assembly for this right,|
|

2215
01:07:29,280 --> 01:07:30,630
0,180 180,270 270,480 690,870 870,1350
so we can {layout -}
我们可以使用 layout split 。

2216
01:07:31,470 --> 01:07:32,440
0,750
split.|
|

2217
01:07:32,980 --> 01:07:34,570
0,810 810,1290 1290,1350 1350,1440 1440,1590
And indeed, we can see
事实上，可以看到所有都是在栈上完成的，

2218
01:07:34,570 --> 01:07:35,800
0,150 150,330 330,480 480,780 780,1230
that all just being, {}

2219
01:07:36,480 --> 01:07:37,320
0,180 180,360 360,510 510,660 660,840
It's all just being done

2220
01:07:37,320 --> 01:07:38,220
0,90 90,180 180,510 510,660 660,900
on the stack,| it looks
|在我看来。

2221
01:07:38,220 --> 01:07:39,060
0,180 180,270 270,540
like to me.|
|

2222
01:07:40,280 --> 01:07:41,180
0,180 180,330 330,450 450,720 720,900
Oh, no, it's always been
不，这都是在 s0, s0 1 3 上做的，

2223
01:07:41,180 --> 01:07:42,080
0,180 180,270 270,420 420,720 720,900
done in {s0 -} {s0

2224
01:07:42,080 --> 01:07:43,790
0,330 330,630 630,1110 1320,1500 1500,1710
 -} one three,| so here
|在这里你可以看到，编译器使用的是被调用者保存寄存器，

2225
01:07:43,790 --> 01:07:45,170
0,180 180,300 300,450 450,870 870,1380
you can see the, {}

2226
01:07:47,060 --> 01:07:48,380
0,480 480,870 870,1080 1080,1170 1170,1320
compiler decided even to use

2227
01:07:48,380 --> 01:07:52,010
0,120 120,480 480,810 810,1500 3030,3630
the callee saved registers| and
|这样我们可以设置，对 i 进行观察。

2228
01:07:52,040 --> 01:07:53,180
0,240 240,360 360,510 510,780 780,1140
so we can set things

2229
01:07:53,180 --> 01:07:55,880
0,630 630,810 810,1050 1050,1860 1860,2700
like we do watch on

2230
01:07:56,910 --> 01:07:57,980
0,690
i.|
|

2231
01:07:58,360 --> 01:07:59,980
0,480 660,840 840,1080 1080,1440 1440,1620
Alright we haven't declared i,|
好的，我们还没有声明 i ，|

2232
01:07:59,980 --> 01:08:01,300
0,240 240,390 390,480 480,690 690,1320
yet because we're not inside
因为我们不在循环里面，

2233
01:08:02,760 --> 01:08:04,320
0,210 210,420 420,1200 1200,1350 1350,1560
we're not inside the for

2234
01:08:04,320 --> 01:08:06,940
0,720 900,1260 1260,1710 1710,2520
loop.| So we step
|所以我们单步执行 C 代码，

2235
01:08:06,880 --> 01:08:08,560
0,360 360,450 450,660 660,1470 1470,1680
through the C instructions,| now
|现在我们对本地变量查看信息，会看到 i ，

2236
01:08:08,560 --> 01:08:10,540
0,150 150,270 270,720 1380,1890 1890,1980
if we do information for

2237
01:08:10,540 --> 01:08:11,680
0,120 120,690 690,840 840,1020 1020,1140
the locals, we see we

2238
01:08:11,680 --> 01:08:13,030
0,210 210,720 750,990 990,1110 1110,1350
get i,| we can even
|我们甚至可以在 sum 设置观察点。

2239
01:08:13,030 --> 01:08:16,120
0,420 420,420 1890,2190 2190,2670 2670,3090
watch {} watch point on

2240
01:08:16,120 --> 01:08:17,460
0,660
sum.|
|

2241
01:08:17,640 --> 01:08:19,410
0,360 360,690 690,1290 1290,1440 1440,1770
So now anytime that sum
现在任何时候 sum 改变都会收到通知，

2242
01:08:19,410 --> 01:08:22,320
0,900 960,1320 1320,1740 1740,2340 2430,2910
changes will actually get a

2243
01:08:22,320 --> 01:08:24,510
0,930 930,1080 1080,1170 1170,1290 1290,2190
notification,| so we can continue
|我们继续，然后这里有一个删除，

2244
01:08:24,810 --> 01:08:25,800
0,210 210,750
and then

2245
01:08:25,990 --> 01:08:27,160
0,270 270,420 420,510 510,870 870,1170
we'll get a delete here,|
|

2246
01:08:27,160 --> 01:08:29,470
0,450 450,870 870,1200 1200,1470 1470,2310
because some has been moved
因为有东西被删除了，所以我们不能查看它，

2247
01:08:29,530 --> 01:08:30,610
0,210 210,300 300,690 720,870 870,1080
so we can't we can't

2248
01:08:30,610 --> 01:08:32,110
0,330 330,570 570,870 990,1380 1380,1500
actually watch it,| {} we
|我们甚至可以做一些事情，比如在 sum_to 上设置断点，

2249
01:08:32,110 --> 01:08:33,850
0,180 180,420 420,630 630,990 990,1740
can even do things like

2250
01:08:33,880 --> 01:08:36,730
0,240 240,900 900,1710 1920,2520 2520,2850
{} break point on {sum_to

2251
01:08:36,730 --> 01:08:37,390
0,300 300,390 390,510 510,600 600,660
-},| so this is a
|这是一个条件断点，如果 i 现在是 1 ，

2252
01:08:37,390 --> 01:08:40,060
0,480 480,720 720,1320 1650,2520
conditional break point if,

2253
01:08:40,260 --> 01:08:42,000
0,270 270,540 540,810 810,1140 1140,1740
well, let's actually see was

2254
01:08:42,000 --> 01:08:43,650
0,240 240,870 870,1020 1020,1290 1290,1650
i currently, so i currently

2255
01:08:43,650 --> 01:08:45,780
0,540 600,1050 1050,1650 1680,1890 1890,2130
1,| let's say I think
|比如，让循环在 i 是 5 的时候中断，

2256
01:08:45,780 --> 01:08:47,310
0,150 150,480 480,630 630,1200 1200,1530
my loop is breaking and

2257
01:08:47,310 --> 01:08:49,200
0,360 360,570 570,720 720,1410 1500,1890
whenever i is 5,| well
|如果我想专门调试这种情况，

2258
01:08:49,200 --> 01:08:50,250
0,90 90,210 210,420 420,480 480,1050
if I want to specifically

2259
01:08:50,250 --> 01:08:52,050
0,420 420,690 690,1380 1410,1650 1650,1800
debug that case,| I can
|我可以在 sum_to 上设置一个断点，如果 i 等于 5 。

2260
01:08:52,050 --> 01:08:53,500
0,180 180,240 240,540 540,1290
set a break point

2261
01:08:53,580 --> 01:08:58,460
0,1410 2070,2610 2610,3240
on {sum_to -}

2262
01:08:58,550 --> 01:09:02,040
0,810 840,1860 2220,2580 2580,3300
if i equal 5.|
|

2263
01:09:02,850 --> 01:09:04,050
0,240 240,720 720,840 840,1020 1020,1200
So now we have this
现在我们有了这个断点，如果我们继续

2264
01:09:04,050 --> 01:09:05,340
0,300 300,810 840,1080 1080,1170 1170,1290
break point, and if we

2265
01:09:05,340 --> 01:09:07,200
0,510 510,1200 1230,1560 1560,1770 1770,1860
continue along,| we'll get to
|我们得到 sum_to ，可以看到它打印了第一组值，

2266
01:09:07,200 --> 01:09:09,390
0,330 330,930 1110,1890 1920,2040 2040,2190
{sum_to -}, and we can

2267
01:09:09,390 --> 01:09:10,890
0,390 390,660 660,780 780,1110 1110,1500
see that it actually printed

2268
01:09:10,890 --> 01:09:13,260
0,480 600,900 900,1200 1200,1470 1470,2370
out the first couple values|
|

2269
01:09:13,320 --> 01:09:14,490
0,300 300,420 420,540 540,870 870,1170
and so we only break
现在我们只在 i 符合条件时在 sum_to 上中断。

2270
01:09:14,490 --> 01:09:16,470
0,270 270,390 390,690 690,1200 1410,1980
now on {sum_to -} if

2271
01:09:17,480 --> 01:09:18,860
0,330 330,600 600,1050 1050,1170 1170,1380
if i if we hit

2272
01:09:18,860 --> 01:09:20,340
0,180 180,420 420,720 720,1230
that break point condition.|
|

2273
01:09:21,280 --> 01:09:22,270
0,150 150,240 240,510 510,780 780,990
And so that's, {} it
也就是说，如果你要调试代码特定的边界条件，它会很有用，

2274
01:09:22,270 --> 01:09:23,170
0,120 120,360 360,690 690,780 780,900
can be again can be

2275
01:09:23,170 --> 01:09:24,160
0,450 450,570 570,690 690,900 900,990
useful if you want to

2276
01:09:24,160 --> 01:09:25,870
0,450 450,900 900,1470 1470,1590 1590,1710
debug specific {edge,cases} of your

2277
01:09:25,870 --> 01:09:27,580
0,510 600,990 990,1260 1260,1560 1560,1710
code| and watch points can
|观察点可能会很有用，

2278
01:09:27,580 --> 01:09:29,830
0,120 120,870 1290,1500 1500,1650 1650,2250
be useful| if for instance
|如果你认为某些东西不应该改变，但你怀疑它改变了，

2279
01:09:29,830 --> 01:09:30,880
0,150 150,330 330,450 450,780 780,1050
you think that something shouldn't

2280
01:09:30,880 --> 01:09:32,710
0,120 120,930 990,1320 1320,1470 1470,1830
be changing, but you suspect

2281
01:09:32,710 --> 01:09:34,870
0,150 150,240 240,930 960,1920 1950,2160
that it is| or you
|或者你认为每次你改变某个变量都会出问题。

2282
01:09:34,870 --> 01:09:35,800
0,150 150,270 270,570 570,660 660,930
think that something is going

2283
01:09:35,800 --> 01:09:37,570
0,390 390,630 630,1170 1200,1470 1470,1770
wrong every time you change

2284
01:09:37,570 --> 01:09:39,080
0,30 30,360 360,960
a certain variable.|
|

2285
01:09:40,000 --> 01:09:41,170
0,150 150,270 270,600 600,900 900,1170
And so that's that's a
这是它的一种用法。

2286
01:09:41,170 --> 01:09:42,460
0,210 210,540 540,870 870,1170 1170,1290
it's one one usage for

2287
01:09:42,460 --> 01:09:44,950
0,330 1170,1560 1560,1920 1920,2190 2190,2490
that.| And {} the last
|今天，我最后要说的是结构体（struct），

2288
01:09:44,950 --> 01:09:45,580
0,120 120,180 180,330 330,390 390,630
thing I want to talk

2289
01:09:45,580 --> 01:09:48,400
0,450 450,960 960,1260 1260,2010 2280,2820
about today is struct,| {}
|结构体非常重要，它会经常出现在实验里，

2290
01:09:48,400 --> 01:09:50,260
0,450 450,690 690,1380 1410,1710 1710,1860
struct pretty important, they'll come

2291
01:09:50,260 --> 01:09:52,500
0,360 390,990 1320,1980
up in {}

2292
01:09:53,050 --> 01:09:55,690
0,300 300,420 420,900 900,1620 1860,2640
in the labs often| and
|还有。

2293
01:09:56,050 --> 01:09:57,240
0,690
also.|
|

2294
01:09:57,310 --> 01:09:59,230
0,420 420,630 630,1320 1470,1710 1710,1920
So, what as, I'll talk
所以我会简单介绍一下结构体在内存中的布局。

2295
01:09:59,230 --> 01:10:00,310
0,30 30,240 240,390 390,870 930,1080
a little bit about the

2296
01:10:00,310 --> 01:10:01,840
0,330 330,750 750,1110 1110,1350 1350,1530
way structs are laid out

2297
01:10:01,840 --> 01:10:03,180
0,60 60,750
in memory.|
|

2298
01:10:03,750 --> 01:10:04,620
0,180 180,330 330,420 420,780 780,870
And so a structure is
基本上，一个结构体就是一个连续的内存区域，

2299
01:10:04,620 --> 01:10:07,350
0,750 960,1530 1740,1920 1920,2010 2010,2730
basically {} it's a continued

2300
01:10:07,350 --> 01:10:08,730
0,540 540,870 870,960 960,1260 1260,1380
contiguous area of memory,| so
|所以如果我们有一些结构体。

2301
01:10:08,730 --> 01:10:09,810
0,90 90,180 180,270 270,480 480,1080
if we have some structure.|
|

2302
01:10:11,510 --> 01:10:13,490
0,360 360,480 480,870 870,1410 1620,1980
And we have like field
我们有字段一，字段二，字段三。

2303
01:10:13,490 --> 01:10:15,800
0,540 540,900 900,1350 1350,1680 1680,2310
one field two field three.|
|

2304
01:10:17,110 --> 01:10:18,220
0,270 270,390 390,600 600,780 780,1110
When we make that struct|
当我们创建该结构体时，|

2305
01:10:18,220 --> 01:10:19,000
0,210 210,510 510,570 570,690 690,780
those fields are going to
在内存中，这些字段将挨着排在一起。

2306
01:10:19,000 --> 01:10:20,530
0,420 450,750 750,1170 1170,1410 1410,1530
be {align -} next to

2307
01:10:20,530 --> 01:10:21,620
0,180 180,690
each other


2308
01:10:22,230 --> 01:10:23,340
0,150 150,540 540,660 660,900 900,1110
in memory,| you can kind
|你可以把它想象成一个数组，

2309
01:10:23,340 --> 01:10:24,750
0,90 90,270 270,360 360,840 900,1410
of think of this like

2310
01:10:24,750 --> 01:10:26,070
0,90 90,720 720,900 900,1110 1110,1320
an array,| but {f1 -}
|但是 f1 f2 f3 可以是不同的类型。

2311
01:10:26,070 --> 01:10:27,030
0,180 180,360 360,600 600,810 810,960
{f2 -} {f3 -} can

2312
01:10:27,030 --> 01:10:28,380
0,150 150,270 270,570 570,1080
all be different types.|
|

2313
01:10:28,380 --> 01:10:31,830
0,690 900,1620 2070,2400 2400,3030 3060,3450
And, {} we can {}
而且，我们可以把它们传递给函数，

2314
01:10:31,830 --> 01:10:33,180
0,360 360,450 450,570 570,1050 1050,1350
pass them [] functions,| usually
|它们作为参数传递给函数，通常是通过引用，

2315
01:10:33,180 --> 01:10:34,800
0,150 150,930 930,1020 1020,1110 1110,1620
they pass them as arguments

2316
01:10:34,800 --> 01:10:36,720
0,90 90,900 930,1500 1500,1620 1620,1920
to functions, usually they pass

2317
01:10:36,720 --> 01:10:38,700
0,150 150,900 990,1440 1440,1830 1830,1980
by reference,| so here I've
|这里有一个结构体 person ，包含两个整型参数，

2318
01:10:38,700 --> 01:10:40,680
0,180 180,240 240,600 600,1350 1440,1980
made a struct person with

2319
01:10:40,680 --> 01:10:43,620
0,240 240,810 810,1740 1980,2730
two integer arguments,| and
|我传递一个 person 作为参数，

2320
01:10:44,120 --> 01:10:46,010
0,330 330,720 720,1230 1350,1530 1530,1890
I'm passing them, {} passing

2321
01:10:46,010 --> 01:10:47,330
0,60 60,420 420,540 540,630 630,1320
a person as an argument

2322
01:10:47,330 --> 01:10:50,780
0,660 990,1650 1710,2730 2730,3090 3090,3450
person| and printing out some
|并打印出其中的一些信息，

2323
01:10:50,780 --> 01:10:52,580
0,90 90,300 300,930 1380,1680 1680,1800
of that information,| so if
|如果我们进入 gdb ，

2324
01:10:52,580 --> 01:10:54,290
0,90 90,360 360,1050 1050,1170 1170,1710
we hop into {gdb -}|
|

2325
01:10:54,290 --> 01:10:55,250
0,120 120,360 360,630 630,840 840,960
and let's delete all our
让我们删除所有的断点和观察点，

2326
01:10:55,250 --> 01:10:56,780
0,240 240,510 510,630 630,870 870,1530
break points and watch points,|
|

2327
01:10:56,990 --> 01:10:58,040
0,390 390,600 600,720 720,870 870,1050
and now we can set
现在我们在 printPerson 上设置一个断点，

2328
01:10:58,040 --> 01:11:00,980
0,30 30,240 240,630 630,1290 2280,2940
a break point at printPerson,|
|

2329
01:11:01,680 --> 01:11:03,900
0,870 1110,1230 1230,1470 1470,1680 1680,2220
and it's {continue - -}
继续，并运行第七个 demo 。

2330
01:11:04,290 --> 01:11:06,360
0,210 210,750 900,1350 1350,1410 1410,2070
and run {seventh -} demo.|
|

2331
01:11:07,640 --> 01:11:08,540
0,240 240,360 360,570 570,690 690,900
We can see that now
现在可以看到，我们在这里，如果输入 i frame ，

2332
01:11:08,540 --> 01:11:09,320
0,120 120,450 450,570 570,690 690,780
we're here and so if

2333
01:11:09,320 --> 01:11:11,240
0,90 90,420 420,420 420,1380 1620,1920
we type i frame,| we
|我们可以看到，我们有一个参数 p 。

2334
01:11:11,240 --> 01:11:13,460
0,150 150,690 690,1410 1440,1770 1770,2220
can see that we have

2335
01:11:13,460 --> 01:11:15,020
0,180 180,780 780,1380
an argument p.|
|

2336
01:11:15,310 --> 01:11:17,440
0,600 600,1260 1320,1740 1740,1950 1950,2130
And indeed, we can see
事实上，如果我们打印 p ，

2337
01:11:17,440 --> 01:11:19,630
0,150 150,240 240,600 630,1500 1530,2190
if we do print p,|
|

2338
01:11:20,780 --> 01:11:22,010
0,510 510,600 600,750 750,960 960,1230
If we can even tell
甚至能辨别出这个地址是 struct person ，

2339
01:11:22,010 --> 01:11:23,750
0,150 150,300 300,720 720,1410 1500,1740
that it's struct person at

2340
01:11:23,750 --> 01:11:27,470
0,180 180,960 2160,2850 3240,3420 3420,3720
this address| and we can
|我们可以间接引用它，

2341
01:11:27,470 --> 01:11:28,850
0,210 210,300 300,510 510,990 990,1380
if we {dereference -} it,|
|

2342
01:11:30,210 --> 01:11:31,200
0,360 360,510 510,630 630,870 870,990
{gdb -} will tell us
gdb 告诉我们 p 的 id 是 1215 ， age 是 22 。

2343
01:11:31,200 --> 01:11:33,000
0,540 540,870 900,1170 1170,1440 1440,1800
exactly what p looks like

2344
01:11:33,000 --> 01:11:34,960
0,150 150,330 330,630 630,1680
it has id 1215

2345
01:11:35,240 --> 01:11:36,700
0,390 390,690 690,1050
age {22. -}|
|

2346
01:11:37,660 --> 01:11:38,860
0,360 360,540 540,660 660,990 990,1200
And just to show kind
只是展示一下结构提是怎么存放的。

2347
01:11:38,860 --> 01:11:40,960
0,60 60,300 300,720 720,1230 1530,2100
of how things are laid

2348
01:11:40,960 --> 01:11:41,880
0,630
out.|
|

2349
01:11:42,060 --> 01:11:43,800
0,180 180,360 360,660 660,900 900,1740
You can take this address
你可以取这个地址，我们可以在这个地址看到，

2350
01:11:43,800 --> 01:11:46,560
0,210 210,780 1830,2340 2340,2520 2520,2760
and we see at this

2351
01:11:46,560 --> 01:11:51,120
0,960 1500,1680 1680,1860 1860,2460
address,| if we look.
|如果我们看。

2352
01:11:51,870 --> 01:11:55,400
0,900 1770,2400 2400,3240
I remember exactly.|
我记得很清楚。|

2353
01:11:57,380 --> 01:11:58,960
0,540
{Should,be}.|
应该是的。|

2354
01:12:02,180 --> 01:12:03,470
0,240 240,360 360,660 720,1110 1110,1290
So if we again so
如果我们再来一次，可以用这个来调试我们的结构体。

2355
01:12:03,470 --> 01:12:04,400
0,120 120,300 300,540 540,810 810,930
we can use this to

2356
01:12:04,400 --> 01:12:06,960
0,810 840,1260 1260,2460
debug our structures.|
|

2357
01:12:07,900 --> 01:12:10,780
0,450 750,1050 1050,1170 1170,2040 2130,2880
In in the code, we
在代码中，我们可以看一下结构体是怎么回事，

2358
01:12:11,020 --> 01:12:11,770
0,240 240,420 420,480 480,660 660,750
can take a look at

2359
01:12:11,770 --> 01:12:13,300
0,210 210,540 540,1020
what's going on

2360
01:12:13,660 --> 01:12:15,550
0,450 450,1170 1170,1380 1380,1650 1680,1890
with structures this way,| so
|因此 gdb 是非常强大的工具，

2361
01:12:15,550 --> 01:12:17,230
0,120 120,720 810,1320 1320,1410 1410,1680
{gdb -} is a super

2362
01:12:17,230 --> 01:12:19,270
0,450 450,870 870,1110 1110,1470 1470,2040
powerful tool| not just for
|不仅用于单步执行，

2363
01:12:19,420 --> 01:12:21,010
0,630 630,870 870,1170 1170,1290 1290,1590
stepping through code,| but also
|还用于检查代码中各种类型的潜在问题。

2364
01:12:21,010 --> 01:12:24,070
0,210 210,1110 1440,2100 2100,2550 2550,3060
for examining all kinds of

2365
01:12:25,060 --> 01:12:26,890
0,660 660,1260 1260,1620 1620,1710 1710,1830
potentially problematic pieces in your

2366
01:12:26,890 --> 01:12:28,900
0,540 540,900 900,1200 1200,1290 1290,2010
code| and looking at arguments
|而且可以查看参数和栈帧，

2367
01:12:28,900 --> 01:12:30,040
0,120 120,480 480,810 810,900 900,1140
and stack frames and things

2368
01:12:30,040 --> 01:12:31,450
0,150 150,480 810,1140 1140,1260 1260,1410
like that,| and this will
|这在下一个实验中很有用，

2369
01:12:31,450 --> 01:12:33,220
0,330 330,840 840,990 990,1080 1080,1770
be hopefully will be useful

2370
01:12:33,280 --> 01:12:34,740
0,330 330,390 390,690 690,1230
in the next lab,|
|

2371
01:12:35,270 --> 01:12:36,350
0,330 330,510 510,660 660,780 780,1080
when you have to work
当你必须使用栈帧和汇编来编程时。

2372
01:12:36,350 --> 01:12:38,480
0,420 570,1140 1140,1380 1380,1680 1680,2130
with, {} with stack frames

2373
01:12:38,480 --> 01:12:39,900
0,180 180,390 390,810 810,1200
and with assembly code.|
|

2374
01:12:40,080 --> 01:12:42,360
0,780 900,1500 1530,1920 1920,2190 2190,2280
So that's that's mostly what
这就是我今天想讲的主要内容。

2375
01:12:42,360 --> 01:12:43,170
0,60 60,300 300,390 390,600 600,810
I wanted to talk about

2376
01:12:43,170 --> 01:12:44,460
0,300 300,780 780,1050 1050,1170 1170,1290
today.| So, {} with the
|最后还有 7 分钟，

2377
01:12:44,460 --> 01:12:47,040
0,330 330,540 540,840 1530,2010 2010,2580
last kind of seven minutes

2378
01:12:47,040 --> 01:12:48,840
0,390 390,870 870,1440 1440,1710 1710,1800
of lecture,| I'll open it
|你们可以提任何问题。

2379
01:12:48,840 --> 01:12:50,610
0,180 180,690 960,1380 1380,1560 1560,1770
up to any any other

2380
01:12:50,610 --> 01:12:52,060
0,540 540,690 690,870 870,1260
questions you guys have.|
|

2381
01:12:59,510 --> 01:12:59,990
0,150 150,240 240,300 300,390 390,480
I had a bit of
我有一个离题的问题，

2382
01:12:59,990 --> 01:13:03,050
0,90 90,690 690,1260 1890,2700 2760,3060
a tangential question,| who is
|谁管理从 C 到各种指令集架构

2383
01:13:03,050 --> 01:13:05,150
0,420 420,960 960,1380 1440,1980 1980,2100
who manages the creation of

2384
01:13:05,150 --> 01:13:07,250
0,720 720,1200 1380,1530 1530,1860 1860,2100
compilers| from to get from
|的编译器的创建，

2385
01:13:07,250 --> 01:13:09,200
0,390 390,540 540,1140 1230,1530 1530,1950
C to various {} instruction

2386
01:13:09,200 --> 01:13:10,460
0,240 240,900 900,960 960,1140 1140,1260
set architectures,| is that the
|是指令集架构的创建者，或是类似的但三方机构。

2387
01:13:10,460 --> 01:13:11,900
0,630 630,810 810,900 900,1260 1260,1440
creator of the instruction set

2388
01:13:11,900 --> 01:13:13,460
0,600 600,690 690,840 840,1140 1140,1560
architecture, is the third parties

2389
01:13:13,460 --> 01:13:14,320
0,300 300,540
like that.|
|

2390
01:13:14,500 --> 01:13:17,620
0,780 1170,1350 1350,2340 2340,2910 2910,3120
Um, I believe that it
我想不是指令集的创建者，

2391
01:13:17,620 --> 01:13:19,090
0,480 480,840 840,930 930,1380 1380,1470
is not the creative the

2392
01:13:19,090 --> 01:13:20,740
0,540 540,870 870,1200 1200,1350 1350,1650
instruction set,| so it's often
|通常是第三方，

2393
01:13:20,740 --> 01:13:22,540
0,60 60,360 360,960 1320,1680 1680,1800
a third party,| {} so
|你们知道的的两个大的 C 编译器，

2394
01:13:22,540 --> 01:13:23,950
0,120 120,360 360,600 600,810 810,1410
the two big C compilers

2395
01:13:23,950 --> 01:13:25,120
0,120 120,300 300,480 480,840 840,1170
that you'll see| refer to
|GCC 是由 GNU 基金会维护的，

2396
01:13:25,120 --> 01:13:27,550
0,900 1080,1410 1410,1530 1530,2190 2190,2430
GCC which is maintained by

2397
01:13:27,550 --> 01:13:28,600
0,150 150,420 420,570 570,870 870,1050
I think the {GNU -}

2398
01:13:28,600 --> 01:13:32,260
0,930 1350,2040 2040,2760 2790,3120 3120,3660
foundation| and {} {Clang -}
|Clang llvm 是自己维护的，

2399
01:13:32,260 --> 01:13:34,630
0,900 1050,1530 1530,1920 1920,2130 2130,2370
llvm, which is its own

2400
01:13:34,630 --> 01:13:36,220
0,360 360,720 720,840 840,1170 1320,1590
thing,| so I think you
|你可以发现， llvm 甚至是开源的，

2401
01:13:36,220 --> 01:13:37,540
0,60 60,240 240,390 390,1020 1170,1320
know you can find I

2402
01:13:37,540 --> 01:13:39,070
0,360 360,960 960,1050 1050,1260 1260,1530
believe llvm is even open

2403
01:13:39,070 --> 01:13:40,720
0,450 450,660 660,870 870,1020 1020,1650
source,| so you can find.
|这样你就能找到，专门做这件事的代码。

2404
01:13:40,840 --> 01:13:41,840
0,690

2405
01:13:42,060 --> 01:13:42,870
0,180 180,300 300,480 480,570 570,810
you can, you can find

2406
01:13:42,870 --> 01:13:44,040
0,60 60,360 360,810 810,930 930,1170
the code specifically that does

2407
01:13:44,040 --> 01:13:45,570
0,390 510,870 870,1230 1230,1350 1350,1530
this,| {} when a new
|当一个像 RISC-V 的新指令集发布时，

2408
01:13:45,570 --> 01:13:47,730
0,630 630,1050 1050,1290 1290,1980 1980,2160
instruction set is released such

2409
01:13:47,730 --> 01:13:49,620
0,150 150,390 390,900 990,1470 1470,1890
as {RISC-V -},| that calling
|调用约定文档以及所有这些指令文档一起发布，

2410
01:13:49,620 --> 01:13:51,120
0,510 510,1020 1020,1170 1170,1380 1380,1500
convention document as well as

2411
01:13:51,120 --> 01:13:53,040
0,240 240,330 330,720 720,1230 1230,1920
all of those instruction documents,|
|

2412
01:13:53,280 --> 01:13:54,750
0,510 510,510 510,990 990,1350 1350,1470
{} I think carefully I
我猜，

2413
01:13:54,750 --> 01:13:55,920
0,300 300,480 480,630 630,840 840,1170
assume| there's a high level
|可能编译器设计者和指令集设计者之间有高级别的合作。

2414
01:13:55,920 --> 01:13:57,780
0,90 90,930 930,1290 1290,1380 1380,1860
of cooperation between the compiler

2415
01:13:57,780 --> 01:13:59,220
0,540 540,630 630,720 720,1230 1230,1440
designer and the instruction set

2416
01:13:59,220 --> 01:14:01,100
0,660 1020,1620
designer {}.|
|

2417
01:14:01,550 --> 01:14:03,110
0,270 270,840 840,840 1050,1350 1350,1560
But yeah a short answer
但简单来说，我相信是第三方维护的，

2418
01:14:03,110 --> 01:14:04,070
0,90 90,420 420,750 750,870 870,960
is I believe it's a

2419
01:14:04,070 --> 01:14:06,080
0,1140 1140,1290 1290,1500 1500,1650 1650,2010
{third,party} who does it,| likely
|很可能与指令集制作人员的大量合作。

2420
01:14:06,080 --> 01:14:08,150
0,480 720,1080 1080,1290 1290,1380 1380,2070
with a lot of cooperation

2421
01:14:08,150 --> 01:14:08,960
0,150 150,270 270,540 540,600 600,810
from the people who make

2422
01:14:08,960 --> 01:14:10,520
0,60 60,510 510,750 810,1200 1200,1560
the instruction set.| {RISC-V -}
|RISC-V 可能是一个例外，因为它来自一个研究项目，

2423
01:14:10,520 --> 01:14:11,580
0,120 120,810
is probably,

2424
01:14:12,030 --> 01:14:12,840
0,210 210,480 480,660 660,750 750,810
{RISC-V -} might be an

2425
01:14:12,840 --> 01:14:14,880
0,930 1020,1410 1410,1710 1710,1800 1800,2040
exception where because it came

2426
01:14:14,880 --> 01:14:16,320
0,90 90,150 150,300 300,720 720,1440
out of a research project,|
|

2427
01:14:16,440 --> 01:14:18,000
0,390 390,600 600,810 810,1140 1140,1560
they may have written the
他们可能也自己编写了编译器。

2428
01:14:18,060 --> 01:14:19,980
0,570 570,840 840,930 930,1830
compiler for it themselves,

2429
01:14:20,050 --> 01:14:20,980
0,180 180,360 360,720
{} as well.|
|

2430
01:14:21,410 --> 01:14:22,760
0,270 270,420 420,690 690,960 960,1350
I I don't think Intel
我不认为英特尔在 GCC 或 llvm 上有所投入。

2431
01:14:22,760 --> 01:14:24,560
0,540 570,780 780,1140 1140,1350 1350,1800
has for example has input

2432
01:14:24,590 --> 01:14:25,480
0,270 270,660
in {}

2433
01:14:25,850 --> 01:14:27,780
0,210 210,900 900,1080 1080,1740
in GCC or llvm.|
|

2434
01:14:45,530 --> 01:14:46,840
0,300 300,960
Other questions?|
还有其他问题吗？|

2435
01:14:54,650 --> 01:14:58,790
0,840 1200,2340 2520,3090 3090,3780 3780,4140
Okay, well, thanks for listening,|
好的，感谢收听，|

2436
01:14:58,790 --> 01:14:59,960
0,90 90,300 300,630 630,840 840,1170
in that case I guess
那样的话，我想我们可以。

2437
01:14:59,960 --> 01:15:01,180
0,150 150,930
we can.|
|

2438
01:15:01,790 --> 01:15:03,260
0,180 180,870 870,1080 1080,1140 1140,1470
You can end the lecture
你可以在这里结束，

2439
01:15:03,260 --> 01:15:05,330
0,480 540,1080 1320,1770 1770,1980 1980,2070
here,| a five minutes to
|还有 5 分钟，好好休息一下。

2440
01:15:05,330 --> 01:15:07,340
0,360 360,750 1050,1500 1500,1740 1740,2010
spare, so have a nice

2441
01:15:07,340 --> 01:15:07,580
0,180
rest.
